#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimatedTransformList
.
h
"
#
include
"
mozilla
/
dom
/
SVGGraphicsElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGTransformableElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGMatrix
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsSVGDisplayableFrame
.
h
"
#
include
"
mozilla
/
dom
/
SVGRect
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
SVGContentUtils
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
already_AddRefed
<
SVGAnimatedTransformList
>
SVGTransformableElement
:
:
Transform
(
)
{
return
SVGAnimatedTransformList
:
:
GetDOMWrapper
(
GetAnimatedTransformList
(
DO_ALLOCATE
)
this
)
;
}
NS_IMETHODIMP_
(
bool
)
SVGTransformableElement
:
:
IsAttributeMapped
(
const
nsAtom
*
name
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sColorMap
sFillStrokeMap
sGraphicsMap
}
;
return
FindAttributeDependence
(
name
map
)
|
|
nsSVGElement
:
:
IsAttributeMapped
(
name
)
;
}
nsChangeHint
SVGTransformableElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
nsSVGElement
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
|
|
aAttribute
=
=
nsGkAtoms
:
:
mozAnimateMotionDummyAttr
)
{
nsIFrame
*
frame
=
const_cast
<
SVGTransformableElement
*
>
(
this
)
-
>
GetPrimaryFrame
(
)
;
retval
|
=
nsChangeHint_InvalidateRenderingObservers
;
if
(
!
frame
|
|
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
{
return
retval
;
}
bool
isAdditionOrRemoval
=
false
;
if
(
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
|
|
aModType
=
=
MutationEvent_Binding
:
:
REMOVAL
)
{
isAdditionOrRemoval
=
true
;
}
else
{
MOZ_ASSERT
(
aModType
=
=
MutationEvent_Binding
:
:
MODIFICATION
"
Unknown
modification
type
.
"
)
;
if
(
!
mTransforms
|
|
!
mTransforms
-
>
HasTransform
(
)
)
{
isAdditionOrRemoval
=
true
;
}
else
if
(
mTransforms
-
>
RequiresFrameReconstruction
(
)
)
{
isAdditionOrRemoval
=
true
;
}
}
if
(
isAdditionOrRemoval
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
{
retval
|
=
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateTransformLayer
;
}
}
return
retval
;
}
bool
SVGTransformableElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
EventNameType_SVGGraphic
)
;
}
gfxMatrix
SVGTransformableElement
:
:
PrependLocalTransformsTo
(
const
gfxMatrix
&
aMatrix
SVGTransformTypes
aWhich
)
const
{
if
(
aWhich
=
=
eChildToUserSpace
)
{
return
aMatrix
;
}
return
GetUserToParentTransform
(
mAnimateMotionTransform
mTransforms
)
*
aMatrix
;
}
const
gfx
:
:
Matrix
*
SVGTransformableElement
:
:
GetAnimateMotionTransform
(
)
const
{
return
mAnimateMotionTransform
.
get
(
)
;
}
void
SVGTransformableElement
:
:
SetAnimateMotionTransform
(
const
gfx
:
:
Matrix
*
aMatrix
)
{
if
(
(
!
aMatrix
&
&
!
mAnimateMotionTransform
)
|
|
(
aMatrix
&
&
mAnimateMotionTransform
&
&
aMatrix
-
>
FuzzyEquals
(
*
mAnimateMotionTransform
)
)
)
{
return
;
}
bool
transformSet
=
mTransforms
&
&
mTransforms
-
>
IsExplicitlySet
(
)
;
bool
prevSet
=
mAnimateMotionTransform
|
|
transformSet
;
mAnimateMotionTransform
=
aMatrix
?
new
gfx
:
:
Matrix
(
*
aMatrix
)
:
nullptr
;
bool
nowSet
=
mAnimateMotionTransform
|
|
transformSet
;
int32_t
modType
;
if
(
prevSet
&
&
!
nowSet
)
{
modType
=
MutationEvent_Binding
:
:
REMOVAL
;
}
else
if
(
!
prevSet
&
&
nowSet
)
{
modType
=
MutationEvent_Binding
:
:
ADDITION
;
}
else
{
modType
=
MutationEvent_Binding
:
:
MODIFICATION
;
}
DidAnimateTransformList
(
modType
)
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
-
>
SchedulePaint
(
)
;
}
}
nsSVGAnimatedTransformList
*
SVGTransformableElement
:
:
GetAnimatedTransformList
(
uint32_t
aFlags
)
{
if
(
!
mTransforms
&
&
(
aFlags
&
DO_ALLOCATE
)
)
{
mTransforms
=
new
nsSVGAnimatedTransformList
(
)
;
}
return
mTransforms
;
}
nsSVGElement
*
SVGTransformableElement
:
:
GetNearestViewportElement
(
)
{
return
SVGContentUtils
:
:
GetNearestViewportElement
(
this
)
;
}
nsSVGElement
*
SVGTransformableElement
:
:
GetFarthestViewportElement
(
)
{
return
SVGContentUtils
:
:
GetOuterSVGElement
(
this
)
;
}
already_AddRefed
<
SVGIRect
>
SVGTransformableElement
:
:
GetBBox
(
const
SVGBoundingBoxOptions
&
aOptions
ErrorResult
&
rv
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Layout
)
;
if
(
!
frame
|
|
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsSVGDisplayableFrame
*
svgframe
=
do_QueryFrame
(
frame
)
;
if
(
!
svgframe
)
{
rv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
if
(
!
NS_SVGNewGetBBoxEnabled
(
)
)
{
return
NS_NewSVGRect
(
this
ToRect
(
nsSVGUtils
:
:
GetBBox
(
frame
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
|
nsSVGUtils
:
:
eUseUserSpaceOfUseElement
)
)
)
;
}
else
{
uint32_t
flags
=
0
;
if
(
aOptions
.
mFill
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeFill
;
}
if
(
aOptions
.
mStroke
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeStroke
;
}
if
(
aOptions
.
mMarkers
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeMarkers
;
}
if
(
aOptions
.
mClipped
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeClipped
;
}
if
(
flags
=
=
0
)
{
return
NS_NewSVGRect
(
this
0
0
0
0
)
;
}
if
(
flags
=
=
nsSVGUtils
:
:
eBBoxIncludeMarkers
|
|
flags
=
=
nsSVGUtils
:
:
eBBoxIncludeClipped
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeFill
;
}
flags
|
=
nsSVGUtils
:
:
eUseUserSpaceOfUseElement
;
return
NS_NewSVGRect
(
this
ToRect
(
nsSVGUtils
:
:
GetBBox
(
frame
flags
)
)
)
;
}
}
already_AddRefed
<
SVGMatrix
>
SVGTransformableElement
:
:
GetCTM
(
)
{
nsIDocument
*
currentDoc
=
GetComposedDoc
(
)
;
if
(
currentDoc
)
{
currentDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
gfx
:
:
Matrix
m
=
SVGContentUtils
:
:
GetCTM
(
this
false
)
;
RefPtr
<
SVGMatrix
>
mat
=
m
.
IsSingular
(
)
?
nullptr
:
new
SVGMatrix
(
ThebesMatrix
(
m
)
)
;
return
mat
.
forget
(
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGTransformableElement
:
:
GetScreenCTM
(
)
{
nsIDocument
*
currentDoc
=
GetComposedDoc
(
)
;
if
(
currentDoc
)
{
currentDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
gfx
:
:
Matrix
m
=
SVGContentUtils
:
:
GetCTM
(
this
true
)
;
RefPtr
<
SVGMatrix
>
mat
=
m
.
IsSingular
(
)
?
nullptr
:
new
SVGMatrix
(
ThebesMatrix
(
m
)
)
;
return
mat
.
forget
(
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGTransformableElement
:
:
GetTransformToElement
(
SVGGraphicsElement
&
aElement
ErrorResult
&
rv
)
{
RefPtr
<
SVGMatrix
>
ourScreenCTM
=
GetScreenCTM
(
)
;
RefPtr
<
SVGMatrix
>
targetScreenCTM
=
aElement
.
GetScreenCTM
(
)
;
if
(
!
ourScreenCTM
|
|
!
targetScreenCTM
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
RefPtr
<
SVGMatrix
>
tmp
=
targetScreenCTM
-
>
Inverse
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
nullptr
;
RefPtr
<
SVGMatrix
>
mat
=
tmp
-
>
Multiply
(
*
ourScreenCTM
)
;
return
mat
.
forget
(
)
;
}
gfxMatrix
SVGTransformableElement
:
:
GetUserToParentTransform
(
const
gfx
:
:
Matrix
*
aAnimateMotionTransform
const
nsSVGAnimatedTransformList
*
aTransforms
)
{
gfxMatrix
result
;
if
(
aAnimateMotionTransform
)
{
result
.
PreMultiply
(
ThebesMatrix
(
*
aAnimateMotionTransform
)
)
;
}
if
(
aTransforms
)
{
result
.
PreMultiply
(
aTransforms
-
>
GetAnimValue
(
)
.
GetConsolidationMatrix
(
)
)
;
}
return
result
;
}
}
}
