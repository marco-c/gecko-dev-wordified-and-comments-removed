#
include
"
SVGTransformableElement
.
h
"
#
include
"
DOMSVGAnimatedTransformList
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrame
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
:
:
dom
{
already_AddRefed
<
DOMSVGAnimatedTransformList
>
SVGTransformableElement
:
:
Transform
(
)
{
return
DOMSVGAnimatedTransformList
:
:
GetDOMWrapper
(
GetAnimatedTransformList
(
DO_ALLOCATE
)
this
)
;
}
bool
SVGTransformableElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
return
aAttribute
=
=
nsGkAtoms
:
:
transform
|
|
SVGElement
:
:
IsAttributeMapped
(
aAttribute
)
;
}
nsChangeHint
SVGTransformableElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
SVGElement
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
|
|
aAttribute
=
=
nsGkAtoms
:
:
mozAnimateMotionDummyAttr
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
retval
|
=
nsChangeHint_InvalidateRenderingObservers
;
if
(
!
frame
|
|
frame
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
return
retval
;
}
bool
isAdditionOrRemoval
=
false
;
if
(
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
|
|
aModType
=
=
MutationEvent_Binding
:
:
REMOVAL
)
{
isAdditionOrRemoval
=
true
;
}
else
{
MOZ_ASSERT
(
aModType
=
=
MutationEvent_Binding
:
:
MODIFICATION
"
Unknown
modification
type
.
"
)
;
if
(
!
mTransforms
|
|
!
mTransforms
-
>
HasTransform
(
)
)
{
isAdditionOrRemoval
=
true
;
}
else
if
(
mTransforms
-
>
CreatedOrRemovedOnLastChange
(
)
)
{
isAdditionOrRemoval
=
true
;
}
}
if
(
isAdditionOrRemoval
)
{
retval
|
=
nsChangeHint_ComprehensiveAddOrRemoveTransform
;
}
else
{
retval
|
=
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateTransformLayer
;
}
}
return
retval
;
}
bool
SVGTransformableElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
EventNameType_SVGGraphic
)
;
}
gfxMatrix
SVGTransformableElement
:
:
PrependLocalTransformsTo
(
const
gfxMatrix
&
aMatrix
SVGTransformTypes
aWhich
)
const
{
return
aMatrix
;
}
const
gfx
:
:
Matrix
*
SVGTransformableElement
:
:
GetAnimateMotionTransform
(
)
const
{
return
mAnimateMotionTransform
.
get
(
)
;
}
void
SVGTransformableElement
:
:
SetAnimateMotionTransform
(
const
gfx
:
:
Matrix
*
aMatrix
)
{
if
(
(
!
aMatrix
&
&
!
mAnimateMotionTransform
)
|
|
(
aMatrix
&
&
mAnimateMotionTransform
&
&
aMatrix
-
>
FuzzyEquals
(
*
mAnimateMotionTransform
)
)
)
{
return
;
}
bool
transformSet
=
mTransforms
&
&
mTransforms
-
>
IsExplicitlySet
(
)
;
bool
prevSet
=
mAnimateMotionTransform
|
|
transformSet
;
mAnimateMotionTransform
=
aMatrix
?
MakeUnique
<
gfx
:
:
Matrix
>
(
*
aMatrix
)
:
nullptr
;
bool
nowSet
=
mAnimateMotionTransform
|
|
transformSet
;
int32_t
modType
;
if
(
prevSet
&
&
!
nowSet
)
{
modType
=
MutationEvent_Binding
:
:
REMOVAL
;
}
else
if
(
!
prevSet
&
&
nowSet
)
{
modType
=
MutationEvent_Binding
:
:
ADDITION
;
}
else
{
modType
=
MutationEvent_Binding
:
:
MODIFICATION
;
}
DidAnimateTransformList
(
modType
)
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
-
>
SchedulePaint
(
)
;
}
}
SVGAnimatedTransformList
*
SVGTransformableElement
:
:
GetAnimatedTransformList
(
uint32_t
aFlags
)
{
if
(
!
mTransforms
&
&
(
aFlags
&
DO_ALLOCATE
)
)
{
mTransforms
=
MakeUnique
<
SVGAnimatedTransformList
>
(
)
;
}
return
mTransforms
.
get
(
)
;
}
}
