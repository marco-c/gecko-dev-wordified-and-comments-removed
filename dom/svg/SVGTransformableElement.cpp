#
include
"
SVGTransformableElement
.
h
"
#
include
"
DOMSVGAnimatedTransformList
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGGraphicsElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGMatrix
.
h
"
#
include
"
mozilla
/
dom
/
SVGRect
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
SVGTextFrame
.
h
"
#
include
"
SVGContentUtils
.
h
"
#
include
"
nsSVGDisplayableFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
already_AddRefed
<
DOMSVGAnimatedTransformList
>
SVGTransformableElement
:
:
Transform
(
)
{
return
DOMSVGAnimatedTransformList
:
:
GetDOMWrapper
(
GetAnimatedTransformList
(
DO_ALLOCATE
)
this
)
;
}
NS_IMETHODIMP_
(
bool
)
SVGTransformableElement
:
:
IsAttributeMapped
(
const
nsAtom
*
name
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sColorMap
sFillStrokeMap
sGraphicsMap
}
;
return
FindAttributeDependence
(
name
map
)
|
|
SVGElement
:
:
IsAttributeMapped
(
name
)
;
}
nsChangeHint
SVGTransformableElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
SVGElement
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
|
|
aAttribute
=
=
nsGkAtoms
:
:
mozAnimateMotionDummyAttr
)
{
nsIFrame
*
frame
=
const_cast
<
SVGTransformableElement
*
>
(
this
)
-
>
GetPrimaryFrame
(
)
;
retval
|
=
nsChangeHint_InvalidateRenderingObservers
;
if
(
!
frame
|
|
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
{
return
retval
;
}
bool
isAdditionOrRemoval
=
false
;
if
(
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
|
|
aModType
=
=
MutationEvent_Binding
:
:
REMOVAL
)
{
isAdditionOrRemoval
=
true
;
}
else
{
MOZ_ASSERT
(
aModType
=
=
MutationEvent_Binding
:
:
MODIFICATION
"
Unknown
modification
type
.
"
)
;
if
(
!
mTransforms
|
|
!
mTransforms
-
>
HasTransform
(
)
)
{
isAdditionOrRemoval
=
true
;
}
else
if
(
mTransforms
-
>
RequiresFrameReconstruction
(
)
)
{
isAdditionOrRemoval
=
true
;
}
}
if
(
isAdditionOrRemoval
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
{
retval
|
=
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateTransformLayer
;
}
}
return
retval
;
}
bool
SVGTransformableElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
EventNameType_SVGGraphic
)
;
}
gfxMatrix
SVGTransformableElement
:
:
PrependLocalTransformsTo
(
const
gfxMatrix
&
aMatrix
SVGTransformTypes
aWhich
)
const
{
if
(
aWhich
=
=
eChildToUserSpace
)
{
return
aMatrix
;
}
return
GetUserToParentTransform
(
mAnimateMotionTransform
mTransforms
)
*
aMatrix
;
}
const
gfx
:
:
Matrix
*
SVGTransformableElement
:
:
GetAnimateMotionTransform
(
)
const
{
return
mAnimateMotionTransform
.
get
(
)
;
}
void
SVGTransformableElement
:
:
SetAnimateMotionTransform
(
const
gfx
:
:
Matrix
*
aMatrix
)
{
if
(
(
!
aMatrix
&
&
!
mAnimateMotionTransform
)
|
|
(
aMatrix
&
&
mAnimateMotionTransform
&
&
aMatrix
-
>
FuzzyEquals
(
*
mAnimateMotionTransform
)
)
)
{
return
;
}
bool
transformSet
=
mTransforms
&
&
mTransforms
-
>
IsExplicitlySet
(
)
;
bool
prevSet
=
mAnimateMotionTransform
|
|
transformSet
;
mAnimateMotionTransform
=
aMatrix
?
new
gfx
:
:
Matrix
(
*
aMatrix
)
:
nullptr
;
bool
nowSet
=
mAnimateMotionTransform
|
|
transformSet
;
int32_t
modType
;
if
(
prevSet
&
&
!
nowSet
)
{
modType
=
MutationEvent_Binding
:
:
REMOVAL
;
}
else
if
(
!
prevSet
&
&
nowSet
)
{
modType
=
MutationEvent_Binding
:
:
ADDITION
;
}
else
{
modType
=
MutationEvent_Binding
:
:
MODIFICATION
;
}
DidAnimateTransformList
(
modType
)
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
-
>
SchedulePaint
(
)
;
}
}
SVGAnimatedTransformList
*
SVGTransformableElement
:
:
GetAnimatedTransformList
(
uint32_t
aFlags
)
{
if
(
!
mTransforms
&
&
(
aFlags
&
DO_ALLOCATE
)
)
{
mTransforms
=
new
SVGAnimatedTransformList
(
)
;
}
return
mTransforms
;
}
SVGElement
*
SVGTransformableElement
:
:
GetNearestViewportElement
(
)
{
return
SVGContentUtils
:
:
GetNearestViewportElement
(
this
)
;
}
SVGElement
*
SVGTransformableElement
:
:
GetFarthestViewportElement
(
)
{
return
SVGContentUtils
:
:
GetOuterSVGElement
(
this
)
;
}
already_AddRefed
<
SVGRect
>
SVGTransformableElement
:
:
GetBBox
(
const
SVGBoundingBoxOptions
&
aOptions
ErrorResult
&
rv
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Layout
)
;
if
(
!
frame
|
|
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsSVGDisplayableFrame
*
svgframe
=
do_QueryFrame
(
frame
)
;
if
(
!
svgframe
)
{
if
(
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
frame
)
)
{
rv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
SVGTextFrame
*
text
=
static_cast
<
SVGTextFrame
*
>
(
nsLayoutUtils
:
:
GetClosestFrameOfType
(
frame
-
>
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
)
;
if
(
text
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
gfxRect
rec
=
text
-
>
TransformFrameRectFromTextChild
(
frame
-
>
GetRectRelativeToSelf
(
)
frame
)
;
rec
.
x
+
=
float
(
text
-
>
GetPosition
(
)
.
x
)
/
AppUnitsPerCSSPixel
(
)
;
rec
.
y
+
=
float
(
text
-
>
GetPosition
(
)
.
y
)
/
AppUnitsPerCSSPixel
(
)
;
return
do_AddRef
(
new
SVGRect
(
this
ToRect
(
rec
)
)
)
;
}
if
(
!
NS_SVGNewGetBBoxEnabled
(
)
)
{
return
do_AddRef
(
new
SVGRect
(
this
ToRect
(
nsSVGUtils
:
:
GetBBox
(
frame
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
|
nsSVGUtils
:
:
eUseUserSpaceOfUseElement
)
)
)
)
;
}
uint32_t
flags
=
0
;
if
(
aOptions
.
mFill
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeFill
;
}
if
(
aOptions
.
mStroke
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeStroke
;
}
if
(
aOptions
.
mMarkers
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeMarkers
;
}
if
(
aOptions
.
mClipped
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeClipped
;
}
if
(
flags
=
=
0
)
{
return
do_AddRef
(
new
SVGRect
(
this
gfx
:
:
Rect
(
)
)
)
;
}
if
(
flags
=
=
nsSVGUtils
:
:
eBBoxIncludeMarkers
|
|
flags
=
=
nsSVGUtils
:
:
eBBoxIncludeClipped
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeFill
;
}
flags
|
=
nsSVGUtils
:
:
eUseUserSpaceOfUseElement
;
return
do_AddRef
(
new
SVGRect
(
this
ToRect
(
nsSVGUtils
:
:
GetBBox
(
frame
flags
)
)
)
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGTransformableElement
:
:
GetCTM
(
)
{
Document
*
currentDoc
=
GetComposedDoc
(
)
;
if
(
currentDoc
)
{
currentDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
gfx
:
:
Matrix
m
=
SVGContentUtils
:
:
GetCTM
(
this
false
)
;
RefPtr
<
SVGMatrix
>
mat
=
m
.
IsSingular
(
)
?
nullptr
:
new
SVGMatrix
(
ThebesMatrix
(
m
)
)
;
return
mat
.
forget
(
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGTransformableElement
:
:
GetScreenCTM
(
)
{
Document
*
currentDoc
=
GetComposedDoc
(
)
;
if
(
currentDoc
)
{
currentDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
gfx
:
:
Matrix
m
=
SVGContentUtils
:
:
GetCTM
(
this
true
)
;
RefPtr
<
SVGMatrix
>
mat
=
m
.
IsSingular
(
)
?
nullptr
:
new
SVGMatrix
(
ThebesMatrix
(
m
)
)
;
return
mat
.
forget
(
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGTransformableElement
:
:
GetTransformToElement
(
SVGGraphicsElement
&
aElement
ErrorResult
&
rv
)
{
RefPtr
<
SVGMatrix
>
ourScreenCTM
=
GetScreenCTM
(
)
;
RefPtr
<
SVGMatrix
>
targetScreenCTM
=
aElement
.
GetScreenCTM
(
)
;
if
(
!
ourScreenCTM
|
|
!
targetScreenCTM
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
RefPtr
<
SVGMatrix
>
tmp
=
targetScreenCTM
-
>
Inverse
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
nullptr
;
RefPtr
<
SVGMatrix
>
mat
=
tmp
-
>
Multiply
(
*
ourScreenCTM
)
;
return
mat
.
forget
(
)
;
}
gfxMatrix
SVGTransformableElement
:
:
GetUserToParentTransform
(
const
gfx
:
:
Matrix
*
aAnimateMotionTransform
const
SVGAnimatedTransformList
*
aTransforms
)
{
gfxMatrix
result
;
if
(
aAnimateMotionTransform
)
{
result
.
PreMultiply
(
ThebesMatrix
(
*
aAnimateMotionTransform
)
)
;
}
if
(
aTransforms
)
{
result
.
PreMultiply
(
aTransforms
-
>
GetAnimValue
(
)
.
GetConsolidationMatrix
(
)
)
;
}
return
result
;
}
}
}
