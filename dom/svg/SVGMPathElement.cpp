#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGMPathElement
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimateMotionElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGPathElement
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGMPathElementBinding
.
h
"
#
include
"
nsIURI
.
h
"
NS_IMPL_NS_NEW_NAMESPACED_SVG_ELEMENT
(
MPath
)
namespace
mozilla
{
namespace
dom
{
JSObject
*
SVGMPathElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGMPathElementBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsSVGElement
:
:
StringInfo
SVGMPathElement
:
:
sStringInfo
[
2
]
=
{
{
&
nsGkAtoms
:
:
href
kNameSpaceID_None
false
}
{
&
nsGkAtoms
:
:
href
kNameSpaceID_XLink
false
}
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SVGMPathElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
SVGMPathElement
SVGMPathElementBase
)
tmp
-
>
UnlinkHrefTarget
(
false
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
SVGMPathElement
SVGMPathElementBase
)
tmp
-
>
mPathTracker
.
Traverse
(
&
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
SVGMPathElement
SVGMPathElementBase
nsIDOMNode
nsIMutationObserver
)
SVGMPathElement
:
:
SVGMPathElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
SVGMPathElementBase
(
aNodeInfo
)
mPathTracker
(
this
)
{
}
SVGMPathElement
:
:
~
SVGMPathElement
(
)
{
UnlinkHrefTarget
(
false
)
;
}
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGMPathElement
)
already_AddRefed
<
SVGAnimatedString
>
SVGMPathElement
:
:
Href
(
)
{
return
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
?
mStringAttributes
[
HREF
]
.
ToDOMAnimatedString
(
this
)
:
mStringAttributes
[
XLINK_HREF
]
.
ToDOMAnimatedString
(
this
)
;
}
nsresult
SVGMPathElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
bool
aCompileEventHandlers
)
{
MOZ_ASSERT
(
!
mPathTracker
.
get
(
)
"
Shouldn
'
t
have
href
-
target
yet
(
or
it
should
'
ve
been
cleared
)
"
)
;
nsresult
rv
=
SVGMPathElementBase
:
:
BindToTree
(
aDocument
aParent
aBindingParent
aCompileEventHandlers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDocument
)
{
const
nsAttrValue
*
hrefAttrValue
=
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
)
?
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
href
kNameSpaceID_None
)
:
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
href
kNameSpaceID_XLink
)
;
if
(
hrefAttrValue
)
{
UpdateHrefTarget
(
aParent
hrefAttrValue
-
>
GetStringValue
(
)
)
;
}
}
return
NS_OK
;
}
void
SVGMPathElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
UnlinkHrefTarget
(
true
)
;
SVGMPathElementBase
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
}
bool
SVGMPathElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
bool
returnVal
=
SVGMPathElementBase
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
if
(
(
aNamespaceID
=
=
kNameSpaceID_XLink
|
|
aNamespaceID
=
=
kNameSpaceID_None
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
href
&
&
IsInUncomposedDoc
(
)
)
{
if
(
aNamespaceID
!
=
kNameSpaceID_XLink
|
|
!
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
)
{
UpdateHrefTarget
(
GetParent
(
)
aValue
)
;
}
}
return
returnVal
;
}
nsresult
SVGMPathElement
:
:
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
!
aValue
&
&
aName
=
=
nsGkAtoms
:
:
href
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
UnlinkHrefTarget
(
true
)
;
const
nsAttrValue
*
xlinkHref
=
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
href
kNameSpaceID_XLink
)
;
if
(
xlinkHref
)
{
UpdateHrefTarget
(
GetParent
(
)
xlinkHref
-
>
GetStringValue
(
)
)
;
}
}
else
if
(
aNamespaceID
=
=
kNameSpaceID_XLink
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
)
)
{
UnlinkHrefTarget
(
true
)
;
}
}
return
SVGMPathElementBase
:
:
AfterSetAttr
(
aNamespaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
nsSVGElement
:
:
StringAttributesInfo
SVGMPathElement
:
:
GetStringInfo
(
)
{
return
StringAttributesInfo
(
mStringAttributes
sStringInfo
ArrayLength
(
sStringInfo
)
)
;
}
void
SVGMPathElement
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
d
)
{
NotifyParentOfMpathChange
(
GetParent
(
)
)
;
}
}
}
SVGPathElement
*
SVGMPathElement
:
:
GetReferencedPath
(
)
{
if
(
!
HasAttr
(
kNameSpaceID_XLink
nsGkAtoms
:
:
href
)
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
href
)
)
{
MOZ_ASSERT
(
!
mPathTracker
.
get
(
)
"
We
shouldn
'
t
have
a
href
target
"
"
if
we
don
'
t
have
an
xlink
:
href
or
href
attribute
"
)
;
return
nullptr
;
}
nsIContent
*
genericTarget
=
mPathTracker
.
get
(
)
;
if
(
genericTarget
&
&
genericTarget
-
>
IsSVGElement
(
nsGkAtoms
:
:
path
)
)
{
return
static_cast
<
SVGPathElement
*
>
(
genericTarget
)
;
}
return
nullptr
;
}
void
SVGMPathElement
:
:
UpdateHrefTarget
(
nsIContent
*
aParent
const
nsAString
&
aHrefStr
)
{
nsCOMPtr
<
nsIURI
>
targetURI
;
nsCOMPtr
<
nsIURI
>
baseURI
=
GetBaseURI
(
)
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
targetURI
)
aHrefStr
OwnerDoc
(
)
baseURI
)
;
if
(
mPathTracker
.
get
(
)
)
{
mPathTracker
.
get
(
)
-
>
RemoveMutationObserver
(
this
)
;
}
if
(
aParent
)
{
mPathTracker
.
Reset
(
aParent
targetURI
)
;
}
else
{
mPathTracker
.
Unlink
(
)
;
}
if
(
mPathTracker
.
get
(
)
)
{
mPathTracker
.
get
(
)
-
>
AddMutationObserver
(
this
)
;
}
NotifyParentOfMpathChange
(
aParent
)
;
}
void
SVGMPathElement
:
:
UnlinkHrefTarget
(
bool
aNotifyParent
)
{
if
(
mPathTracker
.
get
(
)
)
{
mPathTracker
.
get
(
)
-
>
RemoveMutationObserver
(
this
)
;
}
mPathTracker
.
Unlink
(
)
;
if
(
aNotifyParent
)
{
NotifyParentOfMpathChange
(
GetParent
(
)
)
;
}
}
void
SVGMPathElement
:
:
NotifyParentOfMpathChange
(
nsIContent
*
aParent
)
{
if
(
aParent
&
&
aParent
-
>
IsSVGElement
(
nsGkAtoms
:
:
animateMotion
)
)
{
SVGAnimateMotionElement
*
animateMotionParent
=
static_cast
<
SVGAnimateMotionElement
*
>
(
aParent
)
;
animateMotionParent
-
>
MpathChanged
(
)
;
AnimationNeedsResample
(
)
;
}
}
}
}
