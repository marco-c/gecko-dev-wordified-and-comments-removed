#
include
"
mozilla
/
dom
/
SVGTests
.
h
"
#
include
"
DOMSVGStringList
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
SVGSwitchElement
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
namespace
mozilla
{
namespace
dom
{
nsStaticAtom
*
const
SVGTests
:
:
sStringListNames
[
2
]
=
{
nsGkAtoms
:
:
requiredExtensions
nsGkAtoms
:
:
systemLanguage
}
;
SVGTests
:
:
SVGTests
(
)
{
mStringListAttributes
[
LANGUAGE
]
.
SetIsCommaSeparated
(
true
)
;
}
already_AddRefed
<
DOMSVGStringList
>
SVGTests
:
:
RequiredExtensions
(
)
{
return
DOMSVGStringList
:
:
GetDOMWrapper
(
&
mStringListAttributes
[
EXTENSIONS
]
AsSVGElement
(
)
true
EXTENSIONS
)
;
}
already_AddRefed
<
DOMSVGStringList
>
SVGTests
:
:
SystemLanguage
(
)
{
return
DOMSVGStringList
:
:
GetDOMWrapper
(
&
mStringListAttributes
[
LANGUAGE
]
AsSVGElement
(
)
true
LANGUAGE
)
;
}
bool
SVGTests
:
:
HasExtension
(
const
nsAString
&
aExtension
)
const
{
#
define
SVG_SUPPORTED_EXTENSION
(
str
)
\
if
(
aExtension
.
EqualsLiteral
(
str
)
)
return
true
;
SVG_SUPPORTED_EXTENSION
(
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
)
nsNameSpaceManager
*
nameSpaceManager
=
nsNameSpaceManager
:
:
GetInstance
(
)
;
if
(
AsSVGElement
(
)
-
>
IsInChromeDocument
(
)
|
|
!
nameSpaceManager
-
>
mMathMLDisabled
)
{
SVG_SUPPORTED_EXTENSION
(
"
http
:
/
/
www
.
w3
.
org
/
1998
/
Math
/
MathML
"
)
}
#
undef
SVG_SUPPORTED_EXTENSION
return
false
;
}
bool
SVGTests
:
:
IsConditionalProcessingAttribute
(
const
nsAtom
*
aAttribute
)
const
{
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sStringListNames
)
;
i
+
+
)
{
if
(
aAttribute
=
=
sStringListNames
[
i
]
)
{
return
true
;
}
}
return
false
;
}
int32_t
SVGTests
:
:
GetBestLanguagePreferenceRank
(
const
nsAString
&
aAcceptLangs
)
const
{
const
nsCaseInsensitiveStringComparator
caseInsensitiveComparator
;
if
(
!
mStringListAttributes
[
LANGUAGE
]
.
IsExplicitlySet
(
)
)
{
return
-
2
;
}
int32_t
lowestRank
=
-
1
;
for
(
uint32_t
i
=
0
;
i
<
mStringListAttributes
[
LANGUAGE
]
.
Length
(
)
;
i
+
+
)
{
nsCharSeparatedTokenizer
languageTokenizer
(
aAcceptLangs
'
'
)
;
int32_t
index
=
0
;
while
(
languageTokenizer
.
hasMoreTokens
(
)
)
{
const
nsAString
&
languageToken
=
languageTokenizer
.
nextToken
(
)
;
bool
exactMatch
=
languageToken
.
Equals
(
mStringListAttributes
[
LANGUAGE
]
[
i
]
caseInsensitiveComparator
)
;
bool
prefixOnlyMatch
=
!
exactMatch
&
&
nsStyleUtil
:
:
DashMatchCompare
(
mStringListAttributes
[
LANGUAGE
]
[
i
]
languageTokenizer
.
nextToken
(
)
caseInsensitiveComparator
)
;
if
(
index
=
=
0
&
&
exactMatch
)
{
return
0
;
}
if
(
(
exactMatch
|
|
prefixOnlyMatch
)
&
&
(
lowestRank
=
=
-
1
|
|
2
*
index
+
prefixOnlyMatch
<
lowestRank
)
)
{
lowestRank
=
2
*
index
+
prefixOnlyMatch
;
}
+
+
index
;
}
}
return
lowestRank
;
}
const
nsString
*
const
SVGTests
:
:
kIgnoreSystemLanguage
=
(
nsString
*
)
0x01
;
bool
SVGTests
:
:
PassesConditionalProcessingTests
(
const
nsString
*
aAcceptLangs
)
const
{
if
(
mStringListAttributes
[
EXTENSIONS
]
.
IsExplicitlySet
(
)
)
{
if
(
mStringListAttributes
[
EXTENSIONS
]
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
mStringListAttributes
[
EXTENSIONS
]
.
Length
(
)
;
i
+
+
)
{
if
(
!
HasExtension
(
mStringListAttributes
[
EXTENSIONS
]
[
i
]
)
)
{
return
false
;
}
}
}
if
(
aAcceptLangs
=
=
kIgnoreSystemLanguage
)
{
return
true
;
}
if
(
mStringListAttributes
[
LANGUAGE
]
.
IsExplicitlySet
(
)
)
{
if
(
mStringListAttributes
[
LANGUAGE
]
.
IsEmpty
(
)
)
{
return
false
;
}
nsAutoString
acceptLangs
;
if
(
aAcceptLangs
)
{
acceptLangs
.
Assign
(
*
aAcceptLangs
)
;
}
else
{
Preferences
:
:
GetLocalizedString
(
"
intl
.
accept_languages
"
acceptLangs
)
;
}
if
(
acceptLangs
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
no
default
language
specified
for
systemLanguage
conditional
test
"
)
;
return
false
;
}
const
nsCaseInsensitiveStringComparator
caseInsensitiveComparator
;
for
(
uint32_t
i
=
0
;
i
<
mStringListAttributes
[
LANGUAGE
]
.
Length
(
)
;
i
+
+
)
{
nsCharSeparatedTokenizer
languageTokenizer
(
acceptLangs
'
'
)
;
while
(
languageTokenizer
.
hasMoreTokens
(
)
)
{
if
(
nsStyleUtil
:
:
DashMatchCompare
(
mStringListAttributes
[
LANGUAGE
]
[
i
]
languageTokenizer
.
nextToken
(
)
caseInsensitiveComparator
)
)
{
return
true
;
}
}
}
return
false
;
}
return
true
;
}
bool
SVGTests
:
:
ParseConditionalProcessingAttribute
(
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sStringListNames
)
;
i
+
+
)
{
if
(
aAttribute
=
=
sStringListNames
[
i
]
)
{
nsresult
rv
=
mStringListAttributes
[
i
]
.
SetValue
(
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
mStringListAttributes
[
i
]
.
Clear
(
)
;
}
MaybeInvalidate
(
)
;
return
true
;
}
}
return
false
;
}
void
SVGTests
:
:
UnsetAttr
(
const
nsAtom
*
aAttribute
)
{
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
sStringListNames
)
;
i
+
+
)
{
if
(
aAttribute
=
=
sStringListNames
[
i
]
)
{
mStringListAttributes
[
i
]
.
Clear
(
)
;
MaybeInvalidate
(
)
;
return
;
}
}
}
nsStaticAtom
*
SVGTests
:
:
GetAttrName
(
uint8_t
aAttrEnum
)
const
{
return
sStringListNames
[
aAttrEnum
]
;
}
void
SVGTests
:
:
GetAttrValue
(
uint8_t
aAttrEnum
nsAttrValue
&
aValue
)
const
{
MOZ_ASSERT
(
aAttrEnum
<
ArrayLength
(
sStringListNames
)
"
aAttrEnum
out
of
range
"
)
;
aValue
.
SetTo
(
mStringListAttributes
[
aAttrEnum
]
nullptr
)
;
}
void
SVGTests
:
:
MaybeInvalidate
(
)
{
nsIContent
*
parent
=
AsSVGElement
(
)
-
>
GetFlattenedTreeParent
(
)
;
if
(
parent
&
&
parent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
svgSwitch
kNameSpaceID_SVG
)
)
{
static_cast
<
dom
:
:
SVGSwitchElement
*
>
(
parent
)
-
>
MaybeInvalidate
(
)
;
}
}
}
}
