#
ifndef
DOM_SVG_SVGPOINT_H_
#
define
DOM_SVG_SVGPOINT_H_
#
include
"
gfxPoint
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
nsDebug
.
h
"
namespace
mozilla
{
class
SVGPoint
{
using
Point
=
mozilla
:
:
gfx
:
:
Point
;
public
:
SVGPoint
(
)
:
mX
(
0
.
0f
)
mY
(
0
.
0f
)
{
}
SVGPoint
(
float
aX
float
aY
)
:
mX
(
aX
)
mY
(
aY
)
{
NS_ASSERTION
(
IsValid
(
)
"
Constructed
an
invalid
SVGPoint
"
)
;
}
bool
operator
=
=
(
const
SVGPoint
&
rhs
)
const
{
return
mX
=
=
rhs
.
mX
&
&
mY
=
=
rhs
.
mY
;
}
SVGPoint
&
operator
+
=
(
const
SVGPoint
&
rhs
)
{
mX
+
=
rhs
.
mX
;
mY
+
=
rhs
.
mY
;
return
*
this
;
}
operator
gfxPoint
(
)
const
{
return
gfxPoint
(
mX
mY
)
;
}
operator
Point
(
)
const
{
return
Point
(
mX
mY
)
;
}
#
ifdef
DEBUG
bool
IsValid
(
)
const
{
return
std
:
:
isfinite
(
mX
)
&
&
std
:
:
isfinite
(
mY
)
;
}
#
endif
void
SetX
(
float
aX
)
{
mX
=
aX
;
}
void
SetY
(
float
aY
)
{
mY
=
aY
;
}
float
GetX
(
)
const
{
return
mX
;
}
float
GetY
(
)
const
{
return
mY
;
}
bool
operator
!
=
(
const
SVGPoint
&
rhs
)
const
{
return
mX
!
=
rhs
.
mX
|
|
mY
!
=
rhs
.
mY
;
}
float
mX
;
float
mY
;
}
;
inline
SVGPoint
operator
+
(
const
SVGPoint
&
aP1
const
SVGPoint
&
aP2
)
{
return
SVGPoint
(
aP1
.
mX
+
aP2
.
mX
aP1
.
mY
+
aP2
.
mY
)
;
}
inline
SVGPoint
operator
-
(
const
SVGPoint
&
aP1
const
SVGPoint
&
aP2
)
{
return
SVGPoint
(
aP1
.
mX
-
aP2
.
mX
aP1
.
mY
-
aP2
.
mY
)
;
}
inline
SVGPoint
operator
*
(
float
aFactor
const
SVGPoint
&
aPoint
)
{
return
SVGPoint
(
aFactor
*
aPoint
.
mX
aFactor
*
aPoint
.
mY
)
;
}
inline
SVGPoint
operator
*
(
const
SVGPoint
&
aPoint
float
aFactor
)
{
return
SVGPoint
(
aFactor
*
aPoint
.
mX
aFactor
*
aPoint
.
mY
)
;
}
}
#
endif
