#
include
"
mozilla
/
dom
/
SVGSwitchElement
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGSwitchElementBinding
.
h
"
class
nsIFrame
;
NS_IMPL_NS_NEW_SVG_ELEMENT
(
Switch
)
namespace
mozilla
{
namespace
dom
{
JSObject
*
SVGSwitchElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGSwitchElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
SVGSwitchElement
SVGSwitchElementBase
mActiveChild
)
NS_IMPL_ADDREF_INHERITED
(
SVGSwitchElement
SVGSwitchElementBase
)
NS_IMPL_RELEASE_INHERITED
(
SVGSwitchElement
SVGSwitchElementBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGSwitchElement
)
NS_INTERFACE_MAP_END_INHERITING
(
SVGSwitchElementBase
)
SVGSwitchElement
:
:
SVGSwitchElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGSwitchElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
}
void
SVGSwitchElement
:
:
MaybeInvalidate
(
)
{
nsIContent
*
newActiveChild
=
FindActiveChild
(
)
;
if
(
newActiveChild
=
=
mActiveChild
)
{
return
;
}
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
this
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
SVGUtils
:
:
ScheduleReflowSVG
(
frame
)
;
}
mActiveChild
=
newActiveChild
;
}
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGSwitchElement
)
void
SVGSwitchElement
:
:
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
ErrorResult
&
aRv
)
{
SVGSwitchElementBase
:
:
InsertChildBefore
(
aKid
aBeforeThis
aNotify
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MaybeInvalidate
(
)
;
}
void
SVGSwitchElement
:
:
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
{
SVGSwitchElementBase
:
:
RemoveChildNode
(
aKid
aNotify
)
;
MaybeInvalidate
(
)
;
}
NS_IMETHODIMP_
(
bool
)
SVGSwitchElement
:
:
IsAttributeMapped
(
const
nsAtom
*
name
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sFEFloodMap
sFiltersMap
sFontSpecificationMap
sGradientStopMap
sLightingEffectsMap
sMarkersMap
sTextContentElementsMap
sViewportsMap
}
;
return
FindAttributeDependence
(
name
map
)
|
|
SVGSwitchElementBase
:
:
IsAttributeMapped
(
name
)
;
}
nsIContent
*
SVGSwitchElement
:
:
FindActiveChild
(
)
const
{
nsAutoString
acceptLangs
;
Preferences
:
:
GetLocalizedString
(
"
intl
.
accept_languages
"
acceptLangs
)
;
int32_t
bestLanguagePreferenceRank
=
-
1
;
nsIContent
*
bestChild
=
nullptr
;
nsIContent
*
defaultChild
=
nullptr
;
for
(
nsIContent
*
child
=
nsINode
:
:
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsElement
(
)
)
{
continue
;
}
nsCOMPtr
<
SVGTests
>
tests
(
do_QueryInterface
(
child
)
)
;
if
(
tests
)
{
if
(
tests
-
>
PassesConditionalProcessingTestsIgnoringSystemLanguage
(
)
)
{
int32_t
languagePreferenceRank
=
tests
-
>
GetBestLanguagePreferenceRank
(
acceptLangs
)
;
switch
(
languagePreferenceRank
)
{
case
0
:
return
child
;
case
-
1
:
break
;
case
-
2
:
if
(
!
defaultChild
)
{
defaultChild
=
child
;
}
break
;
default
:
if
(
bestLanguagePreferenceRank
=
=
-
1
|
|
languagePreferenceRank
<
bestLanguagePreferenceRank
)
{
bestLanguagePreferenceRank
=
languagePreferenceRank
;
bestChild
=
child
;
}
break
;
}
}
}
else
if
(
!
bestChild
)
{
bestChild
=
child
;
}
}
return
bestChild
?
bestChild
:
defaultChild
;
}
}
}
