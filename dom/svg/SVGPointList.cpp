#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
SVGPointList
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTextFormatter
.
h
"
#
include
"
SVGContentUtils
.
h
"
namespace
mozilla
{
nsresult
SVGPointList
:
:
CopyFrom
(
const
SVGPointList
&
rhs
)
{
if
(
!
mItems
.
Assign
(
rhs
.
mItems
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
SVGPointList
:
:
GetValueAsString
(
nsAString
&
aValue
)
const
{
aValue
.
Truncate
(
)
;
char16_t
buf
[
50
]
;
uint32_t
last
=
mItems
.
Length
(
)
-
1
;
for
(
uint32_t
i
=
0
;
i
<
mItems
.
Length
(
)
;
+
+
i
)
{
nsTextFormatter
:
:
snprintf
(
buf
std
:
:
size
(
buf
)
u
"
%
g
%
g
"
double
(
mItems
[
i
]
.
mX
)
double
(
mItems
[
i
]
.
mY
)
)
;
aValue
.
Append
(
buf
)
;
if
(
i
!
=
last
)
{
aValue
.
Append
(
'
'
)
;
}
}
}
nsresult
SVGPointList
:
:
SetValueFromString
(
const
nsAString
&
aValue
)
{
nsresult
rv
=
NS_OK
;
SVGPointList
temp
;
nsCharSeparatedTokenizerTemplate
<
nsContentUtils
:
:
IsHTMLWhitespace
nsTokenizerFlags
:
:
SeparatorOptional
>
tokenizer
(
aValue
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsAString
&
token
=
tokenizer
.
nextToken
(
)
;
nsAString
:
:
const_iterator
iter
end
;
token
.
BeginReading
(
iter
)
;
token
.
EndReading
(
end
)
;
float
x
;
if
(
!
SVGContentUtils
:
:
ParseNumber
(
iter
end
x
)
)
{
rv
=
NS_ERROR_DOM_SYNTAX_ERR
;
break
;
}
float
y
;
if
(
iter
=
=
end
)
{
if
(
!
tokenizer
.
hasMoreTokens
(
)
|
|
!
SVGContentUtils
:
:
ParseNumber
(
tokenizer
.
nextToken
(
)
y
)
)
{
rv
=
NS_ERROR_DOM_SYNTAX_ERR
;
break
;
}
}
else
{
const
nsAString
&
leftOver
=
Substring
(
iter
end
)
;
if
(
leftOver
[
0
]
!
=
'
-
'
|
|
!
SVGContentUtils
:
:
ParseNumber
(
leftOver
y
)
)
{
rv
=
NS_ERROR_DOM_SYNTAX_ERR
;
break
;
}
}
temp
.
AppendItem
(
SVGPoint
(
x
y
)
)
;
}
if
(
tokenizer
.
separatorAfterCurrentToken
(
)
)
{
rv
=
NS_ERROR_DOM_SYNTAX_ERR
;
}
nsresult
rv2
=
CopyFrom
(
temp
)
;
if
(
NS_FAILED
(
rv2
)
)
{
return
rv2
;
}
return
rv
;
}
}
