#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGScriptElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGScriptElementBinding
.
h
"
#
include
"
nsIScriptError
.
h
"
NS_IMPL_NS_NEW_NAMESPACED_SVG_ELEMENT_CHECK_PARSER
(
Script
)
namespace
mozilla
{
namespace
dom
{
JSObject
*
SVGScriptElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGScriptElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsSVGElement
:
:
StringInfo
SVGScriptElement
:
:
sStringInfo
[
2
]
=
{
{
&
nsGkAtoms
:
:
href
kNameSpaceID_None
false
}
{
&
nsGkAtoms
:
:
href
kNameSpaceID_XLink
false
}
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
SVGScriptElement
SVGScriptElementBase
nsIScriptLoaderObserver
nsIScriptElement
nsIMutationObserver
)
SVGScriptElement
:
:
SVGScriptElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
:
SVGScriptElementBase
(
std
:
:
move
(
aNodeInfo
)
)
ScriptElement
(
aFromParser
)
{
AddMutationObserver
(
this
)
;
}
SVGScriptElement
:
:
~
SVGScriptElement
(
)
{
}
nsresult
SVGScriptElement
:
:
Clone
(
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
{
*
aResult
=
nullptr
;
SVGScriptElement
*
it
=
new
SVGScriptElement
(
do_AddRef
(
aNodeInfo
)
NOT_FROM_PARSER
)
;
nsCOMPtr
<
nsINode
>
kungFuDeathGrip
=
it
;
nsresult
rv1
=
it
-
>
Init
(
)
;
nsresult
rv2
=
const_cast
<
SVGScriptElement
*
>
(
this
)
-
>
CopyInnerTo
(
it
)
;
NS_ENSURE_SUCCESS
(
rv1
rv1
)
;
NS_ENSURE_SUCCESS
(
rv2
rv2
)
;
it
-
>
mAlreadyStarted
=
mAlreadyStarted
;
it
-
>
mLineNumber
=
mLineNumber
;
it
-
>
mMalformed
=
mMalformed
;
kungFuDeathGrip
.
swap
(
*
aResult
)
;
return
NS_OK
;
}
void
SVGScriptElement
:
:
GetType
(
nsAString
&
aType
)
{
GetScriptType
(
aType
)
;
}
void
SVGScriptElement
:
:
SetType
(
const
nsAString
&
aType
ErrorResult
&
rv
)
{
rv
=
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
aType
true
)
;
}
void
SVGScriptElement
:
:
GetCrossOrigin
(
nsAString
&
aCrossOrigin
)
{
GetEnumAttr
(
nsGkAtoms
:
:
crossorigin
nullptr
aCrossOrigin
)
;
}
void
SVGScriptElement
:
:
SetCrossOrigin
(
const
nsAString
&
aCrossOrigin
ErrorResult
&
aError
)
{
SetOrRemoveNullableStringAttr
(
nsGkAtoms
:
:
crossorigin
aCrossOrigin
aError
)
;
}
already_AddRefed
<
SVGAnimatedString
>
SVGScriptElement
:
:
Href
(
)
{
return
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
?
mStringAttributes
[
HREF
]
.
ToDOMAnimatedString
(
this
)
:
mStringAttributes
[
XLINK_HREF
]
.
ToDOMAnimatedString
(
this
)
;
}
bool
SVGScriptElement
:
:
GetScriptType
(
nsAString
&
type
)
{
return
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
;
}
void
SVGScriptElement
:
:
GetScriptText
(
nsAString
&
text
)
{
nsContentUtils
:
:
GetNodeTextContent
(
this
false
text
)
;
}
void
SVGScriptElement
:
:
GetScriptCharset
(
nsAString
&
charset
)
{
charset
.
Truncate
(
)
;
}
void
SVGScriptElement
:
:
FreezeExecutionAttrs
(
nsIDocument
*
aOwnerDoc
)
{
if
(
mFrozen
)
{
return
;
}
if
(
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
|
|
mStringAttributes
[
XLINK_HREF
]
.
IsExplicitlySet
(
)
)
{
bool
isHref
=
false
;
nsAutoString
src
;
if
(
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
)
{
mStringAttributes
[
HREF
]
.
GetAnimValue
(
src
this
)
;
isHref
=
true
;
}
else
{
mStringAttributes
[
XLINK_HREF
]
.
GetAnimValue
(
src
this
)
;
}
if
(
!
src
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURI
>
baseURI
=
GetBaseURI
(
)
;
NS_NewURI
(
getter_AddRefs
(
mUri
)
src
nullptr
baseURI
)
;
if
(
!
mUri
)
{
const
char16_t
*
params
[
]
=
{
isHref
?
u
"
href
"
:
u
"
xlink
:
href
"
src
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
SVG
"
)
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
ScriptSourceInvalidUri
"
params
ArrayLength
(
params
)
nullptr
EmptyString
(
)
GetScriptLineNumber
(
)
GetScriptColumnNumber
(
)
)
;
}
}
else
{
const
char16_t
*
params
[
]
=
{
isHref
?
u
"
href
"
:
u
"
xlink
:
href
"
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
SVG
"
)
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
ScriptSourceEmpty
"
params
ArrayLength
(
params
)
nullptr
EmptyString
(
)
GetScriptLineNumber
(
)
GetScriptColumnNumber
(
)
)
;
}
mExternal
=
true
;
}
mFrozen
=
true
;
}
bool
SVGScriptElement
:
:
HasScriptContent
(
)
{
return
(
mFrozen
?
mExternal
:
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
|
|
mStringAttributes
[
XLINK_HREF
]
.
IsExplicitlySet
(
)
)
|
|
nsContentUtils
:
:
HasNonEmptyTextContent
(
this
)
;
}
nsSVGElement
:
:
StringAttributesInfo
SVGScriptElement
:
:
GetStringInfo
(
)
{
return
StringAttributesInfo
(
mStringAttributes
sStringInfo
ArrayLength
(
sStringInfo
)
)
;
}
nsresult
SVGScriptElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
nsresult
rv
=
SVGScriptElementBase
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDocument
)
{
MaybeProcessScript
(
)
;
}
return
NS_OK
;
}
nsresult
SVGScriptElement
:
:
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
(
aNamespaceID
=
=
kNameSpaceID_XLink
|
|
aNamespaceID
=
=
kNameSpaceID_None
)
&
&
aName
=
=
nsGkAtoms
:
:
href
)
{
MaybeProcessScript
(
)
;
}
return
SVGScriptElementBase
:
:
AfterSetAttr
(
aNamespaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
bool
SVGScriptElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
crossorigin
)
{
ParseCORSValue
(
aValue
aResult
)
;
return
true
;
}
return
SVGScriptElementBase
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
CORSMode
SVGScriptElement
:
:
GetCORSMode
(
)
const
{
return
AttrValueToCORSMode
(
GetParsedAttr
(
nsGkAtoms
:
:
crossorigin
)
)
;
}
}
}
