#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGMatrix
.
h
"
#
include
"
mozilla
/
dom
/
SVGRect
.
h
"
#
include
"
mozilla
/
dom
/
SVGViewElement
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
mozilla
/
SMILTimeContainer
.
h
"
#
include
"
DOMSVGAngle
.
h
"
#
include
"
DOMSVGLength
.
h
"
#
include
"
DOMSVGNumber
.
h
"
#
include
"
DOMSVGPoint
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsLayoutStylesheetCache
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsISVGSVGFrame
.
h
"
#
include
"
nsSVGDisplayableFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
NS_IMPL_NS_NEW_SVG_ELEMENT_CHECK_PARSER
(
SVG
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
using
namespace
SVGPreserveAspectRatio_Binding
;
using
namespace
SVGSVGElement_Binding
;
SVGEnumMapping
SVGSVGElement
:
:
sZoomAndPanMap
[
]
=
{
{
nsGkAtoms
:
:
disable
SVG_ZOOMANDPAN_DISABLE
}
{
nsGkAtoms
:
:
magnify
SVG_ZOOMANDPAN_MAGNIFY
}
{
nullptr
0
}
}
;
SVGElement
:
:
EnumInfo
SVGSVGElement
:
:
sEnumInfo
[
1
]
=
{
{
nsGkAtoms
:
:
zoomAndPan
sZoomAndPanMap
SVG_ZOOMANDPAN_MAGNIFY
}
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
DOMSVGTranslatePoint
nsISVGPoint
mElement
)
NS_IMPL_ADDREF_INHERITED
(
DOMSVGTranslatePoint
nsISVGPoint
)
NS_IMPL_RELEASE_INHERITED
(
DOMSVGTranslatePoint
nsISVGPoint
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DOMSVGTranslatePoint
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
nsISVGPoint
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
DOMSVGPoint
*
DOMSVGTranslatePoint
:
:
Copy
(
)
{
return
new
DOMSVGPoint
(
mPt
.
GetX
(
)
mPt
.
GetY
(
)
)
;
}
nsISupports
*
DOMSVGTranslatePoint
:
:
GetParentObject
(
)
{
return
ToSupports
(
mElement
)
;
}
void
DOMSVGTranslatePoint
:
:
SetX
(
float
aValue
ErrorResult
&
rv
)
{
mElement
-
>
SetCurrentTranslate
(
aValue
mPt
.
GetY
(
)
)
;
}
void
DOMSVGTranslatePoint
:
:
SetY
(
float
aValue
ErrorResult
&
rv
)
{
mElement
-
>
SetCurrentTranslate
(
mPt
.
GetX
(
)
aValue
)
;
}
already_AddRefed
<
nsISVGPoint
>
DOMSVGTranslatePoint
:
:
MatrixTransform
(
SVGMatrix
&
matrix
)
{
float
a
=
matrix
.
A
(
)
b
=
matrix
.
B
(
)
c
=
matrix
.
C
(
)
;
float
d
=
matrix
.
D
(
)
e
=
matrix
.
E
(
)
f
=
matrix
.
F
(
)
;
float
x
=
mPt
.
GetX
(
)
;
float
y
=
mPt
.
GetY
(
)
;
nsCOMPtr
<
nsISVGPoint
>
point
=
new
DOMSVGPoint
(
a
*
x
+
c
*
y
+
e
b
*
x
+
d
*
y
+
f
)
;
return
point
.
forget
(
)
;
}
JSObject
*
SVGSVGElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGSVGElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SVGSVGElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
SVGSVGElement
SVGSVGElementBase
)
if
(
tmp
-
>
mTimedDocumentRoot
)
{
tmp
-
>
mTimedDocumentRoot
-
>
Unlink
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
SVGSVGElement
SVGSVGElementBase
)
if
(
tmp
-
>
mTimedDocumentRoot
)
{
tmp
-
>
mTimedDocumentRoot
-
>
Traverse
(
&
cb
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
SVGSVGElement
SVGSVGElementBase
)
SVGView
:
:
SVGView
(
)
{
mZoomAndPan
.
Init
(
SVGSVGElement
:
:
ZOOMANDPAN
SVG_ZOOMANDPAN_MAGNIFY
)
;
mViewBox
.
Init
(
)
;
mPreserveAspectRatio
.
Init
(
)
;
}
SVGSVGElement
:
:
SVGSVGElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
:
SVGSVGElementBase
(
std
:
:
move
(
aNodeInfo
)
)
mCurrentTranslate
(
0
.
0f
0
.
0f
)
mCurrentScale
(
1
.
0f
)
mPreviousTranslate
(
0
.
0f
0
.
0f
)
mPreviousScale
(
1
.
0f
)
mStartAnimationOnBindToTree
(
aFromParser
=
=
NOT_FROM_PARSER
|
|
aFromParser
=
=
FROM_PARSER_FRAGMENT
|
|
aFromParser
=
=
FROM_PARSER_XSLT
)
mImageNeedsTransformInvalidation
(
false
)
{
}
SVGSVGElement
:
:
~
SVGSVGElement
(
)
{
}
NS_IMPL_ELEMENT_CLONE_WITH_INIT_AND_PARSER
(
SVGSVGElement
)
already_AddRefed
<
SVGAnimatedLength
>
SVGSVGElement
:
:
X
(
)
{
return
mLengthAttributes
[
ATTR_X
]
.
ToDOMAnimatedLength
(
this
)
;
}
already_AddRefed
<
SVGAnimatedLength
>
SVGSVGElement
:
:
Y
(
)
{
return
mLengthAttributes
[
ATTR_Y
]
.
ToDOMAnimatedLength
(
this
)
;
}
already_AddRefed
<
SVGAnimatedLength
>
SVGSVGElement
:
:
Width
(
)
{
return
mLengthAttributes
[
ATTR_WIDTH
]
.
ToDOMAnimatedLength
(
this
)
;
}
already_AddRefed
<
SVGAnimatedLength
>
SVGSVGElement
:
:
Height
(
)
{
return
mLengthAttributes
[
ATTR_HEIGHT
]
.
ToDOMAnimatedLength
(
this
)
;
}
bool
SVGSVGElement
:
:
UseCurrentView
(
)
{
return
mSVGView
|
|
mCurrentViewID
;
}
float
SVGSVGElement
:
:
CurrentScale
(
)
{
return
mCurrentScale
;
}
#
define
CURRENT_SCALE_MAX
16
.
0f
#
define
CURRENT_SCALE_MIN
0
.
0625f
void
SVGSVGElement
:
:
SetCurrentScale
(
float
aCurrentScale
)
{
SetCurrentScaleTranslate
(
aCurrentScale
mCurrentTranslate
.
GetX
(
)
mCurrentTranslate
.
GetY
(
)
)
;
}
already_AddRefed
<
nsISVGPoint
>
SVGSVGElement
:
:
CurrentTranslate
(
)
{
nsCOMPtr
<
nsISVGPoint
>
point
=
new
DOMSVGTranslatePoint
(
&
mCurrentTranslate
this
)
;
return
point
.
forget
(
)
;
}
uint32_t
SVGSVGElement
:
:
SuspendRedraw
(
uint32_t
max_wait_milliseconds
)
{
return
1
;
}
void
SVGSVGElement
:
:
UnsuspendRedraw
(
uint32_t
suspend_handle_id
)
{
}
void
SVGSVGElement
:
:
UnsuspendRedrawAll
(
)
{
}
void
SVGSVGElement
:
:
ForceRedraw
(
)
{
}
void
SVGSVGElement
:
:
PauseAnimations
(
)
{
if
(
mTimedDocumentRoot
)
{
mTimedDocumentRoot
-
>
Pause
(
SMILTimeContainer
:
:
PAUSE_SCRIPT
)
;
}
}
void
SVGSVGElement
:
:
UnpauseAnimations
(
)
{
if
(
mTimedDocumentRoot
)
{
mTimedDocumentRoot
-
>
Resume
(
SMILTimeContainer
:
:
PAUSE_SCRIPT
)
;
}
}
bool
SVGSVGElement
:
:
AnimationsPaused
(
)
{
SMILTimeContainer
*
root
=
GetTimedDocumentRoot
(
)
;
return
root
&
&
root
-
>
IsPausedByType
(
SMILTimeContainer
:
:
PAUSE_SCRIPT
)
;
}
float
SVGSVGElement
:
:
GetCurrentTimeAsFloat
(
)
{
SMILTimeContainer
*
root
=
GetTimedDocumentRoot
(
)
;
if
(
root
)
{
double
fCurrentTimeMs
=
double
(
root
-
>
GetCurrentTimeAsSMILTime
(
)
)
;
return
(
float
)
(
fCurrentTimeMs
/
PR_MSEC_PER_SEC
)
;
}
else
{
return
0
.
f
;
}
}
void
SVGSVGElement
:
:
SetCurrentTime
(
float
seconds
)
{
if
(
mTimedDocumentRoot
)
{
FlushAnimations
(
)
;
double
fMilliseconds
=
double
(
seconds
)
*
PR_MSEC_PER_SEC
;
SMILTime
lMilliseconds
=
int64_t
(
NS_round
(
fMilliseconds
)
)
;
mTimedDocumentRoot
-
>
SetCurrentTime
(
lMilliseconds
)
;
AnimationNeedsResample
(
)
;
FlushAnimations
(
)
;
}
}
void
SVGSVGElement
:
:
DeselectAll
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
frame
-
>
GetFrameSelection
(
)
;
frameSelection
-
>
ClearNormalSelection
(
)
;
}
}
already_AddRefed
<
DOMSVGNumber
>
SVGSVGElement
:
:
CreateSVGNumber
(
)
{
RefPtr
<
DOMSVGNumber
>
number
=
new
DOMSVGNumber
(
ToSupports
(
this
)
)
;
return
number
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGLength
>
SVGSVGElement
:
:
CreateSVGLength
(
)
{
nsCOMPtr
<
DOMSVGLength
>
length
=
new
DOMSVGLength
(
)
;
return
length
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGAngle
>
SVGSVGElement
:
:
CreateSVGAngle
(
)
{
return
do_AddRef
(
new
DOMSVGAngle
(
this
)
)
;
}
already_AddRefed
<
nsISVGPoint
>
SVGSVGElement
:
:
CreateSVGPoint
(
)
{
nsCOMPtr
<
nsISVGPoint
>
point
=
new
DOMSVGPoint
(
0
0
)
;
return
point
.
forget
(
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGSVGElement
:
:
CreateSVGMatrix
(
)
{
RefPtr
<
SVGMatrix
>
matrix
=
new
SVGMatrix
(
)
;
return
matrix
.
forget
(
)
;
}
already_AddRefed
<
SVGIRect
>
SVGSVGElement
:
:
CreateSVGRect
(
)
{
return
NS_NewSVGRect
(
this
)
;
}
already_AddRefed
<
DOMSVGTransform
>
SVGSVGElement
:
:
CreateSVGTransform
(
)
{
RefPtr
<
DOMSVGTransform
>
transform
=
new
DOMSVGTransform
(
)
;
return
transform
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGTransform
>
SVGSVGElement
:
:
CreateSVGTransformFromMatrix
(
SVGMatrix
&
matrix
)
{
RefPtr
<
DOMSVGTransform
>
transform
=
new
DOMSVGTransform
(
matrix
.
GetMatrix
(
)
)
;
return
transform
.
forget
(
)
;
}
void
SVGSVGElement
:
:
SetCurrentScaleTranslate
(
float
s
float
x
float
y
)
{
if
(
s
=
=
mCurrentScale
&
&
x
=
=
mCurrentTranslate
.
GetX
(
)
&
&
y
=
=
mCurrentTranslate
.
GetY
(
)
)
{
return
;
}
if
(
s
<
CURRENT_SCALE_MIN
)
s
=
CURRENT_SCALE_MIN
;
else
if
(
s
>
CURRENT_SCALE_MAX
)
s
=
CURRENT_SCALE_MAX
;
mPreviousScale
=
mCurrentScale
;
mPreviousTranslate
=
mCurrentTranslate
;
mCurrentScale
=
s
;
mCurrentTranslate
=
SVGPoint
(
x
y
)
;
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
doc
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
doc
-
>
GetShell
(
)
;
if
(
presShell
&
&
IsRoot
(
)
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
mPreviousScale
=
=
mCurrentScale
)
{
WidgetEvent
svgScrollEvent
(
true
eSVGScroll
)
;
presShell
-
>
HandleDOMEventWithTarget
(
this
&
svgScrollEvent
&
status
)
;
}
InvalidateTransformNotifyFrame
(
)
;
}
}
}
void
SVGSVGElement
:
:
SetCurrentTranslate
(
float
x
float
y
)
{
SetCurrentScaleTranslate
(
mCurrentScale
x
y
)
;
}
uint16_t
SVGSVGElement
:
:
ZoomAndPan
(
)
{
return
mEnumAttributes
[
ZOOMANDPAN
]
.
GetAnimValue
(
)
;
}
void
SVGSVGElement
:
:
SetZoomAndPan
(
uint16_t
aZoomAndPan
ErrorResult
&
rv
)
{
if
(
aZoomAndPan
=
=
SVG_ZOOMANDPAN_DISABLE
|
|
aZoomAndPan
=
=
SVG_ZOOMANDPAN_MAGNIFY
)
{
mEnumAttributes
[
ZOOMANDPAN
]
.
SetBaseValue
(
aZoomAndPan
this
)
;
return
;
}
rv
.
ThrowRangeError
<
MSG_INVALID_ZOOMANDPAN_VALUE_ERROR
>
(
)
;
}
SMILTimeContainer
*
SVGSVGElement
:
:
GetTimedDocumentRoot
(
)
{
if
(
mTimedDocumentRoot
)
{
return
mTimedDocumentRoot
;
}
SVGSVGElement
*
outerSVGElement
=
SVGContentUtils
:
:
GetOuterSVGElement
(
this
)
;
if
(
outerSVGElement
)
{
return
outerSVGElement
-
>
GetTimedDocumentRoot
(
)
;
}
return
nullptr
;
}
nsresult
SVGSVGElement
:
:
BindToTree
(
Document
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
SMILAnimationController
*
smilController
=
nullptr
;
if
(
aDocument
)
{
smilController
=
aDocument
-
>
GetAnimationController
(
)
;
if
(
smilController
)
{
if
(
WillBeOutermostSVG
(
aParent
aBindingParent
)
)
{
if
(
!
mTimedDocumentRoot
)
{
mTimedDocumentRoot
=
new
SMILTimeContainer
(
)
;
}
}
else
{
mTimedDocumentRoot
=
nullptr
;
mStartAnimationOnBindToTree
=
true
;
}
}
}
nsresult
rv
=
SVGGraphicsElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mTimedDocumentRoot
&
&
smilController
)
{
rv
=
mTimedDocumentRoot
-
>
SetParent
(
smilController
)
;
if
(
mStartAnimationOnBindToTree
)
{
mTimedDocumentRoot
-
>
Begin
(
)
;
mStartAnimationOnBindToTree
=
false
;
}
}
return
rv
;
}
void
SVGSVGElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
if
(
mTimedDocumentRoot
)
{
mTimedDocumentRoot
-
>
SetParent
(
nullptr
)
;
}
SVGGraphicsElement
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
}
SVGAnimatedTransformList
*
SVGSVGElement
:
:
GetAnimatedTransformList
(
uint32_t
aFlags
)
{
if
(
!
(
aFlags
&
DO_ALLOCATE
)
&
&
mSVGView
&
&
mSVGView
-
>
mTransforms
)
{
return
mSVGView
-
>
mTransforms
;
}
return
SVGGraphicsElement
:
:
GetAnimatedTransformList
(
aFlags
)
;
}
void
SVGSVGElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eSVGLoad
)
{
if
(
mTimedDocumentRoot
)
{
mTimedDocumentRoot
-
>
Begin
(
)
;
AnimationNeedsResample
(
)
;
}
}
SVGSVGElementBase
:
:
GetEventTargetParent
(
aVisitor
)
;
}
bool
SVGSVGElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
(
EventNameType_SVGGraphic
|
EventNameType_SVGSVG
)
)
;
}
int32_t
SVGSVGElement
:
:
GetIntrinsicWidth
(
)
{
if
(
mLengthAttributes
[
ATTR_WIDTH
]
.
IsPercentage
(
)
)
{
return
-
1
;
}
float
width
=
mLengthAttributes
[
ATTR_WIDTH
]
.
GetAnimValue
(
this
)
;
return
nsSVGUtils
:
:
ClampToInt
(
width
)
;
}
int32_t
SVGSVGElement
:
:
GetIntrinsicHeight
(
)
{
if
(
mLengthAttributes
[
ATTR_HEIGHT
]
.
IsPercentage
(
)
)
{
return
-
1
;
}
float
height
=
mLengthAttributes
[
ATTR_HEIGHT
]
.
GetAnimValue
(
this
)
;
return
nsSVGUtils
:
:
ClampToInt
(
height
)
;
}
void
SVGSVGElement
:
:
FlushImageTransformInvalidation
(
)
{
MOZ_ASSERT
(
!
GetParent
(
)
"
Should
only
be
called
on
root
node
"
)
;
MOZ_ASSERT
(
OwnerDoc
(
)
-
>
IsBeingUsedAsImage
(
)
"
Should
only
be
called
on
image
documents
"
)
;
if
(
mImageNeedsTransformInvalidation
)
{
InvalidateTransformNotifyFrame
(
)
;
mImageNeedsTransformInvalidation
=
false
;
}
}
bool
SVGSVGElement
:
:
WillBeOutermostSVG
(
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
const
{
nsIContent
*
parent
=
aBindingParent
?
aBindingParent
:
aParent
;
while
(
parent
&
&
parent
-
>
IsSVGElement
(
)
)
{
if
(
parent
-
>
IsSVGElement
(
nsGkAtoms
:
:
foreignObject
)
)
{
return
false
;
}
if
(
parent
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
return
false
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
return
true
;
}
void
SVGSVGElement
:
:
InvalidateTransformNotifyFrame
(
)
{
nsISVGSVGFrame
*
svgframe
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
svgframe
)
{
svgframe
-
>
NotifyViewportOrTransformChanged
(
nsSVGDisplayableFrame
:
:
TRANSFORM_CHANGED
)
;
}
}
SVGElement
:
:
EnumAttributesInfo
SVGSVGElement
:
:
GetEnumInfo
(
)
{
return
EnumAttributesInfo
(
mEnumAttributes
sEnumInfo
ArrayLength
(
sEnumInfo
)
)
;
}
void
SVGSVGElement
:
:
SetImageOverridePreserveAspectRatio
(
const
SVGPreserveAspectRatio
&
aPAR
)
{
MOZ_ASSERT
(
OwnerDoc
(
)
-
>
IsBeingUsedAsImage
(
)
"
should
only
override
preserveAspectRatio
in
images
"
)
;
bool
hasViewBoxRect
=
HasViewBoxRect
(
)
;
if
(
!
hasViewBoxRect
&
&
ShouldSynthesizeViewBox
(
)
)
{
mImageNeedsTransformInvalidation
=
true
;
}
if
(
!
hasViewBoxRect
)
{
return
;
}
if
(
SetPreserveAspectRatioProperty
(
aPAR
)
)
{
mImageNeedsTransformInvalidation
=
true
;
}
}
void
SVGSVGElement
:
:
ClearImageOverridePreserveAspectRatio
(
)
{
MOZ_ASSERT
(
OwnerDoc
(
)
-
>
IsBeingUsedAsImage
(
)
"
should
only
override
image
preserveAspectRatio
in
images
"
)
;
if
(
!
HasViewBoxRect
(
)
&
&
ShouldSynthesizeViewBox
(
)
)
{
mImageNeedsTransformInvalidation
=
true
;
}
if
(
ClearPreserveAspectRatioProperty
(
)
)
{
mImageNeedsTransformInvalidation
=
true
;
}
}
bool
SVGSVGElement
:
:
SetPreserveAspectRatioProperty
(
const
SVGPreserveAspectRatio
&
aPAR
)
{
SVGPreserveAspectRatio
*
pAROverridePtr
=
new
SVGPreserveAspectRatio
(
aPAR
)
;
nsresult
rv
=
SetProperty
(
nsGkAtoms
:
:
overridePreserveAspectRatio
pAROverridePtr
nsINode
:
:
DeleteProperty
<
SVGPreserveAspectRatio
>
true
)
;
MOZ_ASSERT
(
rv
!
=
NS_PROPTABLE_PROP_OVERWRITTEN
"
Setting
override
value
when
it
'
s
already
set
.
.
.
?
"
)
;
if
(
MOZ_UNLIKELY
(
NS_FAILED
(
rv
)
)
)
{
delete
pAROverridePtr
;
return
false
;
}
return
true
;
}
const
SVGPreserveAspectRatio
*
SVGSVGElement
:
:
GetPreserveAspectRatioProperty
(
)
const
{
void
*
valPtr
=
GetProperty
(
nsGkAtoms
:
:
overridePreserveAspectRatio
)
;
if
(
valPtr
)
{
return
static_cast
<
SVGPreserveAspectRatio
*
>
(
valPtr
)
;
}
return
nullptr
;
}
bool
SVGSVGElement
:
:
ClearPreserveAspectRatioProperty
(
)
{
void
*
valPtr
=
UnsetProperty
(
nsGkAtoms
:
:
overridePreserveAspectRatio
)
;
bool
didHaveProperty
=
!
!
valPtr
;
delete
static_cast
<
SVGPreserveAspectRatio
*
>
(
valPtr
)
;
return
didHaveProperty
;
}
SVGPreserveAspectRatio
SVGSVGElement
:
:
GetPreserveAspectRatioWithOverride
(
)
const
{
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
IsBeingUsedAsImage
(
)
)
{
const
SVGPreserveAspectRatio
*
pAROverridePtr
=
GetPreserveAspectRatioProperty
(
)
;
if
(
pAROverridePtr
)
{
return
*
pAROverridePtr
;
}
}
SVGViewElement
*
viewElement
=
GetCurrentViewElement
(
)
;
if
(
!
(
(
viewElement
&
&
viewElement
-
>
mViewBox
.
HasRect
(
)
)
|
|
(
mSVGView
&
&
mSVGView
-
>
mViewBox
.
HasRect
(
)
)
|
|
mViewBox
.
HasRect
(
)
)
&
&
ShouldSynthesizeViewBox
(
)
)
{
return
SVGPreserveAspectRatio
(
SVG_PRESERVEASPECTRATIO_NONE
SVG_MEETORSLICE_SLICE
)
;
}
if
(
viewElement
&
&
viewElement
-
>
mPreserveAspectRatio
.
IsExplicitlySet
(
)
)
{
return
viewElement
-
>
mPreserveAspectRatio
.
GetAnimValue
(
)
;
}
if
(
mSVGView
&
&
mSVGView
-
>
mPreserveAspectRatio
.
IsExplicitlySet
(
)
)
{
return
mSVGView
-
>
mPreserveAspectRatio
.
GetAnimValue
(
)
;
}
return
mPreserveAspectRatio
.
GetAnimValue
(
)
;
}
SVGViewElement
*
SVGSVGElement
:
:
GetCurrentViewElement
(
)
const
{
if
(
mCurrentViewID
)
{
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
doc
)
{
Element
*
element
=
doc
-
>
GetElementById
(
*
mCurrentViewID
)
;
if
(
element
&
&
element
-
>
IsSVGElement
(
nsGkAtoms
:
:
view
)
)
{
return
static_cast
<
SVGViewElement
*
>
(
element
)
;
}
}
}
return
nullptr
;
}
const
SVGViewBox
&
SVGSVGElement
:
:
GetViewBoxInternal
(
)
const
{
SVGViewElement
*
viewElement
=
GetCurrentViewElement
(
)
;
if
(
viewElement
&
&
viewElement
-
>
mViewBox
.
HasRect
(
)
)
{
return
viewElement
-
>
mViewBox
;
}
else
if
(
mSVGView
&
&
mSVGView
-
>
mViewBox
.
HasRect
(
)
)
{
return
mSVGView
-
>
mViewBox
;
}
return
mViewBox
;
}
SVGAnimatedTransformList
*
SVGSVGElement
:
:
GetTransformInternal
(
)
const
{
return
(
mSVGView
&
&
mSVGView
-
>
mTransforms
)
?
mSVGView
-
>
mTransforms
:
mTransforms
;
}
}
}
