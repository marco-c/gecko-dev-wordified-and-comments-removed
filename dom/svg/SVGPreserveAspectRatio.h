#
ifndef
DOM_SVG_SVGPRESERVEASPECTRATIO_H_
#
define
DOM_SVG_SVGPRESERVEASPECTRATIO_H_
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGPreserveAspectRatioBinding
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
namespace
mozilla
{
class
ErrorResult
;
const
uint16_t
SVG_ALIGN_MIN_VALID
=
dom
:
:
SVGPreserveAspectRatio_Binding
:
:
SVG_PRESERVEASPECTRATIO_NONE
;
const
uint16_t
SVG_ALIGN_MAX_VALID
=
dom
:
:
SVGPreserveAspectRatio_Binding
:
:
SVG_PRESERVEASPECTRATIO_XMAXYMAX
;
const
uint16_t
SVG_MEETORSLICE_MIN_VALID
=
dom
:
:
SVGPreserveAspectRatio_Binding
:
:
SVG_MEETORSLICE_MEET
;
const
uint16_t
SVG_MEETORSLICE_MAX_VALID
=
dom
:
:
SVGPreserveAspectRatio_Binding
:
:
SVG_MEETORSLICE_SLICE
;
class
SVGAnimatedPreserveAspectRatio
;
class
SVGPreserveAspectRatio
final
{
friend
class
SVGAnimatedPreserveAspectRatio
;
public
:
explicit
SVGPreserveAspectRatio
(
)
:
mAlign
(
dom
:
:
SVGPreserveAspectRatio_Binding
:
:
SVG_PRESERVEASPECTRATIO_UNKNOWN
)
mMeetOrSlice
(
dom
:
:
SVGPreserveAspectRatio_Binding
:
:
SVG_MEETORSLICE_UNKNOWN
)
{
}
SVGPreserveAspectRatio
(
uint8_t
aAlign
uint8_t
aMeetOrSlice
)
:
mAlign
(
aAlign
)
mMeetOrSlice
(
aMeetOrSlice
)
{
}
static
nsresult
FromString
(
const
nsAString
&
aString
SVGPreserveAspectRatio
*
aValue
)
;
void
ToString
(
nsAString
&
aValueAsString
)
const
;
bool
operator
=
=
(
const
SVGPreserveAspectRatio
&
aOther
)
const
;
bool
SetAlign
(
uint16_t
aAlign
)
{
if
(
aAlign
<
SVG_ALIGN_MIN_VALID
|
|
aAlign
>
SVG_ALIGN_MAX_VALID
)
return
false
;
mAlign
=
static_cast
<
uint8_t
>
(
aAlign
)
;
return
true
;
}
auto
GetAlign
(
)
const
{
return
mAlign
;
}
bool
SetMeetOrSlice
(
uint16_t
aMeetOrSlice
)
{
if
(
aMeetOrSlice
<
SVG_MEETORSLICE_MIN_VALID
|
|
aMeetOrSlice
>
SVG_MEETORSLICE_MAX_VALID
)
return
false
;
mMeetOrSlice
=
static_cast
<
uint8_t
>
(
aMeetOrSlice
)
;
return
true
;
}
auto
GetMeetOrSlice
(
)
const
{
return
mMeetOrSlice
;
}
PLDHashNumber
Hash
(
)
const
{
return
HashGeneric
(
mAlign
mMeetOrSlice
)
;
}
private
:
uint8_t
mAlign
;
uint8_t
mMeetOrSlice
;
}
;
namespace
dom
{
class
DOMSVGPreserveAspectRatio
final
:
public
nsWrapperCache
{
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
DOMSVGPreserveAspectRatio
)
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
DOMSVGPreserveAspectRatio
)
DOMSVGPreserveAspectRatio
(
SVGAnimatedPreserveAspectRatio
*
aVal
SVGElement
*
aSVGElement
bool
aIsBaseValue
)
:
mVal
(
aVal
)
mSVGElement
(
aSVGElement
)
mIsBaseValue
(
aIsBaseValue
)
{
}
SVGElement
*
GetParentObject
(
)
const
{
return
mSVGElement
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
uint16_t
Align
(
)
;
void
SetAlign
(
uint16_t
aAlign
ErrorResult
&
aRv
)
;
uint16_t
MeetOrSlice
(
)
;
void
SetMeetOrSlice
(
uint16_t
aMeetOrSlice
ErrorResult
&
aRv
)
;
protected
:
~
DOMSVGPreserveAspectRatio
(
)
;
SVGAnimatedPreserveAspectRatio
*
mVal
;
RefPtr
<
SVGElement
>
mSVGElement
;
const
bool
mIsBaseValue
;
}
;
}
}
#
endif
