#
include
"
SVGPathData
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsString
.
h
"
#
include
"
SVGPathDataParser
.
h
"
#
include
<
stdarg
.
h
>
#
include
"
nsStyleConsts
.
h
"
#
include
"
SVGContentUtils
.
h
"
#
include
"
SVGGeometryElement
.
h
"
#
include
"
SVGPathSegUtils
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
:
:
dom
:
:
SVGPathSeg_Binding
;
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
static
inline
bool
IsMoveto
(
uint16_t
aSegType
)
{
return
aSegType
=
=
PATHSEG_MOVETO_ABS
|
|
aSegType
=
=
PATHSEG_MOVETO_REL
;
}
static
inline
bool
IsValidType
(
uint16_t
aSegType
)
{
return
SVGPathSegUtils
:
:
IsValidType
(
aSegType
)
;
}
static
inline
bool
IsClosePath
(
uint16_t
aSegType
)
{
return
aSegType
=
=
PATHSEG_CLOSEPATH
;
}
nsresult
SVGPathData
:
:
CopyFrom
(
const
SVGPathData
&
rhs
)
{
if
(
!
mData
.
Assign
(
rhs
.
mData
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
SVGPathData
:
:
GetValueAsString
(
nsAString
&
aValue
)
const
{
aValue
.
Truncate
(
)
;
if
(
!
Length
(
)
)
{
return
;
}
uint32_t
i
=
0
;
for
(
;
;
)
{
nsAutoString
segAsString
;
SVGPathSegUtils
:
:
GetValueAsString
(
&
mData
[
i
]
segAsString
)
;
aValue
.
Append
(
segAsString
)
;
i
+
=
1
+
SVGPathSegUtils
:
:
ArgCountForType
(
mData
[
i
]
)
;
if
(
i
>
=
mData
.
Length
(
)
)
{
MOZ_ASSERT
(
i
=
=
mData
.
Length
(
)
"
Very
very
bad
-
mData
corrupt
"
)
;
return
;
}
aValue
.
Append
(
'
'
)
;
}
}
nsresult
SVGPathData
:
:
SetValueFromString
(
const
nsAString
&
aValue
)
{
SVGPathDataParser
pathParser
(
aValue
this
)
;
return
pathParser
.
Parse
(
)
?
NS_OK
:
NS_ERROR_DOM_SYNTAX_ERR
;
}
nsresult
SVGPathData
:
:
AppendSeg
(
uint32_t
aType
.
.
.
)
{
uint32_t
oldLength
=
mData
.
Length
(
)
;
uint32_t
newLength
=
oldLength
+
1
+
SVGPathSegUtils
:
:
ArgCountForType
(
aType
)
;
if
(
!
mData
.
SetLength
(
newLength
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mData
[
oldLength
]
=
SVGPathSegUtils
:
:
EncodeType
(
aType
)
;
va_list
args
;
va_start
(
args
aType
)
;
for
(
uint32_t
i
=
oldLength
+
1
;
i
<
newLength
;
+
+
i
)
{
mData
[
i
]
=
float
(
va_arg
(
args
double
)
)
;
}
va_end
(
args
)
;
return
NS_OK
;
}
float
SVGPathData
:
:
GetPathLength
(
)
const
{
SVGPathTraversalState
state
;
uint32_t
i
=
0
;
while
(
i
<
mData
.
Length
(
)
)
{
SVGPathSegUtils
:
:
TraversePathSegment
(
&
mData
[
i
]
state
)
;
i
+
=
1
+
SVGPathSegUtils
:
:
ArgCountForType
(
mData
[
i
]
)
;
}
MOZ_ASSERT
(
i
=
=
mData
.
Length
(
)
"
Very
very
bad
-
mData
corrupt
"
)
;
return
state
.
length
;
}
#
ifdef
DEBUG
uint32_t
SVGPathData
:
:
CountItems
(
)
const
{
uint32_t
i
=
0
count
=
0
;
while
(
i
<
mData
.
Length
(
)
)
{
i
+
=
1
+
SVGPathSegUtils
:
:
ArgCountForType
(
mData
[
i
]
)
;
count
+
+
;
}
MOZ_ASSERT
(
i
=
=
mData
.
Length
(
)
"
Very
very
bad
-
mData
corrupt
"
)
;
return
count
;
}
#
endif
bool
SVGPathData
:
:
GetDistancesFromOriginToEndsOfVisibleSegments
(
FallibleTArray
<
double
>
*
aOutput
)
const
{
SVGPathTraversalState
state
;
aOutput
-
>
Clear
(
)
;
uint32_t
i
=
0
;
while
(
i
<
mData
.
Length
(
)
)
{
uint32_t
segType
=
SVGPathSegUtils
:
:
DecodeType
(
mData
[
i
]
)
;
SVGPathSegUtils
:
:
TraversePathSegment
(
&
mData
[
i
]
state
)
;
if
(
!
std
:
:
isfinite
(
state
.
length
)
)
{
return
false
;
}
if
(
i
=
=
0
|
|
!
IsMoveto
(
segType
)
)
{
if
(
!
aOutput
-
>
AppendElement
(
state
.
length
fallible
)
)
{
return
false
;
}
}
i
+
=
1
+
SVGPathSegUtils
:
:
ArgCountForType
(
segType
)
;
}
MOZ_ASSERT
(
i
=
=
mData
.
Length
(
)
"
Very
very
bad
-
mData
corrupt
?
"
)
;
return
true
;
}
bool
SVGPathData
:
:
GetDistancesFromOriginToEndsOfVisibleSegments
(
Span
<
const
StylePathCommand
>
aPath
FallibleTArray
<
double
>
*
aOutput
)
{
SVGPathTraversalState
state
;
aOutput
-
>
Clear
(
)
;
bool
firstMoveToIsChecked
=
false
;
for
(
const
auto
&
cmd
:
aPath
)
{
SVGPathSegUtils
:
:
TraversePathSegment
(
cmd
state
)
;
if
(
!
std
:
:
isfinite
(
state
.
length
)
)
{
return
false
;
}
if
(
!
cmd
.
IsMove
(
)
|
|
!
firstMoveToIsChecked
)
{
if
(
!
aOutput
-
>
AppendElement
(
state
.
length
fallible
)
)
{
return
false
;
}
}
if
(
cmd
.
IsMove
(
)
&
&
!
firstMoveToIsChecked
)
{
firstMoveToIsChecked
=
true
;
}
}
return
true
;
}
uint32_t
SVGPathData
:
:
GetPathSegAtLength
(
float
aDistance
)
const
{
uint32_t
i
=
0
segIndex
=
0
;
SVGPathTraversalState
state
;
while
(
i
<
mData
.
Length
(
)
)
{
SVGPathSegUtils
:
:
TraversePathSegment
(
&
mData
[
i
]
state
)
;
if
(
state
.
length
>
=
aDistance
)
{
return
segIndex
;
}
i
+
=
1
+
SVGPathSegUtils
:
:
ArgCountForType
(
mData
[
i
]
)
;
segIndex
+
+
;
}
MOZ_ASSERT
(
i
=
=
mData
.
Length
(
)
"
Very
very
bad
-
mData
corrupt
"
)
;
return
std
:
:
max
(
1U
segIndex
)
-
1
;
}
uint32_t
SVGPathData
:
:
GetPathSegAtLength
(
Span
<
const
StylePathCommand
>
aPath
float
aDistance
)
{
uint32_t
segIndex
=
0
;
SVGPathTraversalState
state
;
for
(
const
auto
&
cmd
:
aPath
)
{
SVGPathSegUtils
:
:
TraversePathSegment
(
cmd
state
)
;
if
(
state
.
length
>
=
aDistance
)
{
return
segIndex
;
}
segIndex
+
+
;
}
return
std
:
:
max
(
1U
segIndex
)
-
1
;
}
static
void
ApproximateZeroLengthSubpathSquareCaps
(
PathBuilder
*
aPB
const
Point
&
aPoint
Float
aStrokeWidth
)
{
MOZ_ASSERT
(
aStrokeWidth
>
0
.
0f
"
Make
the
caller
check
for
this
or
check
it
here
"
)
;
Float
tinyLength
=
aStrokeWidth
/
SVG_ZERO_LENGTH_PATH_FIX_FACTOR
;
aPB
-
>
LineTo
(
aPoint
+
Point
(
tinyLength
0
)
)
;
aPB
-
>
MoveTo
(
aPoint
)
;
}
#
define
MAYBE_APPROXIMATE_ZERO_LENGTH_SUBPATH_SQUARE_CAPS_TO_DT
\
do
{
\
if
(
!
subpathHasLength
&
&
hasLineCaps
&
&
aStrokeWidth
>
0
&
&
\
subpathContainsNonMoveTo
&
&
IsValidType
(
prevSegType
)
&
&
\
(
!
IsMoveto
(
prevSegType
)
|
|
IsClosePath
(
segType
)
)
)
{
\
ApproximateZeroLengthSubpathSquareCaps
(
aBuilder
segStart
\
aStrokeWidth
)
;
\
}
\
}
while
(
0
)
already_AddRefed
<
Path
>
SVGPathData
:
:
BuildPath
(
PathBuilder
*
aBuilder
StyleStrokeLinecap
aStrokeLineCap
Float
aStrokeWidth
)
const
{
if
(
mData
.
IsEmpty
(
)
|
|
!
IsMoveto
(
SVGPathSegUtils
:
:
DecodeType
(
mData
[
0
]
)
)
)
{
return
nullptr
;
}
bool
hasLineCaps
=
aStrokeLineCap
!
=
StyleStrokeLinecap
:
:
Butt
;
bool
subpathHasLength
=
false
;
bool
subpathContainsNonMoveTo
=
false
;
uint32_t
segType
=
PATHSEG_UNKNOWN
;
uint32_t
prevSegType
=
PATHSEG_UNKNOWN
;
Point
pathStart
(
0
.
0
0
.
0
)
;
Point
segStart
(
0
.
0
0
.
0
)
;
Point
segEnd
;
Point
cp1
cp2
;
Point
tcp1
tcp2
;
uint32_t
i
=
0
;
while
(
i
<
mData
.
Length
(
)
)
{
segType
=
SVGPathSegUtils
:
:
DecodeType
(
mData
[
i
+
+
]
)
;
uint32_t
argCount
=
SVGPathSegUtils
:
:
ArgCountForType
(
segType
)
;
switch
(
segType
)
{
case
PATHSEG_CLOSEPATH
:
subpathContainsNonMoveTo
=
true
;
MAYBE_APPROXIMATE_ZERO_LENGTH_SUBPATH_SQUARE_CAPS_TO_DT
;
segEnd
=
pathStart
;
aBuilder
-
>
Close
(
)
;
break
;
case
PATHSEG_MOVETO_ABS
:
MAYBE_APPROXIMATE_ZERO_LENGTH_SUBPATH_SQUARE_CAPS_TO_DT
;
pathStart
=
segEnd
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
aBuilder
-
>
MoveTo
(
segEnd
)
;
subpathHasLength
=
false
;
break
;
case
PATHSEG_MOVETO_REL
:
MAYBE_APPROXIMATE_ZERO_LENGTH_SUBPATH_SQUARE_CAPS_TO_DT
;
pathStart
=
segEnd
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
aBuilder
-
>
MoveTo
(
segEnd
)
;
subpathHasLength
=
false
;
break
;
case
PATHSEG_LINETO_ABS
:
segEnd
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
segEnd
)
;
}
break
;
case
PATHSEG_LINETO_REL
:
segEnd
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_CUBIC_ABS
:
cp1
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
cp2
=
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
segEnd
=
Point
(
mData
[
i
+
4
]
mData
[
i
+
5
]
)
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
|
|
segEnd
!
=
cp2
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
cp1
cp2
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_CUBIC_REL
:
cp1
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
cp2
=
segStart
+
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
segEnd
=
segStart
+
Point
(
mData
[
i
+
4
]
mData
[
i
+
5
]
)
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
|
|
segEnd
!
=
cp2
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
cp1
cp2
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_QUADRATIC_ABS
:
cp1
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
tcp1
=
segStart
+
(
cp1
-
segStart
)
*
2
/
3
;
segEnd
=
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
tcp2
=
cp1
+
(
segEnd
-
cp1
)
/
3
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
tcp1
tcp2
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_QUADRATIC_REL
:
cp1
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
tcp1
=
segStart
+
(
cp1
-
segStart
)
*
2
/
3
;
segEnd
=
segStart
+
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
tcp2
=
cp1
+
(
segEnd
-
cp1
)
/
3
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
tcp1
tcp2
segEnd
)
;
}
break
;
case
PATHSEG_ARC_ABS
:
case
PATHSEG_ARC_REL
:
{
Point
radii
(
mData
[
i
]
mData
[
i
+
1
]
)
;
segEnd
=
Point
(
mData
[
i
+
5
]
mData
[
i
+
6
]
)
;
if
(
segType
=
=
PATHSEG_ARC_REL
)
{
segEnd
+
=
segStart
;
}
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
if
(
radii
.
x
=
=
0
.
0f
|
|
radii
.
y
=
=
0
.
0f
)
{
aBuilder
-
>
LineTo
(
segEnd
)
;
}
else
{
SVGArcConverter
converter
(
segStart
segEnd
radii
mData
[
i
+
2
]
mData
[
i
+
3
]
!
=
0
mData
[
i
+
4
]
!
=
0
)
;
while
(
converter
.
GetNextSegment
(
&
cp1
&
cp2
&
segEnd
)
)
{
aBuilder
-
>
BezierTo
(
cp1
cp2
segEnd
)
;
}
}
}
break
;
}
case
PATHSEG_LINETO_HORIZONTAL_ABS
:
segEnd
=
Point
(
mData
[
i
]
segStart
.
y
)
;
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
segEnd
)
;
}
break
;
case
PATHSEG_LINETO_HORIZONTAL_REL
:
segEnd
=
segStart
+
Point
(
mData
[
i
]
0
.
0f
)
;
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
segEnd
)
;
}
break
;
case
PATHSEG_LINETO_VERTICAL_ABS
:
segEnd
=
Point
(
segStart
.
x
mData
[
i
]
)
;
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
segEnd
)
;
}
break
;
case
PATHSEG_LINETO_VERTICAL_REL
:
segEnd
=
segStart
+
Point
(
0
.
0f
mData
[
i
]
)
;
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_CUBIC_SMOOTH_ABS
:
cp1
=
SVGPathSegUtils
:
:
IsCubicType
(
prevSegType
)
?
segStart
*
2
-
cp2
:
segStart
;
cp2
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
segEnd
=
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
|
|
segEnd
!
=
cp2
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
cp1
cp2
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_CUBIC_SMOOTH_REL
:
cp1
=
SVGPathSegUtils
:
:
IsCubicType
(
prevSegType
)
?
segStart
*
2
-
cp2
:
segStart
;
cp2
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
segEnd
=
segStart
+
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
|
|
segEnd
!
=
cp2
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
cp1
cp2
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS
:
cp1
=
SVGPathSegUtils
:
:
IsQuadraticType
(
prevSegType
)
?
segStart
*
2
-
cp1
:
segStart
;
tcp1
=
segStart
+
(
cp1
-
segStart
)
*
2
/
3
;
segEnd
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
tcp2
=
cp1
+
(
segEnd
-
cp1
)
/
3
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
tcp1
tcp2
segEnd
)
;
}
break
;
case
PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL
:
cp1
=
SVGPathSegUtils
:
:
IsQuadraticType
(
prevSegType
)
?
segStart
*
2
-
cp1
:
segStart
;
tcp1
=
segStart
+
(
cp1
-
segStart
)
*
2
/
3
;
segEnd
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
tcp2
=
cp1
+
(
segEnd
-
cp1
)
/
3
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
tcp1
tcp2
segEnd
)
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Bad
path
segment
type
"
)
;
return
nullptr
;
}
subpathContainsNonMoveTo
=
!
IsMoveto
(
segType
)
;
i
+
=
argCount
;
prevSegType
=
segType
;
segStart
=
segEnd
;
}
MOZ_ASSERT
(
i
=
=
mData
.
Length
(
)
"
Very
very
bad
-
mData
corrupt
"
)
;
MOZ_ASSERT
(
prevSegType
=
=
segType
"
prevSegType
should
be
left
at
the
final
segType
"
)
;
MAYBE_APPROXIMATE_ZERO_LENGTH_SUBPATH_SQUARE_CAPS_TO_DT
;
return
aBuilder
-
>
Finish
(
)
;
}
#
undef
MAYBE_APPROXIMATE_ZERO_LENGTH_SUBPATH_SQUARE_CAPS_TO_DT
already_AddRefed
<
Path
>
SVGPathData
:
:
BuildPathForMeasuring
(
)
const
{
RefPtr
<
DrawTarget
>
drawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
RefPtr
<
PathBuilder
>
builder
=
drawTarget
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_WINDING
)
;
return
BuildPath
(
builder
StyleStrokeLinecap
:
:
Butt
0
)
;
}
already_AddRefed
<
Path
>
SVGPathData
:
:
BuildPathForMeasuring
(
Span
<
const
StylePathCommand
>
aPath
)
{
RefPtr
<
DrawTarget
>
drawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
RefPtr
<
PathBuilder
>
builder
=
drawTarget
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_WINDING
)
;
return
BuildPath
(
aPath
builder
StyleStrokeLinecap
:
:
Butt
0
)
;
}
static
inline
StyleCSSFloat
GetRotate
(
const
StyleCSSFloat
&
aAngle
)
{
return
aAngle
;
}
static
inline
StyleCSSFloat
GetRotate
(
const
StyleAngle
&
aAngle
)
{
return
aAngle
.
ToDegrees
(
)
;
}
static
inline
StyleCSSFloat
Resolve
(
const
StyleCSSFloat
&
aValue
CSSCoord
aBasis
)
{
return
aValue
;
}
static
inline
StyleCSSFloat
Resolve
(
const
LengthPercentage
&
aValue
CSSCoord
aBasis
)
{
return
aValue
.
ResolveToCSSPixels
(
aBasis
)
;
}
template
<
typename
Angle
typename
LP
>
static
already_AddRefed
<
Path
>
BuildPathInternal
(
Span
<
const
StyleGenericShapeCommand
<
Angle
LP
>
>
aPath
PathBuilder
*
aBuilder
StyleStrokeLinecap
aStrokeLineCap
Float
aStrokeWidth
const
CSSSize
&
aPercentageBasis
const
Point
&
aOffset
float
aZoomFactor
)
{
using
Command
=
StyleGenericShapeCommand
<
Angle
LP
>
;
if
(
aPath
.
IsEmpty
(
)
|
|
!
aPath
[
0
]
.
IsMove
(
)
)
{
return
nullptr
;
}
bool
hasLineCaps
=
aStrokeLineCap
!
=
StyleStrokeLinecap
:
:
Butt
;
bool
subpathHasLength
=
false
;
bool
subpathContainsNonMoveTo
=
false
;
const
Command
*
seg
=
nullptr
;
const
Command
*
prevSeg
=
nullptr
;
Point
pathStart
(
0
.
0
0
.
0
)
;
Point
segStart
(
0
.
0
0
.
0
)
;
Point
segEnd
;
Point
cp1
cp2
;
Point
tcp1
tcp2
;
auto
maybeApproximateZeroLengthSubpathSquareCaps
=
[
&
]
(
const
Command
*
aPrevSeg
const
Command
*
aSeg
)
{
if
(
!
subpathHasLength
&
&
hasLineCaps
&
&
aStrokeWidth
>
0
&
&
subpathContainsNonMoveTo
&
&
aPrevSeg
&
&
aSeg
&
&
(
!
aPrevSeg
-
>
IsMove
(
)
|
|
aSeg
-
>
IsClose
(
)
)
)
{
ApproximateZeroLengthSubpathSquareCaps
(
aBuilder
segStart
aStrokeWidth
)
;
}
}
;
auto
scale
=
[
aOffset
aZoomFactor
]
(
const
Point
&
p
)
{
return
Point
(
p
.
x
*
aZoomFactor
p
.
y
*
aZoomFactor
)
+
aOffset
;
}
;
for
(
const
auto
&
cmd
:
aPath
)
{
seg
=
&
cmd
;
switch
(
cmd
.
tag
)
{
case
Command
:
:
Tag
:
:
Close
:
subpathContainsNonMoveTo
=
true
;
maybeApproximateZeroLengthSubpathSquareCaps
(
prevSeg
seg
)
;
segEnd
=
pathStart
;
aBuilder
-
>
Close
(
)
;
break
;
case
Command
:
:
Tag
:
:
Move
:
{
maybeApproximateZeroLengthSubpathSquareCaps
(
prevSeg
seg
)
;
const
Point
&
p
=
cmd
.
move
.
point
.
ToGfxPoint
(
aPercentageBasis
)
;
pathStart
=
segEnd
=
cmd
.
move
.
by_to
=
=
StyleByTo
:
:
To
?
p
:
segStart
+
p
;
aBuilder
-
>
MoveTo
(
scale
(
segEnd
)
)
;
subpathHasLength
=
false
;
break
;
}
case
Command
:
:
Tag
:
:
Line
:
{
const
Point
&
p
=
cmd
.
line
.
point
.
ToGfxPoint
(
aPercentageBasis
)
;
segEnd
=
cmd
.
line
.
by_to
=
=
StyleByTo
:
:
To
?
p
:
segStart
+
p
;
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
scale
(
segEnd
)
)
;
}
break
;
}
case
Command
:
:
Tag
:
:
CubicCurve
:
cp1
=
cmd
.
cubic_curve
.
control1
.
ToGfxPoint
(
aPercentageBasis
)
;
cp2
=
cmd
.
cubic_curve
.
control2
.
ToGfxPoint
(
aPercentageBasis
)
;
segEnd
=
cmd
.
cubic_curve
.
point
.
ToGfxPoint
(
aPercentageBasis
)
;
if
(
cmd
.
cubic_curve
.
by_to
=
=
StyleByTo
:
:
By
)
{
cp1
+
=
segStart
;
cp2
+
=
segStart
;
segEnd
+
=
segStart
;
}
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
|
|
segEnd
!
=
cp2
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
scale
(
cp1
)
scale
(
cp2
)
scale
(
segEnd
)
)
;
}
break
;
case
Command
:
:
Tag
:
:
QuadCurve
:
cp1
=
cmd
.
quad_curve
.
control1
.
ToGfxPoint
(
aPercentageBasis
)
;
segEnd
=
cmd
.
quad_curve
.
point
.
ToGfxPoint
(
aPercentageBasis
)
;
if
(
cmd
.
quad_curve
.
by_to
=
=
StyleByTo
:
:
By
)
{
cp1
+
=
segStart
;
segEnd
+
=
segStart
;
}
tcp1
=
segStart
+
(
cp1
-
segStart
)
*
2
/
3
;
tcp2
=
cp1
+
(
segEnd
-
cp1
)
/
3
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
scale
(
tcp1
)
scale
(
tcp2
)
scale
(
segEnd
)
)
;
}
break
;
case
Command
:
:
Tag
:
:
Arc
:
{
const
auto
&
arc
=
cmd
.
arc
;
const
Point
&
radii
=
arc
.
radii
.
ToGfxPoint
(
aPercentageBasis
)
;
segEnd
=
arc
.
point
.
ToGfxPoint
(
aPercentageBasis
)
;
if
(
arc
.
by_to
=
=
StyleByTo
:
:
By
)
{
segEnd
+
=
segStart
;
}
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
if
(
radii
.
x
=
=
0
.
0f
|
|
radii
.
y
=
=
0
.
0f
)
{
aBuilder
-
>
LineTo
(
scale
(
segEnd
)
)
;
}
else
{
const
bool
arc_is_large
=
arc
.
arc_size
=
=
StyleArcSize
:
:
Large
;
const
bool
arc_is_cw
=
arc
.
arc_sweep
=
=
StyleArcSweep
:
:
Cw
;
SVGArcConverter
converter
(
segStart
segEnd
radii
GetRotate
(
arc
.
rotate
)
arc_is_large
arc_is_cw
)
;
while
(
converter
.
GetNextSegment
(
&
cp1
&
cp2
&
segEnd
)
)
{
aBuilder
-
>
BezierTo
(
scale
(
cp1
)
scale
(
cp2
)
scale
(
segEnd
)
)
;
}
}
}
break
;
}
case
Command
:
:
Tag
:
:
HLine
:
{
const
float
x
=
Resolve
(
cmd
.
h_line
.
x
aPercentageBasis
.
width
)
;
if
(
cmd
.
h_line
.
by_to
=
=
StyleByTo
:
:
To
)
{
segEnd
=
Point
(
x
segStart
.
y
)
;
}
else
{
segEnd
=
segStart
+
Point
(
x
0
.
0f
)
;
}
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
scale
(
segEnd
)
)
;
}
break
;
}
case
Command
:
:
Tag
:
:
VLine
:
{
const
float
y
=
Resolve
(
cmd
.
v_line
.
y
aPercentageBasis
.
height
)
;
if
(
cmd
.
v_line
.
by_to
=
=
StyleByTo
:
:
To
)
{
segEnd
=
Point
(
segStart
.
x
y
)
;
}
else
{
segEnd
=
segStart
+
Point
(
0
.
0f
y
)
;
}
if
(
segEnd
!
=
segStart
)
{
subpathHasLength
=
true
;
aBuilder
-
>
LineTo
(
scale
(
segEnd
)
)
;
}
break
;
}
case
Command
:
:
Tag
:
:
SmoothCubic
:
cp1
=
prevSeg
&
&
prevSeg
-
>
IsCubicType
(
)
?
segStart
*
2
-
cp2
:
segStart
;
cp2
=
cmd
.
smooth_cubic
.
control2
.
ToGfxPoint
(
aPercentageBasis
)
;
segEnd
=
cmd
.
smooth_cubic
.
point
.
ToGfxPoint
(
aPercentageBasis
)
;
if
(
cmd
.
smooth_cubic
.
by_to
=
=
StyleByTo
:
:
By
)
{
cp2
+
=
segStart
;
segEnd
+
=
segStart
;
}
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
|
|
segEnd
!
=
cp2
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
scale
(
cp1
)
scale
(
cp2
)
scale
(
segEnd
)
)
;
}
break
;
case
Command
:
:
Tag
:
:
SmoothQuad
:
{
cp1
=
prevSeg
&
&
prevSeg
-
>
IsQuadraticType
(
)
?
segStart
*
2
-
cp1
:
segStart
;
tcp1
=
segStart
+
(
cp1
-
segStart
)
*
2
/
3
;
const
Point
&
p
=
cmd
.
smooth_quad
.
point
.
ToGfxPoint
(
aPercentageBasis
)
;
segEnd
=
cmd
.
smooth_quad
.
by_to
=
=
StyleByTo
:
:
To
?
p
:
segStart
+
p
;
tcp2
=
cp1
+
(
segEnd
-
cp1
)
/
3
;
if
(
segEnd
!
=
segStart
|
|
segEnd
!
=
cp1
)
{
subpathHasLength
=
true
;
aBuilder
-
>
BezierTo
(
scale
(
tcp1
)
scale
(
tcp2
)
scale
(
segEnd
)
)
;
}
break
;
}
}
subpathContainsNonMoveTo
=
!
cmd
.
IsMove
(
)
;
prevSeg
=
seg
;
segStart
=
segEnd
;
}
MOZ_ASSERT
(
prevSeg
=
=
seg
"
prevSegType
should
be
left
at
the
final
segType
"
)
;
maybeApproximateZeroLengthSubpathSquareCaps
(
prevSeg
seg
)
;
return
aBuilder
-
>
Finish
(
)
;
}
already_AddRefed
<
Path
>
SVGPathData
:
:
BuildPath
(
Span
<
const
StylePathCommand
>
aPath
PathBuilder
*
aBuilder
StyleStrokeLinecap
aStrokeLineCap
Float
aStrokeWidth
const
CSSSize
&
aBasis
const
gfx
:
:
Point
&
aOffset
float
aZoomFactor
)
{
return
BuildPathInternal
(
aPath
aBuilder
aStrokeLineCap
aStrokeWidth
aBasis
aOffset
aZoomFactor
)
;
}
already_AddRefed
<
Path
>
SVGPathData
:
:
BuildPath
(
Span
<
const
StyleShapeCommand
>
aShape
PathBuilder
*
aBuilder
StyleStrokeLinecap
aStrokeLineCap
Float
aStrokeWidth
const
CSSSize
&
aBasis
const
gfx
:
:
Point
&
aOffset
float
aZoomFactor
)
{
return
BuildPathInternal
(
aShape
aBuilder
aStrokeLineCap
aStrokeWidth
aBasis
aOffset
aZoomFactor
)
;
}
static
double
AngleOfVector
(
const
Point
&
aVector
)
{
return
(
aVector
!
=
Point
(
0
.
0
0
.
0
)
)
?
atan2
(
aVector
.
y
aVector
.
x
)
:
0
.
0
;
}
static
float
AngleOfVector
(
const
Point
&
cp1
const
Point
&
cp2
)
{
return
static_cast
<
float
>
(
AngleOfVector
(
cp1
-
cp2
)
)
;
}
static
std
:
:
tuple
<
float
float
float
float
>
ComputeSegAnglesAndCorrectRadii
(
const
Point
&
aSegStart
const
Point
&
aSegEnd
const
float
aAngle
const
bool
aLargeArcFlag
const
bool
aSweepFlag
const
float
aRx
const
float
aRy
)
{
float
rx
=
fabs
(
aRx
)
;
float
ry
=
fabs
(
aRy
)
;
const
float
angle
=
static_cast
<
float
>
(
aAngle
*
M_PI
/
180
.
0
)
;
double
x1p
=
cos
(
angle
)
*
(
aSegStart
.
x
-
aSegEnd
.
x
)
/
2
.
0
+
sin
(
angle
)
*
(
aSegStart
.
y
-
aSegEnd
.
y
)
/
2
.
0
;
double
y1p
=
-
sin
(
angle
)
*
(
aSegStart
.
x
-
aSegEnd
.
x
)
/
2
.
0
+
cos
(
angle
)
*
(
aSegStart
.
y
-
aSegEnd
.
y
)
/
2
.
0
;
double
root
;
double
numerator
=
rx
*
rx
*
ry
*
ry
-
rx
*
rx
*
y1p
*
y1p
-
ry
*
ry
*
x1p
*
x1p
;
if
(
numerator
>
=
0
.
0
)
{
root
=
sqrt
(
numerator
/
(
rx
*
rx
*
y1p
*
y1p
+
ry
*
ry
*
x1p
*
x1p
)
)
;
if
(
aLargeArcFlag
=
=
aSweepFlag
)
root
=
-
root
;
}
else
{
double
lamedh
=
1
.
0
-
numerator
/
(
rx
*
rx
*
ry
*
ry
)
;
double
s
=
sqrt
(
lamedh
)
;
rx
=
static_cast
<
float
>
(
(
double
)
rx
*
s
)
;
ry
=
static_cast
<
float
>
(
(
double
)
ry
*
s
)
;
root
=
0
.
0
;
}
double
cxp
=
root
*
rx
*
y1p
/
ry
;
double
cyp
=
-
root
*
ry
*
x1p
/
rx
;
double
theta
=
AngleOfVector
(
Point
(
static_cast
<
float
>
(
(
x1p
-
cxp
)
/
rx
)
static_cast
<
float
>
(
(
y1p
-
cyp
)
/
ry
)
)
)
;
double
delta
=
AngleOfVector
(
Point
(
static_cast
<
float
>
(
(
-
x1p
-
cxp
)
/
rx
)
static_cast
<
float
>
(
(
-
y1p
-
cyp
)
/
ry
)
)
)
-
theta
;
if
(
!
aSweepFlag
&
&
delta
>
0
)
{
delta
-
=
2
.
0
*
M_PI
;
}
else
if
(
aSweepFlag
&
&
delta
<
0
)
{
delta
+
=
2
.
0
*
M_PI
;
}
double
tx1
ty1
tx2
ty2
;
tx1
=
-
cos
(
angle
)
*
rx
*
sin
(
theta
)
-
sin
(
angle
)
*
ry
*
cos
(
theta
)
;
ty1
=
-
sin
(
angle
)
*
rx
*
sin
(
theta
)
+
cos
(
angle
)
*
ry
*
cos
(
theta
)
;
tx2
=
-
cos
(
angle
)
*
rx
*
sin
(
theta
+
delta
)
-
sin
(
angle
)
*
ry
*
cos
(
theta
+
delta
)
;
ty2
=
-
sin
(
angle
)
*
rx
*
sin
(
theta
+
delta
)
+
cos
(
angle
)
*
ry
*
cos
(
theta
+
delta
)
;
if
(
delta
<
0
.
0f
)
{
tx1
=
-
tx1
;
ty1
=
-
ty1
;
tx2
=
-
tx2
;
ty2
=
-
ty2
;
}
return
{
rx
ry
static_cast
<
float
>
(
atan2
(
ty1
tx1
)
)
static_cast
<
float
>
(
atan2
(
ty2
tx2
)
)
}
;
}
void
SVGPathData
:
:
GetMarkerPositioningData
(
nsTArray
<
SVGMark
>
*
aMarks
)
const
{
Point
pathStart
(
0
.
0
0
.
0
)
;
float
pathStartAngle
=
0
.
0f
;
uint32_t
pathStartIndex
=
0
;
uint16_t
prevSegType
=
PATHSEG_UNKNOWN
;
Point
prevSegEnd
(
0
.
0
0
.
0
)
;
float
prevSegEndAngle
=
0
.
0f
;
Point
prevCP
;
uint32_t
i
=
0
;
while
(
i
<
mData
.
Length
(
)
)
{
uint16_t
segType
=
SVGPathSegUtils
:
:
DecodeType
(
mData
[
i
+
+
]
)
;
Point
&
segStart
=
prevSegEnd
;
Point
segEnd
;
float
segStartAngle
segEndAngle
;
switch
(
segType
)
{
case
PATHSEG_CLOSEPATH
:
segEnd
=
pathStart
;
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
case
PATHSEG_MOVETO_ABS
:
case
PATHSEG_MOVETO_REL
:
if
(
segType
=
=
PATHSEG_MOVETO_ABS
)
{
segEnd
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
}
else
{
segEnd
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
}
pathStart
=
segEnd
;
pathStartIndex
=
aMarks
-
>
Length
(
)
;
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
i
+
=
2
;
break
;
case
PATHSEG_LINETO_ABS
:
case
PATHSEG_LINETO_REL
:
if
(
segType
=
=
PATHSEG_LINETO_ABS
)
{
segEnd
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
}
else
{
segEnd
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
}
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
i
+
=
2
;
break
;
case
PATHSEG_CURVETO_CUBIC_ABS
:
case
PATHSEG_CURVETO_CUBIC_REL
:
{
Point
cp1
cp2
;
if
(
segType
=
=
PATHSEG_CURVETO_CUBIC_ABS
)
{
cp1
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
cp2
=
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
segEnd
=
Point
(
mData
[
i
+
4
]
mData
[
i
+
5
]
)
;
}
else
{
cp1
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
cp2
=
segStart
+
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
segEnd
=
segStart
+
Point
(
mData
[
i
+
4
]
mData
[
i
+
5
]
)
;
}
prevCP
=
cp2
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
(
cp1
=
=
cp2
?
segEnd
:
cp2
)
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp2
=
=
segEnd
?
(
cp1
=
=
cp2
?
segStart
:
cp1
)
:
cp2
)
;
i
+
=
6
;
break
;
}
case
PATHSEG_CURVETO_QUADRATIC_ABS
:
case
PATHSEG_CURVETO_QUADRATIC_REL
:
{
Point
cp1
;
if
(
segType
=
=
PATHSEG_CURVETO_QUADRATIC_ABS
)
{
cp1
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
segEnd
=
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
}
else
{
cp1
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
segEnd
=
segStart
+
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
}
prevCP
=
cp1
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
segEnd
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp1
=
=
segEnd
?
segStart
:
cp1
)
;
i
+
=
4
;
break
;
}
case
PATHSEG_ARC_ABS
:
case
PATHSEG_ARC_REL
:
{
float
rx
=
mData
[
i
]
;
float
ry
=
mData
[
i
+
1
]
;
float
angle
=
mData
[
i
+
2
]
;
bool
largeArcFlag
=
mData
[
i
+
3
]
!
=
0
.
0f
;
bool
sweepFlag
=
mData
[
i
+
4
]
!
=
0
.
0f
;
if
(
segType
=
=
PATHSEG_ARC_ABS
)
{
segEnd
=
Point
(
mData
[
i
+
5
]
mData
[
i
+
6
]
)
;
}
else
{
segEnd
=
segStart
+
Point
(
mData
[
i
+
5
]
mData
[
i
+
6
]
)
;
}
if
(
segStart
=
=
segEnd
)
{
i
+
=
7
;
continue
;
}
if
(
rx
=
=
0
.
0
|
|
ry
=
=
0
.
0
)
{
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
i
+
=
7
;
break
;
}
std
:
:
tie
(
rx
ry
segStartAngle
segEndAngle
)
=
ComputeSegAnglesAndCorrectRadii
(
segStart
segEnd
angle
largeArcFlag
sweepFlag
rx
ry
)
;
i
+
=
7
;
break
;
}
case
PATHSEG_LINETO_HORIZONTAL_ABS
:
case
PATHSEG_LINETO_HORIZONTAL_REL
:
if
(
segType
=
=
PATHSEG_LINETO_HORIZONTAL_ABS
)
{
segEnd
=
Point
(
mData
[
i
+
+
]
segStart
.
y
)
;
}
else
{
segEnd
=
segStart
+
Point
(
mData
[
i
+
+
]
0
.
0f
)
;
}
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
case
PATHSEG_LINETO_VERTICAL_ABS
:
case
PATHSEG_LINETO_VERTICAL_REL
:
if
(
segType
=
=
PATHSEG_LINETO_VERTICAL_ABS
)
{
segEnd
=
Point
(
segStart
.
x
mData
[
i
+
+
]
)
;
}
else
{
segEnd
=
segStart
+
Point
(
0
.
0f
mData
[
i
+
+
]
)
;
}
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
case
PATHSEG_CURVETO_CUBIC_SMOOTH_ABS
:
case
PATHSEG_CURVETO_CUBIC_SMOOTH_REL
:
{
Point
cp1
=
SVGPathSegUtils
:
:
IsCubicType
(
prevSegType
)
?
segStart
*
2
-
prevCP
:
segStart
;
Point
cp2
;
if
(
segType
=
=
PATHSEG_CURVETO_CUBIC_SMOOTH_ABS
)
{
cp2
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
segEnd
=
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
}
else
{
cp2
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
segEnd
=
segStart
+
Point
(
mData
[
i
+
2
]
mData
[
i
+
3
]
)
;
}
prevCP
=
cp2
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
(
cp1
=
=
cp2
?
segEnd
:
cp2
)
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp2
=
=
segEnd
?
(
cp1
=
=
cp2
?
segStart
:
cp1
)
:
cp2
)
;
i
+
=
4
;
break
;
}
case
PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS
:
case
PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL
:
{
Point
cp1
=
SVGPathSegUtils
:
:
IsQuadraticType
(
prevSegType
)
?
segStart
*
2
-
prevCP
:
segStart
;
if
(
segType
=
=
PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS
)
{
segEnd
=
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
}
else
{
segEnd
=
segStart
+
Point
(
mData
[
i
]
mData
[
i
+
1
]
)
;
}
prevCP
=
cp1
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
segEnd
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp1
=
=
segEnd
?
segStart
:
cp1
)
;
i
+
=
2
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
segment
type
-
path
corruption
?
"
)
;
return
;
}
if
(
aMarks
-
>
Length
(
)
)
{
SVGMark
&
mark
=
aMarks
-
>
LastElement
(
)
;
if
(
!
IsMoveto
(
segType
)
&
&
IsMoveto
(
prevSegType
)
)
{
pathStartAngle
=
mark
.
angle
=
segStartAngle
;
}
else
if
(
IsMoveto
(
segType
)
&
&
!
IsMoveto
(
prevSegType
)
)
{
if
(
prevSegType
!
=
PATHSEG_CLOSEPATH
)
mark
.
angle
=
prevSegEndAngle
;
}
else
{
if
(
!
(
segType
=
=
PATHSEG_CLOSEPATH
&
&
prevSegType
=
=
PATHSEG_CLOSEPATH
)
)
mark
.
angle
=
SVGContentUtils
:
:
AngleBisect
(
prevSegEndAngle
segStartAngle
)
;
}
}
aMarks
-
>
AppendElement
(
SVGMark
(
static_cast
<
float
>
(
segEnd
.
x
)
static_cast
<
float
>
(
segEnd
.
y
)
0
.
0f
SVGMark
:
:
eMid
)
)
;
if
(
segType
=
=
PATHSEG_CLOSEPATH
&
&
prevSegType
!
=
PATHSEG_CLOSEPATH
)
{
aMarks
-
>
LastElement
(
)
.
angle
=
aMarks
-
>
ElementAt
(
pathStartIndex
)
.
angle
=
SVGContentUtils
:
:
AngleBisect
(
segEndAngle
pathStartAngle
)
;
}
prevSegType
=
segType
;
prevSegEnd
=
segEnd
;
prevSegEndAngle
=
segEndAngle
;
}
MOZ_ASSERT
(
i
=
=
mData
.
Length
(
)
"
Very
very
bad
-
mData
corrupt
"
)
;
if
(
aMarks
-
>
Length
(
)
)
{
if
(
prevSegType
!
=
PATHSEG_CLOSEPATH
)
{
aMarks
-
>
LastElement
(
)
.
angle
=
prevSegEndAngle
;
}
aMarks
-
>
LastElement
(
)
.
type
=
SVGMark
:
:
eEnd
;
aMarks
-
>
ElementAt
(
0
)
.
type
=
SVGMark
:
:
eStart
;
}
}
void
SVGPathData
:
:
GetMarkerPositioningData
(
Span
<
const
StylePathCommand
>
aPath
nsTArray
<
SVGMark
>
*
aMarks
)
{
if
(
aPath
.
IsEmpty
(
)
)
{
return
;
}
Point
pathStart
(
0
.
0
0
.
0
)
;
float
pathStartAngle
=
0
.
0f
;
uint32_t
pathStartIndex
=
0
;
const
StylePathCommand
*
prevSeg
=
nullptr
;
Point
prevSegEnd
(
0
.
0
0
.
0
)
;
float
prevSegEndAngle
=
0
.
0f
;
Point
prevCP
;
for
(
const
StylePathCommand
&
cmd
:
aPath
)
{
Point
&
segStart
=
prevSegEnd
;
Point
segEnd
;
float
segStartAngle
segEndAngle
;
switch
(
cmd
.
tag
)
{
case
StylePathCommand
:
:
Tag
:
:
Close
:
segEnd
=
pathStart
;
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
case
StylePathCommand
:
:
Tag
:
:
Move
:
{
const
Point
&
p
=
cmd
.
move
.
point
.
ToGfxPoint
(
)
;
pathStart
=
segEnd
=
cmd
.
move
.
by_to
=
=
StyleByTo
:
:
To
?
p
:
segStart
+
p
;
pathStartIndex
=
aMarks
-
>
Length
(
)
;
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
Line
:
{
const
Point
&
p
=
cmd
.
line
.
point
.
ToGfxPoint
(
)
;
segEnd
=
cmd
.
line
.
by_to
=
=
StyleByTo
:
:
To
?
p
:
segStart
+
p
;
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
CubicCurve
:
{
Point
cp1
=
cmd
.
cubic_curve
.
control1
.
ToGfxPoint
(
)
;
Point
cp2
=
cmd
.
cubic_curve
.
control2
.
ToGfxPoint
(
)
;
segEnd
=
cmd
.
cubic_curve
.
point
.
ToGfxPoint
(
)
;
if
(
cmd
.
cubic_curve
.
by_to
=
=
StyleByTo
:
:
By
)
{
cp1
+
=
segStart
;
cp2
+
=
segStart
;
segEnd
+
=
segStart
;
}
prevCP
=
cp2
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
(
cp1
=
=
cp2
?
segEnd
:
cp2
)
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp2
=
=
segEnd
?
(
cp1
=
=
cp2
?
segStart
:
cp1
)
:
cp2
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
QuadCurve
:
{
Point
cp1
=
cmd
.
quad_curve
.
control1
.
ToGfxPoint
(
)
;
segEnd
=
cmd
.
quad_curve
.
point
.
ToGfxPoint
(
)
;
if
(
cmd
.
quad_curve
.
by_to
=
=
StyleByTo
:
:
By
)
{
cp1
+
=
segStart
;
segEnd
+
=
segStart
;
}
prevCP
=
cp1
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
segEnd
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp1
=
=
segEnd
?
segStart
:
cp1
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
Arc
:
{
const
auto
&
arc
=
cmd
.
arc
;
float
rx
=
arc
.
radii
.
x
;
float
ry
=
arc
.
radii
.
y
;
float
angle
=
arc
.
rotate
;
bool
largeArcFlag
=
arc
.
arc_size
=
=
StyleArcSize
:
:
Large
;
bool
sweepFlag
=
arc
.
arc_sweep
=
=
StyleArcSweep
:
:
Cw
;
segEnd
=
arc
.
point
.
ToGfxPoint
(
)
;
if
(
arc
.
by_to
=
=
StyleByTo
:
:
By
)
{
segEnd
+
=
segStart
;
}
if
(
segStart
=
=
segEnd
)
{
continue
;
}
if
(
rx
=
=
0
.
0
|
|
ry
=
=
0
.
0
)
{
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
}
std
:
:
tie
(
rx
ry
segStartAngle
segEndAngle
)
=
ComputeSegAnglesAndCorrectRadii
(
segStart
segEnd
angle
largeArcFlag
sweepFlag
rx
ry
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
HLine
:
{
if
(
cmd
.
h_line
.
by_to
=
=
StyleByTo
:
:
To
)
{
segEnd
=
Point
(
cmd
.
h_line
.
x
segStart
.
y
)
;
}
else
{
segEnd
=
segStart
+
Point
(
cmd
.
h_line
.
x
0
.
0f
)
;
}
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
VLine
:
{
if
(
cmd
.
v_line
.
by_to
=
=
StyleByTo
:
:
To
)
{
segEnd
=
Point
(
segStart
.
x
cmd
.
v_line
.
y
)
;
}
else
{
segEnd
=
segStart
+
Point
(
0
.
0f
cmd
.
v_line
.
y
)
;
}
segStartAngle
=
segEndAngle
=
AngleOfVector
(
segEnd
segStart
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
SmoothCubic
:
{
const
Point
&
cp1
=
prevSeg
&
&
prevSeg
-
>
IsCubicType
(
)
?
segStart
*
2
-
prevCP
:
segStart
;
Point
cp2
=
cmd
.
smooth_cubic
.
control2
.
ToGfxPoint
(
)
;
segEnd
=
cmd
.
smooth_cubic
.
point
.
ToGfxPoint
(
)
;
if
(
cmd
.
smooth_cubic
.
by_to
=
=
StyleByTo
:
:
By
)
{
cp2
+
=
segStart
;
segEnd
+
=
segStart
;
}
prevCP
=
cp2
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
(
cp1
=
=
cp2
?
segEnd
:
cp2
)
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp2
=
=
segEnd
?
(
cp1
=
=
cp2
?
segStart
:
cp1
)
:
cp2
)
;
break
;
}
case
StylePathCommand
:
:
Tag
:
:
SmoothQuad
:
{
const
Point
&
cp1
=
prevSeg
&
&
prevSeg
-
>
IsQuadraticType
(
)
?
segStart
*
2
-
prevCP
:
segStart
;
segEnd
=
cmd
.
smooth_quad
.
by_to
=
=
StyleByTo
:
:
To
?
cmd
.
smooth_quad
.
point
.
ToGfxPoint
(
)
:
segStart
+
cmd
.
smooth_quad
.
point
.
ToGfxPoint
(
)
;
prevCP
=
cp1
;
segStartAngle
=
AngleOfVector
(
cp1
=
=
segStart
?
segEnd
:
cp1
segStart
)
;
segEndAngle
=
AngleOfVector
(
segEnd
cp1
=
=
segEnd
?
segStart
:
cp1
)
;
break
;
}
}
if
(
aMarks
-
>
Length
(
)
)
{
SVGMark
&
mark
=
aMarks
-
>
LastElement
(
)
;
if
(
!
cmd
.
IsMove
(
)
&
&
prevSeg
&
&
prevSeg
-
>
IsMove
(
)
)
{
pathStartAngle
=
mark
.
angle
=
segStartAngle
;
}
else
if
(
cmd
.
IsMove
(
)
&
&
!
(
prevSeg
&
&
prevSeg
-
>
IsMove
(
)
)
)
{
if
(
!
(
prevSeg
&
&
prevSeg
-
>
IsClose
(
)
)
)
{
mark
.
angle
=
prevSegEndAngle
;
}
}
else
if
(
!
(
cmd
.
IsClose
(
)
&
&
prevSeg
&
&
prevSeg
-
>
IsClose
(
)
)
)
{
mark
.
angle
=
SVGContentUtils
:
:
AngleBisect
(
prevSegEndAngle
segStartAngle
)
;
}
}
aMarks
-
>
AppendElement
(
SVGMark
(
static_cast
<
float
>
(
segEnd
.
x
)
static_cast
<
float
>
(
segEnd
.
y
)
0
.
0f
SVGMark
:
:
eMid
)
)
;
if
(
cmd
.
IsClose
(
)
&
&
!
(
prevSeg
&
&
prevSeg
-
>
IsClose
(
)
)
)
{
aMarks
-
>
LastElement
(
)
.
angle
=
aMarks
-
>
ElementAt
(
pathStartIndex
)
.
angle
=
SVGContentUtils
:
:
AngleBisect
(
segEndAngle
pathStartAngle
)
;
}
prevSeg
=
&
cmd
;
prevSegEnd
=
segEnd
;
prevSegEndAngle
=
segEndAngle
;
}
if
(
aMarks
-
>
Length
(
)
)
{
if
(
!
(
prevSeg
&
&
prevSeg
-
>
IsClose
(
)
)
)
{
aMarks
-
>
LastElement
(
)
.
angle
=
prevSegEndAngle
;
}
aMarks
-
>
LastElement
(
)
.
type
=
SVGMark
:
:
eEnd
;
aMarks
-
>
ElementAt
(
0
)
.
type
=
SVGMark
:
:
eStart
;
}
}
size_t
SVGPathData
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mData
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
size_t
SVGPathData
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
