#
include
"
mozilla
/
dom
/
SVGFEImageElement
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
SVGFEImageElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGFilterElement
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
gfx2DGlue
.
h
"
NS_IMPL_NS_NEW_SVG_ELEMENT
(
FEImage
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
:
:
dom
{
JSObject
*
SVGFEImageElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGFEImageElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
SVGElement
:
:
StringInfo
SVGFEImageElement
:
:
sStringInfo
[
3
]
=
{
{
nsGkAtoms
:
:
result
kNameSpaceID_None
true
}
{
nsGkAtoms
:
:
href
kNameSpaceID_None
true
}
{
nsGkAtoms
:
:
href
kNameSpaceID_XLink
true
}
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
SVGFEImageElement
SVGFEImageElementBase
imgINotificationObserver
nsIImageLoadingContent
)
SVGFEImageElement
:
:
SVGFEImageElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGFEImageElementBase
(
std
:
:
move
(
aNodeInfo
)
)
mImageAnimationMode
(
0
)
{
AddStatesSilently
(
ElementState
:
:
BROKEN
)
;
}
SVGFEImageElement
:
:
~
SVGFEImageElement
(
)
{
nsImageLoadingContent
:
:
Destroy
(
)
;
}
nsresult
SVGFEImageElement
:
:
LoadSVGImage
(
bool
aForce
bool
aNotify
)
{
nsIURI
*
baseURI
=
GetBaseURI
(
)
;
nsAutoString
href
;
if
(
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
)
{
mStringAttributes
[
HREF
]
.
GetAnimValue
(
href
this
)
;
}
else
{
mStringAttributes
[
XLINK_HREF
]
.
GetAnimValue
(
href
this
)
;
}
href
.
Trim
(
"
\
t
\
n
\
r
"
)
;
if
(
baseURI
&
&
!
href
.
IsEmpty
(
)
)
NS_MakeAbsoluteURI
(
href
href
baseURI
)
;
Document
*
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsIURI
>
hrefAsURI
;
if
(
NS_SUCCEEDED
(
StringToURI
(
href
doc
getter_AddRefs
(
hrefAsURI
)
)
)
)
{
bool
isEqual
;
if
(
NS_SUCCEEDED
(
hrefAsURI
-
>
Equals
(
baseURI
&
isEqual
)
)
&
&
isEqual
)
{
return
NS_OK
;
}
}
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
return
LoadImage
(
href
aForce
aNotify
eImageLoadType_Normal
)
;
}
bool
SVGFEImageElement
:
:
ShouldLoadImage
(
)
const
{
return
LoadingEnabled
(
)
&
&
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
;
}
void
SVGFEImageElement
:
:
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
{
nsImageLoadingContent
:
:
AsyncEventRunning
(
aEvent
)
;
}
bool
SVGFEImageElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
crossorigin
)
{
ParseCORSValue
(
aValue
aResult
)
;
return
true
;
}
return
SVGFEImageElementBase
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
nsresult
SVGFEImageElement
:
:
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aName
=
=
nsGkAtoms
:
:
href
&
&
(
aNamespaceID
=
=
kNameSpaceID_XLink
|
|
aNamespaceID
=
=
kNameSpaceID_None
)
)
{
if
(
aValue
)
{
if
(
ShouldLoadImage
(
)
)
{
LoadSVGImage
(
true
aNotify
)
;
}
}
else
{
CancelImageRequests
(
aNotify
)
;
}
}
else
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
crossorigin
)
{
if
(
aNotify
&
&
GetCORSMode
(
)
!
=
AttrValueToCORSMode
(
aOldValue
)
&
&
ShouldLoadImage
(
)
)
{
ForceReload
(
aNotify
IgnoreErrors
(
)
)
;
}
}
return
SVGFEImageElementBase
:
:
AfterSetAttr
(
aNamespaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
void
SVGFEImageElement
:
:
MaybeLoadSVGImage
(
)
{
if
(
(
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
|
|
mStringAttributes
[
XLINK_HREF
]
.
IsExplicitlySet
(
)
)
&
&
(
NS_FAILED
(
LoadSVGImage
(
false
true
)
)
|
|
!
LoadingEnabled
(
)
)
)
{
CancelImageRequests
(
true
)
;
}
}
nsresult
SVGFEImageElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
SVGFEImageElementBase
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsImageLoadingContent
:
:
BindToTree
(
aContext
aParent
)
;
if
(
(
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
|
|
mStringAttributes
[
XLINK_HREF
]
.
IsExplicitlySet
(
)
)
&
&
ShouldLoadImage
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
dom
:
:
SVGFEImageElement
:
:
MaybeLoadSVGImage
"
this
&
SVGFEImageElement
:
:
MaybeLoadSVGImage
)
)
;
}
if
(
aContext
.
InComposedDoc
(
)
)
{
aContext
.
OwnerDoc
(
)
.
SetUseCounter
(
eUseCounter_custom_feImage
)
;
}
return
rv
;
}
void
SVGFEImageElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
nsImageLoadingContent
:
:
UnbindFromTree
(
aNullParent
)
;
SVGFEImageElementBase
:
:
UnbindFromTree
(
aNullParent
)
;
}
ElementState
SVGFEImageElement
:
:
IntrinsicState
(
)
const
{
return
SVGFEImageElementBase
:
:
IntrinsicState
(
)
|
nsImageLoadingContent
:
:
ImageState
(
)
;
}
void
SVGFEImageElement
:
:
DestroyContent
(
)
{
nsImageLoadingContent
:
:
Destroy
(
)
;
SVGFEImageElementBase
:
:
DestroyContent
(
)
;
}
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGFEImageElement
)
already_AddRefed
<
DOMSVGAnimatedString
>
SVGFEImageElement
:
:
Href
(
)
{
return
mStringAttributes
[
HREF
]
.
IsExplicitlySet
(
)
?
mStringAttributes
[
HREF
]
.
ToDOMAnimatedString
(
this
)
:
mStringAttributes
[
XLINK_HREF
]
.
ToDOMAnimatedString
(
this
)
;
}
CORSMode
SVGFEImageElement
:
:
GetCORSMode
(
)
{
return
AttrValueToCORSMode
(
GetParsedAttr
(
nsGkAtoms
:
:
crossorigin
)
)
;
}
FilterPrimitiveDescription
SVGFEImageElement
:
:
GetPrimitiveDescription
(
SVGFilterInstance
*
aInstance
const
IntRect
&
aFilterSubregion
const
nsTArray
<
bool
>
&
aInputsAreTainted
nsTArray
<
RefPtr
<
SourceSurface
>
>
&
aInputImages
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
FilterPrimitiveDescription
(
)
;
}
nsCOMPtr
<
imgIRequest
>
currentRequest
;
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
currentRequest
)
)
;
nsCOMPtr
<
imgIContainer
>
imageContainer
;
if
(
currentRequest
)
{
currentRequest
-
>
GetImage
(
getter_AddRefs
(
imageContainer
)
)
;
}
RefPtr
<
SourceSurface
>
image
;
if
(
imageContainer
)
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
image
=
imageContainer
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
flags
)
;
}
if
(
!
image
)
{
return
FilterPrimitiveDescription
(
)
;
}
IntSize
nativeSize
;
imageContainer
-
>
GetWidth
(
&
nativeSize
.
width
)
;
imageContainer
-
>
GetHeight
(
&
nativeSize
.
height
)
;
Matrix
viewBoxTM
=
SVGContentUtils
:
:
GetViewBoxTransform
(
aFilterSubregion
.
width
aFilterSubregion
.
height
0
0
nativeSize
.
width
nativeSize
.
height
mPreserveAspectRatio
)
;
Matrix
TM
=
viewBoxTM
;
TM
.
PostTranslate
(
aFilterSubregion
.
x
aFilterSubregion
.
y
)
;
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
frame
)
;
ImageAttributes
atts
;
atts
.
mFilter
=
(
uint32_t
)
samplingFilter
;
atts
.
mTransform
=
TM
;
size_t
imageIndex
=
aInputImages
.
Length
(
)
;
aInputImages
.
AppendElement
(
image
)
;
atts
.
mInputIndex
=
(
uint32_t
)
imageIndex
;
return
FilterPrimitiveDescription
(
AsVariant
(
std
:
:
move
(
atts
)
)
)
;
}
bool
SVGFEImageElement
:
:
AttributeAffectsRendering
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
const
{
return
SVGFEImageElementBase
:
:
AttributeAffectsRendering
(
aNameSpaceID
aAttribute
)
|
|
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
)
;
}
bool
SVGFEImageElement
:
:
OutputIsTainted
(
const
nsTArray
<
bool
>
&
aInputsAreTainted
nsIPrincipal
*
aReferencePrincipal
)
{
nsresult
rv
;
nsCOMPtr
<
imgIRequest
>
currentRequest
;
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
currentRequest
)
)
;
if
(
!
currentRequest
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
currentRequest
-
>
GetImagePrincipal
(
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
principal
)
{
return
true
;
}
if
(
nsLayoutUtils
:
:
ImageRequestUsesCORS
(
currentRequest
)
)
{
return
false
;
}
if
(
aReferencePrincipal
-
>
Subsumes
(
principal
)
)
{
return
false
;
}
return
true
;
}
already_AddRefed
<
DOMSVGAnimatedPreserveAspectRatio
>
SVGFEImageElement
:
:
PreserveAspectRatio
(
)
{
return
mPreserveAspectRatio
.
ToDOMAnimatedPreserveAspectRatio
(
this
)
;
}
SVGAnimatedPreserveAspectRatio
*
SVGFEImageElement
:
:
GetAnimatedPreserveAspectRatio
(
)
{
return
&
mPreserveAspectRatio
;
}
SVGElement
:
:
StringAttributesInfo
SVGFEImageElement
:
:
GetStringInfo
(
)
{
return
StringAttributesInfo
(
mStringAttributes
sStringInfo
ArrayLength
(
sStringInfo
)
)
;
}
NS_IMETHODIMP_
(
void
)
SVGFEImageElement
:
:
FrameCreated
(
nsIFrame
*
aFrame
)
{
nsImageLoadingContent
:
:
FrameCreated
(
aFrame
)
;
uint64_t
mode
=
aFrame
-
>
PresContext
(
)
-
>
ImageAnimationMode
(
)
;
if
(
mode
=
=
mImageAnimationMode
)
{
return
;
}
mImageAnimationMode
=
mode
;
if
(
mPendingRequest
)
{
nsCOMPtr
<
imgIContainer
>
container
;
mPendingRequest
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
if
(
container
)
{
container
-
>
SetAnimationMode
(
mode
)
;
}
}
if
(
mCurrentRequest
)
{
nsCOMPtr
<
imgIContainer
>
container
;
mCurrentRequest
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
if
(
container
)
{
container
-
>
SetAnimationMode
(
mode
)
;
}
}
}
void
SVGFEImageElement
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
nsImageLoadingContent
:
:
Notify
(
aRequest
aType
aData
)
;
if
(
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
container
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
MOZ_ASSERT
(
container
"
who
sent
the
notification
then
?
"
)
;
container
-
>
StartDecoding
(
imgIContainer
:
:
FLAG_NONE
)
;
container
-
>
SetAnimationMode
(
mImageAnimationMode
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
|
|
aType
=
=
imgINotificationObserver
:
:
FRAME_UPDATE
|
|
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
if
(
auto
*
filter
=
SVGFilterElement
:
:
FromNodeOrNull
(
GetParent
(
)
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
filter
)
;
}
}
}
}
