#
ifndef
DOM_SVG_DOMSVGPOINT_H_
#
define
DOM_SVG_DOMSVGPOINT_H_
#
include
"
DOMSVGPointList
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
SVGPoint
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
define
MOZ_SVG_LIST_INDEX_BIT_COUNT
29
namespace
mozilla
:
:
dom
{
struct
DOMMatrix2DInit
;
class
DOMSVGPoint
final
:
public
nsWrapperCache
{
template
<
class
T
>
friend
class
AutoChangePointListNotifier
;
using
Point
=
gfx
:
:
Point
;
public
:
DOMSVGPoint
(
DOMSVGPointList
*
aList
uint32_t
aListIndex
bool
aIsAnimValItem
)
:
mVal
(
nullptr
)
mOwner
(
aList
)
mListIndex
(
aListIndex
)
mIsAnimValItem
(
aIsAnimValItem
)
mIsTranslatePoint
(
false
)
mIsInTearoffTable
(
false
)
{
MOZ_ASSERT
(
aList
&
&
aListIndex
<
=
MaxListIndex
(
)
"
bad
arg
"
)
;
MOZ_ASSERT
(
IndexIsValid
(
)
"
Bad
index
for
DOMSVGPoint
!
"
)
;
}
explicit
DOMSVGPoint
(
const
Point
&
aPt
)
:
mListIndex
(
0
)
mIsAnimValItem
(
false
)
mIsTranslatePoint
(
false
)
mIsInTearoffTable
(
false
)
{
mVal
=
new
SVGPoint
(
aPt
.
x
aPt
.
y
)
;
}
private
:
DOMSVGPoint
(
SVGPoint
*
aPt
SVGSVGElement
*
aSVGSVGElement
)
:
mVal
(
aPt
)
mOwner
(
ToSupports
(
aSVGSVGElement
)
)
mListIndex
(
0
)
mIsAnimValItem
(
false
)
mIsTranslatePoint
(
true
)
mIsInTearoffTable
(
false
)
{
}
virtual
~
DOMSVGPoint
(
)
{
CleanupWeakRefs
(
)
;
}
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
DOMSVGPoint
)
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
DOMSVGPoint
)
static
already_AddRefed
<
DOMSVGPoint
>
GetTranslateTearOff
(
SVGPoint
*
aVal
SVGSVGElement
*
aSVGSVGElement
)
;
bool
IsInList
(
)
const
{
return
HasOwner
(
)
&
&
!
IsTranslatePoint
(
)
;
}
bool
HasOwner
(
)
const
{
return
!
!
mOwner
;
}
bool
IsTranslatePoint
(
)
const
{
return
mIsTranslatePoint
;
}
void
DidChangeTranslate
(
)
;
void
InsertingIntoList
(
DOMSVGPointList
*
aList
uint32_t
aListIndex
bool
aIsAnimValItem
)
;
static
uint32_t
MaxListIndex
(
)
{
return
(
1U
<
<
MOZ_SVG_LIST_INDEX_BIT_COUNT
)
-
1
;
}
void
UpdateListIndex
(
uint32_t
aListIndex
)
{
mListIndex
=
aListIndex
;
}
void
RemovingFromList
(
)
;
SVGPoint
ToSVGPoint
(
)
{
return
InternalItem
(
)
;
}
float
X
(
)
;
void
SetX
(
float
aX
ErrorResult
&
rv
)
;
float
Y
(
)
;
void
SetY
(
float
aY
ErrorResult
&
rv
)
;
already_AddRefed
<
DOMSVGPoint
>
MatrixTransform
(
const
DOMMatrix2DInit
&
aMatrix
ErrorResult
&
aRv
)
;
nsISupports
*
GetParentObject
(
)
{
return
Element
(
)
;
}
bool
AttrIsAnimating
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
DOMSVGPoint
*
Copy
(
)
{
return
new
DOMSVGPoint
(
InternalItem
(
)
)
;
}
private
:
#
ifdef
DEBUG
bool
IndexIsValid
(
)
;
#
endif
SVGElement
*
Element
(
)
;
void
CleanupWeakRefs
(
)
;
SVGPoint
&
InternalItem
(
)
;
SVGPoint
*
mVal
;
RefPtr
<
nsISupports
>
mOwner
;
uint32_t
mListIndex
:
MOZ_SVG_LIST_INDEX_BIT_COUNT
;
uint32_t
mIsAnimValItem
:
1
;
uint32_t
mIsTranslatePoint
:
1
;
uint32_t
mIsInTearoffTable
:
1
;
}
;
}
#
undef
MOZ_SVG_LIST_INDEX_BIT_COUNT
#
endif
