#
include
"
SVGFragmentIdentifier
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGViewElement
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
SVGAnimatedTransformList
.
h
"
namespace
mozilla
{
using
namespace
dom
;
static
bool
IsMatchingParameter
(
const
nsAString
&
aString
const
nsAString
&
aParameterName
)
{
return
StringBeginsWith
(
aString
aParameterName
)
&
&
aString
.
Last
(
)
=
=
'
)
'
&
&
aString
.
CharAt
(
aParameterName
.
Length
(
)
)
=
=
'
(
'
;
}
inline
bool
IgnoreWhitespace
(
char16_t
aChar
)
{
return
false
;
}
static
SVGViewElement
*
GetViewElement
(
Document
*
aDocument
const
nsAString
&
aId
)
{
Element
*
element
=
aDocument
-
>
GetElementById
(
aId
)
;
return
(
element
&
&
element
-
>
IsSVGElement
(
nsGkAtoms
:
:
view
)
)
?
static_cast
<
SVGViewElement
*
>
(
element
)
:
nullptr
;
}
class
MOZ_RAII
AutoSVGViewHandler
{
public
:
explicit
AutoSVGViewHandler
(
SVGSVGElement
*
aRoot
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mRoot
(
aRoot
)
mValid
(
false
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mWasOverridden
=
mRoot
-
>
UseCurrentView
(
)
;
mRoot
-
>
mSVGView
=
nullptr
;
mRoot
-
>
mCurrentViewID
=
nullptr
;
}
~
AutoSVGViewHandler
(
)
{
if
(
!
mWasOverridden
&
&
!
mValid
)
{
return
;
}
if
(
mValid
)
{
mRoot
-
>
mSVGView
=
std
:
:
move
(
mSVGView
)
;
}
mRoot
-
>
InvalidateTransformNotifyFrame
(
)
;
}
void
CreateSVGView
(
)
{
MOZ_ASSERT
(
!
mSVGView
"
CreateSVGView
should
not
be
called
multiple
times
"
)
;
mSVGView
=
MakeUnique
<
SVGView
>
(
)
;
}
bool
ProcessAttr
(
const
nsAString
&
aToken
const
nsAString
&
aParams
)
{
MOZ_ASSERT
(
mSVGView
"
CreateSVGView
should
have
been
called
"
)
;
if
(
IsMatchingParameter
(
aToken
u
"
viewBox
"
_ns
)
)
{
if
(
mSVGView
-
>
mViewBox
.
IsExplicitlySet
(
)
|
|
NS_FAILED
(
mSVGView
-
>
mViewBox
.
SetBaseValueString
(
aParams
mRoot
false
)
)
)
{
return
false
;
}
}
else
if
(
IsMatchingParameter
(
aToken
u
"
preserveAspectRatio
"
_ns
)
)
{
if
(
mSVGView
-
>
mPreserveAspectRatio
.
IsExplicitlySet
(
)
|
|
NS_FAILED
(
mSVGView
-
>
mPreserveAspectRatio
.
SetBaseValueString
(
aParams
mRoot
false
)
)
)
{
return
false
;
}
}
else
if
(
IsMatchingParameter
(
aToken
u
"
transform
"
_ns
)
)
{
if
(
mSVGView
-
>
mTransforms
)
{
return
false
;
}
mSVGView
-
>
mTransforms
=
MakeUnique
<
SVGAnimatedTransformList
>
(
)
;
if
(
NS_FAILED
(
mSVGView
-
>
mTransforms
-
>
SetBaseValueString
(
aParams
mRoot
)
)
)
{
return
false
;
}
}
else
if
(
IsMatchingParameter
(
aToken
u
"
zoomAndPan
"
_ns
)
)
{
if
(
mSVGView
-
>
mZoomAndPan
.
IsExplicitlySet
(
)
)
{
return
false
;
}
nsAtom
*
valAtom
=
NS_GetStaticAtom
(
aParams
)
;
if
(
!
valAtom
|
|
!
mSVGView
-
>
mZoomAndPan
.
SetBaseValueAtom
(
valAtom
mRoot
)
)
{
return
false
;
}
}
else
{
return
false
;
}
return
true
;
}
void
SetValid
(
)
{
mValid
=
true
;
}
private
:
SVGSVGElement
*
mRoot
;
UniquePtr
<
SVGView
>
mSVGView
;
bool
mValid
;
bool
mWasOverridden
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
bool
SVGFragmentIdentifier
:
:
ProcessSVGViewSpec
(
const
nsAString
&
aViewSpec
SVGSVGElement
*
aRoot
)
{
AutoSVGViewHandler
viewHandler
(
aRoot
)
;
if
(
!
IsMatchingParameter
(
aViewSpec
u
"
svgView
"
_ns
)
)
{
return
false
;
}
int32_t
bracketPos
=
aViewSpec
.
FindChar
(
'
(
'
)
;
uint32_t
lengthOfViewSpec
=
aViewSpec
.
Length
(
)
-
bracketPos
-
2
;
nsCharSeparatedTokenizerTemplate
<
IgnoreWhitespace
>
tokenizer
(
Substring
(
aViewSpec
bracketPos
+
1
lengthOfViewSpec
)
'
;
'
)
;
if
(
!
tokenizer
.
hasMoreTokens
(
)
)
{
return
false
;
}
viewHandler
.
CreateSVGView
(
)
;
do
{
nsAutoString
token
(
tokenizer
.
nextToken
(
)
)
;
bracketPos
=
token
.
FindChar
(
'
(
'
)
;
if
(
bracketPos
<
1
|
|
token
.
Last
(
)
!
=
'
)
'
)
{
return
false
;
}
const
nsAString
&
params
=
Substring
(
token
bracketPos
+
1
token
.
Length
(
)
-
bracketPos
-
2
)
;
if
(
!
viewHandler
.
ProcessAttr
(
token
params
)
)
{
return
false
;
}
}
while
(
tokenizer
.
hasMoreTokens
(
)
)
;
viewHandler
.
SetValid
(
)
;
return
true
;
}
bool
SVGFragmentIdentifier
:
:
ProcessFragmentIdentifier
(
Document
*
aDocument
const
nsAString
&
aAnchorName
)
{
MOZ_ASSERT
(
aDocument
-
>
GetRootElement
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
"
expecting
an
SVG
root
element
"
)
;
SVGSVGElement
*
rootElement
=
static_cast
<
SVGSVGElement
*
>
(
aDocument
-
>
GetRootElement
(
)
)
;
const
SVGViewElement
*
viewElement
=
GetViewElement
(
aDocument
aAnchorName
)
;
if
(
viewElement
)
{
if
(
!
rootElement
-
>
mCurrentViewID
)
{
rootElement
-
>
mCurrentViewID
=
MakeUnique
<
nsString
>
(
)
;
}
*
rootElement
-
>
mCurrentViewID
=
aAnchorName
;
rootElement
-
>
mSVGView
=
nullptr
;
rootElement
-
>
InvalidateTransformNotifyFrame
(
)
;
return
false
;
}
return
ProcessSVGViewSpec
(
aAnchorName
rootElement
)
;
}
}
