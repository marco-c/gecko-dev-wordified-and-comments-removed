#
include
"
mozilla
/
dom
/
SVGPathElement
.
h
"
#
include
<
algorithm
>
#
include
"
SVGGeometryProperty
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
mozilla
/
dom
/
SVGPathElementBinding
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
SVGPathSegUtils
.
h
"
#
include
"
mozilla
/
SVGContentUtils
.
h
"
NS_IMPL_NS_NEW_SVG_ELEMENT
(
Path
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
:
:
dom
{
JSObject
*
SVGPathElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGPathElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
SVGPathElement
:
:
SVGPathElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGPathElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
}
void
SVGPathElement
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
SVGPathElementBase
:
:
AddSizeOfExcludingThis
(
aSizes
aNodeSize
)
;
*
aNodeSize
+
=
mD
.
SizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
}
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGPathElement
)
bool
SVGPathElement
:
:
HasValidDimensions
(
)
const
{
bool
hasPath
=
false
;
auto
callback
=
[
&
]
(
const
ComputedStyle
*
s
)
{
const
nsStyleSVGReset
*
styleSVGReset
=
s
-
>
StyleSVGReset
(
)
;
hasPath
=
styleSVGReset
-
>
mD
.
IsPath
(
)
&
&
!
styleSVGReset
-
>
mD
.
AsPath
(
)
.
_0
.
IsEmpty
(
)
;
}
;
SVGGeometryProperty
:
:
DoForComputedStyle
(
this
callback
)
;
return
hasPath
|
|
!
mD
.
GetAnimValue
(
)
.
IsEmpty
(
)
;
}
NS_IMETHODIMP_
(
bool
)
SVGPathElement
:
:
IsAttributeMapped
(
const
nsAtom
*
name
)
const
{
return
name
=
=
nsGkAtoms
:
:
d
|
|
SVGPathElementBase
:
:
IsAttributeMapped
(
name
)
;
}
already_AddRefed
<
Path
>
SVGPathElement
:
:
GetOrBuildPathForMeasuring
(
)
{
RefPtr
<
Path
>
path
;
bool
success
=
SVGGeometryProperty
:
:
DoForComputedStyle
(
this
[
&
path
]
(
const
ComputedStyle
*
s
)
{
const
auto
&
d
=
s
-
>
StyleSVGReset
(
)
-
>
mD
;
if
(
d
.
IsNone
(
)
)
{
return
;
}
path
=
SVGPathData
:
:
BuildPathForMeasuring
(
d
.
AsPath
(
)
.
_0
.
AsSpan
(
)
)
;
}
)
;
return
success
?
path
.
forget
(
)
:
mD
.
GetAnimValue
(
)
.
BuildPathForMeasuring
(
)
;
}
bool
SVGPathElement
:
:
AttributeDefinesGeometry
(
const
nsAtom
*
aName
)
{
return
aName
=
=
nsGkAtoms
:
:
d
|
|
aName
=
=
nsGkAtoms
:
:
pathLength
;
}
bool
SVGPathElement
:
:
IsMarkable
(
)
{
return
true
;
}
void
SVGPathElement
:
:
GetMarkPoints
(
nsTArray
<
SVGMark
>
*
aMarks
)
{
auto
callback
=
[
aMarks
]
(
const
ComputedStyle
*
s
)
{
const
nsStyleSVGReset
*
styleSVGReset
=
s
-
>
StyleSVGReset
(
)
;
if
(
styleSVGReset
-
>
mD
.
IsPath
(
)
)
{
Span
<
const
StylePathCommand
>
path
=
styleSVGReset
-
>
mD
.
AsPath
(
)
.
_0
.
AsSpan
(
)
;
SVGPathData
:
:
GetMarkerPositioningData
(
path
aMarks
)
;
}
}
;
if
(
SVGGeometryProperty
:
:
DoForComputedStyle
(
this
callback
)
)
{
return
;
}
mD
.
GetAnimValue
(
)
.
GetMarkerPositioningData
(
aMarks
)
;
}
void
SVGPathElement
:
:
GetAsSimplePath
(
SimplePath
*
aSimplePath
)
{
aSimplePath
-
>
Reset
(
)
;
auto
callback
=
[
&
]
(
const
ComputedStyle
*
s
)
{
const
nsStyleSVGReset
*
styleSVGReset
=
s
-
>
StyleSVGReset
(
)
;
if
(
styleSVGReset
-
>
mD
.
IsPath
(
)
)
{
auto
pathData
=
styleSVGReset
-
>
mD
.
AsPath
(
)
.
_0
.
AsSpan
(
)
;
auto
maybeRect
=
SVGPathToAxisAlignedRect
(
pathData
)
;
if
(
maybeRect
.
isSome
(
)
)
{
Rect
r
=
maybeRect
.
value
(
)
;
aSimplePath
-
>
SetRect
(
r
.
x
r
.
y
r
.
width
r
.
height
)
;
}
}
}
;
SVGGeometryProperty
:
:
DoForComputedStyle
(
this
callback
)
;
}
already_AddRefed
<
Path
>
SVGPathElement
:
:
BuildPath
(
PathBuilder
*
aBuilder
)
{
auto
strokeLineCap
=
StyleStrokeLinecap
:
:
Butt
;
Float
strokeWidth
=
0
;
RefPtr
<
Path
>
path
;
auto
callback
=
[
&
]
(
const
ComputedStyle
*
s
)
{
const
nsStyleSVG
*
styleSVG
=
s
-
>
StyleSVG
(
)
;
if
(
styleSVG
-
>
mStrokeLinecap
!
=
StyleStrokeLinecap
:
:
Butt
)
{
strokeLineCap
=
styleSVG
-
>
mStrokeLinecap
;
strokeWidth
=
SVGContentUtils
:
:
GetStrokeWidth
(
this
s
nullptr
)
;
}
const
auto
&
d
=
s
-
>
StyleSVGReset
(
)
-
>
mD
;
if
(
d
.
IsPath
(
)
)
{
path
=
SVGPathData
:
:
BuildPath
(
d
.
AsPath
(
)
.
_0
.
AsSpan
(
)
aBuilder
strokeLineCap
strokeWidth
)
;
}
}
;
bool
success
=
SVGGeometryProperty
:
:
DoForComputedStyle
(
this
callback
)
;
if
(
success
)
{
return
path
.
forget
(
)
;
}
return
mD
.
GetAnimValue
(
)
.
BuildPath
(
aBuilder
strokeLineCap
strokeWidth
)
;
}
bool
SVGPathElement
:
:
GetDistancesFromOriginToEndsOfVisibleSegments
(
FallibleTArray
<
double
>
*
aOutput
)
{
bool
ret
=
false
;
auto
callback
=
[
&
ret
aOutput
]
(
const
ComputedStyle
*
s
)
{
const
auto
&
d
=
s
-
>
StyleSVGReset
(
)
-
>
mD
;
ret
=
d
.
IsNone
(
)
|
|
SVGPathData
:
:
GetDistancesFromOriginToEndsOfVisibleSegments
(
d
.
AsPath
(
)
.
_0
.
AsSpan
(
)
aOutput
)
;
}
;
if
(
SVGGeometryProperty
:
:
DoForComputedStyle
(
this
callback
)
)
{
return
ret
;
}
return
mD
.
GetAnimValue
(
)
.
GetDistancesFromOriginToEndsOfVisibleSegments
(
aOutput
)
;
}
bool
SVGPathElement
:
:
IsClosedLoop
(
)
const
{
bool
isClosed
=
false
;
auto
callback
=
[
&
]
(
const
ComputedStyle
*
s
)
{
const
nsStyleSVGReset
*
styleSVGReset
=
s
-
>
StyleSVGReset
(
)
;
if
(
styleSVGReset
-
>
mD
.
IsPath
(
)
)
{
isClosed
=
!
styleSVGReset
-
>
mD
.
AsPath
(
)
.
_0
.
IsEmpty
(
)
&
&
styleSVGReset
-
>
mD
.
AsPath
(
)
.
_0
.
AsSpan
(
)
.
rbegin
(
)
-
>
IsClose
(
)
;
}
}
;
const
bool
success
=
SVGGeometryProperty
:
:
DoForComputedStyle
(
this
callback
)
;
if
(
success
)
{
return
isClosed
;
}
const
SVGPathData
&
data
=
mD
.
GetAnimValue
(
)
;
uint32_t
i
=
0
;
uint32_t
segType
=
PATHSEG_UNKNOWN
;
while
(
i
<
data
.
Length
(
)
)
{
segType
=
SVGPathSegUtils
:
:
DecodeType
(
data
[
i
+
+
]
)
;
i
+
=
SVGPathSegUtils
:
:
ArgCountForType
(
segType
)
;
}
return
segType
=
=
PATHSEG_CLOSEPATH
;
}
bool
SVGPathElement
:
:
IsDPropertyChangedViaCSS
(
const
ComputedStyle
&
aNewStyle
const
ComputedStyle
&
aOldStyle
)
{
return
aNewStyle
.
StyleSVGReset
(
)
-
>
mD
!
=
aOldStyle
.
StyleSVGReset
(
)
-
>
mD
;
}
}
