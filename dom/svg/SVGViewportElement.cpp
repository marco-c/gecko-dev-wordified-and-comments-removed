#
include
"
mozilla
/
dom
/
SVGViewportElement
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
SMILTypes
.
h
"
#
include
"
mozilla
/
SVGContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
SVGLengthBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGViewElement
.
h
"
#
include
"
DOMSVGLength
.
h
"
#
include
"
DOMSVGPoint
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
<
algorithm
>
#
include
"
prtime
.
h
"
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
SVGElement
:
:
LengthInfo
SVGViewportElement
:
:
sLengthInfo
[
4
]
=
{
{
nsGkAtoms
:
:
x
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
X
}
{
nsGkAtoms
:
:
y
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
Y
}
{
nsGkAtoms
:
:
width
100
SVGLength_Binding
:
:
SVG_LENGTHTYPE_PERCENTAGE
SVGContentUtils
:
:
X
}
{
nsGkAtoms
:
:
height
100
SVGLength_Binding
:
:
SVG_LENGTHTYPE_PERCENTAGE
SVGContentUtils
:
:
Y
}
}
;
SVGViewportElement
:
:
SVGViewportElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGGraphicsElement
(
std
:
:
move
(
aNodeInfo
)
)
mViewportWidth
(
0
)
mViewportHeight
(
0
)
mHasChildrenOnlyTransform
(
false
)
{
}
already_AddRefed
<
SVGAnimatedRect
>
SVGViewportElement
:
:
ViewBox
(
)
{
return
mViewBox
.
ToSVGAnimatedRect
(
this
)
;
}
already_AddRefed
<
DOMSVGAnimatedPreserveAspectRatio
>
SVGViewportElement
:
:
PreserveAspectRatio
(
)
{
return
mPreserveAspectRatio
.
ToDOMAnimatedPreserveAspectRatio
(
this
)
;
}
bool
SVGViewportElement
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
!
(
aFlags
&
~
eUSE_TARGET
)
;
}
NS_IMETHODIMP_
(
bool
)
SVGViewportElement
:
:
IsAttributeMapped
(
const
nsAtom
*
name
)
const
{
if
(
!
IsInner
(
)
&
&
(
name
=
=
nsGkAtoms
:
:
width
|
|
name
=
=
nsGkAtoms
:
:
height
)
)
{
return
true
;
}
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sColorMap
sFEFloodMap
sFillStrokeMap
sFiltersMap
sFontSpecificationMap
sGradientStopMap
sGraphicsMap
sLightingEffectsMap
sMarkersMap
sTextContentElementsMap
sViewportsMap
}
;
return
FindAttributeDependence
(
name
map
)
|
|
SVGGraphicsElement
:
:
IsAttributeMapped
(
name
)
;
}
inline
float
ComputeSynthesizedViewBoxDimension
(
const
SVGAnimatedLength
&
aLength
float
aViewportLength
const
SVGViewportElement
*
aSelf
)
{
if
(
aLength
.
IsPercentage
(
)
)
{
return
aViewportLength
*
aLength
.
GetAnimValInSpecifiedUnits
(
)
/
100
.
0f
;
}
return
aLength
.
GetAnimValue
(
const_cast
<
SVGViewportElement
*
>
(
aSelf
)
)
;
}
void
SVGViewportElement
:
:
UpdateHasChildrenOnlyTransform
(
)
{
bool
hasChildrenOnlyTransform
=
HasViewBoxOrSyntheticViewBox
(
)
|
|
(
IsRoot
(
)
&
&
static_cast
<
SVGSVGElement
*
>
(
this
)
-
>
IsScaledOrTranslated
(
)
)
;
mHasChildrenOnlyTransform
=
hasChildrenOnlyTransform
;
}
void
SVGViewportElement
:
:
ChildrenOnlyTransformChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
!
(
GetPrimaryFrame
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
Non
-
display
SVG
frames
don
'
t
maintain
overflow
rects
"
)
;
nsChangeHint
changeHint
;
bool
hadChildrenOnlyTransform
=
mHasChildrenOnlyTransform
;
UpdateHasChildrenOnlyTransform
(
)
;
if
(
hadChildrenOnlyTransform
!
=
mHasChildrenOnlyTransform
)
{
changeHint
=
nsChangeHint_ReconstructFrame
;
}
else
{
changeHint
=
nsChangeHint
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_ChildrenOnlyTransform
)
;
}
if
(
(
changeHint
&
nsChangeHint_ReconstructFrame
)
|
|
!
(
aFlags
&
eDuringReflow
)
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
this
RestyleHint
{
0
}
changeHint
)
;
}
}
gfx
:
:
Matrix
SVGViewportElement
:
:
GetViewBoxTransform
(
)
const
{
float
viewportWidth
viewportHeight
;
if
(
IsInner
(
)
)
{
SVGElement
*
self
=
const_cast
<
SVGViewportElement
*
>
(
this
)
;
viewportWidth
=
mLengthAttributes
[
ATTR_WIDTH
]
.
GetAnimValue
(
self
)
;
viewportHeight
=
mLengthAttributes
[
ATTR_HEIGHT
]
.
GetAnimValue
(
self
)
;
}
else
{
viewportWidth
=
mViewportWidth
;
viewportHeight
=
mViewportHeight
;
}
if
(
viewportWidth
<
=
0
.
0f
|
|
viewportHeight
<
=
0
.
0f
)
{
return
gfx
:
:
Matrix
(
0
.
0
0
.
0
0
.
0
0
.
0
0
.
0
0
.
0
)
;
}
SVGViewBox
viewBox
=
GetViewBoxWithSynthesis
(
viewportWidth
viewportHeight
)
;
if
(
viewBox
.
width
<
=
0
.
0f
|
|
viewBox
.
height
<
=
0
.
0f
)
{
return
gfx
:
:
Matrix
(
0
.
0
0
.
0
0
.
0
0
.
0
0
.
0
0
.
0
)
;
}
return
SVGContentUtils
:
:
GetViewBoxTransform
(
viewportWidth
viewportHeight
viewBox
.
x
viewBox
.
y
viewBox
.
width
viewBox
.
height
GetPreserveAspectRatioWithOverride
(
)
)
;
}
float
SVGViewportElement
:
:
GetLength
(
uint8_t
aCtxType
)
{
const
SVGViewBox
*
viewbox
=
GetViewBoxInternal
(
)
.
HasRect
(
)
?
&
GetViewBoxInternal
(
)
.
GetAnimValue
(
)
:
nullptr
;
float
h
=
0
.
0f
w
=
0
.
0f
;
bool
shouldComputeWidth
=
(
aCtxType
=
=
SVGContentUtils
:
:
X
|
|
aCtxType
=
=
SVGContentUtils
:
:
XY
)
shouldComputeHeight
=
(
aCtxType
=
=
SVGContentUtils
:
:
Y
|
|
aCtxType
=
=
SVGContentUtils
:
:
XY
)
;
if
(
viewbox
)
{
w
=
viewbox
-
>
width
;
h
=
viewbox
-
>
height
;
}
else
if
(
IsInner
(
)
)
{
SVGElement
*
self
=
this
;
if
(
shouldComputeWidth
)
{
w
=
mLengthAttributes
[
ATTR_WIDTH
]
.
GetAnimValue
(
self
)
;
}
if
(
shouldComputeHeight
)
{
h
=
mLengthAttributes
[
ATTR_HEIGHT
]
.
GetAnimValue
(
self
)
;
}
}
else
if
(
ShouldSynthesizeViewBox
(
)
)
{
if
(
shouldComputeWidth
)
{
w
=
ComputeSynthesizedViewBoxDimension
(
mLengthAttributes
[
ATTR_WIDTH
]
mViewportWidth
this
)
;
}
if
(
shouldComputeHeight
)
{
h
=
ComputeSynthesizedViewBoxDimension
(
mLengthAttributes
[
ATTR_HEIGHT
]
mViewportHeight
this
)
;
}
}
else
{
w
=
mViewportWidth
;
h
=
mViewportHeight
;
}
w
=
std
:
:
max
(
w
0
.
0f
)
;
h
=
std
:
:
max
(
h
0
.
0f
)
;
switch
(
aCtxType
)
{
case
SVGContentUtils
:
:
X
:
return
w
;
case
SVGContentUtils
:
:
Y
:
return
h
;
case
SVGContentUtils
:
:
XY
:
return
float
(
SVGContentUtils
:
:
ComputeNormalizedHypotenuse
(
w
h
)
)
;
}
return
0
;
}
gfxMatrix
SVGViewportElement
:
:
PrependLocalTransformsTo
(
const
gfxMatrix
&
aMatrix
SVGTransformTypes
aWhich
)
const
{
gfxMatrix
userToParent
;
if
(
aWhich
=
=
eUserSpaceToParent
|
|
aWhich
=
=
eAllTransforms
)
{
userToParent
=
GetUserToParentTransform
(
mAnimateMotionTransform
.
get
(
)
GetTransformInternal
(
)
)
;
if
(
aWhich
=
=
eUserSpaceToParent
)
{
return
userToParent
*
aMatrix
;
}
}
gfxMatrix
childToUser
;
if
(
IsInner
(
)
)
{
float
x
y
;
const_cast
<
SVGViewportElement
*
>
(
this
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
nullptr
)
;
childToUser
=
ThebesMatrix
(
GetViewBoxTransform
(
)
.
PostTranslate
(
x
y
)
)
;
}
else
if
(
IsRoot
(
)
)
{
const
SVGSVGElement
*
svg
=
static_cast
<
const
SVGSVGElement
*
>
(
this
)
;
const
SVGPoint
&
translate
=
svg
-
>
GetCurrentTranslate
(
)
;
float
scale
=
svg
-
>
CurrentScale
(
)
;
childToUser
=
ThebesMatrix
(
GetViewBoxTransform
(
)
.
PostScale
(
scale
scale
)
.
PostTranslate
(
translate
.
GetX
(
)
translate
.
GetY
(
)
)
)
;
}
else
{
childToUser
=
ThebesMatrix
(
GetViewBoxTransform
(
)
)
;
}
if
(
aWhich
=
=
eAllTransforms
)
{
return
childToUser
*
userToParent
*
aMatrix
;
}
MOZ_ASSERT
(
aWhich
=
=
eChildToUserSpace
"
Unknown
TransformTypes
"
)
;
return
childToUser
*
aMatrix
;
}
bool
SVGViewportElement
:
:
HasValidDimensions
(
)
const
{
return
!
IsInner
(
)
|
|
(
(
!
mLengthAttributes
[
ATTR_WIDTH
]
.
IsExplicitlySet
(
)
|
|
mLengthAttributes
[
ATTR_WIDTH
]
.
GetAnimValInSpecifiedUnits
(
)
>
0
)
&
&
(
!
mLengthAttributes
[
ATTR_HEIGHT
]
.
IsExplicitlySet
(
)
|
|
mLengthAttributes
[
ATTR_HEIGHT
]
.
GetAnimValInSpecifiedUnits
(
)
>
0
)
)
;
}
SVGAnimatedViewBox
*
SVGViewportElement
:
:
GetAnimatedViewBox
(
)
{
return
&
mViewBox
;
}
SVGAnimatedPreserveAspectRatio
*
SVGViewportElement
:
:
GetAnimatedPreserveAspectRatio
(
)
{
return
&
mPreserveAspectRatio
;
}
bool
SVGViewportElement
:
:
ShouldSynthesizeViewBox
(
)
const
{
MOZ_ASSERT
(
!
HasViewBox
(
)
"
Should
only
be
called
if
we
lack
a
viewBox
"
)
;
return
IsRoot
(
)
&
&
OwnerDoc
(
)
-
>
IsBeingUsedAsImage
(
)
;
}
SVGViewBox
SVGViewportElement
:
:
GetViewBoxWithSynthesis
(
float
aViewportWidth
float
aViewportHeight
)
const
{
if
(
GetViewBoxInternal
(
)
.
HasRect
(
)
)
{
return
GetViewBoxInternal
(
)
.
GetAnimValue
(
)
;
}
if
(
ShouldSynthesizeViewBox
(
)
)
{
return
SVGViewBox
(
0
0
ComputeSynthesizedViewBoxDimension
(
mLengthAttributes
[
ATTR_WIDTH
]
mViewportWidth
this
)
ComputeSynthesizedViewBoxDimension
(
mLengthAttributes
[
ATTR_HEIGHT
]
mViewportHeight
this
)
)
;
}
return
SVGViewBox
(
0
0
aViewportWidth
aViewportHeight
)
;
}
SVGElement
:
:
LengthAttributesInfo
SVGViewportElement
:
:
GetLengthInfo
(
)
{
return
LengthAttributesInfo
(
mLengthAttributes
sLengthInfo
ArrayLength
(
sLengthInfo
)
)
;
}
}
}
