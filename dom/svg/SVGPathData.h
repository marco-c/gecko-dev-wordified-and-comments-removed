#
ifndef
DOM_SVG_SVGPATHDATA_H_
#
define
DOM_SVG_SVGPATHDATA_H_
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
<
string
.
h
>
namespace
mozilla
{
struct
StylePathCommand
;
struct
SVGMark
;
enum
class
StyleStrokeLinecap
:
uint8_t
;
class
SVGPathDataParser
;
namespace
dom
{
class
DOMSVGPathSeg
;
class
DOMSVGPathSegList
;
}
class
SVGPathData
{
friend
class
SVGAnimatedPathSegList
;
friend
class
dom
:
:
DOMSVGPathSeg
;
friend
class
dom
:
:
DOMSVGPathSegList
;
friend
class
SVGPathDataParser
;
using
DrawTarget
=
gfx
:
:
DrawTarget
;
using
Path
=
gfx
:
:
Path
;
using
PathBuilder
=
gfx
:
:
PathBuilder
;
using
FillRule
=
gfx
:
:
FillRule
;
using
Float
=
gfx
:
:
Float
;
using
CapStyle
=
gfx
:
:
CapStyle
;
public
:
using
const_iterator
=
const
float
*
;
SVGPathData
(
)
=
default
;
~
SVGPathData
(
)
=
default
;
void
GetValueAsString
(
nsAString
&
aValue
)
const
;
bool
IsEmpty
(
)
const
{
return
mData
.
IsEmpty
(
)
;
}
#
ifdef
DEBUG
uint32_t
CountItems
(
)
const
;
#
endif
uint32_t
Length
(
)
const
{
return
mData
.
Length
(
)
;
}
const
float
&
operator
[
]
(
uint32_t
aIndex
)
const
{
return
mData
[
aIndex
]
;
}
bool
operator
=
=
(
const
SVGPathData
&
rhs
)
const
{
return
mData
.
Length
(
)
=
=
rhs
.
mData
.
Length
(
)
&
&
memcmp
(
mData
.
Elements
(
)
rhs
.
mData
.
Elements
(
)
mData
.
Length
(
)
*
sizeof
(
float
)
)
=
=
0
;
}
bool
SetCapacity
(
uint32_t
aSize
)
{
return
mData
.
SetCapacity
(
aSize
fallible
)
;
}
void
Compact
(
)
{
mData
.
Compact
(
)
;
}
float
GetPathLength
(
)
const
;
uint32_t
GetPathSegAtLength
(
float
aDistance
)
const
;
static
uint32_t
GetPathSegAtLength
(
Span
<
const
StylePathCommand
>
aPath
float
aDistance
)
;
void
GetMarkerPositioningData
(
nsTArray
<
SVGMark
>
*
aMarks
)
const
;
static
void
GetMarkerPositioningData
(
Span
<
const
StylePathCommand
>
aPath
nsTArray
<
SVGMark
>
*
aMarks
)
;
bool
GetDistancesFromOriginToEndsOfVisibleSegments
(
FallibleTArray
<
double
>
*
aOutput
)
const
;
already_AddRefed
<
Path
>
BuildPathForMeasuring
(
)
const
;
already_AddRefed
<
Path
>
BuildPath
(
PathBuilder
*
aBuilder
StyleStrokeLinecap
aStrokeLineCap
Float
aStrokeWidth
)
const
;
static
already_AddRefed
<
Path
>
BuildPathForMeasuring
(
Span
<
const
StylePathCommand
>
aPath
)
;
static
already_AddRefed
<
Path
>
BuildPath
(
Span
<
const
StylePathCommand
>
aPath
PathBuilder
*
aBuilder
StyleStrokeLinecap
aStrokeLineCap
Float
aStrokeWidth
float
aZoomFactor
=
1
.
0
)
;
const_iterator
begin
(
)
const
{
return
mData
.
Elements
(
)
;
}
const_iterator
end
(
)
const
{
return
mData
.
Elements
(
)
+
mData
.
Length
(
)
;
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
using
iterator
=
float
*
;
nsresult
CopyFrom
(
const
SVGPathData
&
rhs
)
;
float
&
operator
[
]
(
uint32_t
aIndex
)
{
return
mData
[
aIndex
]
;
}
bool
SetLength
(
uint32_t
aLength
)
{
return
mData
.
SetLength
(
aLength
fallible
)
;
}
nsresult
SetValueFromString
(
const
nsAString
&
aValue
)
;
void
Clear
(
)
{
mData
.
Clear
(
)
;
}
nsresult
AppendSeg
(
uint32_t
aType
.
.
.
)
;
iterator
begin
(
)
{
return
mData
.
Elements
(
)
;
}
iterator
end
(
)
{
return
mData
.
Elements
(
)
+
mData
.
Length
(
)
;
}
FallibleTArray
<
float
>
mData
;
}
;
class
SVGPathDataAndInfo
final
:
public
SVGPathData
{
public
:
explicit
SVGPathDataAndInfo
(
dom
:
:
SVGElement
*
aElement
=
nullptr
)
:
mElement
(
do_GetWeakReference
(
static_cast
<
nsINode
*
>
(
aElement
)
)
)
{
}
void
SetElement
(
dom
:
:
SVGElement
*
aElement
)
{
mElement
=
do_GetWeakReference
(
static_cast
<
nsINode
*
>
(
aElement
)
)
;
}
dom
:
:
SVGElement
*
Element
(
)
const
{
nsCOMPtr
<
nsIContent
>
e
=
do_QueryReferent
(
mElement
)
;
return
static_cast
<
dom
:
:
SVGElement
*
>
(
e
.
get
(
)
)
;
}
nsresult
CopyFrom
(
const
SVGPathDataAndInfo
&
rhs
)
{
mElement
=
rhs
.
mElement
;
return
SVGPathData
:
:
CopyFrom
(
rhs
)
;
}
bool
IsIdentity
(
)
const
{
if
(
!
mElement
)
{
MOZ_ASSERT
(
IsEmpty
(
)
"
target
element
propagation
failure
"
)
;
return
true
;
}
return
false
;
}
using
SVGPathData
:
:
CopyFrom
;
using
SVGPathData
:
:
iterator
;
using
SVGPathData
:
:
operator
[
]
;
using
SVGPathData
:
:
begin
;
using
SVGPathData
:
:
end
;
using
SVGPathData
:
:
SetLength
;
private
:
nsWeakPtr
mElement
;
}
;
}
#
endif
