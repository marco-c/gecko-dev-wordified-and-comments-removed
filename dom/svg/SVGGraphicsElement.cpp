#
include
"
mozilla
/
dom
/
SVGGraphicsElement
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
SVGGraphicsElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGMatrix
.
h
"
#
include
"
mozilla
/
dom
/
SVGRect
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
ISVGDisplayableFrame
.
h
"
#
include
"
mozilla
/
SVGContentUtils
.
h
"
#
include
"
mozilla
/
SVGTextFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsLayoutUtils
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_ADDREF_INHERITED
(
SVGGraphicsElement
SVGGraphicsElementBase
)
NS_IMPL_RELEASE_INHERITED
(
SVGGraphicsElement
SVGGraphicsElementBase
)
NS_INTERFACE_MAP_BEGIN
(
SVGGraphicsElement
)
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
dom
:
:
SVGTests
)
NS_INTERFACE_MAP_END_INHERITING
(
SVGGraphicsElementBase
)
SVGGraphicsElement
:
:
SVGGraphicsElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGGraphicsElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
}
SVGElement
*
SVGGraphicsElement
:
:
GetNearestViewportElement
(
)
{
return
SVGContentUtils
:
:
GetNearestViewportElement
(
this
)
;
}
SVGElement
*
SVGGraphicsElement
:
:
GetFarthestViewportElement
(
)
{
return
SVGContentUtils
:
:
GetOuterSVGElement
(
this
)
;
}
static
already_AddRefed
<
SVGRect
>
ZeroBBox
(
SVGGraphicsElement
&
aOwner
)
{
return
MakeAndAddRef
<
SVGRect
>
(
&
aOwner
gfx
:
:
Rect
{
0
0
0
0
}
)
;
}
already_AddRefed
<
SVGRect
>
SVGGraphicsElement
:
:
GetBBox
(
const
SVGBoundingBoxOptions
&
aOptions
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Layout
)
;
if
(
!
frame
|
|
frame
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
return
ZeroBBox
(
*
this
)
;
}
ISVGDisplayableFrame
*
svgframe
=
do_QueryFrame
(
frame
)
;
if
(
!
svgframe
)
{
if
(
!
frame
-
>
IsInSVGTextSubtree
(
)
)
{
return
ZeroBBox
(
*
this
)
;
}
SVGTextFrame
*
text
=
static_cast
<
SVGTextFrame
*
>
(
nsLayoutUtils
:
:
GetClosestFrameOfType
(
frame
-
>
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
)
;
if
(
text
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
return
ZeroBBox
(
*
this
)
;
}
gfxRect
rec
=
text
-
>
TransformFrameRectFromTextChild
(
frame
-
>
GetRectRelativeToSelf
(
)
frame
)
;
rec
.
x
+
=
float
(
text
-
>
GetPosition
(
)
.
x
)
/
AppUnitsPerCSSPixel
(
)
;
rec
.
y
+
=
float
(
text
-
>
GetPosition
(
)
.
y
)
/
AppUnitsPerCSSPixel
(
)
;
return
do_AddRef
(
new
SVGRect
(
this
ToRect
(
rec
)
)
)
;
}
if
(
!
NS_SVGNewGetBBoxEnabled
(
)
)
{
return
do_AddRef
(
new
SVGRect
(
this
ToRect
(
SVGUtils
:
:
GetBBox
(
frame
SVGUtils
:
:
eBBoxIncludeFillGeometry
|
SVGUtils
:
:
eUseUserSpaceOfUseElement
)
)
)
)
;
}
uint32_t
flags
=
0
;
if
(
aOptions
.
mFill
)
{
flags
|
=
SVGUtils
:
:
eBBoxIncludeFill
;
}
if
(
aOptions
.
mStroke
)
{
flags
|
=
SVGUtils
:
:
eBBoxIncludeStroke
;
}
if
(
aOptions
.
mMarkers
)
{
flags
|
=
SVGUtils
:
:
eBBoxIncludeMarkers
;
}
if
(
aOptions
.
mClipped
)
{
flags
|
=
SVGUtils
:
:
eBBoxIncludeClipped
;
}
if
(
flags
=
=
0
)
{
return
do_AddRef
(
new
SVGRect
(
this
gfx
:
:
Rect
(
)
)
)
;
}
if
(
flags
=
=
SVGUtils
:
:
eBBoxIncludeMarkers
|
|
flags
=
=
SVGUtils
:
:
eBBoxIncludeClipped
)
{
flags
|
=
SVGUtils
:
:
eBBoxIncludeFill
;
}
flags
|
=
SVGUtils
:
:
eUseUserSpaceOfUseElement
;
return
do_AddRef
(
new
SVGRect
(
this
ToRect
(
SVGUtils
:
:
GetBBox
(
frame
flags
)
)
)
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGGraphicsElement
:
:
GetCTM
(
)
{
if
(
auto
*
currentDoc
=
GetComposedDoc
(
)
)
{
currentDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
gfx
:
:
Matrix
m
=
SVGContentUtils
:
:
GetCTM
(
this
false
)
;
RefPtr
<
SVGMatrix
>
mat
=
m
.
IsSingular
(
)
?
nullptr
:
new
SVGMatrix
(
ThebesMatrix
(
m
)
)
;
return
mat
.
forget
(
)
;
}
already_AddRefed
<
SVGMatrix
>
SVGGraphicsElement
:
:
GetScreenCTM
(
)
{
if
(
auto
*
currentDoc
=
GetComposedDoc
(
)
)
{
currentDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
gfx
:
:
Matrix
m
=
SVGContentUtils
:
:
GetCTM
(
this
true
)
;
RefPtr
<
SVGMatrix
>
mat
=
m
.
IsSingular
(
)
?
nullptr
:
new
SVGMatrix
(
ThebesMatrix
(
m
)
)
;
return
mat
.
forget
(
)
;
}
bool
SVGGraphicsElement
:
:
IsSVGFocusable
(
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
!
IsInComposedDoc
(
)
|
|
IsInDesignMode
(
)
)
{
*
aTabIndex
=
-
1
;
*
aIsFocusable
=
false
;
return
true
;
}
*
aTabIndex
=
TabIndex
(
)
;
*
aIsFocusable
=
*
aTabIndex
>
=
0
|
|
GetTabIndexAttrValue
(
)
.
isSome
(
)
;
return
false
;
}
Focusable
SVGGraphicsElement
:
:
IsFocusableWithoutStyle
(
bool
aWithMouse
)
{
Focusable
result
;
IsSVGFocusable
(
&
result
.
mFocusable
&
result
.
mTabIndex
)
;
return
result
;
}
}
