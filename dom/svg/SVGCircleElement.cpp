#
include
"
ComputedStyle
.
h
"
#
include
"
mozilla
/
dom
/
SVGCircleElement
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
SVGCircleElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGLengthBinding
.
h
"
#
include
"
SVGGeometryProperty
.
h
"
NS_IMPL_NS_NEW_SVG_ELEMENT
(
Circle
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
JSObject
*
SVGCircleElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGCircleElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
SVGElement
:
:
LengthInfo
SVGCircleElement
:
:
sLengthInfo
[
3
]
=
{
{
nsGkAtoms
:
:
cx
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
X
}
{
nsGkAtoms
:
:
cy
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
Y
}
{
nsGkAtoms
:
:
r
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
XY
}
}
;
SVGCircleElement
:
:
SVGCircleElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGCircleElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
}
bool
SVGCircleElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
return
IsInLengthInfo
(
aAttribute
sLengthInfo
)
|
|
SVGCircleElementBase
:
:
IsAttributeMapped
(
aAttribute
)
;
}
namespace
SVGT
=
SVGGeometryProperty
:
:
Tags
;
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGCircleElement
)
already_AddRefed
<
DOMSVGAnimatedLength
>
SVGCircleElement
:
:
Cx
(
)
{
return
mLengthAttributes
[
ATTR_CX
]
.
ToDOMAnimatedLength
(
this
)
;
}
already_AddRefed
<
DOMSVGAnimatedLength
>
SVGCircleElement
:
:
Cy
(
)
{
return
mLengthAttributes
[
ATTR_CY
]
.
ToDOMAnimatedLength
(
this
)
;
}
already_AddRefed
<
DOMSVGAnimatedLength
>
SVGCircleElement
:
:
R
(
)
{
return
mLengthAttributes
[
ATTR_R
]
.
ToDOMAnimatedLength
(
this
)
;
}
bool
SVGCircleElement
:
:
HasValidDimensions
(
)
const
{
float
r
;
if
(
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
R
>
(
this
&
r
)
)
{
return
r
>
0
;
}
return
mLengthAttributes
[
ATTR_R
]
.
IsExplicitlySet
(
)
&
&
mLengthAttributes
[
ATTR_R
]
.
GetAnimValInSpecifiedUnits
(
)
>
0
;
}
SVGElement
:
:
LengthAttributesInfo
SVGCircleElement
:
:
GetLengthInfo
(
)
{
return
LengthAttributesInfo
(
mLengthAttributes
sLengthInfo
ArrayLength
(
sLengthInfo
)
)
;
}
bool
SVGCircleElement
:
:
GetGeometryBounds
(
Rect
*
aBounds
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aToBoundsSpace
const
Matrix
*
aToNonScalingStrokeSpace
)
{
float
x
y
r
;
DebugOnly
<
bool
>
ok
=
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
Cx
SVGT
:
:
Cy
SVGT
:
:
R
>
(
this
&
x
&
y
&
r
)
;
MOZ_ASSERT
(
ok
"
SVGGeometryProperty
:
:
ResolveAll
failed
"
)
;
if
(
r
<
=
0
.
f
)
{
*
aBounds
=
Rect
(
aToBoundsSpace
.
TransformPoint
(
Point
(
x
y
)
)
Size
(
)
)
;
return
true
;
}
if
(
aToBoundsSpace
.
IsRectilinear
(
)
)
{
if
(
aStrokeOptions
.
mLineWidth
>
0
.
f
)
{
if
(
aToNonScalingStrokeSpace
)
{
if
(
aToNonScalingStrokeSpace
-
>
IsRectilinear
(
)
)
{
MOZ_ASSERT
(
!
aToNonScalingStrokeSpace
-
>
IsSingular
(
)
)
;
Rect
userBounds
(
x
-
r
y
-
r
2
*
r
2
*
r
)
;
SVGContentUtils
:
:
RectilinearGetStrokeBounds
(
userBounds
aToBoundsSpace
*
aToNonScalingStrokeSpace
aStrokeOptions
.
mLineWidth
aBounds
)
;
return
true
;
}
return
false
;
}
r
+
=
aStrokeOptions
.
mLineWidth
/
2
.
f
;
}
Rect
rect
(
x
-
r
y
-
r
2
*
r
2
*
r
)
;
*
aBounds
=
aToBoundsSpace
.
TransformBounds
(
rect
)
;
return
true
;
}
return
false
;
}
already_AddRefed
<
Path
>
SVGCircleElement
:
:
BuildPath
(
PathBuilder
*
aBuilder
)
{
float
x
y
r
;
if
(
!
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
Cx
SVGT
:
:
Cy
SVGT
:
:
R
>
(
this
&
x
&
y
&
r
)
)
{
GetAnimatedLengthValues
(
&
x
&
y
&
r
nullptr
)
;
}
if
(
r
<
=
0
.
0f
)
{
return
nullptr
;
}
aBuilder
-
>
Arc
(
Point
(
x
y
)
r
0
Float
(
2
*
M_PI
)
)
;
return
aBuilder
-
>
Finish
(
)
;
}
bool
SVGCircleElement
:
:
IsLengthChangedViaCSS
(
const
ComputedStyle
&
aNewStyle
const
ComputedStyle
&
aOldStyle
)
{
const
auto
&
newSVGReset
=
*
aNewStyle
.
StyleSVGReset
(
)
;
const
auto
&
oldSVGReset
=
*
aOldStyle
.
StyleSVGReset
(
)
;
return
newSVGReset
.
mCx
!
=
oldSVGReset
.
mCx
|
|
newSVGReset
.
mCy
!
=
oldSVGReset
.
mCy
|
|
newSVGReset
.
mR
!
=
oldSVGReset
.
mR
;
}
nsCSSPropertyID
SVGCircleElement
:
:
GetCSSPropertyIdForAttrEnum
(
uint8_t
aAttrEnum
)
{
switch
(
aAttrEnum
)
{
case
ATTR_CX
:
return
eCSSProperty_cx
;
case
ATTR_CY
:
return
eCSSProperty_cy
;
case
ATTR_R
:
return
eCSSProperty_r
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
attr
enum
"
)
;
return
eCSSProperty_UNKNOWN
;
}
}
}
}
