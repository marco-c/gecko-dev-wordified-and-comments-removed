#
include
"
mozilla
/
dom
/
SVGCircleElement
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
SVGCircleElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGLengthBinding
.
h
"
NS_IMPL_NS_NEW_SVG_ELEMENT
(
Circle
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
JSObject
*
SVGCircleElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGCircleElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
SVGElement
:
:
LengthInfo
SVGCircleElement
:
:
sLengthInfo
[
3
]
=
{
{
nsGkAtoms
:
:
cx
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
X
}
{
nsGkAtoms
:
:
cy
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
Y
}
{
nsGkAtoms
:
:
r
0
SVGLength_Binding
:
:
SVG_LENGTHTYPE_NUMBER
SVGContentUtils
:
:
XY
}
}
;
SVGCircleElement
:
:
SVGCircleElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
SVGCircleElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
}
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGCircleElement
)
already_AddRefed
<
DOMSVGAnimatedLength
>
SVGCircleElement
:
:
Cx
(
)
{
return
mLengthAttributes
[
ATTR_CX
]
.
ToDOMAnimatedLength
(
this
)
;
}
already_AddRefed
<
DOMSVGAnimatedLength
>
SVGCircleElement
:
:
Cy
(
)
{
return
mLengthAttributes
[
ATTR_CY
]
.
ToDOMAnimatedLength
(
this
)
;
}
already_AddRefed
<
DOMSVGAnimatedLength
>
SVGCircleElement
:
:
R
(
)
{
return
mLengthAttributes
[
ATTR_R
]
.
ToDOMAnimatedLength
(
this
)
;
}
bool
SVGCircleElement
:
:
HasValidDimensions
(
)
const
{
return
mLengthAttributes
[
ATTR_R
]
.
IsExplicitlySet
(
)
&
&
mLengthAttributes
[
ATTR_R
]
.
GetAnimValInSpecifiedUnits
(
)
>
0
;
}
SVGElement
:
:
LengthAttributesInfo
SVGCircleElement
:
:
GetLengthInfo
(
)
{
return
LengthAttributesInfo
(
mLengthAttributes
sLengthInfo
ArrayLength
(
sLengthInfo
)
)
;
}
bool
SVGCircleElement
:
:
GetGeometryBounds
(
Rect
*
aBounds
const
StrokeOptions
&
aStrokeOptions
const
Matrix
&
aToBoundsSpace
const
Matrix
*
aToNonScalingStrokeSpace
)
{
float
x
y
r
;
GetAnimatedLengthValues
(
&
x
&
y
&
r
nullptr
)
;
if
(
r
<
=
0
.
f
)
{
*
aBounds
=
Rect
(
aToBoundsSpace
.
TransformPoint
(
Point
(
x
y
)
)
Size
(
)
)
;
return
true
;
}
if
(
aToBoundsSpace
.
IsRectilinear
(
)
)
{
if
(
aStrokeOptions
.
mLineWidth
>
0
.
f
)
{
if
(
aToNonScalingStrokeSpace
)
{
if
(
aToNonScalingStrokeSpace
-
>
IsRectilinear
(
)
)
{
MOZ_ASSERT
(
!
aToNonScalingStrokeSpace
-
>
IsSingular
(
)
)
;
Rect
userBounds
(
x
-
r
y
-
r
2
*
r
2
*
r
)
;
SVGContentUtils
:
:
RectilinearGetStrokeBounds
(
userBounds
aToBoundsSpace
*
aToNonScalingStrokeSpace
aStrokeOptions
.
mLineWidth
aBounds
)
;
return
true
;
}
return
false
;
}
r
+
=
aStrokeOptions
.
mLineWidth
/
2
.
f
;
}
Rect
rect
(
x
-
r
y
-
r
2
*
r
2
*
r
)
;
*
aBounds
=
aToBoundsSpace
.
TransformBounds
(
rect
)
;
return
true
;
}
return
false
;
}
already_AddRefed
<
Path
>
SVGCircleElement
:
:
BuildPath
(
PathBuilder
*
aBuilder
)
{
float
x
y
r
;
GetAnimatedLengthValues
(
&
x
&
y
&
r
nullptr
)
;
if
(
r
<
=
0
.
0f
)
{
return
nullptr
;
}
aBuilder
-
>
Arc
(
Point
(
x
y
)
r
0
Float
(
2
*
M_PI
)
)
;
return
aBuilder
-
>
Finish
(
)
;
}
}
}
