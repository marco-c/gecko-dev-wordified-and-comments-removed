#
include
"
SVGViewBox
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
SMILValue
.
h
"
#
include
"
mozilla
/
SVGContentUtils
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
SVGViewBoxSMILType
.
h
"
#
include
"
nsTextFormatter
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
#
define
NUM_VIEWBOX_COMPONENTS
4
bool
SVGViewBoxRect
:
:
operator
=
=
(
const
SVGViewBoxRect
&
aOther
)
const
{
if
(
&
aOther
=
=
this
)
return
true
;
return
(
none
&
&
aOther
.
none
)
|
|
(
!
none
&
&
!
aOther
.
none
&
&
x
=
=
aOther
.
x
&
&
y
=
=
aOther
.
y
&
&
width
=
=
aOther
.
width
&
&
height
=
=
aOther
.
height
)
;
}
nsresult
SVGViewBoxRect
:
:
FromString
(
const
nsAString
&
aStr
SVGViewBoxRect
*
aViewBox
)
{
if
(
aStr
.
EqualsLiteral
(
"
none
"
)
)
{
aViewBox
-
>
none
=
true
;
return
NS_OK
;
}
nsCharSeparatedTokenizerTemplate
<
nsContentUtils
:
:
IsHTMLWhitespace
>
tokenizer
(
aStr
'
'
nsCharSeparatedTokenizer
:
:
SEPARATOR_OPTIONAL
)
;
float
vals
[
NUM_VIEWBOX_COMPONENTS
]
;
uint32_t
i
;
for
(
i
=
0
;
i
<
NUM_VIEWBOX_COMPONENTS
&
&
tokenizer
.
hasMoreTokens
(
)
;
+
+
i
)
{
if
(
!
SVGContentUtils
:
:
ParseNumber
(
tokenizer
.
nextToken
(
)
vals
[
i
]
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
}
if
(
i
!
=
NUM_VIEWBOX_COMPONENTS
|
|
tokenizer
.
hasMoreTokens
(
)
|
|
tokenizer
.
separatorAfterCurrentToken
(
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
aViewBox
-
>
x
=
vals
[
0
]
;
aViewBox
-
>
y
=
vals
[
1
]
;
aViewBox
-
>
width
=
vals
[
2
]
;
aViewBox
-
>
height
=
vals
[
3
]
;
aViewBox
-
>
none
=
false
;
return
NS_OK
;
}
NS_SVG_VAL_IMPL_CYCLE_COLLECTION_WRAPPERCACHED
(
SVGViewBox
:
:
DOMBaseVal
mSVGElement
)
NS_SVG_VAL_IMPL_CYCLE_COLLECTION_WRAPPERCACHED
(
SVGViewBox
:
:
DOMAnimVal
mSVGElement
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SVGViewBox
:
:
DOMBaseVal
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SVGViewBox
:
:
DOMBaseVal
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SVGViewBox
:
:
DOMAnimVal
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SVGViewBox
:
:
DOMAnimVal
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGViewBox
:
:
DOMBaseVal
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGViewBox
:
:
DOMAnimVal
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
static
SVGAttrTearoffTable
<
SVGViewBox
SVGViewBox
:
:
DOMBaseVal
>
sBaseSVGViewBoxTearoffTable
;
static
SVGAttrTearoffTable
<
SVGViewBox
SVGViewBox
:
:
DOMAnimVal
>
sAnimSVGViewBoxTearoffTable
;
SVGAttrTearoffTable
<
SVGViewBox
SVGAnimatedRect
>
SVGViewBox
:
:
sSVGAnimatedRectTearoffTable
;
class
MOZ_RAII
AutoChangeViewBoxNotifier
{
public
:
AutoChangeViewBoxNotifier
(
SVGViewBox
*
aViewBox
SVGElement
*
aSVGElement
bool
aDoSetAttr
=
true
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mViewBox
(
aViewBox
)
mSVGElement
(
aSVGElement
)
mDoSetAttr
(
aDoSetAttr
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
mViewBox
"
Expecting
non
-
null
viewBox
"
)
;
MOZ_ASSERT
(
mSVGElement
"
Expecting
non
-
null
element
"
)
;
if
(
mDoSetAttr
)
{
mEmptyOrOldValue
=
mSVGElement
-
>
WillChangeViewBox
(
)
;
}
}
~
AutoChangeViewBoxNotifier
(
)
{
if
(
mDoSetAttr
)
{
mSVGElement
-
>
DidChangeViewBox
(
mEmptyOrOldValue
)
;
}
if
(
mViewBox
-
>
mAnimVal
)
{
mSVGElement
-
>
AnimationNeedsResample
(
)
;
}
}
private
:
SVGViewBox
*
const
mViewBox
;
SVGElement
*
const
mSVGElement
;
nsAttrValue
mEmptyOrOldValue
;
bool
mDoSetAttr
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
void
SVGViewBox
:
:
Init
(
)
{
mHasBaseVal
=
false
;
mBaseVal
.
none
=
true
;
mAnimVal
=
nullptr
;
}
bool
SVGViewBox
:
:
HasRect
(
)
const
{
const
SVGViewBoxRect
*
rect
=
mAnimVal
;
if
(
!
rect
)
{
if
(
!
mHasBaseVal
)
{
return
false
;
}
rect
=
&
mBaseVal
;
}
return
!
rect
-
>
none
&
&
rect
-
>
width
>
=
0
&
&
rect
-
>
height
>
=
0
;
}
void
SVGViewBox
:
:
SetAnimValue
(
const
SVGViewBoxRect
&
aRect
SVGElement
*
aSVGElement
)
{
if
(
!
mAnimVal
)
{
mAnimVal
=
new
SVGViewBoxRect
(
aRect
)
;
}
else
{
if
(
aRect
=
=
*
mAnimVal
)
{
return
;
}
*
mAnimVal
=
aRect
;
}
aSVGElement
-
>
DidAnimateViewBox
(
)
;
}
void
SVGViewBox
:
:
SetBaseValue
(
const
SVGViewBoxRect
&
aRect
SVGElement
*
aSVGElement
)
{
if
(
!
mHasBaseVal
|
|
mBaseVal
=
=
aRect
)
{
mBaseVal
=
aRect
;
return
;
}
AutoChangeViewBoxNotifier
notifier
(
this
aSVGElement
)
;
mBaseVal
=
aRect
;
mHasBaseVal
=
true
;
}
nsresult
SVGViewBox
:
:
SetBaseValueString
(
const
nsAString
&
aValue
SVGElement
*
aSVGElement
bool
aDoSetAttr
)
{
SVGViewBoxRect
viewBox
;
nsresult
rv
=
SVGViewBoxRect
:
:
FromString
(
aValue
&
viewBox
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mHasBaseVal
&
&
viewBox
=
=
mBaseVal
)
{
return
NS_OK
;
}
AutoChangeViewBoxNotifier
notifier
(
this
aSVGElement
aDoSetAttr
)
;
mHasBaseVal
=
true
;
mBaseVal
=
viewBox
;
return
NS_OK
;
}
void
SVGViewBox
:
:
GetBaseValueString
(
nsAString
&
aValue
)
const
{
if
(
mBaseVal
.
none
)
{
aValue
.
AssignLiteral
(
"
none
"
)
;
return
;
}
nsTextFormatter
:
:
ssprintf
(
aValue
u
"
%
g
%
g
%
g
%
g
"
(
double
)
mBaseVal
.
x
(
double
)
mBaseVal
.
y
(
double
)
mBaseVal
.
width
(
double
)
mBaseVal
.
height
)
;
}
already_AddRefed
<
SVGAnimatedRect
>
SVGViewBox
:
:
ToSVGAnimatedRect
(
SVGElement
*
aSVGElement
)
{
RefPtr
<
SVGAnimatedRect
>
domAnimatedRect
=
sSVGAnimatedRectTearoffTable
.
GetTearoff
(
this
)
;
if
(
!
domAnimatedRect
)
{
domAnimatedRect
=
new
SVGAnimatedRect
(
this
aSVGElement
)
;
sSVGAnimatedRectTearoffTable
.
AddTearoff
(
this
domAnimatedRect
)
;
}
return
domAnimatedRect
.
forget
(
)
;
}
already_AddRefed
<
SVGIRect
>
SVGViewBox
:
:
ToDOMBaseVal
(
SVGElement
*
aSVGElement
)
{
if
(
!
mHasBaseVal
|
|
mBaseVal
.
none
)
{
return
nullptr
;
}
RefPtr
<
DOMBaseVal
>
domBaseVal
=
sBaseSVGViewBoxTearoffTable
.
GetTearoff
(
this
)
;
if
(
!
domBaseVal
)
{
domBaseVal
=
new
DOMBaseVal
(
this
aSVGElement
)
;
sBaseSVGViewBoxTearoffTable
.
AddTearoff
(
this
domBaseVal
)
;
}
return
domBaseVal
.
forget
(
)
;
}
SVGViewBox
:
:
DOMBaseVal
:
:
~
DOMBaseVal
(
)
{
sBaseSVGViewBoxTearoffTable
.
RemoveTearoff
(
mVal
)
;
}
already_AddRefed
<
SVGIRect
>
SVGViewBox
:
:
ToDOMAnimVal
(
SVGElement
*
aSVGElement
)
{
if
(
(
mAnimVal
&
&
mAnimVal
-
>
none
)
|
|
(
!
mAnimVal
&
&
(
!
mHasBaseVal
|
|
mBaseVal
.
none
)
)
)
{
return
nullptr
;
}
RefPtr
<
DOMAnimVal
>
domAnimVal
=
sAnimSVGViewBoxTearoffTable
.
GetTearoff
(
this
)
;
if
(
!
domAnimVal
)
{
domAnimVal
=
new
DOMAnimVal
(
this
aSVGElement
)
;
sAnimSVGViewBoxTearoffTable
.
AddTearoff
(
this
domAnimVal
)
;
}
return
domAnimVal
.
forget
(
)
;
}
SVGViewBox
:
:
DOMAnimVal
:
:
~
DOMAnimVal
(
)
{
sAnimSVGViewBoxTearoffTable
.
RemoveTearoff
(
mVal
)
;
}
void
SVGViewBox
:
:
DOMBaseVal
:
:
SetX
(
float
aX
ErrorResult
&
aRv
)
{
SVGViewBoxRect
rect
=
mVal
-
>
GetBaseValue
(
)
;
rect
.
x
=
aX
;
mVal
-
>
SetBaseValue
(
rect
mSVGElement
)
;
}
void
SVGViewBox
:
:
DOMBaseVal
:
:
SetY
(
float
aY
ErrorResult
&
aRv
)
{
SVGViewBoxRect
rect
=
mVal
-
>
GetBaseValue
(
)
;
rect
.
y
=
aY
;
mVal
-
>
SetBaseValue
(
rect
mSVGElement
)
;
}
void
SVGViewBox
:
:
DOMBaseVal
:
:
SetWidth
(
float
aWidth
ErrorResult
&
aRv
)
{
SVGViewBoxRect
rect
=
mVal
-
>
GetBaseValue
(
)
;
rect
.
width
=
aWidth
;
mVal
-
>
SetBaseValue
(
rect
mSVGElement
)
;
}
void
SVGViewBox
:
:
DOMBaseVal
:
:
SetHeight
(
float
aHeight
ErrorResult
&
aRv
)
{
SVGViewBoxRect
rect
=
mVal
-
>
GetBaseValue
(
)
;
rect
.
height
=
aHeight
;
mVal
-
>
SetBaseValue
(
rect
mSVGElement
)
;
}
UniquePtr
<
SMILAttr
>
SVGViewBox
:
:
ToSMILAttr
(
SVGElement
*
aSVGElement
)
{
return
MakeUnique
<
SMILViewBox
>
(
this
aSVGElement
)
;
}
nsresult
SVGViewBox
:
:
SMILViewBox
:
:
ValueFromString
(
const
nsAString
&
aStr
const
SVGAnimationElement
*
SMILValue
&
aValue
bool
&
aPreventCachingOfSandwich
)
const
{
SVGViewBoxRect
viewBox
;
nsresult
res
=
SVGViewBoxRect
:
:
FromString
(
aStr
&
viewBox
)
;
if
(
NS_FAILED
(
res
)
)
{
return
res
;
}
SMILValue
val
(
&
SVGViewBoxSMILType
:
:
sSingleton
)
;
*
static_cast
<
SVGViewBoxRect
*
>
(
val
.
mU
.
mPtr
)
=
viewBox
;
aValue
=
std
:
:
move
(
val
)
;
aPreventCachingOfSandwich
=
false
;
return
NS_OK
;
}
SMILValue
SVGViewBox
:
:
SMILViewBox
:
:
GetBaseValue
(
)
const
{
SMILValue
val
(
&
SVGViewBoxSMILType
:
:
sSingleton
)
;
*
static_cast
<
SVGViewBoxRect
*
>
(
val
.
mU
.
mPtr
)
=
mVal
-
>
mBaseVal
;
return
val
;
}
void
SVGViewBox
:
:
SMILViewBox
:
:
ClearAnimValue
(
)
{
if
(
mVal
-
>
mAnimVal
)
{
mVal
-
>
mAnimVal
=
nullptr
;
mSVGElement
-
>
DidAnimateViewBox
(
)
;
}
}
nsresult
SVGViewBox
:
:
SMILViewBox
:
:
SetAnimValue
(
const
SMILValue
&
aValue
)
{
NS_ASSERTION
(
aValue
.
mType
=
=
&
SVGViewBoxSMILType
:
:
sSingleton
"
Unexpected
type
to
assign
animated
value
"
)
;
if
(
aValue
.
mType
=
=
&
SVGViewBoxSMILType
:
:
sSingleton
)
{
SVGViewBoxRect
&
vb
=
*
static_cast
<
SVGViewBoxRect
*
>
(
aValue
.
mU
.
mPtr
)
;
mVal
-
>
SetAnimValue
(
vb
mSVGElement
)
;
}
return
NS_OK
;
}
}
