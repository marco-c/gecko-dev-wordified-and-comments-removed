#
include
"
DOMSVGTransformList
.
h
"
#
include
<
algorithm
>
#
include
"
DOMSVGTransform
.
h
"
#
include
"
SVGAnimatedTransformList
.
h
"
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGMatrix
.
h
"
#
include
"
mozilla
/
dom
/
SVGTransformListBinding
.
h
"
#
include
"
nsError
.
h
"
namespace
{
void
UpdateListIndicesFromIndex
(
FallibleTArray
<
mozilla
:
:
dom
:
:
DOMSVGTransform
*
>
&
aItemsArray
uint32_t
aStartingIndex
)
{
uint32_t
length
=
aItemsArray
.
Length
(
)
;
for
(
uint32_t
i
=
aStartingIndex
;
i
<
length
;
+
+
i
)
{
if
(
aItemsArray
[
i
]
)
{
aItemsArray
[
i
]
-
>
UpdateListIndex
(
i
)
;
}
}
}
}
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
DOMSVGTransformList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
DOMSVGTransformList
)
if
(
tmp
-
>
mAList
)
{
if
(
tmp
-
>
IsAnimValList
(
)
)
{
tmp
-
>
mAList
-
>
mAnimVal
=
nullptr
;
}
else
{
tmp
-
>
mAList
-
>
mBaseVal
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAList
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
DOMSVGTransformList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
DOMSVGTransformList
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
DOMSVGTransformList
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
DOMSVGTransformList
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DOMSVGTransformList
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
JSObject
*
DOMSVGTransformList
:
:
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
mozilla
:
:
dom
:
:
SVGTransformList_Binding
:
:
Wrap
(
cx
this
aGivenProto
)
;
}
void
DOMSVGTransformList
:
:
InternalListLengthWillChange
(
uint32_t
aNewLength
)
{
uint32_t
oldLength
=
mItems
.
Length
(
)
;
if
(
aNewLength
>
DOMSVGTransform
:
:
MaxListIndex
(
)
)
{
aNewLength
=
DOMSVGTransform
:
:
MaxListIndex
(
)
;
}
RefPtr
<
DOMSVGTransformList
>
kungFuDeathGrip
;
if
(
aNewLength
<
oldLength
)
{
kungFuDeathGrip
=
this
;
}
for
(
uint32_t
i
=
aNewLength
;
i
<
oldLength
;
+
+
i
)
{
if
(
mItems
[
i
]
)
{
mItems
[
i
]
-
>
RemovingFromList
(
)
;
}
}
if
(
!
mItems
.
SetLength
(
aNewLength
fallible
)
)
{
mItems
.
Clear
(
)
;
return
;
}
for
(
uint32_t
i
=
oldLength
;
i
<
aNewLength
;
+
+
i
)
{
mItems
[
i
]
=
nullptr
;
}
}
SVGTransformList
&
DOMSVGTransformList
:
:
InternalList
(
)
const
{
SVGAnimatedTransformList
*
alist
=
Element
(
)
-
>
GetAnimatedTransformList
(
)
;
return
IsAnimValList
(
)
&
&
alist
-
>
mAnimVal
?
*
alist
-
>
mAnimVal
:
alist
-
>
mBaseVal
;
}
void
DOMSVGTransformList
:
:
Clear
(
ErrorResult
&
error
)
{
if
(
IsAnimValList
(
)
)
{
error
.
ThrowNoModificationAllowedError
(
"
Animated
values
cannot
be
set
"
)
;
return
;
}
if
(
LengthNoFlush
(
)
>
0
)
{
AutoChangeTransformListNotifier
notifier
(
this
)
;
mAList
-
>
InternalBaseValListWillChangeLengthTo
(
0
)
;
mItems
.
Clear
(
)
;
auto
*
alist
=
Element
(
)
-
>
GetAnimatedTransformList
(
)
;
alist
-
>
mBaseVal
.
Clear
(
)
;
alist
-
>
mIsBaseSet
=
false
;
}
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
Initialize
(
DOMSVGTransform
&
newItem
ErrorResult
&
error
)
{
if
(
IsAnimValList
(
)
)
{
error
.
ThrowNoModificationAllowedError
(
"
Animated
values
cannot
be
set
"
)
;
return
nullptr
;
}
RefPtr
<
DOMSVGTransform
>
domItem
=
&
newItem
;
if
(
domItem
-
>
HasOwner
(
)
)
{
domItem
=
newItem
.
Clone
(
)
;
}
Clear
(
error
)
;
MOZ_ASSERT
(
!
error
.
Failed
(
)
"
How
could
this
fail
?
"
)
;
return
InsertItemBefore
(
*
domItem
0
error
)
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
GetItem
(
uint32_t
index
ErrorResult
&
error
)
{
bool
found
;
RefPtr
<
DOMSVGTransform
>
item
=
IndexedGetter
(
index
found
error
)
;
if
(
!
found
)
{
error
.
ThrowIndexSizeError
(
"
Index
out
of
range
"
)
;
}
return
item
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
IndexedGetter
(
uint32_t
index
bool
&
found
ErrorResult
&
error
)
{
if
(
IsAnimValList
(
)
)
{
Element
(
)
-
>
FlushAnimations
(
)
;
}
found
=
index
<
LengthNoFlush
(
)
;
if
(
found
)
{
return
GetItemAt
(
index
)
;
}
return
nullptr
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
InsertItemBefore
(
DOMSVGTransform
&
newItem
uint32_t
index
ErrorResult
&
error
)
{
if
(
IsAnimValList
(
)
)
{
error
.
ThrowNoModificationAllowedError
(
"
Animated
values
cannot
be
set
"
)
;
return
nullptr
;
}
index
=
std
:
:
min
(
index
LengthNoFlush
(
)
)
;
if
(
index
>
=
DOMSVGTransform
:
:
MaxListIndex
(
)
)
{
error
.
ThrowIndexSizeError
(
"
Index
out
of
range
"
)
;
return
nullptr
;
}
RefPtr
<
DOMSVGTransform
>
domItem
=
&
newItem
;
if
(
newItem
.
HasOwner
(
)
)
{
domItem
=
newItem
.
Clone
(
)
;
}
if
(
!
mItems
.
SetCapacity
(
mItems
.
Length
(
)
+
1
fallible
)
|
|
!
InternalList
(
)
.
SetCapacity
(
InternalList
(
)
.
Length
(
)
+
1
)
)
{
error
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
if
(
AnimListMirrorsBaseList
(
)
)
{
if
(
!
mAList
-
>
mAnimVal
-
>
mItems
.
SetCapacity
(
mAList
-
>
mAnimVal
-
>
mItems
.
Length
(
)
+
1
fallible
)
)
{
error
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
}
AutoChangeTransformListNotifier
notifier
(
this
)
;
MaybeInsertNullInAnimValListAt
(
index
)
;
InternalList
(
)
.
InsertItem
(
index
domItem
-
>
ToSVGTransform
(
)
)
;
MOZ_ALWAYS_TRUE
(
mItems
.
InsertElementAt
(
index
domItem
.
get
(
)
fallible
)
)
;
domItem
-
>
InsertingIntoList
(
this
index
IsAnimValList
(
)
)
;
UpdateListIndicesFromIndex
(
mItems
index
+
1
)
;
return
domItem
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
ReplaceItem
(
DOMSVGTransform
&
newItem
uint32_t
index
ErrorResult
&
error
)
{
if
(
IsAnimValList
(
)
)
{
error
.
ThrowNoModificationAllowedError
(
"
Animated
values
cannot
be
set
"
)
;
return
nullptr
;
}
if
(
index
>
=
LengthNoFlush
(
)
)
{
error
.
ThrowIndexSizeError
(
"
Index
out
of
range
"
)
;
return
nullptr
;
}
RefPtr
<
DOMSVGTransform
>
domItem
=
&
newItem
;
if
(
newItem
.
HasOwner
(
)
)
{
domItem
=
newItem
.
Clone
(
)
;
}
AutoChangeTransformListNotifier
notifier
(
this
)
;
if
(
mItems
[
index
]
)
{
mItems
[
index
]
-
>
RemovingFromList
(
)
;
}
InternalList
(
)
[
index
]
=
domItem
-
>
ToSVGTransform
(
)
;
mItems
[
index
]
=
domItem
;
domItem
-
>
InsertingIntoList
(
this
index
IsAnimValList
(
)
)
;
return
domItem
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
RemoveItem
(
uint32_t
index
ErrorResult
&
error
)
{
if
(
IsAnimValList
(
)
)
{
error
.
ThrowNoModificationAllowedError
(
"
Animated
values
cannot
be
set
"
)
;
return
nullptr
;
}
if
(
index
>
=
LengthNoFlush
(
)
)
{
error
.
ThrowIndexSizeError
(
"
Index
out
of
range
"
)
;
return
nullptr
;
}
AutoChangeTransformListNotifier
notifier
(
this
)
;
MaybeRemoveItemFromAnimValListAt
(
index
)
;
RefPtr
<
DOMSVGTransform
>
result
=
GetItemAt
(
index
)
;
result
-
>
RemovingFromList
(
)
;
InternalList
(
)
.
RemoveItem
(
index
)
;
mItems
.
RemoveElementAt
(
index
)
;
UpdateListIndicesFromIndex
(
mItems
index
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
CreateSVGTransformFromMatrix
(
const
DOMMatrix2DInit
&
matrix
ErrorResult
&
aRv
)
{
RefPtr
<
DOMSVGTransform
>
result
=
new
DOMSVGTransform
(
matrix
aRv
)
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
Consolidate
(
ErrorResult
&
error
)
{
if
(
IsAnimValList
(
)
)
{
error
.
ThrowNoModificationAllowedError
(
"
Animated
values
cannot
be
set
"
)
;
return
nullptr
;
}
if
(
LengthNoFlush
(
)
=
=
0
)
{
return
nullptr
;
}
gfxMatrix
mx
=
InternalList
(
)
.
GetConsolidationMatrix
(
)
;
Clear
(
error
)
;
MOZ_ASSERT
(
!
error
.
Failed
(
)
"
How
could
this
fail
?
"
)
;
RefPtr
<
DOMSVGTransform
>
transform
=
new
DOMSVGTransform
(
mx
)
;
return
InsertItemBefore
(
*
transform
LengthNoFlush
(
)
error
)
;
}
already_AddRefed
<
DOMSVGTransform
>
DOMSVGTransformList
:
:
GetItemAt
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
<
mItems
.
Length
(
)
)
;
if
(
!
mItems
[
aIndex
]
)
{
mItems
[
aIndex
]
=
new
DOMSVGTransform
(
this
aIndex
IsAnimValList
(
)
)
;
}
RefPtr
<
DOMSVGTransform
>
result
=
mItems
[
aIndex
]
;
return
result
.
forget
(
)
;
}
void
DOMSVGTransformList
:
:
MaybeInsertNullInAnimValListAt
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
!
IsAnimValList
(
)
"
call
from
baseVal
to
animVal
"
)
;
if
(
!
AnimListMirrorsBaseList
(
)
)
{
return
;
}
DOMSVGTransformList
*
animVal
=
mAList
-
>
mAnimVal
;
MOZ_ASSERT
(
animVal
"
AnimListMirrorsBaseList
(
)
promised
a
non
-
null
animVal
"
)
;
MOZ_ASSERT
(
animVal
-
>
mItems
.
Length
(
)
=
=
mItems
.
Length
(
)
"
animVal
list
not
in
sync
!
"
)
;
MOZ_ALWAYS_TRUE
(
animVal
-
>
mItems
.
InsertElementAt
(
aIndex
nullptr
fallible
)
)
;
UpdateListIndicesFromIndex
(
animVal
-
>
mItems
aIndex
+
1
)
;
}
void
DOMSVGTransformList
:
:
MaybeRemoveItemFromAnimValListAt
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
!
IsAnimValList
(
)
"
call
from
baseVal
to
animVal
"
)
;
if
(
!
AnimListMirrorsBaseList
(
)
)
{
return
;
}
RefPtr
<
DOMSVGTransformList
>
animVal
=
mAList
-
>
mAnimVal
;
MOZ_ASSERT
(
animVal
"
AnimListMirrorsBaseList
(
)
promised
a
non
-
null
animVal
"
)
;
MOZ_ASSERT
(
animVal
-
>
mItems
.
Length
(
)
=
=
mItems
.
Length
(
)
"
animVal
list
not
in
sync
!
"
)
;
if
(
animVal
-
>
mItems
[
aIndex
]
)
{
animVal
-
>
mItems
[
aIndex
]
-
>
RemovingFromList
(
)
;
}
animVal
-
>
mItems
.
RemoveElementAt
(
aIndex
)
;
UpdateListIndicesFromIndex
(
animVal
-
>
mItems
aIndex
)
;
}
}
