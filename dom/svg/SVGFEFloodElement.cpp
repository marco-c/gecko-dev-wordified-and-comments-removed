#
include
"
mozilla
/
dom
/
SVGFEFloodElement
.
h
"
#
include
"
FilterSupport
.
h
"
#
include
"
mozilla
/
dom
/
SVGFEFloodElementBinding
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsIFrame
.
h
"
NS_IMPL_NS_NEW_NAMESPACED_SVG_ELEMENT
(
FEFlood
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
dom
{
JSObject
*
SVGFEFloodElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
SVGFEFloodElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsSVGElement
:
:
StringInfo
SVGFEFloodElement
:
:
sStringInfo
[
1
]
=
{
{
&
nsGkAtoms
:
:
result
kNameSpaceID_None
true
}
}
;
NS_IMPL_ELEMENT_CLONE_WITH_INIT
(
SVGFEFloodElement
)
FilterPrimitiveDescription
SVGFEFloodElement
:
:
GetPrimitiveDescription
(
nsSVGFilterInstance
*
aInstance
const
IntRect
&
aFilterSubregion
const
nsTArray
<
bool
>
&
aInputsAreTainted
nsTArray
<
RefPtr
<
SourceSurface
>
>
&
aInputImages
)
{
FilterPrimitiveDescription
descr
(
PrimitiveType
:
:
Flood
)
;
FloodAttributes
atts
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
const
nsStyleSVGReset
*
styleSVGReset
=
frame
-
>
Style
(
)
-
>
StyleSVGReset
(
)
;
Color
color
(
Color
:
:
FromABGR
(
styleSVGReset
-
>
mFloodColor
.
CalcColor
(
frame
)
)
)
;
color
.
a
*
=
styleSVGReset
-
>
mFloodOpacity
;
atts
.
mColor
=
color
;
}
else
{
atts
.
mColor
=
Color
(
)
;
}
descr
.
Attributes
(
)
=
AsVariant
(
std
:
:
move
(
atts
)
)
;
return
descr
;
}
NS_IMETHODIMP_
(
bool
)
SVGFEFloodElement
:
:
IsAttributeMapped
(
const
nsAtom
*
name
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sColorMap
sFEFloodMap
}
;
return
FindAttributeDependence
(
name
map
)
|
|
SVGFEFloodElementBase
:
:
IsAttributeMapped
(
name
)
;
}
nsSVGElement
:
:
StringAttributesInfo
SVGFEFloodElement
:
:
GetStringInfo
(
)
{
return
StringAttributesInfo
(
mStringAttributes
sStringInfo
ArrayLength
(
sStringInfo
)
)
;
}
}
}
