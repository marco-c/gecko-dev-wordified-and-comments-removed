#
ifndef
mozilla_dom_ViewTransition_h
#
define
mozilla_dom_ViewTransition_h
#
include
"
nsRect
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsAtomHashKeys
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
class
nsIGlobalObject
;
class
nsITimer
;
namespace
mozilla
{
class
ErrorResult
;
struct
StyleLockedDeclarationBlock
;
namespace
gfx
{
class
DataSourceSurface
;
}
namespace
dom
{
class
Document
;
class
Element
;
class
Promise
;
class
ViewTransitionUpdateCallback
;
enum
class
SkipTransitionReason
:
uint8_t
{
JS
DocumentHidden
ClobberedActiveTransition
Timeout
UpdateCallbackRejected
DuplicateTransitionNameCapturingOldState
DuplicateTransitionNameCapturingNewState
Resize
}
;
enum
class
ViewTransitionPhase
:
uint8_t
{
PendingCapture
=
0
UpdateCallbackCalled
Animating
Done
}
;
class
ViewTransition
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
using
Phase
=
ViewTransitionPhase
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
ViewTransition
)
ViewTransition
(
Document
&
ViewTransitionUpdateCallback
*
)
;
Promise
*
GetUpdateCallbackDone
(
ErrorResult
&
)
;
Promise
*
GetReady
(
ErrorResult
&
)
;
Promise
*
GetFinished
(
ErrorResult
&
)
;
void
SkipTransition
(
SkipTransitionReason
=
SkipTransitionReason
:
:
JS
)
;
void
PerformPendingOperations
(
)
;
Element
*
GetRoot
(
)
const
{
return
mViewTransitionRoot
;
}
gfx
:
:
DataSourceSurface
*
GetOldSurface
(
nsAtom
*
aName
)
const
;
const
StyleLockedDeclarationBlock
*
GetDynamicRuleFor
(
const
Element
&
)
const
;
nsIGlobalObject
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
struct
CapturedElement
;
private
:
enum
class
CallIfDone
:
bool
{
No
Yes
}
;
MOZ_CAN_RUN_SCRIPT
void
CallUpdateCallbackIgnoringErrors
(
CallIfDone
)
;
MOZ_CAN_RUN_SCRIPT
void
CallUpdateCallback
(
ErrorResult
&
)
;
void
Activate
(
)
;
void
ClearActiveTransition
(
bool
aIsDocumentHidden
)
;
void
Timeout
(
)
;
void
Setup
(
)
;
[
[
nodiscard
]
]
Maybe
<
SkipTransitionReason
>
CaptureOldState
(
)
;
[
[
nodiscard
]
]
Maybe
<
SkipTransitionReason
>
CaptureNewState
(
)
;
void
SetupTransitionPseudoElements
(
)
;
void
ClearNamedElements
(
)
;
void
HandleFrame
(
)
;
bool
CheckForActiveAnimations
(
)
const
;
void
SkipTransition
(
SkipTransitionReason
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
void
ClearTimeoutTimer
(
)
;
nsRect
SnapshotContainingBlockRect
(
)
const
;
~
ViewTransition
(
)
;
RefPtr
<
Document
>
mDocument
;
RefPtr
<
ViewTransitionUpdateCallback
>
mUpdateCallback
;
using
NamedElements
=
nsClassHashtable
<
nsAtomHashKey
CapturedElement
>
;
NamedElements
mNamedElements
;
nsSize
mInitialSnapshotContainingBlockSize
;
RefPtr
<
Promise
>
mUpdateCallbackDonePromise
;
RefPtr
<
Promise
>
mReadyPromise
;
RefPtr
<
Promise
>
mFinishedPromise
;
static
void
TimeoutCallback
(
nsITimer
*
void
*
)
;
RefPtr
<
nsITimer
>
mTimeoutTimer
;
Phase
mPhase
=
Phase
:
:
PendingCapture
;
RefPtr
<
Element
>
mViewTransitionRoot
;
}
;
}
}
#
endif
