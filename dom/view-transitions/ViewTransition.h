#
ifndef
mozilla_dom_ViewTransition_h
#
define
mozilla_dom_ViewTransition_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
layers
/
IpcResourceUpdateQueue
.
h
"
#
include
"
nsAtomHashKeys
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
nsIGlobalObject
;
class
nsITimer
;
namespace
mozilla
{
class
ErrorResult
;
struct
Keyframe
;
struct
PseudoStyleRequest
;
struct
StyleLockedDeclarationBlock
;
namespace
layers
{
class
RenderRootStateManager
;
}
namespace
wr
{
struct
ImageKey
;
class
IpcResourceUpdateQueue
;
}
namespace
dom
{
extern
LazyLogModule
gViewTransitionsLog
;
#
define
VT_LOG
(
.
.
.
)
\
MOZ_LOG
(
mozilla
:
:
dom
:
:
gViewTransitionsLog
mozilla
:
:
LogLevel
:
:
Debug
\
(
__VA_ARGS__
)
)
#
ifdef
DEBUG
#
define
VT_LOG_DEBUG
(
.
.
.
)
VT_LOG
(
__VA_ARGS__
)
#
else
#
define
VT_LOG_DEBUG
(
.
.
.
)
#
endif
class
Document
;
class
Element
;
class
Promise
;
class
ViewTransitionUpdateCallback
;
enum
class
SkipTransitionReason
:
uint8_t
{
JS
DocumentHidden
RootRemoved
ClobberedActiveTransition
Timeout
UpdateCallbackRejected
DuplicateTransitionNameCapturingOldState
DuplicateTransitionNameCapturingNewState
PseudoUpdateFailure
Resize
PageSwap
ResetRendering
}
;
enum
class
ViewTransitionPhase
:
uint8_t
{
PendingCapture
=
0
UpdateCallbackCalled
Animating
Done
}
;
class
ViewTransition
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
using
Phase
=
ViewTransitionPhase
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
ViewTransition
)
ViewTransition
(
Document
&
ViewTransitionUpdateCallback
*
)
;
Promise
*
GetUpdateCallbackDone
(
ErrorResult
&
)
;
Promise
*
GetReady
(
ErrorResult
&
)
;
Promise
*
GetFinished
(
ErrorResult
&
)
;
void
SkipTransition
(
SkipTransitionReason
=
SkipTransitionReason
:
:
JS
)
;
MOZ_CAN_RUN_SCRIPT
void
PerformPendingOperations
(
)
;
Element
*
GetSnapshotContainingBlock
(
)
const
{
return
mSnapshotContainingBlock
;
}
Element
*
GetViewTransitionTreeRoot
(
)
const
;
Maybe
<
nsSize
>
GetOldInkOverflowBoxSize
(
nsAtom
*
aName
)
const
;
Maybe
<
nsSize
>
GetNewInkOverflowBoxSize
(
nsAtom
*
aName
)
const
;
Maybe
<
nsSize
>
GetOldBorderBoxSize
(
nsAtom
*
aName
)
const
;
Maybe
<
nsSize
>
GetNewBorderBoxSize
(
nsAtom
*
aName
)
const
;
Maybe
<
nsPoint
>
GetOldInkOverflowOffset
(
nsAtom
*
aName
)
const
;
Maybe
<
nsPoint
>
GetNewInkOverflowOffset
(
nsAtom
*
aName
)
const
;
const
wr
:
:
ImageKey
*
GetOrCreateOldImageKey
(
nsAtom
*
aName
layers
:
:
RenderRootStateManager
*
wr
:
:
IpcResourceUpdateQueue
&
)
const
;
const
wr
:
:
ImageKey
*
ReadOldImageKey
(
nsAtom
*
aName
layers
:
:
RenderRootStateManager
*
wr
:
:
IpcResourceUpdateQueue
&
)
const
;
const
wr
:
:
ImageKey
*
GetNewImageKey
(
nsAtom
*
aName
)
const
;
const
wr
:
:
ImageKey
*
GetImageKeyForCapturedFrame
(
nsIFrame
*
aFrame
layers
:
:
RenderRootStateManager
*
wr
:
:
IpcResourceUpdateQueue
&
)
const
;
Element
*
FindPseudo
(
const
PseudoStyleRequest
&
)
const
;
const
StyleLockedDeclarationBlock
*
GetDynamicRuleFor
(
const
Element
&
)
const
;
static
constexpr
nsLiteralString
kGroupAnimPrefix
=
u
"
-
ua
-
view
-
transition
-
group
-
anim
-
"
_ns
;
[
[
nodiscard
]
]
bool
GetGroupKeyframes
(
nsAtom
*
aAnimationName
const
StyleComputedTimingFunction
&
nsTArray
<
Keyframe
>
&
)
;
bool
MatchClassList
(
nsAtom
*
const
nsTArray
<
StyleAtom
>
&
)
const
;
nsIGlobalObject
*
GetParentObject
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
struct
CapturedElement
;
static
nsRect
SnapshotContainingBlockRect
(
nsPresContext
*
)
;
MOZ_CAN_RUN_SCRIPT
void
CallUpdateCallback
(
ErrorResult
&
)
;
private
:
MOZ_CAN_RUN_SCRIPT
void
MaybeScheduleUpdateCallback
(
)
;
void
Activate
(
)
;
void
ClearActiveTransition
(
bool
aIsDocumentHidden
)
;
void
Timeout
(
)
;
MOZ_CAN_RUN_SCRIPT
void
Setup
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
Maybe
<
SkipTransitionReason
>
CaptureOldState
(
)
;
[
[
nodiscard
]
]
Maybe
<
SkipTransitionReason
>
CaptureNewState
(
)
;
void
SetupTransitionPseudoElements
(
)
;
[
[
nodiscard
]
]
bool
UpdatePseudoElementStyles
(
bool
aNeedsInvalidation
)
;
void
ClearNamedElements
(
)
;
void
HandleFrame
(
)
;
bool
CheckForActiveAnimations
(
)
const
;
void
SkipTransition
(
SkipTransitionReason
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
void
ClearTimeoutTimer
(
)
;
nsRect
SnapshotContainingBlockRect
(
)
const
;
Maybe
<
uint64_t
>
GetElementIdentifier
(
Element
*
aElement
)
const
;
uint64_t
EnsureElementIdentifier
(
Element
*
aElement
)
;
already_AddRefed
<
nsAtom
>
DocumentScopedTransitionNameFor
(
nsIFrame
*
aFrame
)
;
~
ViewTransition
(
)
;
RefPtr
<
Document
>
mDocument
;
RefPtr
<
ViewTransitionUpdateCallback
>
mUpdateCallback
;
using
NamedElements
=
nsClassHashtable
<
nsAtomHashKey
CapturedElement
>
;
NamedElements
mNamedElements
;
AutoTArray
<
RefPtr
<
nsAtom
>
8
>
mNames
;
using
ElementIdentifiers
=
nsTHashMap
<
Element
*
uint64_t
>
;
ElementIdentifiers
mElementIdentifiers
;
nsSize
mInitialSnapshotContainingBlockSize
;
RefPtr
<
Promise
>
mUpdateCallbackDonePromise
;
RefPtr
<
Promise
>
mReadyPromise
;
RefPtr
<
Promise
>
mFinishedPromise
;
static
void
TimeoutCallback
(
nsITimer
*
void
*
)
;
RefPtr
<
nsITimer
>
mTimeoutTimer
;
Phase
mPhase
=
Phase
:
:
PendingCapture
;
RefPtr
<
Element
>
mSnapshotContainingBlock
;
}
;
}
}
#
endif
