#
include
"
ViewTransition
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
WindowRenderer
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
mozilla
/
dom
/
ViewTransitionBinding
.
h
"
#
include
"
mozilla
/
image
/
WebRenderImageProvider
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
AnimationEventDispatcher
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
ElementAnimationData
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
mozilla
/
SVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFrameState
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
Units
.
h
"
namespace
mozilla
:
:
dom
{
LazyLogModule
gViewTransitionsLog
(
"
ViewTransitions
"
)
;
static
void
SetCaptured
(
nsIFrame
*
aFrame
bool
aCaptured
)
{
aFrame
-
>
AddOrRemoveStateBits
(
NS_FRAME_CAPTURED_IN_VIEW_TRANSITION
aCaptured
)
;
aFrame
-
>
InvalidateFrameSubtree
(
)
;
if
(
aFrame
-
>
Style
(
)
-
>
IsRootElementStyle
(
)
)
{
aFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
-
>
InvalidateFrameSubtree
(
)
;
}
}
static
CSSToCSSMatrix4x4Flagged
EffectiveTransform
(
nsIFrame
*
aFrame
)
{
CSSToCSSMatrix4x4Flagged
matrix
;
if
(
aFrame
-
>
GetSize
(
)
.
IsEmpty
(
)
|
|
aFrame
-
>
Style
(
)
-
>
IsRootElementStyle
(
)
)
{
return
matrix
;
}
CSSSize
untransformedSize
=
CSSSize
:
:
FromAppUnits
(
aFrame
-
>
GetSize
(
)
)
;
CSSRect
boundingRect
=
CSSRect
:
:
FromAppUnits
(
aFrame
-
>
GetBoundingClientRect
(
)
)
;
if
(
boundingRect
.
Size
(
)
!
=
untransformedSize
)
{
float
sx
=
boundingRect
.
width
/
untransformedSize
.
width
;
float
sy
=
boundingRect
.
height
/
untransformedSize
.
height
;
matrix
=
CSSToCSSMatrix4x4Flagged
:
:
Scaling
(
sx
sy
0
.
0f
)
;
}
if
(
boundingRect
.
TopLeft
(
)
!
=
CSSPoint
(
)
)
{
matrix
.
PostTranslate
(
boundingRect
.
x
boundingRect
.
y
0
.
0f
)
;
}
return
matrix
;
}
static
RefPtr
<
gfx
:
:
DataSourceSurface
>
CaptureFallbackSnapshot
(
nsIFrame
*
aFrame
)
{
VT_LOG_DEBUG
(
"
CaptureFallbackSnapshot
(
%
s
)
"
aFrame
-
>
ListTag
(
)
.
get
(
)
)
;
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
const
bool
isRoot
=
aFrame
-
>
Style
(
)
-
>
IsRootElementStyle
(
)
;
nsIFrame
*
frameToCapture
=
isRoot
?
pc
-
>
PresShell
(
)
-
>
GetCanvasFrame
(
)
:
aFrame
;
const
nsRect
rect
=
isRoot
?
ViewTransition
:
:
SnapshotContainingBlockRect
(
pc
)
:
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
;
const
auto
surfaceRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
rect
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
const
auto
format
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
RefPtr
<
gfx
:
:
DrawTarget
>
dt
=
gfx
:
:
Factory
:
:
CreateDrawTarget
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSoftwareBackend
(
)
surfaceRect
.
Size
(
)
.
ToUnknownSize
(
)
format
)
;
if
(
NS_WARN_IF
(
!
dt
)
|
|
NS_WARN_IF
(
!
dt
-
>
IsValid
(
)
)
)
{
return
nullptr
;
}
{
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
gfxContext
thebes
(
dt
)
;
const
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
InTransform
;
nsLayoutUtils
:
:
PaintFrame
(
&
thebes
frameToCapture
rect
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
}
RefPtr
<
gfx
:
:
SourceSurface
>
surf
=
dt
-
>
GetBackingSurface
(
)
;
if
(
NS_WARN_IF
(
!
surf
)
)
{
return
nullptr
;
}
return
surf
-
>
GetDataSurface
(
)
;
}
static
constexpr
wr
:
:
ImageKey
kNoKey
{
{
0
}
0
}
;
struct
OldSnapshotData
{
wr
:
:
ImageKey
mImageKey
=
kNoKey
;
nsSize
mSize
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
mFallback
;
RefPtr
<
layers
:
:
RenderRootStateManager
>
mManager
;
OldSnapshotData
(
)
=
default
;
explicit
OldSnapshotData
(
nsIFrame
*
aFrame
)
:
mSize
(
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
.
Size
(
)
)
{
if
(
!
StaticPrefs
:
:
dom_viewTransitions_wr_old_capture
(
)
)
{
mFallback
=
CaptureFallbackSnapshot
(
aFrame
)
;
}
}
void
EnsureKey
(
layers
:
:
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
{
if
(
mImageKey
!
=
kNoKey
)
{
MOZ_ASSERT
(
mManager
=
=
aManager
"
Stale
manager
?
"
)
;
return
;
}
if
(
StaticPrefs
:
:
dom_viewTransitions_wr_old_capture
(
)
)
{
mManager
=
aManager
;
mImageKey
=
aManager
-
>
WrBridge
(
)
-
>
GetNextImageKey
(
)
;
aResources
.
AddSnapshotImage
(
wr
:
:
SnapshotImageKey
{
mImageKey
}
)
;
return
;
}
if
(
NS_WARN_IF
(
!
mFallback
)
)
{
return
;
}
gfx
:
:
DataSourceSurface
:
:
ScopedMap
map
(
mFallback
gfx
:
:
DataSourceSurface
:
:
READ
)
;
if
(
NS_WARN_IF
(
!
map
.
IsMapped
(
)
)
)
{
return
;
}
mManager
=
aManager
;
mImageKey
=
aManager
-
>
WrBridge
(
)
-
>
GetNextImageKey
(
)
;
auto
size
=
mFallback
-
>
GetSize
(
)
;
auto
format
=
mFallback
-
>
GetFormat
(
)
;
wr
:
:
ImageDescriptor
desc
(
size
format
)
;
Range
<
uint8_t
>
bytes
(
map
.
GetData
(
)
map
.
GetStride
(
)
*
size
.
height
)
;
Unused
<
<
NS_WARN_IF
(
!
aResources
.
AddImage
(
mImageKey
desc
bytes
)
)
;
}
~
OldSnapshotData
(
)
{
if
(
mManager
)
{
mManager
-
>
AddImageKeyForDiscard
(
mImageKey
)
;
}
}
}
;
struct
CapturedElementOldState
{
OldSnapshotData
mSnapshot
;
bool
mTriedImage
=
false
;
nsSize
mSize
;
CSSToCSSMatrix4x4Flagged
mTransform
;
StyleWritingModeProperty
mWritingMode
=
StyleWritingModeProperty
:
:
HorizontalTb
;
StyleDirection
mDirection
=
StyleDirection
:
:
Ltr
;
StyleTextOrientation
mTextOrientation
=
StyleTextOrientation
:
:
Mixed
;
StyleBlend
mMixBlendMode
=
StyleBlend
:
:
Normal
;
StyleOwnedSlice
<
StyleFilter
>
mBackdropFilters
;
StyleColorScheme
mColorScheme
;
CapturedElementOldState
(
nsIFrame
*
aFrame
const
nsSize
&
aSnapshotContainingBlockSize
)
:
mSnapshot
(
aFrame
)
mTriedImage
(
true
)
mSize
(
aFrame
-
>
Style
(
)
-
>
IsRootElementStyle
(
)
?
aSnapshotContainingBlockSize
:
aFrame
-
>
GetRect
(
)
.
Size
(
)
)
mTransform
(
EffectiveTransform
(
aFrame
)
)
mWritingMode
(
aFrame
-
>
StyleVisibility
(
)
-
>
mWritingMode
)
mDirection
(
aFrame
-
>
StyleVisibility
(
)
-
>
mDirection
)
mTextOrientation
(
aFrame
-
>
StyleVisibility
(
)
-
>
mTextOrientation
)
mMixBlendMode
(
aFrame
-
>
StyleEffects
(
)
-
>
mMixBlendMode
)
mBackdropFilters
(
aFrame
-
>
StyleEffects
(
)
-
>
mBackdropFilters
)
mColorScheme
(
aFrame
-
>
StyleUI
(
)
-
>
mColorScheme
)
{
}
CapturedElementOldState
(
)
=
default
;
}
;
struct
ViewTransition
:
:
CapturedElement
{
CapturedElementOldState
mOldState
;
RefPtr
<
Element
>
mNewElement
;
wr
:
:
SnapshotImageKey
mNewSnapshotKey
{
kNoKey
}
;
nsSize
mNewSnapshotSize
;
CapturedElement
(
)
=
default
;
CapturedElement
(
nsIFrame
*
aFrame
const
nsSize
&
aSnapshotContainingBlockSize
)
:
mOldState
(
aFrame
aSnapshotContainingBlockSize
)
{
}
nsTArray
<
Keyframe
>
mGroupKeyframes
;
RefPtr
<
StyleLockedDeclarationBlock
>
mGroupRule
;
RefPtr
<
StyleLockedDeclarationBlock
>
mImagePairRule
;
RefPtr
<
StyleLockedDeclarationBlock
>
mOldRule
;
RefPtr
<
StyleLockedDeclarationBlock
>
mNewRule
;
~
CapturedElement
(
)
{
if
(
wr
:
:
AsImageKey
(
mNewSnapshotKey
)
!
=
kNoKey
)
{
MOZ_ASSERT
(
mOldState
.
mSnapshot
.
mManager
)
;
mOldState
.
mSnapshot
.
mManager
-
>
AddSnapshotImageKeyForDiscard
(
mNewSnapshotKey
)
;
}
}
}
;
static
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCb
const
ViewTransition
:
:
CapturedElement
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCb
aField
.
mNewElement
aName
aFlags
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ViewTransition
mDocument
mUpdateCallback
mUpdateCallbackDonePromise
mReadyPromise
mFinishedPromise
mNamedElements
mViewTransitionRoot
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ViewTransition
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ViewTransition
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ViewTransition
)
ViewTransition
:
:
ViewTransition
(
Document
&
aDoc
ViewTransitionUpdateCallback
*
aCb
)
:
mDocument
(
&
aDoc
)
mUpdateCallback
(
aCb
)
{
}
ViewTransition
:
:
~
ViewTransition
(
)
{
ClearTimeoutTimer
(
)
;
}
Maybe
<
nsSize
>
ViewTransition
:
:
GetOldSize
(
nsAtom
*
aName
)
const
{
auto
*
el
=
mNamedElements
.
Get
(
aName
)
;
if
(
NS_WARN_IF
(
!
el
)
)
{
return
{
}
;
}
return
Some
(
el
-
>
mOldState
.
mSnapshot
.
mSize
)
;
}
Maybe
<
nsSize
>
ViewTransition
:
:
GetNewSize
(
nsAtom
*
aName
)
const
{
auto
*
el
=
mNamedElements
.
Get
(
aName
)
;
if
(
NS_WARN_IF
(
!
el
)
)
{
return
{
}
;
}
return
Some
(
el
-
>
mNewSnapshotSize
)
;
}
const
wr
:
:
ImageKey
*
ViewTransition
:
:
GetOldImageKey
(
nsAtom
*
aName
layers
:
:
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
const
{
auto
*
el
=
mNamedElements
.
Get
(
aName
)
;
if
(
NS_WARN_IF
(
!
el
)
)
{
return
nullptr
;
}
el
-
>
mOldState
.
mSnapshot
.
EnsureKey
(
aManager
aResources
)
;
return
&
el
-
>
mOldState
.
mSnapshot
.
mImageKey
;
}
const
wr
:
:
ImageKey
*
ViewTransition
:
:
GetNewImageKey
(
nsAtom
*
aName
)
const
{
auto
*
el
=
mNamedElements
.
Get
(
aName
)
;
if
(
NS_WARN_IF
(
!
el
)
)
{
return
nullptr
;
}
return
&
el
-
>
mNewSnapshotKey
.
_0
;
}
const
wr
:
:
ImageKey
*
ViewTransition
:
:
GetImageKeyForCapturedFrame
(
nsIFrame
*
aFrame
layers
:
:
RenderRootStateManager
*
aManager
wr
:
:
IpcResourceUpdateQueue
&
aResources
)
const
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_CAPTURED_IN_VIEW_TRANSITION
)
)
;
if
(
!
StaticPrefs
:
:
dom_viewTransitions_live_capture
(
)
)
{
return
nullptr
;
}
nsAtom
*
name
=
aFrame
-
>
StyleUIReset
(
)
-
>
mViewTransitionName
.
_0
.
AsAtom
(
)
;
if
(
NS_WARN_IF
(
name
-
>
IsEmpty
(
)
)
)
{
return
nullptr
;
}
const
bool
isOld
=
mPhase
<
Phase
:
:
Animating
;
VT_LOG
(
"
ViewTransition
:
:
GetImageKeyForCapturedFrame
(
%
s
old
=
%
d
)
\
n
"
nsAtomCString
(
name
)
.
get
(
)
isOld
)
;
if
(
isOld
)
{
const
auto
*
key
=
GetOldImageKey
(
name
aManager
aResources
)
;
VT_LOG
(
"
>
old
image
is
%
s
"
key
?
ToString
(
*
key
)
.
c_str
(
)
:
"
null
"
)
;
return
key
;
}
auto
*
el
=
mNamedElements
.
Get
(
name
)
;
if
(
NS_WARN_IF
(
!
el
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
el
-
>
mNewElement
!
=
aFrame
-
>
GetContent
(
)
)
)
{
return
nullptr
;
}
if
(
wr
:
:
AsImageKey
(
el
-
>
mNewSnapshotKey
)
=
=
kNoKey
)
{
MOZ_ASSERT
(
!
el
-
>
mOldState
.
mSnapshot
.
mManager
|
|
el
-
>
mOldState
.
mSnapshot
.
mManager
=
=
aManager
"
Stale
manager
?
"
)
;
el
-
>
mNewSnapshotKey
=
{
aManager
-
>
WrBridge
(
)
-
>
GetNextImageKey
(
)
}
;
el
-
>
mOldState
.
mSnapshot
.
mManager
=
aManager
;
aResources
.
AddSnapshotImage
(
el
-
>
mNewSnapshotKey
)
;
}
VT_LOG
(
"
>
new
image
is
%
s
"
ToString
(
el
-
>
mNewSnapshotKey
.
_0
)
.
c_str
(
)
)
;
return
&
el
-
>
mNewSnapshotKey
.
_0
;
}
nsIGlobalObject
*
ViewTransition
:
:
GetParentObject
(
)
const
{
return
mDocument
?
mDocument
-
>
GetParentObject
(
)
:
nullptr
;
}
Promise
*
ViewTransition
:
:
GetUpdateCallbackDone
(
ErrorResult
&
aRv
)
{
if
(
!
mUpdateCallbackDonePromise
)
{
mUpdateCallbackDonePromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mUpdateCallbackDonePromise
;
}
Promise
*
ViewTransition
:
:
GetReady
(
ErrorResult
&
aRv
)
{
if
(
!
mReadyPromise
)
{
mReadyPromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mReadyPromise
;
}
Promise
*
ViewTransition
:
:
GetFinished
(
ErrorResult
&
aRv
)
{
if
(
!
mFinishedPromise
)
{
mFinishedPromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mFinishedPromise
;
}
void
ViewTransition
:
:
MaybeScheduleUpdateCallback
(
)
{
if
(
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
RefPtr
doc
=
mDocument
;
doc
-
>
ScheduleViewTransitionUpdateCallback
(
this
)
;
doc
-
>
FlushViewTransitionUpdateCallbackQueue
(
)
;
}
void
ViewTransition
:
:
CallUpdateCallback
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mPhase
=
=
Phase
:
:
Done
|
|
UnderlyingValue
(
mPhase
)
<
UnderlyingValue
(
Phase
:
:
UpdateCallbackCalled
)
)
;
if
(
mPhase
!
=
Phase
:
:
Done
)
{
mPhase
=
Phase
:
:
UpdateCallbackCalled
;
}
RefPtr
<
Promise
>
callbackPromise
;
if
(
!
mUpdateCallback
)
{
callbackPromise
=
Promise
:
:
CreateResolvedWithUndefined
(
GetParentObject
(
)
aRv
)
;
}
else
{
callbackPromise
=
MOZ_KnownLive
(
mUpdateCallback
)
-
>
Call
(
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
callbackPromise
)
;
callbackPromise
-
>
AddCallbacksWithCycleCollectedArgs
(
[
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
ErrorResult
&
aRv
ViewTransition
*
aVt
)
{
aVt
-
>
ClearTimeoutTimer
(
)
;
if
(
Promise
*
ucd
=
aVt
-
>
GetUpdateCallbackDone
(
aRv
)
)
{
ucd
-
>
MaybeResolveWithUndefined
(
)
;
}
aVt
-
>
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
aVt
-
>
mPhase
=
=
Phase
:
:
Done
)
{
if
(
Promise
*
finished
=
aVt
-
>
GetFinished
(
aRv
)
)
{
finished
-
>
MaybeResolveWithUndefined
(
)
;
}
}
aVt
-
>
Activate
(
)
;
}
[
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
ViewTransition
*
aVt
)
{
aVt
-
>
ClearTimeoutTimer
(
)
;
if
(
Promise
*
ucd
=
aVt
-
>
GetUpdateCallbackDone
(
aRv
)
)
{
ucd
-
>
MaybeReject
(
aReason
)
;
}
if
(
aVt
-
>
mPhase
=
=
Phase
:
:
Done
)
{
if
(
Promise
*
finished
=
aVt
-
>
GetFinished
(
aRv
)
)
{
finished
-
>
MaybeReject
(
aReason
)
;
}
return
;
}
if
(
Promise
*
ready
=
aVt
-
>
GetReady
(
aRv
)
)
{
MOZ_ALWAYS_TRUE
(
ready
-
>
SetAnyPromiseIsHandled
(
)
)
;
}
aVt
-
>
SkipTransition
(
SkipTransitionReason
:
:
UpdateCallbackRejected
aReason
)
;
}
RefPtr
(
this
)
)
;
MOZ_ASSERT
(
!
mTimeoutTimer
)
;
ClearTimeoutTimer
(
)
;
mTimeoutTimer
=
NS_NewTimer
(
)
;
mTimeoutTimer
-
>
InitWithNamedFuncCallback
(
TimeoutCallback
this
StaticPrefs
:
:
dom_viewTransitions_timeout_ms
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
ViewTransition
:
:
TimeoutCallback
"
)
;
}
void
ViewTransition
:
:
ClearTimeoutTimer
(
)
{
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
mTimeoutTimer
=
nullptr
;
}
}
void
ViewTransition
:
:
TimeoutCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
vt
=
static_cast
<
ViewTransition
*
>
(
aClosure
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aTimer
=
=
vt
-
>
mTimeoutTimer
)
;
vt
-
>
Timeout
(
)
;
}
void
ViewTransition
:
:
Timeout
(
)
{
ClearTimeoutTimer
(
)
;
if
(
mPhase
!
=
Phase
:
:
Done
&
&
mDocument
)
{
SkipTransition
(
SkipTransitionReason
:
:
Timeout
)
;
}
}
static
already_AddRefed
<
Element
>
MakePseudo
(
Document
&
aDoc
PseudoStyleType
aType
nsAtom
*
aName
)
{
RefPtr
<
Element
>
el
=
aDoc
.
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
if
(
!
aName
)
{
MOZ_ASSERT
(
aType
=
=
PseudoStyleType
:
:
viewTransition
)
;
el
-
>
SetIsNativeAnonymousRoot
(
)
;
}
el
-
>
SetPseudoElementType
(
aType
)
;
if
(
aName
)
{
el
-
>
SetAttr
(
nsGkAtoms
:
:
name
nsDependentAtomString
(
aName
)
IgnoreErrors
(
)
)
;
}
el
-
>
SetAttr
(
nsGkAtoms
:
:
type
nsDependentAtomString
(
nsCSSPseudoElements
:
:
GetPseudoAtom
(
aType
)
)
IgnoreErrors
(
)
)
;
return
el
.
forget
(
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
aDoc
nsCSSPropertyID
aProp
const
nsACString
&
aValue
)
{
return
Servo_DeclarationBlock_SetPropertyById
(
aDecls
aProp
&
aValue
false
aDoc
-
>
DefaultStyleAttrURLData
(
)
StyleParsingMode
:
:
DEFAULT
eCompatibility_FullStandards
aDoc
-
>
CSSLoader
(
)
StyleCssRuleType
:
:
Style
{
}
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
nsCSSPropertyID
aProp
float
aLength
nsCSSUnit
aUnit
)
{
return
Servo_DeclarationBlock_SetLengthValue
(
aDecls
aProp
aLength
aUnit
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
nsCSSPropertyID
aProp
const
CSSToCSSMatrix4x4Flagged
&
aM
)
{
MOZ_ASSERT
(
aProp
=
=
eCSSProperty_transform
)
;
AutoTArray
<
StyleTransformOperation
1
>
ops
;
ops
.
AppendElement
(
StyleTransformOperation
:
:
Matrix3D
(
StyleGenericMatrix3D
<
StyleNumber
>
{
aM
.
_11
aM
.
_12
aM
.
_13
aM
.
_14
aM
.
_21
aM
.
_22
aM
.
_23
aM
.
_24
aM
.
_31
aM
.
_32
aM
.
_33
aM
.
_34
aM
.
_41
aM
.
_42
aM
.
_43
aM
.
_44
}
)
)
;
return
Servo_DeclarationBlock_SetTransform
(
aDecls
aProp
&
ops
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
aDoc
nsCSSPropertyID
aProp
const
StyleWritingModeProperty
aWM
)
{
return
Servo_DeclarationBlock_SetKeywordValue
(
aDecls
aProp
(
int32_t
)
aWM
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
aDoc
nsCSSPropertyID
aProp
const
StyleDirection
aDirection
)
{
return
Servo_DeclarationBlock_SetKeywordValue
(
aDecls
aProp
(
int32_t
)
aDirection
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
aDoc
nsCSSPropertyID
aProp
const
StyleTextOrientation
aTextOrientation
)
{
return
Servo_DeclarationBlock_SetKeywordValue
(
aDecls
aProp
(
int32_t
)
aTextOrientation
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
aDoc
nsCSSPropertyID
aProp
const
StyleBlend
aBlend
)
{
return
Servo_DeclarationBlock_SetKeywordValue
(
aDecls
aProp
(
int32_t
)
aBlend
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
nsCSSPropertyID
aProp
const
StyleOwnedSlice
<
mozilla
:
:
StyleFilter
>
&
aBackdropFilters
)
{
return
Servo_DeclarationBlock_SetBackdropFilter
(
aDecls
aProp
&
aBackdropFilters
)
;
}
static
bool
SetProp
(
StyleLockedDeclarationBlock
*
aDecls
Document
*
nsCSSPropertyID
aProp
const
StyleColorScheme
&
aColorScheme
)
{
return
Servo_DeclarationBlock_SetColorScheme
(
aDecls
aProp
&
aColorScheme
)
;
}
static
StyleLockedDeclarationBlock
*
EnsureRule
(
RefPtr
<
StyleLockedDeclarationBlock
>
&
aRule
)
{
if
(
!
aRule
)
{
aRule
=
Servo_DeclarationBlock_CreateEmpty
(
)
.
Consume
(
)
;
}
return
aRule
.
get
(
)
;
}
static
nsTArray
<
Keyframe
>
BuildGroupKeyframes
(
Document
*
aDoc
const
CSSToCSSMatrix4x4Flagged
&
aTransform
const
nsSize
&
aSize
)
{
nsTArray
<
Keyframe
>
result
;
auto
&
firstKeyframe
=
*
result
.
AppendElement
(
)
;
firstKeyframe
.
mOffset
=
Some
(
0
.
0
)
;
PropertyValuePair
transform
{
AnimatedPropertyID
(
eCSSProperty_transform
)
Servo_DeclarationBlock_CreateEmpty
(
)
.
Consume
(
)
}
;
SetProp
(
transform
.
mServoDeclarationBlock
aDoc
eCSSProperty_transform
aTransform
)
;
PropertyValuePair
width
{
AnimatedPropertyID
(
eCSSProperty_width
)
Servo_DeclarationBlock_CreateEmpty
(
)
.
Consume
(
)
}
;
CSSSize
cssSize
=
CSSSize
:
:
FromAppUnits
(
aSize
)
;
SetProp
(
width
.
mServoDeclarationBlock
aDoc
eCSSProperty_width
cssSize
.
width
eCSSUnit_Pixel
)
;
PropertyValuePair
height
{
AnimatedPropertyID
(
eCSSProperty_height
)
Servo_DeclarationBlock_CreateEmpty
(
)
.
Consume
(
)
}
;
SetProp
(
height
.
mServoDeclarationBlock
aDoc
eCSSProperty_height
cssSize
.
height
eCSSUnit_Pixel
)
;
firstKeyframe
.
mPropertyValues
.
AppendElement
(
std
:
:
move
(
transform
)
)
;
firstKeyframe
.
mPropertyValues
.
AppendElement
(
std
:
:
move
(
width
)
)
;
firstKeyframe
.
mPropertyValues
.
AppendElement
(
std
:
:
move
(
height
)
)
;
auto
&
lastKeyframe
=
*
result
.
AppendElement
(
)
;
lastKeyframe
.
mOffset
=
Some
(
1
.
0
)
;
lastKeyframe
.
mPropertyValues
.
AppendElement
(
PropertyValuePair
{
AnimatedPropertyID
(
eCSSProperty_transform
)
}
)
;
lastKeyframe
.
mPropertyValues
.
AppendElement
(
PropertyValuePair
{
AnimatedPropertyID
(
eCSSProperty_width
)
}
)
;
lastKeyframe
.
mPropertyValues
.
AppendElement
(
PropertyValuePair
{
AnimatedPropertyID
(
eCSSProperty_height
)
}
)
;
return
result
;
}
bool
ViewTransition
:
:
GetGroupKeyframes
(
nsAtom
*
aAnimationName
nsTArray
<
Keyframe
>
&
aResult
)
const
{
MOZ_ASSERT
(
StringBeginsWith
(
nsDependentAtomString
(
aAnimationName
)
kGroupAnimPrefix
)
)
;
RefPtr
<
nsAtom
>
transitionName
=
NS_Atomize
(
Substring
(
nsDependentAtomString
(
aAnimationName
)
kGroupAnimPrefix
.
Length
(
)
)
)
;
auto
*
el
=
mNamedElements
.
Get
(
transitionName
)
;
if
(
NS_WARN_IF
(
!
el
)
|
|
NS_WARN_IF
(
el
-
>
mGroupKeyframes
.
IsEmpty
(
)
)
)
{
return
false
;
}
aResult
=
el
-
>
mGroupKeyframes
.
Clone
(
)
;
return
true
;
}
void
ViewTransition
:
:
SetupTransitionPseudoElements
(
)
{
MOZ_ASSERT
(
!
mViewTransitionRoot
)
;
nsAutoScriptBlocker
scriptBlocker
;
RefPtr
docElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
!
docElement
)
{
return
;
}
mViewTransitionRoot
=
MakePseudo
(
*
mDocument
PseudoStyleType
:
:
viewTransition
nullptr
)
;
#
ifdef
DEBUG
mViewTransitionRoot
-
>
SetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
reinterpret_cast
<
void
*
>
(
true
)
)
;
#
endif
MOZ_ASSERT
(
mNames
.
Length
(
)
=
=
mNamedElements
.
Count
(
)
)
;
for
(
nsAtom
*
transitionName
:
mNames
)
{
constexpr
bool
kNotify
=
false
;
CapturedElement
&
capturedElement
=
*
mNamedElements
.
Get
(
transitionName
)
;
RefPtr
<
Element
>
group
=
MakePseudo
(
*
mDocument
PseudoStyleType
:
:
viewTransitionGroup
transitionName
)
;
mViewTransitionRoot
-
>
AppendChildTo
(
group
kNotify
IgnoreErrors
(
)
)
;
RefPtr
<
Element
>
imagePair
=
MakePseudo
(
*
mDocument
PseudoStyleType
:
:
viewTransitionImagePair
transitionName
)
;
group
-
>
AppendChildTo
(
imagePair
kNotify
IgnoreErrors
(
)
)
;
if
(
capturedElement
.
mOldState
.
mTriedImage
)
{
RefPtr
<
Element
>
old
=
MakePseudo
(
*
mDocument
PseudoStyleType
:
:
viewTransitionOld
transitionName
)
;
imagePair
-
>
AppendChildTo
(
old
kNotify
IgnoreErrors
(
)
)
;
}
else
{
MOZ_ASSERT
(
capturedElement
.
mNewElement
)
;
auto
*
rule
=
EnsureRule
(
capturedElement
.
mNewRule
)
;
SetProp
(
rule
mDocument
eCSSProperty_animation_name
"
-
ua
-
view
-
transition
-
fade
-
in
"
_ns
)
;
}
if
(
capturedElement
.
mNewElement
)
{
RefPtr
<
Element
>
new_
=
MakePseudo
(
*
mDocument
PseudoStyleType
:
:
viewTransitionNew
transitionName
)
;
imagePair
-
>
AppendChildTo
(
new_
kNotify
IgnoreErrors
(
)
)
;
}
else
{
MOZ_ASSERT
(
capturedElement
.
mOldState
.
mTriedImage
)
;
SetProp
(
EnsureRule
(
capturedElement
.
mOldRule
)
mDocument
eCSSProperty_animation_name
"
-
ua
-
view
-
transition
-
fade
-
out
"
_ns
)
;
auto
*
rule
=
EnsureRule
(
capturedElement
.
mGroupRule
)
;
auto
oldRect
=
CSSPixel
:
:
FromAppUnits
(
capturedElement
.
mOldState
.
mSize
)
;
SetProp
(
rule
mDocument
eCSSProperty_width
oldRect
.
width
eCSSUnit_Pixel
)
;
SetProp
(
rule
mDocument
eCSSProperty_height
oldRect
.
height
eCSSUnit_Pixel
)
;
SetProp
(
rule
mDocument
eCSSProperty_transform
capturedElement
.
mOldState
.
mTransform
)
;
SetProp
(
rule
mDocument
eCSSProperty_writing_mode
capturedElement
.
mOldState
.
mWritingMode
)
;
SetProp
(
rule
mDocument
eCSSProperty_direction
capturedElement
.
mOldState
.
mDirection
)
;
SetProp
(
rule
mDocument
eCSSProperty_text_orientation
capturedElement
.
mOldState
.
mTextOrientation
)
;
SetProp
(
rule
mDocument
eCSSProperty_mix_blend_mode
capturedElement
.
mOldState
.
mMixBlendMode
)
;
SetProp
(
rule
mDocument
eCSSProperty_backdrop_filter
capturedElement
.
mOldState
.
mBackdropFilters
)
;
SetProp
(
rule
mDocument
eCSSProperty_color_scheme
capturedElement
.
mOldState
.
mColorScheme
)
;
}
if
(
capturedElement
.
mOldState
.
mTriedImage
&
&
capturedElement
.
mNewElement
)
{
NS_ConvertUTF16toUTF8
dynamicAnimationName
(
kGroupAnimPrefix
+
nsDependentAtomString
(
transitionName
)
)
;
capturedElement
.
mGroupKeyframes
=
BuildGroupKeyframes
(
mDocument
capturedElement
.
mOldState
.
mTransform
capturedElement
.
mOldState
.
mSize
)
;
SetProp
(
EnsureRule
(
capturedElement
.
mGroupRule
)
mDocument
eCSSProperty_animation_name
dynamicAnimationName
)
;
SetProp
(
EnsureRule
(
capturedElement
.
mImagePairRule
)
mDocument
eCSSProperty_isolation
"
isolate
"
_ns
)
;
SetProp
(
EnsureRule
(
capturedElement
.
mOldRule
)
mDocument
eCSSProperty_animation_name
"
-
ua
-
view
-
transition
-
fade
-
out
-
ua
-
mix
-
blend
-
mode
-
plus
-
lighter
"
_ns
)
;
SetProp
(
EnsureRule
(
capturedElement
.
mNewRule
)
mDocument
eCSSProperty_animation_name
"
-
ua
-
view
-
transition
-
fade
-
in
-
ua
-
mix
-
blend
-
mode
-
plus
-
lighter
"
_ns
)
;
}
}
BindContext
context
(
*
docElement
BindContext
:
:
ForNativeAnonymous
)
;
if
(
NS_FAILED
(
mViewTransitionRoot
-
>
BindToTree
(
context
*
docElement
)
)
)
{
mViewTransitionRoot
-
>
UnbindFromTree
(
)
;
mViewTransitionRoot
=
nullptr
;
return
;
}
if
(
mDocument
-
>
DevToolsAnonymousAndShadowEventsEnabled
(
)
)
{
mViewTransitionRoot
-
>
QueueDevtoolsAnonymousEvent
(
false
)
;
}
if
(
PresShell
*
ps
=
mDocument
-
>
GetPresShell
(
)
)
{
ps
-
>
ContentAppended
(
mViewTransitionRoot
)
;
}
}
bool
ViewTransition
:
:
UpdatePseudoElementStyles
(
bool
aNeedsInvalidation
)
{
for
(
auto
&
entry
:
mNamedElements
)
{
nsAtom
*
transitionName
=
entry
.
GetKey
(
)
;
CapturedElement
&
capturedElement
=
*
entry
.
GetData
(
)
;
if
(
!
capturedElement
.
mNewElement
)
{
continue
;
}
nsIFrame
*
frame
=
capturedElement
.
mNewElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
frame
-
>
IsHiddenByContentVisibilityOnAnyAncestor
(
)
|
|
frame
-
>
GetPrevContinuation
(
)
|
|
frame
-
>
GetNextContinuation
(
)
)
{
return
false
;
}
auto
*
rule
=
EnsureRule
(
capturedElement
.
mGroupRule
)
;
auto
newRect
=
frame
-
>
Style
(
)
-
>
IsRootElementStyle
(
)
?
SnapshotContainingBlockRect
(
)
:
frame
-
>
GetRect
(
)
;
auto
size
=
CSSPixel
:
:
FromAppUnits
(
newRect
)
;
bool
groupStyleChanged
=
int
(
SetProp
(
rule
mDocument
eCSSProperty_width
size
.
width
eCSSUnit_Pixel
)
)
|
SetProp
(
rule
mDocument
eCSSProperty_height
size
.
height
eCSSUnit_Pixel
)
|
SetProp
(
rule
mDocument
eCSSProperty_transform
EffectiveTransform
(
frame
)
)
|
SetProp
(
rule
mDocument
eCSSProperty_writing_mode
frame
-
>
StyleVisibility
(
)
-
>
mWritingMode
)
|
SetProp
(
rule
mDocument
eCSSProperty_direction
frame
-
>
StyleVisibility
(
)
-
>
mDirection
)
|
SetProp
(
rule
mDocument
eCSSProperty_text_orientation
frame
-
>
StyleVisibility
(
)
-
>
mTextOrientation
)
|
SetProp
(
rule
mDocument
eCSSProperty_mix_blend_mode
frame
-
>
StyleEffects
(
)
-
>
mMixBlendMode
)
|
SetProp
(
rule
mDocument
eCSSProperty_backdrop_filter
frame
-
>
StyleEffects
(
)
-
>
mBackdropFilters
)
|
SetProp
(
rule
mDocument
eCSSProperty_color_scheme
frame
-
>
StyleUI
(
)
-
>
mColorScheme
)
;
if
(
groupStyleChanged
&
&
aNeedsInvalidation
)
{
auto
*
pseudo
=
FindPseudo
(
PseudoStyleRequest
(
PseudoStyleType
:
:
viewTransitionGroup
transitionName
)
)
;
MOZ_ASSERT
(
pseudo
)
;
nsLayoutUtils
:
:
PostRestyleEvent
(
pseudo
RestyleHint
:
:
RECASCADE_SELF
nsChangeHint
(
0
)
)
;
}
auto
oldSize
=
capturedElement
.
mNewSnapshotSize
;
capturedElement
.
mNewSnapshotSize
=
frame
-
>
InkOverflowRectRelativeToSelf
(
)
.
Size
(
)
;
if
(
oldSize
!
=
capturedElement
.
mNewSnapshotSize
&
&
aNeedsInvalidation
)
{
frame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
frame
IntrinsicDirty
:
:
FrameAndAncestors
NS_FRAME_IS_DIRTY
)
;
}
}
return
true
;
}
void
ViewTransition
:
:
Activate
(
)
{
if
(
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
mDocument
-
>
SetRenderingSuppressedForViewTransitions
(
false
)
;
if
(
mInitialSnapshotContainingBlockSize
!
=
SnapshotContainingBlockRect
(
)
.
Size
(
)
)
{
return
SkipTransition
(
SkipTransitionReason
:
:
Resize
)
;
}
if
(
auto
skipReason
=
CaptureNewState
(
)
)
{
ClearNamedElements
(
)
;
return
SkipTransition
(
*
skipReason
)
;
}
SetupTransitionPseudoElements
(
)
;
if
(
!
UpdatePseudoElementStyles
(
false
)
)
{
return
SkipTransition
(
SkipTransitionReason
:
:
PseudoUpdateFailure
)
;
}
mPhase
=
Phase
:
:
Animating
;
if
(
Promise
*
ready
=
GetReady
(
IgnoreErrors
(
)
)
)
{
ready
-
>
MaybeResolveWithUndefined
(
)
;
}
MOZ_ASSERT
(
mDocument
)
;
mDocument
-
>
EnsureViewTransitionOperationsHappen
(
)
;
}
void
ViewTransition
:
:
PerformPendingOperations
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
;
RefPtr
doc
=
mDocument
;
doc
-
>
FlushViewTransitionUpdateCallbackQueue
(
)
;
switch
(
mPhase
)
{
case
Phase
:
:
PendingCapture
:
return
Setup
(
)
;
case
Phase
:
:
Animating
:
return
HandleFrame
(
)
;
default
:
break
;
}
}
nsRect
ViewTransition
:
:
SnapshotContainingBlockRect
(
nsPresContext
*
aPc
)
{
return
aPc
?
aPc
-
>
GetVisibleArea
(
)
:
nsRect
(
)
;
}
nsRect
ViewTransition
:
:
SnapshotContainingBlockRect
(
)
const
{
nsPresContext
*
pc
=
mDocument
-
>
GetPresContext
(
)
;
return
SnapshotContainingBlockRect
(
pc
)
;
}
Element
*
ViewTransition
:
:
FindPseudo
(
const
PseudoStyleRequest
&
aRequest
)
const
{
Element
*
root
=
GetRoot
(
)
;
if
(
!
root
)
{
return
nullptr
;
}
if
(
aRequest
.
mType
=
=
PseudoStyleType
:
:
viewTransition
)
{
return
root
;
}
Element
*
group
=
root
-
>
GetFirstElementChild
(
)
;
for
(
;
group
;
group
=
group
-
>
GetNextElementSibling
(
)
)
{
MOZ_ASSERT
(
group
-
>
HasName
(
)
"
The
generated
:
:
view
-
transition
-
group
(
)
should
have
a
name
"
)
;
nsAtom
*
name
=
group
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
;
if
(
name
=
=
aRequest
.
mIdentifier
)
{
break
;
}
}
if
(
!
group
)
{
return
nullptr
;
}
if
(
aRequest
.
mType
=
=
PseudoStyleType
:
:
viewTransitionGroup
)
{
return
group
;
}
Element
*
imagePair
=
group
-
>
GetFirstElementChild
(
)
;
MOZ_ASSERT
(
imagePair
"
:
:
view
-
transition
-
image
-
pair
(
)
should
exist
always
"
)
;
if
(
aRequest
.
mType
=
=
PseudoStyleType
:
:
viewTransitionImagePair
)
{
return
imagePair
;
}
Element
*
child
=
imagePair
-
>
GetFirstElementChild
(
)
;
if
(
!
child
)
{
return
nullptr
;
}
const
PseudoStyleType
type
=
child
-
>
GetPseudoElementType
(
)
;
if
(
type
=
=
aRequest
.
mType
)
{
return
child
;
}
if
(
aRequest
.
mType
=
=
PseudoStyleType
:
:
viewTransitionOld
)
{
return
nullptr
;
}
child
=
child
-
>
GetNextElementSibling
(
)
;
MOZ_ASSERT
(
aRequest
.
mType
=
=
PseudoStyleType
:
:
viewTransitionNew
)
;
MOZ_ASSERT
(
!
child
|
|
!
child
-
>
GetNextElementSibling
(
)
"
No
more
psuedo
elements
in
this
subtree
"
)
;
return
child
;
}
const
StyleLockedDeclarationBlock
*
ViewTransition
:
:
GetDynamicRuleFor
(
const
Element
&
aElement
)
const
{
if
(
!
aElement
.
HasName
(
)
)
{
return
nullptr
;
}
nsAtom
*
name
=
aElement
.
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
;
auto
*
capture
=
mNamedElements
.
Get
(
name
)
;
if
(
!
capture
)
{
return
nullptr
;
}
switch
(
aElement
.
GetPseudoElementType
(
)
)
{
case
PseudoStyleType
:
:
viewTransitionNew
:
return
capture
-
>
mNewRule
.
get
(
)
;
case
PseudoStyleType
:
:
viewTransitionOld
:
return
capture
-
>
mOldRule
.
get
(
)
;
case
PseudoStyleType
:
:
viewTransitionImagePair
:
return
capture
-
>
mImagePairRule
.
get
(
)
;
case
PseudoStyleType
:
:
viewTransitionGroup
:
return
capture
-
>
mGroupRule
.
get
(
)
;
default
:
return
nullptr
;
}
}
template
<
typename
Callback
>
static
bool
ForEachChildFrame
(
nsIFrame
*
aFrame
const
Callback
&
aCb
)
{
if
(
!
aCb
(
aFrame
)
)
{
return
false
;
}
for
(
auto
&
[
list
id
]
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
f
:
list
)
{
if
(
!
ForEachChildFrame
(
f
aCb
)
)
{
return
false
;
}
}
}
return
true
;
}
template
<
typename
Callback
>
static
void
ForEachFrame
(
Document
*
aDoc
const
Callback
&
aCb
)
{
PresShell
*
ps
=
aDoc
-
>
GetPresShell
(
)
;
if
(
!
ps
)
{
return
;
}
nsIFrame
*
root
=
ps
-
>
GetRootFrame
(
)
;
if
(
!
root
)
{
return
;
}
ForEachChildFrame
(
root
aCb
)
;
}
static
nsAtom
*
DocumentScopedTransitionNameFor
(
nsIFrame
*
aFrame
)
{
auto
*
name
=
aFrame
-
>
StyleUIReset
(
)
-
>
mViewTransitionName
.
_0
.
AsAtom
(
)
;
if
(
name
-
>
IsEmpty
(
)
)
{
return
nullptr
;
}
return
name
;
}
Maybe
<
SkipTransitionReason
>
ViewTransition
:
:
CaptureOldState
(
)
{
MOZ_ASSERT
(
mNamedElements
.
IsEmpty
(
)
)
;
nsTHashSet
<
nsAtom
*
>
usedTransitionNames
;
AutoTArray
<
std
:
:
pair
<
nsIFrame
*
nsAtom
*
>
32
>
captureElements
;
mInitialSnapshotContainingBlockSize
=
SnapshotContainingBlockRect
(
)
.
Size
(
)
;
Maybe
<
SkipTransitionReason
>
result
;
ForEachFrame
(
mDocument
[
&
]
(
nsIFrame
*
aFrame
)
{
auto
*
name
=
DocumentScopedTransitionNameFor
(
aFrame
)
;
if
(
!
name
)
{
return
true
;
}
if
(
aFrame
-
>
IsHiddenByContentVisibilityOnAnyAncestor
(
)
)
{
return
true
;
}
if
(
aFrame
-
>
GetPrevContinuation
(
)
|
|
aFrame
-
>
GetNextContinuation
(
)
)
{
return
true
;
}
if
(
!
usedTransitionNames
.
EnsureInserted
(
name
)
)
{
result
.
emplace
(
SkipTransitionReason
:
:
DuplicateTransitionNameCapturingOldState
)
;
return
false
;
}
SetCaptured
(
aFrame
true
)
;
captureElements
.
AppendElement
(
std
:
:
make_pair
(
aFrame
name
)
)
;
return
true
;
}
)
;
if
(
result
)
{
for
(
auto
&
[
f
name
]
:
captureElements
)
{
SetCaptured
(
f
false
)
;
}
return
result
;
}
for
(
auto
&
[
f
name
]
:
captureElements
)
{
MOZ_ASSERT
(
f
)
;
MOZ_ASSERT
(
f
-
>
GetContent
(
)
-
>
IsElement
(
)
)
;
auto
capture
=
MakeUnique
<
CapturedElement
>
(
f
mInitialSnapshotContainingBlockSize
)
;
mNamedElements
.
InsertOrUpdate
(
name
std
:
:
move
(
capture
)
)
;
mNames
.
AppendElement
(
name
)
;
}
if
(
StaticPrefs
:
:
dom_viewTransitions_wr_old_capture
(
)
)
{
if
(
RefPtr
<
PresShell
>
ps
=
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
mDocument
)
-
>
GetPresShell
(
)
)
{
VT_LOG
(
"
ViewTransitions
:
:
CaptureOldState
(
)
requesting
composite
"
)
;
RefPtr
<
nsViewManager
>
vm
=
ps
-
>
GetViewManager
(
)
;
ps
-
>
PaintAndRequestComposite
(
vm
-
>
GetRootView
(
)
PaintFlags
:
:
PaintCompositeOffscreen
)
;
VT_LOG
(
"
ViewTransitions
:
:
CaptureOldState
(
)
requesting
composite
end
"
)
;
}
}
for
(
auto
&
[
f
name
]
:
captureElements
)
{
SetCaptured
(
f
false
)
;
}
return
result
;
}
Maybe
<
SkipTransitionReason
>
ViewTransition
:
:
CaptureNewState
(
)
{
nsTHashSet
<
nsAtom
*
>
usedTransitionNames
;
Maybe
<
SkipTransitionReason
>
result
;
ForEachFrame
(
mDocument
[
&
]
(
nsIFrame
*
aFrame
)
{
auto
*
name
=
DocumentScopedTransitionNameFor
(
aFrame
)
;
if
(
!
name
)
{
return
true
;
}
if
(
aFrame
-
>
IsHiddenByContentVisibilityOnAnyAncestor
(
)
)
{
return
true
;
}
if
(
aFrame
-
>
GetPrevContinuation
(
)
|
|
aFrame
-
>
GetNextContinuation
(
)
)
{
return
true
;
}
if
(
!
usedTransitionNames
.
EnsureInserted
(
name
)
)
{
result
.
emplace
(
SkipTransitionReason
:
:
DuplicateTransitionNameCapturingNewState
)
;
return
false
;
}
bool
wasPresent
=
true
;
auto
&
capturedElement
=
mNamedElements
.
LookupOrInsertWith
(
name
[
&
]
{
wasPresent
=
false
;
return
MakeUnique
<
CapturedElement
>
(
)
;
}
)
;
if
(
!
wasPresent
)
{
mNames
.
AppendElement
(
name
)
;
}
capturedElement
-
>
mNewElement
=
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
capturedElement
-
>
mNewSnapshotSize
=
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
.
Size
(
)
;
SetCaptured
(
aFrame
true
)
;
return
true
;
}
)
;
return
result
;
}
void
ViewTransition
:
:
Setup
(
)
{
if
(
auto
skipReason
=
CaptureOldState
(
)
)
{
return
SkipTransition
(
*
skipReason
)
;
}
mDocument
-
>
SetRenderingSuppressedForViewTransitions
(
true
)
;
mDocument
-
>
Dispatch
(
NewRunnableMethod
(
"
ViewTransition
:
:
MaybeScheduleUpdateCallback
"
this
&
ViewTransition
:
:
MaybeScheduleUpdateCallback
)
)
;
}
void
ViewTransition
:
:
HandleFrame
(
)
{
const
bool
hasActiveAnimations
=
CheckForActiveAnimations
(
)
;
if
(
!
hasActiveAnimations
)
{
mPhase
=
Phase
:
:
Done
;
ClearActiveTransition
(
false
)
;
if
(
Promise
*
finished
=
GetFinished
(
IgnoreErrors
(
)
)
)
{
finished
-
>
MaybeResolveWithUndefined
(
)
;
}
return
;
}
if
(
SnapshotContainingBlockRect
(
)
.
Size
(
)
!
=
mInitialSnapshotContainingBlockSize
)
{
SkipTransition
(
SkipTransitionReason
:
:
Resize
)
;
return
;
}
if
(
!
UpdatePseudoElementStyles
(
true
)
)
{
return
SkipTransition
(
SkipTransitionReason
:
:
PseudoUpdateFailure
)
;
}
mDocument
-
>
EnsureViewTransitionOperationsHappen
(
)
;
}
static
bool
CheckForActiveAnimationsForEachPseudo
(
const
Element
&
aRoot
const
AnimationTimeline
&
aDocTimeline
const
AnimationEventDispatcher
&
aDispatcher
PseudoStyleRequest
&
&
aRequest
)
{
EffectSet
*
effects
=
EffectSet
:
:
Get
(
&
aRoot
aRequest
)
;
if
(
!
effects
)
{
return
false
;
}
for
(
const
auto
*
effect
:
*
effects
)
{
MOZ_ASSERT
(
effect
&
&
effect
-
>
GetAnimation
(
)
"
Only
effects
associated
with
an
animation
should
be
"
"
added
to
an
element
'
s
effect
set
"
)
;
const
Animation
*
anim
=
effect
-
>
GetAnimation
(
)
;
if
(
anim
-
>
GetTimeline
(
)
!
=
&
aDocTimeline
)
{
continue
;
}
const
auto
playState
=
anim
-
>
PlayState
(
)
;
if
(
playState
!
=
AnimationPlayState
:
:
Paused
&
&
playState
!
=
AnimationPlayState
:
:
Running
&
&
!
aDispatcher
.
HasQueuedEventsFor
(
anim
)
)
{
continue
;
}
return
true
;
}
return
false
;
}
bool
ViewTransition
:
:
CheckForActiveAnimations
(
)
const
{
MOZ_ASSERT
(
mDocument
)
;
if
(
StaticPrefs
:
:
dom_viewTransitions_remain_active
(
)
)
{
return
true
;
}
const
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
!
root
)
{
return
false
;
}
const
AnimationTimeline
*
timeline
=
mDocument
-
>
Timeline
(
)
;
if
(
!
timeline
)
{
return
false
;
}
nsPresContext
*
presContext
=
mDocument
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
false
;
}
const
AnimationEventDispatcher
*
dispatcher
=
presContext
-
>
AnimationEventDispatcher
(
)
;
MOZ_ASSERT
(
dispatcher
)
;
auto
checkForEachPseudo
=
[
&
]
(
PseudoStyleRequest
&
&
aRequest
)
{
return
CheckForActiveAnimationsForEachPseudo
(
*
root
*
timeline
*
dispatcher
std
:
:
move
(
aRequest
)
)
;
}
;
bool
hasActiveAnimations
=
checkForEachPseudo
(
PseudoStyleRequest
(
PseudoStyleType
:
:
viewTransition
)
)
;
for
(
nsAtom
*
name
:
mNamedElements
.
Keys
(
)
)
{
if
(
hasActiveAnimations
)
{
break
;
}
hasActiveAnimations
=
checkForEachPseudo
(
{
PseudoStyleType
:
:
viewTransitionGroup
name
}
)
|
|
checkForEachPseudo
(
{
PseudoStyleType
:
:
viewTransitionImagePair
name
}
)
|
|
checkForEachPseudo
(
{
PseudoStyleType
:
:
viewTransitionOld
name
}
)
|
|
checkForEachPseudo
(
{
PseudoStyleType
:
:
viewTransitionNew
name
}
)
;
}
return
hasActiveAnimations
;
}
void
ViewTransition
:
:
ClearNamedElements
(
)
{
for
(
auto
&
entry
:
mNamedElements
)
{
if
(
auto
*
element
=
entry
.
GetData
(
)
-
>
mNewElement
.
get
(
)
)
{
if
(
nsIFrame
*
f
=
element
-
>
GetPrimaryFrame
(
)
)
{
SetCaptured
(
f
false
)
;
}
}
}
mNamedElements
.
Clear
(
)
;
mNames
.
Clear
(
)
;
}
static
void
ClearViewTransitionsAnimationData
(
Element
*
aRoot
)
{
if
(
!
aRoot
)
{
return
;
}
auto
*
data
=
aRoot
-
>
GetAnimationData
(
)
;
if
(
!
data
)
{
return
;
}
data
-
>
ClearViewTransitionPseudos
(
)
;
}
void
ViewTransition
:
:
ClearActiveTransition
(
bool
aIsDocumentHidden
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
;
ClearNamedElements
(
)
;
if
(
mViewTransitionRoot
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
mDocument
-
>
DevToolsAnonymousAndShadowEventsEnabled
(
)
)
{
mViewTransitionRoot
-
>
QueueDevtoolsAnonymousEvent
(
true
)
;
}
if
(
PresShell
*
ps
=
mDocument
-
>
GetPresShell
(
)
)
{
ps
-
>
ContentWillBeRemoved
(
mViewTransitionRoot
nullptr
)
;
}
mViewTransitionRoot
-
>
UnbindFromTree
(
)
;
mViewTransitionRoot
=
nullptr
;
if
(
!
aIsDocumentHidden
)
{
ClearViewTransitionsAnimationData
(
mDocument
-
>
GetRootElement
(
)
)
;
}
}
mDocument
-
>
ClearActiveViewTransition
(
)
;
}
void
ViewTransition
:
:
SkipTransition
(
SkipTransitionReason
aReason
)
{
SkipTransition
(
aReason
JS
:
:
UndefinedHandleValue
)
;
}
void
ViewTransition
:
:
SkipTransition
(
SkipTransitionReason
aReason
JS
:
:
Handle
<
JS
:
:
Value
>
aUpdateCallbackRejectReason
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT_IF
(
aReason
!
=
SkipTransitionReason
:
:
JS
mPhase
!
=
Phase
:
:
Done
)
;
MOZ_ASSERT_IF
(
aReason
!
=
SkipTransitionReason
:
:
UpdateCallbackRejected
aUpdateCallbackRejectReason
=
=
JS
:
:
UndefinedHandleValue
)
;
if
(
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
if
(
UnderlyingValue
(
mPhase
)
<
UnderlyingValue
(
Phase
:
:
UpdateCallbackCalled
)
)
{
mDocument
-
>
ScheduleViewTransitionUpdateCallback
(
this
)
;
}
mDocument
-
>
SetRenderingSuppressedForViewTransitions
(
false
)
;
if
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
{
ClearActiveTransition
(
aReason
=
=
SkipTransitionReason
:
:
DocumentHidden
)
;
}
mPhase
=
Phase
:
:
Done
;
Promise
*
ucd
=
GetUpdateCallbackDone
(
IgnoreErrors
(
)
)
;
if
(
Promise
*
readyPromise
=
GetReady
(
IgnoreErrors
(
)
)
)
{
switch
(
aReason
)
{
case
SkipTransitionReason
:
:
JS
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
skipTransition
(
)
call
"
)
;
break
;
case
SkipTransitionReason
:
:
ClobberedActiveTransition
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
another
transition
starting
"
)
;
break
;
case
SkipTransitionReason
:
:
DocumentHidden
:
readyPromise
-
>
MaybeRejectWithInvalidStateError
(
"
Skipped
ViewTransition
due
to
document
being
hidden
"
)
;
break
;
case
SkipTransitionReason
:
:
Timeout
:
readyPromise
-
>
MaybeRejectWithTimeoutError
(
"
Skipped
ViewTransition
due
to
timeout
"
)
;
break
;
case
SkipTransitionReason
:
:
DuplicateTransitionNameCapturingOldState
:
readyPromise
-
>
MaybeRejectWithInvalidStateError
(
"
Duplicate
view
-
transition
-
name
value
while
capturing
old
state
"
)
;
break
;
case
SkipTransitionReason
:
:
DuplicateTransitionNameCapturingNewState
:
readyPromise
-
>
MaybeRejectWithInvalidStateError
(
"
Duplicate
view
-
transition
-
name
value
while
capturing
new
state
"
)
;
break
;
case
SkipTransitionReason
:
:
Resize
:
readyPromise
-
>
MaybeRejectWithInvalidStateError
(
"
Skipped
view
transition
due
to
viewport
resize
"
)
;
break
;
case
SkipTransitionReason
:
:
PseudoUpdateFailure
:
readyPromise
-
>
MaybeRejectWithInvalidStateError
(
"
Skipped
view
transition
due
to
hidden
new
element
"
)
;
break
;
case
SkipTransitionReason
:
:
UpdateCallbackRejected
:
readyPromise
-
>
MaybeReject
(
aUpdateCallbackRejectReason
)
;
if
(
ucd
)
{
MOZ_ASSERT
(
ucd
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Rejected
)
;
if
(
Promise
*
finished
=
GetFinished
(
IgnoreErrors
(
)
)
)
{
finished
-
>
MaybeReject
(
aUpdateCallbackRejectReason
)
;
}
}
break
;
}
}
if
(
ucd
&
&
ucd
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Resolved
)
{
if
(
Promise
*
finished
=
GetFinished
(
IgnoreErrors
(
)
)
)
{
finished
-
>
MaybeResolveWithUndefined
(
)
;
}
}
}
JSObject
*
ViewTransition
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ViewTransition_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
;
