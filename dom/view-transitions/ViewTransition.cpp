#
include
"
ViewTransition
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
mozilla
/
dom
/
ViewTransitionBinding
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
Units
.
h
"
static
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
const
nsRefPtrHashKey
<
nsAtom
>
&
const
char
*
aName
uint32_t
aFlags
=
0
)
{
}
namespace
mozilla
:
:
dom
{
static
CSSToCSSMatrix4x4Flagged
EffectiveTransform
(
nsIFrame
*
aFrame
)
{
CSSToCSSMatrix4x4Flagged
matrix
;
if
(
aFrame
-
>
GetSize
(
)
.
IsEmpty
(
)
|
|
aFrame
-
>
Style
(
)
-
>
IsRootElementStyle
(
)
)
{
return
matrix
;
}
CSSSize
untransformedSize
=
CSSSize
:
:
FromAppUnits
(
aFrame
-
>
GetSize
(
)
)
;
CSSRect
boundingRect
=
CSSRect
:
:
FromAppUnits
(
aFrame
-
>
GetBoundingClientRect
(
)
)
;
if
(
boundingRect
.
Size
(
)
!
=
untransformedSize
)
{
float
sx
=
boundingRect
.
width
/
untransformedSize
.
width
;
float
sy
=
boundingRect
.
height
/
untransformedSize
.
height
;
matrix
=
CSSToCSSMatrix4x4Flagged
:
:
Scaling
(
sx
sy
0
.
0f
)
;
}
if
(
boundingRect
.
TopLeft
(
)
!
=
CSSPoint
(
)
)
{
matrix
.
PostTranslate
(
boundingRect
.
x
boundingRect
.
y
0
.
0f
)
;
}
return
matrix
;
}
struct
CapturedElementOldState
{
nsSize
mSize
;
CSSToCSSMatrix4x4Flagged
mTransform
;
WritingMode
mWritingMode
;
StyleBlend
mMixBlendMode
=
StyleBlend
:
:
Normal
;
StyleOwnedSlice
<
StyleFilter
>
mBackdropFilters
;
StyleColorSchemeFlags
mColorScheme
{
0
}
;
CapturedElementOldState
(
nsIFrame
*
aFrame
const
nsSize
&
aSnapshotContainingBlockSize
)
:
mSize
(
aFrame
-
>
Style
(
)
-
>
IsRootElementStyle
(
)
?
aSnapshotContainingBlockSize
:
aFrame
-
>
GetRect
(
)
.
Size
(
)
)
mTransform
(
EffectiveTransform
(
aFrame
)
)
mWritingMode
(
aFrame
-
>
GetWritingMode
(
)
)
mMixBlendMode
(
aFrame
-
>
StyleEffects
(
)
-
>
mMixBlendMode
)
mBackdropFilters
(
aFrame
-
>
StyleEffects
(
)
-
>
mBackdropFilters
)
mColorScheme
(
aFrame
-
>
StyleUI
(
)
-
>
mColorScheme
.
bits
)
{
}
}
;
struct
ViewTransition
:
:
CapturedElement
{
CapturedElementOldState
mOldState
;
RefPtr
<
Element
>
mNewElement
;
CapturedElement
(
nsIFrame
*
aFrame
const
nsSize
&
aSnapshotContainingBlockSize
)
:
mOldState
(
aFrame
aSnapshotContainingBlockSize
)
{
}
}
;
static
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCb
const
UniquePtr
<
ViewTransition
:
:
CapturedElement
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCb
aField
-
>
mNewElement
aName
aFlags
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ViewTransition
mDocument
mUpdateCallback
mUpdateCallbackDonePromise
mReadyPromise
mFinishedPromise
mNamedElements
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ViewTransition
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ViewTransition
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ViewTransition
)
ViewTransition
:
:
ViewTransition
(
Document
&
aDoc
ViewTransitionUpdateCallback
*
aCb
)
:
mDocument
(
&
aDoc
)
mUpdateCallback
(
aCb
)
{
}
ViewTransition
:
:
~
ViewTransition
(
)
{
ClearTimeoutTimer
(
)
;
}
nsIGlobalObject
*
ViewTransition
:
:
GetParentObject
(
)
const
{
return
mDocument
?
mDocument
-
>
GetParentObject
(
)
:
nullptr
;
}
Promise
*
ViewTransition
:
:
GetUpdateCallbackDone
(
ErrorResult
&
aRv
)
{
if
(
!
mUpdateCallbackDonePromise
)
{
mUpdateCallbackDonePromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mUpdateCallbackDonePromise
;
}
Promise
*
ViewTransition
:
:
GetReady
(
ErrorResult
&
aRv
)
{
if
(
!
mReadyPromise
)
{
mReadyPromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mReadyPromise
;
}
Promise
*
ViewTransition
:
:
GetFinished
(
ErrorResult
&
aRv
)
{
if
(
!
mFinishedPromise
)
{
mFinishedPromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mFinishedPromise
;
}
void
ViewTransition
:
:
CallUpdateCallbackIgnoringErrors
(
CallIfDone
aCallIfDone
)
{
if
(
aCallIfDone
=
=
CallIfDone
:
:
No
&
&
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
CallUpdateCallback
(
IgnoreErrors
(
)
)
;
}
void
ViewTransition
:
:
CallUpdateCallback
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mPhase
=
=
Phase
:
:
Done
|
|
UnderlyingValue
(
mPhase
)
<
UnderlyingValue
(
Phase
:
:
UpdateCallbackCalled
)
)
;
if
(
mPhase
!
=
Phase
:
:
Done
)
{
mPhase
=
Phase
:
:
UpdateCallbackCalled
;
}
RefPtr
<
Promise
>
callbackPromise
;
if
(
!
mUpdateCallback
)
{
callbackPromise
=
Promise
:
:
CreateResolvedWithUndefined
(
GetParentObject
(
)
aRv
)
;
}
else
{
callbackPromise
=
MOZ_KnownLive
(
mUpdateCallback
)
-
>
Call
(
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
callbackPromise
)
;
callbackPromise
-
>
AddCallbacksWithCycleCollectedArgs
(
[
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
ErrorResult
&
aRv
ViewTransition
*
aVt
)
{
if
(
Promise
*
ucd
=
aVt
-
>
GetUpdateCallbackDone
(
aRv
)
)
{
ucd
-
>
MaybeResolveWithUndefined
(
)
;
}
if
(
aVt
-
>
mPhase
=
=
Phase
:
:
Done
)
{
if
(
Promise
*
finished
=
aVt
-
>
GetFinished
(
aRv
)
)
{
finished
-
>
MaybeResolveWithUndefined
(
)
;
}
}
aVt
-
>
Activate
(
)
;
}
[
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
ViewTransition
*
aVt
)
{
if
(
Promise
*
ucd
=
aVt
-
>
GetUpdateCallbackDone
(
aRv
)
)
{
ucd
-
>
MaybeReject
(
aReason
)
;
}
if
(
aVt
-
>
mPhase
=
=
Phase
:
:
Done
)
{
if
(
Promise
*
finished
=
aVt
-
>
GetFinished
(
aRv
)
)
{
finished
-
>
MaybeReject
(
aReason
)
;
}
return
;
}
if
(
Promise
*
ready
=
aVt
-
>
GetReady
(
aRv
)
)
{
MOZ_ALWAYS_TRUE
(
ready
-
>
SetAnyPromiseIsHandled
(
)
)
;
}
aVt
-
>
SkipTransition
(
SkipTransitionReason
:
:
UpdateCallbackRejected
aReason
)
;
}
RefPtr
(
this
)
)
;
MOZ_ASSERT
(
!
mTimeoutTimer
)
;
ClearTimeoutTimer
(
)
;
mTimeoutTimer
=
NS_NewTimer
(
)
;
mTimeoutTimer
-
>
InitWithNamedFuncCallback
(
TimeoutCallback
this
StaticPrefs
:
:
dom_viewTransitions_timeout_ms
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
ViewTransition
:
:
TimeoutCallback
"
)
;
}
void
ViewTransition
:
:
ClearTimeoutTimer
(
)
{
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
mTimeoutTimer
=
nullptr
;
}
}
void
ViewTransition
:
:
TimeoutCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
vt
=
static_cast
<
ViewTransition
*
>
(
aClosure
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aTimer
=
=
vt
-
>
mTimeoutTimer
)
;
vt
-
>
Timeout
(
)
;
}
void
ViewTransition
:
:
Timeout
(
)
{
ClearTimeoutTimer
(
)
;
if
(
mPhase
!
=
Phase
:
:
Done
&
&
mDocument
)
{
SkipTransition
(
SkipTransitionReason
:
:
Timeout
)
;
}
}
void
ViewTransition
:
:
Activate
(
)
{
if
(
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
mPhase
=
Phase
:
:
Animating
;
if
(
Promise
*
ready
=
GetReady
(
IgnoreErrors
(
)
)
)
{
ready
-
>
MaybeResolveWithUndefined
(
)
;
}
}
void
ViewTransition
:
:
PerformPendingOperations
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
;
switch
(
mPhase
)
{
case
Phase
:
:
PendingCapture
:
return
Setup
(
)
;
case
Phase
:
:
Animating
:
return
HandleFrame
(
)
;
default
:
break
;
}
}
nsRect
ViewTransition
:
:
SnapshotContainingBlockRect
(
)
const
{
nsPresContext
*
pc
=
mDocument
-
>
GetPresContext
(
)
;
return
pc
?
pc
-
>
GetVisibleArea
(
)
:
nsRect
(
)
;
}
template
<
typename
Callback
>
static
bool
ForEachChildFrame
(
nsIFrame
*
aFrame
const
Callback
&
aCb
)
{
if
(
!
aCb
(
aFrame
)
)
{
return
false
;
}
for
(
auto
&
[
list
id
]
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
f
:
list
)
{
if
(
!
ForEachChildFrame
(
f
aCb
)
)
{
return
false
;
}
}
}
return
true
;
}
template
<
typename
Callback
>
static
void
ForEachFrame
(
Document
*
aDoc
const
Callback
&
aCb
)
{
PresShell
*
ps
=
aDoc
-
>
GetPresShell
(
)
;
if
(
!
ps
)
{
return
;
}
nsIFrame
*
root
=
ps
-
>
GetRootFrame
(
)
;
if
(
!
root
)
{
return
;
}
ForEachChildFrame
(
root
aCb
)
;
}
static
nsAtom
*
DocumentScopedTransitionNameFor
(
nsIFrame
*
aFrame
)
{
auto
*
name
=
aFrame
-
>
StyleUIReset
(
)
-
>
mViewTransitionName
.
_0
.
AsAtom
(
)
;
if
(
name
-
>
IsEmpty
(
)
)
{
return
nullptr
;
}
return
name
;
}
Maybe
<
SkipTransitionReason
>
ViewTransition
:
:
CaptureOldState
(
)
{
MOZ_ASSERT
(
mNamedElements
.
IsEmpty
(
)
)
;
nsTHashSet
<
nsAtom
*
>
usedTransitionNames
;
AutoTArray
<
std
:
:
pair
<
nsIFrame
*
nsAtom
*
>
32
>
captureElements
;
mInitialSnapshotContainingBlockSize
=
SnapshotContainingBlockRect
(
)
.
Size
(
)
;
Maybe
<
SkipTransitionReason
>
result
;
ForEachFrame
(
mDocument
[
&
]
(
nsIFrame
*
aFrame
)
{
auto
*
name
=
DocumentScopedTransitionNameFor
(
aFrame
)
;
if
(
!
name
)
{
return
true
;
}
if
(
aFrame
-
>
IsHiddenByContentVisibilityOnAnyAncestor
(
)
)
{
return
true
;
}
if
(
aFrame
-
>
GetPrevContinuation
(
)
|
|
aFrame
-
>
GetNextContinuation
(
)
)
{
return
true
;
}
if
(
!
usedTransitionNames
.
EnsureInserted
(
name
)
)
{
result
.
emplace
(
SkipTransitionReason
:
:
DuplicateTransitionName
)
;
return
false
;
}
captureElements
.
AppendElement
(
std
:
:
make_pair
(
aFrame
name
)
)
;
return
true
;
}
)
;
if
(
result
)
{
return
result
;
}
for
(
auto
&
[
f
name
]
:
captureElements
)
{
MOZ_ASSERT
(
f
)
;
MOZ_ASSERT
(
f
-
>
GetContent
(
)
-
>
IsElement
(
)
)
;
auto
capture
=
MakeUnique
<
CapturedElement
>
(
f
mInitialSnapshotContainingBlockSize
)
;
mNamedElements
.
InsertOrUpdate
(
name
std
:
:
move
(
capture
)
)
;
}
return
result
;
}
void
ViewTransition
:
:
Setup
(
)
{
if
(
auto
skipReason
=
CaptureOldState
(
)
)
{
return
SkipTransition
(
*
skipReason
)
;
}
mDocument
-
>
Dispatch
(
NewRunnableMethod
<
CallIfDone
>
(
"
ViewTransition
:
:
CallUpdateCallbackFromSetup
"
this
&
ViewTransition
:
:
CallUpdateCallbackIgnoringErrors
CallIfDone
:
:
No
)
)
;
}
void
ViewTransition
:
:
HandleFrame
(
)
{
bool
hasActiveAnimations
=
false
;
if
(
!
hasActiveAnimations
)
{
mPhase
=
Phase
:
:
Done
;
ClearActiveTransition
(
)
;
if
(
Promise
*
finished
=
GetFinished
(
IgnoreErrors
(
)
)
)
{
finished
-
>
MaybeResolveWithUndefined
(
)
;
}
return
;
}
}
void
ViewTransition
:
:
ClearNamedElements
(
)
{
mNamedElements
.
Clear
(
)
;
}
void
ViewTransition
:
:
ClearActiveTransition
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
;
ClearNamedElements
(
)
;
mDocument
-
>
ClearActiveViewTransition
(
)
;
}
void
ViewTransition
:
:
SkipTransition
(
SkipTransitionReason
aReason
)
{
SkipTransition
(
aReason
JS
:
:
UndefinedHandleValue
)
;
}
void
ViewTransition
:
:
SkipTransition
(
SkipTransitionReason
aReason
JS
:
:
Handle
<
JS
:
:
Value
>
aUpdateCallbackRejectReason
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT_IF
(
aReason
!
=
SkipTransitionReason
:
:
JS
mPhase
!
=
Phase
:
:
Done
)
;
MOZ_ASSERT_IF
(
aReason
!
=
SkipTransitionReason
:
:
UpdateCallbackRejected
aUpdateCallbackRejectReason
=
=
JS
:
:
UndefinedHandleValue
)
;
if
(
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
if
(
UnderlyingValue
(
mPhase
)
<
UnderlyingValue
(
Phase
:
:
UpdateCallbackCalled
)
)
{
mDocument
-
>
Dispatch
(
NewRunnableMethod
<
CallIfDone
>
(
"
ViewTransition
:
:
CallUpdateCallbackFromSkip
"
this
&
ViewTransition
:
:
CallUpdateCallbackIgnoringErrors
CallIfDone
:
:
Yes
)
)
;
}
if
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
{
ClearActiveTransition
(
)
;
}
mPhase
=
Phase
:
:
Done
;
if
(
Promise
*
readyPromise
=
GetReady
(
IgnoreErrors
(
)
)
)
{
switch
(
aReason
)
{
case
SkipTransitionReason
:
:
JS
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
skipTransition
(
)
call
"
)
;
break
;
case
SkipTransitionReason
:
:
ClobberedActiveTransition
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
another
transition
starting
"
)
;
break
;
case
SkipTransitionReason
:
:
DocumentHidden
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
document
being
hidden
"
)
;
break
;
case
SkipTransitionReason
:
:
Timeout
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
timeout
"
)
;
break
;
case
SkipTransitionReason
:
:
DuplicateTransitionName
:
readyPromise
-
>
MaybeRejectWithInvalidStateError
(
"
Duplicate
view
-
transition
-
name
value
while
capturing
old
state
"
)
;
break
;
case
SkipTransitionReason
:
:
UpdateCallbackRejected
:
readyPromise
-
>
MaybeReject
(
aUpdateCallbackRejectReason
)
;
break
;
}
}
}
JSObject
*
ViewTransition
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ViewTransition_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
;
