#
include
"
ViewTransition
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
mozilla
/
dom
/
ViewTransitionBinding
.
h
"
#
include
"
nsITimer
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ViewTransition
mDocument
mUpdateCallback
mUpdateCallbackDonePromise
mReadyPromise
mFinishedPromise
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ViewTransition
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ViewTransition
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ViewTransition
)
ViewTransition
:
:
ViewTransition
(
Document
&
aDoc
ViewTransitionUpdateCallback
*
aCb
)
:
mDocument
(
&
aDoc
)
mUpdateCallback
(
aCb
)
{
}
ViewTransition
:
:
~
ViewTransition
(
)
{
ClearTimeoutTimer
(
)
;
}
nsIGlobalObject
*
ViewTransition
:
:
GetParentObject
(
)
const
{
return
mDocument
?
mDocument
-
>
GetParentObject
(
)
:
nullptr
;
}
Promise
*
ViewTransition
:
:
GetUpdateCallbackDone
(
ErrorResult
&
aRv
)
{
if
(
!
mUpdateCallbackDonePromise
)
{
mUpdateCallbackDonePromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mUpdateCallbackDonePromise
;
}
Promise
*
ViewTransition
:
:
GetReady
(
ErrorResult
&
aRv
)
{
if
(
!
mReadyPromise
)
{
mReadyPromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mReadyPromise
;
}
Promise
*
ViewTransition
:
:
GetFinished
(
ErrorResult
&
aRv
)
{
if
(
!
mFinishedPromise
)
{
mFinishedPromise
=
Promise
:
:
Create
(
GetParentObject
(
)
aRv
)
;
}
return
mFinishedPromise
;
}
void
ViewTransition
:
:
CallUpdateCallbackIgnoringErrors
(
CallIfDone
aCallIfDone
)
{
if
(
aCallIfDone
=
=
CallIfDone
:
:
No
&
&
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
CallUpdateCallback
(
IgnoreErrors
(
)
)
;
}
void
ViewTransition
:
:
CallUpdateCallback
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mPhase
=
=
Phase
:
:
Done
|
|
UnderlyingValue
(
mPhase
)
<
UnderlyingValue
(
Phase
:
:
UpdateCallbackCalled
)
)
;
if
(
mPhase
!
=
Phase
:
:
Done
)
{
mPhase
=
Phase
:
:
UpdateCallbackCalled
;
}
RefPtr
<
Promise
>
callbackPromise
;
if
(
!
mUpdateCallback
)
{
callbackPromise
=
Promise
:
:
CreateResolvedWithUndefined
(
GetParentObject
(
)
aRv
)
;
}
else
{
callbackPromise
=
MOZ_KnownLive
(
mUpdateCallback
)
-
>
Call
(
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
callbackPromise
)
;
callbackPromise
-
>
AddCallbacksWithCycleCollectedArgs
(
[
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
ErrorResult
&
aRv
ViewTransition
*
aVt
)
{
if
(
Promise
*
ucd
=
aVt
-
>
GetUpdateCallbackDone
(
aRv
)
)
{
ucd
-
>
MaybeResolveWithUndefined
(
)
;
}
if
(
aVt
-
>
mPhase
=
=
Phase
:
:
Done
)
{
if
(
Promise
*
finished
=
aVt
-
>
GetFinished
(
aRv
)
)
{
finished
-
>
MaybeResolveWithUndefined
(
)
;
}
}
aVt
-
>
Activate
(
)
;
}
[
]
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
aReason
ErrorResult
&
aRv
ViewTransition
*
aVt
)
{
if
(
Promise
*
ucd
=
aVt
-
>
GetUpdateCallbackDone
(
aRv
)
)
{
ucd
-
>
MaybeReject
(
aReason
)
;
}
if
(
aVt
-
>
mPhase
=
=
Phase
:
:
Done
)
{
if
(
Promise
*
finished
=
aVt
-
>
GetFinished
(
aRv
)
)
{
finished
-
>
MaybeReject
(
aReason
)
;
}
return
;
}
if
(
Promise
*
ready
=
aVt
-
>
GetReady
(
aRv
)
)
{
MOZ_ALWAYS_TRUE
(
ready
-
>
SetAnyPromiseIsHandled
(
)
)
;
}
aVt
-
>
SkipTransition
(
SkipTransitionReason
:
:
UpdateCallbackRejected
aReason
)
;
}
RefPtr
(
this
)
)
;
MOZ_ASSERT
(
!
mTimeoutTimer
)
;
ClearTimeoutTimer
(
)
;
mTimeoutTimer
=
NS_NewTimer
(
)
;
mTimeoutTimer
-
>
InitWithNamedFuncCallback
(
TimeoutCallback
this
StaticPrefs
:
:
dom_viewTransitions_timeout_ms
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
ViewTransition
:
:
TimeoutCallback
"
)
;
}
void
ViewTransition
:
:
ClearTimeoutTimer
(
)
{
if
(
mTimeoutTimer
)
{
mTimeoutTimer
-
>
Cancel
(
)
;
mTimeoutTimer
=
nullptr
;
}
}
void
ViewTransition
:
:
TimeoutCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
vt
=
static_cast
<
ViewTransition
*
>
(
aClosure
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aTimer
=
=
vt
-
>
mTimeoutTimer
)
;
vt
-
>
Timeout
(
)
;
}
void
ViewTransition
:
:
Timeout
(
)
{
ClearTimeoutTimer
(
)
;
if
(
mPhase
!
=
Phase
:
:
Done
&
&
mDocument
)
{
SkipTransition
(
SkipTransitionReason
:
:
Timeout
)
;
}
}
void
ViewTransition
:
:
Activate
(
)
{
if
(
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
mPhase
=
Phase
:
:
Animating
;
if
(
Promise
*
ready
=
GetReady
(
IgnoreErrors
(
)
)
)
{
ready
-
>
MaybeResolveWithUndefined
(
)
;
}
}
void
ViewTransition
:
:
PerformPendingOperations
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
;
switch
(
mPhase
)
{
case
Phase
:
:
PendingCapture
:
return
Setup
(
)
;
case
Phase
:
:
Animating
:
return
HandleFrame
(
)
;
default
:
break
;
}
}
void
ViewTransition
:
:
Setup
(
)
{
mDocument
-
>
Dispatch
(
NewRunnableMethod
<
CallIfDone
>
(
"
ViewTransition
:
:
CallUpdateCallbackFromSetup
"
this
&
ViewTransition
:
:
CallUpdateCallbackIgnoringErrors
CallIfDone
:
:
No
)
)
;
}
void
ViewTransition
:
:
HandleFrame
(
)
{
bool
hasActiveAnimations
=
false
;
if
(
!
hasActiveAnimations
)
{
mPhase
=
Phase
:
:
Done
;
ClearActiveTransition
(
)
;
if
(
Promise
*
finished
=
GetFinished
(
IgnoreErrors
(
)
)
)
{
finished
-
>
MaybeResolveWithUndefined
(
)
;
}
return
;
}
}
void
ViewTransition
:
:
ClearActiveTransition
(
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
;
mDocument
-
>
ClearActiveViewTransition
(
)
;
}
void
ViewTransition
:
:
SkipTransition
(
SkipTransitionReason
aReason
)
{
SkipTransition
(
aReason
JS
:
:
UndefinedHandleValue
)
;
}
void
ViewTransition
:
:
SkipTransition
(
SkipTransitionReason
aReason
JS
:
:
Handle
<
JS
:
:
Value
>
aUpdateCallbackRejectReason
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT_IF
(
aReason
!
=
SkipTransitionReason
:
:
JS
mPhase
!
=
Phase
:
:
Done
)
;
MOZ_ASSERT_IF
(
aReason
!
=
SkipTransitionReason
:
:
UpdateCallbackRejected
aUpdateCallbackRejectReason
=
=
JS
:
:
UndefinedHandleValue
)
;
if
(
mPhase
=
=
Phase
:
:
Done
)
{
return
;
}
if
(
UnderlyingValue
(
mPhase
)
<
UnderlyingValue
(
Phase
:
:
UpdateCallbackCalled
)
)
{
mDocument
-
>
Dispatch
(
NewRunnableMethod
<
CallIfDone
>
(
"
ViewTransition
:
:
CallUpdateCallbackFromSkip
"
this
&
ViewTransition
:
:
CallUpdateCallbackIgnoringErrors
CallIfDone
:
:
Yes
)
)
;
}
if
(
mDocument
-
>
GetActiveViewTransition
(
)
=
=
this
)
{
ClearActiveTransition
(
)
;
}
mPhase
=
Phase
:
:
Done
;
if
(
Promise
*
readyPromise
=
GetReady
(
IgnoreErrors
(
)
)
)
{
switch
(
aReason
)
{
case
SkipTransitionReason
:
:
JS
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
skipTransition
(
)
call
"
)
;
break
;
case
SkipTransitionReason
:
:
ClobberedActiveTransition
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
another
transition
starting
"
)
;
break
;
case
SkipTransitionReason
:
:
DocumentHidden
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
document
being
hidden
"
)
;
break
;
case
SkipTransitionReason
:
:
Timeout
:
readyPromise
-
>
MaybeRejectWithAbortError
(
"
Skipped
ViewTransition
due
to
timeout
"
)
;
break
;
case
SkipTransitionReason
:
:
UpdateCallbackRejected
:
readyPromise
-
>
MaybeReject
(
aUpdateCallbackRejectReason
)
;
break
;
}
}
}
JSObject
*
ViewTransition
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ViewTransition_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
;
