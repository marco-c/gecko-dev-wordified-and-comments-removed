#
include
"
ErrorList
.
h
"
#
include
"
FileSystemDataManager
.
h
"
#
include
"
FileSystemDatabaseManagerVersion001
.
h
"
#
include
"
FileSystemFileManager
.
h
"
#
include
"
FileSystemHashSource
.
h
"
#
include
"
ResultStatement
.
h
"
#
include
"
SchemaVersion001
.
h
"
#
include
"
TestHelpers
.
h
"
#
include
"
gtest
/
gtest
.
h
"
#
include
"
mozIStorageService
.
h
"
#
include
"
mozStorageCID
.
h
"
#
include
"
mozStorageHelper
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemTypes
.
h
"
#
include
"
mozilla
/
dom
/
PFileSystemManager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
CommonMetadata
.
h
"
#
include
"
nsAppDirectoryServiceDefs
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashSet
.
h
"
namespace
mozilla
:
:
dom
:
:
fs
:
:
test
{
using
data
:
:
FileSystemDatabaseManagerVersion001
;
using
data
:
:
FileSystemFileManager
;
namespace
{
const
Origin
&
getTestOrigin
(
)
{
static
const
Origin
orig
=
"
http
:
/
/
example
.
com
"
_ns
;
return
orig
;
}
}
class
MockFileSystemDataManager
final
:
public
data
:
:
FileSystemDataManager
{
public
:
MockFileSystemDataManager
(
const
quota
:
:
OriginMetadata
&
aOriginMetadata
MovingNotNull
<
nsCOMPtr
<
nsIEventTarget
>
>
aIOTarget
MovingNotNull
<
RefPtr
<
TaskQueue
>
>
aIOTaskQueue
)
:
FileSystemDataManager
(
aOriginMetadata
std
:
:
move
(
aIOTarget
)
std
:
:
move
(
aIOTaskQueue
)
)
{
}
virtual
~
MockFileSystemDataManager
(
)
{
mState
=
State
:
:
Closed
;
}
}
;
static
void
MakeDatabaseManagerVersion001
(
FileSystemDatabaseManagerVersion001
*
&
aResult
RefPtr
<
MockFileSystemDataManager
>
&
aDataManager
)
{
TEST_TRY_UNWRAP
(
auto
storageService
MOZ_TO_RESULT_GET_TYPED
(
nsCOMPtr
<
mozIStorageService
>
MOZ_SELECT_OVERLOAD
(
do_GetService
)
MOZ_STORAGE_SERVICE_CONTRACTID
)
)
;
const
auto
flags
=
mozIStorageService
:
:
CONNECTION_DEFAULT
;
ResultConnection
connection
;
nsresult
rv
=
storageService
-
>
OpenSpecialDatabase
(
kMozStorageMemoryStorageKey
VoidCString
(
)
flags
getter_AddRefs
(
connection
)
)
;
ASSERT_NSEQ
(
NS_OK
rv
)
;
const
Origin
&
testOrigin
=
getTestOrigin
(
)
;
TEST_TRY_UNWRAP
(
DatabaseVersion
version
SchemaVersion001
:
:
InitializeConnection
(
connection
testOrigin
)
)
;
ASSERT_EQ
(
1
version
)
;
nsCOMPtr
<
nsIFile
>
testPath
;
rv
=
NS_GetSpecialDirectory
(
NS_APP_USER_PROFILE_50_DIR
getter_AddRefs
(
testPath
)
)
;
ASSERT_NSEQ
(
NS_OK
rv
)
;
TEST_TRY_UNWRAP
(
EntryId
rootId
data
:
:
GetRootHandle
(
getTestOrigin
(
)
)
)
;
auto
fmRes
=
FileSystemFileManager
:
:
CreateFileSystemFileManager
(
std
:
:
move
(
testPath
)
)
;
ASSERT_FALSE
(
fmRes
.
isErr
(
)
)
;
QM_TRY_UNWRAP
(
auto
streamTransportService
MOZ_TO_RESULT_GET_TYPED
(
nsCOMPtr
<
nsIEventTarget
>
MOZ_SELECT_OVERLOAD
(
do_GetService
)
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
QM_VOID
)
;
quota
:
:
OriginMetadata
originMetadata
=
GetTestOriginMetadata
(
)
;
nsCString
taskQueueName
(
"
OPFS
"
_ns
+
originMetadata
.
mOrigin
)
;
RefPtr
<
TaskQueue
>
ioTaskQueue
=
TaskQueue
:
:
Create
(
do_AddRef
(
streamTransportService
)
taskQueueName
.
get
(
)
)
;
auto
dataManager
=
MakeRefPtr
<
MockFileSystemDataManager
>
(
originMetadata
WrapMovingNotNull
(
streamTransportService
)
WrapMovingNotNull
(
ioTaskQueue
)
)
;
aResult
=
new
FileSystemDatabaseManagerVersion001
(
dataManager
std
:
:
move
(
connection
)
MakeUnique
<
FileSystemFileManager
>
(
fmRes
.
unwrap
(
)
)
rootId
)
;
}
TEST
(
TestFileSystemDatabaseManagerVersion001
smokeTestCreateRemoveDirectories
)
{
nsresult
rv
=
NS_OK
;
FileSystemDatabaseManagerVersion001
*
rdm
=
nullptr
;
RefPtr
<
MockFileSystemDataManager
>
dataManager
;
ASSERT_NO_FATAL_FAILURE
(
MakeDatabaseManagerVersion001
(
rdm
dataManager
)
)
;
UniquePtr
<
FileSystemDatabaseManagerVersion001
>
dm
(
rdm
)
;
auto
autoClose
=
MakeScopeExit
(
[
rdm
]
{
rdm
-
>
Close
(
)
;
}
)
;
TEST_TRY_UNWRAP
(
EntryId
rootId
data
:
:
GetRootHandle
(
getTestOrigin
(
)
)
)
;
FileSystemChildMetadata
firstChildMeta
(
rootId
u
"
First
"
_ns
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateDirectory
(
firstChildMeta
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
TEST_TRY_UNWRAP
(
EntryId
firstChild
dm
-
>
GetOrCreateDirectory
(
firstChildMeta
true
)
)
;
int32_t
dbVersion
=
0
;
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
entries
dm
-
>
GetDirectoryEntries
(
rootId
dbVersion
)
)
;
ASSERT_EQ
(
1u
entries
.
directories
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
0u
entries
.
files
(
)
.
Length
(
)
)
;
const
auto
&
firstItemRef
=
entries
.
directories
(
)
[
0
]
;
ASSERT_TRUE
(
u
"
First
"
_ns
=
=
firstItemRef
.
entryName
(
)
)
<
<
firstItemRef
.
entryName
(
)
;
ASSERT_EQ
(
firstChild
firstItemRef
.
entryId
(
)
)
;
TEST_TRY_UNWRAP
(
EntryId
firstChildClone
dm
-
>
GetOrCreateDirectory
(
firstChildMeta
true
)
)
;
ASSERT_EQ
(
firstChild
firstChildClone
)
;
FileSystemChildMetadata
secondChildMeta
(
firstChild
u
"
Second
"
_ns
)
;
TEST_TRY_UNWRAP
(
EntryId
secondChild
dm
-
>
GetOrCreateDirectory
(
secondChildMeta
true
)
)
;
FileSystemEntryPair
shortPair
(
firstChild
secondChild
)
;
TEST_TRY_UNWRAP
(
Path
shortPath
dm
-
>
Resolve
(
shortPair
)
)
;
ASSERT_EQ
(
1u
shortPath
.
Length
(
)
)
;
ASSERT_EQ
(
u
"
Second
"
_ns
shortPath
[
0
]
)
;
FileSystemEntryPair
longPair
(
rootId
secondChild
)
;
TEST_TRY_UNWRAP
(
Path
longPath
dm
-
>
Resolve
(
longPair
)
)
;
ASSERT_EQ
(
2u
longPath
.
Length
(
)
)
;
ASSERT_EQ
(
u
"
First
"
_ns
longPath
[
0
]
)
;
ASSERT_EQ
(
u
"
Second
"
_ns
longPath
[
1
]
)
;
FileSystemEntryPair
wrongPair
(
secondChild
rootId
)
;
TEST_TRY_UNWRAP
(
Path
emptyPath
dm
-
>
Resolve
(
wrongPair
)
)
;
ASSERT_TRUE
(
emptyPath
.
IsEmpty
(
)
)
;
PageNumber
page
=
0
;
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
fEntries
dm
-
>
GetDirectoryEntries
(
firstChild
page
)
)
;
ASSERT_EQ
(
1u
fEntries
.
directories
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
0u
fEntries
.
files
(
)
.
Length
(
)
)
;
const
auto
&
secItemRef
=
fEntries
.
directories
(
)
[
0
]
;
ASSERT_TRUE
(
u
"
Second
"
_ns
=
=
secItemRef
.
entryName
(
)
)
<
<
secItemRef
.
entryName
(
)
;
ASSERT_EQ
(
secondChild
secItemRef
.
entryId
(
)
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
RemoveDirectory
(
firstChildMeta
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_INVALID_MODIFICATION_ERR
rv
)
;
TEST_TRY_UNWRAP
(
bool
isDeleted
dm
-
>
RemoveDirectory
(
firstChildMeta
true
)
)
;
ASSERT_TRUE
(
isDeleted
)
;
FileSystemChildMetadata
thirdChildMeta
(
secondChild
u
"
Second
"
_ns
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateDirectory
(
thirdChildMeta
true
)
)
;
ASSERT_NSEQ
(
NS_ERROR_STORAGE_CONSTRAINT
rv
)
;
dm
-
>
Close
(
)
;
}
TEST
(
TestFileSystemDatabaseManagerVersion001
smokeTestCreateRemoveFiles
)
{
nsresult
rv
=
NS_OK
;
RefPtr
<
MockFileSystemDataManager
>
datamanager
;
FileSystemDatabaseManagerVersion001
*
rdm
=
nullptr
;
ASSERT_NO_FATAL_FAILURE
(
MakeDatabaseManagerVersion001
(
rdm
datamanager
)
)
;
UniquePtr
<
FileSystemDatabaseManagerVersion001
>
dm
(
rdm
)
;
TEST_TRY_UNWRAP
(
EntryId
rootId
data
:
:
GetRootHandle
(
getTestOrigin
(
)
)
)
;
FileSystemChildMetadata
firstChildMeta
(
rootId
u
"
First
"
_ns
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateFile
(
firstChildMeta
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
TEST_TRY_UNWRAP
(
EntryId
firstChild
dm
-
>
GetOrCreateFile
(
firstChildMeta
true
)
)
;
TEST_TRY_UNWRAP
(
EntryId
firstChildClone
dm
-
>
GetOrCreateFile
(
firstChildMeta
true
)
)
;
ASSERT_STREQ
(
firstChild
.
get
(
)
firstChildClone
.
get
(
)
)
;
PageNumber
page
=
0
;
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
entries
dm
-
>
GetDirectoryEntries
(
rootId
page
)
)
;
ASSERT_EQ
(
0u
entries
.
directories
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
1u
entries
.
files
(
)
.
Length
(
)
)
;
auto
&
firstItemRef
=
entries
.
files
(
)
[
0
]
;
ASSERT_TRUE
(
u
"
First
"
_ns
=
=
firstItemRef
.
entryName
(
)
)
<
<
firstItemRef
.
entryName
(
)
;
ASSERT_STREQ
(
firstChild
.
get
(
)
firstItemRef
.
entryId
(
)
.
get
(
)
)
;
nsString
type
;
TimeStamp
lastModifiedMilliSeconds
;
Path
path
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
dm
-
>
GetFile
(
firstItemRef
.
entryId
(
)
type
lastModifiedMilliSeconds
path
file
)
;
ASSERT_NSEQ
(
NS_OK
rv
)
;
ASSERT_TRUE
(
type
.
IsEmpty
(
)
)
;
const
int64_t
nowMilliSeconds
=
PR_Now
(
)
/
1000
;
ASSERT_GE
(
nowMilliSeconds
lastModifiedMilliSeconds
)
;
const
int64_t
expectedMaxDelayMilliSeconds
=
100
;
const
int64_t
actualDelay
=
nowMilliSeconds
-
lastModifiedMilliSeconds
;
ASSERT_LT
(
actualDelay
expectedMaxDelayMilliSeconds
)
;
ASSERT_EQ
(
1u
path
.
Length
(
)
)
;
ASSERT_STREQ
(
u
"
First
"
_ns
path
[
0
]
)
;
ASSERT_NE
(
nullptr
file
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateDirectory
(
firstChildMeta
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_TYPE_MISMATCH_ERR
rv
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateDirectory
(
firstChildMeta
true
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_TYPE_MISMATCH_ERR
rv
)
;
EntryId
notAChildHash
=
"
0123456789abcdef0123456789abcdef
"
_ns
;
FileSystemChildMetadata
notAChildMeta
(
notAChildHash
u
"
Dummy
"
_ns
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateFile
(
notAChildMeta
true
)
)
;
ASSERT_NSEQ
(
NS_ERROR_STORAGE_CONSTRAINT
rv
)
;
FileSystemChildMetadata
secondChildMeta
(
rootId
u
"
Second
"
_ns
)
;
TEST_TRY_UNWRAP
(
EntryId
secondChild
dm
-
>
GetOrCreateDirectory
(
secondChildMeta
true
)
)
;
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
fEntries
dm
-
>
GetDirectoryEntries
(
rootId
page
)
)
;
ASSERT_EQ
(
1u
fEntries
.
directories
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
1u
fEntries
.
files
(
)
.
Length
(
)
)
;
const
auto
&
secItemRef
=
fEntries
.
directories
(
)
[
0
]
;
ASSERT_TRUE
(
u
"
Second
"
_ns
=
=
secItemRef
.
entryName
(
)
)
<
<
secItemRef
.
entryName
(
)
;
ASSERT_EQ
(
secondChild
secItemRef
.
entryId
(
)
)
;
FileSystemChildMetadata
thirdChildMeta
(
secondChild
u
"
Third
"
_ns
)
;
TEST_TRY_UNWRAP
(
EntryId
thirdChild
dm
-
>
GetOrCreateFile
(
thirdChildMeta
true
)
)
;
FileSystemEntryPair
entryPair
(
rootId
thirdChild
)
;
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
entryPair
)
)
;
ASSERT_EQ
(
2u
entryPath
.
Length
(
)
)
;
ASSERT_EQ
(
u
"
Second
"
_ns
entryPath
[
0
]
)
;
ASSERT_EQ
(
u
"
Third
"
_ns
entryPath
[
1
]
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
RemoveDirectory
(
secondChildMeta
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_INVALID_MODIFICATION_ERR
rv
)
;
TEST_TRY_UNWRAP
(
bool
isDeleted
dm
-
>
RemoveDirectory
(
secondChildMeta
true
)
)
;
ASSERT_TRUE
(
isDeleted
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateFile
(
thirdChildMeta
true
)
)
;
ASSERT_NSEQ
(
NS_ERROR_STORAGE_CONSTRAINT
rv
)
;
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
nEntries
dm
-
>
GetDirectoryEntries
(
rootId
0
)
)
;
ASSERT_EQ
(
0u
nEntries
.
directories
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
1u
nEntries
.
files
(
)
.
Length
(
)
)
;
const
auto
&
fileItemRef
=
nEntries
.
files
(
)
[
0
]
;
ASSERT_TRUE
(
u
"
First
"
_ns
=
=
fileItemRef
.
entryName
(
)
)
<
<
fileItemRef
.
entryName
(
)
;
ASSERT_EQ
(
firstChild
fileItemRef
.
entryId
(
)
)
;
dm
-
>
Close
(
)
;
}
TEST
(
TestFileSystemDatabaseManagerVersion001
smokeTestCreateMoveDirectories
)
{
RefPtr
<
MockFileSystemDataManager
>
datamanager
;
FileSystemDatabaseManagerVersion001
*
rdm
=
nullptr
;
ASSERT_NO_FATAL_FAILURE
(
MakeDatabaseManagerVersion001
(
rdm
datamanager
)
)
;
UniquePtr
<
FileSystemDatabaseManagerVersion001
>
dm
(
rdm
)
;
auto
closeAtExit
=
MakeScopeExit
(
[
&
dm
]
(
)
{
dm
-
>
Close
(
)
;
}
)
;
TEST_TRY_UNWRAP
(
EntryId
rootId
data
:
:
GetRootHandle
(
getTestOrigin
(
)
)
)
;
FileSystemEntryMetadata
rootMeta
{
rootId
u
"
root
"
_ns
true
}
;
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
rootId
0u
)
)
;
ASSERT_TRUE
(
contents
.
directories
(
)
.
IsEmpty
(
)
)
;
ASSERT_TRUE
(
contents
.
files
(
)
.
IsEmpty
(
)
)
;
}
FileSystemChildMetadata
firstChildMeta
(
rootId
u
"
First
"
_ns
)
;
TEST_TRY_UNWRAP
(
EntryId
firstChildDir
dm
-
>
GetOrCreateDirectory
(
firstChildMeta
true
)
)
;
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
rootId
0u
)
)
;
ASSERT_TRUE
(
contents
.
files
(
)
.
IsEmpty
(
)
)
;
ASSERT_EQ
(
1u
contents
.
directories
(
)
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
contents
.
directories
(
)
[
0
]
.
entryName
(
)
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDir
firstChildMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
rootId
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDir
firstChildMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
src
.
entryId
(
)
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_INVALID_MODIFICATION_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
rootId
rootMeta
.
entryName
(
)
true
}
;
FileSystemChildMetadata
dest
{
firstChildDir
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
}
FileSystemChildMetadata
firstChildDescendantMeta
(
firstChildDir
u
"
Descendant
"
_ns
)
;
TEST_TRY_UNWRAP
(
EntryId
firstChildDescendant
dm
-
>
GetOrCreateDirectory
(
firstChildDescendantMeta
true
)
)
;
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
firstChildDir
0u
)
)
;
ASSERT_TRUE
(
contents
.
files
(
)
.
IsEmpty
(
)
)
;
ASSERT_EQ
(
1u
contents
.
directories
(
)
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildDescendantMeta
.
childName
(
)
contents
.
directories
(
)
[
0
]
.
entryName
(
)
)
;
TEST_TRY_UNWRAP
(
Path
subSubDirPath
dm
-
>
Resolve
(
{
rootId
contents
.
directories
(
)
[
0
]
.
entryId
(
)
}
)
)
;
ASSERT_EQ
(
2u
subSubDirPath
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
subSubDirPath
[
0
]
)
;
ASSERT_STREQ
(
firstChildDescendantMeta
.
childName
(
)
subSubDirPath
[
1
]
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
firstChildDir
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
src
.
entryId
(
)
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_INVALID_MODIFICATION_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDir
firstChildMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
firstChildDescendant
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_INVALID_MODIFICATION_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
rootId
rootMeta
.
entryName
(
)
true
}
;
FileSystemChildMetadata
dest
{
firstChildDescendant
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
}
FileSystemChildMetadata
testFileMeta
(
firstChildDir
u
"
Subfile
"
_ns
)
;
TEST_TRY_UNWRAP
(
EntryId
testFile
dm
-
>
GetOrCreateFile
(
testFileMeta
true
)
)
;
FileSystemEntryMetadata
subSubDir
;
FileSystemEntryMetadata
subSubFile
;
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
firstChildDir
0u
)
)
;
ASSERT_EQ
(
1u
contents
.
files
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
1u
contents
.
directories
(
)
.
Length
(
)
)
;
subSubDir
=
contents
.
directories
(
)
[
0
]
;
ASSERT_STREQ
(
firstChildDescendantMeta
.
childName
(
)
subSubDir
.
entryName
(
)
)
;
subSubFile
=
contents
.
files
(
)
[
0
]
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
subSubFile
.
entryName
(
)
)
;
}
{
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
{
rootId
subSubFile
.
entryId
(
)
}
)
)
;
ASSERT_EQ
(
2u
entryPath
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
entryPath
[
0
]
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
1
]
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
testFileMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
firstChildDir
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
testFileMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
firstChildDir
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
testFileMeta
.
childName
(
)
false
}
;
const
FileSystemChildMetadata
&
dest
=
firstChildDescendantMeta
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
testFileMeta
.
childName
(
)
true
}
;
const
FileSystemChildMetadata
&
dest
=
firstChildDescendantMeta
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
true
}
;
const
FileSystemChildMetadata
&
dest
=
testFileMeta
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
false
}
;
const
FileSystemChildMetadata
&
dest
=
testFileMeta
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
testFile
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_STORAGE_CONSTRAINT
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
testFile
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_STORAGE_CONSTRAINT
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
testFile
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_STORAGE_CONSTRAINT
rv
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
testFileMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
rootId
src
.
entryName
(
)
}
;
TEST_TRY_UNWRAP
(
bool
isMoved
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_TRUE
(
isMoved
)
;
}
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
firstChildDir
0u
)
)
;
ASSERT_TRUE
(
contents
.
files
(
)
.
IsEmpty
(
)
)
;
ASSERT_EQ
(
1u
contents
.
directories
(
)
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildDescendantMeta
.
childName
(
)
contents
.
directories
(
)
[
0
]
.
entryName
(
)
)
;
}
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
rootId
0u
)
)
;
ASSERT_EQ
(
1u
contents
.
files
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
1u
contents
.
files
(
)
.
Length
(
)
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
contents
.
files
(
)
[
0
]
.
entryName
(
)
)
;
}
{
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
{
rootId
subSubFile
.
entryId
(
)
}
)
)
;
ASSERT_EQ
(
1u
entryPath
.
Length
(
)
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
0
]
)
;
}
{
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
GetOrCreateFile
(
testFileMeta
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
testFileMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
firstChildDir
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
testFileMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
rootId
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP
(
bool
isMoved
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_TRUE
(
isMoved
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
firstChildDescendantMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
firstChildDir
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
rootId
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
FileSystemChildMetadata
newFileMeta
{
firstChildDescendant
testFileMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP
(
EntryId
newFile
dm
-
>
GetOrCreateFile
(
newFileMeta
true
)
)
;
{
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
{
rootId
newFile
}
)
)
;
ASSERT_EQ
(
3u
entryPath
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
entryPath
[
0
]
)
;
ASSERT_STREQ
(
firstChildDescendantMeta
.
childName
(
)
entryPath
[
1
]
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
2
]
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
rootId
testFileMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP
(
bool
isMoved
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_TRUE
(
isMoved
)
;
}
{
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
GetOrCreateDirectory
(
firstChildDescendantMeta
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
TEST_TRY_UNWRAP
(
EntryId
handle
dm
-
>
GetOrCreateFile
(
newFileMeta
false
)
)
;
ASSERT_STREQ
(
handle
newFile
)
;
TEST_TRY_UNWRAP
(
handle
dm
-
>
GetOrCreateDirectory
(
{
rootId
testFileMeta
.
childName
(
)
}
false
)
)
;
ASSERT_STREQ
(
handle
firstChildDescendant
)
;
}
{
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
{
rootId
newFile
}
)
)
;
ASSERT_EQ
(
2u
entryPath
.
Length
(
)
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
0
]
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
1
]
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
firstChildDescendantMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
rootId
firstChildMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
rv
)
;
}
{
FileSystemEntryMetadata
src
{
testFile
firstChildDescendantMeta
.
childName
(
)
true
}
;
FileSystemChildMetadata
dest
{
firstChildDir
firstChildDescendantMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP
(
bool
isMoved
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_TRUE
(
isMoved
)
;
}
{
FileSystemEntryMetadata
src
{
firstChildDescendant
testFileMeta
.
childName
(
)
false
}
;
FileSystemChildMetadata
dest
{
firstChildDir
testFileMeta
.
childName
(
)
}
;
TEST_TRY_UNWRAP
(
bool
isMoved
dm
-
>
MoveEntry
(
src
dest
)
)
;
ASSERT_TRUE
(
isMoved
)
;
}
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
rootId
0u
)
)
;
ASSERT_TRUE
(
contents
.
files
(
)
.
IsEmpty
(
)
)
;
ASSERT_EQ
(
1u
contents
.
directories
(
)
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
contents
.
directories
(
)
[
0
]
.
entryName
(
)
)
;
}
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
firstChildDir
0u
)
)
;
ASSERT_EQ
(
1u
contents
.
files
(
)
.
Length
(
)
)
;
ASSERT_EQ
(
1u
contents
.
directories
(
)
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildDescendantMeta
.
childName
(
)
contents
.
files
(
)
[
0
]
.
entryName
(
)
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
contents
.
directories
(
)
[
0
]
.
entryName
(
)
)
;
}
{
TEST_TRY_UNWRAP
(
FileSystemDirectoryListing
contents
dm
-
>
GetDirectoryEntries
(
firstChildDescendant
0u
)
)
;
ASSERT_EQ
(
1u
contents
.
files
(
)
.
Length
(
)
)
;
ASSERT_TRUE
(
contents
.
directories
(
)
.
IsEmpty
(
)
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
contents
.
files
(
)
[
0
]
.
entryName
(
)
)
;
}
{
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
{
rootId
subSubFile
.
entryId
(
)
}
)
)
;
ASSERT_EQ
(
2u
entryPath
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
entryPath
[
0
]
)
;
ASSERT_STREQ
(
firstChildDescendantMeta
.
childName
(
)
entryPath
[
1
]
)
;
}
{
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
{
rootId
subSubDir
.
entryId
(
)
}
)
)
;
ASSERT_EQ
(
2u
entryPath
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
entryPath
[
0
]
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
1
]
)
;
}
{
TEST_TRY_UNWRAP
(
Path
entryPath
dm
-
>
Resolve
(
{
rootId
newFile
}
)
)
;
ASSERT_EQ
(
3u
entryPath
.
Length
(
)
)
;
ASSERT_STREQ
(
firstChildMeta
.
childName
(
)
entryPath
[
0
]
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
1
]
)
;
ASSERT_STREQ
(
testFileMeta
.
childName
(
)
entryPath
[
2
]
)
;
}
{
TEST_TRY_UNWRAP_ERR
(
nsresult
rv
dm
-
>
GetOrCreateFile
(
{
rootId
testFileMeta
.
childName
(
)
}
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateFile
(
{
rootId
firstChildDescendantMeta
.
childName
(
)
}
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateDirectory
(
{
rootId
testFileMeta
.
childName
(
)
}
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateDirectory
(
{
rootId
firstChildDescendantMeta
.
childName
(
)
}
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateFile
(
{
firstChildDir
testFileMeta
.
childName
(
)
}
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_TYPE_MISMATCH_ERR
rv
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateDirectory
(
{
firstChildDir
firstChildDescendantMeta
.
childName
(
)
}
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_TYPE_MISMATCH_ERR
rv
)
;
TEST_TRY_UNWRAP_ERR
(
rv
dm
-
>
GetOrCreateFile
(
{
testFile
newFileMeta
.
childName
(
)
}
false
)
)
;
ASSERT_NSEQ
(
NS_ERROR_DOM_NOT_FOUND_ERR
rv
)
;
}
}
}
