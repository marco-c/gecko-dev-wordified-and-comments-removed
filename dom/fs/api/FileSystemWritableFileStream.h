#
ifndef
DOM_FS_FILESYSTEMWRITABLEFILESTREAM_H_
#
define
DOM_FS_FILESYSTEMWRITABLEFILESTREAM_H_
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
dom
/
FlippedOnce
.
h
"
#
include
"
mozilla
/
dom
/
PFileSystemManager
.
h
"
#
include
"
mozilla
/
dom
/
WritableStream
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
ForwardDecls
.
h
"
class
nsIGlobalObject
;
class
nsIRandomAccessStream
;
namespace
mozilla
{
template
<
typename
T
>
class
Buffer
;
class
ErrorResult
;
class
TaskQueue
;
namespace
ipc
{
class
RandomAccessStreamParams
;
}
namespace
dom
{
class
ArrayBufferViewOrArrayBufferOrBlobOrUTF8StringOrWriteParams
;
class
Blob
;
class
FileSystemManager
;
class
FileSystemWritableFileStreamChild
;
class
OwningArrayBufferViewOrArrayBufferOrBlobOrUSVString
;
class
Promise
;
class
StrongWorkerRef
;
namespace
fs
{
class
FileSystemThreadSafeStreamOwner
;
}
class
FileSystemWritableFileStream
final
:
public
WritableStream
{
public
:
using
CreatePromise
=
MozPromise
<
already_AddRefed
<
FileSystemWritableFileStream
>
nsresult
true
>
;
using
WriteDataPromise
=
MozPromise
<
Maybe
<
int64_t
>
CopyableErrorResult
true
>
;
static
RefPtr
<
CreatePromise
>
Create
(
const
nsCOMPtr
<
nsIGlobalObject
>
&
aGlobal
RefPtr
<
FileSystemManager
>
&
aManager
RefPtr
<
FileSystemWritableFileStreamChild
>
aActor
mozilla
:
:
ipc
:
:
RandomAccessStreamParams
&
&
aStreamParams
fs
:
:
FileSystemEntryMetadata
&
&
aMetadata
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
FileSystemWritableFileStream
WritableStream
)
void
LastRelease
(
)
override
;
void
ClearActor
(
)
;
class
Command
;
RefPtr
<
Command
>
CreateCommand
(
)
;
bool
IsCommandActive
(
)
const
;
bool
IsOpen
(
)
const
;
bool
IsFinishing
(
)
const
;
bool
IsDone
(
)
const
;
[
[
nodiscard
]
]
RefPtr
<
BoolPromise
>
BeginAbort
(
)
;
[
[
nodiscard
]
]
RefPtr
<
BoolPromise
>
BeginClose
(
)
;
[
[
nodiscard
]
]
RefPtr
<
BoolPromise
>
OnDone
(
)
;
void
SetWorkerRef
(
RefPtr
<
StrongWorkerRef
>
&
&
aWorkerRef
)
;
already_AddRefed
<
Promise
>
Write
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aError
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
Write
(
const
ArrayBufferViewOrArrayBufferOrBlobOrUTF8StringOrWriteParams
&
aData
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
Seek
(
uint64_t
aPosition
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
already_AddRefed
<
Promise
>
Truncate
(
uint64_t
aSize
ErrorResult
&
aError
)
;
private
:
class
CloseHandler
;
FileSystemWritableFileStream
(
const
nsCOMPtr
<
nsIGlobalObject
>
&
aGlobal
RefPtr
<
FileSystemManager
>
&
aManager
RefPtr
<
FileSystemWritableFileStreamChild
>
aActor
already_AddRefed
<
TaskQueue
>
aTaskQueue
nsCOMPtr
<
nsIRandomAccessStream
>
aStream
fs
:
:
FileSystemEntryMetadata
&
&
aMetadata
)
;
virtual
~
FileSystemWritableFileStream
(
)
;
[
[
nodiscard
]
]
RefPtr
<
BoolPromise
>
BeginFinishing
(
bool
aShouldAbort
)
;
RefPtr
<
WriteDataPromise
>
Write
(
ArrayBufferViewOrArrayBufferOrBlobOrUTF8StringOrWriteParams
&
aData
)
;
template
<
typename
T
>
RefPtr
<
Int64Promise
>
Write
(
const
T
&
aData
const
Maybe
<
uint64_t
>
aPosition
)
;
RefPtr
<
BoolPromise
>
Seek
(
uint64_t
aPosition
)
;
RefPtr
<
BoolPromise
>
Truncate
(
uint64_t
aSize
)
;
void
NoteFinishedCommand
(
)
;
[
[
nodiscard
]
]
RefPtr
<
BoolPromise
>
Finish
(
)
;
RefPtr
<
FileSystemManager
>
mManager
;
RefPtr
<
FileSystemWritableFileStreamChild
>
mActor
;
RefPtr
<
TaskQueue
>
mTaskQueue
;
RefPtr
<
fs
:
:
FileSystemThreadSafeStreamOwner
>
mStreamOwner
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
fs
:
:
FileSystemEntryMetadata
mMetadata
;
RefPtr
<
CloseHandler
>
mCloseHandler
;
MozPromiseHolder
<
BoolPromise
>
mFinishPromiseHolder
;
bool
mCommandActive
;
}
;
}
}
#
endif
