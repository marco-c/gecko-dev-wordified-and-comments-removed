#
include
"
fs
/
FileSystemRequestHandler
.
h
"
#
include
"
fs
/
FileSystemConstants
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
mozilla
/
dom
/
BackgroundFileSystemChild
.
h
"
#
include
"
mozilla
/
dom
/
OriginPrivateFileSystemChild
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemFileHandle
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemDirectoryHandle
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
namespace
mozilla
:
:
dom
:
:
fs
{
using
mozilla
:
:
ipc
:
:
RejectCallback
;
namespace
{
RefPtr
<
mozilla
:
:
dom
:
:
BackgroundFileSystemChild
>
GetRootProvider
(
nsIGlobalObject
*
aGlobal
)
{
using
mozilla
:
:
dom
:
:
BackgroundFileSystemChild
;
using
mozilla
:
:
ipc
:
:
BackgroundChild
;
using
mozilla
:
:
ipc
:
:
PBackgroundChild
;
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
backgroundActor
)
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
RefPtr
<
BackgroundFileSystemChild
>
result
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
sop
=
do_QueryInterface
(
aGlobal
)
;
if
(
!
sop
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
sop
-
>
GetEffectiveStoragePrincipal
(
)
;
if
(
!
principal
)
{
return
nullptr
;
}
auto
principalInfo
=
MakeUnique
<
PrincipalInfo
>
(
)
;
nsresult
rv
=
PrincipalToPrincipalInfo
(
principal
principalInfo
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
auto
*
actor
=
new
BackgroundFileSystemChild
(
)
;
result
=
static_cast
<
BackgroundFileSystemChild
*
>
(
backgroundActor
-
>
SendPBackgroundFileSystemConstructor
(
actor
*
principalInfo
)
)
;
}
else
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
if
(
!
workerPrivate
)
{
return
nullptr
;
}
const
PrincipalInfo
&
principalInfo
=
workerPrivate
-
>
GetEffectiveStoragePrincipalInfo
(
)
;
BackgroundFileSystemChild
*
actor
=
new
BackgroundFileSystemChild
(
)
;
result
=
static_cast
<
BackgroundFileSystemChild
*
>
(
backgroundActor
-
>
SendPBackgroundFileSystemConstructor
(
actor
principalInfo
)
)
;
}
MOZ_ASSERT
(
result
)
;
return
result
;
}
RefPtr
<
File
>
MakeGetFileResult
(
nsIGlobalObject
*
aGlobal
const
nsString
&
aName
const
nsString
&
aType
int64_t
aLastModifiedMilliSeconds
nsTArray
<
Name
>
&
&
aPath
IPCBlob
&
&
RefPtr
<
FileSystemActorHolder
>
&
aActor
)
{
RefPtr
<
File
>
result
=
File
:
:
CreateMemoryFileWithCustomLastModified
(
aGlobal
static_cast
<
void
*
>
(
new
uint8_t
[
1
]
)
sizeof
(
uint8_t
)
aName
aType
aLastModifiedMilliSeconds
)
;
return
result
;
}
void
GetDirectoryContentsResponseHandler
(
nsIGlobalObject
*
aGlobal
FileSystemDirectoryListing
&
&
aResponse
ArrayAppendable
&
RefPtr
<
FileSystemActorHolder
>
&
aActor
)
{
nsTArray
<
RefPtr
<
FileSystemHandle
>
>
batch
;
for
(
const
auto
&
it
:
aResponse
.
files
(
)
)
{
RefPtr
<
FileSystemHandle
>
handle
=
new
FileSystemFileHandle
(
aGlobal
aActor
it
)
;
batch
.
AppendElement
(
handle
)
;
}
for
(
const
auto
&
it
:
aResponse
.
directories
(
)
)
{
RefPtr
<
FileSystemHandle
>
handle
=
new
FileSystemDirectoryHandle
(
aGlobal
aActor
it
)
;
batch
.
AppendElement
(
handle
)
;
}
}
RefPtr
<
FileSystemDirectoryHandle
>
MakeResolution
(
nsIGlobalObject
*
aGlobal
FileSystemGetRootResponse
&
&
aResponse
const
RefPtr
<
FileSystemDirectoryHandle
>
&
const
Name
&
aName
RefPtr
<
FileSystemActorHolder
>
&
aActor
)
{
RefPtr
<
FileSystemDirectoryHandle
>
result
=
new
FileSystemDirectoryHandle
(
aGlobal
aActor
FileSystemEntryMetadata
(
aResponse
.
get_EntryId
(
)
aName
)
)
;
return
result
;
}
RefPtr
<
FileSystemDirectoryHandle
>
MakeResolution
(
nsIGlobalObject
*
aGlobal
FileSystemGetHandleResponse
&
&
aResponse
const
RefPtr
<
FileSystemDirectoryHandle
>
&
const
Name
&
aName
RefPtr
<
FileSystemActorHolder
>
&
aActor
)
{
RefPtr
<
FileSystemDirectoryHandle
>
result
=
new
FileSystemDirectoryHandle
(
aGlobal
aActor
FileSystemEntryMetadata
(
aResponse
.
get_EntryId
(
)
aName
)
)
;
return
result
;
}
RefPtr
<
FileSystemFileHandle
>
MakeResolution
(
nsIGlobalObject
*
aGlobal
FileSystemGetHandleResponse
&
&
aResponse
const
RefPtr
<
FileSystemFileHandle
>
&
const
Name
&
aName
RefPtr
<
FileSystemActorHolder
>
&
aActor
)
{
RefPtr
<
FileSystemFileHandle
>
result
=
new
FileSystemFileHandle
(
aGlobal
aActor
FileSystemEntryMetadata
(
aResponse
.
get_EntryId
(
)
aName
)
)
;
return
result
;
}
RefPtr
<
File
>
MakeResolution
(
nsIGlobalObject
*
aGlobal
FileSystemGetFileResponse
&
&
aResponse
const
RefPtr
<
File
>
&
const
Name
&
aName
RefPtr
<
FileSystemActorHolder
>
&
aActor
)
{
auto
&
fileProperties
=
aResponse
.
get_FileSystemFileProperties
(
)
;
return
MakeGetFileResult
(
aGlobal
aName
fileProperties
.
type
(
)
fileProperties
.
last_modified_ms
(
)
std
:
:
move
(
fileProperties
.
path
(
)
)
std
:
:
move
(
fileProperties
.
file
(
)
)
aActor
)
;
}
template
<
class
TResponse
class
.
.
.
Args
>
void
ResolveCallback
(
TResponse
&
&
aResponse
RefPtr
<
Promise
>
aPromise
Args
&
&
.
.
.
args
)
{
MOZ_ASSERT
(
aPromise
)
;
QM_TRY
(
OkIf
(
Promise
:
:
PromiseState
:
:
Pending
=
=
aPromise
-
>
State
(
)
)
QM_VOID
)
;
if
(
TResponse
:
:
Tnsresult
=
=
aResponse
.
type
(
)
)
{
aPromise
-
>
MaybeReject
(
aResponse
.
get_nsresult
(
)
)
;
return
;
}
aPromise
-
>
MaybeResolve
(
MakeResolution
(
aPromise
-
>
GetParentObject
(
)
std
:
:
forward
<
TResponse
>
(
aResponse
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
>
void
ResolveCallback
(
FileSystemRemoveEntryResponse
&
&
aResponse
RefPtr
<
Promise
>
aPromise
)
{
MOZ_ASSERT
(
aPromise
)
;
QM_TRY
(
OkIf
(
Promise
:
:
PromiseState
:
:
Pending
=
=
aPromise
-
>
State
(
)
)
QM_VOID
)
;
MOZ_ASSERT
(
FileSystemRemoveEntryResponse
:
:
Tnsresult
=
=
aResponse
.
type
(
)
)
;
const
auto
&
status
=
aResponse
.
get_nsresult
(
)
;
if
(
NS_ERROR_FILE_ACCESS_DENIED
=
=
status
)
{
aPromise
-
>
MaybeRejectWithNotAllowedError
(
"
Permission
denied
"
)
;
}
else
if
(
NS_ERROR_DOM_FILESYSTEM_NO_MODIFICATION_ALLOWED_ERR
=
=
status
)
{
aPromise
-
>
MaybeRejectWithInvalidModificationError
(
"
Disallowed
by
system
"
)
;
}
else
if
(
NS_FAILED
(
status
)
)
{
aPromise
-
>
MaybeRejectWithUnknownError
(
"
Unknown
failure
"
)
;
}
else
{
aPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
}
template
<
>
void
ResolveCallback
(
FileSystemGetEntriesResponse
&
&
aResponse
RefPtr
<
Promise
>
aPromise
ArrayAppendable
&
aSink
RefPtr
<
FileSystemActorHolder
>
&
aActor
)
{
MOZ_ASSERT
(
aPromise
)
;
QM_TRY
(
OkIf
(
Promise
:
:
PromiseState
:
:
Pending
=
=
aPromise
-
>
State
(
)
)
QM_VOID
)
;
if
(
FileSystemGetEntriesResponse
:
:
Tnsresult
=
=
aResponse
.
type
(
)
)
{
aPromise
-
>
MaybeReject
(
aResponse
.
get_nsresult
(
)
)
;
return
;
}
GetDirectoryContentsResponseHandler
(
aPromise
-
>
GetParentObject
(
)
std
:
:
forward
<
FileSystemDirectoryListing
>
(
aResponse
.
get_FileSystemDirectoryListing
(
)
)
aSink
aActor
)
;
aPromise
-
>
MaybeReject
(
NS_ERROR_NOT_IMPLEMENTED
)
;
}
template
<
class
TResponse
class
TReturns
class
.
.
.
Args
std
:
:
enable_if_t
<
std
:
:
is_same
<
TReturns
void
>
:
:
value
bool
>
=
true
>
mozilla
:
:
ipc
:
:
ResolveCallback
<
TResponse
>
SelectResolveCallback
(
RefPtr
<
Promise
>
aPromise
Args
&
&
.
.
.
args
)
{
using
TOverload
=
void
(
*
)
(
TResponse
&
&
RefPtr
<
Promise
>
Args
.
.
.
)
;
return
static_cast
<
std
:
:
function
<
void
(
TResponse
&
&
)
>
>
(
std
:
:
bind
(
static_cast
<
TOverload
>
(
ResolveCallback
)
std
:
:
placeholders
:
:
_1
aPromise
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
template
<
class
TResponse
class
TReturns
class
.
.
.
Args
std
:
:
enable_if_t
<
!
std
:
:
is_same
<
TReturns
void
>
:
:
value
bool
>
=
true
>
mozilla
:
:
ipc
:
:
ResolveCallback
<
TResponse
>
SelectResolveCallback
(
RefPtr
<
Promise
>
aPromise
Args
&
&
.
.
.
args
)
{
using
TOverload
=
void
(
*
)
(
TResponse
&
&
RefPtr
<
Promise
>
const
TReturns
&
Args
.
.
.
)
;
return
static_cast
<
std
:
:
function
<
void
(
TResponse
&
&
)
>
>
(
std
:
:
bind
(
static_cast
<
TOverload
>
(
ResolveCallback
)
std
:
:
placeholders
:
:
_1
aPromise
TReturns
(
)
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
;
}
void
IPCRejectReporter
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
switch
(
aReason
)
{
case
mozilla
:
:
ipc
:
:
ResponseRejectReason
:
:
ActorDestroyed
:
break
;
case
mozilla
:
:
ipc
:
:
ResponseRejectReason
:
:
HandlerRejected
:
QM_TRY
(
OkIf
(
false
)
QM_VOID
)
;
break
;
case
mozilla
:
:
ipc
:
:
ResponseRejectReason
:
:
ChannelClosed
:
QM_TRY
(
OkIf
(
false
)
QM_VOID
)
;
break
;
case
mozilla
:
:
ipc
:
:
ResponseRejectReason
:
:
ResolverDestroyed
:
QM_TRY
(
OkIf
(
false
)
QM_VOID
)
;
break
;
case
mozilla
:
:
ipc
:
:
ResponseRejectReason
:
:
SendError
:
QM_TRY
(
OkIf
(
false
)
QM_VOID
)
;
break
;
default
:
QM_TRY
(
OkIf
(
false
)
QM_VOID
)
;
break
;
}
}
void
RejectHandler
(
RefPtr
<
Promise
>
aPromise
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
IPCRejectReporter
(
aReason
)
;
QM_TRY
(
OkIf
(
Promise
:
:
PromiseState
:
:
Pending
=
=
aPromise
-
>
State
(
)
)
QM_VOID
)
;
aPromise
-
>
MaybeRejectWithUndefined
(
)
;
}
mozilla
:
:
ipc
:
:
RejectCallback
GetRejectCallback
(
RefPtr
<
Promise
>
aPromise
)
{
return
static_cast
<
mozilla
:
:
ipc
:
:
RejectCallback
>
(
std
:
:
bind
(
RejectHandler
aPromise
std
:
:
placeholders
:
:
_1
)
)
;
}
}
void
FileSystemRequestHandler
:
:
GetRoot
(
RefPtr
<
Promise
>
aPromise
)
{
using
mozilla
:
:
ipc
:
:
Endpoint
;
MOZ_ASSERT
(
aPromise
)
;
Endpoint
<
POriginPrivateFileSystemParent
>
parentEp
;
Endpoint
<
POriginPrivateFileSystemChild
>
childEp
;
MOZ_ALWAYS_SUCCEEDS
(
POriginPrivateFileSystem
:
:
CreateEndpoints
(
&
parentEp
&
childEp
)
)
;
RefPtr
<
FileSystemActorHolder
>
actor
=
MakeAndAddRef
<
FileSystemActorHolder
>
(
new
OriginPrivateFileSystemChild
(
)
)
;
if
(
!
childEp
.
Bind
(
actor
-
>
Actor
(
)
)
)
{
aPromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
auto
&
&
onResolve
=
SelectResolveCallback
<
FileSystemGetRootResponse
RefPtr
<
FileSystemDirectoryHandle
>
>
(
aPromise
kRootName
actor
)
;
auto
&
&
onReject
=
GetRejectCallback
(
aPromise
)
;
RefPtr
<
mozilla
:
:
dom
:
:
BackgroundFileSystemChild
>
rootProvider
=
GetRootProvider
(
aPromise
-
>
GetGlobalObject
(
)
)
;
if
(
!
rootProvider
)
{
aPromise
-
>
MaybeRejectWithUnknownError
(
"
Could
not
access
the
file
system
"
)
;
return
;
}
rootProvider
-
>
SendGetRoot
(
std
:
:
move
(
parentEp
)
std
:
:
move
(
onResolve
)
std
:
:
move
(
onReject
)
)
;
}
void
FileSystemRequestHandler
:
:
GetDirectoryHandle
(
RefPtr
<
FileSystemActorHolder
>
&
aActor
const
FileSystemChildMetadata
&
aDirectory
bool
aCreate
RefPtr
<
Promise
>
aPromise
)
{
MOZ_ASSERT
(
!
aDirectory
.
parentId
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aPromise
)
;
FileSystemGetHandleRequest
request
(
aDirectory
aCreate
)
;
auto
&
&
onResolve
=
SelectResolveCallback
<
FileSystemGetHandleResponse
RefPtr
<
FileSystemDirectoryHandle
>
>
(
aPromise
aDirectory
.
childName
(
)
aActor
)
;
auto
&
&
onReject
=
GetRejectCallback
(
aPromise
)
;
QM_TRY
(
OkIf
(
aActor
)
QM_VOID
)
;
aActor
-
>
Actor
(
)
-
>
SendGetDirectoryHandle
(
request
std
:
:
move
(
onResolve
)
std
:
:
move
(
onReject
)
)
;
}
void
FileSystemRequestHandler
:
:
GetFileHandle
(
RefPtr
<
FileSystemActorHolder
>
&
aActor
const
FileSystemChildMetadata
&
aFile
bool
aCreate
RefPtr
<
Promise
>
aPromise
)
{
MOZ_ASSERT
(
!
aFile
.
parentId
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aPromise
)
;
FileSystemGetHandleRequest
request
(
aFile
aCreate
)
;
auto
&
&
onResolve
=
SelectResolveCallback
<
FileSystemGetHandleResponse
RefPtr
<
FileSystemFileHandle
>
>
(
aPromise
aFile
.
childName
(
)
aActor
)
;
auto
&
&
onReject
=
GetRejectCallback
(
aPromise
)
;
QM_TRY
(
OkIf
(
aActor
)
QM_VOID
)
;
aActor
-
>
Actor
(
)
-
>
SendGetFileHandle
(
request
std
:
:
move
(
onResolve
)
std
:
:
move
(
onReject
)
)
;
}
void
FileSystemRequestHandler
:
:
GetFile
(
RefPtr
<
FileSystemActorHolder
>
&
aActor
const
FileSystemEntryMetadata
&
aFile
RefPtr
<
Promise
>
aPromise
)
{
MOZ_ASSERT
(
!
aFile
.
entryId
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aPromise
)
;
FileSystemGetFileRequest
request
(
aFile
.
entryId
(
)
)
;
auto
&
&
onResolve
=
SelectResolveCallback
<
FileSystemGetFileResponse
RefPtr
<
File
>
>
(
aPromise
aFile
.
entryName
(
)
aActor
)
;
auto
&
&
onReject
=
GetRejectCallback
(
aPromise
)
;
QM_TRY
(
OkIf
(
aActor
)
QM_VOID
)
;
aActor
-
>
Actor
(
)
-
>
SendGetFile
(
request
std
:
:
move
(
onResolve
)
std
:
:
move
(
onReject
)
)
;
}
void
FileSystemRequestHandler
:
:
GetEntries
(
RefPtr
<
FileSystemActorHolder
>
&
aActor
const
EntryId
&
aDirectory
PageNumber
aPage
RefPtr
<
Promise
>
aPromise
ArrayAppendable
&
aSink
)
{
MOZ_ASSERT
(
!
aDirectory
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aPromise
)
;
FileSystemGetEntriesRequest
request
(
aDirectory
aPage
)
;
using
TOverload
=
void
(
*
)
(
FileSystemGetEntriesResponse
&
&
RefPtr
<
Promise
>
ArrayAppendable
&
RefPtr
<
FileSystemActorHolder
>
&
)
;
auto
&
&
onResolve
=
static_cast
<
std
:
:
function
<
void
(
FileSystemGetEntriesResponse
&
&
)
>
>
(
std
:
:
bind
(
static_cast
<
TOverload
>
(
ResolveCallback
)
std
:
:
placeholders
:
:
_1
aPromise
std
:
:
ref
(
aSink
)
aActor
)
)
;
auto
&
&
onReject
=
GetRejectCallback
(
aPromise
)
;
QM_TRY
(
OkIf
(
aActor
)
QM_VOID
)
;
aActor
-
>
Actor
(
)
-
>
SendGetEntries
(
request
std
:
:
move
(
onResolve
)
std
:
:
move
(
onReject
)
)
;
}
void
FileSystemRequestHandler
:
:
RemoveEntry
(
RefPtr
<
FileSystemActorHolder
>
&
aActor
const
FileSystemChildMetadata
&
aEntry
bool
aRecursive
RefPtr
<
Promise
>
aPromise
)
{
MOZ_ASSERT
(
!
aEntry
.
parentId
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aPromise
)
;
FileSystemRemoveEntryRequest
request
(
aEntry
aRecursive
)
;
auto
&
&
onResolve
=
SelectResolveCallback
<
FileSystemRemoveEntryResponse
void
>
(
aPromise
)
;
auto
&
&
onReject
=
GetRejectCallback
(
aPromise
)
;
QM_TRY
(
OkIf
(
aActor
)
QM_VOID
)
;
aActor
-
>
Actor
(
)
-
>
SendRemoveEntry
(
request
std
:
:
move
(
onResolve
)
std
:
:
move
(
onReject
)
)
;
}
}
