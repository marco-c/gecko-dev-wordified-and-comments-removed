#
ifndef
nsBindingManager_h_
#
define
nsBindingManager_h_
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
MediaFeatureChange
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
struct
ElementDependentRuleProcessorData
;
class
nsIXPConnectWrappedJS
;
class
nsAtom
;
class
nsIDOMNodeList
;
class
nsIDocument
;
class
nsIURI
;
class
nsXBLDocumentInfo
;
class
nsIStreamListener
;
class
nsXBLBinding
;
typedef
nsTArray
<
RefPtr
<
nsXBLBinding
>
>
nsBindingList
;
class
nsIPrincipal
;
class
nsITimer
;
class
nsBindingManager
final
:
public
nsStubMutationObserver
{
~
nsBindingManager
(
)
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
explicit
nsBindingManager
(
nsIDocument
*
aDocument
)
;
nsXBLBinding
*
GetBindingWithContent
(
const
nsIContent
*
aContent
)
;
void
AddBoundContent
(
nsIContent
*
aContent
)
;
void
RemoveBoundContent
(
nsIContent
*
aContent
)
;
enum
DestructorHandling
{
eRunDtor
eDoNotRunDtor
}
;
void
RemovedFromDocument
(
nsIContent
*
aContent
nsIDocument
*
aOldDocument
DestructorHandling
aDestructorHandling
)
{
if
(
aContent
-
>
HasFlag
(
NODE_MAY_BE_IN_BINDING_MNGR
)
)
{
RemovedFromDocumentInternal
(
aContent
aOldDocument
aDestructorHandling
)
;
}
}
void
RemovedFromDocumentInternal
(
nsIContent
*
aContent
nsIDocument
*
aOldDocument
DestructorHandling
aDestructorHandling
)
;
nsAtom
*
ResolveTag
(
nsIContent
*
aContent
int32_t
*
aNameSpaceID
)
;
nsresult
GetAnonymousNodesFor
(
nsIContent
*
aContent
nsIDOMNodeList
*
*
aResult
)
;
nsINodeList
*
GetAnonymousNodesFor
(
nsIContent
*
aContent
)
;
nsresult
ClearBinding
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
nsresult
LoadBindingDocument
(
nsIDocument
*
aBoundDoc
nsIURI
*
aURL
nsIPrincipal
*
aOriginPrincipal
)
;
nsresult
AddToAttachedQueue
(
nsXBLBinding
*
aBinding
)
;
void
RemoveFromAttachedQueue
(
nsXBLBinding
*
aBinding
)
;
void
ProcessAttachedQueue
(
uint32_t
aSkipSize
=
0
)
{
if
(
mProcessingAttachedStack
|
|
mAttachedStack
.
Length
(
)
<
=
aSkipSize
)
{
return
;
}
ProcessAttachedQueueInternal
(
aSkipSize
)
;
}
private
:
void
ProcessAttachedQueueInternal
(
uint32_t
aSkipSize
)
;
public
:
void
ExecuteDetachedHandlers
(
)
;
nsresult
PutXBLDocumentInfo
(
nsXBLDocumentInfo
*
aDocumentInfo
)
;
nsXBLDocumentInfo
*
GetXBLDocumentInfo
(
nsIURI
*
aURI
)
;
void
RemoveXBLDocumentInfo
(
nsXBLDocumentInfo
*
aDocumentInfo
)
;
nsresult
PutLoadingDocListener
(
nsIURI
*
aURL
nsIStreamListener
*
aListener
)
;
nsIStreamListener
*
GetLoadingDocListener
(
nsIURI
*
aURL
)
;
void
RemoveLoadingDocListener
(
nsIURI
*
aURL
)
;
void
FlushSkinBindings
(
)
;
nsresult
GetBindingImplementation
(
nsIContent
*
aContent
REFNSIID
aIID
void
*
*
aResult
)
;
#
ifdef
MOZ_OLD_STYLE
nsresult
WalkRules
(
nsIStyleRuleProcessor
:
:
EnumFunc
aFunc
ElementDependentRuleProcessorData
*
aData
bool
*
aCutOffInheritance
)
;
void
WalkAllRules
(
nsIStyleRuleProcessor
:
:
EnumFunc
aFunc
ElementDependentRuleProcessorData
*
aData
)
;
#
endif
bool
MediumFeaturesChanged
(
nsPresContext
*
aPresContext
mozilla
:
:
MediaFeatureChangeReason
)
;
void
UpdateBoundContentBindingsForServo
(
nsPresContext
*
aPresContext
)
;
void
AppendAllSheets
(
nsTArray
<
mozilla
:
:
StyleSheet
*
>
&
aArray
)
;
void
Traverse
(
nsIContent
*
aContent
nsCycleCollectionTraversalCallback
&
cb
)
;
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsBindingManager
)
void
BeginOutermostUpdate
(
)
{
mAttachedStackSizeOnOutermost
=
mAttachedStack
.
Length
(
)
;
}
void
EndOutermostUpdate
(
)
{
if
(
!
mProcessingAttachedStack
)
{
ProcessAttachedQueue
(
mAttachedStackSizeOnOutermost
)
;
mAttachedStackSizeOnOutermost
=
0
;
}
}
void
ClearInsertionPointsRecursively
(
nsIContent
*
aContent
)
;
void
DropDocumentReference
(
)
;
nsIContent
*
FindNestedSingleInsertionPoint
(
nsIContent
*
aContainer
bool
*
aMulti
)
;
using
BoundContentBindingCallback
=
std
:
:
function
<
bool
(
nsXBLBinding
*
)
>
;
bool
EnumerateBoundContentBindings
(
const
BoundContentBindingCallback
&
aCallback
)
const
;
protected
:
nsIXPConnectWrappedJS
*
GetWrappedJS
(
nsIContent
*
aContent
)
;
nsresult
SetWrappedJS
(
nsIContent
*
aContent
nsIXPConnectWrappedJS
*
aResult
)
;
void
HandleChildInsertion
(
nsIContent
*
aContainer
nsIContent
*
aChild
bool
aAppend
)
;
void
DoProcessAttachedQueue
(
)
;
void
PostProcessAttachedQueueEvent
(
)
;
static
void
PostPAQEventCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
nsAutoPtr
<
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
>
mBoundContentSet
;
typedef
nsInterfaceHashtable
<
nsISupportsHashKey
nsIXPConnectWrappedJS
>
WrapperHashtable
;
nsAutoPtr
<
WrapperHashtable
>
mWrapperTable
;
nsAutoPtr
<
nsRefPtrHashtable
<
nsURIHashKey
nsXBLDocumentInfo
>
>
mDocumentTable
;
nsAutoPtr
<
nsInterfaceHashtable
<
nsURIHashKey
nsIStreamListener
>
>
mLoadingDocTable
;
nsBindingList
mAttachedStack
;
bool
mProcessingAttachedStack
;
bool
mDestroyed
;
uint32_t
mAttachedStackSizeOnOutermost
;
friend
class
nsRunnableMethod
<
nsBindingManager
>
;
RefPtr
<
nsRunnableMethod
<
nsBindingManager
>
>
mProcessAttachedQueueEvent
;
nsIDocument
*
mDocument
;
}
;
#
endif
