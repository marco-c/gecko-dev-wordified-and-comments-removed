#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsXBLService
.
h
"
#
include
"
nsXBLWindowKeyHandler
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsString
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIXMLContentSink
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
mozilla
/
dom
/
XMLDocument
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIMemory
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIDOMNodeList
.
h
"
#
include
"
nsXBLContentSink
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsXBLDocumentInfo
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsSyncLoadService
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsXBLSerialize
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPrototypeCache
.
h
"
#
endif
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoRestyleManager
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
NS_MAX_XBL_BINDING_RECURSION
20
nsXBLService
*
nsXBLService
:
:
gInstance
=
nullptr
;
static
bool
IsAncestorBinding
(
nsIDocument
*
aDocument
nsIURI
*
aChildBindingURI
nsIContent
*
aChild
)
{
NS_ASSERTION
(
aDocument
"
expected
a
document
"
)
;
NS_ASSERTION
(
aChildBindingURI
"
expected
a
binding
URI
"
)
;
NS_ASSERTION
(
aChild
"
expected
a
child
content
"
)
;
uint32_t
bindingRecursion
=
0
;
for
(
nsIContent
*
bindingParent
=
aChild
-
>
GetBindingParent
(
)
;
bindingParent
;
bindingParent
=
bindingParent
-
>
GetBindingParent
(
)
)
{
nsXBLBinding
*
binding
=
bindingParent
-
>
GetXBLBinding
(
)
;
if
(
!
binding
)
{
continue
;
}
if
(
binding
-
>
PrototypeBinding
(
)
-
>
CompareBindingURI
(
aChildBindingURI
)
)
{
+
+
bindingRecursion
;
if
(
bindingRecursion
<
NS_MAX_XBL_BINDING_RECURSION
)
{
continue
;
}
NS_ConvertUTF8toUTF16
bindingURI
(
aChildBindingURI
-
>
GetSpecOrDefault
(
)
)
;
const
char16_t
*
params
[
]
=
{
bindingURI
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
XBL
"
)
aDocument
nsContentUtils
:
:
eXBL_PROPERTIES
"
TooDeepBindingRecursion
"
params
ArrayLength
(
params
)
)
;
return
true
;
}
}
return
false
;
}
class
nsXBLBindingRequest
{
public
:
nsCOMPtr
<
nsIURI
>
mBindingURI
;
nsCOMPtr
<
nsIContent
>
mBoundElement
;
void
DocumentLoaded
(
nsIDocument
*
aBindingDoc
)
{
nsIDocument
*
doc
=
mBoundElement
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
return
;
bool
ready
=
false
;
nsXBLService
:
:
GetInstance
(
)
-
>
BindingReady
(
mBoundElement
mBindingURI
&
ready
)
;
if
(
!
ready
)
return
;
if
(
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
)
{
shell
-
>
DestroyFramesForAndRestyle
(
mBoundElement
-
>
AsElement
(
)
)
;
}
MOZ_ASSERT
(
!
mBoundElement
-
>
GetPrimaryFrame
(
)
)
;
}
nsXBLBindingRequest
(
nsIURI
*
aURI
nsIContent
*
aBoundElement
)
:
mBindingURI
(
aURI
)
mBoundElement
(
aBoundElement
)
{
}
}
;
class
nsXBLStreamListener
final
:
public
nsIStreamListener
public
nsIDOMEventListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSIDOMEVENTLISTENER
nsXBLStreamListener
(
nsIDocument
*
aBoundDocument
nsIXMLContentSink
*
aSink
nsIDocument
*
aBindingDocument
)
;
void
AddRequest
(
nsXBLBindingRequest
*
aRequest
)
{
mBindingRequests
.
AppendElement
(
aRequest
)
;
}
bool
HasRequest
(
nsIURI
*
aURI
nsIContent
*
aBoundElement
)
;
private
:
~
nsXBLStreamListener
(
)
;
nsCOMPtr
<
nsIStreamListener
>
mInner
;
AutoTArray
<
nsXBLBindingRequest
*
8
>
mBindingRequests
;
nsCOMPtr
<
nsIWeakReference
>
mBoundDocument
;
nsCOMPtr
<
nsIXMLContentSink
>
mSink
;
nsCOMPtr
<
nsIDocument
>
mBindingDocument
;
}
;
NS_IMPL_ISUPPORTS
(
nsXBLStreamListener
nsIStreamListener
nsIRequestObserver
nsIDOMEventListener
)
nsXBLStreamListener
:
:
nsXBLStreamListener
(
nsIDocument
*
aBoundDocument
nsIXMLContentSink
*
aSink
nsIDocument
*
aBindingDocument
)
:
mSink
(
aSink
)
mBindingDocument
(
aBindingDocument
)
{
mBoundDocument
=
do_GetWeakReference
(
aBoundDocument
)
;
}
nsXBLStreamListener
:
:
~
nsXBLStreamListener
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mBindingRequests
.
Length
(
)
;
i
+
+
)
{
nsXBLBindingRequest
*
req
=
mBindingRequests
.
ElementAt
(
i
)
;
delete
req
;
}
}
NS_IMETHODIMP
nsXBLStreamListener
:
:
OnDataAvailable
(
nsIRequest
*
request
nsISupports
*
aCtxt
nsIInputStream
*
aInStr
uint64_t
aSourceOffset
uint32_t
aCount
)
{
if
(
mInner
)
return
mInner
-
>
OnDataAvailable
(
request
aCtxt
aInStr
aSourceOffset
aCount
)
;
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsXBLStreamListener
:
:
OnStartRequest
(
nsIRequest
*
request
nsISupports
*
aCtxt
)
{
nsCOMPtr
<
nsIXMLContentSink
>
sink
;
mSink
.
swap
(
sink
)
;
nsCOMPtr
<
nsIDocument
>
doc
;
mBindingDocument
.
swap
(
doc
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
request
)
;
NS_ENSURE_TRUE
(
channel
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsILoadGroup
>
group
;
request
-
>
GetLoadGroup
(
getter_AddRefs
(
group
)
)
;
nsresult
rv
=
doc
-
>
StartDocumentLoad
(
"
loadAsInteractiveData
"
channel
group
nullptr
getter_AddRefs
(
mInner
)
true
sink
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
doc
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
load
"
)
this
false
)
;
return
mInner
-
>
OnStartRequest
(
request
aCtxt
)
;
}
NS_IMETHODIMP
nsXBLStreamListener
:
:
OnStopRequest
(
nsIRequest
*
request
nsISupports
*
aCtxt
nsresult
aStatus
)
{
nsresult
rv
=
NS_OK
;
if
(
mInner
)
{
rv
=
mInner
-
>
OnStopRequest
(
request
aCtxt
aStatus
)
;
}
mInner
=
nullptr
;
return
rv
;
}
bool
nsXBLStreamListener
:
:
HasRequest
(
nsIURI
*
aURI
nsIContent
*
aElt
)
{
uint32_t
count
=
mBindingRequests
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
nsXBLBindingRequest
*
req
=
mBindingRequests
.
ElementAt
(
i
)
;
bool
eq
;
if
(
req
-
>
mBoundElement
=
=
aElt
&
&
NS_SUCCEEDED
(
req
-
>
mBindingURI
-
>
Equals
(
aURI
&
eq
)
)
&
&
eq
)
return
true
;
}
return
false
;
}
nsresult
nsXBLStreamListener
:
:
HandleEvent
(
nsIDOMEvent
*
aEvent
)
{
nsresult
rv
=
NS_OK
;
uint32_t
i
;
uint32_t
count
=
mBindingRequests
.
Length
(
)
;
Event
*
event
=
aEvent
-
>
InternalDOMEvent
(
)
;
EventTarget
*
target
=
event
-
>
GetCurrentTarget
(
)
;
nsCOMPtr
<
nsIDocument
>
bindingDocument
=
do_QueryInterface
(
target
)
;
NS_ASSERTION
(
bindingDocument
"
Event
not
targeted
at
document
?
!
"
)
;
nsCOMPtr
<
nsIDocument
>
doc
(
do_QueryReferent
(
mBoundDocument
)
)
;
if
(
!
doc
)
{
NS_WARNING
(
"
XBL
load
did
not
complete
until
after
document
went
away
!
Modal
dialog
bug
?
\
n
"
)
;
}
else
{
if
(
count
>
0
)
{
nsXBLBindingRequest
*
req
=
mBindingRequests
.
ElementAt
(
0
)
;
nsIDocument
*
document
=
req
-
>
mBoundElement
-
>
GetUncomposedDoc
(
)
;
if
(
document
)
document
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
}
nsBindingManager
*
bindingManager
=
doc
-
>
BindingManager
(
)
;
nsIURI
*
documentURI
=
bindingDocument
-
>
GetDocumentURI
(
)
;
bindingManager
-
>
RemoveLoadingDocListener
(
documentURI
)
;
if
(
!
bindingDocument
-
>
GetRootElement
(
)
)
{
NS_WARNING
(
"
XBL
doc
with
no
root
element
-
this
usually
shouldn
'
t
happen
"
)
;
return
NS_ERROR_FAILURE
;
}
nsBindingManager
*
xblDocBindingManager
=
bindingDocument
-
>
BindingManager
(
)
;
RefPtr
<
nsXBLDocumentInfo
>
info
=
xblDocBindingManager
-
>
GetXBLDocumentInfo
(
documentURI
)
;
xblDocBindingManager
-
>
RemoveXBLDocumentInfo
(
info
)
;
if
(
!
info
)
{
if
(
nsXBLService
:
:
IsChromeOrResourceURI
(
documentURI
)
)
{
NS_WARNING
(
"
An
XBL
file
is
malformed
.
Did
you
forget
the
XBL
namespace
on
the
bindings
tag
?
"
)
;
}
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
XBL
"
)
nullptr
nsContentUtils
:
:
eXBL_PROPERTIES
"
MalformedXBL
"
nullptr
0
documentURI
)
;
return
NS_ERROR_FAILURE
;
}
#
ifdef
MOZ_XUL
if
(
nsXBLService
:
:
IsChromeOrResourceURI
(
documentURI
)
)
{
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
if
(
cache
&
&
cache
-
>
IsEnabled
(
)
)
cache
-
>
PutXBLDocumentInfo
(
info
)
;
}
#
endif
bindingManager
-
>
PutXBLDocumentInfo
(
info
)
;
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
nsXBLBindingRequest
*
req
=
mBindingRequests
.
ElementAt
(
i
)
;
req
-
>
DocumentLoaded
(
bindingDocument
)
;
}
}
target
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
load
"
)
this
false
)
;
return
rv
;
}
NS_IMPL_ISUPPORTS
(
nsXBLService
nsISupportsWeakReference
)
void
nsXBLService
:
:
Init
(
)
{
gInstance
=
new
nsXBLService
(
)
;
NS_ADDREF
(
gInstance
)
;
}
nsXBLService
:
:
nsXBLService
(
void
)
{
}
nsXBLService
:
:
~
nsXBLService
(
void
)
{
}
bool
nsXBLService
:
:
IsChromeOrResourceURI
(
nsIURI
*
aURI
)
{
bool
isChrome
=
false
;
bool
isResource
=
false
;
if
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
)
&
&
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
resource
"
&
isResource
)
)
)
return
(
isChrome
|
|
isResource
)
;
return
false
;
}
static
void
EnsureSubtreeStyled
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
HasServoData
(
)
)
{
return
;
}
if
(
Servo_Element_IsDisplayNone
(
aElement
)
)
{
return
;
}
nsIPresShell
*
presShell
=
aElement
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
!
presShell
|
|
!
presShell
-
>
DidInitialize
(
)
)
{
return
;
}
ServoStyleSet
*
servoSet
=
presShell
-
>
StyleSet
(
)
;
StyleChildrenIterator
iter
(
aElement
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
if
(
!
child
-
>
IsElement
(
)
)
{
continue
;
}
if
(
child
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
{
return
;
}
servoSet
-
>
StyleNewSubtree
(
child
-
>
AsElement
(
)
)
;
}
}
class
MOZ_RAII
AutoEnsureSubtreeStyled
{
public
:
explicit
AutoEnsureSubtreeStyled
(
Element
*
aElement
)
:
mElement
(
aElement
)
{
}
~
AutoEnsureSubtreeStyled
(
)
{
EnsureSubtreeStyled
(
mElement
)
;
}
private
:
Element
*
mElement
;
}
;
class
MOZ_RAII
AutoStyleElement
{
public
:
AutoStyleElement
(
Element
*
aElement
bool
*
aResolveStyle
)
:
mElement
(
aElement
)
mHadData
(
aElement
-
>
HasServoData
(
)
)
mResolveStyle
(
aResolveStyle
)
{
MOZ_ASSERT
(
mResolveStyle
)
;
if
(
mHadData
)
{
ServoRestyleManager
:
:
ClearServoDataFromSubtree
(
mElement
ServoRestyleManager
:
:
IncludeRoot
:
:
No
)
;
}
}
~
AutoStyleElement
(
)
{
nsIPresShell
*
presShell
=
mElement
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
!
mHadData
|
|
!
presShell
|
|
!
presShell
-
>
DidInitialize
(
)
)
{
return
;
}
if
(
*
mResolveStyle
)
{
mElement
-
>
ClearServoData
(
)
;
ServoStyleSet
*
servoSet
=
presShell
-
>
StyleSet
(
)
;
servoSet
-
>
StyleNewSubtree
(
mElement
)
;
}
}
private
:
Element
*
mElement
;
bool
mHadData
;
bool
*
mResolveStyle
;
}
;
nsresult
nsXBLService
:
:
LoadBindings
(
Element
*
aElement
nsIURI
*
aURL
nsIPrincipal
*
aOriginPrincipal
nsXBLBinding
*
*
aBinding
bool
*
aResolveStyle
)
{
NS_PRECONDITION
(
aOriginPrincipal
"
Must
have
an
origin
principal
"
)
;
*
aBinding
=
nullptr
;
*
aResolveStyle
=
false
;
AutoEnsureSubtreeStyled
subtreeStyled
(
aElement
)
;
if
(
MOZ_UNLIKELY
(
!
aURL
)
)
{
return
NS_OK
;
}
nsXBLBinding
*
binding
=
aElement
-
>
GetXBLBinding
(
)
;
if
(
binding
&
&
!
binding
-
>
MarkedForDeath
(
)
&
&
binding
-
>
PrototypeBinding
(
)
-
>
CompareBindingURI
(
aURL
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
document
=
aElement
-
>
OwnerDoc
(
)
;
nsAutoCString
urlspec
;
nsresult
rv
;
bool
ok
=
nsContentUtils
:
:
GetWrapperSafeScriptFilename
(
document
aURL
urlspec
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
ok
)
{
return
NS_OK
;
}
if
(
binding
)
{
FlushStyleBindings
(
aElement
)
;
binding
=
nullptr
;
}
bool
ready
;
RefPtr
<
nsXBLBinding
>
newBinding
;
if
(
NS_FAILED
(
rv
=
GetBinding
(
aElement
aURL
false
aOriginPrincipal
&
ready
getter_AddRefs
(
newBinding
)
)
)
)
{
return
rv
;
}
if
(
!
newBinding
)
{
#
ifdef
DEBUG
nsAutoCString
str
(
NS_LITERAL_CSTRING
(
"
Failed
to
locate
XBL
binding
.
XBL
is
now
using
id
instead
of
name
to
reference
bindings
.
Make
sure
you
have
switched
over
.
The
invalid
binding
name
is
:
"
)
+
aURL
-
>
GetSpecOrDefault
(
)
)
;
NS_ERROR
(
str
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
if
(
:
:
IsAncestorBinding
(
document
aURL
aElement
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
AutoStyleElement
styleElement
(
aElement
aResolveStyle
)
;
aElement
-
>
SetXBLBinding
(
newBinding
)
;
{
nsAutoScriptBlocker
scriptBlocker
;
newBinding
-
>
SetBoundElement
(
aElement
)
;
newBinding
-
>
GenerateAnonymousContent
(
)
;
newBinding
-
>
InstallEventHandlers
(
)
;
rv
=
newBinding
-
>
InstallImplementation
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aResolveStyle
=
newBinding
-
>
HasStyleSheets
(
)
;
newBinding
.
forget
(
aBinding
)
;
}
return
NS_OK
;
}
void
nsXBLService
:
:
FlushStyleBindings
(
Element
*
aElement
)
{
nsCOMPtr
<
nsIDocument
>
document
=
aElement
-
>
OwnerDoc
(
)
;
nsXBLBinding
*
binding
=
aElement
-
>
GetXBLBinding
(
)
;
if
(
binding
)
{
binding
-
>
ChangeDocument
(
document
nullptr
)
;
aElement
-
>
SetXBLBinding
(
nullptr
)
;
}
}
nsresult
nsXBLService
:
:
AttachGlobalKeyHandler
(
EventTarget
*
aTarget
)
{
nsCOMPtr
<
EventTarget
>
piTarget
=
aTarget
;
nsCOMPtr
<
nsIContent
>
contentNode
(
do_QueryInterface
(
aTarget
)
)
;
if
(
contentNode
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
contentNode
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
piTarget
=
doc
;
}
if
(
!
piTarget
)
return
NS_ERROR_FAILURE
;
EventListenerManager
*
manager
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
manager
)
return
NS_ERROR_FAILURE
;
if
(
contentNode
&
&
contentNode
-
>
GetProperty
(
nsGkAtoms
:
:
listener
)
)
return
NS_OK
;
nsCOMPtr
<
nsIDOMElement
>
elt
(
do_QueryInterface
(
contentNode
)
)
;
RefPtr
<
nsXBLWindowKeyHandler
>
handler
=
NS_NewXBLWindowKeyHandler
(
elt
piTarget
)
;
handler
-
>
InstallKeyboardEventListenersTo
(
manager
)
;
if
(
contentNode
)
return
contentNode
-
>
SetProperty
(
nsGkAtoms
:
:
listener
handler
.
forget
(
)
.
take
(
)
nsPropertyTable
:
:
SupportsDtorFunc
true
)
;
return
NS_OK
;
}
nsresult
nsXBLService
:
:
DetachGlobalKeyHandler
(
EventTarget
*
aTarget
)
{
nsCOMPtr
<
EventTarget
>
piTarget
=
aTarget
;
nsCOMPtr
<
nsIContent
>
contentNode
(
do_QueryInterface
(
aTarget
)
)
;
if
(
!
contentNode
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIDocument
>
doc
=
contentNode
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
piTarget
=
do_QueryInterface
(
doc
)
;
if
(
!
piTarget
)
return
NS_ERROR_FAILURE
;
EventListenerManager
*
manager
=
piTarget
-
>
GetOrCreateListenerManager
(
)
;
if
(
!
manager
)
return
NS_ERROR_FAILURE
;
nsIDOMEventListener
*
handler
=
static_cast
<
nsIDOMEventListener
*
>
(
contentNode
-
>
GetProperty
(
nsGkAtoms
:
:
listener
)
)
;
if
(
!
handler
)
return
NS_ERROR_FAILURE
;
static_cast
<
nsXBLWindowKeyHandler
*
>
(
handler
)
-
>
RemoveKeyboardEventListenersFrom
(
manager
)
;
contentNode
-
>
DeleteProperty
(
nsGkAtoms
:
:
listener
)
;
return
NS_OK
;
}
nsresult
nsXBLService
:
:
BindingReady
(
nsIContent
*
aBoundElement
nsIURI
*
aURI
bool
*
aIsReady
)
{
return
GetBinding
(
aBoundElement
aURI
true
nullptr
aIsReady
nullptr
)
;
}
nsresult
nsXBLService
:
:
GetBinding
(
nsIContent
*
aBoundElement
nsIURI
*
aURI
bool
aPeekOnly
nsIPrincipal
*
aOriginPrincipal
bool
*
aIsReady
nsXBLBinding
*
*
aResult
)
{
AutoTArray
<
nsCOMPtr
<
nsIURI
>
6
>
uris
;
return
GetBinding
(
aBoundElement
aURI
aPeekOnly
aOriginPrincipal
aIsReady
aResult
uris
)
;
}
static
bool
MayBindToContent
(
nsXBLPrototypeBinding
*
aProtoBinding
nsIContent
*
aBoundElement
nsIURI
*
aURI
)
{
if
(
aProtoBinding
-
>
BindToUntrustedContent
(
)
)
{
return
true
;
}
if
(
aBoundElement
-
>
IsXULElement
(
)
|
|
aBoundElement
-
>
OwnerDoc
(
)
-
>
IsXULElement
(
)
)
{
return
true
;
}
if
(
aBoundElement
-
>
IsInAnonymousSubtree
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIDocument
>
bindingDoc
=
aProtoBinding
-
>
XBLDocumentInfo
(
)
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
bindingDoc
false
)
;
if
(
aBoundElement
-
>
NodePrincipal
(
)
-
>
Subsumes
(
bindingDoc
-
>
NodePrincipal
(
)
)
)
{
return
true
;
}
if
(
nsContentUtils
:
:
AllowXULXBLForPrincipal
(
aBoundElement
-
>
NodePrincipal
(
)
)
)
{
bool
isDataURI
=
false
;
nsresult
rv
=
aURI
-
>
SchemeIs
(
"
data
"
&
isDataURI
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
isDataURI
)
{
return
true
;
}
}
return
false
;
}
nsresult
nsXBLService
:
:
GetBinding
(
nsIContent
*
aBoundElement
nsIURI
*
aURI
bool
aPeekOnly
nsIPrincipal
*
aOriginPrincipal
bool
*
aIsReady
nsXBLBinding
*
*
aResult
nsTArray
<
nsCOMPtr
<
nsIURI
>
>
&
aDontExtendURIs
)
{
NS_ASSERTION
(
aPeekOnly
|
|
aResult
"
Must
have
non
-
null
out
param
if
not
just
peeking
to
see
"
"
whether
the
binding
is
ready
"
)
;
if
(
aResult
)
*
aResult
=
nullptr
;
if
(
!
aURI
)
return
NS_ERROR_FAILURE
;
nsAutoCString
ref
;
aURI
-
>
GetRef
(
ref
)
;
nsCOMPtr
<
nsIDocument
>
boundDocument
=
aBoundElement
-
>
OwnerDoc
(
)
;
RefPtr
<
nsXBLDocumentInfo
>
docInfo
;
nsresult
rv
=
LoadBindingDocumentInfo
(
aBoundElement
boundDocument
aURI
aOriginPrincipal
false
getter_AddRefs
(
docInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
docInfo
)
return
NS_ERROR_FAILURE
;
WeakPtr
<
nsXBLPrototypeBinding
>
protoBinding
=
docInfo
-
>
GetPrototypeBinding
(
ref
)
;
if
(
!
protoBinding
)
{
#
ifdef
DEBUG
nsAutoCString
message
(
"
Unable
to
locate
an
XBL
binding
for
URI
"
)
;
message
+
=
aURI
-
>
GetSpecOrDefault
(
)
;
message
+
=
"
in
document
"
;
message
+
=
boundDocument
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
NS_WARNING
(
message
.
get
(
)
)
;
#
endif
return
NS_ERROR_FAILURE
;
}
if
(
!
MayBindToContent
(
protoBinding
aBoundElement
aURI
)
)
{
#
ifdef
DEBUG
nsAutoCString
message
(
"
Permission
denied
to
apply
binding
"
)
;
message
+
=
aURI
-
>
GetSpecOrDefault
(
)
;
message
+
=
"
to
unprivileged
content
.
Set
bindToUntrustedContent
=
true
on
"
"
the
binding
to
override
this
restriction
.
"
;
NS_WARNING
(
message
.
get
(
)
)
;
#
endif
return
NS_ERROR_FAILURE
;
}
aDontExtendURIs
.
AppendElement
(
protoBinding
-
>
BindingURI
(
)
)
;
nsCOMPtr
<
nsIURI
>
altBindingURI
=
protoBinding
-
>
AlternateBindingURI
(
)
;
if
(
altBindingURI
)
{
aDontExtendURIs
.
AppendElement
(
altBindingURI
)
;
}
bool
ready
=
protoBinding
-
>
LoadResources
(
aBoundElement
)
;
if
(
!
ready
)
{
protoBinding
-
>
AddResourceListener
(
aBoundElement
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
protoBinding
-
>
ResolveBaseBinding
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
baseBindingURI
;
WeakPtr
<
nsXBLPrototypeBinding
>
baseProto
=
protoBinding
-
>
GetBasePrototype
(
)
;
if
(
baseProto
)
{
baseBindingURI
=
baseProto
-
>
BindingURI
(
)
;
}
else
{
baseBindingURI
=
protoBinding
-
>
GetBaseBindingURI
(
)
;
if
(
baseBindingURI
)
{
uint32_t
count
=
aDontExtendURIs
.
Length
(
)
;
for
(
uint32_t
index
=
0
;
index
<
count
;
+
+
index
)
{
bool
equal
;
rv
=
aDontExtendURIs
[
index
]
-
>
Equals
(
baseBindingURI
&
equal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
equal
)
{
NS_ConvertUTF8toUTF16
protoSpec
(
protoBinding
-
>
BindingURI
(
)
-
>
GetSpecOrDefault
(
)
)
;
NS_ConvertUTF8toUTF16
baseSpec
(
baseBindingURI
-
>
GetSpecOrDefault
(
)
)
;
const
char16_t
*
params
[
]
=
{
protoSpec
.
get
(
)
baseSpec
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
XBL
"
)
nullptr
nsContentUtils
:
:
eXBL_PROPERTIES
"
CircularExtendsBinding
"
params
ArrayLength
(
params
)
boundDocument
-
>
GetDocumentURI
(
)
)
;
return
NS_ERROR_ILLEGAL_VALUE
;
}
}
}
}
RefPtr
<
nsXBLBinding
>
baseBinding
;
if
(
baseBindingURI
)
{
nsCOMPtr
<
nsIContent
>
child
=
protoBinding
-
>
GetBindingElement
(
)
;
rv
=
GetBinding
(
aBoundElement
baseBindingURI
aPeekOnly
child
-
>
NodePrincipal
(
)
aIsReady
getter_AddRefs
(
baseBinding
)
aDontExtendURIs
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
*
aIsReady
=
true
;
if
(
!
aPeekOnly
)
{
NS_ENSURE_STATE
(
protoBinding
)
;
nsXBLBinding
*
newBinding
=
new
nsXBLBinding
(
protoBinding
)
;
if
(
baseBinding
)
{
if
(
!
baseProto
)
{
protoBinding
-
>
SetBasePrototype
(
baseBinding
-
>
PrototypeBinding
(
)
)
;
}
newBinding
-
>
SetBaseBinding
(
baseBinding
)
;
}
NS_ADDREF
(
*
aResult
=
newBinding
)
;
}
return
NS_OK
;
}
static
bool
IsSystemOrChromeURLPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aPrincipal
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
uri
;
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_TRUE
(
uri
false
)
;
bool
isChrome
=
false
;
return
NS_SUCCEEDED
(
uri
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
)
&
&
isChrome
;
}
nsresult
nsXBLService
:
:
LoadBindingDocumentInfo
(
nsIContent
*
aBoundElement
nsIDocument
*
aBoundDocument
nsIURI
*
aBindingURI
nsIPrincipal
*
aOriginPrincipal
bool
aForceSyncLoad
nsXBLDocumentInfo
*
*
aResult
)
{
NS_PRECONDITION
(
aBindingURI
"
Must
have
a
binding
URI
"
)
;
NS_PRECONDITION
(
!
aOriginPrincipal
|
|
aBoundDocument
"
If
we
'
re
doing
a
security
check
we
better
have
a
document
!
"
)
;
*
aResult
=
nullptr
;
if
(
aOriginPrincipal
&
&
!
IsSystemOrChromeURLPrincipal
(
aOriginPrincipal
)
)
{
NS_ENSURE_TRUE
(
!
aBoundDocument
|
|
aBoundDocument
-
>
AllowXULXBL
(
)
NS_ERROR_XBL_BLOCKED
)
;
}
RefPtr
<
nsXBLDocumentInfo
>
info
;
nsCOMPtr
<
nsIURI
>
documentURI
;
nsresult
rv
=
aBindingURI
-
>
CloneIgnoringRef
(
getter_AddRefs
(
documentURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsBindingManager
*
bindingManager
=
nullptr
;
if
(
aBoundDocument
)
{
bindingManager
=
aBoundDocument
-
>
BindingManager
(
)
;
info
=
bindingManager
-
>
GetXBLDocumentInfo
(
documentURI
)
;
if
(
aBoundDocument
-
>
IsStaticDocument
(
)
&
&
IsChromeOrResourceURI
(
aBindingURI
)
)
{
aForceSyncLoad
=
true
;
}
}
NodeInfo
*
ni
=
nullptr
;
if
(
aBoundElement
)
ni
=
aBoundElement
-
>
NodeInfo
(
)
;
if
(
!
info
&
&
bindingManager
&
&
(
!
ni
|
|
!
(
ni
-
>
Equals
(
nsGkAtoms
:
:
scrollbar
kNameSpaceID_XUL
)
|
|
ni
-
>
Equals
(
nsGkAtoms
:
:
thumb
kNameSpaceID_XUL
)
|
|
(
(
ni
-
>
Equals
(
nsGkAtoms
:
:
input
)
|
|
ni
-
>
Equals
(
nsGkAtoms
:
:
select
)
)
&
&
aBoundElement
-
>
IsHTMLElement
(
)
)
)
)
&
&
!
aForceSyncLoad
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
;
if
(
bindingManager
)
listener
=
bindingManager
-
>
GetLoadingDocListener
(
documentURI
)
;
if
(
listener
)
{
nsXBLStreamListener
*
xblListener
=
static_cast
<
nsXBLStreamListener
*
>
(
listener
.
get
(
)
)
;
if
(
!
xblListener
-
>
HasRequest
(
aBindingURI
aBoundElement
)
)
{
nsXBLBindingRequest
*
req
=
new
nsXBLBindingRequest
(
aBindingURI
aBoundElement
)
;
xblListener
-
>
AddRequest
(
req
)
;
}
return
NS_OK
;
}
}
#
ifdef
MOZ_XUL
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
bool
useXULCache
=
cache
&
&
cache
-
>
IsEnabled
(
)
;
if
(
!
info
&
&
useXULCache
)
{
info
=
cache
-
>
GetXBLDocumentInfo
(
documentURI
)
;
}
bool
useStartupCache
=
useXULCache
&
&
IsChromeOrResourceURI
(
documentURI
)
;
if
(
!
info
)
{
if
(
!
info
&
&
useStartupCache
)
{
rv
=
nsXBLDocumentInfo
:
:
ReadPrototypeBindings
(
documentURI
getter_AddRefs
(
info
)
aBoundDocument
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
cache
-
>
PutXBLDocumentInfo
(
info
)
;
}
}
}
#
endif
if
(
!
info
)
{
bool
chrome
;
if
(
NS_SUCCEEDED
(
documentURI
-
>
SchemeIs
(
"
chrome
"
&
chrome
)
)
&
&
chrome
)
aForceSyncLoad
=
true
;
nsCOMPtr
<
nsIDocument
>
document
;
rv
=
FetchBindingDocument
(
aBoundElement
aBoundDocument
documentURI
aBindingURI
aOriginPrincipal
aForceSyncLoad
getter_AddRefs
(
document
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
document
)
{
nsBindingManager
*
xblDocBindingManager
=
document
-
>
BindingManager
(
)
;
info
=
xblDocBindingManager
-
>
GetXBLDocumentInfo
(
documentURI
)
;
if
(
!
info
)
{
NS_ERROR
(
"
An
XBL
file
is
malformed
.
Did
you
forget
the
XBL
namespace
on
the
bindings
tag
?
"
)
;
return
NS_ERROR_FAILURE
;
}
xblDocBindingManager
-
>
RemoveXBLDocumentInfo
(
info
)
;
#
ifdef
MOZ_XUL
if
(
useStartupCache
)
{
cache
-
>
PutXBLDocumentInfo
(
info
)
;
info
-
>
WritePrototypeBindings
(
)
;
}
#
endif
}
}
if
(
info
&
&
bindingManager
)
{
bindingManager
-
>
PutXBLDocumentInfo
(
info
)
;
}
info
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
nsXBLService
:
:
FetchBindingDocument
(
nsIContent
*
aBoundElement
nsIDocument
*
aBoundDocument
nsIURI
*
aDocumentURI
nsIURI
*
aBindingURI
nsIPrincipal
*
aOriginPrincipal
bool
aForceSyncLoad
nsIDocument
*
*
aResult
)
{
nsresult
rv
=
NS_OK
;
*
aResult
=
nullptr
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
if
(
aBoundDocument
)
loadGroup
=
aBoundDocument
-
>
GetDocumentLoadGroup
(
)
;
if
(
IsChromeOrResourceURI
(
aDocumentURI
)
)
aForceSyncLoad
=
true
;
nsCOMPtr
<
nsIDocument
>
doc
;
rv
=
NS_NewXMLDocument
(
getter_AddRefs
(
doc
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
doc
-
>
ForceEnableXULXBL
(
)
;
nsCOMPtr
<
nsIXMLContentSink
>
xblSink
;
rv
=
NS_NewXBLContentSink
(
getter_AddRefs
(
xblSink
)
doc
aDocumentURI
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
if
(
aOriginPrincipal
)
{
MOZ_ASSERT
(
aBoundDocument
"
can
not
create
a
channel
without
aBoundDocument
"
)
;
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aDocumentURI
aBoundDocument
aOriginPrincipal
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
|
nsILoadInfo
:
:
SEC_ALLOW_CHROME
nsIContentPolicy
:
:
TYPE_XBL
nullptr
loadGroup
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aDocumentURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
nsIContentPolicy
:
:
TYPE_XBL
nullptr
loadGroup
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aForceSyncLoad
)
{
nsXBLStreamListener
*
xblListener
=
new
nsXBLStreamListener
(
aBoundDocument
xblSink
doc
)
;
nsBindingManager
*
bindingManager
;
if
(
aBoundDocument
)
bindingManager
=
aBoundDocument
-
>
BindingManager
(
)
;
else
bindingManager
=
nullptr
;
if
(
bindingManager
)
bindingManager
-
>
PutLoadingDocListener
(
aDocumentURI
xblListener
)
;
nsXBLBindingRequest
*
req
=
new
nsXBLBindingRequest
(
aBindingURI
aBoundElement
)
;
xblListener
-
>
AddRequest
(
req
)
;
rv
=
channel
-
>
AsyncOpen2
(
xblListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
bindingManager
)
{
bindingManager
-
>
RemoveLoadingDocListener
(
aDocumentURI
)
;
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsIStreamListener
>
listener
;
rv
=
doc
-
>
StartDocumentLoad
(
"
loadAsInteractiveData
"
channel
loadGroup
nullptr
getter_AddRefs
(
listener
)
true
xblSink
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIInputStream
>
in
;
rv
=
channel
-
>
Open2
(
getter_AddRefs
(
in
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsSyncLoadService
:
:
PushSyncStreamToListener
(
in
.
forget
(
)
listener
channel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
doc
.
swap
(
*
aResult
)
;
return
NS_OK
;
}
