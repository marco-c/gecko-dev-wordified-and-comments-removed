#
ifndef
nsXBLMaybeCompiled_h__
#
define
nsXBLMaybeCompiled_h__
#
include
"
js
/
RootingAPI
.
h
"
template
<
class
UncompiledT
>
class
nsXBLMaybeCompiled
{
public
:
nsXBLMaybeCompiled
(
)
:
mUncompiled
(
BIT_UNCOMPILED
)
{
}
explicit
nsXBLMaybeCompiled
(
UncompiledT
*
uncompiled
)
:
mUncompiled
(
reinterpret_cast
<
uintptr_t
>
(
uncompiled
)
|
BIT_UNCOMPILED
)
{
}
explicit
nsXBLMaybeCompiled
(
JSObject
*
compiled
)
:
mCompiled
(
compiled
)
{
}
bool
IsCompiled
(
)
const
{
return
!
(
mUncompiled
&
BIT_UNCOMPILED
)
;
}
UncompiledT
*
GetUncompiled
(
)
const
{
MOZ_ASSERT
(
!
IsCompiled
(
)
"
Attempt
to
get
compiled
function
as
uncompiled
"
)
;
uintptr_t
unmasked
=
mUncompiled
&
~
BIT_UNCOMPILED
;
return
reinterpret_cast
<
UncompiledT
*
>
(
unmasked
)
;
}
JSObject
*
GetJSFunction
(
)
const
{
MOZ_ASSERT
(
IsCompiled
(
)
"
Attempt
to
get
uncompiled
function
as
compiled
"
)
;
if
(
mCompiled
)
{
JS
:
:
ExposeObjectToActiveJS
(
mCompiled
)
;
}
return
mCompiled
;
}
JSObject
*
GetJSFunctionPreserveColor
(
)
const
{
MOZ_ASSERT
(
IsCompiled
(
)
"
Attempt
to
get
uncompiled
function
as
compiled
"
)
;
return
mCompiled
;
}
private
:
JSObject
*
&
UnsafeGetJSFunction
(
)
{
MOZ_ASSERT
(
IsCompiled
(
)
"
Attempt
to
get
uncompiled
function
as
compiled
"
)
;
return
mCompiled
;
}
enum
{
BIT_UNCOMPILED
=
1
<
<
0
}
;
union
{
uintptr_t
mUncompiled
;
JSObject
*
mCompiled
;
}
;
friend
struct
js
:
:
BarrierMethods
<
nsXBLMaybeCompiled
<
UncompiledT
>
>
;
}
;
namespace
js
{
template
<
class
UncompiledT
>
struct
BarrierMethods
<
nsXBLMaybeCompiled
<
UncompiledT
>
>
{
typedef
struct
BarrierMethods
<
JSObject
*
>
Base
;
static
void
postWriteBarrier
(
nsXBLMaybeCompiled
<
UncompiledT
>
*
functionp
nsXBLMaybeCompiled
<
UncompiledT
>
prev
nsXBLMaybeCompiled
<
UncompiledT
>
next
)
{
if
(
next
.
IsCompiled
(
)
)
{
Base
:
:
postWriteBarrier
(
&
functionp
-
>
UnsafeGetJSFunction
(
)
prev
.
IsCompiled
(
)
?
prev
.
UnsafeGetJSFunction
(
)
:
nullptr
next
.
UnsafeGetJSFunction
(
)
)
;
}
else
if
(
prev
.
IsCompiled
(
)
)
{
Base
:
:
postWriteBarrier
(
&
prev
.
UnsafeGetJSFunction
(
)
prev
.
UnsafeGetJSFunction
(
)
nullptr
)
;
}
}
static
void
exposeToJS
(
nsXBLMaybeCompiled
<
UncompiledT
>
fun
)
{
if
(
fun
.
IsCompiled
(
)
)
{
JS
:
:
ExposeObjectToActiveJS
(
fun
.
UnsafeGetJSFunction
(
)
)
;
}
}
}
;
template
<
class
T
>
struct
IsHeapConstructibleType
<
nsXBLMaybeCompiled
<
T
>
>
{
static
constexpr
bool
value
=
true
;
}
;
template
<
class
UncompiledT
class
Wrapper
>
class
HeapBase
<
nsXBLMaybeCompiled
<
UncompiledT
>
Wrapper
>
{
const
Wrapper
&
wrapper
(
)
const
{
return
*
static_cast
<
const
Wrapper
*
>
(
this
)
;
}
Wrapper
&
wrapper
(
)
{
return
*
static_cast
<
Wrapper
*
>
(
this
)
;
}
const
nsXBLMaybeCompiled
<
UncompiledT
>
*
extract
(
)
const
{
return
wrapper
(
)
.
address
(
)
;
}
nsXBLMaybeCompiled
<
UncompiledT
>
*
extract
(
)
{
return
wrapper
(
)
.
unsafeGet
(
)
;
}
public
:
bool
IsCompiled
(
)
const
{
return
extract
(
)
-
>
IsCompiled
(
)
;
}
UncompiledT
*
GetUncompiled
(
)
const
{
return
extract
(
)
-
>
GetUncompiled
(
)
;
}
JSObject
*
GetJSFunction
(
)
const
{
return
extract
(
)
-
>
GetJSFunction
(
)
;
}
JSObject
*
GetJSFunctionPreserveColor
(
)
const
{
return
extract
(
)
-
>
GetJSFunctionPreserveColor
(
)
;
}
void
SetUncompiled
(
UncompiledT
*
source
)
{
wrapper
(
)
=
nsXBLMaybeCompiled
<
UncompiledT
>
(
source
)
;
}
void
SetJSFunction
(
JSObject
*
function
)
{
wrapper
(
)
=
nsXBLMaybeCompiled
<
UncompiledT
>
(
function
)
;
}
JS
:
:
Heap
<
JSObject
*
>
&
AsHeapObject
(
)
{
MOZ_ASSERT
(
extract
(
)
-
>
IsCompiled
(
)
)
;
return
*
reinterpret_cast
<
JS
:
:
Heap
<
JSObject
*
>
*
>
(
this
)
;
}
}
;
}
#
endif
