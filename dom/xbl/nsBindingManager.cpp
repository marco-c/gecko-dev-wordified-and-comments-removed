#
include
"
nsBindingManager
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXBLService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsString
.
h
"
#
include
"
plstr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsIXMLContentSink
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
mozilla
/
dom
/
XMLDocument
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsXBLDocumentInfo
.
h
"
#
include
"
mozilla
/
dom
/
XBLChildrenElement
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPrototypeCache
.
h
"
#
endif
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
NodeListBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsBindingManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsBindingManager
)
tmp
-
>
mDestroyed
=
true
;
if
(
tmp
-
>
mBoundContentSet
)
tmp
-
>
mBoundContentSet
-
>
Clear
(
)
;
if
(
tmp
-
>
mDocumentTable
)
tmp
-
>
mDocumentTable
-
>
Clear
(
)
;
if
(
tmp
-
>
mLoadingDocTable
)
tmp
-
>
mLoadingDocTable
-
>
Clear
(
)
;
if
(
tmp
-
>
mWrapperTable
)
{
tmp
-
>
mWrapperTable
-
>
Clear
(
)
;
tmp
-
>
mWrapperTable
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAttachedStack
)
if
(
tmp
-
>
mProcessAttachedQueueEvent
)
{
tmp
-
>
mProcessAttachedQueueEvent
-
>
Revoke
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsBindingManager
)
if
(
tmp
-
>
mDocumentTable
)
{
for
(
auto
iter
=
tmp
-
>
mDocumentTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mDocumentTable
value
"
)
;
cb
.
NoteXPCOMChild
(
iter
.
UserData
(
)
)
;
}
}
if
(
tmp
-
>
mLoadingDocTable
)
{
for
(
auto
iter
=
tmp
-
>
mLoadingDocTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mLoadingDocTable
value
"
)
;
cb
.
NoteXPCOMChild
(
iter
.
UserData
(
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAttachedStack
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsBindingManager
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsBindingManager
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsBindingManager
)
nsBindingManager
:
:
nsBindingManager
(
nsIDocument
*
aDocument
)
:
mProcessingAttachedStack
(
false
)
mDestroyed
(
false
)
mAttachedStackSizeOnOutermost
(
0
)
mDocument
(
aDocument
)
{
}
nsBindingManager
:
:
~
nsBindingManager
(
void
)
{
mDestroyed
=
true
;
}
nsXBLBinding
*
nsBindingManager
:
:
GetBindingWithContent
(
const
nsIContent
*
aContent
)
{
nsXBLBinding
*
binding
=
aContent
?
aContent
-
>
GetXBLBinding
(
)
:
nullptr
;
return
binding
?
binding
-
>
GetBindingWithContent
(
)
:
nullptr
;
}
void
nsBindingManager
:
:
AddBoundContent
(
nsIContent
*
aContent
)
{
if
(
!
mBoundContentSet
)
{
mBoundContentSet
=
new
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
;
}
mBoundContentSet
-
>
PutEntry
(
aContent
)
;
}
void
nsBindingManager
:
:
RemoveBoundContent
(
nsIContent
*
aContent
)
{
if
(
mBoundContentSet
)
{
mBoundContentSet
-
>
RemoveEntry
(
aContent
)
;
}
SetWrappedJS
(
aContent
nullptr
)
;
}
nsIXPConnectWrappedJS
*
nsBindingManager
:
:
GetWrappedJS
(
nsIContent
*
aContent
)
{
if
(
!
mWrapperTable
)
{
return
nullptr
;
}
if
(
!
aContent
|
|
!
aContent
-
>
HasFlag
(
NODE_MAY_BE_IN_BINDING_MNGR
)
)
{
return
nullptr
;
}
return
mWrapperTable
-
>
GetWeak
(
aContent
)
;
}
nsresult
nsBindingManager
:
:
SetWrappedJS
(
nsIContent
*
aContent
nsIXPConnectWrappedJS
*
aWrappedJS
)
{
if
(
mDestroyed
)
{
return
NS_OK
;
}
if
(
aWrappedJS
)
{
if
(
!
mWrapperTable
)
{
mWrapperTable
=
new
WrapperHashtable
(
)
;
}
aContent
-
>
SetFlags
(
NODE_MAY_BE_IN_BINDING_MNGR
)
;
NS_ASSERTION
(
aContent
"
key
must
be
non
-
null
"
)
;
if
(
!
aContent
)
return
NS_ERROR_INVALID_ARG
;
mWrapperTable
-
>
Put
(
aContent
aWrappedJS
)
;
return
NS_OK
;
}
if
(
mWrapperTable
)
{
mWrapperTable
-
>
Remove
(
aContent
)
;
}
return
NS_OK
;
}
void
nsBindingManager
:
:
RemovedFromDocumentInternal
(
nsIContent
*
aContent
nsIDocument
*
aOldDocument
DestructorHandling
aDestructorHandling
)
{
MOZ_ASSERT
(
aOldDocument
!
=
nullptr
"
no
old
document
"
)
;
RefPtr
<
nsXBLBinding
>
binding
=
aContent
-
>
GetXBLBinding
(
)
;
if
(
binding
)
{
if
(
!
mDestroyed
&
&
aDestructorHandling
=
=
eRunDtor
)
{
binding
-
>
PrototypeBinding
(
)
-
>
BindingDetached
(
binding
-
>
GetBoundElement
(
)
)
;
binding
-
>
ChangeDocument
(
aOldDocument
nullptr
)
;
}
aContent
-
>
AsElement
(
)
-
>
SetXBLBinding
(
nullptr
this
)
;
}
aContent
-
>
SetXBLInsertionPoint
(
nullptr
)
;
}
nsAtom
*
nsBindingManager
:
:
ResolveTag
(
nsIContent
*
aContent
int32_t
*
aNameSpaceID
)
{
nsXBLBinding
*
binding
=
aContent
-
>
GetXBLBinding
(
)
;
if
(
binding
)
{
nsAtom
*
base
=
binding
-
>
GetBaseTag
(
aNameSpaceID
)
;
if
(
base
)
{
return
base
;
}
}
*
aNameSpaceID
=
aContent
-
>
GetNameSpaceID
(
)
;
return
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
nsINodeList
*
nsBindingManager
:
:
GetAnonymousNodesFor
(
nsIContent
*
aContent
)
{
nsXBLBinding
*
binding
=
GetBindingWithContent
(
aContent
)
;
return
binding
?
binding
-
>
GetAnonymousNodeList
(
)
:
nullptr
;
}
nsresult
nsBindingManager
:
:
ClearBinding
(
Element
*
aElement
)
{
RefPtr
<
nsXBLBinding
>
binding
=
aElement
?
aElement
-
>
GetXBLBinding
(
)
:
nullptr
;
if
(
!
binding
)
{
return
NS_OK
;
}
NS_ENSURE_FALSE
(
binding
-
>
GetBaseBinding
(
)
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
aElement
-
>
OwnerDoc
(
)
;
nsIPresShell
*
presShell
=
doc
-
>
GetShell
(
)
;
if
(
presShell
)
{
presShell
-
>
DestroyFramesForAndRestyle
(
aElement
)
;
}
binding
-
>
UnhookEventHandlers
(
)
;
binding
-
>
ChangeDocument
(
doc
nullptr
)
;
aElement
-
>
SetXBLBinding
(
nullptr
this
)
;
binding
-
>
MarkForDeath
(
)
;
presShell
=
doc
-
>
GetShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
presShell
-
>
PostRecreateFramesFor
(
aElement
)
;
return
NS_OK
;
}
nsresult
nsBindingManager
:
:
LoadBindingDocument
(
nsIDocument
*
aBoundDoc
nsIURI
*
aURL
nsIPrincipal
*
aOriginPrincipal
)
{
MOZ_ASSERT
(
aURL
"
Must
have
a
URI
to
load
!
"
)
;
nsXBLService
*
xblService
=
nsXBLService
:
:
GetInstance
(
)
;
if
(
!
xblService
)
return
NS_ERROR_FAILURE
;
RefPtr
<
nsXBLDocumentInfo
>
info
;
xblService
-
>
LoadBindingDocumentInfo
(
nullptr
aBoundDoc
aURL
aOriginPrincipal
true
getter_AddRefs
(
info
)
)
;
if
(
!
info
)
return
NS_ERROR_FAILURE
;
return
NS_OK
;
}
void
nsBindingManager
:
:
RemoveFromAttachedQueue
(
nsXBLBinding
*
aBinding
)
{
size_t
index
=
mAttachedStack
.
IndexOf
(
aBinding
)
;
if
(
index
!
=
nsBindingList
:
:
NoIndex
)
{
mAttachedStack
[
index
]
=
nullptr
;
}
}
nsresult
nsBindingManager
:
:
AddToAttachedQueue
(
nsXBLBinding
*
aBinding
)
{
mAttachedStack
.
AppendElement
(
aBinding
)
;
if
(
!
mProcessingAttachedStack
&
&
!
mProcessAttachedQueueEvent
)
{
PostProcessAttachedQueueEvent
(
)
;
}
if
(
nsIPresShell
*
shell
=
mDocument
-
>
GetShell
(
)
)
{
shell
-
>
SetNeedStyleFlush
(
)
;
}
return
NS_OK
;
}
void
nsBindingManager
:
:
PostProcessAttachedQueueEvent
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mDocument
)
{
return
;
}
mProcessAttachedQueueEvent
=
NewRunnableMethod
(
"
nsBindingManager
:
:
DoProcessAttachedQueue
"
this
&
nsBindingManager
:
:
DoProcessAttachedQueue
)
;
nsresult
rv
=
mDocument
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
-
>
Dispatch
(
do_AddRef
(
mProcessAttachedQueueEvent
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mDocument
-
>
BlockOnload
(
)
;
}
}
void
nsBindingManager
:
:
PostPAQEventCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
nsBindingManager
>
mgr
=
already_AddRefed
<
nsBindingManager
>
(
static_cast
<
nsBindingManager
*
>
(
aClosure
)
)
;
mgr
-
>
PostProcessAttachedQueueEvent
(
)
;
NS_RELEASE
(
aTimer
)
;
}
void
nsBindingManager
:
:
DoProcessAttachedQueue
(
)
{
if
(
!
mProcessingAttachedStack
)
{
ProcessAttachedQueue
(
)
;
NS_ASSERTION
(
mAttachedStack
.
Length
(
)
=
=
0
"
Shouldn
'
t
have
pending
bindings
!
"
)
;
mProcessAttachedQueueEvent
=
nullptr
;
}
else
{
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsITimer
>
timer
;
rv
=
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
timer
)
PostPAQEventCallback
this
100
nsITimer
:
:
TYPE_ONE_SHOT
"
nsBindingManager
:
:
DoProcessAttachedQueue
"
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ADDREF_THIS
(
)
;
Unused
<
<
timer
.
forget
(
)
.
take
(
)
;
}
}
if
(
mDocument
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
mDocument
;
doc
-
>
UnblockOnload
(
true
)
;
}
}
void
nsBindingManager
:
:
ProcessAttachedQueueInternal
(
uint32_t
aSkipSize
)
{
mProcessingAttachedStack
=
true
;
while
(
mAttachedStack
.
Length
(
)
>
aSkipSize
)
{
uint32_t
lastItem
=
mAttachedStack
.
Length
(
)
-
1
;
RefPtr
<
nsXBLBinding
>
binding
=
mAttachedStack
.
ElementAt
(
lastItem
)
;
mAttachedStack
.
RemoveElementAt
(
lastItem
)
;
if
(
binding
)
{
binding
-
>
ExecuteAttachedHandler
(
)
;
}
}
if
(
mDocument
)
{
mProcessingAttachedStack
=
false
;
}
NS_ASSERTION
(
mAttachedStack
.
Length
(
)
=
=
aSkipSize
"
How
did
we
get
here
?
"
)
;
mAttachedStack
.
Compact
(
)
;
}
void
nsBindingManager
:
:
ExecuteDetachedHandlers
(
)
{
if
(
!
mBoundContentSet
)
{
return
;
}
nsCOMArray
<
nsIContent
>
boundElements
;
nsBindingList
bindings
;
for
(
auto
iter
=
mBoundContentSet
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsXBLBinding
*
binding
=
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetXBLBinding
(
)
;
if
(
binding
&
&
bindings
.
AppendElement
(
binding
)
)
{
if
(
!
boundElements
.
AppendObject
(
binding
-
>
GetBoundElement
(
)
)
)
{
bindings
.
RemoveLastElement
(
)
;
}
}
}
uint32_t
i
count
=
bindings
.
Length
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
bindings
[
i
]
-
>
ExecuteDetachedHandler
(
)
;
}
}
nsresult
nsBindingManager
:
:
PutXBLDocumentInfo
(
nsXBLDocumentInfo
*
aDocumentInfo
)
{
MOZ_ASSERT
(
aDocumentInfo
"
Must
have
a
non
-
null
documentinfo
!
"
)
;
if
(
!
mDocumentTable
)
{
mDocumentTable
=
new
nsRefPtrHashtable
<
nsURIHashKey
nsXBLDocumentInfo
>
(
)
;
}
mDocumentTable
-
>
Put
(
aDocumentInfo
-
>
DocumentURI
(
)
aDocumentInfo
)
;
return
NS_OK
;
}
void
nsBindingManager
:
:
RemoveXBLDocumentInfo
(
nsXBLDocumentInfo
*
aDocumentInfo
)
{
if
(
mDocumentTable
)
{
mDocumentTable
-
>
Remove
(
aDocumentInfo
-
>
DocumentURI
(
)
)
;
}
}
nsXBLDocumentInfo
*
nsBindingManager
:
:
GetXBLDocumentInfo
(
nsIURI
*
aURL
)
{
if
(
!
mDocumentTable
)
return
nullptr
;
return
mDocumentTable
-
>
GetWeak
(
aURL
)
;
}
nsresult
nsBindingManager
:
:
PutLoadingDocListener
(
nsIURI
*
aURL
nsIStreamListener
*
aListener
)
{
MOZ_ASSERT
(
aListener
"
Must
have
a
non
-
null
listener
!
"
)
;
if
(
!
mLoadingDocTable
)
{
mLoadingDocTable
=
new
nsInterfaceHashtable
<
nsURIHashKey
nsIStreamListener
>
(
)
;
}
mLoadingDocTable
-
>
Put
(
aURL
aListener
)
;
return
NS_OK
;
}
nsIStreamListener
*
nsBindingManager
:
:
GetLoadingDocListener
(
nsIURI
*
aURL
)
{
if
(
!
mLoadingDocTable
)
return
nullptr
;
return
mLoadingDocTable
-
>
GetWeak
(
aURL
)
;
}
void
nsBindingManager
:
:
RemoveLoadingDocListener
(
nsIURI
*
aURL
)
{
if
(
mLoadingDocTable
)
{
mLoadingDocTable
-
>
Remove
(
aURL
)
;
}
}
void
nsBindingManager
:
:
FlushSkinBindings
(
)
{
if
(
!
mBoundContentSet
)
{
return
;
}
for
(
auto
iter
=
mBoundContentSet
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsXBLBinding
*
binding
=
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetXBLBinding
(
)
;
if
(
binding
-
>
MarkedForDeath
(
)
)
{
continue
;
}
nsAutoCString
path
;
binding
-
>
PrototypeBinding
(
)
-
>
DocURI
(
)
-
>
GetPathQueryRef
(
path
)
;
if
(
!
strncmp
(
path
.
get
(
)
"
/
skin
"
5
)
)
{
binding
-
>
MarkForDeath
(
)
;
}
}
}
struct
AntiRecursionData
{
nsIContent
*
element
;
REFNSIID
iid
;
AntiRecursionData
*
next
;
AntiRecursionData
(
nsIContent
*
aElement
REFNSIID
aIID
AntiRecursionData
*
aNext
)
:
element
(
aElement
)
iid
(
aIID
)
next
(
aNext
)
{
}
}
;
nsresult
nsBindingManager
:
:
GetBindingImplementation
(
nsIContent
*
aContent
REFNSIID
aIID
void
*
*
aResult
)
{
*
aResult
=
nullptr
;
nsXBLBinding
*
binding
=
aContent
?
aContent
-
>
GetXBLBinding
(
)
:
nullptr
;
if
(
binding
)
{
NS_ASSERTION
(
!
aIID
.
Equals
(
NS_GET_IID
(
nsISupports
)
)
"
Asking
a
binding
for
nsISupports
"
)
;
if
(
binding
-
>
ImplementsInterface
(
aIID
)
)
{
nsCOMPtr
<
nsIXPConnectWrappedJS
>
wrappedJS
=
GetWrappedJS
(
aContent
)
;
if
(
wrappedJS
)
{
static
AntiRecursionData
*
list
=
nullptr
;
for
(
AntiRecursionData
*
p
=
list
;
p
;
p
=
p
-
>
next
)
{
if
(
p
-
>
element
=
=
aContent
&
&
p
-
>
iid
.
Equals
(
aIID
)
)
{
*
aResult
=
nullptr
;
return
NS_NOINTERFACE
;
}
}
AntiRecursionData
item
(
aContent
aIID
list
)
;
list
=
&
item
;
nsresult
rv
=
wrappedJS
-
>
AggregatedQueryInterface
(
aIID
aResult
)
;
list
=
item
.
next
;
if
(
*
aResult
)
return
rv
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
nsIXPConnect
*
xpConnect
=
nsContentUtils
:
:
XPConnect
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
jsobj
(
cx
aContent
-
>
GetWrapper
(
)
)
;
NS_ENSURE_TRUE
(
jsobj
NS_NOINTERFACE
)
;
JS
:
:
Rooted
<
JSObject
*
>
xblScope
(
cx
xpc
:
:
GetXBLScopeOrGlobal
(
cx
jsobj
)
)
;
NS_ENSURE_TRUE
(
xblScope
NS_ERROR_UNEXPECTED
)
;
JSAutoRealmAllowCCW
ar
(
cx
xblScope
)
;
bool
ok
=
JS_WrapObject
(
cx
&
jsobj
)
;
NS_ENSURE_TRUE
(
ok
NS_ERROR_OUT_OF_MEMORY
)
;
MOZ_ASSERT_IF
(
js
:
:
IsWrapper
(
jsobj
)
xpc
:
:
IsXrayWrapper
(
jsobj
)
)
;
nsresult
rv
=
xpConnect
-
>
WrapJSAggregatedToNative
(
aContent
cx
jsobj
aIID
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsISupports
*
supp
=
static_cast
<
nsISupports
*
>
(
*
aResult
)
;
wrappedJS
=
do_QueryInterface
(
supp
)
;
SetWrappedJS
(
aContent
wrappedJS
)
;
return
rv
;
}
}
*
aResult
=
nullptr
;
return
NS_NOINTERFACE
;
}
bool
nsBindingManager
:
:
EnumerateBoundContentProtoBindings
(
const
BoundContentProtoBindingCallback
&
aCallback
)
const
{
if
(
!
mBoundContentSet
)
{
return
true
;
}
nsTHashtable
<
nsPtrHashKey
<
nsXBLPrototypeBinding
>
>
bindings
;
for
(
auto
iter
=
mBoundContentSet
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsIContent
*
boundContent
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
for
(
nsXBLBinding
*
binding
=
boundContent
-
>
GetXBLBinding
(
)
;
binding
;
binding
=
binding
-
>
GetBaseBinding
(
)
)
{
nsXBLPrototypeBinding
*
proto
=
binding
-
>
PrototypeBinding
(
)
;
if
(
!
bindings
.
EnsureInserted
(
proto
)
)
{
break
;
}
if
(
!
aCallback
(
proto
)
)
{
return
false
;
}
}
}
return
true
;
}
void
nsBindingManager
:
:
AppendAllSheets
(
nsTArray
<
StyleSheet
*
>
&
aArray
)
{
EnumerateBoundContentProtoBindings
(
[
&
aArray
]
(
nsXBLPrototypeBinding
*
aProto
)
{
aProto
-
>
AppendStyleSheetsTo
(
aArray
)
;
return
true
;
}
)
;
}
static
void
InsertAppendedContent
(
XBLChildrenElement
*
aPoint
nsIContent
*
aFirstNewContent
)
{
int32_t
insertionIndex
;
if
(
nsIContent
*
prevSibling
=
aFirstNewContent
-
>
GetPreviousSibling
(
)
)
{
insertionIndex
=
aPoint
-
>
IndexOfInsertedChild
(
prevSibling
)
;
MOZ_ASSERT
(
insertionIndex
!
=
-
1
)
;
+
+
insertionIndex
;
}
else
{
insertionIndex
=
aPoint
-
>
InsertedChildrenLength
(
)
;
}
for
(
nsIContent
*
currentChild
=
aFirstNewContent
;
currentChild
;
currentChild
=
currentChild
-
>
GetNextSibling
(
)
)
{
aPoint
-
>
InsertInsertedChildAt
(
currentChild
insertionIndex
+
+
)
;
}
}
void
nsBindingManager
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
XBLChildrenElement
*
point
=
nullptr
;
nsIContent
*
container
=
aFirstNewContent
-
>
GetParent
(
)
;
nsIContent
*
parent
=
container
;
if
(
parent
&
&
parent
-
>
IsActiveChildrenElement
(
)
)
{
XBLChildrenElement
*
childrenEl
=
static_cast
<
XBLChildrenElement
*
>
(
parent
)
;
if
(
childrenEl
-
>
HasInsertedChildren
(
)
)
{
return
;
}
childrenEl
-
>
MaybeSetupDefaultContent
(
)
;
parent
=
childrenEl
-
>
GetParent
(
)
;
}
bool
first
=
true
;
do
{
nsXBLBinding
*
binding
=
GetBindingWithContent
(
parent
)
;
if
(
!
binding
)
{
break
;
}
if
(
binding
-
>
HasFilteredInsertionPoints
(
)
)
{
for
(
nsIContent
*
currentChild
=
aFirstNewContent
;
currentChild
;
currentChild
=
currentChild
-
>
GetNextSibling
(
)
)
{
HandleChildInsertion
(
container
currentChild
true
)
;
}
return
;
}
point
=
binding
-
>
GetDefaultInsertionPoint
(
)
;
if
(
!
point
)
{
break
;
}
if
(
first
)
{
first
=
false
;
for
(
nsIContent
*
child
=
aFirstNewContent
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
point
-
>
AppendInsertedChild
(
child
true
)
;
}
}
else
{
InsertAppendedContent
(
point
aFirstNewContent
)
;
}
nsIContent
*
newParent
=
point
-
>
GetParent
(
)
;
if
(
newParent
=
=
parent
)
{
break
;
}
parent
=
newParent
;
}
while
(
parent
)
;
}
void
nsBindingManager
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
HandleChildInsertion
(
aChild
-
>
GetParent
(
)
aChild
false
)
;
}
void
nsBindingManager
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
aChild
-
>
SetXBLInsertionPoint
(
nullptr
)
;
XBLChildrenElement
*
point
=
nullptr
;
nsIContent
*
parent
=
aChild
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsActiveChildrenElement
(
)
)
{
XBLChildrenElement
*
childrenEl
=
static_cast
<
XBLChildrenElement
*
>
(
parent
)
;
if
(
childrenEl
-
>
HasInsertedChildren
(
)
)
{
return
;
}
parent
=
childrenEl
-
>
GetParent
(
)
;
}
do
{
nsXBLBinding
*
binding
=
GetBindingWithContent
(
parent
)
;
if
(
!
binding
)
{
if
(
aChild
-
>
GetBindingParent
(
)
)
{
ClearInsertionPointsRecursively
(
aChild
)
;
}
return
;
}
point
=
binding
-
>
FindInsertionPointFor
(
aChild
)
;
if
(
!
point
)
{
break
;
}
point
-
>
RemoveInsertedChild
(
aChild
)
;
nsIContent
*
newParent
=
point
-
>
GetParent
(
)
;
if
(
newParent
=
=
parent
)
{
break
;
}
parent
=
newParent
;
}
while
(
parent
)
;
}
void
nsBindingManager
:
:
ClearInsertionPointsRecursively
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
children
kNameSpaceID_XBL
)
)
{
static_cast
<
XBLChildrenElement
*
>
(
aContent
)
-
>
ClearInsertedChildren
(
)
;
}
for
(
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
ClearInsertionPointsRecursively
(
child
)
;
}
}
void
nsBindingManager
:
:
DropDocumentReference
(
)
{
mDestroyed
=
true
;
mProcessingAttachedStack
=
true
;
if
(
mProcessAttachedQueueEvent
)
{
mProcessAttachedQueueEvent
-
>
Revoke
(
)
;
}
if
(
mBoundContentSet
)
{
mBoundContentSet
-
>
Clear
(
)
;
}
mDocument
=
nullptr
;
}
void
nsBindingManager
:
:
Traverse
(
nsIContent
*
aContent
nsCycleCollectionTraversalCallback
&
cb
)
{
if
(
!
aContent
-
>
HasFlag
(
NODE_MAY_BE_IN_BINDING_MNGR
)
|
|
!
aContent
-
>
IsElement
(
)
)
{
return
;
}
if
(
mBoundContentSet
&
&
mBoundContentSet
-
>
Contains
(
aContent
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
[
via
binding
manager
]
mBoundContentSet
entry
"
)
;
cb
.
NoteXPCOMChild
(
aContent
)
;
}
nsIXPConnectWrappedJS
*
value
=
GetWrappedJS
(
aContent
)
;
if
(
value
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
[
via
binding
manager
]
mWrapperTable
key
"
)
;
cb
.
NoteXPCOMChild
(
aContent
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
[
via
binding
manager
]
mWrapperTable
value
"
)
;
cb
.
NoteXPCOMChild
(
value
)
;
}
}
void
nsBindingManager
:
:
HandleChildInsertion
(
nsIContent
*
aContainer
nsIContent
*
aChild
bool
aAppend
)
{
MOZ_ASSERT
(
aChild
"
Must
have
child
"
)
;
XBLChildrenElement
*
point
=
nullptr
;
nsIContent
*
parent
=
aContainer
;
if
(
parent
&
&
parent
-
>
IsActiveChildrenElement
(
)
)
{
XBLChildrenElement
*
childrenEl
=
static_cast
<
XBLChildrenElement
*
>
(
parent
)
;
if
(
childrenEl
-
>
HasInsertedChildren
(
)
)
{
return
;
}
childrenEl
-
>
MaybeSetupDefaultContent
(
)
;
parent
=
childrenEl
-
>
GetParent
(
)
;
}
while
(
parent
)
{
nsXBLBinding
*
binding
=
GetBindingWithContent
(
parent
)
;
if
(
!
binding
)
{
break
;
}
point
=
binding
-
>
FindInsertionPointFor
(
aChild
)
;
if
(
!
point
)
{
break
;
}
uint32_t
index
=
aAppend
?
point
-
>
InsertedChildrenLength
(
)
:
0
;
for
(
nsIContent
*
currentSibling
=
aChild
-
>
GetPreviousSibling
(
)
;
currentSibling
;
currentSibling
=
currentSibling
-
>
GetPreviousSibling
(
)
)
{
int32_t
pointIndex
=
point
-
>
IndexOfInsertedChild
(
currentSibling
)
;
if
(
pointIndex
!
=
-
1
)
{
index
=
pointIndex
+
1
;
break
;
}
}
point
-
>
InsertInsertedChildAt
(
aChild
index
)
;
nsIContent
*
newParent
=
point
-
>
GetParent
(
)
;
if
(
newParent
=
=
parent
)
{
break
;
}
parent
=
newParent
;
}
}
nsIContent
*
nsBindingManager
:
:
FindNestedSingleInsertionPoint
(
nsIContent
*
aContainer
bool
*
aMulti
)
{
*
aMulti
=
false
;
nsIContent
*
parent
=
aContainer
;
if
(
aContainer
-
>
IsActiveChildrenElement
(
)
)
{
if
(
static_cast
<
XBLChildrenElement
*
>
(
aContainer
)
-
>
HasInsertedChildren
(
)
)
{
return
nullptr
;
}
parent
=
aContainer
-
>
GetParent
(
)
;
}
while
(
parent
)
{
nsXBLBinding
*
binding
=
GetBindingWithContent
(
parent
)
;
if
(
!
binding
)
{
break
;
}
if
(
binding
-
>
HasFilteredInsertionPoints
(
)
)
{
*
aMulti
=
true
;
return
nullptr
;
}
XBLChildrenElement
*
point
=
binding
-
>
GetDefaultInsertionPoint
(
)
;
if
(
!
point
)
{
return
nullptr
;
}
nsIContent
*
newParent
=
point
-
>
GetParent
(
)
;
if
(
newParent
=
=
parent
)
{
break
;
}
parent
=
newParent
;
}
return
parent
;
}
size_t
nsBindingManager
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
#
define
SHALLOW_SIZE_INCLUDING
(
field_
)
\
n
+
=
field_
?
field_
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
:
0
;
SHALLOW_SIZE_INCLUDING
(
mBoundContentSet
)
;
SHALLOW_SIZE_INCLUDING
(
mWrapperTable
)
;
SHALLOW_SIZE_INCLUDING
(
mLoadingDocTable
)
;
#
undef
SHALLOW_SIZE_INCLUDING
n
+
=
mAttachedStack
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
mDocumentTable
)
{
n
+
=
mDocumentTable
-
>
ShallowSizeOfIncludingThis
(
aMallocSizeOf
)
;
#
ifdef
MOZ_XUL
nsXULPrototypeCache
*
cache
=
nsXULPrototypeCache
:
:
GetInstance
(
)
;
#
endif
for
(
auto
iter
=
mDocumentTable
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsXBLDocumentInfo
*
docInfo
=
iter
.
UserData
(
)
;
#
ifdef
MOZ_XUL
nsXBLDocumentInfo
*
cachedInfo
=
cache
-
>
GetXBLDocumentInfo
(
iter
.
Key
(
)
)
;
if
(
cachedInfo
=
=
docInfo
)
{
continue
;
}
#
endif
n
+
=
docInfo
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
return
n
;
}
