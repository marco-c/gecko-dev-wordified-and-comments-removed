#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXBLPrototypeHandler
.
h
"
#
include
"
nsXBLWindowKeyHandler
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsXBLService
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsXBLDocumentInfo
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
layers
/
KeyboardMap
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
class
nsXBLSpecialDocInfo
:
public
nsIObserver
{
public
:
RefPtr
<
nsXBLDocumentInfo
>
mHTMLBindings
;
static
const
char
sHTMLBindingStr
[
]
;
static
const
char
sUserHTMLBindingStr
[
]
;
bool
mInitialized
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
LoadDocInfo
(
)
;
void
GetHandlers
(
const
nsACString
&
aRef
nsXBLPrototypeHandler
*
*
handler
)
;
nsXBLSpecialDocInfo
(
)
:
mInitialized
(
false
)
{
}
protected
:
virtual
~
nsXBLSpecialDocInfo
(
)
{
}
}
;
const
char
nsXBLSpecialDocInfo
:
:
sHTMLBindingStr
[
]
=
"
chrome
:
/
/
global
/
content
/
platformHTMLBindings
.
xml
"
;
NS_IMPL_ISUPPORTS
(
nsXBLSpecialDocInfo
nsIObserver
)
NS_IMETHODIMP
nsXBLSpecialDocInfo
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
"
wrong
topic
"
)
;
mHTMLBindings
=
nullptr
;
mInitialized
=
false
;
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
return
NS_OK
;
}
void
nsXBLSpecialDocInfo
:
:
LoadDocInfo
(
)
{
if
(
mInitialized
)
return
;
mInitialized
=
true
;
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
nsXBLService
*
xblService
=
nsXBLService
:
:
GetInstance
(
)
;
if
(
!
xblService
)
return
;
nsCOMPtr
<
nsIURI
>
bindingURI
;
NS_NewURI
(
getter_AddRefs
(
bindingURI
)
sHTMLBindingStr
)
;
if
(
!
bindingURI
)
{
return
;
}
xblService
-
>
LoadBindingDocumentInfo
(
nullptr
nullptr
bindingURI
nullptr
true
getter_AddRefs
(
mHTMLBindings
)
)
;
}
void
nsXBLSpecialDocInfo
:
:
GetHandlers
(
const
nsACString
&
aRef
nsXBLPrototypeHandler
*
*
aHandler
)
{
if
(
mHTMLBindings
)
{
nsXBLPrototypeBinding
*
binding
=
mHTMLBindings
-
>
GetPrototypeBinding
(
aRef
)
;
NS_ASSERTION
(
binding
"
No
binding
found
for
the
XBL
window
key
handler
.
"
)
;
if
(
!
binding
)
return
;
*
aHandler
=
binding
-
>
GetPrototypeHandlers
(
)
;
}
}
static
StaticRefPtr
<
nsXBLSpecialDocInfo
>
sXBLSpecialDocInfo
;
uint32_t
nsXBLWindowKeyHandler
:
:
sRefCnt
=
0
;
void
nsXBLWindowKeyHandler
:
:
EnsureSpecialDocInfo
(
)
{
if
(
!
sXBLSpecialDocInfo
)
{
sXBLSpecialDocInfo
=
new
nsXBLSpecialDocInfo
(
)
;
}
sXBLSpecialDocInfo
-
>
LoadDocInfo
(
)
;
}
nsXBLWindowKeyHandler
:
:
nsXBLWindowKeyHandler
(
Element
*
aElement
EventTarget
*
aTarget
)
:
mTarget
(
aTarget
)
mHandler
(
nullptr
)
{
mWeakPtrForElement
=
do_GetWeakReference
(
aElement
)
;
+
+
sRefCnt
;
}
nsXBLWindowKeyHandler
:
:
~
nsXBLWindowKeyHandler
(
)
{
if
(
mWeakPtrForElement
)
delete
mHandler
;
-
-
sRefCnt
;
if
(
!
sRefCnt
)
{
sXBLSpecialDocInfo
=
nullptr
;
}
}
NS_IMPL_ISUPPORTS
(
nsXBLWindowKeyHandler
nsIDOMEventListener
)
static
void
BuildHandlerChain
(
nsIContent
*
aContent
nsXBLPrototypeHandler
*
*
aResult
)
{
*
aResult
=
nullptr
;
for
(
nsIContent
*
key
=
aContent
-
>
GetLastChild
(
)
;
key
;
key
=
key
-
>
GetPreviousSibling
(
)
)
{
if
(
!
key
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
key
kNameSpaceID_XUL
)
)
{
continue
;
}
Element
*
keyElement
=
key
-
>
AsElement
(
)
;
nsAutoString
valKey
valCharCode
valKeyCode
;
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
key
valKey
)
|
|
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
charcode
valCharCode
)
|
|
keyElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
keycode
valKeyCode
)
;
if
(
valKey
.
IsEmpty
(
)
&
&
valCharCode
.
IsEmpty
(
)
&
&
valKeyCode
.
IsEmpty
(
)
)
{
continue
;
}
XBLReservedKey
reserved
=
XBLReservedKey_Unset
;
if
(
keyElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
reserved
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
reserved
=
XBLReservedKey_True
;
}
else
if
(
keyElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
reserved
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
reserved
=
XBLReservedKey_False
;
}
nsXBLPrototypeHandler
*
handler
=
new
nsXBLPrototypeHandler
(
keyElement
reserved
)
;
handler
-
>
SetNextHandler
(
*
aResult
)
;
*
aResult
=
handler
;
}
}
nsresult
nsXBLWindowKeyHandler
:
:
EnsureHandlers
(
)
{
nsCOMPtr
<
Element
>
el
=
GetElement
(
)
;
NS_ENSURE_STATE
(
!
mWeakPtrForElement
|
|
el
)
;
if
(
el
)
{
if
(
mHandler
)
return
NS_OK
;
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
el
)
)
;
BuildHandlerChain
(
content
&
mHandler
)
;
}
else
{
EnsureSpecialDocInfo
(
)
;
if
(
IsHTMLEditableFieldFocused
(
)
)
{
sXBLSpecialDocInfo
-
>
GetHandlers
(
NS_LITERAL_CSTRING
(
"
editor
"
)
&
mHandler
)
;
}
else
{
sXBLSpecialDocInfo
-
>
GetHandlers
(
NS_LITERAL_CSTRING
(
"
browser
"
)
&
mHandler
)
;
}
}
return
NS_OK
;
}
nsresult
nsXBLWindowKeyHandler
:
:
WalkHandlers
(
KeyboardEvent
*
aKeyEvent
nsAtom
*
aEventType
)
{
if
(
aKeyEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
if
(
!
aKeyEvent
-
>
IsTrusted
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
EnsureHandlers
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isDisabled
;
nsCOMPtr
<
Element
>
el
=
GetElement
(
&
isDisabled
)
;
if
(
el
&
&
isDisabled
)
{
return
NS_OK
;
}
WalkHandlersInternal
(
aKeyEvent
aEventType
true
)
;
return
NS_OK
;
}
void
nsXBLWindowKeyHandler
:
:
InstallKeyboardEventListenersTo
(
EventListenerManager
*
aEventListenerManager
)
{
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozaccesskeynotfound
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
void
nsXBLWindowKeyHandler
:
:
RemoveKeyboardEventListenersFrom
(
EventListenerManager
*
aEventListenerManager
)
{
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozaccesskeynotfound
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
KeyboardMap
nsXBLWindowKeyHandler
:
:
CollectKeyboardShortcuts
(
)
{
EnsureSpecialDocInfo
(
)
;
nsXBLPrototypeHandler
*
handlers
=
nullptr
;
sXBLSpecialDocInfo
-
>
GetHandlers
(
NS_LITERAL_CSTRING
(
"
browser
"
)
&
handlers
)
;
AutoTArray
<
KeyboardShortcut
48
>
shortcuts
;
KeyboardShortcut
:
:
AppendHardcodedShortcuts
(
shortcuts
)
;
for
(
nsXBLPrototypeHandler
*
handler
=
handlers
;
handler
;
handler
=
handler
-
>
GetNextHandler
(
)
)
{
KeyboardShortcut
shortcut
;
if
(
handler
-
>
TryConvertToKeyboardShortcut
(
&
shortcut
)
)
{
shortcuts
.
AppendElement
(
shortcut
)
;
}
}
return
KeyboardMap
(
std
:
:
move
(
shortcuts
)
)
;
}
nsAtom
*
nsXBLWindowKeyHandler
:
:
ConvertEventToDOMEventType
(
const
WidgetKeyboardEvent
&
aWidgetKeyboardEvent
)
const
{
if
(
aWidgetKeyboardEvent
.
IsKeyDownOrKeyDownOnPlugin
(
)
)
{
return
nsGkAtoms
:
:
keydown
;
}
if
(
aWidgetKeyboardEvent
.
IsKeyUpOrKeyUpOnPlugin
(
)
)
{
return
nsGkAtoms
:
:
keyup
;
}
if
(
aWidgetKeyboardEvent
.
mMessage
=
=
eKeyPress
|
|
aWidgetKeyboardEvent
.
mMessage
=
=
eAccessKeyNotFound
)
{
return
nsGkAtoms
:
:
keypress
;
}
MOZ_ASSERT_UNREACHABLE
(
"
All
event
messages
which
this
instance
listens
to
should
be
handled
"
)
;
return
nullptr
;
}
NS_IMETHODIMP
nsXBLWindowKeyHandler
:
:
HandleEvent
(
Event
*
aEvent
)
{
RefPtr
<
KeyboardEvent
>
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
NS_ENSURE_TRUE
(
keyEvent
NS_ERROR_INVALID_ARG
)
;
if
(
aEvent
-
>
EventPhase
(
)
=
=
Event_Binding
:
:
CAPTURING_PHASE
)
{
if
(
aEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mInSystemGroup
)
{
HandleEventOnCaptureInSystemEventGroup
(
keyEvent
)
;
}
else
{
HandleEventOnCaptureInDefaultEventGroup
(
keyEvent
)
;
}
return
NS_OK
;
}
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
widgetKeyboardEvent
-
>
IsKeyEventOnPlugin
(
)
)
{
if
(
!
widgetKeyboardEvent
-
>
IsReservedByChrome
(
)
)
{
return
NS_OK
;
}
if
(
!
widgetKeyboardEvent
-
>
IsTrusted
(
)
|
|
widgetKeyboardEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
bool
isReserved
=
false
;
if
(
!
HasHandlerForEvent
(
keyEvent
&
isReserved
)
)
{
return
NS_OK
;
}
}
if
(
widgetKeyboardEvent
-
>
mFlags
.
mHandledByAPZ
)
{
aEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
RefPtr
<
nsAtom
>
eventTypeAtom
=
ConvertEventToDOMEventType
(
*
widgetKeyboardEvent
)
;
return
WalkHandlers
(
keyEvent
eventTypeAtom
)
;
}
void
nsXBLWindowKeyHandler
:
:
HandleEventOnCaptureInDefaultEventGroup
(
KeyboardEvent
*
aEvent
)
{
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
widgetKeyboardEvent
-
>
IsReservedByChrome
(
)
)
{
return
;
}
bool
isReserved
=
false
;
if
(
HasHandlerForEvent
(
aEvent
&
isReserved
)
&
&
isReserved
)
{
widgetKeyboardEvent
-
>
MarkAsReservedByChrome
(
)
;
}
}
void
nsXBLWindowKeyHandler
:
:
HandleEventOnCaptureInSystemEventGroup
(
KeyboardEvent
*
aEvent
)
{
WidgetKeyboardEvent
*
widgetEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
!
widgetEvent
-
>
WillBeSentToRemoteProcess
(
)
)
{
return
;
}
if
(
!
HasHandlerForEvent
(
aEvent
)
)
{
return
;
}
widgetEvent
-
>
StopImmediatePropagation
(
)
;
widgetEvent
-
>
MarkAsWaitingReplyFromRemoteProcess
(
)
;
}
bool
nsXBLWindowKeyHandler
:
:
IsHTMLEditableFieldFocused
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
return
false
;
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedWindow
)
return
false
;
auto
*
piwin
=
nsPIDOMWindowOuter
:
:
From
(
focusedWindow
)
;
nsIDocShell
*
docShell
=
piwin
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
RefPtr
<
HTMLEditor
>
htmlEditor
=
docShell
-
>
GetHTMLEditor
(
)
;
if
(
!
htmlEditor
)
{
return
false
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
htmlEditor
-
>
GetDocument
(
)
;
if
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
true
;
}
nsINode
*
focusedNode
=
fm
-
>
GetFocusedElement
(
)
;
if
(
focusedNode
&
&
focusedNode
-
>
IsElement
(
)
)
{
nsCOMPtr
<
Element
>
activeEditingHost
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
if
(
!
activeEditingHost
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
focusedNode
activeEditingHost
)
;
}
return
false
;
}
bool
nsXBLWindowKeyHandler
:
:
WalkHandlersInternal
(
KeyboardEvent
*
aKeyEvent
nsAtom
*
aEventType
bool
aExecute
bool
*
aOutReservedForChrome
)
{
WidgetKeyboardEvent
*
nativeKeyboardEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
nativeKeyboardEvent
)
;
AutoShortcutKeyCandidateArray
shortcutKeys
;
nativeKeyboardEvent
-
>
GetShortcutKeyCandidates
(
shortcutKeys
)
;
if
(
shortcutKeys
.
IsEmpty
(
)
)
{
return
WalkHandlersAndExecute
(
aKeyEvent
aEventType
0
IgnoreModifierState
(
)
aExecute
aOutReservedForChrome
)
;
}
for
(
uint32_t
i
=
0
;
i
<
shortcutKeys
.
Length
(
)
;
+
+
i
)
{
ShortcutKeyCandidate
&
key
=
shortcutKeys
[
i
]
;
IgnoreModifierState
ignoreModifierState
;
ignoreModifierState
.
mShift
=
key
.
mIgnoreShift
;
if
(
WalkHandlersAndExecute
(
aKeyEvent
aEventType
key
.
mCharCode
ignoreModifierState
aExecute
aOutReservedForChrome
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsXBLWindowKeyHandler
:
:
WalkHandlersAndExecute
(
KeyboardEvent
*
aKeyEvent
nsAtom
*
aEventType
uint32_t
aCharCode
const
IgnoreModifierState
&
aIgnoreModifierState
bool
aExecute
bool
*
aOutReservedForChrome
)
{
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
false
;
}
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetKeyboardEvent
)
)
{
return
false
;
}
for
(
nsXBLPrototypeHandler
*
handler
=
mHandler
;
handler
;
handler
=
handler
-
>
GetNextHandler
(
)
)
{
bool
stopped
=
aKeyEvent
-
>
IsDispatchStopped
(
)
;
if
(
stopped
)
{
return
false
;
}
if
(
aExecute
)
{
if
(
widgetKeyboardEvent
-
>
mMessage
=
=
eKeyDownOnPlugin
)
{
if
(
!
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keydown
)
&
&
!
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
continue
;
}
}
else
if
(
!
handler
-
>
EventTypeEquals
(
aEventType
)
)
{
continue
;
}
}
else
{
if
(
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
if
(
aEventType
!
=
nsGkAtoms
:
:
keydown
&
&
aEventType
!
=
nsGkAtoms
:
:
keypress
)
{
continue
;
}
}
else
if
(
!
handler
-
>
EventTypeEquals
(
aEventType
)
)
{
continue
;
}
}
if
(
!
handler
-
>
KeyEventMatched
(
aKeyEvent
aCharCode
aIgnoreModifierState
)
)
{
continue
;
}
nsCOMPtr
<
Element
>
commandElement
;
if
(
!
GetElementForHandler
(
handler
getter_AddRefs
(
commandElement
)
)
)
{
continue
;
}
if
(
commandElement
)
{
if
(
aExecute
&
&
!
IsExecutableElement
(
commandElement
)
)
{
continue
;
}
}
if
(
!
aExecute
)
{
if
(
handler
-
>
EventTypeEquals
(
aEventType
)
)
{
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
IsReservedKey
(
widgetKeyboardEvent
handler
)
;
}
return
true
;
}
if
(
aEventType
=
=
nsGkAtoms
:
:
keydown
&
&
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
if
(
IsReservedKey
(
widgetKeyboardEvent
handler
)
)
{
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
true
;
}
return
true
;
}
}
continue
;
}
MOZ_ASSERT
(
!
aOutReservedForChrome
)
;
if
(
widgetKeyboardEvent
-
>
IsKeyEventOnPlugin
(
)
&
&
!
IsReservedKey
(
widgetKeyboardEvent
handler
)
)
{
return
false
;
}
nsCOMPtr
<
EventTarget
>
target
;
nsCOMPtr
<
Element
>
chromeHandlerElement
=
GetElement
(
)
;
if
(
chromeHandlerElement
)
{
target
=
commandElement
;
}
else
{
target
=
mTarget
;
}
nsresult
rv
=
handler
-
>
ExecuteHandler
(
target
aKeyEvent
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
true
;
}
}
#
ifdef
XP_WIN
if
(
!
aIgnoreModifierState
.
mOS
&
&
widgetKeyboardEvent
-
>
IsOS
(
)
)
{
IgnoreModifierState
ignoreModifierState
(
aIgnoreModifierState
)
;
ignoreModifierState
.
mOS
=
true
;
return
WalkHandlersAndExecute
(
aKeyEvent
aEventType
aCharCode
ignoreModifierState
aExecute
)
;
}
#
endif
return
false
;
}
bool
nsXBLWindowKeyHandler
:
:
IsReservedKey
(
WidgetKeyboardEvent
*
aKeyEvent
nsXBLPrototypeHandler
*
aHandler
)
{
XBLReservedKey
reserved
=
aHandler
-
>
GetIsReserved
(
)
;
if
(
reserved
=
=
XBLReservedKey_False
)
{
return
false
;
}
if
(
reserved
=
=
XBLReservedKey_True
)
{
return
true
;
}
return
nsContentUtils
:
:
ShouldBlockReservedKeys
(
aKeyEvent
)
;
}
bool
nsXBLWindowKeyHandler
:
:
HasHandlerForEvent
(
KeyboardEvent
*
aEvent
bool
*
aOutReservedForChrome
)
{
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetKeyboardEvent
)
|
|
!
widgetKeyboardEvent
-
>
IsTrusted
(
)
)
{
return
false
;
}
nsresult
rv
=
EnsureHandlers
(
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
isDisabled
;
nsCOMPtr
<
Element
>
el
=
GetElement
(
&
isDisabled
)
;
if
(
el
&
&
isDisabled
)
{
return
false
;
}
RefPtr
<
nsAtom
>
eventTypeAtom
=
ConvertEventToDOMEventType
(
*
widgetKeyboardEvent
)
;
return
WalkHandlersInternal
(
aEvent
eventTypeAtom
false
aOutReservedForChrome
)
;
}
already_AddRefed
<
Element
>
nsXBLWindowKeyHandler
:
:
GetElement
(
bool
*
aIsDisabled
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryReferent
(
mWeakPtrForElement
)
;
if
(
element
&
&
aIsDisabled
)
{
*
aIsDisabled
=
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
return
element
.
forget
(
)
;
}
bool
nsXBLWindowKeyHandler
:
:
GetElementForHandler
(
nsXBLPrototypeHandler
*
aHandler
Element
*
*
aElementForHandler
)
{
MOZ_ASSERT
(
aElementForHandler
)
;
*
aElementForHandler
=
nullptr
;
RefPtr
<
Element
>
keyContent
=
aHandler
-
>
GetHandlerElement
(
)
;
if
(
!
keyContent
)
{
return
true
;
}
nsCOMPtr
<
Element
>
chromeHandlerElement
=
GetElement
(
)
;
if
(
!
chromeHandlerElement
)
{
NS_WARNING_ASSERTION
(
keyContent
-
>
IsInUncomposedDoc
(
)
"
uncomposed
"
)
;
nsCOMPtr
<
Element
>
keyElement
=
do_QueryInterface
(
keyContent
)
;
keyElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
nsAutoString
command
;
keyContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
command
command
)
;
if
(
command
.
IsEmpty
(
)
)
{
NS_WARNING_ASSERTION
(
keyContent
-
>
IsInUncomposedDoc
(
)
"
uncomposed
"
)
;
nsCOMPtr
<
Element
>
keyElement
=
do_QueryInterface
(
keyContent
)
;
keyElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
nsIDocument
*
doc
=
keyContent
-
>
GetUncomposedDoc
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
false
;
}
nsCOMPtr
<
Element
>
commandElement
=
do_QueryInterface
(
doc
-
>
GetElementById
(
command
)
)
;
if
(
!
commandElement
)
{
NS_ERROR
(
"
A
XUL
<
key
>
is
observing
a
command
that
doesn
'
t
exist
.
"
"
Unable
to
execute
key
binding
!
"
)
;
return
false
;
}
commandElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
bool
nsXBLWindowKeyHandler
:
:
IsExecutableElement
(
Element
*
aElement
)
const
{
if
(
!
aElement
)
{
return
false
;
}
nsAutoString
value
;
aElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
disabled
"
)
value
)
;
if
(
value
.
EqualsLiteral
(
"
true
"
)
)
{
return
false
;
}
aElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
oncommand
"
)
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
return
false
;
}
return
true
;
}
already_AddRefed
<
nsXBLWindowKeyHandler
>
NS_NewXBLWindowKeyHandler
(
Element
*
aElement
EventTarget
*
aTarget
)
{
RefPtr
<
nsXBLWindowKeyHandler
>
result
=
new
nsXBLWindowKeyHandler
(
aElement
aTarget
)
;
return
result
.
forget
(
)
;
}
