#
include
"
nsCOMPtr
.
h
"
#
include
"
nsXBLPrototypeHandler
.
h
"
#
include
"
nsXBLWindowKeyHandler
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIDOMKeyEvent
.
h
"
#
include
"
nsXBLService
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsXBLDocumentInfo
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsIDOMDocument
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
nsXBLSpecialDocInfo
:
public
nsIObserver
{
public
:
RefPtr
<
nsXBLDocumentInfo
>
mHTMLBindings
;
RefPtr
<
nsXBLDocumentInfo
>
mUserHTMLBindings
;
static
const
char
sHTMLBindingStr
[
]
;
static
const
char
sUserHTMLBindingStr
[
]
;
bool
mInitialized
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
LoadDocInfo
(
)
;
void
GetAllHandlers
(
const
char
*
aType
nsXBLPrototypeHandler
*
*
handler
nsXBLPrototypeHandler
*
*
userHandler
)
;
void
GetHandlers
(
nsXBLDocumentInfo
*
aInfo
const
nsACString
&
aRef
nsXBLPrototypeHandler
*
*
aResult
)
;
nsXBLSpecialDocInfo
(
)
:
mInitialized
(
false
)
{
}
protected
:
virtual
~
nsXBLSpecialDocInfo
(
)
{
}
}
;
const
char
nsXBLSpecialDocInfo
:
:
sHTMLBindingStr
[
]
=
"
chrome
:
/
/
global
/
content
/
platformHTMLBindings
.
xml
"
;
NS_IMPL_ISUPPORTS
(
nsXBLSpecialDocInfo
nsIObserver
)
NS_IMETHODIMP
nsXBLSpecialDocInfo
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
"
wrong
topic
"
)
;
mHTMLBindings
=
nullptr
;
mUserHTMLBindings
=
nullptr
;
mInitialized
=
false
;
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
return
NS_OK
;
}
void
nsXBLSpecialDocInfo
:
:
LoadDocInfo
(
)
{
if
(
mInitialized
)
return
;
mInitialized
=
true
;
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
nsXBLService
*
xblService
=
nsXBLService
:
:
GetInstance
(
)
;
if
(
!
xblService
)
return
;
nsCOMPtr
<
nsIURI
>
bindingURI
;
NS_NewURI
(
getter_AddRefs
(
bindingURI
)
sHTMLBindingStr
)
;
if
(
!
bindingURI
)
{
return
;
}
xblService
-
>
LoadBindingDocumentInfo
(
nullptr
nullptr
bindingURI
nullptr
true
getter_AddRefs
(
mHTMLBindings
)
)
;
const
nsAdoptingCString
&
userHTMLBindingStr
=
Preferences
:
:
GetCString
(
"
dom
.
userHTMLBindings
.
uri
"
)
;
if
(
!
userHTMLBindingStr
.
IsEmpty
(
)
)
{
NS_NewURI
(
getter_AddRefs
(
bindingURI
)
userHTMLBindingStr
)
;
if
(
!
bindingURI
)
{
return
;
}
xblService
-
>
LoadBindingDocumentInfo
(
nullptr
nullptr
bindingURI
nullptr
true
getter_AddRefs
(
mUserHTMLBindings
)
)
;
}
}
void
nsXBLSpecialDocInfo
:
:
GetHandlers
(
nsXBLDocumentInfo
*
aInfo
const
nsACString
&
aRef
nsXBLPrototypeHandler
*
*
aResult
)
{
nsXBLPrototypeBinding
*
binding
=
aInfo
-
>
GetPrototypeBinding
(
aRef
)
;
NS_ASSERTION
(
binding
"
No
binding
found
for
the
XBL
window
key
handler
.
"
)
;
if
(
!
binding
)
return
;
*
aResult
=
binding
-
>
GetPrototypeHandlers
(
)
;
}
void
nsXBLSpecialDocInfo
:
:
GetAllHandlers
(
const
char
*
aType
nsXBLPrototypeHandler
*
*
aHandler
nsXBLPrototypeHandler
*
*
aUserHandler
)
{
if
(
mUserHTMLBindings
)
{
nsAutoCString
type
(
aType
)
;
type
.
AppendLiteral
(
"
User
"
)
;
GetHandlers
(
mUserHTMLBindings
type
aUserHandler
)
;
}
if
(
mHTMLBindings
)
{
GetHandlers
(
mHTMLBindings
nsDependentCString
(
aType
)
aHandler
)
;
}
}
nsXBLSpecialDocInfo
*
nsXBLWindowKeyHandler
:
:
sXBLSpecialDocInfo
=
nullptr
;
uint32_t
nsXBLWindowKeyHandler
:
:
sRefCnt
=
0
;
nsXBLWindowKeyHandler
:
:
nsXBLWindowKeyHandler
(
nsIDOMElement
*
aElement
EventTarget
*
aTarget
)
:
mTarget
(
aTarget
)
mHandler
(
nullptr
)
mUserHandler
(
nullptr
)
{
mWeakPtrForElement
=
do_GetWeakReference
(
aElement
)
;
+
+
sRefCnt
;
}
nsXBLWindowKeyHandler
:
:
~
nsXBLWindowKeyHandler
(
)
{
if
(
mWeakPtrForElement
)
delete
mHandler
;
-
-
sRefCnt
;
if
(
!
sRefCnt
)
{
NS_IF_RELEASE
(
sXBLSpecialDocInfo
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsXBLWindowKeyHandler
nsIDOMEventListener
)
static
void
BuildHandlerChain
(
nsIContent
*
aContent
nsXBLPrototypeHandler
*
*
aResult
)
{
*
aResult
=
nullptr
;
for
(
nsIContent
*
key
=
aContent
-
>
GetLastChild
(
)
;
key
;
key
=
key
-
>
GetPreviousSibling
(
)
)
{
if
(
key
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
key
kNameSpaceID_XUL
)
)
{
nsAutoString
valKey
valCharCode
valKeyCode
;
bool
attrExists
=
key
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
key
valKey
)
|
|
key
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
charcode
valCharCode
)
|
|
key
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
keycode
valKeyCode
)
;
if
(
attrExists
&
&
valKey
.
IsEmpty
(
)
&
&
valCharCode
.
IsEmpty
(
)
&
&
valKeyCode
.
IsEmpty
(
)
)
continue
;
nsXBLPrototypeHandler
*
handler
=
new
nsXBLPrototypeHandler
(
key
)
;
handler
-
>
SetNextHandler
(
*
aResult
)
;
*
aResult
=
handler
;
}
}
}
nsresult
nsXBLWindowKeyHandler
:
:
EnsureHandlers
(
)
{
nsCOMPtr
<
Element
>
el
=
GetElement
(
)
;
NS_ENSURE_STATE
(
!
mWeakPtrForElement
|
|
el
)
;
if
(
el
)
{
if
(
mHandler
)
return
NS_OK
;
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
el
)
)
;
BuildHandlerChain
(
content
&
mHandler
)
;
}
else
{
if
(
!
sXBLSpecialDocInfo
)
{
sXBLSpecialDocInfo
=
new
nsXBLSpecialDocInfo
(
)
;
NS_ADDREF
(
sXBLSpecialDocInfo
)
;
}
sXBLSpecialDocInfo
-
>
LoadDocInfo
(
)
;
if
(
IsHTMLEditableFieldFocused
(
)
)
{
sXBLSpecialDocInfo
-
>
GetAllHandlers
(
"
editor
"
&
mHandler
&
mUserHandler
)
;
}
else
{
sXBLSpecialDocInfo
-
>
GetAllHandlers
(
"
browser
"
&
mHandler
&
mUserHandler
)
;
}
}
return
NS_OK
;
}
nsresult
nsXBLWindowKeyHandler
:
:
WalkHandlers
(
nsIDOMKeyEvent
*
aKeyEvent
nsIAtom
*
aEventType
)
{
bool
prevent
;
aKeyEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
prevent
)
;
if
(
prevent
)
return
NS_OK
;
bool
trustedEvent
=
false
;
aKeyEvent
-
>
AsEvent
(
)
-
>
GetIsTrusted
(
&
trustedEvent
)
;
if
(
!
trustedEvent
)
return
NS_OK
;
nsresult
rv
=
EnsureHandlers
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isDisabled
;
nsCOMPtr
<
Element
>
el
=
GetElement
(
&
isDisabled
)
;
if
(
!
el
)
{
if
(
mUserHandler
)
{
WalkHandlersInternal
(
aKeyEvent
aEventType
mUserHandler
true
)
;
aKeyEvent
-
>
AsEvent
(
)
-
>
GetDefaultPrevented
(
&
prevent
)
;
if
(
prevent
)
return
NS_OK
;
}
}
if
(
el
&
&
isDisabled
)
{
return
NS_OK
;
}
WalkHandlersInternal
(
aKeyEvent
aEventType
mHandler
true
)
;
return
NS_OK
;
}
void
nsXBLWindowKeyHandler
:
:
InstallKeyboardEventListenersTo
(
EventListenerManager
*
aEventListenerManager
)
{
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
AddEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
void
nsXBLWindowKeyHandler
:
:
RemoveKeyboardEventListenersFrom
(
EventListenerManager
*
aEventListenerManager
)
{
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupCapture
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeydownonplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
aEventListenerManager
-
>
RemoveEventListenerByType
(
this
NS_LITERAL_STRING
(
"
mozkeyuponplugin
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
nsIAtom
*
nsXBLWindowKeyHandler
:
:
ConvertEventToDOMEventType
(
const
WidgetKeyboardEvent
&
aWidgetKeyboardEvent
)
const
{
if
(
aWidgetKeyboardEvent
.
IsKeyDownOrKeyDownOnPlugin
(
)
)
{
return
nsGkAtoms
:
:
keydown
;
}
if
(
aWidgetKeyboardEvent
.
IsKeyUpOrKeyUpOnPlugin
(
)
)
{
return
nsGkAtoms
:
:
keyup
;
}
if
(
aWidgetKeyboardEvent
.
mMessage
=
=
eKeyPress
)
{
return
nsGkAtoms
:
:
keypress
;
}
MOZ_ASSERT_UNREACHABLE
(
"
All
event
messages
which
this
instance
listens
to
should
be
handled
"
)
;
return
nullptr
;
}
NS_IMETHODIMP
nsXBLWindowKeyHandler
:
:
HandleEvent
(
nsIDOMEvent
*
aEvent
)
{
nsCOMPtr
<
nsIDOMKeyEvent
>
keyEvent
(
do_QueryInterface
(
aEvent
)
)
;
NS_ENSURE_TRUE
(
keyEvent
NS_ERROR_INVALID_ARG
)
;
uint16_t
eventPhase
;
aEvent
-
>
GetEventPhase
(
&
eventPhase
)
;
if
(
eventPhase
=
=
nsIDOMEvent
:
:
CAPTURING_PHASE
)
{
if
(
aEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mInSystemGroup
)
{
HandleEventOnCaptureInSystemEventGroup
(
keyEvent
)
;
}
else
{
HandleEventOnCaptureInDefaultEventGroup
(
keyEvent
)
;
}
return
NS_OK
;
}
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
widgetKeyboardEvent
-
>
IsKeyEventOnPlugin
(
)
)
{
if
(
!
widgetKeyboardEvent
-
>
mIsReserved
)
{
return
NS_OK
;
}
if
(
!
widgetKeyboardEvent
-
>
IsTrusted
(
)
|
|
widgetKeyboardEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
bool
isReserved
=
false
;
if
(
!
HasHandlerForEvent
(
keyEvent
&
isReserved
)
)
{
return
NS_OK
;
}
}
nsCOMPtr
<
nsIAtom
>
eventTypeAtom
=
ConvertEventToDOMEventType
(
*
widgetKeyboardEvent
)
;
return
WalkHandlers
(
keyEvent
eventTypeAtom
)
;
}
void
nsXBLWindowKeyHandler
:
:
HandleEventOnCaptureInDefaultEventGroup
(
nsIDOMKeyEvent
*
aEvent
)
{
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
widgetKeyboardEvent
-
>
mIsReserved
)
{
MOZ_RELEASE_ASSERT
(
widgetKeyboardEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
)
;
MOZ_RELEASE_ASSERT
(
widgetKeyboardEvent
-
>
mFlags
.
mNoCrossProcessBoundaryForwarding
)
;
return
;
}
bool
isReserved
=
false
;
if
(
HasHandlerForEvent
(
aEvent
&
isReserved
)
&
&
isReserved
)
{
widgetKeyboardEvent
-
>
mIsReserved
=
true
;
widgetKeyboardEvent
-
>
StopCrossProcessForwarding
(
)
;
widgetKeyboardEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
=
true
;
}
}
void
nsXBLWindowKeyHandler
:
:
HandleEventOnCaptureInSystemEventGroup
(
nsIDOMKeyEvent
*
aEvent
)
{
WidgetKeyboardEvent
*
widgetEvent
=
aEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
widgetEvent
-
>
mFlags
.
mNoCrossProcessBoundaryForwarding
|
|
widgetEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
)
{
return
;
}
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
originalTarget
=
do_QueryInterface
(
aEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
mOriginalTarget
)
;
if
(
!
EventStateManager
:
:
IsRemoteTarget
(
originalTarget
)
)
{
return
;
}
if
(
!
HasHandlerForEvent
(
aEvent
)
)
{
return
;
}
widgetEvent
-
>
mFlags
.
mWantReplyFromContentProcess
=
true
;
aEvent
-
>
AsEvent
(
)
-
>
StopPropagation
(
)
;
}
bool
nsXBLWindowKeyHandler
:
:
IsHTMLEditableFieldFocused
(
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
return
false
;
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedWindow
)
return
false
;
auto
*
piwin
=
nsPIDOMWindowOuter
:
:
From
(
focusedWindow
)
;
nsIDocShell
*
docShell
=
piwin
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
nsCOMPtr
<
nsIEditor
>
editor
;
docShell
-
>
GetEditor
(
getter_AddRefs
(
editor
)
)
;
nsCOMPtr
<
nsIHTMLEditor
>
htmlEditor
=
do_QueryInterface
(
editor
)
;
if
(
!
htmlEditor
)
{
return
false
;
}
nsCOMPtr
<
nsIDOMDocument
>
domDocument
;
editor
-
>
GetDocument
(
getter_AddRefs
(
domDocument
)
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
domDocument
)
;
if
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
true
;
}
nsCOMPtr
<
nsIDOMElement
>
focusedElement
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
focusedElement
)
)
;
nsCOMPtr
<
nsINode
>
focusedNode
=
do_QueryInterface
(
focusedElement
)
;
if
(
focusedNode
)
{
nsCOMPtr
<
Element
>
activeEditingHost
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
if
(
!
activeEditingHost
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
focusedNode
activeEditingHost
)
;
}
return
false
;
}
bool
nsXBLWindowKeyHandler
:
:
WalkHandlersInternal
(
nsIDOMKeyEvent
*
aKeyEvent
nsIAtom
*
aEventType
nsXBLPrototypeHandler
*
aHandler
bool
aExecute
bool
*
aOutReservedForChrome
)
{
WidgetKeyboardEvent
*
nativeKeyboardEvent
=
aKeyEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
nativeKeyboardEvent
)
;
AutoShortcutKeyCandidateArray
shortcutKeys
;
nativeKeyboardEvent
-
>
GetShortcutKeyCandidates
(
shortcutKeys
)
;
if
(
shortcutKeys
.
IsEmpty
(
)
)
{
return
WalkHandlersAndExecute
(
aKeyEvent
aEventType
aHandler
0
IgnoreModifierState
(
)
aExecute
aOutReservedForChrome
)
;
}
for
(
uint32_t
i
=
0
;
i
<
shortcutKeys
.
Length
(
)
;
+
+
i
)
{
ShortcutKeyCandidate
&
key
=
shortcutKeys
[
i
]
;
IgnoreModifierState
ignoreModifierState
;
ignoreModifierState
.
mShift
=
key
.
mIgnoreShift
;
if
(
WalkHandlersAndExecute
(
aKeyEvent
aEventType
aHandler
key
.
mCharCode
ignoreModifierState
aExecute
aOutReservedForChrome
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsXBLWindowKeyHandler
:
:
WalkHandlersAndExecute
(
nsIDOMKeyEvent
*
aKeyEvent
nsIAtom
*
aEventType
nsXBLPrototypeHandler
*
aFirstHandler
uint32_t
aCharCode
const
IgnoreModifierState
&
aIgnoreModifierState
bool
aExecute
bool
*
aOutReservedForChrome
)
{
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
false
;
}
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aKeyEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetKeyboardEvent
)
)
{
return
false
;
}
for
(
nsXBLPrototypeHandler
*
handler
=
aFirstHandler
;
handler
;
handler
=
handler
-
>
GetNextHandler
(
)
)
{
bool
stopped
=
aKeyEvent
-
>
AsEvent
(
)
-
>
IsDispatchStopped
(
)
;
if
(
stopped
)
{
return
false
;
}
if
(
aExecute
)
{
if
(
widgetKeyboardEvent
-
>
mMessage
=
=
eKeyDownOnPlugin
)
{
if
(
!
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keydown
)
&
&
!
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
continue
;
}
}
else
if
(
!
handler
-
>
EventTypeEquals
(
aEventType
)
)
{
continue
;
}
}
else
{
if
(
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
if
(
aEventType
!
=
nsGkAtoms
:
:
keydown
&
&
aEventType
!
=
nsGkAtoms
:
:
keypress
)
{
continue
;
}
}
else
if
(
!
handler
-
>
EventTypeEquals
(
aEventType
)
)
{
continue
;
}
}
if
(
!
handler
-
>
KeyEventMatched
(
aKeyEvent
aCharCode
aIgnoreModifierState
)
)
{
continue
;
}
nsCOMPtr
<
Element
>
commandElement
;
if
(
!
GetElementForHandler
(
handler
getter_AddRefs
(
commandElement
)
)
)
{
continue
;
}
bool
isReserved
=
false
;
if
(
commandElement
)
{
if
(
aExecute
&
&
!
IsExecutableElement
(
commandElement
)
)
{
continue
;
}
isReserved
=
commandElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
reserved
nsGkAtoms
:
:
_true
eCaseMatters
)
;
if
(
aOutReservedForChrome
)
{
*
aOutReservedForChrome
=
isReserved
;
}
}
if
(
!
aExecute
)
{
if
(
handler
-
>
EventTypeEquals
(
aEventType
)
)
{
return
true
;
}
if
(
isReserved
&
&
aEventType
=
=
nsGkAtoms
:
:
keydown
&
&
handler
-
>
EventTypeEquals
(
nsGkAtoms
:
:
keypress
)
)
{
return
true
;
}
continue
;
}
if
(
!
isReserved
&
&
widgetKeyboardEvent
-
>
IsKeyEventOnPlugin
(
)
)
{
return
false
;
}
nsCOMPtr
<
EventTarget
>
target
;
nsCOMPtr
<
Element
>
chromeHandlerElement
=
GetElement
(
)
;
if
(
chromeHandlerElement
)
{
target
=
commandElement
;
}
else
{
target
=
mTarget
;
}
nsresult
rv
=
handler
-
>
ExecuteHandler
(
target
aKeyEvent
-
>
AsEvent
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
true
;
}
}
#
ifdef
XP_WIN
if
(
!
aIgnoreModifierState
.
mOS
&
&
widgetKeyboardEvent
-
>
IsOS
(
)
)
{
IgnoreModifierState
ignoreModifierState
(
aIgnoreModifierState
)
;
ignoreModifierState
.
mOS
=
true
;
return
WalkHandlersAndExecute
(
aKeyEvent
aEventType
aFirstHandler
aCharCode
ignoreModifierState
aExecute
)
;
}
#
endif
return
false
;
}
bool
nsXBLWindowKeyHandler
:
:
HasHandlerForEvent
(
nsIDOMKeyEvent
*
aEvent
bool
*
aOutReservedForChrome
)
{
WidgetKeyboardEvent
*
widgetKeyboardEvent
=
aEvent
-
>
AsEvent
(
)
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
NS_WARN_IF
(
!
widgetKeyboardEvent
)
|
|
!
widgetKeyboardEvent
-
>
IsTrusted
(
)
)
{
return
false
;
}
nsresult
rv
=
EnsureHandlers
(
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
isDisabled
;
nsCOMPtr
<
Element
>
el
=
GetElement
(
&
isDisabled
)
;
if
(
el
&
&
isDisabled
)
{
return
false
;
}
nsCOMPtr
<
nsIAtom
>
eventTypeAtom
=
ConvertEventToDOMEventType
(
*
widgetKeyboardEvent
)
;
return
WalkHandlersInternal
(
aEvent
eventTypeAtom
mHandler
false
aOutReservedForChrome
)
;
}
already_AddRefed
<
Element
>
nsXBLWindowKeyHandler
:
:
GetElement
(
bool
*
aIsDisabled
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryReferent
(
mWeakPtrForElement
)
;
if
(
element
&
&
aIsDisabled
)
{
*
aIsDisabled
=
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
return
element
.
forget
(
)
;
}
bool
nsXBLWindowKeyHandler
:
:
GetElementForHandler
(
nsXBLPrototypeHandler
*
aHandler
Element
*
*
aElementForHandler
)
{
MOZ_ASSERT
(
aElementForHandler
)
;
*
aElementForHandler
=
nullptr
;
nsCOMPtr
<
nsIContent
>
keyContent
=
aHandler
-
>
GetHandlerElement
(
)
;
if
(
!
keyContent
)
{
return
true
;
}
nsCOMPtr
<
Element
>
chromeHandlerElement
=
GetElement
(
)
;
if
(
!
chromeHandlerElement
)
{
NS_WARN_IF
(
!
keyContent
-
>
IsInUncomposedDoc
(
)
)
;
nsCOMPtr
<
Element
>
keyElement
=
do_QueryInterface
(
keyContent
)
;
keyElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
nsAutoString
command
;
keyContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
command
command
)
;
if
(
command
.
IsEmpty
(
)
)
{
NS_WARN_IF
(
!
keyContent
-
>
IsInUncomposedDoc
(
)
)
;
nsCOMPtr
<
Element
>
keyElement
=
do_QueryInterface
(
keyContent
)
;
keyElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
nsIDocument
*
doc
=
keyContent
-
>
GetUncomposedDoc
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
false
;
}
nsCOMPtr
<
Element
>
commandElement
=
do_QueryInterface
(
doc
-
>
GetElementById
(
command
)
)
;
if
(
!
commandElement
)
{
NS_ERROR
(
"
A
XUL
<
key
>
is
observing
a
command
that
doesn
'
t
exist
.
"
"
Unable
to
execute
key
binding
!
"
)
;
return
false
;
}
commandElement
.
swap
(
*
aElementForHandler
)
;
return
true
;
}
bool
nsXBLWindowKeyHandler
:
:
IsExecutableElement
(
Element
*
aElement
)
const
{
if
(
!
aElement
)
{
return
false
;
}
nsAutoString
value
;
aElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
disabled
"
)
value
)
;
if
(
value
.
EqualsLiteral
(
"
true
"
)
)
{
return
false
;
}
aElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
oncommand
"
)
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
return
false
;
}
return
true
;
}
already_AddRefed
<
nsXBLWindowKeyHandler
>
NS_NewXBLWindowKeyHandler
(
nsIDOMElement
*
aElement
EventTarget
*
aTarget
)
{
RefPtr
<
nsXBLWindowKeyHandler
>
result
=
new
nsXBLWindowKeyHandler
(
aElement
aTarget
)
;
return
result
.
forget
(
)
;
}
