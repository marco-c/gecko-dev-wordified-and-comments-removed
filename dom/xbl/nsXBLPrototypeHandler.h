#
ifndef
nsXBLPrototypeHandler_h__
#
define
nsXBLPrototypeHandler_h__
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsXBLEventHandler
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
class
nsIDOMEvent
;
class
nsIContent
;
class
nsIDOMUIEvent
;
class
nsIDOMMouseEvent
;
class
nsIObjectInputStream
;
class
nsIObjectOutputStream
;
class
nsXBLPrototypeBinding
;
namespace
mozilla
{
struct
IgnoreModifierState
;
namespace
dom
{
class
AutoJSAPI
;
class
EventTarget
;
class
KeyboardEvent
;
}
namespace
layers
{
class
KeyboardShortcut
;
}
}
#
define
NS_HANDLER_TYPE_XBL_JS
(
1
<
<
0
)
#
define
NS_HANDLER_TYPE_XBL_COMMAND
(
1
<
<
1
)
#
define
NS_HANDLER_TYPE_XUL
(
1
<
<
2
)
#
define
NS_HANDLER_HAS_ALLOW_UNTRUSTED_ATTR
(
1
<
<
4
)
#
define
NS_HANDLER_ALLOW_UNTRUSTED
(
1
<
<
5
)
#
define
NS_HANDLER_TYPE_SYSTEM
(
1
<
<
6
)
#
define
NS_HANDLER_TYPE_PREVENTDEFAULT
(
1
<
<
7
)
#
define
NS_PHASE_CAPTURING
1
#
define
NS_PHASE_TARGET
2
#
define
NS_PHASE_BUBBLING
3
enum
XBLReservedKey
:
uint8_t
{
XBLReservedKey_False
=
0
XBLReservedKey_True
=
1
XBLReservedKey_Unset
=
2
}
;
namespace
mozilla
{
namespace
dom
{
class
Element
;
}
}
class
nsXBLPrototypeHandler
{
typedef
mozilla
:
:
IgnoreModifierState
IgnoreModifierState
;
typedef
mozilla
:
:
layers
:
:
KeyboardShortcut
KeyboardShortcut
;
typedef
mozilla
:
:
Modifiers
Modifiers
;
public
:
nsXBLPrototypeHandler
(
const
char16_t
*
aEvent
const
char16_t
*
aPhase
const
char16_t
*
aAction
const
char16_t
*
aCommand
const
char16_t
*
aKeyCode
const
char16_t
*
aCharCode
const
char16_t
*
aModifiers
const
char16_t
*
aButton
const
char16_t
*
aClickCount
const
char16_t
*
aGroup
const
char16_t
*
aPreventDefault
const
char16_t
*
aAllowUntrusted
nsXBLPrototypeBinding
*
aBinding
uint32_t
aLineNumber
)
;
explicit
nsXBLPrototypeHandler
(
mozilla
:
:
dom
:
:
Element
*
aKeyElement
XBLReservedKey
aReserved
)
;
explicit
nsXBLPrototypeHandler
(
nsXBLPrototypeBinding
*
aBinding
)
;
~
nsXBLPrototypeHandler
(
)
;
bool
TryConvertToKeyboardShortcut
(
KeyboardShortcut
*
aOut
)
const
;
bool
EventTypeEquals
(
nsAtom
*
aEventType
)
const
{
return
mEventName
=
=
aEventType
;
}
bool
KeyEventMatched
(
mozilla
:
:
dom
:
:
KeyboardEvent
*
aKeyEvent
uint32_t
aCharCode
const
IgnoreModifierState
&
aIgnoreModifierState
)
;
bool
MouseEventMatched
(
nsIDOMMouseEvent
*
aMouseEvent
)
;
inline
bool
MouseEventMatched
(
nsAtom
*
aEventType
nsIDOMMouseEvent
*
aEvent
)
{
if
(
!
EventTypeEquals
(
aEventType
)
)
{
return
false
;
}
return
MouseEventMatched
(
aEvent
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Element
>
GetHandlerElement
(
)
;
void
AppendHandlerText
(
const
nsAString
&
aText
)
;
uint8_t
GetPhase
(
)
{
return
mPhase
;
}
uint8_t
GetType
(
)
{
return
mType
;
}
XBLReservedKey
GetIsReserved
(
)
{
return
mReserved
;
}
nsXBLPrototypeHandler
*
GetNextHandler
(
)
{
return
mNextHandler
;
}
void
SetNextHandler
(
nsXBLPrototypeHandler
*
aHandler
)
{
mNextHandler
=
aHandler
;
}
nsresult
ExecuteHandler
(
mozilla
:
:
dom
:
:
EventTarget
*
aTarget
nsIDOMEvent
*
aEvent
)
;
already_AddRefed
<
nsAtom
>
GetEventName
(
)
;
void
SetEventName
(
nsAtom
*
aName
)
{
mEventName
=
aName
;
}
nsXBLEventHandler
*
GetEventHandler
(
)
{
if
(
!
mHandler
)
{
mHandler
=
NS_NewXBLEventHandler
(
this
mEventName
)
;
}
return
mHandler
;
}
nsXBLEventHandler
*
GetCachedEventHandler
(
)
{
return
mHandler
;
}
bool
HasAllowUntrustedAttr
(
)
{
return
(
mType
&
NS_HANDLER_HAS_ALLOW_UNTRUSTED_ATTR
)
!
=
0
;
}
bool
AllowUntrustedEvents
(
)
{
return
(
mType
&
NS_HANDLER_ALLOW_UNTRUSTED
)
!
=
0
;
}
nsresult
Read
(
nsIObjectInputStream
*
aStream
)
;
nsresult
Write
(
nsIObjectOutputStream
*
aStream
)
;
public
:
static
uint32_t
gRefCnt
;
protected
:
void
Init
(
)
{
+
+
gRefCnt
;
if
(
gRefCnt
=
=
1
)
InitAccessKeys
(
)
;
}
already_AddRefed
<
nsIController
>
GetController
(
mozilla
:
:
dom
:
:
EventTarget
*
aTarget
)
;
inline
int32_t
GetMatchingKeyCode
(
const
nsAString
&
aKeyName
)
;
void
ConstructPrototype
(
mozilla
:
:
dom
:
:
Element
*
aKeyElement
const
char16_t
*
aEvent
=
nullptr
const
char16_t
*
aPhase
=
nullptr
const
char16_t
*
aAction
=
nullptr
const
char16_t
*
aCommand
=
nullptr
const
char16_t
*
aKeyCode
=
nullptr
const
char16_t
*
aCharCode
=
nullptr
const
char16_t
*
aModifiers
=
nullptr
const
char16_t
*
aButton
=
nullptr
const
char16_t
*
aClickCount
=
nullptr
const
char16_t
*
aGroup
=
nullptr
const
char16_t
*
aPreventDefault
=
nullptr
const
char16_t
*
aAllowUntrusted
=
nullptr
)
;
void
ReportKeyConflict
(
const
char16_t
*
aKey
const
char16_t
*
aModifiers
mozilla
:
:
dom
:
:
Element
*
aElement
const
char
*
aMessageName
)
;
void
GetEventType
(
nsAString
&
type
)
;
bool
ModifiersMatchMask
(
nsIDOMUIEvent
*
aEvent
const
IgnoreModifierState
&
aIgnoreModifierState
)
;
nsresult
DispatchXBLCommand
(
mozilla
:
:
dom
:
:
EventTarget
*
aTarget
nsIDOMEvent
*
aEvent
)
;
nsresult
DispatchXULKeyCommand
(
nsIDOMEvent
*
aEvent
)
;
nsresult
EnsureEventHandler
(
mozilla
:
:
dom
:
:
AutoJSAPI
&
jsapi
nsAtom
*
aName
JS
:
:
MutableHandle
<
JSObject
*
>
aHandler
)
;
Modifiers
GetModifiers
(
)
const
;
Modifiers
GetModifiersMask
(
)
const
;
static
int32_t
KeyToMask
(
int32_t
key
)
;
static
int32_t
AccelKeyMask
(
)
;
static
int32_t
kMenuAccessKey
;
static
void
InitAccessKeys
(
)
;
static
const
int32_t
cShift
;
static
const
int32_t
cAlt
;
static
const
int32_t
cControl
;
static
const
int32_t
cMeta
;
static
const
int32_t
cOS
;
static
const
int32_t
cShiftMask
;
static
const
int32_t
cAltMask
;
static
const
int32_t
cControlMask
;
static
const
int32_t
cMetaMask
;
static
const
int32_t
cOSMask
;
static
const
int32_t
cAllModifiers
;
protected
:
union
{
nsIWeakReference
*
mHandlerElement
;
char16_t
*
mHandlerText
;
}
;
uint32_t
mLineNumber
;
uint8_t
mPhase
;
uint8_t
mType
;
uint8_t
mMisc
;
XBLReservedKey
mReserved
;
int32_t
mKeyMask
;
int32_t
mDetail
;
nsXBLPrototypeHandler
*
mNextHandler
;
RefPtr
<
nsAtom
>
mEventName
;
RefPtr
<
nsXBLEventHandler
>
mHandler
;
nsXBLPrototypeBinding
*
mPrototypeBinding
;
}
;
#
endif
