#
include
"
nsContentSecurityUtils
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsITransfer
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
WinUtils
.
h
"
#
include
<
wininet
.
h
>
#
endif
#
include
"
js
/
Array
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
LoadInfo
.
h
"
#
include
"
mozilla
/
StaticPrefs_extensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
static
already_AddRefed
<
nsIPrincipal
>
MakeHTTPPrincipalHTTPS
(
nsIPrincipal
*
aPrincipal
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aPrincipal
;
if
(
!
principal
-
>
SchemeIs
(
"
http
"
)
)
{
return
principal
.
forget
(
)
;
}
nsAutoCString
spec
;
aPrincipal
-
>
GetAsciiSpec
(
spec
)
;
spec
.
ReplaceLiteral
(
0
4
"
https
"
)
;
nsCOMPtr
<
nsIURI
>
newURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
newURI
)
spec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
mozilla
:
:
OriginAttributes
OA
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
-
>
OriginAttributesRef
(
)
;
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
newURI
OA
)
;
return
principal
.
forget
(
)
;
}
bool
nsContentSecurityUtils
:
:
IsConsideredSameOriginForUIR
(
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aResultPrincipal
)
{
MOZ_ASSERT
(
aTriggeringPrincipal
)
;
MOZ_ASSERT
(
aResultPrincipal
)
;
if
(
aTriggeringPrincipal
-
>
Equals
(
aResultPrincipal
)
)
{
return
true
;
}
nsCOMPtr
<
nsIPrincipal
>
compareTriggeringPrincipal
=
MakeHTTPPrincipalHTTPS
(
aTriggeringPrincipal
)
;
nsCOMPtr
<
nsIPrincipal
>
compareResultPrincipal
=
MakeHTTPPrincipalHTTPS
(
aResultPrincipal
)
;
return
compareTriggeringPrincipal
-
>
Equals
(
compareResultPrincipal
)
;
}
nsresult
RegexEval
(
const
nsAString
&
aPattern
const
nsAString
&
aString
bool
aOnlyMatch
bool
&
aMatchResult
nsTArray
<
nsString
>
*
aRegexResults
=
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aMatchResult
=
false
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
AutoDisableJSInterruptCallback
disabler
(
cx
)
;
JSAutoRealm
ar
(
cx
xpc
:
:
PrivilegedJunkScope
(
)
)
;
JS
:
:
RootedObject
regexp
(
cx
JS
:
:
NewUCRegExpObject
(
cx
aPattern
.
BeginReading
(
)
aPattern
.
Length
(
)
JS
:
:
RegExpFlag
:
:
Unicode
)
)
;
if
(
!
regexp
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
JS
:
:
RootedValue
regexResult
(
cx
JS
:
:
NullValue
(
)
)
;
size_t
index
=
0
;
if
(
!
JS
:
:
ExecuteRegExpNoStatics
(
cx
regexp
aString
.
BeginReading
(
)
aString
.
Length
(
)
&
index
aOnlyMatch
&
regexResult
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
regexResult
.
isNull
(
)
)
{
return
NS_OK
;
}
if
(
aOnlyMatch
)
{
MOZ_ASSERT
(
regexResult
.
isBoolean
(
)
&
&
regexResult
.
toBoolean
(
)
)
;
aMatchResult
=
true
;
return
NS_OK
;
}
if
(
aRegexResults
=
=
nullptr
)
{
return
NS_ERROR_INVALID_ARG
;
}
uint32_t
length
;
JS
:
:
RootedObject
regexResultObj
(
cx
&
regexResult
.
toObject
(
)
)
;
if
(
!
JS
:
:
GetArrayLength
(
cx
regexResultObj
&
length
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Regex
Matched
%
i
strings
"
length
)
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
JS
:
:
RootedValue
element
(
cx
)
;
if
(
!
JS_GetElement
(
cx
regexResultObj
i
&
element
)
)
{
return
NS_ERROR_NO_CONTENT
;
}
nsAutoJSString
value
;
if
(
!
value
.
init
(
cx
element
)
)
{
return
NS_ERROR_NO_CONTENT
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Regex
Matching
:
%
i
:
%
s
"
i
NS_ConvertUTF16toUTF8
(
value
)
.
get
(
)
)
)
;
aRegexResults
-
>
AppendElement
(
value
)
;
}
aMatchResult
=
true
;
return
NS_OK
;
}
nsString
OptimizeFileName
(
const
nsAString
&
aFileName
)
{
nsString
optimizedName
(
aFileName
)
;
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Optimizing
FileName
:
%
s
"
NS_ConvertUTF16toUTF8
(
optimizedName
)
.
get
(
)
)
)
;
optimizedName
.
ReplaceSubstring
(
u
"
.
xpi
!
"
_ns
u
"
!
"
_ns
)
;
optimizedName
.
ReplaceSubstring
(
u
"
shield
.
mozilla
.
org
!
"
_ns
u
"
s
!
"
_ns
)
;
optimizedName
.
ReplaceSubstring
(
u
"
mozilla
.
org
!
"
_ns
u
"
m
!
"
_ns
)
;
if
(
optimizedName
.
Length
(
)
>
80
)
{
optimizedName
.
Truncate
(
80
)
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Optimized
FileName
:
%
s
"
NS_ConvertUTF16toUTF8
(
optimizedName
)
.
get
(
)
)
)
;
return
optimizedName
;
}
FilenameTypeAndDetails
nsContentSecurityUtils
:
:
FilenameToFilenameType
(
const
nsString
&
fileName
bool
collectAdditionalExtensionData
)
{
static
constexpr
auto
kChromeURI
=
"
chromeuri
"
_ns
;
static
constexpr
auto
kResourceURI
=
"
resourceuri
"
_ns
;
static
constexpr
auto
kBlobUri
=
"
bloburi
"
_ns
;
static
constexpr
auto
kDataUri
=
"
dataurl
"
_ns
;
static
constexpr
auto
kSingleString
=
"
singlestring
"
_ns
;
static
constexpr
auto
kMozillaExtension
=
"
mozillaextension
"
_ns
;
static
constexpr
auto
kOtherExtension
=
"
otherextension
"
_ns
;
static
constexpr
auto
kSuspectedUserChromeJS
=
"
suspectedUserChromeJS
"
_ns
;
#
if
defined
(
XP_WIN
)
static
constexpr
auto
kSanitizedWindowsURL
=
"
sanitizedWindowsURL
"
_ns
;
static
constexpr
auto
kSanitizedWindowsPath
=
"
sanitizedWindowsPath
"
_ns
;
#
endif
static
constexpr
auto
kOther
=
"
other
"
_ns
;
static
constexpr
auto
kOtherWorker
=
"
other
-
on
-
worker
"
_ns
;
static
constexpr
auto
kRegexFailure
=
"
regexfailure
"
_ns
;
static
constexpr
auto
kUCJSRegex
=
u
"
(
.
+
)
.
uc
.
js
\
\
?
*
[
0
-
9
]
*
"
_ns
;
static
constexpr
auto
kExtensionRegex
=
u
"
extensions
/
(
.
+
)
(
.
+
)
!
(
.
+
)
"
_ns
;
static
constexpr
auto
kSingleFileRegex
=
u
"
^
[
a
-
zA
-
Z0
-
9
.
?
]
+
"
_ns
;
if
(
fileName
.
IsEmpty
(
)
)
{
return
FilenameTypeAndDetails
(
kOther
Nothing
(
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
chrome
:
/
/
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kChromeURI
Some
(
fileName
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
resource
:
/
/
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kResourceURI
Some
(
fileName
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
blob
:
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kBlobUri
Nothing
(
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
data
:
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kDataUri
Nothing
(
)
)
;
}
if
(
!
NS_IsMainThread
(
)
)
{
return
FilenameTypeAndDetails
(
kOtherWorker
Nothing
(
)
)
;
}
bool
regexMatch
;
nsTArray
<
nsString
>
regexResults
;
nsresult
rv
=
RegexEval
(
kExtensionRegex
fileName
false
regexMatch
&
regexResults
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kRegexFailure
Nothing
(
)
)
;
}
if
(
regexMatch
)
{
nsCString
type
=
StringEndsWith
(
regexResults
[
2
]
u
"
mozilla
.
org
.
xpi
"
_ns
)
?
kMozillaExtension
:
kOtherExtension
;
auto
&
extensionNameAndPath
=
Substring
(
regexResults
[
0
]
ArrayLength
(
"
extensions
/
"
)
-
1
)
;
return
FilenameTypeAndDetails
(
type
Some
(
OptimizeFileName
(
extensionNameAndPath
)
)
)
;
}
rv
=
RegexEval
(
kSingleFileRegex
fileName
true
regexMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kRegexFailure
Nothing
(
)
)
;
}
if
(
regexMatch
)
{
return
FilenameTypeAndDetails
(
kSingleString
Some
(
fileName
)
)
;
}
rv
=
RegexEval
(
kUCJSRegex
fileName
true
regexMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kRegexFailure
Nothing
(
)
)
;
}
if
(
regexMatch
)
{
return
FilenameTypeAndDetails
(
kSuspectedUserChromeJS
Nothing
(
)
)
;
}
#
if
defined
(
XP_WIN
)
auto
flags
=
mozilla
:
:
widget
:
:
WinUtils
:
:
PathTransformFlags
:
:
Default
|
mozilla
:
:
widget
:
:
WinUtils
:
:
PathTransformFlags
:
:
RequireFilePath
;
nsAutoString
strSanitizedPath
(
fileName
)
;
if
(
widget
:
:
WinUtils
:
:
PreparePathForTelemetry
(
strSanitizedPath
flags
)
)
{
DWORD
cchDecodedUrl
=
INTERNET_MAX_URL_LENGTH
;
WCHAR
szOut
[
INTERNET_MAX_URL_LENGTH
]
;
HRESULT
hr
;
SAFECALL_URLMON_FUNC
(
CoInternetParseUrl
fileName
.
get
(
)
PARSE_SCHEMA
0
szOut
INTERNET_MAX_URL_LENGTH
&
cchDecodedUrl
0
)
;
if
(
hr
=
=
S_OK
&
&
cchDecodedUrl
)
{
nsAutoString
sanitizedPathAndScheme
;
sanitizedPathAndScheme
.
Append
(
szOut
)
;
if
(
sanitizedPathAndScheme
=
=
u
"
file
"
_ns
)
{
sanitizedPathAndScheme
.
Append
(
u
"
:
/
/
.
.
.
/
"
_ns
)
;
sanitizedPathAndScheme
.
Append
(
strSanitizedPath
)
;
}
else
if
(
sanitizedPathAndScheme
=
=
u
"
moz
-
extension
"
_ns
&
&
collectAdditionalExtensionData
)
{
sanitizedPathAndScheme
.
Append
(
u
"
:
/
/
[
"
_ns
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kSanitizedWindowsURL
Some
(
sanitizedPathAndScheme
)
)
;
}
mozilla
:
:
extensions
:
:
URLInfo
url
(
uri
)
;
if
(
NS_IsMainThread
(
)
)
{
auto
*
policy
=
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetByHost
(
url
.
Host
(
)
)
;
if
(
policy
)
{
nsString
addOnId
;
policy
-
>
GetId
(
addOnId
)
;
sanitizedPathAndScheme
.
Append
(
addOnId
)
;
sanitizedPathAndScheme
.
Append
(
u
"
:
"
_ns
)
;
sanitizedPathAndScheme
.
Append
(
policy
-
>
Name
(
)
)
;
}
else
{
sanitizedPathAndScheme
.
Append
(
u
"
failed
finding
addon
by
host
"
_ns
)
;
}
}
else
{
sanitizedPathAndScheme
.
Append
(
u
"
can
'
t
get
addon
off
main
thread
"
_ns
)
;
}
sanitizedPathAndScheme
.
Append
(
u
"
]
"
_ns
)
;
sanitizedPathAndScheme
.
Append
(
url
.
FilePath
(
)
)
;
}
return
FilenameTypeAndDetails
(
kSanitizedWindowsURL
Some
(
sanitizedPathAndScheme
)
)
;
}
else
{
return
FilenameTypeAndDetails
(
kSanitizedWindowsPath
Some
(
strSanitizedPath
)
)
;
}
}
#
endif
return
FilenameTypeAndDetails
(
kOther
Nothing
(
)
)
;
}
class
EvalUsageNotificationRunnable
final
:
public
Runnable
{
public
:
EvalUsageNotificationRunnable
(
bool
aIsSystemPrincipal
NS_ConvertUTF8toUTF16
&
aFileNameA
uint64_t
aWindowID
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
:
mozilla
:
:
Runnable
(
"
EvalUsageNotificationRunnable
"
)
mIsSystemPrincipal
(
aIsSystemPrincipal
)
mFileNameA
(
aFileNameA
)
mWindowID
(
aWindowID
)
mLineNumber
(
aLineNumber
)
mColumnNumber
(
aColumnNumber
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsContentSecurityUtils
:
:
NotifyEvalUsage
(
mIsSystemPrincipal
mFileNameA
mWindowID
mLineNumber
mColumnNumber
)
;
return
NS_OK
;
}
void
Revoke
(
)
{
}
private
:
bool
mIsSystemPrincipal
;
NS_ConvertUTF8toUTF16
mFileNameA
;
uint64_t
mWindowID
;
uint32_t
mLineNumber
;
uint32_t
mColumnNumber
;
}
;
bool
nsContentSecurityUtils
:
:
IsEvalAllowed
(
JSContext
*
cx
bool
aIsSystemPrincipal
const
nsAString
&
aScript
)
{
static
nsLiteralCString
evalAllowlist
[
]
=
{
"
resource
:
/
/
testing
-
common
/
sinon
-
7
.
2
.
7
.
js
"
_ns
"
resource
:
/
/
testing
-
common
/
ajv
-
4
.
1
.
1
.
js
"
_ns
"
resource
:
/
/
testing
-
common
/
content
-
task
.
js
"
_ns
"
resource
:
/
/
/
modules
/
translation
/
cld
-
worker
.
js
"
_ns
"
resource
:
/
/
gre
/
modules
/
workers
/
require
.
js
"
_ns
"
debugger
"
_ns
}
;
static
constexpr
auto
sAllowedEval1
=
u
"
this
"
_ns
;
static
constexpr
auto
sAllowedEval2
=
u
"
function
anonymous
(
\
n
)
{
\
nreturn
this
\
n
}
"
_ns
;
if
(
MOZ_LIKELY
(
!
aIsSystemPrincipal
&
&
!
XRE_IsE10sParentProcess
(
)
)
)
{
return
true
;
}
if
(
JS
:
:
ContextOptionsRef
(
cx
)
.
disableEvalSecurityChecks
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
because
this
JSContext
was
set
to
allow
it
"
)
)
;
return
true
;
}
if
(
aIsSystemPrincipal
&
&
StaticPrefs
:
:
security_allow_eval_with_system_principal
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
with
System
Principal
because
allowing
pref
is
"
"
enabled
"
)
)
;
return
true
;
}
if
(
XRE_IsE10sParentProcess
(
)
&
&
StaticPrefs
:
:
security_allow_eval_in_parent_process
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
in
parent
process
because
allowing
pref
is
"
"
enabled
"
)
)
;
return
true
;
}
if
(
NS_IsMainThread
(
)
)
{
nsAutoString
jsConfigPref
;
Preferences
:
:
GetString
(
"
general
.
config
.
filename
"
jsConfigPref
)
;
if
(
!
jsConfigPref
.
IsEmpty
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
%
s
because
of
"
"
general
.
config
.
filename
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
)
)
;
return
true
;
}
}
if
(
XRE_IsE10sParentProcess
(
)
&
&
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
in
parent
process
because
the
web
extension
"
"
process
is
disabled
"
)
)
;
return
true
;
}
if
(
!
aScript
.
IsEmpty
(
)
&
&
(
aScript
=
=
sAllowedEval1
|
|
aScript
=
=
sAllowedEval2
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
%
s
because
a
key
string
is
"
"
provided
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
)
)
;
return
true
;
}
nsAutoCString
fileName
;
uint32_t
lineNumber
=
0
columnNumber
=
0
;
nsJSUtils
:
:
GetCallingLocation
(
cx
fileName
&
lineNumber
&
columnNumber
)
;
if
(
fileName
.
IsEmpty
(
)
)
{
fileName
=
"
unknown
-
file
"
_ns
;
}
NS_ConvertUTF8toUTF16
fileNameA
(
fileName
)
;
for
(
const
nsLiteralCString
&
allowlistEntry
:
evalAllowlist
)
{
if
(
StringBeginsWith
(
fileName
allowlistEntry
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
%
s
because
the
containing
"
"
file
is
in
the
allowlist
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
)
)
;
return
true
;
}
}
uint64_t
windowID
=
nsJSUtils
:
:
GetCurrentlyRunningCodeInnerWindowID
(
cx
)
;
if
(
NS_IsMainThread
(
)
)
{
nsContentSecurityUtils
:
:
NotifyEvalUsage
(
aIsSystemPrincipal
fileNameA
windowID
lineNumber
columnNumber
)
;
}
else
{
auto
runnable
=
new
EvalUsageNotificationRunnable
(
aIsSystemPrincipal
fileNameA
windowID
lineNumber
columnNumber
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Warning
(
"
Blocking
eval
(
)
%
s
from
file
%
s
and
script
"
"
provided
%
s
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
fileName
.
get
(
)
NS_ConvertUTF16toUTF8
(
aScript
)
.
get
(
)
)
)
;
#
ifdef
DEBUG
if
(
fileName
.
Length
(
)
>
475
)
{
fileName
.
SetLength
(
475
)
;
}
nsAutoCString
trimmedScript
=
NS_ConvertUTF16toUTF8
(
aScript
)
;
if
(
trimmedScript
.
Length
(
)
>
475
)
{
trimmedScript
.
SetLength
(
475
)
;
}
MOZ_CRASH_UNSAFE_PRINTF
(
"
Blocking
eval
(
)
%
s
from
file
%
s
and
script
provided
"
"
%
s
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
fileName
.
get
(
)
trimmedScript
.
get
(
)
)
;
#
endif
return
false
;
}
void
nsContentSecurityUtils
:
:
NotifyEvalUsage
(
bool
aIsSystemPrincipal
NS_ConvertUTF8toUTF16
&
aFileNameA
uint64_t
aWindowID
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
{
Telemetry
:
:
EventID
eventType
=
aIsSystemPrincipal
?
Telemetry
:
:
EventID
:
:
Security_Evalusage_Systemcontext
:
Telemetry
:
:
EventID
:
:
Security_Evalusage_Parentprocess
;
FilenameTypeAndDetails
fileNameTypeAndDetails
=
FilenameToFilenameType
(
aFileNameA
false
)
;
mozilla
:
:
Maybe
<
nsTArray
<
EventExtraEntry
>
>
extra
;
if
(
fileNameTypeAndDetails
.
second
.
isSome
(
)
)
{
extra
=
Some
<
nsTArray
<
EventExtraEntry
>
>
(
{
EventExtraEntry
{
"
fileinfo
"
_ns
NS_ConvertUTF16toUTF8
(
fileNameTypeAndDetails
.
second
.
value
(
)
)
}
}
)
;
}
else
{
extra
=
Nothing
(
)
;
}
if
(
!
sTelemetryEventEnabled
.
exchange
(
true
)
)
{
sTelemetryEventEnabled
=
true
;
Telemetry
:
:
SetEventRecordingEnabled
(
"
security
"
_ns
true
)
;
}
Telemetry
:
:
RecordEvent
(
eventType
mozilla
:
:
Some
(
fileNameTypeAndDetails
.
first
)
extra
)
;
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
)
;
if
(
!
console
)
{
return
;
}
nsCOMPtr
<
nsIScriptError
>
error
(
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
)
;
if
(
!
error
)
{
return
;
}
nsCOMPtr
<
nsIStringBundle
>
bundle
;
nsCOMPtr
<
nsIStringBundleService
>
stringService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
if
(
!
stringService
)
{
return
;
}
stringService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
security
/
security
.
properties
"
getter_AddRefs
(
bundle
)
)
;
if
(
!
bundle
)
{
return
;
}
nsAutoString
message
;
AutoTArray
<
nsString
1
>
formatStrings
=
{
aFileNameA
}
;
nsresult
rv
=
bundle
-
>
FormatStringFromName
(
"
RestrictBrowserEvalUsage
"
formatStrings
message
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
error
-
>
InitWithWindowID
(
message
aFileNameA
EmptyString
(
)
aLineNumber
aColumnNumber
nsIScriptError
:
:
errorFlag
"
BrowserEvalUsage
"
aWindowID
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
console
-
>
LogMessage
(
error
)
;
}
nsresult
nsContentSecurityUtils
:
:
GetHttpChannelFromPotentialMultiPart
(
nsIChannel
*
aChannel
nsIHttpChannel
*
*
aHttpChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIMultiPartChannel
>
multipart
=
do_QueryInterface
(
aChannel
)
;
if
(
!
multipart
)
{
*
aHttpChannel
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
baseChannel
;
nsresult
rv
=
multipart
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
httpChannel
=
do_QueryInterface
(
baseChannel
)
;
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
nsresult
ParseCSPAndEnforceFrameAncestorCheck
(
nsIChannel
*
aChannel
nsIContentSecurityPolicy
*
*
aOutCSP
)
{
MOZ_ASSERT
(
aChannel
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
nsresult
rv
=
nsContentSecurityUtils
:
:
GetHttpChannelFromPotentialMultiPart
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
httpChannel
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsContentPolicyType
contentType
=
loadInfo
-
>
GetExternalContentPolicyType
(
)
;
if
(
contentType
!
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
&
&
contentType
!
=
nsIContentPolicy
:
:
TYPE_OBJECT
)
{
return
NS_OK
;
}
nsAutoCString
tCspHeaderValue
tCspROHeaderValue
;
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
"
content
-
security
-
policy
"
_ns
tCspHeaderValue
)
;
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
"
content
-
security
-
policy
-
report
-
only
"
_ns
tCspROHeaderValue
)
;
if
(
tCspHeaderValue
.
IsEmpty
(
)
&
&
tCspROHeaderValue
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
NS_ConvertASCIItoUTF16
cspHeaderValue
(
tCspHeaderValue
)
;
NS_ConvertASCIItoUTF16
cspROHeaderValue
(
tCspROHeaderValue
)
;
RefPtr
<
nsCSPContext
>
csp
=
new
nsCSPContext
(
)
;
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
resultPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
selfURI
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
selfURI
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
httpChannel
-
>
GetReferrerInfo
(
)
;
nsAutoString
referrerSpec
;
if
(
referrerInfo
)
{
referrerInfo
-
>
GetComputedReferrerSpec
(
referrerSpec
)
;
}
uint64_t
innerWindowID
=
loadInfo
-
>
GetInnerWindowID
(
)
;
rv
=
csp
-
>
SetRequestContextWithPrincipal
(
resultPrincipal
selfURI
referrerSpec
innerWindowID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
cspHeaderValue
.
IsEmpty
(
)
)
{
rv
=
CSP_AppendCSPFromHeader
(
csp
cspHeaderValue
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
cspROHeaderValue
.
IsEmpty
(
)
)
{
rv
=
CSP_AppendCSPFromHeader
(
csp
cspROHeaderValue
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
bool
safeAncestry
=
false
;
rv
=
csp
-
>
PermitsAncestry
(
loadInfo
&
safeAncestry
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
safeAncestry
)
{
aChannel
-
>
Cancel
(
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
)
;
return
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
;
}
csp
.
forget
(
aOutCSP
)
;
return
NS_OK
;
}
void
EnforceXFrameOptionsCheck
(
nsIChannel
*
aChannel
nsIContentSecurityPolicy
*
aCsp
)
{
MOZ_ASSERT
(
aChannel
)
;
if
(
!
FramingChecker
:
:
CheckFrameOptions
(
aChannel
aCsp
)
)
{
aChannel
-
>
Cancel
(
NS_ERROR_XFO_VIOLATION
)
;
}
}
void
nsContentSecurityUtils
:
:
PerformCSPFrameAncestorAndXFOCheck
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
nsresult
rv
=
ParseCSPAndEnforceFrameAncestorCheck
(
aChannel
getter_AddRefs
(
csp
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
EnforceXFrameOptionsCheck
(
aChannel
csp
)
;
}
#
if
defined
(
DEBUG
)
void
nsContentSecurityUtils
:
:
AssertAboutPageHasCSP
(
Document
*
aDocument
)
{
if
(
StaticPrefs
:
:
dom_security_skip_about_page_has_csp_assert
(
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
documentURI
=
aDocument
-
>
GetDocumentURI
(
)
;
if
(
!
documentURI
-
>
SchemeIs
(
"
about
"
)
)
{
return
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
bool
foundDefaultSrc
=
false
;
bool
foundObjectSrc
=
false
;
bool
foundUnsafeEval
=
false
;
bool
foundUnsafeInline
=
false
;
bool
foundScriptSrc
=
false
;
bool
foundWorkerSrc
=
false
;
bool
foundWebScheme
=
false
;
if
(
csp
)
{
uint32_t
policyCount
=
0
;
csp
-
>
GetPolicyCount
(
&
policyCount
)
;
nsAutoString
parsedPolicyStr
;
for
(
uint32_t
i
=
0
;
i
<
policyCount
;
+
+
i
)
{
csp
-
>
GetPolicyString
(
i
parsedPolicyStr
)
;
if
(
parsedPolicyStr
.
Find
(
"
default
-
src
"
)
>
=
0
)
{
foundDefaultSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
"
object
-
src
'
none
'
"
)
>
=
0
)
{
foundObjectSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
"
'
unsafe
-
eval
'
"
)
>
=
0
)
{
foundUnsafeEval
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
"
'
unsafe
-
inline
'
"
)
>
=
0
)
{
foundUnsafeInline
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
"
script
-
src
"
)
>
=
0
)
{
foundScriptSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
"
worker
-
src
"
)
>
=
0
)
{
foundWorkerSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
"
http
:
"
)
>
=
0
|
|
parsedPolicyStr
.
Find
(
"
https
:
"
)
>
=
0
)
{
foundWebScheme
=
true
;
}
}
}
if
(
StaticPrefs
:
:
dom_security_skip_about_page_csp_allowlist_and_assert
(
)
)
{
NS_ASSERTION
(
foundDefaultSrc
"
about
:
page
must
have
a
CSP
"
)
;
return
;
}
nsAutoCString
aboutSpec
;
documentURI
-
>
GetSpec
(
aboutSpec
)
;
ToLowerCase
(
aboutSpec
)
;
static
nsLiteralCString
sAllowedAboutPagesWithNoCSP
[
]
=
{
"
about
:
blank
"
_ns
"
about
:
srcdoc
"
_ns
"
about
:
sync
-
log
"
_ns
"
about
:
printpreview
"
_ns
"
about
:
logo
"
_ns
#
if
defined
(
ANDROID
)
"
about
:
config
"
_ns
#
endif
}
;
for
(
const
nsLiteralCString
&
allowlistEntry
:
sAllowedAboutPagesWithNoCSP
)
{
if
(
StringBeginsWith
(
aboutSpec
allowlistEntry
)
)
{
return
;
}
}
MOZ_ASSERT
(
foundDefaultSrc
"
about
:
page
must
contain
a
CSP
including
default
-
src
"
)
;
MOZ_ASSERT
(
foundObjectSrc
"
about
:
page
must
contain
a
CSP
denying
object
-
src
"
)
;
MOZ_ASSERT
(
!
foundScriptSrc
|
|
StringBeginsWith
(
aboutSpec
"
about
:
preferences
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
downloads
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
newtab
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
logins
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
compat
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
welcome
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
profiling
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
studies
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
home
"
_ns
)
"
about
:
page
must
not
contain
a
CSP
including
script
-
src
"
)
;
MOZ_ASSERT
(
!
foundWorkerSrc
"
about
:
page
must
not
contain
a
CSP
including
worker
-
src
"
)
;
MOZ_ASSERT
(
!
foundWebScheme
|
|
StringBeginsWith
(
aboutSpec
"
about
:
preferences
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
addons
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
newtab
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
debugging
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
newinstall
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
ion
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
compat
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
logins
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
home
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
welcome
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
devtools
"
_ns
)
"
about
:
page
must
not
contain
a
CSP
including
a
web
scheme
"
)
;
if
(
aDocument
-
>
IsExtensionPage
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
foundUnsafeEval
"
about
:
page
must
not
contain
a
CSP
including
'
unsafe
-
eval
'
"
)
;
static
nsLiteralCString
sLegacyUnsafeInlineAllowList
[
]
=
{
"
about
:
preferences
"
_ns
"
about
:
addons
"
_ns
"
about
:
newtab
"
_ns
"
about
:
welcome
"
_ns
"
about
:
home
"
_ns
}
;
for
(
const
nsLiteralCString
&
aUnsafeInlineEntry
:
sLegacyUnsafeInlineAllowList
)
{
if
(
StringBeginsWith
(
aboutSpec
aUnsafeInlineEntry
)
)
{
return
;
}
}
MOZ_ASSERT
(
!
foundUnsafeInline
"
about
:
page
must
not
contain
a
CSP
including
'
unsafe
-
inline
'
"
)
;
}
#
endif
bool
nsContentSecurityUtils
:
:
ValidateScriptFilename
(
const
char
*
aFilename
bool
aIsSystemRealm
)
{
static
Maybe
<
bool
>
sGeneralConfigFilenameSet
;
if
(
StaticPrefs
:
:
security_allow_parent_unrestricted_js_loads
(
)
)
{
return
true
;
}
if
(
!
XRE_IsE10sParentProcess
(
)
)
{
return
true
;
}
if
(
NS_IsMainThread
(
)
)
{
if
(
!
sGeneralConfigFilenameSet
.
isSome
(
)
)
{
nsAutoString
jsConfigPref
;
Preferences
:
:
GetString
(
"
general
.
config
.
filename
"
jsConfigPref
)
;
sGeneralConfigFilenameSet
.
emplace
(
!
jsConfigPref
.
IsEmpty
(
)
)
;
}
if
(
sGeneralConfigFilenameSet
.
value
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
a
javascript
load
of
%
s
because
"
"
general
.
config
.
filename
is
set
"
aFilename
)
)
;
return
true
;
}
}
if
(
XRE_IsE10sParentProcess
(
)
&
&
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
a
javascript
load
of
%
s
because
the
web
extension
"
"
process
is
disabled
.
"
aFilename
)
)
;
return
true
;
}
NS_ConvertUTF8toUTF16
filenameU
(
aFilename
)
;
if
(
StringBeginsWith
(
filenameU
u
"
chrome
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
resource
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
file
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
jar
:
file
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
filenameU
.
Equals
(
u
"
about
:
sync
-
log
"
_ns
)
)
{
return
true
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Info
(
"
ValidateScriptFilename
System
:
%
i
%
s
\
n
"
(
aIsSystemRealm
?
1
:
0
)
aFilename
)
)
;
FilenameTypeAndDetails
fileNameTypeAndDetails
=
FilenameToFilenameType
(
filenameU
true
)
;
Telemetry
:
:
EventID
eventType
=
Telemetry
:
:
EventID
:
:
Security_Javascriptload_Parentprocess
;
mozilla
:
:
Maybe
<
nsTArray
<
EventExtraEntry
>
>
extra
;
if
(
fileNameTypeAndDetails
.
second
.
isSome
(
)
)
{
extra
=
Some
<
nsTArray
<
EventExtraEntry
>
>
(
{
EventExtraEntry
{
"
fileinfo
"
_ns
NS_ConvertUTF16toUTF8
(
fileNameTypeAndDetails
.
second
.
value
(
)
)
}
}
)
;
}
else
{
extra
=
Nothing
(
)
;
}
if
(
!
sTelemetryEventEnabled
.
exchange
(
true
)
)
{
sTelemetryEventEnabled
=
true
;
Telemetry
:
:
SetEventRecordingEnabled
(
"
security
"
_ns
true
)
;
}
Telemetry
:
:
RecordEvent
(
eventType
mozilla
:
:
Some
(
fileNameTypeAndDetails
.
first
)
extra
)
;
return
true
;
}
void
nsContentSecurityUtils
:
:
LogMessageToConsole
(
nsIHttpChannel
*
aChannel
const
char
*
aMsg
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
uint64_t
windowID
=
0
;
rv
=
aChannel
-
>
GetTopLevelContentWindowId
(
&
windowID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
!
windowID
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
loadInfo
-
>
GetInnerWindowID
(
&
windowID
)
;
}
nsAutoString
localizedMsg
;
nsAutoCString
spec
;
uri
-
>
GetSpec
(
spec
)
;
AutoTArray
<
nsString
1
>
params
=
{
NS_ConvertUTF8toUTF16
(
spec
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eSECURITY_PROPERTIES
aMsg
params
localizedMsg
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsContentUtils
:
:
ReportToConsoleByWindowID
(
localizedMsg
nsIScriptError
:
:
warningFlag
"
Security
"
_ns
windowID
uri
)
;
}
long
nsContentSecurityUtils
:
:
ClassifyDownload
(
nsIChannel
*
aChannel
const
nsAutoCString
&
aMimeTypeGuess
)
{
MOZ_ASSERT
(
aChannel
"
IsDownloadAllowed
without
channel
?
"
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIURI
>
contentLocation
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
contentLocation
)
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
loadInfo
-
>
GetLoadingPrincipal
(
)
;
if
(
!
loadingPrincipal
)
{
loadingPrincipal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
loadingPrincipal
loadInfo
-
>
TriggeringPrincipal
(
)
nullptr
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
nsIContentPolicy
:
:
TYPE_SAVEAS_DOWNLOAD
)
;
int16_t
decission
=
nsIContentPolicy
:
:
ACCEPT
;
nsMixedContentBlocker
:
:
ShouldLoad
(
false
contentLocation
secCheckLoadInfo
aMimeTypeGuess
false
&
decission
)
;
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
MIXED_CONTENT_DOWNLOADS
decission
!
=
nsIContentPolicy
:
:
ACCEPT
)
;
if
(
StaticPrefs
:
:
dom_block_download_insecure
(
)
&
&
decission
!
=
nsIContentPolicy
:
:
ACCEPT
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
LogMessageToConsole
(
httpChannel
"
MixedContentBlockedDownload
"
)
;
}
return
nsITransfer
:
:
DOWNLOAD_POTENTIALLY_UNSAFE
;
}
if
(
loadInfo
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
return
nsITransfer
:
:
DOWNLOAD_ACCEPTABLE
;
}
if
(
!
StaticPrefs
:
:
dom_block_download_in_sandboxed_iframes
(
)
)
{
return
nsITransfer
:
:
DOWNLOAD_ACCEPTABLE
;
}
uint32_t
triggeringFlags
=
loadInfo
-
>
GetTriggeringSandboxFlags
(
)
;
uint32_t
currentflags
=
loadInfo
-
>
GetSandboxFlags
(
)
;
if
(
(
triggeringFlags
&
SANDBOXED_ALLOW_DOWNLOADS
)
|
|
(
currentflags
&
SANDBOXED_ALLOW_DOWNLOADS
)
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
LogMessageToConsole
(
httpChannel
"
IframeSandboxBlockedDownload
"
)
;
}
return
nsITransfer
:
:
DOWNLOAD_FORBIDDEN
;
}
return
nsITransfer
:
:
DOWNLOAD_ACCEPTABLE
;
}
