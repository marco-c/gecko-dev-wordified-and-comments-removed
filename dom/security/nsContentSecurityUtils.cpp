#
include
"
nsContentSecurityUtils
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsITransfer
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
mozilla
/
WinHeaderOnlyUtils
.
h
"
#
include
"
WinUtils
.
h
"
#
include
<
wininet
.
h
>
#
endif
#
include
"
FramingChecker
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
RegExp
.
h
"
#
include
"
js
/
RegExpFlags
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
LoadInfo
.
h
"
#
include
"
mozilla
/
StaticPrefs_extensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryComms
.
h
"
#
include
"
mozilla
/
TelemetryEventEnums
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIStringBundle
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
Telemetry
;
extern
mozilla
:
:
LazyLogModule
sCSMLog
;
extern
Atomic
<
bool
mozilla
:
:
Relaxed
>
sJSHacksChecked
;
extern
Atomic
<
bool
mozilla
:
:
Relaxed
>
sJSHacksPresent
;
extern
Atomic
<
bool
mozilla
:
:
Relaxed
>
sCSSHacksChecked
;
extern
Atomic
<
bool
mozilla
:
:
Relaxed
>
sCSSHacksPresent
;
extern
Atomic
<
bool
mozilla
:
:
Relaxed
>
sTelemetryEventEnabled
;
static
already_AddRefed
<
nsIPrincipal
>
MakeHTTPPrincipalHTTPS
(
nsIPrincipal
*
aPrincipal
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aPrincipal
;
if
(
!
principal
-
>
SchemeIs
(
"
http
"
)
)
{
return
principal
.
forget
(
)
;
}
nsAutoCString
spec
;
aPrincipal
-
>
GetAsciiSpec
(
spec
)
;
spec
.
ReplaceLiteral
(
0
4
"
https
"
)
;
nsCOMPtr
<
nsIURI
>
newURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
newURI
)
spec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
mozilla
:
:
OriginAttributes
OA
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
-
>
OriginAttributesRef
(
)
;
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
newURI
OA
)
;
return
principal
.
forget
(
)
;
}
bool
nsContentSecurityUtils
:
:
IsConsideredSameOriginForUIR
(
nsIPrincipal
*
aTriggeringPrincipal
nsIPrincipal
*
aResultPrincipal
)
{
MOZ_ASSERT
(
aTriggeringPrincipal
)
;
MOZ_ASSERT
(
aResultPrincipal
)
;
if
(
aTriggeringPrincipal
-
>
Equals
(
aResultPrincipal
)
)
{
return
true
;
}
nsCOMPtr
<
nsIPrincipal
>
compareTriggeringPrincipal
=
MakeHTTPPrincipalHTTPS
(
aTriggeringPrincipal
)
;
nsCOMPtr
<
nsIPrincipal
>
compareResultPrincipal
=
MakeHTTPPrincipalHTTPS
(
aResultPrincipal
)
;
return
compareTriggeringPrincipal
-
>
Equals
(
compareResultPrincipal
)
;
}
nsresult
RegexEval
(
const
nsAString
&
aPattern
const
nsAString
&
aString
bool
aOnlyMatch
bool
&
aMatchResult
nsTArray
<
nsString
>
*
aRegexResults
=
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aMatchResult
=
false
;
mozilla
:
:
dom
:
:
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
mozilla
:
:
AutoDisableJSInterruptCallback
disabler
(
cx
)
;
JSAutoRealm
ar
(
cx
xpc
:
:
PrivilegedJunkScope
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
regexp
(
cx
JS
:
:
NewUCRegExpObject
(
cx
aPattern
.
BeginReading
(
)
aPattern
.
Length
(
)
JS
:
:
RegExpFlag
:
:
Unicode
)
)
;
if
(
!
regexp
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
regexResult
(
cx
JS
:
:
NullValue
(
)
)
;
size_t
index
=
0
;
if
(
!
JS
:
:
ExecuteRegExpNoStatics
(
cx
regexp
aString
.
BeginReading
(
)
aString
.
Length
(
)
&
index
aOnlyMatch
&
regexResult
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
regexResult
.
isNull
(
)
)
{
return
NS_OK
;
}
if
(
aOnlyMatch
)
{
MOZ_ASSERT
(
regexResult
.
isBoolean
(
)
&
&
regexResult
.
toBoolean
(
)
)
;
aMatchResult
=
true
;
return
NS_OK
;
}
if
(
aRegexResults
=
=
nullptr
)
{
return
NS_ERROR_INVALID_ARG
;
}
uint32_t
length
;
JS
:
:
Rooted
<
JSObject
*
>
regexResultObj
(
cx
&
regexResult
.
toObject
(
)
)
;
if
(
!
JS
:
:
GetArrayLength
(
cx
regexResultObj
&
length
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Regex
Matched
%
i
strings
"
length
)
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
element
(
cx
)
;
if
(
!
JS_GetElement
(
cx
regexResultObj
i
&
element
)
)
{
return
NS_ERROR_NO_CONTENT
;
}
nsAutoJSString
value
;
if
(
!
value
.
init
(
cx
element
)
)
{
return
NS_ERROR_NO_CONTENT
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Regex
Matching
:
%
i
:
%
s
"
i
NS_ConvertUTF16toUTF8
(
value
)
.
get
(
)
)
)
;
aRegexResults
-
>
AppendElement
(
value
)
;
}
aMatchResult
=
true
;
return
NS_OK
;
}
char
*
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
const
char
*
str
)
{
return
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
strdup
(
str
)
)
;
}
char
*
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
char
*
str
)
{
auto
str_len
=
strlen
(
str
)
;
if
(
str_len
>
sPrintfCrashReasonSize
)
{
str
[
sPrintfCrashReasonSize
-
1
]
=
'
\
0
'
;
str_len
=
strlen
(
str
)
;
}
MOZ_RELEASE_ASSERT
(
sPrintfCrashReasonSize
>
str_len
)
;
return
str
;
}
nsCString
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
const
char
*
part1
const
char
*
part2
const
char
*
format_string
)
{
return
SmartFormatCrashString
(
strdup
(
part1
)
strdup
(
part2
)
format_string
)
;
}
nsCString
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
char
*
part1
char
*
part2
const
char
*
format_string
)
{
auto
part1_len
=
strlen
(
part1
)
;
auto
part2_len
=
strlen
(
part2
)
;
auto
constant_len
=
strlen
(
format_string
)
-
4
;
if
(
part1_len
+
part2_len
+
constant_len
>
sPrintfCrashReasonSize
)
{
if
(
part2_len
>
25
)
{
part2
+
=
(
part2_len
-
25
)
;
}
part2_len
=
strlen
(
part2
)
;
part1
[
sPrintfCrashReasonSize
-
(
constant_len
+
part2_len
+
1
)
]
=
'
\
0
'
;
part1_len
=
strlen
(
part1
)
;
}
MOZ_RELEASE_ASSERT
(
sPrintfCrashReasonSize
>
constant_len
+
part1_len
+
part2_len
)
;
auto
parts
=
nsPrintfCString
(
format_string
part1
part2
)
;
return
std
:
:
move
(
parts
)
;
}
nsString
OptimizeFileName
(
const
nsAString
&
aFileName
)
{
nsString
optimizedName
(
aFileName
)
;
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Optimizing
FileName
:
%
s
"
NS_ConvertUTF16toUTF8
(
optimizedName
)
.
get
(
)
)
)
;
optimizedName
.
ReplaceSubstring
(
u
"
.
xpi
!
"
_ns
u
"
!
"
_ns
)
;
optimizedName
.
ReplaceSubstring
(
u
"
shield
.
mozilla
.
org
!
"
_ns
u
"
s
!
"
_ns
)
;
optimizedName
.
ReplaceSubstring
(
u
"
mozilla
.
org
!
"
_ns
u
"
m
!
"
_ns
)
;
if
(
optimizedName
.
Length
(
)
>
80
)
{
optimizedName
.
Truncate
(
80
)
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Verbose
(
"
Optimized
FileName
:
%
s
"
NS_ConvertUTF16toUTF8
(
optimizedName
)
.
get
(
)
)
)
;
return
optimizedName
;
}
FilenameTypeAndDetails
nsContentSecurityUtils
:
:
FilenameToFilenameType
(
const
nsString
&
fileName
bool
collectAdditionalExtensionData
)
{
static
constexpr
auto
kChromeURI
=
"
chromeuri
"
_ns
;
static
constexpr
auto
kResourceURI
=
"
resourceuri
"
_ns
;
static
constexpr
auto
kBlobUri
=
"
bloburi
"
_ns
;
static
constexpr
auto
kDataUri
=
"
dataurl
"
_ns
;
static
constexpr
auto
kAboutUri
=
"
abouturi
"
_ns
;
static
constexpr
auto
kDataUriWebExtCStyle
=
"
dataurl
-
extension
-
contentstyle
"
_ns
;
static
constexpr
auto
kSingleString
=
"
singlestring
"
_ns
;
static
constexpr
auto
kMozillaExtensionFile
=
"
mozillaextension_file
"
_ns
;
static
constexpr
auto
kOtherExtensionFile
=
"
otherextension_file
"
_ns
;
static
constexpr
auto
kExtensionURI
=
"
extension_uri
"
_ns
;
static
constexpr
auto
kSuspectedUserChromeJS
=
"
suspectedUserChromeJS
"
_ns
;
#
if
defined
(
XP_WIN
)
static
constexpr
auto
kSanitizedWindowsURL
=
"
sanitizedWindowsURL
"
_ns
;
static
constexpr
auto
kSanitizedWindowsPath
=
"
sanitizedWindowsPath
"
_ns
;
#
endif
static
constexpr
auto
kOther
=
"
other
"
_ns
;
static
constexpr
auto
kOtherWorker
=
"
other
-
on
-
worker
"
_ns
;
static
constexpr
auto
kRegexFailure
=
"
regexfailure
"
_ns
;
static
constexpr
auto
kUCJSRegex
=
u
"
(
.
+
)
.
uc
.
js
\
\
?
*
[
0
-
9
]
*
"
_ns
;
static
constexpr
auto
kExtensionRegex
=
u
"
extensions
/
(
.
+
)
(
.
+
)
!
(
.
+
)
"
_ns
;
static
constexpr
auto
kSingleFileRegex
=
u
"
^
[
a
-
zA
-
Z0
-
9
.
?
]
+
"
_ns
;
if
(
fileName
.
IsEmpty
(
)
)
{
return
FilenameTypeAndDetails
(
kOther
Nothing
(
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
chrome
:
/
/
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kChromeURI
Some
(
fileName
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
resource
:
/
/
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kResourceURI
Some
(
fileName
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
blob
:
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kBlobUri
Nothing
(
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
data
:
text
/
css
;
extension
=
style
;
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kDataUriWebExtCStyle
Nothing
(
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
data
:
"
_ns
)
)
{
return
FilenameTypeAndDetails
(
kDataUri
Nothing
(
)
)
;
}
if
(
NS_IsMainThread
(
)
)
{
bool
regexMatch
;
nsTArray
<
nsString
>
regexResults
;
nsresult
rv
=
RegexEval
(
kExtensionRegex
fileName
false
regexMatch
&
regexResults
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kRegexFailure
Nothing
(
)
)
;
}
if
(
regexMatch
)
{
nsCString
type
=
StringEndsWith
(
regexResults
[
2
]
u
"
mozilla
.
org
.
xpi
"
_ns
)
?
kMozillaExtensionFile
:
kOtherExtensionFile
;
const
auto
&
extensionNameAndPath
=
Substring
(
regexResults
[
0
]
ArrayLength
(
"
extensions
/
"
)
-
1
)
;
return
FilenameTypeAndDetails
(
type
Some
(
OptimizeFileName
(
extensionNameAndPath
)
)
)
;
}
rv
=
RegexEval
(
kSingleFileRegex
fileName
true
regexMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kRegexFailure
Nothing
(
)
)
;
}
if
(
regexMatch
)
{
return
FilenameTypeAndDetails
(
kSingleString
Some
(
fileName
)
)
;
}
rv
=
RegexEval
(
kUCJSRegex
fileName
true
regexMatch
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kRegexFailure
Nothing
(
)
)
;
}
if
(
regexMatch
)
{
return
FilenameTypeAndDetails
(
kSuspectedUserChromeJS
Nothing
(
)
)
;
}
}
if
(
StringBeginsWith
(
fileName
u
"
about
:
"
_ns
)
)
{
long
int
desired_length
=
fileName
.
Length
(
)
;
long
int
possible_new_length
=
0
;
possible_new_length
=
fileName
.
FindChar
(
'
?
'
)
;
if
(
possible_new_length
!
=
-
1
&
&
possible_new_length
<
desired_length
)
{
desired_length
=
possible_new_length
;
}
possible_new_length
=
fileName
.
FindChar
(
'
#
'
)
;
if
(
possible_new_length
!
=
-
1
&
&
possible_new_length
<
desired_length
)
{
desired_length
=
possible_new_length
;
}
auto
subFileName
=
Substring
(
fileName
0
desired_length
)
;
return
FilenameTypeAndDetails
(
kAboutUri
Some
(
subFileName
)
)
;
}
if
(
StringBeginsWith
(
fileName
u
"
moz
-
extension
:
/
/
"
_ns
)
)
{
if
(
!
collectAdditionalExtensionData
)
{
return
FilenameTypeAndDetails
(
kExtensionURI
Nothing
(
)
)
;
}
nsAutoString
sanitizedPathAndScheme
;
sanitizedPathAndScheme
.
Append
(
u
"
moz
-
extension
:
/
/
[
"
_ns
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
fileName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
FilenameTypeAndDetails
(
kExtensionURI
Some
(
sanitizedPathAndScheme
)
)
;
}
mozilla
:
:
extensions
:
:
URLInfo
url
(
uri
)
;
if
(
NS_IsMainThread
(
)
)
{
auto
*
policy
=
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetByHost
(
url
.
Host
(
)
)
;
if
(
policy
)
{
nsString
addOnId
;
policy
-
>
GetId
(
addOnId
)
;
sanitizedPathAndScheme
.
Append
(
addOnId
)
;
sanitizedPathAndScheme
.
Append
(
u
"
:
"
_ns
)
;
sanitizedPathAndScheme
.
Append
(
policy
-
>
Name
(
)
)
;
sanitizedPathAndScheme
.
Append
(
u
"
]
"
_ns
)
;
if
(
policy
-
>
IsPrivileged
(
)
)
{
sanitizedPathAndScheme
.
Append
(
u
"
P
=
1
"
_ns
)
;
}
else
{
sanitizedPathAndScheme
.
Append
(
u
"
P
=
0
"
_ns
)
;
}
}
else
{
sanitizedPathAndScheme
.
Append
(
u
"
failed
finding
addon
by
host
]
"
_ns
)
;
}
}
else
{
sanitizedPathAndScheme
.
Append
(
u
"
can
'
t
get
addon
off
main
thread
]
"
_ns
)
;
}
AppendUTF8toUTF16
(
url
.
FilePath
(
)
sanitizedPathAndScheme
)
;
return
FilenameTypeAndDetails
(
kExtensionURI
Some
(
sanitizedPathAndScheme
)
)
;
}
#
if
defined
(
XP_WIN
)
auto
flags
=
mozilla
:
:
widget
:
:
WinUtils
:
:
PathTransformFlags
:
:
Default
|
mozilla
:
:
widget
:
:
WinUtils
:
:
PathTransformFlags
:
:
RequireFilePath
;
nsAutoString
strSanitizedPath
(
fileName
)
;
if
(
widget
:
:
WinUtils
:
:
PreparePathForTelemetry
(
strSanitizedPath
flags
)
)
{
DWORD
cchDecodedUrl
=
INTERNET_MAX_URL_LENGTH
;
WCHAR
szOut
[
INTERNET_MAX_URL_LENGTH
]
;
HRESULT
hr
;
SAFECALL_URLMON_FUNC
(
CoInternetParseUrl
fileName
.
get
(
)
PARSE_SCHEMA
0
szOut
INTERNET_MAX_URL_LENGTH
&
cchDecodedUrl
0
)
;
if
(
hr
=
=
S_OK
&
&
cchDecodedUrl
)
{
nsAutoString
sanitizedPathAndScheme
;
sanitizedPathAndScheme
.
Append
(
szOut
)
;
if
(
sanitizedPathAndScheme
=
=
u
"
file
"
_ns
)
{
sanitizedPathAndScheme
.
Append
(
u
"
:
/
/
.
.
.
/
"
_ns
)
;
sanitizedPathAndScheme
.
Append
(
strSanitizedPath
)
;
}
return
FilenameTypeAndDetails
(
kSanitizedWindowsURL
Some
(
sanitizedPathAndScheme
)
)
;
}
else
{
return
FilenameTypeAndDetails
(
kSanitizedWindowsPath
Some
(
strSanitizedPath
)
)
;
}
}
#
endif
if
(
!
NS_IsMainThread
(
)
)
{
return
FilenameTypeAndDetails
(
kOtherWorker
Nothing
(
)
)
;
}
return
FilenameTypeAndDetails
(
kOther
Nothing
(
)
)
;
}
#
ifdef
NIGHTLY_BUILD
void
PossiblyCrash
(
const
char
*
aPrefSuffix
const
char
*
aUnsafeCrashString
const
nsCString
&
aSafeCrashString
)
{
if
(
MOZ_UNLIKELY
(
!
XRE_IsParentProcess
(
)
)
)
{
return
;
}
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
nsCString
previous_crashes
(
"
security
.
crash_tracking
.
"
)
;
previous_crashes
.
Append
(
aPrefSuffix
)
;
previous_crashes
.
Append
(
"
.
prevCrashes
"
)
;
nsCString
max_crashes
(
"
security
.
crash_tracking
.
"
)
;
max_crashes
.
Append
(
aPrefSuffix
)
;
max_crashes
.
Append
(
"
.
maxCrashes
"
)
;
int32_t
numberOfPreviousCrashes
=
0
;
numberOfPreviousCrashes
=
Preferences
:
:
GetInt
(
previous_crashes
.
get
(
)
0
)
;
int32_t
maxAllowableCrashes
=
0
;
maxAllowableCrashes
=
Preferences
:
:
GetInt
(
max_crashes
.
get
(
)
0
)
;
if
(
numberOfPreviousCrashes
>
=
maxAllowableCrashes
)
{
return
;
}
nsresult
rv
=
Preferences
:
:
SetInt
(
previous_crashes
.
get
(
)
+
+
numberOfPreviousCrashes
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIPrefService
>
prefsCom
=
Preferences
:
:
GetService
(
)
;
Preferences
*
prefs
=
static_cast
<
Preferences
*
>
(
prefsCom
.
get
(
)
)
;
if
(
!
prefs
-
>
AllowOffMainThreadSave
(
)
)
{
return
;
}
rv
=
prefs
-
>
SavePrefFileBlocking
(
)
;
if
(
!
NS_FAILED
(
rv
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
%
s
"
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
aSafeCrashString
.
get
(
)
)
)
;
}
}
#
endif
class
EvalUsageNotificationRunnable
final
:
public
Runnable
{
public
:
EvalUsageNotificationRunnable
(
bool
aIsSystemPrincipal
NS_ConvertUTF8toUTF16
&
aFileNameA
uint64_t
aWindowID
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
:
mozilla
:
:
Runnable
(
"
EvalUsageNotificationRunnable
"
)
mIsSystemPrincipal
(
aIsSystemPrincipal
)
mFileNameA
(
aFileNameA
)
mWindowID
(
aWindowID
)
mLineNumber
(
aLineNumber
)
mColumnNumber
(
aColumnNumber
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsContentSecurityUtils
:
:
NotifyEvalUsage
(
mIsSystemPrincipal
mFileNameA
mWindowID
mLineNumber
mColumnNumber
)
;
return
NS_OK
;
}
void
Revoke
(
)
{
}
private
:
bool
mIsSystemPrincipal
;
NS_ConvertUTF8toUTF16
mFileNameA
;
uint64_t
mWindowID
;
uint32_t
mLineNumber
;
uint32_t
mColumnNumber
;
}
;
bool
nsContentSecurityUtils
:
:
IsEvalAllowed
(
JSContext
*
cx
bool
aIsSystemPrincipal
const
nsAString
&
aScript
)
{
static
nsLiteralCString
evalAllowlist
[
]
=
{
"
resource
:
/
/
testing
-
common
/
sinon
-
7
.
2
.
7
.
js
"
_ns
"
resource
:
/
/
testing
-
common
/
content
-
task
.
js
"
_ns
"
resource
:
/
/
gre
/
modules
/
translation
/
cld
-
worker
.
js
"
_ns
"
resource
:
/
/
gre
/
modules
/
workers
/
require
.
js
"
_ns
"
resource
:
/
/
devtools
/
client
/
performance
-
new
/
shared
/
symbolication
.
jsm
.
js
"
_ns
"
debugger
"
_ns
}
;
static
constexpr
auto
sAllowedEval1
=
u
"
this
"
_ns
;
static
constexpr
auto
sAllowedEval2
=
u
"
function
anonymous
(
\
n
)
{
\
nreturn
this
\
n
}
"
_ns
;
if
(
MOZ_LIKELY
(
!
aIsSystemPrincipal
&
&
!
XRE_IsE10sParentProcess
(
)
)
)
{
return
true
;
}
if
(
JS
:
:
ContextOptionsRef
(
cx
)
.
disableEvalSecurityChecks
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
because
this
JSContext
was
set
to
allow
it
"
)
)
;
return
true
;
}
if
(
aIsSystemPrincipal
&
&
StaticPrefs
:
:
security_allow_eval_with_system_principal
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
with
System
Principal
because
allowing
pref
is
"
"
enabled
"
)
)
;
return
true
;
}
if
(
XRE_IsE10sParentProcess
(
)
&
&
StaticPrefs
:
:
security_allow_eval_in_parent_process
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
in
parent
process
because
allowing
pref
is
"
"
enabled
"
)
)
;
return
true
;
}
DetectJsHacks
(
)
;
if
(
MOZ_UNLIKELY
(
sJSHacksPresent
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
%
s
because
some
"
"
JS
hacks
may
be
present
.
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
)
)
;
return
true
;
}
if
(
XRE_IsE10sParentProcess
(
)
&
&
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
in
parent
process
because
the
web
extension
"
"
process
is
disabled
"
)
)
;
return
true
;
}
if
(
!
aScript
.
IsEmpty
(
)
&
&
(
aScript
=
=
sAllowedEval1
|
|
aScript
=
=
sAllowedEval2
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
%
s
because
a
key
string
is
"
"
provided
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
)
)
;
return
true
;
}
nsAutoCString
fileName
;
uint32_t
lineNumber
=
0
columnNumber
=
0
;
nsJSUtils
:
:
GetCallingLocation
(
cx
fileName
&
lineNumber
&
columnNumber
)
;
if
(
fileName
.
IsEmpty
(
)
)
{
fileName
=
"
unknown
-
file
"
_ns
;
}
NS_ConvertUTF8toUTF16
fileNameA
(
fileName
)
;
for
(
const
nsLiteralCString
&
allowlistEntry
:
evalAllowlist
)
{
if
(
StringBeginsWith
(
fileName
allowlistEntry
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
eval
(
)
%
s
because
the
containing
"
"
file
is
in
the
allowlist
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
)
)
;
return
true
;
}
}
uint64_t
windowID
=
nsJSUtils
:
:
GetCurrentlyRunningCodeInnerWindowID
(
cx
)
;
if
(
NS_IsMainThread
(
)
)
{
nsContentSecurityUtils
:
:
NotifyEvalUsage
(
aIsSystemPrincipal
fileNameA
windowID
lineNumber
columnNumber
)
;
}
else
{
auto
runnable
=
new
EvalUsageNotificationRunnable
(
aIsSystemPrincipal
fileNameA
windowID
lineNumber
columnNumber
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Error
(
"
Blocking
eval
(
)
%
s
from
file
%
s
and
script
"
"
provided
%
s
"
(
aIsSystemPrincipal
?
"
with
System
Principal
"
:
"
in
parent
process
"
)
fileName
.
get
(
)
NS_ConvertUTF16toUTF8
(
aScript
)
.
get
(
)
)
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
auto
crashString
=
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
NS_ConvertUTF16toUTF8
(
aScript
)
.
get
(
)
fileName
.
get
(
)
(
aIsSystemPrincipal
?
"
Blocking
eval
(
)
with
System
Principal
with
script
%
s
from
file
%
s
"
:
"
Blocking
eval
(
)
in
parent
process
with
script
%
s
from
file
%
s
"
)
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
%
s
"
crashString
.
get
(
)
)
;
#
endif
return
false
;
}
void
nsContentSecurityUtils
:
:
NotifyEvalUsage
(
bool
aIsSystemPrincipal
NS_ConvertUTF8toUTF16
&
aFileNameA
uint64_t
aWindowID
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
{
Telemetry
:
:
EventID
eventType
=
aIsSystemPrincipal
?
Telemetry
:
:
EventID
:
:
Security_Evalusage_Systemcontext
:
Telemetry
:
:
EventID
:
:
Security_Evalusage_Parentprocess
;
FilenameTypeAndDetails
fileNameTypeAndDetails
=
FilenameToFilenameType
(
aFileNameA
false
)
;
mozilla
:
:
Maybe
<
nsTArray
<
EventExtraEntry
>
>
extra
;
if
(
fileNameTypeAndDetails
.
second
.
isSome
(
)
)
{
extra
=
Some
<
nsTArray
<
EventExtraEntry
>
>
(
{
EventExtraEntry
{
"
fileinfo
"
_ns
NS_ConvertUTF16toUTF8
(
fileNameTypeAndDetails
.
second
.
value
(
)
)
}
}
)
;
}
else
{
extra
=
Nothing
(
)
;
}
if
(
!
sTelemetryEventEnabled
.
exchange
(
true
)
)
{
sTelemetryEventEnabled
=
true
;
Telemetry
:
:
SetEventRecordingEnabled
(
"
security
"
_ns
true
)
;
}
Telemetry
:
:
RecordEvent
(
eventType
mozilla
:
:
Some
(
fileNameTypeAndDetails
.
first
)
extra
)
;
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
)
;
if
(
!
console
)
{
return
;
}
nsCOMPtr
<
nsIScriptError
>
error
(
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
)
;
if
(
!
error
)
{
return
;
}
nsCOMPtr
<
nsIStringBundle
>
bundle
;
nsCOMPtr
<
nsIStringBundleService
>
stringService
=
mozilla
:
:
components
:
:
StringBundle
:
:
Service
(
)
;
if
(
!
stringService
)
{
return
;
}
stringService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
security
/
security
.
properties
"
getter_AddRefs
(
bundle
)
)
;
if
(
!
bundle
)
{
return
;
}
nsAutoString
message
;
AutoTArray
<
nsString
1
>
formatStrings
=
{
aFileNameA
}
;
nsresult
rv
=
bundle
-
>
FormatStringFromName
(
"
RestrictBrowserEvalUsage
"
formatStrings
message
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
error
-
>
InitWithWindowID
(
message
aFileNameA
u
"
"
_ns
aLineNumber
aColumnNumber
nsIScriptError
:
:
errorFlag
"
BrowserEvalUsage
"
aWindowID
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
console
-
>
LogMessage
(
error
)
;
}
class
JSHackPrefObserver
final
{
public
:
JSHackPrefObserver
(
)
=
default
;
static
void
PrefChanged
(
const
char
*
aPref
void
*
aData
)
;
protected
:
~
JSHackPrefObserver
(
)
=
default
;
}
;
void
JSHackPrefObserver
:
:
PrefChanged
(
const
char
*
aPref
void
*
aData
)
{
sJSHacksChecked
=
false
;
}
static
bool
sJSHackObserverAdded
=
false
;
void
nsContentSecurityUtils
:
:
DetectJsHacks
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
if
(
!
Preferences
:
:
IsServiceAvailable
(
)
)
{
return
;
}
if
(
MOZ_LIKELY
(
sJSHacksChecked
|
|
sJSHacksPresent
)
)
{
return
;
}
static
const
char
*
kObservedPrefs
[
]
=
{
"
xpinstall
.
signatures
.
required
"
"
general
.
config
.
filename
"
"
autoadmin
.
global_config_url
"
"
autoadmin
.
failover_to_cached
"
nullptr
}
;
if
(
MOZ_UNLIKELY
(
!
sJSHackObserverAdded
)
)
{
Preferences
:
:
RegisterCallbacks
(
JSHackPrefObserver
:
:
PrefChanged
kObservedPrefs
)
;
sJSHackObserverAdded
=
true
;
}
nsresult
rv
;
sJSHacksChecked
=
true
;
bool
xpinstallSignatures
;
rv
=
Preferences
:
:
GetBool
(
"
xpinstall
.
signatures
.
required
"
&
xpinstallSignatures
PrefValueKind
:
:
Default
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
!
xpinstallSignatures
)
{
sJSHacksPresent
=
true
;
return
;
}
rv
=
Preferences
:
:
GetBool
(
"
xpinstall
.
signatures
.
required
"
&
xpinstallSignatures
PrefValueKind
:
:
User
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
!
xpinstallSignatures
)
{
sJSHacksPresent
=
true
;
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsAutoString
jsConfigPref
;
rv
=
Preferences
:
:
GetString
(
"
general
.
config
.
filename
"
jsConfigPref
PrefValueKind
:
:
Default
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
!
jsConfigPref
.
IsEmpty
(
)
)
{
sJSHacksPresent
=
true
;
return
;
}
rv
=
Preferences
:
:
GetString
(
"
general
.
config
.
filename
"
jsConfigPref
PrefValueKind
:
:
User
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
!
jsConfigPref
.
IsEmpty
(
)
)
{
sJSHacksPresent
=
true
;
return
;
}
nsAutoString
configUrlPref
;
rv
=
Preferences
:
:
GetString
(
"
autoadmin
.
global_config_url
"
configUrlPref
PrefValueKind
:
:
Default
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
!
configUrlPref
.
IsEmpty
(
)
)
{
sJSHacksPresent
=
true
;
return
;
}
rv
=
Preferences
:
:
GetString
(
"
autoadmin
.
global_config_url
"
configUrlPref
PrefValueKind
:
:
User
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
!
configUrlPref
.
IsEmpty
(
)
)
{
sJSHacksPresent
=
true
;
return
;
}
}
else
{
if
(
Preferences
:
:
HasDefaultValue
(
"
general
.
config
.
filename
"
)
)
{
sJSHacksPresent
=
true
;
return
;
}
if
(
Preferences
:
:
HasUserValue
(
"
general
.
config
.
filename
"
)
)
{
sJSHacksPresent
=
true
;
return
;
}
if
(
Preferences
:
:
HasDefaultValue
(
"
autoadmin
.
global_config_url
"
)
)
{
sJSHacksPresent
=
true
;
return
;
}
if
(
Preferences
:
:
HasUserValue
(
"
autoadmin
.
global_config_url
"
)
)
{
sJSHacksPresent
=
true
;
return
;
}
}
bool
failOverToCache
;
rv
=
Preferences
:
:
GetBool
(
"
autoadmin
.
failover_to_cached
"
&
failOverToCache
PrefValueKind
:
:
Default
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
failOverToCache
)
{
sJSHacksPresent
=
true
;
return
;
}
rv
=
Preferences
:
:
GetBool
(
"
autoadmin
.
failover_to_cached
"
&
failOverToCache
PrefValueKind
:
:
User
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
failOverToCache
)
{
sJSHacksPresent
=
true
;
}
}
void
nsContentSecurityUtils
:
:
DetectCssHacks
(
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
if
(
!
Preferences
:
:
IsServiceAvailable
(
)
)
{
return
;
}
if
(
MOZ_LIKELY
(
sCSSHacksChecked
|
|
sCSSHacksPresent
)
)
{
return
;
}
bool
customStylesPresent
=
Preferences
:
:
GetBool
(
"
toolkit
.
legacyUserProfileCustomizations
.
stylesheets
"
false
)
;
if
(
customStylesPresent
)
{
sCSSHacksPresent
=
true
;
}
sCSSHacksChecked
=
true
;
}
nsresult
nsContentSecurityUtils
:
:
GetHttpChannelFromPotentialMultiPart
(
nsIChannel
*
aChannel
nsIHttpChannel
*
*
aHttpChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIMultiPartChannel
>
multipart
=
do_QueryInterface
(
aChannel
)
;
if
(
!
multipart
)
{
*
aHttpChannel
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
baseChannel
;
nsresult
rv
=
multipart
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
httpChannel
=
do_QueryInterface
(
baseChannel
)
;
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
nsresult
CheckCSPFrameAncestorPolicy
(
nsIChannel
*
aChannel
nsIContentSecurityPolicy
*
*
aOutCSP
)
{
MOZ_ASSERT
(
aChannel
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
ExtContentPolicyType
contentType
=
loadInfo
-
>
GetExternalContentPolicyType
(
)
;
if
(
contentType
!
=
ExtContentPolicy
:
:
TYPE_SUBDOCUMENT
&
&
contentType
!
=
ExtContentPolicy
:
:
TYPE_OBJECT
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
nsresult
rv
=
nsContentSecurityUtils
:
:
GetHttpChannelFromPotentialMultiPart
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
tCspHeaderValue
tCspROHeaderValue
;
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
"
content
-
security
-
policy
"
_ns
tCspHeaderValue
)
;
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
"
content
-
security
-
policy
-
report
-
only
"
_ns
tCspROHeaderValue
)
;
if
(
tCspHeaderValue
.
IsEmpty
(
)
&
&
tCspROHeaderValue
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
}
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
resultPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
extensions
:
:
WebExtensionPolicy
>
addonPolicy
;
if
(
!
httpChannel
)
{
addonPolicy
=
BasePrincipal
:
:
Cast
(
resultPrincipal
)
-
>
AddonPolicy
(
)
;
if
(
!
addonPolicy
)
{
return
NS_OK
;
}
}
RefPtr
<
nsCSPContext
>
csp
=
new
nsCSPContext
(
)
;
csp
-
>
SuppressParserLogMessages
(
)
;
nsCOMPtr
<
nsIURI
>
selfURI
;
nsAutoString
referrerSpec
;
if
(
httpChannel
)
{
aChannel
-
>
GetURI
(
getter_AddRefs
(
selfURI
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
httpChannel
-
>
GetReferrerInfo
(
)
;
if
(
referrerInfo
)
{
referrerInfo
-
>
GetComputedReferrerSpec
(
referrerSpec
)
;
}
}
else
{
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
selfURI
)
)
;
}
uint64_t
innerWindowID
=
loadInfo
-
>
GetInnerWindowID
(
)
;
rv
=
csp
-
>
SetRequestContextWithPrincipal
(
resultPrincipal
selfURI
referrerSpec
innerWindowID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
addonPolicy
)
{
csp
-
>
AppendPolicy
(
addonPolicy
-
>
BaseCSP
(
)
false
false
)
;
csp
-
>
AppendPolicy
(
addonPolicy
-
>
ExtensionPageCSP
(
)
false
false
)
;
}
else
{
NS_ConvertASCIItoUTF16
cspHeaderValue
(
tCspHeaderValue
)
;
NS_ConvertASCIItoUTF16
cspROHeaderValue
(
tCspROHeaderValue
)
;
if
(
!
cspHeaderValue
.
IsEmpty
(
)
)
{
rv
=
CSP_AppendCSPFromHeader
(
csp
cspHeaderValue
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
cspROHeaderValue
.
IsEmpty
(
)
)
{
rv
=
CSP_AppendCSPFromHeader
(
csp
cspROHeaderValue
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
bool
safeAncestry
=
false
;
rv
=
csp
-
>
PermitsAncestry
(
loadInfo
&
safeAncestry
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
safeAncestry
)
{
return
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
;
}
csp
.
forget
(
aOutCSP
)
;
return
NS_OK
;
}
void
EnforceCSPFrameAncestorPolicy
(
nsIChannel
*
aChannel
const
nsresult
&
aError
)
{
if
(
aError
=
=
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
)
{
aChannel
-
>
Cancel
(
NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION
)
;
}
}
void
EnforceXFrameOptionsCheck
(
nsIChannel
*
aChannel
nsIContentSecurityPolicy
*
aCsp
)
{
MOZ_ASSERT
(
aChannel
)
;
bool
isFrameOptionsIgnored
=
false
;
if
(
!
FramingChecker
:
:
CheckFrameOptions
(
aChannel
aCsp
isFrameOptionsIgnored
)
)
{
aChannel
-
>
Cancel
(
NS_ERROR_XFO_VIOLATION
)
;
}
if
(
isFrameOptionsIgnored
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
uint64_t
innerWindowID
=
loadInfo
-
>
GetInnerWindowID
(
)
;
bool
privateWindow
=
!
!
loadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
;
AutoTArray
<
nsString
2
>
params
=
{
u
"
x
-
frame
-
options
"
_ns
u
"
frame
-
ancestors
"
_ns
}
;
CSP_LogLocalizedStr
(
"
IgnoringSrcBecauseOfDirective
"
params
u
"
"
_ns
u
"
"
_ns
0
0
nsIScriptError
:
:
warningFlag
"
IgnoringSrcBecauseOfDirective
"
_ns
innerWindowID
privateWindow
)
;
}
}
void
nsContentSecurityUtils
:
:
PerformCSPFrameAncestorAndXFOCheck
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
nsresult
rv
=
CheckCSPFrameAncestorPolicy
(
aChannel
getter_AddRefs
(
csp
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
EnforceCSPFrameAncestorPolicy
(
aChannel
rv
)
;
return
;
}
EnforceXFrameOptionsCheck
(
aChannel
csp
)
;
}
bool
nsContentSecurityUtils
:
:
CheckCSPFrameAncestorAndXFO
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
nsresult
rv
=
CheckCSPFrameAncestorPolicy
(
aChannel
getter_AddRefs
(
csp
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
bool
isFrameOptionsIgnored
=
false
;
return
FramingChecker
:
:
CheckFrameOptions
(
aChannel
csp
isFrameOptionsIgnored
)
;
}
#
if
defined
(
DEBUG
)
void
nsContentSecurityUtils
:
:
AssertAboutPageHasCSP
(
Document
*
aDocument
)
{
if
(
aDocument
-
>
IsLoadedAsData
(
)
)
{
return
;
}
if
(
StaticPrefs
:
:
dom_security_skip_about_page_has_csp_assert
(
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
documentURI
=
aDocument
-
>
GetDocumentURI
(
)
;
if
(
!
documentURI
-
>
SchemeIs
(
"
about
"
)
)
{
return
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
bool
foundDefaultSrc
=
false
;
bool
foundObjectSrc
=
false
;
bool
foundUnsafeEval
=
false
;
bool
foundUnsafeInline
=
false
;
bool
foundScriptSrc
=
false
;
bool
foundWorkerSrc
=
false
;
bool
foundWebScheme
=
false
;
if
(
csp
)
{
uint32_t
policyCount
=
0
;
csp
-
>
GetPolicyCount
(
&
policyCount
)
;
nsAutoString
parsedPolicyStr
;
for
(
uint32_t
i
=
0
;
i
<
policyCount
;
+
+
i
)
{
csp
-
>
GetPolicyString
(
i
parsedPolicyStr
)
;
if
(
parsedPolicyStr
.
Find
(
u
"
default
-
src
"
)
>
=
0
)
{
foundDefaultSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
u
"
object
-
src
'
none
'
"
)
>
=
0
)
{
foundObjectSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
u
"
'
unsafe
-
eval
'
"
)
>
=
0
)
{
foundUnsafeEval
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
u
"
'
unsafe
-
inline
'
"
)
>
=
0
)
{
foundUnsafeInline
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
u
"
script
-
src
"
)
>
=
0
)
{
foundScriptSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
u
"
worker
-
src
"
)
>
=
0
)
{
foundWorkerSrc
=
true
;
}
if
(
parsedPolicyStr
.
Find
(
u
"
http
:
"
)
>
=
0
|
|
parsedPolicyStr
.
Find
(
u
"
https
:
"
)
>
=
0
)
{
foundWebScheme
=
true
;
}
}
}
if
(
StaticPrefs
:
:
dom_security_skip_about_page_csp_allowlist_and_assert
(
)
)
{
NS_ASSERTION
(
foundDefaultSrc
"
about
:
page
must
have
a
CSP
"
)
;
return
;
}
nsAutoCString
aboutSpec
;
documentURI
-
>
GetSpec
(
aboutSpec
)
;
ToLowerCase
(
aboutSpec
)
;
static
nsLiteralCString
sAllowedAboutPagesWithNoCSP
[
]
=
{
"
about
:
blank
"
_ns
"
about
:
srcdoc
"
_ns
"
about
:
sync
-
log
"
_ns
"
about
:
logo
"
_ns
"
about
:
sync
"
_ns
#
if
defined
(
ANDROID
)
"
about
:
config
"
_ns
#
endif
}
;
for
(
const
nsLiteralCString
&
allowlistEntry
:
sAllowedAboutPagesWithNoCSP
)
{
if
(
StringBeginsWith
(
aboutSpec
allowlistEntry
)
)
{
return
;
}
}
MOZ_ASSERT
(
foundDefaultSrc
"
about
:
page
must
contain
a
CSP
including
default
-
src
"
)
;
MOZ_ASSERT
(
foundObjectSrc
"
about
:
page
must
contain
a
CSP
denying
object
-
src
"
)
;
MOZ_ASSERT
(
!
foundScriptSrc
|
|
StringBeginsWith
(
aboutSpec
"
about
:
preferences
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
downloads
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
newtab
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
logins
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
compat
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
welcome
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
profiling
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
studies
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
home
"
_ns
)
"
about
:
page
must
not
contain
a
CSP
including
script
-
src
"
)
;
MOZ_ASSERT
(
!
foundWorkerSrc
"
about
:
page
must
not
contain
a
CSP
including
worker
-
src
"
)
;
MOZ_ASSERT
(
!
foundWebScheme
|
|
StringBeginsWith
(
aboutSpec
"
about
:
preferences
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
addons
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
newtab
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
debugging
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
ion
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
compat
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
logins
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
home
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
welcome
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
devtools
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
pocket
-
saved
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
pocket
-
home
"
_ns
)
"
about
:
page
must
not
contain
a
CSP
including
a
web
scheme
"
)
;
if
(
aDocument
-
>
IsExtensionPage
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
foundUnsafeEval
"
about
:
page
must
not
contain
a
CSP
including
'
unsafe
-
eval
'
"
)
;
static
nsLiteralCString
sLegacyUnsafeInlineAllowList
[
]
=
{
"
about
:
preferences
"
_ns
"
about
:
addons
"
_ns
"
about
:
newtab
"
_ns
"
about
:
welcome
"
_ns
"
about
:
home
"
_ns
}
;
for
(
const
nsLiteralCString
&
aUnsafeInlineEntry
:
sLegacyUnsafeInlineAllowList
)
{
if
(
StringBeginsWith
(
aboutSpec
aUnsafeInlineEntry
)
)
{
return
;
}
}
MOZ_ASSERT
(
!
foundUnsafeInline
"
about
:
page
must
not
contain
a
CSP
including
'
unsafe
-
inline
'
"
)
;
}
#
endif
bool
nsContentSecurityUtils
:
:
ValidateScriptFilename
(
JSContext
*
cx
const
char
*
aFilename
)
{
if
(
StaticPrefs
:
:
security_allow_parent_unrestricted_js_loads
(
)
)
{
return
true
;
}
if
(
!
XRE_IsE10sParentProcess
(
)
)
{
return
true
;
}
NS_ConvertUTF8toUTF16
filenameU
(
aFilename
)
;
if
(
StaticPrefs
:
:
security_allow_eval_with_system_principal
(
)
|
|
StaticPrefs
:
:
security_allow_eval_in_parent_process
(
)
)
{
if
(
StringEndsWith
(
filenameU
u
"
>
eval
"
_ns
)
)
{
return
true
;
}
}
DetectJsHacks
(
)
;
if
(
MOZ_UNLIKELY
(
!
sJSHacksChecked
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
a
javascript
load
of
%
s
because
"
"
we
have
not
yet
been
able
to
determine
if
JS
hacks
may
be
present
"
aFilename
)
)
;
return
true
;
}
if
(
MOZ_UNLIKELY
(
sJSHacksPresent
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
a
javascript
load
of
%
s
because
"
"
some
JS
hacks
may
be
present
"
aFilename
)
)
;
return
true
;
}
if
(
XRE_IsE10sParentProcess
(
)
&
&
!
StaticPrefs
:
:
extensions_webextensions_remote
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
a
javascript
load
of
%
s
because
the
web
extension
"
"
process
is
disabled
.
"
aFilename
)
)
;
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
chrome
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
resource
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
file
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
jar
:
file
:
/
/
"
_ns
)
)
{
return
true
;
}
if
(
filenameU
.
Equals
(
u
"
about
:
sync
-
log
"
_ns
)
)
{
return
true
;
}
if
(
StringBeginsWith
(
filenameU
u
"
moz
-
extension
:
/
/
"
_ns
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aFilename
)
;
if
(
!
NS_FAILED
(
rv
)
&
&
NS_IsMainThread
(
)
)
{
mozilla
:
:
extensions
:
:
URLInfo
url
(
uri
)
;
auto
*
policy
=
ExtensionPolicyService
:
:
GetSingleton
(
)
.
GetByHost
(
url
.
Host
(
)
)
;
if
(
policy
&
&
policy
-
>
IsPrivileged
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
a
javascript
load
of
%
s
because
the
web
extension
"
"
it
is
associated
with
is
privileged
.
"
aFilename
)
)
;
return
true
;
}
}
}
else
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
cx
)
;
if
(
workerPrivate
&
&
workerPrivate
-
>
IsPrivilegedAddonGlobal
(
)
)
{
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Debug
(
"
Allowing
a
javascript
load
of
%
s
because
the
web
extension
"
"
it
is
associated
with
is
privileged
.
"
aFilename
)
)
;
return
true
;
}
}
auto
kAllowedFilenamesExact
=
{
u
"
data
:
new
function
(
)
{
\
n
const
{
AboutSyncRedirector
}
=
ChromeUtils
.
import
(
\
"
chrome
:
/
/
aboutsync
/
content
/
AboutSyncRedirector
.
js
\
"
)
;
\
n
AboutSyncRedirector
.
register
(
)
;
\
n
}
"
_ns
}
;
for
(
auto
allowedFilename
:
kAllowedFilenamesExact
)
{
if
(
filenameU
=
=
allowedFilename
)
{
return
true
;
}
}
auto
kAllowedFilenamesPrefix
=
{
u
"
about
:
downloads
"
_ns
u
"
about
:
preferences
"
_ns
u
"
debugger
"
_ns
}
;
for
(
auto
allowedFilenamePrefix
:
kAllowedFilenamesPrefix
)
{
if
(
StringBeginsWith
(
filenameU
allowedFilenamePrefix
)
)
{
return
true
;
}
}
MOZ_LOG
(
sCSMLog
LogLevel
:
:
Error
(
"
ValidateScriptFilename
Failed
:
%
s
\
n
"
aFilename
)
)
;
FilenameTypeAndDetails
fileNameTypeAndDetails
=
FilenameToFilenameType
(
filenameU
true
)
;
Telemetry
:
:
EventID
eventType
=
Telemetry
:
:
EventID
:
:
Security_Javascriptload_Parentprocess
;
mozilla
:
:
Maybe
<
nsTArray
<
EventExtraEntry
>
>
extra
;
if
(
fileNameTypeAndDetails
.
second
.
isSome
(
)
)
{
extra
=
Some
<
nsTArray
<
EventExtraEntry
>
>
(
{
EventExtraEntry
{
"
fileinfo
"
_ns
NS_ConvertUTF16toUTF8
(
fileNameTypeAndDetails
.
second
.
value
(
)
)
}
}
)
;
}
else
{
extra
=
Nothing
(
)
;
}
if
(
!
sTelemetryEventEnabled
.
exchange
(
true
)
)
{
sTelemetryEventEnabled
=
true
;
Telemetry
:
:
SetEventRecordingEnabled
(
"
security
"
_ns
true
)
;
}
Telemetry
:
:
RecordEvent
(
eventType
mozilla
:
:
Some
(
fileNameTypeAndDetails
.
first
)
extra
)
;
#
if
defined
(
DEBUG
)
|
|
defined
(
FUZZING
)
auto
crashString
=
nsContentSecurityUtils
:
:
SmartFormatCrashString
(
aFilename
fileNameTypeAndDetails
.
second
.
isSome
(
)
?
NS_ConvertUTF16toUTF8
(
fileNameTypeAndDetails
.
second
.
value
(
)
)
.
get
(
)
:
"
(
None
)
"
"
Blocking
a
script
load
%
s
from
file
%
s
"
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
%
s
"
crashString
.
get
(
)
)
;
#
elif
defined
(
NIGHTLY_BUILD
)
if
(
fileNameTypeAndDetails
.
second
.
isSome
(
)
)
{
PossiblyCrash
(
"
js_load_1
"
aFilename
NS_ConvertUTF16toUTF8
(
fileNameTypeAndDetails
.
second
.
value
(
)
)
)
;
}
else
{
PossiblyCrash
(
"
js_load_1
"
aFilename
"
(
None
)
"
_ns
)
;
}
#
endif
#
ifdef
NIGHTLY_BUILD
return
false
;
#
else
return
true
;
#
endif
}
void
nsContentSecurityUtils
:
:
LogMessageToConsole
(
nsIHttpChannel
*
aChannel
const
char
*
aMsg
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
uint64_t
windowID
=
0
;
rv
=
aChannel
-
>
GetTopLevelContentWindowId
(
&
windowID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
!
windowID
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
loadInfo
-
>
GetInnerWindowID
(
&
windowID
)
;
}
nsAutoString
localizedMsg
;
nsAutoCString
spec
;
uri
-
>
GetSpec
(
spec
)
;
AutoTArray
<
nsString
1
>
params
=
{
NS_ConvertUTF8toUTF16
(
spec
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eSECURITY_PROPERTIES
aMsg
params
localizedMsg
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
nsContentUtils
:
:
ReportToConsoleByWindowID
(
localizedMsg
nsIScriptError
:
:
warningFlag
"
Security
"
_ns
windowID
uri
)
;
}
long
nsContentSecurityUtils
:
:
ClassifyDownload
(
nsIChannel
*
aChannel
const
nsAutoCString
&
aMimeTypeGuess
)
{
MOZ_ASSERT
(
aChannel
"
IsDownloadAllowed
without
channel
?
"
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIURI
>
contentLocation
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
contentLocation
)
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
loadInfo
-
>
GetLoadingPrincipal
(
)
;
if
(
!
loadingPrincipal
)
{
loadingPrincipal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
mozilla
:
:
net
:
:
LoadInfo
(
loadingPrincipal
loadInfo
-
>
TriggeringPrincipal
(
)
nullptr
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
nsIContentPolicy
:
:
TYPE_FETCH
)
;
secCheckLoadInfo
-
>
SetHttpsOnlyStatus
(
nsILoadInfo
:
:
HTTPS_ONLY_EXEMPT
)
;
int16_t
decission
=
nsIContentPolicy
:
:
ACCEPT
;
nsMixedContentBlocker
:
:
ShouldLoad
(
false
contentLocation
secCheckLoadInfo
aMimeTypeGuess
false
&
decission
)
;
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
MIXED_CONTENT_DOWNLOADS
decission
!
=
nsIContentPolicy
:
:
ACCEPT
)
;
if
(
StaticPrefs
:
:
dom_block_download_insecure
(
)
&
&
decission
!
=
nsIContentPolicy
:
:
ACCEPT
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
LogMessageToConsole
(
httpChannel
"
MixedContentBlockedDownload
"
)
;
}
return
nsITransfer
:
:
DOWNLOAD_POTENTIALLY_UNSAFE
;
}
if
(
loadInfo
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
return
nsITransfer
:
:
DOWNLOAD_ACCEPTABLE
;
}
uint32_t
triggeringFlags
=
loadInfo
-
>
GetTriggeringSandboxFlags
(
)
;
uint32_t
currentflags
=
loadInfo
-
>
GetSandboxFlags
(
)
;
if
(
(
triggeringFlags
&
SANDBOXED_ALLOW_DOWNLOADS
)
|
|
(
currentflags
&
SANDBOXED_ALLOW_DOWNLOADS
)
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
LogMessageToConsole
(
httpChannel
"
IframeSandboxBlockedDownload
"
)
;
}
return
nsITransfer
:
:
DOWNLOAD_FORBIDDEN
;
}
return
nsITransfer
:
:
DOWNLOAD_ACCEPTABLE
;
}
