#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCSPService
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsAsyncRedirectVerifyHelper
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
using
namespace
mozilla
;
static
LazyLogModule
gCspPRLog
(
"
CSP
"
)
;
CSPService
:
:
CSPService
(
)
{
}
CSPService
:
:
~
CSPService
(
)
{
}
NS_IMPL_ISUPPORTS
(
CSPService
nsIContentPolicy
nsIChannelEventSink
)
bool
subjectToCSP
(
nsIURI
*
aURI
nsContentPolicyType
aContentType
)
{
nsContentPolicyType
contentType
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
aContentType
)
;
if
(
contentType
=
=
nsIContentPolicy
:
:
TYPE_CSP_REPORT
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_REFRESH
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
return
false
;
}
if
(
aURI
-
>
SchemeIs
(
"
data
"
)
|
|
aURI
-
>
SchemeIs
(
"
blob
"
)
|
|
aURI
-
>
SchemeIs
(
"
filesystem
"
)
)
{
return
true
;
}
if
(
aURI
-
>
SchemeIs
(
"
about
"
)
|
|
aURI
-
>
SchemeIs
(
"
javascript
"
)
)
{
return
false
;
}
bool
isImgOrStyleOrDTDorXBL
=
contentType
=
=
nsIContentPolicy
:
:
TYPE_IMAGE
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_STYLESHEET
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_DTD
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_XBL
;
if
(
aURI
-
>
SchemeIs
(
"
resource
"
)
&
&
!
isImgOrStyleOrDTDorXBL
)
{
return
true
;
}
if
(
aURI
-
>
SchemeIs
(
"
chrome
"
)
&
&
!
isImgOrStyleOrDTDorXBL
)
{
return
true
;
}
if
(
aURI
-
>
SchemeIs
(
"
moz
-
icon
"
)
)
{
return
true
;
}
bool
match
;
nsresult
rv
=
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_IS_LOCAL_RESOURCE
&
match
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
match
)
{
return
false
;
}
return
true
;
}
nsresult
CSPService
:
:
ConsultCSP
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeTypeGuess
int16_t
*
aDecision
)
{
if
(
!
aContentLocation
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
contentType
=
aLoadInfo
-
>
InternalContentPolicyType
(
)
;
nsCOMPtr
<
nsISupports
>
requestContext
=
aLoadInfo
-
>
GetLoadingContext
(
)
;
nsCOMPtr
<
nsIURI
>
requestOrigin
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aLoadInfo
-
>
LoadingPrincipal
(
)
;
if
(
loadingPrincipal
)
{
loadingPrincipal
-
>
GetURI
(
getter_AddRefs
(
requestOrigin
)
)
;
}
nsCOMPtr
<
nsICSPEventListener
>
cspEventListener
;
nsresult
rv
=
aLoadInfo
-
>
GetCspEventListener
(
getter_AddRefs
(
cspEventListener
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
MOZ_LOG_TEST
(
gCspPRLog
LogLevel
:
:
Debug
)
)
{
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
CSPService
:
:
ShouldLoad
called
for
%
s
"
aContentLocation
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
!
StaticPrefs
:
:
security_csp_enable
(
)
|
|
!
subjectToCSP
(
aContentLocation
contentType
)
)
{
return
NS_OK
;
}
nsAutoString
cspNonce
;
rv
=
aLoadInfo
-
>
GetCspNonce
(
cspNonce
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isPreload
=
nsContentUtils
:
:
IsPreloadType
(
contentType
)
;
if
(
isPreload
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
preloadCsp
=
aLoadInfo
-
>
GetPreloadCsp
(
)
;
if
(
preloadCsp
)
{
rv
=
preloadCsp
-
>
ShouldLoad
(
contentType
cspEventListener
aContentLocation
requestOrigin
requestContext
aMimeTypeGuess
nullptr
aLoadInfo
-
>
GetSendCSPViolationEvents
(
)
cspNonce
aDecision
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_CP_REJECTED
(
*
aDecision
)
)
{
NS_SetRequestBlockingReason
(
aLoadInfo
nsILoadInfo
:
:
BLOCKING_REASON_CONTENT_POLICY_PRELOAD
)
;
return
NS_OK
;
}
}
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aLoadInfo
-
>
GetCsp
(
)
;
if
(
csp
)
{
rv
=
csp
-
>
ShouldLoad
(
contentType
cspEventListener
aContentLocation
requestOrigin
requestContext
aMimeTypeGuess
nullptr
aLoadInfo
-
>
GetSendCSPViolationEvents
(
)
cspNonce
aDecision
)
;
if
(
NS_CP_REJECTED
(
*
aDecision
)
)
{
NS_SetRequestBlockingReason
(
aLoadInfo
nsILoadInfo
:
:
BLOCKING_REASON_CONTENT_POLICY_GENERAL
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CSPService
:
:
ShouldLoad
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeTypeGuess
int16_t
*
aDecision
)
{
return
ConsultCSP
(
aContentLocation
aLoadInfo
aMimeTypeGuess
aDecision
)
;
}
NS_IMETHODIMP
CSPService
:
:
ShouldProcess
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeTypeGuess
int16_t
*
aDecision
)
{
if
(
!
aContentLocation
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
contentType
=
aLoadInfo
-
>
InternalContentPolicyType
(
)
;
if
(
MOZ_LOG_TEST
(
gCspPRLog
LogLevel
:
:
Debug
)
)
{
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
CSPService
:
:
ShouldProcess
called
for
%
s
"
aContentLocation
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
uint32_t
policyType
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
contentType
)
;
if
(
policyType
!
=
nsIContentPolicy
:
:
TYPE_OBJECT
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
return
NS_OK
;
}
return
ShouldLoad
(
aContentLocation
aLoadInfo
aMimeTypeGuess
aDecision
)
;
}
NS_IMETHODIMP
CSPService
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
oldChannel
nsIChannel
*
newChannel
uint32_t
flags
nsIAsyncVerifyRedirectCallback
*
callback
)
{
net
:
:
nsAsyncRedirectAutoCallback
autoCallback
(
callback
)
;
if
(
XRE_IsE10sParentProcess
(
)
)
{
nsCOMPtr
<
nsIParentChannel
>
parentChannel
;
NS_QueryNotificationCallbacks
(
oldChannel
parentChannel
)
;
if
(
parentChannel
)
{
return
NS_OK
;
}
}
nsCOMPtr
<
nsIURI
>
newUri
;
nsresult
rv
=
newChannel
-
>
GetURI
(
getter_AddRefs
(
newUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
oldChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIURI
>
originalUri
;
rv
=
oldChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalUri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
autoCallback
.
DontCallback
(
)
;
oldChannel
-
>
Cancel
(
NS_ERROR_DOM_BAD_URI
)
;
return
rv
;
}
Maybe
<
nsresult
>
cancelCode
;
rv
=
ConsultCSPForRedirect
(
originalUri
newUri
loadInfo
cancelCode
)
;
if
(
cancelCode
)
{
oldChannel
-
>
Cancel
(
*
cancelCode
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
autoCallback
.
DontCallback
(
)
;
}
return
rv
;
}
nsresult
CSPService
:
:
ConsultCSPForRedirect
(
nsIURI
*
aOriginalURI
nsIURI
*
aNewURI
nsILoadInfo
*
aLoadInfo
Maybe
<
nsresult
>
&
aCancelCode
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
cspToInherit
=
aLoadInfo
-
>
GetCspToInherit
(
)
;
if
(
cspToInherit
)
{
bool
allowsNavigateTo
=
false
;
nsresult
rv
=
cspToInherit
-
>
GetAllowsNavigateTo
(
aNewURI
aLoadInfo
true
false
&
allowsNavigateTo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
allowsNavigateTo
)
{
aCancelCode
=
Some
(
NS_ERROR_CSP_NAVIGATE_TO_VIOLATION
)
;
return
NS_OK
;
}
}
nsContentPolicyType
policyType
=
aLoadInfo
-
>
InternalContentPolicyType
(
)
;
if
(
!
StaticPrefs
:
:
security_csp_enable
(
)
|
|
!
subjectToCSP
(
aNewURI
policyType
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsICSPEventListener
>
cspEventListener
;
nsresult
rv
=
aLoadInfo
-
>
GetCspEventListener
(
getter_AddRefs
(
cspEventListener
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
rv
)
;
nsAutoString
cspNonce
;
rv
=
aLoadInfo
-
>
GetCspNonce
(
cspNonce
)
;
MOZ_ALWAYS_SUCCEEDS
(
rv
)
;
bool
isPreload
=
nsContentUtils
:
:
IsPreloadType
(
policyType
)
;
policyType
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternalOrWorker
(
policyType
)
;
int16_t
decision
=
nsIContentPolicy
:
:
ACCEPT
;
nsCOMPtr
<
nsISupports
>
requestContext
=
aLoadInfo
-
>
GetLoadingContext
(
)
;
if
(
isPreload
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
preloadCsp
=
aLoadInfo
-
>
GetPreloadCsp
(
)
;
if
(
preloadCsp
)
{
preloadCsp
-
>
ShouldLoad
(
policyType
cspEventListener
aNewURI
nullptr
requestContext
EmptyCString
(
)
aOriginalURI
true
cspNonce
&
decision
)
;
if
(
NS_CP_REJECTED
(
decision
)
)
{
aCancelCode
=
Some
(
NS_ERROR_DOM_BAD_URI
)
;
return
NS_BINDING_FAILED
;
}
}
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aLoadInfo
-
>
GetCsp
(
)
;
if
(
csp
)
{
csp
-
>
ShouldLoad
(
policyType
cspEventListener
aNewURI
nullptr
requestContext
EmptyCString
(
)
aOriginalURI
true
cspNonce
&
decision
)
;
if
(
NS_CP_REJECTED
(
decision
)
)
{
aCancelCode
=
Some
(
NS_ERROR_DOM_BAD_URI
)
;
return
NS_BINDING_FAILED
;
}
}
return
NS_OK
;
}
