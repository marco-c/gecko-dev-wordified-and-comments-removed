#
include
"
nsMixedContentBlocker
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsCSPContext
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsISecurityEventSink
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIParentChannel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsIDocumentLoader
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsLoadGroup
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsAsyncRedirectVerifyHelper
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
using
namespace
mozilla
;
enum
nsMixedContentBlockerMessageType
{
eBlocked
=
0x00
eUserOverride
=
0x01
}
;
bool
nsMixedContentBlocker
:
:
sBlockMixedScript
=
false
;
bool
nsMixedContentBlocker
:
:
sBlockMixedDisplay
=
false
;
bool
nsMixedContentBlocker
:
:
sUseHSTS
=
false
;
bool
nsMixedContentBlocker
:
:
sSendHSTSPriming
=
false
;
uint32_t
nsMixedContentBlocker
:
:
sHSTSPrimingCacheTimeout
=
(
60
*
24
*
7
)
;
bool
IsEligibleForHSTSPriming
(
nsIURI
*
aContentLocation
)
{
bool
isHttpScheme
=
false
;
nsresult
rv
=
aContentLocation
-
>
SchemeIs
(
"
http
"
&
isHttpScheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
isHttpScheme
)
{
return
false
;
}
int32_t
port
=
-
1
;
rv
=
aContentLocation
-
>
GetPort
(
&
port
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
int32_t
defaultPort
=
NS_GetDefaultPort
(
"
https
"
)
;
if
(
port
!
=
-
1
&
&
port
!
=
defaultPort
)
{
return
false
;
}
nsAutoCString
hostname
;
rv
=
aContentLocation
-
>
GetHost
(
hostname
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
PRNetAddr
hostAddr
;
return
(
PR_StringToNetAddr
(
hostname
.
get
(
)
&
hostAddr
)
!
=
PR_SUCCESS
)
;
}
class
nsMixedContentEvent
:
public
Runnable
{
public
:
nsMixedContentEvent
(
nsISupports
*
aContext
MixedContentTypes
aType
bool
aRootHasSecureConnection
)
:
mContext
(
aContext
)
mType
(
aType
)
mRootHasSecureConnection
(
aRootHasSecureConnection
)
{
}
NS_IMETHOD
Run
(
)
override
{
NS_ASSERTION
(
mContext
"
You
can
'
t
call
this
runnable
without
a
requesting
context
"
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
NS_CP_GetDocShellFromContext
(
mContext
)
;
if
(
!
docShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
docShell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
NS_ASSERTION
(
sameTypeRoot
"
No
document
shell
root
tree
item
from
document
shell
tree
item
!
"
)
;
nsCOMPtr
<
nsIDocument
>
rootDoc
=
sameTypeRoot
-
>
GetDocument
(
)
;
NS_ASSERTION
(
rootDoc
"
No
root
document
from
document
shell
root
tree
item
.
"
)
;
nsCOMPtr
<
nsISecurityEventSink
>
eventSink
=
do_QueryInterface
(
docShell
)
;
NS_ASSERTION
(
eventSink
"
No
eventSink
from
docShell
.
"
)
;
nsCOMPtr
<
nsIDocShell
>
rootShell
=
do_GetInterface
(
sameTypeRoot
)
;
NS_ASSERTION
(
rootShell
"
No
root
docshell
from
document
shell
root
tree
item
.
"
)
;
uint32_t
state
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
nsCOMPtr
<
nsISecureBrowserUI
>
securityUI
;
rootShell
-
>
GetSecurityUI
(
getter_AddRefs
(
securityUI
)
)
;
nsresult
stateRV
=
NS_ERROR_FAILURE
;
if
(
securityUI
)
{
stateRV
=
securityUI
-
>
GetState
(
&
state
)
;
}
if
(
mType
=
=
eMixedScript
)
{
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedActiveContentLoaded
(
true
)
;
if
(
securityUI
)
{
if
(
mRootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
eventSink
-
>
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
eventSink
-
>
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
}
}
}
}
else
if
(
mType
=
=
eMixedDisplay
)
{
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedDisplayContentLoaded
(
true
)
;
if
(
securityUI
)
{
if
(
mRootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
}
eventSink
-
>
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
eventSink
-
>
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
}
}
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsISupports
>
mContext
;
const
MixedContentTypes
mType
;
bool
mRootHasSecureConnection
;
}
;
nsMixedContentBlocker
:
:
nsMixedContentBlocker
(
)
{
Preferences
:
:
AddBoolVarCache
(
&
sBlockMixedScript
"
security
.
mixed_content
.
block_active_content
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sBlockMixedDisplay
"
security
.
mixed_content
.
block_display_content
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sUseHSTS
"
security
.
mixed_content
.
use_hsts
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sSendHSTSPriming
"
security
.
mixed_content
.
send_hsts_priming
"
)
;
Preferences
:
:
AddUintVarCache
(
&
sHSTSPrimingCacheTimeout
"
security
.
mixed_content
.
hsts_priming_cache_timeout
"
)
;
}
nsMixedContentBlocker
:
:
~
nsMixedContentBlocker
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsMixedContentBlocker
nsIContentPolicy
nsIChannelEventSink
)
static
void
LogMixedContentMessage
(
MixedContentTypes
aClassification
nsIURI
*
aContentLocation
nsIDocument
*
aRootDoc
nsMixedContentBlockerMessageType
aMessageType
)
{
nsAutoCString
messageCategory
;
uint32_t
severityFlag
;
nsAutoCString
messageLookupKey
;
if
(
aMessageType
=
=
eBlocked
)
{
severityFlag
=
nsIScriptError
:
:
errorFlag
;
messageCategory
.
AssignLiteral
(
"
Mixed
Content
Blocker
"
)
;
if
(
aClassification
=
=
eMixedDisplay
)
{
messageLookupKey
.
AssignLiteral
(
"
BlockMixedDisplayContent
"
)
;
}
else
{
messageLookupKey
.
AssignLiteral
(
"
BlockMixedActiveContent
"
)
;
}
}
else
{
severityFlag
=
nsIScriptError
:
:
warningFlag
;
messageCategory
.
AssignLiteral
(
"
Mixed
Content
Message
"
)
;
if
(
aClassification
=
=
eMixedDisplay
)
{
messageLookupKey
.
AssignLiteral
(
"
LoadingMixedDisplayContent2
"
)
;
}
else
{
messageLookupKey
.
AssignLiteral
(
"
LoadingMixedActiveContent2
"
)
;
}
}
NS_ConvertUTF8toUTF16
locationSpecUTF16
(
aContentLocation
-
>
GetSpecOrDefault
(
)
)
;
const
char16_t
*
strings
[
]
=
{
locationSpecUTF16
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
severityFlag
messageCategory
aRootDoc
nsContentUtils
:
:
eSECURITY_PROPERTIES
messageLookupKey
.
get
(
)
strings
ArrayLength
(
strings
)
)
;
}
NS_IMETHODIMP
nsMixedContentBlocker
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
{
nsAsyncRedirectAutoCallback
autoCallback
(
aCallback
)
;
if
(
!
aOldChannel
)
{
NS_ERROR
(
"
No
channel
when
evaluating
mixed
content
!
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIParentChannel
>
is_ipc_channel
;
NS_QueryNotificationCallbacks
(
aNewChannel
is_ipc_channel
)
;
if
(
is_ipc_channel
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
oldUri
;
rv
=
aOldChannel
-
>
GetURI
(
getter_AddRefs
(
oldUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
newUri
;
rv
=
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
aOldChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
loadInfo
)
{
return
NS_OK
;
}
nsContentPolicyType
contentPolicyType
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
nsCOMPtr
<
nsIPrincipal
>
requestingPrincipal
=
loadInfo
-
>
LoadingPrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
requestingLocation
;
if
(
requestingPrincipal
)
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
requestingPrincipal
)
)
{
return
NS_OK
;
}
rv
=
requestingPrincipal
-
>
GetURI
(
getter_AddRefs
(
requestingLocation
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsISupports
>
requestingContext
=
loadInfo
-
>
LoadingNode
(
)
;
int16_t
decision
=
REJECT_REQUEST
;
rv
=
ShouldLoad
(
contentPolicyType
newUri
requestingLocation
requestingContext
EmptyCString
(
)
nullptr
requestingPrincipal
&
decision
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
nsMixedContentBlocker
:
:
sSendHSTSPriming
)
{
nsCOMPtr
<
nsILoadInfo
>
newLoadInfo
;
rv
=
aNewChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
newLoadInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
newLoadInfo
)
{
rv
=
nsMixedContentBlocker
:
:
MarkLoadInfoForPriming
(
newUri
requestingContext
newLoadInfo
)
;
if
(
NS_FAILED
(
rv
)
)
{
decision
=
REJECT_REQUEST
;
newLoadInfo
-
>
ClearHSTSPriming
(
)
;
}
}
else
{
decision
=
REJECT_REQUEST
;
}
}
if
(
!
NS_CP_ACCEPTED
(
decision
)
)
{
autoCallback
.
DontCallback
(
)
;
return
NS_BINDING_FAILED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsMixedContentBlocker
:
:
ShouldLoad
(
uint32_t
aContentType
nsIURI
*
aContentLocation
nsIURI
*
aRequestingLocation
nsISupports
*
aRequestingContext
const
nsACString
&
aMimeGuess
nsISupports
*
aExtra
nsIPrincipal
*
aRequestPrincipal
int16_t
*
aDecision
)
{
nsresult
rv
=
ShouldLoad
(
false
aContentType
aContentLocation
aRequestingLocation
aRequestingContext
aMimeGuess
aExtra
aRequestPrincipal
aDecision
)
;
return
rv
;
}
nsresult
nsMixedContentBlocker
:
:
ShouldLoad
(
bool
aHadInsecureImageRedirect
uint32_t
aContentType
nsIURI
*
aContentLocation
nsIURI
*
aRequestingLocation
nsISupports
*
aRequestingContext
const
nsACString
&
aMimeGuess
nsISupports
*
aExtra
nsIPrincipal
*
aRequestPrincipal
int16_t
*
aDecision
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
isPreload
=
nsContentUtils
:
:
IsPreloadType
(
aContentType
)
;
bool
isWorkerType
=
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
;
aContentType
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
aContentType
)
;
MixedContentTypes
classification
=
eMixedScript
;
*
aDecision
=
REJECT_REQUEST
;
static_assert
(
TYPE_DATAREQUEST
=
=
TYPE_XMLHTTPREQUEST
"
TYPE_DATAREQUEST
is
not
a
synonym
for
"
"
TYPE_XMLHTTPREQUEST
"
)
;
switch
(
aContentType
)
{
case
TYPE_DOCUMENT
:
*
aDecision
=
ACCEPT
;
return
NS_OK
;
case
TYPE_WEBSOCKET
:
*
aDecision
=
ACCEPT
;
return
NS_OK
;
case
TYPE_IMAGE
:
case
TYPE_MEDIA
:
case
TYPE_OBJECT_SUBREQUEST
:
classification
=
eMixedDisplay
;
break
;
case
TYPE_BEACON
:
case
TYPE_CSP_REPORT
:
case
TYPE_DTD
:
case
TYPE_FETCH
:
case
TYPE_FONT
:
case
TYPE_IMAGESET
:
case
TYPE_OBJECT
:
case
TYPE_SCRIPT
:
case
TYPE_STYLESHEET
:
case
TYPE_SUBDOCUMENT
:
case
TYPE_PING
:
case
TYPE_WEB_MANIFEST
:
case
TYPE_XBL
:
case
TYPE_XMLHTTPREQUEST
:
case
TYPE_XSLT
:
case
TYPE_OTHER
:
break
;
default
:
MOZ_ASSERT
(
false
"
Mixed
content
of
unknown
type
"
)
;
}
nsCOMPtr
<
nsIURI
>
innerContentLocation
=
NS_GetInnermostURI
(
aContentLocation
)
;
if
(
!
innerContentLocation
)
{
NS_ERROR
(
"
Can
'
t
get
innerURI
from
aContentLocation
"
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
bool
schemeLocal
=
false
;
bool
schemeNoReturnData
=
false
;
bool
schemeInherits
=
false
;
bool
schemeSecure
=
false
;
if
(
NS_FAILED
(
NS_URIChainHasFlags
(
innerContentLocation
nsIProtocolHandler
:
:
URI_IS_LOCAL_RESOURCE
&
schemeLocal
)
)
|
|
NS_FAILED
(
NS_URIChainHasFlags
(
innerContentLocation
nsIProtocolHandler
:
:
URI_DOES_NOT_RETURN_DATA
&
schemeNoReturnData
)
)
|
|
NS_FAILED
(
NS_URIChainHasFlags
(
innerContentLocation
nsIProtocolHandler
:
:
URI_INHERITS_SECURITY_CONTEXT
&
schemeInherits
)
)
|
|
NS_FAILED
(
NS_URIChainHasFlags
(
innerContentLocation
nsIProtocolHandler
:
:
URI_SAFE_TO_LOAD_IN_SECURE_CONTEXT
&
schemeSecure
)
)
)
{
*
aDecision
=
REJECT_REQUEST
;
return
NS_ERROR_FAILURE
;
}
if
(
!
aHadInsecureImageRedirect
&
&
(
schemeLocal
|
|
schemeNoReturnData
|
|
schemeInherits
|
|
schemeSecure
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aRequestingContext
)
;
if
(
node
)
{
principal
=
node
-
>
NodePrincipal
(
)
;
}
if
(
!
principal
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
scriptObjPrin
=
do_QueryInterface
(
aRequestingContext
)
;
if
(
scriptObjPrin
)
{
principal
=
scriptObjPrin
-
>
GetPrincipal
(
)
;
}
}
nsCOMPtr
<
nsIURI
>
requestingLocation
;
if
(
principal
)
{
principal
-
>
GetURI
(
getter_AddRefs
(
requestingLocation
)
)
;
}
if
(
principal
&
&
!
requestingLocation
)
{
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
}
if
(
!
requestingLocation
)
{
requestingLocation
=
aRequestingLocation
;
}
if
(
!
principal
&
&
!
requestingLocation
&
&
aRequestPrincipal
)
{
nsCOMPtr
<
nsIExpandedPrincipal
>
expanded
=
do_QueryInterface
(
aRequestPrincipal
)
;
if
(
expanded
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
}
if
(
!
requestingLocation
)
{
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
bool
parentIsHttps
;
nsCOMPtr
<
nsIURI
>
innerRequestingLocation
=
NS_GetInnermostURI
(
requestingLocation
)
;
if
(
!
innerRequestingLocation
)
{
NS_ERROR
(
"
Can
'
t
get
innerURI
from
requestingLocation
"
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
nsresult
rv
=
innerRequestingLocation
-
>
SchemeIs
(
"
https
"
&
parentIsHttps
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
requestingLocation
-
>
SchemeIs
failed
"
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
if
(
!
parentIsHttps
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
NS_CP_GetDocShellFromContext
(
aRequestingContext
)
;
NS_ENSURE_TRUE
(
docShell
NS_OK
)
;
if
(
isWorkerType
)
{
#
ifdef
DEBUG
bool
isHttpsScheme
=
false
;
rv
=
innerContentLocation
-
>
SchemeIs
(
"
https
"
&
isHttpsScheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_ASSERT
(
!
isHttpsScheme
)
;
#
endif
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
bool
isHttpScheme
=
false
;
rv
=
innerContentLocation
-
>
SchemeIs
(
"
http
"
&
isHttpScheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIDocument
*
document
=
docShell
-
>
GetDocument
(
)
;
MOZ_ASSERT
(
document
"
Expected
a
document
"
)
;
if
(
isHttpScheme
&
&
document
-
>
GetUpgradeInsecureRequests
(
isPreload
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
if
(
document
-
>
GetBlockAllMixedContent
(
isPreload
)
)
{
nsAutoCString
spec
;
rv
=
aContentLocation
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
reportSpec
(
spec
)
;
const
char16_t
*
params
[
]
=
{
reportSpec
.
get
(
)
}
;
CSP_LogLocalizedStr
(
u
"
blockAllMixedContent
"
params
ArrayLength
(
params
)
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
errorFlag
"
CSP
"
document
-
>
InnerWindowID
(
)
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
bool
rootHasSecureConnection
=
false
;
bool
allowMixedContent
=
false
;
bool
isRootDocShell
=
false
;
rv
=
docShell
-
>
GetAllowMixedContentAndConnectionData
(
&
rootHasSecureConnection
&
allowMixedContent
&
isRootDocShell
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aDecision
=
REJECT_REQUEST
;
return
rv
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
docShell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
NS_ASSERTION
(
sameTypeRoot
"
No
root
tree
item
from
docshell
!
"
)
;
if
(
aContentType
=
=
TYPE_SUBDOCUMENT
&
&
!
rootHasSecureConnection
)
{
bool
httpsParentExists
=
false
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentTreeItem
;
parentTreeItem
=
docShell
;
while
(
!
httpsParentExists
&
&
parentTreeItem
)
{
nsCOMPtr
<
nsIWebNavigation
>
parentAsNav
(
do_QueryInterface
(
parentTreeItem
)
)
;
NS_ASSERTION
(
parentAsNav
"
No
web
navigation
object
from
parent
'
s
docshell
tree
item
"
)
;
nsCOMPtr
<
nsIURI
>
parentURI
;
parentAsNav
-
>
GetCurrentURI
(
getter_AddRefs
(
parentURI
)
)
;
if
(
!
parentURI
)
{
httpsParentExists
=
true
;
break
;
}
nsCOMPtr
<
nsIURI
>
innerParentURI
=
NS_GetInnermostURI
(
parentURI
)
;
if
(
!
innerParentURI
)
{
NS_ERROR
(
"
Can
'
t
get
innerURI
from
parentURI
"
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
if
(
NS_FAILED
(
innerParentURI
-
>
SchemeIs
(
"
https
"
&
httpsParentExists
)
)
)
{
httpsParentExists
=
true
;
break
;
}
if
(
sameTypeRoot
=
=
parentTreeItem
)
{
break
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
newParentTreeItem
;
parentTreeItem
-
>
GetSameTypeParent
(
getter_AddRefs
(
newParentTreeItem
)
)
;
parentTreeItem
=
newParentTreeItem
;
}
if
(
!
httpsParentExists
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIDocument
>
rootDoc
=
sameTypeRoot
-
>
GetDocument
(
)
;
NS_ASSERTION
(
rootDoc
"
No
root
document
from
document
shell
root
tree
item
.
"
)
;
nsCOMPtr
<
nsISecurityEventSink
>
eventSink
=
do_QueryInterface
(
docShell
)
;
NS_ASSERTION
(
eventSink
"
No
eventSink
from
docShell
.
"
)
;
nsCOMPtr
<
nsIDocShell
>
rootShell
=
do_GetInterface
(
sameTypeRoot
)
;
NS_ASSERTION
(
rootShell
"
No
root
docshell
from
document
shell
root
tree
item
.
"
)
;
uint32_t
state
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
nsCOMPtr
<
nsISecureBrowserUI
>
securityUI
;
rootShell
-
>
GetSecurityUI
(
getter_AddRefs
(
securityUI
)
)
;
if
(
!
securityUI
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
return
NS_OK
;
}
nsresult
stateRV
=
securityUI
-
>
GetState
(
&
state
)
;
OriginAttributes
originAttributes
;
if
(
principal
)
{
originAttributes
.
Inherit
(
principal
-
>
OriginAttributesRef
(
)
)
;
}
else
if
(
aRequestPrincipal
)
{
originAttributes
.
Inherit
(
aRequestPrincipal
-
>
OriginAttributesRef
(
)
)
;
}
bool
doHSTSPriming
=
false
;
if
(
IsEligibleForHSTSPriming
(
aContentLocation
)
)
{
bool
hsts
=
false
;
bool
cached
=
false
;
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
aContentLocation
0
originAttributes
&
cached
&
hsts
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
hsts
&
&
sUseHSTS
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
if
(
!
cached
&
&
sSendHSTSPriming
)
{
doHSTSPriming
=
true
;
document
-
>
AddHSTSPrimingLocation
(
innerContentLocation
HSTSPrimingState
:
:
eHSTS_PRIMING_ALLOW
)
;
*
aDecision
=
ACCEPT
;
}
}
bool
active
=
(
classification
=
=
eMixedScript
)
;
if
(
!
aHadInsecureImageRedirect
)
{
if
(
XRE_IsParentProcess
(
)
)
{
AccumulateMixedContentHSTS
(
innerContentLocation
active
doHSTSPriming
originAttributes
)
;
}
else
{
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
cc
)
{
mozilla
:
:
ipc
:
:
URIParams
uri
;
SerializeURI
(
innerContentLocation
uri
)
;
cc
-
>
SendAccumulateMixedContentHSTS
(
uri
active
doHSTSPriming
originAttributes
)
;
}
}
}
if
(
aContentType
=
=
TYPE_OBJECT_SUBREQUEST
)
{
rootDoc
-
>
SetHasMixedContentObjectSubrequest
(
true
)
;
}
if
(
sBlockMixedDisplay
&
&
classification
=
=
eMixedDisplay
)
{
if
(
allowMixedContent
)
{
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eUserOverride
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedDisplayContentLoaded
(
true
)
;
if
(
rootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
}
eventSink
-
>
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
eventSink
-
>
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
}
}
else
{
if
(
doHSTSPriming
)
{
document
-
>
AddHSTSPrimingLocation
(
innerContentLocation
HSTSPrimingState
:
:
eHSTS_PRIMING_BLOCK
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
}
else
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
}
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eBlocked
)
;
if
(
!
rootDoc
-
>
GetHasMixedDisplayContentBlocked
(
)
&
&
NS_SUCCEEDED
(
stateRV
)
)
{
rootDoc
-
>
SetHasMixedDisplayContentBlocked
(
true
)
;
eventSink
-
>
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_BLOCKED_MIXED_DISPLAY_CONTENT
)
)
;
}
}
return
NS_OK
;
}
else
if
(
sBlockMixedScript
&
&
classification
=
=
eMixedScript
)
{
if
(
allowMixedContent
)
{
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eUserOverride
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedActiveContentLoaded
(
true
)
;
if
(
rootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
eventSink
-
>
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
return
NS_OK
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
eventSink
-
>
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
}
return
NS_OK
;
}
}
else
{
if
(
doHSTSPriming
)
{
document
-
>
AddHSTSPrimingLocation
(
innerContentLocation
HSTSPrimingState
:
:
eHSTS_PRIMING_BLOCK
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
}
else
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
}
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eBlocked
)
;
if
(
rootDoc
-
>
GetHasMixedActiveContentBlocked
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedActiveContentBlocked
(
true
)
;
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
eventSink
-
>
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
)
)
;
}
return
NS_OK
;
}
}
else
{
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eUserOverride
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsMixedContentEvent
(
aRequestingContext
classification
rootHasSecureConnection
)
)
;
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
}
NS_IMETHODIMP
nsMixedContentBlocker
:
:
ShouldProcess
(
uint32_t
aContentType
nsIURI
*
aContentLocation
nsIURI
*
aRequestingLocation
nsISupports
*
aRequestingContext
const
nsACString
&
aMimeGuess
nsISupports
*
aExtra
nsIPrincipal
*
aRequestPrincipal
int16_t
*
aDecision
)
{
aContentType
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
aContentType
)
;
if
(
!
aContentLocation
)
{
if
(
aContentType
=
=
TYPE_OBJECT
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
else
{
*
aDecision
=
REJECT_REQUEST
;
return
NS_ERROR_FAILURE
;
}
}
return
ShouldLoad
(
aContentType
aContentLocation
aRequestingLocation
aRequestingContext
aMimeGuess
aExtra
aRequestPrincipal
aDecision
)
;
}
enum
MixedContentHSTSState
{
MCB_HSTS_PASSIVE_NO_HSTS
=
0
MCB_HSTS_PASSIVE_WITH_HSTS
=
1
MCB_HSTS_ACTIVE_NO_HSTS
=
2
MCB_HSTS_ACTIVE_WITH_HSTS
=
3
}
;
enum
MixedContentHSTSPrimingState
{
eMCB_HSTS_PASSIVE_WITH_HSTS
=
0
eMCB_HSTS_ACTIVE_WITH_HSTS
=
1
eMCB_HSTS_PASSIVE_NO_PRIMING
=
2
eMCB_HSTS_PASSIVE_DO_PRIMING
=
3
eMCB_HSTS_ACTIVE_NO_PRIMING
=
4
eMCB_HSTS_ACTIVE_DO_PRIMING
=
5
}
;
void
nsMixedContentBlocker
:
:
AccumulateMixedContentHSTS
(
nsIURI
*
aURI
bool
aActive
bool
aHasHSTSPriming
const
OriginAttributes
&
aOriginAttributes
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
bool
hsts
;
nsresult
rv
;
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
aURI
0
aOriginAttributes
nullptr
&
hsts
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
!
aActive
)
{
if
(
!
hsts
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_PASSIVE_NO_HSTS
)
;
if
(
aHasHSTSPriming
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS_PRIMING
eMCB_HSTS_PASSIVE_DO_PRIMING
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS_PRIMING
eMCB_HSTS_PASSIVE_NO_PRIMING
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_PASSIVE_WITH_HSTS
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS_PRIMING
eMCB_HSTS_PASSIVE_WITH_HSTS
)
;
}
}
else
{
if
(
!
hsts
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_ACTIVE_NO_HSTS
)
;
if
(
aHasHSTSPriming
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS_PRIMING
eMCB_HSTS_ACTIVE_DO_PRIMING
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS_PRIMING
eMCB_HSTS_ACTIVE_NO_PRIMING
)
;
}
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_ACTIVE_WITH_HSTS
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS_PRIMING
eMCB_HSTS_ACTIVE_WITH_HSTS
)
;
}
}
}
nsresult
nsMixedContentBlocker
:
:
MarkLoadInfoForPriming
(
nsIURI
*
aURI
nsISupports
*
aRequestingContext
nsILoadInfo
*
aLoadInfo
)
{
nsresult
rv
;
bool
sendPriming
=
false
;
bool
mixedContentWouldBlock
=
false
;
rv
=
GetHSTSPrimingFromRequestingContext
(
aURI
aRequestingContext
&
sendPriming
&
mixedContentWouldBlock
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
sendPriming
)
{
aLoadInfo
-
>
SetHSTSPriming
(
mixedContentWouldBlock
)
;
}
return
NS_OK
;
}
nsresult
nsMixedContentBlocker
:
:
GetHSTSPrimingFromRequestingContext
(
nsIURI
*
aURI
nsISupports
*
aRequestingContext
bool
*
aSendPrimingRequest
bool
*
aMixedContentWouldBlock
)
{
*
aSendPrimingRequest
=
false
;
*
aMixedContentWouldBlock
=
false
;
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
aURI
)
;
if
(
!
innerURI
)
{
NS_ERROR
(
"
Can
'
t
get
innerURI
from
aContentLocation
"
)
;
return
NS_ERROR_CONTENT_BLOCKED
;
}
bool
isHttp
=
false
;
innerURI
-
>
SchemeIs
(
"
http
"
&
isHttp
)
;
if
(
!
isHttp
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
NS_CP_GetDocShellFromContext
(
aRequestingContext
)
;
if
(
!
docShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
document
=
docShell
-
>
GetDocument
(
)
;
if
(
!
document
)
{
return
NS_OK
;
}
HSTSPrimingState
status
=
document
-
>
GetHSTSPrimingStateForLocation
(
innerURI
)
;
if
(
status
!
=
HSTSPrimingState
:
:
eNO_HSTS_PRIMING
)
{
*
aSendPrimingRequest
=
(
status
!
=
HSTSPrimingState
:
:
eNO_HSTS_PRIMING
)
;
*
aMixedContentWouldBlock
=
(
status
=
=
HSTSPrimingState
:
:
eHSTS_PRIMING_BLOCK
)
;
}
return
NS_OK
;
}
