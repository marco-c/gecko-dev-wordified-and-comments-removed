#
include
"
nsMixedContentBlocker
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsCSPContext
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIParentChannel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsISecureBrowserUI
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsLoadGroup
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsAsyncRedirectVerifyHelper
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
prnetdb
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
net
/
DNS
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
enum
nsMixedContentBlockerMessageType
{
eBlocked
=
0x00
eUserOverride
=
0x01
}
;
nsCString
*
nsMixedContentBlocker
:
:
sSecurecontextWhitelist
=
nullptr
;
bool
nsMixedContentBlocker
:
:
sSecurecontextWhitelistCached
=
false
;
enum
MixedContentHSTSState
{
MCB_HSTS_PASSIVE_NO_HSTS
=
0
MCB_HSTS_PASSIVE_WITH_HSTS
=
1
MCB_HSTS_ACTIVE_NO_HSTS
=
2
MCB_HSTS_ACTIVE_WITH_HSTS
=
3
}
;
class
nsMixedContentEvent
:
public
Runnable
{
public
:
nsMixedContentEvent
(
nsISupports
*
aContext
MixedContentTypes
aType
bool
aRootHasSecureConnection
)
:
mozilla
:
:
Runnable
(
"
nsMixedContentEvent
"
)
mContext
(
aContext
)
mType
(
aType
)
mRootHasSecureConnection
(
aRootHasSecureConnection
)
{
}
NS_IMETHOD
Run
(
)
override
{
NS_ASSERTION
(
mContext
"
You
can
'
t
call
this
runnable
without
a
requesting
context
"
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
NS_CP_GetDocShellFromContext
(
mContext
)
;
if
(
!
docShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
rootShell
=
docShell
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
-
>
GetDocShell
(
)
;
if
(
!
rootShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
Document
>
rootDoc
=
rootShell
-
>
GetDocument
(
)
;
NS_ASSERTION
(
rootDoc
"
No
root
document
from
document
shell
root
tree
item
.
"
)
;
nsDocShell
*
nativeDocShell
=
nsDocShell
:
:
Cast
(
docShell
)
;
uint32_t
state
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
nsCOMPtr
<
nsISecureBrowserUI
>
securityUI
;
rootShell
-
>
GetSecurityUI
(
getter_AddRefs
(
securityUI
)
)
;
nsresult
stateRV
=
NS_ERROR_FAILURE
;
if
(
securityUI
)
{
stateRV
=
securityUI
-
>
GetState
(
&
state
)
;
}
if
(
mType
=
=
eMixedScript
)
{
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedActiveContentLoaded
(
true
)
;
if
(
securityUI
)
{
if
(
mRootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
}
}
}
}
else
if
(
mType
=
=
eMixedDisplay
)
{
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedDisplayContentLoaded
(
true
)
;
if
(
securityUI
)
{
if
(
mRootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
}
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
mContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
}
}
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsISupports
>
mContext
;
const
MixedContentTypes
mType
;
bool
mRootHasSecureConnection
;
}
;
nsMixedContentBlocker
:
:
~
nsMixedContentBlocker
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
nsMixedContentBlocker
nsIContentPolicy
nsIChannelEventSink
)
static
void
LogMixedContentMessage
(
MixedContentTypes
aClassification
nsIURI
*
aContentLocation
Document
*
aRootDoc
nsMixedContentBlockerMessageType
aMessageType
)
{
nsAutoCString
messageCategory
;
uint32_t
severityFlag
;
nsAutoCString
messageLookupKey
;
if
(
aMessageType
=
=
eBlocked
)
{
severityFlag
=
nsIScriptError
:
:
errorFlag
;
messageCategory
.
AssignLiteral
(
"
Mixed
Content
Blocker
"
)
;
if
(
aClassification
=
=
eMixedDisplay
)
{
messageLookupKey
.
AssignLiteral
(
"
BlockMixedDisplayContent
"
)
;
}
else
{
messageLookupKey
.
AssignLiteral
(
"
BlockMixedActiveContent
"
)
;
}
}
else
{
severityFlag
=
nsIScriptError
:
:
warningFlag
;
messageCategory
.
AssignLiteral
(
"
Mixed
Content
Message
"
)
;
if
(
aClassification
=
=
eMixedDisplay
)
{
messageLookupKey
.
AssignLiteral
(
"
LoadingMixedDisplayContent2
"
)
;
}
else
{
messageLookupKey
.
AssignLiteral
(
"
LoadingMixedActiveContent2
"
)
;
}
}
AutoTArray
<
nsString
1
>
strings
;
CopyUTF8toUTF16
(
aContentLocation
-
>
GetSpecOrDefault
(
)
*
strings
.
AppendElement
(
)
)
;
nsContentUtils
:
:
ReportToConsole
(
severityFlag
messageCategory
aRootDoc
nsContentUtils
:
:
eSECURITY_PROPERTIES
messageLookupKey
.
get
(
)
strings
)
;
}
NS_IMETHODIMP
nsMixedContentBlocker
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
{
mozilla
:
:
net
:
:
nsAsyncRedirectAutoCallback
autoCallback
(
aCallback
)
;
if
(
!
aOldChannel
)
{
NS_ERROR
(
"
No
channel
when
evaluating
mixed
content
!
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIParentChannel
>
is_ipc_channel
;
NS_QueryNotificationCallbacks
(
aNewChannel
is_ipc_channel
)
;
if
(
is_ipc_channel
)
{
return
NS_OK
;
}
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
oldUri
;
rv
=
aOldChannel
-
>
GetURI
(
getter_AddRefs
(
oldUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
newUri
;
rv
=
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newUri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aOldChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsIPrincipal
>
requestingPrincipal
=
loadInfo
-
>
GetLoadingPrincipal
(
)
;
if
(
requestingPrincipal
)
{
if
(
requestingPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
NS_OK
;
}
}
int16_t
decision
=
REJECT_REQUEST
;
rv
=
ShouldLoad
(
newUri
loadInfo
EmptyCString
(
)
&
decision
)
;
if
(
NS_FAILED
(
rv
)
)
{
autoCallback
.
DontCallback
(
)
;
aOldChannel
-
>
Cancel
(
NS_ERROR_DOM_BAD_URI
)
;
return
NS_BINDING_FAILED
;
}
if
(
!
NS_CP_ACCEPTED
(
decision
)
)
{
autoCallback
.
DontCallback
(
)
;
aOldChannel
-
>
Cancel
(
NS_ERROR_DOM_BAD_URI
)
;
return
NS_BINDING_FAILED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsMixedContentBlocker
:
:
ShouldLoad
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
uint32_t
contentType
=
aLoadInfo
-
>
InternalContentPolicyType
(
)
;
nsCOMPtr
<
nsISupports
>
requestingContext
=
aLoadInfo
-
>
GetLoadingContext
(
)
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aLoadInfo
-
>
GetLoadingPrincipal
(
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aLoadInfo
-
>
TriggeringPrincipal
(
)
;
nsresult
rv
=
ShouldLoad
(
false
contentType
aContentLocation
loadingPrincipal
triggeringPrincipal
requestingContext
aMimeGuess
aDecision
)
;
if
(
*
aDecision
=
=
nsIContentPolicy
:
:
REJECT_REQUEST
)
{
NS_SetRequestBlockingReason
(
aLoadInfo
nsILoadInfo
:
:
BLOCKING_REASON_MIXED_BLOCKED
)
;
}
return
rv
;
}
bool
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyLoopbackHost
(
const
nsACString
&
aAsciiHost
)
{
if
(
aAsciiHost
.
EqualsLiteral
(
"
:
:
1
"
)
|
|
aAsciiHost
.
EqualsLiteral
(
"
localhost
"
)
)
{
return
true
;
}
PRNetAddr
tempAddr
;
memset
(
&
tempAddr
0
sizeof
(
PRNetAddr
)
)
;
if
(
PR_StringToNetAddr
(
PromiseFlatCString
(
aAsciiHost
)
.
get
(
)
&
tempAddr
)
!
=
PR_SUCCESS
)
{
return
false
;
}
using
namespace
mozilla
:
:
net
;
NetAddr
addr
;
PRNetAddrToNetAddr
(
&
tempAddr
&
addr
)
;
return
IsIPAddrV4
(
&
addr
)
&
&
IsLoopBackAddress
(
&
addr
)
;
}
bool
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyLoopbackURL
(
nsIURI
*
aURL
)
{
nsAutoCString
asciiHost
;
nsresult
rv
=
aURL
-
>
GetAsciiHost
(
asciiHost
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
IsPotentiallyTrustworthyLoopbackHost
(
asciiHost
)
;
}
bool
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOnion
(
nsIURI
*
aURL
)
{
if
(
!
StaticPrefs
:
:
dom_securecontext_whitelist_onions
(
)
)
{
return
false
;
}
nsAutoCString
host
;
nsresult
rv
=
aURL
-
>
GetHost
(
host
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
StringEndsWith
(
host
NS_LITERAL_CSTRING
(
"
.
onion
"
)
)
;
}
void
nsMixedContentBlocker
:
:
OnPrefChange
(
const
char
*
aPref
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
strcmp
(
aPref
"
dom
.
securecontext
.
whitelist
"
)
)
;
Preferences
:
:
GetCString
(
"
dom
.
securecontext
.
whitelist
"
*
sSecurecontextWhitelist
)
;
}
void
nsMixedContentBlocker
:
:
GetSecureContextWhiteList
(
nsACString
&
aList
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sSecurecontextWhitelistCached
)
{
MOZ_ASSERT
(
!
sSecurecontextWhitelist
)
;
sSecurecontextWhitelistCached
=
true
;
sSecurecontextWhitelist
=
new
nsCString
(
)
;
Preferences
:
:
RegisterCallbackAndCall
(
OnPrefChange
"
dom
.
securecontext
.
whitelist
"
)
;
}
aList
=
*
sSecurecontextWhitelist
;
}
void
nsMixedContentBlocker
:
:
Shutdown
(
)
{
if
(
sSecurecontextWhitelist
)
{
delete
sSecurecontextWhitelist
;
sSecurecontextWhitelist
=
nullptr
;
}
}
bool
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOrigin
(
nsIURI
*
aURI
)
{
nsAutoCString
scheme
;
nsresult
rv
=
aURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
NS_WARNING_ASSERTION
(
!
scheme
.
EqualsLiteral
(
"
blob
"
)
"
IsOriginPotentiallyTrustworthy
ignoring
blob
scheme
"
)
;
bool
aPrioriAuthenticated
=
false
;
if
(
NS_FAILED
(
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_IS_POTENTIALLY_TRUSTWORTHY
&
aPrioriAuthenticated
)
)
)
{
return
false
;
}
if
(
aPrioriAuthenticated
)
{
return
true
;
}
nsAutoCString
host
;
rv
=
aURI
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
IsPotentiallyTrustworthyLoopbackURL
(
aURI
)
)
{
return
true
;
}
if
(
!
scheme
.
EqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
ws
"
)
)
{
return
false
;
}
nsAutoCString
whitelist
;
GetSecureContextWhiteList
(
whitelist
)
;
nsCCharSeparatedTokenizer
tokenizer
(
whitelist
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsACString
&
allowedHost
=
tokenizer
.
nextToken
(
)
;
if
(
host
.
Equals
(
allowedHost
)
)
{
return
true
;
}
}
if
(
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOnion
(
aURI
)
)
{
return
true
;
}
return
false
;
}
nsresult
nsMixedContentBlocker
:
:
ShouldLoad
(
bool
aHadInsecureImageRedirect
uint32_t
aContentType
nsIURI
*
aContentLocation
nsIPrincipal
*
aLoadingPrincipal
nsIPrincipal
*
aTriggeringPrincipal
nsISupports
*
aRequestingContext
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
isPreload
=
nsContentUtils
:
:
IsPreloadType
(
aContentType
)
;
bool
isWorkerType
=
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
;
aContentType
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
aContentType
)
;
MixedContentTypes
classification
=
eMixedScript
;
*
aDecision
=
REJECT_REQUEST
;
static_assert
(
TYPE_DATAREQUEST
=
=
TYPE_XMLHTTPREQUEST
"
TYPE_DATAREQUEST
is
not
a
synonym
for
"
"
TYPE_XMLHTTPREQUEST
"
)
;
switch
(
aContentType
)
{
case
TYPE_DOCUMENT
:
*
aDecision
=
ACCEPT
;
return
NS_OK
;
case
TYPE_WEBSOCKET
:
*
aDecision
=
ACCEPT
;
return
NS_OK
;
case
TYPE_SAVEAS_DOWNLOAD
:
*
aDecision
=
ACCEPT
;
return
NS_OK
;
case
TYPE_IMAGE
:
case
TYPE_MEDIA
:
classification
=
eMixedDisplay
;
break
;
case
TYPE_OBJECT_SUBREQUEST
:
if
(
StaticPrefs
:
:
security_mixed_content_block_object_subrequest
(
)
)
{
classification
=
eMixedScript
;
}
else
{
classification
=
eMixedDisplay
;
}
break
;
case
TYPE_BEACON
:
case
TYPE_CSP_REPORT
:
case
TYPE_DTD
:
case
TYPE_FETCH
:
case
TYPE_FONT
:
case
TYPE_IMAGESET
:
case
TYPE_OBJECT
:
case
TYPE_SCRIPT
:
case
TYPE_STYLESHEET
:
case
TYPE_SUBDOCUMENT
:
case
TYPE_PING
:
case
TYPE_WEB_MANIFEST
:
case
TYPE_XBL
:
case
TYPE_XMLHTTPREQUEST
:
case
TYPE_XSLT
:
case
TYPE_OTHER
:
case
TYPE_SPECULATIVE
:
break
;
default
:
MOZ_ASSERT
(
false
"
Mixed
content
of
unknown
type
"
)
;
}
nsCOMPtr
<
nsIURI
>
innerContentLocation
=
NS_GetInnermostURI
(
aContentLocation
)
;
if
(
!
innerContentLocation
)
{
NS_ERROR
(
"
Can
'
t
get
innerURI
from
aContentLocation
"
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
if
(
!
aHadInsecureImageRedirect
&
&
URISafeToBeLoadedInSecureContext
(
innerContentLocation
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
if
(
aTriggeringPrincipal
)
{
if
(
aTriggeringPrincipal
-
>
IsSystemPrincipal
(
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
nsCOMPtr
<
nsIExpandedPrincipal
>
expanded
=
do_QueryInterface
(
aTriggeringPrincipal
)
;
if
(
expanded
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIURI
>
requestingLocation
;
auto
*
baseLoadingPrincipal
=
BasePrincipal
:
:
Cast
(
aLoadingPrincipal
)
;
if
(
baseLoadingPrincipal
)
{
baseLoadingPrincipal
-
>
GetURI
(
getter_AddRefs
(
requestingLocation
)
)
;
}
if
(
!
requestingLocation
)
{
auto
*
baseTriggeringPrincipal
=
BasePrincipal
:
:
Cast
(
aTriggeringPrincipal
)
;
if
(
baseTriggeringPrincipal
)
{
baseTriggeringPrincipal
-
>
GetURI
(
getter_AddRefs
(
requestingLocation
)
)
;
}
}
if
(
!
requestingLocation
)
{
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
innerRequestingLocation
=
NS_GetInnermostURI
(
requestingLocation
)
;
if
(
!
innerRequestingLocation
)
{
NS_ERROR
(
"
Can
'
t
get
innerURI
from
requestingLocation
"
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
bool
parentIsHttps
=
innerRequestingLocation
-
>
SchemeIs
(
"
https
"
)
;
if
(
!
parentIsHttps
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
if
(
isWorkerType
)
{
#
ifdef
DEBUG
bool
isHttpsScheme
=
innerContentLocation
-
>
SchemeIs
(
"
https
"
)
;
MOZ_ASSERT
(
!
isHttpsScheme
)
;
#
endif
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
bool
isHttpScheme
=
innerContentLocation
-
>
SchemeIs
(
"
http
"
)
;
if
(
isHttpScheme
&
&
IsPotentiallyTrustworthyOrigin
(
innerContentLocation
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
if
(
StaticPrefs
:
:
dom_security_https_only_mode
(
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
NS_CP_GetDocShellFromContext
(
aRequestingContext
)
;
if
(
XRE_IsParentProcess
(
)
&
&
!
docShell
&
&
(
aContentType
=
=
TYPE_IMAGE
|
|
aContentType
=
=
TYPE_MEDIA
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
NS_ENSURE_TRUE
(
docShell
NS_OK
)
;
Document
*
document
=
docShell
-
>
GetDocument
(
)
;
MOZ_ASSERT
(
document
"
Expected
a
document
"
)
;
if
(
isHttpScheme
&
&
document
-
>
GetUpgradeInsecureRequests
(
isPreload
)
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
bool
isUpgradableDisplayType
=
nsContentUtils
:
:
IsUpgradableDisplayType
(
aContentType
)
&
&
StaticPrefs
:
:
security_mixed_content_upgrade_display_content
(
)
;
if
(
isHttpScheme
&
&
isUpgradableDisplayType
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
if
(
document
-
>
GetBlockAllMixedContent
(
isPreload
)
)
{
nsAutoCString
spec
;
nsresult
rv
=
aContentLocation
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoTArray
<
nsString
1
>
params
;
CopyUTF8toUTF16
(
spec
*
params
.
AppendElement
(
)
)
;
CSP_LogLocalizedStr
(
"
blockAllMixedContent
"
params
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
blockAllMixedContent
"
)
document
-
>
InnerWindowID
(
)
!
!
document
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_OK
;
}
bool
rootHasSecureConnection
=
docShell
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
-
>
GetIsSecure
(
)
;
bool
allowMixedContent
=
false
;
nsresult
rv
=
docShell
-
>
GetAllowMixedContentAndConnectionData
(
&
allowMixedContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aDecision
=
REJECT_REQUEST
;
return
rv
;
}
if
(
aContentType
=
=
TYPE_SUBDOCUMENT
&
&
!
rootHasSecureConnection
)
{
bool
httpsParentExists
=
false
;
RefPtr
<
BrowsingContext
>
curBC
=
docShell
-
>
GetBrowsingContext
(
)
;
while
(
!
httpsParentExists
&
&
curBC
)
{
httpsParentExists
=
curBC
-
>
GetIsSecure
(
)
;
curBC
=
curBC
-
>
GetParent
(
)
;
}
if
(
!
httpsParentExists
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIDocShell
>
rootShell
=
docShell
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
-
>
GetDocShell
(
)
;
nsCOMPtr
<
Document
>
rootDoc
=
rootShell
?
rootShell
-
>
GetDocument
(
)
:
nullptr
;
if
(
StaticPrefs
:
:
fission_autostart
(
)
)
{
if
(
!
rootShell
|
|
!
rootDoc
)
{
if
(
classification
=
=
eMixedDisplay
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
return
NS_OK
;
}
*
aDecision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
return
NS_OK
;
}
}
nsDocShell
*
nativeDocShell
=
nsDocShell
:
:
Cast
(
docShell
)
;
uint32_t
state
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
nsCOMPtr
<
nsISecureBrowserUI
>
securityUI
;
rootShell
-
>
GetSecurityUI
(
getter_AddRefs
(
securityUI
)
)
;
if
(
!
securityUI
)
{
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
return
NS_OK
;
}
nsresult
stateRV
=
securityUI
-
>
GetState
(
&
state
)
;
OriginAttributes
originAttributes
;
if
(
aLoadingPrincipal
)
{
originAttributes
=
aLoadingPrincipal
-
>
OriginAttributesRef
(
)
;
}
else
if
(
aTriggeringPrincipal
)
{
originAttributes
=
aTriggeringPrincipal
-
>
OriginAttributesRef
(
)
;
}
bool
active
=
(
classification
=
=
eMixedScript
)
;
if
(
!
aHadInsecureImageRedirect
)
{
if
(
XRE_IsParentProcess
(
)
)
{
AccumulateMixedContentHSTS
(
innerContentLocation
active
originAttributes
)
;
}
else
{
mozilla
:
:
dom
:
:
ContentChild
*
cc
=
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
;
if
(
cc
)
{
cc
-
>
SendAccumulateMixedContentHSTS
(
innerContentLocation
active
originAttributes
)
;
}
}
}
if
(
aContentType
=
=
TYPE_OBJECT_SUBREQUEST
)
{
if
(
!
StaticPrefs
:
:
security_mixed_content_block_object_subrequest
(
)
)
{
rootDoc
-
>
WarnOnceAbout
(
Document
:
:
eMixedDisplayObjectSubrequest
)
;
}
}
if
(
StaticPrefs
:
:
security_mixed_content_block_display_content
(
)
&
&
classification
=
=
eMixedDisplay
)
{
if
(
allowMixedContent
)
{
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eUserOverride
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedDisplayContentLoaded
(
true
)
;
if
(
rootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
;
}
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
)
)
;
}
}
}
else
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eBlocked
)
;
if
(
!
rootDoc
-
>
GetHasMixedDisplayContentBlocked
(
)
&
&
NS_SUCCEEDED
(
stateRV
)
)
{
rootDoc
-
>
SetHasMixedDisplayContentBlocked
(
true
)
;
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_BLOCKED_MIXED_DISPLAY_CONTENT
)
)
;
}
}
return
NS_OK
;
}
else
if
(
StaticPrefs
:
:
security_mixed_content_block_active_content
(
)
&
&
classification
=
=
eMixedScript
)
{
if
(
allowMixedContent
)
{
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eUserOverride
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
rootDoc
-
>
GetHasMixedActiveContentLoaded
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedActiveContentLoaded
(
true
)
;
if
(
rootHasSecureConnection
)
{
state
=
state
>
>
4
<
<
4
;
state
|
=
nsIWebProgressListener
:
:
STATE_IS_BROKEN
;
if
(
rootDoc
-
>
GetHasMixedDisplayContentLoaded
(
)
)
{
state
|
=
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_DISPLAY_CONTENT
;
}
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
return
NS_OK
;
}
else
{
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_LOADED_MIXED_ACTIVE_CONTENT
)
)
;
}
return
NS_OK
;
}
}
else
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_REQUEST
;
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eBlocked
)
;
if
(
rootDoc
-
>
GetHasMixedActiveContentBlocked
(
)
)
{
return
NS_OK
;
}
rootDoc
-
>
SetHasMixedActiveContentBlocked
(
true
)
;
if
(
NS_SUCCEEDED
(
stateRV
)
)
{
nativeDocShell
-
>
nsDocLoader
:
:
OnSecurityChange
(
aRequestingContext
(
state
|
nsIWebProgressListener
:
:
STATE_BLOCKED_MIXED_ACTIVE_CONTENT
)
)
;
}
return
NS_OK
;
}
}
else
{
LogMixedContentMessage
(
classification
aContentLocation
rootDoc
eUserOverride
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsMixedContentEvent
(
aRequestingContext
classification
rootHasSecureConnection
)
)
;
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
}
bool
nsMixedContentBlocker
:
:
URISafeToBeLoadedInSecureContext
(
nsIURI
*
aURI
)
{
bool
schemeLocal
=
false
;
bool
schemeNoReturnData
=
false
;
bool
schemeInherits
=
false
;
bool
schemeSecure
=
false
;
if
(
NS_FAILED
(
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_IS_LOCAL_RESOURCE
&
schemeLocal
)
)
|
|
NS_FAILED
(
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_DOES_NOT_RETURN_DATA
&
schemeNoReturnData
)
)
|
|
NS_FAILED
(
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_INHERITS_SECURITY_CONTEXT
&
schemeInherits
)
)
|
|
NS_FAILED
(
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_IS_POTENTIALLY_TRUSTWORTHY
&
schemeSecure
)
)
)
{
return
false
;
}
return
(
schemeLocal
|
|
schemeNoReturnData
|
|
schemeInherits
|
|
schemeSecure
)
;
}
NS_IMETHODIMP
nsMixedContentBlocker
:
:
ShouldProcess
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
if
(
!
aContentLocation
)
{
if
(
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
TYPE_OBJECT
)
{
*
aDecision
=
ACCEPT
;
return
NS_OK
;
}
NS_SetRequestBlockingReason
(
aLoadInfo
nsILoadInfo
:
:
BLOCKING_REASON_MIXED_BLOCKED
)
;
*
aDecision
=
REJECT_REQUEST
;
return
NS_ERROR_FAILURE
;
}
return
ShouldLoad
(
aContentLocation
aLoadInfo
aMimeGuess
aDecision
)
;
}
void
nsMixedContentBlocker
:
:
AccumulateMixedContentHSTS
(
nsIURI
*
aURI
bool
aActive
const
OriginAttributes
&
aOriginAttributes
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
bool
hsts
;
nsresult
rv
;
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
rv
=
sss
-
>
IsSecureURI
(
nsISiteSecurityService
:
:
HEADER_HSTS
aURI
0
aOriginAttributes
nullptr
nullptr
&
hsts
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
!
aActive
)
{
if
(
!
hsts
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_PASSIVE_NO_HSTS
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_PASSIVE_WITH_HSTS
)
;
}
}
else
{
if
(
!
hsts
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_ACTIVE_NO_HSTS
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MIXED_CONTENT_HSTS
MCB_HSTS_ACTIVE_WITH_HSTS
)
;
}
}
}
