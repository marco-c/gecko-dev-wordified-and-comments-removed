#
include
"
mozilla
/
dom
/
TrustedTypeUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
dom
/
CSPViolationData
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPUtils
.
h
"
#
include
"
mozilla
/
dom
/
TrustedHTML
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
namespace
mozilla
:
:
dom
:
:
TrustedTypeUtils
{
static
bool
DoesSinkTypeRequireTrustedTypes
(
nsIContentSecurityPolicy
*
aCSP
const
nsAString
&
aSinkGroup
)
{
uint32_t
numPolicies
=
0
;
if
(
aCSP
)
{
aCSP
-
>
GetPolicyCount
(
&
numPolicies
)
;
}
for
(
uint32_t
i
=
0
;
i
<
numPolicies
;
+
+
i
)
{
const
nsCSPPolicy
*
policy
=
aCSP
-
>
GetPolicy
(
i
)
;
if
(
policy
-
>
AreTrustedTypesForSinkGroupRequired
(
aSinkGroup
)
)
{
return
true
;
}
}
return
false
;
}
namespace
SinkTypeMismatch
{
enum
class
Value
{
Blocked
Allowed
}
;
static
constexpr
size_t
kTrimmedSourceLength
=
40
;
static
constexpr
nsLiteralString
kSampleSeparator
=
u
"
|
"
_ns
;
}
static
SinkTypeMismatch
:
:
Value
ShouldSinkTypeMismatchViolationBeBlockedByCSP
(
nsIContentSecurityPolicy
*
aCSP
const
nsAString
&
aSink
const
nsAString
&
aSinkGroup
const
nsAString
&
aSource
)
{
SinkTypeMismatch
:
:
Value
result
=
SinkTypeMismatch
:
:
Value
:
:
Allowed
;
uint32_t
numPolicies
=
0
;
if
(
aCSP
)
{
aCSP
-
>
GetPolicyCount
(
&
numPolicies
)
;
}
for
(
uint32_t
i
=
0
;
i
<
numPolicies
;
+
+
i
)
{
const
auto
*
policy
=
aCSP
-
>
GetPolicy
(
i
)
;
if
(
!
policy
-
>
AreTrustedTypesForSinkGroupRequired
(
aSinkGroup
)
)
{
continue
;
}
auto
caller
=
JSCallingLocation
:
:
Get
(
)
;
const
nsDependentSubstring
trimmedSource
=
Substring
(
aSource
0
SinkTypeMismatch
:
:
kTrimmedSourceLength
)
;
const
nsString
sample
=
aSink
+
SinkTypeMismatch
:
:
kSampleSeparator
+
trimmedSource
;
CSPViolationData
cspViolationData
{
i
CSPViolationData
:
:
Resource
{
CSPViolationData
:
:
BlockedContentSource
:
:
TrustedTypesSink
}
nsIContentSecurityPolicy
:
:
REQUIRE_TRUSTED_TYPES_FOR_DIRECTIVE
caller
.
FileName
(
)
caller
.
mLine
caller
.
mColumn
nullptr
sample
}
;
nsICSPEventListener
*
cspEventListener
=
nullptr
;
aCSP
-
>
LogTrustedTypesViolationDetailsUnchecked
(
std
:
:
move
(
cspViolationData
)
NS_LITERAL_STRING_FROM_CSTRING
(
REQUIRE_TRUSTED_TYPES_FOR_SCRIPT_OBSERVER_TOPIC
)
cspEventListener
)
;
if
(
policy
-
>
getDisposition
(
)
=
=
nsCSPPolicy
:
:
Disposition
:
:
Enforce
)
{
result
=
SinkTypeMismatch
:
:
Value
:
:
Blocked
;
}
}
return
result
;
}
static
void
ProcessValueWithADefaultPolicy
(
RefPtr
<
TrustedHTML
>
&
aResult
ErrorResult
&
aError
)
{
aResult
=
nullptr
;
}
void
GetTrustedTypesCompliantString
(
const
TrustedHTMLOrString
&
aInput
nsIContentSecurityPolicy
*
aCSP
const
nsAString
&
aSink
const
nsAString
&
aSinkGroup
nsAString
&
aResult
ErrorResult
&
aError
)
{
if
(
!
StaticPrefs
:
:
dom_security_trusted_types_enabled
(
)
)
{
aResult
=
aInput
.
IsString
(
)
?
aInput
.
GetAsString
(
)
:
aInput
.
GetAsTrustedHTML
(
)
.
mData
;
return
;
}
if
(
aInput
.
IsTrustedHTML
(
)
)
{
aResult
=
aInput
.
GetAsTrustedHTML
(
)
.
mData
;
return
;
}
if
(
!
DoesSinkTypeRequireTrustedTypes
(
aCSP
aSinkGroup
)
)
{
aResult
=
aInput
.
GetAsString
(
)
;
return
;
}
RefPtr
<
TrustedHTML
>
convertedInput
;
ProcessValueWithADefaultPolicy
(
convertedInput
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
if
(
!
convertedInput
)
{
if
(
ShouldSinkTypeMismatchViolationBeBlockedByCSP
(
aCSP
aSink
aSinkGroup
aInput
.
GetAsString
(
)
)
=
=
SinkTypeMismatch
:
:
Value
:
:
Allowed
)
{
aResult
=
aInput
.
GetAsString
(
)
;
return
;
}
aError
.
ThrowTypeError
(
"
Sink
type
mismatch
violation
blocked
by
CSP
"
_ns
)
;
return
;
}
aResult
=
convertedInput
-
>
mData
;
}
}
