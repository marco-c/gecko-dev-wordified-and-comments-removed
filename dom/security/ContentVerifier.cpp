#
include
"
ContentVerifier
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStringStream
.
h
"
using
namespace
mozilla
;
static
LazyLogModule
gContentVerifierPRLog
(
"
ContentVerifier
"
)
;
#
define
CSV_LOG
(
args
)
MOZ_LOG
(
gContentVerifierPRLog
LogLevel
:
:
Debug
args
)
NS_IMPL_ISUPPORTS
(
ContentVerifier
nsIContentSignatureReceiverCallback
nsIStreamListener
)
;
nsresult
ContentVerifier
:
:
Init
(
const
nsACString
&
aContentSignatureHeader
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aContentSignatureHeader
.
IsEmpty
(
)
)
{
CSV_LOG
(
(
"
Content
-
Signature
header
must
not
be
empty
!
\
n
"
)
)
;
return
NS_ERROR_INVALID_SIGNATURE
;
}
nsresult
rv
;
mVerifier
=
do_CreateInstance
(
"
mozilla
.
org
/
security
/
contentsignatureverifier
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
mVerifier
)
{
return
NS_ERROR_INVALID_SIGNATURE
;
}
mContentRequest
=
aRequest
;
mContentContext
=
aContext
;
rv
=
mVerifier
-
>
CreateContextWithoutCertChain
(
this
aContentSignatureHeader
NS_LITERAL_CSTRING
(
"
remotenewtab
.
content
-
signature
.
mozilla
.
org
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mVerifier
=
nullptr
;
}
return
rv
;
}
nsresult
AppendNextSegment
(
nsIInputStream
*
aInputStream
void
*
aClosure
const
char
*
aRawSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
outWrittenCount
)
{
FallibleTArray
<
nsCString
>
*
decodedData
=
static_cast
<
FallibleTArray
<
nsCString
>
*
>
(
aClosure
)
;
nsDependentCSubstring
segment
(
aRawSegment
aCount
)
;
if
(
!
decodedData
-
>
AppendElement
(
segment
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
*
outWrittenCount
=
aCount
;
return
NS_OK
;
}
void
ContentVerifier
:
:
FinishSignature
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIStreamListener
>
nextListener
;
nextListener
.
swap
(
mNextListener
)
;
bool
verified
=
false
;
nsresult
rv
=
NS_OK
;
if
(
NS_FAILED
(
mVerifier
-
>
End
(
&
verified
)
)
|
|
!
verified
)
{
CSV_LOG
(
(
"
failed
to
verify
content
\
n
"
)
)
;
(
void
)
nextListener
-
>
OnStopRequest
(
mContentRequest
mContentContext
NS_ERROR_INVALID_SIGNATURE
)
;
return
;
}
CSV_LOG
(
(
"
Successfully
verified
content
signature
.
\
n
"
)
)
;
uint64_t
offset
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mContent
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIInputStream
>
oInStr
;
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
oInStr
)
mContent
[
i
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
rv
=
nextListener
-
>
OnDataAvailable
(
mContentRequest
mContentContext
oInStr
offset
mContent
[
i
]
.
Length
(
)
)
;
offset
+
=
mContent
[
i
]
.
Length
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
nextListener
-
>
OnStopRequest
(
mContentRequest
mContentContext
rv
)
;
}
NS_IMETHODIMP
ContentVerifier
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
MOZ_CRASH
(
"
This
OnStartRequest
should
'
ve
never
been
called
!
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ContentVerifier
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
if
(
!
mNextListener
)
{
return
NS_OK
;
}
if
(
NS_FAILED
(
aStatus
)
)
{
CSV_LOG
(
(
"
Stream
failed
\
n
"
)
)
;
nsCOMPtr
<
nsIStreamListener
>
nextListener
;
nextListener
.
swap
(
mNextListener
)
;
return
nextListener
-
>
OnStopRequest
(
aRequest
aContext
aStatus
)
;
}
mContentRead
=
true
;
if
(
mContextCreated
)
{
FinishSignature
(
)
;
return
aStatus
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ContentVerifier
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
uint32_t
read
;
nsresult
rv
=
aInputStream
-
>
ReadSegments
(
AppendNextSegment
&
mContent
aCount
&
read
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
mContextCreated
)
{
return
mVerifier
-
>
Update
(
mContent
.
LastElement
(
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ContentVerifier
:
:
ContextCreated
(
bool
successful
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
successful
)
{
if
(
!
mNextListener
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIStreamListener
>
nextListener
;
nextListener
.
swap
(
mNextListener
)
;
MOZ_ASSERT
(
mContentRequest
)
;
CSV_LOG
(
(
"
failed
to
get
a
valid
cert
chain
\
n
"
)
)
;
if
(
mContentRequest
&
&
nextListener
)
{
mContentRequest
-
>
Cancel
(
NS_ERROR_INVALID_SIGNATURE
)
;
nsresult
rv
=
nextListener
-
>
OnStopRequest
(
mContentRequest
mContentContext
NS_ERROR_INVALID_SIGNATURE
)
;
mContentRequest
=
nullptr
;
mContentContext
=
nullptr
;
return
rv
;
}
MOZ_ASSERT_UNREACHABLE
(
"
ContentVerifier
was
used
without
getting
OnStartRequest
!
"
)
;
return
NS_OK
;
}
mContextCreated
=
true
;
for
(
size_t
i
=
0
;
i
<
mContent
.
Length
(
)
;
+
+
i
)
{
if
(
NS_FAILED
(
mVerifier
-
>
Update
(
mContent
[
i
]
)
)
)
{
break
;
}
}
if
(
mContentRead
)
{
FinishSignature
(
)
;
}
return
NS_OK
;
}
