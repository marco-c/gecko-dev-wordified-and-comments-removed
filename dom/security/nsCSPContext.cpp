#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSPContext
.
h
"
#
include
"
nsCSPParser
.
h
"
#
include
"
nsCSPService
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDOMHTMLDocument
.
h
"
#
include
"
nsIDOMHTMLElement
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
nsIUploadChannel
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsSupportsPrimitives
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
CSPReportBinding
.
h
"
#
include
"
mozilla
/
dom
/
CSPDictionariesBinding
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
nsXULAppAPI
.
h
"
using
namespace
mozilla
;
static
LogModule
*
GetCspContextLog
(
)
{
static
LazyLogModule
gCspContextPRLog
(
"
CSPContext
"
)
;
return
gCspContextPRLog
;
}
#
define
CSPCONTEXTLOG
(
args
)
MOZ_LOG
(
GetCspContextLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
CSPCONTEXTLOGENABLED
(
)
MOZ_LOG_TEST
(
GetCspContextLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
)
static
const
uint32_t
CSP_CACHE_URI_CUTOFF_SIZE
=
512
;
nsresult
CreateCacheKey_Internal
(
nsIURI
*
aContentLocation
nsContentPolicyType
aContentType
nsACString
&
outCacheKey
)
{
if
(
!
aContentLocation
)
{
return
NS_ERROR_FAILURE
;
}
bool
isDataScheme
=
false
;
nsresult
rv
=
aContentLocation
-
>
SchemeIs
(
"
data
"
&
isDataScheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outCacheKey
.
Truncate
(
)
;
if
(
aContentType
!
=
nsIContentPolicy
:
:
TYPE_SCRIPT
&
&
isDataScheme
)
{
outCacheKey
.
Append
(
NS_LITERAL_CSTRING
(
"
data
:
"
)
)
;
outCacheKey
.
AppendInt
(
aContentType
)
;
return
NS_OK
;
}
nsAutoCString
spec
;
rv
=
aContentLocation
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
spec
.
Length
(
)
<
=
CSP_CACHE_URI_CUTOFF_SIZE
)
{
outCacheKey
.
Append
(
spec
)
;
outCacheKey
.
Append
(
NS_LITERAL_CSTRING
(
"
!
"
)
)
;
outCacheKey
.
AppendInt
(
aContentType
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
ShouldLoad
(
nsContentPolicyType
aContentType
nsIURI
*
aContentLocation
nsIURI
*
aRequestOrigin
nsISupports
*
aRequestContext
const
nsACString
&
aMimeTypeGuess
nsISupports
*
aExtra
int16_t
*
outDecision
)
{
if
(
CSPCONTEXTLOGENABLED
(
)
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
ShouldLoad
aContentLocation
:
%
s
"
aContentLocation
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
CSPCONTEXTLOG
(
(
"
>
>
>
>
aContentType
:
%
d
"
aContentType
)
)
;
}
bool
isPreload
=
nsContentUtils
:
:
IsPreloadType
(
aContentType
)
;
aContentType
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternalOrWorker
(
aContentType
)
;
nsresult
rv
=
NS_OK
;
nsAutoCString
cacheKey
;
rv
=
CreateCacheKey_Internal
(
aContentLocation
aContentType
cacheKey
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isCached
=
mShouldLoadCache
.
Get
(
cacheKey
outDecision
)
;
if
(
isCached
&
&
cacheKey
.
Length
(
)
>
0
)
{
return
NS_OK
;
}
*
outDecision
=
nsIContentPolicy
:
:
ACCEPT
;
CSPDirective
dir
=
CSP_ContentTypeToDirective
(
aContentType
)
;
if
(
dir
=
=
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
)
{
return
NS_OK
;
}
nsAutoString
nonce
;
bool
parserCreated
=
false
;
if
(
!
isPreload
)
{
if
(
aContentType
=
=
nsIContentPolicy
:
:
TYPE_SCRIPT
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_STYLESHEET
)
{
nsCOMPtr
<
nsIDOMHTMLElement
>
htmlElement
=
do_QueryInterface
(
aRequestContext
)
;
if
(
htmlElement
)
{
rv
=
htmlElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
nonce
"
)
nonce
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
nsCOMPtr
<
nsIScriptElement
>
script
=
do_QueryInterface
(
aRequestContext
)
;
if
(
script
&
&
script
-
>
GetParserCreated
(
)
!
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
{
parserCreated
=
true
;
}
}
nsCOMPtr
<
nsIURI
>
originalURI
=
do_QueryInterface
(
aExtra
)
;
bool
wasRedirected
=
originalURI
;
bool
permitted
=
permitsInternal
(
dir
aContentLocation
originalURI
nonce
wasRedirected
isPreload
false
true
true
parserCreated
)
;
*
outDecision
=
permitted
?
nsIContentPolicy
:
:
ACCEPT
:
nsIContentPolicy
:
:
REJECT_SERVER
;
if
(
cacheKey
.
Length
(
)
>
0
&
&
!
isPreload
)
{
mShouldLoadCache
.
Put
(
cacheKey
*
outDecision
)
;
}
if
(
CSPCONTEXTLOGENABLED
(
)
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
ShouldLoad
decision
:
%
s
"
"
aContentLocation
:
%
s
"
*
outDecision
>
0
?
"
load
"
:
"
deny
"
aContentLocation
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
return
NS_OK
;
}
bool
nsCSPContext
:
:
permitsInternal
(
CSPDirective
aDir
nsIURI
*
aContentLocation
nsIURI
*
aOriginalURI
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aIsPreload
bool
aSpecific
bool
aSendViolationReports
bool
aSendContentLocationInViolationReports
bool
aParserCreated
)
{
bool
permits
=
true
;
nsAutoString
violatedDirective
;
for
(
uint32_t
p
=
0
;
p
<
mPolicies
.
Length
(
)
;
p
+
+
)
{
if
(
aDir
=
=
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
&
&
mPolicies
[
p
]
-
>
getReportOnlyFlag
(
)
)
{
continue
;
}
if
(
!
mPolicies
[
p
]
-
>
permits
(
aDir
aContentLocation
aNonce
aWasRedirected
aSpecific
aParserCreated
violatedDirective
)
)
{
if
(
!
mPolicies
[
p
]
-
>
getReportOnlyFlag
(
)
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
permitsInternal
false
"
)
)
;
permits
=
false
;
}
if
(
!
aIsPreload
&
&
aSendViolationReports
)
{
this
-
>
AsyncReportViolation
(
(
aSendContentLocationInViolationReports
?
aContentLocation
:
nullptr
)
aOriginalURI
violatedDirective
p
EmptyString
(
)
EmptyString
(
)
EmptyString
(
)
0
)
;
}
}
}
return
permits
;
}
NS_IMPL_CLASSINFO
(
nsCSPContext
nullptr
nsIClassInfo
:
:
MAIN_THREAD_ONLY
NS_CSPCONTEXT_CID
)
NS_IMPL_ISUPPORTS_CI
(
nsCSPContext
nsIContentSecurityPolicy
nsISerializable
)
nsCSPContext
:
:
nsCSPContext
(
)
:
mInnerWindowID
(
0
)
mLoadingContext
(
nullptr
)
mLoadingPrincipal
(
nullptr
)
mQueueUpMessages
(
true
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
nsCSPContext
"
)
)
;
}
nsCSPContext
:
:
~
nsCSPContext
(
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
~
nsCSPContext
"
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
delete
mPolicies
[
i
]
;
}
mShouldLoadCache
.
Clear
(
)
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetPolicyString
(
uint32_t
aIndex
nsAString
&
outStr
)
{
if
(
aIndex
>
=
mPolicies
.
Length
(
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
mPolicies
[
aIndex
]
-
>
toString
(
outStr
)
;
return
NS_OK
;
}
const
nsCSPPolicy
*
nsCSPContext
:
:
GetPolicy
(
uint32_t
aIndex
)
{
if
(
aIndex
>
=
mPolicies
.
Length
(
)
)
{
return
nullptr
;
}
return
mPolicies
[
aIndex
]
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetPolicyCount
(
uint32_t
*
outPolicyCount
)
{
*
outPolicyCount
=
mPolicies
.
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetUpgradeInsecureRequests
(
bool
*
outUpgradeRequest
)
{
*
outUpgradeRequest
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
if
(
mPolicies
[
i
]
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
)
{
*
outUpgradeRequest
=
true
;
return
NS_OK
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetBlockAllMixedContent
(
bool
*
outBlockAllMixedContent
)
{
*
outBlockAllMixedContent
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
if
(
!
mPolicies
[
i
]
-
>
getReportOnlyFlag
(
)
&
&
mPolicies
[
i
]
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
)
{
*
outBlockAllMixedContent
=
true
;
return
NS_OK
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetEnforcesFrameAncestors
(
bool
*
outEnforcesFrameAncestors
)
{
*
outEnforcesFrameAncestors
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
if
(
!
mPolicies
[
i
]
-
>
getReportOnlyFlag
(
)
&
&
mPolicies
[
i
]
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
)
)
{
*
outEnforcesFrameAncestors
=
true
;
return
NS_OK
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetReferrerPolicy
(
uint32_t
*
outPolicy
bool
*
outIsSet
)
{
*
outIsSet
=
false
;
*
outPolicy
=
mozilla
:
:
net
:
:
RP_Unset
;
nsAutoString
refpol
;
mozilla
:
:
net
:
:
ReferrerPolicy
previousPolicy
=
mozilla
:
:
net
:
:
RP_Unset
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
mPolicies
[
i
]
-
>
getReferrerPolicy
(
refpol
)
;
if
(
!
mPolicies
[
i
]
-
>
getReportOnlyFlag
(
)
&
&
!
refpol
.
IsEmpty
(
)
)
{
if
(
!
mozilla
:
:
net
:
:
IsValidReferrerPolicy
(
refpol
)
)
{
*
outPolicy
=
mozilla
:
:
net
:
:
RP_No_Referrer
;
*
outIsSet
=
true
;
return
NS_OK
;
}
uint32_t
currentPolicy
=
mozilla
:
:
net
:
:
ReferrerPolicyFromString
(
refpol
)
;
if
(
*
outIsSet
&
&
previousPolicy
!
=
currentPolicy
)
{
*
outPolicy
=
mozilla
:
:
net
:
:
RP_No_Referrer
;
return
NS_OK
;
}
*
outPolicy
=
currentPolicy
;
*
outIsSet
=
true
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
AppendPolicy
(
const
nsAString
&
aPolicyString
bool
aReportOnly
bool
aDeliveredViaMetaTag
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
AppendPolicy
:
%
s
"
NS_ConvertUTF16toUTF8
(
aPolicyString
)
.
get
(
)
)
)
;
NS_ASSERTION
(
mSelfURI
"
mSelfURI
required
for
AppendPolicy
but
not
set
"
)
;
nsCSPPolicy
*
policy
=
nsCSPParser
:
:
parseContentSecurityPolicy
(
aPolicyString
mSelfURI
aReportOnly
this
aDeliveredViaMetaTag
)
;
if
(
policy
)
{
mPolicies
.
AppendElement
(
policy
)
;
mShouldLoadCache
.
Clear
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetAllowsEval
(
bool
*
outShouldReportViolation
bool
*
outAllowsEval
)
{
*
outShouldReportViolation
=
false
;
*
outAllowsEval
=
true
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
if
(
!
mPolicies
[
i
]
-
>
allows
(
nsIContentPolicy
:
:
TYPE_SCRIPT
CSP_UNSAFE_EVAL
EmptyString
(
)
false
)
)
{
*
outShouldReportViolation
=
true
;
if
(
!
mPolicies
[
i
]
-
>
getReportOnlyFlag
(
)
)
{
*
outAllowsEval
=
false
;
}
}
}
return
NS_OK
;
}
void
nsCSPContext
:
:
reportInlineViolation
(
nsContentPolicyType
aContentType
const
nsAString
&
aNonce
const
nsAString
&
aContent
const
nsAString
&
aViolatedDirective
uint32_t
aViolatedPolicyIndex
uint32_t
aLineNumber
)
{
nsString
observerSubject
;
if
(
!
aNonce
.
IsEmpty
(
)
)
{
observerSubject
=
(
aContentType
=
=
nsIContentPolicy
:
:
TYPE_SCRIPT
)
?
NS_LITERAL_STRING
(
SCRIPT_NONCE_VIOLATION_OBSERVER_TOPIC
)
:
NS_LITERAL_STRING
(
STYLE_NONCE_VIOLATION_OBSERVER_TOPIC
)
;
}
else
{
observerSubject
=
(
aContentType
=
=
nsIContentPolicy
:
:
TYPE_SCRIPT
)
?
NS_LITERAL_STRING
(
SCRIPT_HASH_VIOLATION_OBSERVER_TOPIC
)
:
NS_LITERAL_STRING
(
STYLE_HASH_VIOLATION_OBSERVER_TOPIC
)
;
}
nsCOMPtr
<
nsISupportsCString
>
selfICString
(
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
)
)
;
if
(
selfICString
)
{
selfICString
-
>
SetData
(
nsDependentCString
(
"
self
"
)
)
;
}
nsCOMPtr
<
nsISupports
>
selfISupports
(
do_QueryInterface
(
selfICString
)
)
;
nsAutoCString
sourceFile
;
if
(
mSelfURI
)
{
mSelfURI
-
>
GetSpec
(
sourceFile
)
;
}
nsAutoString
codeSample
(
aContent
)
;
if
(
codeSample
.
Length
(
)
>
40
)
{
codeSample
.
Truncate
(
40
)
;
codeSample
.
AppendLiteral
(
"
.
.
.
"
)
;
}
AsyncReportViolation
(
selfISupports
mSelfURI
aViolatedDirective
aViolatedPolicyIndex
observerSubject
NS_ConvertUTF8toUTF16
(
sourceFile
)
codeSample
aLineNumber
)
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetAllowsInline
(
nsContentPolicyType
aContentType
const
nsAString
&
aNonce
bool
aParserCreated
const
nsAString
&
aContent
uint32_t
aLineNumber
bool
*
outAllowsInline
)
{
*
outAllowsInline
=
true
;
MOZ_ASSERT
(
aContentType
=
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
aContentType
)
"
We
should
only
see
external
content
policy
types
here
.
"
)
;
if
(
aContentType
!
=
nsIContentPolicy
:
:
TYPE_SCRIPT
&
&
aContentType
!
=
nsIContentPolicy
:
:
TYPE_STYLESHEET
)
{
MOZ_ASSERT
(
false
"
can
only
allow
inline
for
script
or
style
"
)
;
return
NS_OK
;
}
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
bool
allowed
=
mPolicies
[
i
]
-
>
allows
(
aContentType
CSP_UNSAFE_INLINE
EmptyString
(
)
aParserCreated
)
|
|
mPolicies
[
i
]
-
>
allows
(
aContentType
CSP_NONCE
aNonce
aParserCreated
)
|
|
mPolicies
[
i
]
-
>
allows
(
aContentType
CSP_HASH
aContent
aParserCreated
)
;
if
(
!
allowed
)
{
if
(
!
mPolicies
[
i
]
-
>
getReportOnlyFlag
(
)
)
{
*
outAllowsInline
=
false
;
}
nsAutoString
violatedDirective
;
mPolicies
[
i
]
-
>
getDirectiveStringForContentType
(
aContentType
violatedDirective
)
;
reportInlineViolation
(
aContentType
aNonce
aContent
violatedDirective
i
aLineNumber
)
;
}
}
return
NS_OK
;
}
#
define
CASE_CHECK_AND_REPORT
(
violationType
contentPolicyType
nonceOrHash
\
keyword
observerTopic
)
\
case
nsIContentSecurityPolicy
:
:
VIOLATION_TYPE_
#
#
violationType
:
\
PR_BEGIN_MACRO
\
if
(
!
mPolicies
[
p
]
-
>
allows
(
nsIContentPolicy
:
:
TYPE_
#
#
contentPolicyType
\
keyword
nonceOrHash
false
)
)
\
{
\
nsAutoString
violatedDirective
;
\
mPolicies
[
p
]
-
>
getDirectiveStringForContentType
(
\
nsIContentPolicy
:
:
TYPE_
#
#
contentPolicyType
\
violatedDirective
)
;
\
this
-
>
AsyncReportViolation
(
selfISupports
nullptr
violatedDirective
p
\
NS_LITERAL_STRING
(
observerTopic
)
\
aSourceFile
aScriptSample
aLineNum
)
;
\
}
\
PR_END_MACRO
;
\
break
NS_IMETHODIMP
nsCSPContext
:
:
LogViolationDetails
(
uint16_t
aViolationType
const
nsAString
&
aSourceFile
const
nsAString
&
aScriptSample
int32_t
aLineNum
const
nsAString
&
aNonce
const
nsAString
&
aContent
)
{
for
(
uint32_t
p
=
0
;
p
<
mPolicies
.
Length
(
)
;
p
+
+
)
{
NS_ASSERTION
(
mPolicies
[
p
]
"
null
pointer
in
nsTArray
<
nsCSPPolicy
>
"
)
;
nsCOMPtr
<
nsISupportsCString
>
selfICString
(
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
)
)
;
if
(
selfICString
)
{
selfICString
-
>
SetData
(
nsDependentCString
(
"
self
"
)
)
;
}
nsCOMPtr
<
nsISupports
>
selfISupports
(
do_QueryInterface
(
selfICString
)
)
;
switch
(
aViolationType
)
{
CASE_CHECK_AND_REPORT
(
EVAL
SCRIPT
NS_LITERAL_STRING
(
"
"
)
CSP_UNSAFE_EVAL
EVAL_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
INLINE_STYLE
STYLESHEET
NS_LITERAL_STRING
(
"
"
)
CSP_UNSAFE_INLINE
INLINE_STYLE_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
INLINE_SCRIPT
SCRIPT
NS_LITERAL_STRING
(
"
"
)
CSP_UNSAFE_INLINE
INLINE_SCRIPT_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
NONCE_SCRIPT
SCRIPT
aNonce
CSP_UNSAFE_INLINE
SCRIPT_NONCE_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
NONCE_STYLE
STYLESHEET
aNonce
CSP_UNSAFE_INLINE
STYLE_NONCE_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
HASH_SCRIPT
SCRIPT
aContent
CSP_UNSAFE_INLINE
SCRIPT_HASH_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
HASH_STYLE
STYLESHEET
aContent
CSP_UNSAFE_INLINE
STYLE_HASH_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
REQUIRE_SRI_FOR_STYLE
STYLESHEET
NS_LITERAL_STRING
(
"
"
)
CSP_REQUIRE_SRI_FOR
REQUIRE_SRI_STYLE_VIOLATION_OBSERVER_TOPIC
)
;
CASE_CHECK_AND_REPORT
(
REQUIRE_SRI_FOR_SCRIPT
SCRIPT
NS_LITERAL_STRING
(
"
"
)
CSP_REQUIRE_SRI_FOR
REQUIRE_SRI_SCRIPT_VIOLATION_OBSERVER_TOPIC
)
;
default
:
NS_ASSERTION
(
false
"
LogViolationDetails
with
invalid
type
"
)
;
break
;
}
}
return
NS_OK
;
}
#
undef
CASE_CHECK_AND_REPORT
NS_IMETHODIMP
nsCSPContext
:
:
SetRequestContext
(
nsIDOMDocument
*
aDOMDocument
nsIPrincipal
*
aPrincipal
)
{
NS_PRECONDITION
(
aDOMDocument
|
|
aPrincipal
"
Can
'
t
set
context
without
doc
or
principal
"
)
;
NS_ENSURE_ARG
(
aDOMDocument
|
|
aPrincipal
)
;
if
(
aDOMDocument
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
aDOMDocument
)
;
mLoadingContext
=
do_GetWeakReference
(
doc
)
;
mSelfURI
=
doc
-
>
GetDocumentURI
(
)
;
mLoadingPrincipal
=
doc
-
>
NodePrincipal
(
)
;
doc
-
>
GetReferrer
(
mReferrer
)
;
mInnerWindowID
=
doc
-
>
InnerWindowID
(
)
;
mQueueUpMessages
=
!
mInnerWindowID
;
mCallingChannelLoadGroup
=
doc
-
>
GetDocumentLoadGroup
(
)
;
doc
-
>
SetHasCSP
(
true
)
;
mEventTarget
=
doc
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
else
{
CSPCONTEXTLOG
(
(
"
No
Document
in
SetRequestContext
;
can
not
query
loadgroup
;
sending
reports
may
fail
.
"
)
)
;
mLoadingPrincipal
=
aPrincipal
;
mLoadingPrincipal
-
>
GetURI
(
getter_AddRefs
(
mSelfURI
)
)
;
mQueueUpMessages
=
false
;
}
NS_ASSERTION
(
mSelfURI
"
mSelfURI
not
available
can
not
translate
'
self
'
into
actual
URI
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
EnsureEventTarget
(
nsIEventTarget
*
aEventTarget
)
{
NS_ENSURE_ARG
(
aEventTarget
)
;
if
(
mEventTarget
)
{
return
NS_OK
;
}
mEventTarget
=
aEventTarget
;
return
NS_OK
;
}
struct
ConsoleMsgQueueElem
{
nsXPIDLString
mMsg
;
nsString
mSourceName
;
nsString
mSourceLine
;
uint32_t
mLineNumber
;
uint32_t
mColumnNumber
;
uint32_t
mSeverityFlag
;
}
;
void
nsCSPContext
:
:
flushConsoleMessages
(
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryReferent
(
mLoadingContext
)
;
if
(
doc
)
{
mInnerWindowID
=
doc
-
>
InnerWindowID
(
)
;
}
mQueueUpMessages
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mConsoleMsgQueue
.
Length
(
)
;
i
+
+
)
{
ConsoleMsgQueueElem
&
elem
=
mConsoleMsgQueue
[
i
]
;
CSP_LogMessage
(
elem
.
mMsg
elem
.
mSourceName
elem
.
mSourceLine
elem
.
mLineNumber
elem
.
mColumnNumber
elem
.
mSeverityFlag
"
CSP
"
mInnerWindowID
)
;
}
mConsoleMsgQueue
.
Clear
(
)
;
}
void
nsCSPContext
:
:
logToConsole
(
const
char
*
aName
const
char16_t
*
*
aParams
uint32_t
aParamsLength
const
nsAString
&
aSourceName
const
nsAString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aSeverityFlag
)
{
if
(
mQueueUpMessages
)
{
nsXPIDLString
msg
;
CSP_GetLocalizedStr
(
aName
aParams
aParamsLength
getter_Copies
(
msg
)
)
;
ConsoleMsgQueueElem
&
elem
=
*
mConsoleMsgQueue
.
AppendElement
(
)
;
elem
.
mMsg
=
msg
;
elem
.
mSourceName
=
PromiseFlatString
(
aSourceName
)
;
elem
.
mSourceLine
=
PromiseFlatString
(
aSourceLine
)
;
elem
.
mLineNumber
=
aLineNumber
;
elem
.
mColumnNumber
=
aColumnNumber
;
elem
.
mSeverityFlag
=
aSeverityFlag
;
return
;
}
CSP_LogLocalizedStr
(
aName
aParams
aParamsLength
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aSeverityFlag
"
CSP
"
mInnerWindowID
)
;
}
void
StripURIForReporting
(
nsIURI
*
aURI
nsIURI
*
aSelfURI
nsACString
&
outStrippedURI
)
{
bool
isHttpOrFtp
=
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
http
"
&
isHttpOrFtp
)
)
&
&
isHttpOrFtp
)
|
|
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
https
"
&
isHttpOrFtp
)
)
&
&
isHttpOrFtp
)
|
|
(
NS_SUCCEEDED
(
aURI
-
>
SchemeIs
(
"
ftp
"
&
isHttpOrFtp
)
)
&
&
isHttpOrFtp
)
;
if
(
!
isHttpOrFtp
)
{
aURI
-
>
GetScheme
(
outStrippedURI
)
;
return
;
}
if
(
!
NS_SecurityCompareURIs
(
aSelfURI
aURI
false
)
)
{
aURI
-
>
GetPrePath
(
outStrippedURI
)
;
return
;
}
aURI
-
>
GetSpecIgnoringRef
(
outStrippedURI
)
;
}
nsresult
nsCSPContext
:
:
SendReports
(
nsISupports
*
aBlockedContentSource
nsIURI
*
aOriginalURI
nsAString
&
aViolatedDirective
uint32_t
aViolatedPolicyIndex
nsAString
&
aSourceFile
nsAString
&
aScriptSample
uint32_t
aLineNum
)
{
NS_ENSURE_ARG_MAX
(
aViolatedPolicyIndex
mPolicies
.
Length
(
)
-
1
)
;
#
ifdef
MOZ_B2G
if
(
!
mCallingChannelLoadGroup
)
{
NS_WARNING
(
"
Load
group
required
but
not
present
for
report
sending
;
cannot
send
CSP
violation
reports
"
)
;
return
NS_ERROR_FAILURE
;
}
#
endif
dom
:
:
CSPReport
report
;
nsresult
rv
;
if
(
aBlockedContentSource
)
{
nsAutoCString
reportBlockedURI
;
nsCOMPtr
<
nsIURI
>
uri
=
do_QueryInterface
(
aBlockedContentSource
)
;
if
(
uri
)
{
StripURIForReporting
(
uri
mSelfURI
reportBlockedURI
)
;
}
else
{
nsCOMPtr
<
nsISupportsCString
>
cstr
=
do_QueryInterface
(
aBlockedContentSource
)
;
if
(
cstr
)
{
cstr
-
>
GetData
(
reportBlockedURI
)
;
}
}
if
(
reportBlockedURI
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
No
blocked
URI
(
null
aBlockedContentSource
)
for
CSP
violation
report
.
"
)
;
}
report
.
mCsp_report
.
mBlocked_uri
=
NS_ConvertUTF8toUTF16
(
reportBlockedURI
)
;
}
nsAutoCString
reportDocumentURI
;
StripURIForReporting
(
mSelfURI
mSelfURI
reportDocumentURI
)
;
report
.
mCsp_report
.
mDocument_uri
=
NS_ConvertUTF8toUTF16
(
reportDocumentURI
)
;
nsAutoString
originalPolicy
;
rv
=
this
-
>
GetPolicyString
(
aViolatedPolicyIndex
originalPolicy
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
report
.
mCsp_report
.
mOriginal_policy
=
originalPolicy
;
if
(
!
mReferrer
.
IsEmpty
(
)
)
{
report
.
mCsp_report
.
mReferrer
=
mReferrer
;
}
report
.
mCsp_report
.
mViolated_directive
=
aViolatedDirective
;
if
(
!
aSourceFile
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURI
>
sourceURI
;
NS_NewURI
(
getter_AddRefs
(
sourceURI
)
aSourceFile
)
;
if
(
sourceURI
)
{
nsAutoCString
spec
;
sourceURI
-
>
GetSpecIgnoringRef
(
spec
)
;
aSourceFile
=
NS_ConvertUTF8toUTF16
(
spec
)
;
}
report
.
mCsp_report
.
mSource_file
.
Construct
(
)
;
report
.
mCsp_report
.
mSource_file
.
Value
(
)
=
aSourceFile
;
}
if
(
!
aScriptSample
.
IsEmpty
(
)
)
{
report
.
mCsp_report
.
mScript_sample
.
Construct
(
)
;
report
.
mCsp_report
.
mScript_sample
.
Value
(
)
=
aScriptSample
;
}
if
(
aLineNum
!
=
0
)
{
report
.
mCsp_report
.
mLine_number
.
Construct
(
)
;
report
.
mCsp_report
.
mLine_number
.
Value
(
)
=
aLineNum
;
}
nsString
csp_report
;
if
(
!
report
.
ToJSON
(
csp_report
)
)
{
return
NS_ERROR_FAILURE
;
}
nsTArray
<
nsString
>
reportURIs
;
mPolicies
[
aViolatedPolicyIndex
]
-
>
getReportURIs
(
reportURIs
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryReferent
(
mLoadingContext
)
;
nsCOMPtr
<
nsIURI
>
reportURI
;
nsCOMPtr
<
nsIChannel
>
reportChannel
;
for
(
uint32_t
r
=
0
;
r
<
reportURIs
.
Length
(
)
;
r
+
+
)
{
nsAutoCString
reportURICstring
=
NS_ConvertUTF16toUTF8
(
reportURIs
[
r
]
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
reportURI
)
reportURIs
[
r
]
)
;
if
(
NS_FAILED
(
rv
)
)
{
const
char16_t
*
params
[
]
=
{
reportURIs
[
r
]
.
get
(
)
}
;
CSPCONTEXTLOG
(
(
"
Could
not
create
nsIURI
for
report
URI
%
s
"
reportURICstring
.
get
(
)
)
)
;
logToConsole
(
"
triedToSendReport
"
params
ArrayLength
(
params
)
aSourceFile
aScriptSample
aLineNum
0
nsIScriptError
:
:
errorFlag
)
;
continue
;
}
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
;
if
(
doc
)
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
reportChannel
)
reportURI
doc
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_CSP_REPORT
nullptr
nullptr
loadFlags
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
reportChannel
)
reportURI
mLoadingPrincipal
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_CSP_REPORT
nullptr
nullptr
loadFlags
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
CSPCONTEXTLOG
(
(
"
Could
not
create
new
channel
for
report
URI
%
s
"
reportURICstring
.
get
(
)
)
)
;
continue
;
}
bool
isHttpScheme
=
(
NS_SUCCEEDED
(
reportURI
-
>
SchemeIs
(
"
http
"
&
isHttpScheme
)
)
&
&
isHttpScheme
)
|
|
(
NS_SUCCEEDED
(
reportURI
-
>
SchemeIs
(
"
https
"
&
isHttpScheme
)
)
&
&
isHttpScheme
)
;
if
(
!
isHttpScheme
)
{
const
char16_t
*
params
[
]
=
{
reportURIs
[
r
]
.
get
(
)
}
;
logToConsole
(
"
reportURInotHttpsOrHttp2
"
params
ArrayLength
(
params
)
aSourceFile
aScriptSample
aLineNum
0
nsIScriptError
:
:
errorFlag
)
;
continue
;
}
nsLoadFlags
flags
;
rv
=
reportChannel
-
>
GetLoadFlags
(
&
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
flags
|
=
nsIRequest
:
:
LOAD_ANONYMOUS
;
rv
=
reportChannel
-
>
SetLoadFlags
(
flags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
CSPReportRedirectSink
>
reportSink
=
new
CSPReportRedirectSink
(
)
;
if
(
doc
&
&
doc
-
>
GetDocShell
(
)
)
{
nsCOMPtr
<
nsINetworkInterceptController
>
interceptController
=
do_QueryInterface
(
doc
-
>
GetDocShell
(
)
)
;
reportSink
-
>
SetInterceptController
(
interceptController
)
;
}
reportChannel
-
>
SetNotificationCallbacks
(
reportSink
)
;
rv
=
reportChannel
-
>
SetLoadGroup
(
mCallingChannelLoadGroup
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIStringInputStream
>
sis
(
do_CreateInstance
(
NS_STRINGINPUTSTREAM_CONTRACTID
)
)
;
NS_ASSERTION
(
sis
"
nsIStringInputStream
is
needed
but
not
available
to
send
CSP
violation
reports
"
)
;
nsAutoCString
utf8CSPReport
=
NS_ConvertUTF16toUTF8
(
csp_report
)
;
rv
=
sis
-
>
SetData
(
utf8CSPReport
.
get
(
)
utf8CSPReport
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
(
do_QueryInterface
(
reportChannel
)
)
;
if
(
!
uploadChannel
)
{
continue
;
}
rv
=
uploadChannel
-
>
SetUploadStream
(
sis
NS_LITERAL_CSTRING
(
"
application
/
csp
-
report
"
)
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
reportChannel
)
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
SetRequestMethod
(
NS_LITERAL_CSTRING
(
"
POST
"
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
RefPtr
<
CSPViolationReportListener
>
listener
=
new
CSPViolationReportListener
(
)
;
rv
=
reportChannel
-
>
AsyncOpen2
(
listener
)
;
if
(
NS_FAILED
(
rv
)
)
{
const
char16_t
*
params
[
]
=
{
reportURIs
[
r
]
.
get
(
)
}
;
CSPCONTEXTLOG
(
(
"
AsyncOpen
failed
for
report
URI
%
s
"
NS_ConvertUTF16toUTF8
(
params
[
0
]
)
.
get
(
)
)
)
;
logToConsole
(
"
triedToSendReport
"
params
ArrayLength
(
params
)
aSourceFile
aScriptSample
aLineNum
0
nsIScriptError
:
:
errorFlag
)
;
}
else
{
CSPCONTEXTLOG
(
(
"
Sent
violation
report
to
URI
%
s
"
reportURICstring
.
get
(
)
)
)
;
}
}
return
NS_OK
;
}
class
CSPReportSenderRunnable
final
:
public
Runnable
{
public
:
CSPReportSenderRunnable
(
nsISupports
*
aBlockedContentSource
nsIURI
*
aOriginalURI
uint32_t
aViolatedPolicyIndex
bool
aReportOnlyFlag
const
nsAString
&
aViolatedDirective
const
nsAString
&
aObserverSubject
const
nsAString
&
aSourceFile
const
nsAString
&
aScriptSample
uint32_t
aLineNum
nsCSPContext
*
aCSPContext
)
:
mozilla
:
:
Runnable
(
"
CSPReportSenderRunnable
"
)
mBlockedContentSource
(
aBlockedContentSource
)
mOriginalURI
(
aOriginalURI
)
mViolatedPolicyIndex
(
aViolatedPolicyIndex
)
mReportOnlyFlag
(
aReportOnlyFlag
)
mViolatedDirective
(
aViolatedDirective
)
mSourceFile
(
aSourceFile
)
mScriptSample
(
aScriptSample
)
mLineNum
(
aLineNum
)
mCSPContext
(
aCSPContext
)
{
NS_ASSERTION
(
!
aViolatedDirective
.
IsEmpty
(
)
"
Can
not
send
reports
without
a
violated
directive
"
)
;
if
(
aObserverSubject
.
IsEmpty
(
)
)
{
mObserverSubject
=
aBlockedContentSource
;
}
else
{
nsCOMPtr
<
nsISupportsCString
>
supportscstr
=
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
)
;
NS_ASSERTION
(
supportscstr
"
Couldn
'
t
allocate
nsISupportsCString
"
)
;
supportscstr
-
>
SetData
(
NS_ConvertUTF16toUTF8
(
aObserverSubject
)
)
;
mObserverSubject
=
do_QueryInterface
(
supportscstr
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
observerService
"
needs
observer
service
"
)
;
nsresult
rv
=
observerService
-
>
NotifyObservers
(
mObserverSubject
CSP_VIOLATION_TOPIC
mViolatedDirective
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCSPContext
-
>
SendReports
(
mBlockedContentSource
mOriginalURI
mViolatedDirective
mViolatedPolicyIndex
mSourceFile
mScriptSample
mLineNum
)
;
nsCOMPtr
<
nsIURI
>
blockedURI
=
do_QueryInterface
(
mBlockedContentSource
)
;
nsCOMPtr
<
nsISupportsCString
>
blockedString
=
do_QueryInterface
(
mBlockedContentSource
)
;
nsCString
blockedDataStr
;
if
(
blockedURI
)
{
blockedURI
-
>
GetSpec
(
blockedDataStr
)
;
bool
isData
=
false
;
rv
=
blockedURI
-
>
SchemeIs
(
"
data
"
&
isData
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isData
)
{
blockedDataStr
.
Truncate
(
40
)
;
blockedDataStr
.
AppendASCII
(
"
.
.
.
"
)
;
}
}
else
if
(
blockedString
)
{
blockedString
-
>
GetData
(
blockedDataStr
)
;
}
if
(
blockedDataStr
.
Length
(
)
>
0
)
{
nsString
blockedDataChar16
=
NS_ConvertUTF8toUTF16
(
blockedDataStr
)
;
const
char16_t
*
params
[
]
=
{
mViolatedDirective
.
get
(
)
blockedDataChar16
.
get
(
)
}
;
mCSPContext
-
>
logToConsole
(
mReportOnlyFlag
?
"
CSPROViolationWithURI
"
:
"
CSPViolationWithURI
"
params
ArrayLength
(
params
)
mSourceFile
mScriptSample
mLineNum
0
nsIScriptError
:
:
errorFlag
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsISupports
>
mBlockedContentSource
;
nsCOMPtr
<
nsIURI
>
mOriginalURI
;
uint32_t
mViolatedPolicyIndex
;
bool
mReportOnlyFlag
;
nsString
mViolatedDirective
;
nsCOMPtr
<
nsISupports
>
mObserverSubject
;
nsString
mSourceFile
;
nsString
mScriptSample
;
uint32_t
mLineNum
;
RefPtr
<
nsCSPContext
>
mCSPContext
;
}
;
nsresult
nsCSPContext
:
:
AsyncReportViolation
(
nsISupports
*
aBlockedContentSource
nsIURI
*
aOriginalURI
const
nsAString
&
aViolatedDirective
uint32_t
aViolatedPolicyIndex
const
nsAString
&
aObserverSubject
const
nsAString
&
aSourceFile
const
nsAString
&
aScriptSample
uint32_t
aLineNum
)
{
NS_ENSURE_ARG_MAX
(
aViolatedPolicyIndex
mPolicies
.
Length
(
)
-
1
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
new
CSPReportSenderRunnable
(
aBlockedContentSource
aOriginalURI
aViolatedPolicyIndex
mPolicies
[
aViolatedPolicyIndex
]
-
>
getReportOnlyFlag
(
)
aViolatedDirective
aObserverSubject
aSourceFile
aScriptSample
aLineNum
this
)
;
if
(
XRE_IsContentProcess
(
)
)
{
if
(
mEventTarget
)
{
if
(
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
task
)
)
{
named
-
>
SetName
(
"
CSPReportSenderRunnable
"
)
;
}
mEventTarget
-
>
Dispatch
(
task
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
}
NS_DispatchToMainThread
(
task
.
forget
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
RequireSRIForType
(
nsContentPolicyType
aContentType
bool
*
outRequiresSRIForType
)
{
*
outRequiresSRIForType
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
if
(
mPolicies
[
i
]
-
>
hasDirective
(
REQUIRE_SRI_FOR
)
)
{
if
(
mPolicies
[
i
]
-
>
requireSRIForType
(
aContentType
)
)
{
*
outRequiresSRIForType
=
true
;
return
NS_OK
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
PermitsAncestry
(
nsIDocShell
*
aDocShell
bool
*
outPermitsAncestry
)
{
nsresult
rv
;
if
(
aDocShell
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
*
outPermitsAncestry
=
true
;
nsCOMArray
<
nsIURI
>
ancestorsArray
;
nsCOMPtr
<
nsIInterfaceRequestor
>
ir
(
do_QueryInterface
(
aDocShell
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
do_GetInterface
(
ir
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentTreeItem
;
nsCOMPtr
<
nsIURI
>
currentURI
;
nsCOMPtr
<
nsIURI
>
uriClone
;
while
(
NS_SUCCEEDED
(
treeItem
-
>
GetParent
(
getter_AddRefs
(
parentTreeItem
)
)
)
&
&
parentTreeItem
!
=
nullptr
)
{
if
(
parentTreeItem
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
break
;
}
nsIDocument
*
doc
=
parentTreeItem
-
>
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
Could
not
get
nsIDocument
from
nsIDocShellTreeItem
in
nsCSPContext
:
:
PermitsAncestry
"
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
currentURI
=
doc
-
>
GetDocumentURI
(
)
;
if
(
currentURI
)
{
rv
=
currentURI
-
>
CloneIgnoringRef
(
getter_AddRefs
(
uriClone
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uriClone
-
>
SetUserPass
(
EmptyCString
(
)
)
;
if
(
CSPCONTEXTLOGENABLED
(
)
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
PermitsAncestry
found
ancestor
:
%
s
"
uriClone
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
ancestorsArray
.
AppendElement
(
uriClone
)
;
}
treeItem
=
parentTreeItem
;
}
nsAutoString
violatedDirective
;
for
(
uint32_t
a
=
0
;
a
<
ancestorsArray
.
Length
(
)
;
a
+
+
)
{
if
(
CSPCONTEXTLOGENABLED
(
)
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
PermitsAncestry
checking
ancestor
:
%
s
"
ancestorsArray
[
a
]
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
bool
okToSendAncestor
=
NS_SecurityCompareURIs
(
ancestorsArray
[
a
]
mSelfURI
true
)
;
bool
permits
=
permitsInternal
(
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
ancestorsArray
[
a
]
nullptr
EmptyString
(
)
false
false
true
true
okToSendAncestor
false
)
;
if
(
!
permits
)
{
*
outPermitsAncestry
=
false
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
Permits
(
nsIURI
*
aURI
CSPDirective
aDir
bool
aSpecific
bool
*
outPermits
)
{
if
(
aURI
=
=
nullptr
)
{
return
NS_ERROR_FAILURE
;
}
*
outPermits
=
permitsInternal
(
aDir
aURI
nullptr
EmptyString
(
)
false
false
aSpecific
true
true
false
)
;
if
(
CSPCONTEXTLOGENABLED
(
)
)
{
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
Permits
aUri
:
%
s
aDir
:
%
d
isAllowed
:
%
s
"
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
aDir
*
outPermits
?
"
allow
"
:
"
deny
"
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
ToJSON
(
nsAString
&
outCSPinJSON
)
{
outCSPinJSON
.
Truncate
(
)
;
dom
:
:
CSPPolicies
jsonPolicies
;
jsonPolicies
.
mCsp_policies
.
Construct
(
)
;
for
(
uint32_t
p
=
0
;
p
<
mPolicies
.
Length
(
)
;
p
+
+
)
{
dom
:
:
CSP
jsonCSP
;
mPolicies
[
p
]
-
>
toDomCSPStruct
(
jsonCSP
)
;
jsonPolicies
.
mCsp_policies
.
Value
(
)
.
AppendElement
(
jsonCSP
fallible
)
;
}
if
(
!
jsonPolicies
.
ToJSON
(
outCSPinJSON
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
GetCSPSandboxFlags
(
uint32_t
*
aOutSandboxFlags
)
{
if
(
!
aOutSandboxFlags
)
{
return
NS_ERROR_FAILURE
;
}
*
aOutSandboxFlags
=
SANDBOXED_NONE
;
for
(
uint32_t
i
=
0
;
i
<
mPolicies
.
Length
(
)
;
i
+
+
)
{
uint32_t
flags
=
mPolicies
[
i
]
-
>
getSandboxFlags
(
)
;
if
(
!
flags
)
{
continue
;
}
if
(
!
mPolicies
[
i
]
-
>
getReportOnlyFlag
(
)
)
{
*
aOutSandboxFlags
|
=
flags
;
}
else
{
nsAutoString
policy
;
mPolicies
[
i
]
-
>
toString
(
policy
)
;
CSPCONTEXTLOG
(
(
"
nsCSPContext
:
:
GetCSPSandboxFlags
report
only
policy
ignoring
sandbox
in
:
%
s
"
NS_ConvertUTF16toUTF8
(
policy
)
.
get
(
)
)
)
;
const
char16_t
*
params
[
]
=
{
policy
.
get
(
)
}
;
logToConsole
(
"
ignoringReportOnlyDirective
"
params
ArrayLength
(
params
)
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
warningFlag
)
;
}
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
CSPViolationReportListener
nsIStreamListener
nsIRequestObserver
nsISupports
)
;
CSPViolationReportListener
:
:
CSPViolationReportListener
(
)
{
}
CSPViolationReportListener
:
:
~
CSPViolationReportListener
(
)
{
}
nsresult
AppendSegmentToString
(
nsIInputStream
*
aInputStream
void
*
aClosure
const
char
*
aRawSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
outWrittenCount
)
{
nsCString
*
decodedData
=
static_cast
<
nsCString
*
>
(
aClosure
)
;
decodedData
-
>
Append
(
aRawSegment
aCount
)
;
*
outWrittenCount
=
aCount
;
return
NS_OK
;
}
NS_IMETHODIMP
CSPViolationReportListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
uint32_t
read
;
nsCString
decodedData
;
return
aInputStream
-
>
ReadSegments
(
AppendSegmentToString
&
decodedData
aCount
&
read
)
;
}
NS_IMETHODIMP
CSPViolationReportListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
CSPViolationReportListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
CSPReportRedirectSink
nsIChannelEventSink
nsIInterfaceRequestor
)
;
CSPReportRedirectSink
:
:
CSPReportRedirectSink
(
)
{
}
CSPReportRedirectSink
:
:
~
CSPReportRedirectSink
(
)
{
}
NS_IMETHODIMP
CSPReportRedirectSink
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aRedirFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
{
nsresult
rv
=
aOldChannel
-
>
Cancel
(
NS_ERROR_ABORT
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aOldChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
NS_ASSERTION
(
observerService
"
Observer
service
required
to
log
CSP
violations
"
)
;
observerService
-
>
NotifyObservers
(
uri
CSP_VIOLATION_TOPIC
u
"
denied
redirect
while
sending
violation
report
"
)
;
return
NS_BINDING_REDIRECTED
;
}
NS_IMETHODIMP
CSPReportRedirectSink
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsINetworkInterceptController
)
)
&
&
mInterceptController
)
{
nsCOMPtr
<
nsINetworkInterceptController
>
copy
(
mInterceptController
)
;
*
aResult
=
copy
.
forget
(
)
.
take
(
)
;
return
NS_OK
;
}
return
QueryInterface
(
aIID
aResult
)
;
}
void
CSPReportRedirectSink
:
:
SetInterceptController
(
nsINetworkInterceptController
*
aInterceptController
)
{
mInterceptController
=
aInterceptController
;
}
NS_IMETHODIMP
nsCSPContext
:
:
Read
(
nsIObjectInputStream
*
aStream
)
{
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
NS_ReadOptionalObject
(
aStream
true
getter_AddRefs
(
supports
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSelfURI
=
do_QueryInterface
(
supports
)
;
NS_ASSERTION
(
mSelfURI
"
need
a
self
URI
to
de
-
serialize
"
)
;
uint32_t
numPolicies
;
rv
=
aStream
-
>
Read32
(
&
numPolicies
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoString
policyString
;
while
(
numPolicies
>
0
)
{
numPolicies
-
-
;
rv
=
aStream
-
>
ReadString
(
policyString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
reportOnly
=
false
;
rv
=
aStream
-
>
ReadBoolean
(
&
reportOnly
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCSPPolicy
*
policy
=
nsCSPParser
:
:
parseContentSecurityPolicy
(
policyString
mSelfURI
reportOnly
this
false
)
;
if
(
policy
)
{
mPolicies
.
AppendElement
(
policy
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsCSPContext
:
:
Write
(
nsIObjectOutputStream
*
aStream
)
{
nsresult
rv
=
NS_WriteOptionalCompoundObject
(
aStream
mSelfURI
NS_GET_IID
(
nsIURI
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aStream
-
>
Write32
(
mPolicies
.
Length
(
)
)
;
nsAutoString
polStr
;
for
(
uint32_t
p
=
0
;
p
<
mPolicies
.
Length
(
)
;
p
+
+
)
{
polStr
.
Truncate
(
)
;
mPolicies
[
p
]
-
>
toString
(
polStr
)
;
aStream
-
>
WriteWStringZ
(
polStr
.
get
(
)
)
;
aStream
-
>
WriteBoolean
(
mPolicies
[
p
]
-
>
getReportOnlyFlag
(
)
)
;
}
return
NS_OK
;
}
