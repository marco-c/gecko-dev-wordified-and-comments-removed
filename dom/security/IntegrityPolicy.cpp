#
include
"
IntegrityPolicy
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
net
/
SFVService
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
using
namespace
mozilla
;
static
LazyLogModule
sIntegrityPolicyLogModule
(
"
IntegrityPolicy
"
)
;
#
define
LOG
(
fmt
.
.
.
)
\
MOZ_LOG_FMT
(
sIntegrityPolicyLogModule
LogLevel
:
:
Debug
fmt
#
#
__VA_ARGS__
)
namespace
mozilla
:
:
dom
{
IntegrityPolicy
:
:
~
IntegrityPolicy
(
)
=
default
;
RequestDestination
ContentTypeToDestination
(
nsContentPolicyType
aType
)
{
switch
(
aType
)
{
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_CHROMEUTILS_COMPILED_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME_MESSAGEMANAGER_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_SCRIPT
:
return
RequestDestination
:
:
Script
;
default
:
return
RequestDestination
:
:
_empty
;
}
}
Maybe
<
IntegrityPolicy
:
:
DestinationType
>
DOMRequestDestinationToDestinationType
(
RequestDestination
aDestination
)
{
switch
(
aDestination
)
{
case
RequestDestination
:
:
Script
:
return
Some
(
IntegrityPolicy
:
:
DestinationType
:
:
Script
)
;
default
:
return
Nothing
{
}
;
}
}
Maybe
<
IntegrityPolicy
:
:
DestinationType
>
IntegrityPolicy
:
:
ContentTypeToDestinationType
(
nsContentPolicyType
aType
)
{
return
DOMRequestDestinationToDestinationType
(
ContentTypeToDestination
(
aType
)
)
;
}
nsresult
GetStringsFromInnerList
(
nsISFVInnerList
*
aList
bool
aIsToken
nsTArray
<
nsCString
>
&
aStrings
)
{
nsTArray
<
RefPtr
<
nsISFVItem
>
>
items
;
nsresult
rv
=
aList
-
>
GetItems
(
items
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
auto
&
item
:
items
)
{
nsCOMPtr
<
nsISFVBareItem
>
value
;
rv
=
item
-
>
GetValue
(
getter_AddRefs
(
value
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
itemStr
;
if
(
aIsToken
)
{
nsCOMPtr
<
nsISFVToken
>
itemToken
(
do_QueryInterface
(
value
)
)
;
NS_ENSURE_TRUE
(
itemToken
NS_ERROR_FAILURE
)
;
rv
=
itemToken
-
>
GetValue
(
itemStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsISFVString
>
itemString
(
do_QueryInterface
(
value
)
)
;
NS_ENSURE_TRUE
(
itemString
NS_ERROR_FAILURE
)
;
rv
=
itemString
-
>
GetValue
(
itemStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
aStrings
.
AppendElement
(
itemStr
)
;
}
return
NS_OK
;
}
Result
<
IntegrityPolicy
:
:
Sources
nsresult
>
ParseSources
(
nsISFVDictionary
*
aDict
)
{
nsCOMPtr
<
nsISFVItemOrInnerList
>
iil
;
nsresult
rv
=
aDict
-
>
Get
(
"
sources
"
_ns
getter_AddRefs
(
iil
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
IntegrityPolicy
:
:
Sources
(
IntegrityPolicy
:
:
SourceType
:
:
Inline
)
;
}
nsCOMPtr
<
nsISFVInnerList
>
il
(
do_QueryInterface
(
iil
)
)
;
NS_ENSURE_TRUE
(
il
Err
(
NS_ERROR_FAILURE
)
)
;
nsTArray
<
nsCString
>
sources
;
rv
=
GetStringsFromInnerList
(
il
true
sources
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
IntegrityPolicy
:
:
Sources
result
;
for
(
const
auto
&
source
:
sources
)
{
if
(
source
.
EqualsLiteral
(
"
inline
"
)
)
{
result
+
=
IntegrityPolicy
:
:
SourceType
:
:
Inline
;
}
else
{
LOG
(
"
ParseSources
:
Unknown
source
:
{
}
"
source
.
get
(
)
)
;
continue
;
}
}
return
result
;
}
Result
<
IntegrityPolicy
:
:
Destinations
nsresult
>
ParseDestinations
(
nsISFVDictionary
*
aDict
)
{
nsCOMPtr
<
nsISFVItemOrInnerList
>
iil
;
nsresult
rv
=
aDict
-
>
Get
(
"
blocked
-
destinations
"
_ns
getter_AddRefs
(
iil
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
IntegrityPolicy
:
:
Destinations
(
)
;
}
nsCOMPtr
<
nsISFVInnerList
>
il
(
do_QueryInterface
(
iil
)
)
;
NS_ENSURE_TRUE
(
il
Err
(
NS_ERROR_FAILURE
)
)
;
nsTArray
<
nsCString
>
destinations
;
rv
=
GetStringsFromInnerList
(
il
true
destinations
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
IntegrityPolicy
:
:
Destinations
result
;
for
(
const
auto
&
destination
:
destinations
)
{
if
(
destination
.
EqualsLiteral
(
"
script
"
)
)
{
result
+
=
IntegrityPolicy
:
:
DestinationType
:
:
Script
;
}
else
{
LOG
(
"
ParseDestinations
:
Unknown
destination
:
{
}
"
destination
.
get
(
)
)
;
continue
;
}
}
return
result
;
}
nsresult
IntegrityPolicy
:
:
ParseHeaders
(
const
nsACString
&
aHeader
const
nsACString
&
aHeaderRO
IntegrityPolicy
*
*
aPolicy
)
{
if
(
!
StaticPrefs
:
:
security_integrity_policy_enabled
(
)
)
{
return
NS_OK
;
}
RefPtr
<
IntegrityPolicy
>
policy
=
new
IntegrityPolicy
(
)
;
LOG
(
"
[
{
}
]
Parsing
headers
:
enforcement
=
'
{
}
'
report
-
only
=
'
{
}
'
"
static_cast
<
void
*
>
(
policy
)
aHeader
.
Data
(
)
aHeaderRO
.
Data
(
)
)
;
nsCOMPtr
<
nsISFVService
>
sfv
=
net
:
:
GetSFVService
(
)
;
NS_ENSURE_TRUE
(
sfv
NS_ERROR_FAILURE
)
;
for
(
const
auto
&
isROHeader
:
{
false
true
}
)
{
const
auto
&
headerString
=
isROHeader
?
aHeaderRO
:
aHeader
;
if
(
headerString
.
IsEmpty
(
)
)
{
LOG
(
"
[
{
}
]
No
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
nsCOMPtr
<
nsISFVDictionary
>
dict
;
nsresult
rv
=
sfv
-
>
ParseDictionary
(
headerString
getter_AddRefs
(
dict
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
[
{
}
]
Failed
to
parse
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
auto
sourcesResult
=
ParseSources
(
dict
)
;
if
(
sourcesResult
.
isErr
(
)
)
{
LOG
(
"
[
{
}
]
Failed
to
parse
sources
for
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
auto
destinationsResult
=
ParseDestinations
(
dict
)
;
if
(
destinationsResult
.
isErr
(
)
)
{
LOG
(
"
[
{
}
]
Failed
to
parse
destinations
for
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
LOG
(
"
[
{
}
]
Creating
policy
for
{
}
header
.
sources
=
{
}
destinations
=
{
}
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
sourcesResult
.
unwrap
(
)
.
serialize
(
)
destinationsResult
.
unwrap
(
)
.
serialize
(
)
)
;
Entry
entry
=
Entry
(
sourcesResult
.
unwrap
(
)
destinationsResult
.
unwrap
(
)
)
;
if
(
isROHeader
)
{
policy
-
>
mReportOnly
.
emplace
(
entry
)
;
}
else
{
policy
-
>
mEnforcement
.
emplace
(
entry
)
;
}
}
policy
.
forget
(
aPolicy
)
;
LOG
(
"
[
{
}
]
Finished
parsing
headers
.
"
static_cast
<
void
*
>
(
policy
)
)
;
return
NS_OK
;
}
void
IntegrityPolicy
:
:
PolicyContains
(
DestinationType
aDestination
bool
*
aContains
bool
*
aROContains
)
const
{
*
aContains
=
false
;
*
aROContains
=
false
;
if
(
mEnforcement
&
&
mEnforcement
-
>
mDestinations
.
contains
(
aDestination
)
&
&
mEnforcement
-
>
mSources
.
contains
(
SourceType
:
:
Inline
)
)
{
*
aContains
=
true
;
}
if
(
mReportOnly
&
&
mReportOnly
-
>
mDestinations
.
contains
(
aDestination
)
&
&
mReportOnly
-
>
mSources
.
contains
(
SourceType
:
:
Inline
)
)
{
*
aROContains
=
true
;
}
}
NS_IMPL_ISUPPORTS
(
IntegrityPolicy
nsIIntegrityPolicy
)
}
#
undef
LOG
