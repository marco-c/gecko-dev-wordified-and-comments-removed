#
include
"
IntegrityPolicy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
net
/
SFVService
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIClassInfoImpl
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsString
.
h
"
using
namespace
mozilla
;
static
LazyLogModule
sIntegrityPolicyLogModule
(
"
IntegrityPolicy
"
)
;
#
define
LOG
(
fmt
.
.
.
)
\
MOZ_LOG_FMT
(
sIntegrityPolicyLogModule
LogLevel
:
:
Debug
fmt
#
#
__VA_ARGS__
)
namespace
mozilla
:
:
dom
{
IntegrityPolicy
:
:
~
IntegrityPolicy
(
)
=
default
;
RequestDestination
ContentTypeToDestination
(
nsContentPolicyType
aType
)
{
switch
(
aType
)
{
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_CHROMEUTILS_COMPILED_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME_MESSAGEMANAGER_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_SCRIPT
:
return
RequestDestination
:
:
Script
;
case
nsIContentPolicy
:
:
TYPE_STYLESHEET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
:
return
RequestDestination
:
:
Style
;
default
:
return
RequestDestination
:
:
_empty
;
}
}
Maybe
<
IntegrityPolicy
:
:
DestinationType
>
DOMRequestDestinationToDestinationType
(
RequestDestination
aDestination
)
{
switch
(
aDestination
)
{
case
RequestDestination
:
:
Script
:
return
Some
(
IntegrityPolicy
:
:
DestinationType
:
:
Script
)
;
case
RequestDestination
:
:
Style
:
return
StaticPrefs
:
:
security_integrity_policy_stylesheet_enabled
(
)
?
Some
(
IntegrityPolicy
:
:
DestinationType
:
:
Style
)
:
Nothing
{
}
;
default
:
return
Nothing
{
}
;
}
}
Maybe
<
IntegrityPolicy
:
:
DestinationType
>
IntegrityPolicy
:
:
ContentTypeToDestinationType
(
nsContentPolicyType
aType
)
{
return
DOMRequestDestinationToDestinationType
(
ContentTypeToDestination
(
aType
)
)
;
}
nsresult
GetStringsFromInnerList
(
nsISFVInnerList
*
aList
bool
aIsToken
nsTArray
<
nsCString
>
&
aStrings
)
{
nsTArray
<
RefPtr
<
nsISFVItem
>
>
items
;
nsresult
rv
=
aList
-
>
GetItems
(
items
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
auto
&
item
:
items
)
{
nsCOMPtr
<
nsISFVBareItem
>
value
;
rv
=
item
-
>
GetValue
(
getter_AddRefs
(
value
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
itemStr
;
if
(
aIsToken
)
{
nsCOMPtr
<
nsISFVToken
>
itemToken
(
do_QueryInterface
(
value
)
)
;
NS_ENSURE_TRUE
(
itemToken
NS_ERROR_FAILURE
)
;
rv
=
itemToken
-
>
GetValue
(
itemStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsISFVString
>
itemString
(
do_QueryInterface
(
value
)
)
;
NS_ENSURE_TRUE
(
itemString
NS_ERROR_FAILURE
)
;
rv
=
itemString
-
>
GetValue
(
itemStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
aStrings
.
AppendElement
(
itemStr
)
;
}
return
NS_OK
;
}
Result
<
IntegrityPolicy
:
:
Sources
nsresult
>
ParseSources
(
nsISFVDictionary
*
aDict
)
{
nsCOMPtr
<
nsISFVItemOrInnerList
>
iil
;
nsresult
rv
=
aDict
-
>
Get
(
"
sources
"
_ns
getter_AddRefs
(
iil
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
IntegrityPolicy
:
:
Sources
(
IntegrityPolicy
:
:
SourceType
:
:
Inline
)
;
}
nsCOMPtr
<
nsISFVInnerList
>
il
(
do_QueryInterface
(
iil
)
)
;
NS_ENSURE_TRUE
(
il
Err
(
NS_ERROR_FAILURE
)
)
;
nsTArray
<
nsCString
>
sources
;
rv
=
GetStringsFromInnerList
(
il
true
sources
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
IntegrityPolicy
:
:
Sources
result
;
for
(
const
auto
&
source
:
sources
)
{
if
(
source
.
EqualsLiteral
(
"
inline
"
)
)
{
result
+
=
IntegrityPolicy
:
:
SourceType
:
:
Inline
;
}
else
{
LOG
(
"
ParseSources
:
Unknown
source
:
{
}
"
source
.
get
(
)
)
;
continue
;
}
}
return
result
;
}
Result
<
IntegrityPolicy
:
:
Destinations
nsresult
>
ParseDestinations
(
nsISFVDictionary
*
aDict
)
{
nsCOMPtr
<
nsISFVItemOrInnerList
>
iil
;
nsresult
rv
=
aDict
-
>
Get
(
"
blocked
-
destinations
"
_ns
getter_AddRefs
(
iil
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
IntegrityPolicy
:
:
Destinations
(
)
;
}
nsCOMPtr
<
nsISFVInnerList
>
il
(
do_QueryInterface
(
iil
)
)
;
NS_ENSURE_TRUE
(
il
Err
(
NS_ERROR_FAILURE
)
)
;
nsTArray
<
nsCString
>
destinations
;
rv
=
GetStringsFromInnerList
(
il
true
destinations
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
IntegrityPolicy
:
:
Destinations
result
;
for
(
const
auto
&
destination
:
destinations
)
{
if
(
destination
.
EqualsLiteral
(
"
script
"
)
)
{
result
+
=
IntegrityPolicy
:
:
DestinationType
:
:
Script
;
}
else
if
(
destination
.
EqualsLiteral
(
"
style
"
)
)
{
if
(
StaticPrefs
:
:
security_integrity_policy_stylesheet_enabled
(
)
)
{
result
+
=
IntegrityPolicy
:
:
DestinationType
:
:
Style
;
}
}
else
{
LOG
(
"
ParseDestinations
:
Unknown
destination
:
{
}
"
destination
.
get
(
)
)
;
continue
;
}
}
return
result
;
}
Result
<
nsTArray
<
nsCString
>
nsresult
>
ParseEndpoints
(
nsISFVDictionary
*
aDict
)
{
nsCOMPtr
<
nsISFVItemOrInnerList
>
iil
;
nsresult
rv
=
aDict
-
>
Get
(
"
endpoints
"
_ns
getter_AddRefs
(
iil
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nsTArray
<
nsCString
>
(
)
;
}
nsCOMPtr
<
nsISFVInnerList
>
il
(
do_QueryInterface
(
iil
)
)
;
NS_ENSURE_TRUE
(
il
Err
(
NS_ERROR_FAILURE
)
)
;
nsTArray
<
nsCString
>
endpoints
;
rv
=
GetStringsFromInnerList
(
il
true
endpoints
)
;
NS_ENSURE_SUCCESS
(
rv
Err
(
rv
)
)
;
return
endpoints
;
}
nsresult
IntegrityPolicy
:
:
ParseHeaders
(
const
nsACString
&
aHeader
const
nsACString
&
aHeaderRO
IntegrityPolicy
*
*
aPolicy
)
{
if
(
!
StaticPrefs
:
:
security_integrity_policy_enabled
(
)
)
{
return
NS_OK
;
}
RefPtr
<
IntegrityPolicy
>
policy
=
new
IntegrityPolicy
(
)
;
LOG
(
"
[
{
}
]
Parsing
headers
:
enforcement
=
'
{
}
'
report
-
only
=
'
{
}
'
"
static_cast
<
void
*
>
(
policy
)
aHeader
.
Data
(
)
aHeaderRO
.
Data
(
)
)
;
nsCOMPtr
<
nsISFVService
>
sfv
=
net
:
:
GetSFVService
(
)
;
NS_ENSURE_TRUE
(
sfv
NS_ERROR_FAILURE
)
;
for
(
const
auto
&
isROHeader
:
{
false
true
}
)
{
const
auto
&
headerString
=
isROHeader
?
aHeaderRO
:
aHeader
;
if
(
headerString
.
IsEmpty
(
)
)
{
LOG
(
"
[
{
}
]
No
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
nsCOMPtr
<
nsISFVDictionary
>
dict
;
nsresult
rv
=
sfv
-
>
ParseDictionary
(
headerString
getter_AddRefs
(
dict
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
"
[
{
}
]
Failed
to
parse
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
auto
sourcesResult
=
ParseSources
(
dict
)
;
if
(
sourcesResult
.
isErr
(
)
)
{
LOG
(
"
[
{
}
]
Failed
to
parse
sources
for
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
auto
destinationsResult
=
ParseDestinations
(
dict
)
;
if
(
destinationsResult
.
isErr
(
)
)
{
LOG
(
"
[
{
}
]
Failed
to
parse
destinations
for
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
auto
endpointsResult
=
ParseEndpoints
(
dict
)
;
if
(
endpointsResult
.
isErr
(
)
)
{
LOG
(
"
[
{
}
]
Failed
to
parse
endpoints
for
{
}
header
.
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
)
;
continue
;
}
LOG
(
"
[
{
}
]
Creating
policy
for
{
}
header
.
sources
=
{
}
destinations
=
{
}
"
"
endpoints
=
[
{
}
]
"
static_cast
<
void
*
>
(
policy
)
isROHeader
?
"
report
-
only
"
:
"
enforcement
"
sourcesResult
.
unwrap
(
)
.
serialize
(
)
destinationsResult
.
unwrap
(
)
.
serialize
(
)
fmt
:
:
join
(
endpointsResult
.
unwrap
(
)
"
"
)
)
;
Entry
entry
=
Entry
(
sourcesResult
.
unwrap
(
)
destinationsResult
.
unwrap
(
)
endpointsResult
.
unwrap
(
)
)
;
if
(
isROHeader
)
{
policy
-
>
mReportOnly
.
emplace
(
entry
)
;
}
else
{
policy
-
>
mEnforcement
.
emplace
(
entry
)
;
}
}
policy
.
forget
(
aPolicy
)
;
LOG
(
"
[
{
}
]
Finished
parsing
headers
.
"
static_cast
<
void
*
>
(
policy
)
)
;
return
NS_OK
;
}
void
IntegrityPolicy
:
:
PolicyContains
(
DestinationType
aDestination
bool
*
aContains
bool
*
aROContains
)
const
{
*
aContains
=
false
;
*
aROContains
=
false
;
if
(
mEnforcement
&
&
mEnforcement
-
>
mDestinations
.
contains
(
aDestination
)
&
&
mEnforcement
-
>
mSources
.
contains
(
SourceType
:
:
Inline
)
)
{
*
aContains
=
true
;
}
if
(
mReportOnly
&
&
mReportOnly
-
>
mDestinations
.
contains
(
aDestination
)
&
&
mReportOnly
-
>
mSources
.
contains
(
SourceType
:
:
Inline
)
)
{
*
aROContains
=
true
;
}
}
void
IntegrityPolicy
:
:
ToArgs
(
const
IntegrityPolicy
*
aPolicy
mozilla
:
:
ipc
:
:
IntegrityPolicyArgs
&
aArgs
)
{
aArgs
.
enforcement
(
)
=
Nothing
(
)
;
aArgs
.
reportOnly
(
)
=
Nothing
(
)
;
if
(
!
aPolicy
)
{
return
;
}
if
(
aPolicy
-
>
mEnforcement
)
{
mozilla
:
:
ipc
:
:
IntegrityPolicyEntry
entry
;
entry
.
sources
(
)
=
aPolicy
-
>
mEnforcement
-
>
mSources
;
entry
.
destinations
(
)
=
aPolicy
-
>
mEnforcement
-
>
mDestinations
;
entry
.
endpoints
(
)
=
aPolicy
-
>
mEnforcement
-
>
mEndpoints
.
Clone
(
)
;
aArgs
.
enforcement
(
)
=
Some
(
entry
)
;
}
if
(
aPolicy
-
>
mReportOnly
)
{
mozilla
:
:
ipc
:
:
IntegrityPolicyEntry
entry
;
entry
.
sources
(
)
=
aPolicy
-
>
mReportOnly
-
>
mSources
;
entry
.
destinations
(
)
=
aPolicy
-
>
mReportOnly
-
>
mDestinations
;
entry
.
endpoints
(
)
=
aPolicy
-
>
mReportOnly
-
>
mEndpoints
.
Clone
(
)
;
aArgs
.
reportOnly
(
)
=
Some
(
entry
)
;
}
}
void
IntegrityPolicy
:
:
FromArgs
(
const
mozilla
:
:
ipc
:
:
IntegrityPolicyArgs
&
aArgs
IntegrityPolicy
*
*
aPolicy
)
{
RefPtr
<
IntegrityPolicy
>
policy
=
new
IntegrityPolicy
(
)
;
if
(
aArgs
.
enforcement
(
)
.
isSome
(
)
)
{
const
auto
&
entry
=
*
aArgs
.
enforcement
(
)
;
policy
-
>
mEnforcement
.
emplace
(
Entry
(
entry
.
sources
(
)
entry
.
destinations
(
)
entry
.
endpoints
(
)
.
Clone
(
)
)
)
;
}
if
(
aArgs
.
reportOnly
(
)
.
isSome
(
)
)
{
const
auto
&
entry
=
*
aArgs
.
reportOnly
(
)
;
policy
-
>
mReportOnly
.
emplace
(
Entry
(
entry
.
sources
(
)
entry
.
destinations
(
)
entry
.
endpoints
(
)
.
Clone
(
)
)
)
;
}
policy
.
forget
(
aPolicy
)
;
}
void
IntegrityPolicy
:
:
InitFromOther
(
IntegrityPolicy
*
aOther
)
{
if
(
!
aOther
)
{
return
;
}
if
(
aOther
-
>
mEnforcement
)
{
mEnforcement
.
emplace
(
Entry
(
*
aOther
-
>
mEnforcement
)
)
;
}
if
(
aOther
-
>
mReportOnly
)
{
mReportOnly
.
emplace
(
Entry
(
*
aOther
-
>
mReportOnly
)
)
;
}
}
bool
IntegrityPolicy
:
:
Equals
(
const
IntegrityPolicy
*
aPolicy
const
IntegrityPolicy
*
aOtherPolicy
)
{
if
(
aPolicy
=
=
aOtherPolicy
)
{
return
true
;
}
if
(
!
aPolicy
|
|
!
aOtherPolicy
)
{
return
false
;
}
if
(
!
Entry
:
:
Equals
(
aPolicy
-
>
mEnforcement
aOtherPolicy
-
>
mEnforcement
)
)
{
return
false
;
}
if
(
!
Entry
:
:
Equals
(
aPolicy
-
>
mReportOnly
aOtherPolicy
-
>
mReportOnly
)
)
{
return
false
;
}
return
true
;
}
bool
IntegrityPolicy
:
:
Entry
:
:
Equals
(
const
Maybe
<
Entry
>
&
aPolicy
const
Maybe
<
Entry
>
&
aOtherPolicy
)
{
if
(
aPolicy
.
isSome
(
)
!
=
aOtherPolicy
.
isSome
(
)
)
{
return
false
;
}
if
(
aPolicy
.
isNothing
(
)
&
&
aOtherPolicy
.
isNothing
(
)
)
{
return
true
;
}
if
(
aPolicy
-
>
mSources
!
=
aOtherPolicy
-
>
mSources
)
{
return
false
;
}
if
(
aPolicy
-
>
mDestinations
!
=
aOtherPolicy
-
>
mDestinations
)
{
return
false
;
}
if
(
aPolicy
-
>
mEndpoints
!
=
aOtherPolicy
-
>
mEndpoints
)
{
return
false
;
}
return
true
;
}
constexpr
static
const
uint32_t
kIntegrityPolicySerializationVersion
=
1
;
NS_IMETHODIMP
IntegrityPolicy
:
:
Read
(
nsIObjectInputStream
*
aStream
)
{
nsresult
rv
;
uint32_t
version
;
rv
=
aStream
-
>
Read32
(
&
version
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
version
!
=
kIntegrityPolicySerializationVersion
)
{
LOG
(
"
IntegrityPolicy
:
:
Read
:
Unsupported
version
:
{
}
"
version
)
;
return
NS_ERROR_FAILURE
;
}
for
(
const
bool
&
isRO
:
{
false
true
}
)
{
bool
hasPolicy
;
rv
=
aStream
-
>
ReadBoolean
(
&
hasPolicy
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
hasPolicy
)
{
continue
;
}
uint32_t
sources
;
rv
=
aStream
-
>
Read32
(
&
sources
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Sources
sourcesSet
;
sourcesSet
.
deserialize
(
sources
)
;
uint32_t
destinations
;
rv
=
aStream
-
>
Read32
(
&
destinations
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Destinations
destinationsSet
;
destinationsSet
.
deserialize
(
destinations
)
;
uint32_t
endpointsLen
;
rv
=
aStream
-
>
Read32
(
&
endpointsLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsTArray
<
nsCString
>
endpoints
(
endpointsLen
)
;
for
(
size_t
endpointI
=
0
;
endpointI
<
endpointsLen
;
endpointI
+
+
)
{
nsCString
endpoint
;
rv
=
aStream
-
>
ReadCString
(
endpoint
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
endpoints
.
AppendElement
(
std
:
:
move
(
endpoint
)
)
;
}
Entry
entry
=
Entry
(
sourcesSet
destinationsSet
std
:
:
move
(
endpoints
)
)
;
if
(
isRO
)
{
mReportOnly
.
emplace
(
entry
)
;
}
else
{
mEnforcement
.
emplace
(
entry
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
IntegrityPolicy
:
:
Write
(
nsIObjectOutputStream
*
aStream
)
{
nsresult
rv
;
rv
=
aStream
-
>
Write32
(
kIntegrityPolicySerializationVersion
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
entry
:
{
mEnforcement
mReportOnly
}
)
{
if
(
!
entry
)
{
aStream
-
>
WriteBoolean
(
false
)
;
continue
;
}
aStream
-
>
WriteBoolean
(
true
)
;
rv
=
aStream
-
>
Write32
(
entry
-
>
mSources
.
serialize
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Write32
(
entry
-
>
mDestinations
.
serialize
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aStream
-
>
Write32
(
entry
-
>
mEndpoints
.
Length
(
)
)
;
for
(
const
auto
&
endpoint
:
entry
-
>
mEndpoints
)
{
rv
=
aStream
-
>
WriteCString
(
endpoint
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
NS_IMPL_CLASSINFO
(
IntegrityPolicy
nullptr
0
NS_IINTEGRITYPOLICY_IID
)
NS_IMPL_ISUPPORTS_CI
(
IntegrityPolicy
nsIIntegrityPolicy
nsISerializable
)
}
#
undef
LOG
