"
use
strict
"
;
add_task
(
async
function
(
)
{
await
setup
(
)
;
await
runTest
(
{
queryString
:
"
test1
.
1
"
topLevelScheme
:
"
http
"
expectedTopLevel
:
"
http
"
expectedSameOrigin
:
"
http
"
expectedCrossOrigin
:
"
http
"
}
)
;
await
runTest
(
{
queryString
:
"
test1
.
2
"
topLevelScheme
:
"
https
"
expectedTopLevel
:
"
https
"
expectedSameOrigin
:
"
fail
"
expectedCrossOrigin
:
"
fail
"
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
security
.
https_only_mode
"
true
]
]
}
)
;
await
runTest
(
{
queryString
:
"
test2
.
1
"
topLevelScheme
:
"
http
"
expectedTopLevel
:
"
https
"
expectedSameOrigin
:
"
https
"
expectedCrossOrigin
:
"
https
"
}
)
;
await
runTest
(
{
queryString
:
"
test2
.
2
"
topLevelScheme
:
"
https
"
expectedTopLevel
:
"
https
"
expectedSameOrigin
:
"
https
"
expectedCrossOrigin
:
"
https
"
}
)
;
await
SpecialPowers
.
pushPermissions
(
[
{
type
:
"
https
-
only
-
load
-
insecure
"
allow
:
true
context
:
"
http
:
/
/
example
.
org
"
}
]
)
;
await
SpecialPowers
.
pushPermissions
(
[
{
type
:
"
https
-
only
-
load
-
insecure
"
allow
:
true
context
:
"
http
:
/
/
example
.
com
"
}
]
)
;
await
runTest
(
{
queryString
:
"
test3
.
1
"
topLevelScheme
:
"
http
"
expectedTopLevel
:
"
http
"
expectedSameOrigin
:
"
http
"
expectedCrossOrigin
:
"
http
"
}
)
;
await
SpecialPowers
.
popPermissions
(
)
;
await
SpecialPowers
.
pushPermissions
(
[
{
type
:
"
https
-
only
-
load
-
insecure
"
allow
:
true
context
:
"
https
:
/
/
example
.
com
"
}
]
)
;
await
runTest
(
{
queryString
:
"
test3
.
2
"
topLevelScheme
:
"
https
"
expectedTopLevel
:
"
https
"
expectedSameOrigin
:
"
fail
"
expectedCrossOrigin
:
"
fail
"
}
)
;
await
SpecialPowers
.
popPermissions
(
)
;
await
SpecialPowers
.
popPermissions
(
)
;
await
evaluate
(
)
;
}
)
;
const
SERVER_URL
=
scheme
=
>
{
scheme
}
:
/
/
example
.
com
/
browser
/
dom
/
security
/
test
/
https
-
only
/
file_iframe_test
.
sjs
?
;
let
shouldContain
=
[
]
;
let
shouldNotContain
=
[
]
;
async
function
setup
(
)
{
const
response
=
await
fetch
(
SERVER_URL
(
"
https
"
)
+
"
setup
"
)
;
const
txt
=
await
response
.
text
(
)
;
if
(
txt
!
=
"
ok
"
)
{
ok
(
false
"
Failed
to
setup
test
server
.
"
)
;
finish
(
)
;
}
}
async
function
evaluate
(
)
{
const
response
=
await
fetch
(
SERVER_URL
(
"
https
"
)
+
"
results
"
)
;
const
requestResults
=
(
await
response
.
text
(
)
)
.
split
(
"
;
"
)
;
shouldContain
.
map
(
str
=
>
ok
(
requestResults
.
includes
(
str
)
Results
should
contain
'
{
str
}
'
.
)
)
;
shouldNotContain
.
map
(
str
=
>
ok
(
!
requestResults
.
includes
(
str
)
Results
shouldn
'
t
contain
'
{
str
}
'
.
)
)
;
}
async
function
runTest
(
test
)
{
const
queryString
=
test
.
queryString
;
await
BrowserTestUtils
.
withNewTab
(
"
about
:
blank
"
async
function
(
browser
)
{
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
SERVER_URL
(
test
.
expectedTopLevel
)
+
queryString
false
)
;
BrowserTestUtils
.
loadURI
(
browser
SERVER_URL
(
test
.
topLevelScheme
)
+
queryString
)
;
await
loaded
;
}
)
;
if
(
test
.
expectedTopLevel
!
=
=
"
fail
"
)
{
shouldContain
.
push
(
top
-
{
queryString
}
-
{
test
.
expectedTopLevel
}
)
;
}
else
{
shouldNotContain
.
push
(
top
-
{
queryString
}
-
http
)
;
shouldNotContain
.
push
(
top
-
{
queryString
}
-
https
)
;
}
if
(
test
.
expectedSameOrigin
!
=
=
"
fail
"
)
{
shouldContain
.
push
(
com
-
{
queryString
}
-
{
test
.
expectedSameOrigin
}
)
;
}
else
{
shouldNotContain
.
push
(
com
-
{
queryString
}
-
http
)
;
shouldNotContain
.
push
(
com
-
{
queryString
}
-
https
)
;
}
if
(
test
.
expectedCrossOrigin
!
=
=
"
fail
"
)
{
shouldContain
.
push
(
org
-
{
queryString
}
-
{
test
.
expectedCrossOrigin
}
)
;
}
else
{
shouldNotContain
.
push
(
org
-
{
queryString
}
-
http
)
;
shouldNotContain
.
push
(
org
-
{
queryString
}
-
https
)
;
}
}
