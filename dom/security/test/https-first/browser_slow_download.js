"
use
strict
"
;
XPCOMUtils
.
defineLazyModuleGetters
(
this
{
BrowserWindowTracker
:
"
resource
:
/
/
/
modules
/
BrowserWindowTracker
.
jsm
"
}
)
;
const
testPath
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
com
"
)
;
const
TEST_URI
=
testPath
+
"
file_slow_download
.
html
"
;
const
EXPECTED_DOWNLOAD_URL
=
"
example
.
com
/
browser
/
dom
/
security
/
test
/
https
-
first
/
file_slow_download
.
sjs
"
;
requestLongerTimeout
(
3
)
;
function
promisePanelOpened
(
)
{
if
(
DownloadsPanel
.
panel
&
&
DownloadsPanel
.
panel
.
state
=
=
"
open
"
)
{
return
Promise
.
resolve
(
)
;
}
return
BrowserTestUtils
.
waitForEvent
(
DownloadsPanel
.
panel
"
popupshown
"
)
;
}
function
promiseDownloadStopped
(
aDownload
)
{
if
(
!
aDownload
.
stopped
)
{
return
aDownload
.
start
(
)
;
}
if
(
aDownload
.
succeeded
)
{
return
Promise
.
resolve
(
)
;
}
return
Promise
.
reject
(
aDownload
.
error
|
|
new
Error
(
"
Download
canceled
.
"
)
)
;
}
let
requestCounter
=
0
;
function
examiner
(
)
{
SpecialPowers
.
addObserver
(
this
"
specialpowers
-
http
-
notify
-
request
"
)
;
}
examiner
.
prototype
=
{
observe
(
subject
topic
data
)
{
if
(
topic
!
=
=
"
specialpowers
-
http
-
notify
-
request
"
)
{
return
;
}
if
(
!
data
.
startsWith
(
"
http
:
/
/
example
.
com
"
)
&
&
!
data
.
startsWith
(
"
https
:
/
/
example
.
com
"
)
)
{
return
;
}
+
+
requestCounter
;
if
(
requestCounter
=
=
1
)
{
is
(
data
TEST_URI
"
Download
start
page
is
https
"
)
;
return
;
}
if
(
requestCounter
=
=
2
)
{
is
(
data
"
http
:
/
/
"
+
EXPECTED_DOWNLOAD_URL
"
First
download
request
is
http
(
internal
)
"
)
;
return
;
}
if
(
requestCounter
=
=
3
)
{
is
(
data
"
https
:
/
/
"
+
EXPECTED_DOWNLOAD_URL
"
Download
got
upgraded
to
https
"
)
;
return
;
}
ok
(
false
"
we
should
never
get
here
but
just
in
case
"
)
;
}
remove
(
)
{
SpecialPowers
.
removeObserver
(
this
"
specialpowers
-
http
-
notify
-
request
"
)
;
}
}
;
add_task
(
async
function
test_slow_download
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
security
.
https_first
"
true
]
[
"
browser
.
download
.
improvements_to_download_panel
"
true
]
]
}
)
;
this
.
examiner
=
new
examiner
(
)
;
let
downloadsPanelPromise
=
promisePanelOpened
(
)
;
let
downloadsPromise
=
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
BrowserTestUtils
.
loadURI
(
gBrowser
TEST_URI
)
;
await
downloadsPanelPromise
;
let
downloadList
=
await
downloadsPromise
;
is
(
DownloadsPanel
.
isPanelShowing
true
"
DownloadsPanel
should
be
open
.
"
)
;
is
(
downloadList
.
_downloads
.
length
1
"
File
should
be
downloaded
.
"
)
;
let
[
download
]
=
downloadList
.
_downloads
;
await
promiseDownloadStopped
(
download
)
;
is
(
download
.
contentType
"
text
/
plain
"
"
File
contentType
should
be
correct
.
"
)
;
is
(
download
.
source
.
url
"
https
:
/
/
"
+
EXPECTED_DOWNLOAD_URL
"
Scheme
should
be
https
.
"
)
;
is
(
requestCounter
3
"
three
requests
total
(
download
page
download
http
download
https
/
upgraded
)
"
)
;
is
(
download
.
target
.
size
25
"
Download
size
is
correct
"
)
;
this
.
examiner
.
remove
(
)
;
info
(
"
cleaning
up
downloads
"
)
;
try
{
if
(
Services
.
appinfo
.
OS
=
=
=
"
WINNT
"
)
{
await
IOUtils
.
setPermissions
(
download
.
target
.
path
0o600
)
;
}
await
IOUtils
.
remove
(
download
.
target
.
path
)
;
}
catch
(
error
)
{
info
(
"
The
file
"
+
download
.
target
.
path
+
"
is
not
removed
"
+
error
)
;
}
await
downloadList
.
remove
(
download
)
;
await
download
.
finalize
(
)
;
}
)
;
