'
use
strict
'
;
var
{
classes
:
Cc
interfaces
:
Ci
utils
:
Cu
results
:
Cr
}
=
Components
;
var
TOP_URI
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
security
/
test
/
hsts
/
file_priming
-
top
.
html
"
;
var
test_servers
=
{
'
no
-
ssl
'
:
{
host
:
'
example
.
co
.
jp
'
response
:
false
id
:
'
no
-
ssl
'
}
'
reject
-
upgrade
'
:
{
host
:
'
example
.
org
'
response
:
true
id
:
'
reject
-
upgrade
'
}
'
prime
-
hsts
'
:
{
host
:
'
test1
.
example
.
com
'
response
:
true
id
:
'
prime
-
hsts
'
}
}
;
var
test_settings
=
{
allow_active
:
{
block_active
:
false
block_display
:
false
use_hsts
:
true
send_hsts_priming
:
true
type
:
'
script
'
timeout
:
0
result
:
{
'
no
-
ssl
'
:
'
insecure
'
'
reject
-
upgrade
'
:
'
insecure
'
'
prime
-
hsts
'
:
'
secure
'
}
}
block_active
:
{
block_active
:
true
block_display
:
false
use_hsts
:
true
send_hsts_priming
:
true
type
:
'
script
'
timeout
:
0
result
:
{
'
no
-
ssl
'
:
'
blocked
'
'
reject
-
upgrade
'
:
'
blocked
'
'
prime
-
hsts
'
:
'
secure
'
}
}
hsts_after_mixed
:
{
block_active
:
true
block_display
:
false
use_hsts
:
false
send_hsts_priming
:
true
type
:
'
script
'
timeout
:
0
result
:
{
'
no
-
ssl
'
:
'
blocked
'
'
reject
-
upgrade
'
:
'
blocked
'
'
prime
-
hsts
'
:
'
blocked
'
}
}
allow_display
:
{
block_active
:
true
block_display
:
false
use_hsts
:
true
send_hsts_priming
:
true
type
:
'
img
'
timeout
:
0
result
:
{
'
no
-
ssl
'
:
'
insecure
'
'
reject
-
upgrade
'
:
'
insecure
'
'
prime
-
hsts
'
:
'
secure
'
}
}
block_display
:
{
block_active
:
true
block_display
:
true
use_hsts
:
true
send_hsts_priming
:
true
type
:
'
img
'
timeout
:
0
result
:
{
'
no
-
ssl
'
:
'
blocked
'
'
reject
-
upgrade
'
:
'
blocked
'
'
prime
-
hsts
'
:
'
secure
'
}
}
block_active_css
:
{
block_active
:
true
block_display
:
true
use_hsts
:
true
send_hsts_priming
:
true
type
:
'
css
'
timeout
:
0
result
:
{
'
no
-
ssl
'
:
'
blocked
'
'
reject
-
upgrade
'
:
'
blocked
'
'
prime
-
hsts
'
:
'
secure
'
}
}
block_active_with_redir_same
:
{
block_active
:
true
block_display
:
false
use_hsts
:
true
send_hsts_priming
:
true
type
:
'
script
'
redir
:
'
same
'
timeout
:
0
result
:
{
'
no
-
ssl
'
:
'
blocked
'
'
reject
-
upgrade
'
:
'
blocked
'
'
prime
-
hsts
'
:
'
secure
'
}
}
timeout
:
{
block_active
:
true
block_display
:
true
use_hsts
:
true
send_hsts_priming
:
true
type
:
'
script
'
timeout
:
100000
result
:
{
'
no
-
ssl
'
:
'
blocked
'
'
reject
-
upgrade
'
:
'
blocked
'
'
prime
-
hsts
'
:
'
blocked
'
}
}
}
var
which_test
=
"
"
;
var
StreamListener
=
function
(
subject
)
{
let
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
traceable
=
subject
.
QueryInterface
(
Ci
.
nsITraceableChannel
)
;
this
.
uri
=
channel
.
URI
.
asciiSpec
;
this
.
listener
=
traceable
.
setNewListener
(
this
)
;
return
this
;
}
;
StreamListener
.
prototype
.
onDataAvailable
=
function
(
request
context
input
offset
count
)
{
if
(
request
.
status
=
=
Cr
.
NS_ERROR_ABORT
)
{
this
.
listener
=
null
;
return
Cr
.
NS_SUCCESS
;
}
let
listener
=
this
.
listener
;
if
(
listener
)
{
try
{
let
rv
=
listener
.
onDataAvailable
(
request
context
input
offset
count
)
;
if
(
rv
!
=
Cr
.
NS_ERROR_ABORT
)
{
return
rv
;
}
}
catch
(
e
)
{
if
(
e
!
=
Cr
.
NS_ERROR_ABORT
)
{
return
e
;
}
}
}
return
Cr
.
NS_SUCCESS
;
}
;
StreamListener
.
prototype
.
onStartRequest
=
function
(
request
context
)
{
if
(
request
.
status
=
=
Cr
.
NS_ERROR_ABORT
)
{
this
.
listener
=
null
;
return
Cr
.
NS_SUCCESS
;
}
let
listener
=
this
.
listener
;
if
(
listener
)
{
try
{
let
rv
=
listener
.
onStartRequest
(
request
context
)
;
if
(
rv
!
=
Cr
.
NS_ERROR_ABORT
)
{
return
rv
;
}
}
catch
(
e
)
{
if
(
e
!
=
Cr
.
NS_ERROR_ABORT
)
{
return
e
;
}
}
}
return
Cr
.
NS_SUCCESS
;
}
;
StreamListener
.
prototype
.
onStopRequest
=
function
(
request
context
status
)
{
if
(
status
=
=
Cr
.
NS_ERROR_ABORT
)
{
this
.
listener
=
null
;
return
Cr
.
NS_SUCCESS
;
}
let
listener
=
this
.
listener
;
if
(
listener
)
{
try
{
let
rv
=
listener
.
onStopRequest
(
request
context
status
)
;
if
(
rv
!
=
Cr
.
NS_ERROR_ABORT
)
{
return
rv
;
}
}
catch
(
e
)
{
if
(
e
!
=
Cr
.
NS_ERROR_ABORT
)
{
return
e
;
}
}
}
return
Cr
.
NS_SUCCESS
;
}
;
var
Observer
=
{
listeners
:
{
}
observe
:
function
(
subject
topic
data
)
{
switch
(
topic
)
{
case
'
console
-
api
-
log
-
event
'
:
return
Observer
.
console_api_log_event
(
subject
topic
data
)
;
case
'
http
-
on
-
examine
-
response
'
:
return
Observer
.
http_on_examine_response
(
subject
topic
data
)
;
case
'
http
-
on
-
modify
-
request
'
:
return
Observer
.
http_on_modify_request
(
subject
topic
data
)
;
}
throw
"
Can
'
t
handle
topic
"
+
topic
;
}
add_observers
:
function
(
services
include_on_modify
=
false
)
{
services
.
obs
.
addObserver
(
Observer
"
console
-
api
-
log
-
event
"
)
;
services
.
obs
.
addObserver
(
Observer
"
http
-
on
-
examine
-
response
"
)
;
services
.
obs
.
addObserver
(
Observer
"
http
-
on
-
modify
-
request
"
)
;
}
cleanup
:
function
(
)
{
this
.
listeners
=
{
}
;
}
console_api_log_event
:
function
(
subject
topic
data
)
{
var
message
=
subject
.
wrappedJSObject
.
arguments
[
0
]
;
var
re
=
RegExp
(
/
^
HSTS_PRIMING
:
Blocked
(
[
-
\
w
]
+
)
.
*
/
)
;
if
(
!
re
.
test
(
message
)
)
{
return
;
}
let
id
=
message
.
replace
(
re
'
1
'
)
;
let
curTest
=
test_servers
[
id
]
;
if
(
!
curTest
)
{
ok
(
false
"
HSTS
priming
got
a
console
message
blocked
"
+
"
but
doesn
'
t
match
expectations
"
+
id
+
"
(
msg
=
"
+
message
)
;
return
;
}
is
(
"
blocked
"
test_settings
[
which_test
]
.
result
[
curTest
.
id
]
"
HSTS
priming
"
+
which_test
+
"
:
"
+
curTest
.
id
+
"
expected
"
+
test_settings
[
which_test
]
.
result
[
curTest
.
id
]
+
"
got
blocked
"
)
;
test_settings
[
which_test
]
.
finished
[
curTest
.
id
]
=
"
blocked
"
;
}
get_current_test
:
function
(
uri
)
{
for
(
let
item
in
test_servers
)
{
let
re
=
RegExp
(
'
https
?
:
/
/
'
+
test_servers
[
item
]
.
host
+
'
.
*
\
/
browser
/
dom
/
security
/
test
/
hsts
/
file_testserver
.
sjs
'
)
;
if
(
re
.
test
(
uri
)
)
{
return
test_servers
[
item
]
;
}
}
return
null
;
}
http_on_modify_request
:
function
(
subject
topic
data
)
{
let
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
uri
=
channel
.
URI
.
asciiSpec
;
let
curTest
=
this
.
get_current_test
(
channel
.
URI
.
asciiSpec
)
;
if
(
!
curTest
)
{
return
;
}
if
(
!
(
uri
in
this
.
listeners
)
)
{
this
.
listeners
[
uri
]
=
new
StreamListener
(
subject
)
;
}
if
(
channel
.
requestMethod
!
=
'
HEAD
'
)
{
return
;
}
if
(
typeof
ok
=
=
=
'
undefined
'
)
{
return
;
}
ok
(
!
(
curTest
.
id
in
test_settings
[
which_test
]
.
priming
)
"
Already
saw
a
priming
request
for
"
+
curTest
.
id
)
;
test_settings
[
which_test
]
.
priming
[
curTest
.
id
]
=
true
;
}
http_on_examine_response
:
function
(
subject
topic
data
)
{
let
channel
=
subject
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
let
curTest
=
this
.
get_current_test
(
channel
.
URI
.
asciiSpec
)
;
let
uri
=
channel
.
URI
.
asciiSpec
;
if
(
!
curTest
)
{
return
;
}
let
result
=
(
channel
.
URI
.
asciiSpec
.
startsWith
(
'
https
:
'
)
)
?
"
secure
"
:
"
insecure
"
;
if
(
channel
.
requestMethod
=
=
'
HEAD
'
)
{
is
(
true
curTest
.
response
"
HSTS
priming
response
found
"
+
curTest
.
id
)
;
return
;
}
is
(
result
test_settings
[
which_test
]
.
result
[
curTest
.
id
]
"
HSTS
priming
result
"
+
which_test
+
"
:
"
+
curTest
.
id
)
;
test_settings
[
which_test
]
.
finished
[
curTest
.
id
]
=
result
;
if
(
this
.
listeners
[
uri
]
)
{
this
.
listeners
[
uri
]
=
undefined
;
}
}
}
;
function
openTab
(
uri
)
{
let
tab
=
BrowserTestUtils
.
addTab
(
gBrowser
uri
)
;
gBrowser
.
selectedTab
=
tab
;
tab
.
ownerGlobal
.
focus
(
)
;
return
tab
;
}
function
clear_sts_data
(
)
{
for
(
let
test
in
test_servers
)
{
SpecialPowers
.
cleanUpSTSData
(
'
http
:
/
/
'
+
test_servers
[
test
]
.
host
)
;
}
}
var
oldCanRecord
=
Services
.
telemetry
.
canRecordExtended
;
function
do_cleanup
(
)
{
clear_sts_data
(
)
;
Services
.
obs
.
removeObserver
(
Observer
"
console
-
api
-
log
-
event
"
)
;
Services
.
obs
.
removeObserver
(
Observer
"
http
-
on
-
examine
-
response
"
)
;
Services
.
telemetry
.
canRecordExtended
=
oldCanRecord
;
Observer
.
cleanup
(
)
;
}
function
SetupPrefTestEnvironment
(
which
additional_prefs
)
{
which_test
=
which
;
clear_sts_data
(
)
;
var
settings
=
test_settings
[
which
]
;
settings
.
priming
=
{
}
;
settings
.
finished
=
{
}
;
var
prefs
=
[
[
"
security
.
mixed_content
.
block_active_content
"
settings
.
block_active
]
[
"
security
.
mixed_content
.
block_display_content
"
settings
.
block_display
]
[
"
security
.
mixed_content
.
use_hsts
"
settings
.
use_hsts
]
[
"
security
.
mixed_content
.
send_hsts_priming
"
settings
.
send_hsts_priming
]
]
;
if
(
additional_prefs
)
{
for
(
let
idx
in
additional_prefs
)
{
prefs
.
push
(
additional_prefs
[
idx
]
)
;
}
}
Services
.
telemetry
.
canRecordExtended
=
true
;
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
prefs
}
)
;
}
function
build_test_uri
(
base_uri
host
test_id
type
timeout
)
{
return
base_uri
+
"
?
host
=
"
+
escape
(
host
)
+
"
&
id
=
"
+
escape
(
test_id
)
+
"
&
type
=
"
+
escape
(
type
)
+
"
&
timeout
=
"
+
escape
(
timeout
)
;
}
async
function
execute_test
(
test
mimetype
)
{
var
src
=
build_test_uri
(
TOP_URI
test_servers
[
test
]
.
host
test
test_settings
[
which_test
]
.
type
test_settings
[
which_test
]
.
timeout
)
;
await
BrowserTestUtils
.
withNewTab
(
src
(
)
=
>
{
}
)
;
}
function
test_telemetry
(
expected
)
{
for
(
let
key
in
expected
[
'
histograms
'
]
)
{
let
hs
=
undefined
;
try
{
let
hist
=
Services
.
telemetry
.
getHistogramById
(
key
)
;
hs
=
hist
.
snapshot
(
)
;
hist
.
clear
(
)
;
}
catch
(
e
)
{
ok
(
false
"
Caught
exception
trying
to
get
histogram
for
key
"
+
key
+
"
:
"
+
e
)
;
continue
;
}
if
(
!
hs
)
{
ok
(
false
"
No
histogram
found
for
key
"
+
key
)
;
continue
;
}
if
(
Array
.
isArray
(
expected
[
'
histograms
'
]
[
key
]
)
)
{
var
is_ok
=
true
;
if
(
expected
[
'
histograms
'
]
[
key
]
.
length
!
=
hs
.
counts
.
length
)
{
ok
(
false
"
Histogram
lengths
match
"
)
;
continue
;
}
for
(
let
idx
in
expected
[
'
histograms
'
]
[
key
]
)
{
is_ok
=
(
hs
.
counts
[
idx
]
>
=
expected
[
'
histograms
'
]
[
key
]
[
idx
]
)
;
if
(
!
is_ok
)
{
break
;
}
}
ok
(
is_ok
"
Histogram
counts
match
for
"
+
key
+
"
-
Got
"
+
hs
.
counts
+
"
expected
"
+
expected
[
'
histograms
'
]
[
key
]
)
;
}
else
{
ok
(
hs
.
counts
.
reduce
(
sum
)
>
=
expected
[
'
histograms
'
]
[
key
]
"
Histogram
counts
match
expected
got
"
+
hs
.
counts
.
reduce
(
sum
)
+
"
expected
at
least
"
+
expected
[
'
histograms
'
]
[
key
]
)
;
}
}
for
(
let
key
in
expected
[
'
keyed
-
histograms
'
]
)
{
let
hs
=
undefined
;
try
{
let
hist
=
Services
.
telemetry
.
getKeyedHistogramById
(
key
)
;
hs
=
hist
.
snapshot
(
)
;
hist
.
clear
(
)
;
}
catch
(
e
)
{
ok
(
false
"
Caught
exception
trying
to
get
histogram
for
key
"
+
key
+
"
:
"
+
e
)
;
continue
;
}
if
(
!
hs
)
{
ok
(
false
"
No
keyed
histogram
found
for
key
"
+
key
)
;
continue
;
}
for
(
let
hist_key
in
expected
[
'
keyed
-
histograms
'
]
[
key
]
)
{
ok
(
hist_key
in
hs
"
Keyed
histogram
exists
with
key
"
)
;
if
(
hist_key
in
hs
)
{
ok
(
hs
[
hist_key
]
.
counts
.
reduce
(
sum
)
>
=
expected
[
'
keyed
-
histograms
'
]
[
key
]
[
hist_key
]
"
Keyed
histogram
counts
match
expected
got
"
+
hs
[
hist_key
]
.
counts
.
reduce
(
sum
)
+
"
expected
at
least
"
+
expected
[
'
keyed
-
histograms
'
]
[
key
]
[
hist_key
]
)
}
}
}
}
function
sum
(
a
b
)
{
return
a
+
b
;
}
function
clear_hists
(
hists
)
{
for
(
let
key
in
hists
[
'
histograms
'
]
)
{
try
{
let
hist
=
Services
.
telemetry
.
getHistogramById
(
key
)
;
hist
.
clear
(
)
;
}
catch
(
e
)
{
continue
;
}
}
for
(
let
key
in
hists
[
'
keyed
-
histograms
'
]
)
{
try
{
let
hist
=
Services
.
telemetry
.
getKeyedHistogramById
(
key
)
;
hist
.
clear
(
)
;
}
catch
(
e
)
{
continue
;
}
}
}
