#
include
"
nsAttrValue
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSPUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsCSPParser
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsWhitespaceTokenizer
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
CSPDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
SRIMetadata
.
h
"
#
include
"
mozilla
/
dom
/
TrustedTypesConstants
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
SRIMetadata
;
#
define
DEFAULT_PORT
-
1
static
mozilla
:
:
LogModule
*
GetCspUtilsLog
(
)
{
static
mozilla
:
:
LazyLogModule
gCspUtilsPRLog
(
"
CSPUtils
"
)
;
return
gCspUtilsPRLog
;
}
#
define
CSPUTILSLOG
(
args
)
\
MOZ_LOG
(
GetCspUtilsLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
CSPUTILSLOGENABLED
(
)
\
MOZ_LOG_TEST
(
GetCspUtilsLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
)
void
CSP_PercentDecodeStr
(
const
nsAString
&
aEncStr
nsAString
&
outDecStr
)
{
outDecStr
.
Truncate
(
)
;
struct
local
{
static
inline
char16_t
convertHexDig
(
char16_t
aHexDig
)
{
if
(
isNumberToken
(
aHexDig
)
)
{
return
aHexDig
-
'
0
'
;
}
if
(
aHexDig
>
=
'
A
'
&
&
aHexDig
<
=
'
F
'
)
{
return
aHexDig
-
'
A
'
+
10
;
}
return
aHexDig
-
'
a
'
+
10
;
}
}
;
const
char16_t
*
cur
*
end
*
hexDig1
*
hexDig2
;
cur
=
aEncStr
.
BeginReading
(
)
;
end
=
aEncStr
.
EndReading
(
)
;
while
(
cur
!
=
end
)
{
if
(
*
cur
!
=
PERCENT_SIGN
)
{
outDecStr
.
Append
(
*
cur
)
;
cur
+
+
;
continue
;
}
hexDig1
=
cur
+
1
;
hexDig2
=
cur
+
2
;
if
(
hexDig1
=
=
end
|
|
hexDig2
=
=
end
|
|
!
isValidHexDig
(
*
hexDig1
)
|
|
!
isValidHexDig
(
*
hexDig2
)
)
{
outDecStr
.
Append
(
PERCENT_SIGN
)
;
cur
+
+
;
continue
;
}
char16_t
decChar
=
(
local
:
:
convertHexDig
(
*
hexDig1
)
<
<
4
)
+
local
:
:
convertHexDig
(
*
hexDig2
)
;
outDecStr
.
Append
(
decChar
)
;
cur
=
+
+
hexDig2
;
}
}
bool
CSP_ShouldResponseInheritCSP
(
nsIChannel
*
aChannel
)
{
if
(
!
aChannel
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
isAbout
=
uri
-
>
SchemeIs
(
"
about
"
)
;
if
(
isAbout
)
{
nsAutoCString
aboutSpec
;
rv
=
uri
-
>
GetSpec
(
aboutSpec
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
StringBeginsWith
(
aboutSpec
"
about
:
blank
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
srcdoc
"
_ns
)
)
{
return
true
;
}
}
return
uri
-
>
SchemeIs
(
"
blob
"
)
|
|
uri
-
>
SchemeIs
(
"
data
"
)
|
|
uri
-
>
SchemeIs
(
"
filesystem
"
)
|
|
uri
-
>
SchemeIs
(
"
javascript
"
)
;
}
void
CSP_ApplyMetaCSPToDoc
(
mozilla
:
:
dom
:
:
Document
&
aDoc
const
nsAString
&
aPolicyStr
)
{
if
(
aDoc
.
IsLoadedAsData
(
)
)
{
return
;
}
nsAutoString
policyStr
(
nsContentUtils
:
:
TrimWhitespace
<
nsContentUtils
:
:
IsHTMLWhitespace
>
(
aPolicyStr
)
)
;
if
(
policyStr
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDoc
.
GetCsp
(
)
;
if
(
!
csp
)
{
MOZ_ASSERT
(
false
"
how
come
there
is
no
CSP
"
)
;
return
;
}
bool
reportOnly
=
false
;
if
(
nsIURI
*
uri
=
aDoc
.
GetDocumentURI
(
)
;
uri
-
>
SchemeIs
(
"
chrome
"
)
)
{
nsAutoCString
spec
;
uri
-
>
GetSpec
(
spec
)
;
if
(
spec
.
EqualsLiteral
(
"
chrome
:
/
/
browser
/
content
/
browser
.
xhtml
"
)
)
{
if
(
!
StaticPrefs
:
:
security_browser_xhtml_csp_enabled
(
)
)
{
return
;
}
if
(
StaticPrefs
:
:
security_browser_xhtml_csp_report_only
(
)
)
{
reportOnly
=
true
;
}
}
}
nsresult
rv
=
csp
-
>
AppendPolicy
(
policyStr
reportOnly
true
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
nsPIDOMWindowInner
*
inner
=
aDoc
.
GetInnerWindow
(
)
)
{
inner
-
>
SetCsp
(
csp
)
;
}
aDoc
.
ApplySettingsFromCSP
(
false
)
;
}
void
CSP_GetLocalizedStr
(
const
char
*
aName
const
nsTArray
<
nsString
>
&
aParams
nsAString
&
outResult
)
{
nsCOMPtr
<
nsIStringBundle
>
keyStringBundle
;
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
components
:
:
StringBundle
:
:
Service
(
)
;
NS_ASSERTION
(
stringBundleService
"
String
bundle
service
must
be
present
!
"
)
;
stringBundleService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
security
/
csp
.
properties
"
getter_AddRefs
(
keyStringBundle
)
)
;
NS_ASSERTION
(
keyStringBundle
"
Key
string
bundle
must
be
available
!
"
)
;
if
(
!
keyStringBundle
)
{
return
;
}
if
(
aParams
.
IsEmpty
(
)
)
{
keyStringBundle
-
>
GetStringFromName
(
aName
outResult
)
;
}
else
{
keyStringBundle
-
>
FormatStringFromName
(
aName
aParams
outResult
)
;
}
}
void
CSP_LogStrMessage
(
const
nsAString
&
aMsg
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
!
console
)
{
return
;
}
nsString
msg
(
aMsg
)
;
console
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
void
CSP_LogMessage
(
const
nsAString
&
aMessage
const
nsACString
&
aSourceName
const
nsAString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
const
nsACString
&
aCategory
uint64_t
aInnerWindowID
bool
aFromPrivateWindow
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
)
;
nsCOMPtr
<
nsIScriptError
>
error
(
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
)
;
if
(
!
console
|
|
!
error
)
{
return
;
}
nsString
cspMsg
;
CSP_GetLocalizedStr
(
"
CSPMessagePrefix
"
AutoTArray
<
nsString
1
>
{
nsString
(
aMessage
)
}
cspMsg
)
;
if
(
!
aSourceLine
.
IsEmpty
(
)
&
&
aLineNumber
=
=
0
)
{
cspMsg
.
AppendLiteral
(
u
"
\
nSource
:
"
)
;
cspMsg
.
Append
(
aSourceLine
)
;
}
nsCString
category
(
"
CSP_
"
)
;
category
.
Append
(
aCategory
)
;
nsresult
rv
;
if
(
aInnerWindowID
>
0
)
{
rv
=
error
-
>
InitWithWindowID
(
cspMsg
aSourceName
aLineNumber
aColumnNumber
aFlags
category
aInnerWindowID
)
;
}
else
{
rv
=
error
-
>
Init
(
cspMsg
aSourceName
aLineNumber
aColumnNumber
aFlags
category
aFromPrivateWindow
true
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
console
-
>
LogMessage
(
error
)
;
}
CSPDirective
CSP_StringToCSPDirective
(
const
nsAString
&
aDir
)
{
nsString
lowerDir
=
PromiseFlatString
(
aDir
)
;
ToLowerCase
(
lowerDir
)
;
uint32_t
numDirs
=
(
sizeof
(
CSPStrDirectives
)
/
sizeof
(
CSPStrDirectives
[
0
]
)
)
;
for
(
uint32_t
i
=
1
;
i
<
numDirs
;
i
+
+
)
{
if
(
lowerDir
.
EqualsASCII
(
CSPStrDirectives
[
i
]
)
)
{
return
static_cast
<
CSPDirective
>
(
i
)
;
}
}
return
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
;
}
void
CSP_LogLocalizedStr
(
const
char
*
aName
const
nsTArray
<
nsString
>
&
aParams
const
nsACString
&
aSourceName
const
nsAString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
const
nsACString
&
aCategory
uint64_t
aInnerWindowID
bool
aFromPrivateWindow
)
{
nsAutoString
logMsg
;
CSP_GetLocalizedStr
(
aName
aParams
logMsg
)
;
CSP_LogMessage
(
logMsg
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aFlags
aCategory
aInnerWindowID
aFromPrivateWindow
)
;
}
CSPDirective
CSP_ContentTypeToDirective
(
nsContentPolicyType
aType
)
{
switch
(
aType
)
{
case
nsIContentPolicy
:
:
TYPE_IMAGE
:
case
nsIContentPolicy
:
:
TYPE_IMAGESET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EXTERNAL_RESOURCE
:
return
nsIContentSecurityPolicy
:
:
IMG_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_XSLT
:
case
nsIContentPolicy
:
:
TYPE_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIOWORKLET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_PAINTWORKLET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_CHROMEUTILS_COMPILED_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME_MESSAGEMANAGER_SCRIPT
:
return
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_STYLESHEET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
:
return
nsIContentSecurityPolicy
:
:
STYLE_SRC_ELEM_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_FONT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FONT_PRELOAD
:
return
nsIContentSecurityPolicy
:
:
FONT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_MEDIA
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_TRACK
:
return
nsIContentSecurityPolicy
:
:
MEDIA_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_WEB_MANIFEST
:
return
nsIContentSecurityPolicy
:
:
WEB_MANIFEST_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_STATIC_MODULE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
:
return
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
:
return
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_WEBSOCKET
:
case
nsIContentPolicy
:
:
TYPE_XMLHTTPREQUEST
:
case
nsIContentPolicy
:
:
TYPE_BEACON
:
case
nsIContentPolicy
:
:
TYPE_PING
:
case
nsIContentPolicy
:
:
TYPE_FETCH
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST_ASYNC
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST_SYNC
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EVENTSOURCE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FETCH_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_WEB_IDENTITY
:
case
nsIContentPolicy
:
:
TYPE_WEB_TRANSPORT
:
case
nsIContentPolicy
:
:
TYPE_JSON
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_JSON_PRELOAD
:
return
nsIContentSecurityPolicy
:
:
CONNECT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_OBJECT
:
case
nsIContentPolicy
:
:
TYPE_OBJECT_SUBREQUEST
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EMBED
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_OBJECT
:
return
nsIContentSecurityPolicy
:
:
OBJECT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_DTD
:
case
nsIContentPolicy
:
:
TYPE_OTHER
:
case
nsIContentPolicy
:
:
TYPE_SPECULATIVE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_DTD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FORCE_ALLOWED_DTD
:
return
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_PROXIED_WEBRTC_MEDIA
:
case
nsIContentPolicy
:
:
TYPE_DOCUMENT
:
case
nsIContentPolicy
:
:
TYPE_CSP_REPORT
:
return
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_SAVEAS_DOWNLOAD
:
case
nsIContentPolicy
:
:
TYPE_UA_FONT
:
return
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_INVALID
:
case
nsIContentPolicy
:
:
TYPE_END
:
MOZ_ASSERT
(
false
"
Can
not
map
nsContentPolicyType
to
CSPDirective
"
)
;
}
return
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
;
}
nsCSPHostSrc
*
CSP_CreateHostSrcFromSelfURI
(
nsIURI
*
aSelfURI
)
{
nsCString
host
;
aSelfURI
-
>
GetAsciiHost
(
host
)
;
nsCSPHostSrc
*
hostsrc
=
new
nsCSPHostSrc
(
NS_ConvertUTF8toUTF16
(
host
)
)
;
hostsrc
-
>
setGeneratedFromSelfKeyword
(
)
;
nsCString
scheme
;
aSelfURI
-
>
GetScheme
(
scheme
)
;
hostsrc
-
>
setScheme
(
NS_ConvertUTF8toUTF16
(
scheme
)
)
;
if
(
host
.
EqualsLiteral
(
"
"
)
)
{
hostsrc
-
>
setIsUniqueOrigin
(
)
;
return
hostsrc
;
}
int32_t
port
;
aSelfURI
-
>
GetPort
(
&
port
)
;
if
(
port
>
0
)
{
nsAutoString
portStr
;
portStr
.
AppendInt
(
port
)
;
hostsrc
-
>
setPort
(
portStr
)
;
}
return
hostsrc
;
}
bool
CSP_IsEmptyDirective
(
const
nsAString
&
aValue
const
nsAString
&
aDir
)
{
return
(
aDir
.
Length
(
)
=
=
0
&
&
aValue
.
Length
(
)
=
=
0
)
;
}
bool
CSP_IsDirective
(
const
nsAString
&
aValue
CSPDirective
aDir
)
{
return
aValue
.
LowerCaseEqualsASCII
(
CSP_CSPDirectiveToString
(
aDir
)
)
;
}
bool
CSP_IsKeyword
(
const
nsAString
&
aValue
enum
CSPKeyword
aKey
)
{
return
aValue
.
LowerCaseEqualsASCII
(
CSP_EnumToUTF8Keyword
(
aKey
)
)
;
}
bool
CSP_IsQuotelessKeyword
(
const
nsAString
&
aKey
)
{
nsString
lowerKey
;
ToLowerCase
(
aKey
lowerKey
)
;
nsAutoString
keyword
;
for
(
uint32_t
i
=
0
;
i
<
CSP_LAST_KEYWORD_VALUE
;
i
+
+
)
{
keyword
.
AssignASCII
(
gCSPUTF8Keywords
[
i
]
+
1
)
;
keyword
.
Trim
(
"
'
"
false
true
)
;
if
(
lowerKey
.
Equals
(
keyword
)
)
{
return
true
;
}
}
return
false
;
}
bool
permitsScheme
(
const
nsAString
&
aEnforcementScheme
nsIURI
*
aUri
bool
aReportOnly
bool
aUpgradeInsecure
bool
aFromSelfURI
)
{
nsAutoCString
scheme
;
nsresult
rv
=
aUri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
aEnforcementScheme
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
aEnforcementScheme
.
EqualsASCII
(
scheme
.
get
(
)
)
)
{
return
true
;
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
http
"
)
)
{
if
(
scheme
.
EqualsASCII
(
"
https
"
)
)
{
return
true
;
}
if
(
(
scheme
.
EqualsASCII
(
"
ws
"
)
|
|
scheme
.
EqualsASCII
(
"
wss
"
)
)
&
&
aFromSelfURI
)
{
return
true
;
}
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
https
"
)
)
{
if
(
scheme
.
EqualsLiteral
(
"
wss
"
)
&
&
aFromSelfURI
)
{
return
true
;
}
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
ws
"
)
&
&
scheme
.
EqualsASCII
(
"
wss
"
)
)
{
return
true
;
}
return
(
(
aUpgradeInsecure
&
&
!
aReportOnly
)
&
&
(
(
scheme
.
EqualsASCII
(
"
http
"
)
&
&
aEnforcementScheme
.
EqualsASCII
(
"
https
"
)
)
|
|
(
scheme
.
EqualsASCII
(
"
ws
"
)
&
&
aEnforcementScheme
.
EqualsASCII
(
"
wss
"
)
)
)
)
;
}
nsresult
CSP_AppendCSPFromHeader
(
nsIContentSecurityPolicy
*
aCsp
const
nsAString
&
aHeaderValue
bool
aReportOnly
)
{
NS_ENSURE_ARG
(
aCsp
)
;
nsresult
rv
=
NS_OK
;
for
(
const
nsAString
&
policy
:
nsCharSeparatedTokenizer
(
aHeaderValue
'
'
)
.
ToRange
(
)
)
{
rv
=
aCsp
-
>
AppendPolicy
(
policy
aReportOnly
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
{
CSPUTILSLOG
(
(
"
CSP
refined
with
policy
:
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
policy
)
.
get
(
)
)
)
;
}
}
return
NS_OK
;
}
nsCSPBaseSrc
:
:
nsCSPBaseSrc
(
)
{
}
nsCSPBaseSrc
:
:
~
nsCSPBaseSrc
(
)
=
default
;
bool
nsCSPBaseSrc
:
:
permits
(
nsIURI
*
aUri
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPBaseSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
return
false
;
}
bool
nsCSPBaseSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
)
const
{
CSPUTILSLOG
(
(
"
nsCSPBaseSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
aKeyword
=
=
CSP_HASH
?
"
hash
"
:
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
return
false
;
}
nsCSPSchemeSrc
:
:
nsCSPSchemeSrc
(
const
nsAString
&
aScheme
)
:
mScheme
(
aScheme
)
{
ToLowerCase
(
mScheme
)
;
}
nsCSPSchemeSrc
:
:
~
nsCSPSchemeSrc
(
)
=
default
;
bool
nsCSPSchemeSrc
:
:
permits
(
nsIURI
*
aUri
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPSchemeSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
MOZ_ASSERT
(
(
!
mScheme
.
EqualsASCII
(
"
"
)
)
"
scheme
can
not
be
the
empty
string
"
)
;
return
permitsScheme
(
mScheme
aUri
aReportOnly
aUpgradeInsecure
false
)
;
}
bool
nsCSPSchemeSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitSchemeSrc
(
*
this
)
;
}
void
nsCSPSchemeSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
mScheme
)
;
outStr
.
AppendLiteral
(
"
:
"
)
;
}
nsCSPHostSrc
:
:
nsCSPHostSrc
(
const
nsAString
&
aHost
)
:
mHost
(
aHost
)
mGeneratedFromSelfKeyword
(
false
)
mIsUniqueOrigin
(
false
)
mWithinFrameAncstorsDir
(
false
)
{
ToLowerCase
(
mHost
)
;
}
nsCSPHostSrc
:
:
~
nsCSPHostSrc
(
)
=
default
;
bool
permitsPort
(
const
nsAString
&
aEnforcementScheme
const
nsAString
&
aEnforcementPort
nsIURI
*
aResourceURI
)
{
if
(
aEnforcementPort
.
EqualsASCII
(
"
*
"
)
)
{
return
true
;
}
int32_t
resourcePort
;
nsresult
rv
=
aResourceURI
-
>
GetPort
(
&
resourcePort
)
;
if
(
NS_FAILED
(
rv
)
&
&
aEnforcementPort
.
IsEmpty
(
)
)
{
if
(
aEnforcementScheme
.
IsEmpty
(
)
)
{
return
false
;
}
int
defaultPortforScheme
=
NS_GetDefaultPort
(
NS_ConvertUTF16toUTF8
(
aEnforcementScheme
)
.
get
(
)
)
;
return
(
defaultPortforScheme
=
=
-
1
|
|
defaultPortforScheme
=
=
-
0
)
;
}
if
(
resourcePort
=
=
DEFAULT_PORT
&
&
aEnforcementPort
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
resourcePort
=
=
DEFAULT_PORT
)
{
nsAutoCString
resourceScheme
;
rv
=
aResourceURI
-
>
GetScheme
(
resourceScheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
resourcePort
=
NS_GetDefaultPort
(
resourceScheme
.
get
(
)
)
;
}
nsString
resourcePortStr
;
resourcePortStr
.
AppendInt
(
resourcePort
)
;
if
(
aEnforcementPort
.
Equals
(
resourcePortStr
)
)
{
return
true
;
}
nsString
enforcementPort
(
aEnforcementPort
)
;
if
(
enforcementPort
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
aEnforcementScheme
.
IsEmpty
(
)
"
need
a
scheme
to
query
default
port
"
)
;
int32_t
defaultEnforcementPort
=
NS_GetDefaultPort
(
NS_ConvertUTF16toUTF8
(
aEnforcementScheme
)
.
get
(
)
)
;
enforcementPort
.
Truncate
(
)
;
enforcementPort
.
AppendInt
(
defaultEnforcementPort
)
;
}
if
(
enforcementPort
.
Equals
(
resourcePortStr
)
)
{
return
true
;
}
if
(
enforcementPort
.
EqualsLiteral
(
"
80
"
)
&
&
resourcePortStr
.
EqualsLiteral
(
"
443
"
)
)
{
return
true
;
}
return
false
;
}
bool
nsCSPHostSrc
:
:
permits
(
nsIURI
*
aUri
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPHostSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
if
(
mIsUniqueOrigin
)
{
return
false
;
}
if
(
!
permitsScheme
(
mScheme
aUri
aReportOnly
aUpgradeInsecure
mGeneratedFromSelfKeyword
)
)
{
return
false
;
}
NS_ASSERTION
(
(
!
mHost
.
IsEmpty
(
)
)
"
host
can
not
be
the
empty
string
"
)
;
nsAutoCString
uriHost
;
nsresult
rv
=
aUri
-
>
GetAsciiHost
(
uriHost
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsString
decodedUriHost
;
CSP_PercentDecodeStr
(
NS_ConvertUTF8toUTF16
(
uriHost
)
decodedUriHost
)
;
if
(
mHost
.
EqualsASCII
(
"
*
"
)
)
{
if
(
aUri
-
>
SchemeIs
(
"
blob
"
)
|
|
aUri
-
>
SchemeIs
(
"
data
"
)
|
|
aUri
-
>
SchemeIs
(
"
filesystem
"
)
)
{
return
false
;
}
if
(
mScheme
.
IsEmpty
(
)
)
{
return
true
;
}
}
else
if
(
mHost
.
First
(
)
=
=
'
*
'
)
{
NS_ASSERTION
(
mHost
[
1
]
=
=
'
.
'
"
Second
character
needs
to
be
'
.
'
whenever
host
starts
with
'
*
'
"
)
;
nsString
wildCardHost
=
mHost
;
wildCardHost
=
Substring
(
wildCardHost
1
wildCardHost
.
Length
(
)
-
1
)
;
if
(
!
StringEndsWith
(
decodedUriHost
wildCardHost
)
)
{
return
false
;
}
}
else
if
(
!
mHost
.
Equals
(
decodedUriHost
)
)
{
return
false
;
}
if
(
!
permitsPort
(
mScheme
mPort
aUri
)
)
{
return
false
;
}
if
(
!
aWasRedirected
&
&
!
mPath
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aUri
)
;
if
(
!
url
)
{
NS_ASSERTION
(
false
"
can
'
t
QI
into
nsIURI
"
)
;
return
false
;
}
nsAutoCString
uriPath
;
rv
=
url
-
>
GetFilePath
(
uriPath
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
mWithinFrameAncstorsDir
)
{
return
true
;
}
nsString
decodedUriPath
;
CSP_PercentDecodeStr
(
NS_ConvertUTF8toUTF16
(
uriPath
)
decodedUriPath
)
;
if
(
mPath
.
Last
(
)
=
=
'
/
'
)
{
if
(
!
StringBeginsWith
(
decodedUriPath
mPath
)
)
{
return
false
;
}
}
else
{
if
(
!
mPath
.
Equals
(
decodedUriPath
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
nsCSPHostSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitHostSrc
(
*
this
)
;
}
void
nsCSPHostSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
if
(
mGeneratedFromSelfKeyword
)
{
outStr
.
AppendLiteral
(
"
'
self
'
"
)
;
return
;
}
if
(
mHost
.
EqualsASCII
(
"
*
"
)
&
&
mScheme
.
IsEmpty
(
)
&
&
mPort
.
IsEmpty
(
)
)
{
outStr
.
Append
(
mHost
)
;
return
;
}
outStr
.
Append
(
mScheme
)
;
outStr
.
AppendLiteral
(
"
:
/
/
"
)
;
outStr
.
Append
(
mHost
)
;
if
(
!
mPort
.
IsEmpty
(
)
)
{
outStr
.
AppendLiteral
(
"
:
"
)
;
outStr
.
Append
(
mPort
)
;
}
outStr
.
Append
(
mPath
)
;
}
void
nsCSPHostSrc
:
:
setScheme
(
const
nsAString
&
aScheme
)
{
mScheme
=
aScheme
;
ToLowerCase
(
mScheme
)
;
}
void
nsCSPHostSrc
:
:
setPort
(
const
nsAString
&
aPort
)
{
mPort
=
aPort
;
}
void
nsCSPHostSrc
:
:
appendPath
(
const
nsAString
&
aPath
)
{
mPath
.
Append
(
aPath
)
;
}
nsCSPKeywordSrc
:
:
nsCSPKeywordSrc
(
enum
CSPKeyword
aKeyword
)
:
mKeyword
(
aKeyword
)
{
NS_ASSERTION
(
(
aKeyword
!
=
CSP_SELF
)
"
'
self
'
should
have
been
replaced
in
the
parser
"
)
;
}
nsCSPKeywordSrc
:
:
~
nsCSPKeywordSrc
(
)
=
default
;
bool
nsCSPKeywordSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
)
const
{
CSPUTILSLOG
(
(
"
nsCSPKeywordSrc
:
:
allows
aKeyWord
:
%
s
aHashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
return
mKeyword
=
=
aKeyword
;
}
bool
nsCSPKeywordSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitKeywordSrc
(
*
this
)
;
}
void
nsCSPKeywordSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
CSP_EnumToUTF16Keyword
(
mKeyword
)
)
;
}
nsCSPNonceSrc
:
:
nsCSPNonceSrc
(
const
nsAString
&
aNonce
)
:
mNonce
(
aNonce
)
{
}
nsCSPNonceSrc
:
:
~
nsCSPNonceSrc
(
)
=
default
;
bool
nsCSPNonceSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
)
const
{
CSPUTILSLOG
(
(
"
nsCSPNonceSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
if
(
aKeyword
!
=
CSP_NONCE
)
{
return
false
;
}
return
mNonce
.
Equals
(
aHashOrNonce
)
;
}
bool
nsCSPNonceSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitNonceSrc
(
*
this
)
;
}
void
nsCSPNonceSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
CSP_EnumToUTF16Keyword
(
CSP_NONCE
)
)
;
outStr
.
Append
(
mNonce
)
;
outStr
.
AppendLiteral
(
"
'
"
)
;
}
nsCSPHashSrc
:
:
nsCSPHashSrc
(
const
nsAString
&
aAlgo
const
nsAString
&
aHash
)
:
mAlgorithm
(
aAlgo
)
mHash
(
aHash
)
{
ToLowerCase
(
mAlgorithm
)
;
char16_t
*
cur
=
mHash
.
BeginWriting
(
)
;
char16_t
*
end
=
mHash
.
EndWriting
(
)
;
for
(
;
cur
<
end
;
+
+
cur
)
{
if
(
char16_t
(
'
-
'
)
=
=
*
cur
)
{
*
cur
=
char16_t
(
'
+
'
)
;
}
if
(
char16_t
(
'
_
'
)
=
=
*
cur
)
{
*
cur
=
char16_t
(
'
/
'
)
;
}
}
}
nsCSPHashSrc
:
:
~
nsCSPHashSrc
(
)
=
default
;
bool
nsCSPHashSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
)
const
{
CSPUTILSLOG
(
(
"
nsCSPHashSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
if
(
aKeyword
!
=
CSP_HASH
)
{
return
false
;
}
NS_ConvertUTF16toUTF8
utf8_hash
(
aHashOrNonce
)
;
nsCOMPtr
<
nsICryptoHash
>
hasher
;
nsresult
rv
=
NS_NewCryptoHash
(
NS_ConvertUTF16toUTF8
(
mAlgorithm
)
getter_AddRefs
(
hasher
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
hasher
-
>
Update
(
(
uint8_t
*
)
utf8_hash
.
get
(
)
utf8_hash
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsAutoCString
hash
;
rv
=
hasher
-
>
Finish
(
true
hash
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
NS_ConvertUTF16toUTF8
(
mHash
)
.
Equals
(
hash
)
;
}
bool
nsCSPHashSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitHashSrc
(
*
this
)
;
}
void
nsCSPHashSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendLiteral
(
"
'
"
)
;
outStr
.
Append
(
mAlgorithm
)
;
outStr
.
AppendLiteral
(
"
-
"
)
;
outStr
.
Append
(
mHash
)
;
outStr
.
AppendLiteral
(
"
'
"
)
;
}
nsCSPReportURI
:
:
nsCSPReportURI
(
nsIURI
*
aURI
)
:
mReportURI
(
aURI
)
{
}
nsCSPReportURI
:
:
~
nsCSPReportURI
(
)
=
default
;
bool
nsCSPReportURI
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
false
;
}
void
nsCSPReportURI
:
:
toString
(
nsAString
&
outStr
)
const
{
nsAutoCString
spec
;
nsresult
rv
=
mReportURI
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
outStr
.
AppendASCII
(
spec
.
get
(
)
)
;
}
nsCSPGroup
:
:
nsCSPGroup
(
const
nsAString
&
aGroup
)
:
mGroup
(
aGroup
)
{
}
nsCSPGroup
:
:
~
nsCSPGroup
(
)
=
default
;
bool
nsCSPGroup
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
false
;
}
void
nsCSPGroup
:
:
toString
(
nsAString
&
aOutStr
)
const
{
aOutStr
.
Append
(
mGroup
)
;
}
nsCSPSandboxFlags
:
:
nsCSPSandboxFlags
(
const
nsAString
&
aFlags
)
:
mFlags
(
aFlags
)
{
ToLowerCase
(
mFlags
)
;
}
nsCSPSandboxFlags
:
:
~
nsCSPSandboxFlags
(
)
=
default
;
bool
nsCSPSandboxFlags
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
false
;
}
void
nsCSPSandboxFlags
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
mFlags
)
;
}
nsCSPRequireTrustedTypesForDirectiveValue
:
:
nsCSPRequireTrustedTypesForDirectiveValue
(
const
nsAString
&
aValue
)
:
mValue
{
aValue
}
{
}
bool
nsCSPRequireTrustedTypesForDirectiveValue
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
MOZ_ASSERT_UNREACHABLE
(
"
This
method
should
only
be
called
for
other
overloads
of
this
method
.
"
)
;
return
false
;
}
void
nsCSPRequireTrustedTypesForDirectiveValue
:
:
toString
(
nsAString
&
aOutStr
)
const
{
aOutStr
.
Append
(
mValue
)
;
}
nsCSPTrustedTypesDirectivePolicyName
:
:
nsCSPTrustedTypesDirectivePolicyName
(
const
nsAString
&
aName
)
:
mName
{
aName
}
{
}
bool
nsCSPTrustedTypesDirectivePolicyName
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
only
be
called
for
other
overloads
of
this
method
.
"
)
;
return
false
;
}
void
nsCSPTrustedTypesDirectivePolicyName
:
:
toString
(
nsAString
&
aOutStr
)
const
{
aOutStr
.
Append
(
mName
)
;
}
nsCSPTrustedTypesDirectiveInvalidToken
:
:
nsCSPTrustedTypesDirectiveInvalidToken
(
const
nsAString
&
aInvalidToken
)
:
mInvalidToken
{
aInvalidToken
}
{
}
bool
nsCSPTrustedTypesDirectiveInvalidToken
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
only
be
called
for
other
overloads
of
this
method
.
"
)
;
return
false
;
}
void
nsCSPTrustedTypesDirectiveInvalidToken
:
:
toString
(
nsAString
&
aOutStr
)
const
{
aOutStr
.
Append
(
mInvalidToken
)
;
}
nsCSPDirective
:
:
nsCSPDirective
(
CSPDirective
aDirective
)
{
mDirective
=
aDirective
;
}
nsCSPDirective
:
:
~
nsCSPDirective
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
delete
mSrcs
[
i
]
;
}
}
static
bool
DoesNonceMatchSourceList
(
nsILoadInfo
*
aLoadInfo
const
nsTArray
<
nsCSPBaseSrc
*
>
&
aSrcs
)
{
nsAutoString
nonce
;
MOZ_ALWAYS_SUCCEEDS
(
aLoadInfo
-
>
GetCspNonce
(
nonce
)
)
;
if
(
nonce
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
nsCSPBaseSrc
*
src
:
aSrcs
)
{
if
(
src
-
>
isNonce
(
)
)
{
nsAutoString
srcNonce
;
static_cast
<
nsCSPNonceSrc
*
>
(
src
)
-
>
getNonce
(
srcNonce
)
;
if
(
srcNonce
=
=
nonce
)
{
return
true
;
}
}
}
return
false
;
}
static
nsTArray
<
SRIMetadata
>
ParseSRIMetadata
(
const
nsAString
&
aMetadata
)
{
nsTArray
<
SRIMetadata
>
result
;
NS_ConvertUTF16toUTF8
metadataList
(
aMetadata
)
;
nsAutoCString
token
;
nsCWhitespaceTokenizer
tokenizer
(
metadataList
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
token
=
tokenizer
.
nextToken
(
)
;
SRIMetadata
metadata
(
token
)
;
if
(
metadata
.
IsMalformed
(
)
)
{
continue
;
}
if
(
metadata
.
IsAlgorithmSupported
(
)
)
{
result
.
AppendElement
(
metadata
)
;
}
}
return
result
;
}
bool
nsCSPDirective
:
:
permits
(
CSPDirective
aDirective
nsILoadInfo
*
aLoadInfo
nsIURI
*
aUri
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
)
const
{
MOZ_ASSERT
(
equals
(
aDirective
)
|
|
isDefaultDirective
(
)
)
;
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPDirective
:
:
permits
aUri
:
%
s
aDirective
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
CSP_CSPDirectiveToString
(
aDirective
)
)
)
;
}
if
(
aLoadInfo
)
{
if
(
aDirective
=
=
CSPDirective
:
:
STYLE_SRC_ELEM_DIRECTIVE
)
{
if
(
DoesNonceMatchSourceList
(
aLoadInfo
mSrcs
)
)
{
CSPUTILSLOG
(
(
"
Allowed
by
matching
nonce
(
style
)
"
)
)
;
return
true
;
}
}
else
if
(
aDirective
=
=
CSPDirective
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
|
|
aDirective
=
=
CSPDirective
:
:
WORKER_SRC_DIRECTIVE
)
{
if
(
DoesNonceMatchSourceList
(
aLoadInfo
mSrcs
)
)
{
CSPUTILSLOG
(
(
"
Allowed
by
matching
nonce
(
script
-
like
)
"
)
)
;
return
true
;
}
nsTArray
<
nsCSPHashSrc
*
>
integrityExpressions
;
bool
hasStrictDynamicKeyword
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
mSrcs
[
i
]
-
>
isHash
(
)
)
{
integrityExpressions
.
AppendElement
(
static_cast
<
nsCSPHashSrc
*
>
(
mSrcs
[
i
]
)
)
;
}
else
if
(
mSrcs
[
i
]
-
>
isKeyword
(
CSP_STRICT_DYNAMIC
)
)
{
hasStrictDynamicKeyword
=
true
;
}
}
if
(
!
integrityExpressions
.
IsEmpty
(
)
)
{
nsAutoString
integrityMetadata
;
aLoadInfo
-
>
GetIntegrityMetadata
(
integrityMetadata
)
;
nsTArray
<
SRIMetadata
>
integritySources
=
ParseSRIMetadata
(
integrityMetadata
)
;
MOZ_ASSERT
(
integritySources
.
IsEmpty
(
)
=
=
integrityMetadata
.
IsEmpty
(
)
"
The
integrity
metadata
should
be
only
be
empty
"
"
when
the
parsed
string
was
completely
empty
otherwise
it
should
"
"
include
at
least
one
valid
hash
"
)
;
if
(
!
integritySources
.
IsEmpty
(
)
)
{
bool
bypass
=
true
;
nsAutoCString
sourceAlgorithmUTF8
;
nsAutoCString
sourceHashUTF8
;
nsAutoString
sourceAlgorithm
;
nsAutoString
sourceHash
;
nsAutoString
algorithm
;
nsAutoString
hash
;
for
(
const
SRIMetadata
&
source
:
integritySources
)
{
source
.
GetAlgorithm
(
&
sourceAlgorithmUTF8
)
;
sourceAlgorithm
=
NS_ConvertUTF8toUTF16
(
sourceAlgorithmUTF8
)
;
source
.
GetHash
(
0
&
sourceHashUTF8
)
;
sourceHash
=
NS_ConvertUTF8toUTF16
(
sourceHashUTF8
)
;
bool
found
=
false
;
for
(
const
nsCSPHashSrc
*
hashSrc
:
integrityExpressions
)
{
hashSrc
-
>
getAlgorithm
(
algorithm
)
;
hashSrc
-
>
getHash
(
hash
)
;
if
(
sourceAlgorithm
=
=
algorithm
&
&
sourceHash
=
=
hash
)
{
found
=
true
;
break
;
}
}
if
(
!
found
)
{
bypass
=
false
;
break
;
}
}
if
(
bypass
)
{
CSPUTILSLOG
(
(
"
Allowed
by
matching
integrity
metadata
(
script
-
like
)
"
)
)
;
return
true
;
}
}
}
if
(
hasStrictDynamicKeyword
&
&
aLoadInfo
-
>
InternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_XSLT
)
{
if
(
aLoadInfo
-
>
GetParserCreatedScript
(
)
)
{
CSPUTILSLOG
(
(
"
Blocked
by
'
strict
-
dynamic
'
because
parser
-
inserted
"
)
)
;
return
false
;
}
CSPUTILSLOG
(
(
"
Allowed
by
'
strict
-
dynamic
'
because
not
-
parser
-
inserted
"
)
)
;
return
true
;
}
}
}
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
mSrcs
[
i
]
-
>
permits
(
aUri
aWasRedirected
aReportOnly
aUpgradeInsecure
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSPDirective
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
)
const
{
CSPUTILSLOG
(
(
"
nsCSPDirective
:
:
allows
aKeyWord
:
%
s
aHashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
mSrcs
[
i
]
-
>
allows
(
aKeyword
aHashOrNonce
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSPDirective
:
:
allowsAllInlineBehavior
(
CSPDirective
aDir
)
const
{
bool
allowAll
=
false
;
for
(
nsCSPBaseSrc
*
src
:
mSrcs
)
{
if
(
src
-
>
isNonce
(
)
|
|
src
-
>
isHash
(
)
)
{
return
false
;
}
if
(
(
aDir
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
|
|
aDir
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
&
&
src
-
>
isKeyword
(
CSP_STRICT_DYNAMIC
)
)
{
return
false
;
}
if
(
src
-
>
isKeyword
(
CSP_UNSAFE_INLINE
)
)
{
allowAll
=
true
;
}
}
return
allowAll
;
}
static
constexpr
auto
kWildcard
=
u
"
*
"
_ns
;
bool
nsCSPDirective
:
:
ShouldCreateViolationForNewTrustedTypesPolicy
(
const
nsAString
&
aPolicyName
const
nsTArray
<
nsString
>
&
aCreatedPolicyNames
)
const
{
MOZ_ASSERT
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
TRUSTED_TYPES_DIRECTIVE
)
;
if
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
TRUSTED_TYPES_DIRECTIVE
)
{
if
(
allows
(
CSP_NONE
EmptyString
(
)
)
)
{
return
true
;
}
if
(
aCreatedPolicyNames
.
Contains
(
aPolicyName
)
&
&
!
allows
(
CSP_ALLOW_DUPLICATES
EmptyString
(
)
)
)
{
return
true
;
}
if
(
!
ContainsTrustedTypesDirectivePolicyName
(
aPolicyName
)
&
&
!
ContainsTrustedTypesDirectivePolicyName
(
kWildcard
)
)
{
return
true
;
}
}
return
false
;
}
void
nsCSPDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
mDirective
)
)
;
MOZ_ASSERT
(
!
mSrcs
.
IsEmpty
(
)
)
;
outStr
.
AppendLiteral
(
"
"
)
;
StringJoinAppend
(
outStr
u
"
"
_ns
mSrcs
[
]
(
nsAString
&
dest
nsCSPBaseSrc
*
cspBaseSrc
)
{
cspBaseSrc
-
>
toString
(
dest
)
;
}
)
;
}
void
nsCSPDirective
:
:
toDomCSPStruct
(
mozilla
:
:
dom
:
:
CSP
&
outCSP
)
const
{
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
srcs
;
nsString
src
;
if
(
NS_WARN_IF
(
!
srcs
.
SetCapacity
(
mSrcs
.
Length
(
)
mozilla
:
:
fallible
)
)
)
{
MOZ_ASSERT
(
false
"
Not
enough
memory
for
'
sources
'
sequence
in
"
"
nsCSPDirective
:
:
toDomCSPStruct
(
)
.
"
)
;
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
src
.
Truncate
(
)
;
mSrcs
[
i
]
-
>
toString
(
src
)
;
if
(
!
srcs
.
AppendElement
(
src
mozilla
:
:
fallible
)
)
{
MOZ_ASSERT
(
false
"
Failed
to
append
to
'
sources
'
sequence
in
"
"
nsCSPDirective
:
:
toDomCSPStruct
(
)
.
"
)
;
}
}
switch
(
mDirective
)
{
case
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
:
outCSP
.
mDefault_src
.
Construct
(
)
;
outCSP
.
mDefault_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
:
outCSP
.
mScript_src
.
Construct
(
)
;
outCSP
.
mScript_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
OBJECT_SRC_DIRECTIVE
:
outCSP
.
mObject_src
.
Construct
(
)
;
outCSP
.
mObject_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
STYLE_SRC_DIRECTIVE
:
outCSP
.
mStyle_src
.
Construct
(
)
;
outCSP
.
mStyle_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
IMG_SRC_DIRECTIVE
:
outCSP
.
mImg_src
.
Construct
(
)
;
outCSP
.
mImg_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
MEDIA_SRC_DIRECTIVE
:
outCSP
.
mMedia_src
.
Construct
(
)
;
outCSP
.
mMedia_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
:
outCSP
.
mFrame_src
.
Construct
(
)
;
outCSP
.
mFrame_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FONT_SRC_DIRECTIVE
:
outCSP
.
mFont_src
.
Construct
(
)
;
outCSP
.
mFont_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
CONNECT_SRC_DIRECTIVE
:
outCSP
.
mConnect_src
.
Construct
(
)
;
outCSP
.
mConnect_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
:
outCSP
.
mReport_uri
.
Construct
(
)
;
outCSP
.
mReport_uri
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
:
outCSP
.
mFrame_ancestors
.
Construct
(
)
;
outCSP
.
mFrame_ancestors
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
WEB_MANIFEST_SRC_DIRECTIVE
:
outCSP
.
mManifest_src
.
Construct
(
)
;
outCSP
.
mManifest_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
BASE_URI_DIRECTIVE
:
outCSP
.
mBase_uri
.
Construct
(
)
;
outCSP
.
mBase_uri
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FORM_ACTION_DIRECTIVE
:
outCSP
.
mForm_action
.
Construct
(
)
;
outCSP
.
mForm_action
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
:
outCSP
.
mBlock_all_mixed_content
.
Construct
(
)
;
return
;
case
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
:
outCSP
.
mUpgrade_insecure_requests
.
Construct
(
)
;
return
;
case
nsIContentSecurityPolicy
:
:
CHILD_SRC_DIRECTIVE
:
outCSP
.
mChild_src
.
Construct
(
)
;
outCSP
.
mChild_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
:
outCSP
.
mSandbox
.
Construct
(
)
;
outCSP
.
mSandbox
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
:
outCSP
.
mWorker_src
.
Construct
(
)
;
outCSP
.
mWorker_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
:
outCSP
.
mScript_src_elem
.
Construct
(
)
;
outCSP
.
mScript_src_elem
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
:
outCSP
.
mScript_src_attr
.
Construct
(
)
;
outCSP
.
mScript_src_attr
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
REQUIRE_TRUSTED_TYPES_FOR_DIRECTIVE
:
outCSP
.
mRequire_trusted_types_for
.
Construct
(
)
;
outCSP
.
mRequire_trusted_types_for
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
TRUSTED_TYPES_DIRECTIVE
:
outCSP
.
mTrusted_types
.
Construct
(
)
;
outCSP
.
mTrusted_types
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
REPORT_TO_DIRECTIVE
:
outCSP
.
mReport_to
.
Construct
(
)
;
outCSP
.
mReport_to
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
default
:
NS_ASSERTION
(
false
"
cannot
find
directive
to
convert
CSP
to
JSON
"
)
;
}
}
bool
nsCSPDirective
:
:
isDefaultDirective
(
)
const
{
return
mDirective
=
=
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
;
}
void
nsCSPDirective
:
:
getReportURIs
(
nsTArray
<
nsString
>
&
outReportURIs
)
const
{
NS_ASSERTION
(
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
"
not
a
report
-
uri
directive
"
)
;
nsString
tmpReportURI
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
tmpReportURI
.
Truncate
(
)
;
mSrcs
[
i
]
-
>
toString
(
tmpReportURI
)
;
outReportURIs
.
AppendElement
(
tmpReportURI
)
;
}
}
void
nsCSPDirective
:
:
getReportGroup
(
nsAString
&
outReportGroup
)
const
{
NS_ASSERTION
(
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
REPORT_TO_DIRECTIVE
)
"
not
a
report
-
to
directive
"
)
;
MOZ_ASSERT
(
mSrcs
.
Length
(
)
<
=
1
)
;
mSrcs
[
0
]
-
>
toString
(
outReportGroup
)
;
}
bool
nsCSPDirective
:
:
visitSrcs
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
!
mSrcs
[
i
]
-
>
visit
(
aVisitor
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsCSPDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
return
(
mDirective
=
=
aDirective
)
;
}
void
nsCSPDirective
:
:
getDirName
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
mDirective
)
)
;
}
bool
nsCSPDirective
:
:
hasReportSampleKeyword
(
)
const
{
for
(
nsCSPBaseSrc
*
src
:
mSrcs
)
{
if
(
src
-
>
isReportSample
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSPDirective
:
:
ContainsTrustedTypesDirectivePolicyName
(
const
nsAString
&
aPolicyName
)
const
{
MOZ_ASSERT
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
TRUSTED_TYPES_DIRECTIVE
)
;
if
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
TRUSTED_TYPES_DIRECTIVE
)
{
for
(
const
auto
*
src
:
mSrcs
)
{
if
(
src
-
>
isTrustedTypesDirectivePolicyName
(
)
)
{
const
auto
&
name
=
static_cast
<
const
nsCSPTrustedTypesDirectivePolicyName
*
>
(
src
)
-
>
GetName
(
)
;
if
(
name
.
Equals
(
aPolicyName
)
)
{
return
true
;
}
}
}
}
return
false
;
}
nsCSPChildSrcDirective
:
:
nsCSPChildSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
mRestrictFrames
(
false
)
mRestrictWorkers
(
false
)
{
}
nsCSPChildSrcDirective
:
:
~
nsCSPChildSrcDirective
(
)
=
default
;
bool
nsCSPChildSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
)
{
return
mRestrictFrames
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
)
{
return
mRestrictWorkers
;
}
return
(
mDirective
=
=
aDirective
)
;
}
nsCSPScriptSrcDirective
:
:
nsCSPScriptSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsCSPScriptSrcDirective
:
:
~
nsCSPScriptSrcDirective
(
)
=
default
;
bool
nsCSPScriptSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
)
{
return
mRestrictWorkers
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
{
return
mRestrictScriptElem
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
{
return
mRestrictScriptAttr
;
}
return
mDirective
=
=
aDirective
;
}
nsCSPStyleSrcDirective
:
:
nsCSPStyleSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsCSPStyleSrcDirective
:
:
~
nsCSPStyleSrcDirective
(
)
=
default
;
bool
nsCSPStyleSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
STYLE_SRC_ELEM_DIRECTIVE
)
{
return
mRestrictStyleElem
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
STYLE_SRC_ATTR_DIRECTIVE
)
{
return
mRestrictStyleAttr
;
}
return
mDirective
=
=
aDirective
;
}
nsBlockAllMixedContentDirective
:
:
nsBlockAllMixedContentDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsBlockAllMixedContentDirective
:
:
~
nsBlockAllMixedContentDirective
(
)
=
default
;
void
nsBlockAllMixedContentDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
)
;
}
void
nsBlockAllMixedContentDirective
:
:
getDirName
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
)
;
}
nsUpgradeInsecureDirective
:
:
nsUpgradeInsecureDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsUpgradeInsecureDirective
:
:
~
nsUpgradeInsecureDirective
(
)
=
default
;
void
nsUpgradeInsecureDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
)
;
}
void
nsUpgradeInsecureDirective
:
:
getDirName
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
)
;
}
nsCSPPolicy
:
:
nsCSPPolicy
(
)
:
mUpgradeInsecDir
(
nullptr
)
mReportOnly
(
false
)
mDeliveredViaMetaTag
(
false
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
nsCSPPolicy
"
)
)
;
}
nsCSPPolicy
:
:
~
nsCSPPolicy
(
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
~
nsCSPPolicy
"
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
delete
mDirectives
[
i
]
;
}
}
bool
nsCSPPolicy
:
:
permits
(
CSPDirective
aDir
nsILoadInfo
*
aLoadInfo
nsIURI
*
aUri
bool
aWasRedirected
bool
aSpecific
nsAString
&
outViolatedDirective
nsAString
&
outViolatedDirectiveString
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
permits
aUri
:
%
s
aDir
:
%
s
aSpecific
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
CSP_CSPDirectiveToString
(
aDir
)
aSpecific
?
"
true
"
:
"
false
"
)
)
;
}
NS_ASSERTION
(
aUri
"
permits
needs
an
uri
to
perform
the
check
!
"
)
;
outViolatedDirective
.
Truncate
(
)
;
outViolatedDirectiveString
.
Truncate
(
)
;
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
if
(
!
mDirectives
[
i
]
-
>
permits
(
aDir
aLoadInfo
aUri
aWasRedirected
mReportOnly
mUpgradeInsecDir
)
)
{
mDirectives
[
i
]
-
>
getDirName
(
outViolatedDirective
)
;
mDirectives
[
i
]
-
>
toString
(
outViolatedDirectiveString
)
;
return
false
;
}
return
true
;
}
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
}
}
if
(
!
aSpecific
&
&
defaultDir
)
{
if
(
!
defaultDir
-
>
permits
(
aDir
aLoadInfo
aUri
aWasRedirected
mReportOnly
mUpgradeInsecDir
)
)
{
defaultDir
-
>
getDirName
(
outViolatedDirective
)
;
defaultDir
-
>
toString
(
outViolatedDirectiveString
)
;
return
false
;
}
return
true
;
}
return
true
;
}
bool
nsCSPPolicy
:
:
allows
(
CSPDirective
aDirective
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
)
const
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
if
(
nsCSPDirective
*
directive
=
matchingOrDefaultDirective
(
aDirective
)
)
{
return
directive
-
>
allows
(
aKeyword
aHashOrNonce
)
;
}
return
true
;
}
nsCSPDirective
*
nsCSPPolicy
:
:
matchingOrDefaultDirective
(
CSPDirective
aDirective
)
const
{
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
continue
;
}
if
(
mDirectives
[
i
]
-
>
equals
(
aDirective
)
)
{
return
mDirectives
[
i
]
;
}
}
return
defaultDir
;
}
void
nsCSPPolicy
:
:
toString
(
nsAString
&
outStr
)
const
{
StringJoinAppend
(
outStr
u
"
;
"
_ns
mDirectives
[
]
(
nsAString
&
dest
nsCSPDirective
*
cspDirective
)
{
cspDirective
-
>
toString
(
dest
)
;
}
)
;
}
void
nsCSPPolicy
:
:
toDomCSPStruct
(
mozilla
:
:
dom
:
:
CSP
&
outCSP
)
const
{
outCSP
.
mReport_only
=
mReportOnly
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
+
+
i
)
{
mDirectives
[
i
]
-
>
toDomCSPStruct
(
outCSP
)
;
}
}
bool
nsCSPPolicy
:
:
hasDirective
(
CSPDirective
aDir
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSPPolicy
:
:
allowsAllInlineBehavior
(
CSPDirective
aDir
)
const
{
nsCSPDirective
*
directive
=
matchingOrDefaultDirective
(
aDir
)
;
if
(
!
directive
)
{
return
true
;
}
return
directive
-
>
allowsAllInlineBehavior
(
aDir
)
;
}
bool
nsCSPPolicy
:
:
ShouldCreateViolationForNewTrustedTypesPolicy
(
const
nsAString
&
aPolicyName
const
nsTArray
<
nsString
>
&
aCreatedPolicyNames
)
const
{
for
(
const
auto
*
directive
:
mDirectives
)
{
if
(
directive
-
>
equals
(
nsIContentSecurityPolicy
:
:
TRUSTED_TYPES_DIRECTIVE
)
)
{
return
directive
-
>
ShouldCreateViolationForNewTrustedTypesPolicy
(
aPolicyName
aCreatedPolicyNames
)
;
}
}
return
false
;
}
bool
nsCSPPolicy
:
:
AreTrustedTypesForSinkGroupRequired
(
const
nsAString
&
aSinkGroup
)
const
{
MOZ_ASSERT
(
aSinkGroup
=
=
dom
:
:
kTrustedTypesOnlySinkGroup
)
;
return
mHasRequireTrustedTypesForDirective
;
}
void
nsCSPPolicy
:
:
getViolatedDirectiveInformation
(
CSPDirective
aDirective
nsAString
&
aDirectiveName
nsAString
&
aDirectiveNameAndValue
bool
*
aReportSample
)
const
{
*
aReportSample
=
false
;
nsCSPDirective
*
directive
=
matchingOrDefaultDirective
(
aDirective
)
;
if
(
!
directive
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Can
not
query
violated
directive
"
)
;
aDirectiveName
.
Truncate
(
)
;
aDirectiveNameAndValue
.
Truncate
(
)
;
return
;
}
directive
-
>
getDirName
(
aDirectiveName
)
;
directive
-
>
toString
(
aDirectiveNameAndValue
)
;
*
aReportSample
=
directive
-
>
hasReportSampleKeyword
(
)
;
}
uint32_t
nsCSPPolicy
:
:
getSandboxFlags
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
)
)
{
nsAutoString
flags
;
mDirectives
[
i
]
-
>
toString
(
flags
)
;
if
(
flags
.
IsEmpty
(
)
)
{
return
SANDBOX_ALL_FLAGS
;
}
nsAttrValue
attr
;
attr
.
ParseAtomArray
(
flags
)
;
return
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
&
attr
)
;
}
}
return
SANDBOXED_NONE
;
}
void
nsCSPPolicy
:
:
getReportURIs
(
nsTArray
<
nsString
>
&
outReportURIs
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
)
{
mDirectives
[
i
]
-
>
getReportURIs
(
outReportURIs
)
;
return
;
}
}
}
void
nsCSPPolicy
:
:
getReportGroup
(
nsAString
&
outReportGroup
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
REPORT_TO_DIRECTIVE
)
)
{
mDirectives
[
i
]
-
>
getReportGroup
(
outReportGroup
)
;
return
;
}
}
}
void
nsCSPPolicy
:
:
getDirectiveNames
(
nsTArray
<
nsString
>
&
outDirectives
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
nsAutoString
name
;
mDirectives
[
i
]
-
>
getDirName
(
name
)
;
outDirectives
.
AppendElement
(
name
)
;
}
}
bool
nsCSPPolicy
:
:
visitDirectiveSrcs
(
CSPDirective
aDir
nsCSPSrcVisitor
*
aVisitor
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
return
mDirectives
[
i
]
-
>
visitSrcs
(
aVisitor
)
;
}
}
return
false
;
}
