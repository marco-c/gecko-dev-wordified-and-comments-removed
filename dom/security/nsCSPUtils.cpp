#
include
"
nsAttrValue
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSPUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
define
DEFAULT_PORT
-
1
static
mozilla
:
:
LogModule
*
GetCspUtilsLog
(
)
{
static
mozilla
:
:
LazyLogModule
gCspUtilsPRLog
(
"
CSPUtils
"
)
;
return
gCspUtilsPRLog
;
}
#
define
CSPUTILSLOG
(
args
)
MOZ_LOG
(
GetCspUtilsLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
CSPUTILSLOGENABLED
(
)
MOZ_LOG_TEST
(
GetCspUtilsLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
)
void
CSP_PercentDecodeStr
(
const
nsAString
&
aEncStr
nsAString
&
outDecStr
)
{
outDecStr
.
Truncate
(
)
;
struct
local
{
static
inline
char16_t
convertHexDig
(
char16_t
aHexDig
)
{
if
(
isNumberToken
(
aHexDig
)
)
{
return
aHexDig
-
'
0
'
;
}
if
(
aHexDig
>
=
'
A
'
&
&
aHexDig
<
=
'
F
'
)
{
return
aHexDig
-
'
A
'
+
10
;
}
return
aHexDig
-
'
a
'
+
10
;
}
}
;
const
char16_t
*
cur
*
end
*
hexDig1
*
hexDig2
;
cur
=
aEncStr
.
BeginReading
(
)
;
end
=
aEncStr
.
EndReading
(
)
;
while
(
cur
!
=
end
)
{
if
(
*
cur
!
=
PERCENT_SIGN
)
{
outDecStr
.
Append
(
*
cur
)
;
cur
+
+
;
continue
;
}
hexDig1
=
cur
+
1
;
hexDig2
=
cur
+
2
;
if
(
hexDig1
=
=
end
|
|
hexDig2
=
=
end
|
|
!
isValidHexDig
(
*
hexDig1
)
|
|
!
isValidHexDig
(
*
hexDig2
)
)
{
outDecStr
.
Append
(
PERCENT_SIGN
)
;
cur
+
+
;
continue
;
}
char16_t
decChar
=
(
local
:
:
convertHexDig
(
*
hexDig1
)
<
<
4
)
+
local
:
:
convertHexDig
(
*
hexDig2
)
;
outDecStr
.
Append
(
decChar
)
;
cur
=
+
+
hexDig2
;
}
}
void
CSP_GetLocalizedStr
(
const
char
*
aName
const
char16_t
*
*
aParams
uint32_t
aLength
nsAString
&
outResult
)
{
nsCOMPtr
<
nsIStringBundle
>
keyStringBundle
;
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
NS_ASSERTION
(
stringBundleService
"
String
bundle
service
must
be
present
!
"
)
;
stringBundleService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
security
/
csp
.
properties
"
getter_AddRefs
(
keyStringBundle
)
)
;
NS_ASSERTION
(
keyStringBundle
"
Key
string
bundle
must
be
available
!
"
)
;
if
(
!
keyStringBundle
)
{
return
;
}
keyStringBundle
-
>
FormatStringFromName
(
aName
aParams
aLength
outResult
)
;
}
void
CSP_LogStrMessage
(
const
nsAString
&
aMsg
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
!
console
)
{
return
;
}
nsString
msg
=
PromiseFlatString
(
aMsg
)
;
console
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
void
CSP_LogMessage
(
const
nsAString
&
aMessage
const
nsAString
&
aSourceName
const
nsAString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
const
char
*
aCategory
uint64_t
aInnerWindowID
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
)
;
nsCOMPtr
<
nsIScriptError
>
error
(
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
)
;
if
(
!
console
|
|
!
error
)
{
return
;
}
nsString
cspMsg
;
cspMsg
.
AppendLiteral
(
u
"
Content
Security
Policy
:
"
)
;
cspMsg
.
Append
(
aMessage
)
;
if
(
!
aSourceLine
.
IsEmpty
(
)
)
{
cspMsg
.
AppendLiteral
(
"
Source
:
"
)
;
cspMsg
.
Append
(
aSourceLine
)
;
cspMsg
.
AppendLiteral
(
u
"
.
"
)
;
}
nsresult
rv
;
if
(
aInnerWindowID
>
0
)
{
nsCString
catStr
;
catStr
.
AssignASCII
(
aCategory
)
;
rv
=
error
-
>
InitWithWindowID
(
cspMsg
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aFlags
catStr
aInnerWindowID
)
;
}
else
{
rv
=
error
-
>
Init
(
cspMsg
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aFlags
aCategory
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
console
-
>
LogMessage
(
error
)
;
}
void
CSP_LogLocalizedStr
(
const
char
*
aName
const
char16_t
*
*
aParams
uint32_t
aLength
const
nsAString
&
aSourceName
const
nsAString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
const
char
*
aCategory
uint64_t
aInnerWindowID
)
{
nsAutoString
logMsg
;
CSP_GetLocalizedStr
(
aName
aParams
aLength
logMsg
)
;
CSP_LogMessage
(
logMsg
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aFlags
aCategory
aInnerWindowID
)
;
}
CSPDirective
CSP_ContentTypeToDirective
(
nsContentPolicyType
aType
)
{
switch
(
aType
)
{
case
nsIContentPolicy
:
:
TYPE_IMAGE
:
case
nsIContentPolicy
:
:
TYPE_IMAGESET
:
return
nsIContentSecurityPolicy
:
:
IMG_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_XSLT
:
case
nsIContentPolicy
:
:
TYPE_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS
:
return
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_STYLESHEET
:
return
nsIContentSecurityPolicy
:
:
STYLE_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_FONT
:
return
nsIContentSecurityPolicy
:
:
FONT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_MEDIA
:
return
nsIContentSecurityPolicy
:
:
MEDIA_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_WEB_MANIFEST
:
return
nsIContentSecurityPolicy
:
:
WEB_MANIFEST_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
:
return
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
:
return
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_WEBSOCKET
:
case
nsIContentPolicy
:
:
TYPE_XMLHTTPREQUEST
:
case
nsIContentPolicy
:
:
TYPE_BEACON
:
case
nsIContentPolicy
:
:
TYPE_PING
:
case
nsIContentPolicy
:
:
TYPE_FETCH
:
return
nsIContentSecurityPolicy
:
:
CONNECT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_OBJECT
:
case
nsIContentPolicy
:
:
TYPE_OBJECT_SUBREQUEST
:
return
nsIContentSecurityPolicy
:
:
OBJECT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_XBL
:
case
nsIContentPolicy
:
:
TYPE_DTD
:
case
nsIContentPolicy
:
:
TYPE_OTHER
:
return
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_DOCUMENT
:
case
nsIContentPolicy
:
:
TYPE_CSP_REPORT
:
return
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
;
default
:
MOZ_ASSERT
(
false
"
Can
not
map
nsContentPolicyType
to
CSPDirective
"
)
;
}
return
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
;
}
nsCSPHostSrc
*
CSP_CreateHostSrcFromSelfURI
(
nsIURI
*
aSelfURI
)
{
nsCString
host
;
aSelfURI
-
>
GetAsciiHost
(
host
)
;
nsCSPHostSrc
*
hostsrc
=
new
nsCSPHostSrc
(
NS_ConvertUTF8toUTF16
(
host
)
)
;
hostsrc
-
>
setGeneratedFromSelfKeyword
(
)
;
nsCString
scheme
;
aSelfURI
-
>
GetScheme
(
scheme
)
;
hostsrc
-
>
setScheme
(
NS_ConvertUTF8toUTF16
(
scheme
)
)
;
if
(
host
.
EqualsLiteral
(
"
"
)
)
{
hostsrc
-
>
setIsUniqueOrigin
(
)
;
return
hostsrc
;
}
int32_t
port
;
aSelfURI
-
>
GetPort
(
&
port
)
;
if
(
port
>
0
)
{
nsAutoString
portStr
;
portStr
.
AppendInt
(
port
)
;
hostsrc
-
>
setPort
(
portStr
)
;
}
return
hostsrc
;
}
bool
CSP_IsValidDirective
(
const
nsAString
&
aDir
)
{
uint32_t
numDirs
=
(
sizeof
(
CSPStrDirectives
)
/
sizeof
(
CSPStrDirectives
[
0
]
)
)
;
for
(
uint32_t
i
=
0
;
i
<
numDirs
;
i
+
+
)
{
if
(
aDir
.
LowerCaseEqualsASCII
(
CSPStrDirectives
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
bool
CSP_IsDirective
(
const
nsAString
&
aValue
CSPDirective
aDir
)
{
return
aValue
.
LowerCaseEqualsASCII
(
CSP_CSPDirectiveToString
(
aDir
)
)
;
}
bool
CSP_IsKeyword
(
const
nsAString
&
aValue
enum
CSPKeyword
aKey
)
{
return
aValue
.
LowerCaseEqualsASCII
(
CSP_EnumToUTF8Keyword
(
aKey
)
)
;
}
bool
CSP_IsQuotelessKeyword
(
const
nsAString
&
aKey
)
{
nsString
lowerKey
=
PromiseFlatString
(
aKey
)
;
ToLowerCase
(
lowerKey
)
;
nsAutoString
keyword
;
for
(
uint32_t
i
=
0
;
i
<
CSP_LAST_KEYWORD_VALUE
;
i
+
+
)
{
keyword
.
AssignASCII
(
gCSPUTF8Keywords
[
i
]
+
1
)
;
keyword
.
Trim
(
"
'
"
false
true
)
;
if
(
lowerKey
.
Equals
(
keyword
)
)
{
return
true
;
}
}
return
false
;
}
bool
permitsScheme
(
const
nsAString
&
aEnforcementScheme
nsIURI
*
aUri
bool
aReportOnly
bool
aUpgradeInsecure
bool
aFromSelfURI
)
{
nsAutoCString
scheme
;
nsresult
rv
=
aUri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
aEnforcementScheme
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
aEnforcementScheme
.
EqualsASCII
(
scheme
.
get
(
)
)
)
{
return
true
;
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
http
"
)
)
{
if
(
scheme
.
EqualsASCII
(
"
https
"
)
)
{
return
true
;
}
if
(
(
scheme
.
EqualsASCII
(
"
ws
"
)
|
|
scheme
.
EqualsASCII
(
"
wss
"
)
)
&
&
aFromSelfURI
)
{
return
true
;
}
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
https
"
)
)
{
if
(
scheme
.
EqualsLiteral
(
"
wss
"
)
&
&
aFromSelfURI
)
{
return
true
;
}
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
ws
"
)
&
&
scheme
.
EqualsASCII
(
"
wss
"
)
)
{
return
true
;
}
return
(
(
aUpgradeInsecure
&
&
!
aReportOnly
)
&
&
(
(
scheme
.
EqualsASCII
(
"
http
"
)
&
&
aEnforcementScheme
.
EqualsASCII
(
"
https
"
)
)
|
|
(
scheme
.
EqualsASCII
(
"
ws
"
)
&
&
aEnforcementScheme
.
EqualsASCII
(
"
wss
"
)
)
)
)
;
}
nsresult
CSP_AppendCSPFromHeader
(
nsIContentSecurityPolicy
*
aCsp
const
nsAString
&
aHeaderValue
bool
aReportOnly
)
{
NS_ENSURE_ARG
(
aCsp
)
;
nsresult
rv
=
NS_OK
;
nsCharSeparatedTokenizer
tokenizer
(
aHeaderValue
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsAString
&
policy
=
tokenizer
.
nextToken
(
)
;
rv
=
aCsp
-
>
AppendPolicy
(
policy
aReportOnly
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
{
CSPUTILSLOG
(
(
"
CSP
refined
with
policy
:
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
policy
)
.
get
(
)
)
)
;
}
}
return
NS_OK
;
}
nsCSPBaseSrc
:
:
nsCSPBaseSrc
(
)
:
mInvalidated
(
false
)
{
}
nsCSPBaseSrc
:
:
~
nsCSPBaseSrc
(
)
{
}
bool
nsCSPBaseSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPBaseSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
return
false
;
}
bool
nsCSPBaseSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPBaseSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
aKeyword
=
=
CSP_HASH
?
"
hash
"
:
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
return
false
;
}
nsCSPSchemeSrc
:
:
nsCSPSchemeSrc
(
const
nsAString
&
aScheme
)
:
mScheme
(
aScheme
)
{
ToLowerCase
(
mScheme
)
;
}
nsCSPSchemeSrc
:
:
~
nsCSPSchemeSrc
(
)
{
}
bool
nsCSPSchemeSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPSchemeSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
MOZ_ASSERT
(
(
!
mScheme
.
EqualsASCII
(
"
"
)
)
"
scheme
can
not
be
the
empty
string
"
)
;
if
(
mInvalidated
)
{
return
false
;
}
return
permitsScheme
(
mScheme
aUri
aReportOnly
aUpgradeInsecure
false
)
;
}
bool
nsCSPSchemeSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitSchemeSrc
(
*
this
)
;
}
void
nsCSPSchemeSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
mScheme
)
;
outStr
.
AppendASCII
(
"
:
"
)
;
}
nsCSPHostSrc
:
:
nsCSPHostSrc
(
const
nsAString
&
aHost
)
:
mHost
(
aHost
)
mGeneratedFromSelfKeyword
(
false
)
mIsUniqueOrigin
(
false
)
mWithinFrameAncstorsDir
(
false
)
{
ToLowerCase
(
mHost
)
;
}
nsCSPHostSrc
:
:
~
nsCSPHostSrc
(
)
{
}
bool
permitsPort
(
const
nsAString
&
aEnforcementScheme
const
nsAString
&
aEnforcementPort
nsIURI
*
aResourceURI
)
{
if
(
aEnforcementPort
.
EqualsASCII
(
"
*
"
)
)
{
return
true
;
}
int32_t
resourcePort
;
nsresult
rv
=
aResourceURI
-
>
GetPort
(
&
resourcePort
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
resourcePort
=
=
DEFAULT_PORT
&
&
aEnforcementPort
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
resourcePort
=
=
DEFAULT_PORT
)
{
nsAutoCString
resourceScheme
;
rv
=
aResourceURI
-
>
GetScheme
(
resourceScheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
resourcePort
=
NS_GetDefaultPort
(
resourceScheme
.
get
(
)
)
;
}
nsString
resourcePortStr
;
resourcePortStr
.
AppendInt
(
resourcePort
)
;
if
(
aEnforcementPort
.
Equals
(
resourcePortStr
)
)
{
return
true
;
}
nsString
enforcementPort
(
aEnforcementPort
)
;
if
(
enforcementPort
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
aEnforcementScheme
.
IsEmpty
(
)
"
need
a
scheme
to
query
default
port
"
)
;
int32_t
defaultEnforcementPort
=
NS_GetDefaultPort
(
NS_ConvertUTF16toUTF8
(
aEnforcementScheme
)
.
get
(
)
)
;
enforcementPort
.
Truncate
(
)
;
enforcementPort
.
AppendInt
(
defaultEnforcementPort
)
;
}
if
(
enforcementPort
.
Equals
(
resourcePortStr
)
)
{
return
true
;
}
if
(
enforcementPort
.
EqualsLiteral
(
"
80
"
)
&
&
resourcePortStr
.
EqualsLiteral
(
"
443
"
)
)
{
return
true
;
}
return
false
;
}
bool
nsCSPHostSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPHostSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
if
(
mInvalidated
|
|
mIsUniqueOrigin
)
{
return
false
;
}
if
(
!
permitsScheme
(
mScheme
aUri
aReportOnly
aUpgradeInsecure
mGeneratedFromSelfKeyword
)
)
{
return
false
;
}
NS_ASSERTION
(
(
!
mHost
.
IsEmpty
(
)
)
"
host
can
not
be
the
empty
string
"
)
;
if
(
mHost
.
EqualsASCII
(
"
*
"
)
)
{
bool
isBlobScheme
=
(
NS_SUCCEEDED
(
aUri
-
>
SchemeIs
(
"
blob
"
&
isBlobScheme
)
)
&
&
isBlobScheme
)
;
bool
isDataScheme
=
(
NS_SUCCEEDED
(
aUri
-
>
SchemeIs
(
"
data
"
&
isDataScheme
)
)
&
&
isDataScheme
)
;
bool
isFileScheme
=
(
NS_SUCCEEDED
(
aUri
-
>
SchemeIs
(
"
filesystem
"
&
isFileScheme
)
)
&
&
isFileScheme
)
;
if
(
isBlobScheme
|
|
isDataScheme
|
|
isFileScheme
)
{
return
false
;
}
return
true
;
}
nsAutoCString
uriHost
;
nsresult
rv
=
aUri
-
>
GetAsciiHost
(
uriHost
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsString
decodedUriHost
;
CSP_PercentDecodeStr
(
NS_ConvertUTF8toUTF16
(
uriHost
)
decodedUriHost
)
;
if
(
mHost
.
First
(
)
=
=
'
*
'
)
{
NS_ASSERTION
(
mHost
[
1
]
=
=
'
.
'
"
Second
character
needs
to
be
'
.
'
whenever
host
starts
with
'
*
'
"
)
;
nsString
wildCardHost
=
mHost
;
wildCardHost
=
Substring
(
wildCardHost
1
wildCardHost
.
Length
(
)
-
1
)
;
if
(
!
StringEndsWith
(
decodedUriHost
wildCardHost
)
)
{
return
false
;
}
}
else
if
(
!
mHost
.
Equals
(
decodedUriHost
)
)
{
return
false
;
}
if
(
!
permitsPort
(
mScheme
mPort
aUri
)
)
{
return
false
;
}
if
(
!
aWasRedirected
&
&
!
mPath
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aUri
)
;
if
(
!
url
)
{
NS_ASSERTION
(
false
"
can
'
t
QI
into
nsIURI
"
)
;
return
false
;
}
nsAutoCString
uriPath
;
rv
=
url
-
>
GetFilePath
(
uriPath
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
mWithinFrameAncstorsDir
)
{
return
true
;
}
nsString
decodedUriPath
;
CSP_PercentDecodeStr
(
NS_ConvertUTF8toUTF16
(
uriPath
)
decodedUriPath
)
;
if
(
mPath
.
Last
(
)
=
=
'
/
'
)
{
if
(
!
StringBeginsWith
(
decodedUriPath
mPath
)
)
{
return
false
;
}
}
else
{
if
(
!
mPath
.
Equals
(
decodedUriPath
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
nsCSPHostSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitHostSrc
(
*
this
)
;
}
void
nsCSPHostSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
if
(
mHost
.
EqualsASCII
(
"
*
"
)
&
&
mScheme
.
IsEmpty
(
)
&
&
mPort
.
IsEmpty
(
)
)
{
outStr
.
Append
(
mHost
)
;
return
;
}
outStr
.
Append
(
mScheme
)
;
outStr
.
AppendASCII
(
"
:
/
/
"
)
;
outStr
.
Append
(
mHost
)
;
if
(
!
mPort
.
IsEmpty
(
)
)
{
outStr
.
AppendASCII
(
"
:
"
)
;
outStr
.
Append
(
mPort
)
;
}
outStr
.
Append
(
mPath
)
;
}
void
nsCSPHostSrc
:
:
setScheme
(
const
nsAString
&
aScheme
)
{
mScheme
=
aScheme
;
ToLowerCase
(
mScheme
)
;
}
void
nsCSPHostSrc
:
:
setPort
(
const
nsAString
&
aPort
)
{
mPort
=
aPort
;
}
void
nsCSPHostSrc
:
:
appendPath
(
const
nsAString
&
aPath
)
{
mPath
.
Append
(
aPath
)
;
}
nsCSPKeywordSrc
:
:
nsCSPKeywordSrc
(
enum
CSPKeyword
aKeyword
)
:
mKeyword
(
aKeyword
)
{
NS_ASSERTION
(
(
aKeyword
!
=
CSP_SELF
)
"
'
self
'
should
have
been
replaced
in
the
parser
"
)
;
}
nsCSPKeywordSrc
:
:
~
nsCSPKeywordSrc
(
)
{
}
bool
nsCSPKeywordSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
return
(
(
mKeyword
=
=
CSP_STRICT_DYNAMIC
)
&
&
!
aParserCreated
)
;
}
bool
nsCSPKeywordSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPKeywordSrc
:
:
allows
aKeyWord
:
%
s
aHashOrNonce
:
%
s
mInvalidated
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
mInvalidated
?
"
yes
"
:
"
false
"
)
)
;
if
(
mInvalidated
)
{
MOZ_ASSERT
(
mKeyword
=
=
CSP_UNSAFE_INLINE
"
should
only
invalidate
unsafe
-
inline
"
)
;
return
false
;
}
return
(
(
mKeyword
=
=
aKeyword
)
|
|
(
(
mKeyword
=
=
CSP_STRICT_DYNAMIC
)
&
&
!
aParserCreated
)
)
;
}
bool
nsCSPKeywordSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitKeywordSrc
(
*
this
)
;
}
void
nsCSPKeywordSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
CSP_EnumToUTF16Keyword
(
mKeyword
)
)
;
}
nsCSPNonceSrc
:
:
nsCSPNonceSrc
(
const
nsAString
&
aNonce
)
:
mNonce
(
aNonce
)
{
}
nsCSPNonceSrc
:
:
~
nsCSPNonceSrc
(
)
{
}
bool
nsCSPNonceSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPNonceSrc
:
:
permits
aUri
:
%
s
aNonce
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aNonce
)
.
get
(
)
)
)
;
}
return
mNonce
.
Equals
(
aNonce
)
;
}
bool
nsCSPNonceSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPNonceSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
if
(
aKeyword
!
=
CSP_NONCE
)
{
return
false
;
}
return
mNonce
.
Equals
(
aHashOrNonce
)
;
}
bool
nsCSPNonceSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitNonceSrc
(
*
this
)
;
}
void
nsCSPNonceSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
CSP_EnumToUTF16Keyword
(
CSP_NONCE
)
)
;
outStr
.
Append
(
mNonce
)
;
outStr
.
AppendASCII
(
"
'
"
)
;
}
nsCSPHashSrc
:
:
nsCSPHashSrc
(
const
nsAString
&
aAlgo
const
nsAString
&
aHash
)
:
mAlgorithm
(
aAlgo
)
mHash
(
aHash
)
{
ToLowerCase
(
mAlgorithm
)
;
}
nsCSPHashSrc
:
:
~
nsCSPHashSrc
(
)
{
}
bool
nsCSPHashSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPHashSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
if
(
aKeyword
!
=
CSP_HASH
)
{
return
false
;
}
NS_ConvertUTF16toUTF8
utf8_hash
(
aHashOrNonce
)
;
nsresult
rv
;
nsCOMPtr
<
nsICryptoHash
>
hasher
;
hasher
=
do_CreateInstance
(
"
mozilla
.
org
/
security
/
hash
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
hasher
-
>
InitWithString
(
NS_ConvertUTF16toUTF8
(
mAlgorithm
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
hasher
-
>
Update
(
(
uint8_t
*
)
utf8_hash
.
get
(
)
utf8_hash
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsAutoCString
hash
;
rv
=
hasher
-
>
Finish
(
true
hash
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
NS_ConvertUTF16toUTF8
(
mHash
)
.
Equals
(
hash
)
;
}
bool
nsCSPHashSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitHashSrc
(
*
this
)
;
}
void
nsCSPHashSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
"
'
"
)
;
outStr
.
Append
(
mAlgorithm
)
;
outStr
.
AppendASCII
(
"
-
"
)
;
outStr
.
Append
(
mHash
)
;
outStr
.
AppendASCII
(
"
'
"
)
;
}
nsCSPReportURI
:
:
nsCSPReportURI
(
nsIURI
*
aURI
)
:
mReportURI
(
aURI
)
{
}
nsCSPReportURI
:
:
~
nsCSPReportURI
(
)
{
}
bool
nsCSPReportURI
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
false
;
}
void
nsCSPReportURI
:
:
toString
(
nsAString
&
outStr
)
const
{
nsAutoCString
spec
;
nsresult
rv
=
mReportURI
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
outStr
.
AppendASCII
(
spec
.
get
(
)
)
;
}
nsCSPSandboxFlags
:
:
nsCSPSandboxFlags
(
const
nsAString
&
aFlags
)
:
mFlags
(
aFlags
)
{
ToLowerCase
(
mFlags
)
;
}
nsCSPSandboxFlags
:
:
~
nsCSPSandboxFlags
(
)
{
}
bool
nsCSPSandboxFlags
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
false
;
}
void
nsCSPSandboxFlags
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
mFlags
)
;
}
nsCSPDirective
:
:
nsCSPDirective
(
CSPDirective
aDirective
)
{
mDirective
=
aDirective
;
}
nsCSPDirective
:
:
~
nsCSPDirective
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
delete
mSrcs
[
i
]
;
}
}
bool
nsCSPDirective
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPDirective
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
mSrcs
[
i
]
-
>
permits
(
aUri
aNonce
aWasRedirected
aReportOnly
aUpgradeInsecure
aParserCreated
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSPDirective
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPDirective
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
mSrcs
[
i
]
-
>
allows
(
aKeyword
aHashOrNonce
aParserCreated
)
)
{
return
true
;
}
}
return
false
;
}
void
nsCSPDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
mDirective
)
)
;
outStr
.
AppendASCII
(
"
"
)
;
uint32_t
length
=
mSrcs
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
mSrcs
[
i
]
-
>
toString
(
outStr
)
;
if
(
i
!
=
(
length
-
1
)
)
{
outStr
.
AppendASCII
(
"
"
)
;
}
}
}
void
nsCSPDirective
:
:
toDomCSPStruct
(
mozilla
:
:
dom
:
:
CSP
&
outCSP
)
const
{
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
srcs
;
nsString
src
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
src
.
Truncate
(
)
;
mSrcs
[
i
]
-
>
toString
(
src
)
;
srcs
.
AppendElement
(
src
mozilla
:
:
fallible
)
;
}
switch
(
mDirective
)
{
case
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
:
outCSP
.
mDefault_src
.
Construct
(
)
;
outCSP
.
mDefault_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
:
outCSP
.
mScript_src
.
Construct
(
)
;
outCSP
.
mScript_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
OBJECT_SRC_DIRECTIVE
:
outCSP
.
mObject_src
.
Construct
(
)
;
outCSP
.
mObject_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
STYLE_SRC_DIRECTIVE
:
outCSP
.
mStyle_src
.
Construct
(
)
;
outCSP
.
mStyle_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
IMG_SRC_DIRECTIVE
:
outCSP
.
mImg_src
.
Construct
(
)
;
outCSP
.
mImg_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
MEDIA_SRC_DIRECTIVE
:
outCSP
.
mMedia_src
.
Construct
(
)
;
outCSP
.
mMedia_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
:
outCSP
.
mFrame_src
.
Construct
(
)
;
outCSP
.
mFrame_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FONT_SRC_DIRECTIVE
:
outCSP
.
mFont_src
.
Construct
(
)
;
outCSP
.
mFont_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
CONNECT_SRC_DIRECTIVE
:
outCSP
.
mConnect_src
.
Construct
(
)
;
outCSP
.
mConnect_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
:
outCSP
.
mReport_uri
.
Construct
(
)
;
outCSP
.
mReport_uri
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
:
outCSP
.
mFrame_ancestors
.
Construct
(
)
;
outCSP
.
mFrame_ancestors
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
WEB_MANIFEST_SRC_DIRECTIVE
:
outCSP
.
mManifest_src
.
Construct
(
)
;
outCSP
.
mManifest_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
BASE_URI_DIRECTIVE
:
outCSP
.
mBase_uri
.
Construct
(
)
;
outCSP
.
mBase_uri
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FORM_ACTION_DIRECTIVE
:
outCSP
.
mForm_action
.
Construct
(
)
;
outCSP
.
mForm_action
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
:
outCSP
.
mBlock_all_mixed_content
.
Construct
(
)
;
return
;
case
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
:
outCSP
.
mUpgrade_insecure_requests
.
Construct
(
)
;
return
;
case
nsIContentSecurityPolicy
:
:
CHILD_SRC_DIRECTIVE
:
outCSP
.
mChild_src
.
Construct
(
)
;
outCSP
.
mChild_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
:
outCSP
.
mSandbox
.
Construct
(
)
;
outCSP
.
mSandbox
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
:
outCSP
.
mWorker_src
.
Construct
(
)
;
outCSP
.
mWorker_src
.
Value
(
)
=
mozilla
:
:
Move
(
srcs
)
;
return
;
default
:
NS_ASSERTION
(
false
"
cannot
find
directive
to
convert
CSP
to
JSON
"
)
;
}
}
bool
nsCSPDirective
:
:
restrictsContentType
(
nsContentPolicyType
aContentType
)
const
{
if
(
isDefaultDirective
(
)
)
{
return
false
;
}
return
mDirective
=
=
CSP_ContentTypeToDirective
(
aContentType
)
;
}
void
nsCSPDirective
:
:
getReportURIs
(
nsTArray
<
nsString
>
&
outReportURIs
)
const
{
NS_ASSERTION
(
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
"
not
a
report
-
uri
directive
"
)
;
nsString
tmpReportURI
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
tmpReportURI
.
Truncate
(
)
;
mSrcs
[
i
]
-
>
toString
(
tmpReportURI
)
;
outReportURIs
.
AppendElement
(
tmpReportURI
)
;
}
}
bool
nsCSPDirective
:
:
visitSrcs
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
!
mSrcs
[
i
]
-
>
visit
(
aVisitor
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsCSPDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
return
(
mDirective
=
=
aDirective
)
;
}
nsCSPChildSrcDirective
:
:
nsCSPChildSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
mRestrictFrames
(
false
)
mRestrictWorkers
(
false
)
{
}
nsCSPChildSrcDirective
:
:
~
nsCSPChildSrcDirective
(
)
{
}
bool
nsCSPChildSrcDirective
:
:
restrictsContentType
(
nsContentPolicyType
aContentType
)
const
{
if
(
aContentType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
return
mRestrictFrames
;
}
if
(
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
)
{
return
mRestrictWorkers
;
}
return
false
;
}
bool
nsCSPChildSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
)
{
return
mRestrictFrames
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
)
{
return
mRestrictWorkers
;
}
return
(
mDirective
=
=
aDirective
)
;
}
nsCSPScriptSrcDirective
:
:
nsCSPScriptSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
mRestrictWorkers
(
false
)
{
}
nsCSPScriptSrcDirective
:
:
~
nsCSPScriptSrcDirective
(
)
{
}
bool
nsCSPScriptSrcDirective
:
:
restrictsContentType
(
nsContentPolicyType
aContentType
)
const
{
if
(
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
|
|
aContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
)
{
return
mRestrictWorkers
;
}
return
mDirective
=
=
CSP_ContentTypeToDirective
(
aContentType
)
;
}
bool
nsCSPScriptSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
)
{
return
mRestrictWorkers
;
}
return
(
mDirective
=
=
aDirective
)
;
}
nsBlockAllMixedContentDirective
:
:
nsBlockAllMixedContentDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsBlockAllMixedContentDirective
:
:
~
nsBlockAllMixedContentDirective
(
)
{
}
void
nsBlockAllMixedContentDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
)
;
}
nsUpgradeInsecureDirective
:
:
nsUpgradeInsecureDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsUpgradeInsecureDirective
:
:
~
nsUpgradeInsecureDirective
(
)
{
}
void
nsUpgradeInsecureDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
)
;
}
nsRequireSRIForDirective
:
:
nsRequireSRIForDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsRequireSRIForDirective
:
:
~
nsRequireSRIForDirective
(
)
{
}
void
nsRequireSRIForDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
REQUIRE_SRI_FOR
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mTypes
.
Length
(
)
;
i
+
+
)
{
if
(
mTypes
[
i
]
=
=
nsIContentPolicy
:
:
TYPE_SCRIPT
)
{
outStr
.
AppendASCII
(
"
script
"
)
;
}
else
if
(
mTypes
[
i
]
=
=
nsIContentPolicy
:
:
TYPE_STYLESHEET
)
{
outStr
.
AppendASCII
(
"
style
"
)
;
}
}
}
bool
nsRequireSRIForDirective
:
:
hasType
(
nsContentPolicyType
aType
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mTypes
.
Length
(
)
;
i
+
+
)
{
if
(
mTypes
[
i
]
=
=
aType
)
{
return
true
;
}
}
return
false
;
}
bool
nsRequireSRIForDirective
:
:
restrictsContentType
(
const
nsContentPolicyType
aType
)
const
{
return
this
-
>
hasType
(
aType
)
;
}
bool
nsRequireSRIForDirective
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
return
(
aKeyword
!
=
CSP_REQUIRE_SRI_FOR
)
;
}
nsCSPPolicy
:
:
nsCSPPolicy
(
)
:
mUpgradeInsecDir
(
nullptr
)
mReportOnly
(
false
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
nsCSPPolicy
"
)
)
;
}
nsCSPPolicy
:
:
~
nsCSPPolicy
(
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
~
nsCSPPolicy
"
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
delete
mDirectives
[
i
]
;
}
}
bool
nsCSPPolicy
:
:
permits
(
CSPDirective
aDir
nsIURI
*
aUri
bool
aSpecific
)
const
{
nsString
outp
;
return
this
-
>
permits
(
aDir
aUri
EmptyString
(
)
false
aSpecific
false
outp
)
;
}
bool
nsCSPPolicy
:
:
permits
(
CSPDirective
aDir
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aSpecific
bool
aParserCreated
nsAString
&
outViolatedDirective
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
permits
aUri
:
%
s
aDir
:
%
d
aSpecific
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
aDir
aSpecific
?
"
true
"
:
"
false
"
)
)
;
}
NS_ASSERTION
(
aUri
"
permits
needs
an
uri
to
perform
the
check
!
"
)
;
outViolatedDirective
.
Truncate
(
)
;
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
if
(
!
mDirectives
[
i
]
-
>
permits
(
aUri
aNonce
aWasRedirected
mReportOnly
mUpgradeInsecDir
aParserCreated
)
)
{
mDirectives
[
i
]
-
>
toString
(
outViolatedDirective
)
;
return
false
;
}
return
true
;
}
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
}
}
if
(
!
aSpecific
&
&
defaultDir
)
{
if
(
!
defaultDir
-
>
permits
(
aUri
aNonce
aWasRedirected
mReportOnly
mUpgradeInsecDir
aParserCreated
)
)
{
defaultDir
-
>
toString
(
outViolatedDirective
)
;
return
false
;
}
return
true
;
}
return
true
;
}
bool
nsCSPPolicy
:
:
allows
(
nsContentPolicyType
aContentType
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
restrictsContentType
(
aContentType
)
)
{
if
(
mDirectives
[
i
]
-
>
allows
(
aKeyword
aHashOrNonce
aParserCreated
)
)
{
return
true
;
}
return
false
;
}
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
}
}
if
(
aKeyword
=
=
CSP_NONCE
|
|
aKeyword
=
=
CSP_HASH
)
{
if
(
!
defaultDir
)
{
return
true
;
}
return
false
;
}
if
(
defaultDir
)
{
return
defaultDir
-
>
allows
(
aKeyword
aHashOrNonce
aParserCreated
)
;
}
return
true
;
}
bool
nsCSPPolicy
:
:
allows
(
nsContentPolicyType
aContentType
enum
CSPKeyword
aKeyword
)
const
{
return
allows
(
aContentType
aKeyword
NS_LITERAL_STRING
(
"
"
)
false
)
;
}
void
nsCSPPolicy
:
:
toString
(
nsAString
&
outStr
)
const
{
uint32_t
length
=
mDirectives
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
REFERRER_DIRECTIVE
)
)
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
REFERRER_DIRECTIVE
)
)
;
outStr
.
AppendASCII
(
"
"
)
;
outStr
.
Append
(
mReferrerPolicy
)
;
}
else
{
mDirectives
[
i
]
-
>
toString
(
outStr
)
;
}
if
(
i
!
=
(
length
-
1
)
)
{
outStr
.
AppendASCII
(
"
;
"
)
;
}
}
}
void
nsCSPPolicy
:
:
toDomCSPStruct
(
mozilla
:
:
dom
:
:
CSP
&
outCSP
)
const
{
outCSP
.
mReport_only
=
mReportOnly
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
+
+
i
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
REFERRER_DIRECTIVE
)
)
{
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
srcs
;
srcs
.
AppendElement
(
mReferrerPolicy
mozilla
:
:
fallible
)
;
outCSP
.
mReferrer
.
Construct
(
)
;
outCSP
.
mReferrer
.
Value
(
)
=
srcs
;
}
else
{
mDirectives
[
i
]
-
>
toDomCSPStruct
(
outCSP
)
;
}
}
}
bool
nsCSPPolicy
:
:
hasDirective
(
CSPDirective
aDir
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
return
true
;
}
}
return
false
;
}
void
nsCSPPolicy
:
:
getDirectiveStringForContentType
(
nsContentPolicyType
aContentType
nsAString
&
outDirective
)
const
{
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
restrictsContentType
(
aContentType
)
)
{
mDirectives
[
i
]
-
>
toString
(
outDirective
)
;
return
;
}
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
}
}
if
(
defaultDir
)
{
defaultDir
-
>
toString
(
outDirective
)
;
return
;
}
NS_ASSERTION
(
false
"
Can
not
query
directive
string
for
contentType
!
"
)
;
outDirective
.
AppendASCII
(
"
couldNotQueryViolatedDirective
"
)
;
}
void
nsCSPPolicy
:
:
getDirectiveAsString
(
CSPDirective
aDir
nsAString
&
outDirective
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
mDirectives
[
i
]
-
>
toString
(
outDirective
)
;
return
;
}
}
}
uint32_t
nsCSPPolicy
:
:
getSandboxFlags
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
)
)
{
nsAutoString
flags
;
mDirectives
[
i
]
-
>
toString
(
flags
)
;
if
(
flags
.
IsEmpty
(
)
)
{
return
SANDBOX_ALL_FLAGS
;
}
nsAttrValue
attr
;
attr
.
ParseAtomArray
(
flags
)
;
return
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
&
attr
)
;
}
}
return
SANDBOXED_NONE
;
}
void
nsCSPPolicy
:
:
getReportURIs
(
nsTArray
<
nsString
>
&
outReportURIs
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
)
{
mDirectives
[
i
]
-
>
getReportURIs
(
outReportURIs
)
;
return
;
}
}
}
bool
nsCSPPolicy
:
:
visitDirectiveSrcs
(
CSPDirective
aDir
nsCSPSrcVisitor
*
aVisitor
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
return
mDirectives
[
i
]
-
>
visitSrcs
(
aVisitor
)
;
}
}
return
false
;
}
bool
nsCSPPolicy
:
:
requireSRIForType
(
nsContentPolicyType
aContentType
)
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
REQUIRE_SRI_FOR
)
)
{
return
static_cast
<
nsRequireSRIForDirective
*
>
(
mDirectives
[
i
]
)
-
>
hasType
(
aContentType
)
;
}
}
return
false
;
}
