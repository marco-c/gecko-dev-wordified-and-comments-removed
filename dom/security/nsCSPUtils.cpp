#
include
"
nsAttrValue
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSPUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsCSPParser
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
CSPDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
define
DEFAULT_PORT
-
1
static
mozilla
:
:
LogModule
*
GetCspUtilsLog
(
)
{
static
mozilla
:
:
LazyLogModule
gCspUtilsPRLog
(
"
CSPUtils
"
)
;
return
gCspUtilsPRLog
;
}
#
define
CSPUTILSLOG
(
args
)
\
MOZ_LOG
(
GetCspUtilsLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
CSPUTILSLOGENABLED
(
)
\
MOZ_LOG_TEST
(
GetCspUtilsLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
)
void
CSP_PercentDecodeStr
(
const
nsAString
&
aEncStr
nsAString
&
outDecStr
)
{
outDecStr
.
Truncate
(
)
;
struct
local
{
static
inline
char16_t
convertHexDig
(
char16_t
aHexDig
)
{
if
(
isNumberToken
(
aHexDig
)
)
{
return
aHexDig
-
'
0
'
;
}
if
(
aHexDig
>
=
'
A
'
&
&
aHexDig
<
=
'
F
'
)
{
return
aHexDig
-
'
A
'
+
10
;
}
return
aHexDig
-
'
a
'
+
10
;
}
}
;
const
char16_t
*
cur
*
end
*
hexDig1
*
hexDig2
;
cur
=
aEncStr
.
BeginReading
(
)
;
end
=
aEncStr
.
EndReading
(
)
;
while
(
cur
!
=
end
)
{
if
(
*
cur
!
=
PERCENT_SIGN
)
{
outDecStr
.
Append
(
*
cur
)
;
cur
+
+
;
continue
;
}
hexDig1
=
cur
+
1
;
hexDig2
=
cur
+
2
;
if
(
hexDig1
=
=
end
|
|
hexDig2
=
=
end
|
|
!
isValidHexDig
(
*
hexDig1
)
|
|
!
isValidHexDig
(
*
hexDig2
)
)
{
outDecStr
.
Append
(
PERCENT_SIGN
)
;
cur
+
+
;
continue
;
}
char16_t
decChar
=
(
local
:
:
convertHexDig
(
*
hexDig1
)
<
<
4
)
+
local
:
:
convertHexDig
(
*
hexDig2
)
;
outDecStr
.
Append
(
decChar
)
;
cur
=
+
+
hexDig2
;
}
}
bool
CSP_ShouldResponseInheritCSP
(
nsIChannel
*
aChannel
)
{
if
(
!
aChannel
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
isAbout
=
uri
-
>
SchemeIs
(
"
about
"
)
;
if
(
isAbout
)
{
nsAutoCString
aboutSpec
;
rv
=
uri
-
>
GetSpec
(
aboutSpec
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
StringBeginsWith
(
aboutSpec
"
about
:
blank
"
_ns
)
|
|
StringBeginsWith
(
aboutSpec
"
about
:
srcdoc
"
_ns
)
)
{
return
true
;
}
}
return
uri
-
>
SchemeIs
(
"
blob
"
)
|
|
uri
-
>
SchemeIs
(
"
data
"
)
|
|
uri
-
>
SchemeIs
(
"
filesystem
"
)
|
|
uri
-
>
SchemeIs
(
"
javascript
"
)
;
}
void
CSP_ApplyMetaCSPToDoc
(
mozilla
:
:
dom
:
:
Document
&
aDoc
const
nsAString
&
aPolicyStr
)
{
if
(
aDoc
.
IsLoadedAsData
(
)
)
{
return
;
}
nsAutoString
policyStr
(
nsContentUtils
:
:
TrimWhitespace
<
nsContentUtils
:
:
IsHTMLWhitespace
>
(
aPolicyStr
)
)
;
if
(
policyStr
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDoc
.
GetCsp
(
)
;
if
(
!
csp
)
{
MOZ_ASSERT
(
false
"
how
come
there
is
no
CSP
"
)
;
return
;
}
nsresult
rv
=
csp
-
>
AppendPolicy
(
policyStr
false
true
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
nsPIDOMWindowInner
*
inner
=
aDoc
.
GetInnerWindow
(
)
)
{
inner
-
>
SetCsp
(
csp
)
;
}
aDoc
.
ApplySettingsFromCSP
(
false
)
;
}
void
CSP_GetLocalizedStr
(
const
char
*
aName
const
nsTArray
<
nsString
>
&
aParams
nsAString
&
outResult
)
{
nsCOMPtr
<
nsIStringBundle
>
keyStringBundle
;
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
components
:
:
StringBundle
:
:
Service
(
)
;
NS_ASSERTION
(
stringBundleService
"
String
bundle
service
must
be
present
!
"
)
;
stringBundleService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
security
/
csp
.
properties
"
getter_AddRefs
(
keyStringBundle
)
)
;
NS_ASSERTION
(
keyStringBundle
"
Key
string
bundle
must
be
available
!
"
)
;
if
(
!
keyStringBundle
)
{
return
;
}
keyStringBundle
-
>
FormatStringFromName
(
aName
aParams
outResult
)
;
}
void
CSP_LogStrMessage
(
const
nsAString
&
aMsg
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
!
console
)
{
return
;
}
nsString
msg
(
aMsg
)
;
console
-
>
LogStringMessage
(
msg
.
get
(
)
)
;
}
void
CSP_LogMessage
(
const
nsAString
&
aMessage
const
nsAString
&
aSourceName
const
nsAString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
const
nsACString
&
aCategory
uint64_t
aInnerWindowID
bool
aFromPrivateWindow
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
)
;
nsCOMPtr
<
nsIScriptError
>
error
(
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
)
;
if
(
!
console
|
|
!
error
)
{
return
;
}
nsString
cspMsg
;
cspMsg
.
AppendLiteral
(
u
"
Content
Security
Policy
:
"
)
;
cspMsg
.
Append
(
aMessage
)
;
if
(
!
aSourceLine
.
IsEmpty
(
)
)
{
cspMsg
.
AppendLiteral
(
u
"
Source
:
"
)
;
cspMsg
.
Append
(
aSourceLine
)
;
cspMsg
.
AppendLiteral
(
u
"
.
"
)
;
}
nsCString
category
(
"
CSP_
"
)
;
category
.
Append
(
aCategory
)
;
nsresult
rv
;
if
(
aInnerWindowID
>
0
)
{
rv
=
error
-
>
InitWithWindowID
(
cspMsg
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aFlags
category
aInnerWindowID
)
;
}
else
{
rv
=
error
-
>
Init
(
cspMsg
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aFlags
category
aFromPrivateWindow
true
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
console
-
>
LogMessage
(
error
)
;
}
void
CSP_LogLocalizedStr
(
const
char
*
aName
const
nsTArray
<
nsString
>
&
aParams
const
nsAString
&
aSourceName
const
nsAString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
uint32_t
aFlags
const
nsACString
&
aCategory
uint64_t
aInnerWindowID
bool
aFromPrivateWindow
)
{
nsAutoString
logMsg
;
CSP_GetLocalizedStr
(
aName
aParams
logMsg
)
;
CSP_LogMessage
(
logMsg
aSourceName
aSourceLine
aLineNumber
aColumnNumber
aFlags
aCategory
aInnerWindowID
aFromPrivateWindow
)
;
}
CSPDirective
CSP_ContentTypeToDirective
(
nsContentPolicyType
aType
)
{
switch
(
aType
)
{
case
nsIContentPolicy
:
:
TYPE_IMAGE
:
case
nsIContentPolicy
:
:
TYPE_IMAGESET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
:
return
nsIContentSecurityPolicy
:
:
IMG_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_XSLT
:
case
nsIContentPolicy
:
:
TYPE_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE_PRELOAD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIOWORKLET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_PAINTWORKLET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_CHROMEUTILS_COMPILED_SCRIPT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME_MESSAGEMANAGER_SCRIPT
:
return
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_STYLESHEET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
:
return
nsIContentSecurityPolicy
:
:
STYLE_SRC_ELEM_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_FONT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FONT_PRELOAD
:
return
nsIContentSecurityPolicy
:
:
FONT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_MEDIA
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_TRACK
:
return
nsIContentSecurityPolicy
:
:
MEDIA_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_WEB_MANIFEST
:
return
nsIContentSecurityPolicy
:
:
WEB_MANIFEST_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
:
return
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
:
return
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_WEBSOCKET
:
case
nsIContentPolicy
:
:
TYPE_XMLHTTPREQUEST
:
case
nsIContentPolicy
:
:
TYPE_BEACON
:
case
nsIContentPolicy
:
:
TYPE_PING
:
case
nsIContentPolicy
:
:
TYPE_FETCH
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EVENTSOURCE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FETCH_PRELOAD
:
return
nsIContentSecurityPolicy
:
:
CONNECT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_OBJECT
:
case
nsIContentPolicy
:
:
TYPE_OBJECT_SUBREQUEST
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EMBED
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_OBJECT
:
return
nsIContentSecurityPolicy
:
:
OBJECT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_DTD
:
case
nsIContentPolicy
:
:
TYPE_OTHER
:
case
nsIContentPolicy
:
:
TYPE_SPECULATIVE
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_DTD
:
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FORCE_ALLOWED_DTD
:
return
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_PROXIED_WEBRTC_MEDIA
:
case
nsIContentPolicy
:
:
TYPE_DOCUMENT
:
case
nsIContentPolicy
:
:
TYPE_CSP_REPORT
:
return
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_SAVEAS_DOWNLOAD
:
case
nsIContentPolicy
:
:
TYPE_UA_FONT
:
return
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
;
case
nsIContentPolicy
:
:
TYPE_INVALID
:
MOZ_ASSERT
(
false
"
Can
not
map
nsContentPolicyType
to
CSPDirective
"
)
;
}
return
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
;
}
nsCSPHostSrc
*
CSP_CreateHostSrcFromSelfURI
(
nsIURI
*
aSelfURI
)
{
nsCString
host
;
aSelfURI
-
>
GetAsciiHost
(
host
)
;
nsCSPHostSrc
*
hostsrc
=
new
nsCSPHostSrc
(
NS_ConvertUTF8toUTF16
(
host
)
)
;
hostsrc
-
>
setGeneratedFromSelfKeyword
(
)
;
nsCString
scheme
;
aSelfURI
-
>
GetScheme
(
scheme
)
;
hostsrc
-
>
setScheme
(
NS_ConvertUTF8toUTF16
(
scheme
)
)
;
if
(
host
.
EqualsLiteral
(
"
"
)
)
{
hostsrc
-
>
setIsUniqueOrigin
(
)
;
return
hostsrc
;
}
int32_t
port
;
aSelfURI
-
>
GetPort
(
&
port
)
;
if
(
port
>
0
)
{
nsAutoString
portStr
;
portStr
.
AppendInt
(
port
)
;
hostsrc
-
>
setPort
(
portStr
)
;
}
return
hostsrc
;
}
bool
CSP_IsEmptyDirective
(
const
nsAString
&
aValue
const
nsAString
&
aDir
)
{
return
(
aDir
.
Length
(
)
=
=
0
&
&
aValue
.
Length
(
)
=
=
0
)
;
}
bool
CSP_IsDirective
(
const
nsAString
&
aValue
CSPDirective
aDir
)
{
return
aValue
.
LowerCaseEqualsASCII
(
CSP_CSPDirectiveToString
(
aDir
)
)
;
}
bool
CSP_IsKeyword
(
const
nsAString
&
aValue
enum
CSPKeyword
aKey
)
{
return
aValue
.
LowerCaseEqualsASCII
(
CSP_EnumToUTF8Keyword
(
aKey
)
)
;
}
bool
CSP_IsQuotelessKeyword
(
const
nsAString
&
aKey
)
{
nsString
lowerKey
;
ToLowerCase
(
aKey
lowerKey
)
;
nsAutoString
keyword
;
for
(
uint32_t
i
=
0
;
i
<
CSP_LAST_KEYWORD_VALUE
;
i
+
+
)
{
keyword
.
AssignASCII
(
gCSPUTF8Keywords
[
i
]
+
1
)
;
keyword
.
Trim
(
"
'
"
false
true
)
;
if
(
lowerKey
.
Equals
(
keyword
)
)
{
return
true
;
}
}
return
false
;
}
bool
permitsScheme
(
const
nsAString
&
aEnforcementScheme
nsIURI
*
aUri
bool
aReportOnly
bool
aUpgradeInsecure
bool
aFromSelfURI
)
{
nsAutoCString
scheme
;
nsresult
rv
=
aUri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
aEnforcementScheme
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
aEnforcementScheme
.
EqualsASCII
(
scheme
.
get
(
)
)
)
{
return
true
;
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
http
"
)
)
{
if
(
scheme
.
EqualsASCII
(
"
https
"
)
)
{
return
true
;
}
if
(
(
scheme
.
EqualsASCII
(
"
ws
"
)
|
|
scheme
.
EqualsASCII
(
"
wss
"
)
)
&
&
aFromSelfURI
)
{
return
true
;
}
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
https
"
)
)
{
if
(
scheme
.
EqualsLiteral
(
"
wss
"
)
&
&
aFromSelfURI
)
{
return
true
;
}
}
if
(
aEnforcementScheme
.
EqualsASCII
(
"
ws
"
)
&
&
scheme
.
EqualsASCII
(
"
wss
"
)
)
{
return
true
;
}
return
(
(
aUpgradeInsecure
&
&
!
aReportOnly
)
&
&
(
(
scheme
.
EqualsASCII
(
"
http
"
)
&
&
aEnforcementScheme
.
EqualsASCII
(
"
https
"
)
)
|
|
(
scheme
.
EqualsASCII
(
"
ws
"
)
&
&
aEnforcementScheme
.
EqualsASCII
(
"
wss
"
)
)
)
)
;
}
nsresult
CSP_AppendCSPFromHeader
(
nsIContentSecurityPolicy
*
aCsp
const
nsAString
&
aHeaderValue
bool
aReportOnly
)
{
NS_ENSURE_ARG
(
aCsp
)
;
nsresult
rv
=
NS_OK
;
for
(
const
nsAString
&
policy
:
nsCharSeparatedTokenizer
(
aHeaderValue
'
'
)
.
ToRange
(
)
)
{
rv
=
aCsp
-
>
AppendPolicy
(
policy
aReportOnly
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
{
CSPUTILSLOG
(
(
"
CSP
refined
with
policy
:
\
"
%
s
\
"
"
NS_ConvertUTF16toUTF8
(
policy
)
.
get
(
)
)
)
;
}
}
return
NS_OK
;
}
nsCSPBaseSrc
:
:
nsCSPBaseSrc
(
)
:
mInvalidated
(
false
)
{
}
nsCSPBaseSrc
:
:
~
nsCSPBaseSrc
(
)
=
default
;
bool
nsCSPBaseSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPBaseSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
return
false
;
}
bool
nsCSPBaseSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPBaseSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
aKeyword
=
=
CSP_HASH
?
"
hash
"
:
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
return
false
;
}
nsCSPSchemeSrc
:
:
nsCSPSchemeSrc
(
const
nsAString
&
aScheme
)
:
mScheme
(
aScheme
)
{
ToLowerCase
(
mScheme
)
;
}
nsCSPSchemeSrc
:
:
~
nsCSPSchemeSrc
(
)
=
default
;
bool
nsCSPSchemeSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPSchemeSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
MOZ_ASSERT
(
(
!
mScheme
.
EqualsASCII
(
"
"
)
)
"
scheme
can
not
be
the
empty
string
"
)
;
if
(
mInvalidated
)
{
return
false
;
}
return
permitsScheme
(
mScheme
aUri
aReportOnly
aUpgradeInsecure
false
)
;
}
bool
nsCSPSchemeSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitSchemeSrc
(
*
this
)
;
}
void
nsCSPSchemeSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
mScheme
)
;
outStr
.
AppendLiteral
(
"
:
"
)
;
}
nsCSPHostSrc
:
:
nsCSPHostSrc
(
const
nsAString
&
aHost
)
:
mHost
(
aHost
)
mGeneratedFromSelfKeyword
(
false
)
mIsUniqueOrigin
(
false
)
mWithinFrameAncstorsDir
(
false
)
{
ToLowerCase
(
mHost
)
;
}
nsCSPHostSrc
:
:
~
nsCSPHostSrc
(
)
=
default
;
bool
permitsPort
(
const
nsAString
&
aEnforcementScheme
const
nsAString
&
aEnforcementPort
nsIURI
*
aResourceURI
)
{
if
(
aEnforcementPort
.
EqualsASCII
(
"
*
"
)
)
{
return
true
;
}
int32_t
resourcePort
;
nsresult
rv
=
aResourceURI
-
>
GetPort
(
&
resourcePort
)
;
if
(
NS_FAILED
(
rv
)
&
&
aEnforcementPort
.
IsEmpty
(
)
)
{
if
(
aEnforcementScheme
.
IsEmpty
(
)
)
{
return
false
;
}
int
defaultPortforScheme
=
NS_GetDefaultPort
(
NS_ConvertUTF16toUTF8
(
aEnforcementScheme
)
.
get
(
)
)
;
return
(
defaultPortforScheme
=
=
-
1
|
|
defaultPortforScheme
=
=
-
0
)
;
}
if
(
resourcePort
=
=
DEFAULT_PORT
&
&
aEnforcementPort
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
resourcePort
=
=
DEFAULT_PORT
)
{
nsAutoCString
resourceScheme
;
rv
=
aResourceURI
-
>
GetScheme
(
resourceScheme
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
resourcePort
=
NS_GetDefaultPort
(
resourceScheme
.
get
(
)
)
;
}
nsString
resourcePortStr
;
resourcePortStr
.
AppendInt
(
resourcePort
)
;
if
(
aEnforcementPort
.
Equals
(
resourcePortStr
)
)
{
return
true
;
}
nsString
enforcementPort
(
aEnforcementPort
)
;
if
(
enforcementPort
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
aEnforcementScheme
.
IsEmpty
(
)
"
need
a
scheme
to
query
default
port
"
)
;
int32_t
defaultEnforcementPort
=
NS_GetDefaultPort
(
NS_ConvertUTF16toUTF8
(
aEnforcementScheme
)
.
get
(
)
)
;
enforcementPort
.
Truncate
(
)
;
enforcementPort
.
AppendInt
(
defaultEnforcementPort
)
;
}
if
(
enforcementPort
.
Equals
(
resourcePortStr
)
)
{
return
true
;
}
if
(
enforcementPort
.
EqualsLiteral
(
"
80
"
)
&
&
resourcePortStr
.
EqualsLiteral
(
"
443
"
)
)
{
return
true
;
}
return
false
;
}
bool
nsCSPHostSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPHostSrc
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
if
(
mInvalidated
|
|
mIsUniqueOrigin
)
{
return
false
;
}
if
(
!
permitsScheme
(
mScheme
aUri
aReportOnly
aUpgradeInsecure
mGeneratedFromSelfKeyword
)
)
{
return
false
;
}
NS_ASSERTION
(
(
!
mHost
.
IsEmpty
(
)
)
"
host
can
not
be
the
empty
string
"
)
;
nsAutoCString
uriHost
;
nsresult
rv
=
aUri
-
>
GetAsciiHost
(
uriHost
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsString
decodedUriHost
;
CSP_PercentDecodeStr
(
NS_ConvertUTF8toUTF16
(
uriHost
)
decodedUriHost
)
;
if
(
mHost
.
EqualsASCII
(
"
*
"
)
)
{
if
(
aUri
-
>
SchemeIs
(
"
blob
"
)
|
|
aUri
-
>
SchemeIs
(
"
data
"
)
|
|
aUri
-
>
SchemeIs
(
"
filesystem
"
)
)
{
return
false
;
}
if
(
mScheme
.
IsEmpty
(
)
)
{
return
true
;
}
}
else
if
(
mHost
.
First
(
)
=
=
'
*
'
)
{
NS_ASSERTION
(
mHost
[
1
]
=
=
'
.
'
"
Second
character
needs
to
be
'
.
'
whenever
host
starts
with
'
*
'
"
)
;
nsString
wildCardHost
=
mHost
;
wildCardHost
=
Substring
(
wildCardHost
1
wildCardHost
.
Length
(
)
-
1
)
;
if
(
!
StringEndsWith
(
decodedUriHost
wildCardHost
)
)
{
return
false
;
}
}
else
if
(
!
mHost
.
Equals
(
decodedUriHost
)
)
{
return
false
;
}
if
(
!
permitsPort
(
mScheme
mPort
aUri
)
)
{
return
false
;
}
if
(
!
aWasRedirected
&
&
!
mPath
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURL
>
url
=
do_QueryInterface
(
aUri
)
;
if
(
!
url
)
{
NS_ASSERTION
(
false
"
can
'
t
QI
into
nsIURI
"
)
;
return
false
;
}
nsAutoCString
uriPath
;
rv
=
url
-
>
GetFilePath
(
uriPath
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
mWithinFrameAncstorsDir
)
{
return
true
;
}
nsString
decodedUriPath
;
CSP_PercentDecodeStr
(
NS_ConvertUTF8toUTF16
(
uriPath
)
decodedUriPath
)
;
if
(
mPath
.
Last
(
)
=
=
'
/
'
)
{
if
(
!
StringBeginsWith
(
decodedUriPath
mPath
)
)
{
return
false
;
}
}
else
{
if
(
!
mPath
.
Equals
(
decodedUriPath
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
nsCSPHostSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitHostSrc
(
*
this
)
;
}
void
nsCSPHostSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
if
(
mGeneratedFromSelfKeyword
)
{
outStr
.
AppendLiteral
(
"
'
self
'
"
)
;
return
;
}
if
(
mHost
.
EqualsASCII
(
"
*
"
)
&
&
mScheme
.
IsEmpty
(
)
&
&
mPort
.
IsEmpty
(
)
)
{
outStr
.
Append
(
mHost
)
;
return
;
}
outStr
.
Append
(
mScheme
)
;
outStr
.
AppendLiteral
(
"
:
/
/
"
)
;
outStr
.
Append
(
mHost
)
;
if
(
!
mPort
.
IsEmpty
(
)
)
{
outStr
.
AppendLiteral
(
"
:
"
)
;
outStr
.
Append
(
mPort
)
;
}
outStr
.
Append
(
mPath
)
;
}
void
nsCSPHostSrc
:
:
setScheme
(
const
nsAString
&
aScheme
)
{
mScheme
=
aScheme
;
ToLowerCase
(
mScheme
)
;
}
void
nsCSPHostSrc
:
:
setPort
(
const
nsAString
&
aPort
)
{
mPort
=
aPort
;
}
void
nsCSPHostSrc
:
:
appendPath
(
const
nsAString
&
aPath
)
{
mPath
.
Append
(
aPath
)
;
}
nsCSPKeywordSrc
:
:
nsCSPKeywordSrc
(
enum
CSPKeyword
aKeyword
)
:
mKeyword
(
aKeyword
)
{
NS_ASSERTION
(
(
aKeyword
!
=
CSP_SELF
)
"
'
self
'
should
have
been
replaced
in
the
parser
"
)
;
}
nsCSPKeywordSrc
:
:
~
nsCSPKeywordSrc
(
)
=
default
;
bool
nsCSPKeywordSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
return
(
(
mKeyword
=
=
CSP_STRICT_DYNAMIC
)
&
&
!
aParserCreated
)
;
}
bool
nsCSPKeywordSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPKeywordSrc
:
:
allows
aKeyWord
:
%
s
aHashOrNonce
:
%
s
mInvalidated
:
"
"
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
mInvalidated
?
"
yes
"
:
"
false
"
)
)
;
if
(
mInvalidated
)
{
MOZ_ASSERT
(
mKeyword
=
=
CSP_UNSAFE_INLINE
|
|
mKeyword
=
=
CSP_REPORT_SAMPLE
"
should
only
invalidate
unsafe
-
inline
"
)
;
return
false
;
}
return
(
(
mKeyword
=
=
aKeyword
)
|
|
(
(
mKeyword
=
=
CSP_STRICT_DYNAMIC
)
&
&
!
aParserCreated
&
&
aKeyword
!
=
CSP_UNSAFE_EVAL
&
&
aKeyword
!
=
CSP_WASM_UNSAFE_EVAL
)
)
;
}
bool
nsCSPKeywordSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitKeywordSrc
(
*
this
)
;
}
void
nsCSPKeywordSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
CSP_EnumToUTF16Keyword
(
mKeyword
)
)
;
}
nsCSPNonceSrc
:
:
nsCSPNonceSrc
(
const
nsAString
&
aNonce
)
:
mNonce
(
aNonce
)
{
}
nsCSPNonceSrc
:
:
~
nsCSPNonceSrc
(
)
=
default
;
bool
nsCSPNonceSrc
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPNonceSrc
:
:
permits
aUri
:
%
s
aNonce
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aNonce
)
.
get
(
)
)
)
;
}
if
(
aReportOnly
&
&
aWasRedirected
&
&
aNonce
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aParserCreated
=
=
false
"
Skipping
nonce
-
check
is
only
allowed
for
Preloads
"
)
;
return
true
;
}
return
mNonce
.
Equals
(
aNonce
)
;
}
bool
nsCSPNonceSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPNonceSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
if
(
aKeyword
!
=
CSP_NONCE
)
{
return
false
;
}
return
mNonce
.
Equals
(
aHashOrNonce
)
;
}
bool
nsCSPNonceSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitNonceSrc
(
*
this
)
;
}
void
nsCSPNonceSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
CSP_EnumToUTF16Keyword
(
CSP_NONCE
)
)
;
outStr
.
Append
(
mNonce
)
;
outStr
.
AppendLiteral
(
"
'
"
)
;
}
nsCSPHashSrc
:
:
nsCSPHashSrc
(
const
nsAString
&
aAlgo
const
nsAString
&
aHash
)
:
mAlgorithm
(
aAlgo
)
mHash
(
aHash
)
{
ToLowerCase
(
mAlgorithm
)
;
char16_t
*
cur
=
mHash
.
BeginWriting
(
)
;
char16_t
*
end
=
mHash
.
EndWriting
(
)
;
for
(
;
cur
<
end
;
+
+
cur
)
{
if
(
char16_t
(
'
-
'
)
=
=
*
cur
)
{
*
cur
=
char16_t
(
'
+
'
)
;
}
if
(
char16_t
(
'
_
'
)
=
=
*
cur
)
{
*
cur
=
char16_t
(
'
/
'
)
;
}
}
}
nsCSPHashSrc
:
:
~
nsCSPHashSrc
(
)
=
default
;
bool
nsCSPHashSrc
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPHashSrc
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
if
(
aKeyword
!
=
CSP_HASH
)
{
return
false
;
}
NS_ConvertUTF16toUTF8
utf8_hash
(
aHashOrNonce
)
;
nsCOMPtr
<
nsICryptoHash
>
hasher
;
nsresult
rv
=
NS_NewCryptoHash
(
NS_ConvertUTF16toUTF8
(
mAlgorithm
)
getter_AddRefs
(
hasher
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
hasher
-
>
Update
(
(
uint8_t
*
)
utf8_hash
.
get
(
)
utf8_hash
.
Length
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsAutoCString
hash
;
rv
=
hasher
-
>
Finish
(
true
hash
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
NS_ConvertUTF16toUTF8
(
mHash
)
.
Equals
(
hash
)
;
}
bool
nsCSPHashSrc
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
aVisitor
-
>
visitHashSrc
(
*
this
)
;
}
void
nsCSPHashSrc
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendLiteral
(
"
'
"
)
;
outStr
.
Append
(
mAlgorithm
)
;
outStr
.
AppendLiteral
(
"
-
"
)
;
outStr
.
Append
(
mHash
)
;
outStr
.
AppendLiteral
(
"
'
"
)
;
}
nsCSPReportURI
:
:
nsCSPReportURI
(
nsIURI
*
aURI
)
:
mReportURI
(
aURI
)
{
}
nsCSPReportURI
:
:
~
nsCSPReportURI
(
)
=
default
;
bool
nsCSPReportURI
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
false
;
}
void
nsCSPReportURI
:
:
toString
(
nsAString
&
outStr
)
const
{
nsAutoCString
spec
;
nsresult
rv
=
mReportURI
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
outStr
.
AppendASCII
(
spec
.
get
(
)
)
;
}
nsCSPSandboxFlags
:
:
nsCSPSandboxFlags
(
const
nsAString
&
aFlags
)
:
mFlags
(
aFlags
)
{
ToLowerCase
(
mFlags
)
;
}
nsCSPSandboxFlags
:
:
~
nsCSPSandboxFlags
(
)
=
default
;
bool
nsCSPSandboxFlags
:
:
visit
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
return
false
;
}
void
nsCSPSandboxFlags
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
Append
(
mFlags
)
;
}
nsCSPDirective
:
:
nsCSPDirective
(
CSPDirective
aDirective
)
{
mDirective
=
aDirective
;
}
nsCSPDirective
:
:
~
nsCSPDirective
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
delete
mSrcs
[
i
]
;
}
}
bool
nsCSPDirective
:
:
permits
(
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aReportOnly
bool
aUpgradeInsecure
bool
aParserCreated
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPDirective
:
:
permits
aUri
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
mSrcs
[
i
]
-
>
permits
(
aUri
aNonce
aWasRedirected
aReportOnly
aUpgradeInsecure
aParserCreated
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSPDirective
:
:
allows
(
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPDirective
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
mSrcs
[
i
]
-
>
allows
(
aKeyword
aHashOrNonce
aParserCreated
)
)
{
return
true
;
}
}
return
false
;
}
void
nsCSPDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
mDirective
)
)
;
outStr
.
AppendLiteral
(
"
"
)
;
StringJoinAppend
(
outStr
u
"
"
_ns
mSrcs
[
]
(
nsAString
&
dest
nsCSPBaseSrc
*
cspBaseSrc
)
{
cspBaseSrc
-
>
toString
(
dest
)
;
}
)
;
}
void
nsCSPDirective
:
:
toDomCSPStruct
(
mozilla
:
:
dom
:
:
CSP
&
outCSP
)
const
{
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
srcs
;
nsString
src
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
src
.
Truncate
(
)
;
mSrcs
[
i
]
-
>
toString
(
src
)
;
if
(
!
srcs
.
AppendElement
(
src
mozilla
:
:
fallible
)
)
{
mozalloc_handle_oom
(
0
)
;
}
}
switch
(
mDirective
)
{
case
nsIContentSecurityPolicy
:
:
DEFAULT_SRC_DIRECTIVE
:
outCSP
.
mDefault_src
.
Construct
(
)
;
outCSP
.
mDefault_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
:
outCSP
.
mScript_src
.
Construct
(
)
;
outCSP
.
mScript_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
OBJECT_SRC_DIRECTIVE
:
outCSP
.
mObject_src
.
Construct
(
)
;
outCSP
.
mObject_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
STYLE_SRC_DIRECTIVE
:
outCSP
.
mStyle_src
.
Construct
(
)
;
outCSP
.
mStyle_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
IMG_SRC_DIRECTIVE
:
outCSP
.
mImg_src
.
Construct
(
)
;
outCSP
.
mImg_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
MEDIA_SRC_DIRECTIVE
:
outCSP
.
mMedia_src
.
Construct
(
)
;
outCSP
.
mMedia_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
:
outCSP
.
mFrame_src
.
Construct
(
)
;
outCSP
.
mFrame_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FONT_SRC_DIRECTIVE
:
outCSP
.
mFont_src
.
Construct
(
)
;
outCSP
.
mFont_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
CONNECT_SRC_DIRECTIVE
:
outCSP
.
mConnect_src
.
Construct
(
)
;
outCSP
.
mConnect_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
:
outCSP
.
mReport_uri
.
Construct
(
)
;
outCSP
.
mReport_uri
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
:
outCSP
.
mFrame_ancestors
.
Construct
(
)
;
outCSP
.
mFrame_ancestors
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
WEB_MANIFEST_SRC_DIRECTIVE
:
outCSP
.
mManifest_src
.
Construct
(
)
;
outCSP
.
mManifest_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
BASE_URI_DIRECTIVE
:
outCSP
.
mBase_uri
.
Construct
(
)
;
outCSP
.
mBase_uri
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
FORM_ACTION_DIRECTIVE
:
outCSP
.
mForm_action
.
Construct
(
)
;
outCSP
.
mForm_action
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
:
outCSP
.
mBlock_all_mixed_content
.
Construct
(
)
;
return
;
case
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
:
outCSP
.
mUpgrade_insecure_requests
.
Construct
(
)
;
return
;
case
nsIContentSecurityPolicy
:
:
CHILD_SRC_DIRECTIVE
:
outCSP
.
mChild_src
.
Construct
(
)
;
outCSP
.
mChild_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
:
outCSP
.
mSandbox
.
Construct
(
)
;
outCSP
.
mSandbox
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
:
outCSP
.
mWorker_src
.
Construct
(
)
;
outCSP
.
mWorker_src
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
:
outCSP
.
mScript_src_elem
.
Construct
(
)
;
outCSP
.
mScript_src_elem
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
case
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
:
outCSP
.
mScript_src_attr
.
Construct
(
)
;
outCSP
.
mScript_src_attr
.
Value
(
)
=
std
:
:
move
(
srcs
)
;
return
;
default
:
NS_ASSERTION
(
false
"
cannot
find
directive
to
convert
CSP
to
JSON
"
)
;
}
}
void
nsCSPDirective
:
:
getReportURIs
(
nsTArray
<
nsString
>
&
outReportURIs
)
const
{
NS_ASSERTION
(
(
mDirective
=
=
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
"
not
a
report
-
uri
directive
"
)
;
nsString
tmpReportURI
;
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
tmpReportURI
.
Truncate
(
)
;
mSrcs
[
i
]
-
>
toString
(
tmpReportURI
)
;
outReportURIs
.
AppendElement
(
tmpReportURI
)
;
}
}
bool
nsCSPDirective
:
:
visitSrcs
(
nsCSPSrcVisitor
*
aVisitor
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mSrcs
.
Length
(
)
;
i
+
+
)
{
if
(
!
mSrcs
[
i
]
-
>
visit
(
aVisitor
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsCSPDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
return
(
mDirective
=
=
aDirective
)
;
}
void
nsCSPDirective
:
:
getDirName
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
mDirective
)
)
;
}
bool
nsCSPDirective
:
:
hasReportSampleKeyword
(
)
const
{
for
(
nsCSPBaseSrc
*
src
:
mSrcs
)
{
if
(
src
-
>
isReportSample
(
)
)
{
return
true
;
}
}
return
false
;
}
nsCSPChildSrcDirective
:
:
nsCSPChildSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
mRestrictFrames
(
false
)
mRestrictWorkers
(
false
)
{
}
nsCSPChildSrcDirective
:
:
~
nsCSPChildSrcDirective
(
)
=
default
;
bool
nsCSPChildSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
)
{
return
mRestrictFrames
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
)
{
return
mRestrictWorkers
;
}
return
(
mDirective
=
=
aDirective
)
;
}
nsCSPScriptSrcDirective
:
:
nsCSPScriptSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsCSPScriptSrcDirective
:
:
~
nsCSPScriptSrcDirective
(
)
=
default
;
bool
nsCSPScriptSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
)
{
return
mRestrictWorkers
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
{
return
mRestrictScriptElem
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
{
return
mRestrictScriptAttr
;
}
return
mDirective
=
=
aDirective
;
}
nsCSPStyleSrcDirective
:
:
nsCSPStyleSrcDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsCSPStyleSrcDirective
:
:
~
nsCSPStyleSrcDirective
(
)
=
default
;
bool
nsCSPStyleSrcDirective
:
:
equals
(
CSPDirective
aDirective
)
const
{
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
STYLE_SRC_ELEM_DIRECTIVE
)
{
return
mRestrictStyleElem
;
}
if
(
aDirective
=
=
nsIContentSecurityPolicy
:
:
STYLE_SRC_ATTR_DIRECTIVE
)
{
return
mRestrictStyleAttr
;
}
return
mDirective
=
=
aDirective
;
}
nsBlockAllMixedContentDirective
:
:
nsBlockAllMixedContentDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsBlockAllMixedContentDirective
:
:
~
nsBlockAllMixedContentDirective
(
)
=
default
;
void
nsBlockAllMixedContentDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
)
;
}
void
nsBlockAllMixedContentDirective
:
:
getDirName
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
)
;
}
nsUpgradeInsecureDirective
:
:
nsUpgradeInsecureDirective
(
CSPDirective
aDirective
)
:
nsCSPDirective
(
aDirective
)
{
}
nsUpgradeInsecureDirective
:
:
~
nsUpgradeInsecureDirective
(
)
=
default
;
void
nsUpgradeInsecureDirective
:
:
toString
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
)
;
}
void
nsUpgradeInsecureDirective
:
:
getDirName
(
nsAString
&
outStr
)
const
{
outStr
.
AppendASCII
(
CSP_CSPDirectiveToString
(
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
)
;
}
nsCSPPolicy
:
:
nsCSPPolicy
(
)
:
mUpgradeInsecDir
(
nullptr
)
mReportOnly
(
false
)
mDeliveredViaMetaTag
(
false
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
nsCSPPolicy
"
)
)
;
}
nsCSPPolicy
:
:
~
nsCSPPolicy
(
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
~
nsCSPPolicy
"
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
delete
mDirectives
[
i
]
;
}
}
bool
nsCSPPolicy
:
:
permits
(
CSPDirective
aDir
nsIURI
*
aUri
const
nsAString
&
aNonce
bool
aWasRedirected
bool
aSpecific
bool
aParserCreated
nsAString
&
outViolatedDirective
)
const
{
if
(
CSPUTILSLOGENABLED
(
)
)
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
permits
aUri
:
%
s
aDir
:
%
d
aSpecific
:
%
s
"
aUri
-
>
GetSpecOrDefault
(
)
.
get
(
)
aDir
aSpecific
?
"
true
"
:
"
false
"
)
)
;
}
NS_ASSERTION
(
aUri
"
permits
needs
an
uri
to
perform
the
check
!
"
)
;
outViolatedDirective
.
Truncate
(
)
;
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
if
(
!
mDirectives
[
i
]
-
>
permits
(
aUri
aNonce
aWasRedirected
mReportOnly
mUpgradeInsecDir
aParserCreated
)
)
{
mDirectives
[
i
]
-
>
getDirName
(
outViolatedDirective
)
;
return
false
;
}
return
true
;
}
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
}
}
if
(
!
aSpecific
&
&
defaultDir
)
{
if
(
!
defaultDir
-
>
permits
(
aUri
aNonce
aWasRedirected
mReportOnly
mUpgradeInsecDir
aParserCreated
)
)
{
defaultDir
-
>
getDirName
(
outViolatedDirective
)
;
return
false
;
}
return
true
;
}
return
true
;
}
bool
nsCSPPolicy
:
:
allows
(
CSPDirective
aDirective
enum
CSPKeyword
aKeyword
const
nsAString
&
aHashOrNonce
bool
aParserCreated
)
const
{
CSPUTILSLOG
(
(
"
nsCSPPolicy
:
:
allows
aKeyWord
:
%
s
a
HashOrNonce
:
%
s
"
CSP_EnumToUTF8Keyword
(
aKeyword
)
NS_ConvertUTF16toUTF8
(
aHashOrNonce
)
.
get
(
)
)
)
;
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
continue
;
}
if
(
mDirectives
[
i
]
-
>
equals
(
aDirective
)
)
{
if
(
mDirectives
[
i
]
-
>
allows
(
aKeyword
aHashOrNonce
aParserCreated
)
)
{
return
true
;
}
return
false
;
}
}
if
(
aKeyword
=
=
CSP_NONCE
|
|
aKeyword
=
=
CSP_HASH
)
{
if
(
!
defaultDir
)
{
return
true
;
}
return
false
;
}
if
(
defaultDir
)
{
return
defaultDir
-
>
allows
(
aKeyword
aHashOrNonce
aParserCreated
)
;
}
return
true
;
}
void
nsCSPPolicy
:
:
toString
(
nsAString
&
outStr
)
const
{
StringJoinAppend
(
outStr
u
"
;
"
_ns
mDirectives
[
]
(
nsAString
&
dest
nsCSPDirective
*
cspDirective
)
{
cspDirective
-
>
toString
(
dest
)
;
}
)
;
}
void
nsCSPPolicy
:
:
toDomCSPStruct
(
mozilla
:
:
dom
:
:
CSP
&
outCSP
)
const
{
outCSP
.
mReport_only
=
mReportOnly
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
+
+
i
)
{
mDirectives
[
i
]
-
>
toDomCSPStruct
(
outCSP
)
;
}
}
bool
nsCSPPolicy
:
:
hasDirective
(
CSPDirective
aDir
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSPPolicy
:
:
allowsNavigateTo
(
nsIURI
*
aURI
bool
aWasRedirected
bool
aEnforceAllowlist
)
const
{
bool
allowsNavigateTo
=
true
;
for
(
unsigned
long
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
NAVIGATE_TO_DIRECTIVE
)
)
{
if
(
!
aEnforceAllowlist
&
&
mDirectives
[
i
]
-
>
allows
(
CSP_UNSAFE_ALLOW_REDIRECTS
u
"
"
_ns
false
)
)
{
return
true
;
}
if
(
!
mDirectives
[
i
]
-
>
permits
(
aURI
u
"
"
_ns
aWasRedirected
false
false
false
)
)
{
allowsNavigateTo
=
false
;
}
}
}
return
allowsNavigateTo
;
}
void
nsCSPPolicy
:
:
getDirectiveStringAndReportSampleForContentType
(
CSPDirective
aDirective
nsAString
&
outDirective
bool
*
aReportSample
)
const
{
MOZ_ASSERT
(
aReportSample
)
;
*
aReportSample
=
false
;
nsCSPDirective
*
defaultDir
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
isDefaultDirective
(
)
)
{
defaultDir
=
mDirectives
[
i
]
;
continue
;
}
if
(
mDirectives
[
i
]
-
>
equals
(
aDirective
)
)
{
mDirectives
[
i
]
-
>
getDirName
(
outDirective
)
;
*
aReportSample
=
mDirectives
[
i
]
-
>
hasReportSampleKeyword
(
)
;
return
;
}
}
if
(
defaultDir
)
{
defaultDir
-
>
getDirName
(
outDirective
)
;
*
aReportSample
=
defaultDir
-
>
hasReportSampleKeyword
(
)
;
return
;
}
NS_ASSERTION
(
false
"
Can
not
query
directive
string
for
contentType
!
"
)
;
outDirective
.
AppendLiteral
(
"
couldNotQueryViolatedDirective
"
)
;
}
void
nsCSPPolicy
:
:
getDirectiveAsString
(
CSPDirective
aDir
nsAString
&
outDirective
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
mDirectives
[
i
]
-
>
toString
(
outDirective
)
;
return
;
}
}
}
uint32_t
nsCSPPolicy
:
:
getSandboxFlags
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
)
)
{
nsAutoString
flags
;
mDirectives
[
i
]
-
>
toString
(
flags
)
;
if
(
flags
.
IsEmpty
(
)
)
{
return
SANDBOX_ALL_FLAGS
;
}
nsAttrValue
attr
;
attr
.
ParseAtomArray
(
flags
)
;
return
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
&
attr
)
;
}
}
return
SANDBOXED_NONE
;
}
void
nsCSPPolicy
:
:
getReportURIs
(
nsTArray
<
nsString
>
&
outReportURIs
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
)
{
mDirectives
[
i
]
-
>
getReportURIs
(
outReportURIs
)
;
return
;
}
}
}
bool
nsCSPPolicy
:
:
visitDirectiveSrcs
(
CSPDirective
aDir
nsCSPSrcVisitor
*
aVisitor
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mDirectives
.
Length
(
)
;
i
+
+
)
{
if
(
mDirectives
[
i
]
-
>
equals
(
aDir
)
)
{
return
mDirectives
[
i
]
-
>
visitSrcs
(
aVisitor
)
;
}
}
return
false
;
}
