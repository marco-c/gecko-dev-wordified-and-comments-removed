#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsMixedContentBlocker
.
h
"
#
include
"
nsCDefaultURIFixup
.
h
"
#
include
"
nsIURIFixup
.
h
"
#
include
"
nsINestedURI
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
NS_IMPL_ISUPPORTS
(
nsContentSecurityManager
nsIContentSecurityManager
nsIChannelEventSink
)
static
nsresult
ValidateSecurityFlags
(
nsILoadInfo
*
aLoadInfo
)
{
nsSecurityFlags
securityMode
=
aLoadInfo
-
>
GetSecurityMode
(
)
;
if
(
securityMode
!
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
&
&
securityMode
!
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
)
{
MOZ_ASSERT
(
false
"
need
one
securityflag
from
nsILoadInfo
to
perform
security
checks
"
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
static
bool
SchemeIs
(
nsIURI
*
aURI
const
char
*
aScheme
)
{
nsCOMPtr
<
nsIURI
>
baseURI
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_TRUE
(
baseURI
false
)
;
bool
isScheme
=
false
;
return
NS_SUCCEEDED
(
baseURI
-
>
SchemeIs
(
aScheme
&
isScheme
)
)
&
&
isScheme
;
}
static
bool
IsImageLoadInEditorAppType
(
nsILoadInfo
*
aLoadInfo
)
{
nsContentPolicyType
type
=
aLoadInfo
-
>
InternalContentPolicyType
(
)
;
if
(
type
!
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
&
&
type
!
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
&
&
type
!
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
&
&
type
!
=
nsIContentPolicy
:
:
TYPE_IMAGESET
)
{
return
false
;
}
uint32_t
appType
=
nsIDocShell
:
:
APP_TYPE_UNKNOWN
;
nsINode
*
node
=
aLoadInfo
-
>
LoadingNode
(
)
;
if
(
!
node
)
{
return
false
;
}
nsIDocument
*
doc
=
node
-
>
OwnerDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellTreeItem
=
doc
-
>
GetDocShell
(
)
;
if
(
!
docShellTreeItem
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
docShellTreeItem
-
>
GetRootTreeItem
(
getter_AddRefs
(
root
)
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
root
)
)
;
if
(
!
docShell
|
|
NS_FAILED
(
docShell
-
>
GetAppType
(
&
appType
)
)
)
{
appType
=
nsIDocShell
:
:
APP_TYPE_UNKNOWN
;
}
return
appType
=
=
nsIDocShell
:
:
APP_TYPE_EDITOR
;
}
static
nsresult
DoCheckLoadURIChecks
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
)
{
if
(
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_DTD
)
{
return
NS_OK
;
}
if
(
IsImageLoadInEditorAppType
(
aLoadInfo
)
)
{
return
NS_OK
;
}
uint32_t
flags
=
nsIScriptSecurityManager
:
:
STANDARD
;
if
(
aLoadInfo
-
>
GetAllowChrome
(
)
)
{
flags
|
=
nsIScriptSecurityManager
:
:
ALLOW_CHROME
;
}
if
(
aLoadInfo
-
>
GetDisallowScript
(
)
)
{
flags
|
=
nsIScriptSecurityManager
:
:
DISALLOW_SCRIPT
;
}
return
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIWithPrincipal
(
aLoadInfo
-
>
TriggeringPrincipal
(
)
aURI
flags
)
;
}
static
bool
URIHasFlags
(
nsIURI
*
aURI
uint32_t
aURIFlags
)
{
bool
hasFlags
;
nsresult
rv
=
NS_URIChainHasFlags
(
aURI
aURIFlags
&
hasFlags
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
hasFlags
;
}
static
nsresult
DoSOPChecks
(
nsIURI
*
aURI
nsILoadInfo
*
aLoadInfo
nsIChannel
*
aChannel
)
{
if
(
aLoadInfo
-
>
GetAllowChrome
(
)
&
&
(
URIHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
)
|
|
SchemeIs
(
aURI
"
moz
-
safe
-
about
"
)
)
)
{
return
DoCheckLoadURIChecks
(
aURI
aLoadInfo
)
;
}
NS_ENSURE_FALSE
(
NS_HasBeenCrossOrigin
(
aChannel
true
)
NS_ERROR_DOM_BAD_URI
)
;
return
NS_OK
;
}
static
nsresult
DoCORSChecks
(
nsIChannel
*
aChannel
nsILoadInfo
*
aLoadInfo
nsCOMPtr
<
nsIStreamListener
>
&
aInAndOutListener
)
{
MOZ_RELEASE_ASSERT
(
aInAndOutListener
"
can
not
perform
CORS
checks
without
a
listener
"
)
;
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
aLoadInfo
-
>
TriggeringPrincipal
(
)
)
)
{
return
NS_OK
;
}
nsIPrincipal
*
loadingPrincipal
=
aLoadInfo
-
>
LoadingPrincipal
(
)
;
RefPtr
<
nsCORSListenerProxy
>
corsListener
=
new
nsCORSListenerProxy
(
aInAndOutListener
loadingPrincipal
aLoadInfo
-
>
GetCookiePolicy
(
)
=
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
)
;
nsresult
rv
=
corsListener
-
>
Init
(
aChannel
DataURIHandling
:
:
Allow
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aInAndOutListener
=
corsListener
;
return
NS_OK
;
}
static
nsresult
DoContentSecurityChecks
(
nsIChannel
*
aChannel
nsILoadInfo
*
aLoadInfo
)
{
nsContentPolicyType
contentPolicyType
=
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
nsContentPolicyType
internalContentPolicyType
=
aLoadInfo
-
>
InternalContentPolicyType
(
)
;
nsCString
mimeTypeGuess
;
nsCOMPtr
<
nsINode
>
requestingContext
=
nullptr
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
nsCOMPtr
<
nsIURIFixup
>
urifixup
(
do_GetService
(
NS_URIFIXUP_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
urifixup
)
{
nsCOMPtr
<
nsIURI
>
fixedURI
;
rv
=
urifixup
-
>
CreateExposableURI
(
uri
getter_AddRefs
(
fixedURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uri
=
fixedURI
;
}
}
}
switch
(
contentPolicyType
)
{
case
nsIContentPolicy
:
:
TYPE_OTHER
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_SCRIPT
:
{
mimeTypeGuess
=
NS_LITERAL_CSTRING
(
"
application
/
javascript
"
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_IMAGE
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_STYLESHEET
:
{
mimeTypeGuess
=
NS_LITERAL_CSTRING
(
"
text
/
css
"
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_OBJECT
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_DOCUMENT
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
:
{
mimeTypeGuess
=
NS_LITERAL_CSTRING
(
"
text
/
html
"
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_REFRESH
:
{
MOZ_ASSERT
(
false
"
contentPolicyType
not
supported
yet
"
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_XBL
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_PING
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_XMLHTTPREQUEST
:
{
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
MOZ_ASSERT
(
!
requestingContext
|
|
requestingContext
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
DOCUMENT_NODE
"
type_xml
requires
requestingContext
of
type
Document
"
)
;
if
(
internalContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST
|
|
internalContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_XMLHTTPREQUEST
)
{
mimeTypeGuess
=
EmptyCString
(
)
;
}
else
{
MOZ_ASSERT
(
internalContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_EVENTSOURCE
"
can
not
set
mime
type
guess
for
unexpected
internal
type
"
)
;
mimeTypeGuess
=
NS_LITERAL_CSTRING
(
TEXT_EVENT_STREAM
)
;
}
break
;
}
case
nsIContentPolicy
:
:
TYPE_OBJECT_SUBREQUEST
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
MOZ_ASSERT
(
!
requestingContext
|
|
requestingContext
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
ELEMENT_NODE
"
type_subrequest
requires
requestingContext
of
type
Element
"
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_DTD
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
MOZ_ASSERT
(
!
requestingContext
|
|
requestingContext
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
DOCUMENT_NODE
"
type_dtd
requires
requestingContext
of
type
Document
"
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_FONT
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_MEDIA
:
{
if
(
internalContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_TRACK
)
{
mimeTypeGuess
=
NS_LITERAL_CSTRING
(
"
text
/
vtt
"
)
;
}
else
{
mimeTypeGuess
=
EmptyCString
(
)
;
}
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
MOZ_ASSERT
(
!
requestingContext
|
|
requestingContext
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
ELEMENT_NODE
"
type_media
requires
requestingContext
of
type
Element
"
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_WEBSOCKET
:
{
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
=
do_QueryInterface
(
aChannel
)
;
MOZ_ASSERT
(
httpChannelInternal
)
;
if
(
httpChannelInternal
)
{
rv
=
httpChannelInternal
-
>
GetProxyURI
(
getter_AddRefs
(
uri
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_CSP_REPORT
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_XSLT
:
{
mimeTypeGuess
=
NS_LITERAL_CSTRING
(
"
application
/
xml
"
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
MOZ_ASSERT
(
!
requestingContext
|
|
requestingContext
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
DOCUMENT_NODE
"
type_xslt
requires
requestingContext
of
type
Document
"
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_BEACON
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
MOZ_ASSERT
(
!
requestingContext
|
|
requestingContext
-
>
NodeType
(
)
=
=
nsIDOMNode
:
:
DOCUMENT_NODE
"
type_beacon
requires
requestingContext
of
type
Document
"
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_FETCH
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_IMAGESET
:
{
mimeTypeGuess
=
EmptyCString
(
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
case
nsIContentPolicy
:
:
TYPE_WEB_MANIFEST
:
{
mimeTypeGuess
=
NS_LITERAL_CSTRING
(
"
application
/
manifest
+
json
"
)
;
requestingContext
=
aLoadInfo
-
>
LoadingNode
(
)
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
can
not
perform
security
check
without
a
valid
contentType
"
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
?
aLoadInfo
-
>
TriggeringPrincipal
(
)
:
aLoadInfo
-
>
LoadingPrincipal
(
)
;
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
rv
=
NS_CheckContentLoadPolicy
(
internalContentPolicyType
uri
principal
requestingContext
mimeTypeGuess
nullptr
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
nsContentUtils
:
:
GetSecurityManager
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
(
NS_SUCCEEDED
(
rv
)
&
&
shouldLoad
=
=
nsIContentPolicy
:
:
REJECT_TYPE
)
&
&
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
)
{
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
return
NS_ERROR_CONTENT_BLOCKED
;
}
if
(
nsMixedContentBlocker
:
:
sSendHSTSPriming
)
{
rv
=
nsMixedContentBlocker
:
:
MarkLoadInfoForPriming
(
uri
requestingContext
aLoadInfo
)
;
return
rv
;
}
return
NS_OK
;
}
nsresult
nsContentSecurityManager
:
:
doContentSecurityCheck
(
nsIChannel
*
aChannel
nsCOMPtr
<
nsIStreamListener
>
&
aInAndOutListener
)
{
NS_ENSURE_ARG
(
aChannel
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
if
(
!
loadInfo
)
{
MOZ_ASSERT
(
false
"
channel
needs
to
have
loadInfo
to
perform
security
checks
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
loadInfo
-
>
GetInitialSecurityCheckDone
(
)
)
{
return
NS_OK
;
}
nsresult
rv
=
ValidateSecurityFlags
(
loadInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadInfo
-
>
SetEnforceSecurity
(
true
)
;
if
(
loadInfo
-
>
GetSecurityMode
(
)
=
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
)
{
rv
=
DoCORSChecks
(
aChannel
loadInfo
aInAndOutListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
CheckChannel
(
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
DoContentSecurityChecks
(
aChannel
loadInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
loadInfo
-
>
SetInitialSecurityCheckDone
(
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsContentSecurityManager
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aRedirFlags
nsIAsyncVerifyRedirectCallback
*
aCb
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aOldChannel
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
&
&
loadInfo
-
>
GetEnforceSecurity
(
)
)
{
nsresult
rv
=
CheckChannel
(
aNewChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
aOldChannel
-
>
Cancel
(
rv
)
;
return
rv
;
}
}
nsCOMPtr
<
nsIPrincipal
>
oldPrincipal
;
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
aOldChannel
getter_AddRefs
(
oldPrincipal
)
)
;
nsCOMPtr
<
nsIURI
>
newURI
;
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newURI
)
)
;
nsCOMPtr
<
nsIURI
>
newOriginalURI
;
aNewChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
newOriginalURI
)
)
;
NS_ENSURE_STATE
(
oldPrincipal
&
&
newURI
&
&
newOriginalURI
)
;
const
uint32_t
flags
=
nsIScriptSecurityManager
:
:
LOAD_IS_AUTOMATIC_DOCUMENT_REPLACEMENT
|
nsIScriptSecurityManager
:
:
DISALLOW_SCRIPT
;
nsresult
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIWithPrincipal
(
oldPrincipal
newURI
flags
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
newOriginalURI
!
=
newURI
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIWithPrincipal
(
oldPrincipal
newOriginalURI
flags
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aCb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
static
void
AddLoadFlags
(
nsIRequest
*
aRequest
nsLoadFlags
aNewFlags
)
{
nsLoadFlags
flags
;
aRequest
-
>
GetLoadFlags
(
&
flags
)
;
flags
|
=
aNewFlags
;
aRequest
-
>
SetLoadFlags
(
flags
)
;
}
nsresult
nsContentSecurityManager
:
:
CheckChannel
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
MOZ_ASSERT
(
loadInfo
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsContentPolicyType
contentPolicyType
=
loadInfo
-
>
GetExternalContentPolicyType
(
)
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
uri
)
;
if
(
nestedURI
)
{
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
uri
)
)
;
}
nsCOMPtr
<
nsIURIFixup
>
urifixup
(
do_GetService
(
NS_URIFIXUP_CONTRACTID
&
rv
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
urifixup
)
{
nsCOMPtr
<
nsIURI
>
fixedURI
;
rv
=
urifixup
-
>
CreateExposableURI
(
uri
getter_AddRefs
(
fixedURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
uri
=
fixedURI
;
}
}
}
uint32_t
cookiePolicy
=
loadInfo
-
>
GetCookiePolicy
(
)
;
if
(
cookiePolicy
=
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
)
{
MOZ_ASSERT
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
;
nsIPrincipal
*
loadingPrincipal
=
loadInfo
-
>
LoadingPrincipal
(
)
;
rv
=
loadingPrincipal
-
>
CheckMayLoad
(
uri
false
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
AddLoadFlags
(
aChannel
nsIRequest
:
:
LOAD_ANONYMOUS
)
;
}
}
else
if
(
cookiePolicy
=
=
nsILoadInfo
:
:
SEC_COOKIES_OMIT
)
{
AddLoadFlags
(
aChannel
nsIRequest
:
:
LOAD_ANONYMOUS
)
;
}
nsSecurityFlags
securityMode
=
loadInfo
-
>
GetSecurityMode
(
)
;
if
(
securityMode
=
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
)
{
if
(
NS_HasBeenCrossOrigin
(
aChannel
)
)
{
loadInfo
-
>
MaybeIncreaseTainting
(
LoadTainting
:
:
CORS
)
;
}
return
NS_OK
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
loadInfo
-
>
TriggeringPrincipal
(
)
)
&
&
loadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
&
&
loadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
{
return
NS_OK
;
}
if
(
(
securityMode
=
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
)
|
|
(
securityMode
=
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
)
)
{
rv
=
DoSOPChecks
(
uri
loadInfo
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
(
securityMode
=
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
)
|
|
(
securityMode
=
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
)
)
{
if
(
NS_HasBeenCrossOrigin
(
aChannel
)
)
{
loadInfo
-
>
MaybeIncreaseTainting
(
LoadTainting
:
:
Opaque
)
;
}
rv
=
DoCheckLoadURIChecks
(
uri
loadInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsContentSecurityManager
:
:
PerformSecurityCheck
(
nsIChannel
*
aChannel
nsIStreamListener
*
aStreamListener
nsIStreamListener
*
*
outStreamListener
)
{
nsCOMPtr
<
nsIStreamListener
>
inAndOutListener
=
aStreamListener
;
nsresult
rv
=
doContentSecurityCheck
(
aChannel
inAndOutListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
inAndOutListener
.
forget
(
outStreamListener
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsContentSecurityManager
:
:
IsOriginPotentiallyTrustworthy
(
nsIPrincipal
*
aPrincipal
bool
*
aIsTrustWorthy
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_ARG_POINTER
(
aIsTrustWorthy
)
;
if
(
aPrincipal
-
>
GetIsSystemPrincipal
(
)
)
{
*
aIsTrustWorthy
=
true
;
return
NS_OK
;
}
*
aIsTrustWorthy
=
false
;
if
(
aPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
aPrincipal
-
>
GetIsCodebasePrincipal
(
)
"
Nobody
is
expected
to
call
us
with
an
nsIExpandedPrincipal
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
scheme
;
nsresult
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
NS_WARNING_ASSERTION
(
!
scheme
.
EqualsLiteral
(
"
blob
"
)
"
IsOriginPotentiallyTrustworthy
ignoring
blob
scheme
"
)
;
if
(
scheme
.
EqualsLiteral
(
"
https
"
)
|
|
scheme
.
EqualsLiteral
(
"
file
"
)
|
|
scheme
.
EqualsLiteral
(
"
resource
"
)
|
|
scheme
.
EqualsLiteral
(
"
app
"
)
|
|
scheme
.
EqualsLiteral
(
"
moz
-
extension
"
)
|
|
scheme
.
EqualsLiteral
(
"
wss
"
)
)
{
*
aIsTrustWorthy
=
true
;
return
NS_OK
;
}
nsAutoCString
host
;
rv
=
uri
-
>
GetHost
(
host
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
if
(
host
.
Equals
(
"
127
.
0
.
0
.
1
"
)
|
|
host
.
Equals
(
"
localhost
"
)
|
|
host
.
Equals
(
"
:
:
1
"
)
)
{
*
aIsTrustWorthy
=
true
;
return
NS_OK
;
}
if
(
scheme
.
EqualsLiteral
(
"
http
"
)
|
|
scheme
.
EqualsLiteral
(
"
ws
"
)
)
{
nsAdoptingCString
whitelist
=
Preferences
:
:
GetCString
(
"
dom
.
securecontext
.
whitelist
"
)
;
if
(
whitelist
)
{
nsCCharSeparatedTokenizer
tokenizer
(
whitelist
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsCSubstring
&
allowedHost
=
tokenizer
.
nextToken
(
)
;
if
(
host
.
Equals
(
allowedHost
)
)
{
*
aIsTrustWorthy
=
true
;
return
NS_OK
;
}
}
}
}
return
NS_OK
;
}
