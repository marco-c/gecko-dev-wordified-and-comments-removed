#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSPParser
.
h
"
#
include
"
nsCSPUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
LogModule
*
GetCspParserLog
(
)
{
static
LazyLogModule
gCspParserPRLog
(
"
CSPParser
"
)
;
return
gCspParserPRLog
;
}
#
define
CSPPARSERLOG
(
args
)
\
MOZ_LOG
(
GetCspParserLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
CSPPARSERLOGENABLED
(
)
\
MOZ_LOG_TEST
(
GetCspParserLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
)
static
const
uint32_t
kSubHostPathCharacterCutoff
=
512
;
static
const
char
*
const
kHashSourceValidFns
[
]
=
{
"
sha256
"
"
sha384
"
"
sha512
"
}
;
static
const
uint32_t
kHashSourceValidFnsLen
=
3
;
nsCSPParser
:
:
nsCSPParser
(
policyTokens
&
aTokens
nsIURI
*
aSelfURI
nsCSPContext
*
aCSPContext
bool
aDeliveredViaMetaTag
)
:
mCurChar
(
nullptr
)
mEndChar
(
nullptr
)
mHasHashOrNonce
(
false
)
mHasAnyUnsafeEval
(
false
)
mStrictDynamic
(
false
)
mUnsafeInlineKeywordSrc
(
nullptr
)
mChildSrc
(
nullptr
)
mFrameSrc
(
nullptr
)
mWorkerSrc
(
nullptr
)
mScriptSrc
(
nullptr
)
mStyleSrc
(
nullptr
)
mParsingFrameAncestorsDir
(
false
)
mTokens
(
aTokens
.
Clone
(
)
)
mSelfURI
(
aSelfURI
)
mPolicy
(
nullptr
)
mCSPContext
(
aCSPContext
)
mDeliveredViaMetaTag
(
aDeliveredViaMetaTag
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
nsCSPParser
"
)
)
;
}
nsCSPParser
:
:
~
nsCSPParser
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
~
nsCSPParser
"
)
)
;
}
static
bool
isCharacterToken
(
char16_t
aSymbol
)
{
return
(
aSymbol
>
=
'
a
'
&
&
aSymbol
<
=
'
z
'
)
|
|
(
aSymbol
>
=
'
A
'
&
&
aSymbol
<
=
'
Z
'
)
;
}
bool
isNumberToken
(
char16_t
aSymbol
)
{
return
(
aSymbol
>
=
'
0
'
&
&
aSymbol
<
=
'
9
'
)
;
}
bool
isValidHexDig
(
char16_t
aHexDig
)
{
return
(
isNumberToken
(
aHexDig
)
|
|
(
aHexDig
>
=
'
A
'
&
&
aHexDig
<
=
'
F
'
)
|
|
(
aHexDig
>
=
'
a
'
&
&
aHexDig
<
=
'
f
'
)
)
;
}
static
bool
isValidBase64Value
(
const
char16_t
*
cur
const
char16_t
*
end
)
{
if
(
end
>
cur
&
&
*
(
end
-
1
)
=
=
EQUALS
)
end
-
-
;
if
(
end
>
cur
&
&
*
(
end
-
1
)
=
=
EQUALS
)
end
-
-
;
if
(
end
=
=
cur
)
{
return
false
;
}
for
(
;
cur
<
end
;
+
+
cur
)
{
if
(
!
(
isCharacterToken
(
*
cur
)
|
|
isNumberToken
(
*
cur
)
|
|
*
cur
=
=
PLUS
|
|
*
cur
=
=
SLASH
|
|
*
cur
=
=
DASH
|
|
*
cur
=
=
UNDERLINE
)
)
{
return
false
;
}
}
return
true
;
}
void
nsCSPParser
:
:
resetCurChar
(
const
nsAString
&
aToken
)
{
mCurChar
=
aToken
.
BeginReading
(
)
;
mEndChar
=
aToken
.
EndReading
(
)
;
resetCurValue
(
)
;
}
bool
nsCSPParser
:
:
atEndOfPath
(
)
{
return
(
atEnd
(
)
|
|
peek
(
QUESTIONMARK
)
|
|
peek
(
NUMBER_SIGN
)
)
;
}
bool
nsCSPParser
:
:
atValidUnreservedChar
(
)
{
return
(
peek
(
isCharacterToken
)
|
|
peek
(
isNumberToken
)
|
|
peek
(
DASH
)
|
|
peek
(
DOT
)
|
|
peek
(
UNDERLINE
)
|
|
peek
(
TILDE
)
)
;
}
bool
nsCSPParser
:
:
atValidSubDelimChar
(
)
{
return
(
peek
(
EXCLAMATION
)
|
|
peek
(
DOLLAR
)
|
|
peek
(
AMPERSAND
)
|
|
peek
(
SINGLEQUOTE
)
|
|
peek
(
OPENBRACE
)
|
|
peek
(
CLOSINGBRACE
)
|
|
peek
(
WILDCARD
)
|
|
peek
(
PLUS
)
|
|
peek
(
EQUALS
)
)
;
}
bool
nsCSPParser
:
:
atValidPctEncodedChar
(
)
{
const
char16_t
*
pctCurChar
=
mCurChar
;
if
(
(
pctCurChar
+
2
)
>
=
mEndChar
)
{
return
false
;
}
if
(
PERCENT_SIGN
!
=
*
pctCurChar
|
|
!
isValidHexDig
(
*
(
pctCurChar
+
1
)
)
|
|
!
isValidHexDig
(
*
(
pctCurChar
+
2
)
)
)
{
return
false
;
}
return
true
;
}
bool
nsCSPParser
:
:
atValidPathChar
(
)
{
return
(
atValidUnreservedChar
(
)
|
|
atValidSubDelimChar
(
)
|
|
atValidPctEncodedChar
(
)
|
|
peek
(
COLON
)
|
|
peek
(
ATSYMBOL
)
)
;
}
void
nsCSPParser
:
:
logWarningErrorToConsole
(
uint32_t
aSeverityFlag
const
char
*
aProperty
const
nsTArray
<
nsString
>
&
aParams
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
logWarningErrorToConsole
:
%
s
"
aProperty
)
)
;
mCSPContext
-
>
logToConsole
(
aProperty
aParams
u
"
"
_ns
u
"
"
_ns
0
0
aSeverityFlag
)
;
}
bool
nsCSPParser
:
:
hostChar
(
)
{
if
(
atEnd
(
)
)
{
return
false
;
}
return
accept
(
isCharacterToken
)
|
|
accept
(
isNumberToken
)
|
|
accept
(
DASH
)
;
}
bool
nsCSPParser
:
:
schemeChar
(
)
{
if
(
atEnd
(
)
)
{
return
false
;
}
return
accept
(
isCharacterToken
)
|
|
accept
(
isNumberToken
)
|
|
accept
(
PLUS
)
|
|
accept
(
DASH
)
|
|
accept
(
DOT
)
;
}
bool
nsCSPParser
:
:
port
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
port
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
accept
(
COLON
)
;
resetCurValue
(
)
;
if
(
accept
(
WILDCARD
)
)
{
return
true
;
}
if
(
!
accept
(
isNumberToken
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParsePort
"
params
)
;
return
false
;
}
while
(
accept
(
isNumberToken
)
)
{
}
return
true
;
}
bool
nsCSPParser
:
:
subPath
(
nsCSPHostSrc
*
aCspHost
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
subPath
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
uint32_t
charCounter
=
0
;
nsString
pctDecodedSubPath
;
while
(
!
atEndOfPath
(
)
)
{
if
(
peek
(
SLASH
)
)
{
CSP_PercentDecodeStr
(
mCurValue
pctDecodedSubPath
)
;
aCspHost
-
>
appendPath
(
pctDecodedSubPath
)
;
resetCurValue
(
)
;
}
else
if
(
!
atValidPathChar
(
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParseInvalidSource
"
params
)
;
return
false
;
}
if
(
peek
(
PERCENT_SIGN
)
)
{
advance
(
)
;
advance
(
)
;
}
advance
(
)
;
if
(
+
+
charCounter
>
kSubHostPathCharacterCutoff
)
{
return
false
;
}
}
CSP_PercentDecodeStr
(
mCurValue
pctDecodedSubPath
)
;
aCspHost
-
>
appendPath
(
pctDecodedSubPath
)
;
resetCurValue
(
)
;
return
true
;
}
bool
nsCSPParser
:
:
path
(
nsCSPHostSrc
*
aCspHost
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
path
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
resetCurValue
(
)
;
if
(
!
accept
(
SLASH
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParseInvalidSource
"
params
)
;
return
false
;
}
if
(
atEndOfPath
(
)
)
{
aCspHost
-
>
appendPath
(
u
"
/
"
_ns
)
;
return
true
;
}
if
(
peek
(
SLASH
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParseInvalidSource
"
params
)
;
return
false
;
}
return
subPath
(
aCspHost
)
;
}
bool
nsCSPParser
:
:
subHost
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
subHost
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
uint32_t
charCounter
=
0
;
while
(
!
atEndOfPath
(
)
&
&
!
peek
(
COLON
)
&
&
!
peek
(
SLASH
)
)
{
+
+
charCounter
;
while
(
hostChar
(
)
)
{
+
+
charCounter
;
}
if
(
accept
(
DOT
)
&
&
!
hostChar
(
)
)
{
return
false
;
}
if
(
charCounter
>
kSubHostPathCharacterCutoff
)
{
return
false
;
}
}
return
true
;
}
nsCSPHostSrc
*
nsCSPParser
:
:
host
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
host
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
accept
(
WILDCARD
)
)
{
if
(
atEnd
(
)
|
|
peek
(
COLON
)
)
{
return
new
nsCSPHostSrc
(
mCurValue
)
;
}
if
(
!
accept
(
DOT
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParseInvalidHost
"
params
)
;
return
nullptr
;
}
}
if
(
!
hostChar
(
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParseInvalidHost
"
params
)
;
return
nullptr
;
}
if
(
!
subHost
(
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParseInvalidHost
"
params
)
;
return
nullptr
;
}
if
(
CSP_IsQuotelessKeyword
(
mCurValue
)
)
{
nsString
keyword
=
mCurValue
;
ToLowerCase
(
keyword
)
;
AutoTArray
<
nsString
2
>
params
=
{
mCurToken
keyword
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
hostNameMightBeKeyword
"
params
)
;
}
return
new
nsCSPHostSrc
(
mCurValue
)
;
}
nsCSPBaseSrc
*
nsCSPParser
:
:
keywordSource
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
keywordSource
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
CSP_IsKeyword
(
mCurToken
CSP_SELF
)
)
{
return
CSP_CreateHostSrcFromSelfURI
(
mSelfURI
)
;
}
if
(
CSP_IsKeyword
(
mCurToken
CSP_REPORT_SAMPLE
)
)
{
return
new
nsCSPKeywordSrc
(
CSP_UTF16KeywordToEnum
(
mCurToken
)
)
;
}
if
(
CSP_IsKeyword
(
mCurToken
CSP_STRICT_DYNAMIC
)
)
{
if
(
!
CSP_IsDirective
(
mCurDir
[
0
]
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
)
&
&
!
CSP_IsDirective
(
mCurDir
[
0
]
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
&
&
!
CSP_IsDirective
(
mCurDir
[
0
]
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
u
"
strict
-
dynamic
"
_ns
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringStrictDynamic
"
params
)
;
return
nullptr
;
}
mStrictDynamic
=
true
;
return
new
nsCSPKeywordSrc
(
CSP_UTF16KeywordToEnum
(
mCurToken
)
)
;
}
if
(
CSP_IsKeyword
(
mCurToken
CSP_UNSAFE_INLINE
)
)
{
nsWeakPtr
ctx
=
mCSPContext
-
>
GetLoadingContext
(
)
;
nsCOMPtr
<
Document
>
doc
=
do_QueryReferent
(
ctx
)
;
if
(
doc
)
{
doc
-
>
SetHasUnsafeInlineCSP
(
true
)
;
}
if
(
mUnsafeInlineKeywordSrc
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringDuplicateSrc
"
params
)
;
return
nullptr
;
}
mUnsafeInlineKeywordSrc
=
new
nsCSPKeywordSrc
(
CSP_UTF16KeywordToEnum
(
mCurToken
)
)
;
return
mUnsafeInlineKeywordSrc
;
}
if
(
CSP_IsKeyword
(
mCurToken
CSP_UNSAFE_EVAL
)
)
{
nsWeakPtr
ctx
=
mCSPContext
-
>
GetLoadingContext
(
)
;
nsCOMPtr
<
Document
>
doc
=
do_QueryReferent
(
ctx
)
;
if
(
doc
)
{
doc
-
>
SetHasUnsafeEvalCSP
(
true
)
;
}
mHasAnyUnsafeEval
=
true
;
return
new
nsCSPKeywordSrc
(
CSP_UTF16KeywordToEnum
(
mCurToken
)
)
;
}
if
(
StaticPrefs
:
:
security_csp_wasm_unsafe_eval_enabled
(
)
&
&
CSP_IsKeyword
(
mCurToken
CSP_WASM_UNSAFE_EVAL
)
)
{
mHasAnyUnsafeEval
=
true
;
return
new
nsCSPKeywordSrc
(
CSP_UTF16KeywordToEnum
(
mCurToken
)
)
;
}
if
(
CSP_IsKeyword
(
mCurToken
CSP_UNSAFE_ALLOW_REDIRECTS
)
)
{
if
(
!
CSP_IsDirective
(
mCurDir
[
0
]
nsIContentSecurityPolicy
:
:
NAVIGATE_TO_DIRECTIVE
)
)
{
AutoTArray
<
nsString
2
>
params
=
{
u
"
unsafe
-
allow
-
redirects
"
_ns
u
"
navigate
-
to
"
_ns
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
IgnoringSourceWithinDirective
"
params
)
;
return
nullptr
;
}
return
new
nsCSPKeywordSrc
(
CSP_UTF16KeywordToEnum
(
mCurToken
)
)
;
}
return
nullptr
;
}
nsCSPHostSrc
*
nsCSPParser
:
:
hostSource
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
hostSource
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
nsCSPHostSrc
*
cspHost
=
host
(
)
;
if
(
!
cspHost
)
{
return
nullptr
;
}
if
(
peek
(
COLON
)
)
{
if
(
!
port
(
)
)
{
delete
cspHost
;
return
nullptr
;
}
cspHost
-
>
setPort
(
mCurValue
)
;
}
if
(
atEndOfPath
(
)
)
{
return
cspHost
;
}
if
(
!
path
(
cspHost
)
)
{
delete
cspHost
;
return
nullptr
;
}
return
cspHost
;
}
nsCSPSchemeSrc
*
nsCSPParser
:
:
schemeSource
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
schemeSource
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
!
accept
(
isCharacterToken
)
)
{
return
nullptr
;
}
while
(
schemeChar
(
)
)
{
}
nsString
scheme
=
mCurValue
;
if
(
!
accept
(
COLON
)
)
{
return
nullptr
;
}
if
(
peek
(
isNumberToken
)
|
|
peek
(
WILDCARD
)
)
{
return
nullptr
;
}
return
new
nsCSPSchemeSrc
(
scheme
)
;
}
nsCSPNonceSrc
*
nsCSPParser
:
:
nonceSource
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
nonceSource
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
!
StringBeginsWith
(
mCurToken
nsDependentString
(
CSP_EnumToUTF16Keyword
(
CSP_NONCE
)
)
nsASCIICaseInsensitiveStringComparator
)
|
|
mCurToken
.
Last
(
)
!
=
SINGLEQUOTE
)
{
return
nullptr
;
}
const
nsAString
&
expr
=
Substring
(
mCurToken
1
mCurToken
.
Length
(
)
-
2
)
;
int32_t
dashIndex
=
expr
.
FindChar
(
DASH
)
;
if
(
dashIndex
<
0
)
{
return
nullptr
;
}
if
(
!
isValidBase64Value
(
expr
.
BeginReading
(
)
+
dashIndex
+
1
expr
.
EndReading
(
)
)
)
{
return
nullptr
;
}
mHasHashOrNonce
=
true
;
return
new
nsCSPNonceSrc
(
Substring
(
expr
dashIndex
+
1
expr
.
Length
(
)
-
dashIndex
+
1
)
)
;
}
nsCSPHashSrc
*
nsCSPParser
:
:
hashSource
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
hashSource
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
mCurToken
.
First
(
)
!
=
SINGLEQUOTE
|
|
mCurToken
.
Last
(
)
!
=
SINGLEQUOTE
)
{
return
nullptr
;
}
const
nsAString
&
expr
=
Substring
(
mCurToken
1
mCurToken
.
Length
(
)
-
2
)
;
int32_t
dashIndex
=
expr
.
FindChar
(
DASH
)
;
if
(
dashIndex
<
0
)
{
return
nullptr
;
}
if
(
!
isValidBase64Value
(
expr
.
BeginReading
(
)
+
dashIndex
+
1
expr
.
EndReading
(
)
)
)
{
return
nullptr
;
}
nsAutoString
algo
(
Substring
(
expr
0
dashIndex
)
)
;
nsAutoString
hash
(
Substring
(
expr
dashIndex
+
1
expr
.
Length
(
)
-
dashIndex
+
1
)
)
;
for
(
uint32_t
i
=
0
;
i
<
kHashSourceValidFnsLen
;
i
+
+
)
{
if
(
algo
.
LowerCaseEqualsASCII
(
kHashSourceValidFns
[
i
]
)
)
{
mHasHashOrNonce
=
true
;
return
new
nsCSPHashSrc
(
algo
hash
)
;
}
}
return
nullptr
;
}
nsCSPBaseSrc
*
nsCSPParser
:
:
sourceExpression
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
sourceExpression
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
nsCSPBaseSrc
*
cspKeyword
=
keywordSource
(
)
)
{
return
cspKeyword
;
}
if
(
nsCSPNonceSrc
*
cspNonce
=
nonceSource
(
)
)
{
return
cspNonce
;
}
if
(
nsCSPHashSrc
*
cspHash
=
hashSource
(
)
)
{
return
cspHash
;
}
if
(
mCurToken
.
EqualsASCII
(
"
*
"
)
)
{
return
new
nsCSPHostSrc
(
u
"
*
"
_ns
)
;
}
resetCurChar
(
mCurToken
)
;
nsAutoString
parsedScheme
;
if
(
nsCSPSchemeSrc
*
cspScheme
=
schemeSource
(
)
)
{
if
(
atEnd
(
)
)
{
return
cspScheme
;
}
cspScheme
-
>
toString
(
parsedScheme
)
;
parsedScheme
.
Trim
(
"
:
"
false
true
)
;
delete
cspScheme
;
if
(
!
accept
(
SLASH
)
|
|
!
accept
(
SLASH
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
failedToParseUnrecognizedSource
"
params
)
;
return
nullptr
;
}
}
resetCurValue
(
)
;
if
(
parsedScheme
.
IsEmpty
(
)
)
{
resetCurChar
(
mCurToken
)
;
nsAutoCString
selfScheme
;
mSelfURI
-
>
GetScheme
(
selfScheme
)
;
parsedScheme
.
AssignASCII
(
selfScheme
.
get
(
)
)
;
}
if
(
nsCSPHostSrc
*
cspHost
=
hostSource
(
)
)
{
cspHost
-
>
setScheme
(
parsedScheme
)
;
cspHost
-
>
setWithinFrameAncestorsDir
(
mParsingFrameAncestorsDir
)
;
return
cspHost
;
}
return
nullptr
;
}
void
nsCSPParser
:
:
sourceList
(
nsTArray
<
nsCSPBaseSrc
*
>
&
outSrcs
)
{
bool
isNone
=
false
;
for
(
uint32_t
i
=
1
;
i
<
mCurDir
.
Length
(
)
;
i
+
+
)
{
mCurToken
=
mCurDir
[
i
]
;
resetCurValue
(
)
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
sourceList
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
CSP_IsKeyword
(
mCurToken
CSP_NONE
)
)
{
isNone
=
true
;
continue
;
}
nsCSPBaseSrc
*
src
=
sourceExpression
(
)
;
if
(
src
)
{
outSrcs
.
AppendElement
(
src
)
;
}
}
if
(
isNone
)
{
if
(
outSrcs
.
IsEmpty
(
)
|
|
(
outSrcs
.
Length
(
)
=
=
1
&
&
outSrcs
[
0
]
-
>
isReportSample
(
)
)
)
{
nsCSPKeywordSrc
*
keyword
=
new
nsCSPKeywordSrc
(
CSP_NONE
)
;
outSrcs
.
InsertElementAt
(
0
keyword
)
;
}
else
{
AutoTArray
<
nsString
1
>
params
;
params
.
AppendElement
(
CSP_EnumToUTF16Keyword
(
CSP_NONE
)
)
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringUnknownOption
"
params
)
;
}
}
}
void
nsCSPParser
:
:
reportURIList
(
nsCSPDirective
*
aDir
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
reportURIList
"
)
)
;
nsTArray
<
nsCSPBaseSrc
*
>
srcs
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
;
for
(
uint32_t
i
=
1
;
i
<
mCurDir
.
Length
(
)
;
i
+
+
)
{
mCurToken
=
mCurDir
[
i
]
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
reportURIList
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
mCurToken
"
"
mSelfURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldNotParseReportURI
"
params
)
;
continue
;
}
nsCSPReportURI
*
reportURI
=
new
nsCSPReportURI
(
uri
)
;
srcs
.
AppendElement
(
reportURI
)
;
}
if
(
srcs
.
Length
(
)
=
=
0
)
{
AutoTArray
<
nsString
1
>
directiveName
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringDirectiveWithNoValues
"
directiveName
)
;
delete
aDir
;
return
;
}
aDir
-
>
addSrcs
(
srcs
)
;
mPolicy
-
>
addDirective
(
aDir
)
;
}
void
nsCSPParser
:
:
sandboxFlagList
(
nsCSPDirective
*
aDir
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
sandboxFlagList
"
)
)
;
nsAutoString
flags
;
for
(
uint32_t
i
=
1
;
i
<
mCurDir
.
Length
(
)
;
i
+
+
)
{
mCurToken
=
mCurDir
[
i
]
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
sandboxFlagList
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
!
nsContentUtils
:
:
IsValidSandboxFlag
(
mCurToken
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldntParseInvalidSandboxFlag
"
params
)
;
continue
;
}
flags
.
Append
(
mCurToken
)
;
if
(
i
!
=
mCurDir
.
Length
(
)
-
1
)
{
flags
.
AppendLiteral
(
"
"
)
;
}
}
nsTArray
<
nsCSPBaseSrc
*
>
srcs
;
srcs
.
AppendElement
(
new
nsCSPSandboxFlags
(
flags
)
)
;
aDir
-
>
addSrcs
(
srcs
)
;
mPolicy
-
>
addDirective
(
aDir
)
;
}
void
nsCSPParser
:
:
directiveValue
(
nsTArray
<
nsCSPBaseSrc
*
>
&
outSrcs
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
directiveValue
"
)
)
;
sourceList
(
outSrcs
)
;
}
nsCSPDirective
*
nsCSPParser
:
:
directiveName
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
directiveName
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
CSPDirective
directive
=
CSP_StringToCSPDirective
(
mCurToken
)
;
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
NO_DIRECTIVE
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldNotProcessUnknownDirective
"
params
)
;
return
nullptr
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
REFLECTED_XSS_DIRECTIVE
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
notSupportingDirective
"
params
)
;
return
nullptr
;
}
if
(
(
(
directive
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
|
|
directive
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
&
&
!
StaticPrefs
:
:
security_csp_script_src_attr_elem_enabled
(
)
)
|
|
(
(
directive
=
=
nsIContentSecurityPolicy
:
:
STYLE_SRC_ATTR_DIRECTIVE
|
|
directive
=
=
nsIContentSecurityPolicy
:
:
STYLE_SRC_ELEM_DIRECTIVE
)
&
&
!
StaticPrefs
:
:
security_csp_style_src_attr_elem_enabled
(
)
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
notSupportingDirective
"
params
)
;
return
nullptr
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
NAVIGATE_TO_DIRECTIVE
&
&
!
StaticPrefs
:
:
security_csp_enableNavigateTo
(
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
couldNotProcessUnknownDirective
"
params
)
;
return
nullptr
;
}
if
(
mPolicy
-
>
hasDirective
(
directive
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
duplicateDirective
"
params
)
;
return
nullptr
;
}
if
(
mDeliveredViaMetaTag
&
&
(
(
directive
=
=
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
|
|
(
directive
=
=
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
)
|
|
(
directive
=
=
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
)
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurToken
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringSrcFromMetaCSP
"
params
)
;
return
nullptr
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
{
return
new
nsBlockAllMixedContentDirective
(
directive
)
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
{
return
new
nsUpgradeInsecureDirective
(
directive
)
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
CHILD_SRC_DIRECTIVE
)
{
mChildSrc
=
new
nsCSPChildSrcDirective
(
directive
)
;
return
mChildSrc
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
FRAME_SRC_DIRECTIVE
)
{
mFrameSrc
=
new
nsCSPDirective
(
directive
)
;
return
mFrameSrc
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
WORKER_SRC_DIRECTIVE
)
{
mWorkerSrc
=
new
nsCSPDirective
(
directive
)
;
return
mWorkerSrc
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
)
{
mScriptSrc
=
new
nsCSPScriptSrcDirective
(
directive
)
;
return
mScriptSrc
;
}
if
(
directive
=
=
nsIContentSecurityPolicy
:
:
STYLE_SRC_DIRECTIVE
)
{
mStyleSrc
=
new
nsCSPStyleSrcDirective
(
directive
)
;
return
mStyleSrc
;
}
return
new
nsCSPDirective
(
directive
)
;
}
void
nsCSPParser
:
:
directive
(
)
{
mCurToken
=
mCurDir
[
0
]
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
directive
mCurToken
:
%
s
mCurValue
:
%
s
"
NS_ConvertUTF16toUTF8
(
mCurToken
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
mCurValue
)
.
get
(
)
)
)
;
if
(
mCurDir
.
Length
(
)
<
1
)
{
AutoTArray
<
nsString
1
>
params
=
{
u
"
directive
missing
"
_ns
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
failedToParseUnrecognizedSource
"
params
)
;
return
;
}
if
(
CSP_IsEmptyDirective
(
mCurValue
mCurToken
)
)
{
return
;
}
nsCSPDirective
*
cspDir
=
directiveName
(
)
;
if
(
!
cspDir
)
{
return
;
}
if
(
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
BLOCK_ALL_MIXED_CONTENT
)
)
{
if
(
mCurDir
.
Length
(
)
>
1
)
{
AutoTArray
<
nsString
1
>
params
=
{
u
"
block
-
all
-
mixed
-
content
"
_ns
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoreSrcForDirective
"
params
)
;
}
mPolicy
-
>
addDirective
(
cspDir
)
;
return
;
}
if
(
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
UPGRADE_IF_INSECURE_DIRECTIVE
)
)
{
if
(
mCurDir
.
Length
(
)
>
1
)
{
AutoTArray
<
nsString
1
>
params
=
{
u
"
upgrade
-
insecure
-
requests
"
_ns
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoreSrcForDirective
"
params
)
;
}
mPolicy
-
>
addUpgradeInsecDir
(
static_cast
<
nsUpgradeInsecureDirective
*
>
(
cspDir
)
)
;
return
;
}
if
(
CSP_IsDirective
(
mCurDir
[
0
]
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
)
{
reportURIList
(
cspDir
)
;
return
;
}
if
(
CSP_IsDirective
(
mCurDir
[
0
]
nsIContentSecurityPolicy
:
:
SANDBOX_DIRECTIVE
)
)
{
sandboxFlagList
(
cspDir
)
;
return
;
}
mHasHashOrNonce
=
false
;
mHasAnyUnsafeEval
=
false
;
mStrictDynamic
=
false
;
mUnsafeInlineKeywordSrc
=
nullptr
;
mParsingFrameAncestorsDir
=
CSP_IsDirective
(
mCurDir
[
0
]
nsIContentSecurityPolicy
:
:
FRAME_ANCESTORS_DIRECTIVE
)
;
nsTArray
<
nsCSPBaseSrc
*
>
srcs
;
directiveValue
(
srcs
)
;
if
(
srcs
.
IsEmpty
(
)
|
|
(
srcs
.
Length
(
)
=
=
1
&
&
srcs
[
0
]
-
>
isReportSample
(
)
)
)
{
nsCSPKeywordSrc
*
keyword
=
new
nsCSPKeywordSrc
(
CSP_NONE
)
;
srcs
.
InsertElementAt
(
0
keyword
)
;
}
if
(
mStrictDynamic
)
{
MOZ_ASSERT
(
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
)
|
|
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
|
|
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
"
strict
-
dynamic
only
allowed
within
script
-
src
(
-
elem
|
attr
)
"
)
;
for
(
uint32_t
i
=
0
;
i
<
srcs
.
Length
(
)
;
i
+
+
)
{
srcs
[
i
]
-
>
invalidate
(
)
;
nsAutoString
srcStr
;
srcs
[
i
]
-
>
toString
(
srcStr
)
;
if
(
!
srcStr
.
EqualsASCII
(
CSP_EnumToUTF8Keyword
(
CSP_STRICT_DYNAMIC
)
)
&
&
!
srcStr
.
EqualsASCII
(
CSP_EnumToUTF8Keyword
(
CSP_UNSAFE_EVAL
)
)
&
&
!
StringBeginsWith
(
srcStr
nsDependentString
(
CSP_EnumToUTF16Keyword
(
CSP_NONCE
)
)
)
&
&
!
StringBeginsWith
(
srcStr
u
"
'
sha
"
_ns
)
)
{
AutoTArray
<
nsString
2
>
params
=
{
srcStr
mCurDir
[
0
]
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringScriptSrcForStrictDynamic
"
params
)
;
}
}
if
(
!
mHasHashOrNonce
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurDir
[
0
]
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
strictDynamicButNoHashOrNonce
"
params
)
;
}
}
else
if
(
mHasHashOrNonce
&
&
mUnsafeInlineKeywordSrc
&
&
(
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
)
|
|
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
|
|
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
|
|
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
STYLE_SRC_DIRECTIVE
)
)
)
{
mUnsafeInlineKeywordSrc
-
>
invalidate
(
)
;
AutoTArray
<
nsString
2
>
params
=
{
u
"
'
unsafe
-
inline
'
"
_ns
mCurDir
[
0
]
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringSrcWithinNonceOrHashDirective
"
params
)
;
}
if
(
mHasAnyUnsafeEval
&
&
(
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
|
|
cspDir
-
>
equals
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
)
)
{
AutoTArray
<
nsString
1
>
params
=
{
mCurDir
[
0
]
}
;
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
ignoringUnsafeEval
"
params
)
;
}
cspDir
-
>
addSrcs
(
srcs
)
;
mPolicy
-
>
addDirective
(
cspDir
)
;
}
nsCSPPolicy
*
nsCSPParser
:
:
policy
(
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
policy
"
)
)
;
mPolicy
=
new
nsCSPPolicy
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mTokens
.
Length
(
)
;
i
+
+
)
{
mCurDir
=
mTokens
[
i
]
.
Clone
(
)
;
directive
(
)
;
}
if
(
mChildSrc
)
{
if
(
!
mFrameSrc
)
{
mChildSrc
-
>
setRestrictFrames
(
)
;
}
if
(
!
mWorkerSrc
)
{
mChildSrc
-
>
setRestrictWorkers
(
)
;
}
}
if
(
mScriptSrc
&
&
!
mWorkerSrc
&
&
!
mChildSrc
)
{
mScriptSrc
-
>
setRestrictWorkers
(
)
;
}
if
(
mScriptSrc
&
&
!
mPolicy
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
)
)
{
mScriptSrc
-
>
setRestrictScriptElem
(
)
;
}
if
(
mScriptSrc
&
&
!
mPolicy
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ATTR_DIRECTIVE
)
)
{
mScriptSrc
-
>
setRestrictScriptAttr
(
)
;
}
if
(
mStyleSrc
&
&
!
mPolicy
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
STYLE_SRC_ELEM_DIRECTIVE
)
)
{
mStyleSrc
-
>
setRestrictStyleElem
(
)
;
}
if
(
mStyleSrc
&
&
!
mPolicy
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
STYLE_SRC_ATTR_DIRECTIVE
)
)
{
mStyleSrc
-
>
setRestrictStyleAttr
(
)
;
}
return
mPolicy
;
}
nsCSPPolicy
*
nsCSPParser
:
:
parseContentSecurityPolicy
(
const
nsAString
&
aPolicyString
nsIURI
*
aSelfURI
bool
aReportOnly
nsCSPContext
*
aCSPContext
bool
aDeliveredViaMetaTag
)
{
if
(
CSPPARSERLOGENABLED
(
)
)
{
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
parseContentSecurityPolicy
policy
:
%
s
"
NS_ConvertUTF16toUTF8
(
aPolicyString
)
.
get
(
)
)
)
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
parseContentSecurityPolicy
selfURI
:
%
s
"
aSelfURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
parseContentSecurityPolicy
reportOnly
:
%
s
"
(
aReportOnly
?
"
true
"
:
"
false
"
)
)
)
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
parseContentSecurityPolicy
deliveredViaMetaTag
:
%
s
"
(
aDeliveredViaMetaTag
?
"
true
"
:
"
false
"
)
)
)
;
}
NS_ASSERTION
(
aSelfURI
"
Can
not
parseContentSecurityPolicy
without
aSelfURI
"
)
;
nsTArray
<
CopyableTArray
<
nsString
>
>
tokens
;
PolicyTokenizer
:
:
tokenizePolicy
(
aPolicyString
tokens
)
;
nsCSPParser
parser
(
tokens
aSelfURI
aCSPContext
aDeliveredViaMetaTag
)
;
nsCSPPolicy
*
policy
=
parser
.
policy
(
)
;
if
(
aReportOnly
)
{
policy
-
>
setReportOnlyFlag
(
true
)
;
if
(
!
policy
-
>
hasDirective
(
nsIContentSecurityPolicy
:
:
REPORT_URI_DIRECTIVE
)
)
{
nsAutoCString
prePath
;
nsresult
rv
=
aSelfURI
-
>
GetPrePath
(
prePath
)
;
NS_ENSURE_SUCCESS
(
rv
policy
)
;
AutoTArray
<
nsString
1
>
params
;
CopyUTF8toUTF16
(
prePath
*
params
.
AppendElement
(
)
)
;
parser
.
logWarningErrorToConsole
(
nsIScriptError
:
:
warningFlag
"
reportURInotInReportOnlyHeader
"
params
)
;
}
}
policy
-
>
setDeliveredViaMetaTagFlag
(
aDeliveredViaMetaTag
)
;
if
(
policy
-
>
getNumDirectives
(
)
=
=
0
)
{
delete
policy
;
return
nullptr
;
}
if
(
CSPPARSERLOGENABLED
(
)
)
{
nsString
parsedPolicy
;
policy
-
>
toString
(
parsedPolicy
)
;
CSPPARSERLOG
(
(
"
nsCSPParser
:
:
parseContentSecurityPolicy
parsedPolicy
:
%
s
"
NS_ConvertUTF16toUTF8
(
parsedPolicy
)
.
get
(
)
)
)
;
}
return
policy
;
}
