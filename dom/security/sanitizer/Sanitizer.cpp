#
include
"
Sanitizer
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTemplateElement
.
h
"
#
include
"
mozilla
/
dom
/
SanitizerBinding
.
h
"
#
include
"
mozilla
/
dom
/
SanitizerDefaultConfig
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
namespace
mozilla
:
:
dom
{
using
namespace
sanitizer
;
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
Sanitizer
mGlobal
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Sanitizer
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
Sanitizer
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Sanitizer
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
using
ElementsWithAttributes
=
nsTHashMap
<
const
nsStaticAtom
*
UniquePtr
<
StaticAtomSet
>
>
;
StaticAutoPtr
<
ElementsWithAttributes
>
sDefaultHTMLElements
;
StaticAutoPtr
<
ElementsWithAttributes
>
sDefaultMathMLElements
;
StaticAutoPtr
<
ElementsWithAttributes
>
sDefaultSVGElements
;
StaticAutoPtr
<
StaticAtomSet
>
sDefaultAttributes
;
JSObject
*
Sanitizer
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Sanitizer_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
Sanitizer
>
Sanitizer
:
:
GetInstance
(
nsIGlobalObject
*
aGlobal
const
OwningSanitizerOrSanitizerConfigOrSanitizerPresets
&
aOptions
bool
aSafe
ErrorResult
&
aRv
)
{
if
(
aOptions
.
IsSanitizerPresets
(
)
)
{
MOZ_ASSERT
(
aOptions
.
GetAsSanitizerPresets
(
)
=
=
SanitizerPresets
:
:
Default
)
;
RefPtr
<
Sanitizer
>
sanitizer
=
new
Sanitizer
(
aGlobal
)
;
sanitizer
-
>
SetDefaultConfig
(
)
;
return
sanitizer
.
forget
(
)
;
}
if
(
aOptions
.
IsSanitizerConfig
(
)
)
{
RefPtr
<
Sanitizer
>
sanitizer
=
new
Sanitizer
(
aGlobal
)
;
sanitizer
-
>
SetConfig
(
aOptions
.
GetAsSanitizerConfig
(
)
!
aSafe
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
sanitizer
.
forget
(
)
;
}
MOZ_ASSERT
(
aOptions
.
IsSanitizer
(
)
)
;
RefPtr
<
Sanitizer
>
sanitizer
=
aOptions
.
GetAsSanitizer
(
)
;
return
sanitizer
.
forget
(
)
;
}
already_AddRefed
<
Sanitizer
>
Sanitizer
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
SanitizerConfigOrSanitizerPresets
&
aConfig
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
Sanitizer
>
sanitizer
=
new
Sanitizer
(
global
)
;
if
(
aConfig
.
IsSanitizerPresets
(
)
)
{
MOZ_ASSERT
(
aConfig
.
GetAsSanitizerPresets
(
)
=
=
SanitizerPresets
:
:
Default
)
;
sanitizer
-
>
SetDefaultConfig
(
)
;
return
sanitizer
.
forget
(
)
;
}
sanitizer
-
>
SetConfig
(
aConfig
.
GetAsSanitizerConfig
(
)
true
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
sanitizer
.
forget
(
)
;
}
void
Sanitizer
:
:
SetDefaultConfig
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AssertNoLists
(
)
;
mIsDefaultConfig
=
true
;
MOZ_ASSERT
(
!
mComments
)
;
MOZ_ASSERT
(
!
mDataAttributes
)
;
if
(
sDefaultHTMLElements
)
{
return
;
}
auto
createElements
=
[
]
(
mozilla
:
:
Span
<
nsStaticAtom
*
const
>
aElements
nsStaticAtom
*
const
*
aElementWithAttributes
)
{
auto
elements
=
new
ElementsWithAttributes
(
aElements
.
Length
(
)
)
;
size_t
i
=
0
;
for
(
nsStaticAtom
*
name
:
aElements
)
{
UniquePtr
<
StaticAtomSet
>
attributes
=
nullptr
;
if
(
name
=
=
aElementWithAttributes
[
i
]
)
{
attributes
=
MakeUnique
<
StaticAtomSet
>
(
)
;
while
(
aElementWithAttributes
[
+
+
i
]
)
{
attributes
-
>
Insert
(
aElementWithAttributes
[
i
]
)
;
}
i
+
+
;
}
elements
-
>
InsertOrUpdate
(
name
std
:
:
move
(
attributes
)
)
;
}
return
elements
;
}
;
sDefaultHTMLElements
=
createElements
(
Span
(
kDefaultHTMLElements
)
kHTMLElementWithAttributes
)
;
sDefaultMathMLElements
=
createElements
(
Span
(
kDefaultMathMLElements
)
kMathMLElementWithAttributes
)
;
sDefaultSVGElements
=
createElements
(
Span
(
kDefaultSVGElements
)
kSVGElementWithAttributes
)
;
sDefaultAttributes
=
new
StaticAtomSet
(
std
:
:
size
(
kDefaultAttributes
)
)
;
for
(
nsStaticAtom
*
name
:
kDefaultAttributes
)
{
sDefaultAttributes
-
>
Insert
(
name
)
;
}
ClearOnShutdown
(
&
sDefaultHTMLElements
)
;
ClearOnShutdown
(
&
sDefaultMathMLElements
)
;
ClearOnShutdown
(
&
sDefaultAttributes
)
;
}
void
Sanitizer
:
:
SetConfig
(
const
SanitizerConfig
&
aConfig
bool
aAllowCommentsAndDataAttributes
ErrorResult
&
aRv
)
{
if
(
aConfig
.
mElements
.
WasPassed
(
)
)
{
for
(
const
auto
&
element
:
aConfig
.
mElements
.
Value
(
)
)
{
AllowElement
(
element
)
;
}
}
if
(
aConfig
.
mRemoveElements
.
WasPassed
(
)
)
{
for
(
const
auto
&
element
:
aConfig
.
mRemoveElements
.
Value
(
)
)
{
RemoveElement
(
element
)
;
}
}
if
(
aConfig
.
mReplaceWithChildrenElements
.
WasPassed
(
)
)
{
for
(
const
auto
&
element
:
aConfig
.
mReplaceWithChildrenElements
.
Value
(
)
)
{
ReplaceElementWithChildren
(
element
)
;
}
}
if
(
aConfig
.
mAttributes
.
WasPassed
(
)
)
{
for
(
const
auto
&
attribute
:
aConfig
.
mAttributes
.
Value
(
)
)
{
AllowAttribute
(
attribute
)
;
}
}
if
(
aConfig
.
mRemoveAttributes
.
WasPassed
(
)
)
{
for
(
const
auto
&
attribute
:
aConfig
.
mRemoveAttributes
.
Value
(
)
)
{
RemoveAttribute
(
attribute
)
;
}
}
if
(
aConfig
.
mComments
.
WasPassed
(
)
)
{
SetComments
(
aConfig
.
mComments
.
Value
(
)
)
;
}
else
{
SetComments
(
aAllowCommentsAndDataAttributes
)
;
}
if
(
aConfig
.
mDataAttributes
.
WasPassed
(
)
)
{
SetDataAttributes
(
aConfig
.
mDataAttributes
.
Value
(
)
)
;
}
else
{
SetDataAttributes
(
aAllowCommentsAndDataAttributes
)
;
}
auto
isSameSize
=
[
]
(
const
auto
&
aInputConfig
const
auto
&
aProcessedConfig
)
{
size_t
sizeInput
=
aInputConfig
.
WasPassed
(
)
?
aInputConfig
.
Value
(
)
.
Length
(
)
:
0
;
size_t
sizeProcessed
=
aProcessedConfig
.
Values
(
)
.
Length
(
)
;
return
sizeInput
=
=
sizeProcessed
;
}
;
if
(
!
isSameSize
(
aConfig
.
mElements
mElements
)
)
{
aRv
.
ThrowTypeError
(
"
'
elements
'
changed
"
)
;
return
;
}
if
(
!
isSameSize
(
aConfig
.
mRemoveElements
mRemoveElements
)
)
{
aRv
.
ThrowTypeError
(
"
'
removeElements
'
changed
"
)
;
return
;
}
if
(
!
isSameSize
(
aConfig
.
mReplaceWithChildrenElements
mReplaceWithChildrenElements
)
)
{
aRv
.
ThrowTypeError
(
"
'
replaceWithChildrenElements
'
changed
"
)
;
return
;
}
if
(
!
isSameSize
(
aConfig
.
mAttributes
mAttributes
)
)
{
aRv
.
ThrowTypeError
(
"
'
attributes
'
changed
"
)
;
return
;
}
if
(
!
isSameSize
(
aConfig
.
mRemoveAttributes
mRemoveAttributes
)
)
{
aRv
.
ThrowTypeError
(
"
'
removeAttributes
'
changed
"
)
;
return
;
}
if
(
aConfig
.
mElements
.
WasPassed
(
)
&
&
aConfig
.
mRemoveElements
.
WasPassed
(
)
)
{
aRv
.
ThrowTypeError
(
"
'
elements
'
and
'
removeElements
'
are
not
allowed
at
the
same
time
"
)
;
return
;
}
if
(
aConfig
.
mAttributes
.
WasPassed
(
)
&
&
aConfig
.
mRemoveAttributes
.
WasPassed
(
)
)
{
aRv
.
ThrowTypeError
(
"
'
attributes
'
and
'
removeAttributes
'
are
not
allowed
at
the
same
time
"
)
;
return
;
}
}
void
Sanitizer
:
:
MaybeMaterializeDefaultConfig
(
)
{
if
(
!
mIsDefaultConfig
)
{
return
;
}
mIsDefaultConfig
=
false
;
AssertNoLists
(
)
;
auto
insertElements
=
[
this
]
(
mozilla
:
:
Span
<
nsStaticAtom
*
const
>
aElements
nsStaticAtom
*
aNamespace
nsStaticAtom
*
const
*
aElementWithAttributes
)
{
size_t
i
=
0
;
for
(
nsStaticAtom
*
name
:
aElements
)
{
CanonicalElementWithAttributes
element
(
CanonicalName
(
name
aNamespace
)
)
;
if
(
name
=
=
aElementWithAttributes
[
i
]
)
{
ListSet
<
CanonicalName
>
attributes
;
while
(
aElementWithAttributes
[
+
+
i
]
)
{
attributes
.
InsertNew
(
CanonicalName
(
aElementWithAttributes
[
i
]
nullptr
)
)
;
}
i
+
+
;
element
.
mAttributes
=
Some
(
std
:
:
move
(
attributes
)
)
;
}
mElements
.
InsertNew
(
std
:
:
move
(
element
)
)
;
}
}
;
insertElements
(
Span
(
kDefaultHTMLElements
)
nsGkAtoms
:
:
nsuri_xhtml
kHTMLElementWithAttributes
)
;
insertElements
(
Span
(
kDefaultMathMLElements
)
nsGkAtoms
:
:
nsuri_mathml
kMathMLElementWithAttributes
)
;
insertElements
(
Span
(
kDefaultSVGElements
)
nsGkAtoms
:
:
nsuri_svg
kSVGElementWithAttributes
)
;
for
(
nsStaticAtom
*
name
:
kDefaultAttributes
)
{
mAttributes
.
InsertNew
(
CanonicalName
(
name
nullptr
)
)
;
}
}
void
Sanitizer
:
:
Get
(
SanitizerConfig
&
aConfig
)
{
MaybeMaterializeDefaultConfig
(
)
;
nsTArray
<
OwningStringOrSanitizerElementNamespaceWithAttributes
>
elements
;
for
(
const
CanonicalElementWithAttributes
&
canonical
:
mElements
.
Values
(
)
)
{
elements
.
AppendElement
(
)
-
>
SetAsSanitizerElementNamespaceWithAttributes
(
)
=
canonical
.
ToSanitizerElementNamespaceWithAttributes
(
)
;
}
aConfig
.
mElements
.
Construct
(
std
:
:
move
(
elements
)
)
;
nsTArray
<
OwningStringOrSanitizerElementNamespace
>
removeElements
;
for
(
const
CanonicalName
&
canonical
:
mRemoveElements
.
Values
(
)
)
{
removeElements
.
AppendElement
(
)
-
>
SetAsSanitizerElementNamespace
(
)
=
canonical
.
ToSanitizerElementNamespace
(
)
;
}
aConfig
.
mRemoveElements
.
Construct
(
std
:
:
move
(
removeElements
)
)
;
nsTArray
<
OwningStringOrSanitizerElementNamespace
>
replaceWithChildrenElements
;
for
(
const
CanonicalName
&
canonical
:
mReplaceWithChildrenElements
.
Values
(
)
)
{
replaceWithChildrenElements
.
AppendElement
(
)
-
>
SetAsSanitizerElementNamespace
(
)
=
canonical
.
ToSanitizerElementNamespace
(
)
;
}
aConfig
.
mReplaceWithChildrenElements
.
Construct
(
std
:
:
move
(
replaceWithChildrenElements
)
)
;
aConfig
.
mAttributes
.
Construct
(
ToSanitizerAttributes
(
mAttributes
)
)
;
aConfig
.
mRemoveAttributes
.
Construct
(
ToSanitizerAttributes
(
mRemoveAttributes
)
)
;
aConfig
.
mComments
.
Construct
(
mComments
)
;
aConfig
.
mDataAttributes
.
Construct
(
mDataAttributes
)
;
}
auto
&
GetAsSanitizerElementNamespace
(
const
StringOrSanitizerElementNamespace
&
aElement
)
{
return
aElement
.
GetAsSanitizerElementNamespace
(
)
;
}
auto
&
GetAsSanitizerElementNamespace
(
const
OwningStringOrSanitizerElementNamespace
&
aElement
)
{
return
aElement
.
GetAsSanitizerElementNamespace
(
)
;
}
auto
&
GetAsSanitizerElementNamespace
(
const
StringOrSanitizerElementNamespaceWithAttributes
&
aElement
)
{
return
aElement
.
GetAsSanitizerElementNamespaceWithAttributes
(
)
;
}
auto
&
GetAsSanitizerElementNamespace
(
const
OwningStringOrSanitizerElementNamespaceWithAttributes
&
aElement
)
{
return
aElement
.
GetAsSanitizerElementNamespaceWithAttributes
(
)
;
}
template
<
typename
SanitizerElement
>
static
CanonicalName
CanonicalizeElement
(
const
SanitizerElement
&
aElement
)
{
if
(
aElement
.
IsString
(
)
)
{
RefPtr
<
nsAtom
>
nameAtom
=
NS_AtomizeMainThread
(
aElement
.
GetAsString
(
)
)
;
return
CanonicalName
(
nameAtom
nsGkAtoms
:
:
nsuri_xhtml
)
;
}
const
auto
&
elem
=
GetAsSanitizerElementNamespace
(
aElement
)
;
MOZ_ASSERT
(
!
elem
.
mName
.
IsVoid
(
)
)
;
RefPtr
<
nsAtom
>
namespaceAtom
;
if
(
!
elem
.
mNamespace
.
IsEmpty
(
)
)
{
namespaceAtom
=
NS_AtomizeMainThread
(
elem
.
mNamespace
)
;
}
RefPtr
<
nsAtom
>
nameAtom
=
NS_AtomizeMainThread
(
elem
.
mName
)
;
return
CanonicalName
(
nameAtom
namespaceAtom
)
;
}
template
<
typename
SanitizerAttribute
>
static
CanonicalName
CanonicalizeAttribute
(
const
SanitizerAttribute
&
aAttribute
)
{
if
(
aAttribute
.
IsString
(
)
)
{
RefPtr
<
nsAtom
>
nameAtom
=
NS_AtomizeMainThread
(
aAttribute
.
GetAsString
(
)
)
;
return
CanonicalName
(
nameAtom
nullptr
)
;
}
const
auto
&
attr
=
aAttribute
.
GetAsSanitizerAttributeNamespace
(
)
;
MOZ_ASSERT
(
!
attr
.
mName
.
IsVoid
(
)
)
;
RefPtr
<
nsAtom
>
namespaceAtom
;
if
(
!
attr
.
mNamespace
.
IsEmpty
(
)
)
{
namespaceAtom
=
NS_AtomizeMainThread
(
attr
.
mNamespace
)
;
}
RefPtr
<
nsAtom
>
nameAtom
=
NS_AtomizeMainThread
(
attr
.
mName
)
;
return
CanonicalName
(
nameAtom
namespaceAtom
)
;
}
template
<
typename
SanitizerElementWithAttributes
>
static
CanonicalElementWithAttributes
CanonicalizeElementWithAttributes
(
const
SanitizerElementWithAttributes
&
aElement
)
{
CanonicalElementWithAttributes
result
=
CanonicalElementWithAttributes
(
CanonicalizeElement
(
aElement
)
)
;
if
(
aElement
.
IsSanitizerElementNamespaceWithAttributes
(
)
)
{
auto
&
elem
=
aElement
.
GetAsSanitizerElementNamespaceWithAttributes
(
)
;
if
(
elem
.
mAttributes
.
WasPassed
(
)
)
{
ListSet
<
CanonicalName
>
attributes
;
for
(
const
auto
&
attribute
:
elem
.
mAttributes
.
Value
(
)
)
{
attributes
.
Insert
(
CanonicalizeAttribute
(
attribute
)
)
;
}
result
.
mAttributes
=
Some
(
std
:
:
move
(
attributes
)
)
;
}
if
(
elem
.
mRemoveAttributes
.
WasPassed
(
)
)
{
ListSet
<
CanonicalName
>
attributes
;
for
(
const
auto
&
attribute
:
elem
.
mRemoveAttributes
.
Value
(
)
)
{
attributes
.
Insert
(
CanonicalizeAttribute
(
attribute
)
)
;
}
result
.
mRemoveAttributes
=
Some
(
std
:
:
move
(
attributes
)
)
;
}
}
return
result
;
}
template
<
typename
SanitizerElementWithAttributes
>
void
Sanitizer
:
:
AllowElement
(
const
SanitizerElementWithAttributes
&
aElement
)
{
MaybeMaterializeDefaultConfig
(
)
;
CanonicalElementWithAttributes
element
=
CanonicalizeElementWithAttributes
(
aElement
)
;
mElements
.
Remove
(
element
)
;
mRemoveElements
.
Remove
(
element
)
;
mReplaceWithChildrenElements
.
Remove
(
element
)
;
mElements
.
Insert
(
std
:
:
move
(
element
)
)
;
}
template
void
Sanitizer
:
:
AllowElement
(
const
StringOrSanitizerElementNamespaceWithAttributes
&
)
;
template
<
typename
SanitizerElement
>
void
Sanitizer
:
:
RemoveElement
(
const
SanitizerElement
&
aElement
)
{
MaybeMaterializeDefaultConfig
(
)
;
CanonicalName
element
=
CanonicalizeElement
(
aElement
)
;
RemoveElementCanonical
(
std
:
:
move
(
element
)
)
;
}
void
Sanitizer
:
:
RemoveElementCanonical
(
CanonicalName
&
&
aElement
)
{
mElements
.
Remove
(
aElement
)
;
mReplaceWithChildrenElements
.
Remove
(
aElement
)
;
mRemoveElements
.
Insert
(
std
:
:
move
(
aElement
)
)
;
}
template
void
Sanitizer
:
:
RemoveElement
(
const
StringOrSanitizerElementNamespace
&
)
;
template
<
typename
SanitizerElement
>
void
Sanitizer
:
:
ReplaceElementWithChildren
(
const
SanitizerElement
&
aElement
)
{
MaybeMaterializeDefaultConfig
(
)
;
CanonicalName
element
=
CanonicalizeElement
(
aElement
)
;
mRemoveElements
.
Remove
(
element
)
;
mElements
.
Remove
(
element
)
;
mReplaceWithChildrenElements
.
Insert
(
std
:
:
move
(
element
)
)
;
}
template
void
Sanitizer
:
:
ReplaceElementWithChildren
(
const
StringOrSanitizerElementNamespace
&
)
;
template
<
typename
SanitizerAttribute
>
void
Sanitizer
:
:
AllowAttribute
(
const
SanitizerAttribute
&
aAttribute
)
{
MaybeMaterializeDefaultConfig
(
)
;
CanonicalName
attribute
=
CanonicalizeAttribute
(
aAttribute
)
;
mRemoveAttributes
.
Remove
(
attribute
)
;
mAttributes
.
Insert
(
std
:
:
move
(
attribute
)
)
;
}
template
void
Sanitizer
:
:
AllowAttribute
(
const
StringOrSanitizerAttributeNamespace
&
)
;
template
<
typename
SanitizerAttribute
>
void
Sanitizer
:
:
RemoveAttribute
(
const
SanitizerAttribute
&
aAttribute
)
{
MaybeMaterializeDefaultConfig
(
)
;
CanonicalName
attribute
=
CanonicalizeAttribute
(
aAttribute
)
;
RemoveAttributeCanonical
(
std
:
:
move
(
attribute
)
)
;
}
void
Sanitizer
:
:
RemoveAttributeCanonical
(
CanonicalName
&
&
aAttribute
)
{
mAttributes
.
Remove
(
aAttribute
)
;
mRemoveAttributes
.
Insert
(
std
:
:
move
(
aAttribute
)
)
;
}
template
void
Sanitizer
:
:
RemoveAttribute
(
const
StringOrSanitizerAttributeNamespace
&
)
;
void
Sanitizer
:
:
SetComments
(
bool
aAllow
)
{
mComments
=
aAllow
;
}
void
Sanitizer
:
:
SetDataAttributes
(
bool
aAllow
)
{
mDataAttributes
=
aAllow
;
}
void
Sanitizer
:
:
RemoveUnsafe
(
)
{
MaybeMaterializeDefaultConfig
(
)
;
RemoveElementCanonical
(
CanonicalName
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
nsuri_xhtml
)
)
;
RemoveElementCanonical
(
CanonicalName
(
nsGkAtoms
:
:
frame
nsGkAtoms
:
:
nsuri_xhtml
)
)
;
RemoveElementCanonical
(
CanonicalName
(
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
nsuri_xhtml
)
)
;
RemoveElementCanonical
(
CanonicalName
(
nsGkAtoms
:
:
object
nsGkAtoms
:
:
nsuri_xhtml
)
)
;
RemoveElementCanonical
(
CanonicalName
(
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
nsuri_xhtml
)
)
;
RemoveElementCanonical
(
CanonicalName
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
nsuri_svg
)
)
;
RemoveElementCanonical
(
CanonicalName
(
nsGkAtoms
:
:
use
nsGkAtoms
:
:
nsuri_svg
)
)
;
nsContentUtils
:
:
ForEachEventAttributeName
(
EventNameType_All
&
~
EventNameType_XUL
[
self
=
MOZ_KnownLive
(
this
)
]
(
nsAtom
*
aName
)
{
self
-
>
RemoveAttributeCanonical
(
CanonicalName
(
aName
nullptr
)
)
;
}
)
;
}
void
Sanitizer
:
:
Sanitize
(
nsINode
*
aNode
bool
aSafe
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aNode
-
>
OwnerDoc
(
)
-
>
IsLoadedAsData
(
)
"
SanitizeChildren
relies
on
the
document
being
inert
to
be
safe
"
)
;
if
(
mIsDefaultConfig
)
{
AssertNoLists
(
)
;
SanitizeChildren
<
true
>
(
aNode
aSafe
)
;
}
else
{
SanitizeChildren
<
false
>
(
aNode
aSafe
)
;
}
}
static
RefPtr
<
nsAtom
>
ToNamespace
(
int32_t
aNamespaceID
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
return
nullptr
;
}
RefPtr
<
nsAtom
>
atom
=
nsNameSpaceManager
:
:
GetInstance
(
)
-
>
NameSpaceURIAtom
(
aNamespaceID
)
;
return
atom
;
}
static
bool
IsUnsafeElement
(
nsAtom
*
aLocalName
int32_t
aNamespaceID
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_XHTML
)
{
return
aLocalName
=
=
nsGkAtoms
:
:
script
|
|
aLocalName
=
=
nsGkAtoms
:
:
frame
|
|
aLocalName
=
=
nsGkAtoms
:
:
iframe
|
|
aLocalName
=
=
nsGkAtoms
:
:
object
|
|
aLocalName
=
=
nsGkAtoms
:
:
embed
;
}
if
(
aNamespaceID
=
=
kNameSpaceID_SVG
)
{
return
aLocalName
=
=
nsGkAtoms
:
:
script
|
|
aLocalName
=
=
nsGkAtoms
:
:
use
;
}
return
false
;
}
template
<
bool
IsDefaultConfig
>
void
Sanitizer
:
:
SanitizeChildren
(
nsINode
*
aNode
bool
aSafe
)
{
nsCOMPtr
<
nsIContent
>
next
=
nullptr
;
for
(
nsCOMPtr
<
nsIContent
>
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
next
)
{
next
=
child
-
>
GetNextSibling
(
)
;
MOZ_ASSERT
(
child
-
>
IsText
(
)
|
|
child
-
>
IsComment
(
)
|
|
child
-
>
IsElement
(
)
|
|
child
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
)
;
if
(
child
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
)
{
continue
;
}
if
(
child
-
>
IsText
(
)
)
{
continue
;
}
if
(
child
-
>
IsComment
(
)
)
{
if
(
!
mComments
)
{
child
-
>
RemoveFromParent
(
)
;
}
continue
;
}
MOZ_ASSERT
(
child
-
>
IsElement
(
)
)
;
nsAtom
*
nameAtom
=
child
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
int32_t
namespaceID
=
child
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
;
Maybe
<
CanonicalName
>
elementName
;
if
constexpr
(
!
IsDefaultConfig
)
{
elementName
.
emplace
(
nameAtom
ToNamespace
(
namespaceID
)
)
;
}
if
constexpr
(
!
IsDefaultConfig
)
{
if
(
aSafe
&
&
IsUnsafeElement
(
nameAtom
namespaceID
)
)
{
child
-
>
RemoveFromParent
(
)
;
continue
;
}
}
if
constexpr
(
!
IsDefaultConfig
)
{
if
(
mReplaceWithChildrenElements
.
Contains
(
*
elementName
)
)
{
nsCOMPtr
<
nsIContent
>
parent
=
child
-
>
GetParent
(
)
;
nsCOMPtr
<
nsIContent
>
firstChild
=
child
-
>
GetFirstChild
(
)
;
nsCOMPtr
<
nsIContent
>
newChild
=
firstChild
;
for
(
;
newChild
;
newChild
=
child
-
>
GetFirstChild
(
)
)
{
ErrorResult
rv
;
parent
-
>
InsertBefore
(
*
newChild
child
rv
)
;
if
(
rv
.
Failed
(
)
)
{
break
;
}
}
child
-
>
RemoveFromParent
(
)
;
if
(
firstChild
)
{
next
=
firstChild
;
}
continue
;
}
}
[
[
maybe_unused
]
]
StaticAtomSet
*
elementAttributes
=
nullptr
;
if
constexpr
(
!
IsDefaultConfig
)
{
if
(
mRemoveElements
.
Contains
(
*
elementName
)
|
|
(
!
mElements
.
IsEmpty
(
)
&
&
!
mElements
.
Contains
(
*
elementName
)
)
)
{
child
-
>
RemoveFromParent
(
)
;
continue
;
}
}
else
{
bool
found
=
false
;
if
(
nameAtom
-
>
IsStatic
(
)
)
{
ElementsWithAttributes
*
elements
=
nullptr
;
if
(
namespaceID
=
=
kNameSpaceID_XHTML
)
{
elements
=
sDefaultHTMLElements
;
}
else
if
(
namespaceID
=
=
kNameSpaceID_MathML
)
{
elements
=
sDefaultMathMLElements
;
}
else
if
(
namespaceID
=
=
kNameSpaceID_SVG
)
{
elements
=
sDefaultSVGElements
;
}
if
(
elements
)
{
if
(
auto
lookup
=
elements
-
>
Lookup
(
nameAtom
-
>
AsStatic
(
)
)
)
{
found
=
true
;
elementAttributes
=
lookup
-
>
get
(
)
;
}
}
}
if
(
!
found
)
{
child
-
>
RemoveFromParent
(
)
;
continue
;
}
MOZ_ASSERT
(
!
IsUnsafeElement
(
nameAtom
namespaceID
)
)
;
}
if
(
auto
*
templateEl
=
HTMLTemplateElement
:
:
FromNode
(
child
)
)
{
RefPtr
<
DocumentFragment
>
frag
=
templateEl
-
>
Content
(
)
;
SanitizeChildren
<
IsDefaultConfig
>
(
frag
aSafe
)
;
}
if
(
RefPtr
<
ShadowRoot
>
shadow
=
child
-
>
GetShadowRoot
(
)
)
{
SanitizeChildren
<
IsDefaultConfig
>
(
shadow
aSafe
)
;
}
if
constexpr
(
!
IsDefaultConfig
)
{
SanitizeAttributes
(
child
-
>
AsElement
(
)
*
elementName
aSafe
)
;
}
else
{
SanitizeDefaultConfigAttributes
(
child
-
>
AsElement
(
)
elementAttributes
aSafe
)
;
}
SanitizeChildren
<
IsDefaultConfig
>
(
child
aSafe
)
;
}
}
static
inline
bool
IsDataAttribute
(
nsAtom
*
aName
int32_t
aNamespaceID
)
{
return
StringBeginsWith
(
nsDependentAtomString
(
aName
)
u
"
data
-
"
_ns
)
&
&
aNamespaceID
=
=
kNameSpaceID_None
;
}
static
bool
RemoveJavascriptNavigationURLAttribute
(
Element
*
aElement
nsAtom
*
aLocalName
int32_t
aNamespaceID
)
{
auto
containsJavascriptURL
=
[
&
]
(
)
{
nsAutoString
value
;
if
(
!
aElement
-
>
GetAttr
(
aNamespaceID
aLocalName
value
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
uri
)
value
)
)
)
{
return
false
;
}
return
uri
-
>
SchemeIs
(
"
javascript
"
)
;
}
;
if
(
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
area
nsGkAtoms
:
:
base
)
&
&
aLocalName
=
=
nsGkAtoms
:
:
href
&
&
aNamespaceID
=
=
kNameSpaceID_None
)
|
|
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
button
nsGkAtoms
:
:
input
)
&
&
aLocalName
=
=
nsGkAtoms
:
:
formaction
&
&
aNamespaceID
=
=
kNameSpaceID_None
)
|
|
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
&
&
aLocalName
=
=
nsGkAtoms
:
:
action
&
&
aNamespaceID
=
=
kNameSpaceID_None
)
|
|
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
aLocalName
=
=
nsGkAtoms
:
:
src
&
&
aNamespaceID
=
=
kNameSpaceID_None
)
|
|
(
aElement
-
>
IsSVGElement
(
nsGkAtoms
:
:
a
)
&
&
aLocalName
=
=
nsGkAtoms
:
:
href
&
&
(
aNamespaceID
=
=
kNameSpaceID_None
|
|
aNamespaceID
=
=
kNameSpaceID_XLink
)
)
)
{
if
(
containsJavascriptURL
(
)
)
{
return
true
;
}
}
;
if
(
aElement
-
>
IsMathMLElement
(
)
&
&
aLocalName
=
=
nsGkAtoms
:
:
href
&
&
(
aNamespaceID
=
=
kNameSpaceID_None
|
|
aNamespaceID
=
=
kNameSpaceID_XLink
)
)
{
if
(
containsJavascriptURL
(
)
)
{
return
true
;
}
}
if
(
aLocalName
=
=
nsGkAtoms
:
:
attributeName
&
&
aNamespaceID
=
=
kNameSpaceID_None
&
&
aElement
-
>
IsAnyOfSVGElements
(
nsGkAtoms
:
:
animate
nsGkAtoms
:
:
animateMotion
nsGkAtoms
:
:
animateTransform
nsGkAtoms
:
:
set
)
)
{
nsAutoString
value
;
if
(
!
aElement
-
>
GetAttr
(
aNamespaceID
aLocalName
value
)
)
{
return
false
;
}
return
value
.
EqualsLiteral
(
"
href
"
)
|
|
value
.
EqualsLiteral
(
"
xlink
:
href
"
)
;
}
return
false
;
}
void
Sanitizer
:
:
SanitizeAttributes
(
Element
*
aChild
const
CanonicalName
&
aElementName
bool
aSafe
)
{
MOZ_ASSERT
(
!
mIsDefaultConfig
)
;
const
CanonicalElementWithAttributes
*
elementWithAttributes
=
mElements
.
Get
(
aElementName
)
;
int32_t
count
=
int32_t
(
aChild
-
>
GetAttrCount
(
)
)
;
for
(
int32_t
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
const
nsAttrName
*
attr
=
aChild
-
>
GetAttrNameAt
(
i
)
;
RefPtr
<
nsAtom
>
attrLocalName
=
attr
-
>
LocalName
(
)
;
int32_t
attrNs
=
attr
-
>
NamespaceID
(
)
;
CanonicalName
attrName
(
attrLocalName
ToNamespace
(
attrNs
)
)
;
bool
remove
=
false
;
if
(
aSafe
&
&
attrNs
=
=
kNameSpaceID_None
&
&
nsContentUtils
:
:
IsEventAttributeName
(
attrLocalName
EventNameType_All
&
~
EventNameType_XUL
)
)
{
remove
=
true
;
}
else
if
(
mRemoveAttributes
.
Contains
(
attrName
)
)
{
remove
=
true
;
}
else
if
(
elementWithAttributes
&
&
elementWithAttributes
-
>
mRemoveAttributes
&
&
elementWithAttributes
-
>
mRemoveAttributes
-
>
Contains
(
attrName
)
)
{
remove
=
true
;
}
else
if
(
(
!
mAttributes
.
IsEmpty
(
)
&
&
!
mAttributes
.
Contains
(
attrName
)
)
&
&
!
(
elementWithAttributes
&
&
elementWithAttributes
-
>
mAttributes
&
&
elementWithAttributes
-
>
mAttributes
-
>
Contains
(
attrName
)
)
&
&
!
(
mDataAttributes
&
&
IsDataAttribute
(
attrLocalName
attrNs
)
)
)
{
remove
=
true
;
}
else
if
(
aSafe
)
{
remove
=
RemoveJavascriptNavigationURLAttribute
(
aChild
attrLocalName
attrNs
)
;
}
if
(
remove
)
{
aChild
-
>
UnsetAttr
(
attr
-
>
NamespaceID
(
)
attr
-
>
LocalName
(
)
false
)
;
-
-
count
;
i
=
count
;
}
}
}
void
Sanitizer
:
:
SanitizeDefaultConfigAttributes
(
Element
*
aChild
StaticAtomSet
*
aElementAttributes
bool
aSafe
)
{
MOZ_ASSERT
(
mIsDefaultConfig
)
;
int32_t
count
=
int32_t
(
aChild
-
>
GetAttrCount
(
)
)
;
for
(
int32_t
i
=
count
-
1
;
i
>
=
0
;
-
-
i
)
{
const
nsAttrName
*
attr
=
aChild
-
>
GetAttrNameAt
(
i
)
;
RefPtr
<
nsAtom
>
attrLocalName
=
attr
-
>
LocalName
(
)
;
int32_t
attrNs
=
attr
-
>
NamespaceID
(
)
;
bool
remove
=
false
;
if
(
attrNs
!
=
kNameSpaceID_None
|
|
(
!
sDefaultAttributes
-
>
Contains
(
attrLocalName
)
&
&
!
(
aElementAttributes
&
&
aElementAttributes
-
>
Contains
(
attrLocalName
)
)
&
&
!
(
mDataAttributes
&
&
IsDataAttribute
(
attrLocalName
attrNs
)
)
)
)
{
remove
=
true
;
}
else
if
(
aSafe
)
{
remove
=
RemoveJavascriptNavigationURLAttribute
(
aChild
attrLocalName
attrNs
)
;
}
MOZ_ASSERT_IF
(
!
remove
!
nsContentUtils
:
:
IsEventAttributeName
(
attrLocalName
EventNameType_All
&
~
EventNameType_XUL
)
)
;
if
(
remove
)
{
aChild
-
>
UnsetAttr
(
attr
-
>
NamespaceID
(
)
attr
-
>
LocalName
(
)
false
)
;
-
-
count
;
i
=
count
;
}
}
}
void
Sanitizer
:
:
LogLocalizedString
(
const
char
*
aName
const
nsTArray
<
nsString
>
&
aParams
uint32_t
aFlags
)
{
uint64_t
innerWindowID
=
0
;
bool
isPrivateBrowsing
=
true
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mGlobal
)
;
if
(
window
&
&
window
-
>
GetDoc
(
)
)
{
auto
*
doc
=
window
-
>
GetDoc
(
)
;
innerWindowID
=
doc
-
>
InnerWindowID
(
)
;
isPrivateBrowsing
=
doc
-
>
IsInPrivateBrowsing
(
)
;
}
nsAutoString
logMsg
;
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eSECURITY_PROPERTIES
aName
aParams
logMsg
)
;
LogMessage
(
logMsg
aFlags
innerWindowID
isPrivateBrowsing
)
;
}
void
Sanitizer
:
:
LogMessage
(
const
nsAString
&
aMessage
uint32_t
aFlags
uint64_t
aInnerWindowID
bool
aFromPrivateWindow
)
{
nsString
message
;
message
.
AppendLiteral
(
u
"
Sanitizer
:
"
)
;
message
.
Append
(
aMessage
)
;
constexpr
auto
category
=
"
Sanitizer
"
_ns
;
if
(
aInnerWindowID
>
0
)
{
nsContentUtils
:
:
ReportToConsoleByWindowID
(
message
aFlags
category
aInnerWindowID
)
;
}
else
{
nsContentUtils
:
:
LogSimpleConsoleError
(
message
category
aFromPrivateWindow
true
aFlags
)
;
}
}
}
