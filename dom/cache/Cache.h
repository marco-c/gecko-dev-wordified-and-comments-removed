#
ifndef
mozilla_dom_cache_Cache_h
#
define
mozilla_dom_cache_Cache_h
#
include
"
mozilla
/
dom
/
cache
/
TypeUtils
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Types
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
OwningRequestOrUTF8String
;
class
Promise
;
struct
CacheQueryOptions
;
class
RequestOrUTF8String
;
class
Response
;
template
<
typename
T
>
class
Optional
;
template
<
typename
T
>
class
Sequence
;
enum
class
CallerType
:
uint32_t
;
namespace
cache
{
class
AutoChildOpArgs
;
class
CacheChild
;
enum
class
PutStatusPolicy
{
Default
RequireOK
}
;
bool
IsValidPutRequestURL
(
const
nsACString
&
aUrl
ErrorResult
&
aRv
)
;
bool
IsValidPutRequestMethod
(
const
RequestOrUTF8String
&
aRequest
ErrorResult
&
aRv
)
;
bool
IsValidPutRequestMethod
(
const
Request
&
aRequest
ErrorResult
&
aRv
)
;
bool
IsValidPutResponseStatus
(
Response
&
aResponse
PutStatusPolicy
aPolicy
ErrorResult
&
aRv
)
;
class
Cache
final
:
public
nsISupports
public
nsWrapperCache
public
TypeUtils
public
CacheChildListener
{
public
:
Cache
(
nsIGlobalObject
*
aGlobal
CacheChild
*
aActor
Namespace
aNamespace
)
;
static
bool
CachesEnabled
(
JSContext
*
aCx
JSObject
*
)
;
already_AddRefed
<
Promise
>
Match
(
JSContext
*
aCx
const
RequestOrUTF8String
&
aRequest
const
CacheQueryOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
MatchAll
(
JSContext
*
aCx
const
Optional
<
RequestOrUTF8String
>
&
aRequest
const
CacheQueryOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Add
(
JSContext
*
aContext
const
RequestOrUTF8String
&
aRequest
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
AddAll
(
JSContext
*
aContext
const
Sequence
<
OwningRequestOrUTF8String
>
&
aRequests
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Put
(
JSContext
*
aCx
const
RequestOrUTF8String
&
aRequest
Response
&
aResponse
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Delete
(
JSContext
*
aCx
const
RequestOrUTF8String
&
aRequest
const
CacheQueryOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
Keys
(
JSContext
*
aCx
const
Optional
<
RequestOrUTF8String
>
&
aRequest
const
CacheQueryOptions
&
aParams
ErrorResult
&
aRv
)
;
nsISupports
*
GetParentObject
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aContext
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
OnActorDestroy
(
CacheChild
*
aActor
)
override
;
virtual
nsIGlobalObject
*
GetGlobalObject
(
)
const
override
;
#
ifdef
DEBUG
virtual
void
AssertOwningThread
(
)
const
override
;
#
endif
private
:
class
FetchHandler
;
~
Cache
(
)
;
void
DisconnectFromActor
(
)
;
already_AddRefed
<
Promise
>
ExecuteOp
(
AutoChildOpArgs
&
aOpArgs
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
AddAll
(
const
GlobalObject
&
aGlobal
nsTArray
<
SafeRefPtr
<
Request
>
>
&
&
aRequestList
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
PutAll
(
JSContext
*
aCx
const
nsTArray
<
SafeRefPtr
<
Request
>
>
&
aRequestList
const
nsTArray
<
RefPtr
<
Response
>
>
&
aResponseList
ErrorResult
&
aRv
)
;
OpenMode
GetOpenMode
(
)
const
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
CacheChild
*
mActor
;
const
Namespace
mNamespace
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
Cache
)
}
;
}
}
}
#
endif
