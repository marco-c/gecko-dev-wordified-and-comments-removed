#
include
"
mozilla
/
dom
/
cache
/
CacheStorageParent
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ActorUtils
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheOpParent
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ManagerId
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
PrincipalUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
namespace
mozilla
:
:
dom
:
:
cache
{
using
mozilla
:
:
ipc
:
:
PBackgroundParent
;
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
already_AddRefed
<
PCacheStorageParent
>
AllocPCacheStorageParent
(
PBackgroundParent
*
aManagingActor
Namespace
aNamespace
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
)
{
if
(
NS_WARN_IF
(
!
quota
:
:
IsPrincipalInfoValid
(
aPrincipalInfo
)
)
)
{
MOZ_ASSERT
(
false
)
;
return
nullptr
;
}
return
MakeAndAddRef
<
CacheStorageParent
>
(
aManagingActor
aNamespace
aPrincipalInfo
)
;
}
void
DeallocPCacheStorageParent
(
PCacheStorageParent
*
aActor
)
{
delete
aActor
;
}
CacheStorageParent
:
:
CacheStorageParent
(
PBackgroundParent
*
aManagingActor
Namespace
aNamespace
const
PrincipalInfo
&
aPrincipalInfo
)
:
mNamespace
(
aNamespace
)
mVerifiedStatus
(
NS_OK
)
{
MOZ_COUNT_CTOR
(
cache
:
:
CacheStorageParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aManagingActor
)
;
mVerifier
=
PrincipalVerifier
:
:
CreateAndDispatch
(
*
this
aManagingActor
aPrincipalInfo
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mVerifier
)
;
}
CacheStorageParent
:
:
~
CacheStorageParent
(
)
{
MOZ_COUNT_DTOR
(
cache
:
:
CacheStorageParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mVerifier
)
;
}
void
CacheStorageParent
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
if
(
mVerifier
)
{
mVerifier
-
>
RemoveListener
(
*
this
)
;
mVerifier
=
nullptr
;
}
}
PCacheOpParent
*
CacheStorageParent
:
:
AllocPCacheOpParent
(
const
CacheOpArgs
&
aOpArgs
)
{
if
(
aOpArgs
.
type
(
)
!
=
CacheOpArgs
:
:
TStorageMatchArgs
&
&
aOpArgs
.
type
(
)
!
=
CacheOpArgs
:
:
TStorageHasArgs
&
&
aOpArgs
.
type
(
)
!
=
CacheOpArgs
:
:
TStorageOpenArgs
&
&
aOpArgs
.
type
(
)
!
=
CacheOpArgs
:
:
TStorageDeleteArgs
&
&
aOpArgs
.
type
(
)
!
=
CacheOpArgs
:
:
TStorageKeysArgs
)
{
MOZ_CRASH
(
"
Invalid
operation
sent
to
CacheStorage
actor
!
"
)
;
}
return
new
CacheOpParent
(
Manager
(
)
mNamespace
aOpArgs
)
;
}
bool
CacheStorageParent
:
:
DeallocPCacheOpParent
(
PCacheOpParent
*
aActor
)
{
delete
aActor
;
return
true
;
}
mozilla
:
:
ipc
:
:
IPCResult
CacheStorageParent
:
:
RecvPCacheOpConstructor
(
PCacheOpParent
*
aActor
const
CacheOpArgs
&
aOpArgs
)
{
auto
actor
=
static_cast
<
CacheOpParent
*
>
(
aActor
)
;
if
(
mVerifier
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mManagerId
)
;
actor
-
>
WaitForVerification
(
mVerifier
)
;
return
IPC_OK
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
mVerifiedStatus
)
)
)
{
QM_WARNONLY_TRY
(
OkIf
(
CacheOpParent
:
:
Send__delete__
(
actor
CopyableErrorResult
(
mVerifiedStatus
)
void_t
(
)
)
)
)
;
return
IPC_OK
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mManagerId
)
;
actor
-
>
Execute
(
mManagerId
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CacheStorageParent
:
:
RecvTeardown
(
)
{
QM_WARNONLY_TRY
(
OkIf
(
Send__delete__
(
this
)
)
)
;
return
IPC_OK
(
)
;
}
void
CacheStorageParent
:
:
OnPrincipalVerified
(
nsresult
aRv
const
SafeRefPtr
<
ManagerId
>
&
aManagerId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mVerifier
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mManagerId
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
mVerifiedStatus
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aRv
)
)
)
{
mVerifiedStatus
=
aRv
;
}
mManagerId
=
aManagerId
.
clonePtr
(
)
;
mVerifier
-
>
RemoveListener
(
*
this
)
;
mVerifier
=
nullptr
;
}
}
