#
include
"
mozilla
/
dom
/
cache
/
CacheStreamControlParent
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheTypes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ReadStream
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
StreamList
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptorSetParent
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PFileDescriptorSetParent
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
using
mozilla
:
:
dom
:
:
OptionalFileDescriptorSet
;
using
mozilla
:
:
ipc
:
:
AutoIPCStream
;
using
mozilla
:
:
ipc
:
:
FileDescriptor
;
using
mozilla
:
:
ipc
:
:
FileDescriptorSetParent
;
using
mozilla
:
:
ipc
:
:
PFileDescriptorSetParent
;
void
DeallocPCacheStreamControlParent
(
PCacheStreamControlParent
*
aActor
)
{
delete
aActor
;
}
CacheStreamControlParent
:
:
CacheStreamControlParent
(
)
{
MOZ_COUNT_CTOR
(
cache
:
:
CacheStreamControlParent
)
;
}
CacheStreamControlParent
:
:
~
CacheStreamControlParent
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mStreamList
)
;
MOZ_COUNT_DTOR
(
cache
:
:
CacheStreamControlParent
)
;
}
void
CacheStreamControlParent
:
:
SerializeControl
(
CacheReadStream
*
aReadStreamOut
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aReadStreamOut
)
;
aReadStreamOut
-
>
controlChild
(
)
=
nullptr
;
aReadStreamOut
-
>
controlParent
(
)
=
this
;
}
void
CacheStreamControlParent
:
:
SerializeStream
(
CacheReadStream
*
aReadStreamOut
nsIInputStream
*
aStream
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aReadStreamOut
)
;
UniquePtr
<
AutoIPCStream
>
autoStream
(
new
AutoIPCStream
(
aReadStreamOut
-
>
stream
(
)
)
)
;
DebugOnly
<
bool
>
ok
=
autoStream
-
>
Serialize
(
aStream
Manager
(
)
)
;
MOZ_ASSERT
(
ok
)
;
aStreamCleanupList
.
AppendElement
(
Move
(
autoStream
)
)
;
}
void
CacheStreamControlParent
:
:
OpenStream
(
const
nsID
&
aId
InputStreamResolver
&
&
aResolver
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aResolver
)
;
if
(
!
mStreamList
|
|
!
mStreamList
-
>
ShouldOpenStreamFor
(
aId
)
)
{
aResolver
(
nullptr
)
;
return
;
}
mStreamList
-
>
GetManager
(
)
-
>
ExecuteOpenStream
(
this
Move
(
aResolver
)
aId
)
;
}
void
CacheStreamControlParent
:
:
NoteClosedAfterForget
(
const
nsID
&
aId
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
RecvNoteClosed
(
aId
)
;
}
#
ifdef
DEBUG
void
CacheStreamControlParent
:
:
AssertOwningThread
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
}
#
endif
void
CacheStreamControlParent
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
CloseAllReadStreamsWithoutReporting
(
)
;
if
(
!
mStreamList
)
{
return
;
}
mStreamList
-
>
GetManager
(
)
-
>
RemoveListener
(
this
)
;
mStreamList
-
>
RemoveStreamControl
(
this
)
;
mStreamList
-
>
NoteClosedAll
(
)
;
mStreamList
=
nullptr
;
}
mozilla
:
:
ipc
:
:
IPCResult
CacheStreamControlParent
:
:
RecvOpenStream
(
const
nsID
&
aStreamId
OpenStreamResolver
&
&
aResolver
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
CacheStreamControlParent
*
self
=
this
;
OpenStream
(
aStreamId
[
self
aResolver
]
(
nsCOMPtr
<
nsIInputStream
>
&
&
aStream
)
{
AutoIPCStream
stream
;
Unused
<
<
stream
.
Serialize
(
aStream
self
-
>
Manager
(
)
)
;
aResolver
(
stream
.
TakeOptionalValue
(
)
)
;
}
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CacheStreamControlParent
:
:
RecvNoteClosed
(
const
nsID
&
aId
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mStreamList
)
;
mStreamList
-
>
NoteClosed
(
aId
)
;
return
IPC_OK
(
)
;
}
void
CacheStreamControlParent
:
:
SetStreamList
(
StreamList
*
aStreamList
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mStreamList
)
;
mStreamList
=
aStreamList
;
}
void
CacheStreamControlParent
:
:
Close
(
const
nsID
&
aId
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
NotifyClose
(
aId
)
;
Unused
<
<
SendClose
(
aId
)
;
}
void
CacheStreamControlParent
:
:
CloseAll
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
NotifyCloseAll
(
)
;
Unused
<
<
SendCloseAll
(
)
;
}
void
CacheStreamControlParent
:
:
Shutdown
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
if
(
!
Send__delete__
(
this
)
)
{
NS_WARNING
(
"
Cache
failed
to
delete
stream
actor
.
"
)
;
return
;
}
}
void
CacheStreamControlParent
:
:
NotifyClose
(
const
nsID
&
aId
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
CloseReadStreams
(
aId
)
;
}
void
CacheStreamControlParent
:
:
NotifyCloseAll
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlParent
)
;
CloseAllReadStreams
(
)
;
}
}
}
}
