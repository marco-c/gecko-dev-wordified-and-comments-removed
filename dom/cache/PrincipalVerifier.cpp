#
include
"
mozilla
/
dom
/
cache
/
PrincipalVerifier
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ManagerId
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
CacheCommon
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsNetUtil
.
h
"
namespace
mozilla
:
:
dom
:
:
cache
{
using
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
;
using
mozilla
:
:
ipc
:
:
BackgroundParent
;
using
mozilla
:
:
ipc
:
:
PBackgroundParent
;
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
using
mozilla
:
:
ipc
:
:
PrincipalInfoToPrincipal
;
already_AddRefed
<
PrincipalVerifier
>
PrincipalVerifier
:
:
CreateAndDispatch
(
Listener
&
aListener
PBackgroundParent
*
aActor
const
PrincipalInfo
&
aPrincipalInfo
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
PrincipalVerifier
>
verifier
=
new
PrincipalVerifier
(
aListener
aActor
aPrincipalInfo
)
;
MOZ_ALWAYS_SUCCEEDS
(
NS_DispatchToMainThread
(
verifier
)
)
;
return
verifier
.
forget
(
)
;
}
void
PrincipalVerifier
:
:
AddListener
(
Listener
&
aListener
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mListenerList
.
Contains
(
&
aListener
)
)
;
mListenerList
.
AppendElement
(
WrapNotNullUnchecked
(
&
aListener
)
)
;
}
void
PrincipalVerifier
:
:
RemoveListener
(
Listener
&
aListener
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ALWAYS_TRUE
(
mListenerList
.
RemoveElement
(
&
aListener
)
)
;
}
PrincipalVerifier
:
:
PrincipalVerifier
(
Listener
&
aListener
PBackgroundParent
*
aActor
const
PrincipalInfo
&
aPrincipalInfo
)
:
Runnable
(
"
dom
:
:
cache
:
:
PrincipalVerifier
"
)
mActor
(
BackgroundParent
:
:
GetContentParent
(
aActor
)
)
mPrincipalInfo
(
aPrincipalInfo
)
mInitiatingEventTarget
(
GetCurrentSerialEventTarget
(
)
)
mResult
(
NS_OK
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInitiatingEventTarget
)
;
AddListener
(
aListener
)
;
}
PrincipalVerifier
:
:
~
PrincipalVerifier
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mListenerList
.
IsEmpty
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mActor
)
;
}
NS_IMETHODIMP
PrincipalVerifier
:
:
Run
(
)
{
if
(
NS_IsMainThread
(
)
)
{
VerifyOnMainThread
(
)
;
return
NS_OK
;
}
CompleteOnInitiatingThread
(
)
;
return
NS_OK
;
}
void
PrincipalVerifier
:
:
VerifyOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ContentParent
>
actor
=
std
:
:
move
(
mActor
)
;
CACHE_TRY_INSPECT
(
const
auto
&
principal
PrincipalInfoToPrincipal
(
mPrincipalInfo
)
QM_VOID
[
this
]
(
const
nsresult
result
)
{
DispatchToInitiatingThread
(
result
)
;
}
)
;
if
(
NS_WARN_IF
(
principal
-
>
GetIsNullPrincipal
(
)
)
)
{
DispatchToInitiatingThread
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
NS_WARN_IF
(
actor
&
&
principal
-
>
IsSystemPrincipal
(
)
)
)
{
DispatchToInitiatingThread
(
NS_ERROR_FAILURE
)
;
return
;
}
actor
=
nullptr
;
#
ifdef
DEBUG
nsresult
rv
=
NS_OK
;
if
(
!
principal
-
>
IsSystemPrincipal
(
)
)
{
nsAutoCString
origin
;
rv
=
principal
-
>
GetOriginNoSuffix
(
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
DispatchToInitiatingThread
(
rv
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
DispatchToInitiatingThread
(
rv
)
;
return
;
}
rv
=
principal
-
>
CheckMayLoad
(
uri
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
DispatchToInitiatingThread
(
rv
)
;
return
;
}
}
#
endif
auto
managerIdOrErr
=
ManagerId
:
:
Create
(
principal
)
;
if
(
NS_WARN_IF
(
managerIdOrErr
.
isErr
(
)
)
)
{
DispatchToInitiatingThread
(
managerIdOrErr
.
unwrapErr
(
)
)
;
return
;
}
mManagerId
=
managerIdOrErr
.
unwrap
(
)
;
DispatchToInitiatingThread
(
NS_OK
)
;
}
void
PrincipalVerifier
:
:
CompleteOnInitiatingThread
(
)
{
AssertIsOnBackgroundThread
(
)
;
for
(
const
auto
&
listener
:
mListenerList
.
ForwardRange
(
)
)
{
listener
-
>
OnPrincipalVerified
(
mResult
mManagerId
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mListenerList
.
IsEmpty
(
)
)
;
}
void
PrincipalVerifier
:
:
DispatchToInitiatingThread
(
nsresult
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResult
=
aRv
;
QM_WARNONLY_TRY
(
mInitiatingEventTarget
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
}
}
