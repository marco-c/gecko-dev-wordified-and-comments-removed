#
include
"
QuotaClientImpl
.
h
"
#
include
"
DBAction
.
h
"
#
include
"
FileUtilsImpl
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
DBSchema
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Manager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
UsageInfo
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
{
using
mozilla
:
:
Atomic
;
using
mozilla
:
:
MutexAutoLock
;
using
mozilla
:
:
Some
;
using
mozilla
:
:
Unused
;
using
mozilla
:
:
dom
:
:
ContentParentId
;
using
mozilla
:
:
dom
:
:
cache
:
:
DirPaddingFile
;
using
mozilla
:
:
dom
:
:
cache
:
:
kCachesSQLiteFilename
;
using
mozilla
:
:
dom
:
:
cache
:
:
Manager
;
using
mozilla
:
:
dom
:
:
cache
:
:
QuotaInfo
;
using
mozilla
:
:
dom
:
:
quota
:
:
AssertIsOnIOThread
;
using
mozilla
:
:
dom
:
:
quota
:
:
Client
;
using
mozilla
:
:
dom
:
:
quota
:
:
DatabaseUsageType
;
using
mozilla
:
:
dom
:
:
quota
:
:
PERSISTENCE_TYPE_DEFAULT
;
using
mozilla
:
:
dom
:
:
quota
:
:
PersistenceType
;
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaManager
;
using
mozilla
:
:
dom
:
:
quota
:
:
UsageInfo
;
using
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
;
static
nsresult
GetBodyUsage
(
nsIFile
*
aMorgueDir
const
Atomic
<
bool
>
&
aCanceled
UsageInfo
*
aUsageInfo
const
bool
aInitializing
)
{
AssertIsOnIOThread
(
)
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aMorgueDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
bodyDir
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
bodyDir
)
)
)
&
&
bodyDir
&
&
!
aCanceled
)
{
if
(
NS_WARN_IF
(
QuotaManager
:
:
IsShuttingDown
(
)
)
)
{
return
NS_ERROR_ABORT
;
}
bool
isDir
;
rv
=
bodyDir
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isDir
)
{
QuotaInfo
dummy
;
mozilla
:
:
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
dummy
bodyDir
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
continue
;
}
const
QuotaInfo
dummy
;
const
auto
getUsage
=
[
&
aUsageInfo
]
(
nsIFile
*
bodyFile
const
nsACString
&
leafName
bool
&
fileDeleted
)
{
MOZ_DIAGNOSTIC_ASSERT
(
bodyFile
)
;
Unused
<
<
leafName
;
int64_t
fileSize
;
nsresult
rv
=
bodyFile
-
>
GetFileSize
(
&
fileSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_DIAGNOSTIC_ASSERT
(
fileSize
>
=
0
)
;
*
aUsageInfo
+
=
DatabaseUsageType
(
Some
(
fileSize
)
)
;
fileDeleted
=
false
;
return
NS_OK
;
}
;
rv
=
mozilla
:
:
dom
:
:
cache
:
:
BodyTraverseFiles
(
dummy
bodyDir
getUsage
aInitializing
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
static
nsresult
LockedGetPaddingSizeFromDB
(
nsIFile
*
aDir
const
nsACString
&
aGroup
const
nsACString
&
aOrigin
int64_t
*
aPaddingSizeOut
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aDir
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPaddingSizeOut
)
;
*
aPaddingSizeOut
=
0
;
QuotaInfo
quotaInfo
;
quotaInfo
.
mGroup
=
aGroup
;
quotaInfo
.
mOrigin
=
aOrigin
;
MOZ_DIAGNOSTIC_ASSERT
(
quotaInfo
.
mDirectoryLockId
=
=
-
1
)
;
nsCOMPtr
<
nsIFile
>
dbFile
;
nsresult
rv
=
aDir
-
>
Clone
(
getter_AddRefs
(
dbFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
dbFile
-
>
Append
(
kCachesSQLiteFilename
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
exists
=
false
;
rv
=
dbFile
-
>
Exists
(
&
exists
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
exists
)
{
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageConnection
>
conn
;
rv
=
mozilla
:
:
dom
:
:
cache
:
:
OpenDBConnection
(
quotaInfo
dbFile
getter_AddRefs
(
conn
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mozilla
:
:
dom
:
:
cache
:
:
db
:
:
CreateOrMigrateSchema
(
conn
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int64_t
paddingSize
=
0
;
rv
=
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingRestore
(
aDir
conn
false
&
paddingSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
*
aPaddingSizeOut
=
paddingSize
;
return
rv
;
}
}
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
const
nsLiteralString
kCachesSQLiteFilename
=
u
"
caches
.
sqlite
"
_ns
;
CacheQuotaClient
:
:
CacheQuotaClient
(
)
:
mDirPaddingFileMutex
(
"
DOMCacheQuotaClient
.
mDirPaddingFileMutex
"
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
sInstance
)
;
sInstance
=
this
;
}
CacheQuotaClient
*
CacheQuotaClient
:
:
Get
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
)
;
return
sInstance
;
}
CacheQuotaClient
:
:
Type
CacheQuotaClient
:
:
GetType
(
)
{
return
DOMCACHE
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
InitOrigin
(
PersistenceType
aPersistenceType
const
nsACString
&
aGroup
const
nsACString
&
aOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
return
GetUsageForOriginInternal
(
aPersistenceType
aGroup
aOrigin
aCanceled
true
)
;
}
nsresult
CacheQuotaClient
:
:
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
nsACString
&
aGroup
const
nsACString
&
aOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
UNKNOWN_FILE_WARNING
(
NS_LITERAL_STRING_FROM_CSTRING
(
DOMCACHE_DIRECTORY_NAME
)
)
;
return
NS_OK
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
nsACString
&
aGroup
const
nsACString
&
aOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
return
GetUsageForOriginInternal
(
aPersistenceType
aGroup
aOrigin
aCanceled
false
)
;
}
void
CacheQuotaClient
:
:
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
{
}
void
CacheQuotaClient
:
:
ReleaseIOThreadObjects
(
)
{
}
void
CacheQuotaClient
:
:
AbortOperations
(
const
nsACString
&
aOrigin
)
{
AssertIsOnBackgroundThread
(
)
;
Manager
:
:
Abort
(
aOrigin
)
;
}
void
CacheQuotaClient
:
:
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
{
}
void
CacheQuotaClient
:
:
StartIdleMaintenance
(
)
{
}
void
CacheQuotaClient
:
:
StopIdleMaintenance
(
)
{
}
void
CacheQuotaClient
:
:
ShutdownWorkThreads
(
)
{
AssertIsOnBackgroundThread
(
)
;
Manager
:
:
ShutdownAll
(
)
;
}
nsresult
CacheQuotaClient
:
:
UpgradeStorageFrom2_0To2_1
(
nsIFile
*
aDirectory
)
{
AssertIsOnIOThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aDirectory
)
;
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
nsresult
rv
=
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingInit
(
aDirectory
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
CacheQuotaClient
:
:
RestorePaddingFileInternal
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aConn
)
;
int64_t
dummyPaddingSize
;
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
nsresult
rv
=
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingRestore
(
aBaseDir
aConn
true
&
dummyPaddingSize
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
nsresult
CacheQuotaClient
:
:
WipePaddingFileInternal
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
MOZ_ASSERT
(
mozilla
:
:
dom
:
:
cache
:
:
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
FILE
)
)
;
int64_t
paddingSize
=
0
;
bool
temporaryPaddingFileExist
=
mozilla
:
:
dom
:
:
cache
:
:
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
;
if
(
temporaryPaddingFileExist
|
|
NS_WARN_IF
(
NS_FAILED
(
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingGet
(
aBaseDir
&
paddingSize
)
)
)
)
{
NS_WARNING
(
"
Cannnot
read
padding
size
from
file
!
"
)
;
paddingSize
=
0
;
}
if
(
paddingSize
>
0
)
{
mozilla
:
:
dom
:
:
cache
:
:
DecreaseUsageForQuotaInfo
(
aQuotaInfo
paddingSize
)
;
}
nsresult
rv
=
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
FILE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingInit
(
aBaseDir
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
CacheQuotaClient
:
:
~
CacheQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
=
=
this
)
;
sInstance
=
nullptr
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
GetUsageForOriginInternal
(
PersistenceType
aPersistenceType
const
nsACString
&
aGroup
const
nsACString
&
aOrigin
const
AtomicBool
&
aCanceled
const
bool
aInitializing
)
{
AssertIsOnIOThread
(
)
;
#
ifndef
NIGHTLY_BUILD
Unused
<
<
aInitializing
;
#
endif
QuotaManager
*
qm
=
QuotaManager
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
qm
)
;
nsCOMPtr
<
nsIFile
>
dir
;
nsresult
rv
=
qm
-
>
GetDirectoryForOrigin
(
aPersistenceType
aOrigin
getter_AddRefs
(
dir
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaExternalError
Cache_GetDirForOri
)
;
return
Err
(
rv
)
;
}
rv
=
dir
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
DOMCACHE_DIRECTORY_NAME
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaExternalError
Cache_Append
)
;
return
Err
(
rv
)
;
}
bool
useCachedValue
=
false
;
int64_t
paddingSize
=
0
;
{
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
if
(
mozilla
:
:
dom
:
:
cache
:
:
DirectoryPaddingFileExists
(
dir
DirPaddingFile
:
:
TMP_FILE
)
|
|
NS_WARN_IF
(
NS_FAILED
(
mozilla
:
:
dom
:
:
cache
:
:
LockedDirectoryPaddingGet
(
dir
&
paddingSize
)
)
)
)
{
if
(
aInitializing
)
{
rv
=
LockedGetPaddingSizeFromDB
(
dir
aGroup
aOrigin
&
paddingSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaInternalError
Cache_GetPaddingSize
)
;
return
Err
(
rv
)
;
}
}
else
{
useCachedValue
=
true
;
}
}
}
UsageInfo
usageInfo
;
if
(
useCachedValue
)
{
uint64_t
usage
;
if
(
qm
-
>
GetUsageForClient
(
PERSISTENCE_TYPE_DEFAULT
aGroup
aOrigin
Client
:
:
DOMCACHE
usage
)
)
{
usageInfo
+
=
DatabaseUsageType
(
Some
(
usage
)
)
;
}
return
usageInfo
;
}
usageInfo
+
=
DatabaseUsageType
(
Some
(
paddingSize
)
)
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
rv
=
dir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaExternalError
Cache_GetDirEntries
)
;
return
Err
(
rv
)
;
}
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
&
&
!
aCanceled
)
{
if
(
NS_WARN_IF
(
QuotaManager
:
:
IsShuttingDown
(
)
)
)
{
return
Err
(
NS_ERROR_ABORT
)
;
}
nsAutoString
leafName
;
rv
=
file
-
>
GetLeafName
(
leafName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaExternalError
Cache_GetLeafName
)
;
return
Err
(
rv
)
;
}
bool
isDir
;
rv
=
file
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaExternalError
Cache_IsDirectory
)
;
return
Err
(
rv
)
;
}
if
(
isDir
)
{
if
(
leafName
.
EqualsLiteral
(
"
morgue
"
)
)
{
rv
=
GetBodyUsage
(
file
aCanceled
&
usageInfo
aInitializing
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
if
(
rv
!
=
NS_ERROR_ABORT
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaExternalError
Cache_GetBodyUsage
)
;
}
return
Err
(
rv
)
;
}
}
else
{
NS_WARNING
(
"
Unknown
Cache
directory
found
!
"
)
;
}
continue
;
}
if
(
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
journal
"
)
|
|
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
shm
"
)
|
|
leafName
.
Find
(
"
caches
.
sqlite
-
mj
"
_ns
false
0
0
)
=
=
0
|
|
leafName
.
EqualsLiteral
(
"
context_open
.
marker
"
)
)
{
continue
;
}
if
(
leafName
.
Equals
(
kCachesSQLiteFilename
)
|
|
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
wal
"
)
)
{
int64_t
fileSize
;
rv
=
file
-
>
GetFileSize
(
&
fileSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
REPORT_TELEMETRY_ERR_IN_INIT
(
aInitializing
kQuotaExternalError
Cache_GetFileSize
)
;
return
Err
(
rv
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
fileSize
>
=
0
)
;
usageInfo
+
=
DatabaseUsageType
(
Some
(
fileSize
)
)
;
continue
;
}
if
(
leafName
.
EqualsLiteral
(
PADDING_FILE_NAME
)
|
|
leafName
.
EqualsLiteral
(
PADDING_TMP_FILE_NAME
)
)
{
continue
;
}
NS_WARNING
(
"
Unknown
Cache
file
found
!
"
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
usageInfo
;
}
CacheQuotaClient
*
CacheQuotaClient
:
:
sInstance
=
nullptr
;
already_AddRefed
<
quota
:
:
Client
>
CreateQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
CacheQuotaClient
>
ref
=
new
CacheQuotaClient
(
)
;
return
ref
.
forget
(
)
;
}
nsresult
RestorePaddingFile
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aConn
)
;
RefPtr
<
CacheQuotaClient
>
cacheQuotaClient
=
CacheQuotaClient
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cacheQuotaClient
)
;
nsresult
rv
=
cacheQuotaClient
-
>
RestorePaddingFileInternal
(
aBaseDir
aConn
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
nsresult
WipePaddingFile
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
RefPtr
<
CacheQuotaClient
>
cacheQuotaClient
=
CacheQuotaClient
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cacheQuotaClient
)
;
nsresult
rv
=
cacheQuotaClient
-
>
WipePaddingFileInternal
(
aQuotaInfo
aBaseDir
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
}
}
}
