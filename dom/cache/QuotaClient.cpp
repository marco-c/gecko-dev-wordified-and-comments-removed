#
include
"
QuotaClientImpl
.
h
"
#
include
"
DBAction
.
h
"
#
include
"
FileUtilsImpl
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
DBSchema
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Manager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
UsageInfo
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
dom
:
:
cache
{
using
mozilla
:
:
dom
:
:
quota
:
:
AssertIsOnIOThread
;
using
mozilla
:
:
dom
:
:
quota
:
:
Client
;
using
mozilla
:
:
dom
:
:
quota
:
:
CloneFileAndAppend
;
using
mozilla
:
:
dom
:
:
quota
:
:
DatabaseUsageType
;
using
mozilla
:
:
dom
:
:
quota
:
:
GroupAndOrigin
;
using
mozilla
:
:
dom
:
:
quota
:
:
PERSISTENCE_TYPE_DEFAULT
;
using
mozilla
:
:
dom
:
:
quota
:
:
PersistenceType
;
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaManager
;
using
mozilla
:
:
dom
:
:
quota
:
:
UsageInfo
;
using
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
;
namespace
{
nsresult
GetBodyUsage
(
nsIFile
*
aMorgueDir
const
Atomic
<
bool
>
&
aCanceled
UsageInfo
*
aUsageInfo
const
bool
aInitializing
)
{
AssertIsOnIOThread
(
)
;
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
nsresult
rv
=
aMorgueDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIFile
>
bodyDir
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
bodyDir
)
)
)
&
&
bodyDir
&
&
!
aCanceled
)
{
if
(
NS_WARN_IF
(
QuotaManager
:
:
IsShuttingDown
(
)
)
)
{
return
NS_ERROR_ABORT
;
}
bool
isDir
;
rv
=
bodyDir
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
isDir
)
{
QuotaInfo
dummy
;
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
dummy
bodyDir
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
continue
;
}
const
QuotaInfo
dummy
;
const
auto
getUsage
=
[
&
aUsageInfo
]
(
nsIFile
*
bodyFile
const
nsACString
&
leafName
bool
&
fileDeleted
)
{
MOZ_DIAGNOSTIC_ASSERT
(
bodyFile
)
;
Unused
<
<
leafName
;
int64_t
fileSize
;
nsresult
rv
=
bodyFile
-
>
GetFileSize
(
&
fileSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_DIAGNOSTIC_ASSERT
(
fileSize
>
=
0
)
;
*
aUsageInfo
+
=
DatabaseUsageType
(
Some
(
fileSize
)
)
;
fileDeleted
=
false
;
return
NS_OK
;
}
;
rv
=
BodyTraverseFiles
(
dummy
bodyDir
getUsage
aInitializing
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
Result
<
int64_t
nsresult
>
LockedGetPaddingSizeFromDB
(
nsIFile
&
aDir
const
GroupAndOrigin
&
aGroupAndOrigin
)
{
QuotaInfo
quotaInfo
;
static_cast
<
GroupAndOrigin
&
>
(
quotaInfo
)
=
aGroupAndOrigin
;
MOZ_DIAGNOSTIC_ASSERT
(
quotaInfo
.
mDirectoryLockId
=
=
-
1
)
;
CACHE_TRY_INSPECT
(
const
auto
&
dbFile
CloneFileAndAppend
(
aDir
kCachesSQLiteFilename
)
)
;
CACHE_TRY_INSPECT
(
const
bool
&
exists
MOZ_TO_RESULT_INVOKE
(
dbFile
Exists
)
)
;
if
(
!
exists
)
{
return
0
;
}
CACHE_TRY_INSPECT
(
const
auto
&
conn
ToResultInvoke
<
nsCOMPtr
<
mozIStorageConnection
>
>
(
OpenDBConnection
quotaInfo
dbFile
)
)
;
CACHE_TRY
(
db
:
:
CreateOrMigrateSchema
(
*
conn
)
)
;
CACHE_TRY_RETURN
(
ToResultInvoke
<
int64_t
>
(
LockedDirectoryPaddingRestore
&
aDir
conn
false
)
)
;
}
}
const
nsLiteralString
kCachesSQLiteFilename
=
u
"
caches
.
sqlite
"
_ns
;
CacheQuotaClient
:
:
CacheQuotaClient
(
)
:
mDirPaddingFileMutex
(
"
DOMCacheQuotaClient
.
mDirPaddingFileMutex
"
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
sInstance
)
;
sInstance
=
this
;
}
CacheQuotaClient
*
CacheQuotaClient
:
:
Get
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
)
;
return
sInstance
;
}
CacheQuotaClient
:
:
Type
CacheQuotaClient
:
:
GetType
(
)
{
return
DOMCACHE
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
InitOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
return
GetUsageForOriginInternal
(
aPersistenceType
aGroupAndOrigin
aCanceled
true
)
;
}
nsresult
CacheQuotaClient
:
:
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
UNKNOWN_FILE_WARNING
(
NS_LITERAL_STRING_FROM_CSTRING
(
DOMCACHE_DIRECTORY_NAME
)
)
;
return
NS_OK
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
return
GetUsageForOriginInternal
(
aPersistenceType
aGroupAndOrigin
aCanceled
false
)
;
}
void
CacheQuotaClient
:
:
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
{
}
void
CacheQuotaClient
:
:
ReleaseIOThreadObjects
(
)
{
}
void
CacheQuotaClient
:
:
AbortOperations
(
const
nsACString
&
aOrigin
)
{
AssertIsOnBackgroundThread
(
)
;
Manager
:
:
Abort
(
aOrigin
)
;
}
void
CacheQuotaClient
:
:
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
{
}
void
CacheQuotaClient
:
:
StartIdleMaintenance
(
)
{
}
void
CacheQuotaClient
:
:
StopIdleMaintenance
(
)
{
}
void
CacheQuotaClient
:
:
ShutdownWorkThreads
(
)
{
AssertIsOnBackgroundThread
(
)
;
Manager
:
:
ShutdownAll
(
)
;
}
nsresult
CacheQuotaClient
:
:
UpgradeStorageFrom2_0To2_1
(
nsIFile
*
aDirectory
)
{
AssertIsOnIOThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aDirectory
)
;
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
nsresult
rv
=
LockedDirectoryPaddingInit
(
aDirectory
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
CacheQuotaClient
:
:
RestorePaddingFileInternal
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aConn
)
;
int64_t
dummyPaddingSize
;
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
nsresult
rv
=
LockedDirectoryPaddingRestore
(
aBaseDir
aConn
true
&
dummyPaddingSize
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
nsresult
CacheQuotaClient
:
:
WipePaddingFileInternal
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
MOZ_ASSERT
(
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
FILE
)
)
;
int64_t
paddingSize
=
0
;
bool
temporaryPaddingFileExist
=
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
;
if
(
temporaryPaddingFileExist
|
|
NS_WARN_IF
(
NS_FAILED
(
LockedDirectoryPaddingGet
(
aBaseDir
&
paddingSize
)
)
)
)
{
NS_WARNING
(
"
Cannnot
read
padding
size
from
file
!
"
)
;
paddingSize
=
0
;
}
if
(
paddingSize
>
0
)
{
DecreaseUsageForQuotaInfo
(
aQuotaInfo
paddingSize
)
;
}
nsresult
rv
=
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
FILE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
LockedDirectoryPaddingInit
(
aBaseDir
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
CacheQuotaClient
:
:
~
CacheQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
=
=
this
)
;
sInstance
=
nullptr
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
GetUsageForOriginInternal
(
PersistenceType
aPersistenceType
const
GroupAndOrigin
&
aGroupAndOrigin
const
AtomicBool
&
aCanceled
const
bool
aInitializing
)
{
AssertIsOnIOThread
(
)
;
QuotaManager
*
const
qm
=
QuotaManager
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
qm
)
;
CACHE_TRY_INSPECT
(
const
auto
&
dir
qm
-
>
GetDirectoryForOrigin
(
aPersistenceType
aGroupAndOrigin
.
mOrigin
)
)
;
CACHE_TRY
(
dir
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
DOMCACHE_DIRECTORY_NAME
)
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
maybePaddingSize
(
[
this
&
dir
aInitializing
&
aGroupAndOrigin
]
(
)
-
>
Result
<
Maybe
<
int64_t
>
nsresult
>
{
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
if
(
!
DirectoryPaddingFileExists
(
dir
DirPaddingFile
:
:
TMP_FILE
)
)
{
const
auto
&
maybePaddingSize
=
[
&
dir
]
(
)
-
>
Maybe
<
int64_t
>
{
CACHE_TRY_RETURN
(
ToResultInvoke
<
int64_t
>
(
LockedDirectoryPaddingGet
dir
)
.
map
(
Some
<
int64_t
>
)
Nothing
{
}
)
;
}
(
)
;
if
(
maybePaddingSize
)
{
return
maybePaddingSize
;
}
}
if
(
aInitializing
)
{
CACHE_TRY_RETURN
(
LockedGetPaddingSizeFromDB
(
*
dir
aGroupAndOrigin
)
.
map
(
Some
<
int64_t
>
)
)
;
}
return
Maybe
<
int64_t
>
{
}
;
}
(
)
)
)
;
UsageInfo
usageInfo
;
if
(
!
maybePaddingSize
)
{
uint64_t
usage
;
if
(
qm
-
>
GetUsageForClient
(
PERSISTENCE_TYPE_DEFAULT
aGroupAndOrigin
Client
:
:
DOMCACHE
usage
)
)
{
usageInfo
+
=
DatabaseUsageType
(
Some
(
usage
)
)
;
}
return
usageInfo
;
}
usageInfo
+
=
DatabaseUsageType
(
maybePaddingSize
)
;
CACHE_TRY_INSPECT
(
const
auto
&
entries
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
nsIDirectoryEnumerator
>
dir
GetDirectoryEntries
)
)
;
CACHE_TRY
(
CollectEach
(
[
&
entries
&
aCanceled
]
(
)
-
>
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
{
if
(
aCanceled
)
{
return
nsCOMPtr
<
nsIFile
>
{
}
;
}
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
nsIFile
>
entries
GetNextFile
)
)
;
}
[
&
aCanceled
&
usageInfo
aInitializing
]
(
const
nsCOMPtr
<
nsIFile
>
&
file
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY
(
OkIf
(
!
QuotaManager
:
:
IsShuttingDown
(
)
)
Err
(
NS_ERROR_ABORT
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
leafName
MOZ_TO_RESULT_INVOKE_TYPED
(
nsAutoString
file
GetLeafName
)
)
;
CACHE_TRY_INSPECT
(
const
bool
&
isDir
MOZ_TO_RESULT_INVOKE
(
file
IsDirectory
)
)
;
if
(
isDir
)
{
if
(
leafName
.
EqualsLiteral
(
"
morgue
"
)
)
{
CACHE_TRY
(
GetBodyUsage
(
file
aCanceled
&
usageInfo
aInitializing
)
)
;
}
else
{
NS_WARNING
(
"
Unknown
Cache
directory
found
!
"
)
;
}
return
Ok
{
}
;
}
if
(
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
journal
"
)
|
|
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
shm
"
)
|
|
leafName
.
Find
(
"
caches
.
sqlite
-
mj
"
_ns
false
0
0
)
=
=
0
|
|
leafName
.
EqualsLiteral
(
"
context_open
.
marker
"
)
)
{
return
Ok
{
}
;
}
if
(
leafName
.
Equals
(
kCachesSQLiteFilename
)
|
|
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
wal
"
)
)
{
CACHE_TRY_INSPECT
(
const
int64_t
&
fileSize
MOZ_TO_RESULT_INVOKE
(
file
GetFileSize
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
fileSize
>
=
0
)
;
usageInfo
+
=
DatabaseUsageType
(
Some
(
fileSize
)
)
;
return
Ok
{
}
;
}
if
(
leafName
.
EqualsLiteral
(
PADDING_FILE_NAME
)
|
|
leafName
.
EqualsLiteral
(
PADDING_TMP_FILE_NAME
)
)
{
return
Ok
{
}
;
}
NS_WARNING
(
"
Unknown
Cache
file
found
!
"
)
;
return
Ok
{
}
;
}
)
)
;
return
usageInfo
;
}
CacheQuotaClient
*
CacheQuotaClient
:
:
sInstance
=
nullptr
;
already_AddRefed
<
quota
:
:
Client
>
CreateQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
CacheQuotaClient
>
ref
=
new
CacheQuotaClient
(
)
;
return
ref
.
forget
(
)
;
}
nsresult
RestorePaddingFile
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aConn
)
;
RefPtr
<
CacheQuotaClient
>
cacheQuotaClient
=
CacheQuotaClient
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cacheQuotaClient
)
;
nsresult
rv
=
cacheQuotaClient
-
>
RestorePaddingFileInternal
(
aBaseDir
aConn
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
nsresult
WipePaddingFile
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
RefPtr
<
CacheQuotaClient
>
cacheQuotaClient
=
CacheQuotaClient
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cacheQuotaClient
)
;
nsresult
rv
=
cacheQuotaClient
-
>
WipePaddingFileInternal
(
aQuotaInfo
aBaseDir
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
rv
;
}
}
