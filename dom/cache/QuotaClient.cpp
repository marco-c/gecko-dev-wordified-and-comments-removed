#
include
"
QuotaClientImpl
.
h
"
#
include
"
DBAction
.
h
"
#
include
"
FileUtilsImpl
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
DBSchema
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Manager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
UsageInfo
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
dom
:
:
cache
{
using
mozilla
:
:
dom
:
:
quota
:
:
AssertIsOnIOThread
;
using
mozilla
:
:
dom
:
:
quota
:
:
Client
;
using
mozilla
:
:
dom
:
:
quota
:
:
CloneFileAndAppend
;
using
mozilla
:
:
dom
:
:
quota
:
:
DatabaseUsageType
;
using
mozilla
:
:
dom
:
:
quota
:
:
GetDirEntryKind
;
using
mozilla
:
:
dom
:
:
quota
:
:
nsIFileKind
;
using
mozilla
:
:
dom
:
:
quota
:
:
OriginMetadata
;
using
mozilla
:
:
dom
:
:
quota
:
:
PERSISTENCE_TYPE_DEFAULT
;
using
mozilla
:
:
dom
:
:
quota
:
:
PersistenceType
;
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaManager
;
using
mozilla
:
:
dom
:
:
quota
:
:
UsageInfo
;
using
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
;
namespace
{
template
<
typename
StepFunc
>
Result
<
UsageInfo
nsresult
>
ReduceUsageInfo
(
nsIFile
&
aDir
const
Atomic
<
bool
>
&
aCanceled
const
StepFunc
&
aStepFunc
)
{
CACHE_TRY_RETURN
(
quota
:
:
ReduceEachFileAtomicCancelable
(
aDir
aCanceled
UsageInfo
{
}
[
&
aStepFunc
]
(
UsageInfo
usageInfo
const
nsCOMPtr
<
nsIFile
>
&
bodyDir
)
-
>
Result
<
UsageInfo
nsresult
>
{
CACHE_TRY
(
OkIf
(
!
QuotaManager
:
:
IsShuttingDown
(
)
)
Err
(
NS_ERROR_ABORT
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
stepUsageInfo
aStepFunc
(
bodyDir
)
)
;
return
usageInfo
+
stepUsageInfo
;
}
)
)
;
}
Result
<
UsageInfo
nsresult
>
GetBodyUsage
(
nsIFile
&
aMorgueDir
const
Atomic
<
bool
>
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
CACHE_TRY_RETURN
(
ReduceUsageInfo
(
aMorgueDir
aCanceled
[
]
(
const
nsCOMPtr
<
nsIFile
>
&
bodyDir
)
-
>
Result
<
UsageInfo
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
dirEntryKind
GetDirEntryKind
(
*
bodyDir
)
)
;
if
(
dirEntryKind
!
=
nsIFileKind
:
:
ExistsAsDirectory
)
{
if
(
dirEntryKind
=
=
nsIFileKind
:
:
ExistsAsFile
)
{
const
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
QuotaInfo
{
}
*
bodyDir
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
}
return
UsageInfo
{
}
;
}
UsageInfo
usageInfo
;
const
auto
getUsage
=
[
&
usageInfo
]
(
nsIFile
&
bodyFile
const
nsACString
&
leafName
)
-
>
Result
<
bool
nsresult
>
{
Unused
<
<
leafName
;
CACHE_TRY_INSPECT
(
const
int64_t
&
fileSize
MOZ_TO_RESULT_INVOKE
(
bodyFile
GetFileSize
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
fileSize
>
=
0
)
;
usageInfo
+
=
DatabaseUsageType
(
Some
(
fileSize
)
)
;
return
false
;
}
;
CACHE_TRY
(
ToResult
(
BodyTraverseFiles
(
QuotaInfo
{
}
*
bodyDir
getUsage
true
false
)
)
.
orElse
(
[
]
(
const
nsresult
rv
)
-
>
Result
<
Ok
nsresult
>
{
if
(
rv
=
=
NS_ERROR_FILE_FS_CORRUPTED
)
{
return
Ok
{
}
;
}
return
Err
(
rv
)
;
}
)
)
;
return
usageInfo
;
}
)
)
;
}
Result
<
int64_t
nsresult
>
GetPaddingSizeFromDB
(
nsIFile
&
aDir
nsIFile
&
aDBFile
const
OriginMetadata
&
aOriginMetadata
)
{
QuotaInfo
quotaInfo
;
static_cast
<
OriginMetadata
&
>
(
quotaInfo
)
=
aOriginMetadata
;
MOZ_DIAGNOSTIC_ASSERT
(
quotaInfo
.
mDirectoryLockId
=
=
-
1
)
;
#
ifdef
DEBUG
{
CACHE_TRY_INSPECT
(
const
bool
&
exists
MOZ_TO_RESULT_INVOKE
(
aDBFile
Exists
)
)
;
MOZ_ASSERT
(
exists
)
;
}
#
endif
CACHE_TRY_INSPECT
(
const
auto
&
conn
OpenDBConnection
(
quotaInfo
aDBFile
)
)
;
CACHE_TRY
(
db
:
:
CreateOrMigrateSchema
(
*
conn
)
)
;
CACHE_TRY_RETURN
(
DirectoryPaddingRestore
(
aDir
*
conn
false
)
)
;
}
}
const
nsLiteralString
kCachesSQLiteFilename
=
u
"
caches
.
sqlite
"
_ns
;
const
nsLiteralString
kMorgueDirectoryFilename
=
u
"
morgue
"
_ns
;
CacheQuotaClient
:
:
CacheQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
sInstance
)
;
sInstance
=
this
;
}
CacheQuotaClient
*
CacheQuotaClient
:
:
Get
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
)
;
return
sInstance
;
}
CacheQuotaClient
:
:
Type
CacheQuotaClient
:
:
GetType
(
)
{
return
DOMCACHE
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
InitOrigin
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
QuotaManager
*
const
qm
=
QuotaManager
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
qm
)
;
CACHE_TRY_INSPECT
(
const
auto
&
dir
qm
-
>
GetDirectoryForOrigin
(
aPersistenceType
aOriginMetadata
.
mOrigin
)
)
;
CACHE_TRY
(
dir
-
>
Append
(
NS_LITERAL_STRING_FROM_CSTRING
(
DOMCACHE_DIRECTORY_NAME
)
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
cachesSQLiteFile
(
[
dir
]
(
)
-
>
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
cachesSQLite
CloneFileAndAppend
(
*
dir
kCachesSQLiteFilename
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
dirEntryKind
GetDirEntryKind
(
*
cachesSQLite
)
)
;
if
(
dirEntryKind
=
=
nsIFileKind
:
:
DoesNotExist
)
{
CACHE_TRY
(
mozilla
:
:
dom
:
:
cache
:
:
DirectoryPaddingDeleteFile
(
*
dir
DirPaddingFile
:
:
TMP_FILE
)
)
;
CACHE_TRY
(
mozilla
:
:
dom
:
:
cache
:
:
DirectoryPaddingDeleteFile
(
*
dir
DirPaddingFile
:
:
FILE
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
morgueDir
CloneFileAndAppend
(
*
dir
kMorgueDirectoryFilename
)
)
;
QuotaInfo
dummy
;
CACHE_TRY
(
mozilla
:
:
dom
:
:
cache
:
:
RemoveNsIFileRecursively
(
dummy
*
morgueDir
false
)
)
;
return
nsCOMPtr
<
nsIFile
>
{
nullptr
}
;
}
CACHE_TRY
(
OkIf
(
dirEntryKind
=
=
nsIFileKind
:
:
ExistsAsFile
)
Err
(
NS_ERROR_FAILURE
)
)
;
return
cachesSQLite
;
}
(
)
)
)
;
CACHE_TRY
(
OkIf
(
!
!
cachesSQLiteFile
)
UsageInfo
{
}
)
;
CACHE_TRY_INSPECT
(
const
auto
&
paddingSize
(
[
dir
cachesSQLiteFile
&
aOriginMetadata
]
(
)
-
>
Result
<
int64_t
nsresult
>
{
if
(
!
DirectoryPaddingFileExists
(
*
dir
DirPaddingFile
:
:
TMP_FILE
)
)
{
QM_WARNONLY_TRY_UNWRAP
(
const
auto
maybePaddingSize
DirectoryPaddingGet
(
*
dir
)
)
;
if
(
maybePaddingSize
)
{
return
maybePaddingSize
.
ref
(
)
;
}
}
CACHE_TRY_RETURN
(
GetPaddingSizeFromDB
(
*
dir
*
cachesSQLiteFile
aOriginMetadata
)
)
;
}
(
)
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
innerUsageInfo
ReduceUsageInfo
(
*
dir
aCanceled
[
&
aCanceled
]
(
const
nsCOMPtr
<
nsIFile
>
&
file
)
-
>
Result
<
UsageInfo
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
leafName
MOZ_TO_RESULT_INVOKE_TYPED
(
nsAutoString
file
GetLeafName
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
dirEntryKind
GetDirEntryKind
(
*
file
)
)
;
switch
(
dirEntryKind
)
{
case
nsIFileKind
:
:
ExistsAsDirectory
:
if
(
leafName
.
EqualsLiteral
(
"
morgue
"
)
)
{
CACHE_TRY_RETURN
(
GetBodyUsage
(
*
file
aCanceled
)
)
;
}
else
{
NS_WARNING
(
"
Unknown
Cache
directory
found
!
"
)
;
}
break
;
case
nsIFileKind
:
:
ExistsAsFile
:
if
(
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
journal
"
)
|
|
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
shm
"
)
|
|
leafName
.
Find
(
"
caches
.
sqlite
-
mj
"
_ns
false
0
0
)
=
=
0
|
|
leafName
.
EqualsLiteral
(
"
context_open
.
marker
"
)
)
{
break
;
}
if
(
leafName
.
Equals
(
kCachesSQLiteFilename
)
|
|
leafName
.
EqualsLiteral
(
"
caches
.
sqlite
-
wal
"
)
)
{
CACHE_TRY_INSPECT
(
const
int64_t
&
fileSize
MOZ_TO_RESULT_INVOKE
(
file
GetFileSize
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
fileSize
>
=
0
)
;
return
UsageInfo
{
DatabaseUsageType
(
Some
(
fileSize
)
)
}
;
}
if
(
leafName
.
EqualsLiteral
(
PADDING_FILE_NAME
)
|
|
leafName
.
EqualsLiteral
(
PADDING_TMP_FILE_NAME
)
)
{
break
;
}
NS_WARNING
(
"
Unknown
Cache
file
found
!
"
)
;
break
;
case
nsIFileKind
:
:
DoesNotExist
:
break
;
}
return
UsageInfo
{
}
;
}
)
)
;
return
UsageInfo
{
DatabaseUsageType
(
Some
(
paddingSize
)
)
}
+
innerUsageInfo
;
}
nsresult
CacheQuotaClient
:
:
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
UNKNOWN_FILE_WARNING
(
NS_LITERAL_STRING_FROM_CSTRING
(
DOMCACHE_DIRECTORY_NAME
)
)
;
return
NS_OK
;
}
Result
<
UsageInfo
nsresult
>
CacheQuotaClient
:
:
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
const
AtomicBool
&
aCanceled
)
{
AssertIsOnIOThread
(
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_ASSERT
(
quotaManager
)
;
return
quotaManager
-
>
GetUsageForClient
(
PERSISTENCE_TYPE_DEFAULT
aOriginMetadata
Client
:
:
DOMCACHE
)
;
}
void
CacheQuotaClient
:
:
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
{
}
void
CacheQuotaClient
:
:
ReleaseIOThreadObjects
(
)
{
}
void
CacheQuotaClient
:
:
AbortOperationsForLocks
(
const
DirectoryLockIdTable
&
aDirectoryLockIds
)
{
AssertIsOnBackgroundThread
(
)
;
Manager
:
:
Abort
(
aDirectoryLockIds
)
;
}
void
CacheQuotaClient
:
:
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
{
}
void
CacheQuotaClient
:
:
AbortAllOperations
(
)
{
AssertIsOnBackgroundThread
(
)
;
Manager
:
:
AbortAll
(
)
;
}
void
CacheQuotaClient
:
:
StartIdleMaintenance
(
)
{
}
void
CacheQuotaClient
:
:
StopIdleMaintenance
(
)
{
}
void
CacheQuotaClient
:
:
InitiateShutdown
(
)
{
AssertIsOnBackgroundThread
(
)
;
Manager
:
:
InitiateShutdown
(
)
;
}
bool
CacheQuotaClient
:
:
IsShutdownCompleted
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
Manager
:
:
IsShutdownAllComplete
(
)
;
}
void
CacheQuotaClient
:
:
ForceKillActors
(
)
{
}
nsCString
CacheQuotaClient
:
:
GetShutdownStatus
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
Manager
:
:
GetShutdownStatus
(
)
;
}
void
CacheQuotaClient
:
:
FinalizeShutdown
(
)
{
}
nsresult
CacheQuotaClient
:
:
UpgradeStorageFrom2_0To2_1
(
nsIFile
*
aDirectory
)
{
AssertIsOnIOThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aDirectory
)
;
CACHE_TRY
(
DirectoryPaddingInit
(
*
aDirectory
)
)
;
return
NS_OK
;
}
nsresult
CacheQuotaClient
:
:
RestorePaddingFileInternal
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aConn
)
;
CACHE_TRY_INSPECT
(
const
int64_t
&
dummyPaddingSize
DirectoryPaddingRestore
(
*
aBaseDir
*
aConn
true
)
)
;
Unused
<
<
dummyPaddingSize
;
return
NS_OK
;
}
nsresult
CacheQuotaClient
:
:
WipePaddingFileInternal
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MOZ_ASSERT
(
DirectoryPaddingFileExists
(
*
aBaseDir
DirPaddingFile
:
:
FILE
)
)
;
CACHE_TRY_INSPECT
(
const
int64_t
&
paddingSize
(
[
&
aBaseDir
]
(
)
-
>
Result
<
int64_t
nsresult
>
{
const
bool
temporaryPaddingFileExist
=
DirectoryPaddingFileExists
(
*
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
;
Maybe
<
int64_t
>
directoryPaddingGetResult
;
if
(
!
temporaryPaddingFileExist
)
{
CACHE_TRY_UNWRAP
(
directoryPaddingGetResult
(
[
&
aBaseDir
]
(
)
-
>
Result
<
Maybe
<
int64_t
>
nsresult
>
{
CACHE_TRY_RETURN
(
DirectoryPaddingGet
(
*
aBaseDir
)
.
map
(
Some
<
int64_t
>
)
Maybe
<
int64_t
>
{
}
)
;
}
(
)
)
)
;
}
if
(
temporaryPaddingFileExist
|
|
!
directoryPaddingGetResult
)
{
NS_WARNING
(
"
Cannnot
read
padding
size
from
file
!
"
)
;
return
0
;
}
return
*
directoryPaddingGetResult
;
}
(
)
)
)
;
if
(
paddingSize
>
0
)
{
DecreaseUsageForQuotaInfo
(
aQuotaInfo
paddingSize
)
;
}
CACHE_TRY
(
DirectoryPaddingDeleteFile
(
*
aBaseDir
DirPaddingFile
:
:
FILE
)
)
;
CACHE_TRY
(
DirectoryPaddingDeleteFile
(
*
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
)
;
CACHE_TRY
(
DirectoryPaddingInit
(
*
aBaseDir
)
)
;
return
NS_OK
;
}
CacheQuotaClient
:
:
~
CacheQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sInstance
=
=
this
)
;
sInstance
=
nullptr
;
}
CacheQuotaClient
*
CacheQuotaClient
:
:
sInstance
=
nullptr
;
already_AddRefed
<
quota
:
:
Client
>
CreateQuotaClient
(
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
CacheQuotaClient
>
ref
=
new
CacheQuotaClient
(
)
;
return
ref
.
forget
(
)
;
}
nsresult
RestorePaddingFile
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aConn
)
;
RefPtr
<
CacheQuotaClient
>
cacheQuotaClient
=
CacheQuotaClient
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cacheQuotaClient
)
;
CACHE_TRY
(
cacheQuotaClient
-
>
RestorePaddingFileInternal
(
aBaseDir
aConn
)
)
;
return
NS_OK
;
}
nsresult
WipePaddingFile
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBaseDir
)
;
RefPtr
<
CacheQuotaClient
>
cacheQuotaClient
=
CacheQuotaClient
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cacheQuotaClient
)
;
CACHE_TRY
(
cacheQuotaClient
-
>
WipePaddingFileInternal
(
aQuotaInfo
aBaseDir
)
)
;
return
NS_OK
;
}
}
