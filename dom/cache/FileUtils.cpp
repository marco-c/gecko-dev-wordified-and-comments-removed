#
include
"
FileUtilsImpl
.
h
"
#
include
"
DBSchema
.
h
"
#
include
"
mozilla
/
dom
/
InternalResponse
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
FileStreams
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaObject
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
SnappyCompressOutputStream
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIObjectInputStream
.
h
"
#
include
"
nsIObjectOutputStream
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
dom
:
:
cache
{
using
mozilla
:
:
dom
:
:
quota
:
:
Client
;
using
mozilla
:
:
dom
:
:
quota
:
:
CloneFileAndAppend
;
using
mozilla
:
:
dom
:
:
quota
:
:
FileInputStream
;
using
mozilla
:
:
dom
:
:
quota
:
:
FileOutputStream
;
using
mozilla
:
:
dom
:
:
quota
:
:
GetDirEntryKind
;
using
mozilla
:
:
dom
:
:
quota
:
:
nsIFileKind
;
using
mozilla
:
:
dom
:
:
quota
:
:
PERSISTENCE_TYPE_DEFAULT
;
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaManager
;
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaObject
;
namespace
{
const
int64_t
kRoundUpNumber
=
20480
;
enum
BodyFileType
{
BODY_FILE_FINAL
BODY_FILE_TMP
}
;
Result
<
NotNull
<
nsCOMPtr
<
nsIFile
>
>
nsresult
>
BodyIdToFile
(
nsIFile
&
aBaseDir
const
nsID
&
aId
BodyFileType
aType
)
;
int64_t
RoundUp
(
int64_t
aX
int64_t
aY
)
;
int64_t
BodyGeneratePadding
(
int64_t
aBodyFileSize
uint32_t
aPaddingInfo
)
;
nsresult
LockedDirectoryPaddingWrite
(
nsIFile
&
aBaseDir
DirPaddingFile
aPaddingFileType
int64_t
aPaddingSize
)
;
const
auto
kMorgueDirectory
=
u
"
morgue
"
_ns
;
template
<
typename
SuccessType
=
Ok
>
Result
<
SuccessType
nsresult
>
MapNotFoundToDefault
(
const
nsresult
aRv
)
{
return
(
aRv
=
=
NS_ERROR_FILE_NOT_FOUND
|
|
aRv
=
=
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
)
?
Result
<
SuccessType
nsresult
>
{
std
:
:
in_place
}
:
Err
(
aRv
)
;
}
Result
<
Ok
nsresult
>
MapAlreadyExistsToDefault
(
const
nsresult
aRv
)
{
return
(
aRv
=
=
NS_ERROR_FILE_ALREADY_EXISTS
)
?
Result
<
Ok
nsresult
>
{
std
:
:
in_place
}
:
Err
(
aRv
)
;
}
Result
<
NotNull
<
nsCOMPtr
<
nsIFile
>
>
nsresult
>
BodyGetCacheDir
(
nsIFile
&
aBaseDir
const
nsID
&
aId
)
{
CACHE_TRY_UNWRAP
(
auto
cacheDir
CloneFileAndAppend
(
aBaseDir
kMorgueDirectory
)
)
;
CACHE_TRY
(
cacheDir
-
>
Append
(
IntToString
(
aId
.
m3
[
7
]
)
)
)
;
CACHE_TRY
(
ToResult
(
cacheDir
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
)
.
orElse
(
ErrToDefaultOkOrErr
<
NS_ERROR_FILE_ALREADY_EXISTS
Ok
>
)
)
;
return
WrapNotNullUnchecked
(
std
:
:
move
(
cacheDir
)
)
;
}
}
nsresult
BodyCreateDir
(
nsIFile
&
aBaseDir
)
{
CACHE_TRY_INSPECT
(
const
auto
&
bodyDir
CloneFileAndAppend
(
aBaseDir
kMorgueDirectory
)
)
;
CACHE_TRY
(
ToResult
(
bodyDir
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
0755
)
)
.
orElse
(
ErrToDefaultOkOrErr
<
NS_ERROR_FILE_ALREADY_EXISTS
Ok
>
)
)
;
return
NS_OK
;
}
nsresult
BodyDeleteDir
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aBaseDir
)
{
CACHE_TRY_INSPECT
(
const
auto
&
bodyDir
CloneFileAndAppend
(
aBaseDir
kMorgueDirectory
)
)
;
CACHE_TRY
(
RemoveNsIFileRecursively
(
aQuotaInfo
*
bodyDir
)
)
;
return
NS_OK
;
}
Result
<
std
:
:
pair
<
nsID
nsCOMPtr
<
nsISupports
>
>
nsresult
>
BodyStartWriteStream
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aBaseDir
nsIInputStream
&
aSource
void
*
aClosure
nsAsyncCopyCallbackFun
aCallback
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aClosure
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aCallback
)
;
CACHE_TRY_INSPECT
(
const
auto
&
idGen
ToResultGet
<
nsCOMPtr
<
nsIUUIDGenerator
>
>
(
MOZ_SELECT_OVERLOAD
(
do_GetService
)
"
mozilla
.
org
/
uuid
-
generator
;
1
"
)
)
;
nsID
id
;
CACHE_TRY
(
idGen
-
>
GenerateUUIDInPlace
(
&
id
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
finalFile
BodyIdToFile
(
aBaseDir
id
BODY_FILE_FINAL
)
)
;
{
CACHE_TRY_INSPECT
(
const
bool
&
exists
MOZ_TO_RESULT_INVOKE
(
*
finalFile
Exists
)
)
;
CACHE_TRY
(
OkIf
(
!
exists
)
Err
(
NS_ERROR_FILE_ALREADY_EXISTS
)
)
;
}
CACHE_TRY_INSPECT
(
const
auto
&
tmpFile
BodyIdToFile
(
aBaseDir
id
BODY_FILE_TMP
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
fileStream
CreateFileOutputStream
(
PERSISTENCE_TYPE_DEFAULT
aQuotaInfo
Client
:
:
DOMCACHE
tmpFile
.
get
(
)
)
)
;
const
auto
compressed
=
MakeRefPtr
<
SnappyCompressOutputStream
>
(
fileStream
.
get
(
)
)
;
const
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
;
nsCOMPtr
<
nsISupports
>
copyContext
;
CACHE_TRY
(
NS_AsyncCopy
(
&
aSource
compressed
target
NS_ASYNCCOPY_VIA_WRITESEGMENTS
compressed
-
>
BlockSize
(
)
aCallback
aClosure
true
true
getter_AddRefs
(
copyContext
)
)
)
;
return
std
:
:
make_pair
(
id
std
:
:
move
(
copyContext
)
)
;
}
void
BodyCancelWrite
(
nsISupports
&
aCopyContext
)
{
CACHE_TRY
(
NS_CancelAsyncCopy
(
&
aCopyContext
NS_ERROR_ABORT
)
QM_VOID
)
;
}
nsresult
BodyFinalizeWrite
(
nsIFile
&
aBaseDir
const
nsID
&
aId
)
{
CACHE_TRY_INSPECT
(
const
auto
&
tmpFile
BodyIdToFile
(
aBaseDir
aId
BODY_FILE_TMP
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
finalFile
BodyIdToFile
(
aBaseDir
aId
BODY_FILE_FINAL
)
)
;
nsAutoString
finalFileName
;
CACHE_TRY
(
finalFile
-
>
GetLeafName
(
finalFileName
)
)
;
CACHE_TRY
(
tmpFile
-
>
RenameTo
(
nullptr
finalFileName
)
)
;
return
NS_OK
;
}
Result
<
NotNull
<
nsCOMPtr
<
nsIInputStream
>
>
nsresult
>
BodyOpen
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aBaseDir
const
nsID
&
aId
)
{
CACHE_TRY_INSPECT
(
const
auto
&
finalFile
BodyIdToFile
(
aBaseDir
aId
BODY_FILE_FINAL
)
)
;
CACHE_TRY_RETURN
(
CreateFileInputStream
(
PERSISTENCE_TYPE_DEFAULT
aQuotaInfo
Client
:
:
DOMCACHE
finalFile
.
get
(
)
)
.
map
(
[
]
(
NotNull
<
RefPtr
<
FileInputStream
>
>
&
&
stream
)
{
return
WrapNotNullUnchecked
(
nsCOMPtr
<
nsIInputStream
>
{
stream
.
get
(
)
}
)
;
}
)
)
;
}
nsresult
BodyMaybeUpdatePaddingSize
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aBaseDir
const
nsID
&
aId
const
uint32_t
aPaddingInfo
int64_t
*
aPaddingSizeInOut
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aPaddingSizeInOut
)
;
CACHE_TRY_INSPECT
(
const
auto
&
bodyFile
BodyIdToFile
(
aBaseDir
aId
BODY_FILE_TMP
)
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
quotaManager
)
;
int64_t
fileSize
=
0
;
RefPtr
<
QuotaObject
>
quotaObject
=
quotaManager
-
>
GetQuotaObject
(
PERSISTENCE_TYPE_DEFAULT
aQuotaInfo
Client
:
:
DOMCACHE
bodyFile
.
get
(
)
-
1
&
fileSize
)
;
MOZ_DIAGNOSTIC_ASSERT
(
quotaObject
)
;
MOZ_DIAGNOSTIC_ASSERT
(
fileSize
>
=
0
)
;
if
(
!
quotaObject
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
*
aPaddingSizeInOut
=
=
InternalResponse
:
:
UNKNOWN_PADDING_SIZE
)
{
*
aPaddingSizeInOut
=
BodyGeneratePadding
(
fileSize
aPaddingInfo
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
*
aPaddingSizeInOut
>
=
0
)
;
if
(
!
quotaObject
-
>
IncreaseSize
(
*
aPaddingSizeInOut
)
)
{
return
NS_ERROR_FILE_NO_DEVICE_SPACE
;
}
return
NS_OK
;
}
nsresult
BodyDeleteFiles
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aBaseDir
const
nsTArray
<
nsID
>
&
aIdList
)
{
for
(
const
auto
id
:
aIdList
)
{
CACHE_TRY_INSPECT
(
const
auto
&
bodyDir
BodyGetCacheDir
(
aBaseDir
id
)
)
;
const
auto
removeFileForId
=
[
&
aQuotaInfo
&
id
]
(
nsIFile
&
bodyFile
const
nsACString
&
leafName
)
-
>
Result
<
bool
nsresult
>
{
nsID
fileId
;
CACHE_TRY
(
OkIf
(
fileId
.
Parse
(
leafName
.
BeginReading
(
)
)
)
true
(
[
&
aQuotaInfo
&
bodyFile
]
(
const
auto
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aQuotaInfo
bodyFile
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
}
)
)
;
if
(
id
.
Equals
(
fileId
)
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aQuotaInfo
bodyFile
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
return
true
;
}
return
false
;
}
;
CACHE_TRY
(
BodyTraverseFiles
(
aQuotaInfo
*
bodyDir
removeFileForId
false
true
)
)
;
}
return
NS_OK
;
}
namespace
{
Result
<
NotNull
<
nsCOMPtr
<
nsIFile
>
>
nsresult
>
BodyIdToFile
(
nsIFile
&
aBaseDir
const
nsID
&
aId
const
BodyFileType
aType
)
{
CACHE_TRY_UNWRAP
(
auto
bodyFile
BodyGetCacheDir
(
aBaseDir
aId
)
)
;
char
idString
[
NSID_LENGTH
]
;
aId
.
ToProvidedString
(
idString
)
;
NS_ConvertASCIItoUTF16
fileName
(
idString
)
;
if
(
aType
=
=
BODY_FILE_FINAL
)
{
fileName
.
AppendLiteral
(
"
.
final
"
)
;
}
else
{
fileName
.
AppendLiteral
(
"
.
tmp
"
)
;
}
CACHE_TRY
(
bodyFile
-
>
Append
(
fileName
)
)
;
return
bodyFile
;
}
int64_t
RoundUp
(
const
int64_t
aX
const
int64_t
aY
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aX
>
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aY
>
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
INT64_MAX
-
(
(
aX
-
1
)
/
aY
)
*
aY
>
=
aY
)
;
return
aY
+
(
(
aX
-
1
)
/
aY
)
*
aY
;
}
int64_t
BodyGeneratePadding
(
const
int64_t
aBodyFileSize
const
uint32_t
aPaddingInfo
)
{
int64_t
randomSize
=
static_cast
<
int64_t
>
(
aPaddingInfo
)
;
MOZ_DIAGNOSTIC_ASSERT
(
INT64_MAX
-
aBodyFileSize
>
=
randomSize
)
;
randomSize
+
=
aBodyFileSize
;
return
RoundUp
(
randomSize
kRoundUpNumber
)
-
aBodyFileSize
;
}
nsresult
LockedDirectoryPaddingWrite
(
nsIFile
&
aBaseDir
DirPaddingFile
aPaddingFileType
int64_t
aPaddingSize
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aPaddingSize
>
=
0
)
;
CACHE_TRY_INSPECT
(
const
auto
&
file
CloneFileAndAppend
(
aBaseDir
aPaddingFileType
=
=
DirPaddingFile
:
:
TMP_FILE
?
nsLiteralString
(
PADDING_TMP_FILE_NAME
)
:
nsLiteralString
(
PADDING_FILE_NAME
)
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
outputStream
NS_NewLocalFileOutputStream
(
file
)
)
;
nsCOMPtr
<
nsIObjectOutputStream
>
objectStream
=
NS_NewObjectOutputStream
(
outputStream
)
;
CACHE_TRY
(
objectStream
-
>
Write64
(
aPaddingSize
)
)
;
return
NS_OK
;
}
}
nsresult
BodyDeleteOrphanedFiles
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aBaseDir
const
nsTArray
<
nsID
>
&
aKnownBodyIdList
)
{
CACHE_TRY_INSPECT
(
const
auto
&
dir
CloneFileAndAppend
(
aBaseDir
kMorgueDirectory
)
)
;
CACHE_TRY
(
quota
:
:
CollectEachFile
(
*
dir
[
&
aQuotaInfo
&
aKnownBodyIdList
]
(
const
nsCOMPtr
<
nsIFile
>
&
subdir
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
dirEntryKind
GetDirEntryKind
(
*
subdir
)
)
;
switch
(
dirEntryKind
)
{
case
nsIFileKind
:
:
ExistsAsDirectory
:
{
const
auto
removeOrphanedFiles
=
[
&
aQuotaInfo
&
aKnownBodyIdList
]
(
nsIFile
&
bodyFile
const
nsACString
&
leafName
)
-
>
Result
<
bool
nsresult
>
{
auto
cleanup
=
MakeScopeExit
(
[
&
aQuotaInfo
&
bodyFile
]
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aQuotaInfo
bodyFile
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
}
)
;
nsID
id
;
CACHE_TRY
(
OkIf
(
id
.
Parse
(
leafName
.
BeginReading
(
)
)
)
true
)
;
if
(
!
aKnownBodyIdList
.
Contains
(
id
)
)
{
return
true
;
}
cleanup
.
release
(
)
;
return
false
;
}
;
CACHE_TRY
(
ToResult
(
BodyTraverseFiles
(
aQuotaInfo
*
subdir
removeOrphanedFiles
true
true
)
)
#
ifdef
WIN32
.
orElse
(
[
]
(
const
nsresult
rv
)
-
>
Result
<
Ok
nsresult
>
{
if
(
NS_ERROR_GET_MODULE
(
rv
)
=
=
NS_ERROR_MODULE_WIN32
&
&
NS_ERROR_GET_CODE
(
rv
)
=
=
ERROR_FILE_CORRUPT
)
{
return
Ok
{
}
;
}
return
Err
(
rv
)
;
}
)
#
endif
)
;
break
;
}
case
nsIFileKind
:
:
ExistsAsFile
:
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aQuotaInfo
*
subdir
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
break
;
}
case
nsIFileKind
:
:
DoesNotExist
:
break
;
}
return
Ok
{
}
;
}
)
)
;
return
NS_OK
;
}
namespace
{
Result
<
nsCOMPtr
<
nsIFile
>
nsresult
>
GetMarkerFileHandle
(
const
QuotaInfo
&
aQuotaInfo
)
{
CACHE_TRY_UNWRAP
(
auto
marker
CloneFileAndAppend
(
*
aQuotaInfo
.
mDir
u
"
cache
"
_ns
)
)
;
CACHE_TRY
(
marker
-
>
Append
(
u
"
context_open
.
marker
"
_ns
)
)
;
return
marker
;
}
}
nsresult
CreateMarkerFile
(
const
QuotaInfo
&
aQuotaInfo
)
{
CACHE_TRY_INSPECT
(
const
auto
&
marker
GetMarkerFileHandle
(
aQuotaInfo
)
)
;
CACHE_TRY
(
ToResult
(
marker
-
>
Create
(
nsIFile
:
:
NORMAL_FILE_TYPE
0644
)
)
.
orElse
(
MapAlreadyExistsToDefault
)
)
;
return
NS_OK
;
}
nsresult
DeleteMarkerFile
(
const
QuotaInfo
&
aQuotaInfo
)
{
CACHE_TRY_INSPECT
(
const
auto
&
marker
GetMarkerFileHandle
(
aQuotaInfo
)
)
;
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aQuotaInfo
*
marker
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
return
NS_OK
;
}
bool
MarkerFileExists
(
const
QuotaInfo
&
aQuotaInfo
)
{
CACHE_TRY_INSPECT
(
const
auto
&
marker
GetMarkerFileHandle
(
aQuotaInfo
)
false
)
;
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
marker
Exists
)
false
)
;
}
nsresult
RemoveNsIFileRecursively
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aFile
const
bool
aTrackQuota
)
{
CACHE_TRY_INSPECT
(
const
auto
&
dirEntryKind
GetDirEntryKind
(
aFile
)
)
;
switch
(
dirEntryKind
)
{
case
nsIFileKind
:
:
ExistsAsDirectory
:
CACHE_TRY
(
quota
:
:
CollectEachFile
(
aFile
[
&
aQuotaInfo
&
aTrackQuota
]
(
const
nsCOMPtr
<
nsIFile
>
&
file
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY
(
RemoveNsIFileRecursively
(
aQuotaInfo
*
file
aTrackQuota
)
)
;
return
Ok
{
}
;
}
)
)
;
CACHE_TRY
(
aFile
.
Remove
(
false
)
)
;
break
;
case
nsIFileKind
:
:
ExistsAsFile
:
return
RemoveNsIFile
(
aQuotaInfo
aFile
aTrackQuota
)
;
case
nsIFileKind
:
:
DoesNotExist
:
break
;
}
return
NS_OK
;
}
nsresult
RemoveNsIFile
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
&
aFile
const
bool
aTrackQuota
)
{
int64_t
fileSize
=
0
;
if
(
aTrackQuota
)
{
CACHE_TRY_INSPECT
(
const
auto
&
maybeFileSize
MOZ_TO_RESULT_INVOKE
(
aFile
GetFileSize
)
.
map
(
Some
<
int64_t
>
)
.
orElse
(
MapNotFoundToDefault
<
Maybe
<
int64_t
>
>
)
)
;
if
(
!
maybeFileSize
)
{
return
NS_OK
;
}
fileSize
=
*
maybeFileSize
;
}
CACHE_TRY
(
ToResult
(
aFile
.
Remove
(
false
)
)
.
orElse
(
MapNotFoundToDefault
<
>
)
)
;
if
(
fileSize
>
0
)
{
MOZ_ASSERT
(
aTrackQuota
)
;
DecreaseUsageForQuotaInfo
(
aQuotaInfo
fileSize
)
;
}
return
NS_OK
;
}
void
DecreaseUsageForQuotaInfo
(
const
QuotaInfo
&
aQuotaInfo
const
int64_t
aUpdatingSize
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aUpdatingSize
>
0
)
;
QuotaManager
*
quotaManager
=
QuotaManager
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
quotaManager
)
;
quotaManager
-
>
DecreaseUsageForClient
(
quota
:
:
ClientMetadata
{
aQuotaInfo
Client
:
:
DOMCACHE
}
aUpdatingSize
)
;
}
bool
DirectoryPaddingFileExists
(
nsIFile
&
aBaseDir
DirPaddingFile
aPaddingFileType
)
{
CACHE_TRY_INSPECT
(
const
auto
&
file
CloneFileAndAppend
(
aBaseDir
aPaddingFileType
=
=
DirPaddingFile
:
:
TMP_FILE
?
nsLiteralString
(
PADDING_TMP_FILE_NAME
)
:
nsLiteralString
(
PADDING_FILE_NAME
)
)
false
)
;
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
file
Exists
)
false
)
;
}
Result
<
int64_t
nsresult
>
LockedDirectoryPaddingGet
(
nsIFile
&
aBaseDir
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
file
CloneFileAndAppend
(
aBaseDir
nsLiteralString
(
PADDING_FILE_NAME
)
)
)
;
CACHE_TRY_UNWRAP
(
auto
stream
NS_NewLocalFileInputStream
(
file
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
bufferedStream
NS_NewBufferedInputStream
(
stream
.
forget
(
)
512
)
)
;
const
nsCOMPtr
<
nsIObjectInputStream
>
objectStream
=
NS_NewObjectInputStream
(
bufferedStream
)
;
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
objectStream
Read64
)
.
map
(
[
]
(
const
uint64_t
val
)
{
return
int64_t
(
val
)
;
}
)
)
;
}
nsresult
LockedDirectoryPaddingInit
(
nsIFile
&
aBaseDir
)
{
CACHE_TRY
(
LockedDirectoryPaddingWrite
(
aBaseDir
DirPaddingFile
:
:
FILE
0
)
)
;
return
NS_OK
;
}
nsresult
LockedUpdateDirectoryPaddingFile
(
nsIFile
&
aBaseDir
mozIStorageConnection
&
aConn
const
int64_t
aIncreaseSize
const
int64_t
aDecreaseSize
const
bool
aTemporaryFileExist
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aIncreaseSize
>
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aDecreaseSize
>
=
0
)
;
const
auto
directoryPaddingGetResult
=
aTemporaryFileExist
?
Maybe
<
int64_t
>
{
}
:
[
&
aBaseDir
]
{
CACHE_TRY_RETURN
(
LockedDirectoryPaddingGet
(
aBaseDir
)
.
map
(
Some
<
int64_t
>
)
.
orElse
(
MapNotFoundToDefault
<
Maybe
<
int64_t
>
>
)
Maybe
<
int64_t
>
{
}
)
;
}
(
)
;
CACHE_TRY_INSPECT
(
const
int64_t
&
currentPaddingSize
(
[
directoryPaddingGetResult
&
aBaseDir
&
aConn
aIncreaseSize
aDecreaseSize
]
(
)
-
>
Result
<
int64_t
nsresult
>
{
if
(
!
directoryPaddingGetResult
)
{
CACHE_TRY
(
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
FILE
)
)
;
CACHE_TRY_RETURN
(
db
:
:
FindOverallPaddingSize
(
aConn
)
)
;
}
int64_t
currentPaddingSize
=
directoryPaddingGetResult
.
value
(
)
;
bool
shouldRevise
=
false
;
if
(
aIncreaseSize
>
0
)
{
if
(
INT64_MAX
-
currentPaddingSize
<
aDecreaseSize
)
{
shouldRevise
=
true
;
}
else
{
currentPaddingSize
+
=
aIncreaseSize
;
}
}
if
(
aDecreaseSize
>
0
)
{
if
(
currentPaddingSize
<
aDecreaseSize
)
{
shouldRevise
=
true
;
}
else
if
(
!
shouldRevise
)
{
currentPaddingSize
-
=
aDecreaseSize
;
}
}
if
(
shouldRevise
)
{
CACHE_TRY
(
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
FILE
)
)
;
CACHE_TRY_UNWRAP
(
currentPaddingSize
db
:
:
FindOverallPaddingSize
(
aConn
)
)
;
MOZ_ASSERT
(
false
"
The
padding
size
is
unsync
with
QM
"
)
;
}
#
ifdef
DEBUG
const
int64_t
lastPaddingSize
=
currentPaddingSize
;
CACHE_TRY_UNWRAP
(
currentPaddingSize
db
:
:
FindOverallPaddingSize
(
aConn
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
currentPaddingSize
=
=
lastPaddingSize
)
;
#
endif
return
currentPaddingSize
;
}
(
)
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
currentPaddingSize
>
=
0
)
;
CACHE_TRY
(
LockedDirectoryPaddingWrite
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
currentPaddingSize
)
)
;
return
NS_OK
;
}
nsresult
LockedDirectoryPaddingFinalizeWrite
(
nsIFile
&
aBaseDir
)
{
MOZ_DIAGNOSTIC_ASSERT
(
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
file
CloneFileAndAppend
(
aBaseDir
nsLiteralString
(
PADDING_TMP_FILE_NAME
)
)
)
;
CACHE_TRY
(
file
-
>
RenameTo
(
nullptr
nsLiteralString
(
PADDING_FILE_NAME
)
)
)
;
return
NS_OK
;
}
Result
<
int64_t
nsresult
>
LockedDirectoryPaddingRestore
(
nsIFile
&
aBaseDir
mozIStorageConnection
&
aConn
const
bool
aMustRestore
)
{
CACHE_TRY
(
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
FILE
)
)
;
CACHE_TRY_INSPECT
(
const
int64_t
&
paddingSize
db
:
:
FindOverallPaddingSize
(
aConn
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
paddingSize
>
=
0
)
;
CACHE_TRY
(
LockedDirectoryPaddingWrite
(
aBaseDir
DirPaddingFile
:
:
FILE
paddingSize
)
(
aMustRestore
?
Err
(
tryTempError
)
:
Result
<
int64_t
nsresult
>
{
paddingSize
}
)
)
;
CACHE_TRY
(
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
)
;
return
paddingSize
;
}
nsresult
LockedDirectoryPaddingDeleteFile
(
nsIFile
&
aBaseDir
DirPaddingFile
aPaddingFileType
)
{
CACHE_TRY_INSPECT
(
const
auto
&
file
CloneFileAndAppend
(
aBaseDir
aPaddingFileType
=
=
DirPaddingFile
:
:
TMP_FILE
?
nsLiteralString
(
PADDING_TMP_FILE_NAME
)
:
nsLiteralString
(
PADDING_FILE_NAME
)
)
)
;
CACHE_TRY
(
ToResult
(
file
-
>
Remove
(
false
)
)
.
orElse
(
MapNotFoundToDefault
<
>
)
)
;
return
NS_OK
;
}
}
