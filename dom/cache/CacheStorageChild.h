#
ifndef
mozilla_dom_cache_CacheStorageChild_h
#
define
mozilla_dom_cache_CacheStorageChild_h
#
include
"
mozilla
/
dom
/
cache
/
ActorChild
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Types
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
TypeUtils
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
PCacheStorageChild
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheOpChild
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
:
:
dom
{
class
Promise
;
namespace
cache
{
class
CacheOpArgs
;
class
CacheStorage
;
class
CacheWorkerRef
;
class
PCacheChild
;
class
CacheStorageChild
final
:
public
PCacheStorageChild
public
CacheActorChild
{
friend
class
PCacheStorageChild
;
public
:
CacheStorageChild
(
CacheStorageChildListener
*
aListener
SafeRefPtr
<
CacheWorkerRef
>
aWorkerRef
ActorChild
*
aParentActor
=
nullptr
)
;
void
ClearListener
(
)
;
template
<
typename
PromiseType
>
void
ExecuteOp
(
nsIGlobalObject
*
aGlobal
PromiseType
&
aPromise
nsISupports
*
aParent
const
CacheOpArgs
&
aArgs
)
{
Unused
<
<
SendPCacheOpConstructor
(
new
CacheOpChild
(
GetWorkerRefPtr
(
)
.
clonePtr
(
)
aGlobal
aParent
aPromise
this
)
aArgs
)
;
}
void
StartDestroyFromListener
(
)
;
NS_INLINE_DECL_REFCOUNTING
(
CacheStorageChild
override
)
void
NoteDeletedActor
(
)
override
;
private
:
~
CacheStorageChild
(
)
;
void
DestroyInternal
(
)
;
virtual
void
StartDestroy
(
)
override
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
;
PCacheOpChild
*
AllocPCacheOpChild
(
const
CacheOpArgs
&
aOpArgs
)
;
bool
DeallocPCacheOpChild
(
PCacheOpChild
*
aActor
)
;
inline
uint32_t
NumChildActors
(
)
{
return
ManagedPCacheOpChild
(
)
.
Count
(
)
;
}
ActorChild
*
mParentActor
;
CacheStorageChildListener
*
MOZ_NON_OWNING_REF
mListener
;
bool
mDelayedDestroy
;
}
;
}
}
#
endif
