#
include
"
mozilla
/
dom
/
cache
/
ReadStream
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheStreamControlChild
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheStreamControlParent
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheTypes
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
SnappyUncompressInputStream
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
using
mozilla
:
:
Unused
;
using
mozilla
:
:
ipc
:
:
AutoIPCStream
;
using
mozilla
:
:
ipc
:
:
IPCStream
;
class
ReadStream
:
:
Inner
final
:
public
ReadStream
:
:
Controllable
{
public
:
Inner
(
StreamControl
*
aControl
const
nsID
&
aId
nsIInputStream
*
aStream
)
;
void
Serialize
(
CacheReadStreamOrVoid
*
aReadStreamOut
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
ErrorResult
&
aRv
)
;
void
Serialize
(
CacheReadStream
*
aReadStreamOut
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
ErrorResult
&
aRv
)
;
virtual
void
CloseStream
(
)
override
;
virtual
void
CloseStreamWithoutReporting
(
)
override
;
virtual
bool
MatchId
(
const
nsID
&
aId
)
const
override
;
virtual
bool
HasEverBeenRead
(
)
const
override
;
nsresult
Close
(
)
;
nsresult
Available
(
uint64_t
*
aNumAvailableOut
)
;
nsresult
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
aNumReadOut
)
;
nsresult
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
aNumReadOut
)
;
nsresult
IsNonBlocking
(
bool
*
aNonBlockingOut
)
;
private
:
class
NoteClosedRunnable
;
class
ForgetRunnable
;
~
Inner
(
)
;
void
NoteClosed
(
)
;
void
Forget
(
)
;
void
NoteClosedOnOwningThread
(
)
;
void
ForgetOnOwningThread
(
)
;
StreamControl
*
mControl
;
const
nsID
mId
;
nsCOMPtr
<
nsIInputStream
>
mStream
;
nsCOMPtr
<
nsIInputStream
>
mSnappyStream
;
nsCOMPtr
<
nsIThread
>
mOwningThread
;
enum
State
{
Open
Closed
NumStates
}
;
Atomic
<
State
>
mState
;
Atomic
<
bool
>
mHasEverBeenRead
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
cache
:
:
ReadStream
:
:
Inner
override
)
}
;
class
ReadStream
:
:
Inner
:
:
NoteClosedRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
NoteClosedRunnable
(
ReadStream
:
:
Inner
*
aStream
)
:
mStream
(
aStream
)
{
}
NS_IMETHOD
Run
(
)
override
{
mStream
-
>
NoteClosedOnOwningThread
(
)
;
mStream
=
nullptr
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
Run
(
)
;
return
NS_OK
;
}
private
:
~
NoteClosedRunnable
(
)
{
}
RefPtr
<
ReadStream
:
:
Inner
>
mStream
;
}
;
class
ReadStream
:
:
Inner
:
:
ForgetRunnable
final
:
public
CancelableRunnable
{
public
:
explicit
ForgetRunnable
(
ReadStream
:
:
Inner
*
aStream
)
:
mStream
(
aStream
)
{
}
NS_IMETHOD
Run
(
)
override
{
mStream
-
>
ForgetOnOwningThread
(
)
;
mStream
=
nullptr
;
return
NS_OK
;
}
nsresult
Cancel
(
)
override
{
Run
(
)
;
return
NS_OK
;
}
private
:
~
ForgetRunnable
(
)
{
}
RefPtr
<
ReadStream
:
:
Inner
>
mStream
;
}
;
ReadStream
:
:
Inner
:
:
Inner
(
StreamControl
*
aControl
const
nsID
&
aId
nsIInputStream
*
aStream
)
:
mControl
(
aControl
)
mId
(
aId
)
mStream
(
aStream
)
mSnappyStream
(
new
SnappyUncompressInputStream
(
aStream
)
)
mOwningThread
(
NS_GetCurrentThread
(
)
)
mState
(
Open
)
{
MOZ_ASSERT
(
mStream
)
;
MOZ_ASSERT
(
mControl
)
;
mControl
-
>
AddReadStream
(
this
)
;
}
void
ReadStream
:
:
Inner
:
:
Serialize
(
CacheReadStreamOrVoid
*
aReadStreamOut
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
MOZ_ASSERT
(
aReadStreamOut
)
;
*
aReadStreamOut
=
CacheReadStream
(
)
;
Serialize
(
&
aReadStreamOut
-
>
get_CacheReadStream
(
)
aStreamCleanupList
aRv
)
;
}
void
ReadStream
:
:
Inner
:
:
Serialize
(
CacheReadStream
*
aReadStreamOut
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
MOZ_ASSERT
(
aReadStreamOut
)
;
if
(
mState
!
=
Open
)
{
aRv
.
ThrowTypeError
<
MSG_CACHE_STREAM_CLOSED
>
(
)
;
return
;
}
MOZ_ASSERT
(
mControl
)
;
aReadStreamOut
-
>
id
(
)
=
mId
;
mControl
-
>
SerializeControl
(
aReadStreamOut
)
;
mControl
-
>
SerializeStream
(
aReadStreamOut
mStream
aStreamCleanupList
)
;
MOZ_ASSERT
(
aReadStreamOut
-
>
stream
(
)
.
type
(
)
=
=
IPCStream
:
:
TInputStreamParamsWithFds
)
;
Forget
(
)
;
}
void
ReadStream
:
:
Inner
:
:
CloseStream
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
Close
(
)
;
}
void
ReadStream
:
:
Inner
:
:
CloseStreamWithoutReporting
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
Forget
(
)
;
}
bool
ReadStream
:
:
Inner
:
:
MatchId
(
const
nsID
&
aId
)
const
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
return
mId
.
Equals
(
aId
)
;
}
bool
ReadStream
:
:
Inner
:
:
HasEverBeenRead
(
)
const
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
return
mHasEverBeenRead
;
}
nsresult
ReadStream
:
:
Inner
:
:
Close
(
)
{
nsresult
rv
=
mStream
-
>
Close
(
)
;
NoteClosed
(
)
;
return
rv
;
}
nsresult
ReadStream
:
:
Inner
:
:
Available
(
uint64_t
*
aNumAvailableOut
)
{
nsresult
rv
=
mSnappyStream
-
>
Available
(
aNumAvailableOut
)
;
if
(
NS_FAILED
(
rv
)
)
{
Close
(
)
;
}
return
rv
;
}
nsresult
ReadStream
:
:
Inner
:
:
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
aNumReadOut
)
{
MOZ_ASSERT
(
aNumReadOut
)
;
nsresult
rv
=
mSnappyStream
-
>
Read
(
aBuf
aCount
aNumReadOut
)
;
if
(
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
)
|
|
*
aNumReadOut
=
=
0
)
{
Close
(
)
;
}
mHasEverBeenRead
=
true
;
return
rv
;
}
nsresult
ReadStream
:
:
Inner
:
:
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
aNumReadOut
)
{
MOZ_ASSERT
(
aNumReadOut
)
;
if
(
aCount
)
{
mHasEverBeenRead
=
true
;
}
nsresult
rv
=
mSnappyStream
-
>
ReadSegments
(
aWriter
aClosure
aCount
aNumReadOut
)
;
if
(
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_BASE_STREAM_WOULD_BLOCK
&
&
rv
!
=
NS_ERROR_NOT_IMPLEMENTED
)
|
|
*
aNumReadOut
=
=
0
)
{
Close
(
)
;
}
if
(
*
aNumReadOut
)
{
mHasEverBeenRead
=
true
;
}
return
rv
;
}
nsresult
ReadStream
:
:
Inner
:
:
IsNonBlocking
(
bool
*
aNonBlockingOut
)
{
return
mSnappyStream
-
>
IsNonBlocking
(
aNonBlockingOut
)
;
}
ReadStream
:
:
Inner
:
:
~
Inner
(
)
{
MOZ_ASSERT
(
mState
=
=
Closed
)
;
MOZ_ASSERT
(
!
mControl
)
;
}
void
ReadStream
:
:
Inner
:
:
NoteClosed
(
)
{
if
(
mState
=
=
Closed
)
{
return
;
}
if
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
{
NoteClosedOnOwningThread
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
NoteClosedRunnable
(
this
)
;
MOZ_ALWAYS_SUCCEEDS
(
mOwningThread
-
>
Dispatch
(
runnable
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
}
void
ReadStream
:
:
Inner
:
:
Forget
(
)
{
if
(
mState
=
=
Closed
)
{
return
;
}
if
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
{
ForgetOnOwningThread
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ForgetRunnable
(
this
)
;
MOZ_ALWAYS_SUCCEEDS
(
mOwningThread
-
>
Dispatch
(
runnable
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
}
void
ReadStream
:
:
Inner
:
:
NoteClosedOnOwningThread
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
if
(
!
mState
.
compareExchange
(
Open
Closed
)
)
{
return
;
}
MOZ_ASSERT
(
mControl
)
;
mControl
-
>
NoteClosed
(
this
mId
)
;
mControl
=
nullptr
;
}
void
ReadStream
:
:
Inner
:
:
ForgetOnOwningThread
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mOwningThread
)
;
if
(
!
mState
.
compareExchange
(
Open
Closed
)
)
{
return
;
}
MOZ_ASSERT
(
mControl
)
;
mControl
-
>
ForgetReadStream
(
this
)
;
mControl
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
cache
:
:
ReadStream
nsIInputStream
ReadStream
)
;
already_AddRefed
<
ReadStream
>
ReadStream
:
:
Create
(
const
CacheReadStreamOrVoid
&
aReadStreamOrVoid
)
{
if
(
aReadStreamOrVoid
.
type
(
)
=
=
CacheReadStreamOrVoid
:
:
Tvoid_t
)
{
return
nullptr
;
}
return
Create
(
aReadStreamOrVoid
.
get_CacheReadStream
(
)
)
;
}
already_AddRefed
<
ReadStream
>
ReadStream
:
:
Create
(
const
CacheReadStream
&
aReadStream
)
{
if
(
!
aReadStream
.
controlChild
(
)
&
&
!
aReadStream
.
controlParent
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aReadStream
.
stream
(
)
.
type
(
)
=
=
IPCStream
:
:
TInputStreamParamsWithFds
)
;
StreamControl
*
control
;
if
(
aReadStream
.
controlChild
(
)
)
{
auto
actor
=
static_cast
<
CacheStreamControlChild
*
>
(
aReadStream
.
controlChild
(
)
)
;
control
=
actor
;
}
else
{
auto
actor
=
static_cast
<
CacheStreamControlParent
*
>
(
aReadStream
.
controlParent
(
)
)
;
control
=
actor
;
}
MOZ_ASSERT
(
control
)
;
nsCOMPtr
<
nsIInputStream
>
stream
=
DeserializeIPCStream
(
aReadStream
.
stream
(
)
)
;
MOZ_ASSERT
(
stream
)
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIAsyncInputStream
>
asyncStream
=
do_QueryInterface
(
stream
)
;
MOZ_ASSERT
(
!
asyncStream
)
;
#
endif
RefPtr
<
Inner
>
inner
=
new
Inner
(
control
aReadStream
.
id
(
)
stream
)
;
RefPtr
<
ReadStream
>
ref
=
new
ReadStream
(
inner
)
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
ReadStream
>
ReadStream
:
:
Create
(
PCacheStreamControlParent
*
aControl
const
nsID
&
aId
nsIInputStream
*
aStream
)
{
MOZ_ASSERT
(
aControl
)
;
auto
actor
=
static_cast
<
CacheStreamControlParent
*
>
(
aControl
)
;
RefPtr
<
Inner
>
inner
=
new
Inner
(
actor
aId
aStream
)
;
RefPtr
<
ReadStream
>
ref
=
new
ReadStream
(
inner
)
;
return
ref
.
forget
(
)
;
}
void
ReadStream
:
:
Serialize
(
CacheReadStreamOrVoid
*
aReadStreamOut
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
ErrorResult
&
aRv
)
{
mInner
-
>
Serialize
(
aReadStreamOut
aStreamCleanupList
aRv
)
;
}
void
ReadStream
:
:
Serialize
(
CacheReadStream
*
aReadStreamOut
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
ErrorResult
&
aRv
)
{
mInner
-
>
Serialize
(
aReadStreamOut
aStreamCleanupList
aRv
)
;
}
ReadStream
:
:
ReadStream
(
ReadStream
:
:
Inner
*
aInner
)
:
mInner
(
aInner
)
{
MOZ_ASSERT
(
mInner
)
;
}
ReadStream
:
:
~
ReadStream
(
)
{
mInner
-
>
Close
(
)
;
}
NS_IMETHODIMP
ReadStream
:
:
Close
(
)
{
return
mInner
-
>
Close
(
)
;
}
NS_IMETHODIMP
ReadStream
:
:
Available
(
uint64_t
*
aNumAvailableOut
)
{
return
mInner
-
>
Available
(
aNumAvailableOut
)
;
}
NS_IMETHODIMP
ReadStream
:
:
Read
(
char
*
aBuf
uint32_t
aCount
uint32_t
*
aNumReadOut
)
{
return
mInner
-
>
Read
(
aBuf
aCount
aNumReadOut
)
;
}
NS_IMETHODIMP
ReadStream
:
:
ReadSegments
(
nsWriteSegmentFun
aWriter
void
*
aClosure
uint32_t
aCount
uint32_t
*
aNumReadOut
)
{
return
mInner
-
>
ReadSegments
(
aWriter
aClosure
aCount
aNumReadOut
)
;
}
NS_IMETHODIMP
ReadStream
:
:
IsNonBlocking
(
bool
*
aNonBlockingOut
)
{
return
mInner
-
>
IsNonBlocking
(
aNonBlockingOut
)
;
}
}
}
}
