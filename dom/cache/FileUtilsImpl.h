#
ifndef
mozilla_dom_cache_FileUtilsImpl_h
#
define
mozilla_dom_cache_FileUtilsImpl_h
#
include
"
mozilla
/
dom
/
FlippedOnce
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
FileUtils
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
ResultExtensions
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
template
<
typename
Func
>
nsresult
BodyTraverseFiles
(
const
Maybe
<
CacheDirectoryMetadata
>
&
aDirectoryMetadata
nsIFile
&
aBodyDir
const
Func
&
aHandleFileFunc
const
bool
aCanRemoveFiles
const
bool
aTrackQuota
)
{
MOZ_DIAGNOSTIC_ASSERT_IF
(
aTrackQuota
aDirectoryMetadata
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
{
nsCOMPtr
<
nsIFile
>
parentFile
;
nsresult
rv
=
aBodyDir
.
GetParent
(
getter_AddRefs
(
parentFile
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
parentFile
)
;
nsAutoCString
nativeLeafName
;
rv
=
parentFile
-
>
GetNativeLeafName
(
nativeLeafName
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
StringEndsWith
(
nativeLeafName
"
morgue
"
_ns
)
)
;
}
#
endif
FlippedOnce
<
true
>
isEmpty
;
QM_TRY
(
quota
:
:
CollectEachFile
(
aBodyDir
[
&
isEmpty
&
aDirectoryMetadata
aTrackQuota
&
aHandleFileFunc
aCanRemoveFiles
]
(
const
nsCOMPtr
<
nsIFile
>
&
file
)
-
>
Result
<
Ok
nsresult
>
{
QM_TRY_INSPECT
(
const
auto
&
dirEntryKind
quota
:
:
GetDirEntryKind
(
*
file
)
)
;
switch
(
dirEntryKind
)
{
case
quota
:
:
nsIFileKind
:
:
ExistsAsDirectory
:
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFileRecursively
(
aDirectoryMetadata
*
file
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
break
;
}
case
quota
:
:
nsIFileKind
:
:
ExistsAsFile
:
{
nsAutoCString
leafName
;
QM_TRY
(
MOZ_TO_RESULT
(
file
-
>
GetNativeLeafName
(
leafName
)
)
)
;
if
(
StringEndsWith
(
leafName
"
.
tmp
"
_ns
)
)
{
if
(
aCanRemoveFiles
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aDirectoryMetadata
*
file
aTrackQuota
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
return
Ok
{
}
;
}
}
else
{
QM_WARNONLY_TRY_UNWRAP
(
const
auto
maybeEndingOk
OkIf
(
StringEndsWith
(
leafName
"
.
final
"
_ns
)
)
)
;
if
(
!
maybeEndingOk
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aDirectoryMetadata
*
file
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
return
Ok
{
}
;
}
}
QM_TRY_INSPECT
(
const
bool
&
fileDeleted
aHandleFileFunc
(
*
file
leafName
)
)
;
if
(
fileDeleted
)
{
return
Ok
{
}
;
}
isEmpty
.
EnsureFlipped
(
)
;
break
;
}
case
quota
:
:
nsIFileKind
:
:
DoesNotExist
:
break
;
}
return
Ok
{
}
;
}
)
)
;
if
(
isEmpty
&
&
aCanRemoveFiles
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFileRecursively
(
aDirectoryMetadata
aBodyDir
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
}
return
NS_OK
;
}
}
}
}
#
endif
