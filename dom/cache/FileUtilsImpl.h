#
ifndef
mozilla_dom_cache_FileUtilsImpl_h
#
define
mozilla_dom_cache_FileUtilsImpl_h
#
include
"
mozilla
/
dom
/
cache
/
FileUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
template
<
typename
Func
>
nsresult
BodyTraverseFiles
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBodyDir
const
Func
&
aHandleFileFunc
const
bool
aCanRemoveFiles
const
bool
aTrackQuota
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aBodyDir
)
;
nsresult
rv
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsCOMPtr
<
nsIFile
>
parentFile
;
rv
=
aBodyDir
-
>
GetParent
(
getter_AddRefs
(
parentFile
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
parentFile
)
;
nsAutoCString
nativeLeafName
;
rv
=
parentFile
-
>
GetNativeLeafName
(
nativeLeafName
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
StringEndsWith
(
nativeLeafName
"
morgue
"
_ns
)
)
;
#
endif
nsCOMPtr
<
nsIDirectoryEnumerator
>
entries
;
rv
=
aBodyDir
-
>
GetDirectoryEntries
(
getter_AddRefs
(
entries
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
isEmpty
=
true
;
nsCOMPtr
<
nsIFile
>
file
;
while
(
NS_SUCCEEDED
(
rv
=
entries
-
>
GetNextFile
(
getter_AddRefs
(
file
)
)
)
&
&
file
)
{
bool
isDir
=
false
;
rv
=
file
-
>
IsDirectory
(
&
isDir
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
isDir
)
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFileRecursively
(
aQuotaInfo
file
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
continue
;
}
nsAutoCString
leafName
;
rv
=
file
-
>
GetNativeLeafName
(
leafName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
StringEndsWith
(
leafName
"
.
tmp
"
_ns
)
)
{
if
(
aCanRemoveFiles
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aQuotaInfo
file
aTrackQuota
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
continue
;
}
}
else
if
(
NS_WARN_IF
(
!
StringEndsWith
(
leafName
"
.
final
"
_ns
)
)
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFile
(
aQuotaInfo
file
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
continue
;
}
bool
fileDeleted
;
rv
=
aHandleFileFunc
(
file
leafName
fileDeleted
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
fileDeleted
)
{
continue
;
}
isEmpty
=
false
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
isEmpty
&
&
aCanRemoveFiles
)
{
DebugOnly
<
nsresult
>
result
=
RemoveNsIFileRecursively
(
aQuotaInfo
aBodyDir
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
result
)
)
;
}
return
rv
;
}
}
}
}
#
endif
