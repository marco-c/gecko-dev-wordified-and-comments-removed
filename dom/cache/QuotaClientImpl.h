#
ifndef
mozilla_dom_cache_QuotaClientImpl_h
#
define
mozilla_dom_cache_QuotaClientImpl_h
#
include
"
mozilla
/
dom
/
cache
/
QuotaClient
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
FileUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
class
CacheQuotaClient
final
:
public
quota
:
:
Client
{
static
CacheQuotaClient
*
sInstance
;
public
:
using
OriginMetadata
=
quota
:
:
OriginMetadata
;
using
PersistenceType
=
quota
:
:
PersistenceType
;
using
UsageInfo
=
quota
:
:
UsageInfo
;
CacheQuotaClient
(
)
;
static
CacheQuotaClient
*
Get
(
)
;
virtual
Type
GetType
(
)
override
;
virtual
Result
<
UsageInfo
nsresult
>
InitOrigin
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
const
AtomicBool
&
aCanceled
)
override
;
virtual
nsresult
InitOriginWithoutTracking
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
const
AtomicBool
&
aCanceled
)
override
;
virtual
Result
<
UsageInfo
nsresult
>
GetUsageForOrigin
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
const
AtomicBool
&
aCanceled
)
override
;
virtual
void
OnOriginClearCompleted
(
PersistenceType
aPersistenceType
const
nsACString
&
aOrigin
)
override
;
virtual
void
ReleaseIOThreadObjects
(
)
override
;
void
AbortOperationsForLocks
(
const
DirectoryLockIdTable
&
aDirectoryLockIds
)
override
;
virtual
void
AbortOperationsForProcess
(
ContentParentId
aContentParentId
)
override
;
virtual
void
AbortAllOperations
(
)
override
;
virtual
void
StartIdleMaintenance
(
)
override
;
virtual
void
StopIdleMaintenance
(
)
override
;
nsresult
UpgradeStorageFrom2_0To2_1
(
nsIFile
*
aDirectory
)
override
;
template
<
typename
Callable
>
nsresult
MaybeUpdatePaddingFileInternal
(
nsIFile
&
aBaseDir
mozIStorageConnection
&
aConn
const
int64_t
aIncreaseSize
const
int64_t
aDecreaseSize
Callable
&
&
aCommitHook
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aIncreaseSize
>
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aDecreaseSize
>
=
0
)
;
const
bool
temporaryPaddingFileExist
=
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
;
if
(
aIncreaseSize
=
=
aDecreaseSize
&
&
!
temporaryPaddingFileExist
)
{
CACHE_TRY
(
aCommitHook
(
)
)
;
return
NS_OK
;
}
{
MutexAutoLock
lock
(
mDirPaddingFileMutex
)
;
CACHE_TRY
(
LockedUpdateDirectoryPaddingFile
(
aBaseDir
aConn
aIncreaseSize
aDecreaseSize
temporaryPaddingFileExist
)
)
;
CACHE_TRY
(
aCommitHook
(
)
)
;
QM_TRY
(
QM_OR_ELSE_WARN
(
ToResult
(
LockedDirectoryPaddingFinalizeWrite
(
aBaseDir
)
)
(
[
&
aBaseDir
]
(
const
nsresult
)
-
>
Result
<
Ok
nsresult
>
{
Unused
<
<
LockedDirectoryPaddingDeleteFile
(
aBaseDir
DirPaddingFile
:
:
FILE
)
;
MOZ_ASSERT
(
DirectoryPaddingFileExists
(
aBaseDir
DirPaddingFile
:
:
TMP_FILE
)
)
;
return
Ok
{
}
;
}
)
)
)
;
}
return
NS_OK
;
}
nsresult
RestorePaddingFileInternal
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
)
;
nsresult
WipePaddingFileInternal
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
;
private
:
~
CacheQuotaClient
(
)
;
void
InitiateShutdown
(
)
override
;
bool
IsShutdownCompleted
(
)
const
override
;
nsCString
GetShutdownStatus
(
)
const
override
;
void
ForceKillActors
(
)
override
;
void
FinalizeShutdown
(
)
override
;
Result
<
UsageInfo
nsresult
>
GetUsageForOriginInternal
(
PersistenceType
aPersistenceType
const
OriginMetadata
&
aOriginMetadata
const
AtomicBool
&
aCanceled
bool
aInitializing
)
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CacheQuotaClient
override
)
mozilla
:
:
Mutex
mDirPaddingFileMutex
;
}
;
}
}
}
#
endif
