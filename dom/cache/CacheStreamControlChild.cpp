#
include
"
mozilla
/
dom
/
cache
/
CacheStreamControlChild
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ActorUtils
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheTypes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheWorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ReadStream
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptorSetChild
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PFileDescriptorSetChild
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
using
mozilla
:
:
dom
:
:
OptionalFileDescriptorSet
;
using
mozilla
:
:
ipc
:
:
AutoIPCStream
;
using
mozilla
:
:
ipc
:
:
FileDescriptor
;
using
mozilla
:
:
ipc
:
:
FileDescriptorSetChild
;
using
mozilla
:
:
ipc
:
:
PFileDescriptorSetChild
;
PCacheStreamControlChild
*
AllocPCacheStreamControlChild
(
)
{
return
new
CacheStreamControlChild
(
)
;
}
void
DeallocPCacheStreamControlChild
(
PCacheStreamControlChild
*
aActor
)
{
delete
aActor
;
}
CacheStreamControlChild
:
:
CacheStreamControlChild
(
)
:
mDestroyStarted
(
false
)
mDestroyDelayed
(
false
)
{
MOZ_COUNT_CTOR
(
cache
:
:
CacheStreamControlChild
)
;
}
CacheStreamControlChild
:
:
~
CacheStreamControlChild
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
MOZ_COUNT_DTOR
(
cache
:
:
CacheStreamControlChild
)
;
}
void
CacheStreamControlChild
:
:
StartDestroy
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
if
(
mDestroyStarted
)
{
return
;
}
mDestroyStarted
=
true
;
if
(
HasEverBeenRead
(
)
)
{
mDestroyDelayed
=
true
;
return
;
}
RecvCloseAll
(
)
;
}
void
CacheStreamControlChild
:
:
SerializeControl
(
CacheReadStream
*
aReadStreamOut
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aReadStreamOut
)
;
aReadStreamOut
-
>
controlParent
(
)
=
nullptr
;
aReadStreamOut
-
>
controlChild
(
)
=
this
;
}
void
CacheStreamControlChild
:
:
SerializeStream
(
CacheReadStream
*
aReadStreamOut
nsIInputStream
*
aStream
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aReadStreamOut
)
;
UniquePtr
<
AutoIPCStream
>
autoStream
(
new
AutoIPCStream
(
aReadStreamOut
-
>
stream
(
)
)
)
;
autoStream
-
>
Serialize
(
aStream
Manager
(
)
)
;
aStreamCleanupList
.
AppendElement
(
std
:
:
move
(
autoStream
)
)
;
}
void
CacheStreamControlChild
:
:
OpenStream
(
const
nsID
&
aId
InputStreamResolver
&
&
aResolver
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
if
(
mDestroyStarted
)
{
aResolver
(
nullptr
)
;
return
;
}
RefPtr
<
CacheWorkerRef
>
holder
=
GetWorkerRef
(
)
;
SendOpenStream
(
aId
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
aResolver
holder
]
(
RefPtr
<
nsIInputStream
>
&
&
aOptionalStream
)
{
aResolver
(
nsCOMPtr
<
nsIInputStream
>
(
aOptionalStream
.
forget
(
)
)
)
;
}
[
aResolver
holder
]
(
ResponseRejectReason
&
&
aReason
)
{
aResolver
(
nullptr
)
;
}
)
;
}
void
CacheStreamControlChild
:
:
NoteClosedAfterForget
(
const
nsID
&
aId
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
Unused
<
<
SendNoteClosed
(
aId
)
;
if
(
mDestroyDelayed
&
&
!
HasEverBeenRead
(
)
)
{
mDestroyDelayed
=
false
;
RecvCloseAll
(
)
;
}
}
#
ifdef
DEBUG
void
CacheStreamControlChild
:
:
AssertOwningThread
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
}
#
endif
void
CacheStreamControlChild
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
CloseAllReadStreamsWithoutReporting
(
)
;
RemoveWorkerRef
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CacheStreamControlChild
:
:
RecvClose
(
const
nsID
&
aId
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
CloseReadStreams
(
aId
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CacheStreamControlChild
:
:
RecvCloseAll
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
CloseAllReadStreams
(
)
;
return
IPC_OK
(
)
;
}
}
}
}
