#
include
"
CacheStreamControlChild
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ActorUtils
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheTypes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheWorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ReadStream
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptorSetChild
.
h
"
#
include
"
mozilla
/
ipc
/
IPCStreamUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PFileDescriptorSetChild
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
mozilla
:
:
dom
:
:
cache
{
using
mozilla
:
:
dom
:
:
OptionalFileDescriptorSet
;
using
mozilla
:
:
ipc
:
:
AutoIPCStream
;
using
mozilla
:
:
ipc
:
:
FileDescriptor
;
using
mozilla
:
:
ipc
:
:
FileDescriptorSetChild
;
using
mozilla
:
:
ipc
:
:
PFileDescriptorSetChild
;
already_AddRefed
<
PCacheStreamControlChild
>
AllocPCacheStreamControlChild
(
)
{
return
MakeAndAddRef
<
CacheStreamControlChild
>
(
)
;
}
CacheStreamControlChild
:
:
CacheStreamControlChild
(
)
:
mDestroyStarted
(
false
)
mDestroyDelayed
(
false
)
{
MOZ_COUNT_CTOR
(
cache
:
:
CacheStreamControlChild
)
;
}
CacheStreamControlChild
:
:
~
CacheStreamControlChild
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
MOZ_COUNT_DTOR
(
cache
:
:
CacheStreamControlChild
)
;
}
void
CacheStreamControlChild
:
:
StartDestroy
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
if
(
mDestroyStarted
)
{
return
;
}
mDestroyStarted
=
true
;
if
(
HasEverBeenRead
(
)
)
{
mDestroyDelayed
=
true
;
return
;
}
RecvCloseAll
(
)
;
}
void
CacheStreamControlChild
:
:
SerializeControl
(
CacheReadStream
*
aReadStreamOut
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aReadStreamOut
)
;
aReadStreamOut
-
>
controlParent
(
)
=
nullptr
;
aReadStreamOut
-
>
controlChild
(
)
=
this
;
}
void
CacheStreamControlChild
:
:
SerializeStream
(
CacheReadStream
*
aReadStreamOut
nsIInputStream
*
aStream
nsTArray
<
UniquePtr
<
AutoIPCStream
>
>
&
aStreamCleanupList
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aReadStreamOut
)
;
UniquePtr
<
AutoIPCStream
>
autoStream
(
new
AutoIPCStream
(
aReadStreamOut
-
>
stream
(
)
)
)
;
autoStream
-
>
Serialize
(
aStream
Manager
(
)
)
;
aStreamCleanupList
.
AppendElement
(
std
:
:
move
(
autoStream
)
)
;
}
void
CacheStreamControlChild
:
:
OpenStream
(
const
nsID
&
aId
InputStreamResolver
&
&
aResolver
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
if
(
mDestroyStarted
)
{
aResolver
(
nullptr
)
;
return
;
}
const
SafeRefPtr
<
CacheWorkerRef
>
holder
=
GetWorkerRefPtr
(
)
.
clonePtr
(
)
;
SendOpenStream
(
aId
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
aResolver
holder
=
holder
.
clonePtr
(
)
]
(
const
Maybe
<
IPCStream
>
&
aOptionalStream
)
{
nsCOMPtr
<
nsIInputStream
>
stream
=
DeserializeIPCStream
(
aOptionalStream
)
;
aResolver
(
std
:
:
move
(
stream
)
)
;
}
[
aResolver
holder
=
holder
.
clonePtr
(
)
]
(
ResponseRejectReason
&
&
aReason
)
{
aResolver
(
nullptr
)
;
}
)
;
}
void
CacheStreamControlChild
:
:
NoteClosedAfterForget
(
const
nsID
&
aId
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
QM_WARNONLY_TRY
(
OkIf
(
SendNoteClosed
(
aId
)
)
)
;
if
(
mDestroyDelayed
&
&
!
HasEverBeenRead
(
)
)
{
mDestroyDelayed
=
false
;
RecvCloseAll
(
)
;
}
}
#
ifdef
DEBUG
void
CacheStreamControlChild
:
:
AssertOwningThread
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
}
#
endif
void
CacheStreamControlChild
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
CloseAllReadStreamsWithoutReporting
(
)
;
RemoveWorkerRef
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
CacheStreamControlChild
:
:
RecvCloseAll
(
)
{
NS_ASSERT_OWNINGTHREAD
(
CacheStreamControlChild
)
;
CloseAllReadStreams
(
)
;
return
IPC_OK
(
)
;
}
}
