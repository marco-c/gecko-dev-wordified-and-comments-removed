#
ifndef
mozilla_dom_cache_FileUtils_h
#
define
mozilla_dom_cache_FileUtils_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Types
.
h
"
#
include
"
CacheCommon
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
struct
nsID
;
class
nsIFile
;
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
#
define
PADDING_FILE_NAME
u
"
.
padding
"
#
define
PADDING_TMP_FILE_NAME
u
"
.
padding
-
tmp
"
enum
class
DirPaddingFile
{
FILE
TMP_FILE
}
;
nsresult
BodyCreateDir
(
nsIFile
&
aBaseDir
)
;
nsresult
BodyDeleteDir
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aBaseDir
)
;
Result
<
std
:
:
pair
<
nsID
nsCOMPtr
<
nsISupports
>
>
nsresult
>
BodyStartWriteStream
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aBaseDir
nsIInputStream
&
aSource
void
*
aClosure
nsAsyncCopyCallbackFun
aCallback
)
;
void
BodyCancelWrite
(
nsISupports
&
aCopyContext
)
;
nsresult
BodyFinalizeWrite
(
nsIFile
&
aBaseDir
const
nsID
&
aId
)
;
Result
<
NotNull
<
nsCOMPtr
<
nsIInputStream
>
>
nsresult
>
BodyOpen
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aBaseDir
const
nsID
&
aId
)
;
nsresult
BodyMaybeUpdatePaddingSize
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aBaseDir
const
nsID
&
aId
uint32_t
aPaddingInfo
int64_t
*
aPaddingSizeInOut
)
;
nsresult
BodyDeleteFiles
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aBaseDir
const
nsTArray
<
nsID
>
&
aIdList
)
;
nsresult
BodyDeleteOrphanedFiles
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aBaseDir
const
nsTArray
<
nsID
>
&
aKnownBodyIdList
)
;
template
<
typename
Func
>
nsresult
BodyTraverseFiles
(
const
Maybe
<
ClientMetadata
>
&
aClientMetadata
nsIFile
&
aBodyDir
const
Func
&
aHandleFileFunc
bool
aCanRemoveFiles
bool
aTrackQuota
=
true
)
;
template
<
typename
Func
>
nsresult
BodyTraverseFiles
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aBodyDir
const
Func
&
aHandleFileFunc
bool
aCanRemoveFiles
bool
aTrackQuota
=
true
)
{
return
BodyTraverseFiles
(
Some
(
aClientMetadata
)
aBodyDir
aHandleFileFunc
aCanRemoveFiles
aTrackQuota
)
;
}
nsresult
CreateMarkerFile
(
const
ClientMetadata
&
aClientMetadata
)
;
nsresult
DeleteMarkerFile
(
const
ClientMetadata
&
aClientMetadata
)
;
bool
MarkerFileExists
(
const
ClientMetadata
&
aClientMetadata
)
;
nsresult
RemoveNsIFileRecursively
(
const
Maybe
<
ClientMetadata
>
&
aClientMetadata
nsIFile
&
aFile
bool
aTrackQuota
=
true
)
;
inline
nsresult
RemoveNsIFileRecursively
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aFile
bool
aTrackQuota
=
true
)
{
return
RemoveNsIFileRecursively
(
Some
(
aClientMetadata
)
aFile
aTrackQuota
)
;
}
nsresult
RemoveNsIFile
(
const
Maybe
<
ClientMetadata
>
&
aClientMetadata
nsIFile
&
aFile
bool
aTrackQuota
=
true
)
;
inline
nsresult
RemoveNsIFile
(
const
ClientMetadata
&
aClientMetadata
nsIFile
&
aFile
bool
aTrackQuota
=
true
)
{
return
RemoveNsIFile
(
Some
(
aClientMetadata
)
aFile
aTrackQuota
)
;
}
void
DecreaseUsageForClientMetadata
(
const
ClientMetadata
&
aClientMetadata
int64_t
aUpdatingSize
)
;
bool
DirectoryPaddingFileExists
(
nsIFile
&
aBaseDir
DirPaddingFile
aPaddingFileType
)
;
Result
<
int64_t
nsresult
>
DirectoryPaddingGet
(
nsIFile
&
aBaseDir
)
;
nsresult
DirectoryPaddingInit
(
nsIFile
&
aBaseDir
)
;
nsresult
UpdateDirectoryPaddingFile
(
nsIFile
&
aBaseDir
mozIStorageConnection
&
aConn
int64_t
aIncreaseSize
int64_t
aDecreaseSize
bool
aTemporaryFileExist
)
;
nsresult
DirectoryPaddingFinalizeWrite
(
nsIFile
&
aBaseDir
)
;
Result
<
int64_t
nsresult
>
DirectoryPaddingRestore
(
nsIFile
&
aBaseDir
mozIStorageConnection
&
aConn
bool
aMustRestore
)
;
nsresult
DirectoryPaddingDeleteFile
(
nsIFile
&
aBaseDir
DirPaddingFile
aPaddingFileType
)
;
}
}
}
#
endif
