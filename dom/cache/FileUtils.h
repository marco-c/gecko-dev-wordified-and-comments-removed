#
ifndef
mozilla_dom_cache_FileUtils_h
#
define
mozilla_dom_cache_FileUtils_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Types
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
struct
nsID
;
class
nsIFile
;
namespace
mozilla
{
namespace
dom
{
namespace
cache
{
#
define
PADDING_FILE_NAME
"
.
padding
"
#
define
PADDING_TMP_FILE_NAME
"
.
padding
-
tmp
"
enum
DirPaddingFile
{
FILE
TMP_FILE
}
;
nsresult
BodyCreateDir
(
nsIFile
*
aBaseDir
)
;
nsresult
BodyDeleteDir
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
)
;
nsresult
BodyGetCacheDir
(
nsIFile
*
aBaseDir
const
nsID
&
aId
nsIFile
*
*
aCacheDirOut
)
;
nsresult
BodyStartWriteStream
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
nsIInputStream
*
aSource
void
*
aClosure
nsAsyncCopyCallbackFun
aCallback
nsID
*
aIdOut
nsISupports
*
*
aCopyContextOut
)
;
void
BodyCancelWrite
(
nsIFile
*
aBaseDir
nsISupports
*
aCopyContext
)
;
nsresult
BodyFinalizeWrite
(
nsIFile
*
aBaseDir
const
nsID
&
aId
)
;
nsresult
BodyOpen
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
const
nsID
&
aId
nsIInputStream
*
*
aStreamOut
)
;
nsresult
BodyMaybeUpdatePaddingSize
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
const
nsID
&
aId
const
uint32_t
aPaddingInfo
int64_t
*
aPaddingSizeOut
)
;
nsresult
BodyDeleteFiles
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
const
nsTArray
<
nsID
>
&
aIdList
)
;
nsresult
BodyDeleteOrphanedFiles
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBaseDir
nsTArray
<
nsID
>
&
aKnownBodyIdList
)
;
template
<
typename
Func
>
nsresult
BodyTraverseFiles
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aBodyDir
const
Func
&
aHandleFileFunc
const
bool
aCanRemoveFiles
const
bool
aTrackQuota
=
true
)
;
nsresult
CreateMarkerFile
(
const
QuotaInfo
&
aQuotaInfo
)
;
nsresult
DeleteMarkerFile
(
const
QuotaInfo
&
aQuotaInfo
)
;
bool
MarkerFileExists
(
const
QuotaInfo
&
aQuotaInfo
)
;
nsresult
RemoveNsIFileRecursively
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aFile
const
bool
aTrackQuota
=
true
)
;
nsresult
RemoveNsIFile
(
const
QuotaInfo
&
aQuotaInfo
nsIFile
*
aFile
const
bool
aTrackQuota
=
true
)
;
void
DecreaseUsageForQuotaInfo
(
const
QuotaInfo
&
aQuotaInfo
const
int64_t
&
aUpdatingSize
)
;
bool
DirectoryPaddingFileExists
(
nsIFile
*
aBaseDir
DirPaddingFile
aPaddingFileType
)
;
nsresult
LockedDirectoryPaddingGet
(
nsIFile
*
aBaseDir
int64_t
*
aPaddingSizeOut
)
;
nsresult
LockedDirectoryPaddingInit
(
nsIFile
*
aBaseDir
)
;
nsresult
LockedUpdateDirectoryPaddingFile
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
const
int64_t
aIncreaseSize
const
int64_t
aDecreaseSize
const
bool
aTemporaryFileExist
)
;
nsresult
LockedDirectoryPaddingTemporaryWrite
(
nsIFile
*
aBaseDir
int64_t
aPaddingSize
)
;
nsresult
LockedDirectoryPaddingFinalizeWrite
(
nsIFile
*
aBaseDir
)
;
nsresult
LockedDirectoryPaddingRestore
(
nsIFile
*
aBaseDir
mozIStorageConnection
*
aConn
bool
aMustRestore
int64_t
*
aPaddingSizeOut
)
;
nsresult
LockedDirectoryPaddingDeleteFile
(
nsIFile
*
aBaseDir
DirPaddingFile
aPaddingFileType
)
;
}
}
}
#
endif
