#
ifndef
mozilla_dom_cache_BackgroundStorageKey_h
#
define
mozilla_dom_cache_BackgroundStorageKey_h
#
include
"
BoundStorageKeyChild
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheTypes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
TypeUtils
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
PrincipalInfo
;
class
PBackgroundChild
;
}
namespace
dom
{
class
Response
;
namespace
cache
{
extern
bool
IsTrusted
(
const
:
:
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
bool
aTestingPrefEnabled
)
;
class
CacheStorageChild
;
class
BoundStorageKeyCache
;
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
class
BoundStorageKey
:
public
nsISupports
public
BoundStorageKeyChildListener
{
public
:
using
PBackgroundChild
=
:
:
mozilla
:
:
ipc
:
:
PBackgroundChild
;
NS_DECL_ISUPPORTS
BoundStorageKey
(
)
:
mActor
(
nullptr
)
mStatus
(
NS_OK
)
{
}
void
OnActorDestroy
(
BoundStorageKeyChild
*
aActor
)
override
;
protected
:
virtual
~
BoundStorageKey
(
)
;
nsresult
Init
(
Namespace
aNamespace
const
PrincipalInfo
&
aPrincipalInfo
nsISerialEventTarget
*
aTarget
=
GetCurrentSerialEventTarget
(
)
)
;
RefPtr
<
BoundStorageKeyChild
>
mActor
;
nsresult
mStatus
;
}
;
using
CacheStoragePromise
=
MozPromiseBase
;
using
OpenResultPromise
=
mozilla
:
:
MozPromise
<
RefPtr
<
BoundStorageKeyCache
>
ErrorResult
true
>
;
using
DeleteResultPromise
=
mozilla
:
:
MozPromise
<
bool
ErrorResult
true
>
;
using
HasResultPromise
=
mozilla
:
:
MozPromise
<
bool
ErrorResult
true
>
;
using
KeysResultPromise
=
mozilla
:
:
MozPromise
<
CopyableTArray
<
nsString
>
ErrorResult
true
>
;
using
MatchResultPromise
=
mozilla
:
:
MozPromise
<
RefPtr
<
Response
>
ErrorResult
true
>
;
class
BoundStorageKeyCacheStorage
final
:
public
BoundStorageKey
public
TypeUtils
public
CacheStorageChildListener
{
public
:
static
already_AddRefed
<
BoundStorageKeyCacheStorage
>
Create
(
Namespace
aNamespace
nsIGlobalObject
*
aGlobal
WorkerPrivate
*
aWorkerPrivate
nsISerialEventTarget
*
aActorTarget
ErrorResult
&
aRv
)
;
#
ifdef
DEBUG
void
AssertOwningThread
(
)
const
override
{
NS_ASSERT_OWNINGTHREAD
(
BoundStorageKey
)
;
}
#
else
inline
void
AssertOwningThread
(
)
const
{
}
#
endif
nsresult
Init
(
WorkerPrivate
*
aWorkerPrivate
Namespace
aNamespace
const
PrincipalInfo
&
aPrincipalInfo
nsISerialEventTarget
*
aTarget
=
GetCurrentSerialEventTarget
(
)
)
;
already_AddRefed
<
CacheStoragePromise
>
Match
(
JSContext
*
aCx
const
RequestOrUTF8String
&
aRequest
const
MultiCacheQueryOptions
&
aOptions
ErrorResult
&
aRv
)
;
already_AddRefed
<
CacheStoragePromise
>
Has
(
const
nsAString
&
aKey
ErrorResult
&
aRv
)
;
already_AddRefed
<
CacheStoragePromise
>
Open
(
const
nsAString
&
aKey
ErrorResult
&
aRv
)
;
already_AddRefed
<
CacheStoragePromise
>
Delete
(
const
nsAString
&
aKey
ErrorResult
&
aRv
)
;
already_AddRefed
<
CacheStoragePromise
>
Keys
(
ErrorResult
&
aRv
)
;
nsIGlobalObject
*
GetGlobalObject
(
)
const
override
{
return
mGlobal
;
}
using
BoundStorageKey
:
:
OnActorDestroy
;
void
OnActorDestroy
(
CacheStorageChild
*
aActor
)
override
;
private
:
template
<
typename
PromiseType
>
struct
Entry
;
BoundStorageKeyCacheStorage
(
Namespace
aNamespace
nsIGlobalObject
*
aGlobal
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
)
;
already_AddRefed
<
CacheStorageChild
>
CreateCacheStorageChild
(
WorkerPrivate
*
aWorkerPrivate
)
;
~
BoundStorageKeyCacheStorage
(
)
override
;
template
<
typename
EntryType
>
void
RunRequest
(
EntryType
&
&
aEntry
)
;
RefPtr
<
CacheStorageChild
>
mCacheStorageChild
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
const
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
mPrincipalInfo
;
const
Namespace
mNamespace
;
}
;
}
template
<
dom
:
:
cache
:
:
CacheOpResult
:
:
Type
OP_TYPE
>
struct
cachestorage_traits
;
template
<
>
struct
cachestorage_traits
<
dom
:
:
cache
:
:
CacheOpResult
:
:
Type
:
:
TStorageMatchResult
>
{
using
PromiseType
=
cache
:
:
MatchResultPromise
:
:
Private
;
}
;
template
<
>
struct
cachestorage_traits
<
dom
:
:
cache
:
:
CacheOpResult
:
:
Type
:
:
TStorageHasResult
>
{
using
PromiseType
=
cache
:
:
HasResultPromise
:
:
Private
;
}
;
template
<
>
struct
cachestorage_traits
<
dom
:
:
cache
:
:
CacheOpResult
:
:
Type
:
:
TStorageOpenResult
>
{
using
PromiseType
=
cache
:
:
OpenResultPromise
:
:
Private
;
}
;
template
<
>
struct
cachestorage_traits
<
dom
:
:
cache
:
:
CacheOpResult
:
:
Type
:
:
TStorageDeleteResult
>
{
using
PromiseType
=
cache
:
:
DeleteResultPromise
:
:
Private
;
}
;
template
<
>
struct
cachestorage_traits
<
dom
:
:
cache
:
:
CacheOpResult
:
:
Type
:
:
TStorageKeysResult
>
{
using
PromiseType
=
cache
:
:
KeysResultPromise
:
:
Private
;
}
;
template
<
>
struct
cachestorage_traits
<
dom
:
:
cache
:
:
CacheOpResult
:
:
Type
:
:
Tvoid_t
>
{
using
PromiseType
=
cache
:
:
HasResultPromise
:
:
Private
;
}
;
}
}
#
endif
