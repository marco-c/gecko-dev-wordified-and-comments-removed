#
ifndef
mozilla_dom_cache_ReadStream_h
#
define
mozilla_dom_cache_ReadStream_h
#
include
"
mozilla
/
dom
/
SafeRefPtr
.
h
"
#
include
"
mozilla
/
ipc
/
FileDescriptor
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
:
:
cache
{
class
CacheReadStream
;
class
PCacheStreamControlParent
;
#
define
NS_DOM_CACHE_READSTREAM_IID
\
{
\
0x8e5da7c9
0x0940
0x4f1d
{
\
0x97
0x25
0x5c
0x59
0x38
0xdd
0xb9
0x9f
\
}
\
}
class
ReadStream
final
:
public
nsIInputStream
{
public
:
class
Controllable
:
public
AtomicSafeRefCounted
<
Controllable
>
{
public
:
virtual
~
Controllable
(
)
=
default
;
virtual
void
CloseStream
(
)
=
0
;
virtual
void
CloseStreamWithoutReporting
(
)
=
0
;
virtual
bool
HasEverBeenRead
(
)
const
=
0
;
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
ReadStream
:
:
Controllable
)
;
}
;
static
already_AddRefed
<
ReadStream
>
Create
(
const
Maybe
<
CacheReadStream
>
&
aMaybeReadStream
)
;
static
already_AddRefed
<
ReadStream
>
Create
(
const
CacheReadStream
&
aReadStream
)
;
static
already_AddRefed
<
ReadStream
>
Create
(
PCacheStreamControlParent
*
aControl
const
nsID
&
aId
nsIInputStream
*
aStream
)
;
void
Serialize
(
Maybe
<
CacheReadStream
>
*
aReadStreamOut
ErrorResult
&
aRv
)
;
void
Serialize
(
CacheReadStream
*
aReadStreamOut
ErrorResult
&
aRv
)
;
private
:
class
Inner
;
~
ReadStream
(
)
;
SafeRefPtr
<
ReadStream
:
:
Inner
>
mInner
;
public
:
explicit
ReadStream
(
SafeRefPtr
<
ReadStream
:
:
Inner
>
aInner
)
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_DOM_CACHE_READSTREAM_IID
)
;
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIINPUTSTREAM
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
ReadStream
NS_DOM_CACHE_READSTREAM_IID
)
;
}
}
#
endif
