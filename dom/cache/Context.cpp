#
include
"
mozilla
/
dom
/
cache
/
Context
.
h
"
#
include
"
CacheCommon
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
dom
/
SafeRefPtr
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Action
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
FileUtils
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Manager
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
ManagerId
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManager
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
{
using
mozilla
:
:
dom
:
:
cache
:
:
Action
;
using
mozilla
:
:
dom
:
:
cache
:
:
QuotaInfo
;
class
NullAction
final
:
public
Action
{
public
:
NullAction
(
)
=
default
;
virtual
void
RunOnTarget
(
mozilla
:
:
SafeRefPtr
<
Resolver
>
aResolver
const
QuotaInfo
&
Data
*
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
aResolver
)
;
aResolver
-
>
Resolve
(
NS_OK
)
;
}
}
;
}
namespace
mozilla
:
:
dom
:
:
cache
{
using
mozilla
:
:
dom
:
:
quota
:
:
AssertIsOnIOThread
;
using
mozilla
:
:
dom
:
:
quota
:
:
OpenDirectoryListener
;
using
mozilla
:
:
dom
:
:
quota
:
:
PERSISTENCE_TYPE_DEFAULT
;
using
mozilla
:
:
dom
:
:
quota
:
:
PersistenceType
;
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaManager
;
class
Context
:
:
Data
final
:
public
Action
:
:
Data
{
public
:
explicit
Data
(
nsISerialEventTarget
*
aTarget
)
:
mTarget
(
aTarget
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
)
;
}
virtual
mozIStorageConnection
*
GetConnection
(
)
const
override
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
return
mConnection
;
}
virtual
void
SetConnection
(
mozIStorageConnection
*
aConn
)
override
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mConnection
)
;
mConnection
=
aConn
;
MOZ_DIAGNOSTIC_ASSERT
(
mConnection
)
;
}
private
:
~
Data
(
)
{
MOZ_ASSERT_IF
(
mConnection
mTarget
-
>
IsOnCurrentThread
(
)
)
;
}
nsCOMPtr
<
nsISerialEventTarget
>
mTarget
;
nsCOMPtr
<
mozIStorageConnection
>
mConnection
;
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
Context
:
:
Data
)
}
;
class
Context
:
:
QuotaInitRunnable
final
:
public
nsIRunnable
public
OpenDirectoryListener
{
public
:
QuotaInitRunnable
(
SafeRefPtr
<
Context
>
aContext
SafeRefPtr
<
Manager
>
aManager
Data
*
aData
nsISerialEventTarget
*
aTarget
SafeRefPtr
<
Action
>
aInitAction
)
:
mContext
(
std
:
:
move
(
aContext
)
)
mThreadsafeHandle
(
mContext
-
>
CreateThreadsafeHandle
(
)
)
mManager
(
std
:
:
move
(
aManager
)
)
mData
(
aData
)
mTarget
(
aTarget
)
mInitAction
(
std
:
:
move
(
aInitAction
)
)
mInitiatingEventTarget
(
GetCurrentSerialEventTarget
(
)
)
mResult
(
NS_OK
)
mState
(
STATE_INIT
)
mCanceled
(
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mManager
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mData
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInitiatingEventTarget
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInitAction
)
;
}
nsresult
Dispatch
(
)
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_INIT
)
;
mState
=
STATE_GET_INFO
;
nsresult
rv
=
NS_DispatchToMainThread
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mState
=
STATE_COMPLETE
;
Clear
(
)
;
}
return
rv
;
}
void
Cancel
(
)
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mCanceled
)
;
mCanceled
=
true
;
mInitAction
-
>
CancelOnInitiatingThread
(
)
;
}
void
OpenDirectory
(
)
;
virtual
void
DirectoryLockAcquired
(
DirectoryLock
*
aLock
)
override
;
virtual
void
DirectoryLockFailed
(
)
override
;
private
:
class
SyncResolver
final
:
public
Action
:
:
Resolver
{
public
:
SyncResolver
(
)
:
mResolved
(
false
)
mResult
(
NS_OK
)
{
}
virtual
void
Resolve
(
nsresult
aRv
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mResolved
)
;
mResolved
=
true
;
mResult
=
aRv
;
}
;
bool
Resolved
(
)
const
{
return
mResolved
;
}
nsresult
Result
(
)
const
{
return
mResult
;
}
private
:
~
SyncResolver
(
)
=
default
;
bool
mResolved
;
nsresult
mResult
;
NS_INLINE_DECL_REFCOUNTING
(
Context
:
:
QuotaInitRunnable
:
:
SyncResolver
override
)
}
;
~
QuotaInitRunnable
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_COMPLETE
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitAction
)
;
}
enum
State
{
STATE_INIT
STATE_GET_INFO
STATE_CREATE_QUOTA_MANAGER
STATE_OPEN_DIRECTORY
STATE_WAIT_FOR_DIRECTORY_LOCK
STATE_ENSURE_ORIGIN_INITIALIZED
STATE_RUN_ON_TARGET
STATE_RUNNING
STATE_COMPLETING
STATE_COMPLETE
}
;
void
Complete
(
nsresult
aResult
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_RUNNING
|
|
NS_FAILED
(
aResult
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
NS_SUCCEEDED
(
mResult
)
)
;
mResult
=
aResult
;
mState
=
STATE_COMPLETING
;
MOZ_ALWAYS_SUCCEEDS
(
mInitiatingEventTarget
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
}
void
Clear
(
)
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mContext
)
;
mContext
=
nullptr
;
mManager
=
nullptr
;
mInitAction
=
nullptr
;
}
SafeRefPtr
<
Context
>
mContext
;
SafeRefPtr
<
ThreadsafeHandle
>
mThreadsafeHandle
;
SafeRefPtr
<
Manager
>
mManager
;
RefPtr
<
Data
>
mData
;
nsCOMPtr
<
nsISerialEventTarget
>
mTarget
;
SafeRefPtr
<
Action
>
mInitAction
;
nsCOMPtr
<
nsIEventTarget
>
mInitiatingEventTarget
;
nsresult
mResult
;
QuotaInfo
mQuotaInfo
;
RefPtr
<
DirectoryLock
>
mDirectoryLock
;
State
mState
;
Atomic
<
bool
>
mCanceled
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
}
;
void
Context
:
:
QuotaInitRunnable
:
:
OpenDirectory
(
)
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_CREATE_QUOTA_MANAGER
|
|
mState
=
=
STATE_OPEN_DIRECTORY
)
;
MOZ_DIAGNOSTIC_ASSERT
(
QuotaManager
:
:
Get
(
)
)
;
mState
=
STATE_WAIT_FOR_DIRECTORY_LOCK
;
RefPtr
<
DirectoryLock
>
pendingDirectoryLock
=
QuotaManager
:
:
Get
(
)
-
>
OpenDirectory
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
quota
:
:
Client
:
:
DOMCACHE
false
this
)
;
}
void
Context
:
:
QuotaInitRunnable
:
:
DirectoryLockAcquired
(
DirectoryLock
*
aLock
)
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aLock
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_WAIT_FOR_DIRECTORY_LOCK
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDirectoryLock
)
;
mDirectoryLock
=
aLock
;
MOZ_DIAGNOSTIC_ASSERT
(
mDirectoryLock
-
>
Id
(
)
>
=
0
)
;
mQuotaInfo
.
mDirectoryLockId
=
mDirectoryLock
-
>
Id
(
)
;
if
(
mCanceled
)
{
Complete
(
NS_ERROR_ABORT
)
;
return
;
}
QuotaManager
*
qm
=
QuotaManager
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
qm
)
;
mState
=
STATE_ENSURE_ORIGIN_INITIALIZED
;
nsresult
rv
=
qm
-
>
IOThread
(
)
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Complete
(
rv
)
;
return
;
}
}
void
Context
:
:
QuotaInitRunnable
:
:
DirectoryLockFailed
(
)
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_WAIT_FOR_DIRECTORY_LOCK
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDirectoryLock
)
;
NS_WARNING
(
"
Failed
to
acquire
a
directory
lock
!
"
)
;
Complete
(
NS_ERROR_FAILURE
)
;
}
NS_IMPL_ISUPPORTS
(
mozilla
:
:
dom
:
:
cache
:
:
Context
:
:
QuotaInitRunnable
nsIRunnable
)
;
NS_IMETHODIMP
Context
:
:
QuotaInitRunnable
:
:
Run
(
)
{
SafeRefPtr
<
SyncResolver
>
resolver
=
MakeSafeRefPtr
<
SyncResolver
>
(
)
;
switch
(
mState
)
{
case
STATE_GET_INFO
:
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mCanceled
)
{
resolver
-
>
Resolve
(
NS_ERROR_ABORT
)
;
break
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
mManager
-
>
GetManagerId
(
)
.
Principal
(
)
;
DebugOnly
res
=
QuotaManager
:
:
GetInfoFromPrincipal
(
principal
)
.
andThen
(
[
&
self
=
*
this
]
(
quota
:
:
QuotaInfo
&
&
quotaInfo
)
{
static_cast
<
quota
:
:
QuotaInfo
&
>
(
self
.
mQuotaInfo
)
=
std
:
:
move
(
quotaInfo
)
;
self
.
mState
=
STATE_CREATE_QUOTA_MANAGER
;
MOZ_ALWAYS_SUCCEEDS
(
self
.
mInitiatingEventTarget
-
>
Dispatch
(
&
self
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
return
Result
<
Ok
nsresult
>
{
Ok
{
}
}
;
}
)
.
orElse
(
[
&
resolver
]
(
const
auto
&
res
)
{
resolver
-
>
Resolve
(
res
)
;
return
Result
<
Ok
nsresult
>
{
Ok
{
}
}
;
}
)
;
MOZ_ASSERT
(
res
.
inspect
(
)
.
isOk
(
)
)
;
break
;
}
case
STATE_CREATE_QUOTA_MANAGER
:
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
if
(
mCanceled
|
|
QuotaManager
:
:
IsShuttingDown
(
)
)
{
resolver
-
>
Resolve
(
NS_ERROR_ABORT
)
;
break
;
}
if
(
QuotaManager
:
:
Get
(
)
)
{
OpenDirectory
(
)
;
return
NS_OK
;
}
mState
=
STATE_OPEN_DIRECTORY
;
QuotaManager
:
:
GetOrCreate
(
this
)
;
break
;
}
case
STATE_OPEN_DIRECTORY
:
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
if
(
NS_WARN_IF
(
!
QuotaManager
:
:
Get
(
)
)
)
{
resolver
-
>
Resolve
(
NS_ERROR_FAILURE
)
;
break
;
}
OpenDirectory
(
)
;
break
;
}
case
STATE_ENSURE_ORIGIN_INITIALIZED
:
{
AssertIsOnIOThread
(
)
;
if
(
mCanceled
)
{
resolver
-
>
Resolve
(
NS_ERROR_ABORT
)
;
break
;
}
QuotaManager
*
qm
=
QuotaManager
:
:
Get
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
qm
)
;
auto
directoryOrErr
=
qm
-
>
EnsureStorageAndOriginIsInitialized
(
PERSISTENCE_TYPE_DEFAULT
mQuotaInfo
quota
:
:
Client
:
:
DOMCACHE
)
;
if
(
directoryOrErr
.
isErr
(
)
)
{
resolver
-
>
Resolve
(
directoryOrErr
.
inspectErr
(
)
)
;
break
;
}
mQuotaInfo
.
mDir
=
directoryOrErr
.
unwrap
(
)
;
mState
=
STATE_RUN_ON_TARGET
;
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
break
;
}
case
STATE_RUN_ON_TARGET
:
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
mState
=
STATE_RUNNING
;
mInitAction
-
>
RunOnTarget
(
resolver
.
clonePtr
(
)
mQuotaInfo
mData
)
;
MOZ_DIAGNOSTIC_ASSERT
(
resolver
-
>
Resolved
(
)
)
;
mData
=
nullptr
;
if
(
NS_SUCCEEDED
(
resolver
-
>
Result
(
)
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
CreateMarkerFile
(
mQuotaInfo
)
)
;
}
break
;
}
case
STATE_COMPLETING
:
{
NS_ASSERT_OWNINGTHREAD
(
QuotaInitRunnable
)
;
mInitAction
-
>
CompleteOnInitiatingThread
(
mResult
)
;
mContext
-
>
OnQuotaInit
(
mResult
mQuotaInfo
mDirectoryLock
.
forget
(
)
)
;
mState
=
STATE_COMPLETE
;
Clear
(
)
;
break
;
}
case
STATE_WAIT_FOR_DIRECTORY_LOCK
:
default
:
{
MOZ_CRASH
(
"
unexpected
state
in
QuotaInitRunnable
"
)
;
}
}
if
(
resolver
-
>
Resolved
(
)
)
{
Complete
(
resolver
-
>
Result
(
)
)
;
}
return
NS_OK
;
}
class
Context
:
:
ActionRunnable
final
:
public
nsIRunnable
public
Action
:
:
Resolver
public
Context
:
:
Activity
{
public
:
ActionRunnable
(
SafeRefPtr
<
Context
>
aContext
Data
*
aData
nsISerialEventTarget
*
aTarget
SafeRefPtr
<
Action
>
aAction
const
QuotaInfo
&
aQuotaInfo
)
:
mContext
(
std
:
:
move
(
aContext
)
)
mData
(
aData
)
mTarget
(
aTarget
)
mAction
(
std
:
:
move
(
aAction
)
)
mQuotaInfo
(
aQuotaInfo
)
mInitiatingThread
(
GetCurrentEventTarget
(
)
)
mState
(
STATE_INIT
)
mResult
(
NS_OK
)
mExecutingRunOnTarget
(
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mAction
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInitiatingThread
)
;
}
nsresult
Dispatch
(
)
{
NS_ASSERT_OWNINGTHREAD
(
ActionRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_INIT
)
;
mState
=
STATE_RUN_ON_TARGET
;
nsresult
rv
=
mTarget
-
>
Dispatch
(
this
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mState
=
STATE_COMPLETE
;
Clear
(
)
;
}
return
rv
;
}
virtual
bool
MatchesCacheId
(
CacheId
aCacheId
)
const
override
{
NS_ASSERT_OWNINGTHREAD
(
ActionRunnable
)
;
return
mAction
-
>
MatchesCacheId
(
aCacheId
)
;
}
virtual
void
Cancel
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
ActionRunnable
)
;
mAction
-
>
CancelOnInitiatingThread
(
)
;
}
virtual
void
Resolve
(
nsresult
aRv
)
override
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_RUNNING
)
;
mResult
=
aRv
;
mState
=
STATE_RESOLVING
;
if
(
mExecutingRunOnTarget
)
{
return
;
}
MOZ_ALWAYS_SUCCEEDS
(
mTarget
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
}
private
:
~
ActionRunnable
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_COMPLETE
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mAction
)
;
}
void
Clear
(
)
{
NS_ASSERT_OWNINGTHREAD
(
ActionRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mAction
)
;
mContext
-
>
RemoveActivity
(
this
)
;
mContext
=
nullptr
;
mAction
=
nullptr
;
}
enum
State
{
STATE_INIT
STATE_RUN_ON_TARGET
STATE_RUNNING
STATE_RESOLVING
STATE_COMPLETING
STATE_COMPLETE
}
;
SafeRefPtr
<
Context
>
mContext
;
RefPtr
<
Data
>
mData
;
nsCOMPtr
<
nsISerialEventTarget
>
mTarget
;
SafeRefPtr
<
Action
>
mAction
;
const
QuotaInfo
mQuotaInfo
;
nsCOMPtr
<
nsIEventTarget
>
mInitiatingThread
;
State
mState
;
nsresult
mResult
;
bool
mExecutingRunOnTarget
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIRUNNABLE
}
;
NS_IMPL_ISUPPORTS
(
mozilla
:
:
dom
:
:
cache
:
:
Context
:
:
ActionRunnable
nsIRunnable
)
;
NS_IMETHODIMP
Context
:
:
ActionRunnable
:
:
Run
(
)
{
switch
(
mState
)
{
case
STATE_RUN_ON_TARGET
:
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mExecutingRunOnTarget
)
;
AutoRestore
<
bool
>
executingRunOnTarget
(
mExecutingRunOnTarget
)
;
mExecutingRunOnTarget
=
true
;
mState
=
STATE_RUNNING
;
mAction
-
>
RunOnTarget
(
SafeRefPtrFromThis
(
)
mQuotaInfo
mData
)
;
mData
=
nullptr
;
if
(
mState
=
=
STATE_RESOLVING
)
{
Run
(
)
;
}
break
;
}
case
STATE_RESOLVING
:
{
MOZ_ASSERT
(
mTarget
-
>
IsOnCurrentThread
(
)
)
;
mState
=
STATE_COMPLETING
;
MOZ_ALWAYS_SUCCEEDS
(
mInitiatingThread
-
>
Dispatch
(
this
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
break
;
}
case
STATE_COMPLETING
:
{
NS_ASSERT_OWNINGTHREAD
(
ActionRunnable
)
;
mAction
-
>
CompleteOnInitiatingThread
(
mResult
)
;
mState
=
STATE_COMPLETE
;
Clear
(
)
;
break
;
}
default
:
{
MOZ_CRASH
(
"
unexpected
state
in
ActionRunnable
"
)
;
break
;
}
}
return
NS_OK
;
}
void
Context
:
:
ThreadsafeHandle
:
:
AllowToClose
(
)
{
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
AllowToCloseOnOwningThread
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
dom
:
:
cache
:
:
Context
:
:
ThreadsafeHandle
:
:
AllowToCloseOnOwningThread
"
this
&
ThreadsafeHandle
:
:
AllowToCloseOnOwningThread
)
;
MOZ_ALWAYS_SUCCEEDS
(
mOwningEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
}
void
Context
:
:
ThreadsafeHandle
:
:
InvalidateAndAllowToClose
(
)
{
if
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
InvalidateAndAllowToCloseOnOwningThread
(
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
dom
:
:
cache
:
:
Context
:
:
ThreadsafeHandle
:
:
"
"
InvalidateAndAllowToCloseOnOwningThread
"
this
&
ThreadsafeHandle
:
:
InvalidateAndAllowToCloseOnOwningThread
)
;
MOZ_ALWAYS_SUCCEEDS
(
mOwningEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
nsIThread
:
:
DISPATCH_NORMAL
)
)
;
}
Context
:
:
ThreadsafeHandle
:
:
ThreadsafeHandle
(
SafeRefPtr
<
Context
>
aContext
)
:
mStrongRef
(
std
:
:
move
(
aContext
)
)
mWeakRef
(
mStrongRef
.
unsafeGetRawPtr
(
)
)
mOwningEventTarget
(
GetCurrentSerialEventTarget
(
)
)
{
}
Context
:
:
ThreadsafeHandle
:
:
~
ThreadsafeHandle
(
)
{
if
(
!
mStrongRef
|
|
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
{
return
;
}
NS_ProxyRelease
(
"
Context
:
:
ThreadsafeHandle
:
:
mStrongRef
"
mOwningEventTarget
mStrongRef
.
forget
(
)
)
;
}
void
Context
:
:
ThreadsafeHandle
:
:
AllowToCloseOnOwningThread
(
)
{
MOZ_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mStrongRef
)
{
mStrongRef
-
>
DoomTargetData
(
)
;
}
mStrongRef
=
nullptr
;
}
void
Context
:
:
ThreadsafeHandle
:
:
InvalidateAndAllowToCloseOnOwningThread
(
)
{
MOZ_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
if
(
mWeakRef
)
{
mWeakRef
-
>
Invalidate
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mStrongRef
)
;
}
void
Context
:
:
ThreadsafeHandle
:
:
ContextDestroyed
(
Context
&
aContext
)
{
MOZ_ASSERT
(
mOwningEventTarget
-
>
IsOnCurrentThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mStrongRef
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mWeakRef
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mWeakRef
=
=
&
aContext
)
;
mWeakRef
=
nullptr
;
}
SafeRefPtr
<
Context
>
Context
:
:
Create
(
SafeRefPtr
<
Manager
>
aManager
nsISerialEventTarget
*
aTarget
SafeRefPtr
<
Action
>
aInitAction
Maybe
<
Context
&
>
aOldContext
)
{
auto
context
=
MakeSafeRefPtr
<
Context
>
(
std
:
:
move
(
aManager
)
aTarget
std
:
:
move
(
aInitAction
)
)
;
context
-
>
Init
(
aOldContext
)
;
return
context
;
}
Context
:
:
Context
(
SafeRefPtr
<
Manager
>
aManager
nsISerialEventTarget
*
aTarget
SafeRefPtr
<
Action
>
aInitAction
)
:
mManager
(
std
:
:
move
(
aManager
)
)
mTarget
(
aTarget
)
mData
(
new
Data
(
aTarget
)
)
mState
(
STATE_CONTEXT_PREINIT
)
mOrphanedData
(
false
)
mInitAction
(
std
:
:
move
(
aInitAction
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mManager
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mTarget
)
;
}
void
Context
:
:
Dispatch
(
SafeRefPtr
<
Action
>
aAction
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aAction
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
!
=
STATE_CONTEXT_CANCELED
)
;
if
(
mState
=
=
STATE_CONTEXT_CANCELED
)
{
return
;
}
if
(
mState
=
=
STATE_CONTEXT_INIT
|
|
mState
=
=
STATE_CONTEXT_PREINIT
)
{
PendingAction
*
pending
=
mPendingActions
.
AppendElement
(
)
;
pending
-
>
mAction
=
std
:
:
move
(
aAction
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_CONTEXT_READY
)
;
DispatchAction
(
std
:
:
move
(
aAction
)
)
;
}
void
Context
:
:
CancelAll
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
if
(
mState
=
=
STATE_CONTEXT_PREINIT
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitRunnable
)
;
mInitAction
=
nullptr
;
}
else
if
(
mState
=
=
STATE_CONTEXT_INIT
)
{
mInitRunnable
-
>
Cancel
(
)
;
}
mState
=
STATE_CONTEXT_CANCELED
;
mPendingActions
.
Clear
(
)
;
for
(
auto
*
activity
:
mActivityList
.
ForwardRange
(
)
)
{
activity
-
>
Cancel
(
)
;
}
AllowToClose
(
)
;
}
bool
Context
:
:
IsCanceled
(
)
const
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
return
mState
=
=
STATE_CONTEXT_CANCELED
;
}
void
Context
:
:
Invalidate
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
mManager
-
>
NoteClosing
(
)
;
CancelAll
(
)
;
}
void
Context
:
:
AllowToClose
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
if
(
mThreadsafeHandle
)
{
mThreadsafeHandle
-
>
AllowToClose
(
)
;
}
}
void
Context
:
:
CancelForCacheId
(
CacheId
aCacheId
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
mPendingActions
.
RemoveElementsBy
(
[
aCacheId
]
(
const
auto
&
pendingAction
)
{
return
pendingAction
.
mAction
-
>
MatchesCacheId
(
aCacheId
)
;
}
)
;
for
(
auto
*
activity
:
mActivityList
.
ForwardRange
(
)
)
{
if
(
activity
-
>
MatchesCacheId
(
aCacheId
)
)
{
activity
-
>
Cancel
(
)
;
}
}
}
Context
:
:
~
Context
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mManager
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mData
)
;
if
(
mThreadsafeHandle
)
{
mThreadsafeHandle
-
>
ContextDestroyed
(
*
this
)
;
}
mManager
-
>
RemoveContext
(
*
this
)
;
if
(
mQuotaInfo
.
mDir
&
&
!
mOrphanedData
)
{
MOZ_ALWAYS_SUCCEEDS
(
DeleteMarkerFile
(
mQuotaInfo
)
)
;
}
if
(
mNextContext
)
{
mNextContext
-
>
Start
(
)
;
}
}
void
Context
:
:
Init
(
Maybe
<
Context
&
>
aOldContext
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
if
(
aOldContext
)
{
aOldContext
-
>
SetNextContext
(
SafeRefPtrFromThis
(
)
)
;
return
;
}
Start
(
)
;
}
void
Context
:
:
Start
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
if
(
mState
=
=
STATE_CONTEXT_CANCELED
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitRunnable
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitAction
)
;
mData
=
nullptr
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_CONTEXT_PREINIT
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mInitRunnable
)
;
mInitRunnable
=
new
QuotaInitRunnable
(
SafeRefPtrFromThis
(
)
mManager
.
clonePtr
(
)
mData
mTarget
std
:
:
move
(
mInitAction
)
)
;
mState
=
STATE_CONTEXT_INIT
;
nsresult
rv
=
mInitRunnable
-
>
Dispatch
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Failed
to
dispatch
QuotaInitRunnable
.
"
)
;
}
}
void
Context
:
:
DispatchAction
(
SafeRefPtr
<
Action
>
aAction
bool
aDoomData
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
auto
runnable
=
MakeSafeRefPtr
<
ActionRunnable
>
(
SafeRefPtrFromThis
(
)
mData
mTarget
std
:
:
move
(
aAction
)
mQuotaInfo
)
;
if
(
aDoomData
)
{
mData
=
nullptr
;
}
nsresult
rv
=
runnable
-
>
Dispatch
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
Failed
to
dispatch
ActionRunnable
to
target
thread
.
"
)
;
}
AddActivity
(
runnable
.
unsafeGetRawPtr
(
)
)
;
}
void
Context
:
:
OnQuotaInit
(
nsresult
aRv
const
QuotaInfo
&
aQuotaInfo
already_AddRefed
<
DirectoryLock
>
aDirectoryLock
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInitRunnable
)
;
mInitRunnable
=
nullptr
;
mQuotaInfo
=
aQuotaInfo
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDirectoryLock
)
;
mDirectoryLock
=
aDirectoryLock
;
if
(
NS_FAILED
(
aRv
)
)
{
mState
=
STATE_CONTEXT_CANCELED
;
}
if
(
mState
=
=
STATE_CONTEXT_CANCELED
)
{
for
(
uint32_t
i
=
0
;
i
<
mPendingActions
.
Length
(
)
;
+
+
i
)
{
mPendingActions
[
i
]
.
mAction
-
>
CompleteOnInitiatingThread
(
aRv
)
;
}
mPendingActions
.
Clear
(
)
;
mThreadsafeHandle
-
>
AllowToClose
(
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
STATE_CONTEXT_INIT
)
;
mState
=
STATE_CONTEXT_READY
;
for
(
uint32_t
i
=
0
;
i
<
mPendingActions
.
Length
(
)
;
+
+
i
)
{
DispatchAction
(
std
:
:
move
(
mPendingActions
[
i
]
.
mAction
)
)
;
}
mPendingActions
.
Clear
(
)
;
}
void
Context
:
:
AddActivity
(
Activity
*
aActivity
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aActivity
)
;
MOZ_ASSERT
(
!
mActivityList
.
Contains
(
aActivity
)
)
;
mActivityList
.
AppendElement
(
aActivity
)
;
}
void
Context
:
:
RemoveActivity
(
Activity
*
aActivity
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aActivity
)
;
MOZ_ALWAYS_TRUE
(
mActivityList
.
RemoveElement
(
aActivity
)
)
;
MOZ_ASSERT
(
!
mActivityList
.
Contains
(
aActivity
)
)
;
}
void
Context
:
:
NoteOrphanedData
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
mOrphanedData
=
true
;
}
SafeRefPtr
<
Context
:
:
ThreadsafeHandle
>
Context
:
:
CreateThreadsafeHandle
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
if
(
!
mThreadsafeHandle
)
{
mThreadsafeHandle
=
MakeSafeRefPtr
<
ThreadsafeHandle
>
(
SafeRefPtrFromThis
(
)
)
;
}
return
mThreadsafeHandle
.
clonePtr
(
)
;
}
void
Context
:
:
SetNextContext
(
SafeRefPtr
<
Context
>
aNextContext
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aNextContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mNextContext
)
;
mNextContext
=
std
:
:
move
(
aNextContext
)
;
}
void
Context
:
:
DoomTargetData
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Context
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mData
)
;
DispatchAction
(
MakeSafeRefPtr
<
NullAction
>
(
)
true
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mData
)
;
}
}
