#
ifndef
mozilla_dom_cache_CacheChild_h
#
define
mozilla_dom_cache_CacheChild_h
#
include
"
mozilla
/
dom
/
cache
/
ActorChild
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
PCacheChild
.
h
"
class
nsIAsyncInputStream
;
class
nsIGlobalObject
;
namespace
mozilla
{
namespace
dom
{
class
Promise
;
namespace
cache
{
class
Cache
;
class
CacheOpArgs
;
class
CacheChild
final
:
public
PCacheChild
public
ActorChild
{
friend
class
PCacheChild
;
public
:
class
MOZ_RAII
AutoLock
final
{
CacheChild
*
mActor
;
public
:
explicit
AutoLock
(
CacheChild
*
aActor
)
:
mActor
(
aActor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mActor
)
;
mActor
-
>
Lock
(
)
;
}
~
AutoLock
(
)
{
mActor
-
>
Unlock
(
)
;
}
}
;
CacheChild
(
)
;
~
CacheChild
(
)
;
void
SetListener
(
Cache
*
aListener
)
;
void
ClearListener
(
)
;
void
ExecuteOp
(
nsIGlobalObject
*
aGlobal
Promise
*
aPromise
nsISupports
*
aParent
const
CacheOpArgs
&
aArgs
)
;
void
StartDestroyFromListener
(
)
;
private
:
virtual
void
StartDestroy
(
)
override
;
virtual
void
ActorDestroy
(
ActorDestroyReason
aReason
)
override
;
PCacheOpChild
*
AllocPCacheOpChild
(
const
CacheOpArgs
&
aOpArgs
)
;
bool
DeallocPCacheOpChild
(
PCacheOpChild
*
aActor
)
;
void
NoteDeletedActor
(
)
;
void
MaybeFlushDelayedDestroy
(
)
;
void
Lock
(
)
;
void
Unlock
(
)
;
Cache
*
MOZ_NON_OWNING_REF
mListener
;
uint32_t
mNumChildActors
;
bool
mDelayedDestroy
;
bool
mLocked
;
NS_DECL_OWNINGTHREAD
}
;
}
}
}
#
endif
