#
ifndef
mozilla_dom_cache_Context_h
#
define
mozilla_dom_cache_Context_h
#
include
"
mozilla
/
dom
/
SafeRefPtr
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Types
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTObserverArray
.
h
"
class
nsIEventTarget
;
class
nsIThread
;
namespace
mozilla
{
namespace
dom
{
namespace
quota
{
class
DirectoryLock
;
}
namespace
cache
{
class
Action
;
class
Manager
;
class
Context
final
:
public
SafeRefCounted
<
Context
>
{
using
DirectoryLock
=
mozilla
:
:
dom
:
:
quota
:
:
DirectoryLock
;
public
:
class
ThreadsafeHandle
final
:
public
AtomicSafeRefCounted
<
ThreadsafeHandle
>
{
friend
class
Context
;
public
:
explicit
ThreadsafeHandle
(
SafeRefPtr
<
Context
>
aContext
)
;
~
ThreadsafeHandle
(
)
;
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
cache
:
:
Context
:
:
ThreadsafeHandle
)
void
AllowToClose
(
)
;
void
InvalidateAndAllowToClose
(
)
;
private
:
void
AllowToCloseOnOwningThread
(
)
;
void
InvalidateAndAllowToCloseOnOwningThread
(
)
;
void
ContextDestroyed
(
Context
&
aContext
)
;
SafeRefPtr
<
Context
>
mStrongRef
;
Context
*
mWeakRef
;
nsCOMPtr
<
nsISerialEventTarget
>
mOwningEventTarget
;
}
;
class
Activity
{
public
:
virtual
void
Cancel
(
)
=
0
;
virtual
bool
MatchesCacheId
(
CacheId
aCacheId
)
const
=
0
;
}
;
static
SafeRefPtr
<
Context
>
Create
(
SafeRefPtr
<
Manager
>
aManager
nsISerialEventTarget
*
aTarget
SafeRefPtr
<
Action
>
aInitAction
Maybe
<
Context
&
>
aOldContext
)
;
void
Dispatch
(
SafeRefPtr
<
Action
>
aAction
)
;
Maybe
<
DirectoryLock
&
>
MaybeDirectoryLockRef
(
)
const
;
void
CancelAll
(
)
;
bool
IsCanceled
(
)
const
;
void
Invalidate
(
)
;
void
AllowToClose
(
)
;
void
CancelForCacheId
(
CacheId
aCacheId
)
;
void
AddActivity
(
Activity
&
aActivity
)
;
void
RemoveActivity
(
Activity
&
aActivity
)
;
void
NoteOrphanedData
(
)
;
private
:
class
Data
;
class
QuotaInitRunnable
;
class
ActionRunnable
;
enum
State
{
STATE_CONTEXT_PREINIT
STATE_CONTEXT_INIT
STATE_CONTEXT_READY
STATE_CONTEXT_CANCELED
}
;
struct
PendingAction
{
nsCOMPtr
<
nsIEventTarget
>
mTarget
;
SafeRefPtr
<
Action
>
mAction
;
}
;
void
Init
(
Maybe
<
Context
&
>
aOldContext
)
;
void
Start
(
)
;
void
DispatchAction
(
SafeRefPtr
<
Action
>
aAction
bool
aDoomData
=
false
)
;
void
OnQuotaInit
(
nsresult
aRv
const
Maybe
<
ClientMetadata
>
&
aClientMetadata
already_AddRefed
<
DirectoryLock
>
aDirectoryLock
)
;
SafeRefPtr
<
ThreadsafeHandle
>
CreateThreadsafeHandle
(
)
;
void
SetNextContext
(
SafeRefPtr
<
Context
>
aNextContext
)
;
void
DoomTargetData
(
)
;
SafeRefPtr
<
Manager
>
mManager
;
nsCOMPtr
<
nsISerialEventTarget
>
mTarget
;
RefPtr
<
Data
>
mData
;
State
mState
;
bool
mOrphanedData
;
Maybe
<
ClientMetadata
>
mClientMetadata
;
RefPtr
<
QuotaInitRunnable
>
mInitRunnable
;
SafeRefPtr
<
Action
>
mInitAction
;
nsTArray
<
PendingAction
>
mPendingActions
;
nsTObserverArray
<
NotNull
<
Activity
*
>
>
mActivityList
;
SafeRefPtr
<
ThreadsafeHandle
>
mThreadsafeHandle
;
RefPtr
<
DirectoryLock
>
mDirectoryLock
;
SafeRefPtr
<
Context
>
mNextContext
;
public
:
Context
(
SafeRefPtr
<
Manager
>
aManager
nsISerialEventTarget
*
aTarget
SafeRefPtr
<
Action
>
aInitAction
)
;
~
Context
(
)
;
NS_DECL_OWNINGTHREAD
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
cache
:
:
Context
)
}
;
}
}
}
#
endif
