#
include
"
mozilla
/
dom
/
cache
/
DBSchema
.
h
"
#
include
"
ipc
/
IPCMessageUtils
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
dom
/
HeadersBinding
.
h
"
#
include
"
mozilla
/
dom
/
InternalHeaders
.
h
"
#
include
"
mozilla
/
dom
/
InternalResponse
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
mozilla
/
dom
/
ResponseBinding
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheCommon
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheTypes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
SavedTypes
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Types
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
TypeUtils
.
h
"
#
include
"
mozilla
/
net
/
MozURL
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
StaticPrefs_extensions
.
h
"
#
include
"
mozIStorageConnection
.
h
"
#
include
"
mozIStorageStatement
.
h
"
#
include
"
mozStorageHelper
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsHttp
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsICryptoHash
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
dom
:
:
cache
:
:
db
{
const
int32_t
kFirstShippedSchemaVersion
=
15
;
namespace
{
const
int32_t
kHackyDowngradeSchemaVersion
=
25
;
const
int32_t
kHackyPaddingSizePresentVersion
=
27
;
const
int32_t
kLatestSchemaVersion
=
27
;
const
char
*
const
kTableCaches
=
"
CREATE
TABLE
caches
(
"
"
id
INTEGER
NOT
NULL
PRIMARY
KEY
AUTOINCREMENT
"
"
)
"
;
const
char
*
const
kTableSecurityInfo
=
"
CREATE
TABLE
security_info
(
"
"
id
INTEGER
NOT
NULL
PRIMARY
KEY
"
"
hash
BLOB
NOT
NULL
"
"
data
BLOB
NOT
NULL
"
"
refcount
INTEGER
NOT
NULL
"
"
)
"
;
const
char
*
const
kIndexSecurityInfoHash
=
"
CREATE
INDEX
security_info_hash_index
ON
security_info
(
hash
)
"
;
const
char
*
const
kTableEntries
=
"
CREATE
TABLE
entries
(
"
"
id
INTEGER
NOT
NULL
PRIMARY
KEY
"
"
request_method
TEXT
NOT
NULL
"
"
request_url_no_query
TEXT
NOT
NULL
"
"
request_url_no_query_hash
BLOB
NOT
NULL
"
"
request_url_query
TEXT
NOT
NULL
"
"
request_url_query_hash
BLOB
NOT
NULL
"
"
request_referrer
TEXT
NOT
NULL
"
"
request_headers_guard
INTEGER
NOT
NULL
"
"
request_mode
INTEGER
NOT
NULL
"
"
request_credentials
INTEGER
NOT
NULL
"
"
request_contentpolicytype
INTEGER
NOT
NULL
"
"
request_cache
INTEGER
NOT
NULL
"
"
request_body_id
TEXT
NULL
"
"
response_type
INTEGER
NOT
NULL
"
"
response_status
INTEGER
NOT
NULL
"
"
response_status_text
TEXT
NOT
NULL
"
"
response_headers_guard
INTEGER
NOT
NULL
"
"
response_body_id
TEXT
NULL
"
"
response_security_info_id
INTEGER
NULL
REFERENCES
security_info
(
id
)
"
"
response_principal_info
TEXT
NOT
NULL
"
"
cache_id
INTEGER
NOT
NULL
REFERENCES
caches
(
id
)
ON
DELETE
CASCADE
"
"
request_redirect
INTEGER
NOT
NULL
"
"
request_referrer_policy
INTEGER
NOT
NULL
"
"
request_integrity
TEXT
NOT
NULL
"
"
request_url_fragment
TEXT
NOT
NULL
"
"
response_padding_size
INTEGER
NULL
"
"
)
"
;
const
char
*
const
kIndexEntriesRequest
=
"
CREATE
INDEX
entries_request_match_index
"
"
ON
entries
(
cache_id
request_url_no_query_hash
"
"
request_url_query_hash
)
"
;
const
char
*
const
kTableRequestHeaders
=
"
CREATE
TABLE
request_headers
(
"
"
name
TEXT
NOT
NULL
"
"
value
TEXT
NOT
NULL
"
"
entry_id
INTEGER
NOT
NULL
REFERENCES
entries
(
id
)
ON
DELETE
CASCADE
"
"
)
"
;
const
char
*
const
kTableResponseHeaders
=
"
CREATE
TABLE
response_headers
(
"
"
name
TEXT
NOT
NULL
"
"
value
TEXT
NOT
NULL
"
"
entry_id
INTEGER
NOT
NULL
REFERENCES
entries
(
id
)
ON
DELETE
CASCADE
"
"
)
"
;
const
char
*
const
kIndexResponseHeadersName
=
"
CREATE
INDEX
response_headers_name_index
"
"
ON
response_headers
(
name
)
"
;
const
char
*
const
kTableResponseUrlList
=
"
CREATE
TABLE
response_url_list
(
"
"
url
TEXT
NOT
NULL
"
"
entry_id
INTEGER
NOT
NULL
REFERENCES
entries
(
id
)
ON
DELETE
CASCADE
"
"
)
"
;
const
char
*
const
kTableStorage
=
"
CREATE
TABLE
storage
(
"
"
namespace
INTEGER
NOT
NULL
"
"
key
BLOB
NULL
"
"
cache_id
INTEGER
NOT
NULL
REFERENCES
caches
(
id
)
"
"
PRIMARY
KEY
(
namespace
key
)
"
"
)
"
;
const
int32_t
kMaxEntriesPerStatement
=
255
;
const
uint32_t
kPageSize
=
4
*
1024
;
const
uint32_t
kGrowthSize
=
32
*
1024
;
const
uint32_t
kGrowthPages
=
kGrowthSize
/
kPageSize
;
static_assert
(
kGrowthSize
%
kPageSize
=
=
0
"
Growth
size
must
be
multiple
of
page
size
"
)
;
const
int32_t
kMaxFreePages
=
kGrowthPages
;
const
uint32_t
kWalAutoCheckpointSize
=
512
*
1024
;
const
uint32_t
kWalAutoCheckpointPages
=
kWalAutoCheckpointSize
/
kPageSize
;
static_assert
(
kWalAutoCheckpointSize
%
kPageSize
=
=
0
"
WAL
checkpoint
size
must
be
multiple
of
page
size
"
)
;
}
static_assert
(
int
(
HeadersGuardEnum
:
:
None
)
=
=
0
&
&
int
(
HeadersGuardEnum
:
:
Request
)
=
=
1
&
&
int
(
HeadersGuardEnum
:
:
Request_no_cors
)
=
=
2
&
&
int
(
HeadersGuardEnum
:
:
Response
)
=
=
3
&
&
int
(
HeadersGuardEnum
:
:
Immutable
)
=
=
4
&
&
HeadersGuardEnumValues
:
:
Count
=
=
5
"
HeadersGuardEnum
values
are
as
expected
"
)
;
static_assert
(
int
(
ReferrerPolicy
:
:
_empty
)
=
=
0
&
&
int
(
ReferrerPolicy
:
:
No_referrer
)
=
=
1
&
&
int
(
ReferrerPolicy
:
:
No_referrer_when_downgrade
)
=
=
2
&
&
int
(
ReferrerPolicy
:
:
Origin
)
=
=
3
&
&
int
(
ReferrerPolicy
:
:
Origin_when_cross_origin
)
=
=
4
&
&
int
(
ReferrerPolicy
:
:
Unsafe_url
)
=
=
5
&
&
int
(
ReferrerPolicy
:
:
Same_origin
)
=
=
6
&
&
int
(
ReferrerPolicy
:
:
Strict_origin
)
=
=
7
&
&
int
(
ReferrerPolicy
:
:
Strict_origin_when_cross_origin
)
=
=
8
&
&
ReferrerPolicyValues
:
:
Count
=
=
9
"
ReferrerPolicy
values
are
as
expected
"
)
;
static_assert
(
int
(
RequestMode
:
:
Same_origin
)
=
=
0
&
&
int
(
RequestMode
:
:
No_cors
)
=
=
1
&
&
int
(
RequestMode
:
:
Cors
)
=
=
2
&
&
int
(
RequestMode
:
:
Navigate
)
=
=
3
&
&
RequestModeValues
:
:
Count
=
=
4
"
RequestMode
values
are
as
expected
"
)
;
static_assert
(
int
(
RequestCredentials
:
:
Omit
)
=
=
0
&
&
int
(
RequestCredentials
:
:
Same_origin
)
=
=
1
&
&
int
(
RequestCredentials
:
:
Include
)
=
=
2
&
&
RequestCredentialsValues
:
:
Count
=
=
3
"
RequestCredentials
values
are
as
expected
"
)
;
static_assert
(
int
(
RequestCache
:
:
Default
)
=
=
0
&
&
int
(
RequestCache
:
:
No_store
)
=
=
1
&
&
int
(
RequestCache
:
:
Reload
)
=
=
2
&
&
int
(
RequestCache
:
:
No_cache
)
=
=
3
&
&
int
(
RequestCache
:
:
Force_cache
)
=
=
4
&
&
int
(
RequestCache
:
:
Only_if_cached
)
=
=
5
&
&
RequestCacheValues
:
:
Count
=
=
6
"
RequestCache
values
are
as
expected
"
)
;
static_assert
(
int
(
RequestRedirect
:
:
Follow
)
=
=
0
&
&
int
(
RequestRedirect
:
:
Error
)
=
=
1
&
&
int
(
RequestRedirect
:
:
Manual
)
=
=
2
&
&
RequestRedirectValues
:
:
Count
=
=
3
"
RequestRedirect
values
are
as
expected
"
)
;
static_assert
(
int
(
ResponseType
:
:
Basic
)
=
=
0
&
&
int
(
ResponseType
:
:
Cors
)
=
=
1
&
&
int
(
ResponseType
:
:
Default
)
=
=
2
&
&
int
(
ResponseType
:
:
Error
)
=
=
3
&
&
int
(
ResponseType
:
:
Opaque
)
=
=
4
&
&
int
(
ResponseType
:
:
Opaqueredirect
)
=
=
5
&
&
ResponseTypeValues
:
:
Count
=
=
6
"
ResponseType
values
are
as
expected
"
)
;
static_assert
(
DEFAULT_NAMESPACE
=
=
0
&
&
CHROME_ONLY_NAMESPACE
=
=
1
&
&
NUMBER_OF_NAMESPACES
=
=
2
"
Namespace
values
are
as
expected
"
)
;
static_assert
(
nsIContentPolicy
:
:
TYPE_INVALID
=
=
0
&
&
nsIContentPolicy
:
:
TYPE_OTHER
=
=
1
&
&
nsIContentPolicy
:
:
TYPE_SCRIPT
=
=
2
&
&
nsIContentPolicy
:
:
TYPE_IMAGE
=
=
3
&
&
nsIContentPolicy
:
:
TYPE_STYLESHEET
=
=
4
&
&
nsIContentPolicy
:
:
TYPE_OBJECT
=
=
5
&
&
nsIContentPolicy
:
:
TYPE_DOCUMENT
=
=
6
&
&
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
=
=
7
&
&
nsIContentPolicy
:
:
TYPE_PING
=
=
10
&
&
nsIContentPolicy
:
:
TYPE_XMLHTTPREQUEST
=
=
11
&
&
nsIContentPolicy
:
:
TYPE_OBJECT_SUBREQUEST
=
=
12
&
&
nsIContentPolicy
:
:
TYPE_DTD
=
=
13
&
&
nsIContentPolicy
:
:
TYPE_FONT
=
=
14
&
&
nsIContentPolicy
:
:
TYPE_MEDIA
=
=
15
&
&
nsIContentPolicy
:
:
TYPE_WEBSOCKET
=
=
16
&
&
nsIContentPolicy
:
:
TYPE_CSP_REPORT
=
=
17
&
&
nsIContentPolicy
:
:
TYPE_XSLT
=
=
18
&
&
nsIContentPolicy
:
:
TYPE_BEACON
=
=
19
&
&
nsIContentPolicy
:
:
TYPE_FETCH
=
=
20
&
&
nsIContentPolicy
:
:
TYPE_IMAGESET
=
=
21
&
&
nsIContentPolicy
:
:
TYPE_WEB_MANIFEST
=
=
22
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
=
=
23
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
=
=
24
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
=
=
25
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_EMBED
=
=
26
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_OBJECT
=
=
27
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
=
=
28
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
=
=
29
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
=
=
30
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
=
=
31
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_TRACK
=
=
32
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST
=
=
33
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_EVENTSOURCE
=
=
34
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
=
=
35
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
=
=
36
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
=
=
37
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
=
=
38
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET
=
=
39
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
=
=
40
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
=
=
41
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS
=
=
42
&
&
nsIContentPolicy
:
:
TYPE_SAVEAS_DOWNLOAD
=
=
43
&
&
nsIContentPolicy
:
:
TYPE_SPECULATIVE
=
=
44
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
=
=
45
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE_PRELOAD
=
=
46
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_DTD
=
=
47
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_FORCE_ALLOWED_DTD
=
=
48
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIOWORKLET
=
=
49
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_PAINTWORKLET
=
=
50
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_FONT_PRELOAD
=
=
51
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_CHROMEUTILS_COMPILED_SCRIPT
=
=
52
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME_MESSAGEMANAGER_SCRIPT
=
=
53
&
&
nsIContentPolicy
:
:
TYPE_INTERNAL_FETCH_PRELOAD
=
=
54
"
nsContentPolicyType
values
are
as
expected
"
)
;
namespace
{
typedef
int32_t
EntryId
;
struct
IdCount
{
explicit
IdCount
(
int32_t
aId
)
:
mId
(
aId
)
mCount
(
1
)
{
}
int32_t
mId
;
int32_t
mCount
;
}
;
using
EntryIds
=
AutoTArray
<
EntryId
256
>
;
static
Result
<
EntryIds
nsresult
>
QueryAll
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
)
;
static
Result
<
EntryIds
nsresult
>
QueryCache
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
CacheRequest
&
aRequest
const
CacheQueryParams
&
aParams
uint32_t
aMaxResults
=
UINT32_MAX
)
;
static
Result
<
bool
nsresult
>
MatchByVaryHeader
(
mozIStorageConnection
&
aConn
const
CacheRequest
&
aRequest
EntryId
entryId
)
;
static
nsresult
DeleteEntries
(
mozIStorageConnection
&
aConn
const
nsTArray
<
EntryId
>
&
aEntryIdList
nsTArray
<
nsID
>
&
aDeletedBodyIdListOut
nsTArray
<
IdCount
>
&
aDeletedSecurityIdListOut
int64_t
*
aDeletedPaddingSizeOut
uint32_t
aPos
=
0
int32_t
aLen
=
-
1
)
;
static
Result
<
int32_t
nsresult
>
InsertSecurityInfo
(
mozIStorageConnection
&
aConn
nsICryptoHash
&
aCrypto
const
nsACString
&
aData
)
;
static
nsresult
DeleteSecurityInfo
(
mozIStorageConnection
&
aConn
int32_t
aId
int32_t
aCount
)
;
static
nsresult
DeleteSecurityInfoList
(
mozIStorageConnection
&
aConn
const
nsTArray
<
IdCount
>
&
aDeletedStorageIdList
)
;
static
nsresult
InsertEntry
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
CacheRequest
&
aRequest
const
nsID
*
aRequestBodyId
const
CacheResponse
&
aResponse
const
nsID
*
aResponseBodyId
)
;
static
Result
<
SavedResponse
nsresult
>
ReadResponse
(
mozIStorageConnection
&
aConn
EntryId
aEntryId
)
;
static
Result
<
SavedRequest
nsresult
>
ReadRequest
(
mozIStorageConnection
&
aConn
EntryId
aEntryId
)
;
static
void
AppendListParamsToQuery
(
nsACString
&
aQuery
const
nsTArray
<
EntryId
>
&
aEntryIdList
uint32_t
aPos
int32_t
aLen
)
;
static
nsresult
BindListParamsToQuery
(
mozIStorageStatement
&
aState
const
nsTArray
<
EntryId
>
&
aEntryIdList
uint32_t
aPos
int32_t
aLen
)
;
static
nsresult
BindId
(
mozIStorageStatement
&
aState
const
nsACString
&
aName
const
nsID
*
aId
)
;
static
Result
<
nsID
nsresult
>
ExtractId
(
mozIStorageStatement
&
aState
uint32_t
aPos
)
;
static
Result
<
MovingNotNull
<
nsCOMPtr
<
mozIStorageStatement
>
>
nsresult
>
CreateAndBindKeyStatement
(
mozIStorageConnection
&
aConn
const
char
*
aQueryFormat
const
nsAString
&
aKey
)
;
static
Result
<
nsAutoCString
nsresult
>
HashCString
(
nsICryptoHash
&
aCrypto
const
nsACString
&
aIn
)
;
Result
<
int32_t
nsresult
>
GetEffectiveSchemaVersion
(
mozIStorageConnection
&
aConn
)
;
nsresult
Validate
(
mozIStorageConnection
&
aConn
)
;
nsresult
Migrate
(
mozIStorageConnection
&
aConn
)
;
}
class
MOZ_RAII
AutoDisableForeignKeyChecking
{
public
:
explicit
AutoDisableForeignKeyChecking
(
mozIStorageConnection
*
aConn
)
:
mConn
(
aConn
)
mForeignKeyCheckingDisabled
(
false
)
{
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
*
mConn
"
PRAGMA
foreign_keys
;
"
_ns
)
QM_VOID
)
;
int32_t
mode
;
nsresult
rv
=
state
-
>
GetInt32
(
0
&
mode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
mode
)
{
nsresult
rv
=
mConn
-
>
ExecuteSimpleSQL
(
"
PRAGMA
foreign_keys
=
OFF
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
mForeignKeyCheckingDisabled
=
true
;
}
}
~
AutoDisableForeignKeyChecking
(
)
{
if
(
mForeignKeyCheckingDisabled
)
{
nsresult
rv
=
mConn
-
>
ExecuteSimpleSQL
(
"
PRAGMA
foreign_keys
=
ON
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
}
private
:
nsCOMPtr
<
mozIStorageConnection
>
mConn
;
bool
mForeignKeyCheckingDisabled
;
}
;
nsresult
CreateOrMigrateSchema
(
mozIStorageConnection
&
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
int32_t
schemaVersion
;
CACHE_TRY_UNWRAP
(
schemaVersion
GetEffectiveSchemaVersion
(
aConn
)
)
;
if
(
schemaVersion
=
=
kLatestSchemaVersion
)
{
nsresult
rv
=
Validate
(
aConn
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
AutoDisableForeignKeyChecking
restoreForeignKeyChecking
(
&
aConn
)
;
mozStorageTransaction
trans
(
&
aConn
false
mozIStorageConnection
:
:
TRANSACTION_IMMEDIATE
)
;
bool
needVacuum
=
false
;
if
(
schemaVersion
)
{
nsresult
rv
=
Migrate
(
aConn
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
needVacuum
=
true
;
}
else
{
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kTableCaches
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kTableSecurityInfo
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kIndexSecurityInfoHash
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kTableEntries
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kIndexEntriesRequest
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kTableRequestHeaders
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kTableResponseHeaders
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kIndexResponseHeadersName
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kTableResponseUrlList
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kTableStorage
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
kHackyDowngradeSchemaVersion
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CACHE_TRY_UNWRAP
(
schemaVersion
GetEffectiveSchemaVersion
(
aConn
)
)
;
}
nsresult
rv
=
Validate
(
aConn
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
trans
.
Commit
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
needVacuum
)
{
aConn
.
ExecuteSimpleSQL
(
"
VACUUM
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
rv
;
}
nsresult
InitializeConnection
(
mozIStorageConnection
&
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsPrintfCString
pragmas
(
"
PRAGMA
page_size
=
%
u
;
"
"
PRAGMA
auto_vacuum
=
INCREMENTAL
;
"
"
PRAGMA
foreign_keys
=
ON
;
"
kPageSize
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
pragmas
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetGrowthIncrement
(
kGrowthSize
"
"
_ns
)
;
if
(
rv
=
=
NS_ERROR_FILE_TOO_BIG
)
{
NS_WARNING
(
"
Not
enough
disk
space
to
set
sqlite
growth
increment
.
"
)
;
rv
=
NS_OK
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsPrintfCString
wal
(
"
PRAGMA
wal_autocheckpoint
=
%
u
;
"
"
PRAGMA
journal_size_limit
=
%
u
;
"
"
PRAGMA
journal_mode
=
WAL
;
"
kWalAutoCheckpointPages
kWalAutoCheckpointSize
)
;
rv
=
aConn
.
ExecuteSimpleSQL
(
wal
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifdef
DEBUG
{
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
aConn
"
PRAGMA
auto_vacuum
;
"
_ns
)
)
;
int32_t
mode
;
rv
=
state
-
>
GetInt32
(
0
&
mode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
mode
!
=
2
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
#
endif
return
NS_OK
;
}
Result
<
CacheId
nsresult
>
CreateCacheId
(
mozIStorageConnection
&
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
"
INSERT
INTO
caches
DEFAULT
VALUES
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
<
quota
:
:
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
aConn
"
SELECT
last_insert_rowid
(
)
"
_ns
)
)
;
CACHE_TRY
(
OkIf
(
state
)
Err
(
NS_ERROR_UNEXPECTED
)
)
;
CacheId
id
;
rv
=
state
-
>
GetInt64
(
0
&
id
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
id
;
}
Result
<
DeletionInfo
nsresult
>
DeleteCacheId
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
matches
QueryAll
(
aConn
aCacheId
)
)
;
AutoTArray
<
nsID
16
>
deletedBodyIdList
;
AutoTArray
<
IdCount
16
>
deletedSecurityIdList
;
int64_t
deletedPaddingSize
=
0
;
nsresult
rv
=
DeleteEntries
(
aConn
matches
deletedBodyIdList
deletedSecurityIdList
&
deletedPaddingSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
DeleteSecurityInfoList
(
aConn
deletedSecurityIdList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
"
DELETE
FROM
caches
WHERE
id
=
:
id
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt64ByName
(
"
id
"
_ns
aCacheId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
DeletionInfo
{
std
:
:
move
(
deletedBodyIdList
)
deletedPaddingSize
}
;
}
Result
<
AutoTArray
<
CacheId
8
>
nsresult
>
FindOrphanedCacheIds
(
mozIStorageConnection
&
aConn
)
{
CACHE_TRY_INSPECT
(
const
auto
&
state
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
mozIStorageStatement
>
aConn
CreateStatement
"
SELECT
id
FROM
caches
"
"
WHERE
id
NOT
IN
(
SELECT
cache_id
from
storage
)
;
"
_ns
)
)
;
CACHE_TRY_RETURN
(
(
quota
:
:
CollectElementsWhileHasResultTyped
<
AutoTArray
<
CacheId
8
>
>
(
*
state
[
]
(
auto
&
stmt
)
{
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
stmt
GetInt64
0
)
)
;
}
)
)
)
;
}
Result
<
int64_t
nsresult
>
FindOverallPaddingSize
(
mozIStorageConnection
&
aConn
)
{
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
"
SELECT
response_padding_size
FROM
entries
"
"
WHERE
response_padding_size
IS
NOT
NULL
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
int64_t
overallPaddingSize
=
0
;
CACHE_TRY
(
quota
:
:
CollectWhileHasResult
(
*
state
[
&
overallPaddingSize
]
(
auto
&
stmt
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY_INSPECT
(
const
int64_t
&
padding_size
MOZ_TO_RESULT_INVOKE
(
stmt
GetInt64
0
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
padding_size
>
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
INT64_MAX
-
padding_size
>
=
overallPaddingSize
)
;
overallPaddingSize
+
=
padding_size
;
return
Ok
{
}
;
}
)
)
;
return
overallPaddingSize
;
}
Result
<
nsTArray
<
nsID
>
nsresult
>
GetKnownBodyIds
(
mozIStorageConnection
&
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
SELECT
request_body_id
response_body_id
FROM
entries
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
AutoTArray
<
nsID
64
>
idList
;
CACHE_TRY
(
quota
:
:
CollectWhileHasResult
(
*
state
[
&
idList
]
(
auto
&
stmt
)
-
>
Result
<
Ok
nsresult
>
{
for
(
uint32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
CACHE_TRY_INSPECT
(
const
bool
&
isNull
MOZ_TO_RESULT_INVOKE
(
stmt
GetIsNull
i
)
)
;
if
(
!
isNull
)
{
CACHE_TRY_INSPECT
(
const
auto
&
id
ExtractId
(
stmt
i
)
)
;
idList
.
AppendElement
(
id
)
;
}
}
return
Ok
{
}
;
}
)
)
;
return
std
:
:
move
(
idList
)
;
}
Result
<
Maybe
<
SavedResponse
>
nsresult
>
CacheMatch
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
CacheRequest
&
aRequest
const
CacheQueryParams
&
aParams
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
AutoTArray
<
EntryId
1
>
matches
;
CACHE_TRY_UNWRAP
(
matches
QueryCache
(
aConn
aCacheId
aRequest
aParams
1
)
)
;
if
(
matches
.
IsEmpty
(
)
)
{
return
Maybe
<
SavedResponse
>
(
)
;
}
SavedResponse
response
;
CACHE_TRY_UNWRAP
(
response
ReadResponse
(
aConn
matches
[
0
]
)
)
;
response
.
mCacheId
=
aCacheId
;
return
Some
(
response
)
;
}
Result
<
nsTArray
<
SavedResponse
>
nsresult
>
CacheMatchAll
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
Maybe
<
CacheRequest
>
&
aMaybeRequest
const
CacheQueryParams
&
aParams
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
EntryIds
matches
;
if
(
aMaybeRequest
.
isNothing
(
)
)
{
CACHE_TRY_UNWRAP
(
matches
QueryAll
(
aConn
aCacheId
)
)
;
}
else
{
CACHE_TRY_UNWRAP
(
matches
QueryCache
(
aConn
aCacheId
aMaybeRequest
.
ref
(
)
aParams
)
)
;
}
nsTArray
<
SavedResponse
>
savedResponses
;
for
(
const
auto
match
:
matches
)
{
SavedResponse
savedResponse
;
CACHE_TRY_UNWRAP
(
savedResponse
ReadResponse
(
aConn
match
)
)
;
savedResponse
.
mCacheId
=
aCacheId
;
savedResponses
.
AppendElement
(
savedResponse
)
;
}
return
savedResponses
;
}
Result
<
DeletionInfo
nsresult
>
CachePut
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
CacheRequest
&
aRequest
const
nsID
*
aRequestBodyId
const
CacheResponse
&
aResponse
const
nsID
*
aResponseBodyId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
matches
QueryCache
(
aConn
aCacheId
aRequest
CacheQueryParams
(
false
false
false
false
u
"
"
_ns
)
)
)
;
nsTArray
<
nsID
>
deletedBodyIdList
;
AutoTArray
<
IdCount
16
>
deletedSecurityIdList
;
int64_t
deletedPaddingSize
=
0
;
nsresult
rv
=
DeleteEntries
(
aConn
matches
deletedBodyIdList
deletedSecurityIdList
&
deletedPaddingSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
InsertEntry
(
aConn
aCacheId
aRequest
aRequestBodyId
aResponse
aResponseBodyId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
DeleteSecurityInfoList
(
aConn
deletedSecurityIdList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
DeletionInfo
{
std
:
:
move
(
deletedBodyIdList
)
deletedPaddingSize
}
;
}
Result
<
Maybe
<
DeletionInfo
>
nsresult
>
CacheDelete
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
CacheRequest
&
aRequest
const
CacheQueryParams
&
aParams
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
matches
QueryCache
(
aConn
aCacheId
aRequest
aParams
)
)
;
if
(
matches
.
IsEmpty
(
)
)
{
return
Maybe
<
DeletionInfo
>
(
)
;
}
nsTArray
<
nsID
>
deletedBodyIdList
;
AutoTArray
<
IdCount
16
>
deletedSecurityIdList
;
int64_t
deletedPaddingSize
=
0
;
nsresult
rv
=
DeleteEntries
(
aConn
matches
deletedBodyIdList
deletedSecurityIdList
&
deletedPaddingSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
DeleteSecurityInfoList
(
aConn
deletedSecurityIdList
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
Some
(
DeletionInfo
{
std
:
:
move
(
deletedBodyIdList
)
deletedPaddingSize
}
)
;
}
Result
<
nsTArray
<
SavedRequest
>
nsresult
>
CacheKeys
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
Maybe
<
CacheRequest
>
&
aMaybeRequest
const
CacheQueryParams
&
aParams
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
EntryIds
matches
;
if
(
aMaybeRequest
.
isNothing
(
)
)
{
CACHE_TRY_UNWRAP
(
matches
QueryAll
(
aConn
aCacheId
)
)
;
}
else
{
CACHE_TRY_UNWRAP
(
matches
QueryCache
(
aConn
aCacheId
aMaybeRequest
.
ref
(
)
aParams
)
)
;
}
nsTArray
<
SavedRequest
>
savedRequests
;
for
(
const
auto
match
:
matches
)
{
SavedRequest
savedRequest
;
CACHE_TRY_UNWRAP
(
savedRequest
ReadRequest
(
aConn
match
)
)
;
savedRequest
.
mCacheId
=
aCacheId
;
savedRequests
.
AppendElement
(
savedRequest
)
;
}
return
savedRequests
;
}
Result
<
Maybe
<
SavedResponse
>
nsresult
>
StorageMatch
(
mozIStorageConnection
&
aConn
Namespace
aNamespace
const
CacheRequest
&
aRequest
const
CacheQueryParams
&
aParams
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
;
if
(
!
aParams
.
cacheName
(
)
.
EqualsLiteral
(
"
"
)
)
{
Maybe
<
CacheId
>
maybeCacheId
;
CACHE_TRY_UNWRAP
(
maybeCacheId
StorageGetCacheId
(
aConn
aNamespace
aParams
.
cacheName
(
)
)
)
;
if
(
maybeCacheId
.
isNothing
(
)
)
{
return
Maybe
<
SavedResponse
>
(
)
;
}
return
CacheMatch
(
aConn
maybeCacheId
.
ref
(
)
aRequest
aParams
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
"
SELECT
cache_id
FROM
storage
WHERE
"
"
namespace
=
:
namespace
ORDER
BY
rowid
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
namespace
"
_ns
aNamespace
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_INSPECT
(
const
auto
&
cacheIdList
(
quota
:
:
CollectElementsWhileHasResultTyped
<
AutoTArray
<
CacheId
32
>
>
(
*
state
[
]
(
auto
&
stmt
)
{
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
stmt
GetInt64
0
)
)
;
}
)
)
)
;
for
(
const
auto
cacheId
:
cacheIdList
)
{
Maybe
<
SavedResponse
>
matchedResponse
;
CACHE_TRY_UNWRAP
(
matchedResponse
CacheMatch
(
aConn
cacheId
aRequest
aParams
)
)
;
if
(
matchedResponse
.
isSome
(
)
)
{
return
matchedResponse
;
}
}
return
Maybe
<
SavedResponse
>
(
)
;
}
Result
<
Maybe
<
CacheId
>
nsresult
>
StorageGetCacheId
(
mozIStorageConnection
&
aConn
Namespace
aNamespace
const
nsAString
&
aKey
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
const
char
*
query
=
"
SELECT
cache_id
FROM
storage
"
"
WHERE
namespace
=
:
namespace
AND
%
s
"
"
ORDER
BY
rowid
;
"
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
CACHE_TRY_UNWRAP
(
state
CreateAndBindKeyStatement
(
aConn
query
aKey
)
)
;
nsresult
rv
=
state
-
>
BindInt32ByName
(
"
namespace
"
_ns
aNamespace
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
bool
hasMoreData
=
false
;
rv
=
state
-
>
ExecuteStep
(
&
hasMoreData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
if
(
!
hasMoreData
)
{
return
Maybe
<
CacheId
>
(
)
;
}
CacheId
cacheId
;
rv
=
state
-
>
GetInt64
(
0
&
cacheId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
Some
(
cacheId
)
;
}
nsresult
StoragePutCache
(
mozIStorageConnection
&
aConn
Namespace
aNamespace
const
nsAString
&
aKey
CacheId
aCacheId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
"
INSERT
INTO
storage
(
namespace
key
cache_id
)
"
"
VALUES
(
:
namespace
:
key
:
cache_id
)
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
namespace
"
_ns
aNamespace
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindStringAsBlobByName
(
"
key
"
_ns
aKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt64ByName
(
"
cache_id
"
_ns
aCacheId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
StorageForgetCache
(
mozIStorageConnection
&
aConn
Namespace
aNamespace
const
nsAString
&
aKey
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
const
char
*
query
=
"
DELETE
FROM
storage
WHERE
namespace
=
:
namespace
AND
%
s
;
"
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
CACHE_TRY_UNWRAP
(
state
CreateAndBindKeyStatement
(
aConn
query
aKey
)
)
;
nsresult
rv
=
state
-
>
BindInt32ByName
(
"
namespace
"
_ns
aNamespace
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
Result
<
nsTArray
<
nsString
>
nsresult
>
StorageGetKeys
(
mozIStorageConnection
&
aConn
Namespace
aNamespace
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
SELECT
key
FROM
storage
WHERE
namespace
=
:
namespace
ORDER
BY
rowid
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
namespace
"
_ns
aNamespace
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_RETURN
(
quota
:
:
CollectElementsWhileHasResult
(
*
state
[
]
(
auto
&
stmt
)
{
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE_TYPED
(
nsString
stmt
GetBlobAsString
0
)
)
;
}
)
)
;
}
namespace
{
Result
<
EntryIds
nsresult
>
QueryAll
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
SELECT
id
FROM
entries
WHERE
cache_id
=
:
cache_id
ORDER
BY
id
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt64ByName
(
"
cache_id
"
_ns
aCacheId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_RETURN
(
(
quota
:
:
CollectElementsWhileHasResultTyped
<
EntryIds
>
(
*
state
[
]
(
auto
&
stmt
)
{
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
stmt
GetInt32
0
)
)
;
}
)
)
)
;
}
Result
<
EntryIds
nsresult
>
QueryCache
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
CacheRequest
&
aRequest
const
CacheQueryParams
&
aParams
uint32_t
aMaxResults
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aMaxResults
>
0
)
;
if
(
!
aParams
.
ignoreMethod
(
)
&
&
!
aRequest
.
method
(
)
.
LowerCaseEqualsLiteral
(
"
get
"
)
)
{
return
Result
<
EntryIds
nsresult
>
{
std
:
:
in_place
}
;
}
nsAutoCString
query
(
"
SELECT
id
COUNT
(
response_headers
.
name
)
AS
vary_count
"
"
FROM
entries
"
"
LEFT
OUTER
JOIN
response_headers
ON
"
"
entries
.
id
=
response_headers
.
entry_id
"
"
AND
response_headers
.
name
=
'
vary
'
COLLATE
NOCASE
"
"
WHERE
entries
.
cache_id
=
:
cache_id
"
"
AND
entries
.
request_url_no_query_hash
=
:
url_no_query_hash
"
)
;
if
(
!
aParams
.
ignoreSearch
(
)
)
{
query
.
AppendLiteral
(
"
AND
entries
.
request_url_query_hash
=
:
url_query_hash
"
)
;
}
query
.
AppendLiteral
(
"
AND
entries
.
request_url_no_query
=
:
url_no_query
"
)
;
if
(
!
aParams
.
ignoreSearch
(
)
)
{
query
.
AppendLiteral
(
"
AND
entries
.
request_url_query
=
:
url_query
"
)
;
}
query
.
AppendLiteral
(
"
GROUP
BY
entries
.
id
ORDER
BY
entries
.
id
;
"
)
;
CACHE_TRY_INSPECT
(
const
auto
&
state
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCOMPtr
<
mozIStorageStatement
>
aConn
CreateStatement
query
)
)
;
CACHE_TRY
(
state
-
>
BindInt64ByName
(
"
cache_id
"
_ns
aCacheId
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
crypto
ToResultGet
<
nsCOMPtr
<
nsICryptoHash
>
>
(
MOZ_SELECT_OVERLOAD
(
do_CreateInstance
)
NS_CRYPTO_HASH_CONTRACTID
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
urlWithoutQueryHash
HashCString
(
*
crypto
aRequest
.
urlWithoutQuery
(
)
)
)
;
CACHE_TRY
(
state
-
>
BindUTF8StringAsBlobByName
(
"
url_no_query_hash
"
_ns
urlWithoutQueryHash
)
)
;
if
(
!
aParams
.
ignoreSearch
(
)
)
{
CACHE_TRY_INSPECT
(
const
auto
&
urlQueryHash
HashCString
(
*
crypto
aRequest
.
urlQuery
(
)
)
)
;
CACHE_TRY
(
state
-
>
BindUTF8StringAsBlobByName
(
"
url_query_hash
"
_ns
urlQueryHash
)
)
;
}
CACHE_TRY
(
state
-
>
BindUTF8StringByName
(
"
url_no_query
"
_ns
aRequest
.
urlWithoutQuery
(
)
)
)
;
if
(
!
aParams
.
ignoreSearch
(
)
)
{
CACHE_TRY
(
state
-
>
BindUTF8StringByName
(
"
url_query
"
_ns
aRequest
.
urlQuery
(
)
)
)
;
}
EntryIds
entryIdList
;
CACHE_TRY
(
CollectWhile
(
[
&
state
&
entryIdList
aMaxResults
]
(
)
-
>
Result
<
bool
nsresult
>
{
if
(
entryIdList
.
Length
(
)
=
=
aMaxResults
)
{
return
false
;
}
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
state
ExecuteStep
)
)
;
}
[
&
state
&
entryIdList
ignoreVary
=
aParams
.
ignoreVary
(
)
&
aConn
&
aRequest
]
(
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY_INSPECT
(
const
EntryId
&
entryId
MOZ_TO_RESULT_INVOKE
(
state
GetInt32
0
)
)
;
CACHE_TRY_INSPECT
(
const
int32_t
&
varyCount
MOZ_TO_RESULT_INVOKE
(
state
GetInt32
1
)
)
;
if
(
!
ignoreVary
&
&
varyCount
>
0
)
{
CACHE_TRY_INSPECT
(
const
bool
&
matchedByVary
MatchByVaryHeader
(
aConn
aRequest
entryId
)
)
;
if
(
!
matchedByVary
)
{
return
Ok
{
}
;
}
}
entryIdList
.
AppendElement
(
entryId
)
;
return
Ok
{
}
;
}
)
)
;
return
entryIdList
;
}
Result
<
bool
nsresult
>
MatchByVaryHeader
(
mozIStorageConnection
&
aConn
const
CacheRequest
&
aRequest
EntryId
entryId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
"
SELECT
value
FROM
response_headers
"
"
WHERE
name
=
'
vary
'
COLLATE
NOCASE
"
"
AND
entry_id
=
:
entry_id
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
entryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_UNWRAP
(
auto
varyValues
(
quota
:
:
CollectElementsWhileHasResultTyped
<
AutoTArray
<
nsCString
8
>
>
(
*
state
[
]
(
auto
&
stmt
)
{
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCString
stmt
GetUTF8String
0
)
)
;
}
)
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
varyValues
.
IsEmpty
(
)
)
;
state
-
>
Reset
(
)
;
rv
=
aConn
.
CreateStatement
(
"
SELECT
name
value
FROM
request_headers
"
"
WHERE
entry_id
=
:
entry_id
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
entryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
RefPtr
<
InternalHeaders
>
cachedHeaders
=
new
InternalHeaders
(
HeadersGuardEnum
:
:
None
)
;
CACHE_TRY
(
quota
:
:
CollectWhileHasResult
(
*
state
[
&
cachedHeaders
]
(
auto
&
stmt
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
name
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCString
stmt
GetUTF8String
0
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
value
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCString
stmt
GetUTF8String
1
)
)
;
ErrorResult
errorResult
;
cachedHeaders
-
>
Append
(
name
value
errorResult
)
;
if
(
errorResult
.
Failed
(
)
)
{
return
Err
(
errorResult
.
StealNSResult
(
)
)
;
}
return
Ok
{
}
;
}
)
)
;
RefPtr
<
InternalHeaders
>
queryHeaders
=
TypeUtils
:
:
ToInternalHeaders
(
aRequest
.
headers
(
)
)
;
bool
varyHeadersMatch
=
true
;
for
(
const
auto
&
varyValue
:
varyValues
)
{
bool
bailOut
=
false
;
for
(
const
nsACString
&
header
:
nsCCharSeparatedTokenizer
(
varyValue
NS_HTTP_HEADER_SEP
)
.
ToRange
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
header
.
EqualsLiteral
(
"
*
"
)
"
We
should
have
already
caught
this
in
"
"
TypeUtils
:
:
ToPCacheResponseWithoutBody
(
)
"
)
;
ErrorResult
errorResult
;
nsAutoCString
queryValue
;
queryHeaders
-
>
Get
(
header
queryValue
errorResult
)
;
if
(
errorResult
.
Failed
(
)
)
{
errorResult
.
SuppressException
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
queryValue
.
IsEmpty
(
)
)
;
}
nsAutoCString
cachedValue
;
cachedHeaders
-
>
Get
(
header
cachedValue
errorResult
)
;
if
(
errorResult
.
Failed
(
)
)
{
errorResult
.
SuppressException
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
cachedValue
.
IsEmpty
(
)
)
;
}
if
(
queryValue
!
=
cachedValue
)
{
varyHeadersMatch
=
false
;
bailOut
=
true
;
break
;
}
}
if
(
bailOut
)
{
break
;
}
}
return
varyHeadersMatch
;
}
nsresult
DeleteEntries
(
mozIStorageConnection
&
aConn
const
nsTArray
<
EntryId
>
&
aEntryIdList
nsTArray
<
nsID
>
&
aDeletedBodyIdListOut
nsTArray
<
IdCount
>
&
aDeletedSecurityIdListOut
int64_t
*
aDeletedPaddingSizeOut
uint32_t
aPos
int32_t
aLen
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aDeletedPaddingSizeOut
)
;
if
(
aEntryIdList
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aPos
<
aEntryIdList
.
Length
(
)
)
;
if
(
aLen
<
0
)
{
aLen
=
aEntryIdList
.
Length
(
)
-
aPos
;
}
if
(
aLen
>
kMaxEntriesPerStatement
)
{
int64_t
overallDeletedPaddingSize
=
0
;
uint32_t
curPos
=
aPos
;
int32_t
remaining
=
aLen
;
while
(
remaining
>
0
)
{
int64_t
deletedPaddingSize
=
0
;
int32_t
max
=
kMaxEntriesPerStatement
;
int32_t
curLen
=
std
:
:
min
(
max
remaining
)
;
nsresult
rv
=
DeleteEntries
(
aConn
aEntryIdList
aDeletedBodyIdListOut
aDeletedSecurityIdListOut
&
deletedPaddingSize
curPos
curLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_DIAGNOSTIC_ASSERT
(
INT64_MAX
-
deletedPaddingSize
>
=
overallDeletedPaddingSize
)
;
overallDeletedPaddingSize
+
=
deletedPaddingSize
;
curPos
+
=
curLen
;
remaining
-
=
curLen
;
}
*
aDeletedPaddingSizeOut
+
=
overallDeletedPaddingSize
;
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsAutoCString
query
(
"
SELECT
"
"
request_body_id
"
"
response_body_id
"
"
response_security_info_id
"
"
response_padding_size
"
"
FROM
entries
WHERE
id
IN
(
"
)
;
AppendListParamsToQuery
(
query
aEntryIdList
aPos
aLen
)
;
query
.
AppendLiteral
(
"
)
"
)
;
nsresult
rv
=
aConn
.
CreateStatement
(
query
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
BindListParamsToQuery
(
*
state
aEntryIdList
aPos
aLen
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int64_t
overallPaddingSize
=
0
;
CACHE_TRY
(
quota
:
:
CollectWhileHasResult
(
*
state
[
&
overallPaddingSize
&
aDeletedBodyIdListOut
&
aDeletedSecurityIdListOut
]
(
auto
&
stmt
)
-
>
Result
<
Ok
nsresult
>
{
for
(
uint32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
CACHE_TRY_INSPECT
(
const
bool
&
isNull
MOZ_TO_RESULT_INVOKE
(
stmt
GetIsNull
i
)
)
;
if
(
!
isNull
)
{
CACHE_TRY_INSPECT
(
const
auto
&
id
ExtractId
(
stmt
i
)
)
;
aDeletedBodyIdListOut
.
AppendElement
(
id
)
;
}
}
{
CACHE_TRY_INSPECT
(
const
bool
&
isNull
MOZ_TO_RESULT_INVOKE
(
stmt
GetIsNull
2
)
)
;
if
(
!
isNull
)
{
CACHE_TRY_INSPECT
(
const
int32_t
&
securityId
MOZ_TO_RESULT_INVOKE
(
stmt
GetInt32
2
)
)
;
auto
foundIt
=
std
:
:
find_if
(
aDeletedSecurityIdListOut
.
begin
(
)
aDeletedSecurityIdListOut
.
end
(
)
[
securityId
]
(
const
auto
&
deletedSecurityId
)
{
return
deletedSecurityId
.
mId
=
=
securityId
;
}
)
;
if
(
foundIt
=
=
aDeletedSecurityIdListOut
.
end
(
)
)
{
aDeletedSecurityIdListOut
.
AppendElement
(
IdCount
(
securityId
)
)
;
}
else
{
foundIt
-
>
mCount
+
=
1
;
}
}
}
{
CACHE_TRY_INSPECT
(
const
bool
&
isNull
MOZ_TO_RESULT_INVOKE
(
stmt
GetIsNull
3
)
)
;
if
(
!
isNull
)
{
CACHE_TRY_INSPECT
(
const
int64_t
&
paddingSize
MOZ_TO_RESULT_INVOKE
(
stmt
GetInt64
3
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
paddingSize
>
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
INT64_MAX
-
overallPaddingSize
>
=
paddingSize
)
;
overallPaddingSize
+
=
paddingSize
;
}
}
return
Ok
{
}
;
}
)
)
;
*
aDeletedPaddingSizeOut
=
overallPaddingSize
;
query
=
"
DELETE
FROM
entries
WHERE
id
IN
(
"
_ns
;
AppendListParamsToQuery
(
query
aEntryIdList
aPos
aLen
)
;
query
.
AppendLiteral
(
"
)
"
)
;
rv
=
aConn
.
CreateStatement
(
query
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
BindListParamsToQuery
(
*
state
aEntryIdList
aPos
aLen
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
Result
<
int32_t
nsresult
>
InsertSecurityInfo
(
mozIStorageConnection
&
aConn
nsICryptoHash
&
aCrypto
const
nsACString
&
aData
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aData
.
IsEmpty
(
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
hash
HashCString
(
aCrypto
aData
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
selectStmt
quota
:
:
CreateAndExecuteSingleStepStatement
<
quota
:
:
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
aConn
"
SELECT
id
refcount
FROM
security_info
WHERE
hash
=
:
hash
AND
"
"
data
=
:
data
;
"
_ns
[
&
hash
&
aData
]
(
auto
&
state
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY
(
state
.
BindUTF8StringAsBlobByName
(
"
hash
"
_ns
hash
)
)
;
CACHE_TRY
(
state
.
BindUTF8StringAsBlobByName
(
"
data
"
_ns
aData
)
)
;
return
Ok
{
}
;
}
)
)
;
if
(
selectStmt
)
{
int32_t
id
;
nsresult
rv
=
selectStmt
-
>
GetInt32
(
0
&
id
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
int32_t
refcount
=
-
1
;
rv
=
selectStmt
-
>
GetInt32
(
1
&
refcount
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
refcount
+
=
1
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
UPDATE
security_info
SET
refcount
=
:
refcount
WHERE
id
=
:
id
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
refcount
"
_ns
refcount
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
id
"
_ns
id
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
id
;
}
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
"
INSERT
INTO
security_info
(
hash
data
refcount
)
"
"
VALUES
(
:
hash
:
data
1
)
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindUTF8StringAsBlobByName
(
"
hash
"
_ns
hash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindUTF8StringAsBlobByName
(
"
data
"
_ns
aData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
{
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
aConn
"
SELECT
last_insert_rowid
(
)
"
_ns
)
)
;
int32_t
id
;
rv
=
state
-
>
GetInt32
(
0
&
id
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
id
;
}
}
nsresult
DeleteSecurityInfo
(
mozIStorageConnection
&
aConn
int32_t
aId
int32_t
aCount
)
{
CACHE_TRY_INSPECT
(
const
int32_t
&
refcount
(
[
&
aConn
aId
]
(
)
-
>
Result
<
int32_t
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
aConn
"
SELECT
refcount
FROM
security_info
WHERE
id
=
:
id
;
"
_ns
[
aId
]
(
auto
&
state
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY
(
state
.
BindInt32ByName
(
"
id
"
_ns
aId
)
)
;
return
Ok
{
}
;
}
)
)
;
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
*
state
GetInt32
0
)
)
;
}
(
)
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
refcount
>
=
aCount
)
;
int32_t
newCount
=
refcount
-
aCount
;
if
(
newCount
=
=
0
)
{
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
"
DELETE
FROM
security_info
WHERE
id
=
:
id
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
id
"
_ns
aId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
UPDATE
security_info
SET
refcount
=
:
refcount
WHERE
id
=
:
id
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
refcount
"
_ns
newCount
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
id
"
_ns
aId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
DeleteSecurityInfoList
(
mozIStorageConnection
&
aConn
const
nsTArray
<
IdCount
>
&
aDeletedStorageIdList
)
{
for
(
const
auto
&
deletedStorageId
:
aDeletedStorageIdList
)
{
nsresult
rv
=
DeleteSecurityInfo
(
aConn
deletedStorageId
.
mId
deletedStorageId
.
mCount
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
NS_OK
;
}
nsresult
InsertEntry
(
mozIStorageConnection
&
aConn
CacheId
aCacheId
const
CacheRequest
&
aRequest
const
nsID
*
aRequestBodyId
const
CacheResponse
&
aResponse
const
nsID
*
aResponseBodyId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsICryptoHash
>
crypto
=
do_CreateInstance
(
NS_CRYPTO_HASH_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int32_t
securityId
=
-
1
;
if
(
!
aResponse
.
channelInfo
(
)
.
securityInfo
(
)
.
IsEmpty
(
)
)
{
CACHE_TRY_UNWRAP
(
securityId
InsertSecurityInfo
(
aConn
*
crypto
aResponse
.
channelInfo
(
)
.
securityInfo
(
)
)
)
;
}
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
INSERT
INTO
entries
(
"
"
request_method
"
"
request_url_no_query
"
"
request_url_no_query_hash
"
"
request_url_query
"
"
request_url_query_hash
"
"
request_url_fragment
"
"
request_referrer
"
"
request_referrer_policy
"
"
request_headers_guard
"
"
request_mode
"
"
request_credentials
"
"
request_contentpolicytype
"
"
request_cache
"
"
request_redirect
"
"
request_integrity
"
"
request_body_id
"
"
response_type
"
"
response_status
"
"
response_status_text
"
"
response_headers_guard
"
"
response_body_id
"
"
response_security_info_id
"
"
response_principal_info
"
"
response_padding_size
"
"
cache_id
"
"
)
VALUES
(
"
"
:
request_method
"
"
:
request_url_no_query
"
"
:
request_url_no_query_hash
"
"
:
request_url_query
"
"
:
request_url_query_hash
"
"
:
request_url_fragment
"
"
:
request_referrer
"
"
:
request_referrer_policy
"
"
:
request_headers_guard
"
"
:
request_mode
"
"
:
request_credentials
"
"
:
request_contentpolicytype
"
"
:
request_cache
"
"
:
request_redirect
"
"
:
request_integrity
"
"
:
request_body_id
"
"
:
response_type
"
"
:
response_status
"
"
:
response_status_text
"
"
:
response_headers_guard
"
"
:
response_body_id
"
"
:
response_security_info_id
"
"
:
response_principal_info
"
"
:
response_padding_size
"
"
:
cache_id
"
"
)
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
request_method
"
_ns
aRequest
.
method
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
request_url_no_query
"
_ns
aRequest
.
urlWithoutQuery
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CACHE_TRY_INSPECT
(
const
auto
&
urlWithoutQueryHash
HashCString
(
*
crypto
aRequest
.
urlWithoutQuery
(
)
)
)
;
rv
=
state
-
>
BindUTF8StringAsBlobByName
(
"
request_url_no_query_hash
"
_ns
urlWithoutQueryHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
request_url_query
"
_ns
aRequest
.
urlQuery
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CACHE_TRY_INSPECT
(
const
auto
&
urlQueryHash
HashCString
(
*
crypto
aRequest
.
urlQuery
(
)
)
)
;
rv
=
state
-
>
BindUTF8StringAsBlobByName
(
"
request_url_query_hash
"
_ns
urlQueryHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
request_url_fragment
"
_ns
aRequest
.
urlFragment
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindStringByName
(
"
request_referrer
"
_ns
aRequest
.
referrer
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
request_referrer_policy
"
_ns
static_cast
<
int32_t
>
(
aRequest
.
referrerPolicy
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
request_headers_guard
"
_ns
static_cast
<
int32_t
>
(
aRequest
.
headersGuard
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
request_mode
"
_ns
static_cast
<
int32_t
>
(
aRequest
.
mode
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
request_credentials
"
_ns
static_cast
<
int32_t
>
(
aRequest
.
credentials
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
request_contentpolicytype
"
_ns
static_cast
<
int32_t
>
(
aRequest
.
contentPolicyType
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
request_cache
"
_ns
static_cast
<
int32_t
>
(
aRequest
.
requestCache
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
request_redirect
"
_ns
static_cast
<
int32_t
>
(
aRequest
.
requestRedirect
(
)
)
)
;
rv
=
state
-
>
BindStringByName
(
"
request_integrity
"
_ns
aRequest
.
integrity
(
)
)
;
rv
=
BindId
(
*
state
"
request_body_id
"
_ns
aRequestBodyId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
response_type
"
_ns
static_cast
<
int32_t
>
(
aResponse
.
type
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
response_status
"
_ns
aResponse
.
status
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
response_status_text
"
_ns
aResponse
.
statusText
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
response_headers_guard
"
_ns
static_cast
<
int32_t
>
(
aResponse
.
headersGuard
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
BindId
(
*
state
"
response_body_id
"
_ns
aResponseBodyId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aResponse
.
channelInfo
(
)
.
securityInfo
(
)
.
IsEmpty
(
)
)
{
rv
=
state
-
>
BindNullByName
(
"
response_security_info_id
"
_ns
)
;
}
else
{
rv
=
state
-
>
BindInt32ByName
(
"
response_security_info_id
"
_ns
securityId
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
serializedInfo
;
if
(
aResponse
.
principalInfo
(
)
.
isSome
(
)
)
{
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
principalInfo
=
aResponse
.
principalInfo
(
)
.
ref
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
principalInfo
.
type
(
)
=
=
mozilla
:
:
ipc
:
:
PrincipalInfo
:
:
TContentPrincipalInfo
)
;
const
mozilla
:
:
ipc
:
:
ContentPrincipalInfo
&
cInfo
=
principalInfo
.
get_ContentPrincipalInfo
(
)
;
serializedInfo
.
Append
(
cInfo
.
spec
(
)
)
;
nsAutoCString
suffix
;
cInfo
.
attrs
(
)
.
CreateSuffix
(
suffix
)
;
serializedInfo
.
Append
(
suffix
)
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
response_principal_info
"
_ns
serializedInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aResponse
.
paddingSize
(
)
=
=
InternalResponse
:
:
UNKNOWN_PADDING_SIZE
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aResponse
.
type
(
)
!
=
ResponseType
:
:
Opaque
)
;
rv
=
state
-
>
BindNullByName
(
"
response_padding_size
"
_ns
)
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
aResponse
.
paddingSize
(
)
>
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aResponse
.
type
(
)
=
=
ResponseType
:
:
Opaque
)
;
rv
=
state
-
>
BindInt64ByName
(
"
response_padding_size
"
_ns
aResponse
.
paddingSize
(
)
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt64ByName
(
"
cache_id
"
_ns
aCacheId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CACHE_TRY_INSPECT
(
const
int32_t
&
entryId
(
[
&
aConn
]
(
)
-
>
Result
<
int32_t
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
aConn
"
SELECT
last_insert_rowid
(
)
"
_ns
)
)
;
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE
(
*
state
GetInt32
0
)
)
;
}
(
)
)
)
;
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
INSERT
INTO
request_headers
(
"
"
name
"
"
value
"
"
entry_id
"
"
)
VALUES
(
:
name
:
value
:
entry_id
)
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
requestHeader
:
aRequest
.
headers
(
)
)
{
rv
=
state
-
>
BindUTF8StringByName
(
"
name
"
_ns
requestHeader
.
name
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
value
"
_ns
requestHeader
.
value
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
entryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
INSERT
INTO
response_headers
(
"
"
name
"
"
value
"
"
entry_id
"
"
)
VALUES
(
:
name
:
value
:
entry_id
)
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
responseHeader
:
aResponse
.
headers
(
)
)
{
rv
=
state
-
>
BindUTF8StringByName
(
"
name
"
_ns
responseHeader
.
name
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
value
"
_ns
responseHeader
.
value
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
entryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
INSERT
INTO
response_url_list
(
"
"
url
"
"
entry_id
"
"
)
VALUES
(
:
url
:
entry_id
)
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
for
(
const
auto
&
responseUrl
:
aResponse
.
urlList
(
)
)
{
rv
=
state
-
>
BindUTF8StringByName
(
"
url
"
_ns
responseUrl
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
entryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
return
rv
;
}
Result
<
HeadersEntry
nsresult
>
GetHeadersEntryFromStatement
(
mozIStorageStatement
&
aStmt
)
{
HeadersEntry
header
;
CACHE_TRY_UNWRAP
(
header
.
name
(
)
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCString
aStmt
GetUTF8String
0
)
)
;
CACHE_TRY_UNWRAP
(
header
.
value
(
)
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCString
aStmt
GetUTF8String
1
)
)
;
return
header
;
}
Result
<
SavedResponse
nsresult
>
ReadResponse
(
mozIStorageConnection
&
aConn
EntryId
aEntryId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
SavedResponse
savedResponse
;
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
aConn
"
SELECT
"
"
entries
.
response_type
"
"
entries
.
response_status
"
"
entries
.
response_status_text
"
"
entries
.
response_headers_guard
"
"
entries
.
response_body_id
"
"
entries
.
response_principal_info
"
"
entries
.
response_padding_size
"
"
security_info
.
data
"
"
FROM
entries
"
"
LEFT
OUTER
JOIN
security_info
"
"
ON
entries
.
response_security_info_id
=
security_info
.
id
"
"
WHERE
entries
.
id
=
:
id
;
"
_ns
[
aEntryId
]
(
auto
&
state
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY
(
state
.
BindInt32ByName
(
"
id
"
_ns
aEntryId
)
)
;
return
Ok
{
}
;
}
)
)
;
int32_t
type
;
nsresult
rv
=
state
-
>
GetInt32
(
0
&
type
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedResponse
.
mValue
.
type
(
)
=
static_cast
<
ResponseType
>
(
type
)
;
int32_t
status
;
rv
=
state
-
>
GetInt32
(
1
&
status
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedResponse
.
mValue
.
status
(
)
=
status
;
rv
=
state
-
>
GetUTF8String
(
2
savedResponse
.
mValue
.
statusText
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
int32_t
guard
;
rv
=
state
-
>
GetInt32
(
3
&
guard
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedResponse
.
mValue
.
headersGuard
(
)
=
static_cast
<
HeadersGuardEnum
>
(
guard
)
;
bool
nullBody
=
false
;
rv
=
state
-
>
GetIsNull
(
4
&
nullBody
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedResponse
.
mHasBodyId
=
!
nullBody
;
if
(
savedResponse
.
mHasBodyId
)
{
CACHE_TRY_UNWRAP
(
savedResponse
.
mBodyId
ExtractId
(
*
state
4
)
)
;
}
nsAutoCString
serializedInfo
;
rv
=
state
-
>
GetUTF8String
(
5
serializedInfo
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedResponse
.
mValue
.
principalInfo
(
)
=
Nothing
(
)
;
if
(
!
serializedInfo
.
IsEmpty
(
)
)
{
nsAutoCString
specNoSuffix
;
OriginAttributes
attrs
;
if
(
!
attrs
.
PopulateFromOrigin
(
serializedInfo
specNoSuffix
)
)
{
NS_WARNING
(
"
Something
went
wrong
parsing
a
serialized
principal
!
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
RefPtr
<
net
:
:
MozURL
>
url
;
rv
=
net
:
:
MozURL
:
:
Init
(
getter_AddRefs
(
url
)
specNoSuffix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
#
ifdef
DEBUG
nsDependentCSubstring
scheme
=
url
-
>
Scheme
(
)
;
MOZ_ASSERT
(
scheme
=
=
"
http
"
|
|
scheme
=
=
"
https
"
|
|
scheme
=
=
"
file
"
|
|
scheme
=
=
"
moz
-
extension
"
)
;
#
endif
nsCString
origin
;
url
-
>
Origin
(
origin
)
;
nsCString
baseDomain
;
rv
=
url
-
>
BaseDomain
(
baseDomain
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedResponse
.
mValue
.
principalInfo
(
)
=
Some
(
mozilla
:
:
ipc
:
:
ContentPrincipalInfo
(
attrs
origin
specNoSuffix
Nothing
(
)
baseDomain
)
)
;
}
bool
nullPadding
=
false
;
rv
=
state
-
>
GetIsNull
(
6
&
nullPadding
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
if
(
nullPadding
)
{
MOZ_DIAGNOSTIC_ASSERT
(
savedResponse
.
mValue
.
type
(
)
!
=
ResponseType
:
:
Opaque
)
;
savedResponse
.
mValue
.
paddingSize
(
)
=
InternalResponse
:
:
UNKNOWN_PADDING_SIZE
;
}
else
{
MOZ_DIAGNOSTIC_ASSERT
(
savedResponse
.
mValue
.
type
(
)
=
=
ResponseType
:
:
Opaque
)
;
int64_t
paddingSize
=
0
;
rv
=
state
-
>
GetInt64
(
6
&
paddingSize
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
paddingSize
>
=
0
)
;
savedResponse
.
mValue
.
paddingSize
(
)
=
paddingSize
;
}
rv
=
state
-
>
GetBlobAsUTF8String
(
7
savedResponse
.
mValue
.
channelInfo
(
)
.
securityInfo
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
{
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
SELECT
"
"
name
"
"
value
"
"
FROM
response_headers
"
"
WHERE
entry_id
=
:
entry_id
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
aEntryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_UNWRAP
(
savedResponse
.
mValue
.
headers
(
)
quota
:
:
CollectElementsWhileHasResult
(
*
state
GetHeadersEntryFromStatement
)
)
;
}
{
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
SELECT
"
"
url
"
"
FROM
response_url_list
"
"
WHERE
entry_id
=
:
entry_id
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
aEntryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_UNWRAP
(
savedResponse
.
mValue
.
urlList
(
)
quota
:
:
CollectElementsWhileHasResult
(
*
state
[
]
(
auto
&
stmt
)
-
>
Result
<
nsCString
nsresult
>
{
CACHE_TRY_RETURN
(
MOZ_TO_RESULT_INVOKE_TYPED
(
nsCString
stmt
GetUTF8String
0
)
)
;
}
)
)
;
}
return
savedResponse
;
}
Result
<
SavedRequest
nsresult
>
ReadRequest
(
mozIStorageConnection
&
aConn
EntryId
aEntryId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
SavedRequest
savedRequest
;
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
<
quota
:
:
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
aConn
"
SELECT
"
"
request_method
"
"
request_url_no_query
"
"
request_url_query
"
"
request_url_fragment
"
"
request_referrer
"
"
request_referrer_policy
"
"
request_headers_guard
"
"
request_mode
"
"
request_credentials
"
"
request_contentpolicytype
"
"
request_cache
"
"
request_redirect
"
"
request_integrity
"
"
request_body_id
"
"
FROM
entries
"
"
WHERE
id
=
:
id
;
"
_ns
[
aEntryId
]
(
auto
&
state
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY
(
state
.
BindInt32ByName
(
"
id
"
_ns
aEntryId
)
)
;
return
Ok
{
}
;
}
)
)
;
CACHE_TRY
(
OkIf
(
state
)
Err
(
NS_ERROR_UNEXPECTED
)
)
;
nsresult
rv
=
state
-
>
GetUTF8String
(
0
savedRequest
.
mValue
.
method
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
GetUTF8String
(
1
savedRequest
.
mValue
.
urlWithoutQuery
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
GetUTF8String
(
2
savedRequest
.
mValue
.
urlQuery
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
GetUTF8String
(
3
savedRequest
.
mValue
.
urlFragment
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
GetString
(
4
savedRequest
.
mValue
.
referrer
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
int32_t
referrerPolicy
;
rv
=
state
-
>
GetInt32
(
5
&
referrerPolicy
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mValue
.
referrerPolicy
(
)
=
static_cast
<
ReferrerPolicy
>
(
referrerPolicy
)
;
int32_t
guard
;
rv
=
state
-
>
GetInt32
(
6
&
guard
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mValue
.
headersGuard
(
)
=
static_cast
<
HeadersGuardEnum
>
(
guard
)
;
int32_t
mode
;
rv
=
state
-
>
GetInt32
(
7
&
mode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mValue
.
mode
(
)
=
static_cast
<
RequestMode
>
(
mode
)
;
int32_t
credentials
;
rv
=
state
-
>
GetInt32
(
8
&
credentials
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mValue
.
credentials
(
)
=
static_cast
<
RequestCredentials
>
(
credentials
)
;
int32_t
requestContentPolicyType
;
rv
=
state
-
>
GetInt32
(
9
&
requestContentPolicyType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mValue
.
contentPolicyType
(
)
=
static_cast
<
nsContentPolicyType
>
(
requestContentPolicyType
)
;
int32_t
requestCache
;
rv
=
state
-
>
GetInt32
(
10
&
requestCache
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mValue
.
requestCache
(
)
=
static_cast
<
RequestCache
>
(
requestCache
)
;
int32_t
requestRedirect
;
rv
=
state
-
>
GetInt32
(
11
&
requestRedirect
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mValue
.
requestRedirect
(
)
=
static_cast
<
RequestRedirect
>
(
requestRedirect
)
;
rv
=
state
-
>
GetString
(
12
savedRequest
.
mValue
.
integrity
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
bool
nullBody
=
false
;
rv
=
state
-
>
GetIsNull
(
13
&
nullBody
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
savedRequest
.
mHasBodyId
=
!
nullBody
;
if
(
savedRequest
.
mHasBodyId
)
{
CACHE_TRY_UNWRAP
(
savedRequest
.
mBodyId
ExtractId
(
*
state
13
)
)
;
}
{
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
SELECT
"
"
name
"
"
value
"
"
FROM
request_headers
"
"
WHERE
entry_id
=
:
entry_id
;
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
state
-
>
BindInt32ByName
(
"
entry_id
"
_ns
aEntryId
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
CACHE_TRY_UNWRAP
(
savedRequest
.
mValue
.
headers
(
)
quota
:
:
CollectElementsWhileHasResult
(
*
state
GetHeadersEntryFromStatement
)
)
;
}
return
savedRequest
;
}
void
AppendListParamsToQuery
(
nsACString
&
aQuery
const
nsTArray
<
EntryId
>
&
aEntryIdList
uint32_t
aPos
int32_t
aLen
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
(
aPos
+
aLen
)
<
=
aEntryIdList
.
Length
(
)
)
;
for
(
int32_t
i
=
aPos
;
i
<
aLen
;
+
+
i
)
{
if
(
i
=
=
0
)
{
aQuery
.
AppendLiteral
(
"
?
"
)
;
}
else
{
aQuery
.
AppendLiteral
(
"
?
"
)
;
}
}
}
nsresult
BindListParamsToQuery
(
mozIStorageStatement
&
aState
const
nsTArray
<
EntryId
>
&
aEntryIdList
uint32_t
aPos
int32_t
aLen
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
(
aPos
+
aLen
)
<
=
aEntryIdList
.
Length
(
)
)
;
for
(
int32_t
i
=
aPos
;
i
<
aLen
;
+
+
i
)
{
CACHE_TRY
(
aState
.
BindInt32ByIndex
(
i
aEntryIdList
[
i
]
)
)
;
}
return
NS_OK
;
}
nsresult
BindId
(
mozIStorageStatement
&
aState
const
nsACString
&
aName
const
nsID
*
aId
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
;
if
(
!
aId
)
{
rv
=
aState
.
BindNullByName
(
aName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
char
idBuf
[
NSID_LENGTH
]
;
aId
-
>
ToProvidedString
(
idBuf
)
;
rv
=
aState
.
BindUTF8StringByName
(
aName
nsDependentCString
(
idBuf
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
Result
<
nsID
nsresult
>
ExtractId
(
mozIStorageStatement
&
aState
uint32_t
aPos
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsAutoCString
idString
;
nsresult
rv
=
aState
.
GetUTF8String
(
aPos
idString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
nsID
id
;
bool
success
=
id
.
Parse
(
idString
.
get
(
)
)
;
if
(
NS_WARN_IF
(
!
success
)
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
return
id
;
}
Result
<
MovingNotNull
<
nsCOMPtr
<
mozIStorageStatement
>
>
nsresult
>
CreateAndBindKeyStatement
(
mozIStorageConnection
&
aConn
const
char
*
aQueryFormat
const
nsAString
&
aKey
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aQueryFormat
)
;
const
char
*
constraint
=
nullptr
;
if
(
aKey
.
IsEmpty
(
)
)
{
constraint
=
"
key
IS
NULL
"
;
}
else
{
constraint
=
"
key
=
:
key
"
;
}
nsPrintfCString
query
(
aQueryFormat
constraint
)
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
query
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
if
(
!
aKey
.
IsEmpty
(
)
)
{
rv
=
state
-
>
BindStringAsBlobByName
(
"
key
"
_ns
aKey
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
}
return
WrapMovingNotNull
(
std
:
:
move
(
state
)
)
;
}
Result
<
nsAutoCString
nsresult
>
HashCString
(
nsICryptoHash
&
aCrypto
const
nsACString
&
aIn
)
{
nsresult
rv
=
aCrypto
.
Init
(
nsICryptoHash
:
:
SHA1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
rv
=
aCrypto
.
Update
(
reinterpret_cast
<
const
uint8_t
*
>
(
aIn
.
BeginReading
(
)
)
aIn
.
Length
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
nsAutoCString
fullHash
;
rv
=
aCrypto
.
Finish
(
false
fullHash
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
return
Result
<
nsAutoCString
nsresult
>
{
std
:
:
in_place
Substring
(
fullHash
0
8
)
}
;
}
}
nsresult
IncrementalVacuum
(
mozIStorageConnection
&
aConn
)
{
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
aConn
"
PRAGMA
freelist_count
;
"
_ns
)
)
;
int32_t
freePages
=
0
;
nsresult
rv
=
state
-
>
GetInt32
(
0
&
freePages
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
freePages
<
=
kMaxFreePages
)
{
return
NS_OK
;
}
int32_t
pagesToRelease
=
freePages
-
kMaxFreePages
;
rv
=
aConn
.
ExecuteSimpleSQL
(
nsPrintfCString
(
"
PRAGMA
incremental_vacuum
(
%
d
)
;
"
pagesToRelease
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
#
ifdef
DEBUG
{
CACHE_TRY_INSPECT
(
const
auto
&
state
quota
:
:
CreateAndExecuteSingleStepStatement
(
aConn
"
PRAGMA
freelist_count
;
"
_ns
)
)
;
freePages
=
0
;
rv
=
state
-
>
GetInt32
(
0
&
freePages
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
freePages
<
=
kMaxFreePages
)
;
}
#
endif
return
NS_OK
;
}
namespace
{
Result
<
int32_t
nsresult
>
GetEffectiveSchemaVersion
(
mozIStorageConnection
&
aConn
)
{
int32_t
schemaVersion
;
nsresult
rv
=
aConn
.
GetSchemaVersion
(
&
schemaVersion
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
Err
(
rv
)
;
}
if
(
schemaVersion
=
=
kHackyDowngradeSchemaVersion
)
{
CACHE_TRY_INSPECT
(
const
bool
&
hasColumn
quota
:
:
CreateAndExecuteSingleStepStatement
<
quota
:
:
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
aConn
"
SELECT
name
FROM
pragma_table_info
(
'
entries
'
)
WHERE
"
"
name
=
'
response_padding_size
'
"
_ns
)
)
;
if
(
hasColumn
)
{
return
kHackyPaddingSizePresentVersion
;
}
}
return
schemaVersion
;
}
#
ifdef
DEBUG
struct
Expect
{
Expect
(
const
char
*
aName
const
char
*
aType
const
char
*
aSql
)
:
mName
(
aName
)
mType
(
aType
)
mSql
(
aSql
)
mIgnoreSql
(
false
)
{
}
Expect
(
const
char
*
aName
const
char
*
aType
)
:
mName
(
aName
)
mType
(
aType
)
mIgnoreSql
(
true
)
{
}
const
nsCString
mName
;
const
nsCString
mType
;
const
nsCString
mSql
;
const
bool
mIgnoreSql
;
}
;
#
endif
nsresult
Validate
(
mozIStorageConnection
&
aConn
)
{
int32_t
schemaVersion
;
CACHE_TRY_UNWRAP
(
schemaVersion
GetEffectiveSchemaVersion
(
aConn
)
)
;
if
(
NS_WARN_IF
(
schemaVersion
!
=
kLatestSchemaVersion
)
)
{
return
NS_ERROR_FAILURE
;
}
#
ifdef
DEBUG
const
Expect
expects
[
]
=
{
Expect
(
"
caches
"
"
table
"
kTableCaches
)
Expect
(
"
sqlite_sequence
"
"
table
"
)
Expect
(
"
security_info
"
"
table
"
kTableSecurityInfo
)
Expect
(
"
security_info_hash_index
"
"
index
"
kIndexSecurityInfoHash
)
Expect
(
"
entries
"
"
table
"
kTableEntries
)
Expect
(
"
entries_request_match_index
"
"
index
"
kIndexEntriesRequest
)
Expect
(
"
request_headers
"
"
table
"
kTableRequestHeaders
)
Expect
(
"
response_headers
"
"
table
"
kTableResponseHeaders
)
Expect
(
"
response_headers_name_index
"
"
index
"
kIndexResponseHeadersName
)
Expect
(
"
response_url_list
"
"
table
"
kTableResponseUrlList
)
Expect
(
"
storage
"
"
table
"
kTableStorage
)
Expect
(
"
sqlite_autoindex_storage_1
"
"
index
"
)
}
;
nsCOMPtr
<
mozIStorageStatement
>
state
;
nsresult
rv
=
aConn
.
CreateStatement
(
"
SELECT
name
type
sql
FROM
sqlite_master
;
"
_ns
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CACHE_TRY
(
quota
:
:
CollectWhileHasResult
(
*
state
[
&
expects
]
(
auto
&
stmt
)
-
>
Result
<
Ok
nsresult
>
{
CACHE_TRY_INSPECT
(
const
auto
&
name
MOZ_TO_RESULT_INVOKE_TYPED
(
nsAutoCString
stmt
GetUTF8String
0
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
type
MOZ_TO_RESULT_INVOKE_TYPED
(
nsAutoCString
stmt
GetUTF8String
1
)
)
;
CACHE_TRY_INSPECT
(
const
auto
&
sql
MOZ_TO_RESULT_INVOKE_TYPED
(
nsAutoCString
stmt
GetUTF8String
2
)
)
;
bool
foundMatch
=
false
;
for
(
const
auto
&
expect
:
expects
)
{
if
(
name
=
=
expect
.
mName
)
{
if
(
type
!
=
expect
.
mType
)
{
NS_WARNING
(
nsPrintfCString
(
"
Unexpected
type
for
Cache
schema
entry
%
s
"
name
.
get
(
)
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
if
(
!
expect
.
mIgnoreSql
&
&
sql
!
=
expect
.
mSql
)
{
NS_WARNING
(
nsPrintfCString
(
"
Unexpected
SQL
for
Cache
schema
entry
%
s
"
name
.
get
(
)
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
foundMatch
=
true
;
break
;
}
}
if
(
NS_WARN_IF
(
!
foundMatch
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Unexpected
schema
entry
%
s
in
Cache
database
"
name
.
get
(
)
)
.
get
(
)
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
return
Ok
{
}
;
}
)
)
;
#
endif
return
NS_OK
;
}
typedef
nsresult
(
*
MigrationFunc
)
(
mozIStorageConnection
&
bool
&
)
;
struct
Migration
{
constexpr
Migration
(
int32_t
aFromVersion
MigrationFunc
aFunc
)
:
mFromVersion
(
aFromVersion
)
mFunc
(
aFunc
)
{
}
int32_t
mFromVersion
;
MigrationFunc
mFunc
;
}
;
nsresult
MigrateFrom15To16
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom16To17
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom17To18
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom18To19
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom19To20
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom20To21
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom21To22
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom22To23
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom23To24
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom24To25
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom25To26
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
nsresult
MigrateFrom26To27
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
;
Migration
sMigrationList
[
]
=
{
Migration
(
15
MigrateFrom15To16
)
Migration
(
16
MigrateFrom16To17
)
Migration
(
17
MigrateFrom17To18
)
Migration
(
18
MigrateFrom18To19
)
Migration
(
19
MigrateFrom19To20
)
Migration
(
20
MigrateFrom20To21
)
Migration
(
21
MigrateFrom21To22
)
Migration
(
22
MigrateFrom22To23
)
Migration
(
23
MigrateFrom23To24
)
Migration
(
24
MigrateFrom24To25
)
Migration
(
25
MigrateFrom25To26
)
Migration
(
26
MigrateFrom26To27
)
}
;
nsresult
RewriteEntriesSchema
(
mozIStorageConnection
&
aConn
)
{
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
"
PRAGMA
writable_schema
=
ON
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
mozIStorageStatement
>
state
;
rv
=
aConn
.
CreateStatement
(
nsLiteralCString
(
"
UPDATE
sqlite_master
SET
sql
=
:
sql
WHERE
name
=
'
entries
'
"
)
getter_AddRefs
(
state
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
BindUTF8StringByName
(
"
sql
"
_ns
nsDependentCString
(
kTableEntries
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
state
-
>
Execute
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
"
PRAGMA
writable_schema
=
OFF
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
Migrate
(
mozIStorageConnection
&
aConn
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
int32_t
currentVersion
=
0
;
CACHE_TRY_UNWRAP
(
currentVersion
GetEffectiveSchemaVersion
(
aConn
)
)
;
bool
rewriteSchema
=
false
;
while
(
currentVersion
<
kLatestSchemaVersion
)
{
MOZ_DIAGNOSTIC_ASSERT
(
currentVersion
>
=
kFirstShippedSchemaVersion
)
;
for
(
const
auto
&
migration
:
sMigrationList
)
{
if
(
migration
.
mFromVersion
=
=
currentVersion
)
{
bool
shouldRewrite
=
false
;
nsresult
rv
=
migration
.
mFunc
(
aConn
shouldRewrite
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
shouldRewrite
)
{
rewriteSchema
=
true
;
}
break
;
}
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
int32_t
lastVersion
=
currentVersion
;
#
endif
CACHE_TRY_UNWRAP
(
currentVersion
GetEffectiveSchemaVersion
(
aConn
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
currentVersion
>
lastVersion
)
;
}
MOZ_ASSERT
(
currentVersion
=
=
kLatestSchemaVersion
)
;
nsresult
rv
=
NS_OK
;
if
(
rewriteSchema
)
{
rv
=
RewriteEntriesSchema
(
aConn
)
;
}
return
rv
;
}
nsresult
MigrateFrom15To16
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
entries
"
"
ADD
COLUMN
request_redirect
INTEGER
NOT
NULL
DEFAULT
0
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
16
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aRewriteSchema
=
true
;
return
rv
;
}
nsresult
MigrateFrom16To17
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
new_entries
(
"
"
id
INTEGER
NOT
NULL
PRIMARY
KEY
"
"
request_method
TEXT
NOT
NULL
"
"
request_url_no_query
TEXT
NOT
NULL
"
"
request_url_no_query_hash
BLOB
NOT
NULL
"
"
request_url_query
TEXT
NOT
NULL
"
"
request_url_query_hash
BLOB
NOT
NULL
"
"
request_referrer
TEXT
NOT
NULL
"
"
request_headers_guard
INTEGER
NOT
NULL
"
"
request_mode
INTEGER
NOT
NULL
"
"
request_credentials
INTEGER
NOT
NULL
"
"
request_contentpolicytype
INTEGER
NOT
NULL
"
"
request_cache
INTEGER
NOT
NULL
"
"
request_body_id
TEXT
NULL
"
"
response_type
INTEGER
NOT
NULL
"
"
response_url
TEXT
NOT
NULL
"
"
response_status
INTEGER
NOT
NULL
"
"
response_status_text
TEXT
NOT
NULL
"
"
response_headers_guard
INTEGER
NOT
NULL
"
"
response_body_id
TEXT
NULL
"
"
response_security_info_id
INTEGER
NULL
REFERENCES
security_info
(
id
)
"
"
response_principal_info
TEXT
NOT
NULL
"
"
cache_id
INTEGER
NOT
NULL
REFERENCES
caches
(
id
)
ON
DELETE
CASCADE
"
"
request_redirect
INTEGER
NOT
NULL
"
"
)
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
INSERT
INTO
new_entries
(
"
"
id
"
"
request_method
"
"
request_url_no_query
"
"
request_url_no_query_hash
"
"
request_url_query
"
"
request_url_query_hash
"
"
request_referrer
"
"
request_headers_guard
"
"
request_mode
"
"
request_credentials
"
"
request_contentpolicytype
"
"
request_cache
"
"
request_redirect
"
"
request_body_id
"
"
response_type
"
"
response_url
"
"
response_status
"
"
response_status_text
"
"
response_headers_guard
"
"
response_body_id
"
"
response_security_info_id
"
"
response_principal_info
"
"
cache_id
"
"
)
SELECT
"
"
id
"
"
request_method
"
"
request_url_no_query
"
"
request_url_no_query_hash
"
"
request_url_query
"
"
request_url_query_hash
"
"
request_referrer
"
"
request_headers_guard
"
"
request_mode
"
"
request_credentials
"
"
request_contentpolicytype
"
"
request_cache
"
"
request_redirect
"
"
request_body_id
"
"
response_type
"
"
response_url
"
"
response_status
"
"
response_status_text
"
"
response_headers_guard
"
"
response_body_id
"
"
response_security_info_id
"
"
response_principal_info
"
"
cache_id
"
"
FROM
entries
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
"
DROP
TABLE
entries
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
"
ALTER
TABLE
new_entries
RENAME
to
entries
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kIndexEntriesRequest
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CACHE_TRY_INSPECT
(
const
bool
&
hasResult
quota
:
:
CreateAndExecuteSingleStepStatement
<
quota
:
:
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
aConn
"
PRAGMA
foreign_key_check
;
"
_ns
)
)
;
CACHE_TRY
(
OkIf
(
!
hasResult
)
NS_ERROR_FAILURE
)
;
rv
=
aConn
.
SetSchemaVersion
(
17
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
MigrateFrom17To18
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
static_assert
(
int
(
RequestCache
:
:
Default
)
=
=
0
"
This
is
where
the
0
below
comes
from
!
"
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
UPDATE
entries
SET
request_cache
=
0
"
"
WHERE
request_cache
=
5
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
18
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
MigrateFrom18To19
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
static_assert
(
int
(
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
=
=
6
&
&
int
(
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
)
=
=
7
&
&
int
(
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
)
=
=
28
&
&
int
(
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
)
=
=
29
&
&
int
(
RequestMode
:
:
Navigate
)
=
=
3
"
This
is
where
the
numbers
below
come
from
!
"
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
UPDATE
entries
SET
request_mode
=
3
"
"
WHERE
request_contentpolicytype
IN
(
6
7
28
29
8
)
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
19
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
MigrateFrom19To20
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
entries
"
"
ADD
COLUMN
request_referrer_policy
INTEGER
NOT
NULL
DEFAULT
2
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
20
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aRewriteSchema
=
true
;
return
rv
;
}
nsresult
MigrateFrom20To21
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
new_entries
(
"
"
id
INTEGER
NOT
NULL
PRIMARY
KEY
"
"
request_method
TEXT
NOT
NULL
"
"
request_url_no_query
TEXT
NOT
NULL
"
"
request_url_no_query_hash
BLOB
NOT
NULL
"
"
request_url_query
TEXT
NOT
NULL
"
"
request_url_query_hash
BLOB
NOT
NULL
"
"
request_referrer
TEXT
NOT
NULL
"
"
request_headers_guard
INTEGER
NOT
NULL
"
"
request_mode
INTEGER
NOT
NULL
"
"
request_credentials
INTEGER
NOT
NULL
"
"
request_contentpolicytype
INTEGER
NOT
NULL
"
"
request_cache
INTEGER
NOT
NULL
"
"
request_body_id
TEXT
NULL
"
"
response_type
INTEGER
NOT
NULL
"
"
response_status
INTEGER
NOT
NULL
"
"
response_status_text
TEXT
NOT
NULL
"
"
response_headers_guard
INTEGER
NOT
NULL
"
"
response_body_id
TEXT
NULL
"
"
response_security_info_id
INTEGER
NULL
REFERENCES
security_info
(
id
)
"
"
response_principal_info
TEXT
NOT
NULL
"
"
cache_id
INTEGER
NOT
NULL
REFERENCES
caches
(
id
)
ON
DELETE
CASCADE
"
"
request_redirect
INTEGER
NOT
NULL
"
"
request_referrer_policy
INTEGER
NOT
NULL
"
"
)
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
CREATE
TABLE
response_url_list
(
"
"
url
TEXT
NOT
NULL
"
"
entry_id
INTEGER
NOT
NULL
REFERENCES
entries
(
id
)
ON
DELETE
CASCADE
"
"
)
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
INSERT
INTO
new_entries
(
"
"
id
"
"
request_method
"
"
request_url_no_query
"
"
request_url_no_query_hash
"
"
request_url_query
"
"
request_url_query_hash
"
"
request_referrer
"
"
request_headers_guard
"
"
request_mode
"
"
request_credentials
"
"
request_contentpolicytype
"
"
request_cache
"
"
request_redirect
"
"
request_referrer_policy
"
"
request_body_id
"
"
response_type
"
"
response_status
"
"
response_status_text
"
"
response_headers_guard
"
"
response_body_id
"
"
response_security_info_id
"
"
response_principal_info
"
"
cache_id
"
"
)
SELECT
"
"
id
"
"
request_method
"
"
request_url_no_query
"
"
request_url_no_query_hash
"
"
request_url_query
"
"
request_url_query_hash
"
"
request_referrer
"
"
request_headers_guard
"
"
request_mode
"
"
request_credentials
"
"
request_contentpolicytype
"
"
request_cache
"
"
request_redirect
"
"
request_referrer_policy
"
"
request_body_id
"
"
response_type
"
"
response_status
"
"
response_status_text
"
"
response_headers_guard
"
"
response_body_id
"
"
response_security_info_id
"
"
response_principal_info
"
"
cache_id
"
"
FROM
entries
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
INSERT
INTO
response_url_list
(
"
"
url
"
"
entry_id
"
"
)
SELECT
"
"
response_url
"
"
id
"
"
FROM
entries
;
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
"
DROP
TABLE
entries
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
"
ALTER
TABLE
new_entries
RENAME
to
entries
;
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsDependentCString
(
kIndexEntriesRequest
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
CACHE_TRY_INSPECT
(
const
bool
&
hasResult
quota
:
:
CreateAndExecuteSingleStepStatement
<
quota
:
:
SingleStepResult
:
:
ReturnNullIfNoResult
>
(
aConn
"
PRAGMA
foreign_key_check
;
"
_ns
)
)
;
CACHE_TRY
(
OkIf
(
!
hasResult
)
NS_ERROR_FAILURE
)
;
rv
=
aConn
.
SetSchemaVersion
(
21
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aRewriteSchema
=
true
;
return
rv
;
}
nsresult
MigrateFrom21To22
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
entries
"
"
ADD
COLUMN
request_integrity
TEXT
NULL
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
22
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aRewriteSchema
=
true
;
return
rv
;
}
nsresult
MigrateFrom22To23
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
SetSchemaVersion
(
23
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
MigrateFrom23To24
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
entries
"
"
ADD
COLUMN
request_url_fragment
TEXT
NOT
NULL
DEFAULT
'
'
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
24
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aRewriteSchema
=
true
;
return
rv
;
}
nsresult
MigrateFrom24To25
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
SetSchemaVersion
(
25
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
nsresult
MigrateFrom25To26
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
ALTER
TABLE
entries
"
"
ADD
COLUMN
response_padding_size
INTEGER
NULL
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
ExecuteSimpleSQL
(
nsLiteralCString
(
"
UPDATE
entries
SET
response_padding_size
=
0
"
"
WHERE
response_type
=
4
"
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
aConn
.
SetSchemaVersion
(
26
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aRewriteSchema
=
true
;
return
rv
;
}
nsresult
MigrateFrom26To27
(
mozIStorageConnection
&
aConn
bool
&
aRewriteSchema
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
aConn
.
SetSchemaVersion
(
kHackyDowngradeSchemaVersion
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
rv
;
}
}
}
