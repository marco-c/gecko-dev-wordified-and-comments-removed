#
ifndef
mozilla_dom_ReportingHeader_h
#
define
mozilla_dom_ReportingHeader_h
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsTObserverArray
.
h
"
class
nsIHttpChannel
;
class
nsIPrincipal
;
class
nsIURI
;
namespace
mozilla
{
class
OriginAttributesPattern
;
namespace
ipc
{
class
PrincipalInfo
;
}
namespace
dom
{
class
ReportingHeader
final
:
public
nsIObserver
public
nsITimerCallback
public
nsINamed
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
static
void
Initialize
(
)
;
struct
Endpoint
{
nsCOMPtr
<
nsIURI
>
mUrl
;
uint32_t
mPriority
;
uint32_t
mWeight
;
}
;
struct
Group
{
nsString
mName
;
bool
mIncludeSubdomains
;
int32_t
mTTL
;
TimeStamp
mCreationTime
;
nsTObserverArray
<
Endpoint
>
mEndpoints
;
}
;
struct
Client
{
nsTObserverArray
<
Group
>
mGroups
;
}
;
static
UniquePtr
<
Client
>
ParseHeader
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
const
nsACString
&
aHeaderValue
)
;
static
void
GetEndpointForReport
(
const
nsAString
&
aGroupName
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
nsACString
&
aEndpointURI
)
;
static
void
GetEndpointForReport
(
const
nsAString
&
aGroupName
nsIPrincipal
*
aPrincipal
nsACString
&
aEndpointURI
)
;
static
void
RemoveEndpoint
(
const
nsAString
&
aGroupName
const
nsACString
&
aEndpointURL
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
)
;
static
bool
HasReportingHeaderForOrigin
(
const
nsACString
&
aOrigin
)
;
private
:
ReportingHeader
(
)
;
~
ReportingHeader
(
)
;
static
void
Shutdown
(
)
;
void
ReportingFromChannel
(
nsIHttpChannel
*
aChannel
)
;
bool
IsSecureURI
(
nsIURI
*
aURI
)
const
;
void
RemoveOriginsFromHost
(
const
nsAString
&
aHost
)
;
void
RemoveOriginsFromOriginAttributesPattern
(
const
OriginAttributesPattern
&
aPattern
)
;
void
RemoveOrigins
(
)
;
void
RemoveOriginsForTTL
(
)
;
void
MaybeCreateCleanupTimer
(
)
;
void
MaybeCancelCleanupTimer
(
)
;
static
void
LogToConsoleInvalidJSON
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
)
;
static
void
LogToConsoleDuplicateGroup
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
const
nsAString
&
aName
)
;
static
void
LogToConsoleInvalidNameItem
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
)
;
static
void
LogToConsoleIncompleteItem
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
const
nsAString
&
aName
)
;
static
void
LogToConsoleIncompleteEndpoint
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
const
nsAString
&
aName
)
;
static
void
LogToConsoleInvalidURLEndpoint
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
const
nsAString
&
aName
const
nsAString
&
aURL
)
;
static
void
LogToConsoleInternal
(
nsIHttpChannel
*
aChannel
nsIURI
*
aURI
const
char
*
aMsg
const
nsTArray
<
nsString
>
&
aParams
)
;
static
void
GetEndpointForReportInternal
(
const
ReportingHeader
:
:
Group
&
aGrup
nsACString
&
aEndpointURI
)
;
nsClassHashtable
<
nsCStringHashKey
Client
>
mOrigins
;
nsCOMPtr
<
nsITimer
>
mCleanupTimer
;
}
;
}
}
#
endif
