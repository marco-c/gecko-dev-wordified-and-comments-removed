#
include
"
CloseWatcherManager
.
h
"
#
include
"
CloseWatcher
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION
(
CloseWatcherManager
mGroups
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
CloseWatcherManager
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
CloseWatcherManager
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CloseWatcherManager
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
CloseWatcherManager
:
:
NotifyUserInteraction
(
)
{
if
(
mNextUserInteractionAllowsNewGroup
)
{
mAllowedNumberOfGroups
+
=
1
;
mNextUserInteractionAllowsNewGroup
=
false
;
}
}
bool
CloseWatcherManager
:
:
CanGrow
(
)
const
{
return
mGroups
.
Length
(
)
<
mAllowedNumberOfGroups
;
}
MOZ_CAN_RUN_SCRIPT
bool
CloseWatcherManager
:
:
ProcessCloseRequest
(
)
{
bool
processedACloseWatcher
=
false
;
if
(
mGroups
.
IsEmpty
(
)
)
{
return
processedACloseWatcher
;
}
auto
i
=
mGroups
.
Length
(
)
-
1
;
auto
group
=
mGroups
.
ElementAt
(
i
)
.
Clone
(
)
;
for
(
RefPtr
<
CloseWatcher
>
watcher
:
group
.
BackwardRange
(
)
)
{
processedACloseWatcher
=
true
;
if
(
!
watcher
-
>
RequestToClose
(
)
)
{
break
;
}
}
if
(
mAllowedNumberOfGroups
>
1
)
{
mAllowedNumberOfGroups
-
=
1
;
}
return
processedACloseWatcher
;
}
void
CloseWatcherManager
:
:
Add
(
CloseWatcher
&
aWatcher
)
{
if
(
CanGrow
(
)
)
{
mGroups
.
AppendElement
(
)
-
>
AppendElement
(
&
aWatcher
)
;
}
else
{
MOZ_ASSERT
(
!
mGroups
.
IsEmpty
(
)
"
CloseWatcherManager
groups
must
be
at
least
1
"
)
;
auto
i
=
mGroups
.
Length
(
)
-
1
;
MOZ_ASSERT
(
!
mGroups
.
ElementAt
(
i
)
.
Contains
(
&
aWatcher
)
)
;
mGroups
.
ElementAt
(
i
)
.
AppendElement
(
&
aWatcher
)
;
}
mNextUserInteractionAllowsNewGroup
=
true
;
}
void
CloseWatcherManager
:
:
Remove
(
CloseWatcher
&
aWatcher
)
{
CloseWatcherArray
:
:
ForwardIterator
iter
(
mGroups
)
;
while
(
iter
.
HasMore
(
)
)
{
auto
&
group
=
iter
.
GetNext
(
)
;
group
.
RemoveElement
(
&
aWatcher
)
;
if
(
group
.
IsEmpty
(
)
)
{
iter
.
Remove
(
)
;
}
}
mGroups
.
Compact
(
)
;
}
bool
CloseWatcherManager
:
:
Contains
(
const
CloseWatcher
&
aWatcher
)
const
{
for
(
const
auto
&
group
:
mGroups
.
BackwardRange
(
)
)
{
if
(
group
.
Contains
(
&
aWatcher
)
)
{
return
true
;
}
}
return
false
;
}
}
