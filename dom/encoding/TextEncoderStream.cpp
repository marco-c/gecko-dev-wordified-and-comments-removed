#
include
"
mozilla
/
dom
/
TextEncoderStream
.
h
"
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
TextEncoderStreamBinding
.
h
"
#
include
"
mozilla
/
dom
/
TransformerCallbackHelpers
.
h
"
#
include
"
mozilla
/
dom
/
TransformStream
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
TextEncoderStream
mGlobal
mStream
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextEncoderStream
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextEncoderStream
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TextEncoderStream
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
TextEncoderStream
:
:
TextEncoderStream
(
nsISupports
*
aGlobal
TransformStream
&
aStream
)
:
mGlobal
(
aGlobal
)
mStream
(
&
aStream
)
{
mDecoder
=
UTF_16LE_ENCODING
-
>
NewDecoder
(
)
;
}
TextEncoderStream
:
:
~
TextEncoderStream
(
)
=
default
;
JSObject
*
TextEncoderStream
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
TextEncoderStream_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
static
void
EncodeNative
(
JSContext
*
aCx
mozilla
:
:
Decoder
*
aDecoder
Span
<
const
char16_t
>
aInput
const
bool
aFlush
JS
:
:
MutableHandle
<
JSObject
*
>
aOutputArrayBufferView
ErrorResult
&
aRv
)
{
if
(
aInput
.
Length
(
)
>
SIZE_MAX
/
2
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
size_t
lengthU8
=
aInput
.
Length
(
)
*
2
;
CheckedInt
<
nsAString
:
:
size_type
>
needed
=
aDecoder
-
>
MaxUTF8BufferLength
(
lengthU8
)
;
if
(
!
needed
.
isValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
UniquePtr
<
uint8_t
>
buffer
(
static_cast
<
uint8_t
*
>
(
JS_malloc
(
aCx
needed
.
value
(
)
)
)
)
;
if
(
!
buffer
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
mozilla
:
:
Span
<
uint8_t
>
input
(
(
uint8_t
*
)
aInput
.
data
(
)
lengthU8
)
;
mozilla
:
:
Span
<
uint8_t
>
output
(
buffer
needed
.
value
(
)
)
;
uint32_t
result
;
size_t
read
;
size_t
written
;
std
:
:
tie
(
result
read
written
std
:
:
ignore
)
=
aDecoder
-
>
DecodeToUTF8
(
input
output
aFlush
)
;
MOZ_ASSERT
(
result
=
=
kInputEmpty
)
;
MOZ_ASSERT
(
read
=
=
lengthU8
)
;
MOZ_ASSERT
(
written
<
=
needed
.
value
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
arrayBuffer
(
aCx
JS
:
:
NewArrayBufferWithContents
(
aCx
written
buffer
.
release
(
)
)
)
;
if
(
!
arrayBuffer
.
get
(
)
)
{
JS_ClearPendingException
(
aCx
)
;
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
aOutputArrayBufferView
.
set
(
JS_NewUint8ArrayWithBuffer
(
aCx
arrayBuffer
0
static_cast
<
int64_t
>
(
written
)
)
)
;
}
class
TextEncoderStreamAlgorithms
:
public
TransformerAlgorithmsWrapper
{
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
TextEncoderStreamAlgorithms
TransformerAlgorithmsBase
)
void
SetEncoderStream
(
TextEncoderStream
&
aStream
)
{
mEncoderStream
=
&
aStream
;
}
MOZ_CAN_RUN_SCRIPT
void
EncodeAndEnqueue
(
JSContext
*
aCx
const
nsAString
&
aInput
TransformStreamDefaultController
&
aController
bool
aFlush
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JSObject
*
>
outView
(
aCx
)
;
EncodeNative
(
aCx
mEncoderStream
-
>
Decoder
(
)
aInput
aFlush
&
outView
aRv
)
;
if
(
JS_GetTypedArrayLength
(
outView
)
>
0
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
JS
:
:
ObjectValue
(
*
outView
)
)
;
aController
.
Enqueue
(
aCx
value
aRv
)
;
}
}
MOZ_CAN_RUN_SCRIPT
void
TransformCallbackImpl
(
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
TransformStreamDefaultController
&
aController
ErrorResult
&
aRv
)
override
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
aController
.
GetParentObject
(
)
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
nsString
str
;
if
(
!
ConvertJSValueToString
(
cx
aChunk
eStringify
eStringify
str
)
)
{
aRv
.
MightThrowJSException
(
)
;
aRv
.
StealExceptionFromJSContext
(
cx
)
;
return
;
}
EncodeAndEnqueue
(
cx
str
aController
false
aRv
)
;
}
MOZ_CAN_RUN_SCRIPT
void
FlushCallbackImpl
(
TransformStreamDefaultController
&
aController
ErrorResult
&
aRv
)
override
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
aController
.
GetParentObject
(
)
)
)
{
aRv
.
ThrowUnknownError
(
"
Internal
error
"
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
EncodeAndEnqueue
(
cx
u
"
"
_ns
aController
true
aRv
)
;
}
private
:
~
TextEncoderStreamAlgorithms
(
)
override
=
default
;
RefPtr
<
TextEncoderStream
>
mEncoderStream
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
TextEncoderStreamAlgorithms
TransformerAlgorithmsBase
mEncoderStream
)
NS_IMPL_ADDREF_INHERITED
(
TextEncoderStreamAlgorithms
TransformerAlgorithmsBase
)
NS_IMPL_RELEASE_INHERITED
(
TextEncoderStreamAlgorithms
TransformerAlgorithmsBase
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TextEncoderStreamAlgorithms
)
NS_INTERFACE_MAP_END_INHERITING
(
TransformerAlgorithmsBase
)
already_AddRefed
<
TextEncoderStream
>
TextEncoderStream
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
{
auto
algorithms
=
MakeRefPtr
<
TextEncoderStreamAlgorithms
>
(
)
;
RefPtr
<
TransformStream
>
transformStream
=
TransformStream
:
:
CreateGeneric
(
aGlobal
*
algorithms
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
auto
encoderStream
=
MakeRefPtr
<
TextEncoderStream
>
(
aGlobal
.
GetAsSupports
(
)
*
transformStream
)
;
algorithms
-
>
SetEncoderStream
(
*
encoderStream
)
;
return
encoderStream
.
forget
(
)
;
}
ReadableStream
*
TextEncoderStream
:
:
Readable
(
)
const
{
return
mStream
-
>
Readable
(
)
;
}
WritableStream
*
TextEncoderStream
:
:
Writable
(
)
const
{
return
mStream
-
>
Writable
(
)
;
}
void
TextEncoderStream
:
:
GetEncoding
(
nsCString
&
aRetVal
)
const
{
aRetVal
.
AssignLiteral
(
"
utf
-
8
"
)
;
}
}
