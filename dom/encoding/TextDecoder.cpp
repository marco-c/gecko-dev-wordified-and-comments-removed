#
include
"
mozilla
/
dom
/
TextDecoder
.
h
"
#
include
"
mozilla
/
dom
/
EncodingUtils
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
<
stdint
.
h
>
namespace
mozilla
{
namespace
dom
{
static
const
char16_t
kReplacementChar
=
static_cast
<
char16_t
>
(
0xFFFD
)
;
void
TextDecoder
:
:
Init
(
const
nsAString
&
aLabel
const
bool
aFatal
ErrorResult
&
aRv
)
{
nsAutoCString
encoding
;
if
(
!
EncodingUtils
:
:
FindEncodingForLabelNoReplacement
(
aLabel
encoding
)
)
{
nsAutoString
label
(
aLabel
)
;
EncodingUtils
:
:
TrimSpaceCharacters
(
label
)
;
aRv
.
ThrowRangeError
<
MSG_ENCODING_NOT_SUPPORTED
>
(
label
)
;
return
;
}
InitWithEncoding
(
encoding
aFatal
)
;
}
void
TextDecoder
:
:
InitWithEncoding
(
const
nsACString
&
aEncoding
const
bool
aFatal
)
{
mEncoding
=
aEncoding
;
mFatal
=
aFatal
;
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
mEncoding
)
;
}
void
TextDecoder
:
:
Decode
(
Span
<
const
uint8_t
>
aInput
const
bool
aStream
nsAString
&
aOutDecodedString
ErrorResult
&
aRv
)
{
aOutDecodedString
.
Truncate
(
)
;
CheckedInt
<
size_t
>
needed
=
mDecoder
-
>
MaxUTF16BufferLength
(
aInput
.
Length
(
)
)
;
if
(
!
needed
.
isValid
(
)
|
|
needed
.
value
(
)
>
MaxValue
<
nsAString
:
:
size_type
>
:
:
value
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
!
aOutDecodedString
.
SetLength
(
needed
.
value
(
)
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
uint32_t
result
;
size_t
read
;
size_t
written
;
bool
hadErrors
;
if
(
mFatal
)
{
Tie
(
result
read
written
)
=
mDecoder
-
>
DecodeToUTF16WithoutReplacement
(
aInput
aOutDecodedString
!
aStream
)
;
if
(
result
!
=
kInputEmpty
)
{
aRv
.
ThrowTypeError
<
MSG_DOM_DECODING_FAILED
>
(
)
;
return
;
}
}
else
{
Tie
(
result
read
written
hadErrors
)
=
mDecoder
-
>
DecodeToUTF16
(
aInput
aOutDecodedString
!
aStream
)
;
}
MOZ_ASSERT
(
result
=
=
kInputEmpty
)
;
MOZ_ASSERT
(
read
=
=
aInput
.
Length
(
)
)
;
MOZ_ASSERT
(
written
<
=
aOutDecodedString
.
Length
(
)
)
;
Unused
<
<
hadErrors
;
if
(
!
aOutDecodedString
.
SetLength
(
written
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
!
aStream
)
{
mDecoder
-
>
Encoding
(
)
-
>
NewDecoderWithBOMRemovalInto
(
*
mDecoder
)
;
}
}
void
TextDecoder
:
:
Decode
(
const
Optional
<
ArrayBufferViewOrArrayBuffer
>
&
aBuffer
const
TextDecodeOptions
&
aOptions
nsAString
&
aOutDecodedString
ErrorResult
&
aRv
)
{
if
(
!
aBuffer
.
WasPassed
(
)
)
{
Decode
(
nullptr
aOptions
.
mStream
aOutDecodedString
aRv
)
;
return
;
}
const
ArrayBufferViewOrArrayBuffer
&
buf
=
aBuffer
.
Value
(
)
;
uint8_t
*
data
;
uint32_t
length
;
if
(
buf
.
IsArrayBufferView
(
)
)
{
buf
.
GetAsArrayBufferView
(
)
.
ComputeLengthAndData
(
)
;
data
=
buf
.
GetAsArrayBufferView
(
)
.
Data
(
)
;
length
=
buf
.
GetAsArrayBufferView
(
)
.
Length
(
)
;
}
else
{
MOZ_ASSERT
(
buf
.
IsArrayBuffer
(
)
)
;
buf
.
GetAsArrayBuffer
(
)
.
ComputeLengthAndData
(
)
;
data
=
buf
.
GetAsArrayBuffer
(
)
.
Data
(
)
;
length
=
buf
.
GetAsArrayBuffer
(
)
.
Length
(
)
;
}
Decode
(
MakeSpan
(
data
length
)
aOptions
.
mStream
aOutDecodedString
aRv
)
;
}
void
TextDecoder
:
:
GetEncoding
(
nsAString
&
aEncoding
)
{
CopyASCIItoUTF16
(
mEncoding
aEncoding
)
;
nsContentUtils
:
:
ASCIIToLower
(
aEncoding
)
;
}
}
}
