#
include
"
mozilla
/
dom
/
TextDecoder
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
<
stdint
.
h
>
namespace
mozilla
:
:
dom
{
void
TextDecoder
:
:
Init
(
const
nsAString
&
aLabel
const
TextDecoderOptions
&
aOptions
ErrorResult
&
aRv
)
{
const
Encoding
*
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
aLabel
)
;
if
(
!
encoding
)
{
NS_ConvertUTF16toUTF8
label
(
aLabel
)
;
label
.
Trim
(
"
\
t
\
n
\
f
\
r
"
)
;
aRv
.
ThrowRangeError
<
MSG_ENCODING_NOT_SUPPORTED
>
(
label
)
;
return
;
}
InitWithEncoding
(
WrapNotNull
(
encoding
)
aOptions
)
;
}
void
TextDecoder
:
:
InitWithEncoding
(
NotNull
<
const
Encoding
*
>
aEncoding
const
TextDecoderOptions
&
aOptions
)
{
aEncoding
-
>
Name
(
mEncoding
)
;
mFatal
=
aOptions
.
mFatal
;
mIgnoreBOM
=
aOptions
.
mIgnoreBOM
;
if
(
mIgnoreBOM
)
{
mDecoder
=
aEncoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
else
{
mDecoder
=
aEncoding
-
>
NewDecoderWithBOMRemoval
(
)
;
}
}
void
TextDecoder
:
:
Decode
(
Span
<
const
uint8_t
>
aInput
const
bool
aStream
nsAString
&
aOutDecodedString
ErrorResult
&
aRv
)
{
aOutDecodedString
.
Truncate
(
)
;
CheckedInt
<
nsAString
:
:
size_type
>
needed
=
mDecoder
-
>
MaxUTF16BufferLength
(
aInput
.
Length
(
)
)
;
if
(
!
needed
.
isValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
auto
output
=
aOutDecodedString
.
GetMutableData
(
needed
.
value
(
)
fallible
)
;
if
(
!
output
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
uint32_t
result
;
size_t
read
;
size_t
written
;
if
(
mFatal
)
{
std
:
:
tie
(
result
read
written
)
=
mDecoder
-
>
DecodeToUTF16WithoutReplacement
(
aInput
*
output
!
aStream
)
;
if
(
result
!
=
kInputEmpty
)
{
aRv
.
ThrowTypeError
<
MSG_DOM_DECODING_FAILED
>
(
)
;
return
;
}
}
else
{
std
:
:
tie
(
result
read
written
std
:
:
ignore
)
=
mDecoder
-
>
DecodeToUTF16
(
aInput
*
output
!
aStream
)
;
}
MOZ_ASSERT
(
result
=
=
kInputEmpty
)
;
MOZ_ASSERT
(
read
=
=
aInput
.
Length
(
)
)
;
MOZ_ASSERT
(
written
<
=
aOutDecodedString
.
Length
(
)
)
;
if
(
!
aOutDecodedString
.
SetLength
(
written
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
!
aStream
)
{
if
(
mIgnoreBOM
)
{
mDecoder
-
>
Encoding
(
)
-
>
NewDecoderWithoutBOMHandlingInto
(
*
mDecoder
)
;
}
else
{
mDecoder
-
>
Encoding
(
)
-
>
NewDecoderWithBOMRemovalInto
(
*
mDecoder
)
;
}
}
}
void
TextDecoder
:
:
Decode
(
const
Optional
<
ArrayBufferViewOrArrayBuffer
>
&
aBuffer
const
TextDecodeOptions
&
aOptions
nsAString
&
aOutDecodedString
ErrorResult
&
aRv
)
{
if
(
!
aBuffer
.
WasPassed
(
)
)
{
Decode
(
nullptr
aOptions
.
mStream
aOutDecodedString
aRv
)
;
return
;
}
const
ArrayBufferViewOrArrayBuffer
&
buf
=
aBuffer
.
Value
(
)
;
uint8_t
*
data
;
uint32_t
length
;
if
(
buf
.
IsArrayBufferView
(
)
)
{
buf
.
GetAsArrayBufferView
(
)
.
ComputeState
(
)
;
data
=
buf
.
GetAsArrayBufferView
(
)
.
Data
(
)
;
length
=
buf
.
GetAsArrayBufferView
(
)
.
Length
(
)
;
}
else
{
MOZ_ASSERT
(
buf
.
IsArrayBuffer
(
)
)
;
buf
.
GetAsArrayBuffer
(
)
.
ComputeState
(
)
;
data
=
buf
.
GetAsArrayBuffer
(
)
.
Data
(
)
;
length
=
buf
.
GetAsArrayBuffer
(
)
.
Length
(
)
;
}
Decode
(
Span
(
data
length
)
aOptions
.
mStream
aOutDecodedString
aRv
)
;
}
void
TextDecoder
:
:
GetEncoding
(
nsAString
&
aEncoding
)
{
CopyASCIItoUTF16
(
mEncoding
aEncoding
)
;
nsContentUtils
:
:
ASCIIToLower
(
aEncoding
)
;
}
}
