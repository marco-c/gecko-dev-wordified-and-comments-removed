#
ifndef
mozilla_dom_textdecoder_h_
#
define
mozilla_dom_textdecoder_h_
#
include
"
mozilla
/
dom
/
NonRefcountedDOMObject
.
h
"
#
include
"
mozilla
/
dom
/
TextDecoderBinding
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
ArrayBufferViewOrArrayBuffer
;
class
TextDecoder
final
:
public
NonRefcountedDOMObject
{
public
:
static
TextDecoder
*
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aEncoding
const
TextDecoderOptions
&
aOptions
ErrorResult
&
aRv
)
{
nsAutoPtr
<
TextDecoder
>
txtDecoder
(
new
TextDecoder
(
)
)
;
txtDecoder
-
>
Init
(
aEncoding
aOptions
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
txtDecoder
.
forget
(
)
;
}
TextDecoder
(
)
:
mFatal
(
false
)
mIgnoreBOM
(
false
)
{
MOZ_COUNT_CTOR
(
TextDecoder
)
;
}
MOZ_COUNTED_DTOR
(
TextDecoder
)
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
{
return
TextDecoder_Binding
:
:
Wrap
(
aCx
this
aGivenProto
aReflector
)
;
}
void
Init
(
const
nsAString
&
aLabel
const
TextDecoderOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
InitWithEncoding
(
NotNull
<
const
Encoding
*
>
aEncoding
const
TextDecoderOptions
&
aOptions
)
;
void
GetEncoding
(
nsAString
&
aEncoding
)
;
void
Decode
(
mozilla
:
:
Span
<
const
uint8_t
>
aInput
const
bool
aStream
nsAString
&
aOutDecodedString
ErrorResult
&
aRv
)
;
void
Decode
(
const
Optional
<
ArrayBufferViewOrArrayBuffer
>
&
aBuffer
const
TextDecodeOptions
&
aOptions
nsAString
&
aOutDecodedString
ErrorResult
&
aRv
)
;
bool
Fatal
(
)
const
{
return
mFatal
;
}
bool
IgnoreBOM
(
)
const
{
return
mIgnoreBOM
;
}
private
:
nsCString
mEncoding
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
Decoder
>
mDecoder
;
bool
mFatal
;
bool
mIgnoreBOM
;
}
;
}
}
#
endif
