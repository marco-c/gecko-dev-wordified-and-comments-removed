#
ifndef
mozilla_dom_IterableIterator_h
#
define
mozilla_dom_IterableIterator_h
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
mozilla
/
dom
/
IterableIteratorBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
namespace
mozilla
:
:
dom
{
namespace
iterator_utils
{
void
DictReturn
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
bool
aDone
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
;
void
KeyAndValueReturn
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aKey
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aRv
)
;
void
ResolvePromiseForFinished
(
JSContext
*
aCx
Promise
*
aPromise
ErrorResult
&
aRv
)
;
void
ResolvePromiseWithKeyOrValue
(
JSContext
*
aCx
Promise
*
aPromise
JS
:
:
Handle
<
JS
:
:
Value
>
aKeyOrValue
ErrorResult
&
aRv
)
;
void
ResolvePromiseWithKeyAndValue
(
JSContext
*
aCx
Promise
*
aPromise
JS
:
:
Handle
<
JS
:
:
Value
>
aKey
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
;
}
class
IterableIteratorBase
:
public
nsISupports
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
IterableIteratorBase
)
typedef
enum
{
Keys
=
0
Values
Entries
}
IteratorType
;
IterableIteratorBase
(
)
=
default
;
protected
:
virtual
~
IterableIteratorBase
(
)
=
default
;
virtual
void
UnlinkHelper
(
)
=
0
;
virtual
void
TraverseHelper
(
nsCycleCollectionTraversalCallback
&
cb
)
=
0
;
}
;
template
<
typename
T
typename
U
>
bool
CallIterableGetter
(
JSContext
*
aCx
U
(
T
:
:
*
aMethod
)
(
uint32_t
)
T
*
aInst
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
return
ToJSValue
(
aCx
(
aInst
-
>
*
aMethod
)
(
aIndex
)
aResult
)
;
}
template
<
typename
T
typename
U
>
bool
CallIterableGetter
(
JSContext
*
aCx
U
(
T
:
:
*
aMethod
)
(
uint32_t
)
const
const
T
*
aInst
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
return
ToJSValue
(
aCx
(
aInst
-
>
*
aMethod
)
(
aIndex
)
aResult
)
;
}
template
<
typename
T
>
bool
CallIterableGetter
(
JSContext
*
aCx
bool
(
T
:
:
*
aMethod
)
(
JSContext
*
uint32_t
JS
:
:
MutableHandle
<
JS
:
:
Value
>
)
T
*
aInst
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
return
(
aInst
-
>
*
aMethod
)
(
aCx
aIndex
aResult
)
;
}
template
<
typename
T
>
bool
CallIterableGetter
(
JSContext
*
aCx
bool
(
T
:
:
*
aMethod
)
(
JSContext
*
uint32_t
JS
:
:
MutableHandle
<
JS
:
:
Value
>
)
const
const
T
*
aInst
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
return
(
aInst
-
>
*
aMethod
)
(
aCx
aIndex
aResult
)
;
}
template
<
typename
T
>
class
IterableIterator
final
:
public
IterableIteratorBase
{
public
:
typedef
bool
(
*
WrapFunc
)
(
JSContext
*
aCx
IterableIterator
<
T
>
*
aObject
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
;
explicit
IterableIterator
(
T
*
aIterableObj
IteratorType
aIteratorType
WrapFunc
aWrapFunc
)
:
mIterableObj
(
aIterableObj
)
mIteratorType
(
aIteratorType
)
mWrapFunc
(
aWrapFunc
)
mIndex
(
0
)
{
MOZ_ASSERT
(
mIterableObj
)
;
MOZ_ASSERT
(
mWrapFunc
)
;
}
bool
GetKeyAtIndex
(
JSContext
*
aCx
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
return
CallIterableGetter
(
aCx
&
T
:
:
GetKeyAtIndex
mIterableObj
.
get
(
)
aIndex
aResult
)
;
}
bool
GetValueAtIndex
(
JSContext
*
aCx
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
{
return
CallIterableGetter
(
aCx
&
T
:
:
GetValueAtIndex
mIterableObj
.
get
(
)
aIndex
aResult
)
;
}
void
Next
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
if
(
mIndex
>
=
this
-
>
mIterableObj
-
>
GetIterableLength
(
)
)
{
iterator_utils
:
:
DictReturn
(
aCx
aResult
true
value
aRv
)
;
return
;
}
switch
(
mIteratorType
)
{
case
IteratorType
:
:
Keys
:
{
if
(
!
GetKeyAtIndex
(
aCx
mIndex
&
value
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
iterator_utils
:
:
DictReturn
(
aCx
aResult
false
value
aRv
)
;
break
;
}
case
IteratorType
:
:
Values
:
{
if
(
!
GetValueAtIndex
(
aCx
mIndex
&
value
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
iterator_utils
:
:
DictReturn
(
aCx
aResult
false
value
aRv
)
;
break
;
}
case
IteratorType
:
:
Entries
:
{
JS
:
:
Rooted
<
JS
:
:
Value
>
key
(
aCx
)
;
if
(
!
GetKeyAtIndex
(
aCx
mIndex
&
key
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
!
GetValueAtIndex
(
aCx
mIndex
&
value
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
iterator_utils
:
:
KeyAndValueReturn
(
aCx
key
value
aResult
aRv
)
;
break
;
}
default
:
MOZ_CRASH
(
"
Invalid
iterator
type
!
"
)
;
}
+
+
mIndex
;
}
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aObj
)
{
return
(
*
mWrapFunc
)
(
aCx
this
aGivenProto
aObj
)
;
}
protected
:
virtual
~
IterableIterator
(
)
=
default
;
void
UnlinkHelper
(
)
final
{
mIterableObj
=
nullptr
;
}
virtual
void
TraverseHelper
(
nsCycleCollectionTraversalCallback
&
cb
)
override
{
IterableIterator
<
T
>
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIterableObj
)
;
}
RefPtr
<
T
>
mIterableObj
;
IteratorType
mIteratorType
;
WrapFunc
mWrapFunc
;
uint32_t
mIndex
;
}
;
template
<
typename
T
>
class
AsyncIterableIterator
final
:
public
IterableIteratorBase
public
SupportsWeakPtr
{
public
:
typedef
bool
(
*
WrapFunc
)
(
JSContext
*
aCx
AsyncIterableIterator
<
T
>
*
aObject
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
;
explicit
AsyncIterableIterator
(
T
*
aIterableObj
IteratorType
aIteratorType
WrapFunc
aWrapFunc
)
:
mIterableObj
(
aIterableObj
)
mIteratorType
(
aIteratorType
)
mWrapFunc
(
aWrapFunc
)
{
MOZ_ASSERT
(
mIterableObj
)
;
MOZ_ASSERT
(
mWrapFunc
)
;
}
void
SetData
(
void
*
aData
)
{
mData
=
aData
;
}
void
*
GetData
(
)
{
return
mData
;
}
IteratorType
GetIteratorType
(
)
{
return
mIteratorType
;
}
void
Next
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
mIterableObj
-
>
GetNextPromise
(
aCx
this
aRv
)
;
if
(
!
promise
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aResult
.
set
(
promise
-
>
PromiseObj
(
)
)
;
}
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aObj
)
{
return
(
*
mWrapFunc
)
(
aCx
this
aGivenProto
aObj
)
;
}
protected
:
virtual
~
AsyncIterableIterator
(
)
{
if
(
mIterableObj
)
{
mIterableObj
-
>
DestroyAsyncIterator
(
this
)
;
}
}
void
UnlinkHelper
(
)
final
{
mIterableObj
-
>
DestroyAsyncIterator
(
this
)
;
mIterableObj
=
nullptr
;
}
virtual
void
TraverseHelper
(
nsCycleCollectionTraversalCallback
&
cb
)
override
{
AsyncIterableIterator
<
T
>
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIterableObj
)
;
}
RefPtr
<
T
>
mIterableObj
;
IteratorType
mIteratorType
;
WrapFunc
mWrapFunc
;
void
*
mData
{
nullptr
}
;
}
;
}
#
endif
