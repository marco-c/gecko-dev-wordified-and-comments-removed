#
ifndef
mozilla_dom_BindingDeclarations_h__
#
define
mozilla_dom_BindingDeclarations_h__
#
include
<
type_traits
>
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
mozilla
/
CycleCollectedUniquePtr
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RootedOwningNonNull
.
h
"
#
include
"
mozilla
/
RootedRefPtr
.
h
"
#
include
"
mozilla
/
dom
/
DOMString
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIPrincipal
;
class
nsWrapperCache
;
namespace
mozilla
{
class
ErrorResult
;
class
OOMReporter
;
class
CopyableErrorResult
;
namespace
dom
{
class
BindingCallContext
;
struct
DictionaryBase
{
protected
:
bool
ParseJSON
(
JSContext
*
aCx
const
nsAString
&
aJSON
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
;
bool
StringifyToJSON
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
nsAString
&
aJSON
)
const
;
struct
FastDictionaryInitializer
{
}
;
bool
mIsAnyMemberPresent
=
false
;
private
:
static
bool
AppendJSONToString
(
const
char16_t
*
aJSONData
uint32_t
aDataLength
void
*
aString
)
;
public
:
bool
IsAnyMemberPresent
(
)
const
{
return
mIsAnyMemberPresent
;
}
}
;
template
<
class
T
>
constexpr
bool
is_dom_dictionary
=
std
:
:
is_base_of_v
<
DictionaryBase
T
>
;
template
<
typename
T
>
inline
std
:
:
enable_if_t
<
is_dom_dictionary
<
T
>
void
>
ImplCycleCollectionUnlink
(
T
&
aDictionary
)
{
aDictionary
.
UnlinkForCC
(
)
;
}
template
<
typename
T
>
inline
std
:
:
enable_if_t
<
is_dom_dictionary
<
T
>
void
>
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
T
&
aDictionary
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aDictionary
.
TraverseForCC
(
aCallback
aFlags
)
;
}
template
<
typename
T
>
inline
std
:
:
enable_if_t
<
is_dom_dictionary
<
T
>
void
>
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
UniquePtr
<
T
>
&
aDictionary
const
char
*
aName
uint32_t
aFlags
=
0
)
{
if
(
aDictionary
)
{
ImplCycleCollectionTraverse
(
aCallback
*
aDictionary
aName
aFlags
)
;
}
}
struct
AllTypedArraysBase
{
}
;
template
<
class
T
>
constexpr
bool
is_dom_typed_array
=
std
:
:
is_base_of_v
<
AllTypedArraysBase
T
>
;
struct
AllUnionBase
{
}
;
template
<
class
T
>
constexpr
bool
is_dom_union
=
std
:
:
is_base_of_v
<
AllUnionBase
T
>
;
struct
AllOwningUnionBase
:
public
AllUnionBase
{
}
;
template
<
class
T
>
constexpr
bool
is_dom_owning_union
=
std
:
:
is_base_of_v
<
AllOwningUnionBase
T
>
;
struct
UnionWithTypedArraysBase
{
}
;
template
<
class
T
>
constexpr
bool
is_dom_union_with_typedarray_members
=
std
:
:
is_base_of_v
<
UnionWithTypedArraysBase
T
>
;
enum
class
CallerType
:
uint32_t
;
class
MOZ_STACK_CLASS
GlobalObject
{
public
:
GlobalObject
(
JSContext
*
aCx
JSObject
*
aObject
)
;
JSObject
*
Get
(
)
const
{
return
mGlobalJSObject
;
}
nsISupports
*
GetAsSupports
(
)
const
;
JSContext
*
Context
(
)
const
{
return
mCx
;
}
bool
Failed
(
)
const
{
return
!
Get
(
)
;
}
nsIPrincipal
*
GetSubjectPrincipal
(
)
const
;
dom
:
:
CallerType
CallerType
(
)
const
;
protected
:
JS
:
:
Rooted
<
JSObject
*
>
mGlobalJSObject
;
JSContext
*
mCx
;
mutable
nsISupports
*
MOZ_UNSAFE_REF
(
"
Valid
because
GlobalObject
is
a
stack
"
"
class
and
mGlobalObject
points
to
the
"
"
global
so
it
won
'
t
be
destroyed
as
long
"
"
as
GlobalObject
lives
on
the
stack
"
)
mGlobalObject
;
}
;
template
<
typename
T
typename
InternalType
>
class
Optional_base
{
public
:
Optional_base
(
)
=
default
;
Optional_base
(
Optional_base
&
&
)
=
default
;
Optional_base
&
operator
=
(
Optional_base
&
&
)
=
default
;
explicit
Optional_base
(
const
T
&
aValue
)
{
mImpl
.
emplace
(
aValue
)
;
}
explicit
Optional_base
(
T
&
&
aValue
)
{
mImpl
.
emplace
(
std
:
:
move
(
aValue
)
)
;
}
bool
operator
=
=
(
const
Optional_base
<
T
InternalType
>
&
aOther
)
const
{
return
mImpl
=
=
aOther
.
mImpl
;
}
bool
operator
!
=
(
const
Optional_base
<
T
InternalType
>
&
aOther
)
const
{
return
mImpl
!
=
aOther
.
mImpl
;
}
template
<
typename
T1
typename
T2
>
explicit
Optional_base
(
const
T1
&
aValue1
const
T2
&
aValue2
)
{
mImpl
.
emplace
(
aValue1
aValue2
)
;
}
bool
WasPassed
(
)
const
{
return
mImpl
.
isSome
(
)
;
}
template
<
typename
.
.
.
Args
>
InternalType
&
Construct
(
Args
&
&
.
.
.
aArgs
)
{
mImpl
.
emplace
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
*
mImpl
;
}
void
Reset
(
)
{
mImpl
.
reset
(
)
;
}
const
T
&
Value
(
)
const
{
return
*
mImpl
;
}
InternalType
&
Value
(
)
{
return
*
mImpl
;
}
const
InternalType
&
InternalValue
(
)
const
{
return
*
mImpl
;
}
private
:
Optional_base
(
const
Optional_base
&
other
)
=
delete
;
const
Optional_base
&
operator
=
(
const
Optional_base
&
other
)
=
delete
;
protected
:
Maybe
<
InternalType
>
mImpl
;
}
;
template
<
typename
T
>
class
Optional
:
public
Optional_base
<
T
T
>
{
public
:
MOZ_ALLOW_TEMPORARY
Optional
(
)
:
Optional_base
<
T
T
>
(
)
{
}
explicit
Optional
(
const
T
&
aValue
)
:
Optional_base
<
T
T
>
(
aValue
)
{
}
Optional
(
Optional
&
&
)
=
default
;
}
;
template
<
typename
T
>
class
Optional
<
JS
:
:
Handle
<
T
>
>
:
public
Optional_base
<
JS
:
:
Handle
<
T
>
JS
:
:
Rooted
<
T
>
>
{
public
:
MOZ_ALLOW_TEMPORARY
Optional
(
)
:
Optional_base
<
JS
:
:
Handle
<
T
>
JS
:
:
Rooted
<
T
>
>
(
)
{
}
explicit
Optional
(
JSContext
*
cx
)
:
Optional_base
<
JS
:
:
Handle
<
T
>
JS
:
:
Rooted
<
T
>
>
(
)
{
this
-
>
Construct
(
cx
)
;
}
Optional
(
JSContext
*
cx
const
T
&
aValue
)
:
Optional_base
<
JS
:
:
Handle
<
T
>
JS
:
:
Rooted
<
T
>
>
(
cx
aValue
)
{
}
JS
:
:
Handle
<
T
>
Value
(
)
const
{
return
*
this
-
>
mImpl
;
}
JS
:
:
Rooted
<
T
>
&
Value
(
)
{
return
*
this
-
>
mImpl
;
}
}
;
template
<
>
class
Optional
<
JSObject
*
>
:
public
Optional_base
<
JSObject
*
JSObject
*
>
{
public
:
Optional
(
)
=
default
;
explicit
Optional
(
JSObject
*
aValue
)
:
Optional_base
<
JSObject
*
JSObject
*
>
(
aValue
)
{
}
JSObject
*
&
Construct
(
)
{
return
Optional_base
<
JSObject
*
JSObject
*
>
:
:
Construct
(
static_cast
<
JSObject
*
>
(
nullptr
)
)
;
}
template
<
class
T1
>
JSObject
*
&
Construct
(
const
T1
&
t1
)
{
return
Optional_base
<
JSObject
*
JSObject
*
>
:
:
Construct
(
t1
)
;
}
}
;
template
<
>
class
Optional
<
JS
:
:
Value
>
{
private
:
Optional
(
)
=
delete
;
explicit
Optional
(
const
JS
:
:
Value
&
aValue
)
=
delete
;
}
;
template
<
typename
U
>
class
NonNull
;
template
<
typename
T
>
class
Optional
<
NonNull
<
T
>
>
:
public
Optional_base
<
T
NonNull
<
T
>
>
{
public
:
T
&
Value
(
)
const
{
return
*
this
-
>
mImpl
-
>
get
(
)
;
}
NonNull
<
T
>
&
Value
(
)
{
return
*
this
-
>
mImpl
;
}
}
;
template
<
typename
T
>
class
Optional
<
OwningNonNull
<
T
>
>
:
public
Optional_base
<
T
OwningNonNull
<
T
>
>
{
public
:
T
&
Value
(
)
const
{
return
*
this
-
>
mImpl
-
>
get
(
)
;
}
OwningNonNull
<
T
>
&
Value
(
)
{
return
*
this
-
>
mImpl
;
}
}
;
namespace
binding_detail
{
template
<
typename
CharT
>
struct
FakeString
;
}
template
<
typename
CharT
>
class
Optional
<
nsTSubstring
<
CharT
>
>
{
using
AString
=
nsTSubstring
<
CharT
>
;
public
:
Optional
(
)
:
mStr
(
nullptr
)
{
}
bool
WasPassed
(
)
const
{
return
!
!
mStr
;
}
void
operator
=
(
const
AString
*
str
)
{
MOZ_ASSERT
(
str
)
;
mStr
=
str
;
}
void
operator
=
(
const
binding_detail
:
:
FakeString
<
CharT
>
*
str
)
{
MOZ_ASSERT
(
str
)
;
mStr
=
reinterpret_cast
<
const
nsTString
<
CharT
>
*
>
(
str
)
;
}
const
AString
&
Value
(
)
const
{
MOZ_ASSERT
(
WasPassed
(
)
)
;
return
*
mStr
;
}
private
:
Optional
(
const
Optional
&
other
)
=
delete
;
const
Optional
&
operator
=
(
const
Optional
&
other
)
=
delete
;
const
AString
*
mStr
;
}
;
template
<
typename
T
>
inline
void
ImplCycleCollectionUnlink
(
Optional
<
T
>
&
aField
)
{
if
(
aField
.
WasPassed
(
)
)
{
ImplCycleCollectionUnlink
(
aField
.
Value
(
)
)
;
}
}
template
<
typename
T
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
Optional
<
T
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
if
(
aField
.
WasPassed
(
)
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
Value
(
)
aName
aFlags
)
;
}
}
template
<
class
T
>
class
NonNull
{
public
:
NonNull
(
)
#
ifdef
DEBUG
:
inited
(
false
)
#
endif
{
}
operator
T
&
(
)
const
{
MOZ_ASSERT
(
inited
)
;
MOZ_ASSERT
(
ptr
"
NonNull
<
T
>
was
set
to
null
"
)
;
return
*
ptr
;
}
operator
T
*
(
)
const
{
MOZ_ASSERT
(
inited
)
;
MOZ_ASSERT
(
ptr
"
NonNull
<
T
>
was
set
to
null
"
)
;
return
ptr
;
}
void
operator
=
(
T
*
t
)
{
ptr
=
t
;
MOZ_ASSERT
(
ptr
)
;
#
ifdef
DEBUG
inited
=
true
;
#
endif
}
template
<
typename
U
>
void
operator
=
(
U
*
t
)
{
ptr
=
t
-
>
ToAStringPtr
(
)
;
MOZ_ASSERT
(
ptr
)
;
#
ifdef
DEBUG
inited
=
true
;
#
endif
}
T
*
*
Slot
(
)
{
#
ifdef
DEBUG
inited
=
true
;
#
endif
return
&
ptr
;
}
T
*
Ptr
(
)
{
MOZ_ASSERT
(
inited
)
;
MOZ_ASSERT
(
ptr
"
NonNull
<
T
>
was
set
to
null
"
)
;
return
ptr
;
}
T
*
get
(
)
const
{
MOZ_ASSERT
(
inited
)
;
MOZ_ASSERT
(
ptr
)
;
return
ptr
;
}
protected
:
MOZ_INIT_OUTSIDE_CTOR
T
*
ptr
;
#
ifdef
DEBUG
bool
inited
;
#
endif
}
;
template
<
typename
T
>
class
Sequence
:
public
FallibleTArray
<
T
>
{
public
:
Sequence
(
)
:
FallibleTArray
<
T
>
(
)
{
}
MOZ_IMPLICIT
Sequence
(
FallibleTArray
<
T
>
&
&
aArray
)
:
FallibleTArray
<
T
>
(
std
:
:
move
(
aArray
)
)
{
}
MOZ_IMPLICIT
Sequence
(
nsTArray
<
T
>
&
&
aArray
)
:
FallibleTArray
<
T
>
(
std
:
:
move
(
aArray
)
)
{
}
Sequence
(
Sequence
&
&
)
=
default
;
Sequence
&
operator
=
(
Sequence
&
&
)
=
default
;
Sequence
(
const
Sequence
&
aOther
)
{
if
(
!
this
-
>
AppendElements
(
aOther
fallible
)
)
{
MOZ_CRASH
(
"
Out
of
memory
"
)
;
}
}
Sequence
&
operator
=
(
const
Sequence
&
aOther
)
{
if
(
this
!
=
&
aOther
)
{
this
-
>
Clear
(
)
;
if
(
!
this
-
>
AppendElements
(
aOther
fallible
)
)
{
MOZ_CRASH
(
"
Out
of
memory
"
)
;
}
}
return
*
this
;
}
}
;
inline
nsWrapperCache
*
GetWrapperCache
(
nsWrapperCache
*
cache
)
{
return
cache
;
}
inline
nsWrapperCache
*
GetWrapperCache
(
void
*
p
)
{
return
nullptr
;
}
template
<
template
<
typename
>
class
SmartPtr
typename
T
>
inline
nsWrapperCache
*
GetWrapperCache
(
const
SmartPtr
<
T
>
&
aObject
)
{
return
GetWrapperCache
(
aObject
.
get
(
)
)
;
}
enum
class
ReflectionScope
{
Content
NAC
UAWidget
}
;
struct
MOZ_STACK_CLASS
ParentObject
{
template
<
class
T
>
MOZ_IMPLICIT
ParentObject
(
T
*
aObject
)
:
mObject
(
ToSupports
(
aObject
)
)
mWrapperCache
(
GetWrapperCache
(
aObject
)
)
mReflectionScope
(
ReflectionScope
:
:
Content
)
{
}
template
<
class
T
template
<
typename
>
class
SmartPtr
>
MOZ_IMPLICIT
ParentObject
(
const
SmartPtr
<
T
>
&
aObject
)
:
mObject
(
aObject
.
get
(
)
)
mWrapperCache
(
GetWrapperCache
(
aObject
.
get
(
)
)
)
mReflectionScope
(
ReflectionScope
:
:
Content
)
{
}
ParentObject
(
nsISupports
*
aObject
nsWrapperCache
*
aCache
)
:
mObject
(
aObject
)
mWrapperCache
(
aCache
)
mReflectionScope
(
ReflectionScope
:
:
Content
)
{
}
nsISupports
*
const
MOZ_NON_OWNING_REF
mObject
;
nsWrapperCache
*
const
mWrapperCache
;
ReflectionScope
mReflectionScope
;
}
;
namespace
binding_detail
{
template
<
typename
T
>
class
AutoSequence
:
public
AutoTArray
<
T
16
>
{
public
:
AutoSequence
(
)
:
AutoTArray
<
T
16
>
(
)
{
}
operator
const
Sequence
<
T
>
&
(
)
const
{
return
*
reinterpret_cast
<
const
Sequence
<
T
>
*
>
(
this
)
;
}
}
;
}
enum
class
CallerType
:
uint32_t
{
System
NonSystem
}
;
class
SystemCallerGuarantee
{
public
:
operator
CallerType
(
)
const
{
return
CallerType
:
:
System
;
}
}
;
enum
class
DefineInterfaceProperty
{
No
CheckExposure
Always
}
;
class
ProtoAndIfaceCache
;
using
CreateInterfaceObjectsMethod
=
void
(
*
)
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
ProtoAndIfaceCache
&
DefineInterfaceProperty
aDefineOnGlobal
)
;
JS
:
:
Handle
<
JSObject
*
>
GetPerInterfaceObjectHandle
(
JSContext
*
aCx
size_t
aSlotId
CreateInterfaceObjectsMethod
aCreator
DefineInterfaceProperty
aDefineOnGlobal
)
;
namespace
binding_detail
{
template
<
typename
Enum
>
struct
EnumStrings
;
template
<
size_t
SlotIndex
size_t
XrayExpandoSlotIndex
size_t
Count
>
class
ReflectedHTMLAttributeSlots
;
}
}
}
#
endif
