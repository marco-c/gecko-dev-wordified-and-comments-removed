#
include
"
BindingUtils
.
h
"
#
include
<
algorithm
>
#
include
<
stdarg
.
h
>
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
UseCounter
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDOMGlobalPropertyInitializer
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsUTF8Utils
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
XrayWrapper
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLObjectElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLObjectElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLEmbedElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLEmbedElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
XULElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
XULFrameElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
XULPopupElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ResolveSystemBinding
.
h
"
#
include
"
mozilla
/
dom
/
WebIDLGlobalNameHash
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerScope
.
h
"
#
include
"
mozilla
/
dom
/
XrayExpandoClass
.
h
"
#
include
"
mozilla
/
jsipc
/
CrossProcessObjectWrappers
.
h
"
#
include
"
ipc
/
ErrorIPCUtils
.
h
"
#
include
"
mozilla
/
UseCounter
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
nsXULElement
.
h
"
namespace
mozilla
{
namespace
dom
{
#
define
HTML_TAG
(
_tag
_classname
_interfacename
)
\
namespace
HTML
#
#
_interfacename
#
#
Element_Binding
{
\
JSObject
*
GetConstructorObject
(
JSContext
*
)
;
\
}
#
define
HTML_OTHER
(
_tag
)
#
include
"
nsHTMLTagList
.
h
"
#
undef
HTML_TAG
#
undef
HTML_OTHER
typedef
JSObject
*
(
*
constructorGetterCallback
)
(
JSContext
*
)
;
#
define
HTML_TAG
(
_tag
_classname
_interfacename
)
HTML
#
#
_interfacename
#
#
Element_Binding
:
:
GetConstructorObject
#
define
HTML_OTHER
(
_tag
)
nullptr
static
const
constructorGetterCallback
sConstructorGetterCallback
[
]
=
{
HTMLUnknownElement_Binding
:
:
GetConstructorObject
#
include
"
nsHTMLTagList
.
h
"
#
undef
HTML_TAG
#
undef
HTML_OTHER
}
;
const
JSErrorFormatString
ErrorFormatString
[
]
=
{
#
define
MSG_DEF
(
_name
_argc
_exn
_str
)
\
{
#
_name
_str
_argc
_exn
}
#
include
"
mozilla
/
dom
/
Errors
.
msg
"
#
undef
MSG_DEF
}
;
#
define
MSG_DEF
(
_name
_argc
_exn
_str
)
\
static_assert
(
_argc
<
JS
:
:
MaxNumErrorArguments
\
#
_name
"
must
only
have
as
many
error
arguments
as
the
JS
engine
can
support
"
)
;
#
include
"
mozilla
/
dom
/
Errors
.
msg
"
#
undef
MSG_DEF
const
JSErrorFormatString
*
GetErrorMessage
(
void
*
aUserRef
const
unsigned
aErrorNumber
)
{
MOZ_ASSERT
(
aErrorNumber
<
ArrayLength
(
ErrorFormatString
)
)
;
return
&
ErrorFormatString
[
aErrorNumber
]
;
}
uint16_t
GetErrorArgCount
(
const
ErrNum
aErrorNumber
)
{
return
GetErrorMessage
(
nullptr
aErrorNumber
)
-
>
argCount
;
}
void
binding_detail
:
:
ThrowErrorMessage
(
JSContext
*
aCx
const
unsigned
aErrorNumber
.
.
.
)
{
va_list
ap
;
va_start
(
ap
aErrorNumber
)
;
JS_ReportErrorNumberUTF8VA
(
aCx
GetErrorMessage
nullptr
aErrorNumber
ap
)
;
va_end
(
ap
)
;
}
bool
ThrowInvalidThis
(
JSContext
*
aCx
const
JS
:
:
CallArgs
&
aArgs
bool
aSecurityError
const
char
*
aInterfaceName
)
{
NS_ConvertASCIItoUTF16
ifaceName
(
aInterfaceName
)
;
JS
:
:
Rooted
<
JSFunction
*
>
func
(
aCx
JS_ValueToFunction
(
aCx
aArgs
.
calleev
(
)
)
)
;
MOZ_ASSERT
(
func
)
;
JS
:
:
Rooted
<
JSString
*
>
funcName
(
aCx
JS_GetFunctionDisplayId
(
func
)
)
;
MOZ_ASSERT
(
funcName
)
;
nsAutoJSString
funcNameStr
;
if
(
!
funcNameStr
.
init
(
aCx
funcName
)
)
{
return
false
;
}
const
ErrNum
errorNumber
=
aSecurityError
?
MSG_METHOD_THIS_UNWRAPPING_DENIED
:
MSG_METHOD_THIS_DOES_NOT_IMPLEMENT_INTERFACE
;
MOZ_RELEASE_ASSERT
(
GetErrorArgCount
(
errorNumber
)
<
=
2
)
;
JS_ReportErrorNumberUC
(
aCx
GetErrorMessage
nullptr
static_cast
<
unsigned
>
(
errorNumber
)
funcNameStr
.
get
(
)
ifaceName
.
get
(
)
)
;
return
false
;
}
bool
ThrowInvalidThis
(
JSContext
*
aCx
const
JS
:
:
CallArgs
&
aArgs
bool
aSecurityError
prototypes
:
:
ID
aProtoId
)
{
return
ThrowInvalidThis
(
aCx
aArgs
aSecurityError
NamesOfInterfacesWithProtos
(
aProtoId
)
)
;
}
bool
ThrowNoSetterArg
(
JSContext
*
aCx
prototypes
:
:
ID
aProtoId
)
{
nsPrintfCString
errorMessage
(
"
%
s
attribute
setter
"
NamesOfInterfacesWithProtos
(
aProtoId
)
)
;
return
ThrowErrorMessage
(
aCx
MSG_MISSING_ARGUMENTS
errorMessage
.
get
(
)
)
;
}
}
namespace
binding_danger
{
template
<
typename
CleanupPolicy
>
struct
TErrorResult
<
CleanupPolicy
>
:
:
Message
{
Message
(
)
{
MOZ_COUNT_CTOR
(
TErrorResult
:
:
Message
)
;
}
~
Message
(
)
{
MOZ_COUNT_DTOR
(
TErrorResult
:
:
Message
)
;
}
nsTArray
<
nsString
>
mArgs
;
dom
:
:
ErrNum
mErrorNumber
;
bool
HasCorrectNumberOfArguments
(
)
{
return
GetErrorArgCount
(
mErrorNumber
)
=
=
mArgs
.
Length
(
)
;
}
bool
operator
=
=
(
const
TErrorResult
<
CleanupPolicy
>
:
:
Message
&
aRight
)
const
{
return
mErrorNumber
=
=
aRight
.
mErrorNumber
&
&
mArgs
=
=
aRight
.
mArgs
;
}
}
;
template
<
typename
CleanupPolicy
>
nsTArray
<
nsString
>
&
TErrorResult
<
CleanupPolicy
>
:
:
CreateErrorMessageHelper
(
const
dom
:
:
ErrNum
errorNumber
nsresult
errorType
)
{
AssertInOwningThread
(
)
;
mResult
=
errorType
;
Message
*
message
=
InitMessage
(
new
Message
(
)
)
;
message
-
>
mErrorNumber
=
errorNumber
;
return
message
-
>
mArgs
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SerializeMessage
(
IPC
:
:
Message
*
aMsg
)
const
{
using
namespace
IPC
;
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasMessage
)
;
MOZ_ASSERT
(
mExtra
.
mMessage
)
;
WriteParam
(
aMsg
mExtra
.
mMessage
-
>
mArgs
)
;
WriteParam
(
aMsg
mExtra
.
mMessage
-
>
mErrorNumber
)
;
}
template
<
typename
CleanupPolicy
>
bool
TErrorResult
<
CleanupPolicy
>
:
:
DeserializeMessage
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
)
{
using
namespace
IPC
;
AssertInOwningThread
(
)
;
nsAutoPtr
<
Message
>
readMessage
(
new
Message
(
)
)
;
if
(
!
ReadParam
(
aMsg
aIter
&
readMessage
-
>
mArgs
)
|
|
!
ReadParam
(
aMsg
aIter
&
readMessage
-
>
mErrorNumber
)
)
{
return
false
;
}
if
(
!
readMessage
-
>
HasCorrectNumberOfArguments
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
mUnionState
=
=
HasNothing
)
;
InitMessage
(
readMessage
.
forget
(
)
)
;
#
ifdef
DEBUG
mUnionState
=
HasMessage
;
#
endif
return
true
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SetPendingExceptionWithMessage
(
JSContext
*
aCx
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasMessage
)
;
MOZ_ASSERT
(
mExtra
.
mMessage
"
SetPendingExceptionWithMessage
(
)
can
be
called
only
once
"
)
;
Message
*
message
=
mExtra
.
mMessage
;
MOZ_RELEASE_ASSERT
(
message
-
>
HasCorrectNumberOfArguments
(
)
)
;
const
uint32_t
argCount
=
message
-
>
mArgs
.
Length
(
)
;
const
char16_t
*
args
[
JS
:
:
MaxNumErrorArguments
+
1
]
;
for
(
uint32_t
i
=
0
;
i
<
argCount
;
+
+
i
)
{
args
[
i
]
=
message
-
>
mArgs
.
ElementAt
(
i
)
.
get
(
)
;
}
args
[
argCount
]
=
nullptr
;
JS_ReportErrorNumberUCArray
(
aCx
dom
:
:
GetErrorMessage
nullptr
static_cast
<
unsigned
>
(
message
-
>
mErrorNumber
)
argCount
>
0
?
args
:
nullptr
)
;
ClearMessage
(
)
;
mResult
=
NS_OK
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
ClearMessage
(
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
IsErrorWithMessage
(
)
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasMessage
)
;
delete
mExtra
.
mMessage
;
mExtra
.
mMessage
=
nullptr
;
#
ifdef
DEBUG
mUnionState
=
HasNothing
;
#
endif
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
ThrowJSException
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
exn
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
mMightHaveUnreportedJSException
"
Why
didn
'
t
you
tell
us
you
planned
to
throw
a
JS
exception
?
"
)
;
ClearUnionData
(
)
;
JS
:
:
Value
&
exc
=
InitJSException
(
)
;
if
(
!
js
:
:
AddRawValueRoot
(
cx
&
exc
"
TErrorResult
:
:
mExtra
:
:
mJSException
"
)
)
{
mResult
=
NS_ERROR_OUT_OF_MEMORY
;
}
else
{
exc
=
exn
;
mResult
=
NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION
;
#
ifdef
DEBUG
mUnionState
=
HasJSException
;
#
endif
}
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SetPendingJSException
(
JSContext
*
cx
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
!
mMightHaveUnreportedJSException
"
Why
didn
'
t
you
tell
us
you
planned
to
handle
JS
exceptions
?
"
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasJSException
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
cx
mExtra
.
mJSException
)
;
if
(
JS_WrapValue
(
cx
&
exception
)
)
{
JS_SetPendingException
(
cx
exception
)
;
}
mExtra
.
mJSException
=
exception
;
js
:
:
RemoveRawValueRoot
(
cx
&
mExtra
.
mJSException
)
;
mResult
=
NS_OK
;
#
ifdef
DEBUG
mUnionState
=
HasNothing
;
#
endif
}
template
<
typename
CleanupPolicy
>
struct
TErrorResult
<
CleanupPolicy
>
:
:
DOMExceptionInfo
{
DOMExceptionInfo
(
nsresult
rv
const
nsACString
&
message
)
:
mMessage
(
message
)
mRv
(
rv
)
{
}
nsCString
mMessage
;
nsresult
mRv
;
bool
operator
=
=
(
const
TErrorResult
<
CleanupPolicy
>
:
:
DOMExceptionInfo
&
aRight
)
const
{
return
mRv
=
=
aRight
.
mRv
&
&
mMessage
=
=
aRight
.
mMessage
;
}
}
;
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SerializeDOMExceptionInfo
(
IPC
:
:
Message
*
aMsg
)
const
{
using
namespace
IPC
;
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasDOMExceptionInfo
)
;
MOZ_ASSERT
(
mExtra
.
mDOMExceptionInfo
)
;
WriteParam
(
aMsg
mExtra
.
mDOMExceptionInfo
-
>
mMessage
)
;
WriteParam
(
aMsg
mExtra
.
mDOMExceptionInfo
-
>
mRv
)
;
}
template
<
typename
CleanupPolicy
>
bool
TErrorResult
<
CleanupPolicy
>
:
:
DeserializeDOMExceptionInfo
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
)
{
using
namespace
IPC
;
AssertInOwningThread
(
)
;
nsCString
message
;
nsresult
rv
;
if
(
!
ReadParam
(
aMsg
aIter
&
message
)
|
|
!
ReadParam
(
aMsg
aIter
&
rv
)
)
{
return
false
;
}
MOZ_ASSERT
(
mUnionState
=
=
HasNothing
)
;
MOZ_ASSERT
(
IsDOMException
(
)
)
;
InitDOMExceptionInfo
(
new
DOMExceptionInfo
(
rv
message
)
)
;
#
ifdef
DEBUG
mUnionState
=
HasDOMExceptionInfo
;
#
endif
return
true
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
ThrowDOMException
(
nsresult
rv
const
nsACString
&
message
)
{
AssertInOwningThread
(
)
;
ClearUnionData
(
)
;
mResult
=
NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION
;
InitDOMExceptionInfo
(
new
DOMExceptionInfo
(
rv
message
)
)
;
#
ifdef
DEBUG
mUnionState
=
HasDOMExceptionInfo
;
#
endif
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SetPendingDOMException
(
JSContext
*
cx
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasDOMExceptionInfo
)
;
MOZ_ASSERT
(
mExtra
.
mDOMExceptionInfo
"
SetPendingDOMException
(
)
can
be
called
only
once
"
)
;
dom
:
:
Throw
(
cx
mExtra
.
mDOMExceptionInfo
-
>
mRv
mExtra
.
mDOMExceptionInfo
-
>
mMessage
)
;
ClearDOMExceptionInfo
(
)
;
mResult
=
NS_OK
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
ClearDOMExceptionInfo
(
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
IsDOMException
(
)
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasDOMExceptionInfo
)
;
delete
mExtra
.
mDOMExceptionInfo
;
mExtra
.
mDOMExceptionInfo
=
nullptr
;
#
ifdef
DEBUG
mUnionState
=
HasNothing
;
#
endif
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
ClearUnionData
(
)
{
AssertInOwningThread
(
)
;
if
(
IsJSException
(
)
)
{
JSContext
*
cx
=
dom
:
:
danger
:
:
GetJSContext
(
)
;
MOZ_ASSERT
(
cx
)
;
mExtra
.
mJSException
.
setUndefined
(
)
;
js
:
:
RemoveRawValueRoot
(
cx
&
mExtra
.
mJSException
)
;
#
ifdef
DEBUG
mUnionState
=
HasNothing
;
#
endif
}
else
if
(
IsErrorWithMessage
(
)
)
{
ClearMessage
(
)
;
}
else
if
(
IsDOMException
(
)
)
{
ClearDOMExceptionInfo
(
)
;
}
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SetPendingGenericErrorException
(
JSContext
*
cx
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
!
IsErrorWithMessage
(
)
)
;
MOZ_ASSERT
(
!
IsJSException
(
)
)
;
MOZ_ASSERT
(
!
IsDOMException
(
)
)
;
dom
:
:
Throw
(
cx
ErrorCode
(
)
)
;
mResult
=
NS_OK
;
}
template
<
typename
CleanupPolicy
>
TErrorResult
<
CleanupPolicy
>
&
TErrorResult
<
CleanupPolicy
>
:
:
operator
=
(
TErrorResult
<
CleanupPolicy
>
&
&
aRHS
)
{
AssertInOwningThread
(
)
;
aRHS
.
AssertInOwningThread
(
)
;
ClearUnionData
(
)
;
#
ifdef
DEBUG
mMightHaveUnreportedJSException
=
aRHS
.
mMightHaveUnreportedJSException
;
aRHS
.
mMightHaveUnreportedJSException
=
false
;
#
endif
if
(
aRHS
.
IsErrorWithMessage
(
)
)
{
InitMessage
(
aRHS
.
mExtra
.
mMessage
)
;
aRHS
.
mExtra
.
mMessage
=
nullptr
;
}
else
if
(
aRHS
.
IsJSException
(
)
)
{
JSContext
*
cx
=
dom
:
:
danger
:
:
GetJSContext
(
)
;
MOZ_ASSERT
(
cx
)
;
JS
:
:
Value
&
exn
=
InitJSException
(
)
;
if
(
!
js
:
:
AddRawValueRoot
(
cx
&
exn
"
TErrorResult
:
:
mExtra
:
:
mJSException
"
)
)
{
MOZ_CRASH
(
"
Could
not
root
mExtra
.
mJSException
we
'
re
about
to
OOM
"
)
;
}
mExtra
.
mJSException
=
aRHS
.
mExtra
.
mJSException
;
aRHS
.
mExtra
.
mJSException
.
setUndefined
(
)
;
js
:
:
RemoveRawValueRoot
(
cx
&
aRHS
.
mExtra
.
mJSException
)
;
}
else
if
(
aRHS
.
IsDOMException
(
)
)
{
InitDOMExceptionInfo
(
aRHS
.
mExtra
.
mDOMExceptionInfo
)
;
aRHS
.
mExtra
.
mDOMExceptionInfo
=
nullptr
;
}
else
{
mExtra
.
mMessage
=
aRHS
.
mExtra
.
mMessage
=
nullptr
;
}
#
ifdef
DEBUG
mUnionState
=
aRHS
.
mUnionState
;
aRHS
.
mUnionState
=
HasNothing
;
#
endif
mResult
=
aRHS
.
mResult
;
aRHS
.
mResult
=
NS_OK
;
return
*
this
;
}
template
<
typename
CleanupPolicy
>
bool
TErrorResult
<
CleanupPolicy
>
:
:
operator
=
=
(
const
ErrorResult
&
aRight
)
const
{
auto
right
=
reinterpret_cast
<
const
TErrorResult
<
CleanupPolicy
>
*
>
(
&
aRight
)
;
if
(
mResult
!
=
right
-
>
mResult
)
{
return
false
;
}
if
(
IsJSException
(
)
)
{
return
false
;
}
if
(
IsErrorWithMessage
(
)
)
{
return
*
mExtra
.
mMessage
=
=
*
right
-
>
mExtra
.
mMessage
;
}
if
(
IsDOMException
(
)
)
{
return
*
mExtra
.
mDOMExceptionInfo
=
=
*
right
-
>
mExtra
.
mDOMExceptionInfo
;
}
return
true
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
CloneTo
(
TErrorResult
&
aRv
)
const
{
AssertInOwningThread
(
)
;
aRv
.
AssertInOwningThread
(
)
;
aRv
.
ClearUnionData
(
)
;
aRv
.
mResult
=
mResult
;
#
ifdef
DEBUG
aRv
.
mMightHaveUnreportedJSException
=
mMightHaveUnreportedJSException
;
#
endif
if
(
IsErrorWithMessage
(
)
)
{
#
ifdef
DEBUG
aRv
.
mUnionState
=
HasMessage
;
#
endif
Message
*
message
=
aRv
.
InitMessage
(
new
Message
(
)
)
;
message
-
>
mArgs
=
mExtra
.
mMessage
-
>
mArgs
;
message
-
>
mErrorNumber
=
mExtra
.
mMessage
-
>
mErrorNumber
;
}
else
if
(
IsDOMException
(
)
)
{
#
ifdef
DEBUG
aRv
.
mUnionState
=
HasDOMExceptionInfo
;
#
endif
auto
*
exnInfo
=
new
DOMExceptionInfo
(
mExtra
.
mDOMExceptionInfo
-
>
mRv
mExtra
.
mDOMExceptionInfo
-
>
mMessage
)
;
aRv
.
InitDOMExceptionInfo
(
exnInfo
)
;
}
else
if
(
IsJSException
(
)
)
{
#
ifdef
DEBUG
aRv
.
mUnionState
=
HasJSException
;
#
endif
JSContext
*
cx
=
dom
:
:
danger
:
:
GetJSContext
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
cx
mExtra
.
mJSException
)
;
aRv
.
ThrowJSException
(
cx
exception
)
;
}
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SuppressException
(
)
{
AssertInOwningThread
(
)
;
WouldReportJSException
(
)
;
ClearUnionData
(
)
;
mResult
=
NS_OK
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
SetPendingException
(
JSContext
*
cx
)
{
AssertInOwningThread
(
)
;
if
(
IsUncatchableException
(
)
)
{
JS_ClearPendingException
(
cx
)
;
mResult
=
NS_OK
;
return
;
}
if
(
IsJSContextException
(
)
)
{
MOZ_ASSERT
(
JS_IsExceptionPending
(
cx
)
)
;
mResult
=
NS_OK
;
return
;
}
if
(
IsErrorWithMessage
(
)
)
{
SetPendingExceptionWithMessage
(
cx
)
;
return
;
}
if
(
IsJSException
(
)
)
{
SetPendingJSException
(
cx
)
;
return
;
}
if
(
IsDOMException
(
)
)
{
SetPendingDOMException
(
cx
)
;
return
;
}
SetPendingGenericErrorException
(
cx
)
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
StealExceptionFromJSContext
(
JSContext
*
cx
)
{
AssertInOwningThread
(
)
;
MOZ_ASSERT
(
mMightHaveUnreportedJSException
"
Why
didn
'
t
you
tell
us
you
planned
to
throw
a
JS
exception
?
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
cx
)
;
if
(
!
JS_GetPendingException
(
cx
&
exn
)
)
{
ThrowUncatchableException
(
)
;
return
;
}
ThrowJSException
(
cx
exn
)
;
JS_ClearPendingException
(
cx
)
;
}
template
<
typename
CleanupPolicy
>
void
TErrorResult
<
CleanupPolicy
>
:
:
NoteJSContextException
(
JSContext
*
aCx
)
{
AssertInOwningThread
(
)
;
if
(
JS_IsExceptionPending
(
aCx
)
)
{
mResult
=
NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT
;
}
else
{
mResult
=
NS_ERROR_UNCATCHABLE_EXCEPTION
;
}
}
template
class
TErrorResult
<
JustAssertCleanupPolicy
>
;
template
class
TErrorResult
<
AssertAndSuppressCleanupPolicy
>
;
template
class
TErrorResult
<
JustSuppressCleanupPolicy
>
;
template
class
TErrorResult
<
ThreadSafeJustSuppressCleanupPolicy
>
;
}
namespace
dom
{
bool
DefineConstants
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
ConstantSpec
*
cs
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
)
;
for
(
;
cs
-
>
name
;
+
+
cs
)
{
value
=
cs
-
>
value
;
bool
ok
=
JS_DefineProperty
(
cx
obj
cs
-
>
name
value
JSPROP_ENUMERATE
|
JSPROP_READONLY
|
JSPROP_PERMANENT
)
;
if
(
!
ok
)
{
return
false
;
}
}
return
true
;
}
static
inline
bool
Define
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
JSFunctionSpec
*
spec
)
{
return
JS_DefineFunctions
(
cx
obj
spec
)
;
}
static
inline
bool
Define
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
JSPropertySpec
*
spec
)
{
return
JS_DefineProperties
(
cx
obj
spec
)
;
}
static
inline
bool
Define
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
ConstantSpec
*
spec
)
{
return
DefineConstants
(
cx
obj
spec
)
;
}
template
<
typename
T
>
bool
DefinePrefable
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
Prefable
<
T
>
*
props
)
{
MOZ_ASSERT
(
props
)
;
MOZ_ASSERT
(
props
-
>
specs
)
;
do
{
if
(
props
-
>
isEnabled
(
cx
obj
)
)
{
if
(
!
Define
(
cx
obj
props
-
>
specs
)
)
{
return
false
;
}
}
}
while
(
(
+
+
props
)
-
>
specs
)
;
return
true
;
}
bool
DefineUnforgeableMethods
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
Prefable
<
const
JSFunctionSpec
>
*
props
)
{
return
DefinePrefable
(
cx
obj
props
)
;
}
bool
DefineUnforgeableAttributes
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
Prefable
<
const
JSPropertySpec
>
*
props
)
{
return
DefinePrefable
(
cx
obj
props
)
;
}
JSString
*
InterfaceObjectToString
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
bool
)
{
const
js
:
:
Class
*
clasp
=
js
:
:
GetObjectClass
(
aObject
)
;
MOZ_ASSERT
(
IsDOMIfaceAndProtoClass
(
clasp
)
)
;
const
DOMIfaceAndProtoJSClass
*
ifaceAndProtoJSClass
=
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
clasp
)
;
return
JS_NewStringCopyZ
(
aCx
ifaceAndProtoJSClass
-
>
mToString
)
;
}
bool
Constructor
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
const
JS
:
:
Value
&
v
=
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
CONSTRUCTOR_NATIVE_HOLDER_RESERVED_SLOT
)
;
const
JSNativeHolder
*
nativeHolder
=
static_cast
<
const
JSNativeHolder
*
>
(
v
.
toPrivate
(
)
)
;
return
(
nativeHolder
-
>
mNative
)
(
cx
argc
vp
)
;
}
static
JSObject
*
CreateConstructor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
const
char
*
name
const
JSNativeHolder
*
nativeHolder
unsigned
ctorNargs
)
{
JSFunction
*
fun
=
js
:
:
NewFunctionWithReserved
(
cx
Constructor
ctorNargs
JSFUN_CONSTRUCTOR
name
)
;
if
(
!
fun
)
{
return
nullptr
;
}
JSObject
*
constructor
=
JS_GetFunctionObject
(
fun
)
;
js
:
:
SetFunctionNativeReserved
(
constructor
CONSTRUCTOR_NATIVE_HOLDER_RESERVED_SLOT
js
:
:
PrivateValue
(
const_cast
<
JSNativeHolder
*
>
(
nativeHolder
)
)
)
;
return
constructor
;
}
static
bool
DefineConstructor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
const
char
*
name
JS
:
:
Handle
<
JSObject
*
>
constructor
)
{
bool
alreadyDefined
;
if
(
!
JS_AlreadyHasOwnProperty
(
cx
global
name
&
alreadyDefined
)
)
{
return
false
;
}
return
alreadyDefined
|
|
JS_DefineProperty
(
cx
global
name
constructor
JSPROP_RESOLVING
)
;
}
static
JSObject
*
CreateInterfaceObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
JS
:
:
Handle
<
JSObject
*
>
constructorProto
const
js
:
:
Class
*
constructorClass
unsigned
ctorNargs
const
NamedConstructor
*
namedConstructors
JS
:
:
Handle
<
JSObject
*
>
proto
const
NativeProperties
*
properties
const
NativeProperties
*
chromeOnlyProperties
const
char
*
name
bool
isChrome
bool
defineOnGlobal
)
{
JS
:
:
Rooted
<
JSObject
*
>
constructor
(
cx
)
;
MOZ_ASSERT
(
constructorProto
)
;
MOZ_ASSERT
(
constructorClass
)
;
constructor
=
JS_NewObjectWithGivenProto
(
cx
Jsvalify
(
constructorClass
)
constructorProto
)
;
if
(
!
constructor
)
{
return
nullptr
;
}
if
(
!
JS_DefineProperty
(
cx
constructor
"
length
"
ctorNargs
JSPROP_READONLY
)
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JSString
*
>
nameStr
(
cx
JS_AtomizeAndPinString
(
cx
name
)
)
;
if
(
!
nameStr
)
{
return
nullptr
;
}
if
(
!
JS_DefineProperty
(
cx
constructor
"
name
"
nameStr
JSPROP_READONLY
)
)
{
return
nullptr
;
}
if
(
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
constructorClass
)
-
>
wantsInterfaceHasInstance
)
{
JS
:
:
Rooted
<
jsid
>
hasInstanceId
(
cx
SYMBOL_TO_JSID
(
JS
:
:
GetWellKnownSymbol
(
cx
JS
:
:
SymbolCode
:
:
hasInstance
)
)
)
;
if
(
!
JS_DefineFunctionById
(
cx
constructor
hasInstanceId
InterfaceHasInstance
1
JSPROP_READONLY
|
JSPROP_PERMANENT
)
)
{
return
nullptr
;
}
if
(
isChrome
&
&
!
JS_DefineFunction
(
cx
constructor
"
isInstance
"
InterfaceIsInstance
1
0
)
)
{
return
nullptr
;
}
}
if
(
properties
)
{
if
(
properties
-
>
HasStaticMethods
(
)
&
&
!
DefinePrefable
(
cx
constructor
properties
-
>
StaticMethods
(
)
)
)
{
return
nullptr
;
}
if
(
properties
-
>
HasStaticAttributes
(
)
&
&
!
DefinePrefable
(
cx
constructor
properties
-
>
StaticAttributes
(
)
)
)
{
return
nullptr
;
}
if
(
properties
-
>
HasConstants
(
)
&
&
!
DefinePrefable
(
cx
constructor
properties
-
>
Constants
(
)
)
)
{
return
nullptr
;
}
}
if
(
chromeOnlyProperties
&
&
isChrome
)
{
if
(
chromeOnlyProperties
-
>
HasStaticMethods
(
)
&
&
!
DefinePrefable
(
cx
constructor
chromeOnlyProperties
-
>
StaticMethods
(
)
)
)
{
return
nullptr
;
}
if
(
chromeOnlyProperties
-
>
HasStaticAttributes
(
)
&
&
!
DefinePrefable
(
cx
constructor
chromeOnlyProperties
-
>
StaticAttributes
(
)
)
)
{
return
nullptr
;
}
if
(
chromeOnlyProperties
-
>
HasConstants
(
)
&
&
!
DefinePrefable
(
cx
constructor
chromeOnlyProperties
-
>
Constants
(
)
)
)
{
return
nullptr
;
}
}
if
(
proto
&
&
!
JS_LinkConstructorAndPrototype
(
cx
constructor
proto
)
)
{
return
nullptr
;
}
if
(
defineOnGlobal
&
&
!
DefineConstructor
(
cx
global
name
constructor
)
)
{
return
nullptr
;
}
if
(
namedConstructors
)
{
int
namedConstructorSlot
=
DOM_INTERFACE_SLOTS_BASE
;
while
(
namedConstructors
-
>
mName
)
{
JS
:
:
Rooted
<
JSObject
*
>
namedConstructor
(
cx
CreateConstructor
(
cx
global
namedConstructors
-
>
mName
&
namedConstructors
-
>
mHolder
namedConstructors
-
>
mNargs
)
)
;
if
(
!
namedConstructor
|
|
!
JS_DefineProperty
(
cx
namedConstructor
"
prototype
"
proto
JSPROP_PERMANENT
|
JSPROP_READONLY
)
|
|
(
defineOnGlobal
&
&
!
DefineConstructor
(
cx
global
namedConstructors
-
>
mName
namedConstructor
)
)
)
{
return
nullptr
;
}
js
:
:
SetReservedSlot
(
constructor
namedConstructorSlot
+
+
JS
:
:
ObjectValue
(
*
namedConstructor
)
)
;
+
+
namedConstructors
;
}
}
return
constructor
;
}
static
JSObject
*
CreateInterfacePrototypeObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
JS
:
:
Handle
<
JSObject
*
>
parentProto
const
js
:
:
Class
*
protoClass
const
NativeProperties
*
properties
const
NativeProperties
*
chromeOnlyProperties
const
char
*
const
*
unscopableNames
const
char
*
toStringTag
bool
isGlobal
)
{
JS
:
:
Rooted
<
JSObject
*
>
ourProto
(
cx
JS_NewObjectWithUniqueType
(
cx
Jsvalify
(
protoClass
)
parentProto
)
)
;
if
(
!
ourProto
|
|
(
!
isGlobal
&
&
!
DefineProperties
(
cx
ourProto
properties
chromeOnlyProperties
)
)
)
{
return
nullptr
;
}
if
(
unscopableNames
)
{
JS
:
:
Rooted
<
JSObject
*
>
unscopableObj
(
cx
JS_NewObjectWithGivenProto
(
cx
nullptr
nullptr
)
)
;
if
(
!
unscopableObj
)
{
return
nullptr
;
}
for
(
;
*
unscopableNames
;
+
+
unscopableNames
)
{
if
(
!
JS_DefineProperty
(
cx
unscopableObj
*
unscopableNames
JS
:
:
TrueHandleValue
JSPROP_ENUMERATE
)
)
{
return
nullptr
;
}
}
JS
:
:
Rooted
<
jsid
>
unscopableId
(
cx
SYMBOL_TO_JSID
(
JS
:
:
GetWellKnownSymbol
(
cx
JS
:
:
SymbolCode
:
:
unscopables
)
)
)
;
if
(
!
JS_DefinePropertyById
(
cx
ourProto
unscopableId
unscopableObj
JSPROP_READONLY
)
)
{
return
nullptr
;
}
}
if
(
toStringTag
)
{
JS
:
:
Rooted
<
JSString
*
>
toStringTagStr
(
cx
JS_NewStringCopyZ
(
cx
toStringTag
)
)
;
if
(
!
toStringTagStr
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
jsid
>
toStringTagId
(
cx
SYMBOL_TO_JSID
(
JS
:
:
GetWellKnownSymbol
(
cx
JS
:
:
SymbolCode
:
:
toStringTag
)
)
)
;
if
(
!
JS_DefinePropertyById
(
cx
ourProto
toStringTagId
toStringTagStr
JSPROP_READONLY
)
)
{
return
nullptr
;
}
}
return
ourProto
;
}
bool
DefineProperties
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
NativeProperties
*
properties
const
NativeProperties
*
chromeOnlyProperties
)
{
if
(
properties
)
{
if
(
properties
-
>
HasMethods
(
)
&
&
!
DefinePrefable
(
cx
obj
properties
-
>
Methods
(
)
)
)
{
return
false
;
}
if
(
properties
-
>
HasAttributes
(
)
&
&
!
DefinePrefable
(
cx
obj
properties
-
>
Attributes
(
)
)
)
{
return
false
;
}
if
(
properties
-
>
HasConstants
(
)
&
&
!
DefinePrefable
(
cx
obj
properties
-
>
Constants
(
)
)
)
{
return
false
;
}
}
if
(
chromeOnlyProperties
)
{
if
(
chromeOnlyProperties
-
>
HasMethods
(
)
&
&
!
DefinePrefable
(
cx
obj
chromeOnlyProperties
-
>
Methods
(
)
)
)
{
return
false
;
}
if
(
chromeOnlyProperties
-
>
HasAttributes
(
)
&
&
!
DefinePrefable
(
cx
obj
chromeOnlyProperties
-
>
Attributes
(
)
)
)
{
return
false
;
}
if
(
chromeOnlyProperties
-
>
HasConstants
(
)
&
&
!
DefinePrefable
(
cx
obj
chromeOnlyProperties
-
>
Constants
(
)
)
)
{
return
false
;
}
}
return
true
;
}
void
CreateInterfaceObjects
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
JS
:
:
Handle
<
JSObject
*
>
protoProto
const
js
:
:
Class
*
protoClass
JS
:
:
Heap
<
JSObject
*
>
*
protoCache
const
char
*
toStringTag
JS
:
:
Handle
<
JSObject
*
>
constructorProto
const
js
:
:
Class
*
constructorClass
unsigned
ctorNargs
const
NamedConstructor
*
namedConstructors
JS
:
:
Heap
<
JSObject
*
>
*
constructorCache
const
NativeProperties
*
properties
const
NativeProperties
*
chromeOnlyProperties
const
char
*
name
bool
defineOnGlobal
const
char
*
const
*
unscopableNames
bool
isGlobal
)
{
MOZ_ASSERT
(
protoClass
|
|
constructorClass
"
Need
at
least
one
class
!
"
)
;
MOZ_ASSERT
(
!
(
(
properties
&
&
(
properties
-
>
HasMethods
(
)
|
|
properties
-
>
HasAttributes
(
)
)
)
|
|
(
chromeOnlyProperties
&
&
(
chromeOnlyProperties
-
>
HasMethods
(
)
|
|
chromeOnlyProperties
-
>
HasAttributes
(
)
)
)
)
|
|
protoClass
"
Methods
or
properties
but
no
protoClass
!
"
)
;
MOZ_ASSERT
(
!
(
(
properties
&
&
(
properties
-
>
HasStaticMethods
(
)
|
|
properties
-
>
HasStaticAttributes
(
)
)
)
|
|
(
chromeOnlyProperties
&
&
(
chromeOnlyProperties
-
>
HasStaticMethods
(
)
|
|
chromeOnlyProperties
-
>
HasStaticAttributes
(
)
)
)
)
|
|
constructorClass
"
Static
methods
but
no
constructorClass
!
"
)
;
MOZ_ASSERT
(
bool
(
name
)
=
=
bool
(
constructorClass
)
"
Must
have
name
precisely
when
we
have
an
interface
object
"
)
;
MOZ_ASSERT
(
!
protoClass
=
=
!
protoCache
"
If
and
only
if
there
is
an
interface
prototype
object
we
need
"
"
to
cache
it
"
)
;
MOZ_ASSERT
(
bool
(
constructorClass
)
=
=
bool
(
constructorCache
)
"
If
and
only
if
there
is
an
interface
object
we
need
to
cache
"
"
it
"
)
;
MOZ_ASSERT
(
constructorProto
|
|
!
constructorClass
"
Must
have
a
constructor
proto
if
we
plan
to
create
a
constructor
"
"
object
"
)
;
MOZ_ASSERT
(
protoClass
|
|
!
toStringTag
"
Must
have
a
prototype
object
if
we
have
a
toStringTag
"
)
;
bool
isChrome
=
nsContentUtils
:
:
ThreadsafeIsSystemCaller
(
cx
)
;
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
protoClass
)
{
proto
=
CreateInterfacePrototypeObject
(
cx
global
protoProto
protoClass
properties
isChrome
?
chromeOnlyProperties
:
nullptr
unscopableNames
toStringTag
isGlobal
)
;
if
(
!
proto
)
{
return
;
}
*
protoCache
=
proto
;
}
else
{
MOZ_ASSERT
(
!
proto
)
;
}
JSObject
*
interface
;
if
(
constructorClass
)
{
interface
=
CreateInterfaceObject
(
cx
global
constructorProto
constructorClass
ctorNargs
namedConstructors
proto
properties
chromeOnlyProperties
name
isChrome
defineOnGlobal
)
;
if
(
!
interface
)
{
if
(
protoCache
)
{
*
protoCache
=
nullptr
;
}
return
;
}
*
constructorCache
=
interface
;
}
}
static
bool
NativeInterface2JSObjectAndThrowIfFailed
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aScope
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
xpcObjectHelper
&
aHelper
const
nsIID
*
aIID
bool
aAllowNativeWrapper
)
{
js
:
:
AssertSameCompartment
(
aCx
aScope
)
;
nsresult
rv
;
nsWrapperCache
*
cache
=
aHelper
.
GetWrapperCache
(
)
;
if
(
cache
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
cache
-
>
GetWrapper
(
)
)
;
if
(
!
obj
)
{
obj
=
cache
-
>
WrapObject
(
aCx
nullptr
)
;
if
(
!
obj
)
{
return
Throw
(
aCx
NS_ERROR_UNEXPECTED
)
;
}
}
if
(
aAllowNativeWrapper
&
&
!
JS_WrapObject
(
aCx
&
obj
)
)
{
return
false
;
}
aRetval
.
setObject
(
*
obj
)
;
return
true
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
XPCConvert
:
:
NativeInterface2JSObject
(
aRetval
aHelper
aIID
aAllowNativeWrapper
&
rv
)
)
{
if
(
!
JS_IsExceptionPending
(
aCx
)
)
{
Throw
(
aCx
NS_FAILED
(
rv
)
?
rv
:
NS_ERROR_UNEXPECTED
)
;
}
return
false
;
}
return
true
;
}
bool
TryPreserveWrapper
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsDOMObject
(
obj
)
)
;
if
(
nsISupports
*
native
=
UnwrapDOMObjectToISupports
(
obj
)
)
{
nsWrapperCache
*
cache
=
nullptr
;
CallQueryInterface
(
native
&
cache
)
;
if
(
cache
)
{
cache
-
>
PreserveWrapper
(
native
)
;
}
return
true
;
}
const
DOMJSClass
*
domClass
=
GetDOMClass
(
obj
)
;
return
domClass
&
&
!
domClass
-
>
mParticipant
;
}
bool
InstanceClassHasProtoAtDepth
(
const
js
:
:
Class
*
clasp
uint32_t
protoID
uint32_t
depth
)
{
const
DOMJSClass
*
domClass
=
DOMJSClass
:
:
FromJSClass
(
clasp
)
;
return
static_cast
<
uint32_t
>
(
domClass
-
>
mInterfaceChain
[
depth
]
)
=
=
protoID
;
}
bool
XPCOMObjectToJsval
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scope
xpcObjectHelper
&
helper
const
nsIID
*
iid
bool
allowNativeWrapper
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
NativeInterface2JSObjectAndThrowIfFailed
(
cx
scope
rval
helper
iid
allowNativeWrapper
)
;
}
bool
VariantToJsval
(
JSContext
*
aCx
nsIVariant
*
aVariant
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
{
nsresult
rv
;
if
(
!
XPCVariant
:
:
VariantDataToJS
(
aVariant
&
rv
aRetval
)
)
{
if
(
!
JS_IsExceptionPending
(
aCx
)
)
{
Throw
(
aCx
NS_FAILED
(
rv
)
?
rv
:
NS_ERROR_UNEXPECTED
)
;
}
return
false
;
}
return
true
;
}
static
int
CompareIdsAtIndices
(
const
void
*
aElement1
const
void
*
aElement2
void
*
aClosure
)
{
const
uint16_t
index1
=
*
static_cast
<
const
uint16_t
*
>
(
aElement1
)
;
const
uint16_t
index2
=
*
static_cast
<
const
uint16_t
*
>
(
aElement2
)
;
const
PropertyInfo
*
infos
=
static_cast
<
PropertyInfo
*
>
(
aClosure
)
;
MOZ_ASSERT
(
JSID_BITS
(
infos
[
index1
]
.
Id
(
)
)
!
=
JSID_BITS
(
infos
[
index2
]
.
Id
(
)
)
)
;
return
JSID_BITS
(
infos
[
index1
]
.
Id
(
)
)
<
JSID_BITS
(
infos
[
index2
]
.
Id
(
)
)
?
-
1
:
1
;
}
template
<
typename
SpecT
>
static
bool
InitIdsInternal
(
JSContext
*
cx
const
Prefable
<
SpecT
>
*
pref
PropertyInfo
*
infos
PropertyType
type
)
{
MOZ_ASSERT
(
pref
)
;
MOZ_ASSERT
(
pref
-
>
specs
)
;
uint32_t
prefIndex
=
0
;
do
{
const
SpecT
*
spec
=
pref
-
>
specs
;
uint32_t
specIndex
=
0
;
do
{
jsid
id
;
if
(
!
JS
:
:
PropertySpecNameToPermanentId
(
cx
spec
-
>
name
&
id
)
)
{
return
false
;
}
infos
-
>
SetId
(
id
)
;
infos
-
>
type
=
type
;
infos
-
>
prefIndex
=
prefIndex
;
infos
-
>
specIndex
=
specIndex
+
+
;
+
+
infos
;
}
while
(
(
+
+
spec
)
-
>
name
)
;
+
+
prefIndex
;
}
while
(
(
+
+
pref
)
-
>
specs
)
;
return
true
;
}
#
define
INIT_IDS_IF_DEFINED
(
TypeName
)
{
\
if
(
nativeProperties
-
>
Has
#
#
TypeName
#
#
s
(
)
&
&
\
!
InitIdsInternal
(
cx
\
nativeProperties
-
>
TypeName
#
#
s
(
)
\
nativeProperties
-
>
TypeName
#
#
PropertyInfos
(
)
\
e
#
#
TypeName
)
)
{
\
return
false
;
\
}
\
}
bool
InitIds
(
JSContext
*
cx
const
NativeProperties
*
nativeProperties
)
{
INIT_IDS_IF_DEFINED
(
StaticMethod
)
;
INIT_IDS_IF_DEFINED
(
StaticAttribute
)
;
INIT_IDS_IF_DEFINED
(
Method
)
;
INIT_IDS_IF_DEFINED
(
Attribute
)
;
INIT_IDS_IF_DEFINED
(
UnforgeableMethod
)
;
INIT_IDS_IF_DEFINED
(
UnforgeableAttribute
)
;
INIT_IDS_IF_DEFINED
(
Constant
)
;
uint16_t
*
indices
=
nativeProperties
-
>
sortedPropertyIndices
;
for
(
unsigned
int
i
=
0
;
i
<
nativeProperties
-
>
propertyInfoCount
;
+
+
i
)
{
indices
[
i
]
=
i
;
}
NS_QuickSort
(
indices
nativeProperties
-
>
propertyInfoCount
sizeof
(
uint16_t
)
CompareIdsAtIndices
const_cast
<
PropertyInfo
*
>
(
nativeProperties
-
>
PropertyInfos
(
)
)
)
;
return
true
;
}
#
undef
INIT_IDS_IF_DEFINED
bool
QueryInterface
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
thisv
(
)
.
isObject
(
)
)
{
JS_ReportErrorASCII
(
cx
"
QueryInterface
called
on
incompatible
non
-
object
"
)
;
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
origObj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
js
:
:
CheckedUnwrap
(
origObj
false
)
)
;
if
(
!
obj
)
{
JS_ReportErrorASCII
(
cx
"
Permission
denied
to
access
object
"
)
;
return
false
;
}
nsCOMPtr
<
nsISupports
>
native
=
UnwrapDOMObjectToISupports
(
obj
)
;
if
(
!
native
)
{
return
Throw
(
cx
NS_ERROR_FAILURE
)
;
}
if
(
argc
<
1
)
{
return
Throw
(
cx
NS_ERROR_XPC_NOT_ENOUGH_ARGS
)
;
}
if
(
!
args
[
0
]
.
isObject
(
)
)
{
return
Throw
(
cx
NS_ERROR_XPC_BAD_CONVERT_JS
)
;
}
nsCOMPtr
<
nsIJSID
>
iid
;
obj
=
&
args
[
0
]
.
toObject
(
)
;
if
(
NS_FAILED
(
UnwrapArg
<
nsIJSID
>
(
cx
obj
getter_AddRefs
(
iid
)
)
)
)
{
return
Throw
(
cx
NS_ERROR_XPC_BAD_CONVERT_JS
)
;
}
MOZ_ASSERT
(
iid
)
;
if
(
iid
-
>
GetID
(
)
-
>
Equals
(
NS_GET_IID
(
nsIClassInfo
)
)
)
{
nsresult
rv
;
nsCOMPtr
<
nsIClassInfo
>
ci
=
do_QueryInterface
(
native
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Throw
(
cx
rv
)
;
}
return
WrapObject
(
cx
ci
&
NS_GET_IID
(
nsIClassInfo
)
args
.
rval
(
)
)
;
}
nsCOMPtr
<
nsISupports
>
unused
;
nsresult
rv
=
native
-
>
QueryInterface
(
*
iid
-
>
GetID
(
)
getter_AddRefs
(
unused
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Throw
(
cx
rv
)
;
}
args
.
rval
(
)
.
set
(
args
.
thisv
(
)
)
;
return
true
;
}
void
GetInterfaceImpl
(
JSContext
*
aCx
nsIInterfaceRequestor
*
aRequestor
nsWrapperCache
*
aCache
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
const
nsID
*
iid
=
aIID
-
>
GetID
(
)
;
RefPtr
<
nsISupports
>
result
;
aError
=
aRequestor
-
>
GetInterface
(
*
iid
getter_AddRefs
(
result
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
if
(
!
WrapObject
(
aCx
result
iid
aRetval
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
bool
ThrowingConstructor
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
return
ThrowErrorMessage
(
cx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
bool
ThrowConstructorWithoutNew
(
JSContext
*
cx
const
char
*
name
)
{
return
ThrowErrorMessage
(
cx
MSG_CONSTRUCTOR_WITHOUT_NEW
name
)
;
}
inline
const
NativePropertyHooks
*
GetNativePropertyHooksFromConstructorFunction
(
JS
:
:
Handle
<
JSObject
*
>
obj
)
{
MOZ_ASSERT
(
JS_IsNativeFunction
(
obj
Constructor
)
)
;
const
JS
:
:
Value
&
v
=
js
:
:
GetFunctionNativeReserved
(
obj
CONSTRUCTOR_NATIVE_HOLDER_RESERVED_SLOT
)
;
const
JSNativeHolder
*
nativeHolder
=
static_cast
<
const
JSNativeHolder
*
>
(
v
.
toPrivate
(
)
)
;
return
nativeHolder
-
>
mPropertyHooks
;
}
inline
const
NativePropertyHooks
*
GetNativePropertyHooks
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
DOMObjectType
&
type
)
{
const
js
:
:
Class
*
clasp
=
js
:
:
GetObjectClass
(
obj
)
;
const
DOMJSClass
*
domClass
=
GetDOMClass
(
clasp
)
;
if
(
domClass
)
{
bool
isGlobal
=
(
clasp
-
>
flags
&
JSCLASS_DOM_GLOBAL
)
!
=
0
;
type
=
isGlobal
?
eGlobalInstance
:
eInstance
;
return
domClass
-
>
mNativeHooks
;
}
if
(
JS_ObjectIsFunction
(
cx
obj
)
)
{
type
=
eInterface
;
return
GetNativePropertyHooksFromConstructorFunction
(
obj
)
;
}
MOZ_ASSERT
(
IsDOMIfaceAndProtoClass
(
js
:
:
GetObjectClass
(
obj
)
)
)
;
const
DOMIfaceAndProtoJSClass
*
ifaceAndProtoJSClass
=
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
js
:
:
GetObjectClass
(
obj
)
)
;
type
=
ifaceAndProtoJSClass
-
>
mType
;
return
ifaceAndProtoJSClass
-
>
mNativeHooks
;
}
static
JSObject
*
XrayCreateFunction
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JSNativeWrapper
native
unsigned
nargs
JS
:
:
Handle
<
jsid
>
id
)
{
JSFunction
*
fun
;
if
(
JSID_IS_STRING
(
id
)
)
{
fun
=
js
:
:
NewFunctionByIdWithReserved
(
cx
native
.
op
nargs
0
id
)
;
}
else
{
fun
=
js
:
:
NewFunctionWithReserved
(
cx
native
.
op
nargs
0
nullptr
)
;
}
if
(
!
fun
)
{
return
nullptr
;
}
SET_JITINFO
(
fun
native
.
info
)
;
JSObject
*
obj
=
JS_GetFunctionObject
(
fun
)
;
js
:
:
SetFunctionNativeReserved
(
obj
XRAY_DOM_FUNCTION_PARENT_WRAPPER_SLOT
JS
:
:
ObjectValue
(
*
wrapper
)
)
;
#
ifdef
DEBUG
js
:
:
SetFunctionNativeReserved
(
obj
XRAY_DOM_FUNCTION_NATIVE_SLOT_FOR_SELF
JS
:
:
ObjectValue
(
*
obj
)
)
;
#
endif
return
obj
;
}
struct
IdToIndexComparator
{
const
jsid
&
mId
;
const
PropertyInfo
*
mInfos
;
explicit
IdToIndexComparator
(
const
jsid
&
aId
const
PropertyInfo
*
aInfos
)
:
mId
(
aId
)
mInfos
(
aInfos
)
{
}
int
operator
(
)
(
const
uint16_t
aIndex
)
const
{
if
(
JSID_BITS
(
mId
)
=
=
JSID_BITS
(
mInfos
[
aIndex
]
.
Id
(
)
)
)
{
return
0
;
}
return
JSID_BITS
(
mId
)
<
JSID_BITS
(
mInfos
[
aIndex
]
.
Id
(
)
)
?
-
1
:
1
;
}
}
;
static
const
PropertyInfo
*
XrayFindOwnPropertyInfo
(
JSContext
*
cx
JS
:
:
Handle
<
jsid
>
id
const
NativeProperties
*
nativeProperties
)
{
if
(
MOZ_UNLIKELY
(
nativeProperties
-
>
iteratorAliasMethodIndex
>
=
0
)
&
&
id
=
=
SYMBOL_TO_JSID
(
JS
:
:
GetWellKnownSymbol
(
cx
JS
:
:
SymbolCode
:
:
iterator
)
)
)
{
return
nativeProperties
-
>
MethodPropertyInfos
(
)
+
nativeProperties
-
>
iteratorAliasMethodIndex
;
}
size_t
idx
;
const
uint16_t
*
sortedPropertyIndices
=
nativeProperties
-
>
sortedPropertyIndices
;
const
PropertyInfo
*
propertyInfos
=
nativeProperties
-
>
PropertyInfos
(
)
;
if
(
BinarySearchIf
(
sortedPropertyIndices
0
nativeProperties
-
>
propertyInfoCount
IdToIndexComparator
(
id
propertyInfos
)
&
idx
)
)
{
return
propertyInfos
+
sortedPropertyIndices
[
idx
]
;
}
return
nullptr
;
}
static
bool
XrayResolveAttribute
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
const
Prefable
<
const
JSPropertySpec
>
&
pref
const
JSPropertySpec
&
attrSpec
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
bool
&
cacheOnHolder
)
{
if
(
!
pref
.
isEnabled
(
cx
obj
)
)
{
return
true
;
}
cacheOnHolder
=
true
;
desc
.
setAttributes
(
attrSpec
.
flags
)
;
JS
:
:
Rooted
<
JSObject
*
>
funobj
(
cx
XrayCreateFunction
(
cx
wrapper
attrSpec
.
accessors
.
getter
.
native
0
id
)
)
;
if
(
!
funobj
)
return
false
;
desc
.
setGetterObject
(
funobj
)
;
desc
.
attributesRef
(
)
|
=
JSPROP_GETTER
;
if
(
attrSpec
.
accessors
.
setter
.
native
.
op
)
{
funobj
=
XrayCreateFunction
(
cx
wrapper
attrSpec
.
accessors
.
setter
.
native
1
id
)
;
if
(
!
funobj
)
return
false
;
desc
.
setSetterObject
(
funobj
)
;
desc
.
attributesRef
(
)
|
=
JSPROP_SETTER
;
}
else
{
desc
.
setSetter
(
nullptr
)
;
}
desc
.
object
(
)
.
set
(
wrapper
)
;
desc
.
value
(
)
.
setUndefined
(
)
;
return
true
;
}
static
bool
XrayResolveMethod
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
const
Prefable
<
const
JSFunctionSpec
>
&
pref
const
JSFunctionSpec
&
methodSpec
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
bool
&
cacheOnHolder
)
{
if
(
!
pref
.
isEnabled
(
cx
obj
)
)
{
return
true
;
}
cacheOnHolder
=
true
;
JSObject
*
funobj
;
if
(
methodSpec
.
selfHostedName
)
{
JSFunction
*
fun
=
JS
:
:
GetSelfHostedFunction
(
cx
methodSpec
.
selfHostedName
id
methodSpec
.
nargs
)
;
if
(
!
fun
)
{
return
false
;
}
MOZ_ASSERT
(
!
methodSpec
.
call
.
op
"
Bad
FunctionSpec
declaration
:
non
-
null
native
"
)
;
MOZ_ASSERT
(
!
methodSpec
.
call
.
info
"
Bad
FunctionSpec
declaration
:
non
-
null
jitinfo
"
)
;
funobj
=
JS_GetFunctionObject
(
fun
)
;
}
else
{
funobj
=
XrayCreateFunction
(
cx
wrapper
methodSpec
.
call
methodSpec
.
nargs
id
)
;
if
(
!
funobj
)
{
return
false
;
}
}
desc
.
value
(
)
.
setObject
(
*
funobj
)
;
desc
.
setAttributes
(
methodSpec
.
flags
)
;
desc
.
object
(
)
.
set
(
wrapper
)
;
desc
.
setSetter
(
nullptr
)
;
desc
.
setGetter
(
nullptr
)
;
return
true
;
}
static
bool
XrayResolveConstant
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
const
Prefable
<
const
ConstantSpec
>
&
pref
const
ConstantSpec
&
constantSpec
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
bool
&
cacheOnHolder
)
{
if
(
!
pref
.
isEnabled
(
cx
obj
)
)
{
return
true
;
}
cacheOnHolder
=
true
;
desc
.
setAttributes
(
JSPROP_ENUMERATE
|
JSPROP_READONLY
|
JSPROP_PERMANENT
)
;
desc
.
object
(
)
.
set
(
wrapper
)
;
desc
.
value
(
)
.
set
(
constantSpec
.
value
)
;
return
true
;
}
#
define
RESOLVE_CASE
(
PropType
SpecType
Resolver
)
\
case
e
#
#
PropType
:
{
\
MOZ_ASSERT
(
nativeProperties
-
>
Has
#
#
PropType
#
#
s
(
)
)
;
\
const
Prefable
<
const
SpecType
>
&
pref
=
\
nativeProperties
-
>
PropType
#
#
s
(
)
[
propertyInfo
.
prefIndex
]
;
\
return
Resolver
(
cx
wrapper
obj
id
pref
\
pref
.
specs
[
propertyInfo
.
specIndex
]
desc
cacheOnHolder
)
;
\
}
static
bool
XrayResolveProperty
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
bool
&
cacheOnHolder
DOMObjectType
type
const
NativeProperties
*
nativeProperties
const
PropertyInfo
&
propertyInfo
)
{
MOZ_ASSERT
(
type
!
=
eGlobalInterfacePrototype
)
;
switch
(
propertyInfo
.
type
)
{
case
eStaticMethod
:
case
eStaticAttribute
:
if
(
type
!
=
eInterface
)
{
return
true
;
}
break
;
case
eMethod
:
case
eAttribute
:
if
(
type
!
=
eGlobalInstance
&
&
type
!
=
eInterfacePrototype
)
{
return
true
;
}
break
;
case
eUnforgeableMethod
:
case
eUnforgeableAttribute
:
if
(
!
IsInstance
(
type
)
)
{
return
true
;
}
break
;
case
eConstant
:
if
(
IsInstance
(
type
)
)
{
return
true
;
}
break
;
}
switch
(
propertyInfo
.
type
)
{
RESOLVE_CASE
(
StaticMethod
JSFunctionSpec
XrayResolveMethod
)
RESOLVE_CASE
(
StaticAttribute
JSPropertySpec
XrayResolveAttribute
)
RESOLVE_CASE
(
Method
JSFunctionSpec
XrayResolveMethod
)
RESOLVE_CASE
(
Attribute
JSPropertySpec
XrayResolveAttribute
)
RESOLVE_CASE
(
UnforgeableMethod
JSFunctionSpec
XrayResolveMethod
)
RESOLVE_CASE
(
UnforgeableAttribute
JSPropertySpec
XrayResolveAttribute
)
RESOLVE_CASE
(
Constant
ConstantSpec
XrayResolveConstant
)
}
return
true
;
}
#
undef
RESOLVE_CASE
static
bool
ResolvePrototypeOrConstructor
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
size_t
protoAndIfaceCacheIndex
unsigned
attrs
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
bool
&
cacheOnHolder
)
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
JS
:
:
GetNonCCWObjectGlobal
(
obj
)
)
;
{
JSAutoRealm
ar
(
cx
global
)
;
ProtoAndIfaceCache
&
protoAndIfaceCache
=
*
GetProtoAndIfaceCache
(
global
)
;
JSObject
*
protoOrIface
=
protoAndIfaceCache
.
EntrySlotMustExist
(
protoAndIfaceCacheIndex
)
;
MOZ_RELEASE_ASSERT
(
protoOrIface
"
How
can
this
object
not
exist
?
"
)
;
cacheOnHolder
=
true
;
desc
.
object
(
)
.
set
(
wrapper
)
;
desc
.
setAttributes
(
attrs
)
;
desc
.
setGetter
(
nullptr
)
;
desc
.
setSetter
(
nullptr
)
;
desc
.
value
(
)
.
set
(
JS
:
:
ObjectValue
(
*
protoOrIface
)
)
;
}
return
JS_WrapPropertyDescriptor
(
cx
desc
)
;
}
#
ifdef
DEBUG
static
void
DEBUG_CheckXBLCallable
(
JSContext
*
cx
JSObject
*
obj
)
{
MOZ_ASSERT_IF
(
js
:
:
IsCrossCompartmentWrapper
(
obj
)
xpc
:
:
IsInContentXBLScope
(
js
:
:
UncheckedUnwrap
(
obj
)
)
)
;
MOZ_ASSERT
(
JS
:
:
IsCallable
(
obj
)
)
;
}
static
void
DEBUG_CheckXBLLookup
(
JSContext
*
cx
JS
:
:
PropertyDescriptor
*
desc
)
{
if
(
!
desc
-
>
obj
)
return
;
if
(
!
desc
-
>
value
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
desc
-
>
value
.
isObject
(
)
)
;
DEBUG_CheckXBLCallable
(
cx
&
desc
-
>
value
.
toObject
(
)
)
;
}
if
(
desc
-
>
getter
)
{
MOZ_ASSERT
(
desc
-
>
attrs
&
JSPROP_GETTER
)
;
DEBUG_CheckXBLCallable
(
cx
JS_FUNC_TO_DATA_PTR
(
JSObject
*
desc
-
>
getter
)
)
;
}
if
(
desc
-
>
setter
)
{
MOZ_ASSERT
(
desc
-
>
attrs
&
JSPROP_SETTER
)
;
DEBUG_CheckXBLCallable
(
cx
JS_FUNC_TO_DATA_PTR
(
JSObject
*
desc
-
>
setter
)
)
;
}
}
#
else
#
define
DEBUG_CheckXBLLookup
(
a
b
)
{
}
#
endif
bool
XrayResolveOwnProperty
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
bool
&
cacheOnHolder
)
{
cacheOnHolder
=
false
;
DOMObjectType
type
;
const
NativePropertyHooks
*
nativePropertyHooks
=
GetNativePropertyHooks
(
cx
obj
type
)
;
ResolveOwnProperty
resolveOwnProperty
=
nativePropertyHooks
-
>
mResolveOwnProperty
;
if
(
type
=
=
eNamedPropertiesObject
)
{
MOZ_ASSERT
(
!
resolveOwnProperty
"
Shouldn
'
t
have
any
Xray
-
visible
properties
"
)
;
return
true
;
}
const
NativePropertiesHolder
&
nativePropertiesHolder
=
nativePropertyHooks
-
>
mNativeProperties
;
const
NativeProperties
*
nativeProperties
=
nullptr
;
const
PropertyInfo
*
found
=
nullptr
;
if
(
(
nativeProperties
=
nativePropertiesHolder
.
regular
)
)
{
found
=
XrayFindOwnPropertyInfo
(
cx
id
nativeProperties
)
;
}
if
(
!
found
&
&
(
nativeProperties
=
nativePropertiesHolder
.
chromeOnly
)
&
&
xpc
:
:
AccessCheck
:
:
isChrome
(
js
:
:
GetObjectCompartment
(
wrapper
)
)
)
{
found
=
XrayFindOwnPropertyInfo
(
cx
id
nativeProperties
)
;
}
if
(
IsInstance
(
type
)
)
{
if
(
found
&
&
(
found
-
>
type
=
=
eUnforgeableMethod
|
|
found
-
>
type
=
=
eUnforgeableAttribute
)
)
{
if
(
!
XrayResolveProperty
(
cx
wrapper
obj
id
desc
cacheOnHolder
type
nativeProperties
*
found
)
)
{
return
false
;
}
if
(
desc
.
object
(
)
)
{
return
true
;
}
}
if
(
resolveOwnProperty
)
{
if
(
!
resolveOwnProperty
(
cx
wrapper
obj
id
desc
)
)
{
return
false
;
}
if
(
desc
.
object
(
)
)
{
return
true
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
maybeElement
(
cx
obj
)
;
Element
*
element
;
if
(
xpc
:
:
IsInContentXBLScope
(
wrapper
)
&
&
NS_SUCCEEDED
(
UNWRAP_OBJECT
(
Element
&
maybeElement
element
)
)
)
{
if
(
!
nsContentUtils
:
:
LookupBindingMember
(
cx
element
id
desc
)
)
{
return
false
;
}
DEBUG_CheckXBLLookup
(
cx
desc
.
address
(
)
)
;
if
(
desc
.
object
(
)
)
{
desc
.
object
(
)
.
set
(
wrapper
)
;
return
true
;
}
}
if
(
type
!
=
eGlobalInstance
)
{
return
true
;
}
}
else
if
(
type
=
=
eInterface
)
{
if
(
id
=
=
GetJSIDByIndex
(
cx
XPCJSContext
:
:
IDX_PROTOTYPE
)
)
{
return
nativePropertyHooks
-
>
mPrototypeID
=
=
prototypes
:
:
id
:
:
_ID_Count
|
|
ResolvePrototypeOrConstructor
(
cx
wrapper
obj
nativePropertyHooks
-
>
mPrototypeID
JSPROP_PERMANENT
|
JSPROP_READONLY
desc
cacheOnHolder
)
;
}
if
(
id
=
=
GetJSIDByIndex
(
cx
XPCJSContext
:
:
IDX_ISINSTANCE
)
&
&
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
js
:
:
GetObjectClass
(
obj
)
)
-
>
wantsInterfaceHasInstance
)
{
cacheOnHolder
=
true
;
JSNativeWrapper
interfaceIsInstanceWrapper
=
{
InterfaceIsInstance
nullptr
}
;
JSObject
*
funObj
=
XrayCreateFunction
(
cx
wrapper
interfaceIsInstanceWrapper
1
id
)
;
if
(
!
funObj
)
{
return
false
;
}
desc
.
value
(
)
.
setObject
(
*
funObj
)
;
desc
.
setAttributes
(
0
)
;
desc
.
object
(
)
.
set
(
wrapper
)
;
desc
.
setSetter
(
nullptr
)
;
desc
.
setGetter
(
nullptr
)
;
return
true
;
}
if
(
id
=
=
SYMBOL_TO_JSID
(
JS
:
:
GetWellKnownSymbol
(
cx
JS
:
:
SymbolCode
:
:
hasInstance
)
)
&
&
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
js
:
:
GetObjectClass
(
obj
)
)
-
>
wantsInterfaceHasInstance
)
{
cacheOnHolder
=
true
;
JSNativeWrapper
interfaceHasInstanceWrapper
=
{
InterfaceHasInstance
nullptr
}
;
JSObject
*
funObj
=
XrayCreateFunction
(
cx
wrapper
interfaceHasInstanceWrapper
1
id
)
;
if
(
!
funObj
)
{
return
false
;
}
desc
.
value
(
)
.
setObject
(
*
funObj
)
;
desc
.
setAttributes
(
JSPROP_READONLY
|
JSPROP_PERMANENT
)
;
desc
.
object
(
)
.
set
(
wrapper
)
;
desc
.
setSetter
(
nullptr
)
;
desc
.
setGetter
(
nullptr
)
;
return
true
;
}
}
else
{
MOZ_ASSERT
(
IsInterfacePrototype
(
type
)
)
;
if
(
id
=
=
GetJSIDByIndex
(
cx
XPCJSContext
:
:
IDX_CONSTRUCTOR
)
)
{
return
nativePropertyHooks
-
>
mConstructorID
=
=
constructors
:
:
id
:
:
_ID_Count
|
|
ResolvePrototypeOrConstructor
(
cx
wrapper
obj
nativePropertyHooks
-
>
mConstructorID
0
desc
cacheOnHolder
)
;
}
if
(
type
=
=
eGlobalInterfacePrototype
)
{
return
true
;
}
}
if
(
found
&
&
!
XrayResolveProperty
(
cx
wrapper
obj
id
desc
cacheOnHolder
type
nativeProperties
*
found
)
)
{
return
false
;
}
return
true
;
}
bool
XrayDefineProperty
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
Handle
<
JS
:
:
PropertyDescriptor
>
desc
JS
:
:
ObjectOpResult
&
result
bool
*
defined
)
{
if
(
!
js
:
:
IsProxy
(
obj
)
)
return
true
;
const
DOMProxyHandler
*
handler
=
GetDOMProxyHandler
(
obj
)
;
return
handler
-
>
defineProperty
(
cx
wrapper
id
desc
result
defined
)
;
}
template
<
typename
SpecType
>
bool
XrayAppendPropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
Prefable
<
const
SpecType
>
*
pref
const
PropertyInfo
*
infos
unsigned
flags
JS
:
:
AutoIdVector
&
props
)
{
do
{
bool
prefIsEnabled
=
pref
-
>
isEnabled
(
cx
obj
)
;
if
(
prefIsEnabled
)
{
const
SpecType
*
spec
=
pref
-
>
specs
;
do
{
const
jsid
id
=
infos
+
+
-
>
Id
(
)
;
if
(
(
(
flags
&
JSITER_HIDDEN
)
|
|
(
spec
-
>
flags
&
JSPROP_ENUMERATE
)
)
&
&
(
(
flags
&
JSITER_SYMBOLS
)
|
|
!
JSID_IS_SYMBOL
(
id
)
)
&
&
!
props
.
append
(
id
)
)
{
return
false
;
}
}
while
(
(
+
+
spec
)
-
>
name
)
;
}
if
(
!
(
+
+
pref
)
-
>
specs
)
{
break
;
}
if
(
!
prefIsEnabled
)
{
infos
+
=
pref
-
>
specs
-
(
pref
-
1
)
-
>
specs
-
1
;
}
}
while
(
1
)
;
return
true
;
}
template
<
>
bool
XrayAppendPropertyKeys
<
ConstantSpec
>
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
Prefable
<
const
ConstantSpec
>
*
pref
const
PropertyInfo
*
infos
unsigned
flags
JS
:
:
AutoIdVector
&
props
)
{
do
{
bool
prefIsEnabled
=
pref
-
>
isEnabled
(
cx
obj
)
;
if
(
prefIsEnabled
)
{
const
ConstantSpec
*
spec
=
pref
-
>
specs
;
do
{
if
(
!
props
.
append
(
infos
+
+
-
>
Id
(
)
)
)
{
return
false
;
}
}
while
(
(
+
+
spec
)
-
>
name
)
;
}
if
(
!
(
+
+
pref
)
-
>
specs
)
{
break
;
}
if
(
!
prefIsEnabled
)
{
infos
+
=
pref
-
>
specs
-
(
pref
-
1
)
-
>
specs
-
1
;
}
}
while
(
1
)
;
return
true
;
}
#
define
ADD_KEYS_IF_DEFINED
(
FieldName
)
{
\
if
(
nativeProperties
-
>
Has
#
#
FieldName
#
#
s
(
)
&
&
\
!
XrayAppendPropertyKeys
(
cx
obj
\
nativeProperties
-
>
FieldName
#
#
s
(
)
\
nativeProperties
-
>
FieldName
#
#
PropertyInfos
(
)
\
flags
props
)
)
{
\
return
false
;
\
}
\
}
bool
XrayOwnPropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
unsigned
flags
JS
:
:
AutoIdVector
&
props
DOMObjectType
type
const
NativeProperties
*
nativeProperties
)
{
MOZ_ASSERT
(
type
!
=
eNamedPropertiesObject
)
;
if
(
IsInstance
(
type
)
)
{
ADD_KEYS_IF_DEFINED
(
UnforgeableMethod
)
;
ADD_KEYS_IF_DEFINED
(
UnforgeableAttribute
)
;
if
(
type
=
=
eGlobalInstance
)
{
ADD_KEYS_IF_DEFINED
(
Method
)
;
ADD_KEYS_IF_DEFINED
(
Attribute
)
;
}
}
else
{
MOZ_ASSERT
(
type
!
=
eGlobalInterfacePrototype
)
;
if
(
type
=
=
eInterface
)
{
ADD_KEYS_IF_DEFINED
(
StaticMethod
)
;
ADD_KEYS_IF_DEFINED
(
StaticAttribute
)
;
}
else
{
MOZ_ASSERT
(
type
=
=
eInterfacePrototype
)
;
ADD_KEYS_IF_DEFINED
(
Method
)
;
ADD_KEYS_IF_DEFINED
(
Attribute
)
;
}
ADD_KEYS_IF_DEFINED
(
Constant
)
;
}
return
true
;
}
#
undef
ADD_KEYS_IF_DEFINED
bool
XrayOwnNativePropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
const
NativePropertyHooks
*
nativePropertyHooks
DOMObjectType
type
JS
:
:
Handle
<
JSObject
*
>
obj
unsigned
flags
JS
:
:
AutoIdVector
&
props
)
{
MOZ_ASSERT
(
type
!
=
eNamedPropertiesObject
)
;
if
(
type
=
=
eInterface
&
&
nativePropertyHooks
-
>
mPrototypeID
!
=
prototypes
:
:
id
:
:
_ID_Count
&
&
!
AddStringToIDVector
(
cx
props
"
prototype
"
)
)
{
return
false
;
}
if
(
IsInterfacePrototype
(
type
)
&
&
nativePropertyHooks
-
>
mConstructorID
!
=
constructors
:
:
id
:
:
_ID_Count
&
&
(
flags
&
JSITER_HIDDEN
)
&
&
!
AddStringToIDVector
(
cx
props
"
constructor
"
)
)
{
return
false
;
}
const
NativePropertiesHolder
&
nativeProperties
=
nativePropertyHooks
-
>
mNativeProperties
;
if
(
nativeProperties
.
regular
&
&
!
XrayOwnPropertyKeys
(
cx
wrapper
obj
flags
props
type
nativeProperties
.
regular
)
)
{
return
false
;
}
if
(
nativeProperties
.
chromeOnly
&
&
xpc
:
:
AccessCheck
:
:
isChrome
(
js
:
:
GetObjectCompartment
(
wrapper
)
)
&
&
!
XrayOwnPropertyKeys
(
cx
wrapper
obj
flags
props
type
nativeProperties
.
chromeOnly
)
)
{
return
false
;
}
return
true
;
}
bool
XrayOwnPropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
unsigned
flags
JS
:
:
AutoIdVector
&
props
)
{
DOMObjectType
type
;
const
NativePropertyHooks
*
nativePropertyHooks
=
GetNativePropertyHooks
(
cx
obj
type
)
;
EnumerateOwnProperties
enumerateOwnProperties
=
nativePropertyHooks
-
>
mEnumerateOwnProperties
;
if
(
type
=
=
eNamedPropertiesObject
)
{
MOZ_ASSERT
(
!
enumerateOwnProperties
"
Shouldn
'
t
have
any
Xray
-
visible
properties
"
)
;
return
true
;
}
if
(
IsInstance
(
type
)
)
{
if
(
enumerateOwnProperties
&
&
!
enumerateOwnProperties
(
cx
wrapper
obj
props
)
)
{
return
false
;
}
}
return
type
=
=
eGlobalInterfacePrototype
|
|
XrayOwnNativePropertyKeys
(
cx
wrapper
nativePropertyHooks
type
obj
flags
props
)
;
}
const
JSClass
*
XrayGetExpandoClass
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
{
DOMObjectType
type
;
const
NativePropertyHooks
*
nativePropertyHooks
=
GetNativePropertyHooks
(
cx
obj
type
)
;
if
(
!
IsInstance
(
type
)
)
{
return
&
DefaultXrayExpandoObjectClass
;
}
return
nativePropertyHooks
-
>
mXrayExpandoClass
;
}
bool
XrayDeleteNamedProperty
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
ObjectOpResult
&
opresult
)
{
DOMObjectType
type
;
const
NativePropertyHooks
*
nativePropertyHooks
=
GetNativePropertyHooks
(
cx
obj
type
)
;
if
(
!
IsInstance
(
type
)
|
|
!
nativePropertyHooks
-
>
mDeleteNamedProperty
)
{
return
opresult
.
succeed
(
)
;
}
return
nativePropertyHooks
-
>
mDeleteNamedProperty
(
cx
wrapper
obj
id
opresult
)
;
}
JSObject
*
GetCachedSlotStorageObjectSlow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
bool
*
isXray
)
{
if
(
!
xpc
:
:
WrapperFactory
:
:
IsXrayWrapper
(
obj
)
)
{
JSObject
*
retval
=
js
:
:
UncheckedUnwrap
(
obj
false
)
;
MOZ_ASSERT
(
IsDOMObject
(
retval
)
)
;
*
isXray
=
false
;
return
retval
;
}
*
isXray
=
true
;
return
xpc
:
:
EnsureXrayExpandoObject
(
cx
obj
)
;
;
}
DEFINE_XRAY_EXPANDO_CLASS
(
DefaultXrayExpandoObjectClass
0
)
;
NativePropertyHooks
sEmptyNativePropertyHooks
=
{
nullptr
nullptr
nullptr
{
nullptr
nullptr
}
prototypes
:
:
id
:
:
_ID_Count
constructors
:
:
id
:
:
_ID_Count
nullptr
}
;
const
js
:
:
ClassOps
sBoringInterfaceObjectClassClassOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
ThrowingConstructor
nullptr
ThrowingConstructor
nullptr
}
;
const
js
:
:
ObjectOps
sInterfaceObjectClassObjectOps
=
{
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
nullptr
InterfaceObjectToString
}
;
bool
GetPropertyOnPrototype
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
JS
:
:
Value
>
receiver
JS
:
:
Handle
<
jsid
>
id
bool
*
found
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
)
{
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
js
:
:
GetObjectProto
(
cx
proxy
&
proto
)
)
{
return
false
;
}
if
(
!
proto
)
{
*
found
=
false
;
return
true
;
}
if
(
!
JS_HasPropertyById
(
cx
proto
id
found
)
)
{
return
false
;
}
if
(
!
*
found
)
{
return
true
;
}
return
JS_ForwardGetPropertyTo
(
cx
proto
id
receiver
vp
)
;
}
bool
HasPropertyOnPrototype
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
bool
*
has
)
{
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
if
(
!
js
:
:
GetObjectProto
(
cx
proxy
&
proto
)
)
{
return
false
;
}
if
(
!
proto
)
{
*
has
=
false
;
return
true
;
}
return
JS_HasPropertyById
(
cx
proto
id
has
)
;
}
bool
AppendNamedPropertyIds
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
nsTArray
<
nsString
>
&
names
bool
shadowPrototypeProperties
JS
:
:
AutoIdVector
&
props
)
{
for
(
uint32_t
i
=
0
;
i
<
names
.
Length
(
)
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
cx
)
;
if
(
!
xpc
:
:
NonVoidStringToJsval
(
cx
names
[
i
]
&
v
)
)
{
return
false
;
}
JS
:
:
Rooted
<
jsid
>
id
(
cx
)
;
if
(
!
JS_ValueToId
(
cx
v
&
id
)
)
{
return
false
;
}
bool
shouldAppend
=
shadowPrototypeProperties
;
if
(
!
shouldAppend
)
{
bool
has
;
if
(
!
HasPropertyOnPrototype
(
cx
proxy
id
&
has
)
)
{
return
false
;
}
shouldAppend
=
!
has
;
}
if
(
shouldAppend
)
{
if
(
!
props
.
append
(
id
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
DictionaryBase
:
:
ParseJSON
(
JSContext
*
aCx
const
nsAString
&
aJSON
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
{
if
(
aJSON
.
IsEmpty
(
)
)
{
return
true
;
}
return
JS_ParseJSON
(
aCx
PromiseFlatString
(
aJSON
)
.
get
(
)
aJSON
.
Length
(
)
aVal
)
;
}
bool
DictionaryBase
:
:
StringifyToJSON
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
nsAString
&
aJSON
)
const
{
return
JS
:
:
ToJSONMaybeSafely
(
aCx
aObj
AppendJSONToString
&
aJSON
)
;
}
bool
DictionaryBase
:
:
AppendJSONToString
(
const
char16_t
*
aJSONData
uint32_t
aDataLength
void
*
aString
)
{
nsAString
*
string
=
static_cast
<
nsAString
*
>
(
aString
)
;
string
-
>
Append
(
aJSONData
aDataLength
)
;
return
true
;
}
void
ReparentWrapper
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObjArg
ErrorResult
&
aError
)
{
js
:
:
AssertSameCompartment
(
aCx
aObjArg
)
;
aError
.
MightThrowJSException
(
)
;
if
(
!
js
:
:
CheckRecursionLimitConservative
(
aCx
)
)
{
aError
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
aObj
(
aCx
aObjArg
)
;
const
DOMJSClass
*
domClass
=
GetDOMClass
(
aObj
)
;
JS
:
:
Rooted
<
JSObject
*
>
oldParent
(
aCx
JS
:
:
GetNonCCWObjectGlobal
(
aObj
)
)
;
MOZ_ASSERT
(
JS_IsGlobalObject
(
oldParent
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
newParent
(
aCx
domClass
-
>
mGetAssociatedGlobal
(
aCx
aObj
)
)
;
MOZ_ASSERT
(
JS_IsGlobalObject
(
newParent
)
)
;
JSAutoRealm
oldAr
(
aCx
oldParent
)
;
JS
:
:
Compartment
*
oldCompartment
=
js
:
:
GetObjectCompartment
(
oldParent
)
;
JS
:
:
Compartment
*
newCompartment
=
js
:
:
GetObjectCompartment
(
newParent
)
;
if
(
oldCompartment
=
=
newCompartment
)
{
MOZ_ASSERT
(
oldParent
=
=
newParent
)
;
return
;
}
nsISupports
*
native
=
UnwrapDOMObjectToISupports
(
aObj
)
;
if
(
!
native
)
{
return
;
}
bool
isProxy
=
js
:
:
IsProxy
(
aObj
)
;
JS
:
:
Rooted
<
JSObject
*
>
expandoObject
(
aCx
)
;
if
(
isProxy
)
{
expandoObject
=
DOMProxyHandler
:
:
GetAndClearExpandoObject
(
aObj
)
;
}
JSAutoRealm
newAr
(
aCx
newParent
)
;
JS
:
:
Handle
<
JSObject
*
>
proto
=
(
domClass
-
>
mGetProto
)
(
aCx
)
;
if
(
!
proto
)
{
aError
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
newobj
(
aCx
JS_CloneObject
(
aCx
aObj
proto
)
)
;
if
(
!
newobj
)
{
aError
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
propertyHolder
(
aCx
)
;
JS
:
:
Rooted
<
JSObject
*
>
copyFrom
(
aCx
isProxy
?
expandoObject
:
aObj
)
;
if
(
copyFrom
)
{
propertyHolder
=
JS_NewObjectWithGivenProto
(
aCx
nullptr
nullptr
)
;
if
(
!
propertyHolder
)
{
aError
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
if
(
!
JS_CopyPropertiesFrom
(
aCx
propertyHolder
copyFrom
)
)
{
aError
.
StealExceptionFromJSContext
(
aCx
)
;
return
;
}
}
else
{
propertyHolder
=
nullptr
;
}
js
:
:
SetReservedSlot
(
newobj
DOM_OBJECT_SLOT
js
:
:
GetReservedSlot
(
aObj
DOM_OBJECT_SLOT
)
)
;
js
:
:
SetReservedSlot
(
aObj
DOM_OBJECT_SLOT
JS
:
:
PrivateValue
(
nullptr
)
)
;
aObj
=
xpc
:
:
TransplantObjectRetainingXrayExpandos
(
aCx
aObj
newobj
)
;
if
(
!
aObj
)
{
MOZ_CRASH
(
)
;
}
nsWrapperCache
*
cache
=
nullptr
;
CallQueryInterface
(
native
&
cache
)
;
bool
preserving
=
cache
-
>
PreservingWrapper
(
)
;
cache
-
>
SetPreservingWrapper
(
false
)
;
cache
-
>
SetWrapper
(
aObj
)
;
cache
-
>
SetPreservingWrapper
(
preserving
)
;
if
(
propertyHolder
)
{
JS
:
:
Rooted
<
JSObject
*
>
copyTo
(
aCx
)
;
if
(
isProxy
)
{
copyTo
=
DOMProxyHandler
:
:
EnsureExpandoObject
(
aCx
aObj
)
;
}
else
{
copyTo
=
aObj
;
}
if
(
!
copyTo
|
|
!
JS_CopyPropertiesFrom
(
aCx
copyTo
propertyHolder
)
)
{
MOZ_CRASH
(
)
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
maybeObjLC
(
aCx
aObj
)
;
nsObjectLoadingContent
*
htmlobject
;
nsresult
rv
=
UNWRAP_OBJECT
(
HTMLObjectElement
&
maybeObjLC
htmlobject
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
UNWRAP_OBJECT
(
HTMLEmbedElement
&
maybeObjLC
htmlobject
)
;
if
(
NS_FAILED
(
rv
)
)
{
htmlobject
=
nullptr
;
}
}
if
(
htmlobject
)
{
htmlobject
-
>
SetupProtoChain
(
aCx
aObj
)
;
}
}
GlobalObject
:
:
GlobalObject
(
JSContext
*
aCx
JSObject
*
aObject
)
:
mGlobalJSObject
(
aCx
)
mCx
(
aCx
)
mGlobalObject
(
nullptr
)
{
MOZ_ASSERT
(
mCx
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
aObject
)
;
if
(
js
:
:
IsWrapper
(
obj
)
)
{
obj
=
js
:
:
CheckedUnwrap
(
obj
false
)
;
if
(
!
obj
)
{
if
(
!
MOZ_LIKELY
(
NS_IsMainThread
(
)
)
)
{
MOZ_CRASH
(
)
;
}
Throw
(
aCx
NS_ERROR_XPC_SECURITY_MANAGER_VETO
)
;
return
;
}
}
mGlobalJSObject
=
JS
:
:
GetNonCCWObjectGlobal
(
obj
)
;
}
nsISupports
*
GlobalObject
:
:
GetAsSupports
(
)
const
{
if
(
mGlobalObject
)
{
return
mGlobalObject
;
}
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
mGlobalJSObject
)
)
;
mGlobalObject
=
UnwrapDOMObjectToISupports
(
mGlobalJSObject
)
;
if
(
mGlobalObject
)
{
return
mGlobalObject
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
All
our
worker
globals
are
DOM
objects
"
)
;
nsCOMPtr
<
nsISupports
>
supp
=
xpc
:
:
UnwrapReflectorToISupports
(
mGlobalJSObject
)
;
if
(
supp
)
{
mGlobalObject
=
supp
;
return
mGlobalObject
;
}
if
(
XPCConvert
:
:
GetISupportsFromJSObject
(
mGlobalJSObject
&
mGlobalObject
)
)
{
return
mGlobalObject
;
}
MOZ_ASSERT
(
!
mGlobalObject
)
;
Throw
(
mCx
NS_ERROR_XPC_BAD_CONVERT_JS
)
;
return
nullptr
;
}
nsIPrincipal
*
GlobalObject
:
:
GetSubjectPrincipal
(
)
const
{
if
(
!
NS_IsMainThread
(
)
)
{
return
nullptr
;
}
JS
:
:
Realm
*
realm
=
js
:
:
GetContextRealm
(
mCx
)
;
MOZ_ASSERT
(
realm
)
;
JSPrincipals
*
principals
=
JS
:
:
GetRealmPrincipals
(
realm
)
;
return
nsJSPrincipals
:
:
get
(
principals
)
;
}
CallerType
GlobalObject
:
:
CallerType
(
)
const
{
return
nsContentUtils
:
:
ThreadsafeIsSystemCaller
(
mCx
)
?
dom
:
:
CallerType
:
:
System
:
dom
:
:
CallerType
:
:
NonSystem
;
}
static
bool
CallOrdinaryHasInstance
(
JSContext
*
cx
JS
:
:
CallArgs
&
args
)
{
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
cx
&
args
.
thisv
(
)
.
toObject
(
)
)
;
bool
isInstance
;
if
(
!
JS
:
:
OrdinaryHasInstance
(
cx
thisObj
args
.
get
(
0
)
&
isInstance
)
)
{
return
false
;
}
args
.
rval
(
)
.
setBoolean
(
isInstance
)
;
return
true
;
}
bool
InterfaceHasInstance
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
if
(
!
args
.
thisv
(
)
.
isObject
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
cx
js
:
:
CheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
)
;
if
(
!
thisObj
)
{
return
CallOrdinaryHasInstance
(
cx
args
)
;
}
const
js
:
:
Class
*
thisClass
=
js
:
:
GetObjectClass
(
thisObj
)
;
if
(
!
IsDOMIfaceAndProtoClass
(
thisClass
)
)
{
return
CallOrdinaryHasInstance
(
cx
args
)
;
}
const
DOMIfaceAndProtoJSClass
*
clasp
=
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
thisClass
)
;
if
(
clasp
-
>
mType
!
=
eInterface
|
|
clasp
-
>
mPrototypeID
=
=
prototypes
:
:
id
:
:
_ID_Count
)
{
return
CallOrdinaryHasInstance
(
cx
args
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
instance
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
const
DOMJSClass
*
domClass
=
GetDOMClass
(
js
:
:
UncheckedUnwrap
(
instance
false
)
)
;
if
(
domClass
&
&
domClass
-
>
mInterfaceChain
[
clasp
-
>
mDepth
]
=
=
clasp
-
>
mPrototypeID
)
{
args
.
rval
(
)
.
setBoolean
(
true
)
;
return
true
;
}
if
(
jsipc
:
:
IsWrappedCPOW
(
instance
)
)
{
bool
boolp
=
false
;
if
(
!
jsipc
:
:
DOMInstanceOf
(
cx
js
:
:
UncheckedUnwrap
(
instance
)
clasp
-
>
mPrototypeID
clasp
-
>
mDepth
&
boolp
)
)
{
return
false
;
}
args
.
rval
(
)
.
setBoolean
(
boolp
)
;
return
true
;
}
return
CallOrdinaryHasInstance
(
cx
args
)
;
}
bool
InterfaceHasInstance
(
JSContext
*
cx
int
prototypeID
int
depth
JS
:
:
Handle
<
JSObject
*
>
instance
bool
*
bp
)
{
const
DOMJSClass
*
domClass
=
GetDOMClass
(
js
:
:
UncheckedUnwrap
(
instance
)
)
;
MOZ_ASSERT
(
!
domClass
|
|
prototypeID
!
=
prototypes
:
:
id
:
:
_ID_Count
"
Why
do
we
have
a
hasInstance
hook
if
we
don
'
t
have
a
prototype
"
"
ID
?
"
)
;
*
bp
=
(
domClass
&
&
domClass
-
>
mInterfaceChain
[
depth
]
=
=
prototypeID
)
;
return
true
;
}
bool
InterfaceIsInstance
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
if
(
!
args
.
get
(
0
)
.
isObject
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
if
(
!
args
.
thisv
(
)
.
isObject
(
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
cx
js
:
:
CheckedUnwrap
(
&
args
.
thisv
(
)
.
toObject
(
)
)
)
;
if
(
!
thisObj
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
const
js
:
:
Class
*
thisClass
=
js
:
:
GetObjectClass
(
thisObj
)
;
if
(
!
IsDOMIfaceAndProtoClass
(
thisClass
)
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
const
DOMIfaceAndProtoJSClass
*
clasp
=
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
thisClass
)
;
if
(
clasp
-
>
mType
!
=
eInterface
|
|
clasp
-
>
mPrototypeID
=
=
prototypes
:
:
id
:
:
_ID_Count
)
{
args
.
rval
(
)
.
setBoolean
(
false
)
;
return
true
;
}
JS
:
:
Rooted
<
JSObject
*
>
instance
(
cx
&
args
[
0
]
.
toObject
(
)
)
;
const
DOMJSClass
*
domClass
=
GetDOMClass
(
js
:
:
UncheckedUnwrap
(
instance
false
)
)
;
bool
isInstance
=
domClass
&
&
domClass
-
>
mInterfaceChain
[
clasp
-
>
mDepth
]
=
=
clasp
-
>
mPrototypeID
;
args
.
rval
(
)
.
setBoolean
(
isInstance
)
;
return
true
;
}
bool
ReportLenientThisUnwrappingFailure
(
JSContext
*
cx
JSObject
*
obj
)
{
JS
:
:
Rooted
<
JSObject
*
>
rootedObj
(
cx
obj
)
;
GlobalObject
global
(
cx
rootedObj
)
;
if
(
global
.
Failed
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
global
.
GetAsSupports
(
)
)
;
if
(
window
&
&
window
-
>
GetDoc
(
)
)
{
window
-
>
GetDoc
(
)
-
>
WarnOnceAbout
(
nsIDocument
:
:
eLenientThis
)
;
}
return
true
;
}
bool
GetContentGlobalForJSImplementedObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
nsIGlobalObject
*
*
globalObj
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
xpc
:
:
AccessCheck
:
:
isChrome
(
js
:
:
GetObjectCompartment
(
obj
)
)
)
{
MOZ_CRASH
(
"
Should
have
a
chrome
object
here
"
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
domImplVal
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
obj
"
__DOM_IMPL__
"
&
domImplVal
)
)
{
return
false
;
}
if
(
!
domImplVal
.
isObject
(
)
)
{
ThrowErrorMessage
(
cx
MSG_NOT_OBJECT
"
Value
"
)
;
return
false
;
}
GlobalObject
global
(
cx
&
domImplVal
.
toObject
(
)
)
;
if
(
global
.
Failed
(
)
)
{
return
false
;
}
DebugOnly
<
nsresult
>
rv
=
CallQueryInterface
(
global
.
GetAsSupports
(
)
globalObj
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
*
globalObj
)
;
return
true
;
}
already_AddRefed
<
nsIGlobalObject
>
ConstructJSImplementation
(
const
char
*
aContractId
const
GlobalObject
&
aGlobal
JS
:
:
MutableHandle
<
JSObject
*
>
aObject
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
ConstructJSImplementation
(
aContractId
global
aObject
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
global
.
forget
(
)
;
}
void
ConstructJSImplementation
(
const
char
*
aContractId
nsIGlobalObject
*
aGlobal
JS
:
:
MutableHandle
<
JSObject
*
>
aObject
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
{
AutoNoJSAPI
nojsapi
;
nsresult
rv
;
nsCOMPtr
<
nsISupports
>
implISupports
=
do_CreateInstance
(
aContractId
&
rv
)
;
if
(
!
implISupports
)
{
nsPrintfCString
msg
(
"
Failed
to
get
JS
implementation
for
contract
\
"
%
s
\
"
"
aContractId
)
;
NS_WARNING
(
msg
.
get
(
)
)
;
aRv
.
Throw
(
rv
)
;
return
;
}
nsCOMPtr
<
nsIDOMGlobalPropertyInitializer
>
gpi
=
do_QueryInterface
(
implISupports
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
)
;
if
(
gpi
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
initReturn
(
RootingCx
(
)
)
;
rv
=
gpi
-
>
Init
(
window
&
initReturn
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
!
initReturn
.
isUndefined
(
)
)
{
MOZ_ASSERT
(
false
"
The
init
(
)
method
for
JS
-
implemented
WebIDL
should
not
return
anything
"
)
;
MOZ_CRASH
(
)
;
}
}
nsCOMPtr
<
nsIXPConnectWrappedJS
>
implWrapped
=
do_QueryInterface
(
implISupports
&
rv
)
;
MOZ_ASSERT
(
implWrapped
"
Failed
to
get
wrapped
JS
from
XPCOM
component
.
"
)
;
if
(
!
implWrapped
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
aObject
.
set
(
implWrapped
-
>
GetJSObject
(
)
)
;
if
(
!
aObject
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
}
bool
NonVoidByteStringToJsval
(
JSContext
*
cx
const
nsACString
&
str
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
JSString
*
jsStr
=
JS_NewStringCopyN
(
cx
str
.
Data
(
)
str
.
Length
(
)
)
;
if
(
!
jsStr
)
return
false
;
rval
.
setString
(
jsStr
)
;
return
true
;
}
template
<
typename
T
>
static
void
NormalizeUSVStringInternal
(
T
&
aString
)
{
char16_t
*
start
=
aString
.
BeginWriting
(
)
;
const
char16_t
*
nextChar
=
start
;
const
char16_t
*
end
=
aString
.
Data
(
)
+
aString
.
Length
(
)
;
while
(
nextChar
<
end
)
{
uint32_t
enumerated
=
UTF16CharEnumerator
:
:
NextChar
(
&
nextChar
end
)
;
if
(
enumerated
=
=
UCS2_REPLACEMENT_CHAR
)
{
int32_t
lastCharIndex
=
(
nextChar
-
start
)
-
1
;
start
[
lastCharIndex
]
=
static_cast
<
char16_t
>
(
enumerated
)
;
}
}
}
void
NormalizeUSVString
(
nsAString
&
aString
)
{
NormalizeUSVStringInternal
(
aString
)
;
}
void
NormalizeUSVString
(
binding_detail
:
:
FakeString
&
aString
)
{
NormalizeUSVStringInternal
(
aString
)
;
}
bool
ConvertJSValueToByteString
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v
bool
nullable
nsACString
&
result
)
{
JS
:
:
Rooted
<
JSString
*
>
s
(
cx
)
;
if
(
v
.
isString
(
)
)
{
s
=
v
.
toString
(
)
;
}
else
{
if
(
nullable
&
&
v
.
isNullOrUndefined
(
)
)
{
result
.
SetIsVoid
(
true
)
;
return
true
;
}
s
=
JS
:
:
ToString
(
cx
v
)
;
if
(
!
s
)
{
return
false
;
}
}
size_t
length
;
if
(
!
js
:
:
StringHasLatin1Chars
(
s
)
)
{
bool
foundBadChar
=
false
;
size_t
badCharIndex
;
char16_t
badChar
;
{
JS
:
:
AutoCheckCannotGC
nogc
;
const
char16_t
*
chars
=
JS_GetTwoByteStringCharsAndLength
(
cx
nogc
s
&
length
)
;
if
(
!
chars
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
chars
[
i
]
>
255
)
{
badCharIndex
=
i
;
badChar
=
chars
[
i
]
;
foundBadChar
=
true
;
break
;
}
}
}
if
(
foundBadChar
)
{
MOZ_ASSERT
(
badCharIndex
<
length
)
;
MOZ_ASSERT
(
badChar
>
255
)
;
char
index
[
21
]
;
static_assert
(
sizeof
(
size_t
)
<
=
8
"
index
array
too
small
"
)
;
SprintfLiteral
(
index
"
%
zu
"
badCharIndex
)
;
char
badCharArray
[
6
]
;
static_assert
(
sizeof
(
char16_t
)
<
=
2
"
badCharArray
too
small
"
)
;
SprintfLiteral
(
badCharArray
"
%
d
"
badChar
)
;
ThrowErrorMessage
(
cx
MSG_INVALID_BYTESTRING
index
badCharArray
)
;
return
false
;
}
}
else
{
length
=
js
:
:
GetStringLength
(
s
)
;
}
static_assert
(
js
:
:
MaxStringLength
<
UINT32_MAX
"
length
+
1
shouldn
'
t
overflow
"
)
;
if
(
!
result
.
SetLength
(
length
fallible
)
)
{
return
false
;
}
if
(
!
JS_EncodeStringToBuffer
(
cx
s
result
.
BeginWriting
(
)
length
)
)
{
return
false
;
}
return
true
;
}
void
FinalizeGlobal
(
JSFreeOp
*
aFreeOp
JSObject
*
aObj
)
{
MOZ_ASSERT
(
js
:
:
GetObjectClass
(
aObj
)
-
>
flags
&
JSCLASS_DOM_GLOBAL
)
;
mozilla
:
:
dom
:
:
DestroyProtoAndIfaceCache
(
aObj
)
;
}
bool
ResolveGlobal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
Handle
<
jsid
>
aId
bool
*
aResolvedp
)
{
MOZ_ASSERT
(
JS_IsGlobalObject
(
aObj
)
"
Should
have
a
global
here
since
we
plan
to
resolve
standard
"
"
classes
!
"
)
;
return
JS_ResolveStandardClass
(
aCx
aObj
aId
aResolvedp
)
;
}
bool
MayResolveGlobal
(
const
JSAtomState
&
aNames
jsid
aId
JSObject
*
aMaybeObj
)
{
return
JS_MayResolveStandardClass
(
aNames
aId
aMaybeObj
)
;
}
bool
EnumerateGlobal
(
JSContext
*
aCx
JS
:
:
HandleObject
aObj
JS
:
:
AutoIdVector
&
aProperties
bool
aEnumerableOnly
)
{
MOZ_ASSERT
(
JS_IsGlobalObject
(
aObj
)
"
Should
have
a
global
here
since
we
plan
to
enumerate
standard
"
"
classes
!
"
)
;
return
JS_NewEnumerateStandardClasses
(
aCx
aObj
aProperties
aEnumerableOnly
)
;
}
bool
IsNonExposedGlobal
(
JSContext
*
aCx
JSObject
*
aGlobal
uint32_t
aNonExposedGlobals
)
{
MOZ_ASSERT
(
aNonExposedGlobals
"
Why
did
we
get
called
?
"
)
;
MOZ_ASSERT
(
(
aNonExposedGlobals
&
~
(
GlobalNames
:
:
Window
|
GlobalNames
:
:
BackstagePass
|
GlobalNames
:
:
DedicatedWorkerGlobalScope
|
GlobalNames
:
:
SharedWorkerGlobalScope
|
GlobalNames
:
:
ServiceWorkerGlobalScope
|
GlobalNames
:
:
WorkerDebuggerGlobalScope
|
GlobalNames
:
:
WorkletGlobalScope
|
GlobalNames
:
:
AudioWorkletGlobalScope
)
)
=
=
0
"
Unknown
non
-
exposed
global
type
"
)
;
const
char
*
name
=
js
:
:
GetObjectClass
(
aGlobal
)
-
>
name
;
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
Window
)
&
&
!
strcmp
(
name
"
Window
"
)
)
{
return
true
;
}
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
BackstagePass
)
&
&
!
strcmp
(
name
"
BackstagePass
"
)
)
{
return
true
;
}
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
DedicatedWorkerGlobalScope
)
&
&
!
strcmp
(
name
"
DedicatedWorkerGlobalScope
"
)
)
{
return
true
;
}
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
SharedWorkerGlobalScope
)
&
&
!
strcmp
(
name
"
SharedWorkerGlobalScope
"
)
)
{
return
true
;
}
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
ServiceWorkerGlobalScope
)
&
&
!
strcmp
(
name
"
ServiceWorkerGlobalScope
"
)
)
{
return
true
;
}
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
WorkerDebuggerGlobalScope
)
&
&
!
strcmp
(
name
"
WorkerDebuggerGlobalScopex
"
)
)
{
return
true
;
}
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
WorkletGlobalScope
)
&
&
!
strcmp
(
name
"
WorkletGlobalScope
"
)
)
{
return
true
;
}
if
(
(
aNonExposedGlobals
&
GlobalNames
:
:
AudioWorkletGlobalScope
)
&
&
!
strcmp
(
name
"
AudioWorkletGlobalScope
"
)
)
{
return
true
;
}
return
false
;
}
namespace
binding_detail
{
struct
NormalThisPolicy
{
static
MOZ_ALWAYS_INLINE
bool
HasValidThisValue
(
const
JS
:
:
CallArgs
&
aArgs
)
{
return
aArgs
.
thisv
(
)
.
isObject
(
)
;
}
static
MOZ_ALWAYS_INLINE
JSObject
*
ExtractThisObject
(
const
JS
:
:
CallArgs
&
aArgs
)
{
return
&
aArgs
.
thisv
(
)
.
toObject
(
)
;
}
static
MOZ_ALWAYS_INLINE
JSObject
*
MaybeUnwrapThisObject
(
JSObject
*
aObj
)
{
return
aObj
;
}
static
bool
HandleInvalidThis
(
JSContext
*
aCx
JS
:
:
CallArgs
&
aArgs
bool
aSecurityError
prototypes
:
:
ID
aProtoId
)
{
return
ThrowInvalidThis
(
aCx
aArgs
aSecurityError
aProtoId
)
;
}
}
;
struct
MaybeGlobalThisPolicy
:
public
NormalThisPolicy
{
static
MOZ_ALWAYS_INLINE
bool
HasValidThisValue
(
const
JS
:
:
CallArgs
&
aArgs
)
{
return
aArgs
.
thisv
(
)
.
isObject
(
)
|
|
aArgs
.
thisv
(
)
.
isNullOrUndefined
(
)
;
}
static
MOZ_ALWAYS_INLINE
JSObject
*
ExtractThisObject
(
const
JS
:
:
CallArgs
&
aArgs
)
{
return
aArgs
.
thisv
(
)
.
isObject
(
)
?
&
aArgs
.
thisv
(
)
.
toObject
(
)
:
JS
:
:
GetNonCCWObjectGlobal
(
&
aArgs
.
callee
(
)
)
;
}
}
;
struct
LenientThisPolicy
:
public
MaybeGlobalThisPolicy
{
static
bool
HandleInvalidThis
(
JSContext
*
aCx
const
JS
:
:
CallArgs
&
aArgs
bool
aSecurityError
prototypes
:
:
ID
aProtoId
)
{
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
aCx
)
)
;
if
(
!
ReportLenientThisUnwrappingFailure
(
aCx
&
aArgs
.
callee
(
)
)
)
{
return
false
;
}
aArgs
.
rval
(
)
.
set
(
JS
:
:
UndefinedValue
(
)
)
;
return
true
;
}
}
;
struct
CrossOriginThisPolicy
:
public
MaybeGlobalThisPolicy
{
static
MOZ_ALWAYS_INLINE
JSObject
*
MaybeUnwrapThisObject
(
JSObject
*
aObj
)
{
if
(
xpc
:
:
WrapperFactory
:
:
IsXrayWrapper
(
aObj
)
)
{
return
js
:
:
UncheckedUnwrap
(
aObj
)
;
}
return
aObj
;
}
}
;
struct
ThrowExceptions
{
static
MOZ_ALWAYS_INLINE
bool
HandleException
(
JSContext
*
aCx
JS
:
:
CallArgs
&
aArgs
const
JSJitInfo
*
aInfo
bool
aOK
)
{
return
aOK
;
}
}
;
struct
ConvertExceptionsToPromises
{
static
MOZ_ALWAYS_INLINE
bool
HandleException
(
JSContext
*
aCx
JS
:
:
CallArgs
&
aArgs
const
JSJitInfo
*
aInfo
bool
aOK
)
{
MOZ_ASSERT
(
aInfo
-
>
returnType
(
)
=
=
JSVAL_TYPE_OBJECT
)
;
if
(
aOK
)
{
return
true
;
}
return
ConvertExceptionToPromise
(
aCx
aArgs
.
rval
(
)
)
;
}
}
;
template
<
typename
ThisPolicy
typename
ExceptionPolicy
>
bool
GenericGetter
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
const
JSJitInfo
*
info
=
FUNCTION_VALUE_TO_JITINFO
(
args
.
calleev
(
)
)
;
prototypes
:
:
ID
protoID
=
static_cast
<
prototypes
:
:
ID
>
(
info
-
>
protoID
)
;
if
(
!
ThisPolicy
:
:
HasValidThisValue
(
args
)
)
{
bool
ok
=
ThisPolicy
:
:
HandleInvalidThis
(
cx
args
false
protoID
)
;
return
ExceptionPolicy
:
:
HandleException
(
cx
args
info
ok
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
ThisPolicy
:
:
ExtractThisObject
(
args
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
rootSelf
(
cx
ThisPolicy
:
:
MaybeUnwrapThisObject
(
obj
)
)
;
void
*
self
;
{
binding_detail
:
:
MutableObjectHandleWrapper
wrapper
(
&
rootSelf
)
;
nsresult
rv
=
binding_detail
:
:
UnwrapObjectInternal
<
void
true
>
(
wrapper
self
protoID
info
-
>
depth
)
;
if
(
NS_FAILED
(
rv
)
)
{
bool
ok
=
ThisPolicy
:
:
HandleInvalidThis
(
cx
args
rv
=
=
NS_ERROR_XPC_SECURITY_MANAGER_VETO
protoID
)
;
return
ExceptionPolicy
:
:
HandleException
(
cx
args
info
ok
)
;
}
}
MOZ_ASSERT
(
info
-
>
type
(
)
=
=
JSJitInfo
:
:
Getter
)
;
JSJitGetterOp
getter
=
info
-
>
getter
;
bool
ok
=
getter
(
cx
obj
self
JSJitGetterCallArgs
(
args
)
)
;
#
ifdef
DEBUG
if
(
ok
)
{
AssertReturnTypeMatchesJitinfo
(
info
args
.
rval
(
)
)
;
}
#
endif
return
ExceptionPolicy
:
:
HandleException
(
cx
args
info
ok
)
;
}
template
bool
GenericGetter
<
NormalThisPolicy
ThrowExceptions
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericGetter
<
NormalThisPolicy
ConvertExceptionsToPromises
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericGetter
<
MaybeGlobalThisPolicy
ThrowExceptions
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericGetter
<
MaybeGlobalThisPolicy
ConvertExceptionsToPromises
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericGetter
<
LenientThisPolicy
ThrowExceptions
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericGetter
<
CrossOriginThisPolicy
ThrowExceptions
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
<
typename
ThisPolicy
>
bool
GenericSetter
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
const
JSJitInfo
*
info
=
FUNCTION_VALUE_TO_JITINFO
(
args
.
calleev
(
)
)
;
prototypes
:
:
ID
protoID
=
static_cast
<
prototypes
:
:
ID
>
(
info
-
>
protoID
)
;
if
(
!
ThisPolicy
:
:
HasValidThisValue
(
args
)
)
{
return
ThisPolicy
:
:
HandleInvalidThis
(
cx
args
false
protoID
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
ThisPolicy
:
:
ExtractThisObject
(
args
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
rootSelf
(
cx
ThisPolicy
:
:
MaybeUnwrapThisObject
(
obj
)
)
;
void
*
self
;
{
binding_detail
:
:
MutableObjectHandleWrapper
wrapper
(
&
rootSelf
)
;
nsresult
rv
=
binding_detail
:
:
UnwrapObjectInternal
<
void
true
>
(
wrapper
self
protoID
info
-
>
depth
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
ThisPolicy
:
:
HandleInvalidThis
(
cx
args
rv
=
=
NS_ERROR_XPC_SECURITY_MANAGER_VETO
protoID
)
;
}
}
if
(
args
.
length
(
)
=
=
0
)
{
return
ThrowNoSetterArg
(
cx
protoID
)
;
}
MOZ_ASSERT
(
info
-
>
type
(
)
=
=
JSJitInfo
:
:
Setter
)
;
JSJitSetterOp
setter
=
info
-
>
setter
;
if
(
!
setter
(
cx
obj
self
JSJitSetterCallArgs
(
args
)
)
)
{
return
false
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
#
ifdef
DEBUG
AssertReturnTypeMatchesJitinfo
(
info
args
.
rval
(
)
)
;
#
endif
return
true
;
}
template
bool
GenericSetter
<
NormalThisPolicy
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericSetter
<
MaybeGlobalThisPolicy
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericSetter
<
LenientThisPolicy
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericSetter
<
CrossOriginThisPolicy
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
<
typename
ThisPolicy
typename
ExceptionPolicy
>
bool
GenericMethod
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
const
JSJitInfo
*
info
=
FUNCTION_VALUE_TO_JITINFO
(
args
.
calleev
(
)
)
;
prototypes
:
:
ID
protoID
=
static_cast
<
prototypes
:
:
ID
>
(
info
-
>
protoID
)
;
if
(
!
ThisPolicy
:
:
HasValidThisValue
(
args
)
)
{
bool
ok
=
ThisPolicy
:
:
HandleInvalidThis
(
cx
args
false
protoID
)
;
return
ExceptionPolicy
:
:
HandleException
(
cx
args
info
ok
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
ThisPolicy
:
:
ExtractThisObject
(
args
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
rootSelf
(
cx
ThisPolicy
:
:
MaybeUnwrapThisObject
(
obj
)
)
;
void
*
self
;
{
binding_detail
:
:
MutableObjectHandleWrapper
wrapper
(
&
rootSelf
)
;
nsresult
rv
=
binding_detail
:
:
UnwrapObjectInternal
<
void
true
>
(
wrapper
self
protoID
info
-
>
depth
)
;
if
(
NS_FAILED
(
rv
)
)
{
bool
ok
=
ThisPolicy
:
:
HandleInvalidThis
(
cx
args
rv
=
=
NS_ERROR_XPC_SECURITY_MANAGER_VETO
protoID
)
;
return
ExceptionPolicy
:
:
HandleException
(
cx
args
info
ok
)
;
}
}
MOZ_ASSERT
(
info
-
>
type
(
)
=
=
JSJitInfo
:
:
Method
)
;
JSJitMethodOp
method
=
info
-
>
method
;
bool
ok
=
method
(
cx
obj
self
JSJitMethodCallArgs
(
args
)
)
;
#
ifdef
DEBUG
if
(
ok
)
{
AssertReturnTypeMatchesJitinfo
(
info
args
.
rval
(
)
)
;
}
#
endif
return
ExceptionPolicy
:
:
HandleException
(
cx
args
info
ok
)
;
}
template
bool
GenericMethod
<
NormalThisPolicy
ThrowExceptions
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericMethod
<
NormalThisPolicy
ConvertExceptionsToPromises
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericMethod
<
MaybeGlobalThisPolicy
ThrowExceptions
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericMethod
<
MaybeGlobalThisPolicy
ConvertExceptionsToPromises
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
bool
GenericMethod
<
CrossOriginThisPolicy
ThrowExceptions
>
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
}
bool
StaticMethodPromiseWrapper
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
const
JSJitInfo
*
info
=
FUNCTION_VALUE_TO_JITINFO
(
args
.
calleev
(
)
)
;
MOZ_ASSERT
(
info
)
;
MOZ_ASSERT
(
info
-
>
type
(
)
=
=
JSJitInfo
:
:
StaticMethod
)
;
bool
ok
=
info
-
>
staticMethod
(
cx
argc
vp
)
;
if
(
ok
)
{
return
true
;
}
return
ConvertExceptionToPromise
(
cx
args
.
rval
(
)
)
;
}
bool
ConvertExceptionToPromise
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
cx
)
;
if
(
!
JS_GetPendingException
(
cx
&
exn
)
)
{
return
false
;
}
JS_ClearPendingException
(
cx
)
;
JSObject
*
promise
=
JS
:
:
CallOriginalPromiseReject
(
cx
exn
)
;
if
(
!
promise
)
{
JS_SetPendingException
(
cx
exn
)
;
return
false
;
}
rval
.
setObject
(
*
promise
)
;
return
true
;
}
void
CreateGlobalOptionsWithXPConnect
:
:
TraceGlobal
(
JSTracer
*
aTrc
JSObject
*
aObj
)
{
xpc
:
:
TraceXPCGlobal
(
aTrc
aObj
)
;
}
bool
CreateGlobalOptionsWithXPConnect
:
:
PostCreateGlobal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
{
(
void
)
new
XPCWrappedNativeScope
(
aCx
aGlobal
)
;
return
true
;
}
static
bool
sRegisteredDOMNames
=
false
;
static
void
RegisterDOMNames
(
)
{
if
(
sRegisteredDOMNames
)
{
return
;
}
WebIDLGlobalNameHash
:
:
Init
(
)
;
sRegisteredDOMNames
=
true
;
}
bool
CreateGlobalOptions
<
nsGlobalWindowInner
>
:
:
PostCreateGlobal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
{
RegisterDOMNames
(
)
;
return
CreateGlobalOptionsWithXPConnect
:
:
PostCreateGlobal
(
aCx
aGlobal
)
;
}
#
ifdef
DEBUG
void
AssertReturnTypeMatchesJitinfo
(
const
JSJitInfo
*
aJitInfo
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
switch
(
aJitInfo
-
>
returnType
(
)
)
{
case
JSVAL_TYPE_UNKNOWN
:
break
;
case
JSVAL_TYPE_DOUBLE
:
MOZ_ASSERT
(
aValue
.
isNumber
(
)
)
;
break
;
case
JSVAL_TYPE_INT32
:
MOZ_ASSERT
(
aValue
.
isInt32
(
)
)
;
break
;
case
JSVAL_TYPE_UNDEFINED
:
MOZ_ASSERT
(
aValue
.
isUndefined
(
)
)
;
break
;
case
JSVAL_TYPE_BOOLEAN
:
MOZ_ASSERT
(
aValue
.
isBoolean
(
)
)
;
break
;
case
JSVAL_TYPE_STRING
:
MOZ_ASSERT
(
aValue
.
isString
(
)
)
;
break
;
case
JSVAL_TYPE_NULL
:
MOZ_ASSERT
(
aValue
.
isNull
(
)
)
;
break
;
case
JSVAL_TYPE_OBJECT
:
MOZ_ASSERT
(
aValue
.
isObject
(
)
)
;
break
;
default
:
MOZ_ASSERT
(
false
"
Unexpected
JSValueType
stored
in
jitinfo
"
)
;
break
;
}
}
#
endif
bool
CallerSubsumes
(
JSObject
*
aObject
)
{
nsIPrincipal
*
objPrin
=
nsContentUtils
:
:
ObjectPrincipal
(
js
:
:
UncheckedUnwrap
(
aObject
)
)
;
return
nsContentUtils
:
:
SubjectPrincipal
(
)
-
>
Subsumes
(
objPrin
)
;
}
nsresult
UnwrapArgImpl
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
src
const
nsIID
&
iid
void
*
*
ppArg
)
{
if
(
!
NS_IsMainThread
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsISupports
>
iface
=
xpc
:
:
UnwrapReflectorToISupports
(
src
)
;
if
(
iface
)
{
if
(
NS_FAILED
(
iface
-
>
QueryInterface
(
iid
ppArg
)
)
)
{
return
NS_ERROR_XPC_BAD_CONVERT_JS
;
}
return
NS_OK
;
}
if
(
!
nsContentUtils
:
:
IsSystemCaller
(
cx
)
)
{
return
NS_ERROR_XPC_BAD_CONVERT_JS
;
}
RefPtr
<
nsXPCWrappedJS
>
wrappedJS
;
nsresult
rv
=
nsXPCWrappedJS
:
:
GetNewOrUsed
(
src
iid
getter_AddRefs
(
wrappedJS
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
wrappedJS
)
{
return
rv
;
}
return
wrappedJS
-
>
QueryInterface
(
iid
ppArg
)
;
}
nsresult
UnwrapWindowProxyImpl
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
src
nsPIDOMWindowOuter
*
*
ppArg
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
;
nsresult
rv
=
UnwrapArg
<
nsPIDOMWindowInner
>
(
cx
src
getter_AddRefs
(
inner
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
inner
-
>
GetOuterWindow
(
)
;
outer
.
forget
(
ppArg
)
;
return
NS_OK
;
}
bool
SystemGlobalResolve
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
bool
*
resolvedp
)
{
if
(
!
ResolveGlobal
(
cx
obj
id
resolvedp
)
)
{
return
false
;
}
if
(
*
resolvedp
)
{
return
true
;
}
return
ResolveSystemBinding
(
cx
obj
id
resolvedp
)
;
}
bool
SystemGlobalEnumerate
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
{
bool
ignored
=
false
;
return
JS_EnumerateStandardClasses
(
cx
obj
)
&
&
ResolveSystemBinding
(
cx
obj
JSID_VOIDHANDLE
&
ignored
)
;
}
template
<
decltype
(
JS
:
:
NewMapObject
)
Method
>
bool
GetMaplikeSetlikeBackingObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
size_t
aSlotIndex
JS
:
:
MutableHandle
<
JSObject
*
>
aBackingObj
bool
*
aBackingObjCreated
)
{
JS
:
:
Rooted
<
JSObject
*
>
reflector
(
aCx
)
;
reflector
=
IsDOMObject
(
aObj
)
?
aObj
:
js
:
:
UncheckedUnwrap
(
aObj
false
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
slotValue
(
aCx
)
;
slotValue
=
js
:
:
GetReservedSlot
(
reflector
aSlotIndex
)
;
if
(
slotValue
.
isUndefined
(
)
)
{
{
JSAutoRealm
ar
(
aCx
reflector
)
;
JS
:
:
Rooted
<
JSObject
*
>
newBackingObj
(
aCx
)
;
newBackingObj
.
set
(
Method
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
newBackingObj
)
)
{
return
false
;
}
js
:
:
SetReservedSlot
(
reflector
aSlotIndex
JS
:
:
ObjectValue
(
*
newBackingObj
)
)
;
}
slotValue
=
js
:
:
GetReservedSlot
(
reflector
aSlotIndex
)
;
*
aBackingObjCreated
=
true
;
}
else
{
*
aBackingObjCreated
=
false
;
}
if
(
!
MaybeWrapNonDOMObjectValue
(
aCx
&
slotValue
)
)
{
return
false
;
}
aBackingObj
.
set
(
&
slotValue
.
toObject
(
)
)
;
return
true
;
}
bool
GetMaplikeBackingObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
size_t
aSlotIndex
JS
:
:
MutableHandle
<
JSObject
*
>
aBackingObj
bool
*
aBackingObjCreated
)
{
return
GetMaplikeSetlikeBackingObject
<
JS
:
:
NewMapObject
>
(
aCx
aObj
aSlotIndex
aBackingObj
aBackingObjCreated
)
;
}
bool
GetSetlikeBackingObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
size_t
aSlotIndex
JS
:
:
MutableHandle
<
JSObject
*
>
aBackingObj
bool
*
aBackingObjCreated
)
{
return
GetMaplikeSetlikeBackingObject
<
JS
:
:
NewSetObject
>
(
aCx
aObj
aSlotIndex
aBackingObj
aBackingObjCreated
)
;
}
bool
ForEachHandler
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
callbackFn
(
aCx
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
FOREACH_CALLBACK_SLOT
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
maplikeOrSetlikeObj
(
aCx
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
FOREACH_MAPLIKEORSETLIKEOBJ_SLOT
)
)
;
MOZ_ASSERT
(
aArgc
=
=
3
)
;
JS
:
:
AutoValueVector
newArgs
(
aCx
)
;
if
(
!
newArgs
.
append
(
args
.
get
(
0
)
)
)
{
return
false
;
}
if
(
!
newArgs
.
append
(
args
.
get
(
1
)
)
)
{
return
false
;
}
if
(
!
newArgs
.
append
(
maplikeOrSetlikeObj
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
return
JS
:
:
Call
(
aCx
args
.
thisv
(
)
callbackFn
newArgs
&
rval
)
;
}
static
inline
prototypes
:
:
ID
GetProtoIdForNewtarget
(
JS
:
:
Handle
<
JSObject
*
>
aNewTarget
)
{
const
js
:
:
Class
*
newTargetClass
=
js
:
:
GetObjectClass
(
aNewTarget
)
;
if
(
IsDOMIfaceAndProtoClass
(
newTargetClass
)
)
{
const
DOMIfaceAndProtoJSClass
*
newTargetIfaceClass
=
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
newTargetClass
)
;
if
(
newTargetIfaceClass
-
>
mType
=
=
eInterface
)
{
return
newTargetIfaceClass
-
>
mPrototypeID
;
}
}
else
if
(
JS_IsNativeFunction
(
aNewTarget
Constructor
)
)
{
return
GetNativePropertyHooksFromConstructorFunction
(
aNewTarget
)
-
>
mPrototypeID
;
}
return
prototypes
:
:
id
:
:
_ID_Count
;
}
bool
GetDesiredProto
(
JSContext
*
aCx
const
JS
:
:
CallArgs
&
aCallArgs
JS
:
:
MutableHandle
<
JSObject
*
>
aDesiredProto
)
{
if
(
!
aCallArgs
.
isConstructing
(
)
)
{
aDesiredProto
.
set
(
nullptr
)
;
return
true
;
}
JS
:
:
Rooted
<
JSObject
*
>
newTarget
(
aCx
&
aCallArgs
.
newTarget
(
)
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
originalNewTarget
(
aCx
newTarget
)
;
prototypes
:
:
ID
protoID
=
GetProtoIdForNewtarget
(
newTarget
)
;
if
(
protoID
=
=
prototypes
:
:
id
:
:
_ID_Count
)
{
newTarget
=
js
:
:
CheckedUnwrap
(
newTarget
)
;
if
(
newTarget
&
&
newTarget
!
=
originalNewTarget
)
{
protoID
=
GetProtoIdForNewtarget
(
newTarget
)
;
}
}
if
(
protoID
!
=
prototypes
:
:
id
:
:
_ID_Count
)
{
ProtoAndIfaceCache
&
protoAndIfaceCache
=
*
GetProtoAndIfaceCache
(
JS
:
:
GetNonCCWObjectGlobal
(
newTarget
)
)
;
aDesiredProto
.
set
(
protoAndIfaceCache
.
EntrySlotMustExist
(
protoID
)
)
;
if
(
newTarget
!
=
originalNewTarget
)
{
return
JS_WrapObject
(
aCx
aDesiredProto
)
;
}
return
true
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
protoVal
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
originalNewTarget
"
prototype
"
&
protoVal
)
)
{
return
false
;
}
if
(
!
protoVal
.
isObject
(
)
)
{
aDesiredProto
.
set
(
nullptr
)
;
return
true
;
}
aDesiredProto
.
set
(
&
protoVal
.
toObject
(
)
)
;
return
true
;
}
namespace
binding_detail
{
bool
HTMLConstructor
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
constructors
:
:
id
:
:
ID
aConstructorId
prototypes
:
:
id
:
:
ID
aProtoId
CreateInterfaceObjectsMethod
aCreator
)
{
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
aArgc
aVp
)
;
if
(
!
args
.
isConstructing
(
)
)
{
return
ThrowConstructorWithoutNew
(
aCx
NamesOfInterfacesWithProtos
(
aProtoId
)
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
callee
(
aCx
&
args
.
callee
(
)
)
;
GlobalObject
global
(
aCx
callee
)
;
if
(
global
.
Failed
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
global
.
GetAsSupports
(
)
)
;
if
(
!
window
)
{
return
Throw
(
aCx
NS_ERROR_UNEXPECTED
)
;
}
RefPtr
<
mozilla
:
:
dom
:
:
CustomElementRegistry
>
registry
(
window
-
>
CustomElements
(
)
)
;
nsIDocument
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
Throw
(
aCx
NS_ERROR_UNEXPECTED
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
newTarget
(
aCx
js
:
:
CheckedUnwrap
(
&
args
.
newTarget
(
)
.
toObject
(
)
)
)
;
if
(
!
newTarget
)
{
return
ThrowErrorMessage
(
aCx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
{
JSAutoRealm
ar
(
aCx
newTarget
)
;
JS
:
:
Handle
<
JSObject
*
>
constructor
=
GetPerInterfaceObjectHandle
(
aCx
aConstructorId
aCreator
true
)
;
if
(
!
constructor
)
{
return
false
;
}
if
(
newTarget
=
=
constructor
)
{
return
ThrowErrorMessage
(
aCx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
}
CustomElementDefinition
*
definition
=
registry
-
>
LookupCustomElementDefinition
(
aCx
newTarget
)
;
if
(
!
definition
)
{
return
ThrowErrorMessage
(
aCx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
int32_t
ns
=
doc
-
>
GetDefaultNamespaceID
(
)
;
if
(
ns
!
=
kNameSpaceID_XUL
)
{
ns
=
kNameSpaceID_XHTML
;
}
int32_t
tag
=
eHTMLTag_userdefined
;
if
(
!
definition
-
>
IsCustomBuiltIn
(
)
)
{
JSAutoRealm
ar
(
aCx
global
.
Get
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
constructor
(
aCx
)
;
if
(
ns
=
=
kNameSpaceID_XUL
)
{
constructor
=
XULElement_Binding
:
:
GetConstructorObject
(
aCx
)
;
}
else
{
constructor
=
HTMLElement_Binding
:
:
GetConstructorObject
(
aCx
)
;
}
if
(
!
constructor
)
{
return
false
;
}
if
(
constructor
!
=
js
:
:
CheckedUnwrap
(
callee
)
)
{
return
ThrowErrorMessage
(
aCx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
}
else
{
constructorGetterCallback
cb
;
if
(
ns
=
=
kNameSpaceID_XHTML
)
{
tag
=
nsHTMLTags
:
:
CaseSensitiveAtomTagToId
(
definition
-
>
mLocalName
)
;
if
(
tag
=
=
eHTMLTag_userdefined
)
{
return
ThrowErrorMessage
(
aCx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
MOZ_ASSERT
(
tag
<
=
NS_HTML_TAG_MAX
"
tag
is
out
of
bounds
"
)
;
cb
=
sConstructorGetterCallback
[
tag
]
;
}
else
{
if
(
definition
-
>
mLocalName
=
=
nsGkAtoms
:
:
menupopup
|
|
definition
-
>
mLocalName
=
=
nsGkAtoms
:
:
popup
|
|
definition
-
>
mLocalName
=
=
nsGkAtoms
:
:
panel
|
|
definition
-
>
mLocalName
=
=
nsGkAtoms
:
:
tooltip
)
{
cb
=
XULPopupElement_Binding
:
:
GetConstructorObject
;
}
else
if
(
definition
-
>
mLocalName
=
=
nsGkAtoms
:
:
iframe
|
|
definition
-
>
mLocalName
=
=
nsGkAtoms
:
:
browser
|
|
definition
-
>
mLocalName
=
=
nsGkAtoms
:
:
editor
)
{
cb
=
XULFrameElement_Binding
:
:
GetConstructorObject
;
}
else
{
cb
=
XULElement_Binding
:
:
GetConstructorObject
;
}
}
if
(
!
cb
)
{
return
ThrowErrorMessage
(
aCx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
JSAutoRealm
ar
(
aCx
global
.
Get
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
constructor
(
aCx
cb
(
aCx
)
)
;
if
(
!
constructor
)
{
return
false
;
}
if
(
constructor
!
=
js
:
:
CheckedUnwrap
(
callee
)
)
{
return
ThrowErrorMessage
(
aCx
MSG_ILLEGAL_CONSTRUCTOR
)
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
desiredProto
(
aCx
)
;
if
(
!
GetDesiredProto
(
aCx
args
&
desiredProto
)
)
{
return
false
;
}
if
(
!
desiredProto
)
{
{
JSAutoRealm
ar
(
aCx
newTarget
)
;
desiredProto
=
GetPerInterfaceObjectHandle
(
aCx
aProtoId
aCreator
true
)
;
if
(
!
desiredProto
)
{
return
false
;
}
}
if
(
!
JS_WrapObject
(
aCx
&
desiredProto
)
)
{
return
false
;
}
}
RefPtr
<
Element
>
element
;
nsTArray
<
RefPtr
<
Element
>
>
&
constructionStack
=
definition
-
>
mConstructionStack
;
if
(
constructionStack
.
IsEmpty
(
)
)
{
JSAutoRealm
ar
(
aCx
global
.
Get
(
)
)
;
RefPtr
<
NodeInfo
>
nodeInfo
=
doc
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
definition
-
>
mLocalName
nullptr
ns
nsINode
:
:
ELEMENT_NODE
)
;
MOZ_ASSERT
(
nodeInfo
)
;
if
(
ns
=
=
kNameSpaceID_XUL
)
{
element
=
nsXULElement
:
:
Construct
(
nodeInfo
.
forget
(
)
)
;
}
else
{
if
(
tag
=
=
eHTMLTag_userdefined
)
{
element
=
NS_NewHTMLElement
(
nodeInfo
.
forget
(
)
)
;
}
else
{
element
=
CreateHTMLElement
(
tag
nodeInfo
.
forget
(
)
NOT_FROM_PARSER
)
;
}
}
element
-
>
SetCustomElementData
(
new
CustomElementData
(
definition
-
>
mType
CustomElementData
:
:
State
:
:
eCustom
)
)
;
element
-
>
SetCustomElementDefinition
(
definition
)
;
}
else
{
element
=
constructionStack
.
LastElement
(
)
;
if
(
element
=
=
ALREADY_CONSTRUCTED_MARKER
)
{
return
Throw
(
aCx
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
reflector
(
aCx
element
-
>
GetWrapper
(
)
)
;
if
(
reflector
)
{
JSAutoRealm
ar
(
aCx
reflector
)
;
JS
:
:
Rooted
<
JSObject
*
>
givenProto
(
aCx
desiredProto
)
;
if
(
!
JS_WrapObject
(
aCx
&
givenProto
)
|
|
!
JS_SetPrototype
(
aCx
reflector
givenProto
)
)
{
return
false
;
}
}
constructionStack
.
LastElement
(
)
=
ALREADY_CONSTRUCTED_MARKER
;
}
JSAutoRealm
ar
(
aCx
global
.
Get
(
)
)
;
if
(
!
js
:
:
IsObjectInContextCompartment
(
desiredProto
aCx
)
&
&
!
JS_WrapObject
(
aCx
&
desiredProto
)
)
{
return
false
;
}
return
GetOrCreateDOMReflector
(
aCx
element
args
.
rval
(
)
desiredProto
)
;
}
}
#
ifdef
DEBUG
namespace
binding_detail
{
void
AssertReflectorHasGivenProto
(
JSContext
*
aCx
JSObject
*
aReflector
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
if
(
!
aGivenProto
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
reflector
(
aCx
aReflector
)
;
JSAutoRealm
ar
(
aCx
reflector
)
;
JS
:
:
Rooted
<
JSObject
*
>
reflectorProto
(
aCx
)
;
bool
ok
=
JS_GetPrototype
(
aCx
reflector
&
reflectorProto
)
;
MOZ_ASSERT
(
ok
)
;
JS
:
:
Rooted
<
JSObject
*
>
givenProto
(
aCx
aGivenProto
)
;
ok
=
JS_WrapObject
(
aCx
&
givenProto
)
;
MOZ_ASSERT
(
ok
)
;
MOZ_ASSERT
(
givenProto
=
=
reflectorProto
"
How
are
we
supposed
to
change
the
proto
now
?
"
)
;
}
}
#
endif
void
SetDocumentAndPageUseCounter
(
JSObject
*
aObject
UseCounter
aUseCounter
)
{
nsGlobalWindowInner
*
win
=
xpc
:
:
WindowGlobalOrNull
(
js
:
:
UncheckedUnwrap
(
aObject
)
)
;
if
(
win
&
&
win
-
>
GetDocument
(
)
)
{
win
-
>
GetDocument
(
)
-
>
SetDocumentAndPageUseCounter
(
aUseCounter
)
;
}
}
namespace
{
class
DeprecationWarningRunnable
final
:
public
WorkerProxyToMainThreadRunnable
{
nsIDocument
:
:
DeprecatedOperations
mOperation
;
public
:
explicit
DeprecationWarningRunnable
(
nsIDocument
:
:
DeprecatedOperations
aOperation
)
:
mOperation
(
aOperation
)
{
}
private
:
void
RunOnMainThread
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
WorkerPrivate
*
wp
=
aWorkerPrivate
;
while
(
wp
-
>
GetParent
(
)
)
{
wp
=
wp
-
>
GetParent
(
)
;
}
nsPIDOMWindowInner
*
window
=
wp
-
>
GetWindow
(
)
;
if
(
window
&
&
window
-
>
GetExtantDoc
(
)
)
{
window
-
>
GetExtantDoc
(
)
-
>
WarnOnceAbout
(
mOperation
)
;
}
}
void
RunBackOnWorkerThreadForCleanup
(
WorkerPrivate
*
aWorkerPrivate
)
override
{
}
}
;
}
void
DeprecationWarning
(
JSContext
*
aCx
JSObject
*
aObject
nsIDocument
:
:
DeprecatedOperations
aOperation
)
{
GlobalObject
global
(
aCx
aObject
)
;
if
(
global
.
Failed
(
)
)
{
NS_ERROR
(
"
Could
not
create
global
for
DeprecationWarning
"
)
;
return
;
}
DeprecationWarning
(
global
aOperation
)
;
}
void
DeprecationWarning
(
const
GlobalObject
&
aGlobal
nsIDocument
:
:
DeprecatedOperations
aOperation
)
{
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
window
&
&
window
-
>
GetExtantDoc
(
)
)
{
window
-
>
GetExtantDoc
(
)
-
>
WarnOnceAbout
(
aOperation
)
;
}
return
;
}
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aGlobal
.
Context
(
)
)
;
if
(
!
workerPrivate
)
{
return
;
}
RefPtr
<
DeprecationWarningRunnable
>
runnable
=
new
DeprecationWarningRunnable
(
aOperation
)
;
runnable
-
>
Dispatch
(
workerPrivate
)
;
}
namespace
binding_detail
{
JSObject
*
UnprivilegedJunkScopeOrWorkerGlobal
(
)
{
if
(
NS_IsMainThread
(
)
)
{
return
xpc
:
:
UnprivilegedJunkScope
(
)
;
}
return
GetCurrentThreadWorkerGlobal
(
)
;
}
}
JS
:
:
Handle
<
JSObject
*
>
GetPerInterfaceObjectHandle
(
JSContext
*
aCx
size_t
aSlotId
CreateInterfaceObjectsMethod
aCreator
bool
aDefineOnGlobal
)
{
JSObject
*
global
=
JS
:
:
CurrentGlobalOrNull
(
aCx
)
;
if
(
!
(
js
:
:
GetObjectClass
(
global
)
-
>
flags
&
JSCLASS_DOM_GLOBAL
)
)
{
return
nullptr
;
}
ProtoAndIfaceCache
&
protoAndIfaceCache
=
*
GetProtoAndIfaceCache
(
global
)
;
if
(
!
protoAndIfaceCache
.
HasEntryInSlot
(
aSlotId
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
rootedGlobal
(
aCx
global
)
;
aCreator
(
aCx
rootedGlobal
protoAndIfaceCache
aDefineOnGlobal
)
;
}
const
JS
:
:
Heap
<
JSObject
*
>
&
entrySlot
=
protoAndIfaceCache
.
EntrySlotMustExist
(
aSlotId
)
;
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
entrySlot
)
)
;
return
JS
:
:
Handle
<
JSObject
*
>
:
:
fromMarkedLocation
(
entrySlot
.
address
(
)
)
;
}
namespace
binding_detail
{
bool
IsGetterEnabled
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JSJitGetterOp
aGetter
const
Prefable
<
const
JSPropertySpec
>
*
aAttributes
)
{
MOZ_ASSERT
(
aAttributes
)
;
MOZ_ASSERT
(
aAttributes
-
>
specs
)
;
do
{
if
(
aAttributes
-
>
isEnabled
(
aCx
aObj
)
)
{
const
JSPropertySpec
*
specs
=
aAttributes
-
>
specs
;
do
{
MOZ_ASSERT
(
specs
-
>
isAccessor
(
)
)
;
if
(
specs
-
>
isSelfHosted
(
)
)
{
continue
;
}
const
JSJitInfo
*
info
=
specs
-
>
accessors
.
getter
.
native
.
info
;
if
(
!
info
)
{
continue
;
}
MOZ_ASSERT
(
info
-
>
type
(
)
=
=
JSJitInfo
:
:
OpType
:
:
Getter
)
;
if
(
info
-
>
getter
=
=
aGetter
)
{
return
true
;
}
}
while
(
(
+
+
specs
)
-
>
name
)
;
}
}
while
(
(
+
+
aAttributes
)
-
>
specs
)
;
return
false
;
}
}
}
}
