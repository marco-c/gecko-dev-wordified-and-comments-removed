#
ifndef
mozilla_dom_CallbackObject_h
#
define
mozilla_dom_CallbackObject_h
#
include
"
nsISupports
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
jswrapper
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
TracingAPI
.
h
"
namespace
mozilla
{
namespace
dom
{
#
define
DOM_CALLBACKOBJECT_IID
\
{
0xbe74c190
0x6d76
0x4991
\
{
0x84
0xb9
0x65
0x06
0x99
0xe6
0x93
0x2b
}
}
class
CallbackObject
:
public
nsISupports
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
DOM_CALLBACKOBJECT_IID
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
CallbackObject
)
explicit
CallbackObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCallback
nsIGlobalObject
*
aIncumbentGlobal
)
{
if
(
aCx
&
&
JS
:
:
ContextOptionsRef
(
aCx
)
.
asyncStack
(
)
)
{
JS
:
:
RootedObject
stack
(
aCx
)
;
if
(
!
JS
:
:
CaptureCurrentStack
(
aCx
&
stack
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
Init
(
aCallback
stack
aIncumbentGlobal
)
;
}
else
{
Init
(
aCallback
nullptr
aIncumbentGlobal
)
;
}
}
explicit
CallbackObject
(
JS
:
:
Handle
<
JSObject
*
>
aCallback
JS
:
:
Handle
<
JSObject
*
>
aAsyncStack
nsIGlobalObject
*
aIncumbentGlobal
)
{
Init
(
aCallback
aAsyncStack
aIncumbentGlobal
)
;
}
JS
:
:
Handle
<
JSObject
*
>
Callback
(
)
const
{
mCallback
.
exposeToActiveJS
(
)
;
return
CallbackPreserveColor
(
)
;
}
JSObject
*
GetCreationStack
(
)
const
{
return
mCreationStack
;
}
void
MarkForCC
(
)
{
mCallback
.
exposeToActiveJS
(
)
;
mCreationStack
.
exposeToActiveJS
(
)
;
}
JS
:
:
Handle
<
JSObject
*
>
CallbackPreserveColor
(
)
const
{
return
JS
:
:
Handle
<
JSObject
*
>
:
:
fromMarkedLocation
(
mCallback
.
address
(
)
)
;
}
JS
:
:
Handle
<
JSObject
*
>
CallbackKnownNotGray
(
)
const
{
MOZ_ASSERT
(
!
JS
:
:
ObjectIsMarkedGray
(
mCallback
)
)
;
return
CallbackPreserveColor
(
)
;
}
nsIGlobalObject
*
IncumbentGlobalOrNull
(
)
const
{
return
mIncumbentGlobal
;
}
enum
ExceptionHandling
{
eReportExceptions
eRethrowContentExceptions
eRethrowExceptions
}
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
protected
:
virtual
~
CallbackObject
(
)
{
DropJSObjects
(
)
;
}
explicit
CallbackObject
(
CallbackObject
*
aCallbackObject
)
{
Init
(
aCallbackObject
-
>
mCallback
aCallbackObject
-
>
mCreationStack
aCallbackObject
-
>
mIncumbentGlobal
)
;
}
bool
operator
=
=
(
const
CallbackObject
&
aOther
)
const
{
JSObject
*
thisObj
=
js
:
:
UncheckedUnwrap
(
CallbackPreserveColor
(
)
)
;
JSObject
*
otherObj
=
js
:
:
UncheckedUnwrap
(
aOther
.
CallbackPreserveColor
(
)
)
;
return
thisObj
=
=
otherObj
;
}
private
:
inline
void
InitNoHold
(
JSObject
*
aCallback
JSObject
*
aCreationStack
nsIGlobalObject
*
aIncumbentGlobal
)
{
MOZ_ASSERT
(
aCallback
&
&
!
mCallback
)
;
mCallback
=
aCallback
;
mCreationStack
=
aCreationStack
;
if
(
aIncumbentGlobal
)
{
mIncumbentGlobal
=
aIncumbentGlobal
;
mIncumbentJSGlobal
=
aIncumbentGlobal
-
>
GetGlobalJSObject
(
)
;
}
}
inline
void
Init
(
JSObject
*
aCallback
JSObject
*
aCreationStack
nsIGlobalObject
*
aIncumbentGlobal
)
{
InitNoHold
(
aCallback
aCreationStack
aIncumbentGlobal
)
;
mozilla
:
:
HoldJSObjects
(
this
)
;
}
inline
void
ClearJSReferences
(
)
{
mCallback
=
nullptr
;
mCreationStack
=
nullptr
;
mIncumbentJSGlobal
=
nullptr
;
}
CallbackObject
(
const
CallbackObject
&
)
=
delete
;
CallbackObject
&
operator
=
(
const
CallbackObject
&
)
=
delete
;
protected
:
void
DropJSObjects
(
)
{
MOZ_ASSERT_IF
(
mIncumbentJSGlobal
mCallback
)
;
if
(
mCallback
)
{
ClearJSReferences
(
)
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
}
void
Trace
(
JSTracer
*
aTracer
)
;
void
HoldJSObjectsIfMoreThanOneOwner
(
)
;
struct
FastCallbackConstructor
{
}
;
CallbackObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCallback
nsIGlobalObject
*
aIncumbentGlobal
const
FastCallbackConstructor
&
)
{
if
(
aCx
&
&
JS
:
:
ContextOptionsRef
(
aCx
)
.
asyncStack
(
)
)
{
JS
:
:
RootedObject
stack
(
aCx
)
;
if
(
!
JS
:
:
CaptureCurrentStack
(
aCx
&
stack
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
InitNoHold
(
aCallback
stack
aIncumbentGlobal
)
;
}
else
{
InitNoHold
(
aCallback
nullptr
aIncumbentGlobal
)
;
}
}
JS
:
:
Heap
<
JSObject
*
>
mCallback
;
JS
:
:
Heap
<
JSObject
*
>
mCreationStack
;
nsCOMPtr
<
nsIGlobalObject
>
mIncumbentGlobal
;
JS
:
:
TenuredHeap
<
JSObject
*
>
mIncumbentJSGlobal
;
class
MOZ_STACK_CLASS
CallSetup
{
public
:
CallSetup
(
CallbackObject
*
aCallback
ErrorResult
&
aRv
const
char
*
aExecutionReason
ExceptionHandling
aExceptionHandling
JSCompartment
*
aCompartment
=
nullptr
bool
aIsJSImplementedWebIDL
=
false
)
;
~
CallSetup
(
)
;
JSContext
*
GetContext
(
)
const
{
return
mCx
;
}
private
:
CallSetup
(
const
CallSetup
&
)
=
delete
;
bool
ShouldRethrowException
(
JS
:
:
Handle
<
JS
:
:
Value
>
aException
)
;
JSContext
*
mCx
;
JSCompartment
*
mCompartment
;
Maybe
<
AutoEntryScript
>
mAutoEntryScript
;
Maybe
<
AutoIncumbentScript
>
mAutoIncumbentScript
;
Maybe
<
JS
:
:
Rooted
<
JSObject
*
>
>
mRootedCallable
;
Maybe
<
JS
:
:
Rooted
<
JSObject
*
>
>
mAsyncStack
;
Maybe
<
JS
:
:
AutoSetAsyncStackForNewCalls
>
mAsyncStackSetter
;
Maybe
<
JSAutoCompartment
>
mAc
;
ErrorResult
&
mErrorResult
;
const
ExceptionHandling
mExceptionHandling
;
const
bool
mIsMainThread
;
}
;
}
;
template
<
class
WebIDLCallbackT
class
XPCOMCallbackT
>
class
CallbackObjectHolder
;
template
<
class
T
class
U
>
void
ImplCycleCollectionUnlink
(
CallbackObjectHolder
<
T
U
>
&
aField
)
;
class
CallbackObjectHolderBase
{
protected
:
already_AddRefed
<
nsISupports
>
ToXPCOMCallback
(
CallbackObject
*
aCallback
const
nsIID
&
aIID
)
const
;
}
;
template
<
class
WebIDLCallbackT
class
XPCOMCallbackT
>
class
CallbackObjectHolder
:
CallbackObjectHolderBase
{
public
:
explicit
CallbackObjectHolder
(
WebIDLCallbackT
*
aCallback
)
:
mPtrBits
(
reinterpret_cast
<
uintptr_t
>
(
aCallback
)
)
{
NS_IF_ADDREF
(
aCallback
)
;
}
explicit
CallbackObjectHolder
(
XPCOMCallbackT
*
aCallback
)
:
mPtrBits
(
reinterpret_cast
<
uintptr_t
>
(
aCallback
)
|
XPCOMCallbackFlag
)
{
NS_IF_ADDREF
(
aCallback
)
;
}
CallbackObjectHolder
(
CallbackObjectHolder
&
&
aOther
)
:
mPtrBits
(
aOther
.
mPtrBits
)
{
aOther
.
mPtrBits
=
0
;
static_assert
(
sizeof
(
CallbackObjectHolder
)
=
=
sizeof
(
void
*
)
"
This
object
is
expected
to
be
as
small
as
a
pointer
and
it
"
"
is
currently
passed
by
value
in
various
places
.
If
it
is
"
"
bloating
we
may
want
to
pass
it
by
reference
then
.
"
)
;
}
CallbackObjectHolder
(
const
CallbackObjectHolder
&
aOther
)
=
delete
;
CallbackObjectHolder
(
)
:
mPtrBits
(
0
)
{
}
~
CallbackObjectHolder
(
)
{
UnlinkSelf
(
)
;
}
void
operator
=
(
WebIDLCallbackT
*
aCallback
)
{
UnlinkSelf
(
)
;
mPtrBits
=
reinterpret_cast
<
uintptr_t
>
(
aCallback
)
;
NS_IF_ADDREF
(
aCallback
)
;
}
void
operator
=
(
XPCOMCallbackT
*
aCallback
)
{
UnlinkSelf
(
)
;
mPtrBits
=
reinterpret_cast
<
uintptr_t
>
(
aCallback
)
|
XPCOMCallbackFlag
;
NS_IF_ADDREF
(
aCallback
)
;
}
void
operator
=
(
CallbackObjectHolder
&
&
aOther
)
{
UnlinkSelf
(
)
;
mPtrBits
=
aOther
.
mPtrBits
;
aOther
.
mPtrBits
=
0
;
}
void
operator
=
(
const
CallbackObjectHolder
&
aOther
)
=
delete
;
nsISupports
*
GetISupports
(
)
const
{
return
reinterpret_cast
<
nsISupports
*
>
(
mPtrBits
&
~
XPCOMCallbackFlag
)
;
}
explicit
operator
bool
(
)
const
{
return
GetISupports
(
)
;
}
CallbackObjectHolder
Clone
(
)
const
{
CallbackObjectHolder
result
;
result
.
mPtrBits
=
mPtrBits
;
NS_IF_ADDREF
(
GetISupports
(
)
)
;
return
result
;
}
bool
HasWebIDLCallback
(
)
const
{
return
!
(
mPtrBits
&
XPCOMCallbackFlag
)
;
}
WebIDLCallbackT
*
GetWebIDLCallback
(
)
const
{
MOZ_ASSERT
(
HasWebIDLCallback
(
)
)
;
return
reinterpret_cast
<
WebIDLCallbackT
*
>
(
mPtrBits
)
;
}
XPCOMCallbackT
*
GetXPCOMCallback
(
)
const
{
MOZ_ASSERT
(
!
HasWebIDLCallback
(
)
)
;
return
reinterpret_cast
<
XPCOMCallbackT
*
>
(
mPtrBits
&
~
XPCOMCallbackFlag
)
;
}
bool
operator
=
=
(
WebIDLCallbackT
*
aOtherCallback
)
const
{
if
(
!
aOtherCallback
)
{
return
!
GetISupports
(
)
;
}
if
(
!
HasWebIDLCallback
(
)
|
|
!
GetWebIDLCallback
(
)
)
{
return
false
;
}
return
*
GetWebIDLCallback
(
)
=
=
*
aOtherCallback
;
}
bool
operator
=
=
(
XPCOMCallbackT
*
aOtherCallback
)
const
{
return
(
!
aOtherCallback
&
&
!
GetISupports
(
)
)
|
|
(
!
HasWebIDLCallback
(
)
&
&
GetXPCOMCallback
(
)
=
=
aOtherCallback
)
;
}
bool
operator
=
=
(
const
CallbackObjectHolder
&
aOtherCallback
)
const
{
if
(
aOtherCallback
.
HasWebIDLCallback
(
)
)
{
return
*
this
=
=
aOtherCallback
.
GetWebIDLCallback
(
)
;
}
return
*
this
=
=
aOtherCallback
.
GetXPCOMCallback
(
)
;
}
already_AddRefed
<
XPCOMCallbackT
>
ToXPCOMCallback
(
)
const
{
if
(
!
HasWebIDLCallback
(
)
)
{
RefPtr
<
XPCOMCallbackT
>
callback
=
GetXPCOMCallback
(
)
;
return
callback
.
forget
(
)
;
}
nsCOMPtr
<
nsISupports
>
supp
=
CallbackObjectHolderBase
:
:
ToXPCOMCallback
(
GetWebIDLCallback
(
)
NS_GET_TEMPLATE_IID
(
XPCOMCallbackT
)
)
;
return
supp
.
forget
(
)
.
downcast
<
XPCOMCallbackT
>
(
)
;
}
already_AddRefed
<
WebIDLCallbackT
>
ToWebIDLCallback
(
)
const
{
if
(
HasWebIDLCallback
(
)
)
{
RefPtr
<
WebIDLCallbackT
>
callback
=
GetWebIDLCallback
(
)
;
return
callback
.
forget
(
)
;
}
return
nullptr
;
}
private
:
static
const
uintptr_t
XPCOMCallbackFlag
=
1u
;
friend
void
ImplCycleCollectionUnlink
<
WebIDLCallbackT
XPCOMCallbackT
>
(
CallbackObjectHolder
&
aField
)
;
void
UnlinkSelf
(
)
{
nsISupports
*
ptr
=
GetISupports
(
)
;
NS_IF_RELEASE
(
ptr
)
;
mPtrBits
=
0
;
}
uintptr_t
mPtrBits
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
CallbackObject
DOM_CALLBACKOBJECT_IID
)
template
<
class
T
class
U
>
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
CallbackObjectHolder
<
T
U
>
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
CycleCollectionNoteChild
(
aCallback
aField
.
GetISupports
(
)
aName
aFlags
)
;
}
template
<
class
T
class
U
>
void
ImplCycleCollectionUnlink
(
CallbackObjectHolder
<
T
U
>
&
aField
)
{
aField
.
UnlinkSelf
(
)
;
}
template
<
typename
T
>
class
RootedCallback
:
public
JS
:
:
Rooted
<
T
>
{
public
:
explicit
RootedCallback
(
JSContext
*
cx
)
:
JS
:
:
Rooted
<
T
>
(
cx
)
{
}
template
<
typename
S
>
void
operator
=
(
S
*
arg
)
{
this
-
>
get
(
)
.
operator
=
(
arg
)
;
}
void
operator
=
(
decltype
(
nullptr
)
arg
)
{
this
-
>
get
(
)
.
operator
=
(
arg
)
;
}
JS
:
:
Handle
<
JSObject
*
>
Callback
(
)
const
{
return
this
-
>
get
(
)
-
>
Callback
(
)
;
}
~
RootedCallback
(
)
{
if
(
IsInitialized
(
this
-
>
get
(
)
)
)
{
this
-
>
get
(
)
-
>
HoldJSObjectsIfMoreThanOneOwner
(
)
;
}
}
private
:
template
<
typename
U
>
static
bool
IsInitialized
(
U
&
aArg
)
;
template
<
typename
U
>
static
bool
IsInitialized
(
RefPtr
<
U
>
&
aRefPtr
)
{
return
aRefPtr
;
}
template
<
typename
U
>
static
bool
IsInitialized
(
OwningNonNull
<
U
>
&
aOwningNonNull
)
{
return
aOwningNonNull
.
isInitialized
(
)
;
}
}
;
}
}
#
endif
