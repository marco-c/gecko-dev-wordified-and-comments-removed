from
WebIDL
import
IDLIncludesStatement
import
os
from
collections
import
defaultdict
autogenerated_comment
=
"
/
*
THIS
FILE
IS
AUTOGENERATED
-
DO
NOT
EDIT
*
/
\
n
"
class
DescriptorProvider
:
    
"
"
"
    
A
way
of
getting
descriptors
for
interface
names
.
Subclasses
must
    
have
a
getDescriptor
method
callable
with
the
interface
name
only
.
    
Subclasses
must
also
have
a
getConfig
(
)
method
that
returns
a
    
Configuration
.
    
"
"
"
    
def
__init__
(
self
)
:
        
pass
def
isChildPath
(
path
basePath
)
:
    
path
=
os
.
path
.
normpath
(
path
)
    
return
os
.
path
.
commonprefix
(
(
path
basePath
)
)
=
=
basePath
class
Configuration
(
DescriptorProvider
)
:
    
"
"
"
    
Represents
global
configuration
state
based
on
IDL
parse
data
and
    
the
configuration
file
.
    
"
"
"
    
def
__init__
(
self
filename
webRoots
parseData
generatedEvents
=
[
]
)
:
        
DescriptorProvider
.
__init__
(
self
)
        
glbl
=
{
}
        
execfile
(
filename
glbl
)
        
config
=
glbl
[
'
DOMInterfaces
'
]
        
webRoots
=
tuple
(
map
(
os
.
path
.
normpath
webRoots
)
)
        
def
isInWebIDLRoot
(
path
)
:
            
return
any
(
isChildPath
(
path
root
)
for
root
in
webRoots
)
        
self
.
descriptors
=
[
]
        
self
.
interfaces
=
{
}
        
self
.
descriptorsByName
=
{
}
        
self
.
dictionariesByName
=
{
}
        
self
.
generatedEvents
=
generatedEvents
        
self
.
maxProtoChainLength
=
0
        
for
thing
in
parseData
:
            
if
isinstance
(
thing
IDLIncludesStatement
)
:
                
if
(
thing
.
interface
.
filename
(
)
!
=
thing
.
filename
(
)
)
:
                    
raise
TypeError
(
                        
"
The
binding
build
system
doesn
'
t
really
support
"
                        
"
'
includes
'
statements
which
don
'
t
appear
in
the
"
                        
"
file
in
which
the
left
-
hand
side
of
the
statement
is
"
                        
"
defined
.
\
n
"
                        
"
%
s
\
n
"
                        
"
%
s
"
%
                        
(
thing
.
location
thing
.
interface
.
location
)
)
            
assert
not
thing
.
isType
(
)
            
if
(
not
thing
.
isInterface
(
)
and
not
thing
.
isNamespace
(
)
and
                
not
thing
.
isInterfaceMixin
(
)
)
:
                
continue
            
if
not
thing
.
isExternal
(
)
:
                
for
partial
in
thing
.
getPartials
(
)
:
                    
if
partial
.
filename
(
)
!
=
thing
.
filename
(
)
:
                        
raise
TypeError
(
                            
"
The
binding
build
system
doesn
'
t
really
support
"
                            
"
partial
interfaces
/
namespaces
/
mixins
which
don
'
t
"
                            
"
appear
in
the
file
in
which
the
"
                            
"
interface
/
namespace
/
mixin
they
are
extending
is
"
                            
"
defined
.
Don
'
t
do
this
.
\
n
"
                            
"
%
s
\
n
"
                            
"
%
s
"
%
                            
(
partial
.
location
thing
.
location
)
)
            
if
thing
.
isInterfaceMixin
(
)
:
                
continue
            
iface
=
thing
            
if
not
iface
.
isExternal
(
)
:
                
if
not
(
iface
.
getExtendedAttribute
(
"
ChromeOnly
"
)
or
                        
iface
.
getExtendedAttribute
(
"
Func
"
)
=
=
[
"
IsChromeOrXBL
"
]
or
                        
iface
.
getExtendedAttribute
(
"
Func
"
)
=
=
[
"
nsContentUtils
:
:
IsCallerChromeOrFuzzingEnabled
"
]
or
                        
not
iface
.
hasInterfaceObject
(
)
or
                        
isInWebIDLRoot
(
iface
.
filename
(
)
)
)
:
                    
raise
TypeError
(
                        
"
Interfaces
which
are
exposed
to
the
web
may
only
be
"
                        
"
defined
in
a
DOM
WebIDL
root
%
r
.
Consider
marking
"
                        
"
the
interface
[
ChromeOnly
]
or
[
Func
=
'
IsChromeOrXBL
'
]
"
                        
"
if
you
do
not
want
it
exposed
to
the
web
.
\
n
"
                        
"
%
s
"
%
                        
(
webRoots
iface
.
location
)
)
            
self
.
interfaces
[
iface
.
identifier
.
name
]
=
iface
            
entry
=
config
.
get
(
iface
.
identifier
.
name
{
}
)
            
assert
not
isinstance
(
entry
list
)
            
desc
=
Descriptor
(
self
iface
entry
)
            
self
.
descriptors
.
append
(
desc
)
            
assert
desc
.
interface
.
identifier
.
name
not
in
self
.
descriptorsByName
            
self
.
descriptorsByName
[
desc
.
interface
.
identifier
.
name
]
=
desc
        
self
.
descriptors
.
sort
(
lambda
x
y
:
cmp
(
x
.
name
y
.
name
)
)
        
self
.
descriptorsByFile
=
{
}
        
for
d
in
self
.
descriptors
:
            
self
.
descriptorsByFile
.
setdefault
(
d
.
interface
.
filename
(
)
                                              
[
]
)
.
append
(
d
)
        
self
.
enums
=
[
e
for
e
in
parseData
if
e
.
isEnum
(
)
]
        
self
.
dictionaries
=
[
d
for
d
in
parseData
if
d
.
isDictionary
(
)
]
        
self
.
dictionariesByName
=
{
d
.
identifier
.
name
:
d
for
d
in
self
.
dictionaries
}
        
self
.
callbacks
=
[
c
for
c
in
parseData
if
                          
c
.
isCallback
(
)
and
not
c
.
isInterface
(
)
]
        
self
.
filenamesPerUnion
=
defaultdict
(
set
)
        
self
.
unionsPerFilename
=
defaultdict
(
list
)
        
for
(
t
_
)
in
getAllTypes
(
self
.
descriptors
self
.
dictionaries
self
.
callbacks
)
:
            
t
=
findInnermostType
(
t
)
            
if
t
.
isUnion
(
)
:
                
filenamesForUnion
=
self
.
filenamesPerUnion
[
t
.
name
]
                
if
t
.
filename
(
)
not
in
filenamesForUnion
:
                    
if
t
.
filename
(
)
=
=
"
<
unknown
>
"
:
                        
uniqueFilenameForUnion
=
None
                    
elif
len
(
filenamesForUnion
)
=
=
0
:
                        
uniqueFilenameForUnion
=
t
.
filename
(
)
                    
else
:
                        
if
len
(
filenamesForUnion
)
=
=
1
:
                            
for
f
in
filenamesForUnion
:
                                
unionsForFilename
=
self
.
unionsPerFilename
[
f
]
                                
unionsForFilename
=
filter
(
lambda
u
:
u
.
name
!
=
t
.
name
                                                           
unionsForFilename
)
                                
if
len
(
unionsForFilename
)
=
=
0
:
                                    
del
self
.
unionsPerFilename
[
f
]
                                
else
:
                                    
self
.
unionsPerFilename
[
f
]
=
unionsForFilename
                        
uniqueFilenameForUnion
=
None
                    
self
.
unionsPerFilename
[
uniqueFilenameForUnion
]
.
append
(
t
)
                    
filenamesForUnion
.
add
(
t
.
filename
(
)
)
        
for
d
in
getDictionariesConvertedToJS
(
self
.
descriptors
self
.
dictionaries
                                              
self
.
callbacks
)
:
            
d
.
needsConversionToJS
=
True
        
for
d
in
getDictionariesConvertedFromJS
(
self
.
descriptors
self
.
dictionaries
                                                
self
.
callbacks
)
:
            
d
.
needsConversionFromJS
=
True
    
def
getInterface
(
self
ifname
)
:
        
return
self
.
interfaces
[
ifname
]
    
def
getDescriptors
(
self
*
*
filters
)
:
        
"
"
"
Gets
the
descriptors
that
match
the
given
filters
.
"
"
"
        
curr
=
self
.
descriptors
        
tofilter
=
[
(
lambda
x
:
x
.
interface
.
isExternal
(
)
False
)
]
        
for
key
val
in
filters
.
iteritems
(
)
:
            
if
key
=
=
'
webIDLFile
'
:
                
curr
=
self
.
descriptorsByFile
.
get
(
val
[
]
)
                
continue
            
elif
key
=
=
'
hasInterfaceObject
'
:
                
getter
=
lambda
x
:
x
.
interface
.
hasInterfaceObject
(
)
            
elif
key
=
=
'
hasInterfacePrototypeObject
'
:
                
getter
=
lambda
x
:
x
.
interface
.
hasInterfacePrototypeObject
(
)
            
elif
key
=
=
'
hasInterfaceOrInterfacePrototypeObject
'
:
                
getter
=
lambda
x
:
x
.
hasInterfaceOrInterfacePrototypeObject
(
)
            
elif
key
=
=
'
isCallback
'
:
                
getter
=
lambda
x
:
x
.
interface
.
isCallback
(
)
            
elif
key
=
=
'
isJSImplemented
'
:
                
getter
=
lambda
x
:
x
.
interface
.
isJSImplemented
(
)
            
elif
key
=
=
'
isExposedInAnyWorker
'
:
                
getter
=
lambda
x
:
x
.
interface
.
isExposedInAnyWorker
(
)
            
elif
key
=
=
'
isExposedInWorkerDebugger
'
:
                
getter
=
lambda
x
:
x
.
interface
.
isExposedInWorkerDebugger
(
)
            
elif
key
=
=
'
isExposedInAnyWorklet
'
:
                
getter
=
lambda
x
:
x
.
interface
.
isExposedInAnyWorklet
(
)
            
elif
key
=
=
'
isExposedInWindow
'
:
                
getter
=
lambda
x
:
x
.
interface
.
isExposedInWindow
(
)
            
elif
key
=
=
'
isSerializable
'
:
                
getter
=
lambda
x
:
x
.
interface
.
isSerializable
(
)
            
else
:
                
getter
=
(
lambda
attrName
:
lambda
x
:
getattr
(
x
attrName
)
)
(
key
)
            
tofilter
.
append
(
(
getter
val
)
)
        
for
f
in
tofilter
:
            
curr
=
filter
(
lambda
x
:
f
[
0
]
(
x
)
=
=
f
[
1
]
curr
)
        
return
curr
    
def
getEnums
(
self
webIDLFile
)
:
        
return
filter
(
lambda
e
:
e
.
filename
(
)
=
=
webIDLFile
self
.
enums
)
    
def
getDictionaries
(
self
webIDLFile
)
:
        
return
filter
(
lambda
d
:
d
.
filename
(
)
=
=
webIDLFile
self
.
dictionaries
)
    
def
getCallbacks
(
self
webIDLFile
)
:
        
return
filter
(
lambda
c
:
c
.
filename
(
)
=
=
webIDLFile
self
.
callbacks
)
    
def
getDescriptor
(
self
interfaceName
)
:
        
"
"
"
        
Gets
the
appropriate
descriptor
for
the
given
interface
name
.
        
"
"
"
        
d
=
self
.
descriptorsByName
.
get
(
interfaceName
None
)
        
if
d
:
            
return
d
        
raise
NoSuchDescriptorError
(
"
For
"
+
interfaceName
+
"
found
no
matches
"
)
    
def
getConfig
(
self
)
:
        
return
self
    
def
getDictionariesConvertibleToJS
(
self
)
:
        
return
filter
(
lambda
d
:
d
.
needsConversionToJS
self
.
dictionaries
)
    
def
getDictionariesConvertibleFromJS
(
self
)
:
        
return
filter
(
lambda
d
:
d
.
needsConversionFromJS
self
.
dictionaries
)
    
def
getDictionaryIfExists
(
self
dictionaryName
)
:
        
return
self
.
dictionariesByName
.
get
(
dictionaryName
None
)
class
NoSuchDescriptorError
(
TypeError
)
:
    
def
__init__
(
self
str
)
:
        
TypeError
.
__init__
(
self
str
)
def
methodReturnsJSObject
(
method
)
:
    
assert
method
.
isMethod
(
)
    
for
signature
in
method
.
signatures
(
)
:
        
returnType
=
signature
[
0
]
        
if
returnType
.
isObject
(
)
or
returnType
.
isSpiderMonkeyInterface
(
)
:
            
return
True
    
return
False
def
MemberIsUnforgeable
(
member
descriptor
)
:
    
return
bool
(
(
member
.
isAttr
(
)
or
member
.
isMethod
(
)
)
and
                
not
member
.
isStatic
(
)
and
                
(
member
.
isUnforgeable
(
)
or
                 
descriptor
.
interface
.
getExtendedAttribute
(
"
Unforgeable
"
)
)
)
class
Descriptor
(
DescriptorProvider
)
:
    
"
"
"
    
Represents
a
single
descriptor
for
an
interface
.
See
Bindings
.
conf
.
    
"
"
"
    
def
__init__
(
self
config
interface
desc
)
:
        
DescriptorProvider
.
__init__
(
self
)
        
self
.
config
=
config
        
self
.
interface
=
interface
        
self
.
wantsXrays
=
(
not
interface
.
isExternal
(
)
and
                           
interface
.
isExposedInWindow
(
)
)
        
if
self
.
wantsXrays
:
            
self
.
wantsXrayExpandoClass
=
(
interface
.
totalMembersInSlots
!
=
0
)
        
ifaceName
=
self
.
interface
.
identifier
.
name
        
if
self
.
interface
.
isIteratorInterface
(
)
:
            
itrName
=
self
.
interface
.
iterableInterface
.
identifier
.
name
            
itrDesc
=
self
.
getDescriptor
(
itrName
)
            
nativeTypeDefault
=
iteratorNativeType
(
itrDesc
)
        
elif
self
.
interface
.
isExternal
(
)
:
            
nativeTypeDefault
=
"
nsIDOM
"
+
ifaceName
        
else
:
            
nativeTypeDefault
=
"
mozilla
:
:
dom
:
:
"
+
ifaceName
        
self
.
nativeType
=
desc
.
get
(
'
nativeType
'
nativeTypeDefault
)
        
prettyNativeType
=
self
.
nativeType
.
split
(
"
:
:
"
)
        
if
prettyNativeType
[
0
]
=
=
"
mozilla
"
:
            
prettyNativeType
.
pop
(
0
)
            
if
prettyNativeType
[
0
]
=
=
"
dom
"
:
                
prettyNativeType
.
pop
(
0
)
        
self
.
prettyNativeType
=
"
:
:
"
.
join
(
prettyNativeType
)
        
self
.
jsImplParent
=
desc
.
get
(
'
jsImplParent
'
self
.
nativeType
)
        
if
self
.
nativeType
=
=
"
JSObject
"
:
            
headerDefault
=
"
js
/
TypeDecls
.
h
"
        
elif
self
.
interface
.
isCallback
(
)
or
self
.
interface
.
isJSImplemented
(
)
:
            
basename
=
os
.
path
.
basename
(
self
.
interface
.
filename
(
)
)
            
headerDefault
=
basename
.
replace
(
'
.
webidl
'
'
Binding
.
h
'
)
        
else
:
            
if
not
self
.
interface
.
isExternal
(
)
and
self
.
interface
.
getExtendedAttribute
(
"
HeaderFile
"
)
:
                
headerDefault
=
self
.
interface
.
getExtendedAttribute
(
"
HeaderFile
"
)
[
0
]
            
elif
self
.
interface
.
isIteratorInterface
(
)
:
                
headerDefault
=
"
mozilla
/
dom
/
IterableIterator
.
h
"
            
else
:
                
headerDefault
=
self
.
nativeType
                
headerDefault
=
headerDefault
.
replace
(
"
:
:
"
"
/
"
)
+
"
.
h
"
        
self
.
headerFile
=
desc
.
get
(
'
headerFile
'
headerDefault
)
        
self
.
headerIsDefault
=
self
.
headerFile
=
=
headerDefault
        
if
self
.
jsImplParent
=
=
self
.
nativeType
:
            
self
.
jsImplParentHeader
=
self
.
headerFile
        
else
:
            
self
.
jsImplParentHeader
=
self
.
jsImplParent
.
replace
(
"
:
:
"
"
/
"
)
+
"
.
h
"
        
self
.
notflattened
=
desc
.
get
(
'
notflattened
'
False
)
        
self
.
register
=
desc
.
get
(
'
register
'
True
)
        
concreteDefault
=
(
not
self
.
interface
.
isExternal
(
)
and
                           
not
self
.
interface
.
isCallback
(
)
and
                           
not
self
.
interface
.
isNamespace
(
)
and
                           
(
not
self
.
interface
.
hasChildInterfaces
(
)
or
                            
self
.
interface
.
ctor
(
)
is
not
None
)
)
        
self
.
concrete
=
desc
.
get
(
'
concrete
'
concreteDefault
)
        
self
.
hasUnforgeableMembers
=
(
self
.
concrete
and
                                      
any
(
MemberIsUnforgeable
(
m
self
)
for
m
in
                                          
self
.
interface
.
members
)
)
        
self
.
operations
=
{
            
'
IndexedGetter
'
:
None
            
'
IndexedSetter
'
:
None
            
'
IndexedDeleter
'
:
None
            
'
NamedGetter
'
:
None
            
'
NamedSetter
'
:
None
            
'
NamedDeleter
'
:
None
            
'
Stringifier
'
:
None
            
'
LegacyCaller
'
:
None
            
}
        
self
.
hasDefaultToJSON
=
False
        
def
addOperation
(
operation
m
)
:
            
if
not
self
.
operations
[
operation
]
:
                
self
.
operations
[
operation
]
=
m
        
if
not
self
.
interface
.
isExternal
(
)
:
            
for
m
in
self
.
interface
.
members
:
                
if
m
.
isMethod
(
)
and
m
.
isStringifier
(
)
:
                    
addOperation
(
'
Stringifier
'
m
)
                
if
m
.
isMethod
(
)
and
m
.
isDefaultToJSON
(
)
:
                    
self
.
hasDefaultToJSON
=
True
        
if
self
.
concrete
:
            
self
.
proxy
=
False
            
self
.
instrumentedProps
=
[
]
            
iface
=
self
.
interface
            
for
m
in
iface
.
members
:
                
if
m
.
isMethod
(
)
and
m
.
isLegacycaller
(
)
:
                    
if
not
m
.
isIdentifierLess
(
)
:
                        
raise
TypeError
(
"
We
don
'
t
support
legacycaller
with
"
                                        
"
identifier
.
\
n
%
s
"
%
m
.
location
)
                    
if
len
(
m
.
signatures
(
)
)
!
=
1
:
                        
raise
TypeError
(
"
We
don
'
t
support
overloaded
"
                                        
"
legacycaller
.
\
n
%
s
"
%
m
.
location
)
                    
addOperation
(
'
LegacyCaller
'
m
)
            
while
iface
:
                
instrumentedProps
=
iface
.
getExtendedAttribute
(
"
InstrumentedProps
"
)
                
if
instrumentedProps
:
                    
for
prop
in
instrumentedProps
[
0
]
:
                        
self
.
instrumentedProps
.
append
(
(
iface
.
identifier
.
name
                                                       
prop
)
)
                
for
m
in
iface
.
members
:
                    
if
not
m
.
isMethod
(
)
:
                        
continue
                    
def
addIndexedOrNamedOperation
(
operation
m
)
:
                        
if
m
.
isIndexed
(
)
:
                            
operation
=
'
Indexed
'
+
operation
                        
else
:
                            
assert
m
.
isNamed
(
)
                            
operation
=
'
Named
'
+
operation
                        
addOperation
(
operation
m
)
                    
if
m
.
isGetter
(
)
:
                        
addIndexedOrNamedOperation
(
'
Getter
'
m
)
                    
if
m
.
isSetter
(
)
:
                        
addIndexedOrNamedOperation
(
'
Setter
'
m
)
                    
if
m
.
isDeleter
(
)
:
                        
addIndexedOrNamedOperation
(
'
Deleter
'
m
)
                    
if
m
.
isLegacycaller
(
)
and
iface
!
=
self
.
interface
:
                        
raise
TypeError
(
"
We
don
'
t
support
legacycaller
on
"
                                        
"
non
-
leaf
interface
%
s
.
\
n
%
s
"
%
                                        
(
iface
iface
.
location
)
)
                
iface
.
setUserData
(
'
hasConcreteDescendant
'
True
)
                
iface
=
iface
.
parent
            
uniqueInstrumentedProps
=
set
(
prop
[
1
]
for
prop
in
self
.
instrumentedProps
)
            
if
len
(
uniqueInstrumentedProps
)
!
=
len
(
self
.
instrumentedProps
)
:
                
for
prop
in
self
.
instrumentedProps
:
                    
name
=
prop
[
1
]
                    
if
name
in
uniqueInstrumentedProps
:
                        
uniqueInstrumentedProps
.
remove
(
name
)
                    
else
:
                        
ifaces
=
list
(
                            
entry
[
0
]
for
entry
in
self
.
instrumentedProps
if
                            
entry
[
1
]
=
=
name
)
                        
raise
TypeError
(
                            
"
Duplicated
instrumented
property
'
%
s
'
defined
on
"
                            
"
these
interfaces
:
%
s
.
"
%
(
name
str
(
ifaces
)
)
)
            
self
.
proxy
=
(
self
.
supportsIndexedProperties
(
)
or
                          
(
self
.
supportsNamedProperties
(
)
and
                           
not
self
.
hasNamedPropertiesObject
)
or
                          
self
.
isMaybeCrossOriginObject
(
)
)
            
if
self
.
proxy
:
                
if
(
self
.
isMaybeCrossOriginObject
(
)
and
                    
(
self
.
supportsIndexedProperties
(
)
or
                     
self
.
supportsNamedProperties
(
)
)
)
:
                    
raise
TypeError
(
"
We
don
'
t
support
named
or
indexed
"
                                    
"
properties
on
maybe
-
cross
-
origin
objects
.
"
                                    
"
This
lets
us
assume
that
their
proxy
"
                                    
"
hooks
are
never
called
via
Xrays
.
"
                                    
"
Fix
%
s
.
\
n
%
s
"
%
                                    
(
self
.
interface
self
.
interface
.
location
)
)
                
if
(
not
self
.
operations
[
'
IndexedGetter
'
]
and
                    
(
self
.
operations
[
'
IndexedSetter
'
]
or
                     
self
.
operations
[
'
IndexedDeleter
'
]
)
)
:
                    
raise
SyntaxError
(
"
%
s
supports
indexed
properties
but
does
"
                                      
"
not
have
an
indexed
getter
.
\
n
%
s
"
%
                                      
(
self
.
interface
self
.
interface
.
location
)
)
                
if
(
not
self
.
operations
[
'
NamedGetter
'
]
and
                    
(
self
.
operations
[
'
NamedSetter
'
]
or
                     
self
.
operations
[
'
NamedDeleter
'
]
)
)
:
                    
raise
SyntaxError
(
"
%
s
supports
named
properties
but
does
"
                                      
"
not
have
a
named
getter
.
\
n
%
s
"
%
                                      
(
self
.
interface
self
.
interface
.
location
)
)
                
iface
=
self
.
interface
                
while
iface
:
                    
iface
.
setUserData
(
'
hasProxyDescendant
'
True
)
                    
iface
=
iface
.
parent
        
if
desc
.
get
(
'
wantsQI
'
None
)
is
not
None
:
            
self
.
_wantsQI
=
desc
.
get
(
'
wantsQI
'
None
)
        
self
.
wrapperCache
=
(
not
self
.
interface
.
isCallback
(
)
and
                             
not
self
.
interface
.
isIteratorInterface
(
)
and
                             
desc
.
get
(
'
wrapperCache
'
True
)
)
        
self
.
name
=
interface
.
identifier
.
name
        
self
.
extendedAttributes
=
{
'
all
'
:
{
}
'
getterOnly
'
:
{
}
'
setterOnly
'
:
{
}
}
        
def
addExtendedAttribute
(
attribute
config
)
:
            
def
add
(
key
members
attribute
)
:
                
for
member
in
members
:
                    
self
.
extendedAttributes
[
key
]
.
setdefault
(
member
[
]
)
.
append
(
attribute
)
            
if
isinstance
(
config
dict
)
:
                
for
key
in
[
'
all
'
'
getterOnly
'
'
setterOnly
'
]
:
                    
add
(
key
config
.
get
(
key
[
]
)
attribute
)
            
elif
isinstance
(
config
list
)
:
                
add
(
'
all
'
config
attribute
)
            
else
:
                
assert
isinstance
(
config
str
)
                
if
config
=
=
'
*
'
:
                    
iface
=
self
.
interface
                    
while
iface
:
                        
add
(
'
all
'
map
(
lambda
m
:
m
.
name
iface
.
members
)
attribute
)
                        
iface
=
iface
.
parent
                
else
:
                    
add
(
'
all
'
[
config
]
attribute
)
        
if
self
.
interface
.
isJSImplemented
(
)
:
            
addExtendedAttribute
(
'
implicitJSContext
'
[
'
constructor
'
]
)
        
else
:
            
for
attribute
in
[
'
implicitJSContext
'
]
:
                
addExtendedAttribute
(
attribute
desc
.
get
(
attribute
{
}
)
)
        
self
.
_binaryNames
=
{
}
        
if
not
self
.
interface
.
isExternal
(
)
:
            
def
maybeAddBinaryName
(
member
)
:
                
binaryName
=
member
.
getExtendedAttribute
(
"
BinaryName
"
)
                
if
binaryName
:
                    
assert
isinstance
(
binaryName
list
)
                    
assert
len
(
binaryName
)
=
=
1
                    
self
.
_binaryNames
.
setdefault
(
member
.
identifier
.
name
                                                 
binaryName
[
0
]
)
            
for
member
in
self
.
interface
.
members
:
                
if
not
member
.
isAttr
(
)
and
not
member
.
isMethod
(
)
:
                    
continue
                
maybeAddBinaryName
(
member
)
;
            
ctor
=
self
.
interface
.
ctor
(
)
            
if
ctor
:
                
maybeAddBinaryName
(
ctor
)
        
self
.
_binaryNames
.
setdefault
(
'
__legacycaller
'
'
LegacyCall
'
)
        
self
.
_binaryNames
.
setdefault
(
'
__stringifier
'
'
Stringify
'
)
        
self
.
prototypeChain
=
[
]
        
parent
=
interface
        
while
parent
:
            
self
.
prototypeChain
.
insert
(
0
parent
.
identifier
.
name
)
            
parent
=
parent
.
parent
        
config
.
maxProtoChainLength
=
max
(
config
.
maxProtoChainLength
                                         
len
(
self
.
prototypeChain
)
)
    
def
binaryNameFor
(
self
name
)
:
        
return
self
.
_binaryNames
.
get
(
name
name
)
    
property
    
def
prototypeNameChain
(
self
)
:
        
return
map
(
lambda
p
:
self
.
getDescriptor
(
p
)
.
name
self
.
prototypeChain
)
    
property
    
def
parentPrototypeName
(
self
)
:
        
if
len
(
self
.
prototypeChain
)
=
=
1
:
            
return
None
        
return
self
.
getDescriptor
(
self
.
prototypeChain
[
-
2
]
)
.
name
    
def
hasInterfaceOrInterfacePrototypeObject
(
self
)
:
        
return
(
self
.
interface
.
hasInterfaceObject
(
)
or
                
self
.
interface
.
hasInterfacePrototypeObject
(
)
)
    
property
    
def
hasNamedPropertiesObject
(
self
)
:
        
return
self
.
isGlobal
(
)
and
self
.
supportsNamedProperties
(
)
    
def
getExtendedAttributes
(
self
member
getter
=
False
setter
=
False
)
:
        
def
ensureValidBoolExtendedAttribute
(
attr
name
)
:
            
if
(
attr
is
not
None
and
attr
is
not
True
)
:
                
raise
TypeError
(
"
Unknown
value
for
'
%
s
'
:
%
s
"
%
(
name
attr
[
0
]
)
)
        
def
ensureValidThrowsExtendedAttribute
(
attr
)
:
            
ensureValidBoolExtendedAttribute
(
attr
"
Throws
"
)
        
def
ensureValidCanOOMExtendedAttribute
(
attr
)
:
            
ensureValidBoolExtendedAttribute
(
attr
"
CanOOM
"
)
        
def
ensureValidNeedsSubjectPrincipalExtendedAttribute
(
attr
)
:
            
ensureValidBoolExtendedAttribute
(
attr
"
NeedsSubjectPrincipal
"
)
        
def
maybeAppendInfallibleToAttrs
(
attrs
throws
)
:
            
ensureValidThrowsExtendedAttribute
(
throws
)
            
if
throws
is
None
:
                
attrs
.
append
(
"
infallible
"
)
        
def
maybeAppendCanOOMToAttrs
(
attrs
canOOM
)
:
            
ensureValidCanOOMExtendedAttribute
(
canOOM
)
            
if
canOOM
is
not
None
:
                
attrs
.
append
(
"
canOOM
"
)
        
def
maybeAppendNeedsSubjectPrincipalToAttrs
(
attrs
needsSubjectPrincipal
)
:
            
if
(
needsSubjectPrincipal
is
not
None
and
                
needsSubjectPrincipal
is
not
True
and
                
needsSubjectPrincipal
!
=
[
"
NonSystem
"
]
)
:
                
raise
TypeError
(
"
Unknown
value
for
'
NeedsSubjectPrincipal
'
:
%
s
"
%
                                
needsSubjectPrincipal
[
0
]
)
            
if
needsSubjectPrincipal
is
not
None
:
                
attrs
.
append
(
"
needsSubjectPrincipal
"
)
                
if
needsSubjectPrincipal
=
=
[
"
NonSystem
"
]
:
                    
attrs
.
append
(
"
needsNonSystemSubjectPrincipal
"
)
        
name
=
member
.
identifier
.
name
        
throws
=
self
.
interface
.
isJSImplemented
(
)
or
member
.
getExtendedAttribute
(
"
Throws
"
)
        
canOOM
=
member
.
getExtendedAttribute
(
"
CanOOM
"
)
        
needsSubjectPrincipal
=
member
.
getExtendedAttribute
(
"
NeedsSubjectPrincipal
"
)
        
if
member
.
isMethod
(
)
:
            
if
member
.
getExtendedAttribute
(
"
NewObject
"
)
:
                
if
member
.
returnsPromise
(
)
:
                    
throws
=
True
                
elif
methodReturnsJSObject
(
member
)
:
                    
canOOM
=
True
            
attrs
=
self
.
extendedAttributes
[
'
all
'
]
.
get
(
name
[
]
)
            
maybeAppendInfallibleToAttrs
(
attrs
throws
)
            
maybeAppendCanOOMToAttrs
(
attrs
canOOM
)
            
maybeAppendNeedsSubjectPrincipalToAttrs
(
attrs
                                                    
needsSubjectPrincipal
)
            
return
attrs
        
assert
member
.
isAttr
(
)
        
assert
bool
(
getter
)
!
=
bool
(
setter
)
        
key
=
'
getterOnly
'
if
getter
else
'
setterOnly
'
        
attrs
=
self
.
extendedAttributes
[
'
all
'
]
.
get
(
name
[
]
)
+
self
.
extendedAttributes
[
key
]
.
get
(
name
[
]
)
        
if
throws
is
None
:
            
throwsAttr
=
"
GetterThrows
"
if
getter
else
"
SetterThrows
"
            
throws
=
member
.
getExtendedAttribute
(
throwsAttr
)
        
maybeAppendInfallibleToAttrs
(
attrs
throws
)
        
if
canOOM
is
None
:
            
canOOMAttr
=
"
GetterCanOOM
"
if
getter
else
"
SetterCanOOM
"
            
canOOM
=
member
.
getExtendedAttribute
(
canOOMAttr
)
        
maybeAppendCanOOMToAttrs
(
attrs
canOOM
)
        
if
needsSubjectPrincipal
is
None
:
            
needsSubjectPrincipalAttr
=
(
                
"
GetterNeedsSubjectPrincipal
"
if
getter
else
"
SetterNeedsSubjectPrincipal
"
)
            
needsSubjectPrincipal
=
member
.
getExtendedAttribute
(
                
needsSubjectPrincipalAttr
)
        
maybeAppendNeedsSubjectPrincipalToAttrs
(
attrs
needsSubjectPrincipal
)
        
return
attrs
    
def
supportsIndexedProperties
(
self
)
:
        
return
self
.
operations
[
'
IndexedGetter
'
]
is
not
None
    
def
lengthNeedsCallerType
(
self
)
:
        
"
"
"
        
Determine
whether
our
length
getter
needs
a
caller
type
;
this
is
needed
        
in
some
indexed
-
getter
proxy
algorithms
.
The
idea
is
that
if
our
        
indexed
getter
needs
a
caller
type
our
automatically
-
generated
Length
(
)
        
calls
need
one
too
.
        
"
"
"
        
assert
self
.
supportsIndexedProperties
(
)
        
indexedGetter
=
self
.
operations
[
'
IndexedGetter
'
]
        
return
indexedGetter
.
getExtendedAttribute
(
"
NeedsCallerType
"
)
    
def
supportsNamedProperties
(
self
)
:
        
return
self
.
operations
[
'
NamedGetter
'
]
is
not
None
    
def
supportedNamesNeedCallerType
(
self
)
:
        
"
"
"
        
Determine
whether
our
GetSupportedNames
call
needs
a
caller
type
.
The
        
idea
is
that
if
your
named
getter
needs
a
caller
type
then
so
does
        
GetSupportedNames
.
        
"
"
"
        
assert
self
.
supportsNamedProperties
(
)
        
namedGetter
=
self
.
operations
[
'
NamedGetter
'
]
        
return
namedGetter
.
getExtendedAttribute
(
"
NeedsCallerType
"
)
    
def
isMaybeCrossOriginObject
(
self
)
:
        
return
self
.
concrete
and
self
.
interface
.
hasCrossOriginMembers
and
not
self
.
isGlobal
(
)
    
def
needsHeaderInclude
(
self
)
:
        
"
"
"
        
An
interface
doesn
'
t
need
a
header
file
if
it
is
not
concrete
not
        
pref
-
controlled
has
no
prototype
object
has
no
static
methods
or
        
attributes
and
has
no
parent
.
The
parent
matters
because
we
assert
        
things
about
refcounting
that
depend
on
the
actual
underlying
type
if
we
        
have
a
parent
.
        
"
"
"
        
return
(
self
.
interface
.
isExternal
(
)
or
self
.
concrete
or
                
self
.
interface
.
hasInterfacePrototypeObject
(
)
or
                
any
(
(
m
.
isAttr
(
)
or
m
.
isMethod
(
)
)
and
m
.
isStatic
(
)
for
m
in
self
.
interface
.
members
)
or
                
self
.
interface
.
parent
)
    
def
hasThreadChecks
(
self
)
:
        
return
(
(
self
.
isExposedConditionally
(
)
and
                 
not
self
.
interface
.
isExposedInWindow
(
)
)
or
                
self
.
interface
.
isExposedInSomeButNotAllWorkers
(
)
)
    
def
hasCEReactions
(
self
)
:
        
return
any
(
m
.
getExtendedAttribute
(
"
CEReactions
"
)
for
m
in
self
.
interface
.
members
)
    
def
isExposedConditionally
(
self
)
:
        
return
(
self
.
interface
.
isExposedConditionally
(
)
or
                
self
.
interface
.
isExposedInSomeButNotAllWorkers
(
)
)
    
def
needsXrayResolveHooks
(
self
)
:
        
"
"
"
        
Generally
any
interface
with
NeedResolve
needs
Xray
        
resolveOwnProperty
and
enumerateOwnProperties
hooks
.
But
for
        
the
special
case
of
plugin
-
loading
elements
we
do
NOT
want
        
those
because
we
don
'
t
want
to
instantiate
plug
-
ins
simply
        
due
to
chrome
touching
them
and
that
'
s
all
those
hooks
do
on
        
those
elements
.
So
we
special
-
case
those
here
.
        
"
"
"
        
return
(
self
.
interface
.
getExtendedAttribute
(
"
NeedResolve
"
)
and
                
self
.
interface
.
identifier
.
name
not
in
[
"
HTMLObjectElement
"
                                                       
"
HTMLEmbedElement
"
]
)
    
def
needsXrayNamedDeleterHook
(
self
)
:
        
return
self
.
operations
[
"
NamedDeleter
"
]
is
not
None
    
def
isGlobal
(
self
)
:
        
"
"
"
        
Returns
true
if
this
is
the
primary
interface
for
a
global
object
        
of
some
sort
.
        
"
"
"
        
return
self
.
interface
.
getExtendedAttribute
(
"
Global
"
)
    
property
    
def
namedPropertiesEnumerable
(
self
)
:
        
"
"
"
        
Returns
whether
this
interface
should
have
enumerable
named
properties
        
"
"
"
        
assert
self
.
proxy
        
assert
self
.
supportsNamedProperties
(
)
        
iface
=
self
.
interface
        
while
iface
:
            
if
iface
.
getExtendedAttribute
(
"
LegacyUnenumerableNamedProperties
"
)
:
                
return
False
            
iface
=
iface
.
parent
        
return
True
    
property
    
def
registersGlobalNamesOnWindow
(
self
)
:
        
return
(
self
.
interface
.
hasInterfaceObject
(
)
and
                
self
.
interface
.
isExposedInWindow
(
)
and
                
self
.
register
)
    
def
getDescriptor
(
self
interfaceName
)
:
        
"
"
"
        
Gets
the
appropriate
descriptor
for
the
given
interface
name
.
        
"
"
"
        
return
self
.
config
.
getDescriptor
(
interfaceName
)
    
def
getConfig
(
self
)
:
        
return
self
.
config
def
getTypesFromDescriptor
(
descriptor
includeArgs
=
True
includeReturns
=
True
)
:
    
"
"
"
    
Get
argument
and
/
or
return
types
for
all
members
of
the
descriptor
.
By
    
default
returns
all
argument
types
(
which
includes
types
of
writable
    
attributes
)
and
all
return
types
(
which
includes
types
of
all
attributes
)
.
    
"
"
"
    
assert
(
includeArgs
or
includeReturns
)
    
members
=
[
m
for
m
in
descriptor
.
interface
.
members
]
    
if
descriptor
.
interface
.
ctor
(
)
:
        
members
.
append
(
descriptor
.
interface
.
ctor
(
)
)
    
members
.
extend
(
descriptor
.
interface
.
namedConstructors
)
    
signatures
=
[
s
for
m
in
members
if
m
.
isMethod
(
)
for
s
in
m
.
signatures
(
)
]
    
types
=
[
]
    
for
s
in
signatures
:
        
assert
len
(
s
)
=
=
2
        
(
returnType
arguments
)
=
s
        
if
includeReturns
:
            
types
.
append
(
returnType
)
        
if
includeArgs
:
            
types
.
extend
(
a
.
type
for
a
in
arguments
)
    
types
.
extend
(
a
.
type
for
a
in
members
if
                 
(
a
.
isAttr
(
)
and
(
includeReturns
or
                                  
(
includeArgs
and
not
a
.
readonly
)
)
)
)
    
if
descriptor
.
interface
.
maplikeOrSetlikeOrIterable
:
        
maplikeOrSetlikeOrIterable
=
descriptor
.
interface
.
maplikeOrSetlikeOrIterable
        
if
maplikeOrSetlikeOrIterable
.
isMaplike
(
)
:
            
assert
maplikeOrSetlikeOrIterable
.
hasKeyType
(
)
            
assert
maplikeOrSetlikeOrIterable
.
hasValueType
(
)
            
if
includeReturns
:
                
types
.
append
(
maplikeOrSetlikeOrIterable
.
keyType
)
                
types
.
append
(
maplikeOrSetlikeOrIterable
.
valueType
)
        
elif
maplikeOrSetlikeOrIterable
.
isSetlike
(
)
:
            
assert
maplikeOrSetlikeOrIterable
.
hasKeyType
(
)
            
assert
maplikeOrSetlikeOrIterable
.
hasValueType
(
)
            
assert
maplikeOrSetlikeOrIterable
.
keyType
=
=
maplikeOrSetlikeOrIterable
.
valueType
            
if
includeReturns
:
                
types
.
append
(
maplikeOrSetlikeOrIterable
.
keyType
)
        
else
:
            
assert
maplikeOrSetlikeOrIterable
.
isIterable
(
)
            
if
includeReturns
:
                
if
maplikeOrSetlikeOrIterable
.
hasKeyType
(
)
:
                    
types
.
append
(
maplikeOrSetlikeOrIterable
.
keyType
)
                
if
maplikeOrSetlikeOrIterable
.
hasValueType
(
)
:
                    
types
.
append
(
maplikeOrSetlikeOrIterable
.
valueType
)
    
return
types
def
getTypesFromDictionary
(
dictionary
)
:
    
"
"
"
    
Get
all
member
types
for
this
dictionary
    
"
"
"
    
types
=
[
]
    
curDict
=
dictionary
    
while
curDict
:
        
types
.
extend
(
[
m
.
type
for
m
in
curDict
.
members
]
)
        
curDict
=
curDict
.
parent
    
return
types
def
getTypesFromCallback
(
callback
)
:
    
"
"
"
    
Get
the
types
this
callback
depends
on
:
its
return
type
and
the
    
types
of
its
arguments
.
    
"
"
"
    
sig
=
callback
.
signatures
(
)
[
0
]
    
types
=
[
sig
[
0
]
]
    
types
.
extend
(
arg
.
type
for
arg
in
sig
[
1
]
)
    
return
types
def
getAllTypes
(
descriptors
dictionaries
callbacks
)
:
    
"
"
"
    
Generate
all
the
types
we
'
re
dealing
with
.
For
each
type
a
tuple
    
containing
type
dictionary
is
yielded
.
The
dictionary
can
be
None
if
the
    
type
does
not
come
from
a
dictionary
.
    
"
"
"
    
for
d
in
descriptors
:
        
if
d
.
interface
.
isExternal
(
)
:
            
continue
        
for
t
in
getTypesFromDescriptor
(
d
)
:
            
yield
(
t
None
)
    
for
dictionary
in
dictionaries
:
        
for
t
in
getTypesFromDictionary
(
dictionary
)
:
            
yield
(
t
dictionary
)
    
for
callback
in
callbacks
:
        
for
t
in
getTypesFromCallback
(
callback
)
:
            
yield
(
t
None
)
def
iteratorNativeType
(
descriptor
)
:
    
assert
descriptor
.
interface
.
isIterable
(
)
    
iterableDecl
=
descriptor
.
interface
.
maplikeOrSetlikeOrIterable
    
assert
iterableDecl
.
isPairIterator
(
)
    
return
"
mozilla
:
:
dom
:
:
IterableIterator
<
%
s
>
"
%
descriptor
.
nativeType
def
findInnermostType
(
t
)
:
    
"
"
"
    
Find
the
innermost
type
of
the
given
type
unwrapping
Promise
and
Record
    
types
as
well
as
everything
that
unroll
(
)
unwraps
.
    
"
"
"
    
while
True
:
        
if
t
.
isRecord
(
)
:
            
t
=
t
.
inner
        
elif
t
.
unroll
(
)
!
=
t
:
            
t
=
t
.
unroll
(
)
        
elif
t
.
isPromise
(
)
:
            
t
=
t
.
promiseInnerType
(
)
        
else
:
            
return
t
def
getDependentDictionariesFromDictionary
(
d
)
:
    
"
"
"
    
Find
all
the
dictionaries
contained
in
the
given
dictionary
as
ancestors
or
    
members
.
This
returns
a
generator
.
    
"
"
"
    
while
d
:
        
yield
d
        
for
member
in
d
.
members
:
            
for
next
in
getDictionariesFromType
(
member
.
type
)
:
                
yield
next
        
d
=
d
.
parent
def
getDictionariesFromType
(
type
)
:
    
"
"
"
    
Find
all
the
dictionaries
contained
in
type
.
This
can
be
used
to
find
    
dictionaries
that
need
conversion
to
JS
(
by
looking
at
types
that
get
    
converted
to
JS
)
or
dictionaries
that
need
conversion
from
JS
(
by
looking
at
    
types
that
get
converted
from
JS
)
.
    
This
returns
a
generator
.
    
"
"
"
    
type
=
findInnermostType
(
type
)
    
if
type
.
isUnion
(
)
:
        
for
t
in
type
.
flatMemberTypes
:
            
for
next
in
getDictionariesFromType
(
t
)
:
                
yield
next
    
elif
type
.
isDictionary
(
)
:
        
for
d
in
getDependentDictionariesFromDictionary
(
type
.
inner
)
:
            
yield
d
def
getDictionariesConvertedToJS
(
descriptors
dictionaries
callbacks
)
:
    
for
desc
in
descriptors
:
        
if
desc
.
interface
.
isExternal
(
)
:
            
continue
        
if
desc
.
interface
.
isJSImplemented
(
)
:
            
for
t
in
getTypesFromDescriptor
(
desc
)
:
                
for
d
in
getDictionariesFromType
(
t
)
:
                    
yield
d
        
elif
desc
.
interface
.
isCallback
(
)
:
            
for
t
in
getTypesFromDescriptor
(
desc
includeReturns
=
False
)
:
                
for
d
in
getDictionariesFromType
(
t
)
:
                    
yield
d
        
else
:
            
for
t
in
getTypesFromDescriptor
(
desc
includeArgs
=
False
)
:
                
for
d
in
getDictionariesFromType
(
t
)
:
                    
yield
d
    
for
callback
in
callbacks
:
        
sig
=
callback
.
signatures
(
)
[
0
]
        
for
arg
in
sig
[
1
]
:
            
for
d
in
getDictionariesFromType
(
arg
.
type
)
:
                
yield
d
    
for
dictionary
in
dictionaries
:
        
if
dictionary
.
needsConversionToJS
:
            
for
d
in
getDependentDictionariesFromDictionary
(
dictionary
)
:
                
yield
d
def
getDictionariesConvertedFromJS
(
descriptors
dictionaries
callbacks
)
:
    
for
desc
in
descriptors
:
        
if
desc
.
interface
.
isExternal
(
)
:
            
continue
        
if
desc
.
interface
.
isJSImplemented
(
)
:
            
for
t
in
getTypesFromDescriptor
(
desc
)
:
                
for
d
in
getDictionariesFromType
(
t
)
:
                    
yield
d
        
elif
desc
.
interface
.
isCallback
(
)
:
            
for
t
in
getTypesFromDescriptor
(
desc
includeArgs
=
False
)
:
                
for
d
in
getDictionariesFromType
(
t
)
:
                    
yield
d
        
else
:
            
for
t
in
getTypesFromDescriptor
(
desc
includeReturns
=
False
)
:
                
for
d
in
getDictionariesFromType
(
t
)
:
                    
yield
d
    
for
callback
in
callbacks
:
        
sig
=
callback
.
signatures
(
)
[
0
]
        
for
d
in
getDictionariesFromType
(
sig
[
0
]
)
:
            
yield
d
    
for
dictionary
in
dictionaries
:
        
if
dictionary
.
needsConversionFromJS
:
            
for
d
in
getDependentDictionariesFromDictionary
(
dictionary
)
:
                
yield
d
