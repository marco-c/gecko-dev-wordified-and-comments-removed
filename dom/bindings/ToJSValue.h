#
ifndef
mozilla_dom_ToJSValue_h
#
define
mozilla_dom_ToJSValue_h
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
ErrorList
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
GCVector
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
js
/
ValueArray
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
CallbackObject
.
h
"
#
include
"
mozilla
/
dom
/
Record
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArrayForwardDeclare
.
h
"
#
include
"
xpcObjectHelper
.
h
"
namespace
mozilla
:
:
dom
{
class
CallbackObject
;
class
Promise
;
class
WindowProxyHolder
;
template
<
typename
TypedArrayType
>
class
TypedArrayCreator
;
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
nsAString
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
nsACString
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
std
:
:
is_same
<
T
bool
>
:
:
value
bool
>
ToJSValue
(
JSContext
*
aCx
T
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
setBoolean
(
aArgument
)
;
return
true
;
}
inline
bool
ToJSValue
(
JSContext
*
aCx
int32_t
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
setInt32
(
aArgument
)
;
return
true
;
}
inline
bool
ToJSValue
(
JSContext
*
aCx
uint32_t
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
setNumber
(
aArgument
)
;
return
true
;
}
inline
bool
ToJSValue
(
JSContext
*
aCx
int64_t
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
setNumber
(
double
(
aArgument
)
)
;
return
true
;
}
inline
bool
ToJSValue
(
JSContext
*
aCx
uint64_t
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
setNumber
(
double
(
aArgument
)
)
;
return
true
;
}
inline
bool
ToJSValue
(
JSContext
*
aCx
float
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
setNumber
(
aArgument
)
;
return
true
;
}
inline
bool
ToJSValue
(
JSContext
*
aCx
double
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
set
(
JS_NumberValue
(
aArgument
)
)
;
return
true
;
}
[
[
nodiscard
]
]
inline
bool
ToJSValue
(
JSContext
*
aCx
CallbackObject
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
aValue
.
setObjectOrNull
(
aArgument
.
Callback
(
aCx
)
)
;
return
MaybeWrapValue
(
aCx
aValue
)
;
}
template
<
class
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
nsWrapperCache
T
>
:
:
value
bool
>
ToJSValue
(
JSContext
*
aCx
T
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
return
GetOrCreateDOMReflector
(
aCx
aArgument
aValue
)
;
}
namespace
binding_detail
{
template
<
class
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
NonRefcountedDOMObject
T
>
:
:
value
bool
>
ToJSValueFromPointerHelper
(
JSContext
*
aCx
T
*
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
if
(
!
aArgument
)
{
aValue
.
setNull
(
)
;
return
true
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
)
;
if
(
!
aArgument
-
>
WrapObject
(
aCx
nullptr
&
obj
)
)
{
return
false
;
}
aValue
.
setObject
(
*
obj
)
;
return
true
;
}
}
template
<
class
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
NonRefcountedDOMObject
T
>
:
:
value
bool
>
ToJSValue
(
JSContext
*
aCx
UniquePtr
<
T
>
&
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
if
(
!
binding_detail
:
:
ToJSValueFromPointerHelper
(
aCx
aArgument
.
get
(
)
aValue
)
)
{
return
false
;
}
Unused
<
<
aArgument
.
release
(
)
;
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
typename
std
:
:
enable_if
<
std
:
:
is_base_of
<
AllTypedArraysBase
T
>
:
:
value
bool
>
:
:
type
ToJSValue
(
JSContext
*
aCx
const
TypedArrayCreator
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
JSObject
*
obj
=
aArgument
.
Create
(
aCx
)
;
if
(
!
obj
)
{
return
false
;
}
aValue
.
setObject
(
*
obj
)
;
return
true
;
}
namespace
binding_detail
{
template
<
typename
T
typename
=
void
>
struct
GetScriptableInterfaceType
{
using
Type
=
nsISupports
;
static_assert
(
std
:
:
is_base_of_v
<
nsISupports
T
>
"
T
must
inherit
from
nsISupports
"
)
;
}
;
template
<
typename
T
>
struct
GetScriptableInterfaceType
<
T
std
:
:
void_t
<
typename
T
:
:
ScriptableInterfaceType
>
>
{
using
Type
=
typename
T
:
:
ScriptableInterfaceType
;
static_assert
(
std
:
:
is_base_of_v
<
Type
T
>
"
T
must
inherit
from
ScriptableInterfaceType
"
)
;
static_assert
(
std
:
:
is_base_of_v
<
nsISupports
Type
>
"
ScriptableInterfaceType
must
inherit
from
nsISupports
"
)
;
}
;
template
<
typename
T
>
using
ScriptableInterfaceType
=
typename
GetScriptableInterfaceType
<
T
>
:
:
Type
;
}
template
<
class
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
!
std
:
:
is_base_of
<
nsWrapperCache
T
>
:
:
value
&
&
!
std
:
:
is_base_of
<
CallbackObject
T
>
:
:
value
&
&
std
:
:
is_base_of
<
nsISupports
T
>
:
:
value
bool
>
ToJSValue
(
JSContext
*
aCx
T
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
xpcObjectHelper
helper
(
ToSupports
(
&
aArgument
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
const
nsIID
&
iid
=
NS_GET_TEMPLATE_IID
(
binding_detail
:
:
ScriptableInterfaceType
<
T
>
)
;
return
XPCOMObjectToJsval
(
aCx
scope
helper
&
iid
true
aValue
)
;
}
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
WindowProxyHolder
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
nsCOMPtr
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
*
aArgument
.
get
(
)
aValue
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
RefPtr
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
*
aArgument
.
get
(
)
aValue
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
NonNull
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
*
aArgument
.
get
(
)
aValue
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
OwningNonNull
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
*
aArgument
.
get
(
)
aValue
)
;
}
template
<
class
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
DictionaryBase
T
>
:
:
value
bool
>
ToJSValue
(
JSContext
*
aCx
const
T
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
aArgument
.
ToObjectInternal
(
aCx
aValue
)
;
}
[
[
nodiscard
]
]
inline
bool
ToJSValue
(
JSContext
*
aCx
const
JS
:
:
Value
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
aValue
.
set
(
aArgument
)
;
return
MaybeWrapValue
(
aCx
aValue
)
;
}
[
[
nodiscard
]
]
inline
bool
ToJSValue
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
aValue
.
set
(
aArgument
)
;
return
MaybeWrapValue
(
aCx
aValue
)
;
}
[
[
nodiscard
]
]
inline
bool
ToJSValue
(
JSContext
*
aCx
const
JS
:
:
Heap
<
JS
:
:
Value
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
aValue
.
set
(
aArgument
)
;
return
MaybeWrapValue
(
aCx
aValue
)
;
}
[
[
nodiscard
]
]
inline
bool
ToJSValue
(
JSContext
*
aCx
const
JS
:
:
Rooted
<
JS
:
:
Value
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
aValue
.
set
(
aArgument
)
;
return
MaybeWrapValue
(
aCx
aValue
)
;
}
[
[
nodiscard
]
]
inline
bool
ToJSValue
(
JSContext
*
aCx
const
JS
:
:
Rooted
<
JSObject
*
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
aValue
.
setObjectOrNull
(
aArgument
)
;
return
MaybeWrapObjectOrNullValue
(
aCx
aValue
)
;
}
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
nsresult
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
ErrorResult
&
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
std
:
:
is_base_of
<
AllOwningUnionBase
T
>
:
:
value
bool
>
ToJSValue
(
JSContext
*
aCx
const
T
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
return
aArgument
.
ToJSVal
(
aCx
global
aValue
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
std
:
:
enable_if_t
<
std
:
:
is_pointer
<
T
>
:
:
value
bool
>
ToJSValue
(
JSContext
*
aCx
T
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
*
aArgument
aValue
)
;
}
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
Promise
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
T
*
aArguments
size_t
aLength
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
nsTArray
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
aArgument
.
Elements
(
)
aArgument
.
Length
(
)
aValue
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
FallibleTArray
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
aArgument
.
Elements
(
)
aArgument
.
Length
(
)
aValue
)
;
}
template
<
typename
T
int
N
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
T
(
&
aArgument
)
[
N
]
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
return
ToJSValue
(
aCx
aArgument
N
aValue
)
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
T
*
aArguments
size_t
aLength
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
JS
:
:
RootedVector
<
JS
:
:
Value
>
v
(
aCx
)
;
if
(
!
v
.
resize
(
aLength
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
if
(
!
ToJSValue
(
aCx
aArguments
[
i
]
v
[
i
]
)
)
{
return
false
;
}
}
JSObject
*
arrayObj
=
JS
:
:
NewArrayObject
(
aCx
v
)
;
if
(
!
arrayObj
)
{
return
false
;
}
aValue
.
setObject
(
*
arrayObj
)
;
return
true
;
}
template
<
typename
K
typename
V
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
Record
<
K
V
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
JS
:
:
Rooted
<
JSObject
*
>
recordObj
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
!
recordObj
)
{
return
false
;
}
for
(
auto
&
entry
:
aArgument
.
Entries
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
entry
.
mValue
&
value
)
)
{
return
false
;
}
if
constexpr
(
std
:
:
is_same_v
<
nsCString
decltype
(
entry
.
mKey
)
>
)
{
NS_ConvertUTF8toUTF16
expandedKey
(
entry
.
mKey
)
;
if
(
!
JS_DefineUCProperty
(
aCx
recordObj
expandedKey
.
BeginReading
(
)
expandedKey
.
Length
(
)
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
else
{
if
(
!
JS_DefineUCProperty
(
aCx
recordObj
entry
.
mKey
.
BeginReading
(
)
entry
.
mKey
.
Length
(
)
value
JSPROP_ENUMERATE
)
)
{
return
false
;
}
}
}
aValue
.
setObject
(
*
recordObj
)
;
return
true
;
}
template
<
typename
T
>
[
[
nodiscard
]
]
bool
ToJSValue
(
JSContext
*
aCx
const
Nullable
<
T
>
&
aArgument
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
if
(
aArgument
.
IsNull
(
)
)
{
aValue
.
setNull
(
)
;
return
true
;
}
return
ToJSValue
(
aCx
aArgument
.
Value
(
)
aValue
)
;
}
}
#
endif
