#
include
"
WebIDLGlobalNameHash
.
h
"
#
include
"
js
/
Class
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
Id
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSClass
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSProxyHandler
.
h
"
#
include
"
mozilla
/
dom
/
JSSlots
.
h
"
#
include
"
mozilla
/
dom
/
PrototypeList
.
h
"
#
include
"
mozilla
/
dom
/
RegisterBindings
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
WrapperFactory
.
h
"
namespace
mozilla
{
namespace
dom
{
struct
MOZ_STACK_CLASS
WebIDLNameTableKey
{
explicit
WebIDLNameTableKey
(
JSFlatString
*
aJSString
)
:
mLength
(
js
:
:
GetFlatStringLength
(
aJSString
)
)
{
mNogc
.
emplace
(
)
;
JSLinearString
*
jsString
=
js
:
:
FlatStringToLinearString
(
aJSString
)
;
if
(
js
:
:
LinearStringHasLatin1Chars
(
jsString
)
)
{
mLatin1String
=
reinterpret_cast
<
const
char
*
>
(
js
:
:
GetLatin1LinearStringChars
(
*
mNogc
jsString
)
)
;
mTwoBytesString
=
nullptr
;
mHash
=
mLatin1String
?
HashString
(
mLatin1String
mLength
)
:
0
;
}
else
{
mLatin1String
=
nullptr
;
mTwoBytesString
=
js
:
:
GetTwoByteLinearStringChars
(
*
mNogc
jsString
)
;
mHash
=
mTwoBytesString
?
HashString
(
mTwoBytesString
mLength
)
:
0
;
}
}
explicit
WebIDLNameTableKey
(
const
char
*
aString
size_t
aLength
)
:
mLatin1String
(
aString
)
mTwoBytesString
(
nullptr
)
mLength
(
aLength
)
mHash
(
HashString
(
aString
aLength
)
)
{
MOZ_ASSERT
(
aString
[
aLength
]
=
=
'
\
0
'
)
;
}
Maybe
<
JS
:
:
AutoCheckCannotGC
>
mNogc
;
const
char
*
mLatin1String
;
const
char16_t
*
mTwoBytesString
;
size_t
mLength
;
PLDHashNumber
mHash
;
}
;
struct
WebIDLNameTableEntry
:
public
PLDHashEntryHdr
{
typedef
const
WebIDLNameTableKey
&
KeyType
;
typedef
const
WebIDLNameTableKey
*
KeyTypePointer
;
explicit
WebIDLNameTableEntry
(
KeyTypePointer
aKey
)
:
mNameOffset
(
0
)
mNameLength
(
0
)
mConstructorId
(
constructors
:
:
id
:
:
_ID_Count
)
mCreate
(
nullptr
)
mEnabled
(
nullptr
)
{
}
WebIDLNameTableEntry
(
WebIDLNameTableEntry
&
&
aEntry
)
:
mNameOffset
(
aEntry
.
mNameOffset
)
mNameLength
(
aEntry
.
mNameLength
)
mConstructorId
(
aEntry
.
mConstructorId
)
mCreate
(
aEntry
.
mCreate
)
mEnabled
(
aEntry
.
mEnabled
)
{
}
~
WebIDLNameTableEntry
(
)
{
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
if
(
mNameLength
!
=
aKey
-
>
mLength
)
{
return
false
;
}
const
char
*
name
=
WebIDLGlobalNameHash
:
:
sNames
+
mNameOffset
;
if
(
aKey
-
>
mLatin1String
)
{
return
ArrayEqual
(
aKey
-
>
mLatin1String
name
aKey
-
>
mLength
)
;
}
return
nsCharTraits
<
char16_t
>
:
:
compareASCII
(
aKey
-
>
mTwoBytesString
name
aKey
-
>
mLength
)
=
=
0
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
aKey
-
>
mHash
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
uint16_t
mNameOffset
;
uint16_t
mNameLength
;
constructors
:
:
id
:
:
ID
mConstructorId
;
CreateInterfaceObjectsMethod
mCreate
;
WebIDLGlobalNameHash
:
:
ConstructorEnabled
mEnabled
;
}
;
static
nsTHashtable
<
WebIDLNameTableEntry
>
*
sWebIDLGlobalNames
;
class
WebIDLGlobalNamesHashReporter
final
:
public
nsIMemoryReporter
{
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
~
WebIDLGlobalNamesHashReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
int64_t
amount
=
sWebIDLGlobalNames
?
sWebIDLGlobalNames
-
>
ShallowSizeOfIncludingThis
(
MallocSizeOf
)
:
0
;
MOZ_COLLECT_REPORT
(
"
explicit
/
dom
/
webidl
-
globalnames
"
KIND_HEAP
UNITS_BYTES
amount
"
Memory
used
by
the
hash
table
for
WebIDL
'
s
global
names
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
WebIDLGlobalNamesHashReporter
nsIMemoryReporter
)
void
WebIDLGlobalNameHash
:
:
Init
(
)
{
sWebIDLGlobalNames
=
new
nsTHashtable
<
WebIDLNameTableEntry
>
(
sCount
)
;
RegisterWebIDLGlobalNames
(
)
;
RegisterStrongMemoryReporter
(
new
WebIDLGlobalNamesHashReporter
(
)
)
;
}
void
WebIDLGlobalNameHash
:
:
Shutdown
(
)
{
delete
sWebIDLGlobalNames
;
}
void
WebIDLGlobalNameHash
:
:
Register
(
uint16_t
aNameOffset
uint16_t
aNameLength
CreateInterfaceObjectsMethod
aCreate
ConstructorEnabled
aEnabled
constructors
:
:
id
:
:
ID
aConstructorId
)
{
const
char
*
name
=
sNames
+
aNameOffset
;
WebIDLNameTableKey
key
(
name
aNameLength
)
;
WebIDLNameTableEntry
*
entry
=
sWebIDLGlobalNames
-
>
PutEntry
(
key
)
;
entry
-
>
mNameOffset
=
aNameOffset
;
entry
-
>
mNameLength
=
aNameLength
;
entry
-
>
mCreate
=
aCreate
;
entry
-
>
mEnabled
=
aEnabled
;
entry
-
>
mConstructorId
=
aConstructorId
;
}
void
WebIDLGlobalNameHash
:
:
Remove
(
const
char
*
aName
uint32_t
aLength
)
{
WebIDLNameTableKey
key
(
aName
aLength
)
;
sWebIDLGlobalNames
-
>
RemoveEntry
(
key
)
;
}
static
JSObject
*
FindNamedConstructorForXray
(
JSContext
*
aCx
JS
:
:
Handle
<
jsid
>
aId
const
WebIDLNameTableEntry
*
aEntry
)
{
JSObject
*
interfaceObject
=
GetPerInterfaceObjectHandle
(
aCx
aEntry
-
>
mConstructorId
aEntry
-
>
mCreate
false
)
;
if
(
!
interfaceObject
)
{
return
nullptr
;
}
for
(
unsigned
slot
=
DOM_INTERFACE_SLOTS_BASE
;
slot
<
JSCLASS_RESERVED_SLOTS
(
js
:
:
GetObjectClass
(
interfaceObject
)
)
;
+
+
slot
)
{
JSObject
*
constructor
=
&
js
:
:
GetReservedSlot
(
interfaceObject
slot
)
.
toObject
(
)
;
if
(
JS_GetFunctionId
(
JS_GetObjectFunction
(
constructor
)
)
=
=
JSID_TO_STRING
(
aId
)
)
{
return
constructor
;
}
}
return
interfaceObject
;
}
bool
WebIDLGlobalNameHash
:
:
DefineIfEnabled
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
aDesc
bool
*
aFound
)
{
MOZ_ASSERT
(
JSID_IS_STRING
(
aId
)
"
Check
for
string
id
before
calling
this
!
"
)
;
const
WebIDLNameTableEntry
*
entry
;
{
WebIDLNameTableKey
key
(
JSID_TO_FLAT_STRING
(
aId
)
)
;
JS
:
:
AutoSuppressGCAnalysis
suppress
;
entry
=
sWebIDLGlobalNames
-
>
GetEntry
(
key
)
;
}
if
(
!
entry
)
{
*
aFound
=
false
;
return
true
;
}
*
aFound
=
true
;
ConstructorEnabled
checkEnabledForScope
=
entry
-
>
mEnabled
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
js
:
:
CheckedUnwrap
(
aObj
false
)
)
;
if
(
!
global
)
{
return
Throw
(
aCx
NS_ERROR_DOM_SECURITY_ERR
)
;
}
{
#
ifdef
DEBUG
JS
:
:
Rooted
<
JSObject
*
>
temp
(
aCx
global
)
;
DebugOnly
<
nsGlobalWindowInner
*
>
win
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
UNWRAP_OBJECT
(
Window
&
temp
win
)
)
)
;
#
endif
}
if
(
checkEnabledForScope
&
&
!
checkEnabledForScope
(
aCx
global
)
)
{
return
true
;
}
if
(
xpc
:
:
WrapperFactory
:
:
IsXrayWrapper
(
aObj
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
constructor
(
aCx
)
;
{
JSAutoRealm
ar
(
aCx
global
)
;
constructor
=
FindNamedConstructorForXray
(
aCx
aId
entry
)
;
}
if
(
NS_WARN_IF
(
!
constructor
)
)
{
return
Throw
(
aCx
NS_ERROR_FAILURE
)
;
}
if
(
!
JS_WrapObject
(
aCx
&
constructor
)
)
{
return
Throw
(
aCx
NS_ERROR_FAILURE
)
;
}
FillPropertyDescriptor
(
aDesc
aObj
0
JS
:
:
ObjectValue
(
*
constructor
)
)
;
return
true
;
}
JS
:
:
Rooted
<
JSObject
*
>
interfaceObject
(
aCx
GetPerInterfaceObjectHandle
(
aCx
entry
-
>
mConstructorId
entry
-
>
mCreate
true
)
)
;
if
(
NS_WARN_IF
(
!
interfaceObject
)
)
{
return
Throw
(
aCx
NS_ERROR_FAILURE
)
;
}
FillPropertyDescriptor
(
aDesc
aObj
JS
:
:
UndefinedValue
(
)
false
)
;
return
true
;
}
bool
WebIDLGlobalNameHash
:
:
MayResolve
(
jsid
aId
)
{
WebIDLNameTableKey
key
(
JSID_TO_FLAT_STRING
(
aId
)
)
;
JS
:
:
AutoSuppressGCAnalysis
suppress
;
return
sWebIDLGlobalNames
-
>
Contains
(
key
)
;
}
bool
WebIDLGlobalNameHash
:
:
GetNames
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
NameType
aNameType
JS
:
:
AutoIdVector
&
aNames
)
{
ProtoAndIfaceCache
*
cache
=
GetProtoAndIfaceCache
(
aObj
)
;
for
(
auto
iter
=
sWebIDLGlobalNames
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
WebIDLNameTableEntry
*
entry
=
iter
.
Get
(
)
;
if
(
(
aNameType
=
=
AllNames
|
|
!
cache
-
>
HasEntryInSlot
(
entry
-
>
mConstructorId
)
)
&
&
(
!
entry
-
>
mEnabled
|
|
entry
-
>
mEnabled
(
aCx
aObj
)
)
)
{
JSString
*
str
=
JS_AtomizeStringN
(
aCx
sNames
+
entry
-
>
mNameOffset
entry
-
>
mNameLength
)
;
if
(
!
str
|
|
!
aNames
.
append
(
NON_INTEGER_ATOM_TO_JSID
(
str
)
)
)
{
return
false
;
}
}
}
return
true
;
}
}
}
