#
ifndef
mozilla_dom_BindingUtils_h__
#
define
mozilla_dom_BindingUtils_h__
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DeferredFinalize
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
CallbackObject
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSClass
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSProxyHandler
.
h
"
#
include
"
mozilla
/
dom
/
Exceptions
.
h
"
#
include
"
mozilla
/
dom
/
NonRefcountedDOMObject
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
PrototypeList
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
xpcObjectHelper
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
mozilla
/
dom
/
FakeString
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
class
nsGenericHTMLElement
;
class
nsIJSID
;
namespace
mozilla
{
enum
UseCounter
:
int16_t
;
namespace
dom
{
class
CustomElementReactionsStack
;
class
MessageManagerGlobal
;
template
<
typename
KeyType
typename
ValueType
>
class
Record
;
nsresult
UnwrapArgImpl
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
src
const
nsIID
&
iid
void
*
*
ppArg
)
;
nsresult
UnwrapWindowProxyImpl
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
src
nsPIDOMWindowOuter
*
*
ppArg
)
;
template
<
class
Interface
>
inline
nsresult
UnwrapArg
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
src
Interface
*
*
ppArg
)
{
return
UnwrapArgImpl
(
cx
src
NS_GET_TEMPLATE_IID
(
Interface
)
reinterpret_cast
<
void
*
*
>
(
ppArg
)
)
;
}
template
<
>
inline
nsresult
UnwrapArg
<
nsPIDOMWindowOuter
>
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
src
nsPIDOMWindowOuter
*
*
ppArg
)
{
return
UnwrapWindowProxyImpl
(
cx
src
ppArg
)
;
}
bool
ThrowInvalidThis
(
JSContext
*
aCx
const
JS
:
:
CallArgs
&
aArgs
bool
aSecurityError
const
char
*
aInterfaceName
)
;
bool
ThrowInvalidThis
(
JSContext
*
aCx
const
JS
:
:
CallArgs
&
aArgs
bool
aSecurityError
prototypes
:
:
ID
aProtoId
)
;
inline
bool
IsDOMClass
(
const
JSClass
*
clasp
)
{
return
clasp
-
>
flags
&
JSCLASS_IS_DOMJSCLASS
;
}
inline
bool
IsDOMClass
(
const
js
:
:
Class
*
clasp
)
{
return
IsDOMClass
(
Jsvalify
(
clasp
)
)
;
}
inline
bool
IsNonProxyDOMClass
(
const
js
:
:
Class
*
clasp
)
{
return
IsDOMClass
(
clasp
)
&
&
!
clasp
-
>
isProxy
(
)
;
}
inline
bool
IsNonProxyDOMClass
(
const
JSClass
*
clasp
)
{
return
IsNonProxyDOMClass
(
js
:
:
Valueify
(
clasp
)
)
;
}
inline
bool
IsDOMIfaceAndProtoClass
(
const
JSClass
*
clasp
)
{
return
clasp
-
>
flags
&
JSCLASS_IS_DOMIFACEANDPROTOJSCLASS
;
}
inline
bool
IsDOMIfaceAndProtoClass
(
const
js
:
:
Class
*
clasp
)
{
return
IsDOMIfaceAndProtoClass
(
Jsvalify
(
clasp
)
)
;
}
static_assert
(
DOM_OBJECT_SLOT
=
=
0
"
DOM_OBJECT_SLOT
doesn
'
t
match
the
proxy
private
slot
.
"
"
Expect
bad
things
"
)
;
template
<
class
T
>
inline
T
*
UnwrapDOMObject
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsDOMClass
(
js
:
:
GetObjectClass
(
obj
)
)
"
Don
'
t
pass
non
-
DOM
objects
to
this
function
"
)
;
JS
:
:
Value
val
=
js
:
:
GetReservedSlot
(
obj
DOM_OBJECT_SLOT
)
;
return
static_cast
<
T
*
>
(
val
.
toPrivate
(
)
)
;
}
template
<
class
T
>
inline
T
*
UnwrapPossiblyNotInitializedDOMObject
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
IsDOMClass
(
js
:
:
GetObjectClass
(
obj
)
)
"
Don
'
t
pass
non
-
DOM
objects
to
this
function
"
)
;
JS
:
:
Value
val
=
js
:
:
GetReservedSlot
(
obj
DOM_OBJECT_SLOT
)
;
if
(
val
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
T
*
>
(
val
.
toPrivate
(
)
)
;
}
inline
const
DOMJSClass
*
GetDOMClass
(
const
js
:
:
Class
*
clasp
)
{
return
IsDOMClass
(
clasp
)
?
DOMJSClass
:
:
FromJSClass
(
clasp
)
:
nullptr
;
}
inline
const
DOMJSClass
*
GetDOMClass
(
JSObject
*
obj
)
{
return
GetDOMClass
(
js
:
:
GetObjectClass
(
obj
)
)
;
}
inline
nsISupports
*
UnwrapDOMObjectToISupports
(
JSObject
*
aObject
)
{
const
DOMJSClass
*
clasp
=
GetDOMClass
(
aObject
)
;
if
(
!
clasp
|
|
!
clasp
-
>
mDOMObjectIsISupports
)
{
return
nullptr
;
}
return
UnwrapPossiblyNotInitializedDOMObject
<
nsISupports
>
(
aObject
)
;
}
inline
bool
IsDOMObject
(
JSObject
*
obj
)
{
return
IsDOMClass
(
js
:
:
GetObjectClass
(
obj
)
)
;
}
#
define
UNWRAP_OBJECT
(
Interface
obj
value
)
\
mozilla
:
:
dom
:
:
UnwrapObject
<
mozilla
:
:
dom
:
:
prototypes
:
:
id
:
:
Interface
\
mozilla
:
:
dom
:
:
Interface
#
#
_Binding
:
:
NativeType
>
(
obj
value
)
#
define
IS_INSTANCE_OF
(
Interface
obj
)
\
mozilla
:
:
dom
:
:
IsInstanceOf
<
mozilla
:
:
dom
:
:
prototypes
:
:
id
:
:
Interface
\
mozilla
:
:
dom
:
:
Interface
#
#
_Binding
:
:
NativeType
>
(
obj
)
#
define
UNWRAP_NON_WRAPPER_OBJECT
(
Interface
obj
value
)
\
mozilla
:
:
dom
:
:
UnwrapNonWrapperObject
<
mozilla
:
:
dom
:
:
prototypes
:
:
id
:
:
Interface
\
mozilla
:
:
dom
:
:
Interface
#
#
_Binding
:
:
NativeType
>
(
obj
value
)
namespace
binding_detail
{
template
<
class
T
bool
mayBeWrapper
typename
U
typename
V
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapObjectInternal
(
V
&
obj
U
&
value
prototypes
:
:
ID
protoID
uint32_t
protoDepth
)
{
const
DOMJSClass
*
domClass
=
GetDOMClass
(
obj
)
;
if
(
domClass
)
{
if
(
domClass
-
>
mInterfaceChain
[
protoDepth
]
=
=
protoID
)
{
value
=
UnwrapDOMObject
<
T
>
(
obj
)
;
return
NS_OK
;
}
}
if
(
!
mayBeWrapper
|
|
!
js
:
:
IsWrapper
(
obj
)
)
{
return
NS_ERROR_XPC_BAD_CONVERT_JS
;
}
JSObject
*
unwrappedObj
=
js
:
:
CheckedUnwrap
(
obj
false
)
;
if
(
!
unwrappedObj
)
{
return
NS_ERROR_XPC_SECURITY_MANAGER_VETO
;
}
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
unwrappedObj
)
)
;
T
*
tempValue
=
nullptr
;
nsresult
rv
=
UnwrapObjectInternal
<
T
false
>
(
unwrappedObj
tempValue
protoID
protoDepth
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
obj
=
unwrappedObj
;
value
=
tempValue
;
return
NS_OK
;
}
return
NS_ERROR_XPC_BAD_CONVERT_JS
;
}
struct
MutableObjectHandleWrapper
{
explicit
MutableObjectHandleWrapper
(
JS
:
:
MutableHandle
<
JSObject
*
>
aHandle
)
:
mHandle
(
aHandle
)
{
}
void
operator
=
(
JSObject
*
aObject
)
{
MOZ_ASSERT
(
aObject
)
;
mHandle
.
set
(
aObject
)
;
}
operator
JSObject
*
(
)
const
{
return
mHandle
;
}
private
:
JS
:
:
MutableHandle
<
JSObject
*
>
mHandle
;
}
;
struct
MutableValueHandleWrapper
{
explicit
MutableValueHandleWrapper
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aHandle
)
:
mHandle
(
aHandle
)
{
}
void
operator
=
(
JSObject
*
aObject
)
{
MOZ_ASSERT
(
aObject
)
;
mHandle
.
setObject
(
*
aObject
)
;
}
operator
JSObject
*
(
)
const
{
return
&
mHandle
.
toObject
(
)
;
}
private
:
JS
:
:
MutableHandle
<
JS
:
:
Value
>
mHandle
;
}
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
typename
U
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapObject
(
JS
:
:
MutableHandle
<
JSObject
*
>
obj
U
&
value
)
{
binding_detail
:
:
MutableObjectHandleWrapper
wrapper
(
obj
)
;
return
binding_detail
:
:
UnwrapObjectInternal
<
T
true
>
(
wrapper
value
PrototypeID
PrototypeTraits
<
PrototypeID
>
:
:
Depth
)
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
typename
U
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapObject
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
obj
U
&
value
)
{
MOZ_ASSERT
(
obj
.
isObject
(
)
)
;
binding_detail
:
:
MutableValueHandleWrapper
wrapper
(
obj
)
;
return
binding_detail
:
:
UnwrapObjectInternal
<
T
true
>
(
wrapper
value
PrototypeID
PrototypeTraits
<
PrototypeID
>
:
:
Depth
)
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
typename
U
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapObject
(
JSObject
*
obj
RefPtr
<
U
>
&
value
)
{
return
binding_detail
:
:
UnwrapObjectInternal
<
T
true
>
(
obj
value
PrototypeID
PrototypeTraits
<
PrototypeID
>
:
:
Depth
)
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
typename
U
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapObject
(
JSObject
*
obj
nsCOMPtr
<
U
>
&
value
)
{
return
binding_detail
:
:
UnwrapObjectInternal
<
T
true
>
(
obj
value
PrototypeID
PrototypeTraits
<
PrototypeID
>
:
:
Depth
)
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
typename
U
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapObject
(
JSObject
*
obj
OwningNonNull
<
U
>
&
value
)
{
return
binding_detail
:
:
UnwrapObjectInternal
<
T
true
>
(
obj
value
PrototypeID
PrototypeTraits
<
PrototypeID
>
:
:
Depth
)
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
typename
U
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapObject
(
JS
:
:
Handle
<
JS
:
:
Value
>
obj
U
&
value
)
{
MOZ_ASSERT
(
obj
.
isObject
(
)
)
;
return
UnwrapObject
<
PrototypeID
T
>
(
&
obj
.
toObject
(
)
value
)
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
>
MOZ_ALWAYS_INLINE
bool
IsInstanceOf
(
JSObject
*
obj
)
{
void
*
ignored
;
nsresult
unwrapped
=
binding_detail
:
:
UnwrapObjectInternal
<
T
true
>
(
obj
ignored
PrototypeID
PrototypeTraits
<
PrototypeID
>
:
:
Depth
)
;
return
NS_SUCCEEDED
(
unwrapped
)
;
}
template
<
prototypes
:
:
ID
PrototypeID
class
T
typename
U
>
MOZ_ALWAYS_INLINE
nsresult
UnwrapNonWrapperObject
(
JSObject
*
obj
U
&
value
)
{
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
obj
)
)
;
return
binding_detail
:
:
UnwrapObjectInternal
<
T
false
>
(
obj
value
PrototypeID
PrototypeTraits
<
PrototypeID
>
:
:
Depth
)
;
}
MOZ_ALWAYS_INLINE
bool
IsConvertibleToDictionary
(
JS
:
:
Handle
<
JS
:
:
Value
>
val
)
{
return
val
.
isNullOrUndefined
(
)
|
|
val
.
isObject
(
)
;
}
static_assert
(
(
size_t
)
constructors
:
:
id
:
:
_ID_Start
=
=
(
size_t
)
prototypes
:
:
id
:
:
_ID_Count
&
&
(
size_t
)
namedpropertiesobjects
:
:
id
:
:
_ID_Start
=
=
(
size_t
)
constructors
:
:
id
:
:
_ID_Count
"
Overlapping
or
discontiguous
indexes
.
"
)
;
const
size_t
kProtoAndIfaceCacheCount
=
namedpropertiesobjects
:
:
id
:
:
_ID_Count
;
class
ProtoAndIfaceCache
{
class
ArrayCache
:
public
Array
<
JS
:
:
Heap
<
JSObject
*
>
kProtoAndIfaceCacheCount
>
{
public
:
bool
HasEntryInSlot
(
size_t
i
)
{
return
(
*
this
)
[
i
]
;
}
JS
:
:
Heap
<
JSObject
*
>
&
EntrySlotOrCreate
(
size_t
i
)
{
return
(
*
this
)
[
i
]
;
}
JS
:
:
Heap
<
JSObject
*
>
&
EntrySlotMustExist
(
size_t
i
)
{
return
(
*
this
)
[
i
]
;
}
void
Trace
(
JSTracer
*
aTracer
)
{
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
*
this
)
;
+
+
i
)
{
JS
:
:
TraceEdge
(
aTracer
&
(
*
this
)
[
i
]
"
protoAndIfaceCache
[
i
]
"
)
;
}
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
return
aMallocSizeOf
(
this
)
;
}
}
;
class
PageTableCache
{
public
:
PageTableCache
(
)
{
memset
(
mPages
.
begin
(
)
0
sizeof
(
mPages
)
)
;
}
~
PageTableCache
(
)
{
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mPages
)
;
+
+
i
)
{
delete
mPages
[
i
]
;
}
}
bool
HasEntryInSlot
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
kProtoAndIfaceCacheCount
)
;
size_t
pageIndex
=
i
/
kPageSize
;
size_t
leafIndex
=
i
%
kPageSize
;
Page
*
p
=
mPages
[
pageIndex
]
;
if
(
!
p
)
{
return
false
;
}
return
(
*
p
)
[
leafIndex
]
;
}
JS
:
:
Heap
<
JSObject
*
>
&
EntrySlotOrCreate
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
kProtoAndIfaceCacheCount
)
;
size_t
pageIndex
=
i
/
kPageSize
;
size_t
leafIndex
=
i
%
kPageSize
;
Page
*
p
=
mPages
[
pageIndex
]
;
if
(
!
p
)
{
p
=
new
Page
;
mPages
[
pageIndex
]
=
p
;
}
return
(
*
p
)
[
leafIndex
]
;
}
JS
:
:
Heap
<
JSObject
*
>
&
EntrySlotMustExist
(
size_t
i
)
{
MOZ_ASSERT
(
i
<
kProtoAndIfaceCacheCount
)
;
size_t
pageIndex
=
i
/
kPageSize
;
size_t
leafIndex
=
i
%
kPageSize
;
Page
*
p
=
mPages
[
pageIndex
]
;
MOZ_ASSERT
(
p
)
;
return
(
*
p
)
[
leafIndex
]
;
}
void
Trace
(
JSTracer
*
trc
)
{
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mPages
)
;
+
+
i
)
{
Page
*
p
=
mPages
[
i
]
;
if
(
p
)
{
for
(
size_t
j
=
0
;
j
<
ArrayLength
(
*
p
)
;
+
+
j
)
{
JS
:
:
TraceEdge
(
trc
&
(
*
p
)
[
j
]
"
protoAndIfaceCache
[
i
]
"
)
;
}
}
}
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mPages
)
;
+
+
i
)
{
n
+
=
aMallocSizeOf
(
mPages
[
i
]
)
;
}
return
n
;
}
private
:
static
const
size_t
kPageSize
=
16
;
typedef
Array
<
JS
:
:
Heap
<
JSObject
*
>
kPageSize
>
Page
;
static
const
size_t
kNPages
=
kProtoAndIfaceCacheCount
/
kPageSize
+
size_t
(
bool
(
kProtoAndIfaceCacheCount
%
kPageSize
)
)
;
Array
<
Page
*
kNPages
>
mPages
;
}
;
public
:
enum
Kind
{
WindowLike
NonWindowLike
}
;
explicit
ProtoAndIfaceCache
(
Kind
aKind
)
:
mKind
(
aKind
)
{
MOZ_COUNT_CTOR
(
ProtoAndIfaceCache
)
;
if
(
aKind
=
=
WindowLike
)
{
mArrayCache
=
new
ArrayCache
(
)
;
}
else
{
mPageTableCache
=
new
PageTableCache
(
)
;
}
}
~
ProtoAndIfaceCache
(
)
{
if
(
mKind
=
=
WindowLike
)
{
delete
mArrayCache
;
}
else
{
delete
mPageTableCache
;
}
MOZ_COUNT_DTOR
(
ProtoAndIfaceCache
)
;
}
#
define
FORWARD_OPERATION
(
opName
args
)
\
do
{
\
if
(
mKind
=
=
WindowLike
)
{
\
return
mArrayCache
-
>
opName
args
;
\
}
else
{
\
return
mPageTableCache
-
>
opName
args
;
\
}
\
}
while
(
0
)
bool
HasEntryInSlot
(
size_t
i
)
{
FORWARD_OPERATION
(
HasEntryInSlot
(
i
)
)
;
}
JS
:
:
Heap
<
JSObject
*
>
&
EntrySlotOrCreate
(
size_t
i
)
{
FORWARD_OPERATION
(
EntrySlotOrCreate
(
i
)
)
;
}
JS
:
:
Heap
<
JSObject
*
>
&
EntrySlotMustExist
(
size_t
i
)
{
FORWARD_OPERATION
(
EntrySlotMustExist
(
i
)
)
;
}
void
Trace
(
JSTracer
*
aTracer
)
{
FORWARD_OPERATION
(
Trace
(
aTracer
)
)
;
}
size_t
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
(
mKind
=
=
WindowLike
?
mArrayCache
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
:
mPageTableCache
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
)
;
return
n
;
}
#
undef
FORWARD_OPERATION
private
:
union
{
ArrayCache
*
mArrayCache
;
PageTableCache
*
mPageTableCache
;
}
;
Kind
mKind
;
}
;
inline
void
AllocateProtoAndIfaceCache
(
JSObject
*
obj
ProtoAndIfaceCache
:
:
Kind
aKind
)
{
MOZ_ASSERT
(
js
:
:
GetObjectClass
(
obj
)
-
>
flags
&
JSCLASS_DOM_GLOBAL
)
;
MOZ_ASSERT
(
js
:
:
GetReservedSlot
(
obj
DOM_PROTOTYPE_SLOT
)
.
isUndefined
(
)
)
;
ProtoAndIfaceCache
*
protoAndIfaceCache
=
new
ProtoAndIfaceCache
(
aKind
)
;
js
:
:
SetReservedSlot
(
obj
DOM_PROTOTYPE_SLOT
JS
:
:
PrivateValue
(
protoAndIfaceCache
)
)
;
}
#
ifdef
DEBUG
struct
VerifyTraceProtoAndIfaceCacheCalledTracer
:
public
JS
:
:
CallbackTracer
{
bool
ok
;
explicit
VerifyTraceProtoAndIfaceCacheCalledTracer
(
JSContext
*
cx
)
:
JS
:
:
CallbackTracer
(
cx
)
ok
(
false
)
{
}
void
onChild
(
const
JS
:
:
GCCellPtr
&
)
override
{
}
TracerKind
getTracerKind
(
)
const
override
{
return
TracerKind
:
:
VerifyTraceProtoAndIface
;
}
}
;
#
endif
inline
void
TraceProtoAndIfaceCache
(
JSTracer
*
trc
JSObject
*
obj
)
{
MOZ_ASSERT
(
js
:
:
GetObjectClass
(
obj
)
-
>
flags
&
JSCLASS_DOM_GLOBAL
)
;
#
ifdef
DEBUG
if
(
trc
-
>
isCallbackTracer
(
)
&
&
(
trc
-
>
asCallbackTracer
(
)
-
>
getTracerKind
(
)
=
=
JS
:
:
CallbackTracer
:
:
TracerKind
:
:
VerifyTraceProtoAndIface
)
)
{
static_cast
<
VerifyTraceProtoAndIfaceCacheCalledTracer
*
>
(
trc
)
-
>
ok
=
true
;
return
;
}
#
endif
if
(
!
DOMGlobalHasProtoAndIFaceCache
(
obj
)
)
return
;
ProtoAndIfaceCache
*
protoAndIfaceCache
=
GetProtoAndIfaceCache
(
obj
)
;
protoAndIfaceCache
-
>
Trace
(
trc
)
;
}
inline
void
DestroyProtoAndIfaceCache
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
js
:
:
GetObjectClass
(
obj
)
-
>
flags
&
JSCLASS_DOM_GLOBAL
)
;
if
(
!
DOMGlobalHasProtoAndIFaceCache
(
obj
)
)
{
return
;
}
ProtoAndIfaceCache
*
protoAndIfaceCache
=
GetProtoAndIfaceCache
(
obj
)
;
delete
protoAndIfaceCache
;
}
bool
DefineConstants
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
ConstantSpec
*
cs
)
;
struct
JSNativeHolder
{
JSNative
mNative
;
const
NativePropertyHooks
*
mPropertyHooks
;
}
;
struct
NamedConstructor
{
const
char
*
mName
;
const
JSNativeHolder
mHolder
;
unsigned
mNargs
;
}
;
void
CreateInterfaceObjects
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
JS
:
:
Handle
<
JSObject
*
>
protoProto
const
js
:
:
Class
*
protoClass
JS
:
:
Heap
<
JSObject
*
>
*
protoCache
const
char
*
toStringTag
JS
:
:
Handle
<
JSObject
*
>
interfaceProto
const
js
:
:
Class
*
constructorClass
unsigned
ctorNargs
const
NamedConstructor
*
namedConstructors
JS
:
:
Heap
<
JSObject
*
>
*
constructorCache
const
NativeProperties
*
regularProperties
const
NativeProperties
*
chromeOnlyProperties
const
char
*
name
bool
defineOnGlobal
const
char
*
const
*
unscopableNames
bool
isGlobal
)
;
bool
DefineProperties
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
NativeProperties
*
properties
const
NativeProperties
*
chromeOnlyProperties
)
;
bool
DefineUnforgeableMethods
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
Prefable
<
const
JSFunctionSpec
>
*
props
)
;
bool
DefineUnforgeableAttributes
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
const
Prefable
<
const
JSPropertySpec
>
*
props
)
;
#
define
HAS_MEMBER_TYPEDEFS
\
private
:
\
typedef
char
yes
[
1
]
;
\
typedef
char
no
[
2
]
#
ifdef
_MSC_VER
#
define
HAS_MEMBER_CHECK
(
_name
)
\
template
<
typename
V
>
static
yes
&
Check
#
#
_name
(
char
(
*
)
[
(
&
V
:
:
_name
=
=
0
)
+
1
]
)
#
else
#
define
HAS_MEMBER_CHECK
(
_name
)
\
template
<
typename
V
>
static
yes
&
Check
#
#
_name
(
char
(
*
)
[
sizeof
(
&
V
:
:
_name
)
+
1
]
)
#
endif
#
define
HAS_MEMBER
(
_memberName
_valueName
)
\
private
:
\
HAS_MEMBER_CHECK
(
_memberName
)
;
\
template
<
typename
V
>
static
no
&
Check
#
#
_memberName
(
.
.
.
)
;
\
\
public
:
\
static
bool
const
_valueName
=
\
sizeof
(
Check
#
#
_memberName
<
T
>
(
nullptr
)
)
=
=
sizeof
(
yes
)
template
<
class
T
>
struct
NativeHasMember
{
HAS_MEMBER_TYPEDEFS
;
HAS_MEMBER
(
GetParentObject
GetParentObject
)
;
HAS_MEMBER
(
WrapObject
WrapObject
)
;
}
;
template
<
class
T
>
struct
IsSmartPtr
{
HAS_MEMBER_TYPEDEFS
;
HAS_MEMBER
(
get
value
)
;
}
;
template
<
class
T
>
struct
IsRefcounted
{
HAS_MEMBER_TYPEDEFS
;
HAS_MEMBER
(
AddRef
HasAddref
)
;
HAS_MEMBER
(
Release
HasRelease
)
;
public
:
static
bool
const
value
=
HasAddref
&
&
HasRelease
;
private
:
static_assert
(
!
IsBaseOf
<
nsISupports
T
>
:
:
value
|
|
IsRefcounted
:
:
value
"
Classes
derived
from
nsISupports
are
refcounted
!
"
)
;
}
;
#
undef
HAS_MEMBER
#
undef
HAS_MEMBER_CHECK
#
undef
HAS_MEMBER_TYPEDEFS
#
ifdef
DEBUG
template
<
class
T
bool
isISupports
=
IsBaseOf
<
nsISupports
T
>
:
:
value
>
struct
CheckWrapperCacheCast
{
static
bool
Check
(
)
{
return
reinterpret_cast
<
uintptr_t
>
(
static_cast
<
nsWrapperCache
*
>
(
reinterpret_cast
<
T
*
>
(
1
)
)
)
=
=
1
;
}
}
;
template
<
class
T
>
struct
CheckWrapperCacheCast
<
T
true
>
{
static
bool
Check
(
)
{
return
true
;
}
}
;
#
endif
inline
bool
TryToOuterize
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
if
(
js
:
:
IsWindow
(
&
rval
.
toObject
(
)
)
)
{
JSObject
*
obj
=
js
:
:
ToWindowProxyIfWindow
(
&
rval
.
toObject
(
)
)
;
MOZ_ASSERT
(
obj
)
;
rval
.
set
(
JS
:
:
ObjectValue
(
*
obj
)
)
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
MaybeWrapStringValue
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
rval
.
isString
(
)
)
;
JSString
*
str
=
rval
.
toString
(
)
;
if
(
JS
:
:
GetStringZone
(
str
)
!
=
js
:
:
GetContextZone
(
cx
)
)
{
return
JS_WrapValue
(
cx
rval
)
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
MaybeWrapObjectValue
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
rval
.
isObject
(
)
)
;
JSObject
*
obj
=
&
rval
.
toObject
(
)
;
if
(
js
:
:
GetObjectCompartment
(
obj
)
!
=
js
:
:
GetContextCompartment
(
cx
)
)
{
return
JS_WrapValue
(
cx
rval
)
;
}
if
(
IsDOMObject
(
obj
)
)
{
return
TryToOuterize
(
rval
)
;
}
return
true
;
}
MOZ_ALWAYS_INLINE
bool
MaybeWrapObjectOrNullValue
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
rval
.
isObjectOrNull
(
)
)
;
if
(
rval
.
isNull
(
)
)
{
return
true
;
}
return
MaybeWrapObjectValue
(
cx
rval
)
;
}
MOZ_ALWAYS_INLINE
bool
MaybeWrapNonDOMObjectValue
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
rval
.
isObject
(
)
)
;
MOZ_ASSERT
(
!
GetDOMClass
(
&
rval
.
toObject
(
)
)
)
;
MOZ_ASSERT
(
!
(
js
:
:
GetObjectClass
(
&
rval
.
toObject
(
)
)
-
>
flags
&
JSCLASS_PRIVATE_IS_NSISUPPORTS
)
)
;
JSObject
*
obj
=
&
rval
.
toObject
(
)
;
if
(
js
:
:
GetObjectCompartment
(
obj
)
=
=
js
:
:
GetContextCompartment
(
cx
)
)
{
return
true
;
}
return
JS_WrapValue
(
cx
rval
)
;
}
MOZ_ALWAYS_INLINE
bool
MaybeWrapNonDOMObjectOrNullValue
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
rval
.
isObjectOrNull
(
)
)
;
if
(
rval
.
isNull
(
)
)
{
return
true
;
}
return
MaybeWrapNonDOMObjectValue
(
cx
rval
)
;
}
MOZ_ALWAYS_INLINE
bool
MaybeWrapValue
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
if
(
rval
.
isGCThing
(
)
)
{
if
(
rval
.
isString
(
)
)
{
return
MaybeWrapStringValue
(
cx
rval
)
;
}
if
(
rval
.
isObject
(
)
)
{
return
MaybeWrapObjectValue
(
cx
rval
)
;
}
#
ifdef
ENABLE_BIGINT
if
(
rval
.
isBigInt
(
)
)
{
return
JS_WrapValue
(
cx
rval
)
;
}
#
endif
MOZ_ASSERT
(
rval
.
isSymbol
(
)
)
;
JS_MarkCrossZoneId
(
cx
SYMBOL_TO_JSID
(
rval
.
toSymbol
(
)
)
)
;
}
return
true
;
}
namespace
binding_detail
{
enum
GetOrCreateReflectorWrapBehavior
{
eWrapIntoContextCompartment
eDontWrapIntoContextCompartment
}
;
template
<
class
T
>
struct
TypeNeedsOuterization
{
static
const
bool
value
=
IsBaseOf
<
nsGlobalWindowInner
T
>
:
:
value
|
|
IsBaseOf
<
nsGlobalWindowOuter
T
>
:
:
value
|
|
IsSame
<
EventTarget
T
>
:
:
value
;
}
;
#
ifdef
DEBUG
template
<
typename
T
bool
isISupports
=
IsBaseOf
<
nsISupports
T
>
:
:
value
>
struct
CheckWrapperCacheTracing
{
static
inline
void
Check
(
T
*
aObject
)
{
}
}
;
template
<
typename
T
>
struct
CheckWrapperCacheTracing
<
T
true
>
{
static
void
Check
(
T
*
aObject
)
{
JS
:
:
AutoSuppressGCAnalysis
nogc
;
nsWrapperCache
*
wrapperCacheFromQI
=
nullptr
;
aObject
-
>
QueryInterface
(
NS_GET_IID
(
nsWrapperCache
)
reinterpret_cast
<
void
*
*
>
(
&
wrapperCacheFromQI
)
)
;
MOZ_ASSERT
(
wrapperCacheFromQI
"
Missing
nsWrapperCache
from
QueryInterface
implementation
?
"
)
;
if
(
!
wrapperCacheFromQI
-
>
GetWrapperPreserveColor
(
)
)
{
return
;
}
nsISupports
*
ccISupports
=
nullptr
;
aObject
-
>
QueryInterface
(
NS_GET_IID
(
nsCycleCollectionISupports
)
reinterpret_cast
<
void
*
*
>
(
&
ccISupports
)
)
;
MOZ_ASSERT
(
ccISupports
"
nsWrapperCache
object
which
isn
'
t
cycle
collectable
?
"
)
;
nsXPCOMCycleCollectionParticipant
*
participant
=
nullptr
;
CallQueryInterface
(
ccISupports
&
participant
)
;
MOZ_ASSERT
(
participant
"
Can
'
t
QI
to
CycleCollectionParticipant
?
"
)
;
bool
wasPreservingWrapper
=
wrapperCacheFromQI
-
>
PreservingWrapper
(
)
;
wrapperCacheFromQI
-
>
SetPreservingWrapper
(
true
)
;
wrapperCacheFromQI
-
>
CheckCCWrapperTraversal
(
ccISupports
participant
)
;
wrapperCacheFromQI
-
>
SetPreservingWrapper
(
wasPreservingWrapper
)
;
}
}
;
void
AssertReflectorHasGivenProto
(
JSContext
*
aCx
JSObject
*
aReflector
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
;
#
endif
template
<
class
T
GetOrCreateReflectorWrapBehavior
wrapBehavior
>
MOZ_ALWAYS_INLINE
bool
DoGetOrCreateDOMReflector
(
JSContext
*
cx
T
*
value
JS
:
:
Handle
<
JSObject
*
>
givenProto
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
value
)
;
MOZ_ASSERT_IF
(
givenProto
js
:
:
IsObjectInContextCompartment
(
givenProto
cx
)
)
;
JSObject
*
obj
=
value
-
>
GetWrapper
(
)
;
if
(
obj
)
{
#
ifdef
DEBUG
AssertReflectorHasGivenProto
(
cx
obj
givenProto
)
;
obj
=
value
-
>
GetWrapper
(
)
;
#
endif
}
else
{
obj
=
value
-
>
WrapObject
(
cx
givenProto
)
;
if
(
!
obj
)
{
return
false
;
}
#
ifdef
DEBUG
if
(
IsBaseOf
<
nsWrapperCache
T
>
:
:
value
)
{
CheckWrapperCacheTracing
<
T
>
:
:
Check
(
value
)
;
}
#
endif
}
#
ifdef
DEBUG
const
DOMJSClass
*
clasp
=
GetDOMClass
(
obj
)
;
if
(
clasp
)
{
MOZ_ASSERT
(
clasp
"
What
happened
here
?
"
)
;
MOZ_ASSERT_IF
(
clasp
-
>
mDOMObjectIsISupports
(
IsBaseOf
<
nsISupports
T
>
:
:
value
)
)
;
MOZ_ASSERT
(
CheckWrapperCacheCast
<
T
>
:
:
Check
(
)
)
;
}
#
endif
rval
.
set
(
JS
:
:
ObjectValue
(
*
obj
)
)
;
if
(
js
:
:
GetObjectCompartment
(
obj
)
=
=
js
:
:
GetContextCompartment
(
cx
)
)
{
return
TypeNeedsOuterization
<
T
>
:
:
value
?
TryToOuterize
(
rval
)
:
true
;
}
if
(
wrapBehavior
=
=
eDontWrapIntoContextCompartment
)
{
if
(
TypeNeedsOuterization
<
T
>
:
:
value
)
{
JSAutoRealm
ar
(
cx
obj
)
;
return
TryToOuterize
(
rval
)
;
}
return
true
;
}
return
JS_WrapValue
(
cx
rval
)
;
}
}
template
<
class
T
>
MOZ_ALWAYS_INLINE
bool
GetOrCreateDOMReflector
(
JSContext
*
cx
T
*
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
JS
:
:
Handle
<
JSObject
*
>
givenProto
=
nullptr
)
{
using
namespace
binding_detail
;
return
DoGetOrCreateDOMReflector
<
T
eWrapIntoContextCompartment
>
(
cx
value
givenProto
rval
)
;
}
template
<
class
T
>
MOZ_ALWAYS_INLINE
bool
GetOrCreateDOMReflectorNoWrap
(
JSContext
*
cx
T
*
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
using
namespace
binding_detail
;
return
DoGetOrCreateDOMReflector
<
T
eDontWrapIntoContextCompartment
>
(
cx
value
nullptr
rval
)
;
}
template
<
class
T
>
inline
bool
WrapNewBindingNonWrapperCachedObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scopeArg
T
*
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
JS
:
:
Handle
<
JSObject
*
>
givenProto
=
nullptr
)
{
static_assert
(
IsRefcounted
<
T
>
:
:
value
"
Don
'
t
pass
owned
classes
in
here
.
"
)
;
MOZ_ASSERT
(
value
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
)
;
{
Maybe
<
JSAutoRealm
>
ar
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
cx
scopeArg
)
;
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
givenProto
)
;
if
(
js
:
:
IsWrapper
(
scope
)
)
{
scope
=
js
:
:
CheckedUnwrap
(
scope
false
)
;
if
(
!
scope
)
return
false
;
ar
.
emplace
(
cx
scope
)
;
if
(
!
JS_WrapObject
(
cx
&
proto
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
js
:
:
IsObjectInContextCompartment
(
scope
cx
)
)
;
if
(
!
value
-
>
WrapObject
(
cx
proto
&
obj
)
)
{
return
false
;
}
}
rval
.
set
(
JS
:
:
ObjectValue
(
*
obj
)
)
;
return
MaybeWrapObjectValue
(
cx
rval
)
;
}
template
<
class
T
>
inline
bool
WrapNewBindingNonWrapperCachedObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scopeArg
nsAutoPtr
<
T
>
&
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
JS
:
:
Handle
<
JSObject
*
>
givenProto
=
nullptr
)
{
static_assert
(
!
IsRefcounted
<
T
>
:
:
value
"
Only
pass
owned
classes
in
here
.
"
)
;
if
(
!
value
)
{
MOZ_CRASH
(
"
Don
'
t
try
to
wrap
null
objects
"
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
)
;
{
Maybe
<
JSAutoRealm
>
ar
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
cx
scopeArg
)
;
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
givenProto
)
;
if
(
js
:
:
IsWrapper
(
scope
)
)
{
scope
=
js
:
:
CheckedUnwrap
(
scope
false
)
;
if
(
!
scope
)
return
false
;
ar
.
emplace
(
cx
scope
)
;
if
(
!
JS_WrapObject
(
cx
&
proto
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
js
:
:
IsObjectInContextCompartment
(
scope
cx
)
)
;
if
(
!
value
-
>
WrapObject
(
cx
proto
&
obj
)
)
{
return
false
;
}
value
.
forget
(
)
;
}
rval
.
set
(
JS
:
:
ObjectValue
(
*
obj
)
)
;
return
MaybeWrapObjectValue
(
cx
rval
)
;
}
template
<
template
<
typename
>
class
SmartPtr
typename
T
typename
U
=
typename
EnableIf
<
IsRefcounted
<
T
>
:
:
value
T
>
:
:
Type
typename
V
=
typename
EnableIf
<
IsSmartPtr
<
SmartPtr
<
T
>
>
:
:
value
T
>
:
:
Type
>
inline
bool
WrapNewBindingNonWrapperCachedObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scope
const
SmartPtr
<
T
>
&
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
JS
:
:
Handle
<
JSObject
*
>
givenProto
=
nullptr
)
{
return
WrapNewBindingNonWrapperCachedObject
(
cx
scope
value
.
get
(
)
rval
givenProto
)
;
}
template
<
typename
T
typename
U
=
typename
EnableIf
<
!
IsSmartPtr
<
T
>
:
:
value
T
>
:
:
Type
>
inline
bool
WrapNewBindingNonWrapperCachedObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scope
T
&
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
JS
:
:
Handle
<
JSObject
*
>
givenProto
=
nullptr
)
{
return
WrapNewBindingNonWrapperCachedObject
(
cx
scope
&
value
rval
givenProto
)
;
}
template
<
bool
Fatal
>
inline
bool
EnumValueNotFound
(
JSContext
*
cx
JS
:
:
HandleString
str
const
char
*
type
const
char
*
sourceDescription
)
;
template
<
>
inline
bool
EnumValueNotFound
<
false
>
(
JSContext
*
cx
JS
:
:
HandleString
str
const
char
*
type
const
char
*
sourceDescription
)
{
return
true
;
}
template
<
>
inline
bool
EnumValueNotFound
<
true
>
(
JSContext
*
cx
JS
:
:
HandleString
str
const
char
*
type
const
char
*
sourceDescription
)
{
JSAutoByteString
deflated
;
if
(
!
deflated
.
encodeUtf8
(
cx
str
)
)
{
return
false
;
}
return
ThrowErrorMessage
(
cx
MSG_INVALID_ENUM_VALUE
sourceDescription
deflated
.
ptr
(
)
type
)
;
}
template
<
typename
CharT
>
inline
int
FindEnumStringIndexImpl
(
const
CharT
*
chars
size_t
length
const
EnumEntry
*
values
)
{
int
i
=
0
;
for
(
const
EnumEntry
*
value
=
values
;
value
-
>
value
;
+
+
value
+
+
i
)
{
if
(
length
!
=
value
-
>
length
)
{
continue
;
}
bool
equal
=
true
;
const
char
*
val
=
value
-
>
value
;
for
(
size_t
j
=
0
;
j
!
=
length
;
+
+
j
)
{
if
(
unsigned
(
val
[
j
]
)
!
=
unsigned
(
chars
[
j
]
)
)
{
equal
=
false
;
break
;
}
}
if
(
equal
)
{
return
i
;
}
}
return
-
1
;
}
template
<
bool
InvalidValueFatal
>
inline
bool
FindEnumStringIndex
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v
const
EnumEntry
*
values
const
char
*
type
const
char
*
sourceDescription
int
*
index
)
{
JS
:
:
RootedString
str
(
cx
JS
:
:
ToString
(
cx
v
)
)
;
if
(
!
str
)
{
return
false
;
}
{
size_t
length
;
JS
:
:
AutoCheckCannotGC
nogc
;
if
(
js
:
:
StringHasLatin1Chars
(
str
)
)
{
const
JS
:
:
Latin1Char
*
chars
=
JS_GetLatin1StringCharsAndLength
(
cx
nogc
str
&
length
)
;
if
(
!
chars
)
{
return
false
;
}
*
index
=
FindEnumStringIndexImpl
(
chars
length
values
)
;
}
else
{
const
char16_t
*
chars
=
JS_GetTwoByteStringCharsAndLength
(
cx
nogc
str
&
length
)
;
if
(
!
chars
)
{
return
false
;
}
*
index
=
FindEnumStringIndexImpl
(
chars
length
values
)
;
}
if
(
*
index
>
=
0
)
{
return
true
;
}
}
return
EnumValueNotFound
<
InvalidValueFatal
>
(
cx
str
type
sourceDescription
)
;
}
inline
nsWrapperCache
*
GetWrapperCache
(
const
ParentObject
&
aParentObject
)
{
return
aParentObject
.
mWrapperCache
;
}
template
<
class
T
>
inline
T
*
GetParentPointer
(
T
*
aObject
)
{
return
aObject
;
}
inline
nsISupports
*
GetParentPointer
(
const
ParentObject
&
aObject
)
{
return
aObject
.
mObject
;
}
template
<
typename
T
>
inline
bool
GetUseXBLScope
(
T
*
aParentObject
)
{
return
false
;
}
inline
bool
GetUseXBLScope
(
const
ParentObject
&
aParentObject
)
{
return
aParentObject
.
mUseXBLScope
;
}
template
<
class
T
>
inline
void
ClearWrapper
(
T
*
p
nsWrapperCache
*
cache
JSObject
*
obj
)
{
JS
:
:
AutoAssertGCCallback
inCallback
;
cache
-
>
ClearWrapper
(
obj
)
;
}
template
<
class
T
>
inline
void
ClearWrapper
(
T
*
p
void
*
JSObject
*
obj
)
{
JS
:
:
AutoAssertGCCallback
inCallback
;
nsWrapperCache
*
cache
;
CallQueryInterface
(
p
&
cache
)
;
ClearWrapper
(
p
cache
obj
)
;
}
template
<
class
T
>
inline
void
UpdateWrapper
(
T
*
p
nsWrapperCache
*
cache
JSObject
*
obj
const
JSObject
*
old
)
{
JS
:
:
AutoAssertGCCallback
inCallback
;
cache
-
>
UpdateWrapper
(
obj
old
)
;
}
template
<
class
T
>
inline
void
UpdateWrapper
(
T
*
p
void
*
JSObject
*
obj
const
JSObject
*
old
)
{
JS
:
:
AutoAssertGCCallback
inCallback
;
nsWrapperCache
*
cache
;
CallQueryInterface
(
p
&
cache
)
;
UpdateWrapper
(
p
cache
obj
old
)
;
}
bool
TryPreserveWrapper
(
JSObject
*
obj
)
;
bool
InstanceClassHasProtoAtDepth
(
const
js
:
:
Class
*
clasp
uint32_t
protoID
uint32_t
depth
)
;
bool
XPCOMObjectToJsval
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
scope
xpcObjectHelper
&
helper
const
nsIID
*
iid
bool
allowNativeWrapper
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
;
bool
VariantToJsval
(
JSContext
*
aCx
nsIVariant
*
aVariant
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
;
template
<
class
T
>
inline
bool
WrapObject
(
JSContext
*
cx
T
*
p
nsWrapperCache
*
cache
const
nsIID
*
iid
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
if
(
xpc_FastGetCachedWrapper
(
cx
cache
rval
)
)
return
true
;
xpcObjectHelper
helper
(
ToSupports
(
p
)
cache
)
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
return
XPCOMObjectToJsval
(
cx
scope
helper
iid
true
rval
)
;
}
template
<
>
inline
bool
WrapObject
<
nsIVariant
>
(
JSContext
*
cx
nsIVariant
*
p
nsWrapperCache
*
cache
const
nsIID
*
iid
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
MOZ_ASSERT
(
iid
)
;
MOZ_ASSERT
(
iid
-
>
Equals
(
NS_GET_IID
(
nsIVariant
)
)
)
;
return
VariantToJsval
(
cx
p
rval
)
;
}
template
<
class
T
>
inline
bool
WrapObject
(
JSContext
*
cx
T
*
p
const
nsIID
*
iid
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
WrapObject
(
cx
p
GetWrapperCache
(
p
)
iid
rval
)
;
}
template
<
class
T
>
inline
bool
WrapObject
(
JSContext
*
cx
T
*
p
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
WrapObject
(
cx
p
nullptr
rval
)
;
}
template
<
class
T
>
inline
bool
WrapObject
(
JSContext
*
cx
const
nsCOMPtr
<
T
>
&
p
const
nsIID
*
iid
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
WrapObject
(
cx
p
.
get
(
)
iid
rval
)
;
}
template
<
class
T
>
inline
bool
WrapObject
(
JSContext
*
cx
const
nsCOMPtr
<
T
>
&
p
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
WrapObject
(
cx
p
nullptr
rval
)
;
}
template
<
class
T
>
inline
bool
WrapObject
(
JSContext
*
cx
const
RefPtr
<
T
>
&
p
const
nsIID
*
iid
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
WrapObject
(
cx
p
.
get
(
)
iid
rval
)
;
}
template
<
class
T
>
inline
bool
WrapObject
(
JSContext
*
cx
const
RefPtr
<
T
>
&
p
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
WrapObject
(
cx
p
nullptr
rval
)
;
}
template
<
>
inline
bool
WrapObject
<
JSObject
>
(
JSContext
*
cx
JSObject
*
p
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
rval
.
set
(
JS
:
:
ObjectOrNullValue
(
p
)
)
;
return
true
;
}
inline
bool
WrapObject
(
JSContext
*
cx
JSObject
&
p
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
rval
.
set
(
JS
:
:
ObjectValue
(
p
)
)
;
return
true
;
}
template
<
typename
T
>
static
inline
JSObject
*
WrapNativeISupports
(
JSContext
*
cx
T
*
p
nsWrapperCache
*
cache
)
{
xpcObjectHelper
helper
(
ToSupports
(
p
)
cache
)
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
cx
)
;
return
XPCOMObjectToJsval
(
cx
scope
helper
nullptr
false
&
v
)
?
v
.
toObjectOrNull
(
)
:
nullptr
;
}
template
<
typename
T
bool
hasWrapObject
=
NativeHasMember
<
T
>
:
:
WrapObject
>
struct
WrapNativeHelper
{
static
inline
JSObject
*
Wrap
(
JSContext
*
cx
T
*
parent
nsWrapperCache
*
cache
)
{
MOZ_ASSERT
(
cache
)
;
JSObject
*
obj
;
if
(
(
obj
=
cache
-
>
GetWrapper
(
)
)
)
{
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
obj
)
)
;
return
obj
;
}
obj
=
parent
-
>
WrapObject
(
cx
nullptr
)
;
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
obj
)
)
;
return
obj
;
}
}
;
template
<
typename
T
>
struct
WrapNativeHelper
<
T
false
>
{
static
inline
JSObject
*
Wrap
(
JSContext
*
cx
T
*
parent
nsWrapperCache
*
cache
)
{
JSObject
*
obj
;
if
(
cache
&
&
(
obj
=
cache
-
>
GetWrapper
(
)
)
)
{
#
ifdef
DEBUG
JS
:
:
Rooted
<
JSObject
*
>
rootedObj
(
cx
obj
)
;
NS_ASSERTION
(
WrapNativeISupports
(
cx
parent
cache
)
=
=
rootedObj
"
Unexpected
object
in
nsWrapperCache
"
)
;
obj
=
rootedObj
;
#
endif
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
obj
)
)
;
return
obj
;
}
obj
=
WrapNativeISupports
(
cx
parent
cache
)
;
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
obj
)
)
;
return
obj
;
}
}
;
template
<
typename
T
>
static
inline
JSObject
*
FindAssociatedGlobal
(
JSContext
*
cx
T
*
p
nsWrapperCache
*
cache
bool
useXBLScope
=
false
)
{
if
(
!
p
)
{
return
JS
:
:
CurrentGlobalOrNull
(
cx
)
;
}
JSObject
*
obj
=
WrapNativeHelper
<
T
>
:
:
Wrap
(
cx
p
cache
)
;
if
(
!
obj
)
{
return
nullptr
;
}
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
obj
)
)
;
obj
=
JS
:
:
GetNonCCWObjectGlobal
(
obj
)
;
if
(
!
useXBLScope
)
{
return
obj
;
}
if
(
xpc
:
:
IsInContentXBLScope
(
obj
)
)
{
return
obj
;
}
JS
:
:
Rooted
<
JSObject
*
>
rootedObj
(
cx
obj
)
;
JSObject
*
xblScope
=
xpc
:
:
GetXBLScope
(
cx
rootedObj
)
;
MOZ_ASSERT_IF
(
xblScope
JS_IsGlobalObject
(
xblScope
)
)
;
MOZ_ASSERT
(
JS
:
:
ObjectIsNotGray
(
xblScope
)
)
;
return
xblScope
;
}
template
<
typename
T
>
static
inline
JSObject
*
FindAssociatedGlobal
(
JSContext
*
cx
const
T
&
p
)
{
return
FindAssociatedGlobal
(
cx
GetParentPointer
(
p
)
GetWrapperCache
(
p
)
GetUseXBLScope
(
p
)
)
;
}
template
<
>
inline
JSObject
*
FindAssociatedGlobal
(
JSContext
*
cx
nsIGlobalObject
*
const
&
p
)
{
if
(
!
p
)
{
return
JS
:
:
CurrentGlobalOrNull
(
cx
)
;
}
JSObject
*
global
=
p
-
>
GetGlobalJSObject
(
)
;
if
(
!
global
)
{
return
nullptr
;
}
MOZ_ASSERT
(
JS_IsGlobalObject
(
global
)
)
;
JS
:
:
ExposeObjectToActiveJS
(
global
)
;
return
global
;
}
template
<
typename
T
bool
hasAssociatedGlobal
=
NativeHasMember
<
T
>
:
:
GetParentObject
>
struct
FindAssociatedGlobalForNative
{
static
JSObject
*
Get
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
{
MOZ_ASSERT
(
js
:
:
IsObjectInContextCompartment
(
obj
cx
)
)
;
T
*
native
=
UnwrapDOMObject
<
T
>
(
obj
)
;
return
FindAssociatedGlobal
(
cx
native
-
>
GetParentObject
(
)
)
;
}
}
;
template
<
typename
T
>
struct
FindAssociatedGlobalForNative
<
T
false
>
{
static
JSObject
*
Get
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
{
MOZ_CRASH
(
)
;
return
nullptr
;
}
}
;
template
<
class
T
bool
isSmartPtr
=
IsSmartPtr
<
T
>
:
:
value
>
struct
GetOrCreateDOMReflectorHelper
{
static
inline
bool
GetOrCreate
(
JSContext
*
cx
const
T
&
value
JS
:
:
Handle
<
JSObject
*
>
givenProto
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
GetOrCreateDOMReflector
(
cx
value
.
get
(
)
rval
givenProto
)
;
}
}
;
template
<
class
T
>
struct
GetOrCreateDOMReflectorHelper
<
T
false
>
{
static
inline
bool
GetOrCreate
(
JSContext
*
cx
T
&
value
JS
:
:
Handle
<
JSObject
*
>
givenProto
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
static_assert
(
IsRefcounted
<
T
>
:
:
value
"
Don
'
t
pass
owned
classes
in
here
.
"
)
;
return
GetOrCreateDOMReflector
(
cx
&
value
rval
givenProto
)
;
}
}
;
template
<
class
T
>
inline
bool
GetOrCreateDOMReflector
(
JSContext
*
cx
T
&
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
JS
:
:
Handle
<
JSObject
*
>
givenProto
=
nullptr
)
{
return
GetOrCreateDOMReflectorHelper
<
T
>
:
:
GetOrCreate
(
cx
value
givenProto
rval
)
;
}
template
<
class
T
bool
isSmartPtr
=
IsSmartPtr
<
T
>
:
:
value
>
struct
GetOrCreateDOMReflectorNoWrapHelper
{
static
inline
bool
GetOrCreate
(
JSContext
*
cx
const
T
&
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
GetOrCreateDOMReflectorNoWrap
(
cx
value
.
get
(
)
rval
)
;
}
}
;
template
<
class
T
>
struct
GetOrCreateDOMReflectorNoWrapHelper
<
T
false
>
{
static
inline
bool
GetOrCreate
(
JSContext
*
cx
T
&
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
GetOrCreateDOMReflectorNoWrap
(
cx
&
value
rval
)
;
}
}
;
template
<
class
T
>
inline
bool
GetOrCreateDOMReflectorNoWrap
(
JSContext
*
cx
T
&
value
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
return
GetOrCreateDOMReflectorNoWrapHelper
<
T
>
:
:
GetOrCreate
(
cx
value
rval
)
;
}
template
<
class
T
>
inline
JSObject
*
GetCallbackFromCallbackObject
(
JSContext
*
aCx
T
*
aObj
)
{
return
aObj
-
>
Callback
(
aCx
)
;
}
template
<
class
T
bool
isSmartPtr
=
IsSmartPtr
<
T
>
:
:
value
>
struct
GetCallbackFromCallbackObjectHelper
{
static
inline
JSObject
*
Get
(
JSContext
*
aCx
const
T
&
aObj
)
{
return
GetCallbackFromCallbackObject
(
aCx
aObj
.
get
(
)
)
;
}
}
;
template
<
class
T
>
struct
GetCallbackFromCallbackObjectHelper
<
T
false
>
{
static
inline
JSObject
*
Get
(
JSContext
*
aCx
T
&
aObj
)
{
return
GetCallbackFromCallbackObject
(
aCx
&
aObj
)
;
}
}
;
template
<
class
T
>
inline
JSObject
*
GetCallbackFromCallbackObject
(
JSContext
*
aCx
T
&
aObj
)
{
return
GetCallbackFromCallbackObjectHelper
<
T
>
:
:
Get
(
aCx
aObj
)
;
}
static
inline
bool
AtomizeAndPinJSString
(
JSContext
*
cx
jsid
&
id
const
char
*
chars
)
{
if
(
JSString
*
str
=
:
:
JS_AtomizeAndPinString
(
cx
chars
)
)
{
id
=
INTERNED_STRING_TO_JSID
(
cx
str
)
;
return
true
;
}
return
false
;
}
bool
InitIds
(
JSContext
*
cx
const
NativeProperties
*
properties
)
;
bool
QueryInterface
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
<
class
T
>
struct
WantsQueryInterface
{
static_assert
(
IsBaseOf
<
nsISupports
T
>
:
:
value
"
QueryInterface
can
'
t
work
without
an
nsISupports
.
"
)
;
static
bool
Enabled
(
JSContext
*
aCx
JSObject
*
aGlobal
)
{
return
NS_IsMainThread
(
)
&
&
IsChromeOrXBL
(
aCx
aGlobal
)
;
}
}
;
void
GetInterfaceImpl
(
JSContext
*
aCx
nsIInterfaceRequestor
*
aRequestor
nsWrapperCache
*
aCache
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
;
template
<
class
T
>
void
GetInterface
(
JSContext
*
aCx
T
*
aThis
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
GetInterfaceImpl
(
aCx
aThis
aThis
aIID
aRetval
aError
)
;
}
bool
ThrowingConstructor
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
bool
ThrowConstructorWithoutNew
(
JSContext
*
cx
const
char
*
name
)
;
bool
GetPropertyOnPrototype
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
JS
:
:
Value
>
receiver
JS
:
:
Handle
<
jsid
>
id
bool
*
found
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
)
;
bool
HasPropertyOnPrototype
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
JS
:
:
Handle
<
jsid
>
id
bool
*
has
)
;
bool
AppendNamedPropertyIds
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
proxy
nsTArray
<
nsString
>
&
names
bool
shadowPrototypeProperties
JS
:
:
AutoIdVector
&
props
)
;
enum
StringificationBehavior
{
eStringify
eEmpty
eNull
}
;
template
<
typename
T
>
static
inline
bool
ConvertJSValueToString
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v
StringificationBehavior
nullBehavior
StringificationBehavior
undefinedBehavior
T
&
result
)
{
JSString
*
s
;
if
(
v
.
isString
(
)
)
{
s
=
v
.
toString
(
)
;
}
else
{
StringificationBehavior
behavior
;
if
(
v
.
isNull
(
)
)
{
behavior
=
nullBehavior
;
}
else
if
(
v
.
isUndefined
(
)
)
{
behavior
=
undefinedBehavior
;
}
else
{
behavior
=
eStringify
;
}
if
(
behavior
!
=
eStringify
)
{
if
(
behavior
=
=
eEmpty
)
{
result
.
Truncate
(
)
;
}
else
{
result
.
SetIsVoid
(
true
)
;
}
return
true
;
}
s
=
JS
:
:
ToString
(
cx
v
)
;
if
(
!
s
)
{
return
false
;
}
}
return
AssignJSString
(
cx
result
s
)
;
}
template
<
typename
T
>
static
inline
bool
ConvertJSValueToString
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v
T
&
result
)
{
return
ConvertJSValueToString
(
cx
v
eStringify
eStringify
result
)
;
}
void
NormalizeUSVString
(
nsAString
&
aString
)
;
void
NormalizeUSVString
(
binding_detail
:
:
FakeString
&
aString
)
;
template
<
typename
T
>
static
inline
bool
ConvertJSValueToUSVString
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v
T
&
result
)
{
if
(
!
ConvertJSValueToString
(
cx
v
eStringify
eStringify
result
)
)
{
return
false
;
}
NormalizeUSVString
(
result
)
;
return
true
;
}
template
<
typename
T
>
inline
bool
ConvertIdToString
(
JSContext
*
cx
JS
:
:
HandleId
id
T
&
result
bool
&
isSymbol
)
{
if
(
MOZ_LIKELY
(
JSID_IS_STRING
(
id
)
)
)
{
if
(
!
AssignJSString
(
cx
result
JSID_TO_STRING
(
id
)
)
)
{
return
false
;
}
}
else
if
(
JSID_IS_SYMBOL
(
id
)
)
{
isSymbol
=
true
;
return
true
;
}
else
{
JS
:
:
RootedValue
nameVal
(
cx
js
:
:
IdToValue
(
id
)
)
;
if
(
!
ConvertJSValueToString
(
cx
nameVal
eStringify
eStringify
result
)
)
{
return
false
;
}
}
isSymbol
=
false
;
return
true
;
}
bool
ConvertJSValueToByteString
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v
bool
nullable
nsACString
&
result
)
;
inline
bool
ConvertJSValueToByteString
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
v
nsACString
&
result
)
{
return
ConvertJSValueToByteString
(
cx
v
false
result
)
;
}
template
<
typename
T
>
void
DoTraceSequence
(
JSTracer
*
trc
FallibleTArray
<
T
>
&
seq
)
;
template
<
typename
T
>
void
DoTraceSequence
(
JSTracer
*
trc
InfallibleTArray
<
T
>
&
seq
)
;
template
<
typename
T
bool
isDictionary
=
IsBaseOf
<
DictionaryBase
T
>
:
:
value
bool
isTypedArray
=
IsBaseOf
<
AllTypedArraysBase
T
>
:
:
value
bool
isOwningUnion
=
IsBaseOf
<
AllOwningUnionBase
T
>
:
:
value
>
class
SequenceTracer
{
explicit
SequenceTracer
(
)
=
delete
;
}
;
template
<
>
class
SequenceTracer
<
JSObject
*
false
false
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
JSObject
*
*
objp
JSObject
*
*
end
)
{
for
(
;
objp
!
=
end
;
+
+
objp
)
{
JS
:
:
UnsafeTraceRoot
(
trc
objp
"
sequence
<
object
>
"
)
;
}
}
}
;
template
<
>
class
SequenceTracer
<
JS
:
:
Value
false
false
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
JS
:
:
Value
*
valp
JS
:
:
Value
*
end
)
{
for
(
;
valp
!
=
end
;
+
+
valp
)
{
JS
:
:
UnsafeTraceRoot
(
trc
valp
"
sequence
<
any
>
"
)
;
}
}
}
;
template
<
typename
T
>
class
SequenceTracer
<
Sequence
<
T
>
false
false
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
Sequence
<
T
>
*
seqp
Sequence
<
T
>
*
end
)
{
for
(
;
seqp
!
=
end
;
+
+
seqp
)
{
DoTraceSequence
(
trc
*
seqp
)
;
}
}
}
;
template
<
typename
T
>
class
SequenceTracer
<
nsTArray
<
T
>
false
false
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
nsTArray
<
T
>
*
seqp
nsTArray
<
T
>
*
end
)
{
for
(
;
seqp
!
=
end
;
+
+
seqp
)
{
DoTraceSequence
(
trc
*
seqp
)
;
}
}
}
;
template
<
typename
T
>
class
SequenceTracer
<
T
true
false
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
T
*
dictp
T
*
end
)
{
for
(
;
dictp
!
=
end
;
+
+
dictp
)
{
dictp
-
>
TraceDictionary
(
trc
)
;
}
}
}
;
template
<
typename
T
>
class
SequenceTracer
<
T
false
true
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
T
*
arrayp
T
*
end
)
{
for
(
;
arrayp
!
=
end
;
+
+
arrayp
)
{
arrayp
-
>
TraceSelf
(
trc
)
;
}
}
}
;
template
<
typename
T
>
class
SequenceTracer
<
T
false
false
true
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
T
*
arrayp
T
*
end
)
{
for
(
;
arrayp
!
=
end
;
+
+
arrayp
)
{
arrayp
-
>
TraceUnion
(
trc
)
;
}
}
}
;
template
<
typename
T
>
class
SequenceTracer
<
Nullable
<
T
>
false
false
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
Nullable
<
T
>
*
seqp
Nullable
<
T
>
*
end
)
{
for
(
;
seqp
!
=
end
;
+
+
seqp
)
{
if
(
!
seqp
-
>
IsNull
(
)
)
{
T
&
val
=
seqp
-
>
Value
(
)
;
T
*
ptr
=
&
val
;
SequenceTracer
<
T
>
:
:
TraceSequence
(
trc
ptr
ptr
+
1
)
;
}
}
}
}
;
template
<
typename
K
typename
V
>
void
TraceRecord
(
JSTracer
*
trc
Record
<
K
V
>
&
record
)
{
for
(
auto
&
entry
:
record
.
Entries
(
)
)
{
SequenceTracer
<
V
>
:
:
TraceSequence
(
trc
&
entry
.
mValue
&
entry
.
mValue
+
1
)
;
}
}
template
<
typename
K
typename
V
>
class
SequenceTracer
<
Record
<
K
V
>
false
false
false
>
{
explicit
SequenceTracer
(
)
=
delete
;
public
:
static
void
TraceSequence
(
JSTracer
*
trc
Record
<
K
V
>
*
seqp
Record
<
K
V
>
*
end
)
{
for
(
;
seqp
!
=
end
;
+
+
seqp
)
{
TraceRecord
(
trc
*
seqp
)
;
}
}
}
;
template
<
typename
T
>
void
DoTraceSequence
(
JSTracer
*
trc
FallibleTArray
<
T
>
&
seq
)
{
SequenceTracer
<
T
>
:
:
TraceSequence
(
trc
seq
.
Elements
(
)
seq
.
Elements
(
)
+
seq
.
Length
(
)
)
;
}
template
<
typename
T
>
void
DoTraceSequence
(
JSTracer
*
trc
InfallibleTArray
<
T
>
&
seq
)
{
SequenceTracer
<
T
>
:
:
TraceSequence
(
trc
seq
.
Elements
(
)
seq
.
Elements
(
)
+
seq
.
Length
(
)
)
;
}
template
<
typename
T
>
class
MOZ_RAII
SequenceRooter
final
:
private
JS
:
:
CustomAutoRooter
{
public
:
SequenceRooter
(
JSContext
*
aCx
FallibleTArray
<
T
>
*
aSequence
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
CustomAutoRooter
(
aCx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT
)
mFallibleArray
(
aSequence
)
mSequenceType
(
eFallibleArray
)
{
}
SequenceRooter
(
JSContext
*
aCx
InfallibleTArray
<
T
>
*
aSequence
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
CustomAutoRooter
(
aCx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT
)
mInfallibleArray
(
aSequence
)
mSequenceType
(
eInfallibleArray
)
{
}
SequenceRooter
(
JSContext
*
aCx
Nullable
<
nsTArray
<
T
>
>
*
aSequence
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
CustomAutoRooter
(
aCx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT
)
mNullableArray
(
aSequence
)
mSequenceType
(
eNullableArray
)
{
}
private
:
enum
SequenceType
{
eInfallibleArray
eFallibleArray
eNullableArray
}
;
virtual
void
trace
(
JSTracer
*
trc
)
override
{
if
(
mSequenceType
=
=
eFallibleArray
)
{
DoTraceSequence
(
trc
*
mFallibleArray
)
;
}
else
if
(
mSequenceType
=
=
eInfallibleArray
)
{
DoTraceSequence
(
trc
*
mInfallibleArray
)
;
}
else
{
MOZ_ASSERT
(
mSequenceType
=
=
eNullableArray
)
;
if
(
!
mNullableArray
-
>
IsNull
(
)
)
{
DoTraceSequence
(
trc
mNullableArray
-
>
Value
(
)
)
;
}
}
}
union
{
InfallibleTArray
<
T
>
*
mInfallibleArray
;
FallibleTArray
<
T
>
*
mFallibleArray
;
Nullable
<
nsTArray
<
T
>
>
*
mNullableArray
;
}
;
SequenceType
mSequenceType
;
}
;
template
<
typename
K
typename
V
>
class
MOZ_RAII
RecordRooter
final
:
private
JS
:
:
CustomAutoRooter
{
public
:
RecordRooter
(
JSContext
*
aCx
Record
<
K
V
>
*
aRecord
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
CustomAutoRooter
(
aCx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT
)
mRecord
(
aRecord
)
mRecordType
(
eRecord
)
{
}
RecordRooter
(
JSContext
*
aCx
Nullable
<
Record
<
K
V
>
>
*
aRecord
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
JS
:
:
CustomAutoRooter
(
aCx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT
)
mNullableRecord
(
aRecord
)
mRecordType
(
eNullableRecord
)
{
}
private
:
enum
RecordType
{
eRecord
eNullableRecord
}
;
virtual
void
trace
(
JSTracer
*
trc
)
override
{
if
(
mRecordType
=
=
eRecord
)
{
TraceRecord
(
trc
*
mRecord
)
;
}
else
{
MOZ_ASSERT
(
mRecordType
=
=
eNullableRecord
)
;
if
(
!
mNullableRecord
-
>
IsNull
(
)
)
{
TraceRecord
(
trc
mNullableRecord
-
>
Value
(
)
)
;
}
}
}
union
{
Record
<
K
V
>
*
mRecord
;
Nullable
<
Record
<
K
V
>
>
*
mNullableRecord
;
}
;
RecordType
mRecordType
;
}
;
template
<
typename
T
>
class
MOZ_RAII
RootedUnion
:
public
T
private
JS
:
:
CustomAutoRooter
{
public
:
explicit
RootedUnion
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
T
(
)
JS
:
:
CustomAutoRooter
(
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT
)
{
}
virtual
void
trace
(
JSTracer
*
trc
)
override
{
this
-
>
TraceUnion
(
trc
)
;
}
}
;
template
<
typename
T
>
class
MOZ_STACK_CLASS
NullableRootedUnion
:
public
Nullable
<
T
>
private
JS
:
:
CustomAutoRooter
{
public
:
explicit
NullableRootedUnion
(
JSContext
*
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
Nullable
<
T
>
(
)
JS
:
:
CustomAutoRooter
(
cx
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_TO_PARENT
)
{
}
virtual
void
trace
(
JSTracer
*
trc
)
override
{
if
(
!
this
-
>
IsNull
(
)
)
{
this
-
>
Value
(
)
.
TraceUnion
(
trc
)
;
}
}
}
;
inline
bool
IdEquals
(
jsid
id
const
char
*
string
)
{
return
JSID_IS_STRING
(
id
)
&
&
JS_FlatStringEqualsAscii
(
JSID_TO_FLAT_STRING
(
id
)
string
)
;
}
inline
bool
AddStringToIDVector
(
JSContext
*
cx
JS
:
:
AutoIdVector
&
vector
const
char
*
name
)
{
return
vector
.
growBy
(
1
)
&
&
AtomizeAndPinJSString
(
cx
*
(
vector
[
vector
.
length
(
)
-
1
]
)
.
address
(
)
name
)
;
}
enum
{
CONSTRUCTOR_NATIVE_HOLDER_RESERVED_SLOT
=
0
}
;
bool
Constructor
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
bool
XrayResolveOwnProperty
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
bool
&
cacheOnHolder
)
;
bool
XrayDefineProperty
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
Handle
<
JS
:
:
PropertyDescriptor
>
desc
JS
:
:
ObjectOpResult
&
result
bool
*
defined
)
;
bool
XrayOwnPropertyKeys
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
unsigned
flags
JS
:
:
AutoIdVector
&
props
)
;
inline
bool
XrayGetNativeProto
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
MutableHandle
<
JSObject
*
>
protop
)
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
JS
:
:
GetNonCCWObjectGlobal
(
obj
)
)
;
{
JSAutoRealm
ar
(
cx
global
)
;
const
DOMJSClass
*
domClass
=
GetDOMClass
(
obj
)
;
if
(
domClass
)
{
ProtoHandleGetter
protoGetter
=
domClass
-
>
mGetProto
;
if
(
protoGetter
)
{
protop
.
set
(
protoGetter
(
cx
)
)
;
}
else
{
protop
.
set
(
JS
:
:
GetRealmObjectPrototype
(
cx
)
)
;
}
}
else
if
(
JS_ObjectIsFunction
(
cx
obj
)
)
{
MOZ_ASSERT
(
JS_IsNativeFunction
(
obj
Constructor
)
)
;
protop
.
set
(
JS
:
:
GetRealmFunctionPrototype
(
cx
)
)
;
}
else
{
const
js
:
:
Class
*
clasp
=
js
:
:
GetObjectClass
(
obj
)
;
MOZ_ASSERT
(
IsDOMIfaceAndProtoClass
(
clasp
)
)
;
ProtoGetter
protoGetter
=
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
clasp
)
-
>
mGetParentProto
;
protop
.
set
(
protoGetter
(
cx
)
)
;
}
}
return
JS_WrapObject
(
cx
protop
)
;
}
const
JSClass
*
XrayGetExpandoClass
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
;
bool
XrayDeleteNamedProperty
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
wrapper
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
ObjectOpResult
&
opresult
)
;
JSObject
*
GetCachedSlotStorageObjectSlow
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
bool
*
isXray
)
;
inline
JSObject
*
GetCachedSlotStorageObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
bool
*
isXray
)
{
if
(
IsDOMObject
(
obj
)
)
{
*
isXray
=
false
;
return
obj
;
}
return
GetCachedSlotStorageObjectSlow
(
cx
obj
isXray
)
;
}
extern
NativePropertyHooks
sEmptyNativePropertyHooks
;
extern
const
js
:
:
ClassOps
sBoringInterfaceObjectClassClassOps
;
extern
const
js
:
:
ObjectOps
sInterfaceObjectClassObjectOps
;
inline
bool
UseDOMXray
(
JSObject
*
obj
)
{
const
js
:
:
Class
*
clasp
=
js
:
:
GetObjectClass
(
obj
)
;
return
IsDOMClass
(
clasp
)
|
|
JS_IsNativeFunction
(
obj
Constructor
)
|
|
IsDOMIfaceAndProtoClass
(
clasp
)
;
}
inline
bool
IsDOMConstructor
(
JSObject
*
obj
)
{
if
(
JS_IsNativeFunction
(
obj
dom
:
:
Constructor
)
)
{
return
true
;
}
const
js
:
:
Class
*
clasp
=
js
:
:
GetObjectClass
(
obj
)
;
return
dom
:
:
IsDOMIfaceAndProtoClass
(
clasp
)
&
&
dom
:
:
DOMIfaceAndProtoJSClass
:
:
FromJSClass
(
clasp
)
-
>
mType
=
=
dom
:
:
eInterface
;
}
#
ifdef
DEBUG
inline
bool
HasConstructor
(
JSObject
*
obj
)
{
return
JS_IsNativeFunction
(
obj
Constructor
)
|
|
js
:
:
GetObjectClass
(
obj
)
-
>
getConstruct
(
)
;
}
#
endif
template
<
typename
T
>
const
T
&
Constify
(
T
&
arg
)
{
return
arg
;
}
template
<
typename
T
>
T
&
NonNullHelper
(
T
&
aArg
)
{
return
aArg
;
}
template
<
typename
T
>
T
&
NonNullHelper
(
NonNull
<
T
>
&
aArg
)
{
return
aArg
;
}
template
<
typename
T
>
const
T
&
NonNullHelper
(
const
NonNull
<
T
>
&
aArg
)
{
return
aArg
;
}
template
<
typename
T
>
T
&
NonNullHelper
(
OwningNonNull
<
T
>
&
aArg
)
{
return
aArg
;
}
template
<
typename
T
>
const
T
&
NonNullHelper
(
const
OwningNonNull
<
T
>
&
aArg
)
{
return
aArg
;
}
inline
void
NonNullHelper
(
NonNull
<
binding_detail
:
:
FakeString
>
&
aArg
)
{
}
inline
void
NonNullHelper
(
const
NonNull
<
binding_detail
:
:
FakeString
>
&
aArg
)
{
}
inline
void
NonNullHelper
(
binding_detail
:
:
FakeString
&
aArg
)
{
}
MOZ_ALWAYS_INLINE
const
nsAString
&
NonNullHelper
(
const
binding_detail
:
:
FakeString
&
aArg
)
{
return
aArg
;
}
void
ReparentWrapper
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
ErrorResult
&
aError
)
;
bool
InterfaceHasInstance
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
bool
InterfaceHasInstance
(
JSContext
*
cx
int
prototypeID
int
depth
JS
:
:
Handle
<
JSObject
*
>
instance
bool
*
bp
)
;
bool
InterfaceIsInstance
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
bool
ReportLenientThisUnwrappingFailure
(
JSContext
*
cx
JSObject
*
obj
)
;
bool
GetContentGlobalForJSImplementedObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
nsIGlobalObject
*
*
global
)
;
void
ConstructJSImplementation
(
const
char
*
aContractId
nsIGlobalObject
*
aGlobal
JS
:
:
MutableHandle
<
JSObject
*
>
aObject
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsIGlobalObject
>
ConstructJSImplementation
(
const
char
*
aContractId
const
GlobalObject
&
aGlobal
JS
:
:
MutableHandle
<
JSObject
*
>
aObject
ErrorResult
&
aRv
)
;
bool
NonVoidByteStringToJsval
(
JSContext
*
cx
const
nsACString
&
str
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
;
inline
bool
ByteStringToJsval
(
JSContext
*
cx
const
nsACString
&
str
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
{
if
(
str
.
IsVoid
(
)
)
{
rval
.
setNull
(
)
;
return
true
;
}
return
NonVoidByteStringToJsval
(
cx
str
rval
)
;
}
template
<
class
T
bool
isISupports
=
IsBaseOf
<
nsISupports
T
>
:
:
value
>
struct
PreserveWrapperHelper
{
static
void
PreserveWrapper
(
T
*
aObject
)
{
aObject
-
>
PreserveWrapper
(
aObject
NS_CYCLE_COLLECTION_PARTICIPANT
(
T
)
)
;
}
}
;
template
<
class
T
>
struct
PreserveWrapperHelper
<
T
true
>
{
static
void
PreserveWrapper
(
T
*
aObject
)
{
aObject
-
>
PreserveWrapper
(
reinterpret_cast
<
nsISupports
*
>
(
aObject
)
)
;
}
}
;
template
<
class
T
>
void
PreserveWrapper
(
T
*
aObject
)
{
PreserveWrapperHelper
<
T
>
:
:
PreserveWrapper
(
aObject
)
;
}
template
<
class
T
bool
isISupports
=
IsBaseOf
<
nsISupports
T
>
:
:
value
>
struct
CastingAssertions
{
static
bool
ToSupportsIsCorrect
(
T
*
)
{
return
true
;
}
static
bool
ToSupportsIsOnPrimaryInheritanceChain
(
T
*
nsWrapperCache
*
)
{
return
true
;
}
}
;
template
<
class
T
>
struct
CastingAssertions
<
T
true
>
{
static
bool
ToSupportsIsCorrect
(
T
*
aObject
)
{
return
ToSupports
(
aObject
)
=
=
reinterpret_cast
<
nsISupports
*
>
(
aObject
)
;
}
static
bool
ToSupportsIsOnPrimaryInheritanceChain
(
T
*
aObject
nsWrapperCache
*
aCache
)
{
return
reinterpret_cast
<
void
*
>
(
aObject
)
!
=
aCache
;
}
}
;
template
<
class
T
>
bool
ToSupportsIsCorrect
(
T
*
aObject
)
{
return
CastingAssertions
<
T
>
:
:
ToSupportsIsCorrect
(
aObject
)
;
}
template
<
class
T
>
bool
ToSupportsIsOnPrimaryInheritanceChain
(
T
*
aObject
nsWrapperCache
*
aCache
)
{
return
CastingAssertions
<
T
>
:
:
ToSupportsIsOnPrimaryInheritanceChain
(
aObject
aCache
)
;
}
inline
size_t
BindingJSObjectMallocBytes
(
void
*
aNativePtr
)
{
return
0
;
}
template
<
class
T
>
static
void
RecordReplayRegisterDeferredFinalize
(
T
*
aObject
)
;
template
<
class
T
>
class
MOZ_STACK_CLASS
BindingJSObjectCreator
{
public
:
explicit
BindingJSObjectCreator
(
JSContext
*
aCx
)
:
mReflector
(
aCx
)
{
}
~
BindingJSObjectCreator
(
)
{
if
(
mReflector
)
{
js
:
:
SetReservedSlot
(
mReflector
DOM_OBJECT_SLOT
JS
:
:
UndefinedValue
(
)
)
;
}
}
void
CreateProxyObject
(
JSContext
*
aCx
const
js
:
:
Class
*
aClass
const
DOMProxyHandler
*
aHandler
JS
:
:
Handle
<
JSObject
*
>
aProto
T
*
aNative
JS
:
:
Handle
<
JS
:
:
Value
>
aExpandoValue
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
{
js
:
:
ProxyOptions
options
;
options
.
setClass
(
aClass
)
;
aReflector
.
set
(
js
:
:
NewProxyObject
(
aCx
aHandler
aExpandoValue
aProto
options
)
)
;
if
(
aReflector
)
{
js
:
:
SetProxyReservedSlot
(
aReflector
DOM_OBJECT_SLOT
JS
:
:
PrivateValue
(
aNative
)
)
;
mNative
=
aNative
;
mReflector
=
aReflector
;
RecordReplayRegisterDeferredFinalize
<
T
>
(
aNative
)
;
}
if
(
size_t
mallocBytes
=
BindingJSObjectMallocBytes
(
aNative
)
)
{
JS_updateMallocCounter
(
aCx
mallocBytes
)
;
}
}
void
CreateObject
(
JSContext
*
aCx
const
JSClass
*
aClass
JS
:
:
Handle
<
JSObject
*
>
aProto
T
*
aNative
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
{
aReflector
.
set
(
JS_NewObjectWithGivenProto
(
aCx
aClass
aProto
)
)
;
if
(
aReflector
)
{
js
:
:
SetReservedSlot
(
aReflector
DOM_OBJECT_SLOT
JS
:
:
PrivateValue
(
aNative
)
)
;
mNative
=
aNative
;
mReflector
=
aReflector
;
RecordReplayRegisterDeferredFinalize
<
T
>
(
aNative
)
;
}
if
(
size_t
mallocBytes
=
BindingJSObjectMallocBytes
(
aNative
)
)
{
JS_updateMallocCounter
(
aCx
mallocBytes
)
;
}
}
void
InitializationSucceeded
(
)
{
void
*
dummy
;
mNative
.
forget
(
&
dummy
)
;
mReflector
=
nullptr
;
}
private
:
struct
OwnedNative
{
static_assert
(
IsBaseOf
<
NonRefcountedDOMObject
T
>
:
:
value
"
Non
-
refcounted
objects
with
DOM
bindings
should
inherit
"
"
from
NonRefcountedDOMObject
.
"
)
;
OwnedNative
&
operator
=
(
T
*
aNative
)
{
return
*
this
;
}
void
forget
(
void
*
*
)
{
}
}
;
JS
:
:
Rooted
<
JSObject
*
>
mReflector
;
typename
Conditional
<
IsRefcounted
<
T
>
:
:
value
RefPtr
<
T
>
OwnedNative
>
:
:
Type
mNative
;
}
;
template
<
class
T
>
struct
DeferredFinalizerImpl
{
typedef
typename
Conditional
<
IsSame
<
T
nsISupports
>
:
:
value
nsCOMPtr
<
T
>
typename
Conditional
<
IsRefcounted
<
T
>
:
:
value
RefPtr
<
T
>
nsAutoPtr
<
T
>
>
:
:
Type
>
:
:
Type
SmartPtr
;
typedef
SegmentedVector
<
SmartPtr
>
SmartPtrArray
;
static_assert
(
IsSame
<
T
nsISupports
>
:
:
value
|
|
!
IsBaseOf
<
nsISupports
T
>
:
:
value
"
nsISupports
classes
should
all
use
the
nsISupports
instantiation
"
)
;
static
inline
void
AppendAndTake
(
SegmentedVector
<
nsCOMPtr
<
nsISupports
>
>
&
smartPtrArray
nsISupports
*
ptr
)
{
smartPtrArray
.
InfallibleAppend
(
dont_AddRef
(
ptr
)
)
;
}
template
<
class
U
>
static
inline
void
AppendAndTake
(
SegmentedVector
<
RefPtr
<
U
>
>
&
smartPtrArray
U
*
ptr
)
{
smartPtrArray
.
InfallibleAppend
(
dont_AddRef
(
ptr
)
)
;
}
template
<
class
U
>
static
inline
void
AppendAndTake
(
SegmentedVector
<
nsAutoPtr
<
U
>
>
&
smartPtrArray
U
*
ptr
)
{
smartPtrArray
.
InfallibleAppend
(
ptr
)
;
}
static
void
*
AppendDeferredFinalizePointer
(
void
*
aData
void
*
aObject
)
{
SmartPtrArray
*
pointers
=
static_cast
<
SmartPtrArray
*
>
(
aData
)
;
if
(
!
pointers
)
{
pointers
=
new
SmartPtrArray
(
)
;
}
AppendAndTake
(
*
pointers
static_cast
<
T
*
>
(
aObject
)
)
;
return
pointers
;
}
static
bool
DeferredFinalize
(
uint32_t
aSlice
void
*
aData
)
{
MOZ_ASSERT
(
aSlice
>
0
"
nonsensical
/
useless
call
with
aSlice
=
=
0
"
)
;
SmartPtrArray
*
pointers
=
static_cast
<
SmartPtrArray
*
>
(
aData
)
;
uint32_t
oldLen
=
pointers
-
>
Length
(
)
;
if
(
oldLen
<
aSlice
)
{
aSlice
=
oldLen
;
}
uint32_t
newLen
=
oldLen
-
aSlice
;
pointers
-
>
PopLastN
(
aSlice
)
;
if
(
newLen
=
=
0
)
{
delete
pointers
;
return
true
;
}
return
false
;
}
}
;
template
<
class
T
bool
isISupports
=
IsBaseOf
<
nsISupports
T
>
:
:
value
>
struct
DeferredFinalizer
{
static
void
AddForDeferredFinalization
(
T
*
aObject
)
{
typedef
DeferredFinalizerImpl
<
T
>
Impl
;
DeferredFinalize
(
Impl
:
:
AppendDeferredFinalizePointer
Impl
:
:
DeferredFinalize
aObject
)
;
}
static
void
RecordReplayRegisterDeferredFinalize
(
T
*
aObject
)
{
typedef
DeferredFinalizerImpl
<
T
>
Impl
;
RecordReplayRegisterDeferredFinalizeThing
(
Impl
:
:
AppendDeferredFinalizePointer
Impl
:
:
DeferredFinalize
aObject
)
;
}
}
;
template
<
class
T
>
struct
DeferredFinalizer
<
T
true
>
{
static
void
AddForDeferredFinalization
(
T
*
aObject
)
{
DeferredFinalize
(
reinterpret_cast
<
nsISupports
*
>
(
aObject
)
)
;
}
static
void
RecordReplayRegisterDeferredFinalize
(
T
*
aObject
)
{
RecordReplayRegisterDeferredFinalizeThing
(
nullptr
nullptr
aObject
)
;
}
}
;
template
<
class
T
>
static
void
AddForDeferredFinalization
(
T
*
aObject
)
{
DeferredFinalizer
<
T
>
:
:
AddForDeferredFinalization
(
aObject
)
;
}
template
<
class
T
>
static
void
RecordReplayRegisterDeferredFinalize
(
T
*
aObject
)
{
DeferredFinalizer
<
T
>
:
:
RecordReplayRegisterDeferredFinalize
(
aObject
)
;
}
template
<
class
T
bool
isISupports
=
IsBaseOf
<
nsISupports
T
>
:
:
value
>
class
GetCCParticipant
{
template
<
class
U
>
static
constexpr
nsCycleCollectionParticipant
*
GetHelper
(
int
typename
U
:
:
NS_CYCLE_COLLECTION_INNERCLASS
*
dummy
=
nullptr
)
{
return
T
:
:
NS_CYCLE_COLLECTION_INNERCLASS
:
:
GetParticipant
(
)
;
}
template
<
class
U
>
static
constexpr
nsCycleCollectionParticipant
*
GetHelper
(
double
)
{
return
nullptr
;
}
public
:
static
constexpr
nsCycleCollectionParticipant
*
Get
(
)
{
return
GetHelper
<
T
>
(
int
(
)
)
;
}
}
;
template
<
class
T
>
class
GetCCParticipant
<
T
true
>
{
public
:
static
constexpr
nsCycleCollectionParticipant
*
Get
(
)
{
return
nullptr
;
}
}
;
void
FinalizeGlobal
(
JSFreeOp
*
aFop
JSObject
*
aObj
)
;
bool
ResolveGlobal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
Handle
<
jsid
>
aId
bool
*
aResolvedp
)
;
bool
MayResolveGlobal
(
const
JSAtomState
&
aNames
jsid
aId
JSObject
*
aMaybeObj
)
;
bool
EnumerateGlobal
(
JSContext
*
aCx
JS
:
:
HandleObject
aObj
JS
:
:
AutoIdVector
&
aProperties
bool
aEnumerableOnly
)
;
struct
CreateGlobalOptionsGeneric
{
static
void
TraceGlobal
(
JSTracer
*
aTrc
JSObject
*
aObj
)
{
mozilla
:
:
dom
:
:
TraceProtoAndIfaceCache
(
aTrc
aObj
)
;
}
static
bool
PostCreateGlobal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
{
MOZ_ALWAYS_TRUE
(
TryPreserveWrapper
(
aGlobal
)
)
;
return
true
;
}
}
;
struct
CreateGlobalOptionsWithXPConnect
{
static
void
TraceGlobal
(
JSTracer
*
aTrc
JSObject
*
aObj
)
;
static
bool
PostCreateGlobal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
;
}
;
template
<
class
T
>
using
IsGlobalWithXPConnect
=
IntegralConstant
<
bool
IsBaseOf
<
nsGlobalWindowInner
T
>
:
:
value
|
|
IsBaseOf
<
MessageManagerGlobal
T
>
:
:
value
>
;
template
<
class
T
>
struct
CreateGlobalOptions
:
Conditional
<
IsGlobalWithXPConnect
<
T
>
:
:
value
CreateGlobalOptionsWithXPConnect
CreateGlobalOptionsGeneric
>
:
:
Type
{
static
constexpr
ProtoAndIfaceCache
:
:
Kind
ProtoAndIfaceCacheKind
=
ProtoAndIfaceCache
:
:
NonWindowLike
;
}
;
template
<
>
struct
CreateGlobalOptions
<
nsGlobalWindowInner
>
:
public
CreateGlobalOptionsWithXPConnect
{
static
constexpr
ProtoAndIfaceCache
:
:
Kind
ProtoAndIfaceCacheKind
=
ProtoAndIfaceCache
:
:
WindowLike
;
static
bool
PostCreateGlobal
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
;
}
;
template
<
class
T
ProtoHandleGetter
GetProto
>
bool
CreateGlobal
(
JSContext
*
aCx
T
*
aNative
nsWrapperCache
*
aCache
const
JSClass
*
aClass
JS
:
:
RealmOptions
&
aOptions
JSPrincipals
*
aPrincipal
bool
aInitStandardClasses
JS
:
:
MutableHandle
<
JSObject
*
>
aGlobal
)
{
aOptions
.
creationOptions
(
)
.
setTrace
(
CreateGlobalOptions
<
T
>
:
:
TraceGlobal
)
;
if
(
xpc
:
:
SharedMemoryEnabled
(
)
)
{
aOptions
.
creationOptions
(
)
.
setSharedMemoryAndAtomicsEnabled
(
true
)
;
}
aGlobal
.
set
(
JS_NewGlobalObject
(
aCx
aClass
aPrincipal
JS
:
:
DontFireOnNewGlobalHook
aOptions
)
)
;
if
(
!
aGlobal
)
{
NS_WARNING
(
"
Failed
to
create
global
"
)
;
return
false
;
}
JSAutoRealm
ar
(
aCx
aGlobal
)
;
{
js
:
:
SetReservedSlot
(
aGlobal
DOM_OBJECT_SLOT
JS
:
:
PrivateValue
(
aNative
)
)
;
NS_ADDREF
(
aNative
)
;
aCache
-
>
SetWrapper
(
aGlobal
)
;
RecordReplayRegisterDeferredFinalize
<
T
>
(
aNative
)
;
dom
:
:
AllocateProtoAndIfaceCache
(
aGlobal
CreateGlobalOptions
<
T
>
:
:
ProtoAndIfaceCacheKind
)
;
if
(
!
CreateGlobalOptions
<
T
>
:
:
PostCreateGlobal
(
aCx
aGlobal
)
)
{
return
false
;
}
}
if
(
aInitStandardClasses
&
&
!
JS
:
:
InitRealmStandardClasses
(
aCx
)
)
{
NS_WARNING
(
"
Failed
to
init
standard
classes
"
)
;
return
false
;
}
JS
:
:
Handle
<
JSObject
*
>
proto
=
GetProto
(
aCx
)
;
if
(
!
proto
|
|
!
JS_SplicePrototype
(
aCx
aGlobal
proto
)
)
{
NS_WARNING
(
"
Failed
to
set
proto
"
)
;
return
false
;
}
bool
succeeded
;
if
(
!
JS_SetImmutablePrototype
(
aCx
aGlobal
&
succeeded
)
)
{
return
false
;
}
MOZ_ASSERT
(
succeeded
"
making
a
fresh
global
object
'
s
[
[
Prototype
]
]
immutable
can
"
"
internally
fail
but
it
should
never
be
unsuccessful
"
)
;
return
true
;
}
class
PinnedStringId
{
jsid
id
;
public
:
constexpr
PinnedStringId
(
)
:
id
(
JSID_VOID
)
{
}
bool
init
(
JSContext
*
cx
const
char
*
string
)
{
JSString
*
str
=
JS_AtomizeAndPinString
(
cx
string
)
;
if
(
!
str
)
return
false
;
id
=
INTERNED_STRING_TO_JSID
(
cx
str
)
;
return
true
;
}
operator
const
jsid
&
(
)
const
{
return
id
;
}
operator
JS
:
:
Handle
<
jsid
>
(
)
const
{
return
JS
:
:
Handle
<
jsid
>
:
:
fromMarkedLocation
(
&
id
)
;
}
}
JS_HAZ_ROOTED
;
namespace
binding_detail
{
template
<
typename
ThisPolicy
typename
ExceptionPolicy
>
bool
GenericGetter
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
<
typename
ThisPolicy
>
bool
GenericSetter
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
template
<
typename
ThisPolicy
typename
ExceptionPolicy
>
bool
GenericMethod
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
struct
NormalThisPolicy
;
struct
MaybeGlobalThisPolicy
;
struct
LenientThisPolicy
;
struct
CrossOriginThisPolicy
;
struct
ThrowExceptions
;
struct
ConvertExceptionsToPromises
;
}
bool
StaticMethodPromiseWrapper
(
JSContext
*
cx
unsigned
argc
JS
:
:
Value
*
vp
)
;
bool
ConvertExceptionToPromise
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
rval
)
;
#
ifdef
DEBUG
void
AssertReturnTypeMatchesJitinfo
(
const
JSJitInfo
*
aJitinfo
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
#
endif
bool
CallerSubsumes
(
JSObject
*
aObject
)
;
MOZ_ALWAYS_INLINE
bool
CallerSubsumes
(
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
if
(
!
aValue
.
isObject
(
)
)
{
return
true
;
}
return
CallerSubsumes
(
&
aValue
.
toObject
(
)
)
;
}
template
<
class
T
class
S
>
inline
RefPtr
<
T
>
StrongOrRawPtr
(
already_AddRefed
<
S
>
&
&
aPtr
)
{
return
std
:
:
move
(
aPtr
)
;
}
template
<
class
T
class
ReturnType
=
typename
Conditional
<
IsRefcounted
<
T
>
:
:
value
T
*
nsAutoPtr
<
T
>
>
:
:
Type
>
inline
ReturnType
StrongOrRawPtr
(
T
*
aPtr
)
{
return
ReturnType
(
aPtr
)
;
}
template
<
class
T
template
<
typename
>
class
SmartPtr
class
S
>
inline
void
StrongOrRawPtr
(
SmartPtr
<
S
>
&
&
aPtr
)
=
delete
;
template
<
class
T
>
struct
StrongPtrForMember
{
typedef
typename
Conditional
<
IsRefcounted
<
T
>
:
:
value
RefPtr
<
T
>
nsAutoPtr
<
T
>
>
:
:
Type
Type
;
}
;
namespace
binding_detail
{
inline
JSObject
*
GetHackedNamespaceProtoObject
(
JSContext
*
aCx
)
{
return
JS_NewPlainObject
(
aCx
)
;
}
}
bool
SystemGlobalResolve
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
bool
*
resolvedp
)
;
bool
SystemGlobalEnumerate
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
)
;
#
define
FOREACH_CALLBACK_SLOT
0
#
define
FOREACH_MAPLIKEORSETLIKEOBJ_SLOT
1
bool
ForEachHandler
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
;
bool
GetMaplikeBackingObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
size_t
aSlotIndex
JS
:
:
MutableHandle
<
JSObject
*
>
aBackingObj
bool
*
aBackingObjCreated
)
;
bool
GetSetlikeBackingObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
size_t
aSlotIndex
JS
:
:
MutableHandle
<
JSObject
*
>
aBackingObj
bool
*
aBackingObjCreated
)
;
bool
GetDesiredProto
(
JSContext
*
aCx
const
JS
:
:
CallArgs
&
aCallArgs
JS
:
:
MutableHandle
<
JSObject
*
>
aDesiredProto
)
;
already_AddRefed
<
Element
>
CreateXULOrHTMLElement
(
const
GlobalObject
&
aGlobal
const
JS
:
:
CallArgs
&
aCallArgs
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
ErrorResult
&
aRv
)
;
void
SetDocumentAndPageUseCounter
(
JSObject
*
aObject
UseCounter
aUseCounter
)
;
void
DeprecationWarning
(
JSContext
*
aCx
JSObject
*
aObject
nsIDocument
:
:
DeprecatedOperations
aOperation
)
;
void
DeprecationWarning
(
const
GlobalObject
&
aGlobal
nsIDocument
:
:
DeprecatedOperations
aOperation
)
;
JSString
*
InterfaceObjectToString
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
unsigned
)
;
namespace
binding_detail
{
JSObject
*
UnprivilegedJunkScopeOrWorkerGlobal
(
)
;
bool
HTMLConstructor
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
constructors
:
:
id
:
:
ID
aConstructorId
prototypes
:
:
id
:
:
ID
aProtoId
CreateInterfaceObjectsMethod
aCreator
)
;
bool
IsGetterEnabled
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JSJitGetterOp
aGetter
const
Prefable
<
const
JSPropertySpec
>
*
aAttributes
)
;
}
}
}
#
endif
