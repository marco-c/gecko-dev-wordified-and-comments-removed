#
ifndef
mozilla_ErrorResult_h
#
define
mozilla_ErrorResult_h
#
include
<
new
>
#
include
<
stdarg
.
h
>
#
include
"
js
/
GCAnnotations
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
IPC
{
class
Message
;
template
<
typename
>
struct
ParamTraits
;
}
class
PickleIterator
;
namespace
mozilla
{
namespace
dom
{
enum
ErrNum
{
#
define
MSG_DEF
(
_name
_argc
_exn
_str
)
\
_name
#
include
"
mozilla
/
dom
/
Errors
.
msg
"
#
undef
MSG_DEF
Err_Limit
}
;
#
if
defined
(
DEBUG
)
&
&
(
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
)
uint16_t
constexpr
ErrorFormatNumArgs
[
]
=
{
#
define
MSG_DEF
(
_name
_argc
_exn
_str
)
\
_argc
#
include
"
mozilla
/
dom
/
Errors
.
msg
"
#
undef
MSG_DEF
}
;
#
endif
uint16_t
GetErrorArgCount
(
const
ErrNum
aErrorNumber
)
;
namespace
binding_detail
{
void
ThrowErrorMessage
(
JSContext
*
aCx
const
unsigned
aErrorNumber
.
.
.
)
;
}
template
<
typename
.
.
.
Ts
>
inline
bool
ThrowErrorMessage
(
JSContext
*
aCx
const
ErrNum
aErrorNumber
Ts
&
&
.
.
.
aArgs
)
{
binding_detail
:
:
ThrowErrorMessage
(
aCx
static_cast
<
unsigned
>
(
aErrorNumber
)
std
:
:
forward
<
Ts
>
(
aArgs
)
.
.
.
)
;
return
false
;
}
struct
StringArrayAppender
{
static
void
Append
(
nsTArray
<
nsString
>
&
aArgs
uint16_t
aCount
)
{
MOZ_RELEASE_ASSERT
(
aCount
=
=
0
"
Must
give
at
least
as
many
string
arguments
as
are
required
by
the
ErrNum
.
"
)
;
}
template
<
typename
.
.
.
Ts
>
static
void
Append
(
nsTArray
<
nsString
>
&
aArgs
uint16_t
aCount
const
nsAString
&
aFirst
Ts
&
&
.
.
.
aOtherArgs
)
{
if
(
aCount
=
=
0
)
{
MOZ_ASSERT
(
false
"
There
should
not
be
more
string
arguments
provided
than
are
required
by
the
ErrNum
.
"
)
;
return
;
}
aArgs
.
AppendElement
(
aFirst
)
;
Append
(
aArgs
aCount
-
1
std
:
:
forward
<
Ts
>
(
aOtherArgs
)
.
.
.
)
;
}
}
;
}
class
ErrorResult
;
class
OOMReporter
;
namespace
binding_danger
{
template
<
typename
CleanupPolicy
>
class
TErrorResult
{
public
:
TErrorResult
(
)
:
mResult
(
NS_OK
)
#
ifdef
DEBUG
mMightHaveUnreportedJSException
(
false
)
mUnionState
(
HasNothing
)
#
endif
{
}
~
TErrorResult
(
)
{
AssertInOwningThread
(
)
;
if
(
CleanupPolicy
:
:
assertHandled
)
{
AssertReportedOrSuppressed
(
)
;
}
if
(
CleanupPolicy
:
:
suppress
)
{
SuppressException
(
)
;
}
AssertReportedOrSuppressed
(
)
;
}
TErrorResult
(
TErrorResult
&
&
aRHS
)
:
TErrorResult
(
)
{
*
this
=
std
:
:
move
(
aRHS
)
;
}
TErrorResult
&
operator
=
(
TErrorResult
&
&
aRHS
)
;
explicit
TErrorResult
(
nsresult
aRv
)
:
TErrorResult
(
)
{
AssignErrorCode
(
aRv
)
;
}
operator
ErrorResult
&
(
)
;
operator
const
ErrorResult
&
(
)
const
;
operator
OOMReporter
&
(
)
;
void
MOZ_MUST_RETURN_FROM_CALLER
Throw
(
nsresult
rv
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
"
Please
don
'
t
try
throwing
success
"
)
;
AssignErrorCode
(
rv
)
;
}
void
ThrowWithCustomCleanup
(
nsresult
rv
)
{
Throw
(
rv
)
;
}
void
CloneTo
(
TErrorResult
&
aRv
)
const
;
void
SuppressException
(
)
;
nsresult
StealNSResult
(
)
{
nsresult
rv
=
ErrorCode
(
)
;
SuppressException
(
)
;
if
(
rv
=
=
NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR
|
|
rv
=
=
NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR
|
|
rv
=
=
NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION
|
|
rv
=
=
NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
return
rv
;
}
MOZ_MUST_USE
bool
MaybeSetPendingException
(
JSContext
*
cx
)
{
WouldReportJSException
(
)
;
if
(
!
Failed
(
)
)
{
return
false
;
}
SetPendingException
(
cx
)
;
return
true
;
}
void
StealExceptionFromJSContext
(
JSContext
*
cx
)
;
template
<
dom
:
:
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
ThrowTypeError
(
Ts
&
&
.
.
.
messageArgs
)
{
ThrowErrorWithMessage
<
errorNumber
>
(
NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR
std
:
:
forward
<
Ts
>
(
messageArgs
)
.
.
.
)
;
}
template
<
dom
:
:
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
ThrowRangeError
(
Ts
&
&
.
.
.
messageArgs
)
{
ThrowErrorWithMessage
<
errorNumber
>
(
NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR
std
:
:
forward
<
Ts
>
(
messageArgs
)
.
.
.
)
;
}
bool
IsErrorWithMessage
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR
|
|
ErrorCode
(
)
=
=
NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR
;
}
void
ThrowJSException
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
exn
)
;
bool
IsJSException
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION
;
}
void
ThrowDOMException
(
nsresult
rv
const
nsACString
&
message
=
EmptyCString
(
)
)
;
bool
IsDOMException
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION
;
}
void
NoteJSContextException
(
JSContext
*
aCx
)
;
bool
IsJSContextException
(
)
{
return
ErrorCode
(
)
=
=
NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT
;
}
void
MOZ_MUST_RETURN_FROM_CALLER
ThrowUncatchableException
(
)
{
Throw
(
NS_ERROR_UNCATCHABLE_EXCEPTION
)
;
}
bool
IsUncatchableException
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_UNCATCHABLE_EXCEPTION
;
}
void
MOZ_ALWAYS_INLINE
MightThrowJSException
(
)
{
#
ifdef
DEBUG
mMightHaveUnreportedJSException
=
true
;
#
endif
}
void
MOZ_ALWAYS_INLINE
WouldReportJSException
(
)
{
#
ifdef
DEBUG
mMightHaveUnreportedJSException
=
false
;
#
endif
}
void
operator
=
(
nsresult
rv
)
{
AssignErrorCode
(
rv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mResult
)
;
}
bool
ErrorCodeIs
(
nsresult
rv
)
const
{
return
mResult
=
=
rv
;
}
uint32_t
ErrorCodeAsInt
(
)
const
{
return
static_cast
<
uint32_t
>
(
ErrorCode
(
)
)
;
}
bool
operator
=
=
(
const
ErrorResult
&
aRight
)
const
;
protected
:
nsresult
ErrorCode
(
)
const
{
return
mResult
;
}
private
:
#
ifdef
DEBUG
enum
UnionState
{
HasMessage
HasDOMExceptionInfo
HasJSException
HasNothing
}
;
#
endif
friend
struct
IPC
:
:
ParamTraits
<
TErrorResult
>
;
friend
struct
IPC
:
:
ParamTraits
<
ErrorResult
>
;
void
SerializeMessage
(
IPC
:
:
Message
*
aMsg
)
const
;
bool
DeserializeMessage
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
)
;
void
SerializeDOMExceptionInfo
(
IPC
:
:
Message
*
aMsg
)
const
;
bool
DeserializeDOMExceptionInfo
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
)
;
nsTArray
<
nsString
>
&
CreateErrorMessageHelper
(
const
dom
:
:
ErrNum
errorNumber
nsresult
errorType
)
;
template
<
dom
:
:
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
ThrowErrorWithMessage
(
nsresult
errorType
Ts
&
&
.
.
.
messageArgs
)
{
#
if
defined
(
DEBUG
)
&
&
(
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
)
static_assert
(
dom
:
:
ErrorFormatNumArgs
[
errorNumber
]
=
=
sizeof
.
.
.
(
messageArgs
)
"
Pass
in
the
right
number
of
arguments
"
)
;
#
endif
ClearUnionData
(
)
;
nsTArray
<
nsString
>
&
messageArgsArray
=
CreateErrorMessageHelper
(
errorNumber
errorType
)
;
uint16_t
argCount
=
dom
:
:
GetErrorArgCount
(
errorNumber
)
;
dom
:
:
StringArrayAppender
:
:
Append
(
messageArgsArray
argCount
std
:
:
forward
<
Ts
>
(
messageArgs
)
.
.
.
)
;
#
ifdef
DEBUG
mUnionState
=
HasMessage
;
#
endif
}
MOZ_ALWAYS_INLINE
void
AssertInOwningThread
(
)
const
{
#
ifdef
DEBUG
if
(
CleanupPolicy
:
:
assertSameThread
)
{
NS_ASSERT_OWNINGTHREAD
(
TErrorResult
)
;
}
#
endif
}
void
AssignErrorCode
(
nsresult
aRv
)
{
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR
"
Use
ThrowTypeError
(
)
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_INTERNAL_ERRORRESULT_RANGEERROR
"
Use
ThrowRangeError
(
)
"
)
;
MOZ_ASSERT
(
!
IsErrorWithMessage
(
)
"
Don
'
t
overwrite
errors
with
message
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_INTERNAL_ERRORRESULT_JS_EXCEPTION
"
Use
ThrowJSException
(
)
"
)
;
MOZ_ASSERT
(
!
IsJSException
(
)
"
Don
'
t
overwrite
JS
exceptions
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_INTERNAL_ERRORRESULT_DOMEXCEPTION
"
Use
ThrowDOMException
(
)
"
)
;
MOZ_ASSERT
(
!
IsDOMException
(
)
"
Don
'
t
overwrite
DOM
exceptions
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_XPC_NOT_ENOUGH_ARGS
"
May
need
to
bring
back
ThrowNotEnoughArgsError
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_INTERNAL_ERRORRESULT_EXCEPTION_ON_JSCONTEXT
"
Use
NoteJSContextException
"
)
;
mResult
=
aRv
;
}
void
ClearMessage
(
)
;
void
ClearDOMExceptionInfo
(
)
;
void
ClearUnionData
(
)
;
void
SetPendingException
(
JSContext
*
cx
)
;
void
SetPendingExceptionWithMessage
(
JSContext
*
cx
)
;
void
SetPendingJSException
(
JSContext
*
cx
)
;
void
SetPendingDOMException
(
JSContext
*
cx
)
;
void
SetPendingGenericErrorException
(
JSContext
*
cx
)
;
MOZ_ALWAYS_INLINE
void
AssertReportedOrSuppressed
(
)
{
MOZ_ASSERT
(
!
Failed
(
)
)
;
MOZ_ASSERT
(
!
mMightHaveUnreportedJSException
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasNothing
)
;
}
nsresult
mResult
;
struct
Message
;
struct
DOMExceptionInfo
;
union
Extra
{
Message
*
mMessage
;
JS
:
:
Value
mJSException
;
DOMExceptionInfo
*
mDOMExceptionInfo
;
MOZ_PUSH_DISABLE_NONTRIVIAL_UNION_WARNINGS
Extra
(
)
:
mMessage
(
nullptr
)
{
}
MOZ_POP_DISABLE_NONTRIVIAL_UNION_WARNINGS
}
mExtra
;
Message
*
InitMessage
(
Message
*
aMessage
)
{
new
(
&
mExtra
.
mMessage
)
Message
*
(
aMessage
)
;
return
mExtra
.
mMessage
;
}
JS
:
:
Value
&
InitJSException
(
)
{
new
(
&
mExtra
.
mJSException
)
JS
:
:
Value
(
)
;
return
mExtra
.
mJSException
;
}
DOMExceptionInfo
*
InitDOMExceptionInfo
(
DOMExceptionInfo
*
aDOMExceptionInfo
)
{
new
(
&
mExtra
.
mDOMExceptionInfo
)
DOMExceptionInfo
*
(
aDOMExceptionInfo
)
;
return
mExtra
.
mDOMExceptionInfo
;
}
#
ifdef
DEBUG
bool
mMightHaveUnreportedJSException
;
UnionState
mUnionState
;
NS_DECL_OWNINGTHREAD
;
#
endif
TErrorResult
(
const
TErrorResult
&
)
=
delete
;
void
operator
=
(
const
TErrorResult
&
)
=
delete
;
}
JS_HAZ_ROOTED
;
struct
JustAssertCleanupPolicy
{
static
const
bool
assertHandled
=
true
;
static
const
bool
suppress
=
false
;
static
const
bool
assertSameThread
=
true
;
}
;
struct
AssertAndSuppressCleanupPolicy
{
static
const
bool
assertHandled
=
true
;
static
const
bool
suppress
=
true
;
static
const
bool
assertSameThread
=
true
;
}
;
struct
JustSuppressCleanupPolicy
{
static
const
bool
assertHandled
=
false
;
static
const
bool
suppress
=
true
;
static
const
bool
assertSameThread
=
true
;
}
;
struct
ThreadSafeJustSuppressCleanupPolicy
{
static
const
bool
assertHandled
=
false
;
static
const
bool
suppress
=
true
;
static
const
bool
assertSameThread
=
false
;
}
;
}
class
ErrorResult
:
public
binding_danger
:
:
TErrorResult
<
binding_danger
:
:
AssertAndSuppressCleanupPolicy
>
{
typedef
binding_danger
:
:
TErrorResult
<
binding_danger
:
:
AssertAndSuppressCleanupPolicy
>
BaseErrorResult
;
public
:
ErrorResult
(
)
:
BaseErrorResult
(
)
{
}
ErrorResult
(
ErrorResult
&
&
aRHS
)
:
BaseErrorResult
(
std
:
:
move
(
aRHS
)
)
{
}
explicit
ErrorResult
(
nsresult
aRv
)
:
BaseErrorResult
(
aRv
)
{
}
void
operator
=
(
nsresult
rv
)
{
BaseErrorResult
:
:
operator
=
(
rv
)
;
}
ErrorResult
&
operator
=
(
ErrorResult
&
&
aRHS
)
{
BaseErrorResult
:
:
operator
=
(
std
:
:
move
(
aRHS
)
)
;
return
*
this
;
}
private
:
ErrorResult
(
const
ErrorResult
&
)
=
delete
;
void
operator
=
(
const
ErrorResult
&
)
=
delete
;
}
;
template
<
typename
CleanupPolicy
>
binding_danger
:
:
TErrorResult
<
CleanupPolicy
>
:
:
operator
ErrorResult
&
(
)
{
return
*
static_cast
<
ErrorResult
*
>
(
reinterpret_cast
<
TErrorResult
<
AssertAndSuppressCleanupPolicy
>
*
>
(
this
)
)
;
}
template
<
typename
CleanupPolicy
>
binding_danger
:
:
TErrorResult
<
CleanupPolicy
>
:
:
operator
const
ErrorResult
&
(
)
const
{
return
*
static_cast
<
const
ErrorResult
*
>
(
reinterpret_cast
<
const
TErrorResult
<
AssertAndSuppressCleanupPolicy
>
*
>
(
this
)
)
;
}
class
IgnoredErrorResult
:
public
binding_danger
:
:
TErrorResult
<
binding_danger
:
:
JustSuppressCleanupPolicy
>
{
}
;
class
CopyableErrorResult
:
public
binding_danger
:
:
TErrorResult
<
binding_danger
:
:
ThreadSafeJustSuppressCleanupPolicy
>
{
typedef
binding_danger
:
:
TErrorResult
<
binding_danger
:
:
ThreadSafeJustSuppressCleanupPolicy
>
BaseErrorResult
;
public
:
CopyableErrorResult
(
)
:
BaseErrorResult
(
)
{
}
explicit
CopyableErrorResult
(
const
ErrorResult
&
aRight
)
:
BaseErrorResult
(
)
{
auto
val
=
reinterpret_cast
<
const
CopyableErrorResult
&
>
(
aRight
)
;
operator
=
(
val
)
;
}
CopyableErrorResult
(
CopyableErrorResult
&
&
aRHS
)
:
BaseErrorResult
(
std
:
:
move
(
aRHS
)
)
{
}
explicit
CopyableErrorResult
(
nsresult
aRv
)
:
BaseErrorResult
(
aRv
)
{
}
void
operator
=
(
nsresult
rv
)
{
BaseErrorResult
:
:
operator
=
(
rv
)
;
}
CopyableErrorResult
&
operator
=
(
CopyableErrorResult
&
&
aRHS
)
{
BaseErrorResult
:
:
operator
=
(
std
:
:
move
(
aRHS
)
)
;
return
*
this
;
}
CopyableErrorResult
(
const
CopyableErrorResult
&
aRight
)
:
BaseErrorResult
(
)
{
operator
=
(
aRight
)
;
}
CopyableErrorResult
&
operator
=
(
const
CopyableErrorResult
&
aRight
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsJSException
(
)
"
Attempt
to
copy
to
ErrorResult
with
a
JS
exception
value
.
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aRight
.
IsJSException
(
)
"
Attempt
to
copy
from
ErrorResult
with
a
JS
exception
value
.
"
)
;
if
(
aRight
.
IsJSException
(
)
)
{
SuppressException
(
)
;
Throw
(
NS_ERROR_FAILURE
)
;
}
else
{
aRight
.
CloneTo
(
*
this
)
;
}
return
*
this
;
}
}
;
namespace
dom
{
namespace
binding_detail
{
class
FastErrorResult
:
public
mozilla
:
:
binding_danger
:
:
TErrorResult
<
mozilla
:
:
binding_danger
:
:
JustAssertCleanupPolicy
>
{
}
;
}
}
namespace
binding_danger
{
class
OOMReporterInstantiator
;
}
class
OOMReporter
:
private
dom
:
:
binding_detail
:
:
FastErrorResult
{
public
:
void
ReportOOM
(
)
{
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
private
:
friend
class
binding_danger
:
:
OOMReporterInstantiator
;
template
<
typename
CleanupPolicy
>
friend
class
binding_danger
:
:
TErrorResult
;
OOMReporter
(
)
:
dom
:
:
binding_detail
:
:
FastErrorResult
(
)
{
}
}
;
namespace
binding_danger
{
class
OOMReporterInstantiator
:
public
OOMReporter
{
public
:
OOMReporterInstantiator
(
)
:
OOMReporter
(
)
{
}
bool
MaybeSetPendingException
(
JSContext
*
cx
)
{
return
OOMReporter
:
:
MaybeSetPendingException
(
cx
)
;
}
}
;
}
template
<
typename
CleanupPolicy
>
binding_danger
:
:
TErrorResult
<
CleanupPolicy
>
:
:
operator
OOMReporter
&
(
)
{
return
*
static_cast
<
OOMReporter
*
>
(
reinterpret_cast
<
TErrorResult
<
JustAssertCleanupPolicy
>
*
>
(
this
)
)
;
}
class
MOZ_TEMPORARY_CLASS
IgnoreErrors
{
public
:
operator
ErrorResult
&
(
)
&
&
{
return
mInner
;
}
operator
OOMReporter
&
(
)
&
&
{
return
mInner
;
}
private
:
binding_danger
:
:
TErrorResult
<
binding_danger
:
:
JustSuppressCleanupPolicy
>
mInner
;
}
JS_HAZ_ROOTED
;
#
define
ENSURE_SUCCESS
(
res
ret
)
\
do
{
\
if
(
res
.
Failed
(
)
)
{
\
nsCString
msg
;
\
msg
.
AppendPrintf
(
"
ENSURE_SUCCESS
(
%
s
%
s
)
failed
with
"
\
"
result
0x
%
X
"
#
res
#
ret
res
.
ErrorCodeAsInt
(
)
)
;
\
NS_WARNING
(
msg
.
get
(
)
)
;
\
return
ret
;
\
}
\
}
while
(
0
)
#
define
ENSURE_SUCCESS_VOID
(
res
)
\
do
{
\
if
(
res
.
Failed
(
)
)
{
\
nsCString
msg
;
\
msg
.
AppendPrintf
(
"
ENSURE_SUCCESS_VOID
(
%
s
)
failed
with
"
\
"
result
0x
%
X
"
#
res
res
.
ErrorCodeAsInt
(
)
)
;
\
NS_WARNING
(
msg
.
get
(
)
)
;
\
return
;
\
}
\
}
while
(
0
)
}
#
endif
