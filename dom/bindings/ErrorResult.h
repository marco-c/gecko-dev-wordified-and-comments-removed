#
ifndef
mozilla_ErrorResult_h
#
define
mozilla_ErrorResult_h
#
include
<
stdarg
.
h
>
#
include
"
js
/
Value
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsStringGlue
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsTArray
.
h
"
namespace
IPC
{
class
Message
;
template
<
typename
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
dom
{
enum
ErrNum
{
#
define
MSG_DEF
(
_name
_argc
_exn
_str
)
\
_name
#
include
"
mozilla
/
dom
/
Errors
.
msg
"
#
undef
MSG_DEF
Err_Limit
}
;
#
if
defined
(
DEBUG
)
&
&
(
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
)
uint16_t
constexpr
ErrorFormatNumArgs
[
]
=
{
#
define
MSG_DEF
(
_name
_argc
_exn
_str
)
\
_argc
#
include
"
mozilla
/
dom
/
Errors
.
msg
"
#
undef
MSG_DEF
}
;
#
endif
uint16_t
GetErrorArgCount
(
const
ErrNum
aErrorNumber
)
;
bool
ThrowErrorMessage
(
JSContext
*
aCx
const
ErrNum
aErrorNumber
.
.
.
)
;
struct
StringArrayAppender
{
static
void
Append
(
nsTArray
<
nsString
>
&
aArgs
uint16_t
aCount
)
{
MOZ_RELEASE_ASSERT
(
aCount
=
=
0
"
Must
give
at
least
as
many
string
arguments
as
are
required
by
the
ErrNum
.
"
)
;
}
template
<
typename
.
.
.
Ts
>
static
void
Append
(
nsTArray
<
nsString
>
&
aArgs
uint16_t
aCount
const
nsAString
*
aFirst
Ts
.
.
.
aOtherArgs
)
{
if
(
aCount
=
=
0
)
{
MOZ_ASSERT
(
false
"
There
should
not
be
more
string
arguments
provided
than
are
required
by
the
ErrNum
.
"
)
;
return
;
}
aArgs
.
AppendElement
(
*
aFirst
)
;
Append
(
aArgs
aCount
-
1
aOtherArgs
.
.
.
)
;
}
}
;
}
class
ErrorResult
{
public
:
ErrorResult
(
)
:
mResult
(
NS_OK
)
#
ifdef
DEBUG
mMightHaveUnreportedJSException
(
false
)
mUnionState
(
HasNothing
)
#
endif
{
}
#
ifdef
DEBUG
~
ErrorResult
(
)
{
MOZ_ASSERT_IF
(
IsErrorWithMessage
(
)
!
mMessage
)
;
MOZ_ASSERT_IF
(
IsDOMException
(
)
!
mDOMExceptionInfo
)
;
MOZ_ASSERT
(
!
mMightHaveUnreportedJSException
)
;
MOZ_ASSERT
(
mUnionState
=
=
HasNothing
)
;
}
#
endif
ErrorResult
(
ErrorResult
&
&
aRHS
)
:
ErrorResult
(
)
{
*
this
=
Move
(
aRHS
)
;
}
ErrorResult
&
operator
=
(
ErrorResult
&
&
aRHS
)
;
explicit
ErrorResult
(
nsresult
aRv
)
:
ErrorResult
(
)
{
AssignErrorCode
(
aRv
)
;
}
void
Throw
(
nsresult
rv
)
{
MOZ_ASSERT
(
NS_FAILED
(
rv
)
"
Please
don
'
t
try
throwing
success
"
)
;
AssignErrorCode
(
rv
)
;
}
void
SuppressException
(
)
;
nsresult
StealNSResult
(
)
{
nsresult
rv
=
ErrorCode
(
)
;
SuppressException
(
)
;
return
rv
;
}
template
<
dom
:
:
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
ThrowTypeError
(
Ts
.
.
.
messageArgs
)
{
ThrowErrorWithMessage
<
errorNumber
>
(
NS_ERROR_TYPE_ERR
messageArgs
.
.
.
)
;
}
template
<
dom
:
:
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
ThrowRangeError
(
Ts
.
.
.
messageArgs
)
{
ThrowErrorWithMessage
<
errorNumber
>
(
NS_ERROR_RANGE_ERR
messageArgs
.
.
.
)
;
}
void
ReportErrorWithMessage
(
JSContext
*
cx
)
;
bool
IsErrorWithMessage
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_TYPE_ERR
|
|
ErrorCode
(
)
=
=
NS_ERROR_RANGE_ERR
;
}
void
ThrowJSException
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
exn
)
;
void
ReportJSException
(
JSContext
*
cx
)
;
bool
IsJSException
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_DOM_JS_EXCEPTION
;
}
void
ThrowDOMException
(
nsresult
rv
const
nsACString
&
message
=
EmptyCString
(
)
)
;
void
ReportDOMException
(
JSContext
*
cx
)
;
bool
IsDOMException
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_DOM_DOMEXCEPTION
;
}
void
NoteJSContextException
(
)
{
mResult
=
NS_ERROR_DOM_EXCEPTION_ON_JSCONTEXT
;
}
bool
IsJSContextException
(
)
{
return
ErrorCode
(
)
=
=
NS_ERROR_DOM_EXCEPTION_ON_JSCONTEXT
;
}
void
ReportGenericError
(
JSContext
*
cx
)
;
void
ThrowUncatchableException
(
)
{
Throw
(
NS_ERROR_UNCATCHABLE_EXCEPTION
)
;
}
bool
IsUncatchableException
(
)
const
{
return
ErrorCode
(
)
=
=
NS_ERROR_UNCATCHABLE_EXCEPTION
;
}
void
StealJSException
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
value
)
;
void
MOZ_ALWAYS_INLINE
MightThrowJSException
(
)
{
#
ifdef
DEBUG
mMightHaveUnreportedJSException
=
true
;
#
endif
}
void
MOZ_ALWAYS_INLINE
WouldReportJSException
(
)
{
#
ifdef
DEBUG
mMightHaveUnreportedJSException
=
false
;
#
endif
}
void
operator
=
(
nsresult
rv
)
{
AssignErrorCode
(
rv
)
;
}
bool
Failed
(
)
const
{
return
NS_FAILED
(
mResult
)
;
}
bool
ErrorCodeIs
(
nsresult
rv
)
const
{
return
mResult
=
=
rv
;
}
uint32_t
ErrorCodeAsInt
(
)
const
{
return
static_cast
<
uint32_t
>
(
ErrorCode
(
)
)
;
}
protected
:
nsresult
ErrorCode
(
)
const
{
return
mResult
;
}
private
:
#
ifdef
DEBUG
enum
UnionState
{
HasMessage
HasDOMExceptionInfo
HasJSException
HasNothing
}
;
#
endif
friend
struct
IPC
:
:
ParamTraits
<
ErrorResult
>
;
void
SerializeMessage
(
IPC
:
:
Message
*
aMsg
)
const
;
bool
DeserializeMessage
(
const
IPC
:
:
Message
*
aMsg
void
*
*
aIter
)
;
void
SerializeDOMExceptionInfo
(
IPC
:
:
Message
*
aMsg
)
const
;
bool
DeserializeDOMExceptionInfo
(
const
IPC
:
:
Message
*
aMsg
void
*
*
aIter
)
;
nsTArray
<
nsString
>
&
CreateErrorMessageHelper
(
const
dom
:
:
ErrNum
errorNumber
nsresult
errorType
)
;
template
<
dom
:
:
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
ThrowErrorWithMessage
(
nsresult
errorType
Ts
.
.
.
messageArgs
)
{
#
if
defined
(
DEBUG
)
&
&
(
defined
(
__clang__
)
|
|
defined
(
__GNUC__
)
)
static_assert
(
dom
:
:
ErrorFormatNumArgs
[
errorNumber
]
=
=
sizeof
.
.
.
(
messageArgs
)
"
Pass
in
the
right
number
of
arguments
"
)
;
#
endif
ClearUnionData
(
)
;
nsTArray
<
nsString
>
&
messageArgsArray
=
CreateErrorMessageHelper
(
errorNumber
errorType
)
;
uint16_t
argCount
=
dom
:
:
GetErrorArgCount
(
errorNumber
)
;
dom
:
:
StringArrayAppender
:
:
Append
(
messageArgsArray
argCount
messageArgs
.
.
.
)
;
#
ifdef
DEBUG
mUnionState
=
HasMessage
;
#
endif
}
void
AssignErrorCode
(
nsresult
aRv
)
{
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_TYPE_ERR
"
Use
ThrowTypeError
(
)
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_RANGE_ERR
"
Use
ThrowRangeError
(
)
"
)
;
MOZ_ASSERT
(
!
IsErrorWithMessage
(
)
"
Don
'
t
overwrite
errors
with
message
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_DOM_JS_EXCEPTION
"
Use
ThrowJSException
(
)
"
)
;
MOZ_ASSERT
(
!
IsJSException
(
)
"
Don
'
t
overwrite
JS
exceptions
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_DOM_DOMEXCEPTION
"
Use
ThrowDOMException
(
)
"
)
;
MOZ_ASSERT
(
!
IsDOMException
(
)
"
Don
'
t
overwrite
DOM
exceptions
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_XPC_NOT_ENOUGH_ARGS
"
May
need
to
bring
back
ThrowNotEnoughArgsError
"
)
;
MOZ_ASSERT
(
aRv
!
=
NS_ERROR_DOM_EXCEPTION_ON_JSCONTEXT
"
Use
NoteJSContextException
"
)
;
mResult
=
aRv
;
}
void
ClearMessage
(
)
;
void
ClearDOMExceptionInfo
(
)
;
void
ClearUnionData
(
)
;
nsresult
mResult
;
struct
Message
;
struct
DOMExceptionInfo
;
union
{
Message
*
mMessage
;
JS
:
:
Value
mJSException
;
DOMExceptionInfo
*
mDOMExceptionInfo
;
}
;
#
ifdef
DEBUG
bool
mMightHaveUnreportedJSException
;
UnionState
mUnionState
;
#
endif
ErrorResult
(
const
ErrorResult
&
)
=
delete
;
void
operator
=
(
const
ErrorResult
&
)
=
delete
;
}
;
#
define
ENSURE_SUCCESS
(
res
ret
)
\
do
{
\
if
(
res
.
Failed
(
)
)
{
\
nsCString
msg
;
\
msg
.
AppendPrintf
(
"
ENSURE_SUCCESS
(
%
s
%
s
)
failed
with
"
\
"
result
0x
%
X
"
#
res
#
ret
res
.
ErrorCodeAsInt
(
)
)
;
\
NS_WARNING
(
msg
.
get
(
)
)
;
\
return
ret
;
\
}
\
}
while
(
0
)
#
define
ENSURE_SUCCESS_VOID
(
res
)
\
do
{
\
if
(
res
.
Failed
(
)
)
{
\
nsCString
msg
;
\
msg
.
AppendPrintf
(
"
ENSURE_SUCCESS_VOID
(
%
s
)
failed
with
"
\
"
result
0x
%
X
"
#
res
res
.
ErrorCodeAsInt
(
)
)
;
\
NS_WARNING
(
msg
.
get
(
)
)
;
\
return
;
\
}
\
}
while
(
0
)
}
#
endif
