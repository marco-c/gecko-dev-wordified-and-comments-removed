#
ifndef
mozilla_dom_FakeString_h__
#
define
mozilla_dom_FakeString_h__
#
include
"
nsString
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
binding_detail
{
struct
FakeString
{
FakeString
(
)
:
mDataFlags
(
nsString
:
:
DataFlags
:
:
TERMINATED
)
mClassFlags
(
nsString
:
:
ClassFlags
(
0
)
)
{
}
~
FakeString
(
)
{
if
(
mDataFlags
&
nsString
:
:
DataFlags
:
:
REFCOUNTED
)
{
MOZ_ASSERT
(
mDataInitialized
)
;
nsStringBuffer
:
:
FromData
(
mData
)
-
>
Release
(
)
;
}
}
void
ShareOrDependUpon
(
const
nsAString
&
aString
)
{
RefPtr
<
nsStringBuffer
>
sharedBuffer
=
nsStringBuffer
:
:
FromString
(
aString
)
;
if
(
!
sharedBuffer
)
{
InitData
(
aString
.
BeginReading
(
)
aString
.
Length
(
)
)
;
if
(
!
aString
.
IsTerminated
(
)
)
{
mDataFlags
&
=
~
nsString
:
:
DataFlags
:
:
TERMINATED
;
}
}
else
{
AssignFromStringBuffer
(
sharedBuffer
.
forget
(
)
aString
.
Length
(
)
)
;
}
}
void
Truncate
(
)
{
InitData
(
nsString
:
:
char_traits
:
:
sEmptyBuffer
0
)
;
}
void
SetIsVoid
(
bool
aValue
)
{
MOZ_ASSERT
(
aValue
"
We
don
'
t
support
SetIsVoid
(
false
)
on
FakeString
!
"
)
;
Truncate
(
)
;
mDataFlags
|
=
nsString
:
:
DataFlags
:
:
VOIDED
;
}
nsString
:
:
char_type
*
BeginWriting
(
)
{
MOZ_ASSERT
(
IsMutable
(
)
)
;
MOZ_ASSERT
(
mDataInitialized
)
;
return
mData
;
}
nsString
:
:
size_type
Length
(
)
const
{
return
mLength
;
}
operator
mozilla
:
:
Span
<
const
nsString
:
:
char_type
>
(
)
const
{
MOZ_ASSERT
(
mDataInitialized
)
;
return
mozilla
:
:
MakeSpan
(
mData
Length
(
)
)
;
}
operator
mozilla
:
:
Span
<
nsString
:
:
char_type
>
(
)
{
return
mozilla
:
:
MakeSpan
(
BeginWriting
(
)
Length
(
)
)
;
}
bool
SetLength
(
nsString
:
:
size_type
aLength
mozilla
:
:
fallible_t
const
&
)
{
if
(
aLength
<
sInlineCapacity
)
{
InitData
(
mInlineStorage
aLength
)
;
mDataFlags
|
=
nsString
:
:
DataFlags
:
:
INLINE
;
}
else
{
RefPtr
<
nsStringBuffer
>
buf
=
nsStringBuffer
:
:
Alloc
(
(
aLength
+
1
)
*
sizeof
(
nsString
:
:
char_type
)
)
;
if
(
MOZ_UNLIKELY
(
!
buf
)
)
{
return
false
;
}
AssignFromStringBuffer
(
buf
.
forget
(
)
aLength
)
;
}
MOZ_ASSERT
(
mDataInitialized
)
;
mData
[
mLength
]
=
char16_t
(
0
)
;
return
true
;
}
bool
EnsureMutable
(
)
{
MOZ_ASSERT
(
mDataInitialized
)
;
if
(
IsMutable
(
)
)
{
return
true
;
}
RefPtr
<
nsStringBuffer
>
buffer
;
if
(
mDataFlags
&
nsString
:
:
DataFlags
:
:
REFCOUNTED
)
{
buffer
=
dont_AddRef
(
nsStringBuffer
:
:
FromData
(
mData
)
)
;
}
const
nsString
:
:
char_type
*
oldChars
=
mData
;
mDataFlags
=
nsString
:
:
DataFlags
:
:
TERMINATED
;
#
ifdef
DEBUG
mDataInitialized
=
false
;
#
endif
if
(
!
SetLength
(
Length
(
)
fallible
)
)
{
return
false
;
}
MOZ_ASSERT
(
oldChars
!
=
mData
"
Should
have
new
chars
now
!
"
)
;
MOZ_ASSERT
(
IsMutable
(
)
"
Why
are
we
still
not
mutable
?
"
)
;
memcpy
(
mData
oldChars
Length
(
)
*
sizeof
(
nsString
:
:
char_type
)
)
;
return
true
;
}
void
AssignFromStringBuffer
(
already_AddRefed
<
nsStringBuffer
>
aBuffer
size_t
aLength
)
{
InitData
(
static_cast
<
nsString
:
:
char_type
*
>
(
aBuffer
.
take
(
)
-
>
Data
(
)
)
aLength
)
;
mDataFlags
|
=
nsString
:
:
DataFlags
:
:
REFCOUNTED
;
}
template
<
int
N
>
void
AssignLiteral
(
const
nsString
:
:
char_type
(
&
aData
)
[
N
]
)
{
AssignLiteral
(
aData
N
-
1
)
;
}
void
AssignLiteral
(
const
nsString
:
:
char_type
*
aData
size_t
aLength
)
{
InitData
(
aData
aLength
)
;
mDataFlags
|
=
nsString
:
:
DataFlags
:
:
LITERAL
;
}
const
nsAString
*
ToAStringPtr
(
)
const
{
return
reinterpret_cast
<
const
nsString
*
>
(
this
)
;
}
operator
const
nsAString
&
(
)
const
{
return
*
reinterpret_cast
<
const
nsString
*
>
(
this
)
;
}
private
:
nsAString
*
ToAStringPtr
(
)
{
return
reinterpret_cast
<
nsString
*
>
(
this
)
;
}
MOZ_INIT_OUTSIDE_CTOR
nsString
:
:
char_type
*
mData
;
MOZ_INIT_OUTSIDE_CTOR
nsString
:
:
size_type
mLength
;
nsString
:
:
DataFlags
mDataFlags
;
nsString
:
:
ClassFlags
mClassFlags
;
static
const
size_t
sInlineCapacity
=
64
;
nsString
:
:
char_type
mInlineStorage
[
sInlineCapacity
]
;
#
ifdef
DEBUG
bool
mDataInitialized
=
false
;
#
endif
FakeString
(
const
FakeString
&
other
)
=
delete
;
void
operator
=
(
const
FakeString
&
other
)
=
delete
;
void
InitData
(
const
nsString
:
:
char_type
*
aData
nsString
:
:
size_type
aLength
)
{
MOZ_ASSERT
(
mDataFlags
=
=
nsString
:
:
DataFlags
:
:
TERMINATED
)
;
MOZ_ASSERT
(
!
mDataInitialized
)
;
mData
=
const_cast
<
nsString
:
:
char_type
*
>
(
aData
)
;
mLength
=
aLength
;
#
ifdef
DEBUG
mDataInitialized
=
true
;
#
endif
}
bool
IsMutable
(
)
{
return
(
mDataFlags
&
nsString
:
:
DataFlags
:
:
INLINE
)
|
|
(
(
mDataFlags
&
nsString
:
:
DataFlags
:
:
REFCOUNTED
)
&
&
!
nsStringBuffer
:
:
FromData
(
mData
)
-
>
IsReadonly
(
)
)
;
}
friend
class
NonNull
<
nsAString
>
;
class
StringAsserter
;
friend
class
StringAsserter
;
class
StringAsserter
:
public
nsString
{
public
:
static
void
StaticAsserts
(
)
{
static_assert
(
offsetof
(
FakeString
mInlineStorage
)
=
=
sizeof
(
nsString
)
"
FakeString
should
include
all
nsString
members
"
)
;
static_assert
(
offsetof
(
FakeString
mData
)
=
=
offsetof
(
StringAsserter
mData
)
"
Offset
of
mData
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mLength
)
=
=
offsetof
(
StringAsserter
mLength
)
"
Offset
of
mLength
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mDataFlags
)
=
=
offsetof
(
StringAsserter
mDataFlags
)
"
Offset
of
mDataFlags
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mClassFlags
)
=
=
offsetof
(
StringAsserter
mClassFlags
)
"
Offset
of
mClassFlags
should
match
"
)
;
}
}
;
}
;
}
}
}
inline
void
AssignFromStringBuffer
(
nsStringBuffer
*
aBuffer
size_t
aLength
mozilla
:
:
dom
:
:
binding_detail
:
:
FakeString
&
aDest
)
{
aDest
.
AssignFromStringBuffer
(
do_AddRef
(
aBuffer
)
aLength
)
;
}
#
endif
