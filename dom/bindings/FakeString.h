#
ifndef
mozilla_dom_FakeString_h__
#
define
mozilla_dom_FakeString_h__
#
include
"
js
/
String
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
StringBuffer
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTStringRepr
.
h
"
namespace
mozilla
:
:
dom
:
:
binding_detail
{
template
<
typename
CharT
>
struct
MOZ_GSL_OWNER
FakeString
{
using
char_type
=
CharT
;
using
string_type
=
nsTString
<
CharT
>
;
using
size_type
=
typename
string_type
:
:
size_type
;
using
DataFlags
=
typename
string_type
:
:
DataFlags
;
using
ClassFlags
=
typename
string_type
:
:
ClassFlags
;
using
AString
=
nsTSubstring
<
CharT
>
;
using
LengthStorage
=
mozilla
:
:
detail
:
:
nsTStringLengthStorage
<
CharT
>
;
static
const
size_t
kInlineCapacity
=
64
;
using
AutoString
=
nsTAutoStringN
<
CharT
kInlineCapacity
>
;
FakeString
(
)
:
mDataFlags
(
DataFlags
:
:
TERMINATED
)
mClassFlags
(
ClassFlags
:
:
INLINE
)
mInlineCapacity
(
kInlineCapacity
-
1
)
{
}
~
FakeString
(
)
{
if
(
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
{
MOZ_ASSERT
(
mDataInitialized
)
;
StringBuffer
:
:
FromData
(
mData
)
-
>
Release
(
)
;
}
}
void
ShareOrDependUpon
(
const
AString
&
aString
)
{
RefPtr
<
StringBuffer
>
sharedBuffer
=
aString
.
GetStringBuffer
(
)
;
if
(
!
sharedBuffer
)
{
InitData
(
aString
.
BeginReading
(
)
aString
.
Length
(
)
)
;
if
(
!
aString
.
IsTerminated
(
)
)
{
mDataFlags
&
=
~
DataFlags
:
:
TERMINATED
;
}
}
else
{
AssignFromStringBuffer
(
sharedBuffer
.
forget
(
)
aString
.
Length
(
)
)
;
}
}
void
Truncate
(
)
{
InitData
(
string_type
:
:
char_traits
:
:
sEmptyBuffer
0
)
;
}
void
SetIsVoid
(
bool
aValue
)
{
MOZ_ASSERT
(
aValue
"
We
don
'
t
support
SetIsVoid
(
false
)
on
FakeString
!
"
)
;
Truncate
(
)
;
mDataFlags
|
=
DataFlags
:
:
VOIDED
;
}
char_type
*
BeginWriting
(
)
{
MOZ_ASSERT
(
IsMutable
(
)
)
;
MOZ_ASSERT
(
mDataInitialized
)
;
return
mData
;
}
size_type
Length
(
)
const
{
return
mLength
;
}
operator
mozilla
:
:
Span
<
const
char_type
>
(
)
const
{
MOZ_ASSERT
(
mDataInitialized
)
;
return
mozilla
:
:
Span
<
const
char_type
>
{
mData
Length
(
)
}
;
}
mozilla
:
:
Result
<
mozilla
:
:
BulkWriteHandle
<
CharT
>
nsresult
>
BulkWrite
(
size_type
aCapacity
size_type
aPrefixToPreserve
bool
aAllowShrinking
)
{
MOZ_ASSERT
(
!
mDataInitialized
)
;
InitData
(
mStorage
0
)
;
mDataFlags
|
=
DataFlags
:
:
INLINE
;
return
ToAStringPtr
(
)
-
>
BulkWrite
(
aCapacity
aPrefixToPreserve
aAllowShrinking
)
;
}
bool
SetLength
(
size_type
aLength
mozilla
:
:
fallible_t
const
&
)
{
if
(
aLength
<
kInlineCapacity
)
{
InitData
(
mStorage
aLength
)
;
mDataFlags
|
=
DataFlags
:
:
INLINE
;
}
else
{
RefPtr
<
StringBuffer
>
buf
=
StringBuffer
:
:
Alloc
(
(
aLength
+
1
)
*
sizeof
(
char_type
)
)
;
if
(
MOZ_UNLIKELY
(
!
buf
)
)
{
return
false
;
}
AssignFromStringBuffer
(
buf
.
forget
(
)
aLength
)
;
}
MOZ_ASSERT
(
mDataInitialized
)
;
mData
[
mLength
]
=
char_type
(
0
)
;
return
true
;
}
bool
EnsureMutable
(
)
{
MOZ_ASSERT
(
mDataInitialized
)
;
if
(
IsMutable
(
)
)
{
return
true
;
}
RefPtr
<
StringBuffer
>
buffer
;
if
(
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
{
buffer
=
dont_AddRef
(
StringBuffer
:
:
FromData
(
mData
)
)
;
}
const
char_type
*
oldChars
=
mData
;
mDataFlags
=
DataFlags
:
:
TERMINATED
;
#
ifdef
DEBUG
mDataInitialized
=
false
;
#
endif
if
(
!
SetLength
(
Length
(
)
fallible
)
)
{
return
false
;
}
MOZ_ASSERT
(
oldChars
!
=
mData
"
Should
have
new
chars
now
!
"
)
;
MOZ_ASSERT
(
IsMutable
(
)
"
Why
are
we
still
not
mutable
?
"
)
;
memcpy
(
mData
oldChars
Length
(
)
*
sizeof
(
char_type
)
)
;
return
true
;
}
void
AssignFromStringBuffer
(
already_AddRefed
<
StringBuffer
>
aBuffer
size_t
aLength
)
{
InitData
(
static_cast
<
char_type
*
>
(
aBuffer
.
take
(
)
-
>
Data
(
)
)
aLength
)
;
mDataFlags
|
=
DataFlags
:
:
REFCOUNTED
;
}
template
<
int
N
>
void
AssignLiteral
(
const
char_type
(
&
aData
)
[
N
]
)
{
AssignLiteral
(
aData
N
-
1
)
;
}
void
AssignLiteral
(
const
char_type
*
aData
size_t
aLength
)
{
InitData
(
aData
aLength
)
;
mDataFlags
|
=
DataFlags
:
:
LITERAL
;
}
const
AString
*
ToAStringPtr
(
)
const
{
return
reinterpret_cast
<
const
string_type
*
>
(
this
)
;
}
operator
const
AString
&
(
)
const
{
return
*
ToAStringPtr
(
)
;
}
private
:
AString
*
ToAStringPtr
(
)
{
return
reinterpret_cast
<
string_type
*
>
(
this
)
;
}
MOZ_INIT_OUTSIDE_CTOR
char_type
*
mData
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
mLength
;
DataFlags
mDataFlags
;
const
ClassFlags
mClassFlags
;
const
uint32_t
mInlineCapacity
;
char_type
mStorage
[
kInlineCapacity
]
;
#
ifdef
DEBUG
bool
mDataInitialized
=
false
;
#
endif
FakeString
(
const
FakeString
&
other
)
=
delete
;
void
operator
=
(
const
FakeString
&
other
)
=
delete
;
void
InitData
(
const
char_type
*
aData
size_type
aLength
)
{
MOZ_ASSERT
(
aLength
<
=
LengthStorage
:
:
kMax
"
string
is
too
large
"
)
;
MOZ_ASSERT
(
mDataFlags
=
=
DataFlags
:
:
TERMINATED
)
;
MOZ_ASSERT
(
!
mDataInitialized
)
;
mData
=
const_cast
<
char_type
*
>
(
aData
)
;
mLength
=
uint32_t
(
aLength
)
;
#
ifdef
DEBUG
mDataInitialized
=
true
;
#
endif
}
bool
IsMutable
(
)
{
return
(
mDataFlags
&
DataFlags
:
:
INLINE
)
|
|
(
(
mDataFlags
&
DataFlags
:
:
REFCOUNTED
)
&
&
!
StringBuffer
:
:
FromData
(
mData
)
-
>
IsReadonly
(
)
)
;
}
friend
class
NonNull
<
AString
>
;
class
StringAsserter
;
friend
class
StringAsserter
;
class
StringAsserter
:
public
AutoString
{
public
:
static
void
StaticAsserts
(
)
{
static_assert
(
sizeof
(
AutoString
)
=
=
sizeof
(
FakeString
)
"
Should
be
binary
compatible
with
nsTAutoString
"
)
;
static_assert
(
offsetof
(
FakeString
mInlineCapacity
)
=
=
sizeof
(
string_type
)
"
FakeString
should
include
all
nsString
members
"
)
;
static_assert
(
offsetof
(
FakeString
mData
)
=
=
offsetof
(
StringAsserter
mData
)
"
Offset
of
mData
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mLength
)
=
=
offsetof
(
StringAsserter
mLength
)
"
Offset
of
mLength
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mDataFlags
)
=
=
offsetof
(
StringAsserter
mDataFlags
)
"
Offset
of
mDataFlags
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mClassFlags
)
=
=
offsetof
(
StringAsserter
mClassFlags
)
"
Offset
of
mClassFlags
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mInlineCapacity
)
=
=
offsetof
(
StringAsserter
mInlineCapacity
)
"
Offset
of
mInlineCapacity
should
match
"
)
;
static_assert
(
offsetof
(
FakeString
mStorage
)
=
=
offsetof
(
StringAsserter
mStorage
)
"
Offset
of
mStorage
should
match
"
)
;
static_assert
(
JS
:
:
MaxStringLength
<
=
LengthStorage
:
:
kMax
"
JS
:
:
MaxStringLength
fits
in
a
nsTString
"
)
;
}
}
;
}
;
}
namespace
mozilla
{
template
<
typename
CharT
>
inline
void
AssignFromStringBuffer
(
StringBuffer
*
aBuffer
size_t
aLength
dom
:
:
binding_detail
:
:
FakeString
<
CharT
>
&
aDest
)
{
aDest
.
AssignFromStringBuffer
(
do_AddRef
(
aBuffer
)
aLength
)
;
}
}
#
endif
