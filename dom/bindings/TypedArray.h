#
ifndef
mozilla_dom_TypedArray_h
#
define
mozilla_dom_TypedArray_h
#
include
<
utility
>
#
include
"
js
/
ArrayBuffer
.
h
"
#
include
"
js
/
ArrayBufferMaybeShared
.
h
"
#
include
"
js
/
experimental
/
TypedData
.
h
"
#
include
"
js
/
GCAPI
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
ScalarType
.
h
"
#
include
"
js
/
SharedArrayBuffer
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
SpiderMonkeyInterface
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
namespace
mozilla
{
namespace
dom
{
template
<
class
ArrayT
>
struct
TypedArray_base
:
public
SpiderMonkeyInterfaceObjectStorage
AllTypedArraysBase
{
using
element_type
=
typename
ArrayT
:
:
DataType
;
TypedArray_base
(
)
:
mData
(
nullptr
)
mLength
(
0
)
mShared
(
false
)
mComputed
(
false
)
{
}
TypedArray_base
(
TypedArray_base
&
&
aOther
)
:
SpiderMonkeyInterfaceObjectStorage
(
std
:
:
move
(
aOther
)
)
mData
(
aOther
.
mData
)
mLength
(
aOther
.
mLength
)
mShared
(
aOther
.
mShared
)
mComputed
(
aOther
.
mComputed
)
{
aOther
.
Reset
(
)
;
}
private
:
mutable
element_type
*
mData
;
mutable
uint32_t
mLength
;
mutable
bool
mShared
;
mutable
bool
mComputed
;
public
:
inline
bool
Init
(
JSObject
*
obj
)
{
MOZ_ASSERT
(
!
inited
(
)
)
;
mImplObj
=
mWrappedObj
=
ArrayT
:
:
unwrap
(
obj
)
.
asObject
(
)
;
return
inited
(
)
;
}
inline
bool
IsShared
(
)
const
{
MOZ_ASSERT
(
mComputed
)
;
return
mShared
;
}
inline
element_type
*
Data
(
)
const
{
MOZ_ASSERT
(
mComputed
)
;
return
mData
;
}
inline
element_type
*
FixedData
(
uint8_t
*
buffer
size_t
bufSize
)
const
{
MOZ_ASSERT
(
mComputed
)
;
return
JS_GetArrayBufferViewFixedData
(
mImplObj
buffer
bufSize
)
;
}
inline
uint32_t
Length
(
)
const
{
MOZ_ASSERT
(
mComputed
)
;
return
mLength
;
}
inline
void
ComputeState
(
)
const
{
MOZ_ASSERT
(
inited
(
)
)
;
MOZ_ASSERT
(
!
mComputed
)
;
size_t
length
;
JS
:
:
AutoCheckCannotGC
nogc
;
mData
=
ArrayT
:
:
fromObject
(
mImplObj
)
.
getLengthAndData
(
&
length
&
mShared
nogc
)
;
MOZ_RELEASE_ASSERT
(
length
<
=
INT32_MAX
"
Bindings
must
have
checked
ArrayBuffer
{
View
}
length
"
)
;
mLength
=
length
;
mComputed
=
true
;
}
inline
void
Reset
(
)
{
mData
=
nullptr
;
mLength
=
0
;
mShared
=
false
;
mComputed
=
false
;
}
private
:
TypedArray_base
(
const
TypedArray_base
&
)
=
delete
;
}
;
template
<
class
ArrayT
>
struct
TypedArray
:
public
TypedArray_base
<
ArrayT
>
{
using
Base
=
TypedArray_base
<
ArrayT
>
;
using
element_type
=
typename
Base
:
:
element_type
;
TypedArray
(
)
=
default
;
TypedArray
(
TypedArray
&
&
aOther
)
=
default
;
static
inline
JSObject
*
Create
(
JSContext
*
cx
nsWrapperCache
*
creator
uint32_t
length
const
element_type
*
data
=
nullptr
)
{
JS
:
:
Rooted
<
JSObject
*
>
creatorWrapper
(
cx
)
;
Maybe
<
JSAutoRealm
>
ar
;
if
(
creator
&
&
(
creatorWrapper
=
creator
-
>
GetWrapperPreserveColor
(
)
)
)
{
ar
.
emplace
(
cx
creatorWrapper
)
;
}
return
CreateCommon
(
cx
length
data
)
;
}
static
inline
JSObject
*
Create
(
JSContext
*
cx
uint32_t
length
const
element_type
*
data
=
nullptr
)
{
return
CreateCommon
(
cx
length
data
)
;
}
static
inline
JSObject
*
Create
(
JSContext
*
cx
nsWrapperCache
*
creator
Span
<
const
element_type
>
data
)
{
if
(
MOZ_UNLIKELY
(
data
.
Length
(
)
>
UINT32_MAX
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
Create
(
cx
creator
data
.
Length
(
)
data
.
Elements
(
)
)
;
}
static
inline
JSObject
*
Create
(
JSContext
*
cx
Span
<
const
element_type
>
data
)
{
if
(
MOZ_UNLIKELY
(
data
.
Length
(
)
>
UINT32_MAX
)
)
{
JS_ReportOutOfMemory
(
cx
)
;
return
nullptr
;
}
return
CreateCommon
(
cx
data
.
Length
(
)
data
.
Elements
(
)
)
;
}
private
:
static
inline
JSObject
*
CreateCommon
(
JSContext
*
cx
uint32_t
length
const
element_type
*
data
)
{
auto
array
=
ArrayT
:
:
create
(
cx
length
)
;
if
(
!
array
)
{
return
nullptr
;
}
if
(
data
)
{
JS
:
:
AutoCheckCannotGC
nogc
;
bool
isShared
;
element_type
*
buf
=
array
.
getData
(
&
isShared
nogc
)
;
MOZ_ASSERT
(
!
isShared
)
;
memcpy
(
buf
data
length
*
sizeof
(
element_type
)
)
;
}
return
array
.
asObject
(
)
;
}
TypedArray
(
const
TypedArray
&
)
=
delete
;
}
;
template
<
JS
:
:
Scalar
:
:
Type
GetViewType
(
JSObject
*
)
>
struct
ArrayBufferView_base
:
public
TypedArray_base
<
JS
:
:
ArrayBufferView
>
{
private
:
using
Base
=
TypedArray_base
<
JS
:
:
ArrayBufferView
>
;
public
:
ArrayBufferView_base
(
)
:
Base
(
)
mType
(
JS
:
:
Scalar
:
:
MaxTypedArrayViewType
)
{
}
ArrayBufferView_base
(
ArrayBufferView_base
&
&
aOther
)
:
Base
(
std
:
:
move
(
aOther
)
)
mType
(
aOther
.
mType
)
{
aOther
.
mType
=
JS
:
:
Scalar
:
:
MaxTypedArrayViewType
;
}
private
:
JS
:
:
Scalar
:
:
Type
mType
;
public
:
inline
bool
Init
(
JSObject
*
obj
)
{
if
(
!
Base
:
:
Init
(
obj
)
)
{
return
false
;
}
mType
=
GetViewType
(
this
-
>
Obj
(
)
)
;
return
true
;
}
inline
JS
:
:
Scalar
:
:
Type
Type
(
)
const
{
MOZ_ASSERT
(
this
-
>
inited
(
)
)
;
return
mType
;
}
}
;
using
Int8Array
=
TypedArray
<
JS
:
:
Int8Array
>
;
using
Uint8Array
=
TypedArray
<
JS
:
:
Uint8Array
>
;
using
Uint8ClampedArray
=
TypedArray
<
JS
:
:
Uint8ClampedArray
>
;
using
Int16Array
=
TypedArray
<
JS
:
:
Int16Array
>
;
using
Uint16Array
=
TypedArray
<
JS
:
:
Uint16Array
>
;
using
Int32Array
=
TypedArray
<
JS
:
:
Int32Array
>
;
using
Uint32Array
=
TypedArray
<
JS
:
:
Uint32Array
>
;
using
Float32Array
=
TypedArray
<
JS
:
:
Float32Array
>
;
using
Float64Array
=
TypedArray
<
JS
:
:
Float64Array
>
;
using
ArrayBufferView
=
ArrayBufferView_base
<
JS_GetArrayBufferViewType
>
;
using
ArrayBuffer
=
TypedArray
<
JS
:
:
ArrayBuffer
>
;
template
<
typename
TypedArrayType
>
class
TypedArrayCreator
{
typedef
nsTArray
<
typename
TypedArrayType
:
:
element_type
>
ArrayType
;
public
:
explicit
TypedArrayCreator
(
const
ArrayType
&
aArray
)
:
mArray
(
aArray
)
{
}
JSObject
*
Create
(
JSContext
*
aCx
)
const
{
return
TypedArrayType
:
:
Create
(
aCx
mArray
.
Length
(
)
mArray
.
Elements
(
)
)
;
}
private
:
const
ArrayType
&
mArray
;
}
;
}
}
#
endif
