const
CC
=
Components
.
Constructor
;
const
BinaryInputStream
=
CC
(
"
mozilla
.
org
/
binaryinputstream
;
1
"
"
nsIBinaryInputStream
"
"
setInputStream
"
)
;
function
DEBUG
(
str
)
{
}
function
setOurState
(
data
)
{
x
=
{
data
:
data
QueryInterface
:
function
(
iid
)
{
return
this
}
}
;
x
.
wrappedJSObject
=
x
;
setObjectState
(
"
beacon
-
handler
"
x
)
;
DEBUG
(
"
our
state
is
"
+
data
)
;
}
function
getOurState
(
)
{
var
data
;
getObjectState
(
"
beacon
-
handler
"
function
(
x
)
{
if
(
x
)
{
data
=
x
.
wrappedJSObject
.
data
;
}
}
)
;
return
data
;
}
function
handleRequest
(
request
response
)
{
DEBUG
(
"
Entered
request
handler
"
)
;
response
.
setHeader
(
"
Cache
-
Control
"
"
no
-
cache
"
false
)
;
function
finishControlResponse
(
response
)
{
DEBUG
(
"
*
*
*
*
*
*
*
*
*
sending
out
the
control
GET
response
"
)
;
var
data
=
getState
(
"
beaconData
"
)
;
var
mimetype
=
getState
(
"
beaconMimetype
"
)
;
DEBUG
(
"
GET
was
sending
:
"
+
data
+
"
\
n
"
)
;
DEBUG
(
"
GET
was
sending
:
"
+
mimetype
+
"
\
n
"
)
;
var
result
=
{
"
data
"
:
data
"
mimetype
"
:
mimetype
}
;
response
.
write
(
JSON
.
stringify
(
result
)
)
;
setOurState
(
null
)
;
}
if
(
request
.
method
=
=
"
GET
"
)
{
DEBUG
(
"
-
-
-
-
-
-
-
-
-
-
-
-
GET
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
application
/
json
"
false
)
;
switch
(
request
.
queryString
)
{
case
"
getLastBeacon
"
:
var
originHeader
=
request
.
getHeader
(
"
origin
"
)
;
response
.
setHeader
(
"
Access
-
Control
-
Allow
-
Headers
"
"
content
-
type
"
false
)
;
response
.
setHeader
(
"
Access
-
Control
-
Allow
-
Methods
"
"
POST
GET
"
false
)
;
response
.
setHeader
(
"
Access
-
Control
-
Allow
-
Origin
"
originHeader
false
)
;
response
.
setHeader
(
"
Access
-
Control
-
Allow
-
Credentials
"
"
true
"
false
)
;
var
state
=
getOurState
(
)
;
if
(
state
=
=
=
"
unblocked
"
)
{
finishControlResponse
(
response
)
;
}
else
{
DEBUG
(
"
GET
has
arrived
but
POST
has
not
blocking
response
!
"
)
;
setOurState
(
response
)
;
response
.
processAsync
(
)
;
}
break
;
default
:
response
.
setStatusLine
(
request
.
httpVersion
400
"
Bad
Request
"
)
;
break
;
}
return
;
}
if
(
request
.
method
=
=
"
POST
"
)
{
DEBUG
(
"
-
-
-
-
-
-
-
-
-
-
-
-
POST
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
"
)
;
var
body
=
new
BinaryInputStream
(
request
.
bodyInputStream
)
;
var
avail
;
var
bytes
=
[
]
;
while
(
(
avail
=
body
.
available
(
)
)
>
0
)
{
Array
.
prototype
.
push
.
apply
(
bytes
body
.
readByteArray
(
avail
)
)
;
}
var
data
=
"
"
;
for
(
var
i
=
0
;
i
<
bytes
.
length
;
i
+
+
)
{
if
(
bytes
[
i
]
<
32
)
continue
;
var
charcode
=
String
.
fromCharCode
(
bytes
[
i
]
)
;
data
+
=
charcode
;
}
var
mimetype
=
"
"
;
if
(
request
.
hasHeader
(
"
Content
-
Type
"
)
)
{
mimetype
=
request
.
getHeader
(
"
Content
-
Type
"
)
;
}
if
(
mimetype
.
indexOf
(
"
multipart
/
form
-
data
"
)
!
=
-
1
)
{
mimetype
=
"
multipart
/
form
-
data
"
;
var
pattern
=
/
;
name
=
\
"
(
.
+
)
\
"
;
/
;
data
=
data
.
split
(
pattern
)
[
1
]
;
}
DEBUG
(
"
*
*
*
*
*
*
*
*
*
*
POST
was
sending
:
"
+
data
+
"
\
n
"
)
;
DEBUG
(
"
*
*
*
*
*
*
*
*
*
*
POST
was
sending
:
"
+
mimetype
+
"
\
n
"
)
;
setState
(
"
beaconData
"
data
)
;
setState
(
"
beaconMimetype
"
mimetype
)
;
response
.
setHeader
(
"
Content
-
Type
"
"
text
/
plain
"
false
)
;
response
.
write
(
'
ok
'
)
;
var
blockedResponse
=
getOurState
(
)
;
if
(
typeof
(
blockedResponse
)
=
=
"
object
"
&
&
blockedResponse
)
{
DEBUG
(
"
GET
is
already
pending
finishing
!
"
)
;
finishControlResponse
(
blockedResponse
)
;
blockedResponse
.
finish
(
)
;
}
else
{
DEBUG
(
"
GET
has
not
arrived
marking
it
as
unblocked
"
)
;
setOurState
(
"
unblocked
"
)
;
}
return
;
}
response
.
setStatusLine
(
request
.
httpVersion
402
"
Bad
Request
"
)
;
}
