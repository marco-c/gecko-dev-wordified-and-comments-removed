class
KnownTab
{
constructor
(
name
tab
)
{
this
.
name
=
name
;
this
.
tab
=
tab
;
}
cleanup
(
)
{
this
.
tab
=
null
;
}
}
class
KnownTabs
{
constructor
(
)
{
this
.
byPid
=
new
Map
(
)
;
this
.
byName
=
new
Map
(
)
;
}
cleanup
(
)
{
for
(
let
key
of
this
.
byPid
.
keys
(
)
)
{
this
.
byPid
[
key
]
=
null
;
}
this
.
byPid
=
null
;
this
.
byName
=
null
;
}
}
async
function
openTestTab
(
helperPageUrl
name
knownTabs
shouldLoadInNewProcess
)
{
let
realUrl
=
helperPageUrl
+
"
?
"
+
encodeURIComponent
(
name
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
"
about
:
blank
"
forceNewProcess
:
true
}
)
;
ok
(
!
knownTabs
.
byName
.
has
(
name
)
"
tab
needs
its
own
name
:
"
+
name
)
;
let
knownTab
=
new
KnownTab
(
name
tab
)
;
knownTabs
.
byName
.
set
(
name
knownTab
)
;
BrowserTestUtils
.
startLoadingURIString
(
tab
.
linkedBrowser
realUrl
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
let
pid
=
tab
.
linkedBrowser
.
frameLoader
.
remoteTab
.
osPid
;
if
(
shouldLoadInNewProcess
)
{
ok
(
!
knownTabs
.
byPid
.
has
(
pid
)
"
tab
should
be
loaded
in
new
process
pid
:
"
+
pid
)
;
}
else
{
ok
(
knownTabs
.
byPid
.
has
(
pid
)
"
tab
should
be
loaded
in
the
same
process
new
pid
:
"
+
pid
)
;
}
if
(
knownTabs
.
byPid
.
has
(
pid
)
)
{
knownTabs
.
byPid
.
get
(
pid
)
.
set
(
name
knownTab
)
;
}
else
{
let
pidMap
=
new
Map
(
)
;
pidMap
.
set
(
name
knownTab
)
;
knownTabs
.
byPid
.
set
(
pid
pidMap
)
;
}
return
knownTab
;
}
async
function
cleanupTabs
(
knownTabs
)
{
for
(
let
knownTab
of
knownTabs
.
byName
.
values
(
)
)
{
BrowserTestUtils
.
removeTab
(
knownTab
.
tab
)
;
knownTab
.
cleanup
(
)
;
}
knownTabs
.
cleanup
(
)
;
}
function
waitForLocalStorageFlush
(
)
{
if
(
Services
.
domStorageManager
.
nextGenLocalStorageEnabled
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
return
new
Promise
(
function
(
resolve
)
{
let
observer
=
{
observe
(
)
{
SpecialPowers
.
removeObserver
(
observer
"
domstorage
-
test
-
flushed
"
)
;
resolve
(
)
;
}
}
;
SpecialPowers
.
addObserver
(
observer
"
domstorage
-
test
-
flushed
"
)
;
}
)
;
}
function
triggerAndWaitForLocalStorageFlush
(
)
{
if
(
Services
.
domStorageManager
.
nextGenLocalStorageEnabled
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
SpecialPowers
.
notifyObservers
(
null
"
domstorage
-
test
-
flush
-
force
"
)
;
return
waitForLocalStorageFlush
(
)
.
then
(
function
(
)
{
SpecialPowers
.
notifyObservers
(
null
"
domstorage
-
test
-
flush
-
force
"
)
;
return
waitForLocalStorageFlush
(
)
;
}
)
;
}
function
clearOriginStorageEnsuringNoPreload
(
origin
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
if
(
Services
.
domStorageManager
.
nextGenLocalStorageEnabled
)
{
let
request
=
Services
.
qms
.
clearStoragesForPrincipal
(
principal
"
default
"
"
ls
"
)
;
let
promise
=
new
Promise
(
resolve
=
>
{
request
.
callback
=
(
)
=
>
{
resolve
(
)
;
}
;
}
)
;
return
promise
;
}
let
storage
=
Services
.
domStorageManager
.
createStorage
(
null
principal
principal
"
"
)
;
storage
.
clear
(
)
;
return
triggerAndWaitForLocalStorageFlush
(
)
;
}
async
function
verifyTabPreload
(
knownTab
expectStorageExists
origin
)
{
let
storageExists
=
await
SpecialPowers
.
spawn
(
knownTab
.
tab
.
linkedBrowser
[
origin
]
function
(
origin
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
if
(
Services
.
domStorageManager
.
nextGenLocalStorageEnabled
)
{
return
Services
.
domStorageManager
.
isPreloaded
(
principal
)
;
}
return
!
!
Services
.
domStorageManager
.
getStorage
(
null
principal
principal
)
;
}
)
;
is
(
storageExists
expectStorageExists
"
Storage
existence
=
=
=
preload
"
)
;
}
async
function
mutateTabStorage
(
knownTab
mutations
sentinelValue
)
{
await
SpecialPowers
.
spawn
(
knownTab
.
tab
.
linkedBrowser
[
{
mutations
sentinelValue
}
]
function
(
args
)
{
return
content
.
wrappedJSObject
.
mutateStorage
(
Cu
.
cloneInto
(
args
content
)
)
;
}
)
;
}
async
function
recordTabStorageEvents
(
knownTab
sentinelValue
)
{
await
SpecialPowers
.
spawn
(
knownTab
.
tab
.
linkedBrowser
[
sentinelValue
]
function
(
sentinelValue
)
{
return
content
.
wrappedJSObject
.
listenForStorageEvents
(
sentinelValue
)
;
}
)
;
}
async
function
verifyTabStorageState
(
knownTab
expectedState
maybeSentinel
)
{
let
actualState
=
await
SpecialPowers
.
spawn
(
knownTab
.
tab
.
linkedBrowser
[
maybeSentinel
]
function
(
maybeSentinel
)
{
return
content
.
wrappedJSObject
.
getStorageState
(
maybeSentinel
)
;
}
)
;
for
(
let
[
expectedKey
expectedValue
]
of
Object
.
entries
(
expectedState
)
)
{
ok
(
actualState
.
hasOwnProperty
(
expectedKey
)
"
key
present
:
"
+
expectedKey
)
;
is
(
actualState
[
expectedKey
]
expectedValue
"
value
correct
"
)
;
}
for
(
let
actualKey
of
Object
.
keys
(
actualState
)
)
{
if
(
!
expectedState
.
hasOwnProperty
(
actualKey
)
)
{
ok
(
false
"
actual
state
has
key
it
shouldn
'
t
have
:
"
+
actualKey
)
;
}
}
}
async
function
verifyTabStorageEvents
(
knownTab
expectedEvents
)
{
let
actualEvents
=
await
SpecialPowers
.
spawn
(
knownTab
.
tab
.
linkedBrowser
[
]
function
(
)
{
return
content
.
wrappedJSObject
.
returnAndClearStorageEvents
(
)
;
}
)
;
is
(
actualEvents
.
length
expectedEvents
.
length
"
right
number
of
events
"
)
;
for
(
let
i
=
0
;
i
<
actualEvents
.
length
;
i
+
+
)
{
let
[
actualKey
actualNewValue
actualOldValue
]
=
actualEvents
[
i
]
;
let
[
expectedKey
expectedNewValue
expectedOldValue
]
=
expectedEvents
[
i
]
;
is
(
actualKey
expectedKey
"
keys
match
"
)
;
is
(
actualNewValue
expectedNewValue
"
new
values
match
"
)
;
is
(
actualOldValue
expectedOldValue
"
old
values
match
"
)
;
}
}
