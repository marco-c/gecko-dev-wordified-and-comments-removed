"
use
strict
"
;
const
TEST_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
"
"
https
:
/
/
example
.
org
"
)
;
var
MockFilePicker
=
SpecialPowers
.
MockFilePicker
;
MockFilePicker
.
init
(
window
)
;
registerCleanupFunction
(
async
function
(
)
{
info
(
"
Running
the
cleanup
code
"
)
;
MockFilePicker
.
cleanup
(
)
;
if
(
gTestDir
&
&
gTestDir
.
exists
(
)
)
{
let
succeeded
=
false
;
while
(
!
succeeded
)
{
try
{
gTestDir
.
remove
(
true
)
;
succeeded
=
true
;
}
catch
(
ex
)
{
await
new
Promise
(
requestAnimationFrame
)
;
}
}
}
}
)
;
let
gTestDir
=
null
;
function
createTemporarySaveDirectory
(
)
{
var
saveDir
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
saveDir
.
append
(
"
testsavedir
"
)
;
if
(
!
saveDir
.
exists
(
)
)
{
info
(
"
create
testsavedir
!
"
)
;
saveDir
.
create
(
Ci
.
nsIFile
.
DIRECTORY_TYPE
0o755
)
;
}
info
(
"
return
from
createTempSaveDir
:
"
+
saveDir
.
path
)
;
return
saveDir
;
}
add_task
(
async
function
test_image_download
(
)
{
await
BrowserTestUtils
.
withNewTab
(
TEST_PATH
+
"
dummy
.
html
"
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
function
(
)
{
let
loc
=
content
.
document
.
location
.
href
;
let
imgloc
=
new
content
.
URL
(
"
dummy
.
png
"
loc
)
;
let
img
=
content
.
document
.
createElement
(
"
img
"
)
;
img
.
src
=
imgloc
;
await
new
Promise
(
resolve
=
>
{
img
.
onload
=
resolve
;
content
.
document
.
body
.
appendChild
(
img
)
;
}
)
;
}
)
;
gTestDir
=
createTemporarySaveDirectory
(
)
;
let
destFile
=
gTestDir
.
clone
(
)
;
MockFilePicker
.
displayDirectory
=
gTestDir
;
let
fileName
;
MockFilePicker
.
showCallback
=
function
(
fp
)
{
info
(
"
showCallback
"
)
;
fileName
=
fp
.
defaultString
;
info
(
"
fileName
:
"
+
fileName
)
;
destFile
.
append
(
fileName
)
;
info
(
"
path
:
"
+
destFile
.
path
)
;
MockFilePicker
.
setFiles
(
[
destFile
]
)
;
MockFilePicker
.
filterIndex
=
0
;
info
(
"
done
showCallback
"
)
;
}
;
let
publicDownloads
=
await
Downloads
.
getList
(
Downloads
.
PUBLIC
)
;
let
downloadFinishedPromise
=
new
Promise
(
resolve
=
>
{
publicDownloads
.
addView
(
{
onDownloadChanged
(
download
)
{
info
(
"
Download
changed
!
"
)
;
if
(
download
.
succeeded
|
|
download
.
error
)
{
info
(
"
Download
succeeded
or
errored
"
)
;
publicDownloads
.
removeView
(
this
)
;
publicDownloads
.
removeFinished
(
)
;
resolve
(
download
)
;
}
}
}
)
;
}
)
;
let
httpOnModifyPromise
=
TestUtils
.
topicObserved
(
"
http
-
on
-
modify
-
request
"
(
s
t
d
)
=
>
{
let
channel
=
s
.
QueryInterface
(
Ci
.
nsIChannel
)
;
let
uri
=
channel
.
URI
&
&
channel
.
URI
.
spec
;
if
(
!
uri
.
endsWith
(
"
dummy
.
png
"
)
)
{
info
(
"
Ignoring
request
for
"
+
uri
)
;
return
false
;
}
ok
(
channel
instanceof
Ci
.
nsIHttpChannel
"
Should
be
HTTP
channel
"
)
;
channel
.
QueryInterface
(
Ci
.
nsIHttpChannel
)
;
is
(
channel
.
getRequestHeader
(
"
Accept
"
)
Services
.
prefs
.
getCharPref
(
"
image
.
http
.
accept
"
)
"
Header
should
be
image
header
"
)
;
return
true
;
}
)
;
let
popup
=
document
.
getElementById
(
"
contentAreaContextMenu
"
)
;
let
popupShown
=
BrowserTestUtils
.
waitForEvent
(
popup
"
popupshown
"
)
;
BrowserTestUtils
.
synthesizeMouseAtCenter
(
"
img
"
{
type
:
"
contextmenu
"
button
:
2
}
browser
)
;
await
popupShown
;
let
popupHidden
=
BrowserTestUtils
.
waitForEvent
(
popup
"
popuphidden
"
)
;
popup
.
querySelector
(
"
#
context
-
saveimage
"
)
.
click
(
)
;
popup
.
hidePopup
(
)
;
await
popupHidden
;
info
(
"
Context
menu
hidden
waiting
for
download
to
finish
"
)
;
let
imageDownload
=
await
downloadFinishedPromise
;
ok
(
imageDownload
.
succeeded
"
Image
should
have
downloaded
successfully
"
)
;
info
(
"
Waiting
for
http
request
to
complete
.
"
)
;
await
httpOnModifyPromise
;
}
)
;
}
)
;
