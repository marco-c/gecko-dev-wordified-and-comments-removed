const
HELPER_PAGE_URL
=
"
http
:
/
/
example
.
com
/
browser
/
dom
/
tests
/
browser
/
page_localstorage_e10s
.
html
"
;
const
HELPER_PAGE_ORIGIN
=
"
http
:
/
/
example
.
com
/
"
;
class
KnownTab
{
constructor
(
name
tab
)
{
this
.
name
=
name
;
this
.
tab
=
tab
;
}
cleanup
(
)
{
this
.
tab
=
null
;
}
}
class
KnownTabs
{
constructor
(
)
{
this
.
byPid
=
new
Map
(
)
;
this
.
byName
=
new
Map
(
)
;
}
cleanup
(
)
{
this
.
byPid
=
null
;
this
.
byName
=
null
;
}
}
async
function
openTestTabInOwnProcess
(
name
knownTabs
)
{
let
realUrl
=
HELPER_PAGE_URL
+
'
?
'
+
encodeURIComponent
(
name
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
'
about
:
blank
'
forceNewProcess
:
true
}
)
;
let
pid
=
tab
.
linkedBrowser
.
frameLoader
.
tabParent
.
osPid
;
ok
(
!
knownTabs
.
byName
.
has
(
name
)
"
tab
needs
its
own
name
:
"
+
name
)
;
ok
(
!
knownTabs
.
byPid
.
has
(
pid
)
"
tab
needs
to
be
in
its
own
process
:
"
+
pid
)
;
let
knownTab
=
new
KnownTab
(
name
tab
)
;
knownTabs
.
byPid
.
set
(
pid
knownTab
)
;
knownTabs
.
byName
.
set
(
name
knownTab
)
;
tab
.
linkedBrowser
.
loadURI
(
realUrl
)
;
await
BrowserTestUtils
.
browserLoaded
(
tab
.
linkedBrowser
)
;
is
(
tab
.
linkedBrowser
.
frameLoader
.
tabParent
.
osPid
pid
"
still
same
pid
"
)
;
return
knownTab
;
}
async
function
cleanupTabs
(
knownTabs
)
{
for
(
let
knownTab
of
knownTabs
.
byName
.
values
(
)
)
{
await
BrowserTestUtils
.
removeTab
(
knownTab
.
tab
)
;
knownTab
.
cleanup
(
)
;
}
knownTabs
.
cleanup
(
)
;
}
function
waitForLocalStorageFlush
(
)
{
return
new
Promise
(
function
(
resolve
)
{
let
observer
=
{
observe
:
function
(
)
{
SpecialPowers
.
removeObserver
(
observer
"
domstorage
-
test
-
flushed
"
)
;
resolve
(
)
;
}
}
;
SpecialPowers
.
addObserver
(
observer
"
domstorage
-
test
-
flushed
"
)
;
}
)
;
}
function
triggerAndWaitForLocalStorageFlush
(
)
{
SpecialPowers
.
notifyObservers
(
null
"
domstorage
-
test
-
flush
-
force
"
)
;
return
waitForLocalStorageFlush
(
)
.
then
(
function
(
)
{
SpecialPowers
.
notifyObservers
(
null
"
domstorage
-
test
-
flush
-
force
"
)
;
return
waitForLocalStorageFlush
(
)
;
}
)
}
function
clearOriginStorageEnsuringNoPreload
(
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
HELPER_PAGE_ORIGIN
)
;
let
storage
=
Services
.
domStorageManager
.
createStorage
(
null
principal
"
"
)
;
storage
.
clear
(
)
;
return
triggerAndWaitForLocalStorageFlush
(
)
;
}
async
function
verifyTabPreload
(
knownTab
expectStorageExists
)
{
let
storageExists
=
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
HELPER_PAGE_ORIGIN
function
(
origin
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
origin
)
;
return
!
!
Services
.
domStorageManager
.
getStorage
(
null
principal
)
;
}
)
;
is
(
storageExists
expectStorageExists
"
Storage
existence
=
=
=
preload
"
)
;
}
async
function
mutateTabStorage
(
knownTab
mutations
)
{
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
{
mutations
}
function
(
args
)
{
return
content
.
wrappedJSObject
.
mutateStorage
(
args
.
mutations
)
;
}
)
;
}
async
function
recordTabStorageEvents
(
knownTab
)
{
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
{
}
function
(
)
{
return
content
.
wrappedJSObject
.
listenForStorageEvents
(
)
;
}
)
;
}
async
function
verifyTabStorageState
(
knownTab
expectedState
)
{
let
actualState
=
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
{
}
function
(
)
{
return
content
.
wrappedJSObject
.
getStorageState
(
)
;
}
)
;
for
(
let
[
expectedKey
expectedValue
]
of
Object
.
entries
(
expectedState
)
)
{
ok
(
actualState
.
hasOwnProperty
(
expectedKey
)
"
key
present
:
"
+
expectedKey
)
;
is
(
actualState
[
expectedKey
]
expectedValue
"
value
correct
"
)
;
}
for
(
let
actualKey
of
Object
.
keys
(
actualState
)
)
{
if
(
!
expectedState
.
hasOwnProperty
(
actualKey
)
)
{
ok
(
false
"
actual
state
has
key
it
shouldn
'
t
have
:
"
+
actualKey
)
;
}
}
}
async
function
verifyTabStorageEvents
(
knownTab
expectedEvents
)
{
let
actualEvents
=
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
{
}
function
(
)
{
return
content
.
wrappedJSObject
.
returnAndClearStorageEvents
(
)
;
}
)
;
is
(
actualEvents
.
length
expectedEvents
.
length
"
right
number
of
events
"
)
;
for
(
let
i
=
0
;
i
<
actualEvents
.
length
;
i
+
+
)
{
let
[
actualKey
actualNewValue
actualOldValue
]
=
actualEvents
[
i
]
;
let
[
expectedKey
expectedNewValue
expectedOldValue
]
=
expectedEvents
[
i
]
;
is
(
actualKey
expectedKey
"
keys
match
"
)
;
is
(
actualNewValue
expectedNewValue
"
new
values
match
"
)
;
is
(
actualOldValue
expectedOldValue
"
old
values
match
"
)
;
}
}
requestLongerTimeout
(
4
)
;
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
]
[
"
dom
.
storage
.
testing
"
true
]
]
}
)
;
await
clearOriginStorageEnsuringNoPreload
(
)
;
await
triggerAndWaitForLocalStorageFlush
(
)
;
const
knownTabs
=
new
KnownTabs
(
)
;
const
writerTab
=
await
openTestTabInOwnProcess
(
"
writer
"
knownTabs
)
;
const
listenerTab
=
await
openTestTabInOwnProcess
(
"
listener
"
knownTabs
)
;
const
readerTab
=
await
openTestTabInOwnProcess
(
"
reader
"
knownTabs
)
;
const
lateWriteThenListenTab
=
await
openTestTabInOwnProcess
(
"
lateWriteThenListen
"
knownTabs
)
;
await
verifyTabPreload
(
writerTab
false
)
;
await
verifyTabPreload
(
listenerTab
false
)
;
await
verifyTabPreload
(
readerTab
false
)
;
await
recordTabStorageEvents
(
listenerTab
)
;
const
initialWriteMutations
=
[
[
"
getsCleared
"
"
1
"
null
]
[
"
alsoGetsCleared
"
"
2
"
null
]
[
null
null
null
]
[
"
stays
"
"
3
"
null
]
[
"
clobbered
"
"
pre
"
null
]
[
"
getsDeletedLater
"
"
4
"
null
]
[
"
getsDeletedImmediately
"
"
5
"
null
]
[
"
getsDeletedImmediately
"
null
"
5
"
]
[
"
alsoStays
"
"
6
"
null
]
[
"
getsDeletedLater
"
null
"
4
"
]
[
"
clobbered
"
"
post
"
"
pre
"
]
]
;
const
initialWriteState
=
{
stays
:
"
3
"
clobbered
:
"
post
"
alsoStays
:
"
6
"
}
;
await
mutateTabStorage
(
writerTab
initialWriteMutations
)
;
await
verifyTabStorageState
(
writerTab
initialWriteState
)
;
await
verifyTabStorageEvents
(
listenerTab
initialWriteMutations
)
;
await
verifyTabStorageState
(
listenerTab
initialWriteState
)
;
await
verifyTabStorageState
(
readerTab
initialWriteState
)
;
const
lateWriteMutations
=
[
[
"
lateStays
"
"
10
"
null
]
[
"
lateClobbered
"
"
latePre
"
null
]
[
"
lateDeleted
"
"
11
"
null
]
[
"
lateClobbered
"
"
lastPost
"
"
latePre
"
]
[
"
lateDeleted
"
null
"
11
"
]
]
;
const
lateWriteState
=
Object
.
assign
(
{
}
initialWriteState
{
lateStays
:
"
10
"
lateClobbered
:
"
lastPost
"
}
)
;
await
mutateTabStorage
(
lateWriteThenListenTab
lateWriteMutations
)
;
await
recordTabStorageEvents
(
lateWriteThenListenTab
)
;
await
verifyTabStorageState
(
writerTab
lateWriteState
)
;
await
verifyTabStorageEvents
(
listenerTab
lateWriteMutations
)
;
await
verifyTabStorageState
(
listenerTab
lateWriteState
)
;
await
verifyTabStorageState
(
readerTab
lateWriteState
)
;
const
lastWriteMutations
=
[
[
"
lastStays
"
"
20
"
null
]
[
"
lastDeleted
"
"
21
"
null
]
[
"
lastClobbered
"
"
lastPre
"
null
]
[
"
lastClobbered
"
"
lastPost
"
"
lastPre
"
]
[
"
lastDeleted
"
null
"
21
"
]
]
;
const
lastWriteState
=
Object
.
assign
(
{
}
lateWriteState
{
lastStays
:
"
20
"
lastClobbered
:
"
lastPost
"
}
)
;
await
mutateTabStorage
(
writerTab
lastWriteMutations
)
;
await
verifyTabStorageState
(
writerTab
lastWriteState
)
;
await
verifyTabStorageEvents
(
listenerTab
lastWriteMutations
)
;
await
verifyTabStorageState
(
listenerTab
lastWriteState
)
;
await
verifyTabStorageState
(
readerTab
lastWriteState
)
;
await
verifyTabStorageEvents
(
lateWriteThenListenTab
lastWriteMutations
)
;
await
verifyTabStorageState
(
lateWriteThenListenTab
lastWriteState
)
;
await
triggerAndWaitForLocalStorageFlush
(
)
;
const
lateOpenSeesPreload
=
await
openTestTabInOwnProcess
(
"
lateOpenSeesPreload
"
knownTabs
)
;
await
verifyTabPreload
(
lateOpenSeesPreload
true
)
;
await
cleanupTabs
(
knownTabs
)
;
clearOriginStorageEnsuringNoPreload
(
)
;
}
)
;
