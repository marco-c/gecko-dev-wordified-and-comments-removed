const
HELPER_PAGE_URL
=
"
http
:
/
/
example
.
com
/
browser
/
dom
/
tests
/
browser
/
page_localstorage_e10s
.
html
"
;
const
HELPER_PAGE_ORIGIN
=
"
http
:
/
/
example
.
com
/
"
;
let
testDir
=
gTestPath
.
substr
(
0
gTestPath
.
lastIndexOf
(
"
/
"
)
)
;
Services
.
scriptloader
.
loadSubScript
(
testDir
+
"
/
helper_localStorage_e10s
.
js
"
this
)
;
function
waitForLocalStorageFlush
(
)
{
if
(
Services
.
lsm
.
nextGenLocalStorageEnabled
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
return
new
Promise
(
function
(
resolve
)
{
let
observer
=
{
observe
(
)
{
SpecialPowers
.
removeObserver
(
observer
"
domstorage
-
test
-
flushed
"
)
;
resolve
(
)
;
}
}
;
SpecialPowers
.
addObserver
(
observer
"
domstorage
-
test
-
flushed
"
)
;
}
)
;
}
function
triggerAndWaitForLocalStorageFlush
(
)
{
if
(
Services
.
lsm
.
nextGenLocalStorageEnabled
)
{
return
new
Promise
(
resolve
=
>
executeSoon
(
resolve
)
)
;
}
SpecialPowers
.
notifyObservers
(
null
"
domstorage
-
test
-
flush
-
force
"
)
;
return
waitForLocalStorageFlush
(
)
.
then
(
function
(
)
{
SpecialPowers
.
notifyObservers
(
null
"
domstorage
-
test
-
flush
-
force
"
)
;
return
waitForLocalStorageFlush
(
)
;
}
)
;
}
function
clearOriginStorageEnsuringNoPreload
(
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
HELPER_PAGE_ORIGIN
)
;
if
(
Services
.
lsm
.
nextGenLocalStorageEnabled
)
{
let
request
=
Services
.
qms
.
clearStoragesForPrincipal
(
principal
"
default
"
"
ls
"
)
;
let
promise
=
new
Promise
(
resolve
=
>
{
request
.
callback
=
(
)
=
>
{
resolve
(
)
;
}
;
}
)
;
return
promise
;
}
let
storage
=
Services
.
domStorageManager
.
createStorage
(
null
principal
principal
"
"
)
;
storage
.
clear
(
)
;
return
triggerAndWaitForLocalStorageFlush
(
)
;
}
async
function
verifyTabPreload
(
knownTab
expectStorageExists
)
{
let
storageExists
=
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
HELPER_PAGE_ORIGIN
function
(
origin
)
{
let
principal
=
Services
.
scriptSecurityManager
.
createCodebasePrincipalFromOrigin
(
origin
)
;
if
(
Services
.
lsm
.
nextGenLocalStorageEnabled
)
{
return
Services
.
lsm
.
isPreloaded
(
principal
)
;
}
return
!
!
Services
.
domStorageManager
.
getStorage
(
null
principal
principal
)
;
}
)
;
is
(
storageExists
expectStorageExists
"
Storage
existence
=
=
=
preload
"
)
;
}
async
function
mutateTabStorage
(
knownTab
mutations
sentinelValue
)
{
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
{
mutations
sentinelValue
}
function
(
args
)
{
return
content
.
wrappedJSObject
.
mutateStorage
(
Cu
.
cloneInto
(
args
content
)
)
;
}
)
;
}
async
function
recordTabStorageEvents
(
knownTab
sentinelValue
)
{
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
sentinelValue
function
(
sentinelValue
)
{
return
content
.
wrappedJSObject
.
listenForStorageEvents
(
sentinelValue
)
;
}
)
;
}
async
function
verifyTabStorageState
(
knownTab
expectedState
maybeSentinel
)
{
let
actualState
=
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
maybeSentinel
function
(
maybeSentinel
)
{
return
content
.
wrappedJSObject
.
getStorageState
(
maybeSentinel
)
;
}
)
;
for
(
let
[
expectedKey
expectedValue
]
of
Object
.
entries
(
expectedState
)
)
{
ok
(
actualState
.
hasOwnProperty
(
expectedKey
)
"
key
present
:
"
+
expectedKey
)
;
is
(
actualState
[
expectedKey
]
expectedValue
"
value
correct
"
)
;
}
for
(
let
actualKey
of
Object
.
keys
(
actualState
)
)
{
if
(
!
expectedState
.
hasOwnProperty
(
actualKey
)
)
{
ok
(
false
"
actual
state
has
key
it
shouldn
'
t
have
:
"
+
actualKey
)
;
}
}
}
async
function
verifyTabStorageEvents
(
knownTab
expectedEvents
)
{
let
actualEvents
=
await
ContentTask
.
spawn
(
knownTab
.
tab
.
linkedBrowser
{
}
function
(
)
{
return
content
.
wrappedJSObject
.
returnAndClearStorageEvents
(
)
;
}
)
;
is
(
actualEvents
.
length
expectedEvents
.
length
"
right
number
of
events
"
)
;
for
(
let
i
=
0
;
i
<
actualEvents
.
length
;
i
+
+
)
{
let
[
actualKey
actualNewValue
actualOldValue
]
=
actualEvents
[
i
]
;
let
[
expectedKey
expectedNewValue
expectedOldValue
]
=
expectedEvents
[
i
]
;
is
(
actualKey
expectedKey
"
keys
match
"
)
;
is
(
actualNewValue
expectedNewValue
"
new
values
match
"
)
;
is
(
actualOldValue
expectedOldValue
"
old
values
match
"
)
;
}
}
requestLongerTimeout
(
4
)
;
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
false
]
[
"
dom
.
storage
.
testing
"
true
]
]
}
)
;
await
clearOriginStorageEnsuringNoPreload
(
)
;
await
triggerAndWaitForLocalStorageFlush
(
)
;
const
knownTabs
=
new
KnownTabs
(
)
;
const
writerTab
=
await
openTestTabInOwnProcess
(
HELPER_PAGE_URL
"
writer
"
knownTabs
)
;
const
listenerTab
=
await
openTestTabInOwnProcess
(
HELPER_PAGE_URL
"
listener
"
knownTabs
)
;
const
readerTab
=
await
openTestTabInOwnProcess
(
HELPER_PAGE_URL
"
reader
"
knownTabs
)
;
const
lateWriteThenListenTab
=
await
openTestTabInOwnProcess
(
HELPER_PAGE_URL
"
lateWriteThenListen
"
knownTabs
)
;
await
verifyTabPreload
(
writerTab
false
)
;
await
verifyTabPreload
(
listenerTab
false
)
;
await
verifyTabPreload
(
readerTab
false
)
;
const
initialSentinel
=
"
initial
"
;
const
noSentinelCheck
=
null
;
await
recordTabStorageEvents
(
listenerTab
initialSentinel
)
;
info
(
"
initial
writes
"
)
;
const
initialWriteMutations
=
[
[
"
getsCleared
"
"
1
"
null
]
[
"
alsoGetsCleared
"
"
2
"
null
]
[
null
null
null
]
[
"
stays
"
"
3
"
null
]
[
"
clobbered
"
"
pre
"
null
]
[
"
getsDeletedLater
"
"
4
"
null
]
[
"
getsDeletedImmediately
"
"
5
"
null
]
[
"
getsDeletedImmediately
"
null
"
5
"
]
[
"
alsoStays
"
"
6
"
null
]
[
"
getsDeletedLater
"
null
"
4
"
]
[
"
clobbered
"
"
post
"
"
pre
"
]
]
;
const
initialWriteState
=
{
stays
:
"
3
"
clobbered
:
"
post
"
alsoStays
:
"
6
"
}
;
await
mutateTabStorage
(
writerTab
initialWriteMutations
initialSentinel
)
;
await
verifyTabStorageState
(
writerTab
initialWriteState
noSentinelCheck
)
;
await
verifyTabStorageEvents
(
listenerTab
initialWriteMutations
initialSentinel
)
;
await
verifyTabStorageState
(
listenerTab
initialWriteState
noSentinelCheck
)
;
await
verifyTabStorageState
(
readerTab
initialWriteState
noSentinelCheck
)
;
info
(
"
late
writes
"
)
;
const
lateWriteSentinel
=
"
lateWrite
"
;
const
lateWriteMutations
=
[
[
"
lateStays
"
"
10
"
null
]
[
"
lateClobbered
"
"
latePre
"
null
]
[
"
lateDeleted
"
"
11
"
null
]
[
"
lateClobbered
"
"
lastPost
"
"
latePre
"
]
[
"
lateDeleted
"
null
"
11
"
]
]
;
const
lateWriteState
=
Object
.
assign
(
{
}
initialWriteState
{
lateStays
:
"
10
"
lateClobbered
:
"
lastPost
"
}
)
;
await
recordTabStorageEvents
(
listenerTab
lateWriteSentinel
)
;
await
mutateTabStorage
(
lateWriteThenListenTab
lateWriteMutations
lateWriteSentinel
)
;
await
verifyTabStorageState
(
writerTab
lateWriteState
lateWriteSentinel
)
;
await
verifyTabStorageEvents
(
listenerTab
lateWriteMutations
lateWriteSentinel
)
;
await
verifyTabStorageState
(
listenerTab
lateWriteState
noSentinelCheck
)
;
await
verifyTabStorageState
(
readerTab
lateWriteState
lateWriteSentinel
)
;
info
(
"
last
set
of
writes
"
)
;
const
lastWriteSentinel
=
"
lastWrite
"
;
const
lastWriteMutations
=
[
[
"
lastStays
"
"
20
"
null
]
[
"
lastDeleted
"
"
21
"
null
]
[
"
lastClobbered
"
"
lastPre
"
null
]
[
"
lastClobbered
"
"
lastPost
"
"
lastPre
"
]
[
"
lastDeleted
"
null
"
21
"
]
]
;
const
lastWriteState
=
Object
.
assign
(
{
}
lateWriteState
{
lastStays
:
"
20
"
lastClobbered
:
"
lastPost
"
}
)
;
await
recordTabStorageEvents
(
listenerTab
lastWriteSentinel
)
;
await
recordTabStorageEvents
(
lateWriteThenListenTab
lastWriteSentinel
)
;
await
mutateTabStorage
(
writerTab
lastWriteMutations
lastWriteSentinel
)
;
await
verifyTabStorageState
(
writerTab
lastWriteState
noSentinelCheck
)
;
await
verifyTabStorageEvents
(
listenerTab
lastWriteMutations
lastWriteSentinel
)
;
await
verifyTabStorageState
(
listenerTab
lastWriteState
noSentinelCheck
)
;
await
verifyTabStorageState
(
readerTab
lastWriteState
lastWriteSentinel
)
;
await
verifyTabStorageEvents
(
lateWriteThenListenTab
lastWriteMutations
lastWriteSentinel
)
;
await
verifyTabStorageState
(
lateWriteThenListenTab
lastWriteState
noSentinelCheck
)
;
info
(
"
flush
to
make
preload
check
work
"
)
;
await
triggerAndWaitForLocalStorageFlush
(
)
;
info
(
"
late
open
preload
check
"
)
;
const
lateOpenSeesPreload
=
await
openTestTabInOwnProcess
(
HELPER_PAGE_URL
"
lateOpenSeesPreload
"
knownTabs
)
;
await
verifyTabPreload
(
lateOpenSeesPreload
true
)
;
await
cleanupTabs
(
knownTabs
)
;
clearOriginStorageEnsuringNoPreload
(
)
;
}
)
;
