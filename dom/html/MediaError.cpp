#
include
"
mozilla
/
dom
/
MediaError
.
h
"
#
include
<
string
>
#
include
<
unordered_set
>
#
include
"
mozilla
/
dom
/
MediaErrorBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
jsapi
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
MediaError
mParent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
MediaError
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
MediaError
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MediaError
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
MediaError
:
:
MediaError
(
HTMLMediaElement
*
aParent
uint16_t
aCode
const
nsACString
&
aMessage
)
:
mParent
(
aParent
)
mCode
(
aCode
)
mMessage
(
aMessage
)
{
}
void
MediaError
:
:
GetMessage
(
nsAString
&
aResult
)
const
{
static
const
std
:
:
unordered_set
<
std
:
:
string
>
whitelist
=
{
"
404
:
Not
Found
"
}
;
bool
shouldBlank
=
(
whitelist
.
find
(
mMessage
.
get
(
)
)
=
=
whitelist
.
end
(
)
)
;
if
(
shouldBlank
)
{
nsAutoCString
message
=
NS_LITERAL_CSTRING
(
"
This
error
message
will
be
blank
when
"
"
privacy
.
resistFingerprinting
=
true
.
"
"
If
it
is
really
necessary
please
add
it
to
the
whitelist
in
"
"
MediaError
:
:
GetMessage
:
"
)
+
mMessage
;
Document
*
ownerDoc
=
mParent
-
>
OwnerDoc
(
)
;
AutoJSAPI
api
;
if
(
api
.
Init
(
ownerDoc
-
>
GetScopeObject
(
)
)
)
{
JS_ReportWarningASCII
(
api
.
cx
(
)
"
%
s
"
message
.
get
(
)
)
;
}
else
{
nsContentUtils
:
:
ReportToConsoleNonLocalized
(
NS_ConvertASCIItoUTF16
(
message
)
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
MediaError
"
)
ownerDoc
)
;
}
}
if
(
!
nsContentUtils
:
:
IsCallerChrome
(
)
&
&
nsContentUtils
:
:
ShouldResistFingerprinting
(
mParent
-
>
OwnerDoc
(
)
)
&
&
shouldBlank
)
{
aResult
.
Truncate
(
)
;
return
;
}
CopyUTF8toUTF16
(
mMessage
aResult
)
;
}
JSObject
*
MediaError
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MediaError_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
