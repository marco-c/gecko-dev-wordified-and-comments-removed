#
include
"
mozilla
/
dom
/
HTMLTableElement
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCollectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTableElementBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
jsfriendapi
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Table
)
namespace
mozilla
{
namespace
dom
{
class
TableRowsCollection
final
:
public
nsIHTMLCollection
public
nsStubMutationObserver
public
nsWrapperCache
{
public
:
explicit
TableRowsCollection
(
HTMLTableElement
*
aParent
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
virtual
uint32_t
Length
(
)
override
;
virtual
Element
*
GetElementAt
(
uint32_t
aIndex
)
override
;
virtual
nsINode
*
GetParentObject
(
)
override
{
return
mParent
;
}
virtual
Element
*
GetFirstNamedElement
(
const
nsAString
&
aName
bool
&
aFound
)
override
;
virtual
void
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
override
;
NS_IMETHOD
ParentDestroyed
(
)
;
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
TableRowsCollection
nsIHTMLCollection
)
using
nsWrapperCache
:
:
GetWrapperPreserveColor
;
using
nsWrapperCache
:
:
PreserveWrapper
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
protected
:
void
CleanUp
(
)
;
void
LastRelease
(
)
{
CleanUp
(
)
;
}
virtual
~
TableRowsCollection
(
)
{
CleanUp
(
)
;
}
virtual
JSObject
*
GetWrapperPreserveColorInternal
(
)
override
{
return
nsWrapperCache
:
:
GetWrapperPreserveColor
(
)
;
}
virtual
void
PreserveWrapperInternal
(
nsISupports
*
aScriptObjectHolder
)
override
{
nsWrapperCache
:
:
PreserveWrapper
(
aScriptObjectHolder
)
;
}
void
EnsureInitialized
(
)
;
bool
InterestingContainer
(
nsIContent
*
aContainer
)
;
bool
IsAppropriateRow
(
nsAtom
*
aSection
nsIContent
*
aContent
)
;
nsIContent
*
PreviousRow
(
nsAtom
*
aSection
nsIContent
*
aCurrent
)
;
int32_t
HandleInsert
(
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
aIndexGuess
=
-
1
)
;
HTMLTableElement
*
mParent
;
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
mRows
;
uint32_t
mBodyStart
;
uint32_t
mFootStart
;
bool
mInitialized
;
}
;
TableRowsCollection
:
:
TableRowsCollection
(
HTMLTableElement
*
aParent
)
:
mParent
(
aParent
)
mBodyStart
(
0
)
mFootStart
(
0
)
mInitialized
(
false
)
{
MOZ_ASSERT
(
mParent
)
;
}
void
TableRowsCollection
:
:
EnsureInitialized
(
)
{
if
(
mInitialized
)
{
return
;
}
mInitialized
=
true
;
AutoTArray
<
nsCOMPtr
<
nsIContent
>
32
>
body
;
AutoTArray
<
nsCOMPtr
<
nsIContent
>
32
>
foot
;
mRows
.
Clear
(
)
;
auto
addRowChildren
=
[
&
]
(
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
&
aArray
nsIContent
*
aNode
)
{
for
(
nsIContent
*
inner
=
aNode
-
>
nsINode
:
:
GetFirstChild
(
)
;
inner
;
inner
=
inner
-
>
GetNextSibling
(
)
)
{
if
(
inner
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
aArray
.
AppendElement
(
inner
)
;
}
}
}
;
for
(
nsIContent
*
node
=
mParent
-
>
nsINode
:
:
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
thead
)
)
{
addRowChildren
(
mRows
node
)
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tbody
)
)
{
addRowChildren
(
body
node
)
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tfoot
)
)
{
addRowChildren
(
foot
node
)
;
}
else
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
body
.
AppendElement
(
node
)
;
}
}
mBodyStart
=
mRows
.
Length
(
)
;
mRows
.
AppendElements
(
std
:
:
move
(
body
)
)
;
mFootStart
=
mRows
.
Length
(
)
;
mRows
.
AppendElements
(
std
:
:
move
(
foot
)
)
;
mParent
-
>
AddMutationObserver
(
this
)
;
}
void
TableRowsCollection
:
:
CleanUp
(
)
{
if
(
mInitialized
&
&
mParent
)
{
mParent
-
>
RemoveMutationObserver
(
this
)
;
}
mRows
.
Clear
(
)
;
mBodyStart
=
0
;
mFootStart
=
0
;
mInitialized
=
true
;
mParent
=
nullptr
;
}
JSObject
*
TableRowsCollection
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLCollection_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
TableRowsCollection
mRows
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TableRowsCollection
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
TableRowsCollection
LastRelease
(
)
)
NS_INTERFACE_TABLE_HEAD
(
TableRowsCollection
)
NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY
NS_INTERFACE_TABLE
(
TableRowsCollection
nsIHTMLCollection
nsIMutationObserver
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
TableRowsCollection
)
NS_INTERFACE_MAP_END
uint32_t
TableRowsCollection
:
:
Length
(
)
{
EnsureInitialized
(
)
;
return
mRows
.
Length
(
)
;
}
Element
*
TableRowsCollection
:
:
GetElementAt
(
uint32_t
aIndex
)
{
EnsureInitialized
(
)
;
if
(
aIndex
<
mRows
.
Length
(
)
)
{
return
mRows
[
aIndex
]
-
>
AsElement
(
)
;
}
return
nullptr
;
}
Element
*
TableRowsCollection
:
:
GetFirstNamedElement
(
const
nsAString
&
aName
bool
&
aFound
)
{
EnsureInitialized
(
)
;
aFound
=
false
;
RefPtr
<
nsAtom
>
nameAtom
=
NS_Atomize
(
aName
)
;
NS_ENSURE_TRUE
(
nameAtom
nullptr
)
;
for
(
auto
&
node
:
mRows
)
{
if
(
node
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nameAtom
eCaseMatters
)
|
|
node
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
id
nameAtom
eCaseMatters
)
)
{
aFound
=
true
;
return
node
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
void
TableRowsCollection
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
{
EnsureInitialized
(
)
;
for
(
auto
&
node
:
mRows
)
{
if
(
node
-
>
HasID
(
)
)
{
nsAtom
*
idAtom
=
node
-
>
GetID
(
)
;
MOZ_ASSERT
(
idAtom
!
=
nsGkAtoms
:
:
_empty
"
Empty
ids
don
'
t
get
atomized
"
)
;
nsDependentAtomString
idStr
(
idAtom
)
;
if
(
!
aNames
.
Contains
(
idStr
)
)
{
aNames
.
AppendElement
(
idStr
)
;
}
}
nsGenericHTMLElement
*
el
=
nsGenericHTMLElement
:
:
FromNode
(
node
)
;
if
(
el
)
{
const
nsAttrValue
*
val
=
el
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
;
if
(
val
&
&
val
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
)
{
nsAtom
*
nameAtom
=
val
-
>
GetAtomValue
(
)
;
MOZ_ASSERT
(
nameAtom
!
=
nsGkAtoms
:
:
_empty
"
Empty
names
don
'
t
get
atomized
"
)
;
nsDependentAtomString
nameStr
(
nameAtom
)
;
if
(
!
aNames
.
Contains
(
nameStr
)
)
{
aNames
.
AppendElement
(
nameStr
)
;
}
}
}
}
}
NS_IMETHODIMP
TableRowsCollection
:
:
ParentDestroyed
(
)
{
CleanUp
(
)
;
return
NS_OK
;
}
bool
TableRowsCollection
:
:
InterestingContainer
(
nsIContent
*
aContainer
)
{
return
mParent
&
&
aContainer
&
&
(
aContainer
=
=
mParent
|
|
(
aContainer
-
>
GetParent
(
)
=
=
mParent
&
&
aContainer
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
)
)
)
;
}
bool
TableRowsCollection
:
:
IsAppropriateRow
(
nsAtom
*
aSection
nsIContent
*
aContent
)
{
if
(
!
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
return
false
;
}
nsIContent
*
parent
=
aContent
-
>
GetParent
(
)
;
if
(
aSection
=
=
nsGkAtoms
:
:
tbody
&
&
parent
=
=
mParent
)
{
return
true
;
}
return
parent
-
>
IsHTMLElement
(
aSection
)
;
}
nsIContent
*
TableRowsCollection
:
:
PreviousRow
(
nsAtom
*
aSection
nsIContent
*
aCurrent
)
{
nsIContent
*
prev
=
aCurrent
;
do
{
nsIContent
*
parent
=
prev
-
>
GetParent
(
)
;
prev
=
prev
-
>
GetPreviousSibling
(
)
;
if
(
!
prev
&
&
parent
!
=
mParent
)
{
prev
=
parent
-
>
GetPreviousSibling
(
)
;
}
if
(
prev
&
&
prev
-
>
GetParent
(
)
=
=
mParent
&
&
prev
-
>
IsHTMLElement
(
aSection
)
)
{
prev
=
prev
-
>
GetLastChild
(
)
;
}
}
while
(
prev
&
&
!
IsAppropriateRow
(
aSection
prev
)
)
;
return
prev
;
}
int32_t
TableRowsCollection
:
:
HandleInsert
(
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
aIndexGuess
)
{
if
(
!
nsContentUtils
:
:
IsInSameAnonymousTree
(
mParent
aChild
)
)
{
return
aIndexGuess
;
}
if
(
aContainer
=
=
mParent
&
&
aChild
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
)
)
{
bool
isTBody
=
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tbody
)
;
int32_t
indexGuess
=
isTBody
?
aIndexGuess
:
-
1
;
for
(
nsIContent
*
inner
=
aChild
-
>
GetFirstChild
(
)
;
inner
;
inner
=
inner
-
>
GetNextSibling
(
)
)
{
indexGuess
=
HandleInsert
(
aChild
inner
indexGuess
)
;
}
return
isTBody
?
indexGuess
:
-
1
;
}
if
(
!
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
return
aIndexGuess
;
}
nsAtom
*
section
=
aContainer
=
=
mParent
?
nsGkAtoms
:
:
tbody
:
aContainer
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
size_t
index
=
0
;
if
(
section
=
=
nsGkAtoms
:
:
thead
)
{
mBodyStart
+
+
;
mFootStart
+
+
;
}
else
if
(
section
=
=
nsGkAtoms
:
:
tbody
)
{
index
=
mBodyStart
;
mFootStart
+
+
;
}
else
if
(
section
=
=
nsGkAtoms
:
:
tfoot
)
{
index
=
mFootStart
;
}
else
{
MOZ_ASSERT
(
false
"
section
should
be
one
of
thead
tbody
or
tfoot
"
)
;
}
if
(
aIndexGuess
>
=
0
)
{
index
=
aIndexGuess
;
}
else
{
nsIContent
*
insertAfter
=
PreviousRow
(
section
aChild
)
;
if
(
insertAfter
)
{
index
=
mRows
.
LastIndexOf
(
insertAfter
)
+
1
;
MOZ_ASSERT
(
index
!
=
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
:
:
NoIndex
)
;
}
}
#
ifdef
DEBUG
if
(
section
=
=
nsGkAtoms
:
:
thead
)
{
MOZ_ASSERT
(
index
<
mBodyStart
)
;
}
else
if
(
section
=
=
nsGkAtoms
:
:
tbody
)
{
MOZ_ASSERT
(
index
>
=
mBodyStart
)
;
MOZ_ASSERT
(
index
<
mFootStart
)
;
}
else
if
(
section
=
=
nsGkAtoms
:
:
tfoot
)
{
MOZ_ASSERT
(
index
>
=
mFootStart
)
;
MOZ_ASSERT
(
index
<
=
mRows
.
Length
(
)
)
;
}
MOZ_ASSERT
(
mBodyStart
<
=
mFootStart
)
;
MOZ_ASSERT
(
mFootStart
<
=
mRows
.
Length
(
)
+
1
)
;
#
endif
mRows
.
InsertElementAt
(
index
aChild
)
;
return
index
+
1
;
}
void
TableRowsCollection
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
nsIContent
*
container
=
aFirstNewContent
-
>
GetParent
(
)
;
if
(
!
nsContentUtils
:
:
IsInSameAnonymousTree
(
mParent
aFirstNewContent
)
|
|
!
InterestingContainer
(
container
)
)
{
return
;
}
int32_t
indexGuess
=
mParent
=
=
container
?
mFootStart
:
-
1
;
for
(
nsIContent
*
content
=
aFirstNewContent
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
indexGuess
=
HandleInsert
(
container
content
indexGuess
)
;
}
}
void
TableRowsCollection
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
if
(
!
nsContentUtils
:
:
IsInSameAnonymousTree
(
mParent
aChild
)
|
|
!
InterestingContainer
(
aChild
-
>
GetParent
(
)
)
)
{
return
;
}
HandleInsert
(
aChild
-
>
GetParent
(
)
aChild
)
;
}
void
TableRowsCollection
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
!
nsContentUtils
:
:
IsInSameAnonymousTree
(
mParent
aChild
)
|
|
!
InterestingContainer
(
aChild
-
>
GetParent
(
)
)
)
{
return
;
}
if
(
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
)
{
size_t
index
=
mRows
.
IndexOf
(
aChild
)
;
if
(
index
!
=
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
:
:
NoIndex
)
{
mRows
.
RemoveElementAt
(
index
)
;
if
(
mBodyStart
>
index
)
{
mBodyStart
-
-
;
}
if
(
mFootStart
>
index
)
{
mFootStart
-
-
;
}
}
return
;
}
if
(
!
aChild
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
)
)
{
return
;
}
size_t
beforeLength
=
mRows
.
Length
(
)
;
mRows
.
RemoveElementsBy
(
[
&
]
(
nsIContent
*
element
)
{
return
element
-
>
GetParent
(
)
=
=
aChild
;
}
)
;
size_t
removed
=
beforeLength
-
mRows
.
Length
(
)
;
if
(
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
thead
)
)
{
mBodyStart
-
=
removed
;
mFootStart
-
=
removed
;
}
else
if
(
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tbody
)
)
{
mFootStart
-
=
removed
;
}
}
void
TableRowsCollection
:
:
NodeWillBeDestroyed
(
const
nsINode
*
aNode
)
{
mInitialized
=
false
;
CleanUp
(
)
;
}
HTMLTableElement
:
:
HTMLTableElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsGenericHTMLElement
(
aNodeInfo
)
mTableInheritedAttributes
(
nullptr
)
{
SetHasWeirdParserInsertionMode
(
)
;
}
HTMLTableElement
:
:
~
HTMLTableElement
(
)
{
if
(
mRows
)
{
mRows
-
>
ParentDestroyed
(
)
;
}
ReleaseInheritedAttributes
(
)
;
}
JSObject
*
HTMLTableElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLTableElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLTableElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLTableElement
nsGenericHTMLElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTBodies
)
if
(
tmp
-
>
mRows
)
{
tmp
-
>
mRows
-
>
ParentDestroyed
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRows
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLTableElement
nsGenericHTMLElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTBodies
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRows
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
HTMLTableElement
nsGenericHTMLElement
)
NS_IMPL_ELEMENT_CLONE
(
HTMLTableElement
)
nsIHTMLCollection
*
HTMLTableElement
:
:
Rows
(
)
{
if
(
!
mRows
)
{
mRows
=
new
TableRowsCollection
(
this
)
;
}
return
mRows
;
}
nsIHTMLCollection
*
HTMLTableElement
:
:
TBodies
(
)
{
if
(
!
mTBodies
)
{
mTBodies
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tbody
false
)
;
}
return
mTBodies
;
}
already_AddRefed
<
nsGenericHTMLElement
>
HTMLTableElement
:
:
CreateTHead
(
)
{
RefPtr
<
nsGenericHTMLElement
>
head
=
GetTHead
(
)
;
if
(
!
head
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nsContentUtils
:
:
QNameChanged
(
mNodeInfo
nsGkAtoms
:
:
thead
getter_AddRefs
(
nodeInfo
)
)
;
head
=
NS_NewHTMLTableSectionElement
(
nodeInfo
.
forget
(
)
)
;
if
(
!
head
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
refNode
=
nullptr
;
for
(
refNode
=
nsINode
:
:
GetFirstChild
(
)
;
refNode
;
refNode
=
refNode
-
>
GetNextSibling
(
)
)
{
if
(
refNode
-
>
IsHTMLElement
(
)
&
&
!
refNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
caption
)
&
&
!
refNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
colgroup
)
)
{
break
;
}
}
nsINode
:
:
InsertBefore
(
*
head
refNode
IgnoreErrors
(
)
)
;
}
return
head
.
forget
(
)
;
}
void
HTMLTableElement
:
:
DeleteTHead
(
)
{
HTMLTableSectionElement
*
tHead
=
GetTHead
(
)
;
if
(
tHead
)
{
mozilla
:
:
ErrorResult
rv
;
nsINode
:
:
RemoveChild
(
*
tHead
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
)
;
}
}
already_AddRefed
<
nsGenericHTMLElement
>
HTMLTableElement
:
:
CreateTFoot
(
)
{
RefPtr
<
nsGenericHTMLElement
>
foot
=
GetTFoot
(
)
;
if
(
!
foot
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nsContentUtils
:
:
QNameChanged
(
mNodeInfo
nsGkAtoms
:
:
tfoot
getter_AddRefs
(
nodeInfo
)
)
;
foot
=
NS_NewHTMLTableSectionElement
(
nodeInfo
.
forget
(
)
)
;
if
(
!
foot
)
{
return
nullptr
;
}
AppendChildTo
(
foot
true
)
;
}
return
foot
.
forget
(
)
;
}
void
HTMLTableElement
:
:
DeleteTFoot
(
)
{
HTMLTableSectionElement
*
tFoot
=
GetTFoot
(
)
;
if
(
tFoot
)
{
mozilla
:
:
ErrorResult
rv
;
nsINode
:
:
RemoveChild
(
*
tFoot
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
)
;
}
}
already_AddRefed
<
nsGenericHTMLElement
>
HTMLTableElement
:
:
CreateCaption
(
)
{
RefPtr
<
nsGenericHTMLElement
>
caption
=
GetCaption
(
)
;
if
(
!
caption
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nsContentUtils
:
:
QNameChanged
(
mNodeInfo
nsGkAtoms
:
:
caption
getter_AddRefs
(
nodeInfo
)
)
;
caption
=
NS_NewHTMLTableCaptionElement
(
nodeInfo
.
forget
(
)
)
;
if
(
!
caption
)
{
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
firsChild
=
nsINode
:
:
GetFirstChild
(
)
;
nsINode
:
:
InsertBefore
(
*
caption
firsChild
IgnoreErrors
(
)
)
;
}
return
caption
.
forget
(
)
;
}
void
HTMLTableElement
:
:
DeleteCaption
(
)
{
HTMLTableCaptionElement
*
caption
=
GetCaption
(
)
;
if
(
caption
)
{
mozilla
:
:
ErrorResult
rv
;
nsINode
:
:
RemoveChild
(
*
caption
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
)
;
}
}
already_AddRefed
<
nsGenericHTMLElement
>
HTMLTableElement
:
:
CreateTBody
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
tbody
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
MOZ_ASSERT
(
nodeInfo
)
;
RefPtr
<
nsGenericHTMLElement
>
newBody
=
NS_NewHTMLTableSectionElement
(
nodeInfo
.
forget
(
)
)
;
MOZ_ASSERT
(
newBody
)
;
nsCOMPtr
<
nsIContent
>
referenceNode
=
nullptr
;
for
(
nsIContent
*
child
=
nsINode
:
:
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tbody
)
)
{
referenceNode
=
child
-
>
GetNextSibling
(
)
;
break
;
}
}
nsINode
:
:
InsertBefore
(
*
newBody
referenceNode
IgnoreErrors
(
)
)
;
return
newBody
.
forget
(
)
;
}
already_AddRefed
<
nsGenericHTMLElement
>
HTMLTableElement
:
:
InsertRow
(
int32_t
aIndex
ErrorResult
&
aError
)
{
if
(
aIndex
<
-
1
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
nsIHTMLCollection
*
rows
=
Rows
(
)
;
uint32_t
rowCount
=
rows
-
>
Length
(
)
;
if
(
(
uint32_t
)
aIndex
>
rowCount
&
&
aIndex
!
=
-
1
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
uint32_t
refIndex
=
(
uint32_t
)
aIndex
;
RefPtr
<
nsGenericHTMLElement
>
newRow
;
if
(
rowCount
>
0
)
{
if
(
refIndex
=
=
rowCount
|
|
aIndex
=
=
-
1
)
{
refIndex
=
rowCount
-
1
;
}
RefPtr
<
Element
>
refRow
=
rows
-
>
Item
(
refIndex
)
;
nsCOMPtr
<
nsINode
>
parent
=
refRow
-
>
GetParentNode
(
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nsContentUtils
:
:
QNameChanged
(
mNodeInfo
nsGkAtoms
:
:
tr
getter_AddRefs
(
nodeInfo
)
)
;
newRow
=
NS_NewHTMLTableRowElement
(
nodeInfo
.
forget
(
)
)
;
if
(
newRow
)
{
if
(
aIndex
=
=
-
1
|
|
uint32_t
(
aIndex
)
=
=
rowCount
)
{
parent
-
>
AppendChild
(
*
newRow
aError
)
;
}
else
{
parent
-
>
InsertBefore
(
*
newRow
refRow
aError
)
;
}
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
else
{
nsCOMPtr
<
nsIContent
>
rowGroup
;
for
(
nsIContent
*
child
=
nsINode
:
:
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tbody
)
)
{
rowGroup
=
child
;
break
;
}
}
if
(
!
rowGroup
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nsContentUtils
:
:
QNameChanged
(
mNodeInfo
nsGkAtoms
:
:
tbody
getter_AddRefs
(
nodeInfo
)
)
;
rowGroup
=
NS_NewHTMLTableSectionElement
(
nodeInfo
.
forget
(
)
)
;
if
(
rowGroup
)
{
aError
=
AppendChildTo
(
rowGroup
true
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
if
(
rowGroup
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nsContentUtils
:
:
QNameChanged
(
mNodeInfo
nsGkAtoms
:
:
tr
getter_AddRefs
(
nodeInfo
)
)
;
newRow
=
NS_NewHTMLTableRowElement
(
nodeInfo
.
forget
(
)
)
;
if
(
newRow
)
{
HTMLTableSectionElement
*
section
=
static_cast
<
HTMLTableSectionElement
*
>
(
rowGroup
.
get
(
)
)
;
nsIHTMLCollection
*
rows
=
section
-
>
Rows
(
)
;
nsCOMPtr
<
nsINode
>
refNode
=
rows
-
>
Item
(
0
)
;
rowGroup
-
>
InsertBefore
(
*
newRow
refNode
aError
)
;
}
}
}
return
newRow
.
forget
(
)
;
}
void
HTMLTableElement
:
:
DeleteRow
(
int32_t
aIndex
ErrorResult
&
aError
)
{
if
(
aIndex
<
-
1
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
nsIHTMLCollection
*
rows
=
Rows
(
)
;
uint32_t
refIndex
;
if
(
aIndex
=
=
-
1
)
{
refIndex
=
rows
-
>
Length
(
)
;
if
(
refIndex
=
=
0
)
{
return
;
}
-
-
refIndex
;
}
else
{
refIndex
=
(
uint32_t
)
aIndex
;
}
nsCOMPtr
<
nsIContent
>
row
=
rows
-
>
Item
(
refIndex
)
;
if
(
!
row
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
row
-
>
RemoveFromParent
(
)
;
}
bool
HTMLTableElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
cellspacing
|
|
aAttribute
=
=
nsGkAtoms
:
:
cellpadding
|
|
aAttribute
=
=
nsGkAtoms
:
:
border
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
)
{
if
(
aResult
.
ParseSpecialIntValue
(
aValue
)
)
{
nsAttrValue
:
:
ValueType
type
=
aResult
.
Type
(
)
;
return
!
(
(
type
=
=
nsAttrValue
:
:
eInteger
&
&
aResult
.
GetIntegerValue
(
)
=
=
0
)
|
|
(
type
=
=
nsAttrValue
:
:
ePercent
&
&
aResult
.
GetPercentValue
(
)
=
=
0
.
0f
)
)
;
}
return
false
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseTableHAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
bgcolor
|
|
aAttribute
=
=
nsGkAtoms
:
:
bordercolor
)
{
return
aResult
.
ParseColor
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
hspace
|
|
aAttribute
=
=
nsGkAtoms
:
:
vspace
)
{
return
aResult
.
ParseIntWithBounds
(
aValue
0
)
;
}
}
return
nsGenericHTMLElement
:
:
ParseBackgroundAttribute
(
aNamespaceID
aAttribute
aValue
aResult
)
|
|
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLTableElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
nsCompatibility
mode
=
aDecls
.
Document
(
)
-
>
GetCompatibilityMode
(
)
;
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
cellspacing
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
&
&
!
aDecls
.
PropertyIsSet
(
eCSSProperty_border_spacing
)
)
{
aDecls
.
SetPixelValue
(
eCSSProperty_border_spacing
float
(
value
-
>
GetIntegerValue
(
)
)
)
;
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
align
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
if
(
value
-
>
GetEnumValue
(
)
=
=
NS_STYLE_TEXT_ALIGN_CENTER
|
|
value
-
>
GetEnumValue
(
)
=
=
NS_STYLE_TEXT_ALIGN_MOZ_CENTER
)
{
aDecls
.
SetAutoValueIfUnset
(
eCSSProperty_margin_left
)
;
aDecls
.
SetAutoValueIfUnset
(
eCSSProperty_margin_right
)
;
}
}
if
(
eCompatibility_NavQuirks
=
=
mode
)
{
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
hspace
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_margin_left
(
float
)
value
-
>
GetIntegerValue
(
)
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_margin_right
(
float
)
value
-
>
GetIntegerValue
(
)
)
;
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
vspace
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_margin_top
(
float
)
value
-
>
GetIntegerValue
(
)
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_margin_bottom
(
float
)
value
-
>
GetIntegerValue
(
)
)
;
}
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
bordercolor
)
;
nscolor
color
;
if
(
value
&
&
value
-
>
GetColorValue
(
color
)
)
{
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_border_top_color
color
)
;
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_border_left_color
color
)
;
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_border_bottom_color
color
)
;
aDecls
.
SetColorValueIfUnset
(
eCSSProperty_border_right_color
color
)
;
}
const
nsAttrValue
*
borderValue
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
border
)
;
if
(
borderValue
)
{
int32_t
borderThickness
=
1
;
if
(
borderValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
borderThickness
=
borderValue
-
>
GetIntegerValue
(
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_top_width
(
float
)
borderThickness
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_left_width
(
float
)
borderThickness
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_bottom_width
(
float
)
borderThickness
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_right_width
(
float
)
borderThickness
)
;
}
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapBackgroundAttributesInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
aAttributes
aDecls
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTableElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
attributes
[
]
=
{
{
&
nsGkAtoms
:
:
cellpadding
}
{
&
nsGkAtoms
:
:
cellspacing
}
{
&
nsGkAtoms
:
:
border
}
{
&
nsGkAtoms
:
:
width
}
{
&
nsGkAtoms
:
:
height
}
{
&
nsGkAtoms
:
:
hspace
}
{
&
nsGkAtoms
:
:
vspace
}
{
&
nsGkAtoms
:
:
bordercolor
}
{
&
nsGkAtoms
:
:
align
}
{
nullptr
}
}
;
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
attributes
sCommonAttributeMap
sBackgroundAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLTableElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
static
void
MapInheritedTableAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
cellpadding
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
float
pad
=
float
(
value
-
>
GetIntegerValue
(
)
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_padding_top
pad
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_padding_right
pad
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_padding_bottom
pad
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_padding_left
pad
)
;
}
}
nsMappedAttributes
*
HTMLTableElement
:
:
GetAttributesMappedForCell
(
)
{
return
mTableInheritedAttributes
;
}
void
HTMLTableElement
:
:
BuildInheritedAttributes
(
)
{
NS_ASSERTION
(
!
mTableInheritedAttributes
"
potential
leak
plus
waste
of
work
"
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsIDocument
*
document
=
GetComposedDoc
(
)
;
nsHTMLStyleSheet
*
sheet
=
document
?
document
-
>
GetAttributeStyleSheet
(
)
:
nullptr
;
RefPtr
<
nsMappedAttributes
>
newAttrs
;
if
(
sheet
)
{
const
nsAttrValue
*
value
=
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
cellpadding
)
;
if
(
value
)
{
RefPtr
<
nsMappedAttributes
>
modifiableMapped
=
new
nsMappedAttributes
(
sheet
MapInheritedTableAttributesIntoRule
)
;
if
(
modifiableMapped
)
{
nsAttrValue
val
(
*
value
)
;
bool
oldValueSet
;
modifiableMapped
-
>
SetAndSwapAttr
(
nsGkAtoms
:
:
cellpadding
val
&
oldValueSet
)
;
}
newAttrs
=
sheet
-
>
UniqueMappedAttributes
(
modifiableMapped
)
;
NS_ASSERTION
(
newAttrs
"
out
of
memory
but
handling
gracefully
"
)
;
if
(
newAttrs
!
=
modifiableMapped
)
{
modifiableMapped
-
>
DropStyleSheetReference
(
)
;
}
}
mTableInheritedAttributes
=
newAttrs
;
NS_IF_ADDREF
(
mTableInheritedAttributes
)
;
}
}
void
HTMLTableElement
:
:
ReleaseInheritedAttributes
(
)
{
NS_IF_RELEASE
(
mTableInheritedAttributes
)
;
}
nsresult
HTMLTableElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
ReleaseInheritedAttributes
(
)
;
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
BuildInheritedAttributes
(
)
;
return
NS_OK
;
}
void
HTMLTableElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
ReleaseInheritedAttributes
(
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
}
nsresult
HTMLTableElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aName
=
=
nsGkAtoms
:
:
cellpadding
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
ReleaseInheritedAttributes
(
)
;
}
return
nsGenericHTMLElement
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLTableElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aName
=
=
nsGkAtoms
:
:
cellpadding
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
BuildInheritedAttributes
(
)
;
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
}
}
