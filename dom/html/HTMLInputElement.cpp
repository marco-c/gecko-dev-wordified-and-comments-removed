#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
Date
.
h
"
#
include
"
mozilla
/
dom
/
Directory
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormSubmission
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemUtils
.
h
"
#
include
"
mozilla
/
dom
/
GetFilesHelper
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsIDOMHTMLInputElement
.
h
"
#
include
"
nsITextControlElement
.
h
"
#
include
"
nsIDOMNSEditableElement
.
h
"
#
include
"
nsIRadioVisitor
.
h
"
#
include
"
nsIPhonetic
.
h
"
#
include
"
HTMLFormSubmissionConstants
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsColorControlFrame
.
h
"
#
include
"
nsNumberControlFrame
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsRepeatService
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIDOMHTMLFormElement
.
h
"
#
include
"
mozilla
/
dom
/
ProgressEvent
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIFormControlFrame
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsRangeFrame
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsDocument
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
nsDateTimeControlFrame
.
h
"
#
include
"
nsPresState
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsIDOMNodeList
.
h
"
#
include
"
nsIDOMHTMLCollection
.
h
"
#
include
"
nsLinebreakConverter
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsIDOMMutationEvent
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
nsRuleData
.
h
"
#
include
<
algorithm
>
#
include
"
nsIRadioGroupContainer
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemEntry
.
h
"
#
include
"
mozilla
/
dom
/
FileSystem
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
FileList
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIContentPrefService
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPopupWindowManager
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsImageLoadingContent
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
nsRadioVisitor
.
h
"
#
include
"
nsTextEditorState
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
<
limits
>
#
include
"
nsIColorPicker
.
h
"
#
include
"
nsIDatePicker
.
h
"
#
include
"
nsIStringEnumerator
.
h
"
#
include
"
HTMLSplitOnSpacesTokenizer
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsIMIMEInfo
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
js
/
Date
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
Input
)
static
NS_DEFINE_CID
(
kXULControllersCID
NS_XULCONTROLLERS_CID
)
;
inline
mozilla
:
:
Decimal
NS_floorModulo
(
mozilla
:
:
Decimal
x
mozilla
:
:
Decimal
y
)
{
return
(
x
-
y
*
(
x
/
y
)
.
floor
(
)
)
;
}
namespace
mozilla
{
namespace
dom
{
#
define
NS_OUTER_ACTIVATE_EVENT
(
1
<
<
9
)
#
define
NS_ORIGINAL_CHECKED_VALUE
(
1
<
<
10
)
#
define
NS_NO_CONTENT_DISPATCH
(
1
<
<
11
)
#
define
NS_ORIGINAL_INDETERMINATE_VALUE
(
1
<
<
12
)
#
define
NS_CONTROL_TYPE
(
bits
)
(
(
bits
)
&
~
(
\
NS_OUTER_ACTIVATE_EVENT
|
NS_ORIGINAL_CHECKED_VALUE
|
NS_NO_CONTENT_DISPATCH
|
\
NS_ORIGINAL_INDETERMINATE_VALUE
)
)
#
define
NS_PRE_HANDLE_BLUR_EVENT
(
1
<
<
13
)
#
define
NS_PRE_HANDLE_INPUT_EVENT
(
1
<
<
14
)
static
int32_t
gSelectTextFieldOnFocus
;
UploadLastDir
*
HTMLInputElement
:
:
gUploadLastDir
;
static
const
nsAttrValue
:
:
EnumTable
kInputTypeTable
[
]
=
{
{
"
button
"
NS_FORM_INPUT_BUTTON
}
{
"
checkbox
"
NS_FORM_INPUT_CHECKBOX
}
{
"
color
"
NS_FORM_INPUT_COLOR
}
{
"
date
"
NS_FORM_INPUT_DATE
}
{
"
datetime
-
local
"
NS_FORM_INPUT_DATETIME_LOCAL
}
{
"
email
"
NS_FORM_INPUT_EMAIL
}
{
"
file
"
NS_FORM_INPUT_FILE
}
{
"
hidden
"
NS_FORM_INPUT_HIDDEN
}
{
"
reset
"
NS_FORM_INPUT_RESET
}
{
"
image
"
NS_FORM_INPUT_IMAGE
}
{
"
month
"
NS_FORM_INPUT_MONTH
}
{
"
number
"
NS_FORM_INPUT_NUMBER
}
{
"
password
"
NS_FORM_INPUT_PASSWORD
}
{
"
radio
"
NS_FORM_INPUT_RADIO
}
{
"
range
"
NS_FORM_INPUT_RANGE
}
{
"
search
"
NS_FORM_INPUT_SEARCH
}
{
"
submit
"
NS_FORM_INPUT_SUBMIT
}
{
"
tel
"
NS_FORM_INPUT_TEL
}
{
"
text
"
NS_FORM_INPUT_TEXT
}
{
"
time
"
NS_FORM_INPUT_TIME
}
{
"
url
"
NS_FORM_INPUT_URL
}
{
"
week
"
NS_FORM_INPUT_WEEK
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
*
kInputDefaultType
=
&
kInputTypeTable
[
18
]
;
static
const
uint8_t
NS_INPUT_INPUTMODE_AUTO
=
0
;
static
const
uint8_t
NS_INPUT_INPUTMODE_NUMERIC
=
1
;
static
const
uint8_t
NS_INPUT_INPUTMODE_DIGIT
=
2
;
static
const
uint8_t
NS_INPUT_INPUTMODE_UPPERCASE
=
3
;
static
const
uint8_t
NS_INPUT_INPUTMODE_LOWERCASE
=
4
;
static
const
uint8_t
NS_INPUT_INPUTMODE_TITLECASE
=
5
;
static
const
uint8_t
NS_INPUT_INPUTMODE_AUTOCAPITALIZED
=
6
;
static
const
nsAttrValue
:
:
EnumTable
kInputInputmodeTable
[
]
=
{
{
"
auto
"
NS_INPUT_INPUTMODE_AUTO
}
{
"
numeric
"
NS_INPUT_INPUTMODE_NUMERIC
}
{
"
digit
"
NS_INPUT_INPUTMODE_DIGIT
}
{
"
uppercase
"
NS_INPUT_INPUTMODE_UPPERCASE
}
{
"
lowercase
"
NS_INPUT_INPUTMODE_LOWERCASE
}
{
"
titlecase
"
NS_INPUT_INPUTMODE_TITLECASE
}
{
"
autocapitalized
"
NS_INPUT_INPUTMODE_AUTOCAPITALIZED
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
*
kInputDefaultInputmode
=
&
kInputInputmodeTable
[
0
]
;
const
Decimal
HTMLInputElement
:
:
kStepScaleFactorDate
=
Decimal
(
86400000
)
;
const
Decimal
HTMLInputElement
:
:
kStepScaleFactorNumberRange
=
Decimal
(
1
)
;
const
Decimal
HTMLInputElement
:
:
kStepScaleFactorTime
=
Decimal
(
1000
)
;
const
Decimal
HTMLInputElement
:
:
kStepScaleFactorMonth
=
Decimal
(
1
)
;
const
Decimal
HTMLInputElement
:
:
kStepScaleFactorWeek
=
Decimal
(
7
*
86400000
)
;
const
Decimal
HTMLInputElement
:
:
kDefaultStepBase
=
Decimal
(
0
)
;
const
Decimal
HTMLInputElement
:
:
kDefaultStepBaseWeek
=
Decimal
(
-
259200000
)
;
const
Decimal
HTMLInputElement
:
:
kDefaultStep
=
Decimal
(
1
)
;
const
Decimal
HTMLInputElement
:
:
kDefaultStepTime
=
Decimal
(
60
)
;
const
Decimal
HTMLInputElement
:
:
kStepAny
=
Decimal
(
0
)
;
const
double
HTMLInputElement
:
:
kMinimumYear
=
1
;
const
double
HTMLInputElement
:
:
kMaximumYear
=
275760
;
const
double
HTMLInputElement
:
:
kMaximumWeekInMaximumYear
=
37
;
const
double
HTMLInputElement
:
:
kMaximumDayInMaximumYear
=
13
;
const
double
HTMLInputElement
:
:
kMaximumMonthInMaximumYear
=
9
;
const
double
HTMLInputElement
:
:
kMaximumWeekInYear
=
53
;
const
double
HTMLInputElement
:
:
kMsPerDay
=
24
*
60
*
60
*
1000
;
#
define
NS_INPUT_ELEMENT_STATE_IID
\
{
/
*
dc3b3d14
-
23e2
-
4479
-
b513
-
7b369343e3a0
*
/
\
0xdc3b3d14
\
0x23e2
\
0x4479
\
{
0xb5
0x13
0x7b
0x36
0x93
0x43
0xe3
0xa0
}
\
}
#
define
PROGRESS_STR
"
progress
"
static
const
uint32_t
kProgressEventInterval
=
50
;
class
DispatchChangeEventCallback
final
:
public
GetFilesCallback
{
public
:
explicit
DispatchChangeEventCallback
(
HTMLInputElement
*
aInputElement
)
:
mInputElement
(
aInputElement
)
{
MOZ_ASSERT
(
aInputElement
)
;
}
virtual
void
Callback
(
nsresult
aStatus
const
Sequence
<
RefPtr
<
File
>
>
&
aFiles
)
override
{
nsTArray
<
OwningFileOrDirectory
>
array
;
for
(
uint32_t
i
=
0
;
i
<
aFiles
.
Length
(
)
;
+
+
i
)
{
OwningFileOrDirectory
*
element
=
array
.
AppendElement
(
)
;
element
-
>
SetAsFile
(
)
=
aFiles
[
i
]
;
}
mInputElement
-
>
SetFilesOrDirectories
(
array
true
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
DispatchEvents
(
)
)
)
;
}
nsresult
DispatchEvents
(
)
{
nsresult
rv
=
NS_OK
;
rv
=
nsContentUtils
:
:
DispatchTrustedEvent
(
mInputElement
-
>
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
mInputElement
.
get
(
)
)
NS_LITERAL_STRING
(
"
input
"
)
true
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
DispatchTrustedEvent
failed
"
)
;
rv
=
nsContentUtils
:
:
DispatchTrustedEvent
(
mInputElement
-
>
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
mInputElement
.
get
(
)
)
NS_LITERAL_STRING
(
"
change
"
)
true
false
)
;
return
rv
;
}
private
:
RefPtr
<
HTMLInputElement
>
mInputElement
;
}
;
class
HTMLInputElementState
final
:
public
nsISupports
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_INPUT_ELEMENT_STATE_IID
)
NS_DECL_ISUPPORTS
bool
IsCheckedSet
(
)
{
return
mCheckedSet
;
}
bool
GetChecked
(
)
{
return
mChecked
;
}
void
SetChecked
(
bool
aChecked
)
{
mChecked
=
aChecked
;
mCheckedSet
=
true
;
}
const
nsString
&
GetValue
(
)
{
return
mValue
;
}
void
SetValue
(
const
nsAString
&
aValue
)
{
mValue
=
aValue
;
}
void
GetFilesOrDirectories
(
nsPIDOMWindowInner
*
aWindow
nsTArray
<
OwningFileOrDirectory
>
&
aResult
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mBlobImplsOrDirectoryPaths
.
Length
(
)
;
+
+
i
)
{
if
(
mBlobImplsOrDirectoryPaths
[
i
]
.
mType
=
=
BlobImplOrDirectoryPath
:
:
eBlobImpl
)
{
RefPtr
<
File
>
file
=
File
:
:
Create
(
aWindow
mBlobImplsOrDirectoryPaths
[
i
]
.
mBlobImpl
)
;
MOZ_ASSERT
(
file
)
;
OwningFileOrDirectory
*
element
=
aResult
.
AppendElement
(
)
;
element
-
>
SetAsFile
(
)
=
file
;
}
else
{
MOZ_ASSERT
(
mBlobImplsOrDirectoryPaths
[
i
]
.
mType
=
=
BlobImplOrDirectoryPath
:
:
eDirectoryPath
)
;
nsCOMPtr
<
nsIFile
>
file
;
NS_ConvertUTF16toUTF8
path
(
mBlobImplsOrDirectoryPaths
[
i
]
.
mDirectoryPath
)
;
nsresult
rv
=
NS_NewNativeLocalFile
(
path
true
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
RefPtr
<
Directory
>
directory
=
Directory
:
:
Create
(
aWindow
file
)
;
MOZ_ASSERT
(
directory
)
;
OwningFileOrDirectory
*
element
=
aResult
.
AppendElement
(
)
;
element
-
>
SetAsDirectory
(
)
=
directory
;
}
}
}
void
SetFilesOrDirectories
(
const
nsTArray
<
OwningFileOrDirectory
>
&
aArray
)
{
mBlobImplsOrDirectoryPaths
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aArray
.
Length
(
)
;
+
+
i
)
{
if
(
aArray
[
i
]
.
IsFile
(
)
)
{
BlobImplOrDirectoryPath
*
data
=
mBlobImplsOrDirectoryPaths
.
AppendElement
(
)
;
RefPtr
<
File
>
file
=
aArray
[
i
]
.
GetAsFile
(
)
;
nsAutoString
name
;
file
-
>
GetName
(
name
)
;
nsAutoString
path
;
path
.
AssignLiteral
(
FILESYSTEM_DOM_PATH_SEPARATOR_LITERAL
)
;
path
.
Append
(
name
)
;
file
-
>
SetPath
(
path
)
;
data
-
>
mBlobImpl
=
file
-
>
Impl
(
)
;
data
-
>
mType
=
BlobImplOrDirectoryPath
:
:
eBlobImpl
;
}
else
{
MOZ_ASSERT
(
aArray
[
i
]
.
IsDirectory
(
)
)
;
nsAutoString
fullPath
;
nsresult
rv
=
aArray
[
i
]
.
GetAsDirectory
(
)
-
>
GetFullRealPath
(
fullPath
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
BlobImplOrDirectoryPath
*
data
=
mBlobImplsOrDirectoryPaths
.
AppendElement
(
)
;
data
-
>
mDirectoryPath
=
fullPath
;
data
-
>
mType
=
BlobImplOrDirectoryPath
:
:
eDirectoryPath
;
}
}
}
HTMLInputElementState
(
)
:
mValue
(
)
mChecked
(
false
)
mCheckedSet
(
false
)
{
}
protected
:
~
HTMLInputElementState
(
)
{
}
nsString
mValue
;
struct
BlobImplOrDirectoryPath
{
RefPtr
<
BlobImpl
>
mBlobImpl
;
nsString
mDirectoryPath
;
enum
{
eBlobImpl
eDirectoryPath
}
mType
;
}
;
nsTArray
<
BlobImplOrDirectoryPath
>
mBlobImplsOrDirectoryPaths
;
bool
mChecked
;
bool
mCheckedSet
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
HTMLInputElementState
NS_INPUT_ELEMENT_STATE_IID
)
NS_IMPL_ISUPPORTS
(
HTMLInputElementState
HTMLInputElementState
)
HTMLInputElement
:
:
nsFilePickerShownCallback
:
:
nsFilePickerShownCallback
(
HTMLInputElement
*
aInput
nsIFilePicker
*
aFilePicker
)
:
mFilePicker
(
aFilePicker
)
mInput
(
aInput
)
{
}
NS_IMPL_ISUPPORTS
(
UploadLastDir
:
:
ContentPrefCallback
nsIContentPrefCallback2
)
NS_IMETHODIMP
UploadLastDir
:
:
ContentPrefCallback
:
:
HandleCompletion
(
uint16_t
aReason
)
{
nsCOMPtr
<
nsIFile
>
localFile
;
nsAutoString
prefStr
;
if
(
aReason
=
=
nsIContentPrefCallback2
:
:
COMPLETE_ERROR
|
|
!
mResult
)
{
prefStr
=
Preferences
:
:
GetString
(
"
dom
.
input
.
fallbackUploadDir
"
)
;
if
(
prefStr
.
IsEmpty
(
)
)
{
NS_GetSpecialDirectory
(
NS_OS_DESKTOP_DIR
getter_AddRefs
(
localFile
)
)
;
}
}
if
(
!
localFile
)
{
if
(
prefStr
.
IsEmpty
(
)
&
&
mResult
)
{
nsCOMPtr
<
nsIVariant
>
pref
;
mResult
-
>
GetValue
(
getter_AddRefs
(
pref
)
)
;
pref
-
>
GetAsAString
(
prefStr
)
;
}
localFile
=
do_CreateInstance
(
NS_LOCAL_FILE_CONTRACTID
)
;
localFile
-
>
InitWithPath
(
prefStr
)
;
}
mFilePicker
-
>
SetDisplayDirectory
(
localFile
)
;
mFilePicker
-
>
Open
(
mFpCallback
)
;
return
NS_OK
;
}
NS_IMETHODIMP
UploadLastDir
:
:
ContentPrefCallback
:
:
HandleResult
(
nsIContentPref
*
pref
)
{
mResult
=
pref
;
return
NS_OK
;
}
NS_IMETHODIMP
UploadLastDir
:
:
ContentPrefCallback
:
:
HandleError
(
nsresult
error
)
{
return
NS_OK
;
}
namespace
{
static
already_AddRefed
<
nsIFile
>
DOMFileOrDirectoryToLocalFile
(
const
OwningFileOrDirectory
&
aData
)
{
nsString
path
;
if
(
aData
.
IsFile
(
)
)
{
ErrorResult
rv
;
aData
.
GetAsFile
(
)
-
>
GetMozFullPathInternal
(
path
rv
)
;
if
(
rv
.
Failed
(
)
|
|
path
.
IsEmpty
(
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
}
else
{
MOZ_ASSERT
(
aData
.
IsDirectory
(
)
)
;
aData
.
GetAsDirectory
(
)
-
>
GetFullRealPath
(
path
)
;
}
nsCOMPtr
<
nsIFile
>
localFile
;
nsresult
rv
=
NS_NewNativeLocalFile
(
NS_ConvertUTF16toUTF8
(
path
)
true
getter_AddRefs
(
localFile
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
localFile
.
forget
(
)
;
}
void
GetDOMFileOrDirectoryName
(
const
OwningFileOrDirectory
&
aData
nsAString
&
aName
)
{
if
(
aData
.
IsFile
(
)
)
{
aData
.
GetAsFile
(
)
-
>
GetName
(
aName
)
;
}
else
{
MOZ_ASSERT
(
aData
.
IsDirectory
(
)
)
;
ErrorResult
rv
;
aData
.
GetAsDirectory
(
)
-
>
GetName
(
aName
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
}
}
}
void
GetDOMFileOrDirectoryPath
(
const
OwningFileOrDirectory
&
aData
nsAString
&
aPath
ErrorResult
&
aRv
)
{
if
(
aData
.
IsFile
(
)
)
{
aData
.
GetAsFile
(
)
-
>
GetMozFullPathInternal
(
aPath
aRv
)
;
}
else
{
MOZ_ASSERT
(
aData
.
IsDirectory
(
)
)
;
aData
.
GetAsDirectory
(
)
-
>
GetFullRealPath
(
aPath
)
;
}
}
}
bool
HTMLInputElement
:
:
ValueAsDateEnabled
(
JSContext
*
cx
JSObject
*
obj
)
{
return
Preferences
:
:
GetBool
(
"
dom
.
experimental_forms
"
false
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datepicker
"
false
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datetime
"
false
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
nsFilePickerShownCallback
:
:
Done
(
int16_t
aResult
)
{
mInput
-
>
PickerClosed
(
)
;
if
(
aResult
=
=
nsIFilePicker
:
:
returnCancel
)
{
return
NS_OK
;
}
int16_t
mode
;
mFilePicker
-
>
GetMode
(
&
mode
)
;
nsTArray
<
OwningFileOrDirectory
>
newFilesOrDirectories
;
if
(
mode
=
=
static_cast
<
int16_t
>
(
nsIFilePicker
:
:
modeOpenMultiple
)
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
iter
;
nsresult
rv
=
mFilePicker
-
>
GetDomFileOrDirectoryEnumerator
(
getter_AddRefs
(
iter
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
iter
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISupports
>
tmp
;
bool
hasMore
=
true
;
while
(
NS_SUCCEEDED
(
iter
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
iter
-
>
GetNext
(
getter_AddRefs
(
tmp
)
)
;
nsCOMPtr
<
nsIDOMBlob
>
domBlob
=
do_QueryInterface
(
tmp
)
;
MOZ_ASSERT
(
domBlob
"
Null
file
object
from
FilePicker
'
s
file
enumerator
?
"
)
;
if
(
!
domBlob
)
{
continue
;
}
OwningFileOrDirectory
*
element
=
newFilesOrDirectories
.
AppendElement
(
)
;
element
-
>
SetAsFile
(
)
=
static_cast
<
File
*
>
(
domBlob
.
get
(
)
)
;
}
}
else
{
MOZ_ASSERT
(
mode
=
=
static_cast
<
int16_t
>
(
nsIFilePicker
:
:
modeOpen
)
|
|
mode
=
=
static_cast
<
int16_t
>
(
nsIFilePicker
:
:
modeGetFolder
)
)
;
nsCOMPtr
<
nsISupports
>
tmp
;
nsresult
rv
=
mFilePicker
-
>
GetDomFileOrDirectory
(
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMBlob
>
blob
=
do_QueryInterface
(
tmp
)
;
if
(
blob
)
{
RefPtr
<
File
>
file
=
static_cast
<
Blob
*
>
(
blob
.
get
(
)
)
-
>
ToFile
(
)
;
MOZ_ASSERT
(
file
)
;
OwningFileOrDirectory
*
element
=
newFilesOrDirectories
.
AppendElement
(
)
;
element
-
>
SetAsFile
(
)
=
file
;
}
else
if
(
tmp
)
{
RefPtr
<
Directory
>
directory
=
static_cast
<
Directory
*
>
(
tmp
.
get
(
)
)
;
OwningFileOrDirectory
*
element
=
newFilesOrDirectories
.
AppendElement
(
)
;
element
-
>
SetAsDirectory
(
)
=
directory
;
}
}
if
(
newFilesOrDirectories
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIFile
>
file
=
DOMFileOrDirectoryToLocalFile
(
newFilesOrDirectories
[
0
]
)
;
if
(
file
)
{
nsCOMPtr
<
nsIFile
>
lastUsedDir
;
file
-
>
GetParent
(
getter_AddRefs
(
lastUsedDir
)
)
;
HTMLInputElement
:
:
gUploadLastDir
-
>
StoreLastUsedDirectory
(
mInput
-
>
OwnerDoc
(
)
lastUsedDir
)
;
}
mInput
-
>
SetFilesOrDirectories
(
newFilesOrDirectories
true
)
;
RefPtr
<
DispatchChangeEventCallback
>
dispatchChangeEventCallback
=
new
DispatchChangeEventCallback
(
mInput
)
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
dirPicker
.
enabled
"
false
)
&
&
mInput
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
webkitdirectory
)
)
{
ErrorResult
error
;
GetFilesHelper
*
helper
=
mInput
-
>
GetOrCreateGetFilesHelper
(
true
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
helper
-
>
AddCallback
(
dispatchChangeEventCallback
)
;
return
NS_OK
;
}
return
dispatchChangeEventCallback
-
>
DispatchEvents
(
)
;
}
NS_IMPL_ISUPPORTS
(
HTMLInputElement
:
:
nsFilePickerShownCallback
nsIFilePickerShownCallback
)
class
nsColorPickerShownCallback
final
:
public
nsIColorPickerShownCallback
{
~
nsColorPickerShownCallback
(
)
{
}
public
:
nsColorPickerShownCallback
(
HTMLInputElement
*
aInput
nsIColorPicker
*
aColorPicker
)
:
mInput
(
aInput
)
mColorPicker
(
aColorPicker
)
mValueChanged
(
false
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
Update
(
const
nsAString
&
aColor
)
override
;
NS_IMETHOD
Done
(
const
nsAString
&
aColor
)
override
;
private
:
nsresult
UpdateInternal
(
const
nsAString
&
aColor
bool
aTrustedUpdate
)
;
RefPtr
<
HTMLInputElement
>
mInput
;
nsCOMPtr
<
nsIColorPicker
>
mColorPicker
;
bool
mValueChanged
;
}
;
nsresult
nsColorPickerShownCallback
:
:
UpdateInternal
(
const
nsAString
&
aColor
bool
aTrustedUpdate
)
{
bool
valueChanged
=
false
;
nsAutoString
oldValue
;
if
(
aTrustedUpdate
)
{
valueChanged
=
true
;
}
else
{
mInput
-
>
GetValue
(
oldValue
CallerType
:
:
System
)
;
}
IgnoredErrorResult
rv
;
mInput
-
>
SetValue
(
aColor
CallerType
:
:
System
rv
)
;
if
(
!
aTrustedUpdate
)
{
nsAutoString
newValue
;
mInput
-
>
GetValue
(
newValue
CallerType
:
:
System
)
;
if
(
!
oldValue
.
Equals
(
newValue
)
)
{
valueChanged
=
true
;
}
}
if
(
valueChanged
)
{
mValueChanged
=
true
;
return
nsContentUtils
:
:
DispatchTrustedEvent
(
mInput
-
>
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
mInput
.
get
(
)
)
NS_LITERAL_STRING
(
"
input
"
)
true
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsColorPickerShownCallback
:
:
Update
(
const
nsAString
&
aColor
)
{
return
UpdateInternal
(
aColor
true
)
;
}
NS_IMETHODIMP
nsColorPickerShownCallback
:
:
Done
(
const
nsAString
&
aColor
)
{
nsresult
rv
=
NS_OK
;
mInput
-
>
PickerClosed
(
)
;
if
(
!
aColor
.
IsEmpty
(
)
)
{
UpdateInternal
(
aColor
false
)
;
}
if
(
mValueChanged
)
{
rv
=
nsContentUtils
:
:
DispatchTrustedEvent
(
mInput
-
>
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
mInput
.
get
(
)
)
NS_LITERAL_STRING
(
"
change
"
)
true
false
)
;
}
return
rv
;
}
NS_IMPL_ISUPPORTS
(
nsColorPickerShownCallback
nsIColorPickerShownCallback
)
class
DatePickerShownCallback
final
:
public
nsIDatePickerShownCallback
{
~
DatePickerShownCallback
(
)
{
}
public
:
DatePickerShownCallback
(
HTMLInputElement
*
aInput
nsIDatePicker
*
aDatePicker
)
:
mInput
(
aInput
)
mDatePicker
(
aDatePicker
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
Done
(
const
nsAString
&
aDate
)
override
;
NS_IMETHOD
Cancel
(
)
override
;
private
:
RefPtr
<
HTMLInputElement
>
mInput
;
nsCOMPtr
<
nsIDatePicker
>
mDatePicker
;
}
;
NS_IMETHODIMP
DatePickerShownCallback
:
:
Cancel
(
)
{
mInput
-
>
PickerClosed
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
DatePickerShownCallback
:
:
Done
(
const
nsAString
&
aDate
)
{
nsAutoString
oldValue
;
mInput
-
>
PickerClosed
(
)
;
mInput
-
>
GetValue
(
oldValue
CallerType
:
:
System
)
;
if
(
!
oldValue
.
Equals
(
aDate
)
)
{
IgnoredErrorResult
rv
;
mInput
-
>
SetValue
(
aDate
CallerType
:
:
System
rv
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
mInput
-
>
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
mInput
.
get
(
)
)
NS_LITERAL_STRING
(
"
input
"
)
true
false
)
;
return
nsContentUtils
:
:
DispatchTrustedEvent
(
mInput
-
>
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
mInput
.
get
(
)
)
NS_LITERAL_STRING
(
"
change
"
)
true
false
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
DatePickerShownCallback
nsIDatePickerShownCallback
)
bool
HTMLInputElement
:
:
IsPopupBlocked
(
)
const
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
OwnerDoc
(
)
-
>
GetWindow
(
)
;
MOZ_ASSERT
(
win
"
window
should
not
be
null
"
)
;
if
(
!
win
)
{
return
true
;
}
if
(
win
-
>
GetPopupControlState
(
)
<
=
openControlled
)
{
return
false
;
}
nsCOMPtr
<
nsIPopupWindowManager
>
pm
=
do_GetService
(
NS_POPUPWINDOWMANAGER_CONTRACTID
)
;
if
(
!
pm
)
{
return
true
;
}
uint32_t
permission
;
pm
-
>
TestPermission
(
OwnerDoc
(
)
-
>
NodePrincipal
(
)
&
permission
)
;
return
permission
=
=
nsIPopupWindowManager
:
:
DENY_POPUP
;
}
nsresult
HTMLInputElement
:
:
InitDatePicker
(
)
{
if
(
!
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datepicker
"
false
)
)
{
return
NS_OK
;
}
if
(
mPickerRunning
)
{
NS_WARNING
(
"
Just
one
nsIDatePicker
is
allowed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
NS_ERROR_FAILURE
;
}
if
(
IsPopupBlocked
(
)
)
{
win
-
>
FirePopupBlockedEvent
(
doc
nullptr
EmptyString
(
)
EmptyString
(
)
)
;
return
NS_OK
;
}
nsXPIDLString
title
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
DatePicker
"
title
)
;
nsresult
rv
;
nsCOMPtr
<
nsIDatePicker
>
datePicker
=
do_CreateInstance
(
"
mozilla
.
org
/
datepicker
;
1
"
&
rv
)
;
if
(
!
datePicker
)
{
return
rv
;
}
nsAutoString
initialValue
;
GetNonFileValueInternal
(
initialValue
)
;
rv
=
datePicker
-
>
Init
(
win
title
initialValue
)
;
nsCOMPtr
<
nsIDatePickerShownCallback
>
callback
=
new
DatePickerShownCallback
(
this
datePicker
)
;
rv
=
datePicker
-
>
Open
(
callback
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPickerRunning
=
true
;
}
return
rv
;
}
nsresult
HTMLInputElement
:
:
InitColorPicker
(
)
{
if
(
mPickerRunning
)
{
NS_WARNING
(
"
Just
one
nsIColorPicker
is
allowed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
NS_ERROR_FAILURE
;
}
if
(
IsPopupBlocked
(
)
)
{
win
-
>
FirePopupBlockedEvent
(
doc
nullptr
EmptyString
(
)
EmptyString
(
)
)
;
return
NS_OK
;
}
nsXPIDLString
title
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
ColorPicker
"
title
)
;
nsCOMPtr
<
nsIColorPicker
>
colorPicker
=
do_CreateInstance
(
"
mozilla
.
org
/
colorpicker
;
1
"
)
;
if
(
!
colorPicker
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
initialValue
;
GetNonFileValueInternal
(
initialValue
)
;
nsresult
rv
=
colorPicker
-
>
Init
(
win
title
initialValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIColorPickerShownCallback
>
callback
=
new
nsColorPickerShownCallback
(
this
colorPicker
)
;
rv
=
colorPicker
-
>
Open
(
callback
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPickerRunning
=
true
;
}
return
rv
;
}
nsresult
HTMLInputElement
:
:
InitFilePicker
(
FilePickerType
aType
)
{
if
(
mPickerRunning
)
{
NS_WARNING
(
"
Just
one
nsIFilePicker
is
allowed
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
NS_ERROR_FAILURE
;
}
if
(
IsPopupBlocked
(
)
)
{
win
-
>
FirePopupBlockedEvent
(
doc
nullptr
EmptyString
(
)
EmptyString
(
)
)
;
return
NS_OK
;
}
nsXPIDLString
title
;
nsXPIDLString
okButtonLabel
;
if
(
aType
=
=
FILE_PICKER_DIRECTORY
)
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
DirectoryUpload
"
title
)
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
DirectoryPickerOkButtonLabel
"
okButtonLabel
)
;
}
else
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
FileUpload
"
title
)
;
}
nsCOMPtr
<
nsIFilePicker
>
filePicker
=
do_CreateInstance
(
"
mozilla
.
org
/
filepicker
;
1
"
)
;
if
(
!
filePicker
)
return
NS_ERROR_FAILURE
;
int16_t
mode
;
if
(
aType
=
=
FILE_PICKER_DIRECTORY
)
{
mode
=
static_cast
<
int16_t
>
(
nsIFilePicker
:
:
modeGetFolder
)
;
}
else
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
multiple
)
)
{
mode
=
static_cast
<
int16_t
>
(
nsIFilePicker
:
:
modeOpenMultiple
)
;
}
else
{
mode
=
static_cast
<
int16_t
>
(
nsIFilePicker
:
:
modeOpen
)
;
}
nsresult
rv
=
filePicker
-
>
Init
(
win
title
mode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
okButtonLabel
.
IsEmpty
(
)
)
{
filePicker
-
>
SetOkButtonLabel
(
okButtonLabel
)
;
}
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accept
)
&
&
aType
!
=
FILE_PICKER_DIRECTORY
)
{
SetFilePickerFiltersFromAccept
(
filePicker
)
;
}
else
{
filePicker
-
>
AppendFilters
(
nsIFilePicker
:
:
filterAll
)
;
}
nsAutoString
defaultName
;
const
nsTArray
<
OwningFileOrDirectory
>
&
oldFiles
=
GetFilesOrDirectoriesInternal
(
)
;
nsCOMPtr
<
nsIFilePickerShownCallback
>
callback
=
new
HTMLInputElement
:
:
nsFilePickerShownCallback
(
this
filePicker
)
;
if
(
!
oldFiles
.
IsEmpty
(
)
&
&
aType
!
=
FILE_PICKER_DIRECTORY
)
{
nsString
path
;
nsCOMPtr
<
nsIFile
>
localFile
=
DOMFileOrDirectoryToLocalFile
(
oldFiles
[
0
]
)
;
if
(
localFile
)
{
nsCOMPtr
<
nsIFile
>
parentFile
;
nsresult
rv
=
localFile
-
>
GetParent
(
getter_AddRefs
(
parentFile
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
filePicker
-
>
SetDisplayDirectory
(
parentFile
)
;
}
}
if
(
oldFiles
.
Length
(
)
=
=
1
)
{
nsAutoString
leafName
;
GetDOMFileOrDirectoryName
(
oldFiles
[
0
]
leafName
)
;
if
(
!
leafName
.
IsEmpty
(
)
)
{
filePicker
-
>
SetDefaultString
(
leafName
)
;
}
}
rv
=
filePicker
-
>
Open
(
callback
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPickerRunning
=
true
;
}
return
rv
;
}
HTMLInputElement
:
:
gUploadLastDir
-
>
FetchDirectoryAndDisplayPicker
(
doc
filePicker
callback
)
;
mPickerRunning
=
true
;
return
NS_OK
;
}
#
define
CPS_PREF_NAME
NS_LITERAL_STRING
(
"
browser
.
upload
.
lastDir
"
)
NS_IMPL_ISUPPORTS
(
UploadLastDir
nsIObserver
nsISupportsWeakReference
)
void
HTMLInputElement
:
:
InitUploadLastDir
(
)
{
gUploadLastDir
=
new
UploadLastDir
(
)
;
NS_ADDREF
(
gUploadLastDir
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
&
&
gUploadLastDir
)
{
observerService
-
>
AddObserver
(
gUploadLastDir
"
browser
:
purge
-
session
-
history
"
true
)
;
}
}
void
HTMLInputElement
:
:
DestroyUploadLastDir
(
)
{
NS_IF_RELEASE
(
gUploadLastDir
)
;
}
nsresult
UploadLastDir
:
:
FetchDirectoryAndDisplayPicker
(
nsIDocument
*
aDoc
nsIFilePicker
*
aFilePicker
nsIFilePickerShownCallback
*
aFpCallback
)
{
NS_PRECONDITION
(
aDoc
"
aDoc
is
null
"
)
;
NS_PRECONDITION
(
aFilePicker
"
aFilePicker
is
null
"
)
;
NS_PRECONDITION
(
aFpCallback
"
aFpCallback
is
null
"
)
;
nsIURI
*
docURI
=
aDoc
-
>
GetDocumentURI
(
)
;
NS_PRECONDITION
(
docURI
"
docURI
is
null
"
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
aDoc
-
>
GetLoadContext
(
)
;
nsCOMPtr
<
nsIContentPrefCallback2
>
prefCallback
=
new
UploadLastDir
:
:
ContentPrefCallback
(
aFilePicker
aFpCallback
)
;
#
ifdef
MOZ_B2G
if
(
XRE_IsContentProcess
(
)
)
{
prefCallback
-
>
HandleCompletion
(
nsIContentPrefCallback2
:
:
COMPLETE_ERROR
)
;
return
NS_OK
;
}
#
endif
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
if
(
!
contentPrefService
)
{
prefCallback
-
>
HandleCompletion
(
nsIContentPrefCallback2
:
:
COMPLETE_ERROR
)
;
return
NS_OK
;
}
nsAutoCString
cstrSpec
;
docURI
-
>
GetSpec
(
cstrSpec
)
;
NS_ConvertUTF8toUTF16
spec
(
cstrSpec
)
;
contentPrefService
-
>
GetByDomainAndName
(
spec
CPS_PREF_NAME
loadContext
prefCallback
)
;
return
NS_OK
;
}
nsresult
UploadLastDir
:
:
StoreLastUsedDirectory
(
nsIDocument
*
aDoc
nsIFile
*
aDir
)
{
NS_PRECONDITION
(
aDoc
"
aDoc
is
null
"
)
;
if
(
!
aDir
)
{
return
NS_OK
;
}
#
ifdef
MOZ_B2G
if
(
XRE_IsContentProcess
(
)
)
{
return
NS_OK
;
}
#
endif
nsCOMPtr
<
nsIURI
>
docURI
=
aDoc
-
>
GetDocumentURI
(
)
;
NS_PRECONDITION
(
docURI
"
docURI
is
null
"
)
;
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
if
(
!
contentPrefService
)
return
NS_ERROR_NOT_AVAILABLE
;
nsAutoCString
cstrSpec
;
docURI
-
>
GetSpec
(
cstrSpec
)
;
NS_ConvertUTF8toUTF16
spec
(
cstrSpec
)
;
nsString
unicodePath
;
aDir
-
>
GetPath
(
unicodePath
)
;
if
(
unicodePath
.
IsEmpty
(
)
)
return
NS_OK
;
RefPtr
<
nsVariantCC
>
prefValue
=
new
nsVariantCC
(
)
;
prefValue
-
>
SetAsAString
(
unicodePath
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
aDoc
-
>
GetLoadContext
(
)
;
return
contentPrefService
-
>
Set
(
spec
CPS_PREF_NAME
prefValue
loadContext
nullptr
)
;
}
NS_IMETHODIMP
UploadLastDir
:
:
Observe
(
nsISupports
*
aSubject
char
const
*
aTopic
char16_t
const
*
aData
)
{
if
(
strcmp
(
aTopic
"
browser
:
purge
-
session
-
history
"
)
=
=
0
)
{
nsCOMPtr
<
nsIContentPrefService2
>
contentPrefService
=
do_GetService
(
NS_CONTENT_PREF_SERVICE_CONTRACTID
)
;
if
(
contentPrefService
)
contentPrefService
-
>
RemoveByName
(
CPS_PREF_NAME
nullptr
nullptr
)
;
}
return
NS_OK
;
}
#
ifdef
ACCESSIBILITY
static
nsresult
FireEventForAccessibility
(
nsIDOMHTMLInputElement
*
aTarget
nsPresContext
*
aPresContext
const
nsAString
&
aEventType
)
;
#
endif
HTMLInputElement
:
:
HTMLInputElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
FromParser
aFromParser
FromClone
aFromClone
)
:
nsGenericHTMLFormElementWithState
(
aNodeInfo
)
mType
(
kInputDefaultType
-
>
value
)
mAutocompleteAttrState
(
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
)
mDisabledChanged
(
false
)
mValueChanged
(
false
)
mLastValueChangeWasInteractive
(
false
)
mCheckedChanged
(
false
)
mChecked
(
false
)
mHandlingSelectEvent
(
false
)
mShouldInitChecked
(
false
)
mDoneCreating
(
aFromParser
=
=
NOT_FROM_PARSER
&
&
aFromClone
=
=
FromClone
:
:
no
)
mInInternalActivate
(
false
)
mCheckedIsToggled
(
false
)
mIndeterminate
(
false
)
mInhibitRestoration
(
aFromParser
&
FROM_PARSER_FRAGMENT
)
mCanShowValidUI
(
true
)
mCanShowInvalidUI
(
true
)
mHasRange
(
false
)
mIsDraggingRange
(
false
)
mNumberControlSpinnerIsSpinning
(
false
)
mNumberControlSpinnerSpinsUp
(
false
)
mPickerRunning
(
false
)
mSelectionCached
(
true
)
{
mInputData
.
mState
=
new
nsTextEditorState
(
this
)
;
if
(
!
gUploadLastDir
)
HTMLInputElement
:
:
InitUploadLastDir
(
)
;
AddStatesSilently
(
NS_EVENT_STATE_ENABLED
|
NS_EVENT_STATE_OPTIONAL
|
NS_EVENT_STATE_VALID
)
;
UpdateApzAwareFlag
(
)
;
}
HTMLInputElement
:
:
~
HTMLInputElement
(
)
{
if
(
mNumberControlSpinnerIsSpinning
)
{
StopNumberControlSpinnerSpin
(
eDisallowDispatchingEvents
)
;
}
DestroyImageLoadingContent
(
)
;
FreeData
(
)
;
}
void
HTMLInputElement
:
:
FreeData
(
)
{
if
(
!
IsSingleLineTextControl
(
false
)
)
{
free
(
mInputData
.
mValue
)
;
mInputData
.
mValue
=
nullptr
;
}
else
{
UnbindFromFrame
(
nullptr
)
;
delete
mInputData
.
mState
;
mInputData
.
mState
=
nullptr
;
}
}
nsTextEditorState
*
HTMLInputElement
:
:
GetEditorState
(
)
const
{
if
(
!
IsSingleLineTextControl
(
false
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mInputData
.
mState
"
Single
line
text
controls
need
to
have
a
state
"
"
associated
with
them
"
)
;
return
mInputData
.
mState
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLInputElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLInputElement
nsGenericHTMLFormElementWithState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mValidity
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mControllers
)
if
(
tmp
-
>
IsSingleLineTextControl
(
false
)
)
{
tmp
-
>
mInputData
.
mState
-
>
Traverse
(
cb
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFilesOrDirectories
)
if
(
tmp
-
>
mGetFilesRecursiveHelper
)
{
tmp
-
>
mGetFilesRecursiveHelper
-
>
Traverse
(
cb
)
;
}
if
(
tmp
-
>
mGetFilesNonRecursiveHelper
)
{
tmp
-
>
mGetFilesNonRecursiveHelper
-
>
Traverse
(
cb
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFileList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEntries
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLInputElement
nsGenericHTMLFormElementWithState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mValidity
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mControllers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFilesOrDirectories
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFileList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEntries
)
if
(
tmp
-
>
IsSingleLineTextControl
(
false
)
)
{
tmp
-
>
mInputData
.
mState
-
>
Unlink
(
)
;
}
tmp
-
>
ClearGetFilesHelpers
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ADDREF_INHERITED
(
HTMLInputElement
Element
)
NS_IMPL_RELEASE_INHERITED
(
HTMLInputElement
Element
)
NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED
(
HTMLInputElement
)
NS_INTERFACE_TABLE_INHERITED
(
HTMLInputElement
nsIDOMHTMLInputElement
nsITextControlElement
nsIPhonetic
imgINotificationObserver
nsIImageLoadingContent
imgIOnloadBlocker
nsIDOMNSEditableElement
nsIConstraintValidation
)
NS_INTERFACE_TABLE_TAIL_INHERITING
(
nsGenericHTMLFormElementWithState
)
NS_IMPL_NSICONSTRAINTVALIDATION_EXCEPT_SETCUSTOMVALIDITY
(
HTMLInputElement
)
nsresult
HTMLInputElement
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
{
*
aResult
=
nullptr
;
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
(
aNodeInfo
)
.
forget
(
)
;
RefPtr
<
HTMLInputElement
>
it
=
new
HTMLInputElement
(
ni
NOT_FROM_PARSER
FromClone
:
:
yes
)
;
nsresult
rv
=
const_cast
<
HTMLInputElement
*
>
(
this
)
-
>
CopyInnerTo
(
it
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_VALUE
:
if
(
mValueChanged
)
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
rv
=
it
-
>
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_Notify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
break
;
case
VALUE_MODE_FILENAME
:
if
(
it
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
GetDisplayFileName
(
it
-
>
mStaticDocFileList
)
;
}
else
{
it
-
>
ClearGetFilesHelpers
(
)
;
it
-
>
mFilesOrDirectories
.
Clear
(
)
;
it
-
>
mFilesOrDirectories
.
AppendElements
(
mFilesOrDirectories
)
;
}
break
;
case
VALUE_MODE_DEFAULT_ON
:
if
(
mCheckedChanged
)
{
it
-
>
DoSetChecked
(
mChecked
false
true
)
;
}
break
;
case
VALUE_MODE_DEFAULT
:
if
(
mType
=
=
NS_FORM_INPUT_IMAGE
&
&
it
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
CreateStaticImageClone
(
it
)
;
}
break
;
}
it
-
>
DoneCreatingElement
(
)
;
it
-
>
mLastValueChangeWasInteractive
=
mLastValueChangeWasInteractive
;
it
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
HTMLInputElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
(
aName
=
=
nsGkAtoms
:
:
name
|
|
(
aName
=
=
nsGkAtoms
:
:
type
&
&
!
mForm
)
)
&
&
mType
=
=
NS_FORM_INPUT_RADIO
&
&
(
mForm
|
|
mDoneCreating
)
)
{
WillRemoveFromRadioGroup
(
)
;
}
else
if
(
aNotify
&
&
aName
=
=
nsGkAtoms
:
:
src
&
&
mType
=
=
NS_FORM_INPUT_IMAGE
)
{
if
(
aValue
)
{
LoadImage
(
aValue
-
>
String
(
)
true
aNotify
eImageLoadType_Normal
)
;
}
else
{
CancelImageRequests
(
aNotify
)
;
}
}
else
if
(
aNotify
&
&
aName
=
=
nsGkAtoms
:
:
disabled
)
{
mDisabledChanged
=
true
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
dir
&
&
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
_auto
eIgnoreCase
)
)
{
SetDirectionIfAuto
(
false
aNotify
)
;
}
else
if
(
mType
=
=
NS_FORM_INPUT_RADIO
&
&
aName
=
=
nsGkAtoms
:
:
required
)
{
nsCOMPtr
<
nsIRadioGroupContainer
>
container
=
GetRadioGroupContainer
(
)
;
if
(
container
&
&
(
(
aValue
&
&
!
HasAttr
(
aNameSpaceID
aName
)
)
|
|
(
!
aValue
&
&
HasAttr
(
aNameSpaceID
aName
)
)
)
)
{
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
container
-
>
RadioRequiredWillChange
(
name
!
!
aValue
)
;
}
}
if
(
aName
=
=
nsGkAtoms
:
:
webkitdirectory
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBKIT_DIRECTORY_USED
true
)
;
}
}
return
nsGenericHTMLFormElementWithState
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLInputElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
const
nsAttrValue
*
aValue
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
(
aName
=
=
nsGkAtoms
:
:
name
|
|
(
aName
=
=
nsGkAtoms
:
:
type
&
&
!
mForm
)
)
&
&
mType
=
=
NS_FORM_INPUT_RADIO
&
&
(
mForm
|
|
mDoneCreating
)
)
{
AddedToRadioGroup
(
)
;
UpdateValueMissingValidityStateForRadio
(
false
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
value
&
&
!
mValueChanged
&
&
GetValueMode
(
)
=
=
VALUE_MODE_VALUE
)
{
SetDefaultValueAsValue
(
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
checked
&
&
!
mCheckedChanged
)
{
if
(
!
mDoneCreating
)
{
mShouldInitChecked
=
true
;
}
else
{
DoSetChecked
(
DefaultChecked
(
)
true
true
)
;
SetCheckedChanged
(
false
)
;
}
}
if
(
aName
=
=
nsGkAtoms
:
:
type
)
{
if
(
!
aValue
)
{
HandleTypeChange
(
kInputDefaultType
-
>
value
)
;
}
UpdateBarredFromConstraintValidation
(
)
;
if
(
mType
!
=
NS_FORM_INPUT_IMAGE
)
{
CancelImageRequests
(
aNotify
)
;
}
else
if
(
aNotify
)
{
nsAutoString
src
;
if
(
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
)
{
LoadImage
(
src
false
aNotify
eImageLoadType_Normal
)
;
}
}
if
(
mType
=
=
NS_FORM_INPUT_PASSWORD
&
&
IsInComposedDoc
(
)
)
{
AsyncEventDispatcher
*
dispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
DOMInputPasswordAdded
"
)
true
true
)
;
dispatcher
-
>
PostDOMEvent
(
)
;
}
}
if
(
aName
=
=
nsGkAtoms
:
:
required
|
|
aName
=
=
nsGkAtoms
:
:
disabled
|
|
aName
=
=
nsGkAtoms
:
:
readonly
)
{
UpdateValueMissingValidityState
(
)
;
if
(
aName
=
=
nsGkAtoms
:
:
readonly
|
|
aName
=
=
nsGkAtoms
:
:
disabled
)
{
UpdateBarredFromConstraintValidation
(
)
;
}
}
else
if
(
MinOrMaxLengthApplies
(
)
&
&
aName
=
=
nsGkAtoms
:
:
maxlength
)
{
UpdateTooLongValidityState
(
)
;
}
else
if
(
MinOrMaxLengthApplies
(
)
&
&
aName
=
=
nsGkAtoms
:
:
minlength
)
{
UpdateTooShortValidityState
(
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
pattern
&
&
mDoneCreating
)
{
UpdatePatternMismatchValidityState
(
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
multiple
)
{
UpdateTypeMismatchValidityState
(
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
max
)
{
UpdateHasRange
(
)
;
if
(
mType
=
=
NS_FORM_INPUT_RANGE
)
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
nsresult
rv
=
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_Internal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
UpdateRangeOverflowValidityState
(
)
;
MOZ_ASSERT
(
!
mDoneCreating
|
|
mType
!
=
NS_FORM_INPUT_RANGE
|
|
!
GetValidityState
(
VALIDITY_STATE_RANGE_UNDERFLOW
)
"
HTML5
spec
does
not
allow
underflow
for
type
=
range
"
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
min
)
{
UpdateHasRange
(
)
;
if
(
mType
=
=
NS_FORM_INPUT_RANGE
)
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
nsresult
rv
=
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_Internal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
UpdateRangeUnderflowValidityState
(
)
;
UpdateStepMismatchValidityState
(
)
;
MOZ_ASSERT
(
!
mDoneCreating
|
|
mType
!
=
NS_FORM_INPUT_RANGE
|
|
!
GetValidityState
(
VALIDITY_STATE_RANGE_UNDERFLOW
)
"
HTML5
spec
does
not
allow
underflow
for
type
=
range
"
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
step
)
{
if
(
mType
=
=
NS_FORM_INPUT_RANGE
)
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
nsresult
rv
=
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_Internal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
UpdateStepMismatchValidityState
(
)
;
MOZ_ASSERT
(
!
mDoneCreating
|
|
mType
!
=
NS_FORM_INPUT_RANGE
|
|
!
GetValidityState
(
VALIDITY_STATE_RANGE_UNDERFLOW
)
"
HTML5
spec
does
not
allow
underflow
for
type
=
range
"
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
dir
&
&
aValue
&
&
aValue
-
>
Equals
(
nsGkAtoms
:
:
_auto
eIgnoreCase
)
)
{
SetDirectionIfAuto
(
true
aNotify
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
lang
)
{
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
numberControlFrame
-
>
SetValueOfAnonTextControl
(
value
)
;
}
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
autocomplete
)
{
mAutocompleteAttrState
=
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
;
}
UpdateState
(
aNotify
)
;
}
return
nsGenericHTMLFormElementWithState
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetForm
(
nsIDOMHTMLFormElement
*
*
aForm
)
{
return
nsGenericHTMLFormElementWithState
:
:
GetForm
(
aForm
)
;
}
NS_IMPL_STRING_ATTR
(
HTMLInputElement
DefaultValue
value
)
NS_IMPL_BOOL_ATTR
(
HTMLInputElement
DefaultChecked
checked
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Accept
accept
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Align
align
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Alt
alt
)
NS_IMPL_BOOL_ATTR
(
HTMLInputElement
Autofocus
autofocus
)
NS_IMPL_BOOL_ATTR
(
HTMLInputElement
Disabled
disabled
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Max
max
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Min
min
)
NS_IMPL_ACTION_ATTR
(
HTMLInputElement
FormAction
formaction
)
NS_IMPL_ENUM_ATTR_DEFAULT_MISSING_INVALID_VALUES
(
HTMLInputElement
FormEnctype
formenctype
"
"
kFormDefaultEnctype
-
>
tag
)
NS_IMPL_ENUM_ATTR_DEFAULT_MISSING_INVALID_VALUES
(
HTMLInputElement
FormMethod
formmethod
"
"
kFormDefaultMethod
-
>
tag
)
NS_IMPL_BOOL_ATTR
(
HTMLInputElement
FormNoValidate
formnovalidate
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
FormTarget
formtarget
)
NS_IMPL_ENUM_ATTR_DEFAULT_VALUE
(
HTMLInputElement
InputMode
inputmode
kInputDefaultInputmode
-
>
tag
)
NS_IMPL_BOOL_ATTR
(
HTMLInputElement
Multiple
multiple
)
NS_IMPL_NON_NEGATIVE_INT_ATTR
(
HTMLInputElement
MaxLength
maxlength
)
NS_IMPL_NON_NEGATIVE_INT_ATTR
(
HTMLInputElement
MinLength
minlength
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Name
name
)
NS_IMPL_BOOL_ATTR
(
HTMLInputElement
ReadOnly
readonly
)
NS_IMPL_BOOL_ATTR
(
HTMLInputElement
Required
required
)
NS_IMPL_URI_ATTR
(
HTMLInputElement
Src
src
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Step
step
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
UseMap
usemap
)
NS_IMPL_UINT_ATTR_NON_ZERO_DEFAULT_VALUE
(
HTMLInputElement
Size
size
DEFAULT_COLS
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Pattern
pattern
)
NS_IMPL_STRING_ATTR
(
HTMLInputElement
Placeholder
placeholder
)
NS_IMPL_ENUM_ATTR_DEFAULT_VALUE
(
HTMLInputElement
Type
type
kInputDefaultType
-
>
tag
)
NS_IMETHODIMP
HTMLInputElement
:
:
GetAutocomplete
(
nsAString
&
aValue
)
{
if
(
!
DoesAutocompleteApply
(
)
)
{
return
NS_OK
;
}
aValue
.
Truncate
(
0
)
;
const
nsAttrValue
*
attributeVal
=
GetParsedAttr
(
nsGkAtoms
:
:
autocomplete
)
;
mAutocompleteAttrState
=
nsContentUtils
:
:
SerializeAutocompleteAttribute
(
attributeVal
aValue
mAutocompleteAttrState
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetAutocomplete
(
const
nsAString
&
aValue
)
{
return
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
nullptr
aValue
true
)
;
}
void
HTMLInputElement
:
:
GetAutocompleteInfo
(
Nullable
<
AutocompleteInfo
>
&
aInfo
)
{
if
(
!
DoesAutocompleteApply
(
)
)
{
aInfo
.
SetNull
(
)
;
return
;
}
const
nsAttrValue
*
attributeVal
=
GetParsedAttr
(
nsGkAtoms
:
:
autocomplete
)
;
mAutocompleteAttrState
=
nsContentUtils
:
:
SerializeAutocompleteAttribute
(
attributeVal
aInfo
.
SetValue
(
)
mAutocompleteAttrState
)
;
}
int32_t
HTMLInputElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
uint32_t
HTMLInputElement
:
:
Height
(
)
{
if
(
mType
!
=
NS_FORM_INPUT_IMAGE
)
{
return
0
;
}
return
GetWidthHeightForImage
(
mCurrentRequest
)
.
height
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetHeight
(
uint32_t
*
aHeight
)
{
*
aHeight
=
Height
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetHeight
(
uint32_t
aHeight
)
{
ErrorResult
rv
;
SetHeight
(
aHeight
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetIndeterminate
(
bool
*
aValue
)
{
*
aValue
=
Indeterminate
(
)
;
return
NS_OK
;
}
void
HTMLInputElement
:
:
SetIndeterminateInternal
(
bool
aValue
bool
aShouldInvalidate
)
{
mIndeterminate
=
aValue
;
if
(
aShouldInvalidate
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
frame
-
>
InvalidateFrameSubtree
(
)
;
}
UpdateState
(
true
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetIndeterminate
(
bool
aValue
)
{
SetIndeterminateInternal
(
aValue
true
)
;
return
NS_OK
;
}
uint32_t
HTMLInputElement
:
:
Width
(
)
{
if
(
mType
!
=
NS_FORM_INPUT_IMAGE
)
{
return
0
;
}
return
GetWidthHeightForImage
(
mCurrentRequest
)
.
width
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetWidth
(
uint32_t
*
aWidth
)
{
*
aWidth
=
Width
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetWidth
(
uint32_t
aWidth
)
{
ErrorResult
rv
;
SetWidth
(
aWidth
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
HTMLInputElement
:
:
GetValue
(
nsAString
&
aValue
CallerType
aCallerType
)
{
GetValueInternal
(
aValue
aCallerType
)
;
if
(
IsExperimentalMobileType
(
mType
)
|
|
IsDateTimeInputType
(
mType
)
)
{
SanitizeValue
(
aValue
)
;
}
}
void
HTMLInputElement
:
:
GetValueInternal
(
nsAString
&
aValue
CallerType
aCallerType
)
const
{
if
(
mType
!
=
NS_FORM_INPUT_FILE
)
{
GetNonFileValueInternal
(
aValue
)
;
return
;
}
if
(
aCallerType
=
=
CallerType
:
:
System
)
{
aValue
.
Assign
(
mFirstFilePath
)
;
}
else
{
if
(
mFilesOrDirectories
.
IsEmpty
(
)
)
{
aValue
.
Truncate
(
)
;
}
else
{
GetDOMFileOrDirectoryName
(
mFilesOrDirectories
[
0
]
aValue
)
;
}
}
}
void
HTMLInputElement
:
:
GetNonFileValueInternal
(
nsAString
&
aValue
)
const
{
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_VALUE
:
if
(
IsSingleLineTextControl
(
false
)
)
{
mInputData
.
mState
-
>
GetValue
(
aValue
true
)
;
}
else
if
(
!
aValue
.
Assign
(
mInputData
.
mValue
fallible
)
)
{
aValue
.
Truncate
(
)
;
}
return
;
case
VALUE_MODE_FILENAME
:
NS_NOTREACHED
(
"
Someone
screwed
up
here
"
)
;
aValue
.
Truncate
(
)
;
return
;
case
VALUE_MODE_DEFAULT
:
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aValue
)
;
return
;
case
VALUE_MODE_DEFAULT_ON
:
if
(
!
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aValue
)
)
{
aValue
.
AssignLiteral
(
"
on
"
)
;
}
return
;
}
}
bool
HTMLInputElement
:
:
IsValueEmpty
(
)
const
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
return
value
.
IsEmpty
(
)
;
}
void
HTMLInputElement
:
:
ClearFiles
(
bool
aSetValueChanged
)
{
nsTArray
<
OwningFileOrDirectory
>
data
;
SetFilesOrDirectories
(
data
aSetValueChanged
)
;
}
int32_t
HTMLInputElement
:
:
MonthsSinceJan1970
(
uint32_t
aYear
uint32_t
aMonth
)
const
{
return
(
aYear
-
1970
)
*
12
+
aMonth
-
1
;
}
Decimal
HTMLInputElement
:
:
StringToDecimal
(
const
nsAString
&
aValue
)
{
if
(
!
IsASCII
(
aValue
)
)
{
return
Decimal
:
:
nan
(
)
;
}
NS_LossyConvertUTF16toASCII
asciiString
(
aValue
)
;
std
:
:
string
stdString
=
asciiString
.
get
(
)
;
return
Decimal
:
:
fromString
(
stdString
)
;
}
bool
HTMLInputElement
:
:
ConvertStringToNumber
(
nsAString
&
aValue
Decimal
&
aResultValue
)
const
{
MOZ_ASSERT
(
DoesValueAsNumberApply
(
)
"
ConvertStringToNumber
only
applies
if
.
valueAsNumber
applies
"
)
;
switch
(
mType
)
{
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_RANGE
:
{
aResultValue
=
StringToDecimal
(
aValue
)
;
if
(
!
aResultValue
.
isFinite
(
)
)
{
return
false
;
}
return
true
;
}
case
NS_FORM_INPUT_DATE
:
{
uint32_t
year
month
day
;
if
(
!
ParseDate
(
aValue
&
year
&
month
&
day
)
)
{
return
false
;
}
JS
:
:
ClippedTime
time
=
JS
:
:
TimeClip
(
JS
:
:
MakeDate
(
year
month
-
1
day
)
)
;
if
(
!
time
.
isValid
(
)
)
{
return
false
;
}
aResultValue
=
Decimal
:
:
fromDouble
(
time
.
toDouble
(
)
)
;
return
true
;
}
case
NS_FORM_INPUT_TIME
:
uint32_t
milliseconds
;
if
(
!
ParseTime
(
aValue
&
milliseconds
)
)
{
return
false
;
}
aResultValue
=
Decimal
(
int32_t
(
milliseconds
)
)
;
return
true
;
case
NS_FORM_INPUT_MONTH
:
{
uint32_t
year
month
;
if
(
!
ParseMonth
(
aValue
&
year
&
month
)
)
{
return
false
;
}
if
(
year
<
kMinimumYear
|
|
year
>
kMaximumYear
)
{
return
false
;
}
if
(
year
=
=
kMaximumYear
&
&
month
>
kMaximumMonthInMaximumYear
)
{
return
false
;
}
int32_t
months
=
MonthsSinceJan1970
(
year
month
)
;
aResultValue
=
Decimal
(
int32_t
(
months
)
)
;
return
true
;
}
case
NS_FORM_INPUT_WEEK
:
{
uint32_t
year
week
;
if
(
!
ParseWeek
(
aValue
&
year
&
week
)
)
{
return
false
;
}
if
(
year
<
kMinimumYear
|
|
year
>
kMaximumYear
)
{
return
false
;
}
if
(
year
=
=
kMaximumYear
&
&
week
>
kMaximumWeekInMaximumYear
)
{
return
false
;
}
double
days
=
DaysSinceEpochFromWeek
(
year
week
)
;
aResultValue
=
Decimal
:
:
fromDouble
(
days
*
kMsPerDay
)
;
return
true
;
}
default
:
MOZ_ASSERT
(
false
"
Unrecognized
input
type
"
)
;
return
false
;
}
}
Decimal
HTMLInputElement
:
:
GetValueAsDecimal
(
)
const
{
Decimal
decimalValue
;
nsAutoString
stringValue
;
GetNonFileValueInternal
(
stringValue
)
;
return
!
ConvertStringToNumber
(
stringValue
decimalValue
)
?
Decimal
:
:
nan
(
)
:
decimalValue
;
}
void
HTMLInputElement
:
:
SetValue
(
const
nsAString
&
aValue
CallerType
aCallerType
ErrorResult
&
aRv
)
{
if
(
mType
=
=
NS_FORM_INPUT_FILE
)
{
if
(
!
aValue
.
IsEmpty
(
)
)
{
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
Sequence
<
nsString
>
list
;
if
(
!
list
.
AppendElement
(
aValue
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
MozSetFileNameArray
(
list
aRv
)
;
return
;
}
else
{
ClearFiles
(
true
)
;
}
}
else
{
if
(
MayFireChangeOnBlur
(
)
)
{
nsAutoString
currentValue
;
GetValue
(
currentValue
aCallerType
)
;
nsresult
rv
=
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_ByContent
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
mFocusedValue
.
Equals
(
currentValue
)
)
{
GetValue
(
mFocusedValue
aCallerType
)
;
}
}
else
{
nsresult
rv
=
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_ByContent
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
}
}
}
nsGenericHTMLElement
*
HTMLInputElement
:
:
GetList
(
)
const
{
nsAutoString
dataListId
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
list
dataListId
)
;
if
(
dataListId
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsIDocument
*
doc
=
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
Element
*
element
=
doc
-
>
GetElementById
(
dataListId
)
;
if
(
!
element
|
|
!
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
datalist
)
)
{
return
nullptr
;
}
return
static_cast
<
nsGenericHTMLElement
*
>
(
element
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetList
(
nsIDOMHTMLElement
*
*
aValue
)
{
*
aValue
=
nullptr
;
RefPtr
<
nsGenericHTMLElement
>
element
=
GetList
(
)
;
if
(
!
element
)
{
return
NS_OK
;
}
element
.
forget
(
aValue
)
;
return
NS_OK
;
}
void
HTMLInputElement
:
:
SetValue
(
Decimal
aValue
CallerType
aCallerType
)
{
MOZ_ASSERT
(
!
aValue
.
isInfinity
(
)
"
aValue
must
not
be
Infinity
!
"
)
;
if
(
aValue
.
isNaN
(
)
)
{
IgnoredErrorResult
rv
;
SetValue
(
EmptyString
(
)
aCallerType
rv
)
;
return
;
}
nsAutoString
value
;
ConvertNumberToString
(
aValue
value
)
;
IgnoredErrorResult
rv
;
SetValue
(
value
aCallerType
rv
)
;
}
bool
HTMLInputElement
:
:
ConvertNumberToString
(
Decimal
aValue
nsAString
&
aResultString
)
const
{
MOZ_ASSERT
(
DoesValueAsNumberApply
(
)
"
ConvertNumberToString
is
only
implemented
for
types
implementing
.
valueAsNumber
"
)
;
MOZ_ASSERT
(
aValue
.
isFinite
(
)
"
aValue
must
be
a
valid
non
-
Infinite
number
.
"
)
;
aResultString
.
Truncate
(
)
;
switch
(
mType
)
{
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_RANGE
:
{
char
buf
[
32
]
;
bool
ok
=
aValue
.
toString
(
buf
ArrayLength
(
buf
)
)
;
aResultString
.
AssignASCII
(
buf
)
;
MOZ_ASSERT
(
ok
"
buf
not
big
enough
"
)
;
return
ok
;
}
case
NS_FORM_INPUT_DATE
:
{
aValue
=
aValue
.
floor
(
)
;
double
year
=
JS
:
:
YearFromTime
(
aValue
.
toDouble
(
)
)
;
double
month
=
JS
:
:
MonthFromTime
(
aValue
.
toDouble
(
)
)
;
double
day
=
JS
:
:
DayFromTime
(
aValue
.
toDouble
(
)
)
;
if
(
IsNaN
(
year
)
|
|
IsNaN
(
month
)
|
|
IsNaN
(
day
)
)
{
return
false
;
}
aResultString
.
AppendPrintf
(
"
%
04
.
0f
-
%
02
.
0f
-
%
02
.
0f
"
year
month
+
1
day
)
;
return
true
;
}
case
NS_FORM_INPUT_TIME
:
{
uint32_t
value
=
NS_floorModulo
(
aValue
.
floor
(
)
Decimal
(
86400000
)
)
.
toDouble
(
)
;
uint16_t
milliseconds
=
value
%
1000
;
value
/
=
1000
;
uint8_t
seconds
=
value
%
60
;
value
/
=
60
;
uint8_t
minutes
=
value
%
60
;
value
/
=
60
;
uint8_t
hours
=
value
;
if
(
milliseconds
!
=
0
)
{
aResultString
.
AppendPrintf
(
"
%
02d
:
%
02d
:
%
02d
.
%
03d
"
hours
minutes
seconds
milliseconds
)
;
}
else
if
(
seconds
!
=
0
)
{
aResultString
.
AppendPrintf
(
"
%
02d
:
%
02d
:
%
02d
"
hours
minutes
seconds
)
;
}
else
{
aResultString
.
AppendPrintf
(
"
%
02d
:
%
02d
"
hours
minutes
)
;
}
return
true
;
}
case
NS_FORM_INPUT_MONTH
:
{
aValue
=
aValue
.
floor
(
)
;
double
month
=
NS_floorModulo
(
aValue
Decimal
(
12
)
)
.
toDouble
(
)
;
month
=
(
month
<
0
?
month
+
12
:
month
)
;
double
year
=
1970
+
(
aValue
.
toDouble
(
)
-
month
)
/
12
;
if
(
year
<
kMinimumYear
|
|
year
>
kMaximumYear
)
{
return
false
;
}
if
(
year
=
=
kMaximumYear
&
&
month
>
8
)
{
return
false
;
}
aResultString
.
AppendPrintf
(
"
%
04
.
0f
-
%
02
.
0f
"
year
month
+
1
)
;
return
true
;
}
case
NS_FORM_INPUT_WEEK
:
{
aValue
=
aValue
.
floor
(
)
;
double
year
=
JS
:
:
YearFromTime
(
aValue
.
toDouble
(
)
)
;
double
month
=
JS
:
:
MonthFromTime
(
aValue
.
toDouble
(
)
)
;
double
day
=
JS
:
:
DayFromTime
(
aValue
.
toDouble
(
)
)
;
double
dayInYear
=
JS
:
:
DayWithinYear
(
aValue
.
toDouble
(
)
year
)
+
1
;
uint32_t
isoWeekday
=
DayOfWeek
(
year
month
+
1
day
true
)
;
uint32_t
week
=
(
dayInYear
-
isoWeekday
+
10
)
/
7
;
if
(
week
<
1
)
{
year
-
-
;
if
(
year
<
1
)
{
return
false
;
}
week
=
MaximumWeekInYear
(
year
)
;
}
else
if
(
week
>
MaximumWeekInYear
(
year
)
)
{
year
+
+
;
if
(
year
>
kMaximumYear
|
|
(
year
=
=
kMaximumYear
&
&
week
>
kMaximumWeekInMaximumYear
)
)
{
return
false
;
}
week
=
1
;
}
aResultString
.
AppendPrintf
(
"
%
04
.
0f
-
W
%
02d
"
year
week
)
;
return
true
;
}
default
:
MOZ_ASSERT
(
false
"
Unrecognized
input
type
"
)
;
return
false
;
}
}
Nullable
<
Date
>
HTMLInputElement
:
:
GetValueAsDate
(
ErrorResult
&
aRv
)
{
if
(
!
IsDateTimeInputType
(
mType
)
|
|
mType
=
=
NS_FORM_INPUT_DATETIME_LOCAL
)
{
return
Nullable
<
Date
>
(
)
;
}
switch
(
mType
)
{
case
NS_FORM_INPUT_DATE
:
{
uint32_t
year
month
day
;
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
!
ParseDate
(
value
&
year
&
month
&
day
)
)
{
return
Nullable
<
Date
>
(
)
;
}
JS
:
:
ClippedTime
time
=
JS
:
:
TimeClip
(
JS
:
:
MakeDate
(
year
month
-
1
day
)
)
;
return
Nullable
<
Date
>
(
Date
(
time
)
)
;
}
case
NS_FORM_INPUT_TIME
:
{
uint32_t
millisecond
;
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
!
ParseTime
(
value
&
millisecond
)
)
{
return
Nullable
<
Date
>
(
)
;
}
JS
:
:
ClippedTime
time
=
JS
:
:
TimeClip
(
millisecond
)
;
MOZ_ASSERT
(
time
.
toDouble
(
)
=
=
millisecond
"
HTML
times
are
restricted
to
the
day
after
the
epoch
and
"
"
never
clip
"
)
;
return
Nullable
<
Date
>
(
Date
(
time
)
)
;
}
case
NS_FORM_INPUT_MONTH
:
{
uint32_t
year
month
;
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
!
ParseMonth
(
value
&
year
&
month
)
)
{
return
Nullable
<
Date
>
(
)
;
}
JS
:
:
ClippedTime
time
=
JS
:
:
TimeClip
(
JS
:
:
MakeDate
(
year
month
-
1
1
)
)
;
return
Nullable
<
Date
>
(
Date
(
time
)
)
;
}
case
NS_FORM_INPUT_WEEK
:
{
uint32_t
year
week
;
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
!
ParseWeek
(
value
&
year
&
week
)
)
{
return
Nullable
<
Date
>
(
)
;
}
double
days
=
DaysSinceEpochFromWeek
(
year
week
)
;
JS
:
:
ClippedTime
time
=
JS
:
:
TimeClip
(
days
*
kMsPerDay
)
;
return
Nullable
<
Date
>
(
Date
(
time
)
)
;
}
}
MOZ_ASSERT
(
false
"
Unrecognized
input
type
"
)
;
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
Nullable
<
Date
>
(
)
;
}
void
HTMLInputElement
:
:
SetValueAsDate
(
Nullable
<
Date
>
aDate
ErrorResult
&
aRv
)
{
if
(
!
IsDateTimeInputType
(
mType
)
|
|
mType
=
=
NS_FORM_INPUT_DATETIME_LOCAL
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
aDate
.
IsNull
(
)
|
|
aDate
.
Value
(
)
.
IsUndefined
(
)
)
{
SetValue
(
EmptyString
(
)
CallerType
:
:
NonSystem
aRv
)
;
return
;
}
double
milliseconds
=
aDate
.
Value
(
)
.
TimeStamp
(
)
.
toDouble
(
)
;
if
(
mType
!
=
NS_FORM_INPUT_MONTH
)
{
SetValue
(
Decimal
:
:
fromDouble
(
milliseconds
)
CallerType
:
:
NonSystem
)
;
return
;
}
double
year
=
JS
:
:
YearFromTime
(
milliseconds
)
;
double
month
=
JS
:
:
MonthFromTime
(
milliseconds
)
;
if
(
IsNaN
(
year
)
|
|
IsNaN
(
month
)
)
{
SetValue
(
EmptyString
(
)
CallerType
:
:
NonSystem
aRv
)
;
return
;
}
int32_t
months
=
MonthsSinceJan1970
(
year
month
+
1
)
;
SetValue
(
Decimal
(
int32_t
(
months
)
)
CallerType
:
:
NonSystem
)
;
}
void
HTMLInputElement
:
:
SetValueAsNumber
(
double
aValueAsNumber
ErrorResult
&
aRv
)
{
if
(
IsInfinite
(
aValueAsNumber
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
if
(
!
DoesValueAsNumberApply
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
SetValue
(
Decimal
:
:
fromDouble
(
aValueAsNumber
)
CallerType
:
:
NonSystem
)
;
}
Decimal
HTMLInputElement
:
:
GetMinimum
(
)
const
{
MOZ_ASSERT
(
DoesValueAsNumberApply
(
)
"
GetMinimum
(
)
should
only
be
used
for
types
that
allow
.
valueAsNumber
"
)
;
Decimal
defaultMinimum
=
mType
=
=
NS_FORM_INPUT_RANGE
?
Decimal
(
0
)
:
Decimal
:
:
nan
(
)
;
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
min
)
)
{
return
defaultMinimum
;
}
nsAutoString
minStr
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
min
minStr
)
;
Decimal
min
;
return
ConvertStringToNumber
(
minStr
min
)
?
min
:
defaultMinimum
;
}
Decimal
HTMLInputElement
:
:
GetMaximum
(
)
const
{
MOZ_ASSERT
(
DoesValueAsNumberApply
(
)
"
GetMaximum
(
)
should
only
be
used
for
types
that
allow
.
valueAsNumber
"
)
;
Decimal
defaultMaximum
=
mType
=
=
NS_FORM_INPUT_RANGE
?
Decimal
(
100
)
:
Decimal
:
:
nan
(
)
;
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
max
)
)
{
return
defaultMaximum
;
}
nsAutoString
maxStr
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
max
maxStr
)
;
Decimal
max
;
return
ConvertStringToNumber
(
maxStr
max
)
?
max
:
defaultMaximum
;
}
Decimal
HTMLInputElement
:
:
GetStepBase
(
)
const
{
MOZ_ASSERT
(
mType
=
=
NS_FORM_INPUT_NUMBER
|
|
mType
=
=
NS_FORM_INPUT_DATE
|
|
mType
=
=
NS_FORM_INPUT_TIME
|
|
mType
=
=
NS_FORM_INPUT_MONTH
|
|
mType
=
=
NS_FORM_INPUT_WEEK
|
|
mType
=
=
NS_FORM_INPUT_RANGE
"
Check
that
kDefaultStepBase
is
correct
for
this
new
type
"
)
;
Decimal
stepBase
;
nsAutoString
minStr
;
if
(
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
min
minStr
)
&
&
ConvertStringToNumber
(
minStr
stepBase
)
)
{
return
stepBase
;
}
nsAutoString
valueStr
;
if
(
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
valueStr
)
&
&
ConvertStringToNumber
(
valueStr
stepBase
)
)
{
return
stepBase
;
}
if
(
mType
=
=
NS_FORM_INPUT_WEEK
)
{
return
kDefaultStepBaseWeek
;
}
return
kDefaultStepBase
;
}
nsresult
HTMLInputElement
:
:
GetValueIfStepped
(
int32_t
aStep
StepCallerType
aCallerType
Decimal
*
aNextStep
)
{
if
(
!
DoStepDownStepUpApply
(
)
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
Decimal
stepBase
=
GetStepBase
(
)
;
Decimal
step
=
GetStep
(
)
;
if
(
step
=
=
kStepAny
)
{
if
(
aCallerType
!
=
CALLED_FOR_USER_EVENT
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
step
=
GetDefaultStep
(
)
;
}
Decimal
minimum
=
GetMinimum
(
)
;
Decimal
maximum
=
GetMaximum
(
)
;
if
(
!
maximum
.
isNaN
(
)
)
{
maximum
=
maximum
-
NS_floorModulo
(
maximum
-
stepBase
step
)
;
if
(
!
minimum
.
isNaN
(
)
)
{
if
(
minimum
>
maximum
)
{
return
NS_OK
;
}
}
}
Decimal
value
=
GetValueAsDecimal
(
)
;
bool
valueWasNaN
=
false
;
if
(
value
.
isNaN
(
)
)
{
value
=
Decimal
(
0
)
;
valueWasNaN
=
true
;
}
Decimal
valueBeforeStepping
=
value
;
Decimal
deltaFromStep
=
NS_floorModulo
(
value
-
stepBase
step
)
;
if
(
deltaFromStep
!
=
Decimal
(
0
)
)
{
if
(
aStep
>
0
)
{
value
+
=
step
-
deltaFromStep
;
value
+
=
step
*
Decimal
(
aStep
-
1
)
;
}
else
if
(
aStep
<
0
)
{
value
-
=
deltaFromStep
;
value
+
=
step
*
Decimal
(
aStep
+
1
)
;
}
}
else
{
value
+
=
step
*
Decimal
(
aStep
)
;
}
if
(
value
<
minimum
)
{
value
=
minimum
;
deltaFromStep
=
NS_floorModulo
(
value
-
stepBase
step
)
;
if
(
deltaFromStep
!
=
Decimal
(
0
)
)
{
value
+
=
step
-
deltaFromStep
;
}
}
if
(
value
>
maximum
)
{
value
=
maximum
;
deltaFromStep
=
NS_floorModulo
(
value
-
stepBase
step
)
;
if
(
deltaFromStep
!
=
Decimal
(
0
)
)
{
value
-
=
deltaFromStep
;
}
}
if
(
!
valueWasNaN
&
&
(
(
aStep
>
0
&
&
value
<
valueBeforeStepping
)
|
|
(
aStep
<
0
&
&
value
>
valueBeforeStepping
)
)
)
{
return
NS_OK
;
}
*
aNextStep
=
value
;
return
NS_OK
;
}
nsresult
HTMLInputElement
:
:
ApplyStep
(
int32_t
aStep
)
{
Decimal
nextStep
=
Decimal
:
:
nan
(
)
;
nsresult
rv
=
GetValueIfStepped
(
aStep
CALLED_FOR_SCRIPT
&
nextStep
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
nextStep
.
isFinite
(
)
)
{
SetValue
(
nextStep
CallerType
:
:
NonSystem
)
;
}
return
rv
;
}
bool
HTMLInputElement
:
:
IsExperimentalMobileType
(
uint8_t
aType
)
{
return
(
aType
=
=
NS_FORM_INPUT_DATE
&
&
!
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datetime
"
false
)
&
&
!
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datepicker
"
false
)
)
|
|
(
aType
=
=
NS_FORM_INPUT_TIME
&
&
!
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datetime
"
false
)
)
;
}
bool
HTMLInputElement
:
:
IsDateTimeInputType
(
uint8_t
aType
)
{
return
aType
=
=
NS_FORM_INPUT_DATE
|
|
aType
=
=
NS_FORM_INPUT_TIME
|
|
aType
=
=
NS_FORM_INPUT_MONTH
|
|
aType
=
=
NS_FORM_INPUT_WEEK
|
|
aType
=
=
NS_FORM_INPUT_DATETIME_LOCAL
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
StepDown
(
int32_t
n
uint8_t
optional_argc
)
{
return
ApplyStep
(
optional_argc
?
-
n
:
-
1
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
StepUp
(
int32_t
n
uint8_t
optional_argc
)
{
return
ApplyStep
(
optional_argc
?
n
:
1
)
;
}
void
HTMLInputElement
:
:
FlushFrames
(
)
{
if
(
GetComposedDoc
(
)
)
{
GetComposedDoc
(
)
-
>
FlushPendingNotifications
(
Flush_Frames
)
;
}
}
void
HTMLInputElement
:
:
MozGetFileNameArray
(
nsTArray
<
nsString
>
&
aArray
ErrorResult
&
aRv
)
{
for
(
uint32_t
i
=
0
;
i
<
mFilesOrDirectories
.
Length
(
)
;
i
+
+
)
{
nsAutoString
str
;
GetDOMFileOrDirectoryPath
(
mFilesOrDirectories
[
i
]
str
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
aArray
.
AppendElement
(
str
)
;
}
}
void
HTMLInputElement
:
:
MozSetFileArray
(
const
Sequence
<
OwningNonNull
<
File
>
>
&
aFiles
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
MOZ_ASSERT
(
global
)
;
if
(
!
global
)
{
return
;
}
nsTArray
<
OwningFileOrDirectory
>
files
;
for
(
uint32_t
i
=
0
;
i
<
aFiles
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
File
>
file
=
File
:
:
Create
(
global
aFiles
[
i
]
.
get
(
)
-
>
Impl
(
)
)
;
MOZ_ASSERT
(
file
)
;
OwningFileOrDirectory
*
element
=
files
.
AppendElement
(
)
;
element
-
>
SetAsFile
(
)
=
file
;
}
SetFilesOrDirectories
(
files
true
)
;
}
void
HTMLInputElement
:
:
MozSetFileNameArray
(
const
Sequence
<
nsString
>
&
aFileNames
ErrorResult
&
aRv
)
{
if
(
XRE_IsContentProcess
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
nsTArray
<
OwningFileOrDirectory
>
files
;
for
(
uint32_t
i
=
0
;
i
<
aFileNames
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
nsIFile
>
file
;
if
(
StringBeginsWith
(
aFileNames
[
i
]
NS_LITERAL_STRING
(
"
file
:
"
)
nsASCIICaseInsensitiveStringComparator
(
)
)
)
{
NS_GetFileFromURLSpec
(
NS_ConvertUTF16toUTF8
(
aFileNames
[
i
]
)
getter_AddRefs
(
file
)
)
;
}
if
(
!
file
)
{
NS_NewLocalFile
(
aFileNames
[
i
]
false
getter_AddRefs
(
file
)
)
;
}
if
(
!
file
)
{
continue
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
File
>
domFile
=
File
:
:
CreateFromFile
(
global
file
)
;
OwningFileOrDirectory
*
element
=
files
.
AppendElement
(
)
;
element
-
>
SetAsFile
(
)
=
domFile
;
}
SetFilesOrDirectories
(
files
true
)
;
}
void
HTMLInputElement
:
:
MozSetDirectory
(
const
nsAString
&
aDirectoryPath
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIFile
>
file
;
NS_ConvertUTF16toUTF8
path
(
aDirectoryPath
)
;
aRv
=
NS_NewNativeLocalFile
(
path
true
getter_AddRefs
(
file
)
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
window
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
Directory
>
directory
=
Directory
:
:
Create
(
window
file
)
;
MOZ_ASSERT
(
directory
)
;
nsTArray
<
OwningFileOrDirectory
>
array
;
OwningFileOrDirectory
*
element
=
array
.
AppendElement
(
)
;
element
-
>
SetAsDirectory
(
)
=
directory
;
SetFilesOrDirectories
(
array
true
)
;
}
void
HTMLInputElement
:
:
GetDateTimeInputBoxValue
(
DateTimeValue
&
aValue
)
{
if
(
NS_WARN_IF
(
!
IsDateTimeInputType
(
mType
)
)
|
|
!
mDateTimeInputBoxValue
)
{
return
;
}
aValue
=
*
mDateTimeInputBoxValue
;
}
void
HTMLInputElement
:
:
UpdateDateTimeInputBox
(
const
DateTimeValue
&
aValue
)
{
if
(
NS_WARN_IF
(
!
IsDateTimeInputType
(
mType
)
)
)
{
return
;
}
nsDateTimeControlFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
SetValueFromPicker
(
aValue
)
;
}
}
void
HTMLInputElement
:
:
SetDateTimePickerState
(
bool
aOpen
)
{
if
(
NS_WARN_IF
(
!
IsDateTimeInputType
(
mType
)
)
)
{
return
;
}
nsDateTimeControlFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
SetPickerState
(
aOpen
)
;
}
}
void
HTMLInputElement
:
:
OpenDateTimePicker
(
const
DateTimeValue
&
aInitialValue
)
{
if
(
NS_WARN_IF
(
!
IsDateTimeInputType
(
mType
)
)
)
{
return
;
}
mDateTimeInputBoxValue
=
new
DateTimeValue
(
aInitialValue
)
;
nsContentUtils
:
:
DispatchChromeEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
MozOpenDateTimePicker
"
)
true
true
)
;
}
void
HTMLInputElement
:
:
UpdateDateTimePicker
(
const
DateTimeValue
&
aValue
)
{
if
(
NS_WARN_IF
(
!
IsDateTimeInputType
(
mType
)
)
)
{
return
;
}
mDateTimeInputBoxValue
=
new
DateTimeValue
(
aValue
)
;
nsContentUtils
:
:
DispatchChromeEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
MozUpdateDateTimePicker
"
)
true
true
)
;
}
void
HTMLInputElement
:
:
CloseDateTimePicker
(
)
{
if
(
NS_WARN_IF
(
!
IsDateTimeInputType
(
mType
)
)
)
{
return
;
}
nsContentUtils
:
:
DispatchChromeEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
MozCloseDateTimePicker
"
)
true
true
)
;
}
bool
HTMLInputElement
:
:
MozIsTextField
(
bool
aExcludePassword
)
{
if
(
IsExperimentalMobileType
(
mType
)
|
|
IsDateTimeInputType
(
mType
)
)
{
return
false
;
}
return
IsSingleLineTextControl
(
aExcludePassword
)
;
}
HTMLInputElement
*
HTMLInputElement
:
:
GetOwnerNumberControl
(
)
{
if
(
IsInNativeAnonymousSubtree
(
)
&
&
mType
=
=
NS_FORM_INPUT_TEXT
&
&
GetParent
(
)
&
&
GetParent
(
)
-
>
GetParent
(
)
)
{
HTMLInputElement
*
grandparent
=
HTMLInputElement
:
:
FromContentOrNull
(
GetParent
(
)
-
>
GetParent
(
)
)
;
if
(
grandparent
&
&
grandparent
-
>
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
return
grandparent
;
}
}
return
nullptr
;
}
HTMLInputElement
*
HTMLInputElement
:
:
GetOwnerDateTimeControl
(
)
{
if
(
IsInNativeAnonymousSubtree
(
)
&
&
mType
=
=
NS_FORM_INPUT_TEXT
&
&
GetParent
(
)
&
&
GetParent
(
)
-
>
GetParent
(
)
&
&
GetParent
(
)
-
>
GetParent
(
)
-
>
GetParent
(
)
&
&
GetParent
(
)
-
>
GetParent
(
)
-
>
GetParent
(
)
-
>
GetParent
(
)
)
{
HTMLInputElement
*
ownerDateTimeControl
=
HTMLInputElement
:
:
FromContentOrNull
(
GetParent
(
)
-
>
GetParent
(
)
-
>
GetParent
(
)
-
>
GetParent
(
)
)
;
if
(
ownerDateTimeControl
&
&
ownerDateTimeControl
-
>
mType
=
=
NS_FORM_INPUT_TIME
)
{
return
ownerDateTimeControl
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
MozIsTextField
(
bool
aExcludePassword
bool
*
aResult
)
{
*
aResult
=
MozIsTextField
(
aExcludePassword
)
;
return
NS_OK
;
}
void
HTMLInputElement
:
:
SetUserInput
(
const
nsAString
&
aInput
nsIPrincipal
&
aSubjectPrincipal
)
{
if
(
mType
=
=
NS_FORM_INPUT_FILE
&
&
!
nsContentUtils
:
:
IsSystemPrincipal
(
&
aSubjectPrincipal
)
)
{
return
;
}
SetUserInput
(
aInput
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetUserInput
(
const
nsAString
&
aValue
)
{
if
(
mType
=
=
NS_FORM_INPUT_FILE
)
{
Sequence
<
nsString
>
list
;
if
(
!
list
.
AppendElement
(
aValue
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
ErrorResult
rv
;
MozSetFileNameArray
(
list
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
else
{
nsresult
rv
=
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_BySetUserInput
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
input
"
)
true
true
)
;
if
(
!
ShouldBlur
(
this
)
)
{
FireChangeEventIfNeeded
(
)
;
}
return
NS_OK
;
}
nsIEditor
*
HTMLInputElement
:
:
GetEditor
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
return
state
-
>
GetEditor
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP_
(
nsIEditor
*
)
HTMLInputElement
:
:
GetTextEditor
(
)
{
return
GetEditor
(
)
;
}
NS_IMETHODIMP_
(
nsISelectionController
*
)
HTMLInputElement
:
:
GetSelectionController
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
return
state
-
>
GetSelectionController
(
)
;
}
return
nullptr
;
}
nsFrameSelection
*
HTMLInputElement
:
:
GetConstFrameSelection
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
return
state
-
>
GetConstFrameSelection
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
BindToFrame
(
nsTextControlFrame
*
aFrame
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
return
state
-
>
BindToFrame
(
aFrame
)
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP_
(
void
)
HTMLInputElement
:
:
UnbindFromFrame
(
nsTextControlFrame
*
aFrame
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
aFrame
)
{
state
-
>
UnbindFromFrame
(
aFrame
)
;
}
}
NS_IMETHODIMP
HTMLInputElement
:
:
CreateEditor
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
return
state
-
>
PrepareEditor
(
)
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP_
(
nsIContent
*
)
HTMLInputElement
:
:
GetRootEditorNode
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
return
state
-
>
GetRootNode
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP_
(
Element
*
)
HTMLInputElement
:
:
CreatePlaceholderNode
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
NS_ENSURE_SUCCESS
(
state
-
>
CreatePlaceholderNode
(
)
nullptr
)
;
return
state
-
>
GetPlaceholderNode
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP_
(
Element
*
)
HTMLInputElement
:
:
GetPlaceholderNode
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
return
state
-
>
GetPlaceholderNode
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP_
(
void
)
HTMLInputElement
:
:
UpdatePlaceholderVisibility
(
bool
aNotify
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
state
-
>
UpdatePlaceholderVisibility
(
aNotify
)
;
}
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
GetPlaceholderVisibility
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
!
state
)
{
return
false
;
}
return
state
-
>
GetPlaceholderVisibility
(
)
;
}
void
HTMLInputElement
:
:
GetDisplayFileName
(
nsAString
&
aValue
)
const
{
if
(
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
aValue
=
mStaticDocFileList
;
return
;
}
if
(
mFilesOrDirectories
.
Length
(
)
=
=
1
)
{
GetDOMFileOrDirectoryName
(
mFilesOrDirectories
[
0
]
aValue
)
;
return
;
}
nsXPIDLString
value
;
if
(
mFilesOrDirectories
.
IsEmpty
(
)
)
{
if
(
(
Preferences
:
:
GetBool
(
"
dom
.
input
.
dirpicker
"
false
)
&
&
Allowdirs
(
)
)
|
|
(
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
dirPicker
.
enabled
"
false
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
webkitdirectory
)
)
)
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
NoDirSelected
"
value
)
;
}
else
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
multiple
)
)
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
NoFilesSelected
"
value
)
;
}
else
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
NoFileSelected
"
value
)
;
}
}
else
{
nsString
count
;
count
.
AppendInt
(
int
(
mFilesOrDirectories
.
Length
(
)
)
)
;
const
char16_t
*
params
[
]
=
{
count
.
get
(
)
}
;
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
XFilesSelected
"
params
value
)
;
}
aValue
=
value
;
}
void
HTMLInputElement
:
:
SetFilesOrDirectories
(
const
nsTArray
<
OwningFileOrDirectory
>
&
aFilesOrDirectories
bool
aSetValueChanged
)
{
ClearGetFilesHelpers
(
)
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
filesystem
.
enabled
"
false
)
)
{
HTMLInputElementBinding
:
:
ClearCachedWebkitEntriesValue
(
this
)
;
mEntries
.
Clear
(
)
;
}
mFilesOrDirectories
.
Clear
(
)
;
mFilesOrDirectories
.
AppendElements
(
aFilesOrDirectories
)
;
AfterSetFilesOrDirectories
(
aSetValueChanged
)
;
}
void
HTMLInputElement
:
:
SetFiles
(
nsIDOMFileList
*
aFiles
bool
aSetValueChanged
)
{
RefPtr
<
FileList
>
files
=
static_cast
<
FileList
*
>
(
aFiles
)
;
mFilesOrDirectories
.
Clear
(
)
;
ClearGetFilesHelpers
(
)
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
filesystem
.
enabled
"
false
)
)
{
HTMLInputElementBinding
:
:
ClearCachedWebkitEntriesValue
(
this
)
;
mEntries
.
Clear
(
)
;
}
if
(
aFiles
)
{
uint32_t
listLength
;
aFiles
-
>
GetLength
(
&
listLength
)
;
for
(
uint32_t
i
=
0
;
i
<
listLength
;
i
+
+
)
{
OwningFileOrDirectory
*
element
=
mFilesOrDirectories
.
AppendElement
(
)
;
element
-
>
SetAsFile
(
)
=
files
-
>
Item
(
i
)
;
}
}
AfterSetFilesOrDirectories
(
aSetValueChanged
)
;
}
void
HTMLInputElement
:
:
MozSetDndFilesAndDirectories
(
const
nsTArray
<
OwningFileOrDirectory
>
&
aFilesOrDirectories
)
{
SetFilesOrDirectories
(
aFilesOrDirectories
true
)
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
filesystem
.
enabled
"
false
)
)
{
UpdateEntries
(
aFilesOrDirectories
)
;
}
RefPtr
<
DispatchChangeEventCallback
>
dispatchChangeEventCallback
=
new
DispatchChangeEventCallback
(
this
)
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
dirPicker
.
enabled
"
false
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
webkitdirectory
)
)
{
ErrorResult
rv
;
GetFilesHelper
*
helper
=
GetOrCreateGetFilesHelper
(
true
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
;
}
helper
-
>
AddCallback
(
dispatchChangeEventCallback
)
;
}
else
{
dispatchChangeEventCallback
-
>
DispatchEvents
(
)
;
}
}
void
HTMLInputElement
:
:
AfterSetFilesOrDirectories
(
bool
aSetValueChanged
)
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
false
)
;
if
(
formControlFrame
)
{
nsAutoString
readableValue
;
GetDisplayFileName
(
readableValue
)
;
formControlFrame
-
>
SetFormProperty
(
nsGkAtoms
:
:
value
readableValue
)
;
}
if
(
mFilesOrDirectories
.
IsEmpty
(
)
)
{
mFirstFilePath
.
Truncate
(
)
;
}
else
{
ErrorResult
rv
;
GetDOMFileOrDirectoryPath
(
mFilesOrDirectories
[
0
]
mFirstFilePath
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
}
}
UpdateFileList
(
)
;
if
(
aSetValueChanged
)
{
SetValueChanged
(
true
)
;
}
UpdateAllValidityStates
(
true
)
;
}
void
HTMLInputElement
:
:
FireChangeEventIfNeeded
(
)
{
nsAutoString
value
;
GetValue
(
value
CallerType
:
:
System
)
;
if
(
!
MayFireChangeOnBlur
(
)
|
|
mFocusedValue
.
Equals
(
value
)
)
{
return
;
}
mFocusedValue
=
value
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
this
)
NS_LITERAL_STRING
(
"
change
"
)
true
false
)
;
}
FileList
*
HTMLInputElement
:
:
GetFiles
(
)
{
if
(
mType
!
=
NS_FORM_INPUT_FILE
)
{
return
nullptr
;
}
if
(
Preferences
:
:
GetBool
(
"
dom
.
input
.
dirpicker
"
false
)
&
&
Allowdirs
(
)
&
&
(
!
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
dirPicker
.
enabled
"
false
)
|
|
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
webkitdirectory
)
)
)
{
return
nullptr
;
}
if
(
!
mFileList
)
{
mFileList
=
new
FileList
(
static_cast
<
nsIContent
*
>
(
this
)
)
;
UpdateFileList
(
)
;
}
return
mFileList
;
}
void
HTMLInputElement
:
:
HandleNumberControlSpin
(
void
*
aData
)
{
HTMLInputElement
*
input
=
static_cast
<
HTMLInputElement
*
>
(
aData
)
;
NS_ASSERTION
(
input
-
>
mNumberControlSpinnerIsSpinning
"
Should
have
called
nsRepeatService
:
:
Stop
(
)
"
)
;
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
input
-
>
GetPrimaryFrame
(
)
)
;
if
(
input
-
>
mType
!
=
NS_FORM_INPUT_NUMBER
|
|
!
numberControlFrame
)
{
input
-
>
StopNumberControlSpinnerSpin
(
)
;
}
else
{
input
-
>
StepNumberControlForUserEvent
(
input
-
>
mNumberControlSpinnerSpinsUp
?
1
:
-
1
)
;
}
}
void
HTMLInputElement
:
:
UpdateFileList
(
)
{
if
(
mFileList
)
{
mFileList
-
>
Clear
(
)
;
const
nsTArray
<
OwningFileOrDirectory
>
&
array
=
GetFilesOrDirectoriesInternal
(
)
;
for
(
uint32_t
i
=
0
;
i
<
array
.
Length
(
)
;
+
+
i
)
{
if
(
array
[
i
]
.
IsFile
(
)
)
{
mFileList
-
>
Append
(
array
[
i
]
.
GetAsFile
(
)
)
;
}
}
}
}
nsresult
HTMLInputElement
:
:
SetValueInternal
(
const
nsAString
&
aValue
uint32_t
aFlags
)
{
NS_PRECONDITION
(
GetValueMode
(
)
!
=
VALUE_MODE_FILENAME
"
Don
'
t
call
SetValueInternal
for
file
inputs
"
)
;
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_VALUE
:
{
nsAutoString
value
(
aValue
)
;
if
(
mDoneCreating
)
{
SanitizeValue
(
value
)
;
}
bool
setValueChanged
=
!
!
(
aFlags
&
nsTextEditorState
:
:
eSetValue_Notify
)
;
if
(
setValueChanged
)
{
SetValueChanged
(
true
)
;
}
if
(
IsSingleLineTextControl
(
false
)
)
{
if
(
!
mInputData
.
mState
-
>
SetValue
(
value
aFlags
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mType
=
=
NS_FORM_INPUT_EMAIL
)
{
UpdateAllValidityStates
(
!
mDoneCreating
)
;
}
}
else
{
free
(
mInputData
.
mValue
)
;
mInputData
.
mValue
=
ToNewUnicode
(
value
)
;
if
(
setValueChanged
)
{
SetValueChanged
(
true
)
;
}
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
numberControlFrame
-
>
SetValueOfAnonTextControl
(
value
)
;
}
}
else
if
(
mType
=
=
NS_FORM_INPUT_RANGE
)
{
nsRangeFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
UpdateForValueChange
(
)
;
}
}
else
if
(
mType
=
=
NS_FORM_INPUT_TIME
&
&
!
IsExperimentalMobileType
(
mType
)
)
{
nsDateTimeControlFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
UpdateInputBoxValue
(
)
;
}
}
if
(
mDoneCreating
)
{
OnValueChanged
(
true
false
)
;
}
}
if
(
mType
=
=
NS_FORM_INPUT_COLOR
)
{
nsColorControlFrame
*
colorControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
colorControlFrame
)
{
colorControlFrame
-
>
UpdateColor
(
)
;
}
}
if
(
PlaceholderApplies
(
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
)
)
{
UpdateState
(
true
)
;
}
return
NS_OK
;
}
case
VALUE_MODE_DEFAULT
:
case
VALUE_MODE_DEFAULT_ON
:
if
(
mType
=
=
NS_FORM_INPUT_HIDDEN
)
{
SetValueChanged
(
true
)
;
}
return
nsGenericHTMLFormElementWithState
:
:
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aValue
true
)
;
case
VALUE_MODE_FILENAME
:
return
NS_ERROR_UNEXPECTED
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetValueChanged
(
bool
aValueChanged
)
{
bool
valueChangedBefore
=
mValueChanged
;
mValueChanged
=
aValueChanged
;
if
(
valueChangedBefore
!
=
aValueChanged
)
{
UpdateState
(
true
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetChecked
(
bool
*
aChecked
)
{
*
aChecked
=
Checked
(
)
;
return
NS_OK
;
}
void
HTMLInputElement
:
:
SetCheckedChanged
(
bool
aCheckedChanged
)
{
DoSetCheckedChanged
(
aCheckedChanged
true
)
;
}
void
HTMLInputElement
:
:
DoSetCheckedChanged
(
bool
aCheckedChanged
bool
aNotify
)
{
if
(
mType
=
=
NS_FORM_INPUT_RADIO
)
{
if
(
mCheckedChanged
!
=
aCheckedChanged
)
{
nsCOMPtr
<
nsIRadioVisitor
>
visitor
=
new
nsRadioSetCheckedChangedVisitor
(
aCheckedChanged
)
;
VisitGroup
(
visitor
aNotify
)
;
}
}
else
{
SetCheckedChangedInternal
(
aCheckedChanged
)
;
}
}
void
HTMLInputElement
:
:
SetCheckedChangedInternal
(
bool
aCheckedChanged
)
{
bool
checkedChangedBefore
=
mCheckedChanged
;
mCheckedChanged
=
aCheckedChanged
;
if
(
checkedChangedBefore
!
=
aCheckedChanged
)
{
UpdateState
(
true
)
;
}
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetChecked
(
bool
aChecked
)
{
DoSetChecked
(
aChecked
true
true
)
;
return
NS_OK
;
}
void
HTMLInputElement
:
:
DoSetChecked
(
bool
aChecked
bool
aNotify
bool
aSetValueChanged
)
{
if
(
aSetValueChanged
)
{
DoSetCheckedChanged
(
true
aNotify
)
;
}
if
(
mChecked
=
=
aChecked
)
{
return
;
}
if
(
mType
!
=
NS_FORM_INPUT_RADIO
)
{
SetCheckedInternal
(
aChecked
aNotify
)
;
return
;
}
if
(
aChecked
)
{
RadioSetChecked
(
aNotify
)
;
return
;
}
nsIRadioGroupContainer
*
container
=
GetRadioGroupContainer
(
)
;
if
(
container
)
{
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
container
-
>
SetCurrentRadioButton
(
name
nullptr
)
;
}
SetCheckedInternal
(
false
aNotify
)
;
}
void
HTMLInputElement
:
:
RadioSetChecked
(
bool
aNotify
)
{
nsCOMPtr
<
nsIDOMHTMLInputElement
>
currentlySelected
=
GetSelectedRadioButton
(
)
;
if
(
currentlySelected
)
{
static_cast
<
HTMLInputElement
*
>
(
currentlySelected
.
get
(
)
)
-
>
SetCheckedInternal
(
false
true
)
;
}
nsIRadioGroupContainer
*
container
=
GetRadioGroupContainer
(
)
;
if
(
container
)
{
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
container
-
>
SetCurrentRadioButton
(
name
this
)
;
}
SetCheckedInternal
(
true
aNotify
)
;
}
nsIRadioGroupContainer
*
HTMLInputElement
:
:
GetRadioGroupContainer
(
)
const
{
NS_ASSERTION
(
mType
=
=
NS_FORM_INPUT_RADIO
"
GetRadioGroupContainer
should
only
be
called
when
type
=
'
radio
'
"
)
;
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
if
(
name
.
IsEmpty
(
)
)
{
return
nullptr
;
}
if
(
mForm
)
{
return
mForm
;
}
return
static_cast
<
nsDocument
*
>
(
GetUncomposedDoc
(
)
)
;
}
already_AddRefed
<
nsIDOMHTMLInputElement
>
HTMLInputElement
:
:
GetSelectedRadioButton
(
)
const
{
nsIRadioGroupContainer
*
container
=
GetRadioGroupContainer
(
)
;
if
(
!
container
)
{
return
nullptr
;
}
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
nsCOMPtr
<
nsIDOMHTMLInputElement
>
selected
=
container
-
>
GetCurrentRadioButton
(
name
)
;
return
selected
.
forget
(
)
;
}
nsresult
HTMLInputElement
:
:
MaybeSubmitForm
(
nsPresContext
*
aPresContext
)
{
if
(
!
mForm
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIPresShell
>
shell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
shell
)
{
return
NS_OK
;
}
nsIFormControl
*
submitControl
=
mForm
-
>
GetDefaultSubmitElement
(
)
;
if
(
submitControl
)
{
nsCOMPtr
<
nsIContent
>
submitContent
=
do_QueryInterface
(
submitControl
)
;
NS_ASSERTION
(
submitContent
"
Form
control
not
implementing
nsIContent
?
!
"
)
;
WidgetMouseEvent
event
(
true
eMouseClick
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
shell
-
>
HandleDOMEventWithTarget
(
submitContent
&
event
&
status
)
;
}
else
if
(
!
mForm
-
>
ImplicitSubmissionIsDisabled
(
)
&
&
mForm
-
>
SubmissionCanProceed
(
nullptr
)
)
{
RefPtr
<
mozilla
:
:
dom
:
:
HTMLFormElement
>
form
=
mForm
;
InternalFormEvent
event
(
true
eFormSubmit
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
shell
-
>
HandleDOMEventWithTarget
(
form
&
event
&
status
)
;
}
return
NS_OK
;
}
void
HTMLInputElement
:
:
SetCheckedInternal
(
bool
aChecked
bool
aNotify
)
{
mChecked
=
aChecked
;
if
(
mType
=
=
NS_FORM_INPUT_CHECKBOX
|
|
mType
=
=
NS_FORM_INPUT_RADIO
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
-
>
InvalidateFrameSubtree
(
)
;
}
}
UpdateAllValidityStates
(
aNotify
)
;
UpdateState
(
aNotify
)
;
if
(
mType
=
=
NS_FORM_INPUT_RADIO
)
{
nsCOMPtr
<
nsIRadioVisitor
>
visitor
=
new
nsRadioUpdateStateVisitor
(
this
)
;
VisitGroup
(
visitor
aNotify
)
;
}
}
void
HTMLInputElement
:
:
Blur
(
ErrorResult
&
aError
)
{
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
HTMLInputElement
*
textControl
=
numberControlFrame
-
>
GetAnonTextControl
(
)
;
if
(
textControl
)
{
textControl
-
>
Blur
(
aError
)
;
return
;
}
}
}
if
(
mType
=
=
NS_FORM_INPUT_TIME
&
&
!
IsExperimentalMobileType
(
mType
)
)
{
nsDateTimeControlFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
HandleBlurEvent
(
)
;
return
;
}
}
nsGenericHTMLElement
:
:
Blur
(
aError
)
;
}
void
HTMLInputElement
:
:
Focus
(
ErrorResult
&
aError
)
{
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
HTMLInputElement
*
textControl
=
numberControlFrame
-
>
GetAnonTextControl
(
)
;
if
(
textControl
)
{
textControl
-
>
Focus
(
aError
)
;
return
;
}
}
}
if
(
mType
=
=
NS_FORM_INPUT_TIME
&
&
!
IsExperimentalMobileType
(
mType
)
)
{
nsDateTimeControlFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
HandleFocusEvent
(
)
;
return
;
}
}
if
(
mType
!
=
NS_FORM_INPUT_FILE
)
{
nsGenericHTMLElement
:
:
Focus
(
aError
)
;
return
;
}
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
for
(
nsIFrame
*
childFrame
:
frame
-
>
PrincipalChildList
(
)
)
{
nsCOMPtr
<
nsIFormControl
>
formCtrl
=
do_QueryInterface
(
childFrame
-
>
GetContent
(
)
)
;
if
(
formCtrl
&
&
formCtrl
-
>
GetType
(
)
=
=
NS_FORM_BUTTON_BUTTON
)
{
nsCOMPtr
<
nsIDOMElement
>
element
=
do_QueryInterface
(
formCtrl
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
element
)
{
fm
-
>
SetFocus
(
element
0
)
;
}
break
;
}
}
}
return
;
}
#
if
!
defined
(
ANDROID
)
&
&
!
defined
(
XP_MACOSX
)
bool
HTMLInputElement
:
:
IsNodeApzAwareInternal
(
)
const
{
return
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
|
|
(
mType
=
=
NS_FORM_INPUT_RANGE
)
|
|
nsINode
:
:
IsNodeApzAwareInternal
(
)
;
}
#
endif
bool
HTMLInputElement
:
:
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
{
return
mType
!
=
NS_FORM_INPUT_HIDDEN
|
|
nsGenericHTMLFormElementWithState
:
:
IsInteractiveHTMLContent
(
aIgnoreTabindex
)
;
}
void
HTMLInputElement
:
:
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
{
nsImageLoadingContent
:
:
AsyncEventRunning
(
aEvent
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
Select
(
)
{
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
return
numberControlFrame
-
>
HandleSelectCall
(
)
;
}
return
NS_OK
;
}
if
(
!
IsSingleLineTextControl
(
false
)
)
{
return
NS_OK
;
}
FocusTristate
state
=
FocusState
(
)
;
if
(
state
=
=
eUnfocusable
)
{
return
NS_OK
;
}
nsTextEditorState
*
tes
=
GetEditorState
(
)
;
if
(
tes
)
{
nsFrameSelection
*
fs
=
tes
-
>
GetConstFrameSelection
(
)
;
if
(
fs
&
&
fs
-
>
MouseDownRecorded
(
)
)
{
fs
-
>
SetDelayedCaretData
(
nullptr
)
;
}
}
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
eForComposedDoc
)
;
if
(
state
=
=
eInactiveWindow
)
{
if
(
fm
)
fm
-
>
SetFocus
(
this
nsIFocusManager
:
:
FLAG_NOSCROLL
)
;
SelectAll
(
presContext
)
;
return
NS_OK
;
}
if
(
DispatchSelectEvent
(
presContext
)
&
&
fm
)
{
fm
-
>
SetFocus
(
this
nsIFocusManager
:
:
FLAG_NOSCROLL
)
;
nsCOMPtr
<
nsIDOMElement
>
focusedElement
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
focusedElement
)
)
;
if
(
SameCOMIdentity
(
static_cast
<
nsIDOMNode
*
>
(
this
)
focusedElement
)
)
{
SelectAll
(
presContext
)
;
}
}
return
NS_OK
;
}
bool
HTMLInputElement
:
:
DispatchSelectEvent
(
nsPresContext
*
aPresContext
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
!
mHandlingSelectEvent
)
{
WidgetEvent
event
(
true
eFormSelect
)
;
mHandlingSelectEvent
=
true
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
aPresContext
&
event
nullptr
&
status
)
;
mHandlingSelectEvent
=
false
;
}
return
(
status
=
=
nsEventStatus_eIgnore
)
;
}
void
HTMLInputElement
:
:
SelectAll
(
nsPresContext
*
aPresContext
)
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
if
(
formControlFrame
)
{
formControlFrame
-
>
SetFormProperty
(
nsGkAtoms
:
:
select
EmptyString
(
)
)
;
}
}
bool
HTMLInputElement
:
:
NeedToInitializeEditorForEvent
(
EventChainPreVisitor
&
aVisitor
)
const
{
if
(
!
IsSingleLineTextControl
(
false
)
|
|
aVisitor
.
mEvent
-
>
mClass
=
=
eMutationEventClass
)
{
return
false
;
}
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseMove
:
case
eMouseEnterIntoWidget
:
case
eMouseExitFromWidget
:
case
eMouseOver
:
case
eMouseOut
:
case
eScrollPortUnderflow
:
case
eScrollPortOverflow
:
return
false
;
default
:
return
true
;
}
}
bool
HTMLInputElement
:
:
IsDisabledForEvents
(
EventMessage
aMessage
)
{
return
IsElementDisabledForEvents
(
aMessage
GetPrimaryFrame
(
)
)
;
}
nsresult
HTMLInputElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
false
;
if
(
IsDisabledForEvents
(
aVisitor
.
mEvent
-
>
mMessage
)
)
{
return
NS_OK
;
}
if
(
NeedToInitializeEditorForEvent
(
aVisitor
)
)
{
nsITextControlFrame
*
textControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
textControlFrame
)
textControlFrame
-
>
EnsureEditorInitialized
(
)
;
}
if
(
!
aVisitor
.
mPresContext
)
{
return
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
bool
outerActivateEvent
=
(
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
)
|
|
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eLegacyDOMActivate
&
&
!
mInInternalActivate
)
)
;
if
(
outerActivateEvent
)
{
aVisitor
.
mItemFlags
|
=
NS_OUTER_ACTIVATE_EVENT
;
}
bool
originalCheckedValue
=
false
;
if
(
outerActivateEvent
)
{
mCheckedIsToggled
=
false
;
switch
(
mType
)
{
case
NS_FORM_INPUT_CHECKBOX
:
{
if
(
mIndeterminate
)
{
SetIndeterminateInternal
(
false
false
)
;
aVisitor
.
mItemFlags
|
=
NS_ORIGINAL_INDETERMINATE_VALUE
;
}
GetChecked
(
&
originalCheckedValue
)
;
DoSetChecked
(
!
originalCheckedValue
true
true
)
;
mCheckedIsToggled
=
true
;
}
break
;
case
NS_FORM_INPUT_RADIO
:
{
nsCOMPtr
<
nsIDOMHTMLInputElement
>
selectedRadioButton
=
GetSelectedRadioButton
(
)
;
aVisitor
.
mItemData
=
selectedRadioButton
;
originalCheckedValue
=
mChecked
;
if
(
!
originalCheckedValue
)
{
DoSetChecked
(
true
true
true
)
;
mCheckedIsToggled
=
true
;
}
}
break
;
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_IMAGE
:
if
(
mForm
)
{
mForm
-
>
OnSubmitClickBegin
(
this
)
;
}
break
;
default
:
break
;
}
}
if
(
originalCheckedValue
)
{
aVisitor
.
mItemFlags
|
=
NS_ORIGINAL_CHECKED_VALUE
;
}
if
(
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
)
{
aVisitor
.
mItemFlags
|
=
NS_NO_CONTENT_DISPATCH
;
}
if
(
IsSingleLineTextControl
(
false
)
&
&
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseClick
&
&
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eMiddleButton
)
{
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
=
false
;
}
aVisitor
.
mItemFlags
|
=
mType
;
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
MayFireChangeOnBlur
(
)
&
&
!
mIsDraggingRange
)
{
GetValue
(
mFocusedValue
CallerType
:
:
System
)
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
{
aVisitor
.
mWantsPreHandleEvent
=
true
;
aVisitor
.
mItemFlags
|
=
NS_PRE_HANDLE_BLUR_EVENT
;
}
if
(
mType
=
=
NS_FORM_INPUT_RANGE
&
&
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
-
>
InvalidateFrameSubtree
(
)
;
}
}
if
(
mType
=
=
NS_FORM_INPUT_TIME
&
&
!
IsExperimentalMobileType
(
mType
)
&
&
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
&
&
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
this
)
{
nsDateTimeControlFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
HandleFocusEvent
(
)
;
}
}
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
if
(
mNumberControlSpinnerIsSpinning
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseMove
)
{
bool
stopSpin
=
true
;
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
bool
oldNumberControlSpinTimerSpinsUpValue
=
mNumberControlSpinnerSpinsUp
;
switch
(
numberControlFrame
-
>
GetSpinButtonForPointerEvent
(
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
)
)
{
case
nsNumberControlFrame
:
:
eSpinButtonUp
:
mNumberControlSpinnerSpinsUp
=
true
;
stopSpin
=
false
;
break
;
case
nsNumberControlFrame
:
:
eSpinButtonDown
:
mNumberControlSpinnerSpinsUp
=
false
;
stopSpin
=
false
;
break
;
}
if
(
mNumberControlSpinnerSpinsUp
!
=
oldNumberControlSpinTimerSpinsUpValue
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
numberControlFrame
-
>
SpinnerStateChanged
(
)
;
}
}
}
if
(
stopSpin
)
{
StopNumberControlSpinnerSpin
(
)
;
}
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseUp
)
{
StopNumberControlSpinnerSpin
(
)
;
}
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
numberControlFrame
-
>
HandleFocusEvent
(
aVisitor
.
mEvent
)
;
}
}
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsThemed
(
)
)
{
frame
-
>
InvalidateFrame
(
)
;
}
}
}
nsresult
rv
=
nsGenericHTMLFormElementWithState
:
:
GetEventTargetParent
(
aVisitor
)
;
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
aVisitor
.
mEvent
-
>
mOriginalTarget
!
=
this
)
{
HTMLInputElement
*
textControl
=
nullptr
;
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
textControl
=
numberControlFrame
-
>
GetAnonTextControl
(
)
;
}
if
(
textControl
&
&
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
textControl
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eEditorInput
)
{
aVisitor
.
mWantsPreHandleEvent
=
true
;
aVisitor
.
mItemFlags
|
=
NS_PRE_HANDLE_INPUT_EVENT
;
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFormChange
)
{
aVisitor
.
mCanHandle
=
false
;
}
}
}
if
(
mType
=
=
NS_FORM_INPUT_TIME
&
&
!
IsExperimentalMobileType
(
mType
)
&
&
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocusIn
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocusOut
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
)
{
nsCOMPtr
<
nsIContent
>
originalTarget
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
AsFocusEvent
(
)
-
>
mRelatedTarget
)
;
nsCOMPtr
<
nsIContent
>
relatedTarget
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
AsFocusEvent
(
)
-
>
mRelatedTarget
)
;
if
(
originalTarget
&
&
relatedTarget
&
&
originalTarget
-
>
FindFirstNonChromeOnlyAccessContent
(
)
=
=
relatedTarget
-
>
FindFirstNonChromeOnlyAccessContent
(
)
)
{
aVisitor
.
mCanHandle
=
false
;
}
}
return
rv
;
}
nsresult
HTMLInputElement
:
:
PreHandleEvent
(
EventChainVisitor
&
aVisitor
)
{
if
(
!
aVisitor
.
mPresContext
)
{
return
nsGenericHTMLElement
:
:
PreHandleEvent
(
aVisitor
)
;
}
nsresult
rv
;
if
(
aVisitor
.
mItemFlags
&
NS_PRE_HANDLE_BLUR_EVENT
)
{
MOZ_ASSERT
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
;
if
(
IsExperimentalMobileType
(
mType
)
)
{
nsAutoString
aValue
;
GetNonFileValueInternal
(
aValue
)
;
rv
=
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_Internal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
FireChangeEventIfNeeded
(
)
;
}
rv
=
nsGenericHTMLFormElementWithState
:
:
PreHandleEvent
(
aVisitor
)
;
if
(
aVisitor
.
mItemFlags
&
NS_PRE_HANDLE_INPUT_EVENT
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
MOZ_ASSERT
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eEditorInput
)
;
MOZ_ASSERT
(
numberControlFrame
)
;
MOZ_ASSERT
(
numberControlFrame
-
>
GetAnonTextControl
(
)
=
=
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
nsAutoString
value
;
numberControlFrame
-
>
GetValueOfAnonTextControl
(
value
)
;
numberControlFrame
-
>
HandlingInputEvent
(
true
)
;
nsWeakFrame
weakNumberControlFrame
(
numberControlFrame
)
;
rv
=
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_BySetUserInput
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
weakNumberControlFrame
.
IsAlive
(
)
)
{
numberControlFrame
-
>
HandlingInputEvent
(
false
)
;
}
}
return
rv
;
}
void
HTMLInputElement
:
:
StartRangeThumbDrag
(
WidgetGUIEvent
*
aEvent
)
{
mIsDraggingRange
=
true
;
mRangeThumbDragStartValue
=
GetValueAsDecimal
(
)
;
nsIPresShell
:
:
SetCapturingContent
(
this
CAPTURE_IGNOREALLOWED
)
;
nsRangeFrame
*
rangeFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
GetValue
(
mFocusedValue
CallerType
:
:
System
)
;
SetValueOfRangeForUserEvent
(
rangeFrame
-
>
GetValueAtEventPoint
(
aEvent
)
)
;
}
void
HTMLInputElement
:
:
FinishRangeThumbDrag
(
WidgetGUIEvent
*
aEvent
)
{
MOZ_ASSERT
(
mIsDraggingRange
)
;
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
=
=
this
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
if
(
aEvent
)
{
nsRangeFrame
*
rangeFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
SetValueOfRangeForUserEvent
(
rangeFrame
-
>
GetValueAtEventPoint
(
aEvent
)
)
;
}
mIsDraggingRange
=
false
;
FireChangeEventIfNeeded
(
)
;
}
void
HTMLInputElement
:
:
CancelRangeThumbDrag
(
bool
aIsForUserEvent
)
{
MOZ_ASSERT
(
mIsDraggingRange
)
;
mIsDraggingRange
=
false
;
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
=
=
this
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
if
(
aIsForUserEvent
)
{
SetValueOfRangeForUserEvent
(
mRangeThumbDragStartValue
)
;
}
else
{
nsAutoString
val
;
ConvertNumberToString
(
mRangeThumbDragStartValue
val
)
;
SetValueInternal
(
val
nsTextEditorState
:
:
eSetValue_BySetUserInput
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
nsRangeFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
UpdateForValueChange
(
)
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
input
"
)
true
false
)
;
asyncDispatcher
-
>
RunDOMEventWhenSafe
(
)
;
}
}
void
HTMLInputElement
:
:
SetValueOfRangeForUserEvent
(
Decimal
aValue
)
{
MOZ_ASSERT
(
aValue
.
isFinite
(
)
)
;
Decimal
oldValue
=
GetValueAsDecimal
(
)
;
nsAutoString
val
;
ConvertNumberToString
(
aValue
val
)
;
SetValueInternal
(
val
nsTextEditorState
:
:
eSetValue_BySetUserInput
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
nsRangeFrame
*
frame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
frame
)
{
frame
-
>
UpdateForValueChange
(
)
;
}
if
(
GetValueAsDecimal
(
)
!
=
oldValue
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
input
"
)
true
false
)
;
}
}
void
HTMLInputElement
:
:
StartNumberControlSpinnerSpin
(
)
{
MOZ_ASSERT
(
!
mNumberControlSpinnerIsSpinning
)
;
mNumberControlSpinnerIsSpinning
=
true
;
nsRepeatService
:
:
GetInstance
(
)
-
>
Start
(
HandleNumberControlSpin
this
)
;
nsIPresShell
:
:
SetCapturingContent
(
this
CAPTURE_IGNOREALLOWED
)
;
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
numberControlFrame
-
>
SpinnerStateChanged
(
)
;
}
}
void
HTMLInputElement
:
:
StopNumberControlSpinnerSpin
(
SpinnerStopState
aState
)
{
if
(
mNumberControlSpinnerIsSpinning
)
{
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
=
=
this
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
nsRepeatService
:
:
GetInstance
(
)
-
>
Stop
(
HandleNumberControlSpin
this
)
;
mNumberControlSpinnerIsSpinning
=
false
;
if
(
aState
=
=
eAllowDispatchingEvents
)
{
FireChangeEventIfNeeded
(
)
;
}
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
MOZ_ASSERT
(
aState
=
=
eAllowDispatchingEvents
"
Shouldn
'
t
have
primary
frame
for
the
element
when
we
'
re
not
"
"
allowed
to
dispatch
events
to
it
anymore
.
"
)
;
numberControlFrame
-
>
SpinnerStateChanged
(
)
;
}
}
}
void
HTMLInputElement
:
:
StepNumberControlForUserEvent
(
int32_t
aDirection
)
{
if
(
HasBadInput
(
)
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
&
&
!
numberControlFrame
-
>
AnonTextControlIsEmpty
(
)
)
{
UpdateValidityUIBits
(
true
)
;
UpdateState
(
true
)
;
return
;
}
}
Decimal
newValue
=
Decimal
:
:
nan
(
)
;
nsresult
rv
=
GetValueIfStepped
(
aDirection
CALLED_FOR_USER_EVENT
&
newValue
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
newValue
.
isFinite
(
)
)
{
return
;
}
nsAutoString
newVal
;
ConvertNumberToString
(
newValue
newVal
)
;
SetValueInternal
(
newVal
nsTextEditorState
:
:
eSetValue_BySetUserInput
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
input
"
)
true
false
)
;
}
static
bool
SelectTextFieldOnFocus
(
)
{
if
(
!
gSelectTextFieldOnFocus
)
{
int32_t
selectTextfieldsOnKeyFocus
=
-
1
;
nsresult
rv
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_SelectTextfieldsOnKeyFocus
&
selectTextfieldsOnKeyFocus
)
;
if
(
NS_FAILED
(
rv
)
)
{
gSelectTextFieldOnFocus
=
-
1
;
}
else
{
gSelectTextFieldOnFocus
=
selectTextfieldsOnKeyFocus
!
=
0
?
1
:
-
1
;
}
}
return
gSelectTextFieldOnFocus
=
=
1
;
}
bool
HTMLInputElement
:
:
ShouldPreventDOMActivateDispatch
(
EventTarget
*
aOriginalTarget
)
{
if
(
mType
!
=
NS_FORM_INPUT_FILE
)
{
return
false
;
}
nsCOMPtr
<
nsIContent
>
target
=
do_QueryInterface
(
aOriginalTarget
)
;
if
(
!
target
)
{
return
false
;
}
return
target
-
>
GetParent
(
)
=
=
this
&
&
target
-
>
IsRootOfNativeAnonymousSubtree
(
)
&
&
target
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
button
eCaseMatters
)
;
}
nsresult
HTMLInputElement
:
:
MaybeInitPickers
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
!
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
)
)
{
return
NS_OK
;
}
if
(
mType
=
=
NS_FORM_INPUT_FILE
)
{
FilePickerType
type
=
FILE_PICKER_FILE
;
nsCOMPtr
<
nsIContent
>
target
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
if
(
target
&
&
target
-
>
FindFirstNonChromeOnlyAccessContent
(
)
=
=
this
&
&
(
(
Preferences
:
:
GetBool
(
"
dom
.
input
.
dirpicker
"
false
)
&
&
Allowdirs
(
)
)
|
|
(
Preferences
:
:
GetBool
(
"
dom
.
webkitBlink
.
dirPicker
.
enabled
"
false
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
webkitdirectory
)
)
)
)
{
type
=
FILE_PICKER_DIRECTORY
;
}
return
InitFilePicker
(
type
)
;
}
if
(
mType
=
=
NS_FORM_INPUT_COLOR
)
{
return
InitColorPicker
(
)
;
}
if
(
mType
=
=
NS_FORM_INPUT_DATE
)
{
return
InitDatePicker
(
)
;
}
return
NS_OK
;
}
static
bool
IgnoreInputEventWithModifier
(
WidgetInputEvent
*
aEvent
)
{
return
aEvent
-
>
IsShift
(
)
|
|
aEvent
-
>
IsControl
(
)
|
|
aEvent
-
>
IsAlt
(
)
|
|
aEvent
-
>
IsMeta
(
)
|
|
aEvent
-
>
IsAltGraph
(
)
|
|
aEvent
-
>
IsFn
(
)
|
|
aEvent
-
>
IsOS
(
)
;
}
nsresult
HTMLInputElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
!
aVisitor
.
mPresContext
)
{
return
MaybeInitPickers
(
aVisitor
)
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
{
if
(
mIsDraggingRange
)
{
FinishRangeThumbDrag
(
)
;
}
else
if
(
mNumberControlSpinnerIsSpinning
)
{
StopNumberControlSpinnerSpin
(
)
;
}
}
UpdateValidityUIBits
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
)
;
UpdateState
(
true
)
;
}
nsresult
rv
=
NS_OK
;
bool
outerActivateEvent
=
!
!
(
aVisitor
.
mItemFlags
&
NS_OUTER_ACTIVATE_EVENT
)
;
bool
originalCheckedValue
=
!
!
(
aVisitor
.
mItemFlags
&
NS_ORIGINAL_CHECKED_VALUE
)
;
bool
noContentDispatch
=
!
!
(
aVisitor
.
mItemFlags
&
NS_NO_CONTENT_DISPATCH
)
;
uint8_t
oldType
=
NS_CONTROL_TYPE
(
aVisitor
.
mItemFlags
)
;
if
(
aVisitor
.
mEventStatus
!
=
nsEventStatus_eConsumeNoDefault
&
&
!
IsSingleLineTextControl
(
true
)
&
&
mType
!
=
NS_FORM_INPUT_NUMBER
)
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
&
&
!
ShouldPreventDOMActivateDispatch
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
)
{
InternalUIEvent
actEvent
(
true
eLegacyDOMActivate
mouseEvent
)
;
actEvent
.
mDetail
=
1
;
nsCOMPtr
<
nsIPresShell
>
shell
=
aVisitor
.
mPresContext
-
>
GetPresShell
(
)
;
if
(
shell
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mInInternalActivate
=
true
;
rv
=
shell
-
>
HandleDOMEventWithTarget
(
this
&
actEvent
&
status
)
;
mInInternalActivate
=
false
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
aVisitor
.
mEventStatus
=
status
;
}
}
}
}
if
(
outerActivateEvent
)
{
switch
(
oldType
)
{
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_IMAGE
:
if
(
mForm
)
{
mForm
-
>
OnSubmitClickEnd
(
)
;
}
break
;
default
:
break
;
}
}
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
=
noContentDispatch
;
if
(
mCheckedIsToggled
&
&
outerActivateEvent
)
{
if
(
aVisitor
.
mEventStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
if
(
oldType
=
=
NS_FORM_INPUT_RADIO
)
{
nsCOMPtr
<
nsIDOMHTMLInputElement
>
selectedRadioButton
=
do_QueryInterface
(
aVisitor
.
mItemData
)
;
if
(
selectedRadioButton
)
{
selectedRadioButton
-
>
SetChecked
(
true
)
;
}
if
(
!
selectedRadioButton
|
|
mType
!
=
NS_FORM_INPUT_RADIO
)
{
DoSetChecked
(
false
true
true
)
;
}
}
else
if
(
oldType
=
=
NS_FORM_INPUT_CHECKBOX
)
{
bool
originalIndeterminateValue
=
!
!
(
aVisitor
.
mItemFlags
&
NS_ORIGINAL_INDETERMINATE_VALUE
)
;
SetIndeterminateInternal
(
originalIndeterminateValue
false
)
;
DoSetChecked
(
originalCheckedValue
true
true
)
;
}
}
else
{
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
input
"
)
true
false
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIDOMHTMLInputElement
*
>
(
this
)
NS_LITERAL_STRING
(
"
change
"
)
true
false
)
;
#
ifdef
ACCESSIBILITY
if
(
mType
=
=
NS_FORM_INPUT_CHECKBOX
)
{
FireEventForAccessibility
(
this
aVisitor
.
mPresContext
NS_LITERAL_STRING
(
"
CheckboxStateChange
"
)
)
;
}
else
{
FireEventForAccessibility
(
this
aVisitor
.
mPresContext
NS_LITERAL_STRING
(
"
RadioStateChange
"
)
)
;
nsCOMPtr
<
nsIDOMHTMLInputElement
>
previous
=
do_QueryInterface
(
aVisitor
.
mItemData
)
;
if
(
previous
)
{
FireEventForAccessibility
(
previous
aVisitor
.
mPresContext
NS_LITERAL_STRING
(
"
RadioStateChange
"
)
)
;
}
}
#
endif
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
WidgetKeyboardEvent
*
keyEvent
=
aVisitor
.
mEvent
-
>
AsKeyboardEvent
(
)
;
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
&
&
keyEvent
&
&
keyEvent
-
>
mMessage
=
=
eKeyPress
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_DOWN
)
&
&
!
IgnoreInputEventWithModifier
(
keyEvent
)
)
{
if
(
!
aVisitor
.
mEvent
-
>
DefaultPreventedByContent
(
)
&
&
IsMutable
(
)
)
{
StepNumberControlForUserEvent
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_UP
?
1
:
-
1
)
;
FireChangeEventIfNeeded
(
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
else
if
(
nsEventStatus_eIgnore
=
=
aVisitor
.
mEventStatus
)
{
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eFocus
:
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
IsSingleLineTextControl
(
false
)
&
&
!
aVisitor
.
mEvent
-
>
AsFocusEvent
(
)
-
>
mFromRaise
&
&
SelectTextFieldOnFocus
(
)
)
{
nsIDocument
*
document
=
GetComposedDoc
(
)
;
if
(
document
)
{
uint32_t
lastFocusMethod
;
fm
-
>
GetLastFocusMethod
(
document
-
>
GetWindow
(
)
&
lastFocusMethod
)
;
if
(
lastFocusMethod
&
(
nsIFocusManager
:
:
FLAG_BYKEY
|
nsIFocusManager
:
:
FLAG_BYMOVEFOCUS
)
)
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
eForComposedDoc
)
;
if
(
DispatchSelectEvent
(
presContext
)
)
{
SelectAll
(
presContext
)
;
}
}
}
}
break
;
}
case
eKeyPress
:
case
eKeyUp
:
{
WidgetKeyboardEvent
*
keyEvent
=
aVisitor
.
mEvent
-
>
AsKeyboardEvent
(
)
;
if
(
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eKeyPress
&
&
keyEvent
-
>
mKeyCode
=
=
NS_VK_RETURN
)
|
|
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eKeyUp
&
&
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
)
)
{
switch
(
mType
)
{
case
NS_FORM_INPUT_CHECKBOX
:
case
NS_FORM_INPUT_RADIO
:
{
if
(
keyEvent
-
>
mKeyCode
!
=
NS_VK_SPACE
)
{
MaybeSubmitForm
(
aVisitor
.
mPresContext
)
;
break
;
}
MOZ_FALLTHROUGH
;
}
case
NS_FORM_INPUT_BUTTON
:
case
NS_FORM_INPUT_RESET
:
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_IMAGE
:
case
NS_FORM_INPUT_COLOR
:
{
DispatchSimulatedClick
(
this
aVisitor
.
mEvent
-
>
IsTrusted
(
)
aVisitor
.
mPresContext
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eKeyPress
&
&
mType
=
=
NS_FORM_INPUT_RADIO
&
&
!
keyEvent
-
>
IsAlt
(
)
&
&
!
keyEvent
-
>
IsControl
(
)
&
&
!
keyEvent
-
>
IsMeta
(
)
)
{
bool
isMovingBack
=
false
;
switch
(
keyEvent
-
>
mKeyCode
)
{
case
NS_VK_UP
:
case
NS_VK_LEFT
:
isMovingBack
=
true
;
MOZ_FALLTHROUGH
;
case
NS_VK_DOWN
:
case
NS_VK_RIGHT
:
nsIRadioGroupContainer
*
container
=
GetRadioGroupContainer
(
)
;
if
(
container
)
{
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
RefPtr
<
HTMLInputElement
>
selectedRadioButton
;
container
-
>
GetNextRadioButton
(
name
isMovingBack
this
getter_AddRefs
(
selectedRadioButton
)
)
;
if
(
selectedRadioButton
)
{
rv
=
selectedRadioButton
-
>
Focus
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
DispatchSimulatedClick
(
selectedRadioButton
aVisitor
.
mEvent
-
>
IsTrusted
(
)
aVisitor
.
mPresContext
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
}
}
}
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eKeyPress
&
&
keyEvent
-
>
mKeyCode
=
=
NS_VK_RETURN
&
&
(
IsSingleLineTextControl
(
false
mType
)
|
|
mType
=
=
NS_FORM_INPUT_NUMBER
|
|
IsExperimentalMobileType
(
mType
)
|
|
IsDateTimeInputType
(
mType
)
)
)
{
FireChangeEventIfNeeded
(
)
;
rv
=
MaybeSubmitForm
(
aVisitor
.
mPresContext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eKeyPress
&
&
mType
=
=
NS_FORM_INPUT_RANGE
&
&
!
keyEvent
-
>
IsAlt
(
)
&
&
!
keyEvent
-
>
IsControl
(
)
&
&
!
keyEvent
-
>
IsMeta
(
)
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_LEFT
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_RIGHT
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_DOWN
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_PAGE_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_PAGE_DOWN
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_HOME
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_END
)
)
{
Decimal
minimum
=
GetMinimum
(
)
;
Decimal
maximum
=
GetMaximum
(
)
;
MOZ_ASSERT
(
minimum
.
isFinite
(
)
&
&
maximum
.
isFinite
(
)
)
;
if
(
minimum
<
maximum
)
{
Decimal
value
=
GetValueAsDecimal
(
)
;
Decimal
step
=
GetStep
(
)
;
if
(
step
=
=
kStepAny
)
{
step
=
GetDefaultStep
(
)
;
}
MOZ_ASSERT
(
value
.
isFinite
(
)
&
&
step
.
isFinite
(
)
)
;
Decimal
newValue
;
switch
(
keyEvent
-
>
mKeyCode
)
{
case
NS_VK_LEFT
:
newValue
=
value
+
(
GetComputedDirectionality
(
)
=
=
eDir_RTL
?
step
:
-
step
)
;
break
;
case
NS_VK_RIGHT
:
newValue
=
value
+
(
GetComputedDirectionality
(
)
=
=
eDir_RTL
?
-
step
:
step
)
;
break
;
case
NS_VK_UP
:
newValue
=
value
+
step
;
break
;
case
NS_VK_DOWN
:
newValue
=
value
-
step
;
break
;
case
NS_VK_HOME
:
newValue
=
minimum
;
break
;
case
NS_VK_END
:
newValue
=
maximum
;
break
;
case
NS_VK_PAGE_UP
:
newValue
=
value
+
std
:
:
max
(
step
(
maximum
-
minimum
)
/
Decimal
(
10
)
)
;
break
;
case
NS_VK_PAGE_DOWN
:
newValue
=
value
-
std
:
:
max
(
step
(
maximum
-
minimum
)
/
Decimal
(
10
)
)
;
break
;
}
SetValueOfRangeForUserEvent
(
newValue
)
;
FireChangeEventIfNeeded
(
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
}
break
;
case
eMouseDown
:
case
eMouseUp
:
case
eMouseDoubleClick
:
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
button
=
=
WidgetMouseEvent
:
:
eMiddleButton
|
|
mouseEvent
-
>
button
=
=
WidgetMouseEvent
:
:
eRightButton
)
{
if
(
mType
=
=
NS_FORM_INPUT_BUTTON
|
|
mType
=
=
NS_FORM_INPUT_RESET
|
|
mType
=
=
NS_FORM_INPUT_SUBMIT
)
{
if
(
aVisitor
.
mDOMEvent
)
{
aVisitor
.
mDOMEvent
-
>
StopPropagation
(
)
;
}
else
{
rv
=
NS_ERROR_FAILURE
;
}
}
}
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
if
(
mouseEvent
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
&
&
!
IgnoreInputEventWithModifier
(
mouseEvent
)
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseDown
&
&
IsMutable
(
)
)
{
switch
(
numberControlFrame
-
>
GetSpinButtonForPointerEvent
(
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
)
)
{
case
nsNumberControlFrame
:
:
eSpinButtonUp
:
StepNumberControlForUserEvent
(
1
)
;
mNumberControlSpinnerSpinsUp
=
true
;
StartNumberControlSpinnerSpin
(
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
break
;
case
nsNumberControlFrame
:
:
eSpinButtonDown
:
StepNumberControlForUserEvent
(
-
1
)
;
mNumberControlSpinnerSpinsUp
=
false
;
StartNumberControlSpinnerSpin
(
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
break
;
}
}
}
}
if
(
aVisitor
.
mEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
StopNumberControlSpinnerSpin
(
)
;
}
}
break
;
}
#
if
!
defined
(
ANDROID
)
&
&
!
defined
(
XP_MACOSX
)
case
eWheel
:
{
WidgetWheelEvent
*
wheelEvent
=
aVisitor
.
mEvent
-
>
AsWheelEvent
(
)
;
if
(
!
aVisitor
.
mEvent
-
>
DefaultPrevented
(
)
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
IsMutable
(
)
&
&
wheelEvent
&
&
wheelEvent
-
>
mDeltaY
!
=
0
&
&
wheelEvent
-
>
mDeltaMode
!
=
nsIDOMWheelEvent
:
:
DOM_DELTA_PIXEL
)
{
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
&
&
numberControlFrame
-
>
IsFocused
(
)
)
{
StepNumberControlForUserEvent
(
wheelEvent
-
>
mDeltaY
>
0
?
-
1
:
1
)
;
FireChangeEventIfNeeded
(
)
;
aVisitor
.
mEvent
-
>
PreventDefault
(
)
;
}
}
else
if
(
mType
=
=
NS_FORM_INPUT_RANGE
&
&
nsContentUtils
:
:
IsFocusedContent
(
this
)
&
&
GetMinimum
(
)
<
GetMaximum
(
)
)
{
Decimal
value
=
GetValueAsDecimal
(
)
;
Decimal
step
=
GetStep
(
)
;
if
(
step
=
=
kStepAny
)
{
step
=
GetDefaultStep
(
)
;
}
MOZ_ASSERT
(
value
.
isFinite
(
)
&
&
step
.
isFinite
(
)
)
;
SetValueOfRangeForUserEvent
(
wheelEvent
-
>
mDeltaY
<
0
?
value
+
step
:
value
-
step
)
;
FireChangeEventIfNeeded
(
)
;
aVisitor
.
mEvent
-
>
PreventDefault
(
)
;
}
}
break
;
}
#
endif
default
:
break
;
}
if
(
outerActivateEvent
)
{
if
(
mForm
&
&
(
oldType
=
=
NS_FORM_INPUT_SUBMIT
|
|
oldType
=
=
NS_FORM_INPUT_IMAGE
)
)
{
if
(
mType
!
=
NS_FORM_INPUT_SUBMIT
&
&
mType
!
=
NS_FORM_INPUT_IMAGE
)
{
mForm
-
>
FlushPendingSubmission
(
)
;
}
}
switch
(
mType
)
{
case
NS_FORM_INPUT_RESET
:
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_IMAGE
:
if
(
mForm
)
{
InternalFormEvent
event
(
true
(
mType
=
=
NS_FORM_INPUT_RESET
)
?
eFormReset
:
eFormSubmit
)
;
event
.
mOriginator
=
this
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
aVisitor
.
mPresContext
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
(
event
.
mMessage
!
=
eFormSubmit
|
|
mForm
-
>
SubmissionCanProceed
(
this
)
)
)
{
RefPtr
<
mozilla
:
:
dom
:
:
HTMLFormElement
>
form
(
mForm
)
;
presShell
-
>
HandleDOMEventWithTarget
(
form
&
event
&
status
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
break
;
default
:
break
;
}
}
}
else
if
(
outerActivateEvent
&
&
(
oldType
=
=
NS_FORM_INPUT_SUBMIT
|
|
oldType
=
=
NS_FORM_INPUT_IMAGE
)
&
&
mForm
)
{
mForm
-
>
FlushPendingSubmission
(
)
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
mType
=
=
NS_FORM_INPUT_RANGE
)
{
PostHandleEventForRangeThumb
(
aVisitor
)
;
}
return
MaybeInitPickers
(
aVisitor
)
;
}
void
HTMLInputElement
:
:
PostHandleEventForRangeThumb
(
EventChainPostVisitor
&
aVisitor
)
{
MOZ_ASSERT
(
mType
=
=
NS_FORM_INPUT_RANGE
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
aVisitor
.
mEventStatus
|
|
!
(
aVisitor
.
mEvent
-
>
mClass
=
=
eMouseEventClass
|
|
aVisitor
.
mEvent
-
>
mClass
=
=
eTouchEventClass
|
|
aVisitor
.
mEvent
-
>
mClass
=
=
eKeyboardEventClass
)
)
{
return
;
}
nsRangeFrame
*
rangeFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
!
rangeFrame
&
&
mIsDraggingRange
)
{
CancelRangeThumbDrag
(
)
;
return
;
}
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseDown
:
case
eTouchStart
:
{
if
(
mIsDraggingRange
)
{
break
;
}
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
)
{
break
;
}
WidgetInputEvent
*
inputEvent
=
aVisitor
.
mEvent
-
>
AsInputEvent
(
)
;
if
(
IgnoreInputEventWithModifier
(
inputEvent
)
)
{
break
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseDown
)
{
if
(
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
-
>
buttons
=
=
WidgetMouseEvent
:
:
eLeftButtonFlag
)
{
StartRangeThumbDrag
(
inputEvent
)
;
}
else
if
(
mIsDraggingRange
)
{
CancelRangeThumbDrag
(
)
;
}
}
else
{
if
(
aVisitor
.
mEvent
-
>
AsTouchEvent
(
)
-
>
mTouches
.
Length
(
)
=
=
1
)
{
StartRangeThumbDrag
(
inputEvent
)
;
}
else
if
(
mIsDraggingRange
)
{
CancelRangeThumbDrag
(
)
;
}
}
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
break
;
case
eMouseMove
:
case
eTouchMove
:
if
(
!
mIsDraggingRange
)
{
break
;
}
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
!
=
this
)
{
CancelRangeThumbDrag
(
)
;
break
;
}
SetValueOfRangeForUserEvent
(
rangeFrame
-
>
GetValueAtEventPoint
(
aVisitor
.
mEvent
-
>
AsInputEvent
(
)
)
)
;
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
break
;
case
eMouseUp
:
case
eTouchEnd
:
if
(
!
mIsDraggingRange
)
{
break
;
}
FinishRangeThumbDrag
(
aVisitor
.
mEvent
-
>
AsInputEvent
(
)
)
;
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
break
;
case
eKeyPress
:
if
(
mIsDraggingRange
&
&
aVisitor
.
mEvent
-
>
AsKeyboardEvent
(
)
-
>
mKeyCode
=
=
NS_VK_ESCAPE
)
{
CancelRangeThumbDrag
(
)
;
}
break
;
case
eTouchCancel
:
if
(
mIsDraggingRange
)
{
CancelRangeThumbDrag
(
)
;
}
break
;
default
:
break
;
}
}
void
HTMLInputElement
:
:
MaybeLoadImage
(
)
{
nsAutoString
uri
;
if
(
mType
=
=
NS_FORM_INPUT_IMAGE
&
&
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
uri
)
&
&
(
NS_FAILED
(
LoadImage
(
uri
false
true
eImageLoadType_Normal
)
)
|
|
!
LoadingEnabled
(
)
)
)
{
CancelImageRequests
(
true
)
;
}
}
nsresult
HTMLInputElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
bool
aCompileEventHandlers
)
{
nsresult
rv
=
nsGenericHTMLFormElementWithState
:
:
BindToTree
(
aDocument
aParent
aBindingParent
aCompileEventHandlers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsImageLoadingContent
:
:
BindToTree
(
aDocument
aParent
aBindingParent
aCompileEventHandlers
)
;
if
(
mType
=
=
NS_FORM_INPUT_IMAGE
)
{
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
)
{
ClearBrokenState
(
)
;
RemoveStatesSilently
(
NS_EVENT_STATE_BROKEN
)
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
this
&
HTMLInputElement
:
:
MaybeLoadImage
)
)
;
}
}
if
(
aDocument
&
&
!
mForm
&
&
mType
=
=
NS_FORM_INPUT_RADIO
)
{
AddedToRadioGroup
(
)
;
}
SetDirectionIfAuto
(
HasDirAuto
(
)
false
)
;
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateState
(
false
)
;
if
(
mType
=
=
NS_FORM_INPUT_PASSWORD
)
{
if
(
IsInComposedDoc
(
)
)
{
AsyncEventDispatcher
*
dispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
DOMInputPasswordAdded
"
)
true
true
)
;
dispatcher
-
>
PostDOMEvent
(
)
;
}
#
ifdef
EARLY_BETA_OR_EARLIER
Telemetry
:
:
Accumulate
(
Telemetry
:
:
PWMGR_PASSWORD_INPUT_IN_FORM
!
!
mForm
)
;
#
endif
}
return
rv
;
}
void
HTMLInputElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
if
(
!
mForm
&
&
mType
=
=
NS_FORM_INPUT_RADIO
)
{
WillRemoveFromRadioGroup
(
)
;
}
nsImageLoadingContent
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
nsGenericHTMLFormElementWithState
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateState
(
false
)
;
}
void
HTMLInputElement
:
:
HandleTypeChange
(
uint8_t
aNewType
)
{
if
(
mType
=
=
NS_FORM_INPUT_RANGE
&
&
mIsDraggingRange
)
{
CancelRangeThumbDrag
(
false
)
;
}
ValueModeType
aOldValueMode
=
GetValueMode
(
)
;
uint8_t
oldType
=
mType
;
nsAutoString
aOldValue
;
if
(
aOldValueMode
=
=
VALUE_MODE_VALUE
)
{
GetValue
(
aOldValue
CallerType
:
:
NonSystem
)
;
}
nsTextEditorState
:
:
SelectionProperties
sp
;
if
(
GetEditorState
(
)
)
{
sp
=
mInputData
.
mState
-
>
GetSelectionProperties
(
)
;
}
FreeData
(
)
;
mType
=
aNewType
;
if
(
IsSingleLineTextControl
(
)
)
{
mInputData
.
mState
=
new
nsTextEditorState
(
this
)
;
if
(
!
sp
.
IsDefault
(
)
)
{
mInputData
.
mState
-
>
SetSelectionProperties
(
sp
)
;
}
}
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_DEFAULT
:
case
VALUE_MODE_DEFAULT_ON
:
if
(
aOldValueMode
=
=
VALUE_MODE_VALUE
&
&
!
aOldValue
.
IsEmpty
(
)
)
{
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aOldValue
true
)
;
}
break
;
case
VALUE_MODE_VALUE
:
{
nsAutoString
value
;
if
(
aOldValueMode
!
=
VALUE_MODE_VALUE
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
value
)
;
}
else
{
value
=
aOldValue
;
}
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_Internal
)
;
}
break
;
case
VALUE_MODE_FILENAME
:
default
:
break
;
}
if
(
MayFireChangeOnBlur
(
mType
)
&
&
!
MayFireChangeOnBlur
(
oldType
)
)
{
GetValue
(
mFocusedValue
CallerType
:
:
System
)
;
}
else
if
(
!
IsSingleLineTextControl
(
false
mType
)
&
&
IsSingleLineTextControl
(
false
oldType
)
)
{
mFocusedValue
.
Truncate
(
)
;
}
UpdateHasRange
(
)
;
UpdateAllValidityStates
(
false
)
;
UpdateApzAwareFlag
(
)
;
}
void
HTMLInputElement
:
:
SanitizeValue
(
nsAString
&
aValue
)
{
NS_ASSERTION
(
mDoneCreating
"
The
element
creation
should
be
finished
!
"
)
;
switch
(
mType
)
{
case
NS_FORM_INPUT_TEXT
:
case
NS_FORM_INPUT_SEARCH
:
case
NS_FORM_INPUT_TEL
:
case
NS_FORM_INPUT_PASSWORD
:
{
char16_t
crlf
[
]
=
{
char16_t
(
'
\
r
'
)
char16_t
(
'
\
n
'
)
0
}
;
aValue
.
StripChars
(
crlf
)
;
}
break
;
case
NS_FORM_INPUT_EMAIL
:
case
NS_FORM_INPUT_URL
:
{
char16_t
crlf
[
]
=
{
char16_t
(
'
\
r
'
)
char16_t
(
'
\
n
'
)
0
}
;
aValue
.
StripChars
(
crlf
)
;
aValue
=
nsContentUtils
:
:
TrimWhitespace
<
nsContentUtils
:
:
IsHTMLWhitespace
>
(
aValue
)
;
}
break
;
case
NS_FORM_INPUT_NUMBER
:
{
Decimal
value
;
bool
ok
=
ConvertStringToNumber
(
aValue
value
)
;
if
(
!
ok
)
{
aValue
.
Truncate
(
)
;
}
}
break
;
case
NS_FORM_INPUT_RANGE
:
{
Decimal
minimum
=
GetMinimum
(
)
;
Decimal
maximum
=
GetMaximum
(
)
;
MOZ_ASSERT
(
minimum
.
isFinite
(
)
&
&
maximum
.
isFinite
(
)
"
type
=
range
should
have
a
default
maximum
/
minimum
"
)
;
bool
needSanitization
=
false
;
Decimal
value
;
bool
ok
=
ConvertStringToNumber
(
aValue
value
)
;
if
(
!
ok
)
{
needSanitization
=
true
;
value
=
maximum
<
=
minimum
?
minimum
:
minimum
+
(
maximum
-
minimum
)
/
Decimal
(
2
)
;
}
else
if
(
value
<
minimum
|
|
maximum
<
minimum
)
{
needSanitization
=
true
;
value
=
minimum
;
}
else
if
(
value
>
maximum
)
{
needSanitization
=
true
;
value
=
maximum
;
}
Decimal
step
=
GetStep
(
)
;
if
(
step
!
=
kStepAny
)
{
Decimal
stepBase
=
GetStepBase
(
)
;
Decimal
deltaToStep
=
NS_floorModulo
(
value
-
stepBase
step
)
;
if
(
deltaToStep
!
=
Decimal
(
0
)
)
{
MOZ_ASSERT
(
deltaToStep
>
Decimal
(
0
)
"
stepBelow
/
stepAbove
will
be
wrong
"
)
;
Decimal
stepBelow
=
value
-
deltaToStep
;
Decimal
stepAbove
=
value
-
deltaToStep
+
step
;
Decimal
halfStep
=
step
/
Decimal
(
2
)
;
bool
stepAboveIsClosest
=
(
stepAbove
-
value
)
<
=
halfStep
;
bool
stepAboveInRange
=
stepAbove
>
=
minimum
&
&
stepAbove
<
=
maximum
;
bool
stepBelowInRange
=
stepBelow
>
=
minimum
&
&
stepBelow
<
=
maximum
;
if
(
(
stepAboveIsClosest
|
|
!
stepBelowInRange
)
&
&
stepAboveInRange
)
{
needSanitization
=
true
;
value
=
stepAbove
;
}
else
if
(
(
!
stepAboveIsClosest
|
|
!
stepAboveInRange
)
&
&
stepBelowInRange
)
{
needSanitization
=
true
;
value
=
stepBelow
;
}
}
}
if
(
needSanitization
)
{
char
buf
[
32
]
;
DebugOnly
<
bool
>
ok
=
value
.
toString
(
buf
ArrayLength
(
buf
)
)
;
aValue
.
AssignASCII
(
buf
)
;
MOZ_ASSERT
(
ok
"
buf
not
big
enough
"
)
;
}
}
break
;
case
NS_FORM_INPUT_DATE
:
{
if
(
!
aValue
.
IsEmpty
(
)
&
&
!
IsValidDate
(
aValue
)
)
{
aValue
.
Truncate
(
)
;
}
}
break
;
case
NS_FORM_INPUT_TIME
:
{
if
(
!
aValue
.
IsEmpty
(
)
&
&
!
IsValidTime
(
aValue
)
)
{
aValue
.
Truncate
(
)
;
}
}
break
;
case
NS_FORM_INPUT_MONTH
:
{
if
(
!
aValue
.
IsEmpty
(
)
&
&
!
IsValidMonth
(
aValue
)
)
{
aValue
.
Truncate
(
)
;
}
}
break
;
case
NS_FORM_INPUT_WEEK
:
{
if
(
!
aValue
.
IsEmpty
(
)
&
&
!
IsValidWeek
(
aValue
)
)
{
aValue
.
Truncate
(
)
;
}
}
break
;
case
NS_FORM_INPUT_DATETIME_LOCAL
:
{
if
(
!
aValue
.
IsEmpty
(
)
&
&
!
IsValidDateTimeLocal
(
aValue
)
)
{
aValue
.
Truncate
(
)
;
}
else
{
NormalizeDateTimeLocal
(
aValue
)
;
}
}
break
;
case
NS_FORM_INPUT_COLOR
:
{
if
(
IsValidSimpleColor
(
aValue
)
)
{
ToLowerCase
(
aValue
)
;
}
else
{
aValue
.
AssignLiteral
(
"
#
000000
"
)
;
}
}
break
;
}
}
bool
HTMLInputElement
:
:
IsValidSimpleColor
(
const
nsAString
&
aValue
)
const
{
if
(
aValue
.
Length
(
)
!
=
7
|
|
aValue
.
First
(
)
!
=
'
#
'
)
{
return
false
;
}
for
(
int
i
=
1
;
i
<
7
;
+
+
i
)
{
if
(
!
nsCRT
:
:
IsAsciiDigit
(
aValue
[
i
]
)
&
&
!
(
aValue
[
i
]
>
=
'
a
'
&
&
aValue
[
i
]
<
=
'
f
'
)
&
&
!
(
aValue
[
i
]
>
=
'
A
'
&
&
aValue
[
i
]
<
=
'
F
'
)
)
{
return
false
;
}
}
return
true
;
}
bool
HTMLInputElement
:
:
IsLeapYear
(
uint32_t
aYear
)
const
{
if
(
(
aYear
%
4
=
=
0
&
&
aYear
%
100
!
=
0
)
|
|
(
aYear
%
400
=
=
0
)
)
{
return
true
;
}
return
false
;
}
uint32_t
HTMLInputElement
:
:
DayOfWeek
(
uint32_t
aYear
uint32_t
aMonth
uint32_t
aDay
bool
isoWeek
)
const
{
int
monthTable
[
]
=
{
0
3
2
5
0
3
5
1
4
6
2
4
}
;
aYear
-
=
aMonth
<
3
;
uint32_t
day
=
(
aYear
+
aYear
/
4
-
aYear
/
100
+
aYear
/
400
+
monthTable
[
aMonth
-
1
]
+
aDay
)
%
7
;
if
(
isoWeek
)
{
return
(
(
day
+
6
)
%
7
)
+
1
;
}
return
day
;
}
uint32_t
HTMLInputElement
:
:
MaximumWeekInYear
(
uint32_t
aYear
)
const
{
int
day
=
DayOfWeek
(
aYear
1
1
true
)
;
return
day
=
=
4
|
|
(
day
=
=
3
&
&
IsLeapYear
(
aYear
)
)
?
kMaximumWeekInYear
:
kMaximumWeekInYear
-
1
;
}
bool
HTMLInputElement
:
:
IsValidWeek
(
const
nsAString
&
aValue
)
const
{
uint32_t
year
week
;
return
ParseWeek
(
aValue
&
year
&
week
)
;
}
bool
HTMLInputElement
:
:
IsValidMonth
(
const
nsAString
&
aValue
)
const
{
uint32_t
year
month
;
return
ParseMonth
(
aValue
&
year
&
month
)
;
}
bool
HTMLInputElement
:
:
IsValidDate
(
const
nsAString
&
aValue
)
const
{
uint32_t
year
month
day
;
return
ParseDate
(
aValue
&
year
&
month
&
day
)
;
}
bool
HTMLInputElement
:
:
IsValidDateTimeLocal
(
const
nsAString
&
aValue
)
const
{
uint32_t
year
month
day
time
;
return
ParseDateTimeLocal
(
aValue
&
year
&
month
&
day
&
time
)
;
}
bool
HTMLInputElement
:
:
ParseYear
(
const
nsAString
&
aValue
uint32_t
*
aYear
)
const
{
if
(
aValue
.
Length
(
)
<
4
)
{
return
false
;
}
return
DigitSubStringToNumber
(
aValue
0
aValue
.
Length
(
)
aYear
)
&
&
*
aYear
>
0
;
}
bool
HTMLInputElement
:
:
ParseMonth
(
const
nsAString
&
aValue
uint32_t
*
aYear
uint32_t
*
aMonth
)
const
{
if
(
aValue
.
Length
(
)
<
7
)
{
return
false
;
}
uint32_t
endOfYearOffset
=
aValue
.
Length
(
)
-
3
;
if
(
aValue
[
endOfYearOffset
]
!
=
'
-
'
)
{
return
false
;
}
const
nsAString
&
yearStr
=
Substring
(
aValue
0
endOfYearOffset
)
;
if
(
!
ParseYear
(
yearStr
aYear
)
)
{
return
false
;
}
return
DigitSubStringToNumber
(
aValue
endOfYearOffset
+
1
2
aMonth
)
&
&
*
aMonth
>
0
&
&
*
aMonth
<
=
12
;
}
bool
HTMLInputElement
:
:
ParseWeek
(
const
nsAString
&
aValue
uint32_t
*
aYear
uint32_t
*
aWeek
)
const
{
if
(
aValue
.
Length
(
)
<
8
)
{
return
false
;
}
uint32_t
endOfYearOffset
=
aValue
.
Length
(
)
-
4
;
if
(
aValue
[
endOfYearOffset
]
!
=
'
-
'
)
{
return
false
;
}
if
(
aValue
[
endOfYearOffset
+
1
]
!
=
'
W
'
)
{
return
false
;
}
const
nsAString
&
yearStr
=
Substring
(
aValue
0
endOfYearOffset
)
;
if
(
!
ParseYear
(
yearStr
aYear
)
)
{
return
false
;
}
return
DigitSubStringToNumber
(
aValue
endOfYearOffset
+
2
2
aWeek
)
&
&
*
aWeek
>
0
&
&
*
aWeek
<
=
MaximumWeekInYear
(
*
aYear
)
;
}
bool
HTMLInputElement
:
:
ParseDate
(
const
nsAString
&
aValue
uint32_t
*
aYear
uint32_t
*
aMonth
uint32_t
*
aDay
)
const
{
if
(
aValue
.
Length
(
)
<
10
)
{
return
false
;
}
uint32_t
endOfMonthOffset
=
aValue
.
Length
(
)
-
3
;
if
(
aValue
[
endOfMonthOffset
]
!
=
'
-
'
)
{
return
false
;
}
const
nsAString
&
yearMonthStr
=
Substring
(
aValue
0
endOfMonthOffset
)
;
if
(
!
ParseMonth
(
yearMonthStr
aYear
aMonth
)
)
{
return
false
;
}
return
DigitSubStringToNumber
(
aValue
endOfMonthOffset
+
1
2
aDay
)
&
&
*
aDay
>
0
&
&
*
aDay
<
=
NumberOfDaysInMonth
(
*
aMonth
*
aYear
)
;
}
bool
HTMLInputElement
:
:
ParseDateTimeLocal
(
const
nsAString
&
aValue
uint32_t
*
aYear
uint32_t
*
aMonth
uint32_t
*
aDay
uint32_t
*
aTime
)
const
{
if
(
aValue
.
Length
(
)
<
16
)
{
return
false
;
}
const
uint32_t
sepIndex
=
10
;
if
(
aValue
[
sepIndex
]
!
=
'
T
'
&
&
aValue
[
sepIndex
]
!
=
'
'
)
{
return
false
;
}
const
nsAString
&
dateStr
=
Substring
(
aValue
0
sepIndex
)
;
if
(
!
ParseDate
(
dateStr
aYear
aMonth
aDay
)
)
{
return
false
;
}
const
nsAString
&
timeStr
=
Substring
(
aValue
sepIndex
+
1
aValue
.
Length
(
)
-
sepIndex
+
1
)
;
if
(
!
ParseTime
(
timeStr
aTime
)
)
{
return
false
;
}
return
true
;
}
void
HTMLInputElement
:
:
NormalizeDateTimeLocal
(
nsAString
&
aValue
)
const
{
if
(
aValue
.
IsEmpty
(
)
)
{
return
;
}
const
uint32_t
sepIndex
=
10
;
if
(
aValue
[
sepIndex
]
=
=
'
'
)
{
aValue
.
Replace
(
sepIndex
1
NS_LITERAL_STRING
(
"
T
"
)
)
;
}
if
(
aValue
.
Length
(
)
=
=
16
)
{
return
;
}
if
(
aValue
.
Length
(
)
>
19
)
{
uint32_t
milliseconds
;
if
(
!
DigitSubStringToNumber
(
aValue
20
aValue
.
Length
(
)
-
20
&
milliseconds
)
)
{
return
;
}
if
(
milliseconds
!
=
0
)
{
return
;
}
aValue
.
Cut
(
19
aValue
.
Length
(
)
-
19
)
;
}
uint32_t
seconds
;
if
(
!
DigitSubStringToNumber
(
aValue
17
aValue
.
Length
(
)
-
17
&
seconds
)
)
{
return
;
}
if
(
seconds
!
=
0
)
{
return
;
}
aValue
.
Cut
(
16
aValue
.
Length
(
)
-
16
)
;
}
double
HTMLInputElement
:
:
DaysSinceEpochFromWeek
(
uint32_t
aYear
uint32_t
aWeek
)
const
{
double
days
=
JS
:
:
DayFromYear
(
aYear
)
+
(
aWeek
-
1
)
*
7
;
uint32_t
dayOneIsoWeekday
=
DayOfWeek
(
aYear
1
1
true
)
;
if
(
dayOneIsoWeekday
<
=
4
)
{
days
-
=
(
dayOneIsoWeekday
-
1
)
;
}
else
{
days
+
=
(
7
-
dayOneIsoWeekday
+
1
)
;
}
return
days
;
}
uint32_t
HTMLInputElement
:
:
NumberOfDaysInMonth
(
uint32_t
aMonth
uint32_t
aYear
)
const
{
static
const
bool
longMonths
[
]
=
{
true
false
true
false
true
false
true
true
false
true
false
true
}
;
MOZ_ASSERT
(
aMonth
<
=
12
&
&
aMonth
>
0
)
;
if
(
longMonths
[
aMonth
-
1
]
)
{
return
31
;
}
if
(
aMonth
!
=
2
)
{
return
30
;
}
return
IsLeapYear
(
aYear
)
?
29
:
28
;
}
bool
HTMLInputElement
:
:
DigitSubStringToNumber
(
const
nsAString
&
aStr
uint32_t
aStart
uint32_t
aLen
uint32_t
*
aRetVal
)
{
MOZ_ASSERT
(
aStr
.
Length
(
)
>
(
aStart
+
aLen
-
1
)
)
;
for
(
uint32_t
offset
=
0
;
offset
<
aLen
;
+
+
offset
)
{
if
(
!
NS_IsAsciiDigit
(
aStr
[
aStart
+
offset
]
)
)
{
return
false
;
}
}
nsresult
ec
;
*
aRetVal
=
static_cast
<
uint32_t
>
(
PromiseFlatString
(
Substring
(
aStr
aStart
aLen
)
)
.
ToInteger
(
&
ec
)
)
;
return
NS_SUCCEEDED
(
ec
)
;
}
bool
HTMLInputElement
:
:
IsValidTime
(
const
nsAString
&
aValue
)
const
{
return
ParseTime
(
aValue
nullptr
)
;
}
bool
HTMLInputElement
:
:
ParseTime
(
const
nsAString
&
aValue
uint32_t
*
aResult
)
{
if
(
aValue
.
Length
(
)
<
5
)
{
return
false
;
}
uint32_t
hours
;
if
(
!
DigitSubStringToNumber
(
aValue
0
2
&
hours
)
|
|
hours
>
23
)
{
return
false
;
}
if
(
aValue
[
2
]
!
=
'
:
'
)
{
return
false
;
}
uint32_t
minutes
;
if
(
!
DigitSubStringToNumber
(
aValue
3
2
&
minutes
)
|
|
minutes
>
59
)
{
return
false
;
}
if
(
aValue
.
Length
(
)
=
=
5
)
{
if
(
aResult
)
{
*
aResult
=
(
(
hours
*
60
)
+
minutes
)
*
60000
;
}
return
true
;
}
if
(
aValue
.
Length
(
)
<
8
|
|
aValue
[
5
]
!
=
'
:
'
)
{
return
false
;
}
uint32_t
seconds
;
if
(
!
DigitSubStringToNumber
(
aValue
6
2
&
seconds
)
|
|
seconds
>
59
)
{
return
false
;
}
if
(
aValue
.
Length
(
)
=
=
8
)
{
if
(
aResult
)
{
*
aResult
=
(
(
(
hours
*
60
)
+
minutes
)
*
60
+
seconds
)
*
1000
;
}
return
true
;
}
if
(
aValue
.
Length
(
)
=
=
9
|
|
aValue
.
Length
(
)
>
12
|
|
aValue
[
8
]
!
=
'
.
'
)
{
return
false
;
}
uint32_t
fractionsSeconds
;
if
(
!
DigitSubStringToNumber
(
aValue
9
aValue
.
Length
(
)
-
9
&
fractionsSeconds
)
)
{
return
false
;
}
if
(
aResult
)
{
*
aResult
=
(
(
(
hours
*
60
)
+
minutes
)
*
60
+
seconds
)
*
1000
+
fractionsSeconds
*
pow
(
10
.
0
static_cast
<
int
>
(
3
-
(
aValue
.
Length
(
)
-
9
)
)
)
;
}
return
true
;
}
static
bool
IsDateTimeEnabled
(
int32_t
aNewType
)
{
return
(
aNewType
=
=
NS_FORM_INPUT_DATE
&
&
(
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datetime
"
false
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
experimental_forms
"
false
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datepicker
"
false
)
)
)
|
|
(
aNewType
=
=
NS_FORM_INPUT_TIME
&
&
(
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datetime
"
false
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
experimental_forms
"
false
)
)
)
|
|
(
(
aNewType
=
=
NS_FORM_INPUT_MONTH
|
|
aNewType
=
=
NS_FORM_INPUT_WEEK
|
|
aNewType
=
=
NS_FORM_INPUT_DATETIME_LOCAL
)
&
&
Preferences
:
:
GetBool
(
"
dom
.
forms
.
datetime
"
false
)
)
;
}
bool
HTMLInputElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsIAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
type
)
{
int32_t
newType
;
bool
success
=
aResult
.
ParseEnumValue
(
aValue
kInputTypeTable
false
)
;
if
(
success
)
{
newType
=
aResult
.
GetEnumValue
(
)
;
if
(
(
IsExperimentalMobileType
(
newType
)
&
&
!
Preferences
:
:
GetBool
(
"
dom
.
experimental_forms
"
false
)
)
|
|
(
newType
=
=
NS_FORM_INPUT_NUMBER
&
&
!
Preferences
:
:
GetBool
(
"
dom
.
forms
.
number
"
false
)
)
|
|
(
newType
=
=
NS_FORM_INPUT_COLOR
&
&
!
Preferences
:
:
GetBool
(
"
dom
.
forms
.
color
"
false
)
)
|
|
(
IsDateTimeInputType
(
newType
)
&
&
!
IsDateTimeEnabled
(
newType
)
)
)
{
newType
=
kInputDefaultType
-
>
value
;
aResult
.
SetTo
(
newType
&
aValue
)
;
}
}
else
{
newType
=
kInputDefaultType
-
>
value
;
}
if
(
newType
!
=
mType
)
{
if
(
newType
=
=
NS_FORM_INPUT_FILE
|
|
mType
=
=
NS_FORM_INPUT_FILE
)
{
ClearFiles
(
false
)
;
}
HandleTypeChange
(
newType
)
;
}
return
success
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
maxlength
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
minlength
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
size
)
{
return
aResult
.
ParsePositiveIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
border
)
{
return
aResult
.
ParseIntWithBounds
(
aValue
0
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
formmethod
)
{
return
aResult
.
ParseEnumValue
(
aValue
kFormMethodTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
formenctype
)
{
return
aResult
.
ParseEnumValue
(
aValue
kFormEnctypeTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
autocomplete
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
inputmode
)
{
return
aResult
.
ParseEnumValue
(
aValue
kInputInputmodeTable
false
)
;
}
if
(
ParseImageAttribute
(
aAttribute
aValue
aResult
)
)
{
return
true
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aResult
)
;
}
void
HTMLInputElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
nsRuleData
*
aData
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
type
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
&
&
value
-
>
GetEnumValue
(
)
=
=
NS_FORM_INPUT_IMAGE
)
{
nsGenericHTMLFormElementWithState
:
:
MapImageBorderAttributeInto
(
aAttributes
aData
)
;
nsGenericHTMLFormElementWithState
:
:
MapImageMarginAttributeInto
(
aAttributes
aData
)
;
nsGenericHTMLFormElementWithState
:
:
MapImageSizeAttributesInto
(
aAttributes
aData
)
;
nsGenericHTMLFormElementWithState
:
:
MapImageAlignAttributeInto
(
aAttributes
aData
)
;
}
nsGenericHTMLFormElementWithState
:
:
MapCommonAttributesInto
(
aAttributes
aData
)
;
}
nsChangeHint
HTMLInputElement
:
:
GetAttributeChangeHint
(
const
nsIAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
nsGenericHTMLFormElementWithState
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
type
|
|
aAttribute
=
=
nsGkAtoms
:
:
allowdirs
|
|
aAttribute
=
=
nsGkAtoms
:
:
webkitdirectory
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
if
(
mType
=
=
NS_FORM_INPUT_IMAGE
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
alt
|
|
aAttribute
=
=
nsGkAtoms
:
:
value
)
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
)
{
retval
|
=
NS_STYLE_HINT_REFLOW
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
size
&
&
IsSingleLineTextControl
(
false
)
)
{
retval
|
=
NS_STYLE_HINT_REFLOW
;
}
else
if
(
PlaceholderApplies
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
placeholder
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
return
retval
;
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
IsAttributeMapped
(
const
nsIAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
attributes
[
]
=
{
{
&
nsGkAtoms
:
:
align
}
{
&
nsGkAtoms
:
:
type
}
{
nullptr
}
}
;
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
attributes
sCommonAttributeMap
sImageMarginSizeAttributeMap
sImageBorderAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLInputElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
bool
HTMLInputElement
:
:
IsFilesAndDirectoriesSupported
(
)
const
{
return
false
;
}
void
HTMLInputElement
:
:
ChooseDirectory
(
ErrorResult
&
aRv
)
{
if
(
mType
!
=
NS_FORM_INPUT_FILE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
InitFilePicker
(
#
if
defined
(
ANDROID
)
|
|
defined
(
MOZ_B2G
)
FILE_PICKER_FILE
#
else
FILE_PICKER_DIRECTORY
#
endif
)
;
}
already_AddRefed
<
Promise
>
HTMLInputElement
:
:
GetFilesAndDirectories
(
ErrorResult
&
aRv
)
{
if
(
mType
!
=
NS_FORM_INPUT_FILE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
MOZ_ASSERT
(
global
)
;
if
(
!
global
)
{
return
nullptr
;
}
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
const
nsTArray
<
OwningFileOrDirectory
>
&
filesAndDirs
=
GetFilesOrDirectoriesInternal
(
)
;
Sequence
<
OwningFileOrDirectory
>
filesAndDirsSeq
;
if
(
!
filesAndDirsSeq
.
SetLength
(
filesAndDirs
.
Length
(
)
mozilla
:
:
fallible_t
(
)
)
)
{
p
-
>
MaybeReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
p
.
forget
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
filesAndDirs
.
Length
(
)
;
+
+
i
)
{
if
(
filesAndDirs
[
i
]
.
IsDirectory
(
)
)
{
RefPtr
<
Directory
>
directory
=
filesAndDirs
[
i
]
.
GetAsDirectory
(
)
;
directory
-
>
SetContentFilters
(
NS_LITERAL_STRING
(
"
filter
-
out
-
sensitive
"
)
)
;
filesAndDirsSeq
[
i
]
.
SetAsDirectory
(
)
=
directory
;
}
else
{
MOZ_ASSERT
(
filesAndDirs
[
i
]
.
IsFile
(
)
)
;
filesAndDirsSeq
[
i
]
.
SetAsFile
(
)
=
filesAndDirs
[
i
]
.
GetAsFile
(
)
;
}
}
p
-
>
MaybeResolve
(
filesAndDirsSeq
)
;
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
HTMLInputElement
:
:
GetFiles
(
bool
aRecursiveFlag
ErrorResult
&
aRv
)
{
if
(
mType
!
=
NS_FORM_INPUT_FILE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
GetFilesHelper
*
helper
=
GetOrCreateGetFilesHelper
(
aRecursiveFlag
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
helper
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
MOZ_ASSERT
(
global
)
;
if
(
!
global
)
{
return
nullptr
;
}
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
helper
-
>
AddPromise
(
p
)
;
return
p
.
forget
(
)
;
}
nsIControllers
*
HTMLInputElement
:
:
GetControllers
(
ErrorResult
&
aRv
)
{
if
(
IsSingleLineTextControl
(
false
)
)
{
if
(
!
mControllers
)
{
nsresult
rv
;
mControllers
=
do_CreateInstance
(
kXULControllersCID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIController
>
controller
(
do_CreateInstance
(
"
mozilla
.
org
/
editor
/
editorcontroller
;
1
"
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
mControllers
-
>
AppendController
(
controller
)
;
controller
=
do_CreateInstance
(
"
mozilla
.
org
/
editor
/
editingcontroller
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
mControllers
-
>
AppendController
(
controller
)
;
}
}
return
mControllers
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetControllers
(
nsIControllers
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
ErrorResult
rv
;
RefPtr
<
nsIControllers
>
controller
=
GetControllers
(
rv
)
;
controller
.
forget
(
aResult
)
;
return
rv
.
StealNSResult
(
)
;
}
int32_t
HTMLInputElement
:
:
InputTextLength
(
CallerType
aCallerType
)
{
nsAutoString
val
;
GetValue
(
val
aCallerType
)
;
return
val
.
Length
(
)
;
}
void
HTMLInputElement
:
:
SetSelectionRange
(
int32_t
aSelectionStart
int32_t
aSelectionEnd
const
Optional
<
nsAString
>
&
aDirection
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsresult
rv
=
SetSelectionRange
(
aSelectionStart
aSelectionEnd
aDirection
.
WasPassed
(
)
?
aDirection
.
Value
(
)
:
NullString
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetSelectionRange
(
int32_t
aSelectionStart
int32_t
aSelectionEnd
const
nsAString
&
aDirection
)
{
nsresult
rv
=
NS_OK
;
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
nsITextControlFrame
*
textControlFrame
=
do_QueryFrame
(
formControlFrame
)
;
if
(
textControlFrame
)
{
nsITextControlFrame
:
:
SelectionDirection
dir
=
nsITextControlFrame
:
:
eForward
;
if
(
!
aDirection
.
IsEmpty
(
)
&
&
aDirection
.
EqualsLiteral
(
"
backward
"
)
)
{
dir
=
nsITextControlFrame
:
:
eBackward
;
}
rv
=
textControlFrame
-
>
SetSelectionRange
(
aSelectionStart
aSelectionEnd
dir
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
textControlFrame
-
>
ScrollSelectionIntoView
(
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
select
"
)
true
false
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
return
rv
;
}
void
HTMLInputElement
:
:
SetRangeText
(
const
nsAString
&
aReplacement
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
int32_t
start
end
;
aRv
=
GetSelectionRange
(
&
start
&
end
)
;
if
(
aRv
.
Failed
(
)
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
start
=
state
-
>
GetSelectionProperties
(
)
.
GetStart
(
)
;
end
=
state
-
>
GetSelectionProperties
(
)
.
GetEnd
(
)
;
aRv
=
NS_OK
;
}
}
SetRangeText
(
aReplacement
start
end
mozilla
:
:
dom
:
:
SelectionMode
:
:
Preserve
aRv
start
end
)
;
}
void
HTMLInputElement
:
:
SetRangeText
(
const
nsAString
&
aReplacement
uint32_t
aStart
uint32_t
aEnd
const
SelectionMode
&
aSelectMode
ErrorResult
&
aRv
int32_t
aSelectionStart
int32_t
aSelectionEnd
)
{
if
(
!
SupportsTextSelection
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
aStart
>
aEnd
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
uint32_t
inputValueLength
=
value
.
Length
(
)
;
if
(
aStart
>
inputValueLength
)
{
aStart
=
inputValueLength
;
}
if
(
aEnd
>
inputValueLength
)
{
aEnd
=
inputValueLength
;
}
if
(
aSelectionStart
=
=
-
1
&
&
aSelectionEnd
=
=
-
1
)
{
aRv
=
GetSelectionRange
(
&
aSelectionStart
&
aSelectionEnd
)
;
if
(
aRv
.
Failed
(
)
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
aSelectionStart
=
state
-
>
GetSelectionProperties
(
)
.
GetStart
(
)
;
aSelectionEnd
=
state
-
>
GetSelectionProperties
(
)
.
GetEnd
(
)
;
aRv
=
NS_OK
;
}
}
}
if
(
aStart
<
=
aEnd
)
{
value
.
Replace
(
aStart
aEnd
-
aStart
aReplacement
)
;
nsresult
rv
=
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_ByContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
}
uint32_t
newEnd
=
aStart
+
aReplacement
.
Length
(
)
;
int32_t
delta
=
aReplacement
.
Length
(
)
-
(
aEnd
-
aStart
)
;
switch
(
aSelectMode
)
{
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
Select
:
{
aSelectionStart
=
aStart
;
aSelectionEnd
=
newEnd
;
}
break
;
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
Start
:
{
aSelectionStart
=
aSelectionEnd
=
aStart
;
}
break
;
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
End
:
{
aSelectionStart
=
aSelectionEnd
=
newEnd
;
}
break
;
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
Preserve
:
{
if
(
(
uint32_t
)
aSelectionStart
>
aEnd
)
{
aSelectionStart
+
=
delta
;
}
else
if
(
(
uint32_t
)
aSelectionStart
>
aStart
)
{
aSelectionStart
=
aStart
;
}
if
(
(
uint32_t
)
aSelectionEnd
>
aEnd
)
{
aSelectionEnd
+
=
delta
;
}
else
if
(
(
uint32_t
)
aSelectionEnd
>
aStart
)
{
aSelectionEnd
=
newEnd
;
}
}
break
;
default
:
MOZ_CRASH
(
"
Unknown
mode
!
"
)
;
}
Optional
<
nsAString
>
direction
;
SetSelectionRange
(
aSelectionStart
aSelectionEnd
direction
aRv
)
;
}
Nullable
<
int32_t
>
HTMLInputElement
:
:
GetSelectionStart
(
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
return
Nullable
<
int32_t
>
(
)
;
}
int32_t
selStart
;
nsresult
rv
=
GetSelectionStart
(
&
selStart
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
return
Nullable
<
int32_t
>
(
selStart
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetSelectionStart
(
int32_t
*
aSelectionStart
)
{
NS_ENSURE_ARG_POINTER
(
aSelectionStart
)
;
int32_t
selEnd
selStart
;
nsresult
rv
=
GetSelectionRange
(
&
selStart
&
selEnd
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
*
aSelectionStart
=
state
-
>
GetSelectionProperties
(
)
.
GetStart
(
)
;
return
NS_OK
;
}
return
rv
;
}
*
aSelectionStart
=
selStart
;
return
NS_OK
;
}
void
HTMLInputElement
:
:
SetSelectionStart
(
const
Nullable
<
int32_t
>
&
aSelectionStart
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
int32_t
selStart
=
0
;
if
(
!
aSelectionStart
.
IsNull
(
)
)
{
selStart
=
aSelectionStart
.
Value
(
)
;
}
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
state
-
>
GetSelectionProperties
(
)
.
SetStart
(
selStart
)
;
return
;
}
nsAutoString
direction
;
aRv
=
GetSelectionDirection
(
direction
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
int32_t
start
end
;
aRv
=
GetSelectionRange
(
&
start
&
end
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
start
=
selStart
;
if
(
end
<
start
)
{
end
=
start
;
}
aRv
=
SetSelectionRange
(
start
end
direction
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetSelectionStart
(
int32_t
aSelectionStart
)
{
ErrorResult
rv
;
Nullable
<
int32_t
>
selStart
(
aSelectionStart
)
;
SetSelectionStart
(
selStart
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
Nullable
<
int32_t
>
HTMLInputElement
:
:
GetSelectionEnd
(
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
return
Nullable
<
int32_t
>
(
)
;
}
int32_t
selEnd
;
nsresult
rv
=
GetSelectionEnd
(
&
selEnd
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
return
Nullable
<
int32_t
>
(
selEnd
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetSelectionEnd
(
int32_t
*
aSelectionEnd
)
{
NS_ENSURE_ARG_POINTER
(
aSelectionEnd
)
;
int32_t
selEnd
selStart
;
nsresult
rv
=
GetSelectionRange
(
&
selStart
&
selEnd
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
*
aSelectionEnd
=
state
-
>
GetSelectionProperties
(
)
.
GetEnd
(
)
;
return
NS_OK
;
}
return
rv
;
}
*
aSelectionEnd
=
selEnd
;
return
NS_OK
;
}
void
HTMLInputElement
:
:
SetSelectionEnd
(
const
Nullable
<
int32_t
>
&
aSelectionEnd
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
int32_t
selEnd
=
0
;
if
(
!
aSelectionEnd
.
IsNull
(
)
)
{
selEnd
=
aSelectionEnd
.
Value
(
)
;
}
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
state
-
>
GetSelectionProperties
(
)
.
SetEnd
(
selEnd
)
;
return
;
}
nsAutoString
direction
;
aRv
=
GetSelectionDirection
(
direction
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
int32_t
start
end
;
aRv
=
GetSelectionRange
(
&
start
&
end
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
end
=
selEnd
;
if
(
start
>
end
)
{
start
=
end
;
}
aRv
=
SetSelectionRange
(
start
end
direction
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetSelectionEnd
(
int32_t
aSelectionEnd
)
{
ErrorResult
rv
;
Nullable
<
int32_t
>
selEnd
(
aSelectionEnd
)
;
SetSelectionEnd
(
selEnd
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetFiles
(
nsIDOMFileList
*
*
aFileList
)
{
RefPtr
<
FileList
>
list
=
GetFiles
(
)
;
list
.
forget
(
aFileList
)
;
return
NS_OK
;
}
nsresult
HTMLInputElement
:
:
GetSelectionRange
(
int32_t
*
aSelectionStart
int32_t
*
aSelectionEnd
)
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
nsITextControlFrame
*
textControlFrame
=
do_QueryFrame
(
formControlFrame
)
;
if
(
textControlFrame
)
{
return
textControlFrame
-
>
GetSelectionRange
(
aSelectionStart
aSelectionEnd
)
;
}
return
NS_ERROR_FAILURE
;
}
static
void
DirectionToName
(
nsITextControlFrame
:
:
SelectionDirection
dir
nsAString
&
aDirection
)
{
if
(
dir
=
=
nsITextControlFrame
:
:
eNone
)
{
aDirection
.
AssignLiteral
(
"
none
"
)
;
}
else
if
(
dir
=
=
nsITextControlFrame
:
:
eForward
)
{
aDirection
.
AssignLiteral
(
"
forward
"
)
;
}
else
if
(
dir
=
=
nsITextControlFrame
:
:
eBackward
)
{
aDirection
.
AssignLiteral
(
"
backward
"
)
;
}
else
{
NS_NOTREACHED
(
"
Invalid
SelectionDirection
value
"
)
;
}
}
void
HTMLInputElement
:
:
GetSelectionDirection
(
nsAString
&
aDirection
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
aDirection
.
SetIsVoid
(
true
)
;
return
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
nsITextControlFrame
*
textControlFrame
=
do_QueryFrame
(
formControlFrame
)
;
if
(
textControlFrame
)
{
nsITextControlFrame
:
:
SelectionDirection
dir
;
rv
=
textControlFrame
-
>
GetSelectionRange
(
nullptr
nullptr
&
dir
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
DirectionToName
(
dir
aDirection
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
DirectionToName
(
state
-
>
GetSelectionProperties
(
)
.
GetDirection
(
)
aDirection
)
;
return
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetSelectionDirection
(
nsAString
&
aDirection
)
{
ErrorResult
rv
;
GetSelectionDirection
(
aDirection
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
HTMLInputElement
:
:
SetSelectionDirection
(
const
nsAString
&
aDirection
ErrorResult
&
aRv
)
{
if
(
!
SupportsTextSelection
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
&
&
state
-
>
IsSelectionCached
(
)
)
{
nsITextControlFrame
:
:
SelectionDirection
dir
=
nsITextControlFrame
:
:
eNone
;
if
(
aDirection
.
EqualsLiteral
(
"
forward
"
)
)
{
dir
=
nsITextControlFrame
:
:
eForward
;
}
else
if
(
aDirection
.
EqualsLiteral
(
"
backward
"
)
)
{
dir
=
nsITextControlFrame
:
:
eBackward
;
}
state
-
>
GetSelectionProperties
(
)
.
SetDirection
(
dir
)
;
return
;
}
int32_t
start
end
;
aRv
=
GetSelectionRange
(
&
start
&
end
)
;
if
(
!
aRv
.
Failed
(
)
)
{
aRv
=
SetSelectionRange
(
start
end
aDirection
)
;
}
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetSelectionDirection
(
const
nsAString
&
aDirection
)
{
ErrorResult
rv
;
SetSelectionDirection
(
aDirection
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
GetPhonetic
(
nsAString
&
aPhonetic
)
{
aPhonetic
.
Truncate
(
)
;
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
nsITextControlFrame
*
textControlFrame
=
do_QueryFrame
(
formControlFrame
)
;
if
(
textControlFrame
)
{
textControlFrame
-
>
GetPhonetic
(
aPhonetic
)
;
}
return
NS_OK
;
}
#
ifdef
ACCESSIBILITY
nsresult
FireEventForAccessibility
(
nsIDOMHTMLInputElement
*
aTarget
nsPresContext
*
aPresContext
const
nsAString
&
aEventType
)
{
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
element
=
do_QueryInterface
(
aTarget
)
;
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
element
aPresContext
nullptr
)
;
event
-
>
InitEvent
(
aEventType
true
true
)
;
event
-
>
SetTrusted
(
true
)
;
EventDispatcher
:
:
DispatchDOMEvent
(
aTarget
nullptr
event
aPresContext
nullptr
)
;
return
NS_OK
;
}
#
endif
void
HTMLInputElement
:
:
UpdateApzAwareFlag
(
)
{
#
if
!
defined
(
ANDROID
)
&
&
!
defined
(
XP_MACOSX
)
if
(
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
|
|
(
mType
=
=
NS_FORM_INPUT_RANGE
)
)
{
SetMayBeApzAware
(
)
;
}
#
endif
}
nsresult
HTMLInputElement
:
:
SetDefaultValueAsValue
(
)
{
NS_ASSERTION
(
GetValueMode
(
)
=
=
VALUE_MODE_VALUE
"
GetValueMode
(
)
should
return
VALUE_MODE_VALUE
!
"
)
;
nsAutoString
resetVal
;
GetDefaultValue
(
resetVal
)
;
return
SetValueInternal
(
resetVal
nsTextEditorState
:
:
eSetValue_Internal
)
;
}
void
HTMLInputElement
:
:
SetDirectionIfAuto
(
bool
aAuto
bool
aNotify
)
{
if
(
aAuto
)
{
SetHasDirAuto
(
)
;
if
(
IsSingleLineTextControl
(
true
)
)
{
nsAutoString
value
;
GetValue
(
value
CallerType
:
:
System
)
;
SetDirectionalityFromValue
(
this
value
aNotify
)
;
}
}
else
{
ClearHasDirAuto
(
)
;
}
}
NS_IMETHODIMP
HTMLInputElement
:
:
Reset
(
)
{
SetCheckedChanged
(
false
)
;
SetValueChanged
(
false
)
;
mLastValueChangeWasInteractive
=
false
;
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_VALUE
:
return
SetDefaultValueAsValue
(
)
;
case
VALUE_MODE_DEFAULT_ON
:
DoSetChecked
(
DefaultChecked
(
)
true
false
)
;
return
NS_OK
;
case
VALUE_MODE_FILENAME
:
ClearFiles
(
false
)
;
return
NS_OK
;
case
VALUE_MODE_DEFAULT
:
default
:
return
NS_OK
;
}
}
NS_IMETHODIMP
HTMLInputElement
:
:
SubmitNamesValues
(
HTMLFormSubmission
*
aFormSubmission
)
{
if
(
IsDisabled
(
)
|
|
mType
=
=
NS_FORM_INPUT_RESET
|
|
mType
=
=
NS_FORM_INPUT_BUTTON
|
|
(
(
mType
=
=
NS_FORM_INPUT_SUBMIT
|
|
mType
=
=
NS_FORM_INPUT_IMAGE
)
&
&
aFormSubmission
-
>
GetOriginatingElement
(
)
!
=
this
)
|
|
(
(
mType
=
=
NS_FORM_INPUT_RADIO
|
|
mType
=
=
NS_FORM_INPUT_CHECKBOX
)
&
&
!
mChecked
)
)
{
return
NS_OK
;
}
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
if
(
mType
=
=
NS_FORM_INPUT_IMAGE
)
{
nsIntPoint
*
lastClickedPoint
=
static_cast
<
nsIntPoint
*
>
(
GetProperty
(
nsGkAtoms
:
:
imageClickedPoint
)
)
;
int32_t
x
y
;
if
(
lastClickedPoint
)
{
x
=
lastClickedPoint
-
>
x
;
y
=
lastClickedPoint
-
>
y
;
}
else
{
x
=
y
=
0
;
}
nsAutoString
xVal
yVal
;
xVal
.
AppendInt
(
x
)
;
yVal
.
AppendInt
(
y
)
;
if
(
!
name
.
IsEmpty
(
)
)
{
aFormSubmission
-
>
AddNameValuePair
(
name
+
NS_LITERAL_STRING
(
"
.
x
"
)
xVal
)
;
aFormSubmission
-
>
AddNameValuePair
(
name
+
NS_LITERAL_STRING
(
"
.
y
"
)
yVal
)
;
}
else
{
aFormSubmission
-
>
AddNameValuePair
(
NS_LITERAL_STRING
(
"
x
"
)
xVal
)
;
aFormSubmission
-
>
AddNameValuePair
(
NS_LITERAL_STRING
(
"
y
"
)
yVal
)
;
}
return
NS_OK
;
}
if
(
name
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
mType
=
=
NS_FORM_INPUT_FILE
)
{
const
nsTArray
<
OwningFileOrDirectory
>
&
files
=
GetFilesOrDirectoriesInternal
(
)
;
if
(
files
.
IsEmpty
(
)
)
{
aFormSubmission
-
>
AddNameBlobOrNullPair
(
name
nullptr
)
;
return
NS_OK
;
}
for
(
uint32_t
i
=
0
;
i
<
files
.
Length
(
)
;
+
+
i
)
{
if
(
files
[
i
]
.
IsFile
(
)
)
{
aFormSubmission
-
>
AddNameBlobOrNullPair
(
name
files
[
i
]
.
GetAsFile
(
)
)
;
}
else
{
MOZ_ASSERT
(
files
[
i
]
.
IsDirectory
(
)
)
;
aFormSubmission
-
>
AddNameDirectoryPair
(
name
files
[
i
]
.
GetAsDirectory
(
)
)
;
}
}
return
NS_OK
;
}
if
(
mType
=
=
NS_FORM_INPUT_HIDDEN
&
&
name
.
EqualsLiteral
(
"
_charset_
"
)
)
{
nsCString
charset
;
aFormSubmission
-
>
GetCharset
(
charset
)
;
return
aFormSubmission
-
>
AddNameValuePair
(
name
NS_ConvertASCIItoUTF16
(
charset
)
)
;
}
nsAutoString
value
;
GetValue
(
value
CallerType
:
:
System
)
;
if
(
mType
=
=
NS_FORM_INPUT_SUBMIT
&
&
value
.
IsEmpty
(
)
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
)
)
{
nsXPIDLString
defaultValue
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
Submit
"
defaultValue
)
;
value
=
defaultValue
;
}
if
(
IsSingleLineTextControl
(
true
)
&
&
name
.
EqualsLiteral
(
"
isindex
"
)
&
&
aFormSubmission
-
>
SupportsIsindexSubmission
(
)
)
{
return
aFormSubmission
-
>
AddIsindex
(
value
)
;
}
return
aFormSubmission
-
>
AddNameValuePair
(
name
value
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SaveState
(
)
{
RefPtr
<
HTMLInputElementState
>
inputState
;
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_DEFAULT_ON
:
if
(
mCheckedChanged
)
{
inputState
=
new
HTMLInputElementState
(
)
;
inputState
-
>
SetChecked
(
mChecked
)
;
}
break
;
case
VALUE_MODE_FILENAME
:
if
(
!
mFilesOrDirectories
.
IsEmpty
(
)
)
{
inputState
=
new
HTMLInputElementState
(
)
;
inputState
-
>
SetFilesOrDirectories
(
mFilesOrDirectories
)
;
}
break
;
case
VALUE_MODE_VALUE
:
case
VALUE_MODE_DEFAULT
:
if
(
(
GetValueMode
(
)
=
=
VALUE_MODE_DEFAULT
&
&
mType
!
=
NS_FORM_INPUT_HIDDEN
)
|
|
mType
=
=
NS_FORM_INPUT_PASSWORD
|
|
!
mValueChanged
)
{
break
;
}
inputState
=
new
HTMLInputElementState
(
)
;
nsAutoString
value
;
GetValue
(
value
CallerType
:
:
System
)
;
if
(
!
IsSingleLineTextControl
(
false
)
)
{
nsresult
rv
=
nsLinebreakConverter
:
:
ConvertStringLineBreaks
(
value
nsLinebreakConverter
:
:
eLinebreakPlatform
nsLinebreakConverter
:
:
eLinebreakContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Converting
linebreaks
failed
!
"
)
;
return
rv
;
}
}
inputState
-
>
SetValue
(
value
)
;
break
;
}
if
(
inputState
)
{
nsPresState
*
state
=
GetPrimaryPresState
(
)
;
if
(
state
)
{
state
-
>
SetStateProperty
(
inputState
)
;
}
}
if
(
mDisabledChanged
)
{
nsPresState
*
state
=
GetPrimaryPresState
(
)
;
if
(
state
)
{
state
-
>
SetDisabled
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
)
)
;
}
}
return
NS_OK
;
}
void
HTMLInputElement
:
:
DoneCreatingElement
(
)
{
mDoneCreating
=
true
;
bool
restoredCheckedState
=
!
mInhibitRestoration
&
&
NS_SUCCEEDED
(
GenerateStateKey
(
)
)
&
&
RestoreFormControlState
(
)
;
if
(
!
restoredCheckedState
&
&
mShouldInitChecked
)
{
DoSetChecked
(
DefaultChecked
(
)
false
true
)
;
DoSetCheckedChanged
(
false
false
)
;
}
if
(
GetValueMode
(
)
=
=
VALUE_MODE_VALUE
)
{
nsAutoString
aValue
;
GetValue
(
aValue
CallerType
:
:
System
)
;
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_Internal
)
;
}
mShouldInitChecked
=
false
;
}
EventStates
HTMLInputElement
:
:
IntrinsicState
(
)
const
{
EventStates
state
=
nsGenericHTMLFormElementWithState
:
:
IntrinsicState
(
)
;
if
(
mType
=
=
NS_FORM_INPUT_CHECKBOX
|
|
mType
=
=
NS_FORM_INPUT_RADIO
)
{
if
(
mChecked
)
{
state
|
=
NS_EVENT_STATE_CHECKED
;
}
if
(
mType
=
=
NS_FORM_INPUT_CHECKBOX
&
&
mIndeterminate
)
{
state
|
=
NS_EVENT_STATE_INDETERMINATE
;
}
if
(
mType
=
=
NS_FORM_INPUT_RADIO
)
{
nsCOMPtr
<
nsIDOMHTMLInputElement
>
selected
=
GetSelectedRadioButton
(
)
;
bool
indeterminate
=
!
selected
&
&
!
mChecked
;
if
(
indeterminate
)
{
state
|
=
NS_EVENT_STATE_INDETERMINATE
;
}
}
if
(
DefaultChecked
(
)
)
{
state
|
=
NS_EVENT_STATE_DEFAULT
;
}
}
else
if
(
mType
=
=
NS_FORM_INPUT_IMAGE
)
{
state
|
=
nsImageLoadingContent
:
:
ImageState
(
)
;
}
if
(
DoesRequiredApply
(
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
required
)
)
{
state
|
=
NS_EVENT_STATE_REQUIRED
;
}
else
{
state
|
=
NS_EVENT_STATE_OPTIONAL
;
}
if
(
IsCandidateForConstraintValidation
(
)
)
{
if
(
IsValid
(
)
)
{
state
|
=
NS_EVENT_STATE_VALID
;
}
else
{
state
|
=
NS_EVENT_STATE_INVALID
;
if
(
(
!
mForm
|
|
!
mForm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
)
&
&
(
GetValidityState
(
VALIDITY_STATE_CUSTOM_ERROR
)
|
|
(
mCanShowInvalidUI
&
&
ShouldShowValidityUI
(
)
)
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_UI_INVALID
;
}
}
if
(
(
!
mForm
|
|
!
mForm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
)
&
&
(
mCanShowValidUI
&
&
ShouldShowValidityUI
(
)
&
&
(
IsValid
(
)
|
|
(
!
state
.
HasState
(
NS_EVENT_STATE_MOZ_UI_INVALID
)
&
&
!
mCanShowInvalidUI
)
)
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_UI_VALID
;
}
if
(
mHasRange
)
{
state
|
=
(
GetValidityState
(
VALIDITY_STATE_RANGE_OVERFLOW
)
|
|
GetValidityState
(
VALIDITY_STATE_RANGE_UNDERFLOW
)
)
?
NS_EVENT_STATE_OUTOFRANGE
:
NS_EVENT_STATE_INRANGE
;
}
}
if
(
PlaceholderApplies
(
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
)
&
&
IsValueEmpty
(
)
)
{
state
|
=
NS_EVENT_STATE_PLACEHOLDERSHOWN
;
}
if
(
mForm
&
&
!
mForm
-
>
GetValidity
(
)
&
&
IsSubmitControl
(
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_SUBMITINVALID
;
}
return
state
;
}
void
HTMLInputElement
:
:
AddStates
(
EventStates
aStates
)
{
if
(
mType
=
=
NS_FORM_INPUT_TEXT
)
{
EventStates
focusStates
(
aStates
&
(
NS_EVENT_STATE_FOCUS
|
NS_EVENT_STATE_FOCUSRING
)
)
;
if
(
!
focusStates
.
IsEmpty
(
)
)
{
HTMLInputElement
*
ownerNumberControl
=
GetOwnerNumberControl
(
)
;
if
(
ownerNumberControl
)
{
ownerNumberControl
-
>
AddStates
(
focusStates
)
;
}
else
{
HTMLInputElement
*
ownerDateTimeControl
=
GetOwnerDateTimeControl
(
)
;
if
(
ownerDateTimeControl
)
{
ownerDateTimeControl
-
>
AddStates
(
focusStates
)
;
}
}
}
}
nsGenericHTMLFormElementWithState
:
:
AddStates
(
aStates
)
;
}
void
HTMLInputElement
:
:
RemoveStates
(
EventStates
aStates
)
{
if
(
mType
=
=
NS_FORM_INPUT_TEXT
)
{
EventStates
focusStates
(
aStates
&
(
NS_EVENT_STATE_FOCUS
|
NS_EVENT_STATE_FOCUSRING
)
)
;
if
(
!
focusStates
.
IsEmpty
(
)
)
{
HTMLInputElement
*
ownerNumberControl
=
GetOwnerNumberControl
(
)
;
if
(
ownerNumberControl
)
{
ownerNumberControl
-
>
RemoveStates
(
focusStates
)
;
}
else
{
HTMLInputElement
*
ownerDateTimeControl
=
GetOwnerDateTimeControl
(
)
;
if
(
ownerDateTimeControl
)
{
ownerDateTimeControl
-
>
RemoveStates
(
focusStates
)
;
}
}
}
}
nsGenericHTMLFormElementWithState
:
:
RemoveStates
(
aStates
)
;
}
bool
HTMLInputElement
:
:
RestoreState
(
nsPresState
*
aState
)
{
bool
restoredCheckedState
=
false
;
nsCOMPtr
<
HTMLInputElementState
>
inputState
(
do_QueryInterface
(
aState
-
>
GetStateProperty
(
)
)
)
;
if
(
inputState
)
{
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_DEFAULT_ON
:
if
(
inputState
-
>
IsCheckedSet
(
)
)
{
restoredCheckedState
=
true
;
DoSetChecked
(
inputState
-
>
GetChecked
(
)
true
true
)
;
}
break
;
case
VALUE_MODE_FILENAME
:
{
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
window
)
{
nsTArray
<
OwningFileOrDirectory
>
array
;
inputState
-
>
GetFilesOrDirectories
(
window
array
)
;
SetFilesOrDirectories
(
array
true
)
;
}
}
break
;
case
VALUE_MODE_VALUE
:
case
VALUE_MODE_DEFAULT
:
if
(
GetValueMode
(
)
=
=
VALUE_MODE_DEFAULT
&
&
mType
!
=
NS_FORM_INPUT_HIDDEN
)
{
break
;
}
SetValueInternal
(
inputState
-
>
GetValue
(
)
nsTextEditorState
:
:
eSetValue_Notify
)
;
break
;
}
}
if
(
aState
-
>
IsDisabledSet
(
)
)
{
SetDisabled
(
aState
-
>
GetDisabled
(
)
)
;
}
return
restoredCheckedState
;
}
bool
HTMLInputElement
:
:
AllowDrop
(
)
{
return
mType
!
=
NS_FORM_INPUT_FILE
;
}
void
HTMLInputElement
:
:
AddedToRadioGroup
(
)
{
if
(
!
mForm
&
&
!
IsInUncomposedDoc
(
)
)
{
return
;
}
bool
notify
=
mDoneCreating
;
if
(
mChecked
)
{
RadioSetChecked
(
notify
)
;
}
bool
checkedChanged
=
mCheckedChanged
;
nsCOMPtr
<
nsIRadioVisitor
>
visitor
=
new
nsRadioGetCheckedChangedVisitor
(
&
checkedChanged
this
)
;
VisitGroup
(
visitor
notify
)
;
SetCheckedChangedInternal
(
checkedChanged
)
;
nsCOMPtr
<
nsIRadioGroupContainer
>
container
=
GetRadioGroupContainer
(
)
;
if
(
container
)
{
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
container
-
>
AddToRadioGroup
(
name
static_cast
<
nsIFormControl
*
>
(
this
)
)
;
SetValidityState
(
VALIDITY_STATE_VALUE_MISSING
container
-
>
GetValueMissingState
(
name
)
)
;
}
}
void
HTMLInputElement
:
:
WillRemoveFromRadioGroup
(
)
{
nsIRadioGroupContainer
*
container
=
GetRadioGroupContainer
(
)
;
if
(
!
container
)
{
return
;
}
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
if
(
mChecked
)
{
container
-
>
SetCurrentRadioButton
(
name
nullptr
)
;
nsCOMPtr
<
nsIRadioVisitor
>
visitor
=
new
nsRadioUpdateStateVisitor
(
this
)
;
VisitGroup
(
visitor
true
)
;
}
UpdateValueMissingValidityStateForRadio
(
true
)
;
container
-
>
RemoveFromRadioGroup
(
name
static_cast
<
nsIFormControl
*
>
(
this
)
)
;
}
bool
HTMLInputElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
nsGenericHTMLFormElementWithState
:
:
IsHTMLFocusable
(
aWithMouse
aIsFocusable
aTabIndex
)
)
{
return
true
;
}
if
(
IsDisabled
(
)
)
{
*
aIsFocusable
=
false
;
return
true
;
}
if
(
IsSingleLineTextControl
(
false
)
|
|
mType
=
=
NS_FORM_INPUT_RANGE
)
{
*
aIsFocusable
=
true
;
return
false
;
}
#
ifdef
XP_MACOSX
const
bool
defaultFocusable
=
!
aWithMouse
|
|
nsFocusManager
:
:
sMouseFocusesFormControl
;
#
else
const
bool
defaultFocusable
=
true
;
#
endif
if
(
mType
=
=
NS_FORM_INPUT_FILE
|
|
mType
=
=
NS_FORM_INPUT_NUMBER
|
|
mType
=
=
NS_FORM_INPUT_TIME
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
|
|
mType
=
=
NS_FORM_INPUT_TIME
)
{
*
aIsFocusable
=
true
;
}
else
{
*
aIsFocusable
=
defaultFocusable
;
}
return
true
;
}
if
(
mType
=
=
NS_FORM_INPUT_HIDDEN
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
*
aIsFocusable
=
false
;
return
false
;
}
if
(
!
aTabIndex
)
{
*
aIsFocusable
=
defaultFocusable
;
return
false
;
}
if
(
mType
!
=
NS_FORM_INPUT_RADIO
)
{
*
aIsFocusable
=
defaultFocusable
;
return
false
;
}
if
(
mChecked
)
{
*
aIsFocusable
=
defaultFocusable
;
return
false
;
}
nsIRadioGroupContainer
*
container
=
GetRadioGroupContainer
(
)
;
if
(
!
container
)
{
*
aIsFocusable
=
defaultFocusable
;
return
false
;
}
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
if
(
container
-
>
GetCurrentRadioButton
(
name
)
)
{
*
aTabIndex
=
-
1
;
}
*
aIsFocusable
=
defaultFocusable
;
return
false
;
}
nsresult
HTMLInputElement
:
:
VisitGroup
(
nsIRadioVisitor
*
aVisitor
bool
aFlushContent
)
{
nsIRadioGroupContainer
*
container
=
GetRadioGroupContainer
(
)
;
if
(
container
)
{
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
return
container
-
>
WalkRadioGroup
(
name
aVisitor
aFlushContent
)
;
}
aVisitor
-
>
Visit
(
this
)
;
return
NS_OK
;
}
HTMLInputElement
:
:
ValueModeType
HTMLInputElement
:
:
GetValueMode
(
)
const
{
switch
(
mType
)
{
case
NS_FORM_INPUT_HIDDEN
:
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_BUTTON
:
case
NS_FORM_INPUT_RESET
:
case
NS_FORM_INPUT_IMAGE
:
return
VALUE_MODE_DEFAULT
;
case
NS_FORM_INPUT_CHECKBOX
:
case
NS_FORM_INPUT_RADIO
:
return
VALUE_MODE_DEFAULT_ON
;
case
NS_FORM_INPUT_FILE
:
return
VALUE_MODE_FILENAME
;
#
ifdef
DEBUG
case
NS_FORM_INPUT_TEXT
:
case
NS_FORM_INPUT_PASSWORD
:
case
NS_FORM_INPUT_SEARCH
:
case
NS_FORM_INPUT_TEL
:
case
NS_FORM_INPUT_EMAIL
:
case
NS_FORM_INPUT_URL
:
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_RANGE
:
case
NS_FORM_INPUT_DATE
:
case
NS_FORM_INPUT_TIME
:
case
NS_FORM_INPUT_COLOR
:
case
NS_FORM_INPUT_MONTH
:
case
NS_FORM_INPUT_WEEK
:
case
NS_FORM_INPUT_DATETIME_LOCAL
:
return
VALUE_MODE_VALUE
;
default
:
NS_NOTYETIMPLEMENTED
(
"
Unexpected
input
type
in
GetValueMode
(
)
"
)
;
return
VALUE_MODE_VALUE
;
#
else
default
:
return
VALUE_MODE_VALUE
;
#
endif
}
}
bool
HTMLInputElement
:
:
IsMutable
(
)
const
{
return
!
IsDisabled
(
)
&
&
!
(
DoesReadOnlyApply
(
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
)
;
}
bool
HTMLInputElement
:
:
DoesReadOnlyApply
(
)
const
{
switch
(
mType
)
{
case
NS_FORM_INPUT_HIDDEN
:
case
NS_FORM_INPUT_BUTTON
:
case
NS_FORM_INPUT_IMAGE
:
case
NS_FORM_INPUT_RESET
:
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_RADIO
:
case
NS_FORM_INPUT_FILE
:
case
NS_FORM_INPUT_CHECKBOX
:
case
NS_FORM_INPUT_RANGE
:
case
NS_FORM_INPUT_COLOR
:
return
false
;
#
ifdef
DEBUG
case
NS_FORM_INPUT_TEXT
:
case
NS_FORM_INPUT_PASSWORD
:
case
NS_FORM_INPUT_SEARCH
:
case
NS_FORM_INPUT_TEL
:
case
NS_FORM_INPUT_EMAIL
:
case
NS_FORM_INPUT_URL
:
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_DATE
:
case
NS_FORM_INPUT_TIME
:
case
NS_FORM_INPUT_MONTH
:
case
NS_FORM_INPUT_WEEK
:
case
NS_FORM_INPUT_DATETIME_LOCAL
:
return
true
;
default
:
NS_NOTYETIMPLEMENTED
(
"
Unexpected
input
type
in
DoesReadOnlyApply
(
)
"
)
;
return
true
;
#
else
default
:
return
true
;
#
endif
}
}
bool
HTMLInputElement
:
:
DoesRequiredApply
(
)
const
{
switch
(
mType
)
{
case
NS_FORM_INPUT_HIDDEN
:
case
NS_FORM_INPUT_BUTTON
:
case
NS_FORM_INPUT_IMAGE
:
case
NS_FORM_INPUT_RESET
:
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_RANGE
:
case
NS_FORM_INPUT_COLOR
:
return
false
;
#
ifdef
DEBUG
case
NS_FORM_INPUT_RADIO
:
case
NS_FORM_INPUT_CHECKBOX
:
case
NS_FORM_INPUT_FILE
:
case
NS_FORM_INPUT_TEXT
:
case
NS_FORM_INPUT_PASSWORD
:
case
NS_FORM_INPUT_SEARCH
:
case
NS_FORM_INPUT_TEL
:
case
NS_FORM_INPUT_EMAIL
:
case
NS_FORM_INPUT_URL
:
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_DATE
:
case
NS_FORM_INPUT_TIME
:
case
NS_FORM_INPUT_MONTH
:
case
NS_FORM_INPUT_WEEK
:
case
NS_FORM_INPUT_DATETIME_LOCAL
:
return
true
;
default
:
NS_NOTYETIMPLEMENTED
(
"
Unexpected
input
type
in
DoesRequiredApply
(
)
"
)
;
return
true
;
#
else
default
:
return
true
;
#
endif
}
}
bool
HTMLInputElement
:
:
PlaceholderApplies
(
)
const
{
if
(
IsDateTimeInputType
(
mType
)
)
{
return
false
;
}
return
IsSingleLineTextControl
(
false
)
;
}
bool
HTMLInputElement
:
:
DoesPatternApply
(
)
const
{
if
(
IsExperimentalMobileType
(
mType
)
|
|
IsDateTimeInputType
(
mType
)
)
{
return
false
;
}
return
IsSingleLineTextControl
(
false
)
;
}
bool
HTMLInputElement
:
:
DoesMinMaxApply
(
)
const
{
switch
(
mType
)
{
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_DATE
:
case
NS_FORM_INPUT_TIME
:
case
NS_FORM_INPUT_RANGE
:
case
NS_FORM_INPUT_MONTH
:
case
NS_FORM_INPUT_WEEK
:
case
NS_FORM_INPUT_DATETIME_LOCAL
:
return
true
;
#
ifdef
DEBUG
case
NS_FORM_INPUT_RESET
:
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_IMAGE
:
case
NS_FORM_INPUT_BUTTON
:
case
NS_FORM_INPUT_HIDDEN
:
case
NS_FORM_INPUT_RADIO
:
case
NS_FORM_INPUT_CHECKBOX
:
case
NS_FORM_INPUT_FILE
:
case
NS_FORM_INPUT_TEXT
:
case
NS_FORM_INPUT_PASSWORD
:
case
NS_FORM_INPUT_SEARCH
:
case
NS_FORM_INPUT_TEL
:
case
NS_FORM_INPUT_EMAIL
:
case
NS_FORM_INPUT_URL
:
case
NS_FORM_INPUT_COLOR
:
return
false
;
default
:
NS_NOTYETIMPLEMENTED
(
"
Unexpected
input
type
in
DoesRequiredApply
(
)
"
)
;
return
false
;
#
else
default
:
return
false
;
#
endif
}
}
bool
HTMLInputElement
:
:
DoesAutocompleteApply
(
)
const
{
switch
(
mType
)
{
case
NS_FORM_INPUT_HIDDEN
:
case
NS_FORM_INPUT_TEXT
:
case
NS_FORM_INPUT_SEARCH
:
case
NS_FORM_INPUT_URL
:
case
NS_FORM_INPUT_TEL
:
case
NS_FORM_INPUT_EMAIL
:
case
NS_FORM_INPUT_PASSWORD
:
case
NS_FORM_INPUT_DATE
:
case
NS_FORM_INPUT_TIME
:
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_RANGE
:
case
NS_FORM_INPUT_COLOR
:
case
NS_FORM_INPUT_MONTH
:
case
NS_FORM_INPUT_WEEK
:
case
NS_FORM_INPUT_DATETIME_LOCAL
:
return
true
;
#
ifdef
DEBUG
case
NS_FORM_INPUT_RESET
:
case
NS_FORM_INPUT_SUBMIT
:
case
NS_FORM_INPUT_IMAGE
:
case
NS_FORM_INPUT_BUTTON
:
case
NS_FORM_INPUT_RADIO
:
case
NS_FORM_INPUT_CHECKBOX
:
case
NS_FORM_INPUT_FILE
:
return
false
;
default
:
NS_NOTYETIMPLEMENTED
(
"
Unexpected
input
type
in
DoesAutocompleteApply
(
)
"
)
;
return
false
;
#
else
default
:
return
false
;
#
endif
}
}
Decimal
HTMLInputElement
:
:
GetStep
(
)
const
{
MOZ_ASSERT
(
DoesStepApply
(
)
"
GetStep
(
)
can
only
be
called
if
step
applies
"
)
;
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
step
)
)
{
return
GetDefaultStep
(
)
*
GetStepScaleFactor
(
)
;
}
nsAutoString
stepStr
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
step
stepStr
)
;
if
(
stepStr
.
LowerCaseEqualsLiteral
(
"
any
"
)
)
{
return
kStepAny
;
}
Decimal
step
=
StringToDecimal
(
stepStr
)
;
if
(
!
step
.
isFinite
(
)
|
|
step
<
=
Decimal
(
0
)
)
{
step
=
GetDefaultStep
(
)
;
}
if
(
mType
=
=
NS_FORM_INPUT_DATE
|
|
mType
=
=
NS_FORM_INPUT_MONTH
|
|
mType
=
=
NS_FORM_INPUT_WEEK
)
{
step
=
std
:
:
max
(
step
.
round
(
)
Decimal
(
1
)
)
;
}
return
step
*
GetStepScaleFactor
(
)
;
}
NS_IMETHODIMP
HTMLInputElement
:
:
SetCustomValidity
(
const
nsAString
&
aError
)
{
nsIConstraintValidation
:
:
SetCustomValidity
(
aError
)
;
UpdateState
(
true
)
;
return
NS_OK
;
}
bool
HTMLInputElement
:
:
IsTooLong
(
)
{
if
(
!
mValueChanged
|
|
!
mLastValueChangeWasInteractive
|
|
!
MinOrMaxLengthApplies
(
)
|
|
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
maxlength
)
)
{
return
false
;
}
int32_t
maxLength
=
MaxLength
(
)
;
if
(
maxLength
=
=
-
1
)
{
return
false
;
}
return
InputTextLength
(
CallerType
:
:
System
)
>
maxLength
;
}
bool
HTMLInputElement
:
:
IsTooShort
(
)
{
if
(
!
mValueChanged
|
|
!
mLastValueChangeWasInteractive
|
|
!
MinOrMaxLengthApplies
(
)
|
|
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
minlength
)
)
{
return
false
;
}
int32_t
minLength
=
MinLength
(
)
;
if
(
minLength
=
=
-
1
)
{
return
false
;
}
int32_t
textLength
=
InputTextLength
(
CallerType
:
:
System
)
;
return
textLength
&
&
textLength
<
minLength
;
}
bool
HTMLInputElement
:
:
IsValueMissing
(
)
const
{
MOZ_ASSERT
(
mType
!
=
NS_FORM_INPUT_RADIO
)
;
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
required
)
|
|
!
DoesRequiredApply
(
)
)
{
return
false
;
}
if
(
!
IsMutable
(
)
)
{
return
false
;
}
switch
(
GetValueMode
(
)
)
{
case
VALUE_MODE_VALUE
:
return
IsValueEmpty
(
)
;
case
VALUE_MODE_FILENAME
:
return
GetFilesOrDirectoriesInternal
(
)
.
IsEmpty
(
)
;
case
VALUE_MODE_DEFAULT_ON
:
return
!
mChecked
;
case
VALUE_MODE_DEFAULT
:
default
:
return
false
;
}
}
bool
HTMLInputElement
:
:
HasTypeMismatch
(
)
const
{
if
(
mType
!
=
NS_FORM_INPUT_EMAIL
&
&
mType
!
=
NS_FORM_INPUT_URL
)
{
return
false
;
}
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
mType
=
=
NS_FORM_INPUT_EMAIL
)
{
return
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
multiple
)
?
!
IsValidEmailAddressList
(
value
)
:
!
IsValidEmailAddress
(
value
)
;
}
else
if
(
mType
=
=
NS_FORM_INPUT_URL
)
{
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
return
!
NS_SUCCEEDED
(
ioService
-
>
NewURI
(
NS_ConvertUTF16toUTF8
(
value
)
nullptr
nullptr
getter_AddRefs
(
uri
)
)
)
;
}
return
false
;
}
bool
HTMLInputElement
:
:
HasPatternMismatch
(
)
const
{
if
(
!
DoesPatternApply
(
)
|
|
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
pattern
)
)
{
return
false
;
}
nsAutoString
pattern
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
pattern
pattern
)
;
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
return
false
;
}
nsIDocument
*
doc
=
OwnerDoc
(
)
;
return
!
nsContentUtils
:
:
IsPatternMatching
(
value
pattern
doc
)
;
}
bool
HTMLInputElement
:
:
IsRangeOverflow
(
)
const
{
if
(
!
DoesMinMaxApply
(
)
|
|
mType
=
=
NS_FORM_INPUT_DATETIME_LOCAL
)
{
return
false
;
}
Decimal
maximum
=
GetMaximum
(
)
;
if
(
maximum
.
isNaN
(
)
)
{
return
false
;
}
Decimal
value
=
GetValueAsDecimal
(
)
;
if
(
value
.
isNaN
(
)
)
{
return
false
;
}
return
value
>
maximum
;
}
bool
HTMLInputElement
:
:
IsRangeUnderflow
(
)
const
{
if
(
!
DoesMinMaxApply
(
)
|
|
mType
=
=
NS_FORM_INPUT_DATETIME_LOCAL
)
{
return
false
;
}
Decimal
minimum
=
GetMinimum
(
)
;
if
(
minimum
.
isNaN
(
)
)
{
return
false
;
}
Decimal
value
=
GetValueAsDecimal
(
)
;
if
(
value
.
isNaN
(
)
)
{
return
false
;
}
return
value
<
minimum
;
}
bool
HTMLInputElement
:
:
HasStepMismatch
(
bool
aUseZeroIfValueNaN
)
const
{
if
(
!
DoesStepApply
(
)
)
{
return
false
;
}
Decimal
value
=
GetValueAsDecimal
(
)
;
if
(
value
.
isNaN
(
)
)
{
if
(
aUseZeroIfValueNaN
)
{
value
=
Decimal
(
0
)
;
}
else
{
return
false
;
}
}
Decimal
step
=
GetStep
(
)
;
if
(
step
=
=
kStepAny
)
{
return
false
;
}
return
NS_floorModulo
(
value
-
GetStepBase
(
)
step
)
!
=
Decimal
(
0
)
;
}
static
bool
PunycodeEncodeEmailAddress
(
const
nsAString
&
aEmail
nsAutoCString
&
aEncodedEmail
uint32_t
*
aIndexOfAt
)
{
nsAutoCString
value
=
NS_ConvertUTF16toUTF8
(
aEmail
)
;
*
aIndexOfAt
=
(
uint32_t
)
value
.
FindChar
(
'
'
)
;
if
(
*
aIndexOfAt
=
=
(
uint32_t
)
kNotFound
|
|
*
aIndexOfAt
=
=
value
.
Length
(
)
-
1
)
{
aEncodedEmail
=
value
;
return
true
;
}
nsCOMPtr
<
nsIIDNService
>
idnSrv
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
)
;
if
(
!
idnSrv
)
{
NS_ERROR
(
"
nsIIDNService
isn
'
t
present
!
"
)
;
return
false
;
}
uint32_t
indexOfDomain
=
*
aIndexOfAt
+
1
;
const
nsDependentCSubstring
domain
=
Substring
(
value
indexOfDomain
)
;
bool
ace
;
if
(
NS_SUCCEEDED
(
idnSrv
-
>
IsACE
(
domain
&
ace
)
)
&
&
!
ace
)
{
nsAutoCString
domainACE
;
if
(
NS_FAILED
(
idnSrv
-
>
ConvertUTF8toACE
(
domain
domainACE
)
)
)
{
return
false
;
}
value
.
Replace
(
indexOfDomain
domain
.
Length
(
)
domainACE
)
;
}
aEncodedEmail
=
value
;
return
true
;
}
bool
HTMLInputElement
:
:
HasBadInput
(
)
const
{
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
GetValueAsDecimal
(
)
.
isNaN
(
)
"
Should
have
sanitized
"
)
;
return
false
;
}
nsNumberControlFrame
*
numberControlFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
numberControlFrame
&
&
!
numberControlFrame
-
>
AnonTextControlIsEmpty
(
)
)
{
return
true
;
}
return
false
;
}
if
(
mType
=
=
NS_FORM_INPUT_EMAIL
)
{
nsAutoString
value
;
nsAutoCString
unused
;
uint32_t
unused2
;
GetNonFileValueInternal
(
value
)
;
HTMLSplitOnSpacesTokenizer
tokenizer
(
value
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
if
(
!
PunycodeEncodeEmailAddress
(
tokenizer
.
nextToken
(
)
unused
&
unused2
)
)
{
return
true
;
}
}
return
false
;
}
return
false
;
}
void
HTMLInputElement
:
:
UpdateTooLongValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_TOO_LONG
IsTooLong
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateTooShortValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_TOO_SHORT
IsTooShort
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateValueMissingValidityStateForRadio
(
bool
aIgnoreSelf
)
{
bool
notify
=
mDoneCreating
;
nsCOMPtr
<
nsIDOMHTMLInputElement
>
selection
=
GetSelectedRadioButton
(
)
;
aIgnoreSelf
=
aIgnoreSelf
|
|
!
IsMutable
(
)
;
bool
selected
=
selection
|
|
(
!
aIgnoreSelf
&
&
mChecked
)
;
bool
required
=
!
aIgnoreSelf
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
required
)
;
bool
valueMissing
=
false
;
nsCOMPtr
<
nsIRadioGroupContainer
>
container
=
GetRadioGroupContainer
(
)
;
if
(
!
container
)
{
SetValidityState
(
VALIDITY_STATE_VALUE_MISSING
IsMutable
(
)
&
&
required
&
&
!
selected
)
;
return
;
}
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
if
(
!
required
)
{
required
=
(
aIgnoreSelf
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
required
)
)
?
container
-
>
GetRequiredRadioCount
(
name
)
-
1
:
container
-
>
GetRequiredRadioCount
(
name
)
;
}
valueMissing
=
required
&
&
!
selected
;
if
(
container
-
>
GetValueMissingState
(
name
)
!
=
valueMissing
)
{
container
-
>
SetValueMissingState
(
name
valueMissing
)
;
SetValidityState
(
VALIDITY_STATE_VALUE_MISSING
valueMissing
)
;
nsAutoScriptBlocker
scriptBlocker
;
nsCOMPtr
<
nsIRadioVisitor
>
visitor
=
new
nsRadioSetValueMissingState
(
this
valueMissing
notify
)
;
VisitGroup
(
visitor
notify
)
;
}
}
void
HTMLInputElement
:
:
UpdateValueMissingValidityState
(
)
{
if
(
mType
=
=
NS_FORM_INPUT_RADIO
)
{
UpdateValueMissingValidityStateForRadio
(
false
)
;
return
;
}
SetValidityState
(
VALIDITY_STATE_VALUE_MISSING
IsValueMissing
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateTypeMismatchValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_TYPE_MISMATCH
HasTypeMismatch
(
)
)
;
}
void
HTMLInputElement
:
:
UpdatePatternMismatchValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_PATTERN_MISMATCH
HasPatternMismatch
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateRangeOverflowValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_RANGE_OVERFLOW
IsRangeOverflow
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateRangeUnderflowValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_RANGE_UNDERFLOW
IsRangeUnderflow
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateStepMismatchValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_STEP_MISMATCH
HasStepMismatch
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateBadInputValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_BAD_INPUT
HasBadInput
(
)
)
;
}
void
HTMLInputElement
:
:
UpdateAllValidityStates
(
bool
aNotify
)
{
bool
validBefore
=
IsValid
(
)
;
UpdateTooLongValidityState
(
)
;
UpdateTooShortValidityState
(
)
;
UpdateValueMissingValidityState
(
)
;
UpdateTypeMismatchValidityState
(
)
;
UpdatePatternMismatchValidityState
(
)
;
UpdateRangeOverflowValidityState
(
)
;
UpdateRangeUnderflowValidityState
(
)
;
UpdateStepMismatchValidityState
(
)
;
UpdateBadInputValidityState
(
)
;
if
(
validBefore
!
=
IsValid
(
)
)
{
UpdateState
(
aNotify
)
;
}
}
void
HTMLInputElement
:
:
UpdateBarredFromConstraintValidation
(
)
{
SetBarredFromConstraintValidation
(
mType
=
=
NS_FORM_INPUT_HIDDEN
|
|
mType
=
=
NS_FORM_INPUT_BUTTON
|
|
mType
=
=
NS_FORM_INPUT_RESET
|
|
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
|
|
IsDisabled
(
)
)
;
}
void
HTMLInputElement
:
:
GetValidationMessage
(
nsAString
&
aValidationMessage
ErrorResult
&
aRv
)
{
aRv
=
GetValidationMessage
(
aValidationMessage
)
;
}
nsresult
HTMLInputElement
:
:
GetValidationMessage
(
nsAString
&
aValidationMessage
ValidityStateType
aType
)
{
nsresult
rv
=
NS_OK
;
switch
(
aType
)
{
case
VALIDITY_STATE_TOO_LONG
:
{
nsXPIDLString
message
;
int32_t
maxLength
=
MaxLength
(
)
;
int32_t
textLength
=
InputTextLength
(
CallerType
:
:
System
)
;
nsAutoString
strMaxLength
;
nsAutoString
strTextLength
;
strMaxLength
.
AppendInt
(
maxLength
)
;
strTextLength
.
AppendInt
(
textLength
)
;
const
char16_t
*
params
[
]
=
{
strMaxLength
.
get
(
)
strTextLength
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationTextTooLong
"
params
message
)
;
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_TOO_SHORT
:
{
nsXPIDLString
message
;
int32_t
minLength
=
MinLength
(
)
;
int32_t
textLength
=
InputTextLength
(
CallerType
:
:
System
)
;
nsAutoString
strMinLength
;
nsAutoString
strTextLength
;
strMinLength
.
AppendInt
(
minLength
)
;
strTextLength
.
AppendInt
(
textLength
)
;
const
char16_t
*
params
[
]
=
{
strMinLength
.
get
(
)
strTextLength
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationTextTooShort
"
params
message
)
;
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_VALUE_MISSING
:
{
nsXPIDLString
message
;
nsAutoCString
key
;
switch
(
mType
)
{
case
NS_FORM_INPUT_FILE
:
key
.
AssignLiteral
(
"
FormValidationFileMissing
"
)
;
break
;
case
NS_FORM_INPUT_CHECKBOX
:
key
.
AssignLiteral
(
"
FormValidationCheckboxMissing
"
)
;
break
;
case
NS_FORM_INPUT_RADIO
:
key
.
AssignLiteral
(
"
FormValidationRadioMissing
"
)
;
break
;
case
NS_FORM_INPUT_NUMBER
:
key
.
AssignLiteral
(
"
FormValidationBadInputNumber
"
)
;
break
;
default
:
key
.
AssignLiteral
(
"
FormValidationValueMissing
"
)
;
}
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
key
.
get
(
)
message
)
;
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_TYPE_MISMATCH
:
{
nsXPIDLString
message
;
nsAutoCString
key
;
if
(
mType
=
=
NS_FORM_INPUT_EMAIL
)
{
key
.
AssignLiteral
(
"
FormValidationInvalidEmail
"
)
;
}
else
if
(
mType
=
=
NS_FORM_INPUT_URL
)
{
key
.
AssignLiteral
(
"
FormValidationInvalidURL
"
)
;
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
key
.
get
(
)
message
)
;
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_PATTERN_MISMATCH
:
{
nsXPIDLString
message
;
nsAutoString
title
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
title
title
)
;
if
(
title
.
IsEmpty
(
)
)
{
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationPatternMismatch
"
message
)
;
}
else
{
if
(
title
.
Length
(
)
>
nsIConstraintValidation
:
:
sContentSpecifiedMaxLengthMessage
)
{
title
.
Truncate
(
nsIConstraintValidation
:
:
sContentSpecifiedMaxLengthMessage
)
;
}
const
char16_t
*
params
[
]
=
{
title
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationPatternMismatchWithTitle
"
params
message
)
;
}
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_RANGE_OVERFLOW
:
{
static
const
char
kNumberOverTemplate
[
]
=
"
FormValidationNumberRangeOverflow
"
;
static
const
char
kDateOverTemplate
[
]
=
"
FormValidationDateRangeOverflow
"
;
static
const
char
kTimeOverTemplate
[
]
=
"
FormValidationTimeRangeOverflow
"
;
const
char
*
msgTemplate
;
nsXPIDLString
message
;
nsAutoString
maxStr
;
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
|
|
mType
=
=
NS_FORM_INPUT_RANGE
)
{
msgTemplate
=
kNumberOverTemplate
;
Decimal
maximum
=
GetMaximum
(
)
;
MOZ_ASSERT
(
!
maximum
.
isNaN
(
)
)
;
char
buf
[
32
]
;
DebugOnly
<
bool
>
ok
=
maximum
.
toString
(
buf
ArrayLength
(
buf
)
)
;
maxStr
.
AssignASCII
(
buf
)
;
MOZ_ASSERT
(
ok
"
buf
not
big
enough
"
)
;
}
else
if
(
IsDateTimeInputType
(
mType
)
)
{
msgTemplate
=
mType
=
=
NS_FORM_INPUT_TIME
?
kTimeOverTemplate
:
kDateOverTemplate
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
max
maxStr
)
;
}
else
{
msgTemplate
=
kNumberOverTemplate
;
NS_NOTREACHED
(
"
Unexpected
input
type
"
)
;
}
const
char16_t
*
params
[
]
=
{
maxStr
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
msgTemplate
params
message
)
;
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_RANGE_UNDERFLOW
:
{
static
const
char
kNumberUnderTemplate
[
]
=
"
FormValidationNumberRangeUnderflow
"
;
static
const
char
kDateUnderTemplate
[
]
=
"
FormValidationDateRangeUnderflow
"
;
static
const
char
kTimeUnderTemplate
[
]
=
"
FormValidationTimeRangeUnderflow
"
;
const
char
*
msgTemplate
;
nsXPIDLString
message
;
nsAutoString
minStr
;
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
|
|
mType
=
=
NS_FORM_INPUT_RANGE
)
{
msgTemplate
=
kNumberUnderTemplate
;
Decimal
minimum
=
GetMinimum
(
)
;
MOZ_ASSERT
(
!
minimum
.
isNaN
(
)
)
;
char
buf
[
32
]
;
DebugOnly
<
bool
>
ok
=
minimum
.
toString
(
buf
ArrayLength
(
buf
)
)
;
minStr
.
AssignASCII
(
buf
)
;
MOZ_ASSERT
(
ok
"
buf
not
big
enough
"
)
;
}
else
if
(
IsDateTimeInputType
(
mType
)
)
{
msgTemplate
=
mType
=
=
NS_FORM_INPUT_TIME
?
kTimeUnderTemplate
:
kDateUnderTemplate
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
min
minStr
)
;
}
else
{
msgTemplate
=
kNumberUnderTemplate
;
NS_NOTREACHED
(
"
Unexpected
input
type
"
)
;
}
const
char16_t
*
params
[
]
=
{
minStr
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
msgTemplate
params
message
)
;
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_STEP_MISMATCH
:
{
nsXPIDLString
message
;
Decimal
value
=
GetValueAsDecimal
(
)
;
MOZ_ASSERT
(
!
value
.
isNaN
(
)
)
;
Decimal
step
=
GetStep
(
)
;
MOZ_ASSERT
(
step
!
=
kStepAny
&
&
step
>
Decimal
(
0
)
)
;
Decimal
stepBase
=
GetStepBase
(
)
;
Decimal
valueLow
=
value
-
NS_floorModulo
(
value
-
stepBase
step
)
;
Decimal
valueHigh
=
value
+
step
-
NS_floorModulo
(
value
-
stepBase
step
)
;
Decimal
maximum
=
GetMaximum
(
)
;
if
(
maximum
.
isNaN
(
)
|
|
valueHigh
<
=
maximum
)
{
nsAutoString
valueLowStr
valueHighStr
;
ConvertNumberToString
(
valueLow
valueLowStr
)
;
ConvertNumberToString
(
valueHigh
valueHighStr
)
;
if
(
valueLowStr
.
Equals
(
valueHighStr
)
)
{
const
char16_t
*
params
[
]
=
{
valueLowStr
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationStepMismatchOneValue
"
params
message
)
;
}
else
{
const
char16_t
*
params
[
]
=
{
valueLowStr
.
get
(
)
valueHighStr
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationStepMismatch
"
params
message
)
;
}
}
else
{
nsAutoString
valueLowStr
;
ConvertNumberToString
(
valueLow
valueLowStr
)
;
const
char16_t
*
params
[
]
=
{
valueLowStr
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationStepMismatchOneValue
"
params
message
)
;
}
aValidationMessage
=
message
;
break
;
}
case
VALIDITY_STATE_BAD_INPUT
:
{
nsXPIDLString
message
;
nsAutoCString
key
;
if
(
mType
=
=
NS_FORM_INPUT_NUMBER
)
{
key
.
AssignLiteral
(
"
FormValidationBadInputNumber
"
)
;
}
else
if
(
mType
=
=
NS_FORM_INPUT_EMAIL
)
{
key
.
AssignLiteral
(
"
FormValidationInvalidEmail
"
)
;
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
key
.
get
(
)
message
)
;
aValidationMessage
=
message
;
break
;
}
default
:
rv
=
nsIConstraintValidation
:
:
GetValidationMessage
(
aValidationMessage
aType
)
;
}
return
rv
;
}
bool
HTMLInputElement
:
:
IsValidEmailAddressList
(
const
nsAString
&
aValue
)
{
HTMLSplitOnSpacesTokenizer
tokenizer
(
aValue
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
if
(
!
IsValidEmailAddress
(
tokenizer
.
nextToken
(
)
)
)
{
return
false
;
}
}
return
!
tokenizer
.
separatorAfterCurrentToken
(
)
;
}
bool
HTMLInputElement
:
:
IsValidEmailAddress
(
const
nsAString
&
aValue
)
{
if
(
aValue
.
IsEmpty
(
)
|
|
aValue
.
Last
(
)
=
=
'
.
'
|
|
aValue
.
Last
(
)
=
=
'
-
'
)
{
return
false
;
}
uint32_t
atPos
;
nsAutoCString
value
;
if
(
!
PunycodeEncodeEmailAddress
(
aValue
value
&
atPos
)
|
|
atPos
=
=
(
uint32_t
)
kNotFound
|
|
atPos
=
=
0
|
|
atPos
=
=
value
.
Length
(
)
-
1
)
{
return
false
;
}
uint32_t
length
=
value
.
Length
(
)
;
uint32_t
i
=
0
;
for
(
;
i
<
atPos
;
+
+
i
)
{
char16_t
c
=
value
[
i
]
;
if
(
!
(
nsCRT
:
:
IsAsciiAlpha
(
c
)
|
|
nsCRT
:
:
IsAsciiDigit
(
c
)
|
|
c
=
=
'
.
'
|
|
c
=
=
'
!
'
|
|
c
=
=
'
#
'
|
|
c
=
=
'
'
|
|
c
=
=
'
%
'
|
|
c
=
=
'
&
'
|
|
c
=
=
'
\
'
'
|
|
c
=
=
'
*
'
|
|
c
=
=
'
+
'
|
|
c
=
=
'
-
'
|
|
c
=
=
'
/
'
|
|
c
=
=
'
=
'
|
|
c
=
=
'
?
'
|
|
c
=
=
'
^
'
|
|
c
=
=
'
_
'
|
|
c
=
=
'
'
|
|
c
=
=
'
{
'
|
|
c
=
=
'
|
'
|
|
c
=
=
'
}
'
|
|
c
=
=
'
~
'
)
)
{
return
false
;
}
}
+
+
i
;
if
(
value
[
i
]
=
=
'
.
'
|
|
value
[
i
]
=
=
'
-
'
)
{
return
false
;
}
for
(
;
i
<
length
;
+
+
i
)
{
char16_t
c
=
value
[
i
]
;
if
(
c
=
=
'
.
'
)
{
if
(
value
[
i
-
1
]
=
=
'
.
'
|
|
value
[
i
-
1
]
=
=
'
-
'
)
{
return
false
;
}
}
else
if
(
c
=
=
'
-
'
)
{
if
(
value
[
i
-
1
]
=
=
'
.
'
)
{
return
false
;
}
}
else
if
(
!
(
nsCRT
:
:
IsAsciiAlpha
(
c
)
|
|
nsCRT
:
:
IsAsciiDigit
(
c
)
|
|
c
=
=
'
-
'
)
)
{
return
false
;
}
}
return
true
;
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
IsSingleLineTextControl
(
)
const
{
return
IsSingleLineTextControl
(
false
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
IsTextArea
(
)
const
{
return
false
;
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
IsPlainTextControl
(
)
const
{
return
true
;
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
IsPasswordTextControl
(
)
const
{
return
mType
=
=
NS_FORM_INPUT_PASSWORD
;
}
NS_IMETHODIMP_
(
int32_t
)
HTMLInputElement
:
:
GetCols
(
)
{
const
nsAttrValue
*
attr
=
GetParsedAttr
(
nsGkAtoms
:
:
size
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
int32_t
cols
=
attr
-
>
GetIntegerValue
(
)
;
if
(
cols
>
0
)
{
return
cols
;
}
}
return
DEFAULT_COLS
;
}
NS_IMETHODIMP_
(
int32_t
)
HTMLInputElement
:
:
GetWrapCols
(
)
{
return
0
;
}
NS_IMETHODIMP_
(
int32_t
)
HTMLInputElement
:
:
GetRows
(
)
{
return
DEFAULT_ROWS
;
}
NS_IMETHODIMP_
(
void
)
HTMLInputElement
:
:
GetDefaultValueFromContent
(
nsAString
&
aValue
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
GetDefaultValue
(
aValue
)
;
if
(
mDoneCreating
)
{
SanitizeValue
(
aValue
)
;
}
}
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
ValueChanged
(
)
const
{
return
mValueChanged
;
}
NS_IMETHODIMP_
(
void
)
HTMLInputElement
:
:
GetTextEditorValue
(
nsAString
&
aValue
bool
aIgnoreWrap
)
const
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
state
-
>
GetValue
(
aValue
aIgnoreWrap
)
;
}
}
NS_IMETHODIMP_
(
void
)
HTMLInputElement
:
:
InitializeKeyboardEventListeners
(
)
{
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
state
-
>
InitializeKeyboardEventListeners
(
)
;
}
}
NS_IMETHODIMP_
(
void
)
HTMLInputElement
:
:
OnValueChanged
(
bool
aNotify
bool
aWasInteractiveUserChange
)
{
mLastValueChangeWasInteractive
=
aWasInteractiveUserChange
;
UpdateAllValidityStates
(
aNotify
)
;
if
(
HasDirAuto
(
)
)
{
SetDirectionIfAuto
(
true
aNotify
)
;
}
if
(
PlaceholderApplies
(
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
)
)
{
UpdateState
(
aNotify
)
;
}
}
NS_IMETHODIMP_
(
bool
)
HTMLInputElement
:
:
HasCachedSelection
(
)
{
bool
isCached
=
false
;
nsTextEditorState
*
state
=
GetEditorState
(
)
;
if
(
state
)
{
isCached
=
state
-
>
IsSelectionCached
(
)
&
&
state
-
>
HasNeverInitializedBefore
(
)
&
&
!
state
-
>
GetSelectionProperties
(
)
.
IsDefault
(
)
;
if
(
isCached
)
{
state
-
>
WillInitEagerly
(
)
;
}
}
return
isCached
;
}
void
HTMLInputElement
:
:
FieldSetDisabledChanged
(
bool
aNotify
)
{
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
nsGenericHTMLFormElementWithState
:
:
FieldSetDisabledChanged
(
aNotify
)
;
}
void
HTMLInputElement
:
:
SetFilePickerFiltersFromAccept
(
nsIFilePicker
*
filePicker
)
{
filePicker
-
>
AppendFilters
(
nsIFilePicker
:
:
filterAll
)
;
NS_ASSERTION
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accept
)
"
You
should
not
call
SetFilePickerFiltersFromAccept
if
the
"
"
element
has
no
accept
attribute
!
"
)
;
nsCOMPtr
<
nsIStringBundleService
>
stringService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
if
(
!
stringService
)
{
return
;
}
nsCOMPtr
<
nsIStringBundle
>
filterBundle
;
if
(
NS_FAILED
(
stringService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
content
/
filepicker
.
properties
"
getter_AddRefs
(
filterBundle
)
)
)
)
{
return
;
}
nsCOMPtr
<
nsIMIMEService
>
mimeService
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
!
mimeService
)
{
return
;
}
nsAutoString
accept
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accept
accept
)
;
HTMLSplitOnSpacesTokenizer
tokenizer
(
accept
'
'
)
;
nsTArray
<
nsFilePickerFilter
>
filters
;
nsString
allExtensionsList
;
bool
allMimeTypeFiltersAreValid
=
true
;
bool
atLeastOneFileExtensionFilter
=
false
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
const
nsDependentSubstring
&
token
=
tokenizer
.
nextToken
(
)
;
if
(
token
.
IsEmpty
(
)
)
{
continue
;
}
int32_t
filterMask
=
0
;
nsString
filterName
;
nsString
extensionListStr
;
if
(
token
.
EqualsLiteral
(
"
image
/
*
"
)
)
{
filterMask
=
nsIFilePicker
:
:
filterImages
;
filterBundle
-
>
GetStringFromName
(
u
"
imageFilter
"
getter_Copies
(
extensionListStr
)
)
;
}
else
if
(
token
.
EqualsLiteral
(
"
audio
/
*
"
)
)
{
filterMask
=
nsIFilePicker
:
:
filterAudio
;
filterBundle
-
>
GetStringFromName
(
u
"
audioFilter
"
getter_Copies
(
extensionListStr
)
)
;
}
else
if
(
token
.
EqualsLiteral
(
"
video
/
*
"
)
)
{
filterMask
=
nsIFilePicker
:
:
filterVideo
;
filterBundle
-
>
GetStringFromName
(
u
"
videoFilter
"
getter_Copies
(
extensionListStr
)
)
;
}
else
if
(
token
.
First
(
)
=
=
'
.
'
)
{
if
(
token
.
Contains
(
'
;
'
)
|
|
token
.
Contains
(
'
*
'
)
)
{
continue
;
}
extensionListStr
=
NS_LITERAL_STRING
(
"
*
"
)
+
token
;
filterName
=
extensionListStr
;
atLeastOneFileExtensionFilter
=
true
;
}
else
{
nsCOMPtr
<
nsIMIMEInfo
>
mimeInfo
;
if
(
NS_FAILED
(
mimeService
-
>
GetFromTypeAndExtension
(
NS_ConvertUTF16toUTF8
(
token
)
EmptyCString
(
)
getter_AddRefs
(
mimeInfo
)
)
)
|
|
!
mimeInfo
)
{
allMimeTypeFiltersAreValid
=
false
;
continue
;
}
mimeInfo
-
>
GetDescription
(
filterName
)
;
if
(
filterName
.
IsEmpty
(
)
)
{
nsCString
mimeTypeName
;
mimeInfo
-
>
GetType
(
mimeTypeName
)
;
CopyUTF8toUTF16
(
mimeTypeName
filterName
)
;
}
nsCOMPtr
<
nsIUTF8StringEnumerator
>
extensions
;
mimeInfo
-
>
GetFileExtensions
(
getter_AddRefs
(
extensions
)
)
;
bool
hasMore
;
while
(
NS_SUCCEEDED
(
extensions
-
>
HasMore
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCString
extension
;
if
(
NS_FAILED
(
extensions
-
>
GetNext
(
extension
)
)
)
{
continue
;
}
if
(
!
extensionListStr
.
IsEmpty
(
)
)
{
extensionListStr
.
AppendLiteral
(
"
;
"
)
;
}
extensionListStr
+
=
NS_LITERAL_STRING
(
"
*
.
"
)
+
NS_ConvertUTF8toUTF16
(
extension
)
;
}
}
if
(
!
filterMask
&
&
(
extensionListStr
.
IsEmpty
(
)
|
|
filterName
.
IsEmpty
(
)
)
)
{
allMimeTypeFiltersAreValid
=
false
;
continue
;
}
nsFilePickerFilter
filter
;
if
(
filterMask
)
{
filter
=
nsFilePickerFilter
(
filterMask
)
;
}
else
{
filter
=
nsFilePickerFilter
(
filterName
extensionListStr
)
;
}
if
(
!
filters
.
Contains
(
filter
)
)
{
if
(
!
allExtensionsList
.
IsEmpty
(
)
)
{
allExtensionsList
.
AppendLiteral
(
"
;
"
)
;
}
allExtensionsList
+
=
extensionListStr
;
filters
.
AppendElement
(
filter
)
;
}
}
nsTArray
<
nsFilePickerFilter
>
filtersCopy
;
filtersCopy
=
filters
;
for
(
uint32_t
i
=
0
;
i
<
filtersCopy
.
Length
(
)
;
+
+
i
)
{
const
nsFilePickerFilter
&
filterToCheck
=
filtersCopy
[
i
]
;
if
(
filterToCheck
.
mFilterMask
)
{
continue
;
}
for
(
uint32_t
j
=
0
;
j
<
filtersCopy
.
Length
(
)
;
+
+
j
)
{
if
(
i
=
=
j
)
{
continue
;
}
if
(
FindInReadable
(
filterToCheck
.
mFilter
+
NS_LITERAL_STRING
(
"
;
"
)
filtersCopy
[
j
]
.
mFilter
+
NS_LITERAL_STRING
(
"
;
"
)
)
)
{
filters
.
RemoveElement
(
filterToCheck
)
;
}
}
}
if
(
filters
.
Length
(
)
>
1
)
{
nsXPIDLString
title
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
AllSupportedTypes
"
title
)
;
filePicker
-
>
AppendFilter
(
title
allExtensionsList
)
;
}
for
(
uint32_t
i
=
0
;
i
<
filters
.
Length
(
)
;
+
+
i
)
{
const
nsFilePickerFilter
&
filter
=
filters
[
i
]
;
if
(
filter
.
mFilterMask
)
{
filePicker
-
>
AppendFilters
(
filter
.
mFilterMask
)
;
}
else
{
filePicker
-
>
AppendFilter
(
filter
.
mTitle
filter
.
mFilter
)
;
}
}
if
(
filters
.
Length
(
)
>
=
1
&
&
(
allMimeTypeFiltersAreValid
|
|
atLeastOneFileExtensionFilter
)
)
{
filePicker
-
>
SetFilterIndex
(
1
)
;
}
}
Decimal
HTMLInputElement
:
:
GetStepScaleFactor
(
)
const
{
MOZ_ASSERT
(
DoesStepApply
(
)
)
;
switch
(
mType
)
{
case
NS_FORM_INPUT_DATE
:
return
kStepScaleFactorDate
;
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_RANGE
:
return
kStepScaleFactorNumberRange
;
case
NS_FORM_INPUT_TIME
:
return
kStepScaleFactorTime
;
case
NS_FORM_INPUT_MONTH
:
return
kStepScaleFactorMonth
;
case
NS_FORM_INPUT_WEEK
:
return
kStepScaleFactorWeek
;
default
:
MOZ_ASSERT
(
false
"
Unrecognized
input
type
"
)
;
return
Decimal
:
:
nan
(
)
;
}
}
Decimal
HTMLInputElement
:
:
GetDefaultStep
(
)
const
{
MOZ_ASSERT
(
DoesStepApply
(
)
)
;
switch
(
mType
)
{
case
NS_FORM_INPUT_DATE
:
case
NS_FORM_INPUT_MONTH
:
case
NS_FORM_INPUT_WEEK
:
case
NS_FORM_INPUT_NUMBER
:
case
NS_FORM_INPUT_RANGE
:
return
kDefaultStep
;
case
NS_FORM_INPUT_TIME
:
return
kDefaultStepTime
;
default
:
MOZ_ASSERT
(
false
"
Unrecognized
input
type
"
)
;
return
Decimal
:
:
nan
(
)
;
}
}
void
HTMLInputElement
:
:
UpdateValidityUIBits
(
bool
aIsFocused
)
{
if
(
aIsFocused
)
{
mCanShowInvalidUI
=
!
IsValid
(
)
&
&
ShouldShowValidityUI
(
)
;
mCanShowValidUI
=
ShouldShowValidityUI
(
)
;
}
else
{
mCanShowInvalidUI
=
true
;
mCanShowValidUI
=
true
;
}
}
void
HTMLInputElement
:
:
UpdateHasRange
(
)
{
mHasRange
=
false
;
if
(
!
DoesMinMaxApply
(
)
|
|
mType
=
=
NS_FORM_INPUT_DATETIME_LOCAL
)
{
return
;
}
Decimal
minimum
=
GetMinimum
(
)
;
if
(
!
minimum
.
isNaN
(
)
)
{
mHasRange
=
true
;
return
;
}
Decimal
maximum
=
GetMaximum
(
)
;
if
(
!
maximum
.
isNaN
(
)
)
{
mHasRange
=
true
;
return
;
}
}
void
HTMLInputElement
:
:
PickerClosed
(
)
{
mPickerRunning
=
false
;
}
JSObject
*
HTMLInputElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLInputElementBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
HTMLInputElement
:
:
ClearGetFilesHelpers
(
)
{
if
(
mGetFilesRecursiveHelper
)
{
mGetFilesRecursiveHelper
-
>
Unlink
(
)
;
mGetFilesRecursiveHelper
=
nullptr
;
}
if
(
mGetFilesNonRecursiveHelper
)
{
mGetFilesNonRecursiveHelper
-
>
Unlink
(
)
;
mGetFilesNonRecursiveHelper
=
nullptr
;
}
}
GetFilesHelper
*
HTMLInputElement
:
:
GetOrCreateGetFilesHelper
(
bool
aRecursiveFlag
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
MOZ_ASSERT
(
global
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
aRecursiveFlag
)
{
if
(
!
mGetFilesRecursiveHelper
)
{
mGetFilesRecursiveHelper
=
GetFilesHelper
:
:
Create
(
global
GetFilesOrDirectoriesInternal
(
)
aRecursiveFlag
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
return
mGetFilesRecursiveHelper
;
}
if
(
!
mGetFilesNonRecursiveHelper
)
{
mGetFilesNonRecursiveHelper
=
GetFilesHelper
:
:
Create
(
global
GetFilesOrDirectoriesInternal
(
)
aRecursiveFlag
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
return
mGetFilesNonRecursiveHelper
;
}
void
HTMLInputElement
:
:
UpdateEntries
(
const
nsTArray
<
OwningFileOrDirectory
>
&
aFilesOrDirectories
)
{
MOZ_ASSERT
(
mEntries
.
IsEmpty
(
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
MOZ_ASSERT
(
global
)
;
RefPtr
<
FileSystem
>
fs
=
FileSystem
:
:
Create
(
global
)
;
if
(
NS_WARN_IF
(
!
fs
)
)
{
return
;
}
Sequence
<
RefPtr
<
FileSystemEntry
>
>
entries
;
for
(
uint32_t
i
=
0
;
i
<
aFilesOrDirectories
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
FileSystemEntry
>
entry
=
FileSystemEntry
:
:
Create
(
global
aFilesOrDirectories
[
i
]
fs
)
;
MOZ_ASSERT
(
entry
)
;
if
(
!
entries
.
AppendElement
(
entry
fallible
)
)
{
return
;
}
}
fs
-
>
CreateRoot
(
entries
)
;
mEntries
.
SwapElements
(
entries
)
;
}
void
HTMLInputElement
:
:
GetWebkitEntries
(
nsTArray
<
RefPtr
<
FileSystemEntry
>
>
&
aSequence
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BLINK_FILESYSTEM_USED
true
)
;
aSequence
.
AppendElements
(
mEntries
)
;
}
}
}
#
undef
NS_ORIGINAL_CHECKED_VALUE
