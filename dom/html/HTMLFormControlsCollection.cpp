#
include
"
mozilla
/
dom
/
HTMLFormControlsCollection
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormControlsCollectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
RadioNodeList
.
h
"
#
include
"
jsfriendapi
.
h
"
namespace
mozilla
:
:
dom
{
bool
HTMLFormControlsCollection
:
:
ShouldBeInElements
(
const
nsIFormControl
*
aFormControl
)
{
switch
(
aFormControl
-
>
ControlType
(
)
)
{
case
FormControlType
:
:
ButtonButton
:
case
FormControlType
:
:
ButtonReset
:
case
FormControlType
:
:
ButtonSubmit
:
case
FormControlType
:
:
InputButton
:
case
FormControlType
:
:
InputCheckbox
:
case
FormControlType
:
:
InputColor
:
case
FormControlType
:
:
InputEmail
:
case
FormControlType
:
:
InputFile
:
case
FormControlType
:
:
InputHidden
:
case
FormControlType
:
:
InputReset
:
case
FormControlType
:
:
InputPassword
:
case
FormControlType
:
:
InputRadio
:
case
FormControlType
:
:
InputSearch
:
case
FormControlType
:
:
InputSubmit
:
case
FormControlType
:
:
InputText
:
case
FormControlType
:
:
InputTel
:
case
FormControlType
:
:
InputUrl
:
case
FormControlType
:
:
InputNumber
:
case
FormControlType
:
:
InputRange
:
case
FormControlType
:
:
InputDate
:
case
FormControlType
:
:
InputTime
:
case
FormControlType
:
:
InputMonth
:
case
FormControlType
:
:
InputWeek
:
case
FormControlType
:
:
InputDatetimeLocal
:
case
FormControlType
:
:
Select
:
case
FormControlType
:
:
Textarea
:
case
FormControlType
:
:
Fieldset
:
case
FormControlType
:
:
Object
:
case
FormControlType
:
:
Output
:
case
FormControlType
:
:
FormAssociatedCustomElement
:
return
true
;
case
FormControlType
:
:
InputImage
:
break
;
}
return
false
;
}
HTMLFormControlsCollection
:
:
HTMLFormControlsCollection
(
HTMLFormElement
*
aForm
)
:
mForm
(
aForm
)
mNameLookupTable
(
HTMLFormElement
:
:
FORM_CONTROL_LIST_HASHTABLE_LENGTH
)
{
}
HTMLFormControlsCollection
:
:
~
HTMLFormControlsCollection
(
)
{
mForm
=
nullptr
;
Clear
(
)
;
}
void
HTMLFormControlsCollection
:
:
DropFormReference
(
)
{
mForm
=
nullptr
;
Clear
(
)
;
}
void
HTMLFormControlsCollection
:
:
Clear
(
)
{
for
(
nsGenericHTMLFormElement
*
element
:
Reversed
(
mElements
.
AsList
(
)
)
)
{
nsCOMPtr
<
nsIFormControl
>
formControl
=
nsIFormControl
:
:
FromNode
(
element
)
;
MOZ_ASSERT
(
formControl
)
;
formControl
-
>
ClearForm
(
false
false
)
;
}
mElements
.
Clear
(
)
;
for
(
nsGenericHTMLFormElement
*
element
:
Reversed
(
mNotInElements
.
AsList
(
)
)
)
{
nsCOMPtr
<
nsIFormControl
>
formControl
=
nsIFormControl
:
:
FromNode
(
element
)
;
MOZ_ASSERT
(
formControl
)
;
formControl
-
>
ClearForm
(
false
false
)
;
}
mNotInElements
.
Clear
(
)
;
mNameLookupTable
.
Clear
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLFormControlsCollection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
HTMLFormControlsCollection
)
tmp
-
>
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
HTMLFormControlsCollection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNameLookupTable
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
HTMLFormControlsCollection
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_INTERFACE_TABLE_HEAD
(
HTMLFormControlsCollection
)
NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY
NS_INTERFACE_TABLE
(
HTMLFormControlsCollection
nsIHTMLCollection
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
HTMLFormControlsCollection
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
HTMLFormControlsCollection
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
HTMLFormControlsCollection
)
uint32_t
HTMLFormControlsCollection
:
:
Length
(
)
{
return
mElements
-
>
Length
(
)
;
}
nsISupports
*
HTMLFormControlsCollection
:
:
NamedItemInternal
(
const
nsAString
&
aName
)
{
return
mNameLookupTable
.
GetWeak
(
aName
)
;
}
nsresult
HTMLFormControlsCollection
:
:
AddElementToTable
(
nsGenericHTMLFormElement
*
aChild
const
nsAString
&
aName
)
{
const
auto
*
formControl
=
nsIFormControl
:
:
FromNode
(
aChild
)
;
MOZ_ASSERT
(
formControl
)
;
if
(
!
ShouldBeInElements
(
formControl
)
)
{
return
NS_OK
;
}
return
mForm
-
>
AddElementToTableInternal
(
mNameLookupTable
aChild
aName
)
;
}
nsresult
HTMLFormControlsCollection
:
:
IndexOfContent
(
nsIContent
*
aContent
int32_t
*
aIndex
)
{
NS_ENSURE_ARG_POINTER
(
aIndex
)
;
*
aIndex
=
mElements
-
>
IndexOf
(
aContent
)
;
return
NS_OK
;
}
nsresult
HTMLFormControlsCollection
:
:
RemoveElementFromTable
(
nsGenericHTMLFormElement
*
aChild
const
nsAString
&
aName
)
{
const
auto
*
formControl
=
nsIFormControl
:
:
FromNode
(
aChild
)
;
MOZ_ASSERT
(
formControl
)
;
if
(
!
ShouldBeInElements
(
formControl
)
)
{
return
NS_OK
;
}
return
mForm
-
>
RemoveElementFromTableInternal
(
mNameLookupTable
aChild
aName
)
;
}
nsresult
HTMLFormControlsCollection
:
:
GetSortedControls
(
nsTArray
<
RefPtr
<
nsGenericHTMLFormElement
>
>
&
aControls
)
const
{
#
ifdef
DEBUG
HTMLFormElement
:
:
AssertDocumentOrder
(
mElements
mForm
)
;
HTMLFormElement
:
:
AssertDocumentOrder
(
mNotInElements
mForm
)
;
#
endif
aControls
.
Clear
(
)
;
uint32_t
elementsLen
=
mElements
-
>
Length
(
)
;
uint32_t
notInElementsLen
=
mNotInElements
-
>
Length
(
)
;
aControls
.
SetCapacity
(
elementsLen
+
notInElementsLen
)
;
uint32_t
elementsIdx
=
0
;
uint32_t
notInElementsIdx
=
0
;
while
(
elementsIdx
<
elementsLen
|
|
notInElementsIdx
<
notInElementsLen
)
{
if
(
elementsIdx
=
=
elementsLen
)
{
NS_ASSERTION
(
notInElementsIdx
<
notInElementsLen
"
Should
have
remaining
not
-
in
-
elements
"
)
;
aControls
.
AppendElements
(
mNotInElements
-
>
Elements
(
)
+
notInElementsIdx
notInElementsLen
-
notInElementsIdx
)
;
break
;
}
if
(
notInElementsIdx
=
=
notInElementsLen
)
{
NS_ASSERTION
(
elementsIdx
<
elementsLen
"
Should
have
remaining
in
-
elements
"
)
;
aControls
.
AppendElements
(
mElements
-
>
Elements
(
)
+
elementsIdx
elementsLen
-
elementsIdx
)
;
break
;
}
NS_ASSERTION
(
mElements
-
>
ElementAt
(
elementsIdx
)
&
&
mNotInElements
-
>
ElementAt
(
notInElementsIdx
)
"
Should
have
remaining
elements
"
)
;
nsGenericHTMLFormElement
*
elementToAdd
;
if
(
nsContentUtils
:
:
CompareTreePosition
<
TreeKind
:
:
DOM
>
(
mElements
-
>
ElementAt
(
elementsIdx
)
mNotInElements
-
>
ElementAt
(
notInElementsIdx
)
mForm
)
<
0
)
{
elementToAdd
=
mElements
-
>
ElementAt
(
elementsIdx
)
;
+
+
elementsIdx
;
}
else
{
elementToAdd
=
mNotInElements
-
>
ElementAt
(
notInElementsIdx
)
;
+
+
notInElementsIdx
;
}
aControls
.
AppendElement
(
elementToAdd
)
;
}
NS_ASSERTION
(
aControls
.
Length
(
)
=
=
elementsLen
+
notInElementsLen
"
Not
all
form
controls
were
added
to
the
sorted
list
"
)
;
#
ifdef
DEBUG
HTMLFormElement
:
:
AssertDocumentOrder
(
aControls
mForm
)
;
#
endif
return
NS_OK
;
}
Element
*
HTMLFormControlsCollection
:
:
GetElementAt
(
uint32_t
aIndex
)
{
return
mElements
-
>
SafeElementAt
(
aIndex
nullptr
)
;
}
nsINode
*
HTMLFormControlsCollection
:
:
GetParentObject
(
)
{
return
mForm
;
}
Element
*
HTMLFormControlsCollection
:
:
GetFirstNamedElement
(
const
nsAString
&
aName
bool
&
aFound
)
{
Nullable
<
OwningRadioNodeListOrElement
>
maybeResult
;
NamedGetter
(
aName
aFound
maybeResult
)
;
if
(
!
aFound
)
{
return
nullptr
;
}
MOZ_ASSERT
(
!
maybeResult
.
IsNull
(
)
)
;
const
OwningRadioNodeListOrElement
&
result
=
maybeResult
.
Value
(
)
;
if
(
result
.
IsElement
(
)
)
{
return
result
.
GetAsElement
(
)
.
get
(
)
;
}
if
(
result
.
IsRadioNodeList
(
)
)
{
RadioNodeList
&
nodelist
=
result
.
GetAsRadioNodeList
(
)
;
return
nodelist
.
Item
(
0
)
-
>
AsElement
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Should
only
have
Elements
and
NodeLists
here
.
"
)
;
return
nullptr
;
}
void
HTMLFormControlsCollection
:
:
NamedGetter
(
const
nsAString
&
aName
bool
&
aFound
Nullable
<
OwningRadioNodeListOrElement
>
&
aResult
)
{
nsISupports
*
item
=
NamedItemInternal
(
aName
)
;
if
(
!
item
)
{
aFound
=
false
;
return
;
}
aFound
=
true
;
if
(
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
item
)
)
{
aResult
.
SetValue
(
)
.
SetAsElement
(
)
=
element
;
return
;
}
if
(
nsCOMPtr
<
RadioNodeList
>
nodelist
=
do_QueryInterface
(
item
)
)
{
aResult
.
SetValue
(
)
.
SetAsRadioNodeList
(
)
=
nodelist
;
return
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Should
only
have
Elements
and
NodeLists
here
.
"
)
;
}
void
HTMLFormControlsCollection
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
{
AppendToArray
(
aNames
mNameLookupTable
.
Keys
(
)
)
;
}
JSObject
*
HTMLFormControlsCollection
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLFormControlsCollection_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
