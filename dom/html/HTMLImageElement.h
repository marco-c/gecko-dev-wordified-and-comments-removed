#
ifndef
mozilla_dom_HTMLImageElement_h
#
define
mozilla_dom_HTMLImageElement_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsImageLoadingContent
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
namespace
mozilla
{
class
EventChainPreVisitor
;
namespace
dom
{
class
ImageLoadTask
;
class
ResponsiveImageSelector
;
class
HTMLImageElement
final
:
public
nsGenericHTMLElement
public
nsImageLoadingContent
{
friend
class
HTMLSourceElement
;
friend
class
HTMLPictureElement
;
friend
class
ImageLoadTask
;
public
:
explicit
HTMLImageElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
;
static
already_AddRefed
<
HTMLImageElement
>
Image
(
const
GlobalObject
&
aGlobal
const
Optional
<
uint32_t
>
&
aWidth
const
Optional
<
uint32_t
>
&
aHeight
ErrorResult
&
aError
)
;
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLImageElement
nsGenericHTMLElement
)
NS_DECL_ISUPPORTS_INHERITED
virtual
bool
Draggable
(
)
const
override
;
ResponsiveImageSelector
*
GetResponsiveImageSelector
(
)
{
return
mResponsiveSelector
.
get
(
)
;
}
virtual
bool
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
override
;
virtual
void
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
override
;
NS_IMPL_FROMNODE_HTML_WITH_TAG
(
HTMLImageElement
img
)
CORSMode
GetCORSMode
(
)
override
;
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
virtual
nsChangeHint
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
override
;
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
override
;
virtual
nsMapRuleToAttributesFunc
GetAttributeMappingFunction
(
)
const
override
;
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
bool
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
override
;
virtual
nsresult
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
override
;
virtual
EventStates
IntrinsicState
(
)
const
override
;
virtual
nsresult
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
override
;
virtual
void
NodeInfoChanged
(
nsIDocument
*
aOldDoc
)
override
;
nsresult
CopyInnerTo
(
Element
*
aDest
bool
aPreallocateChildren
)
;
void
MaybeLoadImage
(
bool
aAlwaysForceLoad
)
;
NS_IMETHOD
GetNaturalHeight
(
uint32_t
*
aNaturalHeight
)
override
;
NS_IMETHOD
GetNaturalWidth
(
uint32_t
*
aNaturalWidth
)
override
;
bool
IsMap
(
)
{
return
GetBoolAttr
(
nsGkAtoms
:
:
ismap
)
;
}
void
SetIsMap
(
bool
aIsMap
ErrorResult
&
aError
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
ismap
aIsMap
aError
)
;
}
MOZ_CAN_RUN_SCRIPT
uint32_t
Width
(
)
{
return
GetWidthHeightForImage
(
mCurrentRequest
)
.
width
;
}
void
SetWidth
(
uint32_t
aWidth
ErrorResult
&
aError
)
{
SetUnsignedIntAttr
(
nsGkAtoms
:
:
width
aWidth
0
aError
)
;
}
MOZ_CAN_RUN_SCRIPT
uint32_t
Height
(
)
{
return
GetWidthHeightForImage
(
mCurrentRequest
)
.
height
;
}
void
SetHeight
(
uint32_t
aHeight
ErrorResult
&
aError
)
{
SetUnsignedIntAttr
(
nsGkAtoms
:
:
height
aHeight
0
aError
)
;
}
uint32_t
NaturalWidth
(
)
;
uint32_t
NaturalHeight
(
)
;
bool
Complete
(
)
;
uint32_t
Hspace
(
)
{
return
GetUnsignedIntAttr
(
nsGkAtoms
:
:
hspace
0
)
;
}
void
SetHspace
(
uint32_t
aHspace
ErrorResult
&
aError
)
{
SetUnsignedIntAttr
(
nsGkAtoms
:
:
hspace
aHspace
0
aError
)
;
}
uint32_t
Vspace
(
)
{
return
GetUnsignedIntAttr
(
nsGkAtoms
:
:
vspace
0
)
;
}
void
SetVspace
(
uint32_t
aVspace
ErrorResult
&
aError
)
{
SetUnsignedIntAttr
(
nsGkAtoms
:
:
vspace
aVspace
0
aError
)
;
}
void
GetAlt
(
nsAString
&
aAlt
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
alt
aAlt
)
;
}
void
SetAlt
(
const
nsAString
&
aAlt
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
alt
aAlt
aError
)
;
}
void
GetSrc
(
nsAString
&
aSrc
)
{
GetURIAttr
(
nsGkAtoms
:
:
src
nullptr
aSrc
)
;
}
void
SetSrc
(
const
nsAString
&
aSrc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aError
)
;
}
void
SetSrc
(
const
nsAString
&
aSrc
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aTriggeringPrincipal
aError
)
;
}
void
GetSrcset
(
nsAString
&
aSrcset
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
srcset
aSrcset
)
;
}
void
SetSrcset
(
const
nsAString
&
aSrcset
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
srcset
aSrcset
aTriggeringPrincipal
aError
)
;
}
void
GetCrossOrigin
(
nsAString
&
aResult
)
{
GetEnumAttr
(
nsGkAtoms
:
:
crossorigin
nullptr
aResult
)
;
}
void
SetCrossOrigin
(
const
nsAString
&
aCrossOrigin
ErrorResult
&
aError
)
{
SetOrRemoveNullableStringAttr
(
nsGkAtoms
:
:
crossorigin
aCrossOrigin
aError
)
;
}
void
GetUseMap
(
nsAString
&
aUseMap
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
usemap
aUseMap
)
;
}
void
SetUseMap
(
const
nsAString
&
aUseMap
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
usemap
aUseMap
aError
)
;
}
void
GetName
(
nsAString
&
aName
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
name
aName
)
;
}
void
SetName
(
const
nsAString
&
aName
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
name
aName
aError
)
;
}
void
GetAlign
(
nsAString
&
aAlign
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
align
aAlign
)
;
}
void
SetAlign
(
const
nsAString
&
aAlign
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
align
aAlign
aError
)
;
}
void
GetLongDesc
(
nsAString
&
aLongDesc
)
{
GetURIAttr
(
nsGkAtoms
:
:
longdesc
nullptr
aLongDesc
)
;
}
void
SetLongDesc
(
const
nsAString
&
aLongDesc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
longdesc
aLongDesc
aError
)
;
}
void
GetSizes
(
nsAString
&
aSizes
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
sizes
aSizes
)
;
}
void
SetSizes
(
const
nsAString
&
aSizes
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
sizes
aSizes
aError
)
;
}
void
GetCurrentSrc
(
nsAString
&
aValue
)
;
void
GetBorder
(
nsAString
&
aBorder
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
border
aBorder
)
;
}
void
SetBorder
(
const
nsAString
&
aBorder
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
border
aBorder
aError
)
;
}
void
SetReferrerPolicy
(
const
nsAString
&
aReferrer
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
referrerpolicy
aReferrer
aError
)
;
}
void
GetReferrerPolicy
(
nsAString
&
aReferrer
)
{
GetEnumAttr
(
nsGkAtoms
:
:
referrerpolicy
EmptyCString
(
)
.
get
(
)
aReferrer
)
;
}
net
:
:
ReferrerPolicy
GetImageReferrerPolicy
(
)
override
{
return
GetReferrerPolicyAsEnum
(
)
;
}
MOZ_CAN_RUN_SCRIPT
int32_t
X
(
)
;
MOZ_CAN_RUN_SCRIPT
int32_t
Y
(
)
;
void
GetLowsrc
(
nsAString
&
aLowsrc
)
{
GetURIAttr
(
nsGkAtoms
:
:
lowsrc
nullptr
aLowsrc
)
;
}
void
SetLowsrc
(
const
nsAString
&
aLowsrc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
lowsrc
aLowsrc
aError
)
;
}
#
ifdef
DEBUG
HTMLFormElement
*
GetForm
(
)
const
;
#
endif
void
SetForm
(
HTMLFormElement
*
aForm
)
;
void
ClearForm
(
bool
aRemoveFromForm
)
;
virtual
void
DestroyContent
(
)
override
;
void
MediaFeatureValuesChanged
(
)
;
static
bool
SelectSourceForTagWithAttrs
(
nsIDocument
*
aDocument
bool
aIsSourceTag
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
nsAString
&
aResult
)
;
void
FlushUseCounters
(
)
;
protected
:
virtual
~
HTMLImageElement
(
)
;
void
QueueImageLoadTask
(
bool
aAlwaysLoad
)
;
bool
HaveSrcsetOrInPicture
(
)
;
bool
InResponsiveMode
(
)
;
bool
SelectedSourceMatchesLast
(
nsIURI
*
aSelectedSource
)
;
nsresult
LoadSelectedImage
(
bool
aForce
bool
aNotify
bool
aAlwaysLoad
)
;
static
bool
SupportedPictureSourceType
(
const
nsAString
&
aType
)
;
void
PictureSourceSrcsetChanged
(
nsIContent
*
aSourceNode
const
nsAString
&
aNewValue
bool
aNotify
)
;
void
PictureSourceSizesChanged
(
nsIContent
*
aSourceNode
const
nsAString
&
aNewValue
bool
aNotify
)
;
void
PictureSourceMediaOrTypeChanged
(
nsIContent
*
aSourceNode
bool
aNotify
)
;
void
PictureSourceAdded
(
nsIContent
*
aSourceNode
)
;
void
PictureSourceRemoved
(
nsIContent
*
aSourceNode
)
;
bool
UpdateResponsiveSource
(
)
;
bool
TryCreateResponsiveSelector
(
Element
*
aSourceElement
)
;
MOZ_CAN_RUN_SCRIPT
CSSIntPoint
GetXY
(
)
;
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
UpdateFormOwner
(
)
;
virtual
nsresult
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
override
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
nsresult
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
override
;
nsIContent
*
AsContent
(
)
override
{
return
this
;
}
HTMLFormElement
*
mForm
;
RefPtr
<
ResponsiveImageSelector
>
mResponsiveSelector
;
private
:
bool
SourceElementMatches
(
Element
*
aSourceElement
)
;
static
void
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
)
;
void
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aValueMaybeChanged
bool
aNotify
)
;
bool
mInDocResponsiveContent
;
RefPtr
<
ImageLoadTask
>
mPendingImageLoadTask
;
nsCOMPtr
<
nsIPrincipal
>
mSrcTriggeringPrincipal
;
nsCOMPtr
<
nsIPrincipal
>
mSrcsetTriggeringPrincipal
;
nsCOMPtr
<
nsIURI
>
mLastSelectedSource
;
double
mCurrentDensity
;
}
;
}
}
#
endif
