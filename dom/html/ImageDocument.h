#
ifndef
mozilla_dom_ImageDocument_h
#
define
mozilla_dom_ImageDocument_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
mozilla
/
dom
/
MediaDocument
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
namespace
mozilla
{
enum
class
StyleImageRendering
:
uint8_t
;
struct
IntrinsicSize
;
}
namespace
mozilla
:
:
dom
{
class
HTMLImageElement
;
class
ImageDocument
final
:
public
MediaDocument
public
imgINotificationObserver
public
nsIDOMEventListener
{
public
:
ImageDocument
(
)
;
NS_DECL_ISUPPORTS_INHERITED
enum
MediaDocumentKind
MediaDocumentKind
(
)
const
override
{
return
MediaDocumentKind
:
:
Image
;
}
nsresult
Init
(
)
override
;
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
=
true
)
override
;
void
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
)
override
;
void
Destroy
(
)
override
;
void
OnPageShow
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
=
false
)
override
;
NS_DECL_IMGINOTIFICATIONOBSERVER
NS_DECL_NSIDOMEVENTLISTENER
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
ImageDocument
MediaDocument
)
friend
class
ImageListener
;
void
DefaultCheckOverflowing
(
)
;
JSObject
*
WrapNode
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
bool
ImageIsOverflowing
(
)
const
{
return
ImageIsOverflowingHorizontally
(
)
|
|
ImageIsOverflowingVertically
(
)
;
}
bool
ImageIsOverflowingVertically
(
)
const
{
return
mImageHeight
>
mVisibleHeight
;
}
bool
ImageIsOverflowingHorizontally
(
)
const
{
return
mImageWidth
>
mVisibleWidth
;
}
bool
ImageIsResized
(
)
const
{
return
mImageIsResized
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
ShrinkToFit
(
)
;
void
RestoreImage
(
)
;
void
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
override
;
void
UpdateRemoteStyle
(
StyleImageRendering
aImageRendering
)
;
protected
:
virtual
~
ImageDocument
(
)
;
nsresult
CreateSyntheticDocument
(
)
override
;
nsresult
CheckOverflowing
(
bool
changeState
)
;
void
UpdateTitleAndCharset
(
)
;
void
ScrollImageTo
(
int32_t
aX
int32_t
aY
)
;
float
GetRatio
(
)
const
{
return
std
:
:
min
(
mVisibleWidth
/
mImageWidth
mVisibleHeight
/
mImageHeight
)
;
}
void
ResetZoomLevel
(
)
;
float
GetZoomLevel
(
)
;
float
GetResolution
(
)
;
void
UpdateSizeFromLayout
(
)
;
enum
eModeClasses
{
eNone
eShrinkToFit
eOverflowingVertical
eOverflowingHorizontalOnly
eIsInObjectOrEmbed
}
;
void
SetModeClass
(
eModeClasses
mode
)
;
void
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
;
void
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
OnHasTransparency
(
)
;
void
MaybeSendResultToEmbedder
(
nsresult
aResult
)
;
RefPtr
<
HTMLImageElement
>
mImageContent
;
float
mVisibleWidth
;
float
mVisibleHeight
;
int32_t
mImageWidth
;
int32_t
mImageHeight
;
bool
mImageIsResized
;
bool
mShouldResize
;
bool
mFirstResize
;
bool
mObservingImageLoader
;
bool
mTitleUpdateInProgress
;
bool
mHasCustomTitle
;
bool
mIsInObjectOrEmbed
;
float
mOriginalZoomLevel
;
float
mOriginalResolution
;
}
;
inline
ImageDocument
*
Document
:
:
AsImageDocument
(
)
{
MOZ_ASSERT
(
IsImageDocument
(
)
)
;
return
static_cast
<
ImageDocument
*
>
(
this
)
;
}
inline
const
ImageDocument
*
Document
:
:
AsImageDocument
(
)
const
{
MOZ_ASSERT
(
IsImageDocument
(
)
)
;
return
static_cast
<
const
ImageDocument
*
>
(
this
)
;
}
}
#
endif
