#
ifndef
mozilla_dom_ImageDocument_h
#
define
mozilla_dom_ImageDocument_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
MediaDocument
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ImageDocument
final
:
public
MediaDocument
public
imgINotificationObserver
public
nsIDOMEventListener
{
public
:
ImageDocument
(
)
;
NS_DECL_ISUPPORTS_INHERITED
enum
MediaDocumentKind
MediaDocumentKind
(
)
const
override
{
return
MediaDocumentKind
:
:
Image
;
}
virtual
nsresult
Init
(
)
override
;
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
=
true
nsIContentSink
*
aSink
=
nullptr
)
override
;
virtual
void
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aScriptGlobalObject
)
override
;
virtual
void
Destroy
(
)
override
;
virtual
void
OnPageShow
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
=
false
)
override
;
NS_DECL_IMGINOTIFICATIONOBSERVER
NS_DECL_NSIDOMEVENTLISTENER
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
ImageDocument
MediaDocument
)
friend
class
ImageListener
;
void
DefaultCheckOverflowing
(
)
{
CheckOverflowing
(
mResizeImageByDefault
)
;
}
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
bool
ImageIsOverflowing
(
)
const
{
return
mImageIsOverflowingHorizontally
|
|
mImageIsOverflowingVertically
;
}
bool
ImageIsResized
(
)
const
{
return
mImageIsResized
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
ShrinkToFit
(
)
;
void
RestoreImage
(
)
;
void
RestoreImageTo
(
int32_t
aX
int32_t
aY
)
{
ScrollImageTo
(
aX
aY
true
)
;
}
virtual
void
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
override
;
protected
:
virtual
~
ImageDocument
(
)
;
virtual
nsresult
CreateSyntheticDocument
(
)
override
;
nsresult
CheckOverflowing
(
bool
changeState
)
;
void
UpdateTitleAndCharset
(
)
;
void
ScrollImageTo
(
int32_t
aX
int32_t
aY
bool
restoreImage
)
;
float
GetRatio
(
)
{
return
std
:
:
min
(
mVisibleWidth
/
mImageWidth
mVisibleHeight
/
mImageHeight
)
;
}
void
ResetZoomLevel
(
)
;
float
GetZoomLevel
(
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
float
GetResolution
(
)
;
#
endif
void
UpdateSizeFromLayout
(
)
;
enum
eModeClasses
{
eNone
eShrinkToFit
eOverflowingVertical
eOverflowingHorizontalOnly
}
;
void
SetModeClass
(
eModeClasses
mode
)
;
void
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
;
void
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
OnHasTransparency
(
)
;
nsCOMPtr
<
Element
>
mImageContent
;
float
mVisibleWidth
;
float
mVisibleHeight
;
int32_t
mImageWidth
;
int32_t
mImageHeight
;
bool
mResizeImageByDefault
;
bool
mClickResizingEnabled
;
bool
mImageIsOverflowingHorizontally
;
bool
mImageIsOverflowingVertically
;
bool
mImageIsResized
;
bool
mShouldResize
;
bool
mFirstResize
;
bool
mObservingImageLoader
;
bool
mTitleUpdateInProgress
;
bool
mHasCustomTitle
;
float
mOriginalZoomLevel
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
float
mOriginalResolution
;
#
endif
}
;
}
}
#
endif
