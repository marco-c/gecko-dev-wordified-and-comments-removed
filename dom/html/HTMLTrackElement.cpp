#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTrackElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTrackElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLUnknownElement
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
WebVTTListener
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsIDOMHTMLMediaElement
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsRuleData
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsVideoFrame
.
h
"
static
mozilla
:
:
LazyLogModule
gTrackElementLog
(
"
nsTrackElement
"
)
;
#
define
LOG
(
type
msg
)
MOZ_LOG
(
gTrackElementLog
type
msg
)
nsGenericHTMLElement
*
NS_NewHTMLTrackElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
return
new
mozilla
:
:
dom
:
:
HTMLTrackElement
(
aNodeInfo
)
;
}
namespace
mozilla
{
namespace
dom
{
static
constexpr
nsAttrValue
:
:
EnumTable
kKindTable
[
]
=
{
{
"
subtitles
"
static_cast
<
int16_t
>
(
TextTrackKind
:
:
Subtitles
)
}
{
"
captions
"
static_cast
<
int16_t
>
(
TextTrackKind
:
:
Captions
)
}
{
"
descriptions
"
static_cast
<
int16_t
>
(
TextTrackKind
:
:
Descriptions
)
}
{
"
chapters
"
static_cast
<
int16_t
>
(
TextTrackKind
:
:
Chapters
)
}
{
"
metadata
"
static_cast
<
int16_t
>
(
TextTrackKind
:
:
Metadata
)
}
{
nullptr
0
}
}
;
static
constexpr
const
nsAttrValue
:
:
EnumTable
*
kKindTableInvalidValueDefault
=
&
kKindTable
[
4
]
;
class
WindowDestroyObserver
final
:
public
nsIObserver
{
NS_DECL_ISUPPORTS
public
:
explicit
WindowDestroyObserver
(
HTMLTrackElement
*
aElement
uint64_t
aWinID
)
:
mTrackElement
(
aElement
)
mInnerID
(
aWinID
)
{
RegisterWindowDestroyObserver
(
)
;
}
void
RegisterWindowDestroyObserver
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
inner
-
window
-
destroyed
"
false
)
;
}
}
void
UnRegisterWindowDestroyObserver
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
}
mTrackElement
=
nullptr
;
}
NS_IMETHODIMP
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
strcmp
(
aTopic
"
inner
-
window
-
destroyed
"
)
=
=
0
)
{
nsCOMPtr
<
nsISupportsPRUint64
>
wrapper
=
do_QueryInterface
(
aSubject
)
;
NS_ENSURE_TRUE
(
wrapper
NS_ERROR_FAILURE
)
;
uint64_t
innerID
;
nsresult
rv
=
wrapper
-
>
GetData
(
&
innerID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
innerID
=
=
mInnerID
)
{
if
(
mTrackElement
)
{
mTrackElement
-
>
NotifyShutdown
(
)
;
}
UnRegisterWindowDestroyObserver
(
)
;
}
}
return
NS_OK
;
}
private
:
~
WindowDestroyObserver
(
)
{
}
;
HTMLTrackElement
*
mTrackElement
;
uint64_t
mInnerID
;
}
;
NS_IMPL_ISUPPORTS
(
WindowDestroyObserver
nsIObserver
)
;
HTMLTrackElement
:
:
HTMLTrackElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsGenericHTMLElement
(
aNodeInfo
)
mLoadResourceDispatched
(
false
)
mWindowDestroyObserver
(
nullptr
)
{
nsISupports
*
parentObject
=
OwnerDoc
(
)
-
>
GetParentObject
(
)
;
NS_ENSURE_TRUE_VOID
(
parentObject
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
parentObject
)
;
if
(
window
)
{
mWindowDestroyObserver
=
new
WindowDestroyObserver
(
this
window
-
>
WindowID
(
)
)
;
}
}
HTMLTrackElement
:
:
~
HTMLTrackElement
(
)
{
if
(
mWindowDestroyObserver
)
{
mWindowDestroyObserver
-
>
UnRegisterWindowDestroyObserver
(
)
;
}
NotifyShutdown
(
)
;
}
NS_IMPL_ELEMENT_CLONE
(
HTMLTrackElement
)
NS_IMPL_ADDREF_INHERITED
(
HTMLTrackElement
Element
)
NS_IMPL_RELEASE_INHERITED
(
HTMLTrackElement
Element
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLTrackElement
nsGenericHTMLElement
mTrack
mMediaParent
mListener
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
HTMLTrackElement
)
NS_INTERFACE_MAP_END_INHERITING
(
nsGenericHTMLElement
)
void
HTMLTrackElement
:
:
GetKind
(
DOMString
&
aKind
)
const
{
GetEnumAttr
(
nsGkAtoms
:
:
kind
kKindTable
[
0
]
.
tag
aKind
)
;
}
void
HTMLTrackElement
:
:
OnChannelRedirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
{
NS_ASSERTION
(
aChannel
=
=
mChannel
"
Channels
should
match
!
"
)
;
mChannel
=
aNewChannel
;
}
JSObject
*
HTMLTrackElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLTrackElementBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
TextTrack
*
HTMLTrackElement
:
:
GetTrack
(
)
{
if
(
!
mTrack
)
{
CreateTextTrack
(
)
;
}
return
mTrack
;
}
void
HTMLTrackElement
:
:
CreateTextTrack
(
)
{
nsString
label
srcLang
;
GetSrclang
(
srcLang
)
;
GetLabel
(
label
)
;
TextTrackKind
kind
;
if
(
const
nsAttrValue
*
value
=
GetParsedAttr
(
nsGkAtoms
:
:
kind
)
)
{
kind
=
static_cast
<
TextTrackKind
>
(
value
-
>
GetEnumValue
(
)
)
;
}
else
{
kind
=
TextTrackKind
:
:
Subtitles
;
}
nsISupports
*
parentObject
=
OwnerDoc
(
)
-
>
GetParentObject
(
)
;
NS_ENSURE_TRUE_VOID
(
parentObject
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
parentObject
)
;
mTrack
=
new
TextTrack
(
window
kind
label
srcLang
TextTrackMode
:
:
Disabled
TextTrackReadyState
:
:
NotLoaded
TextTrackSource
:
:
Track
)
;
mTrack
-
>
SetTrackElement
(
this
)
;
if
(
mMediaParent
)
{
mMediaParent
-
>
AddTextTrack
(
mTrack
)
;
}
}
bool
HTMLTrackElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsIAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
kind
)
{
return
aResult
.
ParseEnumValue
(
aValue
kKindTable
false
kKindTableInvalidValueDefault
)
;
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aResult
)
;
}
void
HTMLTrackElement
:
:
SetSrc
(
const
nsAString
&
aSrc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aError
)
;
uint16_t
oldReadyState
=
ReadyState
(
)
;
SetReadyState
(
TextTrackReadyState
:
:
NotLoaded
)
;
if
(
!
mMediaParent
)
{
return
;
}
if
(
mTrack
&
&
(
oldReadyState
!
=
TextTrackReadyState
:
:
NotLoaded
)
)
{
mMediaParent
-
>
RemoveTextTrack
(
mTrack
)
;
CreateTextTrack
(
)
;
}
mListener
=
nullptr
;
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mChannel
=
nullptr
;
}
DispatchLoadResource
(
)
;
}
void
HTMLTrackElement
:
:
DispatchLoadResource
(
)
{
if
(
!
mLoadResourceDispatched
)
{
RefPtr
<
Runnable
>
r
=
NewRunnableMethod
(
this
&
HTMLTrackElement
:
:
LoadResource
)
;
nsContentUtils
:
:
RunInStableState
(
r
.
forget
(
)
)
;
mLoadResourceDispatched
=
true
;
}
}
void
HTMLTrackElement
:
:
LoadResource
(
)
{
mLoadResourceDispatched
=
false
;
nsAutoString
src
;
if
(
!
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NewURIFromString
(
src
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_TRUE_VOID
(
NS_SUCCEEDED
(
rv
)
)
;
LOG
(
LogLevel
:
:
Info
(
"
%
p
Trying
to
load
from
src
=
%
s
"
this
NS_ConvertUTF16toUTF8
(
src
)
.
get
(
)
)
)
;
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mChannel
=
nullptr
;
}
CORSMode
corsMode
=
mMediaParent
?
mMediaParent
-
>
GetCORSMode
(
)
:
CORS_NONE
;
nsSecurityFlags
secFlags
;
if
(
CORS_NONE
=
=
corsMode
)
{
secFlags
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
;
}
else
{
secFlags
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
CORS_ANONYMOUS
=
=
corsMode
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
CORS_USE_CREDENTIALS
=
=
corsMode
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
else
{
NS_WARNING
(
"
Unknown
CORS
mode
.
"
)
;
secFlags
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
OwnerDoc
(
)
-
>
GetDocumentLoadGroup
(
)
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
static_cast
<
Element
*
>
(
this
)
secFlags
nsIContentPolicy
:
:
TYPE_INTERNAL_TRACK
loadGroup
nullptr
nsIRequest
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
)
;
NS_ENSURE_TRUE_VOID
(
NS_SUCCEEDED
(
rv
)
)
;
mListener
=
new
WebVTTListener
(
this
)
;
rv
=
mListener
-
>
LoadResource
(
)
;
NS_ENSURE_TRUE_VOID
(
NS_SUCCEEDED
(
rv
)
)
;
channel
-
>
SetNotificationCallbacks
(
mListener
)
;
LOG
(
LogLevel
:
:
Debug
(
"
opening
webvtt
channel
"
)
)
;
rv
=
channel
-
>
AsyncOpen2
(
mListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
SetReadyState
(
TextTrackReadyState
:
:
FailedToLoad
)
;
return
;
}
mChannel
=
channel
;
}
nsresult
HTMLTrackElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
bool
aCompileEventHandlers
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
aCompileEventHandlers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Track
Element
bound
to
tree
.
"
)
)
;
if
(
!
aParent
|
|
!
aParent
-
>
IsNodeOfType
(
nsINode
:
:
eMEDIA
)
)
{
return
NS_OK
;
}
if
(
!
mMediaParent
)
{
mMediaParent
=
static_cast
<
HTMLMediaElement
*
>
(
aParent
)
;
mMediaParent
-
>
NotifyAddedSource
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Track
element
sent
notification
to
parent
.
"
)
)
;
if
(
!
mTrack
)
{
CreateTextTrack
(
)
;
}
DispatchLoadResource
(
)
;
}
return
NS_OK
;
}
void
HTMLTrackElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
if
(
mMediaParent
&
&
aNullParent
)
{
if
(
mTrack
)
{
mMediaParent
-
>
RemoveTextTrack
(
mTrack
)
;
mMediaParent
-
>
UpdateReadyState
(
)
;
}
mMediaParent
=
nullptr
;
}
nsGenericHTMLElement
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
}
uint16_t
HTMLTrackElement
:
:
ReadyState
(
)
const
{
if
(
!
mTrack
)
{
return
TextTrackReadyState
:
:
NotLoaded
;
}
return
mTrack
-
>
ReadyState
(
)
;
}
void
HTMLTrackElement
:
:
SetReadyState
(
uint16_t
aReadyState
)
{
if
(
ReadyState
(
)
=
=
aReadyState
)
{
return
;
}
if
(
mTrack
)
{
switch
(
aReadyState
)
{
case
TextTrackReadyState
:
:
Loaded
:
DispatchTrackRunnable
(
NS_LITERAL_STRING
(
"
load
"
)
)
;
break
;
case
TextTrackReadyState
:
:
FailedToLoad
:
DispatchTrackRunnable
(
NS_LITERAL_STRING
(
"
error
"
)
)
;
break
;
}
mTrack
-
>
SetReadyState
(
aReadyState
)
;
}
}
void
HTMLTrackElement
:
:
DispatchTrackRunnable
(
const
nsString
&
aEventName
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
<
const
nsString
>
(
this
&
HTMLTrackElement
:
:
DispatchTrustedEvent
aEventName
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
void
HTMLTrackElement
:
:
DispatchTrustedEvent
(
const
nsAString
&
aName
)
{
nsIDocument
*
doc
=
OwnerDoc
(
)
;
if
(
!
doc
)
{
return
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
doc
static_cast
<
nsIContent
*
>
(
this
)
aName
false
false
)
;
}
void
HTMLTrackElement
:
:
DropChannel
(
)
{
mChannel
=
nullptr
;
}
void
HTMLTrackElement
:
:
NotifyShutdown
(
)
{
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
mChannel
=
nullptr
;
mListener
=
nullptr
;
}
}
}
