#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormSubmission
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElementBinding
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsIConstraintValidation
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIFormControlFrame
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIForm
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLinebreakConverter
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTextEditorState
.
h
"
#
include
"
nsIController
.
h
"
static
NS_DEFINE_CID
(
kXULControllersCID
NS_XULCONTROLLERS_CID
)
;
#
define
NS_NO_CONTENT_DISPATCH
(
1
<
<
0
)
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
TextArea
)
namespace
mozilla
{
namespace
dom
{
HTMLTextAreaElement
:
:
HTMLTextAreaElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFormElementWithState
(
aNodeInfo
NS_FORM_TEXTAREA
)
mValueChanged
(
false
)
mLastValueChangeWasInteractive
(
false
)
mHandlingSelect
(
false
)
mDoneAddingChildren
(
!
aFromParser
)
mInhibitStateRestoration
(
!
!
(
aFromParser
&
FROM_PARSER_FRAGMENT
)
)
mDisabledChanged
(
false
)
mCanShowInvalidUI
(
true
)
mCanShowValidUI
(
true
)
mIsPreviewEnabled
(
false
)
mAutocompleteAttrState
(
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
)
mState
(
this
)
{
AddMutationObserver
(
this
)
;
AddStatesSilently
(
NS_EVENT_STATE_ENABLED
|
NS_EVENT_STATE_OPTIONAL
|
NS_EVENT_STATE_VALID
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLTextAreaElement
nsGenericHTMLFormElementWithState
mValidity
mControllers
mState
)
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLTextAreaElement
nsGenericHTMLFormElementWithState
nsITextControlElement
nsIMutationObserver
nsIConstraintValidation
)
nsresult
HTMLTextAreaElement
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
{
*
aResult
=
nullptr
;
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
(
aNodeInfo
)
.
forget
(
)
;
RefPtr
<
HTMLTextAreaElement
>
it
=
new
HTMLTextAreaElement
(
ni
)
;
nsresult
rv
=
const_cast
<
HTMLTextAreaElement
*
>
(
this
)
-
>
CopyInnerTo
(
it
aPreallocateChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mValueChanged
)
{
nsAutoString
value
;
GetValueInternal
(
value
true
)
;
rv
=
it
-
>
SetValueInternal
(
value
nsTextEditorState
:
:
eSetValue_Notify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
it
-
>
mLastValueChangeWasInteractive
=
mLastValueChangeWasInteractive
;
it
.
forget
(
aResult
)
;
return
NS_OK
;
}
void
HTMLTextAreaElement
:
:
Select
(
)
{
FocusTristate
state
=
FocusState
(
)
;
if
(
state
=
=
eUnfocusable
)
{
return
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
eForComposedDoc
)
;
if
(
state
=
=
eInactiveWindow
)
{
if
(
fm
)
fm
-
>
SetFocus
(
this
nsIFocusManager
:
:
FLAG_NOSCROLL
)
;
SelectAll
(
presContext
)
;
return
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetGUIEvent
event
(
true
eFormSelect
nullptr
)
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
presContext
&
event
nullptr
&
status
)
;
if
(
status
=
=
nsEventStatus_eIgnore
)
{
if
(
fm
)
{
fm
-
>
SetFocus
(
this
nsIFocusManager
:
:
FLAG_NOSCROLL
)
;
if
(
this
=
=
fm
-
>
GetFocusedElement
(
)
)
{
SelectAll
(
presContext
)
;
}
}
}
}
NS_IMETHODIMP
HTMLTextAreaElement
:
:
SelectAll
(
nsPresContext
*
aPresContext
)
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
if
(
formControlFrame
)
{
formControlFrame
-
>
SetFormProperty
(
nsGkAtoms
:
:
select
EmptyString
(
)
)
;
}
return
NS_OK
;
}
bool
HTMLTextAreaElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
nsGenericHTMLFormElementWithState
:
:
IsHTMLFocusable
(
aWithMouse
aIsFocusable
aTabIndex
)
)
{
return
true
;
}
*
aIsFocusable
=
!
IsDisabled
(
)
;
return
false
;
}
int32_t
HTMLTextAreaElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
void
HTMLTextAreaElement
:
:
GetType
(
nsAString
&
aType
)
{
aType
.
AssignLiteral
(
"
textarea
"
)
;
}
void
HTMLTextAreaElement
:
:
GetValue
(
nsAString
&
aValue
)
{
nsAutoString
value
;
GetValueInternal
(
value
true
)
;
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
value
)
;
aValue
=
value
;
}
void
HTMLTextAreaElement
:
:
GetValueInternal
(
nsAString
&
aValue
bool
aIgnoreWrap
)
const
{
mState
.
GetValue
(
aValue
aIgnoreWrap
)
;
}
NS_IMETHODIMP_
(
TextEditor
*
)
HTMLTextAreaElement
:
:
GetTextEditor
(
)
{
return
mState
.
GetTextEditor
(
)
;
}
NS_IMETHODIMP_
(
nsISelectionController
*
)
HTMLTextAreaElement
:
:
GetSelectionController
(
)
{
return
mState
.
GetSelectionController
(
)
;
}
NS_IMETHODIMP_
(
nsFrameSelection
*
)
HTMLTextAreaElement
:
:
GetConstFrameSelection
(
)
{
return
mState
.
GetConstFrameSelection
(
)
;
}
NS_IMETHODIMP
HTMLTextAreaElement
:
:
BindToFrame
(
nsTextControlFrame
*
aFrame
)
{
return
mState
.
BindToFrame
(
aFrame
)
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
UnbindFromFrame
(
nsTextControlFrame
*
aFrame
)
{
if
(
aFrame
)
{
mState
.
UnbindFromFrame
(
aFrame
)
;
}
}
NS_IMETHODIMP
HTMLTextAreaElement
:
:
CreateEditor
(
)
{
return
mState
.
PrepareEditor
(
)
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
UpdateOverlayTextVisibility
(
bool
aNotify
)
{
mState
.
UpdateOverlayTextVisibility
(
aNotify
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
GetPlaceholderVisibility
(
)
{
return
mState
.
GetPlaceholderVisibility
(
)
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
SetPreviewValue
(
const
nsAString
&
aValue
)
{
mState
.
SetPreviewText
(
aValue
true
)
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
GetPreviewValue
(
nsAString
&
aValue
)
{
mState
.
GetPreviewText
(
aValue
)
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
EnablePreview
(
)
{
if
(
mIsPreviewEnabled
)
{
return
;
}
mIsPreviewEnabled
=
true
;
nsLayoutUtils
:
:
PostRestyleEvent
(
this
nsRestyleHint
(
0
)
nsChangeHint_ReconstructFrame
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
IsPreviewEnabled
(
)
{
return
mIsPreviewEnabled
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
GetPreviewVisibility
(
)
{
return
mState
.
GetPreviewVisibility
(
)
;
}
nsresult
HTMLTextAreaElement
:
:
SetValueInternal
(
const
nsAString
&
aValue
uint32_t
aFlags
)
{
if
(
aFlags
&
nsTextEditorState
:
:
eSetValue_Notify
)
{
SetValueChanged
(
true
)
;
}
if
(
!
mState
.
SetValue
(
aValue
aFlags
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
HTMLTextAreaElement
:
:
SetValue
(
const
nsAString
&
aValue
ErrorResult
&
aError
)
{
nsAutoString
currentValue
;
GetValueInternal
(
currentValue
true
)
;
nsresult
rv
=
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_ByContent
|
nsTextEditorState
:
:
eSetValue_Notify
|
nsTextEditorState
:
:
eSetValue_MoveCursorToEndIfValueChanged
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
if
(
mFocusedValue
.
Equals
(
currentValue
)
)
{
GetValueInternal
(
mFocusedValue
true
)
;
}
}
void
HTMLTextAreaElement
:
:
SetUserInput
(
const
nsAString
&
aValue
nsIPrincipal
&
aSubjectPrincipal
)
{
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_BySetUserInput
|
nsTextEditorState
:
:
eSetValue_Notify
|
nsTextEditorState
:
:
eSetValue_MoveCursorToEndIfValueChanged
)
;
}
NS_IMETHODIMP
HTMLTextAreaElement
:
:
SetValueChanged
(
bool
aValueChanged
)
{
bool
previousValue
=
mValueChanged
;
mValueChanged
=
aValueChanged
;
if
(
!
aValueChanged
&
&
!
mState
.
IsEmpty
(
)
)
{
mState
.
EmptyValue
(
)
;
}
if
(
mValueChanged
!
=
previousValue
)
{
UpdateState
(
true
)
;
}
return
NS_OK
;
}
void
HTMLTextAreaElement
:
:
GetDefaultValue
(
nsAString
&
aDefaultValue
ErrorResult
&
aError
)
{
if
(
!
nsContentUtils
:
:
GetNodeTextContent
(
this
false
aDefaultValue
fallible
)
)
{
aError
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
}
void
HTMLTextAreaElement
:
:
SetDefaultValue
(
const
nsAString
&
aDefaultValue
ErrorResult
&
aError
)
{
nsresult
rv
=
nsContentUtils
:
:
SetNodeTextContent
(
this
aDefaultValue
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
mValueChanged
)
{
Reset
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
}
}
bool
HTMLTextAreaElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
maxlength
|
|
aAttribute
=
=
nsGkAtoms
:
:
minlength
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
cols
)
{
aResult
.
ParseIntWithFallback
(
aValue
DEFAULT_COLS
)
;
return
true
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
rows
)
{
aResult
.
ParseIntWithFallback
(
aValue
DEFAULT_ROWS_TEXTAREA
)
;
return
true
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
autocomplete
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLTextAreaElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_white_space
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
wrap
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
&
&
value
-
>
Equals
(
nsGkAtoms
:
:
OFF
eIgnoreCase
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_white_space
StyleWhiteSpace
:
:
Pre
)
;
}
}
nsGenericHTMLFormElementWithState
:
:
MapDivAlignAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLFormElementWithState
:
:
MapCommonAttributesInto
(
aAttributes
aDecls
)
;
}
nsChangeHint
HTMLTextAreaElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
nsGenericHTMLFormElementWithState
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
rows
|
|
aAttribute
=
=
nsGkAtoms
:
:
cols
)
{
retval
|
=
NS_STYLE_HINT_REFLOW
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
wrap
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
placeholder
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
return
retval
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
attributes
[
]
=
{
{
&
nsGkAtoms
:
:
wrap
}
{
nullptr
}
}
;
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
attributes
sDivAlignAttributeMap
sCommonAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLTextAreaElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
bool
HTMLTextAreaElement
:
:
IsDisabledForEvents
(
EventMessage
aMessage
)
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
false
)
;
nsIFrame
*
formFrame
=
do_QueryFrame
(
formControlFrame
)
;
return
IsElementDisabledForEvents
(
aMessage
formFrame
)
;
}
void
HTMLTextAreaElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
false
;
if
(
IsDisabledForEvents
(
aVisitor
.
mEvent
-
>
mMessage
)
)
{
return
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFormSelect
)
{
if
(
mHandlingSelect
)
{
return
;
}
mHandlingSelect
=
true
;
}
if
(
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
)
{
aVisitor
.
mItemFlags
|
=
NS_NO_CONTENT_DISPATCH
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseClick
&
&
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eMiddleButton
)
{
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
=
false
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
{
aVisitor
.
mWantsPreHandleEvent
=
true
;
}
nsGenericHTMLFormElementWithState
:
:
GetEventTargetParent
(
aVisitor
)
;
}
nsresult
HTMLTextAreaElement
:
:
PreHandleEvent
(
EventChainVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
{
FireChangeEventIfNeeded
(
)
;
}
return
nsGenericHTMLFormElementWithState
:
:
PreHandleEvent
(
aVisitor
)
;
}
void
HTMLTextAreaElement
:
:
FireChangeEventIfNeeded
(
)
{
nsString
value
;
GetValueInternal
(
value
true
)
;
if
(
mFocusedValue
.
Equals
(
value
)
)
{
return
;
}
mFocusedValue
=
value
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
this
)
NS_LITERAL_STRING
(
"
change
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
nsresult
HTMLTextAreaElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFormSelect
)
{
mHandlingSelect
=
false
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
)
{
GetValueInternal
(
mFocusedValue
true
)
;
mCanShowInvalidUI
=
!
IsValid
(
)
&
&
ShouldShowValidityUI
(
)
;
mCanShowValidUI
=
ShouldShowValidityUI
(
)
;
}
else
{
mCanShowInvalidUI
=
true
;
mCanShowValidUI
=
true
;
}
UpdateState
(
true
)
;
}
aVisitor
.
mEvent
-
>
mFlags
.
mNoContentDispatch
=
(
(
aVisitor
.
mItemFlags
&
NS_NO_CONTENT_DISPATCH
)
!
=
0
)
;
return
NS_OK
;
}
void
HTMLTextAreaElement
:
:
DoneAddingChildren
(
bool
aHaveNotified
)
{
if
(
!
mValueChanged
)
{
if
(
!
mDoneAddingChildren
)
{
Reset
(
)
;
}
if
(
!
mInhibitStateRestoration
)
{
nsresult
rv
=
GenerateStateKey
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RestoreFormControlState
(
)
;
}
}
}
mDoneAddingChildren
=
true
;
}
bool
HTMLTextAreaElement
:
:
IsDoneAddingChildren
(
)
{
return
mDoneAddingChildren
;
}
nsIControllers
*
HTMLTextAreaElement
:
:
GetControllers
(
ErrorResult
&
aError
)
{
if
(
!
mControllers
)
{
nsresult
rv
;
mControllers
=
do_CreateInstance
(
kXULControllersCID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIController
>
controller
=
do_CreateInstance
(
"
mozilla
.
org
/
editor
/
editorcontroller
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
mControllers
-
>
AppendController
(
controller
)
;
controller
=
do_CreateInstance
(
"
mozilla
.
org
/
editor
/
editingcontroller
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
mControllers
-
>
AppendController
(
controller
)
;
}
return
mControllers
;
}
nsresult
HTMLTextAreaElement
:
:
GetControllers
(
nsIControllers
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
ErrorResult
error
;
*
aResult
=
GetControllers
(
error
)
;
NS_IF_ADDREF
(
*
aResult
)
;
return
error
.
StealNSResult
(
)
;
}
uint32_t
HTMLTextAreaElement
:
:
GetTextLength
(
)
{
nsAutoString
val
;
GetValue
(
val
)
;
return
val
.
Length
(
)
;
}
Nullable
<
uint32_t
>
HTMLTextAreaElement
:
:
GetSelectionStart
(
ErrorResult
&
aError
)
{
uint32_t
selStart
selEnd
;
GetSelectionRange
(
&
selStart
&
selEnd
aError
)
;
return
Nullable
<
uint32_t
>
(
selStart
)
;
}
void
HTMLTextAreaElement
:
:
SetSelectionStart
(
const
Nullable
<
uint32_t
>
&
aSelectionStart
ErrorResult
&
aError
)
{
mState
.
SetSelectionStart
(
aSelectionStart
aError
)
;
}
Nullable
<
uint32_t
>
HTMLTextAreaElement
:
:
GetSelectionEnd
(
ErrorResult
&
aError
)
{
uint32_t
selStart
selEnd
;
GetSelectionRange
(
&
selStart
&
selEnd
aError
)
;
return
Nullable
<
uint32_t
>
(
selEnd
)
;
}
void
HTMLTextAreaElement
:
:
SetSelectionEnd
(
const
Nullable
<
uint32_t
>
&
aSelectionEnd
ErrorResult
&
aError
)
{
mState
.
SetSelectionEnd
(
aSelectionEnd
aError
)
;
}
void
HTMLTextAreaElement
:
:
GetSelectionRange
(
uint32_t
*
aSelectionStart
uint32_t
*
aSelectionEnd
ErrorResult
&
aRv
)
{
return
mState
.
GetSelectionRange
(
aSelectionStart
aSelectionEnd
aRv
)
;
}
void
HTMLTextAreaElement
:
:
GetSelectionDirection
(
nsAString
&
aDirection
ErrorResult
&
aError
)
{
mState
.
GetSelectionDirectionString
(
aDirection
aError
)
;
}
void
HTMLTextAreaElement
:
:
SetSelectionDirection
(
const
nsAString
&
aDirection
ErrorResult
&
aError
)
{
mState
.
SetSelectionDirection
(
aDirection
aError
)
;
}
void
HTMLTextAreaElement
:
:
SetSelectionRange
(
uint32_t
aSelectionStart
uint32_t
aSelectionEnd
const
Optional
<
nsAString
>
&
aDirection
ErrorResult
&
aError
)
{
mState
.
SetSelectionRange
(
aSelectionStart
aSelectionEnd
aDirection
aError
)
;
}
void
HTMLTextAreaElement
:
:
SetRangeText
(
const
nsAString
&
aReplacement
ErrorResult
&
aRv
)
{
mState
.
SetRangeText
(
aReplacement
aRv
)
;
}
void
HTMLTextAreaElement
:
:
SetRangeText
(
const
nsAString
&
aReplacement
uint32_t
aStart
uint32_t
aEnd
SelectionMode
aSelectMode
ErrorResult
&
aRv
)
{
mState
.
SetRangeText
(
aReplacement
aStart
aEnd
aSelectMode
aRv
)
;
}
void
HTMLTextAreaElement
:
:
GetValueFromSetRangeText
(
nsAString
&
aValue
)
{
GetValueInternal
(
aValue
false
)
;
}
nsresult
HTMLTextAreaElement
:
:
SetValueFromSetRangeText
(
const
nsAString
&
aValue
)
{
return
SetValueInternal
(
aValue
nsTextEditorState
:
:
eSetValue_ByContent
|
nsTextEditorState
:
:
eSetValue_Notify
)
;
}
nsresult
HTMLTextAreaElement
:
:
Reset
(
)
{
nsAutoString
resetVal
;
GetDefaultValue
(
resetVal
IgnoreErrors
(
)
)
;
SetValueChanged
(
false
)
;
nsresult
rv
=
SetValueInternal
(
resetVal
nsTextEditorState
:
:
eSetValue_Internal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLTextAreaElement
:
:
SubmitNamesValues
(
HTMLFormSubmission
*
aFormSubmission
)
{
if
(
IsDisabled
(
)
)
{
return
NS_OK
;
}
nsAutoString
name
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
if
(
name
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsAutoString
value
;
GetValueInternal
(
value
false
)
;
return
aFormSubmission
-
>
AddNameValuePair
(
name
value
)
;
}
NS_IMETHODIMP
HTMLTextAreaElement
:
:
SaveState
(
)
{
nsresult
rv
=
NS_OK
;
PresState
*
state
=
nullptr
;
if
(
mValueChanged
)
{
state
=
GetPrimaryPresState
(
)
;
if
(
state
)
{
nsAutoString
value
;
GetValueInternal
(
value
true
)
;
rv
=
nsLinebreakConverter
:
:
ConvertStringLineBreaks
(
value
nsLinebreakConverter
:
:
eLinebreakPlatform
nsLinebreakConverter
:
:
eLinebreakContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Converting
linebreaks
failed
!
"
)
;
return
rv
;
}
state
-
>
contentData
(
)
=
std
:
:
move
(
value
)
;
}
}
if
(
mDisabledChanged
)
{
if
(
!
state
)
{
state
=
GetPrimaryPresState
(
)
;
rv
=
NS_OK
;
}
if
(
state
)
{
state
-
>
disabled
(
)
=
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
)
;
state
-
>
disabledSet
(
)
=
true
;
}
}
return
rv
;
}
bool
HTMLTextAreaElement
:
:
RestoreState
(
PresState
*
aState
)
{
const
PresContentData
&
state
=
aState
-
>
contentData
(
)
;
if
(
state
.
type
(
)
=
=
PresContentData
:
:
TnsString
)
{
ErrorResult
rv
;
SetValue
(
state
.
get_nsString
(
)
rv
)
;
ENSURE_SUCCESS
(
rv
false
)
;
}
if
(
aState
-
>
disabledSet
(
)
&
&
!
aState
-
>
disabled
(
)
)
{
SetDisabled
(
false
IgnoreErrors
(
)
)
;
}
return
false
;
}
EventStates
HTMLTextAreaElement
:
:
IntrinsicState
(
)
const
{
EventStates
state
=
nsGenericHTMLFormElementWithState
:
:
IntrinsicState
(
)
;
if
(
IsCandidateForConstraintValidation
(
)
)
{
if
(
IsValid
(
)
)
{
state
|
=
NS_EVENT_STATE_VALID
;
}
else
{
state
|
=
NS_EVENT_STATE_INVALID
;
if
(
(
!
mForm
|
|
!
mForm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
)
&
&
(
GetValidityState
(
VALIDITY_STATE_CUSTOM_ERROR
)
|
|
(
mCanShowInvalidUI
&
&
ShouldShowValidityUI
(
)
)
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_UI_INVALID
;
}
}
if
(
(
!
mForm
|
|
!
mForm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
)
&
&
(
mCanShowValidUI
&
&
ShouldShowValidityUI
(
)
&
&
(
IsValid
(
)
|
|
(
state
.
HasState
(
NS_EVENT_STATE_MOZ_UI_INVALID
)
&
&
!
mCanShowInvalidUI
)
)
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_UI_VALID
;
}
}
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
)
&
&
IsValueEmpty
(
)
)
{
state
|
=
NS_EVENT_STATE_PLACEHOLDERSHOWN
;
}
return
state
;
}
nsresult
HTMLTextAreaElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
nsresult
rv
=
nsGenericHTMLFormElementWithState
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateState
(
false
)
;
return
rv
;
}
void
HTMLTextAreaElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
nsGenericHTMLFormElementWithState
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateState
(
false
)
;
}
nsresult
HTMLTextAreaElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNotify
&
&
aName
=
=
nsGkAtoms
:
:
disabled
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
mDisabledChanged
=
true
;
}
return
nsGenericHTMLFormElementWithState
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
void
HTMLTextAreaElement
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
ContentChanged
(
aContent
)
;
}
void
HTMLTextAreaElement
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
ContentChanged
(
aFirstNewContent
)
;
}
void
HTMLTextAreaElement
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
ContentChanged
(
aChild
)
;
}
void
HTMLTextAreaElement
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
ContentChanged
(
aChild
)
;
}
void
HTMLTextAreaElement
:
:
ContentChanged
(
nsIContent
*
aContent
)
{
if
(
!
mValueChanged
&
&
mDoneAddingChildren
&
&
nsContentUtils
:
:
IsInSameAnonymousTree
(
this
aContent
)
)
{
nsCOMPtr
<
nsIMutationObserver
>
kungFuDeathGrip
(
this
)
;
Reset
(
)
;
}
}
nsresult
HTMLTextAreaElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
required
|
|
aName
=
=
nsGkAtoms
:
:
disabled
|
|
aName
=
=
nsGkAtoms
:
:
readonly
)
{
if
(
aName
=
=
nsGkAtoms
:
:
disabled
)
{
UpdateDisabledState
(
aNotify
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
required
)
{
UpdateRequiredState
(
!
!
aValue
aNotify
)
;
}
UpdateValueMissingValidityState
(
)
;
if
(
aName
=
=
nsGkAtoms
:
:
readonly
|
|
aName
=
=
nsGkAtoms
:
:
disabled
)
{
UpdateBarredFromConstraintValidation
(
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
autocomplete
)
{
mAutocompleteAttrState
=
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
maxlength
)
{
UpdateTooLongValidityState
(
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
minlength
)
{
UpdateTooShortValidityState
(
)
;
}
}
return
nsGenericHTMLFormElementWithState
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
nsresult
HTMLTextAreaElement
:
:
CopyInnerTo
(
Element
*
aDest
bool
aPreallocateChildren
)
{
nsresult
rv
=
nsGenericHTMLFormElementWithState
:
:
CopyInnerTo
(
aDest
aPreallocateChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDest
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
nsAutoString
value
;
GetValueInternal
(
value
true
)
;
ErrorResult
ret
;
static_cast
<
HTMLTextAreaElement
*
>
(
aDest
)
-
>
SetValue
(
value
ret
)
;
return
ret
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
bool
HTMLTextAreaElement
:
:
IsMutable
(
)
const
{
return
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
&
&
!
IsDisabled
(
)
)
;
}
bool
HTMLTextAreaElement
:
:
IsValueEmpty
(
)
const
{
nsAutoString
value
;
GetValueInternal
(
value
true
)
;
return
value
.
IsEmpty
(
)
;
}
void
HTMLTextAreaElement
:
:
SetCustomValidity
(
const
nsAString
&
aError
)
{
nsIConstraintValidation
:
:
SetCustomValidity
(
aError
)
;
UpdateState
(
true
)
;
}
bool
HTMLTextAreaElement
:
:
IsTooLong
(
)
{
if
(
!
mValueChanged
|
|
!
mLastValueChangeWasInteractive
|
|
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
maxlength
)
)
{
return
false
;
}
int32_t
maxLength
=
MaxLength
(
)
;
if
(
maxLength
=
=
-
1
)
{
return
false
;
}
int32_t
textLength
=
GetTextLength
(
)
;
return
textLength
>
maxLength
;
}
bool
HTMLTextAreaElement
:
:
IsTooShort
(
)
{
if
(
!
mValueChanged
|
|
!
mLastValueChangeWasInteractive
|
|
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
minlength
)
)
{
return
false
;
}
int32_t
minLength
=
MinLength
(
)
;
if
(
minLength
=
=
-
1
)
{
return
false
;
}
int32_t
textLength
=
GetTextLength
(
)
;
return
textLength
&
&
textLength
<
minLength
;
}
bool
HTMLTextAreaElement
:
:
IsValueMissing
(
)
const
{
if
(
!
Required
(
)
|
|
!
IsMutable
(
)
)
{
return
false
;
}
return
IsValueEmpty
(
)
;
}
void
HTMLTextAreaElement
:
:
UpdateTooLongValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_TOO_LONG
IsTooLong
(
)
)
;
}
void
HTMLTextAreaElement
:
:
UpdateTooShortValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_TOO_SHORT
IsTooShort
(
)
)
;
}
void
HTMLTextAreaElement
:
:
UpdateValueMissingValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_VALUE_MISSING
IsValueMissing
(
)
)
;
}
void
HTMLTextAreaElement
:
:
UpdateBarredFromConstraintValidation
(
)
{
SetBarredFromConstraintValidation
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
|
|
IsDisabled
(
)
)
;
}
nsresult
HTMLTextAreaElement
:
:
GetValidationMessage
(
nsAString
&
aValidationMessage
ValidityStateType
aType
)
{
nsresult
rv
=
NS_OK
;
switch
(
aType
)
{
case
VALIDITY_STATE_TOO_LONG
:
{
nsAutoString
message
;
int32_t
maxLength
=
MaxLength
(
)
;
int32_t
textLength
=
GetTextLength
(
)
;
nsAutoString
strMaxLength
;
nsAutoString
strTextLength
;
strMaxLength
.
AppendInt
(
maxLength
)
;
strTextLength
.
AppendInt
(
textLength
)
;
const
char16_t
*
params
[
]
=
{
strMaxLength
.
get
(
)
strTextLength
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationTextTooLong
"
params
message
)
;
aValidationMessage
=
message
;
}
break
;
case
VALIDITY_STATE_TOO_SHORT
:
{
nsAutoString
message
;
int32_t
minLength
=
MinLength
(
)
;
int32_t
textLength
=
GetTextLength
(
)
;
nsAutoString
strMinLength
;
nsAutoString
strTextLength
;
strMinLength
.
AppendInt
(
minLength
)
;
strTextLength
.
AppendInt
(
textLength
)
;
const
char16_t
*
params
[
]
=
{
strMinLength
.
get
(
)
strTextLength
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationTextTooShort
"
params
message
)
;
aValidationMessage
=
message
;
}
break
;
case
VALIDITY_STATE_VALUE_MISSING
:
{
nsAutoString
message
;
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationValueMissing
"
message
)
;
aValidationMessage
=
message
;
}
break
;
default
:
rv
=
nsIConstraintValidation
:
:
GetValidationMessage
(
aValidationMessage
aType
)
;
}
return
rv
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
IsSingleLineTextControl
(
)
const
{
return
false
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
IsTextArea
(
)
const
{
return
true
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
IsPasswordTextControl
(
)
const
{
return
false
;
}
NS_IMETHODIMP_
(
int32_t
)
HTMLTextAreaElement
:
:
GetCols
(
)
{
return
Cols
(
)
;
}
NS_IMETHODIMP_
(
int32_t
)
HTMLTextAreaElement
:
:
GetWrapCols
(
)
{
nsHTMLTextWrap
wrapProp
;
nsITextControlElement
:
:
GetWrapPropertyEnum
(
this
wrapProp
)
;
if
(
wrapProp
=
=
nsITextControlElement
:
:
eHTMLTextWrap_Off
)
{
return
0
;
}
return
GetCols
(
)
;
}
NS_IMETHODIMP_
(
int32_t
)
HTMLTextAreaElement
:
:
GetRows
(
)
{
const
nsAttrValue
*
attr
=
GetParsedAttr
(
nsGkAtoms
:
:
rows
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
int32_t
rows
=
attr
-
>
GetIntegerValue
(
)
;
return
(
rows
<
=
0
)
?
DEFAULT_ROWS_TEXTAREA
:
rows
;
}
return
DEFAULT_ROWS_TEXTAREA
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
GetDefaultValueFromContent
(
nsAString
&
aValue
)
{
GetDefaultValue
(
aValue
IgnoreErrors
(
)
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
ValueChanged
(
)
const
{
return
mValueChanged
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
GetTextEditorValue
(
nsAString
&
aValue
bool
aIgnoreWrap
)
const
{
mState
.
GetValue
(
aValue
aIgnoreWrap
)
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
InitializeKeyboardEventListeners
(
)
{
mState
.
InitializeKeyboardEventListeners
(
)
;
}
NS_IMETHODIMP_
(
void
)
HTMLTextAreaElement
:
:
OnValueChanged
(
bool
aNotify
bool
aWasInteractiveUserChange
)
{
mLastValueChangeWasInteractive
=
aWasInteractiveUserChange
;
bool
validBefore
=
IsValid
(
)
;
UpdateTooLongValidityState
(
)
;
UpdateTooShortValidityState
(
)
;
UpdateValueMissingValidityState
(
)
;
if
(
validBefore
!
=
IsValid
(
)
|
|
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
)
)
{
UpdateState
(
aNotify
)
;
}
}
NS_IMETHODIMP_
(
bool
)
HTMLTextAreaElement
:
:
HasCachedSelection
(
)
{
return
mState
.
IsSelectionCached
(
)
;
}
void
HTMLTextAreaElement
:
:
FieldSetDisabledChanged
(
bool
aNotify
)
{
nsGenericHTMLFormElementWithState
:
:
FieldSetDisabledChanged
(
aNotify
)
;
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateState
(
aNotify
)
;
}
JSObject
*
HTMLTextAreaElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLTextAreaElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
HTMLTextAreaElement
:
:
GetAutocomplete
(
DOMString
&
aValue
)
{
const
nsAttrValue
*
attributeVal
=
GetParsedAttr
(
nsGkAtoms
:
:
autocomplete
)
;
mAutocompleteAttrState
=
nsContentUtils
:
:
SerializeAutocompleteAttribute
(
attributeVal
aValue
mAutocompleteAttrState
)
;
}
}
}
