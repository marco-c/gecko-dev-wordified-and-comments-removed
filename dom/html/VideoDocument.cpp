#
include
"
MediaDocument
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
DocumentInlines
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
namespace
mozilla
:
:
dom
{
class
VideoDocument
final
:
public
MediaDocument
{
public
:
enum
MediaDocumentKind
MediaDocumentKind
(
)
const
override
{
return
MediaDocumentKind
:
:
Video
;
}
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
=
true
)
override
;
virtual
void
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aScriptGlobalObject
)
override
;
virtual
void
Destroy
(
)
override
{
if
(
mStreamListener
)
{
mStreamListener
-
>
DropDocumentRef
(
)
;
}
MediaDocument
:
:
Destroy
(
)
;
}
nsresult
StartLayout
(
)
override
;
protected
:
nsresult
CreateVideoElement
(
)
;
void
UpdateTitle
(
nsIChannel
*
aChannel
)
;
RefPtr
<
MediaDocumentStreamListener
>
mStreamListener
;
}
;
nsresult
VideoDocument
:
:
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
)
{
nsresult
rv
=
MediaDocument
:
:
StartDocumentLoad
(
aCommand
aChannel
aLoadGroup
aContainer
aDocListener
aReset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mStreamListener
=
new
MediaDocumentStreamListener
(
this
)
;
NS_ADDREF
(
*
aDocListener
=
mStreamListener
)
;
return
rv
;
}
nsresult
VideoDocument
:
:
StartLayout
(
)
{
nsresult
rv
=
CreateVideoElement
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MediaDocument
:
:
StartLayout
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
VideoDocument
:
:
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aScriptGlobalObject
)
{
MediaDocument
:
:
SetScriptGlobalObject
(
aScriptGlobalObject
)
;
if
(
aScriptGlobalObject
&
&
!
InitialSetupHasBeenDone
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
CreateSyntheticDocument
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
failed
to
create
synthetic
video
document
"
)
;
InitialSetupDone
(
)
;
}
}
nsresult
VideoDocument
:
:
CreateVideoElement
(
)
{
RefPtr
<
Element
>
body
=
GetBodyElement
(
)
;
if
(
!
body
)
{
NS_WARNING
(
"
no
body
on
video
document
!
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nodeInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
video
nullptr
kNameSpaceID_XHTML
nsINode
:
:
ELEMENT_NODE
)
;
RefPtr
<
HTMLMediaElement
>
element
=
static_cast
<
HTMLMediaElement
*
>
(
NS_NewHTMLVideoElement
(
nodeInfo
.
forget
(
)
NOT_FROM_PARSER
)
)
;
if
(
!
element
)
return
NS_ERROR_OUT_OF_MEMORY
;
element
-
>
SetAutoplay
(
true
IgnoreErrors
(
)
)
;
element
-
>
SetControls
(
true
IgnoreErrors
(
)
)
;
element
-
>
LoadWithChannel
(
mChannel
getter_AddRefs
(
mStreamListener
-
>
mNextStream
)
)
;
UpdateTitle
(
mChannel
)
;
if
(
nsContentUtils
:
:
IsChildOfSameType
(
this
)
)
{
element
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
nsLiteralString
(
u
"
position
:
absolute
;
top
:
0
;
left
:
0
;
width
:
100
%
;
height
:
100
%
"
)
true
)
;
}
else
{
LinkStylesheet
(
nsLiteralString
(
u
"
resource
:
/
/
content
-
accessible
/
TopLevelVideoDocument
.
css
"
)
)
;
LinkScript
(
u
"
chrome
:
/
/
global
/
content
/
TopLevelVideoDocument
.
js
"
_ns
)
;
}
ErrorResult
rv
;
body
-
>
AppendChildTo
(
element
false
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
VideoDocument
:
:
UpdateTitle
(
nsIChannel
*
aChannel
)
{
if
(
!
aChannel
)
return
;
nsAutoString
fileName
;
GetFileName
(
fileName
aChannel
)
;
IgnoredErrorResult
ignored
;
SetTitle
(
fileName
ignored
)
;
}
}
nsresult
NS_NewVideoDocument
(
mozilla
:
:
dom
:
:
Document
*
*
aResult
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aPartitionedPrincipal
)
{
auto
*
doc
=
new
mozilla
:
:
dom
:
:
VideoDocument
(
)
;
NS_ADDREF
(
doc
)
;
nsresult
rv
=
doc
-
>
Init
(
aPrincipal
aPartitionedPrincipal
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_RELEASE
(
doc
)
;
}
*
aResult
=
doc
;
return
rv
;
}
