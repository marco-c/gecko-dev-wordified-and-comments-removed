#
include
"
mozilla
/
dom
/
HTMLElement
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
HTMLElementBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
:
:
dom
{
HTMLElement
:
:
HTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsGenericHTMLFormElement
(
std
:
:
move
(
aNodeInfo
)
)
{
if
(
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
bdi
)
)
{
AddStatesSilently
(
NS_EVENT_STATE_DIR_ATTR_LIKE_AUTO
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLElement
nsGenericHTMLFormElement
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLElement
)
NS_INTERFACE_MAP_ENTRY_TEAROFF
(
nsIFormControl
GetElementInternals
(
)
)
NS_INTERFACE_MAP_END_INHERITING
(
nsGenericHTMLFormElement
)
NS_IMPL_ADDREF_INHERITED
(
HTMLElement
nsGenericHTMLFormElement
)
NS_IMPL_RELEASE_INHERITED
(
HTMLElement
nsGenericHTMLFormElement
)
NS_IMPL_ELEMENT_CLONE
(
HTMLElement
)
JSObject
*
HTMLElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
HTMLElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
HTMLElement
:
:
SetCustomElementDefinition
(
CustomElementDefinition
*
aDefinition
)
{
if
(
aDefinition
&
&
!
aDefinition
-
>
IsCustomBuiltIn
(
)
&
&
aDefinition
-
>
mFormAssociated
)
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
MOZ_ASSERT
(
data
)
;
data
-
>
GetOrCreateElementInternals
(
this
)
;
}
nsGenericHTMLFormElement
:
:
SetCustomElementDefinition
(
aDefinition
)
;
}
already_AddRefed
<
ElementInternals
>
HTMLElement
:
:
AttachInternals
(
ErrorResult
&
aRv
)
{
CustomElementData
*
ceData
=
GetCustomElementData
(
)
;
if
(
nsAtom
*
isAtom
=
ceData
?
ceData
-
>
GetIs
(
this
)
:
nullptr
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Cannot
attach
ElementInternals
to
a
customized
built
-
in
element
"
"
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
isAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
nsAtom
*
nameAtom
=
NodeInfo
(
)
-
>
NameAtom
(
)
;
CustomElementDefinition
*
definition
=
nullptr
;
if
(
ceData
)
{
definition
=
ceData
-
>
GetCustomElementDefinition
(
)
;
if
(
!
definition
)
{
definition
=
nsContentUtils
:
:
LookupCustomElementDefinition
(
NodeInfo
(
)
-
>
GetDocument
(
)
nameAtom
NodeInfo
(
)
-
>
NamespaceID
(
)
ceData
-
>
GetCustomElementType
(
)
)
;
}
}
if
(
!
definition
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Cannot
attach
ElementInternals
to
a
non
-
custom
element
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
nameAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
if
(
definition
-
>
mDisableInternals
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
AttachInternal
(
)
to
'
%
s
'
is
disabled
by
disabledFeatures
"
NS_ConvertUTF16toUTF8
(
nameAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
MOZ_ASSERT
(
ceData
)
;
if
(
ceData
-
>
HasAttachedInternals
(
)
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
AttachInternals
(
)
has
already
been
called
from
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
nameAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
if
(
ceData
-
>
mState
!
=
CustomElementData
:
:
State
:
:
ePrecustomized
&
&
ceData
-
>
mState
!
=
CustomElementData
:
:
State
:
:
eCustom
)
{
aRv
.
ThrowNotSupportedError
(
R
"
(
Custom
element
state
is
not
"
precustomized
"
or
"
custom
"
.
)
"
)
;
return
nullptr
;
}
ceData
-
>
AttachedInternals
(
)
;
return
do_AddRef
(
ceData
-
>
GetOrCreateElementInternals
(
this
)
)
;
}
void
HTMLElement
:
:
UpdateFormOwner
(
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
?
IsInComposedDoc
(
)
:
!
!
GetParent
(
)
)
{
nsGenericHTMLFormElement
:
:
UpdateFormOwner
(
true
nullptr
)
;
}
UpdateFieldSet
(
true
)
;
}
void
HTMLElement
:
:
SetFormInternal
(
HTMLFormElement
*
aForm
bool
aBindToTree
)
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
internals
-
>
SetForm
(
aForm
)
;
}
HTMLFormElement
*
HTMLElement
:
:
GetFormInternal
(
)
const
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
return
internals
-
>
GetForm
(
)
;
}
void
HTMLElement
:
:
SetFieldSetInternal
(
HTMLFieldSetElement
*
aFieldset
)
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
internals
-
>
SetFieldSet
(
aFieldset
)
;
}
HTMLFieldSetElement
*
HTMLElement
:
:
GetFieldSetInternal
(
)
const
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
return
internals
-
>
GetFieldSet
(
)
;
}
bool
HTMLElement
:
:
CanBeDisabled
(
)
const
{
return
IsFormAssociatedElement
(
)
;
}
bool
HTMLElement
:
:
DoesReadOnlyApply
(
)
const
{
return
IsFormAssociatedElement
(
)
;
}
bool
HTMLElement
:
:
IsFormAssociatedElement
(
)
const
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
bool
isFormAssociatedCustomElement
=
data
&
&
data
-
>
IsFormAssociated
(
)
;
MOZ_ASSERT_IF
(
isFormAssociatedCustomElement
StaticPrefs
:
:
dom_webcomponents_formAssociatedCustomElement_enabled
(
)
)
;
return
isFormAssociatedCustomElement
;
}
ElementInternals
*
HTMLElement
:
:
GetElementInternals
(
)
const
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
if
(
!
data
|
|
!
data
-
>
IsFormAssociated
(
)
)
{
return
nullptr
;
}
return
data
-
>
GetElementInternals
(
)
;
}
}
nsGenericHTMLElement
*
NS_NewHTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
mozilla
:
:
dom
:
:
HTMLElement
(
nodeInfo
.
forget
(
)
)
;
}
nsGenericHTMLElement
*
NS_NewCustomElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
mozilla
:
:
dom
:
:
HTMLElement
(
nodeInfo
.
forget
(
)
)
;
}
