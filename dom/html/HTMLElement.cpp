#
include
"
mozilla
/
dom
/
HTMLElement
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
ElementInternalsBinding
.
h
"
#
include
"
mozilla
/
dom
/
FormData
.
h
"
#
include
"
mozilla
/
dom
/
FromParser
.
h
"
#
include
"
mozilla
/
dom
/
HTMLElementBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
namespace
mozilla
:
:
dom
{
HTMLElement
:
:
HTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFormElement
(
std
:
:
move
(
aNodeInfo
)
)
{
if
(
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
bdi
)
)
{
AddStatesSilently
(
ElementState
:
:
HAS_DIR_ATTR_LIKE_AUTO
)
;
}
InhibitRestoration
(
!
(
aFromParser
&
FROM_PARSER_NETWORK
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLElement
nsGenericHTMLFormElement
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLElement
)
NS_INTERFACE_MAP_ENTRY_TEAROFF
(
nsIFormControl
GetElementInternals
(
)
)
NS_INTERFACE_MAP_ENTRY_TEAROFF
(
nsIConstraintValidation
GetElementInternals
(
)
)
NS_INTERFACE_MAP_END_INHERITING
(
nsGenericHTMLFormElement
)
NS_IMPL_ADDREF_INHERITED
(
HTMLElement
nsGenericHTMLFormElement
)
NS_IMPL_RELEASE_INHERITED
(
HTMLElement
nsGenericHTMLFormElement
)
NS_IMPL_ELEMENT_CLONE
(
HTMLElement
)
JSObject
*
HTMLElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
dom
:
:
HTMLElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
HTMLElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
if
(
IsDisabledForEvents
(
aVisitor
.
mEvent
)
)
{
aVisitor
.
mCanHandle
=
false
;
return
;
}
nsGenericHTMLFormElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
nsINode
*
HTMLElement
:
:
GetScopeChainParent
(
)
const
{
if
(
IsFormAssociatedCustomElements
(
)
)
{
auto
*
form
=
GetFormInternal
(
)
;
if
(
form
)
{
return
form
;
}
}
return
nsGenericHTMLFormElement
:
:
GetScopeChainParent
(
)
;
}
nsresult
HTMLElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLFormElement
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UpdateBarredFromConstraintValidation
(
)
;
return
rv
;
}
void
HTMLElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
nsGenericHTMLFormElement
:
:
UnbindFromTree
(
aNullParent
)
;
UpdateBarredFromConstraintValidation
(
)
;
}
void
HTMLElement
:
:
DoneCreatingElement
(
)
{
if
(
MOZ_UNLIKELY
(
IsFormAssociatedElement
(
)
)
)
{
MaybeRestoreFormAssociatedCustomElementState
(
)
;
}
}
void
HTMLElement
:
:
SaveState
(
)
{
if
(
MOZ_LIKELY
(
!
IsFormAssociatedElement
(
)
)
)
{
return
;
}
auto
*
internals
=
GetElementInternals
(
)
;
nsCString
stateKey
=
internals
-
>
GetStateKey
(
)
;
if
(
stateKey
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
history
=
GetLayoutHistory
(
false
)
;
if
(
!
history
)
{
return
;
}
PresState
*
result
=
history
-
>
GetState
(
stateKey
)
;
if
(
!
result
)
{
UniquePtr
<
PresState
>
newState
=
NewPresState
(
)
;
result
=
newState
.
get
(
)
;
history
-
>
AddState
(
stateKey
std
:
:
move
(
newState
)
)
;
}
const
auto
&
state
=
internals
-
>
GetFormState
(
)
;
const
auto
&
value
=
internals
-
>
GetFormSubmissionValue
(
)
;
result
-
>
contentData
(
)
=
CustomElementTuple
(
nsContentUtils
:
:
ConvertToCustomElementFormValue
(
value
)
nsContentUtils
:
:
ConvertToCustomElementFormValue
(
state
)
)
;
}
void
HTMLElement
:
:
MaybeRestoreFormAssociatedCustomElementState
(
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
if
(
HasFlag
(
HTML_ELEMENT_INHIBIT_RESTORATION
)
)
{
return
;
}
auto
*
internals
=
GetElementInternals
(
)
;
if
(
internals
-
>
GetStateKey
(
)
.
IsEmpty
(
)
)
{
Document
*
doc
=
GetUncomposedDoc
(
)
;
nsCString
stateKey
;
nsContentUtils
:
:
GenerateStateKey
(
this
doc
stateKey
)
;
internals
-
>
SetStateKey
(
std
:
:
move
(
stateKey
)
)
;
RestoreFormAssociatedCustomElementState
(
)
;
}
}
void
HTMLElement
:
:
RestoreFormAssociatedCustomElementState
(
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
auto
*
internals
=
GetElementInternals
(
)
;
const
nsCString
&
stateKey
=
internals
-
>
GetStateKey
(
)
;
if
(
stateKey
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
history
=
GetLayoutHistory
(
true
)
;
if
(
!
history
)
{
return
;
}
PresState
*
result
=
history
-
>
GetState
(
stateKey
)
;
if
(
!
result
)
{
return
;
}
auto
&
content
=
result
-
>
contentData
(
)
;
if
(
content
.
type
(
)
!
=
PresContentData
:
:
TCustomElementTuple
)
{
return
;
}
auto
&
ce
=
content
.
get_CustomElementTuple
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetOwnerDocument
(
)
-
>
GetOwnerGlobal
(
)
;
internals
-
>
RestoreFormValue
(
nsContentUtils
:
:
ExtractFormAssociatedCustomElementValue
(
global
ce
.
value
(
)
)
nsContentUtils
:
:
ExtractFormAssociatedCustomElementValue
(
global
ce
.
state
(
)
)
)
;
}
void
HTMLElement
:
:
InhibitRestoration
(
bool
aShouldInhibit
)
{
if
(
aShouldInhibit
)
{
SetFlags
(
HTML_ELEMENT_INHIBIT_RESTORATION
)
;
}
else
{
UnsetFlags
(
HTML_ELEMENT_INHIBIT_RESTORATION
)
;
}
}
void
HTMLElement
:
:
SetCustomElementDefinition
(
CustomElementDefinition
*
aDefinition
)
{
nsGenericHTMLFormElement
:
:
SetCustomElementDefinition
(
aDefinition
)
;
if
(
aDefinition
&
&
!
aDefinition
-
>
IsCustomBuiltIn
(
)
&
&
aDefinition
-
>
mFormAssociated
)
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
MOZ_ASSERT
(
data
)
;
auto
*
internals
=
data
-
>
GetOrCreateElementInternals
(
this
)
;
if
(
data
-
>
mState
=
=
CustomElementData
:
:
State
:
:
eCustom
)
{
UpdateDisabledState
(
true
)
;
}
else
if
(
!
HasFlag
(
HTML_ELEMENT_INHIBIT_RESTORATION
)
)
{
internals
-
>
InitializeControlNumber
(
)
;
}
}
}
already_AddRefed
<
ElementInternals
>
HTMLElement
:
:
AttachInternals
(
ErrorResult
&
aRv
)
{
CustomElementData
*
ceData
=
GetCustomElementData
(
)
;
if
(
nsAtom
*
isAtom
=
ceData
?
ceData
-
>
GetIs
(
this
)
:
nullptr
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Cannot
attach
ElementInternals
to
a
customized
built
-
in
element
"
"
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
isAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
nsAtom
*
nameAtom
=
NodeInfo
(
)
-
>
NameAtom
(
)
;
CustomElementDefinition
*
definition
=
nullptr
;
if
(
ceData
)
{
definition
=
ceData
-
>
GetCustomElementDefinition
(
)
;
if
(
!
definition
)
{
definition
=
nsContentUtils
:
:
LookupCustomElementDefinition
(
NodeInfo
(
)
-
>
GetDocument
(
)
nameAtom
NodeInfo
(
)
-
>
NamespaceID
(
)
ceData
-
>
GetCustomElementType
(
)
)
;
}
}
if
(
!
definition
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Cannot
attach
ElementInternals
to
a
non
-
custom
element
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
nameAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
if
(
definition
-
>
mDisableInternals
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
AttachInternal
(
)
to
'
%
s
'
is
disabled
by
disabledFeatures
"
NS_ConvertUTF16toUTF8
(
nameAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
MOZ_ASSERT
(
ceData
)
;
if
(
ceData
-
>
HasAttachedInternals
(
)
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
AttachInternals
(
)
has
already
been
called
from
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
nameAtom
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
if
(
ceData
-
>
mState
!
=
CustomElementData
:
:
State
:
:
ePrecustomized
&
&
ceData
-
>
mState
!
=
CustomElementData
:
:
State
:
:
eCustom
)
{
aRv
.
ThrowNotSupportedError
(
R
"
(
Custom
element
state
is
not
"
precustomized
"
or
"
custom
"
.
)
"
)
;
return
nullptr
;
}
ceData
-
>
AttachedInternals
(
)
;
return
do_AddRef
(
ceData
-
>
GetOrCreateElementInternals
(
this
)
)
;
}
void
HTMLElement
:
:
AfterClearForm
(
bool
aUnbindOrDelete
)
{
if
(
aUnbindOrDelete
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
nsContentUtils
:
:
EnqueueLifecycleCallback
(
ElementCallbackType
:
:
eFormAssociated
this
{
}
)
;
}
}
void
HTMLElement
:
:
UpdateFormOwner
(
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
if
(
HasAttr
(
nsGkAtoms
:
:
form
)
?
IsInComposedDoc
(
)
:
!
!
GetParent
(
)
)
{
UpdateFormOwner
(
true
nullptr
)
;
}
UpdateFieldSet
(
true
)
;
UpdateDisabledState
(
true
)
;
UpdateBarredFromConstraintValidation
(
)
;
MaybeRestoreFormAssociatedCustomElementState
(
)
;
}
bool
HTMLElement
:
:
IsDisabledForEvents
(
WidgetEvent
*
aEvent
)
{
if
(
IsFormAssociatedElement
(
)
)
{
return
IsElementDisabledForEvents
(
aEvent
GetPrimaryFrame
(
)
)
;
}
return
false
;
}
void
HTMLElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aName
=
=
nsGkAtoms
:
:
disabled
|
|
aName
=
=
nsGkAtoms
:
:
readonly
)
)
{
if
(
aName
=
=
nsGkAtoms
:
:
disabled
)
{
UpdateDisabledState
(
aNotify
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
readonly
&
&
!
!
aValue
!
=
!
!
aOldValue
)
{
UpdateReadOnlyState
(
aNotify
)
;
}
UpdateBarredFromConstraintValidation
(
)
;
}
return
nsGenericHTMLFormElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
ElementState
HTMLElement
:
:
IntrinsicState
(
)
const
{
ElementState
state
=
nsGenericHTMLFormElement
:
:
IntrinsicState
(
)
;
if
(
ElementInternals
*
internals
=
GetElementInternals
(
)
)
{
if
(
internals
-
>
IsCandidateForConstraintValidation
(
)
)
{
if
(
internals
-
>
IsValid
(
)
)
{
state
|
=
ElementState
:
:
VALID
|
ElementState
:
:
USER_VALID
;
}
else
{
state
|
=
ElementState
:
:
INVALID
|
ElementState
:
:
USER_INVALID
;
}
}
}
return
state
;
}
void
HTMLElement
:
:
SetFormInternal
(
HTMLFormElement
*
aForm
bool
aBindToTree
)
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
internals
-
>
SetForm
(
aForm
)
;
}
HTMLFormElement
*
HTMLElement
:
:
GetFormInternal
(
)
const
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
return
internals
-
>
GetForm
(
)
;
}
void
HTMLElement
:
:
SetFieldSetInternal
(
HTMLFieldSetElement
*
aFieldset
)
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
internals
-
>
SetFieldSet
(
aFieldset
)
;
}
HTMLFieldSetElement
*
HTMLElement
:
:
GetFieldSetInternal
(
)
const
{
ElementInternals
*
internals
=
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
return
internals
-
>
GetFieldSet
(
)
;
}
bool
HTMLElement
:
:
CanBeDisabled
(
)
const
{
return
IsFormAssociatedElement
(
)
;
}
bool
HTMLElement
:
:
DoesReadOnlyApply
(
)
const
{
return
IsFormAssociatedElement
(
)
;
}
void
HTMLElement
:
:
UpdateDisabledState
(
bool
aNotify
)
{
bool
oldState
=
IsDisabled
(
)
;
nsGenericHTMLFormElement
:
:
UpdateDisabledState
(
aNotify
)
;
if
(
oldState
!
=
IsDisabled
(
)
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
LifecycleCallbackArgs
args
;
args
.
mDisabled
=
!
oldState
;
nsContentUtils
:
:
EnqueueLifecycleCallback
(
ElementCallbackType
:
:
eFormDisabled
this
args
)
;
}
}
void
HTMLElement
:
:
UpdateFormOwner
(
bool
aBindToTree
Element
*
aFormIdElement
)
{
HTMLFormElement
*
oldForm
=
GetFormInternal
(
)
;
nsGenericHTMLFormElement
:
:
UpdateFormOwner
(
aBindToTree
aFormIdElement
)
;
HTMLFormElement
*
newForm
=
GetFormInternal
(
)
;
if
(
newForm
!
=
oldForm
)
{
LifecycleCallbackArgs
args
;
args
.
mForm
=
newForm
;
nsContentUtils
:
:
EnqueueLifecycleCallback
(
ElementCallbackType
:
:
eFormAssociated
this
args
)
;
}
}
bool
HTMLElement
:
:
IsFormAssociatedElement
(
)
const
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
return
data
&
&
data
-
>
IsFormAssociated
(
)
;
}
void
HTMLElement
:
:
FieldSetDisabledChanged
(
bool
aNotify
)
{
nsGenericHTMLFormElement
:
:
FieldSetDisabledChanged
(
aNotify
)
;
UpdateBarredFromConstraintValidation
(
)
;
}
ElementInternals
*
HTMLElement
:
:
GetElementInternals
(
)
const
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
if
(
!
data
|
|
!
data
-
>
IsFormAssociated
(
)
)
{
return
nullptr
;
}
return
data
-
>
GetElementInternals
(
)
;
}
void
HTMLElement
:
:
UpdateBarredFromConstraintValidation
(
)
{
CustomElementData
*
data
=
GetCustomElementData
(
)
;
if
(
data
&
&
data
-
>
IsFormAssociated
(
)
)
{
ElementInternals
*
internals
=
data
-
>
GetElementInternals
(
)
;
MOZ_ASSERT
(
internals
)
;
internals
-
>
UpdateBarredFromConstraintValidation
(
)
;
}
}
}
nsGenericHTMLElement
*
NS_NewHTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
mozilla
:
:
dom
:
:
HTMLElement
(
nodeInfo
.
forget
(
)
aFromParser
)
;
}
nsGenericHTMLElement
*
NS_NewCustomElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
mozilla
:
:
dom
:
:
HTMLElement
(
nodeInfo
.
forget
(
)
aFromParser
)
;
}
