#
if
!
defined
(
mozilla_dom_HTMLCanvasElement_h
)
#
define
mozilla_dom_HTMLCanvasElement_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContextHelper
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
class
nsICanvasRenderingContextInternal
;
class
nsIInputStream
;
class
nsITimerCallback
;
enum
class
gfxAlphaType
;
enum
class
FrameCaptureState
:
uint8_t
;
namespace
mozilla
{
class
nsDisplayListBuilder
;
class
ClientWebGLContext
;
namespace
layers
{
class
CanvasRenderer
;
class
Image
;
class
ImageContainer
;
class
Layer
;
class
LayerManager
;
class
OOPCanvasRenderer
;
class
SharedSurfaceTextureClient
;
class
WebRenderCanvasData
;
}
namespace
gfx
{
class
DrawTarget
;
class
SourceSurface
;
class
VRLayerChild
;
}
namespace
webgpu
{
class
CanvasContext
;
}
namespace
dom
{
class
BlobCallback
;
class
CanvasCaptureMediaStream
;
class
File
;
class
HTMLCanvasPrintState
;
class
OffscreenCanvas
;
class
OffscreenCanvasDisplayHelper
;
class
PrintCallback
;
class
PWebGLChild
;
class
RequestedFrameRefreshObserver
;
class
HTMLCanvasElementObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
explicit
HTMLCanvasElementObserver
(
HTMLCanvasElement
*
aElement
)
;
void
Destroy
(
)
;
void
RegisterObserverEvents
(
)
;
void
UnregisterObserverEvents
(
)
;
private
:
~
HTMLCanvasElementObserver
(
)
;
HTMLCanvasElement
*
mElement
;
}
;
class
FrameCaptureListener
:
public
SupportsWeakPtr
{
public
:
FrameCaptureListener
(
)
=
default
;
virtual
bool
FrameCaptureRequested
(
const
TimeStamp
&
aTime
)
const
=
0
;
virtual
void
NewFrame
(
already_AddRefed
<
layers
:
:
Image
>
aImage
const
TimeStamp
&
aTime
)
=
0
;
protected
:
virtual
~
FrameCaptureListener
(
)
=
default
;
}
;
class
HTMLCanvasElement
final
:
public
nsGenericHTMLElement
public
CanvasRenderingContextHelper
public
SupportsWeakPtr
{
enum
{
DEFAULT_CANVAS_WIDTH
=
300
DEFAULT_CANVAS_HEIGHT
=
150
}
;
typedef
layers
:
:
CanvasRenderer
CanvasRenderer
;
typedef
layers
:
:
LayerManager
LayerManager
;
typedef
layers
:
:
WebRenderCanvasData
WebRenderCanvasData
;
public
:
explicit
HTMLCanvasElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
NS_IMPL_FROMNODE_HTML_WITH_TAG
(
HTMLCanvasElement
canvas
)
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLCanvasElement
nsGenericHTMLElement
)
uint32_t
Height
(
)
{
return
GetUnsignedIntAttr
(
nsGkAtoms
:
:
height
DEFAULT_CANVAS_HEIGHT
)
;
}
uint32_t
Width
(
)
{
return
GetUnsignedIntAttr
(
nsGkAtoms
:
:
width
DEFAULT_CANVAS_WIDTH
)
;
}
void
SetHeight
(
uint32_t
aHeight
ErrorResult
&
aRv
)
;
void
SetWidth
(
uint32_t
aWidth
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsISupports
>
GetContext
(
JSContext
*
aCx
const
nsAString
&
aContextId
JS
:
:
Handle
<
JS
:
:
Value
>
aContextOptions
ErrorResult
&
aRv
)
;
void
ToDataURL
(
JSContext
*
aCx
const
nsAString
&
aType
JS
:
:
Handle
<
JS
:
:
Value
>
aParams
nsAString
&
aDataURL
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
void
ToBlob
(
JSContext
*
aCx
BlobCallback
&
aCallback
const
nsAString
&
aType
JS
:
:
Handle
<
JS
:
:
Value
>
aParams
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
OffscreenCanvas
*
TransferControlToOffscreen
(
ErrorResult
&
aRv
)
;
bool
MozOpaque
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
moz_opaque
)
;
}
void
SetMozOpaque
(
bool
aValue
ErrorResult
&
aRv
)
{
if
(
mOffscreenCanvas
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
SetHTMLBoolAttr
(
nsGkAtoms
:
:
moz_opaque
aValue
aRv
)
;
}
PrintCallback
*
GetMozPrintCallback
(
)
const
;
void
SetMozPrintCallback
(
PrintCallback
*
aCallback
)
;
already_AddRefed
<
CanvasCaptureMediaStream
>
CaptureStream
(
const
Optional
<
double
>
&
aFrameRate
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
;
nsIntSize
GetSize
(
)
;
bool
IsWriteOnly
(
)
const
;
void
SetWriteOnly
(
nsIPrincipal
*
aExpandedReader
=
nullptr
)
;
void
InvalidateCanvasPlaceholder
(
uint32_t
aWidth
uint32_t
aHeight
)
;
void
InvalidateCanvasContent
(
const
mozilla
:
:
gfx
:
:
Rect
*
aDamageRect
)
;
void
InvalidateCanvas
(
)
;
nsICanvasRenderingContextInternal
*
GetCurrentContext
(
)
{
return
mCurrentContext
;
}
bool
GetIsOpaque
(
)
;
virtual
bool
GetOpaqueAttr
(
)
override
;
virtual
already_AddRefed
<
gfx
:
:
SourceSurface
>
GetSurfaceSnapshot
(
gfxAlphaType
*
aOutAlphaType
=
nullptr
gfx
:
:
DrawTarget
*
aTarget
=
nullptr
)
;
nsresult
RegisterFrameCaptureListener
(
FrameCaptureListener
*
aListener
bool
aReturnPlaceholderData
)
;
bool
IsFrameCaptureRequested
(
const
TimeStamp
&
aTime
)
const
;
void
ProcessDestroyedFrameListeners
(
)
;
void
SetFrameCapture
(
already_AddRefed
<
gfx
:
:
SourceSurface
>
aSurface
const
TimeStamp
&
aTime
)
;
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
override
;
nsChangeHint
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
override
;
nsMapRuleToAttributesFunc
GetAttributeMappingFunction
(
)
const
override
;
virtual
nsresult
Clone
(
dom
:
:
NodeInfo
*
nsINode
*
*
aResult
)
const
override
;
nsresult
CopyInnerTo
(
HTMLCanvasElement
*
aDest
)
;
static
void
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
)
;
already_AddRefed
<
layers
:
:
Image
>
GetAsImage
(
)
;
bool
UpdateWebRenderCanvasData
(
nsDisplayListBuilder
*
aBuilder
WebRenderCanvasData
*
aCanvasData
)
;
bool
InitializeCanvasRenderer
(
nsDisplayListBuilder
*
aBuilder
CanvasRenderer
*
aRenderer
)
;
void
MarkContextClean
(
)
;
void
MarkContextCleanForFrameCapture
(
)
;
Watchable
<
FrameCaptureState
>
*
GetFrameCaptureState
(
)
;
nsresult
GetContext
(
const
nsAString
&
aContextId
nsISupports
*
*
aContext
)
;
layers
:
:
LayersBackend
GetCompositorBackendType
(
)
const
;
void
OnMemoryPressure
(
)
;
void
OnDeviceReset
(
)
;
already_AddRefed
<
layers
:
:
SharedSurfaceTextureClient
>
GetVRFrame
(
)
;
void
ClearVRFrame
(
)
;
bool
MaybeModified
(
)
const
{
return
mMaybeModified
;
}
;
protected
:
virtual
~
HTMLCanvasElement
(
)
;
void
Destroy
(
)
;
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
nsIntSize
GetWidthHeight
(
)
override
;
virtual
already_AddRefed
<
nsICanvasRenderingContextInternal
>
CreateContext
(
CanvasContextType
aContextType
)
override
;
nsresult
ExtractData
(
JSContext
*
aCx
nsIPrincipal
&
aSubjectPrincipal
nsAString
&
aType
const
nsAString
&
aOptions
nsIInputStream
*
*
aStream
)
;
nsresult
ToDataURLImpl
(
JSContext
*
aCx
nsIPrincipal
&
aSubjectPrincipal
const
nsAString
&
aMimeType
const
JS
:
:
Value
&
aEncoderOptions
nsAString
&
aDataURL
)
;
MOZ_CAN_RUN_SCRIPT
void
CallPrintCallback
(
)
;
virtual
void
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
override
;
virtual
void
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
override
;
public
:
ClientWebGLContext
*
GetWebGLContext
(
)
;
webgpu
:
:
CanvasContext
*
GetWebGPUContext
(
)
;
bool
IsOffscreen
(
)
const
{
return
!
!
mOffscreenCanvas
;
}
OffscreenCanvas
*
GetOffscreenCanvas
(
)
const
{
return
mOffscreenCanvas
;
}
layers
:
:
ImageContainer
*
GetImageContainer
(
)
const
{
return
mImageContainer
;
}
protected
:
bool
mResetLayer
;
bool
mMaybeModified
;
RefPtr
<
HTMLCanvasElement
>
mOriginalCanvas
;
RefPtr
<
PrintCallback
>
mPrintCallback
;
RefPtr
<
HTMLCanvasPrintState
>
mPrintState
;
nsTArray
<
WeakPtr
<
FrameCaptureListener
>
>
mRequestedFrameListeners
;
RefPtr
<
RequestedFrameRefreshObserver
>
mRequestedFrameRefreshObserver
;
RefPtr
<
CanvasRenderer
>
mCanvasRenderer
;
RefPtr
<
OffscreenCanvas
>
mOffscreenCanvas
;
RefPtr
<
OffscreenCanvasDisplayHelper
>
mOffscreenDisplay
;
RefPtr
<
layers
:
:
ImageContainer
>
mImageContainer
;
RefPtr
<
HTMLCanvasElementObserver
>
mContextObserver
;
public
:
bool
mWriteOnly
;
RefPtr
<
nsIPrincipal
>
mExpandedReader
;
bool
CallerCanRead
(
JSContext
*
aCx
)
const
;
bool
IsPrintCallbackDone
(
)
;
void
HandlePrintCallback
(
nsPresContext
*
)
;
nsresult
DispatchPrintCallback
(
nsITimerCallback
*
aCallback
)
;
void
ResetPrintCallback
(
)
;
HTMLCanvasElement
*
GetOriginalCanvas
(
)
;
CanvasContextType
GetCurrentContextType
(
)
;
private
:
void
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
;
}
;
class
HTMLCanvasPrintState
final
:
public
nsWrapperCache
{
public
:
HTMLCanvasPrintState
(
HTMLCanvasElement
*
aCanvas
nsICanvasRenderingContextInternal
*
aContext
nsITimerCallback
*
aCallback
)
;
nsISupports
*
Context
(
)
const
;
void
Done
(
)
;
void
NotifyDone
(
)
;
bool
mIsDone
;
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
HTMLCanvasPrintState
)
NS_DECL_CYCLE_COLLECTION_NATIVE_WRAPPERCACHE_CLASS
(
HTMLCanvasPrintState
)
virtual
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
HTMLCanvasElement
*
GetParentObject
(
)
{
return
mCanvas
;
}
private
:
~
HTMLCanvasPrintState
(
)
;
bool
mPendingNotify
;
protected
:
RefPtr
<
HTMLCanvasElement
>
mCanvas
;
nsCOMPtr
<
nsICanvasRenderingContextInternal
>
mContext
;
nsCOMPtr
<
nsITimerCallback
>
mCallback
;
}
;
}
}
#
endif
