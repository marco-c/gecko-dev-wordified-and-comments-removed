#
include
"
mozilla
/
dom
/
ElementInternals
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
mozilla
/
dom
/
ElementInternalsBinding
.
h
"
#
include
"
mozilla
/
dom
/
FormData
.
h
"
#
include
"
mozilla
/
dom
/
HTMLElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFieldSetElement
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
ValidityState
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
ElementInternals
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ElementInternals
)
tmp
-
>
Unlink
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTarget
mSubmissionValue
mState
mValidity
mValidationAnchor
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
ElementInternals
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTarget
mSubmissionValue
mState
mValidity
mValidationAnchor
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ElementInternals
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ElementInternals
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ElementInternals
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIFormControl
)
NS_INTERFACE_MAP_ENTRY
(
nsIConstraintValidation
)
NS_INTERFACE_MAP_END
ElementInternals
:
:
ElementInternals
(
HTMLElement
*
aTarget
)
:
nsIFormControl
(
FormControlType
:
:
FormAssociatedCustomElement
)
mTarget
(
aTarget
)
mForm
(
nullptr
)
mFieldSet
(
nullptr
)
{
}
nsISupports
*
ElementInternals
:
:
GetParentObject
(
)
{
return
ToSupports
(
mTarget
)
;
}
JSObject
*
ElementInternals
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ElementInternals_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
ShadowRoot
*
ElementInternals
:
:
GetShadowRoot
(
)
const
{
MOZ_ASSERT
(
mTarget
)
;
ShadowRoot
*
shadowRoot
=
mTarget
-
>
GetShadowRoot
(
)
;
if
(
shadowRoot
&
&
!
shadowRoot
-
>
IsAvailableToElementInternals
(
)
)
{
return
nullptr
;
}
return
shadowRoot
;
}
void
ElementInternals
:
:
SetFormValue
(
const
Nullable
<
FileOrUSVStringOrFormData
>
&
aValue
const
Optional
<
Nullable
<
FileOrUSVStringOrFormData
>
>
&
aState
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
;
}
mSubmissionValue
.
SetNull
(
)
;
if
(
!
aValue
.
IsNull
(
)
)
{
const
FileOrUSVStringOrFormData
&
value
=
aValue
.
Value
(
)
;
OwningFileOrUSVStringOrFormData
&
owningValue
=
mSubmissionValue
.
SetValue
(
)
;
if
(
value
.
IsFormData
(
)
)
{
owningValue
.
SetAsFormData
(
)
=
value
.
GetAsFormData
(
)
.
Clone
(
)
;
}
else
if
(
value
.
IsFile
(
)
)
{
owningValue
.
SetAsFile
(
)
=
&
value
.
GetAsFile
(
)
;
}
else
{
owningValue
.
SetAsUSVString
(
)
=
value
.
GetAsUSVString
(
)
;
}
}
if
(
!
aState
.
WasPassed
(
)
)
{
mState
=
mSubmissionValue
;
return
;
}
mState
.
SetNull
(
)
;
if
(
!
aState
.
Value
(
)
.
IsNull
(
)
)
{
const
FileOrUSVStringOrFormData
&
state
=
aState
.
Value
(
)
.
Value
(
)
;
OwningFileOrUSVStringOrFormData
&
owningState
=
mState
.
SetValue
(
)
;
if
(
state
.
IsFormData
(
)
)
{
owningState
.
SetAsFormData
(
)
=
state
.
GetAsFormData
(
)
.
Clone
(
)
;
}
else
if
(
state
.
IsFile
(
)
)
{
owningState
.
SetAsFile
(
)
=
&
state
.
GetAsFile
(
)
;
}
else
{
owningState
.
SetAsUSVString
(
)
=
state
.
GetAsUSVString
(
)
;
}
}
}
HTMLFormElement
*
ElementInternals
:
:
GetForm
(
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
nullptr
;
}
return
GetForm
(
)
;
}
void
ElementInternals
:
:
SetValidity
(
const
ValidityStateFlags
&
aFlags
const
Optional
<
nsAString
>
&
aMessage
const
Optional
<
NonNull
<
nsGenericHTMLElement
>
>
&
aAnchor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
;
}
if
(
(
aFlags
.
mBadInput
|
|
aFlags
.
mCustomError
|
|
aFlags
.
mPatternMismatch
|
|
aFlags
.
mRangeOverflow
|
|
aFlags
.
mRangeUnderflow
|
|
aFlags
.
mStepMismatch
|
|
aFlags
.
mTooLong
|
|
aFlags
.
mTooShort
|
|
aFlags
.
mTypeMismatch
|
|
aFlags
.
mValueMissing
)
&
&
(
!
aMessage
.
WasPassed
(
)
|
|
aMessage
.
Value
(
)
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
Need
to
provide
validation
message
"
)
;
return
;
}
SetValidityState
(
VALIDITY_STATE_VALUE_MISSING
aFlags
.
mValueMissing
)
;
SetValidityState
(
VALIDITY_STATE_TYPE_MISMATCH
aFlags
.
mTypeMismatch
)
;
SetValidityState
(
VALIDITY_STATE_PATTERN_MISMATCH
aFlags
.
mPatternMismatch
)
;
SetValidityState
(
VALIDITY_STATE_TOO_LONG
aFlags
.
mTooLong
)
;
SetValidityState
(
VALIDITY_STATE_TOO_SHORT
aFlags
.
mTooShort
)
;
SetValidityState
(
VALIDITY_STATE_RANGE_UNDERFLOW
aFlags
.
mRangeUnderflow
)
;
SetValidityState
(
VALIDITY_STATE_RANGE_OVERFLOW
aFlags
.
mRangeOverflow
)
;
SetValidityState
(
VALIDITY_STATE_STEP_MISMATCH
aFlags
.
mStepMismatch
)
;
SetValidityState
(
VALIDITY_STATE_BAD_INPUT
aFlags
.
mBadInput
)
;
SetValidityState
(
VALIDITY_STATE_CUSTOM_ERROR
aFlags
.
mCustomError
)
;
mTarget
-
>
UpdateState
(
true
)
;
mValidationMessage
=
(
!
aMessage
.
WasPassed
(
)
|
|
IsValid
(
)
)
?
EmptyString
(
)
:
aMessage
.
Value
(
)
;
nsGenericHTMLElement
*
anchor
=
aAnchor
.
WasPassed
(
)
?
&
aAnchor
.
Value
(
)
:
nullptr
;
if
(
anchor
&
&
(
anchor
=
=
mTarget
|
|
!
anchor
-
>
IsShadowIncludingInclusiveDescendantOf
(
mTarget
)
)
)
{
aRv
.
ThrowNotFoundError
(
"
Validation
anchor
is
not
a
shadow
-
including
descendant
of
target
"
"
element
"
)
;
return
;
}
mValidationAnchor
=
anchor
;
}
bool
ElementInternals
:
:
GetWillValidate
(
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
false
;
}
return
WillValidate
(
)
;
}
ValidityState
*
ElementInternals
:
:
GetValidity
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
nullptr
;
}
return
Validity
(
)
;
}
void
ElementInternals
:
:
GetValidationMessage
(
nsAString
&
aValidationMessage
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
;
}
aValidationMessage
=
mValidationMessage
;
}
bool
ElementInternals
:
:
CheckValidity
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
false
;
}
return
nsIConstraintValidation
:
:
CheckValidity
(
*
mTarget
)
;
}
bool
ElementInternals
:
:
ReportValidity
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
false
;
}
bool
defaultAction
=
true
;
if
(
nsIConstraintValidation
:
:
CheckValidity
(
*
mTarget
&
defaultAction
)
)
{
return
true
;
}
if
(
!
defaultAction
)
{
return
false
;
}
AutoTArray
<
RefPtr
<
Element
>
1
>
invalidElements
;
invalidElements
.
AppendElement
(
mTarget
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mTarget
-
>
GetOwnerGlobal
(
)
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
detail
(
jsapi
.
cx
(
)
)
;
if
(
!
ToJSValue
(
jsapi
.
cx
(
)
invalidElements
&
detail
)
)
{
return
false
;
}
mTarget
-
>
UpdateState
(
true
)
;
RefPtr
<
CustomEvent
>
event
=
NS_NewDOMCustomEvent
(
mTarget
-
>
OwnerDoc
(
)
nullptr
nullptr
)
;
event
-
>
InitCustomEvent
(
jsapi
.
cx
(
)
u
"
MozInvalidForm
"
_ns
true
true
detail
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
mTarget
-
>
DispatchEvent
(
*
event
)
;
return
false
;
}
already_AddRefed
<
nsINodeList
>
ElementInternals
:
:
GetLabels
(
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
nullptr
;
}
return
mTarget
-
>
Labels
(
)
;
}
nsGenericHTMLElement
*
ElementInternals
:
:
GetValidationAnchor
(
ErrorResult
&
aRv
)
const
{
MOZ_ASSERT
(
mTarget
)
;
if
(
!
mTarget
-
>
IsFormAssociatedElement
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
Target
element
is
not
a
form
-
associated
custom
element
"
)
;
return
nullptr
;
}
return
mValidationAnchor
;
}
void
ElementInternals
:
:
SetForm
(
HTMLFormElement
*
aForm
)
{
mForm
=
aForm
;
}
void
ElementInternals
:
:
ClearForm
(
bool
aRemoveFromForm
bool
aUnbindOrDelete
)
{
if
(
mTarget
)
{
mTarget
-
>
ClearForm
(
aRemoveFromForm
aUnbindOrDelete
)
;
}
}
NS_IMETHODIMP
ElementInternals
:
:
Reset
(
)
{
if
(
mTarget
)
{
MOZ_ASSERT
(
mTarget
-
>
IsFormAssociatedElement
(
)
)
;
nsContentUtils
:
:
EnqueueLifecycleCallback
(
ElementCallbackType
:
:
eFormReset
mTarget
{
}
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ElementInternals
:
:
SubmitNamesValues
(
FormData
*
aFormData
)
{
if
(
!
mTarget
)
{
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
mTarget
-
>
IsFormAssociatedElement
(
)
)
;
if
(
!
mSubmissionValue
.
IsNull
(
)
)
{
if
(
mSubmissionValue
.
Value
(
)
.
IsFormData
(
)
)
{
aFormData
-
>
Append
(
mSubmissionValue
.
Value
(
)
.
GetAsFormData
(
)
)
;
return
NS_OK
;
}
nsAutoString
name
;
if
(
!
mTarget
-
>
GetAttr
(
nsGkAtoms
:
:
name
name
)
|
|
name
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
mSubmissionValue
.
Value
(
)
.
IsUSVString
(
)
)
{
return
aFormData
-
>
AddNameValuePair
(
name
mSubmissionValue
.
Value
(
)
.
GetAsUSVString
(
)
)
;
}
return
aFormData
-
>
AddNameBlobPair
(
name
mSubmissionValue
.
Value
(
)
.
GetAsFile
(
)
)
;
}
return
NS_OK
;
}
void
ElementInternals
:
:
UpdateFormOwner
(
)
{
if
(
mTarget
)
{
mTarget
-
>
UpdateFormOwner
(
)
;
}
}
void
ElementInternals
:
:
UpdateBarredFromConstraintValidation
(
)
{
if
(
mTarget
)
{
MOZ_ASSERT
(
mTarget
-
>
IsFormAssociatedElement
(
)
)
;
SetBarredFromConstraintValidation
(
mTarget
-
>
HasAttr
(
nsGkAtoms
:
:
readonly
)
|
|
mTarget
-
>
HasFlag
(
ELEMENT_IS_DATALIST_OR_HAS_DATALIST_ANCESTOR
)
|
|
mTarget
-
>
IsDisabled
(
)
)
;
}
}
void
ElementInternals
:
:
Unlink
(
)
{
if
(
mForm
)
{
ClearForm
(
true
true
)
;
}
if
(
mFieldSet
)
{
mFieldSet
-
>
RemoveElement
(
mTarget
)
;
mFieldSet
=
nullptr
;
}
}
void
ElementInternals
:
:
GetAttr
(
const
nsAtom
*
aName
nsAString
&
aResult
)
const
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
"
Should
have
empty
string
coming
in
"
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
aName
)
;
if
(
val
)
{
val
-
>
ToString
(
aResult
)
;
return
;
}
SetDOMStringToNull
(
aResult
)
;
}
nsresult
ElementInternals
:
:
SetAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
Document
*
document
=
mTarget
-
>
GetComposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
document
true
)
;
uint8_t
modType
=
mAttrs
.
HasAttr
(
kNameSpaceID_None
aName
)
?
MutationEvent_Binding
:
:
MODIFICATION
:
MutationEvent_Binding
:
:
ADDITION
;
MutationObservers
:
:
NotifyARIAAttributeDefaultWillChange
(
mTarget
aName
modType
)
;
bool
attrHadValue
;
nsAttrValue
attrValue
(
aValue
)
;
nsresult
rs
=
mAttrs
.
SetAndSwapAttr
(
aName
attrValue
&
attrHadValue
)
;
nsMutationGuard
:
:
DidMutate
(
)
;
MutationObservers
:
:
NotifyARIAAttributeDefaultChanged
(
mTarget
aName
modType
)
;
mTarget
-
>
UpdateState
(
true
)
;
return
rs
;
}
DocGroup
*
ElementInternals
:
:
GetDocGroup
(
)
{
return
mTarget
-
>
OwnerDoc
(
)
-
>
GetDocGroup
(
)
;
}
}
