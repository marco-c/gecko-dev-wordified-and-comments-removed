requestLongerTimeout
(
2
)
;
function
test
(
)
{
waitForExplicitFinish
(
)
;
runPass
(
"
file_bug1108547
-
2
.
html
"
function
(
)
{
runPass
(
"
file_bug1108547
-
3
.
html
"
function
(
)
{
finish
(
)
;
}
)
;
}
)
;
}
function
runPass
(
getterFile
finishedCallback
)
{
var
rootDir
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
dom
/
html
/
test
/
"
;
var
testBrowser
;
var
privateWin
;
function
whenDelayedStartupFinished
(
win
callback
)
{
let
topic
=
"
browser
-
delayed
-
startup
-
finished
"
;
Services
.
obs
.
addObserver
(
function
onStartup
(
aSubject
)
{
if
(
win
!
=
aSubject
)
return
;
Services
.
obs
.
removeObserver
(
onStartup
topic
)
;
executeSoon
(
callback
)
;
}
topic
)
;
}
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
rootDir
+
"
file_bug1108547
-
1
.
html
"
)
;
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
selectedBrowser
)
.
then
(
afterOpenCookieSetter
)
;
function
afterOpenCookieSetter
(
)
{
gBrowser
.
removeCurrentTab
(
)
;
privateWin
=
OpenBrowserWindow
(
{
private
:
true
}
)
;
whenDelayedStartupFinished
(
privateWin
afterPrivateWindowOpened
)
;
}
function
afterPrivateWindowOpened
(
)
{
privateWin
.
gBrowser
.
selectedTab
=
privateWin
.
gBrowser
.
addTab
(
rootDir
+
getterFile
)
;
testBrowser
=
privateWin
.
gBrowser
.
selectedBrowser
;
privateWin
.
gBrowser
.
tabContainer
.
addEventListener
(
"
TabOpen
"
onNewTabOpened
true
)
;
}
function
fetchResult
(
)
{
return
ContentTask
.
spawn
(
testBrowser
null
function
(
)
{
return
content
.
document
.
getElementById
(
"
result
"
)
.
textContent
;
}
)
;
}
function
onNewTabOpened
(
)
{
privateWin
.
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabOpen
"
onNewTabOpened
true
)
;
BrowserTestUtils
.
browserLoaded
(
privateWin
.
gBrowser
.
tabs
[
privateWin
.
gBrowser
.
tabs
.
length
-
1
]
.
linkedBrowser
)
.
then
(
fetchResult
)
.
then
(
onNewTabLoaded
)
;
}
function
onNewTabLoaded
(
result
)
{
is
(
result
"
"
"
Shouldn
'
t
have
access
to
the
cookies
"
)
;
privateWin
.
close
(
)
;
Cc
[
"
mozilla
.
org
/
cookiemanager
;
1
"
]
.
getService
(
Ci
.
nsICookieManager
)
.
removeAll
(
)
;
privateWin
=
OpenBrowserWindow
(
{
private
:
true
}
)
;
whenDelayedStartupFinished
(
privateWin
afterPrivateWindowOpened2
)
;
}
function
afterPrivateWindowOpened2
(
)
{
privateWin
.
gBrowser
.
selectedTab
=
privateWin
.
gBrowser
.
addTab
(
rootDir
+
"
file_bug1108547
-
1
.
html
"
)
;
BrowserTestUtils
.
browserLoaded
(
privateWin
.
gBrowser
.
selectedBrowser
)
.
then
(
afterOpenCookieSetter2
)
;
}
function
afterOpenCookieSetter2
(
)
{
privateWin
.
close
(
)
;
gBrowser
.
selectedTab
=
BrowserTestUtils
.
addTab
(
gBrowser
rootDir
+
getterFile
)
;
testBrowser
=
gBrowser
.
selectedBrowser
;
gBrowser
.
tabContainer
.
addEventListener
(
"
TabOpen
"
onNewTabOpened2
true
)
;
}
function
onNewTabOpened2
(
)
{
gBrowser
.
tabContainer
.
removeEventListener
(
"
TabOpen
"
onNewTabOpened2
true
)
;
BrowserTestUtils
.
browserLoaded
(
gBrowser
.
tabs
[
gBrowser
.
tabs
.
length
-
1
]
.
linkedBrowser
)
.
then
(
fetchResult
)
.
then
(
onNewTabLoaded2
)
;
}
function
onNewTabLoaded2
(
result
)
{
is
(
result
"
"
"
Shouldn
'
t
have
access
to
the
cookies
"
)
;
gBrowser
.
removeCurrentTab
(
)
;
gBrowser
.
removeCurrentTab
(
)
;
privateWin
=
null
;
testBrowser
=
null
;
finishedCallback
(
)
;
}
}
