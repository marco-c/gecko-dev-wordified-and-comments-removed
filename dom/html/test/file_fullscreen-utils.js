function
inFullscreenMode
(
win
)
{
return
(
win
.
innerWidth
=
=
win
.
screen
.
width
&
&
win
.
innerHeight
=
=
win
.
screen
.
height
)
;
}
function
inNormalMode
(
win
)
{
return
(
win
.
innerWidth
=
=
win
.
normalSize
.
w
&
&
win
.
innerHeight
=
=
win
.
normalSize
.
h
)
;
}
function
addFullscreenChangeContinuation
(
type
callback
inDoc
)
{
var
doc
=
inDoc
|
|
document
;
var
topWin
=
doc
.
defaultView
.
top
;
if
(
!
topWin
.
normalSize
)
{
topWin
.
normalSize
=
{
w
:
window
.
innerWidth
h
:
window
.
innerHeight
}
;
}
function
checkCondition
(
)
{
if
(
type
=
=
"
enter
"
)
{
return
inFullscreenMode
(
topWin
)
;
}
else
if
(
type
=
=
"
exit
"
)
{
return
topWin
.
document
.
fullscreenElement
|
|
inNormalMode
(
topWin
)
;
}
else
{
throw
"
'
type
'
must
be
either
'
enter
'
or
'
exit
'
.
"
;
}
}
function
invokeCallback
(
event
)
{
requestAnimationFrame
(
(
)
=
>
setTimeout
(
(
)
=
>
callback
(
event
)
0
)
0
)
;
}
function
onFullscreenChange
(
event
)
{
doc
.
removeEventListener
(
"
fullscreenchange
"
onFullscreenChange
)
;
if
(
checkCondition
(
)
)
{
invokeCallback
(
event
)
;
return
;
}
function
onResize
(
)
{
if
(
checkCondition
(
)
)
{
topWin
.
removeEventListener
(
"
resize
"
onResize
)
;
invokeCallback
(
event
)
;
}
}
topWin
.
addEventListener
(
"
resize
"
onResize
)
;
}
doc
.
addEventListener
(
"
fullscreenchange
"
onFullscreenChange
)
;
}
function
addFullscreenErrorContinuation
(
callback
inDoc
)
{
return
new
Promise
(
resolve
=
>
{
let
doc
=
inDoc
|
|
document
;
let
listener
=
function
(
event
)
{
doc
.
removeEventListener
(
"
fullscreenerror
"
listener
)
;
setTimeout
(
function
(
)
{
if
(
callback
)
{
callback
(
event
)
;
}
resolve
(
)
;
}
0
)
;
}
;
doc
.
addEventListener
(
"
fullscreenerror
"
listener
)
;
}
)
;
}
function
waitForLoadAndPaint
(
win
callback
)
{
win
.
addEventListener
(
"
MozAfterPaint
"
function
(
)
{
if
(
win
.
document
.
readyState
=
=
"
complete
"
)
{
callback
(
)
;
}
else
{
win
.
addEventListener
(
"
load
"
callback
{
once
:
true
}
)
;
}
}
{
once
:
true
}
)
;
}
