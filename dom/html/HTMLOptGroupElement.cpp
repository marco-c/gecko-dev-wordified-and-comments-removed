#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptGroupElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptGroupElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFormControlFrame
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
OptGroup
)
namespace
mozilla
{
namespace
dom
{
HTMLOptGroupElement
:
:
HTMLOptGroupElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsGenericHTMLElement
(
aNodeInfo
)
{
AddStatesSilently
(
NS_EVENT_STATE_ENABLED
)
;
}
HTMLOptGroupElement
:
:
~
HTMLOptGroupElement
(
)
{
}
NS_IMPL_ELEMENT_CLONE
(
HTMLOptGroupElement
)
void
HTMLOptGroupElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
false
;
if
(
IsDisabled
(
)
)
{
return
;
}
if
(
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
StyleUserInterface
(
)
-
>
mUserInput
=
=
StyleUserInput
:
:
None
)
{
return
;
}
}
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
Element
*
HTMLOptGroupElement
:
:
GetSelect
(
)
{
Element
*
parent
=
nsINode
:
:
GetParentElement
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
return
nullptr
;
}
return
parent
;
}
nsresult
HTMLOptGroupElement
:
:
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
{
int32_t
index
=
aBeforeThis
?
ComputeIndexOf
(
aBeforeThis
)
:
GetChildCount
(
)
;
SafeOptionListMutation
safeMutation
(
GetSelect
(
)
this
aKid
index
aNotify
)
;
nsresult
rv
=
nsGenericHTMLElement
:
:
InsertChildBefore
(
aKid
aBeforeThis
aNotify
)
;
if
(
NS_FAILED
(
rv
)
)
{
safeMutation
.
MutationFailed
(
)
;
}
return
rv
;
}
void
HTMLOptGroupElement
:
:
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
{
SafeOptionListMutation
safeMutation
(
GetSelect
(
)
this
nullptr
ComputeIndexOf
(
aKid
)
aNotify
)
;
nsGenericHTMLElement
:
:
RemoveChildNode
(
aKid
aNotify
)
;
}
nsresult
HTMLOptGroupElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
disabled
)
{
EventStates
disabledStates
;
if
(
aValue
)
{
disabledStates
|
=
NS_EVENT_STATE_DISABLED
;
}
else
{
disabledStates
|
=
NS_EVENT_STATE_ENABLED
;
}
EventStates
oldDisabledStates
=
State
(
)
&
DISABLED_STATES
;
EventStates
changedStates
=
disabledStates
^
oldDisabledStates
;
if
(
!
changedStates
.
IsEmpty
(
)
)
{
ToggleStates
(
changedStates
aNotify
)
;
for
(
nsIContent
*
child
=
nsINode
:
:
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
auto
optElement
=
HTMLOptionElement
:
:
FromNode
(
child
)
)
{
optElement
-
>
OptGroupDisabledChanged
(
true
)
;
}
}
}
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
JSObject
*
HTMLOptGroupElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLOptGroupElementBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
