#
ifndef
mozilla_dom_HTMLMediaElement_h
#
define
mozilla_dom_HTMLMediaElement_h
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
AudioChannelService
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
SeekTarget
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaElementEventRunners
.
h
"
#
include
"
MediaPlaybackDelayPolicy
.
h
"
#
include
"
MediaPromiseDefs
.
h
"
#
include
"
TelemetryProbesReporter
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
Visibility
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
DecoderTraits
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
DecoderDoctorNotificationBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaDebugInfoBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaKeys
.
h
"
#
include
"
mozilla
/
dom
/
TextTrackManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
MediaSegment
.
h
"
#
include
<
utility
>
#
ifdef
CurrentTime
#
undef
CurrentTime
#
endif
using
nsMediaNetworkState
=
uint16_t
;
using
nsMediaReadyState
=
uint16_t
;
using
SuspendTypes
=
uint32_t
;
using
AudibleChangedReasons
=
uint32_t
;
class
nsIStreamListener
;
namespace
mozilla
{
class
AbstractThread
;
class
ChannelMediaDecoder
;
class
DecoderDoctorDiagnostics
;
class
DOMMediaStream
;
class
ErrorResult
;
class
FirstFrameVideoOutput
;
class
MediaResource
;
class
MediaDecoder
;
class
MediaInputPort
;
class
MediaTrack
;
class
MediaTrackGraph
;
class
MediaStreamWindowCapturer
;
struct
SharedDummyTrack
;
class
VideoFrameContainer
;
class
VideoOutput
;
namespace
dom
{
class
HTMLSourceElement
;
class
MediaKeys
;
class
TextTrack
;
class
TimeRanges
;
class
WakeLock
;
class
MediaStreamTrack
;
class
MediaStreamTrackSource
;
class
MediaTrack
;
class
VideoStreamTrack
;
}
}
class
AudioDeviceInfo
;
class
nsIChannel
;
class
nsIHttpChannel
;
class
nsILoadGroup
;
class
nsIRunnable
;
class
nsISerialEventTarget
;
class
nsITimer
;
class
nsRange
;
namespace
mozilla
:
:
dom
{
#
define
TIMEUPDATE_MS
250
class
HTMLVideoElement
;
class
MediaError
;
class
MediaSource
;
class
PlayPromise
;
class
Promise
;
class
TextTrackList
;
class
AudioTrackList
;
class
VideoTrackList
;
enum
class
StreamCaptureType
:
uint8_t
{
CAPTURE_ALL_TRACKS
CAPTURE_AUDIO
}
;
enum
class
StreamCaptureBehavior
:
uint8_t
{
CONTINUE_WHEN_ENDED
FINISH_WHEN_ENDED
}
;
class
HTMLMediaElement
:
public
nsGenericHTMLElement
public
MediaDecoderOwner
public
PrincipalChangeObserver
<
MediaStreamTrack
>
public
SupportsWeakPtr
public
nsStubMutationObserver
public
TelemetryProbesReporterOwner
{
public
:
using
TimeStamp
=
mozilla
:
:
TimeStamp
;
using
ImageContainer
=
mozilla
:
:
layers
:
:
ImageContainer
;
using
VideoFrameContainer
=
mozilla
:
:
VideoFrameContainer
;
using
MediaResource
=
mozilla
:
:
MediaResource
;
using
MediaDecoderOwner
=
mozilla
:
:
MediaDecoderOwner
;
using
MetadataTags
=
mozilla
:
:
MetadataTags
;
struct
OutputMediaStream
{
OutputMediaStream
(
RefPtr
<
DOMMediaStream
>
aStream
bool
aCapturingAudioOnly
bool
aFinishWhenEnded
)
;
~
OutputMediaStream
(
)
;
RefPtr
<
DOMMediaStream
>
mStream
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
mLiveTracks
;
const
bool
mCapturingAudioOnly
;
const
bool
mFinishWhenEnded
;
nsCOMPtr
<
nsIURI
>
mFinishWhenEndedLoadingSrc
;
RefPtr
<
DOMMediaStream
>
mFinishWhenEndedAttrStream
;
RefPtr
<
MediaSource
>
mFinishWhenEndedMediaSource
;
}
;
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
CORSMode
GetCORSMode
(
)
{
return
mCORSMode
;
}
explicit
HTMLMediaElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
void
Init
(
)
;
virtual
HTMLVideoElement
*
AsHTMLVideoElement
(
)
{
return
nullptr
;
}
;
enum
class
TimeupdateType
:
bool
{
eMandatory
=
false
ePeriodic
=
true
}
;
enum
class
EventFlag
:
uint8_t
{
eNone
=
0
eMandatory
=
1
}
;
nsresult
LoadWithChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
NS_IMPL_FROMNODE_HELPER
(
HTMLMediaElement
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
video
nsGkAtoms
:
:
audio
)
)
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
void
NodeInfoChanged
(
Document
*
aOldDoc
)
override
;
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
nsresult
BindToTree
(
BindContext
&
nsINode
&
aParent
)
override
;
void
UnbindFromTree
(
UnbindContext
&
)
override
;
void
DoneCreatingElement
(
)
override
;
bool
IsHTMLFocusable
(
IsFocusableFlags
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
override
;
int32_t
TabIndexDefault
(
)
override
;
void
MetadataLoaded
(
const
MediaInfo
*
aInfo
UniquePtr
<
const
MetadataTags
>
aTags
)
final
;
void
FirstFrameLoaded
(
)
final
;
void
NetworkError
(
const
MediaResult
&
aError
)
final
;
void
DecodeError
(
const
MediaResult
&
aError
)
final
;
void
DecodeWarning
(
const
MediaResult
&
aError
)
final
;
bool
HasError
(
)
const
final
;
void
LoadAborted
(
)
final
;
void
PlaybackEnded
(
)
final
;
void
SeekStarted
(
)
final
;
void
SeekCompleted
(
)
final
;
void
SeekAborted
(
)
final
;
void
DownloadSuspended
(
)
final
;
void
DownloadResumed
(
)
;
void
DownloadProgressed
(
)
final
;
void
NotifySuspendedByCache
(
bool
aSuspendedByCache
)
final
;
bool
IsActuallyInvisible
(
)
const
override
;
bool
IsInViewPort
(
)
const
;
VideoFrameContainer
*
GetVideoFrameContainer
(
)
final
;
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
void
NotifyOwnerDocumentActivityChanged
(
)
;
void
NotifyFullScreenChanged
(
)
;
bool
IsInFullScreen
(
)
const
;
void
PrincipalChanged
(
MediaStreamTrack
*
aTrack
)
override
;
void
UpdateSrcStreamVideoPrincipal
(
const
PrincipalHandle
&
aPrincipalHandle
)
;
void
PrincipalHandleChangedForVideoFrameContainer
(
VideoFrameContainer
*
aContainer
const
PrincipalHandle
&
aNewPrincipalHandle
)
override
;
void
DispatchAsyncEvent
(
const
nsAString
&
aName
)
final
;
void
DispatchAsyncEvent
(
RefPtr
<
nsMediaEventRunner
>
aRunner
)
;
void
UpdateReadyState
(
)
override
{
mWatchManager
.
ManualNotify
(
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
}
nsresult
DispatchPendingMediaEvents
(
)
;
bool
IsEligibleForAutoplay
(
)
;
void
CheckAutoplayDataReady
(
)
;
void
RunAutoplay
(
)
;
bool
ShouldCheckAllowOrigin
(
)
;
bool
IsCORSSameOrigin
(
)
;
bool
IsPotentiallyPlaying
(
)
const
;
bool
IsPlaybackEnded
(
)
const
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
;
bool
HadCrossOriginRedirects
(
)
;
bool
ShouldResistFingerprinting
(
RFPTarget
aTarget
)
const
override
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentVideoPrincipal
(
)
;
void
NotifyDecoderPrincipalChanged
(
)
final
;
void
GetEMEInfo
(
dom
:
:
EMEDebugInfo
&
aInfo
)
;
virtual
void
UpdateMediaSize
(
const
nsIntSize
&
aSize
)
;
void
Invalidate
(
ImageSizeChanged
aImageSizeChanged
const
Maybe
<
nsIntSize
>
&
aNewIntrinsicSize
ForceInvalidate
aForceInvalidate
)
override
;
static
CanPlayStatus
GetCanPlay
(
const
nsAString
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
;
void
NotifyAddedSource
(
)
;
void
NotifyLoadError
(
const
nsACString
&
aErrorDetails
=
nsCString
(
)
)
;
void
NotifyMediaTrackAdded
(
dom
:
:
MediaTrack
*
aTrack
)
;
void
NotifyMediaTrackRemoved
(
dom
:
:
MediaTrack
*
aTrack
)
;
void
NotifyMediaTrackEnabled
(
dom
:
:
MediaTrack
*
aTrack
)
;
void
NotifyMediaTrackDisabled
(
dom
:
:
MediaTrack
*
aTrack
)
;
uint32_t
GetCurrentLoadID
(
)
const
{
return
mCurrentLoadID
;
}
already_AddRefed
<
nsILoadGroup
>
GetDocumentLoadGroup
(
)
;
bool
GetPlayedOrSeeked
(
)
const
{
return
mHasPlayedOrSeeked
;
}
nsresult
CopyInnerTo
(
Element
*
aDest
)
;
virtual
nsresult
SetAcceptHeader
(
nsIHttpChannel
*
aChannel
)
=
0
;
void
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
)
;
void
RunInStableState
(
nsIRunnable
*
aRunnable
)
;
void
FireTimeUpdate
(
TimeupdateType
aType
)
;
void
MaybeQueueTimeupdateEvent
(
)
final
{
FireTimeUpdate
(
TimeupdateType
:
:
ePeriodic
)
;
}
const
TimeStamp
&
LastTimeupdateDispatchTime
(
)
const
;
void
UpdateLastTimeupdateDispatchTime
(
)
;
MediaError
*
GetError
(
)
const
;
void
GetSrc
(
nsAString
&
aSrc
)
{
GetURIAttr
(
nsGkAtoms
:
:
src
nullptr
aSrc
)
;
}
void
SetSrc
(
const
nsAString
&
aSrc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aError
)
;
}
void
SetSrc
(
const
nsAString
&
aSrc
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aTriggeringPrincipal
aError
)
;
}
void
GetCurrentSrc
(
nsAString
&
aCurrentSrc
)
;
void
GetCrossOrigin
(
nsAString
&
aResult
)
{
GetEnumAttr
(
nsGkAtoms
:
:
crossorigin
nullptr
aResult
)
;
}
void
SetCrossOrigin
(
const
nsAString
&
aCrossOrigin
ErrorResult
&
aError
)
{
SetOrRemoveNullableStringAttr
(
nsGkAtoms
:
:
crossorigin
aCrossOrigin
aError
)
;
}
uint16_t
NetworkState
(
)
const
{
return
mNetworkState
;
}
void
NotifyXPCOMShutdown
(
)
final
;
void
SetAudibleState
(
bool
aAudible
)
final
;
void
NotifyAudioPlaybackChanged
(
AudibleChangedReasons
aReason
)
;
void
GetPreload
(
nsAString
&
aValue
)
{
if
(
mSrcAttrStream
)
{
nsGkAtoms
:
:
none
-
>
ToString
(
aValue
)
;
return
;
}
GetEnumAttr
(
nsGkAtoms
:
:
preload
nullptr
aValue
)
;
}
void
SetPreload
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
if
(
mSrcAttrStream
)
{
return
;
}
SetHTMLAttr
(
nsGkAtoms
:
:
preload
aValue
aRv
)
;
}
already_AddRefed
<
TimeRanges
>
Buffered
(
)
const
;
void
Load
(
)
;
void
CanPlayType
(
const
nsAString
&
aType
nsAString
&
aResult
)
;
uint16_t
ReadyState
(
)
const
{
return
mReadyState
;
}
bool
Seeking
(
)
const
;
double
CurrentTime
(
)
const
;
void
SetCurrentTime
(
double
aCurrentTime
ErrorResult
&
aRv
)
;
void
SetCurrentTime
(
double
aCurrentTime
)
{
SetCurrentTime
(
aCurrentTime
IgnoreErrors
(
)
)
;
}
void
FastSeek
(
double
aTime
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
SeekToNextFrame
(
ErrorResult
&
aRv
)
;
double
Duration
(
)
const
;
bool
HasAudio
(
)
const
{
return
mMediaInfo
.
HasAudio
(
)
;
}
virtual
bool
IsVideo
(
)
const
{
return
false
;
}
bool
HasVideo
(
)
const
{
return
mMediaInfo
.
HasVideo
(
)
;
}
bool
IsEncrypted
(
)
const
override
{
return
mIsEncrypted
;
}
#
ifdef
MOZ_WMF_CDM
bool
IsUsingWMFCDM
(
)
const
override
;
#
endif
bool
Paused
(
)
const
{
return
mPaused
;
}
double
DefaultPlaybackRate
(
)
const
{
if
(
mSrcAttrStream
)
{
return
1
.
0
;
}
return
mDefaultPlaybackRate
;
}
void
SetDefaultPlaybackRate
(
double
aDefaultPlaybackRate
ErrorResult
&
aRv
)
;
double
PlaybackRate
(
)
const
{
if
(
mSrcAttrStream
)
{
return
1
.
0
;
}
return
mPlaybackRate
;
}
void
SetPlaybackRate
(
double
aPlaybackRate
ErrorResult
&
aRv
)
;
already_AddRefed
<
TimeRanges
>
Played
(
)
;
already_AddRefed
<
TimeRanges
>
Seekable
(
)
const
;
bool
Ended
(
)
;
bool
Autoplay
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
autoplay
)
;
}
void
SetAutoplay
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
autoplay
aValue
aRv
)
;
}
bool
Loop
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
loop
)
;
}
void
SetLoop
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
loop
aValue
aRv
)
;
}
already_AddRefed
<
Promise
>
Play
(
ErrorResult
&
aRv
)
;
void
Play
(
)
{
IgnoredErrorResult
dummy
;
RefPtr
<
Promise
>
toBeIgnored
=
Play
(
dummy
)
;
}
void
Pause
(
ErrorResult
&
aRv
)
;
void
Pause
(
)
{
Pause
(
IgnoreErrors
(
)
)
;
}
bool
Controls
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
controls
)
;
}
void
SetControls
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
controls
aValue
aRv
)
;
}
double
Volume
(
)
const
{
return
mVolume
;
}
void
SetVolume
(
double
aVolume
ErrorResult
&
aRv
)
;
bool
Muted
(
)
const
{
return
mMuted
&
MUTED_BY_CONTENT
;
}
void
SetMuted
(
bool
aMuted
)
;
bool
DefaultMuted
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
muted
)
;
}
void
SetDefaultMuted
(
bool
aMuted
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
muted
aMuted
aRv
)
;
}
bool
MozAllowCasting
(
)
const
{
return
mAllowCasting
;
}
void
SetMozAllowCasting
(
bool
aShow
)
{
mAllowCasting
=
aShow
;
}
bool
MozIsCasting
(
)
const
{
return
mIsCasting
;
}
void
SetMozIsCasting
(
bool
aShow
)
{
mIsCasting
=
aShow
;
}
bool
AllowedToPlay
(
)
const
;
already_AddRefed
<
MediaSource
>
GetMozMediaSourceObject
(
)
const
;
already_AddRefed
<
Promise
>
MozRequestDebugInfo
(
ErrorResult
&
aRv
)
;
static
void
MozEnableDebugLog
(
const
GlobalObject
&
)
;
already_AddRefed
<
Promise
>
MozRequestDebugLog
(
ErrorResult
&
aRv
)
;
void
SetVisible
(
bool
aVisible
)
;
bool
HasSuspendTaint
(
)
const
;
bool
IsVideoDecodingSuspended
(
)
const
;
double
TotalVideoPlayTime
(
)
const
;
double
TotalVideoHDRPlayTime
(
)
const
;
double
VisiblePlayTime
(
)
const
;
double
InvisiblePlayTime
(
)
const
;
double
TotalAudioPlayTime
(
)
const
;
double
AudiblePlayTime
(
)
const
;
double
InaudiblePlayTime
(
)
const
;
double
MutedPlayTime
(
)
const
;
void
SetFormatDiagnosticsReportForMimeType
(
const
nsAString
&
aMimeType
DecoderDoctorReportType
aType
)
;
void
SetDecodeError
(
const
nsAString
&
aError
ErrorResult
&
aRv
)
;
void
SetAudioSinkFailedStartup
(
)
;
already_AddRefed
<
layers
:
:
Image
>
GetCurrentImage
(
)
;
already_AddRefed
<
DOMMediaStream
>
GetSrcObject
(
)
const
;
void
SetSrcObject
(
DOMMediaStream
&
aValue
)
;
void
SetSrcObject
(
DOMMediaStream
*
aValue
)
;
bool
PreservesPitch
(
)
const
{
return
mPreservesPitch
;
}
void
SetPreservesPitch
(
bool
aPreservesPitch
)
;
MediaKeys
*
GetMediaKeys
(
)
const
;
already_AddRefed
<
Promise
>
SetMediaKeys
(
MediaKeys
*
mediaKeys
ErrorResult
&
aRv
)
;
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOnencrypted
(
)
;
void
SetOnencrypted
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
aCallback
)
;
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOnwaitingforkey
(
)
;
void
SetOnwaitingforkey
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
aCallback
)
;
void
DispatchEncrypted
(
const
nsTArray
<
uint8_t
>
&
aInitData
const
nsAString
&
aInitDataType
)
override
;
bool
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
override
;
bool
ContainsRestrictedContent
(
)
const
;
void
NotifyWaitingForKey
(
)
override
;
already_AddRefed
<
DOMMediaStream
>
CaptureAudio
(
ErrorResult
&
aRv
MediaTrackGraph
*
aGraph
)
;
already_AddRefed
<
DOMMediaStream
>
MozCaptureStream
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMMediaStream
>
MozCaptureStreamUntilEnded
(
ErrorResult
&
aRv
)
;
bool
MozAudioCaptured
(
)
const
{
return
mAudioCaptured
;
}
void
MozGetMetadata
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aRv
)
;
double
MozFragmentEnd
(
)
;
AudioTrackList
*
AudioTracks
(
)
;
VideoTrackList
*
VideoTracks
(
)
;
TextTrackList
*
GetTextTracks
(
)
;
already_AddRefed
<
TextTrack
>
AddTextTrack
(
TextTrackKind
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
)
;
void
AddTextTrack
(
TextTrack
*
aTextTrack
)
{
GetOrCreateTextTrackManager
(
)
-
>
AddTextTrack
(
aTextTrack
)
;
}
void
RemoveTextTrack
(
TextTrack
*
aTextTrack
bool
aPendingListOnly
=
false
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
RemoveTextTrack
(
aTextTrack
aPendingListOnly
)
;
}
}
void
NotifyCueAdded
(
TextTrackCue
&
aCue
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyCueAdded
(
aCue
)
;
}
}
void
NotifyCueRemoved
(
TextTrackCue
&
aCue
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyCueRemoved
(
aCue
)
;
}
}
void
NotifyCueUpdated
(
TextTrackCue
*
aCue
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyCueUpdated
(
aCue
)
;
}
}
void
NotifyCueDisplayStatesChanged
(
)
;
bool
IsBlessed
(
)
const
{
return
mIsBlessed
;
}
bool
IsCurrentlyPlaying
(
)
const
;
bool
IsBeingDestroyed
(
)
;
virtual
void
OnVisibilityChange
(
Visibility
aNewVisibility
)
;
float
ComputedVolume
(
)
const
;
bool
ComputedMuted
(
)
const
;
bool
IsSuspendedByInactiveDocOrDocShell
(
)
const
;
void
SetMediaInfo
(
const
MediaInfo
&
aInfo
)
;
MediaInfo
GetMediaInfo
(
)
const
override
;
FrameStatistics
*
GetFrameStatistics
(
)
const
override
;
void
DispatchAsyncTestingEvent
(
const
nsAString
&
aName
)
override
;
enum
class
CallerAPI
{
DRAW_IMAGE
CREATE_PATTERN
CREATE_IMAGEBITMAP
CAPTURE_STREAM
CREATE_VIDEOFRAME
}
;
void
LogVisibility
(
CallerAPI
aAPI
)
;
Document
*
GetDocument
(
)
const
override
;
already_AddRefed
<
GMPCrashHelper
>
CreateGMPCrashHelper
(
)
override
;
already_AddRefed
<
Promise
>
SetSinkId
(
const
nsAString
&
aSinkId
ErrorResult
&
aRv
)
;
void
GetSinkId
(
nsString
&
aSinkId
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
aSinkId
=
mSink
.
first
;
}
RefPtr
<
GenericNonExclusivePromise
>
GetAllowedToPlayPromise
(
)
;
bool
GetShowPosterFlag
(
)
const
{
return
mShowPoster
;
}
bool
IsAudible
(
)
const
;
Maybe
<
nsAutoString
>
GetKeySystem
(
)
const
override
;
protected
:
virtual
~
HTMLMediaElement
(
)
;
class
AudioChannelAgentCallback
;
class
ChannelLoader
;
class
ErrorSink
;
class
MediaElementTrackSource
;
class
MediaLoadListener
;
class
MediaStreamRenderer
;
class
MediaStreamTrackListener
;
class
ShutdownObserver
;
class
TitleChangeObserver
;
class
MediaControlKeyListener
;
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
;
void
SetDecoder
(
MediaDecoder
*
aDecoder
)
;
void
PlayInternal
(
bool
aHandlingUserInput
)
;
void
PauseInternal
(
)
;
void
ChangeReadyState
(
nsMediaReadyState
aState
)
;
void
ChangeNetworkState
(
nsMediaNetworkState
aState
)
;
virtual
void
WakeLockRelease
(
)
;
virtual
void
UpdateWakeLock
(
)
;
void
CreateAudioWakeLockIfNeeded
(
)
;
void
ReleaseAudioWakeLockIfExists
(
)
;
RefPtr
<
WakeLock
>
mWakeLock
;
void
ReportLoadError
(
const
char
*
aMsg
const
nsTArray
<
nsString
>
&
aParams
=
nsTArray
<
nsString
>
(
)
)
;
void
ReportToConsole
(
uint32_t
aErrorFlags
const
char
*
aMsg
const
nsTArray
<
nsString
>
&
aParams
=
nsTArray
<
nsString
>
(
)
)
const
;
void
SetPlayedOrSeeked
(
bool
aValue
)
;
void
SetupSrcMediaStreamPlayback
(
DOMMediaStream
*
aStream
)
;
void
EndSrcMediaStreamPlayback
(
)
;
enum
{
REMOVING_SRC_STREAM
=
0x1
}
;
void
UpdateSrcMediaStreamPlaying
(
uint32_t
aFlags
=
0
)
;
void
UpdateSrcStreamPotentiallyPlaying
(
)
;
void
UpdateSrcStreamTime
(
)
;
void
UpdateSrcStreamReportPlaybackEnded
(
)
;
void
NotifyMediaStreamTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
;
void
NotifyMediaStreamTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
;
void
GetAllEnabledMediaTracks
(
nsTArray
<
RefPtr
<
MediaTrack
>
>
&
aTracks
)
;
void
SetCapturedOutputStreamsEnabled
(
bool
aEnabled
)
;
enum
class
OutputMuteState
{
Muted
Unmuted
}
;
OutputMuteState
OutputTracksMuted
(
)
;
void
UpdateOutputTracksMuting
(
)
;
enum
class
AddTrackMode
{
ASYNC
SYNC
}
;
void
AddOutputTrackSourceToOutputStream
(
MediaElementTrackSource
*
aSource
OutputMediaStream
&
aOutputStream
AddTrackMode
aMode
=
AddTrackMode
:
:
ASYNC
)
;
void
UpdateOutputTrackSources
(
)
;
already_AddRefed
<
DOMMediaStream
>
CaptureStreamInternal
(
StreamCaptureBehavior
aFinishBehavior
StreamCaptureType
aStreamCaptureType
MediaTrackGraph
*
aGraph
)
;
nsresult
InitializeDecoderAsClone
(
ChannelMediaDecoder
*
aOriginal
)
;
template
<
typename
DecoderType
typename
.
.
.
LoadArgs
>
nsresult
SetupDecoder
(
DecoderType
*
aDecoder
LoadArgs
&
&
.
.
.
aArgs
)
;
nsresult
InitializeDecoderForChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
;
nsresult
FinishDecoderSetup
(
MediaDecoder
*
aDecoder
)
;
void
AddMediaElementToURITable
(
)
;
void
RemoveMediaElementFromURITable
(
)
;
HTMLMediaElement
*
LookupMediaElementURITable
(
nsIURI
*
aURI
)
;
void
ShutdownDecoder
(
)
;
void
AbortExistingLoads
(
)
;
void
NoSupportedMediaSourceError
(
const
nsACString
&
aErrorDetails
=
nsCString
(
)
)
;
void
DealWithFailedElement
(
nsIContent
*
aSourceElement
)
;
void
LoadFromSourceChildren
(
)
;
void
QueueLoadFromSourceTask
(
)
;
void
SelectResource
(
)
;
void
SelectResourceWrapper
(
)
;
void
QueueSelectResourceTask
(
)
;
virtual
void
ResetState
(
)
;
MediaResult
LoadResource
(
)
;
HTMLSourceElement
*
GetNextSource
(
)
;
void
ChangeDelayLoadStatus
(
bool
aDelay
)
;
void
StopSuspendingAfterFirstFrame
(
)
;
nsresult
OnChannelRedirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
;
void
AddRemoveSelfReference
(
)
;
void
NotifyShutdownEvent
(
)
;
enum
PreloadAttrValue
:
uint8_t
{
PRELOAD_ATTR_EMPTY
PRELOAD_ATTR_NONE
PRELOAD_ATTR_METADATA
PRELOAD_ATTR_AUTO
}
;
enum
PreloadAction
{
PRELOAD_UNDEFINED
=
0
PRELOAD_NONE
=
1
PRELOAD_METADATA
=
2
PRELOAD_ENOUGH
=
3
}
;
void
DoLoad
(
)
;
void
SuspendLoad
(
)
;
void
ResumeLoad
(
PreloadAction
aAction
)
;
void
UpdatePreloadAction
(
)
;
void
CheckProgress
(
bool
aHaveNewProgress
)
;
static
void
ProgressTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
StartProgressTimer
(
)
;
void
StartProgress
(
)
;
void
StopProgress
(
)
;
void
DispatchAsyncSourceError
(
nsIContent
*
aSourceElement
const
nsACString
&
aErrorDetails
)
;
void
Error
(
uint16_t
aErrorCode
const
nsACString
&
aErrorDetails
=
nsCString
(
)
)
;
void
GetCurrentSpec
(
nsCString
&
aString
)
;
void
ProcessMediaFragmentURI
(
)
;
void
SetMutedInternal
(
uint32_t
aMuted
)
;
void
SetVolumeInternal
(
)
;
void
SuspendOrResumeElement
(
bool
aSuspendElement
)
;
HTMLMediaElement
*
GetMediaElement
(
)
final
{
return
this
;
}
bool
GetPaused
(
)
final
{
return
Paused
(
)
;
}
void
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
ErrorResult
&
aRv
)
;
void
UpdateAudioChannelPlayingState
(
)
;
void
PopulatePendingTextTrackList
(
)
;
TextTrackManager
*
GetOrCreateTextTrackManager
(
)
;
void
UpdateReadyStateInternal
(
)
;
void
AudioCaptureTrackChange
(
bool
aCapture
)
;
void
MaybeDoLoad
(
)
;
void
UpdateCustomPolicyAfterPlayed
(
)
;
StreamCaptureType
CaptureTypeForElement
(
)
;
bool
CanBeCaptured
(
StreamCaptureType
aCaptureType
)
;
using
nsGenericHTMLElement
:
:
DispatchEvent
;
nsresult
DispatchEvent
(
const
nsAString
&
aName
)
;
already_AddRefed
<
nsMediaEventRunner
>
GetEventRunner
(
const
nsAString
&
aName
EventFlag
aFlag
=
EventFlag
:
:
eNone
)
;
nsTArray
<
RefPtr
<
PlayPromise
>
>
TakePendingPlayPromises
(
)
;
void
AsyncResolvePendingPlayPromises
(
)
;
void
AsyncRejectPendingPlayPromises
(
nsresult
aError
)
;
void
NotifyAboutPlaying
(
)
;
already_AddRefed
<
Promise
>
CreateDOMPromise
(
ErrorResult
&
aRv
)
const
;
void
NotifyDecoderActivityChanges
(
)
const
;
void
ConstructMediaTracks
(
const
MediaInfo
*
aInfo
)
;
void
RemoveMediaTracks
(
)
;
void
MarkAsTainted
(
)
;
virtual
void
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
void
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
override
;
bool
DetachExistingMediaKeys
(
)
;
bool
TryRemoveMediaKeysAssociation
(
)
;
void
RemoveMediaKeys
(
)
;
bool
AttachNewMediaKeys
(
)
;
bool
TryMakeAssociationWithCDM
(
CDMProxy
*
aProxy
)
;
void
MakeAssociationWithCDMResolved
(
)
;
void
SetCDMProxyFailure
(
const
MediaResult
&
aResult
)
;
void
ResetSetMediaKeysTempVariables
(
)
;
void
PauseIfShouldNotBePlaying
(
)
;
WatchManager
<
HTMLMediaElement
>
mWatchManager
;
void
DispatchEventsWhenPlayWasNotAllowed
(
)
;
void
MaybeNotifyAutoplayBlocked
(
)
;
void
DispatchBlockEventForVideoControl
(
)
;
void
NotifyMediaControlPlaybackStateChanged
(
)
;
void
ClearStopMediaControlTimerIfNeeded
(
)
;
void
SetSecondaryMediaStreamRenderer
(
VideoFrameContainer
*
aContainer
FirstFrameVideoOutput
*
aFirstFrameOutput
=
nullptr
)
;
void
UpdateMediaControlAfterPictureInPictureModeChanged
(
)
;
virtual
bool
HasPendingCallbacks
(
)
const
{
return
false
;
}
RefPtr
<
MediaDecoder
>
mDecoder
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
RefPtr
<
DOMMediaStream
>
mSrcAttrStream
;
nsCOMPtr
<
nsIPrincipal
>
mSrcAttrTriggeringPrincipal
;
RefPtr
<
DOMMediaStream
>
mSrcStream
;
RefPtr
<
MediaStreamRenderer
>
mMediaStreamRenderer
;
RefPtr
<
MediaStreamRenderer
>
mSecondaryMediaStreamRenderer
;
Watchable
<
bool
>
mSrcStreamPlaybackEnded
=
{
false
"
HTMLMediaElement
:
:
mSrcStreamPlaybackEnded
"
}
;
bool
mSrcStreamReportPlaybackEnded
=
false
;
RefPtr
<
MediaStreamWindowCapturer
>
mStreamWindowCapturer
;
nsTArray
<
OutputMediaStream
>
mOutputStreams
;
nsRefPtrHashtable
<
nsStringHashKey
MediaElementTrackSource
>
mOutputTrackSources
;
RefPtr
<
VideoStreamTrack
>
mSelectedVideoStreamTrack
;
const
RefPtr
<
ShutdownObserver
>
mShutdownObserver
;
const
RefPtr
<
TitleChangeObserver
>
mTitleChangeObserver
;
RefPtr
<
MediaSource
>
mSrcMediaSource
;
RefPtr
<
MediaSource
>
mMediaSource
;
RefPtr
<
ChannelLoader
>
mChannelLoader
;
nsCOMPtr
<
nsIContent
>
mSourcePointer
;
nsCOMPtr
<
Document
>
mLoadBlockedDoc
;
class
EventBlocker
;
RefPtr
<
EventBlocker
>
mEventBlocker
;
nsMediaNetworkState
mNetworkState
=
HTMLMediaElement_Binding
:
:
NETWORK_EMPTY
;
Watchable
<
nsMediaReadyState
>
mReadyState
=
{
HTMLMediaElement_Binding
:
:
HAVE_NOTHING
"
HTMLMediaElement
:
:
mReadyState
"
}
;
enum
LoadAlgorithmState
{
NOT_WAITING
WAITING_FOR_SOURCE
}
;
uint32_t
mCurrentLoadID
=
0
;
LoadAlgorithmState
mLoadWaitStatus
=
NOT_WAITING
;
double
mVolume
=
1
.
0
;
bool
mIsAudioTrackAudible
=
false
;
enum
MutedReasons
{
MUTED_BY_CONTENT
=
0x01
MUTED_BY_INVALID_PLAYBACK_RATE
=
0x02
MUTED_BY_AUDIO_CHANNEL
=
0x04
MUTED_BY_AUDIO_TRACK
=
0x08
}
;
uint32_t
mMuted
=
0
;
UniquePtr
<
const
MetadataTags
>
mTags
;
nsCOMPtr
<
nsIURI
>
mLoadingSrc
;
nsCOMPtr
<
nsIPrincipal
>
mLoadingSrcTriggeringPrincipal
;
PreloadAction
mPreloadAction
=
PRELOAD_UNDEFINED
;
TimeStamp
mQueueTimeUpdateRunnerTime
;
TimeStamp
mLastTimeUpdateDispatchTime
;
TimeStamp
mProgressTime
;
TimeStamp
mDataTime
;
double
mLastCurrentTime
=
0
.
0
;
double
mFragmentStart
=
-
1
.
0
;
double
mFragmentEnd
=
-
1
.
0
;
double
mDefaultPlaybackRate
=
1
.
0
;
double
mPlaybackRate
=
1
.
0
;
bool
mPreservesPitch
=
true
;
nsCOMPtr
<
nsIContent
>
mSourceLoadCandidate
;
RefPtr
<
TimeRanges
>
mPlayed
;
nsCOMPtr
<
nsITimer
>
mProgressTimer
;
RefPtr
<
MediaKeys
>
mMediaKeys
;
RefPtr
<
MediaKeys
>
mIncomingMediaKeys
;
RefPtr
<
DetailedPromise
>
mSetMediaKeysDOMPromise
;
bool
mAttachingMediaKey
=
false
;
MozPromiseRequestHolder
<
SetCDMPromise
>
mSetCDMRequest
;
double
mCurrentPlayRangeStart
=
1
.
0
;
bool
mLoadedDataFired
=
false
;
bool
mCanAutoplayFlag
=
true
;
Watchable
<
bool
>
mPaused
=
{
true
"
HTMLMediaElement
:
:
mPaused
"
}
;
bool
mAllowCasting
=
false
;
bool
mIsCasting
=
false
;
Watchable
<
RefPtr
<
SharedDummyTrack
>
>
mTracksCaptured
;
bool
mAudioCaptured
=
false
;
bool
mPlayingBeforeSeek
=
false
;
bool
mSuspendedByInactiveDocOrDocshell
=
false
;
bool
mIsRunningLoadMethod
=
false
;
bool
mIsDoingExplicitLoad
=
false
;
bool
mIsLoadingFromSourceChildren
=
false
;
bool
mDelayingLoadEvent
=
false
;
bool
mIsRunningSelectResource
=
false
;
bool
mHaveQueuedSelectResource
=
false
;
bool
mSuspendedAfterFirstFrame
=
false
;
bool
mAllowSuspendAfterFirstFrame
=
true
;
bool
mHasPlayedOrSeeked
=
false
;
bool
mHasSelfReference
=
false
;
bool
mShuttingDown
=
false
;
bool
mSuspendedForPreloadNone
=
false
;
bool
mSrcStreamIsPlaying
=
false
;
bool
mUseUrgentStartForChannel
=
false
;
CORSMode
mCORSMode
=
CORS_NONE
;
MediaInfo
mMediaInfo
;
bool
mIsEncrypted
=
false
;
enum
WaitingForKeyState
{
NOT_WAITING_FOR_KEY
=
0
WAITING_FOR_KEY
=
1
WAITING_FOR_KEY_DISPATCHED
=
2
}
;
WaitingForKeyState
mWaitingForKey
=
NOT_WAITING_FOR_KEY
;
MediaEventListener
mWaitingForKeyListener
;
EncryptionInfo
mPendingEncryptedInitData
;
Watchable
<
bool
>
mDownloadSuspendedByCache
=
{
false
"
HTMLMediaElement
:
:
mDownloadSuspendedByCache
"
}
;
bool
mDisableVideo
=
false
;
RefPtr
<
TextTrackManager
>
mTextTrackManager
;
RefPtr
<
AudioTrackList
>
mAudioTrackList
;
RefPtr
<
VideoTrackList
>
mVideoTrackList
;
RefPtr
<
MediaStreamTrackListener
>
mMediaStreamTrackListener
;
nsCOMPtr
<
nsIPrincipal
>
mSrcStreamVideoPrincipal
;
bool
mBlockedAsWithoutMetadata
=
false
;
MozPromiseHolder
<
GenericNonExclusivePromise
>
mAllowedToPlayPromise
;
bool
mHasEverBeenBlockedForAutoplay
=
false
;
bool
mPendingTextTrackChanged
=
false
;
public
:
void
NotifyTextTrackModeChanged
(
)
;
private
:
friend
class
nsMediaEventRunner
;
friend
class
nsResolveOrRejectPendingPlayPromisesRunner
;
already_AddRefed
<
PlayPromise
>
CreatePlayPromise
(
ErrorResult
&
aRv
)
const
;
virtual
void
MaybeBeginCloningVisually
(
)
{
}
;
uint32_t
GetPreloadDefault
(
)
const
;
uint32_t
GetPreloadDefaultAuto
(
)
const
;
void
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
;
bool
mInitialized
=
false
;
bool
mIsBlessed
=
false
;
Watchable
<
bool
>
mFirstFrameLoaded
=
{
false
"
HTMLMediaElement
:
:
mFirstFrameLoaded
"
}
;
double
mDefaultPlaybackStartPosition
=
0
.
0
;
bool
mHasSuspendTaint
=
false
;
bool
mForcedHidden
=
false
;
Visibility
mVisibilityState
=
Visibility
:
:
Untracked
;
UniquePtr
<
ErrorSink
>
mErrorSink
;
RefPtr
<
AudioChannelAgentCallback
>
mAudioChannelWrapper
;
nsTArray
<
RefPtr
<
PlayPromise
>
>
mPendingPlayPromises
;
nsTArray
<
nsResolveOrRejectPendingPlayPromisesRunner
*
>
mPendingPlayPromisesRunners
;
RefPtr
<
dom
:
:
Promise
>
mSeekDOMPromise
;
bool
ShouldBeSuspendedByInactiveDocShell
(
)
const
;
void
AssertReadyStateIsNothing
(
)
;
std
:
:
pair
<
nsString
RefPtr
<
AudioDeviceInfo
>
>
mSink
;
bool
mShowPoster
;
void
CreateResumeDelayedMediaPlaybackAgentIfNeeded
(
)
;
void
ClearResumeDelayedMediaPlaybackAgentIfNeeded
(
)
;
RefPtr
<
ResumeDelayedPlaybackAgent
>
mResumeDelayedPlaybackAgent
;
MozPromiseRequestHolder
<
ResumeDelayedPlaybackAgent
:
:
ResumePromise
>
mResumePlaybackRequest
;
bool
IsPlayable
(
)
const
;
bool
ShouldStartMediaControlKeyListener
(
)
const
;
void
StartMediaControlKeyListenerIfNeeded
(
)
;
RefPtr
<
MediaControlKeyListener
>
mMediaControlKeyListener
;
void
UpdateStreamName
(
)
;
bool
IsBeingUsedInPictureInPictureMode
(
)
const
;
bool
ShouldQueueTimeupdateAsyncTask
(
TimeupdateType
aType
)
const
;
#
ifdef
MOZ_WMF_CDM
bool
mIsUsingWMFCDM
=
false
;
#
endif
}
;
bool
HasDebuggerOrTabsPrivilege
(
JSContext
*
aCx
JSObject
*
aObj
)
;
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
dom
:
:
HTMLMediaElement
*
aElement
)
{
return
static_cast
<
mozilla
:
:
dom
:
:
EventTarget
*
>
(
aElement
)
;
}
#
endif
