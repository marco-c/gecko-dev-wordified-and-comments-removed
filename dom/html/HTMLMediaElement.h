#
ifndef
mozilla_dom_HTMLMediaElement_h
#
define
mozilla_dom_HTMLMediaElement_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
MediaEventSource
.
h
"
#
include
"
SeekTarget
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
MediaPromiseDefs
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
DecoderTraits
.
h
"
#
include
"
nsIAudioChannelAgent
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
TextTrackManager
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
MediaKeys
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
MediaSegment
.
h
"
#
ifdef
CurrentTime
#
undef
CurrentTime
#
endif
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
typedef
uint16_t
nsMediaNetworkState
;
typedef
uint16_t
nsMediaReadyState
;
typedef
uint32_t
SuspendTypes
;
typedef
uint32_t
AudibleChangedReasons
;
typedef
uint8_t
AudibleState
;
namespace
mozilla
{
class
AbstractThread
;
class
ChannelMediaDecoder
;
class
DecoderDoctorDiagnostics
;
class
DOMMediaStream
;
class
ErrorResult
;
class
MediaResource
;
class
MediaDecoder
;
class
MediaInputPort
;
class
MediaStream
;
class
MediaStreamGraph
;
class
VideoFrameContainer
;
namespace
dom
{
class
MediaKeys
;
class
TextTrack
;
class
TimeRanges
;
class
WakeLock
;
class
MediaTrack
;
class
MediaStreamTrack
;
class
VideoStreamTrack
;
}
}
class
nsIChannel
;
class
nsIHttpChannel
;
class
nsILoadGroup
;
class
nsIRunnable
;
class
nsISerialEventTarget
;
class
nsITimer
;
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
#
define
TIMEUPDATE_MS
250
class
MediaError
;
class
MediaSource
;
class
PlayPromise
;
class
Promise
;
class
TextTrackList
;
class
AudioTrackList
;
class
VideoTrackList
;
enum
class
StreamCaptureType
:
uint8_t
{
CAPTURE_ALL_TRACKS
CAPTURE_AUDIO
}
;
enum
class
StreamCaptureBehavior
:
uint8_t
{
CONTINUE_WHEN_ENDED
FINISH_WHEN_ENDED
}
;
class
HTMLMediaElement
:
public
nsGenericHTMLElement
public
MediaDecoderOwner
public
PrincipalChangeObserver
<
DOMMediaStream
>
public
SupportsWeakPtr
<
HTMLMediaElement
>
public
nsStubMutationObserver
{
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
VideoFrameContainer
VideoFrameContainer
;
typedef
mozilla
:
:
MediaStream
MediaStream
;
typedef
mozilla
:
:
MediaResource
MediaResource
;
typedef
mozilla
:
:
MediaDecoderOwner
MediaDecoderOwner
;
typedef
mozilla
:
:
MetadataTags
MetadataTags
;
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
HTMLMediaElement
)
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
CORSMode
GetCORSMode
(
)
{
return
mCORSMode
;
}
explicit
HTMLMediaElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
;
void
ReportCanPlayTelemetry
(
)
;
nsresult
LoadWithChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
NS_IMPL_FROMNODE_HELPER
(
HTMLMediaElement
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
video
nsGkAtoms
:
:
audio
)
)
void
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
override
;
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
virtual
nsresult
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aDeep
=
true
bool
aNullParent
=
true
)
override
;
virtual
void
DoneCreatingElement
(
)
override
;
virtual
bool
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
override
;
virtual
int32_t
TabIndexDefault
(
)
override
;
virtual
void
MetadataLoaded
(
const
MediaInfo
*
aInfo
UniquePtr
<
const
MetadataTags
>
aTags
)
final
;
void
FirstFrameLoaded
(
)
final
;
void
NetworkError
(
const
MediaResult
&
aError
)
final
;
void
DecodeError
(
const
MediaResult
&
aError
)
final
;
void
DecodeWarning
(
const
MediaResult
&
aError
)
final
;
bool
HasError
(
)
const
final
;
void
LoadAborted
(
)
final
;
void
PlaybackEnded
(
)
final
;
void
SeekStarted
(
)
final
;
void
SeekCompleted
(
)
final
;
void
DownloadSuspended
(
)
final
;
void
DownloadResumed
(
)
;
void
DownloadProgressed
(
)
final
;
void
NotifySuspendedByCache
(
bool
aSuspendedByCache
)
final
;
bool
IsActive
(
)
const
;
bool
IsHidden
(
)
const
;
VideoFrameContainer
*
GetVideoFrameContainer
(
)
final
;
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
void
NotifyOwnerDocumentActivityChanged
(
)
;
void
PrincipalChanged
(
DOMMediaStream
*
aStream
)
override
;
void
UpdateSrcStreamVideoPrincipal
(
const
PrincipalHandle
&
aPrincipalHandle
)
;
void
PrincipalHandleChangedForVideoFrameContainer
(
VideoFrameContainer
*
aContainer
const
PrincipalHandle
&
aNewPrincipalHandle
)
override
;
void
DispatchAsyncEvent
(
const
nsAString
&
aName
)
final
;
void
UpdateReadyState
(
)
override
{
UpdateReadyStateInternal
(
)
;
}
nsresult
DispatchPendingMediaEvents
(
)
;
bool
CanActivateAutoplay
(
)
;
void
CheckAutoplayDataReady
(
)
;
bool
ShouldCheckAllowOrigin
(
)
;
bool
IsCORSSameOrigin
(
)
;
bool
IsPotentiallyPlaying
(
)
const
;
bool
IsPlaybackEnded
(
)
const
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentVideoPrincipal
(
)
;
void
NotifyDecoderPrincipalChanged
(
)
final
;
void
GetEMEInfo
(
nsString
&
aEMEInfo
)
;
class
DecoderPrincipalChangeObserver
{
public
:
virtual
void
NotifyDecoderPrincipalChanged
(
)
=
0
;
}
;
void
AddDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
;
bool
RemoveDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
;
class
StreamCaptureTrackSource
;
class
DecoderCaptureTrackSource
;
class
CaptureStreamTrackSourceGetter
;
void
UpdateMediaSize
(
const
nsIntSize
&
aSize
)
;
void
UpdateInitialMediaSize
(
const
nsIntSize
&
aSize
)
;
void
Invalidate
(
bool
aImageSizeChanged
Maybe
<
nsIntSize
>
&
aNewIntrinsicSize
bool
aForceInvalidate
)
override
;
static
CanPlayStatus
GetCanPlay
(
const
nsAString
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
;
void
NotifyAddedSource
(
)
;
void
NotifyLoadError
(
const
nsACString
&
aErrorDetails
=
nsCString
(
)
)
;
void
NotifyMediaTrackEnabled
(
MediaTrack
*
aTrack
)
;
void
NotifyMediaTrackDisabled
(
MediaTrack
*
aTrack
)
;
void
NotifyMediaStreamTracksAvailable
(
DOMMediaStream
*
aStream
)
;
void
NotifyOutputTrackStopped
(
DOMMediaStream
*
aOwningStream
TrackID
aDestinationTrackID
)
;
uint32_t
GetCurrentLoadID
(
)
{
return
mCurrentLoadID
;
}
already_AddRefed
<
nsILoadGroup
>
GetDocumentLoadGroup
(
)
;
bool
GetPlayedOrSeeked
(
)
const
{
return
mHasPlayedOrSeeked
;
}
nsresult
CopyInnerTo
(
Element
*
aDest
bool
aPreallocateChildren
)
;
virtual
nsresult
SetAcceptHeader
(
nsIHttpChannel
*
aChannel
)
=
0
;
void
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
)
;
void
RunInStableState
(
nsIRunnable
*
aRunnable
)
;
void
FireTimeUpdate
(
bool
aPeriodic
)
final
;
MediaStream
*
GetSrcMediaStream
(
)
const
;
MediaError
*
GetError
(
)
const
;
void
GetSrc
(
nsAString
&
aSrc
)
{
GetURIAttr
(
nsGkAtoms
:
:
src
nullptr
aSrc
)
;
}
void
SetSrc
(
const
nsAString
&
aSrc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aError
)
;
}
void
SetSrc
(
const
nsAString
&
aSrc
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aTriggeringPrincipal
aError
)
;
}
void
GetCurrentSrc
(
nsAString
&
aCurrentSrc
)
;
void
GetCrossOrigin
(
nsAString
&
aResult
)
{
GetEnumAttr
(
nsGkAtoms
:
:
crossorigin
nullptr
aResult
)
;
}
void
SetCrossOrigin
(
const
nsAString
&
aCrossOrigin
ErrorResult
&
aError
)
{
SetOrRemoveNullableStringAttr
(
nsGkAtoms
:
:
crossorigin
aCrossOrigin
aError
)
;
}
uint16_t
NetworkState
(
)
const
{
return
mNetworkState
;
}
void
NotifyXPCOMShutdown
(
)
final
;
void
SetAudibleState
(
bool
aAudible
)
final
;
void
NotifyAudioPlaybackChanged
(
AudibleChangedReasons
aReason
)
;
void
GetPreload
(
nsAString
&
aValue
)
{
GetEnumAttr
(
nsGkAtoms
:
:
preload
nullptr
aValue
)
;
}
void
SetPreload
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
preload
aValue
aRv
)
;
}
already_AddRefed
<
TimeRanges
>
Buffered
(
)
const
;
void
Load
(
)
;
void
CanPlayType
(
const
nsAString
&
aType
nsAString
&
aResult
)
;
uint16_t
ReadyState
(
)
const
{
return
mReadyState
;
}
bool
Seeking
(
)
const
;
double
CurrentTime
(
)
const
;
void
SetCurrentTime
(
double
aCurrentTime
ErrorResult
&
aRv
)
;
void
SetCurrentTime
(
double
aCurrentTime
)
{
SetCurrentTime
(
aCurrentTime
IgnoreErrors
(
)
)
;
}
void
FastSeek
(
double
aTime
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
SeekToNextFrame
(
ErrorResult
&
aRv
)
;
double
Duration
(
)
const
;
bool
HasAudio
(
)
const
{
return
mMediaInfo
.
HasAudio
(
)
;
}
virtual
bool
IsVideo
(
)
const
{
return
false
;
}
bool
HasVideo
(
)
const
{
return
mMediaInfo
.
HasVideo
(
)
;
}
bool
IsEncrypted
(
)
const
{
return
mIsEncrypted
;
}
bool
Paused
(
)
const
{
return
mPaused
;
}
double
DefaultPlaybackRate
(
)
const
{
return
mDefaultPlaybackRate
;
}
void
SetDefaultPlaybackRate
(
double
aDefaultPlaybackRate
ErrorResult
&
aRv
)
;
double
PlaybackRate
(
)
const
{
return
mPlaybackRate
;
}
void
SetPlaybackRate
(
double
aPlaybackRate
ErrorResult
&
aRv
)
;
already_AddRefed
<
TimeRanges
>
Played
(
)
;
already_AddRefed
<
TimeRanges
>
Seekable
(
)
const
;
bool
Ended
(
)
;
bool
Autoplay
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
autoplay
)
;
}
void
SetAutoplay
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
autoplay
aValue
aRv
)
;
}
bool
Loop
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
loop
)
;
}
void
SetLoop
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
loop
aValue
aRv
)
;
}
already_AddRefed
<
Promise
>
Play
(
ErrorResult
&
aRv
)
;
void
Pause
(
ErrorResult
&
aRv
)
;
void
Pause
(
)
{
Pause
(
IgnoreErrors
(
)
)
;
}
bool
Controls
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
controls
)
;
}
void
SetControls
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
controls
aValue
aRv
)
;
}
double
Volume
(
)
const
{
return
mVolume
;
}
void
SetVolume
(
double
aVolume
ErrorResult
&
aRv
)
;
bool
Muted
(
)
const
{
return
mMuted
&
MUTED_BY_CONTENT
;
}
void
SetMuted
(
bool
aMuted
)
;
bool
DefaultMuted
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
muted
)
;
}
void
SetDefaultMuted
(
bool
aMuted
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
muted
aMuted
aRv
)
;
}
bool
MozAllowCasting
(
)
const
{
return
mAllowCasting
;
}
void
SetMozAllowCasting
(
bool
aShow
)
{
mAllowCasting
=
aShow
;
}
bool
MozIsCasting
(
)
const
{
return
mIsCasting
;
}
void
SetMozIsCasting
(
bool
aShow
)
{
mIsCasting
=
aShow
;
}
bool
AllowedToPlay
(
)
const
;
already_AddRefed
<
MediaSource
>
GetMozMediaSourceObject
(
)
const
;
void
GetMozDebugReaderData
(
nsAString
&
aString
)
;
already_AddRefed
<
Promise
>
MozRequestDebugInfo
(
ErrorResult
&
aRv
)
;
static
void
MozEnableDebugLog
(
const
GlobalObject
&
)
;
already_AddRefed
<
Promise
>
MozRequestDebugLog
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
MozDumpDebugInfo
(
)
;
void
SetVisible
(
bool
aVisible
)
;
bool
HasSuspendTaint
(
)
const
;
already_AddRefed
<
layers
:
:
Image
>
GetCurrentImage
(
)
;
already_AddRefed
<
DOMMediaStream
>
GetSrcObject
(
)
const
;
void
SetSrcObject
(
DOMMediaStream
&
aValue
)
;
void
SetSrcObject
(
DOMMediaStream
*
aValue
)
;
bool
MozPreservesPitch
(
)
const
{
return
mPreservesPitch
;
}
void
SetMozPreservesPitch
(
bool
aPreservesPitch
)
;
MediaKeys
*
GetMediaKeys
(
)
const
;
already_AddRefed
<
Promise
>
SetMediaKeys
(
MediaKeys
*
mediaKeys
ErrorResult
&
aRv
)
;
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOnencrypted
(
)
;
void
SetOnencrypted
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
aCallback
)
;
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOnwaitingforkey
(
)
;
void
SetOnwaitingforkey
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
aCallback
)
;
void
DispatchEncrypted
(
const
nsTArray
<
uint8_t
>
&
aInitData
const
nsAString
&
aInitDataType
)
override
;
bool
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
override
;
already_AddRefed
<
nsIPrincipal
>
GetTopLevelPrincipal
(
)
;
bool
ContainsRestrictedContent
(
)
;
void
NotifyWaitingForKey
(
)
override
;
already_AddRefed
<
DOMMediaStream
>
CaptureAudio
(
ErrorResult
&
aRv
MediaStreamGraph
*
aGraph
)
;
already_AddRefed
<
DOMMediaStream
>
MozCaptureStream
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMMediaStream
>
MozCaptureStreamUntilEnded
(
ErrorResult
&
aRv
)
;
bool
MozAudioCaptured
(
)
const
{
return
mAudioCaptured
;
}
void
MozGetMetadata
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aRv
)
;
double
MozFragmentEnd
(
)
;
AudioTrackList
*
AudioTracks
(
)
;
VideoTrackList
*
VideoTracks
(
)
;
TextTrackList
*
GetTextTracks
(
)
;
already_AddRefed
<
TextTrack
>
AddTextTrack
(
TextTrackKind
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
)
;
void
AddTextTrack
(
TextTrack
*
aTextTrack
)
{
GetOrCreateTextTrackManager
(
)
-
>
AddTextTrack
(
aTextTrack
)
;
}
void
RemoveTextTrack
(
TextTrack
*
aTextTrack
bool
aPendingListOnly
=
false
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
RemoveTextTrack
(
aTextTrack
aPendingListOnly
)
;
}
}
void
NotifyCueAdded
(
TextTrackCue
&
aCue
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyCueAdded
(
aCue
)
;
}
}
void
NotifyCueRemoved
(
TextTrackCue
&
aCue
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyCueRemoved
(
aCue
)
;
}
}
void
NotifyCueUpdated
(
TextTrackCue
*
aCue
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyCueUpdated
(
aCue
)
;
}
}
void
NotifyCueDisplayStatesChanged
(
)
;
bool
IsBlessed
(
)
const
{
return
mIsBlessed
;
}
bool
IsCurrentlyPlaying
(
)
const
;
bool
IsBeingDestroyed
(
)
;
void
OnVisibilityChange
(
Visibility
aNewVisibility
)
;
float
ComputedVolume
(
)
const
;
bool
ComputedMuted
(
)
const
;
nsSuspendedTypes
ComputedSuspended
(
)
const
;
void
SetMediaInfo
(
const
MediaInfo
&
aInfo
)
;
AbstractThread
*
AbstractMainThread
(
)
const
final
;
enum
class
CallerAPI
{
DRAW_IMAGE
CREATE_PATTERN
CREATE_IMAGEBITMAP
CAPTURE_STREAM
}
;
void
MarkAsContentSource
(
CallerAPI
aAPI
)
;
nsIDocument
*
GetDocument
(
)
const
override
;
void
ConstructMediaTracks
(
const
MediaInfo
*
aInfo
)
override
;
void
RemoveMediaTracks
(
)
override
;
already_AddRefed
<
GMPCrashHelper
>
CreateGMPCrashHelper
(
)
override
;
void
AsyncResolveSeekDOMPromiseIfExists
(
)
override
;
void
AsyncRejectSeekDOMPromiseIfExists
(
)
override
;
nsISerialEventTarget
*
MainThreadEventTarget
(
)
{
return
mMainThreadEventTarget
;
}
protected
:
virtual
~
HTMLMediaElement
(
)
;
class
AudioChannelAgentCallback
;
class
ChannelLoader
;
class
ErrorSink
;
class
MediaLoadListener
;
class
MediaStreamTracksAvailableCallback
;
class
MediaStreamTrackListener
;
class
StreamListener
;
class
StreamSizeListener
;
class
ShutdownObserver
;
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
;
void
SetDecoder
(
MediaDecoder
*
aDecoder
)
;
void
UpdateWakeLock
(
)
;
struct
OutputMediaStream
{
OutputMediaStream
(
)
;
~
OutputMediaStream
(
)
;
RefPtr
<
DOMMediaStream
>
mStream
;
TrackID
mNextAvailableTrackID
;
bool
mFinishWhenEnded
;
bool
mCapturingAudioOnly
;
bool
mCapturingDecoder
;
bool
mCapturingMediaStream
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
mPreCreatedTracks
;
nsTArray
<
Pair
<
nsString
RefPtr
<
MediaInputPort
>
>
>
mTrackPorts
;
}
;
void
PlayInternal
(
bool
aHandlingUserInput
)
;
void
ChangeReadyState
(
nsMediaReadyState
aState
)
;
void
ChangeNetworkState
(
nsMediaNetworkState
aState
)
;
virtual
void
WakeLockCreate
(
)
;
virtual
void
WakeLockRelease
(
)
;
RefPtr
<
WakeLock
>
mWakeLock
;
void
ReportLoadError
(
const
char
*
aMsg
const
char16_t
*
*
aParams
=
nullptr
uint32_t
aParamCount
=
0
)
;
void
SetPlayedOrSeeked
(
bool
aValue
)
;
void
SetupSrcMediaStreamPlayback
(
DOMMediaStream
*
aStream
)
;
void
EndSrcMediaStreamPlayback
(
)
;
enum
{
REMOVING_SRC_STREAM
=
0x1
}
;
void
UpdateSrcMediaStreamPlaying
(
uint32_t
aFlags
=
0
)
;
void
NotifyMediaStreamTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
;
void
NotifyMediaStreamTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
;
void
SetCapturedOutputStreamsEnabled
(
bool
aEnabled
)
;
void
AddCaptureMediaTrackToOutputStream
(
MediaTrack
*
aTrack
OutputMediaStream
&
aOutputStream
bool
aAsyncAddtrack
=
true
)
;
already_AddRefed
<
DOMMediaStream
>
CaptureStreamInternal
(
StreamCaptureBehavior
aBehavior
StreamCaptureType
aType
MediaStreamGraph
*
aGraph
)
;
nsresult
InitializeDecoderAsClone
(
ChannelMediaDecoder
*
aOriginal
)
;
template
<
typename
DecoderType
typename
.
.
.
LoadArgs
>
nsresult
SetupDecoder
(
DecoderType
*
aDecoder
LoadArgs
&
&
.
.
.
aArgs
)
;
nsresult
InitializeDecoderForChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
;
nsresult
FinishDecoderSetup
(
MediaDecoder
*
aDecoder
)
;
void
AddMediaElementToURITable
(
)
;
void
RemoveMediaElementFromURITable
(
)
;
HTMLMediaElement
*
LookupMediaElementURITable
(
nsIURI
*
aURI
)
;
void
ShutdownDecoder
(
)
;
void
AbortExistingLoads
(
)
;
void
NoSupportedMediaSourceError
(
const
nsACString
&
aErrorDetails
=
nsCString
(
)
)
;
void
DealWithFailedElement
(
nsIContent
*
aSourceElement
)
;
void
LoadFromSourceChildren
(
)
;
void
QueueLoadFromSourceTask
(
)
;
void
SelectResource
(
)
;
void
SelectResourceWrapper
(
)
;
void
QueueSelectResourceTask
(
)
;
void
ResetState
(
)
;
MediaResult
LoadResource
(
)
;
Element
*
GetNextSource
(
)
;
void
ChangeDelayLoadStatus
(
bool
aDelay
)
;
void
StopSuspendingAfterFirstFrame
(
)
;
nsresult
OnChannelRedirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
;
void
AddRemoveSelfReference
(
)
;
void
DoRemoveSelfReference
(
)
;
void
NotifyShutdownEvent
(
)
;
enum
PreloadAttrValue
:
uint8_t
{
PRELOAD_ATTR_EMPTY
PRELOAD_ATTR_NONE
PRELOAD_ATTR_METADATA
PRELOAD_ATTR_AUTO
}
;
enum
PreloadAction
{
PRELOAD_UNDEFINED
=
0
PRELOAD_NONE
=
1
PRELOAD_METADATA
=
2
PRELOAD_ENOUGH
=
3
}
;
void
DoLoad
(
)
;
void
SuspendLoad
(
)
;
void
ResumeLoad
(
PreloadAction
aAction
)
;
void
UpdatePreloadAction
(
)
;
void
CheckProgress
(
bool
aHaveNewProgress
)
;
static
void
ProgressTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
StartProgressTimer
(
)
;
void
StartProgress
(
)
;
void
StopProgress
(
)
;
void
DispatchAsyncSourceError
(
nsIContent
*
aSourceElement
)
;
void
Error
(
uint16_t
aErrorCode
const
nsACString
&
aErrorDetails
=
nsCString
(
)
)
;
void
GetCurrentSpec
(
nsCString
&
aString
)
;
void
ProcessMediaFragmentURI
(
)
;
void
SetMutedInternal
(
uint32_t
aMuted
)
;
void
SetVolumeInternal
(
)
;
void
SuspendOrResumeElement
(
bool
aPauseElement
bool
aSuspendEvents
)
;
HTMLMediaElement
*
GetMediaElement
(
)
final
{
return
this
;
}
bool
GetPaused
(
)
final
{
return
Paused
(
)
;
}
static
void
VideoDecodeSuspendTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
HiddenVideoStart
(
)
;
void
HiddenVideoStop
(
)
;
void
ReportTelemetry
(
)
;
already_AddRefed
<
Promise
>
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
ErrorResult
&
aRv
)
;
void
UpdateAudioChannelPlayingState
(
bool
aForcePlaying
=
false
)
;
void
PopulatePendingTextTrackList
(
)
;
TextTrackManager
*
GetOrCreateTextTrackManager
(
)
;
void
UpdateReadyStateInternal
(
)
;
bool
ShouldElementBePaused
(
)
;
void
AudioCaptureStreamChange
(
bool
aCapture
)
;
bool
AudioChannelAgentBlockedPlay
(
)
;
void
MaybeDoLoad
(
)
;
void
UpdateCustomPolicyAfterPlayed
(
)
;
StreamCaptureType
CaptureTypeForElement
(
)
;
bool
CanBeCaptured
(
StreamCaptureType
aCaptureType
)
;
class
nsAsyncEventRunner
;
class
nsNotifyAboutPlayingRunner
;
class
nsResolveOrRejectPendingPlayPromisesRunner
;
using
nsGenericHTMLElement
:
:
DispatchEvent
;
nsresult
DispatchEvent
(
const
nsAString
&
aName
)
;
void
OpenUnsupportedMediaWithExternalAppIfNeeded
(
)
const
;
nsTArray
<
RefPtr
<
PlayPromise
>
>
TakePendingPlayPromises
(
)
;
void
AsyncResolvePendingPlayPromises
(
)
;
void
AsyncRejectPendingPlayPromises
(
nsresult
aError
)
;
void
NotifyAboutPlaying
(
)
;
already_AddRefed
<
Promise
>
CreateDOMPromise
(
ErrorResult
&
aRv
)
const
;
void
NotifyDecoderActivityChanges
(
)
const
;
void
MarkAsTainted
(
)
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
nsresult
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
override
;
bool
DetachExistingMediaKeys
(
)
;
bool
TryRemoveMediaKeysAssociation
(
)
;
void
RemoveMediaKeys
(
)
;
bool
AttachNewMediaKeys
(
)
;
bool
TryMakeAssociationWithCDM
(
CDMProxy
*
aProxy
)
;
void
MakeAssociationWithCDMResolved
(
)
;
void
SetCDMProxyFailure
(
const
MediaResult
&
aResult
)
;
void
ResetSetMediaKeysTempVariables
(
)
;
void
PauseIfShouldNotBePlaying
(
)
;
WatchManager
<
HTMLMediaElement
>
mWatchManager
;
bool
AudioChannelAgentDelayingPlayback
(
)
;
void
EnsureAutoplayRequested
(
bool
aHandlingUserInput
)
;
RefPtr
<
MediaDecoder
>
mDecoder
;
nsCOMPtr
<
nsISerialEventTarget
>
mMainThreadEventTarget
;
RefPtr
<
AbstractThread
>
mAbstractMainThread
;
nsTArray
<
DecoderPrincipalChangeObserver
*
>
mDecoderPrincipalChangeObservers
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
RefPtr
<
DOMMediaStream
>
mSrcAttrStream
;
nsCOMPtr
<
nsIPrincipal
>
mSrcAttrTriggeringPrincipal
;
RefPtr
<
DOMMediaStream
>
mSrcStream
;
bool
mSrcStreamTracksAvailable
=
false
;
double
mSrcStreamPausedCurrentTime
=
-
1
;
RefPtr
<
MediaInputPort
>
mCaptureStreamPort
;
nsTArray
<
OutputMediaStream
>
mOutputStreams
;
RefPtr
<
StreamListener
>
mMediaStreamListener
;
RefPtr
<
StreamSizeListener
>
mMediaStreamSizeListener
;
RefPtr
<
VideoStreamTrack
>
mSelectedVideoStreamTrack
;
const
RefPtr
<
ShutdownObserver
>
mShutdownObserver
;
RefPtr
<
MediaSource
>
mSrcMediaSource
;
RefPtr
<
MediaSource
>
mMediaSource
;
RefPtr
<
ChannelLoader
>
mChannelLoader
;
nsCOMPtr
<
nsIContent
>
mSourcePointer
;
nsCOMPtr
<
nsIDocument
>
mLoadBlockedDoc
;
nsTArray
<
nsString
>
mPendingEvents
;
nsMediaNetworkState
mNetworkState
=
HTMLMediaElement_Binding
:
:
NETWORK_EMPTY
;
nsMediaReadyState
mReadyState
=
HTMLMediaElement_Binding
:
:
HAVE_NOTHING
;
enum
LoadAlgorithmState
{
NOT_WAITING
WAITING_FOR_SOURCE
}
;
uint32_t
mCurrentLoadID
=
0
;
LoadAlgorithmState
mLoadWaitStatus
=
NOT_WAITING
;
double
mVolume
=
1
.
0
;
bool
mIsAudioTrackAudible
=
false
;
enum
MutedReasons
{
MUTED_BY_CONTENT
=
0x01
MUTED_BY_INVALID_PLAYBACK_RATE
=
0x02
MUTED_BY_AUDIO_CHANNEL
=
0x04
MUTED_BY_AUDIO_TRACK
=
0x08
}
;
uint32_t
mMuted
=
0
;
UniquePtr
<
const
MetadataTags
>
mTags
;
nsCOMPtr
<
nsIURI
>
mLoadingSrc
;
nsCOMPtr
<
nsIPrincipal
>
mLoadingSrcTriggeringPrincipal
;
PreloadAction
mPreloadAction
=
PRELOAD_UNDEFINED
;
TimeStamp
mTimeUpdateTime
;
TimeStamp
mProgressTime
;
TimeStamp
mDataTime
;
double
mLastCurrentTime
=
0
.
0
;
double
mFragmentStart
=
-
1
.
0
;
double
mFragmentEnd
=
-
1
.
0
;
double
mDefaultPlaybackRate
=
1
.
0
;
double
mPlaybackRate
=
1
.
0
;
bool
mPreservesPitch
=
true
;
nsCOMPtr
<
nsIContent
>
mSourceLoadCandidate
;
RefPtr
<
TimeRanges
>
mPlayed
;
nsCOMPtr
<
nsITimer
>
mProgressTimer
;
nsCOMPtr
<
nsITimer
>
mVideoDecodeSuspendTimer
;
RefPtr
<
MediaKeys
>
mMediaKeys
;
RefPtr
<
MediaKeys
>
mIncomingMediaKeys
;
RefPtr
<
DetailedPromise
>
mSetMediaKeysDOMPromise
;
bool
mAttachingMediaKey
=
false
;
MozPromiseRequestHolder
<
SetCDMPromise
>
mSetCDMRequest
;
MozPromiseRequestHolder
<
GenericPromise
>
mAutoplayPermissionRequest
;
double
mCurrentPlayRangeStart
=
1
.
0
;
bool
mLoadedDataFired
=
false
;
bool
mAutoplaying
=
true
;
Watchable
<
bool
>
mPaused
;
bool
mAllowCasting
=
false
;
bool
mIsCasting
=
false
;
bool
mAudioCaptured
=
false
;
bool
mPlayingBeforeSeek
=
false
;
bool
mPausedForInactiveDocumentOrChannel
=
false
;
bool
mEventDeliveryPaused
=
false
;
bool
mIsRunningLoadMethod
=
false
;
bool
mIsDoingExplicitLoad
=
false
;
bool
mIsLoadingFromSourceChildren
=
false
;
bool
mDelayingLoadEvent
=
false
;
bool
mIsRunningSelectResource
=
false
;
bool
mHaveQueuedSelectResource
=
false
;
bool
mSuspendedAfterFirstFrame
=
false
;
bool
mAllowSuspendAfterFirstFrame
=
true
;
bool
mHasPlayedOrSeeked
=
false
;
bool
mHasSelfReference
=
false
;
bool
mShuttingDown
=
false
;
bool
mSuspendedForPreloadNone
=
false
;
bool
mSrcStreamIsPlaying
=
false
;
bool
mUseUrgentStartForChannel
=
false
;
CORSMode
mCORSMode
=
CORS_NONE
;
MediaInfo
mMediaInfo
;
bool
mIsEncrypted
=
false
;
enum
WaitingForKeyState
{
NOT_WAITING_FOR_KEY
=
0
WAITING_FOR_KEY
=
1
WAITING_FOR_KEY_DISPATCHED
=
2
}
;
WaitingForKeyState
mWaitingForKey
=
NOT_WAITING_FOR_KEY
;
MediaEventListener
mWaitingForKeyListener
;
EncryptionInfo
mPendingEncryptedInitData
;
bool
mDownloadSuspendedByCache
=
false
;
bool
mDisableVideo
=
false
;
RefPtr
<
TextTrackManager
>
mTextTrackManager
;
RefPtr
<
AudioTrackList
>
mAudioTrackList
;
RefPtr
<
VideoTrackList
>
mVideoTrackList
;
nsAutoPtr
<
MediaStreamTrackListener
>
mMediaStreamTrackListener
;
nsCOMPtr
<
nsIPrincipal
>
mSrcStreamVideoPrincipal
;
bool
mUnboundFromTree
=
false
;
public
:
class
TimeDurationAccumulator
{
public
:
TimeDurationAccumulator
(
)
:
mCount
(
0
)
{
}
void
Start
(
)
{
if
(
IsStarted
(
)
)
{
return
;
}
mStartTime
=
TimeStamp
:
:
Now
(
)
;
}
void
Pause
(
)
{
if
(
!
IsStarted
(
)
)
{
return
;
}
mSum
+
=
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
;
mCount
+
+
;
mStartTime
=
TimeStamp
(
)
;
}
bool
IsStarted
(
)
const
{
return
!
mStartTime
.
IsNull
(
)
;
}
double
Total
(
)
const
{
if
(
!
IsStarted
(
)
)
{
return
mSum
.
ToSeconds
(
)
;
}
return
(
mSum
+
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
)
.
ToSeconds
(
)
;
}
uint32_t
Count
(
)
const
{
if
(
!
IsStarted
(
)
)
{
return
mCount
;
}
return
mCount
+
1
;
}
private
:
TimeStamp
mStartTime
;
TimeDuration
mSum
;
uint32_t
mCount
;
}
;
private
:
already_AddRefed
<
PlayPromise
>
CreatePlayPromise
(
ErrorResult
&
aRv
)
const
;
void
UpdateHadAudibleAutoplayState
(
)
const
;
void
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
;
TimeDurationAccumulator
mPlayTime
;
TimeDurationAccumulator
mHiddenPlayTime
;
TimeDurationAccumulator
mVideoDecodeSuspendTime
;
bool
mIsBlessed
=
false
;
bool
mFirstFrameLoaded
=
false
;
double
mDefaultPlaybackStartPosition
=
0
.
0
;
bool
mHasSuspendTaint
=
false
;
bool
mForcedHidden
=
false
;
bool
mMediaTracksConstructed
=
false
;
Visibility
mVisibilityState
=
Visibility
:
:
UNTRACKED
;
UniquePtr
<
ErrorSink
>
mErrorSink
;
RefPtr
<
AudioChannelAgentCallback
>
mAudioChannelWrapper
;
nsTArray
<
RefPtr
<
PlayPromise
>
>
mPendingPlayPromises
;
nsTArray
<
nsResolveOrRejectPendingPlayPromisesRunner
*
>
mPendingPlayPromisesRunners
;
RefPtr
<
dom
:
:
Promise
>
mSeekDOMPromise
;
void
AssertReadyStateIsNothing
(
)
;
}
;
bool
HasDebuggerOrTabsPrivilege
(
JSContext
*
aCx
JSObject
*
aObj
)
;
}
}
#
endif
