#
ifndef
mozilla_dom_HTMLMediaElement_h
#
define
mozilla_dom_HTMLMediaElement_h
#
include
"
nsIDOMHTMLMediaElement
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
MediaDecoderOwner
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
DecoderTraits
.
h
"
#
include
"
nsIAudioChannelAgent
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
TextTrackManager
.
h
"
#
include
"
MediaDecoder
.
h
"
#
ifdef
MOZ_EME
#
include
"
mozilla
/
dom
/
MediaKeys
.
h
"
#
endif
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
PrincipalChangeObserver
.
h
"
#
ifdef
CurrentTime
#
undef
CurrentTime
#
endif
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
typedef
uint16_t
nsMediaNetworkState
;
typedef
uint16_t
nsMediaReadyState
;
typedef
uint32_t
SuspendTypes
;
namespace
mozilla
{
class
DecoderDoctorDiagnostics
;
class
DOMMediaStream
;
class
ErrorResult
;
class
MediaResource
;
class
MediaDecoder
;
class
VideoFrameContainer
;
namespace
dom
{
class
MediaKeys
;
class
TextTrack
;
class
TimeRanges
;
class
WakeLock
;
class
MediaTrack
;
}
}
class
AutoNotifyAudioChannelAgent
;
class
nsIChannel
;
class
nsIHttpChannel
;
class
nsILoadGroup
;
class
nsIRunnable
;
class
nsITimer
;
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
#
define
TIMEUPDATE_MS
250
class
MediaError
;
class
MediaSource
;
class
TextTrackList
;
class
AudioTrackList
;
class
VideoTrackList
;
class
HTMLMediaElement
:
public
nsGenericHTMLElement
public
nsIDOMHTMLMediaElement
public
nsIObserver
public
MediaDecoderOwner
public
nsIAudioChannelAgentCallback
public
PrincipalChangeObserver
<
DOMMediaStream
>
{
friend
AutoNotifyAudioChannelAgent
;
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
VideoFrameContainer
VideoFrameContainer
;
typedef
mozilla
:
:
MediaStream
MediaStream
;
typedef
mozilla
:
:
MediaResource
MediaResource
;
typedef
mozilla
:
:
MediaDecoderOwner
MediaDecoderOwner
;
typedef
mozilla
:
:
MetadataTags
MetadataTags
;
CORSMode
GetCORSMode
(
)
{
return
mCORSMode
;
}
explicit
HTMLMediaElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
;
nsresult
LoadWithChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
;
NS_DECL_NSIDOMHTMLMEDIAELEMENT
NS_DECL_NSIOBSERVER
NS_DECL_NSIAUDIOCHANNELAGENTCALLBACK
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsIAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
override
;
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
const
nsAString
&
aValue
bool
aNotify
)
{
return
SetAttr
(
aNameSpaceID
aName
nullptr
aValue
aNotify
)
;
}
virtual
nsresult
SetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
nsIAtom
*
aPrefix
const
nsAString
&
aValue
bool
aNotify
)
override
;
virtual
nsresult
UnsetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aAttr
bool
aNotify
)
override
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
const
nsAttrValue
*
aValue
bool
aNotify
)
override
;
virtual
nsresult
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
bool
aCompileEventHandlers
)
override
;
virtual
void
UnbindFromTree
(
bool
aDeep
=
true
bool
aNullParent
=
true
)
override
;
virtual
void
DoneCreatingElement
(
)
override
;
virtual
bool
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
override
;
virtual
int32_t
TabIndexDefault
(
)
override
;
void
NotifyOwnerDocumentActivityChanged
(
)
;
virtual
bool
NotifyOwnerDocumentActivityChangedInternal
(
)
;
virtual
void
MetadataLoaded
(
const
MediaInfo
*
aInfo
nsAutoPtr
<
const
MetadataTags
>
aTags
)
final
override
;
virtual
void
FirstFrameLoaded
(
)
final
override
;
virtual
void
NetworkError
(
)
final
override
;
virtual
void
DecodeError
(
)
final
override
;
virtual
bool
HasError
(
)
const
final
override
;
virtual
void
LoadAborted
(
)
final
override
;
virtual
void
PlaybackEnded
(
)
final
override
;
virtual
void
SeekStarted
(
)
final
override
;
virtual
void
SeekCompleted
(
)
final
override
;
virtual
void
DownloadSuspended
(
)
final
override
;
virtual
void
DownloadResumed
(
bool
aForceNetworkLoading
=
false
)
final
override
;
virtual
void
DownloadProgressed
(
)
final
override
;
virtual
void
NotifySuspendedByCache
(
bool
aIsSuspended
)
final
override
;
virtual
bool
IsActive
(
)
const
final
override
;
virtual
bool
IsHidden
(
)
const
final
override
;
virtual
VideoFrameContainer
*
GetVideoFrameContainer
(
)
final
override
;
layers
:
:
ImageContainer
*
GetImageContainer
(
)
;
void
PrincipalChanged
(
DOMMediaStream
*
aStream
)
override
;
void
UpdateSrcStreamVideoPrincipal
(
const
PrincipalHandle
&
aPrincipalHandle
)
;
void
PrincipalHandleChangedForVideoFrameContainer
(
VideoFrameContainer
*
aContainer
const
PrincipalHandle
&
aNewPrincipalHandle
)
;
virtual
nsresult
DispatchAsyncEvent
(
const
nsAString
&
aName
)
final
override
;
void
UpdateReadyState
(
)
override
{
UpdateReadyStateInternal
(
)
;
}
nsresult
DispatchPendingMediaEvents
(
)
;
bool
CanActivateAutoplay
(
)
;
void
CheckAutoplayDataReady
(
)
;
bool
ShouldCheckAllowOrigin
(
)
;
bool
IsCORSSameOrigin
(
)
;
bool
IsPotentiallyPlaying
(
)
const
;
bool
IsPlaybackEnded
(
)
const
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentPrincipal
(
)
;
already_AddRefed
<
nsIPrincipal
>
GetCurrentVideoPrincipal
(
)
;
void
NotifyDecoderPrincipalChanged
(
)
final
override
;
class
DecoderPrincipalChangeObserver
{
public
:
virtual
void
NotifyDecoderPrincipalChanged
(
)
=
0
;
}
;
void
AddDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
;
bool
RemoveDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
;
class
CaptureStreamTrackSource
;
class
CaptureStreamTrackSourceGetter
;
void
UpdateMediaSize
(
const
nsIntSize
&
aSize
)
;
void
UpdateInitialMediaSize
(
const
nsIntSize
&
aSize
)
;
static
CanPlayStatus
GetCanPlay
(
const
nsAString
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
;
void
NotifyAddedSource
(
)
;
void
NotifyLoadError
(
)
;
void
NotifyMediaTrackEnabled
(
MediaTrack
*
aTrack
)
;
void
NotifyMediaStreamTracksAvailable
(
DOMMediaStream
*
aStream
)
;
virtual
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
;
uint32_t
GetCurrentLoadID
(
)
{
return
mCurrentLoadID
;
}
already_AddRefed
<
nsILoadGroup
>
GetDocumentLoadGroup
(
)
;
bool
GetPlayedOrSeeked
(
)
const
{
return
mHasPlayedOrSeeked
;
}
nsresult
CopyInnerTo
(
Element
*
aDest
)
;
virtual
nsresult
SetAcceptHeader
(
nsIHttpChannel
*
aChannel
)
=
0
;
void
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
)
;
void
RunInStableState
(
nsIRunnable
*
aRunnable
)
;
virtual
void
FireTimeUpdate
(
bool
aPeriodic
)
final
override
;
MediaStream
*
GetSrcMediaStream
(
)
const
{
if
(
!
mSrcStream
)
{
return
nullptr
;
}
if
(
mSrcStream
-
>
GetCameraStream
(
)
)
{
return
mSrcStream
-
>
GetCameraStream
(
)
;
}
return
mSrcStream
-
>
GetPlaybackStream
(
)
;
}
MediaError
*
GetError
(
)
const
{
return
mError
;
}
void
SetSrc
(
const
nsAString
&
aSrc
ErrorResult
&
aRv
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aRv
)
;
}
void
GetCrossOrigin
(
nsAString
&
aResult
)
{
GetEnumAttr
(
nsGkAtoms
:
:
crossorigin
nullptr
aResult
)
;
}
void
SetCrossOrigin
(
const
nsAString
&
aCrossOrigin
ErrorResult
&
aError
)
{
SetOrRemoveNullableStringAttr
(
nsGkAtoms
:
:
crossorigin
aCrossOrigin
aError
)
;
}
uint16_t
NetworkState
(
)
const
{
return
mNetworkState
;
}
virtual
void
ResetConnectionState
(
)
final
override
;
virtual
void
SetAudibleState
(
bool
aAudible
)
final
override
;
void
NotifyAudioPlaybackChanged
(
)
;
void
SetPreload
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
preload
aValue
aRv
)
;
}
already_AddRefed
<
TimeRanges
>
Buffered
(
)
const
;
uint16_t
ReadyState
(
)
const
{
return
mReadyState
;
}
bool
Seeking
(
)
const
;
double
CurrentTime
(
)
const
;
void
SetCurrentTime
(
double
aCurrentTime
ErrorResult
&
aRv
)
;
void
FastSeek
(
double
aTime
ErrorResult
&
aRv
)
;
double
Duration
(
)
const
;
bool
HasAudio
(
)
const
{
return
mMediaInfo
.
HasAudio
(
)
;
}
bool
HasVideo
(
)
const
{
return
mMediaInfo
.
HasVideo
(
)
;
}
bool
IsEncrypted
(
)
const
{
return
mIsEncrypted
;
}
bool
Paused
(
)
const
{
return
mPaused
;
}
double
DefaultPlaybackRate
(
)
const
{
return
mDefaultPlaybackRate
;
}
void
SetDefaultPlaybackRate
(
double
aDefaultPlaybackRate
ErrorResult
&
aRv
)
;
double
PlaybackRate
(
)
const
{
return
mPlaybackRate
;
}
void
SetPlaybackRate
(
double
aPlaybackRate
ErrorResult
&
aRv
)
;
already_AddRefed
<
TimeRanges
>
Played
(
)
;
already_AddRefed
<
TimeRanges
>
Seekable
(
)
const
;
bool
Ended
(
)
;
bool
Autoplay
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
autoplay
)
;
}
void
SetAutoplay
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
autoplay
aValue
aRv
)
;
}
bool
Loop
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
loop
)
;
}
void
SetLoop
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
loop
aValue
aRv
)
;
}
void
Play
(
ErrorResult
&
aRv
)
;
void
Pause
(
ErrorResult
&
aRv
)
;
bool
Controls
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
controls
)
;
}
void
SetControls
(
bool
aValue
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
controls
aValue
aRv
)
;
}
double
Volume
(
)
const
{
return
mVolume
;
}
void
SetVolume
(
double
aVolume
ErrorResult
&
aRv
)
;
bool
Muted
(
)
const
{
return
mMuted
&
MUTED_BY_CONTENT
;
}
bool
DefaultMuted
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
muted
)
;
}
void
SetDefaultMuted
(
bool
aMuted
ErrorResult
&
aRv
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
muted
aMuted
aRv
)
;
}
bool
MozMediaStatisticsShowing
(
)
const
{
return
mStatsShowing
;
}
void
SetMozMediaStatisticsShowing
(
bool
aShow
)
{
mStatsShowing
=
aShow
;
}
bool
MozAllowCasting
(
)
const
{
return
mAllowCasting
;
}
void
SetMozAllowCasting
(
bool
aShow
)
{
mAllowCasting
=
aShow
;
}
bool
MozIsCasting
(
)
const
{
return
mIsCasting
;
}
void
SetMozIsCasting
(
bool
aShow
)
{
mIsCasting
=
aShow
;
}
already_AddRefed
<
MediaSource
>
GetMozMediaSourceObject
(
)
const
;
void
GetMozDebugReaderData
(
nsAString
&
aString
)
;
void
MozDumpDebugInfo
(
)
;
already_AddRefed
<
DOMMediaStream
>
GetSrcObject
(
)
const
;
void
SetSrcObject
(
DOMMediaStream
&
aValue
)
;
void
SetSrcObject
(
DOMMediaStream
*
aValue
)
;
already_AddRefed
<
DOMMediaStream
>
GetMozSrcObject
(
)
const
;
void
SetMozSrcObject
(
DOMMediaStream
&
aValue
)
;
void
SetMozSrcObject
(
DOMMediaStream
*
aValue
)
;
bool
MozPreservesPitch
(
)
const
{
return
mPreservesPitch
;
}
#
ifdef
MOZ_EME
MediaKeys
*
GetMediaKeys
(
)
const
;
already_AddRefed
<
Promise
>
SetMediaKeys
(
MediaKeys
*
mediaKeys
ErrorResult
&
aRv
)
;
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOnencrypted
(
)
;
void
SetOnencrypted
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
listener
)
;
void
DispatchEncrypted
(
const
nsTArray
<
uint8_t
>
&
aInitData
const
nsAString
&
aInitDataType
)
override
;
bool
IsEventAttributeName
(
nsIAtom
*
aName
)
override
;
already_AddRefed
<
nsIPrincipal
>
GetTopLevelPrincipal
(
)
;
bool
ContainsRestrictedContent
(
)
;
#
endif
bool
MozAutoplayEnabled
(
)
const
{
return
mAutoplayEnabled
;
}
already_AddRefed
<
DOMMediaStream
>
MozCaptureStream
(
ErrorResult
&
aRv
MediaStreamGraph
*
aGraph
=
nullptr
)
;
already_AddRefed
<
DOMMediaStream
>
MozCaptureStreamUntilEnded
(
ErrorResult
&
aRv
MediaStreamGraph
*
aGraph
=
nullptr
)
;
bool
MozAudioCaptured
(
)
const
{
return
mAudioCaptured
;
}
void
MozGetMetadata
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aRv
)
;
double
MozFragmentEnd
(
)
;
AudioChannel
MozAudioChannelType
(
)
const
{
return
mAudioChannel
;
}
void
SetMozAudioChannelType
(
AudioChannel
aValue
ErrorResult
&
aRv
)
;
AudioTrackList
*
AudioTracks
(
)
;
VideoTrackList
*
VideoTracks
(
)
;
TextTrackList
*
GetTextTracks
(
)
;
already_AddRefed
<
TextTrack
>
AddTextTrack
(
TextTrackKind
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
)
;
void
AddTextTrack
(
TextTrack
*
aTextTrack
)
{
GetOrCreateTextTrackManager
(
)
-
>
AddTextTrack
(
aTextTrack
)
;
}
void
RemoveTextTrack
(
TextTrack
*
aTextTrack
bool
aPendingListOnly
=
false
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
RemoveTextTrack
(
aTextTrack
aPendingListOnly
)
;
}
}
void
AddCue
(
TextTrackCue
&
aCue
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
AddCue
(
aCue
)
;
}
}
nsresult
FinishDecoderSetup
(
MediaDecoder
*
aDecoder
MediaResource
*
aStream
)
{
return
FinishDecoderSetup
(
aDecoder
aStream
nullptr
)
;
}
bool
IsBeingDestroyed
(
)
;
IMPL_EVENT_HANDLER
(
mozinterruptbegin
)
IMPL_EVENT_HANDLER
(
mozinterruptend
)
float
ComputedVolume
(
)
const
;
bool
ComputedMuted
(
)
const
;
nsSuspendedTypes
ComputedSuspended
(
)
const
;
protected
:
virtual
~
HTMLMediaElement
(
)
;
class
MediaLoadListener
;
class
MediaStreamTracksAvailableCallback
;
class
MediaStreamTrackListener
;
class
StreamListener
;
class
StreamSizeListener
;
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
;
void
SetDecoder
(
MediaDecoder
*
aDecoder
)
{
MOZ_ASSERT
(
aDecoder
)
;
mDecoder
=
aDecoder
;
}
class
WakeLockBoolWrapper
{
public
:
explicit
WakeLockBoolWrapper
(
bool
val
=
false
)
:
mValue
(
val
)
mCanPlay
(
true
)
mOuter
(
nullptr
)
{
}
~
WakeLockBoolWrapper
(
)
;
void
SetOuter
(
HTMLMediaElement
*
outer
)
{
mOuter
=
outer
;
}
void
SetCanPlay
(
bool
aCanPlay
)
;
MOZ_IMPLICIT
operator
bool
(
)
const
{
return
mValue
;
}
WakeLockBoolWrapper
&
operator
=
(
bool
val
)
;
bool
operator
!
(
)
const
{
return
!
mValue
;
}
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
private
:
void
UpdateWakeLock
(
)
;
bool
mValue
;
bool
mCanPlay
;
HTMLMediaElement
*
mOuter
;
nsCOMPtr
<
nsITimer
>
mTimer
;
}
;
nsresult
PlayInternal
(
bool
aCallerIsChrome
)
;
void
ChangeReadyState
(
nsMediaReadyState
aState
)
;
void
ChangeNetworkState
(
nsMediaNetworkState
aState
)
;
virtual
void
WakeLockCreate
(
)
;
virtual
void
WakeLockRelease
(
)
;
RefPtr
<
WakeLock
>
mWakeLock
;
void
ReportLoadError
(
const
char
*
aMsg
const
char16_t
*
*
aParams
=
nullptr
uint32_t
aParamCount
=
0
)
;
void
SetPlayedOrSeeked
(
bool
aValue
)
;
void
SetupSrcMediaStreamPlayback
(
DOMMediaStream
*
aStream
)
;
void
EndSrcMediaStreamPlayback
(
)
;
enum
{
REMOVING_SRC_STREAM
=
0x1
}
;
void
UpdateSrcMediaStreamPlaying
(
uint32_t
aFlags
=
0
)
;
void
ConstructMediaTracks
(
)
;
void
NotifyMediaStreamTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
;
void
NotifyMediaStreamTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
;
already_AddRefed
<
DOMMediaStream
>
CaptureStreamInternal
(
bool
aFinishWhenEnded
MediaStreamGraph
*
aGraph
=
nullptr
)
;
nsresult
InitializeDecoderAsClone
(
MediaDecoder
*
aOriginal
)
;
nsresult
InitializeDecoderForChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
;
nsresult
FinishDecoderSetup
(
MediaDecoder
*
aDecoder
MediaResource
*
aStream
nsIStreamListener
*
*
aListener
)
;
void
AddMediaElementToURITable
(
)
;
void
RemoveMediaElementFromURITable
(
)
;
HTMLMediaElement
*
LookupMediaElementURITable
(
nsIURI
*
aURI
)
;
void
ShutdownDecoder
(
)
;
void
AbortExistingLoads
(
)
;
void
NoSupportedMediaSourceError
(
)
;
void
LoadFromSourceChildren
(
)
;
void
QueueLoadFromSourceTask
(
)
;
void
SelectResource
(
)
;
void
SelectResourceWrapper
(
)
;
void
QueueSelectResourceTask
(
)
;
void
ResetState
(
)
;
nsresult
LoadResource
(
)
;
nsIContent
*
GetNextSource
(
)
;
void
ChangeDelayLoadStatus
(
bool
aDelay
)
;
void
StopSuspendingAfterFirstFrame
(
)
;
nsresult
OnChannelRedirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
;
void
AddRemoveSelfReference
(
)
;
void
DoRemoveSelfReference
(
)
;
enum
PreloadAttrValue
{
PRELOAD_ATTR_EMPTY
PRELOAD_ATTR_NONE
PRELOAD_ATTR_METADATA
PRELOAD_ATTR_AUTO
}
;
enum
PreloadAction
{
PRELOAD_UNDEFINED
=
0
PRELOAD_NONE
=
1
PRELOAD_METADATA
=
2
PRELOAD_ENOUGH
=
3
}
;
void
DoLoad
(
)
;
void
SuspendLoad
(
)
;
void
ResumeLoad
(
PreloadAction
aAction
)
;
void
UpdatePreloadAction
(
)
;
void
CheckProgress
(
bool
aHaveNewProgress
)
;
static
void
ProgressTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
StartProgressTimer
(
)
;
void
StartProgress
(
)
;
void
StopProgress
(
)
;
void
DispatchAsyncSourceError
(
nsIContent
*
aSourceElement
)
;
void
Error
(
uint16_t
aErrorCode
)
;
void
GetCurrentSpec
(
nsCString
&
aString
)
;
void
ProcessMediaFragmentURI
(
)
;
void
SetMutedInternal
(
uint32_t
aMuted
)
;
void
SetVolumeInternal
(
)
;
void
SuspendOrResumeElement
(
bool
aPauseElement
bool
aSuspendEvents
)
;
virtual
HTMLMediaElement
*
GetMediaElement
(
)
final
override
{
return
this
;
}
virtual
bool
GetPaused
(
)
final
override
{
bool
isPaused
=
false
;
GetPaused
(
&
isPaused
)
;
return
isPaused
;
}
#
ifdef
MOZ_EME
void
ReportEMETelemetry
(
)
;
#
endif
void
ReportTelemetry
(
)
;
bool
CheckAudioChannelPermissions
(
const
nsAString
&
aType
)
;
void
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
ErrorResult
&
aRv
)
;
bool
IsPlayingThroughTheAudioChannel
(
)
const
;
bool
IsCurrentlyPlaying
(
)
const
;
void
UpdateAudioChannelPlayingState
(
)
;
void
PopulatePendingTextTrackList
(
)
;
TextTrackManager
*
GetOrCreateTextTrackManager
(
)
;
void
UpdateReadyStateInternal
(
)
;
void
NotifyAudioChannelAgent
(
bool
aPlaying
)
;
bool
MaybeCreateAudioChannelAgent
(
)
;
void
PauseByAudioChannel
(
SuspendTypes
aSuspend
)
;
void
BlockByAudioChannel
(
)
;
void
ResumeFromAudioChannel
(
)
;
void
ResumeFromAudioChannelPaused
(
SuspendTypes
aSuspend
)
;
void
ResumeFromAudioChannelBlocked
(
)
;
bool
IsSuspendedByAudioChannel
(
)
const
;
void
SetAudioChannelSuspended
(
SuspendTypes
aSuspend
)
;
bool
IsAllowedToPlay
(
)
;
class
nsAsyncEventRunner
;
using
nsGenericHTMLElement
:
:
DispatchEvent
;
nsresult
DispatchEvent
(
const
nsAString
&
aName
)
;
RefPtr
<
MediaDecoder
>
mDecoder
;
nsTArray
<
DecoderPrincipalChangeObserver
*
>
mDecoderPrincipalChangeObservers
;
WatchManager
<
HTMLMediaElement
>
mWatchManager
;
RefPtr
<
VideoFrameContainer
>
mVideoFrameContainer
;
RefPtr
<
DOMMediaStream
>
mSrcAttrStream
;
RefPtr
<
DOMMediaStream
>
mSrcStream
;
double
mSrcStreamPausedCurrentTime
;
RefPtr
<
MediaInputPort
>
mCaptureStreamPort
;
struct
OutputMediaStream
{
RefPtr
<
DOMMediaStream
>
mStream
;
bool
mFinishWhenEnded
;
}
;
nsTArray
<
OutputMediaStream
>
mOutputStreams
;
RefPtr
<
StreamListener
>
mMediaStreamListener
;
RefPtr
<
StreamSizeListener
>
mMediaStreamSizeListener
;
RefPtr
<
MediaSource
>
mSrcMediaSource
;
RefPtr
<
MediaSource
>
mMediaSource
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
RefPtr
<
MediaError
>
mError
;
uint32_t
mCurrentLoadID
;
RefPtr
<
nsRange
>
mSourcePointer
;
nsCOMPtr
<
nsIDocument
>
mLoadBlockedDoc
;
nsTArray
<
nsString
>
mPendingEvents
;
nsMediaNetworkState
mNetworkState
;
Watchable
<
nsMediaReadyState
>
mReadyState
;
enum
LoadAlgorithmState
{
NOT_WAITING
WAITING_FOR_SOURCE
}
;
LoadAlgorithmState
mLoadWaitStatus
;
double
mVolume
;
nsAutoPtr
<
const
MetadataTags
>
mTags
;
nsCOMPtr
<
nsIURI
>
mLoadingSrc
;
PreloadAction
mPreloadAction
;
TimeStamp
mTimeUpdateTime
;
TimeStamp
mProgressTime
;
TimeStamp
mDataTime
;
double
mLastCurrentTime
;
double
mFragmentStart
;
double
mFragmentEnd
;
double
mDefaultPlaybackRate
;
double
mPlaybackRate
;
bool
mPreservesPitch
;
nsCOMPtr
<
nsIContent
>
mSourceLoadCandidate
;
RefPtr
<
TimeRanges
>
mPlayed
;
nsCOMPtr
<
nsITimer
>
mProgressTimer
;
#
ifdef
MOZ_EME
RefPtr
<
MediaKeys
>
mMediaKeys
;
#
endif
double
mCurrentPlayRangeStart
;
bool
mBegun
;
bool
mLoadedDataFired
;
bool
mAutoplaying
;
bool
mAutoplayEnabled
;
WakeLockBoolWrapper
mPaused
;
enum
MutedReasons
{
MUTED_BY_CONTENT
=
0x01
MUTED_BY_INVALID_PLAYBACK_RATE
=
0x02
MUTED_BY_AUDIO_CHANNEL
=
0x04
MUTED_BY_AUDIO_TRACK
=
0x08
}
;
uint32_t
mMuted
;
SuspendTypes
mAudioChannelSuspended
;
bool
mStatsShowing
;
bool
mAllowCasting
;
bool
mIsCasting
;
bool
mAudioCaptured
;
bool
mAudioCapturedByWindow
;
bool
mPlayingBeforeSeek
;
bool
mPlayingThroughTheAudioChannelBeforeSeek
;
bool
mPausedForInactiveDocumentOrChannel
;
bool
mEventDeliveryPaused
;
bool
mWaitingFired
;
bool
mIsRunningLoadMethod
;
bool
mIsDoingExplicitLoad
;
bool
mIsLoadingFromSourceChildren
;
bool
mDelayingLoadEvent
;
bool
mIsRunningSelectResource
;
bool
mHaveQueuedSelectResource
;
bool
mSuspendedAfterFirstFrame
;
bool
mAllowSuspendAfterFirstFrame
;
bool
mHasPlayedOrSeeked
;
bool
mHasSelfReference
;
bool
mShuttingDown
;
bool
mSuspendedForPreloadNone
;
bool
mSrcStreamIsPlaying
;
bool
mMediaSecurityVerified
;
CORSMode
mCORSMode
;
MediaInfo
mMediaInfo
;
bool
mIsEncrypted
;
#
ifdef
MOZ_EME
EncryptionInfo
mPendingEncryptedInitData
;
#
endif
Watchable
<
bool
>
mDownloadSuspendedByCache
;
AudioChannel
mAudioChannel
;
float
mAudioChannelVolume
;
bool
mPlayingThroughTheAudioChannel
;
bool
mDisableVideo
;
bool
mPlayBlockedBecauseHidden
;
nsCOMPtr
<
nsIAudioChannelAgent
>
mAudioChannelAgent
;
RefPtr
<
TextTrackManager
>
mTextTrackManager
;
RefPtr
<
AudioTrackList
>
mAudioTrackList
;
RefPtr
<
VideoTrackList
>
mVideoTrackList
;
nsAutoPtr
<
MediaStreamTrackListener
>
mMediaStreamTrackListener
;
nsCOMPtr
<
nsIPrincipal
>
mSrcStreamVideoPrincipal
;
enum
ElementInTreeState
{
ELEMENT_NOT_INTREE
ELEMENT_INTREE
ELEMENT_NOT_INTREE_HAD_INTREE
}
;
ElementInTreeState
mElementInTreeState
;
public
:
class
TimeDurationAccumulator
{
public
:
TimeDurationAccumulator
(
)
:
mCount
(
0
)
{
}
void
Start
(
)
{
if
(
IsStarted
(
)
)
{
return
;
}
mStartTime
=
TimeStamp
:
:
Now
(
)
;
}
void
Pause
(
)
{
if
(
!
IsStarted
(
)
)
{
return
;
}
mSum
+
=
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
;
mCount
+
+
;
mStartTime
=
TimeStamp
(
)
;
}
bool
IsStarted
(
)
const
{
return
!
mStartTime
.
IsNull
(
)
;
}
double
Total
(
)
const
{
return
mSum
.
ToSeconds
(
)
;
}
uint32_t
Count
(
)
const
{
return
mCount
;
}
private
:
TimeStamp
mStartTime
;
TimeDuration
mSum
;
uint32_t
mCount
;
}
;
private
:
TimeDurationAccumulator
mPlayTime
;
bool
mHasUserInteraction
;
bool
mFirstFrameLoaded
;
double
mDefaultPlaybackStartPosition
;
bool
mIsAudioTrackAudible
;
}
;
}
}
#
endif
