#
ifndef
nsGenericHTMLElement_h___
#
define
nsGenericHTMLElement_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
nsMappedAttributeElement
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
ValidityState
.
h
"
class
nsDOMTokenList
;
class
nsIFormControlFrame
;
class
nsIFrame
;
class
nsILayoutHistoryState
;
class
nsIURI
;
struct
nsSize
;
namespace
mozilla
{
class
EditorBase
;
class
ErrorResult
;
class
EventChainPostVisitor
;
class
EventChainPreVisitor
;
class
EventChainVisitor
;
class
EventListenerManager
;
class
EventStates
;
class
PresState
;
namespace
dom
{
class
ElementInternals
;
class
HTMLFormElement
;
class
HTMLMenuElement
;
}
}
using
nsGenericHTMLElementBase
=
nsMappedAttributeElement
;
class
nsGenericHTMLElement
:
public
nsGenericHTMLElementBase
{
public
:
using
Element
:
:
Focus
;
using
Element
:
:
SetTabIndex
;
explicit
nsGenericHTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsGenericHTMLElementBase
(
std
:
:
move
(
aNodeInfo
)
)
{
NS_ASSERTION
(
mNodeInfo
-
>
NamespaceID
(
)
=
=
kNameSpaceID_XHTML
"
Unexpected
namespace
"
)
;
AddStatesSilently
(
NS_EVENT_STATE_LTR
)
;
SetFlags
(
NODE_HAS_DIRECTION_LTR
)
;
}
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
nsGenericHTMLElement
nsGenericHTMLElementBase
)
NS_IMPL_FROMNODE
(
nsGenericHTMLElement
kNameSpaceID_XHTML
)
nsresult
CopyInnerTo
(
mozilla
:
:
dom
:
:
Element
*
aDest
)
;
void
GetTitle
(
mozilla
:
:
dom
:
:
DOMString
&
aTitle
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
title
aTitle
)
;
}
void
SetTitle
(
const
nsAString
&
aTitle
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
title
aTitle
)
;
}
void
GetLang
(
mozilla
:
:
dom
:
:
DOMString
&
aLang
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
lang
aLang
)
;
}
void
SetLang
(
const
nsAString
&
aLang
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
lang
aLang
)
;
}
void
GetDir
(
nsAString
&
aDir
)
{
GetHTMLEnumAttr
(
nsGkAtoms
:
:
dir
aDir
)
;
}
void
SetDir
(
const
nsAString
&
aDir
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
dir
aDir
aError
)
;
}
bool
Hidden
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
hidden
)
;
}
void
SetHidden
(
bool
aHidden
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
hidden
aHidden
aError
)
;
}
bool
Inert
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
inert
)
;
}
void
SetInert
(
bool
aInert
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
inert
aInert
aError
)
;
}
MOZ_CAN_RUN_SCRIPT
void
Click
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
GetAccessKey
(
nsString
&
aAccessKey
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
accesskey
aAccessKey
)
;
}
void
SetAccessKey
(
const
nsAString
&
aAccessKey
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
accesskey
aAccessKey
aError
)
;
}
void
GetAccessKeyLabel
(
nsString
&
aAccessKeyLabel
)
;
virtual
bool
Draggable
(
)
const
{
return
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
draggable
nsGkAtoms
:
:
_true
eIgnoreCase
)
;
}
void
SetDraggable
(
bool
aDraggable
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
draggable
aDraggable
?
u
"
true
"
_ns
:
u
"
false
"
_ns
aError
)
;
}
void
GetContentEditable
(
nsString
&
aContentEditable
)
{
ContentEditableTristate
value
=
GetContentEditableValue
(
)
;
if
(
value
=
=
eTrue
)
{
aContentEditable
.
AssignLiteral
(
"
true
"
)
;
}
else
if
(
value
=
=
eFalse
)
{
aContentEditable
.
AssignLiteral
(
"
false
"
)
;
}
else
{
aContentEditable
.
AssignLiteral
(
"
inherit
"
)
;
}
}
void
SetContentEditable
(
const
nsAString
&
aContentEditable
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
aContentEditable
.
LowerCaseEqualsLiteral
(
"
inherit
"
)
)
{
UnsetHTMLAttr
(
nsGkAtoms
:
:
contenteditable
aError
)
;
}
else
if
(
aContentEditable
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
contenteditable
u
"
true
"
_ns
aError
)
;
}
else
if
(
aContentEditable
.
LowerCaseEqualsLiteral
(
"
false
"
)
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
contenteditable
u
"
false
"
_ns
aError
)
;
}
else
{
aError
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
}
}
bool
IsContentEditable
(
)
{
for
(
nsIContent
*
node
=
this
;
node
;
node
=
node
-
>
GetParent
(
)
)
{
nsGenericHTMLElement
*
element
=
FromNode
(
node
)
;
if
(
element
)
{
ContentEditableTristate
value
=
element
-
>
GetContentEditableValue
(
)
;
if
(
value
!
=
eInherit
)
{
return
value
=
=
eTrue
;
}
}
}
return
false
;
}
void
SetNonce
(
const
nsAString
&
aNonce
)
{
SetProperty
(
nsGkAtoms
:
:
nonce
new
nsString
(
aNonce
)
nsINode
:
:
DeleteProperty
<
nsString
>
)
;
}
void
RemoveNonce
(
)
{
RemoveProperty
(
nsGkAtoms
:
:
nonce
)
;
}
void
GetNonce
(
nsAString
&
aNonce
)
const
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
aNonce
=
*
cspNonce
;
}
}
bool
IsFormControlDefaultFocusable
(
bool
aWithMouse
)
const
;
uint32_t
EditableInclusiveDescendantCount
(
)
;
mozilla
:
:
dom
:
:
HTMLMenuElement
*
GetContextMenu
(
)
const
;
bool
Spellcheck
(
)
;
void
SetSpellcheck
(
bool
aSpellcheck
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
spellcheck
aSpellcheck
?
u
"
true
"
_ns
:
u
"
false
"
_ns
aError
)
;
}
MOZ_CAN_RUN_SCRIPT
void
GetInnerText
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT
void
GetOuterText
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
ErrorResult
&
aError
)
{
return
GetInnerText
(
aValue
aError
)
;
}
MOZ_CAN_RUN_SCRIPT
void
SetInnerText
(
const
nsAString
&
aValue
)
;
MOZ_CAN_RUN_SCRIPT
void
SetOuterText
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
;
void
GetInputMode
(
nsAString
&
aValue
)
{
GetEnumAttr
(
nsGkAtoms
:
:
inputmode
nullptr
aValue
)
;
}
void
SetInputMode
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
inputmode
aValue
aRv
)
;
}
virtual
void
GetAutocapitalize
(
nsAString
&
aValue
)
const
;
void
SetAutocapitalize
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
autocapitalize
aValue
aRv
)
;
}
void
GetEnterKeyHint
(
nsAString
&
aValue
)
const
{
GetEnumAttr
(
nsGkAtoms
:
:
enterkeyhint
nullptr
aValue
)
;
}
void
SetEnterKeyHint
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
enterkeyhint
aValue
aRv
)
;
}
virtual
bool
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
override
;
#
define
EVENT
(
name_
id_
type_
struct_
)
#
define
FORWARDED_EVENT
(
name_
id_
type_
struct_
)
\
using
nsINode
:
:
GetOn
#
#
name_
;
\
using
nsINode
:
:
SetOn
#
#
name_
;
\
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOn
#
#
name_
(
)
;
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
;
#
define
ERROR_EVENT
(
name_
id_
type_
struct_
)
\
using
nsINode
:
:
GetOn
#
#
name_
;
\
using
nsINode
:
:
SetOn
#
#
name_
;
\
already_AddRefed
<
mozilla
:
:
dom
:
:
EventHandlerNonNull
>
GetOn
#
#
name_
(
)
;
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
;
#
include
"
mozilla
/
EventNameList
.
h
"
/
/
IWYU
pragma
:
keep
#
undef
ERROR_EVENT
#
undef
FORWARDED_EVENT
#
undef
EVENT
mozilla
:
:
dom
:
:
Element
*
GetOffsetParent
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
return
GetOffsetRect
(
rcFrame
)
;
}
int32_t
OffsetTop
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
y
;
}
int32_t
OffsetLeft
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
x
;
}
int32_t
OffsetWidth
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
Width
(
)
;
}
int32_t
OffsetHeight
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
Height
(
)
;
}
inline
bool
IsHTMLElement
(
)
const
{
return
true
;
}
inline
bool
IsHTMLElement
(
nsAtom
*
aTag
)
const
{
return
mNodeInfo
-
>
Equals
(
aTag
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
virtual
already_AddRefed
<
mozilla
:
:
dom
:
:
ElementInternals
>
AttachInternals
(
ErrorResult
&
aRv
)
;
mozilla
:
:
dom
:
:
ElementInternals
*
GetInternals
(
)
const
;
bool
IsFormAssociatedCustomElements
(
)
const
;
virtual
bool
IsDisabledForEvents
(
mozilla
:
:
WidgetEvent
*
aEvent
)
{
return
false
;
}
protected
:
virtual
~
nsGenericHTMLElement
(
)
=
default
;
public
:
virtual
nsresult
BindToTree
(
BindContext
&
nsINode
&
aParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aNullParent
=
true
)
override
;
virtual
bool
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
override
{
bool
isFocusable
=
false
;
IsHTMLFocusable
(
aWithMouse
&
isFocusable
aTabIndex
)
;
return
isFocusable
;
}
virtual
bool
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
;
MOZ_CAN_RUN_SCRIPT
virtual
mozilla
:
:
Result
<
bool
nsresult
>
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
override
;
bool
CheckHandleEventForAnchorsPreconditions
(
mozilla
:
:
EventChainVisitor
&
aVisitor
)
;
void
GetEventTargetParentForAnchors
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
PostHandleEventForAnchors
(
mozilla
:
:
EventChainPostVisitor
&
aVisitor
)
;
bool
IsHTMLLink
(
nsIURI
*
*
aURI
)
const
;
void
Compact
(
)
{
mAttrs
.
Compact
(
)
;
}
virtual
void
UpdateEditableState
(
bool
aNotify
)
override
;
virtual
mozilla
:
:
EventStates
IntrinsicState
(
)
const
override
;
void
DoSetEditableFlag
(
bool
aEditable
bool
aNotify
)
{
SetEditableFlag
(
aEditable
)
;
UpdateState
(
aNotify
)
;
}
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
bool
ParseBackgroundAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
;
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
override
;
virtual
nsMapRuleToAttributesFunc
GetAttributeMappingFunction
(
)
const
override
;
void
GetBaseTarget
(
nsAString
&
aBaseTarget
)
const
;
nsIFormControlFrame
*
GetFormControlFrame
(
bool
aFlushFrames
)
;
static
bool
ParseAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseDivAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseTableHAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseTableCellHAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseTableVAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseImageAttribute
(
nsAtom
*
aAttribute
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseReferrerAttribute
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseFrameborderValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseScrollingValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
void
MapCommonAttributesInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapCommonAttributesIntoExceptHidden
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
const
MappedAttributeEntry
sCommonAttributeMap
[
]
;
static
const
MappedAttributeEntry
sImageMarginSizeAttributeMap
[
]
;
static
const
MappedAttributeEntry
sImageBorderAttributeMap
[
]
;
static
const
MappedAttributeEntry
sImageAlignAttributeMap
[
]
;
static
const
MappedAttributeEntry
sDivAlignAttributeMap
[
]
;
static
const
MappedAttributeEntry
sBackgroundAttributeMap
[
]
;
static
const
MappedAttributeEntry
sBackgroundColorAttributeMap
[
]
;
static
void
MapImageAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapDivAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapVAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapImageBorderAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapImageMarginAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
enum
class
MapAspectRatio
{
No
Yes
}
;
static
void
MapImageSizeAttributesInto
(
const
nsMappedAttributes
*
mozilla
:
:
MappedDeclarations
&
MapAspectRatio
=
MapAspectRatio
:
:
No
)
;
static
void
MapAspectRatioInto
(
const
nsMappedAttributes
*
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapWidthAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapHeightAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapBackgroundInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapBGColorInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapBackgroundAttributesInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapScrollingAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
mozilla
:
:
dom
:
:
HTMLFormElement
*
FindAncestorForm
(
mozilla
:
:
dom
:
:
HTMLFormElement
*
aCurrentForm
=
nullptr
)
;
static
bool
InNavQuirksMode
(
Document
*
)
;
void
GetURIAttr
(
nsAtom
*
aAttr
nsAtom
*
aBaseAttr
nsAString
&
aResult
)
const
;
bool
GetURIAttr
(
nsAtom
*
aAttr
nsAtom
*
aBaseAttr
nsIURI
*
*
aURI
)
const
;
bool
IsHidden
(
)
const
{
return
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
)
;
}
virtual
bool
IsLabelable
(
)
const
override
;
static
bool
MatchLabelsElement
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
;
already_AddRefed
<
nsINodeList
>
Labels
(
)
;
static
bool
LegacyTouchAPIEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
;
static
inline
bool
CanHaveName
(
nsAtom
*
aTag
)
{
return
aTag
=
=
nsGkAtoms
:
:
img
|
|
aTag
=
=
nsGkAtoms
:
:
form
|
|
aTag
=
=
nsGkAtoms
:
:
embed
|
|
aTag
=
=
nsGkAtoms
:
:
object
;
}
static
inline
bool
ShouldExposeNameAsHTMLDocumentProperty
(
Element
*
aElement
)
{
return
aElement
-
>
IsHTMLElement
(
)
&
&
CanHaveName
(
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
static
inline
bool
ShouldExposeIdAsHTMLDocumentProperty
(
Element
*
aElement
)
{
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
{
return
true
;
}
return
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
&
&
aElement
-
>
HasName
(
)
;
}
virtual
inline
void
ResultForDialogSubmit
(
nsAString
&
aResult
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aResult
)
;
}
protected
:
void
AddToNameTable
(
nsAtom
*
aName
)
;
void
RemoveFromNameTable
(
)
;
void
RegUnRegAccessKey
(
bool
aDoReg
)
override
{
if
(
!
HasFlag
(
NODE_HAS_ACCESSKEY
)
)
{
return
;
}
nsStyledElement
:
:
RegUnRegAccessKey
(
aDoReg
)
;
}
protected
:
virtual
nsresult
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
nsresult
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HandleKeyboardActivation
(
mozilla
:
:
EventChainPostVisitor
&
)
;
MOZ_CAN_RUN_SCRIPT
static
nsresult
DispatchSimulatedClick
(
nsGenericHTMLElement
*
aElement
bool
aIsTrusted
nsPresContext
*
aPresContext
)
;
nsresult
NewURIFromString
(
const
nsAString
&
aURISpec
nsIURI
*
*
aURI
)
;
void
GetHTMLAttr
(
nsAtom
*
aName
nsAString
&
aResult
)
const
{
GetAttr
(
aName
aResult
)
;
}
void
GetHTMLAttr
(
nsAtom
*
aName
mozilla
:
:
dom
:
:
DOMString
&
aResult
)
const
{
GetAttr
(
kNameSpaceID_None
aName
aResult
)
;
}
void
GetHTMLEnumAttr
(
nsAtom
*
aName
nsAString
&
aResult
)
const
{
GetEnumAttr
(
aName
nullptr
aResult
)
;
}
void
GetHTMLURIAttr
(
nsAtom
*
aName
nsAString
&
aResult
)
const
{
GetURIAttr
(
aName
nullptr
aResult
)
;
}
void
SetHTMLAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
SetAttr
(
kNameSpaceID_None
aName
aValue
true
)
;
}
void
SetHTMLAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
SetAttr
(
aName
aValue
aError
)
;
}
void
SetHTMLAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
mozilla
:
:
ErrorResult
&
aError
)
{
SetAttr
(
aName
aValue
aTriggeringPrincipal
aError
)
;
}
void
UnsetHTMLAttr
(
nsAtom
*
aName
mozilla
:
:
ErrorResult
&
aError
)
{
UnsetAttr
(
aName
aError
)
;
}
void
SetHTMLBoolAttr
(
nsAtom
*
aName
bool
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
aValue
)
{
SetHTMLAttr
(
aName
u
"
"
_ns
aError
)
;
}
else
{
UnsetHTMLAttr
(
aName
aError
)
;
}
}
template
<
typename
T
>
void
SetHTMLIntAttr
(
nsAtom
*
aName
T
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
nsAutoString
value
;
value
.
AppendInt
(
aValue
)
;
SetHTMLAttr
(
aName
value
aError
)
;
}
int32_t
GetIntAttr
(
nsAtom
*
aAttr
int32_t
aDefault
)
const
;
nsresult
SetIntAttr
(
nsAtom
*
aAttr
int32_t
aValue
)
;
uint32_t
GetUnsignedIntAttr
(
nsAtom
*
aAttr
uint32_t
aDefault
)
const
;
void
SetUnsignedIntAttr
(
nsAtom
*
aName
uint32_t
aValue
uint32_t
aDefault
mozilla
:
:
ErrorResult
&
aError
)
{
nsAutoString
value
;
if
(
aValue
>
INT32_MAX
)
{
value
.
AppendInt
(
aDefault
)
;
}
else
{
value
.
AppendInt
(
aValue
)
;
}
SetHTMLAttr
(
aName
value
aError
)
;
}
uint32_t
GetDimensionAttrAsUnsignedInt
(
nsAtom
*
aAttr
uint32_t
aDefault
)
const
;
void
SetDoubleAttr
(
nsAtom
*
aAttr
double
aValue
mozilla
:
:
ErrorResult
&
aRv
)
{
nsAutoString
value
;
value
.
AppendFloat
(
aValue
)
;
SetHTMLAttr
(
aAttr
value
aRv
)
;
}
virtual
already_AddRefed
<
mozilla
:
:
EditorBase
>
GetAssociatedEditor
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetOffsetRect
(
mozilla
:
:
CSSIntRect
&
aRect
)
;
static
void
SyncEditorsOnSubtree
(
nsIContent
*
content
)
;
enum
ContentEditableTristate
{
eInherit
=
-
1
eFalse
=
0
eTrue
=
1
}
;
ContentEditableTristate
GetContentEditableValue
(
)
const
{
static
const
Element
:
:
AttrValuesArray
values
[
]
=
{
nsGkAtoms
:
:
_false
nsGkAtoms
:
:
_true
nsGkAtoms
:
:
_empty
nullptr
}
;
if
(
!
MayHaveContentEditableAttr
(
)
)
return
eInherit
;
int32_t
value
=
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
contenteditable
values
eIgnoreCase
)
;
return
value
>
0
?
eTrue
:
(
value
=
=
0
?
eFalse
:
eInherit
)
;
}
already_AddRefed
<
nsIURI
>
GetHrefURIForAnchors
(
)
const
;
public
:
bool
IsEditableRoot
(
)
const
;
private
:
void
ChangeEditableState
(
int32_t
aChange
)
;
}
;
namespace
mozilla
:
:
dom
{
class
HTMLFieldSetElement
;
}
#
define
HTML_ELEMENT_FLAG_BIT
(
n_
)
\
NODE_FLAG_BIT
(
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
(
n_
)
)
enum
{
HTML_ELEMENT_ACTIVE_FOR_KEYBOARD
=
HTML_ELEMENT_FLAG_BIT
(
0
)
HTML_ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
=
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
1
}
;
ASSERT_NODE_FLAGS_SPACE
(
HTML_ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
)
;
#
define
FORM_ELEMENT_FLAG_BIT
(
n_
)
\
NODE_FLAG_BIT
(
HTML_ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
(
n_
)
)
enum
{
ADDED_TO_FORM
=
FORM_ELEMENT_FLAG_BIT
(
0
)
MAYBE_ORPHAN_FORM_ELEMENT
=
FORM_ELEMENT_FLAG_BIT
(
1
)
MAY_BE_IN_PAST_NAMES_MAP
=
FORM_ELEMENT_FLAG_BIT
(
2
)
}
;
ASSERT_NODE_FLAGS_SPACE
(
HTML_ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
3
)
;
#
undef
FORM_ELEMENT_FLAG_BIT
class
nsGenericHTMLFormElement
:
public
nsGenericHTMLElement
{
public
:
nsGenericHTMLFormElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
virtual
nsresult
BindToTree
(
BindContext
&
nsINode
&
aParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aNullParent
=
true
)
override
;
virtual
void
FieldSetDisabledChanged
(
bool
aNotify
)
;
void
FieldSetFirstLegendChanged
(
bool
aNotify
)
{
UpdateFieldSet
(
aNotify
)
;
}
void
ForgetFieldSet
(
nsIContent
*
aFieldset
)
;
void
ClearForm
(
bool
aRemoveFromForm
bool
aUnbindOrDelete
)
;
protected
:
virtual
~
nsGenericHTMLFormElement
(
)
=
default
;
virtual
nsresult
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
override
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
void
BeforeSetForm
(
bool
aBindToTree
)
{
}
virtual
void
AfterClearForm
(
bool
aUnbindOrDelete
)
{
}
virtual
void
UpdateDisabledState
(
bool
aNotify
)
;
virtual
void
SetFormInternal
(
mozilla
:
:
dom
:
:
HTMLFormElement
*
aForm
bool
aBindToTree
)
{
}
virtual
mozilla
:
:
dom
:
:
HTMLFormElement
*
GetFormInternal
(
)
const
{
return
nullptr
;
}
virtual
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
GetFieldSetInternal
(
)
const
{
return
nullptr
;
}
virtual
void
SetFieldSetInternal
(
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
aFieldset
)
{
}
virtual
void
UpdateFormOwner
(
bool
aBindToTree
Element
*
aFormIdElement
)
;
void
UpdateFieldSet
(
bool
aNotify
)
;
Element
*
AddFormIdObserver
(
)
;
void
RemoveFormIdObserver
(
)
;
static
bool
FormIdUpdated
(
Element
*
aOldElement
Element
*
aNewElement
void
*
aData
)
;
bool
IsElementDisabledForEvents
(
mozilla
:
:
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
)
;
virtual
bool
CanBeDisabled
(
)
const
{
return
false
;
}
virtual
bool
DoesReadOnlyApply
(
)
const
{
return
false
;
}
virtual
bool
IsFormAssociatedElement
(
)
const
{
return
false
;
}
}
;
class
nsGenericHTMLFormControlElement
:
public
nsGenericHTMLFormElement
public
nsIFormControl
{
public
:
nsGenericHTMLFormControlElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FormControlType
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_IMPL_FROMNODE_HELPER
(
nsGenericHTMLFormControlElement
IsNodeOfType
(
nsINode
:
:
eHTML_FORM_CONTROL
)
)
nsINode
*
GetScopeChainParent
(
)
const
override
;
virtual
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
;
virtual
void
SaveSubtreeState
(
)
override
;
virtual
IMEState
GetDesiredIMEState
(
)
override
;
virtual
nsresult
BindToTree
(
BindContext
&
nsINode
&
aParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aNullParent
=
true
)
override
;
virtual
void
GetAutocapitalize
(
nsAString
&
aValue
)
const
override
;
virtual
bool
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
override
;
void
GetEventTargetParent
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
override
;
virtual
nsresult
PreHandleEvent
(
mozilla
:
:
EventChainVisitor
&
aVisitor
)
override
;
virtual
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
GetFieldSet
(
)
override
;
virtual
mozilla
:
:
dom
:
:
HTMLFormElement
*
GetForm
(
)
const
override
{
return
mForm
;
}
virtual
void
SetForm
(
mozilla
:
:
dom
:
:
HTMLFormElement
*
aForm
)
override
;
virtual
void
ClearForm
(
bool
aRemoveFromForm
bool
aUnbindOrDelete
)
override
;
virtual
bool
AllowDrop
(
)
override
{
return
true
;
}
protected
:
virtual
~
nsGenericHTMLFormControlElement
(
)
;
virtual
mozilla
:
:
EventStates
IntrinsicState
(
)
const
override
;
virtual
bool
IsLabelable
(
)
const
override
;
bool
CanBeDisabled
(
)
const
override
;
bool
DoesReadOnlyApply
(
)
const
override
;
void
SetFormInternal
(
mozilla
:
:
dom
:
:
HTMLFormElement
*
aForm
bool
aBindToTree
)
override
;
mozilla
:
:
dom
:
:
HTMLFormElement
*
GetFormInternal
(
)
const
override
;
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
GetFieldSetInternal
(
)
const
override
;
void
SetFieldSetInternal
(
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
aFieldset
)
override
;
bool
IsFormAssociatedElement
(
)
const
override
{
return
true
;
}
void
UpdateRequiredState
(
bool
aIsRequired
bool
aNotify
)
;
bool
IsAutocapitalizeInheriting
(
)
const
;
inline
bool
IsAutofocusable
(
)
const
;
virtual
void
SaveState
(
)
{
}
mozilla
:
:
dom
:
:
HTMLFormElement
*
mForm
;
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
mFieldSet
;
}
;
class
nsGenericHTMLFormControlElementWithState
:
public
nsGenericHTMLFormControlElement
{
public
:
nsGenericHTMLFormControlElementWithState
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
FormControlType
)
;
mozilla
:
:
PresState
*
GetPrimaryPresState
(
)
;
already_AddRefed
<
nsILayoutHistoryState
>
GetLayoutHistory
(
bool
aRead
)
;
virtual
void
NodeInfoChanged
(
Document
*
aOldDoc
)
override
;
void
GetFormAction
(
nsString
&
aValue
)
;
protected
:
virtual
bool
RestoreState
(
mozilla
:
:
PresState
*
aState
)
{
return
false
;
}
bool
RestoreFormControlState
(
)
;
void
GenerateStateKey
(
)
;
int32_t
GetParserInsertedControlNumberForStateKey
(
)
const
override
{
return
mControlNumber
;
}
nsCString
mStateKey
;
int32_t
mControlNumber
;
}
;
#
define
NS_INTERFACE_MAP_ENTRY_IF_TAG
(
_interface
_tag
)
\
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
_interface
\
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
_tag
)
)
namespace
mozilla
:
:
dom
{
using
HTMLContentCreatorFunction
=
nsGenericHTMLElement
*
(
*
)
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
mozilla
:
:
dom
:
:
FromParser
)
;
}
#
define
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
_elementName
)
\
namespace
mozilla
{
\
namespace
dom
{
\
class
HTML
#
#
_elementName
#
#
Element
;
\
}
\
}
\
nsGenericHTMLElement
*
NS_NewHTML
#
#
_elementName
#
#
Element
(
\
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
#
define
NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED
(
_elementName
)
\
inline
nsGenericHTMLElement
*
NS_NewHTML
#
#
_elementName
#
#
Element
(
\
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
{
\
return
NS_NewHTMLSharedElement
(
std
:
:
move
(
aNodeInfo
)
aFromParser
)
;
\
}
#
define
NS_IMPL_NS_NEW_HTML_ELEMENT
(
_elementName
)
\
nsGenericHTMLElement
*
NS_NewHTML
#
#
_elementName
#
#
Element
(
\
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
\
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
\
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
\
MOZ_ASSERT
(
nim
)
;
\
return
new
(
nim
)
\
mozilla
:
:
dom
:
:
HTML
#
#
_elementName
#
#
Element
(
nodeInfo
.
forget
(
)
)
;
\
}
#
define
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
_elementName
)
\
nsGenericHTMLElement
*
NS_NewHTML
#
#
_elementName
#
#
Element
(
\
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
\
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
\
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
\
MOZ_ASSERT
(
nim
)
;
\
return
new
(
nim
)
mozilla
:
:
dom
:
:
HTML
#
#
_elementName
#
#
Element
(
\
nodeInfo
.
forget
(
)
aFromParser
)
;
\
}
nsGenericHTMLElement
*
NS_NewHTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
nsGenericHTMLElement
*
NS_NewCustomElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Shared
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
SharedList
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Anchor
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Area
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Audio
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
BR
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Body
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Button
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Canvas
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Content
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Mod
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Data
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
DataList
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Details
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Dialog
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Div
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Embed
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
FieldSet
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Font
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Form
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Frame
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
FrameSet
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
HR
)
NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED
(
Head
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Heading
)
NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED
(
Html
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
IFrame
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Image
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Input
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
LI
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Label
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Legend
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Link
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Marquee
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Map
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Menu
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
MenuItem
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Meta
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Meter
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Object
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
OptGroup
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Option
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Output
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Paragraph
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Picture
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Pre
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Progress
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Script
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Select
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Slot
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Source
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Span
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Style
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Summary
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableCaption
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableCell
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableCol
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Table
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableRow
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableSection
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Tbody
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Template
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TextArea
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Tfoot
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Thead
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Time
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Title
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Track
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Unknown
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Video
)
#
endif
