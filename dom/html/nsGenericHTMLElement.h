#
ifndef
nsGenericHTMLElement_h___
#
define
nsGenericHTMLElement_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
nsMappedAttributeElement
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
ValidityState
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
class
nsDOMTokenList
;
class
nsIFormControlFrame
;
class
nsIFrame
;
class
nsILayoutHistoryState
;
class
nsIURI
;
struct
nsSize
;
namespace
mozilla
{
class
EventChainPostVisitor
;
class
EventChainPreVisitor
;
class
EventChainVisitor
;
class
EventListenerManager
;
class
EventStates
;
class
TextEditor
;
class
PresState
;
namespace
dom
{
class
HTMLFormElement
;
class
HTMLMenuElement
;
}
}
typedef
nsMappedAttributeElement
nsGenericHTMLElementBase
;
class
nsGenericHTMLElement
:
public
nsGenericHTMLElementBase
{
public
:
using
Element
:
:
SetTabIndex
;
using
Element
:
:
Focus
;
explicit
nsGenericHTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsGenericHTMLElementBase
(
aNodeInfo
)
{
NS_ASSERTION
(
mNodeInfo
-
>
NamespaceID
(
)
=
=
kNameSpaceID_XHTML
"
Unexpected
namespace
"
)
;
AddStatesSilently
(
NS_EVENT_STATE_LTR
)
;
SetFlags
(
NODE_HAS_DIRECTION_LTR
)
;
}
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
nsGenericHTMLElement
nsGenericHTMLElementBase
)
NS_IMPL_FROMNODE
(
nsGenericHTMLElement
kNameSpaceID_XHTML
)
nsresult
CopyInnerTo
(
mozilla
:
:
dom
:
:
Element
*
aDest
bool
aPreallocateChildren
)
;
void
GetTitle
(
mozilla
:
:
dom
:
:
DOMString
&
aTitle
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
title
aTitle
)
;
}
void
SetTitle
(
const
nsAString
&
aTitle
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
title
aTitle
)
;
}
void
GetLang
(
mozilla
:
:
dom
:
:
DOMString
&
aLang
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
lang
aLang
)
;
}
void
SetLang
(
const
nsAString
&
aLang
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
lang
aLang
)
;
}
void
GetDir
(
nsAString
&
aDir
)
{
GetHTMLEnumAttr
(
nsGkAtoms
:
:
dir
aDir
)
;
}
void
SetDir
(
const
nsAString
&
aDir
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
dir
aDir
aError
)
;
}
bool
Hidden
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
hidden
)
;
}
void
SetHidden
(
bool
aHidden
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
hidden
aHidden
aError
)
;
}
void
Click
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
GetAccessKey
(
nsString
&
aAccessKey
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
accesskey
aAccessKey
)
;
}
void
SetAccessKey
(
const
nsAString
&
aAccessKey
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
accesskey
aAccessKey
aError
)
;
}
void
GetAccessKeyLabel
(
nsString
&
aAccessKeyLabel
)
;
virtual
bool
Draggable
(
)
const
{
return
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
draggable
nsGkAtoms
:
:
_true
eIgnoreCase
)
;
}
void
SetDraggable
(
bool
aDraggable
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
draggable
aDraggable
?
NS_LITERAL_STRING
(
"
true
"
)
:
NS_LITERAL_STRING
(
"
false
"
)
aError
)
;
}
void
GetContentEditable
(
nsString
&
aContentEditable
)
{
ContentEditableTristate
value
=
GetContentEditableValue
(
)
;
if
(
value
=
=
eTrue
)
{
aContentEditable
.
AssignLiteral
(
"
true
"
)
;
}
else
if
(
value
=
=
eFalse
)
{
aContentEditable
.
AssignLiteral
(
"
false
"
)
;
}
else
{
aContentEditable
.
AssignLiteral
(
"
inherit
"
)
;
}
}
void
SetContentEditable
(
const
nsAString
&
aContentEditable
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
aContentEditable
.
LowerCaseEqualsLiteral
(
"
inherit
"
)
)
{
UnsetHTMLAttr
(
nsGkAtoms
:
:
contenteditable
aError
)
;
}
else
if
(
aContentEditable
.
LowerCaseEqualsLiteral
(
"
true
"
)
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
contenteditable
NS_LITERAL_STRING
(
"
true
"
)
aError
)
;
}
else
if
(
aContentEditable
.
LowerCaseEqualsLiteral
(
"
false
"
)
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
contenteditable
NS_LITERAL_STRING
(
"
false
"
)
aError
)
;
}
else
{
aError
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
}
}
bool
IsContentEditable
(
)
{
for
(
nsIContent
*
node
=
this
;
node
;
node
=
node
-
>
GetParent
(
)
)
{
nsGenericHTMLElement
*
element
=
FromNode
(
node
)
;
if
(
element
)
{
ContentEditableTristate
value
=
element
-
>
GetContentEditableValue
(
)
;
if
(
value
!
=
eInherit
)
{
return
value
=
=
eTrue
;
}
}
}
return
false
;
}
uint32_t
EditableInclusiveDescendantCount
(
)
;
mozilla
:
:
dom
:
:
HTMLMenuElement
*
GetContextMenu
(
)
const
;
bool
Spellcheck
(
)
;
void
SetSpellcheck
(
bool
aSpellcheck
mozilla
:
:
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
spellcheck
aSpellcheck
?
NS_LITERAL_STRING
(
"
true
"
)
:
NS_LITERAL_STRING
(
"
false
"
)
aError
)
;
}
MOZ_CAN_RUN_SCRIPT
void
GetInnerText
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetInnerText
(
const
nsAString
&
aValue
)
;
virtual
bool
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
override
;
#
define
EVENT
(
name_
id_
type_
struct_
)
#
define
FORWARDED_EVENT
(
name_
id_
type_
struct_
)
\
using
nsINode
:
:
GetOn
#
#
name_
;
\
using
nsINode
:
:
SetOn
#
#
name_
;
\
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOn
#
#
name_
(
)
;
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
;
#
define
ERROR_EVENT
(
name_
id_
type_
struct_
)
\
using
nsINode
:
:
GetOn
#
#
name_
;
\
using
nsINode
:
:
SetOn
#
#
name_
;
\
already_AddRefed
<
mozilla
:
:
dom
:
:
EventHandlerNonNull
>
GetOn
#
#
name_
(
)
;
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
;
#
include
"
mozilla
/
EventNameList
.
h
"
/
/
IWYU
pragma
:
keep
#
undef
ERROR_EVENT
#
undef
FORWARDED_EVENT
#
undef
EVENT
mozilla
:
:
dom
:
:
Element
*
GetOffsetParent
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
return
GetOffsetRect
(
rcFrame
)
;
}
int32_t
OffsetTop
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
y
;
}
int32_t
OffsetLeft
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
x
;
}
int32_t
OffsetWidth
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
Width
(
)
;
}
int32_t
OffsetHeight
(
)
{
mozilla
:
:
CSSIntRect
rcFrame
;
GetOffsetRect
(
rcFrame
)
;
return
rcFrame
.
Height
(
)
;
}
inline
bool
IsHTMLElement
(
)
const
{
return
true
;
}
inline
bool
IsHTMLElement
(
nsAtom
*
aTag
)
const
{
return
mNodeInfo
-
>
Equals
(
aTag
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
protected
:
virtual
~
nsGenericHTMLElement
(
)
{
}
public
:
MOZ_CAN_RUN_SCRIPT
nsSize
GetWidthHeightForImage
(
RefPtr
<
imgRequestProxy
>
&
aImageRequest
)
;
public
:
virtual
nsresult
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aDeep
=
true
bool
aNullParent
=
true
)
override
;
virtual
bool
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
override
{
bool
isFocusable
=
false
;
IsHTMLFocusable
(
aWithMouse
&
isFocusable
aTabIndex
)
;
return
isFocusable
;
}
virtual
bool
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
;
virtual
bool
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
override
;
bool
CheckHandleEventForAnchorsPreconditions
(
mozilla
:
:
EventChainVisitor
&
aVisitor
)
;
void
GetEventTargetParentForAnchors
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
;
nsresult
PostHandleEventForAnchors
(
mozilla
:
:
EventChainPostVisitor
&
aVisitor
)
;
bool
IsHTMLLink
(
nsIURI
*
*
aURI
)
const
;
void
Compact
(
)
{
mAttrsAndChildren
.
Compact
(
)
;
}
virtual
void
UpdateEditableState
(
bool
aNotify
)
override
;
virtual
mozilla
:
:
EventStates
IntrinsicState
(
)
const
override
;
void
DoSetEditableFlag
(
bool
aEditable
bool
aNotify
)
{
SetEditableFlag
(
aEditable
)
;
UpdateState
(
aNotify
)
;
}
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
bool
ParseBackgroundAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
;
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
override
;
virtual
nsMapRuleToAttributesFunc
GetAttributeMappingFunction
(
)
const
override
;
void
GetBaseTarget
(
nsAString
&
aBaseTarget
)
const
;
nsIFormControlFrame
*
GetFormControlFrame
(
bool
aFlushFrames
)
;
static
bool
ParseAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseDivAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseTableHAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseTableCellHAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseTableVAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseImageAttribute
(
nsAtom
*
aAttribute
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseReferrerAttribute
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseFrameborderValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
bool
ParseScrollingValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
;
static
void
MapCommonAttributesInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapCommonAttributesIntoExceptHidden
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
const
MappedAttributeEntry
sCommonAttributeMap
[
]
;
static
const
MappedAttributeEntry
sImageMarginSizeAttributeMap
[
]
;
static
const
MappedAttributeEntry
sImageBorderAttributeMap
[
]
;
static
const
MappedAttributeEntry
sImageAlignAttributeMap
[
]
;
static
const
MappedAttributeEntry
sDivAlignAttributeMap
[
]
;
static
const
MappedAttributeEntry
sBackgroundAttributeMap
[
]
;
static
const
MappedAttributeEntry
sBackgroundColorAttributeMap
[
]
;
static
void
MapImageAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapDivAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapVAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapImageBorderAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapImageMarginAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapImageSizeAttributesInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapWidthAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapHeightAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapBackgroundInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapBGColorInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapBackgroundAttributesInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
static
void
MapScrollingAttributeInto
(
const
nsMappedAttributes
*
aAttributes
mozilla
:
:
MappedDeclarations
&
)
;
enum
PresContextFor
{
eForComposedDoc
eForUncomposedDoc
}
;
nsPresContext
*
GetPresContext
(
PresContextFor
aFor
)
;
mozilla
:
:
dom
:
:
HTMLFormElement
*
FindAncestorForm
(
mozilla
:
:
dom
:
:
HTMLFormElement
*
aCurrentForm
=
nullptr
)
;
virtual
void
RecompileScriptEventListeners
(
)
override
;
static
bool
InNavQuirksMode
(
nsIDocument
*
aDoc
)
;
void
GetURIAttr
(
nsAtom
*
aAttr
nsAtom
*
aBaseAttr
nsAString
&
aResult
)
const
;
bool
GetURIAttr
(
nsAtom
*
aAttr
nsAtom
*
aBaseAttr
nsIURI
*
*
aURI
)
const
;
bool
IsDisabled
(
)
const
{
return
State
(
)
.
HasState
(
NS_EVENT_STATE_DISABLED
)
;
}
bool
IsHidden
(
)
const
{
return
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
)
;
}
virtual
bool
IsLabelable
(
)
const
override
;
static
bool
MatchLabelsElement
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
;
already_AddRefed
<
nsINodeList
>
Labels
(
)
;
virtual
bool
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
override
;
static
bool
TouchEventsEnabled
(
JSContext
*
JSObject
*
)
;
static
inline
bool
CanHaveName
(
nsAtom
*
aTag
)
{
return
aTag
=
=
nsGkAtoms
:
:
img
|
|
aTag
=
=
nsGkAtoms
:
:
form
|
|
aTag
=
=
nsGkAtoms
:
:
embed
|
|
aTag
=
=
nsGkAtoms
:
:
object
;
}
static
inline
bool
ShouldExposeNameAsHTMLDocumentProperty
(
Element
*
aElement
)
{
return
aElement
-
>
IsHTMLElement
(
)
&
&
CanHaveName
(
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
static
inline
bool
ShouldExposeIdAsHTMLDocumentProperty
(
Element
*
aElement
)
{
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
{
return
true
;
}
return
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
&
&
aElement
-
>
HasName
(
)
;
}
protected
:
void
AddToNameTable
(
nsAtom
*
aName
)
;
void
RemoveFromNameTable
(
)
;
void
RegAccessKey
(
)
{
if
(
HasFlag
(
NODE_HAS_ACCESSKEY
)
)
{
RegUnRegAccessKey
(
true
)
;
}
}
void
UnregAccessKey
(
)
{
if
(
HasFlag
(
NODE_HAS_ACCESSKEY
)
)
{
RegUnRegAccessKey
(
false
)
;
}
}
private
:
void
RegUnRegAccessKey
(
bool
aDoReg
)
;
protected
:
virtual
nsresult
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
override
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
override
;
nsresult
DispatchSimulatedClick
(
nsGenericHTMLElement
*
aElement
bool
aIsTrusted
nsPresContext
*
aPresContext
)
;
nsresult
NewURIFromString
(
const
nsAString
&
aURISpec
nsIURI
*
*
aURI
)
;
void
GetHTMLAttr
(
nsAtom
*
aName
nsAString
&
aResult
)
const
{
GetAttr
(
aName
aResult
)
;
}
void
GetHTMLAttr
(
nsAtom
*
aName
mozilla
:
:
dom
:
:
DOMString
&
aResult
)
const
{
GetAttr
(
kNameSpaceID_None
aName
aResult
)
;
}
void
GetHTMLEnumAttr
(
nsAtom
*
aName
nsAString
&
aResult
)
const
{
GetEnumAttr
(
aName
nullptr
aResult
)
;
}
void
GetHTMLURIAttr
(
nsAtom
*
aName
nsAString
&
aResult
)
const
{
GetURIAttr
(
aName
nullptr
aResult
)
;
}
void
SetHTMLAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
SetAttr
(
kNameSpaceID_None
aName
aValue
true
)
;
}
void
SetHTMLAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
SetAttr
(
aName
aValue
aError
)
;
}
void
SetHTMLAttr
(
nsAtom
*
aName
const
nsAString
&
aValue
nsIPrincipal
*
aTriggeringPrincipal
mozilla
:
:
ErrorResult
&
aError
)
{
SetAttr
(
aName
aValue
aTriggeringPrincipal
aError
)
;
}
void
UnsetHTMLAttr
(
nsAtom
*
aName
mozilla
:
:
ErrorResult
&
aError
)
{
UnsetAttr
(
aName
aError
)
;
}
void
SetHTMLBoolAttr
(
nsAtom
*
aName
bool
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
aValue
)
{
SetHTMLAttr
(
aName
EmptyString
(
)
aError
)
;
}
else
{
UnsetHTMLAttr
(
aName
aError
)
;
}
}
template
<
typename
T
>
void
SetHTMLIntAttr
(
nsAtom
*
aName
T
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
nsAutoString
value
;
value
.
AppendInt
(
aValue
)
;
SetHTMLAttr
(
aName
value
aError
)
;
}
int32_t
GetIntAttr
(
nsAtom
*
aAttr
int32_t
aDefault
)
const
;
nsresult
SetIntAttr
(
nsAtom
*
aAttr
int32_t
aValue
)
;
uint32_t
GetUnsignedIntAttr
(
nsAtom
*
aAttr
uint32_t
aDefault
)
const
;
void
SetUnsignedIntAttr
(
nsAtom
*
aName
uint32_t
aValue
uint32_t
aDefault
mozilla
:
:
ErrorResult
&
aError
)
{
nsAutoString
value
;
if
(
aValue
>
INT32_MAX
)
{
value
.
AppendInt
(
aDefault
)
;
}
else
{
value
.
AppendInt
(
aValue
)
;
}
SetHTMLAttr
(
aName
value
aError
)
;
}
void
SetDoubleAttr
(
nsAtom
*
aAttr
double
aValue
mozilla
:
:
ErrorResult
&
aRv
)
{
nsAutoString
value
;
value
.
AppendFloat
(
aValue
)
;
SetHTMLAttr
(
aAttr
value
aRv
)
;
}
virtual
already_AddRefed
<
mozilla
:
:
TextEditor
>
GetAssociatedEditor
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetOffsetRect
(
mozilla
:
:
CSSIntRect
&
aRect
)
;
static
void
SyncEditorsOnSubtree
(
nsIContent
*
content
)
;
enum
ContentEditableTristate
{
eInherit
=
-
1
eFalse
=
0
eTrue
=
1
}
;
ContentEditableTristate
GetContentEditableValue
(
)
const
{
static
const
Element
:
:
AttrValuesArray
values
[
]
=
{
&
nsGkAtoms
:
:
_false
&
nsGkAtoms
:
:
_true
&
nsGkAtoms
:
:
_empty
nullptr
}
;
if
(
!
MayHaveContentEditableAttr
(
)
)
return
eInherit
;
int32_t
value
=
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
contenteditable
values
eIgnoreCase
)
;
return
value
>
0
?
eTrue
:
(
value
=
=
0
?
eFalse
:
eInherit
)
;
}
already_AddRefed
<
nsIURI
>
GetHrefURIForAnchors
(
)
const
;
bool
IsEditableRoot
(
)
const
;
private
:
void
ChangeEditableState
(
int32_t
aChange
)
;
}
;
namespace
mozilla
{
namespace
dom
{
class
HTMLFieldSetElement
;
}
}
#
define
FORM_ELEMENT_FLAG_BIT
(
n_
)
NODE_FLAG_BIT
(
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
(
n_
)
)
enum
{
ADDED_TO_FORM
=
FORM_ELEMENT_FLAG_BIT
(
0
)
MAYBE_ORPHAN_FORM_ELEMENT
=
FORM_ELEMENT_FLAG_BIT
(
1
)
MAY_BE_IN_PAST_NAMES_MAP
=
FORM_ELEMENT_FLAG_BIT
(
2
)
}
;
ASSERT_NODE_FLAGS_SPACE
(
ELEMENT_TYPE_SPECIFIC_BITS_OFFSET
+
3
)
;
#
undef
FORM_ELEMENT_FLAG_BIT
class
nsGenericHTMLFormElement
:
public
nsGenericHTMLElement
public
nsIFormControl
{
public
:
nsGenericHTMLFormElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
uint8_t
aType
)
;
NS_DECL_ISUPPORTS_INHERITED
nsINode
*
GetScopeChainParent
(
)
const
override
;
virtual
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
override
;
virtual
void
SaveSubtreeState
(
)
override
;
virtual
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
GetFieldSet
(
)
override
;
virtual
mozilla
:
:
dom
:
:
Element
*
GetFormElement
(
)
override
;
mozilla
:
:
dom
:
:
HTMLFormElement
*
GetForm
(
)
const
{
return
mForm
;
}
virtual
void
SetForm
(
mozilla
:
:
dom
:
:
HTMLFormElement
*
aForm
)
override
;
virtual
void
ClearForm
(
bool
aRemoveFromForm
bool
aUnbindOrDelete
)
override
;
NS_IMETHOD
SaveState
(
)
override
{
return
NS_OK
;
}
virtual
bool
RestoreState
(
mozilla
:
:
PresState
*
aState
)
override
{
return
false
;
}
virtual
bool
AllowDrop
(
)
override
{
return
true
;
}
virtual
nsresult
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
override
;
virtual
void
UnbindFromTree
(
bool
aDeep
=
true
bool
aNullParent
=
true
)
override
;
virtual
IMEState
GetDesiredIMEState
(
)
override
;
virtual
mozilla
:
:
EventStates
IntrinsicState
(
)
const
override
;
void
GetEventTargetParent
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
override
;
virtual
nsresult
PreHandleEvent
(
mozilla
:
:
EventChainVisitor
&
aVisitor
)
override
;
virtual
void
FieldSetDisabledChanged
(
bool
aNotify
)
;
void
UpdateDisabledState
(
bool
aNotify
)
;
void
UpdateRequiredState
(
bool
aIsRequired
bool
aNotify
)
;
void
FieldSetFirstLegendChanged
(
bool
aNotify
)
{
UpdateFieldSet
(
aNotify
)
;
}
void
ForgetFieldSet
(
nsIContent
*
aFieldset
)
;
bool
CanBeDisabled
(
)
const
;
bool
DoesReadOnlyApply
(
)
const
;
virtual
bool
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
override
;
virtual
bool
IsLabelable
(
)
const
override
;
void
GetFormAction
(
nsString
&
aValue
)
;
protected
:
virtual
~
nsGenericHTMLFormElement
(
)
;
virtual
nsresult
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
override
;
virtual
nsresult
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
void
BeforeSetForm
(
bool
aBindToTree
)
{
}
virtual
void
AfterClearForm
(
bool
aUnbindOrDelete
)
{
}
void
SetForm
(
mozilla
:
:
dom
:
:
HTMLFormElement
*
aForm
bool
aBindToTree
)
;
void
UpdateFormOwner
(
bool
aBindToTree
Element
*
aFormIdElement
)
;
void
UpdateFieldSet
(
bool
aNotify
)
;
Element
*
AddFormIdObserver
(
)
;
void
RemoveFormIdObserver
(
)
;
static
bool
FormIdUpdated
(
Element
*
aOldElement
Element
*
aNewElement
void
*
aData
)
;
bool
IsElementDisabledForEvents
(
mozilla
:
:
EventMessage
aMessage
nsIFrame
*
aFrame
)
;
enum
FocusTristate
{
eUnfocusable
eInactiveWindow
eActiveWindow
}
;
FocusTristate
FocusState
(
)
;
mozilla
:
:
dom
:
:
HTMLFormElement
*
mForm
;
mozilla
:
:
dom
:
:
HTMLFieldSetElement
*
mFieldSet
;
}
;
class
nsGenericHTMLFormElementWithState
:
public
nsGenericHTMLFormElement
{
public
:
nsGenericHTMLFormElementWithState
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
uint8_t
aType
)
;
mozilla
:
:
PresState
*
GetPrimaryPresState
(
)
;
already_AddRefed
<
nsILayoutHistoryState
>
GetLayoutHistory
(
bool
aRead
)
;
bool
RestoreFormControlState
(
)
;
virtual
void
NodeInfoChanged
(
nsIDocument
*
aOldDoc
)
override
;
protected
:
nsresult
GenerateStateKey
(
)
;
nsCString
mStateKey
;
}
;
#
define
NS_INTERFACE_MAP_ENTRY_IF_TAG
(
_interface
_tag
)
\
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
_interface
\
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
_tag
)
)
namespace
mozilla
{
namespace
dom
{
typedef
nsGenericHTMLElement
*
(
*
HTMLContentCreatorFunction
)
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
;
}
}
#
define
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
_elementName
)
\
namespace
mozilla
{
\
namespace
dom
{
\
class
HTML
#
#
_elementName
#
#
Element
;
\
}
\
}
\
nsGenericHTMLElement
*
\
NS_NewHTML
#
#
_elementName
#
#
Element
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
#
define
NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED
(
_elementName
)
\
inline
nsGenericHTMLElement
*
\
NS_NewHTML
#
#
_elementName
#
#
Element
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
\
{
\
return
NS_NewHTMLSharedElement
(
std
:
:
move
(
aNodeInfo
)
aFromParser
)
;
\
}
#
define
NS_IMPL_NS_NEW_HTML_ELEMENT
(
_elementName
)
\
nsGenericHTMLElement
*
\
NS_NewHTML
#
#
_elementName
#
#
Element
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
\
{
\
return
new
mozilla
:
:
dom
:
:
HTML
#
#
_elementName
#
#
Element
(
aNodeInfo
)
;
\
}
#
define
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
_elementName
)
\
nsGenericHTMLElement
*
\
NS_NewHTML
#
#
_elementName
#
#
Element
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
\
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
\
{
\
return
new
mozilla
:
:
dom
:
:
HTML
#
#
_elementName
#
#
Element
(
aNodeInfo
\
aFromParser
)
;
\
}
nsGenericHTMLElement
*
NS_NewHTMLElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
nsGenericHTMLElement
*
NS_NewCustomElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Shared
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
SharedList
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Anchor
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Area
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Audio
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
BR
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Body
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Button
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Canvas
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Content
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Mod
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Data
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
DataList
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Details
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Dialog
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Div
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Embed
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
FieldSet
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Font
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Form
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Frame
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
FrameSet
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
HR
)
NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED
(
Head
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Heading
)
NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED
(
Html
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
IFrame
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Image
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Input
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
LI
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Label
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Legend
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Link
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Map
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Menu
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
MenuItem
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Meta
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Meter
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Object
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
OptGroup
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Option
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Output
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Paragraph
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Picture
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Pre
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Progress
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Script
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Select
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Slot
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Source
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Span
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Style
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Summary
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableCaption
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableCell
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableCol
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Table
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableRow
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TableSection
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Tbody
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Template
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
TextArea
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Tfoot
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Thead
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Time
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Title
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Track
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Unknown
)
NS_DECLARE_NS_NEW_HTML_ELEMENT
(
Video
)
#
endif
