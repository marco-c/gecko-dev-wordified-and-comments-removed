#
include
"
mozilla
/
dom
/
HTMLAllCollection
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAllCollectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsHTMLDocument
.
h
"
namespace
mozilla
{
namespace
dom
{
HTMLAllCollection
:
:
HTMLAllCollection
(
nsHTMLDocument
*
aDocument
)
:
mDocument
(
aDocument
)
{
MOZ_ASSERT
(
mDocument
)
;
}
HTMLAllCollection
:
:
~
HTMLAllCollection
(
)
{
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
HTMLAllCollection
mDocument
mCollection
mNamedMap
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
HTMLAllCollection
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
HTMLAllCollection
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLAllCollection
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
nsINode
*
HTMLAllCollection
:
:
GetParentObject
(
)
const
{
return
mDocument
;
}
uint32_t
HTMLAllCollection
:
:
Length
(
)
{
return
Collection
(
)
-
>
Length
(
true
)
;
}
nsIContent
*
HTMLAllCollection
:
:
Item
(
uint32_t
aIndex
)
{
return
Collection
(
)
-
>
Item
(
aIndex
)
;
}
nsContentList
*
HTMLAllCollection
:
:
Collection
(
)
{
if
(
!
mCollection
)
{
nsIDocument
*
document
=
mDocument
;
mCollection
=
document
-
>
GetElementsByTagName
(
NS_LITERAL_STRING
(
"
*
"
)
)
;
MOZ_ASSERT
(
mCollection
)
;
}
return
mCollection
;
}
static
bool
IsAllNamedElement
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
button
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
form
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
img
nsGkAtoms
:
:
input
nsGkAtoms
:
:
map
nsGkAtoms
:
:
meta
nsGkAtoms
:
:
object
nsGkAtoms
:
:
select
nsGkAtoms
:
:
textarea
nsGkAtoms
:
:
frame
nsGkAtoms
:
:
frameset
)
;
}
static
bool
DocAllResultMatch
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
if
(
aElement
-
>
GetID
(
)
=
=
aAtom
)
{
return
true
;
}
nsGenericHTMLElement
*
elm
=
nsGenericHTMLElement
:
:
FromContent
(
aElement
)
;
if
(
!
elm
)
{
return
false
;
}
if
(
!
IsAllNamedElement
(
elm
)
)
{
return
false
;
}
const
nsAttrValue
*
val
=
elm
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
;
return
val
&
&
val
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
&
&
val
-
>
GetAtomValue
(
)
=
=
aAtom
;
}
nsContentList
*
HTMLAllCollection
:
:
GetDocumentAllList
(
const
nsAString
&
aID
)
{
return
mNamedMap
.
LookupForAdd
(
aID
)
.
OrInsert
(
[
this
&
aID
]
(
)
{
RefPtr
<
nsAtom
>
id
=
NS_Atomize
(
aID
)
;
return
new
nsContentList
(
mDocument
DocAllResultMatch
nullptr
nullptr
true
id
)
;
}
)
;
}
void
HTMLAllCollection
:
:
NamedGetter
(
const
nsAString
&
aID
bool
&
aFound
Nullable
<
OwningNodeOrHTMLCollection
>
&
aResult
)
{
if
(
aID
.
IsEmpty
(
)
)
{
aFound
=
false
;
aResult
.
SetNull
(
)
;
return
;
}
nsContentList
*
docAllList
=
GetDocumentAllList
(
aID
)
;
if
(
!
docAllList
)
{
aFound
=
false
;
aResult
.
SetNull
(
)
;
return
;
}
if
(
docAllList
-
>
Item
(
1
true
)
)
{
aFound
=
true
;
aResult
.
SetValue
(
)
.
SetAsHTMLCollection
(
)
=
docAllList
;
return
;
}
if
(
nsIContent
*
node
=
docAllList
-
>
Item
(
0
true
)
)
{
aFound
=
true
;
aResult
.
SetValue
(
)
.
SetAsNode
(
)
=
node
;
return
;
}
aFound
=
false
;
aResult
.
SetNull
(
)
;
}
void
HTMLAllCollection
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
{
AutoTArray
<
nsAtom
*
8
>
atoms
;
for
(
uint32_t
i
=
0
;
i
<
Length
(
)
;
+
+
i
)
{
nsIContent
*
content
=
Item
(
i
)
;
if
(
content
-
>
HasID
(
)
)
{
nsAtom
*
id
=
content
-
>
GetID
(
)
;
MOZ_ASSERT
(
id
!
=
nsGkAtoms
:
:
_empty
"
Empty
ids
don
'
t
get
atomized
"
)
;
if
(
!
atoms
.
Contains
(
id
)
)
{
atoms
.
AppendElement
(
id
)
;
}
}
nsGenericHTMLElement
*
el
=
nsGenericHTMLElement
:
:
FromContent
(
content
)
;
if
(
el
)
{
const
nsAttrValue
*
val
=
el
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
;
if
(
val
&
&
val
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
&
&
IsAllNamedElement
(
content
)
)
{
nsAtom
*
name
=
val
-
>
GetAtomValue
(
)
;
MOZ_ASSERT
(
name
!
=
nsGkAtoms
:
:
_empty
"
Empty
names
don
'
t
get
atomized
"
)
;
if
(
!
atoms
.
Contains
(
name
)
)
{
atoms
.
AppendElement
(
name
)
;
}
}
}
}
uint32_t
atomsLen
=
atoms
.
Length
(
)
;
nsString
*
names
=
aNames
.
AppendElements
(
atomsLen
)
;
for
(
uint32_t
i
=
0
;
i
<
atomsLen
;
+
+
i
)
{
atoms
[
i
]
-
>
ToString
(
names
[
i
]
)
;
}
}
JSObject
*
HTMLAllCollection
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLAllCollectionBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
