#
include
"
SingleLineTextInputTypes
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
HTMLSplitOnSpacesTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
bool
SingleLineTextInputTypeBase
:
:
IsMutable
(
)
const
{
return
!
mInputElement
-
>
IsDisabled
(
)
&
&
!
mInputElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
;
}
bool
SingleLineTextInputTypeBase
:
:
IsTooLong
(
)
const
{
int32_t
maxLength
=
mInputElement
-
>
MaxLength
(
)
;
if
(
maxLength
=
=
-
1
)
{
return
false
;
}
int32_t
textLength
=
mInputElement
-
>
InputTextLength
(
mozilla
:
:
dom
:
:
CallerType
:
:
System
)
;
return
textLength
>
maxLength
;
}
bool
SingleLineTextInputTypeBase
:
:
IsTooShort
(
)
const
{
int32_t
minLength
=
mInputElement
-
>
MinLength
(
)
;
if
(
minLength
=
=
-
1
)
{
return
false
;
}
int32_t
textLength
=
mInputElement
-
>
InputTextLength
(
mozilla
:
:
dom
:
:
CallerType
:
:
System
)
;
return
textLength
&
&
textLength
<
minLength
;
}
bool
SingleLineTextInputTypeBase
:
:
IsValueMissing
(
)
const
{
if
(
!
mInputElement
-
>
IsRequired
(
)
)
{
return
false
;
}
if
(
!
IsMutable
(
)
)
{
return
false
;
}
return
IsValueEmpty
(
)
;
}
Maybe
<
bool
>
SingleLineTextInputTypeBase
:
:
HasPatternMismatch
(
)
const
{
if
(
!
mInputElement
-
>
HasPatternAttribute
(
)
)
{
return
Some
(
false
)
;
}
nsAutoString
pattern
;
if
(
!
mInputElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
pattern
pattern
)
)
{
return
Some
(
false
)
;
}
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
return
Some
(
false
)
;
}
Document
*
doc
=
mInputElement
-
>
OwnerDoc
(
)
;
Maybe
<
bool
>
result
=
nsContentUtils
:
:
IsPatternMatching
(
value
pattern
doc
)
;
return
result
?
Some
(
!
*
result
)
:
Nothing
(
)
;
}
bool
URLInputType
:
:
HasTypeMismatch
(
)
const
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIIOService
>
ioService
=
do_GetIOService
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
return
!
NS_SUCCEEDED
(
ioService
-
>
NewURI
(
NS_ConvertUTF16toUTF8
(
value
)
nullptr
nullptr
getter_AddRefs
(
uri
)
)
)
;
}
nsresult
URLInputType
:
:
GetTypeMismatchMessage
(
nsAString
&
aMessage
)
{
return
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationInvalidURL
"
aMessage
)
;
}
bool
EmailInputType
:
:
HasTypeMismatch
(
)
const
{
nsAutoString
value
;
GetNonFileValueInternal
(
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
return
false
;
}
return
mInputElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
multiple
)
?
!
IsValidEmailAddressList
(
value
)
:
!
IsValidEmailAddress
(
value
)
;
}
bool
EmailInputType
:
:
HasBadInput
(
)
const
{
nsAutoString
value
;
nsAutoCString
unused
;
uint32_t
unused2
;
GetNonFileValueInternal
(
value
)
;
HTMLSplitOnSpacesTokenizer
tokenizer
(
value
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
if
(
!
PunycodeEncodeEmailAddress
(
tokenizer
.
nextToken
(
)
unused
&
unused2
)
)
{
return
true
;
}
}
return
false
;
}
nsresult
EmailInputType
:
:
GetTypeMismatchMessage
(
nsAString
&
aMessage
)
{
return
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationInvalidEmail
"
aMessage
)
;
}
nsresult
EmailInputType
:
:
GetBadInputMessage
(
nsAString
&
aMessage
)
{
return
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationInvalidEmail
"
aMessage
)
;
}
bool
EmailInputType
:
:
IsValidEmailAddressList
(
const
nsAString
&
aValue
)
{
HTMLSplitOnSpacesTokenizer
tokenizer
(
aValue
'
'
)
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
if
(
!
IsValidEmailAddress
(
tokenizer
.
nextToken
(
)
)
)
{
return
false
;
}
}
return
!
tokenizer
.
separatorAfterCurrentToken
(
)
;
}
bool
EmailInputType
:
:
IsValidEmailAddress
(
const
nsAString
&
aValue
)
{
if
(
aValue
.
IsEmpty
(
)
|
|
aValue
.
Last
(
)
=
=
'
.
'
|
|
aValue
.
Last
(
)
=
=
'
-
'
)
{
return
false
;
}
uint32_t
atPos
;
nsAutoCString
value
;
if
(
!
PunycodeEncodeEmailAddress
(
aValue
value
&
atPos
)
|
|
atPos
=
=
(
uint32_t
)
kNotFound
|
|
atPos
=
=
0
|
|
atPos
=
=
value
.
Length
(
)
-
1
)
{
return
false
;
}
uint32_t
length
=
value
.
Length
(
)
;
uint32_t
i
=
0
;
for
(
;
i
<
atPos
;
+
+
i
)
{
char16_t
c
=
value
[
i
]
;
if
(
!
(
IsAsciiAlpha
(
c
)
|
|
IsAsciiDigit
(
c
)
|
|
c
=
=
'
.
'
|
|
c
=
=
'
!
'
|
|
c
=
=
'
#
'
|
|
c
=
=
'
'
|
|
c
=
=
'
%
'
|
|
c
=
=
'
&
'
|
|
c
=
=
'
\
'
'
|
|
c
=
=
'
*
'
|
|
c
=
=
'
+
'
|
|
c
=
=
'
-
'
|
|
c
=
=
'
/
'
|
|
c
=
=
'
=
'
|
|
c
=
=
'
?
'
|
|
c
=
=
'
^
'
|
|
c
=
=
'
_
'
|
|
c
=
=
'
'
|
|
c
=
=
'
{
'
|
|
c
=
=
'
|
'
|
|
c
=
=
'
}
'
|
|
c
=
=
'
~
'
)
)
{
return
false
;
}
}
+
+
i
;
if
(
value
[
i
]
=
=
'
.
'
|
|
value
[
i
]
=
=
'
-
'
)
{
return
false
;
}
for
(
;
i
<
length
;
+
+
i
)
{
char16_t
c
=
value
[
i
]
;
if
(
c
=
=
'
.
'
)
{
if
(
value
[
i
-
1
]
=
=
'
.
'
|
|
value
[
i
-
1
]
=
=
'
-
'
)
{
return
false
;
}
}
else
if
(
c
=
=
'
-
'
)
{
if
(
value
[
i
-
1
]
=
=
'
.
'
)
{
return
false
;
}
}
else
if
(
!
(
IsAsciiAlpha
(
c
)
|
|
IsAsciiDigit
(
c
)
|
|
c
=
=
'
-
'
)
)
{
return
false
;
}
}
return
true
;
}
bool
EmailInputType
:
:
PunycodeEncodeEmailAddress
(
const
nsAString
&
aEmail
nsAutoCString
&
aEncodedEmail
uint32_t
*
aIndexOfAt
)
{
nsAutoCString
value
=
NS_ConvertUTF16toUTF8
(
aEmail
)
;
*
aIndexOfAt
=
(
uint32_t
)
value
.
FindChar
(
'
'
)
;
if
(
*
aIndexOfAt
=
=
(
uint32_t
)
kNotFound
|
|
*
aIndexOfAt
=
=
value
.
Length
(
)
-
1
)
{
aEncodedEmail
=
value
;
return
true
;
}
nsCOMPtr
<
nsIIDNService
>
idnSrv
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
)
;
if
(
!
idnSrv
)
{
NS_ERROR
(
"
nsIIDNService
isn
'
t
present
!
"
)
;
return
false
;
}
uint32_t
indexOfDomain
=
*
aIndexOfAt
+
1
;
const
nsDependentCSubstring
domain
=
Substring
(
value
indexOfDomain
)
;
bool
ace
;
if
(
NS_SUCCEEDED
(
idnSrv
-
>
IsACE
(
domain
&
ace
)
)
&
&
!
ace
)
{
nsAutoCString
domainACE
;
if
(
NS_FAILED
(
idnSrv
-
>
ConvertUTF8toACE
(
domain
domainACE
)
)
)
{
return
false
;
}
value
.
Replace
(
indexOfDomain
domain
.
Length
(
)
domainACE
)
;
}
aEncodedEmail
=
value
;
return
true
;
}
