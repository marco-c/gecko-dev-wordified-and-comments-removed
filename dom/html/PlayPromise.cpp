#
include
"
mozilla
/
dom
/
PlayPromise
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
extern
mozilla
:
:
LazyLogModule
gMediaElementLog
;
#
define
PLAY_PROMISE_LOG
(
msg
.
.
.
)
\
MOZ_LOG
(
gMediaElementLog
LogLevel
:
:
Debug
(
msg
#
#
__VA_ARGS__
)
)
namespace
mozilla
{
namespace
dom
{
PlayPromise
:
:
PlayPromise
(
nsIGlobalObject
*
aGlobal
)
:
Promise
(
aGlobal
)
{
}
PlayPromise
:
:
~
PlayPromise
(
)
{
if
(
!
mFulfilled
&
&
PromiseObj
(
)
)
{
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
}
already_AddRefed
<
PlayPromise
>
PlayPromise
:
:
Create
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
{
RefPtr
<
PlayPromise
>
promise
=
new
PlayPromise
(
aGlobal
)
;
promise
-
>
CreateWrapper
(
aRv
)
;
return
aRv
.
Failed
(
)
?
nullptr
:
promise
.
forget
(
)
;
}
void
PlayPromise
:
:
MaybeResolveWithUndefined
(
)
{
if
(
mFulfilled
)
{
return
;
}
mFulfilled
=
true
;
PLAY_PROMISE_LOG
(
"
PlayPromise
%
p
resolved
with
undefined
"
this
)
;
Promise
:
:
MaybeResolveWithUndefined
(
)
;
}
static
const
char
*
ToPlayResultStr
(
nsresult
aReason
)
{
switch
(
aReason
)
{
case
NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR
:
return
"
NotAllowedErr
"
;
case
NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR
:
return
"
SrcNotSupportedErr
"
;
case
NS_ERROR_DOM_MEDIA_ABORT_ERR
:
return
"
PauseAbortErr
"
;
case
NS_ERROR_DOM_ABORT_ERR
:
return
"
AbortErr
"
;
default
:
return
"
UnknownErr
"
;
}
}
void
PlayPromise
:
:
MaybeReject
(
nsresult
aReason
)
{
if
(
mFulfilled
)
{
return
;
}
mFulfilled
=
true
;
PLAY_PROMISE_LOG
(
"
PlayPromise
%
p
rejected
with
0x
%
x
(
%
s
)
"
this
static_cast
<
uint32_t
>
(
aReason
)
ToPlayResultStr
(
aReason
)
)
;
Promise
:
:
MaybeReject
(
aReason
)
;
}
}
}
