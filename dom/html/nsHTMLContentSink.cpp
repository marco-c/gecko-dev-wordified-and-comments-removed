#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
nsContentSink
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIHTMLContentSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
prtime
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsDocElementCreatedNotificationRunner
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsStubDocumentObserver
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsTextNode
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsGenericHTMLElement
*
NS_NewHTMLNOTUSEDElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
{
MOZ_ASSERT_UNREACHABLE
(
"
The
element
ctor
should
never
be
called
"
)
;
return
nullptr
;
}
#
define
HTML_TAG
(
_tag
_classname
_interfacename
)
\
NS_NewHTML
#
#
_classname
#
#
Element
#
define
HTML_OTHER
(
_tag
)
NS_NewHTMLNOTUSEDElement
static
const
HTMLContentCreatorFunction
sHTMLContentCreatorFunctions
[
]
=
{
NS_NewHTMLUnknownElement
#
include
"
nsHTMLTagList
.
h
"
#
undef
HTML_TAG
#
undef
HTML_OTHER
NS_NewHTMLUnknownElement
}
;
class
SinkContext
;
class
HTMLContentSink
;
class
HTMLContentSink
:
public
nsContentSink
public
nsIHTMLContentSink
{
public
:
friend
class
SinkContext
;
HTMLContentSink
(
)
;
nsresult
Init
(
Document
*
aDoc
nsIURI
*
aURI
nsISupports
*
aContainer
nsIChannel
*
aChannel
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLContentSink
nsContentSink
)
NS_IMETHOD
WillParse
(
void
)
override
;
NS_IMETHOD
WillBuildModel
(
nsDTDMode
aDTDMode
)
override
;
NS_IMETHOD
DidBuildModel
(
bool
aTerminated
)
override
;
NS_IMETHOD
WillInterrupt
(
void
)
override
;
void
WillResume
(
)
override
;
NS_IMETHOD
SetParser
(
nsParserBase
*
aParser
)
override
;
virtual
void
FlushPendingNotifications
(
FlushType
aType
)
override
;
virtual
void
SetDocumentCharset
(
NotNull
<
const
Encoding
*
>
aEncoding
)
override
;
virtual
nsISupports
*
GetTarget
(
)
override
;
virtual
bool
IsScriptExecuting
(
)
override
;
virtual
void
ContinueInterruptedParsingAsync
(
)
override
;
NS_IMETHOD
OpenContainer
(
ElementType
aNodeType
)
override
;
NS_IMETHOD
CloseContainer
(
ElementType
aTag
)
override
;
protected
:
virtual
~
HTMLContentSink
(
)
;
RefPtr
<
nsHTMLDocument
>
mHTMLDocument
;
int32_t
mMaxTextRun
;
RefPtr
<
nsGenericHTMLElement
>
mRoot
;
RefPtr
<
nsGenericHTMLElement
>
mBody
;
RefPtr
<
nsGenericHTMLElement
>
mHead
;
AutoTArray
<
SinkContext
*
8
>
mContextStack
;
SinkContext
*
mCurrentContext
;
SinkContext
*
mHeadContext
;
bool
mHaveSeenHead
;
bool
mNotifiedRootInsertion
;
nsresult
FlushTags
(
)
override
;
nsresult
CloseHTML
(
)
;
nsresult
OpenBody
(
)
;
nsresult
CloseBody
(
)
;
void
CloseHeadContext
(
)
;
void
UpdateChildCounts
(
)
override
;
void
NotifyInsert
(
nsIContent
*
aContent
nsIContent
*
aChildContent
)
;
void
NotifyRootInsertion
(
)
;
private
:
void
ContinueInterruptedParsingIfEnabled
(
)
;
}
;
class
SinkContext
{
public
:
explicit
SinkContext
(
HTMLContentSink
*
aSink
)
;
~
SinkContext
(
)
;
nsresult
Begin
(
nsHTMLTag
aNodeType
nsGenericHTMLElement
*
aRoot
uint32_t
aNumFlushed
int32_t
aInsertionPoint
)
;
nsresult
OpenBody
(
)
;
nsresult
CloseBody
(
)
;
nsresult
End
(
)
;
nsresult
GrowStack
(
)
;
nsresult
FlushTags
(
)
;
bool
IsCurrentContainer
(
nsHTMLTag
aTag
)
const
;
void
DidAddContent
(
nsIContent
*
aContent
)
;
void
UpdateChildCounts
(
)
;
private
:
bool
HaveNotifiedForCurrentContent
(
)
const
;
public
:
HTMLContentSink
*
mSink
;
int32_t
mNotifyLevel
;
struct
Node
{
nsHTMLTag
mType
;
nsGenericHTMLElement
*
mContent
;
uint32_t
mNumFlushed
;
int32_t
mInsertionPoint
;
nsIContent
*
Add
(
nsIContent
*
child
)
;
}
;
Node
*
mStack
;
int32_t
mStackSize
;
int32_t
mStackPos
;
}
;
nsresult
NS_NewHTMLElement
(
Element
*
*
aResult
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
nsAtom
*
aIsAtom
mozilla
:
:
dom
:
:
CustomElementDefinition
*
aDefinition
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
aNodeInfo
;
NS_ASSERTION
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
"
Trying
to
create
HTML
elements
that
don
'
t
have
the
XHTML
namespace
"
)
;
return
nsContentUtils
:
:
NewXULOrHTMLElement
(
aResult
nodeInfo
aFromParser
aIsAtom
aDefinition
)
;
}
already_AddRefed
<
nsGenericHTMLElement
>
CreateHTMLElement
(
uint32_t
aNodeType
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
{
NS_ASSERTION
(
aNodeType
<
=
NS_HTML_TAG_MAX
|
|
aNodeType
=
=
eHTMLTag_userdefined
"
aNodeType
is
out
of
bounds
"
)
;
HTMLContentCreatorFunction
cb
=
sHTMLContentCreatorFunctions
[
aNodeType
]
;
NS_ASSERTION
(
cb
!
=
NS_NewHTMLNOTUSEDElement
"
Don
'
t
know
how
to
construct
tag
element
!
"
)
;
RefPtr
<
nsGenericHTMLElement
>
result
=
cb
(
std
:
:
move
(
aNodeInfo
)
aFromParser
)
;
return
result
.
forget
(
)
;
}
SinkContext
:
:
SinkContext
(
HTMLContentSink
*
aSink
)
:
mSink
(
aSink
)
mNotifyLevel
(
0
)
mStack
(
nullptr
)
mStackSize
(
0
)
mStackPos
(
0
)
{
MOZ_COUNT_CTOR
(
SinkContext
)
;
}
SinkContext
:
:
~
SinkContext
(
)
{
MOZ_COUNT_DTOR
(
SinkContext
)
;
if
(
mStack
)
{
for
(
int32_t
i
=
0
;
i
<
mStackPos
;
i
+
+
)
{
NS_RELEASE
(
mStack
[
i
]
.
mContent
)
;
}
delete
[
]
mStack
;
}
}
nsresult
SinkContext
:
:
Begin
(
nsHTMLTag
aNodeType
nsGenericHTMLElement
*
aRoot
uint32_t
aNumFlushed
int32_t
aInsertionPoint
)
{
if
(
mStackSize
<
1
)
{
nsresult
rv
=
GrowStack
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
mStack
[
0
]
.
mType
=
aNodeType
;
mStack
[
0
]
.
mContent
=
aRoot
;
mStack
[
0
]
.
mNumFlushed
=
aNumFlushed
;
mStack
[
0
]
.
mInsertionPoint
=
aInsertionPoint
;
NS_ADDREF
(
aRoot
)
;
mStackPos
=
1
;
return
NS_OK
;
}
bool
SinkContext
:
:
IsCurrentContainer
(
nsHTMLTag
aTag
)
const
{
return
aTag
=
=
mStack
[
mStackPos
-
1
]
.
mType
;
}
void
SinkContext
:
:
DidAddContent
(
nsIContent
*
aContent
)
{
if
(
(
mStackPos
=
=
2
)
&
&
(
mSink
-
>
mBody
=
=
mStack
[
1
]
.
mContent
)
)
{
mNotifyLevel
=
0
;
}
if
(
0
<
mStackPos
&
&
mStack
[
mStackPos
-
1
]
.
mInsertionPoint
!
=
-
1
&
&
mStack
[
mStackPos
-
1
]
.
mNumFlushed
<
mStack
[
mStackPos
-
1
]
.
mContent
-
>
GetChildCount
(
)
)
{
nsIContent
*
parent
=
mStack
[
mStackPos
-
1
]
.
mContent
;
mSink
-
>
NotifyInsert
(
parent
aContent
)
;
mStack
[
mStackPos
-
1
]
.
mNumFlushed
=
parent
-
>
GetChildCount
(
)
;
}
else
if
(
mSink
-
>
IsTimeToNotify
(
)
)
{
FlushTags
(
)
;
}
}
nsresult
SinkContext
:
:
OpenBody
(
)
{
if
(
mStackPos
<
=
0
)
{
NS_ERROR
(
"
container
w
/
o
parent
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
if
(
mStackPos
+
1
>
mStackSize
)
{
rv
=
GrowStack
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
mSink
-
>
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
body
nullptr
kNameSpaceID_XHTML
nsINode
:
:
ELEMENT_NODE
)
;
NS_ENSURE_TRUE
(
nodeInfo
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
nsGenericHTMLElement
>
body
=
NS_NewHTMLBodyElement
(
nodeInfo
.
forget
(
)
FROM_PARSER_NETWORK
)
;
if
(
!
body
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mStack
[
mStackPos
]
.
mType
=
eHTMLTag_body
;
body
.
forget
(
&
mStack
[
mStackPos
]
.
mContent
)
;
mStack
[
mStackPos
]
.
mNumFlushed
=
0
;
mStack
[
mStackPos
]
.
mInsertionPoint
=
-
1
;
+
+
mStackPos
;
mStack
[
mStackPos
-
2
]
.
Add
(
mStack
[
mStackPos
-
1
]
.
mContent
)
;
return
NS_OK
;
}
bool
SinkContext
:
:
HaveNotifiedForCurrentContent
(
)
const
{
if
(
0
<
mStackPos
)
{
nsIContent
*
parent
=
mStack
[
mStackPos
-
1
]
.
mContent
;
return
mStack
[
mStackPos
-
1
]
.
mNumFlushed
=
=
parent
-
>
GetChildCount
(
)
;
}
return
true
;
}
nsIContent
*
SinkContext
:
:
Node
:
:
Add
(
nsIContent
*
child
)
{
NS_ASSERTION
(
mContent
"
No
parent
to
insert
/
append
into
!
"
)
;
if
(
mInsertionPoint
!
=
-
1
)
{
NS_ASSERTION
(
mNumFlushed
=
=
mContent
-
>
GetChildCount
(
)
"
Inserting
multiple
children
without
flushing
.
"
)
;
nsCOMPtr
<
nsIContent
>
nodeToInsertBefore
=
mContent
-
>
GetChildAt_Deprecated
(
mInsertionPoint
+
+
)
;
mContent
-
>
InsertChildBefore
(
child
nodeToInsertBefore
false
IgnoreErrors
(
)
)
;
}
else
{
mContent
-
>
AppendChildTo
(
child
false
IgnoreErrors
(
)
)
;
}
return
child
;
}
nsresult
SinkContext
:
:
CloseBody
(
)
{
NS_ASSERTION
(
mStackPos
>
0
"
stack
out
of
bounds
.
wrong
context
probably
!
"
)
;
if
(
mStackPos
<
=
0
)
{
return
NS_OK
;
}
-
-
mStackPos
;
NS_ASSERTION
(
mStack
[
mStackPos
]
.
mType
=
=
eHTMLTag_body
"
Tag
mismatch
.
Closing
tag
on
wrong
context
or
something
?
"
)
;
nsGenericHTMLElement
*
content
=
mStack
[
mStackPos
]
.
mContent
;
content
-
>
Compact
(
)
;
if
(
mNotifyLevel
>
=
mStackPos
)
{
if
(
mStack
[
mStackPos
]
.
mNumFlushed
<
content
-
>
GetChildCount
(
)
)
{
mSink
-
>
NotifyAppend
(
content
mStack
[
mStackPos
]
.
mNumFlushed
)
;
mStack
[
mStackPos
]
.
mNumFlushed
=
content
-
>
GetChildCount
(
)
;
}
mNotifyLevel
=
mStackPos
-
1
;
}
DidAddContent
(
content
)
;
NS_IF_RELEASE
(
content
)
;
return
NS_OK
;
}
nsresult
SinkContext
:
:
End
(
)
{
for
(
int32_t
i
=
0
;
i
<
mStackPos
;
i
+
+
)
{
NS_RELEASE
(
mStack
[
i
]
.
mContent
)
;
}
mStackPos
=
0
;
return
NS_OK
;
}
nsresult
SinkContext
:
:
GrowStack
(
)
{
int32_t
newSize
=
mStackSize
*
2
;
if
(
newSize
=
=
0
)
{
newSize
=
32
;
}
Node
*
stack
=
new
Node
[
newSize
]
;
if
(
mStackPos
!
=
0
)
{
memcpy
(
stack
mStack
sizeof
(
Node
)
*
mStackPos
)
;
delete
[
]
mStack
;
}
mStack
=
stack
;
mStackSize
=
newSize
;
return
NS_OK
;
}
nsresult
SinkContext
:
:
FlushTags
(
)
{
mSink
-
>
mDeferredFlushTags
=
false
;
uint32_t
oldUpdates
=
mSink
-
>
mUpdatesInNotification
;
+
+
(
mSink
-
>
mInNotification
)
;
mSink
-
>
mUpdatesInNotification
=
0
;
{
mozAutoDocUpdate
updateBatch
(
mSink
-
>
mDocument
true
)
;
int32_t
stackPos
=
0
;
bool
flushed
=
false
;
uint32_t
childCount
;
nsGenericHTMLElement
*
content
;
while
(
stackPos
<
mStackPos
)
{
content
=
mStack
[
stackPos
]
.
mContent
;
childCount
=
content
-
>
GetChildCount
(
)
;
if
(
!
flushed
&
&
(
mStack
[
stackPos
]
.
mNumFlushed
<
childCount
)
)
{
if
(
mStack
[
stackPos
]
.
mInsertionPoint
!
=
-
1
)
{
int32_t
childIndex
=
mStack
[
stackPos
]
.
mInsertionPoint
-
1
;
nsIContent
*
child
=
content
-
>
GetChildAt_Deprecated
(
childIndex
)
;
NS_ASSERTION
(
!
(
mStackPos
>
(
stackPos
+
1
)
)
|
|
(
child
=
=
mStack
[
stackPos
+
1
]
.
mContent
)
"
Flushing
the
wrong
child
.
"
)
;
mSink
-
>
NotifyInsert
(
content
child
)
;
}
else
{
mSink
-
>
NotifyAppend
(
content
mStack
[
stackPos
]
.
mNumFlushed
)
;
}
flushed
=
true
;
}
mStack
[
stackPos
]
.
mNumFlushed
=
childCount
;
stackPos
+
+
;
}
mNotifyLevel
=
mStackPos
-
1
;
}
-
-
(
mSink
-
>
mInNotification
)
;
if
(
mSink
-
>
mUpdatesInNotification
>
1
)
{
UpdateChildCounts
(
)
;
}
mSink
-
>
mUpdatesInNotification
=
oldUpdates
;
return
NS_OK
;
}
void
SinkContext
:
:
UpdateChildCounts
(
)
{
int32_t
stackPos
=
mStackPos
-
1
;
while
(
stackPos
>
=
0
)
{
Node
&
node
=
mStack
[
stackPos
]
;
node
.
mNumFlushed
=
node
.
mContent
-
>
GetChildCount
(
)
;
stackPos
-
-
;
}
mNotifyLevel
=
mStackPos
-
1
;
}
nsresult
NS_NewHTMLContentSink
(
nsIHTMLContentSink
*
*
aResult
Document
*
aDoc
nsIURI
*
aURI
nsISupports
*
aContainer
nsIChannel
*
aChannel
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
RefPtr
<
HTMLContentSink
>
it
=
new
HTMLContentSink
(
)
;
nsresult
rv
=
it
-
>
Init
(
aDoc
aURI
aContainer
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aResult
=
it
;
NS_ADDREF
(
*
aResult
)
;
return
NS_OK
;
}
HTMLContentSink
:
:
HTMLContentSink
(
)
:
mMaxTextRun
(
0
)
mCurrentContext
(
nullptr
)
mHeadContext
(
nullptr
)
mHaveSeenHead
(
false
)
mNotifiedRootInsertion
(
false
)
{
}
HTMLContentSink
:
:
~
HTMLContentSink
(
)
{
if
(
mNotificationTimer
)
{
mNotificationTimer
-
>
Cancel
(
)
;
}
if
(
mCurrentContext
=
=
mHeadContext
&
&
!
mContextStack
.
IsEmpty
(
)
)
{
mContextStack
.
RemoveLastElement
(
)
;
}
for
(
int32_t
i
=
0
numContexts
=
mContextStack
.
Length
(
)
;
i
<
numContexts
;
i
+
+
)
{
SinkContext
*
sc
=
mContextStack
.
ElementAt
(
i
)
;
if
(
sc
)
{
sc
-
>
End
(
)
;
if
(
sc
=
=
mCurrentContext
)
{
mCurrentContext
=
nullptr
;
}
delete
sc
;
}
}
if
(
mCurrentContext
=
=
mHeadContext
)
{
mCurrentContext
=
nullptr
;
}
delete
mCurrentContext
;
delete
mHeadContext
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLContentSink
nsContentSink
mHTMLDocument
mRoot
mBody
mHead
)
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLContentSink
nsContentSink
nsIContentSink
nsIHTMLContentSink
)
nsresult
HTMLContentSink
:
:
Init
(
Document
*
aDoc
nsIURI
*
aURI
nsISupports
*
aContainer
nsIChannel
*
aChannel
)
{
NS_ENSURE_TRUE
(
aContainer
NS_ERROR_NULL_POINTER
)
;
nsresult
rv
=
nsContentSink
:
:
Init
(
aDoc
aURI
aContainer
aChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aDoc
-
>
AddObserver
(
this
)
;
mIsDocumentObserver
=
true
;
mHTMLDocument
=
aDoc
-
>
AsHTMLDocument
(
)
;
NS_ASSERTION
(
mDocShell
"
oops
no
docshell
!
"
)
;
mMaxTextRun
=
Preferences
:
:
GetInt
(
"
content
.
maxtextrun
"
8191
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nodeInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
html
nullptr
kNameSpaceID_XHTML
nsINode
:
:
ELEMENT_NODE
)
;
mRoot
=
NS_NewHTMLHtmlElement
(
nodeInfo
.
forget
(
)
)
;
if
(
!
mRoot
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
NS_ASSERTION
(
mDocument
-
>
GetChildCount
(
)
=
=
0
"
Document
should
have
no
kids
here
!
"
)
;
ErrorResult
error
;
mDocument
-
>
AppendChildTo
(
mRoot
false
error
)
;
if
(
error
.
Failed
(
)
)
{
return
error
.
StealNSResult
(
)
;
}
nodeInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
head
nullptr
kNameSpaceID_XHTML
nsINode
:
:
ELEMENT_NODE
)
;
mHead
=
NS_NewHTMLHeadElement
(
nodeInfo
.
forget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mRoot
-
>
AppendChildTo
(
mHead
false
IgnoreErrors
(
)
)
;
mCurrentContext
=
new
SinkContext
(
this
)
;
mCurrentContext
-
>
Begin
(
eHTMLTag_html
mRoot
0
-
1
)
;
mContextStack
.
AppendElement
(
mCurrentContext
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLContentSink
:
:
WillParse
(
void
)
{
return
WillParseImpl
(
)
;
}
NS_IMETHODIMP
HTMLContentSink
:
:
WillBuildModel
(
nsDTDMode
aDTDMode
)
{
WillBuildModelImpl
(
)
;
mDocument
-
>
SetCompatibilityMode
(
aDTDMode
=
=
eDTDMode_full_standards
?
eCompatibility_FullStandards
:
eCompatibility_NavQuirks
)
;
mDocument
-
>
BeginLoad
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLContentSink
:
:
DidBuildModel
(
bool
aTerminated
)
{
DidBuildModelImpl
(
aTerminated
)
;
if
(
mBody
)
{
mCurrentContext
-
>
FlushTags
(
)
;
}
else
if
(
!
mLayoutStarted
)
{
bool
bDestroying
=
true
;
if
(
mDocShell
)
{
mDocShell
-
>
IsBeingDestroyed
(
&
bDestroying
)
;
}
if
(
!
bDestroying
)
{
StartLayout
(
false
)
;
}
}
ScrollToRef
(
)
;
mDocument
-
>
RemoveObserver
(
this
)
;
mIsDocumentObserver
=
false
;
mDocument
-
>
EndLoad
(
)
;
DropParserAndPerfHint
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLContentSink
:
:
SetParser
(
nsParserBase
*
aParser
)
{
MOZ_ASSERT
(
aParser
"
Should
have
a
parser
here
!
"
)
;
mParser
=
aParser
;
return
NS_OK
;
}
nsresult
HTMLContentSink
:
:
CloseHTML
(
)
{
if
(
mHeadContext
)
{
if
(
mCurrentContext
=
=
mHeadContext
)
{
mCurrentContext
=
mContextStack
.
PopLastElement
(
)
;
}
mHeadContext
-
>
End
(
)
;
delete
mHeadContext
;
mHeadContext
=
nullptr
;
}
return
NS_OK
;
}
nsresult
HTMLContentSink
:
:
OpenBody
(
)
{
CloseHeadContext
(
)
;
if
(
mBody
)
{
return
NS_OK
;
}
nsresult
rv
=
mCurrentContext
-
>
OpenBody
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mBody
=
mCurrentContext
-
>
mStack
[
mCurrentContext
-
>
mStackPos
-
1
]
.
mContent
;
if
(
mCurrentContext
-
>
mStackPos
>
1
)
{
int32_t
parentIndex
=
mCurrentContext
-
>
mStackPos
-
2
;
nsGenericHTMLElement
*
parent
=
mCurrentContext
-
>
mStack
[
parentIndex
]
.
mContent
;
int32_t
numFlushed
=
mCurrentContext
-
>
mStack
[
parentIndex
]
.
mNumFlushed
;
int32_t
childCount
=
parent
-
>
GetChildCount
(
)
;
NS_ASSERTION
(
numFlushed
<
childCount
"
Already
notified
on
the
body
?
"
)
;
int32_t
insertionPoint
=
mCurrentContext
-
>
mStack
[
parentIndex
]
.
mInsertionPoint
;
uint32_t
oldUpdates
=
mUpdatesInNotification
;
mUpdatesInNotification
=
0
;
if
(
insertionPoint
!
=
-
1
)
{
NotifyInsert
(
parent
mBody
)
;
}
else
{
NotifyAppend
(
parent
numFlushed
)
;
}
mCurrentContext
-
>
mStack
[
parentIndex
]
.
mNumFlushed
=
childCount
;
if
(
mUpdatesInNotification
>
1
)
{
UpdateChildCounts
(
)
;
}
mUpdatesInNotification
=
oldUpdates
;
}
StartLayout
(
false
)
;
return
NS_OK
;
}
nsresult
HTMLContentSink
:
:
CloseBody
(
)
{
mCurrentContext
-
>
FlushTags
(
)
;
mCurrentContext
-
>
CloseBody
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLContentSink
:
:
OpenContainer
(
ElementType
aElementType
)
{
nsresult
rv
=
NS_OK
;
switch
(
aElementType
)
{
case
eBody
:
rv
=
OpenBody
(
)
;
break
;
case
eHTML
:
if
(
mRoot
)
{
if
(
!
mNotifiedRootInsertion
)
{
NotifyRootInsertion
(
)
;
}
}
break
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLContentSink
:
:
CloseContainer
(
const
ElementType
aTag
)
{
nsresult
rv
=
NS_OK
;
switch
(
aTag
)
{
case
eBody
:
rv
=
CloseBody
(
)
;
break
;
case
eHTML
:
rv
=
CloseHTML
(
)
;
break
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLContentSink
:
:
WillInterrupt
(
)
{
return
WillInterruptImpl
(
)
;
}
void
HTMLContentSink
:
:
WillResume
(
)
{
WillResumeImpl
(
)
;
}
void
HTMLContentSink
:
:
CloseHeadContext
(
)
{
if
(
mCurrentContext
)
{
if
(
!
mCurrentContext
-
>
IsCurrentContainer
(
eHTMLTag_head
)
)
return
;
mCurrentContext
-
>
FlushTags
(
)
;
}
if
(
!
mContextStack
.
IsEmpty
(
)
)
{
mCurrentContext
=
mContextStack
.
PopLastElement
(
)
;
}
}
void
HTMLContentSink
:
:
NotifyInsert
(
nsIContent
*
aContent
nsIContent
*
aChildContent
)
{
mInNotification
+
+
;
{
MOZ_AUTO_DOC_UPDATE
(
aContent
?
aContent
-
>
OwnerDoc
(
)
:
mDocument
.
get
(
)
true
)
;
MutationObservers
:
:
NotifyContentInserted
(
NODE_FROM
(
aContent
mDocument
)
aChildContent
)
;
mLastNotificationTime
=
PR_Now
(
)
;
}
mInNotification
-
-
;
}
void
HTMLContentSink
:
:
NotifyRootInsertion
(
)
{
MOZ_ASSERT
(
!
mNotifiedRootInsertion
"
Double
-
notifying
on
root
?
"
)
;
NS_ASSERTION
(
!
mLayoutStarted
"
How
did
we
start
layout
without
notifying
on
root
?
"
)
;
mNotifiedRootInsertion
=
true
;
NotifyInsert
(
nullptr
mRoot
)
;
UpdateChildCounts
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsDocElementCreatedNotificationRunner
(
mDocument
)
)
;
}
void
HTMLContentSink
:
:
UpdateChildCounts
(
)
{
uint32_t
numContexts
=
mContextStack
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numContexts
;
i
+
+
)
{
SinkContext
*
sc
=
mContextStack
.
ElementAt
(
i
)
;
sc
-
>
UpdateChildCounts
(
)
;
}
mCurrentContext
-
>
UpdateChildCounts
(
)
;
}
void
HTMLContentSink
:
:
FlushPendingNotifications
(
FlushType
aType
)
{
if
(
!
mInNotification
)
{
if
(
mIsDocumentObserver
)
{
if
(
aType
>
=
FlushType
:
:
ContentAndNotify
)
{
FlushTags
(
)
;
}
}
if
(
aType
>
=
FlushType
:
:
EnsurePresShellInitAndFrames
)
{
StartLayout
(
true
)
;
}
}
}
nsresult
HTMLContentSink
:
:
FlushTags
(
)
{
if
(
!
mNotifiedRootInsertion
)
{
NotifyRootInsertion
(
)
;
return
NS_OK
;
}
return
mCurrentContext
?
mCurrentContext
-
>
FlushTags
(
)
:
NS_OK
;
}
void
HTMLContentSink
:
:
SetDocumentCharset
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
MOZ_ASSERT_UNREACHABLE
(
"
<
meta
charset
>
case
doesn
'
t
occur
with
about
:
blank
"
)
;
}
nsISupports
*
HTMLContentSink
:
:
GetTarget
(
)
{
return
ToSupports
(
mDocument
)
;
}
bool
HTMLContentSink
:
:
IsScriptExecuting
(
)
{
return
IsScriptExecutingImpl
(
)
;
}
void
HTMLContentSink
:
:
ContinueInterruptedParsingIfEnabled
(
)
{
if
(
mParser
&
&
mParser
-
>
IsParserEnabled
(
)
)
{
static_cast
<
nsIParser
*
>
(
mParser
.
get
(
)
)
-
>
ContinueInterruptedParsing
(
)
;
}
}
void
HTMLContentSink
:
:
ContinueInterruptedParsingAsync
(
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
HTMLContentSink
:
:
ContinueInterruptedParsingIfEnabled
"
this
&
HTMLContentSink
:
:
ContinueInterruptedParsingIfEnabled
)
;
RefPtr
<
Document
>
doc
=
mHTMLDocument
;
doc
-
>
Dispatch
(
mozilla
:
:
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
}
