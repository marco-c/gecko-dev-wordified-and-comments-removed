#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
dom
/
HTMLEmbedElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLEmbedElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPluginDocument
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsContentUtils
.
h
"
#
ifdef
XP_MACOSX
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
HTMLObjectElement
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
Embed
)
namespace
mozilla
{
namespace
dom
{
HTMLEmbedElement
:
:
HTMLEmbedElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLElement
(
aNodeInfo
)
{
RegisterActivityObserver
(
)
;
SetIsNetworkCreated
(
aFromParser
=
=
FROM_PARSER_NETWORK
)
;
AddStatesSilently
(
NS_EVENT_STATE_LOADING
)
;
}
HTMLEmbedElement
:
:
~
HTMLEmbedElement
(
)
{
#
ifdef
XP_MACOSX
HTMLObjectElement
:
:
OnFocusBlurPlugin
(
this
false
)
;
#
endif
UnregisterActivityObserver
(
)
;
DestroyImageLoadingContent
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLEmbedElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLEmbedElement
nsGenericHTMLElement
)
nsObjectLoadingContent
:
:
Traverse
(
tmp
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLEmbedElement
nsGenericHTMLElement
nsIRequestObserver
nsIStreamListener
nsIFrameLoaderOwner
nsIObjectLoadingContent
imgINotificationObserver
nsIImageLoadingContent
nsIChannelEventSink
)
NS_IMPL_ELEMENT_CLONE
(
HTMLEmbedElement
)
#
ifdef
XP_MACOSX
NS_IMETHODIMP
HTMLEmbedElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
HTMLObjectElement
:
:
HandleFocusBlurPlugin
(
this
aVisitor
.
mEvent
)
;
return
NS_OK
;
}
#
endif
void
HTMLEmbedElement
:
:
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
{
nsImageLoadingContent
:
:
AsyncEventRunning
(
aEvent
)
;
}
nsresult
HTMLEmbedElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsObjectLoadingContent
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPluginDocument
>
pluginDoc
=
do_QueryInterface
(
aDocument
)
;
if
(
!
pluginDoc
)
{
void
(
HTMLEmbedElement
:
:
*
start
)
(
)
=
&
HTMLEmbedElement
:
:
StartObjectLoad
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
dom
:
:
HTMLEmbedElement
:
:
BindToTree
"
this
start
)
)
;
}
return
NS_OK
;
}
void
HTMLEmbedElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
#
ifdef
XP_MACOSX
HTMLObjectElement
:
:
OnFocusBlurPlugin
(
this
false
)
;
#
endif
nsObjectLoadingContent
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
}
nsresult
HTMLEmbedElement
:
:
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aValue
)
{
nsresult
rv
=
AfterMaybeChangeAttr
(
aNamespaceID
aName
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNamespaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
nsresult
HTMLEmbedElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
nsresult
rv
=
AfterMaybeChangeAttr
(
aNamespaceID
aName
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
nsGenericHTMLElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLEmbedElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
src
)
{
if
(
aNotify
&
&
IsInComposedDoc
(
)
&
&
!
BlockEmbedOrObjectContentLoading
(
)
)
{
nsresult
rv
=
LoadObject
(
aNotify
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
bool
HTMLEmbedElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
TabIndex
(
)
;
}
*
aIsFocusable
=
true
;
return
true
;
}
nsIContent
:
:
IMEState
HTMLEmbedElement
:
:
GetDesiredIMEState
(
)
{
if
(
Type
(
)
=
=
eType_Plugin
)
{
return
IMEState
(
IMEState
:
:
PLUGIN
)
;
}
return
nsGenericHTMLElement
:
:
GetDesiredIMEState
(
)
;
}
int32_t
HTMLEmbedElement
:
:
TabIndexDefault
(
)
{
return
-
1
;
}
bool
HTMLEmbedElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
ParseImageAttribute
(
aAttribute
aValue
aResult
)
)
{
return
true
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
static
void
MapAttributesIntoRuleBase
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
nsGenericHTMLElement
:
:
MapImageBorderAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageMarginAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageAlignAttributeInto
(
aAttributes
aDecls
)
;
}
static
void
MapAttributesIntoRuleExceptHidden
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
MapAttributesIntoRuleBase
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesIntoExceptHidden
(
aAttributes
aDecls
)
;
}
void
HTMLEmbedElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
MapAttributesIntoRuleBase
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
aAttributes
aDecls
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLEmbedElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sCommonAttributeMap
sImageMarginSizeAttributeMap
sImageBorderAttributeMap
sImageAlignAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLEmbedElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRuleExceptHidden
;
}
void
HTMLEmbedElement
:
:
StartObjectLoad
(
bool
aNotify
bool
aForceLoad
)
{
if
(
!
IsInComposedDoc
(
)
|
|
!
OwnerDoc
(
)
-
>
IsActive
(
)
|
|
BlockEmbedOrObjectContentLoading
(
)
)
{
return
;
}
LoadObject
(
aNotify
aForceLoad
)
;
SetIsNetworkCreated
(
false
)
;
}
EventStates
HTMLEmbedElement
:
:
IntrinsicState
(
)
const
{
return
nsGenericHTMLElement
:
:
IntrinsicState
(
)
|
ObjectState
(
)
;
}
uint32_t
HTMLEmbedElement
:
:
GetCapabilities
(
)
const
{
return
eSupportPlugins
|
eAllowPluginSkipChannel
|
eSupportImages
|
eSupportDocuments
;
}
void
HTMLEmbedElement
:
:
DestroyContent
(
)
{
nsObjectLoadingContent
:
:
DestroyContent
(
)
;
nsGenericHTMLElement
:
:
DestroyContent
(
)
;
}
nsresult
HTMLEmbedElement
:
:
CopyInnerTo
(
HTMLEmbedElement
*
aDest
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
CopyInnerTo
(
aDest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDest
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
CreateStaticClone
(
aDest
)
;
}
return
rv
;
}
JSObject
*
HTMLEmbedElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
JSObject
*
obj
;
obj
=
HTMLEmbedElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
if
(
!
obj
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
rootedObj
(
aCx
obj
)
;
SetupProtoChain
(
aCx
rootedObj
)
;
return
rootedObj
;
}
nsContentPolicyType
HTMLEmbedElement
:
:
GetContentPolicyType
(
)
const
{
return
nsIContentPolicy
:
:
TYPE_INTERNAL_EMBED
;
}
}
}
