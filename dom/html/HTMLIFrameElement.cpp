#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElementBinding
.
h
"
#
include
"
mozilla
/
GenericSpecifiedValuesInlines
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsSandboxFlags
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
IFrame
)
namespace
mozilla
{
namespace
dom
{
const
DOMTokenListSupportedToken
HTMLIFrameElement
:
:
sSupportedSandboxTokens
[
]
=
{
#
define
SANDBOX_KEYWORD
(
string
atom
flags
)
string
#
include
"
IframeSandboxKeywordList
.
h
"
#
undef
SANDBOX_KEYWORD
nullptr
}
;
HTMLIFrameElement
:
:
HTMLIFrameElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFrameElement
(
aNodeInfo
aFromParser
)
{
}
HTMLIFrameElement
:
:
~
HTMLIFrameElement
(
)
{
}
NS_IMPL_ISUPPORTS_INHERITED0
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_IMPL_ELEMENT_CLONE
(
HTMLIFrameElement
)
bool
HTMLIFrameElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsIAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginwidth
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginheight
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
frameborder
)
{
return
ParseFrameborderValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
scrolling
)
{
return
ParseScrollingValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
sandbox
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
}
return
nsGenericHTMLFrameElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aResult
)
;
}
void
HTMLIFrameElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
GenericSpecifiedValues
*
aData
)
{
if
(
aData
-
>
ShouldComputeStyleStruct
(
NS_STYLE_INHERIT_BIT
(
Border
)
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
frameborder
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
int32_t
frameborder
=
value
-
>
GetEnumValue
(
)
;
if
(
NS_STYLE_FRAME_0
=
=
frameborder
|
|
NS_STYLE_FRAME_NO
=
=
frameborder
|
|
NS_STYLE_FRAME_OFF
=
=
frameborder
)
{
aData
-
>
SetPixelValueIfUnset
(
eCSSProperty_border_top_width
0
.
0f
)
;
aData
-
>
SetPixelValueIfUnset
(
eCSSProperty_border_right_width
0
.
0f
)
;
aData
-
>
SetPixelValueIfUnset
(
eCSSProperty_border_bottom_width
0
.
0f
)
;
aData
-
>
SetPixelValueIfUnset
(
eCSSProperty_border_left_width
0
.
0f
)
;
}
}
}
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
aAttributes
aData
)
;
nsGenericHTMLElement
:
:
MapImageAlignAttributeInto
(
aAttributes
aData
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
aAttributes
aData
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLIFrameElement
:
:
IsAttributeMapped
(
const
nsIAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
attributes
[
]
=
{
{
&
nsGkAtoms
:
:
width
}
{
&
nsGkAtoms
:
:
height
}
{
&
nsGkAtoms
:
:
frameborder
}
{
nullptr
}
}
;
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
attributes
sImageAlignAttributeMap
sCommonAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLIFrameElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
nsresult
HTMLIFrameElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNameSpaceID
aName
aNotify
)
;
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
sandbox
)
{
if
(
mFrameLoader
)
{
mFrameLoader
-
>
ApplySandboxFlags
(
GetSandboxFlags
(
)
)
;
}
}
}
return
nsGenericHTMLFrameElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aNotify
)
;
}
nsresult
HTMLIFrameElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsIAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNamespaceID
aName
aNotify
)
;
return
nsGenericHTMLFrameElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
void
HTMLIFrameElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsIAtom
*
aName
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
srcdoc
)
{
LoadSrc
(
)
;
}
}
}
uint32_t
HTMLIFrameElement
:
:
GetSandboxFlags
(
)
{
const
nsAttrValue
*
sandboxAttr
=
GetParsedAttr
(
nsGkAtoms
:
:
sandbox
)
;
if
(
!
sandboxAttr
)
{
return
SANDBOXED_NONE
;
}
return
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
sandboxAttr
)
;
}
JSObject
*
HTMLIFrameElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLIFrameElementBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
