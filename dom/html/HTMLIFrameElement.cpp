#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicy
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsNetUtil
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
IFrame
)
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLIFrameElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSandbox
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSandbox
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ADDREF_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_IMPL_RELEASE_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLIFrameElement
)
NS_INTERFACE_MAP_END_INHERITING
(
nsGenericHTMLFrameElement
)
const
DOMTokenListSupportedToken
HTMLIFrameElement
:
:
sSupportedSandboxTokens
[
]
=
{
#
define
SANDBOX_KEYWORD
(
string
atom
flags
)
string
#
include
"
IframeSandboxKeywordList
.
h
"
#
undef
SANDBOX_KEYWORD
nullptr
}
;
HTMLIFrameElement
:
:
HTMLIFrameElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFrameElement
(
std
:
:
move
(
aNodeInfo
)
aFromParser
)
{
mFeaturePolicy
=
new
mozilla
:
:
dom
:
:
FeaturePolicy
(
this
)
;
nsCOMPtr
<
nsIPrincipal
>
origin
=
GetFeaturePolicyDefaultOrigin
(
)
;
MOZ_ASSERT
(
origin
)
;
mFeaturePolicy
-
>
SetDefaultOrigin
(
origin
)
;
}
HTMLIFrameElement
:
:
~
HTMLIFrameElement
(
)
{
}
NS_IMPL_ELEMENT_CLONE
(
HTMLIFrameElement
)
nsresult
HTMLIFrameElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLFrameElement
:
:
BindToTree
(
aContext
aParent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
{
RefreshFeaturePolicy
(
true
)
;
}
return
NS_OK
;
}
bool
HTMLIFrameElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginwidth
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginheight
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
)
{
return
aResult
.
ParseHTMLDimension
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
return
aResult
.
ParseHTMLDimension
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
frameborder
)
{
return
ParseFrameborderValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
scrolling
)
{
return
ParseScrollingValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
sandbox
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
}
return
nsGenericHTMLFrameElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLIFrameElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
frameborder
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
int32_t
frameborder
=
value
-
>
GetEnumValue
(
)
;
if
(
NS_STYLE_FRAME_0
=
=
frameborder
|
|
NS_STYLE_FRAME_NO
=
=
frameborder
|
|
NS_STYLE_FRAME_OFF
=
=
frameborder
)
{
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_top_width
0
.
0f
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_right_width
0
.
0f
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_bottom_width
0
.
0f
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_left_width
0
.
0f
)
;
}
}
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageAlignAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
aAttributes
aDecls
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLIFrameElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
attributes
[
]
=
{
{
nsGkAtoms
:
:
width
}
{
nsGkAtoms
:
:
height
}
{
nsGkAtoms
:
:
frameborder
}
{
nullptr
}
}
;
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
attributes
sImageAlignAttributeMap
sCommonAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLIFrameElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
nsresult
HTMLIFrameElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNameSpaceID
aName
aNotify
)
;
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
sandbox
)
{
if
(
mFrameLoader
)
{
mFrameLoader
-
>
ApplySandboxFlags
(
GetSandboxFlags
(
)
)
;
}
}
if
(
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
{
if
(
aName
=
=
nsGkAtoms
:
:
allow
|
|
aName
=
=
nsGkAtoms
:
:
src
|
|
aName
=
=
nsGkAtoms
:
:
srcdoc
|
|
aName
=
=
nsGkAtoms
:
:
sandbox
)
{
RefreshFeaturePolicy
(
true
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
allowfullscreen
|
|
aName
=
=
nsGkAtoms
:
:
allowpaymentrequest
)
{
RefreshFeaturePolicy
(
false
)
;
}
}
}
return
nsGenericHTMLFrameElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
nsresult
HTMLIFrameElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNamespaceID
aName
aNotify
)
;
return
nsGenericHTMLFrameElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
void
HTMLIFrameElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
srcdoc
)
{
LoadSrc
(
)
;
}
}
}
uint32_t
HTMLIFrameElement
:
:
GetSandboxFlags
(
)
const
{
const
nsAttrValue
*
sandboxAttr
=
GetParsedAttr
(
nsGkAtoms
:
:
sandbox
)
;
if
(
!
sandboxAttr
)
{
return
SANDBOXED_NONE
;
}
return
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
sandboxAttr
)
;
}
JSObject
*
HTMLIFrameElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLIFrameElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
mozilla
:
:
dom
:
:
FeaturePolicy
*
HTMLIFrameElement
:
:
FeaturePolicy
(
)
const
{
return
mFeaturePolicy
;
}
void
HTMLIFrameElement
:
:
MaybeStoreCrossOriginFeaturePolicy
(
)
{
if
(
!
mFrameLoader
)
{
return
;
}
if
(
!
mFrameLoader
-
>
IsRemoteFrame
(
)
&
&
!
mFrameLoader
-
>
GetExistingDocShell
(
)
)
{
return
;
}
RefPtr
<
BrowsingContext
>
browsingContext
=
mFrameLoader
-
>
GetBrowsingContext
(
)
;
if
(
!
browsingContext
|
|
!
browsingContext
-
>
IsContentSubframe
(
)
)
{
return
;
}
nsPIDOMWindowOuter
*
topWindow
=
browsingContext
-
>
Top
(
)
-
>
GetDOMWindow
(
)
;
if
(
NS_WARN_IF
(
!
topWindow
)
)
{
return
;
}
Document
*
topLevelDocument
=
topWindow
-
>
GetExtantDoc
(
)
;
if
(
NS_WARN_IF
(
!
topLevelDocument
)
)
{
return
;
}
if
(
!
NS_SUCCEEDED
(
nsContentUtils
:
:
CheckSameOrigin
(
topLevelDocument
this
)
)
)
{
return
;
}
browsingContext
-
>
SetFeaturePolicy
(
mFeaturePolicy
)
;
}
already_AddRefed
<
nsIPrincipal
>
HTMLIFrameElement
:
:
GetFeaturePolicyDefaultOrigin
(
)
const
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
srcdoc
)
)
{
principal
=
NodePrincipal
(
)
;
return
principal
.
forget
(
)
;
}
nsCOMPtr
<
nsIURI
>
nodeURI
;
if
(
GetURIAttr
(
nsGkAtoms
:
:
src
nullptr
getter_AddRefs
(
nodeURI
)
)
&
&
nodeURI
)
{
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
nodeURI
BasePrincipal
:
:
Cast
(
NodePrincipal
(
)
)
-
>
OriginAttributesRef
(
)
)
;
}
if
(
!
principal
)
{
principal
=
NodePrincipal
(
)
;
}
return
principal
.
forget
(
)
;
}
void
HTMLIFrameElement
:
:
RefreshFeaturePolicy
(
bool
aParseAllowAttribute
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
;
if
(
aParseAllowAttribute
)
{
mFeaturePolicy
-
>
ResetDeclaredPolicy
(
)
;
nsCOMPtr
<
nsIPrincipal
>
origin
=
GetFeaturePolicyDefaultOrigin
(
)
;
MOZ_ASSERT
(
origin
)
;
mFeaturePolicy
-
>
SetDefaultOrigin
(
origin
)
;
nsAutoString
allow
;
GetAttr
(
nsGkAtoms
:
:
allow
allow
)
;
if
(
!
allow
.
IsEmpty
(
)
)
{
mFeaturePolicy
-
>
SetDeclaredPolicy
(
OwnerDoc
(
)
allow
NodePrincipal
(
)
origin
)
;
}
mFeaturePolicy
-
>
InheritPolicy
(
OwnerDoc
(
)
-
>
FeaturePolicy
(
)
)
;
}
if
(
AllowPaymentRequest
(
)
)
{
mFeaturePolicy
-
>
MaybeSetAllowedPolicy
(
NS_LITERAL_STRING
(
"
payment
"
)
)
;
}
if
(
AllowFullscreen
(
)
)
{
mFeaturePolicy
-
>
MaybeSetAllowedPolicy
(
NS_LITERAL_STRING
(
"
fullscreen
"
)
)
;
}
MaybeStoreCrossOriginFeaturePolicy
(
)
;
}
}
}
