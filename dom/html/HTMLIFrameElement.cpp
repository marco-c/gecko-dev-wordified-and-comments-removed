#
include
"
mozilla
/
dom
/
DOMIntersectionObserver
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicy
.
h
"
#
include
"
mozilla
/
MappedDeclarationsBuilder
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsNetUtil
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
IFrame
)
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLIFrameElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSandbox
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSandbox
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ADDREF_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_IMPL_RELEASE_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLIFrameElement
)
NS_INTERFACE_MAP_END_INHERITING
(
nsGenericHTMLFrameElement
)
const
DOMTokenListSupportedToken
HTMLIFrameElement
:
:
sSupportedSandboxTokens
[
]
=
{
#
define
SANDBOX_KEYWORD
(
string
atom
flags
)
string
#
include
"
IframeSandboxKeywordList
.
h
"
#
undef
SANDBOX_KEYWORD
nullptr
}
;
HTMLIFrameElement
:
:
HTMLIFrameElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFrameElement
(
std
:
:
move
(
aNodeInfo
)
aFromParser
)
{
mFeaturePolicy
=
new
mozilla
:
:
dom
:
:
FeaturePolicy
(
this
)
;
nsCOMPtr
<
nsIPrincipal
>
origin
=
GetFeaturePolicyDefaultOrigin
(
)
;
MOZ_ASSERT
(
origin
)
;
mFeaturePolicy
-
>
SetDefaultOrigin
(
origin
)
;
}
HTMLIFrameElement
:
:
~
HTMLIFrameElement
(
)
=
default
;
NS_IMPL_ELEMENT_CLONE
(
HTMLIFrameElement
)
void
HTMLIFrameElement
:
:
BindToBrowsingContext
(
BrowsingContext
*
)
{
RefreshFeaturePolicy
(
true
)
;
}
bool
HTMLIFrameElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginwidth
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginheight
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
)
{
return
aResult
.
ParseHTMLDimension
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
return
aResult
.
ParseHTMLDimension
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
frameborder
)
{
return
ParseFrameborderValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
scrolling
)
{
return
ParseScrollingValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
sandbox
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
loading
)
{
return
ParseLoadingAttribute
(
aValue
aResult
)
;
}
}
return
nsGenericHTMLFrameElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLIFrameElement
:
:
MapAttributesIntoRule
(
MappedDeclarationsBuilder
&
aBuilder
)
{
const
nsAttrValue
*
value
=
aBuilder
.
GetAttr
(
nsGkAtoms
:
:
frameborder
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
auto
frameborder
=
static_cast
<
FrameBorderProperty
>
(
value
-
>
GetEnumValue
(
)
)
;
if
(
FrameBorderProperty
:
:
No
=
=
frameborder
|
|
FrameBorderProperty
:
:
Zero
=
=
frameborder
)
{
aBuilder
.
SetPixelValueIfUnset
(
eCSSProperty_border_top_width
0
.
0f
)
;
aBuilder
.
SetPixelValueIfUnset
(
eCSSProperty_border_right_width
0
.
0f
)
;
aBuilder
.
SetPixelValueIfUnset
(
eCSSProperty_border_bottom_width
0
.
0f
)
;
aBuilder
.
SetPixelValueIfUnset
(
eCSSProperty_border_left_width
0
.
0f
)
;
}
}
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
aBuilder
)
;
nsGenericHTMLElement
:
:
MapImageAlignAttributeInto
(
aBuilder
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
aBuilder
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLIFrameElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
attributes
[
]
=
{
{
nsGkAtoms
:
:
width
}
{
nsGkAtoms
:
:
height
}
{
nsGkAtoms
:
:
frameborder
}
{
nullptr
}
}
;
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
attributes
sImageAlignAttributeMap
sCommonAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLIFrameElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
void
HTMLIFrameElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNameSpaceID
aName
aNotify
)
;
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
loading
)
{
if
(
aValue
&
&
Loading
(
aValue
-
>
GetEnumValue
(
)
)
=
=
Loading
:
:
Lazy
)
{
SetLazyLoading
(
)
;
}
else
if
(
aOldValue
&
&
Loading
(
aOldValue
-
>
GetEnumValue
(
)
)
=
=
Loading
:
:
Lazy
)
{
StopLazyLoading
(
)
;
}
}
if
(
(
aName
=
=
nsGkAtoms
:
:
src
|
|
aName
=
=
nsGkAtoms
:
:
srcdoc
)
&
&
LoadingState
(
)
=
=
Loading
:
:
Lazy
)
{
SetLazyLoading
(
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
sandbox
)
{
if
(
mFrameLoader
)
{
mFrameLoader
-
>
ApplySandboxFlags
(
GetSandboxFlags
(
)
)
;
}
}
if
(
aName
=
=
nsGkAtoms
:
:
allow
|
|
aName
=
=
nsGkAtoms
:
:
src
|
|
aName
=
=
nsGkAtoms
:
:
srcdoc
|
|
aName
=
=
nsGkAtoms
:
:
sandbox
)
{
RefreshFeaturePolicy
(
true
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
allowfullscreen
)
{
RefreshFeaturePolicy
(
false
)
;
}
}
return
nsGenericHTMLFrameElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
void
HTMLIFrameElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNamespaceID
aName
aNotify
)
;
return
nsGenericHTMLFrameElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
void
HTMLIFrameElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
srcdoc
)
{
LoadSrc
(
)
;
}
}
}
uint32_t
HTMLIFrameElement
:
:
GetSandboxFlags
(
)
const
{
const
nsAttrValue
*
sandboxAttr
=
GetParsedAttr
(
nsGkAtoms
:
:
sandbox
)
;
if
(
!
sandboxAttr
)
{
return
SANDBOXED_NONE
;
}
return
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
sandboxAttr
)
;
}
JSObject
*
HTMLIFrameElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLIFrameElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
mozilla
:
:
dom
:
:
FeaturePolicy
*
HTMLIFrameElement
:
:
FeaturePolicy
(
)
const
{
return
mFeaturePolicy
;
}
void
HTMLIFrameElement
:
:
MaybeStoreCrossOriginFeaturePolicy
(
)
{
if
(
!
mFrameLoader
)
{
return
;
}
if
(
!
mFrameLoader
-
>
IsRemoteFrame
(
)
&
&
!
mFrameLoader
-
>
GetExistingDocShell
(
)
)
{
return
;
}
RefPtr
<
BrowsingContext
>
browsingContext
=
mFrameLoader
-
>
GetBrowsingContext
(
)
;
if
(
!
browsingContext
|
|
!
browsingContext
-
>
IsContentSubframe
(
)
)
{
return
;
}
if
(
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
)
{
Unused
<
<
cc
-
>
SendSetContainerFeaturePolicy
(
browsingContext
Some
(
mFeaturePolicy
-
>
ToFeaturePolicyInfo
(
)
)
)
;
}
}
already_AddRefed
<
nsIPrincipal
>
HTMLIFrameElement
:
:
GetFeaturePolicyDefaultOrigin
(
)
const
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
HasAttr
(
nsGkAtoms
:
:
srcdoc
)
)
{
principal
=
NodePrincipal
(
)
;
return
principal
.
forget
(
)
;
}
nsCOMPtr
<
nsIURI
>
nodeURI
;
if
(
GetURIAttr
(
nsGkAtoms
:
:
src
nullptr
getter_AddRefs
(
nodeURI
)
)
&
&
nodeURI
)
{
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
nodeURI
BasePrincipal
:
:
Cast
(
NodePrincipal
(
)
)
-
>
OriginAttributesRef
(
)
)
;
}
if
(
!
principal
)
{
principal
=
NodePrincipal
(
)
;
}
return
principal
.
forget
(
)
;
}
void
HTMLIFrameElement
:
:
RefreshFeaturePolicy
(
bool
aParseAllowAttribute
)
{
if
(
aParseAllowAttribute
)
{
mFeaturePolicy
-
>
ResetDeclaredPolicy
(
)
;
nsCOMPtr
<
nsIPrincipal
>
origin
=
GetFeaturePolicyDefaultOrigin
(
)
;
MOZ_ASSERT
(
origin
)
;
mFeaturePolicy
-
>
SetDefaultOrigin
(
origin
)
;
nsAutoString
allow
;
GetAttr
(
nsGkAtoms
:
:
allow
allow
)
;
if
(
!
allow
.
IsEmpty
(
)
)
{
mFeaturePolicy
-
>
SetDeclaredPolicy
(
OwnerDoc
(
)
allow
NodePrincipal
(
)
origin
)
;
}
}
if
(
AllowFullscreen
(
)
)
{
mFeaturePolicy
-
>
MaybeSetAllowedPolicy
(
u
"
fullscreen
"
_ns
)
;
}
mFeaturePolicy
-
>
InheritPolicy
(
OwnerDoc
(
)
-
>
FeaturePolicy
(
)
)
;
MaybeStoreCrossOriginFeaturePolicy
(
)
;
}
void
HTMLIFrameElement
:
:
UpdateLazyLoadState
(
)
{
mLazyLoadState
.
mBaseURI
=
GetBaseURI
(
)
;
mLazyLoadState
.
mReferrerPolicy
=
GetReferrerPolicyAsEnum
(
)
;
}
nsresult
HTMLIFrameElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
if
(
mLazyLoading
)
{
UpdateLazyLoadState
(
)
;
}
return
nsGenericHTMLFrameElement
:
:
BindToTree
(
aContext
aParent
)
;
}
void
HTMLIFrameElement
:
:
SetLazyLoading
(
)
{
if
(
mLazyLoading
)
{
return
;
}
if
(
!
StaticPrefs
:
:
dom_iframe_lazy_loading_enabled
(
)
)
{
return
;
}
Document
*
doc
=
OwnerDoc
(
)
;
if
(
!
doc
-
>
IsScriptEnabled
(
)
|
|
doc
-
>
IsStaticDocument
(
)
)
{
return
;
}
doc
-
>
EnsureLazyLoadObserver
(
)
.
Observe
(
*
this
)
;
mLazyLoading
=
true
;
UpdateLazyLoadState
(
)
;
}
void
HTMLIFrameElement
:
:
StopLazyLoading
(
)
{
CancelLazyLoading
(
false
)
;
LoadSrc
(
)
;
mLazyLoadState
.
Clear
(
)
;
if
(
nsSubDocumentFrame
*
ourFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
)
{
ourFrame
-
>
ResetFrameLoader
(
nsSubDocumentFrame
:
:
RetainPaintData
:
:
No
)
;
}
}
void
HTMLIFrameElement
:
:
NodeInfoChanged
(
Document
*
aOldDoc
)
{
nsGenericHTMLElement
:
:
NodeInfoChanged
(
aOldDoc
)
;
if
(
mLazyLoading
)
{
aOldDoc
-
>
GetLazyLoadObserver
(
)
-
>
Unobserve
(
*
this
)
;
mLazyLoading
=
false
;
}
if
(
LoadingState
(
)
=
=
Loading
:
:
Lazy
)
{
SetLazyLoading
(
)
;
}
}
void
HTMLIFrameElement
:
:
CancelLazyLoading
(
bool
aClearLazyLoadState
)
{
if
(
!
mLazyLoading
)
{
return
;
}
Document
*
doc
=
OwnerDoc
(
)
;
if
(
auto
*
obs
=
doc
-
>
GetLazyLoadObserver
(
)
)
{
obs
-
>
Unobserve
(
*
this
)
;
}
mLazyLoading
=
false
;
if
(
aClearLazyLoadState
)
{
mLazyLoadState
.
Clear
(
)
;
}
}
}
