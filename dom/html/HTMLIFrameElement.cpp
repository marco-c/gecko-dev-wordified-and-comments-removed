#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicy
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsNetUtil
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
IFrame
)
namespace
mozilla
{
namespace
dom
{
const
DOMTokenListSupportedToken
HTMLIFrameElement
:
:
sSupportedSandboxTokens
[
]
=
{
#
define
SANDBOX_KEYWORD
(
string
atom
flags
)
string
#
include
"
IframeSandboxKeywordList
.
h
"
#
undef
SANDBOX_KEYWORD
nullptr
}
;
HTMLIFrameElement
:
:
HTMLIFrameElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFrameElement
(
std
:
:
move
(
aNodeInfo
)
aFromParser
)
{
if
(
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
{
mFeaturePolicy
=
new
FeaturePolicy
(
this
)
;
}
}
HTMLIFrameElement
:
:
~
HTMLIFrameElement
(
)
{
}
NS_IMPL_ELEMENT_CLONE
(
HTMLIFrameElement
)
nsresult
HTMLIFrameElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
nsresult
rv
=
nsGenericHTMLFrameElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
{
RefreshFeaturePolicy
(
)
;
}
return
NS_OK
;
}
bool
HTMLIFrameElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginwidth
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginheight
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
return
aResult
.
ParseSpecialIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
frameborder
)
{
return
ParseFrameborderValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
scrolling
)
{
return
ParseScrollingValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
sandbox
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
}
return
nsGenericHTMLFrameElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLIFrameElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
frameborder
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
int32_t
frameborder
=
value
-
>
GetEnumValue
(
)
;
if
(
NS_STYLE_FRAME_0
=
=
frameborder
|
|
NS_STYLE_FRAME_NO
=
=
frameborder
|
|
NS_STYLE_FRAME_OFF
=
=
frameborder
)
{
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_top_width
0
.
0f
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_right_width
0
.
0f
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_bottom_width
0
.
0f
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_left_width
0
.
0f
)
;
}
}
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageAlignAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
aAttributes
aDecls
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLIFrameElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
attributes
[
]
=
{
{
&
nsGkAtoms
:
:
width
}
{
&
nsGkAtoms
:
:
height
}
{
&
nsGkAtoms
:
:
frameborder
}
{
nullptr
}
}
;
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
attributes
sImageAlignAttributeMap
sCommonAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLIFrameElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
nsresult
HTMLIFrameElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNameSpaceID
aName
aNotify
)
;
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
sandbox
)
{
if
(
mFrameLoader
)
{
mFrameLoader
-
>
ApplySandboxFlags
(
GetSandboxFlags
(
)
)
;
}
}
if
(
(
aName
=
=
nsGkAtoms
:
:
allow
|
|
aName
=
=
nsGkAtoms
:
:
src
|
|
aName
=
=
nsGkAtoms
:
:
sandbox
)
&
&
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
{
RefreshFeaturePolicy
(
)
;
}
}
return
nsGenericHTMLFrameElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
nsresult
HTMLIFrameElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNamespaceID
aName
aNotify
)
;
return
nsGenericHTMLFrameElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
void
HTMLIFrameElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
srcdoc
)
{
LoadSrc
(
)
;
}
}
}
uint32_t
HTMLIFrameElement
:
:
GetSandboxFlags
(
)
const
{
const
nsAttrValue
*
sandboxAttr
=
GetParsedAttr
(
nsGkAtoms
:
:
sandbox
)
;
if
(
!
sandboxAttr
)
{
return
SANDBOXED_NONE
;
}
return
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
sandboxAttr
)
;
}
JSObject
*
HTMLIFrameElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLIFrameElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
FeaturePolicy
*
HTMLIFrameElement
:
:
Policy
(
)
const
{
MOZ_ASSERT
(
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
;
return
mFeaturePolicy
;
}
nsresult
HTMLIFrameElement
:
:
GetFeaturePolicyDefaultOrigin
(
nsAString
&
aDefaultOrigin
)
const
{
aDefaultOrigin
.
Truncate
(
)
;
nsresult
rv
;
nsAutoString
src
;
GetURIAttr
(
nsGkAtoms
:
:
src
nullptr
src
)
;
nsCOMPtr
<
nsIURI
>
nodeURI
;
if
(
!
src
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURI
>
baseURI
=
OwnerDoc
(
)
-
>
GetBaseURI
(
)
;
rv
=
NS_NewURI
(
getter_AddRefs
(
nodeURI
)
src
OwnerDoc
(
)
-
>
GetDocumentCharacterSet
(
)
baseURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
nodeURI
=
nullptr
;
}
}
if
(
!
nodeURI
)
{
if
(
OwnerDoc
(
)
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
{
return
NS_OK
;
}
nodeURI
=
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
}
nsAutoString
origin
;
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
nodeURI
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
aDefaultOrigin
.
Assign
(
origin
)
;
return
NS_OK
;
}
void
HTMLIFrameElement
:
:
RefreshFeaturePolicy
(
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
dom_security_featurePolicy_enabled
(
)
)
;
mFeaturePolicy
-
>
ResetDeclaredPolicy
(
)
;
nsAutoString
origin
;
nsresult
rv
=
GetFeaturePolicyDefaultOrigin
(
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
mFeaturePolicy
-
>
SetDefaultOrigin
(
origin
)
;
nsAutoString
allow
;
GetAttr
(
nsGkAtoms
:
:
allow
allow
)
;
if
(
!
allow
.
IsEmpty
(
)
)
{
nsAutoString
documentOrigin
;
if
(
OwnerDoc
(
)
-
>
GetSandboxFlags
(
)
^
SANDBOXED_ORIGIN
)
{
nsresult
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
NodePrincipal
(
)
documentOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
mFeaturePolicy
-
>
SetDeclaredPolicy
(
OwnerDoc
(
)
allow
documentOrigin
origin
true
)
;
}
mFeaturePolicy
-
>
InheritPolicy
(
OwnerDoc
(
)
-
>
Policy
(
)
)
;
}
}
}
