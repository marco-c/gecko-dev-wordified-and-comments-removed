#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DeclarationBlock
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IMEContentObserver
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
StaticPrefs_html5
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_accessibility
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsDOMCSSDeclaration
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
nsDOMStringMap
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsHtml5Module
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
HTMLFieldSetElement
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
HTMLBRElement
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
FromParser
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
mozilla
/
BloomFilter
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLabelElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
ElementInternals
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
const
uint8_t
NS_INPUTMODE_NONE
=
1
;
static
const
uint8_t
NS_INPUTMODE_TEXT
=
2
;
static
const
uint8_t
NS_INPUTMODE_TEL
=
3
;
static
const
uint8_t
NS_INPUTMODE_URL
=
4
;
static
const
uint8_t
NS_INPUTMODE_EMAIL
=
5
;
static
const
uint8_t
NS_INPUTMODE_NUMERIC
=
6
;
static
const
uint8_t
NS_INPUTMODE_DECIMAL
=
7
;
static
const
uint8_t
NS_INPUTMODE_SEARCH
=
8
;
static
const
nsAttrValue
:
:
EnumTable
kInputmodeTable
[
]
=
{
{
"
none
"
NS_INPUTMODE_NONE
}
{
"
text
"
NS_INPUTMODE_TEXT
}
{
"
tel
"
NS_INPUTMODE_TEL
}
{
"
url
"
NS_INPUTMODE_URL
}
{
"
email
"
NS_INPUTMODE_EMAIL
}
{
"
numeric
"
NS_INPUTMODE_NUMERIC
}
{
"
decimal
"
NS_INPUTMODE_DECIMAL
}
{
"
search
"
NS_INPUTMODE_SEARCH
}
{
nullptr
0
}
}
;
static
const
uint8_t
NS_ENTERKEYHINT_ENTER
=
1
;
static
const
uint8_t
NS_ENTERKEYHINT_DONE
=
2
;
static
const
uint8_t
NS_ENTERKEYHINT_GO
=
3
;
static
const
uint8_t
NS_ENTERKEYHINT_NEXT
=
4
;
static
const
uint8_t
NS_ENTERKEYHINT_PREVIOUS
=
5
;
static
const
uint8_t
NS_ENTERKEYHINT_SEARCH
=
6
;
static
const
uint8_t
NS_ENTERKEYHINT_SEND
=
7
;
static
const
nsAttrValue
:
:
EnumTable
kEnterKeyHintTable
[
]
=
{
{
"
enter
"
NS_ENTERKEYHINT_ENTER
}
{
"
done
"
NS_ENTERKEYHINT_DONE
}
{
"
go
"
NS_ENTERKEYHINT_GO
}
{
"
next
"
NS_ENTERKEYHINT_NEXT
}
{
"
previous
"
NS_ENTERKEYHINT_PREVIOUS
}
{
"
search
"
NS_ENTERKEYHINT_SEARCH
}
{
"
send
"
NS_ENTERKEYHINT_SEND
}
{
nullptr
0
}
}
;
static
const
uint8_t
NS_AUTOCAPITALIZE_NONE
=
1
;
static
const
uint8_t
NS_AUTOCAPITALIZE_SENTENCES
=
2
;
static
const
uint8_t
NS_AUTOCAPITALIZE_WORDS
=
3
;
static
const
uint8_t
NS_AUTOCAPITALIZE_CHARACTERS
=
4
;
static
const
nsAttrValue
:
:
EnumTable
kAutocapitalizeTable
[
]
=
{
{
"
none
"
NS_AUTOCAPITALIZE_NONE
}
{
"
sentences
"
NS_AUTOCAPITALIZE_SENTENCES
}
{
"
words
"
NS_AUTOCAPITALIZE_WORDS
}
{
"
characters
"
NS_AUTOCAPITALIZE_CHARACTERS
}
{
"
off
"
NS_AUTOCAPITALIZE_NONE
}
{
"
on
"
NS_AUTOCAPITALIZE_SENTENCES
}
{
"
"
0
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
*
kDefaultAutocapitalize
=
&
kAutocapitalizeTable
[
1
]
;
nsresult
nsGenericHTMLElement
:
:
CopyInnerTo
(
Element
*
aDst
)
{
MOZ_ASSERT
(
!
aDst
-
>
GetUncomposedDoc
(
)
"
Should
not
CopyInnerTo
an
Element
in
a
document
"
)
;
auto
reparse
=
aDst
-
>
OwnerDoc
(
)
=
=
OwnerDoc
(
)
?
ReparseAttributes
:
:
No
:
ReparseAttributes
:
:
Yes
;
nsresult
rv
=
Element
:
:
CopyInnerTo
(
aDst
reparse
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsString
*
nonce
=
static_cast
<
nsString
*
>
(
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
nonce
)
{
static_cast
<
nsGenericHTMLElement
*
>
(
aDst
)
-
>
SetNonce
(
*
nonce
)
;
}
return
NS_OK
;
}
static
const
nsAttrValue
:
:
EnumTable
kDirTable
[
]
=
{
{
"
ltr
"
eDir_LTR
}
{
"
rtl
"
eDir_RTL
}
{
"
auto
"
eDir_Auto
}
{
nullptr
0
}
}
;
void
nsGenericHTMLElement
:
:
AddToNameTable
(
nsAtom
*
aName
)
{
MOZ_ASSERT
(
HasName
(
)
"
Node
doesn
'
t
have
name
?
"
)
;
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
doc
&
&
!
IsInNativeAnonymousSubtree
(
)
)
{
doc
-
>
AddToNameTable
(
this
aName
)
;
}
}
void
nsGenericHTMLElement
:
:
RemoveFromNameTable
(
)
{
if
(
HasName
(
)
&
&
CanHaveName
(
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
{
if
(
Document
*
doc
=
GetUncomposedDoc
(
)
)
{
doc
-
>
RemoveFromNameTable
(
this
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
)
;
}
}
}
void
nsGenericHTMLElement
:
:
GetAccessKeyLabel
(
nsString
&
aLabel
)
{
nsAutoString
suffix
;
GetAccessKey
(
suffix
)
;
if
(
!
suffix
.
IsEmpty
(
)
)
{
EventStateManager
:
:
GetAccessKeyLabelPrefix
(
this
aLabel
)
;
aLabel
.
Append
(
suffix
)
;
}
}
static
bool
IsOffsetParent
(
nsIFrame
*
aFrame
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
TableCell
|
|
frameType
=
=
LayoutFrameType
:
:
Table
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
return
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
table
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
;
}
return
false
;
}
struct
OffsetResult
{
Element
*
mParent
=
nullptr
;
CSSIntRect
mRect
;
}
;
static
OffsetResult
GetUnretargetedOffsetsFor
(
const
Element
&
aElement
)
{
nsIFrame
*
frame
=
aElement
.
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
{
}
;
}
nsIFrame
*
styleFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
frame
)
;
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
nsPoint
origin
(
0
0
)
;
nsIContent
*
offsetParent
=
nullptr
;
Element
*
docElement
=
aElement
.
GetComposedDoc
(
)
-
>
GetRootElement
(
)
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
content
&
&
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
content
=
=
docElement
)
)
{
parent
=
frame
;
}
else
{
const
bool
isPositioned
=
styleFrame
-
>
IsAbsPosContainingBlock
(
)
;
const
bool
isAbsolutelyPositioned
=
frame
-
>
IsAbsolutelyPositioned
(
)
;
origin
+
=
frame
-
>
GetPositionIgnoringScrolling
(
)
;
for
(
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
content
=
parent
-
>
GetContent
(
)
;
if
(
parent
-
>
IsAbsPosContainingBlock
(
)
)
{
offsetParent
=
content
;
break
;
}
const
bool
isOffsetParent
=
!
isPositioned
&
&
IsOffsetParent
(
parent
)
;
if
(
!
isOffsetParent
)
{
origin
+
=
parent
-
>
GetPositionIgnoringScrolling
(
)
;
}
if
(
content
)
{
if
(
content
=
=
docElement
)
{
break
;
}
if
(
isOffsetParent
|
|
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
offsetParent
=
content
;
break
;
}
}
}
if
(
isAbsolutelyPositioned
&
&
!
offsetParent
)
{
offsetParent
=
aElement
.
GetComposedDoc
(
)
-
>
GetBodyElement
(
)
;
}
}
if
(
parent
)
{
const
nsStyleBorder
*
border
=
parent
-
>
StyleBorder
(
)
;
origin
.
x
-
=
border
-
>
GetComputedBorderWidth
(
eSideLeft
)
;
origin
.
y
-
=
border
-
>
GetComputedBorderWidth
(
eSideTop
)
;
}
nsRect
rcFrame
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
frame
frame
)
;
rcFrame
.
MoveTo
(
origin
)
;
return
{
Element
:
:
FromNodeOrNull
(
offsetParent
)
CSSIntRect
:
:
FromAppUnitsRounded
(
rcFrame
)
}
;
}
static
bool
ShouldBeRetargeted
(
const
Element
&
aReferenceElement
const
Element
&
aElementToMaybeRetarget
)
{
ShadowRoot
*
shadow
=
aElementToMaybeRetarget
.
GetContainingShadow
(
)
;
if
(
!
shadow
)
{
return
false
;
}
for
(
ShadowRoot
*
scope
=
aReferenceElement
.
GetContainingShadow
(
)
;
scope
;
scope
=
scope
-
>
Host
(
)
-
>
GetContainingShadow
(
)
)
{
if
(
scope
=
=
shadow
)
{
return
false
;
}
}
return
true
;
}
Element
*
nsGenericHTMLElement
:
:
GetOffsetRect
(
CSSIntRect
&
aRect
)
{
aRect
=
CSSIntRect
(
)
;
if
(
!
GetPrimaryFrame
(
FlushType
:
:
Layout
)
)
{
return
nullptr
;
}
OffsetResult
thisResult
=
GetUnretargetedOffsetsFor
(
*
this
)
;
aRect
=
thisResult
.
mRect
;
Element
*
parent
=
thisResult
.
mParent
;
while
(
parent
&
&
ShouldBeRetargeted
(
*
this
*
parent
)
)
{
OffsetResult
result
=
GetUnretargetedOffsetsFor
(
*
parent
)
;
aRect
+
=
result
.
mRect
.
TopLeft
(
)
;
parent
=
result
.
mParent
;
}
return
parent
;
}
bool
nsGenericHTMLElement
:
:
Spellcheck
(
)
{
nsIContent
*
node
;
for
(
node
=
this
;
node
;
node
=
node
-
>
GetParent
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
)
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
_true
nsGkAtoms
:
:
_false
nullptr
}
;
switch
(
node
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
spellcheck
strings
eCaseMatters
)
)
{
case
0
:
return
true
;
case
1
:
return
false
;
}
}
}
if
(
IsEditable
(
)
)
{
return
true
;
}
if
(
nsContentUtils
:
:
IsChromeDoc
(
OwnerDoc
(
)
)
)
{
return
false
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryObject
(
this
)
;
if
(
!
formControl
)
{
return
false
;
}
auto
controlType
=
formControl
-
>
ControlType
(
)
;
if
(
controlType
=
=
FormControlType
:
:
Textarea
)
{
return
true
;
}
if
(
controlType
!
=
FormControlType
:
:
InputText
)
{
return
false
;
}
int32_t
spellcheckLevel
=
Preferences
:
:
GetInt
(
"
layout
.
spellcheckDefault
"
1
)
;
return
spellcheckLevel
=
=
2
;
}
bool
nsGenericHTMLElement
:
:
InNavQuirksMode
(
Document
*
aDoc
)
{
return
aDoc
&
&
aDoc
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
;
}
void
nsGenericHTMLElement
:
:
UpdateEditableState
(
bool
aNotify
)
{
ContentEditableTristate
value
=
GetContentEditableValue
(
)
;
if
(
value
!
=
eInherit
)
{
DoSetEditableFlag
(
!
!
value
aNotify
)
;
return
;
}
nsStyledElement
:
:
UpdateEditableState
(
aNotify
)
;
}
ElementState
nsGenericHTMLElement
:
:
IntrinsicState
(
)
const
{
ElementState
state
=
nsGenericHTMLElementBase
:
:
IntrinsicState
(
)
;
if
(
GetDirectionality
(
)
=
=
eDir_RTL
)
{
state
|
=
ElementState
:
:
RTL
;
state
&
=
~
ElementState
:
:
LTR
;
}
else
{
NS_ASSERTION
(
GetDirectionality
(
)
=
=
eDir_LTR
"
HTML
element
'
s
directionality
must
be
either
RTL
or
LTR
"
)
;
state
|
=
ElementState
:
:
LTR
;
state
&
=
~
ElementState
:
:
RTL
;
}
return
state
;
}
nsresult
nsGenericHTMLElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLElementBase
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsInComposedDoc
(
)
)
{
RegUnRegAccessKey
(
true
)
;
}
if
(
IsInUncomposedDoc
(
)
)
{
if
(
HasName
(
)
&
&
CanHaveName
(
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
{
aContext
.
OwnerDoc
(
)
.
AddToNameTable
(
this
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
)
;
}
}
if
(
HasFlag
(
NODE_IS_EDITABLE
)
&
&
GetContentEditableValue
(
)
=
=
eTrue
&
&
IsInComposedDoc
(
)
)
{
aContext
.
OwnerDoc
(
)
.
ChangeContentEditableCount
(
this
+
1
)
;
}
if
(
HasFlag
(
NODE_HAS_NONCE_AND_HEADER_CSP
)
&
&
IsInComposedDoc
(
)
&
&
OwnerDoc
(
)
-
>
GetBrowsingContext
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
nsGenericHTMLElement
:
:
ResetNonce
:
:
Runnable
"
[
self
=
RefPtr
<
nsGenericHTMLElement
>
(
this
)
]
(
)
{
nsAutoString
nonce
;
self
-
>
GetNonce
(
nonce
)
;
self
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
nonce
u
"
"
_ns
true
)
;
self
-
>
SetNonce
(
nonce
)
;
}
)
)
;
}
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
if
(
slots
&
&
slots
-
>
mLabelsList
)
{
slots
-
>
mLabelsList
-
>
MaybeResetRoot
(
SubtreeRoot
(
)
)
;
}
return
rv
;
}
void
nsGenericHTMLElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
if
(
IsInComposedDoc
(
)
)
{
RegUnRegAccessKey
(
false
)
;
}
RemoveFromNameTable
(
)
;
if
(
GetContentEditableValue
(
)
=
=
eTrue
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
doc
-
>
ChangeContentEditableCount
(
this
-
1
)
;
}
}
nsStyledElement
:
:
UnbindFromTree
(
aNullParent
)
;
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
if
(
slots
&
&
slots
-
>
mLabelsList
)
{
slots
-
>
mLabelsList
-
>
MaybeResetRoot
(
SubtreeRoot
(
)
)
;
}
}
HTMLFormElement
*
nsGenericHTMLElement
:
:
FindAncestorForm
(
HTMLFormElement
*
aCurrentForm
)
{
NS_ASSERTION
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
|
|
IsHTMLElement
(
nsGkAtoms
:
:
img
)
"
FindAncestorForm
should
not
be
called
if
form
is
set
!
"
)
;
if
(
IsInNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
this
;
while
(
content
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
)
{
#
ifdef
DEBUG
if
(
!
nsContentUtils
:
:
IsInSameAnonymousTree
(
this
content
)
)
{
for
(
nsIContent
*
child
=
this
;
child
!
=
content
;
child
=
child
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
child
-
>
ComputeIndexInParentContent
(
)
.
isSome
(
)
"
Walked
too
far
?
"
)
;
}
}
#
endif
return
static_cast
<
HTMLFormElement
*
>
(
content
)
;
}
nsIContent
*
prevContent
=
content
;
content
=
prevContent
-
>
GetParent
(
)
;
if
(
!
content
&
&
aCurrentForm
)
{
if
(
aCurrentForm
-
>
IsInclusiveDescendantOf
(
prevContent
)
)
{
return
aCurrentForm
;
}
}
}
return
nullptr
;
}
bool
nsGenericHTMLElement
:
:
CheckHandleEventForAnchorsPreconditions
(
EventChainVisitor
&
aVisitor
)
{
MOZ_ASSERT
(
nsCOMPtr
<
Link
>
(
do_QueryObject
(
this
)
)
"
should
be
called
only
when
|
this
|
implements
|
Link
|
"
)
;
return
IsInComposedDoc
(
)
|
|
IsHTMLElement
(
nsGkAtoms
:
:
a
)
;
}
void
nsGenericHTMLElement
:
:
GetEventTargetParentForAnchors
(
EventChainPreVisitor
&
aVisitor
)
{
nsGenericHTMLElementBase
:
:
GetEventTargetParent
(
aVisitor
)
;
if
(
!
CheckHandleEventForAnchorsPreconditions
(
aVisitor
)
)
{
return
;
}
GetEventTargetParentForLinks
(
aVisitor
)
;
}
nsresult
nsGenericHTMLElement
:
:
PostHandleEventForAnchors
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
!
CheckHandleEventForAnchorsPreconditions
(
aVisitor
)
)
{
return
NS_OK
;
}
return
PostHandleEventForLinks
(
aVisitor
)
;
}
bool
nsGenericHTMLElement
:
:
IsHTMLLink
(
nsIURI
*
*
aURI
)
const
{
MOZ_ASSERT
(
aURI
"
Must
provide
aURI
out
param
"
)
;
*
aURI
=
GetHrefURIForAnchors
(
)
.
take
(
)
;
return
*
aURI
!
=
nullptr
;
}
already_AddRefed
<
nsIURI
>
nsGenericHTMLElement
:
:
GetHrefURIForAnchors
(
)
const
{
nsCOMPtr
<
nsIURI
>
uri
;
GetURIAttr
(
nsGkAtoms
:
:
href
nullptr
getter_AddRefs
(
uri
)
)
;
return
uri
.
forget
(
)
;
}
nsresult
nsGenericHTMLElement
:
:
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
accesskey
)
{
RegUnRegAccessKey
(
false
)
;
if
(
!
aValue
)
{
UnsetFlags
(
NODE_HAS_ACCESSKEY
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
name
)
{
RemoveFromNameTable
(
)
;
if
(
!
aValue
|
|
aValue
-
>
IsEmpty
(
)
)
{
ClearHasName
(
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
contenteditable
)
{
if
(
aValue
)
{
SetMayHaveContentEditableAttr
(
)
;
}
}
if
(
!
aValue
&
&
IsEventAttributeName
(
aName
)
)
{
if
(
EventListenerManager
*
manager
=
GetExistingListenerManager
(
)
)
{
manager
-
>
RemoveEventHandler
(
GetEventNameForAttr
(
aName
)
)
;
}
}
}
return
nsGenericHTMLElementBase
:
:
BeforeSetAttr
(
aNamespaceID
aName
aValue
aNotify
)
;
}
nsresult
nsGenericHTMLElement
:
:
AfterSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
IsEventAttributeName
(
aName
)
&
&
aValue
)
{
MOZ_ASSERT
(
aValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eString
"
Expected
string
value
for
script
body
"
)
;
SetEventHandler
(
GetEventNameForAttr
(
aName
)
aValue
-
>
GetStringValue
(
)
)
;
}
else
if
(
aNotify
&
&
aName
=
=
nsGkAtoms
:
:
spellcheck
)
{
SyncEditorsOnSubtree
(
this
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
dir
)
{
Directionality
dir
=
eDir_LTR
;
bool
recomputeDirectionality
=
false
;
ElementState
dirStates
;
if
(
aValue
&
&
aValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
SetHasValidDir
(
)
;
dirStates
|
=
ElementState
:
:
HAS_DIR_ATTR
;
Directionality
dirValue
=
(
Directionality
)
aValue
-
>
GetEnumValue
(
)
;
if
(
dirValue
=
=
eDir_Auto
)
{
dirStates
|
=
ElementState
:
:
HAS_DIR_ATTR_LIKE_AUTO
;
}
else
{
dir
=
dirValue
;
SetDirectionality
(
dir
aNotify
)
;
if
(
dirValue
=
=
eDir_LTR
)
{
dirStates
|
=
ElementState
:
:
HAS_DIR_ATTR_LTR
;
}
else
{
MOZ_ASSERT
(
dirValue
=
=
eDir_RTL
)
;
dirStates
|
=
ElementState
:
:
HAS_DIR_ATTR_RTL
;
}
}
}
else
{
if
(
aValue
)
{
dirStates
|
=
ElementState
:
:
HAS_DIR_ATTR
;
}
ClearHasValidDir
(
)
;
if
(
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
bdi
)
)
{
dirStates
|
=
ElementState
:
:
HAS_DIR_ATTR_LIKE_AUTO
;
}
else
{
recomputeDirectionality
=
true
;
}
}
ElementState
oldDirStates
=
State
(
)
&
ElementState
:
:
DIR_ATTR_STATES
;
ElementState
changedStates
=
dirStates
^
oldDirStates
;
ToggleStates
(
changedStates
aNotify
)
;
if
(
recomputeDirectionality
)
{
dir
=
RecomputeDirectionality
(
this
aNotify
)
;
}
SetDirectionalityOnDescendants
(
this
dir
aNotify
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
contenteditable
)
{
int32_t
editableCountDelta
=
0
;
if
(
aOldValue
&
&
(
aOldValue
-
>
Equals
(
u
"
true
"
_ns
eIgnoreCase
)
|
|
aOldValue
-
>
Equals
(
u
"
"
_ns
eIgnoreCase
)
)
)
{
editableCountDelta
=
-
1
;
}
if
(
aValue
&
&
(
aValue
-
>
Equals
(
u
"
true
"
_ns
eIgnoreCase
)
|
|
aValue
-
>
Equals
(
u
"
"
_ns
eIgnoreCase
)
)
)
{
+
+
editableCountDelta
;
}
ChangeEditableState
(
editableCountDelta
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
accesskey
)
{
if
(
aValue
&
&
!
aValue
-
>
Equals
(
u
"
"
_ns
eIgnoreCase
)
)
{
SetFlags
(
NODE_HAS_ACCESSKEY
)
;
RegUnRegAccessKey
(
true
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
inert
&
&
StaticPrefs
:
:
html5_inert_enabled
(
)
)
{
if
(
aValue
)
{
AddStates
(
ElementState
:
:
INERT
)
;
}
else
{
RemoveStates
(
ElementState
:
:
INERT
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
name
)
{
if
(
aValue
&
&
!
aValue
-
>
Equals
(
u
"
"
_ns
eIgnoreCase
)
)
{
SetHasName
(
)
;
if
(
CanHaveName
(
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
{
AddToNameTable
(
aValue
-
>
GetAtomValue
(
)
)
;
}
}
}
else
if
(
(
aName
=
=
nsGkAtoms
:
:
inputmode
&
&
StaticPrefs
:
:
dom_forms_inputmode
(
)
)
|
|
(
aName
=
=
nsGkAtoms
:
:
enterkeyhint
&
&
StaticPrefs
:
:
dom_forms_enterkeyhint
(
)
)
)
{
nsPIDOMWindowOuter
*
window
=
OwnerDoc
(
)
-
>
GetWindow
(
)
;
if
(
window
&
&
window
-
>
GetFocusedElement
(
)
=
=
this
)
{
if
(
IMEContentObserver
*
observer
=
IMEStateManager
:
:
GetActiveContentObserver
(
)
)
{
if
(
const
nsPresContext
*
presContext
=
GetPresContext
(
eForComposedDoc
)
)
{
if
(
observer
-
>
IsManaging
(
*
presContext
this
)
)
{
if
(
RefPtr
<
EditorBase
>
editor
=
nsContentUtils
:
:
GetActiveEditor
(
window
)
)
{
IMEState
newState
;
editor
-
>
GetPreferredIMEState
(
&
newState
)
;
OwningNonNull
<
nsGenericHTMLElement
>
kungFuDeathGrip
(
*
this
)
;
IMEStateManager
:
:
UpdateIMEState
(
newState
kungFuDeathGrip
*
editor
{
IMEStateManager
:
:
UpdateIMEStateOption
:
:
ForceUpdate
IMEStateManager
:
:
UpdateIMEStateOption
:
:
DontCommitComposition
}
)
;
}
}
}
}
}
}
if
(
nsGkAtoms
:
:
nonce
=
=
aName
)
{
if
(
aValue
)
{
SetNonce
(
aValue
-
>
GetStringValue
(
)
)
;
if
(
OwnerDoc
(
)
-
>
GetHasCSPDeliveredThroughHeader
(
)
)
{
SetFlags
(
NODE_HAS_NONCE_AND_HEADER_CSP
)
;
}
}
else
{
RemoveNonce
(
)
;
}
}
}
return
nsGenericHTMLElementBase
:
:
AfterSetAttr
(
aNamespaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
EventListenerManager
*
nsGenericHTMLElement
:
:
GetEventListenerManagerForAttr
(
nsAtom
*
aAttrName
bool
*
aDefer
)
{
if
(
(
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
body
)
|
|
mNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
frameset
)
)
&
&
(
0
#
define
EVENT
(
name_
id_
type_
struct_
)
#
define
FORWARDED_EVENT
(
name_
id_
type_
struct_
)
\
|
|
nsGkAtoms
:
:
on
#
#
name_
=
=
aAttrName
#
define
WINDOW_EVENT
FORWARDED_EVENT
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
WINDOW_EVENT
#
undef
FORWARDED_EVENT
#
undef
EVENT
)
)
{
nsPIDOMWindowInner
*
win
;
Document
*
document
=
OwnerDoc
(
)
;
*
aDefer
=
false
;
if
(
(
win
=
document
-
>
GetInnerWindow
(
)
)
)
{
nsCOMPtr
<
EventTarget
>
piTarget
(
do_QueryInterface
(
win
)
)
;
return
piTarget
-
>
GetOrCreateListenerManager
(
)
;
}
return
nullptr
;
}
return
nsGenericHTMLElementBase
:
:
GetEventListenerManagerForAttr
(
aAttrName
aDefer
)
;
}
#
define
EVENT
(
name_
id_
type_
struct_
)
#
define
FORWARDED_EVENT
(
name_
id_
type_
struct_
)
\
EventHandlerNonNull
*
nsGenericHTMLElement
:
:
GetOn
#
#
name_
(
)
{
\
if
(
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
frameset
)
)
{
\
/
*
XXXbz
note
to
self
:
add
tests
for
this
!
*
/
\
if
(
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
{
\
nsGlobalWindowInner
*
globalWin
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
\
return
globalWin
-
>
GetOn
#
#
name_
(
)
;
\
}
\
return
nullptr
;
\
}
\
\
return
nsINode
:
:
GetOn
#
#
name_
(
)
;
\
}
\
void
nsGenericHTMLElement
:
:
SetOn
#
#
name_
(
EventHandlerNonNull
*
handler
)
{
\
if
(
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
frameset
)
)
{
\
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
\
if
(
!
win
)
{
\
return
;
\
}
\
\
nsGlobalWindowInner
*
globalWin
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
\
return
globalWin
-
>
SetOn
#
#
name_
(
handler
)
;
\
}
\
\
return
nsINode
:
:
SetOn
#
#
name_
(
handler
)
;
\
}
#
define
ERROR_EVENT
(
name_
id_
type_
struct_
)
\
already_AddRefed
<
EventHandlerNonNull
>
nsGenericHTMLElement
:
:
GetOn
#
#
name_
(
)
{
\
if
(
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
frameset
)
)
{
\
/
*
XXXbz
note
to
self
:
add
tests
for
this
!
*
/
\
if
(
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
{
\
nsGlobalWindowInner
*
globalWin
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
\
OnErrorEventHandlerNonNull
*
errorHandler
=
globalWin
-
>
GetOn
#
#
name_
(
)
;
\
if
(
errorHandler
)
{
\
RefPtr
<
EventHandlerNonNull
>
handler
=
\
new
EventHandlerNonNull
(
errorHandler
)
;
\
return
handler
.
forget
(
)
;
\
}
\
}
\
return
nullptr
;
\
}
\
\
RefPtr
<
EventHandlerNonNull
>
handler
=
nsINode
:
:
GetOn
#
#
name_
(
)
;
\
return
handler
.
forget
(
)
;
\
}
\
void
nsGenericHTMLElement
:
:
SetOn
#
#
name_
(
EventHandlerNonNull
*
handler
)
{
\
if
(
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
frameset
)
)
{
\
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
\
if
(
!
win
)
{
\
return
;
\
}
\
\
nsGlobalWindowInner
*
globalWin
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
\
RefPtr
<
OnErrorEventHandlerNonNull
>
errorHandler
;
\
if
(
handler
)
{
\
errorHandler
=
new
OnErrorEventHandlerNonNull
(
handler
)
;
\
}
\
return
globalWin
-
>
SetOn
#
#
name_
(
errorHandler
)
;
\
}
\
\
return
nsINode
:
:
SetOn
#
#
name_
(
handler
)
;
\
}
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
ERROR_EVENT
#
undef
FORWARDED_EVENT
#
undef
EVENT
void
nsGenericHTMLElement
:
:
GetBaseTarget
(
nsAString
&
aBaseTarget
)
const
{
OwnerDoc
(
)
-
>
GetBaseTarget
(
aBaseTarget
)
;
}
bool
nsGenericHTMLElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
dir
)
{
return
aResult
.
ParseEnumValue
(
aValue
kDirTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
tabindex
)
{
return
aResult
.
ParseIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
referrerpolicy
)
{
return
ParseReferrerAttribute
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
name
)
{
if
(
aValue
.
IsEmpty
(
)
)
{
return
false
;
}
aResult
.
ParseAtom
(
aValue
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
contenteditable
)
{
aResult
.
ParseAtom
(
aValue
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
rel
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
inputmode
)
{
return
aResult
.
ParseEnumValue
(
aValue
kInputmodeTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
enterkeyhint
)
{
return
aResult
.
ParseEnumValue
(
aValue
kEnterKeyHintTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
autocapitalize
)
{
return
aResult
.
ParseEnumValue
(
aValue
kAutocapitalizeTable
false
)
;
}
}
return
nsGenericHTMLElementBase
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
bool
nsGenericHTMLElement
:
:
ParseBackgroundAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
background
&
&
!
aValue
.
IsEmpty
(
)
)
{
Document
*
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
uri
)
aValue
doc
GetBaseURI
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
aResult
.
SetTo
(
uri
&
aValue
)
;
return
true
;
}
return
false
;
}
bool
nsGenericHTMLElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sCommonAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
nsGenericHTMLElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapCommonAttributesInto
;
}
nsIFormControlFrame
*
nsGenericHTMLElement
:
:
GetFormControlFrame
(
bool
aFlushFrames
)
{
auto
flushType
=
aFlushFrames
?
FlushType
:
:
Frames
:
FlushType
:
:
None
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
flushType
)
;
if
(
!
frame
)
{
return
nullptr
;
}
if
(
nsIFormControlFrame
*
f
=
do_QueryFrame
(
frame
)
)
{
return
f
;
}
for
(
nsIFrame
*
kid
:
frame
-
>
PrincipalChildList
(
)
)
{
if
(
nsIFormControlFrame
*
f
=
do_QueryFrame
(
kid
)
)
{
return
f
;
}
}
return
nullptr
;
}
static
const
nsAttrValue
:
:
EnumTable
kDivAlignTable
[
]
=
{
{
"
left
"
StyleTextAlign
:
:
MozLeft
}
{
"
right
"
StyleTextAlign
:
:
MozRight
}
{
"
center
"
StyleTextAlign
:
:
MozCenter
}
{
"
middle
"
StyleTextAlign
:
:
MozCenter
}
{
"
justify
"
StyleTextAlign
:
:
Justify
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kFrameborderTable
[
]
=
{
{
"
yes
"
NS_STYLE_FRAME_YES
}
{
"
no
"
NS_STYLE_FRAME_NO
}
{
"
1
"
NS_STYLE_FRAME_1
}
{
"
0
"
NS_STYLE_FRAME_0
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kScrollingTable
[
]
=
{
{
"
yes
"
NS_STYLE_FRAME_YES
}
{
"
no
"
NS_STYLE_FRAME_NO
}
{
"
on
"
NS_STYLE_FRAME_ON
}
{
"
off
"
NS_STYLE_FRAME_OFF
}
{
"
scroll
"
NS_STYLE_FRAME_SCROLL
}
{
"
noscroll
"
NS_STYLE_FRAME_NOSCROLL
}
{
"
auto
"
NS_STYLE_FRAME_AUTO
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kTableVAlignTable
[
]
=
{
{
"
top
"
StyleVerticalAlignKeyword
:
:
Top
}
{
"
middle
"
StyleVerticalAlignKeyword
:
:
Middle
}
{
"
bottom
"
StyleVerticalAlignKeyword
:
:
Bottom
}
{
"
baseline
"
StyleVerticalAlignKeyword
:
:
Baseline
}
{
nullptr
0
}
}
;
bool
nsGenericHTMLElement
:
:
ParseAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
static
const
nsAttrValue
:
:
EnumTable
kAlignTable
[
]
=
{
{
"
left
"
StyleTextAlign
:
:
Left
}
{
"
right
"
StyleTextAlign
:
:
Right
}
{
"
top
"
StyleVerticalAlignKeyword
:
:
Top
}
{
"
middle
"
StyleVerticalAlignKeyword
:
:
MozMiddleWithBaseline
}
{
"
bottom
"
StyleVerticalAlignKeyword
:
:
Baseline
}
{
"
center
"
StyleVerticalAlignKeyword
:
:
MozMiddleWithBaseline
}
{
"
baseline
"
StyleVerticalAlignKeyword
:
:
Baseline
}
{
"
texttop
"
StyleVerticalAlignKeyword
:
:
TextTop
}
{
"
absmiddle
"
StyleVerticalAlignKeyword
:
:
Middle
}
{
"
abscenter
"
StyleVerticalAlignKeyword
:
:
Middle
}
{
"
absbottom
"
StyleVerticalAlignKeyword
:
:
Bottom
}
{
nullptr
0
}
}
;
static_assert
(
uint8_t
(
StyleTextAlign
:
:
Left
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Top
)
&
&
uint8_t
(
StyleTextAlign
:
:
Left
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
MozMiddleWithBaseline
)
&
&
uint8_t
(
StyleTextAlign
:
:
Left
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Baseline
)
&
&
uint8_t
(
StyleTextAlign
:
:
Left
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
TextTop
)
&
&
uint8_t
(
StyleTextAlign
:
:
Left
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Middle
)
&
&
uint8_t
(
StyleTextAlign
:
:
Left
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Bottom
)
)
;
static_assert
(
uint8_t
(
StyleTextAlign
:
:
Right
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Top
)
&
&
uint8_t
(
StyleTextAlign
:
:
Right
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
MozMiddleWithBaseline
)
&
&
uint8_t
(
StyleTextAlign
:
:
Right
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Baseline
)
&
&
uint8_t
(
StyleTextAlign
:
:
Right
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
TextTop
)
&
&
uint8_t
(
StyleTextAlign
:
:
Right
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Middle
)
&
&
uint8_t
(
StyleTextAlign
:
:
Right
)
!
=
uint8_t
(
StyleVerticalAlignKeyword
:
:
Bottom
)
)
;
return
aResult
.
ParseEnumValue
(
aString
kAlignTable
false
)
;
}
static
const
nsAttrValue
:
:
EnumTable
kTableHAlignTable
[
]
=
{
{
"
left
"
StyleTextAlign
:
:
Left
}
{
"
right
"
StyleTextAlign
:
:
Right
}
{
"
center
"
StyleTextAlign
:
:
Center
}
{
"
char
"
StyleTextAlign
:
:
Char
}
{
"
justify
"
StyleTextAlign
:
:
Justify
}
{
nullptr
0
}
}
;
bool
nsGenericHTMLElement
:
:
ParseTableHAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
return
aResult
.
ParseEnumValue
(
aString
kTableHAlignTable
false
)
;
}
static
const
nsAttrValue
:
:
EnumTable
kTableCellHAlignTable
[
]
=
{
{
"
left
"
StyleTextAlign
:
:
MozLeft
}
{
"
right
"
StyleTextAlign
:
:
MozRight
}
{
"
center
"
StyleTextAlign
:
:
MozCenter
}
{
"
char
"
StyleTextAlign
:
:
Char
}
{
"
justify
"
StyleTextAlign
:
:
Justify
}
{
"
middle
"
StyleTextAlign
:
:
MozCenter
}
{
"
absmiddle
"
StyleTextAlign
:
:
Center
}
{
nullptr
0
}
}
;
bool
nsGenericHTMLElement
:
:
ParseTableCellHAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
return
aResult
.
ParseEnumValue
(
aString
kTableCellHAlignTable
false
)
;
}
bool
nsGenericHTMLElement
:
:
ParseTableVAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
return
aResult
.
ParseEnumValue
(
aString
kTableVAlignTable
false
)
;
}
bool
nsGenericHTMLElement
:
:
ParseDivAlignValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
return
aResult
.
ParseEnumValue
(
aString
kDivAlignTable
false
)
;
}
bool
nsGenericHTMLElement
:
:
ParseImageAttribute
(
nsAtom
*
aAttribute
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
|
|
aAttribute
=
=
nsGkAtoms
:
:
hspace
|
|
aAttribute
=
=
nsGkAtoms
:
:
vspace
)
{
return
aResult
.
ParseHTMLDimension
(
aString
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
border
)
{
return
aResult
.
ParseNonNegativeIntValue
(
aString
)
;
}
return
false
;
}
bool
nsGenericHTMLElement
:
:
ParseReferrerAttribute
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
using
mozilla
:
:
dom
:
:
ReferrerInfo
;
static
const
nsAttrValue
:
:
EnumTable
kReferrerPolicyTable
[
]
=
{
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
No_referrer
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
No_referrer
)
}
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
Origin
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
Origin
)
}
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
Origin_when_cross_origin
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
Origin_when_cross_origin
)
}
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
No_referrer_when_downgrade
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
No_referrer_when_downgrade
)
}
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
Unsafe_url
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
Unsafe_url
)
}
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
Strict_origin
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
Strict_origin
)
}
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
Same_origin
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
Same_origin
)
}
{
ReferrerInfo
:
:
ReferrerPolicyToString
(
ReferrerPolicy
:
:
Strict_origin_when_cross_origin
)
static_cast
<
int16_t
>
(
ReferrerPolicy
:
:
Strict_origin_when_cross_origin
)
}
{
nullptr
ReferrerPolicy
:
:
_empty
}
}
;
return
aResult
.
ParseEnumValue
(
aString
kReferrerPolicyTable
false
)
;
}
bool
nsGenericHTMLElement
:
:
ParseFrameborderValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
return
aResult
.
ParseEnumValue
(
aString
kFrameborderTable
false
)
;
}
bool
nsGenericHTMLElement
:
:
ParseScrollingValue
(
const
nsAString
&
aString
nsAttrValue
&
aResult
)
{
return
aResult
.
ParseEnumValue
(
aString
kScrollingTable
false
)
;
}
static
inline
void
MapLangAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
langValue
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
lang
)
;
if
(
!
langValue
)
{
return
;
}
MOZ_ASSERT
(
langValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
)
;
aDecls
.
SetIdentAtomValueIfUnset
(
eCSSProperty__x_lang
langValue
-
>
GetAtomValue
(
)
)
;
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_text_emphasis_position
)
)
{
const
nsAtom
*
lang
=
langValue
-
>
GetAtomValue
(
)
;
if
(
nsStyleUtil
:
:
MatchesLanguagePrefix
(
lang
u
"
zh
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_text_emphasis_position
NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT_ZH
)
;
}
else
if
(
nsStyleUtil
:
:
MatchesLanguagePrefix
(
lang
u
"
ja
"
)
|
|
nsStyleUtil
:
:
MatchesLanguagePrefix
(
lang
u
"
mn
"
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_text_emphasis_position
NS_STYLE_TEXT_EMPHASIS_POSITION_DEFAULT
)
;
}
}
}
void
nsGenericHTMLElement
:
:
MapCommonAttributesIntoExceptHidden
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty__moz_user_modify
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
contenteditable
)
;
if
(
value
)
{
if
(
value
-
>
Equals
(
nsGkAtoms
:
:
_empty
eCaseMatters
)
|
|
value
-
>
Equals
(
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty__moz_user_modify
StyleUserModify
:
:
ReadWrite
)
;
}
else
if
(
value
-
>
Equals
(
nsGkAtoms
:
:
_false
eIgnoreCase
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty__moz_user_modify
StyleUserModify
:
:
ReadOnly
)
;
}
}
}
MapLangAttributeInto
(
aAttributes
aDecls
)
;
}
void
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
MapCommonAttributesIntoExceptHidden
(
aAttributes
aDecls
)
;
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_display
)
)
{
if
(
aAttributes
-
>
IndexOfAttr
(
nsGkAtoms
:
:
hidden
)
>
=
0
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_display
StyleDisplay
:
:
None
)
;
}
}
}
const
nsGenericHTMLElement
:
:
MappedAttributeEntry
nsGenericHTMLElement
:
:
sCommonAttributeMap
[
]
=
{
{
nsGkAtoms
:
:
contenteditable
}
{
nsGkAtoms
:
:
lang
}
{
nsGkAtoms
:
:
hidden
}
{
nullptr
}
}
;
const
Element
:
:
MappedAttributeEntry
nsGenericHTMLElement
:
:
sImageMarginSizeAttributeMap
[
]
=
{
{
nsGkAtoms
:
:
width
}
{
nsGkAtoms
:
:
height
}
{
nsGkAtoms
:
:
hspace
}
{
nsGkAtoms
:
:
vspace
}
{
nullptr
}
}
;
const
Element
:
:
MappedAttributeEntry
nsGenericHTMLElement
:
:
sImageAlignAttributeMap
[
]
=
{
{
nsGkAtoms
:
:
align
}
{
nullptr
}
}
;
const
Element
:
:
MappedAttributeEntry
nsGenericHTMLElement
:
:
sDivAlignAttributeMap
[
]
=
{
{
nsGkAtoms
:
:
align
}
{
nullptr
}
}
;
const
Element
:
:
MappedAttributeEntry
nsGenericHTMLElement
:
:
sImageBorderAttributeMap
[
]
=
{
{
nsGkAtoms
:
:
border
}
{
nullptr
}
}
;
const
Element
:
:
MappedAttributeEntry
nsGenericHTMLElement
:
:
sBackgroundAttributeMap
[
]
=
{
{
nsGkAtoms
:
:
background
}
{
nsGkAtoms
:
:
bgcolor
}
{
nullptr
}
}
;
const
Element
:
:
MappedAttributeEntry
nsGenericHTMLElement
:
:
sBackgroundColorAttributeMap
[
]
=
{
{
nsGkAtoms
:
:
bgcolor
}
{
nullptr
}
}
;
void
nsGenericHTMLElement
:
:
MapImageAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
align
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
int32_t
align
=
value
-
>
GetEnumValue
(
)
;
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_float
)
)
{
if
(
align
=
=
uint8_t
(
StyleTextAlign
:
:
Left
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_float
StyleFloat
:
:
Left
)
;
}
else
if
(
align
=
=
uint8_t
(
StyleTextAlign
:
:
Right
)
)
{
aDecls
.
SetKeywordValue
(
eCSSProperty_float
StyleFloat
:
:
Right
)
;
}
}
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_vertical_align
)
)
{
switch
(
align
)
{
case
uint8_t
(
StyleTextAlign
:
:
Left
)
:
case
uint8_t
(
StyleTextAlign
:
:
Right
)
:
break
;
default
:
aDecls
.
SetKeywordValue
(
eCSSProperty_vertical_align
align
)
;
break
;
}
}
}
}
void
nsGenericHTMLElement
:
:
MapDivAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_text_align
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
align
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
aDecls
.
SetKeywordValue
(
eCSSProperty_text_align
value
-
>
GetEnumValue
(
)
)
;
}
}
void
nsGenericHTMLElement
:
:
MapVAlignAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_vertical_align
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
valign
)
;
if
(
value
&
&
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
aDecls
.
SetKeywordValue
(
eCSSProperty_vertical_align
value
-
>
GetEnumValue
(
)
)
;
}
}
static
void
MapDimensionAttributeInto
(
MappedDeclarations
&
aDecls
nsCSSPropertyID
aProp
const
nsAttrValue
&
aValue
)
{
MOZ_ASSERT
(
!
aDecls
.
PropertyIsSet
(
aProp
)
"
Why
mapping
the
same
property
twice
?
"
)
;
if
(
aValue
.
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
return
aDecls
.
SetPixelValue
(
aProp
aValue
.
GetIntegerValue
(
)
)
;
}
if
(
aValue
.
Type
(
)
=
=
nsAttrValue
:
:
ePercent
)
{
return
aDecls
.
SetPercentValue
(
aProp
aValue
.
GetPercentValue
(
)
)
;
}
if
(
aValue
.
Type
(
)
=
=
nsAttrValue
:
:
eDoubleValue
)
{
return
aDecls
.
SetPixelValue
(
aProp
aValue
.
GetDoubleValue
(
)
)
;
}
}
void
nsGenericHTMLElement
:
:
MapImageMarginAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
;
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
hspace
)
;
if
(
value
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_margin_left
*
value
)
;
MapDimensionAttributeInto
(
aDecls
eCSSProperty_margin_right
*
value
)
;
}
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
vspace
)
;
if
(
value
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_margin_top
*
value
)
;
MapDimensionAttributeInto
(
aDecls
eCSSProperty_margin_bottom
*
value
)
;
}
}
void
nsGenericHTMLElement
:
:
MapWidthAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
width
)
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_width
*
value
)
;
}
}
void
nsGenericHTMLElement
:
:
MapHeightAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
height
)
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_height
*
value
)
;
}
}
static
void
DoMapAspectRatio
(
const
nsAttrValue
&
aWidth
const
nsAttrValue
&
aHeight
MappedDeclarations
&
aDecls
)
{
Maybe
<
double
>
w
;
if
(
aWidth
.
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
w
.
emplace
(
aWidth
.
GetIntegerValue
(
)
)
;
}
else
if
(
aWidth
.
Type
(
)
=
=
nsAttrValue
:
:
eDoubleValue
)
{
w
.
emplace
(
aWidth
.
GetDoubleValue
(
)
)
;
}
Maybe
<
double
>
h
;
if
(
aHeight
.
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
h
.
emplace
(
aHeight
.
GetIntegerValue
(
)
)
;
}
else
if
(
aHeight
.
Type
(
)
=
=
nsAttrValue
:
:
eDoubleValue
)
{
h
.
emplace
(
aHeight
.
GetDoubleValue
(
)
)
;
}
if
(
w
&
&
h
)
{
aDecls
.
SetAspectRatio
(
*
w
*
h
)
;
}
}
void
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
MapAspectRatio
aMapAspectRatio
)
{
auto
*
width
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
width
)
;
auto
*
height
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
height
)
;
if
(
width
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_width
*
width
)
;
}
if
(
height
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_height
*
height
)
;
}
if
(
aMapAspectRatio
=
=
MapAspectRatio
:
:
Yes
&
&
width
&
&
height
)
{
DoMapAspectRatio
(
*
width
*
height
aDecls
)
;
}
}
void
nsGenericHTMLElement
:
:
MapPictureSourceSizeAttributesInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
auto
*
width
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
width
)
;
const
auto
*
height
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
height
)
;
if
(
!
width
&
&
!
height
)
{
return
;
}
if
(
width
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_width
*
width
)
;
}
else
{
aDecls
.
SetAutoValue
(
eCSSProperty_width
)
;
}
if
(
height
)
{
MapDimensionAttributeInto
(
aDecls
eCSSProperty_height
*
height
)
;
}
else
{
aDecls
.
SetAutoValue
(
eCSSProperty_height
)
;
}
if
(
width
&
&
height
)
{
DoMapAspectRatio
(
*
width
*
height
aDecls
)
;
}
else
{
aDecls
.
SetAutoValue
(
eCSSProperty_aspect_ratio
)
;
}
}
void
nsGenericHTMLElement
:
:
MapAspectRatioInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
auto
*
width
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
width
)
;
auto
*
height
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
height
)
;
if
(
width
&
&
height
)
{
DoMapAspectRatio
(
*
width
*
height
aDecls
)
;
}
}
void
nsGenericHTMLElement
:
:
MapImageBorderAttributeInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
border
)
;
if
(
!
value
)
return
;
nscoord
val
=
0
;
if
(
value
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
val
=
value
-
>
GetIntegerValue
(
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_top_width
(
float
)
val
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_right_width
(
float
)
val
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_bottom_width
(
float
)
val
)
;
aDecls
.
SetPixelValueIfUnset
(
eCSSProperty_border_left_width
(
float
)
val
)
;
aDecls
.
SetKeywordValueIfUnset
(
eCSSProperty_border_top_style
StyleBorderStyle
:
:
Solid
)
;
aDecls
.
SetKeywordValueIfUnset
(
eCSSProperty_border_right_style
StyleBorderStyle
:
:
Solid
)
;
aDecls
.
SetKeywordValueIfUnset
(
eCSSProperty_border_bottom_style
StyleBorderStyle
:
:
Solid
)
;
aDecls
.
SetKeywordValueIfUnset
(
eCSSProperty_border_left_style
StyleBorderStyle
:
:
Solid
)
;
aDecls
.
SetCurrentColorIfUnset
(
eCSSProperty_border_top_color
)
;
aDecls
.
SetCurrentColorIfUnset
(
eCSSProperty_border_right_color
)
;
aDecls
.
SetCurrentColorIfUnset
(
eCSSProperty_border_bottom_color
)
;
aDecls
.
SetCurrentColorIfUnset
(
eCSSProperty_border_left_color
)
;
}
void
nsGenericHTMLElement
:
:
MapBackgroundInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_background_image
)
)
{
nsAttrValue
*
value
=
const_cast
<
nsAttrValue
*
>
(
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
background
)
)
;
if
(
value
)
{
aDecls
.
SetBackgroundImage
(
*
value
)
;
}
}
}
void
nsGenericHTMLElement
:
:
MapBGColorInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
if
(
!
aDecls
.
PropertyIsSet
(
eCSSProperty_background_color
)
)
{
const
nsAttrValue
*
value
=
aAttributes
-
>
GetAttr
(
nsGkAtoms
:
:
bgcolor
)
;
nscolor
color
;
if
(
value
&
&
value
-
>
GetColorValue
(
color
)
)
{
aDecls
.
SetColorValue
(
eCSSProperty_background_color
color
)
;
}
}
}
void
nsGenericHTMLElement
:
:
MapBackgroundAttributesInto
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
MapBackgroundInto
(
aAttributes
aDecls
)
;
MapBGColorInto
(
aAttributes
aDecls
)
;
}
int32_t
nsGenericHTMLElement
:
:
GetIntAttr
(
nsAtom
*
aAttr
int32_t
aDefault
)
const
{
const
nsAttrValue
*
attrVal
=
mAttrs
.
GetAttr
(
aAttr
)
;
if
(
attrVal
&
&
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
return
attrVal
-
>
GetIntegerValue
(
)
;
}
return
aDefault
;
}
nsresult
nsGenericHTMLElement
:
:
SetIntAttr
(
nsAtom
*
aAttr
int32_t
aValue
)
{
nsAutoString
value
;
value
.
AppendInt
(
aValue
)
;
return
SetAttr
(
kNameSpaceID_None
aAttr
value
true
)
;
}
uint32_t
nsGenericHTMLElement
:
:
GetUnsignedIntAttr
(
nsAtom
*
aAttr
uint32_t
aDefault
)
const
{
const
nsAttrValue
*
attrVal
=
mAttrs
.
GetAttr
(
aAttr
)
;
if
(
!
attrVal
|
|
attrVal
-
>
Type
(
)
!
=
nsAttrValue
:
:
eInteger
)
{
return
aDefault
;
}
return
attrVal
-
>
GetIntegerValue
(
)
;
}
uint32_t
nsGenericHTMLElement
:
:
GetDimensionAttrAsUnsignedInt
(
nsAtom
*
aAttr
uint32_t
aDefault
)
const
{
const
nsAttrValue
*
attrVal
=
mAttrs
.
GetAttr
(
aAttr
)
;
if
(
!
attrVal
)
{
return
aDefault
;
}
if
(
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
return
attrVal
-
>
GetIntegerValue
(
)
;
}
if
(
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
ePercent
)
{
return
uint32_t
(
attrVal
-
>
GetPercentValue
(
)
*
100
.
0f
)
;
}
if
(
attrVal
-
>
Type
(
)
=
=
nsAttrValue
:
:
eDoubleValue
)
{
return
uint32_t
(
attrVal
-
>
GetDoubleValue
(
)
)
;
}
nsAutoString
val
;
attrVal
-
>
ToString
(
val
)
;
nsContentUtils
:
:
ParseHTMLIntegerResultFlags
result
;
int32_t
parsedInt
=
nsContentUtils
:
:
ParseHTMLInteger
(
val
&
result
)
;
if
(
(
result
&
nsContentUtils
:
:
eParseHTMLInteger_Error
)
|
|
parsedInt
<
0
)
{
return
aDefault
;
}
return
parsedInt
;
}
void
nsGenericHTMLElement
:
:
GetURIAttr
(
nsAtom
*
aAttr
nsAtom
*
aBaseAttr
nsAString
&
aResult
)
const
{
nsCOMPtr
<
nsIURI
>
uri
;
bool
hadAttr
=
GetURIAttr
(
aAttr
aBaseAttr
getter_AddRefs
(
uri
)
)
;
if
(
!
hadAttr
)
{
aResult
.
Truncate
(
)
;
return
;
}
if
(
!
uri
)
{
GetAttr
(
kNameSpaceID_None
aAttr
aResult
)
;
return
;
}
nsAutoCString
spec
;
uri
-
>
GetSpec
(
spec
)
;
CopyUTF8toUTF16
(
spec
aResult
)
;
}
bool
nsGenericHTMLElement
:
:
GetURIAttr
(
nsAtom
*
aAttr
nsAtom
*
aBaseAttr
nsIURI
*
*
aURI
)
const
{
*
aURI
=
nullptr
;
const
nsAttrValue
*
attr
=
mAttrs
.
GetAttr
(
aAttr
)
;
if
(
!
attr
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
baseURI
=
GetBaseURI
(
)
;
if
(
aBaseAttr
)
{
nsAutoString
baseAttrValue
;
if
(
GetAttr
(
kNameSpaceID_None
aBaseAttr
baseAttrValue
)
)
{
nsCOMPtr
<
nsIURI
>
baseAttrURI
;
nsresult
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
baseAttrURI
)
baseAttrValue
OwnerDoc
(
)
baseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
true
;
}
baseURI
.
swap
(
baseAttrURI
)
;
}
}
nsContentUtils
:
:
NewURIWithDocumentCharset
(
aURI
attr
-
>
GetStringValue
(
)
OwnerDoc
(
)
baseURI
)
;
return
true
;
}
bool
nsGenericHTMLElement
:
:
IsLabelable
(
)
const
{
return
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
meter
)
;
}
bool
nsGenericHTMLElement
:
:
MatchLabelsElement
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
HTMLLabelElement
*
element
=
HTMLLabelElement
:
:
FromNode
(
aElement
)
;
return
element
&
&
element
-
>
GetControl
(
)
=
=
aData
;
}
already_AddRefed
<
nsINodeList
>
nsGenericHTMLElement
:
:
Labels
(
)
{
MOZ_ASSERT
(
IsLabelable
(
)
"
Labels
(
)
only
allow
labelable
elements
to
use
it
.
"
)
;
nsExtendedDOMSlots
*
slots
=
ExtendedDOMSlots
(
)
;
if
(
!
slots
-
>
mLabelsList
)
{
slots
-
>
mLabelsList
=
new
nsLabelsNodeList
(
SubtreeRoot
(
)
MatchLabelsElement
nullptr
this
)
;
}
RefPtr
<
nsLabelsNodeList
>
labels
=
slots
-
>
mLabelsList
;
return
labels
.
forget
(
)
;
}
bool
nsGenericHTMLElement
:
:
LegacyTouchAPIEnabled
(
JSContext
*
aCx
JSObject
*
aGlobal
)
{
return
TouchEvent
:
:
LegacyAPIEnabled
(
aCx
aGlobal
)
;
}
bool
nsGenericHTMLElement
:
:
IsFormControlDefaultFocusable
(
bool
aWithMouse
)
const
{
if
(
!
aWithMouse
)
{
return
true
;
}
switch
(
StaticPrefs
:
:
accessibility_mouse_focuses_formcontrol
(
)
)
{
case
0
:
return
false
;
case
1
:
return
true
;
default
:
return
!
IsInChromeDocument
(
)
;
}
}
nsGenericHTMLFormElement
:
:
nsGenericHTMLFormElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsGenericHTMLElement
(
std
:
:
move
(
aNodeInfo
)
)
{
}
void
nsGenericHTMLFormElement
:
:
ClearForm
(
bool
aRemoveFromForm
bool
aUnbindOrDelete
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
HTMLFormElement
*
form
=
GetFormInternal
(
)
;
NS_ASSERTION
(
(
form
!
=
nullptr
)
=
=
HasFlag
(
ADDED_TO_FORM
)
"
Form
control
should
have
had
flag
set
correctly
"
)
;
if
(
!
form
)
{
return
;
}
if
(
aRemoveFromForm
)
{
nsAutoString
nameVal
idVal
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nameVal
)
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
idVal
)
;
form
-
>
RemoveElement
(
this
true
)
;
if
(
!
nameVal
.
IsEmpty
(
)
)
{
form
-
>
RemoveElementFromTable
(
this
nameVal
)
;
}
if
(
!
idVal
.
IsEmpty
(
)
)
{
form
-
>
RemoveElementFromTable
(
this
idVal
)
;
}
}
UnsetFlags
(
ADDED_TO_FORM
)
;
SetFormInternal
(
nullptr
false
)
;
AfterClearForm
(
aUnbindOrDelete
)
;
}
nsresult
nsGenericHTMLFormElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsFormAssociatedElement
(
)
)
{
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
?
IsInComposedDoc
(
)
:
aParent
.
IsContent
(
)
)
{
UpdateFormOwner
(
true
nullptr
)
;
}
}
UpdateFieldSet
(
false
)
;
return
NS_OK
;
}
void
nsGenericHTMLFormElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
if
(
IsFormAssociatedElement
(
)
)
{
if
(
HTMLFormElement
*
form
=
GetFormInternal
(
)
)
{
if
(
aNullParent
)
{
ClearForm
(
true
true
)
;
}
else
{
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
|
|
!
FindAncestorForm
(
form
)
)
{
ClearForm
(
true
true
)
;
}
else
{
UnsetFlags
(
MAYBE_ORPHAN_FORM_ELEMENT
)
;
}
}
if
(
!
GetFormInternal
(
)
)
{
UpdateState
(
false
)
;
}
}
if
(
nsContentUtils
:
:
HasNonEmptyAttr
(
this
kNameSpaceID_None
nsGkAtoms
:
:
form
)
)
{
RemoveFormIdObserver
(
)
;
}
}
nsGenericHTMLElement
:
:
UnbindFromTree
(
aNullParent
)
;
UpdateFieldSet
(
false
)
;
}
nsresult
nsGenericHTMLFormElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
IsFormAssociatedElement
(
)
)
{
nsAutoString
tmp
;
HTMLFormElement
*
form
=
GetFormInternal
(
)
;
if
(
form
&
&
(
aName
=
=
nsGkAtoms
:
:
name
|
|
aName
=
=
nsGkAtoms
:
:
id
)
)
{
GetAttr
(
kNameSpaceID_None
aName
tmp
)
;
if
(
!
tmp
.
IsEmpty
(
)
)
{
form
-
>
RemoveElementFromTable
(
this
tmp
)
;
}
}
if
(
form
&
&
aName
=
=
nsGkAtoms
:
:
type
)
{
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
tmp
)
;
if
(
!
tmp
.
IsEmpty
(
)
)
{
form
-
>
RemoveElementFromTable
(
this
tmp
)
;
}
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
tmp
)
;
if
(
!
tmp
.
IsEmpty
(
)
)
{
form
-
>
RemoveElementFromTable
(
this
tmp
)
;
}
form
-
>
RemoveElement
(
this
false
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
form
)
{
if
(
nsContentUtils
:
:
HasNonEmptyAttr
(
this
kNameSpaceID_None
nsGkAtoms
:
:
form
)
)
{
RemoveFormIdObserver
(
)
;
}
}
}
return
nsGenericHTMLElement
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
nsresult
nsGenericHTMLFormElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
IsFormAssociatedElement
(
)
)
{
HTMLFormElement
*
form
=
GetFormInternal
(
)
;
if
(
form
&
&
(
aName
=
=
nsGkAtoms
:
:
name
|
|
aName
=
=
nsGkAtoms
:
:
id
)
&
&
aValue
&
&
!
aValue
-
>
IsEmptyString
(
)
)
{
MOZ_ASSERT
(
aValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
"
Expected
atom
value
for
name
/
id
"
)
;
form
-
>
AddElementToTable
(
this
nsDependentAtomString
(
aValue
-
>
GetAtomValue
(
)
)
)
;
}
if
(
form
&
&
aName
=
=
nsGkAtoms
:
:
type
)
{
nsAutoString
tmp
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
tmp
)
;
if
(
!
tmp
.
IsEmpty
(
)
)
{
form
-
>
AddElementToTable
(
this
tmp
)
;
}
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
tmp
)
;
if
(
!
tmp
.
IsEmpty
(
)
)
{
form
-
>
AddElementToTable
(
this
tmp
)
;
}
form
-
>
AddElement
(
this
false
aNotify
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
form
)
{
DocumentOrShadowRoot
*
docOrShadow
=
GetUncomposedDocOrConnectedShadowRoot
(
)
;
if
(
docOrShadow
)
{
Element
*
formIdElement
=
nullptr
;
if
(
aValue
&
&
!
aValue
-
>
IsEmptyString
(
)
)
{
formIdElement
=
AddFormIdObserver
(
)
;
}
UpdateFormOwner
(
false
formIdElement
)
;
}
}
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
void
nsGenericHTMLFormElement
:
:
ForgetFieldSet
(
nsIContent
*
aFieldset
)
{
if
(
IsFormAssociatedElement
(
)
&
&
GetFieldSetInternal
(
)
=
=
aFieldset
)
{
SetFieldSetInternal
(
nullptr
)
;
}
}
Element
*
nsGenericHTMLFormElement
:
:
AddFormIdObserver
(
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
nsAutoString
formId
;
DocumentOrShadowRoot
*
docOrShadow
=
GetUncomposedDocOrConnectedShadowRoot
(
)
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
formId
)
;
NS_ASSERTION
(
!
formId
.
IsEmpty
(
)
"
form
value
should
not
be
the
empty
string
!
"
)
;
RefPtr
<
nsAtom
>
atom
=
NS_Atomize
(
formId
)
;
return
docOrShadow
-
>
AddIDTargetObserver
(
atom
FormIdUpdated
this
false
)
;
}
void
nsGenericHTMLFormElement
:
:
RemoveFormIdObserver
(
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
DocumentOrShadowRoot
*
docOrShadow
=
GetUncomposedDocOrConnectedShadowRoot
(
)
;
if
(
!
docOrShadow
)
{
return
;
}
nsAutoString
formId
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
formId
)
;
NS_ASSERTION
(
!
formId
.
IsEmpty
(
)
"
form
value
should
not
be
the
empty
string
!
"
)
;
RefPtr
<
nsAtom
>
atom
=
NS_Atomize
(
formId
)
;
docOrShadow
-
>
RemoveIDTargetObserver
(
atom
FormIdUpdated
this
false
)
;
}
bool
nsGenericHTMLFormElement
:
:
FormIdUpdated
(
Element
*
aOldElement
Element
*
aNewElement
void
*
aData
)
{
nsGenericHTMLFormElement
*
element
=
static_cast
<
nsGenericHTMLFormElement
*
>
(
aData
)
;
NS_ASSERTION
(
element
-
>
IsHTMLElement
(
)
"
aData
should
be
an
HTML
element
"
)
;
element
-
>
UpdateFormOwner
(
false
aNewElement
)
;
return
true
;
}
bool
nsGenericHTMLFormElement
:
:
IsElementDisabledForEvents
(
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aEvent
)
;
if
(
!
aEvent
-
>
IsTrusted
(
)
)
{
return
false
;
}
switch
(
aEvent
-
>
mMessage
)
{
case
eAnimationStart
:
case
eAnimationEnd
:
case
eAnimationIteration
:
case
eAnimationCancel
:
case
eFormChange
:
case
eMouseMove
:
case
eMouseOver
:
case
eMouseOut
:
case
eMouseEnter
:
case
eMouseLeave
:
case
ePointerMove
:
case
ePointerOver
:
case
ePointerOut
:
case
ePointerEnter
:
case
ePointerLeave
:
case
eTransitionCancel
:
case
eTransitionEnd
:
case
eTransitionRun
:
case
eTransitionStart
:
case
eWheel
:
case
eLegacyMouseLineOrPageScroll
:
case
eLegacyMousePixelScroll
:
return
false
;
default
:
break
;
}
if
(
aEvent
-
>
mSpecifiedEventType
=
=
nsGkAtoms
:
:
oninput
)
{
return
false
;
}
if
(
aFrame
&
&
aFrame
-
>
StyleUI
(
)
-
>
UserInput
(
)
=
=
StyleUserInput
:
:
None
)
{
return
true
;
}
return
IsDisabled
(
)
;
}
void
nsGenericHTMLFormElement
:
:
UpdateFormOwner
(
bool
aBindToTree
Element
*
aFormIdElement
)
{
MOZ_ASSERT
(
IsFormAssociatedElement
(
)
)
;
MOZ_ASSERT
(
!
aBindToTree
|
|
!
aFormIdElement
"
aFormIdElement
shouldn
'
t
be
set
if
aBindToTree
is
true
!
"
)
;
bool
needStateUpdate
=
false
;
if
(
!
aBindToTree
)
{
HTMLFormElement
*
form
=
GetFormInternal
(
)
;
needStateUpdate
=
form
&
&
form
-
>
IsDefaultSubmitElement
(
this
)
;
ClearForm
(
true
false
)
;
}
HTMLFormElement
*
oldForm
=
GetFormInternal
(
)
;
if
(
!
oldForm
)
{
nsAutoString
formId
;
if
(
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
formId
)
)
{
if
(
!
formId
.
IsEmpty
(
)
)
{
Element
*
element
=
nullptr
;
if
(
aBindToTree
)
{
element
=
AddFormIdObserver
(
)
;
}
else
{
element
=
aFormIdElement
;
}
NS_ASSERTION
(
!
IsInComposedDoc
(
)
|
|
element
=
=
GetUncomposedDocOrConnectedShadowRoot
(
)
-
>
GetElementById
(
formId
)
"
element
should
be
equals
to
the
current
element
"
"
associated
with
the
id
in
form
!
"
)
;
if
(
element
&
&
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
form
)
&
&
nsContentUtils
:
:
IsInSameAnonymousTree
(
this
element
)
)
{
SetFormInternal
(
static_cast
<
HTMLFormElement
*
>
(
element
)
aBindToTree
)
;
}
}
}
else
{
SetFormInternal
(
FindAncestorForm
(
)
aBindToTree
)
;
}
}
HTMLFormElement
*
form
=
GetFormInternal
(
)
;
if
(
form
&
&
!
HasFlag
(
ADDED_TO_FORM
)
)
{
nsAutoString
nameVal
idVal
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nameVal
)
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
idVal
)
;
SetFlags
(
ADDED_TO_FORM
)
;
form
-
>
AddElement
(
this
true
oldForm
=
=
nullptr
)
;
if
(
!
nameVal
.
IsEmpty
(
)
)
{
form
-
>
AddElementToTable
(
this
nameVal
)
;
}
if
(
!
idVal
.
IsEmpty
(
)
)
{
form
-
>
AddElementToTable
(
this
idVal
)
;
}
}
if
(
form
!
=
oldForm
|
|
needStateUpdate
)
{
UpdateState
(
true
)
;
}
}
void
nsGenericHTMLFormElement
:
:
UpdateFieldSet
(
bool
aNotify
)
{
if
(
IsInNativeAnonymousSubtree
(
)
|
|
!
IsFormAssociatedElement
(
)
)
{
MOZ_ASSERT_IF
(
IsFormAssociatedElement
(
)
!
GetFieldSetInternal
(
)
)
;
return
;
}
nsIContent
*
parent
=
nullptr
;
nsIContent
*
prev
=
nullptr
;
HTMLFieldSetElement
*
fieldset
=
GetFieldSetInternal
(
)
;
for
(
parent
=
GetParent
(
)
;
parent
;
prev
=
parent
parent
=
parent
-
>
GetParent
(
)
)
{
HTMLFieldSetElement
*
parentFieldset
=
HTMLFieldSetElement
:
:
FromNode
(
parent
)
;
if
(
parentFieldset
&
&
(
!
prev
|
|
parentFieldset
-
>
GetFirstLegend
(
)
!
=
prev
)
)
{
if
(
fieldset
=
=
parentFieldset
)
{
return
;
}
if
(
fieldset
)
{
fieldset
-
>
RemoveElement
(
this
)
;
}
SetFieldSetInternal
(
parentFieldset
)
;
parentFieldset
-
>
AddElement
(
this
)
;
FieldSetDisabledChanged
(
aNotify
)
;
return
;
}
}
if
(
fieldset
)
{
fieldset
-
>
RemoveElement
(
this
)
;
SetFieldSetInternal
(
nullptr
)
;
FieldSetDisabledChanged
(
aNotify
)
;
}
}
void
nsGenericHTMLFormElement
:
:
UpdateDisabledState
(
bool
aNotify
)
{
if
(
!
CanBeDisabled
(
)
)
{
return
;
}
HTMLFieldSetElement
*
fieldset
=
GetFieldSetInternal
(
)
;
const
bool
isDisabled
=
HasAttr
(
nsGkAtoms
:
:
disabled
)
|
|
(
fieldset
&
&
fieldset
-
>
IsDisabled
(
)
)
;
const
ElementState
disabledStates
=
isDisabled
?
ElementState
:
:
DISABLED
:
ElementState
:
:
ENABLED
;
ElementState
oldDisabledStates
=
State
(
)
&
ElementState
:
:
DISABLED_STATES
;
ElementState
changedStates
=
disabledStates
^
oldDisabledStates
;
if
(
!
changedStates
.
IsEmpty
(
)
)
{
ToggleStates
(
changedStates
aNotify
)
;
if
(
DoesReadOnlyApply
(
)
)
{
UpdateState
(
aNotify
)
;
}
}
}
void
nsGenericHTMLFormElement
:
:
FieldSetDisabledChanged
(
bool
aNotify
)
{
UpdateDisabledState
(
aNotify
)
;
}
void
nsGenericHTMLElement
:
:
Click
(
CallerType
aCallerType
)
{
if
(
IsDisabled
(
)
|
|
HandlingClick
(
)
)
{
return
;
}
nsCOMPtr
<
Document
>
doc
=
GetComposedDoc
(
)
;
RefPtr
<
nsPresContext
>
context
;
if
(
doc
)
{
context
=
doc
-
>
GetPresContext
(
)
;
}
SetHandlingClick
(
)
;
WidgetMouseEvent
event
(
aCallerType
=
=
CallerType
:
:
System
eMouseClick
nullptr
WidgetMouseEvent
:
:
eReal
)
;
event
.
mFlags
.
mIsPositionless
=
true
;
event
.
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_UNKNOWN
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
context
&
event
)
;
ClearHandlingClick
(
)
;
}
bool
nsGenericHTMLElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
ShadowRoot
*
root
=
GetShadowRoot
(
)
)
{
if
(
root
-
>
DelegatesFocus
(
)
)
{
*
aIsFocusable
=
false
;
return
true
;
}
}
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
|
|
IsInDesignMode
(
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
*
aIsFocusable
=
false
;
return
true
;
}
int32_t
tabIndex
=
TabIndex
(
)
;
bool
disabled
=
false
;
bool
disallowOverridingFocusability
=
true
;
Maybe
<
int32_t
>
attrVal
=
GetTabIndexAttrValue
(
)
;
if
(
IsEditableRoot
(
)
)
{
disallowOverridingFocusability
=
true
;
if
(
attrVal
.
isNothing
(
)
)
{
tabIndex
=
0
;
}
}
else
{
disallowOverridingFocusability
=
false
;
disabled
=
IsDisabled
(
)
;
if
(
disabled
)
{
tabIndex
=
-
1
;
}
}
if
(
aTabIndex
)
{
*
aTabIndex
=
tabIndex
;
}
*
aIsFocusable
=
(
tabIndex
>
=
0
|
|
(
!
disabled
&
&
attrVal
.
isSome
(
)
)
)
;
return
disallowOverridingFocusability
;
}
Result
<
bool
nsresult
>
nsGenericHTMLElement
:
:
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
eForComposedDoc
)
;
if
(
!
presContext
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
bool
focused
=
true
;
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
fm
-
>
SetFocus
(
this
nsIFocusManager
:
:
FLAG_BYKEY
)
;
nsPIDOMWindowOuter
*
window
=
OwnerDoc
(
)
-
>
GetWindow
(
)
;
focused
=
window
&
&
window
-
>
GetFocusedElement
(
)
=
=
this
;
}
if
(
aKeyCausesActivation
)
{
AutoHandlingUserInputStatePusher
userInputStatePusher
(
aIsTrustedEvent
)
;
AutoPopupStatePusher
popupStatePusher
(
aIsTrustedEvent
?
PopupBlocker
:
:
openAllowed
:
PopupBlocker
:
:
openAbused
)
;
DispatchSimulatedClick
(
this
aIsTrustedEvent
presContext
)
;
return
focused
;
}
return
focused
?
Result
<
bool
nsresult
>
{
focused
}
:
Err
(
NS_ERROR_ABORT
)
;
}
void
nsGenericHTMLElement
:
:
HandleKeyboardActivation
(
EventChainPostVisitor
&
aVisitor
)
{
const
auto
message
=
aVisitor
.
mEvent
-
>
mMessage
;
if
(
message
!
=
eKeyDown
&
&
message
!
=
eKeyUp
&
&
message
!
=
eKeyPress
)
{
return
;
}
const
WidgetKeyboardEvent
*
keyEvent
=
aVisitor
.
mEvent
-
>
AsKeyboardEvent
(
)
;
if
(
nsEventStatus_eIgnore
!
=
aVisitor
.
mEventStatus
)
{
if
(
message
=
=
eKeyUp
&
&
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
)
{
UnsetFlags
(
HTML_ELEMENT_ACTIVE_FOR_KEYBOARD
)
;
}
return
;
}
bool
shouldActivate
=
false
;
switch
(
message
)
{
case
eKeyDown
:
if
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
)
{
SetFlags
(
HTML_ELEMENT_ACTIVE_FOR_KEYBOARD
)
;
}
return
;
case
eKeyPress
:
shouldActivate
=
keyEvent
-
>
mKeyCode
=
=
NS_VK_RETURN
;
if
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
)
{
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
break
;
case
eKeyUp
:
shouldActivate
=
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
&
&
HasFlag
(
HTML_ELEMENT_ACTIVE_FOR_KEYBOARD
)
;
if
(
shouldActivate
)
{
UnsetFlags
(
HTML_ELEMENT_ACTIVE_FOR_KEYBOARD
)
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
why
didn
'
t
we
bail
out
earlier
?
"
)
;
break
;
}
if
(
!
shouldActivate
)
{
return
;
}
RefPtr
<
nsPresContext
>
presContext
=
aVisitor
.
mPresContext
;
DispatchSimulatedClick
(
this
aVisitor
.
mEvent
-
>
IsTrusted
(
)
presContext
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
nsresult
nsGenericHTMLElement
:
:
DispatchSimulatedClick
(
nsGenericHTMLElement
*
aElement
bool
aIsTrusted
nsPresContext
*
aPresContext
)
{
WidgetMouseEvent
event
(
aIsTrusted
eMouseClick
nullptr
WidgetMouseEvent
:
:
eReal
)
;
event
.
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_KEYBOARD
;
event
.
mFlags
.
mIsPositionless
=
true
;
return
EventDispatcher
:
:
Dispatch
(
MOZ_KnownLive
(
ToSupports
(
aElement
)
)
aPresContext
&
event
)
;
}
already_AddRefed
<
EditorBase
>
nsGenericHTMLElement
:
:
GetAssociatedEditor
(
)
{
RefPtr
<
TextEditor
>
textEditor
=
GetTextEditorInternal
(
)
;
return
textEditor
.
forget
(
)
;
}
void
nsGenericHTMLElement
:
:
SyncEditorsOnSubtree
(
nsIContent
*
content
)
{
nsGenericHTMLElement
*
element
=
FromNode
(
content
)
;
if
(
element
)
{
if
(
RefPtr
<
EditorBase
>
editorBase
=
element
-
>
GetAssociatedEditor
(
)
)
{
editorBase
-
>
SyncRealTimeSpell
(
)
;
}
}
for
(
nsIContent
*
child
=
content
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
SyncEditorsOnSubtree
(
child
)
;
}
}
bool
nsGenericHTMLElement
:
:
IsEditableRoot
(
)
const
{
if
(
!
IsInComposedDoc
(
)
)
{
return
false
;
}
if
(
IsInDesignMode
(
)
)
{
return
false
;
}
if
(
GetContentEditableValue
(
)
!
=
eTrue
)
{
return
false
;
}
nsIContent
*
parent
=
GetParent
(
)
;
return
!
parent
|
|
!
parent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
}
static
void
MakeContentDescendantsEditable
(
nsIContent
*
aContent
)
{
if
(
!
aContent
-
>
IsElement
(
)
)
{
aContent
-
>
UpdateEditableState
(
false
)
;
return
;
}
Element
*
element
=
aContent
-
>
AsElement
(
)
;
element
-
>
UpdateEditableState
(
true
)
;
for
(
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsElement
(
)
|
|
!
child
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
contenteditable
)
)
{
MakeContentDescendantsEditable
(
child
)
;
}
}
}
void
nsGenericHTMLElement
:
:
ChangeEditableState
(
int32_t
aChange
)
{
Document
*
document
=
GetComposedDoc
(
)
;
if
(
!
document
)
{
return
;
}
Document
:
:
EditingState
previousEditingState
=
Document
:
:
EditingState
:
:
eOff
;
if
(
aChange
!
=
0
)
{
document
-
>
ChangeContentEditableCount
(
this
aChange
)
;
previousEditingState
=
document
-
>
GetEditingState
(
)
;
}
nsAutoScriptBlocker
scriptBlocker
;
MakeContentDescendantsEditable
(
this
)
;
if
(
IsInDesignMode
(
)
&
&
!
IsInShadowTree
(
)
&
&
aChange
>
0
&
&
previousEditingState
=
=
Document
:
:
EditingState
:
:
eContentEditable
)
{
if
(
HTMLEditor
*
htmlEditor
=
nsContentUtils
:
:
GetHTMLEditor
(
document
-
>
GetPresContext
(
)
)
)
{
htmlEditor
-
>
NotifyEditingHostMaybeChanged
(
)
;
}
}
}
nsGenericHTMLFormControlElement
:
:
nsGenericHTMLFormControlElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FormControlType
aType
)
:
nsGenericHTMLFormElement
(
std
:
:
move
(
aNodeInfo
)
)
nsIFormControl
(
aType
)
mForm
(
nullptr
)
mFieldSet
(
nullptr
)
{
}
nsGenericHTMLFormControlElement
:
:
~
nsGenericHTMLFormControlElement
(
)
{
if
(
mFieldSet
)
{
mFieldSet
-
>
RemoveElement
(
this
)
;
}
NS_ASSERTION
(
!
mForm
"
mForm
should
be
null
at
this
point
!
"
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsGenericHTMLFormControlElement
nsGenericHTMLFormElement
nsIFormControl
)
nsINode
*
nsGenericHTMLFormControlElement
:
:
GetScopeChainParent
(
)
const
{
return
mForm
?
mForm
:
nsGenericHTMLElement
:
:
GetScopeChainParent
(
)
;
}
bool
nsGenericHTMLFormControlElement
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
!
(
aFlags
&
~
eHTML_FORM_CONTROL
)
;
}
void
nsGenericHTMLFormControlElement
:
:
SaveSubtreeState
(
)
{
SaveState
(
)
;
nsGenericHTMLFormElement
:
:
SaveSubtreeState
(
)
;
}
nsIContent
:
:
IMEState
nsGenericHTMLFormControlElement
:
:
GetDesiredIMEState
(
)
{
TextEditor
*
textEditor
=
GetTextEditorInternal
(
)
;
if
(
!
textEditor
)
{
return
nsGenericHTMLFormElement
:
:
GetDesiredIMEState
(
)
;
}
IMEState
state
;
nsresult
rv
=
textEditor
-
>
GetPreferredIMEState
(
&
state
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nsGenericHTMLFormElement
:
:
GetDesiredIMEState
(
)
;
}
return
state
;
}
nsresult
nsGenericHTMLFormControlElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLFormElement
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsAutofocusable
(
)
&
&
HasAttr
(
nsGkAtoms
:
:
autofocus
)
&
&
aContext
.
AllowsAutoFocus
(
)
)
{
aContext
.
OwnerDoc
(
)
.
SetAutoFocusElement
(
this
)
;
}
return
NS_OK
;
}
void
nsGenericHTMLFormControlElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
SaveState
(
)
;
nsGenericHTMLFormElement
:
:
UnbindFromTree
(
aNullParent
)
;
}
void
nsGenericHTMLFormControlElement
:
:
GetAutocapitalize
(
nsAString
&
aValue
)
const
{
if
(
nsContentUtils
:
:
HasNonEmptyAttr
(
this
kNameSpaceID_None
nsGkAtoms
:
:
autocapitalize
)
)
{
nsGenericHTMLFormElement
:
:
GetAutocapitalize
(
aValue
)
;
return
;
}
if
(
mForm
&
&
IsAutocapitalizeInheriting
(
)
)
{
mForm
-
>
GetAutocapitalize
(
aValue
)
;
}
}
bool
nsGenericHTMLFormControlElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
nsGenericHTMLFormElement
:
:
IsHTMLFocusable
(
aWithMouse
aIsFocusable
aTabIndex
)
)
{
return
true
;
}
*
aIsFocusable
=
*
aIsFocusable
&
&
IsFormControlDefaultFocusable
(
aWithMouse
)
;
return
false
;
}
void
nsGenericHTMLFormControlElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFocus
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eBlur
)
)
{
aVisitor
.
mWantsPreHandleEvent
=
true
;
}
nsGenericHTMLFormElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
nsresult
nsGenericHTMLFormControlElement
:
:
PreHandleEvent
(
EventChainVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eFocus
:
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
if
(
formControlFrame
&
&
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
static_cast
<
nsINode
*
>
(
this
)
)
{
formControlFrame
-
>
SetFocus
(
true
true
)
;
}
break
;
}
case
eBlur
:
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
true
)
;
if
(
formControlFrame
)
{
formControlFrame
-
>
SetFocus
(
false
false
)
;
}
break
;
}
default
:
break
;
}
}
return
nsGenericHTMLFormElement
:
:
PreHandleEvent
(
aVisitor
)
;
}
HTMLFieldSetElement
*
nsGenericHTMLFormControlElement
:
:
GetFieldSet
(
)
{
return
GetFieldSetInternal
(
)
;
}
void
nsGenericHTMLFormControlElement
:
:
SetForm
(
HTMLFormElement
*
aForm
)
{
MOZ_ASSERT
(
aForm
"
Don
'
t
pass
null
here
"
)
;
NS_ASSERTION
(
!
mForm
"
We
don
'
t
support
switching
from
one
non
-
null
form
to
another
.
"
)
;
SetFormInternal
(
aForm
false
)
;
}
void
nsGenericHTMLFormControlElement
:
:
ClearForm
(
bool
aRemoveFromForm
bool
aUnbindOrDelete
)
{
nsGenericHTMLFormElement
:
:
ClearForm
(
aRemoveFromForm
aUnbindOrDelete
)
;
}
ElementState
nsGenericHTMLFormControlElement
:
:
IntrinsicState
(
)
const
{
ElementState
state
=
nsGenericHTMLFormElement
:
:
IntrinsicState
(
)
;
if
(
mForm
&
&
mForm
-
>
IsDefaultSubmitElement
(
this
)
)
{
NS_ASSERTION
(
IsSubmitControl
(
)
"
Default
submit
element
that
isn
'
t
a
submit
control
.
"
)
;
state
|
=
ElementState
:
:
DEFAULT
;
}
if
(
!
state
.
HasState
(
ElementState
:
:
READWRITE
)
&
&
DoesReadOnlyApply
(
)
)
{
if
(
!
GetBoolAttr
(
nsGkAtoms
:
:
readonly
)
&
&
!
IsDisabled
(
)
)
{
state
|
=
ElementState
:
:
READWRITE
;
state
&
=
~
ElementState
:
:
READONLY
;
}
}
return
state
;
}
bool
nsGenericHTMLFormControlElement
:
:
IsLabelable
(
)
const
{
auto
type
=
ControlType
(
)
;
return
(
IsInputElement
(
type
)
&
&
type
!
=
FormControlType
:
:
InputHidden
)
|
|
IsButtonElement
(
type
)
|
|
type
=
=
FormControlType
:
:
Output
|
|
type
=
=
FormControlType
:
:
Select
|
|
type
=
=
FormControlType
:
:
Textarea
;
}
bool
nsGenericHTMLFormControlElement
:
:
CanBeDisabled
(
)
const
{
auto
type
=
ControlType
(
)
;
return
type
!
=
FormControlType
:
:
Object
&
&
type
!
=
FormControlType
:
:
Output
;
}
bool
nsGenericHTMLFormControlElement
:
:
DoesReadOnlyApply
(
)
const
{
auto
type
=
ControlType
(
)
;
if
(
!
IsInputElement
(
type
)
&
&
type
!
=
FormControlType
:
:
Textarea
)
{
return
false
;
}
switch
(
type
)
{
case
FormControlType
:
:
InputHidden
:
case
FormControlType
:
:
InputButton
:
case
FormControlType
:
:
InputImage
:
case
FormControlType
:
:
InputReset
:
case
FormControlType
:
:
InputSubmit
:
case
FormControlType
:
:
InputRadio
:
case
FormControlType
:
:
InputFile
:
case
FormControlType
:
:
InputCheckbox
:
case
FormControlType
:
:
InputRange
:
case
FormControlType
:
:
InputColor
:
return
false
;
#
ifdef
DEBUG
case
FormControlType
:
:
Textarea
:
case
FormControlType
:
:
InputText
:
case
FormControlType
:
:
InputPassword
:
case
FormControlType
:
:
InputSearch
:
case
FormControlType
:
:
InputTel
:
case
FormControlType
:
:
InputEmail
:
case
FormControlType
:
:
InputUrl
:
case
FormControlType
:
:
InputNumber
:
case
FormControlType
:
:
InputDate
:
case
FormControlType
:
:
InputTime
:
case
FormControlType
:
:
InputMonth
:
case
FormControlType
:
:
InputWeek
:
case
FormControlType
:
:
InputDatetimeLocal
:
return
true
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
input
type
in
DoesReadOnlyApply
(
)
"
)
;
return
true
;
#
else
default
:
return
true
;
#
endif
}
}
void
nsGenericHTMLFormControlElement
:
:
SetFormInternal
(
HTMLFormElement
*
aForm
bool
aBindToTree
)
{
if
(
aForm
)
{
BeforeSetForm
(
aBindToTree
)
;
}
mForm
=
aForm
;
}
HTMLFormElement
*
nsGenericHTMLFormControlElement
:
:
GetFormInternal
(
)
const
{
return
mForm
;
}
HTMLFieldSetElement
*
nsGenericHTMLFormControlElement
:
:
GetFieldSetInternal
(
)
const
{
return
mFieldSet
;
}
void
nsGenericHTMLFormControlElement
:
:
SetFieldSetInternal
(
HTMLFieldSetElement
*
aFieldset
)
{
mFieldSet
=
aFieldset
;
}
void
nsGenericHTMLFormControlElement
:
:
UpdateRequiredState
(
bool
aIsRequired
bool
aNotify
)
{
#
ifdef
DEBUG
auto
type
=
ControlType
(
)
;
#
endif
MOZ_ASSERT
(
IsInputElement
(
type
)
|
|
type
=
=
FormControlType
:
:
Select
|
|
type
=
=
FormControlType
:
:
Textarea
"
This
should
be
called
only
on
types
that
required
applies
"
)
;
#
ifdef
DEBUG
if
(
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
this
)
)
{
MOZ_ASSERT
(
input
-
>
DoesRequiredApply
(
)
"
This
should
be
called
only
on
input
types
that
required
applies
"
)
;
}
#
endif
ElementState
requiredStates
;
if
(
aIsRequired
)
{
requiredStates
|
=
ElementState
:
:
REQUIRED
;
}
else
{
requiredStates
|
=
ElementState
:
:
OPTIONAL_
;
}
ElementState
oldRequiredStates
=
State
(
)
&
ElementState
:
:
REQUIRED_STATES
;
ElementState
changedStates
=
requiredStates
^
oldRequiredStates
;
if
(
!
changedStates
.
IsEmpty
(
)
)
{
ToggleStates
(
changedStates
aNotify
)
;
}
}
bool
nsGenericHTMLFormControlElement
:
:
IsAutocapitalizeInheriting
(
)
const
{
auto
type
=
ControlType
(
)
;
return
IsInputElement
(
type
)
|
|
IsButtonElement
(
type
)
|
|
type
=
=
FormControlType
:
:
Fieldset
|
|
type
=
=
FormControlType
:
:
Output
|
|
type
=
=
FormControlType
:
:
Select
|
|
type
=
=
FormControlType
:
:
Textarea
;
}
bool
nsGenericHTMLFormControlElement
:
:
IsAutofocusable
(
)
const
{
auto
type
=
ControlType
(
)
;
return
IsInputElement
(
type
)
|
|
IsButtonElement
(
type
)
|
|
type
=
=
FormControlType
:
:
Textarea
|
|
type
=
=
FormControlType
:
:
Select
;
}
nsGenericHTMLFormControlElementWithState
:
:
nsGenericHTMLFormControlElementWithState
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
FormControlType
aType
)
:
nsGenericHTMLFormControlElement
(
std
:
:
move
(
aNodeInfo
)
aType
)
mControlNumber
(
!
!
(
aFromParser
&
FROM_PARSER_NETWORK
)
?
OwnerDoc
(
)
-
>
GetNextControlNumber
(
)
:
-
1
)
{
mStateKey
.
SetIsVoid
(
true
)
;
}
void
nsGenericHTMLFormControlElementWithState
:
:
GenerateStateKey
(
)
{
if
(
!
mStateKey
.
IsVoid
(
)
)
{
return
;
}
Document
*
doc
=
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
mStateKey
.
Truncate
(
)
;
return
;
}
nsContentUtils
:
:
GenerateStateKey
(
this
doc
mStateKey
)
;
if
(
!
mStateKey
.
IsEmpty
(
)
)
{
mStateKey
+
=
"
-
C
"
;
}
}
PresState
*
nsGenericHTMLFormControlElementWithState
:
:
GetPrimaryPresState
(
)
{
if
(
mStateKey
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
history
=
GetLayoutHistory
(
false
)
;
if
(
!
history
)
{
return
nullptr
;
}
PresState
*
result
=
history
-
>
GetState
(
mStateKey
)
;
if
(
!
result
)
{
UniquePtr
<
PresState
>
newState
=
NewPresState
(
)
;
result
=
newState
.
get
(
)
;
history
-
>
AddState
(
mStateKey
std
:
:
move
(
newState
)
)
;
}
return
result
;
}
already_AddRefed
<
nsILayoutHistoryState
>
nsGenericHTMLFormControlElementWithState
:
:
GetLayoutHistory
(
bool
aRead
)
{
nsCOMPtr
<
Document
>
doc
=
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
history
=
doc
-
>
GetLayoutHistoryState
(
)
;
if
(
!
history
)
{
return
nullptr
;
}
if
(
aRead
&
&
!
history
-
>
HasStates
(
)
)
{
return
nullptr
;
}
return
history
.
forget
(
)
;
}
bool
nsGenericHTMLFormControlElementWithState
:
:
RestoreFormControlState
(
)
{
MOZ_ASSERT
(
!
mStateKey
.
IsVoid
(
)
"
GenerateStateKey
must
already
have
been
called
"
)
;
if
(
mStateKey
.
IsEmpty
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsILayoutHistoryState
>
history
=
GetLayoutHistory
(
true
)
;
if
(
!
history
)
{
return
false
;
}
PresState
*
state
=
history
-
>
GetState
(
mStateKey
)
;
if
(
state
)
{
bool
result
=
RestoreState
(
state
)
;
history
-
>
RemoveState
(
mStateKey
)
;
return
result
;
}
return
false
;
}
void
nsGenericHTMLFormControlElementWithState
:
:
NodeInfoChanged
(
Document
*
aOldDoc
)
{
nsGenericHTMLFormControlElement
:
:
NodeInfoChanged
(
aOldDoc
)
;
mControlNumber
=
-
1
;
mStateKey
.
SetIsVoid
(
true
)
;
}
void
nsGenericHTMLFormControlElementWithState
:
:
GetFormAction
(
nsString
&
aValue
)
{
auto
type
=
ControlType
(
)
;
if
(
!
IsInputElement
(
type
)
&
&
!
IsButtonElement
(
type
)
)
{
return
;
}
if
(
!
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
formaction
aValue
)
|
|
aValue
.
IsEmpty
(
)
)
{
Document
*
document
=
OwnerDoc
(
)
;
nsIURI
*
docURI
=
document
-
>
GetDocumentURI
(
)
;
if
(
docURI
)
{
nsAutoCString
spec
;
nsresult
rv
=
docURI
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CopyUTF8toUTF16
(
spec
aValue
)
;
}
}
else
{
GetURIAttr
(
nsGkAtoms
:
:
formaction
nullptr
aValue
)
;
}
}
bool
nsGenericHTMLElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
EventNameType_HTML
)
;
}
nsresult
nsGenericHTMLElement
:
:
NewURIFromString
(
const
nsAString
&
aURISpec
nsIURI
*
*
aURI
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
*
aURI
=
nullptr
;
nsCOMPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
nsresult
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
aURI
aURISpec
doc
GetBaseURI
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
equal
;
if
(
aURISpec
.
IsEmpty
(
)
&
&
doc
-
>
GetDocumentURI
(
)
&
&
NS_SUCCEEDED
(
doc
-
>
GetDocumentURI
(
)
-
>
Equals
(
*
aURI
&
equal
)
)
&
&
equal
)
{
NS_RELEASE
(
*
aURI
)
;
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
return
NS_OK
;
}
void
nsGenericHTMLElement
:
:
GetInnerText
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
mozilla
:
:
ErrorResult
&
aError
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
}
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
IsDisplayContents
(
)
)
{
for
(
Element
*
parent
=
GetFlattenedTreeParentElement
(
)
;
parent
;
parent
=
parent
-
>
GetFlattenedTreeParentElement
(
)
)
{
frame
=
parent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
break
;
}
}
}
bool
dirty
=
frame
&
&
frame
-
>
PresShell
(
)
-
>
FrameIsAncestorOfDirtyRoot
(
frame
)
;
dirty
|
=
frame
&
&
frame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
while
(
!
dirty
&
&
frame
)
{
dirty
|
=
frame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
;
frame
=
frame
-
>
GetInFlowParent
(
)
;
}
if
(
dirty
&
&
doc
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
if
(
!
IsRendered
(
)
)
{
GetTextContentInternal
(
aValue
aError
)
;
}
else
{
nsRange
:
:
GetInnerTextNoFlush
(
aValue
aError
this
)
;
}
}
static
already_AddRefed
<
nsINode
>
TextToNode
(
const
nsAString
&
aString
nsNodeInfoManager
*
aNim
)
{
nsString
str
;
const
char16_t
*
s
=
aString
.
BeginReading
(
)
;
const
char16_t
*
end
=
aString
.
EndReading
(
)
;
RefPtr
<
DocumentFragment
>
fragment
;
while
(
true
)
{
if
(
s
!
=
end
&
&
*
s
=
=
'
\
r
'
&
&
s
+
1
!
=
end
&
&
s
[
1
]
=
=
'
\
n
'
)
{
+
+
s
;
}
if
(
s
=
=
end
|
|
*
s
=
=
'
\
r
'
|
|
*
s
=
=
'
\
n
'
)
{
if
(
!
str
.
IsEmpty
(
)
)
{
RefPtr
<
nsTextNode
>
textContent
=
new
(
aNim
)
nsTextNode
(
aNim
)
;
textContent
-
>
SetText
(
str
true
)
;
if
(
!
fragment
)
{
if
(
s
=
=
end
)
{
return
textContent
.
forget
(
)
;
}
fragment
=
new
(
aNim
)
DocumentFragment
(
aNim
)
;
}
fragment
-
>
AppendChildTo
(
textContent
true
IgnoreErrors
(
)
)
;
}
if
(
s
=
=
end
)
{
break
;
}
str
.
Truncate
(
)
;
RefPtr
<
NodeInfo
>
ni
=
aNim
-
>
GetNodeInfo
(
nsGkAtoms
:
:
br
nullptr
kNameSpaceID_XHTML
nsINode
:
:
ELEMENT_NODE
)
;
auto
*
nim
=
ni
-
>
NodeInfoManager
(
)
;
RefPtr
<
HTMLBRElement
>
br
=
new
(
nim
)
HTMLBRElement
(
ni
.
forget
(
)
)
;
if
(
!
fragment
)
{
if
(
s
+
1
=
=
end
)
{
return
br
.
forget
(
)
;
}
fragment
=
new
(
aNim
)
DocumentFragment
(
aNim
)
;
}
fragment
-
>
AppendChildTo
(
br
true
IgnoreErrors
(
)
)
;
}
else
{
str
.
Append
(
*
s
)
;
}
+
+
s
;
}
return
fragment
.
forget
(
)
;
}
void
nsGenericHTMLElement
:
:
SetInnerText
(
const
nsAString
&
aValue
)
{
RefPtr
<
nsINode
>
node
=
TextToNode
(
aValue
NodeInfo
(
)
-
>
NodeInfoManager
(
)
)
;
ReplaceChildren
(
node
IgnoreErrors
(
)
)
;
}
static
void
MergeWithNextTextNode
(
Text
&
aText
ErrorResult
&
aRv
)
{
RefPtr
<
Text
>
nextSibling
=
Text
:
:
FromNodeOrNull
(
aText
.
GetNextSibling
(
)
)
;
if
(
!
nextSibling
)
{
return
;
}
nsAutoString
data
;
nextSibling
-
>
GetData
(
data
)
;
aText
.
AppendData
(
data
aRv
)
;
nextSibling
-
>
Remove
(
)
;
}
void
nsGenericHTMLElement
:
:
SetOuterText
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
aRv
.
ThrowNoModificationAllowedError
(
"
Element
has
no
parent
"
)
;
}
RefPtr
<
nsINode
>
next
=
GetNextSibling
(
)
;
RefPtr
<
nsINode
>
previous
=
GetPreviousSibling
(
)
;
mozAutoSubtreeModified
subtree
(
OwnerDoc
(
)
nullptr
)
;
nsNodeInfoManager
*
nim
=
NodeInfo
(
)
-
>
NodeInfoManager
(
)
;
RefPtr
<
nsINode
>
node
=
TextToNode
(
aValue
nim
)
;
if
(
!
node
)
{
node
=
new
(
nim
)
nsTextNode
(
nim
)
;
}
parent
-
>
ReplaceChild
(
*
node
*
this
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
next
)
{
if
(
RefPtr
<
Text
>
text
=
Text
:
:
FromNodeOrNull
(
next
-
>
GetPreviousSibling
(
)
)
)
{
MergeWithNextTextNode
(
*
text
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
if
(
auto
*
text
=
Text
:
:
FromNodeOrNull
(
previous
)
)
{
MergeWithNextTextNode
(
*
text
aRv
)
;
}
}
already_AddRefed
<
ElementInternals
>
nsGenericHTMLElement
:
:
AttachInternals
(
ErrorResult
&
aRv
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Cannot
attach
ElementInternals
to
a
customized
built
-
in
or
non
-
custom
"
"
element
"
"
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
GetUTF16String
(
)
)
.
get
(
)
)
)
;
return
nullptr
;
}
ElementInternals
*
nsGenericHTMLElement
:
:
GetInternals
(
)
const
{
if
(
CustomElementData
*
data
=
GetCustomElementData
(
)
)
{
return
data
-
>
GetElementInternals
(
)
;
}
return
nullptr
;
}
bool
nsGenericHTMLElement
:
:
IsFormAssociatedCustomElements
(
)
const
{
if
(
CustomElementData
*
data
=
GetCustomElementData
(
)
)
{
return
data
-
>
IsFormAssociated
(
)
;
}
return
false
;
}
void
nsGenericHTMLElement
:
:
GetAutocapitalize
(
nsAString
&
aValue
)
const
{
GetEnumAttr
(
nsGkAtoms
:
:
autocapitalize
nullptr
kDefaultAutocapitalize
-
>
tag
aValue
)
;
}
