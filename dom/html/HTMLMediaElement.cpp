#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSourceElement
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
MediaEncryptedEvent
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
nsIDOMHTMLMediaElement
.
h
"
#
include
"
nsIDOMHTMLSourceElement
.
h
"
#
include
"
TimeRanges
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsXPCOMStrings
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
MediaError
.
h
"
#
include
"
MediaDecoder
.
h
"
#
include
"
MediaPrefs
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsVideoFrame
.
h
"
#
include
"
Layers
.
h
"
#
include
<
limits
>
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsMediaFragmentURIParser
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsHostObjectProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
MediaSource
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaSourceDecoder
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
AudioStreamTrack
.
h
"
#
include
"
VideoStreamTrack
.
h
"
#
include
"
MediaTrackList
.
h
"
#
include
"
MediaStreamError
.
h
"
#
include
"
VideoFrameContainer
.
h
"
#
include
"
AudioChannelService
.
h
"
#
include
"
mozilla
/
dom
/
power
/
PowerManagerService
.
h
"
#
include
"
mozilla
/
dom
/
WakeLock
.
h
"
#
include
"
mozilla
/
dom
/
AudioTrack
.
h
"
#
include
"
mozilla
/
dom
/
AudioTrackList
.
h
"
#
include
"
mozilla
/
dom
/
MediaErrorBinding
.
h
"
#
include
"
mozilla
/
dom
/
VideoTrack
.
h
"
#
include
"
mozilla
/
dom
/
VideoTrackList
.
h
"
#
include
"
mozilla
/
dom
/
TextTrack
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
DecoderTraits
.
h
"
#
include
"
MediaContentType
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
nsRange
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
static
mozilla
:
:
LazyLogModule
gMediaElementLog
(
"
nsMediaElement
"
)
;
static
mozilla
:
:
LazyLogModule
gMediaElementEventsLog
(
"
nsMediaElementEvents
"
)
;
#
define
LOG
(
type
msg
)
MOZ_LOG
(
gMediaElementLog
type
msg
)
#
define
LOG_EVENT
(
type
msg
)
MOZ_LOG
(
gMediaElementEventsLog
type
msg
)
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
dom
/
HTMLVideoElement
.
h
"
#
include
"
mozilla
/
dom
/
VideoPlaybackQuality
.
h
"
using
namespace
mozilla
:
:
layers
;
using
mozilla
:
:
net
:
:
nsMediaFragmentURIParser
;
class
MOZ_STACK_CLASS
AutoNotifyAudioChannelAgent
{
RefPtr
<
mozilla
:
:
dom
:
:
HTMLMediaElement
>
mElement
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
;
public
:
explicit
AutoNotifyAudioChannelAgent
(
mozilla
:
:
dom
:
:
HTMLMediaElement
*
aElement
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mElement
(
aElement
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoNotifyAudioChannelAgent
(
)
{
mElement
-
>
UpdateAudioChannelPlayingState
(
)
;
}
}
;
namespace
mozilla
{
namespace
dom
{
static
const
uint32_t
PROGRESS_MS
=
350
;
static
const
uint32_t
STALL_MS
=
3000
;
#
define
FADED_VOLUME_RATIO
0
.
25
static
const
double
MIN_PLAYBACKRATE
=
0
.
25
;
static
const
double
MAX_PLAYBACKRATE
=
5
.
0
;
static
const
double
THRESHOLD_HIGH_PLAYBACKRATE_AUDIO
=
4
.
0
;
static
const
double
THRESHOLD_LOW_PLAYBACKRATE_AUDIO
=
0
.
5
;
static
const
unsigned
short
MEDIA_ERR_ABORTED
=
1
;
static
const
unsigned
short
MEDIA_ERR_NETWORK
=
2
;
static
const
unsigned
short
MEDIA_ERR_DECODE
=
3
;
static
const
unsigned
short
MEDIA_ERR_SRC_NOT_SUPPORTED
=
4
;
class
nsMediaEvent
:
public
Runnable
{
public
:
explicit
nsMediaEvent
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
mLoadID
(
mElement
-
>
GetCurrentLoadID
(
)
)
{
}
~
nsMediaEvent
(
)
{
}
NS_IMETHOD
Run
(
)
=
0
;
protected
:
bool
IsCancelled
(
)
{
return
mElement
-
>
GetCurrentLoadID
(
)
!
=
mLoadID
;
}
RefPtr
<
HTMLMediaElement
>
mElement
;
uint32_t
mLoadID
;
}
;
class
HTMLMediaElement
:
:
nsAsyncEventRunner
:
public
nsMediaEvent
{
private
:
nsString
mName
;
public
:
nsAsyncEventRunner
(
const
nsAString
&
aName
HTMLMediaElement
*
aElement
)
:
nsMediaEvent
(
aElement
)
mName
(
aName
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
IsCancelled
(
)
)
return
NS_OK
;
return
mElement
-
>
DispatchEvent
(
mName
)
;
}
}
;
class
nsSourceErrorEventRunner
:
public
nsMediaEvent
{
private
:
nsCOMPtr
<
nsIContent
>
mSource
;
public
:
nsSourceErrorEventRunner
(
HTMLMediaElement
*
aElement
nsIContent
*
aSource
)
:
nsMediaEvent
(
aElement
)
mSource
(
aSource
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
IsCancelled
(
)
)
return
NS_OK
;
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Dispatching
simple
event
source
error
"
mElement
.
get
(
)
)
)
;
return
nsContentUtils
:
:
DispatchTrustedEvent
(
mElement
-
>
OwnerDoc
(
)
mSource
NS_LITERAL_STRING
(
"
error
"
)
false
false
)
;
}
}
;
class
HTMLMediaElement
:
:
StreamSizeListener
:
public
DirectMediaStreamTrackListener
{
public
:
explicit
StreamSizeListener
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
mInitialSizeFound
(
false
)
{
}
void
Forget
(
)
{
mElement
=
nullptr
;
}
void
ReceivedSize
(
gfx
:
:
IntSize
aSize
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mElement
)
{
return
;
}
RefPtr
<
HTMLMediaElement
>
deathGrip
=
mElement
;
deathGrip
-
>
UpdateInitialMediaSize
(
aSize
)
;
}
void
NotifyRealtimeTrackData
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
const
MediaSegment
&
aMedia
)
override
{
if
(
mInitialSizeFound
)
{
return
;
}
if
(
aMedia
.
GetType
(
)
!
=
MediaSegment
:
:
VIDEO
)
{
MOZ_ASSERT
(
false
"
Should
only
lock
on
to
a
video
track
"
)
;
return
;
}
const
VideoSegment
&
video
=
static_cast
<
const
VideoSegment
&
>
(
aMedia
)
;
for
(
VideoSegment
:
:
ConstChunkIterator
c
(
video
)
;
!
c
.
IsEnded
(
)
;
c
.
Next
(
)
)
{
if
(
c
-
>
mFrame
.
GetIntrinsicSize
(
)
!
=
gfx
:
:
IntSize
(
0
0
)
)
{
mInitialSizeFound
=
true
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
<
gfx
:
:
IntSize
>
(
this
&
StreamSizeListener
:
:
ReceivedSize
c
-
>
mFrame
.
GetIntrinsicSize
(
)
)
;
NS_DispatchToMainThread
(
event
.
forget
(
)
)
;
return
;
}
}
}
private
:
HTMLMediaElement
*
mElement
;
bool
mInitialSizeFound
;
}
;
class
HTMLMediaElement
:
:
MediaLoadListener
final
:
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIInterfaceRequestor
public
nsIObserver
{
~
MediaLoadListener
(
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIOBSERVER
NS_DECL_NSIINTERFACEREQUESTOR
public
:
explicit
MediaLoadListener
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
mLoadID
(
aElement
-
>
GetCurrentLoadID
(
)
)
{
MOZ_ASSERT
(
mElement
"
Must
pass
an
element
to
call
back
"
)
;
}
private
:
RefPtr
<
HTMLMediaElement
>
mElement
;
nsCOMPtr
<
nsIStreamListener
>
mNextListener
;
const
uint32_t
mLoadID
;
}
;
NS_IMPL_ISUPPORTS
(
HTMLMediaElement
:
:
MediaLoadListener
nsIRequestObserver
nsIStreamListener
nsIChannelEventSink
nsIInterfaceRequestor
nsIObserver
)
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
mElement
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
if
(
!
mElement
)
{
return
NS_BINDING_ABORTED
;
}
RefPtr
<
HTMLMediaElement
>
element
;
element
.
swap
(
mElement
)
;
if
(
mLoadID
!
=
element
-
>
GetCurrentLoadID
(
)
)
{
return
NS_BINDING_ABORTED
;
}
nsresult
status
;
nsresult
rv
=
aRequest
-
>
GetStatus
(
&
status
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_FAILED
(
status
)
)
{
if
(
element
)
{
if
(
status
=
=
NS_ERROR_TRACKING_URI
)
{
nsIDocument
*
ownerDoc
=
element
-
>
OwnerDoc
(
)
;
if
(
ownerDoc
)
{
ownerDoc
-
>
AddBlockedTrackingNode
(
element
)
;
}
}
element
-
>
NotifyLoadError
(
)
;
}
return
status
;
}
nsCOMPtr
<
nsIHttpChannel
>
hc
=
do_QueryInterface
(
aRequest
)
;
bool
succeeded
;
if
(
hc
&
&
NS_SUCCEEDED
(
hc
-
>
GetRequestSucceeded
(
&
succeeded
)
)
&
&
!
succeeded
)
{
element
-
>
NotifyLoadError
(
)
;
uint32_t
responseStatus
=
0
;
hc
-
>
GetResponseStatus
(
&
responseStatus
)
;
nsAutoString
code
;
code
.
AppendInt
(
responseStatus
)
;
nsAutoString
src
;
element
-
>
GetCurrentSrc
(
src
)
;
const
char16_t
*
params
[
]
=
{
code
.
get
(
)
src
.
get
(
)
}
;
element
-
>
ReportLoadError
(
"
MediaLoadHttpError
"
params
ArrayLength
(
params
)
)
;
return
NS_BINDING_ABORTED
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
if
(
channel
&
&
NS_SUCCEEDED
(
rv
=
element
-
>
InitializeDecoderForChannel
(
channel
getter_AddRefs
(
mNextListener
)
)
)
&
&
mNextListener
)
{
rv
=
mNextListener
-
>
OnStartRequest
(
aRequest
aContext
)
;
}
else
{
if
(
NS_FAILED
(
rv
)
&
&
!
mNextListener
)
{
element
-
>
NotifyLoadError
(
)
;
}
rv
=
NS_BINDING_ABORTED
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
if
(
mNextListener
)
{
return
mNextListener
-
>
OnStopRequest
(
aRequest
aContext
aStatus
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
!
mNextListener
)
{
NS_ERROR
(
"
Must
have
a
chained
listener
;
OnStartRequest
should
have
canceled
this
request
"
)
;
return
NS_BINDING_ABORTED
;
}
return
mNextListener
-
>
OnDataAvailable
(
aRequest
aContext
aStream
aOffset
aCount
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
if
(
mElement
)
{
mElement
-
>
OnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
)
;
}
nsCOMPtr
<
nsIChannelEventSink
>
sink
=
do_QueryInterface
(
mNextListener
)
;
if
(
sink
)
{
return
sink
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
cb
)
;
}
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
return
QueryInterface
(
aIID
aResult
)
;
}
void
HTMLMediaElement
:
:
ReportLoadError
(
const
char
*
aMsg
const
char16_t
*
*
aParams
uint32_t
aParamCount
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
aMsg
aParams
aParamCount
)
;
}
class
HTMLMediaElement
:
:
ChannelLoader
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ChannelLoader
)
;
void
LoadInternal
(
HTMLMediaElement
*
aElement
)
{
if
(
mCancelled
)
{
return
;
}
nsSecurityFlags
securityFlags
=
aElement
-
>
ShouldCheckAllowOrigin
(
)
?
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
:
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
;
if
(
aElement
-
>
GetCORSMode
(
)
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
MOZ_ASSERT
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
audio
nsGkAtoms
:
:
video
)
)
;
nsContentPolicyType
contentPolicyType
=
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
audio
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aElement
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aElement
-
>
mLoadingSrc
static_cast
<
Element
*
>
(
aElement
)
securityFlags
contentPolicyType
loadGroup
nullptr
nsICachingChannel
:
:
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
|
nsIChannel
:
:
LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
|
nsIChannel
:
:
LOAD_CALL_CONTENT_SNIFFERS
)
;
if
(
NS_FAILED
(
rv
)
)
{
aElement
-
>
NotifyLoadError
(
)
;
return
;
}
RefPtr
<
MediaLoadListener
>
loadListener
=
new
MediaLoadListener
(
aElement
)
;
channel
-
>
SetNotificationCallbacks
(
loadListener
)
;
nsCOMPtr
<
nsIHttpChannel
>
hc
=
do_QueryInterface
(
channel
)
;
if
(
hc
)
{
hc
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Range
"
)
NS_LITERAL_CSTRING
(
"
bytes
=
0
-
"
)
false
)
;
aElement
-
>
SetRequestHeaders
(
hc
)
;
}
rv
=
channel
-
>
AsyncOpen2
(
loadListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
aElement
-
>
NotifyLoadError
(
)
;
return
;
}
mChannel
=
channel
;
nsContentUtils
:
:
RegisterShutdownObserver
(
loadListener
)
;
}
nsresult
Load
(
HTMLMediaElement
*
aElement
)
{
return
NS_DispatchToMainThread
(
NewRunnableMethod
<
HTMLMediaElement
*
>
(
this
&
ChannelLoader
:
:
LoadInternal
aElement
)
)
;
}
void
Cancel
(
)
{
mCancelled
=
true
;
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mChannel
=
nullptr
;
}
}
void
Done
(
)
{
MOZ_ASSERT
(
mChannel
)
;
mChannel
=
nullptr
;
}
nsresult
Redirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
{
NS_ASSERTION
(
aChannel
=
=
mChannel
"
Channels
should
match
!
"
)
;
mChannel
=
aNewChannel
;
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aChannel
)
;
NS_ENSURE_STATE
(
http
)
;
NS_NAMED_LITERAL_CSTRING
(
rangeHdr
"
Range
"
)
;
nsAutoCString
rangeVal
;
if
(
NS_SUCCEEDED
(
http
-
>
GetRequestHeader
(
rangeHdr
rangeVal
)
)
)
{
NS_ENSURE_STATE
(
!
rangeVal
.
IsEmpty
(
)
)
;
http
=
do_QueryInterface
(
aNewChannel
)
;
NS_ENSURE_STATE
(
http
)
;
nsresult
rv
=
http
-
>
SetRequestHeader
(
rangeHdr
rangeVal
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
private
:
~
ChannelLoader
(
)
{
MOZ_ASSERT
(
!
mChannel
)
;
}
nsCOMPtr
<
nsIChannel
>
mChannel
;
bool
mCancelled
=
false
;
}
;
NS_IMPL_ADDREF_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
NS_IMPL_RELEASE_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLMediaElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMediaSource
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSrcMediaSource
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSrcStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSrcAttrStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSourcePointer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLoadBlockedDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSourceLoadCandidate
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioChannelAgent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mError
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mOutputStreams
.
Length
(
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOutputStreams
[
i
]
.
mStream
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPlayed
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTextTrackManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioTrackList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mVideoTrackList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMediaKeys
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectedVideoStreamTrack
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
if
(
tmp
-
>
mSrcStream
)
{
tmp
-
>
EndSrcMediaStreamPlayback
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSrcAttrStream
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMediaSource
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSrcMediaSource
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSourcePointer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLoadBlockedDoc
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSourceLoadCandidate
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioChannelAgent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mError
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mOutputStreams
.
Length
(
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOutputStreams
[
i
]
.
mStream
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPlayed
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTextTrackManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioTrackList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mVideoTrackList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMediaKeys
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelectedVideoStreamTrack
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMHTMLMediaElement
)
NS_INTERFACE_MAP_ENTRY
(
nsIAudioChannelAgentCallback
)
NS_INTERFACE_MAP_END_INHERITING
(
nsGenericHTMLElement
)
NS_IMPL_URI_ATTR
(
HTMLMediaElement
Src
src
)
NS_IMPL_BOOL_ATTR
(
HTMLMediaElement
Controls
controls
)
NS_IMPL_BOOL_ATTR
(
HTMLMediaElement
Autoplay
autoplay
)
NS_IMPL_BOOL_ATTR
(
HTMLMediaElement
Loop
loop
)
NS_IMPL_BOOL_ATTR
(
HTMLMediaElement
DefaultMuted
muted
)
NS_IMPL_ENUM_ATTR_DEFAULT_VALUE
(
HTMLMediaElement
Preload
preload
nullptr
)
NS_IMETHODIMP
HTMLMediaElement
:
:
GetMozAudioChannelType
(
nsAString
&
aValue
)
{
nsString
defaultValue
;
AudioChannelService
:
:
GetDefaultAudioChannelString
(
defaultValue
)
;
NS_ConvertUTF16toUTF8
str
(
defaultValue
)
;
GetEnumAttr
(
nsGkAtoms
:
:
mozaudiochannel
str
.
get
(
)
aValue
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
SetMozAudioChannelType
(
const
nsAString
&
aValue
)
{
return
SetAttrHelper
(
nsGkAtoms
:
:
mozaudiochannel
aValue
)
;
}
NS_IMETHODIMP_
(
bool
)
HTMLMediaElement
:
:
IsVideo
(
)
{
return
false
;
}
already_AddRefed
<
MediaSource
>
HTMLMediaElement
:
:
GetMozMediaSourceObject
(
)
const
{
RefPtr
<
MediaSource
>
source
=
mMediaSource
;
return
source
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
GetMozDebugReaderData
(
nsAString
&
aString
)
{
if
(
mDecoder
&
&
!
mSrcStream
)
{
mDecoder
-
>
GetMozDebugReaderData
(
aString
)
;
}
}
void
HTMLMediaElement
:
:
MozDumpDebugInfo
(
)
{
if
(
mDecoder
)
{
mDecoder
-
>
DumpDebugInfo
(
)
;
}
}
void
HTMLMediaElement
:
:
SetVisible
(
bool
aVisible
)
{
if
(
!
mDecoder
)
{
return
;
}
mDecoder
-
>
SetForcedHidden
(
!
aVisible
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
GetSrcObject
(
)
const
{
NS_ASSERTION
(
!
mSrcAttrStream
|
|
mSrcAttrStream
-
>
GetPlaybackStream
(
)
"
MediaStream
should
have
been
set
up
properly
"
)
;
RefPtr
<
DOMMediaStream
>
stream
=
mSrcAttrStream
;
return
stream
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
SetSrcObject
(
DOMMediaStream
&
aValue
)
{
SetMozSrcObject
(
&
aValue
)
;
}
void
HTMLMediaElement
:
:
SetSrcObject
(
DOMMediaStream
*
aValue
)
{
mSrcAttrStream
=
aValue
;
UpdateAudioChannelPlayingState
(
)
;
DoLoad
(
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
GetMozSrcObject
(
)
const
{
NS_ASSERTION
(
!
mSrcAttrStream
|
|
mSrcAttrStream
-
>
GetPlaybackStream
(
)
"
MediaStream
should
have
been
set
up
properly
"
)
;
RefPtr
<
DOMMediaStream
>
stream
=
mSrcAttrStream
;
return
stream
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
SetMozSrcObject
(
DOMMediaStream
&
aValue
)
{
SetMozSrcObject
(
&
aValue
)
;
}
void
HTMLMediaElement
:
:
SetMozSrcObject
(
DOMMediaStream
*
aValue
)
{
mSrcAttrStream
=
aValue
;
UpdateAudioChannelPlayingState
(
)
;
DoLoad
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetMozAutoplayEnabled
(
bool
*
aAutoplayEnabled
)
{
*
aAutoplayEnabled
=
mAutoplayEnabled
;
return
NS_OK
;
}
bool
HTMLMediaElement
:
:
Ended
(
)
{
if
(
MediaStream
*
stream
=
GetSrcMediaStream
(
)
)
{
return
stream
-
>
IsFinished
(
)
;
}
return
mDecoder
&
&
mDecoder
-
>
IsEnded
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetEnded
(
bool
*
aEnded
)
{
*
aEnded
=
Ended
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetCurrentSrc
(
nsAString
&
aCurrentSrc
)
{
nsAutoCString
src
;
GetCurrentSpec
(
src
)
;
aCurrentSrc
=
NS_ConvertUTF8toUTF16
(
src
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetNetworkState
(
uint16_t
*
aNetworkState
)
{
*
aNetworkState
=
NetworkState
(
)
;
return
NS_OK
;
}
nsresult
HTMLMediaElement
:
:
OnChannelRedirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
{
MOZ_ASSERT
(
mChannelLoader
)
;
return
mChannelLoader
-
>
Redirect
(
aChannel
aNewChannel
aFlags
)
;
}
void
HTMLMediaElement
:
:
ShutdownDecoder
(
)
{
RemoveMediaElementFromURITable
(
)
;
NS_ASSERTION
(
mDecoder
"
Must
have
decoder
to
shut
down
"
)
;
mWaitingForKeyListener
.
DisconnectIfExists
(
)
;
mDecoder
-
>
Shutdown
(
)
;
mDecoder
=
nullptr
;
}
void
HTMLMediaElement
:
:
AbortExistingLoads
(
)
{
if
(
mDecoder
)
{
ReportEMETelemetry
(
)
;
}
mLoadWaitStatus
=
NOT_WAITING
;
mCurrentLoadID
+
+
;
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Cancel
(
)
;
mChannelLoader
=
nullptr
;
}
bool
fireTimeUpdate
=
false
;
if
(
mMediaStreamSizeListener
)
{
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
mMediaStreamSizeListener
-
>
Forget
(
)
;
mMediaStreamSizeListener
=
nullptr
;
}
AudioTracks
(
)
-
>
EmptyTracks
(
)
;
VideoTracks
(
)
-
>
EmptyTracks
(
)
;
if
(
mDecoder
)
{
fireTimeUpdate
=
mDecoder
-
>
GetCurrentTime
(
)
!
=
0
.
0
;
ShutdownDecoder
(
)
;
}
if
(
mSrcStream
)
{
EndSrcMediaStreamPlayback
(
)
;
}
RemoveMediaElementFromURITable
(
)
;
mLoadingSrc
=
nullptr
;
mMediaSource
=
nullptr
;
if
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
|
|
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_IDLE
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
abort
"
)
)
;
}
mError
=
nullptr
;
mCurrentPlayRangeStart
=
-
1
.
0
;
mLoadedDataFired
=
false
;
mAutoplaying
=
true
;
mIsLoadingFromSourceChildren
=
false
;
mSuspendedAfterFirstFrame
=
false
;
mAllowSuspendAfterFirstFrame
=
true
;
mHaveQueuedSelectResource
=
false
;
mSuspendedForPreloadNone
=
false
;
mDownloadSuspendedByCache
=
false
;
mMediaInfo
=
MediaInfo
(
)
;
mIsEncrypted
=
false
;
mPendingEncryptedInitData
.
mInitDatas
.
Clear
(
)
;
mWaitingForKey
=
false
;
mSourcePointer
=
nullptr
;
mTags
=
nullptr
;
if
(
mNetworkState
!
=
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
{
NS_ASSERTION
(
!
mDecoder
&
&
!
mSrcStream
"
How
did
someone
setup
a
new
stream
/
decoder
already
?
"
)
;
mPaused
=
true
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_NOTHING
)
;
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
GetTextTracks
(
)
-
>
SetCuesInactive
(
)
;
}
if
(
fireTimeUpdate
)
{
FireTimeUpdate
(
false
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
emptied
"
)
)
;
UpdateAudioChannelPlayingState
(
)
;
}
AddRemoveSelfReference
(
)
;
mIsRunningSelectResource
=
false
;
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyReset
(
)
;
}
mEventDeliveryPaused
=
false
;
mPendingEvents
.
Clear
(
)
;
}
void
HTMLMediaElement
:
:
NoSupportedMediaSourceError
(
const
nsACString
&
aErrorDetails
)
{
mError
=
new
MediaError
(
this
MEDIA_ERR_SRC_NOT_SUPPORTED
aErrorDetails
)
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_NO_SOURCE
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
error
"
)
)
;
ChangeDelayLoadStatus
(
false
)
;
UpdateAudioChannelPlayingState
(
)
;
OpenUnsupportedMediaWithExtenalAppIfNeeded
(
)
;
}
typedef
void
(
HTMLMediaElement
:
:
*
SyncSectionFn
)
(
)
;
class
nsSyncSection
:
public
nsMediaEvent
{
private
:
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
public
:
nsSyncSection
(
HTMLMediaElement
*
aElement
nsIRunnable
*
aRunnable
)
:
nsMediaEvent
(
aElement
)
mRunnable
(
aRunnable
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
IsCancelled
(
)
)
return
NS_OK
;
mRunnable
-
>
Run
(
)
;
return
NS_OK
;
}
}
;
void
HTMLMediaElement
:
:
RunInStableState
(
nsIRunnable
*
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsSyncSection
(
this
aRunnable
)
;
nsContentUtils
:
:
RunInStableState
(
event
.
forget
(
)
)
;
}
void
HTMLMediaElement
:
:
QueueLoadFromSourceTask
(
)
{
ChangeDelayLoadStatus
(
true
)
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
;
RefPtr
<
Runnable
>
r
=
NewRunnableMethod
(
this
&
HTMLMediaElement
:
:
LoadFromSourceChildren
)
;
RunInStableState
(
r
)
;
}
void
HTMLMediaElement
:
:
QueueSelectResourceTask
(
)
{
if
(
mHaveQueuedSelectResource
)
return
;
mHaveQueuedSelectResource
=
true
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_NO_SOURCE
)
;
RefPtr
<
Runnable
>
r
=
NewRunnableMethod
(
this
&
HTMLMediaElement
:
:
SelectResourceWrapper
)
;
RunInStableState
(
r
)
;
}
static
bool
HasSourceChildren
(
nsIContent
*
aElement
)
{
for
(
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
)
{
return
true
;
}
}
return
false
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
Load
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Load
(
)
hasSrcAttrStream
=
%
d
hasSrcAttr
=
%
d
hasSourceChildren
=
%
d
"
"
handlingInput
=
%
d
isCallerChromeOrNative
=
%
d
"
this
!
!
mSrcAttrStream
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
HasSourceChildren
(
this
)
EventStateManager
:
:
IsHandlingUserInput
(
)
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
)
;
if
(
mIsRunningLoadMethod
)
{
return
NS_OK
;
}
mIsDoingExplicitLoad
=
true
;
DoLoad
(
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
DoLoad
(
)
{
if
(
mIsRunningLoadMethod
)
{
return
;
}
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
|
|
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
mHasUserInteraction
=
true
;
}
SetPlayedOrSeeked
(
false
)
;
mIsRunningLoadMethod
=
true
;
AbortExistingLoads
(
)
;
SetPlaybackRate
(
mDefaultPlaybackRate
)
;
QueueSelectResourceTask
(
)
;
ResetState
(
)
;
mIsRunningLoadMethod
=
false
;
}
void
HTMLMediaElement
:
:
ResetState
(
)
{
if
(
mVideoFrameContainer
)
{
mVideoFrameContainer
-
>
ForgetElement
(
)
;
mVideoFrameContainer
=
nullptr
;
}
}
void
HTMLMediaElement
:
:
SelectResourceWrapper
(
)
{
SelectResource
(
)
;
mIsRunningSelectResource
=
false
;
mHaveQueuedSelectResource
=
false
;
mIsDoingExplicitLoad
=
false
;
}
void
HTMLMediaElement
:
:
SelectResource
(
)
{
if
(
!
mSrcAttrStream
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
&
&
!
HasSourceChildren
(
this
)
)
{
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
;
ChangeDelayLoadStatus
(
false
)
;
return
;
}
ChangeDelayLoadStatus
(
true
)
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadstart
"
)
)
;
UpdatePreloadAction
(
)
;
mIsRunningSelectResource
=
true
;
nsAutoString
src
;
if
(
mSrcAttrStream
)
{
SetupSrcMediaStreamPlayback
(
mSrcAttrStream
)
;
}
else
if
(
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NewURIFromString
(
src
getter_AddRefs
(
uri
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Trying
load
from
src
=
%
s
"
this
NS_ConvertUTF16toUTF8
(
src
)
.
get
(
)
)
)
;
NS_ASSERTION
(
!
mIsLoadingFromSourceChildren
"
Should
think
we
'
re
not
loading
from
source
children
by
default
"
)
;
RemoveMediaElementFromURITable
(
)
;
mLoadingSrc
=
uri
;
mMediaSource
=
mSrcMediaSource
;
UpdatePreloadAction
(
)
;
if
(
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_NONE
&
&
!
IsMediaStreamURI
(
mLoadingSrc
)
&
&
!
mMediaSource
)
{
SuspendLoad
(
)
;
return
;
}
rv
=
LoadResource
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
;
}
}
else
{
const
char16_t
*
params
[
]
=
{
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadInvalidURI
"
params
ArrayLength
(
params
)
)
;
}
NoSupportedMediaSourceError
(
)
;
}
else
{
mIsLoadingFromSourceChildren
=
true
;
LoadFromSourceChildren
(
)
;
}
}
void
HTMLMediaElement
:
:
NotifyLoadError
(
)
{
if
(
!
mIsLoadingFromSourceChildren
)
{
LOG
(
LogLevel
:
:
Debug
(
"
NotifyLoadError
(
)
no
supported
media
error
"
)
)
;
NoSupportedMediaSourceError
(
)
;
}
else
if
(
mSourceLoadCandidate
)
{
DispatchAsyncSourceError
(
mSourceLoadCandidate
)
;
QueueLoadFromSourceTask
(
)
;
}
else
{
NS_WARNING
(
"
Should
know
the
source
we
were
loading
from
!
"
)
;
}
}
void
HTMLMediaElement
:
:
NotifyMediaTrackEnabled
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
if
(
!
aTrack
)
{
return
;
}
#
ifdef
DEBUG
nsString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
%
sTrack
with
id
%
s
enabled
"
this
aTrack
-
>
AsAudioTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
#
endif
MOZ_ASSERT
(
(
aTrack
-
>
AsAudioTrack
(
)
&
&
aTrack
-
>
AsAudioTrack
(
)
-
>
Enabled
(
)
)
|
|
(
aTrack
-
>
AsVideoTrack
(
)
&
&
aTrack
-
>
AsVideoTrack
(
)
-
>
Selected
(
)
)
)
;
if
(
aTrack
-
>
AsAudioTrack
(
)
)
{
SetMutedInternal
(
mMuted
&
~
MUTED_BY_AUDIO_TRACK
)
;
}
else
if
(
aTrack
-
>
AsVideoTrack
(
)
)
{
if
(
!
IsVideo
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
mDisableVideo
=
false
;
}
else
{
MOZ_ASSERT
(
false
"
Unknown
track
type
"
)
;
}
if
(
mSrcStream
)
{
if
(
aTrack
-
>
AsVideoTrack
(
)
)
{
MOZ_ASSERT
(
!
mSelectedVideoStreamTrack
)
;
MOZ_ASSERT
(
!
mMediaStreamSizeListener
)
;
mSelectedVideoStreamTrack
=
aTrack
-
>
AsVideoTrack
(
)
-
>
GetVideoStreamTrack
(
)
;
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSrcStreamIsPlaying
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
AddVideoOutput
(
container
)
;
}
HTMLVideoElement
*
self
=
static_cast
<
HTMLVideoElement
*
>
(
this
)
;
if
(
self
-
>
VideoWidth
(
)
<
=
1
&
&
self
-
>
VideoHeight
(
)
<
=
1
)
{
mMediaStreamSizeListener
=
new
StreamSizeListener
(
this
)
;
mSelectedVideoStreamTrack
-
>
AddDirectListener
(
mMediaStreamSizeListener
)
;
}
}
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
return
;
}
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
aTrack
-
>
AsVideoTrack
(
)
&
&
ms
.
mCapturingAudioOnly
)
{
continue
;
}
AddCaptureMediaTrackToOutputStream
(
aTrack
ms
)
;
}
}
}
void
HTMLMediaElement
:
:
NotifyMediaTrackDisabled
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
if
(
!
aTrack
)
{
return
;
}
#
ifdef
DEBUG
nsString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
%
sTrack
with
id
%
s
disabled
"
this
aTrack
-
>
AsAudioTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
#
endif
MOZ_ASSERT
(
(
!
aTrack
-
>
AsAudioTrack
(
)
|
|
!
aTrack
-
>
AsAudioTrack
(
)
-
>
Enabled
(
)
)
&
&
(
!
aTrack
-
>
AsVideoTrack
(
)
|
|
!
aTrack
-
>
AsVideoTrack
(
)
-
>
Selected
(
)
)
)
;
if
(
aTrack
-
>
AsAudioTrack
(
)
)
{
bool
shouldMute
=
true
;
for
(
uint32_t
i
=
0
;
i
<
AudioTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
if
(
(
*
AudioTracks
(
)
)
[
i
]
-
>
Enabled
(
)
)
{
shouldMute
=
false
;
break
;
}
}
if
(
shouldMute
)
{
SetMutedInternal
(
mMuted
|
MUTED_BY_AUDIO_TRACK
)
;
}
}
else
if
(
aTrack
-
>
AsVideoTrack
(
)
)
{
if
(
mSrcStream
)
{
MOZ_ASSERT
(
mSelectedVideoStreamTrack
)
;
if
(
mSelectedVideoStreamTrack
&
&
mMediaStreamSizeListener
)
{
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
mMediaStreamSizeListener
-
>
Forget
(
)
;
mMediaStreamSizeListener
=
nullptr
;
}
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSrcStreamIsPlaying
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
RemoveVideoOutput
(
container
)
;
}
mSelectedVideoStreamTrack
=
nullptr
;
}
}
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
ms
.
mCapturingDecoder
)
{
MOZ_ASSERT
(
!
ms
.
mCapturingMediaStream
)
;
continue
;
}
MOZ_ASSERT
(
ms
.
mCapturingMediaStream
)
;
for
(
int32_t
i
=
ms
.
mTrackPorts
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
ms
.
mTrackPorts
[
i
]
.
first
(
)
=
=
aTrack
-
>
GetId
(
)
)
{
MediaStreamTrack
*
outputTrack
=
ms
.
mStream
-
>
FindOwnedDOMTrack
(
ms
.
mTrackPorts
[
i
]
.
second
(
)
-
>
GetDestination
(
)
ms
.
mTrackPorts
[
i
]
.
second
(
)
-
>
GetDestinationTrackId
(
)
)
;
MOZ_ASSERT
(
outputTrack
)
;
if
(
outputTrack
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
(
outputTrack
&
MediaStreamTrack
:
:
NotifyEnded
)
)
;
}
ms
.
mTrackPorts
[
i
]
.
second
(
)
-
>
Destroy
(
)
;
ms
.
mTrackPorts
.
RemoveElementAt
(
i
)
;
break
;
}
}
#
ifdef
DEBUG
for
(
auto
pair
:
ms
.
mTrackPorts
)
{
MOZ_ASSERT
(
pair
.
first
(
)
!
=
aTrack
-
>
GetId
(
)
"
The
same
MediaTrack
was
forwarded
to
the
output
stream
more
than
once
.
This
shouldn
'
t
happen
.
"
)
;
}
#
endif
}
}
void
HTMLMediaElement
:
:
NotifyMediaStreamTracksAvailable
(
DOMMediaStream
*
aStream
)
{
if
(
!
mSrcStream
|
|
mSrcStream
!
=
aStream
)
{
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
MediaStream
tracks
available
"
this
)
)
;
mSrcStreamTracksAvailable
=
true
;
bool
videoHasChanged
=
IsVideo
(
)
&
&
HasVideo
(
)
!
=
!
VideoTracks
(
)
-
>
IsEmpty
(
)
;
if
(
videoHasChanged
)
{
NotifyOwnerDocumentActivityChanged
(
)
;
}
mWatchManager
.
ManualNotify
(
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
}
void
HTMLMediaElement
:
:
LoadFromSourceChildren
(
)
{
NS_ASSERTION
(
mDelayingLoadEvent
"
Should
delay
load
event
(
if
in
document
)
during
load
"
)
;
NS_ASSERTION
(
mIsLoadingFromSourceChildren
"
Must
remember
we
'
re
loading
from
source
children
"
)
;
nsIDocument
*
parentDoc
=
OwnerDoc
(
)
-
>
GetParentDocument
(
)
;
if
(
parentDoc
)
{
parentDoc
-
>
FlushPendingNotifications
(
Flush_Layout
)
;
}
while
(
true
)
{
nsIContent
*
child
=
GetNextSource
(
)
;
if
(
!
child
)
{
mLoadWaitStatus
=
WAITING_FOR_SOURCE
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_NO_SOURCE
)
;
ChangeDelayLoadStatus
(
false
)
;
ReportLoadError
(
"
MediaLoadExhaustedCandidates
"
)
;
return
;
}
nsAutoString
src
;
if
(
!
child
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
)
{
ReportLoadError
(
"
MediaLoadSourceMissingSrc
"
)
;
DispatchAsyncSourceError
(
child
)
;
continue
;
}
nsAutoString
type
;
if
(
child
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
)
{
DecoderDoctorDiagnostics
diagnostics
;
CanPlayStatus
canPlay
=
GetCanPlay
(
type
&
diagnostics
)
;
diagnostics
.
StoreFormatDiagnostics
(
OwnerDoc
(
)
type
canPlay
!
=
CANPLAY_NO
__func__
)
;
if
(
canPlay
=
=
CANPLAY_NO
)
{
DispatchAsyncSourceError
(
child
)
;
const
char16_t
*
params
[
]
=
{
type
.
get
(
)
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadUnsupportedTypeAttribute
"
params
ArrayLength
(
params
)
)
;
continue
;
}
}
nsAutoString
media
;
HTMLSourceElement
*
childSrc
=
HTMLSourceElement
:
:
FromContent
(
child
)
;
MOZ_ASSERT
(
childSrc
"
Expect
child
to
be
HTMLSourceElement
"
)
;
if
(
childSrc
&
&
!
childSrc
-
>
MatchesCurrentMedia
(
)
)
{
DispatchAsyncSourceError
(
child
)
;
const
char16_t
*
params
[
]
=
{
media
.
get
(
)
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadSourceMediaNotMatched
"
params
ArrayLength
(
params
)
)
;
continue
;
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Trying
load
from
<
source
>
=
%
s
type
=
%
s
media
=
%
s
"
this
NS_ConvertUTF16toUTF8
(
src
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
type
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
media
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NewURIFromString
(
src
getter_AddRefs
(
uri
)
)
;
if
(
!
uri
)
{
DispatchAsyncSourceError
(
child
)
;
const
char16_t
*
params
[
]
=
{
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadInvalidURI
"
params
ArrayLength
(
params
)
)
;
continue
;
}
RemoveMediaElementFromURITable
(
)
;
mLoadingSrc
=
uri
;
mMediaSource
=
childSrc
-
>
GetSrcMediaSource
(
)
;
NS_ASSERTION
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
"
Network
state
should
be
loading
"
)
;
if
(
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_NONE
&
&
!
IsMediaStreamURI
(
mLoadingSrc
)
&
&
!
mMediaSource
)
{
SuspendLoad
(
)
;
return
;
}
if
(
NS_SUCCEEDED
(
LoadResource
(
)
)
)
{
return
;
}
DispatchAsyncSourceError
(
child
)
;
}
NS_NOTREACHED
(
"
Execution
should
not
reach
here
!
"
)
;
}
void
HTMLMediaElement
:
:
SuspendLoad
(
)
{
mSuspendedForPreloadNone
=
true
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_IDLE
)
;
ChangeDelayLoadStatus
(
false
)
;
}
void
HTMLMediaElement
:
:
ResumeLoad
(
PreloadAction
aAction
)
{
NS_ASSERTION
(
mSuspendedForPreloadNone
"
Must
be
halted
for
preload
:
none
to
resume
from
preload
:
none
suspended
load
.
"
)
;
mSuspendedForPreloadNone
=
false
;
mPreloadAction
=
aAction
;
ChangeDelayLoadStatus
(
true
)
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
;
if
(
!
mIsLoadingFromSourceChildren
)
{
if
(
NS_FAILED
(
LoadResource
(
)
)
)
{
NoSupportedMediaSourceError
(
)
;
}
}
else
{
if
(
NS_FAILED
(
LoadResource
(
)
)
)
{
LoadFromSourceChildren
(
)
;
}
}
}
static
bool
IsAutoplayEnabled
(
)
{
return
Preferences
:
:
GetBool
(
"
media
.
autoplay
.
enabled
"
)
;
}
void
HTMLMediaElement
:
:
UpdatePreloadAction
(
)
{
PreloadAction
nextAction
=
PRELOAD_UNDEFINED
;
if
(
(
IsAutoplayEnabled
(
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
)
|
|
!
mPaused
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_ENOUGH
;
}
else
{
const
nsAttrValue
*
val
=
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
preload
kNameSpaceID_None
)
;
uint32_t
preloadDefault
=
mMediaSource
?
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
:
Preferences
:
:
GetInt
(
"
media
.
preload
.
default
"
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
)
;
uint32_t
preloadAuto
=
Preferences
:
:
GetInt
(
"
media
.
preload
.
auto
"
HTMLMediaElement
:
:
PRELOAD_ENOUGH
)
;
if
(
!
val
)
{
nextAction
=
static_cast
<
PreloadAction
>
(
preloadDefault
)
;
}
else
if
(
val
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
PreloadAttrValue
attr
=
static_cast
<
PreloadAttrValue
>
(
val
-
>
GetEnumValue
(
)
)
;
if
(
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_EMPTY
|
|
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_AUTO
)
{
nextAction
=
static_cast
<
PreloadAction
>
(
preloadAuto
)
;
}
else
if
(
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_METADATA
;
}
else
if
(
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_NONE
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_NONE
;
}
}
else
{
nextAction
=
static_cast
<
PreloadAction
>
(
preloadDefault
)
;
}
}
if
(
nextAction
=
=
HTMLMediaElement
:
:
PRELOAD_NONE
&
&
mIsDoingExplicitLoad
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_METADATA
;
}
mPreloadAction
=
nextAction
;
if
(
nextAction
=
=
HTMLMediaElement
:
:
PRELOAD_ENOUGH
)
{
if
(
mSuspendedForPreloadNone
)
{
ResumeLoad
(
PRELOAD_ENOUGH
)
;
}
else
{
StopSuspendingAfterFirstFrame
(
)
;
}
}
else
if
(
nextAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
)
{
mAllowSuspendAfterFirstFrame
=
true
;
if
(
mSuspendedForPreloadNone
)
{
ResumeLoad
(
PRELOAD_METADATA
)
;
}
}
}
nsresult
HTMLMediaElement
:
:
LoadResource
(
)
{
NS_ASSERTION
(
mDelayingLoadEvent
"
Should
delay
load
event
(
if
in
document
)
during
load
"
)
;
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Cancel
(
)
;
mChannelLoader
=
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
if
(
docShell
&
&
!
docShell
-
>
GetAllowMedia
(
)
)
{
return
NS_ERROR_FAILURE
;
}
mCORSMode
=
AttrValueToCORSMode
(
GetParsedAttr
(
nsGkAtoms
:
:
crossorigin
)
)
;
HTMLMediaElement
*
other
=
LookupMediaElementURITable
(
mLoadingSrc
)
;
if
(
other
&
&
other
-
>
mDecoder
)
{
nsresult
rv
=
InitializeDecoderAsClone
(
other
-
>
mDecoder
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
rv
;
}
if
(
IsMediaStreamURI
(
mLoadingSrc
)
)
{
RefPtr
<
DOMMediaStream
>
stream
;
nsresult
rv
=
NS_GetStreamForMediaStreamURI
(
mLoadingSrc
getter_AddRefs
(
stream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoString
spec
;
GetCurrentSrc
(
spec
)
;
const
char16_t
*
params
[
]
=
{
spec
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadInvalidURI
"
params
ArrayLength
(
params
)
)
;
return
rv
;
}
SetupSrcMediaStreamPlayback
(
stream
)
;
return
NS_OK
;
}
if
(
mMediaSource
)
{
RefPtr
<
MediaSourceDecoder
>
decoder
=
new
MediaSourceDecoder
(
this
)
;
if
(
!
mMediaSource
-
>
Attach
(
decoder
)
)
{
decoder
-
>
Shutdown
(
)
;
return
NS_ERROR_FAILURE
;
}
ChangeDelayLoadStatus
(
false
)
;
RefPtr
<
MediaResource
>
resource
=
MediaSourceDecoder
:
:
CreateResource
(
mMediaSource
-
>
GetPrincipal
(
)
)
;
return
FinishDecoderSetup
(
decoder
resource
nullptr
)
;
}
RefPtr
<
ChannelLoader
>
loader
=
new
ChannelLoader
;
nsresult
rv
=
loader
-
>
Load
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mChannelLoader
=
loader
.
forget
(
)
;
}
return
rv
;
}
nsresult
HTMLMediaElement
:
:
LoadWithChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
{
NS_ENSURE_ARG_POINTER
(
aChannel
)
;
NS_ENSURE_ARG_POINTER
(
aListener
)
;
*
aListener
=
nullptr
;
if
(
mIsRunningLoadMethod
)
return
NS_OK
;
mIsRunningLoadMethod
=
true
;
AbortExistingLoads
(
)
;
mIsRunningLoadMethod
=
false
;
nsresult
rv
=
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
mLoadingSrc
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ChangeDelayLoadStatus
(
true
)
;
rv
=
InitializeDecoderForChannel
(
aChannel
aListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
ChangeDelayLoadStatus
(
false
)
;
return
rv
;
}
SetPlaybackRate
(
mDefaultPlaybackRate
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadstart
"
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetReadyState
(
uint16_t
*
aReadyState
)
{
*
aReadyState
=
ReadyState
(
)
;
return
NS_OK
;
}
bool
HTMLMediaElement
:
:
Seeking
(
)
const
{
return
mDecoder
&
&
mDecoder
-
>
IsSeeking
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetSeeking
(
bool
*
aSeeking
)
{
*
aSeeking
=
Seeking
(
)
;
return
NS_OK
;
}
double
HTMLMediaElement
:
:
CurrentTime
(
)
const
{
if
(
MediaStream
*
stream
=
GetSrcMediaStream
(
)
)
{
if
(
mSrcStreamPausedCurrentTime
>
=
0
)
{
return
mSrcStreamPausedCurrentTime
;
}
return
stream
-
>
StreamTimeToSeconds
(
stream
-
>
GetCurrentTime
(
)
)
;
}
if
(
mDefaultPlaybackStartPosition
=
=
0
.
0
&
&
mDecoder
)
{
return
mDecoder
-
>
GetCurrentTime
(
)
;
}
return
mDefaultPlaybackStartPosition
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetCurrentTime
(
double
*
aCurrentTime
)
{
*
aCurrentTime
=
CurrentTime
(
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
FastSeek
(
double
aTime
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Reporting
telemetry
VIDEO_FASTSEEK_USED
"
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_FASTSEEK_USED
1
)
;
RefPtr
<
Promise
>
tobeDropped
=
Seek
(
aTime
SeekTarget
:
:
PrevSyncPoint
aRv
)
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
SeekToNextFrame
(
ErrorResult
&
aRv
)
{
return
Seek
(
CurrentTime
(
)
SeekTarget
:
:
NextFrame
aRv
)
;
}
void
HTMLMediaElement
:
:
SetCurrentTime
(
double
aCurrentTime
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
tobeDropped
=
Seek
(
aCurrentTime
SeekTarget
:
:
Accurate
aRv
)
;
}
static
nsresult
IsInRanges
(
dom
:
:
TimeRanges
&
aRanges
double
aValue
bool
&
aIsInRanges
int32_t
&
aIntervalIndex
)
{
aIsInRanges
=
false
;
uint32_t
length
;
nsresult
rv
=
aRanges
.
GetLength
(
&
length
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
double
start
end
;
rv
=
aRanges
.
Start
(
i
&
start
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
start
>
aValue
)
{
aIntervalIndex
=
i
-
1
;
return
NS_OK
;
}
rv
=
aRanges
.
End
(
i
&
end
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aValue
<
=
end
)
{
aIntervalIndex
=
i
;
aIsInRanges
=
true
;
return
NS_OK
;
}
}
aIntervalIndex
=
length
-
1
;
return
NS_OK
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
mozilla
:
:
IsNaN
(
aTime
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
|
|
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
mHasUserInteraction
=
true
;
}
StopSuspendingAfterFirstFrame
(
)
;
if
(
mSrcStream
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
mPlayed
&
&
mCurrentPlayRangeStart
!
=
-
1
.
0
)
{
double
rangeEndTime
=
CurrentTime
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Adding
\
'
played
\
'
a
range
:
[
%
f
%
f
]
"
this
mCurrentPlayRangeStart
rangeEndTime
)
)
;
if
(
mCurrentPlayRangeStart
!
=
rangeEndTime
)
{
mPlayed
-
>
Add
(
mCurrentPlayRangeStart
rangeEndTime
)
;
}
mCurrentPlayRangeStart
=
-
1
.
0
;
}
if
(
mReadyState
=
=
nsIDOMHTMLMediaElement
:
:
HAVE_NOTHING
)
{
mDefaultPlaybackStartPosition
=
aTime
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
!
mDecoder
)
{
NS_ASSERTION
(
mDecoder
"
SetCurrentTime
failed
:
no
decoder
"
)
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
dom
:
:
TimeRanges
>
seekable
=
new
dom
:
:
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
)
;
media
:
:
TimeIntervals
seekableIntervals
=
mDecoder
-
>
GetSeekable
(
)
;
if
(
seekableIntervals
.
IsInvalid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
seekableIntervals
.
ToTimeRanges
(
seekable
)
;
uint32_t
length
=
0
;
seekable
-
>
GetLength
(
&
length
)
;
if
(
!
length
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
int32_t
range
=
0
;
bool
isInRange
=
false
;
if
(
NS_FAILED
(
IsInRanges
(
*
seekable
aTime
isInRange
range
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
!
isInRange
)
{
if
(
range
!
=
-
1
)
{
if
(
uint32_t
(
range
+
1
)
<
length
)
{
double
leftBound
rightBound
;
if
(
NS_FAILED
(
seekable
-
>
End
(
range
&
leftBound
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
NS_FAILED
(
seekable
-
>
Start
(
range
+
1
&
rightBound
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
double
distanceLeft
=
Abs
(
leftBound
-
aTime
)
;
double
distanceRight
=
Abs
(
rightBound
-
aTime
)
;
if
(
distanceLeft
=
=
distanceRight
)
{
double
currentTime
=
CurrentTime
(
)
;
distanceLeft
=
Abs
(
leftBound
-
currentTime
)
;
distanceRight
=
Abs
(
rightBound
-
currentTime
)
;
}
aTime
=
(
distanceLeft
<
distanceRight
)
?
leftBound
:
rightBound
;
}
else
{
if
(
NS_FAILED
(
seekable
-
>
End
(
length
-
1
&
aTime
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
}
}
else
{
seekable
-
>
Start
(
0
&
aTime
)
;
}
}
mPlayingBeforeSeek
=
IsPotentiallyPlaying
(
)
;
if
(
mPlayingThroughTheAudioChannel
)
{
mPlayingThroughTheAudioChannelBeforeSeek
=
true
;
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetCurrentTime
(
%
f
)
starting
seek
"
this
aTime
)
)
;
nsresult
rv
=
mDecoder
-
>
Seek
(
aTime
aSeekType
promise
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
AddRemoveSelfReference
(
)
;
return
promise
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
SetCurrentTime
(
double
aCurrentTime
)
{
if
(
mozilla
:
:
IsNaN
(
aCurrentTime
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetCurrentTime
(
%
f
)
failed
:
bad
time
"
this
aCurrentTime
)
)
;
return
NS_ERROR_FAILURE
;
}
ErrorResult
rv
;
SetCurrentTime
(
aCurrentTime
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
double
HTMLMediaElement
:
:
Duration
(
)
const
{
if
(
mSrcStream
)
{
return
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
if
(
mDecoder
)
{
return
mDecoder
-
>
GetDuration
(
)
;
}
return
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetDuration
(
double
*
aDuration
)
{
*
aDuration
=
Duration
(
)
;
return
NS_OK
;
}
already_AddRefed
<
TimeRanges
>
HTMLMediaElement
:
:
Seekable
(
)
const
{
RefPtr
<
TimeRanges
>
ranges
=
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
)
;
if
(
mDecoder
)
{
mDecoder
-
>
GetSeekable
(
)
.
ToTimeRanges
(
ranges
)
;
}
return
ranges
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetSeekable
(
nsIDOMTimeRanges
*
*
aSeekable
)
{
RefPtr
<
TimeRanges
>
ranges
=
Seekable
(
)
;
ranges
.
forget
(
aSeekable
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetPaused
(
bool
*
aPaused
)
{
*
aPaused
=
Paused
(
)
;
return
NS_OK
;
}
already_AddRefed
<
TimeRanges
>
HTMLMediaElement
:
:
Played
(
)
{
RefPtr
<
TimeRanges
>
ranges
=
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
)
;
uint32_t
timeRangeCount
=
0
;
if
(
mPlayed
)
{
mPlayed
-
>
GetLength
(
&
timeRangeCount
)
;
}
for
(
uint32_t
i
=
0
;
i
<
timeRangeCount
;
i
+
+
)
{
double
begin
;
double
end
;
mPlayed
-
>
Start
(
i
&
begin
)
;
mPlayed
-
>
End
(
i
&
end
)
;
ranges
-
>
Add
(
begin
end
)
;
}
if
(
mCurrentPlayRangeStart
!
=
-
1
.
0
)
{
double
now
=
CurrentTime
(
)
;
if
(
mCurrentPlayRangeStart
!
=
now
)
{
ranges
-
>
Add
(
mCurrentPlayRangeStart
now
)
;
}
}
ranges
-
>
Normalize
(
)
;
return
ranges
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetPlayed
(
nsIDOMTimeRanges
*
*
aPlayed
)
{
RefPtr
<
TimeRanges
>
ranges
=
Played
(
)
;
ranges
.
forget
(
aPlayed
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
Pause
(
ErrorResult
&
aRv
)
{
if
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Loading
due
to
Pause
(
)
"
)
)
;
DoLoad
(
)
;
}
else
if
(
mDecoder
)
{
mDecoder
-
>
Pause
(
)
;
}
bool
oldPaused
=
mPaused
;
mPaused
=
true
;
mAutoplaying
=
false
;
AddRemoveSelfReference
(
)
;
UpdateSrcMediaStreamPlaying
(
)
;
UpdateAudioChannelPlayingState
(
)
;
if
(
!
oldPaused
)
{
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
pause
"
)
)
;
}
}
NS_IMETHODIMP
HTMLMediaElement
:
:
Pause
(
)
{
ErrorResult
rv
;
Pause
(
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetVolume
(
double
*
aVolume
)
{
*
aVolume
=
Volume
(
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
SetVolume
(
double
aVolume
ErrorResult
&
aRv
)
{
if
(
aVolume
<
0
.
0
|
|
aVolume
>
1
.
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
if
(
aVolume
=
=
mVolume
)
return
;
mVolume
=
aVolume
;
SetVolumeInternal
(
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
volumechange
"
)
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
SetVolume
(
double
aVolume
)
{
ErrorResult
rv
;
SetVolume
(
aVolume
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
HTMLMediaElement
:
:
MozGetMetadata
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
ErrorResult
&
aRv
)
{
if
(
mReadyState
<
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
tags
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
tags
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
mTags
)
{
for
(
auto
iter
=
mTags
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsString
wideValue
=
NS_ConvertUTF8toUTF16
(
iter
.
UserData
(
)
)
;
JS
:
:
Rooted
<
JSString
*
>
string
(
cx
JS_NewUCStringCopyZ
(
cx
wideValue
.
Data
(
)
)
)
;
if
(
!
string
|
|
!
JS_DefineProperty
(
cx
tags
iter
.
Key
(
)
.
Data
(
)
string
JSPROP_ENUMERATE
)
)
{
NS_WARNING
(
"
couldn
'
t
create
metadata
object
!
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
}
aRetval
.
set
(
tags
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MozGetMetadata
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
ErrorResult
rv
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
)
;
MozGetMetadata
(
cx
&
obj
rv
)
;
if
(
!
rv
.
Failed
(
)
)
{
MOZ_ASSERT
(
obj
)
;
aValue
.
setObject
(
*
obj
)
;
}
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetMuted
(
bool
*
aMuted
)
{
*
aMuted
=
Muted
(
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
SetMutedInternal
(
uint32_t
aMuted
)
{
uint32_t
oldMuted
=
mMuted
;
mMuted
=
aMuted
;
if
(
!
!
aMuted
=
=
!
!
oldMuted
)
{
return
;
}
SetVolumeInternal
(
)
;
}
void
HTMLMediaElement
:
:
SetVolumeInternal
(
)
{
float
effectiveVolume
=
ComputedVolume
(
)
;
if
(
mDecoder
)
{
mDecoder
-
>
SetVolume
(
effectiveVolume
)
;
}
else
if
(
MediaStream
*
stream
=
GetSrcMediaStream
(
)
)
{
if
(
mSrcStreamIsPlaying
)
{
stream
-
>
SetAudioOutputVolume
(
this
effectiveVolume
)
;
}
}
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
eVolumeChanged
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
SetMuted
(
bool
aMuted
)
{
if
(
aMuted
=
=
Muted
(
)
)
{
return
NS_OK
;
}
if
(
aMuted
)
{
SetMutedInternal
(
mMuted
|
MUTED_BY_CONTENT
)
;
}
else
{
SetMutedInternal
(
mMuted
&
~
MUTED_BY_CONTENT
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
volumechange
"
)
)
;
return
NS_OK
;
}
class
HTMLMediaElement
:
:
StreamCaptureTrackSource
:
public
MediaStreamTrackSource
public
MediaStreamTrackSource
:
:
Sink
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
StreamCaptureTrackSource
MediaStreamTrackSource
)
explicit
StreamCaptureTrackSource
(
MediaStreamTrackSource
*
aCapturedTrackSource
)
:
MediaStreamTrackSource
(
aCapturedTrackSource
-
>
GetPrincipal
(
)
true
nsString
(
)
)
mCapturedTrackSource
(
aCapturedTrackSource
)
{
mCapturedTrackSource
-
>
RegisterSink
(
this
)
;
}
void
Destroy
(
)
override
{
MOZ_ASSERT
(
mCapturedTrackSource
)
;
if
(
mCapturedTrackSource
)
{
mCapturedTrackSource
-
>
UnregisterSink
(
this
)
;
}
}
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
MediaSourceEnum
:
:
Other
;
}
CORSMode
GetCORSMode
(
)
const
override
{
return
mCapturedTrackSource
-
>
GetCORSMode
(
)
;
}
already_AddRefed
<
PledgeVoid
>
ApplyConstraints
(
nsPIDOMWindowInner
*
aWindow
const
dom
:
:
MediaTrackConstraints
&
aConstraints
)
override
{
RefPtr
<
PledgeVoid
>
p
=
new
PledgeVoid
(
)
;
p
-
>
Reject
(
new
dom
:
:
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
OverconstrainedError
"
)
NS_LITERAL_STRING
(
"
"
)
)
)
;
return
p
.
forget
(
)
;
}
void
Stop
(
)
override
{
NS_ERROR
(
"
We
'
re
reporting
remote
=
true
to
not
be
stoppable
.
"
"
Stop
(
)
should
not
be
called
.
"
)
;
}
void
PrincipalChanged
(
)
override
{
mPrincipal
=
mCapturedTrackSource
-
>
GetPrincipal
(
)
;
MediaStreamTrackSource
:
:
PrincipalChanged
(
)
;
}
private
:
virtual
~
StreamCaptureTrackSource
(
)
{
}
RefPtr
<
MediaStreamTrackSource
>
mCapturedTrackSource
;
}
;
NS_IMPL_ADDREF_INHERITED
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
MediaStreamTrackSource
)
NS_IMPL_RELEASE_INHERITED
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
MediaStreamTrackSource
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
)
NS_INTERFACE_MAP_END_INHERITING
(
MediaStreamTrackSource
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
MediaStreamTrackSource
mCapturedTrackSource
)
class
HTMLMediaElement
:
:
DecoderCaptureTrackSource
:
public
MediaStreamTrackSource
public
DecoderPrincipalChangeObserver
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
DecoderCaptureTrackSource
MediaStreamTrackSource
)
explicit
DecoderCaptureTrackSource
(
HTMLMediaElement
*
aElement
)
:
MediaStreamTrackSource
(
nsCOMPtr
<
nsIPrincipal
>
(
aElement
-
>
GetCurrentPrincipal
(
)
)
.
get
(
)
true
nsString
(
)
)
mElement
(
aElement
)
{
MOZ_ASSERT
(
mElement
)
;
mElement
-
>
AddDecoderPrincipalChangeObserver
(
this
)
;
}
void
Destroy
(
)
override
{
MOZ_ASSERT
(
mElement
)
;
DebugOnly
<
bool
>
res
=
mElement
-
>
RemoveDecoderPrincipalChangeObserver
(
this
)
;
NS_ASSERTION
(
res
"
Removing
decoder
principal
changed
observer
failed
.
"
"
Had
it
already
been
removed
?
"
)
;
}
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
MediaSourceEnum
:
:
Other
;
}
CORSMode
GetCORSMode
(
)
const
override
{
return
mElement
-
>
GetCORSMode
(
)
;
}
already_AddRefed
<
PledgeVoid
>
ApplyConstraints
(
nsPIDOMWindowInner
*
aWindow
const
dom
:
:
MediaTrackConstraints
&
aConstraints
)
override
{
RefPtr
<
PledgeVoid
>
p
=
new
PledgeVoid
(
)
;
p
-
>
Reject
(
new
dom
:
:
MediaStreamError
(
aWindow
NS_LITERAL_STRING
(
"
OverconstrainedError
"
)
NS_LITERAL_STRING
(
"
"
)
)
)
;
return
p
.
forget
(
)
;
}
void
Stop
(
)
override
{
NS_ERROR
(
"
We
'
re
reporting
remote
=
true
to
not
be
stoppable
.
"
"
Stop
(
)
should
not
be
called
.
"
)
;
}
void
NotifyDecoderPrincipalChanged
(
)
override
{
nsCOMPtr
<
nsIPrincipal
>
newPrincipal
=
mElement
-
>
GetCurrentPrincipal
(
)
;
if
(
nsContentUtils
:
:
CombineResourcePrincipals
(
&
mPrincipal
newPrincipal
)
)
{
PrincipalChanged
(
)
;
}
}
protected
:
virtual
~
DecoderCaptureTrackSource
(
)
{
}
RefPtr
<
HTMLMediaElement
>
mElement
;
}
;
NS_IMPL_ADDREF_INHERITED
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
MediaStreamTrackSource
)
NS_IMPL_RELEASE_INHERITED
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
MediaStreamTrackSource
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
)
NS_INTERFACE_MAP_END_INHERITING
(
MediaStreamTrackSource
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
MediaStreamTrackSource
mElement
)
class
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
:
public
MediaStreamTrackSourceGetter
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
)
explicit
CaptureStreamTrackSourceGetter
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
{
}
already_AddRefed
<
dom
:
:
MediaStreamTrackSource
>
GetMediaStreamTrackSource
(
TrackID
aInputTrackID
)
override
{
if
(
mElement
&
&
mElement
-
>
mSrcStream
)
{
NS_ERROR
(
"
Captured
media
element
playing
a
stream
adds
tracks
explicitly
on
main
thread
.
"
)
;
return
nullptr
;
}
return
do_AddRef
(
new
DecoderCaptureTrackSource
(
mElement
)
)
;
}
protected
:
virtual
~
CaptureStreamTrackSourceGetter
(
)
{
}
RefPtr
<
HTMLMediaElement
>
mElement
;
}
;
NS_IMPL_ADDREF_INHERITED
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
)
NS_IMPL_RELEASE_INHERITED
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
)
NS_INTERFACE_MAP_END_INHERITING
(
MediaStreamTrackSourceGetter
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
mElement
)
void
HTMLMediaElement
:
:
SetCapturedOutputStreamsEnabled
(
bool
aEnabled
)
{
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
ms
.
mCapturingDecoder
)
{
MOZ_ASSERT
(
!
ms
.
mCapturingMediaStream
)
;
continue
;
}
for
(
auto
pair
:
ms
.
mTrackPorts
)
{
MediaStream
*
outputSource
=
ms
.
mStream
-
>
GetInputStream
(
)
;
if
(
!
outputSource
)
{
NS_ERROR
(
"
No
output
source
stream
"
)
;
return
;
}
TrackID
id
=
pair
.
second
(
)
-
>
GetDestinationTrackId
(
)
;
outputSource
-
>
SetTrackEnabled
(
id
aEnabled
?
DisabledTrackMode
:
:
ENABLED
:
DisabledTrackMode
:
:
SILENCE_FREEZE
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
s
track
%
d
for
captured
MediaStream
%
p
"
aEnabled
?
"
Enabled
"
:
"
Disabled
"
id
ms
.
mStream
.
get
(
)
)
)
;
}
}
}
void
HTMLMediaElement
:
:
AddCaptureMediaTrackToOutputStream
(
MediaTrack
*
aTrack
OutputMediaStream
&
aOutputStream
bool
aAsyncAddtrack
)
{
if
(
aOutputStream
.
mCapturingDecoder
)
{
MOZ_ASSERT
(
!
aOutputStream
.
mCapturingMediaStream
)
;
return
;
}
aOutputStream
.
mCapturingMediaStream
=
true
;
MediaStream
*
outputSource
=
aOutputStream
.
mStream
-
>
GetInputStream
(
)
;
if
(
!
outputSource
)
{
NS_ERROR
(
"
No
output
source
stream
"
)
;
return
;
}
ProcessedMediaStream
*
processedOutputSource
=
outputSource
-
>
AsProcessedStream
(
)
;
if
(
!
processedOutputSource
)
{
NS_ERROR
(
"
Input
stream
not
a
ProcessedMediaStream
"
)
;
return
;
}
if
(
!
aTrack
)
{
MOZ_ASSERT
(
false
"
Bad
MediaTrack
"
)
;
return
;
}
MediaStreamTrack
*
inputTrack
=
mSrcStream
-
>
GetTrackById
(
aTrack
-
>
GetId
(
)
)
;
MOZ_ASSERT
(
inputTrack
)
;
if
(
!
inputTrack
)
{
NS_ERROR
(
"
Input
track
not
found
in
source
stream
"
)
;
return
;
}
#
if
DEBUG
for
(
auto
pair
:
aOutputStream
.
mTrackPorts
)
{
MOZ_ASSERT
(
pair
.
first
(
)
!
=
aTrack
-
>
GetId
(
)
"
Captured
track
already
captured
to
output
stream
"
)
;
}
#
endif
TrackID
destinationTrackID
=
aOutputStream
.
mNextAvailableTrackID
+
+
;
RefPtr
<
MediaStreamTrackSource
>
source
=
new
StreamCaptureTrackSource
(
&
inputTrack
-
>
GetSource
(
)
)
;
MediaSegment
:
:
Type
type
=
inputTrack
-
>
AsAudioStreamTrack
(
)
?
MediaSegment
:
:
AUDIO
:
MediaSegment
:
:
VIDEO
;
RefPtr
<
MediaStreamTrack
>
track
=
aOutputStream
.
mStream
-
>
CreateDOMTrack
(
destinationTrackID
type
source
)
;
if
(
aAsyncAddtrack
)
{
NS_DispatchToMainThread
(
NewRunnableMethod
<
StorensRefPtrPassByPtr
<
MediaStreamTrack
>
>
(
aOutputStream
.
mStream
&
DOMMediaStream
:
:
AddTrackInternal
track
)
)
;
}
else
{
aOutputStream
.
mStream
-
>
AddTrackInternal
(
track
)
;
}
processedOutputSource
-
>
SetTrackEnabled
(
destinationTrackID
DisabledTrackMode
:
:
SILENCE_FREEZE
)
;
RefPtr
<
MediaInputPort
>
port
=
inputTrack
-
>
ForwardTrackContentsTo
(
processedOutputSource
destinationTrackID
)
;
Pair
<
nsString
RefPtr
<
MediaInputPort
>
>
p
(
aTrack
-
>
GetId
(
)
port
)
;
aOutputStream
.
mTrackPorts
.
AppendElement
(
Move
(
p
)
)
;
if
(
mSrcStreamIsPlaying
)
{
processedOutputSource
-
>
SetTrackEnabled
(
destinationTrackID
DisabledTrackMode
:
:
ENABLED
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
Created
%
s
track
%
p
with
id
%
d
from
track
%
p
through
MediaInputPort
%
p
"
inputTrack
-
>
AsAudioStreamTrack
(
)
?
"
audio
"
:
"
video
"
track
.
get
(
)
destinationTrackID
inputTrack
port
.
get
(
)
)
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
CaptureStreamInternal
(
bool
aFinishWhenEnded
bool
aCaptureAudio
MediaStreamGraph
*
aGraph
)
{
MOZ_RELEASE_ASSERT
(
aGraph
)
;
MarkAsContentSource
(
CallerAPI
:
:
CAPTURE_STREAM
)
;
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
if
(
ContainsRestrictedContent
(
)
)
{
return
nullptr
;
}
if
(
!
mOutputStreams
.
IsEmpty
(
)
&
&
aGraph
!
=
mOutputStreams
[
0
]
.
mStream
-
>
GetInputStream
(
)
-
>
Graph
(
)
)
{
return
nullptr
;
}
OutputMediaStream
*
out
=
mOutputStreams
.
AppendElement
(
)
;
MediaStreamTrackSourceGetter
*
getter
=
new
CaptureStreamTrackSourceGetter
(
this
)
;
out
-
>
mStream
=
DOMMediaStream
:
:
CreateTrackUnionStreamAsInput
(
window
aGraph
getter
)
;
out
-
>
mFinishWhenEnded
=
aFinishWhenEnded
;
out
-
>
mCapturingAudioOnly
=
aCaptureAudio
;
if
(
aCaptureAudio
)
{
if
(
mSrcStream
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
MediaElementAudioCaptureOfMediaStreamError
"
)
;
return
nullptr
;
}
mAudioCaptured
=
true
;
}
if
(
mDecoder
)
{
out
-
>
mCapturingDecoder
=
true
;
mDecoder
-
>
AddOutputStream
(
out
-
>
mStream
-
>
GetInputStream
(
)
-
>
AsProcessedStream
(
)
aFinishWhenEnded
)
;
}
else
if
(
mSrcStream
)
{
out
-
>
mCapturingMediaStream
=
true
;
}
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
RefPtr
<
DOMMediaStream
>
result
=
out
-
>
mStream
;
return
result
.
forget
(
)
;
}
if
(
mDecoder
)
{
if
(
HasAudio
(
)
)
{
TrackID
audioTrackId
=
mMediaInfo
.
mAudio
.
mTrackId
;
RefPtr
<
MediaStreamTrackSource
>
trackSource
=
getter
-
>
GetMediaStreamTrackSource
(
audioTrackId
)
;
RefPtr
<
MediaStreamTrack
>
track
=
out
-
>
mStream
-
>
CreateDOMTrack
(
audioTrackId
MediaSegment
:
:
AUDIO
trackSource
)
;
out
-
>
mStream
-
>
AddTrackInternal
(
track
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Created
audio
track
%
d
for
captured
decoder
"
audioTrackId
)
)
;
}
if
(
IsVideo
(
)
&
&
HasVideo
(
)
&
&
!
out
-
>
mCapturingAudioOnly
)
{
TrackID
videoTrackId
=
mMediaInfo
.
mVideo
.
mTrackId
;
RefPtr
<
MediaStreamTrackSource
>
trackSource
=
getter
-
>
GetMediaStreamTrackSource
(
videoTrackId
)
;
RefPtr
<
MediaStreamTrack
>
track
=
out
-
>
mStream
-
>
CreateDOMTrack
(
videoTrackId
MediaSegment
:
:
VIDEO
trackSource
)
;
out
-
>
mStream
-
>
AddTrackInternal
(
track
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Created
video
track
%
d
for
captured
decoder
"
videoTrackId
)
)
;
}
}
if
(
mSrcStream
)
{
for
(
size_t
i
=
0
;
i
<
AudioTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
AudioTrack
*
t
=
(
*
AudioTracks
(
)
)
[
i
]
;
if
(
t
-
>
Enabled
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
*
out
false
)
;
}
}
if
(
IsVideo
(
)
&
&
!
out
-
>
mCapturingAudioOnly
)
{
for
(
size_t
i
=
0
;
i
<
VideoTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
VideoTrack
*
t
=
(
*
VideoTracks
(
)
)
[
i
]
;
if
(
t
-
>
Selected
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
*
out
false
)
;
}
}
}
}
RefPtr
<
DOMMediaStream
>
result
=
out
-
>
mStream
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
CaptureAudio
(
ErrorResult
&
aRv
MediaStreamGraph
*
aGraph
)
{
MOZ_RELEASE_ASSERT
(
aGraph
)
;
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
false
true
aGraph
)
;
if
(
!
stream
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
MozCaptureStream
(
ErrorResult
&
aRv
)
{
MediaStreamGraph
:
:
GraphDriverType
graphDriverType
=
HasAudio
(
)
?
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
:
MediaStreamGraph
:
:
SYSTEM_THREAD_DRIVER
;
MediaStreamGraph
*
graph
=
MediaStreamGraph
:
:
GetInstance
(
graphDriverType
mAudioChannel
)
;
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
false
false
graph
)
;
if
(
!
stream
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
MozCaptureStreamUntilEnded
(
ErrorResult
&
aRv
)
{
MediaStreamGraph
:
:
GraphDriverType
graphDriverType
=
HasAudio
(
)
?
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
:
MediaStreamGraph
:
:
SYSTEM_THREAD_DRIVER
;
MediaStreamGraph
*
graph
=
MediaStreamGraph
:
:
GetInstance
(
graphDriverType
mAudioChannel
)
;
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
true
false
graph
)
;
if
(
!
stream
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetMozAudioCaptured
(
bool
*
aCaptured
)
{
*
aCaptured
=
MozAudioCaptured
(
)
;
return
NS_OK
;
}
class
MediaElementSetForURI
:
public
nsURIHashKey
{
public
:
explicit
MediaElementSetForURI
(
const
nsIURI
*
aKey
)
:
nsURIHashKey
(
aKey
)
{
}
MediaElementSetForURI
(
const
MediaElementSetForURI
&
toCopy
)
:
nsURIHashKey
(
toCopy
)
mElements
(
toCopy
.
mElements
)
{
}
nsTArray
<
HTMLMediaElement
*
>
mElements
;
}
;
typedef
nsTHashtable
<
MediaElementSetForURI
>
MediaElementURITable
;
static
MediaElementURITable
*
gElementTable
;
#
ifdef
DEBUG
static
bool
URISafeEquals
(
nsIURI
*
a1
nsIURI
*
a2
)
{
if
(
!
a1
|
|
!
a2
)
{
return
false
;
}
bool
equal
=
false
;
nsresult
rv
=
a1
-
>
Equals
(
a2
&
equal
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
equal
;
}
static
unsigned
MediaElementTableCount
(
HTMLMediaElement
*
aElement
nsIURI
*
aURI
)
{
if
(
!
gElementTable
|
|
!
aElement
)
{
return
0
;
}
uint32_t
uriCount
=
0
;
uint32_t
otherCount
=
0
;
for
(
auto
it
=
gElementTable
-
>
ConstIter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
MediaElementSetForURI
*
entry
=
it
.
Get
(
)
;
uint32_t
count
=
0
;
for
(
const
auto
&
elem
:
entry
-
>
mElements
)
{
if
(
elem
=
=
aElement
)
{
count
+
+
;
}
}
if
(
URISafeEquals
(
aURI
entry
-
>
GetKey
(
)
)
)
{
uriCount
=
count
;
}
else
{
otherCount
+
=
count
;
}
}
NS_ASSERTION
(
otherCount
=
=
0
"
Should
not
have
entries
for
unknown
URIs
"
)
;
return
uriCount
;
}
#
endif
void
HTMLMediaElement
:
:
AddMediaElementToURITable
(
)
{
NS_ASSERTION
(
mDecoder
&
&
mDecoder
-
>
GetResource
(
)
"
Call
this
only
with
decoder
Load
called
"
)
;
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
0
"
Should
not
have
entry
for
element
in
element
table
before
addition
"
)
;
if
(
!
gElementTable
)
{
gElementTable
=
new
MediaElementURITable
(
)
;
}
MediaElementSetForURI
*
entry
=
gElementTable
-
>
PutEntry
(
mLoadingSrc
)
;
entry
-
>
mElements
.
AppendElement
(
this
)
;
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
1
"
Should
have
a
single
entry
for
element
in
element
table
after
addition
"
)
;
}
void
HTMLMediaElement
:
:
RemoveMediaElementFromURITable
(
)
{
if
(
!
mDecoder
|
|
!
mLoadingSrc
|
|
!
gElementTable
)
{
return
;
}
MediaElementSetForURI
*
entry
=
gElementTable
-
>
GetEntry
(
mLoadingSrc
)
;
if
(
!
entry
)
{
return
;
}
entry
-
>
mElements
.
RemoveElement
(
this
)
;
if
(
entry
-
>
mElements
.
IsEmpty
(
)
)
{
gElementTable
-
>
RemoveEntry
(
entry
)
;
if
(
gElementTable
-
>
Count
(
)
=
=
0
)
{
delete
gElementTable
;
gElementTable
=
nullptr
;
}
}
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
0
"
After
remove
should
no
longer
have
an
entry
in
element
table
"
)
;
}
HTMLMediaElement
*
HTMLMediaElement
:
:
LookupMediaElementURITable
(
nsIURI
*
aURI
)
{
if
(
!
gElementTable
)
{
return
nullptr
;
}
MediaElementSetForURI
*
entry
=
gElementTable
-
>
GetEntry
(
aURI
)
;
if
(
!
entry
)
{
return
nullptr
;
}
for
(
uint32_t
i
=
0
;
i
<
entry
-
>
mElements
.
Length
(
)
;
+
+
i
)
{
HTMLMediaElement
*
elem
=
entry
-
>
mElements
[
i
]
;
bool
equal
;
if
(
NS_SUCCEEDED
(
elem
-
>
NodePrincipal
(
)
-
>
Equals
(
NodePrincipal
(
)
&
equal
)
)
&
&
equal
&
&
elem
-
>
mCORSMode
=
=
mCORSMode
)
{
NS_ASSERTION
(
elem
-
>
mDecoder
&
&
elem
-
>
mDecoder
-
>
GetResource
(
)
"
Decoder
gone
"
)
;
MediaResource
*
resource
=
elem
-
>
mDecoder
-
>
GetResource
(
)
;
if
(
resource
-
>
CanClone
(
)
)
{
return
elem
;
}
}
}
return
nullptr
;
}
class
HTMLMediaElement
:
:
ShutdownObserver
:
public
nsIObserver
{
enum
class
Phase
:
int8_t
{
Init
Subscribed
Unsubscribed
}
;
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
mPhase
=
=
Phase
:
:
Subscribed
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mWeak
)
;
if
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
mWeak
-
>
NotifyShutdownEvent
(
)
;
}
return
NS_OK
;
}
void
Subscribe
(
HTMLMediaElement
*
aPtr
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPhase
=
=
Phase
:
:
Init
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mWeak
)
;
mWeak
=
aPtr
;
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
mPhase
=
Phase
:
:
Subscribed
;
}
void
Unsubscribe
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPhase
=
=
Phase
:
:
Subscribed
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mWeak
)
;
mWeak
=
nullptr
;
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
mPhase
=
Phase
:
:
Unsubscribed
;
}
void
AddRefMediaElement
(
)
{
mWeak
-
>
AddRef
(
)
;
}
void
ReleaseMediaElement
(
)
{
mWeak
-
>
Release
(
)
;
}
private
:
virtual
~
ShutdownObserver
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPhase
=
=
Phase
:
:
Unsubscribed
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mWeak
)
;
}
HTMLMediaElement
*
mWeak
=
nullptr
;
Phase
mPhase
=
Phase
:
:
Init
;
}
;
NS_IMPL_ISUPPORTS
(
HTMLMediaElement
:
:
ShutdownObserver
nsIObserver
)
HTMLMediaElement
:
:
HTMLMediaElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsGenericHTMLElement
(
aNodeInfo
)
mWatchManager
(
this
AbstractThread
:
:
MainThread
(
)
)
mSrcStreamTracksAvailable
(
false
)
mSrcStreamPausedCurrentTime
(
-
1
)
mShutdownObserver
(
new
ShutdownObserver
)
mCurrentLoadID
(
0
)
mNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
mReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_NOTHING
"
HTMLMediaElement
:
:
mReadyState
"
)
mLoadWaitStatus
(
NOT_WAITING
)
mVolume
(
1
.
0
)
mPreloadAction
(
PRELOAD_UNDEFINED
)
mLastCurrentTime
(
0
.
0
)
mFragmentStart
(
-
1
.
0
)
mFragmentEnd
(
-
1
.
0
)
mDefaultPlaybackRate
(
1
.
0
)
mPlaybackRate
(
1
.
0
)
mPreservesPitch
(
true
)
mPlayed
(
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
)
)
mCurrentPlayRangeStart
(
-
1
.
0
)
mBegun
(
false
)
mLoadedDataFired
(
false
)
mAutoplaying
(
true
)
mAutoplayEnabled
(
true
)
mPaused
(
true
)
mMuted
(
0
)
mAudioChannelSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
mStatsShowing
(
false
)
mAllowCasting
(
false
)
mIsCasting
(
false
)
mAudioCaptured
(
false
)
mAudioCapturedByWindow
(
false
)
mPlayingBeforeSeek
(
false
)
mPlayingThroughTheAudioChannelBeforeSeek
(
false
)
mPausedForInactiveDocumentOrChannel
(
false
)
mEventDeliveryPaused
(
false
)
mIsRunningLoadMethod
(
false
)
mIsDoingExplicitLoad
(
false
)
mIsLoadingFromSourceChildren
(
false
)
mDelayingLoadEvent
(
false
)
mIsRunningSelectResource
(
false
)
mHaveQueuedSelectResource
(
false
)
mSuspendedAfterFirstFrame
(
false
)
mAllowSuspendAfterFirstFrame
(
true
)
mHasPlayedOrSeeked
(
false
)
mHasSelfReference
(
false
)
mShuttingDown
(
false
)
mSuspendedForPreloadNone
(
false
)
mSrcStreamIsPlaying
(
false
)
mMediaSecurityVerified
(
false
)
mCORSMode
(
CORS_NONE
)
mIsEncrypted
(
false
)
mWaitingForKey
(
false
)
mDownloadSuspendedByCache
(
false
"
HTMLMediaElement
:
:
mDownloadSuspendedByCache
"
)
mAudioChannelVolume
(
1
.
0
)
mPlayingThroughTheAudioChannel
(
false
)
mDisableVideo
(
false
)
mHasUserInteraction
(
false
)
mFirstFrameLoaded
(
false
)
mDefaultPlaybackStartPosition
(
0
.
0
)
mIsAudioTrackAudible
(
false
)
mAudible
(
IsAudible
(
)
)
mVisibilityState
(
Visibility
:
:
APPROXIMATELY_NONVISIBLE
)
{
ErrorResult
rv
;
double
defaultVolume
=
Preferences
:
:
GetFloat
(
"
media
.
default_volume
"
1
.
0
)
;
SetVolume
(
defaultVolume
rv
)
;
mAudioChannel
=
AudioChannelService
:
:
GetDefaultAudioChannel
(
)
;
mPaused
.
SetOuter
(
this
)
;
RegisterActivityObserver
(
)
;
NotifyOwnerDocumentActivityChanged
(
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mWatchManager
.
Watch
(
mDownloadSuspendedByCache
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
mWatchManager
.
Watch
(
mReadyState
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
mShutdownObserver
-
>
Subscribe
(
this
)
;
}
HTMLMediaElement
:
:
~
HTMLMediaElement
(
)
{
NS_ASSERTION
(
!
mHasSelfReference
"
How
can
we
be
destroyed
if
we
'
re
still
holding
a
self
reference
?
"
)
;
mShutdownObserver
-
>
Unsubscribe
(
)
;
if
(
mVideoFrameContainer
)
{
mVideoFrameContainer
-
>
ForgetElement
(
)
;
}
UnregisterActivityObserver
(
)
;
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
if
(
mProgressTimer
)
{
StopProgress
(
)
;
}
if
(
mVideoDecodeSuspendTimer
)
{
mVideoDecodeSuspendTimer
-
>
Cancel
(
)
;
mVideoDecodeSuspendTimer
=
nullptr
;
}
if
(
mSrcStream
)
{
EndSrcMediaStreamPlayback
(
)
;
}
if
(
mCaptureStreamPort
)
{
mCaptureStreamPort
-
>
Destroy
(
)
;
mCaptureStreamPort
=
nullptr
;
}
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
0
"
Destroyed
media
element
should
no
longer
be
in
element
table
"
)
;
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Cancel
(
)
;
}
WakeLockRelease
(
)
;
}
void
HTMLMediaElement
:
:
StopSuspendingAfterFirstFrame
(
)
{
mAllowSuspendAfterFirstFrame
=
false
;
if
(
!
mSuspendedAfterFirstFrame
)
return
;
mSuspendedAfterFirstFrame
=
false
;
if
(
mDecoder
)
{
mDecoder
-
>
Resume
(
)
;
}
}
void
HTMLMediaElement
:
:
SetPlayedOrSeeked
(
bool
aValue
)
{
if
(
aValue
=
=
mHasPlayedOrSeeked
)
{
return
;
}
mHasPlayedOrSeeked
=
aValue
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
;
}
frame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
frame
nsIPresShell
:
:
eTreeChange
NS_FRAME_IS_DIRTY
)
;
}
void
HTMLMediaElement
:
:
NotifyXPCOMShutdown
(
)
{
ShutdownDecoder
(
)
;
}
void
HTMLMediaElement
:
:
Play
(
ErrorResult
&
aRv
)
{
nsresult
rv
=
PlayInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
nsresult
HTMLMediaElement
:
:
PlayInternal
(
)
{
if
(
!
IsAllowedToPlay
(
)
)
{
return
NS_OK
;
}
mHasUserInteraction
=
true
;
StopSuspendingAfterFirstFrame
(
)
;
SetPlayedOrSeeked
(
true
)
;
if
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
{
DoLoad
(
)
;
}
if
(
mSuspendedForPreloadNone
)
{
ResumeLoad
(
PRELOAD_ENOUGH
)
;
}
if
(
mDecoder
)
{
if
(
mDecoder
-
>
IsEnded
(
)
)
{
SetCurrentTime
(
0
)
;
}
if
(
!
mPausedForInactiveDocumentOrChannel
)
{
nsresult
rv
=
mDecoder
-
>
Play
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
mCurrentPlayRangeStart
=
=
-
1
.
0
)
{
mCurrentPlayRangeStart
=
CurrentTime
(
)
;
}
bool
oldPaused
=
mPaused
;
mPaused
=
false
;
mAutoplaying
=
false
;
SetAudioChannelSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
AddRemoveSelfReference
(
)
;
UpdatePreloadAction
(
)
;
UpdateSrcMediaStreamPlaying
(
)
;
UpdateAudioChannelPlayingState
(
)
;
OpenUnsupportedMediaWithExtenalAppIfNeeded
(
)
;
if
(
oldPaused
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
play
"
)
)
;
switch
(
mReadyState
)
{
case
nsIDOMHTMLMediaElement
:
:
HAVE_NOTHING
:
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
break
;
case
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
:
case
nsIDOMHTMLMediaElement
:
:
HAVE_CURRENT_DATA
:
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
break
;
case
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
:
case
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
:
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
playing
"
)
)
;
break
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
Play
(
)
{
return
PlayInternal
(
)
;
}
HTMLMediaElement
:
:
WakeLockBoolWrapper
&
HTMLMediaElement
:
:
WakeLockBoolWrapper
:
:
operator
=
(
bool
val
)
{
if
(
mValue
=
=
val
)
{
return
*
this
;
}
mValue
=
val
;
UpdateWakeLock
(
)
;
return
*
this
;
}
HTMLMediaElement
:
:
WakeLockBoolWrapper
:
:
~
WakeLockBoolWrapper
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
void
HTMLMediaElement
:
:
WakeLockBoolWrapper
:
:
SetCanPlay
(
bool
aCanPlay
)
{
mCanPlay
=
aCanPlay
;
UpdateWakeLock
(
)
;
}
void
HTMLMediaElement
:
:
WakeLockBoolWrapper
:
:
UpdateWakeLock
(
)
{
if
(
!
mOuter
)
{
return
;
}
bool
playing
=
(
!
mValue
&
&
mCanPlay
)
;
if
(
playing
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
mOuter
-
>
WakeLockCreate
(
)
;
}
else
if
(
!
mTimer
)
{
int
timeout
=
Preferences
:
:
GetInt
(
"
media
.
wakelock_timeout
"
2000
)
;
mTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
)
;
if
(
mTimer
)
{
mTimer
-
>
InitWithFuncCallback
(
TimerCallback
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
}
}
void
HTMLMediaElement
:
:
WakeLockBoolWrapper
:
:
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
WakeLockBoolWrapper
*
wakeLock
=
static_cast
<
WakeLockBoolWrapper
*
>
(
aClosure
)
;
wakeLock
-
>
mOuter
-
>
WakeLockRelease
(
)
;
wakeLock
-
>
mTimer
=
nullptr
;
}
void
HTMLMediaElement
:
:
WakeLockCreate
(
)
{
if
(
!
mWakeLock
)
{
RefPtr
<
power
:
:
PowerManagerService
>
pmService
=
power
:
:
PowerManagerService
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE_VOID
(
pmService
)
;
ErrorResult
rv
;
mWakeLock
=
pmService
-
>
NewWakeLock
(
NS_LITERAL_STRING
(
"
cpu
"
)
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
rv
)
;
}
}
void
HTMLMediaElement
:
:
WakeLockRelease
(
)
{
if
(
mWakeLock
)
{
ErrorResult
rv
;
mWakeLock
-
>
Unlock
(
rv
)
;
rv
.
SuppressException
(
)
;
mWakeLock
=
nullptr
;
}
}
HTMLMediaElement
:
:
OutputMediaStream
:
:
OutputMediaStream
(
)
:
mFinishWhenEnded
(
false
)
mCapturingAudioOnly
(
false
)
mCapturingDecoder
(
false
)
mCapturingMediaStream
(
false
)
mNextAvailableTrackID
(
1
)
{
}
HTMLMediaElement
:
:
OutputMediaStream
:
:
~
OutputMediaStream
(
)
{
for
(
auto
pair
:
mTrackPorts
)
{
pair
.
second
(
)
-
>
Destroy
(
)
;
}
}
bool
HTMLMediaElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsIAtom
*
aAttribute
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
static
const
nsAttrValue
:
:
EnumTable
kPreloadTable
[
]
=
{
{
"
"
HTMLMediaElement
:
:
PRELOAD_ATTR_EMPTY
}
{
"
none
"
HTMLMediaElement
:
:
PRELOAD_ATTR_NONE
}
{
"
metadata
"
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
}
{
"
auto
"
HTMLMediaElement
:
:
PRELOAD_ATTR_AUTO
}
{
nullptr
0
}
}
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
ParseImageAttribute
(
aAttribute
aValue
aResult
)
)
{
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
crossorigin
)
{
ParseCORSValue
(
aValue
aResult
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
preload
)
{
return
aResult
.
ParseEnumValue
(
aValue
kPreloadTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
mozaudiochannel
)
{
const
nsAttrValue
:
:
EnumTable
*
table
=
AudioChannelService
:
:
GetAudioChannelTable
(
)
;
MOZ_ASSERT
(
table
)
;
bool
parsed
=
aResult
.
ParseEnumValue
(
aValue
table
false
&
table
[
0
]
)
;
if
(
!
parsed
)
{
return
false
;
}
AudioChannel
audioChannel
=
static_cast
<
AudioChannel
>
(
aResult
.
GetEnumValue
(
)
)
;
if
(
audioChannel
=
=
mAudioChannel
|
|
!
CheckAudioChannelPermissions
(
aValue
)
)
{
return
true
;
}
if
(
mDecoder
)
{
return
true
;
}
mAudioChannel
=
audioChannel
;
if
(
mSrcStream
)
{
RefPtr
<
MediaStream
>
stream
=
GetSrcMediaStream
(
)
;
if
(
stream
)
{
stream
-
>
SetAudioChannelType
(
mAudioChannel
)
;
}
}
return
true
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aResult
)
;
}
bool
HTMLMediaElement
:
:
CheckAudioChannelPermissions
(
const
nsAString
&
aString
)
{
if
(
aString
.
EqualsASCII
(
"
normal
"
)
)
{
return
true
;
}
nsString
audioChannel
;
AudioChannelService
:
:
GetDefaultAudioChannelString
(
audioChannel
)
;
if
(
audioChannel
.
Equals
(
aString
)
)
{
return
true
;
}
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
services
:
:
GetPermissionManager
(
)
;
if
(
!
permissionManager
)
{
return
false
;
}
uint32_t
perm
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
permissionManager
-
>
TestExactPermissionFromPrincipal
(
NodePrincipal
(
)
nsCString
(
NS_LITERAL_CSTRING
(
"
audio
-
channel
-
"
)
+
NS_ConvertUTF16toUTF8
(
aString
)
)
.
get
(
)
&
perm
)
;
if
(
perm
!
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
return
false
;
}
return
true
;
}
void
HTMLMediaElement
:
:
DoneCreatingElement
(
)
{
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
muted
)
)
{
mMuted
|
=
MUTED_BY_CONTENT
;
}
}
bool
HTMLMediaElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
nsGenericHTMLElement
:
:
IsHTMLFocusable
(
aWithMouse
aIsFocusable
aTabIndex
)
)
{
return
true
;
}
*
aIsFocusable
=
true
;
return
false
;
}
int32_t
HTMLMediaElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
nsresult
HTMLMediaElement
:
:
SetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
nsIAtom
*
aPrefix
const
nsAString
&
aValue
bool
aNotify
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
SetAttr
(
aNameSpaceID
aName
aPrefix
aValue
aNotify
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
src
)
{
DoLoad
(
)
;
}
if
(
aNotify
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
autoplay
)
{
StopSuspendingAfterFirstFrame
(
)
;
CheckAutoplayDataReady
(
)
;
AddRemoveSelfReference
(
)
;
UpdatePreloadAction
(
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
preload
)
{
UpdatePreloadAction
(
)
;
}
}
return
rv
;
}
nsresult
HTMLMediaElement
:
:
UnsetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aAttr
bool
aNotify
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
UnsetAttr
(
aNameSpaceID
aAttr
aNotify
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
aNotify
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
autoplay
)
{
AddRemoveSelfReference
(
)
;
UpdatePreloadAction
(
)
;
}
else
if
(
aAttr
=
=
nsGkAtoms
:
:
preload
)
{
UpdatePreloadAction
(
)
;
}
}
return
rv
;
}
nsresult
HTMLMediaElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsIAtom
*
aName
const
nsAttrValue
*
aValue
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
src
)
{
mSrcMediaSource
=
nullptr
;
if
(
aValue
)
{
nsString
srcStr
=
aValue
-
>
GetStringValue
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NewURIFromString
(
srcStr
getter_AddRefs
(
uri
)
)
;
if
(
uri
&
&
IsMediaSourceURI
(
uri
)
)
{
nsresult
rv
=
NS_GetSourceForMediaSourceURI
(
uri
getter_AddRefs
(
mSrcMediaSource
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoString
spec
;
GetCurrentSrc
(
spec
)
;
const
char16_t
*
params
[
]
=
{
spec
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadInvalidURI
"
params
ArrayLength
(
params
)
)
;
}
}
}
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLMediaElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
bool
aCompileEventHandlers
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
aCompileEventHandlers
)
;
mUnboundFromTree
=
false
;
if
(
aDocument
)
{
mAutoplayEnabled
=
IsAutoplayEnabled
(
)
&
&
(
!
aDocument
|
|
!
aDocument
-
>
IsStaticDocument
(
)
)
&
&
!
IsEditable
(
)
;
UpdatePreloadAction
(
)
;
}
if
(
mDecoder
)
{
mDecoder
-
>
NotifyOwnerActivityChanged
(
!
IsHidden
(
)
)
;
}
return
rv
;
}
void
HTMLMediaElement
:
:
VideoDecodeSuspendTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
element
=
static_cast
<
HTMLMediaElement
*
>
(
aClosure
)
;
element
-
>
mVideoDecodeSuspendTime
.
Start
(
)
;
element
-
>
mVideoDecodeSuspendTimer
=
nullptr
;
}
void
HTMLMediaElement
:
:
HiddenVideoStart
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHiddenPlayTime
.
Start
(
)
;
if
(
mVideoDecodeSuspendTimer
)
{
return
;
}
mVideoDecodeSuspendTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
)
;
mVideoDecodeSuspendTimer
-
>
InitWithNamedFuncCallback
(
VideoDecodeSuspendTimerCallback
this
MediaPrefs
:
:
MDSMSuspendBackgroundVideoDelay
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
HTMLMediaElement
:
:
VideoDecodeSuspendTimerCallback
"
)
;
}
void
HTMLMediaElement
:
:
HiddenVideoStop
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHiddenPlayTime
.
Pause
(
)
;
mVideoDecodeSuspendTime
.
Pause
(
)
;
if
(
!
mVideoDecodeSuspendTimer
)
{
return
;
}
mVideoDecodeSuspendTimer
-
>
Cancel
(
)
;
mVideoDecodeSuspendTimer
=
nullptr
;
}
void
HTMLMediaElement
:
:
ReportEMETelemetry
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
if
(
mIsEncrypted
&
&
Preferences
:
:
GetBool
(
"
media
.
eme
.
enabled
"
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_EME_PLAY_SUCCESS
mLoadedDataFired
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_EME_PLAY_SUCCESS
=
%
s
"
this
mLoadedDataFired
?
"
true
"
:
"
false
"
)
)
;
}
}
void
HTMLMediaElement
:
:
ReportTelemetry
(
)
{
enum
UnloadedState
{
ENDED
=
0
PAUSED
=
1
STALLED
=
2
SEEKING
=
3
OTHER
=
4
}
;
UnloadedState
state
=
OTHER
;
if
(
Seeking
(
)
)
{
state
=
SEEKING
;
}
else
if
(
Ended
(
)
)
{
state
=
ENDED
;
}
else
if
(
Paused
(
)
)
{
state
=
PAUSED
;
}
else
{
bool
stalled
=
false
;
RefPtr
<
TimeRanges
>
ranges
=
Buffered
(
)
;
const
double
errorMargin
=
0
.
05
;
double
t
=
CurrentTime
(
)
;
TimeRanges
:
:
index_type
index
=
ranges
-
>
Find
(
t
errorMargin
)
;
ErrorResult
ignore
;
stalled
=
index
!
=
TimeRanges
:
:
NoIndex
&
&
(
ranges
-
>
End
(
index
ignore
)
-
t
)
<
errorMargin
;
stalled
|
=
mDecoder
&
&
NextFrameStatus
(
)
=
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_BUFFERING
&
&
mReadyState
=
=
HTMLMediaElement
:
:
HAVE_CURRENT_DATA
;
if
(
stalled
)
{
state
=
STALLED
;
}
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_UNLOAD_STATE
state
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_UNLOAD_STATE
=
%
d
"
this
state
)
)
;
FrameStatisticsData
data
;
if
(
HTMLVideoElement
*
vid
=
HTMLVideoElement
:
:
FromContentOrNull
(
this
)
)
{
FrameStatistics
*
stats
=
vid
-
>
GetFrameStatistics
(
)
;
if
(
stats
)
{
data
=
stats
-
>
GetFrameStatisticsData
(
)
;
if
(
data
.
mParsedFrames
)
{
MOZ_ASSERT
(
data
.
mDroppedFrames
<
=
data
.
mParsedFrames
)
;
uint32_t
percentage
=
100
*
data
.
mDroppedFrames
/
data
.
mParsedFrames
;
LOG
(
LogLevel
:
:
Debug
(
"
Reporting
telemetry
DROPPED_FRAMES_IN_VIDEO_PLAYBACK
"
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_DROPPED_FRAMES_PROPORTION
percentage
)
;
}
}
}
if
(
mMediaInfo
.
HasVideo
(
)
&
&
mMediaInfo
.
mVideo
.
mImage
.
height
>
0
)
{
double
playTime
=
mPlayTime
.
Total
(
)
;
double
hiddenPlayTime
=
mHiddenPlayTime
.
Total
(
)
;
double
videoDecodeSuspendTime
=
mVideoDecodeSuspendTime
.
Total
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_PLAY_TIME_MS
SECONDS_TO_MS
(
playTime
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_PLAY_TIME_MS
=
%
f
"
this
playTime
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_HIDDEN_PLAY_TIME_MS
SECONDS_TO_MS
(
hiddenPlayTime
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_HIDDEN_PLAY_TIME_MS
=
%
f
"
this
hiddenPlayTime
)
)
;
if
(
playTime
>
0
.
0
)
{
nsCString
key
(
mMediaInfo
.
HasAudio
(
)
?
"
AV
"
:
"
V
"
)
;
static
const
struct
{
int32_t
mH
;
const
char
*
mRes
;
}
sResolutions
[
]
=
{
{
240
"
0
<
h
<
=
240
"
}
{
480
"
240
<
h
<
=
480
"
}
{
576
"
480
<
h
<
=
576
"
}
{
720
"
576
<
h
<
=
720
"
}
{
1080
"
720
<
h
<
=
1080
"
}
{
2160
"
1080
<
h
<
=
2160
"
}
}
;
const
char
*
resolution
=
"
h
>
2160
"
;
int32_t
height
=
mMediaInfo
.
mVideo
.
mImage
.
height
;
for
(
const
auto
&
res
:
sResolutions
)
{
if
(
height
<
=
res
.
mH
)
{
resolution
=
res
.
mRes
;
break
;
}
}
key
.
AppendASCII
(
resolution
)
;
uint32_t
hiddenPercentage
=
uint32_t
(
hiddenPlayTime
/
playTime
*
100
.
0
+
0
.
5
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_HIDDEN_PLAY_TIME_PERCENTAGE
key
hiddenPercentage
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_HIDDEN_PLAY_TIME_PERCENTAGE
NS_LITERAL_CSTRING
(
"
All
"
)
hiddenPercentage
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_HIDDEN_PLAY_TIME_PERCENTAGE
=
%
u
keys
:
'
%
s
'
and
'
All
'
"
this
hiddenPercentage
key
.
get
(
)
)
)
;
uint32_t
videoDecodeSuspendPercentage
=
uint32_t
(
videoDecodeSuspendTime
/
playTime
*
100
.
0
+
0
.
5
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INFERRED_DECODE_SUSPEND_PERCENTAGE
key
videoDecodeSuspendPercentage
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INFERRED_DECODE_SUSPEND_PERCENTAGE
NS_LITERAL_CSTRING
(
"
All
"
)
videoDecodeSuspendPercentage
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INFERRED_DECODE_SUSPEND_PERCENTAGE
=
%
u
keys
:
'
%
s
'
and
'
All
'
"
this
videoDecodeSuspendPercentage
key
.
get
(
)
)
)
;
if
(
data
.
mInterKeyframeCount
!
=
0
)
{
uint32_t
average_ms
=
uint32_t
(
std
:
:
min
<
uint64_t
>
(
double
(
data
.
mInterKeyframeSum_us
)
/
double
(
data
.
mInterKeyframeCount
)
/
1000
.
0
+
0
.
5
UINT32_MAX
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_AVERAGE_MS
key
average_ms
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_AVERAGE_MS
NS_LITERAL_CSTRING
(
"
All
"
)
average_ms
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INTER_KEYFRAME_AVERAGE_MS
=
%
u
keys
:
'
%
s
'
and
'
All
'
"
this
average_ms
key
.
get
(
)
)
)
;
uint32_t
max_ms
=
uint32_t
(
std
:
:
min
<
uint64_t
>
(
(
data
.
mInterKeyFrameMax_us
+
500
)
/
1000
UINT32_MAX
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
key
max_ms
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
NS_LITERAL_CSTRING
(
"
All
"
)
max_ms
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INTER_KEYFRAME_MAX_MS
=
%
u
keys
:
'
%
s
'
and
'
All
'
"
this
max_ms
key
.
get
(
)
)
)
;
}
else
{
uint32_t
suspendDelay_ms
=
MediaPrefs
:
:
MDSMSuspendBackgroundVideoDelay
(
)
;
if
(
uint32_t
(
playTime
*
1000
.
0
)
>
suspendDelay_ms
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
key
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
NS_LITERAL_CSTRING
(
"
All
"
)
0
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INTER_KEYFRAME_MAX_MS
=
0
(
only
1
keyframe
)
keys
:
'
%
s
'
and
'
All
'
"
this
key
.
get
(
)
)
)
;
}
}
}
}
}
void
HTMLMediaElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
mUnboundFromTree
=
true
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
if
(
mDecoder
)
{
MOZ_ASSERT
(
IsHidden
(
)
)
;
mDecoder
-
>
NotifyOwnerActivityChanged
(
false
)
;
}
RefPtr
<
HTMLMediaElement
>
self
(
this
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
[
self
]
(
)
{
if
(
self
-
>
mUnboundFromTree
&
&
self
-
>
mNetworkState
!
=
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
{
self
-
>
Pause
(
)
;
}
}
)
;
RunInStableState
(
task
)
;
}
CanPlayStatus
HTMLMediaElement
:
:
GetCanPlay
(
const
nsAString
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
MediaContentType
contentType
{
aType
}
;
return
DecoderTraits
:
:
CanHandleContentType
(
contentType
aDiagnostics
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
CanPlayType
(
const
nsAString
&
aType
nsAString
&
aResult
)
{
DecoderDoctorDiagnostics
diagnostics
;
CanPlayStatus
canPlay
=
GetCanPlay
(
aType
&
diagnostics
)
;
diagnostics
.
StoreFormatDiagnostics
(
OwnerDoc
(
)
aType
canPlay
!
=
CANPLAY_NO
__func__
)
;
switch
(
canPlay
)
{
case
CANPLAY_NO
:
aResult
.
Truncate
(
)
;
break
;
case
CANPLAY_YES
:
aResult
.
AssignLiteral
(
"
probably
"
)
;
break
;
default
:
case
CANPLAY_MAYBE
:
aResult
.
AssignLiteral
(
"
maybe
"
)
;
break
;
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
CanPlayType
(
%
s
)
=
\
"
%
s
\
"
"
this
NS_ConvertUTF16toUTF8
(
aType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aResult
)
.
get
(
)
)
)
;
return
NS_OK
;
}
nsresult
HTMLMediaElement
:
:
InitializeDecoderAsClone
(
MediaDecoder
*
aOriginal
)
{
NS_ASSERTION
(
mLoadingSrc
"
mLoadingSrc
must
already
be
set
"
)
;
NS_ASSERTION
(
mDecoder
=
=
nullptr
"
Shouldn
'
t
have
a
decoder
"
)
;
MediaResource
*
originalResource
=
aOriginal
-
>
GetResource
(
)
;
if
(
!
originalResource
)
return
NS_ERROR_FAILURE
;
RefPtr
<
MediaDecoder
>
decoder
=
aOriginal
-
>
Clone
(
this
)
;
if
(
!
decoder
)
return
NS_ERROR_FAILURE
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Cloned
decoder
%
p
from
%
p
"
this
decoder
.
get
(
)
aOriginal
)
)
;
decoder
-
>
SetMediaSeekable
(
aOriginal
-
>
IsMediaSeekable
(
)
)
;
decoder
-
>
SetMediaSeekableOnlyInBufferedRanges
(
aOriginal
-
>
IsMediaSeekableOnlyInBufferedRanges
(
)
)
;
RefPtr
<
MediaResource
>
resource
=
originalResource
-
>
CloneData
(
decoder
-
>
GetResourceCallback
(
)
)
;
if
(
!
resource
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Failed
to
cloned
stream
for
decoder
%
p
"
this
decoder
.
get
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
return
FinishDecoderSetup
(
decoder
resource
nullptr
)
;
}
nsresult
HTMLMediaElement
:
:
InitializeDecoderForChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
{
NS_ASSERTION
(
mLoadingSrc
"
mLoadingSrc
must
already
be
set
"
)
;
NS_ASSERTION
(
mDecoder
=
=
nullptr
"
Shouldn
'
t
have
a
decoder
"
)
;
nsAutoCString
mimeType
;
aChannel
-
>
GetContentType
(
mimeType
)
;
NS_ASSERTION
(
!
mimeType
.
IsEmpty
(
)
"
We
should
have
the
Content
-
Type
.
"
)
;
DecoderDoctorDiagnostics
diagnostics
;
RefPtr
<
MediaDecoder
>
decoder
=
DecoderTraits
:
:
CreateDecoder
(
mimeType
this
&
diagnostics
)
;
diagnostics
.
StoreFormatDiagnostics
(
OwnerDoc
(
)
NS_ConvertASCIItoUTF16
(
mimeType
)
decoder
!
=
nullptr
__func__
)
;
if
(
!
decoder
)
{
nsAutoString
src
;
GetCurrentSrc
(
src
)
;
NS_ConvertUTF8toUTF16
mimeUTF16
(
mimeType
)
;
const
char16_t
*
params
[
]
=
{
mimeUTF16
.
get
(
)
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadUnsupportedMimeType
"
params
ArrayLength
(
params
)
)
;
return
NS_ERROR_FAILURE
;
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Created
decoder
%
p
for
type
%
s
"
this
decoder
.
get
(
)
mimeType
.
get
(
)
)
)
;
RefPtr
<
MediaResource
>
resource
=
MediaResource
:
:
Create
(
decoder
-
>
GetResourceCallback
(
)
aChannel
)
;
if
(
!
resource
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Done
(
)
;
mChannelLoader
=
nullptr
;
}
return
FinishDecoderSetup
(
decoder
resource
aListener
)
;
}
nsresult
HTMLMediaElement
:
:
FinishDecoderSetup
(
MediaDecoder
*
aDecoder
MediaResource
*
aStream
nsIStreamListener
*
*
aListener
)
{
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
;
mMediaSecurityVerified
=
false
;
SetDecoder
(
aDecoder
)
;
mDecoder
-
>
SetResource
(
aStream
)
;
mDecoder
-
>
SetAudioChannel
(
mAudioChannel
)
;
mDecoder
-
>
SetVolume
(
mMuted
?
0
.
0
:
mVolume
)
;
mDecoder
-
>
SetPreservesPitch
(
mPreservesPitch
)
;
mDecoder
-
>
SetPlaybackRate
(
mPlaybackRate
)
;
if
(
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
)
{
mDecoder
-
>
SetMinimizePrerollUntilPlaybackStarts
(
)
;
}
NotifyDecoderPrincipalChanged
(
)
;
nsresult
rv
=
aDecoder
-
>
Load
(
aListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
ShutdownDecoder
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Failed
to
load
for
decoder
%
p
"
this
aDecoder
)
)
;
return
rv
;
}
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
ms
.
mCapturingMediaStream
)
{
MOZ_ASSERT
(
!
ms
.
mCapturingDecoder
)
;
continue
;
}
ms
.
mCapturingDecoder
=
true
;
aDecoder
-
>
AddOutputStream
(
ms
.
mStream
-
>
GetInputStream
(
)
-
>
AsProcessedStream
(
)
ms
.
mFinishWhenEnded
)
;
}
if
(
mMediaKeys
)
{
if
(
mMediaKeys
-
>
GetCDMProxy
(
)
)
{
mDecoder
-
>
SetCDMProxy
(
mMediaKeys
-
>
GetCDMProxy
(
)
)
;
}
else
{
ShutdownDecoder
(
)
;
return
NS_ERROR_FAILURE
;
}
}
MediaEventSource
<
void
>
*
waitingForKeyProducer
=
mDecoder
-
>
WaitingForKeyEvent
(
)
;
if
(
waitingForKeyProducer
)
{
mWaitingForKeyListener
=
waitingForKeyProducer
-
>
Connect
(
AbstractThread
:
:
MainThread
(
)
this
&
HTMLMediaElement
:
:
CannotDecryptWaitingForKey
)
;
}
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Done
(
)
;
mChannelLoader
=
nullptr
;
}
AddMediaElementToURITable
(
)
;
NotifyOwnerDocumentActivityChanged
(
)
;
UpdateAudioChannelPlayingState
(
)
;
if
(
!
mPaused
)
{
SetPlayedOrSeeked
(
true
)
;
if
(
!
mPausedForInactiveDocumentOrChannel
)
{
rv
=
mDecoder
-
>
Play
(
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
ShutdownDecoder
(
)
;
}
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
=
=
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
1
)
"
Media
element
should
have
single
table
entry
if
decode
initialized
"
)
;
return
rv
;
}
class
HTMLMediaElement
:
:
StreamListener
:
public
MediaStreamListener
public
WatchTarget
{
public
:
explicit
StreamListener
(
HTMLMediaElement
*
aElement
const
char
*
aName
)
:
WatchTarget
(
aName
)
mElement
(
aElement
)
mHaveCurrentData
(
false
)
mBlocked
(
false
)
mFinished
(
false
)
mMutex
(
aName
)
mPendingNotifyOutput
(
false
)
{
}
void
Forget
(
)
{
mElement
=
nullptr
;
}
void
DoNotifyFinished
(
)
{
mFinished
=
true
;
if
(
mElement
)
{
RefPtr
<
HTMLMediaElement
>
deathGrip
=
mElement
;
mElement
=
nullptr
;
NotifyWatchers
(
)
;
deathGrip
-
>
PlaybackEnded
(
)
;
}
}
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
{
if
(
!
mElement
|
|
!
mHaveCurrentData
|
|
mFinished
)
{
return
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
;
}
return
mBlocked
?
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_BUFFERING
:
MediaDecoderOwner
:
:
NEXT_FRAME_AVAILABLE
;
}
void
DoNotifyBlocked
(
)
{
mBlocked
=
true
;
NotifyWatchers
(
)
;
}
void
DoNotifyUnblocked
(
)
{
mBlocked
=
false
;
NotifyWatchers
(
)
;
}
void
DoNotifyOutput
(
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
mPendingNotifyOutput
=
false
;
}
if
(
mElement
&
&
mHaveCurrentData
)
{
RefPtr
<
HTMLMediaElement
>
kungFuDeathGrip
=
mElement
;
kungFuDeathGrip
-
>
FireTimeUpdate
(
true
)
;
}
}
void
DoNotifyHaveCurrentData
(
)
{
mHaveCurrentData
=
true
;
if
(
mElement
)
{
RefPtr
<
HTMLMediaElement
>
kungFuDeathGrip
=
mElement
;
kungFuDeathGrip
-
>
FirstFrameLoaded
(
)
;
}
NotifyWatchers
(
)
;
DoNotifyOutput
(
)
;
}
virtual
void
NotifyBlockingChanged
(
MediaStreamGraph
*
aGraph
Blocking
aBlocked
)
override
{
nsCOMPtr
<
nsIRunnable
>
event
;
if
(
aBlocked
=
=
BLOCKED
)
{
event
=
NewRunnableMethod
(
this
&
StreamListener
:
:
DoNotifyBlocked
)
;
}
else
{
event
=
NewRunnableMethod
(
this
&
StreamListener
:
:
DoNotifyUnblocked
)
;
}
aGraph
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
event
.
forget
(
)
)
;
}
virtual
void
NotifyEvent
(
MediaStreamGraph
*
aGraph
MediaStreamGraphEvent
event
)
override
{
if
(
event
=
=
MediaStreamGraphEvent
:
:
EVENT_FINISHED
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
this
&
StreamListener
:
:
DoNotifyFinished
)
;
aGraph
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
event
.
forget
(
)
)
;
}
}
virtual
void
NotifyHasCurrentData
(
MediaStreamGraph
*
aGraph
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
this
&
StreamListener
:
:
DoNotifyHaveCurrentData
)
;
aGraph
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
event
.
forget
(
)
)
;
}
virtual
void
NotifyOutput
(
MediaStreamGraph
*
aGraph
GraphTime
aCurrentTime
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mPendingNotifyOutput
)
return
;
mPendingNotifyOutput
=
true
;
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
this
&
StreamListener
:
:
DoNotifyOutput
)
;
aGraph
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
event
.
forget
(
)
)
;
}
private
:
HTMLMediaElement
*
mElement
;
bool
mHaveCurrentData
;
bool
mBlocked
;
bool
mFinished
;
Mutex
mMutex
;
bool
mPendingNotifyOutput
;
}
;
class
HTMLMediaElement
:
:
MediaStreamTracksAvailableCallback
:
public
OnTracksAvailableCallback
{
public
:
explicit
MediaStreamTracksAvailableCallback
(
HTMLMediaElement
*
aElement
)
:
OnTracksAvailableCallback
(
)
mElement
(
aElement
)
{
}
virtual
void
NotifyTracksAvailable
(
DOMMediaStream
*
aStream
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
mElement
-
>
NotifyMediaStreamTracksAvailable
(
aStream
)
;
}
private
:
HTMLMediaElement
*
mElement
;
}
;
class
HTMLMediaElement
:
:
MediaStreamTrackListener
:
public
DOMMediaStream
:
:
TrackListener
{
public
:
explicit
MediaStreamTrackListener
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
{
}
void
NotifyTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
mElement
-
>
NotifyMediaStreamTrackAdded
(
aTrack
)
;
}
void
NotifyTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
mElement
-
>
NotifyMediaStreamTrackRemoved
(
aTrack
)
;
}
protected
:
HTMLMediaElement
*
const
mElement
;
}
;
void
HTMLMediaElement
:
:
UpdateSrcMediaStreamPlaying
(
uint32_t
aFlags
)
{
if
(
!
mSrcStream
)
{
return
;
}
MediaStream
*
stream
=
GetSrcMediaStream
(
)
;
bool
shouldPlay
=
!
(
aFlags
&
REMOVING_SRC_STREAM
)
&
&
!
mPaused
&
&
!
mPausedForInactiveDocumentOrChannel
&
&
stream
;
if
(
shouldPlay
=
=
mSrcStreamIsPlaying
)
{
return
;
}
mSrcStreamIsPlaying
=
shouldPlay
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
%
s
playback
of
DOMMediaStream
%
p
"
this
shouldPlay
?
"
Setting
up
"
:
"
Removing
"
mSrcStream
.
get
(
)
)
)
;
if
(
shouldPlay
)
{
mSrcStreamPausedCurrentTime
=
-
1
;
mMediaStreamListener
=
new
StreamListener
(
this
"
HTMLMediaElement
:
:
mMediaStreamListener
"
)
;
stream
-
>
AddListener
(
mMediaStreamListener
)
;
mWatchManager
.
Watch
(
*
mMediaStreamListener
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
stream
-
>
AddAudioOutput
(
this
)
;
SetVolumeInternal
(
)
;
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSelectedVideoStreamTrack
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
AddVideoOutput
(
container
)
;
}
SetCapturedOutputStreamsEnabled
(
true
)
;
}
else
{
if
(
stream
)
{
mSrcStreamPausedCurrentTime
=
CurrentTime
(
)
;
stream
-
>
RemoveListener
(
mMediaStreamListener
)
;
stream
-
>
RemoveAudioOutput
(
this
)
;
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSelectedVideoStreamTrack
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
RemoveVideoOutput
(
container
)
;
}
SetCapturedOutputStreamsEnabled
(
false
)
;
}
mWatchManager
.
Unwatch
(
*
mMediaStreamListener
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
mMediaStreamListener
-
>
Forget
(
)
;
mMediaStreamListener
=
nullptr
;
}
SetAudibleState
(
shouldPlay
)
;
}
void
HTMLMediaElement
:
:
SetupSrcMediaStreamPlayback
(
DOMMediaStream
*
aStream
)
{
NS_ASSERTION
(
!
mSrcStream
&
&
!
mMediaStreamListener
&
&
!
mMediaStreamSizeListener
"
Should
have
been
ended
already
"
)
;
mSrcStream
=
aStream
;
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
RefPtr
<
MediaStream
>
stream
=
GetSrcMediaStream
(
)
;
if
(
stream
)
{
stream
-
>
SetAudioChannelType
(
mAudioChannel
)
;
}
UpdateSrcMediaStreamPlaying
(
)
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
tracks
;
mSrcStream
-
>
GetTracks
(
tracks
)
;
for
(
const
RefPtr
<
MediaStreamTrack
>
&
track
:
tracks
)
{
NotifyMediaStreamTrackAdded
(
track
)
;
}
mSrcStream
-
>
OnTracksAvailable
(
new
MediaStreamTracksAvailableCallback
(
this
)
)
;
mMediaStreamTrackListener
=
new
MediaStreamTrackListener
(
this
)
;
mSrcStream
-
>
RegisterTrackListener
(
mMediaStreamTrackListener
)
;
mSrcStream
-
>
AddPrincipalChangeObserver
(
this
)
;
mSrcStreamVideoPrincipal
=
mSrcStream
-
>
GetVideoPrincipal
(
)
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_IDLE
)
;
ChangeDelayLoadStatus
(
false
)
;
CheckAutoplayDataReady
(
)
;
}
void
HTMLMediaElement
:
:
EndSrcMediaStreamPlayback
(
)
{
MOZ_ASSERT
(
mSrcStream
)
;
UpdateSrcMediaStreamPlaying
(
REMOVING_SRC_STREAM
)
;
if
(
mMediaStreamSizeListener
)
{
MOZ_ASSERT
(
mSelectedVideoStreamTrack
)
;
if
(
mSelectedVideoStreamTrack
)
{
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
}
mMediaStreamSizeListener
-
>
Forget
(
)
;
}
mSelectedVideoStreamTrack
=
nullptr
;
mMediaStreamSizeListener
=
nullptr
;
mSrcStream
-
>
UnregisterTrackListener
(
mMediaStreamTrackListener
)
;
mMediaStreamTrackListener
=
nullptr
;
mSrcStreamTracksAvailable
=
false
;
mSrcStream
-
>
RemovePrincipalChangeObserver
(
this
)
;
mSrcStreamVideoPrincipal
=
nullptr
;
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
for
(
auto
pair
:
ms
.
mTrackPorts
)
{
pair
.
second
(
)
-
>
Destroy
(
)
;
}
ms
.
mTrackPorts
.
Clear
(
)
;
}
mSrcStream
=
nullptr
;
}
static
already_AddRefed
<
AudioTrack
>
CreateAudioTrack
(
AudioStreamTrack
*
aStreamTrack
)
{
nsAutoString
id
;
nsAutoString
label
;
aStreamTrack
-
>
GetId
(
id
)
;
aStreamTrack
-
>
GetLabel
(
label
)
;
return
MediaTrackList
:
:
CreateAudioTrack
(
id
NS_LITERAL_STRING
(
"
main
"
)
label
EmptyString
(
)
true
)
;
}
static
already_AddRefed
<
VideoTrack
>
CreateVideoTrack
(
VideoStreamTrack
*
aStreamTrack
)
{
nsAutoString
id
;
nsAutoString
label
;
aStreamTrack
-
>
GetId
(
id
)
;
aStreamTrack
-
>
GetLabel
(
label
)
;
return
MediaTrackList
:
:
CreateVideoTrack
(
id
NS_LITERAL_STRING
(
"
main
"
)
label
EmptyString
(
)
aStreamTrack
)
;
}
void
HTMLMediaElement
:
:
NotifyMediaStreamTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
if
(
aTrack
-
>
Ended
(
)
)
{
return
;
}
#
ifdef
DEBUG
nsString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Adding
%
sTrack
with
id
%
s
"
this
aTrack
-
>
AsAudioStreamTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
#
endif
if
(
AudioStreamTrack
*
t
=
aTrack
-
>
AsAudioStreamTrack
(
)
)
{
RefPtr
<
AudioTrack
>
audioTrack
=
CreateAudioTrack
(
t
)
;
AudioTracks
(
)
-
>
AddTrack
(
audioTrack
)
;
}
else
if
(
VideoStreamTrack
*
t
=
aTrack
-
>
AsVideoStreamTrack
(
)
)
{
if
(
!
IsVideo
(
)
)
{
return
;
}
RefPtr
<
VideoTrack
>
videoTrack
=
CreateVideoTrack
(
t
)
;
VideoTracks
(
)
-
>
AddTrack
(
videoTrack
)
;
if
(
VideoTracks
(
)
-
>
SelectedIndex
(
)
=
=
-
1
)
{
MOZ_ASSERT
(
!
mSelectedVideoStreamTrack
)
;
videoTrack
-
>
SetEnabledInternal
(
true
MediaTrack
:
:
FIRE_NO_EVENTS
)
;
}
}
mWatchManager
.
ManualNotify
(
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
}
void
HTMLMediaElement
:
:
NotifyMediaStreamTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
nsAutoString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Removing
%
sTrack
with
id
%
s
"
this
aTrack
-
>
AsAudioStreamTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
if
(
MediaTrack
*
t
=
AudioTracks
(
)
-
>
GetTrackById
(
id
)
)
{
AudioTracks
(
)
-
>
RemoveTrack
(
t
)
;
}
else
if
(
MediaTrack
*
t
=
VideoTracks
(
)
-
>
GetTrackById
(
id
)
)
{
VideoTracks
(
)
-
>
RemoveTrack
(
t
)
;
}
else
{
return
;
}
}
void
HTMLMediaElement
:
:
ProcessMediaFragmentURI
(
)
{
nsMediaFragmentURIParser
parser
(
mLoadingSrc
)
;
if
(
mDecoder
&
&
parser
.
HasEndTime
(
)
)
{
mFragmentEnd
=
parser
.
GetEndTime
(
)
;
}
if
(
parser
.
HasStartTime
(
)
)
{
SetCurrentTime
(
parser
.
GetStartTime
(
)
)
;
mFragmentStart
=
parser
.
GetStartTime
(
)
;
}
}
void
HTMLMediaElement
:
:
MetadataLoaded
(
const
MediaInfo
*
aInfo
nsAutoPtr
<
const
MetadataTags
>
aTags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
AutoNotifyAudioChannelAgent
autoNotify
(
this
)
;
SetMediaInfo
(
*
aInfo
)
;
mIsEncrypted
=
aInfo
-
>
IsEncrypted
(
)
|
|
mPendingEncryptedInitData
.
IsEncrypted
(
)
;
mTags
=
aTags
.
forget
(
)
;
mLoadedDataFired
=
false
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
durationchange
"
)
)
;
if
(
IsVideo
(
)
&
&
HasVideo
(
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
resize
"
)
)
;
}
NS_ASSERTION
(
!
HasVideo
(
)
|
|
(
mMediaInfo
.
mVideo
.
mDisplay
.
width
>
0
&
&
mMediaInfo
.
mVideo
.
mDisplay
.
height
>
0
)
"
Video
resolution
must
be
known
on
'
loadedmetadata
'
"
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadedmetadata
"
)
)
;
if
(
mDecoder
&
&
mDecoder
-
>
IsTransportSeekable
(
)
&
&
mDecoder
-
>
IsMediaSeekable
(
)
)
{
ProcessMediaFragmentURI
(
)
;
mDecoder
-
>
SetFragmentEndTime
(
mFragmentEnd
)
;
}
if
(
mIsEncrypted
)
{
if
(
!
mMediaSource
&
&
Preferences
:
:
GetBool
(
"
media
.
eme
.
mse
-
only
"
true
)
)
{
DecodeError
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
"
Encrypted
content
not
supported
outside
of
MSE
"
)
)
;
return
;
}
for
(
const
auto
&
initData
:
mPendingEncryptedInitData
.
mInitDatas
)
{
DispatchEncrypted
(
initData
.
mInitData
initData
.
mType
)
;
}
mPendingEncryptedInitData
.
mInitDatas
.
Clear
(
)
;
}
mWatchManager
.
ManualNotify
(
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
if
(
IsVideo
(
)
&
&
aInfo
-
>
HasVideo
(
)
)
{
NotifyOwnerDocumentActivityChanged
(
)
;
}
if
(
mDefaultPlaybackStartPosition
!
=
0
.
0
)
{
SetCurrentTime
(
mDefaultPlaybackStartPosition
)
;
mDefaultPlaybackStartPosition
=
0
.
0
;
}
if
(
!
mSrcStream
)
{
return
;
}
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
for
(
size_t
i
=
0
;
i
<
AudioTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
AudioTrack
*
t
=
(
*
AudioTracks
(
)
)
[
i
]
;
if
(
t
-
>
Enabled
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
ms
)
;
}
}
if
(
IsVideo
(
)
&
&
!
ms
.
mCapturingAudioOnly
)
{
for
(
size_t
i
=
0
;
i
<
VideoTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
VideoTrack
*
t
=
(
*
VideoTracks
(
)
)
[
i
]
;
if
(
t
-
>
Selected
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
ms
)
;
}
}
}
}
}
void
HTMLMediaElement
:
:
FirstFrameLoaded
(
)
{
NS_ASSERTION
(
!
mSuspendedAfterFirstFrame
"
Should
not
have
already
suspended
"
)
;
if
(
!
mFirstFrameLoaded
)
{
mFirstFrameLoaded
=
true
;
UpdateReadyStateInternal
(
)
;
}
ChangeDelayLoadStatus
(
false
)
;
if
(
mDecoder
&
&
mAllowSuspendAfterFirstFrame
&
&
mPaused
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
&
&
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
)
{
mSuspendedAfterFirstFrame
=
true
;
mDecoder
-
>
Suspend
(
)
;
}
}
void
HTMLMediaElement
:
:
NetworkError
(
)
{
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
if
(
mReadyState
=
=
nsIDOMHTMLMediaElement
:
:
HAVE_NOTHING
)
{
NoSupportedMediaSourceError
(
)
;
}
else
{
Error
(
MEDIA_ERR_NETWORK
)
;
}
}
void
HTMLMediaElement
:
:
DecodeError
(
const
MediaResult
&
aError
)
{
nsAutoString
src
;
GetCurrentSrc
(
src
)
;
const
char16_t
*
params
[
]
=
{
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadDecodeError
"
params
ArrayLength
(
params
)
)
;
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
RemoveMediaElementFromURITable
(
)
;
mLoadingSrc
=
nullptr
;
mMediaSource
=
nullptr
;
AudioTracks
(
)
-
>
EmptyTracks
(
)
;
VideoTracks
(
)
-
>
EmptyTracks
(
)
;
if
(
mIsLoadingFromSourceChildren
)
{
mError
=
nullptr
;
if
(
mSourceLoadCandidate
)
{
DispatchAsyncSourceError
(
mSourceLoadCandidate
)
;
QueueLoadFromSourceTask
(
)
;
}
else
{
NS_WARNING
(
"
Should
know
the
source
we
were
loading
from
!
"
)
;
}
}
else
if
(
mReadyState
=
=
nsIDOMHTMLMediaElement
:
:
HAVE_NOTHING
)
{
NoSupportedMediaSourceError
(
aError
.
Description
(
)
)
;
}
else
{
Error
(
MEDIA_ERR_DECODE
aError
.
Description
(
)
)
;
}
}
bool
HTMLMediaElement
:
:
HasError
(
)
const
{
return
GetError
(
)
;
}
void
HTMLMediaElement
:
:
LoadAborted
(
)
{
Error
(
MEDIA_ERR_ABORTED
)
;
}
void
HTMLMediaElement
:
:
Error
(
uint16_t
aErrorCode
const
nsACString
&
aErrorDetails
)
{
NS_ASSERTION
(
aErrorCode
=
=
MEDIA_ERR_DECODE
|
|
aErrorCode
=
=
MEDIA_ERR_NETWORK
|
|
aErrorCode
=
=
MEDIA_ERR_ABORTED
"
Only
use
MediaError
codes
!
"
)
;
if
(
mError
)
{
return
;
}
mError
=
new
MediaError
(
this
aErrorCode
aErrorDetails
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
error
"
)
)
;
if
(
mReadyState
=
=
HAVE_NOTHING
&
&
aErrorCode
=
=
MEDIA_ERR_ABORTED
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
abort
"
)
)
;
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
emptied
"
)
)
;
}
else
{
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_IDLE
)
;
}
ChangeDelayLoadStatus
(
false
)
;
UpdateAudioChannelPlayingState
(
)
;
}
void
HTMLMediaElement
:
:
PlaybackEnded
(
)
{
AddRemoveSelfReference
(
)
;
NS_ASSERTION
(
!
mDecoder
|
|
mDecoder
-
>
IsEnded
(
)
"
Decoder
fired
ended
but
not
in
ended
state
"
)
;
for
(
int32_t
i
=
mOutputStreams
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mOutputStreams
[
i
]
.
mFinishWhenEnded
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Playback
ended
.
Removing
output
stream
%
p
"
mOutputStreams
[
i
]
.
mStream
.
get
(
)
)
)
;
mOutputStreams
.
RemoveElementAt
(
i
)
;
}
}
if
(
mSrcStream
|
|
(
mDecoder
&
&
mDecoder
-
>
IsInfinite
(
)
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
got
duration
by
reaching
the
end
of
the
resource
"
this
)
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
durationchange
"
)
)
;
}
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loop
)
)
{
SetCurrentTime
(
0
)
;
return
;
}
Pause
(
)
;
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
ended
"
)
)
;
}
void
HTMLMediaElement
:
:
SeekStarted
(
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
seeking
"
)
)
;
}
void
HTMLMediaElement
:
:
SeekCompleted
(
)
{
mPlayingBeforeSeek
=
false
;
SetPlayedOrSeeked
(
true
)
;
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
DidSeek
(
)
;
}
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
seeked
"
)
)
;
AddRemoveSelfReference
(
)
;
if
(
mCurrentPlayRangeStart
=
=
-
1
.
0
)
{
mCurrentPlayRangeStart
=
CurrentTime
(
)
;
}
mPlayingThroughTheAudioChannelBeforeSeek
=
false
;
}
void
HTMLMediaElement
:
:
NotifySuspendedByCache
(
bool
aIsSuspended
)
{
mDownloadSuspendedByCache
=
aIsSuspended
;
}
void
HTMLMediaElement
:
:
DownloadSuspended
(
)
{
if
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
progress
"
)
)
;
}
if
(
mBegun
)
{
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_IDLE
)
;
}
}
void
HTMLMediaElement
:
:
DownloadResumed
(
bool
aForceNetworkLoading
)
{
if
(
mBegun
|
|
aForceNetworkLoading
)
{
ChangeNetworkState
(
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
;
}
}
void
HTMLMediaElement
:
:
CheckProgress
(
bool
aHaveNewProgress
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
;
TimeStamp
now
=
TimeStamp
:
:
NowLoRes
(
)
;
if
(
aHaveNewProgress
)
{
mDataTime
=
now
;
}
NS_ASSERTION
(
(
mProgressTime
.
IsNull
(
)
&
&
!
aHaveNewProgress
)
|
|
!
mDataTime
.
IsNull
(
)
"
null
TimeStamp
mDataTime
should
not
be
used
in
comparison
"
)
;
if
(
mProgressTime
.
IsNull
(
)
?
aHaveNewProgress
:
(
now
-
mProgressTime
>
=
TimeDuration
:
:
FromMilliseconds
(
PROGRESS_MS
)
&
&
mDataTime
>
mProgressTime
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
progress
"
)
)
;
mProgressTime
=
now
-
TimeDuration
:
:
Resolution
(
)
;
if
(
mDataTime
>
mProgressTime
)
{
mDataTime
=
mProgressTime
;
}
if
(
!
mProgressTimer
)
{
NS_ASSERTION
(
aHaveNewProgress
"
timer
dispatched
when
there
was
no
timer
"
)
;
StartProgressTimer
(
)
;
if
(
!
mLoadedDataFired
)
{
ChangeDelayLoadStatus
(
true
)
;
}
}
UpdateReadyStateInternal
(
)
;
}
if
(
now
-
mDataTime
>
=
TimeDuration
:
:
FromMilliseconds
(
STALL_MS
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
stalled
"
)
)
;
if
(
mMediaSource
)
{
ChangeDelayLoadStatus
(
false
)
;
}
NS_ASSERTION
(
mProgressTimer
"
detected
stalled
without
timer
"
)
;
StopProgress
(
)
;
}
AddRemoveSelfReference
(
)
;
}
void
HTMLMediaElement
:
:
ProgressTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
auto
decoder
=
static_cast
<
HTMLMediaElement
*
>
(
aClosure
)
;
decoder
-
>
CheckProgress
(
false
)
;
}
void
HTMLMediaElement
:
:
StartProgressTimer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
;
NS_ASSERTION
(
!
mProgressTimer
"
Already
started
progress
timer
.
"
)
;
mProgressTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
)
;
mProgressTimer
-
>
InitWithNamedFuncCallback
(
ProgressTimerCallback
this
PROGRESS_MS
nsITimer
:
:
TYPE_REPEATING_SLACK
"
HTMLMediaElement
:
:
ProgressTimerCallback
"
)
;
}
void
HTMLMediaElement
:
:
StartProgress
(
)
{
mDataTime
=
TimeStamp
:
:
NowLoRes
(
)
;
mProgressTime
=
TimeStamp
(
)
;
StartProgressTimer
(
)
;
}
void
HTMLMediaElement
:
:
StopProgress
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mProgressTimer
)
{
return
;
}
mProgressTimer
-
>
Cancel
(
)
;
mProgressTimer
=
nullptr
;
}
void
HTMLMediaElement
:
:
DownloadProgressed
(
)
{
if
(
mNetworkState
!
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
{
return
;
}
CheckProgress
(
true
)
;
}
bool
HTMLMediaElement
:
:
ShouldCheckAllowOrigin
(
)
{
return
mCORSMode
!
=
CORS_NONE
;
}
bool
HTMLMediaElement
:
:
IsCORSSameOrigin
(
)
{
bool
subsumes
;
RefPtr
<
nsIPrincipal
>
principal
=
GetCurrentPrincipal
(
)
;
return
(
NS_SUCCEEDED
(
NodePrincipal
(
)
-
>
Subsumes
(
principal
&
subsumes
)
)
&
&
subsumes
)
|
|
ShouldCheckAllowOrigin
(
)
;
}
void
HTMLMediaElement
:
:
UpdateReadyStateInternal
(
)
{
if
(
!
mDecoder
&
&
!
mSrcStream
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Not
initialized
"
this
)
)
;
return
;
}
if
(
mDecoder
&
&
mReadyState
<
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Decoder
ready
state
<
HAVE_METADATA
"
this
)
)
;
return
;
}
if
(
mSrcStream
&
&
mReadyState
<
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
)
{
if
(
!
mSrcStreamTracksAvailable
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
MediaStreamTracks
not
available
yet
"
this
)
)
;
return
;
}
bool
hasAudioTracks
=
!
AudioTracks
(
)
-
>
IsEmpty
(
)
;
bool
hasVideoTracks
=
!
VideoTracks
(
)
-
>
IsEmpty
(
)
;
if
(
!
hasAudioTracks
&
&
!
hasVideoTracks
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Stream
with
no
tracks
"
this
)
)
;
return
;
}
if
(
IsVideo
(
)
&
&
hasVideoTracks
&
&
!
HasVideo
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Stream
waiting
for
video
"
this
)
)
;
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
Stream
has
"
"
metadata
;
audioTracks
=
%
d
videoTracks
=
%
d
"
"
hasVideoFrame
=
%
d
"
this
AudioTracks
(
)
-
>
Length
(
)
VideoTracks
(
)
-
>
Length
(
)
HasVideo
(
)
)
)
;
MediaInfo
mediaInfo
=
mMediaInfo
;
if
(
hasAudioTracks
)
{
mediaInfo
.
EnableAudio
(
)
;
}
if
(
hasVideoTracks
)
{
mediaInfo
.
EnableVideo
(
)
;
}
MetadataLoaded
(
&
mediaInfo
nsAutoPtr
<
const
MetadataTags
>
(
nullptr
)
)
;
}
enum
NextFrameStatus
nextFrameStatus
=
NextFrameStatus
(
)
;
if
(
mDecoder
&
&
nextFrameStatus
=
=
NEXT_FRAME_UNAVAILABLE
)
{
nextFrameStatus
=
mDecoder
-
>
NextFrameBufferedStatus
(
)
;
}
if
(
nextFrameStatus
=
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_SEEKING
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
NEXT_FRAME_UNAVAILABLE_SEEKING
;
Forcing
HAVE_METADATA
"
this
)
)
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
)
;
return
;
}
if
(
IsVideo
(
)
&
&
HasVideo
(
)
&
&
!
IsPlaybackEnded
(
)
&
&
GetImageContainer
(
)
&
&
!
GetImageContainer
(
)
-
>
HasCurrentImage
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Playing
video
but
no
video
frame
;
Forcing
HAVE_METADATA
"
this
)
)
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
)
;
return
;
}
if
(
mDownloadSuspendedByCache
&
&
mDecoder
&
&
!
mDecoder
-
>
IsEnded
(
)
&
&
mFirstFrameLoaded
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Decoder
download
suspended
by
cache
"
this
)
)
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
)
;
return
;
}
if
(
nextFrameStatus
!
=
MediaDecoderOwner
:
:
NEXT_FRAME_AVAILABLE
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Next
frame
not
available
"
this
)
)
;
if
(
mFirstFrameLoaded
)
{
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_CURRENT_DATA
)
;
}
return
;
}
if
(
!
mFirstFrameLoaded
)
{
return
;
}
if
(
mSrcStream
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Stream
HAVE_ENOUGH_DATA
"
this
)
)
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
)
;
return
;
}
if
(
mDecoder
-
>
CanPlayThrough
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Decoder
can
play
through
"
this
)
)
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
)
;
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Default
;
Decoder
has
future
data
"
this
)
)
;
ChangeReadyState
(
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
)
;
}
static
const
char
*
const
gReadyStateToString
[
]
=
{
"
HAVE_NOTHING
"
"
HAVE_METADATA
"
"
HAVE_CURRENT_DATA
"
"
HAVE_FUTURE_DATA
"
"
HAVE_ENOUGH_DATA
"
}
;
void
HTMLMediaElement
:
:
ChangeReadyState
(
nsMediaReadyState
aState
)
{
nsMediaReadyState
oldState
=
mReadyState
;
mReadyState
=
aState
;
if
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
|
|
oldState
=
=
mReadyState
)
{
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Ready
state
changed
to
%
s
"
this
gReadyStateToString
[
aState
]
)
)
;
UpdateAudioChannelPlayingState
(
)
;
if
(
mPlayingBeforeSeek
&
&
mReadyState
<
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
}
else
if
(
oldState
>
=
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
&
&
mReadyState
<
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
&
&
!
Paused
(
)
&
&
!
Ended
(
)
&
&
!
mError
)
{
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
}
if
(
oldState
<
nsIDOMHTMLMediaElement
:
:
HAVE_CURRENT_DATA
&
&
mReadyState
>
=
nsIDOMHTMLMediaElement
:
:
HAVE_CURRENT_DATA
&
&
!
mLoadedDataFired
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadeddata
"
)
)
;
mLoadedDataFired
=
true
;
}
if
(
oldState
<
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
&
&
mReadyState
>
=
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
canplay
"
)
)
;
if
(
!
mPaused
)
{
mWaitingForKey
=
false
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
playing
"
)
)
;
}
}
CheckAutoplayDataReady
(
)
;
if
(
oldState
<
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
&
&
mReadyState
>
=
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
canplaythrough
"
)
)
;
}
}
static
const
char
*
const
gNetworkStateToString
[
]
=
{
"
EMPTY
"
"
IDLE
"
"
LOADING
"
"
NO_SOURCE
"
}
;
void
HTMLMediaElement
:
:
ChangeNetworkState
(
nsMediaNetworkState
aState
)
{
if
(
mNetworkState
=
=
aState
)
{
return
;
}
nsMediaNetworkState
oldState
=
mNetworkState
;
mNetworkState
=
aState
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Network
state
changed
to
%
s
"
this
gNetworkStateToString
[
aState
]
)
)
;
if
(
oldState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
{
mBegun
=
false
;
StopProgress
(
)
;
}
if
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
{
mBegun
=
true
;
StartProgress
(
)
;
}
else
if
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_IDLE
&
&
!
mError
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
suspend
"
)
)
;
}
AddRemoveSelfReference
(
)
;
}
bool
HTMLMediaElement
:
:
CanActivateAutoplay
(
)
{
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
|
|
!
mAutoplayEnabled
)
{
return
false
;
}
if
(
!
mAutoplaying
)
{
return
false
;
}
if
(
IsEditable
(
)
)
{
return
false
;
}
if
(
!
mPaused
)
{
return
false
;
}
if
(
mPausedForInactiveDocumentOrChannel
)
{
return
false
;
}
bool
hasData
=
(
mDecoder
&
&
mReadyState
>
=
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
)
|
|
mSrcStream
|
|
mMediaSource
;
return
hasData
;
}
void
HTMLMediaElement
:
:
CheckAutoplayDataReady
(
)
{
if
(
!
CanActivateAutoplay
(
)
)
{
return
;
}
mPaused
=
false
;
AddRemoveSelfReference
(
)
;
UpdateSrcMediaStreamPlaying
(
)
;
UpdateAudioChannelPlayingState
(
)
;
if
(
mDecoder
)
{
SetPlayedOrSeeked
(
true
)
;
if
(
mCurrentPlayRangeStart
=
=
-
1
.
0
)
{
mCurrentPlayRangeStart
=
CurrentTime
(
)
;
}
if
(
!
ShouldElementBePaused
(
)
)
{
mDecoder
-
>
Play
(
)
;
}
}
else
if
(
mSrcStream
)
{
SetPlayedOrSeeked
(
true
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
play
"
)
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
playing
"
)
)
;
}
bool
HTMLMediaElement
:
:
IsActive
(
)
const
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
return
ownerDoc
&
&
ownerDoc
-
>
IsActive
(
)
&
&
ownerDoc
-
>
IsVisible
(
)
;
}
bool
HTMLMediaElement
:
:
IsHidden
(
)
const
{
nsIDocument
*
ownerDoc
;
return
mUnboundFromTree
|
|
!
(
ownerDoc
=
OwnerDoc
(
)
)
|
|
ownerDoc
-
>
Hidden
(
)
;
}
VideoFrameContainer
*
HTMLMediaElement
:
:
GetVideoFrameContainer
(
)
{
if
(
mShuttingDown
)
{
return
nullptr
;
}
if
(
mVideoFrameContainer
)
return
mVideoFrameContainer
;
if
(
!
IsVideo
(
)
)
{
return
nullptr
;
}
mVideoFrameContainer
=
new
VideoFrameContainer
(
this
LayerManager
:
:
CreateImageContainer
(
ImageContainer
:
:
ASYNCHRONOUS
)
)
;
return
mVideoFrameContainer
;
}
void
HTMLMediaElement
:
:
PrincipalChanged
(
DOMMediaStream
*
aStream
)
{
LOG
(
LogLevel
:
:
Info
(
"
HTMLMediaElement
%
p
Stream
principal
changed
.
"
this
)
)
;
nsContentUtils
:
:
CombineResourcePrincipals
(
&
mSrcStreamVideoPrincipal
aStream
-
>
GetVideoPrincipal
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
HTMLMediaElement
%
p
Stream
video
principal
changed
to
"
"
%
p
.
Waiting
for
it
to
reach
VideoFrameContainer
before
"
"
setting
.
"
this
aStream
-
>
GetVideoPrincipal
(
)
)
)
;
if
(
mVideoFrameContainer
)
{
UpdateSrcStreamVideoPrincipal
(
mVideoFrameContainer
-
>
GetLastPrincipalHandle
(
)
)
;
}
}
void
HTMLMediaElement
:
:
UpdateSrcStreamVideoPrincipal
(
const
PrincipalHandle
&
aPrincipalHandle
)
{
nsTArray
<
RefPtr
<
VideoStreamTrack
>
>
videoTracks
;
mSrcStream
-
>
GetVideoTracks
(
videoTracks
)
;
PrincipalHandle
handle
(
aPrincipalHandle
)
;
bool
matchesTrackPrincipal
=
false
;
for
(
const
RefPtr
<
VideoStreamTrack
>
&
track
:
videoTracks
)
{
if
(
PrincipalHandleMatches
(
handle
track
-
>
GetPrincipal
(
)
)
&
&
!
track
-
>
Ended
(
)
)
{
matchesTrackPrincipal
=
true
;
LOG
(
LogLevel
:
:
Debug
(
"
HTMLMediaElement
%
p
VideoFrameContainer
'
s
"
"
PrincipalHandle
matches
track
%
p
.
That
'
s
all
we
"
"
need
.
"
this
track
.
get
(
)
)
)
;
break
;
}
}
if
(
matchesTrackPrincipal
)
{
mSrcStreamVideoPrincipal
=
mSrcStream
-
>
GetVideoPrincipal
(
)
;
}
}
void
HTMLMediaElement
:
:
PrincipalHandleChangedForVideoFrameContainer
(
VideoFrameContainer
*
aContainer
const
PrincipalHandle
&
aNewPrincipalHandle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mSrcStream
)
{
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
HTMLMediaElement
%
p
PrincipalHandle
changed
in
"
"
VideoFrameContainer
.
"
this
)
)
;
UpdateSrcStreamVideoPrincipal
(
aNewPrincipalHandle
)
;
}
nsresult
HTMLMediaElement
:
:
DispatchEvent
(
const
nsAString
&
aName
)
{
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Dispatching
event
%
s
"
this
NS_ConvertUTF16toUTF8
(
aName
)
.
get
(
)
)
)
;
if
(
mEventDeliveryPaused
)
{
mPendingEvents
.
AppendElement
(
aName
)
;
return
NS_OK
;
}
return
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
this
)
aName
false
false
)
;
}
nsresult
HTMLMediaElement
:
:
DispatchAsyncEvent
(
const
nsAString
&
aName
)
{
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Queuing
event
%
s
"
this
NS_ConvertUTF16toUTF8
(
aName
)
.
get
(
)
)
)
;
if
(
mEventDeliveryPaused
)
{
mPendingEvents
.
AppendElement
(
aName
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsAsyncEventRunner
(
aName
this
)
;
NS_DispatchToMainThread
(
event
)
;
if
(
(
aName
.
EqualsLiteral
(
"
play
"
)
|
|
aName
.
EqualsLiteral
(
"
playing
"
)
)
)
{
mPlayTime
.
Start
(
)
;
if
(
IsHidden
(
)
)
{
HiddenVideoStart
(
)
;
}
}
else
if
(
aName
.
EqualsLiteral
(
"
waiting
"
)
)
{
mPlayTime
.
Pause
(
)
;
HiddenVideoStop
(
)
;
}
else
if
(
aName
.
EqualsLiteral
(
"
pause
"
)
)
{
mPlayTime
.
Pause
(
)
;
HiddenVideoStop
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLMediaElement
:
:
DispatchPendingMediaEvents
(
)
{
NS_ASSERTION
(
!
mEventDeliveryPaused
"
Must
not
be
in
bfcache
when
dispatching
pending
media
events
"
)
;
uint32_t
count
=
mPendingEvents
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
DispatchAsyncEvent
(
mPendingEvents
[
i
]
)
;
}
mPendingEvents
.
Clear
(
)
;
return
NS_OK
;
}
bool
HTMLMediaElement
:
:
IsPotentiallyPlaying
(
)
const
{
return
!
mPaused
&
&
(
mReadyState
=
=
nsIDOMHTMLMediaElement
:
:
HAVE_ENOUGH_DATA
|
|
mReadyState
=
=
nsIDOMHTMLMediaElement
:
:
HAVE_FUTURE_DATA
)
&
&
!
IsPlaybackEnded
(
)
;
}
bool
HTMLMediaElement
:
:
IsPlaybackEnded
(
)
const
{
return
mReadyState
>
=
nsIDOMHTMLMediaElement
:
:
HAVE_METADATA
&
&
mDecoder
&
&
mDecoder
-
>
IsEnded
(
)
;
}
already_AddRefed
<
nsIPrincipal
>
HTMLMediaElement
:
:
GetCurrentPrincipal
(
)
{
if
(
mDecoder
)
{
return
mDecoder
-
>
GetCurrentPrincipal
(
)
;
}
if
(
mSrcStream
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
mSrcStream
-
>
GetPrincipal
(
)
;
return
principal
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsIPrincipal
>
HTMLMediaElement
:
:
GetCurrentVideoPrincipal
(
)
{
if
(
mDecoder
)
{
return
mDecoder
-
>
GetCurrentPrincipal
(
)
;
}
if
(
mSrcStream
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
mSrcStreamVideoPrincipal
;
return
principal
.
forget
(
)
;
}
return
nullptr
;
}
void
HTMLMediaElement
:
:
NotifyDecoderPrincipalChanged
(
)
{
RefPtr
<
nsIPrincipal
>
principal
=
GetCurrentPrincipal
(
)
;
mDecoder
-
>
UpdateSameOriginStatus
(
!
principal
|
|
IsCORSSameOrigin
(
)
)
;
for
(
DecoderPrincipalChangeObserver
*
observer
:
mDecoderPrincipalChangeObservers
)
{
observer
-
>
NotifyDecoderPrincipalChanged
(
)
;
}
}
void
HTMLMediaElement
:
:
AddDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
{
mDecoderPrincipalChangeObservers
.
AppendElement
(
aObserver
)
;
}
bool
HTMLMediaElement
:
:
RemoveDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
{
return
mDecoderPrincipalChangeObservers
.
RemoveElement
(
aObserver
)
;
}
void
HTMLMediaElement
:
:
UpdateMediaSize
(
const
nsIntSize
&
aSize
)
{
if
(
IsVideo
(
)
&
&
mReadyState
!
=
HAVE_NOTHING
&
&
mMediaInfo
.
mVideo
.
mDisplay
!
=
aSize
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
resize
"
)
)
;
}
mMediaInfo
.
mVideo
.
mDisplay
=
aSize
;
mWatchManager
.
ManualNotify
(
&
HTMLMediaElement
:
:
UpdateReadyStateInternal
)
;
}
void
HTMLMediaElement
:
:
UpdateInitialMediaSize
(
const
nsIntSize
&
aSize
)
{
if
(
!
mMediaInfo
.
HasVideo
(
)
)
{
UpdateMediaSize
(
aSize
)
;
}
if
(
!
mMediaStreamSizeListener
)
{
return
;
}
if
(
!
mSelectedVideoStreamTrack
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
mMediaStreamSizeListener
-
>
Forget
(
)
;
mMediaStreamSizeListener
=
nullptr
;
}
void
HTMLMediaElement
:
:
SuspendOrResumeElement
(
bool
aPauseElement
bool
aSuspendEvents
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SuspendOrResumeElement
(
pause
=
%
d
suspendEvents
=
%
d
)
hidden
=
%
d
"
this
aPauseElement
aSuspendEvents
OwnerDoc
(
)
-
>
Hidden
(
)
)
)
;
if
(
aPauseElement
!
=
mPausedForInactiveDocumentOrChannel
)
{
mPausedForInactiveDocumentOrChannel
=
aPauseElement
;
UpdateSrcMediaStreamPlaying
(
)
;
UpdateAudioChannelPlayingState
(
)
;
if
(
aPauseElement
)
{
ReportTelemetry
(
)
;
ReportEMETelemetry
(
)
;
if
(
mMediaKeys
)
{
mMediaKeys
-
>
Shutdown
(
)
;
mMediaKeys
=
nullptr
;
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
}
if
(
mDecoder
)
{
mDecoder
-
>
Pause
(
)
;
mDecoder
-
>
Suspend
(
)
;
}
mEventDeliveryPaused
=
aSuspendEvents
;
}
else
{
MOZ_ASSERT
(
!
mMediaKeys
)
;
if
(
mDecoder
)
{
mDecoder
-
>
Resume
(
)
;
if
(
!
mPaused
&
&
!
mDecoder
-
>
IsEnded
(
)
)
{
mDecoder
-
>
Play
(
)
;
}
}
if
(
mEventDeliveryPaused
)
{
mEventDeliveryPaused
=
false
;
DispatchPendingMediaEvents
(
)
;
}
}
}
}
bool
HTMLMediaElement
:
:
IsBeingDestroyed
(
)
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
nsIDocShell
*
docShell
=
ownerDoc
?
ownerDoc
-
>
GetDocShell
(
)
:
nullptr
;
bool
isBeingDestroyed
=
false
;
if
(
docShell
)
{
docShell
-
>
IsBeingDestroyed
(
&
isBeingDestroyed
)
;
}
return
isBeingDestroyed
;
}
void
HTMLMediaElement
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
bool
visible
=
!
IsHidden
(
)
;
if
(
visible
)
{
HiddenVideoStop
(
)
;
}
else
if
(
mPlayTime
.
IsStarted
(
)
)
{
HiddenVideoStart
(
)
;
}
if
(
mDecoder
&
&
!
IsBeingDestroyed
(
)
)
{
mDecoder
-
>
NotifyOwnerActivityChanged
(
visible
)
;
}
bool
pauseElement
=
ShouldElementBePaused
(
)
;
SuspendOrResumeElement
(
pauseElement
!
IsActive
(
)
)
;
AddRemoveSelfReference
(
)
;
}
void
HTMLMediaElement
:
:
AddRemoveSelfReference
(
)
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
bool
needSelfReference
=
!
mShuttingDown
&
&
ownerDoc
-
>
IsActive
(
)
&
&
(
mDelayingLoadEvent
|
|
(
!
mPaused
&
&
mDecoder
&
&
!
mDecoder
-
>
IsEnded
(
)
)
|
|
(
!
mPaused
&
&
mSrcStream
&
&
!
mSrcStream
-
>
IsFinished
(
)
)
|
|
(
mDecoder
&
&
mDecoder
-
>
IsSeeking
(
)
)
|
|
CanActivateAutoplay
(
)
|
|
(
mMediaSource
?
mProgressTimer
:
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_LOADING
)
)
;
if
(
needSelfReference
!
=
mHasSelfReference
)
{
mHasSelfReference
=
needSelfReference
;
if
(
needSelfReference
)
{
mShutdownObserver
-
>
AddRefMediaElement
(
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
this
&
HTMLMediaElement
:
:
DoRemoveSelfReference
)
;
NS_DispatchToMainThread
(
event
)
;
}
}
UpdateAudioChannelPlayingState
(
)
;
}
void
HTMLMediaElement
:
:
DoRemoveSelfReference
(
)
{
mShutdownObserver
-
>
ReleaseMediaElement
(
)
;
}
void
HTMLMediaElement
:
:
NotifyShutdownEvent
(
)
{
mShuttingDown
=
true
;
ResetState
(
)
;
AddRemoveSelfReference
(
)
;
}
bool
HTMLMediaElement
:
:
IsNodeOfType
(
uint32_t
aFlags
)
const
{
return
!
(
aFlags
&
~
(
eCONTENT
|
eMEDIA
)
)
;
}
void
HTMLMediaElement
:
:
DispatchAsyncSourceError
(
nsIContent
*
aSourceElement
)
{
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Queuing
simple
source
error
event
"
this
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsSourceErrorEventRunner
(
this
aSourceElement
)
;
NS_DispatchToMainThread
(
event
)
;
}
void
HTMLMediaElement
:
:
NotifyAddedSource
(
)
{
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
&
&
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_EMPTY
)
{
QueueSelectResourceTask
(
)
;
}
if
(
mLoadWaitStatus
=
=
WAITING_FOR_SOURCE
)
{
mLoadWaitStatus
=
NOT_WAITING
;
QueueLoadFromSourceTask
(
)
;
}
}
nsIContent
*
HTMLMediaElement
:
:
GetNextSource
(
)
{
nsCOMPtr
<
nsIDOMNode
>
thisDomNode
=
do_QueryObject
(
this
)
;
mSourceLoadCandidate
=
nullptr
;
nsresult
rv
=
NS_OK
;
if
(
!
mSourcePointer
)
{
mSourcePointer
=
new
nsRange
(
this
)
;
mSourcePointer
-
>
SetEnableGravitationOnElementRemoval
(
false
)
;
rv
=
mSourcePointer
-
>
SelectNodeContents
(
thisDomNode
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
rv
=
mSourcePointer
-
>
Collapse
(
true
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
}
while
(
true
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDOMNode
>
startContainer
;
rv
=
mSourcePointer
-
>
GetStartContainer
(
getter_AddRefs
(
startContainer
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
nullptr
;
NS_ASSERTION
(
startContainer
=
=
thisDomNode
"
Should
only
iterate
over
direct
children
"
)
;
#
endif
int32_t
startOffset
=
0
;
rv
=
mSourcePointer
-
>
GetStartOffset
(
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
if
(
uint32_t
(
startOffset
)
=
=
GetChildCount
(
)
)
return
nullptr
;
rv
=
mSourcePointer
-
>
SetStart
(
thisDomNode
startOffset
+
1
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
nsIContent
*
child
=
GetChildAt
(
startOffset
)
;
if
(
child
&
&
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
)
{
mSourceLoadCandidate
=
child
;
return
child
;
}
}
NS_NOTREACHED
(
"
Execution
should
not
reach
here
!
"
)
;
return
nullptr
;
}
void
HTMLMediaElement
:
:
ChangeDelayLoadStatus
(
bool
aDelay
)
{
if
(
mDelayingLoadEvent
=
=
aDelay
)
return
;
mDelayingLoadEvent
=
aDelay
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
ChangeDelayLoadStatus
(
%
d
)
doc
=
0x
%
p
"
this
aDelay
mLoadBlockedDoc
.
get
(
)
)
)
;
if
(
mDecoder
)
{
mDecoder
-
>
SetLoadInBackground
(
!
aDelay
)
;
}
if
(
aDelay
)
{
mLoadBlockedDoc
=
OwnerDoc
(
)
;
mLoadBlockedDoc
-
>
BlockOnload
(
)
;
}
else
{
if
(
mLoadBlockedDoc
)
{
mLoadBlockedDoc
-
>
UnblockOnload
(
false
)
;
mLoadBlockedDoc
=
nullptr
;
}
}
AddRemoveSelfReference
(
)
;
}
already_AddRefed
<
nsILoadGroup
>
HTMLMediaElement
:
:
GetDocumentLoadGroup
(
)
{
if
(
!
OwnerDoc
(
)
-
>
IsActive
(
)
)
{
NS_WARNING
(
"
Load
group
requested
for
media
element
in
inactive
document
.
"
)
;
}
return
OwnerDoc
(
)
-
>
GetDocumentLoadGroup
(
)
;
}
nsresult
HTMLMediaElement
:
:
CopyInnerTo
(
Element
*
aDest
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
CopyInnerTo
(
aDest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDest
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
HTMLMediaElement
*
dest
=
static_cast
<
HTMLMediaElement
*
>
(
aDest
)
;
dest
-
>
SetMediaInfo
(
mMediaInfo
)
;
}
return
rv
;
}
already_AddRefed
<
TimeRanges
>
HTMLMediaElement
:
:
Buffered
(
)
const
{
RefPtr
<
TimeRanges
>
ranges
=
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
)
;
if
(
mDecoder
)
{
media
:
:
TimeIntervals
buffered
=
mDecoder
-
>
GetBuffered
(
)
;
if
(
!
buffered
.
IsInvalid
(
)
)
{
buffered
.
ToTimeRanges
(
ranges
)
;
}
}
return
ranges
.
forget
(
)
;
}
nsresult
HTMLMediaElement
:
:
GetBuffered
(
nsIDOMTimeRanges
*
*
aBuffered
)
{
RefPtr
<
TimeRanges
>
ranges
=
Buffered
(
)
;
ranges
.
forget
(
aBuffered
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
)
{
SetAcceptHeader
(
aChannel
)
;
nsLoadFlags
loadflags
;
aChannel
-
>
GetLoadFlags
(
&
loadflags
)
;
loadflags
|
=
nsIRequest
:
:
INHIBIT_PIPELINE
;
aChannel
-
>
SetLoadFlags
(
loadflags
)
;
aChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Accept
-
Encoding
"
)
EmptyCString
(
)
false
)
;
aChannel
-
>
SetReferrerWithPolicy
(
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
OwnerDoc
(
)
-
>
GetReferrerPolicy
(
)
)
;
}
void
HTMLMediaElement
:
:
FireTimeUpdate
(
bool
aPeriodic
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
double
time
=
CurrentTime
(
)
;
if
(
!
aPeriodic
|
|
(
mLastCurrentTime
!
=
time
&
&
(
mTimeUpdateTime
.
IsNull
(
)
|
|
now
-
mTimeUpdateTime
>
=
TimeDuration
:
:
FromMilliseconds
(
TIMEUPDATE_MS
)
)
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
timeupdate
"
)
)
;
mTimeUpdateTime
=
now
;
mLastCurrentTime
=
time
;
}
if
(
mFragmentEnd
>
=
0
.
0
&
&
time
>
=
mFragmentEnd
)
{
Pause
(
)
;
mFragmentEnd
=
-
1
.
0
;
mFragmentStart
=
-
1
.
0
;
mDecoder
-
>
SetFragmentEndTime
(
mFragmentEnd
)
;
}
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
TimeMarchesOn
(
)
;
}
}
MediaStream
*
HTMLMediaElement
:
:
GetSrcMediaStream
(
)
const
{
if
(
!
mSrcStream
)
{
return
nullptr
;
}
if
(
mSrcStream
-
>
GetCameraStream
(
)
)
{
return
mSrcStream
-
>
GetCameraStream
(
)
;
}
return
mSrcStream
-
>
GetPlaybackStream
(
)
;
}
void
HTMLMediaElement
:
:
GetCurrentSpec
(
nsCString
&
aString
)
{
if
(
mLoadingSrc
)
{
mLoadingSrc
-
>
GetSpec
(
aString
)
;
}
else
{
aString
.
Truncate
(
)
;
}
}
double
HTMLMediaElement
:
:
MozFragmentEnd
(
)
{
double
duration
=
Duration
(
)
;
return
(
mFragmentEnd
<
0
.
0
|
|
mFragmentEnd
>
duration
)
?
duration
:
mFragmentEnd
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetMozFragmentEnd
(
double
*
aTime
)
{
*
aTime
=
MozFragmentEnd
(
)
;
return
NS_OK
;
}
static
double
ClampPlaybackRate
(
double
aPlaybackRate
)
{
if
(
aPlaybackRate
=
=
0
.
0
)
{
return
aPlaybackRate
;
}
if
(
Abs
(
aPlaybackRate
)
<
MIN_PLAYBACKRATE
)
{
return
aPlaybackRate
<
0
?
-
MIN_PLAYBACKRATE
:
MIN_PLAYBACKRATE
;
}
if
(
Abs
(
aPlaybackRate
)
>
MAX_PLAYBACKRATE
)
{
return
aPlaybackRate
<
0
?
-
MAX_PLAYBACKRATE
:
MAX_PLAYBACKRATE
;
}
return
aPlaybackRate
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetDefaultPlaybackRate
(
double
*
aDefaultPlaybackRate
)
{
*
aDefaultPlaybackRate
=
DefaultPlaybackRate
(
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
SetDefaultPlaybackRate
(
double
aDefaultPlaybackRate
ErrorResult
&
aRv
)
{
if
(
aDefaultPlaybackRate
<
0
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
;
}
mDefaultPlaybackRate
=
ClampPlaybackRate
(
aDefaultPlaybackRate
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
ratechange
"
)
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
SetDefaultPlaybackRate
(
double
aDefaultPlaybackRate
)
{
ErrorResult
rv
;
SetDefaultPlaybackRate
(
aDefaultPlaybackRate
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetPlaybackRate
(
double
*
aPlaybackRate
)
{
*
aPlaybackRate
=
PlaybackRate
(
)
;
return
NS_OK
;
}
void
HTMLMediaElement
:
:
SetPlaybackRate
(
double
aPlaybackRate
ErrorResult
&
aRv
)
{
if
(
aPlaybackRate
<
0
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
;
}
mPlaybackRate
=
ClampPlaybackRate
(
aPlaybackRate
)
;
if
(
mPlaybackRate
!
=
0
.
0
&
&
(
mPlaybackRate
<
0
|
|
mPlaybackRate
>
THRESHOLD_HIGH_PLAYBACKRATE_AUDIO
|
|
mPlaybackRate
<
THRESHOLD_LOW_PLAYBACKRATE_AUDIO
)
)
{
SetMutedInternal
(
mMuted
|
MUTED_BY_INVALID_PLAYBACK_RATE
)
;
}
else
{
SetMutedInternal
(
mMuted
&
~
MUTED_BY_INVALID_PLAYBACK_RATE
)
;
}
if
(
mDecoder
)
{
mDecoder
-
>
SetPlaybackRate
(
mPlaybackRate
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
ratechange
"
)
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
SetPlaybackRate
(
double
aPlaybackRate
)
{
ErrorResult
rv
;
SetPlaybackRate
(
aPlaybackRate
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
GetMozPreservesPitch
(
bool
*
aPreservesPitch
)
{
*
aPreservesPitch
=
MozPreservesPitch
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
SetMozPreservesPitch
(
bool
aPreservesPitch
)
{
mPreservesPitch
=
aPreservesPitch
;
if
(
mDecoder
)
{
mDecoder
-
>
SetPreservesPitch
(
mPreservesPitch
)
;
}
return
NS_OK
;
}
ImageContainer
*
HTMLMediaElement
:
:
GetImageContainer
(
)
{
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
return
container
?
container
-
>
GetImageContainer
(
)
:
nullptr
;
}
void
HTMLMediaElement
:
:
CreateAudioChannelAgent
(
)
{
if
(
mAudioChannelAgent
)
{
return
;
}
mAudioChannelAgent
=
new
AudioChannelAgent
(
)
;
mAudioChannelAgent
-
>
InitWithWeakCallback
(
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
static_cast
<
int32_t
>
(
mAudioChannel
)
this
)
;
}
bool
HTMLMediaElement
:
:
IsPlayingThroughTheAudioChannel
(
)
const
{
if
(
mError
)
{
return
false
;
}
if
(
IsSuspendedByAudioChannel
(
)
)
{
return
true
;
}
if
(
mPaused
)
{
return
false
;
}
if
(
!
IsActive
(
)
)
{
return
false
;
}
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loop
)
)
{
return
true
;
}
if
(
IsCurrentlyPlaying
(
)
)
{
return
true
;
}
if
(
mPlayingThroughTheAudioChannelBeforeSeek
)
{
return
true
;
}
if
(
mSrcAttrStream
)
{
return
true
;
}
return
false
;
}
void
HTMLMediaElement
:
:
UpdateAudioChannelPlayingState
(
)
{
bool
playingThroughTheAudioChannel
=
IsPlayingThroughTheAudioChannel
(
)
;
if
(
playingThroughTheAudioChannel
!
=
mPlayingThroughTheAudioChannel
)
{
mPlayingThroughTheAudioChannel
=
playingThroughTheAudioChannel
;
if
(
!
mAudioChannelAgent
&
&
!
mPlayingThroughTheAudioChannel
)
{
return
;
}
CreateAudioChannelAgent
(
)
;
NotifyAudioChannelAgent
(
mPlayingThroughTheAudioChannel
)
;
}
}
void
HTMLMediaElement
:
:
NotifyAudioChannelAgent
(
bool
aPlaying
)
{
AutoNoJSAPI
nojsapi
;
if
(
aPlaying
)
{
AudioPlaybackConfig
config
;
nsresult
rv
=
mAudioChannelAgent
-
>
NotifyStartedPlaying
(
&
config
IsAudible
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
WindowVolumeChanged
(
config
.
mVolume
config
.
mMuted
)
;
WindowSuspendChanged
(
config
.
mSuspend
)
;
}
else
{
mAudioChannelAgent
-
>
NotifyStoppedPlaying
(
)
;
mAudioChannelAgent
=
nullptr
;
}
}
NS_IMETHODIMP
HTMLMediaElement
:
:
WindowVolumeChanged
(
float
aVolume
bool
aMuted
)
{
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
WindowVolumeChanged
this
=
%
p
"
"
aVolume
=
%
f
aMuted
=
%
d
\
n
"
this
aVolume
aMuted
)
)
;
if
(
mAudioChannelVolume
!
=
aVolume
)
{
mAudioChannelVolume
=
aVolume
;
SetVolumeInternal
(
)
;
}
if
(
aMuted
&
&
!
ComputedMuted
(
)
)
{
SetMutedInternal
(
mMuted
|
MUTED_BY_AUDIO_CHANNEL
)
;
}
else
if
(
!
aMuted
&
&
ComputedMuted
(
)
)
{
SetMutedInternal
(
mMuted
&
~
MUTED_BY_AUDIO_CHANNEL
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
WindowSuspendChanged
(
SuspendTypes
aSuspend
)
{
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
WindowSuspendChanged
this
=
%
p
"
"
aSuspend
=
%
d
\
n
"
this
aSuspend
)
)
;
switch
(
aSuspend
)
{
case
nsISuspendedTypes
:
:
NONE_SUSPENDED
:
ResumeFromAudioChannel
(
)
;
break
;
case
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
:
case
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
:
PauseByAudioChannel
(
aSuspend
)
;
break
;
case
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
:
BlockByAudioChannel
(
)
;
break
;
case
nsISuspendedTypes
:
:
SUSPENDED_STOP_DISPOSABLE
:
SetAudioChannelSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
Pause
(
)
;
break
;
default
:
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
WindowSuspendChanged
this
=
%
p
"
"
Error
:
unknown
suspended
type
!
\
n
"
this
)
)
;
}
return
NS_OK
;
}
void
HTMLMediaElement
:
:
ResumeFromAudioChannel
(
)
{
if
(
!
IsSuspendedByAudioChannel
(
)
)
{
return
;
}
switch
(
mAudioChannelSuspended
)
{
case
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
:
case
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
:
ResumeFromAudioChannelPaused
(
mAudioChannelSuspended
)
;
break
;
case
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
:
ResumeFromAudioChannelBlocked
(
)
;
break
;
default
:
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
ResumeFromAudioChannel
this
=
%
p
"
"
Error
:
resume
without
suspended
!
\
n
"
this
)
)
;
}
}
void
HTMLMediaElement
:
:
ResumeFromAudioChannelPaused
(
SuspendTypes
aSuspend
)
{
MOZ_ASSERT
(
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
|
|
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
)
;
SetAudioChannelSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
nsresult
rv
=
PlayInternal
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
mozinterruptend
"
)
)
;
}
void
HTMLMediaElement
:
:
ResumeFromAudioChannelBlocked
(
)
{
MOZ_ASSERT
(
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
;
SetAudioChannelSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
mPaused
=
false
;
SuspendOrResumeElement
(
false
false
)
;
}
void
HTMLMediaElement
:
:
PauseByAudioChannel
(
SuspendTypes
aSuspend
)
{
if
(
IsSuspendedByAudioChannel
(
)
)
{
return
;
}
SetAudioChannelSuspended
(
aSuspend
)
;
Pause
(
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
mozinterruptbegin
"
)
)
;
}
void
HTMLMediaElement
:
:
BlockByAudioChannel
(
)
{
if
(
IsSuspendedByAudioChannel
(
)
)
{
return
;
}
SetAudioChannelSuspended
(
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
;
mPaused
=
true
;
SuspendOrResumeElement
(
true
true
)
;
}
void
HTMLMediaElement
:
:
SetAudioChannelSuspended
(
SuspendTypes
aSuspend
)
{
if
(
mAudioChannelSuspended
=
=
aSuspend
)
{
return
;
}
mAudioChannelSuspended
=
aSuspend
;
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
SetAudioChannelSuspended
this
=
%
p
"
"
aSuspend
=
%
d
\
n
"
this
aSuspend
)
)
;
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
ePauseStateChanged
)
;
}
bool
HTMLMediaElement
:
:
IsSuspendedByAudioChannel
(
)
const
{
return
(
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
|
|
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
|
|
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
;
}
bool
HTMLMediaElement
:
:
IsAllowedToPlay
(
)
{
if
(
!
mHasUserInteraction
&
&
!
IsAutoplayEnabled
(
)
&
&
!
EventStateManager
:
:
IsHandlingUserInput
(
)
&
&
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
this
)
NS_LITERAL_STRING
(
"
MozAutoplayMediaBlocked
"
)
false
false
)
;
#
endif
return
false
;
}
if
(
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
|
|
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
{
return
false
;
}
return
true
;
}
static
const
char
*
VisibilityString
(
Visibility
aVisibility
)
{
switch
(
aVisibility
)
{
case
Visibility
:
:
UNTRACKED
:
{
return
"
UNTRACKED
"
;
}
case
Visibility
:
:
APPROXIMATELY_NONVISIBLE
:
{
return
"
APPROXIMATELY_NONVISIBLE
"
;
}
case
Visibility
:
:
APPROXIMATELY_VISIBLE
:
{
return
"
APPROXIMATELY_VISIBLE
"
;
}
}
return
"
NAN
"
;
}
void
HTMLMediaElement
:
:
OnVisibilityChange
(
Visibility
aNewVisibility
)
{
LOG
(
LogLevel
:
:
Debug
(
"
OnVisibilityChange
(
)
:
%
s
\
n
"
VisibilityString
(
aNewVisibility
)
)
)
;
mVisibilityState
=
aNewVisibility
;
if
(
!
mDecoder
)
{
return
;
}
switch
(
aNewVisibility
)
{
case
Visibility
:
:
UNTRACKED
:
{
MOZ_ASSERT_UNREACHABLE
(
"
Shouldn
'
t
notify
for
untracked
visibility
"
)
;
break
;
}
case
Visibility
:
:
APPROXIMATELY_NONVISIBLE
:
{
if
(
mPlayTime
.
IsStarted
(
)
)
{
HiddenVideoStart
(
)
;
}
mDecoder
-
>
NotifyOwnerActivityChanged
(
false
)
;
break
;
}
case
Visibility
:
:
APPROXIMATELY_VISIBLE
:
{
HiddenVideoStop
(
)
;
mDecoder
-
>
NotifyOwnerActivityChanged
(
true
)
;
break
;
}
}
}
MediaKeys
*
HTMLMediaElement
:
:
GetMediaKeys
(
)
const
{
return
mMediaKeys
;
}
bool
HTMLMediaElement
:
:
ContainsRestrictedContent
(
)
{
return
GetMediaKeys
(
)
!
=
nullptr
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
SetMediaKeys
(
mozilla
:
:
dom
:
:
MediaKeys
*
aMediaKeys
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetMediaKeys
(
%
p
)
mMediaKeys
=
%
p
mDecoder
=
%
p
"
this
aMediaKeys
mMediaKeys
.
get
(
)
mDecoder
.
get
(
)
)
)
;
if
(
MozAudioCaptured
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
DetailedPromise
>
promise
=
DetailedPromise
:
:
Create
(
global
aRv
NS_LITERAL_CSTRING
(
"
HTMLMediaElement
.
setMediaKeys
"
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
mMediaKeys
=
=
aMediaKeys
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
aMediaKeys
&
&
aMediaKeys
-
>
IsBoundToMediaElement
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_QUOTA_EXCEEDED_ERR
NS_LITERAL_CSTRING
(
"
MediaKeys
object
is
already
bound
to
another
HTMLMediaElement
"
)
)
;
return
promise
.
forget
(
)
;
}
if
(
mMediaKeys
)
{
if
(
mDecoder
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
NS_LITERAL_CSTRING
(
"
Can
'
t
change
MediaKeys
on
HTMLMediaElement
after
load
has
started
"
)
)
;
return
promise
.
forget
(
)
;
}
mMediaKeys
-
>
Unbind
(
)
;
mMediaKeys
=
nullptr
;
}
if
(
aMediaKeys
)
{
if
(
!
aMediaKeys
-
>
GetCDMProxy
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
NS_LITERAL_CSTRING
(
"
CDM
crashed
before
binding
MediaKeys
object
to
HTMLMediaElement
"
)
)
;
return
promise
.
forget
(
)
;
}
if
(
NS_FAILED
(
aMediaKeys
-
>
Bind
(
this
)
)
)
{
mMediaKeys
=
nullptr
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
NS_LITERAL_CSTRING
(
"
Failed
to
bind
MediaKeys
object
to
HTMLMediaElement
"
)
)
;
return
promise
.
forget
(
)
;
}
if
(
mDecoder
)
{
mDecoder
-
>
SetCDMProxy
(
aMediaKeys
-
>
GetCDMProxy
(
)
)
;
}
}
mMediaKeys
=
aMediaKeys
;
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
EventHandlerNonNull
*
HTMLMediaElement
:
:
GetOnencrypted
(
)
{
return
EventTarget
:
:
GetEventHandler
(
nsGkAtoms
:
:
onencrypted
EmptyString
(
)
)
;
}
void
HTMLMediaElement
:
:
SetOnencrypted
(
EventHandlerNonNull
*
aCallback
)
{
EventTarget
:
:
SetEventHandler
(
nsGkAtoms
:
:
onencrypted
EmptyString
(
)
aCallback
)
;
}
EventHandlerNonNull
*
HTMLMediaElement
:
:
GetOnwaitingforkey
(
)
{
return
EventTarget
:
:
GetEventHandler
(
nsGkAtoms
:
:
onwaitingforkey
EmptyString
(
)
)
;
}
void
HTMLMediaElement
:
:
SetOnwaitingforkey
(
EventHandlerNonNull
*
aCallback
)
{
EventTarget
:
:
SetEventHandler
(
nsGkAtoms
:
:
onwaitingforkey
EmptyString
(
)
aCallback
)
;
}
void
HTMLMediaElement
:
:
DispatchEncrypted
(
const
nsTArray
<
uint8_t
>
&
aInitData
const
nsAString
&
aInitDataType
)
{
if
(
mReadyState
=
=
nsIDOMHTMLMediaElement
:
:
HAVE_NOTHING
)
{
mPendingEncryptedInitData
.
AddInitData
(
aInitDataType
aInitData
)
;
return
;
}
RefPtr
<
MediaEncryptedEvent
>
event
;
if
(
IsCORSSameOrigin
(
)
)
{
event
=
MediaEncryptedEvent
:
:
Constructor
(
this
aInitDataType
aInitData
)
;
}
else
{
event
=
MediaEncryptedEvent
:
:
Constructor
(
this
)
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
event
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
bool
HTMLMediaElement
:
:
IsEventAttributeName
(
nsIAtom
*
aName
)
{
return
aName
=
=
nsGkAtoms
:
:
onencrypted
|
|
nsGenericHTMLElement
:
:
IsEventAttributeName
(
aName
)
;
}
already_AddRefed
<
nsIPrincipal
>
HTMLMediaElement
:
:
GetTopLevelPrincipal
(
)
{
RefPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
window
-
>
GetOuterWindow
(
)
-
>
GetTop
(
)
;
if
(
!
top
)
{
return
nullptr
;
}
nsIDocument
*
doc
=
top
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
principal
=
doc
-
>
NodePrincipal
(
)
;
return
principal
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
CannotDecryptWaitingForKey
(
)
{
if
(
!
mWaitingForKey
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waitingforkey
"
)
)
;
mWaitingForKey
=
true
;
}
}
NS_IMETHODIMP
HTMLMediaElement
:
:
WindowAudioCaptureChanged
(
bool
aCapture
)
{
MOZ_ASSERT
(
mAudioChannelAgent
)
;
if
(
mAudioCapturedByWindow
!
=
aCapture
)
{
mAudioCapturedByWindow
=
aCapture
;
AudioCaptureStreamChangeIfNeeded
(
)
;
}
return
NS_OK
;
}
AudioTrackList
*
HTMLMediaElement
:
:
AudioTracks
(
)
{
if
(
!
mAudioTrackList
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
OwnerDoc
(
)
-
>
GetParentObject
(
)
)
;
mAudioTrackList
=
new
AudioTrackList
(
window
this
)
;
}
return
mAudioTrackList
;
}
VideoTrackList
*
HTMLMediaElement
:
:
VideoTracks
(
)
{
if
(
!
mVideoTrackList
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
OwnerDoc
(
)
-
>
GetParentObject
(
)
)
;
mVideoTrackList
=
new
VideoTrackList
(
window
this
)
;
}
return
mVideoTrackList
;
}
TextTrackList
*
HTMLMediaElement
:
:
GetTextTracks
(
)
{
return
GetOrCreateTextTrackManager
(
)
-
>
GetTextTracks
(
)
;
}
already_AddRefed
<
TextTrack
>
HTMLMediaElement
:
:
AddTextTrack
(
TextTrackKind
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
)
{
return
GetOrCreateTextTrackManager
(
)
-
>
AddTextTrack
(
aKind
aLabel
aLanguage
TextTrackMode
:
:
Hidden
TextTrackReadyState
:
:
Loaded
TextTrackSource
:
:
AddTextTrack
)
;
}
void
HTMLMediaElement
:
:
PopulatePendingTextTrackList
(
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
PopulatePendingList
(
)
;
}
}
TextTrackManager
*
HTMLMediaElement
:
:
GetOrCreateTextTrackManager
(
)
{
if
(
!
mTextTrackManager
)
{
mTextTrackManager
=
new
TextTrackManager
(
this
)
;
mTextTrackManager
-
>
AddListeners
(
)
;
}
return
mTextTrackManager
;
}
void
HTMLMediaElement
:
:
SetMozAudioChannelType
(
AudioChannel
aValue
ErrorResult
&
aRv
)
{
nsString
channel
;
channel
.
AssignASCII
(
AudioChannelValues
:
:
strings
[
uint32_t
(
aValue
)
]
.
value
AudioChannelValues
:
:
strings
[
uint32_t
(
aValue
)
]
.
length
)
;
SetHTMLAttr
(
nsGkAtoms
:
:
mozaudiochannel
channel
aRv
)
;
}
MediaDecoderOwner
:
:
NextFrameStatus
HTMLMediaElement
:
:
NextFrameStatus
(
)
{
if
(
mDecoder
)
{
return
mDecoder
-
>
NextFrameStatus
(
)
;
}
else
if
(
mMediaStreamListener
)
{
return
mMediaStreamListener
-
>
NextFrameStatus
(
)
;
}
return
NEXT_FRAME_UNINITIALIZED
;
}
float
HTMLMediaElement
:
:
ComputedVolume
(
)
const
{
return
mMuted
?
0
.
0f
:
float
(
mVolume
*
mAudioChannelVolume
)
;
}
bool
HTMLMediaElement
:
:
ComputedMuted
(
)
const
{
return
(
mMuted
&
MUTED_BY_AUDIO_CHANNEL
)
;
}
nsSuspendedTypes
HTMLMediaElement
:
:
ComputedSuspended
(
)
const
{
return
mAudioChannelSuspended
;
}
bool
HTMLMediaElement
:
:
IsCurrentlyPlaying
(
)
const
{
return
mReadyState
>
=
nsIDOMHTMLMediaElement
:
:
HAVE_CURRENT_DATA
&
&
!
IsPlaybackEnded
(
)
;
}
void
HTMLMediaElement
:
:
SetAudibleState
(
bool
aAudible
)
{
if
(
mIsAudioTrackAudible
!
=
aAudible
)
{
mIsAudioTrackAudible
=
aAudible
;
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
eDataAudibleChanged
)
;
}
}
void
HTMLMediaElement
:
:
NotifyAudioPlaybackChanged
(
AudibleChangedReasons
aReason
)
{
if
(
!
mAudioChannelAgent
)
{
return
;
}
if
(
mAudible
=
=
IsAudible
(
)
)
{
return
;
}
mAudible
=
IsAudible
(
)
;
mAudioChannelAgent
-
>
NotifyStartedAudible
(
mAudible
aReason
)
;
}
bool
HTMLMediaElement
:
:
IsAudible
(
)
const
{
if
(
Muted
(
)
|
|
(
std
:
:
fabs
(
Volume
(
)
)
<
=
1e
-
7
)
)
{
return
false
;
}
if
(
IsSuspendedByAudioChannel
(
)
)
{
return
false
;
}
if
(
!
mIsAudioTrackAudible
)
{
return
false
;
}
return
true
;
}
bool
HTMLMediaElement
:
:
HaveFailedWithSourceNotSupportedError
(
)
const
{
if
(
!
mError
)
{
return
false
;
}
uint16_t
errorCode
=
mError
-
>
Code
(
)
;
return
(
mNetworkState
=
=
nsIDOMHTMLMediaElement
:
:
NETWORK_NO_SOURCE
&
&
errorCode
=
=
MEDIA_ERR_SRC_NOT_SUPPORTED
)
;
}
void
HTMLMediaElement
:
:
OpenUnsupportedMediaWithExtenalAppIfNeeded
(
)
{
if
(
!
Preferences
:
:
GetBool
(
"
media
.
openUnsupportedTypeWithExternalApp
"
)
)
{
return
;
}
if
(
!
HaveFailedWithSourceNotSupportedError
(
)
)
{
return
;
}
if
(
mPaused
)
{
return
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
this
)
NS_LITERAL_STRING
(
"
OpenMediaWithExternalApp
"
)
true
true
)
;
}
bool
HTMLMediaElement
:
:
ShouldElementBePaused
(
)
{
if
(
mAudioChannelSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
{
return
true
;
}
if
(
!
IsActive
(
)
)
{
return
true
;
}
return
false
;
}
void
HTMLMediaElement
:
:
SetMediaInfo
(
const
MediaInfo
&
aInfo
)
{
mMediaInfo
=
aInfo
;
AudioCaptureStreamChangeIfNeeded
(
)
;
}
void
HTMLMediaElement
:
:
AudioCaptureStreamChangeIfNeeded
(
)
{
if
(
!
mAudioChannelAgent
)
{
return
;
}
if
(
!
HasAudio
(
)
)
{
return
;
}
if
(
mAudioCapturedByWindow
&
&
!
mCaptureStreamPort
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
{
return
;
}
uint64_t
id
=
window
-
>
WindowID
(
)
;
MediaStreamGraph
*
msg
=
MediaStreamGraph
:
:
GetInstance
(
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
mAudioChannel
)
;
if
(
GetSrcMediaStream
(
)
)
{
mCaptureStreamPort
=
msg
-
>
ConnectToCaptureStream
(
id
GetSrcMediaStream
(
)
)
;
}
else
{
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
false
false
msg
)
;
mCaptureStreamPort
=
msg
-
>
ConnectToCaptureStream
(
id
stream
-
>
GetPlaybackStream
(
)
)
;
}
}
else
if
(
!
mAudioCapturedByWindow
&
&
mCaptureStreamPort
)
{
if
(
mDecoder
)
{
ProcessedMediaStream
*
ps
=
mCaptureStreamPort
-
>
GetSource
(
)
-
>
AsProcessedStream
(
)
;
MOZ_ASSERT
(
ps
)
;
for
(
uint32_t
i
=
0
;
i
<
mOutputStreams
.
Length
(
)
;
i
+
+
)
{
if
(
mOutputStreams
[
i
]
.
mStream
-
>
GetPlaybackStream
(
)
=
=
ps
)
{
mOutputStreams
.
RemoveElementAt
(
i
)
;
break
;
}
}
mDecoder
-
>
RemoveOutputStream
(
ps
)
;
}
mCaptureStreamPort
-
>
Destroy
(
)
;
mCaptureStreamPort
=
nullptr
;
}
}
void
HTMLMediaElement
:
:
NotifyCueDisplayStatesChanged
(
)
{
if
(
!
mTextTrackManager
)
{
return
;
}
mTextTrackManager
-
>
DispatchUpdateCueDisplay
(
)
;
}
void
HTMLMediaElement
:
:
MarkAsContentSource
(
CallerAPI
aAPI
)
{
const
bool
isVisible
=
mVisibilityState
!
=
Visibility
:
:
APPROXIMATELY_NONVISIBLE
;
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
0
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
1
)
;
}
switch
(
aAPI
)
{
case
CallerAPI
:
:
DRAW_IMAGE
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
2
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
3
)
;
}
break
;
}
case
CallerAPI
:
:
CREATE_PATTERN
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
4
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
5
)
;
}
break
;
}
case
CallerAPI
:
:
CREATE_IMAGEBITMAP
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
6
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
7
)
;
}
break
;
}
case
CallerAPI
:
:
CAPTURE_STREAM
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
8
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
9
)
;
}
break
;
}
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Log
VIDEO_AS_CONTENT_SOURCE
:
visibility
=
%
u
API
:
'
%
d
'
and
'
All
'
"
this
isVisible
aAPI
)
)
;
}
}
}
