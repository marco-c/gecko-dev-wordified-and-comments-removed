#
ifdef
XP_WIN
#
include
"
objbase
.
h
"
#
undef
GetCurrentTime
#
endif
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
AudioChannelService
.
h
"
#
include
"
AudioStreamTrack
.
h
"
#
include
"
AutoplayPolicy
.
h
"
#
include
"
ChannelMediaDecoder
.
h
"
#
include
"
DOMMediaStream
.
h
"
#
include
"
DecoderDoctorDiagnostics
.
h
"
#
include
"
DecoderDoctorLogger
.
h
"
#
include
"
DecoderTraits
.
h
"
#
include
"
FrameStatistics
.
h
"
#
include
"
GMPCrashHelper
.
h
"
#
ifdef
MOZ_ANDROID_HLS_SUPPORT
#
include
"
HLSDecoder
.
h
"
#
endif
#
include
"
HTMLMediaElement
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
Layers
.
h
"
#
include
"
MP4Decoder
.
h
"
#
include
"
MediaContainerType
.
h
"
#
include
"
MediaError
.
h
"
#
include
"
MediaMetadataManager
.
h
"
#
include
"
MediaResource
.
h
"
#
include
"
MediaSourceDecoder
.
h
"
#
include
"
MediaStreamError
.
h
"
#
include
"
MediaStreamGraph
.
h
"
#
include
"
MediaStreamListener
.
h
"
#
include
"
MediaTrackList
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
TimeRanges
.
h
"
#
include
"
VideoFrameContainer
.
h
"
#
include
"
VideoStreamTrack
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
EMEUtils
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
AudioTrack
.
h
"
#
include
"
mozilla
/
dom
/
AudioTrackList
.
h
"
#
include
"
mozilla
/
AutoplayPermissionManager
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAudioElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSourceElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLVideoElement
.
h
"
#
include
"
mozilla
/
dom
/
MediaEncryptedEvent
.
h
"
#
include
"
mozilla
/
dom
/
MediaErrorBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaSource
.
h
"
#
include
"
mozilla
/
dom
/
PlayPromise
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
TextTrack
.
h
"
#
include
"
mozilla
/
dom
/
VideoPlaybackQuality
.
h
"
#
include
"
mozilla
/
dom
/
VideoTrack
.
h
"
#
include
"
mozilla
/
dom
/
VideoTrackList
.
h
"
#
include
"
mozilla
/
dom
/
WakeLock
.
h
"
#
include
"
mozilla
/
dom
/
power
/
PowerManagerService
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIAutoplay
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIThreadInternal
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsMediaFragmentURIParser
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsVideoFrame
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
limits
>
mozilla
:
:
LazyLogModule
gMediaElementLog
(
"
nsMediaElement
"
)
;
static
mozilla
:
:
LazyLogModule
gMediaElementEventsLog
(
"
nsMediaElementEvents
"
)
;
#
define
LOG
(
type
msg
)
MOZ_LOG
(
gMediaElementLog
type
msg
)
#
define
LOG_EVENT
(
type
msg
)
MOZ_LOG
(
gMediaElementEventsLog
type
msg
)
using
namespace
mozilla
:
:
layers
;
using
mozilla
:
:
net
:
:
nsMediaFragmentURIParser
;
using
namespace
mozilla
:
:
dom
:
:
HTMLMediaElement_Binding
;
namespace
mozilla
{
namespace
dom
{
static
const
uint32_t
PROGRESS_MS
=
350
;
static
const
uint32_t
STALL_MS
=
3000
;
#
define
FADED_VOLUME_RATIO
0
.
25
static
const
double
MIN_PLAYBACKRATE
=
1
.
0
/
16
;
static
const
double
MAX_PLAYBACKRATE
=
16
.
0
;
static
const
double
THRESHOLD_HIGH_PLAYBACKRATE_AUDIO
=
4
.
0
;
static
const
double
THRESHOLD_LOW_PLAYBACKRATE_AUDIO
=
0
.
5
;
static
const
unsigned
short
MEDIA_ERR_ABORTED
=
1
;
static
const
unsigned
short
MEDIA_ERR_NETWORK
=
2
;
static
const
unsigned
short
MEDIA_ERR_DECODE
=
3
;
static
const
unsigned
short
MEDIA_ERR_SRC_NOT_SUPPORTED
=
4
;
static
void
ResolvePromisesWithUndefined
(
const
nsTArray
<
RefPtr
<
PlayPromise
>
>
&
aPromises
)
{
for
(
auto
&
promise
:
aPromises
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
}
static
void
RejectPromises
(
const
nsTArray
<
RefPtr
<
PlayPromise
>
>
&
aPromises
nsresult
aError
)
{
for
(
auto
&
promise
:
aPromises
)
{
promise
-
>
MaybeReject
(
aError
)
;
}
}
class
nsMediaEvent
:
public
Runnable
{
public
:
explicit
nsMediaEvent
(
const
char
*
aName
HTMLMediaElement
*
aElement
)
:
Runnable
(
aName
)
mElement
(
aElement
)
mLoadID
(
mElement
-
>
GetCurrentLoadID
(
)
)
{
}
~
nsMediaEvent
(
)
{
}
NS_IMETHOD
Run
(
)
override
=
0
;
protected
:
bool
IsCancelled
(
)
{
return
mElement
-
>
GetCurrentLoadID
(
)
!
=
mLoadID
;
}
RefPtr
<
HTMLMediaElement
>
mElement
;
uint32_t
mLoadID
;
}
;
class
HTMLMediaElement
:
:
nsAsyncEventRunner
:
public
nsMediaEvent
{
private
:
nsString
mName
;
public
:
nsAsyncEventRunner
(
const
nsAString
&
aName
HTMLMediaElement
*
aElement
)
:
nsMediaEvent
(
"
HTMLMediaElement
:
:
nsAsyncEventRunner
"
aElement
)
mName
(
aName
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
IsCancelled
(
)
)
return
NS_OK
;
return
mElement
-
>
DispatchEvent
(
mName
)
;
}
}
;
class
HTMLMediaElement
:
:
nsResolveOrRejectPendingPlayPromisesRunner
:
public
nsMediaEvent
{
nsTArray
<
RefPtr
<
PlayPromise
>
>
mPromises
;
nsresult
mError
;
public
:
nsResolveOrRejectPendingPlayPromisesRunner
(
HTMLMediaElement
*
aElement
nsTArray
<
RefPtr
<
PlayPromise
>
>
&
&
aPromises
nsresult
aError
=
NS_OK
)
:
nsMediaEvent
(
"
HTMLMediaElement
:
:
nsResolveOrRejectPendingPlayPromisesRunner
"
aElement
)
mPromises
(
std
:
:
move
(
aPromises
)
)
mError
(
aError
)
{
mElement
-
>
mPendingPlayPromisesRunners
.
AppendElement
(
this
)
;
}
void
ResolveOrReject
(
)
{
if
(
NS_SUCCEEDED
(
mError
)
)
{
ResolvePromisesWithUndefined
(
mPromises
)
;
}
else
{
RejectPromises
(
mPromises
mError
)
;
}
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
IsCancelled
(
)
)
{
ResolveOrReject
(
)
;
}
mElement
-
>
mPendingPlayPromisesRunners
.
RemoveElement
(
this
)
;
return
NS_OK
;
}
}
;
class
HTMLMediaElement
:
:
nsNotifyAboutPlayingRunner
:
public
nsResolveOrRejectPendingPlayPromisesRunner
{
public
:
nsNotifyAboutPlayingRunner
(
HTMLMediaElement
*
aElement
nsTArray
<
RefPtr
<
PlayPromise
>
>
&
&
aPendingPlayPromises
)
:
nsResolveOrRejectPendingPlayPromisesRunner
(
aElement
std
:
:
move
(
aPendingPlayPromises
)
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
IsCancelled
(
)
)
{
mElement
-
>
mPendingPlayPromisesRunners
.
RemoveElement
(
this
)
;
return
NS_OK
;
}
mElement
-
>
DispatchEvent
(
NS_LITERAL_STRING
(
"
playing
"
)
)
;
return
nsResolveOrRejectPendingPlayPromisesRunner
:
:
Run
(
)
;
}
}
;
class
nsSourceErrorEventRunner
:
public
nsMediaEvent
{
private
:
nsCOMPtr
<
nsIContent
>
mSource
;
public
:
nsSourceErrorEventRunner
(
HTMLMediaElement
*
aElement
nsIContent
*
aSource
)
:
nsMediaEvent
(
"
dom
:
:
nsSourceErrorEventRunner
"
aElement
)
mSource
(
aSource
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
IsCancelled
(
)
)
return
NS_OK
;
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Dispatching
simple
event
source
error
"
mElement
.
get
(
)
)
)
;
return
nsContentUtils
:
:
DispatchTrustedEvent
(
mElement
-
>
OwnerDoc
(
)
mSource
NS_LITERAL_STRING
(
"
error
"
)
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
}
}
;
class
HTMLMediaElement
:
:
StreamSizeListener
:
public
DirectMediaStreamTrackListener
{
public
:
explicit
StreamSizeListener
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
mMainThreadEventTarget
(
aElement
-
>
MainThreadEventTarget
(
)
)
mInitialSizeFound
(
false
)
{
MOZ_ASSERT
(
mElement
)
;
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
}
void
Forget
(
)
{
mElement
=
nullptr
;
}
void
ReceivedSize
(
gfx
:
:
IntSize
aSize
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mElement
)
{
return
;
}
RefPtr
<
HTMLMediaElement
>
deathGrip
=
mElement
;
deathGrip
-
>
UpdateInitialMediaSize
(
aSize
)
;
}
void
NotifyRealtimeTrackData
(
MediaStreamGraph
*
aGraph
StreamTime
aTrackOffset
const
MediaSegment
&
aMedia
)
override
{
if
(
mInitialSizeFound
)
{
return
;
}
if
(
aMedia
.
GetType
(
)
!
=
MediaSegment
:
:
VIDEO
)
{
MOZ_ASSERT
(
false
"
Should
only
lock
on
to
a
video
track
"
)
;
return
;
}
const
VideoSegment
&
video
=
static_cast
<
const
VideoSegment
&
>
(
aMedia
)
;
for
(
VideoSegment
:
:
ConstChunkIterator
c
(
video
)
;
!
c
.
IsEnded
(
)
;
c
.
Next
(
)
)
{
if
(
c
-
>
mFrame
.
GetIntrinsicSize
(
)
!
=
gfx
:
:
IntSize
(
0
0
)
)
{
mInitialSizeFound
=
true
;
mMainThreadEventTarget
-
>
Dispatch
(
NewRunnableMethod
<
gfx
:
:
IntSize
>
(
"
dom
:
:
HTMLMediaElement
:
:
StreamSizeListener
:
:
ReceivedSize
"
this
&
StreamSizeListener
:
:
ReceivedSize
c
-
>
mFrame
.
GetIntrinsicSize
(
)
)
)
;
return
;
}
}
}
private
:
HTMLMediaElement
*
mElement
;
nsCOMPtr
<
nsISerialEventTarget
>
mMainThreadEventTarget
;
bool
mInitialSizeFound
;
}
;
class
HTMLMediaElement
:
:
MediaLoadListener
final
:
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIInterfaceRequestor
public
nsIObserver
public
nsIThreadRetargetableStreamListener
{
~
MediaLoadListener
(
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIOBSERVER
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
public
:
explicit
MediaLoadListener
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
mLoadID
(
aElement
-
>
GetCurrentLoadID
(
)
)
{
MOZ_ASSERT
(
mElement
"
Must
pass
an
element
to
call
back
"
)
;
}
private
:
RefPtr
<
HTMLMediaElement
>
mElement
;
nsCOMPtr
<
nsIStreamListener
>
mNextListener
;
const
uint32_t
mLoadID
;
}
;
NS_IMPL_ISUPPORTS
(
HTMLMediaElement
:
:
MediaLoadListener
nsIRequestObserver
nsIStreamListener
nsIChannelEventSink
nsIInterfaceRequestor
nsIObserver
nsIThreadRetargetableStreamListener
)
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
mElement
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
if
(
!
mElement
)
{
return
NS_BINDING_ABORTED
;
}
if
(
recordreplay
:
:
IsRecordingOrReplaying
(
)
)
{
mElement
-
>
ReportLoadError
(
"
Media
elements
not
available
when
recording
"
nullptr
0
)
;
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
HTMLMediaElement
>
element
;
element
.
swap
(
mElement
)
;
AbstractThread
:
:
AutoEnter
context
(
element
-
>
AbstractMainThread
(
)
)
;
if
(
mLoadID
!
=
element
-
>
GetCurrentLoadID
(
)
)
{
return
NS_BINDING_ABORTED
;
}
nsresult
status
;
nsresult
rv
=
aRequest
-
>
GetStatus
(
&
status
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
NS_FAILED
(
status
)
)
{
if
(
element
)
{
if
(
status
=
=
NS_ERROR_TRACKING_URI
)
{
nsIDocument
*
ownerDoc
=
element
-
>
OwnerDoc
(
)
;
if
(
ownerDoc
)
{
ownerDoc
-
>
AddBlockedTrackingNode
(
element
)
;
}
}
element
-
>
NotifyLoadError
(
nsPrintfCString
(
"
%
u
:
%
s
"
uint32_t
(
status
)
"
Request
failed
"
)
)
;
}
return
status
;
}
nsCOMPtr
<
nsIHttpChannel
>
hc
=
do_QueryInterface
(
aRequest
)
;
bool
succeeded
;
if
(
hc
&
&
NS_SUCCEEDED
(
hc
-
>
GetRequestSucceeded
(
&
succeeded
)
)
&
&
!
succeeded
)
{
uint32_t
responseStatus
=
0
;
Unused
<
<
hc
-
>
GetResponseStatus
(
&
responseStatus
)
;
nsAutoCString
statusText
;
Unused
<
<
hc
-
>
GetResponseStatusText
(
statusText
)
;
element
-
>
NotifyLoadError
(
nsPrintfCString
(
"
%
u
:
%
s
"
responseStatus
statusText
.
get
(
)
)
)
;
nsAutoString
code
;
code
.
AppendInt
(
responseStatus
)
;
nsAutoString
src
;
element
-
>
GetCurrentSrc
(
src
)
;
const
char16_t
*
params
[
]
=
{
code
.
get
(
)
src
.
get
(
)
}
;
element
-
>
ReportLoadError
(
"
MediaLoadHttpError
"
params
ArrayLength
(
params
)
)
;
return
NS_BINDING_ABORTED
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
if
(
channel
&
&
NS_SUCCEEDED
(
rv
=
element
-
>
InitializeDecoderForChannel
(
channel
getter_AddRefs
(
mNextListener
)
)
)
&
&
mNextListener
)
{
rv
=
mNextListener
-
>
OnStartRequest
(
aRequest
aContext
)
;
}
else
{
if
(
NS_FAILED
(
rv
)
&
&
!
mNextListener
)
{
element
-
>
NotifyLoadError
(
NS_LITERAL_CSTRING
(
"
Failed
to
init
decoder
"
)
)
;
}
rv
=
NS_BINDING_ABORTED
;
}
return
rv
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatus
)
{
if
(
mNextListener
)
{
return
mNextListener
-
>
OnStopRequest
(
aRequest
aContext
aStatus
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
!
mNextListener
)
{
NS_ERROR
(
"
Must
have
a
chained
listener
;
OnStartRequest
should
have
"
"
canceled
this
request
"
)
;
return
NS_BINDING_ABORTED
;
}
return
mNextListener
-
>
OnDataAvailable
(
aRequest
aContext
aStream
aOffset
aCount
)
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
if
(
mElement
)
{
mElement
-
>
OnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
)
;
}
nsCOMPtr
<
nsIChannelEventSink
>
sink
=
do_QueryInterface
(
mNextListener
)
;
if
(
sink
)
{
return
sink
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
cb
)
;
}
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
CheckListenerChain
(
)
{
MOZ_ASSERT
(
mNextListener
)
;
nsCOMPtr
<
nsIThreadRetargetableStreamListener
>
retargetable
=
do_QueryInterface
(
mNextListener
)
;
if
(
retargetable
)
{
return
retargetable
-
>
CheckListenerChain
(
)
;
}
return
NS_ERROR_NO_INTERFACE
;
}
NS_IMETHODIMP
HTMLMediaElement
:
:
MediaLoadListener
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
return
QueryInterface
(
aIID
aResult
)
;
}
void
HTMLMediaElement
:
:
ReportLoadError
(
const
char
*
aMsg
const
char16_t
*
*
aParams
uint32_t
aParamCount
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
aMsg
aParams
aParamCount
)
;
}
class
HTMLMediaElement
:
:
AudioChannelAgentCallback
final
:
public
nsIAudioChannelAgentCallback
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
AudioChannelAgentCallback
)
explicit
AudioChannelAgentCallback
(
HTMLMediaElement
*
aOwner
)
:
mOwner
(
aOwner
)
mAudioChannelVolume
(
1
.
0
)
mPlayingThroughTheAudioChannel
(
false
)
mAudioCapturedByWindow
(
false
)
mSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
mIsOwnerAudible
(
IsOwnerAudible
(
)
)
mIsShutDown
(
false
)
{
MOZ_ASSERT
(
mOwner
)
;
MaybeCreateAudioChannelAgent
(
)
;
}
void
UpdateAudioChannelPlayingState
(
bool
aForcePlaying
=
false
)
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
bool
playingThroughTheAudioChannel
=
aForcePlaying
|
|
IsPlayingThroughTheAudioChannel
(
)
;
if
(
playingThroughTheAudioChannel
!
=
mPlayingThroughTheAudioChannel
)
{
if
(
!
MaybeCreateAudioChannelAgent
(
)
)
{
return
;
}
mPlayingThroughTheAudioChannel
=
playingThroughTheAudioChannel
;
NotifyAudioChannelAgent
(
mPlayingThroughTheAudioChannel
)
;
}
}
bool
ShouldResetSuspend
(
)
const
{
if
(
!
mOwner
-
>
Paused
(
)
&
&
mSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
)
{
return
true
;
}
if
(
mOwner
-
>
Paused
(
)
&
&
mSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
{
return
true
;
}
return
false
;
}
void
NotifyPlayStateChanged
(
)
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
if
(
ShouldResetSuspend
(
)
)
{
SetSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
ePauseStateChanged
)
;
}
UpdateAudioChannelPlayingState
(
)
;
}
NS_IMETHODIMP
WindowVolumeChanged
(
float
aVolume
bool
aMuted
)
override
{
MOZ_ASSERT
(
mAudioChannelAgent
)
;
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
:
:
AudioChannelAgentCallback
WindowVolumeChanged
"
"
this
=
%
p
aVolume
=
%
f
aMuted
=
%
s
\
n
"
this
aVolume
aMuted
?
"
true
"
:
"
false
"
)
)
;
if
(
mAudioChannelVolume
!
=
aVolume
)
{
mAudioChannelVolume
=
aVolume
;
mOwner
-
>
SetVolumeInternal
(
)
;
}
const
uint32_t
muted
=
mOwner
-
>
mMuted
;
if
(
aMuted
&
&
!
mOwner
-
>
ComputedMuted
(
)
)
{
mOwner
-
>
SetMutedInternal
(
muted
|
MUTED_BY_AUDIO_CHANNEL
)
;
}
else
if
(
!
aMuted
&
&
mOwner
-
>
ComputedMuted
(
)
)
{
mOwner
-
>
SetMutedInternal
(
muted
&
~
MUTED_BY_AUDIO_CHANNEL
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WindowSuspendChanged
(
SuspendTypes
aSuspend
)
override
{
MOZ_ASSERT
(
mAudioChannelAgent
)
;
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
:
:
AudioChannelAgentCallback
WindowSuspendChanged
"
"
this
=
%
p
aSuspend
=
%
s
\
n
"
this
SuspendTypeToStr
(
aSuspend
)
)
)
;
switch
(
aSuspend
)
{
case
nsISuspendedTypes
:
:
NONE_SUSPENDED
:
Resume
(
)
;
break
;
case
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
:
case
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
:
case
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
:
Suspend
(
aSuspend
)
;
break
;
case
nsISuspendedTypes
:
:
SUSPENDED_STOP_DISPOSABLE
:
Stop
(
)
;
break
;
default
:
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
:
:
AudioChannelAgentCallback
WindowSuspendChanged
"
"
this
=
%
p
Error
:
unknown
suspended
type
!
\
n
"
this
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
WindowAudioCaptureChanged
(
bool
aCapture
)
override
{
MOZ_ASSERT
(
mAudioChannelAgent
)
;
if
(
mAudioCapturedByWindow
!
=
aCapture
)
{
mAudioCapturedByWindow
=
aCapture
;
AudioCaptureStreamChangeIfNeeded
(
)
;
}
return
NS_OK
;
}
void
AudioCaptureStreamChangeIfNeeded
(
)
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
if
(
!
IsPlayingStarted
(
)
)
{
return
;
}
if
(
!
mOwner
-
>
HasAudio
(
)
)
{
return
;
}
mOwner
-
>
AudioCaptureStreamChange
(
mAudioCapturedByWindow
)
;
}
void
NotifyAudioPlaybackChanged
(
AudibleChangedReasons
aReason
)
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
if
(
!
IsPlayingStarted
(
)
)
{
return
;
}
AudibleState
newAudibleState
=
IsOwnerAudible
(
)
;
if
(
mIsOwnerAudible
=
=
newAudibleState
)
{
return
;
}
mIsOwnerAudible
=
newAudibleState
;
mAudioChannelAgent
-
>
NotifyStartedAudible
(
mIsOwnerAudible
aReason
)
;
}
bool
IsPlaybackBlocked
(
)
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
if
(
!
IsTabActivated
(
)
)
{
UpdateAudioChannelPlayingState
(
true
)
;
return
true
;
}
return
false
;
}
void
Shutdown
(
)
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
if
(
mAudioChannelAgent
)
{
mAudioChannelAgent
-
>
NotifyStoppedPlaying
(
)
;
mAudioChannelAgent
=
nullptr
;
}
mIsShutDown
=
true
;
}
float
GetEffectiveVolume
(
)
const
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
return
mOwner
-
>
Volume
(
)
*
mAudioChannelVolume
;
}
SuspendTypes
GetSuspendType
(
)
const
{
MOZ_ASSERT
(
!
mIsShutDown
)
;
return
mSuspended
;
}
private
:
~
AudioChannelAgentCallback
(
)
{
MOZ_ASSERT
(
mIsShutDown
)
;
}
;
bool
MaybeCreateAudioChannelAgent
(
)
{
if
(
mAudioChannelAgent
)
{
return
true
;
}
mAudioChannelAgent
=
new
AudioChannelAgent
(
)
;
nsresult
rv
=
mAudioChannelAgent
-
>
Init
(
mOwner
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mAudioChannelAgent
=
nullptr
;
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
:
:
AudioChannelAgentCallback
Fail
to
initialize
"
"
the
audio
channel
agent
this
=
%
p
\
n
"
this
)
)
;
return
false
;
}
return
true
;
}
void
NotifyAudioChannelAgent
(
bool
aPlaying
)
{
MOZ_ASSERT
(
mAudioChannelAgent
)
;
if
(
aPlaying
)
{
AudioPlaybackConfig
config
;
nsresult
rv
=
mAudioChannelAgent
-
>
NotifyStartedPlaying
(
&
config
IsOwnerAudible
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
WindowVolumeChanged
(
config
.
mVolume
config
.
mMuted
)
;
WindowSuspendChanged
(
config
.
mSuspend
)
;
}
else
{
mAudioChannelAgent
-
>
NotifyStoppedPlaying
(
)
;
}
}
void
SetSuspended
(
SuspendTypes
aSuspend
)
{
if
(
mSuspended
=
=
aSuspend
)
{
return
;
}
MaybeNotifyMediaResumed
(
aSuspend
)
;
mSuspended
=
aSuspend
;
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
:
:
AudioChannelAgentCallback
SetAudioChannelSuspended
"
"
this
=
%
p
aSuspend
=
%
s
\
n
"
this
SuspendTypeToStr
(
aSuspend
)
)
)
;
}
void
Resume
(
)
{
if
(
!
IsSuspended
(
)
)
{
MOZ_LOG
(
AudioChannelService
:
:
GetAudioChannelLog
(
)
LogLevel
:
:
Debug
(
"
HTMLMediaElement
:
:
AudioChannelAgentCallback
ResumeFromAudioChannel
"
"
this
=
%
p
don
'
t
need
to
be
resumed
!
\
n
"
this
)
)
;
return
;
}
SetSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
IgnoredErrorResult
rv
;
RefPtr
<
Promise
>
toBeIgnored
=
mOwner
-
>
Play
(
rv
)
;
MOZ_ASSERT_IF
(
toBeIgnored
&
&
toBeIgnored
-
>
State
(
)
=
=
Promise
:
:
PromiseState
:
:
Rejected
rv
.
Failed
(
)
)
;
if
(
rv
.
Failed
(
)
)
{
NS_WARNING
(
"
Not
able
to
resume
from
AudioChannel
.
"
)
;
}
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
ePauseStateChanged
)
;
}
void
Suspend
(
SuspendTypes
aSuspend
)
{
if
(
IsSuspended
(
)
)
{
return
;
}
SetSuspended
(
aSuspend
)
;
if
(
aSuspend
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
|
|
aSuspend
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
)
{
IgnoredErrorResult
rv
;
mOwner
-
>
Pause
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
;
}
}
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
ePauseStateChanged
)
;
}
void
Stop
(
)
{
SetSuspended
(
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
;
mOwner
-
>
Pause
(
)
;
}
bool
IsPlayingStarted
(
)
{
if
(
MaybeCreateAudioChannelAgent
(
)
)
{
return
mAudioChannelAgent
-
>
IsPlayingStarted
(
)
;
}
return
false
;
}
void
MaybeNotifyMediaResumed
(
SuspendTypes
aSuspend
)
{
if
(
mSuspended
!
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
&
&
aSuspend
!
=
nsISuspendedTypes
:
:
NONE_SUSPENDED
)
{
return
;
}
if
(
!
IsPlayingStarted
(
)
)
{
return
;
}
uint64_t
windowID
=
mAudioChannelAgent
-
>
WindowID
(
)
;
mOwner
-
>
MainThreadEventTarget
(
)
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
dom
:
:
HTMLMediaElement
:
:
AudioChannelAgentCallback
:
:
"
"
MaybeNotifyMediaResumed
"
[
windowID
]
(
)
-
>
void
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
observerService
)
)
{
return
;
}
nsCOMPtr
<
nsISupportsPRUint64
>
wrapper
=
do_CreateInstance
(
NS_SUPPORTS_PRUINT64_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
wrapper
)
)
{
return
;
}
wrapper
-
>
SetData
(
windowID
)
;
observerService
-
>
NotifyObservers
(
wrapper
"
media
-
playback
-
resumed
"
u
"
active
"
)
;
}
)
)
;
}
bool
IsTabActivated
(
)
{
if
(
MaybeCreateAudioChannelAgent
(
)
)
{
return
!
mAudioChannelAgent
-
>
ShouldBlockMedia
(
)
;
}
return
false
;
}
bool
IsSuspended
(
)
const
{
return
(
mSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
|
|
mSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE_DISPOSABLE
|
|
mSuspended
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
)
;
}
AudibleState
IsOwnerAudible
(
)
const
{
if
(
mOwner
-
>
mMuted
|
|
(
std
:
:
fabs
(
mOwner
-
>
Volume
(
)
)
<
=
1e
-
7
)
)
{
return
mOwner
-
>
HasAudio
(
)
?
AudioChannelService
:
:
AudibleState
:
:
eMaybeAudible
:
AudioChannelService
:
:
AudibleState
:
:
eNotAudible
;
}
if
(
!
mOwner
-
>
HasAudio
(
)
)
{
return
AudioChannelService
:
:
AudibleState
:
:
eNotAudible
;
}
if
(
mOwner
-
>
HasAudio
(
)
&
&
!
mOwner
-
>
mIsAudioTrackAudible
)
{
return
AudioChannelService
:
:
AudibleState
:
:
eMaybeAudible
;
}
if
(
mSuspended
!
=
nsISuspendedTypes
:
:
NONE_SUSPENDED
|
|
mOwner
-
>
mPaused
)
{
return
AudioChannelService
:
:
AudibleState
:
:
eNotAudible
;
}
return
AudioChannelService
:
:
AudibleState
:
:
eAudible
;
}
bool
IsPlayingThroughTheAudioChannel
(
)
const
{
if
(
mOwner
-
>
GetError
(
)
)
{
return
false
;
}
if
(
!
mOwner
-
>
IsActive
(
)
)
{
return
false
;
}
if
(
IsSuspended
(
)
)
{
return
true
;
}
if
(
mOwner
-
>
mPaused
)
{
return
false
;
}
if
(
!
mOwner
-
>
HasAudio
(
)
)
{
return
false
;
}
if
(
mOwner
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loop
)
)
{
return
true
;
}
if
(
mOwner
-
>
IsCurrentlyPlaying
(
)
)
{
return
true
;
}
if
(
mOwner
-
>
mSrcAttrStream
)
{
return
true
;
}
return
false
;
}
RefPtr
<
AudioChannelAgent
>
mAudioChannelAgent
;
HTMLMediaElement
*
mOwner
;
float
mAudioChannelVolume
;
bool
mPlayingThroughTheAudioChannel
;
bool
mAudioCapturedByWindow
;
SuspendTypes
mSuspended
;
AudibleState
mIsOwnerAudible
;
bool
mIsShutDown
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLMediaElement
:
:
AudioChannelAgentCallback
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
HTMLMediaElement
:
:
AudioChannelAgentCallback
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioChannelAgent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
HTMLMediaElement
:
:
AudioChannelAgentCallback
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioChannelAgent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLMediaElement
:
:
AudioChannelAgentCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIAudioChannelAgentCallback
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
HTMLMediaElement
:
:
AudioChannelAgentCallback
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
HTMLMediaElement
:
:
AudioChannelAgentCallback
)
class
HTMLMediaElement
:
:
ChannelLoader
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ChannelLoader
)
;
void
LoadInternal
(
HTMLMediaElement
*
aElement
)
{
if
(
mCancelled
)
{
return
;
}
nsSecurityFlags
securityFlags
=
aElement
-
>
ShouldCheckAllowOrigin
(
)
?
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
:
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
;
if
(
aElement
-
>
GetCORSMode
(
)
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
MOZ_ASSERT
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
audio
nsGkAtoms
:
:
video
)
)
;
nsContentPolicyType
contentPolicyType
=
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
audio
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
;
bool
setAttrs
=
nsContentUtils
:
:
QueryTriggeringPrincipal
(
aElement
aElement
-
>
mLoadingSrcTriggeringPrincipal
getter_AddRefs
(
triggeringPrincipal
)
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aElement
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aElement
-
>
mLoadingSrc
static_cast
<
Element
*
>
(
aElement
)
triggeringPrincipal
securityFlags
contentPolicyType
nullptr
loadGroup
nullptr
nsICachingChannel
:
:
LOAD_BYPASS_LOCAL_CACHE_IF_BUSY
|
nsIChannel
:
:
LOAD_MEDIA_SNIFFER_OVERRIDES_CONTENT_TYPE
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
|
nsIChannel
:
:
LOAD_CALL_CONTENT_SNIFFERS
)
;
if
(
NS_FAILED
(
rv
)
)
{
aElement
-
>
NotifyLoadError
(
NS_LITERAL_CSTRING
(
"
Fail
to
create
channel
"
)
)
;
return
;
}
if
(
setAttrs
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
)
{
Unused
<
<
loadInfo
-
>
SetOriginAttributes
(
triggeringPrincipal
-
>
OriginAttributesRef
(
)
)
;
}
}
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
channel
)
)
;
if
(
cos
)
{
if
(
aElement
-
>
mUseUrgentStartForChannel
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
UrgentStart
)
;
aElement
-
>
mUseUrgentStartForChannel
=
false
;
}
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
DontThrottle
)
;
}
RefPtr
<
MediaLoadListener
>
loadListener
=
new
MediaLoadListener
(
aElement
)
;
channel
-
>
SetNotificationCallbacks
(
loadListener
)
;
nsCOMPtr
<
nsIHttpChannel
>
hc
=
do_QueryInterface
(
channel
)
;
if
(
hc
)
{
rv
=
hc
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Range
"
)
NS_LITERAL_CSTRING
(
"
bytes
=
0
-
"
)
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
aElement
-
>
SetRequestHeaders
(
hc
)
;
}
rv
=
channel
-
>
AsyncOpen2
(
loadListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
aElement
-
>
NotifyLoadError
(
NS_LITERAL_CSTRING
(
"
Failed
to
open
channel
"
)
)
;
return
;
}
mChannel
=
channel
;
nsContentUtils
:
:
RegisterShutdownObserver
(
loadListener
)
;
}
nsresult
Load
(
HTMLMediaElement
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
return
aElement
-
>
MainThreadEventTarget
(
)
-
>
Dispatch
(
NewRunnableMethod
<
HTMLMediaElement
*
>
(
"
ChannelLoader
:
:
LoadInternal
"
this
&
ChannelLoader
:
:
LoadInternal
aElement
)
)
;
}
void
Cancel
(
)
{
mCancelled
=
true
;
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mChannel
=
nullptr
;
}
}
void
Done
(
)
{
MOZ_ASSERT
(
mChannel
)
;
mChannel
=
nullptr
;
}
nsresult
Redirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
{
NS_ASSERTION
(
aChannel
=
=
mChannel
"
Channels
should
match
!
"
)
;
mChannel
=
aNewChannel
;
nsCOMPtr
<
nsIHttpChannel
>
http
=
do_QueryInterface
(
aChannel
)
;
NS_ENSURE_STATE
(
http
)
;
NS_NAMED_LITERAL_CSTRING
(
rangeHdr
"
Range
"
)
;
nsAutoCString
rangeVal
;
if
(
NS_SUCCEEDED
(
http
-
>
GetRequestHeader
(
rangeHdr
rangeVal
)
)
)
{
NS_ENSURE_STATE
(
!
rangeVal
.
IsEmpty
(
)
)
;
http
=
do_QueryInterface
(
aNewChannel
)
;
NS_ENSURE_STATE
(
http
)
;
nsresult
rv
=
http
-
>
SetRequestHeader
(
rangeHdr
rangeVal
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
private
:
~
ChannelLoader
(
)
{
MOZ_ASSERT
(
!
mChannel
)
;
}
nsCOMPtr
<
nsIChannel
>
mChannel
;
bool
mCancelled
=
false
;
}
;
class
HTMLMediaElement
:
:
ErrorSink
{
public
:
explicit
ErrorSink
(
HTMLMediaElement
*
aOwner
)
:
mOwner
(
aOwner
)
mSrcIsUnsupportedTypeMedia
(
false
)
{
MOZ_ASSERT
(
mOwner
)
;
}
void
SetError
(
uint16_t
aErrorCode
const
nsACString
&
aErrorDetails
)
{
if
(
mError
)
{
return
;
}
if
(
!
IsValidErrorCode
(
aErrorCode
)
)
{
NS_ASSERTION
(
false
"
Undefined
MediaError
codes
!
"
)
;
return
;
}
if
(
CanOwnerPlayUnsupportedTypeMedia
(
)
&
&
aErrorCode
=
=
MEDIA_ERR_SRC_NOT_SUPPORTED
)
{
mSrcIsUnsupportedTypeMedia
=
true
;
mOwner
-
>
ChangeNetworkState
(
NETWORK_NO_SOURCE
)
;
MaybeOpenUnsupportedMediaForOwner
(
)
;
}
else
{
mError
=
new
MediaError
(
mOwner
aErrorCode
aErrorDetails
)
;
mOwner
-
>
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
error
"
)
)
;
if
(
mOwner
-
>
ReadyState
(
)
=
=
HAVE_NOTHING
&
&
aErrorCode
=
=
MEDIA_ERR_ABORTED
)
{
mOwner
-
>
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
abort
"
)
)
;
mOwner
-
>
ChangeNetworkState
(
NETWORK_EMPTY
)
;
mOwner
-
>
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
emptied
"
)
)
;
if
(
mOwner
-
>
mDecoder
)
{
mOwner
-
>
ShutdownDecoder
(
)
;
}
}
else
if
(
aErrorCode
=
=
MEDIA_ERR_SRC_NOT_SUPPORTED
)
{
mOwner
-
>
ChangeNetworkState
(
NETWORK_NO_SOURCE
)
;
}
else
{
mOwner
-
>
ChangeNetworkState
(
NETWORK_IDLE
)
;
}
}
}
void
ResetError
(
)
{
mError
=
nullptr
;
mSrcIsUnsupportedTypeMedia
=
false
;
}
void
MaybeOpenUnsupportedMediaForOwner
(
)
const
{
if
(
!
mSrcIsUnsupportedTypeMedia
|
|
!
CanOwnerPlayUnsupportedTypeMedia
(
)
)
{
return
;
}
if
(
mOwner
-
>
Paused
(
)
)
{
return
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
mOwner
-
>
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
mOwner
)
NS_LITERAL_STRING
(
"
OpenMediaWithExternalApp
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
}
RefPtr
<
MediaError
>
mError
;
private
:
bool
IsValidErrorCode
(
const
uint16_t
&
aErrorCode
)
const
{
return
(
aErrorCode
=
=
MEDIA_ERR_DECODE
|
|
aErrorCode
=
=
MEDIA_ERR_NETWORK
|
|
aErrorCode
=
=
MEDIA_ERR_ABORTED
|
|
aErrorCode
=
=
MEDIA_ERR_SRC_NOT_SUPPORTED
)
;
}
bool
CanOwnerPlayUnsupportedTypeMedia
(
)
const
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
return
Preferences
:
:
GetBool
(
"
media
.
openUnsupportedTypeWithExternalApp
"
)
;
#
endif
return
false
;
}
HTMLMediaElement
*
mOwner
;
bool
mSrcIsUnsupportedTypeMedia
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLMediaElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMediaSource
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSrcMediaSource
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSrcStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSrcAttrStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSourcePointer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLoadBlockedDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSourceLoadCandidate
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioChannelWrapper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mErrorSink
-
>
mError
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mOutputStreams
.
Length
(
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOutputStreams
[
i
]
.
mStream
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOutputStreams
[
i
]
.
mPreCreatedTracks
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPlayed
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTextTrackManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioTrackList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mVideoTrackList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMediaKeys
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIncomingMediaKeys
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectedVideoStreamTrack
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPendingPlayPromises
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSeekDOMPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSetMediaKeysDOMPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLMediaElement
nsGenericHTMLElement
)
tmp
-
>
RemoveMutationObserver
(
tmp
)
;
if
(
tmp
-
>
mSrcStream
)
{
tmp
-
>
EndSrcMediaStreamPlayback
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSrcAttrStream
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMediaSource
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSrcMediaSource
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSourcePointer
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLoadBlockedDoc
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSourceLoadCandidate
)
if
(
tmp
-
>
mAudioChannelWrapper
)
{
tmp
-
>
mAudioChannelWrapper
-
>
Shutdown
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioChannelWrapper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mErrorSink
-
>
mError
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOutputStreams
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPlayed
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTextTrackManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioTrackList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mVideoTrackList
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMediaKeys
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIncomingMediaKeys
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelectedVideoStreamTrack
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPendingPlayPromises
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSeekDOMPromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSetMediaKeysDOMPromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
HTMLMediaElement
nsGenericHTMLElement
)
void
HTMLMediaElement
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
aChild
=
=
mSourcePointer
)
{
mSourcePointer
=
aPreviousSibling
;
}
}
already_AddRefed
<
MediaSource
>
HTMLMediaElement
:
:
GetMozMediaSourceObject
(
)
const
{
RefPtr
<
MediaSource
>
source
=
mMediaSource
;
return
source
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
GetMozDebugReaderData
(
nsAString
&
aString
)
{
if
(
mDecoder
&
&
!
mSrcStream
)
{
nsAutoCString
result
;
mDecoder
-
>
GetMozDebugReaderData
(
result
)
;
CopyUTF8toUTF16
(
result
aString
)
;
}
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
MozRequestDebugInfo
(
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
CreateDOMPromise
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nsAutoString
result
;
GetMozDebugReaderData
(
result
)
;
if
(
mVideoFrameContainer
)
{
result
.
AppendPrintf
(
"
Compositor
dropped
frame
(
including
when
element
'
s
invisible
)
:
%
u
\
n
"
mVideoFrameContainer
-
>
GetDroppedImageCount
(
)
)
;
}
if
(
mMediaKeys
)
{
nsString
EMEInfo
;
GetEMEInfo
(
EMEInfo
)
;
result
.
AppendLiteral
(
"
EME
Info
:
"
)
;
result
.
Append
(
EMEInfo
)
;
result
.
AppendLiteral
(
"
\
n
"
)
;
}
if
(
mDecoder
)
{
mDecoder
-
>
RequestDebugInfo
(
)
-
>
Then
(
mAbstractMainThread
__func__
[
promise
result
]
(
const
nsACString
&
aString
)
{
promise
-
>
MaybeResolve
(
result
+
NS_ConvertUTF8toUTF16
(
aString
)
)
;
}
[
promise
result
]
(
)
{
promise
-
>
MaybeResolve
(
result
)
;
}
)
;
}
else
{
promise
-
>
MaybeResolve
(
result
)
;
}
return
promise
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
MozEnableDebugLog
(
const
GlobalObject
&
)
{
DecoderDoctorLogger
:
:
EnableLogging
(
)
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
MozRequestDebugLog
(
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
CreateDOMPromise
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
DecoderDoctorLogger
:
:
RetrieveMessages
(
this
)
-
>
Then
(
mAbstractMainThread
__func__
[
promise
]
(
const
nsACString
&
aString
)
{
promise
-
>
MaybeResolve
(
NS_ConvertUTF8toUTF16
(
aString
)
)
;
}
[
promise
]
(
nsresult
rv
)
{
promise
-
>
MaybeReject
(
rv
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
MozDumpDebugInfo
(
)
{
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
CreateDOMPromise
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
mDecoder
)
{
mDecoder
-
>
DumpDebugInfo
(
)
-
>
Then
(
mAbstractMainThread
__func__
promise
.
get
(
)
&
Promise
:
:
MaybeResolveWithUndefined
)
;
}
else
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
return
promise
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
SetVisible
(
bool
aVisible
)
{
mForcedHidden
=
!
aVisible
;
if
(
mDecoder
)
{
mDecoder
-
>
SetForcedHidden
(
!
aVisible
)
;
}
}
already_AddRefed
<
layers
:
:
Image
>
HTMLMediaElement
:
:
GetCurrentImage
(
)
{
MarkAsTainted
(
)
;
ImageContainer
*
container
=
GetImageContainer
(
)
;
if
(
!
container
)
{
return
nullptr
;
}
AutoLockImage
lockImage
(
container
)
;
RefPtr
<
layers
:
:
Image
>
image
=
lockImage
.
GetImage
(
TimeStamp
:
:
Now
(
)
)
;
return
image
.
forget
(
)
;
}
bool
HTMLMediaElement
:
:
HasSuspendTaint
(
)
const
{
MOZ_ASSERT
(
!
mDecoder
|
|
(
mDecoder
-
>
HasSuspendTaint
(
)
=
=
mHasSuspendTaint
)
)
;
return
mHasSuspendTaint
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
GetSrcObject
(
)
const
{
NS_ASSERTION
(
!
mSrcAttrStream
|
|
mSrcAttrStream
-
>
GetPlaybackStream
(
)
"
MediaStream
should
have
been
set
up
properly
"
)
;
RefPtr
<
DOMMediaStream
>
stream
=
mSrcAttrStream
;
return
stream
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
SetSrcObject
(
DOMMediaStream
&
aValue
)
{
SetSrcObject
(
&
aValue
)
;
}
void
HTMLMediaElement
:
:
SetSrcObject
(
DOMMediaStream
*
aValue
)
{
mSrcAttrStream
=
aValue
;
UpdateAudioChannelPlayingState
(
)
;
DoLoad
(
)
;
}
bool
HTMLMediaElement
:
:
Ended
(
)
{
return
(
mDecoder
&
&
mDecoder
-
>
IsEnded
(
)
)
|
|
(
mSrcStream
&
&
!
mSrcStream
-
>
Active
(
)
)
;
}
void
HTMLMediaElement
:
:
GetCurrentSrc
(
nsAString
&
aCurrentSrc
)
{
nsAutoCString
src
;
GetCurrentSpec
(
src
)
;
CopyUTF8toUTF16
(
src
aCurrentSrc
)
;
}
nsresult
HTMLMediaElement
:
:
OnChannelRedirect
(
nsIChannel
*
aChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
)
{
MOZ_ASSERT
(
mChannelLoader
)
;
return
mChannelLoader
-
>
Redirect
(
aChannel
aNewChannel
aFlags
)
;
}
void
HTMLMediaElement
:
:
ShutdownDecoder
(
)
{
RemoveMediaElementFromURITable
(
)
;
NS_ASSERTION
(
mDecoder
"
Must
have
decoder
to
shut
down
"
)
;
mWaitingForKeyListener
.
DisconnectIfExists
(
)
;
if
(
mMediaSource
)
{
mMediaSource
-
>
CompletePendingTransactions
(
)
;
}
for
(
OutputMediaStream
&
out
:
mOutputStreams
)
{
if
(
!
out
.
mCapturingDecoder
)
{
continue
;
}
out
.
mNextAvailableTrackID
=
std
:
:
max
<
TrackID
>
(
mDecoder
-
>
NextAvailableTrackIDFor
(
out
.
mStream
-
>
GetInputStream
(
)
)
out
.
mNextAvailableTrackID
)
;
}
mDecoder
-
>
Shutdown
(
)
;
DDUNLINKCHILD
(
mDecoder
.
get
(
)
)
;
mDecoder
=
nullptr
;
}
void
HTMLMediaElement
:
:
AbortExistingLoads
(
)
{
mLoadWaitStatus
=
NOT_WAITING
;
mCurrentLoadID
+
+
;
for
(
auto
&
runner
:
mPendingPlayPromisesRunners
)
{
runner
-
>
ResolveOrReject
(
)
;
}
mPendingPlayPromisesRunners
.
Clear
(
)
;
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Cancel
(
)
;
mChannelLoader
=
nullptr
;
}
bool
fireTimeUpdate
=
false
;
if
(
mMediaStreamSizeListener
)
{
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
mMediaStreamSizeListener
-
>
Forget
(
)
;
mMediaStreamSizeListener
=
nullptr
;
}
AudioTracks
(
)
-
>
EmptyTracks
(
)
;
VideoTracks
(
)
-
>
EmptyTracks
(
)
;
if
(
mDecoder
)
{
fireTimeUpdate
=
mDecoder
-
>
GetCurrentTime
(
)
!
=
0
.
0
;
ShutdownDecoder
(
)
;
}
if
(
mSrcStream
)
{
EndSrcMediaStreamPlayback
(
)
;
}
RemoveMediaElementFromURITable
(
)
;
mLoadingSrc
=
nullptr
;
mLoadingSrcTriggeringPrincipal
=
nullptr
;
DDLOG
(
DDLogCategory
:
:
Property
"
loading_src
"
"
"
)
;
DDUNLINKCHILD
(
mMediaSource
.
get
(
)
)
;
mMediaSource
=
nullptr
;
if
(
mNetworkState
=
=
NETWORK_LOADING
|
|
mNetworkState
=
=
NETWORK_IDLE
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
abort
"
)
)
;
}
mErrorSink
-
>
ResetError
(
)
;
mCurrentPlayRangeStart
=
-
1
.
0
;
mLoadedDataFired
=
false
;
mAutoplaying
=
true
;
mIsLoadingFromSourceChildren
=
false
;
mSuspendedAfterFirstFrame
=
false
;
mAllowSuspendAfterFirstFrame
=
true
;
mHaveQueuedSelectResource
=
false
;
mSuspendedForPreloadNone
=
false
;
mDownloadSuspendedByCache
=
false
;
mMediaInfo
=
MediaInfo
(
)
;
mIsEncrypted
=
false
;
mPendingEncryptedInitData
.
Reset
(
)
;
mWaitingForKey
=
NOT_WAITING_FOR_KEY
;
mSourcePointer
=
nullptr
;
mTags
=
nullptr
;
if
(
mNetworkState
!
=
NETWORK_EMPTY
)
{
NS_ASSERTION
(
!
mDecoder
&
&
!
mSrcStream
"
How
did
someone
setup
a
new
stream
/
decoder
already
?
"
)
;
if
(
!
mPaused
)
{
mPaused
=
true
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
pause
"
)
)
;
RejectPromises
(
TakePendingPlayPromises
(
)
NS_ERROR_DOM_MEDIA_ABORT_ERR
)
;
}
ChangeNetworkState
(
NETWORK_EMPTY
)
;
ChangeReadyState
(
HAVE_NOTHING
)
;
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
GetTextTracks
(
)
-
>
SetCuesInactive
(
)
;
}
if
(
fireTimeUpdate
)
{
FireTimeUpdate
(
false
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
emptied
"
)
)
;
UpdateAudioChannelPlayingState
(
)
;
}
mAutoplayPermissionRequest
.
DisconnectIfExists
(
)
;
AddRemoveSelfReference
(
)
;
mIsRunningSelectResource
=
false
;
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
NotifyReset
(
)
;
}
mEventDeliveryPaused
=
false
;
mPendingEvents
.
Clear
(
)
;
AssertReadyStateIsNothing
(
)
;
}
void
HTMLMediaElement
:
:
NoSupportedMediaSourceError
(
const
nsACString
&
aErrorDetails
)
{
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
mErrorSink
-
>
SetError
(
MEDIA_ERR_SRC_NOT_SUPPORTED
aErrorDetails
)
;
ChangeDelayLoadStatus
(
false
)
;
UpdateAudioChannelPlayingState
(
)
;
RejectPromises
(
TakePendingPlayPromises
(
)
NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR
)
;
}
typedef
void
(
HTMLMediaElement
:
:
*
SyncSectionFn
)
(
)
;
class
nsSyncSection
:
public
nsMediaEvent
{
private
:
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
public
:
nsSyncSection
(
HTMLMediaElement
*
aElement
nsIRunnable
*
aRunnable
)
:
nsMediaEvent
(
"
dom
:
:
nsSyncSection
"
aElement
)
mRunnable
(
aRunnable
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
IsCancelled
(
)
)
return
NS_OK
;
mRunnable
-
>
Run
(
)
;
return
NS_OK
;
}
}
;
void
HTMLMediaElement
:
:
RunInStableState
(
nsIRunnable
*
aRunnable
)
{
if
(
mShuttingDown
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsSyncSection
(
this
aRunnable
)
;
nsContentUtils
:
:
RunInStableState
(
event
.
forget
(
)
)
;
}
void
HTMLMediaElement
:
:
QueueLoadFromSourceTask
(
)
{
if
(
!
mIsLoadingFromSourceChildren
|
|
mShuttingDown
)
{
return
;
}
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
ChangeReadyState
(
HAVE_NOTHING
)
;
}
AssertReadyStateIsNothing
(
)
;
ChangeDelayLoadStatus
(
true
)
;
ChangeNetworkState
(
NETWORK_LOADING
)
;
RefPtr
<
Runnable
>
r
=
NewRunnableMethod
(
"
HTMLMediaElement
:
:
LoadFromSourceChildren
"
this
&
HTMLMediaElement
:
:
LoadFromSourceChildren
)
;
RunInStableState
(
r
)
;
}
void
HTMLMediaElement
:
:
QueueSelectResourceTask
(
)
{
if
(
mHaveQueuedSelectResource
)
return
;
mHaveQueuedSelectResource
=
true
;
ChangeNetworkState
(
NETWORK_NO_SOURCE
)
;
RefPtr
<
Runnable
>
r
=
NewRunnableMethod
(
"
HTMLMediaElement
:
:
SelectResourceWrapper
"
this
&
HTMLMediaElement
:
:
SelectResourceWrapper
)
;
RunInStableState
(
r
)
;
}
static
bool
HasSourceChildren
(
nsIContent
*
aElement
)
{
for
(
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
)
{
return
true
;
}
}
return
false
;
}
static
nsCString
DocumentOrigin
(
nsIDocument
*
aDoc
)
{
if
(
!
aDoc
)
{
return
NS_LITERAL_CSTRING
(
"
null
"
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aDoc
-
>
NodePrincipal
(
)
;
if
(
!
principal
)
{
return
NS_LITERAL_CSTRING
(
"
null
"
)
;
}
nsCString
origin
;
if
(
NS_FAILED
(
principal
-
>
GetOrigin
(
origin
)
)
)
{
return
NS_LITERAL_CSTRING
(
"
null
"
)
;
}
return
origin
;
}
void
HTMLMediaElement
:
:
Load
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Load
(
)
hasSrcAttrStream
=
%
d
hasSrcAttr
=
%
d
hasSourceChildren
=
%
d
"
"
handlingInput
=
%
d
hasAutoplayAttr
=
%
d
IsAllowedToPlay
=
%
d
"
"
ownerDoc
=
%
p
(
%
s
)
ownerDocUserActivated
=
%
d
"
"
muted
=
%
d
volume
=
%
f
"
this
!
!
mSrcAttrStream
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
HasSourceChildren
(
this
)
EventStateManager
:
:
IsHandlingUserInput
(
)
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
AutoplayPolicy
:
:
IsAllowedToPlay
(
*
this
)
=
=
nsIAutoplay
:
:
ALLOWED
OwnerDoc
(
)
DocumentOrigin
(
OwnerDoc
(
)
)
.
get
(
)
OwnerDoc
(
)
?
OwnerDoc
(
)
-
>
HasBeenUserGestureActivated
(
)
:
0
mMuted
mVolume
)
)
;
if
(
mIsRunningLoadMethod
)
{
return
;
}
mIsDoingExplicitLoad
=
true
;
DoLoad
(
)
;
}
void
HTMLMediaElement
:
:
DoLoad
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
if
(
docShell
&
&
!
docShell
-
>
GetAllowMedia
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Media
not
allowed
"
this
)
)
;
return
;
}
if
(
mIsRunningLoadMethod
)
{
return
;
}
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
mIsBlessed
=
true
;
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
)
{
mUseUrgentStartForChannel
=
true
;
}
}
SetPlayedOrSeeked
(
false
)
;
mIsRunningLoadMethod
=
true
;
AbortExistingLoads
(
)
;
SetPlaybackRate
(
mDefaultPlaybackRate
IgnoreErrors
(
)
)
;
QueueSelectResourceTask
(
)
;
ResetState
(
)
;
mIsRunningLoadMethod
=
false
;
}
void
HTMLMediaElement
:
:
ResetState
(
)
{
if
(
mVideoFrameContainer
)
{
mVideoFrameContainer
-
>
ForgetElement
(
)
;
mVideoFrameContainer
=
nullptr
;
}
}
void
HTMLMediaElement
:
:
SelectResourceWrapper
(
)
{
SelectResource
(
)
;
mIsRunningSelectResource
=
false
;
mHaveQueuedSelectResource
=
false
;
mIsDoingExplicitLoad
=
false
;
}
void
HTMLMediaElement
:
:
SelectResource
(
)
{
if
(
!
mSrcAttrStream
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
&
&
!
HasSourceChildren
(
this
)
)
{
ChangeNetworkState
(
NETWORK_EMPTY
)
;
ChangeDelayLoadStatus
(
false
)
;
return
;
}
ChangeDelayLoadStatus
(
true
)
;
ChangeNetworkState
(
NETWORK_LOADING
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadstart
"
)
)
;
UpdatePreloadAction
(
)
;
mIsRunningSelectResource
=
true
;
nsAutoString
src
;
if
(
mSrcAttrStream
)
{
SetupSrcMediaStreamPlayback
(
mSrcAttrStream
)
;
}
else
if
(
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
MediaResult
rv
=
NewURIFromString
(
src
getter_AddRefs
(
uri
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Trying
load
from
src
=
%
s
"
this
NS_ConvertUTF16toUTF8
(
src
)
.
get
(
)
)
)
;
NS_ASSERTION
(
!
mIsLoadingFromSourceChildren
"
Should
think
we
'
re
not
loading
from
source
children
by
default
"
)
;
RemoveMediaElementFromURITable
(
)
;
mLoadingSrc
=
uri
;
mLoadingSrcTriggeringPrincipal
=
mSrcAttrTriggeringPrincipal
;
DDLOG
(
DDLogCategory
:
:
Property
"
loading_src
"
nsCString
(
NS_ConvertUTF16toUTF8
(
src
)
)
)
;
mMediaSource
=
mSrcMediaSource
;
DDLINKCHILD
(
"
mediasource
"
mMediaSource
.
get
(
)
)
;
UpdatePreloadAction
(
)
;
if
(
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_NONE
&
&
!
mMediaSource
)
{
SuspendLoad
(
)
;
return
;
}
rv
=
LoadResource
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
;
}
}
else
{
const
char16_t
*
params
[
]
=
{
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadInvalidURI
"
params
ArrayLength
(
params
)
)
;
rv
=
MediaResult
(
rv
.
Code
(
)
"
MediaLoadInvalidURI
"
)
;
}
mMainThreadEventTarget
-
>
Dispatch
(
NewRunnableMethod
<
nsCString
>
(
"
HTMLMediaElement
:
:
NoSupportedMediaSourceError
"
this
&
HTMLMediaElement
:
:
NoSupportedMediaSourceError
rv
.
Description
(
)
)
)
;
}
else
{
mIsLoadingFromSourceChildren
=
true
;
LoadFromSourceChildren
(
)
;
}
}
void
HTMLMediaElement
:
:
NotifyLoadError
(
const
nsACString
&
aErrorDetails
)
{
if
(
!
mIsLoadingFromSourceChildren
)
{
LOG
(
LogLevel
:
:
Debug
(
"
NotifyLoadError
(
)
no
supported
media
error
"
)
)
;
NoSupportedMediaSourceError
(
aErrorDetails
)
;
}
else
if
(
mSourceLoadCandidate
)
{
DispatchAsyncSourceError
(
mSourceLoadCandidate
)
;
QueueLoadFromSourceTask
(
)
;
}
else
{
NS_WARNING
(
"
Should
know
the
source
we
were
loading
from
!
"
)
;
}
}
void
HTMLMediaElement
:
:
NotifyMediaTrackEnabled
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
if
(
!
aTrack
)
{
return
;
}
#
ifdef
DEBUG
nsString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
%
sTrack
with
id
%
s
enabled
"
this
aTrack
-
>
AsAudioTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
#
endif
MOZ_ASSERT
(
(
aTrack
-
>
AsAudioTrack
(
)
&
&
aTrack
-
>
AsAudioTrack
(
)
-
>
Enabled
(
)
)
|
|
(
aTrack
-
>
AsVideoTrack
(
)
&
&
aTrack
-
>
AsVideoTrack
(
)
-
>
Selected
(
)
)
)
;
if
(
aTrack
-
>
AsAudioTrack
(
)
)
{
SetMutedInternal
(
mMuted
&
~
MUTED_BY_AUDIO_TRACK
)
;
}
else
if
(
aTrack
-
>
AsVideoTrack
(
)
)
{
if
(
!
IsVideo
(
)
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
mDisableVideo
=
false
;
}
else
{
MOZ_ASSERT
(
false
"
Unknown
track
type
"
)
;
}
if
(
mSrcStream
)
{
if
(
aTrack
-
>
AsVideoTrack
(
)
)
{
MOZ_ASSERT
(
!
mSelectedVideoStreamTrack
)
;
MOZ_ASSERT
(
!
mMediaStreamSizeListener
)
;
mSelectedVideoStreamTrack
=
aTrack
-
>
AsVideoTrack
(
)
-
>
GetVideoStreamTrack
(
)
;
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSrcStreamIsPlaying
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
AddVideoOutput
(
container
)
;
}
HTMLVideoElement
*
self
=
static_cast
<
HTMLVideoElement
*
>
(
this
)
;
if
(
self
-
>
VideoWidth
(
)
<
=
1
&
&
self
-
>
VideoHeight
(
)
<
=
1
)
{
mMediaStreamSizeListener
=
new
StreamSizeListener
(
this
)
;
mSelectedVideoStreamTrack
-
>
AddDirectListener
(
mMediaStreamSizeListener
)
;
}
}
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
return
;
}
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
aTrack
-
>
AsVideoTrack
(
)
&
&
ms
.
mCapturingAudioOnly
)
{
continue
;
}
AddCaptureMediaTrackToOutputStream
(
aTrack
ms
)
;
}
}
}
void
HTMLMediaElement
:
:
NotifyMediaTrackDisabled
(
MediaTrack
*
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
if
(
!
aTrack
)
{
return
;
}
#
ifdef
DEBUG
nsString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
%
sTrack
with
id
%
s
disabled
"
this
aTrack
-
>
AsAudioTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
#
endif
MOZ_ASSERT
(
(
!
aTrack
-
>
AsAudioTrack
(
)
|
|
!
aTrack
-
>
AsAudioTrack
(
)
-
>
Enabled
(
)
)
&
&
(
!
aTrack
-
>
AsVideoTrack
(
)
|
|
!
aTrack
-
>
AsVideoTrack
(
)
-
>
Selected
(
)
)
)
;
if
(
aTrack
-
>
AsAudioTrack
(
)
)
{
if
(
AudioTracks
(
)
-
>
Length
(
)
>
0
)
{
bool
shouldMute
=
true
;
for
(
uint32_t
i
=
0
;
i
<
AudioTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
if
(
(
*
AudioTracks
(
)
)
[
i
]
-
>
Enabled
(
)
)
{
shouldMute
=
false
;
break
;
}
}
if
(
shouldMute
)
{
SetMutedInternal
(
mMuted
|
MUTED_BY_AUDIO_TRACK
)
;
}
}
}
else
if
(
aTrack
-
>
AsVideoTrack
(
)
)
{
if
(
mSrcStream
)
{
MOZ_ASSERT
(
mSelectedVideoStreamTrack
)
;
if
(
mSelectedVideoStreamTrack
&
&
mMediaStreamSizeListener
)
{
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
mMediaStreamSizeListener
-
>
Forget
(
)
;
mMediaStreamSizeListener
=
nullptr
;
}
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSrcStreamIsPlaying
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
RemoveVideoOutput
(
container
)
;
}
mSelectedVideoStreamTrack
=
nullptr
;
}
}
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
return
;
}
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
ms
.
mCapturingDecoder
)
{
MOZ_ASSERT
(
!
ms
.
mCapturingMediaStream
)
;
continue
;
}
MOZ_ASSERT
(
ms
.
mCapturingMediaStream
)
;
for
(
int32_t
i
=
ms
.
mTrackPorts
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
ms
.
mTrackPorts
[
i
]
.
first
(
)
=
=
aTrack
-
>
GetId
(
)
)
{
MediaStreamTrack
*
outputTrack
=
ms
.
mStream
-
>
FindOwnedDOMTrack
(
ms
.
mTrackPorts
[
i
]
.
second
(
)
-
>
GetDestination
(
)
ms
.
mTrackPorts
[
i
]
.
second
(
)
-
>
GetDestinationTrackId
(
)
)
;
MOZ_ASSERT
(
outputTrack
)
;
if
(
outputTrack
)
{
mMainThreadEventTarget
-
>
Dispatch
(
NewRunnableMethod
(
"
MediaStreamTrack
:
:
OverrideEnded
"
outputTrack
&
MediaStreamTrack
:
:
OverrideEnded
)
)
;
}
ms
.
mTrackPorts
[
i
]
.
second
(
)
-
>
Destroy
(
)
;
ms
.
mTrackPorts
.
RemoveElementAt
(
i
)
;
break
;
}
}
#
ifdef
DEBUG
for
(
auto
pair
:
ms
.
mTrackPorts
)
{
MOZ_ASSERT
(
pair
.
first
(
)
!
=
aTrack
-
>
GetId
(
)
"
The
same
MediaTrack
was
forwarded
to
the
output
stream
more
"
"
than
once
.
This
shouldn
'
t
happen
.
"
)
;
}
#
endif
}
}
void
HTMLMediaElement
:
:
NotifyMediaStreamTracksAvailable
(
DOMMediaStream
*
aStream
)
{
if
(
!
mSrcStream
|
|
mSrcStream
!
=
aStream
)
{
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
MediaStream
tracks
available
"
this
)
)
;
mSrcStreamTracksAvailable
=
true
;
bool
videoHasChanged
=
IsVideo
(
)
&
&
HasVideo
(
)
!
=
!
VideoTracks
(
)
-
>
IsEmpty
(
)
;
if
(
videoHasChanged
)
{
NotifyOwnerDocumentActivityChanged
(
)
;
}
UpdateReadyStateInternal
(
)
;
}
void
HTMLMediaElement
:
:
DealWithFailedElement
(
nsIContent
*
aSourceElement
)
{
if
(
mShuttingDown
)
{
return
;
}
DispatchAsyncSourceError
(
aSourceElement
)
;
mMainThreadEventTarget
-
>
Dispatch
(
NewRunnableMethod
(
"
HTMLMediaElement
:
:
QueueLoadFromSourceTask
"
this
&
HTMLMediaElement
:
:
QueueLoadFromSourceTask
)
)
;
}
void
HTMLMediaElement
:
:
NotifyOutputTrackStopped
(
DOMMediaStream
*
aOwningStream
TrackID
aDestinationTrackID
)
{
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
!
ms
.
mCapturingMediaStream
)
{
continue
;
}
if
(
ms
.
mStream
!
=
aOwningStream
)
{
continue
;
}
for
(
int32_t
i
=
ms
.
mTrackPorts
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
MediaInputPort
*
port
=
ms
.
mTrackPorts
[
i
]
.
second
(
)
;
if
(
port
-
>
GetDestinationTrackId
(
)
!
=
aDestinationTrackID
)
{
continue
;
}
port
-
>
Destroy
(
)
;
ms
.
mTrackPorts
.
RemoveElementAt
(
i
)
;
return
;
}
}
}
void
HTMLMediaElement
:
:
LoadFromSourceChildren
(
)
{
NS_ASSERTION
(
mDelayingLoadEvent
"
Should
delay
load
event
(
if
in
document
)
during
load
"
)
;
NS_ASSERTION
(
mIsLoadingFromSourceChildren
"
Must
remember
we
'
re
loading
from
source
children
"
)
;
AddMutationObserverUnlessExists
(
this
)
;
while
(
true
)
{
Element
*
child
=
GetNextSource
(
)
;
if
(
!
child
)
{
mLoadWaitStatus
=
WAITING_FOR_SOURCE
;
ChangeNetworkState
(
NETWORK_NO_SOURCE
)
;
ChangeDelayLoadStatus
(
false
)
;
ReportLoadError
(
"
MediaLoadExhaustedCandidates
"
)
;
return
;
}
nsAutoString
src
;
if
(
!
child
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
)
{
ReportLoadError
(
"
MediaLoadSourceMissingSrc
"
)
;
DealWithFailedElement
(
child
)
;
return
;
}
nsAutoString
type
;
if
(
child
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
)
{
DecoderDoctorDiagnostics
diagnostics
;
CanPlayStatus
canPlay
=
GetCanPlay
(
type
&
diagnostics
)
;
diagnostics
.
StoreFormatDiagnostics
(
OwnerDoc
(
)
type
canPlay
!
=
CANPLAY_NO
__func__
)
;
if
(
canPlay
=
=
CANPLAY_NO
)
{
const
char16_t
*
params
[
]
=
{
type
.
get
(
)
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadUnsupportedTypeAttribute
"
params
ArrayLength
(
params
)
)
;
DealWithFailedElement
(
child
)
;
return
;
}
}
HTMLSourceElement
*
childSrc
=
HTMLSourceElement
:
:
FromNode
(
child
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Trying
load
from
<
source
>
=
%
s
type
=
%
s
"
this
NS_ConvertUTF16toUTF8
(
src
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
type
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NewURIFromString
(
src
getter_AddRefs
(
uri
)
)
;
if
(
!
uri
)
{
const
char16_t
*
params
[
]
=
{
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadInvalidURI
"
params
ArrayLength
(
params
)
)
;
DealWithFailedElement
(
child
)
;
return
;
}
RemoveMediaElementFromURITable
(
)
;
mLoadingSrc
=
uri
;
mLoadingSrcTriggeringPrincipal
=
childSrc
-
>
GetSrcTriggeringPrincipal
(
)
;
DDLOG
(
DDLogCategory
:
:
Property
"
loading_src
"
nsCString
(
NS_ConvertUTF16toUTF8
(
src
)
)
)
;
mMediaSource
=
childSrc
-
>
GetSrcMediaSource
(
)
;
DDLINKCHILD
(
"
mediasource
"
mMediaSource
.
get
(
)
)
;
NS_ASSERTION
(
mNetworkState
=
=
NETWORK_LOADING
"
Network
state
should
be
loading
"
)
;
if
(
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_NONE
&
&
!
mMediaSource
)
{
SuspendLoad
(
)
;
return
;
}
if
(
NS_SUCCEEDED
(
LoadResource
(
)
)
)
{
return
;
}
DispatchAsyncSourceError
(
child
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Execution
should
not
reach
here
!
"
)
;
}
void
HTMLMediaElement
:
:
SuspendLoad
(
)
{
mSuspendedForPreloadNone
=
true
;
ChangeNetworkState
(
NETWORK_IDLE
)
;
ChangeDelayLoadStatus
(
false
)
;
}
void
HTMLMediaElement
:
:
ResumeLoad
(
PreloadAction
aAction
)
{
NS_ASSERTION
(
mSuspendedForPreloadNone
"
Must
be
halted
for
preload
:
none
to
resume
from
preload
:
none
"
"
suspended
load
.
"
)
;
mSuspendedForPreloadNone
=
false
;
mPreloadAction
=
aAction
;
ChangeDelayLoadStatus
(
true
)
;
ChangeNetworkState
(
NETWORK_LOADING
)
;
if
(
!
mIsLoadingFromSourceChildren
)
{
MediaResult
rv
=
LoadResource
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NoSupportedMediaSourceError
(
rv
.
Description
(
)
)
;
}
}
else
{
if
(
NS_FAILED
(
LoadResource
(
)
)
)
{
LoadFromSourceChildren
(
)
;
}
}
}
void
HTMLMediaElement
:
:
UpdatePreloadAction
(
)
{
PreloadAction
nextAction
=
PRELOAD_UNDEFINED
;
if
(
(
AutoplayPolicy
:
:
IsAllowedToPlay
(
*
this
)
=
=
nsIAutoplay
:
:
ALLOWED
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
)
|
|
!
mPaused
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_ENOUGH
;
}
else
{
const
nsAttrValue
*
val
=
mAttrsAndChildren
.
GetAttr
(
nsGkAtoms
:
:
preload
kNameSpaceID_None
)
;
uint32_t
preloadDefault
=
mMediaSource
?
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
:
Preferences
:
:
GetInt
(
"
media
.
preload
.
default
"
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
)
;
uint32_t
preloadAuto
=
Preferences
:
:
GetInt
(
"
media
.
preload
.
auto
"
HTMLMediaElement
:
:
PRELOAD_ENOUGH
)
;
if
(
!
val
)
{
nextAction
=
static_cast
<
PreloadAction
>
(
preloadDefault
)
;
}
else
if
(
val
-
>
Type
(
)
=
=
nsAttrValue
:
:
eEnum
)
{
PreloadAttrValue
attr
=
static_cast
<
PreloadAttrValue
>
(
val
-
>
GetEnumValue
(
)
)
;
if
(
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_EMPTY
|
|
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_AUTO
)
{
nextAction
=
static_cast
<
PreloadAction
>
(
preloadAuto
)
;
}
else
if
(
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_METADATA
;
}
else
if
(
attr
=
=
HTMLMediaElement
:
:
PRELOAD_ATTR_NONE
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_NONE
;
}
}
else
{
nextAction
=
static_cast
<
PreloadAction
>
(
preloadDefault
)
;
}
}
if
(
nextAction
=
=
HTMLMediaElement
:
:
PRELOAD_NONE
&
&
mIsDoingExplicitLoad
)
{
nextAction
=
HTMLMediaElement
:
:
PRELOAD_METADATA
;
}
mPreloadAction
=
nextAction
;
if
(
nextAction
=
=
HTMLMediaElement
:
:
PRELOAD_ENOUGH
)
{
if
(
mSuspendedForPreloadNone
)
{
ResumeLoad
(
PRELOAD_ENOUGH
)
;
}
else
{
StopSuspendingAfterFirstFrame
(
)
;
}
}
else
if
(
nextAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
)
{
mAllowSuspendAfterFirstFrame
=
true
;
if
(
mSuspendedForPreloadNone
)
{
ResumeLoad
(
PRELOAD_METADATA
)
;
}
}
}
MediaResult
HTMLMediaElement
:
:
LoadResource
(
)
{
AbstractThread
:
:
AutoEnter
context
(
AbstractMainThread
(
)
)
;
NS_ASSERTION
(
mDelayingLoadEvent
"
Should
delay
load
event
(
if
in
document
)
during
load
"
)
;
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Cancel
(
)
;
mChannelLoader
=
nullptr
;
}
mCORSMode
=
AttrValueToCORSMode
(
GetParsedAttr
(
nsGkAtoms
:
:
crossorigin
)
)
;
HTMLMediaElement
*
other
=
LookupMediaElementURITable
(
mLoadingSrc
)
;
if
(
other
&
&
other
-
>
mDecoder
)
{
nsresult
rv
=
InitializeDecoderAsClone
(
static_cast
<
ChannelMediaDecoder
*
>
(
other
-
>
mDecoder
.
get
(
)
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
return
rv
;
}
if
(
mMediaSource
)
{
MediaDecoderInit
decoderInit
(
this
mMuted
?
0
.
0
:
mVolume
mPreservesPitch
mPlaybackRate
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
mHasSuspendTaint
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loop
)
MediaContainerType
(
MEDIAMIMETYPE
(
"
application
/
x
.
mediasource
"
)
)
)
;
RefPtr
<
MediaSourceDecoder
>
decoder
=
new
MediaSourceDecoder
(
decoderInit
)
;
if
(
!
mMediaSource
-
>
Attach
(
decoder
)
)
{
decoder
-
>
Shutdown
(
)
;
return
MediaResult
(
NS_ERROR_FAILURE
"
Failed
to
attach
MediaSource
"
)
;
}
ChangeDelayLoadStatus
(
false
)
;
nsresult
rv
=
decoder
-
>
Load
(
mMediaSource
-
>
GetPrincipal
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
decoder
-
>
Shutdown
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Failed
to
load
for
decoder
%
p
"
this
decoder
.
get
(
)
)
)
;
return
MediaResult
(
rv
"
Fail
to
load
decoder
"
)
;
}
rv
=
FinishDecoderSetup
(
decoder
)
;
return
MediaResult
(
rv
"
Failed
to
set
up
decoder
"
)
;
}
AssertReadyStateIsNothing
(
)
;
RefPtr
<
ChannelLoader
>
loader
=
new
ChannelLoader
;
nsresult
rv
=
loader
-
>
Load
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mChannelLoader
=
loader
.
forget
(
)
;
}
return
MediaResult
(
rv
"
Failed
to
load
channel
"
)
;
}
nsresult
HTMLMediaElement
:
:
LoadWithChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
{
NS_ENSURE_ARG_POINTER
(
aChannel
)
;
NS_ENSURE_ARG_POINTER
(
aListener
)
;
*
aListener
=
nullptr
;
if
(
mIsRunningLoadMethod
)
return
NS_OK
;
mIsRunningLoadMethod
=
true
;
AbortExistingLoads
(
)
;
mIsRunningLoadMethod
=
false
;
mLoadingSrcTriggeringPrincipal
=
nullptr
;
nsresult
rv
=
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
mLoadingSrc
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ChangeDelayLoadStatus
(
true
)
;
rv
=
InitializeDecoderForChannel
(
aChannel
aListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
ChangeDelayLoadStatus
(
false
)
;
return
rv
;
}
SetPlaybackRate
(
mDefaultPlaybackRate
IgnoreErrors
(
)
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadstart
"
)
)
;
return
NS_OK
;
}
bool
HTMLMediaElement
:
:
Seeking
(
)
const
{
return
mDecoder
&
&
mDecoder
-
>
IsSeeking
(
)
;
}
double
HTMLMediaElement
:
:
CurrentTime
(
)
const
{
if
(
MediaStream
*
stream
=
GetSrcMediaStream
(
)
)
{
if
(
mSrcStreamPausedCurrentTime
>
=
0
)
{
return
mSrcStreamPausedCurrentTime
;
}
return
stream
-
>
StreamTimeToSeconds
(
stream
-
>
GetCurrentTime
(
)
)
;
}
if
(
mDefaultPlaybackStartPosition
=
=
0
.
0
&
&
mDecoder
)
{
return
mDecoder
-
>
GetCurrentTime
(
)
;
}
return
mDefaultPlaybackStartPosition
;
}
void
HTMLMediaElement
:
:
FastSeek
(
double
aTime
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
FastSeek
(
%
f
)
called
by
JS
"
this
aTime
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Reporting
telemetry
VIDEO_FASTSEEK_USED
"
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_FASTSEEK_USED
1
)
;
RefPtr
<
Promise
>
tobeDropped
=
Seek
(
aTime
SeekTarget
:
:
PrevSyncPoint
aRv
)
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
SeekToNextFrame
(
ErrorResult
&
aRv
)
{
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
win
)
{
if
(
JSObject
*
obj
=
win
-
>
AsGlobal
(
)
-
>
GetGlobalJSObject
(
)
)
{
js
:
:
NotifyAnimationActivity
(
obj
)
;
}
}
return
Seek
(
CurrentTime
(
)
SeekTarget
:
:
NextFrame
aRv
)
;
}
void
HTMLMediaElement
:
:
SetCurrentTime
(
double
aCurrentTime
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetCurrentTime
(
%
f
)
called
by
JS
"
this
aCurrentTime
)
)
;
RefPtr
<
Promise
>
tobeDropped
=
Seek
(
aCurrentTime
SeekTarget
:
:
Accurate
aRv
)
;
}
static
bool
IsInRanges
(
TimeRanges
&
aRanges
double
aValue
uint32_t
&
aIntervalIndex
)
{
uint32_t
length
=
aRanges
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
double
start
=
aRanges
.
Start
(
i
)
;
if
(
start
>
aValue
)
{
aIntervalIndex
=
i
;
return
false
;
}
double
end
=
aRanges
.
End
(
i
)
;
if
(
aValue
<
=
end
)
{
aIntervalIndex
=
i
;
return
true
;
}
}
aIntervalIndex
=
length
;
return
false
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
Seek
(
double
aTime
SeekTarget
:
:
Type
aSeekType
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
mozilla
:
:
IsNaN
(
aTime
)
)
;
RefPtr
<
Promise
>
promise
=
CreateDOMPromise
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
mIsBlessed
=
true
;
}
StopSuspendingAfterFirstFrame
(
)
;
if
(
mSrcStream
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
mPlayed
&
&
mCurrentPlayRangeStart
!
=
-
1
.
0
)
{
double
rangeEndTime
=
CurrentTime
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Adding
\
'
played
\
'
a
range
:
[
%
f
%
f
]
"
this
mCurrentPlayRangeStart
rangeEndTime
)
)
;
if
(
mCurrentPlayRangeStart
!
=
rangeEndTime
)
{
mPlayed
-
>
Add
(
mCurrentPlayRangeStart
rangeEndTime
)
;
}
mCurrentPlayRangeStart
=
-
1
.
0
;
}
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
mDefaultPlaybackStartPosition
=
aTime
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
!
mDecoder
)
{
NS_ASSERTION
(
mDecoder
"
SetCurrentTime
failed
:
no
decoder
"
)
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
media
:
:
TimeIntervals
seekableIntervals
=
mDecoder
-
>
GetSeekable
(
)
;
if
(
seekableIntervals
.
IsInvalid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
TimeRanges
>
seekable
=
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
seekableIntervals
)
;
uint32_t
length
=
seekable
-
>
Length
(
)
;
if
(
length
=
=
0
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
uint32_t
range
=
0
;
bool
isInRange
=
IsInRanges
(
*
seekable
aTime
range
)
;
if
(
!
isInRange
)
{
if
(
range
=
=
0
)
{
aTime
=
seekable
-
>
Start
(
0
)
;
}
else
if
(
range
=
=
length
)
{
aTime
=
seekable
-
>
End
(
length
-
1
)
;
}
else
{
double
leftBound
=
seekable
-
>
End
(
range
-
1
)
;
double
rightBound
=
seekable
-
>
Start
(
range
)
;
double
distanceLeft
=
Abs
(
leftBound
-
aTime
)
;
double
distanceRight
=
Abs
(
rightBound
-
aTime
)
;
if
(
distanceLeft
=
=
distanceRight
)
{
double
currentTime
=
CurrentTime
(
)
;
distanceLeft
=
Abs
(
leftBound
-
currentTime
)
;
distanceRight
=
Abs
(
rightBound
-
currentTime
)
;
}
aTime
=
(
distanceLeft
<
distanceRight
)
?
leftBound
:
rightBound
;
}
}
mPlayingBeforeSeek
=
IsPotentiallyPlaying
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetCurrentTime
(
%
f
)
starting
seek
"
this
aTime
)
)
;
mDecoder
-
>
Seek
(
aTime
aSeekType
)
;
AddRemoveSelfReference
(
)
;
mSeekDOMPromise
=
promise
;
return
promise
.
forget
(
)
;
}
double
HTMLMediaElement
:
:
Duration
(
)
const
{
if
(
mSrcStream
)
{
return
std
:
:
numeric_limits
<
double
>
:
:
infinity
(
)
;
}
if
(
mDecoder
)
{
return
mDecoder
-
>
GetDuration
(
)
;
}
return
std
:
:
numeric_limits
<
double
>
:
:
quiet_NaN
(
)
;
}
already_AddRefed
<
TimeRanges
>
HTMLMediaElement
:
:
Seekable
(
)
const
{
media
:
:
TimeIntervals
seekable
=
mDecoder
?
mDecoder
-
>
GetSeekable
(
)
:
media
:
:
TimeIntervals
(
)
;
RefPtr
<
TimeRanges
>
ranges
=
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
seekable
)
;
return
ranges
.
forget
(
)
;
}
already_AddRefed
<
TimeRanges
>
HTMLMediaElement
:
:
Played
(
)
{
RefPtr
<
TimeRanges
>
ranges
=
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
)
;
uint32_t
timeRangeCount
=
0
;
if
(
mPlayed
)
{
timeRangeCount
=
mPlayed
-
>
Length
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
timeRangeCount
;
i
+
+
)
{
double
begin
=
mPlayed
-
>
Start
(
i
)
;
double
end
=
mPlayed
-
>
End
(
i
)
;
ranges
-
>
Add
(
begin
end
)
;
}
if
(
mCurrentPlayRangeStart
!
=
-
1
.
0
)
{
double
now
=
CurrentTime
(
)
;
if
(
mCurrentPlayRangeStart
!
=
now
)
{
ranges
-
>
Add
(
mCurrentPlayRangeStart
now
)
;
}
}
ranges
-
>
Normalize
(
)
;
return
ranges
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
Pause
(
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Pause
(
)
called
by
JS
"
this
)
)
;
if
(
mNetworkState
=
=
NETWORK_EMPTY
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Loading
due
to
Pause
(
)
"
)
)
;
DoLoad
(
)
;
}
else
if
(
mDecoder
)
{
mDecoder
-
>
Pause
(
)
;
}
bool
oldPaused
=
mPaused
;
mPaused
=
true
;
mAutoplaying
=
false
;
AddRemoveSelfReference
(
)
;
UpdateSrcMediaStreamPlaying
(
)
;
if
(
mAudioChannelWrapper
)
{
mAudioChannelWrapper
-
>
NotifyPlayStateChanged
(
)
;
}
if
(
!
oldPaused
)
{
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
pause
"
)
)
;
AsyncRejectPendingPlayPromises
(
NS_ERROR_DOM_MEDIA_ABORT_ERR
)
;
}
}
void
HTMLMediaElement
:
:
SetVolume
(
double
aVolume
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetVolume
(
%
f
)
called
by
JS
"
this
aVolume
)
)
;
if
(
aVolume
<
0
.
0
|
|
aVolume
>
1
.
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
if
(
aVolume
=
=
mVolume
)
return
;
mVolume
=
aVolume
;
SetVolumeInternal
(
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
volumechange
"
)
)
;
PauseIfShouldNotBePlaying
(
)
;
}
void
HTMLMediaElement
:
:
MozGetMetadata
(
JSContext
*
cx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
ErrorResult
&
aRv
)
{
if
(
mReadyState
<
HAVE_METADATA
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
tags
(
cx
JS_NewPlainObject
(
cx
)
)
;
if
(
!
tags
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
mTags
)
{
for
(
auto
iter
=
mTags
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsString
wideValue
;
CopyUTF8toUTF16
(
iter
.
UserData
(
)
wideValue
)
;
JS
:
:
Rooted
<
JSString
*
>
string
(
cx
JS_NewUCStringCopyZ
(
cx
wideValue
.
Data
(
)
)
)
;
if
(
!
string
|
|
!
JS_DefineProperty
(
cx
tags
iter
.
Key
(
)
.
Data
(
)
string
JSPROP_ENUMERATE
)
)
{
NS_WARNING
(
"
couldn
'
t
create
metadata
object
!
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
}
aRetval
.
set
(
tags
)
;
}
void
HTMLMediaElement
:
:
SetMutedInternal
(
uint32_t
aMuted
)
{
uint32_t
oldMuted
=
mMuted
;
mMuted
=
aMuted
;
if
(
!
!
aMuted
=
=
!
!
oldMuted
)
{
return
;
}
SetVolumeInternal
(
)
;
}
void
HTMLMediaElement
:
:
PauseIfShouldNotBePlaying
(
)
{
if
(
GetPaused
(
)
)
{
return
;
}
if
(
AutoplayPolicy
:
:
IsAllowedToPlay
(
*
this
)
!
=
nsIAutoplay
:
:
ALLOWED
)
{
ErrorResult
rv
;
Pause
(
rv
)
;
OwnerDoc
(
)
-
>
SetDocTreeHadPlayRevoked
(
)
;
}
}
void
HTMLMediaElement
:
:
SetVolumeInternal
(
)
{
float
effectiveVolume
=
ComputedVolume
(
)
;
if
(
mDecoder
)
{
mDecoder
-
>
SetVolume
(
effectiveVolume
)
;
}
else
if
(
MediaStream
*
stream
=
GetSrcMediaStream
(
)
)
{
if
(
mSrcStreamIsPlaying
)
{
stream
-
>
SetAudioOutputVolume
(
this
effectiveVolume
)
;
}
}
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
eVolumeChanged
)
;
}
void
HTMLMediaElement
:
:
SetMuted
(
bool
aMuted
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetMuted
(
%
d
)
called
by
JS
"
this
aMuted
)
)
;
if
(
aMuted
=
=
Muted
(
)
)
{
return
;
}
if
(
aMuted
)
{
SetMutedInternal
(
mMuted
|
MUTED_BY_CONTENT
)
;
}
else
{
SetMutedInternal
(
mMuted
&
~
MUTED_BY_CONTENT
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
volumechange
"
)
)
;
PauseIfShouldNotBePlaying
(
)
;
}
class
HTMLMediaElement
:
:
StreamCaptureTrackSource
:
public
MediaStreamTrackSource
public
MediaStreamTrackSource
:
:
Sink
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
StreamCaptureTrackSource
MediaStreamTrackSource
)
StreamCaptureTrackSource
(
HTMLMediaElement
*
aElement
MediaStreamTrackSource
*
aCapturedTrackSource
DOMMediaStream
*
aOwningStream
TrackID
aDestinationTrackID
)
:
MediaStreamTrackSource
(
aCapturedTrackSource
-
>
GetPrincipal
(
)
nsString
(
)
)
mElement
(
aElement
)
mCapturedTrackSource
(
aCapturedTrackSource
)
mOwningStream
(
aOwningStream
)
mDestinationTrackID
(
aDestinationTrackID
)
{
MOZ_ASSERT
(
mElement
)
;
MOZ_ASSERT
(
mCapturedTrackSource
)
;
MOZ_ASSERT
(
mOwningStream
)
;
MOZ_ASSERT
(
IsTrackIDExplicit
(
mDestinationTrackID
)
)
;
mCapturedTrackSource
-
>
RegisterSink
(
this
)
;
}
void
Destroy
(
)
override
{
if
(
mCapturedTrackSource
)
{
mCapturedTrackSource
-
>
UnregisterSink
(
this
)
;
mCapturedTrackSource
=
nullptr
;
}
}
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
MediaSourceEnum
:
:
Other
;
}
CORSMode
GetCORSMode
(
)
const
override
{
if
(
!
mCapturedTrackSource
)
{
return
CORS_NONE
;
}
return
mCapturedTrackSource
-
>
GetCORSMode
(
)
;
}
void
Stop
(
)
override
{
if
(
mElement
&
&
mElement
-
>
mSrcStream
)
{
mElement
-
>
NotifyOutputTrackStopped
(
mOwningStream
mDestinationTrackID
)
;
}
mElement
=
nullptr
;
mOwningStream
=
nullptr
;
Destroy
(
)
;
}
bool
KeepsSourceAlive
(
)
const
override
{
return
false
;
}
bool
Enabled
(
)
const
override
{
return
false
;
}
void
Disable
(
)
override
{
}
void
Enable
(
)
override
{
}
void
PrincipalChanged
(
)
override
{
if
(
!
mCapturedTrackSource
)
{
return
;
}
mPrincipal
=
mCapturedTrackSource
-
>
GetPrincipal
(
)
;
MediaStreamTrackSource
:
:
PrincipalChanged
(
)
;
}
void
MutedChanged
(
bool
aNewState
)
override
{
if
(
!
mCapturedTrackSource
)
{
return
;
}
MediaStreamTrackSource
:
:
MutedChanged
(
aNewState
)
;
}
private
:
virtual
~
StreamCaptureTrackSource
(
)
{
}
RefPtr
<
HTMLMediaElement
>
mElement
;
RefPtr
<
MediaStreamTrackSource
>
mCapturedTrackSource
;
RefPtr
<
DOMMediaStream
>
mOwningStream
;
TrackID
mDestinationTrackID
;
}
;
NS_IMPL_ADDREF_INHERITED
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
MediaStreamTrackSource
)
NS_IMPL_RELEASE_INHERITED
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
MediaStreamTrackSource
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
)
NS_INTERFACE_MAP_END_INHERITING
(
MediaStreamTrackSource
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
StreamCaptureTrackSource
MediaStreamTrackSource
mElement
mCapturedTrackSource
mOwningStream
)
class
HTMLMediaElement
:
:
DecoderCaptureTrackSource
:
public
MediaStreamTrackSource
public
DecoderPrincipalChangeObserver
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
DecoderCaptureTrackSource
MediaStreamTrackSource
)
explicit
DecoderCaptureTrackSource
(
HTMLMediaElement
*
aElement
)
:
MediaStreamTrackSource
(
nsCOMPtr
<
nsIPrincipal
>
(
aElement
-
>
GetCurrentPrincipal
(
)
)
.
get
(
)
nsString
(
)
)
mElement
(
aElement
)
{
MOZ_ASSERT
(
mElement
)
;
mElement
-
>
AddDecoderPrincipalChangeObserver
(
this
)
;
}
void
Destroy
(
)
override
{
if
(
mElement
)
{
DebugOnly
<
bool
>
res
=
mElement
-
>
RemoveDecoderPrincipalChangeObserver
(
this
)
;
NS_ASSERTION
(
res
"
Removing
decoder
principal
changed
observer
failed
.
"
"
Had
it
already
been
removed
?
"
)
;
mElement
=
nullptr
;
}
}
MediaSourceEnum
GetMediaSource
(
)
const
override
{
return
MediaSourceEnum
:
:
Other
;
}
CORSMode
GetCORSMode
(
)
const
override
{
if
(
!
mElement
)
{
MOZ_ASSERT
(
false
"
Should
always
have
an
element
if
in
use
"
)
;
return
CORS_NONE
;
}
return
mElement
-
>
GetCORSMode
(
)
;
}
void
Stop
(
)
override
{
}
void
Disable
(
)
override
{
}
void
Enable
(
)
override
{
}
void
NotifyDecoderPrincipalChanged
(
)
override
{
nsCOMPtr
<
nsIPrincipal
>
newPrincipal
=
mElement
-
>
GetCurrentPrincipal
(
)
;
if
(
nsContentUtils
:
:
CombineResourcePrincipals
(
&
mPrincipal
newPrincipal
)
)
{
PrincipalChanged
(
)
;
}
}
protected
:
virtual
~
DecoderCaptureTrackSource
(
)
{
}
RefPtr
<
HTMLMediaElement
>
mElement
;
}
;
NS_IMPL_ADDREF_INHERITED
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
MediaStreamTrackSource
)
NS_IMPL_RELEASE_INHERITED
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
MediaStreamTrackSource
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
)
NS_INTERFACE_MAP_END_INHERITING
(
MediaStreamTrackSource
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
DecoderCaptureTrackSource
MediaStreamTrackSource
mElement
)
class
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
:
public
MediaStreamTrackSourceGetter
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
)
explicit
CaptureStreamTrackSourceGetter
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
{
}
already_AddRefed
<
dom
:
:
MediaStreamTrackSource
>
GetMediaStreamTrackSource
(
TrackID
aInputTrackID
)
override
{
if
(
mElement
&
&
mElement
-
>
mSrcStream
)
{
NS_ERROR
(
"
Captured
media
element
playing
a
stream
adds
tracks
explicitly
"
"
on
main
thread
.
"
)
;
return
nullptr
;
}
return
do_AddRef
(
new
DecoderCaptureTrackSource
(
mElement
)
)
;
}
protected
:
virtual
~
CaptureStreamTrackSourceGetter
(
)
{
}
RefPtr
<
HTMLMediaElement
>
mElement
;
}
;
NS_IMPL_ADDREF_INHERITED
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
)
NS_IMPL_RELEASE_INHERITED
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
)
NS_INTERFACE_MAP_END_INHERITING
(
MediaStreamTrackSourceGetter
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLMediaElement
:
:
CaptureStreamTrackSourceGetter
MediaStreamTrackSourceGetter
mElement
)
void
HTMLMediaElement
:
:
SetCapturedOutputStreamsEnabled
(
bool
aEnabled
)
{
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
ms
.
mCapturingDecoder
)
{
MOZ_ASSERT
(
!
ms
.
mCapturingMediaStream
)
;
continue
;
}
for
(
auto
pair
:
ms
.
mTrackPorts
)
{
MediaStream
*
outputSource
=
ms
.
mStream
-
>
GetInputStream
(
)
;
if
(
!
outputSource
)
{
NS_ERROR
(
"
No
output
source
stream
"
)
;
return
;
}
TrackID
id
=
pair
.
second
(
)
-
>
GetDestinationTrackId
(
)
;
outputSource
-
>
SetTrackEnabled
(
id
aEnabled
?
DisabledTrackMode
:
:
ENABLED
:
DisabledTrackMode
:
:
SILENCE_FREEZE
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
s
track
%
d
for
captured
MediaStream
%
p
"
aEnabled
?
"
Enabled
"
:
"
Disabled
"
id
ms
.
mStream
.
get
(
)
)
)
;
}
}
}
void
HTMLMediaElement
:
:
AddCaptureMediaTrackToOutputStream
(
MediaTrack
*
aTrack
OutputMediaStream
&
aOutputStream
bool
aAsyncAddtrack
)
{
if
(
aOutputStream
.
mCapturingDecoder
)
{
MOZ_ASSERT
(
!
aOutputStream
.
mCapturingMediaStream
)
;
return
;
}
aOutputStream
.
mCapturingMediaStream
=
true
;
if
(
aOutputStream
.
mStream
=
=
mSrcStream
)
{
return
;
}
MediaStream
*
outputSource
=
aOutputStream
.
mStream
-
>
GetInputStream
(
)
;
if
(
!
outputSource
)
{
NS_ERROR
(
"
No
output
source
stream
"
)
;
return
;
}
ProcessedMediaStream
*
processedOutputSource
=
outputSource
-
>
AsProcessedStream
(
)
;
if
(
!
processedOutputSource
)
{
NS_ERROR
(
"
Input
stream
not
a
ProcessedMediaStream
"
)
;
return
;
}
if
(
!
aTrack
)
{
MOZ_ASSERT
(
false
"
Bad
MediaTrack
"
)
;
return
;
}
MediaStreamTrack
*
inputTrack
=
mSrcStream
-
>
GetTrackById
(
aTrack
-
>
GetId
(
)
)
;
MOZ_ASSERT
(
inputTrack
)
;
if
(
!
inputTrack
)
{
NS_ERROR
(
"
Input
track
not
found
in
source
stream
"
)
;
return
;
}
#
if
DEBUG
for
(
auto
pair
:
aOutputStream
.
mTrackPorts
)
{
MOZ_ASSERT
(
pair
.
first
(
)
!
=
aTrack
-
>
GetId
(
)
"
Captured
track
already
captured
to
output
stream
"
)
;
}
#
endif
TrackID
destinationTrackID
=
aOutputStream
.
mNextAvailableTrackID
+
+
;
RefPtr
<
MediaStreamTrackSource
>
source
=
new
StreamCaptureTrackSource
(
this
&
inputTrack
-
>
GetSource
(
)
aOutputStream
.
mStream
destinationTrackID
)
;
MediaSegment
:
:
Type
type
=
inputTrack
-
>
AsAudioStreamTrack
(
)
?
MediaSegment
:
:
AUDIO
:
MediaSegment
:
:
VIDEO
;
RefPtr
<
MediaStreamTrack
>
track
=
aOutputStream
.
mStream
-
>
CreateDOMTrack
(
destinationTrackID
type
source
)
;
if
(
aAsyncAddtrack
)
{
mMainThreadEventTarget
-
>
Dispatch
(
NewRunnableMethod
<
StoreRefPtrPassByPtr
<
MediaStreamTrack
>
>
(
"
DOMMediaStream
:
:
AddTrackInternal
"
aOutputStream
.
mStream
&
DOMMediaStream
:
:
AddTrackInternal
track
)
)
;
}
else
{
aOutputStream
.
mStream
-
>
AddTrackInternal
(
track
)
;
}
processedOutputSource
-
>
SetTrackEnabled
(
destinationTrackID
DisabledTrackMode
:
:
SILENCE_FREEZE
)
;
RefPtr
<
MediaInputPort
>
port
=
inputTrack
-
>
ForwardTrackContentsTo
(
processedOutputSource
destinationTrackID
)
;
Pair
<
nsString
RefPtr
<
MediaInputPort
>
>
p
(
aTrack
-
>
GetId
(
)
port
)
;
aOutputStream
.
mTrackPorts
.
AppendElement
(
std
:
:
move
(
p
)
)
;
if
(
mSrcStreamIsPlaying
)
{
processedOutputSource
-
>
SetTrackEnabled
(
destinationTrackID
DisabledTrackMode
:
:
ENABLED
)
;
}
LOG
(
LogLevel
:
:
Debug
(
"
Created
%
s
track
%
p
with
id
%
d
from
track
%
p
through
MediaInputPort
%
p
"
inputTrack
-
>
AsAudioStreamTrack
(
)
?
"
audio
"
:
"
video
"
track
.
get
(
)
destinationTrackID
inputTrack
port
.
get
(
)
)
)
;
}
bool
HTMLMediaElement
:
:
CanBeCaptured
(
StreamCaptureType
aCaptureType
)
{
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
if
(
aCaptureType
=
=
StreamCaptureType
:
:
CAPTURE_ALL_TRACKS
&
&
ContainsRestrictedContent
(
)
)
{
return
false
;
}
return
true
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
CaptureStreamInternal
(
StreamCaptureBehavior
aFinishBehavior
StreamCaptureType
aStreamCaptureType
MediaStreamGraph
*
aGraph
)
{
MOZ_RELEASE_ASSERT
(
aGraph
)
;
MOZ_ASSERT
(
CanBeCaptured
(
aStreamCaptureType
)
)
;
MarkAsContentSource
(
CallerAPI
:
:
CAPTURE_STREAM
)
;
MarkAsTainted
(
)
;
if
(
!
mOutputStreams
.
IsEmpty
(
)
&
&
aGraph
!
=
mOutputStreams
[
0
]
.
mStream
-
>
GetInputStream
(
)
-
>
Graph
(
)
)
{
return
nullptr
;
}
OutputMediaStream
*
out
=
mOutputStreams
.
AppendElement
(
)
;
MediaStreamTrackSourceGetter
*
getter
=
new
CaptureStreamTrackSourceGetter
(
this
)
;
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
out
-
>
mStream
=
DOMMediaStream
:
:
CreateTrackUnionStreamAsInput
(
window
aGraph
getter
)
;
out
-
>
mStream
-
>
SetInactiveOnFinish
(
)
;
out
-
>
mFinishWhenEnded
=
aFinishBehavior
=
=
StreamCaptureBehavior
:
:
FINISH_WHEN_ENDED
;
out
-
>
mCapturingAudioOnly
=
aStreamCaptureType
=
=
StreamCaptureType
:
:
CAPTURE_AUDIO
;
if
(
aStreamCaptureType
=
=
StreamCaptureType
:
:
CAPTURE_AUDIO
)
{
if
(
mSrcStream
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
Media
"
)
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
MediaElementAudioCaptureOfMediaStreamError
"
)
;
return
nullptr
;
}
mAudioCaptured
=
true
;
}
if
(
mDecoder
)
{
out
-
>
mCapturingDecoder
=
true
;
mDecoder
-
>
AddOutputStream
(
out
-
>
mStream
-
>
GetInputStream
(
)
-
>
AsProcessedStream
(
)
out
-
>
mNextAvailableTrackID
aFinishBehavior
=
=
StreamCaptureBehavior
:
:
FINISH_WHEN_ENDED
)
;
}
else
if
(
mSrcStream
)
{
out
-
>
mCapturingMediaStream
=
true
;
}
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
RefPtr
<
DOMMediaStream
>
result
=
out
-
>
mStream
;
return
result
.
forget
(
)
;
}
if
(
mDecoder
)
{
if
(
HasAudio
(
)
)
{
TrackID
audioTrackId
=
out
-
>
mNextAvailableTrackID
+
+
;
RefPtr
<
MediaStreamTrackSource
>
trackSource
=
getter
-
>
GetMediaStreamTrackSource
(
audioTrackId
)
;
RefPtr
<
MediaStreamTrack
>
track
=
out
-
>
mStream
-
>
CreateDOMTrack
(
audioTrackId
MediaSegment
:
:
AUDIO
trackSource
)
;
out
-
>
mPreCreatedTracks
.
AppendElement
(
track
)
;
out
-
>
mStream
-
>
AddTrackInternal
(
track
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Created
audio
track
%
d
for
captured
decoder
"
audioTrackId
)
)
;
}
if
(
IsVideo
(
)
&
&
HasVideo
(
)
&
&
!
out
-
>
mCapturingAudioOnly
)
{
TrackID
videoTrackId
=
out
-
>
mNextAvailableTrackID
+
+
;
RefPtr
<
MediaStreamTrackSource
>
trackSource
=
getter
-
>
GetMediaStreamTrackSource
(
videoTrackId
)
;
RefPtr
<
MediaStreamTrack
>
track
=
out
-
>
mStream
-
>
CreateDOMTrack
(
videoTrackId
MediaSegment
:
:
VIDEO
trackSource
)
;
out
-
>
mPreCreatedTracks
.
AppendElement
(
track
)
;
out
-
>
mStream
-
>
AddTrackInternal
(
track
)
;
LOG
(
LogLevel
:
:
Debug
(
"
Created
video
track
%
d
for
captured
decoder
"
videoTrackId
)
)
;
}
}
if
(
mSrcStream
)
{
for
(
size_t
i
=
0
;
i
<
AudioTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
AudioTrack
*
t
=
(
*
AudioTracks
(
)
)
[
i
]
;
if
(
t
-
>
Enabled
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
*
out
false
)
;
}
}
if
(
IsVideo
(
)
&
&
!
out
-
>
mCapturingAudioOnly
)
{
for
(
size_t
i
=
0
;
i
<
VideoTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
VideoTrack
*
t
=
(
*
VideoTracks
(
)
)
[
i
]
;
if
(
t
-
>
Selected
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
*
out
false
)
;
}
}
}
}
RefPtr
<
DOMMediaStream
>
result
=
out
-
>
mStream
;
return
result
.
forget
(
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
CaptureAudio
(
ErrorResult
&
aRv
MediaStreamGraph
*
aGraph
)
{
MOZ_RELEASE_ASSERT
(
aGraph
)
;
if
(
!
CanBeCaptured
(
StreamCaptureType
:
:
CAPTURE_AUDIO
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
StreamCaptureBehavior
:
:
CONTINUE_WHEN_ENDED
StreamCaptureType
:
:
CAPTURE_AUDIO
aGraph
)
;
if
(
!
stream
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
MozCaptureStream
(
ErrorResult
&
aRv
)
{
MediaStreamGraph
:
:
GraphDriverType
graphDriverType
=
HasAudio
(
)
?
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
:
MediaStreamGraph
:
:
SYSTEM_THREAD_DRIVER
;
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
CanBeCaptured
(
StreamCaptureType
:
:
CAPTURE_ALL_TRACKS
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
MediaStreamGraph
*
graph
=
MediaStreamGraph
:
:
GetInstance
(
graphDriverType
window
MediaStreamGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
)
;
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
StreamCaptureBehavior
:
:
CONTINUE_WHEN_ENDED
StreamCaptureType
:
:
CAPTURE_ALL_TRACKS
graph
)
;
if
(
!
stream
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
already_AddRefed
<
DOMMediaStream
>
HTMLMediaElement
:
:
MozCaptureStreamUntilEnded
(
ErrorResult
&
aRv
)
{
MediaStreamGraph
:
:
GraphDriverType
graphDriverType
=
HasAudio
(
)
?
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
:
MediaStreamGraph
:
:
SYSTEM_THREAD_DRIVER
;
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
CanBeCaptured
(
StreamCaptureType
:
:
CAPTURE_ALL_TRACKS
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
MediaStreamGraph
*
graph
=
MediaStreamGraph
:
:
GetInstance
(
graphDriverType
window
MediaStreamGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
)
;
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
StreamCaptureBehavior
:
:
FINISH_WHEN_ENDED
StreamCaptureType
:
:
CAPTURE_ALL_TRACKS
graph
)
;
if
(
!
stream
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
stream
.
forget
(
)
;
}
class
MediaElementSetForURI
:
public
nsURIHashKey
{
public
:
explicit
MediaElementSetForURI
(
const
nsIURI
*
aKey
)
:
nsURIHashKey
(
aKey
)
{
}
MediaElementSetForURI
(
const
MediaElementSetForURI
&
toCopy
)
:
nsURIHashKey
(
toCopy
)
mElements
(
toCopy
.
mElements
)
{
}
nsTArray
<
HTMLMediaElement
*
>
mElements
;
}
;
typedef
nsTHashtable
<
MediaElementSetForURI
>
MediaElementURITable
;
static
MediaElementURITable
*
gElementTable
;
#
ifdef
DEBUG
static
bool
URISafeEquals
(
nsIURI
*
a1
nsIURI
*
a2
)
{
if
(
!
a1
|
|
!
a2
)
{
return
false
;
}
bool
equal
=
false
;
nsresult
rv
=
a1
-
>
Equals
(
a2
&
equal
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
equal
;
}
static
unsigned
MediaElementTableCount
(
HTMLMediaElement
*
aElement
nsIURI
*
aURI
)
{
if
(
!
gElementTable
|
|
!
aElement
)
{
return
0
;
}
uint32_t
uriCount
=
0
;
uint32_t
otherCount
=
0
;
for
(
auto
it
=
gElementTable
-
>
ConstIter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
MediaElementSetForURI
*
entry
=
it
.
Get
(
)
;
uint32_t
count
=
0
;
for
(
const
auto
&
elem
:
entry
-
>
mElements
)
{
if
(
elem
=
=
aElement
)
{
count
+
+
;
}
}
if
(
URISafeEquals
(
aURI
entry
-
>
GetKey
(
)
)
)
{
uriCount
=
count
;
}
else
{
otherCount
+
=
count
;
}
}
NS_ASSERTION
(
otherCount
=
=
0
"
Should
not
have
entries
for
unknown
URIs
"
)
;
return
uriCount
;
}
#
endif
void
HTMLMediaElement
:
:
AddMediaElementToURITable
(
)
{
NS_ASSERTION
(
mDecoder
"
Call
this
only
with
decoder
Load
called
"
)
;
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
0
"
Should
not
have
entry
for
element
in
element
table
before
addition
"
)
;
if
(
!
gElementTable
)
{
gElementTable
=
new
MediaElementURITable
(
)
;
}
MediaElementSetForURI
*
entry
=
gElementTable
-
>
PutEntry
(
mLoadingSrc
)
;
entry
-
>
mElements
.
AppendElement
(
this
)
;
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
1
"
Should
have
a
single
entry
for
element
in
element
table
after
addition
"
)
;
}
void
HTMLMediaElement
:
:
RemoveMediaElementFromURITable
(
)
{
if
(
!
mDecoder
|
|
!
mLoadingSrc
|
|
!
gElementTable
)
{
return
;
}
MediaElementSetForURI
*
entry
=
gElementTable
-
>
GetEntry
(
mLoadingSrc
)
;
if
(
!
entry
)
{
return
;
}
entry
-
>
mElements
.
RemoveElement
(
this
)
;
if
(
entry
-
>
mElements
.
IsEmpty
(
)
)
{
gElementTable
-
>
RemoveEntry
(
entry
)
;
if
(
gElementTable
-
>
Count
(
)
=
=
0
)
{
delete
gElementTable
;
gElementTable
=
nullptr
;
}
}
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
0
"
After
remove
should
no
longer
have
an
entry
in
element
table
"
)
;
}
HTMLMediaElement
*
HTMLMediaElement
:
:
LookupMediaElementURITable
(
nsIURI
*
aURI
)
{
if
(
!
gElementTable
)
{
return
nullptr
;
}
MediaElementSetForURI
*
entry
=
gElementTable
-
>
GetEntry
(
aURI
)
;
if
(
!
entry
)
{
return
nullptr
;
}
for
(
uint32_t
i
=
0
;
i
<
entry
-
>
mElements
.
Length
(
)
;
+
+
i
)
{
HTMLMediaElement
*
elem
=
entry
-
>
mElements
[
i
]
;
bool
equal
;
if
(
NS_SUCCEEDED
(
elem
-
>
NodePrincipal
(
)
-
>
Equals
(
NodePrincipal
(
)
&
equal
)
)
&
&
equal
&
&
elem
-
>
mCORSMode
=
=
mCORSMode
)
{
auto
decoder
=
static_cast
<
ChannelMediaDecoder
*
>
(
elem
-
>
mDecoder
.
get
(
)
)
;
NS_ASSERTION
(
decoder
"
Decoder
gone
"
)
;
if
(
decoder
-
>
CanClone
(
)
)
{
return
elem
;
}
}
}
return
nullptr
;
}
class
HTMLMediaElement
:
:
ShutdownObserver
:
public
nsIObserver
{
enum
class
Phase
:
int8_t
{
Init
Subscribed
Unsubscribed
}
;
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
const
char
*
aTopic
const
char16_t
*
)
override
{
if
(
mPhase
!
=
Phase
:
:
Subscribed
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mWeak
)
;
if
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
mWeak
-
>
NotifyShutdownEvent
(
)
;
}
return
NS_OK
;
}
void
Subscribe
(
HTMLMediaElement
*
aPtr
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPhase
=
=
Phase
:
:
Init
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mWeak
)
;
mWeak
=
aPtr
;
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
mPhase
=
Phase
:
:
Subscribed
;
}
void
Unsubscribe
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPhase
=
=
Phase
:
:
Subscribed
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mWeak
)
;
mWeak
=
nullptr
;
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
mPhase
=
Phase
:
:
Unsubscribed
;
}
void
AddRefMediaElement
(
)
{
mWeak
-
>
AddRef
(
)
;
}
void
ReleaseMediaElement
(
)
{
mWeak
-
>
Release
(
)
;
}
private
:
virtual
~
ShutdownObserver
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPhase
=
=
Phase
:
:
Unsubscribed
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mWeak
)
;
}
HTMLMediaElement
*
mWeak
=
nullptr
;
Phase
mPhase
=
Phase
:
:
Init
;
}
;
NS_IMPL_ISUPPORTS
(
HTMLMediaElement
:
:
ShutdownObserver
nsIObserver
)
HTMLMediaElement
:
:
HTMLMediaElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsGenericHTMLElement
(
aNodeInfo
)
mWatchManager
(
this
OwnerDoc
(
)
-
>
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
)
mMainThreadEventTarget
(
OwnerDoc
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
mAbstractMainThread
(
OwnerDoc
(
)
-
>
AbstractMainThreadFor
(
TaskCategory
:
:
Other
)
)
mShutdownObserver
(
new
ShutdownObserver
)
mPlayed
(
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
)
)
mPaused
(
true
"
HTMLMediaElement
:
:
mPaused
"
)
mErrorSink
(
new
ErrorSink
(
this
)
)
mAudioChannelWrapper
(
new
AudioChannelAgentCallback
(
this
)
)
{
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
MOZ_ASSERT
(
mAbstractMainThread
)
;
DecoderDoctorLogger
:
:
LogConstruction
(
this
)
;
mWatchManager
.
Watch
(
mPaused
&
HTMLMediaElement
:
:
UpdateWakeLock
)
;
ErrorResult
rv
;
double
defaultVolume
=
Preferences
:
:
GetFloat
(
"
media
.
default_volume
"
1
.
0
)
;
SetVolume
(
defaultVolume
rv
)
;
RegisterActivityObserver
(
)
;
NotifyOwnerDocumentActivityChanged
(
)
;
mShutdownObserver
-
>
Subscribe
(
this
)
;
}
HTMLMediaElement
:
:
~
HTMLMediaElement
(
)
{
NS_ASSERTION
(
!
mHasSelfReference
"
How
can
we
be
destroyed
if
we
'
re
still
holding
a
self
reference
?
"
)
;
mShutdownObserver
-
>
Unsubscribe
(
)
;
if
(
mVideoFrameContainer
)
{
mVideoFrameContainer
-
>
ForgetElement
(
)
;
}
UnregisterActivityObserver
(
)
;
mSetCDMRequest
.
DisconnectIfExists
(
)
;
mAutoplayPermissionRequest
.
DisconnectIfExists
(
)
;
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
if
(
mProgressTimer
)
{
StopProgress
(
)
;
}
if
(
mVideoDecodeSuspendTimer
)
{
mVideoDecodeSuspendTimer
-
>
Cancel
(
)
;
mVideoDecodeSuspendTimer
=
nullptr
;
}
if
(
mSrcStream
)
{
EndSrcMediaStreamPlayback
(
)
;
}
if
(
mCaptureStreamPort
)
{
mCaptureStreamPort
-
>
Destroy
(
)
;
mCaptureStreamPort
=
nullptr
;
}
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
0
"
Destroyed
media
element
should
no
longer
be
in
element
table
"
)
;
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Cancel
(
)
;
}
if
(
mAudioChannelWrapper
)
{
mAudioChannelWrapper
-
>
Shutdown
(
)
;
mAudioChannelWrapper
=
nullptr
;
}
WakeLockRelease
(
)
;
DecoderDoctorLogger
:
:
LogDestruction
(
this
)
;
}
void
HTMLMediaElement
:
:
StopSuspendingAfterFirstFrame
(
)
{
mAllowSuspendAfterFirstFrame
=
false
;
if
(
!
mSuspendedAfterFirstFrame
)
return
;
mSuspendedAfterFirstFrame
=
false
;
if
(
mDecoder
)
{
mDecoder
-
>
Resume
(
)
;
}
}
void
HTMLMediaElement
:
:
SetPlayedOrSeeked
(
bool
aValue
)
{
if
(
aValue
=
=
mHasPlayedOrSeeked
)
{
return
;
}
mHasPlayedOrSeeked
=
aValue
;
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
;
}
frame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
frame
nsIPresShell
:
:
eTreeChange
NS_FRAME_IS_DIRTY
)
;
}
void
HTMLMediaElement
:
:
NotifyXPCOMShutdown
(
)
{
ShutdownDecoder
(
)
;
}
bool
HTMLMediaElement
:
:
AudioChannelAgentDelayingPlayback
(
)
{
return
mAudioChannelWrapper
&
&
mAudioChannelWrapper
-
>
IsPlaybackBlocked
(
)
;
}
void
HTMLMediaElement
:
:
ReportAutoplayTelemetry
(
)
const
{
if
(
(
Volume
(
)
>
0
.
0
&
&
!
Muted
(
)
)
&
&
(
!
OwnerDoc
(
)
-
>
HasBeenUserGestureActivated
(
)
|
|
Autoplay
(
)
)
)
{
OwnerDoc
(
)
-
>
SetDocTreeHadAudibleMedia
(
)
;
if
(
AutoplayPolicy
:
:
WouldBeAllowedToPlayIfAutoplayDisabled
(
*
this
)
)
{
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MEDIA_AUTOPLAY_WOULD_BE_ALLOWED_COUNT
1
)
;
}
else
{
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MEDIA_AUTOPLAY_WOULD_NOT_BE_ALLOWED_COUNT
1
)
;
}
}
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
Play
(
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Play
(
)
called
by
JS
readyState
=
%
d
"
this
mReadyState
)
)
;
RefPtr
<
PlayPromise
>
promise
=
CreatePlayPromise
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
GetError
(
)
&
&
GetError
(
)
-
>
Code
(
)
=
=
MEDIA_ERR_SRC_NOT_SUPPORTED
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Play
(
)
promise
rejected
because
source
not
supported
.
"
this
)
)
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_MEDIA_NOT_SUPPORTED_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
AudioChannelAgentDelayingPlayback
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Play
(
)
call
delayed
by
AudioChannelAgent
"
this
)
)
;
MaybeDoLoad
(
)
;
mPendingPlayPromises
.
AppendElement
(
promise
)
;
return
promise
.
forget
(
)
;
}
if
(
AudioChannelAgentBlockedPlay
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
play
blocked
by
AudioChannelAgent
.
"
this
)
)
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR
)
;
if
(
StaticPrefs
:
:
MediaBlockEventEnabled
(
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
blocked
"
)
)
;
}
return
promise
.
forget
(
)
;
}
ReportAutoplayTelemetry
(
)
;
const
bool
handlingUserInput
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
switch
(
AutoplayPolicy
:
:
IsAllowedToPlay
(
*
this
)
)
{
case
nsIAutoplay
:
:
ALLOWED
:
{
mPendingPlayPromises
.
AppendElement
(
promise
)
;
PlayInternal
(
handlingUserInput
)
;
UpdateCustomPolicyAfterPlayed
(
)
;
break
;
}
case
nsIAutoplay
:
:
BLOCKED
:
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
play
not
blocked
.
"
this
)
)
;
promise
-
>
MaybeReject
(
NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR
)
;
if
(
StaticPrefs
:
:
MediaBlockEventEnabled
(
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
blocked
"
)
)
;
}
break
;
}
case
nsIAutoplay
:
:
PROMPT
:
{
mPendingPlayPromises
.
AppendElement
(
promise
)
;
EnsureAutoplayRequested
(
handlingUserInput
)
;
break
;
}
}
return
promise
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
EnsureAutoplayRequested
(
bool
aHandlingUserInput
)
{
if
(
mAutoplayPermissionRequest
.
Exists
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
EnsureAutoplayRequested
(
)
existing
request
bailing
.
"
this
)
)
;
return
;
}
RefPtr
<
AutoplayPermissionManager
>
request
=
AutoplayPolicy
:
:
RequestFor
(
*
OwnerDoc
(
)
)
;
if
(
!
request
)
{
AsyncRejectPendingPlayPromises
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
RefPtr
<
HTMLMediaElement
>
self
=
this
;
request
-
>
RequestWithPrompt
(
)
-
>
Then
(
mAbstractMainThread
__func__
[
self
handlingUserInput
=
aHandlingUserInput
request
]
(
bool
aApproved
)
{
self
-
>
mAutoplayPermissionRequest
.
Complete
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Autoplay
request
approved
request
=
%
p
"
self
.
get
(
)
request
.
get
(
)
)
)
;
self
-
>
PlayInternal
(
handlingUserInput
)
;
self
-
>
UpdateCustomPolicyAfterPlayed
(
)
;
}
[
self
request
]
(
nsresult
aError
)
{
self
-
>
mAutoplayPermissionRequest
.
Complete
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Autoplay
request
denied
request
=
%
p
"
self
.
get
(
)
request
.
get
(
)
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
s
rejecting
play
promimses
"
__func__
)
)
;
self
-
>
AsyncRejectPendingPlayPromises
(
NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR
)
;
}
)
-
>
Track
(
mAutoplayPermissionRequest
)
;
}
void
HTMLMediaElement
:
:
PlayInternal
(
bool
aHandlingUserInput
)
{
if
(
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_NONE
)
{
mUseUrgentStartForChannel
=
true
;
}
StopSuspendingAfterFirstFrame
(
)
;
SetPlayedOrSeeked
(
true
)
;
MaybeDoLoad
(
)
;
if
(
mSuspendedForPreloadNone
)
{
ResumeLoad
(
PRELOAD_ENOUGH
)
;
}
if
(
mDecoder
)
{
if
(
mDecoder
-
>
IsEnded
(
)
)
{
SetCurrentTime
(
0
)
;
}
if
(
!
mPausedForInactiveDocumentOrChannel
)
{
mDecoder
-
>
Play
(
)
;
}
}
if
(
mCurrentPlayRangeStart
=
=
-
1
.
0
)
{
mCurrentPlayRangeStart
=
CurrentTime
(
)
;
}
const
bool
oldPaused
=
mPaused
;
mPaused
=
false
;
mAutoplaying
=
false
;
AddRemoveSelfReference
(
)
;
UpdatePreloadAction
(
)
;
UpdateSrcMediaStreamPlaying
(
)
;
mIsBlessed
|
=
aHandlingUserInput
;
if
(
oldPaused
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
play
"
)
)
;
switch
(
mReadyState
)
{
case
HAVE_NOTHING
:
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
break
;
case
HAVE_METADATA
:
case
HAVE_CURRENT_DATA
:
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
break
;
case
HAVE_FUTURE_DATA
:
case
HAVE_ENOUGH_DATA
:
FireTimeUpdate
(
false
)
;
NotifyAboutPlaying
(
)
;
break
;
}
}
else
if
(
mReadyState
>
=
HAVE_FUTURE_DATA
)
{
AsyncResolvePendingPlayPromises
(
)
;
}
}
void
HTMLMediaElement
:
:
MaybeDoLoad
(
)
{
if
(
mNetworkState
=
=
NETWORK_EMPTY
)
{
DoLoad
(
)
;
}
}
void
HTMLMediaElement
:
:
UpdateWakeLock
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
playing
=
!
mPaused
;
bool
isAudible
=
Volume
(
)
>
0
.
0
&
&
!
mMuted
&
&
mIsAudioTrackAudible
;
if
(
playing
&
&
isAudible
)
{
WakeLockCreate
(
)
;
}
else
{
WakeLockRelease
(
)
;
}
}
void
HTMLMediaElement
:
:
WakeLockCreate
(
)
{
if
(
!
mWakeLock
)
{
RefPtr
<
power
:
:
PowerManagerService
>
pmService
=
power
:
:
PowerManagerService
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE_VOID
(
pmService
)
;
ErrorResult
rv
;
mWakeLock
=
pmService
-
>
NewWakeLock
(
NS_LITERAL_STRING
(
"
audio
-
playing
"
)
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
rv
)
;
}
}
void
HTMLMediaElement
:
:
WakeLockRelease
(
)
{
if
(
mWakeLock
)
{
ErrorResult
rv
;
mWakeLock
-
>
Unlock
(
rv
)
;
rv
.
SuppressException
(
)
;
mWakeLock
=
nullptr
;
}
}
HTMLMediaElement
:
:
OutputMediaStream
:
:
OutputMediaStream
(
)
:
mNextAvailableTrackID
(
1
)
mFinishWhenEnded
(
false
)
mCapturingAudioOnly
(
false
)
mCapturingDecoder
(
false
)
mCapturingMediaStream
(
false
)
{
}
HTMLMediaElement
:
:
OutputMediaStream
:
:
~
OutputMediaStream
(
)
{
for
(
auto
pair
:
mTrackPorts
)
{
pair
.
second
(
)
-
>
Destroy
(
)
;
}
}
void
HTMLMediaElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
if
(
!
this
-
>
Controls
(
)
|
|
!
aVisitor
.
mEvent
-
>
mFlags
.
mIsTrusted
)
{
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
return
;
}
HTMLInputElement
*
el
=
nullptr
;
nsCOMPtr
<
nsINode
>
node
;
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
ePointerDown
:
case
ePointerUp
:
case
eTouchEnd
:
case
eTouchMove
:
case
eTouchStart
:
case
eMouseClick
:
case
eMouseDoubleClick
:
case
eMouseDown
:
case
eMouseUp
:
aVisitor
.
mCanHandle
=
false
;
return
;
case
ePointerMove
:
case
eMouseMove
:
node
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
if
(
node
-
>
IsInNativeAnonymousSubtree
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
el
=
static_cast
<
HTMLInputElement
*
>
(
node
.
get
(
)
)
;
}
else
if
(
node
-
>
GetParentNode
(
)
&
&
node
-
>
GetParentNode
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
el
=
static_cast
<
HTMLInputElement
*
>
(
node
-
>
GetParentNode
(
)
)
;
}
}
if
(
el
&
&
el
-
>
IsDraggingRange
(
)
)
{
aVisitor
.
mCanHandle
=
false
;
return
;
}
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
return
;
default
:
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
return
;
}
}
bool
HTMLMediaElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
static
const
nsAttrValue
:
:
EnumTable
kPreloadTable
[
]
=
{
{
"
"
HTMLMediaElement
:
:
PRELOAD_ATTR_EMPTY
}
{
"
none
"
HTMLMediaElement
:
:
PRELOAD_ATTR_NONE
}
{
"
metadata
"
HTMLMediaElement
:
:
PRELOAD_ATTR_METADATA
}
{
"
auto
"
HTMLMediaElement
:
:
PRELOAD_ATTR_AUTO
}
{
nullptr
0
}
}
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
ParseImageAttribute
(
aAttribute
aValue
aResult
)
)
{
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
crossorigin
)
{
ParseCORSValue
(
aValue
aResult
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
preload
)
{
return
aResult
.
ParseEnumValue
(
aValue
kPreloadTable
false
)
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLMediaElement
:
:
DoneCreatingElement
(
)
{
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
muted
)
)
{
mMuted
|
=
MUTED_BY_CONTENT
;
}
}
bool
HTMLMediaElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
nsGenericHTMLElement
:
:
IsHTMLFocusable
(
aWithMouse
aIsFocusable
aTabIndex
)
)
{
return
true
;
}
*
aIsFocusable
=
true
;
return
false
;
}
int32_t
HTMLMediaElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
nsresult
HTMLMediaElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
src
)
{
mSrcMediaSource
=
nullptr
;
mSrcAttrTriggeringPrincipal
=
nsContentUtils
:
:
GetAttrTriggeringPrincipal
(
this
aValue
?
aValue
-
>
GetStringValue
(
)
:
EmptyString
(
)
aMaybeScriptedPrincipal
)
;
if
(
aValue
)
{
nsString
srcStr
=
aValue
-
>
GetStringValue
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
NewURIFromString
(
srcStr
getter_AddRefs
(
uri
)
)
;
if
(
uri
&
&
IsMediaSourceURI
(
uri
)
)
{
nsresult
rv
=
NS_GetSourceForMediaSourceURI
(
uri
getter_AddRefs
(
mSrcMediaSource
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsAutoString
spec
;
GetCurrentSrc
(
spec
)
;
const
char16_t
*
params
[
]
=
{
spec
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadInvalidURI
"
params
ArrayLength
(
params
)
)
;
}
}
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
autoplay
)
{
if
(
aNotify
)
{
if
(
aValue
)
{
StopSuspendingAfterFirstFrame
(
)
;
CheckAutoplayDataReady
(
)
;
}
AddRemoveSelfReference
(
)
;
UpdatePreloadAction
(
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
preload
)
{
UpdatePreloadAction
(
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
loop
)
{
if
(
mDecoder
)
{
mDecoder
-
>
SetLooping
(
!
!
aValue
)
;
}
}
}
if
(
aValue
)
{
AfterMaybeChangeAttr
(
aNameSpaceID
aName
aNotify
)
;
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
nsresult
HTMLMediaElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNamespaceID
aName
aNotify
)
;
return
nsGenericHTMLElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
void
HTMLMediaElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
src
)
{
DoLoad
(
)
;
}
}
}
nsresult
HTMLMediaElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
bool
aCompileEventHandlers
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
aCompileEventHandlers
)
;
mUnboundFromTree
=
false
;
if
(
aDocument
)
{
UpdatePreloadAction
(
)
;
}
NotifyDecoderActivityChanges
(
)
;
return
rv
;
}
void
HTMLMediaElement
:
:
VideoDecodeSuspendTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
auto
element
=
static_cast
<
HTMLMediaElement
*
>
(
aClosure
)
;
element
-
>
mVideoDecodeSuspendTime
.
Start
(
)
;
element
-
>
mVideoDecodeSuspendTimer
=
nullptr
;
}
void
HTMLMediaElement
:
:
HiddenVideoStart
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHiddenPlayTime
.
Start
(
)
;
if
(
mVideoDecodeSuspendTimer
)
{
return
;
}
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mVideoDecodeSuspendTimer
)
VideoDecodeSuspendTimerCallback
this
StaticPrefs
:
:
MediaSuspendBkgndVideoDelayMs
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
HTMLMediaElement
:
:
VideoDecodeSuspendTimerCallback
"
mMainThreadEventTarget
)
;
}
void
HTMLMediaElement
:
:
HiddenVideoStop
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mHiddenPlayTime
.
Pause
(
)
;
mVideoDecodeSuspendTime
.
Pause
(
)
;
if
(
!
mVideoDecodeSuspendTimer
)
{
return
;
}
mVideoDecodeSuspendTimer
-
>
Cancel
(
)
;
mVideoDecodeSuspendTimer
=
nullptr
;
}
void
HTMLMediaElement
:
:
ReportTelemetry
(
)
{
enum
UnloadedState
{
ENDED
=
0
PAUSED
=
1
STALLED
=
2
SEEKING
=
3
OTHER
=
4
}
;
UnloadedState
state
=
OTHER
;
if
(
Seeking
(
)
)
{
state
=
SEEKING
;
}
else
if
(
Ended
(
)
)
{
state
=
ENDED
;
}
else
if
(
Paused
(
)
)
{
state
=
PAUSED
;
}
else
{
bool
stalled
=
false
;
RefPtr
<
TimeRanges
>
ranges
=
Buffered
(
)
;
const
double
errorMargin
=
0
.
05
;
double
t
=
CurrentTime
(
)
;
TimeRanges
:
:
index_type
index
=
ranges
-
>
Find
(
t
errorMargin
)
;
stalled
=
index
!
=
TimeRanges
:
:
NoIndex
&
&
(
ranges
-
>
End
(
index
)
-
t
)
<
errorMargin
;
stalled
|
=
mDecoder
&
&
NextFrameStatus
(
)
=
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_BUFFERING
&
&
mReadyState
=
=
HAVE_CURRENT_DATA
;
if
(
stalled
)
{
state
=
STALLED
;
}
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_UNLOAD_STATE
state
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_UNLOAD_STATE
=
%
d
"
this
state
)
)
;
FrameStatisticsData
data
;
if
(
HTMLVideoElement
*
vid
=
HTMLVideoElement
:
:
FromNodeOrNull
(
this
)
)
{
FrameStatistics
*
stats
=
vid
-
>
GetFrameStatistics
(
)
;
if
(
stats
)
{
data
=
stats
-
>
GetFrameStatisticsData
(
)
;
if
(
data
.
mParsedFrames
)
{
MOZ_ASSERT
(
data
.
mDroppedFrames
<
=
data
.
mParsedFrames
)
;
uint32_t
percentage
=
100
*
data
.
mDroppedFrames
/
data
.
mParsedFrames
;
LOG
(
LogLevel
:
:
Debug
(
"
Reporting
telemetry
DROPPED_FRAMES_IN_VIDEO_PLAYBACK
"
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_DROPPED_FRAMES_PROPORTION
percentage
)
;
}
}
}
if
(
mMediaInfo
.
HasVideo
(
)
&
&
mMediaInfo
.
mVideo
.
mImage
.
height
>
0
)
{
double
playTime
=
mPlayTime
.
Total
(
)
;
double
hiddenPlayTime
=
mHiddenPlayTime
.
Total
(
)
;
double
videoDecodeSuspendTime
=
mVideoDecodeSuspendTime
.
Total
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_PLAY_TIME_MS
SECONDS_TO_MS
(
playTime
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_PLAY_TIME_MS
=
%
f
"
this
playTime
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_HIDDEN_PLAY_TIME_MS
SECONDS_TO_MS
(
hiddenPlayTime
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_HIDDEN_PLAY_TIME_MS
=
%
f
"
this
hiddenPlayTime
)
)
;
if
(
playTime
>
0
.
0
)
{
nsCString
key
(
mMediaInfo
.
HasAudio
(
)
?
"
AV
"
:
"
V
"
)
;
static
const
struct
{
int32_t
mH
;
const
char
*
mRes
;
}
sResolutions
[
]
=
{
{
240
"
0
<
h
<
=
240
"
}
{
480
"
240
<
h
<
=
480
"
}
{
576
"
480
<
h
<
=
576
"
}
{
720
"
576
<
h
<
=
720
"
}
{
1080
"
720
<
h
<
=
1080
"
}
{
2160
"
1080
<
h
<
=
2160
"
}
}
;
const
char
*
resolution
=
"
h
>
2160
"
;
int32_t
height
=
mMediaInfo
.
mVideo
.
mImage
.
height
;
for
(
const
auto
&
res
:
sResolutions
)
{
if
(
height
<
=
res
.
mH
)
{
resolution
=
res
.
mRes
;
break
;
}
}
key
.
AppendASCII
(
resolution
)
;
uint32_t
hiddenPercentage
=
uint32_t
(
hiddenPlayTime
/
playTime
*
100
.
0
+
0
.
5
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_HIDDEN_PLAY_TIME_PERCENTAGE
key
hiddenPercentage
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_HIDDEN_PLAY_TIME_PERCENTAGE
NS_LITERAL_CSTRING
(
"
All
"
)
hiddenPercentage
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_HIDDEN_PLAY_TIME_PERCENTAGE
=
%
u
keys
:
'
%
s
'
and
'
All
'
"
this
hiddenPercentage
key
.
get
(
)
)
)
;
uint32_t
videoDecodeSuspendPercentage
=
uint32_t
(
videoDecodeSuspendTime
/
playTime
*
100
.
0
+
0
.
5
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INFERRED_DECODE_SUSPEND_PERCENTAGE
key
videoDecodeSuspendPercentage
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INFERRED_DECODE_SUSPEND_PERCENTAGE
NS_LITERAL_CSTRING
(
"
All
"
)
videoDecodeSuspendPercentage
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INFERRED_DECODE_SUSPEND_PERCENTAGE
=
%
u
keys
:
'
%
s
'
and
"
"
'
All
'
"
this
videoDecodeSuspendPercentage
key
.
get
(
)
)
)
;
if
(
data
.
mInterKeyframeCount
!
=
0
)
{
uint32_t
average_ms
=
uint32_t
(
std
:
:
min
<
uint64_t
>
(
double
(
data
.
mInterKeyframeSum_us
)
/
double
(
data
.
mInterKeyframeCount
)
/
1000
.
0
+
0
.
5
UINT32_MAX
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_AVERAGE_MS
key
average_ms
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_AVERAGE_MS
NS_LITERAL_CSTRING
(
"
All
"
)
average_ms
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INTER_KEYFRAME_AVERAGE_MS
=
%
u
keys
:
'
%
s
'
and
'
All
'
"
this
average_ms
key
.
get
(
)
)
)
;
uint32_t
max_ms
=
uint32_t
(
std
:
:
min
<
uint64_t
>
(
(
data
.
mInterKeyFrameMax_us
+
500
)
/
1000
UINT32_MAX
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
key
max_ms
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
NS_LITERAL_CSTRING
(
"
All
"
)
max_ms
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INTER_KEYFRAME_MAX_MS
=
%
u
keys
:
'
%
s
'
and
'
All
'
"
this
max_ms
key
.
get
(
)
)
)
;
}
else
{
uint32_t
suspendDelay_ms
=
StaticPrefs
:
:
MediaSuspendBkgndVideoDelayMs
(
)
;
if
(
uint32_t
(
playTime
*
1000
.
0
)
>
suspendDelay_ms
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
key
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_INTER_KEYFRAME_MAX_MS
NS_LITERAL_CSTRING
(
"
All
"
)
0
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
VIDEO_INTER_KEYFRAME_MAX_MS
=
0
(
only
1
keyframe
)
keys
:
"
"
'
%
s
'
and
'
All
'
"
this
key
.
get
(
)
)
)
;
}
}
}
}
}
void
HTMLMediaElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
mUnboundFromTree
=
true
;
mVisibilityState
=
Visibility
:
:
UNTRACKED
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
MOZ_ASSERT
(
IsHidden
(
)
)
;
NotifyDecoderActivityChanges
(
)
;
RefPtr
<
HTMLMediaElement
>
self
(
this
)
;
nsCOMPtr
<
nsIRunnable
>
task
=
NS_NewRunnableFunction
(
"
dom
:
:
HTMLMediaElement
:
:
UnbindFromTree
"
[
self
]
(
)
{
if
(
self
-
>
mUnboundFromTree
)
{
self
-
>
Pause
(
)
;
}
}
)
;
RunInStableState
(
task
)
;
}
CanPlayStatus
HTMLMediaElement
:
:
GetCanPlay
(
const
nsAString
&
aType
DecoderDoctorDiagnostics
*
aDiagnostics
)
{
Maybe
<
MediaContainerType
>
containerType
=
MakeMediaContainerType
(
aType
)
;
if
(
!
containerType
)
{
return
CANPLAY_NO
;
}
CanPlayStatus
status
=
DecoderTraits
:
:
CanHandleContainerType
(
*
containerType
aDiagnostics
)
;
if
(
status
=
=
CANPLAY_YES
&
&
(
*
containerType
)
.
ExtendedType
(
)
.
Codecs
(
)
.
IsEmpty
(
)
)
{
return
CANPLAY_MAYBE
;
}
return
status
;
}
void
HTMLMediaElement
:
:
CanPlayType
(
const
nsAString
&
aType
nsAString
&
aResult
)
{
DecoderDoctorDiagnostics
diagnostics
;
CanPlayStatus
canPlay
=
GetCanPlay
(
aType
&
diagnostics
)
;
diagnostics
.
StoreFormatDiagnostics
(
OwnerDoc
(
)
aType
canPlay
!
=
CANPLAY_NO
__func__
)
;
switch
(
canPlay
)
{
case
CANPLAY_NO
:
aResult
.
Truncate
(
)
;
break
;
case
CANPLAY_YES
:
aResult
.
AssignLiteral
(
"
probably
"
)
;
break
;
case
CANPLAY_MAYBE
:
aResult
.
AssignLiteral
(
"
maybe
"
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
case
.
"
)
;
break
;
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
CanPlayType
(
%
s
)
=
\
"
%
s
\
"
"
this
NS_ConvertUTF16toUTF8
(
aType
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aResult
)
.
get
(
)
)
)
;
}
void
HTMLMediaElement
:
:
AssertReadyStateIsNothing
(
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
if
(
mReadyState
!
=
HAVE_NOTHING
)
{
char
buf
[
1024
]
;
SprintfLiteral
(
buf
"
readyState
=
%
d
networkState
=
%
d
mLoadWaitStatus
=
%
d
"
"
mSourceLoadCandidate
=
%
d
"
"
mIsLoadingFromSourceChildren
=
%
d
mPreloadAction
=
%
d
"
"
mSuspendedForPreloadNone
=
%
d
error
=
%
d
"
int
(
mReadyState
)
int
(
mNetworkState
)
int
(
mLoadWaitStatus
)
!
!
mSourceLoadCandidate
mIsLoadingFromSourceChildren
int
(
mPreloadAction
)
mSuspendedForPreloadNone
GetError
(
)
?
GetError
(
)
-
>
Code
(
)
:
0
)
;
MOZ_CRASH_UNSAFE_PRINTF
(
"
ReadyState
should
be
HAVE_NOTHING
!
%
s
"
buf
)
;
}
#
endif
}
nsresult
HTMLMediaElement
:
:
InitializeDecoderAsClone
(
ChannelMediaDecoder
*
aOriginal
)
{
NS_ASSERTION
(
mLoadingSrc
"
mLoadingSrc
must
already
be
set
"
)
;
NS_ASSERTION
(
mDecoder
=
=
nullptr
"
Shouldn
'
t
have
a
decoder
"
)
;
AssertReadyStateIsNothing
(
)
;
MediaDecoderInit
decoderInit
(
this
mMuted
?
0
.
0
:
mVolume
mPreservesPitch
mPlaybackRate
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
mHasSuspendTaint
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loop
)
aOriginal
-
>
ContainerType
(
)
)
;
RefPtr
<
ChannelMediaDecoder
>
decoder
=
aOriginal
-
>
Clone
(
decoderInit
)
;
if
(
!
decoder
)
return
NS_ERROR_FAILURE
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Cloned
decoder
%
p
from
%
p
"
this
decoder
.
get
(
)
aOriginal
)
)
;
return
FinishDecoderSetup
(
decoder
)
;
}
template
<
typename
DecoderType
typename
.
.
.
LoadArgs
>
nsresult
HTMLMediaElement
:
:
SetupDecoder
(
DecoderType
*
aDecoder
LoadArgs
&
&
.
.
.
aArgs
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Created
decoder
%
p
for
type
%
s
"
this
aDecoder
aDecoder
-
>
ContainerType
(
)
.
OriginalString
(
)
.
Data
(
)
)
)
;
nsresult
rv
=
aDecoder
-
>
Load
(
std
:
:
forward
<
LoadArgs
>
(
aArgs
)
.
.
.
)
;
if
(
NS_FAILED
(
rv
)
)
{
aDecoder
-
>
Shutdown
(
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Failed
to
load
for
decoder
%
p
"
this
aDecoder
)
)
;
return
rv
;
}
rv
=
FinishDecoderSetup
(
aDecoder
)
;
if
(
IsSame
<
DecoderType
ChannelMediaDecoder
>
:
:
value
&
&
NS_SUCCEEDED
(
rv
)
)
{
AddMediaElementToURITable
(
)
;
NS_ASSERTION
(
MediaElementTableCount
(
this
mLoadingSrc
)
=
=
1
"
Media
element
should
have
single
table
entry
if
decode
initialized
"
)
;
}
return
rv
;
}
nsresult
HTMLMediaElement
:
:
InitializeDecoderForChannel
(
nsIChannel
*
aChannel
nsIStreamListener
*
*
aListener
)
{
NS_ASSERTION
(
mLoadingSrc
"
mLoadingSrc
must
already
be
set
"
)
;
AssertReadyStateIsNothing
(
)
;
DecoderDoctorDiagnostics
diagnostics
;
nsAutoCString
mimeType
;
aChannel
-
>
GetContentType
(
mimeType
)
;
NS_ASSERTION
(
!
mimeType
.
IsEmpty
(
)
"
We
should
have
the
Content
-
Type
.
"
)
;
NS_ConvertUTF8toUTF16
mimeUTF16
(
mimeType
)
;
RefPtr
<
HTMLMediaElement
>
self
=
this
;
auto
reportCanPlay
=
[
&
self
]
(
bool
aCanPlay
)
{
diagnostics
.
StoreFormatDiagnostics
(
self
-
>
OwnerDoc
(
)
mimeUTF16
aCanPlay
__func__
)
;
if
(
!
aCanPlay
)
{
nsAutoString
src
;
self
-
>
GetCurrentSrc
(
src
)
;
const
char16_t
*
params
[
]
=
{
mimeUTF16
.
get
(
)
src
.
get
(
)
}
;
self
-
>
ReportLoadError
(
"
MediaLoadUnsupportedMimeType
"
params
ArrayLength
(
params
)
)
;
}
}
;
auto
onExit
=
MakeScopeExit
(
[
self
]
{
if
(
self
-
>
mChannelLoader
)
{
self
-
>
mChannelLoader
-
>
Done
(
)
;
self
-
>
mChannelLoader
=
nullptr
;
}
}
)
;
Maybe
<
MediaContainerType
>
containerType
=
MakeMediaContainerType
(
mimeType
)
;
if
(
!
containerType
)
{
reportCanPlay
(
false
)
;
return
NS_ERROR_FAILURE
;
}
MediaDecoderInit
decoderInit
(
this
mMuted
?
0
.
0
:
mVolume
mPreservesPitch
mPlaybackRate
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
mHasSuspendTaint
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loop
)
*
containerType
)
;
#
ifdef
MOZ_ANDROID_HLS_SUPPORT
if
(
HLSDecoder
:
:
IsSupportedType
(
*
containerType
)
)
{
RefPtr
<
HLSDecoder
>
decoder
=
new
HLSDecoder
(
decoderInit
)
;
reportCanPlay
(
true
)
;
return
SetupDecoder
(
decoder
.
get
(
)
aChannel
)
;
}
#
endif
RefPtr
<
ChannelMediaDecoder
>
decoder
=
ChannelMediaDecoder
:
:
Create
(
decoderInit
&
diagnostics
)
;
if
(
!
decoder
)
{
reportCanPlay
(
false
)
;
return
NS_ERROR_FAILURE
;
}
reportCanPlay
(
true
)
;
bool
isPrivateBrowsing
=
NodePrincipal
(
)
-
>
GetPrivateBrowsingId
(
)
>
0
;
return
SetupDecoder
(
decoder
.
get
(
)
aChannel
isPrivateBrowsing
aListener
)
;
}
nsresult
HTMLMediaElement
:
:
FinishDecoderSetup
(
MediaDecoder
*
aDecoder
)
{
ChangeNetworkState
(
NETWORK_LOADING
)
;
SetDecoder
(
aDecoder
)
;
NotifyDecoderActivityChanges
(
)
;
NotifyDecoderPrincipalChanged
(
)
;
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
ms
.
mCapturingMediaStream
)
{
MOZ_ASSERT
(
!
ms
.
mCapturingDecoder
)
;
continue
;
}
ms
.
mCapturingDecoder
=
true
;
aDecoder
-
>
AddOutputStream
(
ms
.
mStream
-
>
GetInputStream
(
)
-
>
AsProcessedStream
(
)
ms
.
mNextAvailableTrackID
ms
.
mFinishWhenEnded
)
;
}
if
(
mMediaKeys
)
{
if
(
mMediaKeys
-
>
GetCDMProxy
(
)
)
{
mDecoder
-
>
SetCDMProxy
(
mMediaKeys
-
>
GetCDMProxy
(
)
)
;
}
else
{
ShutdownDecoder
(
)
;
return
NS_ERROR_FAILURE
;
}
}
if
(
mChannelLoader
)
{
mChannelLoader
-
>
Done
(
)
;
mChannelLoader
=
nullptr
;
}
NotifyOwnerDocumentActivityChanged
(
)
;
if
(
mPausedForInactiveDocumentOrChannel
)
{
mDecoder
-
>
Suspend
(
)
;
}
if
(
!
mPaused
)
{
SetPlayedOrSeeked
(
true
)
;
if
(
!
mPausedForInactiveDocumentOrChannel
)
{
mDecoder
-
>
Play
(
)
;
}
}
return
NS_OK
;
}
class
HTMLMediaElement
:
:
StreamListener
:
public
MediaStreamListener
{
public
:
StreamListener
(
HTMLMediaElement
*
aElement
const
char
*
aName
)
:
mElement
(
aElement
)
mHaveCurrentData
(
false
)
mFinished
(
false
)
mMutex
(
aName
)
mPendingNotifyOutput
(
false
)
{
}
void
Forget
(
)
{
if
(
mElement
)
{
HTMLMediaElement
*
element
=
mElement
;
mElement
=
nullptr
;
element
-
>
UpdateReadyStateInternal
(
)
;
}
}
MediaDecoderOwner
:
:
NextFrameStatus
NextFrameStatus
(
)
{
if
(
!
mElement
|
|
!
mHaveCurrentData
|
|
mFinished
)
{
return
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE
;
}
return
MediaDecoderOwner
:
:
NEXT_FRAME_AVAILABLE
;
}
void
DoNotifyOutput
(
)
{
{
MutexAutoLock
lock
(
mMutex
)
;
mPendingNotifyOutput
=
false
;
}
if
(
mElement
&
&
mHaveCurrentData
)
{
RefPtr
<
HTMLMediaElement
>
kungFuDeathGrip
=
mElement
;
kungFuDeathGrip
-
>
FireTimeUpdate
(
true
)
;
}
}
void
DoNotifyHaveCurrentData
(
)
{
mHaveCurrentData
=
true
;
if
(
mElement
)
{
RefPtr
<
HTMLMediaElement
>
kungFuDeathGrip
=
mElement
;
kungFuDeathGrip
-
>
FirstFrameLoaded
(
)
;
kungFuDeathGrip
-
>
UpdateReadyStateInternal
(
)
;
}
DoNotifyOutput
(
)
;
}
virtual
void
NotifyHasCurrentData
(
MediaStreamGraph
*
aGraph
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
aGraph
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
NewRunnableMethod
(
"
dom
:
:
HTMLMediaElement
:
:
StreamListener
:
:
DoNotifyHaveCurrentData
"
this
&
StreamListener
:
:
DoNotifyHaveCurrentData
)
)
;
}
virtual
void
NotifyOutput
(
MediaStreamGraph
*
aGraph
GraphTime
aCurrentTime
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
mPendingNotifyOutput
)
return
;
mPendingNotifyOutput
=
true
;
aGraph
-
>
DispatchToMainThreadAfterStreamStateUpdate
(
NewRunnableMethod
(
"
dom
:
:
HTMLMediaElement
:
:
StreamListener
:
:
DoNotifyOutput
"
this
&
StreamListener
:
:
DoNotifyOutput
)
)
;
}
private
:
HTMLMediaElement
*
mElement
;
bool
mHaveCurrentData
;
bool
mFinished
;
Mutex
mMutex
;
bool
mPendingNotifyOutput
;
}
;
class
HTMLMediaElement
:
:
MediaStreamTracksAvailableCallback
:
public
OnTracksAvailableCallback
{
public
:
explicit
MediaStreamTracksAvailableCallback
(
HTMLMediaElement
*
aElement
)
:
OnTracksAvailableCallback
(
)
mElement
(
aElement
)
{
}
virtual
void
NotifyTracksAvailable
(
DOMMediaStream
*
aStream
)
override
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
if
(
!
mElement
)
{
return
;
}
mElement
-
>
NotifyMediaStreamTracksAvailable
(
aStream
)
;
}
private
:
WeakPtr
<
HTMLMediaElement
>
mElement
;
}
;
class
HTMLMediaElement
:
:
MediaStreamTrackListener
:
public
DOMMediaStream
:
:
TrackListener
{
public
:
explicit
MediaStreamTrackListener
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
{
}
void
NotifyTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
mElement
-
>
NotifyMediaStreamTrackAdded
(
aTrack
)
;
}
void
NotifyTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
override
{
mElement
-
>
NotifyMediaStreamTrackRemoved
(
aTrack
)
;
}
void
NotifyActive
(
)
override
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
mSrcStream
%
p
became
active
"
mElement
mElement
-
>
mSrcStream
.
get
(
)
)
)
;
mElement
-
>
CheckAutoplayDataReady
(
)
;
}
void
NotifyInactive
(
)
override
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
mSrcStream
%
p
became
inactive
"
mElement
mElement
-
>
mSrcStream
.
get
(
)
)
)
;
MOZ_ASSERT
(
!
mElement
-
>
mSrcStream
-
>
Active
(
)
)
;
if
(
mElement
-
>
mMediaStreamListener
)
{
mElement
-
>
mMediaStreamListener
-
>
Forget
(
)
;
}
mElement
-
>
PlaybackEnded
(
)
;
}
protected
:
HTMLMediaElement
*
const
mElement
;
}
;
void
HTMLMediaElement
:
:
UpdateSrcMediaStreamPlaying
(
uint32_t
aFlags
)
{
if
(
!
mSrcStream
)
{
return
;
}
MediaStream
*
stream
=
GetSrcMediaStream
(
)
;
bool
shouldPlay
=
!
(
aFlags
&
REMOVING_SRC_STREAM
)
&
&
!
mPaused
&
&
!
mPausedForInactiveDocumentOrChannel
&
&
stream
;
if
(
shouldPlay
=
=
mSrcStreamIsPlaying
)
{
return
;
}
mSrcStreamIsPlaying
=
shouldPlay
;
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
%
s
playback
of
DOMMediaStream
%
p
"
this
shouldPlay
?
"
Setting
up
"
:
"
Removing
"
mSrcStream
.
get
(
)
)
)
;
if
(
shouldPlay
)
{
mSrcStreamPausedCurrentTime
=
-
1
;
mMediaStreamListener
=
new
StreamListener
(
this
"
HTMLMediaElement
:
:
mMediaStreamListener
"
)
;
stream
-
>
AddListener
(
mMediaStreamListener
)
;
stream
-
>
AddAudioOutput
(
this
)
;
SetVolumeInternal
(
)
;
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSelectedVideoStreamTrack
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
AddVideoOutput
(
container
)
;
}
SetCapturedOutputStreamsEnabled
(
true
)
;
SetAudibleState
(
true
)
;
}
else
{
if
(
stream
)
{
mSrcStreamPausedCurrentTime
=
CurrentTime
(
)
;
stream
-
>
RemoveListener
(
mMediaStreamListener
)
;
stream
-
>
RemoveAudioOutput
(
this
)
;
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
if
(
mSelectedVideoStreamTrack
&
&
container
)
{
mSelectedVideoStreamTrack
-
>
RemoveVideoOutput
(
container
)
;
}
SetCapturedOutputStreamsEnabled
(
false
)
;
}
mMediaStreamListener
-
>
Forget
(
)
;
mMediaStreamListener
=
nullptr
;
}
}
void
HTMLMediaElement
:
:
SetupSrcMediaStreamPlayback
(
DOMMediaStream
*
aStream
)
{
NS_ASSERTION
(
!
mSrcStream
&
&
!
mMediaStreamListener
&
&
!
mMediaStreamSizeListener
"
Should
have
been
ended
already
"
)
;
mSrcStream
=
aStream
;
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
UpdateSrcMediaStreamPlaying
(
)
;
nsTArray
<
RefPtr
<
MediaStreamTrack
>
>
tracks
;
mSrcStream
-
>
GetTracks
(
tracks
)
;
for
(
const
RefPtr
<
MediaStreamTrack
>
&
track
:
tracks
)
{
NotifyMediaStreamTrackAdded
(
track
)
;
}
mSrcStream
-
>
OnTracksAvailable
(
new
MediaStreamTracksAvailableCallback
(
this
)
)
;
mMediaStreamTrackListener
=
new
MediaStreamTrackListener
(
this
)
;
mSrcStream
-
>
RegisterTrackListener
(
mMediaStreamTrackListener
)
;
mSrcStream
-
>
AddPrincipalChangeObserver
(
this
)
;
mSrcStreamVideoPrincipal
=
mSrcStream
-
>
GetVideoPrincipal
(
)
;
ChangeNetworkState
(
NETWORK_IDLE
)
;
ChangeDelayLoadStatus
(
false
)
;
CheckAutoplayDataReady
(
)
;
}
void
HTMLMediaElement
:
:
EndSrcMediaStreamPlayback
(
)
{
MOZ_ASSERT
(
mSrcStream
)
;
UpdateSrcMediaStreamPlaying
(
REMOVING_SRC_STREAM
)
;
if
(
mMediaStreamSizeListener
)
{
MOZ_ASSERT
(
mSelectedVideoStreamTrack
)
;
if
(
mSelectedVideoStreamTrack
)
{
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
}
mMediaStreamSizeListener
-
>
Forget
(
)
;
}
mSelectedVideoStreamTrack
=
nullptr
;
mMediaStreamSizeListener
=
nullptr
;
mSrcStream
-
>
UnregisterTrackListener
(
mMediaStreamTrackListener
)
;
mMediaStreamTrackListener
=
nullptr
;
mSrcStreamTracksAvailable
=
false
;
mSrcStream
-
>
RemovePrincipalChangeObserver
(
this
)
;
mSrcStreamVideoPrincipal
=
nullptr
;
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
for
(
auto
pair
:
ms
.
mTrackPorts
)
{
pair
.
second
(
)
-
>
Destroy
(
)
;
}
ms
.
mTrackPorts
.
Clear
(
)
;
}
mSrcStream
=
nullptr
;
}
static
already_AddRefed
<
AudioTrack
>
CreateAudioTrack
(
AudioStreamTrack
*
aStreamTrack
nsIGlobalObject
*
aOwnerGlobal
)
{
nsAutoString
id
;
nsAutoString
label
;
aStreamTrack
-
>
GetId
(
id
)
;
aStreamTrack
-
>
GetLabel
(
label
CallerType
:
:
System
)
;
return
MediaTrackList
:
:
CreateAudioTrack
(
aOwnerGlobal
id
NS_LITERAL_STRING
(
"
main
"
)
label
EmptyString
(
)
true
)
;
}
static
already_AddRefed
<
VideoTrack
>
CreateVideoTrack
(
VideoStreamTrack
*
aStreamTrack
nsIGlobalObject
*
aOwnerGlobal
)
{
nsAutoString
id
;
nsAutoString
label
;
aStreamTrack
-
>
GetId
(
id
)
;
aStreamTrack
-
>
GetLabel
(
label
CallerType
:
:
System
)
;
return
MediaTrackList
:
:
CreateVideoTrack
(
aOwnerGlobal
id
NS_LITERAL_STRING
(
"
main
"
)
label
EmptyString
(
)
aStreamTrack
)
;
}
void
HTMLMediaElement
:
:
NotifyMediaStreamTrackAdded
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
if
(
aTrack
-
>
Ended
(
)
)
{
return
;
}
#
ifdef
DEBUG
nsString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Adding
%
sTrack
with
id
%
s
"
this
aTrack
-
>
AsAudioStreamTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
#
endif
if
(
AudioStreamTrack
*
t
=
aTrack
-
>
AsAudioStreamTrack
(
)
)
{
RefPtr
<
AudioTrack
>
audioTrack
=
CreateAudioTrack
(
t
AudioTracks
(
)
-
>
GetOwnerGlobal
(
)
)
;
AudioTracks
(
)
-
>
AddTrack
(
audioTrack
)
;
}
else
if
(
VideoStreamTrack
*
t
=
aTrack
-
>
AsVideoStreamTrack
(
)
)
{
if
(
!
IsVideo
(
)
)
{
return
;
}
RefPtr
<
VideoTrack
>
videoTrack
=
CreateVideoTrack
(
t
VideoTracks
(
)
-
>
GetOwnerGlobal
(
)
)
;
VideoTracks
(
)
-
>
AddTrack
(
videoTrack
)
;
if
(
VideoTracks
(
)
-
>
SelectedIndex
(
)
=
=
-
1
)
{
MOZ_ASSERT
(
!
mSelectedVideoStreamTrack
)
;
videoTrack
-
>
SetEnabledInternal
(
true
MediaTrack
:
:
FIRE_NO_EVENTS
)
;
}
}
UpdateReadyStateInternal
(
)
;
}
void
HTMLMediaElement
:
:
NotifyMediaStreamTrackRemoved
(
const
RefPtr
<
MediaStreamTrack
>
&
aTrack
)
{
MOZ_ASSERT
(
aTrack
)
;
nsAutoString
id
;
aTrack
-
>
GetId
(
id
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Removing
%
sTrack
with
id
%
s
"
this
aTrack
-
>
AsAudioStreamTrack
(
)
?
"
Audio
"
:
"
Video
"
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
)
)
;
if
(
MediaTrack
*
t
=
AudioTracks
(
)
-
>
GetTrackById
(
id
)
)
{
AudioTracks
(
)
-
>
RemoveTrack
(
t
)
;
}
else
if
(
MediaTrack
*
t
=
VideoTracks
(
)
-
>
GetTrackById
(
id
)
)
{
VideoTracks
(
)
-
>
RemoveTrack
(
t
)
;
}
else
{
NS_ASSERTION
(
aTrack
-
>
AsVideoStreamTrack
(
)
&
&
!
IsVideo
(
)
"
MediaStreamTrack
ended
but
did
not
exist
in
track
lists
.
"
"
This
is
only
allowed
if
a
video
element
ends
and
we
are
an
"
"
audio
element
.
"
)
;
return
;
}
}
void
HTMLMediaElement
:
:
ProcessMediaFragmentURI
(
)
{
nsMediaFragmentURIParser
parser
(
mLoadingSrc
)
;
if
(
mDecoder
&
&
parser
.
HasEndTime
(
)
)
{
mFragmentEnd
=
parser
.
GetEndTime
(
)
;
}
if
(
parser
.
HasStartTime
(
)
)
{
SetCurrentTime
(
parser
.
GetStartTime
(
)
)
;
mFragmentStart
=
parser
.
GetStartTime
(
)
;
}
}
void
HTMLMediaElement
:
:
MetadataLoaded
(
const
MediaInfo
*
aInfo
UniquePtr
<
const
MetadataTags
>
aTags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SetMediaInfo
(
*
aInfo
)
;
mIsEncrypted
=
aInfo
-
>
IsEncrypted
(
)
|
|
mPendingEncryptedInitData
.
IsEncrypted
(
)
;
mTags
=
std
:
:
move
(
aTags
)
;
mLoadedDataFired
=
false
;
ChangeReadyState
(
HAVE_METADATA
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
durationchange
"
)
)
;
if
(
IsVideo
(
)
&
&
HasVideo
(
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
resize
"
)
)
;
}
NS_ASSERTION
(
!
HasVideo
(
)
|
|
(
mMediaInfo
.
mVideo
.
mDisplay
.
width
>
0
&
&
mMediaInfo
.
mVideo
.
mDisplay
.
height
>
0
)
"
Video
resolution
must
be
known
on
'
loadedmetadata
'
"
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadedmetadata
"
)
)
;
if
(
mDecoder
&
&
mDecoder
-
>
IsTransportSeekable
(
)
&
&
mDecoder
-
>
IsMediaSeekable
(
)
)
{
ProcessMediaFragmentURI
(
)
;
mDecoder
-
>
SetFragmentEndTime
(
mFragmentEnd
)
;
}
if
(
mIsEncrypted
)
{
if
(
!
mMediaSource
&
&
Preferences
:
:
GetBool
(
"
media
.
eme
.
mse
-
only
"
true
)
)
{
DecodeError
(
MediaResult
(
NS_ERROR_DOM_MEDIA_FATAL_ERR
"
Encrypted
content
not
supported
outside
of
MSE
"
)
)
;
return
;
}
for
(
const
auto
&
initData
:
mPendingEncryptedInitData
.
mInitDatas
)
{
DispatchEncrypted
(
initData
.
mInitData
initData
.
mType
)
;
}
mPendingEncryptedInitData
.
Reset
(
)
;
}
if
(
IsVideo
(
)
&
&
aInfo
-
>
HasVideo
(
)
)
{
NotifyOwnerDocumentActivityChanged
(
)
;
}
if
(
mDefaultPlaybackStartPosition
!
=
0
.
0
)
{
SetCurrentTime
(
mDefaultPlaybackStartPosition
)
;
mDefaultPlaybackStartPosition
=
0
.
0
;
}
UpdateReadyStateInternal
(
)
;
if
(
!
mSrcStream
)
{
return
;
}
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
for
(
size_t
i
=
0
;
i
<
AudioTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
AudioTrack
*
t
=
(
*
AudioTracks
(
)
)
[
i
]
;
if
(
t
-
>
Enabled
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
ms
)
;
}
}
if
(
IsVideo
(
)
&
&
!
ms
.
mCapturingAudioOnly
)
{
for
(
size_t
i
=
0
;
i
<
VideoTracks
(
)
-
>
Length
(
)
;
+
+
i
)
{
VideoTrack
*
t
=
(
*
VideoTracks
(
)
)
[
i
]
;
if
(
t
-
>
Selected
(
)
)
{
AddCaptureMediaTrackToOutputStream
(
t
ms
)
;
}
}
}
}
}
void
HTMLMediaElement
:
:
FirstFrameLoaded
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
FirstFrameLoaded
(
)
mFirstFrameLoaded
=
%
d
mWaitingForKey
=
%
d
"
this
mFirstFrameLoaded
mWaitingForKey
)
)
;
NS_ASSERTION
(
!
mSuspendedAfterFirstFrame
"
Should
not
have
already
suspended
"
)
;
if
(
!
mFirstFrameLoaded
)
{
mFirstFrameLoaded
=
true
;
UpdateReadyStateInternal
(
)
;
}
ChangeDelayLoadStatus
(
false
)
;
if
(
mDecoder
&
&
mAllowSuspendAfterFirstFrame
&
&
mPaused
&
&
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
&
&
mPreloadAction
=
=
HTMLMediaElement
:
:
PRELOAD_METADATA
)
{
mSuspendedAfterFirstFrame
=
true
;
mDecoder
-
>
Suspend
(
)
;
}
}
void
HTMLMediaElement
:
:
NetworkError
(
const
MediaResult
&
aError
)
{
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
NoSupportedMediaSourceError
(
aError
.
Description
(
)
)
;
}
else
{
Error
(
MEDIA_ERR_NETWORK
)
;
}
}
void
HTMLMediaElement
:
:
DecodeError
(
const
MediaResult
&
aError
)
{
nsAutoString
src
;
GetCurrentSrc
(
src
)
;
const
char16_t
*
params
[
]
=
{
src
.
get
(
)
}
;
ReportLoadError
(
"
MediaLoadDecodeError
"
params
ArrayLength
(
params
)
)
;
DecoderDoctorDiagnostics
diagnostics
;
diagnostics
.
StoreDecodeError
(
OwnerDoc
(
)
aError
src
__func__
)
;
AudioTracks
(
)
-
>
EmptyTracks
(
)
;
VideoTracks
(
)
-
>
EmptyTracks
(
)
;
if
(
mIsLoadingFromSourceChildren
)
{
mErrorSink
-
>
ResetError
(
)
;
if
(
mSourceLoadCandidate
)
{
DispatchAsyncSourceError
(
mSourceLoadCandidate
)
;
QueueLoadFromSourceTask
(
)
;
}
else
{
NS_WARNING
(
"
Should
know
the
source
we
were
loading
from
!
"
)
;
}
}
else
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
NoSupportedMediaSourceError
(
aError
.
Description
(
)
)
;
}
else
{
Error
(
MEDIA_ERR_DECODE
aError
.
Description
(
)
)
;
}
}
void
HTMLMediaElement
:
:
DecodeWarning
(
const
MediaResult
&
aError
)
{
nsAutoString
src
;
GetCurrentSrc
(
src
)
;
DecoderDoctorDiagnostics
diagnostics
;
diagnostics
.
StoreDecodeWarning
(
OwnerDoc
(
)
aError
src
__func__
)
;
}
bool
HTMLMediaElement
:
:
HasError
(
)
const
{
return
GetError
(
)
;
}
void
HTMLMediaElement
:
:
LoadAborted
(
)
{
Error
(
MEDIA_ERR_ABORTED
)
;
}
void
HTMLMediaElement
:
:
Error
(
uint16_t
aErrorCode
const
nsACString
&
aErrorDetails
)
{
mErrorSink
-
>
SetError
(
aErrorCode
aErrorDetails
)
;
ChangeDelayLoadStatus
(
false
)
;
UpdateAudioChannelPlayingState
(
)
;
}
void
HTMLMediaElement
:
:
PlaybackEnded
(
)
{
AddRemoveSelfReference
(
)
;
NS_ASSERTION
(
!
mDecoder
|
|
mDecoder
-
>
IsEnded
(
)
"
Decoder
fired
ended
but
not
in
ended
state
"
)
;
for
(
int32_t
i
=
mOutputStreams
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mOutputStreams
[
i
]
.
mFinishWhenEnded
)
{
LOG
(
LogLevel
:
:
Debug
(
"
Playback
ended
.
Removing
output
stream
%
p
"
mOutputStreams
[
i
]
.
mStream
.
get
(
)
)
)
;
mOutputStreams
.
RemoveElementAt
(
i
)
;
}
}
if
(
mSrcStream
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
got
duration
by
reaching
the
end
of
the
resource
"
this
)
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
durationchange
"
)
)
;
}
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loop
)
)
{
SetCurrentTime
(
0
)
;
return
;
}
FireTimeUpdate
(
false
)
;
if
(
!
mPaused
)
{
Pause
(
)
;
}
if
(
mSrcStream
)
{
mAutoplaying
=
true
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
ended
"
)
)
;
}
void
HTMLMediaElement
:
:
SeekStarted
(
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
seeking
"
)
)
;
}
void
HTMLMediaElement
:
:
SeekCompleted
(
)
{
mPlayingBeforeSeek
=
false
;
SetPlayedOrSeeked
(
true
)
;
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
DidSeek
(
)
;
}
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
seeked
"
)
)
;
AddRemoveSelfReference
(
)
;
if
(
mCurrentPlayRangeStart
=
=
-
1
.
0
)
{
mCurrentPlayRangeStart
=
CurrentTime
(
)
;
}
}
void
HTMLMediaElement
:
:
NotifySuspendedByCache
(
bool
aSuspendedByCache
)
{
mDownloadSuspendedByCache
=
aSuspendedByCache
;
UpdateReadyStateInternal
(
)
;
}
void
HTMLMediaElement
:
:
DownloadSuspended
(
)
{
if
(
mNetworkState
=
=
NETWORK_LOADING
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
progress
"
)
)
;
}
ChangeNetworkState
(
NETWORK_IDLE
)
;
}
void
HTMLMediaElement
:
:
DownloadResumed
(
)
{
ChangeNetworkState
(
NETWORK_LOADING
)
;
}
void
HTMLMediaElement
:
:
CheckProgress
(
bool
aHaveNewProgress
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mNetworkState
=
=
NETWORK_LOADING
)
;
TimeStamp
now
=
TimeStamp
:
:
NowLoRes
(
)
;
if
(
aHaveNewProgress
)
{
mDataTime
=
now
;
}
NS_ASSERTION
(
(
mProgressTime
.
IsNull
(
)
&
&
!
aHaveNewProgress
)
|
|
!
mDataTime
.
IsNull
(
)
"
null
TimeStamp
mDataTime
should
not
be
used
in
comparison
"
)
;
if
(
mProgressTime
.
IsNull
(
)
?
aHaveNewProgress
:
(
now
-
mProgressTime
>
=
TimeDuration
:
:
FromMilliseconds
(
PROGRESS_MS
)
&
&
mDataTime
>
mProgressTime
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
progress
"
)
)
;
mProgressTime
=
now
-
TimeDuration
:
:
Resolution
(
)
;
if
(
mDataTime
>
mProgressTime
)
{
mDataTime
=
mProgressTime
;
}
if
(
!
mProgressTimer
)
{
NS_ASSERTION
(
aHaveNewProgress
"
timer
dispatched
when
there
was
no
timer
"
)
;
StartProgressTimer
(
)
;
if
(
!
mLoadedDataFired
)
{
ChangeDelayLoadStatus
(
true
)
;
}
}
UpdateReadyStateInternal
(
)
;
}
if
(
now
-
mDataTime
>
=
TimeDuration
:
:
FromMilliseconds
(
STALL_MS
)
)
{
if
(
!
mMediaSource
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
stalled
"
)
)
;
}
else
{
ChangeDelayLoadStatus
(
false
)
;
}
NS_ASSERTION
(
mProgressTimer
"
detected
stalled
without
timer
"
)
;
StopProgress
(
)
;
}
AddRemoveSelfReference
(
)
;
}
void
HTMLMediaElement
:
:
ProgressTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
auto
decoder
=
static_cast
<
HTMLMediaElement
*
>
(
aClosure
)
;
decoder
-
>
CheckProgress
(
false
)
;
}
void
HTMLMediaElement
:
:
StartProgressTimer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mNetworkState
=
=
NETWORK_LOADING
)
;
NS_ASSERTION
(
!
mProgressTimer
"
Already
started
progress
timer
.
"
)
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mProgressTimer
)
ProgressTimerCallback
this
PROGRESS_MS
nsITimer
:
:
TYPE_REPEATING_SLACK
"
HTMLMediaElement
:
:
ProgressTimerCallback
"
mMainThreadEventTarget
)
;
}
void
HTMLMediaElement
:
:
StartProgress
(
)
{
mDataTime
=
TimeStamp
:
:
NowLoRes
(
)
;
mProgressTime
=
TimeStamp
(
)
;
StartProgressTimer
(
)
;
}
void
HTMLMediaElement
:
:
StopProgress
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mProgressTimer
)
{
return
;
}
mProgressTimer
-
>
Cancel
(
)
;
mProgressTimer
=
nullptr
;
}
void
HTMLMediaElement
:
:
DownloadProgressed
(
)
{
if
(
mNetworkState
!
=
NETWORK_LOADING
)
{
return
;
}
CheckProgress
(
true
)
;
}
bool
HTMLMediaElement
:
:
ShouldCheckAllowOrigin
(
)
{
return
mCORSMode
!
=
CORS_NONE
;
}
bool
HTMLMediaElement
:
:
IsCORSSameOrigin
(
)
{
bool
subsumes
;
RefPtr
<
nsIPrincipal
>
principal
=
GetCurrentPrincipal
(
)
;
return
(
NS_SUCCEEDED
(
NodePrincipal
(
)
-
>
Subsumes
(
principal
&
subsumes
)
)
&
&
subsumes
)
|
|
ShouldCheckAllowOrigin
(
)
;
}
void
HTMLMediaElement
:
:
UpdateReadyStateInternal
(
)
{
if
(
!
mDecoder
&
&
!
mSrcStream
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Not
initialized
"
this
)
)
;
return
;
}
if
(
mDecoder
&
&
mReadyState
<
HAVE_METADATA
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Decoder
ready
state
<
HAVE_METADATA
"
this
)
)
;
return
;
}
if
(
mSrcStream
&
&
mReadyState
<
HAVE_METADATA
)
{
if
(
!
mSrcStreamTracksAvailable
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
MediaStreamTracks
not
available
yet
"
this
)
)
;
return
;
}
bool
hasAudioTracks
=
!
AudioTracks
(
)
-
>
IsEmpty
(
)
;
bool
hasVideoTracks
=
!
VideoTracks
(
)
-
>
IsEmpty
(
)
;
if
(
!
hasAudioTracks
&
&
!
hasVideoTracks
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Stream
with
no
tracks
"
this
)
)
;
return
;
}
if
(
IsVideo
(
)
&
&
hasVideoTracks
&
&
!
HasVideo
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Stream
waiting
for
video
"
this
)
)
;
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
Stream
has
"
"
metadata
;
audioTracks
=
%
d
videoTracks
=
%
d
"
"
hasVideoFrame
=
%
d
"
this
AudioTracks
(
)
-
>
Length
(
)
VideoTracks
(
)
-
>
Length
(
)
HasVideo
(
)
)
)
;
MediaInfo
mediaInfo
=
mMediaInfo
;
if
(
hasAudioTracks
)
{
mediaInfo
.
EnableAudio
(
)
;
}
if
(
hasVideoTracks
)
{
mediaInfo
.
EnableVideo
(
)
;
}
MetadataLoaded
(
&
mediaInfo
nullptr
)
;
}
if
(
mMediaSource
)
{
mMediaSource
-
>
CompletePendingTransactions
(
)
;
}
enum
NextFrameStatus
nextFrameStatus
=
NextFrameStatus
(
)
;
if
(
mWaitingForKey
=
=
NOT_WAITING_FOR_KEY
)
{
if
(
nextFrameStatus
=
=
NEXT_FRAME_UNAVAILABLE
&
&
mDecoder
&
&
!
mDecoder
-
>
IsEnded
(
)
)
{
nextFrameStatus
=
mDecoder
-
>
NextFrameBufferedStatus
(
)
;
}
}
else
if
(
mWaitingForKey
=
=
WAITING_FOR_KEY
)
{
if
(
nextFrameStatus
=
=
NEXT_FRAME_UNAVAILABLE
|
|
nextFrameStatus
=
=
NEXT_FRAME_UNAVAILABLE_BUFFERING
)
{
mWaitingForKey
=
WAITING_FOR_KEY_DISPATCHED
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waitingforkey
"
)
)
;
}
}
else
{
MOZ_ASSERT
(
mWaitingForKey
=
=
WAITING_FOR_KEY_DISPATCHED
)
;
if
(
nextFrameStatus
=
=
NEXT_FRAME_AVAILABLE
)
{
mWaitingForKey
=
NOT_WAITING_FOR_KEY
;
}
}
if
(
nextFrameStatus
=
=
MediaDecoderOwner
:
:
NEXT_FRAME_UNAVAILABLE_SEEKING
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
NEXT_FRAME_UNAVAILABLE_SEEKING
;
Forcing
HAVE_METADATA
"
this
)
)
;
ChangeReadyState
(
HAVE_METADATA
)
;
return
;
}
if
(
IsVideo
(
)
&
&
HasVideo
(
)
&
&
!
IsPlaybackEnded
(
)
&
&
GetImageContainer
(
)
&
&
!
GetImageContainer
(
)
-
>
HasCurrentImage
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Playing
video
but
no
video
frame
;
Forcing
HAVE_METADATA
"
this
)
)
;
ChangeReadyState
(
HAVE_METADATA
)
;
return
;
}
if
(
!
mFirstFrameLoaded
)
{
return
;
}
if
(
nextFrameStatus
=
=
NEXT_FRAME_UNAVAILABLE_BUFFERING
)
{
ChangeReadyState
(
HAVE_CURRENT_DATA
)
;
return
;
}
if
(
mTextTrackManager
&
&
!
mTextTrackManager
-
>
IsLoaded
(
)
)
{
ChangeReadyState
(
HAVE_CURRENT_DATA
)
;
return
;
}
if
(
mDownloadSuspendedByCache
&
&
mDecoder
&
&
!
mDecoder
-
>
IsEnded
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Decoder
download
suspended
by
cache
"
this
)
)
;
ChangeReadyState
(
HAVE_ENOUGH_DATA
)
;
return
;
}
if
(
nextFrameStatus
!
=
MediaDecoderOwner
:
:
NEXT_FRAME_AVAILABLE
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Next
frame
not
available
"
this
)
)
;
ChangeReadyState
(
HAVE_CURRENT_DATA
)
;
return
;
}
if
(
mSrcStream
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Stream
HAVE_ENOUGH_DATA
"
this
)
)
;
ChangeReadyState
(
HAVE_ENOUGH_DATA
)
;
return
;
}
if
(
mDecoder
-
>
CanPlayThrough
(
)
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Decoder
can
play
through
"
this
)
)
;
ChangeReadyState
(
HAVE_ENOUGH_DATA
)
;
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
MediaElement
%
p
UpdateReadyStateInternal
(
)
"
"
Default
;
Decoder
has
future
data
"
this
)
)
;
ChangeReadyState
(
HAVE_FUTURE_DATA
)
;
}
static
const
char
*
const
gReadyStateToString
[
]
=
{
"
HAVE_NOTHING
"
"
HAVE_METADATA
"
"
HAVE_CURRENT_DATA
"
"
HAVE_FUTURE_DATA
"
"
HAVE_ENOUGH_DATA
"
}
;
void
HTMLMediaElement
:
:
ChangeReadyState
(
nsMediaReadyState
aState
)
{
if
(
mReadyState
=
=
aState
)
{
return
;
}
nsMediaReadyState
oldState
=
mReadyState
;
mReadyState
=
aState
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Ready
state
changed
to
%
s
"
this
gReadyStateToString
[
aState
]
)
)
;
DDLOG
(
DDLogCategory
:
:
Property
"
ready_state
"
gReadyStateToString
[
aState
]
)
;
if
(
mNetworkState
=
=
NETWORK_EMPTY
)
{
return
;
}
UpdateAudioChannelPlayingState
(
)
;
if
(
mPlayingBeforeSeek
&
&
mReadyState
<
HAVE_FUTURE_DATA
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
}
else
if
(
oldState
>
=
HAVE_FUTURE_DATA
&
&
mReadyState
<
HAVE_FUTURE_DATA
&
&
!
Paused
(
)
&
&
!
Ended
(
)
&
&
!
mErrorSink
-
>
mError
)
{
FireTimeUpdate
(
false
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
waiting
"
)
)
;
}
if
(
oldState
<
HAVE_CURRENT_DATA
&
&
mReadyState
>
=
HAVE_CURRENT_DATA
&
&
!
mLoadedDataFired
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
loadeddata
"
)
)
;
mLoadedDataFired
=
true
;
}
if
(
oldState
<
HAVE_FUTURE_DATA
&
&
mReadyState
>
=
HAVE_FUTURE_DATA
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
canplay
"
)
)
;
if
(
!
mPaused
)
{
if
(
mDecoder
&
&
!
mPausedForInactiveDocumentOrChannel
)
{
MOZ_ASSERT
(
AutoplayPolicy
:
:
IsAllowedToPlay
(
*
this
)
=
=
nsIAutoplay
:
:
ALLOWED
)
;
mDecoder
-
>
Play
(
)
;
}
NotifyAboutPlaying
(
)
;
}
}
CheckAutoplayDataReady
(
)
;
if
(
oldState
<
HAVE_ENOUGH_DATA
&
&
mReadyState
>
=
HAVE_ENOUGH_DATA
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
canplaythrough
"
)
)
;
}
}
static
const
char
*
const
gNetworkStateToString
[
]
=
{
"
EMPTY
"
"
IDLE
"
"
LOADING
"
"
NO_SOURCE
"
}
;
void
HTMLMediaElement
:
:
ChangeNetworkState
(
nsMediaNetworkState
aState
)
{
if
(
mNetworkState
=
=
aState
)
{
return
;
}
nsMediaNetworkState
oldState
=
mNetworkState
;
mNetworkState
=
aState
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Network
state
changed
to
%
s
"
this
gNetworkStateToString
[
aState
]
)
)
;
DDLOG
(
DDLogCategory
:
:
Property
"
network_state
"
gNetworkStateToString
[
aState
]
)
;
if
(
oldState
=
=
NETWORK_LOADING
)
{
StopProgress
(
)
;
}
if
(
mNetworkState
=
=
NETWORK_LOADING
)
{
StartProgress
(
)
;
}
else
if
(
mNetworkState
=
=
NETWORK_IDLE
&
&
!
mErrorSink
-
>
mError
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
suspend
"
)
)
;
}
AddRemoveSelfReference
(
)
;
}
bool
HTMLMediaElement
:
:
CanActivateAutoplay
(
)
{
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
autoplay
)
)
{
return
false
;
}
if
(
!
mAutoplaying
)
{
return
false
;
}
if
(
IsEditable
(
)
)
{
return
false
;
}
if
(
!
mPaused
)
{
return
false
;
}
if
(
mPausedForInactiveDocumentOrChannel
)
{
return
false
;
}
if
(
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
return
false
;
}
if
(
mAudioChannelWrapper
)
{
if
(
mAudioChannelWrapper
-
>
GetSuspendType
(
)
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
|
|
mAudioChannelWrapper
-
>
GetSuspendType
(
)
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
|
|
mAudioChannelWrapper
-
>
IsPlaybackBlocked
(
)
)
{
return
false
;
}
}
bool
hasData
=
(
mDecoder
&
&
mReadyState
>
=
HAVE_ENOUGH_DATA
)
|
|
(
mSrcStream
&
&
mSrcStream
-
>
Active
(
)
)
;
return
hasData
;
}
void
HTMLMediaElement
:
:
CheckAutoplayDataReady
(
)
{
if
(
!
CanActivateAutoplay
(
)
)
{
return
;
}
ReportAutoplayTelemetry
(
)
;
switch
(
AutoplayPolicy
:
:
IsAllowedToPlay
(
*
this
)
)
{
case
nsIAutoplay
:
:
BLOCKED
:
return
;
case
nsIAutoplay
:
:
PROMPT
:
EnsureAutoplayRequested
(
false
)
;
return
;
case
nsIAutoplay
:
:
ALLOWED
:
break
;
}
mPaused
=
false
;
AddRemoveSelfReference
(
)
;
UpdateSrcMediaStreamPlaying
(
)
;
UpdateAudioChannelPlayingState
(
)
;
if
(
mDecoder
)
{
SetPlayedOrSeeked
(
true
)
;
if
(
mCurrentPlayRangeStart
=
=
-
1
.
0
)
{
mCurrentPlayRangeStart
=
CurrentTime
(
)
;
}
MOZ_ASSERT
(
!
mPausedForInactiveDocumentOrChannel
)
;
mDecoder
-
>
Play
(
)
;
}
else
if
(
mSrcStream
)
{
SetPlayedOrSeeked
(
true
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
play
"
)
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
playing
"
)
)
;
}
bool
HTMLMediaElement
:
:
IsActive
(
)
const
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
return
ownerDoc
&
&
ownerDoc
-
>
IsActive
(
)
&
&
ownerDoc
-
>
IsVisible
(
)
;
}
bool
HTMLMediaElement
:
:
IsHidden
(
)
const
{
nsIDocument
*
ownerDoc
;
return
mUnboundFromTree
|
|
!
(
ownerDoc
=
OwnerDoc
(
)
)
|
|
ownerDoc
-
>
Hidden
(
)
;
}
VideoFrameContainer
*
HTMLMediaElement
:
:
GetVideoFrameContainer
(
)
{
if
(
mShuttingDown
)
{
return
nullptr
;
}
if
(
mVideoFrameContainer
)
return
mVideoFrameContainer
;
if
(
!
IsVideo
(
)
)
{
return
nullptr
;
}
mVideoFrameContainer
=
new
VideoFrameContainer
(
this
LayerManager
:
:
CreateImageContainer
(
ImageContainer
:
:
ASYNCHRONOUS
)
)
;
return
mVideoFrameContainer
;
}
void
HTMLMediaElement
:
:
PrincipalChanged
(
DOMMediaStream
*
aStream
)
{
LOG
(
LogLevel
:
:
Info
(
"
HTMLMediaElement
%
p
Stream
principal
changed
.
"
this
)
)
;
nsContentUtils
:
:
CombineResourcePrincipals
(
&
mSrcStreamVideoPrincipal
aStream
-
>
GetVideoPrincipal
(
)
)
;
LOG
(
LogLevel
:
:
Debug
(
"
HTMLMediaElement
%
p
Stream
video
principal
changed
to
"
"
%
p
.
Waiting
for
it
to
reach
VideoFrameContainer
before
"
"
setting
.
"
this
aStream
-
>
GetVideoPrincipal
(
)
)
)
;
if
(
mVideoFrameContainer
)
{
UpdateSrcStreamVideoPrincipal
(
mVideoFrameContainer
-
>
GetLastPrincipalHandle
(
)
)
;
}
}
void
HTMLMediaElement
:
:
UpdateSrcStreamVideoPrincipal
(
const
PrincipalHandle
&
aPrincipalHandle
)
{
nsTArray
<
RefPtr
<
VideoStreamTrack
>
>
videoTracks
;
mSrcStream
-
>
GetVideoTracks
(
videoTracks
)
;
PrincipalHandle
handle
(
aPrincipalHandle
)
;
bool
matchesTrackPrincipal
=
false
;
for
(
const
RefPtr
<
VideoStreamTrack
>
&
track
:
videoTracks
)
{
if
(
PrincipalHandleMatches
(
handle
track
-
>
GetPrincipal
(
)
)
&
&
!
track
-
>
Ended
(
)
)
{
matchesTrackPrincipal
=
true
;
LOG
(
LogLevel
:
:
Debug
(
"
HTMLMediaElement
%
p
VideoFrameContainer
'
s
"
"
PrincipalHandle
matches
track
%
p
.
That
'
s
all
we
"
"
need
.
"
this
track
.
get
(
)
)
)
;
break
;
}
}
if
(
matchesTrackPrincipal
)
{
mSrcStreamVideoPrincipal
=
mSrcStream
-
>
GetVideoPrincipal
(
)
;
}
}
void
HTMLMediaElement
:
:
PrincipalHandleChangedForVideoFrameContainer
(
VideoFrameContainer
*
aContainer
const
PrincipalHandle
&
aNewPrincipalHandle
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mSrcStream
)
{
return
;
}
LOG
(
LogLevel
:
:
Debug
(
"
HTMLMediaElement
%
p
PrincipalHandle
changed
in
"
"
VideoFrameContainer
.
"
this
)
)
;
UpdateSrcStreamVideoPrincipal
(
aNewPrincipalHandle
)
;
}
nsresult
HTMLMediaElement
:
:
DispatchEvent
(
const
nsAString
&
aName
)
{
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Dispatching
event
%
s
"
this
NS_ConvertUTF16toUTF8
(
aName
)
.
get
(
)
)
)
;
if
(
mEventDeliveryPaused
)
{
mPendingEvents
.
AppendElement
(
aName
)
;
return
NS_OK
;
}
return
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
this
)
aName
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
}
void
HTMLMediaElement
:
:
DispatchAsyncEvent
(
const
nsAString
&
aName
)
{
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Queuing
event
%
s
"
this
NS_ConvertUTF16toUTF8
(
aName
)
.
get
(
)
)
)
;
DDLOG
(
DDLogCategory
:
:
Event
"
HTMLMediaElement
"
nsCString
(
NS_ConvertUTF16toUTF8
(
aName
)
)
)
;
if
(
mEventDeliveryPaused
)
{
mPendingEvents
.
AppendElement
(
aName
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
event
;
if
(
aName
.
EqualsLiteral
(
"
playing
"
)
)
{
event
=
new
nsNotifyAboutPlayingRunner
(
this
TakePendingPlayPromises
(
)
)
;
}
else
{
event
=
new
nsAsyncEventRunner
(
aName
this
)
;
}
mMainThreadEventTarget
-
>
Dispatch
(
event
.
forget
(
)
)
;
if
(
(
aName
.
EqualsLiteral
(
"
play
"
)
|
|
aName
.
EqualsLiteral
(
"
playing
"
)
)
)
{
mPlayTime
.
Start
(
)
;
if
(
IsHidden
(
)
)
{
HiddenVideoStart
(
)
;
}
}
else
if
(
aName
.
EqualsLiteral
(
"
waiting
"
)
)
{
mPlayTime
.
Pause
(
)
;
HiddenVideoStop
(
)
;
}
else
if
(
aName
.
EqualsLiteral
(
"
pause
"
)
)
{
mPlayTime
.
Pause
(
)
;
HiddenVideoStop
(
)
;
}
}
nsresult
HTMLMediaElement
:
:
DispatchPendingMediaEvents
(
)
{
NS_ASSERTION
(
!
mEventDeliveryPaused
"
Must
not
be
in
bfcache
when
dispatching
pending
media
events
"
)
;
uint32_t
count
=
mPendingEvents
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
DispatchAsyncEvent
(
mPendingEvents
[
i
]
)
;
}
mPendingEvents
.
Clear
(
)
;
return
NS_OK
;
}
bool
HTMLMediaElement
:
:
IsPotentiallyPlaying
(
)
const
{
return
!
mPaused
&
&
(
mReadyState
=
=
HAVE_ENOUGH_DATA
|
|
mReadyState
=
=
HAVE_FUTURE_DATA
)
&
&
!
IsPlaybackEnded
(
)
;
}
bool
HTMLMediaElement
:
:
IsPlaybackEnded
(
)
const
{
return
mReadyState
>
=
HAVE_METADATA
&
&
mDecoder
&
&
mDecoder
-
>
IsEnded
(
)
;
}
already_AddRefed
<
nsIPrincipal
>
HTMLMediaElement
:
:
GetCurrentPrincipal
(
)
{
if
(
mDecoder
)
{
return
mDecoder
-
>
GetCurrentPrincipal
(
)
;
}
if
(
mSrcStream
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
mSrcStream
-
>
GetPrincipal
(
)
;
return
principal
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsIPrincipal
>
HTMLMediaElement
:
:
GetCurrentVideoPrincipal
(
)
{
if
(
mDecoder
)
{
return
mDecoder
-
>
GetCurrentPrincipal
(
)
;
}
if
(
mSrcStream
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
mSrcStreamVideoPrincipal
;
return
principal
.
forget
(
)
;
}
return
nullptr
;
}
void
HTMLMediaElement
:
:
NotifyDecoderPrincipalChanged
(
)
{
RefPtr
<
nsIPrincipal
>
principal
=
GetCurrentPrincipal
(
)
;
mDecoder
-
>
UpdateSameOriginStatus
(
!
principal
|
|
IsCORSSameOrigin
(
)
)
;
for
(
DecoderPrincipalChangeObserver
*
observer
:
mDecoderPrincipalChangeObservers
)
{
observer
-
>
NotifyDecoderPrincipalChanged
(
)
;
}
}
void
HTMLMediaElement
:
:
AddDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
{
mDecoderPrincipalChangeObservers
.
AppendElement
(
aObserver
)
;
}
bool
HTMLMediaElement
:
:
RemoveDecoderPrincipalChangeObserver
(
DecoderPrincipalChangeObserver
*
aObserver
)
{
return
mDecoderPrincipalChangeObservers
.
RemoveElement
(
aObserver
)
;
}
void
HTMLMediaElement
:
:
Invalidate
(
bool
aImageSizeChanged
Maybe
<
nsIntSize
>
&
aNewIntrinsicSize
bool
aForceInvalidate
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
if
(
aNewIntrinsicSize
)
{
UpdateMediaSize
(
aNewIntrinsicSize
.
value
(
)
)
;
if
(
frame
)
{
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
nsIPresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
presShell
-
>
FrameNeedsReflow
(
frame
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
RefPtr
<
ImageContainer
>
imageContainer
=
GetImageContainer
(
)
;
bool
asyncInvalidate
=
imageContainer
&
&
imageContainer
-
>
IsAsync
(
)
&
&
!
aForceInvalidate
;
if
(
frame
)
{
if
(
aImageSizeChanged
)
{
frame
-
>
InvalidateFrame
(
)
;
}
else
{
frame
-
>
InvalidateLayer
(
DisplayItemType
:
:
TYPE_VIDEO
nullptr
nullptr
asyncInvalidate
?
nsIFrame
:
:
UPDATE_IS_ASYNC
:
0
)
;
}
}
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
void
HTMLMediaElement
:
:
UpdateMediaSize
(
const
nsIntSize
&
aSize
)
{
if
(
IsVideo
(
)
&
&
mReadyState
!
=
HAVE_NOTHING
&
&
mMediaInfo
.
mVideo
.
mDisplay
!
=
aSize
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
resize
"
)
)
;
}
mMediaInfo
.
mVideo
.
mDisplay
=
aSize
;
UpdateReadyStateInternal
(
)
;
}
void
HTMLMediaElement
:
:
UpdateInitialMediaSize
(
const
nsIntSize
&
aSize
)
{
if
(
!
mMediaInfo
.
HasVideo
(
)
)
{
UpdateMediaSize
(
aSize
)
;
}
if
(
!
mMediaStreamSizeListener
)
{
return
;
}
if
(
!
mSelectedVideoStreamTrack
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
mSelectedVideoStreamTrack
-
>
RemoveDirectListener
(
mMediaStreamSizeListener
)
;
mMediaStreamSizeListener
-
>
Forget
(
)
;
mMediaStreamSizeListener
=
nullptr
;
}
void
HTMLMediaElement
:
:
SuspendOrResumeElement
(
bool
aPauseElement
bool
aSuspendEvents
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SuspendOrResumeElement
(
pause
=
%
d
suspendEvents
=
%
d
)
hidden
=
%
d
"
this
aPauseElement
aSuspendEvents
OwnerDoc
(
)
-
>
Hidden
(
)
)
)
;
if
(
aPauseElement
!
=
mPausedForInactiveDocumentOrChannel
)
{
mPausedForInactiveDocumentOrChannel
=
aPauseElement
;
UpdateSrcMediaStreamPlaying
(
)
;
UpdateAudioChannelPlayingState
(
)
;
if
(
aPauseElement
)
{
ReportTelemetry
(
)
;
if
(
mMediaKeys
)
{
nsAutoString
keySystem
;
mMediaKeys
-
>
GetKeySystem
(
keySystem
)
;
}
if
(
mDecoder
)
{
mDecoder
-
>
Pause
(
)
;
mDecoder
-
>
Suspend
(
)
;
}
mEventDeliveryPaused
=
aSuspendEvents
;
}
else
{
if
(
mDecoder
)
{
mDecoder
-
>
Resume
(
)
;
if
(
!
mPaused
&
&
!
mDecoder
-
>
IsEnded
(
)
)
{
mDecoder
-
>
Play
(
)
;
}
}
if
(
mEventDeliveryPaused
)
{
mEventDeliveryPaused
=
false
;
DispatchPendingMediaEvents
(
)
;
}
}
}
}
bool
HTMLMediaElement
:
:
IsBeingDestroyed
(
)
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
nsIDocShell
*
docShell
=
ownerDoc
?
ownerDoc
-
>
GetDocShell
(
)
:
nullptr
;
bool
isBeingDestroyed
=
false
;
if
(
docShell
)
{
docShell
-
>
IsBeingDestroyed
(
&
isBeingDestroyed
)
;
}
return
isBeingDestroyed
;
}
void
HTMLMediaElement
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
bool
visible
=
!
IsHidden
(
)
;
if
(
visible
)
{
HiddenVideoStop
(
)
;
}
else
if
(
mPlayTime
.
IsStarted
(
)
)
{
HiddenVideoStart
(
)
;
}
if
(
mDecoder
&
&
!
IsBeingDestroyed
(
)
)
{
NotifyDecoderActivityChanges
(
)
;
}
bool
pauseElement
=
ShouldElementBePaused
(
)
;
SuspendOrResumeElement
(
pauseElement
!
IsActive
(
)
)
;
if
(
!
OwnerDoc
(
)
-
>
IsCurrentActiveDocument
(
)
&
&
mMediaKeys
)
{
mMediaKeys
-
>
Shutdown
(
)
;
DDUNLINKCHILD
(
mMediaKeys
.
get
(
)
)
;
mMediaKeys
=
nullptr
;
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
}
AddRemoveSelfReference
(
)
;
}
void
HTMLMediaElement
:
:
AddRemoveSelfReference
(
)
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
bool
needSelfReference
=
!
mShuttingDown
&
&
ownerDoc
-
>
IsActive
(
)
&
&
(
mDelayingLoadEvent
|
|
(
!
mPaused
&
&
mDecoder
&
&
!
mDecoder
-
>
IsEnded
(
)
)
|
|
(
!
mPaused
&
&
mSrcStream
&
&
!
mSrcStream
-
>
IsFinished
(
)
)
|
|
(
mDecoder
&
&
mDecoder
-
>
IsSeeking
(
)
)
|
|
CanActivateAutoplay
(
)
|
|
(
mMediaSource
?
mProgressTimer
:
mNetworkState
=
=
NETWORK_LOADING
)
)
;
if
(
needSelfReference
!
=
mHasSelfReference
)
{
mHasSelfReference
=
needSelfReference
;
if
(
needSelfReference
)
{
mShutdownObserver
-
>
AddRefMediaElement
(
)
;
}
else
{
mMainThreadEventTarget
-
>
Dispatch
(
NewRunnableMethod
(
"
dom
:
:
HTMLMediaElement
:
:
DoRemoveSelfReference
"
this
&
HTMLMediaElement
:
:
DoRemoveSelfReference
)
)
;
}
}
}
void
HTMLMediaElement
:
:
DoRemoveSelfReference
(
)
{
mShutdownObserver
-
>
ReleaseMediaElement
(
)
;
}
void
HTMLMediaElement
:
:
NotifyShutdownEvent
(
)
{
mShuttingDown
=
true
;
ResetState
(
)
;
AddRemoveSelfReference
(
)
;
}
void
HTMLMediaElement
:
:
DispatchAsyncSourceError
(
nsIContent
*
aSourceElement
)
{
LOG_EVENT
(
LogLevel
:
:
Debug
(
"
%
p
Queuing
simple
source
error
event
"
this
)
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsSourceErrorEventRunner
(
this
aSourceElement
)
;
mMainThreadEventTarget
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
void
HTMLMediaElement
:
:
NotifyAddedSource
(
)
{
if
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
&
&
mNetworkState
=
=
NETWORK_EMPTY
)
{
AssertReadyStateIsNothing
(
)
;
QueueSelectResourceTask
(
)
;
}
if
(
mLoadWaitStatus
=
=
WAITING_FOR_SOURCE
)
{
mLoadWaitStatus
=
NOT_WAITING
;
QueueLoadFromSourceTask
(
)
;
}
}
Element
*
HTMLMediaElement
:
:
GetNextSource
(
)
{
mSourceLoadCandidate
=
nullptr
;
while
(
true
)
{
if
(
mSourcePointer
=
=
nsINode
:
:
GetLastChild
(
)
)
{
return
nullptr
;
}
if
(
!
mSourcePointer
)
{
mSourcePointer
=
nsINode
:
:
GetFirstChild
(
)
;
}
else
{
mSourcePointer
=
mSourcePointer
-
>
GetNextSibling
(
)
;
}
nsIContent
*
child
=
mSourcePointer
;
if
(
child
&
&
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
)
{
mSourceLoadCandidate
=
child
;
return
child
-
>
AsElement
(
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Execution
should
not
reach
here
!
"
)
;
return
nullptr
;
}
void
HTMLMediaElement
:
:
ChangeDelayLoadStatus
(
bool
aDelay
)
{
if
(
mDelayingLoadEvent
=
=
aDelay
)
return
;
mDelayingLoadEvent
=
aDelay
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
ChangeDelayLoadStatus
(
%
d
)
doc
=
0x
%
p
"
this
aDelay
mLoadBlockedDoc
.
get
(
)
)
)
;
if
(
mDecoder
)
{
mDecoder
-
>
SetLoadInBackground
(
!
aDelay
)
;
}
if
(
aDelay
)
{
mLoadBlockedDoc
=
OwnerDoc
(
)
;
mLoadBlockedDoc
-
>
BlockOnload
(
)
;
}
else
{
if
(
mLoadBlockedDoc
)
{
mLoadBlockedDoc
-
>
UnblockOnload
(
false
)
;
mLoadBlockedDoc
=
nullptr
;
}
}
AddRemoveSelfReference
(
)
;
}
already_AddRefed
<
nsILoadGroup
>
HTMLMediaElement
:
:
GetDocumentLoadGroup
(
)
{
if
(
!
OwnerDoc
(
)
-
>
IsActive
(
)
)
{
NS_WARNING
(
"
Load
group
requested
for
media
element
in
inactive
document
.
"
)
;
}
return
OwnerDoc
(
)
-
>
GetDocumentLoadGroup
(
)
;
}
nsresult
HTMLMediaElement
:
:
CopyInnerTo
(
Element
*
aDest
bool
aPreallocateChildren
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
CopyInnerTo
(
aDest
aPreallocateChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDest
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
HTMLMediaElement
*
dest
=
static_cast
<
HTMLMediaElement
*
>
(
aDest
)
;
dest
-
>
SetMediaInfo
(
mMediaInfo
)
;
}
return
rv
;
}
already_AddRefed
<
TimeRanges
>
HTMLMediaElement
:
:
Buffered
(
)
const
{
media
:
:
TimeIntervals
buffered
=
mDecoder
?
mDecoder
-
>
GetBuffered
(
)
:
media
:
:
TimeIntervals
(
)
;
RefPtr
<
TimeRanges
>
ranges
=
new
TimeRanges
(
ToSupports
(
OwnerDoc
(
)
)
buffered
)
;
return
ranges
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
)
{
SetAcceptHeader
(
aChannel
)
;
DebugOnly
<
nsresult
>
rv
=
aChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Accept
-
Encoding
"
)
EmptyCString
(
)
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
aChannel
-
>
SetReferrerWithPolicy
(
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
OwnerDoc
(
)
-
>
GetReferrerPolicy
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
HTMLMediaElement
:
:
FireTimeUpdate
(
bool
aPeriodic
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
main
thread
.
"
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
double
time
=
CurrentTime
(
)
;
if
(
!
aPeriodic
|
|
(
mLastCurrentTime
!
=
time
&
&
(
mTimeUpdateTime
.
IsNull
(
)
|
|
now
-
mTimeUpdateTime
>
=
TimeDuration
:
:
FromMilliseconds
(
TIMEUPDATE_MS
)
)
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
timeupdate
"
)
)
;
mTimeUpdateTime
=
now
;
mLastCurrentTime
=
time
;
}
if
(
mFragmentEnd
>
=
0
.
0
&
&
time
>
=
mFragmentEnd
)
{
Pause
(
)
;
mFragmentEnd
=
-
1
.
0
;
mFragmentStart
=
-
1
.
0
;
mDecoder
-
>
SetFragmentEndTime
(
mFragmentEnd
)
;
}
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
TimeMarchesOn
(
)
;
}
}
MediaStream
*
HTMLMediaElement
:
:
GetSrcMediaStream
(
)
const
{
if
(
!
mSrcStream
)
{
return
nullptr
;
}
return
mSrcStream
-
>
GetPlaybackStream
(
)
;
}
MediaError
*
HTMLMediaElement
:
:
GetError
(
)
const
{
return
mErrorSink
-
>
mError
;
}
void
HTMLMediaElement
:
:
OpenUnsupportedMediaWithExternalAppIfNeeded
(
)
const
{
mErrorSink
-
>
MaybeOpenUnsupportedMediaForOwner
(
)
;
}
void
HTMLMediaElement
:
:
GetCurrentSpec
(
nsCString
&
aString
)
{
if
(
mLoadingSrc
)
{
mLoadingSrc
-
>
GetSpec
(
aString
)
;
}
else
{
aString
.
Truncate
(
)
;
}
}
double
HTMLMediaElement
:
:
MozFragmentEnd
(
)
{
double
duration
=
Duration
(
)
;
return
(
mFragmentEnd
<
0
.
0
|
|
mFragmentEnd
>
duration
)
?
duration
:
mFragmentEnd
;
}
static
double
ClampPlaybackRate
(
double
aPlaybackRate
)
{
MOZ_ASSERT
(
aPlaybackRate
>
=
0
.
0
)
;
if
(
aPlaybackRate
=
=
0
.
0
)
{
return
aPlaybackRate
;
}
if
(
aPlaybackRate
<
MIN_PLAYBACKRATE
)
{
return
MIN_PLAYBACKRATE
;
}
if
(
aPlaybackRate
>
MAX_PLAYBACKRATE
)
{
return
MAX_PLAYBACKRATE
;
}
return
aPlaybackRate
;
}
void
HTMLMediaElement
:
:
SetDefaultPlaybackRate
(
double
aDefaultPlaybackRate
ErrorResult
&
aRv
)
{
if
(
aDefaultPlaybackRate
<
0
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
;
}
mDefaultPlaybackRate
=
ClampPlaybackRate
(
aDefaultPlaybackRate
)
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
ratechange
"
)
)
;
}
void
HTMLMediaElement
:
:
SetPlaybackRate
(
double
aPlaybackRate
ErrorResult
&
aRv
)
{
if
(
aPlaybackRate
<
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
if
(
mPlaybackRate
=
=
aPlaybackRate
)
{
return
;
}
mPlaybackRate
=
aPlaybackRate
;
if
(
mPlaybackRate
!
=
0
.
0
&
&
(
mPlaybackRate
>
THRESHOLD_HIGH_PLAYBACKRATE_AUDIO
|
|
mPlaybackRate
<
THRESHOLD_LOW_PLAYBACKRATE_AUDIO
)
)
{
SetMutedInternal
(
mMuted
|
MUTED_BY_INVALID_PLAYBACK_RATE
)
;
}
else
{
SetMutedInternal
(
mMuted
&
~
MUTED_BY_INVALID_PLAYBACK_RATE
)
;
}
if
(
mDecoder
)
{
mDecoder
-
>
SetPlaybackRate
(
ClampPlaybackRate
(
mPlaybackRate
)
)
;
}
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
ratechange
"
)
)
;
}
void
HTMLMediaElement
:
:
SetMozPreservesPitch
(
bool
aPreservesPitch
)
{
mPreservesPitch
=
aPreservesPitch
;
if
(
mDecoder
)
{
mDecoder
-
>
SetPreservesPitch
(
mPreservesPitch
)
;
}
}
ImageContainer
*
HTMLMediaElement
:
:
GetImageContainer
(
)
{
VideoFrameContainer
*
container
=
GetVideoFrameContainer
(
)
;
return
container
?
container
-
>
GetImageContainer
(
)
:
nullptr
;
}
void
HTMLMediaElement
:
:
UpdateAudioChannelPlayingState
(
bool
aForcePlaying
)
{
if
(
mAudioChannelWrapper
)
{
mAudioChannelWrapper
-
>
UpdateAudioChannelPlayingState
(
aForcePlaying
)
;
}
}
bool
HTMLMediaElement
:
:
AudioChannelAgentBlockedPlay
(
)
{
if
(
!
mAudioChannelWrapper
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
AudioChannelAgentBlockedPlay
(
)
returning
true
due
to
null
"
"
AudioChannelAgent
.
"
this
)
)
;
return
true
;
}
const
auto
suspendType
=
mAudioChannelWrapper
-
>
GetSuspendType
(
)
;
return
suspendType
=
=
nsISuspendedTypes
:
:
SUSPENDED_PAUSE
|
|
suspendType
=
=
nsISuspendedTypes
:
:
SUSPENDED_BLOCK
;
}
static
const
char
*
VisibilityString
(
Visibility
aVisibility
)
{
switch
(
aVisibility
)
{
case
Visibility
:
:
UNTRACKED
:
{
return
"
UNTRACKED
"
;
}
case
Visibility
:
:
APPROXIMATELY_NONVISIBLE
:
{
return
"
APPROXIMATELY_NONVISIBLE
"
;
}
case
Visibility
:
:
APPROXIMATELY_VISIBLE
:
{
return
"
APPROXIMATELY_VISIBLE
"
;
}
}
return
"
NAN
"
;
}
void
HTMLMediaElement
:
:
OnVisibilityChange
(
Visibility
aNewVisibility
)
{
LOG
(
LogLevel
:
:
Debug
(
"
OnVisibilityChange
(
)
:
%
s
\
n
"
VisibilityString
(
aNewVisibility
)
)
)
;
mVisibilityState
=
aNewVisibility
;
if
(
!
mDecoder
)
{
return
;
}
switch
(
aNewVisibility
)
{
case
Visibility
:
:
UNTRACKED
:
{
MOZ_ASSERT_UNREACHABLE
(
"
Shouldn
'
t
notify
for
untracked
visibility
"
)
;
return
;
}
case
Visibility
:
:
APPROXIMATELY_NONVISIBLE
:
{
if
(
mPlayTime
.
IsStarted
(
)
)
{
HiddenVideoStart
(
)
;
}
break
;
}
case
Visibility
:
:
APPROXIMATELY_VISIBLE
:
{
HiddenVideoStop
(
)
;
break
;
}
}
NotifyDecoderActivityChanges
(
)
;
}
MediaKeys
*
HTMLMediaElement
:
:
GetMediaKeys
(
)
const
{
return
mMediaKeys
;
}
bool
HTMLMediaElement
:
:
ContainsRestrictedContent
(
)
{
return
GetMediaKeys
(
)
!
=
nullptr
;
}
void
HTMLMediaElement
:
:
SetCDMProxyFailure
(
const
MediaResult
&
aResult
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
s
"
__func__
)
)
;
MOZ_ASSERT
(
mSetMediaKeysDOMPromise
)
;
ResetSetMediaKeysTempVariables
(
)
;
mSetMediaKeysDOMPromise
-
>
MaybeReject
(
aResult
.
Code
(
)
aResult
.
Message
(
)
)
;
}
void
HTMLMediaElement
:
:
RemoveMediaKeys
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
s
"
__func__
)
)
;
if
(
mMediaKeys
)
{
mMediaKeys
-
>
Unbind
(
)
;
}
mMediaKeys
=
nullptr
;
}
bool
HTMLMediaElement
:
:
TryRemoveMediaKeysAssociation
(
)
{
MOZ_ASSERT
(
mMediaKeys
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
s
"
__func__
)
)
;
if
(
mDecoder
)
{
RefPtr
<
HTMLMediaElement
>
self
=
this
;
mDecoder
-
>
SetCDMProxy
(
nullptr
)
-
>
Then
(
mAbstractMainThread
__func__
[
self
]
(
)
{
self
-
>
mSetCDMRequest
.
Complete
(
)
;
self
-
>
RemoveMediaKeys
(
)
;
if
(
self
-
>
AttachNewMediaKeys
(
)
)
{
self
-
>
MakeAssociationWithCDMResolved
(
)
;
}
}
[
self
]
(
const
MediaResult
&
aResult
)
{
self
-
>
mSetCDMRequest
.
Complete
(
)
;
self
-
>
SetCDMProxyFailure
(
aResult
)
;
}
)
-
>
Track
(
mSetCDMRequest
)
;
return
false
;
}
RemoveMediaKeys
(
)
;
return
true
;
}
bool
HTMLMediaElement
:
:
DetachExistingMediaKeys
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
s
"
__func__
)
)
;
MOZ_ASSERT
(
mSetMediaKeysDOMPromise
)
;
if
(
mIncomingMediaKeys
&
&
mIncomingMediaKeys
-
>
IsBoundToMediaElement
(
)
)
{
SetCDMProxyFailure
(
MediaResult
(
NS_ERROR_DOM_QUOTA_EXCEEDED_ERR
"
MediaKeys
object
is
already
bound
to
another
HTMLMediaElement
"
)
)
;
return
false
;
}
if
(
mMediaKeys
)
{
return
TryRemoveMediaKeysAssociation
(
)
;
}
return
true
;
}
void
HTMLMediaElement
:
:
MakeAssociationWithCDMResolved
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
s
"
__func__
)
)
;
MOZ_ASSERT
(
mSetMediaKeysDOMPromise
)
;
mMediaKeys
=
mIncomingMediaKeys
;
ResetSetMediaKeysTempVariables
(
)
;
mSetMediaKeysDOMPromise
-
>
MaybeResolveWithUndefined
(
)
;
mSetMediaKeysDOMPromise
=
nullptr
;
}
bool
HTMLMediaElement
:
:
TryMakeAssociationWithCDM
(
CDMProxy
*
aProxy
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
s
"
__func__
)
)
;
MOZ_ASSERT
(
aProxy
)
;
if
(
mDecoder
)
{
RefPtr
<
HTMLMediaElement
>
self
=
this
;
mDecoder
-
>
SetCDMProxy
(
aProxy
)
-
>
Then
(
mAbstractMainThread
__func__
[
self
]
(
)
{
self
-
>
mSetCDMRequest
.
Complete
(
)
;
self
-
>
MakeAssociationWithCDMResolved
(
)
;
}
[
self
]
(
const
MediaResult
&
aResult
)
{
self
-
>
mSetCDMRequest
.
Complete
(
)
;
self
-
>
SetCDMProxyFailure
(
aResult
)
;
}
)
-
>
Track
(
mSetCDMRequest
)
;
return
false
;
}
return
true
;
}
bool
HTMLMediaElement
:
:
AttachNewMediaKeys
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
s
incoming
MediaKeys
(
%
p
)
"
__func__
mIncomingMediaKeys
.
get
(
)
)
)
;
MOZ_ASSERT
(
mSetMediaKeysDOMPromise
)
;
if
(
mIncomingMediaKeys
)
{
auto
cdmProxy
=
mIncomingMediaKeys
-
>
GetCDMProxy
(
)
;
if
(
!
cdmProxy
)
{
SetCDMProxyFailure
(
MediaResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
CDM
crashed
before
binding
MediaKeys
object
to
HTMLMediaElement
"
)
)
;
return
false
;
}
if
(
NS_FAILED
(
mIncomingMediaKeys
-
>
Bind
(
this
)
)
)
{
mMediaKeys
=
nullptr
;
SetCDMProxyFailure
(
MediaResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
Failed
to
bind
MediaKeys
object
to
HTMLMediaElement
"
)
)
;
return
false
;
}
return
TryMakeAssociationWithCDM
(
cdmProxy
)
;
}
return
true
;
}
void
HTMLMediaElement
:
:
ResetSetMediaKeysTempVariables
(
)
{
mAttachingMediaKey
=
false
;
mIncomingMediaKeys
=
nullptr
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
SetMediaKeys
(
mozilla
:
:
dom
:
:
MediaKeys
*
aMediaKeys
ErrorResult
&
aRv
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
SetMediaKeys
(
%
p
)
mMediaKeys
=
%
p
mDecoder
=
%
p
"
this
aMediaKeys
mMediaKeys
.
get
(
)
mDecoder
.
get
(
)
)
)
;
if
(
MozAudioCaptured
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
win
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
DetailedPromise
>
promise
=
DetailedPromise
:
:
Create
(
win
-
>
AsGlobal
(
)
aRv
NS_LITERAL_CSTRING
(
"
HTMLMediaElement
.
setMediaKeys
"
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
mMediaKeys
=
=
aMediaKeys
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
mAttachingMediaKey
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
NS_LITERAL_CSTRING
(
"
A
MediaKeys
object
is
in
attaching
operation
.
"
)
)
;
return
promise
.
forget
(
)
;
}
mAttachingMediaKey
=
true
;
mIncomingMediaKeys
=
aMediaKeys
;
mSetMediaKeysDOMPromise
=
promise
;
if
(
!
DetachExistingMediaKeys
(
)
|
|
!
AttachNewMediaKeys
(
)
)
{
return
promise
.
forget
(
)
;
}
MakeAssociationWithCDMResolved
(
)
;
return
promise
.
forget
(
)
;
}
EventHandlerNonNull
*
HTMLMediaElement
:
:
GetOnencrypted
(
)
{
return
EventTarget
:
:
GetEventHandler
(
nsGkAtoms
:
:
onencrypted
EmptyString
(
)
)
;
}
void
HTMLMediaElement
:
:
SetOnencrypted
(
EventHandlerNonNull
*
aCallback
)
{
EventTarget
:
:
SetEventHandler
(
nsGkAtoms
:
:
onencrypted
EmptyString
(
)
aCallback
)
;
}
EventHandlerNonNull
*
HTMLMediaElement
:
:
GetOnwaitingforkey
(
)
{
return
EventTarget
:
:
GetEventHandler
(
nsGkAtoms
:
:
onwaitingforkey
EmptyString
(
)
)
;
}
void
HTMLMediaElement
:
:
SetOnwaitingforkey
(
EventHandlerNonNull
*
aCallback
)
{
EventTarget
:
:
SetEventHandler
(
nsGkAtoms
:
:
onwaitingforkey
EmptyString
(
)
aCallback
)
;
}
void
HTMLMediaElement
:
:
DispatchEncrypted
(
const
nsTArray
<
uint8_t
>
&
aInitData
const
nsAString
&
aInitDataType
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
DispatchEncrypted
initDataType
=
'
%
s
'
"
this
NS_ConvertUTF16toUTF8
(
aInitDataType
)
.
get
(
)
)
)
;
if
(
mReadyState
=
=
HAVE_NOTHING
)
{
mPendingEncryptedInitData
.
AddInitData
(
aInitDataType
aInitData
)
;
return
;
}
RefPtr
<
MediaEncryptedEvent
>
event
;
if
(
IsCORSSameOrigin
(
)
)
{
event
=
MediaEncryptedEvent
:
:
Constructor
(
this
aInitDataType
aInitData
)
;
}
else
{
event
=
MediaEncryptedEvent
:
:
Constructor
(
this
)
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
event
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
bool
HTMLMediaElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
aName
=
=
nsGkAtoms
:
:
onencrypted
|
|
nsGenericHTMLElement
:
:
IsEventAttributeNameInternal
(
aName
)
;
}
already_AddRefed
<
nsIPrincipal
>
HTMLMediaElement
:
:
GetTopLevelPrincipal
(
)
{
RefPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
window
-
>
GetOuterWindow
(
)
-
>
GetTop
(
)
;
if
(
!
top
)
{
return
nullptr
;
}
nsIDocument
*
doc
=
top
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
principal
=
doc
-
>
NodePrincipal
(
)
;
return
principal
.
forget
(
)
;
}
void
HTMLMediaElement
:
:
NotifyWaitingForKey
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
NotifyWaitingForKey
(
)
"
this
)
)
;
if
(
mWaitingForKey
=
=
NOT_WAITING_FOR_KEY
)
{
mWaitingForKey
=
WAITING_FOR_KEY
;
UpdateReadyStateInternal
(
)
;
}
}
AudioTrackList
*
HTMLMediaElement
:
:
AudioTracks
(
)
{
if
(
!
mAudioTrackList
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
OwnerDoc
(
)
-
>
GetParentObject
(
)
)
;
mAudioTrackList
=
new
AudioTrackList
(
window
this
)
;
}
return
mAudioTrackList
;
}
VideoTrackList
*
HTMLMediaElement
:
:
VideoTracks
(
)
{
if
(
!
mVideoTrackList
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
OwnerDoc
(
)
-
>
GetParentObject
(
)
)
;
mVideoTrackList
=
new
VideoTrackList
(
window
this
)
;
}
return
mVideoTrackList
;
}
TextTrackList
*
HTMLMediaElement
:
:
GetTextTracks
(
)
{
return
GetOrCreateTextTrackManager
(
)
-
>
GetTextTracks
(
)
;
}
already_AddRefed
<
TextTrack
>
HTMLMediaElement
:
:
AddTextTrack
(
TextTrackKind
aKind
const
nsAString
&
aLabel
const
nsAString
&
aLanguage
)
{
return
GetOrCreateTextTrackManager
(
)
-
>
AddTextTrack
(
aKind
aLabel
aLanguage
TextTrackMode
:
:
Hidden
TextTrackReadyState
:
:
Loaded
TextTrackSource
:
:
AddTextTrack
)
;
}
void
HTMLMediaElement
:
:
PopulatePendingTextTrackList
(
)
{
if
(
mTextTrackManager
)
{
mTextTrackManager
-
>
PopulatePendingList
(
)
;
}
}
TextTrackManager
*
HTMLMediaElement
:
:
GetOrCreateTextTrackManager
(
)
{
if
(
!
mTextTrackManager
)
{
mTextTrackManager
=
new
TextTrackManager
(
this
)
;
mTextTrackManager
-
>
AddListeners
(
)
;
}
return
mTextTrackManager
;
}
MediaDecoderOwner
:
:
NextFrameStatus
HTMLMediaElement
:
:
NextFrameStatus
(
)
{
if
(
mDecoder
)
{
return
mDecoder
-
>
NextFrameStatus
(
)
;
}
else
if
(
mMediaStreamListener
)
{
return
mMediaStreamListener
-
>
NextFrameStatus
(
)
;
}
return
NEXT_FRAME_UNINITIALIZED
;
}
void
HTMLMediaElement
:
:
SetDecoder
(
MediaDecoder
*
aDecoder
)
{
MOZ_ASSERT
(
aDecoder
)
;
if
(
mDecoder
)
{
ShutdownDecoder
(
)
;
}
mDecoder
=
aDecoder
;
DDLINKCHILD
(
"
decoder
"
mDecoder
.
get
(
)
)
;
if
(
mDecoder
&
&
mForcedHidden
)
{
mDecoder
-
>
SetForcedHidden
(
mForcedHidden
)
;
}
}
float
HTMLMediaElement
:
:
ComputedVolume
(
)
const
{
return
mMuted
?
0
.
0f
:
mAudioChannelWrapper
?
mAudioChannelWrapper
-
>
GetEffectiveVolume
(
)
:
mVolume
;
}
bool
HTMLMediaElement
:
:
ComputedMuted
(
)
const
{
return
(
mMuted
&
MUTED_BY_AUDIO_CHANNEL
)
;
}
nsSuspendedTypes
HTMLMediaElement
:
:
ComputedSuspended
(
)
const
{
return
mAudioChannelWrapper
?
mAudioChannelWrapper
-
>
GetSuspendType
(
)
:
nsISuspendedTypes
:
:
NONE_SUSPENDED
;
}
bool
HTMLMediaElement
:
:
IsCurrentlyPlaying
(
)
const
{
return
mReadyState
>
=
HAVE_CURRENT_DATA
&
&
!
IsPlaybackEnded
(
)
;
}
void
HTMLMediaElement
:
:
SetAudibleState
(
bool
aAudible
)
{
if
(
mIsAudioTrackAudible
!
=
aAudible
)
{
mIsAudioTrackAudible
=
aAudible
;
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
eDataAudibleChanged
)
;
}
}
void
HTMLMediaElement
:
:
NotifyAudioPlaybackChanged
(
AudibleChangedReasons
aReason
)
{
if
(
mAudioChannelWrapper
)
{
mAudioChannelWrapper
-
>
NotifyAudioPlaybackChanged
(
aReason
)
;
}
UpdateWakeLock
(
)
;
}
bool
HTMLMediaElement
:
:
ShouldElementBePaused
(
)
{
if
(
!
IsActive
(
)
)
{
return
true
;
}
return
false
;
}
void
HTMLMediaElement
:
:
SetMediaInfo
(
const
MediaInfo
&
aInfo
)
{
const
bool
oldHasAudio
=
mMediaInfo
.
HasAudio
(
)
;
mMediaInfo
=
aInfo
;
if
(
aInfo
.
HasAudio
(
)
!
=
oldHasAudio
)
{
UpdateAudioChannelPlayingState
(
)
;
NotifyAudioPlaybackChanged
(
AudioChannelService
:
:
AudibleChangedReasons
:
:
eDataAudibleChanged
)
;
}
if
(
mAudioChannelWrapper
)
{
mAudioChannelWrapper
-
>
AudioCaptureStreamChangeIfNeeded
(
)
;
}
}
void
HTMLMediaElement
:
:
AudioCaptureStreamChange
(
bool
aCapture
)
{
if
(
!
HasAudio
(
)
)
{
return
;
}
if
(
aCapture
&
&
!
mCaptureStreamPort
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
{
return
;
}
uint64_t
id
=
window
-
>
WindowID
(
)
;
MediaStreamGraph
*
msg
=
MediaStreamGraph
:
:
GetInstance
(
MediaStreamGraph
:
:
AUDIO_THREAD_DRIVER
window
MediaStreamGraph
:
:
REQUEST_DEFAULT_SAMPLE_RATE
)
;
if
(
GetSrcMediaStream
(
)
)
{
mCaptureStreamPort
=
msg
-
>
ConnectToCaptureStream
(
id
GetSrcMediaStream
(
)
)
;
}
else
{
RefPtr
<
DOMMediaStream
>
stream
=
CaptureStreamInternal
(
StreamCaptureBehavior
:
:
CONTINUE_WHEN_ENDED
StreamCaptureType
:
:
CAPTURE_AUDIO
msg
)
;
mCaptureStreamPort
=
msg
-
>
ConnectToCaptureStream
(
id
stream
-
>
GetPlaybackStream
(
)
)
;
}
}
else
if
(
!
aCapture
&
&
mCaptureStreamPort
)
{
if
(
mDecoder
)
{
ProcessedMediaStream
*
ps
=
mCaptureStreamPort
-
>
GetSource
(
)
-
>
AsProcessedStream
(
)
;
MOZ_ASSERT
(
ps
)
;
for
(
uint32_t
i
=
0
;
i
<
mOutputStreams
.
Length
(
)
;
i
+
+
)
{
if
(
mOutputStreams
[
i
]
.
mStream
-
>
GetPlaybackStream
(
)
=
=
ps
)
{
mOutputStreams
.
RemoveElementAt
(
i
)
;
break
;
}
}
mDecoder
-
>
RemoveOutputStream
(
ps
)
;
}
mCaptureStreamPort
-
>
Destroy
(
)
;
mCaptureStreamPort
=
nullptr
;
}
}
void
HTMLMediaElement
:
:
NotifyCueDisplayStatesChanged
(
)
{
if
(
!
mTextTrackManager
)
{
return
;
}
mTextTrackManager
-
>
DispatchUpdateCueDisplay
(
)
;
}
void
HTMLMediaElement
:
:
MarkAsContentSource
(
CallerAPI
aAPI
)
{
const
bool
isVisible
=
mVisibilityState
=
=
Visibility
:
:
APPROXIMATELY_VISIBLE
;
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
0
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
1
)
;
if
(
IsInComposedDoc
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
0
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
1
)
;
}
}
switch
(
aAPI
)
{
case
CallerAPI
:
:
DRAW_IMAGE
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
2
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
3
)
;
if
(
IsInComposedDoc
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
2
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
3
)
;
}
}
break
;
}
case
CallerAPI
:
:
CREATE_PATTERN
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
4
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
5
)
;
if
(
IsInComposedDoc
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
4
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
5
)
;
}
}
break
;
}
case
CallerAPI
:
:
CREATE_IMAGEBITMAP
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
6
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
7
)
;
if
(
IsInComposedDoc
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
6
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
7
)
;
}
}
break
;
}
case
CallerAPI
:
:
CAPTURE_STREAM
:
{
if
(
isVisible
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
8
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE
9
)
;
if
(
IsInComposedDoc
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
8
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
9
)
;
}
}
break
;
}
}
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Log
VIDEO_AS_CONTENT_SOURCE
:
visibility
=
%
u
API
:
'
%
d
'
and
'
All
'
"
this
isVisible
static_cast
<
int
>
(
aAPI
)
)
)
;
if
(
!
isVisible
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
p
Log
VIDEO_AS_CONTENT_SOURCE_IN_TREE_OR_NOT
:
inTree
=
%
u
API
:
"
"
'
%
d
'
and
'
All
'
"
this
IsInComposedDoc
(
)
static_cast
<
int
>
(
aAPI
)
)
)
;
}
}
void
HTMLMediaElement
:
:
UpdateCustomPolicyAfterPlayed
(
)
{
OpenUnsupportedMediaWithExternalAppIfNeeded
(
)
;
if
(
mAudioChannelWrapper
)
{
mAudioChannelWrapper
-
>
NotifyPlayStateChanged
(
)
;
}
}
AbstractThread
*
HTMLMediaElement
:
:
AbstractMainThread
(
)
const
{
MOZ_ASSERT
(
mAbstractMainThread
)
;
return
mAbstractMainThread
;
}
nsTArray
<
RefPtr
<
PlayPromise
>
>
HTMLMediaElement
:
:
TakePendingPlayPromises
(
)
{
return
std
:
:
move
(
mPendingPlayPromises
)
;
}
void
HTMLMediaElement
:
:
NotifyAboutPlaying
(
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
playing
"
)
)
;
}
already_AddRefed
<
PlayPromise
>
HTMLMediaElement
:
:
CreatePlayPromise
(
ErrorResult
&
aRv
)
const
{
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
win
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
PlayPromise
>
promise
=
PlayPromise
:
:
Create
(
win
-
>
AsGlobal
(
)
aRv
)
;
LOG
(
LogLevel
:
:
Debug
(
"
%
p
created
PlayPromise
%
p
"
this
promise
.
get
(
)
)
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
HTMLMediaElement
:
:
CreateDOMPromise
(
ErrorResult
&
aRv
)
const
{
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
win
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
return
Promise
:
:
Create
(
win
-
>
AsGlobal
(
)
aRv
)
;
}
void
HTMLMediaElement
:
:
AsyncResolvePendingPlayPromises
(
)
{
mAutoplayPermissionRequest
.
DisconnectIfExists
(
)
;
if
(
mShuttingDown
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsResolveOrRejectPendingPlayPromisesRunner
(
this
TakePendingPlayPromises
(
)
)
;
mMainThreadEventTarget
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
void
HTMLMediaElement
:
:
AsyncRejectPendingPlayPromises
(
nsresult
aError
)
{
mAutoplayPermissionRequest
.
DisconnectIfExists
(
)
;
if
(
!
mPaused
)
{
mPaused
=
true
;
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
pause
"
)
)
;
}
if
(
mShuttingDown
)
{
return
;
}
if
(
aError
=
=
NS_ERROR_DOM_MEDIA_NOT_ALLOWED_ERR
&
&
Preferences
:
:
GetBool
(
"
media
.
autoplay
.
block
-
event
.
enabled
"
false
)
)
{
DispatchAsyncEvent
(
NS_LITERAL_STRING
(
"
blocked
"
)
)
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsResolveOrRejectPendingPlayPromisesRunner
(
this
TakePendingPlayPromises
(
)
aError
)
;
mMainThreadEventTarget
-
>
Dispatch
(
event
.
forget
(
)
)
;
}
void
HTMLMediaElement
:
:
GetEMEInfo
(
nsString
&
aEMEInfo
)
{
if
(
!
mMediaKeys
)
{
return
;
}
nsString
keySystem
;
mMediaKeys
-
>
GetKeySystem
(
keySystem
)
;
nsString
sessionsInfo
;
mMediaKeys
-
>
GetSessionsInfo
(
sessionsInfo
)
;
aEMEInfo
.
AppendLiteral
(
"
Key
System
=
"
)
;
aEMEInfo
.
Append
(
keySystem
)
;
aEMEInfo
.
AppendLiteral
(
"
SessionsInfo
=
"
)
;
aEMEInfo
.
Append
(
sessionsInfo
)
;
}
void
HTMLMediaElement
:
:
NotifyDecoderActivityChanges
(
)
const
{
if
(
mDecoder
)
{
mDecoder
-
>
NotifyOwnerActivityChanged
(
!
IsHidden
(
)
mVisibilityState
IsInComposedDoc
(
)
)
;
}
}
nsIDocument
*
HTMLMediaElement
:
:
GetDocument
(
)
const
{
return
OwnerDoc
(
)
;
}
void
HTMLMediaElement
:
:
ConstructMediaTracks
(
const
MediaInfo
*
aInfo
)
{
if
(
mMediaTracksConstructed
|
|
!
aInfo
)
{
return
;
}
mMediaTracksConstructed
=
true
;
AudioTrackList
*
audioList
=
AudioTracks
(
)
;
if
(
audioList
&
&
aInfo
-
>
HasAudio
(
)
)
{
const
TrackInfo
&
info
=
aInfo
-
>
mAudio
;
RefPtr
<
AudioTrack
>
track
=
MediaTrackList
:
:
CreateAudioTrack
(
audioList
-
>
GetOwnerGlobal
(
)
info
.
mId
info
.
mKind
info
.
mLabel
info
.
mLanguage
info
.
mEnabled
)
;
audioList
-
>
AddTrack
(
track
)
;
}
VideoTrackList
*
videoList
=
VideoTracks
(
)
;
if
(
videoList
&
&
aInfo
-
>
HasVideo
(
)
)
{
const
TrackInfo
&
info
=
aInfo
-
>
mVideo
;
RefPtr
<
VideoTrack
>
track
=
MediaTrackList
:
:
CreateVideoTrack
(
videoList
-
>
GetOwnerGlobal
(
)
info
.
mId
info
.
mKind
info
.
mLabel
info
.
mLanguage
)
;
videoList
-
>
AddTrack
(
track
)
;
track
-
>
SetEnabledInternal
(
info
.
mEnabled
MediaTrack
:
:
FIRE_NO_EVENTS
)
;
}
}
void
HTMLMediaElement
:
:
RemoveMediaTracks
(
)
{
if
(
mAudioTrackList
)
{
mAudioTrackList
-
>
RemoveTracks
(
)
;
}
if
(
mVideoTrackList
)
{
mVideoTrackList
-
>
RemoveTracks
(
)
;
}
mMediaTracksConstructed
=
false
;
for
(
OutputMediaStream
&
ms
:
mOutputStreams
)
{
if
(
!
ms
.
mCapturingDecoder
)
{
continue
;
}
for
(
RefPtr
<
MediaStreamTrack
>
&
t
:
ms
.
mPreCreatedTracks
)
{
if
(
t
-
>
Ended
(
)
)
{
continue
;
}
mAbstractMainThread
-
>
Dispatch
(
NewRunnableMethod
(
"
dom
:
:
HTMLMediaElement
:
:
RemoveMediaTracks
"
t
&
MediaStreamTrack
:
:
OverrideEnded
)
)
;
}
ms
.
mPreCreatedTracks
.
Clear
(
)
;
}
}
class
MediaElementGMPCrashHelper
:
public
GMPCrashHelper
{
public
:
explicit
MediaElementGMPCrashHelper
(
HTMLMediaElement
*
aElement
)
:
mElement
(
aElement
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
already_AddRefed
<
nsPIDOMWindowInner
>
GetPluginCrashedEventTarget
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mElement
)
{
return
nullptr
;
}
return
do_AddRef
(
mElement
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
}
private
:
WeakPtr
<
HTMLMediaElement
>
mElement
;
}
;
already_AddRefed
<
GMPCrashHelper
>
HTMLMediaElement
:
:
CreateGMPCrashHelper
(
)
{
return
MakeAndAddRef
<
MediaElementGMPCrashHelper
>
(
this
)
;
}
void
HTMLMediaElement
:
:
MarkAsTainted
(
)
{
mHasSuspendTaint
=
true
;
if
(
mDecoder
)
{
mDecoder
-
>
SetSuspendTaint
(
true
)
;
}
}
bool
HasDebuggerOrTabsPrivilege
(
JSContext
*
aCx
JSObject
*
aObj
)
{
return
nsContentUtils
:
:
CallerHasPermission
(
aCx
nsGkAtoms
:
:
debugger
)
|
|
nsContentUtils
:
:
CallerHasPermission
(
aCx
nsGkAtoms
:
:
tabs
)
;
}
void
HTMLMediaElement
:
:
AsyncResolveSeekDOMPromiseIfExists
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mSeekDOMPromise
)
{
RefPtr
<
dom
:
:
Promise
>
promise
=
mSeekDOMPromise
.
forget
(
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
dom
:
:
HTMLMediaElement
:
:
AsyncResolveSeekDOMPromiseIfExists
"
[
=
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
)
;
mAbstractMainThread
-
>
Dispatch
(
r
.
forget
(
)
)
;
mSeekDOMPromise
=
nullptr
;
}
}
void
HTMLMediaElement
:
:
AsyncRejectSeekDOMPromiseIfExists
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mSeekDOMPromise
)
{
RefPtr
<
dom
:
:
Promise
>
promise
=
mSeekDOMPromise
.
forget
(
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
dom
:
:
HTMLMediaElement
:
:
AsyncRejectSeekDOMPromiseIfExists
"
[
=
]
(
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_ABORT_ERR
)
;
}
)
;
mAbstractMainThread
-
>
Dispatch
(
r
.
forget
(
)
)
;
mSeekDOMPromise
=
nullptr
;
}
}
void
HTMLMediaElement
:
:
ReportCanPlayTelemetry
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
%
s
"
__func__
)
)
;
RefPtr
<
nsIThread
>
thread
;
nsresult
rv
=
NS_NewNamedThread
(
"
MediaTelemetry
"
getter_AddRefs
(
thread
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
RefPtr
<
AbstractThread
>
abstractThread
=
mAbstractMainThread
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
dom
:
:
HTMLMediaElement
:
:
ReportCanPlayTelemetry
"
[
thread
abstractThread
]
(
)
{
#
if
XP_WIN
DebugOnly
<
HRESULT
>
hr
=
CoInitializeEx
(
0
COINIT_MULTITHREADED
)
;
MOZ_ASSERT
(
hr
=
=
S_OK
)
;
#
endif
bool
aac
=
MP4Decoder
:
:
IsSupportedType
(
MediaContainerType
(
MEDIAMIMETYPE
(
AUDIO_MP4
)
)
nullptr
)
;
bool
h264
=
MP4Decoder
:
:
IsSupportedType
(
MediaContainerType
(
MEDIAMIMETYPE
(
VIDEO_MP4
)
)
nullptr
)
;
#
if
XP_WIN
CoUninitialize
(
)
;
#
endif
abstractThread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
dom
:
:
HTMLMediaElement
:
:
ReportCanPlayTelemetry
"
[
thread
aac
h264
]
(
)
{
LOG
(
LogLevel
:
:
Debug
(
"
MediaTelemetry
aac
=
%
d
h264
=
%
d
"
aac
h264
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
:
:
VIDEO_CAN_CREATE_AAC_DECODER
aac
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
:
:
VIDEO_CAN_CREATE_H264_DECODER
h264
)
;
thread
-
>
AsyncShutdown
(
)
;
}
)
)
;
}
)
NS_DISPATCH_NORMAL
)
;
}
}
}
#
undef
LOG
#
undef
LOG_EVENT
