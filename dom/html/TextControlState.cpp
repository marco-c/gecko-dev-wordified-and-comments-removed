#
include
"
TextControlState
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TextInputListener
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsTextControlFrame
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsIControllerContext
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
InputEventOptions
.
h
"
#
include
"
mozilla
/
NativeKeyBindingsType
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ShortcutKeys
.
h
"
#
include
"
mozilla
/
KeyEventHandler
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
ValueSetterOption
=
TextControlState
:
:
ValueSetterOption
;
using
ValueSetterOptions
=
TextControlState
:
:
ValueSetterOptions
;
using
SelectionDirection
=
nsITextControlFrame
:
:
SelectionDirection
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TextControlElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
TextControlElement
nsGenericHTMLFormControlElementWithState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
TextControlElement
nsGenericHTMLFormControlElementWithState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
TextControlElement
nsGenericHTMLFormControlElementWithState
)
bool
TextControlElement
:
:
GetWrapPropertyEnum
(
nsIContent
*
aContent
TextControlElement
:
:
nsHTMLTextWrap
&
aWrapProp
)
{
aWrapProp
=
eHTMLTextWrap_Soft
;
if
(
!
aContent
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
static
mozilla
:
:
dom
:
:
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
HARD
nsGkAtoms
:
:
OFF
nullptr
}
;
switch
(
aContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
wrap
strings
eIgnoreCase
)
)
{
case
0
:
aWrapProp
=
eHTMLTextWrap_Hard
;
break
;
case
1
:
aWrapProp
=
eHTMLTextWrap_Off
;
break
;
}
return
true
;
}
already_AddRefed
<
TextControlElement
>
TextControlElement
:
:
GetTextControlElementFromEditingHost
(
nsIContent
*
aHost
)
{
if
(
!
aHost
)
{
return
nullptr
;
}
RefPtr
<
TextControlElement
>
parent
=
TextControlElement
:
:
FromNodeOrNull
(
aHost
-
>
GetParent
(
)
)
;
return
parent
.
forget
(
)
;
}
TextControlElement
:
:
FocusTristate
TextControlElement
:
:
FocusState
(
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
FocusTristate
:
:
eUnfocusable
;
}
if
(
IsDisabled
(
)
)
{
return
FocusTristate
:
:
eUnfocusable
;
}
return
IsInActiveTab
(
doc
)
?
FocusTristate
:
:
eActiveWindow
:
FocusTristate
:
:
eInactiveWindow
;
}
using
ValueChangeKind
=
TextControlElement
:
:
ValueChangeKind
;
MOZ_CAN_RUN_SCRIPT
inline
nsresult
SetEditorFlagsIfNecessary
(
EditorBase
&
aEditorBase
uint32_t
aFlags
)
{
if
(
aEditorBase
.
Flags
(
)
=
=
aFlags
)
{
return
NS_OK
;
}
return
aEditorBase
.
SetFlags
(
aFlags
)
;
}
class
MOZ_STACK_CLASS
AutoInputEventSuppresser
final
{
public
:
explicit
AutoInputEventSuppresser
(
TextEditor
*
aTextEditor
)
:
mTextEditor
(
aTextEditor
)
mOuterTransaction
(
aTextEditor
-
>
IsSuppressingDispatchingInputEvent
(
)
)
{
MOZ_ASSERT
(
mTextEditor
)
;
mTextEditor
-
>
SuppressDispatchingInputEvent
(
true
)
;
}
~
AutoInputEventSuppresser
(
)
{
mTextEditor
-
>
SuppressDispatchingInputEvent
(
mOuterTransaction
)
;
}
private
:
RefPtr
<
TextEditor
>
mTextEditor
;
bool
mOuterTransaction
;
}
;
class
RestoreSelectionState
:
public
Runnable
{
public
:
RestoreSelectionState
(
TextControlState
*
aState
nsTextControlFrame
*
aFrame
)
:
Runnable
(
"
RestoreSelectionState
"
)
mFrame
(
aFrame
)
mTextControlState
(
aState
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
!
mTextControlState
)
{
return
NS_OK
;
}
AutoHideSelectionChanges
hideSelectionChanges
(
mFrame
-
>
GetConstFrameSelection
(
)
)
;
if
(
mFrame
)
{
nsAutoScriptBlocker
scriptBlocker
;
mFrame
-
>
EnsureEditorInitialized
(
)
;
TextControlState
:
:
SelectionProperties
&
properties
=
mTextControlState
-
>
GetSelectionProperties
(
)
;
if
(
properties
.
IsDirty
(
)
)
{
mFrame
-
>
SetSelectionRange
(
properties
.
GetStart
(
)
properties
.
GetEnd
(
)
properties
.
GetDirection
(
)
)
;
}
}
if
(
mTextControlState
)
{
mTextControlState
-
>
FinishedRestoringSelection
(
)
;
}
return
NS_OK
;
}
void
Revoke
(
)
{
mFrame
=
nullptr
;
mTextControlState
=
nullptr
;
}
private
:
nsTextControlFrame
*
mFrame
;
TextControlState
*
mTextControlState
;
}
;
class
MOZ_RAII
AutoRestoreEditorState
final
{
public
:
MOZ_CAN_RUN_SCRIPT
explicit
AutoRestoreEditorState
(
TextEditor
*
aTextEditor
)
:
mTextEditor
(
aTextEditor
)
mSavedFlags
(
mTextEditor
-
>
Flags
(
)
)
mSavedMaxLength
(
mTextEditor
-
>
MaxTextLength
(
)
)
mSavedEchoingPasswordPrevented
(
mTextEditor
-
>
EchoingPasswordPrevented
(
)
)
{
MOZ_ASSERT
(
mTextEditor
)
;
uint32_t
flags
=
mSavedFlags
;
flags
&
=
~
nsIEditor
:
:
eEditorReadonlyMask
;
if
(
mSavedFlags
!
=
flags
)
{
MOZ_KnownLive
(
mTextEditor
)
-
>
SetFlags
(
flags
)
;
}
mTextEditor
-
>
PreventToEchoPassword
(
)
;
mTextEditor
-
>
SetMaxTextLength
(
-
1
)
;
}
MOZ_CAN_RUN_SCRIPT
~
AutoRestoreEditorState
(
)
{
if
(
!
mSavedEchoingPasswordPrevented
)
{
mTextEditor
-
>
AllowToEchoPassword
(
)
;
}
mTextEditor
-
>
SetMaxTextLength
(
mSavedMaxLength
)
;
SetEditorFlagsIfNecessary
(
MOZ_KnownLive
(
*
mTextEditor
)
mSavedFlags
)
;
}
private
:
TextEditor
*
mTextEditor
;
uint32_t
mSavedFlags
;
int32_t
mSavedMaxLength
;
bool
mSavedEchoingPasswordPrevented
;
}
;
class
MOZ_RAII
AutoDisableUndo
final
{
public
:
explicit
AutoDisableUndo
(
TextEditor
*
aTextEditor
)
:
mTextEditor
(
aTextEditor
)
mNumberOfMaximumTransactions
(
0
)
{
MOZ_ASSERT
(
mTextEditor
)
;
mNumberOfMaximumTransactions
=
mTextEditor
?
mTextEditor
-
>
NumberOfMaximumTransactions
(
)
:
0
;
DebugOnly
<
bool
>
disabledUndoRedo
=
mTextEditor
-
>
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transactions
"
)
;
}
~
AutoDisableUndo
(
)
{
if
(
mTextEditor
-
>
IsUndoRedoEnabled
(
)
)
{
return
;
}
if
(
mNumberOfMaximumTransactions
)
{
DebugOnly
<
bool
>
enabledUndoRedo
=
mTextEditor
-
>
EnableUndoRedo
(
mNumberOfMaximumTransactions
)
;
NS_WARNING_ASSERTION
(
enabledUndoRedo
"
Failed
to
enable
undo
/
redo
transactions
"
)
;
}
else
{
DebugOnly
<
bool
>
disabledUndoRedo
=
mTextEditor
-
>
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transactions
"
)
;
}
}
private
:
TextEditor
*
mTextEditor
;
int32_t
mNumberOfMaximumTransactions
;
}
;
static
bool
SuppressEventHandlers
(
nsPresContext
*
aPresContext
)
{
bool
suppressHandlers
=
false
;
if
(
aPresContext
)
{
suppressHandlers
=
aPresContext
-
>
IsPaginated
(
)
;
}
return
suppressHandlers
;
}
class
TextInputSelectionController
final
:
public
nsSupportsWeakReference
public
nsISelectionController
{
~
TextInputSelectionController
(
)
=
default
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
TextInputSelectionController
nsISelectionController
)
TextInputSelectionController
(
PresShell
*
aPresShell
nsIContent
*
aLimiter
)
;
void
SetScrollableFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
;
nsFrameSelection
*
GetConstFrameSelection
(
)
{
return
mFrameSelection
;
}
Selection
*
GetSelection
(
SelectionType
aSelectionType
)
;
NS_IMETHOD
SetDisplaySelection
(
int16_t
toggle
)
override
;
NS_IMETHOD
GetDisplaySelection
(
int16_t
*
_retval
)
override
;
NS_IMETHOD
SetSelectionFlags
(
int16_t
aInEnable
)
override
;
NS_IMETHOD
GetSelectionFlags
(
int16_t
*
aOutEnable
)
override
;
NS_IMETHOD
GetSelectionFromScript
(
RawSelectionType
aRawSelectionType
Selection
*
*
aSelection
)
override
;
Selection
*
GetSelection
(
RawSelectionType
aRawSelectionType
)
override
;
NS_IMETHOD
ScrollSelectionIntoView
(
RawSelectionType
aRawSelectionType
int16_t
aRegion
int16_t
aFlags
)
override
;
NS_IMETHOD
RepaintSelection
(
RawSelectionType
aRawSelectionType
)
override
;
nsresult
RepaintSelection
(
nsPresContext
*
aPresContext
SelectionType
aSelectionType
)
;
NS_IMETHOD
SetCaretEnabled
(
bool
enabled
)
override
;
NS_IMETHOD
SetCaretReadOnly
(
bool
aReadOnly
)
override
;
NS_IMETHOD
GetCaretEnabled
(
bool
*
_retval
)
override
;
NS_IMETHOD
GetCaretVisible
(
bool
*
_retval
)
override
;
NS_IMETHOD
SetCaretVisibilityDuringSelection
(
bool
aVisibility
)
override
;
NS_IMETHOD
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
override
;
NS_IMETHOD
CharacterMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
WordMove
(
bool
aForward
bool
aExtend
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
LineMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
IntraLineMove
(
bool
aForward
bool
aExtend
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
PageMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
CompleteScroll
(
bool
aForward
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
CompleteMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
ScrollPage
(
bool
aForward
)
override
;
NS_IMETHOD
ScrollLine
(
bool
aForward
)
override
;
NS_IMETHOD
ScrollCharacter
(
bool
aRight
)
override
;
NS_IMETHOD
CheckVisibility
(
nsINode
*
node
int16_t
startOffset
int16_t
EndOffset
bool
*
_retval
)
override
;
virtual
nsresult
CheckVisibilityContent
(
nsIContent
*
aNode
int16_t
aStartOffset
int16_t
aEndOffset
bool
*
aRetval
)
override
;
void
SelectionWillTakeFocus
(
)
override
;
void
SelectionWillLoseFocus
(
)
override
;
private
:
RefPtr
<
nsFrameSelection
>
mFrameSelection
;
nsIScrollableFrame
*
mScrollFrame
;
nsWeakPtr
mPresShellWeak
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextInputSelectionController
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextInputSelectionController
)
NS_INTERFACE_TABLE_HEAD
(
TextInputSelectionController
)
NS_INTERFACE_TABLE
(
TextInputSelectionController
nsISelectionController
nsISelectionDisplay
nsISupportsWeakReference
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
TextInputSelectionController
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_WEAK
(
TextInputSelectionController
mFrameSelection
)
TextInputSelectionController
:
:
TextInputSelectionController
(
PresShell
*
aPresShell
nsIContent
*
aLimiter
)
:
mScrollFrame
(
nullptr
)
{
if
(
aPresShell
)
{
bool
accessibleCaretEnabled
=
PresShell
:
:
AccessibleCaretEnabled
(
aLimiter
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
)
;
mFrameSelection
=
new
nsFrameSelection
(
aPresShell
aLimiter
accessibleCaretEnabled
)
;
mPresShellWeak
=
do_GetWeakReference
(
aPresShell
)
;
}
}
void
TextInputSelectionController
:
:
SetScrollableFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
{
mScrollFrame
=
aScrollableFrame
;
if
(
!
mScrollFrame
&
&
mFrameSelection
)
{
mFrameSelection
-
>
DisconnectFromPresShell
(
)
;
mFrameSelection
=
nullptr
;
}
}
Selection
*
TextInputSelectionController
:
:
GetSelection
(
SelectionType
aSelectionType
)
{
if
(
!
mFrameSelection
)
{
return
nullptr
;
}
return
mFrameSelection
-
>
GetSelection
(
aSelectionType
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
SetDisplaySelection
(
int16_t
aToggle
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
mFrameSelection
-
>
SetDisplaySelection
(
aToggle
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
GetDisplaySelection
(
int16_t
*
aToggle
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aToggle
=
mFrameSelection
-
>
GetDisplaySelection
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
SetSelectionFlags
(
int16_t
aToggle
)
{
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
GetSelectionFlags
(
int16_t
*
aOutEnable
)
{
*
aOutEnable
=
nsISelectionDisplay
:
:
DISPLAY_TEXT
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
GetSelectionFromScript
(
RawSelectionType
aRawSelectionType
Selection
*
*
aSelection
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aSelection
=
mFrameSelection
-
>
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
if
(
!
(
*
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
NS_ADDREF
(
*
aSelection
)
;
return
NS_OK
;
}
Selection
*
TextInputSelectionController
:
:
GetSelection
(
RawSelectionType
aRawSelectionType
)
{
return
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
ScrollSelectionIntoView
(
RawSelectionType
aRawSelectionType
int16_t
aRegion
int16_t
aFlags
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
ScrollSelectionIntoView
(
ToSelectionType
(
aRawSelectionType
)
aRegion
aFlags
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
RepaintSelection
(
RawSelectionType
aRawSelectionType
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
RepaintSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
nsresult
TextInputSelectionController
:
:
RepaintSelection
(
nsPresContext
*
aPresContext
SelectionType
aSelectionType
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
RepaintSelection
(
aSelectionType
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
SetCaretEnabled
(
bool
enabled
)
{
if
(
!
mPresShellWeak
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
RefPtr
<
PresShell
>
presShell
=
do_QueryReferent
(
mPresShellWeak
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
presShell
-
>
SetCaretEnabled
(
enabled
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
SetCaretReadOnly
(
bool
aReadOnly
)
{
if
(
!
mPresShellWeak
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
;
RefPtr
<
PresShell
>
presShell
=
do_QueryReferent
(
mPresShellWeak
&
rv
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mFrameSelection
)
{
return
NS_ERROR_FAILURE
;
}
Selection
*
selection
=
mFrameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
selection
)
{
caret
-
>
SetCaretReadOnly
(
aReadOnly
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
GetCaretEnabled
(
bool
*
_retval
)
{
return
GetCaretVisible
(
_retval
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
GetCaretVisible
(
bool
*
_retval
)
{
if
(
!
mPresShellWeak
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
;
RefPtr
<
PresShell
>
presShell
=
do_QueryReferent
(
mPresShellWeak
&
rv
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
{
return
NS_ERROR_FAILURE
;
}
*
_retval
=
caret
-
>
IsVisible
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
SetCaretVisibilityDuringSelection
(
bool
aVisibility
)
{
if
(
!
mPresShellWeak
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
;
RefPtr
<
PresShell
>
presShell
=
do_QueryReferent
(
mPresShellWeak
&
rv
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
{
return
NS_ERROR_FAILURE
;
}
Selection
*
selection
=
mFrameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
selection
)
{
caret
-
>
SetVisibilityDuringSelection
(
aVisibility
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
PhysicalMove
(
aDirection
aAmount
aExtend
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
CharacterMove
(
bool
aForward
bool
aExtend
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
CharacterMove
(
aForward
aExtend
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
WordMove
(
bool
aForward
bool
aExtend
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
WordMove
(
aForward
aExtend
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
LineMove
(
bool
aForward
bool
aExtend
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsresult
result
=
frameSelection
-
>
LineMove
(
aForward
aExtend
)
;
if
(
NS_FAILED
(
result
)
)
{
result
=
CompleteMove
(
aForward
aExtend
)
;
}
return
result
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
IntraLineMove
(
bool
aForward
bool
aExtend
)
{
if
(
!
mFrameSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
IntraLineMove
(
aForward
aExtend
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
PageMove
(
bool
aForward
bool
aExtend
)
{
if
(
mScrollFrame
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
mScrollFrame
)
;
return
frameSelection
-
>
PageMove
(
aForward
aExtend
scrollFrame
nsFrameSelection
:
:
SelectionIntoView
:
:
Yes
)
;
}
return
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
|
nsISelectionController
:
:
SCROLL_FOR_CARET_MOVE
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
CompleteScroll
(
bool
aForward
)
{
if
(
!
mScrollFrame
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
WHOLE
ScrollMode
:
:
Instant
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
CompleteMove
(
bool
aForward
bool
aExtend
)
{
if
(
NS_WARN_IF
(
!
mFrameSelection
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsIContent
*
parentDIV
=
frameSelection
-
>
GetLimiter
(
)
;
if
(
!
parentDIV
)
{
return
NS_ERROR_UNEXPECTED
;
}
int32_t
offset
=
0
;
CaretAssociationHint
hint
=
CARET_ASSOCIATE_BEFORE
;
if
(
aForward
)
{
offset
=
parentDIV
-
>
GetChildCount
(
)
;
if
(
offset
>
0
)
{
nsIContent
*
child
=
parentDIV
-
>
GetLastChild
(
)
;
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
-
-
offset
;
hint
=
CARET_ASSOCIATE_AFTER
;
}
}
}
const
RefPtr
<
nsIContent
>
pinnedParentDIV
{
parentDIV
}
;
const
nsFrameSelection
:
:
FocusMode
focusMode
=
aExtend
?
nsFrameSelection
:
:
FocusMode
:
:
kExtendSelection
:
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
;
frameSelection
-
>
HandleClick
(
pinnedParentDIV
offset
offset
focusMode
hint
)
;
return
CompleteScroll
(
aForward
)
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
ScrollPage
(
bool
aForward
)
{
if
(
!
mScrollFrame
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
PAGES
ScrollMode
:
:
Smooth
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
ScrollLine
(
bool
aForward
)
{
if
(
!
mScrollFrame
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
LINES
ScrollMode
:
:
Smooth
)
;
return
NS_OK
;
}
NS_IMETHODIMP
TextInputSelectionController
:
:
ScrollCharacter
(
bool
aRight
)
{
if
(
!
mScrollFrame
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
aRight
?
1
:
-
1
0
)
ScrollUnit
:
:
LINES
ScrollMode
:
:
Smooth
)
;
return
NS_OK
;
}
void
TextInputSelectionController
:
:
SelectionWillTakeFocus
(
)
{
if
(
mFrameSelection
)
{
if
(
PresShell
*
shell
=
mFrameSelection
-
>
GetPresShell
(
)
)
{
shell
-
>
FrameSelectionWillTakeFocus
(
*
mFrameSelection
)
;
}
}
}
void
TextInputSelectionController
:
:
SelectionWillLoseFocus
(
)
{
if
(
mFrameSelection
)
{
if
(
PresShell
*
shell
=
mFrameSelection
-
>
GetPresShell
(
)
)
{
shell
-
>
FrameSelectionWillLoseFocus
(
*
mFrameSelection
)
;
}
}
}
NS_IMETHODIMP
TextInputSelectionController
:
:
CheckVisibility
(
nsINode
*
node
int16_t
startOffset
int16_t
EndOffset
bool
*
_retval
)
{
if
(
!
mPresShellWeak
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsresult
rv
;
nsCOMPtr
<
nsISelectionController
>
presShell
=
do_QueryReferent
(
mPresShellWeak
&
rv
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
return
presShell
-
>
CheckVisibility
(
node
startOffset
EndOffset
_retval
)
;
}
nsresult
TextInputSelectionController
:
:
CheckVisibilityContent
(
nsIContent
*
aNode
int16_t
aStartOffset
int16_t
aEndOffset
bool
*
aRetval
)
{
if
(
!
mPresShellWeak
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsISelectionController
>
presShell
=
do_QueryReferent
(
mPresShellWeak
)
;
if
(
NS_WARN_IF
(
!
presShell
)
)
{
return
NS_ERROR_FAILURE
;
}
return
presShell
-
>
CheckVisibilityContent
(
aNode
aStartOffset
aEndOffset
aRetval
)
;
}
TextInputListener
:
:
TextInputListener
(
TextControlElement
*
aTxtCtrlElement
)
:
mFrame
(
nullptr
)
mTxtCtrlElement
(
aTxtCtrlElement
)
mTextControlState
(
aTxtCtrlElement
?
aTxtCtrlElement
-
>
GetTextControlState
(
)
:
nullptr
)
mSelectionWasCollapsed
(
true
)
mHadUndoItems
(
false
)
mHadRedoItems
(
false
)
mSettingValue
(
false
)
mSetValueChanged
(
true
)
mListeningToSelectionChange
(
false
)
{
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextInputListener
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextInputListener
)
NS_INTERFACE_MAP_BEGIN
(
TextInputListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
TextInputListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
TextInputListener
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
TextInputListener
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
TextInputListener
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
void
TextInputListener
:
:
OnSelectionChange
(
Selection
&
aSelection
int16_t
aReason
)
{
if
(
!
mListeningToSelectionChange
)
{
return
;
}
AutoWeakFrame
weakFrame
=
mFrame
;
bool
collapsed
=
aSelection
.
IsCollapsed
(
)
;
if
(
!
collapsed
&
&
(
aReason
&
(
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
)
)
)
{
if
(
nsCOMPtr
<
nsIContent
>
content
=
mFrame
-
>
GetContent
(
)
)
{
if
(
nsCOMPtr
<
Document
>
doc
=
content
-
>
GetComposedDoc
(
)
)
{
if
(
RefPtr
<
PresShell
>
presShell
=
doc
-
>
GetPresShell
(
)
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
eFormSelect
)
;
presShell
-
>
HandleEventWithTarget
(
&
event
mFrame
content
&
status
)
;
}
}
}
}
if
(
collapsed
=
=
mSelectionWasCollapsed
)
{
return
;
}
mSelectionWasCollapsed
=
collapsed
;
if
(
!
weakFrame
.
IsAlive
(
)
|
|
!
mFrame
|
|
!
nsContentUtils
:
:
IsFocusedContent
(
mFrame
-
>
GetContent
(
)
)
)
{
return
;
}
UpdateTextInputCommands
(
u
"
select
"
_ns
&
aSelection
aReason
)
;
}
MOZ_CAN_RUN_SCRIPT
static
void
DoCommandCallback
(
Command
aCommand
void
*
aData
)
{
nsTextControlFrame
*
frame
=
static_cast
<
nsTextControlFrame
*
>
(
aData
)
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
nsCOMPtr
<
nsIControllers
>
controllers
;
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
content
)
;
if
(
input
)
{
input
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
else
{
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
content
)
;
if
(
textArea
)
{
textArea
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
}
if
(
!
controllers
)
{
NS_WARNING
(
"
Could
not
get
controllers
"
)
;
return
;
}
const
char
*
commandStr
=
WidgetKeyboardEvent
:
:
GetCommandStr
(
aCommand
)
;
nsCOMPtr
<
nsIController
>
controller
;
controllers
-
>
GetControllerForCommand
(
commandStr
getter_AddRefs
(
controller
)
)
;
if
(
!
controller
)
{
return
;
}
bool
commandEnabled
;
if
(
NS_WARN_IF
(
NS_FAILED
(
controller
-
>
IsCommandEnabled
(
commandStr
&
commandEnabled
)
)
)
)
{
return
;
}
if
(
commandEnabled
)
{
controller
-
>
DoCommand
(
commandStr
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
TextInputListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
if
(
aEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
if
(
!
aEvent
-
>
IsTrusted
(
)
)
{
return
NS_OK
;
}
RefPtr
<
KeyboardEvent
>
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
if
(
!
keyEvent
)
{
return
NS_ERROR_UNEXPECTED
;
}
WidgetKeyboardEvent
*
widgetKeyEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
!
widgetKeyEvent
)
{
return
NS_ERROR_UNEXPECTED
;
}
{
auto
*
input
=
HTMLInputElement
:
:
FromNode
(
mTxtCtrlElement
)
;
if
(
input
&
&
input
-
>
StepsInputValue
(
*
widgetKeyEvent
)
)
{
return
NS_OK
;
}
}
auto
ExecuteOurShortcutKeys
=
[
&
]
(
TextControlElement
&
aTextControlElement
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
-
>
bool
{
KeyEventHandler
*
keyHandlers
=
ShortcutKeys
:
:
GetHandlers
(
aTextControlElement
.
IsTextArea
(
)
?
HandlerType
:
:
eTextArea
:
HandlerType
:
:
eInput
)
;
RefPtr
<
nsAtom
>
eventTypeAtom
=
ShortcutKeys
:
:
ConvertEventToDOMEventType
(
widgetKeyEvent
)
;
for
(
KeyEventHandler
*
handler
=
keyHandlers
;
handler
;
handler
=
handler
-
>
GetNextHandler
(
)
)
{
if
(
!
handler
-
>
EventTypeEquals
(
eventTypeAtom
)
)
{
continue
;
}
if
(
!
handler
-
>
KeyEventMatched
(
keyEvent
0
IgnoreModifierState
(
)
)
)
{
continue
;
}
nsresult
rv
=
handler
-
>
ExecuteHandler
(
&
aTextControlElement
aEvent
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
true
;
}
}
return
false
;
}
;
auto
ExecuteNativeKeyBindings
=
[
&
]
(
TextControlElement
&
aTextControlElement
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
-
>
bool
{
if
(
widgetKeyEvent
-
>
mMessage
!
=
eKeyPress
)
{
return
false
;
}
NativeKeyBindingsType
nativeKeyBindingsType
=
aTextControlElement
.
IsTextArea
(
)
?
NativeKeyBindingsType
:
:
MultiLineEditor
:
NativeKeyBindingsType
:
:
SingleLineEditor
;
nsIWidget
*
widget
=
widgetKeyEvent
-
>
mWidget
;
if
(
MOZ_UNLIKELY
(
!
widget
)
)
{
widget
=
mFrame
-
>
GetNearestWidget
(
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
widget
)
)
)
{
return
false
;
}
}
AutoRestore
<
nsCOMPtr
<
nsIWidget
>
>
saveWidget
(
widgetKeyEvent
-
>
mWidget
)
;
widgetKeyEvent
-
>
mWidget
=
widget
;
if
(
widgetKeyEvent
-
>
ExecuteEditCommands
(
nativeKeyBindingsType
DoCommandCallback
mFrame
)
)
{
aEvent
-
>
PreventDefault
(
)
;
return
true
;
}
return
false
;
}
;
OwningNonNull
<
TextControlElement
>
textControlElement
(
*
mTxtCtrlElement
)
;
if
(
StaticPrefs
:
:
ui_key_textcontrol_prefer_native_key_bindings_over_builtin_shortcut_key_definitions
(
)
)
{
if
(
!
ExecuteNativeKeyBindings
(
textControlElement
)
)
{
ExecuteOurShortcutKeys
(
textControlElement
)
;
}
}
else
{
if
(
!
ExecuteOurShortcutKeys
(
textControlElement
)
)
{
ExecuteNativeKeyBindings
(
textControlElement
)
;
}
}
return
NS_OK
;
}
nsresult
TextInputListener
:
:
OnEditActionHandled
(
TextEditor
&
aTextEditor
)
{
if
(
mFrame
)
{
AutoWeakFrame
weakFrame
=
mFrame
;
size_t
numUndoItems
=
aTextEditor
.
NumberOfUndoItems
(
)
;
size_t
numRedoItems
=
aTextEditor
.
NumberOfRedoItems
(
)
;
if
(
(
numUndoItems
&
&
!
mHadUndoItems
)
|
|
(
!
numUndoItems
&
&
mHadUndoItems
)
|
|
(
numRedoItems
&
&
!
mHadRedoItems
)
|
|
(
!
numRedoItems
&
&
mHadRedoItems
)
)
{
UpdateTextInputCommands
(
u
"
undo
"
_ns
)
;
mHadUndoItems
=
numUndoItems
!
=
0
;
mHadRedoItems
=
numRedoItems
!
=
0
;
}
if
(
weakFrame
.
IsAlive
(
)
)
{
HandleValueChanged
(
)
;
}
}
return
mTextControlState
?
mTextControlState
-
>
OnEditActionHandled
(
)
:
NS_OK
;
}
void
TextInputListener
:
:
HandleValueChanged
(
)
{
if
(
mSetValueChanged
)
{
mTxtCtrlElement
-
>
SetValueChanged
(
true
)
;
}
if
(
!
mSettingValue
)
{
mTxtCtrlElement
-
>
OnValueChanged
(
ValueChangeKind
:
:
UserInteraction
)
;
if
(
mTextControlState
)
{
mTextControlState
-
>
ClearLastInteractiveValue
(
)
;
}
}
}
nsresult
TextInputListener
:
:
UpdateTextInputCommands
(
const
nsAString
&
aCommandsToUpdate
Selection
*
aSelection
int16_t
aReason
)
{
nsIContent
*
content
=
mFrame
-
>
GetContent
(
)
;
if
(
NS_WARN_IF
(
!
content
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
Document
>
doc
=
content
-
>
GetComposedDoc
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
nsPIDOMWindowOuter
*
domWindow
=
doc
-
>
GetWindow
(
)
;
if
(
NS_WARN_IF
(
!
domWindow
)
)
{
return
NS_ERROR_FAILURE
;
}
domWindow
-
>
UpdateCommands
(
aCommandsToUpdate
aSelection
aReason
)
;
return
NS_OK
;
}
enum
class
TextControlAction
{
CommitComposition
Destructor
PrepareEditor
SetRangeText
SetSelectionRange
SetValue
UnbindFromFrame
Unlink
}
;
class
MOZ_STACK_CLASS
AutoTextControlHandlingState
{
public
:
AutoTextControlHandlingState
(
)
=
delete
;
explicit
AutoTextControlHandlingState
(
const
AutoTextControlHandlingState
&
)
=
delete
;
AutoTextControlHandlingState
(
AutoTextControlHandlingState
&
&
)
=
delete
;
void
operator
=
(
AutoTextControlHandlingState
&
)
=
delete
;
void
operator
=
(
const
AutoTextControlHandlingState
&
)
=
delete
;
MOZ_CAN_RUN_SCRIPT
AutoTextControlHandlingState
(
TextControlState
&
aTextControlState
TextControlAction
aTextControlAction
)
:
mParent
(
aTextControlState
.
mHandlingState
)
mTextControlState
(
aTextControlState
)
mTextCtrlElement
(
aTextControlState
.
mTextCtrlElement
)
mTextInputListener
(
aTextControlState
.
mTextListener
)
mTextControlAction
(
aTextControlAction
)
{
MOZ_ASSERT
(
aTextControlAction
!
=
TextControlAction
:
:
SetValue
"
Use
specific
constructor
"
)
;
mTextControlState
.
mHandlingState
=
this
;
if
(
Is
(
TextControlAction
:
:
CommitComposition
)
)
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mParent
-
>
Is
(
TextControlAction
:
:
SetValue
)
)
;
mParent
-
>
InvalidateOldValue
(
)
;
}
}
MOZ_CAN_RUN_SCRIPT
AutoTextControlHandlingState
(
TextControlState
&
aTextControlState
TextControlAction
aTextControlAction
const
nsAString
&
aSettingValue
const
nsAString
*
aOldValue
const
ValueSetterOptions
&
aOptions
ErrorResult
&
aRv
)
:
mParent
(
aTextControlState
.
mHandlingState
)
mTextControlState
(
aTextControlState
)
mTextCtrlElement
(
aTextControlState
.
mTextCtrlElement
)
mTextInputListener
(
aTextControlState
.
mTextListener
)
mSettingValue
(
aSettingValue
)
mOldValue
(
aOldValue
)
mValueSetterOptions
(
aOptions
)
mTextControlAction
(
aTextControlAction
)
{
MOZ_ASSERT
(
aTextControlAction
=
=
TextControlAction
:
:
SetValue
"
Use
generic
constructor
"
)
;
mTextControlState
.
mHandlingState
=
this
;
if
(
!
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
mSettingValue
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
mParent
)
{
mParent
-
>
UpdateSettingValueAndInvalidateOldValue
(
mSettingValue
)
;
}
}
MOZ_CAN_RUN_SCRIPT
~
AutoTextControlHandlingState
(
)
{
mTextControlState
.
mHandlingState
=
mParent
;
if
(
!
mParent
&
&
mTextControlStateDestroyed
)
{
mTextControlState
.
DeleteOrCacheForReuse
(
)
;
}
if
(
!
mTextControlStateDestroyed
&
&
mPreareEditorLater
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
mTextControlState
.
PrepareEditor
(
)
;
}
}
void
OnDestroyTextControlState
(
)
{
if
(
IsHandling
(
TextControlAction
:
:
Destructor
)
)
{
return
;
}
mTextControlStateDestroyed
=
true
;
if
(
mParent
)
{
mParent
-
>
OnDestroyTextControlState
(
)
;
}
}
void
PrepareEditorLater
(
)
{
MOZ_ASSERT
(
IsHandling
(
TextControlAction
:
:
SetValue
)
)
;
MOZ_ASSERT
(
!
IsHandling
(
TextControlAction
:
:
PrepareEditor
)
)
;
AutoTextControlHandlingState
*
settingValue
=
nullptr
;
for
(
AutoTextControlHandlingState
*
handlingSomething
=
this
;
handlingSomething
;
handlingSomething
=
handlingSomething
-
>
mParent
)
{
if
(
handlingSomething
-
>
Is
(
TextControlAction
:
:
SetValue
)
)
{
settingValue
=
handlingSomething
;
}
}
settingValue
-
>
mPreareEditorLater
=
true
;
}
void
WillSetValueWithTextEditor
(
)
{
MOZ_ASSERT
(
Is
(
TextControlAction
:
:
SetValue
)
)
;
MOZ_ASSERT
(
mTextControlState
.
mBoundFrame
)
;
mTextControlFrame
=
mTextControlState
.
mBoundFrame
;
if
(
mValueSetterOptions
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
)
{
return
;
}
mTextInputListener
-
>
SettingValue
(
true
)
;
mTextInputListener
-
>
SetValueChanged
(
mValueSetterOptions
.
contains
(
ValueSetterOption
:
:
SetValueChanged
)
)
;
mEditActionHandled
=
false
;
WillDispatchBeforeInputEvent
(
)
;
}
void
WillDispatchBeforeInputEvent
(
)
{
mBeforeInputEventHasBeenDispatched
=
true
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
OnEditActionHandled
(
)
{
MOZ_ASSERT
(
!
mEditActionHandled
)
;
mEditActionHandled
=
true
;
if
(
!
Is
(
TextControlAction
:
:
SetValue
)
)
{
return
NS_OK
;
}
if
(
!
mValueSetterOptions
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
)
{
mTextInputListener
-
>
SetValueChanged
(
true
)
;
mTextInputListener
-
>
SettingValue
(
mParent
&
&
mParent
-
>
IsHandling
(
TextControlAction
:
:
SetValue
)
)
;
}
if
(
!
IsOriginalTextControlFrameAlive
(
)
)
{
return
SetValueWithoutTextEditorAgain
(
)
?
NS_OK
:
NS_ERROR_OUT_OF_MEMORY
;
}
nsITextControlFrame
*
textControlFrame
=
do_QueryFrame
(
mTextControlFrame
.
GetFrame
(
)
)
;
return
static_cast
<
nsTextControlFrame
*
>
(
textControlFrame
)
-
>
CacheValue
(
mSettingValue
fallible
)
?
NS_OK
:
NS_ERROR_OUT_OF_MEMORY
;
}
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
bool
SetValueWithoutTextEditorAgain
(
)
{
MOZ_ASSERT
(
!
IsOriginalTextControlFrameAlive
(
)
)
;
if
(
mTextControlState
.
mBoundFrame
)
{
return
true
;
}
ErrorResult
error
;
AutoTextControlHandlingState
handlingSetValueWithoutEditor
(
mTextControlState
TextControlAction
:
:
SetValue
mSettingValue
mOldValue
mValueSetterOptions
&
ValueSetterOption
:
:
SetValueChanged
error
)
;
if
(
error
.
Failed
(
)
)
{
MOZ_ASSERT
(
error
.
ErrorCodeIs
(
NS_ERROR_OUT_OF_MEMORY
)
)
;
error
.
SuppressException
(
)
;
return
false
;
}
return
mTextControlState
.
SetValueWithoutTextEditor
(
handlingSetValueWithoutEditor
)
;
}
bool
IsTextControlStateDestroyed
(
)
const
{
return
mTextControlStateDestroyed
;
}
bool
IsOriginalTextControlFrameAlive
(
)
const
{
return
const_cast
<
AutoTextControlHandlingState
*
>
(
this
)
-
>
mTextControlFrame
.
IsAlive
(
)
;
}
bool
HasEditActionHandled
(
)
const
{
return
mEditActionHandled
;
}
bool
HasBeforeInputEventDispatched
(
)
const
{
return
mBeforeInputEventHasBeenDispatched
;
}
bool
Is
(
TextControlAction
aTextControlAction
)
const
{
return
mTextControlAction
=
=
aTextControlAction
;
}
bool
IsHandling
(
TextControlAction
aTextControlAction
)
const
{
if
(
mTextControlAction
=
=
aTextControlAction
)
{
return
true
;
}
return
mParent
?
mParent
-
>
IsHandling
(
aTextControlAction
)
:
false
;
}
TextControlElement
*
GetTextControlElement
(
)
const
{
return
mTextCtrlElement
;
}
TextInputListener
*
GetTextInputListener
(
)
const
{
return
mTextInputListener
;
}
const
ValueSetterOptions
&
ValueSetterOptionsRef
(
)
const
{
MOZ_ASSERT
(
Is
(
TextControlAction
:
:
SetValue
)
)
;
return
mValueSetterOptions
;
}
const
nsAString
*
GetOldValue
(
)
const
{
MOZ_ASSERT
(
Is
(
TextControlAction
:
:
SetValue
)
)
;
return
mOldValue
;
}
const
nsString
&
GetSettingValue
(
)
const
{
MOZ_ASSERT
(
IsHandling
(
TextControlAction
:
:
SetValue
)
)
;
if
(
mTextControlAction
=
=
TextControlAction
:
:
SetValue
)
{
return
mSettingValue
;
}
return
mParent
-
>
GetSettingValue
(
)
;
}
private
:
void
UpdateSettingValueAndInvalidateOldValue
(
const
nsString
&
aSettingValue
)
{
if
(
mTextControlAction
=
=
TextControlAction
:
:
SetValue
)
{
mSettingValue
=
aSettingValue
;
}
mOldValue
=
nullptr
;
if
(
mParent
)
{
mParent
-
>
UpdateSettingValueAndInvalidateOldValue
(
aSettingValue
)
;
}
}
void
InvalidateOldValue
(
)
{
mOldValue
=
nullptr
;
if
(
mParent
)
{
mParent
-
>
InvalidateOldValue
(
)
;
}
}
AutoTextControlHandlingState
*
const
mParent
;
TextControlState
&
mTextControlState
;
AutoWeakFrame
mTextControlFrame
;
RefPtr
<
TextControlElement
>
const
mTextCtrlElement
;
RefPtr
<
TextInputListener
>
const
mTextInputListener
;
nsString
mSettingValue
;
const
nsAString
*
mOldValue
=
nullptr
;
ValueSetterOptions
mValueSetterOptions
;
TextControlAction
const
mTextControlAction
;
bool
mTextControlStateDestroyed
=
false
;
bool
mEditActionHandled
=
false
;
bool
mPreareEditorLater
=
false
;
bool
mBeforeInputEventHasBeenDispatched
=
false
;
}
;
static
constexpr
size_t
kMaxCountOfCacheToReuse
=
25
;
static
AutoTArray
<
void
*
kMaxCountOfCacheToReuse
>
*
sReleasedInstances
=
nullptr
;
static
bool
sHasShutDown
=
false
;
TextControlState
:
:
TextControlState
(
TextControlElement
*
aOwningElement
)
:
mTextCtrlElement
(
aOwningElement
)
mEverInited
(
false
)
mEditorInitialized
(
false
)
mValueTransferInProgress
(
false
)
mSelectionCached
(
true
)
{
MOZ_COUNT_CTOR
(
TextControlState
)
;
static_assert
(
sizeof
(
*
this
)
<
=
128
"
Please
keep
small
TextControlState
as
far
as
possible
"
)
;
}
TextControlState
*
TextControlState
:
:
Construct
(
TextControlElement
*
aOwningElement
)
{
void
*
mem
;
if
(
sReleasedInstances
&
&
!
sReleasedInstances
-
>
IsEmpty
(
)
)
{
mem
=
sReleasedInstances
-
>
PopLastElement
(
)
;
}
else
{
mem
=
moz_xmalloc
(
sizeof
(
TextControlState
)
)
;
}
return
new
(
mem
)
TextControlState
(
aOwningElement
)
;
}
TextControlState
:
:
~
TextControlState
(
)
{
MOZ_ASSERT
(
!
mHandlingState
)
;
MOZ_COUNT_DTOR
(
TextControlState
)
;
AutoTextControlHandlingState
handlingDesctructor
(
*
this
TextControlAction
:
:
Destructor
)
;
Clear
(
)
;
}
void
TextControlState
:
:
Shutdown
(
)
{
sHasShutDown
=
true
;
if
(
sReleasedInstances
)
{
for
(
void
*
mem
:
*
sReleasedInstances
)
{
free
(
mem
)
;
}
delete
sReleasedInstances
;
}
}
void
TextControlState
:
:
Destroy
(
)
{
if
(
mHandlingState
)
{
mHandlingState
-
>
OnDestroyTextControlState
(
)
;
return
;
}
DeleteOrCacheForReuse
(
)
;
}
void
TextControlState
:
:
DeleteOrCacheForReuse
(
)
{
MOZ_ASSERT
(
!
IsBusy
(
)
)
;
void
*
mem
=
this
;
this
-
>
~
TextControlState
(
)
;
if
(
!
sHasShutDown
&
&
(
!
sReleasedInstances
|
|
sReleasedInstances
-
>
Length
(
)
<
kMaxCountOfCacheToReuse
)
)
{
if
(
!
sReleasedInstances
)
{
sReleasedInstances
=
new
AutoTArray
<
void
*
kMaxCountOfCacheToReuse
>
;
}
sReleasedInstances
-
>
AppendElement
(
mem
)
;
}
else
{
free
(
mem
)
;
}
}
nsresult
TextControlState
:
:
OnEditActionHandled
(
)
{
return
mHandlingState
?
mHandlingState
-
>
OnEditActionHandled
(
)
:
NS_OK
;
}
Element
*
TextControlState
:
:
GetRootNode
(
)
{
return
mBoundFrame
?
mBoundFrame
-
>
GetRootNode
(
)
:
nullptr
;
}
Element
*
TextControlState
:
:
GetPreviewNode
(
)
{
return
mBoundFrame
?
mBoundFrame
-
>
GetPreviewNode
(
)
:
nullptr
;
}
void
TextControlState
:
:
Clear
(
)
{
MOZ_ASSERT
(
mHandlingState
)
;
MOZ_ASSERT
(
mHandlingState
-
>
Is
(
TextControlAction
:
:
Destructor
)
|
|
mHandlingState
-
>
Is
(
TextControlAction
:
:
Unlink
)
)
;
if
(
mTextEditor
)
{
mTextEditor
-
>
SetTextInputListener
(
nullptr
)
;
}
if
(
mBoundFrame
)
{
UnbindFromFrame
(
mBoundFrame
)
;
mTextEditor
=
nullptr
;
}
else
{
DestroyEditor
(
)
;
}
mTextListener
=
nullptr
;
}
void
TextControlState
:
:
Unlink
(
)
{
AutoTextControlHandlingState
handlingUnlink
(
*
this
TextControlAction
:
:
Unlink
)
;
UnlinkInternal
(
)
;
}
void
TextControlState
:
:
UnlinkInternal
(
)
{
MOZ_ASSERT
(
mHandlingState
)
;
MOZ_ASSERT
(
mHandlingState
-
>
Is
(
TextControlAction
:
:
Unlink
)
)
;
TextControlState
*
tmp
=
this
;
tmp
-
>
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelCon
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTextEditor
)
}
void
TextControlState
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
{
TextControlState
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelCon
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTextEditor
)
}
nsFrameSelection
*
TextControlState
:
:
GetConstFrameSelection
(
)
{
return
mSelCon
?
mSelCon
-
>
GetConstFrameSelection
(
)
:
nullptr
;
}
TextEditor
*
TextControlState
:
:
GetTextEditor
(
)
{
if
(
!
mTextEditor
&
&
NS_WARN_IF
(
NS_FAILED
(
PrepareEditor
(
)
)
)
)
{
return
nullptr
;
}
return
mTextEditor
;
}
TextEditor
*
TextControlState
:
:
GetTextEditorWithoutCreation
(
)
{
return
mTextEditor
;
}
nsISelectionController
*
TextControlState
:
:
GetSelectionController
(
)
const
{
return
mSelCon
;
}
class
PrepareEditorEvent
:
public
Runnable
{
public
:
PrepareEditorEvent
(
TextControlState
&
aState
nsIContent
*
aOwnerContent
const
nsAString
&
aCurrentValue
)
:
Runnable
(
"
PrepareEditorEvent
"
)
mState
(
&
aState
)
mOwnerContent
(
aOwnerContent
)
mCurrentValue
(
aCurrentValue
)
{
aState
.
mValueTransferInProgress
=
true
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
NS_WARN_IF
(
!
mState
)
)
{
return
NS_ERROR_NULL_POINTER
;
}
const
nsAString
*
value
=
nullptr
;
if
(
!
mCurrentValue
.
IsEmpty
(
)
)
{
value
=
&
mCurrentValue
;
}
nsAutoScriptBlocker
scriptBlocker
;
mState
-
>
PrepareEditor
(
value
)
;
mState
-
>
mValueTransferInProgress
=
false
;
return
NS_OK
;
}
private
:
WeakPtr
<
TextControlState
>
mState
;
nsCOMPtr
<
nsIContent
>
mOwnerContent
;
nsAutoString
mCurrentValue
;
}
;
nsresult
TextControlState
:
:
BindToFrame
(
nsTextControlFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
TextControlState
:
:
BindToFrame
(
)
has
to
be
called
with
script
blocker
"
)
;
NS_ASSERTION
(
aFrame
"
The
frame
to
bind
to
should
be
valid
"
)
;
if
(
!
aFrame
)
{
return
NS_ERROR_INVALID_ARG
;
}
NS_ASSERTION
(
!
mBoundFrame
"
Cannot
bind
twice
need
to
unbind
first
"
)
;
if
(
mBoundFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoString
currentValue
;
if
(
mTextEditor
)
{
GetValue
(
currentValue
true
)
;
}
mBoundFrame
=
aFrame
;
Element
*
rootNode
=
aFrame
-
>
GetRootNode
(
)
;
MOZ_ASSERT
(
rootNode
)
;
PresShell
*
presShell
=
aFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
presShell
)
;
mSelCon
=
new
TextInputSelectionController
(
presShell
rootNode
)
;
MOZ_ASSERT
(
!
mTextListener
"
Should
not
overwrite
the
object
"
)
;
mTextListener
=
new
TextInputListener
(
mTextCtrlElement
)
;
mTextListener
-
>
SetFrame
(
mBoundFrame
)
;
mSelCon
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
Selection
*
selection
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
selection
)
{
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
caret
)
{
selection
-
>
AddSelectionListener
(
caret
)
;
}
mTextListener
-
>
StartToListenToSelectionChange
(
)
;
}
if
(
mTextEditor
)
{
if
(
NS_WARN_IF
(
!
mTextCtrlElement
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mTextEditor
-
>
IsRightToLeft
(
)
)
{
rootNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
u
"
rtl
"
_ns
false
)
;
}
else
if
(
mTextEditor
-
>
IsLeftToRight
(
)
)
{
rootNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
u
"
ltr
"
_ns
false
)
;
}
else
{
}
nsContentUtils
:
:
AddScriptRunner
(
new
PrepareEditorEvent
(
*
this
mTextCtrlElement
currentValue
)
)
;
}
return
NS_OK
;
}
struct
MOZ_STACK_CLASS
PreDestroyer
{
void
Init
(
TextEditor
*
aTextEditor
)
{
mTextEditor
=
aTextEditor
;
}
~
PreDestroyer
(
)
{
if
(
mTextEditor
)
{
UniquePtr
<
PasswordMaskData
>
passwordMaskData
=
mTextEditor
-
>
PreDestroy
(
)
;
}
}
void
Swap
(
RefPtr
<
TextEditor
>
&
aTextEditor
)
{
return
mTextEditor
.
swap
(
aTextEditor
)
;
}
private
:
RefPtr
<
TextEditor
>
mTextEditor
;
}
;
nsresult
TextControlState
:
:
PrepareEditor
(
const
nsAString
*
aValue
)
{
if
(
!
mBoundFrame
)
{
return
NS_OK
;
}
if
(
mEditorInitialized
)
{
return
NS_OK
;
}
AutoHideSelectionChanges
hideSelectionChanges
(
GetConstFrameSelection
(
)
)
;
if
(
mHandlingState
)
{
if
(
mHandlingState
-
>
IsHandling
(
TextControlAction
:
:
PrepareEditor
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
mHandlingState
-
>
IsHandling
(
TextControlAction
:
:
SetValue
)
)
{
mHandlingState
-
>
PrepareEditorLater
(
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
}
MOZ_ASSERT
(
mTextCtrlElement
)
;
AutoTextControlHandlingState
preparingEditor
(
*
this
TextControlAction
:
:
PrepareEditor
)
;
nsPresContext
*
presContext
=
mBoundFrame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
GetPresShell
(
)
;
uint32_t
editorFlags
=
nsIEditor
:
:
eEditorPlaintextMask
;
if
(
IsSingleLineTextControl
(
)
)
{
editorFlags
|
=
nsIEditor
:
:
eEditorSingleLineMask
;
}
if
(
IsPasswordTextControl
(
)
)
{
editorFlags
|
=
nsIEditor
:
:
eEditorPasswordMask
;
}
editorFlags
|
=
nsIEditor
:
:
eEditorSkipSpellCheck
;
bool
shouldInitializeEditor
=
false
;
RefPtr
<
TextEditor
>
newTextEditor
;
PreDestroyer
preDestroyer
;
if
(
!
mTextEditor
)
{
shouldInitializeEditor
=
true
;
newTextEditor
=
new
TextEditor
(
)
;
preDestroyer
.
Init
(
newTextEditor
)
;
nsresult
rv
=
mBoundFrame
-
>
UpdateValueDisplay
(
true
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsTextControlFrame
:
:
UpdateValueDisplay
(
)
failed
"
)
;
return
rv
;
}
}
else
{
if
(
aValue
|
|
!
mEditorInitialized
)
{
nsresult
rv
=
mBoundFrame
-
>
UpdateValueDisplay
(
true
!
mEditorInitialized
aValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsTextControlFrame
:
:
UpdateValueDisplay
(
)
failed
"
)
;
return
rv
;
}
}
newTextEditor
=
mTextEditor
;
if
(
newTextEditor
-
>
IsMailEditor
(
)
)
{
editorFlags
|
=
nsIEditor
:
:
eEditorMailMask
;
}
}
nsAutoString
defaultValue
;
if
(
aValue
)
{
defaultValue
=
*
aValue
;
}
else
{
GetValue
(
defaultValue
true
)
;
}
if
(
!
mEditorInitialized
)
{
nsCOMPtr
<
Document
>
doc
=
presShell
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoNoJSAPI
nojsapi
;
RefPtr
<
Element
>
anonymousDivElement
=
GetRootNode
(
)
;
if
(
NS_WARN_IF
(
!
anonymousDivElement
)
|
|
NS_WARN_IF
(
!
mSelCon
)
)
{
return
NS_ERROR_FAILURE
;
}
OwningNonNull
<
TextInputSelectionController
>
selectionController
(
*
mSelCon
)
;
UniquePtr
<
PasswordMaskData
>
passwordMaskData
;
if
(
editorFlags
&
nsIEditor
:
:
eEditorPasswordMask
)
{
if
(
mPasswordMaskData
)
{
passwordMaskData
=
std
:
:
move
(
mPasswordMaskData
)
;
}
else
{
passwordMaskData
=
MakeUnique
<
PasswordMaskData
>
(
)
;
}
}
else
{
mPasswordMaskData
=
nullptr
;
}
nsresult
rv
=
newTextEditor
-
>
Init
(
*
doc
*
anonymousDivElement
selectionController
editorFlags
std
:
:
move
(
passwordMaskData
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextEditor
:
:
Init
(
)
failed
"
)
;
return
rv
;
}
}
nsresult
rv
=
NS_OK
;
if
(
!
SuppressEventHandlers
(
presContext
)
)
{
nsCOMPtr
<
nsIControllers
>
controllers
;
if
(
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNodeOrNull
(
mTextCtrlElement
)
)
{
nsresult
rv
=
inputElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
else
{
HTMLTextAreaElement
*
textAreaElement
=
HTMLTextAreaElement
:
:
FromNodeOrNull
(
mTextCtrlElement
)
;
if
(
!
textAreaElement
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
textAreaElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
controllers
)
{
uint32_t
numControllers
;
bool
found
=
false
;
rv
=
controllers
-
>
GetControllerCount
(
&
numControllers
)
;
for
(
uint32_t
i
=
0
;
i
<
numControllers
;
i
+
+
)
{
nsCOMPtr
<
nsIController
>
controller
;
rv
=
controllers
-
>
GetControllerAt
(
i
getter_AddRefs
(
controller
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
controller
)
{
nsCOMPtr
<
nsIControllerContext
>
editController
=
do_QueryInterface
(
controller
)
;
if
(
editController
)
{
editController
-
>
SetCommandContext
(
static_cast
<
nsIEditor
*
>
(
newTextEditor
)
)
;
found
=
true
;
}
}
}
if
(
!
found
)
{
rv
=
NS_ERROR_FAILURE
;
}
}
}
if
(
shouldInitializeEditor
)
{
const
int32_t
wrapCols
=
GetWrapCols
(
)
;
MOZ_ASSERT
(
wrapCols
>
=
0
)
;
newTextEditor
-
>
SetWrapColumn
(
wrapCols
)
;
}
newTextEditor
-
>
SetMaxTextLength
(
mTextCtrlElement
-
>
UsedMaxLength
(
)
)
;
editorFlags
=
newTextEditor
-
>
Flags
(
)
;
if
(
mTextCtrlElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
|
|
mTextCtrlElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
)
)
{
editorFlags
|
=
nsIEditor
:
:
eEditorReadonlyMask
;
}
SetEditorFlagsIfNecessary
(
*
newTextEditor
editorFlags
)
;
if
(
shouldInitializeEditor
)
{
preDestroyer
.
Swap
(
mTextEditor
)
;
}
if
(
!
defaultValue
.
IsEmpty
(
)
)
{
rv
=
SetEditorFlagsIfNecessary
(
*
newTextEditor
editorFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
SetValue
(
defaultValue
ValueSetterOption
:
:
ByInternalAPI
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
rv
=
SetEditorFlagsIfNecessary
(
*
newTextEditor
editorFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
IsPasswordTextControl
(
)
)
{
DebugOnly
<
bool
>
disabledUndoRedo
=
newTextEditor
-
>
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transaction
"
)
;
}
else
{
DebugOnly
<
bool
>
enabledUndoRedo
=
newTextEditor
-
>
EnableUndoRedo
(
TextControlElement
:
:
DEFAULT_UNDO_CAP
)
;
NS_WARNING_ASSERTION
(
enabledUndoRedo
"
Failed
to
enable
undo
/
redo
transaction
"
)
;
}
if
(
!
mEditorInitialized
)
{
newTextEditor
-
>
PostCreate
(
)
;
mEverInited
=
true
;
mEditorInitialized
=
true
;
}
if
(
mTextListener
)
{
newTextEditor
-
>
SetTextInputListener
(
mTextListener
)
;
}
if
(
mSelectionCached
)
{
if
(
mRestoringSelection
)
{
mRestoringSelection
-
>
Revoke
(
)
;
}
mRestoringSelection
=
new
RestoreSelectionState
(
this
mBoundFrame
)
;
if
(
mRestoringSelection
)
{
nsContentUtils
:
:
AddScriptRunner
(
mRestoringSelection
)
;
}
}
mSelectionCached
=
false
;
return
preparingEditor
.
IsTextControlStateDestroyed
(
)
?
NS_ERROR_NOT_INITIALIZED
:
rv
;
}
void
TextControlState
:
:
FinishedRestoringSelection
(
)
{
mRestoringSelection
=
nullptr
;
}
void
TextControlState
:
:
SyncUpSelectionPropertiesBeforeDestruction
(
)
{
if
(
mBoundFrame
)
{
UnbindFromFrame
(
mBoundFrame
)
;
}
}
void
TextControlState
:
:
SetSelectionProperties
(
TextControlState
:
:
SelectionProperties
&
aProps
)
{
if
(
mBoundFrame
)
{
mBoundFrame
-
>
SetSelectionRange
(
aProps
.
GetStart
(
)
aProps
.
GetEnd
(
)
aProps
.
GetDirection
(
)
)
;
}
else
{
mSelectionProperties
=
aProps
;
}
}
void
TextControlState
:
:
GetSelectionRange
(
uint32_t
*
aSelectionStart
uint32_t
*
aSelectionEnd
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aSelectionStart
)
;
MOZ_ASSERT
(
aSelectionEnd
)
;
MOZ_ASSERT
(
IsSelectionCached
(
)
|
|
GetSelectionController
(
)
"
How
can
we
not
have
a
cached
selection
if
we
have
no
selection
"
"
controller
?
"
)
;
if
(
IsSelectionCached
(
)
)
{
const
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
*
aSelectionStart
=
props
.
GetStart
(
)
;
*
aSelectionEnd
=
props
.
GetEnd
(
)
;
return
;
}
Selection
*
sel
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
NS_WARN_IF
(
!
sel
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Element
*
root
=
GetRootNode
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
nsContentUtils
:
:
GetSelectionInTextControl
(
sel
root
*
aSelectionStart
*
aSelectionEnd
)
;
}
SelectionDirection
TextControlState
:
:
GetSelectionDirection
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsSelectionCached
(
)
|
|
GetSelectionController
(
)
"
How
can
we
not
have
a
cached
selection
if
we
have
no
selection
"
"
controller
?
"
)
;
if
(
IsSelectionCached
(
)
)
{
return
GetSelectionProperties
(
)
.
GetDirection
(
)
;
}
Selection
*
sel
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
NS_WARN_IF
(
!
sel
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
SelectionDirection
:
:
Forward
;
}
nsDirection
direction
=
sel
-
>
GetDirection
(
)
;
if
(
direction
=
=
eDirNext
)
{
return
SelectionDirection
:
:
Forward
;
}
MOZ_ASSERT
(
direction
=
=
eDirPrevious
)
;
return
SelectionDirection
:
:
Backward
;
}
void
TextControlState
:
:
SetSelectionRange
(
uint32_t
aStart
uint32_t
aEnd
SelectionDirection
aDirection
ErrorResult
&
aRv
ScrollAfterSelection
aScroll
)
{
MOZ_ASSERT
(
IsSelectionCached
(
)
|
|
mBoundFrame
"
How
can
we
have
a
non
-
cached
selection
but
no
frame
?
"
)
;
AutoTextControlHandlingState
handlingSetSelectionRange
(
*
this
TextControlAction
:
:
SetSelectionRange
)
;
if
(
aStart
>
aEnd
)
{
aStart
=
aEnd
;
}
if
(
!
IsSelectionCached
(
)
)
{
MOZ_ASSERT
(
mBoundFrame
"
Our
frame
should
still
be
valid
"
)
;
aRv
=
mBoundFrame
-
>
SetSelectionRange
(
aStart
aEnd
aDirection
)
;
if
(
aRv
.
Failed
(
)
|
|
handlingSetSelectionRange
.
IsTextControlStateDestroyed
(
)
)
{
return
;
}
if
(
aScroll
=
=
ScrollAfterSelection
:
:
Yes
&
&
mBoundFrame
)
{
mBoundFrame
-
>
ScrollSelectionIntoViewAsync
(
)
;
}
return
;
}
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
if
(
!
props
.
HasMaxLength
(
)
)
{
nsAutoString
value
;
GetValue
(
value
false
)
;
props
.
SetMaxLength
(
value
.
Length
(
)
)
;
}
bool
changed
=
props
.
SetStart
(
aStart
)
;
changed
|
=
props
.
SetEnd
(
aEnd
)
;
changed
|
=
props
.
SetDirection
(
aDirection
)
;
if
(
!
changed
)
{
return
;
}
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
mTextCtrlElement
eFormSelect
CanBubble
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
if
(
IsSelectionCached
(
)
&
&
StaticPrefs
:
:
dom_select_events_textcontrols_selectionchange_enabled
(
)
)
{
asyncDispatcher
=
new
AsyncEventDispatcher
(
mTextCtrlElement
eSelectionChange
CanBubble
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
void
TextControlState
:
:
SetSelectionStart
(
const
Nullable
<
uint32_t
>
&
aStart
ErrorResult
&
aRv
)
{
uint32_t
start
=
0
;
if
(
!
aStart
.
IsNull
(
)
)
{
start
=
aStart
.
Value
(
)
;
}
uint32_t
ignored
end
;
GetSelectionRange
(
&
ignored
&
end
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SelectionDirection
dir
=
GetSelectionDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
end
<
start
)
{
end
=
start
;
}
SetSelectionRange
(
start
end
dir
aRv
)
;
}
void
TextControlState
:
:
SetSelectionEnd
(
const
Nullable
<
uint32_t
>
&
aEnd
ErrorResult
&
aRv
)
{
uint32_t
end
=
0
;
if
(
!
aEnd
.
IsNull
(
)
)
{
end
=
aEnd
.
Value
(
)
;
}
uint32_t
start
ignored
;
GetSelectionRange
(
&
start
&
ignored
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SelectionDirection
dir
=
GetSelectionDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetSelectionRange
(
start
end
dir
aRv
)
;
}
static
void
DirectionToName
(
SelectionDirection
dir
nsAString
&
aDirection
)
{
switch
(
dir
)
{
case
SelectionDirection
:
:
None
:
NS_WARNING
(
"
We
don
'
t
actually
support
this
.
.
.
how
did
we
get
it
?
"
)
;
return
aDirection
.
AssignLiteral
(
"
none
"
)
;
case
SelectionDirection
:
:
Forward
:
return
aDirection
.
AssignLiteral
(
"
forward
"
)
;
case
SelectionDirection
:
:
Backward
:
return
aDirection
.
AssignLiteral
(
"
backward
"
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
SelectionDirection
value
"
)
;
}
void
TextControlState
:
:
GetSelectionDirectionString
(
nsAString
&
aDirection
ErrorResult
&
aRv
)
{
SelectionDirection
dir
=
GetSelectionDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
DirectionToName
(
dir
aDirection
)
;
}
static
SelectionDirection
DirectionStringToSelectionDirection
(
const
nsAString
&
aDirection
)
{
if
(
aDirection
.
EqualsLiteral
(
"
backward
"
)
)
{
return
SelectionDirection
:
:
Backward
;
}
return
SelectionDirection
:
:
Forward
;
}
void
TextControlState
:
:
SetSelectionDirection
(
const
nsAString
&
aDirection
ErrorResult
&
aRv
)
{
SelectionDirection
dir
=
DirectionStringToSelectionDirection
(
aDirection
)
;
uint32_t
start
end
;
GetSelectionRange
(
&
start
&
end
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetSelectionRange
(
start
end
dir
aRv
)
;
}
static
SelectionDirection
DirectionStringToSelectionDirection
(
const
Optional
<
nsAString
>
&
aDirection
)
{
if
(
!
aDirection
.
WasPassed
(
)
)
{
return
SelectionDirection
:
:
Forward
;
}
return
DirectionStringToSelectionDirection
(
aDirection
.
Value
(
)
)
;
}
void
TextControlState
:
:
SetSelectionRange
(
uint32_t
aSelectionStart
uint32_t
aSelectionEnd
const
Optional
<
nsAString
>
&
aDirection
ErrorResult
&
aRv
ScrollAfterSelection
aScroll
)
{
SelectionDirection
dir
=
DirectionStringToSelectionDirection
(
aDirection
)
;
SetSelectionRange
(
aSelectionStart
aSelectionEnd
dir
aRv
aScroll
)
;
}
void
TextControlState
:
:
SetRangeText
(
const
nsAString
&
aReplacement
ErrorResult
&
aRv
)
{
uint32_t
start
end
;
GetSelectionRange
(
&
start
&
end
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetRangeText
(
aReplacement
start
end
SelectionMode
:
:
Preserve
aRv
Some
(
start
)
Some
(
end
)
)
;
}
void
TextControlState
:
:
SetRangeText
(
const
nsAString
&
aReplacement
uint32_t
aStart
uint32_t
aEnd
SelectionMode
aSelectMode
ErrorResult
&
aRv
const
Maybe
<
uint32_t
>
&
aSelectionStart
const
Maybe
<
uint32_t
>
&
aSelectionEnd
)
{
if
(
aStart
>
aEnd
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
AutoTextControlHandlingState
handlingSetRangeText
(
*
this
TextControlAction
:
:
SetRangeText
)
;
nsAutoString
value
;
mTextCtrlElement
-
>
GetValueFromSetRangeText
(
value
)
;
uint32_t
inputValueLength
=
value
.
Length
(
)
;
if
(
aStart
>
inputValueLength
)
{
aStart
=
inputValueLength
;
}
if
(
aEnd
>
inputValueLength
)
{
aEnd
=
inputValueLength
;
}
uint32_t
selectionStart
selectionEnd
;
if
(
!
aSelectionStart
)
{
MOZ_ASSERT
(
!
aSelectionEnd
)
;
GetSelectionRange
(
&
selectionStart
&
selectionEnd
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
aSelectionEnd
)
;
selectionStart
=
*
aSelectionStart
;
selectionEnd
=
*
aSelectionEnd
;
}
Selection
*
selection
=
mSelCon
?
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
:
nullptr
;
SelectionBatcher
selectionBatcher
(
selection
__FUNCTION__
nsISelectionListener
:
:
JS_REASON
)
;
MOZ_ASSERT
(
aStart
<
=
aEnd
)
;
value
.
Replace
(
aStart
aEnd
-
aStart
aReplacement
)
;
nsresult
rv
=
MOZ_KnownLive
(
mTextCtrlElement
)
-
>
SetValueFromSetRangeText
(
value
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
uint32_t
newEnd
=
aStart
+
aReplacement
.
Length
(
)
;
int32_t
delta
=
aReplacement
.
Length
(
)
-
(
aEnd
-
aStart
)
;
switch
(
aSelectMode
)
{
case
SelectionMode
:
:
Select
:
selectionStart
=
aStart
;
selectionEnd
=
newEnd
;
break
;
case
SelectionMode
:
:
Start
:
selectionStart
=
selectionEnd
=
aStart
;
break
;
case
SelectionMode
:
:
End
:
selectionStart
=
selectionEnd
=
newEnd
;
break
;
case
SelectionMode
:
:
Preserve
:
if
(
selectionStart
>
aEnd
)
{
selectionStart
+
=
delta
;
}
else
if
(
selectionStart
>
aStart
)
{
selectionStart
=
aStart
;
}
if
(
selectionEnd
>
aEnd
)
{
selectionEnd
+
=
delta
;
}
else
if
(
selectionEnd
>
aStart
)
{
selectionEnd
=
newEnd
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
mode
!
"
)
;
}
SetSelectionRange
(
selectionStart
selectionEnd
Optional
<
nsAString
>
(
)
aRv
)
;
if
(
IsSelectionCached
(
)
)
{
GetSelectionProperties
(
)
.
SetMaxLength
(
value
.
Length
(
)
)
;
}
}
void
TextControlState
:
:
DestroyEditor
(
)
{
if
(
mEditorInitialized
)
{
MOZ_ASSERT
(
!
mPasswordMaskData
)
;
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
mPasswordMaskData
=
textEditor
-
>
PreDestroy
(
)
;
MOZ_ASSERT_IF
(
mPasswordMaskData
!
mPasswordMaskData
-
>
mTimer
)
;
mEditorInitialized
=
false
;
}
}
void
TextControlState
:
:
UnbindFromFrame
(
nsTextControlFrame
*
aFrame
)
{
if
(
NS_WARN_IF
(
!
mBoundFrame
)
)
{
return
;
}
MOZ_ASSERT
(
aFrame
=
=
mBoundFrame
"
Unbinding
from
the
wrong
frame
"
)
;
if
(
aFrame
&
&
aFrame
!
=
mBoundFrame
)
{
return
;
}
AutoTextControlHandlingState
handlingUnbindFromFrame
(
*
this
TextControlAction
:
:
UnbindFromFrame
)
;
if
(
mSelCon
)
{
mSelCon
-
>
SelectionWillLoseFocus
(
)
;
}
nsAutoString
value
;
GetValue
(
value
true
)
;
if
(
mRestoringSelection
)
{
mRestoringSelection
-
>
Revoke
(
)
;
mRestoringSelection
=
nullptr
;
}
if
(
!
IsSelectionCached
(
)
)
{
uint32_t
start
=
0
end
=
0
;
GetSelectionRange
(
&
start
&
end
IgnoreErrors
(
)
)
;
nsITextControlFrame
:
:
SelectionDirection
direction
=
GetSelectionDirection
(
IgnoreErrors
(
)
)
;
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
props
.
SetMaxLength
(
value
.
Length
(
)
)
;
props
.
SetStart
(
start
)
;
props
.
SetEnd
(
end
)
;
props
.
SetDirection
(
direction
)
;
mSelectionCached
=
true
;
}
DestroyEditor
(
)
;
if
(
!
SuppressEventHandlers
(
mBoundFrame
-
>
PresContext
(
)
)
)
{
nsCOMPtr
<
nsIControllers
>
controllers
;
if
(
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNodeOrNull
(
mTextCtrlElement
)
)
{
inputElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
else
{
HTMLTextAreaElement
*
textAreaElement
=
HTMLTextAreaElement
:
:
FromNodeOrNull
(
mTextCtrlElement
)
;
if
(
textAreaElement
)
{
textAreaElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
}
if
(
controllers
)
{
uint32_t
numControllers
;
nsresult
rv
=
controllers
-
>
GetControllerCount
(
&
numControllers
)
;
NS_ASSERTION
(
(
NS_SUCCEEDED
(
rv
)
)
"
bad
result
in
gfx
text
control
destructor
"
)
;
for
(
uint32_t
i
=
0
;
i
<
numControllers
;
i
+
+
)
{
nsCOMPtr
<
nsIController
>
controller
;
rv
=
controllers
-
>
GetControllerAt
(
i
getter_AddRefs
(
controller
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
controller
)
{
nsCOMPtr
<
nsIControllerContext
>
editController
=
do_QueryInterface
(
controller
)
;
if
(
editController
)
{
editController
-
>
SetCommandContext
(
nullptr
)
;
}
}
}
}
}
if
(
mSelCon
)
{
if
(
mTextListener
)
{
mTextListener
-
>
EndListeningToSelectionChange
(
)
;
}
mSelCon
-
>
SetScrollableFrame
(
nullptr
)
;
mSelCon
=
nullptr
;
}
if
(
mTextListener
)
{
mTextListener
-
>
SetFrame
(
nullptr
)
;
EventListenerManager
*
manager
=
mTextCtrlElement
-
>
GetExistingListenerManager
(
)
;
if
(
manager
)
{
manager
-
>
RemoveEventListenerByType
(
mTextListener
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
RemoveEventListenerByType
(
mTextListener
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
RemoveEventListenerByType
(
mTextListener
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
mTextListener
=
nullptr
;
}
mBoundFrame
=
nullptr
;
if
(
!
mValueTransferInProgress
)
{
DebugOnly
<
bool
>
ok
=
SetValue
(
value
ValueSetterOption
:
:
ByInternalAPI
)
;
NS_WARNING_ASSERTION
(
ok
"
SetValue
(
)
couldn
'
t
allocate
memory
"
)
;
}
}
void
TextControlState
:
:
GetValue
(
nsAString
&
aValue
bool
aIgnoreWrap
)
const
{
if
(
mHandlingState
&
&
mHandlingState
-
>
IsHandling
(
TextControlAction
:
:
CommitComposition
)
)
{
aValue
=
mHandlingState
-
>
GetSettingValue
(
)
;
MOZ_ASSERT
(
aValue
.
FindChar
(
u
'
\
r
'
)
=
=
-
1
)
;
return
;
}
if
(
mTextEditor
&
&
mBoundFrame
&
&
(
mEditorInitialized
|
|
!
IsSingleLineTextControl
(
)
)
)
{
if
(
aIgnoreWrap
&
&
!
mBoundFrame
-
>
CachedValue
(
)
.
IsVoid
(
)
)
{
aValue
=
mBoundFrame
-
>
CachedValue
(
)
;
MOZ_ASSERT
(
aValue
.
FindChar
(
u
'
\
r
'
)
=
=
-
1
)
;
return
;
}
aValue
.
Truncate
(
)
;
uint32_t
flags
=
(
nsIDocumentEncoder
:
:
OutputLFLineBreak
|
nsIDocumentEncoder
:
:
OutputPreformatted
|
nsIDocumentEncoder
:
:
OutputPersistNBSP
|
nsIDocumentEncoder
:
:
OutputBodyOnly
)
;
if
(
!
aIgnoreWrap
)
{
TextControlElement
:
:
nsHTMLTextWrap
wrapProp
;
if
(
mTextCtrlElement
&
&
TextControlElement
:
:
GetWrapPropertyEnum
(
mTextCtrlElement
wrapProp
)
&
&
wrapProp
=
=
TextControlElement
:
:
eHTMLTextWrap_Hard
)
{
flags
|
=
nsIDocumentEncoder
:
:
OutputWrap
;
}
}
{
AutoNoJSAPI
nojsapi
;
DebugOnly
<
nsresult
>
rv
=
mTextEditor
-
>
ComputeTextValue
(
flags
aValue
)
;
MOZ_ASSERT
(
aValue
.
FindChar
(
u
'
\
r
'
)
=
=
-
1
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
get
value
"
)
;
}
if
(
!
(
flags
&
nsIDocumentEncoder
:
:
OutputWrap
)
)
{
mBoundFrame
-
>
CacheValue
(
aValue
)
;
}
else
{
mBoundFrame
-
>
ClearCachedValue
(
)
;
}
}
else
{
if
(
!
mTextCtrlElement
-
>
ValueChanged
(
)
|
|
mValue
.
IsVoid
(
)
)
{
nsString
value
;
mTextCtrlElement
-
>
GetDefaultValueFromContent
(
value
)
;
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
value
)
;
aValue
=
value
;
}
else
{
aValue
=
mValue
;
MOZ_ASSERT
(
aValue
.
FindChar
(
u
'
\
r
'
)
=
=
-
1
)
;
}
}
}
bool
TextControlState
:
:
ValueEquals
(
const
nsAString
&
aValue
)
const
{
nsString
value
;
GetValue
(
value
true
)
;
return
aValue
.
Equals
(
value
)
;
}
#
ifdef
DEBUG
bool
AreFlagsNotDemandingContradictingMovements
(
const
ValueSetterOptions
&
aOptions
)
{
return
!
aOptions
.
contains
(
{
ValueSetterOption
:
:
MoveCursorToBeginSetSelectionDirectionForward
ValueSetterOption
:
:
MoveCursorToEndIfValueChanged
}
)
;
}
#
endif
bool
TextControlState
:
:
SetValue
(
const
nsAString
&
aValue
const
nsAString
*
aOldValue
const
ValueSetterOptions
&
aOptions
)
{
if
(
mHandlingState
&
&
mHandlingState
-
>
IsHandling
(
TextControlAction
:
:
CommitComposition
)
)
{
aOldValue
=
nullptr
;
}
if
(
mPasswordMaskData
)
{
if
(
mHandlingState
&
&
mHandlingState
-
>
Is
(
TextControlAction
:
:
UnbindFromFrame
)
)
{
}
else
{
mPasswordMaskData
-
>
Reset
(
)
;
}
}
const
bool
wasHandlingSetValue
=
mHandlingState
&
&
mHandlingState
-
>
IsHandling
(
TextControlAction
:
:
SetValue
)
;
ErrorResult
error
;
AutoTextControlHandlingState
handlingSetValue
(
*
this
TextControlAction
:
:
SetValue
aValue
aOldValue
aOptions
error
)
;
if
(
error
.
Failed
(
)
)
{
MOZ_ASSERT
(
error
.
ErrorCodeIs
(
NS_ERROR_OUT_OF_MEMORY
)
)
;
error
.
SuppressException
(
)
;
return
false
;
}
const
auto
changeKind
=
[
&
]
{
if
(
aOptions
.
contains
(
ValueSetterOption
:
:
ByInternalAPI
)
)
{
return
ValueChangeKind
:
:
Internal
;
}
if
(
aOptions
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
)
{
return
ValueChangeKind
:
:
UserInteraction
;
}
return
ValueChangeKind
:
:
Script
;
}
(
)
;
if
(
changeKind
=
=
ValueChangeKind
:
:
Script
)
{
if
(
auto
*
input
=
HTMLInputElement
:
:
FromNode
(
mTextCtrlElement
)
)
{
if
(
input
-
>
LastValueChangeWasInteractive
(
)
)
{
GetValue
(
mLastInteractiveValue
true
)
;
}
}
}
if
(
aOptions
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
|
|
aOptions
.
contains
(
ValueSetterOption
:
:
ByContentAPI
)
)
{
if
(
EditorHasComposition
(
)
)
{
if
(
handlingSetValue
.
IsHandling
(
TextControlAction
:
:
CommitComposition
)
)
{
return
true
;
}
if
(
NS_WARN_IF
(
!
mBoundFrame
)
)
{
}
else
{
MOZ_ASSERT
(
!
aOldValue
|
|
mBoundFrame
-
>
TextEquals
(
*
aOldValue
)
)
;
bool
isSameAsCurrentValue
=
aOldValue
?
aOldValue
-
>
Equals
(
handlingSetValue
.
GetSettingValue
(
)
)
:
mBoundFrame
-
>
TextEquals
(
handlingSetValue
.
GetSettingValue
(
)
)
;
if
(
isSameAsCurrentValue
)
{
return
true
;
}
}
AutoTextControlHandlingState
handlingCommitComposition
(
*
this
TextControlAction
:
:
CommitComposition
)
;
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
nsresult
rv
=
textEditor
-
>
CommitComposition
(
)
;
if
(
handlingCommitComposition
.
IsTextControlStateDestroyed
(
)
)
{
return
true
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
TextControlState
failed
to
commit
composition
"
)
;
return
true
;
}
}
else
{
NS_WARNING
(
"
SetValue
(
)
is
called
when
there
is
composition
but
"
"
it
'
s
not
safe
to
request
to
commit
the
composition
"
)
;
}
}
}
if
(
mTextEditor
&
&
mBoundFrame
)
{
if
(
!
SetValueWithTextEditor
(
handlingSetValue
)
)
{
return
false
;
}
}
else
if
(
!
SetValueWithoutTextEditor
(
handlingSetValue
)
)
{
return
false
;
}
if
(
!
wasHandlingSetValue
)
{
handlingSetValue
.
GetTextControlElement
(
)
-
>
OnValueChanged
(
changeKind
)
;
}
return
true
;
}
bool
TextControlState
:
:
SetValueWithTextEditor
(
AutoTextControlHandlingState
&
aHandlingSetValue
)
{
MOZ_ASSERT
(
aHandlingSetValue
.
Is
(
TextControlAction
:
:
SetValue
)
)
;
MOZ_ASSERT
(
mTextEditor
)
;
MOZ_ASSERT
(
mBoundFrame
)
;
NS_WARNING_ASSERTION
(
!
EditorHasComposition
(
)
"
Failed
to
commit
composition
before
setting
value
.
"
"
Investigate
the
cause
!
"
)
;
#
ifdef
DEBUG
if
(
IsSingleLineTextControl
(
)
)
{
NS_ASSERTION
(
mEditorInitialized
|
|
aHandlingSetValue
.
IsHandling
(
TextControlAction
:
:
PrepareEditor
)
"
We
should
never
try
to
use
the
editor
if
we
'
re
not
"
"
initialized
unless
we
'
re
being
initialized
"
)
;
}
#
endif
MOZ_ASSERT
(
!
aHandlingSetValue
.
GetOldValue
(
)
|
|
mBoundFrame
-
>
TextEquals
(
*
aHandlingSetValue
.
GetOldValue
(
)
)
)
;
bool
isSameAsCurrentValue
=
aHandlingSetValue
.
GetOldValue
(
)
?
aHandlingSetValue
.
GetOldValue
(
)
-
>
Equals
(
aHandlingSetValue
.
GetSettingValue
(
)
)
:
mBoundFrame
-
>
TextEquals
(
aHandlingSetValue
.
GetSettingValue
(
)
)
;
if
(
isSameAsCurrentValue
)
{
return
true
;
}
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
nsCOMPtr
<
Document
>
document
=
textEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
true
;
}
AutoNoJSAPI
nojsapi
;
Selection
*
selection
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
SelectionBatcher
selectionBatcher
(
selection
__FUNCTION__
)
;
AutoRestoreEditorState
restoreState
(
textEditor
)
;
aHandlingSetValue
.
WillSetValueWithTextEditor
(
)
;
if
(
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
)
{
nsresult
rv
=
textEditor
-
>
ReplaceTextAsAction
(
aHandlingSetValue
.
GetSettingValue
(
)
nullptr
StaticPrefs
:
:
dom_input_event_allow_to_cancel_set_user_input
(
)
?
TextEditor
:
:
AllowBeforeInputEventCancelable
:
:
Yes
:
TextEditor
:
:
AllowBeforeInputEventCancelable
:
:
No
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
EditorBase
:
:
ReplaceTextAsAction
(
)
failed
"
)
;
return
rv
!
=
NS_ERROR_OUT_OF_MEMORY
;
}
AutoInputEventSuppresser
suppressInputEventDispatching
(
textEditor
)
;
Maybe
<
AutoDisableUndo
>
disableUndo
;
if
(
!
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
PreserveUndoHistory
)
)
{
disableUndo
.
emplace
(
textEditor
)
;
}
if
(
selection
)
{
IgnoredErrorResult
ignoredError
;
MOZ_KnownLive
(
selection
)
-
>
RemoveAllRanges
(
ignoredError
)
;
NS_WARNING_ASSERTION
(
!
ignoredError
.
Failed
(
)
"
Selection
:
:
RemoveAllRanges
(
)
failed
but
ignored
"
)
;
}
nsresult
rv
=
textEditor
-
>
SetTextAsAction
(
aHandlingSetValue
.
GetSettingValue
(
)
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
&
&
!
StaticPrefs
:
:
dom_input_event_allow_to_cancel_set_user_input
(
)
?
TextEditor
:
:
AllowBeforeInputEventCancelable
:
:
No
:
TextEditor
:
:
AllowBeforeInputEventCancelable
:
:
Yes
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
TextEditor
:
:
SetTextAsAction
(
)
failed
"
)
;
if
(
!
aHandlingSetValue
.
HasEditActionHandled
(
)
)
{
nsresult
rvOnEditActionHandled
=
MOZ_KnownLive
(
aHandlingSetValue
.
GetTextInputListener
(
)
)
-
>
OnEditActionHandled
(
*
textEditor
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvOnEditActionHandled
)
"
TextInputListener
:
:
OnEditActionHandled
(
)
failed
"
)
;
if
(
rv
!
=
NS_ERROR_OUT_OF_MEMORY
)
{
rv
=
rvOnEditActionHandled
;
}
}
return
rv
!
=
NS_ERROR_OUT_OF_MEMORY
;
}
bool
TextControlState
:
:
SetValueWithoutTextEditor
(
AutoTextControlHandlingState
&
aHandlingSetValue
)
{
MOZ_ASSERT
(
aHandlingSetValue
.
Is
(
TextControlAction
:
:
SetValue
)
)
;
MOZ_ASSERT
(
!
mTextEditor
|
|
!
mBoundFrame
)
;
NS_WARNING_ASSERTION
(
!
EditorHasComposition
(
)
"
Failed
to
commit
composition
before
setting
value
.
"
"
Investigate
the
cause
!
"
)
;
if
(
mValue
.
IsVoid
(
)
)
{
mValue
.
SetIsVoid
(
false
)
;
}
if
(
!
mValue
.
Equals
(
aHandlingSetValue
.
GetSettingValue
(
)
)
|
|
!
StaticPrefs
:
:
dom_input_skip_cursor_move_for_same_value_set
(
)
)
{
bool
handleSettingValue
=
true
;
nsString
inputEventData
(
aHandlingSetValue
.
GetSettingValue
(
)
)
;
if
(
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
&
&
StaticPrefs
:
:
dom_input_events_beforeinput_enabled
(
)
&
&
!
aHandlingSetValue
.
HasBeforeInputEventDispatched
(
)
)
{
MOZ_ASSERT
(
aHandlingSetValue
.
GetTextControlElement
(
)
)
;
MOZ_ASSERT
(
!
aHandlingSetValue
.
GetSettingValue
(
)
.
IsVoid
(
)
)
;
aHandlingSetValue
.
WillDispatchBeforeInputEvent
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
DebugOnly
<
nsresult
>
rvIgnored
=
nsContentUtils
:
:
DispatchInputEvent
(
MOZ_KnownLive
(
aHandlingSetValue
.
GetTextControlElement
(
)
)
eEditorBeforeInput
EditorInputType
:
:
eInsertReplacementText
nullptr
InputEventOptions
(
inputEventData
StaticPrefs
:
:
dom_input_event_allow_to_cancel_set_user_input
(
)
?
InputEventOptions
:
:
NeverCancelable
:
:
No
:
InputEventOptions
:
:
NeverCancelable
:
:
Yes
)
&
status
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
dispatch
beforeinput
event
"
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
true
;
}
if
(
aHandlingSetValue
.
IsTextControlStateDestroyed
(
)
)
{
return
true
;
}
if
(
mTextEditor
&
&
mBoundFrame
)
{
AutoInputEventSuppresser
suppressInputEvent
(
mTextEditor
)
;
if
(
!
SetValueWithTextEditor
(
aHandlingSetValue
)
)
{
return
false
;
}
if
(
aHandlingSetValue
.
IsTextControlStateDestroyed
(
)
)
{
return
true
;
}
handleSettingValue
=
false
;
}
}
if
(
handleSettingValue
)
{
if
(
!
mValue
.
Assign
(
aHandlingSetValue
.
GetSettingValue
(
)
fallible
)
)
{
return
false
;
}
if
(
IsSelectionCached
(
)
)
{
MOZ_ASSERT
(
AreFlagsNotDemandingContradictingMovements
(
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
)
)
;
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
props
.
SetMaxLength
(
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
BySetRangeTextAPI
)
?
UINT32_MAX
:
aHandlingSetValue
.
GetSettingValue
(
)
.
Length
(
)
)
;
if
(
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
MoveCursorToEndIfValueChanged
)
)
{
props
.
SetStart
(
aHandlingSetValue
.
GetSettingValue
(
)
.
Length
(
)
)
;
props
.
SetEnd
(
aHandlingSetValue
.
GetSettingValue
(
)
.
Length
(
)
)
;
props
.
SetDirection
(
SelectionDirection
:
:
Forward
)
;
}
else
if
(
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
MoveCursorToBeginSetSelectionDirectionForward
)
)
{
props
.
SetStart
(
0
)
;
props
.
SetEnd
(
0
)
;
props
.
SetDirection
(
SelectionDirection
:
:
Forward
)
;
}
}
if
(
mBoundFrame
)
{
mBoundFrame
-
>
UpdateValueDisplay
(
true
)
;
}
}
if
(
aHandlingSetValue
.
ValueSetterOptionsRef
(
)
.
contains
(
ValueSetterOption
:
:
BySetUserInputAPI
)
)
{
MOZ_ASSERT
(
aHandlingSetValue
.
GetTextControlElement
(
)
)
;
aHandlingSetValue
.
GetTextControlElement
(
)
-
>
OnValueChanged
(
ValueChangeKind
:
:
UserInteraction
)
;
ClearLastInteractiveValue
(
)
;
MOZ_ASSERT
(
!
aHandlingSetValue
.
GetSettingValue
(
)
.
IsVoid
(
)
)
;
DebugOnly
<
nsresult
>
rvIgnored
=
nsContentUtils
:
:
DispatchInputEvent
(
MOZ_KnownLive
(
aHandlingSetValue
.
GetTextControlElement
(
)
)
eEditorInput
EditorInputType
:
:
eInsertReplacementText
nullptr
InputEventOptions
(
inputEventData
InputEventOptions
:
:
NeverCancelable
:
:
No
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
dispatch
input
event
"
)
;
}
}
else
{
if
(
IsSelectionCached
(
)
)
{
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
props
.
SetIsDirty
(
)
;
}
}
return
true
;
}
bool
TextControlState
:
:
HasNonEmptyValue
(
)
{
if
(
mTextEditor
&
&
mBoundFrame
&
&
mEditorInitialized
&
&
!
(
mHandlingState
&
&
mHandlingState
-
>
IsHandling
(
TextControlAction
:
:
CommitComposition
)
)
)
{
return
!
mTextEditor
-
>
IsEmpty
(
)
;
}
nsAutoString
value
;
GetValue
(
value
true
)
;
return
!
value
.
IsEmpty
(
)
;
}
void
TextControlState
:
:
InitializeKeyboardEventListeners
(
)
{
EventListenerManager
*
manager
=
mTextCtrlElement
-
>
GetOrCreateListenerManager
(
)
;
if
(
manager
)
{
manager
-
>
AddEventListenerByType
(
mTextListener
u
"
keydown
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
AddEventListenerByType
(
mTextListener
u
"
keypress
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
AddEventListenerByType
(
mTextListener
u
"
keyup
"
_ns
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
mSelCon
-
>
SetScrollableFrame
(
mBoundFrame
-
>
GetScrollTargetFrame
(
)
)
;
}
void
TextControlState
:
:
SetPreviewText
(
const
nsAString
&
aValue
bool
aNotify
)
{
Element
*
previewDiv
=
GetPreviewNode
(
)
;
if
(
!
previewDiv
)
{
return
;
}
nsAutoString
previewValue
(
aValue
)
;
nsContentUtils
:
:
RemoveNewlines
(
previewValue
)
;
MOZ_ASSERT
(
previewDiv
-
>
GetFirstChild
(
)
"
preview
div
has
no
child
"
)
;
previewDiv
-
>
GetFirstChild
(
)
-
>
AsText
(
)
-
>
SetText
(
previewValue
aNotify
)
;
}
void
TextControlState
:
:
GetPreviewText
(
nsAString
&
aValue
)
{
Element
*
previewDiv
=
GetPreviewNode
(
)
;
if
(
!
previewDiv
)
{
return
;
}
MOZ_ASSERT
(
previewDiv
-
>
GetFirstChild
(
)
"
preview
div
has
no
child
"
)
;
const
nsTextFragment
*
text
=
previewDiv
-
>
GetFirstChild
(
)
-
>
GetText
(
)
;
aValue
.
Truncate
(
)
;
text
-
>
AppendTo
(
aValue
)
;
}
bool
TextControlState
:
:
EditorHasComposition
(
)
{
return
mTextEditor
&
&
mTextEditor
-
>
IsIMEComposing
(
)
;
}
}
