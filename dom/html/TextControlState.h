#
ifndef
mozilla_TextControlState_h
#
define
mozilla_TextControlState_h
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsITextControlFrame
.
h
"
class
nsTextControlFrame
;
class
nsISelectionController
;
class
nsFrameSelection
;
class
nsFrame
;
namespace
mozilla
{
class
AutoTextControlHandlingState
;
class
ErrorResult
;
class
TextInputListener
;
class
TextInputSelectionController
;
namespace
dom
{
class
HTMLInputElement
;
}
class
RestoreSelectionState
;
class
TextControlState
final
:
public
SupportsWeakPtr
<
TextControlState
>
{
public
:
typedef
dom
:
:
Element
Element
;
typedef
dom
:
:
HTMLInputElement
HTMLInputElement
;
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
TextControlState
)
static
TextControlState
*
Construct
(
TextControlElement
*
aOwningElement
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
void
Shutdown
(
)
;
void
Destroy
(
)
;
TextControlState
(
)
=
delete
;
explicit
TextControlState
(
const
TextControlState
&
)
=
delete
;
TextControlState
(
TextControlState
&
&
)
=
delete
;
void
operator
=
(
const
TextControlState
&
)
=
delete
;
void
operator
=
(
TextControlState
&
&
)
=
delete
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Unlink
(
)
;
bool
IsBusy
(
)
const
{
return
!
!
mHandlingState
|
|
mValueTransferInProgress
;
}
TextEditor
*
GetTextEditor
(
)
;
TextEditor
*
GetTextEditorWithoutCreation
(
)
;
nsISelectionController
*
GetSelectionController
(
)
const
;
nsFrameSelection
*
GetConstFrameSelection
(
)
;
nsresult
BindToFrame
(
nsTextControlFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
UnbindFromFrame
(
nsTextControlFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
PrepareEditor
(
const
nsAString
*
aValue
=
nullptr
)
;
void
InitializeKeyboardEventListeners
(
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
nsresult
OnEditActionHandled
(
)
;
enum
SetValueFlags
{
eSetValue_Internal
=
1
<
<
0
eSetValue_BySetUserInput
=
1
<
<
1
eSetValue_ByContent
=
1
<
<
2
eSetValue_Notify
=
1
<
<
3
eSetValue_MoveCursorToEndIfValueChanged
=
1
<
<
4
eSetValue_ForXUL
=
1
<
<
5
eSetValue_MoveCursorToBeginSetSelectionDirectionForward
=
1
<
<
6
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
bool
SetValue
(
const
nsAString
&
aValue
const
nsAString
*
aOldValue
uint32_t
aFlags
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
bool
SetValue
(
const
nsAString
&
aValue
uint32_t
aFlags
)
{
return
SetValue
(
aValue
nullptr
aFlags
)
;
}
void
GetValue
(
nsAString
&
aValue
bool
aIgnoreWrap
)
const
;
bool
ValueEquals
(
const
nsAString
&
aValue
)
const
;
bool
HasNonEmptyValue
(
)
;
void
EmptyValue
(
)
{
if
(
mValue
)
{
mValue
-
>
Truncate
(
)
;
}
}
bool
IsEmpty
(
)
const
{
return
mValue
?
mValue
-
>
IsEmpty
(
)
:
true
;
}
Element
*
GetRootNode
(
)
;
Element
*
GetPreviewNode
(
)
;
bool
IsSingleLineTextControl
(
)
const
{
return
mTextCtrlElement
-
>
IsSingleLineTextControl
(
)
;
}
bool
IsTextArea
(
)
const
{
return
mTextCtrlElement
-
>
IsTextArea
(
)
;
}
bool
IsPasswordTextControl
(
)
const
{
return
mTextCtrlElement
-
>
IsPasswordTextControl
(
)
;
}
int32_t
GetCols
(
)
{
return
mTextCtrlElement
-
>
GetCols
(
)
;
}
int32_t
GetWrapCols
(
)
{
int32_t
wrapCols
=
mTextCtrlElement
-
>
GetWrapCols
(
)
;
MOZ_ASSERT
(
wrapCols
>
=
0
)
;
return
wrapCols
;
}
int32_t
GetRows
(
)
{
return
mTextCtrlElement
-
>
GetRows
(
)
;
}
void
UpdateOverlayTextVisibility
(
bool
aNotify
)
;
bool
GetPlaceholderVisibility
(
)
{
return
mPlaceholderVisibility
;
}
void
SetPreviewText
(
const
nsAString
&
aValue
bool
aNotify
)
;
void
GetPreviewText
(
nsAString
&
aValue
)
;
bool
GetPreviewVisibility
(
)
{
return
mPreviewVisibility
;
}
int32_t
GetMaxLength
(
)
;
void
HideSelectionIfBlurred
(
)
;
struct
SelectionProperties
{
public
:
SelectionProperties
(
)
:
mStart
(
0
)
mEnd
(
0
)
mDirection
(
nsITextControlFrame
:
:
eForward
)
{
}
bool
IsDefault
(
)
const
{
return
mStart
=
=
0
&
&
mEnd
=
=
0
&
&
mDirection
=
=
nsITextControlFrame
:
:
eForward
;
}
uint32_t
GetStart
(
)
const
{
return
mStart
;
}
void
SetStart
(
uint32_t
value
)
{
mIsDirty
=
true
;
mStart
=
value
;
}
uint32_t
GetEnd
(
)
const
{
return
mEnd
;
}
void
SetEnd
(
uint32_t
value
)
{
mIsDirty
=
true
;
mEnd
=
value
;
}
nsITextControlFrame
:
:
SelectionDirection
GetDirection
(
)
const
{
return
mDirection
;
}
void
SetDirection
(
nsITextControlFrame
:
:
SelectionDirection
value
)
{
mIsDirty
=
true
;
mDirection
=
value
;
}
bool
IsDirty
(
)
const
{
return
mIsDirty
;
}
void
SetIsDirty
(
)
{
mIsDirty
=
true
;
}
private
:
uint32_t
mStart
mEnd
;
bool
mIsDirty
=
false
;
nsITextControlFrame
:
:
SelectionDirection
mDirection
;
}
;
bool
IsSelectionCached
(
)
const
;
SelectionProperties
&
GetSelectionProperties
(
)
;
void
SetSelectionProperties
(
SelectionProperties
&
aProps
)
;
void
WillInitEagerly
(
)
{
mSelectionRestoreEagerInit
=
true
;
}
bool
HasNeverInitializedBefore
(
)
const
{
return
!
mEverInited
;
}
MOZ_CAN_RUN_SCRIPT
void
SyncUpSelectionPropertiesBeforeDestruction
(
)
;
void
GetSelectionRange
(
uint32_t
*
aSelectionStart
uint32_t
*
aSelectionEnd
ErrorResult
&
aRv
)
;
nsITextControlFrame
:
:
SelectionDirection
GetSelectionDirection
(
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetSelectionRange
(
uint32_t
aStart
uint32_t
aEnd
nsITextControlFrame
:
:
SelectionDirection
aDirection
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetSelectionRange
(
uint32_t
aSelectionStart
uint32_t
aSelectionEnd
const
dom
:
:
Optional
<
nsAString
>
&
aDirection
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetSelectionStart
(
const
dom
:
:
Nullable
<
uint32_t
>
&
aStart
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetSelectionEnd
(
const
dom
:
:
Nullable
<
uint32_t
>
&
aEnd
ErrorResult
&
aRv
)
;
void
GetSelectionDirectionString
(
nsAString
&
aDirection
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetSelectionDirection
(
const
nsAString
&
aDirection
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetRangeText
(
const
nsAString
&
aReplacement
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
SetRangeText
(
const
nsAString
&
aReplacement
uint32_t
aStart
uint32_t
aEnd
dom
:
:
SelectionMode
aSelectMode
ErrorResult
&
aRv
const
Maybe
<
uint32_t
>
&
aSelectionStart
=
Nothing
(
)
const
Maybe
<
uint32_t
>
&
aSelectionEnd
=
Nothing
(
)
)
;
void
UpdateEditableState
(
bool
aNotify
)
{
if
(
auto
*
root
=
GetRootNode
(
)
)
{
root
-
>
UpdateEditableState
(
aNotify
)
;
}
}
private
:
explicit
TextControlState
(
TextControlElement
*
aOwningElement
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
~
TextControlState
(
)
;
void
DeleteOrCacheForReuse
(
)
;
void
PrepareForReuse
(
)
{
MOZ_ASSERT
(
!
IsBusy
(
)
)
;
Unlink
(
)
;
mValue
.
reset
(
)
;
mTextCtrlElement
=
nullptr
;
}
void
ValueWasChanged
(
bool
aNotify
)
;
MOZ_CAN_RUN_SCRIPT
void
DestroyEditor
(
)
;
MOZ_CAN_RUN_SCRIPT
void
Clear
(
)
;
nsresult
InitializeRootNode
(
)
;
void
FinishedRestoringSelection
(
)
;
HTMLInputElement
*
GetParentNumberControl
(
nsFrame
*
aFrame
)
const
;
bool
EditorHasComposition
(
)
;
MOZ_CAN_RUN_SCRIPT
bool
SetValueWithTextEditor
(
AutoTextControlHandlingState
&
aHandlingState
)
;
MOZ_CAN_RUN_SCRIPT
bool
SetValueWithoutTextEditor
(
AutoTextControlHandlingState
&
aHandlingState
)
;
AutoTextControlHandlingState
*
mHandlingState
=
nullptr
;
TextControlElement
*
MOZ_NON_OWNING_REF
mTextCtrlElement
;
RefPtr
<
TextInputSelectionController
>
mSelCon
;
RefPtr
<
RestoreSelectionState
>
mRestoringSelection
;
RefPtr
<
TextEditor
>
mTextEditor
;
nsTextControlFrame
*
mBoundFrame
;
RefPtr
<
TextInputListener
>
mTextListener
;
Maybe
<
nsString
>
mValue
;
SelectionProperties
mSelectionProperties
;
bool
mEverInited
;
bool
mEditorInitialized
;
bool
mValueTransferInProgress
;
bool
mSelectionCached
;
mutable
bool
mSelectionRestoreEagerInit
;
bool
mPlaceholderVisibility
;
bool
mPreviewVisibility
;
static
const
size_t
kMaxCountOfCacheToReuse
=
25
;
static
AutoTArray
<
TextControlState
*
kMaxCountOfCacheToReuse
>
*
sReleasedInstances
;
static
bool
sHasShutDown
;
friend
class
AutoTextControlHandlingState
;
friend
class
PrepareEditorEvent
;
friend
class
RestoreSelectionState
;
}
;
}
#
endif
