#
ifndef
nsTextEditorState_h__
#
define
nsTextEditorState_h__
#
include
"
nsString
.
h
"
#
include
"
nsITextControlElement
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
Nullable
.
h
"
class
nsTextControlFrame
;
class
nsTextInputSelectionImpl
;
class
nsAnonDivObserver
;
class
nsISelectionController
;
class
nsFrameSelection
;
class
nsITextControlElement
;
class
nsFrame
;
namespace
mozilla
{
class
ErrorResult
;
class
TextInputListener
;
namespace
dom
{
class
HTMLInputElement
;
}
}
class
RestoreSelectionState
;
class
nsTextEditorState
:
public
mozilla
:
:
SupportsWeakPtr
<
nsTextEditorState
>
{
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
nsTextEditorState
)
explicit
nsTextEditorState
(
nsITextControlElement
*
aOwningElement
)
;
static
nsTextEditorState
*
Construct
(
nsITextControlElement
*
aOwningElement
nsTextEditorState
*
*
aReusedState
)
;
~
nsTextEditorState
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
;
void
Unlink
(
)
;
void
PrepareForReuse
(
)
{
Unlink
(
)
;
mValue
.
reset
(
)
;
mValueBeingSet
.
Truncate
(
)
;
mTextCtrlElement
=
nullptr
;
}
mozilla
:
:
TextEditor
*
GetTextEditor
(
)
;
mozilla
:
:
TextEditor
*
GetTextEditorWithoutCreation
(
)
;
nsISelectionController
*
GetSelectionController
(
)
const
;
nsFrameSelection
*
GetConstFrameSelection
(
)
;
nsresult
BindToFrame
(
nsTextControlFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
UnbindFromFrame
(
nsTextControlFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
PrepareEditor
(
const
nsAString
*
aValue
=
nullptr
)
;
void
InitializeKeyboardEventListeners
(
)
;
enum
SetValueFlags
{
eSetValue_Internal
=
1
<
<
0
eSetValue_BySetUserInput
=
1
<
<
1
eSetValue_ByContent
=
1
<
<
2
eSetValue_Notify
=
1
<
<
3
eSetValue_MoveCursorToEndIfValueChanged
=
1
<
<
4
eSetValue_ForXUL
=
1
<
<
5
}
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
bool
SetValue
(
const
nsAString
&
aValue
const
nsAString
*
aOldValue
uint32_t
aFlags
)
;
MOZ_CAN_RUN_SCRIPT
MOZ_MUST_USE
bool
SetValue
(
const
nsAString
&
aValue
uint32_t
aFlags
)
{
return
SetValue
(
aValue
nullptr
aFlags
)
;
}
void
GetValue
(
nsAString
&
aValue
bool
aIgnoreWrap
)
const
;
bool
HasNonEmptyValue
(
)
;
void
EmptyValue
(
)
{
if
(
mValue
)
mValue
-
>
Truncate
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mValue
?
mValue
-
>
IsEmpty
(
)
:
true
;
}
mozilla
:
:
dom
:
:
Element
*
GetRootNode
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetPreviewNode
(
)
;
bool
IsSingleLineTextControl
(
)
const
{
return
mTextCtrlElement
-
>
IsSingleLineTextControl
(
)
;
}
bool
IsTextArea
(
)
const
{
return
mTextCtrlElement
-
>
IsTextArea
(
)
;
}
bool
IsPasswordTextControl
(
)
const
{
return
mTextCtrlElement
-
>
IsPasswordTextControl
(
)
;
}
int32_t
GetCols
(
)
{
return
mTextCtrlElement
-
>
GetCols
(
)
;
}
int32_t
GetWrapCols
(
)
{
return
mTextCtrlElement
-
>
GetWrapCols
(
)
;
}
int32_t
GetRows
(
)
{
return
mTextCtrlElement
-
>
GetRows
(
)
;
}
void
UpdateOverlayTextVisibility
(
bool
aNotify
)
;
bool
GetPlaceholderVisibility
(
)
{
return
mPlaceholderVisibility
;
}
void
SetPreviewText
(
const
nsAString
&
aValue
bool
aNotify
)
;
void
GetPreviewText
(
nsAString
&
aValue
)
;
bool
GetPreviewVisibility
(
)
{
return
mPreviewVisibility
;
}
int32_t
GetMaxLength
(
)
;
void
HideSelectionIfBlurred
(
)
;
struct
SelectionProperties
{
public
:
SelectionProperties
(
)
:
mStart
(
0
)
mEnd
(
0
)
mDirection
(
nsITextControlFrame
:
:
eForward
)
{
}
bool
IsDefault
(
)
const
{
return
mStart
=
=
0
&
&
mEnd
=
=
0
&
&
mDirection
=
=
nsITextControlFrame
:
:
eForward
;
}
uint32_t
GetStart
(
)
const
{
return
mStart
;
}
void
SetStart
(
uint32_t
value
)
{
mIsDirty
=
true
;
mStart
=
value
;
}
uint32_t
GetEnd
(
)
const
{
return
mEnd
;
}
void
SetEnd
(
uint32_t
value
)
{
mIsDirty
=
true
;
mEnd
=
value
;
}
nsITextControlFrame
:
:
SelectionDirection
GetDirection
(
)
const
{
return
mDirection
;
}
void
SetDirection
(
nsITextControlFrame
:
:
SelectionDirection
value
)
{
mIsDirty
=
true
;
mDirection
=
value
;
}
bool
IsDirty
(
)
const
{
return
mIsDirty
;
}
void
SetIsDirty
(
)
{
mIsDirty
=
true
;
}
private
:
uint32_t
mStart
mEnd
;
bool
mIsDirty
=
false
;
nsITextControlFrame
:
:
SelectionDirection
mDirection
;
}
;
bool
IsSelectionCached
(
)
const
;
SelectionProperties
&
GetSelectionProperties
(
)
;
void
SetSelectionProperties
(
SelectionProperties
&
aProps
)
;
void
WillInitEagerly
(
)
{
mSelectionRestoreEagerInit
=
true
;
}
bool
HasNeverInitializedBefore
(
)
const
{
return
!
mEverInited
;
}
MOZ_CAN_RUN_SCRIPT
void
SyncUpSelectionPropertiesBeforeDestruction
(
)
;
void
GetSelectionRange
(
uint32_t
*
aSelectionStart
uint32_t
*
aSelectionEnd
mozilla
:
:
ErrorResult
&
aRv
)
;
nsITextControlFrame
:
:
SelectionDirection
GetSelectionDirection
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetSelectionRange
(
uint32_t
aStart
uint32_t
aEnd
nsITextControlFrame
:
:
SelectionDirection
aDirection
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetSelectionRange
(
uint32_t
aSelectionStart
uint32_t
aSelectionEnd
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
aDirection
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetSelectionStart
(
const
mozilla
:
:
dom
:
:
Nullable
<
uint32_t
>
&
aStart
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetSelectionEnd
(
const
mozilla
:
:
dom
:
:
Nullable
<
uint32_t
>
&
aEnd
mozilla
:
:
ErrorResult
&
aRv
)
;
void
GetSelectionDirectionString
(
nsAString
&
aDirection
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetSelectionDirection
(
const
nsAString
&
aDirection
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetRangeText
(
const
nsAString
&
aReplacement
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetRangeText
(
const
nsAString
&
aReplacement
uint32_t
aStart
uint32_t
aEnd
mozilla
:
:
dom
:
:
SelectionMode
aSelectMode
mozilla
:
:
ErrorResult
&
aRv
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aSelectionStart
=
mozilla
:
:
Nothing
(
)
const
mozilla
:
:
Maybe
<
uint32_t
>
&
aSelectionEnd
=
mozilla
:
:
Nothing
(
)
)
;
void
UpdateEditableState
(
bool
aNotify
)
{
if
(
auto
*
root
=
GetRootNode
(
)
)
{
root
-
>
UpdateEditableState
(
aNotify
)
;
}
}
private
:
friend
class
RestoreSelectionState
;
nsTextEditorState
(
const
nsTextEditorState
&
)
;
void
operator
=
(
const
nsTextEditorState
&
)
;
void
ValueWasChanged
(
bool
aNotify
)
;
void
DestroyEditor
(
)
;
void
Clear
(
)
;
nsresult
InitializeRootNode
(
)
;
void
FinishedRestoringSelection
(
)
;
mozilla
:
:
dom
:
:
HTMLInputElement
*
GetParentNumberControl
(
nsFrame
*
aFrame
)
const
;
bool
EditorHasComposition
(
)
;
class
InitializationGuard
{
public
:
explicit
InitializationGuard
(
nsTextEditorState
&
aState
)
:
mState
(
aState
)
mGuardSet
(
false
)
{
if
(
!
mState
.
mInitializing
)
{
mGuardSet
=
true
;
mState
.
mInitializing
=
true
;
}
}
~
InitializationGuard
(
)
{
if
(
mGuardSet
)
{
mState
.
mInitializing
=
false
;
}
}
bool
IsInitializingRecursively
(
)
const
{
return
!
mGuardSet
;
}
private
:
nsTextEditorState
&
mState
;
bool
mGuardSet
;
}
;
friend
class
InitializationGuard
;
friend
class
PrepareEditorEvent
;
nsITextControlElement
*
MOZ_NON_OWNING_REF
mTextCtrlElement
;
RefPtr
<
nsTextInputSelectionImpl
>
mSelCon
;
RefPtr
<
RestoreSelectionState
>
mRestoringSelection
;
RefPtr
<
mozilla
:
:
TextEditor
>
mTextEditor
;
nsTextControlFrame
*
mBoundFrame
;
RefPtr
<
mozilla
:
:
TextInputListener
>
mTextListener
;
mozilla
:
:
Maybe
<
nsString
>
mValue
;
nsString
mValueBeingSet
;
SelectionProperties
mSelectionProperties
;
bool
mEverInited
;
bool
mEditorInitialized
;
bool
mInitializing
;
bool
mValueTransferInProgress
;
bool
mSelectionCached
;
mutable
bool
mSelectionRestoreEagerInit
;
bool
mPlaceholderVisibility
;
bool
mPreviewVisibility
;
bool
mIsCommittingComposition
;
}
;
inline
void
ImplCycleCollectionUnlink
(
nsTextEditorState
&
aField
)
{
aField
.
Unlink
(
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsTextEditorState
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
aField
.
Traverse
(
aCallback
)
;
}
#
endif
