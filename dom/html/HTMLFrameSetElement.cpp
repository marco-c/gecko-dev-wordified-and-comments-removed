#
include
"
HTMLFrameSetElement
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
"
mozilla
/
UniquePtrExtensions
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
EventHandlerBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFrameSetElementBinding
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
FrameSet
)
namespace
mozilla
:
:
dom
{
HTMLFrameSetElement
:
:
~
HTMLFrameSetElement
(
)
=
default
;
JSObject
*
HTMLFrameSetElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLFrameSetElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_ELEMENT_CLONE
(
HTMLFrameSetElement
)
void
HTMLFrameSetElement
:
:
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
bool
aNotify
)
{
mCurrentRowColHint
=
NS_STYLE_HINT_REFLOW
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
rows
)
{
if
(
aValue
)
{
int32_t
oldRows
=
mNumRows
;
ParseRowCol
(
*
aValue
mNumRows
&
mRowSpecs
)
;
if
(
mNumRows
!
=
oldRows
)
{
mCurrentRowColHint
=
nsChangeHint_ReconstructFrame
;
}
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
cols
)
{
if
(
aValue
)
{
int32_t
oldCols
=
mNumCols
;
ParseRowCol
(
*
aValue
mNumCols
&
mColSpecs
)
;
if
(
mNumCols
!
=
oldCols
)
{
mCurrentRowColHint
=
nsChangeHint_ReconstructFrame
;
}
}
}
}
return
nsGenericHTMLElement
:
:
BeforeSetAttr
(
aNamespaceID
aName
aValue
aNotify
)
;
}
Span
<
const
nsFramesetSpec
>
HTMLFrameSetElement
:
:
GetRowSpec
(
)
{
if
(
!
mRowSpecs
)
{
if
(
const
nsAttrValue
*
value
=
GetParsedAttr
(
nsGkAtoms
:
:
rows
)
)
{
if
(
NS_FAILED
(
ParseRowCol
(
*
value
mNumRows
&
mRowSpecs
)
)
)
{
return
{
}
;
}
}
if
(
!
mRowSpecs
)
{
mRowSpecs
=
MakeUnique
<
nsFramesetSpec
[
]
>
(
1
)
;
mNumRows
=
1
;
mRowSpecs
[
0
]
.
mUnit
=
eFramesetUnit_Relative
;
mRowSpecs
[
0
]
.
mValue
=
1
;
}
}
return
Span
(
mRowSpecs
.
get
(
)
mNumRows
)
;
}
Span
<
const
nsFramesetSpec
>
HTMLFrameSetElement
:
:
GetColSpec
(
)
{
if
(
!
mColSpecs
)
{
if
(
const
nsAttrValue
*
value
=
GetParsedAttr
(
nsGkAtoms
:
:
cols
)
)
{
if
(
NS_FAILED
(
ParseRowCol
(
*
value
mNumCols
&
mColSpecs
)
)
)
{
return
{
}
;
}
}
if
(
!
mColSpecs
)
{
mColSpecs
=
MakeUnique
<
nsFramesetSpec
[
]
>
(
1
)
;
mNumCols
=
1
;
mColSpecs
[
0
]
.
mUnit
=
eFramesetUnit_Relative
;
mColSpecs
[
0
]
.
mValue
=
1
;
}
}
return
Span
(
mColSpecs
.
get
(
)
mNumCols
)
;
}
bool
HTMLFrameSetElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
bordercolor
)
{
return
aResult
.
ParseColor
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
frameborder
)
{
return
nsGenericHTMLElement
:
:
ParseFrameborderValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
border
)
{
return
aResult
.
ParseIntWithBounds
(
aValue
0
100
)
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
nsChangeHint
HTMLFrameSetElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
AttrModType
aModType
)
const
{
nsChangeHint
retval
=
nsGenericHTMLElement
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
rows
|
|
aAttribute
=
=
nsGkAtoms
:
:
cols
)
{
retval
|
=
mCurrentRowColHint
;
}
return
retval
;
}
nsresult
HTMLFrameSetElement
:
:
ParseRowCol
(
const
nsAttrValue
&
aValue
int32_t
&
aNumSpecs
UniquePtr
<
nsFramesetSpec
[
]
>
*
aSpecs
)
{
if
(
aValue
.
IsEmptyString
(
)
)
{
aNumSpecs
=
0
;
*
aSpecs
=
nullptr
;
return
NS_OK
;
}
MOZ_ASSERT
(
aValue
.
Type
(
)
=
=
nsAttrValue
:
:
eString
)
;
static
const
char16_t
sAster
(
'
*
'
)
;
static
const
char16_t
sPercent
(
'
%
'
)
;
static
const
char16_t
sComma
(
'
'
)
;
nsAutoString
spec
(
aValue
.
GetStringValue
(
)
)
;
spec
.
StripChars
(
u
"
\
n
\
r
\
t
\
"
\
'
"
)
;
spec
.
Trim
(
"
"
)
;
static_assert
(
NS_MAX_FRAMESET_SPEC_COUNT
*
sizeof
(
nsFramesetSpec
)
<
(
1
<
<
30
)
"
Too
many
frameset
specs
allowed
to
allocate
"
)
;
int32_t
commaX
=
spec
.
FindChar
(
sComma
)
;
size_t
count
=
1
;
while
(
commaX
!
=
kNotFound
&
&
count
<
NS_MAX_FRAMESET_SPEC_COUNT
)
{
count
+
+
;
commaX
=
spec
.
FindChar
(
sComma
commaX
+
1
)
;
}
auto
specs
=
MakeUniqueFallible
<
nsFramesetSpec
[
]
>
(
count
)
;
if
(
!
specs
)
{
*
aSpecs
=
nullptr
;
aNumSpecs
=
0
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
bool
isInQuirks
=
InNavQuirksMode
(
OwnerDoc
(
)
)
;
size_t
start
=
0
;
size_t
specLen
=
spec
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
count
;
i
+
+
)
{
commaX
=
spec
.
FindChar
(
sComma
start
)
;
MOZ_ASSERT
(
i
=
=
count
-
1
|
|
commaX
!
=
kNotFound
"
Failed
to
find
comma
somehow
"
)
;
size_t
end
=
(
commaX
=
=
kNotFound
)
?
specLen
:
commaX
;
specs
[
i
]
.
mUnit
=
eFramesetUnit_Fixed
;
specs
[
i
]
.
mValue
=
0
;
if
(
end
>
start
)
{
size_t
numberEnd
=
end
;
char16_t
ch
=
spec
.
CharAt
(
numberEnd
-
1
)
;
if
(
sAster
=
=
ch
)
{
specs
[
i
]
.
mUnit
=
eFramesetUnit_Relative
;
numberEnd
-
-
;
}
else
if
(
sPercent
=
=
ch
)
{
specs
[
i
]
.
mUnit
=
eFramesetUnit_Percent
;
numberEnd
-
-
;
if
(
numberEnd
>
start
)
{
ch
=
spec
.
CharAt
(
numberEnd
-
1
)
;
if
(
sAster
=
=
ch
)
{
specs
[
i
]
.
mUnit
=
eFramesetUnit_Relative
;
numberEnd
-
-
;
}
}
}
nsAutoString
token
;
spec
.
Mid
(
token
start
numberEnd
-
start
)
;
if
(
(
eFramesetUnit_Relative
=
=
specs
[
i
]
.
mUnit
)
&
&
(
0
=
=
token
.
Length
(
)
)
)
{
specs
[
i
]
.
mValue
=
1
;
}
else
{
nsresult
err
;
specs
[
i
]
.
mValue
=
token
.
ToInteger
(
&
err
)
;
if
(
NS_FAILED
(
err
)
)
{
specs
[
i
]
.
mValue
=
0
;
}
}
if
(
isInQuirks
)
{
if
(
(
eFramesetUnit_Relative
=
=
specs
[
i
]
.
mUnit
)
&
&
(
0
=
=
specs
[
i
]
.
mValue
)
)
{
specs
[
i
]
.
mValue
=
1
;
}
}
if
(
specs
[
i
]
.
mValue
<
0
)
{
specs
[
i
]
.
mValue
=
0
;
}
start
=
end
+
1
;
}
}
aNumSpecs
=
static_cast
<
int32_t
>
(
count
)
;
*
aSpecs
=
std
:
:
move
(
specs
)
;
return
NS_OK
;
}
bool
HTMLFrameSetElement
:
:
IsEventAttributeNameInternal
(
nsAtom
*
aName
)
{
return
nsContentUtils
:
:
IsEventAttributeName
(
aName
EventNameType_HTML
|
EventNameType_HTMLBodyOrFramesetOnly
)
;
}
#
define
EVENT
(
name_
id_
type_
struct_
)
#
define
WINDOW_EVENT_HELPER
(
name_
type_
)
\
type_
*
HTMLFrameSetElement
:
:
GetOn
#
#
name_
(
)
{
\
if
(
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
{
\
nsGlobalWindowInner
*
globalWin
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
\
return
globalWin
-
>
GetOn
#
#
name_
(
)
;
\
}
\
return
nullptr
;
\
}
\
void
HTMLFrameSetElement
:
:
SetOn
#
#
name_
(
type_
*
handler
)
{
\
nsPIDOMWindowInner
*
win
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
\
if
(
!
win
)
{
\
return
;
\
}
\
\
nsGlobalWindowInner
*
globalWin
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
\
return
globalWin
-
>
SetOn
#
#
name_
(
handler
)
;
\
}
#
define
WINDOW_EVENT
(
name_
id_
type_
struct_
)
\
WINDOW_EVENT_HELPER
(
name_
EventHandlerNonNull
)
#
define
BEFOREUNLOAD_EVENT
(
name_
id_
type_
struct_
)
\
WINDOW_EVENT_HELPER
(
name_
OnBeforeUnloadEventHandlerNonNull
)
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
BEFOREUNLOAD_EVENT
#
undef
WINDOW_EVENT
#
undef
WINDOW_EVENT_HELPER
#
undef
EVENT
}
