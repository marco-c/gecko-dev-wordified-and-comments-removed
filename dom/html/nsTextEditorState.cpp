#
include
"
nsTextEditorState
.
h
"
#
include
"
mozilla
/
TextInputListener
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsTextControlFrame
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsITransactionManager
.
h
"
#
include
"
nsIControllerContext
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIEditorObserver
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
TextEditRules
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsNumberControlFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ShortcutKeys
.
h
"
#
include
"
nsXBLPrototypeHandler
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
inline
nsresult
SetEditorFlagsIfNecessary
(
EditorBase
&
aEditorBase
uint32_t
aFlags
)
{
if
(
aEditorBase
.
Flags
(
)
=
=
aFlags
)
{
return
NS_OK
;
}
return
aEditorBase
.
SetFlags
(
aFlags
)
;
}
class
MOZ_STACK_CLASS
AutoInputEventSuppresser
final
{
public
:
explicit
AutoInputEventSuppresser
(
TextEditor
*
aTextEditor
)
:
mTextEditor
(
aTextEditor
)
mOuterTransaction
(
aTextEditor
-
>
IsSuppressingDispatchingInputEvent
(
)
)
{
MOZ_ASSERT
(
aTextEditor
)
;
}
~
AutoInputEventSuppresser
(
)
{
mTextEditor
-
>
SuppressDispatchingInputEvent
(
mOuterTransaction
)
;
}
void
Init
(
)
{
mTextEditor
-
>
SuppressDispatchingInputEvent
(
true
)
;
}
private
:
RefPtr
<
TextEditor
>
mTextEditor
;
bool
mOuterTransaction
;
}
;
class
RestoreSelectionState
:
public
Runnable
{
public
:
RestoreSelectionState
(
nsTextEditorState
*
aState
nsTextControlFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
RestoreSelectionState
"
)
mFrame
(
aFrame
)
mTextEditorState
(
aState
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
!
mTextEditorState
)
{
return
NS_OK
;
}
AutoHideSelectionChanges
hideSelectionChanges
(
mFrame
-
>
GetConstFrameSelection
(
)
)
;
if
(
mFrame
)
{
nsAutoScriptBlocker
scriptBlocker
;
nsTextEditorState
:
:
SelectionProperties
&
properties
=
mTextEditorState
-
>
GetSelectionProperties
(
)
;
if
(
properties
.
IsDirty
(
)
)
{
mFrame
-
>
SetSelectionRange
(
properties
.
GetStart
(
)
properties
.
GetEnd
(
)
properties
.
GetDirection
(
)
)
;
}
if
(
!
mTextEditorState
-
>
mSelectionRestoreEagerInit
)
{
mTextEditorState
-
>
HideSelectionIfBlurred
(
)
;
}
mTextEditorState
-
>
mSelectionRestoreEagerInit
=
false
;
}
if
(
mTextEditorState
)
{
mTextEditorState
-
>
FinishedRestoringSelection
(
)
;
}
return
NS_OK
;
}
void
Revoke
(
)
{
mFrame
=
nullptr
;
mTextEditorState
=
nullptr
;
}
private
:
nsTextControlFrame
*
mFrame
;
nsTextEditorState
*
mTextEditorState
;
}
;
class
MOZ_RAII
AutoRestoreEditorState
final
{
public
:
explicit
AutoRestoreEditorState
(
TextEditor
*
aTextEditor
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mTextEditor
(
aTextEditor
)
mSavedFlags
(
mTextEditor
-
>
Flags
(
)
)
mSavedMaxLength
(
mTextEditor
-
>
MaxTextLength
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
mTextEditor
)
;
uint32_t
flags
=
mSavedFlags
;
flags
&
=
~
(
nsIPlaintextEditor
:
:
eEditorDisabledMask
)
;
flags
&
=
~
(
nsIPlaintextEditor
:
:
eEditorReadonlyMask
)
;
flags
|
=
nsIPlaintextEditor
:
:
eEditorDontEchoPassword
;
if
(
mSavedFlags
!
=
flags
)
{
mTextEditor
-
>
SetFlags
(
flags
)
;
}
mTextEditor
-
>
SetMaxTextLength
(
-
1
)
;
}
~
AutoRestoreEditorState
(
)
{
mTextEditor
-
>
SetMaxTextLength
(
mSavedMaxLength
)
;
SetEditorFlagsIfNecessary
(
*
mTextEditor
mSavedFlags
)
;
}
private
:
TextEditor
*
mTextEditor
;
uint32_t
mSavedFlags
;
int32_t
mSavedMaxLength
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoDisableUndo
final
{
public
:
explicit
AutoDisableUndo
(
TextEditor
*
aTextEditor
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mTextEditor
(
aTextEditor
)
mNumberOfMaximumTransactions
(
0
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
mTextEditor
)
;
mNumberOfMaximumTransactions
=
mTextEditor
?
mTextEditor
-
>
NumberOfMaximumTransactions
(
)
:
0
;
DebugOnly
<
bool
>
disabledUndoRedo
=
mTextEditor
-
>
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transactions
"
)
;
}
~
AutoDisableUndo
(
)
{
if
(
mTextEditor
-
>
IsUndoRedoEnabled
(
)
)
{
return
;
}
if
(
mNumberOfMaximumTransactions
)
{
DebugOnly
<
bool
>
enabledUndoRedo
=
mTextEditor
-
>
EnableUndoRedo
(
mNumberOfMaximumTransactions
)
;
NS_WARNING_ASSERTION
(
enabledUndoRedo
"
Failed
to
enable
undo
/
redo
transactions
"
)
;
}
else
{
DebugOnly
<
bool
>
disabledUndoRedo
=
mTextEditor
-
>
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transactions
"
)
;
}
}
private
:
TextEditor
*
mTextEditor
;
int32_t
mNumberOfMaximumTransactions
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
bool
nsITextControlElement
:
:
GetWrapPropertyEnum
(
nsIContent
*
aContent
nsITextControlElement
:
:
nsHTMLTextWrap
&
aWrapProp
)
{
aWrapProp
=
eHTMLTextWrap_Soft
;
nsAutoString
wrap
;
if
(
aContent
-
>
IsHTMLElement
(
)
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
HARD
nsGkAtoms
:
:
OFF
nullptr
}
;
switch
(
aContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
wrap
strings
eIgnoreCase
)
)
{
case
0
:
aWrapProp
=
eHTMLTextWrap_Hard
;
break
;
case
1
:
aWrapProp
=
eHTMLTextWrap_Off
;
break
;
}
return
true
;
}
return
false
;
}
already_AddRefed
<
nsITextControlElement
>
nsITextControlElement
:
:
GetTextControlElementFromEditingHost
(
nsIContent
*
aHost
)
{
if
(
!
aHost
)
{
return
nullptr
;
}
nsCOMPtr
<
nsITextControlElement
>
parent
=
do_QueryInterface
(
aHost
-
>
GetParent
(
)
)
;
return
parent
.
forget
(
)
;
}
static
bool
SuppressEventHandlers
(
nsPresContext
*
aPresContext
)
{
bool
suppressHandlers
=
false
;
if
(
aPresContext
)
{
suppressHandlers
=
aPresContext
-
>
IsPaginated
(
)
;
}
return
suppressHandlers
;
}
class
nsAnonDivObserver
final
:
public
nsStubMutationObserver
{
public
:
explicit
nsAnonDivObserver
(
nsTextEditorState
*
aTextEditorState
)
:
mTextEditorState
(
aTextEditorState
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
private
:
~
nsAnonDivObserver
(
)
{
}
nsTextEditorState
*
mTextEditorState
;
}
;
class
nsTextInputSelectionImpl
final
:
public
nsSupportsWeakReference
public
nsISelectionController
{
~
nsTextInputSelectionImpl
(
)
{
}
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
nsTextInputSelectionImpl
nsISelectionController
)
nsTextInputSelectionImpl
(
nsFrameSelection
*
aSel
nsIPresShell
*
aShell
nsIContent
*
aLimiter
)
;
void
SetScrollableFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
;
nsFrameSelection
*
GetConstFrameSelection
(
)
{
return
mFrameSelection
;
}
Selection
*
GetSelection
(
SelectionType
aSelectionType
)
;
NS_IMETHOD
SetDisplaySelection
(
int16_t
toggle
)
override
;
NS_IMETHOD
GetDisplaySelection
(
int16_t
*
_retval
)
override
;
NS_IMETHOD
SetSelectionFlags
(
int16_t
aInEnable
)
override
;
NS_IMETHOD
GetSelectionFlags
(
int16_t
*
aOutEnable
)
override
;
NS_IMETHOD
GetSelectionFromScript
(
RawSelectionType
aRawSelectionType
Selection
*
*
aSelection
)
override
;
Selection
*
GetSelection
(
RawSelectionType
aRawSelectionType
)
override
;
NS_IMETHOD
ScrollSelectionIntoView
(
RawSelectionType
aRawSelectionType
int16_t
aRegion
int16_t
aFlags
)
override
;
NS_IMETHOD
RepaintSelection
(
RawSelectionType
aRawSelectionType
)
override
;
nsresult
RepaintSelection
(
nsPresContext
*
aPresContext
SelectionType
aSelectionType
)
;
NS_IMETHOD
SetCaretEnabled
(
bool
enabled
)
override
;
NS_IMETHOD
SetCaretReadOnly
(
bool
aReadOnly
)
override
;
NS_IMETHOD
GetCaretEnabled
(
bool
*
_retval
)
override
;
NS_IMETHOD
GetCaretVisible
(
bool
*
_retval
)
override
;
NS_IMETHOD
SetCaretVisibilityDuringSelection
(
bool
aVisibility
)
override
;
NS_IMETHOD
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
override
;
NS_IMETHOD
CharacterMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
CharacterExtendForDelete
(
)
override
;
NS_IMETHOD
CharacterExtendForBackspace
(
)
override
;
NS_IMETHOD
WordMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
WordExtendForDelete
(
bool
aForward
)
override
;
NS_IMETHOD
LineMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
IntraLineMove
(
bool
aForward
bool
aExtend
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
PageMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
CompleteScroll
(
bool
aForward
)
override
;
NS_IMETHOD
CompleteMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
ScrollPage
(
bool
aForward
)
override
;
NS_IMETHOD
ScrollLine
(
bool
aForward
)
override
;
NS_IMETHOD
ScrollCharacter
(
bool
aRight
)
override
;
NS_IMETHOD
SelectAll
(
void
)
override
;
NS_IMETHOD
CheckVisibility
(
nsINode
*
node
int16_t
startOffset
int16_t
EndOffset
bool
*
_retval
)
override
;
virtual
nsresult
CheckVisibilityContent
(
nsIContent
*
aNode
int16_t
aStartOffset
int16_t
aEndOffset
bool
*
aRetval
)
override
;
private
:
RefPtr
<
nsFrameSelection
>
mFrameSelection
;
nsCOMPtr
<
nsIContent
>
mLimiter
;
nsIScrollableFrame
*
mScrollFrame
;
nsWeakPtr
mPresShellWeak
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsTextInputSelectionImpl
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsTextInputSelectionImpl
)
NS_INTERFACE_TABLE_HEAD
(
nsTextInputSelectionImpl
)
NS_INTERFACE_TABLE
(
nsTextInputSelectionImpl
nsISelectionController
nsISelectionDisplay
nsISupportsWeakReference
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
nsTextInputSelectionImpl
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsTextInputSelectionImpl
mFrameSelection
mLimiter
)
nsTextInputSelectionImpl
:
:
nsTextInputSelectionImpl
(
nsFrameSelection
*
aSel
nsIPresShell
*
aShell
nsIContent
*
aLimiter
)
:
mScrollFrame
(
nullptr
)
{
if
(
aSel
&
&
aShell
)
{
mFrameSelection
=
aSel
;
mLimiter
=
aLimiter
;
bool
accessibleCaretEnabled
=
PresShell
:
:
AccessibleCaretEnabled
(
aLimiter
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
)
;
mFrameSelection
-
>
Init
(
aShell
mLimiter
accessibleCaretEnabled
)
;
mPresShellWeak
=
do_GetWeakReference
(
aShell
)
;
}
}
void
nsTextInputSelectionImpl
:
:
SetScrollableFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
{
mScrollFrame
=
aScrollableFrame
;
if
(
!
mScrollFrame
&
&
mFrameSelection
)
{
mFrameSelection
-
>
DisconnectFromPresShell
(
)
;
mFrameSelection
=
nullptr
;
}
}
Selection
*
nsTextInputSelectionImpl
:
:
GetSelection
(
SelectionType
aSelectionType
)
{
if
(
!
mFrameSelection
)
{
return
nullptr
;
}
return
mFrameSelection
-
>
GetSelection
(
aSelectionType
)
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
SetDisplaySelection
(
int16_t
aToggle
)
{
if
(
!
mFrameSelection
)
return
NS_ERROR_NULL_POINTER
;
mFrameSelection
-
>
SetDisplaySelection
(
aToggle
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
GetDisplaySelection
(
int16_t
*
aToggle
)
{
if
(
!
mFrameSelection
)
return
NS_ERROR_NULL_POINTER
;
*
aToggle
=
mFrameSelection
-
>
GetDisplaySelection
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
SetSelectionFlags
(
int16_t
aToggle
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
GetSelectionFlags
(
int16_t
*
aOutEnable
)
{
*
aOutEnable
=
nsISelectionDisplay
:
:
DISPLAY_TEXT
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
GetSelectionFromScript
(
RawSelectionType
aRawSelectionType
Selection
*
*
aSelection
)
{
if
(
!
mFrameSelection
)
return
NS_ERROR_NULL_POINTER
;
*
aSelection
=
mFrameSelection
-
>
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
if
(
!
(
*
aSelection
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
NS_ADDREF
(
*
aSelection
)
;
return
NS_OK
;
}
Selection
*
nsTextInputSelectionImpl
:
:
GetSelection
(
RawSelectionType
aRawSelectionType
)
{
return
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
ScrollSelectionIntoView
(
RawSelectionType
aRawSelectionType
int16_t
aRegion
int16_t
aFlags
)
{
if
(
!
mFrameSelection
)
return
NS_ERROR_FAILURE
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
ScrollSelectionIntoView
(
ToSelectionType
(
aRawSelectionType
)
aRegion
aFlags
)
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
RepaintSelection
(
RawSelectionType
aRawSelectionType
)
{
if
(
!
mFrameSelection
)
return
NS_ERROR_FAILURE
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
RepaintSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
nsresult
nsTextInputSelectionImpl
:
:
RepaintSelection
(
nsPresContext
*
aPresContext
SelectionType
aSelectionType
)
{
if
(
!
mFrameSelection
)
return
NS_ERROR_FAILURE
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
RepaintSelection
(
aSelectionType
)
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
SetCaretEnabled
(
bool
enabled
)
{
if
(
!
mPresShellWeak
)
return
NS_ERROR_NOT_INITIALIZED
;
nsCOMPtr
<
nsIPresShell
>
shell
=
do_QueryReferent
(
mPresShellWeak
)
;
if
(
!
shell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsISelectionController
>
selCon
=
do_QueryInterface
(
shell
)
;
if
(
!
selCon
)
return
NS_ERROR_NO_INTERFACE
;
selCon
-
>
SetCaretEnabled
(
enabled
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
SetCaretReadOnly
(
bool
aReadOnly
)
{
if
(
!
mPresShellWeak
)
return
NS_ERROR_NOT_INITIALIZED
;
nsresult
result
;
nsCOMPtr
<
nsIPresShell
>
shell
=
do_QueryReferent
(
mPresShellWeak
&
result
)
;
if
(
shell
)
{
RefPtr
<
nsCaret
>
caret
=
shell
-
>
GetCaret
(
)
;
if
(
caret
)
{
Selection
*
selection
=
mFrameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
selection
)
{
caret
-
>
SetCaretReadOnly
(
aReadOnly
)
;
}
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
GetCaretEnabled
(
bool
*
_retval
)
{
return
GetCaretVisible
(
_retval
)
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
GetCaretVisible
(
bool
*
_retval
)
{
if
(
!
mPresShellWeak
)
return
NS_ERROR_NOT_INITIALIZED
;
nsresult
result
;
nsCOMPtr
<
nsIPresShell
>
shell
=
do_QueryReferent
(
mPresShellWeak
&
result
)
;
if
(
shell
)
{
RefPtr
<
nsCaret
>
caret
=
shell
-
>
GetCaret
(
)
;
if
(
caret
)
{
*
_retval
=
caret
-
>
IsVisible
(
)
;
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
SetCaretVisibilityDuringSelection
(
bool
aVisibility
)
{
if
(
!
mPresShellWeak
)
return
NS_ERROR_NOT_INITIALIZED
;
nsresult
result
;
nsCOMPtr
<
nsIPresShell
>
shell
=
do_QueryReferent
(
mPresShellWeak
&
result
)
;
if
(
shell
)
{
RefPtr
<
nsCaret
>
caret
=
shell
-
>
GetCaret
(
)
;
if
(
caret
)
{
Selection
*
selection
=
mFrameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
selection
)
{
caret
-
>
SetVisibilityDuringSelection
(
aVisibility
)
;
}
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
PhysicalMove
(
aDirection
aAmount
aExtend
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
CharacterMove
(
bool
aForward
bool
aExtend
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
CharacterMove
(
aForward
aExtend
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
CharacterExtendForDelete
(
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
CharacterExtendForDelete
(
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
CharacterExtendForBackspace
(
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
CharacterExtendForBackspace
(
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
WordMove
(
bool
aForward
bool
aExtend
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
WordMove
(
aForward
aExtend
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
WordExtendForDelete
(
bool
aForward
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
WordExtendForDelete
(
aForward
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
LineMove
(
bool
aForward
bool
aExtend
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsresult
result
=
frameSelection
-
>
LineMove
(
aForward
aExtend
)
;
if
(
NS_FAILED
(
result
)
)
result
=
CompleteMove
(
aForward
aExtend
)
;
return
result
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
IntraLineMove
(
bool
aForward
bool
aExtend
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
IntraLineMove
(
aForward
aExtend
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
PageMove
(
bool
aForward
bool
aExtend
)
{
if
(
mScrollFrame
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
mScrollFrame
)
;
frameSelection
-
>
CommonPageMove
(
aForward
aExtend
scrollFrame
)
;
}
return
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
|
nsISelectionController
:
:
SCROLL_FOR_CARET_MOVE
)
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
CompleteScroll
(
bool
aForward
)
{
if
(
!
mScrollFrame
)
return
NS_ERROR_NOT_INITIALIZED
;
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
nsIScrollableFrame
:
:
WHOLE
nsIScrollableFrame
:
:
INSTANT
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
CompleteMove
(
bool
aForward
bool
aExtend
)
{
NS_ENSURE_STATE
(
mFrameSelection
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
nsIContent
*
parentDIV
=
frameSelection
-
>
GetLimiter
(
)
;
if
(
!
parentDIV
)
return
NS_ERROR_UNEXPECTED
;
int32_t
offset
=
0
;
CaretAssociationHint
hint
=
CARET_ASSOCIATE_BEFORE
;
if
(
aForward
)
{
offset
=
parentDIV
-
>
GetChildCount
(
)
;
if
(
offset
>
0
)
{
nsIContent
*
child
=
parentDIV
-
>
GetLastChild
(
)
;
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
-
-
offset
;
hint
=
CARET_ASSOCIATE_AFTER
;
}
}
}
frameSelection
-
>
HandleClick
(
parentDIV
offset
offset
aExtend
false
hint
)
;
return
CompleteScroll
(
aForward
)
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
ScrollPage
(
bool
aForward
)
{
if
(
!
mScrollFrame
)
return
NS_ERROR_NOT_INITIALIZED
;
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
nsIScrollableFrame
:
:
PAGES
nsIScrollableFrame
:
:
SMOOTH
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
ScrollLine
(
bool
aForward
)
{
if
(
!
mScrollFrame
)
return
NS_ERROR_NOT_INITIALIZED
;
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
nsIScrollableFrame
:
:
LINES
nsIScrollableFrame
:
:
SMOOTH
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
ScrollCharacter
(
bool
aRight
)
{
if
(
!
mScrollFrame
)
return
NS_ERROR_NOT_INITIALIZED
;
mScrollFrame
-
>
ScrollBy
(
nsIntPoint
(
aRight
?
1
:
-
1
0
)
nsIScrollableFrame
:
:
LINES
nsIScrollableFrame
:
:
SMOOTH
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
SelectAll
(
)
{
if
(
mFrameSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrameSelection
;
return
frameSelection
-
>
SelectAll
(
)
;
}
return
NS_ERROR_NULL_POINTER
;
}
NS_IMETHODIMP
nsTextInputSelectionImpl
:
:
CheckVisibility
(
nsINode
*
node
int16_t
startOffset
int16_t
EndOffset
bool
*
_retval
)
{
if
(
!
mPresShellWeak
)
return
NS_ERROR_NOT_INITIALIZED
;
nsresult
result
;
nsCOMPtr
<
nsISelectionController
>
shell
=
do_QueryReferent
(
mPresShellWeak
&
result
)
;
if
(
shell
)
{
return
shell
-
>
CheckVisibility
(
node
startOffset
EndOffset
_retval
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsTextInputSelectionImpl
:
:
CheckVisibilityContent
(
nsIContent
*
aNode
int16_t
aStartOffset
int16_t
aEndOffset
bool
*
aRetval
)
{
if
(
!
mPresShellWeak
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsCOMPtr
<
nsISelectionController
>
shell
=
do_QueryReferent
(
mPresShellWeak
)
;
NS_ENSURE_TRUE
(
shell
NS_ERROR_FAILURE
)
;
return
shell
-
>
CheckVisibilityContent
(
aNode
aStartOffset
aEndOffset
aRetval
)
;
}
TextInputListener
:
:
TextInputListener
(
nsITextControlElement
*
aTxtCtrlElement
)
:
mFrame
(
nullptr
)
mTxtCtrlElement
(
aTxtCtrlElement
)
mSelectionWasCollapsed
(
true
)
mHadUndoItems
(
false
)
mHadRedoItems
(
false
)
mSettingValue
(
false
)
mSetValueChanged
(
true
)
mListeningToSelectionChange
(
false
)
{
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TextInputListener
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TextInputListener
)
NS_INTERFACE_MAP_BEGIN
(
TextInputListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
TextInputListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_0
(
TextInputListener
)
void
TextInputListener
:
:
OnSelectionChange
(
Selection
&
aSelection
int16_t
aReason
)
{
if
(
!
mListeningToSelectionChange
)
{
return
;
}
AutoWeakFrame
weakFrame
=
mFrame
;
bool
collapsed
=
aSelection
.
IsCollapsed
(
)
;
if
(
!
collapsed
&
&
(
aReason
&
(
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
)
)
)
{
nsIContent
*
content
=
mFrame
-
>
GetContent
(
)
;
if
(
content
)
{
nsCOMPtr
<
Document
>
doc
=
content
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
doc
-
>
GetShell
(
)
;
if
(
presShell
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
eFormSelect
)
;
presShell
-
>
HandleEventWithTarget
(
&
event
mFrame
content
&
status
)
;
}
}
}
}
if
(
collapsed
=
=
mSelectionWasCollapsed
)
{
return
;
}
mSelectionWasCollapsed
=
collapsed
;
if
(
!
weakFrame
.
IsAlive
(
)
|
|
!
mFrame
|
|
!
nsContentUtils
:
:
IsFocusedContent
(
mFrame
-
>
GetContent
(
)
)
)
{
return
;
}
UpdateTextInputCommands
(
NS_LITERAL_STRING
(
"
select
"
)
&
aSelection
aReason
)
;
}
static
void
DoCommandCallback
(
Command
aCommand
void
*
aData
)
{
nsTextControlFrame
*
frame
=
static_cast
<
nsTextControlFrame
*
>
(
aData
)
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
nsCOMPtr
<
nsIControllers
>
controllers
;
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
content
)
;
if
(
input
)
{
input
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
else
{
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
content
)
;
if
(
textArea
)
{
textArea
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
}
if
(
!
controllers
)
{
NS_WARNING
(
"
Could
not
get
controllers
"
)
;
return
;
}
const
char
*
commandStr
=
WidgetKeyboardEvent
:
:
GetCommandStr
(
aCommand
)
;
nsCOMPtr
<
nsIController
>
controller
;
controllers
-
>
GetControllerForCommand
(
commandStr
getter_AddRefs
(
controller
)
)
;
if
(
!
controller
)
{
return
;
}
bool
commandEnabled
;
nsresult
rv
=
controller
-
>
IsCommandEnabled
(
commandStr
&
commandEnabled
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
commandEnabled
)
{
controller
-
>
DoCommand
(
commandStr
)
;
}
}
NS_IMETHODIMP
TextInputListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
if
(
aEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
if
(
!
aEvent
-
>
IsTrusted
(
)
)
{
return
NS_OK
;
}
RefPtr
<
KeyboardEvent
>
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
if
(
!
keyEvent
)
{
return
NS_ERROR_UNEXPECTED
;
}
WidgetKeyboardEvent
*
widgetKeyEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
!
keyEvent
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsXBLPrototypeHandler
*
keyHandlers
=
ShortcutKeys
:
:
GetHandlers
(
mTxtCtrlElement
-
>
IsTextArea
(
)
?
HandlerType
:
:
eTextArea
:
HandlerType
:
:
eInput
)
;
RefPtr
<
nsAtom
>
eventTypeAtom
=
ShortcutKeys
:
:
ConvertEventToDOMEventType
(
widgetKeyEvent
)
;
for
(
nsXBLPrototypeHandler
*
handler
=
keyHandlers
;
handler
;
handler
=
handler
-
>
GetNextHandler
(
)
)
{
if
(
!
handler
-
>
EventTypeEquals
(
eventTypeAtom
)
)
{
continue
;
}
if
(
!
handler
-
>
KeyEventMatched
(
keyEvent
0
IgnoreModifierState
(
)
)
)
{
continue
;
}
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
mTxtCtrlElement
)
;
nsresult
rv
=
handler
-
>
ExecuteHandler
(
target
aEvent
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
}
if
(
widgetKeyEvent
-
>
mMessage
!
=
eKeyPress
)
{
return
NS_OK
;
}
nsIWidget
:
:
NativeKeyBindingsType
nativeKeyBindingsType
=
mTxtCtrlElement
-
>
IsTextArea
(
)
?
nsIWidget
:
:
NativeKeyBindingsForMultiLineEditor
:
nsIWidget
:
:
NativeKeyBindingsForSingleLineEditor
;
nsIWidget
*
widget
=
widgetKeyEvent
-
>
mWidget
;
if
(
!
widget
)
{
widget
=
mFrame
-
>
GetNearestWidget
(
)
;
NS_ENSURE_TRUE
(
widget
NS_OK
)
;
}
AutoRestore
<
nsCOMPtr
<
nsIWidget
>
>
saveWidget
(
widgetKeyEvent
-
>
mWidget
)
;
widgetKeyEvent
-
>
mWidget
=
widget
;
if
(
widgetKeyEvent
-
>
ExecuteEditCommands
(
nativeKeyBindingsType
DoCommandCallback
mFrame
)
)
{
aEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
void
TextInputListener
:
:
OnEditActionHandled
(
)
{
if
(
!
mFrame
)
{
return
;
}
AutoWeakFrame
weakFrame
=
mFrame
;
nsITextControlFrame
*
frameBase
=
do_QueryFrame
(
mFrame
)
;
nsTextControlFrame
*
frame
=
static_cast
<
nsTextControlFrame
*
>
(
frameBase
)
;
NS_ASSERTION
(
frame
"
Where
is
our
frame
?
"
)
;
RefPtr
<
TextEditor
>
textEditor
=
frame
-
>
GetTextEditor
(
)
;
size_t
numUndoItems
=
textEditor
-
>
NumberOfUndoItems
(
)
;
size_t
numRedoItems
=
textEditor
-
>
NumberOfRedoItems
(
)
;
if
(
(
numUndoItems
&
&
!
mHadUndoItems
)
|
|
(
!
numUndoItems
&
&
mHadUndoItems
)
|
|
(
numRedoItems
&
&
!
mHadRedoItems
)
|
|
(
!
numRedoItems
&
&
mHadRedoItems
)
)
{
UpdateTextInputCommands
(
NS_LITERAL_STRING
(
"
undo
"
)
)
;
mHadUndoItems
=
numUndoItems
!
=
0
;
mHadRedoItems
=
numRedoItems
!
=
0
;
}
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
HandleValueChanged
(
frame
)
;
}
void
TextInputListener
:
:
HandleValueChanged
(
nsTextControlFrame
*
aFrame
)
{
if
(
mSetValueChanged
)
{
if
(
!
aFrame
)
{
nsITextControlFrame
*
frameBase
=
do_QueryFrame
(
mFrame
)
;
aFrame
=
static_cast
<
nsTextControlFrame
*
>
(
frameBase
)
;
NS_ASSERTION
(
aFrame
"
Where
is
our
frame
?
"
)
;
}
aFrame
-
>
SetValueChanged
(
true
)
;
}
if
(
!
mSettingValue
)
{
mTxtCtrlElement
-
>
OnValueChanged
(
true
true
)
;
}
}
nsresult
TextInputListener
:
:
UpdateTextInputCommands
(
const
nsAString
&
aCommandsToUpdate
Selection
*
aSelection
int16_t
aReason
)
{
nsIContent
*
content
=
mFrame
-
>
GetContent
(
)
;
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
Document
>
doc
=
content
-
>
GetComposedDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsPIDOMWindowOuter
*
domWindow
=
doc
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
domWindow
NS_ERROR_FAILURE
)
;
domWindow
-
>
UpdateCommands
(
aCommandsToUpdate
aSelection
aReason
)
;
return
NS_OK
;
}
nsTextEditorState
:
:
nsTextEditorState
(
nsITextControlElement
*
aOwningElement
)
:
mTextCtrlElement
(
aOwningElement
)
mBoundFrame
(
nullptr
)
mEverInited
(
false
)
mEditorInitialized
(
false
)
mInitializing
(
false
)
mValueTransferInProgress
(
false
)
mSelectionCached
(
true
)
mSelectionRestoreEagerInit
(
false
)
mPlaceholderVisibility
(
false
)
mPreviewVisibility
(
false
)
mIsCommittingComposition
(
false
)
{
MOZ_COUNT_CTOR
(
nsTextEditorState
)
;
}
nsTextEditorState
*
nsTextEditorState
:
:
Construct
(
nsITextControlElement
*
aOwningElement
nsTextEditorState
*
*
aReusedState
)
{
if
(
*
aReusedState
)
{
nsTextEditorState
*
state
=
*
aReusedState
;
*
aReusedState
=
nullptr
;
state
-
>
mTextCtrlElement
=
aOwningElement
;
state
-
>
mBoundFrame
=
nullptr
;
state
-
>
mSelectionProperties
=
SelectionProperties
(
)
;
state
-
>
mEverInited
=
false
;
state
-
>
mEditorInitialized
=
false
;
state
-
>
mInitializing
=
false
;
state
-
>
mValueTransferInProgress
=
false
;
state
-
>
mSelectionCached
=
true
;
state
-
>
mSelectionRestoreEagerInit
=
false
;
state
-
>
mPlaceholderVisibility
=
false
;
state
-
>
mPreviewVisibility
=
false
;
state
-
>
mIsCommittingComposition
=
false
;
return
state
;
}
return
new
nsTextEditorState
(
aOwningElement
)
;
}
nsTextEditorState
:
:
~
nsTextEditorState
(
)
{
MOZ_COUNT_DTOR
(
nsTextEditorState
)
;
Clear
(
)
;
}
Element
*
nsTextEditorState
:
:
GetRootNode
(
)
{
return
mBoundFrame
?
mBoundFrame
-
>
GetRootNode
(
)
:
nullptr
;
}
Element
*
nsTextEditorState
:
:
GetPreviewNode
(
)
{
return
mBoundFrame
?
mBoundFrame
-
>
GetPreviewNode
(
)
:
nullptr
;
}
void
nsTextEditorState
:
:
Clear
(
)
{
if
(
mTextEditor
)
{
mTextEditor
-
>
SetTextInputListener
(
nullptr
)
;
}
if
(
mBoundFrame
)
{
UnbindFromFrame
(
mBoundFrame
)
;
mTextEditor
=
nullptr
;
}
else
{
DestroyEditor
(
)
;
}
mTextListener
=
nullptr
;
}
void
nsTextEditorState
:
:
Unlink
(
)
{
nsTextEditorState
*
tmp
=
this
;
tmp
-
>
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelCon
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTextEditor
)
}
void
nsTextEditorState
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
{
nsTextEditorState
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelCon
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTextEditor
)
}
nsFrameSelection
*
nsTextEditorState
:
:
GetConstFrameSelection
(
)
{
if
(
mSelCon
)
return
mSelCon
-
>
GetConstFrameSelection
(
)
;
return
nullptr
;
}
TextEditor
*
nsTextEditorState
:
:
GetTextEditor
(
)
{
if
(
!
mTextEditor
)
{
nsresult
rv
=
PrepareEditor
(
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
return
mTextEditor
;
}
TextEditor
*
nsTextEditorState
:
:
GetTextEditorWithoutCreation
(
)
{
return
mTextEditor
;
}
nsISelectionController
*
nsTextEditorState
:
:
GetSelectionController
(
)
const
{
return
mSelCon
;
}
class
PrepareEditorEvent
:
public
Runnable
{
public
:
PrepareEditorEvent
(
nsTextEditorState
&
aState
nsIContent
*
aOwnerContent
const
nsAString
&
aCurrentValue
)
:
mozilla
:
:
Runnable
(
"
PrepareEditorEvent
"
)
mState
(
&
aState
)
mOwnerContent
(
aOwnerContent
)
mCurrentValue
(
aCurrentValue
)
{
aState
.
mValueTransferInProgress
=
true
;
}
NS_IMETHOD
Run
(
)
override
{
NS_ENSURE_TRUE
(
mState
NS_ERROR_NULL_POINTER
)
;
const
nsAString
*
value
=
nullptr
;
if
(
!
mCurrentValue
.
IsEmpty
(
)
)
{
value
=
&
mCurrentValue
;
}
nsAutoScriptBlocker
scriptBlocker
;
mState
-
>
PrepareEditor
(
value
)
;
mState
-
>
mValueTransferInProgress
=
false
;
return
NS_OK
;
}
private
:
WeakPtr
<
nsTextEditorState
>
mState
;
nsCOMPtr
<
nsIContent
>
mOwnerContent
;
nsAutoString
mCurrentValue
;
}
;
nsresult
nsTextEditorState
:
:
BindToFrame
(
nsTextControlFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
"
The
frame
to
bind
to
should
be
valid
"
)
;
NS_ENSURE_ARG_POINTER
(
aFrame
)
;
NS_ASSERTION
(
!
mBoundFrame
"
Cannot
bind
twice
need
to
unbind
first
"
)
;
NS_ENSURE_TRUE
(
!
mBoundFrame
NS_ERROR_FAILURE
)
;
nsAutoString
currentValue
;
if
(
mTextEditor
)
{
GetValue
(
currentValue
true
)
;
}
mBoundFrame
=
aFrame
;
Element
*
rootNode
=
aFrame
-
>
GetRootNode
(
)
;
MOZ_ASSERT
(
rootNode
)
;
nsIPresShell
*
shell
=
aFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
shell
)
;
RefPtr
<
nsFrameSelection
>
frameSel
=
new
nsFrameSelection
(
)
;
mSelCon
=
new
nsTextInputSelectionImpl
(
frameSel
shell
rootNode
)
;
MOZ_ASSERT
(
!
mTextListener
"
Should
not
overwrite
the
object
"
)
;
mTextListener
=
new
TextInputListener
(
mTextCtrlElement
)
;
mTextListener
-
>
SetFrame
(
mBoundFrame
)
;
mSelCon
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
Selection
*
selection
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
selection
)
{
RefPtr
<
nsCaret
>
caret
=
shell
-
>
GetCaret
(
)
;
if
(
caret
)
{
selection
-
>
AddSelectionListener
(
caret
)
;
}
mTextListener
-
>
StartToListenToSelectionChange
(
)
;
}
if
(
mTextEditor
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mTextCtrlElement
)
;
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
if
(
mTextEditor
-
>
IsRightToLeft
(
)
)
{
rootNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
NS_LITERAL_STRING
(
"
rtl
"
)
false
)
;
}
else
if
(
mTextEditor
-
>
IsLeftToRight
(
)
)
{
rootNode
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
NS_LITERAL_STRING
(
"
ltr
"
)
false
)
;
}
else
{
}
nsContentUtils
:
:
AddScriptRunner
(
new
PrepareEditorEvent
(
*
this
content
currentValue
)
)
;
}
return
NS_OK
;
}
struct
PreDestroyer
{
void
Init
(
TextEditor
*
aTextEditor
)
{
mTextEditor
=
aTextEditor
;
}
~
PreDestroyer
(
)
{
if
(
mTextEditor
)
{
mTextEditor
-
>
PreDestroy
(
true
)
;
}
}
void
Swap
(
RefPtr
<
TextEditor
>
&
aTextEditor
)
{
return
mTextEditor
.
swap
(
aTextEditor
)
;
}
private
:
RefPtr
<
TextEditor
>
mTextEditor
;
}
;
nsresult
nsTextEditorState
:
:
PrepareEditor
(
const
nsAString
*
aValue
)
{
if
(
!
mBoundFrame
)
{
return
NS_OK
;
}
if
(
mEditorInitialized
)
{
return
NS_OK
;
}
AutoHideSelectionChanges
hideSelectionChanges
(
GetConstFrameSelection
(
)
)
;
InitializationGuard
guard
(
*
this
)
;
if
(
guard
.
IsInitializingRecursively
(
)
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
nsPresContext
*
presContext
=
mBoundFrame
-
>
PresContext
(
)
;
nsIPresShell
*
shell
=
presContext
-
>
GetPresShell
(
)
;
uint32_t
editorFlags
=
nsIPlaintextEditor
:
:
eEditorPlaintextMask
;
if
(
IsSingleLineTextControl
(
)
)
editorFlags
|
=
nsIPlaintextEditor
:
:
eEditorSingleLineMask
;
if
(
IsPasswordTextControl
(
)
)
editorFlags
|
=
nsIPlaintextEditor
:
:
eEditorPasswordMask
;
editorFlags
|
=
nsIPlaintextEditor
:
:
eEditorWidgetMask
;
editorFlags
|
=
nsIPlaintextEditor
:
:
eEditorSkipSpellCheck
;
bool
shouldInitializeEditor
=
false
;
RefPtr
<
TextEditor
>
newTextEditor
;
nsresult
rv
=
NS_OK
;
PreDestroyer
preDestroyer
;
if
(
!
mTextEditor
)
{
shouldInitializeEditor
=
true
;
newTextEditor
=
new
TextEditor
(
)
;
preDestroyer
.
Init
(
newTextEditor
)
;
rv
=
mBoundFrame
-
>
UpdateValueDisplay
(
true
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
aValue
|
|
!
mEditorInitialized
)
{
rv
=
mBoundFrame
-
>
UpdateValueDisplay
(
true
!
mEditorInitialized
aValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
newTextEditor
=
mTextEditor
;
if
(
newTextEditor
-
>
IsMailEditor
(
)
)
{
editorFlags
|
=
nsIPlaintextEditor
:
:
eEditorMailMask
;
}
}
nsAutoString
defaultValue
;
if
(
aValue
)
{
defaultValue
=
*
aValue
;
}
else
{
GetValue
(
defaultValue
true
)
;
}
if
(
!
mEditorInitialized
)
{
nsCOMPtr
<
Document
>
doc
=
shell
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoNoJSAPI
nojsapi
;
rv
=
newTextEditor
-
>
Init
(
*
doc
GetRootNode
(
)
mSelCon
editorFlags
defaultValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
SuppressEventHandlers
(
presContext
)
)
{
nsCOMPtr
<
nsIControllers
>
controllers
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mTextCtrlElement
)
;
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNodeOrNull
(
content
)
;
if
(
inputElement
)
{
rv
=
inputElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
else
{
HTMLTextAreaElement
*
textAreaElement
=
HTMLTextAreaElement
:
:
FromNodeOrNull
(
content
)
;
if
(
!
textAreaElement
)
return
NS_ERROR_FAILURE
;
rv
=
textAreaElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
controllers
)
{
uint32_t
numControllers
;
bool
found
=
false
;
rv
=
controllers
-
>
GetControllerCount
(
&
numControllers
)
;
for
(
uint32_t
i
=
0
;
i
<
numControllers
;
i
+
+
)
{
nsCOMPtr
<
nsIController
>
controller
;
rv
=
controllers
-
>
GetControllerAt
(
i
getter_AddRefs
(
controller
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
controller
)
{
nsCOMPtr
<
nsIControllerContext
>
editController
=
do_QueryInterface
(
controller
)
;
if
(
editController
)
{
editController
-
>
SetCommandContext
(
static_cast
<
nsIEditor
*
>
(
newTextEditor
)
)
;
found
=
true
;
}
}
}
if
(
!
found
)
rv
=
NS_ERROR_FAILURE
;
}
}
if
(
shouldInitializeEditor
)
{
newTextEditor
-
>
SetWrapColumn
(
GetWrapCols
(
)
)
;
}
newTextEditor
-
>
SetMaxTextLength
(
GetMaxLength
(
)
)
;
if
(
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
mTextCtrlElement
)
)
{
editorFlags
=
newTextEditor
-
>
Flags
(
)
;
if
(
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
)
)
editorFlags
|
=
nsIPlaintextEditor
:
:
eEditorReadonlyMask
;
if
(
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
)
)
editorFlags
|
=
nsIPlaintextEditor
:
:
eEditorDisabledMask
;
if
(
newTextEditor
-
>
IsDisabled
(
)
)
{
mSelCon
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_OFF
)
;
}
SetEditorFlagsIfNecessary
(
*
newTextEditor
editorFlags
)
;
}
if
(
shouldInitializeEditor
)
{
preDestroyer
.
Swap
(
mTextEditor
)
;
}
if
(
!
defaultValue
.
IsEmpty
(
)
)
{
rv
=
SetEditorFlagsIfNecessary
(
*
newTextEditor
editorFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
success
=
SetValue
(
defaultValue
eSetValue_Internal
)
;
NS_ENSURE_TRUE
(
success
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
SetEditorFlagsIfNecessary
(
*
newTextEditor
editorFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
if
(
IsPasswordTextControl
(
)
)
{
DebugOnly
<
bool
>
disabledUndoRedo
=
newTextEditor
-
>
DisableUndoRedo
(
)
;
NS_WARNING_ASSERTION
(
disabledUndoRedo
"
Failed
to
disable
undo
/
redo
transaction
"
)
;
}
else
{
DebugOnly
<
bool
>
enabledUndoRedo
=
newTextEditor
-
>
EnableUndoRedo
(
nsITextControlElement
:
:
DEFAULT_UNDO_CAP
)
;
NS_WARNING_ASSERTION
(
enabledUndoRedo
"
Failed
to
enable
undo
/
redo
transaction
"
)
;
}
if
(
!
mEditorInitialized
)
{
newTextEditor
-
>
PostCreate
(
)
;
mEverInited
=
true
;
mEditorInitialized
=
true
;
}
if
(
mTextListener
)
{
newTextEditor
-
>
SetTextInputListener
(
mTextListener
)
;
}
HTMLInputElement
*
number
=
GetParentNumberControl
(
mBoundFrame
)
;
if
(
number
?
number
-
>
IsSelectionCached
(
)
:
mSelectionCached
)
{
if
(
mRestoringSelection
)
mRestoringSelection
-
>
Revoke
(
)
;
mRestoringSelection
=
new
RestoreSelectionState
(
this
mBoundFrame
)
;
if
(
mRestoringSelection
)
{
nsContentUtils
:
:
AddScriptRunner
(
mRestoringSelection
)
;
}
}
if
(
number
)
{
number
-
>
ClearSelectionCached
(
)
;
}
else
{
mSelectionCached
=
false
;
}
return
rv
;
}
void
nsTextEditorState
:
:
FinishedRestoringSelection
(
)
{
mRestoringSelection
=
nullptr
;
}
bool
nsTextEditorState
:
:
IsSelectionCached
(
)
const
{
if
(
mBoundFrame
)
{
HTMLInputElement
*
number
=
GetParentNumberControl
(
mBoundFrame
)
;
if
(
number
)
{
return
number
-
>
IsSelectionCached
(
)
;
}
}
return
mSelectionCached
;
}
nsTextEditorState
:
:
SelectionProperties
&
nsTextEditorState
:
:
GetSelectionProperties
(
)
{
if
(
mBoundFrame
)
{
HTMLInputElement
*
number
=
GetParentNumberControl
(
mBoundFrame
)
;
if
(
number
)
{
return
number
-
>
GetSelectionProperties
(
)
;
}
}
return
mSelectionProperties
;
}
void
nsTextEditorState
:
:
SyncUpSelectionPropertiesBeforeDestruction
(
)
{
if
(
mBoundFrame
)
{
UnbindFromFrame
(
mBoundFrame
)
;
}
}
void
nsTextEditorState
:
:
SetSelectionProperties
(
nsTextEditorState
:
:
SelectionProperties
&
aProps
)
{
if
(
mBoundFrame
)
{
mBoundFrame
-
>
SetSelectionRange
(
aProps
.
GetStart
(
)
aProps
.
GetEnd
(
)
aProps
.
GetDirection
(
)
)
;
}
else
{
mSelectionProperties
=
aProps
;
}
}
void
nsTextEditorState
:
:
GetSelectionRange
(
uint32_t
*
aSelectionStart
uint32_t
*
aSelectionEnd
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aSelectionStart
)
;
MOZ_ASSERT
(
aSelectionEnd
)
;
MOZ_ASSERT
(
IsSelectionCached
(
)
|
|
GetSelectionController
(
)
"
How
can
we
not
have
a
cached
selection
if
we
have
no
selection
"
"
controller
?
"
)
;
if
(
IsSelectionCached
(
)
)
{
const
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
*
aSelectionStart
=
props
.
GetStart
(
)
;
*
aSelectionEnd
=
props
.
GetEnd
(
)
;
return
;
}
Selection
*
sel
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
NS_WARN_IF
(
!
sel
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
mozilla
:
:
dom
:
:
Element
*
root
=
GetRootNode
(
)
;
if
(
NS_WARN_IF
(
!
root
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
nsContentUtils
:
:
GetSelectionInTextControl
(
sel
root
*
aSelectionStart
*
aSelectionEnd
)
;
}
nsITextControlFrame
:
:
SelectionDirection
nsTextEditorState
:
:
GetSelectionDirection
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsSelectionCached
(
)
|
|
GetSelectionController
(
)
"
How
can
we
not
have
a
cached
selection
if
we
have
no
selection
"
"
controller
?
"
)
;
if
(
IsSelectionCached
(
)
)
{
return
GetSelectionProperties
(
)
.
GetDirection
(
)
;
}
Selection
*
sel
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
NS_WARN_IF
(
!
sel
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nsITextControlFrame
:
:
eForward
;
}
nsDirection
direction
=
sel
-
>
GetDirection
(
)
;
if
(
direction
=
=
eDirNext
)
{
return
nsITextControlFrame
:
:
eForward
;
}
MOZ_ASSERT
(
direction
=
=
eDirPrevious
)
;
return
nsITextControlFrame
:
:
eBackward
;
}
void
nsTextEditorState
:
:
SetSelectionRange
(
uint32_t
aStart
uint32_t
aEnd
nsITextControlFrame
:
:
SelectionDirection
aDirection
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsSelectionCached
(
)
|
|
mBoundFrame
"
How
can
we
have
a
non
-
cached
selection
but
no
frame
?
"
)
;
if
(
aStart
>
aEnd
)
{
aStart
=
aEnd
;
}
bool
changed
=
false
;
nsresult
rv
=
NS_OK
;
if
(
IsSelectionCached
(
)
)
{
nsAutoString
value
;
GetValue
(
value
false
)
;
uint32_t
length
=
value
.
Length
(
)
;
if
(
aStart
>
length
)
{
aStart
=
length
;
}
if
(
aEnd
>
length
)
{
aEnd
=
length
;
}
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
changed
=
props
.
GetStart
(
)
!
=
aStart
|
|
props
.
GetEnd
(
)
!
=
aEnd
|
|
props
.
GetDirection
(
)
!
=
aDirection
;
props
.
SetStart
(
aStart
)
;
props
.
SetEnd
(
aEnd
)
;
props
.
SetDirection
(
aDirection
)
;
}
else
{
WeakPtr
<
nsTextEditorState
>
self
(
this
)
;
aRv
=
mBoundFrame
-
>
SetSelectionRange
(
aStart
aEnd
aDirection
)
;
if
(
aRv
.
Failed
(
)
|
|
!
self
.
get
(
)
)
{
return
;
}
rv
=
mBoundFrame
-
>
ScrollSelectionIntoView
(
)
;
changed
=
true
;
}
if
(
changed
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
mTextCtrlElement
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
node
NS_LITERAL_STRING
(
"
select
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
void
nsTextEditorState
:
:
SetSelectionStart
(
const
Nullable
<
uint32_t
>
&
aStart
ErrorResult
&
aRv
)
{
uint32_t
start
=
0
;
if
(
!
aStart
.
IsNull
(
)
)
{
start
=
aStart
.
Value
(
)
;
}
uint32_t
ignored
end
;
GetSelectionRange
(
&
ignored
&
end
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
nsITextControlFrame
:
:
SelectionDirection
dir
=
GetSelectionDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
end
<
start
)
{
end
=
start
;
}
SetSelectionRange
(
start
end
dir
aRv
)
;
}
void
nsTextEditorState
:
:
SetSelectionEnd
(
const
Nullable
<
uint32_t
>
&
aEnd
ErrorResult
&
aRv
)
{
uint32_t
end
=
0
;
if
(
!
aEnd
.
IsNull
(
)
)
{
end
=
aEnd
.
Value
(
)
;
}
uint32_t
start
ignored
;
GetSelectionRange
(
&
start
&
ignored
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
nsITextControlFrame
:
:
SelectionDirection
dir
=
GetSelectionDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetSelectionRange
(
start
end
dir
aRv
)
;
}
static
void
DirectionToName
(
nsITextControlFrame
:
:
SelectionDirection
dir
nsAString
&
aDirection
)
{
if
(
dir
=
=
nsITextControlFrame
:
:
eNone
)
{
NS_WARNING
(
"
We
don
'
t
actually
support
this
.
.
.
how
did
we
get
it
?
"
)
;
aDirection
.
AssignLiteral
(
"
none
"
)
;
}
else
if
(
dir
=
=
nsITextControlFrame
:
:
eForward
)
{
aDirection
.
AssignLiteral
(
"
forward
"
)
;
}
else
if
(
dir
=
=
nsITextControlFrame
:
:
eBackward
)
{
aDirection
.
AssignLiteral
(
"
backward
"
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
SelectionDirection
value
"
)
;
}
}
void
nsTextEditorState
:
:
GetSelectionDirectionString
(
nsAString
&
aDirection
ErrorResult
&
aRv
)
{
nsITextControlFrame
:
:
SelectionDirection
dir
=
GetSelectionDirection
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
DirectionToName
(
dir
aDirection
)
;
}
static
nsITextControlFrame
:
:
SelectionDirection
DirectionStringToSelectionDirection
(
const
nsAString
&
aDirection
)
{
if
(
aDirection
.
EqualsLiteral
(
"
backward
"
)
)
{
return
nsITextControlFrame
:
:
eBackward
;
}
return
nsITextControlFrame
:
:
eForward
;
}
void
nsTextEditorState
:
:
SetSelectionDirection
(
const
nsAString
&
aDirection
ErrorResult
&
aRv
)
{
nsITextControlFrame
:
:
SelectionDirection
dir
=
DirectionStringToSelectionDirection
(
aDirection
)
;
if
(
IsSelectionCached
(
)
)
{
GetSelectionProperties
(
)
.
SetDirection
(
dir
)
;
return
;
}
uint32_t
start
end
;
GetSelectionRange
(
&
start
&
end
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetSelectionRange
(
start
end
dir
aRv
)
;
}
static
nsITextControlFrame
:
:
SelectionDirection
DirectionStringToSelectionDirection
(
const
Optional
<
nsAString
>
&
aDirection
)
{
if
(
!
aDirection
.
WasPassed
(
)
)
{
return
nsITextControlFrame
:
:
eForward
;
}
return
DirectionStringToSelectionDirection
(
aDirection
.
Value
(
)
)
;
}
void
nsTextEditorState
:
:
SetSelectionRange
(
uint32_t
aSelectionStart
uint32_t
aSelectionEnd
const
Optional
<
nsAString
>
&
aDirection
ErrorResult
&
aRv
)
{
nsITextControlFrame
:
:
SelectionDirection
dir
=
DirectionStringToSelectionDirection
(
aDirection
)
;
SetSelectionRange
(
aSelectionStart
aSelectionEnd
dir
aRv
)
;
}
void
nsTextEditorState
:
:
SetRangeText
(
const
nsAString
&
aReplacement
ErrorResult
&
aRv
)
{
uint32_t
start
end
;
GetSelectionRange
(
&
start
&
end
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SetRangeText
(
aReplacement
start
end
SelectionMode
:
:
Preserve
aRv
Some
(
start
)
Some
(
end
)
)
;
}
void
nsTextEditorState
:
:
SetRangeText
(
const
nsAString
&
aReplacement
uint32_t
aStart
uint32_t
aEnd
SelectionMode
aSelectMode
ErrorResult
&
aRv
const
Maybe
<
uint32_t
>
&
aSelectionStart
const
Maybe
<
uint32_t
>
&
aSelectionEnd
)
{
if
(
aStart
>
aEnd
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
nsAutoString
value
;
mTextCtrlElement
-
>
GetValueFromSetRangeText
(
value
)
;
uint32_t
inputValueLength
=
value
.
Length
(
)
;
if
(
aStart
>
inputValueLength
)
{
aStart
=
inputValueLength
;
}
if
(
aEnd
>
inputValueLength
)
{
aEnd
=
inputValueLength
;
}
uint32_t
selectionStart
selectionEnd
;
if
(
!
aSelectionStart
)
{
MOZ_ASSERT
(
!
aSelectionEnd
)
;
GetSelectionRange
(
&
selectionStart
&
selectionEnd
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
aSelectionEnd
)
;
selectionStart
=
*
aSelectionStart
;
selectionEnd
=
*
aSelectionEnd
;
}
MOZ_ASSERT
(
aStart
<
=
aEnd
)
;
value
.
Replace
(
aStart
aEnd
-
aStart
aReplacement
)
;
nsresult
rv
=
mTextCtrlElement
-
>
SetValueFromSetRangeText
(
value
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
uint32_t
newEnd
=
aStart
+
aReplacement
.
Length
(
)
;
int32_t
delta
=
aReplacement
.
Length
(
)
-
(
aEnd
-
aStart
)
;
switch
(
aSelectMode
)
{
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
Select
:
{
selectionStart
=
aStart
;
selectionEnd
=
newEnd
;
}
break
;
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
Start
:
{
selectionStart
=
selectionEnd
=
aStart
;
}
break
;
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
End
:
{
selectionStart
=
selectionEnd
=
newEnd
;
}
break
;
case
mozilla
:
:
dom
:
:
SelectionMode
:
:
Preserve
:
{
if
(
selectionStart
>
aEnd
)
{
selectionStart
+
=
delta
;
}
else
if
(
selectionStart
>
aStart
)
{
selectionStart
=
aStart
;
}
if
(
selectionEnd
>
aEnd
)
{
selectionEnd
+
=
delta
;
}
else
if
(
selectionEnd
>
aStart
)
{
selectionEnd
=
newEnd
;
}
}
break
;
default
:
MOZ_CRASH
(
"
Unknown
mode
!
"
)
;
}
SetSelectionRange
(
selectionStart
selectionEnd
Optional
<
nsAString
>
(
)
aRv
)
;
}
HTMLInputElement
*
nsTextEditorState
:
:
GetParentNumberControl
(
nsFrame
*
aFrame
)
const
{
MOZ_ASSERT
(
aFrame
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
MOZ_ASSERT
(
content
)
;
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
nsIContent
*
parentOfParent
=
parent
-
>
GetParent
(
)
;
if
(
!
parentOfParent
)
{
return
nullptr
;
}
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNode
(
parentOfParent
)
;
if
(
input
)
{
return
(
input
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_NUMBER
)
?
input
:
nullptr
;
}
return
nullptr
;
}
void
nsTextEditorState
:
:
DestroyEditor
(
)
{
if
(
mEditorInitialized
)
{
mTextEditor
-
>
PreDestroy
(
true
)
;
mEditorInitialized
=
false
;
}
}
void
nsTextEditorState
:
:
UnbindFromFrame
(
nsTextControlFrame
*
aFrame
)
{
NS_ENSURE_TRUE_VOID
(
mBoundFrame
)
;
MOZ_ASSERT
(
aFrame
=
=
mBoundFrame
"
Unbinding
from
the
wrong
frame
"
)
;
NS_ENSURE_TRUE_VOID
(
!
aFrame
|
|
aFrame
=
=
mBoundFrame
)
;
if
(
mTextListener
&
&
mTextEditor
&
&
mEditorInitialized
&
&
mTextEditor
-
>
IsInEditSubAction
(
)
)
{
mTextListener
-
>
OnEditActionHandled
(
)
;
}
nsAutoString
value
;
GetValue
(
value
true
)
;
if
(
mRestoringSelection
)
{
mRestoringSelection
-
>
Revoke
(
)
;
mRestoringSelection
=
nullptr
;
}
if
(
!
IsSelectionCached
(
)
)
{
uint32_t
start
=
0
end
=
0
;
GetSelectionRange
(
&
start
&
end
IgnoreErrors
(
)
)
;
nsITextControlFrame
:
:
SelectionDirection
direction
=
GetSelectionDirection
(
IgnoreErrors
(
)
)
;
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
props
.
SetStart
(
start
)
;
props
.
SetEnd
(
end
)
;
props
.
SetDirection
(
direction
)
;
HTMLInputElement
*
number
=
GetParentNumberControl
(
aFrame
)
;
if
(
number
)
{
number
-
>
SetSelectionCached
(
)
;
}
else
{
mSelectionCached
=
true
;
}
}
DestroyEditor
(
)
;
if
(
!
SuppressEventHandlers
(
mBoundFrame
-
>
PresContext
(
)
)
)
{
nsCOMPtr
<
nsIControllers
>
controllers
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mTextCtrlElement
)
;
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNodeOrNull
(
content
)
;
if
(
inputElement
)
inputElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
else
{
HTMLTextAreaElement
*
textAreaElement
=
HTMLTextAreaElement
:
:
FromNodeOrNull
(
content
)
;
if
(
textAreaElement
)
{
textAreaElement
-
>
GetControllers
(
getter_AddRefs
(
controllers
)
)
;
}
}
if
(
controllers
)
{
uint32_t
numControllers
;
nsresult
rv
=
controllers
-
>
GetControllerCount
(
&
numControllers
)
;
NS_ASSERTION
(
(
NS_SUCCEEDED
(
rv
)
)
"
bad
result
in
gfx
text
control
destructor
"
)
;
for
(
uint32_t
i
=
0
;
i
<
numControllers
;
i
+
+
)
{
nsCOMPtr
<
nsIController
>
controller
;
rv
=
controllers
-
>
GetControllerAt
(
i
getter_AddRefs
(
controller
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
controller
)
{
nsCOMPtr
<
nsIControllerContext
>
editController
=
do_QueryInterface
(
controller
)
;
if
(
editController
)
{
editController
-
>
SetCommandContext
(
nullptr
)
;
}
}
}
}
}
if
(
mSelCon
)
{
if
(
mTextListener
)
{
mTextListener
-
>
EndListeningToSelectionChange
(
)
;
}
mSelCon
-
>
SetScrollableFrame
(
nullptr
)
;
mSelCon
=
nullptr
;
}
if
(
mTextListener
)
{
mTextListener
-
>
SetFrame
(
nullptr
)
;
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
mTextCtrlElement
)
;
EventListenerManager
*
manager
=
target
-
>
GetExistingListenerManager
(
)
;
if
(
manager
)
{
manager
-
>
RemoveEventListenerByType
(
mTextListener
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
RemoveEventListenerByType
(
mTextListener
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
RemoveEventListenerByType
(
mTextListener
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
mTextListener
=
nullptr
;
}
mBoundFrame
=
nullptr
;
if
(
!
mValueTransferInProgress
)
{
bool
success
=
SetValue
(
value
eSetValue_Internal
)
;
NS_ENSURE_TRUE_VOID
(
success
)
;
}
}
int32_t
nsTextEditorState
:
:
GetMaxLength
(
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mTextCtrlElement
)
;
nsGenericHTMLElement
*
element
=
nsGenericHTMLElement
:
:
FromNodeOrNull
(
content
)
;
if
(
NS_WARN_IF
(
!
element
)
)
{
return
-
1
;
}
const
nsAttrValue
*
attr
=
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
maxlength
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
return
attr
-
>
GetIntegerValue
(
)
;
}
return
-
1
;
}
void
nsTextEditorState
:
:
GetValue
(
nsAString
&
aValue
bool
aIgnoreWrap
)
const
{
if
(
mIsCommittingComposition
)
{
aValue
=
mValueBeingSet
;
return
;
}
if
(
mTextEditor
&
&
mBoundFrame
&
&
(
mEditorInitialized
|
|
!
IsSingleLineTextControl
(
)
)
)
{
if
(
aIgnoreWrap
&
&
!
mBoundFrame
-
>
CachedValue
(
)
.
IsVoid
(
)
)
{
aValue
=
mBoundFrame
-
>
CachedValue
(
)
;
return
;
}
aValue
.
Truncate
(
)
;
uint32_t
flags
=
(
nsIDocumentEncoder
:
:
OutputLFLineBreak
|
nsIDocumentEncoder
:
:
OutputPreformatted
|
nsIDocumentEncoder
:
:
OutputPersistNBSP
|
nsIDocumentEncoder
:
:
OutputBodyOnly
)
;
if
(
!
aIgnoreWrap
)
{
nsITextControlElement
:
:
nsHTMLTextWrap
wrapProp
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mTextCtrlElement
)
;
if
(
content
&
&
nsITextControlElement
:
:
GetWrapPropertyEnum
(
content
wrapProp
)
&
&
wrapProp
=
=
nsITextControlElement
:
:
eHTMLTextWrap_Hard
)
{
flags
|
=
nsIDocumentEncoder
:
:
OutputWrap
;
}
}
{
AutoNoJSAPI
nojsapi
;
DebugOnly
<
nsresult
>
rv
=
mTextEditor
-
>
ComputeTextValue
(
flags
aValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
get
value
"
)
;
}
if
(
!
(
flags
&
nsIDocumentEncoder
:
:
OutputWrap
)
)
{
mBoundFrame
-
>
CacheValue
(
aValue
)
;
}
else
{
mBoundFrame
-
>
ClearCachedValue
(
)
;
}
}
else
{
if
(
!
mTextCtrlElement
-
>
ValueChanged
(
)
|
|
!
mValue
)
{
mTextCtrlElement
-
>
GetDefaultValueFromContent
(
aValue
)
;
}
else
{
aValue
=
*
mValue
;
}
}
}
bool
nsTextEditorState
:
:
SetValue
(
const
nsAString
&
aValue
const
nsAString
*
aOldValue
uint32_t
aFlags
)
{
nsAutoString
newValue
(
aValue
)
;
if
(
mIsCommittingComposition
)
{
mValueBeingSet
=
aValue
;
aOldValue
=
nullptr
;
}
if
(
aFlags
&
(
eSetValue_BySetUserInput
|
eSetValue_ByContent
)
)
{
if
(
EditorHasComposition
(
)
)
{
if
(
NS_WARN_IF
(
mIsCommittingComposition
)
)
{
return
true
;
}
if
(
NS_WARN_IF
(
!
mBoundFrame
)
)
{
}
else
{
nsAutoString
currentValue
;
if
(
aOldValue
)
{
#
ifdef
DEBUG
mBoundFrame
-
>
GetText
(
currentValue
)
;
MOZ_ASSERT
(
currentValue
.
Equals
(
*
aOldValue
)
)
;
#
endif
currentValue
.
Assign
(
*
aOldValue
)
;
}
else
{
mBoundFrame
-
>
GetText
(
currentValue
)
;
}
if
(
newValue
=
=
currentValue
)
{
return
true
;
}
aOldValue
=
nullptr
;
}
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
WeakPtr
<
nsTextEditorState
>
self
(
this
)
;
mValueBeingSet
=
aValue
;
mIsCommittingComposition
=
true
;
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
nsresult
rv
=
textEditor
-
>
CommitComposition
(
)
;
if
(
!
self
.
get
(
)
)
{
return
true
;
}
mIsCommittingComposition
=
false
;
newValue
=
mValueBeingSet
;
mValueBeingSet
.
Truncate
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
nsTextEditorState
failed
to
commit
composition
"
)
;
return
true
;
}
}
else
{
NS_WARNING
(
"
SetValue
(
)
is
called
when
there
is
composition
but
"
"
it
'
s
not
safe
to
request
to
commit
the
composition
"
)
;
}
}
}
if
(
!
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
newValue
fallible
)
)
{
return
false
;
}
nsCOMPtr
<
nsITextControlElement
>
textControlElement
(
mTextCtrlElement
)
;
if
(
mTextEditor
&
&
mBoundFrame
)
{
nsAutoScriptBlocker
scriptBlocker
;
#
ifdef
DEBUG
if
(
IsSingleLineTextControl
(
)
)
{
NS_ASSERTION
(
mEditorInitialized
|
|
mInitializing
"
We
should
never
try
to
use
the
editor
if
we
'
re
not
"
"
initialized
unless
we
'
re
being
initialized
"
)
;
}
#
endif
nsAutoString
currentValue
;
if
(
aOldValue
)
{
#
ifdef
DEBUG
mBoundFrame
-
>
GetText
(
currentValue
)
;
MOZ_ASSERT
(
currentValue
.
Equals
(
*
aOldValue
)
)
;
#
endif
currentValue
.
Assign
(
*
aOldValue
)
;
}
else
{
mBoundFrame
-
>
GetText
(
currentValue
)
;
}
AutoWeakFrame
weakFrame
(
mBoundFrame
)
;
if
(
!
currentValue
.
Equals
(
newValue
)
)
{
RefPtr
<
TextEditor
>
textEditor
=
mTextEditor
;
AutoInputEventSuppresser
suppressInputEventDispatching
(
textEditor
)
;
nsCOMPtr
<
Document
>
document
=
textEditor
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
true
;
}
{
AutoNoJSAPI
nojsapi
;
Selection
*
selection
=
mSelCon
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
SelectionBatcher
selectionBatcher
(
selection
)
;
if
(
NS_WARN_IF
(
!
weakFrame
.
IsAlive
(
)
)
)
{
return
true
;
}
{
AutoRestoreEditorState
restoreState
(
textEditor
)
;
mTextListener
-
>
SettingValue
(
true
)
;
bool
notifyValueChanged
=
!
!
(
aFlags
&
eSetValue_Notify
)
;
mTextListener
-
>
SetValueChanged
(
notifyValueChanged
)
;
if
(
aFlags
&
eSetValue_BySetUserInput
)
{
DebugOnly
<
nsresult
>
rv
=
textEditor
-
>
ReplaceTextAsAction
(
newValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
set
the
new
value
"
)
;
}
else
if
(
aFlags
&
eSetValue_ForXUL
)
{
suppressInputEventDispatching
.
Init
(
)
;
nsCOMPtr
<
nsISelectionController
>
kungFuDeathGrip
=
mSelCon
.
get
(
)
;
uint32_t
currentLength
=
currentValue
.
Length
(
)
;
uint32_t
newlength
=
newValue
.
Length
(
)
;
if
(
!
currentLength
|
|
!
StringBeginsWith
(
newValue
currentValue
)
)
{
currentLength
=
0
;
kungFuDeathGrip
-
>
SelectAll
(
)
;
}
else
{
mBoundFrame
-
>
SelectAllOrCollapseToEndOfText
(
false
)
;
}
const
nsAString
&
insertValue
=
StringTail
(
newValue
newlength
-
currentLength
)
;
if
(
insertValue
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
textEditor
-
>
DeleteSelectionAsAction
(
nsIEditor
:
:
eNone
nsIEditor
:
:
eStrip
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
remove
the
text
"
)
;
}
else
{
DebugOnly
<
nsresult
>
rv
=
textEditor
-
>
InsertTextAsAction
(
insertValue
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
insert
the
new
value
"
)
;
}
}
else
{
suppressInputEventDispatching
.
Init
(
)
;
AutoDisableUndo
disableUndo
(
textEditor
)
;
if
(
selection
)
{
selection
-
>
RemoveAllRangesTemporarily
(
)
;
}
textEditor
-
>
SetText
(
newValue
)
;
mTextListener
-
>
HandleValueChanged
(
)
;
}
mTextListener
-
>
SetValueChanged
(
true
)
;
mTextListener
-
>
SettingValue
(
false
)
;
if
(
!
notifyValueChanged
)
{
ValueWasChanged
(
true
)
;
}
}
if
(
!
weakFrame
.
IsAlive
(
)
)
{
if
(
!
mBoundFrame
)
{
return
SetValue
(
newValue
aFlags
&
eSetValue_Notify
)
;
}
return
true
;
}
if
(
!
mBoundFrame
-
>
CacheValue
(
newValue
fallible
)
)
{
return
false
;
}
}
}
}
else
{
if
(
!
mValue
)
{
mValue
.
emplace
(
)
;
}
if
(
!
mValue
-
>
Equals
(
newValue
)
|
|
!
nsContentUtils
:
:
SkipCursorMoveForSameValueSet
(
)
)
{
if
(
!
mValue
-
>
Assign
(
newValue
fallible
)
)
{
return
false
;
}
if
(
IsSelectionCached
(
)
)
{
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
if
(
aFlags
&
eSetValue_MoveCursorToEndIfValueChanged
)
{
props
.
SetStart
(
newValue
.
Length
(
)
)
;
props
.
SetEnd
(
newValue
.
Length
(
)
)
;
props
.
SetDirection
(
nsITextControlFrame
:
:
eForward
)
;
}
else
{
props
.
SetStart
(
std
:
:
min
(
props
.
GetStart
(
)
newValue
.
Length
(
)
)
)
;
props
.
SetEnd
(
std
:
:
min
(
props
.
GetEnd
(
)
newValue
.
Length
(
)
)
)
;
}
}
if
(
mBoundFrame
)
{
mBoundFrame
-
>
UpdateValueDisplay
(
true
)
;
}
if
(
aFlags
&
eSetValue_BySetUserInput
)
{
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
textControlElement
)
;
MOZ_ASSERT
(
element
)
;
RefPtr
<
TextEditor
>
textEditor
;
DebugOnly
<
nsresult
>
rvIgnored
=
nsContentUtils
:
:
DispatchInputEvent
(
element
EditorInputType
:
:
eInsertReplacementText
textEditor
nsContentUtils
:
:
InputEventOptions
(
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
dispatch
input
event
"
)
;
}
}
else
{
if
(
IsSelectionCached
(
)
)
{
SelectionProperties
&
props
=
GetSelectionProperties
(
)
;
props
.
SetIsDirty
(
)
;
}
}
ValueWasChanged
(
!
!
mBoundFrame
)
;
}
textControlElement
-
>
OnValueChanged
(
!
!
mBoundFrame
false
)
;
return
true
;
}
bool
nsTextEditorState
:
:
HasNonEmptyValue
(
)
{
if
(
mTextEditor
&
&
mBoundFrame
&
&
mEditorInitialized
&
&
!
mIsCommittingComposition
)
{
bool
empty
;
nsresult
rv
=
mTextEditor
-
>
IsEmpty
(
&
empty
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
!
empty
;
}
}
nsAutoString
value
;
GetValue
(
value
true
)
;
return
!
value
.
IsEmpty
(
)
;
}
void
nsTextEditorState
:
:
InitializeKeyboardEventListeners
(
)
{
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
mTextCtrlElement
)
;
EventListenerManager
*
manager
=
target
-
>
GetOrCreateListenerManager
(
)
;
if
(
manager
)
{
manager
-
>
AddEventListenerByType
(
mTextListener
NS_LITERAL_STRING
(
"
keydown
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
AddEventListenerByType
(
mTextListener
NS_LITERAL_STRING
(
"
keypress
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
manager
-
>
AddEventListenerByType
(
mTextListener
NS_LITERAL_STRING
(
"
keyup
"
)
TrustedEventsAtSystemGroupBubble
(
)
)
;
}
mSelCon
-
>
SetScrollableFrame
(
do_QueryFrame
(
mBoundFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
)
;
}
void
nsTextEditorState
:
:
ValueWasChanged
(
bool
aNotify
)
{
UpdateOverlayTextVisibility
(
aNotify
)
;
}
void
nsTextEditorState
:
:
SetPreviewText
(
const
nsAString
&
aValue
bool
aNotify
)
{
Element
*
previewDiv
=
GetPreviewNode
(
)
;
if
(
!
previewDiv
)
return
;
nsAutoString
previewValue
(
aValue
)
;
nsContentUtils
:
:
RemoveNewlines
(
previewValue
)
;
MOZ_ASSERT
(
previewDiv
-
>
GetFirstChild
(
)
"
preview
div
has
no
child
"
)
;
previewDiv
-
>
GetFirstChild
(
)
-
>
AsText
(
)
-
>
SetText
(
previewValue
aNotify
)
;
UpdateOverlayTextVisibility
(
aNotify
)
;
}
void
nsTextEditorState
:
:
GetPreviewText
(
nsAString
&
aValue
)
{
Element
*
previewDiv
=
GetPreviewNode
(
)
;
if
(
!
previewDiv
)
return
;
MOZ_ASSERT
(
previewDiv
-
>
GetFirstChild
(
)
"
preview
div
has
no
child
"
)
;
const
nsTextFragment
*
text
=
previewDiv
-
>
GetFirstChild
(
)
-
>
GetText
(
)
;
aValue
.
Truncate
(
)
;
text
-
>
AppendTo
(
aValue
)
;
}
void
nsTextEditorState
:
:
UpdateOverlayTextVisibility
(
bool
aNotify
)
{
nsAutoString
value
previewValue
;
bool
valueIsEmpty
=
!
HasNonEmptyValue
(
)
;
GetPreviewText
(
previewValue
)
;
mPreviewVisibility
=
valueIsEmpty
&
&
!
previewValue
.
IsEmpty
(
)
;
mPlaceholderVisibility
=
valueIsEmpty
&
&
previewValue
.
IsEmpty
(
)
;
if
(
mPlaceholderVisibility
&
&
!
nsContentUtils
:
:
ShowInputPlaceholderOnFocus
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mTextCtrlElement
)
;
mPlaceholderVisibility
=
!
nsContentUtils
:
:
IsFocusedContent
(
content
)
;
}
if
(
mBoundFrame
&
&
aNotify
)
{
mBoundFrame
-
>
InvalidateFrame
(
)
;
}
}
void
nsTextEditorState
:
:
HideSelectionIfBlurred
(
)
{
MOZ_ASSERT
(
mSelCon
"
Should
have
a
selection
controller
if
we
have
a
frame
!
"
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
mTextCtrlElement
)
;
if
(
!
nsContentUtils
:
:
IsFocusedContent
(
content
)
)
{
mSelCon
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
}
}
bool
nsTextEditorState
:
:
EditorHasComposition
(
)
{
return
mTextEditor
&
&
mTextEditor
-
>
IsIMEComposing
(
)
;
}
