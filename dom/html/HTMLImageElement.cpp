#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
dom
/
DOMIntersectionObserver
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
Image
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSourceElement
.
h
"
#
include
"
mozilla
/
dom
/
ResponsiveImageSelector
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsLayoutUtils
.
h
"
using
namespace
mozilla
:
:
net
;
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Image
)
#
ifdef
DEBUG
static
bool
IsPreviousSibling
(
nsINode
*
aSubject
nsINode
*
aNode
)
{
if
(
aSubject
=
=
aNode
)
{
return
false
;
}
nsINode
*
parent
=
aSubject
-
>
GetParentNode
(
)
;
if
(
parent
&
&
parent
=
=
aNode
-
>
GetParentNode
(
)
)
{
const
Maybe
<
uint32_t
>
indexOfSubject
=
parent
-
>
ComputeIndexOf
(
aSubject
)
;
const
Maybe
<
uint32_t
>
indexOfNode
=
parent
-
>
ComputeIndexOf
(
aNode
)
;
if
(
MOZ_LIKELY
(
indexOfSubject
.
isSome
(
)
&
&
indexOfNode
.
isSome
(
)
)
)
{
return
*
indexOfSubject
<
*
indexOfNode
;
}
return
indexOfSubject
.
isNothing
(
)
&
&
indexOfNode
.
isSome
(
)
;
}
return
false
;
}
#
endif
namespace
mozilla
:
:
dom
{
class
ImageLoadTask
final
:
public
MicroTaskRunnable
{
public
:
ImageLoadTask
(
HTMLImageElement
*
aElement
bool
aAlwaysLoad
bool
aUseUrgentStartForChannel
)
:
MicroTaskRunnable
(
)
mElement
(
aElement
)
mAlwaysLoad
(
aAlwaysLoad
)
mUseUrgentStartForChannel
(
aUseUrgentStartForChannel
)
{
mDocument
=
aElement
-
>
OwnerDoc
(
)
;
mDocument
-
>
BlockOnload
(
)
;
}
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
if
(
mElement
-
>
mPendingImageLoadTask
=
=
this
)
{
mElement
-
>
mPendingImageLoadTask
=
nullptr
;
mElement
-
>
mUseUrgentStartForChannel
=
mUseUrgentStartForChannel
;
mElement
-
>
LoadSelectedImage
(
true
true
mAlwaysLoad
)
;
}
mDocument
-
>
UnblockOnload
(
false
)
;
}
bool
Suppressed
(
)
override
{
nsIGlobalObject
*
global
=
mElement
-
>
GetOwnerGlobal
(
)
;
return
global
&
&
global
-
>
IsInSyncOperation
(
)
;
}
bool
AlwaysLoad
(
)
const
{
return
mAlwaysLoad
;
}
private
:
~
ImageLoadTask
(
)
=
default
;
RefPtr
<
HTMLImageElement
>
mElement
;
nsCOMPtr
<
Document
>
mDocument
;
bool
mAlwaysLoad
;
bool
mUseUrgentStartForChannel
;
}
;
HTMLImageElement
:
:
HTMLImageElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsGenericHTMLElement
(
std
:
:
move
(
aNodeInfo
)
)
mForm
(
nullptr
)
mInDocResponsiveContent
(
false
)
mCurrentDensity
(
1
.
0
)
{
AddStatesSilently
(
ElementState
:
:
BROKEN
)
;
}
HTMLImageElement
:
:
~
HTMLImageElement
(
)
{
nsImageLoadingContent
:
:
Destroy
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLImageElement
nsGenericHTMLElement
mResponsiveSelector
)
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLImageElement
nsGenericHTMLElement
nsIImageLoadingContent
imgINotificationObserver
)
NS_IMPL_ELEMENT_CLONE
(
HTMLImageElement
)
bool
HTMLImageElement
:
:
IsInteractiveHTMLContent
(
)
const
{
return
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
usemap
)
|
|
nsGenericHTMLElement
:
:
IsInteractiveHTMLContent
(
)
;
}
void
HTMLImageElement
:
:
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
{
nsImageLoadingContent
:
:
AsyncEventRunning
(
aEvent
)
;
}
void
HTMLImageElement
:
:
GetCurrentSrc
(
nsAString
&
aValue
)
{
nsCOMPtr
<
nsIURI
>
currentURI
;
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
if
(
currentURI
)
{
nsAutoCString
spec
;
currentURI
-
>
GetSpec
(
spec
)
;
CopyUTF8toUTF16
(
spec
aValue
)
;
}
else
{
SetDOMStringToNull
(
aValue
)
;
}
}
bool
HTMLImageElement
:
:
Draggable
(
)
const
{
return
!
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
draggable
nsGkAtoms
:
:
_false
eIgnoreCase
)
;
}
bool
HTMLImageElement
:
:
Complete
(
)
{
if
(
!
HasAttr
(
nsGkAtoms
:
:
srcset
)
&
&
!
HasNonEmptyAttr
(
nsGkAtoms
:
:
src
)
)
{
return
true
;
}
if
(
!
mCurrentRequest
|
|
mPendingRequest
)
{
return
false
;
}
uint32_t
status
;
mCurrentRequest
-
>
GetImageStatus
(
&
status
)
;
return
(
status
&
(
imgIRequest
:
:
STATUS_LOAD_COMPLETE
|
imgIRequest
:
:
STATUS_ERROR
)
)
!
=
0
;
}
CSSIntPoint
HTMLImageElement
:
:
GetXY
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Layout
)
;
if
(
!
frame
)
{
return
CSSIntPoint
(
0
0
)
;
}
return
CSSIntPoint
:
:
FromAppUnitsRounded
(
frame
-
>
GetOffsetTo
(
frame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
)
;
}
int32_t
HTMLImageElement
:
:
X
(
)
{
return
GetXY
(
)
.
x
;
}
int32_t
HTMLImageElement
:
:
Y
(
)
{
return
GetXY
(
)
.
y
;
}
void
HTMLImageElement
:
:
GetDecoding
(
nsAString
&
aValue
)
{
GetEnumAttr
(
nsGkAtoms
:
:
decoding
kDecodingTableDefault
-
>
tag
aValue
)
;
}
static
const
nsAttrValue
:
:
EnumTable
kLoadingTable
[
]
=
{
{
"
eager
"
HTMLImageElement
:
:
Loading
:
:
Eager
}
{
"
lazy
"
HTMLImageElement
:
:
Loading
:
:
Lazy
}
{
nullptr
0
}
}
;
void
HTMLImageElement
:
:
GetLoading
(
nsAString
&
aValue
)
const
{
GetEnumAttr
(
nsGkAtoms
:
:
loading
kLoadingTable
[
0
]
.
tag
aValue
)
;
}
HTMLImageElement
:
:
Loading
HTMLImageElement
:
:
LoadingState
(
)
const
{
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
loading
)
;
if
(
!
val
)
{
return
HTMLImageElement
:
:
Loading
:
:
Eager
;
}
return
static_cast
<
HTMLImageElement
:
:
Loading
>
(
val
-
>
GetEnumValue
(
)
)
;
}
already_AddRefed
<
Promise
>
HTMLImageElement
:
:
Decode
(
ErrorResult
&
aRv
)
{
return
nsImageLoadingContent
:
:
QueueDecodeAsync
(
aRv
)
;
}
bool
HTMLImageElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
crossorigin
)
{
ParseCORSValue
(
aValue
aResult
)
;
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
decoding
)
{
return
aResult
.
ParseEnumValue
(
aValue
kDecodingTable
false
kDecodingTableDefault
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
loading
)
{
return
aResult
.
ParseEnumValue
(
aValue
kLoadingTable
false
kLoadingTable
)
;
}
if
(
ParseImageAttribute
(
aAttribute
aValue
aResult
)
)
{
return
true
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLImageElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
MapImageAlignAttributeInto
(
aAttributes
aDecls
)
;
MapImageBorderAttributeInto
(
aAttributes
aDecls
)
;
MapImageMarginAttributeInto
(
aAttributes
aDecls
)
;
MapImageSizeAttributesInto
(
aAttributes
aDecls
MapAspectRatio
:
:
Yes
)
;
MapCommonAttributesInto
(
aAttributes
aDecls
)
;
}
nsChangeHint
HTMLImageElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
nsGenericHTMLElement
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
usemap
|
|
aAttribute
=
=
nsGkAtoms
:
:
ismap
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
alt
)
{
if
(
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
|
|
aModType
=
=
MutationEvent_Binding
:
:
REMOVAL
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
}
return
retval
;
}
NS_IMETHODIMP_
(
bool
)
HTMLImageElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sCommonAttributeMap
sImageMarginSizeAttributeMap
sImageBorderAttributeMap
sImageAlignAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLImageElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
nsresult
HTMLImageElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
mForm
&
&
(
aName
=
=
nsGkAtoms
:
:
name
|
|
aName
=
=
nsGkAtoms
:
:
id
)
)
{
nsAutoString
tmp
;
GetAttr
(
kNameSpaceID_None
aName
tmp
)
;
if
(
!
tmp
.
IsEmpty
(
)
)
{
mForm
-
>
RemoveImageElementFromTable
(
this
tmp
)
;
}
}
return
nsGenericHTMLElement
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLImageElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_None
)
{
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
nsAttrValueOrString
attrVal
(
aValue
)
;
if
(
aValue
)
{
AfterMaybeChangeAttr
(
aNameSpaceID
aName
attrVal
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
if
(
mForm
&
&
(
aName
=
=
nsGkAtoms
:
:
name
|
|
aName
=
=
nsGkAtoms
:
:
id
)
&
&
aValue
&
&
!
aValue
-
>
IsEmptyString
(
)
)
{
MOZ_ASSERT
(
aValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
"
Expected
atom
value
for
name
/
id
"
)
;
mForm
-
>
AddImageElementToTable
(
this
nsDependentAtomString
(
aValue
-
>
GetAtomValue
(
)
)
)
;
}
bool
forceReload
=
false
;
if
(
aName
=
=
nsGkAtoms
:
:
loading
&
&
!
ImageState
(
)
.
HasState
(
ElementState
:
:
LOADING
)
)
{
if
(
aValue
&
&
Loading
(
aValue
-
>
GetEnumValue
(
)
)
=
=
Loading
:
:
Lazy
)
{
SetLazyLoading
(
)
;
}
else
if
(
aOldValue
&
&
Loading
(
aOldValue
-
>
GetEnumValue
(
)
)
=
=
Loading
:
:
Lazy
)
{
StopLazyLoading
(
FromIntersectionObserver
:
:
No
StartLoading
:
:
Yes
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
src
&
&
!
aValue
)
{
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
if
(
InResponsiveMode
(
)
)
{
if
(
mResponsiveSelector
&
&
mResponsiveSelector
-
>
Content
(
)
=
=
this
)
{
mResponsiveSelector
-
>
SetDefaultSource
(
VoidString
(
)
)
;
}
QueueImageLoadTask
(
true
)
;
}
else
{
CancelImageRequests
(
aNotify
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
srcset
)
{
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
mSrcsetTriggeringPrincipal
=
aMaybeScriptedPrincipal
;
PictureSourceSrcsetChanged
(
this
attrVal
.
String
(
)
aNotify
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
sizes
)
{
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
PictureSourceSizesChanged
(
this
attrVal
.
String
(
)
aNotify
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
decoding
)
{
SetSyncDecodingHint
(
aValue
&
&
static_cast
<
ImageDecodingType
>
(
aValue
-
>
GetEnumValue
(
)
)
=
=
ImageDecodingType
:
:
Sync
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
referrerpolicy
)
{
ReferrerPolicy
referrerPolicy
=
GetReferrerPolicyAsEnum
(
)
;
forceReload
=
aNotify
&
&
!
InResponsiveMode
(
)
&
&
referrerPolicy
!
=
ReferrerPolicy
:
:
_empty
&
&
referrerPolicy
!
=
ReferrerPolicyFromAttr
(
aOldValue
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
crossorigin
)
{
forceReload
=
aNotify
&
&
GetCORSMode
(
)
!
=
AttrValueToCORSMode
(
aOldValue
)
;
}
if
(
forceReload
)
{
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
if
(
InResponsiveMode
(
)
)
{
QueueImageLoadTask
(
true
)
;
}
else
if
(
ShouldLoadImage
(
)
)
{
ForceReload
(
aNotify
IgnoreErrors
(
)
)
;
}
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
nsresult
HTMLImageElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNamespaceID
aName
aValue
nullptr
nullptr
aNotify
)
;
return
nsGenericHTMLElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
void
HTMLImageElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
if
(
aNamespaceID
!
=
kNameSpaceID_None
|
|
aName
!
=
nsGkAtoms
:
:
src
)
{
return
;
}
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
mSrcTriggeringPrincipal
=
nsContentUtils
:
:
GetAttrTriggeringPrincipal
(
this
aValue
.
String
(
)
aMaybeScriptedPrincipal
)
;
if
(
InResponsiveMode
(
)
)
{
if
(
mResponsiveSelector
&
&
mResponsiveSelector
-
>
Content
(
)
=
=
this
)
{
mResponsiveSelector
-
>
SetDefaultSource
(
aValue
.
String
(
)
mSrcTriggeringPrincipal
)
;
}
QueueImageLoadTask
(
true
)
;
}
else
if
(
aNotify
&
&
ShouldLoadImage
(
)
)
{
mNewRequestsWillNeedAnimationReset
=
true
;
LoadSelectedImage
(
true
aNotify
true
)
;
mNewRequestsWillNeedAnimationReset
=
false
;
}
}
void
HTMLImageElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
&
&
IsMap
(
)
)
{
mouseEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
bool
HTMLImageElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
int32_t
tabIndex
=
TabIndex
(
)
;
if
(
IsInComposedDoc
(
)
&
&
FindImageMap
(
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
(
sTabFocusModel
&
eTabFocus_linksMask
)
?
0
:
-
1
;
}
*
aIsFocusable
=
false
;
return
false
;
}
if
(
aTabIndex
)
{
*
aTabIndex
=
(
sTabFocusModel
&
eTabFocus_formElementsMask
)
?
tabIndex
:
-
1
;
}
*
aIsFocusable
=
IsFormControlDefaultFocusable
(
aWithMouse
)
&
&
(
tabIndex
>
=
0
|
|
GetTabIndexAttrValue
(
)
.
isSome
(
)
)
;
return
false
;
}
nsresult
HTMLImageElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsImageLoadingContent
:
:
BindToTree
(
aContext
aParent
)
;
UpdateFormOwner
(
)
;
if
(
HaveSrcsetOrInPicture
(
)
)
{
if
(
IsInComposedDoc
(
)
&
&
!
mInDocResponsiveContent
)
{
aContext
.
OwnerDoc
(
)
.
AddResponsiveContent
(
this
)
;
mInDocResponsiveContent
=
true
;
}
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
QueueImageLoadTask
(
false
)
;
}
else
if
(
!
InResponsiveMode
(
)
&
&
HasAttr
(
nsGkAtoms
:
:
src
)
)
{
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
if
(
LoadingEnabled
(
)
&
&
ShouldLoadImage
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
MaybeLoadImage
"
this
&
HTMLImageElement
:
:
MaybeLoadImage
false
)
)
;
}
}
return
rv
;
}
void
HTMLImageElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
if
(
mForm
)
{
if
(
aNullParent
|
|
!
FindAncestorForm
(
mForm
)
)
{
ClearForm
(
true
)
;
}
else
{
UnsetFlags
(
MAYBE_ORPHAN_FORM_ELEMENT
)
;
}
}
if
(
mInDocResponsiveContent
)
{
OwnerDoc
(
)
-
>
RemoveResponsiveContent
(
this
)
;
mInDocResponsiveContent
=
false
;
}
nsImageLoadingContent
:
:
UnbindFromTree
(
aNullParent
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aNullParent
)
;
}
void
HTMLImageElement
:
:
UpdateFormOwner
(
)
{
if
(
!
mForm
)
{
mForm
=
FindAncestorForm
(
)
;
}
if
(
mForm
&
&
!
HasFlag
(
ADDED_TO_FORM
)
)
{
nsAutoString
nameVal
idVal
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nameVal
)
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
idVal
)
;
SetFlags
(
ADDED_TO_FORM
)
;
mForm
-
>
AddImageElement
(
this
)
;
if
(
!
nameVal
.
IsEmpty
(
)
)
{
mForm
-
>
AddImageElementToTable
(
this
nameVal
)
;
}
if
(
!
idVal
.
IsEmpty
(
)
)
{
mForm
-
>
AddImageElementToTable
(
this
idVal
)
;
}
}
}
void
HTMLImageElement
:
:
MaybeLoadImage
(
bool
aAlwaysForceLoad
)
{
LoadSelectedImage
(
aAlwaysForceLoad
true
aAlwaysForceLoad
)
;
if
(
!
LoadingEnabled
(
)
)
{
CancelImageRequests
(
true
)
;
}
}
ElementState
HTMLImageElement
:
:
IntrinsicState
(
)
const
{
return
nsGenericHTMLElement
:
:
IntrinsicState
(
)
|
nsImageLoadingContent
:
:
ImageState
(
)
;
}
void
HTMLImageElement
:
:
NodeInfoChanged
(
Document
*
aOldDoc
)
{
nsGenericHTMLElement
:
:
NodeInfoChanged
(
aOldDoc
)
;
if
(
auto
*
observer
=
aOldDoc
-
>
GetLazyLoadImageObserverViewport
(
)
)
{
observer
-
>
Unobserve
(
*
this
)
;
}
if
(
mLazyLoading
)
{
aOldDoc
-
>
GetLazyLoadImageObserver
(
)
-
>
Unobserve
(
*
this
)
;
aOldDoc
-
>
DecLazyLoadImageCount
(
)
;
mLazyLoading
=
false
;
SetLazyLoading
(
)
;
}
StartLoadingIfNeeded
(
)
;
}
already_AddRefed
<
HTMLImageElement
>
HTMLImageElement
:
:
Image
(
const
GlobalObject
&
aGlobal
const
Optional
<
uint32_t
>
&
aWidth
const
Optional
<
uint32_t
>
&
aHeight
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
Document
*
doc
;
if
(
!
win
|
|
!
(
doc
=
win
-
>
GetExtantDoc
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
doc
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
img
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
RefPtr
<
HTMLImageElement
>
img
=
new
(
nim
)
HTMLImageElement
(
nodeInfo
.
forget
(
)
)
;
if
(
aWidth
.
WasPassed
(
)
)
{
img
-
>
SetWidth
(
aWidth
.
Value
(
)
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
aHeight
.
WasPassed
(
)
)
{
img
-
>
SetHeight
(
aHeight
.
Value
(
)
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
return
img
.
forget
(
)
;
}
uint32_t
HTMLImageElement
:
:
Height
(
)
{
return
GetWidthHeightForImage
(
)
.
height
;
}
uint32_t
HTMLImageElement
:
:
Width
(
)
{
return
GetWidthHeightForImage
(
)
.
width
;
}
nsIntSize
HTMLImageElement
:
:
NaturalSize
(
)
{
if
(
!
mCurrentRequest
)
{
return
{
}
;
}
nsCOMPtr
<
imgIContainer
>
image
;
mCurrentRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
!
image
)
{
return
{
}
;
}
nsIntSize
size
;
Unused
<
<
image
-
>
GetHeight
(
&
size
.
height
)
;
Unused
<
<
image
-
>
GetWidth
(
&
size
.
width
)
;
ImageResolution
resolution
=
image
-
>
GetResolution
(
)
;
if
(
mResponsiveSelector
)
{
float
density
=
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
;
MOZ_ASSERT
(
density
>
=
0
.
0
)
;
resolution
.
ScaleBy
(
density
)
;
}
resolution
.
ApplyTo
(
size
.
width
size
.
height
)
;
return
size
;
}
nsresult
HTMLImageElement
:
:
CopyInnerTo
(
HTMLImageElement
*
aDest
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
CopyInnerTo
(
aDest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
aDest
-
>
InResponsiveMode
(
)
&
&
aDest
-
>
HasAttr
(
nsGkAtoms
:
:
src
)
&
&
aDest
-
>
ShouldLoadImage
(
)
)
{
mUseUrgentStartForChannel
=
UserActivation
:
:
IsHandlingUserInput
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
MaybeLoadImage
"
aDest
&
HTMLImageElement
:
:
MaybeLoadImage
false
)
)
;
}
return
NS_OK
;
}
CORSMode
HTMLImageElement
:
:
GetCORSMode
(
)
{
return
AttrValueToCORSMode
(
GetParsedAttr
(
nsGkAtoms
:
:
crossorigin
)
)
;
}
JSObject
*
HTMLImageElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLImageElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
#
ifdef
DEBUG
HTMLFormElement
*
HTMLImageElement
:
:
GetForm
(
)
const
{
return
mForm
;
}
#
endif
void
HTMLImageElement
:
:
SetForm
(
HTMLFormElement
*
aForm
)
{
MOZ_ASSERT
(
aForm
"
Don
'
t
pass
null
here
"
)
;
NS_ASSERTION
(
!
mForm
"
We
don
'
t
support
switching
from
one
non
-
null
form
to
another
.
"
)
;
mForm
=
aForm
;
}
void
HTMLImageElement
:
:
ClearForm
(
bool
aRemoveFromForm
)
{
NS_ASSERTION
(
(
mForm
!
=
nullptr
)
=
=
HasFlag
(
ADDED_TO_FORM
)
"
Form
control
should
have
had
flag
set
correctly
"
)
;
if
(
!
mForm
)
{
return
;
}
if
(
aRemoveFromForm
)
{
nsAutoString
nameVal
idVal
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nameVal
)
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
idVal
)
;
mForm
-
>
RemoveImageElement
(
this
)
;
if
(
!
nameVal
.
IsEmpty
(
)
)
{
mForm
-
>
RemoveImageElementFromTable
(
this
nameVal
)
;
}
if
(
!
idVal
.
IsEmpty
(
)
)
{
mForm
-
>
RemoveImageElementFromTable
(
this
idVal
)
;
}
}
UnsetFlags
(
ADDED_TO_FORM
)
;
mForm
=
nullptr
;
}
void
HTMLImageElement
:
:
QueueImageLoadTask
(
bool
aAlwaysLoad
)
{
if
(
!
LoadingEnabled
(
)
|
|
!
ShouldLoadImage
(
)
)
{
return
;
}
bool
alwaysLoad
=
aAlwaysLoad
;
if
(
mPendingImageLoadTask
)
{
alwaysLoad
=
alwaysLoad
|
|
mPendingImageLoadTask
-
>
AlwaysLoad
(
)
;
}
RefPtr
<
ImageLoadTask
>
task
=
new
ImageLoadTask
(
this
alwaysLoad
mUseUrgentStartForChannel
)
;
mPendingImageLoadTask
=
task
;
CycleCollectedJSContext
:
:
Get
(
)
-
>
DispatchToMicroTask
(
task
.
forget
(
)
)
;
}
bool
HTMLImageElement
:
:
HaveSrcsetOrInPicture
(
)
{
if
(
HasAttr
(
nsGkAtoms
:
:
srcset
)
)
{
return
true
;
}
return
IsInPicture
(
)
;
}
bool
HTMLImageElement
:
:
InResponsiveMode
(
)
{
return
mResponsiveSelector
|
|
mPendingImageLoadTask
|
|
HaveSrcsetOrInPicture
(
)
;
}
bool
HTMLImageElement
:
:
SelectedSourceMatchesLast
(
nsIURI
*
aSelectedSource
)
{
if
(
!
mLastSelectedSource
|
|
!
aSelectedSource
)
{
return
false
;
}
bool
equal
=
false
;
return
NS_SUCCEEDED
(
mLastSelectedSource
-
>
Equals
(
aSelectedSource
&
equal
)
)
&
&
equal
;
}
nsresult
HTMLImageElement
:
:
LoadSelectedImage
(
bool
aForce
bool
aNotify
bool
aAlwaysLoad
)
{
double
currentDensity
=
1
.
0
;
if
(
aForce
)
{
const
bool
sourceChanged
=
UpdateResponsiveSource
(
)
;
if
(
mResponsiveSelector
)
{
currentDensity
=
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
;
}
if
(
!
sourceChanged
&
&
!
aAlwaysLoad
)
{
MOZ_ASSERT
(
currentDensity
=
=
mCurrentDensity
)
;
return
NS_OK
;
}
}
else
if
(
mResponsiveSelector
)
{
currentDensity
=
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
;
}
nsCOMPtr
<
nsIURI
>
selectedSource
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
;
ImageLoadType
type
=
eImageLoadType_Normal
;
bool
hasSrc
=
false
;
if
(
mResponsiveSelector
)
{
selectedSource
=
mResponsiveSelector
-
>
GetSelectedImageURL
(
)
;
triggeringPrincipal
=
mResponsiveSelector
-
>
GetSelectedImageTriggeringPrincipal
(
)
;
type
=
eImageLoadType_Imageset
;
}
else
{
nsAutoString
src
;
hasSrc
=
GetAttr
(
nsGkAtoms
:
:
src
src
)
;
if
(
hasSrc
&
&
!
src
.
IsEmpty
(
)
)
{
Document
*
doc
=
OwnerDoc
(
)
;
StringToURI
(
src
doc
getter_AddRefs
(
selectedSource
)
)
;
if
(
HaveSrcsetOrInPicture
(
)
)
{
type
=
eImageLoadType_Imageset
;
}
triggeringPrincipal
=
mSrcTriggeringPrincipal
;
}
}
if
(
!
aAlwaysLoad
&
&
SelectedSourceMatchesLast
(
selectedSource
)
)
{
SetDensity
(
currentDensity
)
;
return
NS_OK
;
}
if
(
mLazyLoading
)
{
if
(
!
selectedSource
|
|
!
nsContentUtils
:
:
IsImageAvailable
(
this
selectedSource
triggeringPrincipal
GetCORSMode
(
)
)
)
{
return
NS_OK
;
}
StopLazyLoading
(
FromIntersectionObserver
:
:
No
StartLoading
:
:
No
)
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
selectedSource
|
|
hasSrc
)
{
rv
=
LoadImage
(
selectedSource
aForce
aNotify
type
triggeringPrincipal
)
;
}
mLastSelectedSource
=
selectedSource
;
mCurrentDensity
=
currentDensity
;
if
(
NS_FAILED
(
rv
)
)
{
CancelImageRequests
(
aNotify
)
;
}
return
rv
;
}
void
HTMLImageElement
:
:
PictureSourceSrcsetChanged
(
nsIContent
*
aSourceNode
const
nsAString
&
aNewValue
bool
aNotify
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
nsIContent
*
currentSrc
=
mResponsiveSelector
?
mResponsiveSelector
-
>
Content
(
)
:
nullptr
;
if
(
aSourceNode
=
=
currentSrc
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
aSourceNode
=
=
this
)
{
principal
=
mSrcsetTriggeringPrincipal
;
}
else
if
(
auto
*
source
=
HTMLSourceElement
:
:
FromNode
(
aSourceNode
)
)
{
principal
=
source
-
>
GetSrcsetTriggeringPrincipal
(
)
;
}
mResponsiveSelector
-
>
SetCandidatesFromSourceSet
(
aNewValue
principal
)
;
}
if
(
!
mInDocResponsiveContent
&
&
IsInComposedDoc
(
)
)
{
OwnerDoc
(
)
-
>
AddResponsiveContent
(
this
)
;
mInDocResponsiveContent
=
true
;
}
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceSizesChanged
(
nsIContent
*
aSourceNode
const
nsAString
&
aNewValue
bool
aNotify
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
nsIContent
*
currentSrc
=
mResponsiveSelector
?
mResponsiveSelector
-
>
Content
(
)
:
nullptr
;
if
(
aSourceNode
=
=
currentSrc
)
{
mResponsiveSelector
-
>
SetSizesFromDescriptor
(
aNewValue
)
;
}
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceMediaOrTypeChanged
(
nsIContent
*
aSourceNode
bool
aNotify
)
{
MOZ_ASSERT
(
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceAdded
(
nsIContent
*
aSourceNode
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceRemoved
(
nsIContent
*
aSourceNode
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
QueueImageLoadTask
(
true
)
;
}
bool
HTMLImageElement
:
:
UpdateResponsiveSource
(
)
{
bool
hadSelector
=
!
!
mResponsiveSelector
;
nsIContent
*
currentSource
=
mResponsiveSelector
?
mResponsiveSelector
-
>
Content
(
)
:
nullptr
;
nsINode
*
candidateSource
=
IsInPicture
(
)
?
GetParentElement
(
)
-
>
GetFirstChild
(
)
:
this
;
RefPtr
<
ResponsiveImageSelector
>
newResponsiveSelector
=
nullptr
;
while
(
candidateSource
)
{
if
(
candidateSource
=
=
currentSource
)
{
bool
changed
=
mResponsiveSelector
-
>
SelectImage
(
true
)
;
if
(
mResponsiveSelector
-
>
NumCandidates
(
)
)
{
bool
isUsableCandidate
=
true
;
if
(
candidateSource
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
&
&
!
SourceElementMatches
(
candidateSource
-
>
AsElement
(
)
)
)
{
isUsableCandidate
=
false
;
}
if
(
isUsableCandidate
)
{
SetDensity
(
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
)
;
return
changed
;
}
}
newResponsiveSelector
=
nullptr
;
if
(
candidateSource
=
=
this
)
{
break
;
}
}
else
if
(
candidateSource
=
=
this
)
{
newResponsiveSelector
=
TryCreateResponsiveSelector
(
candidateSource
-
>
AsElement
(
)
)
;
break
;
}
else
if
(
auto
*
source
=
HTMLSourceElement
:
:
FromNode
(
candidateSource
)
)
{
if
(
RefPtr
<
ResponsiveImageSelector
>
selector
=
TryCreateResponsiveSelector
(
source
)
)
{
newResponsiveSelector
=
selector
.
forget
(
)
;
break
;
}
}
candidateSource
=
candidateSource
-
>
GetNextSibling
(
)
;
}
SetResponsiveSelector
(
std
:
:
move
(
newResponsiveSelector
)
)
;
return
hadSelector
|
|
mResponsiveSelector
;
}
bool
HTMLImageElement
:
:
SupportedPictureSourceType
(
const
nsAString
&
aType
)
{
nsAutoString
type
;
nsAutoString
params
;
nsContentUtils
:
:
SplitMimeType
(
aType
type
params
)
;
if
(
type
.
IsEmpty
(
)
)
{
return
true
;
}
return
imgLoader
:
:
SupportImageWithMimeType
(
NS_ConvertUTF16toUTF8
(
type
)
AcceptedMimeTypes
:
:
IMAGES_AND_DOCUMENTS
)
;
}
bool
HTMLImageElement
:
:
SourceElementMatches
(
Element
*
aSourceElement
)
{
MOZ_ASSERT
(
aSourceElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
)
;
MOZ_ASSERT
(
IsInPicture
(
)
)
;
MOZ_ASSERT
(
IsPreviousSibling
(
aSourceElement
this
)
)
;
auto
*
src
=
static_cast
<
HTMLSourceElement
*
>
(
aSourceElement
)
;
if
(
!
src
-
>
MatchesCurrentMedia
(
)
)
{
return
false
;
}
nsAutoString
type
;
if
(
src
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
&
&
!
SupportedPictureSourceType
(
type
)
)
{
return
false
;
}
return
true
;
}
already_AddRefed
<
ResponsiveImageSelector
>
HTMLImageElement
:
:
TryCreateResponsiveSelector
(
Element
*
aSourceElement
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
bool
isSourceTag
=
aSourceElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
;
if
(
isSourceTag
)
{
if
(
!
SourceElementMatches
(
aSourceElement
)
)
{
return
nullptr
;
}
auto
*
source
=
HTMLSourceElement
:
:
FromNode
(
aSourceElement
)
;
principal
=
source
-
>
GetSrcsetTriggeringPrincipal
(
)
;
}
else
if
(
aSourceElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
MOZ_ASSERT
(
aSourceElement
=
=
this
)
;
principal
=
mSrcsetTriggeringPrincipal
;
}
nsString
srcset
;
if
(
!
aSourceElement
-
>
GetAttr
(
nsGkAtoms
:
:
srcset
srcset
)
)
{
return
nullptr
;
}
if
(
srcset
.
IsEmpty
(
)
)
{
return
nullptr
;
}
RefPtr
<
ResponsiveImageSelector
>
sel
=
new
ResponsiveImageSelector
(
aSourceElement
)
;
if
(
!
sel
-
>
SetCandidatesFromSourceSet
(
srcset
principal
)
)
{
return
nullptr
;
}
nsAutoString
sizes
;
aSourceElement
-
>
GetAttr
(
nsGkAtoms
:
:
sizes
sizes
)
;
sel
-
>
SetSizesFromDescriptor
(
sizes
)
;
if
(
!
isSourceTag
)
{
MOZ_ASSERT
(
aSourceElement
=
=
this
)
;
nsAutoString
src
;
if
(
GetAttr
(
nsGkAtoms
:
:
src
src
)
&
&
!
src
.
IsEmpty
(
)
)
{
sel
-
>
SetDefaultSource
(
src
mSrcTriggeringPrincipal
)
;
}
}
return
sel
.
forget
(
)
;
}
bool
HTMLImageElement
:
:
SelectSourceForTagWithAttrs
(
Document
*
aDocument
bool
aIsSourceTag
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
nsAString
&
aResult
)
{
MOZ_ASSERT
(
aIsSourceTag
|
|
(
aTypeAttr
.
IsEmpty
(
)
&
&
aMediaAttr
.
IsEmpty
(
)
)
"
Passing
type
or
media
attrs
makes
no
sense
without
aIsSourceTag
"
)
;
MOZ_ASSERT
(
!
aIsSourceTag
|
|
aSrcAttr
.
IsEmpty
(
)
"
Passing
aSrcAttr
makes
no
sense
with
aIsSourceTag
set
"
)
;
if
(
aSrcsetAttr
.
IsEmpty
(
)
)
{
if
(
!
aIsSourceTag
)
{
aResult
.
Assign
(
aSrcAttr
)
;
return
true
;
}
return
false
;
}
if
(
aIsSourceTag
&
&
(
(
!
aMediaAttr
.
IsVoid
(
)
&
&
!
HTMLSourceElement
:
:
WouldMatchMediaForDocument
(
aMediaAttr
aDocument
)
)
|
|
(
!
aTypeAttr
.
IsVoid
(
)
&
&
!
SupportedPictureSourceType
(
aTypeAttr
)
)
)
)
{
return
false
;
}
RefPtr
<
ResponsiveImageSelector
>
sel
=
new
ResponsiveImageSelector
(
aDocument
)
;
sel
-
>
SetCandidatesFromSourceSet
(
aSrcsetAttr
)
;
if
(
!
aSizesAttr
.
IsEmpty
(
)
)
{
sel
-
>
SetSizesFromDescriptor
(
aSizesAttr
)
;
}
if
(
!
aIsSourceTag
)
{
sel
-
>
SetDefaultSource
(
aSrcAttr
)
;
}
if
(
sel
-
>
GetSelectedImageURLSpec
(
aResult
)
)
{
return
true
;
}
if
(
!
aIsSourceTag
)
{
aResult
.
Truncate
(
)
;
return
true
;
}
return
false
;
}
void
HTMLImageElement
:
:
DestroyContent
(
)
{
mResponsiveSelector
=
nullptr
;
nsImageLoadingContent
:
:
Destroy
(
)
;
nsGenericHTMLElement
:
:
DestroyContent
(
)
;
}
void
HTMLImageElement
:
:
MediaFeatureValuesChanged
(
)
{
QueueImageLoadTask
(
false
)
;
}
bool
HTMLImageElement
:
:
ShouldLoadImage
(
)
const
{
return
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
;
}
void
HTMLImageElement
:
:
SetLazyLoading
(
)
{
if
(
mLazyLoading
)
{
return
;
}
if
(
!
StaticPrefs
:
:
dom_image_lazy_loading_enabled
(
)
)
{
return
;
}
Document
*
doc
=
OwnerDoc
(
)
;
if
(
!
doc
-
>
IsScriptEnabled
(
)
|
|
doc
-
>
IsStaticDocument
(
)
)
{
return
;
}
doc
-
>
EnsureLazyLoadImageObserver
(
)
.
Observe
(
*
this
)
;
doc
-
>
EnsureLazyLoadImageObserverViewport
(
)
.
Observe
(
*
this
)
;
doc
-
>
IncLazyLoadImageCount
(
)
;
mLazyLoading
=
true
;
UpdateImageState
(
true
)
;
}
void
HTMLImageElement
:
:
StartLoadingIfNeeded
(
)
{
if
(
LoadingEnabled
(
)
&
&
ShouldLoadImage
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
InResponsiveMode
(
)
?
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
QueueImageLoadTask
"
this
&
HTMLImageElement
:
:
QueueImageLoadTask
true
)
:
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
MaybeLoadImage
"
this
&
HTMLImageElement
:
:
MaybeLoadImage
true
)
)
;
}
}
void
HTMLImageElement
:
:
StopLazyLoading
(
FromIntersectionObserver
aFromIntersectionObserver
StartLoading
aStartLoading
)
{
if
(
!
mLazyLoading
)
{
return
;
}
mLazyLoading
=
false
;
Document
*
doc
=
OwnerDoc
(
)
;
if
(
auto
*
obs
=
doc
-
>
GetLazyLoadImageObserver
(
)
)
{
obs
-
>
Unobserve
(
*
this
)
;
}
if
(
bool
(
aFromIntersectionObserver
)
)
{
doc
-
>
IncLazyLoadImageStarted
(
)
;
}
else
{
doc
-
>
DecLazyLoadImageCount
(
)
;
if
(
auto
*
obs
=
doc
-
>
GetLazyLoadImageObserverViewport
(
)
)
{
obs
-
>
Unobserve
(
*
this
)
;
}
}
if
(
bool
(
aStartLoading
)
)
{
StartLoadingIfNeeded
(
)
;
}
}
void
HTMLImageElement
:
:
LazyLoadImageReachedViewport
(
)
{
Document
*
doc
=
OwnerDoc
(
)
;
if
(
auto
*
obs
=
doc
-
>
GetLazyLoadImageObserverViewport
(
)
)
{
obs
-
>
Unobserve
(
*
this
)
;
}
doc
-
>
IncLazyLoadImageReachViewport
(
!
Complete
(
)
)
;
}
void
HTMLImageElement
:
:
SetResponsiveSelector
(
RefPtr
<
ResponsiveImageSelector
>
&
&
aSource
)
{
if
(
mResponsiveSelector
=
=
aSource
)
{
return
;
}
mResponsiveSelector
=
std
:
:
move
(
aSource
)
;
SetDensity
(
mResponsiveSelector
?
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
:
1
.
0
)
;
}
void
HTMLImageElement
:
:
SetDensity
(
double
aDensity
)
{
if
(
mCurrentDensity
=
=
aDensity
)
{
return
;
}
mCurrentDensity
=
aDensity
;
if
(
nsImageFrame
*
f
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
)
{
f
-
>
ResponsiveContentDensityChanged
(
)
;
}
}
}
