#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElementBinding
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsDocument
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
Image
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSourceElement
.
h
"
#
include
"
mozilla
/
dom
/
ResponsiveImageSelector
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgILoader
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MappedDeclarations
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
include
"
nsLayoutUtils
.
h
"
using
namespace
mozilla
:
:
net
;
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Image
)
#
ifdef
DEBUG
static
bool
IsPreviousSibling
(
nsINode
*
aSubject
nsINode
*
aNode
)
{
if
(
aSubject
=
=
aNode
)
{
return
false
;
}
nsINode
*
parent
=
aSubject
-
>
GetParentNode
(
)
;
if
(
parent
&
&
parent
=
=
aNode
-
>
GetParentNode
(
)
)
{
return
parent
-
>
ComputeIndexOf
(
aSubject
)
<
parent
-
>
ComputeIndexOf
(
aNode
)
;
}
return
false
;
}
#
endif
namespace
mozilla
{
namespace
dom
{
class
ImageLoadTask
:
public
Runnable
{
public
:
ImageLoadTask
(
HTMLImageElement
*
aElement
bool
aAlwaysLoad
bool
aUseUrgentStartForChannel
)
:
Runnable
(
"
dom
:
:
ImageLoadTask
"
)
mElement
(
aElement
)
mAlwaysLoad
(
aAlwaysLoad
)
mUseUrgentStartForChannel
(
aUseUrgentStartForChannel
)
{
mDocument
=
aElement
-
>
OwnerDoc
(
)
;
mDocument
-
>
BlockOnload
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mElement
-
>
mPendingImageLoadTask
=
=
this
)
{
mElement
-
>
mPendingImageLoadTask
=
nullptr
;
mElement
-
>
mUseUrgentStartForChannel
=
mUseUrgentStartForChannel
;
mElement
-
>
LoadSelectedImage
(
true
true
mAlwaysLoad
)
;
}
mDocument
-
>
UnblockOnload
(
false
)
;
return
NS_OK
;
}
bool
AlwaysLoad
(
)
{
return
mAlwaysLoad
;
}
private
:
~
ImageLoadTask
(
)
{
}
RefPtr
<
HTMLImageElement
>
mElement
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
bool
mAlwaysLoad
;
bool
mUseUrgentStartForChannel
;
}
;
HTMLImageElement
:
:
HTMLImageElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsGenericHTMLElement
(
aNodeInfo
)
mForm
(
nullptr
)
mInDocResponsiveContent
(
false
)
mCurrentDensity
(
1
.
0
)
{
AddStatesSilently
(
NS_EVENT_STATE_BROKEN
)
;
}
HTMLImageElement
:
:
~
HTMLImageElement
(
)
{
DestroyImageLoadingContent
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLImageElement
nsGenericHTMLElement
mResponsiveSelector
)
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLImageElement
nsGenericHTMLElement
nsIImageLoadingContent
imgINotificationObserver
)
NS_IMPL_ELEMENT_CLONE
(
HTMLImageElement
)
bool
HTMLImageElement
:
:
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
{
return
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
usemap
)
|
|
nsGenericHTMLElement
:
:
IsInteractiveHTMLContent
(
aIgnoreTabindex
)
;
}
void
HTMLImageElement
:
:
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
{
nsImageLoadingContent
:
:
AsyncEventRunning
(
aEvent
)
;
}
void
HTMLImageElement
:
:
GetCurrentSrc
(
nsAString
&
aValue
)
{
nsCOMPtr
<
nsIURI
>
currentURI
;
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
if
(
currentURI
)
{
nsAutoCString
spec
;
currentURI
-
>
GetSpec
(
spec
)
;
CopyUTF8toUTF16
(
spec
aValue
)
;
}
else
{
SetDOMStringToNull
(
aValue
)
;
}
}
bool
HTMLImageElement
:
:
Draggable
(
)
const
{
return
!
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
draggable
nsGkAtoms
:
:
_false
eIgnoreCase
)
;
}
bool
HTMLImageElement
:
:
Complete
(
)
{
if
(
!
mCurrentRequest
)
{
return
true
;
}
if
(
mPendingRequest
)
{
return
false
;
}
uint32_t
status
;
mCurrentRequest
-
>
GetImageStatus
(
&
status
)
;
return
(
status
&
(
imgIRequest
:
:
STATUS_LOAD_COMPLETE
|
imgIRequest
:
:
STATUS_ERROR
)
)
!
=
0
;
}
CSSIntPoint
HTMLImageElement
:
:
GetXY
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Layout
)
;
if
(
!
frame
)
{
return
CSSIntPoint
(
0
0
)
;
}
nsIFrame
*
layer
=
nsLayoutUtils
:
:
GetClosestLayer
(
frame
-
>
GetParent
(
)
)
;
return
CSSIntPoint
:
:
FromAppUnitsRounded
(
frame
-
>
GetOffsetTo
(
layer
)
)
;
}
int32_t
HTMLImageElement
:
:
X
(
)
{
return
GetXY
(
)
.
x
;
}
int32_t
HTMLImageElement
:
:
Y
(
)
{
return
GetXY
(
)
.
y
;
}
bool
HTMLImageElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
)
{
return
ParseAlignValue
(
aValue
aResult
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
crossorigin
)
{
ParseCORSValue
(
aValue
aResult
)
;
return
true
;
}
if
(
ParseImageAttribute
(
aAttribute
aValue
aResult
)
)
{
return
true
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLImageElement
:
:
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
aDecls
)
{
nsGenericHTMLElement
:
:
MapImageAlignAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageBorderAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageMarginAttributeInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapImageSizeAttributesInto
(
aAttributes
aDecls
)
;
nsGenericHTMLElement
:
:
MapCommonAttributesInto
(
aAttributes
aDecls
)
;
}
nsChangeHint
HTMLImageElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
nsGenericHTMLElement
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
usemap
|
|
aAttribute
=
=
nsGkAtoms
:
:
ismap
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
alt
)
{
if
(
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
|
|
aModType
=
=
MutationEvent_Binding
:
:
REMOVAL
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
}
return
retval
;
}
NS_IMETHODIMP_
(
bool
)
HTMLImageElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sCommonAttributeMap
sImageMarginSizeAttributeMap
sImageBorderAttributeMap
sImageAlignAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLImageElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
nsresult
HTMLImageElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
mForm
&
&
(
aName
=
=
nsGkAtoms
:
:
name
|
|
aName
=
=
nsGkAtoms
:
:
id
)
)
{
nsAutoString
tmp
;
GetAttr
(
kNameSpaceID_None
aName
tmp
)
;
if
(
!
tmp
.
IsEmpty
(
)
)
{
mForm
-
>
RemoveImageElementFromTable
(
this
tmp
)
;
}
}
return
nsGenericHTMLElement
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLImageElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
nsAttrValueOrString
attrVal
(
aValue
)
;
if
(
aValue
)
{
AfterMaybeChangeAttr
(
aNameSpaceID
aName
attrVal
aOldValue
aMaybeScriptedPrincipal
true
aNotify
)
;
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
mForm
&
&
(
aName
=
=
nsGkAtoms
:
:
name
|
|
aName
=
=
nsGkAtoms
:
:
id
)
&
&
aValue
&
&
!
aValue
-
>
IsEmptyString
(
)
)
{
MOZ_ASSERT
(
aValue
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
"
Expected
atom
value
for
name
/
id
"
)
;
mForm
-
>
AddImageElementToTable
(
this
nsDependentAtomString
(
aValue
-
>
GetAtomValue
(
)
)
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
src
&
&
aNameSpaceID
=
=
kNameSpaceID_None
&
&
!
aValue
)
{
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
if
(
InResponsiveMode
(
)
)
{
if
(
mResponsiveSelector
&
&
mResponsiveSelector
-
>
Content
(
)
=
=
this
)
{
mResponsiveSelector
-
>
SetDefaultSource
(
VoidString
(
)
)
;
}
QueueImageLoadTask
(
true
)
;
}
else
{
CancelImageRequests
(
aNotify
)
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
srcset
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
mSrcsetTriggeringPrincipal
=
aMaybeScriptedPrincipal
;
PictureSourceSrcsetChanged
(
this
attrVal
.
String
(
)
aNotify
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
sizes
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
PictureSourceSizesChanged
(
this
attrVal
.
String
(
)
aNotify
)
;
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
}
nsresult
HTMLImageElement
:
:
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
{
AfterMaybeChangeAttr
(
aNamespaceID
aName
aValue
nullptr
nullptr
false
aNotify
)
;
return
nsGenericHTMLElement
:
:
OnAttrSetButNotChanged
(
aNamespaceID
aName
aValue
aNotify
)
;
}
void
HTMLImageElement
:
:
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aValueMaybeChanged
bool
aNotify
)
{
bool
forceReload
=
false
;
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
src
)
{
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
mSrcTriggeringPrincipal
=
nsContentUtils
:
:
GetAttrTriggeringPrincipal
(
this
aValue
.
String
(
)
aMaybeScriptedPrincipal
)
;
if
(
InResponsiveMode
(
)
)
{
if
(
mResponsiveSelector
&
&
mResponsiveSelector
-
>
Content
(
)
=
=
this
)
{
mResponsiveSelector
-
>
SetDefaultSource
(
aValue
.
String
(
)
mSrcTriggeringPrincipal
)
;
}
QueueImageLoadTask
(
true
)
;
}
else
if
(
aNotify
&
&
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
)
{
mNewRequestsWillNeedAnimationReset
=
true
;
LoadImage
(
aValue
.
String
(
)
true
aNotify
eImageLoadType_Normal
mSrcTriggeringPrincipal
)
;
mNewRequestsWillNeedAnimationReset
=
false
;
}
}
else
if
(
aNamespaceID
=
=
kNameSpaceID_None
&
&
aName
=
=
nsGkAtoms
:
:
crossorigin
&
&
aNotify
)
{
if
(
aValueMaybeChanged
&
&
GetCORSMode
(
)
!
=
AttrValueToCORSMode
(
aOldValue
)
)
{
forceReload
=
true
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
referrerpolicy
&
&
aNamespaceID
=
=
kNameSpaceID_None
&
&
aNotify
)
{
ReferrerPolicy
referrerPolicy
=
GetImageReferrerPolicy
(
)
;
if
(
!
InResponsiveMode
(
)
&
&
referrerPolicy
!
=
RP_Unset
&
&
aValueMaybeChanged
&
&
referrerPolicy
!
=
ReferrerPolicyFromAttr
(
aOldValue
)
)
{
forceReload
=
true
;
}
}
if
(
forceReload
)
{
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
if
(
InResponsiveMode
(
)
)
{
QueueImageLoadTask
(
true
)
;
}
else
if
(
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
)
{
ForceReload
(
aNotify
IgnoreErrors
(
)
)
;
}
}
}
void
HTMLImageElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
&
&
IsMap
(
)
)
{
mouseEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
bool
HTMLImageElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
int32_t
tabIndex
=
TabIndex
(
)
;
if
(
IsInComposedDoc
(
)
&
&
FindImageMap
(
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
(
sTabFocusModel
&
eTabFocus_linksMask
)
?
0
:
-
1
;
}
*
aIsFocusable
=
false
;
return
false
;
}
if
(
aTabIndex
)
{
*
aTabIndex
=
(
sTabFocusModel
&
eTabFocus_formElementsMask
)
?
tabIndex
:
-
1
;
}
*
aIsFocusable
=
#
ifdef
XP_MACOSX
(
!
aWithMouse
|
|
nsFocusManager
:
:
sMouseFocusesFormControl
)
&
&
#
endif
(
tabIndex
>
=
0
|
|
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
tabindex
)
)
;
return
false
;
}
nsresult
HTMLImageElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsImageLoadingContent
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
if
(
aParent
)
{
UpdateFormOwner
(
)
;
}
if
(
HaveSrcsetOrInPicture
(
)
)
{
if
(
aDocument
&
&
!
mInDocResponsiveContent
)
{
aDocument
-
>
AddResponsiveContent
(
this
)
;
mInDocResponsiveContent
=
true
;
}
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
QueueImageLoadTask
(
false
)
;
}
else
if
(
!
InResponsiveMode
(
)
&
&
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
)
{
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
ClearBrokenState
(
)
;
RemoveStatesSilently
(
NS_EVENT_STATE_BROKEN
)
;
if
(
LoadingEnabled
(
)
&
&
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
MaybeLoadImage
"
this
&
HTMLImageElement
:
:
MaybeLoadImage
false
)
)
;
}
}
return
rv
;
}
void
HTMLImageElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
if
(
mForm
)
{
if
(
aNullParent
|
|
!
FindAncestorForm
(
mForm
)
)
{
ClearForm
(
true
)
;
}
else
{
UnsetFlags
(
MAYBE_ORPHAN_FORM_ELEMENT
)
;
}
}
if
(
mInDocResponsiveContent
)
{
OwnerDoc
(
)
-
>
RemoveResponsiveContent
(
this
)
;
mInDocResponsiveContent
=
false
;
}
nsImageLoadingContent
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
}
void
HTMLImageElement
:
:
UpdateFormOwner
(
)
{
if
(
!
mForm
)
{
mForm
=
FindAncestorForm
(
)
;
}
if
(
mForm
&
&
!
HasFlag
(
ADDED_TO_FORM
)
)
{
nsAutoString
nameVal
idVal
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nameVal
)
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
idVal
)
;
SetFlags
(
ADDED_TO_FORM
)
;
mForm
-
>
AddImageElement
(
this
)
;
if
(
!
nameVal
.
IsEmpty
(
)
)
{
mForm
-
>
AddImageElementToTable
(
this
nameVal
)
;
}
if
(
!
idVal
.
IsEmpty
(
)
)
{
mForm
-
>
AddImageElementToTable
(
this
idVal
)
;
}
}
}
void
HTMLImageElement
:
:
MaybeLoadImage
(
bool
aAlwaysForceLoad
)
{
LoadSelectedImage
(
aAlwaysForceLoad
true
aAlwaysForceLoad
)
;
if
(
!
LoadingEnabled
(
)
)
{
CancelImageRequests
(
true
)
;
}
}
EventStates
HTMLImageElement
:
:
IntrinsicState
(
)
const
{
return
nsGenericHTMLElement
:
:
IntrinsicState
(
)
|
nsImageLoadingContent
:
:
ImageState
(
)
;
}
void
HTMLImageElement
:
:
NodeInfoChanged
(
nsIDocument
*
aOldDoc
)
{
nsGenericHTMLElement
:
:
NodeInfoChanged
(
aOldDoc
)
;
if
(
LoadingEnabled
(
)
&
&
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
(
InResponsiveMode
(
)
)
?
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
QueueImageLoadTask
"
this
&
HTMLImageElement
:
:
QueueImageLoadTask
true
)
:
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
MaybeLoadImage
"
this
&
HTMLImageElement
:
:
MaybeLoadImage
true
)
)
;
}
}
already_AddRefed
<
HTMLImageElement
>
HTMLImageElement
:
:
Image
(
const
GlobalObject
&
aGlobal
const
Optional
<
uint32_t
>
&
aWidth
const
Optional
<
uint32_t
>
&
aHeight
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
nsIDocument
*
doc
;
if
(
!
win
|
|
!
(
doc
=
win
-
>
GetExtantDoc
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
doc
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
img
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
RefPtr
<
HTMLImageElement
>
img
=
new
HTMLImageElement
(
nodeInfo
)
;
if
(
aWidth
.
WasPassed
(
)
)
{
img
-
>
SetWidth
(
aWidth
.
Value
(
)
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
aHeight
.
WasPassed
(
)
)
{
img
-
>
SetHeight
(
aHeight
.
Value
(
)
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
return
img
.
forget
(
)
;
}
NS_IMETHODIMP
HTMLImageElement
:
:
GetNaturalHeight
(
uint32_t
*
aNaturalHeight
)
{
*
aNaturalHeight
=
NaturalHeight
(
)
;
return
NS_OK
;
}
uint32_t
HTMLImageElement
:
:
NaturalHeight
(
)
{
uint32_t
height
;
nsresult
rv
=
nsImageLoadingContent
:
:
GetNaturalHeight
(
&
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
GetNaturalHeight
should
not
fail
"
)
;
return
0
;
}
if
(
mResponsiveSelector
)
{
double
density
=
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
;
MOZ_ASSERT
(
density
>
=
0
.
0
)
;
height
=
NSToIntRound
(
double
(
height
)
/
density
)
;
}
return
height
;
}
NS_IMETHODIMP
HTMLImageElement
:
:
GetNaturalWidth
(
uint32_t
*
aNaturalWidth
)
{
*
aNaturalWidth
=
NaturalWidth
(
)
;
return
NS_OK
;
}
uint32_t
HTMLImageElement
:
:
NaturalWidth
(
)
{
uint32_t
width
;
nsresult
rv
=
nsImageLoadingContent
:
:
GetNaturalWidth
(
&
width
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT
(
false
"
GetNaturalWidth
should
not
fail
"
)
;
return
0
;
}
if
(
mResponsiveSelector
)
{
double
density
=
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
;
MOZ_ASSERT
(
density
>
=
0
.
0
)
;
width
=
NSToIntRound
(
double
(
width
)
/
density
)
;
}
return
width
;
}
nsresult
HTMLImageElement
:
:
CopyInnerTo
(
Element
*
aDest
bool
aPreallocateChildren
)
{
bool
destIsStatic
=
aDest
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
;
auto
dest
=
static_cast
<
HTMLImageElement
*
>
(
aDest
)
;
if
(
destIsStatic
)
{
CreateStaticImageClone
(
dest
)
;
}
nsresult
rv
=
nsGenericHTMLElement
:
:
CopyInnerTo
(
aDest
aPreallocateChildren
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
!
destIsStatic
)
{
if
(
!
dest
-
>
InResponsiveMode
(
)
&
&
dest
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
&
&
dest
-
>
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
)
{
mUseUrgentStartForChannel
=
EventStateManager
:
:
IsHandlingUserInput
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
<
bool
>
(
"
dom
:
:
HTMLImageElement
:
:
MaybeLoadImage
"
dest
&
HTMLImageElement
:
:
MaybeLoadImage
false
)
)
;
}
}
return
NS_OK
;
}
CORSMode
HTMLImageElement
:
:
GetCORSMode
(
)
{
return
AttrValueToCORSMode
(
GetParsedAttr
(
nsGkAtoms
:
:
crossorigin
)
)
;
}
JSObject
*
HTMLImageElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLImageElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
#
ifdef
DEBUG
HTMLFormElement
*
HTMLImageElement
:
:
GetForm
(
)
const
{
return
mForm
;
}
#
endif
void
HTMLImageElement
:
:
SetForm
(
HTMLFormElement
*
aForm
)
{
MOZ_ASSERT
(
aForm
"
Don
'
t
pass
null
here
"
)
;
NS_ASSERTION
(
!
mForm
"
We
don
'
t
support
switching
from
one
non
-
null
form
to
another
.
"
)
;
mForm
=
aForm
;
}
void
HTMLImageElement
:
:
ClearForm
(
bool
aRemoveFromForm
)
{
NS_ASSERTION
(
(
mForm
!
=
nullptr
)
=
=
HasFlag
(
ADDED_TO_FORM
)
"
Form
control
should
have
had
flag
set
correctly
"
)
;
if
(
!
mForm
)
{
return
;
}
if
(
aRemoveFromForm
)
{
nsAutoString
nameVal
idVal
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nameVal
)
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
idVal
)
;
mForm
-
>
RemoveImageElement
(
this
)
;
if
(
!
nameVal
.
IsEmpty
(
)
)
{
mForm
-
>
RemoveImageElementFromTable
(
this
nameVal
)
;
}
if
(
!
idVal
.
IsEmpty
(
)
)
{
mForm
-
>
RemoveImageElementFromTable
(
this
idVal
)
;
}
}
UnsetFlags
(
ADDED_TO_FORM
)
;
mForm
=
nullptr
;
}
void
HTMLImageElement
:
:
QueueImageLoadTask
(
bool
aAlwaysLoad
)
{
if
(
!
LoadingEnabled
(
)
|
|
!
this
-
>
OwnerDoc
(
)
-
>
ShouldLoadImages
(
)
)
{
return
;
}
bool
alwaysLoad
=
aAlwaysLoad
;
if
(
mPendingImageLoadTask
)
{
alwaysLoad
=
alwaysLoad
|
|
mPendingImageLoadTask
-
>
AlwaysLoad
(
)
;
}
RefPtr
<
ImageLoadTask
>
task
=
new
ImageLoadTask
(
this
alwaysLoad
mUseUrgentStartForChannel
)
;
mPendingImageLoadTask
=
task
;
nsContentUtils
:
:
RunInStableState
(
task
.
forget
(
)
)
;
}
bool
HTMLImageElement
:
:
HaveSrcsetOrInPicture
(
)
{
if
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
srcset
)
)
{
return
true
;
}
Element
*
parent
=
nsINode
:
:
GetParentElement
(
)
;
return
(
parent
&
&
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
picture
)
)
;
}
bool
HTMLImageElement
:
:
InResponsiveMode
(
)
{
return
mResponsiveSelector
|
|
mPendingImageLoadTask
|
|
HaveSrcsetOrInPicture
(
)
;
}
bool
HTMLImageElement
:
:
SelectedSourceMatchesLast
(
nsIURI
*
aSelectedSource
)
{
if
(
!
mLastSelectedSource
|
|
!
aSelectedSource
)
{
return
false
;
}
bool
equal
=
false
;
return
NS_SUCCEEDED
(
mLastSelectedSource
-
>
Equals
(
aSelectedSource
&
equal
)
)
&
&
equal
;
}
nsresult
HTMLImageElement
:
:
LoadSelectedImage
(
bool
aForce
bool
aNotify
bool
aAlwaysLoad
)
{
double
currentDensity
=
1
.
0
;
auto
UpdateDensityOnly
=
[
&
]
(
)
-
>
void
{
if
(
mCurrentDensity
=
=
currentDensity
)
{
return
;
}
mCurrentDensity
=
currentDensity
;
if
(
nsImageFrame
*
f
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
)
{
f
-
>
ResponsiveContentDensityChanged
(
)
;
}
}
;
if
(
aForce
)
{
const
bool
sourceChanged
=
UpdateResponsiveSource
(
)
;
if
(
mResponsiveSelector
)
{
currentDensity
=
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
;
}
if
(
!
sourceChanged
&
&
!
aAlwaysLoad
)
{
UpdateDensityOnly
(
)
;
return
NS_OK
;
}
}
else
if
(
mResponsiveSelector
)
{
currentDensity
=
mResponsiveSelector
-
>
GetSelectedImageDensity
(
)
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIURI
>
selectedSource
;
if
(
mResponsiveSelector
)
{
nsCOMPtr
<
nsIURI
>
url
=
mResponsiveSelector
-
>
GetSelectedImageURL
(
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
mResponsiveSelector
-
>
GetSelectedImageTriggeringPrincipal
(
)
;
selectedSource
=
url
;
if
(
!
aAlwaysLoad
&
&
SelectedSourceMatchesLast
(
selectedSource
)
)
{
UpdateDensityOnly
(
)
;
return
NS_OK
;
}
if
(
url
)
{
rv
=
LoadImage
(
url
aForce
aNotify
eImageLoadType_Imageset
triggeringPrincipal
)
;
}
}
else
{
nsAutoString
src
;
if
(
!
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
)
{
CancelImageRequests
(
aNotify
)
;
rv
=
NS_OK
;
}
else
{
nsIDocument
*
doc
=
OwnerDoc
(
)
;
StringToURI
(
src
doc
getter_AddRefs
(
selectedSource
)
)
;
if
(
!
aAlwaysLoad
&
&
SelectedSourceMatchesLast
(
selectedSource
)
)
{
UpdateDensityOnly
(
)
;
return
NS_OK
;
}
rv
=
LoadImage
(
src
aForce
aNotify
HaveSrcsetOrInPicture
(
)
?
eImageLoadType_Imageset
:
eImageLoadType_Normal
mSrcTriggeringPrincipal
)
;
}
}
mLastSelectedSource
=
selectedSource
;
mCurrentDensity
=
currentDensity
;
if
(
NS_FAILED
(
rv
)
)
{
CancelImageRequests
(
aNotify
)
;
}
return
rv
;
}
void
HTMLImageElement
:
:
PictureSourceSrcsetChanged
(
nsIContent
*
aSourceNode
const
nsAString
&
aNewValue
bool
aNotify
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
nsIContent
*
currentSrc
=
mResponsiveSelector
?
mResponsiveSelector
-
>
Content
(
)
:
nullptr
;
if
(
aSourceNode
=
=
currentSrc
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
aSourceNode
=
=
this
)
{
principal
=
mSrcsetTriggeringPrincipal
;
}
else
if
(
auto
*
source
=
HTMLSourceElement
:
:
FromNode
(
aSourceNode
)
)
{
principal
=
source
-
>
GetSrcsetTriggeringPrincipal
(
)
;
}
mResponsiveSelector
-
>
SetCandidatesFromSourceSet
(
aNewValue
principal
)
;
}
if
(
!
mInDocResponsiveContent
&
&
IsInComposedDoc
(
)
)
{
OwnerDoc
(
)
-
>
AddResponsiveContent
(
this
)
;
mInDocResponsiveContent
=
true
;
}
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceSizesChanged
(
nsIContent
*
aSourceNode
const
nsAString
&
aNewValue
bool
aNotify
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
nsIContent
*
currentSrc
=
mResponsiveSelector
?
mResponsiveSelector
-
>
Content
(
)
:
nullptr
;
if
(
aSourceNode
=
=
currentSrc
)
{
mResponsiveSelector
-
>
SetSizesFromDescriptor
(
aNewValue
)
;
}
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceMediaOrTypeChanged
(
nsIContent
*
aSourceNode
bool
aNotify
)
{
MOZ_ASSERT
(
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceAdded
(
nsIContent
*
aSourceNode
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
QueueImageLoadTask
(
true
)
;
}
void
HTMLImageElement
:
:
PictureSourceRemoved
(
nsIContent
*
aSourceNode
)
{
MOZ_ASSERT
(
aSourceNode
=
=
this
|
|
IsPreviousSibling
(
aSourceNode
this
)
"
Should
not
be
getting
notifications
for
non
-
previous
-
siblings
"
)
;
QueueImageLoadTask
(
true
)
;
}
bool
HTMLImageElement
:
:
UpdateResponsiveSource
(
)
{
bool
hadSelector
=
!
!
mResponsiveSelector
;
nsIContent
*
currentSource
=
mResponsiveSelector
?
mResponsiveSelector
-
>
Content
(
)
:
nullptr
;
Element
*
parent
=
nsINode
:
:
GetParentElement
(
)
;
nsINode
*
candidateSource
=
nullptr
;
if
(
parent
&
&
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
picture
)
)
{
candidateSource
=
parent
-
>
GetFirstChild
(
)
;
}
else
{
candidateSource
=
this
;
}
while
(
candidateSource
)
{
if
(
candidateSource
=
=
currentSource
)
{
bool
changed
=
mResponsiveSelector
-
>
SelectImage
(
true
)
;
if
(
mResponsiveSelector
-
>
NumCandidates
(
)
)
{
bool
isUsableCandidate
=
true
;
if
(
candidateSource
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
&
&
!
SourceElementMatches
(
candidateSource
-
>
AsElement
(
)
)
)
{
isUsableCandidate
=
false
;
}
if
(
isUsableCandidate
)
{
return
changed
;
}
}
mResponsiveSelector
=
nullptr
;
if
(
candidateSource
=
=
this
)
{
break
;
}
}
else
if
(
candidateSource
=
=
this
)
{
if
(
!
TryCreateResponsiveSelector
(
candidateSource
-
>
AsElement
(
)
)
)
{
mResponsiveSelector
=
nullptr
;
}
break
;
}
else
if
(
candidateSource
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
&
&
TryCreateResponsiveSelector
(
candidateSource
-
>
AsElement
(
)
)
)
{
break
;
}
candidateSource
=
candidateSource
-
>
GetNextSibling
(
)
;
}
if
(
!
candidateSource
)
{
mResponsiveSelector
=
nullptr
;
}
return
hadSelector
|
|
mResponsiveSelector
;
}
bool
HTMLImageElement
:
:
SupportedPictureSourceType
(
const
nsAString
&
aType
)
{
nsAutoString
type
;
nsAutoString
params
;
nsContentUtils
:
:
SplitMimeType
(
aType
type
params
)
;
if
(
type
.
IsEmpty
(
)
)
{
return
true
;
}
return
imgLoader
:
:
SupportImageWithMimeType
(
NS_ConvertUTF16toUTF8
(
type
)
.
get
(
)
AcceptedMimeTypes
:
:
IMAGES_AND_DOCUMENTS
)
;
}
bool
HTMLImageElement
:
:
SourceElementMatches
(
Element
*
aSourceElement
)
{
MOZ_ASSERT
(
aSourceElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
)
;
DebugOnly
<
Element
*
>
parent
(
nsINode
:
:
GetParentElement
(
)
)
;
MOZ_ASSERT
(
parent
&
&
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
picture
)
)
;
MOZ_ASSERT
(
IsPreviousSibling
(
aSourceElement
this
)
)
;
auto
*
src
=
static_cast
<
HTMLSourceElement
*
>
(
aSourceElement
)
;
if
(
!
src
-
>
MatchesCurrentMedia
(
)
)
{
return
false
;
}
nsAutoString
type
;
if
(
src
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
&
&
!
SupportedPictureSourceType
(
type
)
)
{
return
false
;
}
return
true
;
}
bool
HTMLImageElement
:
:
TryCreateResponsiveSelector
(
Element
*
aSourceElement
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
bool
isSourceTag
=
aSourceElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
source
)
;
if
(
isSourceTag
)
{
if
(
!
SourceElementMatches
(
aSourceElement
)
)
{
return
false
;
}
auto
*
source
=
HTMLSourceElement
:
:
FromNode
(
aSourceElement
)
;
principal
=
source
-
>
GetSrcsetTriggeringPrincipal
(
)
;
}
else
if
(
aSourceElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
MOZ_ASSERT
(
aSourceElement
=
=
this
)
;
principal
=
mSrcsetTriggeringPrincipal
;
}
nsString
srcset
;
if
(
!
aSourceElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
srcset
srcset
)
)
{
return
false
;
}
if
(
srcset
.
IsEmpty
(
)
)
{
return
false
;
}
RefPtr
<
ResponsiveImageSelector
>
sel
=
new
ResponsiveImageSelector
(
aSourceElement
)
;
if
(
!
sel
-
>
SetCandidatesFromSourceSet
(
srcset
principal
)
)
{
return
false
;
}
nsAutoString
sizes
;
aSourceElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
sizes
sizes
)
;
sel
-
>
SetSizesFromDescriptor
(
sizes
)
;
if
(
!
isSourceTag
)
{
MOZ_ASSERT
(
aSourceElement
=
=
this
)
;
nsAutoString
src
;
if
(
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
&
&
!
src
.
IsEmpty
(
)
)
{
sel
-
>
SetDefaultSource
(
src
mSrcTriggeringPrincipal
)
;
}
}
mResponsiveSelector
=
sel
;
return
true
;
}
bool
HTMLImageElement
:
:
SelectSourceForTagWithAttrs
(
nsIDocument
*
aDocument
bool
aIsSourceTag
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
nsAString
&
aResult
)
{
MOZ_ASSERT
(
aIsSourceTag
|
|
(
aTypeAttr
.
IsEmpty
(
)
&
&
aMediaAttr
.
IsEmpty
(
)
)
"
Passing
type
or
media
attrs
makes
no
sense
without
aIsSourceTag
"
)
;
MOZ_ASSERT
(
!
aIsSourceTag
|
|
aSrcAttr
.
IsEmpty
(
)
"
Passing
aSrcAttr
makes
no
sense
with
aIsSourceTag
set
"
)
;
if
(
aSrcsetAttr
.
IsEmpty
(
)
)
{
if
(
!
aIsSourceTag
)
{
aResult
.
Assign
(
aSrcAttr
)
;
return
true
;
}
return
false
;
}
if
(
aIsSourceTag
&
&
(
(
!
aMediaAttr
.
IsVoid
(
)
&
&
!
HTMLSourceElement
:
:
WouldMatchMediaForDocument
(
aMediaAttr
aDocument
)
)
|
|
(
!
aTypeAttr
.
IsVoid
(
)
&
&
!
SupportedPictureSourceType
(
aTypeAttr
)
)
)
)
{
return
false
;
}
RefPtr
<
ResponsiveImageSelector
>
sel
=
new
ResponsiveImageSelector
(
aDocument
)
;
sel
-
>
SetCandidatesFromSourceSet
(
aSrcsetAttr
)
;
if
(
!
aSizesAttr
.
IsEmpty
(
)
)
{
sel
-
>
SetSizesFromDescriptor
(
aSizesAttr
)
;
}
if
(
!
aIsSourceTag
)
{
sel
-
>
SetDefaultSource
(
aSrcAttr
)
;
}
if
(
sel
-
>
GetSelectedImageURLSpec
(
aResult
)
)
{
return
true
;
}
if
(
!
aIsSourceTag
)
{
aResult
.
Truncate
(
)
;
return
true
;
}
return
false
;
}
void
HTMLImageElement
:
:
DestroyContent
(
)
{
mResponsiveSelector
=
nullptr
;
nsGenericHTMLElement
:
:
DestroyContent
(
)
;
}
void
HTMLImageElement
:
:
MediaFeatureValuesChanged
(
)
{
QueueImageLoadTask
(
false
)
;
}
void
HTMLImageElement
:
:
FlushUseCounters
(
)
{
nsCOMPtr
<
imgIRequest
>
request
;
GetRequest
(
CURRENT_REQUEST
getter_AddRefs
(
request
)
)
;
nsCOMPtr
<
imgIContainer
>
container
;
request
-
>
GetImage
(
getter_AddRefs
(
container
)
)
;
static_cast
<
image
:
:
Image
*
>
(
container
.
get
(
)
)
-
>
ReportUseCounters
(
)
;
}
}
}
