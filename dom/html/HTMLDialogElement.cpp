#
include
"
mozilla
/
dom
/
HTMLDialogElement
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
CloseWatcher
.
h
"
#
include
"
mozilla
/
dom
/
CloseWatcherManager
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDialogElementBinding
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIFrame
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Dialog
)
namespace
mozilla
:
:
dom
{
static
constexpr
nsAttrValue
:
:
EnumTableEntry
kClosedbyTable
[
]
=
{
{
"
"
HTMLDialogElement
:
:
ClosedBy
:
:
Auto
}
{
"
none
"
HTMLDialogElement
:
:
ClosedBy
:
:
None
}
{
"
any
"
HTMLDialogElement
:
:
ClosedBy
:
:
Any
}
{
"
closerequest
"
HTMLDialogElement
:
:
ClosedBy
:
:
CloseRequest
}
}
;
static
constexpr
const
nsAttrValue
:
:
EnumTableEntry
*
kClosedbyAuto
=
&
kClosedbyTable
[
0
]
;
static
constexpr
const
nsAttrValue
:
:
EnumTableEntry
*
kClosedbyDefault
=
&
kClosedbyTable
[
1
]
;
static
constexpr
const
nsAttrValue
:
:
EnumTableEntry
*
kClosedbyModalDefault
=
&
kClosedbyTable
[
3
]
;
HTMLDialogElement
:
:
~
HTMLDialogElement
(
)
=
default
;
NS_IMPL_ELEMENT_CLONE
(
HTMLDialogElement
)
class
DialogCloseWatcherListener
:
public
nsIDOMEventListener
{
public
:
NS_DECL_ISUPPORTS
explicit
DialogCloseWatcherListener
(
HTMLDialogElement
*
aDialog
)
{
mDialog
=
do_GetWeakReference
(
aDialog
)
;
}
NS_IMETHODIMP
HandleEvent
(
Event
*
aEvent
)
override
{
RefPtr
<
nsINode
>
node
=
do_QueryReferent
(
mDialog
)
;
if
(
HTMLDialogElement
*
dialog
=
HTMLDialogElement
:
:
FromNodeOrNull
(
node
)
)
{
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
cancel
"
)
)
{
bool
defaultAction
=
true
;
auto
cancelable
=
aEvent
-
>
Cancelable
(
)
?
Cancelable
:
:
eYes
:
Cancelable
:
:
eNo
;
nsContentUtils
:
:
DispatchTrustedEvent
(
dialog
-
>
OwnerDoc
(
)
dialog
u
"
cancel
"
_ns
CanBubble
:
:
eNo
cancelable
&
defaultAction
)
;
if
(
!
defaultAction
)
{
aEvent
-
>
PreventDefault
(
)
;
}
}
else
if
(
eventType
.
EqualsLiteral
(
"
close
"
)
)
{
Optional
<
nsAString
>
retValue
;
retValue
=
&
dialog
-
>
RequestCloseReturnValue
(
)
;
dialog
-
>
Close
(
retValue
)
;
}
}
return
NS_OK
;
}
private
:
virtual
~
DialogCloseWatcherListener
(
)
=
default
;
nsWeakPtr
mDialog
;
}
;
NS_IMPL_ISUPPORTS
(
DialogCloseWatcherListener
nsIDOMEventListener
)
void
HTMLDialogElement
:
:
GetClosedBy
(
nsAString
&
aResult
)
const
{
aResult
.
Truncate
(
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
dom_dialog_light_dismiss_enabled
(
)
)
;
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
closedby
)
;
if
(
!
val
|
|
val
-
>
GetEnumValue
(
)
=
=
kClosedbyAuto
-
>
value
)
{
const
char
*
tag
=
(
IsInTopLayer
(
)
?
kClosedbyModalDefault
-
>
tag
:
kClosedbyDefault
-
>
tag
)
;
AppendASCIItoUTF16
(
nsDependentCString
(
tag
)
aResult
)
;
return
;
}
val
-
>
GetEnumString
(
aResult
true
)
;
}
HTMLDialogElement
:
:
ClosedBy
HTMLDialogElement
:
:
GetClosedBy
(
)
const
{
if
(
!
StaticPrefs
:
:
dom_dialog_light_dismiss_enabled
(
)
)
{
return
static_cast
<
ClosedBy
>
(
IsInTopLayer
(
)
?
kClosedbyModalDefault
-
>
value
:
kClosedbyDefault
-
>
value
)
;
}
const
nsAttrValue
*
val
=
mAttrs
.
GetAttr
(
nsGkAtoms
:
:
closedby
)
;
if
(
!
val
|
|
val
-
>
GetEnumValue
(
)
=
=
kClosedbyAuto
-
>
value
)
{
return
static_cast
<
ClosedBy
>
(
IsInTopLayer
(
)
?
kClosedbyModalDefault
-
>
value
:
kClosedbyDefault
-
>
value
)
;
}
return
static_cast
<
ClosedBy
>
(
val
-
>
GetEnumValue
(
)
)
;
}
bool
HTMLDialogElement
:
:
ParseClosedByAttribute
(
const
nsAString
&
aValue
nsAttrValue
&
aResult
)
{
return
aResult
.
ParseEnumValue
(
aValue
kClosedbyTable
false
kClosedbyAuto
)
;
}
bool
HTMLDialogElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
StaticPrefs
:
:
dom_dialog_light_dismiss_enabled
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
closedby
)
{
return
ParseClosedByAttribute
(
aValue
aResult
)
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLDialogElement
:
:
Close
(
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
aReturnValue
)
{
if
(
!
Open
(
)
)
{
return
;
}
FireToggleEvent
(
u
"
open
"
_ns
u
"
closed
"
_ns
u
"
beforetoggle
"
_ns
)
;
if
(
!
Open
(
)
)
{
return
;
}
QueueToggleEventTask
(
)
;
if
(
aReturnValue
.
WasPassed
(
)
)
{
SetReturnValue
(
aReturnValue
.
Value
(
)
)
;
}
SetOpen
(
false
IgnoreErrors
(
)
)
;
RemoveFromTopLayerIfNeeded
(
)
;
MOZ_ASSERT
(
!
OwnerDoc
(
)
-
>
DialogIsInOpenDialogsList
(
*
this
)
"
Dialog
should
not
being
in
Open
Dialog
List
"
)
;
RefPtr
<
Element
>
previouslyFocusedElement
=
do_QueryReferent
(
mPreviouslyFocusedElement
)
;
if
(
previouslyFocusedElement
)
{
mPreviouslyFocusedElement
=
nullptr
;
FocusOptions
options
;
options
.
mPreventScroll
=
true
;
previouslyFocusedElement
-
>
Focus
(
options
CallerType
:
:
NonSystem
IgnoredErrorResult
(
)
)
;
}
RefPtr
<
AsyncEventDispatcher
>
eventDispatcher
=
new
AsyncEventDispatcher
(
this
u
"
close
"
_ns
CanBubble
:
:
eNo
)
;
eventDispatcher
-
>
PostDOMEvent
(
)
;
if
(
mCloseWatcher
)
{
mCloseWatcher
-
>
Destroy
(
)
;
mCloseWatcher
=
nullptr
;
}
}
void
HTMLDialogElement
:
:
RequestClose
(
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
aReturnValue
)
{
if
(
!
Open
(
)
)
{
return
;
}
if
(
aReturnValue
.
WasPassed
(
)
)
{
mRequestCloseReturnValue
=
aReturnValue
.
Value
(
)
;
}
else
{
mRequestCloseReturnValue
.
SetIsVoid
(
true
)
;
}
RunCancelDialogSteps
(
)
;
}
void
HTMLDialogElement
:
:
Show
(
ErrorResult
&
aError
)
{
if
(
Open
(
)
)
{
if
(
!
IsInTopLayer
(
)
)
{
return
;
}
return
aError
.
ThrowInvalidStateError
(
"
Cannot
call
show
(
)
on
an
open
modal
dialog
.
"
)
;
}
if
(
FireToggleEvent
(
u
"
closed
"
_ns
u
"
open
"
_ns
u
"
beforetoggle
"
_ns
)
)
{
return
;
}
if
(
Open
(
)
)
{
return
;
}
QueueToggleEventTask
(
)
;
SetOpen
(
true
IgnoreErrors
(
)
)
;
if
(
StaticPrefs
:
:
dom_closewatcher_enabled
(
)
)
{
SetDialogCloseWatcherIfNeeded
(
)
;
}
StorePreviouslyFocusedElement
(
)
;
RefPtr
<
nsINode
>
hideUntil
=
GetTopmostPopoverAncestor
(
nullptr
false
)
;
if
(
!
hideUntil
)
{
hideUntil
=
OwnerDoc
(
)
;
}
OwnerDoc
(
)
-
>
HideAllPopoversUntil
(
*
hideUntil
false
true
)
;
FocusDialog
(
)
;
}
bool
HTMLDialogElement
:
:
Open
(
)
const
{
MOZ_ASSERT
(
GetBoolAttr
(
nsGkAtoms
:
:
open
)
=
=
State
(
)
.
HasState
(
ElementState
:
:
OPEN
)
)
;
return
State
(
)
.
HasState
(
ElementState
:
:
OPEN
)
;
}
bool
HTMLDialogElement
:
:
IsInTopLayer
(
)
const
{
return
State
(
)
.
HasState
(
ElementState
:
:
MODAL
)
;
}
void
HTMLDialogElement
:
:
AddToTopLayerIfNeeded
(
)
{
MOZ_ASSERT
(
IsInComposedDoc
(
)
)
;
if
(
IsInTopLayer
(
)
)
{
return
;
}
OwnerDoc
(
)
-
>
AddModalDialog
(
*
this
)
;
}
void
HTMLDialogElement
:
:
RemoveFromTopLayerIfNeeded
(
)
{
if
(
!
IsInTopLayer
(
)
)
{
return
;
}
OwnerDoc
(
)
-
>
RemoveModalDialog
(
*
this
)
;
}
void
HTMLDialogElement
:
:
StorePreviouslyFocusedElement
(
)
{
if
(
Element
*
element
=
nsFocusManager
:
:
GetFocusedElementStatic
(
)
)
{
if
(
NS_SUCCEEDED
(
nsContentUtils
:
:
CheckSameOrigin
(
this
element
)
)
)
{
mPreviouslyFocusedElement
=
do_GetWeakReference
(
element
)
;
}
}
else
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
if
(
nsIContent
*
unretargetedFocus
=
doc
-
>
GetUnretargetedFocusedContent
(
)
)
{
mPreviouslyFocusedElement
=
do_GetWeakReference
(
unretargetedFocus
)
;
}
}
}
nsresult
HTMLDialogElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
MOZ_TRY
(
nsGenericHTMLElement
:
:
BindToTree
(
aContext
aParent
)
)
;
if
(
Open
(
)
)
{
SetupSteps
(
)
;
}
return
NS_OK
;
}
void
HTMLDialogElement
:
:
UnbindFromTree
(
UnbindContext
&
aContext
)
{
if
(
Open
(
)
)
{
CleanupSteps
(
)
;
}
RemoveFromTopLayerIfNeeded
(
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aContext
)
;
}
void
HTMLDialogElement
:
:
ShowModal
(
ErrorResult
&
aError
)
{
if
(
Open
(
)
)
{
if
(
IsInTopLayer
(
)
)
{
return
;
}
return
aError
.
ThrowInvalidStateError
(
"
Cannot
call
showModal
(
)
on
an
open
non
-
modal
dialog
.
"
)
;
}
if
(
!
OwnerDoc
(
)
-
>
IsFullyActive
(
)
)
{
return
aError
.
ThrowInvalidStateError
(
"
The
owner
document
is
not
fully
active
"
)
;
}
if
(
!
IsInComposedDoc
(
)
)
{
return
aError
.
ThrowInvalidStateError
(
"
Dialog
element
is
not
connected
"
)
;
}
if
(
IsPopoverOpen
(
)
)
{
return
aError
.
ThrowInvalidStateError
(
"
Dialog
element
is
already
an
open
popover
.
"
)
;
}
if
(
FireToggleEvent
(
u
"
closed
"
_ns
u
"
open
"
_ns
u
"
beforetoggle
"
_ns
)
)
{
return
;
}
if
(
Open
(
)
|
|
!
IsInComposedDoc
(
)
|
|
IsPopoverOpen
(
)
)
{
return
;
}
QueueToggleEventTask
(
)
;
SetOpen
(
true
aError
)
;
AddToTopLayerIfNeeded
(
)
;
if
(
StaticPrefs
:
:
dom_closewatcher_enabled
(
)
)
{
SetDialogCloseWatcherIfNeeded
(
)
;
}
StorePreviouslyFocusedElement
(
)
;
RefPtr
<
nsINode
>
hideUntil
=
GetTopmostPopoverAncestor
(
nullptr
false
)
;
if
(
!
hideUntil
)
{
hideUntil
=
OwnerDoc
(
)
;
}
OwnerDoc
(
)
-
>
HideAllPopoversUntil
(
*
hideUntil
false
true
)
;
FocusDialog
(
)
;
aError
.
SuppressException
(
)
;
}
void
HTMLDialogElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
{
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aMaybeScriptedPrincipal
aNotify
)
;
if
(
aNameSpaceID
!
=
kNameSpaceID_None
)
{
return
;
}
if
(
aName
=
=
nsGkAtoms
:
:
closedby
)
{
if
(
StaticPrefs
:
:
dom_closewatcher_enabled
(
)
&
&
IsInComposedDoc
(
)
&
&
Open
(
)
)
{
SetDialogCloseWatcherIfNeeded
(
)
;
}
}
if
(
aName
!
=
nsGkAtoms
:
:
open
)
{
return
;
}
bool
wasOpen
=
!
!
aOldValue
;
bool
isOpen
=
!
!
aValue
;
MOZ_ASSERT
(
GetBoolAttr
(
nsGkAtoms
:
:
open
)
=
=
isOpen
)
;
SetStates
(
ElementState
:
:
OPEN
isOpen
)
;
if
(
!
isOpen
&
&
wasOpen
)
{
CleanupSteps
(
)
;
}
if
(
isOpen
&
&
!
wasOpen
)
{
SetupSteps
(
)
;
}
}
void
HTMLDialogElement
:
:
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
{
if
(
mToggleEventDispatcher
=
=
aEvent
)
{
mToggleEventDispatcher
=
nullptr
;
}
}
void
HTMLDialogElement
:
:
FocusDialog
(
)
{
RefPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
if
(
IsInComposedDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
RefPtr
<
Element
>
control
=
HasAttr
(
nsGkAtoms
:
:
autofocus
)
?
this
:
GetFocusDelegate
(
IsFocusableFlags
(
0
)
)
;
if
(
!
control
)
{
control
=
this
;
}
FocusCandidate
(
control
IsInTopLayer
(
)
)
;
}
int32_t
HTMLDialogElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
void
HTMLDialogElement
:
:
QueueCancelDialog
(
)
{
OwnerDoc
(
)
-
>
Dispatch
(
NewRunnableMethod
(
"
HTMLDialogElement
:
:
RunCancelDialogSteps
"
this
&
HTMLDialogElement
:
:
RunCancelDialogSteps
)
)
;
}
void
HTMLDialogElement
:
:
RunCancelDialogSteps
(
)
{
bool
defaultAction
=
true
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
this
u
"
cancel
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eYes
&
defaultAction
)
;
if
(
defaultAction
)
{
Optional
<
nsAString
>
retValue
;
retValue
=
&
RequestCloseReturnValue
(
)
;
Close
(
retValue
)
;
}
}
bool
HTMLDialogElement
:
:
IsValidCommandAction
(
Command
aCommand
)
const
{
return
nsGenericHTMLElement
:
:
IsValidCommandAction
(
aCommand
)
|
|
aCommand
=
=
Command
:
:
ShowModal
|
|
aCommand
=
=
Command
:
:
Close
;
}
bool
HTMLDialogElement
:
:
HandleCommandInternal
(
Element
*
aSource
Command
aCommand
ErrorResult
&
aRv
)
{
if
(
nsGenericHTMLElement
:
:
HandleCommandInternal
(
aSource
aCommand
aRv
)
)
{
return
true
;
}
MOZ_ASSERT
(
IsValidCommandAction
(
aCommand
)
)
;
const
bool
actionMayClose
=
aCommand
=
=
Command
:
:
Auto
|
|
aCommand
=
=
Command
:
:
Close
;
const
bool
actionMayOpen
=
aCommand
=
=
Command
:
:
Auto
|
|
aCommand
=
=
Command
:
:
ShowModal
;
if
(
actionMayClose
&
&
Open
(
)
)
{
Optional
<
nsAString
>
retValue
;
Close
(
retValue
)
;
return
true
;
}
if
(
IsInComposedDoc
(
)
&
&
!
Open
(
)
&
&
actionMayOpen
)
{
ShowModal
(
aRv
)
;
return
true
;
}
return
false
;
}
void
HTMLDialogElement
:
:
QueueToggleEventTask
(
)
{
nsAutoString
oldState
;
auto
newState
=
Open
(
)
?
u
"
closed
"
_ns
:
u
"
open
"
_ns
;
if
(
mToggleEventDispatcher
)
{
oldState
.
Truncate
(
)
;
static_cast
<
ToggleEvent
*
>
(
mToggleEventDispatcher
-
>
mEvent
.
get
(
)
)
-
>
GetOldState
(
oldState
)
;
mToggleEventDispatcher
-
>
Cancel
(
)
;
}
else
{
oldState
.
Assign
(
Open
(
)
?
u
"
open
"
_ns
:
u
"
closed
"
_ns
)
;
}
RefPtr
<
ToggleEvent
>
toggleEvent
=
CreateToggleEvent
(
u
"
toggle
"
_ns
oldState
newState
Cancelable
:
:
eNo
)
;
mToggleEventDispatcher
=
new
AsyncEventDispatcher
(
this
toggleEvent
.
forget
(
)
)
;
mToggleEventDispatcher
-
>
PostDOMEvent
(
)
;
}
void
HTMLDialogElement
:
:
SetDialogCloseWatcherIfNeeded
(
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
dom_closewatcher_enabled
(
)
"
CloseWatcher
enabled
"
)
;
if
(
mCloseWatcher
)
{
SetCloseWatcherEnabledState
(
)
;
return
;
}
RefPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
RefPtr
window
=
doc
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
mCloseWatcher
=
new
CloseWatcher
(
window
)
;
RefPtr
<
DialogCloseWatcherListener
>
eventListener
=
new
DialogCloseWatcherListener
(
this
)
;
mCloseWatcher
-
>
AddSystemEventListener
(
u
"
cancel
"
_ns
eventListener
false
false
)
;
mCloseWatcher
-
>
AddSystemEventListener
(
u
"
close
"
_ns
eventListener
false
false
)
;
SetCloseWatcherEnabledState
(
)
;
window
-
>
EnsureCloseWatcherManager
(
)
-
>
Add
(
*
mCloseWatcher
)
;
}
void
HTMLDialogElement
:
:
SetupSteps
(
)
{
if
(
StaticPrefs
:
:
dom_closewatcher_enabled
(
)
)
{
SetDialogCloseWatcherIfNeeded
(
)
;
}
if
(
!
IsInComposedDoc
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
OwnerDoc
(
)
-
>
DialogIsInOpenDialogsList
(
*
this
)
)
;
OwnerDoc
(
)
-
>
AddOpenDialog
(
*
this
)
;
}
void
HTMLDialogElement
:
:
SetCloseWatcherEnabledState
(
)
{
if
(
StaticPrefs
:
:
dom_closewatcher_enabled
(
)
)
{
MOZ_ASSERT
(
mCloseWatcher
)
;
mCloseWatcher
-
>
SetEnabled
(
GetClosedBy
(
)
!
=
ClosedBy
:
:
None
)
;
}
}
void
HTMLDialogElement
:
:
CleanupSteps
(
)
{
OwnerDoc
(
)
-
>
RemoveOpenDialog
(
*
this
)
;
if
(
mCloseWatcher
)
{
mCloseWatcher
-
>
Destroy
(
)
;
mCloseWatcher
=
nullptr
;
}
}
JSObject
*
HTMLDialogElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLDialogElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
