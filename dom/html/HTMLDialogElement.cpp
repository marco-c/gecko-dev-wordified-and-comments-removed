#
include
"
mozilla
/
dom
/
HTMLDialogElement
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDialogElementBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIFrame
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Dialog
)
namespace
mozilla
:
:
dom
{
HTMLDialogElement
:
:
~
HTMLDialogElement
(
)
=
default
;
NS_IMPL_ELEMENT_CLONE
(
HTMLDialogElement
)
void
HTMLDialogElement
:
:
Close
(
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
aReturnValue
)
{
if
(
!
Open
(
)
)
{
return
;
}
if
(
aReturnValue
.
WasPassed
(
)
)
{
SetReturnValue
(
aReturnValue
.
Value
(
)
)
;
}
SetOpen
(
false
IgnoreErrors
(
)
)
;
RemoveFromTopLayerIfNeeded
(
)
;
RefPtr
<
Element
>
previouslyFocusedElement
=
do_QueryReferent
(
mPreviouslyFocusedElement
)
;
if
(
previouslyFocusedElement
)
{
mPreviouslyFocusedElement
=
nullptr
;
FocusOptions
options
;
options
.
mPreventScroll
=
true
;
previouslyFocusedElement
-
>
Focus
(
options
CallerType
:
:
NonSystem
IgnoredErrorResult
(
)
)
;
}
RefPtr
<
AsyncEventDispatcher
>
eventDispatcher
=
new
AsyncEventDispatcher
(
this
u
"
close
"
_ns
CanBubble
:
:
eNo
)
;
eventDispatcher
-
>
PostDOMEvent
(
)
;
}
void
HTMLDialogElement
:
:
Show
(
ErrorResult
&
aError
)
{
if
(
Open
(
)
)
{
if
(
!
IsInTopLayer
(
)
)
{
return
;
}
return
aError
.
ThrowInvalidStateError
(
"
Cannot
call
show
(
)
on
an
open
modal
dialog
.
"
)
;
}
SetOpen
(
true
IgnoreErrors
(
)
)
;
StorePreviouslyFocusedElement
(
)
;
OwnerDoc
(
)
-
>
HideAllPopoversWithoutRunningScript
(
)
;
FocusDialog
(
)
;
}
bool
HTMLDialogElement
:
:
IsInTopLayer
(
)
const
{
return
State
(
)
.
HasState
(
ElementState
:
:
MODAL
)
;
}
void
HTMLDialogElement
:
:
AddToTopLayerIfNeeded
(
)
{
MOZ_ASSERT
(
IsInComposedDoc
(
)
)
;
if
(
IsInTopLayer
(
)
)
{
return
;
}
OwnerDoc
(
)
-
>
AddModalDialog
(
*
this
)
;
}
void
HTMLDialogElement
:
:
RemoveFromTopLayerIfNeeded
(
)
{
if
(
!
IsInTopLayer
(
)
)
{
return
;
}
OwnerDoc
(
)
-
>
RemoveModalDialog
(
*
this
)
;
}
void
HTMLDialogElement
:
:
StorePreviouslyFocusedElement
(
)
{
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
if
(
nsIContent
*
unretargetedFocus
=
doc
-
>
GetUnretargetedFocusedContent
(
)
)
{
mPreviouslyFocusedElement
=
do_GetWeakReference
(
unretargetedFocus
-
>
AsElement
(
)
)
;
}
}
}
void
HTMLDialogElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
RemoveFromTopLayerIfNeeded
(
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aNullParent
)
;
}
void
HTMLDialogElement
:
:
ShowModal
(
ErrorResult
&
aError
)
{
if
(
Open
(
)
)
{
if
(
IsInTopLayer
(
)
)
{
return
;
}
return
aError
.
ThrowInvalidStateError
(
"
Cannot
call
showModal
(
)
on
an
open
non
-
modal
dialog
.
"
)
;
}
if
(
!
IsInComposedDoc
(
)
)
{
return
aError
.
ThrowInvalidStateError
(
"
Dialog
element
is
not
connected
"
)
;
}
if
(
IsPopoverOpen
(
)
)
{
return
aError
.
ThrowInvalidStateError
(
"
Dialog
element
is
already
an
open
popover
.
"
)
;
}
AddToTopLayerIfNeeded
(
)
;
SetOpen
(
true
aError
)
;
StorePreviouslyFocusedElement
(
)
;
OwnerDoc
(
)
-
>
HideAllPopoversWithoutRunningScript
(
)
;
FocusDialog
(
)
;
aError
.
SuppressException
(
)
;
}
void
HTMLDialogElement
:
:
FocusDialog
(
)
{
RefPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
if
(
IsInComposedDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
RefPtr
<
Element
>
control
=
GetFocusDelegate
(
false
)
;
if
(
!
control
)
{
control
=
this
;
}
FocusCandidate
(
*
control
IsInTopLayer
(
)
)
;
}
void
HTMLDialogElement
:
:
QueueCancelDialog
(
)
{
OwnerDoc
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
UI
)
-
>
Dispatch
(
NewRunnableMethod
(
"
HTMLDialogElement
:
:
RunCancelDialogSteps
"
this
&
HTMLDialogElement
:
:
RunCancelDialogSteps
)
)
;
}
void
HTMLDialogElement
:
:
RunCancelDialogSteps
(
)
{
bool
defaultAction
=
true
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
this
u
"
cancel
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eYes
&
defaultAction
)
;
if
(
defaultAction
)
{
Optional
<
nsAString
>
retValue
;
Close
(
retValue
)
;
}
}
JSObject
*
HTMLDialogElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLDialogElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
