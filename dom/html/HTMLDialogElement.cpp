#
include
"
mozilla
/
dom
/
HTMLDialogElement
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDialogElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLUnknownElement
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIFrame
.
h
"
nsGenericHTMLElement
*
NS_NewHTMLDialogElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
mozilla
:
:
dom
:
:
FromParser
aFromParser
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
(
aNodeInfo
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
bool
isChromeDocument
=
nsContentUtils
:
:
IsChromeDoc
(
nodeInfo
-
>
GetDocument
(
)
)
;
if
(
mozilla
:
:
StaticPrefs
:
:
dom_dialog_element_enabled
(
)
|
|
isChromeDocument
)
{
return
new
(
nim
)
mozilla
:
:
dom
:
:
HTMLDialogElement
(
nodeInfo
.
forget
(
)
)
;
}
return
new
(
nim
)
mozilla
:
:
dom
:
:
HTMLUnknownElement
(
nodeInfo
.
forget
(
)
)
;
}
namespace
mozilla
:
:
dom
{
HTMLDialogElement
:
:
~
HTMLDialogElement
(
)
=
default
;
NS_IMPL_ELEMENT_CLONE
(
HTMLDialogElement
)
bool
HTMLDialogElement
:
:
IsDialogEnabled
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
)
{
return
StaticPrefs
:
:
dom_dialog_element_enabled
(
)
|
|
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
;
}
void
HTMLDialogElement
:
:
Close
(
const
mozilla
:
:
dom
:
:
Optional
<
nsAString
>
&
aReturnValue
)
{
if
(
!
Open
(
)
)
{
return
;
}
if
(
aReturnValue
.
WasPassed
(
)
)
{
SetReturnValue
(
aReturnValue
.
Value
(
)
)
;
}
SetOpen
(
false
IgnoreErrors
(
)
)
;
RemoveFromTopLayerIfNeeded
(
)
;
RefPtr
<
Element
>
previouslyFocusedElement
=
do_QueryReferent
(
mPreviouslyFocusedElement
)
;
if
(
previouslyFocusedElement
)
{
mPreviouslyFocusedElement
=
nullptr
;
FocusOptions
options
;
options
.
mPreventScroll
=
true
;
previouslyFocusedElement
-
>
Focus
(
options
CallerType
:
:
NonSystem
IgnoredErrorResult
(
)
)
;
}
RefPtr
<
AsyncEventDispatcher
>
eventDispatcher
=
new
AsyncEventDispatcher
(
this
u
"
close
"
_ns
CanBubble
:
:
eNo
)
;
eventDispatcher
-
>
PostDOMEvent
(
)
;
}
void
HTMLDialogElement
:
:
Show
(
)
{
if
(
Open
(
)
)
{
return
;
}
SetOpen
(
true
IgnoreErrors
(
)
)
;
StorePreviouslyFocusedElement
(
)
;
FocusDialog
(
)
;
}
bool
HTMLDialogElement
:
:
IsInTopLayer
(
)
const
{
return
State
(
)
.
HasState
(
NS_EVENT_STATE_MODAL_DIALOG
)
;
}
void
HTMLDialogElement
:
:
AddToTopLayerIfNeeded
(
)
{
if
(
IsInTopLayer
(
)
)
{
return
;
}
Document
*
doc
=
OwnerDoc
(
)
;
doc
-
>
TopLayerPush
(
this
)
;
doc
-
>
SetBlockedByModalDialog
(
*
this
)
;
AddStates
(
NS_EVENT_STATE_MODAL_DIALOG
)
;
}
void
HTMLDialogElement
:
:
RemoveFromTopLayerIfNeeded
(
)
{
if
(
!
IsInTopLayer
(
)
)
{
return
;
}
auto
predictFunc
=
[
&
]
(
Element
*
element
)
{
return
element
=
=
this
;
}
;
Document
*
doc
=
OwnerDoc
(
)
;
DebugOnly
<
Element
*
>
removedElement
=
doc
-
>
TopLayerPop
(
predictFunc
)
;
MOZ_ASSERT
(
removedElement
=
=
this
)
;
RemoveStates
(
NS_EVENT_STATE_MODAL_DIALOG
)
;
doc
-
>
UnsetBlockedByModalDialog
(
*
this
)
;
}
void
HTMLDialogElement
:
:
StorePreviouslyFocusedElement
(
)
{
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
if
(
nsIContent
*
unretargetedFocus
=
doc
-
>
GetUnretargetedFocusedContent
(
)
)
{
mPreviouslyFocusedElement
=
do_GetWeakReference
(
unretargetedFocus
-
>
AsElement
(
)
)
;
}
}
}
void
HTMLDialogElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
RemoveFromTopLayerIfNeeded
(
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aNullParent
)
;
}
void
HTMLDialogElement
:
:
ShowModal
(
ErrorResult
&
aError
)
{
if
(
!
IsInComposedDoc
(
)
)
{
aError
.
ThrowInvalidStateError
(
"
Dialog
element
is
not
connected
"
)
;
return
;
}
if
(
Open
(
)
)
{
aError
.
ThrowInvalidStateError
(
"
Dialog
element
already
has
an
'
open
'
attribute
"
)
;
return
;
}
AddToTopLayerIfNeeded
(
)
;
SetOpen
(
true
aError
)
;
StorePreviouslyFocusedElement
(
)
;
FocusDialog
(
)
;
aError
.
SuppressException
(
)
;
}
void
HTMLDialogElement
:
:
FocusDialog
(
)
{
if
(
RefPtr
<
Document
>
doc
=
GetComposedDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
Element
*
control
=
nullptr
;
for
(
auto
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextNode
(
this
)
)
{
auto
*
element
=
Element
:
:
FromNode
(
child
)
;
if
(
!
element
)
{
continue
;
}
nsIFrame
*
frame
=
element
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsFocusable
(
)
)
{
continue
;
}
if
(
element
-
>
HasAttr
(
nsGkAtoms
:
:
autofocus
)
)
{
control
=
element
;
break
;
}
if
(
!
control
)
{
control
=
element
;
}
}
if
(
!
control
)
{
control
=
this
;
}
ErrorResult
rv
;
nsIFrame
*
frame
=
control
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsFocusable
(
)
)
{
control
-
>
Focus
(
FocusOptions
(
)
CallerType
:
:
NonSystem
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
}
else
if
(
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
fm
-
>
ClearFocus
(
OwnerDoc
(
)
-
>
GetWindow
(
)
)
;
}
BrowsingContext
*
bc
=
control
-
>
OwnerDoc
(
)
-
>
GetBrowsingContext
(
)
;
if
(
bc
&
&
bc
-
>
SameOriginWithTop
(
)
)
{
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
bc
-
>
Top
(
)
-
>
GetDocShell
(
)
)
{
if
(
Document
*
topDocument
=
docShell
-
>
GetExtantDocument
(
)
)
{
topDocument
-
>
SetAutoFocusFired
(
)
;
}
}
}
}
void
HTMLDialogElement
:
:
QueueCancelDialog
(
)
{
OwnerDoc
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
UI
)
-
>
Dispatch
(
NewRunnableMethod
(
"
HTMLDialogElement
:
:
RunCancelDialogSteps
"
this
&
HTMLDialogElement
:
:
RunCancelDialogSteps
)
)
;
}
void
HTMLDialogElement
:
:
RunCancelDialogSteps
(
)
{
bool
defaultAction
=
true
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
this
u
"
cancel
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eYes
&
defaultAction
)
;
if
(
defaultAction
)
{
Optional
<
nsAString
>
retValue
;
Close
(
retValue
)
;
}
}
JSObject
*
HTMLDialogElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLDialogElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
