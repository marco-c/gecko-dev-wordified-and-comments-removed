#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPUtils
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
dom
/
nsMixedContentBlocker
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormControlsCollection
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElementBinding
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFormControlFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
HTMLFormSubmissionConstants
.
h
"
#
include
"
mozilla
/
dom
/
FormData
.
h
"
#
include
"
mozilla
/
dom
/
FormDataEvent
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIFormSubmitObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsCategoryManagerUtils
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsISecurityUITelemetry
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
nsIRadioVisitor
.
h
"
#
include
"
RadioNodeList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsIConstraintValidation
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLButtonElement
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Form
)
namespace
mozilla
{
namespace
dom
{
static
const
uint8_t
NS_FORM_AUTOCOMPLETE_ON
=
1
;
static
const
uint8_t
NS_FORM_AUTOCOMPLETE_OFF
=
0
;
static
const
nsAttrValue
:
:
EnumTable
kFormAutocompleteTable
[
]
=
{
{
"
on
"
NS_FORM_AUTOCOMPLETE_ON
}
{
"
off
"
NS_FORM_AUTOCOMPLETE_OFF
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
*
kFormDefaultAutocomplete
=
&
kFormAutocompleteTable
[
0
]
;
HTMLFormElement
:
:
HTMLFormElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsGenericHTMLElement
(
std
:
:
move
(
aNodeInfo
)
)
mControls
(
new
HTMLFormControlsCollection
(
this
)
)
mSelectedRadioButtons
(
2
)
mRequiredRadioButtonCounts
(
2
)
mValueMissingRadioGroups
(
2
)
mPendingSubmission
(
nullptr
)
mSubmittingRequest
(
nullptr
)
mDefaultSubmitElement
(
nullptr
)
mFirstSubmitInElements
(
nullptr
)
mFirstSubmitNotInElements
(
nullptr
)
mImageNameLookupTable
(
FORM_CONTROL_LIST_HASHTABLE_LENGTH
)
mPastNameLookupTable
(
FORM_CONTROL_LIST_HASHTABLE_LENGTH
)
mSubmitPopupState
(
PopupBlocker
:
:
openAbused
)
mInvalidElementsCount
(
0
)
mFormNumber
(
-
1
)
mGeneratingSubmit
(
false
)
mGeneratingReset
(
false
)
mIsSubmitting
(
false
)
mDeferSubmission
(
false
)
mNotifiedObservers
(
false
)
mNotifiedObserversResult
(
false
)
mEverTriedInvalidSubmit
(
false
)
mIsConstructingEntryList
(
false
)
{
AddStatesSilently
(
NS_EVENT_STATE_VALID
)
;
}
HTMLFormElement
:
:
~
HTMLFormElement
(
)
{
if
(
mControls
)
{
mControls
-
>
DropFormReference
(
)
;
}
Clear
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLFormElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLFormElement
nsGenericHTMLElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mControls
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mImageNameLookupTable
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPastNameLookupTable
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectedRadioButtons
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLFormElement
nsGenericHTMLElement
)
tmp
-
>
Clear
(
)
;
tmp
-
>
mExpandoAndGeneration
.
OwnerUnlinked
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLFormElement
nsGenericHTMLElement
nsIForm
nsIWebProgressListener
nsIRadioGroupContainer
)
void
HTMLFormElement
:
:
AsyncEventRunning
(
AsyncEventDispatcher
*
aEvent
)
{
if
(
mFormPasswordEventDispatcher
=
=
aEvent
)
{
mFormPasswordEventDispatcher
=
nullptr
;
}
}
NS_IMPL_ELEMENT_CLONE
(
HTMLFormElement
)
nsIHTMLCollection
*
HTMLFormElement
:
:
Elements
(
)
{
return
mControls
;
}
nsresult
HTMLFormElement
:
:
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
action
|
|
aName
=
=
nsGkAtoms
:
:
target
)
{
bool
notifiedObservers
=
mNotifiedObservers
;
ForgetCurrentSubmission
(
)
;
mNotifiedObservers
=
notifiedObservers
;
}
}
return
nsGenericHTMLElement
:
:
BeforeSetAttr
(
aNamespaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLFormElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aName
=
=
nsGkAtoms
:
:
novalidate
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
for
(
uint32_t
i
=
0
length
=
mControls
-
>
mElements
.
Length
(
)
;
i
<
length
;
+
+
i
)
{
mControls
-
>
mElements
[
i
]
-
>
UpdateState
(
true
)
;
}
for
(
uint32_t
i
=
0
length
=
mControls
-
>
mNotInElements
.
Length
(
)
;
i
<
length
;
+
+
i
)
{
mControls
-
>
mNotInElements
[
i
]
-
>
UpdateState
(
true
)
;
}
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
void
HTMLFormElement
:
:
GetAutocomplete
(
nsAString
&
aValue
)
{
GetEnumAttr
(
nsGkAtoms
:
:
autocomplete
kFormDefaultAutocomplete
-
>
tag
aValue
)
;
}
void
HTMLFormElement
:
:
GetEnctype
(
nsAString
&
aValue
)
{
GetEnumAttr
(
nsGkAtoms
:
:
enctype
kFormDefaultEnctype
-
>
tag
aValue
)
;
}
void
HTMLFormElement
:
:
GetMethod
(
nsAString
&
aValue
)
{
GetEnumAttr
(
nsGkAtoms
:
:
method
kFormDefaultMethod
-
>
tag
aValue
)
;
}
void
HTMLFormElement
:
:
MaybeSubmit
(
Element
*
aSubmitter
)
{
#
ifdef
DEBUG
if
(
aSubmitter
)
{
nsCOMPtr
<
nsIFormControl
>
fc
=
do_QueryInterface
(
aSubmitter
)
;
MOZ_ASSERT
(
fc
)
;
MOZ_ASSERT
(
fc
-
>
IsSubmitControl
(
)
"
aSubmitter
is
not
a
submit
control
?
"
)
;
}
#
endif
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
mIsConstructingEntryList
|
|
!
doc
|
|
(
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_FORMS
)
)
{
return
;
}
bool
noValidateState
=
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
|
|
(
aSubmitter
&
&
aSubmitter
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
formnovalidate
)
)
;
if
(
!
noValidateState
&
&
!
CheckValidFormSubmission
(
)
)
{
return
;
}
if
(
RefPtr
<
PresShell
>
presShell
=
doc
-
>
GetPresShell
(
)
)
{
InternalFormEvent
event
(
true
eFormSubmit
)
;
event
.
mOriginator
=
aSubmitter
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
presShell
-
>
HandleDOMEventWithTarget
(
this
&
event
&
status
)
;
}
}
void
HTMLFormElement
:
:
MaybeReset
(
Element
*
aSubmitter
)
{
if
(
RefPtr
<
PresShell
>
presShell
=
OwnerDoc
(
)
-
>
GetPresShell
(
)
)
{
InternalFormEvent
event
(
true
eFormReset
)
;
event
.
mOriginator
=
aSubmitter
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
presShell
-
>
HandleDOMEventWithTarget
(
this
&
event
&
status
)
;
}
}
void
HTMLFormElement
:
:
Submit
(
ErrorResult
&
aRv
)
{
if
(
mPendingSubmission
)
{
mPendingSubmission
=
nullptr
;
}
aRv
=
DoSubmitOrReset
(
nullptr
eFormSubmit
)
;
}
void
HTMLFormElement
:
:
Reset
(
)
{
InternalFormEvent
event
(
true
eFormReset
)
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
nullptr
&
event
)
;
}
bool
HTMLFormElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
method
)
{
return
aResult
.
ParseEnumValue
(
aValue
kFormMethodTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
enctype
)
{
return
aResult
.
ParseEnumValue
(
aValue
kFormEnctypeTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
autocomplete
)
{
return
aResult
.
ParseEnumValue
(
aValue
kFormAutocompleteTable
false
)
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
nsresult
HTMLFormElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsInUncomposedDoc
(
)
&
&
aContext
.
OwnerDoc
(
)
.
IsHTMLOrXHTML
(
)
)
{
aContext
.
OwnerDoc
(
)
.
AsHTMLDocument
(
)
-
>
AddedForm
(
)
;
}
return
rv
;
}
template
<
typename
T
>
static
void
MarkOrphans
(
const
nsTArray
<
T
*
>
&
aArray
)
{
uint32_t
length
=
aArray
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
aArray
[
i
]
-
>
SetFlags
(
MAYBE_ORPHAN_FORM_ELEMENT
)
;
}
}
static
void
CollectOrphans
(
nsINode
*
aRemovalRoot
const
nsTArray
<
nsGenericHTMLFormElement
*
>
&
aArray
#
ifdef
DEBUG
HTMLFormElement
*
aThisForm
#
endif
)
{
nsAutoScriptBlocker
scriptBlocker
;
uint32_t
length
=
aArray
.
Length
(
)
;
for
(
uint32_t
i
=
length
;
i
>
0
;
-
-
i
)
{
nsGenericHTMLFormElement
*
node
=
aArray
[
i
-
1
]
;
#
ifdef
DEBUG
bool
removed
=
false
;
#
endif
if
(
node
-
>
HasFlag
(
MAYBE_ORPHAN_FORM_ELEMENT
)
)
{
node
-
>
UnsetFlags
(
MAYBE_ORPHAN_FORM_ELEMENT
)
;
if
(
!
node
-
>
IsInclusiveDescendantOf
(
aRemovalRoot
)
)
{
node
-
>
ClearForm
(
true
false
)
;
node
-
>
UpdateState
(
true
)
;
#
ifdef
DEBUG
removed
=
true
;
#
endif
}
}
#
ifdef
DEBUG
if
(
!
removed
)
{
HTMLFormElement
*
form
=
node
-
>
GetForm
(
)
;
NS_ASSERTION
(
form
=
=
aThisForm
"
How
did
that
happen
?
"
)
;
}
#
endif
}
}
static
void
CollectOrphans
(
nsINode
*
aRemovalRoot
const
nsTArray
<
HTMLImageElement
*
>
&
aArray
#
ifdef
DEBUG
HTMLFormElement
*
aThisForm
#
endif
)
{
uint32_t
length
=
aArray
.
Length
(
)
;
for
(
uint32_t
i
=
length
;
i
>
0
;
-
-
i
)
{
HTMLImageElement
*
node
=
aArray
[
i
-
1
]
;
#
ifdef
DEBUG
bool
removed
=
false
;
#
endif
if
(
node
-
>
HasFlag
(
MAYBE_ORPHAN_FORM_ELEMENT
)
)
{
node
-
>
UnsetFlags
(
MAYBE_ORPHAN_FORM_ELEMENT
)
;
if
(
!
node
-
>
IsInclusiveDescendantOf
(
aRemovalRoot
)
)
{
node
-
>
ClearForm
(
true
)
;
#
ifdef
DEBUG
removed
=
true
;
#
endif
}
}
#
ifdef
DEBUG
if
(
!
removed
)
{
HTMLFormElement
*
form
=
node
-
>
GetForm
(
)
;
NS_ASSERTION
(
form
=
=
aThisForm
"
How
did
that
happen
?
"
)
;
}
#
endif
}
}
void
HTMLFormElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
RefPtr
<
Document
>
oldDocument
=
GetUncomposedDoc
(
)
;
MarkOrphans
(
mControls
-
>
mElements
)
;
MarkOrphans
(
mControls
-
>
mNotInElements
)
;
MarkOrphans
(
mImageElements
)
;
nsGenericHTMLElement
:
:
UnbindFromTree
(
aNullParent
)
;
nsINode
*
ancestor
=
this
;
nsINode
*
cur
;
do
{
cur
=
ancestor
-
>
GetParentNode
(
)
;
if
(
!
cur
)
{
break
;
}
ancestor
=
cur
;
}
while
(
1
)
;
CollectOrphans
(
ancestor
mControls
-
>
mElements
#
ifdef
DEBUG
this
#
endif
)
;
CollectOrphans
(
ancestor
mControls
-
>
mNotInElements
#
ifdef
DEBUG
this
#
endif
)
;
CollectOrphans
(
ancestor
mImageElements
#
ifdef
DEBUG
this
#
endif
)
;
if
(
oldDocument
&
&
oldDocument
-
>
IsHTMLOrXHTML
(
)
)
{
oldDocument
-
>
AsHTMLDocument
(
)
-
>
RemovedForm
(
)
;
}
ForgetCurrentSubmission
(
)
;
}
void
HTMLFormElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mWantsWillHandleEvent
=
true
;
if
(
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
static_cast
<
nsIContent
*
>
(
this
)
)
{
uint32_t
msg
=
aVisitor
.
mEvent
-
>
mMessage
;
if
(
msg
=
=
eFormSubmit
)
{
if
(
mGeneratingSubmit
)
{
aVisitor
.
mCanHandle
=
false
;
return
;
}
mGeneratingSubmit
=
true
;
mDeferSubmission
=
true
;
}
else
if
(
msg
=
=
eFormReset
)
{
if
(
mGeneratingReset
)
{
aVisitor
.
mCanHandle
=
false
;
return
;
}
mGeneratingReset
=
true
;
}
}
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
void
HTMLFormElement
:
:
WillHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eFormSubmit
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eFormReset
)
&
&
aVisitor
.
mEvent
-
>
mFlags
.
mInBubblingPhase
&
&
aVisitor
.
mEvent
-
>
mOriginalTarget
!
=
static_cast
<
nsIContent
*
>
(
this
)
)
{
aVisitor
.
mEvent
-
>
StopPropagation
(
)
;
}
}
nsresult
HTMLFormElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
static_cast
<
nsIContent
*
>
(
this
)
)
{
EventMessage
msg
=
aVisitor
.
mEvent
-
>
mMessage
;
if
(
msg
=
=
eFormSubmit
)
{
mDeferSubmission
=
false
;
}
if
(
aVisitor
.
mEventStatus
=
=
nsEventStatus_eIgnore
)
{
switch
(
msg
)
{
case
eFormReset
:
case
eFormSubmit
:
{
if
(
mPendingSubmission
&
&
msg
=
=
eFormSubmit
)
{
mPendingSubmission
=
nullptr
;
}
DoSubmitOrReset
(
aVisitor
.
mEvent
msg
)
;
break
;
}
default
:
break
;
}
}
else
{
if
(
msg
=
=
eFormSubmit
)
{
FlushPendingSubmission
(
)
;
}
}
if
(
msg
=
=
eFormSubmit
)
{
mGeneratingSubmit
=
false
;
}
else
if
(
msg
=
=
eFormReset
)
{
mGeneratingReset
=
false
;
}
}
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
DoSubmitOrReset
(
WidgetEvent
*
aEvent
EventMessage
aMessage
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
}
if
(
eFormReset
=
=
aMessage
)
{
return
DoReset
(
)
;
}
if
(
eFormSubmit
=
=
aMessage
)
{
if
(
mIsConstructingEntryList
|
|
!
doc
|
|
(
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_FORMS
)
)
{
return
NS_OK
;
}
return
DoSubmit
(
aEvent
)
;
}
MOZ_ASSERT
(
false
)
;
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
DoReset
(
)
{
mEverTriedInvalidSubmit
=
false
;
uint32_t
numElements
=
GetElementCount
(
)
;
for
(
uint32_t
elementX
=
0
;
elementX
<
numElements
;
+
+
elementX
)
{
nsCOMPtr
<
nsIFormControl
>
controlNode
=
GetElementAt
(
elementX
)
;
if
(
controlNode
)
{
controlNode
-
>
Reset
(
)
;
}
}
return
NS_OK
;
}
#
define
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
\
if
(
NS_FAILED
(
rv
)
)
{
\
ForgetCurrentSubmission
(
)
;
\
return
rv
;
\
}
nsresult
HTMLFormElement
:
:
DoSubmit
(
WidgetEvent
*
aEvent
)
{
NS_ASSERTION
(
GetComposedDoc
(
)
"
Should
never
get
here
without
a
current
doc
"
)
;
if
(
mIsSubmitting
)
{
NS_WARNING
(
"
Preventing
double
form
submission
"
)
;
return
NS_OK
;
}
mIsSubmitting
=
true
;
NS_ASSERTION
(
!
mWebProgress
&
&
!
mSubmittingRequest
"
Web
progress
/
submitting
request
should
not
exist
here
!
"
)
;
nsAutoPtr
<
HTMLFormSubmission
>
submission
;
nsresult
rv
=
BuildSubmission
(
getter_Transfers
(
submission
)
aEvent
)
;
if
(
StaticPrefs
:
:
dom_formdata_event_enabled
(
)
&
&
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
mIsSubmitting
=
false
;
return
NS_OK
;
}
if
(
NS_FAILED
(
rv
)
)
{
mIsSubmitting
=
false
;
return
rv
;
}
nsPIDOMWindowOuter
*
window
=
OwnerDoc
(
)
-
>
GetWindow
(
)
;
if
(
window
)
{
mSubmitPopupState
=
PopupBlocker
:
:
GetPopupControlState
(
)
;
}
else
{
mSubmitPopupState
=
PopupBlocker
:
:
openAbused
;
}
if
(
mDeferSubmission
)
{
mPendingSubmission
=
submission
;
mIsSubmitting
=
false
;
return
NS_OK
;
}
return
SubmitSubmission
(
submission
)
;
}
nsresult
HTMLFormElement
:
:
BuildSubmission
(
HTMLFormSubmission
*
*
aFormSubmission
WidgetEvent
*
aEvent
)
{
NS_ASSERTION
(
!
mPendingSubmission
"
tried
to
build
two
submissions
!
"
)
;
nsGenericHTMLElement
*
originatingElement
=
nullptr
;
if
(
aEvent
)
{
InternalFormEvent
*
formEvent
=
aEvent
-
>
AsFormEvent
(
)
;
if
(
formEvent
)
{
nsIContent
*
originator
=
formEvent
-
>
mOriginator
;
if
(
originator
)
{
if
(
!
originator
-
>
IsHTMLElement
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
originatingElement
=
static_cast
<
nsGenericHTMLElement
*
>
(
originator
)
;
}
}
}
nsresult
rv
;
auto
encoding
=
GetSubmitEncoding
(
)
-
>
OutputEncoding
(
)
;
RefPtr
<
FormData
>
formData
=
new
FormData
(
GetOwnerGlobal
(
)
encoding
originatingElement
)
;
rv
=
ConstructEntryList
(
formData
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
if
(
StaticPrefs
:
:
dom_formdata_event_enabled
(
)
&
&
!
GetComposedDoc
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
rv
=
HTMLFormSubmission
:
:
GetFromForm
(
this
originatingElement
encoding
aFormSubmission
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
rv
=
formData
-
>
CopySubmissionDataTo
(
*
aFormSubmission
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
SubmitSubmission
(
HTMLFormSubmission
*
aFormSubmission
)
{
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
actionURI
=
aFormSubmission
-
>
GetActionURL
(
)
;
if
(
!
actionURI
)
{
mIsSubmitting
=
false
;
return
NS_OK
;
}
Document
*
doc
=
GetComposedDoc
(
)
;
nsCOMPtr
<
nsIDocShell
>
container
=
doc
?
doc
-
>
GetDocShell
(
)
:
nullptr
;
if
(
!
container
|
|
IsEditable
(
)
)
{
mIsSubmitting
=
false
;
return
NS_OK
;
}
bool
schemeIsJavaScript
=
actionURI
-
>
SchemeIs
(
"
javascript
"
)
;
if
(
schemeIsJavaScript
)
{
mIsSubmitting
=
false
;
}
bool
cancelSubmit
=
false
;
if
(
mNotifiedObservers
)
{
cancelSubmit
=
mNotifiedObserversResult
;
}
else
{
rv
=
NotifySubmitObservers
(
actionURI
&
cancelSubmit
true
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
}
if
(
cancelSubmit
)
{
mIsSubmitting
=
false
;
return
NS_OK
;
}
cancelSubmit
=
false
;
rv
=
NotifySubmitObservers
(
actionURI
&
cancelSubmit
false
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
if
(
cancelSubmit
)
{
mIsSubmitting
=
false
;
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
;
{
AutoPopupStatePusher
popupStatePusher
(
mSubmitPopupState
)
;
AutoHandlingUserInputStatePusher
userInpStatePusher
(
aFormSubmission
-
>
IsInitiatedFromUserInput
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
postDataStream
;
rv
=
aFormSubmission
-
>
GetEncodedSubmission
(
actionURI
getter_AddRefs
(
postDataStream
)
actionURI
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
nsAutoString
target
;
aFormSubmission
-
>
GetTarget
(
target
)
;
rv
=
nsDocShell
:
:
Cast
(
container
)
-
>
OnLinkClickSync
(
this
actionURI
target
VoidString
(
)
postDataStream
nullptr
false
getter_AddRefs
(
docShell
)
getter_AddRefs
(
mSubmittingRequest
)
aFormSubmission
-
>
IsInitiatedFromUserInput
(
)
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
}
if
(
docShell
)
{
bool
pending
=
false
;
mSubmittingRequest
-
>
IsPending
(
&
pending
)
;
if
(
pending
&
&
!
schemeIsJavaScript
)
{
nsCOMPtr
<
nsIWebProgress
>
webProgress
=
do_GetInterface
(
docShell
)
;
NS_ASSERTION
(
webProgress
"
nsIDocShell
not
converted
to
nsIWebProgress
!
"
)
;
rv
=
webProgress
-
>
AddProgressListener
(
this
nsIWebProgress
:
:
NOTIFY_STATE_ALL
)
;
NS_ENSURE_SUBMIT_SUCCESS
(
rv
)
;
mWebProgress
=
do_GetWeakReference
(
webProgress
)
;
NS_ASSERTION
(
mWebProgress
"
can
'
t
hold
weak
ref
to
webprogress
!
"
)
;
}
else
{
ForgetCurrentSubmission
(
)
;
}
}
else
{
ForgetCurrentSubmission
(
)
;
}
return
rv
;
}
nsresult
HTMLFormElement
:
:
DoSecureToInsecureSubmitCheck
(
nsIURI
*
aActionURL
bool
*
aCancelSubmit
)
{
*
aCancelSubmit
=
false
;
Document
*
parent
=
OwnerDoc
(
)
-
>
GetInProcessParentDocument
(
)
;
bool
isRootDocument
=
(
!
parent
|
|
nsContentUtils
:
:
IsChromeDoc
(
parent
)
)
;
if
(
!
isRootDocument
)
{
return
NS_OK
;
}
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
if
(
!
principal
)
{
*
aCancelSubmit
=
true
;
return
NS_OK
;
}
bool
formIsHTTPS
=
principal
-
>
SchemeIs
(
"
https
"
)
;
if
(
principal
-
>
IsSystemPrincipal
(
)
|
|
principal
-
>
GetIsExpandedPrincipal
(
)
)
{
formIsHTTPS
=
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
-
>
SchemeIs
(
"
https
"
)
;
}
if
(
!
formIsHTTPS
)
{
return
NS_OK
;
}
if
(
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyLoopbackURL
(
aActionURL
)
)
{
return
NS_OK
;
}
if
(
nsMixedContentBlocker
:
:
URISafeToBeLoadedInSecureContext
(
aActionURL
)
)
{
return
NS_OK
;
}
if
(
nsMixedContentBlocker
:
:
IsPotentiallyTrustworthyOnion
(
aActionURL
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
OwnerDoc
(
)
-
>
GetWindow
(
)
;
if
(
!
window
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPrompt
>
prompt
=
do_GetInterface
(
docShell
)
;
if
(
!
prompt
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIStringBundle
>
stringBundle
;
nsCOMPtr
<
nsIStringBundleService
>
stringBundleService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
if
(
!
stringBundleService
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
stringBundleService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
browser
.
properties
"
getter_AddRefs
(
stringBundle
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsAutoString
title
;
nsAutoString
message
;
nsAutoString
cont
;
stringBundle
-
>
GetStringFromName
(
"
formPostSecureToInsecureWarning
.
title
"
title
)
;
stringBundle
-
>
GetStringFromName
(
"
formPostSecureToInsecureWarning
.
message
"
message
)
;
stringBundle
-
>
GetStringFromName
(
"
formPostSecureToInsecureWarning
.
continue
"
cont
)
;
int32_t
buttonPressed
;
bool
checkState
=
false
;
rv
=
prompt
-
>
ConfirmEx
(
title
.
get
(
)
message
.
get
(
)
(
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
*
nsIPrompt
:
:
BUTTON_POS_0
)
+
(
nsIPrompt
:
:
BUTTON_TITLE_CANCEL
*
nsIPrompt
:
:
BUTTON_POS_1
)
cont
.
get
(
)
nullptr
nullptr
nullptr
&
checkState
&
buttonPressed
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aCancelSubmit
=
(
buttonPressed
=
=
1
)
;
uint32_t
telemetryBucket
=
nsISecurityUITelemetry
:
:
WARNING_CONFIRM_POST_TO_INSECURE_FROM_SECURE
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SECURITY_UI
telemetryBucket
)
;
if
(
!
*
aCancelSubmit
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SECURITY_UI
telemetryBucket
+
1
)
;
}
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
NotifySubmitObservers
(
nsIURI
*
aActionURL
bool
*
aCancelSubmit
bool
aEarlyNotify
)
{
if
(
!
aEarlyNotify
)
{
nsresult
rv
=
DoSecureToInsecureSubmitCheck
(
aActionURL
aCancelSubmit
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
*
aCancelSubmit
)
{
return
NS_OK
;
}
}
bool
defaultAction
=
true
;
nsresult
rv
=
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
OwnerDoc
(
)
static_cast
<
nsINode
*
>
(
this
)
aEarlyNotify
?
NS_LITERAL_STRING
(
"
DOMFormBeforeSubmit
"
)
:
NS_LITERAL_STRING
(
"
DOMFormSubmit
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
&
defaultAction
)
;
*
aCancelSubmit
=
!
defaultAction
;
if
(
*
aCancelSubmit
)
{
return
NS_OK
;
}
return
rv
;
}
nsresult
HTMLFormElement
:
:
ConstructEntryList
(
FormData
*
aFormData
)
{
MOZ_ASSERT
(
aFormData
"
Must
have
FormData
!
"
)
;
bool
isFormDataEventEnabled
=
StaticPrefs
:
:
dom_formdata_event_enabled
(
)
;
if
(
isFormDataEventEnabled
&
&
mIsConstructingEntryList
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
AutoRestore
<
bool
>
resetConstructingEntryList
(
mIsConstructingEntryList
)
;
mIsConstructingEntryList
=
true
;
AutoTArray
<
RefPtr
<
nsGenericHTMLFormElement
>
100
>
sortedControls
;
nsresult
rv
=
mControls
-
>
GetSortedControls
(
sortedControls
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
len
=
sortedControls
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
sortedControls
[
i
]
-
>
SubmitNamesValues
(
aFormData
)
;
}
if
(
isFormDataEventEnabled
)
{
FormDataEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
false
;
init
.
mFormData
=
aFormData
;
RefPtr
<
FormDataEvent
>
event
=
FormDataEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
formdata
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
EventDispatcher
:
:
DispatchDOMEvent
(
ToSupports
(
this
)
nullptr
event
nullptr
nullptr
)
;
}
return
NS_OK
;
}
NotNull
<
const
Encoding
*
>
HTMLFormElement
:
:
GetSubmitEncoding
(
)
{
nsAutoString
acceptCharsetValue
;
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
acceptcharset
acceptCharsetValue
)
;
int32_t
charsetLen
=
acceptCharsetValue
.
Length
(
)
;
if
(
charsetLen
>
0
)
{
int32_t
offset
=
0
;
int32_t
spPos
=
0
;
do
{
spPos
=
acceptCharsetValue
.
FindChar
(
char16_t
(
'
'
)
offset
)
;
int32_t
cnt
=
(
(
-
1
=
=
spPos
)
?
(
charsetLen
-
offset
)
:
(
spPos
-
offset
)
)
;
if
(
cnt
>
0
)
{
nsAutoString
uCharset
;
acceptCharsetValue
.
Mid
(
uCharset
offset
cnt
)
;
auto
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
uCharset
)
;
if
(
encoding
)
{
return
WrapNotNull
(
encoding
)
;
}
}
offset
=
spPos
+
1
;
}
while
(
spPos
!
=
-
1
)
;
}
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
doc
)
{
return
doc
-
>
GetDocumentCharacterSet
(
)
;
}
return
UTF_8_ENCODING
;
}
NS_IMETHODIMP_
(
uint32_t
)
HTMLFormElement
:
:
GetElementCount
(
)
const
{
return
mControls
-
>
Length
(
)
;
}
Element
*
HTMLFormElement
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
{
Element
*
element
=
mControls
-
>
mElements
.
SafeElementAt
(
aIndex
nullptr
)
;
aFound
=
element
!
=
nullptr
;
return
element
;
}
NS_IMETHODIMP_
(
nsIFormControl
*
)
HTMLFormElement
:
:
GetElementAt
(
int32_t
aIndex
)
const
{
return
mControls
-
>
mElements
.
SafeElementAt
(
aIndex
nullptr
)
;
}
int32_t
HTMLFormElement
:
:
CompareFormControlPosition
(
Element
*
aElement1
Element
*
aElement2
const
nsIContent
*
aForm
)
{
NS_ASSERTION
(
aElement1
!
=
aElement2
"
Comparing
a
form
control
to
itself
"
)
;
NS_ASSERTION
(
(
aElement1
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
|
|
aElement1
-
>
GetParent
(
)
)
&
&
(
aElement2
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
|
|
aElement2
-
>
GetParent
(
)
)
"
Form
controls
should
always
have
parents
"
)
;
#
ifdef
DEBUG
nsLayoutUtils
:
:
gPreventAssertInCompareTreePosition
=
true
;
int32_t
rVal
=
nsLayoutUtils
:
:
CompareTreePosition
(
aElement1
aElement2
aForm
)
;
nsLayoutUtils
:
:
gPreventAssertInCompareTreePosition
=
false
;
return
rVal
;
#
else
return
nsLayoutUtils
:
:
CompareTreePosition
(
aElement1
aElement2
aForm
)
;
#
endif
}
#
ifdef
DEBUG
void
HTMLFormElement
:
:
AssertDocumentOrder
(
const
nsTArray
<
nsGenericHTMLFormElement
*
>
&
aControls
nsIContent
*
aForm
)
{
return
;
if
(
!
aControls
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
aControls
.
Length
(
)
-
1
;
+
+
i
)
{
NS_ASSERTION
(
CompareFormControlPosition
(
aControls
[
i
]
aControls
[
i
+
1
]
aForm
)
<
0
"
Form
controls
not
ordered
correctly
"
)
;
}
}
}
void
HTMLFormElement
:
:
AssertDocumentOrder
(
const
nsTArray
<
RefPtr
<
nsGenericHTMLFormElement
>
>
&
aControls
nsIContent
*
aForm
)
{
return
;
if
(
!
aControls
.
IsEmpty
(
)
)
{
for
(
uint32_t
i
=
0
;
i
<
aControls
.
Length
(
)
-
1
;
+
+
i
)
{
NS_ASSERTION
(
CompareFormControlPosition
(
aControls
[
i
]
aControls
[
i
+
1
]
aForm
)
<
0
"
Form
controls
not
ordered
correctly
"
)
;
}
}
}
#
endif
void
HTMLFormElement
:
:
PostPasswordEvent
(
)
{
if
(
mFormPasswordEventDispatcher
.
get
(
)
)
{
return
;
}
mFormPasswordEventDispatcher
=
new
AsyncEventDispatcher
(
this
NS_LITERAL_STRING
(
"
DOMFormHasPassword
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
;
mFormPasswordEventDispatcher
-
>
PostDOMEvent
(
)
;
}
namespace
{
struct
FormComparator
{
Element
*
const
mChild
;
HTMLFormElement
*
const
mForm
;
FormComparator
(
Element
*
aChild
HTMLFormElement
*
aForm
)
:
mChild
(
aChild
)
mForm
(
aForm
)
{
}
int
operator
(
)
(
Element
*
aElement
)
const
{
return
HTMLFormElement
:
:
CompareFormControlPosition
(
mChild
aElement
mForm
)
;
}
}
;
}
template
<
typename
ElementType
>
static
bool
AddElementToList
(
nsTArray
<
ElementType
*
>
&
aList
ElementType
*
aChild
HTMLFormElement
*
aForm
)
{
NS_ASSERTION
(
aList
.
IndexOf
(
aChild
)
=
=
aList
.
NoIndex
"
aChild
already
in
aList
"
)
;
const
uint32_t
count
=
aList
.
Length
(
)
;
ElementType
*
element
;
bool
lastElement
=
false
;
int32_t
position
=
-
1
;
if
(
count
>
0
)
{
element
=
aList
[
count
-
1
]
;
position
=
HTMLFormElement
:
:
CompareFormControlPosition
(
aChild
element
aForm
)
;
}
if
(
position
>
=
0
|
|
count
=
=
0
)
{
aList
.
AppendElement
(
aChild
)
;
lastElement
=
true
;
}
else
{
size_t
idx
;
BinarySearchIf
(
aList
0
count
FormComparator
(
aChild
aForm
)
&
idx
)
;
aList
.
InsertElementAt
(
idx
aChild
)
;
}
return
lastElement
;
}
nsresult
HTMLFormElement
:
:
AddElement
(
nsGenericHTMLFormElement
*
aChild
bool
aUpdateValidity
bool
aNotify
)
{
NS_ASSERTION
(
aChild
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
|
|
aChild
-
>
GetParent
(
)
"
Form
control
should
have
a
parent
"
)
;
bool
childInElements
=
HTMLFormControlsCollection
:
:
ShouldBeInElements
(
aChild
)
;
nsTArray
<
nsGenericHTMLFormElement
*
>
&
controlList
=
childInElements
?
mControls
-
>
mElements
:
mControls
-
>
mNotInElements
;
bool
lastElement
=
AddElementToList
(
controlList
aChild
this
)
;
#
ifdef
DEBUG
AssertDocumentOrder
(
controlList
this
)
;
#
endif
int32_t
type
=
aChild
-
>
ControlType
(
)
;
if
(
type
=
=
NS_FORM_INPUT_PASSWORD
)
{
PostPasswordEvent
(
)
;
}
if
(
aChild
-
>
IsSubmitControl
(
)
)
{
nsGenericHTMLFormElement
*
*
firstSubmitSlot
=
childInElements
?
&
mFirstSubmitInElements
:
&
mFirstSubmitNotInElements
;
nsGenericHTMLFormElement
*
oldDefaultSubmit
=
mDefaultSubmitElement
;
if
(
!
*
firstSubmitSlot
|
|
(
!
lastElement
&
&
CompareFormControlPosition
(
aChild
*
firstSubmitSlot
this
)
<
0
)
)
{
if
(
(
mDefaultSubmitElement
|
|
(
!
mFirstSubmitInElements
&
&
!
mFirstSubmitNotInElements
)
)
&
&
(
*
firstSubmitSlot
=
=
mDefaultSubmitElement
|
|
CompareFormControlPosition
(
aChild
mDefaultSubmitElement
this
)
<
0
)
)
{
mDefaultSubmitElement
=
aChild
;
}
*
firstSubmitSlot
=
aChild
;
}
MOZ_ASSERT
(
mDefaultSubmitElement
=
=
mFirstSubmitInElements
|
|
mDefaultSubmitElement
=
=
mFirstSubmitNotInElements
|
|
!
mDefaultSubmitElement
"
What
happened
here
?
"
)
;
if
(
oldDefaultSubmit
&
&
oldDefaultSubmit
!
=
mDefaultSubmitElement
)
{
oldDefaultSubmit
-
>
UpdateState
(
aNotify
)
;
}
}
if
(
aUpdateValidity
)
{
nsCOMPtr
<
nsIConstraintValidation
>
cvElmt
=
do_QueryObject
(
aChild
)
;
if
(
cvElmt
&
&
cvElmt
-
>
IsCandidateForConstraintValidation
(
)
&
&
!
cvElmt
-
>
IsValid
(
)
)
{
UpdateValidity
(
false
)
;
}
}
if
(
type
=
=
NS_FORM_INPUT_RADIO
)
{
RefPtr
<
HTMLInputElement
>
radio
=
static_cast
<
HTMLInputElement
*
>
(
aChild
)
;
radio
-
>
AddedToRadioGroup
(
)
;
}
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
AddElementToTable
(
nsGenericHTMLFormElement
*
aChild
const
nsAString
&
aName
)
{
return
mControls
-
>
AddElementToTable
(
aChild
aName
)
;
}
nsresult
HTMLFormElement
:
:
RemoveElement
(
nsGenericHTMLFormElement
*
aChild
bool
aUpdateValidity
)
{
RemoveElementFromPastNamesMap
(
aChild
)
;
nsresult
rv
=
NS_OK
;
if
(
aChild
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RADIO
)
{
RefPtr
<
HTMLInputElement
>
radio
=
static_cast
<
HTMLInputElement
*
>
(
aChild
)
;
radio
-
>
WillRemoveFromRadioGroup
(
)
;
}
bool
childInElements
=
HTMLFormControlsCollection
:
:
ShouldBeInElements
(
aChild
)
;
nsTArray
<
nsGenericHTMLFormElement
*
>
&
controls
=
childInElements
?
mControls
-
>
mElements
:
mControls
-
>
mNotInElements
;
size_t
index
=
controls
.
IndexOf
(
aChild
)
;
NS_ENSURE_STATE
(
index
!
=
controls
.
NoIndex
)
;
controls
.
RemoveElementAt
(
index
)
;
nsGenericHTMLFormElement
*
*
firstSubmitSlot
=
childInElements
?
&
mFirstSubmitInElements
:
&
mFirstSubmitNotInElements
;
if
(
aChild
=
=
*
firstSubmitSlot
)
{
*
firstSubmitSlot
=
nullptr
;
uint32_t
length
=
controls
.
Length
(
)
;
for
(
uint32_t
i
=
index
;
i
<
length
;
+
+
i
)
{
nsGenericHTMLFormElement
*
currentControl
=
controls
[
i
]
;
if
(
currentControl
-
>
IsSubmitControl
(
)
)
{
*
firstSubmitSlot
=
currentControl
;
break
;
}
}
}
if
(
aChild
=
=
mDefaultSubmitElement
)
{
mDefaultSubmitElement
=
nullptr
;
nsContentUtils
:
:
AddScriptRunner
(
new
RemoveElementRunnable
(
this
)
)
;
}
if
(
aUpdateValidity
)
{
nsCOMPtr
<
nsIConstraintValidation
>
cvElmt
=
do_QueryObject
(
aChild
)
;
if
(
cvElmt
&
&
cvElmt
-
>
IsCandidateForConstraintValidation
(
)
&
&
!
cvElmt
-
>
IsValid
(
)
)
{
UpdateValidity
(
true
)
;
}
}
return
rv
;
}
void
HTMLFormElement
:
:
HandleDefaultSubmitRemoval
(
)
{
if
(
mDefaultSubmitElement
)
{
return
;
}
if
(
!
mFirstSubmitNotInElements
)
{
mDefaultSubmitElement
=
mFirstSubmitInElements
;
}
else
if
(
!
mFirstSubmitInElements
)
{
mDefaultSubmitElement
=
mFirstSubmitNotInElements
;
}
else
{
NS_ASSERTION
(
mFirstSubmitInElements
!
=
mFirstSubmitNotInElements
"
How
did
that
happen
?
"
)
;
mDefaultSubmitElement
=
CompareFormControlPosition
(
mFirstSubmitInElements
mFirstSubmitNotInElements
this
)
<
0
?
mFirstSubmitInElements
:
mFirstSubmitNotInElements
;
}
MOZ_ASSERT
(
mDefaultSubmitElement
=
=
mFirstSubmitInElements
|
|
mDefaultSubmitElement
=
=
mFirstSubmitNotInElements
"
What
happened
here
?
"
)
;
if
(
mDefaultSubmitElement
)
{
mDefaultSubmitElement
-
>
UpdateState
(
true
)
;
}
}
nsresult
HTMLFormElement
:
:
RemoveElementFromTableInternal
(
nsInterfaceHashtable
<
nsStringHashKey
nsISupports
>
&
aTable
nsIContent
*
aChild
const
nsAString
&
aName
)
{
auto
entry
=
aTable
.
Lookup
(
aName
)
;
if
(
!
entry
)
{
return
NS_OK
;
}
if
(
entry
.
Data
(
)
=
=
aChild
)
{
entry
.
Remove
(
)
;
+
+
mExpandoAndGeneration
.
generation
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
entry
.
Data
(
)
)
)
;
if
(
content
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
nsCOMPtr
<
RadioNodeList
>
(
do_QueryInterface
(
entry
.
Data
(
)
)
)
)
;
auto
*
list
=
static_cast
<
RadioNodeList
*
>
(
entry
.
Data
(
)
.
get
(
)
)
;
list
-
>
RemoveElement
(
aChild
)
;
uint32_t
length
=
list
-
>
Length
(
)
;
if
(
!
length
)
{
entry
.
Remove
(
)
;
+
+
mExpandoAndGeneration
.
generation
;
}
else
if
(
length
=
=
1
)
{
nsIContent
*
node
=
list
-
>
Item
(
0
)
;
if
(
node
)
{
entry
.
Data
(
)
=
node
;
}
}
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
RemoveElementFromTable
(
nsGenericHTMLFormElement
*
aElement
const
nsAString
&
aName
)
{
return
mControls
-
>
RemoveElementFromTable
(
aElement
aName
)
;
}
already_AddRefed
<
nsISupports
>
HTMLFormElement
:
:
NamedGetter
(
const
nsAString
&
aName
bool
&
aFound
)
{
aFound
=
true
;
nsCOMPtr
<
nsISupports
>
result
=
DoResolveName
(
aName
true
)
;
if
(
result
)
{
AddToPastNamesMap
(
aName
result
)
;
return
result
.
forget
(
)
;
}
result
=
mImageNameLookupTable
.
GetWeak
(
aName
)
;
if
(
result
)
{
AddToPastNamesMap
(
aName
result
)
;
return
result
.
forget
(
)
;
}
result
=
mPastNameLookupTable
.
GetWeak
(
aName
)
;
if
(
result
)
{
return
result
.
forget
(
)
;
}
aFound
=
false
;
return
nullptr
;
}
void
HTMLFormElement
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aRetval
)
{
}
already_AddRefed
<
nsISupports
>
HTMLFormElement
:
:
FindNamedItem
(
const
nsAString
&
aName
nsWrapperCache
*
*
aCache
)
{
bool
found
;
nsCOMPtr
<
nsISupports
>
result
=
NamedGetter
(
aName
found
)
;
if
(
result
)
{
*
aCache
=
nullptr
;
return
result
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsISupports
>
HTMLFormElement
:
:
DoResolveName
(
const
nsAString
&
aName
bool
aFlushContent
)
{
nsCOMPtr
<
nsISupports
>
result
=
mControls
-
>
NamedItemInternal
(
aName
aFlushContent
)
;
return
result
.
forget
(
)
;
}
void
HTMLFormElement
:
:
OnSubmitClickBegin
(
Element
*
aOriginatingElement
)
{
mDeferSubmission
=
true
;
nsCOMPtr
<
nsIURI
>
actionURI
;
nsresult
rv
;
rv
=
GetActionURL
(
getter_AddRefs
(
actionURI
)
aOriginatingElement
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
actionURI
)
return
;
if
(
mInvalidElementsCount
=
=
0
)
{
bool
cancelSubmit
=
false
;
rv
=
NotifySubmitObservers
(
actionURI
&
cancelSubmit
true
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mNotifiedObservers
=
true
;
mNotifiedObserversResult
=
cancelSubmit
;
}
}
}
void
HTMLFormElement
:
:
OnSubmitClickEnd
(
)
{
mDeferSubmission
=
false
;
}
void
HTMLFormElement
:
:
FlushPendingSubmission
(
)
{
if
(
mPendingSubmission
)
{
nsAutoPtr
<
HTMLFormSubmission
>
submission
=
std
:
:
move
(
mPendingSubmission
)
;
SubmitSubmission
(
submission
)
;
}
}
void
HTMLFormElement
:
:
GetAction
(
nsString
&
aValue
)
{
if
(
!
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
action
aValue
)
|
|
aValue
.
IsEmpty
(
)
)
{
Document
*
document
=
OwnerDoc
(
)
;
nsIURI
*
docURI
=
document
-
>
GetDocumentURI
(
)
;
if
(
docURI
)
{
nsAutoCString
spec
;
nsresult
rv
=
docURI
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
CopyUTF8toUTF16
(
spec
aValue
)
;
}
}
else
{
GetURIAttr
(
nsGkAtoms
:
:
action
nullptr
aValue
)
;
}
}
nsresult
HTMLFormElement
:
:
GetActionURL
(
nsIURI
*
*
aActionURL
Element
*
aOriginatingElement
)
{
nsresult
rv
=
NS_OK
;
*
aActionURL
=
nullptr
;
nsAutoString
action
;
if
(
aOriginatingElement
&
&
aOriginatingElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
formaction
)
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
aOriginatingElement
)
;
NS_ASSERTION
(
formControl
&
&
formControl
-
>
IsSubmitControl
(
)
"
The
originating
element
must
be
a
submit
form
control
!
"
)
;
#
endif
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNode
(
aOriginatingElement
)
;
if
(
inputElement
)
{
inputElement
-
>
GetFormAction
(
action
)
;
}
else
{
auto
buttonElement
=
HTMLButtonElement
:
:
FromNode
(
aOriginatingElement
)
;
if
(
buttonElement
)
{
buttonElement
-
>
GetFormAction
(
action
)
;
}
else
{
NS_ERROR
(
"
Originating
element
must
be
an
input
or
button
element
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
}
else
{
GetAction
(
action
)
;
}
if
(
!
IsInComposedDoc
(
)
)
{
return
NS_OK
;
}
Document
*
document
=
OwnerDoc
(
)
;
nsIURI
*
docURI
=
document
-
>
GetDocumentURI
(
)
;
NS_ENSURE_TRUE
(
docURI
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIURI
>
actionURL
;
if
(
action
.
IsEmpty
(
)
)
{
if
(
!
document
-
>
IsHTMLOrXHTML
(
)
)
{
return
NS_OK
;
}
actionURL
=
docURI
;
}
else
{
nsIURI
*
baseURL
=
GetBaseURI
(
)
;
NS_ASSERTION
(
baseURL
"
No
Base
URL
found
in
Form
Submit
!
\
n
"
)
;
if
(
!
baseURL
)
{
return
NS_OK
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
actionURL
)
action
nullptr
baseURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsIScriptSecurityManager
*
securityManager
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
rv
=
securityManager
-
>
CheckLoadURIWithPrincipal
(
NodePrincipal
(
)
actionURL
nsIScriptSecurityManager
:
:
STANDARD
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isHttpScheme
=
actionURL
-
>
SchemeIs
(
"
http
"
)
;
if
(
isHttpScheme
&
&
document
-
>
GetUpgradeInsecureRequests
(
false
)
)
{
AutoTArray
<
nsString
2
>
params
;
nsAutoCString
spec
;
rv
=
actionURL
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
spec
*
params
.
AppendElement
(
)
)
;
nsCOMPtr
<
nsIURI
>
upgradedActionURL
;
rv
=
NS_GetSecureUpgradedURI
(
actionURL
getter_AddRefs
(
upgradedActionURL
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
actionURL
=
upgradedActionURL
.
forget
(
)
;
nsAutoCString
scheme
;
rv
=
actionURL
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
scheme
*
params
.
AppendElement
(
)
)
;
CSP_LogLocalizedStr
(
"
upgradeInsecureRequest
"
params
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
upgradeInsecureRequest
"
)
document
-
>
InnerWindowID
(
)
!
!
document
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
)
;
}
actionURL
.
forget
(
aActionURL
)
;
return
rv
;
}
NS_IMETHODIMP_
(
nsIFormControl
*
)
HTMLFormElement
:
:
GetDefaultSubmitElement
(
)
const
{
MOZ_ASSERT
(
mDefaultSubmitElement
=
=
mFirstSubmitInElements
|
|
mDefaultSubmitElement
=
=
mFirstSubmitNotInElements
"
What
happened
here
?
"
)
;
return
mDefaultSubmitElement
;
}
bool
HTMLFormElement
:
:
IsDefaultSubmitElement
(
const
nsIFormControl
*
aControl
)
const
{
MOZ_ASSERT
(
aControl
"
Unexpected
call
"
)
;
if
(
aControl
=
=
mDefaultSubmitElement
)
{
return
true
;
}
if
(
mDefaultSubmitElement
|
|
(
aControl
!
=
mFirstSubmitInElements
&
&
aControl
!
=
mFirstSubmitNotInElements
)
)
{
return
false
;
}
if
(
!
mFirstSubmitInElements
|
|
!
mFirstSubmitNotInElements
)
{
return
true
;
}
nsIFormControl
*
defaultSubmit
=
CompareFormControlPosition
(
mFirstSubmitInElements
mFirstSubmitNotInElements
this
)
<
0
?
mFirstSubmitInElements
:
mFirstSubmitNotInElements
;
return
aControl
=
=
defaultSubmit
;
}
bool
HTMLFormElement
:
:
ImplicitSubmissionIsDisabled
(
)
const
{
uint32_t
numDisablingControlsFound
=
0
;
uint32_t
length
=
mControls
-
>
mElements
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
&
&
numDisablingControlsFound
<
2
;
+
+
i
)
{
if
(
mControls
-
>
mElements
[
i
]
-
>
IsSingleLineTextOrNumberControl
(
false
)
)
{
numDisablingControlsFound
+
+
;
}
}
return
numDisablingControlsFound
!
=
1
;
}
bool
HTMLFormElement
:
:
IsLastActiveElement
(
const
nsIFormControl
*
aControl
)
const
{
MOZ_ASSERT
(
aControl
"
Unexpected
call
"
)
;
for
(
auto
*
element
:
Reversed
(
mControls
-
>
mElements
)
)
{
if
(
element
-
>
IsTextOrNumberControl
(
false
)
&
&
!
element
-
>
IsDisabled
(
)
)
{
return
element
=
=
aControl
;
}
}
return
false
;
}
int32_t
HTMLFormElement
:
:
Length
(
)
{
return
mControls
-
>
Length
(
)
;
}
void
HTMLFormElement
:
:
ForgetCurrentSubmission
(
)
{
mNotifiedObservers
=
false
;
mIsSubmitting
=
false
;
mSubmittingRequest
=
nullptr
;
nsCOMPtr
<
nsIWebProgress
>
webProgress
=
do_QueryReferent
(
mWebProgress
)
;
if
(
webProgress
)
{
webProgress
-
>
RemoveProgressListener
(
this
)
;
}
mWebProgress
=
nullptr
;
}
bool
HTMLFormElement
:
:
CheckFormValidity
(
nsTArray
<
RefPtr
<
Element
>
>
*
aInvalidElements
)
const
{
bool
ret
=
true
;
AutoTArray
<
RefPtr
<
nsGenericHTMLFormElement
>
100
>
sortedControls
;
if
(
NS_FAILED
(
mControls
-
>
GetSortedControls
(
sortedControls
)
)
)
{
return
false
;
}
uint32_t
len
=
sortedControls
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsCOMPtr
<
nsIConstraintValidation
>
cvElmt
=
do_QueryObject
(
sortedControls
[
i
]
)
;
if
(
cvElmt
&
&
cvElmt
-
>
IsCandidateForConstraintValidation
(
)
&
&
!
cvElmt
-
>
IsValid
(
)
)
{
ret
=
false
;
bool
defaultAction
=
true
;
nsContentUtils
:
:
DispatchTrustedEvent
(
sortedControls
[
i
]
-
>
OwnerDoc
(
)
static_cast
<
nsIContent
*
>
(
sortedControls
[
i
]
)
NS_LITERAL_STRING
(
"
invalid
"
)
CanBubble
:
:
eNo
Cancelable
:
:
eYes
&
defaultAction
)
;
if
(
defaultAction
&
&
aInvalidElements
)
{
aInvalidElements
-
>
AppendElement
(
sortedControls
[
i
]
)
;
}
}
}
return
ret
;
}
bool
HTMLFormElement
:
:
CheckValidFormSubmission
(
)
{
NS_ASSERTION
(
!
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
"
We
shouldn
'
t
be
there
if
novalidate
is
set
!
"
)
;
nsCOMPtr
<
nsIObserverService
>
service
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
!
service
)
{
NS_WARNING
(
"
No
observer
service
available
!
"
)
;
return
true
;
}
AutoTArray
<
RefPtr
<
Element
>
32
>
invalidElements
;
if
(
CheckFormValidity
(
&
invalidElements
)
)
{
return
true
;
}
if
(
!
mEverTriedInvalidSubmit
)
{
mEverTriedInvalidSubmit
=
true
;
nsAutoScriptBlocker
scriptBlocker
;
for
(
uint32_t
i
=
0
length
=
mControls
-
>
mElements
.
Length
(
)
;
i
<
length
;
+
+
i
)
{
if
(
mControls
-
>
mElements
[
i
]
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
&
&
mControls
-
>
mElements
[
i
]
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
{
static_cast
<
HTMLInputElement
*
>
(
mControls
-
>
mElements
[
i
]
)
-
>
UpdateValidityUIBits
(
true
)
;
}
mControls
-
>
mElements
[
i
]
-
>
UpdateState
(
true
)
;
}
for
(
uint32_t
i
=
0
length
=
mControls
-
>
mNotInElements
.
Length
(
)
;
i
<
length
;
+
+
i
)
{
mControls
-
>
mNotInElements
[
i
]
-
>
UpdateState
(
true
)
;
}
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
GetOwnerGlobal
(
)
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
detail
(
jsapi
.
cx
(
)
)
;
if
(
!
ToJSValue
(
jsapi
.
cx
(
)
invalidElements
&
detail
)
)
{
return
false
;
}
RefPtr
<
CustomEvent
>
event
=
NS_NewDOMCustomEvent
(
OwnerDoc
(
)
nullptr
nullptr
)
;
event
-
>
InitCustomEvent
(
jsapi
.
cx
(
)
NS_LITERAL_STRING
(
"
MozInvalidForm
"
)
true
true
detail
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
DispatchEvent
(
*
event
)
;
bool
result
=
!
event
-
>
DefaultPrevented
(
)
;
nsCOMPtr
<
nsISimpleEnumerator
>
theEnum
;
nsresult
rv
=
service
-
>
EnumerateObservers
(
NS_INVALIDFORMSUBMIT_SUBJECT
getter_AddRefs
(
theEnum
)
)
;
NS_ENSURE_SUCCESS
(
rv
result
)
;
bool
hasObserver
=
false
;
rv
=
theEnum
-
>
HasMoreElements
(
&
hasObserver
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
hasObserver
)
{
result
=
false
;
nsCOMPtr
<
nsISupports
>
inst
;
nsCOMPtr
<
nsIFormSubmitObserver
>
observer
;
bool
more
=
true
;
while
(
NS_SUCCEEDED
(
theEnum
-
>
HasMoreElements
(
&
more
)
)
&
&
more
)
{
theEnum
-
>
GetNext
(
getter_AddRefs
(
inst
)
)
;
observer
=
do_QueryInterface
(
inst
)
;
if
(
observer
)
{
observer
-
>
NotifyInvalidSubmit
(
this
invalidElements
)
;
}
}
}
if
(
result
)
{
NS_WARNING
(
"
There
is
no
observer
for
\
"
invalidformsubmit
\
"
.
\
One
should
be
implemented
!
"
)
;
}
return
result
;
}
void
HTMLFormElement
:
:
UpdateValidity
(
bool
aElementValidity
)
{
if
(
aElementValidity
)
{
-
-
mInvalidElementsCount
;
}
else
{
+
+
mInvalidElementsCount
;
}
NS_ASSERTION
(
mInvalidElementsCount
>
=
0
"
Something
went
seriously
wrong
!
"
)
;
if
(
mInvalidElementsCount
&
&
(
mInvalidElementsCount
!
=
1
|
|
aElementValidity
)
)
{
return
;
}
nsAutoScriptBlocker
scriptBlocker
;
for
(
uint32_t
i
=
0
length
=
mControls
-
>
mElements
.
Length
(
)
;
i
<
length
;
+
+
i
)
{
if
(
mControls
-
>
mElements
[
i
]
-
>
IsSubmitControl
(
)
)
{
mControls
-
>
mElements
[
i
]
-
>
UpdateState
(
true
)
;
}
}
uint32_t
length
=
mControls
-
>
mNotInElements
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mControls
-
>
mNotInElements
[
i
]
-
>
IsSubmitControl
(
)
)
{
mControls
-
>
mNotInElements
[
i
]
-
>
UpdateState
(
true
)
;
}
}
UpdateState
(
true
)
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
OnStateChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aStatus
)
{
if
(
aRequest
=
=
mSubmittingRequest
&
&
aStateFlags
&
nsIWebProgressListener
:
:
STATE_STOP
)
{
ForgetCurrentSubmission
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
OnProgressChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
OnLocationChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsIURI
*
location
uint32_t
aFlags
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
{
MOZ_ASSERT_UNREACHABLE
(
"
notification
excluded
in
AddProgressListener
(
.
.
.
)
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
int32_t
)
HTMLFormElement
:
:
IndexOfControl
(
nsIFormControl
*
aControl
)
{
int32_t
index
=
0
;
return
mControls
-
>
IndexOfControl
(
aControl
&
index
)
=
=
NS_OK
?
index
:
0
;
}
void
HTMLFormElement
:
:
SetCurrentRadioButton
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
{
mSelectedRadioButtons
.
Put
(
aName
aRadio
)
;
}
HTMLInputElement
*
HTMLFormElement
:
:
GetCurrentRadioButton
(
const
nsAString
&
aName
)
{
return
mSelectedRadioButtons
.
GetWeak
(
aName
)
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
GetNextRadioButton
(
const
nsAString
&
aName
const
bool
aPrevious
HTMLInputElement
*
aFocusedRadio
HTMLInputElement
*
*
aRadioOut
)
{
*
aRadioOut
=
nullptr
;
RefPtr
<
HTMLInputElement
>
currentRadio
;
if
(
aFocusedRadio
)
{
currentRadio
=
aFocusedRadio
;
}
else
{
mSelectedRadioButtons
.
Get
(
aName
getter_AddRefs
(
currentRadio
)
)
;
}
nsCOMPtr
<
nsISupports
>
itemWithName
=
DoResolveName
(
aName
true
)
;
nsCOMPtr
<
nsINodeList
>
radioGroup
(
do_QueryInterface
(
itemWithName
)
)
;
if
(
!
radioGroup
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
index
=
radioGroup
-
>
IndexOf
(
currentRadio
)
;
if
(
index
<
0
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
numRadios
=
radioGroup
-
>
Length
(
)
;
RefPtr
<
HTMLInputElement
>
radio
;
bool
isRadio
=
false
;
do
{
if
(
aPrevious
)
{
if
(
-
-
index
<
0
)
{
index
=
numRadios
-
1
;
}
}
else
if
(
+
+
index
>
=
(
int32_t
)
numRadios
)
{
index
=
0
;
}
radio
=
HTMLInputElement
:
:
FromNodeOrNull
(
radioGroup
-
>
Item
(
index
)
)
;
isRadio
=
radio
&
&
radio
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RADIO
;
if
(
!
isRadio
)
{
continue
;
}
nsAutoString
name
;
radio
-
>
GetName
(
name
)
;
isRadio
=
aName
.
Equals
(
name
)
;
}
while
(
!
isRadio
|
|
(
radio
-
>
Disabled
(
)
&
&
radio
!
=
currentRadio
)
)
;
NS_IF_ADDREF
(
*
aRadioOut
=
radio
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLFormElement
:
:
WalkRadioGroup
(
const
nsAString
&
aName
nsIRadioVisitor
*
aVisitor
bool
aFlushContent
)
{
if
(
aName
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIFormControl
>
control
;
uint32_t
len
=
GetElementCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
i
+
+
)
{
control
=
GetElementAt
(
i
)
;
if
(
control
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RADIO
)
{
nsCOMPtr
<
Element
>
controlElement
=
do_QueryInterface
(
control
)
;
if
(
controlElement
&
&
controlElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
EmptyString
(
)
eCaseMatters
)
&
&
!
aVisitor
-
>
Visit
(
control
)
)
{
break
;
}
}
}
return
NS_OK
;
}
nsCOMPtr
<
nsISupports
>
item
=
DoResolveName
(
aName
aFlushContent
)
;
if
(
!
item
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
item
)
;
if
(
formControl
)
{
if
(
formControl
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RADIO
)
{
aVisitor
-
>
Visit
(
formControl
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsINodeList
>
nodeList
=
do_QueryInterface
(
item
)
;
if
(
!
nodeList
)
{
return
NS_OK
;
}
uint32_t
length
=
nodeList
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
nsIContent
*
node
=
nodeList
-
>
Item
(
i
)
;
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
node
)
;
if
(
formControl
&
&
formControl
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RADIO
&
&
!
aVisitor
-
>
Visit
(
formControl
)
)
{
break
;
}
}
return
NS_OK
;
}
void
HTMLFormElement
:
:
AddToRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
{
if
(
aRadio
-
>
IsRequired
(
)
)
{
auto
entry
=
mRequiredRadioButtonCounts
.
LookupForAdd
(
aName
)
;
if
(
!
entry
)
{
entry
.
OrInsert
(
[
]
(
)
{
return
1
;
}
)
;
}
else
{
+
+
entry
.
Data
(
)
;
}
}
}
void
HTMLFormElement
:
:
RemoveFromRadioGroup
(
const
nsAString
&
aName
HTMLInputElement
*
aRadio
)
{
if
(
aRadio
-
>
IsRequired
(
)
)
{
auto
entry
=
mRequiredRadioButtonCounts
.
Lookup
(
aName
)
;
if
(
!
entry
)
{
MOZ_ASSERT_UNREACHABLE
(
"
At
least
one
radio
button
has
to
be
required
!
"
)
;
}
else
{
MOZ_ASSERT
(
entry
.
Data
(
)
>
=
1
"
At
least
one
radio
button
has
to
be
required
!
"
)
;
if
(
entry
.
Data
(
)
<
=
1
)
{
entry
.
Remove
(
)
;
}
else
{
-
-
entry
.
Data
(
)
;
}
}
}
}
uint32_t
HTMLFormElement
:
:
GetRequiredRadioCount
(
const
nsAString
&
aName
)
const
{
return
mRequiredRadioButtonCounts
.
Get
(
aName
)
;
}
void
HTMLFormElement
:
:
RadioRequiredWillChange
(
const
nsAString
&
aName
bool
aRequiredAdded
)
{
if
(
aRequiredAdded
)
{
mRequiredRadioButtonCounts
.
Put
(
aName
mRequiredRadioButtonCounts
.
Get
(
aName
)
+
1
)
;
}
else
{
uint32_t
requiredNb
=
mRequiredRadioButtonCounts
.
Get
(
aName
)
;
NS_ASSERTION
(
requiredNb
>
=
1
"
At
least
one
radio
button
has
to
be
required
!
"
)
;
if
(
requiredNb
=
=
1
)
{
mRequiredRadioButtonCounts
.
Remove
(
aName
)
;
}
else
{
mRequiredRadioButtonCounts
.
Put
(
aName
requiredNb
-
1
)
;
}
}
}
bool
HTMLFormElement
:
:
GetValueMissingState
(
const
nsAString
&
aName
)
const
{
return
mValueMissingRadioGroups
.
Get
(
aName
)
;
}
void
HTMLFormElement
:
:
SetValueMissingState
(
const
nsAString
&
aName
bool
aValue
)
{
mValueMissingRadioGroups
.
Put
(
aName
aValue
)
;
}
EventStates
HTMLFormElement
:
:
IntrinsicState
(
)
const
{
EventStates
state
=
nsGenericHTMLElement
:
:
IntrinsicState
(
)
;
if
(
mInvalidElementsCount
)
{
state
|
=
NS_EVENT_STATE_INVALID
;
}
else
{
state
|
=
NS_EVENT_STATE_VALID
;
}
return
state
;
}
void
HTMLFormElement
:
:
Clear
(
)
{
for
(
int32_t
i
=
mImageElements
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
mImageElements
[
i
]
-
>
ClearForm
(
false
)
;
}
mImageElements
.
Clear
(
)
;
mImageNameLookupTable
.
Clear
(
)
;
mPastNameLookupTable
.
Clear
(
)
;
}
namespace
{
struct
PositionComparator
{
nsIContent
*
const
mElement
;
explicit
PositionComparator
(
nsIContent
*
const
aElement
)
:
mElement
(
aElement
)
{
}
int
operator
(
)
(
nsIContent
*
aElement
)
const
{
if
(
mElement
=
=
aElement
)
{
return
0
;
}
if
(
nsContentUtils
:
:
PositionIsBefore
(
mElement
aElement
)
)
{
return
-
1
;
}
return
1
;
}
}
;
struct
RadioNodeListAdaptor
{
RadioNodeList
*
const
mList
;
explicit
RadioNodeListAdaptor
(
RadioNodeList
*
aList
)
:
mList
(
aList
)
{
}
nsIContent
*
operator
[
]
(
size_t
aIdx
)
const
{
return
mList
-
>
Item
(
aIdx
)
;
}
}
;
}
nsresult
HTMLFormElement
:
:
AddElementToTableInternal
(
nsInterfaceHashtable
<
nsStringHashKey
nsISupports
>
&
aTable
nsIContent
*
aChild
const
nsAString
&
aName
)
{
auto
entry
=
aTable
.
LookupForAdd
(
aName
)
;
if
(
!
entry
)
{
entry
.
OrInsert
(
[
&
aChild
]
(
)
{
return
aChild
;
}
)
;
+
+
mExpandoAndGeneration
.
generation
;
}
else
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
entry
.
Data
(
)
)
;
if
(
content
)
{
if
(
content
=
=
aChild
)
{
return
NS_OK
;
}
RadioNodeList
*
list
=
new
RadioNodeList
(
this
)
;
NS_ASSERTION
(
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
form
)
)
|
|
content
-
>
GetParent
(
)
"
Item
in
list
without
parent
"
)
;
bool
newFirst
=
nsContentUtils
:
:
PositionIsBefore
(
aChild
content
)
;
list
-
>
AppendElement
(
newFirst
?
aChild
:
content
.
get
(
)
)
;
list
-
>
AppendElement
(
newFirst
?
content
.
get
(
)
:
aChild
)
;
nsCOMPtr
<
nsISupports
>
listSupports
=
do_QueryObject
(
list
)
;
entry
.
Data
(
)
=
listSupports
;
}
else
{
MOZ_ASSERT
(
nsCOMPtr
<
RadioNodeList
>
(
do_QueryInterface
(
entry
.
Data
(
)
)
)
)
;
auto
*
list
=
static_cast
<
RadioNodeList
*
>
(
entry
.
Data
(
)
.
get
(
)
)
;
NS_ASSERTION
(
list
-
>
Length
(
)
>
1
"
List
should
have
been
converted
back
to
a
single
element
"
)
;
if
(
nsContentUtils
:
:
PositionIsBefore
(
list
-
>
Item
(
list
-
>
Length
(
)
-
1
)
aChild
)
)
{
list
-
>
AppendElement
(
aChild
)
;
return
NS_OK
;
}
if
(
list
-
>
IndexOf
(
aChild
)
!
=
-
1
)
{
return
NS_OK
;
}
size_t
idx
;
DebugOnly
<
bool
>
found
=
BinarySearchIf
(
RadioNodeListAdaptor
(
list
)
0
list
-
>
Length
(
)
PositionComparator
(
aChild
)
&
idx
)
;
MOZ_ASSERT
(
!
found
"
should
not
have
found
an
element
"
)
;
list
-
>
InsertElementAt
(
aChild
idx
)
;
}
}
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
AddImageElement
(
HTMLImageElement
*
aChild
)
{
AddElementToList
(
mImageElements
aChild
this
)
;
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
AddImageElementToTable
(
HTMLImageElement
*
aChild
const
nsAString
&
aName
)
{
return
AddElementToTableInternal
(
mImageNameLookupTable
aChild
aName
)
;
}
nsresult
HTMLFormElement
:
:
RemoveImageElement
(
HTMLImageElement
*
aChild
)
{
RemoveElementFromPastNamesMap
(
aChild
)
;
size_t
index
=
mImageElements
.
IndexOf
(
aChild
)
;
NS_ENSURE_STATE
(
index
!
=
mImageElements
.
NoIndex
)
;
mImageElements
.
RemoveElementAt
(
index
)
;
return
NS_OK
;
}
nsresult
HTMLFormElement
:
:
RemoveImageElementFromTable
(
HTMLImageElement
*
aElement
const
nsAString
&
aName
)
{
return
RemoveElementFromTableInternal
(
mImageNameLookupTable
aElement
aName
)
;
}
void
HTMLFormElement
:
:
AddToPastNamesMap
(
const
nsAString
&
aName
nsISupports
*
aChild
)
{
nsCOMPtr
<
nsIContent
>
node
=
do_QueryInterface
(
aChild
)
;
if
(
node
)
{
mPastNameLookupTable
.
Put
(
aName
node
)
;
node
-
>
SetFlags
(
MAY_BE_IN_PAST_NAMES_MAP
)
;
}
}
void
HTMLFormElement
:
:
RemoveElementFromPastNamesMap
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
HasFlag
(
MAY_BE_IN_PAST_NAMES_MAP
)
)
{
return
;
}
aElement
-
>
UnsetFlags
(
MAY_BE_IN_PAST_NAMES_MAP
)
;
uint32_t
oldCount
=
mPastNameLookupTable
.
Count
(
)
;
for
(
auto
iter
=
mPastNameLookupTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
aElement
=
=
iter
.
Data
(
)
)
{
iter
.
Remove
(
)
;
}
}
if
(
oldCount
!
=
mPastNameLookupTable
.
Count
(
)
)
{
+
+
mExpandoAndGeneration
.
generation
;
}
}
JSObject
*
HTMLFormElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLFormElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
int32_t
HTMLFormElement
:
:
GetFormNumberForStateKey
(
)
{
if
(
mFormNumber
=
=
-
1
)
{
mFormNumber
=
OwnerDoc
(
)
-
>
GetNextFormNumber
(
)
;
}
return
mFormNumber
;
}
void
HTMLFormElement
:
:
NodeInfoChanged
(
Document
*
aOldDoc
)
{
nsGenericHTMLElement
:
:
NodeInfoChanged
(
aOldDoc
)
;
mFormNumber
=
-
1
;
}
}
}
