#
include
"
mozilla
/
dom
/
HTMLOptionElement
.
h
"
#
include
"
HTMLOptGroupElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptionElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsISelectControlFrame
.
h
"
#
include
"
nsIFormControlFrame
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsTextNode
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Option
)
namespace
mozilla
:
:
dom
{
HTMLOptionElement
:
:
HTMLOptionElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsGenericHTMLElement
(
std
:
:
move
(
aNodeInfo
)
)
mSelectedChanged
(
false
)
mIsSelected
(
false
)
mIsInSetDefaultSelected
(
false
)
{
AddStatesSilently
(
ElementState
:
:
ENABLED
)
;
}
HTMLOptionElement
:
:
~
HTMLOptionElement
(
)
=
default
;
NS_IMPL_ELEMENT_CLONE
(
HTMLOptionElement
)
mozilla
:
:
dom
:
:
HTMLFormElement
*
HTMLOptionElement
:
:
GetForm
(
)
{
HTMLSelectElement
*
selectControl
=
GetSelect
(
)
;
return
selectControl
?
selectControl
-
>
GetForm
(
)
:
nullptr
;
}
void
HTMLOptionElement
:
:
SetSelectedInternal
(
bool
aValue
bool
aNotify
)
{
mSelectedChanged
=
true
;
mIsSelected
=
aValue
;
if
(
!
mIsInSetDefaultSelected
)
{
UpdateState
(
aNotify
)
;
}
}
void
HTMLOptionElement
:
:
OptGroupDisabledChanged
(
bool
aNotify
)
{
UpdateDisabledState
(
aNotify
)
;
}
void
HTMLOptionElement
:
:
UpdateDisabledState
(
bool
aNotify
)
{
bool
isDisabled
=
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
)
;
if
(
!
isDisabled
)
{
nsIContent
*
parent
=
GetParent
(
)
;
if
(
auto
optGroupElement
=
HTMLOptGroupElement
:
:
FromNodeOrNull
(
parent
)
)
{
isDisabled
=
optGroupElement
-
>
IsDisabled
(
)
;
}
}
ElementState
disabledStates
;
if
(
isDisabled
)
{
disabledStates
|
=
ElementState
:
:
DISABLED
;
}
else
{
disabledStates
|
=
ElementState
:
:
ENABLED
;
}
ElementState
oldDisabledStates
=
State
(
)
&
ElementState
:
:
DISABLED_STATES
;
ElementState
changedStates
=
disabledStates
^
oldDisabledStates
;
if
(
!
changedStates
.
IsEmpty
(
)
)
{
ToggleStates
(
changedStates
aNotify
)
;
}
}
void
HTMLOptionElement
:
:
SetSelected
(
bool
aValue
)
{
HTMLSelectElement
*
selectInt
=
GetSelect
(
)
;
if
(
selectInt
)
{
int32_t
index
=
Index
(
)
;
HTMLSelectElement
:
:
OptionFlags
mask
{
HTMLSelectElement
:
:
OptionFlag
:
:
SetDisabled
HTMLSelectElement
:
:
OptionFlag
:
:
Notify
}
;
if
(
aValue
)
{
mask
+
=
HTMLSelectElement
:
:
OptionFlag
:
:
IsSelected
;
}
selectInt
-
>
SetOptionsSelectedByIndex
(
index
index
mask
)
;
}
else
{
SetSelectedInternal
(
aValue
true
)
;
}
}
int32_t
HTMLOptionElement
:
:
Index
(
)
{
static
int32_t
defaultIndex
=
0
;
HTMLSelectElement
*
selectElement
=
GetSelect
(
)
;
if
(
!
selectElement
)
{
return
defaultIndex
;
}
HTMLOptionsCollection
*
options
=
selectElement
-
>
GetOptions
(
)
;
if
(
!
options
)
{
return
defaultIndex
;
}
int32_t
index
=
defaultIndex
;
MOZ_ALWAYS_SUCCEEDS
(
options
-
>
GetOptionIndex
(
this
0
true
&
index
)
)
;
return
index
;
}
nsChangeHint
HTMLOptionElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
nsGenericHTMLElement
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
text
)
{
retval
|
=
NS_STYLE_HINT_REFLOW
;
}
return
retval
;
}
void
HTMLOptionElement
:
:
BeforeSetAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
nsGenericHTMLElement
:
:
BeforeSetAttr
(
aNamespaceID
aName
aValue
aNotify
)
;
if
(
aNamespaceID
!
=
kNameSpaceID_None
|
|
aName
!
=
nsGkAtoms
:
:
selected
|
|
mSelectedChanged
)
{
return
;
}
HTMLSelectElement
*
selectInt
=
GetSelect
(
)
;
if
(
!
selectInt
)
{
mIsSelected
=
aValue
;
return
;
}
NS_ASSERTION
(
!
mSelectedChanged
"
Shouldn
'
t
be
here
"
)
;
bool
inSetDefaultSelected
=
mIsInSetDefaultSelected
;
mIsInSetDefaultSelected
=
true
;
int32_t
index
=
Index
(
)
;
HTMLSelectElement
:
:
OptionFlags
mask
=
HTMLSelectElement
:
:
OptionFlag
:
:
SetDisabled
;
if
(
aValue
)
{
mask
+
=
HTMLSelectElement
:
:
OptionFlag
:
:
IsSelected
;
}
if
(
aNotify
)
{
mask
+
=
HTMLSelectElement
:
:
OptionFlag
:
:
Notify
;
}
selectInt
-
>
SetOptionsSelectedByIndex
(
index
index
mask
)
;
mIsInSetDefaultSelected
=
inSetDefaultSelected
;
mSelectedChanged
=
false
;
}
nsresult
HTMLOptionElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
disabled
)
{
UpdateDisabledState
(
aNotify
)
;
}
if
(
aName
=
=
nsGkAtoms
:
:
value
&
&
Selected
(
)
)
{
HTMLSelectElement
*
select
=
GetSelect
(
)
;
if
(
select
)
{
select
-
>
UpdateValueMissingValidityState
(
)
;
}
}
}
return
nsGenericHTMLElement
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
void
HTMLOptionElement
:
:
GetText
(
nsAString
&
aText
)
{
nsAutoString
text
;
nsIContent
*
child
=
nsINode
:
:
GetFirstChild
(
)
;
while
(
child
)
{
if
(
Text
*
textChild
=
child
-
>
GetAsText
(
)
)
{
textChild
-
>
AppendTextTo
(
text
)
;
}
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
script
)
|
|
child
-
>
IsSVGElement
(
nsGkAtoms
:
:
script
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
this
)
;
}
else
{
child
=
child
-
>
GetNextNode
(
this
)
;
}
}
text
.
CompressWhitespace
(
true
true
)
;
aText
=
text
;
}
void
HTMLOptionElement
:
:
SetText
(
const
nsAString
&
aText
ErrorResult
&
aRv
)
{
aRv
=
nsContentUtils
:
:
SetNodeTextContent
(
this
aText
true
)
;
}
nsresult
HTMLOptionElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UpdateDisabledState
(
false
)
;
return
NS_OK
;
}
void
HTMLOptionElement
:
:
UnbindFromTree
(
bool
aNullParent
)
{
nsGenericHTMLElement
:
:
UnbindFromTree
(
aNullParent
)
;
UpdateDisabledState
(
false
)
;
}
ElementState
HTMLOptionElement
:
:
IntrinsicState
(
)
const
{
ElementState
state
=
nsGenericHTMLElement
:
:
IntrinsicState
(
)
;
if
(
Selected
(
)
)
{
state
|
=
ElementState
:
:
CHECKED
;
}
if
(
DefaultSelected
(
)
)
{
state
|
=
ElementState
:
:
DEFAULT
;
}
return
state
;
}
HTMLSelectElement
*
HTMLOptionElement
:
:
GetSelect
(
)
{
nsIContent
*
parent
=
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
HTMLSelectElement
*
select
=
HTMLSelectElement
:
:
FromNode
(
parent
)
;
if
(
select
)
{
return
select
;
}
if
(
!
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
)
{
return
nullptr
;
}
return
HTMLSelectElement
:
:
FromNodeOrNull
(
parent
-
>
GetParent
(
)
)
;
}
already_AddRefed
<
HTMLOptionElement
>
HTMLOptionElement
:
:
Option
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aText
const
Optional
<
nsAString
>
&
aValue
bool
aDefaultSelected
bool
aSelected
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
Document
*
doc
;
if
(
!
win
|
|
!
(
doc
=
win
-
>
GetExtantDoc
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
doc
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
option
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
auto
*
nim
=
nodeInfo
-
>
NodeInfoManager
(
)
;
RefPtr
<
HTMLOptionElement
>
option
=
new
(
nim
)
HTMLOptionElement
(
nodeInfo
.
forget
(
)
)
;
if
(
!
aText
.
IsEmpty
(
)
)
{
RefPtr
<
nsTextNode
>
textContent
=
new
(
option
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
)
nsTextNode
(
option
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
)
;
textContent
-
>
SetText
(
aText
false
)
;
option
-
>
AppendChildTo
(
textContent
false
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
if
(
aValue
.
WasPassed
(
)
)
{
aError
=
option
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aValue
.
Value
(
)
false
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
if
(
aDefaultSelected
)
{
aError
=
option
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
selected
u
"
"
_ns
false
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
option
-
>
SetSelected
(
aSelected
)
;
option
-
>
SetSelectedChanged
(
false
)
;
return
option
.
forget
(
)
;
}
nsresult
HTMLOptionElement
:
:
CopyInnerTo
(
Element
*
aDest
)
{
nsresult
rv
=
nsGenericHTMLElement
:
:
CopyInnerTo
(
aDest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aDest
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
)
{
static_cast
<
HTMLOptionElement
*
>
(
aDest
)
-
>
SetSelected
(
Selected
(
)
)
;
}
return
NS_OK
;
}
JSObject
*
HTMLOptionElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLOptionElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
