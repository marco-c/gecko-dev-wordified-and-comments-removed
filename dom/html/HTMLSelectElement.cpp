#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FormData
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptGroupElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptionElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
MappedDeclarationsBuilder
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
nsISelectControlFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTextNode
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
Select
)
namespace
mozilla
:
:
dom
{
SafeOptionListMutation
:
:
SafeOptionListMutation
(
nsIContent
*
aSelect
nsIContent
*
aParent
nsIContent
*
aKid
uint32_t
aIndex
bool
aNotify
)
:
mSelect
(
HTMLSelectElement
:
:
FromNodeOrNull
(
aSelect
)
)
mTopLevelMutation
(
false
)
mNeedsRebuild
(
false
)
mNotify
(
aNotify
)
{
if
(
mSelect
)
{
mInitialSelectedOption
=
mSelect
-
>
Item
(
mSelect
-
>
SelectedIndex
(
)
)
;
mTopLevelMutation
=
!
mSelect
-
>
mMutating
;
if
(
mTopLevelMutation
)
{
mSelect
-
>
mMutating
=
true
;
}
else
{
mSelect
-
>
RebuildOptionsArray
(
mNotify
)
;
}
nsresult
rv
;
if
(
aKid
)
{
rv
=
mSelect
-
>
WillAddOptions
(
aKid
aParent
aIndex
mNotify
)
;
}
else
{
rv
=
mSelect
-
>
WillRemoveOptions
(
aParent
aIndex
mNotify
)
;
}
mNeedsRebuild
=
NS_FAILED
(
rv
)
;
}
}
SafeOptionListMutation
:
:
~
SafeOptionListMutation
(
)
{
if
(
mSelect
)
{
if
(
mNeedsRebuild
|
|
(
mTopLevelMutation
&
&
mGuard
.
Mutated
(
1
)
)
)
{
mSelect
-
>
RebuildOptionsArray
(
true
)
;
}
if
(
mTopLevelMutation
)
{
mSelect
-
>
mMutating
=
false
;
}
if
(
mSelect
-
>
Item
(
mSelect
-
>
SelectedIndex
(
)
)
!
=
mInitialSelectedOption
)
{
mSelect
-
>
UpdateValueMissingValidityState
(
)
;
mSelect
-
>
UpdateValidityElementStates
(
mNotify
)
;
}
#
ifdef
DEBUG
mSelect
-
>
VerifyOptionsArray
(
)
;
#
endif
}
}
HTMLSelectElement
:
:
HTMLSelectElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFormControlElementWithState
(
std
:
:
move
(
aNodeInfo
)
aFromParser
FormControlType
:
:
Select
)
mOptions
(
new
HTMLOptionsCollection
(
this
)
)
mAutocompleteAttrState
(
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
)
mAutocompleteInfoState
(
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
)
mIsDoneAddingChildren
(
!
aFromParser
)
mDisabledChanged
(
false
)
mMutating
(
false
)
mInhibitStateRestoration
(
!
!
(
aFromParser
&
FROM_PARSER_FRAGMENT
)
)
mUserInteracted
(
false
)
mDefaultSelectionSet
(
false
)
mIsOpenInParentProcess
(
false
)
mNonOptionChildren
(
0
)
mOptGroupCount
(
0
)
mSelectedIndex
(
-
1
)
{
SetHasWeirdParserInsertionMode
(
)
;
AddStatesSilently
(
ElementState
:
:
ENABLED
|
ElementState
:
:
OPTIONAL_
|
ElementState
:
:
VALID
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
HTMLSelectElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
HTMLSelectElement
nsGenericHTMLFormControlElementWithState
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mValidity
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOptions
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelectedOptions
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
HTMLSelectElement
nsGenericHTMLFormControlElementWithState
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mValidity
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelectedOptions
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLSelectElement
nsGenericHTMLFormControlElementWithState
nsIConstraintValidation
)
NS_IMPL_ELEMENT_CLONE
(
HTMLSelectElement
)
void
HTMLSelectElement
:
:
SetCustomValidity
(
const
nsAString
&
aError
)
{
ConstraintValidation
:
:
SetCustomValidity
(
aError
)
;
UpdateValidityElementStates
(
true
)
;
}
void
HTMLSelectElement
:
:
ShowPicker
(
ErrorResult
&
aRv
)
{
if
(
IsDisabled
(
)
)
{
return
aRv
.
ThrowInvalidStateError
(
"
This
select
is
disabled
.
"
)
;
}
nsPIDOMWindowInner
*
window
=
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
;
WindowGlobalChild
*
windowGlobalChild
=
window
?
window
-
>
GetWindowGlobalChild
(
)
:
nullptr
;
if
(
!
windowGlobalChild
|
|
!
windowGlobalChild
-
>
SameOriginWithTop
(
)
)
{
return
aRv
.
ThrowSecurityError
(
"
Call
was
blocked
because
the
current
origin
isn
'
t
same
-
origin
with
"
"
top
.
"
)
;
}
if
(
!
OwnerDoc
(
)
-
>
HasValidTransientUserGestureActivation
(
)
)
{
return
aRv
.
ThrowNotAllowedError
(
"
Call
was
blocked
due
to
lack
of
user
activation
.
"
)
;
}
Unused
<
<
GetPrimaryFrame
(
FlushType
:
:
Frames
)
;
if
(
!
IsRendered
(
)
)
{
return
aRv
.
ThrowNotSupportedError
(
"
This
select
isn
'
t
being
rendered
.
"
)
;
}
OwnerDoc
(
)
-
>
ConsumeTransientUserGestureActivation
(
)
;
#
if
!
defined
(
ANDROID
)
if
(
!
IsCombobox
(
)
)
{
return
;
}
#
endif
if
(
!
IsInActiveTab
(
OwnerDoc
(
)
)
)
{
return
;
}
if
(
!
OpenInParentProcess
(
)
)
{
RefPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
nsContentUtils
:
:
DispatchChromeEvent
(
doc
this
u
"
mozshowdropdown
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
}
void
HTMLSelectElement
:
:
GetAutocomplete
(
DOMString
&
aValue
)
{
const
nsAttrValue
*
attributeVal
=
GetParsedAttr
(
nsGkAtoms
:
:
autocomplete
)
;
mAutocompleteAttrState
=
nsContentUtils
:
:
SerializeAutocompleteAttribute
(
attributeVal
aValue
mAutocompleteAttrState
)
;
}
void
HTMLSelectElement
:
:
GetAutocompleteInfo
(
AutocompleteInfo
&
aInfo
)
{
const
nsAttrValue
*
attributeVal
=
GetParsedAttr
(
nsGkAtoms
:
:
autocomplete
)
;
mAutocompleteInfoState
=
nsContentUtils
:
:
SerializeAutocompleteAttribute
(
attributeVal
aInfo
mAutocompleteInfoState
true
)
;
}
void
HTMLSelectElement
:
:
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
ErrorResult
&
aRv
)
{
const
uint32_t
index
=
aBeforeThis
?
*
ComputeIndexOf
(
aBeforeThis
)
:
GetChildCount
(
)
;
SafeOptionListMutation
safeMutation
(
this
this
aKid
index
aNotify
)
;
nsGenericHTMLFormControlElementWithState
:
:
InsertChildBefore
(
aKid
aBeforeThis
aNotify
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
safeMutation
.
MutationFailed
(
)
;
}
}
void
HTMLSelectElement
:
:
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
const
BatchRemovalState
*
aState
)
{
SafeOptionListMutation
safeMutation
(
this
this
nullptr
*
ComputeIndexOf
(
aKid
)
aNotify
)
;
nsGenericHTMLFormControlElementWithState
:
:
RemoveChildNode
(
aKid
aNotify
aState
)
;
}
void
HTMLSelectElement
:
:
InsertOptionsIntoList
(
nsIContent
*
aOptions
int32_t
aListIndex
int32_t
aDepth
bool
aNotify
)
{
MOZ_ASSERT
(
aDepth
=
=
0
|
|
aDepth
=
=
1
)
;
int32_t
insertIndex
=
aListIndex
;
HTMLOptionElement
*
optElement
=
HTMLOptionElement
:
:
FromNode
(
aOptions
)
;
if
(
optElement
)
{
mOptions
-
>
InsertOptionAt
(
optElement
insertIndex
)
;
insertIndex
+
+
;
}
else
if
(
aDepth
=
=
0
)
{
mNonOptionChildren
+
+
;
if
(
aOptions
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
)
{
mOptGroupCount
+
+
;
for
(
nsIContent
*
child
=
aOptions
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
optElement
=
HTMLOptionElement
:
:
FromNode
(
child
)
;
if
(
optElement
)
{
mOptions
-
>
InsertOptionAt
(
optElement
insertIndex
)
;
insertIndex
+
+
;
}
}
}
}
if
(
insertIndex
-
aListIndex
)
{
if
(
aListIndex
<
=
mSelectedIndex
)
{
mSelectedIndex
+
=
(
insertIndex
-
aListIndex
)
;
OnSelectionChanged
(
)
;
}
nsISelectControlFrame
*
selectFrame
=
nullptr
;
AutoWeakFrame
weakSelectFrame
;
bool
didGetFrame
=
false
;
for
(
int32_t
i
=
aListIndex
;
i
<
insertIndex
;
i
+
+
)
{
if
(
!
didGetFrame
|
|
(
selectFrame
&
&
!
weakSelectFrame
.
IsAlive
(
)
)
)
{
selectFrame
=
GetSelectFrame
(
)
;
weakSelectFrame
=
do_QueryFrame
(
selectFrame
)
;
didGetFrame
=
true
;
}
if
(
selectFrame
)
{
selectFrame
-
>
AddOption
(
i
)
;
}
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
i
)
;
if
(
option
&
&
option
-
>
Selected
(
)
)
{
if
(
!
HasAttr
(
nsGkAtoms
:
:
multiple
)
)
{
OptionFlags
mask
{
OptionFlag
:
:
IsSelected
OptionFlag
:
:
ClearAll
OptionFlag
:
:
SetDisabled
OptionFlag
:
:
Notify
OptionFlag
:
:
InsertingOptions
}
;
SetOptionsSelectedByIndex
(
i
i
mask
)
;
}
OnOptionSelected
(
selectFrame
i
true
false
aNotify
)
;
}
}
CheckSelectSomething
(
aNotify
)
;
}
}
nsresult
HTMLSelectElement
:
:
RemoveOptionsFromList
(
nsIContent
*
aOptions
int32_t
aListIndex
int32_t
aDepth
bool
aNotify
)
{
MOZ_ASSERT
(
aDepth
=
=
0
|
|
aDepth
=
=
1
)
;
int32_t
numRemoved
=
0
;
HTMLOptionElement
*
optElement
=
HTMLOptionElement
:
:
FromNode
(
aOptions
)
;
if
(
optElement
)
{
if
(
mOptions
-
>
ItemAsOption
(
aListIndex
)
!
=
optElement
)
{
NS_ERROR
(
"
wrong
option
at
index
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
mOptions
-
>
RemoveOptionAt
(
aListIndex
)
;
numRemoved
+
+
;
}
else
if
(
aDepth
=
=
0
)
{
mNonOptionChildren
-
-
;
if
(
mOptGroupCount
&
&
aOptions
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
)
{
mOptGroupCount
-
-
;
for
(
nsIContent
*
child
=
aOptions
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
optElement
=
HTMLOptionElement
:
:
FromNode
(
child
)
;
if
(
optElement
)
{
if
(
mOptions
-
>
ItemAsOption
(
aListIndex
)
!
=
optElement
)
{
NS_ERROR
(
"
wrong
option
at
index
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
mOptions
-
>
RemoveOptionAt
(
aListIndex
)
;
numRemoved
+
+
;
}
}
}
}
if
(
numRemoved
)
{
nsISelectControlFrame
*
selectFrame
=
GetSelectFrame
(
)
;
if
(
selectFrame
)
{
nsAutoScriptBlocker
scriptBlocker
;
for
(
int32_t
i
=
aListIndex
;
i
<
aListIndex
+
numRemoved
;
+
+
i
)
{
selectFrame
-
>
RemoveOption
(
i
)
;
}
}
if
(
aListIndex
<
=
mSelectedIndex
)
{
if
(
mSelectedIndex
<
(
aListIndex
+
numRemoved
)
)
{
if
(
IsCombobox
(
)
)
{
mSelectedIndex
=
-
1
;
OnSelectionChanged
(
)
;
}
else
{
FindSelectedIndex
(
aListIndex
aNotify
)
;
}
}
else
{
mSelectedIndex
-
=
numRemoved
;
OnSelectionChanged
(
)
;
}
}
if
(
!
CheckSelectSomething
(
aNotify
)
&
&
mSelectedIndex
=
=
-
1
)
{
UpdateValueMissingValidityState
(
)
;
UpdateValidityElementStates
(
aNotify
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
HTMLSelectElement
:
:
WillAddOptions
(
nsIContent
*
aOptions
nsIContent
*
aParent
int32_t
aContentIndex
bool
aNotify
)
{
if
(
this
!
=
aParent
&
&
this
!
=
aParent
-
>
GetParent
(
)
)
{
return
NS_OK
;
}
int32_t
level
=
aParent
=
=
this
?
0
:
1
;
int32_t
ind
=
-
1
;
if
(
!
mNonOptionChildren
)
{
ind
=
aContentIndex
;
}
else
{
int32_t
children
=
aParent
-
>
GetChildCount
(
)
;
if
(
aContentIndex
>
=
children
)
{
ind
=
GetOptionIndexAfter
(
aParent
)
;
}
else
{
nsIContent
*
currentKid
=
aParent
-
>
GetChildAt_Deprecated
(
aContentIndex
)
;
NS_ASSERTION
(
currentKid
"
Child
not
found
!
"
)
;
if
(
currentKid
)
{
ind
=
GetOptionIndexAt
(
currentKid
)
;
}
else
{
ind
=
-
1
;
}
}
}
InsertOptionsIntoList
(
aOptions
ind
level
aNotify
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLSelectElement
:
:
WillRemoveOptions
(
nsIContent
*
aParent
int32_t
aContentIndex
bool
aNotify
)
{
if
(
this
!
=
aParent
&
&
this
!
=
aParent
-
>
GetParent
(
)
)
{
return
NS_OK
;
}
int32_t
level
=
this
=
=
aParent
?
0
:
1
;
nsIContent
*
currentKid
=
aParent
-
>
GetChildAt_Deprecated
(
aContentIndex
)
;
if
(
currentKid
)
{
int32_t
ind
;
if
(
!
mNonOptionChildren
)
{
ind
=
aContentIndex
;
}
else
{
ind
=
GetFirstOptionIndex
(
currentKid
)
;
}
if
(
ind
!
=
-
1
)
{
nsresult
rv
=
RemoveOptionsFromList
(
currentKid
ind
level
aNotify
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
return
NS_OK
;
}
int32_t
HTMLSelectElement
:
:
GetOptionIndexAt
(
nsIContent
*
aOptions
)
{
int32_t
retval
=
GetFirstOptionIndex
(
aOptions
)
;
if
(
retval
=
=
-
1
)
{
retval
=
GetOptionIndexAfter
(
aOptions
)
;
}
return
retval
;
}
int32_t
HTMLSelectElement
:
:
GetOptionIndexAfter
(
nsIContent
*
aOptions
)
{
if
(
aOptions
=
=
this
)
{
return
Length
(
)
;
}
int32_t
retval
=
-
1
;
nsCOMPtr
<
nsIContent
>
parent
=
aOptions
-
>
GetParent
(
)
;
if
(
parent
)
{
const
int32_t
index
=
parent
-
>
ComputeIndexOf_Deprecated
(
aOptions
)
;
const
int32_t
count
=
static_cast
<
int32_t
>
(
parent
-
>
GetChildCount
(
)
)
;
retval
=
GetFirstChildOptionIndex
(
parent
index
+
1
count
)
;
if
(
retval
=
=
-
1
)
{
retval
=
GetOptionIndexAfter
(
parent
)
;
}
}
return
retval
;
}
int32_t
HTMLSelectElement
:
:
GetFirstOptionIndex
(
nsIContent
*
aOptions
)
{
int32_t
listIndex
=
-
1
;
HTMLOptionElement
*
optElement
=
HTMLOptionElement
:
:
FromNode
(
aOptions
)
;
if
(
optElement
)
{
mOptions
-
>
GetOptionIndex
(
optElement
0
true
&
listIndex
)
;
return
listIndex
;
}
listIndex
=
GetFirstChildOptionIndex
(
aOptions
0
aOptions
-
>
GetChildCount
(
)
)
;
return
listIndex
;
}
int32_t
HTMLSelectElement
:
:
GetFirstChildOptionIndex
(
nsIContent
*
aOptions
int32_t
aStartIndex
int32_t
aEndIndex
)
{
int32_t
retval
=
-
1
;
for
(
int32_t
i
=
aStartIndex
;
i
<
aEndIndex
;
+
+
i
)
{
retval
=
GetFirstOptionIndex
(
aOptions
-
>
GetChildAt_Deprecated
(
i
)
)
;
if
(
retval
!
=
-
1
)
{
break
;
}
}
return
retval
;
}
nsISelectControlFrame
*
HTMLSelectElement
:
:
GetSelectFrame
(
)
{
return
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
}
void
HTMLSelectElement
:
:
Add
(
const
HTMLOptionElementOrHTMLOptGroupElement
&
aElement
const
Nullable
<
HTMLElementOrLong
>
&
aBefore
ErrorResult
&
aRv
)
{
nsGenericHTMLElement
&
element
=
aElement
.
IsHTMLOptionElement
(
)
?
static_cast
<
nsGenericHTMLElement
&
>
(
aElement
.
GetAsHTMLOptionElement
(
)
)
:
static_cast
<
nsGenericHTMLElement
&
>
(
aElement
.
GetAsHTMLOptGroupElement
(
)
)
;
if
(
aBefore
.
IsNull
(
)
)
{
Add
(
element
static_cast
<
nsGenericHTMLElement
*
>
(
nullptr
)
aRv
)
;
}
else
if
(
aBefore
.
Value
(
)
.
IsHTMLElement
(
)
)
{
Add
(
element
&
aBefore
.
Value
(
)
.
GetAsHTMLElement
(
)
aRv
)
;
}
else
{
Add
(
element
aBefore
.
Value
(
)
.
GetAsLong
(
)
aRv
)
;
}
}
void
HTMLSelectElement
:
:
Add
(
nsGenericHTMLElement
&
aElement
nsGenericHTMLElement
*
aBefore
ErrorResult
&
aError
)
{
if
(
!
aBefore
)
{
Element
:
:
AppendChild
(
aElement
aError
)
;
return
;
}
nsCOMPtr
<
nsINode
>
parent
=
aBefore
-
>
Element
:
:
GetParentNode
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsInclusiveDescendantOf
(
this
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
;
}
nsCOMPtr
<
nsINode
>
refNode
=
aBefore
;
parent
-
>
InsertBefore
(
aElement
refNode
aError
)
;
}
void
HTMLSelectElement
:
:
Remove
(
int32_t
aIndex
)
const
{
if
(
aIndex
<
0
)
{
return
;
}
nsCOMPtr
<
nsINode
>
option
=
Item
(
static_cast
<
uint32_t
>
(
aIndex
)
)
;
if
(
!
option
)
{
return
;
}
option
-
>
Remove
(
)
;
}
void
HTMLSelectElement
:
:
GetType
(
nsAString
&
aType
)
{
if
(
HasAttr
(
nsGkAtoms
:
:
multiple
)
)
{
aType
.
AssignLiteral
(
"
select
-
multiple
"
)
;
}
else
{
aType
.
AssignLiteral
(
"
select
-
one
"
)
;
}
}
void
HTMLSelectElement
:
:
SetLength
(
uint32_t
aLength
ErrorResult
&
aRv
)
{
constexpr
uint32_t
kMaxDynamicSelectLength
=
100000
;
uint32_t
curlen
=
Length
(
)
;
if
(
curlen
>
aLength
)
{
for
(
uint32_t
i
=
curlen
;
i
>
aLength
;
-
-
i
)
{
Remove
(
i
-
1
)
;
}
}
else
if
(
aLength
>
curlen
)
{
if
(
aLength
>
kMaxDynamicSelectLength
)
{
nsAutoString
strOptionsLength
;
strOptionsLength
.
AppendInt
(
aLength
)
;
nsAutoString
strLimit
;
strLimit
.
AppendInt
(
kMaxDynamicSelectLength
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
DOM
"
_ns
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
"
SelectOptionsLengthAssignmentWarning
"
{
strOptionsLength
strLimit
}
)
;
return
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nsContentUtils
:
:
QNameChanged
(
mNodeInfo
nsGkAtoms
:
:
option
getter_AddRefs
(
nodeInfo
)
)
;
nsCOMPtr
<
nsINode
>
node
=
NS_NewHTMLOptionElement
(
nodeInfo
.
forget
(
)
)
;
for
(
uint32_t
i
=
curlen
;
i
<
aLength
;
i
+
+
)
{
nsINode
:
:
AppendChild
(
*
node
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
i
+
1
<
aLength
)
{
node
=
node
-
>
CloneNode
(
true
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
node
)
;
}
}
}
}
bool
HTMLSelectElement
:
:
MatchSelectedOptions
(
Element
*
aElement
int32_t
nsAtom
*
void
*
)
{
HTMLOptionElement
*
option
=
HTMLOptionElement
:
:
FromNode
(
aElement
)
;
return
option
&
&
option
-
>
Selected
(
)
;
}
nsIHTMLCollection
*
HTMLSelectElement
:
:
SelectedOptions
(
)
{
if
(
!
mSelectedOptions
)
{
mSelectedOptions
=
new
nsContentList
(
this
MatchSelectedOptions
nullptr
nullptr
true
)
;
}
return
mSelectedOptions
;
}
void
HTMLSelectElement
:
:
SetSelectedIndexInternal
(
int32_t
aIndex
bool
aNotify
)
{
int32_t
oldSelectedIndex
=
mSelectedIndex
;
OptionFlags
mask
{
OptionFlag
:
:
IsSelected
OptionFlag
:
:
ClearAll
OptionFlag
:
:
SetDisabled
}
;
if
(
aNotify
)
{
mask
+
=
OptionFlag
:
:
Notify
;
}
SetOptionsSelectedByIndex
(
aIndex
aIndex
mask
)
;
nsISelectControlFrame
*
selectFrame
=
GetSelectFrame
(
)
;
if
(
selectFrame
)
{
selectFrame
-
>
OnSetSelectedIndex
(
oldSelectedIndex
mSelectedIndex
)
;
}
OnSelectionChanged
(
)
;
}
bool
HTMLSelectElement
:
:
IsOptionSelectedByIndex
(
int32_t
aIndex
)
const
{
HTMLOptionElement
*
option
=
Item
(
static_cast
<
uint32_t
>
(
aIndex
)
)
;
return
option
&
&
option
-
>
Selected
(
)
;
}
void
HTMLSelectElement
:
:
OnOptionSelected
(
nsISelectControlFrame
*
aSelectFrame
int32_t
aIndex
bool
aSelected
bool
aChangeOptionState
bool
aNotify
)
{
if
(
aSelected
&
&
(
aIndex
<
mSelectedIndex
|
|
mSelectedIndex
<
0
)
)
{
mSelectedIndex
=
aIndex
;
OnSelectionChanged
(
)
;
}
else
if
(
!
aSelected
&
&
aIndex
=
=
mSelectedIndex
)
{
FindSelectedIndex
(
aIndex
+
1
aNotify
)
;
}
if
(
aChangeOptionState
)
{
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
static_cast
<
uint32_t
>
(
aIndex
)
)
;
if
(
option
)
{
option
-
>
SetSelectedInternal
(
aSelected
aNotify
)
;
}
}
if
(
aSelectFrame
)
{
aSelectFrame
-
>
OnOptionSelected
(
aIndex
aSelected
)
;
}
UpdateSelectedOptions
(
)
;
UpdateValueMissingValidityState
(
)
;
UpdateValidityElementStates
(
aNotify
)
;
}
void
HTMLSelectElement
:
:
FindSelectedIndex
(
int32_t
aStartIndex
bool
aNotify
)
{
mSelectedIndex
=
-
1
;
uint32_t
len
=
Length
(
)
;
for
(
int32_t
i
=
aStartIndex
;
i
<
int32_t
(
len
)
;
i
+
+
)
{
if
(
IsOptionSelectedByIndex
(
i
)
)
{
mSelectedIndex
=
i
;
break
;
}
}
OnSelectionChanged
(
)
;
}
bool
HTMLSelectElement
:
:
SetOptionsSelectedByIndex
(
int32_t
aStartIndex
int32_t
aEndIndex
OptionFlags
aOptionsMask
)
{
#
if
0
printf
(
"
SetOption
(
%
d
-
%
d
%
c
ClearAll
=
%
c
)
\
n
"
aStartIndex
aEndIndex
(
aOptionsMask
.
contains
(
OptionFlag
:
:
IsSelected
)
?
'
Y
'
:
'
N
'
)
(
aOptionsMask
.
contains
(
OptionFlag
:
:
ClearAll
)
?
'
Y
'
:
'
N
'
)
)
;
#
endif
if
(
!
aOptionsMask
.
contains
(
OptionFlag
:
:
SetDisabled
)
&
&
IsDisabled
(
)
)
{
return
false
;
}
uint32_t
numItems
=
Length
(
)
;
if
(
numItems
=
=
0
)
{
return
false
;
}
bool
isMultiple
=
Multiple
(
)
;
bool
optionsSelected
=
false
;
bool
optionsDeselected
=
false
;
nsISelectControlFrame
*
selectFrame
=
nullptr
;
bool
didGetFrame
=
false
;
AutoWeakFrame
weakSelectFrame
;
if
(
aOptionsMask
.
contains
(
OptionFlag
:
:
IsSelected
)
)
{
if
(
aStartIndex
<
0
|
|
AssertedCast
<
uint32_t
>
(
aStartIndex
)
>
=
numItems
|
|
aEndIndex
<
0
|
|
AssertedCast
<
uint32_t
>
(
aEndIndex
)
>
=
numItems
)
{
aStartIndex
=
-
1
;
aEndIndex
=
-
1
;
}
if
(
!
isMultiple
)
{
aEndIndex
=
aStartIndex
;
}
bool
allDisabled
=
!
aOptionsMask
.
contains
(
OptionFlag
:
:
SetDisabled
)
;
int32_t
previousSelectedIndex
=
mSelectedIndex
;
if
(
aStartIndex
!
=
-
1
)
{
MOZ_ASSERT
(
aStartIndex
>
=
0
)
;
MOZ_ASSERT
(
aEndIndex
>
=
0
)
;
for
(
uint32_t
optIndex
=
AssertedCast
<
uint32_t
>
(
aStartIndex
)
;
optIndex
<
=
AssertedCast
<
uint32_t
>
(
aEndIndex
)
;
optIndex
+
+
)
{
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
optIndex
)
;
if
(
!
aOptionsMask
.
contains
(
OptionFlag
:
:
SetDisabled
)
)
{
if
(
option
&
&
IsOptionDisabled
(
option
)
)
{
continue
;
}
allDisabled
=
false
;
}
if
(
option
&
&
(
aOptionsMask
.
contains
(
OptionFlag
:
:
InsertingOptions
)
|
|
!
option
-
>
Selected
(
)
)
)
{
selectFrame
=
GetSelectFrame
(
)
;
weakSelectFrame
=
do_QueryFrame
(
selectFrame
)
;
didGetFrame
=
true
;
OnOptionSelected
(
selectFrame
optIndex
true
!
option
-
>
Selected
(
)
aOptionsMask
.
contains
(
OptionFlag
:
:
Notify
)
)
;
optionsSelected
=
true
;
}
}
}
if
(
(
(
!
isMultiple
&
&
optionsSelected
)
|
|
(
aOptionsMask
.
contains
(
OptionFlag
:
:
ClearAll
)
&
&
!
allDisabled
)
|
|
aStartIndex
=
=
-
1
)
&
&
previousSelectedIndex
!
=
-
1
)
{
for
(
uint32_t
optIndex
=
AssertedCast
<
uint32_t
>
(
previousSelectedIndex
)
;
optIndex
<
numItems
;
optIndex
+
+
)
{
if
(
static_cast
<
int32_t
>
(
optIndex
)
<
aStartIndex
|
|
static_cast
<
int32_t
>
(
optIndex
)
>
aEndIndex
)
{
HTMLOptionElement
*
option
=
Item
(
optIndex
)
;
if
(
option
&
&
option
-
>
Selected
(
)
)
{
if
(
!
didGetFrame
|
|
(
selectFrame
&
&
!
weakSelectFrame
.
IsAlive
(
)
)
)
{
selectFrame
=
GetSelectFrame
(
)
;
weakSelectFrame
=
do_QueryFrame
(
selectFrame
)
;
didGetFrame
=
true
;
}
OnOptionSelected
(
selectFrame
optIndex
false
true
aOptionsMask
.
contains
(
OptionFlag
:
:
Notify
)
)
;
optionsDeselected
=
true
;
if
(
!
isMultiple
)
{
break
;
}
}
}
}
}
}
else
{
for
(
int32_t
optIndex
=
aStartIndex
;
optIndex
<
=
aEndIndex
;
optIndex
+
+
)
{
HTMLOptionElement
*
option
=
Item
(
optIndex
)
;
if
(
!
aOptionsMask
.
contains
(
OptionFlag
:
:
SetDisabled
)
&
&
IsOptionDisabled
(
option
)
)
{
continue
;
}
if
(
option
&
&
option
-
>
Selected
(
)
)
{
if
(
!
didGetFrame
|
|
(
selectFrame
&
&
!
weakSelectFrame
.
IsAlive
(
)
)
)
{
selectFrame
=
GetSelectFrame
(
)
;
weakSelectFrame
=
do_QueryFrame
(
selectFrame
)
;
didGetFrame
=
true
;
}
OnOptionSelected
(
selectFrame
optIndex
false
true
aOptionsMask
.
contains
(
OptionFlag
:
:
Notify
)
)
;
optionsDeselected
=
true
;
}
}
}
if
(
optionsDeselected
&
&
aStartIndex
!
=
-
1
&
&
!
aOptionsMask
.
contains
(
OptionFlag
:
:
NoReselect
)
)
{
optionsSelected
=
CheckSelectSomething
(
aOptionsMask
.
contains
(
OptionFlag
:
:
Notify
)
)
|
|
optionsSelected
;
}
return
optionsSelected
|
|
optionsDeselected
;
}
NS_IMETHODIMP
HTMLSelectElement
:
:
IsOptionDisabled
(
int32_t
aIndex
bool
*
aIsDisabled
)
{
*
aIsDisabled
=
false
;
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
aIndex
)
;
NS_ENSURE_TRUE
(
option
NS_ERROR_FAILURE
)
;
*
aIsDisabled
=
IsOptionDisabled
(
option
)
;
return
NS_OK
;
}
bool
HTMLSelectElement
:
:
IsOptionDisabled
(
HTMLOptionElement
*
aOption
)
const
{
MOZ_ASSERT
(
aOption
)
;
if
(
aOption
-
>
Disabled
(
)
)
{
return
true
;
}
if
(
mNonOptionChildren
)
{
for
(
nsCOMPtr
<
Element
>
node
=
static_cast
<
nsINode
*
>
(
aOption
)
-
>
GetParentElement
(
)
;
node
;
node
=
node
-
>
GetParentElement
(
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
return
false
;
}
RefPtr
<
HTMLOptGroupElement
>
optGroupElement
=
HTMLOptGroupElement
:
:
FromNode
(
node
)
;
if
(
!
optGroupElement
)
{
return
false
;
}
if
(
optGroupElement
-
>
Disabled
(
)
)
{
return
true
;
}
}
}
return
false
;
}
void
HTMLSelectElement
:
:
GetValue
(
DOMString
&
aValue
)
const
{
int32_t
selectedIndex
=
SelectedIndex
(
)
;
if
(
selectedIndex
<
0
)
{
return
;
}
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
static_cast
<
uint32_t
>
(
selectedIndex
)
)
;
if
(
!
option
)
{
return
;
}
option
-
>
GetValue
(
aValue
)
;
}
void
HTMLSelectElement
:
:
SetValue
(
const
nsAString
&
aValue
)
{
uint32_t
length
=
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
i
)
;
if
(
!
option
)
{
continue
;
}
nsAutoString
optionVal
;
option
-
>
GetValue
(
optionVal
)
;
if
(
optionVal
.
Equals
(
aValue
)
)
{
SetSelectedIndexInternal
(
int32_t
(
i
)
true
)
;
return
;
}
}
SetSelectedIndexInternal
(
-
1
true
)
;
}
int32_t
HTMLSelectElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
bool
HTMLSelectElement
:
:
IsHTMLFocusable
(
IsFocusableFlags
aFlags
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
nsGenericHTMLFormControlElementWithState
:
:
IsHTMLFocusable
(
aFlags
aIsFocusable
aTabIndex
)
)
{
return
true
;
}
*
aIsFocusable
=
!
IsDisabled
(
)
;
return
false
;
}
bool
HTMLSelectElement
:
:
CheckSelectSomething
(
bool
aNotify
)
{
if
(
mIsDoneAddingChildren
)
{
if
(
mSelectedIndex
<
0
&
&
IsCombobox
(
)
)
{
return
SelectSomething
(
aNotify
)
;
}
}
return
false
;
}
bool
HTMLSelectElement
:
:
SelectSomething
(
bool
aNotify
)
{
if
(
!
mIsDoneAddingChildren
)
{
return
false
;
}
uint32_t
count
=
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
bool
disabled
;
nsresult
rv
=
IsOptionDisabled
(
i
&
disabled
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
disabled
)
{
SetSelectedIndexInternal
(
i
aNotify
)
;
UpdateValueMissingValidityState
(
)
;
UpdateValidityElementStates
(
aNotify
)
;
return
true
;
}
}
return
false
;
}
nsresult
HTMLSelectElement
:
:
BindToTree
(
BindContext
&
aContext
nsINode
&
aParent
)
{
nsresult
rv
=
nsGenericHTMLFormControlElementWithState
:
:
BindToTree
(
aContext
aParent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateValidityElementStates
(
false
)
;
return
rv
;
}
void
HTMLSelectElement
:
:
UnbindFromTree
(
UnbindContext
&
aContext
)
{
nsGenericHTMLFormControlElementWithState
:
:
UnbindFromTree
(
aContext
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateValidityElementStates
(
false
)
;
}
void
HTMLSelectElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
disabled
)
{
if
(
aNotify
)
{
mDisabledChanged
=
true
;
}
}
else
if
(
aName
=
=
nsGkAtoms
:
:
multiple
)
{
if
(
!
aValue
&
&
aNotify
&
&
mSelectedIndex
>
=
0
)
{
SetSelectedIndexInternal
(
mSelectedIndex
aNotify
)
;
}
}
}
return
nsGenericHTMLFormControlElementWithState
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
void
HTMLSelectElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
disabled
)
{
UpdateDisabledState
(
aNotify
)
;
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateValidityElementStates
(
aNotify
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
required
)
{
UpdateRequiredState
(
!
!
aValue
aNotify
)
;
UpdateValueMissingValidityState
(
)
;
UpdateValidityElementStates
(
aNotify
)
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
autocomplete
)
{
mAutocompleteAttrState
=
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
;
mAutocompleteInfoState
=
nsContentUtils
:
:
eAutocompleteAttrState_Unknown
;
}
else
if
(
aName
=
=
nsGkAtoms
:
:
multiple
)
{
if
(
!
aValue
&
&
aNotify
)
{
CheckSelectSomething
(
aNotify
)
;
}
}
}
return
nsGenericHTMLFormControlElementWithState
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
void
HTMLSelectElement
:
:
DoneAddingChildren
(
bool
aHaveNotified
)
{
mIsDoneAddingChildren
=
true
;
nsISelectControlFrame
*
selectFrame
=
GetSelectFrame
(
)
;
if
(
mRestoreState
)
{
RestoreStateTo
(
*
mRestoreState
)
;
mRestoreState
=
nullptr
;
}
if
(
selectFrame
)
{
selectFrame
-
>
DoneAddingChildren
(
true
)
;
}
if
(
!
mInhibitStateRestoration
)
{
GenerateStateKey
(
)
;
RestoreFormControlState
(
)
;
}
if
(
!
CheckSelectSomething
(
false
)
)
{
UpdateValueMissingValidityState
(
)
;
UpdateValidityElementStates
(
aHaveNotified
)
;
}
mDefaultSelectionSet
=
true
;
}
bool
HTMLSelectElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
kNameSpaceID_None
=
=
aNamespaceID
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
size
)
{
return
aResult
.
ParsePositiveIntValue
(
aValue
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
autocomplete
)
{
aResult
.
ParseAtomArray
(
aValue
)
;
return
true
;
}
}
return
nsGenericHTMLFormControlElementWithState
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
void
HTMLSelectElement
:
:
MapAttributesIntoRule
(
MappedDeclarationsBuilder
&
aBuilder
)
{
nsGenericHTMLFormControlElementWithState
:
:
MapImageAlignAttributeInto
(
aBuilder
)
;
nsGenericHTMLFormControlElementWithState
:
:
MapCommonAttributesInto
(
aBuilder
)
;
}
nsChangeHint
HTMLSelectElement
:
:
GetAttributeChangeHint
(
const
nsAtom
*
aAttribute
int32_t
aModType
)
const
{
nsChangeHint
retval
=
nsGenericHTMLFormControlElementWithState
:
:
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
multiple
|
|
aAttribute
=
=
nsGkAtoms
:
:
size
)
{
retval
|
=
nsChangeHint_ReconstructFrame
;
}
return
retval
;
}
NS_IMETHODIMP_
(
bool
)
HTMLSelectElement
:
:
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
{
static
const
MappedAttributeEntry
*
const
map
[
]
=
{
sCommonAttributeMap
sImageAlignAttributeMap
}
;
return
FindAttributeDependence
(
aAttribute
map
)
;
}
nsMapRuleToAttributesFunc
HTMLSelectElement
:
:
GetAttributeMappingFunction
(
)
const
{
return
&
MapAttributesIntoRule
;
}
bool
HTMLSelectElement
:
:
IsDisabledForEvents
(
WidgetEvent
*
aEvent
)
{
return
IsElementDisabledForEvents
(
aEvent
GetPrimaryFrame
(
)
)
;
}
void
HTMLSelectElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
false
;
if
(
IsDisabledForEvents
(
aVisitor
.
mEvent
)
)
{
return
;
}
nsGenericHTMLFormControlElementWithState
:
:
GetEventTargetParent
(
aVisitor
)
;
}
void
HTMLSelectElement
:
:
UpdateValidityElementStates
(
bool
aNotify
)
{
AutoStateChangeNotifier
notifier
(
*
this
aNotify
)
;
RemoveStatesSilently
(
ElementState
:
:
VALIDITY_STATES
)
;
if
(
!
IsCandidateForConstraintValidation
(
)
)
{
return
;
}
ElementState
state
;
if
(
IsValid
(
)
)
{
state
|
=
ElementState
:
:
VALID
;
if
(
mUserInteracted
)
{
state
|
=
ElementState
:
:
USER_VALID
;
}
}
else
{
state
|
=
ElementState
:
:
INVALID
;
if
(
mUserInteracted
)
{
state
|
=
ElementState
:
:
USER_INVALID
;
}
}
AddStatesSilently
(
state
)
;
}
void
HTMLSelectElement
:
:
SaveState
(
)
{
PresState
*
presState
=
GetPrimaryPresState
(
)
;
if
(
!
presState
)
{
return
;
}
SelectContentData
state
;
uint32_t
len
=
Length
(
)
;
for
(
uint32_t
optIndex
=
0
;
optIndex
<
len
;
optIndex
+
+
)
{
HTMLOptionElement
*
option
=
Item
(
optIndex
)
;
if
(
option
&
&
option
-
>
Selected
(
)
)
{
nsAutoString
value
;
option
-
>
GetValue
(
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
state
.
indices
(
)
.
AppendElement
(
optIndex
)
;
}
else
{
state
.
values
(
)
.
AppendElement
(
std
:
:
move
(
value
)
)
;
}
}
}
presState
-
>
contentData
(
)
=
std
:
:
move
(
state
)
;
if
(
mDisabledChanged
)
{
presState
-
>
disabled
(
)
=
HasAttr
(
nsGkAtoms
:
:
disabled
)
;
presState
-
>
disabledSet
(
)
=
true
;
}
}
bool
HTMLSelectElement
:
:
RestoreState
(
PresState
*
aState
)
{
const
PresContentData
&
state
=
aState
-
>
contentData
(
)
;
if
(
state
.
type
(
)
=
=
PresContentData
:
:
TSelectContentData
)
{
RestoreStateTo
(
state
.
get_SelectContentData
(
)
)
;
DispatchContentReset
(
)
;
}
if
(
aState
-
>
disabledSet
(
)
&
&
!
aState
-
>
disabled
(
)
)
{
SetDisabled
(
false
IgnoreErrors
(
)
)
;
}
return
false
;
}
void
HTMLSelectElement
:
:
RestoreStateTo
(
const
SelectContentData
&
aNewSelected
)
{
if
(
!
mIsDoneAddingChildren
)
{
mRestoreState
=
MakeUnique
<
SelectContentData
>
(
aNewSelected
)
;
return
;
}
uint32_t
len
=
Length
(
)
;
OptionFlags
mask
{
OptionFlag
:
:
IsSelected
OptionFlag
:
:
ClearAll
OptionFlag
:
:
SetDisabled
OptionFlag
:
:
Notify
}
;
SetOptionsSelectedByIndex
(
-
1
-
1
mask
)
;
for
(
uint32_t
idx
:
aNewSelected
.
indices
(
)
)
{
if
(
idx
<
len
)
{
SetOptionsSelectedByIndex
(
idx
idx
{
OptionFlag
:
:
IsSelected
OptionFlag
:
:
SetDisabled
OptionFlag
:
:
Notify
}
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
HTMLOptionElement
*
option
=
Item
(
i
)
;
if
(
option
)
{
nsAutoString
value
;
option
-
>
GetValue
(
value
)
;
if
(
aNewSelected
.
values
(
)
.
Contains
(
value
)
)
{
SetOptionsSelectedByIndex
(
i
i
{
OptionFlag
:
:
IsSelected
OptionFlag
:
:
SetDisabled
OptionFlag
:
:
Notify
}
)
;
}
}
}
}
NS_IMETHODIMP
HTMLSelectElement
:
:
Reset
(
)
{
uint32_t
numSelected
=
0
;
uint32_t
numOptions
=
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numOptions
;
i
+
+
)
{
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
i
)
;
if
(
option
)
{
OptionFlags
mask
=
{
OptionFlag
:
:
SetDisabled
OptionFlag
:
:
Notify
OptionFlag
:
:
NoReselect
}
;
if
(
option
-
>
DefaultSelected
(
)
)
{
mask
+
=
OptionFlag
:
:
IsSelected
;
numSelected
+
+
;
}
SetOptionsSelectedByIndex
(
i
i
mask
)
;
option
-
>
SetSelectedChanged
(
false
)
;
}
}
if
(
numSelected
=
=
0
&
&
IsCombobox
(
)
)
{
SelectSomething
(
true
)
;
}
OnSelectionChanged
(
)
;
SetUserInteracted
(
false
)
;
DispatchContentReset
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
HTMLSelectElement
:
:
SubmitNamesValues
(
FormData
*
aFormData
)
{
nsAutoString
name
;
GetAttr
(
nsGkAtoms
:
:
name
name
)
;
if
(
name
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
uint32_t
len
=
Length
(
)
;
for
(
uint32_t
optIndex
=
0
;
optIndex
<
len
;
optIndex
+
+
)
{
HTMLOptionElement
*
option
=
Item
(
optIndex
)
;
if
(
!
option
|
|
IsOptionDisabled
(
option
)
)
{
continue
;
}
if
(
!
option
-
>
Selected
(
)
)
{
continue
;
}
nsString
value
;
option
-
>
GetValue
(
value
)
;
aFormData
-
>
AddNameValuePair
(
name
value
)
;
}
return
NS_OK
;
}
void
HTMLSelectElement
:
:
DispatchContentReset
(
)
{
if
(
nsListControlFrame
*
listFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
)
{
listFrame
-
>
OnContentReset
(
)
;
}
}
static
void
AddOptions
(
nsIContent
*
aRoot
HTMLOptionsCollection
*
aArray
)
{
for
(
nsIContent
*
child
=
aRoot
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
HTMLOptionElement
*
opt
=
HTMLOptionElement
:
:
FromNode
(
child
)
;
if
(
opt
)
{
aArray
-
>
AppendOption
(
opt
)
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
)
{
for
(
nsIContent
*
grandchild
=
child
-
>
GetFirstChild
(
)
;
grandchild
;
grandchild
=
grandchild
-
>
GetNextSibling
(
)
)
{
opt
=
HTMLOptionElement
:
:
FromNode
(
grandchild
)
;
if
(
opt
)
{
aArray
-
>
AppendOption
(
opt
)
;
}
}
}
}
}
void
HTMLSelectElement
:
:
RebuildOptionsArray
(
bool
aNotify
)
{
mOptions
-
>
Clear
(
)
;
AddOptions
(
this
mOptions
)
;
FindSelectedIndex
(
0
aNotify
)
;
}
bool
HTMLSelectElement
:
:
IsValueMissing
(
)
const
{
if
(
!
Required
(
)
)
{
return
false
;
}
uint32_t
length
=
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
RefPtr
<
HTMLOptionElement
>
option
=
Item
(
i
)
;
if
(
i
=
=
0
&
&
!
Multiple
(
)
&
&
Size
(
)
<
=
1
&
&
option
-
>
GetParent
(
)
=
=
this
)
{
nsAutoString
value
;
option
-
>
GetValue
(
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
continue
;
}
}
if
(
!
option
-
>
Selected
(
)
)
{
continue
;
}
return
false
;
}
return
true
;
}
void
HTMLSelectElement
:
:
UpdateValueMissingValidityState
(
)
{
SetValidityState
(
VALIDITY_STATE_VALUE_MISSING
IsValueMissing
(
)
)
;
}
nsresult
HTMLSelectElement
:
:
GetValidationMessage
(
nsAString
&
aValidationMessage
ValidityStateType
aType
)
{
switch
(
aType
)
{
case
VALIDITY_STATE_VALUE_MISSING
:
{
nsAutoString
message
;
nsresult
rv
=
nsContentUtils
:
:
GetMaybeLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
FormValidationSelectMissing
"
OwnerDoc
(
)
message
)
;
aValidationMessage
=
message
;
return
rv
;
}
default
:
{
return
ConstraintValidation
:
:
GetValidationMessage
(
aValidationMessage
aType
)
;
}
}
}
#
ifdef
DEBUG
void
HTMLSelectElement
:
:
VerifyOptionsArray
(
)
{
int32_t
index
=
0
;
for
(
nsIContent
*
child
=
nsINode
:
:
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
HTMLOptionElement
*
opt
=
HTMLOptionElement
:
:
FromNode
(
child
)
;
if
(
opt
)
{
NS_ASSERTION
(
opt
=
=
mOptions
-
>
ItemAsOption
(
index
+
+
)
"
Options
collection
broken
"
)
;
}
else
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
)
{
for
(
nsIContent
*
grandchild
=
child
-
>
GetFirstChild
(
)
;
grandchild
;
grandchild
=
grandchild
-
>
GetNextSibling
(
)
)
{
opt
=
HTMLOptionElement
:
:
FromNode
(
grandchild
)
;
if
(
opt
)
{
NS_ASSERTION
(
opt
=
=
mOptions
-
>
ItemAsOption
(
index
+
+
)
"
Options
collection
broken
"
)
;
}
}
}
}
}
#
endif
void
HTMLSelectElement
:
:
UpdateBarredFromConstraintValidation
(
)
{
SetBarredFromConstraintValidation
(
HasFlag
(
ELEMENT_IS_DATALIST_OR_HAS_DATALIST_ANCESTOR
)
|
|
IsDisabled
(
)
)
;
}
void
HTMLSelectElement
:
:
FieldSetDisabledChanged
(
bool
aNotify
)
{
nsGenericHTMLFormControlElementWithState
:
:
FieldSetDisabledChanged
(
aNotify
)
;
UpdateValueMissingValidityState
(
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateValidityElementStates
(
aNotify
)
;
}
void
HTMLSelectElement
:
:
OnSelectionChanged
(
)
{
if
(
!
mDefaultSelectionSet
)
{
return
;
}
if
(
State
(
)
.
HasState
(
ElementState
:
:
AUTOFILL
)
)
{
RemoveStates
(
ElementState
:
:
AUTOFILL
|
ElementState
:
:
AUTOFILL_PREVIEW
)
;
}
UpdateSelectedOptions
(
)
;
}
void
HTMLSelectElement
:
:
UpdateSelectedOptions
(
)
{
if
(
mSelectedOptions
)
{
mSelectedOptions
-
>
SetDirty
(
)
;
}
}
void
HTMLSelectElement
:
:
SetUserInteracted
(
bool
aInteracted
)
{
if
(
mUserInteracted
=
=
aInteracted
)
{
return
;
}
mUserInteracted
=
aInteracted
;
UpdateValidityElementStates
(
true
)
;
}
void
HTMLSelectElement
:
:
SetPreviewValue
(
const
nsAString
&
aValue
)
{
mPreviewValue
=
aValue
;
nsContentUtils
:
:
RemoveNewlines
(
mPreviewValue
)
;
nsComboboxControlFrame
*
comboFrame
=
do_QueryFrame
(
GetPrimaryFrame
(
)
)
;
if
(
comboFrame
)
{
comboFrame
-
>
RedisplaySelectedText
(
)
;
}
}
void
HTMLSelectElement
:
:
UserFinishedInteracting
(
bool
aChanged
)
{
SetUserInteracted
(
true
)
;
if
(
!
aChanged
)
{
return
;
}
DebugOnly
<
nsresult
>
rvIgnored
=
nsContentUtils
:
:
DispatchInputEvent
(
this
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
Failed
to
dispatch
input
event
"
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
OwnerDoc
(
)
this
u
"
change
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
JSObject
*
HTMLSelectElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLSelectElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
