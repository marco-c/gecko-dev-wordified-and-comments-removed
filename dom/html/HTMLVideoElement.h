#
ifndef
mozilla_dom_HTMLVideoElement_h
#
define
mozilla_dom_HTMLVideoElement_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
mozilla
/
StaticPrefs_media
.
h
"
namespace
mozilla
{
class
FrameStatistics
;
namespace
dom
{
class
WakeLock
;
class
VideoPlaybackQuality
;
class
HTMLVideoElement
final
:
public
HTMLMediaElement
{
class
SecondaryVideoOutput
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLVideoElement
HTMLMediaElement
)
typedef
mozilla
:
:
dom
:
:
NodeInfo
NodeInfo
;
explicit
HTMLVideoElement
(
already_AddRefed
<
NodeInfo
>
&
&
aNodeInfo
)
;
NS_IMPL_FROMNODE_HTML_WITH_TAG
(
HTMLVideoElement
video
)
using
HTMLMediaElement
:
:
GetPaused
;
void
Invalidate
(
bool
aImageSizeChanged
Maybe
<
nsIntSize
>
&
aNewIntrinsicSize
bool
aForceInvalidate
)
override
;
virtual
bool
IsVideo
(
)
const
override
{
return
true
;
}
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
override
;
virtual
nsMapRuleToAttributesFunc
GetAttributeMappingFunction
(
)
const
override
;
virtual
nsresult
Clone
(
NodeInfo
*
nsINode
*
*
aResult
)
const
override
;
virtual
void
UnbindFromTree
(
bool
aNullParent
=
true
)
override
;
nsresult
GetVideoSize
(
nsIntSize
*
size
)
;
virtual
void
UpdateMediaSize
(
const
nsIntSize
&
aSize
)
override
;
virtual
nsresult
SetAcceptHeader
(
nsIHttpChannel
*
aChannel
)
override
;
virtual
bool
IsInteractiveHTMLContent
(
bool
aIgnoreTabindex
)
const
override
;
uint32_t
Width
(
)
const
{
return
GetDimensionAttrAsUnsignedInt
(
nsGkAtoms
:
:
width
0
)
;
}
void
SetWidth
(
uint32_t
aValue
ErrorResult
&
aRv
)
{
SetUnsignedIntAttr
(
nsGkAtoms
:
:
width
aValue
0
aRv
)
;
}
uint32_t
Height
(
)
const
{
return
GetDimensionAttrAsUnsignedInt
(
nsGkAtoms
:
:
height
0
)
;
}
void
SetHeight
(
uint32_t
aValue
ErrorResult
&
aRv
)
{
SetUnsignedIntAttr
(
nsGkAtoms
:
:
height
aValue
0
aRv
)
;
}
uint32_t
VideoWidth
(
)
const
{
if
(
mMediaInfo
.
HasVideo
(
)
)
{
if
(
mMediaInfo
.
mVideo
.
mRotation
=
=
VideoInfo
:
:
Rotation
:
:
kDegree_90
|
|
mMediaInfo
.
mVideo
.
mRotation
=
=
VideoInfo
:
:
Rotation
:
:
kDegree_270
)
{
return
mMediaInfo
.
mVideo
.
mDisplay
.
height
;
}
return
mMediaInfo
.
mVideo
.
mDisplay
.
width
;
}
return
0
;
}
uint32_t
VideoHeight
(
)
const
{
if
(
mMediaInfo
.
HasVideo
(
)
)
{
if
(
mMediaInfo
.
mVideo
.
mRotation
=
=
VideoInfo
:
:
Rotation
:
:
kDegree_90
|
|
mMediaInfo
.
mVideo
.
mRotation
=
=
VideoInfo
:
:
Rotation
:
:
kDegree_270
)
{
return
mMediaInfo
.
mVideo
.
mDisplay
.
width
;
}
return
mMediaInfo
.
mVideo
.
mDisplay
.
height
;
}
return
0
;
}
VideoInfo
:
:
Rotation
RotationDegrees
(
)
const
{
return
mMediaInfo
.
mVideo
.
mRotation
;
}
bool
HasAlpha
(
)
const
{
return
mMediaInfo
.
mVideo
.
HasAlpha
(
)
;
}
void
GetPoster
(
nsAString
&
aValue
)
{
GetURIAttr
(
nsGkAtoms
:
:
poster
nullptr
aValue
)
;
}
void
SetPoster
(
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
poster
aValue
aRv
)
;
}
uint32_t
MozParsedFrames
(
)
const
;
uint32_t
MozDecodedFrames
(
)
const
;
uint32_t
MozPresentedFrames
(
)
const
;
uint32_t
MozPaintedFrames
(
)
;
double
MozFrameDelay
(
)
;
bool
MozHasAudio
(
)
const
;
FrameStatistics
*
GetFrameStatistics
(
)
;
already_AddRefed
<
VideoPlaybackQuality
>
GetVideoPlaybackQuality
(
)
;
bool
MozOrientationLockEnabled
(
)
const
{
return
StaticPrefs
:
:
media_videocontrols_lock_video_orientation
(
)
;
}
bool
MozIsOrientationLocked
(
)
const
{
return
mIsOrientationLocked
;
}
void
SetMozIsOrientationLocked
(
bool
aLock
)
{
mIsOrientationLocked
=
aLock
;
}
already_AddRefed
<
Promise
>
CloneElementVisually
(
HTMLVideoElement
&
aTarget
ErrorResult
&
rv
)
;
void
StopCloningElementVisually
(
)
;
bool
IsCloningElementVisually
(
)
const
{
return
!
!
mVisualCloneTarget
;
}
void
OnSecondaryVideoContainerInstalled
(
const
RefPtr
<
VideoFrameContainer
>
&
aSecondaryContainer
)
override
;
protected
:
virtual
~
HTMLVideoElement
(
)
;
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
WakeLockRelease
(
)
override
;
void
UpdateWakeLock
(
)
override
;
bool
ShouldCreateVideoWakeLock
(
)
const
;
void
CreateVideoWakeLockIfNeeded
(
)
;
void
ReleaseVideoWakeLockIfExists
(
)
;
RefPtr
<
WakeLock
>
mScreenWakeLock
;
bool
mIsOrientationLocked
;
private
:
bool
SetVisualCloneTarget
(
RefPtr
<
HTMLVideoElement
>
aVisualCloneTarget
RefPtr
<
Promise
>
aVisualCloneTargetPromise
=
nullptr
)
;
bool
SetVisualCloneSource
(
RefPtr
<
HTMLVideoElement
>
aVisualCloneSource
)
;
RefPtr
<
HTMLVideoElement
>
mVisualCloneTarget
;
RefPtr
<
Promise
>
mVisualCloneTargetPromise
;
RefPtr
<
SecondaryVideoOutput
>
mSecondaryVideoOutput
;
RefPtr
<
HTMLVideoElement
>
mVisualCloneSource
;
static
void
MapAttributesIntoRule
(
const
nsMappedAttributes
*
aAttributes
MappedDeclarations
&
)
;
static
bool
IsVideoStatsEnabled
(
)
;
double
TotalPlayTime
(
)
const
;
virtual
void
MaybeBeginCloningVisually
(
)
override
;
void
EndCloningVisually
(
)
;
}
;
}
}
#
endif
