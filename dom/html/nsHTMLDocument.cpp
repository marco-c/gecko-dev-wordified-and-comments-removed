#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAllCollection
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIHTMLContentSink
.
h
"
#
include
"
nsIXMLContentSink
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIPrivateBrowsingChannel
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIWebShellServices
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsParserCIID
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIWyciwygChannel
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
mozilla
/
dom
/
FallbackEncoding
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsIEditorStyleSheets
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsHtml5Module
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsHtml5TreeOpExecutor
.
h
"
#
include
"
nsHtml5Parser
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsIImageDocument
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDocumentBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsLayoutStylesheetCache
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCommandParams
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
NS_MAX_DOCUMENT_WRITE_DEPTH
20
#
include
"
prtime
.
h
"
static
NS_DEFINE_CID
(
kCParserCID
NS_PARSER_CID
)
;
uint32_t
nsHTMLDocument
:
:
gWyciwygSessionCnt
=
0
;
static
bool
ConvertToMidasInternalCommand
(
const
nsAString
&
inCommandID
const
nsAString
&
inParam
nsACString
&
outCommandID
nsACString
&
outParam
bool
&
isBoolean
bool
&
boolValue
)
;
static
bool
ConvertToMidasInternalCommand
(
const
nsAString
&
inCommandID
nsACString
&
outCommandID
)
;
static
bool
IsAsciiCompatible
(
const
Encoding
*
aEncoding
)
{
return
aEncoding
-
>
IsAsciiCompatible
(
)
|
|
aEncoding
=
=
ISO_2022_JP_ENCODING
;
}
nsresult
NS_NewHTMLDocument
(
nsIDocument
*
*
aInstancePtrResult
bool
aLoadedAsData
)
{
RefPtr
<
nsHTMLDocument
>
doc
=
new
nsHTMLDocument
(
)
;
nsresult
rv
=
doc
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aInstancePtrResult
=
nullptr
;
return
rv
;
}
doc
-
>
SetLoadedAsData
(
aLoadedAsData
)
;
doc
.
forget
(
aInstancePtrResult
)
;
return
NS_OK
;
}
nsHTMLDocument
:
:
nsHTMLDocument
(
)
:
nsDocument
(
"
text
/
html
"
)
mContentListHolder
(
nullptr
)
mNumForms
(
0
)
mWriteLevel
(
0
)
mLoadFlags
(
0
)
mTooDeepWriteRecursion
(
false
)
mDisableDocWrite
(
false
)
mWarnedWidthHeight
(
false
)
mContentEditableCount
(
0
)
mEditingState
(
EditingState
:
:
eOff
)
mDisableCookieAccess
(
false
)
mPendingMaybeEditingStateChanged
(
false
)
{
mType
=
eHTML
;
mDefaultElementType
=
kNameSpaceID_XHTML
;
mCompatMode
=
eCompatibility_NavQuirks
;
}
nsHTMLDocument
:
:
~
nsHTMLDocument
(
)
{
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsHTMLDocument
nsDocument
mAll
mWyciwygChannel
mMidasCommandManager
)
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
nsHTMLDocument
nsDocument
nsIHTMLDocument
)
JSObject
*
nsHTMLDocument
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLDocument_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsresult
nsHTMLDocument
:
:
Init
(
)
{
nsresult
rv
=
nsDocument
:
:
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CSSLoader
(
)
-
>
SetCompatibilityMode
(
mCompatMode
)
;
return
NS_OK
;
}
void
nsHTMLDocument
:
:
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
{
nsDocument
:
:
Reset
(
aChannel
aLoadGroup
)
;
if
(
aChannel
)
{
aChannel
-
>
GetLoadFlags
(
&
mLoadFlags
)
;
}
}
void
nsHTMLDocument
:
:
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
)
{
mLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
nsDocument
:
:
ResetToURI
(
aURI
aLoadGroup
aPrincipal
)
;
mImages
=
nullptr
;
mApplets
=
nullptr
;
mEmbeds
=
nullptr
;
mLinks
=
nullptr
;
mAnchors
=
nullptr
;
mScripts
=
nullptr
;
mForms
=
nullptr
;
NS_ASSERTION
(
!
mWyciwygChannel
"
nsHTMLDocument
:
:
Reset
(
)
-
Wyciwyg
Channel
still
exists
!
"
)
;
mWyciwygChannel
=
nullptr
;
SetContentTypeInternal
(
nsDependentCString
(
"
text
/
html
"
)
)
;
}
void
nsHTMLDocument
:
:
TryHintCharset
(
nsIContentViewer
*
aCv
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
aCv
)
{
int32_t
requestCharsetSource
;
nsresult
rv
=
aCv
-
>
GetHintCharacterSetSource
(
&
requestCharsetSource
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
kCharsetUninitialized
!
=
requestCharsetSource
)
{
auto
requestCharset
=
aCv
-
>
GetHintCharset
(
)
;
aCv
-
>
SetHintCharacterSetSource
(
(
int32_t
)
(
kCharsetUninitialized
)
)
;
if
(
requestCharsetSource
<
=
aCharsetSource
)
return
;
if
(
requestCharset
&
&
IsAsciiCompatible
(
requestCharset
)
)
{
aCharsetSource
=
requestCharsetSource
;
aEncoding
=
WrapNotNull
(
requestCharset
)
;
}
}
}
}
void
nsHTMLDocument
:
:
TryUserForcedCharset
(
nsIContentViewer
*
aCv
nsIDocShell
*
aDocShell
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
kCharsetFromUserForced
<
=
aCharsetSource
)
return
;
if
(
WillIgnoreCharsetOverride
(
)
|
|
!
IsAsciiCompatible
(
aEncoding
)
)
{
return
;
}
const
Encoding
*
forceCharsetFromDocShell
=
nullptr
;
if
(
aCv
)
{
forceCharsetFromDocShell
=
aCv
-
>
GetForceCharset
(
)
;
}
if
(
forceCharsetFromDocShell
&
&
IsAsciiCompatible
(
forceCharsetFromDocShell
)
)
{
aEncoding
=
WrapNotNull
(
forceCharsetFromDocShell
)
;
aCharsetSource
=
kCharsetFromUserForced
;
return
;
}
if
(
aDocShell
)
{
auto
encoding
=
nsDocShell
:
:
Cast
(
aDocShell
)
-
>
GetForcedCharset
(
)
;
if
(
encoding
)
{
if
(
!
IsAsciiCompatible
(
encoding
)
)
{
return
;
}
aEncoding
=
WrapNotNull
(
encoding
)
;
aCharsetSource
=
kCharsetFromUserForced
;
aDocShell
-
>
SetForcedCharset
(
NS_LITERAL_CSTRING
(
"
"
)
)
;
}
}
}
void
nsHTMLDocument
:
:
TryCacheCharset
(
nsICachingChannel
*
aCachingChannel
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
nsresult
rv
;
if
(
kCharsetFromCache
<
=
aCharsetSource
)
{
return
;
}
nsCString
cachedCharset
;
rv
=
aCachingChannel
-
>
GetCacheTokenCachedCharset
(
cachedCharset
)
;
if
(
NS_FAILED
(
rv
)
|
|
cachedCharset
.
IsEmpty
(
)
)
{
return
;
}
const
Encoding
*
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
cachedCharset
)
;
if
(
!
encoding
)
{
return
;
}
if
(
!
encoding
-
>
IsAsciiCompatible
(
)
&
&
encoding
!
=
ISO_2022_JP_ENCODING
)
{
return
;
}
aEncoding
=
WrapNotNull
(
encoding
)
;
aCharsetSource
=
kCharsetFromCache
;
}
void
nsHTMLDocument
:
:
TryParentCharset
(
nsIDocShell
*
aDocShell
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
!
aDocShell
)
{
return
;
}
if
(
aCharsetSource
>
=
kCharsetFromParentForced
)
{
return
;
}
int32_t
parentSource
;
const
Encoding
*
parentCharset
;
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
;
aDocShell
-
>
GetParentCharset
(
parentCharset
&
parentSource
getter_AddRefs
(
parentPrincipal
)
)
;
if
(
!
parentCharset
)
{
return
;
}
if
(
kCharsetFromParentForced
=
=
parentSource
|
|
kCharsetFromUserForced
=
=
parentSource
)
{
if
(
WillIgnoreCharsetOverride
(
)
|
|
!
IsAsciiCompatible
(
aEncoding
)
|
|
!
IsAsciiCompatible
(
parentCharset
)
)
{
return
;
}
aEncoding
=
WrapNotNull
(
parentCharset
)
;
aCharsetSource
=
kCharsetFromParentForced
;
return
;
}
if
(
aCharsetSource
>
=
kCharsetFromParentFrame
)
{
return
;
}
if
(
kCharsetFromCache
<
=
parentSource
)
{
if
(
!
NodePrincipal
(
)
-
>
Equals
(
parentPrincipal
)
|
|
!
IsAsciiCompatible
(
parentCharset
)
)
{
return
;
}
aEncoding
=
WrapNotNull
(
parentCharset
)
;
aCharsetSource
=
kCharsetFromParentFrame
;
}
}
void
nsHTMLDocument
:
:
TryTLD
(
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
aCharsetSource
>
=
kCharsetFromTopLevelDomain
)
{
return
;
}
if
(
!
FallbackEncoding
:
:
sGuessFallbackFromTopLevelDomain
)
{
return
;
}
if
(
!
mDocumentURI
)
{
return
;
}
nsAutoCString
host
;
mDocumentURI
-
>
GetAsciiHost
(
host
)
;
if
(
host
.
IsEmpty
(
)
)
{
return
;
}
if
(
host
.
Last
(
)
=
=
'
.
'
)
{
host
.
SetLength
(
host
.
Length
(
)
-
1
)
;
if
(
host
.
IsEmpty
(
)
)
{
return
;
}
}
if
(
host
.
Last
(
)
=
=
'
.
'
)
{
return
;
}
int32_t
index
=
host
.
RFindChar
(
'
.
'
)
;
if
(
index
=
=
kNotFound
)
{
return
;
}
nsAutoCString
tld
;
ToLowerCase
(
Substring
(
host
index
+
1
host
.
Length
(
)
-
(
index
+
1
)
)
tld
)
;
if
(
!
FallbackEncoding
:
:
IsParticipatingTopLevelDomain
(
tld
)
)
{
return
;
}
bool
seenNonDigit
=
false
;
for
(
size_t
i
=
0
;
i
<
tld
.
Length
(
)
;
+
+
i
)
{
char
c
=
tld
.
CharAt
(
i
)
;
if
(
c
<
'
0
'
|
|
c
>
'
9
'
)
{
seenNonDigit
=
true
;
break
;
}
}
if
(
!
seenNonDigit
)
{
return
;
}
aCharsetSource
=
kCharsetFromTopLevelDomain
;
aEncoding
=
FallbackEncoding
:
:
FromTopLevelDomain
(
tld
)
;
}
void
nsHTMLDocument
:
:
TryFallback
(
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
kCharsetFromFallback
<
=
aCharsetSource
)
return
;
aCharsetSource
=
kCharsetFromFallback
;
bool
isFile
=
false
;
if
(
FallbackEncoding
:
:
sFallbackToUTF8ForFile
&
&
mDocumentURI
&
&
NS_SUCCEEDED
(
mDocumentURI
-
>
SchemeIs
(
"
file
"
&
isFile
)
)
&
&
isFile
)
{
aEncoding
=
UTF_8_ENCODING
;
return
;
}
aEncoding
=
FallbackEncoding
:
:
FromLocale
(
)
;
}
void
nsHTMLDocument
:
:
SetDocumentCharacterSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
nsDocument
:
:
SetDocumentCharacterSet
(
aEncoding
)
;
nsCOMPtr
<
nsIWyciwygChannel
>
wyciwygChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
wyciwygChannel
)
{
nsAutoCString
charset
;
aEncoding
-
>
Name
(
charset
)
;
wyciwygChannel
-
>
SetCharsetAndSource
(
GetDocumentCharacterSetSource
(
)
charset
)
;
}
}
nsresult
nsHTMLDocument
:
:
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
)
{
if
(
!
aCommand
)
{
MOZ_ASSERT
(
false
"
Command
is
mandatory
"
)
;
return
NS_ERROR_INVALID_POINTER
;
}
if
(
aSink
)
{
MOZ_ASSERT
(
false
"
Got
a
sink
override
.
Should
not
happen
for
HTML
doc
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mType
!
=
eHTML
)
{
MOZ_ASSERT
(
mType
=
=
eXHTML
)
;
MOZ_ASSERT
(
false
"
Must
not
set
HTML
doc
to
XHTML
mode
before
load
start
.
"
)
;
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
nsAutoCString
contentType
;
aChannel
-
>
GetContentType
(
contentType
)
;
bool
view
=
!
strcmp
(
aCommand
"
view
"
)
|
|
!
strcmp
(
aCommand
"
external
-
resource
"
)
;
bool
viewSource
=
!
strcmp
(
aCommand
"
view
-
source
"
)
;
bool
asData
=
!
strcmp
(
aCommand
kLoadAsData
)
;
if
(
!
(
view
|
|
viewSource
|
|
asData
)
)
{
MOZ_ASSERT
(
false
"
Bad
parser
command
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
bool
html
=
contentType
.
EqualsLiteral
(
TEXT_HTML
)
;
bool
xhtml
=
!
html
&
&
(
contentType
.
EqualsLiteral
(
APPLICATION_XHTML_XML
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_WAPXHTML_XML
)
)
;
bool
plainText
=
!
html
&
&
!
xhtml
&
&
nsContentUtils
:
:
IsPlainTextType
(
contentType
)
;
if
(
!
(
html
|
|
xhtml
|
|
plainText
|
|
viewSource
)
)
{
MOZ_ASSERT
(
false
"
Channel
with
bad
content
type
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
bool
forceUtf8
=
plainText
&
&
nsContentUtils
:
:
IsUtf8OnlyPlainTextType
(
contentType
)
;
bool
loadAsHtml5
=
true
;
if
(
!
viewSource
&
&
xhtml
)
{
mType
=
eXHTML
;
mCompatMode
=
eCompatibility_FullStandards
;
loadAsHtml5
=
false
;
}
if
(
loadAsHtml5
&
&
view
)
{
nsCOMPtr
<
nsIURI
>
uri
;
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
;
bool
isAbout
=
false
;
if
(
uri
&
&
NS_SUCCEEDED
(
uri
-
>
SchemeIs
(
"
about
"
&
isAbout
)
)
&
&
isAbout
)
{
if
(
uri
-
>
GetSpecOrDefault
(
)
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
loadAsHtml5
=
false
;
}
}
}
CSSLoader
(
)
-
>
SetCompatibilityMode
(
mCompatMode
)
;
nsresult
rv
=
nsDocument
:
:
StartDocumentLoad
(
aCommand
aChannel
aLoadGroup
aContainer
aDocListener
aReset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
mSecurityInfo
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsICachingChannel
>
cachingChan
=
do_QueryInterface
(
aChannel
)
;
if
(
loadAsHtml5
)
{
mParser
=
nsHtml5Module
:
:
NewHtml5Parser
(
)
;
if
(
plainText
)
{
if
(
viewSource
)
{
mParser
-
>
MarkAsNotScriptCreated
(
"
view
-
source
-
plain
"
)
;
}
else
{
mParser
-
>
MarkAsNotScriptCreated
(
"
plain
-
text
"
)
;
}
}
else
if
(
viewSource
&
&
!
html
)
{
mParser
-
>
MarkAsNotScriptCreated
(
"
view
-
source
-
xml
"
)
;
}
else
{
mParser
-
>
MarkAsNotScriptCreated
(
aCommand
)
;
}
}
else
{
mParser
=
do_CreateInstance
(
kCParserCID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
aContainer
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
if
(
docShell
)
{
docShell
-
>
GetSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
;
}
nsCOMPtr
<
nsIDocShell
>
parent
(
do_QueryInterface
(
parentAsItem
)
)
;
nsCOMPtr
<
nsIContentViewer
>
parentContentViewer
;
if
(
parent
)
{
rv
=
parent
-
>
GetContentViewer
(
getter_AddRefs
(
parentContentViewer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
if
(
docShell
)
{
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
}
if
(
!
cv
)
{
cv
=
parentContentViewer
.
forget
(
)
;
}
nsAutoCString
urlSpec
;
uri
-
>
GetSpec
(
urlSpec
)
;
#
ifdef
DEBUG_charset
printf
(
"
Determining
charset
for
%
s
\
n
"
urlSpec
.
get
(
)
)
;
#
endif
int32_t
charsetSource
;
auto
encoding
=
UTF_8_ENCODING
;
int32_t
parserCharsetSource
;
auto
parserCharset
=
UTF_8_ENCODING
;
nsCOMPtr
<
nsIWyciwygChannel
>
wyciwygChannel
;
nsHtml5TreeOpExecutor
*
executor
=
nullptr
;
if
(
loadAsHtml5
)
{
executor
=
static_cast
<
nsHtml5TreeOpExecutor
*
>
(
mParser
-
>
GetContentSink
(
)
)
;
if
(
mReferrerPolicySet
)
{
executor
-
>
SetSpeculationReferrerPolicy
(
static_cast
<
ReferrerPolicy
>
(
mReferrerPolicy
)
)
;
}
}
if
(
forceUtf8
)
{
charsetSource
=
kCharsetFromUtf8OnlyMime
;
parserCharsetSource
=
charsetSource
;
}
else
if
(
!
IsHTMLDocument
(
)
|
|
!
docShell
)
{
charsetSource
=
IsHTMLDocument
(
)
?
kCharsetFromFallback
:
kCharsetFromDocTypeDefault
;
TryChannelCharset
(
aChannel
charsetSource
encoding
executor
)
;
parserCharset
=
encoding
;
parserCharsetSource
=
charsetSource
;
}
else
{
NS_ASSERTION
(
docShell
"
Unexpected
null
value
"
)
;
charsetSource
=
kCharsetUninitialized
;
wyciwygChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
!
wyciwygChannel
)
{
TryChannelCharset
(
aChannel
charsetSource
encoding
executor
)
;
}
TryUserForcedCharset
(
cv
docShell
charsetSource
encoding
)
;
TryHintCharset
(
cv
charsetSource
encoding
)
;
TryParentCharset
(
docShell
charsetSource
encoding
)
;
if
(
cachingChan
&
&
!
urlSpec
.
IsEmpty
(
)
)
{
TryCacheCharset
(
cachingChan
charsetSource
encoding
)
;
}
TryTLD
(
charsetSource
encoding
)
;
TryFallback
(
charsetSource
encoding
)
;
if
(
wyciwygChannel
)
{
parserCharset
=
UTF_16LE_ENCODING
;
parserCharsetSource
=
charsetSource
<
kCharsetFromChannel
?
kCharsetFromChannel
:
charsetSource
;
nsAutoCString
cachedCharset
;
int32_t
cachedSource
;
rv
=
wyciwygChannel
-
>
GetCharsetAndSource
(
&
cachedSource
cachedCharset
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
cachedSource
>
charsetSource
)
{
auto
cachedEncoding
=
Encoding
:
:
ForLabel
(
cachedCharset
)
;
if
(
cachedEncoding
)
{
charsetSource
=
cachedSource
;
encoding
=
WrapNotNull
(
cachedEncoding
)
;
}
}
}
else
{
rv
=
NS_OK
;
}
}
else
{
parserCharset
=
encoding
;
parserCharsetSource
=
charsetSource
;
}
}
SetDocumentCharacterSetSource
(
charsetSource
)
;
SetDocumentCharacterSet
(
encoding
)
;
if
(
cachingChan
)
{
NS_ASSERTION
(
encoding
=
=
parserCharset
"
How
did
those
end
up
different
here
?
wyciwyg
channels
are
"
"
not
nsICachingChannel
"
)
;
nsAutoCString
charset
;
encoding
-
>
Name
(
charset
)
;
rv
=
cachingChan
-
>
SetCacheTokenCachedCharset
(
charset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
cannot
SetMetaDataElement
"
)
;
rv
=
NS_OK
;
}
rv
=
NS_OK
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
mParser
-
>
GetStreamListener
(
)
;
listener
.
forget
(
aDocListener
)
;
#
ifdef
DEBUG_charset
printf
(
"
charset
=
%
s
source
%
d
\
n
"
charset
.
get
(
)
charsetSource
)
;
#
endif
mParser
-
>
SetDocumentCharset
(
parserCharset
parserCharsetSource
)
;
mParser
-
>
SetCommand
(
aCommand
)
;
if
(
!
IsHTMLDocument
(
)
)
{
MOZ_ASSERT
(
!
loadAsHtml5
)
;
nsCOMPtr
<
nsIXMLContentSink
>
xmlsink
;
NS_NewXMLContentSink
(
getter_AddRefs
(
xmlsink
)
this
uri
docShell
aChannel
)
;
mParser
-
>
SetContentSink
(
xmlsink
)
;
}
else
{
if
(
loadAsHtml5
)
{
nsHtml5Module
:
:
Initialize
(
mParser
this
uri
docShell
aChannel
)
;
}
else
{
nsCOMPtr
<
nsIHTMLContentSink
>
htmlsink
;
NS_NewHTMLContentSink
(
getter_AddRefs
(
htmlsink
)
this
uri
docShell
aChannel
)
;
mParser
-
>
SetContentSink
(
htmlsink
)
;
}
}
if
(
plainText
&
&
!
nsContentUtils
:
:
IsChildOfSameType
(
this
)
&
&
Preferences
:
:
GetBool
(
"
plain_text
.
wrap_long_lines
"
)
)
{
nsCOMPtr
<
nsIStringBundleService
>
bundleService
=
do_GetService
(
NS_STRINGBUNDLE_CONTRACTID
&
rv
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
&
&
bundleService
"
The
bundle
service
could
not
be
loaded
"
)
;
nsCOMPtr
<
nsIStringBundle
>
bundle
;
rv
=
bundleService
-
>
CreateBundle
(
"
chrome
:
/
/
global
/
locale
/
browser
.
properties
"
getter_AddRefs
(
bundle
)
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
&
&
bundle
"
chrome
:
/
/
global
/
locale
/
browser
.
properties
could
not
be
loaded
"
)
;
nsAutoString
title
;
if
(
bundle
)
{
bundle
-
>
GetStringFromName
(
"
plainText
.
wordWrap
"
title
)
;
}
SetSelectedStyleSheetSet
(
title
)
;
}
mParser
-
>
Parse
(
uri
nullptr
(
void
*
)
this
)
;
return
rv
;
}
void
nsHTMLDocument
:
:
StopDocumentLoad
(
)
{
BlockOnload
(
)
;
RemoveWyciwygChannel
(
)
;
NS_ASSERTION
(
!
mWyciwygChannel
"
nsHTMLDocument
:
:
StopDocumentLoad
(
)
:
"
"
nsIWyciwygChannel
could
not
be
removed
!
"
)
;
nsDocument
:
:
StopDocumentLoad
(
)
;
UnblockOnload
(
false
)
;
}
void
nsHTMLDocument
:
:
BeginLoad
(
)
{
if
(
IsEditingOn
(
)
)
{
TurnEditingOff
(
)
;
EditingStateChanged
(
)
;
}
nsDocument
:
:
BeginLoad
(
)
;
}
void
nsHTMLDocument
:
:
EndLoad
(
)
{
bool
turnOnEditing
=
mParser
&
&
(
HasFlag
(
NODE_IS_EDITABLE
)
|
|
mContentEditableCount
>
0
)
;
nsDocument
:
:
EndLoad
(
)
;
if
(
turnOnEditing
)
{
EditingStateChanged
(
)
;
}
}
void
nsHTMLDocument
:
:
SetCompatibilityMode
(
nsCompatibility
aMode
)
{
NS_ASSERTION
(
IsHTMLDocument
(
)
|
|
aMode
=
=
eCompatibility_FullStandards
"
Bad
compat
mode
for
XHTML
document
!
"
)
;
if
(
mCompatMode
=
=
aMode
)
{
return
;
}
mCompatMode
=
aMode
;
CSSLoader
(
)
-
>
SetCompatibilityMode
(
mCompatMode
)
;
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
pc
-
>
CompatibilityModeChanged
(
)
;
}
}
nsIContent
*
nsHTMLDocument
:
:
GetUnfocusedKeyEventTarget
(
)
{
if
(
nsGenericHTMLElement
*
body
=
GetBody
(
)
)
{
return
body
;
}
return
nsDocument
:
:
GetUnfocusedKeyEventTarget
(
)
;
}
already_AddRefed
<
nsIURI
>
nsHTMLDocument
:
:
GetDomainURI
(
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
principal
-
>
GetDomain
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
return
uri
.
forget
(
)
;
}
principal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
return
uri
.
forget
(
)
;
}
void
nsHTMLDocument
:
:
GetDomain
(
nsAString
&
aDomain
)
{
nsCOMPtr
<
nsIURI
>
uri
=
GetDomainURI
(
)
;
if
(
!
uri
)
{
aDomain
.
Truncate
(
)
;
return
;
}
nsAutoCString
hostName
;
nsresult
rv
=
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
uri
hostName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF8toUTF16
(
hostName
aDomain
)
;
}
else
{
aDomain
.
Truncate
(
)
;
}
}
already_AddRefed
<
nsIURI
>
nsHTMLDocument
:
:
CreateInheritingURIForHost
(
const
nsACString
&
aHostString
)
{
if
(
aHostString
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
=
GetDomainURI
(
)
;
if
(
!
uri
)
{
return
nullptr
;
}
nsresult
rv
;
rv
=
NS_MutateURI
(
uri
)
.
SetUserPass
(
EmptyCString
(
)
)
.
SetPort
(
-
1
)
.
SetHostPort
(
aHostString
)
.
Finalize
(
uri
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
nsHTMLDocument
:
:
RegistrableDomainSuffixOfInternal
(
const
nsAString
&
aNewDomain
nsIURI
*
aOrigHost
)
{
if
(
NS_WARN_IF
(
!
aOrigHost
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
newURI
=
CreateInheritingURIForHost
(
NS_ConvertUTF16toUTF8
(
aNewDomain
)
)
;
if
(
!
newURI
)
{
return
nullptr
;
}
nsAutoCString
current
;
nsAutoCString
domain
;
if
(
NS_FAILED
(
aOrigHost
-
>
GetAsciiHost
(
current
)
)
)
{
current
.
Truncate
(
)
;
}
if
(
NS_FAILED
(
newURI
-
>
GetAsciiHost
(
domain
)
)
)
{
domain
.
Truncate
(
)
;
}
bool
ok
=
current
.
Equals
(
domain
)
;
if
(
current
.
Length
(
)
>
domain
.
Length
(
)
&
&
StringEndsWith
(
current
domain
)
&
&
current
.
CharAt
(
current
.
Length
(
)
-
domain
.
Length
(
)
-
1
)
=
=
'
.
'
)
{
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
return
nullptr
;
}
nsAutoCString
currentBaseDomain
;
ok
=
NS_SUCCEEDED
(
tldService
-
>
GetBaseDomain
(
aOrigHost
0
currentBaseDomain
)
)
;
NS_ASSERTION
(
StringEndsWith
(
domain
currentBaseDomain
)
=
=
(
domain
.
Length
(
)
>
=
currentBaseDomain
.
Length
(
)
)
"
uh
-
oh
!
slight
optimization
wasn
'
t
valid
somehow
!
"
)
;
ok
=
ok
&
&
domain
.
Length
(
)
>
=
currentBaseDomain
.
Length
(
)
;
}
if
(
!
ok
)
{
return
nullptr
;
}
return
CreateInheritingURIForHost
(
domain
)
;
}
bool
nsHTMLDocument
:
:
IsRegistrableDomainSuffixOfOrEqualTo
(
const
nsAString
&
aHostSuffixString
const
nsACString
&
aOrigHost
)
{
if
(
aHostSuffixString
.
IsEmpty
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
origURI
=
CreateInheritingURIForHost
(
aOrigHost
)
;
if
(
!
origURI
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
newURI
=
RegistrableDomainSuffixOfInternal
(
aHostSuffixString
origURI
)
;
if
(
!
newURI
)
{
return
false
;
}
return
true
;
}
void
nsHTMLDocument
:
:
SetDomain
(
const
nsAString
&
aDomain
ErrorResult
&
rv
)
{
if
(
mSandboxFlags
&
SANDBOXED_DOMAIN
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
aDomain
.
IsEmpty
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
uri
=
GetDomainURI
(
)
;
if
(
!
uri
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
newURI
=
RegistrableDomainSuffixOfInternal
(
aDomain
uri
)
;
if
(
!
newURI
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
rv
=
NodePrincipal
(
)
-
>
SetDomain
(
newURI
)
;
}
already_AddRefed
<
nsIChannel
>
nsHTMLDocument
:
:
CreateDummyChannelForCookies
(
nsIURI
*
aCodebaseURI
)
{
MOZ_ASSERT
(
!
mChannel
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
NS_NewChannel
(
getter_AddRefs
(
channel
)
aCodebaseURI
this
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
nsIContentPolicy
:
:
TYPE_INVALID
)
;
nsCOMPtr
<
nsIPrivateBrowsingChannel
>
pbChannel
=
do_QueryInterface
(
channel
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_QueryInterface
(
docShell
)
;
if
(
!
pbChannel
|
|
!
loadContext
)
{
return
nullptr
;
}
pbChannel
-
>
SetPrivate
(
loadContext
-
>
UsePrivateBrowsing
(
)
)
;
nsCOMPtr
<
nsIHttpChannel
>
docHTTPChannel
=
do_QueryInterface
(
GetChannel
(
)
)
;
if
(
docHTTPChannel
)
{
bool
isTracking
=
docHTTPChannel
-
>
GetIsTrackingResource
(
)
;
if
(
isTracking
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
;
MOZ_ASSERT
(
httpChannel
"
How
come
we
'
re
coming
from
an
HTTP
doc
but
"
"
we
don
'
t
have
an
HTTP
channel
here
?
"
)
;
if
(
httpChannel
)
{
httpChannel
-
>
OverrideTrackingResource
(
isTracking
)
;
}
}
}
return
channel
.
forget
(
)
;
}
void
nsHTMLDocument
:
:
GetCookie
(
nsAString
&
aCookie
ErrorResult
&
rv
)
{
aCookie
.
Truncate
(
)
;
if
(
mDisableCookieAccess
)
{
return
;
}
if
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
nsContentUtils
:
:
StorageDisabledByAntiTracking
(
GetInnerWindow
(
)
nullptr
nullptr
)
)
{
return
;
}
if
(
IsCookieAverse
(
)
)
{
return
;
}
nsCOMPtr
<
nsICookieService
>
service
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
if
(
service
)
{
nsCOMPtr
<
nsIURI
>
codebaseURI
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
codebaseURI
)
)
;
if
(
!
codebaseURI
)
{
return
;
}
nsCOMPtr
<
nsIChannel
>
channel
(
mChannel
)
;
if
(
!
channel
)
{
channel
=
CreateDummyChannelForCookies
(
codebaseURI
)
;
if
(
!
channel
)
{
return
;
}
}
nsCString
cookie
;
service
-
>
GetCookieString
(
codebaseURI
channel
getter_Copies
(
cookie
)
)
;
UTF_8_ENCODING
-
>
DecodeWithoutBOMHandling
(
cookie
aCookie
)
;
}
}
void
nsHTMLDocument
:
:
SetCookie
(
const
nsAString
&
aCookie
ErrorResult
&
rv
)
{
if
(
mDisableCookieAccess
)
{
return
;
}
if
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
IsCookieAverse
(
)
)
{
return
;
}
nsCOMPtr
<
nsICookieService
>
service
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
if
(
service
&
&
mDocumentURI
)
{
nsCOMPtr
<
nsIURI
>
codebaseURI
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
codebaseURI
)
)
;
if
(
!
codebaseURI
)
{
return
;
}
nsCOMPtr
<
nsIChannel
>
channel
(
mChannel
)
;
if
(
!
channel
)
{
channel
=
CreateDummyChannelForCookies
(
codebaseURI
)
;
if
(
!
channel
)
{
return
;
}
}
NS_ConvertUTF16toUTF8
cookie
(
aCookie
)
;
service
-
>
SetCookieString
(
codebaseURI
nullptr
cookie
.
get
(
)
channel
)
;
}
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsHTMLDocument
:
:
Open
(
JSContext
*
const
nsAString
&
aURL
const
nsAString
&
aName
const
nsAString
&
aFeatures
bool
aReplace
ErrorResult
&
rv
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
CanCallerAccess
(
this
)
"
XOW
should
have
caught
this
!
"
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetInnerWindow
(
)
;
if
(
!
window
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
window
)
;
if
(
!
outer
)
{
rv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
RefPtr
<
nsGlobalWindowOuter
>
win
=
nsGlobalWindowOuter
:
:
Cast
(
outer
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
newWindow
;
rv
=
win
-
>
OpenJS
(
aURL
aName
aFeatures
getter_AddRefs
(
newWindow
)
)
;
return
newWindow
.
forget
(
)
;
}
already_AddRefed
<
nsIDocument
>
nsHTMLDocument
:
:
Open
(
JSContext
*
cx
const
Optional
<
nsAString
>
&
const
nsAString
&
aReplace
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
CanCallerAccess
(
this
)
"
XOW
should
have
caught
this
!
"
)
;
if
(
!
IsHTMLDocument
(
)
|
|
mDisableDocWrite
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
ShouldThrowOnDynamicMarkupInsertion
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mParser
|
|
mParserAborted
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
if
(
ShouldIgnoreOpens
(
)
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
if
(
!
mScriptGlobalObject
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
nsPIDOMWindowOuter
*
outer
=
GetWindow
(
)
;
if
(
!
outer
|
|
(
GetInnerWindow
(
)
!
=
outer
-
>
GetCurrentInnerWindow
(
)
)
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
nsCOMPtr
<
nsIDocShell
>
shell
(
mDocumentContainer
)
;
if
(
!
shell
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
bool
inUnload
;
shell
-
>
GetIsInUnload
(
&
inUnload
)
;
if
(
inUnload
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
nsCOMPtr
<
nsIDocument
>
callerDoc
=
GetEntryDocument
(
)
;
if
(
!
callerDoc
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsISupports
>
securityInfo
=
callerDoc
-
>
GetSecurityInfo
(
)
;
nsCOMPtr
<
nsIURI
>
uri
=
callerDoc
-
>
GetDocumentURI
(
)
;
nsCOMPtr
<
nsIURI
>
baseURI
=
callerDoc
-
>
GetBaseURI
(
)
;
nsCOMPtr
<
nsIPrincipal
>
callerPrincipal
=
callerDoc
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIChannel
>
callerChannel
=
callerDoc
-
>
GetChannel
(
)
;
bool
equals
=
false
;
if
(
NS_FAILED
(
callerPrincipal
-
>
Equals
(
NodePrincipal
(
)
&
equals
)
)
|
|
!
equals
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIURI
>
callerDocURI
=
callerDoc
-
>
GetDocumentURI
(
)
;
nsCOMPtr
<
nsIURI
>
thisURI
=
nsIDocument
:
:
GetDocumentURI
(
)
;
printf
(
"
nsHTMLDocument
:
:
Open
callerDoc
%
s
this
%
s
\
n
"
callerDocURI
?
callerDocURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
thisURI
?
thisURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
;
#
endif
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
SetDocumentAndPageUseCounter
(
eUseCounter_custom_DocumentOpen
)
;
bool
isReplace
=
aReplace
.
LowerCaseEqualsLiteral
(
"
replace
"
)
;
if
(
isReplace
)
{
SetDocumentAndPageUseCounter
(
eUseCounter_custom_DocumentOpenReplace
)
;
}
if
(
mScriptGlobalObject
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
shell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
bool
okToUnload
;
if
(
NS_SUCCEEDED
(
cv
-
>
PermitUnload
(
&
okToUnload
)
)
&
&
!
okToUnload
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
if
(
!
mScriptGlobalObject
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
nsPIDOMWindowOuter
*
outer
=
GetWindow
(
)
;
if
(
!
outer
|
|
(
GetInnerWindow
(
)
!
=
outer
-
>
GetCurrentInnerWindow
(
)
)
)
{
nsCOMPtr
<
nsIDocument
>
ret
=
this
;
return
ret
.
forget
(
)
;
}
}
nsCOMPtr
<
nsIWebNavigation
>
webnav
(
do_QueryInterface
(
shell
)
)
;
webnav
-
>
Stop
(
nsIWebNavigation
:
:
STOP_NETWORK
)
;
EnsureOnloadBlocker
(
)
;
}
nsCOMPtr
<
nsIDocShell
>
curDocShell
=
GetDocShell
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
if
(
curDocShell
)
{
curDocShell
-
>
GetSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
}
nsContentPolicyType
policyType
;
if
(
!
parent
)
{
policyType
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
;
}
else
{
Element
*
requestingElement
=
nullptr
;
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
if
(
window
)
{
nsPIDOMWindowOuter
*
outer
=
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
window
)
;
if
(
outer
)
{
nsGlobalWindowOuter
*
win
=
nsGlobalWindowOuter
:
:
Cast
(
outer
)
;
requestingElement
=
win
-
>
AsOuter
(
)
-
>
GetFrameElementInternal
(
)
;
}
}
if
(
requestingElement
)
{
policyType
=
requestingElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
:
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
;
}
else
{
policyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
;
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
aError
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
uri
callerDoc
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
policyType
nullptr
group
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
callerChannel
)
{
nsLoadFlags
callerLoadFlags
;
aError
=
callerChannel
-
>
GetLoadFlags
(
&
callerLoadFlags
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsLoadFlags
loadFlags
;
aError
=
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
loadFlags
|
=
callerLoadFlags
&
nsIRequest
:
:
INHIBIT_PERSISTENT_CACHING
;
aError
=
channel
-
>
SetLoadFlags
(
loadFlags
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
bool
rootHasSecureConnection
=
false
;
bool
allowMixedContent
=
false
;
bool
isDocShellRoot
=
false
;
nsresult
rvalue
=
shell
-
>
GetAllowMixedContentAndConnectionData
(
&
rootHasSecureConnection
&
allowMixedContent
&
isDocShellRoot
)
;
if
(
NS_SUCCEEDED
(
rvalue
)
&
&
allowMixedContent
&
&
isDocShellRoot
)
{
shell
-
>
SetMixedContentChannel
(
channel
)
;
}
}
nsCOMPtr
<
nsIDocument
>
kungFuDeathGrip
=
this
;
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
)
{
nsCOMPtr
<
nsIScriptGlobalObject
>
oldScope
(
do_QueryReferent
(
mScopeObject
)
)
;
#
ifdef
DEBUG
bool
willReparent
=
mWillReparent
;
mWillReparent
=
true
;
nsIDocument
*
templateContentsOwner
=
mTemplateContentsOwner
.
get
(
)
;
if
(
templateContentsOwner
)
{
templateContentsOwner
-
>
mWillReparent
=
true
;
}
#
endif
SetReadyStateInternal
(
READYSTATE_UNINITIALIZED
)
;
aError
=
window
-
>
SetNewDocument
(
this
nullptr
false
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
#
ifdef
DEBUG
if
(
templateContentsOwner
)
{
templateContentsOwner
-
>
mWillReparent
=
willReparent
;
}
mWillReparent
=
willReparent
;
#
endif
SetIsInitialDocument
(
false
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
newScope
(
do_QueryReferent
(
mScopeObject
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
wrapper
(
cx
GetWrapper
(
)
)
;
if
(
oldScope
&
&
newScope
!
=
oldScope
&
&
wrapper
)
{
JSAutoRealm
ar
(
cx
wrapper
)
;
mozilla
:
:
dom
:
:
ReparentWrapper
(
cx
wrapper
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
mTemplateContentsOwner
)
{
JS
:
:
Rooted
<
JSObject
*
>
contentsOwnerWrapper
(
cx
mTemplateContentsOwner
-
>
GetWrapper
(
)
)
;
if
(
contentsOwnerWrapper
)
{
mozilla
:
:
dom
:
:
ReparentWrapper
(
cx
contentsOwnerWrapper
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
}
}
mDidDocumentOpen
=
true
;
nsAutoCString
contentType
(
GetContentTypeInternal
(
)
)
;
Reset
(
channel
group
)
;
if
(
baseURI
)
{
mDocumentBaseURI
=
baseURI
;
}
SetContentTypeInternal
(
contentType
)
;
mSecurityInfo
=
securityInfo
;
mParserAborted
=
false
;
mParser
=
nsHtml5Module
:
:
NewHtml5Parser
(
)
;
nsHtml5Module
:
:
Initialize
(
mParser
this
uri
shell
channel
)
;
if
(
mReferrerPolicySet
)
{
nsHtml5TreeOpExecutor
*
executor
=
nullptr
;
executor
=
static_cast
<
nsHtml5TreeOpExecutor
*
>
(
mParser
-
>
GetContentSink
(
)
)
;
if
(
executor
&
&
mReferrerPolicySet
)
{
executor
-
>
SetSpeculationReferrerPolicy
(
static_cast
<
ReferrerPolicy
>
(
mReferrerPolicy
)
)
;
}
}
mContentTypeForWriteCalls
.
AssignLiteral
(
"
text
/
html
"
)
;
shell
-
>
PrepareForNewContentModel
(
)
;
shell
-
>
SetLoadType
(
isReplace
?
LOAD_NORMAL_REPLACE
:
LOAD_NORMAL
)
;
nsCOMPtr
<
nsIContentViewer
>
cv
;
shell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
cv
-
>
LoadStart
(
this
)
;
}
NS_ASSERTION
(
!
mWyciwygChannel
"
nsHTMLDocument
:
:
Open
(
)
:
wyciwyg
"
"
channel
already
exists
!
"
)
;
+
+
mWriteLevel
;
CreateAndAddWyciwygChannel
(
)
;
-
-
mWriteLevel
;
SetReadyStateInternal
(
nsIDocument
:
:
READYSTATE_LOADING
)
;
DebugOnly
<
JSObject
*
>
wrapper
=
GetWrapperPreserveColor
(
)
;
MOZ_ASSERT_IF
(
wrapper
JS
:
:
GetRealmPrincipals
(
js
:
:
GetNonCCWObjectRealm
(
wrapper
)
)
=
=
nsJSPrincipals
:
:
get
(
NodePrincipal
(
)
)
)
;
return
kungFuDeathGrip
.
forget
(
)
;
}
void
nsHTMLDocument
:
:
Close
(
ErrorResult
&
rv
)
{
if
(
!
IsHTMLDocument
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
ShouldThrowOnDynamicMarkupInsertion
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
!
mParser
|
|
!
mParser
-
>
IsScriptCreated
(
)
)
{
return
;
}
+
+
mWriteLevel
;
rv
=
(
static_cast
<
nsHtml5Parser
*
>
(
mParser
.
get
(
)
)
)
-
>
Parse
(
EmptyString
(
)
nullptr
mContentTypeForWriteCalls
true
)
;
-
-
mWriteLevel
;
if
(
GetShell
(
)
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
NS_ASSERTION
(
mWyciwygChannel
"
nsHTMLDocument
:
:
Close
(
)
:
Trying
to
remove
"
"
nonexistent
wyciwyg
channel
!
"
)
;
RemoveWyciwygChannel
(
)
;
NS_ASSERTION
(
!
mWyciwygChannel
"
nsHTMLDocument
:
:
Close
(
)
:
"
"
nsIWyciwygChannel
could
not
be
removed
!
"
)
;
}
void
nsHTMLDocument
:
:
WriteCommon
(
JSContext
*
cx
const
Sequence
<
nsString
>
&
aText
bool
aNewlineTerminate
mozilla
:
:
ErrorResult
&
rv
)
{
if
(
aText
.
Length
(
)
=
=
1
)
{
WriteCommon
(
cx
aText
[
0
]
aNewlineTerminate
rv
)
;
}
else
{
nsString
text
;
for
(
uint32_t
i
=
0
;
i
<
aText
.
Length
(
)
;
+
+
i
)
{
text
.
Append
(
aText
[
i
]
)
;
}
WriteCommon
(
cx
text
aNewlineTerminate
rv
)
;
}
}
void
nsHTMLDocument
:
:
WriteCommon
(
JSContext
*
cx
const
nsAString
&
aText
bool
aNewlineTerminate
ErrorResult
&
aRv
)
{
mTooDeepWriteRecursion
=
(
mWriteLevel
>
NS_MAX_DOCUMENT_WRITE_DEPTH
|
|
mTooDeepWriteRecursion
)
;
if
(
NS_WARN_IF
(
mTooDeepWriteRecursion
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
!
IsHTMLDocument
(
)
|
|
mDisableDocWrite
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
ShouldThrowOnDynamicMarkupInsertion
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mParserAborted
)
{
return
;
}
if
(
ShouldIgnoreOpens
(
)
)
{
return
;
}
void
*
key
=
GenerateParserKey
(
)
;
if
(
mParser
&
&
!
mParser
-
>
IsInsertionPointDefined
(
)
)
{
if
(
mIgnoreDestructiveWritesCounter
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
Events
"
)
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
DocumentWriteIgnored
"
nullptr
0
mDocumentURI
)
;
return
;
}
IgnoreOpensDuringUnload
ignoreOpenGuard
(
this
)
;
mParser
-
>
Terminate
(
)
;
MOZ_RELEASE_ASSERT
(
!
mParser
"
mParser
should
have
been
null
'
d
out
"
)
;
}
if
(
!
mParser
)
{
if
(
mIgnoreDestructiveWritesCounter
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
Events
"
)
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
DocumentWriteIgnored
"
nullptr
0
mDocumentURI
)
;
return
;
}
nsCOMPtr
<
nsIDocument
>
ignored
=
Open
(
cx
Optional
<
nsAString
>
(
)
EmptyString
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
|
|
!
mParser
)
{
return
;
}
MOZ_ASSERT
(
!
JS_IsExceptionPending
(
cx
)
"
Open
(
)
succeeded
but
JS
exception
is
pending
"
)
;
}
static
NS_NAMED_LITERAL_STRING
(
new_line
"
\
n
"
)
;
if
(
mWyciwygChannel
&
&
!
key
)
{
if
(
!
aText
.
IsEmpty
(
)
)
{
mWyciwygChannel
-
>
WriteToCacheEntry
(
aText
)
;
}
if
(
aNewlineTerminate
)
{
mWyciwygChannel
-
>
WriteToCacheEntry
(
new_line
)
;
}
}
+
+
mWriteLevel
;
if
(
aNewlineTerminate
)
{
aRv
=
(
static_cast
<
nsHtml5Parser
*
>
(
mParser
.
get
(
)
)
)
-
>
Parse
(
aText
+
new_line
key
mContentTypeForWriteCalls
false
)
;
}
else
{
aRv
=
(
static_cast
<
nsHtml5Parser
*
>
(
mParser
.
get
(
)
)
)
-
>
Parse
(
aText
key
mContentTypeForWriteCalls
false
)
;
}
-
-
mWriteLevel
;
mTooDeepWriteRecursion
=
(
mWriteLevel
!
=
0
&
&
mTooDeepWriteRecursion
)
;
}
void
nsHTMLDocument
:
:
Write
(
JSContext
*
cx
const
Sequence
<
nsString
>
&
aText
ErrorResult
&
rv
)
{
WriteCommon
(
cx
aText
false
rv
)
;
}
void
nsHTMLDocument
:
:
Writeln
(
JSContext
*
cx
const
Sequence
<
nsString
>
&
aText
ErrorResult
&
rv
)
{
WriteCommon
(
cx
aText
true
rv
)
;
}
void
nsHTMLDocument
:
:
AddedForm
(
)
{
+
+
mNumForms
;
}
void
nsHTMLDocument
:
:
RemovedForm
(
)
{
-
-
mNumForms
;
}
int32_t
nsHTMLDocument
:
:
GetNumFormsSynchronous
(
)
{
return
mNumForms
;
}
void
nsHTMLDocument
:
:
GetAlinkColor
(
nsAString
&
aAlinkColor
)
{
aAlinkColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetALink
(
aAlinkColor
)
;
}
}
void
nsHTMLDocument
:
:
SetAlinkColor
(
const
nsAString
&
aAlinkColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetALink
(
aAlinkColor
)
;
}
}
void
nsHTMLDocument
:
:
GetLinkColor
(
nsAString
&
aLinkColor
)
{
aLinkColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetLink
(
aLinkColor
)
;
}
}
void
nsHTMLDocument
:
:
SetLinkColor
(
const
nsAString
&
aLinkColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetLink
(
aLinkColor
)
;
}
}
void
nsHTMLDocument
:
:
GetVlinkColor
(
nsAString
&
aVlinkColor
)
{
aVlinkColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetVLink
(
aVlinkColor
)
;
}
}
void
nsHTMLDocument
:
:
SetVlinkColor
(
const
nsAString
&
aVlinkColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetVLink
(
aVlinkColor
)
;
}
}
void
nsHTMLDocument
:
:
GetBgColor
(
nsAString
&
aBgColor
)
{
aBgColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetBgColor
(
aBgColor
)
;
}
}
void
nsHTMLDocument
:
:
SetBgColor
(
const
nsAString
&
aBgColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetBgColor
(
aBgColor
)
;
}
}
void
nsHTMLDocument
:
:
GetFgColor
(
nsAString
&
aFgColor
)
{
aFgColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetText
(
aFgColor
)
;
}
}
void
nsHTMLDocument
:
:
SetFgColor
(
const
nsAString
&
aFgColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetText
(
aFgColor
)
;
}
}
void
nsHTMLDocument
:
:
CaptureEvents
(
)
{
WarnOnceAbout
(
nsIDocument
:
:
eUseOfCaptureEvents
)
;
}
void
nsHTMLDocument
:
:
ReleaseEvents
(
)
{
WarnOnceAbout
(
nsIDocument
:
:
eUseOfReleaseEvents
)
;
}
bool
nsHTMLDocument
:
:
ResolveName
(
JSContext
*
aCx
const
nsAString
&
aName
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
nsIdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aName
)
;
if
(
!
entry
)
{
return
false
;
}
nsBaseContentList
*
list
=
entry
-
>
GetNameContentList
(
)
;
uint32_t
length
=
list
?
list
-
>
Length
(
)
:
0
;
nsIContent
*
node
;
if
(
length
>
0
)
{
if
(
length
>
1
)
{
if
(
!
ToJSValue
(
aCx
list
aRetval
)
)
{
aError
.
NoteJSContextException
(
aCx
)
;
return
false
;
}
return
true
;
}
node
=
list
-
>
Item
(
0
)
;
}
else
{
Element
*
e
=
entry
-
>
GetIdElement
(
)
;
if
(
!
e
|
|
!
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
e
)
)
{
return
false
;
}
node
=
e
;
}
if
(
!
ToJSValue
(
aCx
node
aRetval
)
)
{
aError
.
NoteJSContextException
(
aCx
)
;
return
false
;
}
return
true
;
}
void
nsHTMLDocument
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
{
for
(
auto
iter
=
mIdentifierMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsIdentifierMapEntry
*
entry
=
iter
.
Get
(
)
;
if
(
entry
-
>
HasNameElement
(
)
|
|
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
aNames
.
AppendElement
(
entry
-
>
GetKeyAsString
(
)
)
;
}
}
}
bool
nsHTMLDocument
:
:
MatchFormControls
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
return
aElement
-
>
IsNodeOfType
(
nsIContent
:
:
eHTML_FORM_CONTROL
)
;
}
nsresult
nsHTMLDocument
:
:
CreateAndAddWyciwygChannel
(
void
)
{
nsresult
rv
=
NS_OK
;
nsAutoCString
url
originalSpec
;
mDocumentURI
-
>
GetSpec
(
originalSpec
)
;
url
=
NS_LITERAL_CSTRING
(
"
wyciwyg
:
/
/
"
)
+
nsPrintfCString
(
"
%
d
"
gWyciwygSessionCnt
+
+
)
+
NS_LITERAL_CSTRING
(
"
/
"
)
+
originalSpec
;
nsCOMPtr
<
nsIURI
>
wcwgURI
;
NS_NewURI
(
getter_AddRefs
(
wcwgURI
)
url
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
wcwgURI
NodePrincipal
(
)
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
NS_ENSURE_STATE
(
loadInfo
)
;
loadInfo
-
>
SetPrincipalToInherit
(
NodePrincipal
(
)
)
;
mWyciwygChannel
=
do_QueryInterface
(
channel
)
;
mWyciwygChannel
-
>
SetSecurityInfo
(
mSecurityInfo
)
;
SetDocumentCharacterSetSource
(
kCharsetFromHintPrevDoc
)
;
nsAutoCString
charset
;
GetDocumentCharacterSet
(
)
-
>
Name
(
charset
)
;
mWyciwygChannel
-
>
SetCharsetAndSource
(
kCharsetFromHintPrevDoc
charset
)
;
channel
-
>
SetLoadFlags
(
mLoadFlags
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
&
&
channel
)
{
rv
=
channel
-
>
SetLoadGroup
(
loadGroup
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsLoadFlags
loadFlags
=
0
;
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
loadFlags
|
=
nsIChannel
:
:
LOAD_DOCUMENT_URI
;
if
(
nsDocShell
:
:
SandboxFlagsImplyCookies
(
mSandboxFlags
)
)
{
loadFlags
|
=
nsIRequest
:
:
LOAD_DOCUMENT_NEEDS_COOKIE
;
}
channel
-
>
SetLoadFlags
(
loadFlags
)
;
channel
-
>
SetOriginalURI
(
wcwgURI
)
;
rv
=
loadGroup
-
>
AddRequest
(
mWyciwygChannel
nullptr
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
add
request
to
load
group
.
"
)
;
}
return
rv
;
}
nsresult
nsHTMLDocument
:
:
RemoveWyciwygChannel
(
void
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
&
&
mWyciwygChannel
)
{
mWyciwygChannel
-
>
CloseCacheEntry
(
NS_OK
)
;
loadGroup
-
>
RemoveRequest
(
mWyciwygChannel
nullptr
NS_OK
)
;
}
mWyciwygChannel
=
nullptr
;
return
NS_OK
;
}
void
*
nsHTMLDocument
:
:
GenerateParserKey
(
void
)
{
if
(
!
mScriptLoader
)
{
return
nullptr
;
}
nsIScriptElement
*
script
=
mScriptLoader
-
>
GetCurrentParserInsertedScript
(
)
;
if
(
script
&
&
mParser
&
&
mParser
-
>
IsScriptCreated
(
)
)
{
nsCOMPtr
<
nsIParser
>
creatorParser
=
script
-
>
GetCreatorParser
(
)
;
if
(
creatorParser
!
=
mParser
)
{
return
nullptr
;
}
}
return
script
;
}
void
nsHTMLDocument
:
:
GetDesignMode
(
nsAString
&
aDesignMode
)
{
if
(
HasFlag
(
NODE_IS_EDITABLE
)
)
{
aDesignMode
.
AssignLiteral
(
"
on
"
)
;
}
else
{
aDesignMode
.
AssignLiteral
(
"
off
"
)
;
}
}
void
nsHTMLDocument
:
:
MaybeEditingStateChanged
(
)
{
if
(
!
mPendingMaybeEditingStateChanged
&
&
mMayStartLayout
&
&
mUpdateNestLevel
=
=
0
&
&
(
mContentEditableCount
>
0
)
!
=
IsEditingOn
(
)
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
EditingStateChanged
(
)
;
}
else
if
(
!
mInDestructor
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
nsHTMLDocument
:
:
MaybeEditingStateChanged
"
this
&
nsHTMLDocument
:
:
MaybeEditingStateChanged
)
)
;
}
}
}
void
nsHTMLDocument
:
:
EndUpdate
(
)
{
const
bool
reset
=
!
mPendingMaybeEditingStateChanged
;
mPendingMaybeEditingStateChanged
=
true
;
nsDocument
:
:
EndUpdate
(
)
;
if
(
reset
)
{
mPendingMaybeEditingStateChanged
=
false
;
}
MaybeEditingStateChanged
(
)
;
}
void
nsHTMLDocument
:
:
SetMayStartLayout
(
bool
aMayStartLayout
)
{
nsIDocument
:
:
SetMayStartLayout
(
aMayStartLayout
)
;
MaybeEditingStateChanged
(
)
;
}
class
DeferredContentEditableCountChangeEvent
:
public
Runnable
{
public
:
DeferredContentEditableCountChangeEvent
(
nsHTMLDocument
*
aDoc
nsIContent
*
aElement
)
:
mozilla
:
:
Runnable
(
"
DeferredContentEditableCountChangeEvent
"
)
mDoc
(
aDoc
)
mElement
(
aElement
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mElement
&
&
mElement
-
>
OwnerDoc
(
)
=
=
mDoc
)
{
mDoc
-
>
DeferredContentEditableCountChange
(
mElement
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
nsHTMLDocument
>
mDoc
;
nsCOMPtr
<
nsIContent
>
mElement
;
}
;
nsresult
nsHTMLDocument
:
:
ChangeContentEditableCount
(
nsIContent
*
aElement
int32_t
aChange
)
{
NS_ASSERTION
(
int32_t
(
mContentEditableCount
)
+
aChange
>
=
0
"
Trying
to
decrement
too
much
.
"
)
;
mContentEditableCount
+
=
aChange
;
nsContentUtils
:
:
AddScriptRunner
(
new
DeferredContentEditableCountChangeEvent
(
this
aElement
)
)
;
return
NS_OK
;
}
void
nsHTMLDocument
:
:
DeferredContentEditableCountChange
(
nsIContent
*
aElement
)
{
if
(
mParser
|
|
(
mUpdateNestLevel
>
0
&
&
(
mContentEditableCount
>
0
)
!
=
IsEditingOn
(
)
)
)
{
return
;
}
EditingState
oldState
=
mEditingState
;
nsresult
rv
=
EditingStateChanged
(
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
oldState
=
=
mEditingState
&
&
mEditingState
=
=
eContentEditable
)
{
if
(
aElement
)
{
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
return
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
return
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
docshell
-
>
GetHTMLEditor
(
)
;
if
(
htmlEditor
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aElement
)
;
IgnoredErrorResult
res
;
range
-
>
SelectNode
(
*
aElement
res
)
;
if
(
res
.
Failed
(
)
)
{
return
;
}
nsCOMPtr
<
nsIInlineSpellChecker
>
spellChecker
;
rv
=
htmlEditor
-
>
GetInlineSpellChecker
(
false
getter_AddRefs
(
spellChecker
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
spellChecker
)
{
rv
=
spellChecker
-
>
SpellCheckRange
(
range
)
;
}
}
}
}
}
HTMLAllCollection
*
nsHTMLDocument
:
:
All
(
)
{
if
(
!
mAll
)
{
mAll
=
new
HTMLAllCollection
(
this
)
;
}
return
mAll
;
}
static
void
NotifyEditableStateChange
(
nsINode
*
aNode
nsIDocument
*
aDocument
)
{
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
child
-
>
AsElement
(
)
-
>
UpdateState
(
true
)
;
}
NotifyEditableStateChange
(
child
aDocument
)
;
}
}
void
nsHTMLDocument
:
:
TearingDownEditor
(
)
{
if
(
IsEditingOn
(
)
)
{
EditingState
oldState
=
mEditingState
;
mEditingState
=
eTearingDown
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetShell
(
)
;
if
(
!
presShell
)
return
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
agentSheets
;
presShell
-
>
GetAgentStyleSheets
(
agentSheets
)
;
auto
cache
=
nsLayoutStylesheetCache
:
:
Singleton
(
)
;
agentSheets
.
RemoveElement
(
cache
-
>
ContentEditableSheet
(
)
)
;
if
(
oldState
=
=
eDesignMode
)
agentSheets
.
RemoveElement
(
cache
-
>
DesignModeSheet
(
)
)
;
presShell
-
>
SetAgentStyleSheets
(
agentSheets
)
;
presShell
-
>
ApplicableStylesChanged
(
)
;
}
}
nsresult
nsHTMLDocument
:
:
TurnEditingOff
(
)
{
NS_ASSERTION
(
mEditingState
!
=
eOff
"
Editing
is
already
off
.
"
)
;
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
return
NS_ERROR_FAILURE
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIEditingSession
>
editSession
;
nsresult
rv
=
docshell
-
>
GetEditingSession
(
getter_AddRefs
(
editSession
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
editSession
-
>
TearDownEditorOnWindow
(
window
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mEditingState
=
eOff
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
Element
*
element
=
fm
-
>
GetFocusedElement
(
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
element
)
;
if
(
txtCtrl
)
{
RefPtr
<
TextEditor
>
textEditor
=
txtCtrl
-
>
GetTextEditor
(
)
;
if
(
textEditor
)
{
textEditor
-
>
ReinitializeSelection
(
*
element
)
;
}
}
}
return
NS_OK
;
}
static
bool
HasPresShell
(
nsPIDOMWindowOuter
*
aWindow
)
{
nsIDocShell
*
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
return
false
;
return
docShell
-
>
GetPresShell
(
)
!
=
nullptr
;
}
nsresult
nsHTMLDocument
:
:
SetEditingState
(
EditingState
aState
)
{
mEditingState
=
aState
;
return
NS_OK
;
}
nsresult
nsHTMLDocument
:
:
EditingStateChanged
(
)
{
if
(
mRemovedFromDocShell
)
{
return
NS_OK
;
}
if
(
mEditingState
=
=
eSettingUp
|
|
mEditingState
=
=
eTearingDown
)
{
return
NS_OK
;
}
bool
designMode
=
HasFlag
(
NODE_IS_EDITABLE
)
;
EditingState
newState
=
designMode
?
eDesignMode
:
(
mContentEditableCount
>
0
?
eContentEditable
:
eOff
)
;
if
(
mEditingState
=
=
newState
)
{
return
NS_OK
;
}
if
(
newState
=
=
eOff
)
{
nsAutoScriptBlocker
scriptBlocker
;
NotifyEditableStateChange
(
this
this
)
;
return
TurnEditingOff
(
)
;
}
if
(
mParentDocument
)
{
mParentDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetWindow
(
)
;
if
(
!
window
)
return
NS_ERROR_FAILURE
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
return
NS_ERROR_FAILURE
;
bool
isBeingDestroyed
=
false
;
docshell
-
>
IsBeingDestroyed
(
&
isBeingDestroyed
)
;
if
(
isBeingDestroyed
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIEditingSession
>
editSession
;
nsresult
rv
=
docshell
-
>
GetEditingSession
(
getter_AddRefs
(
editSession
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
editSession
-
>
GetHTMLEditorForWindow
(
window
)
;
if
(
htmlEditor
)
{
uint32_t
flags
=
0
;
htmlEditor
-
>
GetFlags
(
&
flags
)
;
if
(
flags
&
nsIPlaintextEditor
:
:
eEditorMailMask
)
{
return
NS_OK
;
}
}
if
(
!
HasPresShell
(
window
)
)
{
return
NS_OK
;
}
bool
makeWindowEditable
=
mEditingState
=
=
eOff
;
bool
updateState
=
false
;
bool
spellRecheckAll
=
false
;
bool
putOffToRemoveScriptBlockerUntilModifyingEditingState
=
false
;
htmlEditor
=
nullptr
;
{
EditingState
oldState
=
mEditingState
;
nsAutoEditingState
push
(
this
eSettingUp
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
agentSheets
;
rv
=
presShell
-
>
GetAgentStyleSheets
(
agentSheets
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
cache
=
nsLayoutStylesheetCache
:
:
Singleton
(
)
;
StyleSheet
*
contentEditableSheet
=
cache
-
>
ContentEditableSheet
(
)
;
if
(
!
agentSheets
.
Contains
(
contentEditableSheet
)
)
{
agentSheets
.
AppendElement
(
contentEditableSheet
)
;
}
if
(
designMode
)
{
StyleSheet
*
designModeSheet
=
cache
-
>
DesignModeSheet
(
)
;
if
(
!
agentSheets
.
Contains
(
designModeSheet
)
)
{
agentSheets
.
AppendElement
(
designModeSheet
)
;
}
updateState
=
true
;
spellRecheckAll
=
oldState
=
=
eContentEditable
;
}
else
if
(
oldState
=
=
eDesignMode
)
{
agentSheets
.
RemoveElement
(
cache
-
>
DesignModeSheet
(
)
)
;
updateState
=
true
;
}
rv
=
presShell
-
>
SetAgentStyleSheets
(
agentSheets
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
presShell
-
>
ApplicableStylesChanged
(
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
designMode
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsIContent
*
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
if
(
focusedContent
)
{
nsIFrame
*
focusedFrame
=
focusedContent
-
>
GetPrimaryFrame
(
)
;
bool
clearFocus
=
focusedFrame
?
!
focusedFrame
-
>
IsFocusable
(
)
:
!
focusedContent
-
>
IsFocusable
(
)
;
if
(
clearFocus
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
fm
-
>
ClearFocus
(
window
)
;
putOffToRemoveScriptBlockerUntilModifyingEditingState
=
true
;
}
}
}
}
if
(
makeWindowEditable
)
{
rv
=
editSession
-
>
MakeWindowEditable
(
window
"
html
"
false
false
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
htmlEditor
=
docshell
-
>
GetHTMLEditor
(
)
;
if
(
!
htmlEditor
)
{
return
NS_ERROR_FAILURE
;
}
if
(
designMode
&
&
oldState
=
=
eOff
)
{
htmlEditor
-
>
BeginningOfDocument
(
)
;
}
if
(
putOffToRemoveScriptBlockerUntilModifyingEditingState
)
{
nsContentUtils
:
:
AddScriptBlocker
(
)
;
}
}
mEditingState
=
newState
;
if
(
putOffToRemoveScriptBlockerUntilModifyingEditingState
)
{
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
if
(
mEditingState
=
=
eOff
)
{
return
NS_OK
;
}
}
if
(
makeWindowEditable
)
{
ErrorResult
errorResult
;
Unused
<
<
ExecCommand
(
NS_LITERAL_STRING
(
"
insertBrOnReturn
"
)
false
NS_LITERAL_STRING
(
"
false
"
)
*
NodePrincipal
(
)
errorResult
)
;
if
(
errorResult
.
Failed
(
)
)
{
editSession
-
>
TearDownEditorOnWindow
(
window
)
;
mEditingState
=
eOff
;
return
errorResult
.
StealNSResult
(
)
;
}
}
if
(
updateState
)
{
nsAutoScriptBlocker
scriptBlocker
;
NotifyEditableStateChange
(
this
this
)
;
}
if
(
spellRecheckAll
)
{
nsCOMPtr
<
nsISelectionController
>
selectionController
=
htmlEditor
-
>
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Selection
>
spellCheckSelection
=
selectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_SPELLCHECK
)
;
if
(
spellCheckSelection
)
{
spellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
}
htmlEditor
-
>
SyncRealTimeSpell
(
)
;
return
NS_OK
;
}
void
nsHTMLDocument
:
:
SetDesignMode
(
const
nsAString
&
aDesignMode
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
rv
)
{
SetDesignMode
(
aDesignMode
Some
(
&
aSubjectPrincipal
)
rv
)
;
}
void
nsHTMLDocument
:
:
SetDesignMode
(
const
nsAString
&
aDesignMode
const
Maybe
<
nsIPrincipal
*
>
&
aSubjectPrincipal
ErrorResult
&
rv
)
{
if
(
aSubjectPrincipal
.
isSome
(
)
&
&
!
aSubjectPrincipal
.
value
(
)
-
>
Subsumes
(
NodePrincipal
(
)
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_PROP_ACCESS_DENIED
)
;
return
;
}
bool
editableMode
=
HasFlag
(
NODE_IS_EDITABLE
)
;
if
(
aDesignMode
.
LowerCaseEqualsASCII
(
editableMode
?
"
off
"
:
"
on
"
)
)
{
SetEditableFlag
(
!
editableMode
)
;
rv
=
EditingStateChanged
(
)
;
}
}
nsresult
nsHTMLDocument
:
:
GetMidasCommandManager
(
nsICommandManager
*
*
aCmdMgr
)
{
NS_ENSURE_ARG_POINTER
(
aCmdMgr
)
;
if
(
mMidasCommandManager
)
{
NS_ADDREF
(
*
aCmdMgr
=
mMidasCommandManager
)
;
return
NS_OK
;
}
*
aCmdMgr
=
nullptr
;
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
return
NS_ERROR_FAILURE
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
return
NS_ERROR_FAILURE
;
mMidasCommandManager
=
docshell
-
>
GetCommandManager
(
)
;
if
(
!
mMidasCommandManager
)
return
NS_ERROR_FAILURE
;
NS_ADDREF
(
*
aCmdMgr
=
mMidasCommandManager
)
;
return
NS_OK
;
}
struct
MidasCommand
{
const
char
*
incomingCommandString
;
const
char
*
internalCommandString
;
const
char
*
internalParamString
;
bool
useNewParam
;
bool
convertToBoolean
;
}
;
static
const
struct
MidasCommand
gMidasCommandTable
[
]
=
{
{
"
bold
"
"
cmd_bold
"
"
"
true
false
}
{
"
italic
"
"
cmd_italic
"
"
"
true
false
}
{
"
underline
"
"
cmd_underline
"
"
"
true
false
}
{
"
strikethrough
"
"
cmd_strikethrough
"
"
"
true
false
}
{
"
subscript
"
"
cmd_subscript
"
"
"
true
false
}
{
"
superscript
"
"
cmd_superscript
"
"
"
true
false
}
{
"
cut
"
"
cmd_cut
"
"
"
true
false
}
{
"
copy
"
"
cmd_copy
"
"
"
true
false
}
{
"
paste
"
"
cmd_paste
"
"
"
true
false
}
{
"
delete
"
"
cmd_deleteCharBackward
"
"
"
true
false
}
{
"
forwarddelete
"
"
cmd_deleteCharForward
"
"
"
true
false
}
{
"
selectall
"
"
cmd_selectAll
"
"
"
true
false
}
{
"
undo
"
"
cmd_undo
"
"
"
true
false
}
{
"
redo
"
"
cmd_redo
"
"
"
true
false
}
{
"
indent
"
"
cmd_indent
"
"
"
true
false
}
{
"
outdent
"
"
cmd_outdent
"
"
"
true
false
}
{
"
backcolor
"
"
cmd_highlight
"
"
"
false
false
}
{
"
forecolor
"
"
cmd_fontColor
"
"
"
false
false
}
{
"
hilitecolor
"
"
cmd_highlight
"
"
"
false
false
}
{
"
fontname
"
"
cmd_fontFace
"
"
"
false
false
}
{
"
fontsize
"
"
cmd_fontSize
"
"
"
false
false
}
{
"
increasefontsize
"
"
cmd_increaseFont
"
"
"
false
false
}
{
"
decreasefontsize
"
"
cmd_decreaseFont
"
"
"
false
false
}
{
"
inserthorizontalrule
"
"
cmd_insertHR
"
"
"
true
false
}
{
"
createlink
"
"
cmd_insertLinkNoUI
"
"
"
false
false
}
{
"
insertimage
"
"
cmd_insertImageNoUI
"
"
"
false
false
}
{
"
inserthtml
"
"
cmd_insertHTML
"
"
"
false
false
}
{
"
inserttext
"
"
cmd_insertText
"
"
"
false
false
}
{
"
gethtml
"
"
cmd_getContents
"
"
"
false
false
}
{
"
justifyleft
"
"
cmd_align
"
"
left
"
true
false
}
{
"
justifyright
"
"
cmd_align
"
"
right
"
true
false
}
{
"
justifycenter
"
"
cmd_align
"
"
center
"
true
false
}
{
"
justifyfull
"
"
cmd_align
"
"
justify
"
true
false
}
{
"
removeformat
"
"
cmd_removeStyles
"
"
"
true
false
}
{
"
unlink
"
"
cmd_removeLinks
"
"
"
true
false
}
{
"
insertorderedlist
"
"
cmd_ol
"
"
"
true
false
}
{
"
insertunorderedlist
"
"
cmd_ul
"
"
"
true
false
}
{
"
insertparagraph
"
"
cmd_insertParagraph
"
"
"
true
false
}
{
"
insertlinebreak
"
"
cmd_insertLineBreak
"
"
"
true
false
}
{
"
formatblock
"
"
cmd_paragraphState
"
"
"
false
false
}
{
"
heading
"
"
cmd_paragraphState
"
"
"
false
false
}
{
"
styleWithCSS
"
"
cmd_setDocumentUseCSS
"
"
"
false
true
}
{
"
contentReadOnly
"
"
cmd_setDocumentReadOnly
"
"
"
false
true
}
{
"
insertBrOnReturn
"
"
cmd_insertBrOnReturn
"
"
"
false
true
}
{
"
defaultParagraphSeparator
"
"
cmd_defaultParagraphSeparator
"
"
"
false
false
}
{
"
enableObjectResizing
"
"
cmd_enableObjectResizing
"
"
"
false
true
}
{
"
enableInlineTableEditing
"
"
cmd_enableInlineTableEditing
"
"
"
false
true
}
#
if
0
{
"
justifynone
"
"
cmd_align
"
"
"
true
false
}
{
"
saveas
"
"
cmd_saveAs
"
"
"
true
false
}
{
"
print
"
"
cmd_print
"
"
"
true
false
}
#
endif
{
nullptr
nullptr
nullptr
false
false
}
}
;
#
define
MidasCommandCount
(
(
sizeof
(
gMidasCommandTable
)
/
sizeof
(
struct
MidasCommand
)
)
-
1
)
static
const
char
*
const
gBlocks
[
]
=
{
"
ADDRESS
"
"
BLOCKQUOTE
"
"
DD
"
"
DIV
"
"
DL
"
"
DT
"
"
H1
"
"
H2
"
"
H3
"
"
H4
"
"
H5
"
"
H6
"
"
P
"
"
PRE
"
}
;
static
bool
ConvertToMidasInternalCommandInner
(
const
nsAString
&
inCommandID
const
nsAString
&
inParam
nsACString
&
outCommandID
nsACString
&
outParam
bool
&
outIsBoolean
bool
&
outBooleanValue
bool
aIgnoreParams
)
{
NS_ConvertUTF16toUTF8
convertedCommandID
(
inCommandID
)
;
bool
invertBool
=
false
;
if
(
convertedCommandID
.
LowerCaseEqualsLiteral
(
"
usecss
"
)
)
{
convertedCommandID
.
AssignLiteral
(
"
styleWithCSS
"
)
;
invertBool
=
true
;
}
else
if
(
convertedCommandID
.
LowerCaseEqualsLiteral
(
"
readonly
"
)
)
{
convertedCommandID
.
AssignLiteral
(
"
contentReadOnly
"
)
;
invertBool
=
true
;
}
uint32_t
i
;
bool
found
=
false
;
for
(
i
=
0
;
i
<
MidasCommandCount
;
+
+
i
)
{
if
(
convertedCommandID
.
Equals
(
gMidasCommandTable
[
i
]
.
incomingCommandString
nsCaseInsensitiveCStringComparator
(
)
)
)
{
found
=
true
;
break
;
}
}
if
(
!
found
)
{
outCommandID
.
SetLength
(
0
)
;
outParam
.
SetLength
(
0
)
;
outIsBoolean
=
false
;
return
false
;
}
outCommandID
.
Assign
(
gMidasCommandTable
[
i
]
.
internalCommandString
)
;
outIsBoolean
=
gMidasCommandTable
[
i
]
.
convertToBoolean
;
if
(
aIgnoreParams
)
{
return
true
;
}
if
(
gMidasCommandTable
[
i
]
.
useNewParam
)
{
outParam
.
Assign
(
gMidasCommandTable
[
i
]
.
internalParamString
)
;
return
true
;
}
if
(
outIsBoolean
)
{
if
(
invertBool
)
{
outBooleanValue
=
inParam
.
LowerCaseEqualsLiteral
(
"
false
"
)
;
}
else
{
outBooleanValue
=
!
inParam
.
LowerCaseEqualsLiteral
(
"
false
"
)
;
}
outParam
.
Truncate
(
)
;
return
true
;
}
if
(
outCommandID
.
EqualsLiteral
(
"
cmd_paragraphState
"
)
)
{
const
char16_t
*
start
=
inParam
.
BeginReading
(
)
;
const
char16_t
*
end
=
inParam
.
EndReading
(
)
;
if
(
start
!
=
end
&
&
*
start
=
=
'
<
'
&
&
*
(
end
-
1
)
=
=
'
>
'
)
{
+
+
start
;
-
-
end
;
}
NS_ConvertUTF16toUTF8
convertedParam
(
Substring
(
start
end
)
)
;
uint32_t
j
;
for
(
j
=
0
;
j
<
ArrayLength
(
gBlocks
)
;
+
+
j
)
{
if
(
convertedParam
.
Equals
(
gBlocks
[
j
]
nsCaseInsensitiveCStringComparator
(
)
)
)
{
outParam
.
Assign
(
gBlocks
[
j
]
)
;
break
;
}
}
if
(
j
=
=
ArrayLength
(
gBlocks
)
)
{
outParam
.
Truncate
(
)
;
}
}
else
if
(
outCommandID
.
EqualsLiteral
(
"
cmd_fontSize
"
)
)
{
outParam
.
Truncate
(
)
;
int32_t
size
=
nsContentUtils
:
:
ParseLegacyFontSize
(
inParam
)
;
if
(
size
)
{
outParam
.
AppendInt
(
size
)
;
}
}
else
{
CopyUTF16toUTF8
(
inParam
outParam
)
;
}
return
true
;
}
static
bool
ConvertToMidasInternalCommand
(
const
nsAString
&
inCommandID
const
nsAString
&
inParam
nsACString
&
outCommandID
nsACString
&
outParam
bool
&
outIsBoolean
bool
&
outBooleanValue
)
{
return
ConvertToMidasInternalCommandInner
(
inCommandID
inParam
outCommandID
outParam
outIsBoolean
outBooleanValue
false
)
;
}
static
bool
ConvertToMidasInternalCommand
(
const
nsAString
&
inCommandID
nsACString
&
outCommandID
)
{
nsAutoCString
dummyCString
;
nsAutoString
dummyString
;
bool
dummyBool
;
return
ConvertToMidasInternalCommandInner
(
inCommandID
dummyString
outCommandID
dummyCString
dummyBool
dummyBool
true
)
;
}
bool
nsHTMLDocument
:
:
ExecCommand
(
const
nsAString
&
commandID
bool
doShowUI
const
nsAString
&
value
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
rv
)
{
nsAutoCString
cmdToDispatch
paramStr
;
bool
isBool
boolVal
;
if
(
!
ConvertToMidasInternalCommand
(
commandID
value
cmdToDispatch
paramStr
isBool
boolVal
)
)
{
return
false
;
}
bool
isCutCopy
=
(
commandID
.
LowerCaseEqualsLiteral
(
"
cut
"
)
|
|
commandID
.
LowerCaseEqualsLiteral
(
"
copy
"
)
)
;
bool
isPaste
=
commandID
.
LowerCaseEqualsLiteral
(
"
paste
"
)
;
if
(
!
isCutCopy
&
&
!
isPaste
&
&
!
IsEditingOnAfterFlush
(
)
)
{
return
false
;
}
if
(
doShowUI
)
{
return
false
;
}
if
(
isCutCopy
)
{
if
(
!
nsContentUtils
:
:
IsCutCopyAllowed
(
&
aSubjectPrincipal
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
ExecCommandCutCopyDeniedNotInputDriven
"
)
;
return
false
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
)
{
nsresult
res
=
docShell
-
>
DoCommand
(
cmdToDispatch
.
get
(
)
)
;
if
(
res
=
=
NS_SUCCESS_DOM_NO_OPERATION
)
{
return
false
;
}
return
NS_SUCCEEDED
(
res
)
;
}
return
false
;
}
if
(
commandID
.
LowerCaseEqualsLiteral
(
"
gethtml
"
)
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
if
(
isPaste
&
&
!
nsContentUtils
:
:
PrincipalHasPermission
(
&
aSubjectPrincipal
nsGkAtoms
:
:
clipboardRead
)
)
{
return
false
;
}
nsCOMPtr
<
nsICommandManager
>
cmdMgr
;
GetMidasCommandManager
(
getter_AddRefs
(
cmdMgr
)
)
;
if
(
!
cmdMgr
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
if
(
(
cmdToDispatch
.
EqualsLiteral
(
"
cmd_fontSize
"
)
|
|
cmdToDispatch
.
EqualsLiteral
(
"
cmd_insertImageNoUI
"
)
|
|
cmdToDispatch
.
EqualsLiteral
(
"
cmd_insertLinkNoUI
"
)
|
|
cmdToDispatch
.
EqualsLiteral
(
"
cmd_paragraphState
"
)
)
&
&
paramStr
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
cmdToDispatch
.
EqualsLiteral
(
"
cmd_defaultParagraphSeparator
"
)
&
&
!
paramStr
.
LowerCaseEqualsLiteral
(
"
div
"
)
&
&
!
paramStr
.
LowerCaseEqualsLiteral
(
"
p
"
)
&
&
!
paramStr
.
LowerCaseEqualsLiteral
(
"
br
"
)
)
{
return
false
;
}
bool
enabled
=
false
;
cmdMgr
-
>
IsCommandEnabled
(
cmdToDispatch
.
get
(
)
window
&
enabled
)
;
if
(
!
enabled
)
{
return
false
;
}
if
(
!
isBool
&
&
paramStr
.
IsEmpty
(
)
)
{
rv
=
cmdMgr
-
>
DoCommand
(
cmdToDispatch
.
get
(
)
nullptr
window
)
;
}
else
{
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
if
(
isBool
)
{
rv
=
params
-
>
SetBool
(
"
state_attribute
"
boolVal
)
;
}
else
if
(
cmdToDispatch
.
EqualsLiteral
(
"
cmd_fontFace
"
)
)
{
rv
=
params
-
>
SetString
(
"
state_attribute
"
value
)
;
}
else
if
(
cmdToDispatch
.
EqualsLiteral
(
"
cmd_insertHTML
"
)
|
|
cmdToDispatch
.
EqualsLiteral
(
"
cmd_insertText
"
)
)
{
rv
=
params
-
>
SetString
(
"
state_data
"
value
)
;
}
else
{
rv
=
params
-
>
SetCString
(
"
state_attribute
"
paramStr
)
;
}
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
rv
=
cmdMgr
-
>
DoCommand
(
cmdToDispatch
.
get
(
)
params
window
)
;
}
return
!
rv
.
Failed
(
)
;
}
bool
nsHTMLDocument
:
:
QueryCommandEnabled
(
const
nsAString
&
commandID
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
rv
)
{
nsAutoCString
cmdToDispatch
;
if
(
!
ConvertToMidasInternalCommand
(
commandID
cmdToDispatch
)
)
{
return
false
;
}
bool
isCutCopy
=
commandID
.
LowerCaseEqualsLiteral
(
"
cut
"
)
|
|
commandID
.
LowerCaseEqualsLiteral
(
"
copy
"
)
;
if
(
isCutCopy
)
{
return
nsContentUtils
:
:
IsCutCopyAllowed
(
&
aSubjectPrincipal
)
;
}
bool
restricted
=
commandID
.
LowerCaseEqualsLiteral
(
"
paste
"
)
;
if
(
restricted
&
&
!
nsContentUtils
:
:
IsSystemPrincipal
(
&
aSubjectPrincipal
)
)
{
return
false
;
}
if
(
!
IsEditingOnAfterFlush
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsICommandManager
>
cmdMgr
;
GetMidasCommandManager
(
getter_AddRefs
(
cmdMgr
)
)
;
if
(
!
cmdMgr
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
bool
retval
;
rv
=
cmdMgr
-
>
IsCommandEnabled
(
cmdToDispatch
.
get
(
)
window
&
retval
)
;
return
retval
;
}
bool
nsHTMLDocument
:
:
QueryCommandIndeterm
(
const
nsAString
&
commandID
ErrorResult
&
rv
)
{
nsAutoCString
cmdToDispatch
;
if
(
!
ConvertToMidasInternalCommand
(
commandID
cmdToDispatch
)
)
{
return
false
;
}
if
(
!
IsEditingOnAfterFlush
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsICommandManager
>
cmdMgr
;
GetMidasCommandManager
(
getter_AddRefs
(
cmdMgr
)
)
;
if
(
!
cmdMgr
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
rv
=
cmdMgr
-
>
GetCommandState
(
cmdToDispatch
.
get
(
)
window
params
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
return
params
-
>
GetBool
(
"
state_mixed
"
)
;
}
bool
nsHTMLDocument
:
:
QueryCommandState
(
const
nsAString
&
commandID
ErrorResult
&
rv
)
{
nsAutoCString
cmdToDispatch
paramToCheck
;
bool
dummy
dummy2
;
if
(
!
ConvertToMidasInternalCommand
(
commandID
commandID
cmdToDispatch
paramToCheck
dummy
dummy2
)
)
{
return
false
;
}
if
(
!
IsEditingOnAfterFlush
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsICommandManager
>
cmdMgr
;
GetMidasCommandManager
(
getter_AddRefs
(
cmdMgr
)
)
;
if
(
!
cmdMgr
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
if
(
commandID
.
LowerCaseEqualsLiteral
(
"
usecss
"
)
)
{
return
false
;
}
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
rv
=
cmdMgr
-
>
GetCommandState
(
cmdToDispatch
.
get
(
)
window
params
)
;
if
(
rv
.
Failed
(
)
)
{
return
false
;
}
if
(
cmdToDispatch
.
EqualsLiteral
(
"
cmd_align
"
)
)
{
nsAutoCString
actualAlignmentType
;
rv
=
params
-
>
GetCString
(
"
state_attribute
"
actualAlignmentType
)
;
return
!
rv
.
Failed
(
)
&
&
!
actualAlignmentType
.
IsEmpty
(
)
&
&
paramToCheck
=
=
actualAlignmentType
;
}
return
params
-
>
GetBool
(
"
state_all
"
)
;
}
bool
nsHTMLDocument
:
:
QueryCommandSupported
(
const
nsAString
&
commandID
CallerType
aCallerType
)
{
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
commandID
.
LowerCaseEqualsLiteral
(
"
paste
"
)
)
{
return
false
;
}
if
(
nsContentUtils
:
:
IsCutCopyRestricted
(
)
)
{
if
(
commandID
.
LowerCaseEqualsLiteral
(
"
cut
"
)
|
|
commandID
.
LowerCaseEqualsLiteral
(
"
copy
"
)
)
{
return
false
;
}
}
}
nsAutoCString
cmdToDispatch
;
return
ConvertToMidasInternalCommand
(
commandID
cmdToDispatch
)
;
}
void
nsHTMLDocument
:
:
QueryCommandValue
(
const
nsAString
&
commandID
nsAString
&
aValue
ErrorResult
&
rv
)
{
aValue
.
Truncate
(
)
;
nsAutoCString
cmdToDispatch
paramStr
;
if
(
!
ConvertToMidasInternalCommand
(
commandID
cmdToDispatch
)
)
{
return
;
}
if
(
!
IsEditingOnAfterFlush
(
)
)
{
return
;
}
nsCOMPtr
<
nsICommandManager
>
cmdMgr
;
GetMidasCommandManager
(
getter_AddRefs
(
cmdMgr
)
)
;
if
(
!
cmdMgr
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
if
(
cmdToDispatch
.
EqualsLiteral
(
"
cmd_getContents
"
)
)
{
rv
=
params
-
>
SetBool
(
"
selection_only
"
true
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
rv
=
params
-
>
SetCString
(
"
format
"
NS_LITERAL_CSTRING
(
"
text
/
html
"
)
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
rv
=
cmdMgr
-
>
DoCommand
(
cmdToDispatch
.
get
(
)
params
window
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
params
-
>
GetString
(
"
result
"
aValue
)
;
return
;
}
rv
=
params
-
>
SetCString
(
"
state_attribute
"
paramStr
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
rv
=
cmdMgr
-
>
GetCommandState
(
cmdToDispatch
.
get
(
)
window
params
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
nsAutoCString
result
;
params
-
>
GetCString
(
"
state_attribute
"
result
)
;
CopyUTF8toUTF16
(
result
aValue
)
;
}
nsresult
nsHTMLDocument
:
:
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
{
NS_ASSERTION
(
aNodeInfo
-
>
NodeInfoManager
(
)
=
=
mNodeInfoManager
"
Can
'
t
import
this
document
into
another
document
!
"
)
;
RefPtr
<
nsHTMLDocument
>
clone
=
new
nsHTMLDocument
(
)
;
nsresult
rv
=
CloneDocHelper
(
clone
.
get
(
)
aPreallocateChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
clone
-
>
mLoadFlags
=
mLoadFlags
;
return
CallQueryInterface
(
clone
.
get
(
)
aResult
)
;
}
bool
nsHTMLDocument
:
:
IsEditingOnAfterFlush
(
)
{
nsIDocument
*
doc
=
GetParentDocument
(
)
;
if
(
doc
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
return
IsEditingOn
(
)
;
}
void
nsHTMLDocument
:
:
RemovedFromDocShell
(
)
{
mEditingState
=
eOff
;
nsDocument
:
:
RemovedFromDocShell
(
)
;
}
void
nsHTMLDocument
:
:
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
nsDocument
:
:
DocAddSizeOfExcludingThis
(
aWindowSizes
)
;
}
bool
nsHTMLDocument
:
:
WillIgnoreCharsetOverride
(
)
{
if
(
mEncodingMenuDisabled
)
{
return
true
;
}
if
(
mType
!
=
eHTML
)
{
MOZ_ASSERT
(
mType
=
=
eXHTML
)
;
return
true
;
}
if
(
mCharacterSetSource
>
=
kCharsetFromByteOrderMark
)
{
return
true
;
}
if
(
!
mCharacterSet
-
>
IsAsciiCompatible
(
)
&
&
mCharacterSet
!
=
ISO_2022_JP_ENCODING
)
{
return
true
;
}
nsCOMPtr
<
nsIWyciwygChannel
>
wyciwyg
=
do_QueryInterface
(
mChannel
)
;
if
(
wyciwyg
)
{
return
true
;
}
nsIURI
*
uri
=
GetOriginalURI
(
)
;
if
(
uri
)
{
bool
schemeIs
=
false
;
uri
-
>
SchemeIs
(
"
about
"
&
schemeIs
)
;
if
(
schemeIs
)
{
return
true
;
}
bool
isResource
;
nsresult
rv
=
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
isResource
)
;
if
(
NS_FAILED
(
rv
)
|
|
isResource
)
{
return
true
;
}
}
return
false
;
}
void
nsHTMLDocument
:
:
GetFormsAndFormControls
(
nsContentList
*
*
aFormList
nsContentList
*
*
aFormControlList
)
{
RefPtr
<
ContentListHolder
>
holder
=
mContentListHolder
;
if
(
!
holder
)
{
FlushPendingNotifications
(
FlushType
:
:
Content
)
;
RefPtr
<
nsContentList
>
htmlForms
=
GetExistingForms
(
)
;
if
(
!
htmlForms
)
{
htmlForms
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
form
nsGkAtoms
:
:
form
true
true
)
;
}
RefPtr
<
nsContentList
>
htmlFormControls
=
new
nsContentList
(
this
nsHTMLDocument
:
:
MatchFormControls
nullptr
nullptr
true
nullptr
kNameSpaceID_None
true
true
)
;
holder
=
new
ContentListHolder
(
this
htmlForms
htmlFormControls
)
;
RefPtr
<
ContentListHolder
>
runnable
=
holder
;
if
(
NS_SUCCEEDED
(
Dispatch
(
TaskCategory
:
:
GarbageCollection
runnable
.
forget
(
)
)
)
)
{
mContentListHolder
=
holder
;
}
}
NS_ADDREF
(
*
aFormList
=
holder
-
>
mFormList
)
;
NS_ADDREF
(
*
aFormControlList
=
holder
-
>
mFormControlList
)
;
}
void
nsHTMLDocument
:
:
UserInteractionForTesting
(
)
{
NotifyUserGestureActivation
(
)
;
}
