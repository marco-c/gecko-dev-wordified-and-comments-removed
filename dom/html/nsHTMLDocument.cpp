#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_intl
.
h
"
#
include
"
nsCommandManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsIDocumentLoader
.
h
"
#
include
"
nsIHTMLContentSink
.
h
"
#
include
"
nsIXMLContentSink
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsHTMLStyleSheet
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsParserCIID
.
h
"
#
include
"
mozilla
/
parser
/
PrototypeDocumentParser
.
h
"
#
include
"
mozilla
/
dom
/
PrototypeDocumentContentSink
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
DocumentInlines
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsICachingChannel
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
mozilla
/
dom
/
FallbackEncoding
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
IdentifierMapEntry
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsHtml5Module
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsHtml5TreeOpExecutor
.
h
"
#
include
"
nsHtml5Parser
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsIImageDocument
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDocumentBinding
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
ShadowIncludingTreeIterator
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIStructuredCloneContainer
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
include
"
prtime
.
h
"
static
NS_DEFINE_CID
(
kCParserCID
NS_PARSER_CID
)
;
static
bool
IsAsciiCompatible
(
const
Encoding
*
aEncoding
)
{
return
aEncoding
-
>
IsAsciiCompatible
(
)
|
|
aEncoding
=
=
ISO_2022_JP_ENCODING
;
}
nsresult
NS_NewHTMLDocument
(
Document
*
*
aInstancePtrResult
bool
aLoadedAsData
)
{
RefPtr
<
nsHTMLDocument
>
doc
=
new
nsHTMLDocument
(
)
;
nsresult
rv
=
doc
-
>
Init
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
*
aInstancePtrResult
=
nullptr
;
return
rv
;
}
doc
-
>
SetLoadedAsData
(
aLoadedAsData
)
;
doc
.
forget
(
aInstancePtrResult
)
;
return
NS_OK
;
}
nsHTMLDocument
:
:
nsHTMLDocument
(
)
:
Document
(
"
text
/
html
"
)
mContentListHolder
(
nullptr
)
mNumForms
(
0
)
mLoadFlags
(
0
)
mWarnedWidthHeight
(
false
)
mIsPlainText
(
false
)
{
mType
=
eHTML
;
mDefaultElementType
=
kNameSpaceID_XHTML
;
mCompatMode
=
eCompatibility_NavQuirks
;
}
nsHTMLDocument
:
:
~
nsHTMLDocument
(
)
{
}
JSObject
*
nsHTMLDocument
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLDocument_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsresult
nsHTMLDocument
:
:
Init
(
)
{
nsresult
rv
=
Document
:
:
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CSSLoader
(
)
-
>
SetCompatibilityMode
(
mCompatMode
)
;
return
NS_OK
;
}
void
nsHTMLDocument
:
:
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
{
Document
:
:
Reset
(
aChannel
aLoadGroup
)
;
if
(
aChannel
)
{
aChannel
-
>
GetLoadFlags
(
&
mLoadFlags
)
;
}
}
void
nsHTMLDocument
:
:
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aStoragePrincipal
)
{
mLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
Document
:
:
ResetToURI
(
aURI
aLoadGroup
aPrincipal
aStoragePrincipal
)
;
mImages
=
nullptr
;
mApplets
=
nullptr
;
mEmbeds
=
nullptr
;
mLinks
=
nullptr
;
mAnchors
=
nullptr
;
mScripts
=
nullptr
;
mForms
=
nullptr
;
SetContentTypeInternal
(
nsDependentCString
(
"
text
/
html
"
)
)
;
}
void
nsHTMLDocument
:
:
TryHintCharset
(
nsIContentViewer
*
aCv
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
aCv
)
{
int32_t
requestCharsetSource
;
nsresult
rv
=
aCv
-
>
GetHintCharacterSetSource
(
&
requestCharsetSource
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
kCharsetUninitialized
!
=
requestCharsetSource
)
{
auto
requestCharset
=
aCv
-
>
GetHintCharset
(
)
;
aCv
-
>
SetHintCharacterSetSource
(
(
int32_t
)
(
kCharsetUninitialized
)
)
;
if
(
requestCharsetSource
<
=
aCharsetSource
)
return
;
if
(
requestCharset
&
&
IsAsciiCompatible
(
requestCharset
)
)
{
aCharsetSource
=
requestCharsetSource
;
aEncoding
=
WrapNotNull
(
requestCharset
)
;
}
}
}
}
void
nsHTMLDocument
:
:
TryUserForcedCharset
(
nsIContentViewer
*
aCv
nsIDocShell
*
aDocShell
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
kCharsetFromUserForced
<
=
aCharsetSource
)
return
;
if
(
WillIgnoreCharsetOverride
(
)
|
|
!
IsAsciiCompatible
(
aEncoding
)
)
{
return
;
}
const
Encoding
*
forceCharsetFromDocShell
=
nullptr
;
if
(
aCv
)
{
forceCharsetFromDocShell
=
aCv
-
>
GetForceCharset
(
)
;
}
if
(
forceCharsetFromDocShell
&
&
IsAsciiCompatible
(
forceCharsetFromDocShell
)
)
{
aEncoding
=
WrapNotNull
(
forceCharsetFromDocShell
)
;
aCharsetSource
=
kCharsetFromUserForced
;
return
;
}
if
(
aDocShell
)
{
auto
encoding
=
nsDocShell
:
:
Cast
(
aDocShell
)
-
>
GetForcedCharset
(
)
;
if
(
encoding
)
{
if
(
!
IsAsciiCompatible
(
encoding
)
)
{
return
;
}
aEncoding
=
WrapNotNull
(
encoding
)
;
aCharsetSource
=
kCharsetFromUserForced
;
aDocShell
-
>
SetForcedCharset
(
NS_LITERAL_CSTRING
(
"
"
)
)
;
}
}
}
void
nsHTMLDocument
:
:
TryCacheCharset
(
nsICachingChannel
*
aCachingChannel
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
nsresult
rv
;
if
(
kCharsetFromCache
<
=
aCharsetSource
)
{
return
;
}
nsCString
cachedCharset
;
rv
=
aCachingChannel
-
>
GetCacheTokenCachedCharset
(
cachedCharset
)
;
if
(
NS_FAILED
(
rv
)
|
|
cachedCharset
.
IsEmpty
(
)
)
{
return
;
}
const
Encoding
*
encoding
=
Encoding
:
:
ForLabelNoReplacement
(
cachedCharset
)
;
if
(
!
encoding
)
{
return
;
}
if
(
!
encoding
-
>
IsAsciiCompatible
(
)
&
&
encoding
!
=
ISO_2022_JP_ENCODING
)
{
return
;
}
aEncoding
=
WrapNotNull
(
encoding
)
;
aCharsetSource
=
kCharsetFromCache
;
}
void
nsHTMLDocument
:
:
TryParentCharset
(
nsIDocShell
*
aDocShell
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
!
aDocShell
)
{
return
;
}
if
(
aCharsetSource
>
=
kCharsetFromParentForced
)
{
return
;
}
int32_t
parentSource
;
const
Encoding
*
parentCharset
;
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
;
aDocShell
-
>
GetParentCharset
(
parentCharset
&
parentSource
getter_AddRefs
(
parentPrincipal
)
)
;
if
(
!
parentCharset
)
{
return
;
}
if
(
kCharsetFromParentForced
=
=
parentSource
|
|
kCharsetFromUserForced
=
=
parentSource
)
{
if
(
WillIgnoreCharsetOverride
(
)
|
|
!
IsAsciiCompatible
(
aEncoding
)
|
|
!
IsAsciiCompatible
(
parentCharset
)
)
{
return
;
}
aEncoding
=
WrapNotNull
(
parentCharset
)
;
aCharsetSource
=
kCharsetFromParentForced
;
return
;
}
if
(
aCharsetSource
>
=
kCharsetFromParentFrame
)
{
return
;
}
if
(
kCharsetFromCache
<
=
parentSource
)
{
if
(
!
NodePrincipal
(
)
-
>
Equals
(
parentPrincipal
)
|
|
!
IsAsciiCompatible
(
parentCharset
)
)
{
return
;
}
aEncoding
=
WrapNotNull
(
parentCharset
)
;
aCharsetSource
=
kCharsetFromParentFrame
;
}
}
void
nsHTMLDocument
:
:
TryTLD
(
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
aCharsetSource
>
=
kCharsetFromTopLevelDomain
)
{
return
;
}
if
(
!
StaticPrefs
:
:
intl_charset_fallback_tld
(
)
)
{
return
;
}
if
(
!
mDocumentURI
)
{
return
;
}
nsAutoCString
host
;
mDocumentURI
-
>
GetAsciiHost
(
host
)
;
if
(
host
.
IsEmpty
(
)
)
{
return
;
}
if
(
host
.
Last
(
)
=
=
'
.
'
)
{
host
.
SetLength
(
host
.
Length
(
)
-
1
)
;
if
(
host
.
IsEmpty
(
)
)
{
return
;
}
}
if
(
host
.
Last
(
)
=
=
'
.
'
)
{
return
;
}
int32_t
index
=
host
.
RFindChar
(
'
.
'
)
;
if
(
index
=
=
kNotFound
)
{
return
;
}
nsAutoCString
tld
;
ToLowerCase
(
Substring
(
host
index
+
1
host
.
Length
(
)
-
(
index
+
1
)
)
tld
)
;
if
(
!
FallbackEncoding
:
:
IsParticipatingTopLevelDomain
(
tld
)
)
{
return
;
}
bool
seenNonDigit
=
false
;
for
(
size_t
i
=
0
;
i
<
tld
.
Length
(
)
;
+
+
i
)
{
char
c
=
tld
.
CharAt
(
i
)
;
if
(
c
<
'
0
'
|
|
c
>
'
9
'
)
{
seenNonDigit
=
true
;
break
;
}
}
if
(
!
seenNonDigit
)
{
return
;
}
aCharsetSource
=
kCharsetFromTopLevelDomain
;
aEncoding
=
FallbackEncoding
:
:
FromTopLevelDomain
(
tld
)
;
}
void
nsHTMLDocument
:
:
TryFallback
(
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
)
{
if
(
kCharsetFromFallback
<
=
aCharsetSource
)
return
;
aCharsetSource
=
kCharsetFromFallback
;
aEncoding
=
FallbackEncoding
:
:
FromLocale
(
)
;
}
bool
ShouldUsePrototypeDocument
(
nsIChannel
*
aChannel
Document
*
aDoc
)
{
if
(
!
aChannel
|
|
!
aDoc
|
|
!
StaticPrefs
:
:
dom_prototype_document_cache_enabled
(
)
)
{
return
false
;
}
return
nsContentUtils
:
:
IsChromeDoc
(
aDoc
)
;
}
nsresult
nsHTMLDocument
:
:
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
)
{
if
(
!
aCommand
)
{
MOZ_ASSERT
(
false
"
Command
is
mandatory
"
)
;
return
NS_ERROR_INVALID_POINTER
;
}
if
(
aSink
)
{
MOZ_ASSERT
(
false
"
Got
a
sink
override
.
Should
not
happen
for
HTML
doc
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
if
(
mType
!
=
eHTML
)
{
MOZ_ASSERT
(
mType
=
=
eXHTML
)
;
MOZ_ASSERT
(
false
"
Must
not
set
HTML
doc
to
XHTML
mode
before
load
start
.
"
)
;
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
nsAutoCString
contentType
;
aChannel
-
>
GetContentType
(
contentType
)
;
bool
view
=
!
strcmp
(
aCommand
"
view
"
)
|
|
!
strcmp
(
aCommand
"
external
-
resource
"
)
;
bool
viewSource
=
!
strcmp
(
aCommand
"
view
-
source
"
)
;
bool
asData
=
!
strcmp
(
aCommand
kLoadAsData
)
;
if
(
!
(
view
|
|
viewSource
|
|
asData
)
)
{
MOZ_ASSERT
(
false
"
Bad
parser
command
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
bool
html
=
contentType
.
EqualsLiteral
(
TEXT_HTML
)
;
bool
xhtml
=
!
html
&
&
(
contentType
.
EqualsLiteral
(
APPLICATION_XHTML_XML
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_WAPXHTML_XML
)
|
|
contentType
.
EqualsLiteral
(
APPLICATION_CACHED_XUL
)
|
|
contentType
.
EqualsLiteral
(
TEXT_XUL
)
)
;
mIsPlainText
=
!
html
&
&
!
xhtml
&
&
nsContentUtils
:
:
IsPlainTextType
(
contentType
)
;
if
(
!
(
html
|
|
xhtml
|
|
mIsPlainText
|
|
viewSource
)
)
{
MOZ_ASSERT
(
false
"
Channel
with
bad
content
type
.
"
)
;
return
NS_ERROR_INVALID_ARG
;
}
bool
forceUtf8
=
mIsPlainText
&
&
nsContentUtils
:
:
IsUtf8OnlyPlainTextType
(
contentType
)
;
bool
loadAsHtml5
=
true
;
if
(
!
viewSource
&
&
xhtml
)
{
mType
=
eXHTML
;
SetCompatibilityMode
(
eCompatibility_FullStandards
)
;
loadAsHtml5
=
false
;
}
if
(
loadAsHtml5
&
&
view
)
{
nsCOMPtr
<
nsIURI
>
uri
;
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
&
&
uri
-
>
SchemeIs
(
"
about
"
)
)
{
if
(
uri
-
>
GetSpecOrDefault
(
)
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
loadAsHtml5
=
false
;
}
}
}
nsresult
rv
=
Document
:
:
StartDocumentLoad
(
aCommand
aChannel
aLoadGroup
aContainer
aDocListener
aReset
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
mSecurityInfo
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsICachingChannel
>
cachingChan
=
do_QueryInterface
(
aChannel
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
aContainer
)
)
;
bool
loadWithPrototype
=
false
;
RefPtr
<
nsHtml5Parser
>
html5Parser
;
if
(
loadAsHtml5
)
{
html5Parser
=
nsHtml5Module
:
:
NewHtml5Parser
(
)
;
mParser
=
html5Parser
;
if
(
mIsPlainText
)
{
if
(
viewSource
)
{
html5Parser
-
>
MarkAsNotScriptCreated
(
"
view
-
source
-
plain
"
)
;
}
else
{
html5Parser
-
>
MarkAsNotScriptCreated
(
"
plain
-
text
"
)
;
}
}
else
if
(
viewSource
&
&
!
html
)
{
html5Parser
-
>
MarkAsNotScriptCreated
(
"
view
-
source
-
xml
"
)
;
}
else
{
html5Parser
-
>
MarkAsNotScriptCreated
(
aCommand
)
;
}
}
else
if
(
xhtml
&
&
ShouldUsePrototypeDocument
(
aChannel
this
)
)
{
loadWithPrototype
=
true
;
nsCOMPtr
<
nsIURI
>
originalURI
;
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
originalURI
)
)
;
mParser
=
new
mozilla
:
:
parser
:
:
PrototypeDocumentParser
(
originalURI
this
)
;
}
else
{
mParser
=
do_CreateInstance
(
kCParserCID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
;
if
(
docShell
)
{
docShell
-
>
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentAsItem
)
)
;
}
nsCOMPtr
<
nsIDocShell
>
parent
(
do_QueryInterface
(
parentAsItem
)
)
;
nsCOMPtr
<
nsIContentViewer
>
parentContentViewer
;
if
(
parent
)
{
rv
=
parent
-
>
GetContentViewer
(
getter_AddRefs
(
parentContentViewer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
if
(
docShell
)
{
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
}
if
(
!
cv
)
{
cv
=
parentContentViewer
.
forget
(
)
;
}
nsAutoCString
urlSpec
;
uri
-
>
GetSpec
(
urlSpec
)
;
#
ifdef
DEBUG_charset
printf
(
"
Determining
charset
for
%
s
\
n
"
urlSpec
.
get
(
)
)
;
#
endif
int32_t
charsetSource
;
auto
encoding
=
UTF_8_ENCODING
;
nsHtml5TreeOpExecutor
*
executor
=
nullptr
;
if
(
loadAsHtml5
)
{
executor
=
static_cast
<
nsHtml5TreeOpExecutor
*
>
(
mParser
-
>
GetContentSink
(
)
)
;
}
if
(
forceUtf8
)
{
charsetSource
=
kCharsetFromUtf8OnlyMime
;
}
else
if
(
!
IsHTMLDocument
(
)
|
|
!
docShell
)
{
charsetSource
=
IsHTMLDocument
(
)
?
kCharsetFromFallback
:
kCharsetFromDocTypeDefault
;
TryChannelCharset
(
aChannel
charsetSource
encoding
executor
)
;
}
else
{
NS_ASSERTION
(
docShell
"
Unexpected
null
value
"
)
;
charsetSource
=
kCharsetUninitialized
;
TryChannelCharset
(
aChannel
charsetSource
encoding
executor
)
;
TryUserForcedCharset
(
cv
docShell
charsetSource
encoding
)
;
TryHintCharset
(
cv
charsetSource
encoding
)
;
TryParentCharset
(
docShell
charsetSource
encoding
)
;
if
(
cachingChan
&
&
!
urlSpec
.
IsEmpty
(
)
)
{
TryCacheCharset
(
cachingChan
charsetSource
encoding
)
;
}
TryTLD
(
charsetSource
encoding
)
;
TryFallback
(
charsetSource
encoding
)
;
}
SetDocumentCharacterSetSource
(
charsetSource
)
;
SetDocumentCharacterSet
(
encoding
)
;
if
(
cachingChan
)
{
nsAutoCString
charset
;
encoding
-
>
Name
(
charset
)
;
rv
=
cachingChan
-
>
SetCacheTokenCachedCharset
(
charset
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
cannot
SetMetaDataElement
"
)
;
rv
=
NS_OK
;
}
rv
=
NS_OK
;
nsCOMPtr
<
nsIStreamListener
>
listener
=
mParser
-
>
GetStreamListener
(
)
;
listener
.
forget
(
aDocListener
)
;
#
ifdef
DEBUG_charset
printf
(
"
charset
=
%
s
source
%
d
\
n
"
charset
.
get
(
)
charsetSource
)
;
#
endif
mParser
-
>
SetDocumentCharset
(
encoding
charsetSource
)
;
mParser
-
>
SetCommand
(
aCommand
)
;
if
(
!
IsHTMLDocument
(
)
)
{
MOZ_ASSERT
(
!
loadAsHtml5
)
;
if
(
loadWithPrototype
)
{
nsCOMPtr
<
nsIContentSink
>
sink
;
NS_NewPrototypeDocumentContentSink
(
getter_AddRefs
(
sink
)
this
uri
docShell
aChannel
)
;
mParser
-
>
SetContentSink
(
sink
)
;
}
else
{
nsCOMPtr
<
nsIXMLContentSink
>
xmlsink
;
NS_NewXMLContentSink
(
getter_AddRefs
(
xmlsink
)
this
uri
docShell
aChannel
)
;
mParser
-
>
SetContentSink
(
xmlsink
)
;
}
}
else
{
if
(
loadAsHtml5
)
{
html5Parser
-
>
Initialize
(
this
uri
docShell
aChannel
)
;
}
else
{
nsCOMPtr
<
nsIHTMLContentSink
>
htmlsink
;
NS_NewHTMLContentSink
(
getter_AddRefs
(
htmlsink
)
this
uri
docShell
aChannel
)
;
mParser
-
>
SetContentSink
(
htmlsink
)
;
}
}
mParser
-
>
Parse
(
uri
nullptr
(
void
*
)
this
)
;
return
rv
;
}
bool
nsHTMLDocument
:
:
UseWidthDeviceWidthFallbackViewport
(
)
const
{
if
(
mIsPlainText
)
{
return
true
;
}
return
Document
:
:
UseWidthDeviceWidthFallbackViewport
(
)
;
}
Element
*
nsHTMLDocument
:
:
GetUnfocusedKeyEventTarget
(
)
{
if
(
nsGenericHTMLElement
*
body
=
GetBody
(
)
)
{
return
body
;
}
return
Document
:
:
GetUnfocusedKeyEventTarget
(
)
;
}
bool
nsHTMLDocument
:
:
IsRegistrableDomainSuffixOfOrEqualTo
(
const
nsAString
&
aHostSuffixString
const
nsACString
&
aOrigHost
)
{
if
(
aHostSuffixString
.
IsEmpty
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
origURI
=
CreateInheritingURIForHost
(
aOrigHost
)
;
if
(
!
origURI
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
newURI
=
RegistrableDomainSuffixOfInternal
(
aHostSuffixString
origURI
)
;
if
(
!
newURI
)
{
return
false
;
}
return
true
;
}
void
nsHTMLDocument
:
:
AddedForm
(
)
{
+
+
mNumForms
;
}
void
nsHTMLDocument
:
:
RemovedForm
(
)
{
-
-
mNumForms
;
}
int32_t
nsHTMLDocument
:
:
GetNumFormsSynchronous
(
)
{
return
mNumForms
;
}
bool
nsHTMLDocument
:
:
ResolveName
(
JSContext
*
aCx
const
nsAString
&
aName
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aName
)
;
if
(
!
entry
)
{
return
false
;
}
nsBaseContentList
*
list
=
entry
-
>
GetNameContentList
(
)
;
uint32_t
length
=
list
?
list
-
>
Length
(
)
:
0
;
nsIContent
*
node
;
if
(
length
>
0
)
{
if
(
length
>
1
)
{
if
(
!
ToJSValue
(
aCx
list
aRetval
)
)
{
aError
.
NoteJSContextException
(
aCx
)
;
return
false
;
}
return
true
;
}
node
=
list
-
>
Item
(
0
)
;
}
else
{
Element
*
e
=
entry
-
>
GetIdElement
(
)
;
if
(
!
e
|
|
!
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
e
)
)
{
return
false
;
}
node
=
e
;
}
if
(
!
ToJSValue
(
aCx
node
aRetval
)
)
{
aError
.
NoteJSContextException
(
aCx
)
;
return
false
;
}
return
true
;
}
void
nsHTMLDocument
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
{
for
(
auto
iter
=
mIdentifierMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
IdentifierMapEntry
*
entry
=
iter
.
Get
(
)
;
if
(
entry
-
>
HasNameElement
(
)
|
|
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
aNames
.
AppendElement
(
entry
-
>
GetKeyAsString
(
)
)
;
}
}
}
bool
nsHTMLDocument
:
:
MatchFormControls
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
return
aElement
-
>
IsNodeOfType
(
nsIContent
:
:
eHTML_FORM_CONTROL
)
;
}
nsresult
nsHTMLDocument
:
:
Clone
(
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
)
const
{
NS_ASSERTION
(
aNodeInfo
-
>
NodeInfoManager
(
)
=
=
mNodeInfoManager
"
Can
'
t
import
this
document
into
another
document
!
"
)
;
RefPtr
<
nsHTMLDocument
>
clone
=
new
nsHTMLDocument
(
)
;
nsresult
rv
=
CloneDocHelper
(
clone
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
clone
-
>
mLoadFlags
=
mLoadFlags
;
clone
.
forget
(
aResult
)
;
return
NS_OK
;
}
void
nsHTMLDocument
:
:
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
Document
:
:
DocAddSizeOfExcludingThis
(
aWindowSizes
)
;
}
bool
nsHTMLDocument
:
:
WillIgnoreCharsetOverride
(
)
{
if
(
mEncodingMenuDisabled
)
{
return
true
;
}
if
(
mType
!
=
eHTML
)
{
MOZ_ASSERT
(
mType
=
=
eXHTML
)
;
return
true
;
}
if
(
mCharacterSetSource
>
=
kCharsetFromByteOrderMark
)
{
return
true
;
}
if
(
!
mCharacterSet
-
>
IsAsciiCompatible
(
)
&
&
mCharacterSet
!
=
ISO_2022_JP_ENCODING
)
{
return
true
;
}
nsIURI
*
uri
=
GetOriginalURI
(
)
;
if
(
uri
)
{
if
(
uri
-
>
SchemeIs
(
"
about
"
)
)
{
return
true
;
}
bool
isResource
;
nsresult
rv
=
NS_URIChainHasFlags
(
uri
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
isResource
)
;
if
(
NS_FAILED
(
rv
)
|
|
isResource
)
{
return
true
;
}
}
return
false
;
}
void
nsHTMLDocument
:
:
GetFormsAndFormControls
(
nsContentList
*
*
aFormList
nsContentList
*
*
aFormControlList
)
{
RefPtr
<
ContentListHolder
>
holder
=
mContentListHolder
;
if
(
!
holder
)
{
FlushPendingNotifications
(
FlushType
:
:
Content
)
;
RefPtr
<
nsContentList
>
htmlForms
=
GetExistingForms
(
)
;
if
(
!
htmlForms
)
{
htmlForms
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
form
nsGkAtoms
:
:
form
true
true
)
;
}
RefPtr
<
nsContentList
>
htmlFormControls
=
new
nsContentList
(
this
nsHTMLDocument
:
:
MatchFormControls
nullptr
nullptr
true
nullptr
kNameSpaceID_None
true
true
)
;
holder
=
new
ContentListHolder
(
this
htmlForms
htmlFormControls
)
;
RefPtr
<
ContentListHolder
>
runnable
=
holder
;
if
(
NS_SUCCEEDED
(
Dispatch
(
TaskCategory
:
:
GarbageCollection
runnable
.
forget
(
)
)
)
)
{
mContentListHolder
=
holder
;
}
}
NS_ADDREF
(
*
aFormList
=
holder
-
>
mFormList
)
;
NS_ADDREF
(
*
aFormControlList
=
holder
-
>
mFormControlList
)
;
}
