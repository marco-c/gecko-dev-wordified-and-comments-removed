#
include
"
mozilla
/
dom
/
HTMLButtonElement
.
h
"
#
include
"
HTMLFormSubmissionConstants
.
h
"
#
include
"
mozilla
/
dom
/
HTMLButtonElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormSubmission
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFormControlFrame
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresState
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
define
NS_IN_SUBMIT_CLICK
(
1
<
<
0
)
#
define
NS_OUTER_ACTIVATE_EVENT
(
1
<
<
1
)
NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER
(
Button
)
namespace
mozilla
{
namespace
dom
{
static
const
nsAttrValue
:
:
EnumTable
kButtonTypeTable
[
]
=
{
{
"
button
"
NS_FORM_BUTTON_BUTTON
}
{
"
reset
"
NS_FORM_BUTTON_RESET
}
{
"
submit
"
NS_FORM_BUTTON_SUBMIT
}
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
*
kButtonDefaultType
=
&
kButtonTypeTable
[
2
]
;
HTMLButtonElement
:
:
HTMLButtonElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
FromParser
aFromParser
)
:
nsGenericHTMLFormElementWithState
(
aNodeInfo
kButtonDefaultType
-
>
value
)
mDisabledChanged
(
false
)
mInInternalActivate
(
false
)
mInhibitStateRestoration
(
!
!
(
aFromParser
&
FROM_PARSER_FRAGMENT
)
)
{
AddStatesSilently
(
NS_EVENT_STATE_ENABLED
)
;
}
HTMLButtonElement
:
:
~
HTMLButtonElement
(
)
{
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
HTMLButtonElement
nsGenericHTMLFormElementWithState
mValidity
)
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED
(
HTMLButtonElement
nsGenericHTMLFormElementWithState
nsIConstraintValidation
)
void
HTMLButtonElement
:
:
SetCustomValidity
(
const
nsAString
&
aError
)
{
nsIConstraintValidation
:
:
SetCustomValidity
(
aError
)
;
UpdateState
(
true
)
;
}
void
HTMLButtonElement
:
:
UpdateBarredFromConstraintValidation
(
)
{
SetBarredFromConstraintValidation
(
mType
=
=
NS_FORM_BUTTON_BUTTON
|
|
mType
=
=
NS_FORM_BUTTON_RESET
|
|
IsDisabled
(
)
)
;
}
void
HTMLButtonElement
:
:
FieldSetDisabledChanged
(
bool
aNotify
)
{
nsGenericHTMLFormElementWithState
:
:
FieldSetDisabledChanged
(
aNotify
)
;
UpdateBarredFromConstraintValidation
(
)
;
UpdateState
(
aNotify
)
;
}
NS_IMPL_ELEMENT_CLONE
(
HTMLButtonElement
)
void
HTMLButtonElement
:
:
GetFormEnctype
(
nsAString
&
aFormEncType
)
{
GetEnumAttr
(
nsGkAtoms
:
:
formenctype
"
"
kFormDefaultEnctype
-
>
tag
aFormEncType
)
;
}
void
HTMLButtonElement
:
:
GetFormMethod
(
nsAString
&
aFormMethod
)
{
GetEnumAttr
(
nsGkAtoms
:
:
formmethod
"
"
kFormDefaultMethod
-
>
tag
aFormMethod
)
;
}
void
HTMLButtonElement
:
:
GetType
(
nsAString
&
aType
)
{
GetEnumAttr
(
nsGkAtoms
:
:
type
kButtonDefaultType
-
>
tag
aType
)
;
}
int32_t
HTMLButtonElement
:
:
TabIndexDefault
(
)
{
return
0
;
}
bool
HTMLButtonElement
:
:
IsHTMLFocusable
(
bool
aWithMouse
bool
*
aIsFocusable
int32_t
*
aTabIndex
)
{
if
(
nsGenericHTMLFormElementWithState
:
:
IsHTMLFocusable
(
aWithMouse
aIsFocusable
aTabIndex
)
)
{
return
true
;
}
*
aIsFocusable
=
#
ifdef
XP_MACOSX
(
!
aWithMouse
|
|
nsFocusManager
:
:
sMouseFocusesFormControl
)
&
&
#
endif
!
IsDisabled
(
)
;
return
false
;
}
bool
HTMLButtonElement
:
:
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
type
)
{
return
aResult
.
ParseEnumValue
(
aValue
kButtonTypeTable
false
kButtonDefaultType
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
formmethod
)
{
return
aResult
.
ParseEnumValue
(
aValue
kFormMethodTable
false
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
formenctype
)
{
return
aResult
.
ParseEnumValue
(
aValue
kFormEnctypeTable
false
)
;
}
}
return
nsGenericHTMLElement
:
:
ParseAttribute
(
aNamespaceID
aAttribute
aValue
aMaybeScriptedPrincipal
aResult
)
;
}
bool
HTMLButtonElement
:
:
IsDisabledForEvents
(
EventMessage
aMessage
)
{
nsIFormControlFrame
*
formControlFrame
=
GetFormControlFrame
(
false
)
;
nsIFrame
*
formFrame
=
do_QueryFrame
(
formControlFrame
)
;
return
IsElementDisabledForEvents
(
aMessage
formFrame
)
;
}
nsresult
HTMLButtonElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
false
;
if
(
IsDisabledForEvents
(
aVisitor
.
mEvent
-
>
mMessage
)
)
{
return
NS_OK
;
}
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
bool
outerActivateEvent
=
(
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
)
|
|
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eLegacyDOMActivate
&
&
!
mInInternalActivate
)
)
;
if
(
outerActivateEvent
)
{
aVisitor
.
mItemFlags
|
=
NS_OUTER_ACTIVATE_EVENT
;
if
(
mType
=
=
NS_FORM_BUTTON_SUBMIT
&
&
mForm
)
{
aVisitor
.
mItemFlags
|
=
NS_IN_SUBMIT_CLICK
;
mForm
-
>
OnSubmitClickBegin
(
this
)
;
}
}
return
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
nsresult
HTMLButtonElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
nsresult
rv
=
NS_OK
;
if
(
!
aVisitor
.
mPresContext
)
{
return
rv
;
}
if
(
aVisitor
.
mEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
)
{
InternalUIEvent
actEvent
(
true
eLegacyDOMActivate
mouseEvent
)
;
actEvent
.
mDetail
=
1
;
nsCOMPtr
<
nsIPresShell
>
shell
=
aVisitor
.
mPresContext
-
>
GetPresShell
(
)
;
if
(
shell
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mInInternalActivate
=
true
;
shell
-
>
HandleDOMEventWithTarget
(
this
&
actEvent
&
status
)
;
mInInternalActivate
=
false
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
aVisitor
.
mEventStatus
=
status
;
}
}
}
}
if
(
(
aVisitor
.
mItemFlags
&
NS_IN_SUBMIT_CLICK
)
&
&
mForm
)
{
mForm
-
>
OnSubmitClickEnd
(
)
;
}
if
(
nsEventStatus_eIgnore
=
=
aVisitor
.
mEventStatus
)
{
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyUp
:
{
WidgetKeyboardEvent
*
keyEvent
=
aVisitor
.
mEvent
-
>
AsKeyboardEvent
(
)
;
if
(
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_RETURN
&
&
eKeyPress
=
=
aVisitor
.
mEvent
-
>
mMessage
)
|
|
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
&
&
eKeyUp
=
=
aVisitor
.
mEvent
-
>
mMessage
)
)
{
DispatchSimulatedClick
(
this
aVisitor
.
mEvent
-
>
IsTrusted
(
)
aVisitor
.
mPresContext
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
break
;
default
:
break
;
}
if
(
aVisitor
.
mItemFlags
&
NS_OUTER_ACTIVATE_EVENT
)
{
if
(
mForm
&
&
(
mType
=
=
NS_FORM_BUTTON_SUBMIT
|
|
mType
=
=
NS_FORM_BUTTON_RESET
)
)
{
InternalFormEvent
event
(
true
(
mType
=
=
NS_FORM_BUTTON_RESET
)
?
eFormReset
:
eFormSubmit
)
;
event
.
mOriginator
=
this
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
aVisitor
.
mPresContext
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
(
event
.
mMessage
!
=
eFormSubmit
|
|
mForm
-
>
SubmissionCanProceed
(
this
)
)
)
{
RefPtr
<
HTMLFormElement
>
form
(
mForm
)
;
presShell
-
>
HandleDOMEventWithTarget
(
form
&
event
&
status
)
;
aVisitor
.
mEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
}
}
}
else
if
(
(
aVisitor
.
mItemFlags
&
NS_IN_SUBMIT_CLICK
)
&
&
mForm
)
{
mForm
-
>
FlushPendingSubmission
(
)
;
}
return
rv
;
}
nsresult
HTMLButtonElement
:
:
BindToTree
(
nsIDocument
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
bool
aCompileEventHandlers
)
{
nsresult
rv
=
nsGenericHTMLFormElementWithState
:
:
BindToTree
(
aDocument
aParent
aBindingParent
aCompileEventHandlers
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
UpdateState
(
false
)
;
return
NS_OK
;
}
void
HTMLButtonElement
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
nsGenericHTMLFormElementWithState
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
UpdateState
(
false
)
;
}
NS_IMETHODIMP
HTMLButtonElement
:
:
Reset
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
HTMLButtonElement
:
:
SubmitNamesValues
(
HTMLFormSubmission
*
aFormSubmission
)
{
if
(
aFormSubmission
-
>
GetOriginatingElement
(
)
!
=
this
)
{
return
NS_OK
;
}
if
(
IsDisabled
(
)
)
{
return
NS_OK
;
}
nsAutoString
name
;
GetHTMLAttr
(
nsGkAtoms
:
:
name
name
)
;
if
(
name
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
nsAutoString
value
;
GetHTMLAttr
(
nsGkAtoms
:
:
value
value
)
;
return
aFormSubmission
-
>
AddNameValuePair
(
name
value
)
;
}
void
HTMLButtonElement
:
:
DoneCreatingElement
(
)
{
if
(
!
mInhibitStateRestoration
)
{
nsresult
rv
=
GenerateStateKey
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
RestoreFormControlState
(
)
;
}
}
}
nsresult
HTMLButtonElement
:
:
BeforeSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValueOrString
*
aValue
bool
aNotify
)
{
if
(
aNotify
&
&
aName
=
=
nsGkAtoms
:
:
disabled
&
&
aNameSpaceID
=
=
kNameSpaceID_None
)
{
mDisabledChanged
=
true
;
}
return
nsGenericHTMLFormElementWithState
:
:
BeforeSetAttr
(
aNameSpaceID
aName
aValue
aNotify
)
;
}
nsresult
HTMLButtonElement
:
:
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aSubjectPrincipal
bool
aNotify
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aName
=
=
nsGkAtoms
:
:
type
)
{
if
(
aValue
)
{
mType
=
aValue
-
>
GetEnumValue
(
)
;
}
else
{
mType
=
kButtonDefaultType
-
>
value
;
}
}
if
(
aName
=
=
nsGkAtoms
:
:
type
|
|
aName
=
=
nsGkAtoms
:
:
disabled
)
{
if
(
aName
=
=
nsGkAtoms
:
:
disabled
)
{
UpdateDisabledState
(
aNotify
)
;
}
UpdateBarredFromConstraintValidation
(
)
;
}
}
return
nsGenericHTMLFormElementWithState
:
:
AfterSetAttr
(
aNameSpaceID
aName
aValue
aOldValue
aSubjectPrincipal
aNotify
)
;
}
NS_IMETHODIMP
HTMLButtonElement
:
:
SaveState
(
)
{
if
(
!
mDisabledChanged
)
{
return
NS_OK
;
}
nsPresState
*
state
=
GetPrimaryPresState
(
)
;
if
(
state
)
{
state
-
>
SetDisabled
(
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
)
)
;
}
return
NS_OK
;
}
bool
HTMLButtonElement
:
:
RestoreState
(
nsPresState
*
aState
)
{
if
(
aState
&
&
aState
-
>
IsDisabledSet
(
)
&
&
!
aState
-
>
GetDisabled
(
)
)
{
SetDisabled
(
false
IgnoreErrors
(
)
)
;
}
return
false
;
}
EventStates
HTMLButtonElement
:
:
IntrinsicState
(
)
const
{
EventStates
state
=
nsGenericHTMLFormElementWithState
:
:
IntrinsicState
(
)
;
if
(
IsCandidateForConstraintValidation
(
)
)
{
if
(
IsValid
(
)
)
{
state
|
=
NS_EVENT_STATE_VALID
;
if
(
!
mForm
|
|
!
mForm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_UI_VALID
;
}
}
else
{
state
|
=
NS_EVENT_STATE_INVALID
;
if
(
!
mForm
|
|
!
mForm
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
novalidate
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_UI_INVALID
;
}
}
}
if
(
mForm
&
&
!
mForm
-
>
GetValidity
(
)
&
&
IsSubmitControl
(
)
)
{
state
|
=
NS_EVENT_STATE_MOZ_SUBMITINVALID
;
}
return
state
;
}
JSObject
*
HTMLButtonElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLButtonElementBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
