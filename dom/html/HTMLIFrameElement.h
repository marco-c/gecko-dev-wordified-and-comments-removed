#
ifndef
mozilla_dom_HTMLIFrameElement_h
#
define
mozilla_dom_HTMLIFrameElement_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGenericHTMLFrameElement
.
h
"
#
include
"
nsDOMTokenList
.
h
"
namespace
mozilla
:
:
dom
{
class
FeaturePolicy
;
class
HTMLIFrameElement
final
:
public
nsGenericHTMLFrameElement
{
public
:
explicit
HTMLIFrameElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
FromParser
aFromParser
=
NOT_FROM_PARSER
)
;
NS_IMPL_FROMNODE_HTML_WITH_TAG
(
HTMLIFrameElement
iframe
)
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
HTMLIFrameElement
nsGenericHTMLFrameElement
)
virtual
bool
IsInteractiveHTMLContent
(
)
const
override
{
return
true
;
}
virtual
bool
ParseAttribute
(
int32_t
aNamespaceID
nsAtom
*
aAttribute
const
nsAString
&
aValue
nsIPrincipal
*
aMaybeScriptedPrincipal
nsAttrValue
&
aResult
)
override
;
NS_IMETHOD_
(
bool
)
IsAttributeMapped
(
const
nsAtom
*
aAttribute
)
const
override
;
virtual
nsMapRuleToAttributesFunc
GetAttributeMappingFunction
(
)
const
override
;
virtual
nsresult
Clone
(
dom
:
:
NodeInfo
*
nsINode
*
*
aResult
)
const
override
;
void
NodeInfoChanged
(
Document
*
aOldDoc
)
override
;
void
BindToBrowsingContext
(
BrowsingContext
*
aBrowsingContext
)
;
uint32_t
GetSandboxFlags
(
)
const
;
void
GetSrc
(
nsString
&
aSrc
)
const
{
GetURIAttr
(
nsGkAtoms
:
:
src
nullptr
aSrc
)
;
}
void
SetSrc
(
const
nsAString
&
aSrc
nsIPrincipal
*
aTriggeringPrincipal
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
src
aSrc
aTriggeringPrincipal
aError
)
;
}
void
GetSrcdoc
(
DOMString
&
aSrcdoc
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
srcdoc
aSrcdoc
)
;
}
void
SetSrcdoc
(
const
nsAString
&
aSrcdoc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
srcdoc
aSrcdoc
aError
)
;
}
void
GetName
(
DOMString
&
aName
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
name
aName
)
;
}
void
SetName
(
const
nsAString
&
aName
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
name
aName
aError
)
;
}
nsDOMTokenList
*
Sandbox
(
)
{
if
(
!
mSandbox
)
{
mSandbox
=
new
nsDOMTokenList
(
this
nsGkAtoms
:
:
sandbox
sSupportedSandboxTokens
)
;
}
return
mSandbox
;
}
bool
AllowFullscreen
(
)
const
{
return
GetBoolAttr
(
nsGkAtoms
:
:
allowfullscreen
)
;
}
void
SetAllowFullscreen
(
bool
aAllow
ErrorResult
&
aError
)
{
SetHTMLBoolAttr
(
nsGkAtoms
:
:
allowfullscreen
aAllow
aError
)
;
}
void
GetWidth
(
DOMString
&
aWidth
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
width
aWidth
)
;
}
void
SetWidth
(
const
nsAString
&
aWidth
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
width
aWidth
aError
)
;
}
void
GetHeight
(
DOMString
&
aHeight
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
height
aHeight
)
;
}
void
SetHeight
(
const
nsAString
&
aHeight
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
height
aHeight
aError
)
;
}
using
nsGenericHTMLFrameElement
:
:
GetContentDocument
;
using
nsGenericHTMLFrameElement
:
:
GetContentWindow
;
void
GetAlign
(
DOMString
&
aAlign
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
align
aAlign
)
;
}
void
SetAlign
(
const
nsAString
&
aAlign
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
align
aAlign
aError
)
;
}
void
GetAllow
(
DOMString
&
aAllow
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
allow
aAllow
)
;
}
void
SetAllow
(
const
nsAString
&
aAllow
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
allow
aAllow
aError
)
;
}
void
GetScrolling
(
DOMString
&
aScrolling
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
scrolling
aScrolling
)
;
}
void
SetScrolling
(
const
nsAString
&
aScrolling
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
scrolling
aScrolling
aError
)
;
}
void
GetFrameBorder
(
DOMString
&
aFrameBorder
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
frameborder
aFrameBorder
)
;
}
void
SetFrameBorder
(
const
nsAString
&
aFrameBorder
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
frameborder
aFrameBorder
aError
)
;
}
void
GetLongDesc
(
nsAString
&
aLongDesc
)
const
{
GetURIAttr
(
nsGkAtoms
:
:
longdesc
nullptr
aLongDesc
)
;
}
void
SetLongDesc
(
const
nsAString
&
aLongDesc
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
longdesc
aLongDesc
aError
)
;
}
void
GetMarginWidth
(
DOMString
&
aMarginWidth
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
marginwidth
aMarginWidth
)
;
}
void
SetMarginWidth
(
const
nsAString
&
aMarginWidth
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
marginwidth
aMarginWidth
aError
)
;
}
void
GetMarginHeight
(
DOMString
&
aMarginHeight
)
{
GetHTMLAttr
(
nsGkAtoms
:
:
marginheight
aMarginHeight
)
;
}
void
SetMarginHeight
(
const
nsAString
&
aMarginHeight
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
marginheight
aMarginHeight
aError
)
;
}
void
SetReferrerPolicy
(
const
nsAString
&
aReferrer
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
referrerpolicy
aReferrer
aError
)
;
}
void
GetReferrerPolicy
(
nsAString
&
aReferrer
)
{
GetEnumAttr
(
nsGkAtoms
:
:
referrerpolicy
"
"
aReferrer
)
;
}
Document
*
GetSVGDocument
(
nsIPrincipal
&
aSubjectPrincipal
)
{
return
GetContentDocument
(
aSubjectPrincipal
)
;
}
bool
FullscreenFlag
(
)
const
{
return
mFullscreenFlag
;
}
void
SetFullscreenFlag
(
bool
aValue
)
{
mFullscreenFlag
=
aValue
;
}
mozilla
:
:
dom
:
:
FeaturePolicy
*
FeaturePolicy
(
)
const
;
void
SetLoading
(
const
nsAString
&
aLoading
ErrorResult
&
aError
)
{
SetHTMLAttr
(
nsGkAtoms
:
:
loading
aLoading
aError
)
;
}
void
SetLazyLoading
(
)
;
void
StopLazyLoading
(
)
;
const
LazyLoadFrameResumptionState
&
GetLazyLoadFrameResumptionState
(
)
const
{
return
mLazyLoadState
;
}
protected
:
virtual
~
HTMLIFrameElement
(
)
;
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
virtual
void
AfterSetAttr
(
int32_t
aNameSpaceID
nsAtom
*
aName
const
nsAttrValue
*
aValue
const
nsAttrValue
*
aOldValue
nsIPrincipal
*
aMaybeScriptedPrincipal
bool
aNotify
)
override
;
virtual
void
OnAttrSetButNotChanged
(
int32_t
aNamespaceID
nsAtom
*
aName
const
nsAttrValueOrString
&
aValue
bool
aNotify
)
override
;
nsresult
BindToTree
(
BindContext
&
nsINode
&
aParent
)
override
;
private
:
static
void
MapAttributesIntoRule
(
MappedDeclarationsBuilder
&
)
;
static
const
DOMTokenListSupportedToken
sSupportedSandboxTokens
[
]
;
void
RefreshFeaturePolicy
(
bool
aParseAllowAttribute
)
;
already_AddRefed
<
nsIPrincipal
>
GetFeaturePolicyDefaultOrigin
(
)
const
;
void
AfterMaybeChangeAttr
(
int32_t
aNamespaceID
nsAtom
*
aName
bool
aNotify
)
;
void
MaybeStoreCrossOriginFeaturePolicy
(
)
;
RefPtr
<
dom
:
:
FeaturePolicy
>
mFeaturePolicy
;
RefPtr
<
nsDOMTokenList
>
mSandbox
;
LazyLoadFrameResumptionState
mLazyLoadState
;
void
UpdateLazyLoadState
(
)
;
}
;
}
#
endif
