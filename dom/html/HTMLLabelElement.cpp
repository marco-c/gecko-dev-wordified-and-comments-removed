#
include
"
HTMLLabelElement
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLabelElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Label
)
namespace
mozilla
:
:
dom
{
HTMLLabelElement
:
:
~
HTMLLabelElement
(
)
=
default
;
JSObject
*
HTMLLabelElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLLabelElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_ELEMENT_CLONE
(
HTMLLabelElement
)
HTMLFormElement
*
HTMLLabelElement
:
:
GetForm
(
)
const
{
nsGenericHTMLElement
*
control
=
GetControl
(
)
;
if
(
!
control
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryObject
(
control
)
;
if
(
!
formControl
)
{
return
nullptr
;
}
return
formControl
-
>
GetForm
(
)
;
}
void
HTMLLabelElement
:
:
Focus
(
const
FocusOptions
&
aOptions
const
CallerType
aCallerType
ErrorResult
&
aError
)
{
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
FlushType
:
:
Frames
)
;
if
(
frame
&
&
frame
-
>
IsFocusable
(
)
)
{
return
nsGenericHTMLElement
:
:
Focus
(
aOptions
aCallerType
aError
)
;
}
}
if
(
RefPtr
<
Element
>
elem
=
GetLabeledElement
(
)
)
{
return
elem
-
>
Focus
(
aOptions
aCallerType
aError
)
;
}
}
bool
HTMLLabelElement
:
:
CheckHandleEventPreconditions
(
EventChainVisitor
&
aVisitor
)
{
return
!
mHandlingEvent
&
&
aVisitor
.
mEventStatus
!
=
nsEventStatus_eConsumeDoDefault
&
&
aVisitor
.
mPresContext
&
&
!
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
;
}
void
HTMLLabelElement
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
CheckHandleEventPreconditions
(
aVisitor
)
&
&
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
)
{
aVisitor
.
mWantsActivationBehavior
=
true
;
}
nsGenericHTMLElement
:
:
GetEventTargetParent
(
aVisitor
)
;
}
nsresult
HTMLLabelElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
!
CheckHandleEventPreconditions
(
aVisitor
)
)
{
return
NS_OK
;
}
if
(
aVisitor
.
mEvent
-
>
mMessage
!
=
eMouseDown
)
{
return
NS_OK
;
}
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
MOZ_ASSERT
(
mouseEvent
)
;
nsCOMPtr
<
Element
>
target
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
GetOriginalDOMEventTarget
(
)
)
;
if
(
nsContentUtils
:
:
IsInInteractiveHTMLContent
(
target
this
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
content
=
GetLabeledElement
(
)
;
if
(
!
content
|
|
content
-
>
IsDisabled
(
)
)
{
return
NS_OK
;
}
mHandlingEvent
=
true
;
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseDown
:
if
(
mouseEvent
-
>
mButton
=
=
MouseButton
:
:
ePrimary
)
{
LayoutDeviceIntPoint
*
curPoint
=
new
LayoutDeviceIntPoint
(
mouseEvent
-
>
mRefPoint
)
;
SetProperty
(
nsGkAtoms
:
:
labelMouseDownPtProperty
static_cast
<
void
*
>
(
curPoint
)
nsINode
:
:
DeleteProperty
<
LayoutDeviceIntPoint
>
)
;
}
break
;
default
:
break
;
}
mHandlingEvent
=
false
;
return
NS_OK
;
}
void
HTMLLabelElement
:
:
ActivationBehavior
(
EventChainPostVisitor
&
aVisitor
)
{
if
(
!
CheckHandleEventPreconditions
(
aVisitor
)
)
{
return
;
}
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
MOZ_ASSERT
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
)
;
nsCOMPtr
<
Element
>
target
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
GetOriginalDOMEventTarget
(
)
)
;
if
(
nsContentUtils
:
:
IsInInteractiveHTMLContent
(
target
this
)
)
{
return
;
}
RefPtr
<
Element
>
content
=
GetLabeledElement
(
)
;
if
(
!
content
|
|
content
-
>
IsDisabled
(
)
)
{
return
;
}
mHandlingEvent
=
true
;
LayoutDeviceIntPoint
*
mouseDownPoint
=
static_cast
<
LayoutDeviceIntPoint
*
>
(
GetProperty
(
nsGkAtoms
:
:
labelMouseDownPtProperty
)
)
;
bool
dragSelect
=
false
;
if
(
mouseDownPoint
)
{
LayoutDeviceIntPoint
dragDistance
=
*
mouseDownPoint
;
RemoveProperty
(
nsGkAtoms
:
:
labelMouseDownPtProperty
)
;
dragDistance
-
=
mouseEvent
-
>
mRefPoint
;
const
int
CLICK_DISTANCE
=
2
;
dragSelect
=
dragDistance
.
x
>
CLICK_DISTANCE
|
|
dragDistance
.
x
<
-
CLICK_DISTANCE
|
|
dragDistance
.
y
>
CLICK_DISTANCE
|
|
dragDistance
.
y
<
-
CLICK_DISTANCE
;
}
if
(
dragSelect
|
|
mouseEvent
-
>
IsShift
(
)
|
|
mouseEvent
-
>
IsControl
(
)
|
|
mouseEvent
-
>
IsAlt
(
)
|
|
mouseEvent
-
>
IsMeta
(
)
)
{
mHandlingEvent
=
false
;
return
;
}
if
(
mouseEvent
-
>
mClickCount
<
=
1
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
bool
byMouse
=
(
mouseEvent
-
>
mInputSource
!
=
MouseEvent_Binding
:
:
MOZ_SOURCE_KEYBOARD
)
;
bool
byTouch
=
(
mouseEvent
-
>
mInputSource
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
;
fm
-
>
SetFocus
(
content
nsIFocusManager
:
:
FLAG_BYMOVEFOCUS
|
(
byMouse
?
nsIFocusManager
:
:
FLAG_BYMOUSE
:
0
)
|
(
byTouch
?
nsIFocusManager
:
:
FLAG_BYTOUCH
:
0
)
)
;
}
}
nsEventStatus
status
=
aVisitor
.
mEventStatus
;
EventFlags
eventFlags
;
eventFlags
.
mMultipleActionsPrevented
=
true
;
DispatchClickEvent
(
aVisitor
.
mPresContext
mouseEvent
content
false
&
eventFlags
&
status
)
;
mouseEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
mHandlingEvent
=
false
;
}
Result
<
bool
nsresult
>
HTMLLabelElement
:
:
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
{
if
(
!
aKeyCausesActivation
)
{
RefPtr
<
Element
>
element
=
GetLabeledElement
(
)
;
if
(
element
)
{
return
element
-
>
PerformAccesskey
(
aKeyCausesActivation
aIsTrustedEvent
)
;
}
return
Err
(
NS_ERROR_ABORT
)
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
eForUncomposedDoc
)
;
if
(
!
presContext
)
{
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
AutoHandlingUserInputStatePusher
userInputStatePusher
(
aIsTrustedEvent
)
;
AutoPopupStatePusher
popupStatePusher
(
aIsTrustedEvent
?
PopupBlocker
:
:
openAllowed
:
PopupBlocker
:
:
openAbused
)
;
DispatchSimulatedClick
(
this
aIsTrustedEvent
presContext
)
;
return
true
;
}
nsGenericHTMLElement
*
HTMLLabelElement
:
:
GetLabeledElement
(
)
const
{
nsAutoString
elementId
;
if
(
!
GetAttr
(
nsGkAtoms
:
:
_for
elementId
)
)
{
return
GetFirstLabelableDescendant
(
)
;
}
Element
*
element
=
nullptr
;
if
(
ShadowRoot
*
shadowRoot
=
GetContainingShadow
(
)
)
{
element
=
shadowRoot
-
>
GetElementById
(
elementId
)
;
}
else
if
(
Document
*
doc
=
GetUncomposedDoc
(
)
)
{
element
=
doc
-
>
GetElementById
(
elementId
)
;
}
else
{
element
=
nsContentUtils
:
:
MatchElementId
(
SubtreeRoot
(
)
-
>
AsContent
(
)
elementId
)
;
}
if
(
element
&
&
element
-
>
IsLabelable
(
)
)
{
return
static_cast
<
nsGenericHTMLElement
*
>
(
element
)
;
}
return
nullptr
;
}
nsGenericHTMLElement
*
HTMLLabelElement
:
:
GetFirstLabelableDescendant
(
)
const
{
for
(
nsIContent
*
cur
=
nsINode
:
:
GetFirstChild
(
)
;
cur
;
cur
=
cur
-
>
GetNextNode
(
this
)
)
{
Element
*
element
=
Element
:
:
FromNode
(
cur
)
;
if
(
element
&
&
element
-
>
IsLabelable
(
)
)
{
return
static_cast
<
nsGenericHTMLElement
*
>
(
element
)
;
}
}
return
nullptr
;
}
}
