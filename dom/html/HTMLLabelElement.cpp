#
include
"
HTMLLabelElement
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLabelElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
NS_IMPL_NS_NEW_HTML_ELEMENT
(
Label
)
namespace
mozilla
{
namespace
dom
{
HTMLLabelElement
:
:
~
HTMLLabelElement
(
)
{
}
JSObject
*
HTMLLabelElement
:
:
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
HTMLLabelElement_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
NS_IMPL_ELEMENT_CLONE
(
HTMLLabelElement
)
HTMLFormElement
*
HTMLLabelElement
:
:
GetForm
(
)
const
{
nsGenericHTMLElement
*
control
=
GetControl
(
)
;
if
(
!
control
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryObject
(
control
)
;
if
(
!
formControl
)
{
return
nullptr
;
}
return
static_cast
<
HTMLFormElement
*
>
(
formControl
-
>
GetFormElement
(
)
)
;
}
void
HTMLLabelElement
:
:
Focus
(
ErrorResult
&
aError
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
RefPtr
<
Element
>
elem
=
GetLabeledElement
(
)
;
if
(
elem
)
{
fm
-
>
SetFocus
(
elem
0
)
;
}
}
}
static
bool
InInteractiveHTMLContent
(
nsIContent
*
aContent
nsIContent
*
aStop
)
{
nsIContent
*
content
=
aContent
;
while
(
content
&
&
content
!
=
aStop
)
{
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
IsInteractiveHTMLContent
(
true
)
)
{
return
true
;
}
content
=
content
-
>
GetParent
(
)
;
}
return
false
;
}
nsresult
HTMLLabelElement
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
WidgetMouseEvent
*
mouseEvent
=
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mHandlingEvent
|
|
(
!
(
mouseEvent
&
&
mouseEvent
-
>
IsLeftClickEvent
(
)
)
&
&
aVisitor
.
mEvent
-
>
mMessage
!
=
eMouseDown
)
|
|
aVisitor
.
mEventStatus
=
=
nsEventStatus_eConsumeNoDefault
|
|
!
aVisitor
.
mPresContext
|
|
aVisitor
.
mEvent
-
>
mFlags
.
mMultipleActionsPrevented
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
target
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mTarget
)
;
if
(
InInteractiveHTMLContent
(
target
this
)
)
{
return
NS_OK
;
}
RefPtr
<
Element
>
content
=
GetLabeledElement
(
)
;
if
(
content
)
{
mHandlingEvent
=
true
;
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eMouseDown
:
if
(
mouseEvent
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
{
LayoutDeviceIntPoint
*
curPoint
=
new
LayoutDeviceIntPoint
(
mouseEvent
-
>
mRefPoint
)
;
SetProperty
(
nsGkAtoms
:
:
labelMouseDownPtProperty
static_cast
<
void
*
>
(
curPoint
)
nsINode
:
:
DeleteProperty
<
LayoutDeviceIntPoint
>
)
;
}
break
;
case
eMouseClick
:
if
(
mouseEvent
-
>
IsLeftClickEvent
(
)
)
{
LayoutDeviceIntPoint
*
mouseDownPoint
=
static_cast
<
LayoutDeviceIntPoint
*
>
(
GetProperty
(
nsGkAtoms
:
:
labelMouseDownPtProperty
)
)
;
bool
dragSelect
=
false
;
if
(
mouseDownPoint
)
{
LayoutDeviceIntPoint
dragDistance
=
*
mouseDownPoint
;
DeleteProperty
(
nsGkAtoms
:
:
labelMouseDownPtProperty
)
;
dragDistance
-
=
mouseEvent
-
>
mRefPoint
;
const
int
CLICK_DISTANCE
=
2
;
dragSelect
=
dragDistance
.
x
>
CLICK_DISTANCE
|
|
dragDistance
.
x
<
-
CLICK_DISTANCE
|
|
dragDistance
.
y
>
CLICK_DISTANCE
|
|
dragDistance
.
y
<
-
CLICK_DISTANCE
;
}
if
(
dragSelect
|
|
mouseEvent
-
>
IsShift
(
)
|
|
mouseEvent
-
>
IsControl
(
)
|
|
mouseEvent
-
>
IsAlt
(
)
|
|
mouseEvent
-
>
IsMeta
(
)
)
{
break
;
}
if
(
mouseEvent
-
>
mClickCount
<
=
1
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
bool
byMouse
=
(
mouseEvent
-
>
inputSource
!
=
MouseEvent_Binding
:
:
MOZ_SOURCE_KEYBOARD
)
;
bool
byTouch
=
(
mouseEvent
-
>
inputSource
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
;
fm
-
>
SetFocus
(
content
nsIFocusManager
:
:
FLAG_BYMOVEFOCUS
|
(
byMouse
?
nsIFocusManager
:
:
FLAG_BYMOUSE
:
0
)
|
(
byTouch
?
nsIFocusManager
:
:
FLAG_BYTOUCH
:
0
)
)
;
}
}
nsEventStatus
status
=
aVisitor
.
mEventStatus
;
EventFlags
eventFlags
;
eventFlags
.
mMultipleActionsPrevented
=
true
;
DispatchClickEvent
(
aVisitor
.
mPresContext
mouseEvent
content
false
&
eventFlags
&
status
)
;
mouseEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
break
;
default
:
break
;
}
mHandlingEvent
=
false
;
}
return
NS_OK
;
}
bool
HTMLLabelElement
:
:
PerformAccesskey
(
bool
aKeyCausesActivation
bool
aIsTrustedEvent
)
{
if
(
!
aKeyCausesActivation
)
{
RefPtr
<
Element
>
element
=
GetLabeledElement
(
)
;
if
(
element
)
{
return
element
-
>
PerformAccesskey
(
aKeyCausesActivation
aIsTrustedEvent
)
;
}
}
else
{
nsPresContext
*
presContext
=
GetPresContext
(
eForUncomposedDoc
)
;
if
(
!
presContext
)
{
return
false
;
}
WidgetMouseEvent
event
(
aIsTrustedEvent
eMouseClick
nullptr
WidgetMouseEvent
:
:
eReal
)
;
event
.
inputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_KEYBOARD
;
nsAutoPopupStatePusher
popupStatePusher
(
aIsTrustedEvent
?
PopupBlocker
:
:
openAllowed
:
PopupBlocker
:
:
openAbused
)
;
EventDispatcher
:
:
Dispatch
(
static_cast
<
nsIContent
*
>
(
this
)
presContext
&
event
)
;
}
return
aKeyCausesActivation
;
}
nsGenericHTMLElement
*
HTMLLabelElement
:
:
GetLabeledElement
(
)
const
{
nsAutoString
elementId
;
if
(
!
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
elementId
)
)
{
return
GetFirstLabelableDescendant
(
)
;
}
Element
*
element
=
nullptr
;
if
(
ShadowRoot
*
shadowRoot
=
GetContainingShadow
(
)
)
{
element
=
shadowRoot
-
>
GetElementById
(
elementId
)
;
}
else
if
(
nsIDocument
*
doc
=
GetUncomposedDoc
(
)
)
{
element
=
doc
-
>
GetElementById
(
elementId
)
;
}
else
{
element
=
nsContentUtils
:
:
MatchElementId
(
SubtreeRoot
(
)
-
>
AsContent
(
)
elementId
)
;
}
if
(
element
&
&
element
-
>
IsLabelable
(
)
)
{
return
static_cast
<
nsGenericHTMLElement
*
>
(
element
)
;
}
return
nullptr
;
}
nsGenericHTMLElement
*
HTMLLabelElement
:
:
GetFirstLabelableDescendant
(
)
const
{
for
(
nsIContent
*
cur
=
nsINode
:
:
GetFirstChild
(
)
;
cur
;
cur
=
cur
-
>
GetNextNode
(
this
)
)
{
Element
*
element
=
Element
:
:
FromNode
(
cur
)
;
if
(
element
&
&
element
-
>
IsLabelable
(
)
)
{
return
static_cast
<
nsGenericHTMLElement
*
>
(
element
)
;
}
}
return
nullptr
;
}
}
}
