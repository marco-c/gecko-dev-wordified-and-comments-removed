#
ifndef
mozilla_dom_TCPSocketChild_h
#
define
mozilla_dom_TCPSocketChild_h
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
net
/
PTCPSocketChild
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsICancelable
.
h
"
class
nsITCPSocketCallback
;
namespace
IPC
{
bool
DeserializeArrayBuffer
(
JSContext
*
cx
const
nsTArray
<
uint8_t
>
&
aBuffer
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
;
}
namespace
mozilla
{
namespace
dom
{
class
TCPSocket
;
class
TCPSocketChildBase
:
public
nsISupports
{
public
:
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
TCPSocketChildBase
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
void
AddIPDLReference
(
)
;
void
ReleaseIPDLReference
(
)
;
protected
:
TCPSocketChildBase
(
)
;
virtual
~
TCPSocketChildBase
(
)
;
nsCOMPtr
<
nsITCPSocketCallback
>
mSocket
;
bool
mIPCOpen
;
}
;
class
TCPSocketChild
:
public
mozilla
:
:
net
:
:
PTCPSocketChild
public
TCPSocketChildBase
{
public
:
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
)
override
;
TCPSocketChild
(
const
nsAString
&
aHost
const
uint16_t
&
aPort
nsIEventTarget
*
aTarget
)
;
~
TCPSocketChild
(
)
;
void
SendOpen
(
nsITCPSocketCallback
*
aSocket
bool
aUseSSL
bool
aUseArrayBuffers
)
;
void
SendSend
(
const
nsACString
&
aData
)
;
nsresult
SendSend
(
const
ArrayBuffer
&
aData
uint32_t
aByteOffset
uint32_t
aByteLength
)
;
void
SetSocket
(
TCPSocket
*
aSocket
)
;
void
GetHost
(
nsAString
&
aHost
)
;
void
GetPort
(
uint16_t
*
aPort
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvCallback
(
const
nsString
&
aType
const
CallbackData
&
aData
const
uint32_t
&
aReadyState
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvRequestDelete
(
)
;
mozilla
:
:
ipc
:
:
IPCResult
RecvUpdateBufferedAmount
(
const
uint32_t
&
aBufferred
const
uint32_t
&
aTrackingNumber
)
;
private
:
nsString
mHost
;
uint16_t
mPort
;
nsCOMPtr
<
nsIEventTarget
>
mIPCEventTarget
;
}
;
}
}
#
endif
