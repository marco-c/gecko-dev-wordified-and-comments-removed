#
ifndef
mozilla_dom_TCPSocket_h
#
define
mozilla_dom_TCPSocket_h
#
include
"
mozilla
/
dom
/
TCPSocketBinding
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
nsIProxyInfo
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsITCPSocketCallback
.
h
"
#
include
"
nsIProtocolProxyCallback
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
class
nsISocketTransport
;
class
nsIInputStreamPump
;
class
nsIScriptableInputStream
;
class
nsIBinaryInputStream
;
class
nsIMultiplexInputStream
;
class
nsIAsyncStreamCopier
;
class
nsIInputStream
;
class
nsINetworkInfo
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
struct
ServerSocketOptions
;
class
TCPServerSocket
;
class
TCPSocketChild
;
class
TCPSocketParent
;
class
LegacyMozTCPSocket
:
public
nsISupports
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
LegacyMozTCPSocket
)
explicit
LegacyMozTCPSocket
(
nsPIDOMWindowInner
*
aWindow
)
;
already_AddRefed
<
TCPServerSocket
>
Listen
(
uint16_t
aPort
const
ServerSocketOptions
&
aOptions
uint16_t
aBacklog
ErrorResult
&
aRv
)
;
already_AddRefed
<
TCPSocket
>
Open
(
const
nsAString
&
aHost
uint16_t
aPort
const
SocketOptions
&
aOptions
ErrorResult
&
aRv
)
;
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
;
private
:
virtual
~
LegacyMozTCPSocket
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
}
;
class
TCPSocket
final
:
public
DOMEventTargetHelper
public
nsIStreamListener
public
nsITransportEventSink
public
nsIInputStreamCallback
public
nsIObserver
public
nsSupportsWeakReference
public
nsITCPSocketCallback
public
nsIProtocolProxyCallback
{
public
:
TCPSocket
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aHost
uint16_t
aPort
bool
aSsl
bool
aUseArrayBuffers
)
;
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
TCPSocket
DOMEventTargetHelper
)
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITRANSPORTEVENTSINK
NS_DECL_NSIINPUTSTREAMCALLBACK
NS_DECL_NSIOBSERVER
NS_DECL_NSITCPSOCKETCALLBACK
NS_DECL_NSIPROTOCOLPROXYCALLBACK
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
bool
ShouldTCPSocketExist
(
JSContext
*
aCx
JSObject
*
aGlobal
)
;
nsISocketTransport
*
GetTransport
(
)
const
{
return
mTransport
.
get
(
)
;
}
void
GetHost
(
nsAString
&
aHost
)
;
uint32_t
Port
(
)
const
;
bool
Ssl
(
)
const
;
uint64_t
BufferedAmount
(
)
const
{
return
mBufferedAmount
;
}
void
Suspend
(
)
;
void
Resume
(
ErrorResult
&
aRv
)
;
void
Close
(
)
;
void
CloseImmediately
(
)
;
bool
Send
(
const
nsACString
&
aData
ErrorResult
&
aRv
)
;
bool
Send
(
const
ArrayBuffer
&
aData
uint32_t
aByteOffset
const
Optional
<
uint32_t
>
&
aByteLength
ErrorResult
&
aRv
)
;
TCPReadyState
ReadyState
(
)
;
TCPSocketBinaryType
BinaryType
(
)
const
;
void
UpgradeToSecure
(
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
TCPSocket
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aHost
uint16_t
aPort
const
SocketOptions
&
aOptions
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
TCPSocket
>
CreateAcceptedSocket
(
nsIGlobalObject
*
aGlobal
nsISocketTransport
*
aTransport
bool
aUseArrayBuffers
)
;
static
already_AddRefed
<
TCPSocket
>
CreateAcceptedSocket
(
nsIGlobalObject
*
aGlobal
TCPSocketChild
*
aBridge
bool
aUseArrayBuffers
)
;
void
SetSocketBridgeParent
(
TCPSocketParent
*
aBridgeParent
)
;
static
bool
SocketEnabled
(
)
;
IMPL_EVENT_HANDLER
(
open
)
;
IMPL_EVENT_HANDLER
(
drain
)
;
IMPL_EVENT_HANDLER
(
data
)
;
IMPL_EVENT_HANDLER
(
error
)
;
IMPL_EVENT_HANDLER
(
close
)
;
nsresult
Init
(
nsIProxyInfo
*
aProxyInfo
)
;
void
NotifyCopyComplete
(
nsresult
aStatus
)
;
nsresult
InitWithUnconnectedTransport
(
nsISocketTransport
*
aTransport
)
;
private
:
~
TCPSocket
(
)
;
void
InitWithSocketChild
(
TCPSocketChild
*
aSocketBridge
)
;
nsresult
InitWithTransport
(
nsISocketTransport
*
aTransport
)
;
nsresult
CreateStream
(
)
;
nsresult
CreateInputStreamPump
(
)
;
bool
Send
(
nsIInputStream
*
aStream
uint32_t
aByteLength
)
;
nsresult
EnsureCopying
(
)
;
void
CalculateBufferedAmount
(
)
;
void
ActivateTLSHelper
(
)
;
void
ActivateTLS
(
)
;
nsresult
MaybeReportErrorAndCloseIfOpen
(
nsresult
status
)
;
nsresult
FireDataEvent
(
JSContext
*
aCx
const
nsAString
&
aType
JS
:
:
Handle
<
JS
:
:
Value
>
aData
)
;
void
CloseHelper
(
bool
waitForUnsentData
)
;
nsresult
ResolveProxy
(
)
;
TCPReadyState
mReadyState
;
bool
mUseArrayBuffers
;
nsString
mHost
;
uint16_t
mPort
;
bool
mSsl
;
RefPtr
<
TCPSocketChild
>
mSocketBridgeChild
;
RefPtr
<
TCPSocketParent
>
mSocketBridgeParent
;
nsCOMPtr
<
nsISocketTransport
>
mTransport
;
nsCOMPtr
<
nsIInputStream
>
mSocketInputStream
;
nsCOMPtr
<
nsIOutputStream
>
mSocketOutputStream
;
nsCOMPtr
<
nsICancelable
>
mProxyRequest
;
nsCOMPtr
<
nsIInputStreamPump
>
mInputStreamPump
;
nsCOMPtr
<
nsIScriptableInputStream
>
mInputStreamScriptable
;
nsCOMPtr
<
nsIBinaryInputStream
>
mInputStreamBinary
;
bool
mAsyncCopierActive
;
bool
mWaitingForDrain
;
uint64_t
mInnerWindowID
;
uint64_t
mBufferedAmount
;
uint32_t
mSuspendCount
;
uint32_t
mTrackingNumber
;
bool
mWaitingForStartTLS
;
nsTArray
<
nsCOMPtr
<
nsIInputStream
>
>
mPendingDataAfterStartTLS
;
nsTArray
<
nsCOMPtr
<
nsIInputStream
>
>
mPendingData
;
bool
mObserversActive
;
}
;
}
}
#
endif
