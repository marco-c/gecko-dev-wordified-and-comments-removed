"
use
strict
"
;
const
isOSX
=
Services
.
appinfo
.
OS
=
=
=
"
Darwin
"
;
const
testConnectingToNonListeningPort
=
!
isOSX
;
const
SERVER_BACKLOG
=
-
1
;
const
SOCKET_EVENTS
=
[
"
open
"
"
data
"
"
drain
"
"
error
"
"
close
"
]
;
function
concatUint8Arrays
(
a
b
)
{
let
newArr
=
new
Uint8Array
(
a
.
length
+
b
.
length
)
;
newArr
.
set
(
a
0
)
;
newArr
.
set
(
b
a
.
length
)
;
return
newArr
;
}
function
assertUint8ArraysEqual
(
a
b
comparingWhat
)
{
if
(
a
.
length
!
=
=
b
.
length
)
{
ok
(
false
comparingWhat
+
"
arrays
do
not
have
the
same
length
;
"
+
a
.
length
+
"
versus
"
+
b
.
length
)
;
return
;
}
for
(
let
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
if
(
a
[
i
]
!
=
=
b
[
i
]
)
{
ok
(
false
comparingWhat
+
"
arrays
differ
at
index
"
+
i
+
a
[
i
]
+
"
versus
"
+
b
[
i
]
)
;
return
;
}
}
ok
(
true
comparingWhat
+
"
arrays
were
equivalent
.
"
)
;
}
function
listenForEventsOnSocket
(
socket
socketType
)
{
let
wantDataLength
=
null
;
let
wantDataAndClose
=
false
;
let
pendingResolve
=
null
;
let
receivedEvents
=
[
]
;
let
receivedData
=
null
;
let
handleGenericEvent
=
function
(
event
)
{
dump
(
"
(
"
+
socketType
+
"
event
:
"
+
event
.
type
+
"
)
\
n
"
)
;
if
(
pendingResolve
&
&
wantDataLength
=
=
=
null
)
{
pendingResolve
(
event
)
;
pendingResolve
=
null
;
}
else
{
receivedEvents
.
push
(
event
)
;
}
}
;
socket
.
onopen
=
handleGenericEvent
;
socket
.
ondrain
=
handleGenericEvent
;
socket
.
onerror
=
handleGenericEvent
;
socket
.
onclose
=
function
(
event
)
{
if
(
!
wantDataAndClose
)
{
handleGenericEvent
(
event
)
;
}
else
if
(
pendingResolve
)
{
dump
(
"
(
"
+
socketType
+
"
event
:
close
)
\
n
"
)
;
pendingResolve
(
receivedData
)
;
pendingResolve
=
null
;
wantDataAndClose
=
false
;
}
}
;
socket
.
ondata
=
function
(
event
)
{
dump
(
"
(
"
+
socketType
+
"
event
:
"
+
event
.
type
+
"
length
:
"
+
event
.
data
.
byteLength
+
"
)
\
n
"
)
;
ok
(
socketCompartmentInstanceOfArrayBuffer
(
event
.
data
)
"
payload
is
ArrayBuffer
"
)
;
var
arr
=
new
Uint8Array
(
event
.
data
)
;
if
(
receivedData
=
=
=
null
)
{
receivedData
=
arr
;
}
else
{
receivedData
=
concatUint8Arrays
(
receivedData
arr
)
;
}
if
(
wantDataLength
!
=
=
null
&
&
receivedData
.
length
>
=
wantDataLength
)
{
pendingResolve
(
receivedData
)
;
pendingResolve
=
null
;
receivedData
=
null
;
wantDataLength
=
null
;
}
}
;
return
{
waitForEvent
(
)
{
if
(
pendingResolve
)
{
throw
new
Error
(
"
only
one
wait
allowed
at
a
time
.
"
)
;
}
if
(
receivedEvents
.
length
)
{
return
Promise
.
resolve
(
receivedEvents
.
shift
(
)
)
;
}
dump
(
"
(
"
+
socketType
+
"
waiting
for
event
)
\
n
"
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
pendingResolve
=
resolve
;
}
)
;
}
waitForDataWithAtLeastLength
(
length
)
{
if
(
pendingResolve
)
{
throw
new
Error
(
"
only
one
wait
allowed
at
a
time
.
"
)
;
}
if
(
receivedData
&
&
receivedData
.
length
>
=
length
)
{
let
promise
=
Promise
.
resolve
(
receivedData
)
;
receivedData
=
null
;
return
promise
;
}
dump
(
"
(
"
+
socketType
+
"
waiting
for
"
+
length
+
"
bytes
)
\
n
"
)
;
return
new
Promise
(
function
(
resolve
reject
)
{
pendingResolve
=
resolve
;
wantDataLength
=
length
;
}
)
;
}
waitForAnyDataAndClose
(
)
{
if
(
pendingResolve
)
{
throw
new
Error
(
"
only
one
wait
allowed
at
a
time
.
"
)
;
}
return
new
Promise
(
function
(
resolve
reject
)
{
pendingResolve
=
resolve
;
receivedData
=
new
Uint8Array
(
)
;
wantDataAndClose
=
true
;
}
)
;
}
}
;
}
function
waitForConnection
(
listeningServer
)
{
return
new
Promise
(
function
(
resolve
reject
)
{
listeningServer
.
onconnect
=
function
(
event
)
{
listeningServer
.
onconnect
=
function
(
)
{
ok
(
false
"
Received
a
connection
when
not
expecting
one
.
"
)
;
}
;
ok
(
true
"
Listening
server
accepted
socket
"
)
;
resolve
(
{
socket
:
event
.
socket
queue
:
listenForEventsOnSocket
(
event
.
socket
"
server
"
)
}
)
;
}
;
}
)
;
}
function
defer
(
)
{
var
deferred
=
{
}
;
deferred
.
promise
=
new
Promise
(
function
(
resolve
reject
)
{
deferred
.
resolve
=
resolve
;
deferred
.
reject
=
reject
;
}
)
;
return
deferred
;
}
async
function
test_basics
(
)
{
let
serverPort
=
8085
;
let
listeningServer
=
createServer
(
serverPort
{
binaryType
:
"
arraybuffer
"
}
SERVER_BACKLOG
)
;
let
connectedPromise
=
waitForConnection
(
listeningServer
)
;
let
clientSocket
=
createSocket
(
"
127
.
0
.
0
.
1
"
serverPort
{
binaryType
:
"
arraybuffer
"
}
)
;
let
clientQueue
=
listenForEventsOnSocket
(
clientSocket
"
client
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
open
"
"
got
open
event
"
)
;
is
(
clientSocket
.
readyState
"
open
"
"
client
readyState
is
open
"
)
;
let
{
socket
:
serverSocket
queue
:
serverQueue
}
=
await
connectedPromise
;
is
(
serverSocket
.
readyState
"
open
"
"
server
readyState
is
open
"
)
;
let
smallUint8Array
=
new
Uint8Array
(
256
)
;
for
(
let
i
=
0
;
i
<
smallUint8Array
.
length
;
i
+
+
)
{
smallUint8Array
[
i
]
=
i
;
}
is
(
clientSocket
.
send
(
smallUint8Array
.
buffer
0
smallUint8Array
.
length
)
true
"
Client
sending
less
than
64k
buffer
should
not
be
full
.
"
)
;
let
serverReceived
=
await
serverQueue
.
waitForDataWithAtLeastLength
(
256
)
;
assertUint8ArraysEqual
(
serverReceived
smallUint8Array
"
Server
received
/
client
sent
"
)
;
is
(
serverSocket
.
send
(
smallUint8Array
.
buffer
0
smallUint8Array
.
length
)
true
"
Server
sending
less
than
64k
buffer
should
not
be
full
.
"
)
;
let
clientReceived
=
await
clientQueue
.
waitForDataWithAtLeastLength
(
256
)
;
assertUint8ArraysEqual
(
clientReceived
smallUint8Array
"
Client
received
/
server
sent
"
)
;
is
(
clientSocket
.
send
(
smallUint8Array
.
buffer
0
7
)
true
"
Client
sending
less
than
64k
buffer
should
not
be
full
.
"
)
;
is
(
clientSocket
.
send
(
smallUint8Array
.
buffer
7
smallUint8Array
.
length
-
7
)
true
"
Client
sending
less
than
64k
buffer
should
not
be
full
.
"
)
;
serverReceived
=
await
serverQueue
.
waitForDataWithAtLeastLength
(
256
)
;
assertUint8ArraysEqual
(
serverReceived
smallUint8Array
"
Server
received
/
client
sent
"
)
;
is
(
serverSocket
.
send
(
smallUint8Array
.
buffer
0
7
)
true
"
Server
sending
less
than
64k
buffer
should
not
be
full
.
"
)
;
is
(
serverSocket
.
send
(
smallUint8Array
.
buffer
7
smallUint8Array
.
length
-
7
)
true
"
Server
sending
less
than
64k
buffer
should
not
be
full
.
"
)
;
clientReceived
=
await
clientQueue
.
waitForDataWithAtLeastLength
(
256
)
;
assertUint8ArraysEqual
(
clientReceived
smallUint8Array
"
Client
received
/
server
sent
"
)
;
let
bigUint8Array
=
new
Uint8Array
(
65536
+
3
)
;
for
(
let
i
=
0
;
i
<
bigUint8Array
.
length
;
i
+
+
)
{
bigUint8Array
[
i
]
=
i
%
256
;
}
let
lengthOfChunk1
=
65536
;
is
(
clientSocket
.
send
(
bigUint8Array
.
buffer
0
lengthOfChunk1
)
true
"
Client
sending
chunk1
should
not
result
in
the
buffer
being
full
.
"
)
;
for
(
let
iSend
=
0
;
iSend
<
2
;
iSend
+
+
)
{
let
offset
=
iSend
=
=
0
?
lengthOfChunk1
:
0
;
is
(
clientSocket
.
send
(
bigUint8Array
.
buffer
offset
bigUint8Array
.
length
)
false
"
Client
sending
more
than
64k
should
result
in
the
buffer
being
full
.
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
drain
"
"
The
drain
event
should
fire
after
a
large
send
that
indicated
full
.
"
)
;
serverReceived
=
await
serverQueue
.
waitForDataWithAtLeastLength
(
bigUint8Array
.
length
)
;
assertUint8ArraysEqual
(
serverReceived
bigUint8Array
"
server
received
/
client
sent
"
)
;
if
(
iSend
=
=
0
)
{
is
(
serverSocket
.
send
(
bigUint8Array
.
buffer
0
lengthOfChunk1
)
true
"
Server
sending
chunk1
should
not
result
in
the
buffer
being
full
.
"
)
;
}
is
(
serverSocket
.
send
(
bigUint8Array
.
buffer
offset
bigUint8Array
.
length
)
false
"
Server
sending
more
than
64k
should
result
in
the
buffer
being
full
.
"
)
;
is
(
(
await
serverQueue
.
waitForEvent
(
)
)
.
type
"
drain
"
"
The
drain
event
should
fire
after
a
large
send
that
indicated
full
.
"
)
;
clientReceived
=
await
clientQueue
.
waitForDataWithAtLeastLength
(
bigUint8Array
.
length
)
;
assertUint8ArraysEqual
(
clientReceived
bigUint8Array
"
client
received
/
server
sent
"
)
;
}
serverSocket
.
close
(
)
;
is
(
serverSocket
.
readyState
"
closing
"
"
readyState
should
be
closing
immediately
after
calling
close
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
close
"
"
The
client
should
get
a
close
event
when
the
server
closes
.
"
)
;
is
(
clientSocket
.
readyState
"
closed
"
"
client
readyState
should
be
closed
after
close
event
"
)
;
is
(
(
await
serverQueue
.
waitForEvent
(
)
)
.
type
"
close
"
"
The
server
should
get
a
close
event
when
it
closes
itself
.
"
)
;
is
(
serverSocket
.
readyState
"
closed
"
"
server
readyState
should
be
closed
after
close
event
"
)
;
connectedPromise
=
waitForConnection
(
listeningServer
)
;
clientSocket
=
createSocket
(
"
127
.
0
.
0
.
1
"
serverPort
{
binaryType
:
"
arraybuffer
"
}
)
;
clientQueue
=
listenForEventsOnSocket
(
clientSocket
"
client
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
open
"
"
got
open
event
"
)
;
let
connectedResult
=
await
connectedPromise
;
serverSocket
=
connectedResult
.
socket
;
serverQueue
=
connectedResult
.
queue
;
clientSocket
.
close
(
)
;
is
(
clientSocket
.
readyState
"
closing
"
"
client
readyState
should
be
losing
immediately
after
calling
close
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
close
"
"
The
client
should
get
a
close
event
when
it
closes
itself
.
"
)
;
is
(
clientSocket
.
readyState
"
closed
"
"
client
readyState
should
be
closed
after
the
close
event
is
received
"
)
;
is
(
(
await
serverQueue
.
waitForEvent
(
)
)
.
type
"
close
"
"
The
server
should
get
a
close
event
when
the
client
closes
.
"
)
;
is
(
serverSocket
.
readyState
"
closed
"
"
server
readyState
should
be
closed
after
the
close
event
is
received
"
)
;
connectedPromise
=
waitForConnection
(
listeningServer
)
;
clientSocket
=
createSocket
(
"
127
.
0
.
0
.
1
"
serverPort
{
binaryType
:
"
arraybuffer
"
}
)
;
clientQueue
=
listenForEventsOnSocket
(
clientSocket
"
client
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
open
"
"
got
open
event
"
)
;
connectedResult
=
await
connectedPromise
;
serverSocket
=
connectedResult
.
socket
;
serverQueue
=
connectedResult
.
queue
;
is
(
clientSocket
.
send
(
bigUint8Array
.
buffer
0
bigUint8Array
.
length
)
false
"
Client
sending
more
than
64k
should
result
in
the
buffer
being
full
.
"
)
;
clientSocket
.
close
(
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
drain
"
"
The
drain
event
should
fire
after
a
large
send
that
returned
true
.
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
close
"
"
The
close
event
should
fire
after
the
drain
event
.
"
)
;
serverReceived
=
await
serverQueue
.
waitForDataWithAtLeastLength
(
bigUint8Array
.
length
)
;
assertUint8ArraysEqual
(
serverReceived
bigUint8Array
"
server
received
/
client
sent
"
)
;
is
(
(
await
serverQueue
.
waitForEvent
(
)
)
.
type
"
close
"
"
The
drain
event
should
fire
after
a
large
send
that
returned
true
.
"
)
;
connectedPromise
=
waitForConnection
(
listeningServer
)
;
clientSocket
=
createSocket
(
"
127
.
0
.
0
.
1
"
serverPort
{
binaryType
:
"
string
"
}
)
;
clientQueue
=
listenForEventsOnSocket
(
clientSocket
"
client
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
open
"
"
got
open
event
"
)
;
connectedResult
=
await
connectedPromise
;
serverSocket
=
connectedResult
.
socket
;
serverQueue
=
connectedResult
.
queue
;
bigUint8Array
.
toString
=
Object
.
prototype
.
toString
;
is
(
clientSocket
.
send
(
bigUint8Array
)
true
"
Client
sending
a
large
non
-
string
should
only
send
a
small
string
.
"
)
;
clientSocket
.
close
(
)
;
serverReceived
=
await
serverQueue
.
waitForDataWithAtLeastLength
(
bigUint8Array
.
toString
(
)
.
length
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
close
"
"
The
close
event
should
fire
after
the
drain
event
.
"
)
;
connectedPromise
=
waitForConnection
(
listeningServer
)
;
clientSocket
=
createSocket
(
"
127
.
0
.
0
.
1
"
serverPort
{
binaryType
:
"
arraybuffer
"
}
)
;
clientQueue
=
listenForEventsOnSocket
(
clientSocket
"
client
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
open
"
"
got
open
event
"
)
;
connectedResult
=
await
connectedPromise
;
serverSocket
=
connectedResult
.
socket
;
serverQueue
=
connectedResult
.
queue
;
is
(
clientSocket
.
send
(
bigUint8Array
.
buffer
0
bigUint8Array
.
length
)
false
"
Server
sending
more
than
64k
should
result
in
the
buffer
being
full
.
"
)
;
is
(
clientSocket
.
send
(
bigUint8Array
.
buffer
0
bigUint8Array
.
length
)
false
"
Server
sending
more
than
64k
should
result
in
the
buffer
being
full
.
"
)
;
clientSocket
.
closeImmediately
(
)
;
serverReceived
=
await
serverQueue
.
waitForAnyDataAndClose
(
)
;
is
(
serverReceived
.
length
<
2
*
bigUint8Array
.
length
true
"
Received
array
length
less
than
sent
array
length
"
)
;
listeningServer
.
close
(
)
;
if
(
testConnectingToNonListeningPort
)
{
clientSocket
=
createSocket
(
"
127
.
0
.
0
.
1
"
serverPort
{
binaryType
:
"
arraybuffer
"
}
)
;
clientQueue
=
listenForEventsOnSocket
(
clientSocket
"
client
"
)
;
is
(
(
await
clientQueue
.
waitForEvent
(
)
)
.
type
"
error
"
"
fail
to
connect
"
)
;
is
(
clientSocket
.
readyState
"
closed
"
"
client
readyState
should
be
closed
after
the
failure
to
connect
"
)
;
}
}
add_task
(
test_basics
)
;
add_task
(
async
function
test_ipv6
(
)
{
const
{
HttpServer
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
httpd
.
js
"
)
;
let
deferred
=
defer
(
)
;
let
httpServer
=
new
HttpServer
(
)
;
httpServer
.
start_ipv6
(
-
1
)
;
let
clientSocket
=
new
TCPSocket
(
"
:
:
1
"
httpServer
.
identity
.
primaryPort
)
;
clientSocket
.
onopen
=
(
)
=
>
{
ok
(
true
"
Connect
to
ipv6
address
succeeded
"
)
;
deferred
.
resolve
(
)
;
}
;
clientSocket
.
onerror
=
(
)
=
>
{
ok
(
false
"
Connect
to
ipv6
address
failed
"
)
;
deferred
.
reject
(
)
;
}
;
await
deferred
.
promise
;
await
httpServer
.
stop
(
)
;
}
)
;
