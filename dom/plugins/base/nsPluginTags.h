#
ifndef
nsPluginTags_h_
#
define
nsPluginTags_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsIBlocklistService
.
h
"
#
include
"
nsIPluginTag
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsString
.
h
"
class
nsIURI
;
struct
PRLibrary
;
struct
nsPluginInfo
;
class
nsNPAPIPlugin
;
namespace
mozilla
{
namespace
dom
{
struct
FakePluginTagInit
;
}
}
#
define
NS_IINTERNALPLUGINTAG_IID
\
{
\
0xe8fdd227
0x27da
0x46ee
{
\
0xbe
0xf3
0x1a
0xef
0x5a
0x8f
0xc5
0xb4
\
}
\
}
#
define
NS_PLUGINTAG_IID
\
{
\
0xcce2e8b9
0x9702
0x4d4b
{
\
0xbe
0xa4
0x7c
0x1e
0x13
0x1f
0xaf
0x78
\
}
\
}
class
nsIInternalPluginTag
:
public
nsIPluginTag
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_IINTERNALPLUGINTAG_IID
)
nsIInternalPluginTag
(
)
;
nsIInternalPluginTag
(
const
char
*
aName
const
char
*
aDescription
const
char
*
aFileName
const
char
*
aVersion
)
;
nsIInternalPluginTag
(
const
char
*
aName
const
char
*
aDescription
const
char
*
aFileName
const
char
*
aVersion
const
nsTArray
<
nsCString
>
&
aMimeTypes
const
nsTArray
<
nsCString
>
&
aMimeDescriptions
const
nsTArray
<
nsCString
>
&
aExtensions
)
;
virtual
bool
IsEnabled
(
)
=
0
;
virtual
const
nsCString
&
GetNiceFileName
(
)
=
0
;
const
nsCString
&
Name
(
)
const
{
return
mName
;
}
const
nsCString
&
Description
(
)
const
{
return
mDescription
;
}
const
nsTArray
<
nsCString
>
&
MimeTypes
(
)
const
{
return
mMimeTypes
;
}
const
nsTArray
<
nsCString
>
&
MimeDescriptions
(
)
const
{
return
mMimeDescriptions
;
}
const
nsTArray
<
nsCString
>
&
Extensions
(
)
const
{
return
mExtensions
;
}
const
nsCString
&
FileName
(
)
const
{
return
mFileName
;
}
const
nsCString
&
Version
(
)
const
{
return
mVersion
;
}
bool
HasMimeType
(
const
nsACString
&
aMimeType
)
const
;
bool
HasExtension
(
const
nsACString
&
aExtension
nsACString
&
aMatchingType
)
const
;
protected
:
~
nsIInternalPluginTag
(
)
;
nsCString
mName
;
nsCString
mDescription
;
nsCString
mFileName
;
nsCString
mVersion
;
nsTArray
<
nsCString
>
mMimeTypes
;
nsTArray
<
nsCString
>
mMimeDescriptions
;
nsTArray
<
nsCString
>
mExtensions
;
static
uint32_t
sNextId
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsIInternalPluginTag
NS_IINTERNALPLUGINTAG_IID
)
class
nsPluginTag
final
:
public
nsIInternalPluginTag
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PLUGINTAG_IID
)
NS_DECL_ISUPPORTS
NS_DECL_NSIPLUGINTAG
enum
PluginState
{
ePluginState_Disabled
=
0
ePluginState_Clicktoplay
=
1
ePluginState_Enabled
=
2
ePluginState_MaxValue
=
3
}
;
nsPluginTag
(
nsPluginInfo
*
aPluginInfo
int64_t
aLastModifiedTime
uint32_t
aBlocklistState
)
;
nsPluginTag
(
const
char
*
aName
const
char
*
aDescription
const
char
*
aFileName
const
char
*
aFullPath
const
char
*
aVersion
const
char
*
const
*
aMimeTypes
const
char
*
const
*
aMimeDescriptions
const
char
*
const
*
aExtensions
int32_t
aVariants
int64_t
aLastModifiedTime
uint32_t
aBlocklistState
bool
aArgsAreUTF8
=
false
)
;
nsPluginTag
(
uint32_t
aId
const
char
*
aName
const
char
*
aDescription
const
char
*
aFileName
const
char
*
aFullPath
const
char
*
aVersion
nsTArray
<
nsCString
>
aMimeTypes
nsTArray
<
nsCString
>
aMimeDescriptions
nsTArray
<
nsCString
>
aExtensions
bool
aIsFlashPlugin
bool
aSupportsAsyncRender
int64_t
aLastModifiedTime
int32_t
aSandboxLevel
uint32_t
aBlocklistState
)
;
void
TryUnloadPlugin
(
bool
inShutdown
)
;
bool
IsActive
(
)
;
bool
IsEnabled
(
)
override
;
void
SetEnabled
(
bool
enabled
)
;
bool
IsClicktoplay
(
)
;
bool
IsBlocklisted
(
)
;
uint32_t
BlocklistState
(
)
;
PluginState
GetPluginState
(
)
;
void
SetPluginState
(
PluginState
state
)
;
void
SetBlocklistState
(
uint32_t
aBlocklistState
)
;
bool
HasSameNameAndMimes
(
const
nsPluginTag
*
aPluginTag
)
const
;
const
nsCString
&
GetNiceFileName
(
)
override
;
RefPtr
<
nsPluginTag
>
mNext
;
uint32_t
mId
;
size_t
mContentProcessRunningCount
;
bool
mHadLocalInstance
;
PRLibrary
*
mLibrary
;
RefPtr
<
nsNPAPIPlugin
>
mPlugin
;
bool
mIsFlashPlugin
;
bool
mSupportsAsyncRender
;
nsCString
mFullPath
;
int64_t
mLastModifiedTime
;
nsCOMPtr
<
nsITimer
>
mUnloadTimer
;
int32_t
mSandboxLevel
;
bool
mIsSandboxLoggingEnabled
;
private
:
virtual
~
nsPluginTag
(
)
;
nsCString
mNiceFileName
;
uint32_t
mBlocklistState
;
void
InitMime
(
const
char
*
const
*
aMimeTypes
const
char
*
const
*
aMimeDescriptions
const
char
*
const
*
aExtensions
uint32_t
aVariantCount
)
;
void
InitSandboxLevel
(
)
;
nsresult
EnsureMembersAreUTF8
(
)
;
void
FixupVersion
(
)
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsPluginTag
NS_PLUGINTAG_IID
)
class
nsFakePluginTag
:
public
nsIInternalPluginTag
public
nsIFakePluginTag
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIPLUGINTAG
NS_DECL_NSIFAKEPLUGINTAG
static
nsresult
Create
(
const
mozilla
:
:
dom
:
:
FakePluginTagInit
&
aInitDictionary
nsFakePluginTag
*
*
aPluginTag
)
;
nsFakePluginTag
(
uint32_t
aId
already_AddRefed
<
nsIURI
>
&
&
aHandlerURI
const
char
*
aName
const
char
*
aDescription
const
nsTArray
<
nsCString
>
&
aMimeTypes
const
nsTArray
<
nsCString
>
&
aMimeDescriptions
const
nsTArray
<
nsCString
>
&
aExtensions
const
nsCString
&
aNiceName
const
nsString
&
aSandboxScript
)
;
bool
IsEnabled
(
)
override
;
const
nsCString
&
GetNiceFileName
(
)
override
;
bool
HandlerURIMatches
(
nsIURI
*
aURI
)
;
nsIURI
*
HandlerURI
(
)
const
{
return
mHandlerURI
;
}
uint32_t
Id
(
)
const
{
return
mId
;
}
const
nsString
&
SandboxScript
(
)
const
{
return
mSandboxScript
;
}
static
const
int32_t
NOT_JSPLUGIN
=
-
1
;
private
:
nsFakePluginTag
(
)
;
virtual
~
nsFakePluginTag
(
)
;
uint32_t
mId
;
nsCOMPtr
<
nsIURI
>
mHandlerURI
;
nsCString
mFullPath
;
nsCString
mNiceName
;
nsString
mSandboxScript
;
nsPluginTag
:
:
PluginState
mState
;
}
;
#
endif
