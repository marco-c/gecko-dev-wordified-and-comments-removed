#
ifdef
MOZ_X11
#
include
<
cairo
-
xlib
.
h
>
#
include
"
gfxXlibSurface
.
h
"
enum
{
XKeyPress
=
KeyPress
}
;
#
include
"
mozilla
/
X11Util
.
h
"
using
mozilla
:
:
DefaultXDisplay
;
#
endif
#
include
"
nsPluginInstanceOwner
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
GLImages
.
h
"
#
include
"
nsPluginFrame
.
h
"
#
include
"
nsIPluginDocument
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIPluginWidget
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsIAppShell
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsIFocusManager
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
EGLUtils
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
MiscEvents
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
DragEvent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
HTMLObjectElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
WheelEventBinding
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
PuppetWidget
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
TextComposition
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsWidgetsCID
.
h
"
static
NS_DEFINE_CID
(
kWidgetCID
NS_CHILD_CID
)
;
static
NS_DEFINE_CID
(
kAppShellCID
NS_APPSHELL_CID
)
;
#
ifdef
XP_WIN
#
include
<
wtypes
.
h
>
#
include
<
winuser
.
h
>
#
include
"
mozilla
/
widget
/
WinMessages
.
h
"
#
endif
#
ifdef
XP_MACOSX
#
include
"
ComplexTextInputPanel
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GTK
#
include
<
gdk
/
gdk
.
h
>
#
include
<
gtk
/
gtk
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
class
nsPluginDOMContextMenuListener
:
public
nsIDOMEventListener
{
virtual
~
nsPluginDOMContextMenuListener
(
)
;
public
:
explicit
nsPluginDOMContextMenuListener
(
nsIContent
*
aContent
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIDOMEVENTLISTENER
void
Destroy
(
nsIContent
*
aContent
)
;
nsEventStatus
ProcessEvent
(
const
WidgetGUIEvent
&
anEvent
)
{
return
nsEventStatus_eConsumeNoDefault
;
}
}
;
class
AsyncPaintWaitEvent
:
public
Runnable
{
public
:
AsyncPaintWaitEvent
(
nsIContent
*
aContent
bool
aFinished
)
:
Runnable
(
"
AsyncPaintWaitEvent
"
)
mContent
(
aContent
)
mFinished
(
aFinished
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsContentUtils
:
:
DispatchTrustedEvent
(
mContent
-
>
OwnerDoc
(
)
mContent
mFinished
?
NS_LITERAL_STRING
(
"
MozPaintWaitFinished
"
)
:
NS_LITERAL_STRING
(
"
MozPaintWait
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIContent
>
mContent
;
bool
mFinished
;
}
;
void
nsPluginInstanceOwner
:
:
NotifyPaintWaiter
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
!
mWaitingForPaint
&
&
!
IsUpToDate
(
)
&
&
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
AsyncPaintWaitEvent
(
content
false
)
;
nsContentUtils
:
:
AddScriptRunner
(
event
)
;
mWaitingForPaint
=
true
;
}
}
bool
nsPluginInstanceOwner
:
:
NeedsScrollImageLayer
(
)
{
#
if
defined
(
XP_WIN
)
return
XRE_IsContentProcess
(
)
&
&
mPluginWindow
&
&
mPluginWindow
-
>
type
=
=
NPWindowTypeWindow
;
#
else
return
false
;
#
endif
}
already_AddRefed
<
ImageContainer
>
nsPluginInstanceOwner
:
:
GetImageContainer
(
)
{
if
(
!
mInstance
)
return
nullptr
;
RefPtr
<
ImageContainer
>
container
;
if
(
NeedsScrollImageLayer
(
)
)
{
#
if
defined
(
XP_WIN
)
mInstance
-
>
GetScrollCaptureContainer
(
getter_AddRefs
(
container
)
)
;
#
endif
}
else
{
mInstance
-
>
GetImageContainer
(
getter_AddRefs
(
container
)
)
;
}
return
container
.
forget
(
)
;
}
void
nsPluginInstanceOwner
:
:
DidComposite
(
)
{
if
(
mInstance
)
{
mInstance
-
>
DidComposite
(
)
;
}
}
void
nsPluginInstanceOwner
:
:
SetBackgroundUnknown
(
)
{
if
(
mInstance
)
{
mInstance
-
>
SetBackgroundUnknown
(
)
;
}
}
already_AddRefed
<
mozilla
:
:
gfx
:
:
DrawTarget
>
nsPluginInstanceOwner
:
:
BeginUpdateBackground
(
const
nsIntRect
&
aRect
)
{
nsIntRect
rect
=
aRect
;
RefPtr
<
DrawTarget
>
dt
;
if
(
mInstance
&
&
NS_SUCCEEDED
(
mInstance
-
>
BeginUpdateBackground
(
&
rect
getter_AddRefs
(
dt
)
)
)
)
{
return
dt
.
forget
(
)
;
}
return
nullptr
;
}
void
nsPluginInstanceOwner
:
:
EndUpdateBackground
(
const
nsIntRect
&
aRect
)
{
nsIntRect
rect
=
aRect
;
if
(
mInstance
)
{
mInstance
-
>
EndUpdateBackground
(
&
rect
)
;
}
}
bool
nsPluginInstanceOwner
:
:
UseAsyncRendering
(
)
{
#
ifdef
XP_MACOSX
if
(
mUseAsyncRendering
)
{
return
true
;
}
#
endif
bool
isOOP
;
bool
result
=
(
mInstance
&
&
NS_SUCCEEDED
(
mInstance
-
>
GetIsOOP
(
&
isOOP
)
)
&
&
isOOP
#
ifndef
XP_MACOSX
&
&
(
!
mPluginWindow
|
|
mPluginWindow
-
>
type
=
=
NPWindowTypeDrawable
)
#
endif
)
;
#
ifdef
XP_MACOSX
if
(
result
)
{
mUseAsyncRendering
=
true
;
}
#
endif
return
result
;
}
nsIntSize
nsPluginInstanceOwner
:
:
GetCurrentImageSize
(
)
{
nsIntSize
size
(
0
0
)
;
if
(
mInstance
)
{
mInstance
-
>
GetImageSize
(
&
size
)
;
}
return
size
;
}
nsPluginInstanceOwner
:
:
nsPluginInstanceOwner
(
)
:
mPluginWindow
(
nullptr
)
mLastEventloopNestingLevel
(
0
)
{
nsCOMPtr
<
nsIPluginHost
>
pluginHostCOM
=
do_GetService
(
MOZ_PLUGIN_HOST_CONTRACTID
)
;
mPluginHost
=
static_cast
<
nsPluginHost
*
>
(
pluginHostCOM
.
get
(
)
)
;
if
(
mPluginHost
)
mPluginHost
-
>
NewPluginNativeWindow
(
&
mPluginWindow
)
;
mPluginFrame
=
nullptr
;
mWidgetCreationComplete
=
false
;
#
ifdef
XP_MACOSX
mSentInitialTopLevelWindowEvent
=
false
;
mLastWindowIsActive
=
false
;
mLastContentFocused
=
false
;
mLastScaleFactor
=
1
.
0
;
mShouldBlurOnActivate
=
false
;
#
endif
mLastCSSZoomFactor
=
1
.
0
;
mContentFocused
=
false
;
mWidgetVisible
=
true
;
mPluginWindowVisible
=
false
;
mPluginDocumentActiveState
=
true
;
mLastMouseDownButtonType
=
-
1
;
#
ifdef
XP_MACOSX
#
ifndef
NP_NO_CARBON
mEventModel
=
NPEventModelCarbon
;
#
else
mEventModel
=
NPEventModelCocoa
;
#
endif
mUseAsyncRendering
=
false
;
#
endif
mWaitingForPaint
=
false
;
#
ifdef
XP_WIN
mGotCompositionData
=
false
;
mSentStartComposition
=
false
;
mPluginDidNotHandleIMEComposition
=
false
;
#
endif
}
nsPluginInstanceOwner
:
:
~
nsPluginInstanceOwner
(
)
{
if
(
mWaitingForPaint
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
content
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
AsyncPaintWaitEvent
(
content
true
)
;
NS_DispatchToMainThread
(
event
)
;
}
}
mPluginFrame
=
nullptr
;
PLUG_DeletePluginNativeWindow
(
mPluginWindow
)
;
mPluginWindow
=
nullptr
;
if
(
mInstance
)
{
mInstance
-
>
SetOwner
(
nullptr
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsPluginInstanceOwner
nsIPluginInstanceOwner
nsIDOMEventListener
nsIPrivacyTransitionObserver
nsIKeyEventInPluginCallback
nsISupportsWeakReference
)
nsresult
nsPluginInstanceOwner
:
:
SetInstance
(
nsNPAPIPluginInstance
*
aInstance
)
{
NS_ASSERTION
(
!
mInstance
|
|
!
aInstance
"
mInstance
should
only
be
set
or
unset
!
"
)
;
if
(
mInstance
&
&
!
aInstance
)
{
mInstance
-
>
SetOwner
(
nullptr
)
;
}
mInstance
=
aInstance
;
nsCOMPtr
<
nsIDocument
>
doc
;
GetDocument
(
getter_AddRefs
(
doc
)
)
;
if
(
doc
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
doc
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
domWindow
-
>
GetDocShell
(
)
;
if
(
docShell
)
docShell
-
>
AddWeakPrivacyTransitionObserver
(
this
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetWindow
(
NPWindow
*
&
aWindow
)
{
NS_ASSERTION
(
mPluginWindow
"
the
plugin
window
object
being
returned
is
null
"
)
;
aWindow
=
mPluginWindow
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetMode
(
int32_t
*
aMode
)
{
nsCOMPtr
<
nsIDocument
>
doc
;
nsresult
rv
=
GetDocument
(
getter_AddRefs
(
doc
)
)
;
nsCOMPtr
<
nsIPluginDocument
>
pDoc
(
do_QueryInterface
(
doc
)
)
;
if
(
pDoc
)
{
*
aMode
=
NP_FULL
;
}
else
{
*
aMode
=
NP_EMBED
;
}
return
rv
;
}
void
nsPluginInstanceOwner
:
:
GetAttributes
(
nsTArray
<
MozPluginParameter
>
&
attributes
)
{
nsCOMPtr
<
nsIObjectLoadingContent
>
content
=
do_QueryReferent
(
mContent
)
;
nsObjectLoadingContent
*
loadingContent
=
static_cast
<
nsObjectLoadingContent
*
>
(
content
.
get
(
)
)
;
loadingContent
-
>
GetPluginAttributes
(
attributes
)
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetDOMElement
(
Element
*
*
result
)
{
return
CallQueryReferent
(
mContent
.
get
(
)
result
)
;
}
nsresult
nsPluginInstanceOwner
:
:
GetInstance
(
nsNPAPIPluginInstance
*
*
aInstance
)
{
NS_ENSURE_ARG_POINTER
(
aInstance
)
;
*
aInstance
=
mInstance
;
NS_IF_ADDREF
(
*
aInstance
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetURL
(
const
char
*
aURL
const
char
*
aTarget
nsIInputStream
*
aPostStream
void
*
aHeadersData
uint32_t
aHeadersDataLen
bool
aDoCheckLoadURIChecks
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
!
content
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
content
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
nsIDocument
*
doc
=
content
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
NS_ERROR_FAILURE
;
}
nsPresContext
*
presContext
=
doc
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsISupports
>
container
=
presContext
-
>
GetContainerWeak
(
)
;
NS_ENSURE_TRUE
(
container
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsILinkHandler
>
lh
=
do_QueryInterface
(
container
)
;
NS_ENSURE_TRUE
(
lh
NS_ERROR_FAILURE
)
;
nsAutoString
unitarget
;
if
(
(
0
=
=
PL_strcmp
(
aTarget
"
newwindow
"
)
)
|
|
(
0
=
=
PL_strcmp
(
aTarget
"
_new
"
)
)
)
{
unitarget
.
AssignASCII
(
"
_blank
"
)
;
}
else
if
(
0
=
=
PL_strcmp
(
aTarget
"
_current
"
)
)
{
unitarget
.
AssignASCII
(
"
_self
"
)
;
}
else
{
unitarget
.
AssignASCII
(
aTarget
)
;
}
nsCOMPtr
<
nsIURI
>
baseURI
=
GetBaseURI
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aURL
baseURI
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIInputStream
>
headersDataStream
;
if
(
aPostStream
&
&
aHeadersData
)
{
if
(
!
aHeadersDataLen
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIStringInputStream
>
sis
=
do_CreateInstance
(
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
)
;
if
(
!
sis
)
return
NS_ERROR_OUT_OF_MEMORY
;
rv
=
sis
-
>
SetData
(
(
char
*
)
aHeadersData
aHeadersDataLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
headersDataStream
=
do_QueryInterface
(
sis
)
;
}
int32_t
blockPopups
=
Preferences
:
:
GetInt
(
"
privacy
.
popups
.
disable_from_plugins
"
)
;
nsAutoPopupStatePusher
popupStatePusher
(
(
PopupControlState
)
blockPopups
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
;
if
(
!
aDoCheckLoadURIChecks
)
{
mozilla
:
:
OriginAttributes
attrs
=
BasePrincipal
:
:
Cast
(
content
-
>
NodePrincipal
(
)
)
-
>
OriginAttributesRef
(
)
;
triggeringPrincipal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
uri
attrs
)
;
}
rv
=
lh
-
>
OnLinkClick
(
content
uri
unitarget
.
get
(
)
VoidString
(
)
aPostStream
headersDataStream
false
true
triggeringPrincipal
)
;
return
rv
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetDocument
(
nsIDocument
*
*
aDocument
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
!
aDocument
|
|
!
content
)
{
return
NS_ERROR_NULL_POINTER
;
}
NS_ADDREF
(
*
aDocument
=
content
-
>
OwnerDoc
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
InvalidateRect
(
NPRect
*
invalidRect
)
{
if
(
mWaitingForPaint
&
&
(
!
mPluginFrame
|
|
IsUpToDate
(
)
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
AsyncPaintWaitEvent
(
content
true
)
;
NS_DispatchToMainThread
(
event
)
;
mWaitingForPaint
=
false
;
}
if
(
!
mPluginFrame
|
|
!
invalidRect
|
|
!
mWidgetVisible
)
return
NS_ERROR_FAILURE
;
#
if
defined
(
XP_MACOSX
)
RefPtr
<
ImageContainer
>
container
;
mInstance
-
>
GetImageContainer
(
getter_AddRefs
(
container
)
)
;
#
endif
#
ifndef
XP_MACOSX
if
(
mWidget
)
{
mWidget
-
>
Invalidate
(
LayoutDeviceIntRect
(
invalidRect
-
>
left
invalidRect
-
>
top
invalidRect
-
>
right
-
invalidRect
-
>
left
invalidRect
-
>
bottom
-
invalidRect
-
>
top
)
)
;
if
(
!
NeedsScrollImageLayer
(
)
)
{
return
NS_OK
;
}
}
#
endif
nsIntRect
rect
(
invalidRect
-
>
left
invalidRect
-
>
top
invalidRect
-
>
right
-
invalidRect
-
>
left
invalidRect
-
>
bottom
-
invalidRect
-
>
top
)
;
double
scaleFactor
=
1
.
0
;
GetContentsScaleFactor
(
&
scaleFactor
)
;
rect
.
ScaleRoundOut
(
scaleFactor
)
;
mPluginFrame
-
>
InvalidateLayer
(
DisplayItemType
:
:
TYPE_PLUGIN
&
rect
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
InvalidateRegion
(
NPRegion
invalidRegion
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
RedrawPlugin
(
)
{
if
(
mPluginFrame
)
{
mPluginFrame
-
>
InvalidateLayer
(
DisplayItemType
:
:
TYPE_PLUGIN
)
;
}
return
NS_OK
;
}
#
if
defined
(
XP_WIN
)
nsIWidget
*
nsPluginInstanceOwner
:
:
GetContainingWidgetIfOffset
(
)
{
MOZ_ASSERT
(
mPluginFrame
"
Caller
should
have
checked
for
null
mPluginFrame
.
"
)
;
if
(
!
XRE_IsContentProcess
(
)
&
&
mPluginWindow
&
&
mPluginWindow
-
>
type
=
=
NPWindowTypeDrawable
)
{
nsIWidget
*
win
=
mPluginFrame
-
>
GetNearestWidget
(
)
;
if
(
win
)
{
nsView
*
view
=
nsView
:
:
GetViewFor
(
win
)
;
NS_ASSERTION
(
view
"
No
view
for
widget
"
)
;
nsPoint
offset
=
view
-
>
GetOffsetTo
(
nullptr
)
;
if
(
offset
.
x
|
|
offset
.
y
)
{
return
win
;
}
}
}
return
nullptr
;
}
static
already_AddRefed
<
nsIWidget
>
GetRootWidgetForPluginFrame
(
const
nsPluginFrame
*
aPluginFrame
)
{
MOZ_ASSERT
(
aPluginFrame
)
;
nsViewManager
*
vm
=
aPluginFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
NS_WARNING
(
"
Could
not
find
view
manager
for
plugin
frame
.
"
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
rootWidget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
rootWidget
)
)
;
return
rootWidget
.
forget
(
)
;
}
#
endif
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetNetscapeWindow
(
void
*
value
)
{
if
(
!
mPluginFrame
)
{
NS_WARNING
(
"
plugin
owner
has
no
owner
in
getting
doc
'
s
window
handle
"
)
;
return
NS_ERROR_FAILURE
;
}
#
if
defined
(
XP_WIN
)
void
*
*
pvalue
=
(
void
*
*
)
value
;
nsIWidget
*
offsetContainingWidget
=
GetContainingWidgetIfOffset
(
)
;
if
(
offsetContainingWidget
)
{
*
pvalue
=
(
void
*
)
offsetContainingWidget
-
>
GetNativeData
(
NS_NATIVE_WINDOW
)
;
if
(
*
pvalue
)
{
return
NS_OK
;
}
}
nsCOMPtr
<
nsIWidget
>
widget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
widget
)
{
*
pvalue
=
widget
-
>
GetNativeData
(
NS_NATIVE_SHAREABLE_WINDOW
)
;
}
else
{
NS_ASSERTION
(
widget
"
couldn
'
t
get
doc
'
s
widget
in
getting
doc
'
s
window
handle
"
)
;
}
return
NS_OK
;
#
elif
defined
(
MOZ_WIDGET_GTK
)
&
&
defined
(
MOZ_X11
)
nsIWidget
*
win
=
mPluginFrame
-
>
GetNearestWidget
(
)
;
if
(
!
win
)
return
NS_ERROR_FAILURE
;
*
static_cast
<
Window
*
>
(
value
)
=
(
long
unsigned
int
)
win
-
>
GetNativeData
(
NS_NATIVE_SHAREABLE_WINDOW
)
;
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
#
if
defined
(
XP_WIN
)
void
nsPluginInstanceOwner
:
:
SetWidgetWindowAsParent
(
HWND
aWindowToAdopt
)
{
if
(
!
mWidget
)
{
NS_ERROR
(
"
mWidget
should
exist
before
this
gets
called
.
"
)
;
return
;
}
mWidget
-
>
SetNativeData
(
NS_NATIVE_CHILD_WINDOW
reinterpret_cast
<
uintptr_t
>
(
aWindowToAdopt
)
)
;
}
nsresult
nsPluginInstanceOwner
:
:
SetNetscapeWindowAsParent
(
HWND
aWindowToAdopt
)
{
if
(
!
mPluginFrame
)
{
NS_WARNING
(
"
Plugin
owner
has
no
plugin
frame
.
"
)
;
return
NS_ERROR_FAILURE
;
}
nsIWidget
*
offsetWidget
=
GetContainingWidgetIfOffset
(
)
;
if
(
offsetWidget
)
{
offsetWidget
-
>
SetNativeData
(
NS_NATIVE_CHILD_WINDOW
reinterpret_cast
<
uintptr_t
>
(
aWindowToAdopt
)
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWidget
>
rootWidget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
!
rootWidget
)
{
NS_ASSERTION
(
rootWidget
"
Couldn
'
t
get
topmost
document
'
s
widget
.
"
)
;
return
NS_ERROR_FAILURE
;
}
rootWidget
-
>
SetNativeData
(
NS_NATIVE_CHILD_OF_SHAREABLE_WINDOW
reinterpret_cast
<
uintptr_t
>
(
aWindowToAdopt
)
)
;
return
NS_OK
;
}
bool
nsPluginInstanceOwner
:
:
GetCompositionString
(
uint32_t
aType
nsTArray
<
uint8_t
>
*
aDist
int32_t
*
aLength
)
{
mGotCompositionData
=
true
;
RefPtr
<
TextComposition
>
composition
=
GetTextComposition
(
)
;
if
(
NS_WARN_IF
(
!
composition
)
)
{
return
false
;
}
switch
(
aType
)
{
case
GCS_COMPSTR
:
{
if
(
!
composition
-
>
IsComposing
(
)
)
{
*
aLength
=
0
;
return
true
;
}
uint32_t
len
=
composition
-
>
LastData
(
)
.
Length
(
)
*
sizeof
(
char16_t
)
;
if
(
len
)
{
aDist
-
>
SetLength
(
len
)
;
memcpy
(
aDist
-
>
Elements
(
)
composition
-
>
LastData
(
)
.
get
(
)
len
)
;
}
*
aLength
=
len
;
return
true
;
}
case
GCS_RESULTSTR
:
{
if
(
composition
-
>
IsComposing
(
)
)
{
*
aLength
=
0
;
return
true
;
}
uint32_t
len
=
composition
-
>
LastData
(
)
.
Length
(
)
*
sizeof
(
char16_t
)
;
if
(
len
)
{
aDist
-
>
SetLength
(
len
)
;
memcpy
(
aDist
-
>
Elements
(
)
composition
-
>
LastData
(
)
.
get
(
)
len
)
;
}
*
aLength
=
len
;
return
true
;
}
case
GCS_CURSORPOS
:
{
*
aLength
=
0
;
TextRangeArray
*
ranges
=
composition
-
>
GetLastRanges
(
)
;
if
(
!
ranges
)
{
return
true
;
}
*
aLength
=
ranges
-
>
GetCaretPosition
(
)
;
if
(
*
aLength
<
0
)
{
return
false
;
}
return
true
;
}
case
GCS_COMPATTR
:
{
TextRangeArray
*
ranges
=
composition
-
>
GetLastRanges
(
)
;
if
(
!
ranges
|
|
ranges
-
>
IsEmpty
(
)
)
{
*
aLength
=
0
;
return
true
;
}
aDist
-
>
SetLength
(
composition
-
>
LastData
(
)
.
Length
(
)
)
;
memset
(
aDist
-
>
Elements
(
)
ATTR_INPUT
aDist
-
>
Length
(
)
)
;
for
(
TextRange
&
range
:
*
ranges
)
{
uint8_t
type
=
ATTR_INPUT
;
switch
(
range
.
mRangeType
)
{
case
TextRangeType
:
:
eRawClause
:
type
=
ATTR_INPUT
;
break
;
case
TextRangeType
:
:
eSelectedRawClause
:
type
=
ATTR_TARGET_NOTCONVERTED
;
break
;
case
TextRangeType
:
:
eConvertedClause
:
type
=
ATTR_CONVERTED
;
break
;
case
TextRangeType
:
:
eSelectedClause
:
type
=
ATTR_TARGET_CONVERTED
;
break
;
default
:
continue
;
}
size_t
minLen
=
std
:
:
min
<
size_t
>
(
range
.
mEndOffset
aDist
-
>
Length
(
)
)
;
for
(
size_t
i
=
range
.
mStartOffset
;
i
<
minLen
;
i
+
+
)
{
(
*
aDist
)
[
i
]
=
type
;
}
}
*
aLength
=
aDist
-
>
Length
(
)
;
return
true
;
}
case
GCS_COMPCLAUSE
:
{
RefPtr
<
TextRangeArray
>
ranges
=
composition
-
>
GetLastRanges
(
)
;
if
(
!
ranges
|
|
ranges
-
>
IsEmpty
(
)
)
{
aDist
-
>
SetLength
(
sizeof
(
uint32_t
)
)
;
memset
(
aDist
-
>
Elements
(
)
0
sizeof
(
uint32_t
)
)
;
*
aLength
=
aDist
-
>
Length
(
)
;
return
true
;
}
AutoTArray
<
uint32_t
16
>
clauses
;
clauses
.
AppendElement
(
0
)
;
for
(
TextRange
&
range
:
*
ranges
)
{
if
(
!
range
.
IsClause
(
)
)
{
continue
;
}
clauses
.
AppendElement
(
range
.
mEndOffset
)
;
}
aDist
-
>
SetLength
(
clauses
.
Length
(
)
*
sizeof
(
uint32_t
)
)
;
memcpy
(
aDist
-
>
Elements
(
)
clauses
.
Elements
(
)
aDist
-
>
Length
(
)
)
;
*
aLength
=
aDist
-
>
Length
(
)
;
return
true
;
}
case
GCS_RESULTREADSTR
:
{
*
aLength
=
0
;
return
true
;
}
case
GCS_RESULTCLAUSE
:
{
*
aLength
=
0
;
return
true
;
}
default
:
NS_WARNING
(
nsPrintfCString
(
"
Unsupported
type
%
x
of
ImmGetCompositionStringW
hook
"
aType
)
.
get
(
)
)
;
break
;
}
return
false
;
}
bool
nsPluginInstanceOwner
:
:
SetCandidateWindow
(
const
widget
:
:
CandidateWindowPosition
&
aPosition
)
{
if
(
NS_WARN_IF
(
!
mPluginFrame
)
)
{
return
false
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
GetContainingWidgetIfOffset
(
)
;
if
(
!
widget
)
{
widget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
false
;
}
}
widget
-
>
SetCandidateWindowForPlugin
(
aPosition
)
;
return
true
;
}
bool
nsPluginInstanceOwner
:
:
RequestCommitOrCancel
(
bool
aCommitted
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetContainingWidgetIfOffset
(
)
;
if
(
!
widget
)
{
widget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
false
;
}
}
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
widget
)
;
if
(
!
composition
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
content
!
=
composition
-
>
GetEventTargetNode
(
)
)
{
return
true
;
}
IMEStateManager
:
:
NotifyIME
(
aCommitted
?
widget
:
:
REQUEST_TO_COMMIT_COMPOSITION
:
widget
:
:
REQUEST_TO_CANCEL_COMPOSITION
widget
composition
-
>
GetTabParent
(
)
)
;
return
true
;
}
bool
nsPluginInstanceOwner
:
:
EnableIME
(
bool
aEnable
)
{
if
(
NS_WARN_IF
(
!
mPluginFrame
)
)
{
return
false
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
GetContainingWidgetIfOffset
(
)
;
if
(
!
widget
)
{
widget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
false
;
}
}
widget
-
>
EnableIMEForPlugin
(
aEnable
)
;
return
true
;
}
#
endif
void
nsPluginInstanceOwner
:
:
HandledWindowedPluginKeyEvent
(
const
NativeEventData
&
aKeyEventData
bool
aIsConsumed
)
{
if
(
NS_WARN_IF
(
!
mInstance
)
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
mInstance
-
>
HandledWindowedPluginKeyEvent
(
aKeyEventData
aIsConsumed
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
HandledWindowedPluginKeyEvent
fail
"
)
;
}
void
nsPluginInstanceOwner
:
:
OnWindowedPluginKeyEvent
(
const
NativeEventData
&
aKeyEventData
)
{
if
(
NS_WARN_IF
(
!
mPluginFrame
)
)
{
HandledWindowedPluginKeyEvent
(
aKeyEventData
false
)
;
return
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
mPluginFrame
-
>
PresContext
(
)
-
>
GetRootWidget
(
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
HandledWindowedPluginKeyEvent
(
aKeyEventData
false
)
;
return
;
}
nsresult
rv
=
widget
-
>
OnWindowedPluginKeyEvent
(
aKeyEventData
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
HandledWindowedPluginKeyEvent
(
aKeyEventData
false
)
;
return
;
}
if
(
rv
=
=
NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY
)
{
return
;
}
bool
consumed
=
(
rv
=
=
NS_SUCCESS_EVENT_CONSUMED
)
;
HandledWindowedPluginKeyEvent
(
aKeyEventData
consumed
)
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
SetEventModel
(
int32_t
eventModel
)
{
#
ifdef
XP_MACOSX
mEventModel
=
static_cast
<
NPEventModel
>
(
eventModel
)
;
return
NS_OK
;
#
else
return
NS_ERROR_NOT_IMPLEMENTED
;
#
endif
}
#
ifdef
XP_MACOSX
NPBool
nsPluginInstanceOwner
:
:
ConvertPointPuppet
(
PuppetWidget
*
widget
nsPluginFrame
*
pluginFrame
double
sourceX
double
sourceY
NPCoordinateSpace
sourceSpace
double
*
destX
double
*
destY
NPCoordinateSpace
destSpace
)
{
NS_ENSURE_TRUE
(
widget
&
&
widget
-
>
GetOwningTabChild
(
)
&
&
pluginFrame
false
)
;
NS_ENSURE_TRUE
(
destX
|
|
destY
false
)
;
if
(
sourceSpace
=
=
destSpace
)
{
if
(
destX
)
{
*
destX
=
sourceX
;
}
if
(
destY
)
{
*
destY
=
sourceY
;
}
return
true
;
}
nsPresContext
*
presContext
=
pluginFrame
-
>
PresContext
(
)
;
CSSToLayoutDeviceScale
scaleFactor
(
double
(
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
/
presContext
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
)
;
PuppetWidget
*
puppetWidget
=
static_cast
<
PuppetWidget
*
>
(
widget
)
;
PuppetWidget
*
rootWidget
=
static_cast
<
PuppetWidget
*
>
(
widget
-
>
GetTopLevelWidget
(
)
)
;
if
(
!
rootWidget
)
{
return
false
;
}
CSSIntPoint
chromeSize
=
CSSIntPoint
:
:
Truncate
(
rootWidget
-
>
GetChromeOffset
(
)
/
scaleFactor
)
;
nsIntSize
intScreenDims
=
rootWidget
-
>
GetScreenDimensions
(
)
;
CSSIntSize
screenDims
=
CSSIntSize
:
:
Truncate
(
LayoutDeviceIntSize
:
:
FromUnknownSize
(
intScreenDims
)
/
scaleFactor
)
;
int32_t
screenH
=
screenDims
.
height
;
CSSIntPoint
windowPosition
=
CSSIntPoint
:
:
Truncate
(
rootWidget
-
>
GetWindowPosition
(
)
/
scaleFactor
)
;
LayoutDeviceIntRect
tabContentBounds
=
puppetWidget
-
>
GetBounds
(
)
;
tabContentBounds
.
ScaleInverseRoundOut
(
scaleFactor
.
scale
)
;
int32_t
windowH
=
tabContentBounds
.
height
+
int
(
chromeSize
.
y
)
;
CSSIntPoint
pluginPosition
=
pluginFrame
-
>
GetScreenRect
(
)
.
TopLeft
(
)
;
CSSIntPoint
sourcePoint
=
CSSIntPoint
:
:
Truncate
(
sourceX
sourceY
)
;
CSSIntPoint
screenPoint
;
switch
(
sourceSpace
)
{
case
NPCoordinateSpacePlugin
:
screenPoint
=
sourcePoint
+
pluginPosition
+
CSSIntPoint
:
:
Truncate
(
CSSPoint
:
:
FromAppUnits
(
pluginFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
)
;
break
;
case
NPCoordinateSpaceWindow
:
screenPoint
=
CSSIntPoint
(
sourcePoint
.
x
windowH
-
sourcePoint
.
y
)
+
windowPosition
;
break
;
case
NPCoordinateSpaceFlippedWindow
:
screenPoint
=
sourcePoint
+
windowPosition
;
break
;
case
NPCoordinateSpaceScreen
:
screenPoint
=
CSSIntPoint
(
sourcePoint
.
x
screenH
-
sourcePoint
.
y
)
;
break
;
case
NPCoordinateSpaceFlippedScreen
:
screenPoint
=
sourcePoint
;
break
;
default
:
return
false
;
}
CSSIntPoint
destPoint
;
switch
(
destSpace
)
{
case
NPCoordinateSpacePlugin
:
destPoint
=
screenPoint
-
pluginPosition
-
CSSIntPoint
:
:
Truncate
(
CSSPoint
:
:
FromAppUnits
(
pluginFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
)
;
break
;
case
NPCoordinateSpaceWindow
:
destPoint
=
screenPoint
-
windowPosition
;
destPoint
.
y
=
windowH
-
destPoint
.
y
;
break
;
case
NPCoordinateSpaceFlippedWindow
:
destPoint
=
screenPoint
-
windowPosition
;
break
;
case
NPCoordinateSpaceScreen
:
destPoint
=
CSSIntPoint
(
screenPoint
.
x
screenH
-
screenPoint
.
y
)
;
break
;
case
NPCoordinateSpaceFlippedScreen
:
destPoint
=
screenPoint
;
break
;
default
:
return
false
;
}
if
(
destX
)
{
*
destX
=
destPoint
.
x
;
}
if
(
destY
)
{
*
destY
=
destPoint
.
y
;
}
return
true
;
}
NPBool
nsPluginInstanceOwner
:
:
ConvertPointNoPuppet
(
nsIWidget
*
widget
nsPluginFrame
*
pluginFrame
double
sourceX
double
sourceY
NPCoordinateSpace
sourceSpace
double
*
destX
double
*
destY
NPCoordinateSpace
destSpace
)
{
NS_ENSURE_TRUE
(
widget
&
&
pluginFrame
false
)
;
NS_ENSURE_TRUE
(
destX
|
|
destY
false
)
;
if
(
sourceSpace
=
=
destSpace
)
{
if
(
destX
)
{
*
destX
=
sourceX
;
}
if
(
destY
)
{
*
destY
=
sourceY
;
}
return
true
;
}
nsPresContext
*
presContext
=
pluginFrame
-
>
PresContext
(
)
;
double
scaleFactor
=
double
(
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
/
presContext
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
nsCOMPtr
<
nsIScreen
>
screen
=
widget
-
>
GetWidgetScreen
(
)
;
if
(
!
screen
)
{
return
false
;
}
int32_t
screenX
screenY
screenWidth
screenHeight
;
screen
-
>
GetRect
(
&
screenX
&
screenY
&
screenWidth
&
screenHeight
)
;
screenHeight
/
=
scaleFactor
;
LayoutDeviceIntRect
windowScreenBounds
=
widget
-
>
GetScreenBounds
(
)
;
windowScreenBounds
.
ScaleInverseRoundOut
(
scaleFactor
)
;
int32_t
windowX
=
windowScreenBounds
.
x
;
int32_t
windowY
=
windowScreenBounds
.
y
;
int32_t
windowHeight
=
windowScreenBounds
.
height
;
CSSIntRect
pluginScreenRect
=
pluginFrame
-
>
GetScreenRect
(
)
;
double
screenXGecko
screenYGecko
;
switch
(
sourceSpace
)
{
case
NPCoordinateSpacePlugin
:
screenXGecko
=
pluginScreenRect
.
x
+
sourceX
;
screenYGecko
=
pluginScreenRect
.
y
+
sourceY
;
break
;
case
NPCoordinateSpaceWindow
:
screenXGecko
=
windowX
+
sourceX
;
screenYGecko
=
windowY
+
(
windowHeight
-
sourceY
)
;
break
;
case
NPCoordinateSpaceFlippedWindow
:
screenXGecko
=
windowX
+
sourceX
;
screenYGecko
=
windowY
+
sourceY
;
break
;
case
NPCoordinateSpaceScreen
:
screenXGecko
=
sourceX
;
screenYGecko
=
screenHeight
-
sourceY
;
break
;
case
NPCoordinateSpaceFlippedScreen
:
screenXGecko
=
sourceX
;
screenYGecko
=
sourceY
;
break
;
default
:
return
false
;
}
double
destXCocoa
destYCocoa
;
switch
(
destSpace
)
{
case
NPCoordinateSpacePlugin
:
destXCocoa
=
screenXGecko
-
pluginScreenRect
.
x
;
destYCocoa
=
screenYGecko
-
pluginScreenRect
.
y
;
break
;
case
NPCoordinateSpaceWindow
:
destXCocoa
=
screenXGecko
-
windowX
;
destYCocoa
=
windowHeight
-
(
screenYGecko
-
windowY
)
;
break
;
case
NPCoordinateSpaceFlippedWindow
:
destXCocoa
=
screenXGecko
-
windowX
;
destYCocoa
=
screenYGecko
-
windowY
;
break
;
case
NPCoordinateSpaceScreen
:
destXCocoa
=
screenXGecko
;
destYCocoa
=
screenHeight
-
screenYGecko
;
break
;
case
NPCoordinateSpaceFlippedScreen
:
destXCocoa
=
screenXGecko
;
destYCocoa
=
screenYGecko
;
break
;
default
:
return
false
;
}
if
(
destX
)
{
*
destX
=
destXCocoa
;
}
if
(
destY
)
{
*
destY
=
destYCocoa
;
}
return
true
;
}
#
endif
NPBool
nsPluginInstanceOwner
:
:
ConvertPoint
(
double
sourceX
double
sourceY
NPCoordinateSpace
sourceSpace
double
*
destX
double
*
destY
NPCoordinateSpace
destSpace
)
{
#
ifdef
XP_MACOSX
if
(
!
mPluginFrame
)
{
return
false
;
}
MOZ_ASSERT
(
mPluginFrame
-
>
GetNearestWidget
(
)
)
;
if
(
nsIWidget
:
:
UsePuppetWidgets
(
)
)
{
return
ConvertPointPuppet
(
static_cast
<
PuppetWidget
*
>
(
mPluginFrame
-
>
GetNearestWidget
(
)
)
mPluginFrame
sourceX
sourceY
sourceSpace
destX
destY
destSpace
)
;
}
return
ConvertPointNoPuppet
(
mPluginFrame
-
>
GetNearestWidget
(
)
mPluginFrame
sourceX
sourceY
sourceSpace
destX
destY
destSpace
)
;
#
else
return
false
;
#
endif
}
NPError
nsPluginInstanceOwner
:
:
InitAsyncSurface
(
NPSize
*
size
NPImageFormat
format
void
*
initData
NPAsyncSurface
*
surface
)
{
return
NPERR_INCOMPATIBLE_VERSION_ERROR
;
}
NPError
nsPluginInstanceOwner
:
:
FinalizeAsyncSurface
(
NPAsyncSurface
*
)
{
return
NPERR_INCOMPATIBLE_VERSION_ERROR
;
}
void
nsPluginInstanceOwner
:
:
SetCurrentAsyncSurface
(
NPAsyncSurface
*
NPRect
*
)
{
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetTagType
(
nsPluginTagType
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
*
result
=
nsPluginTagType_Unknown
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
embed
)
)
*
result
=
nsPluginTagType_Embed
;
else
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
*
result
=
nsPluginTagType_Object
;
return
NS_OK
;
}
void
nsPluginInstanceOwner
:
:
GetParameters
(
nsTArray
<
MozPluginParameter
>
&
parameters
)
{
nsCOMPtr
<
nsIObjectLoadingContent
>
content
=
do_QueryReferent
(
mContent
)
;
nsObjectLoadingContent
*
loadingContent
=
static_cast
<
nsObjectLoadingContent
*
>
(
content
.
get
(
)
)
;
loadingContent
-
>
GetPluginParameters
(
parameters
)
;
}
#
ifdef
XP_MACOSX
static
void
InitializeNPCocoaEvent
(
NPCocoaEvent
*
event
)
{
memset
(
event
0
sizeof
(
NPCocoaEvent
)
)
;
}
NPDrawingModel
nsPluginInstanceOwner
:
:
GetDrawingModel
(
)
{
#
ifndef
NP_NO_QUICKDRAW
NPDrawingModel
drawingModel
=
NPDrawingModelQuickDraw
;
#
else
NPDrawingModel
drawingModel
=
NPDrawingModelCoreGraphics
;
#
endif
if
(
!
mInstance
)
return
drawingModel
;
mInstance
-
>
GetDrawingModel
(
(
int32_t
*
)
&
drawingModel
)
;
return
drawingModel
;
}
bool
nsPluginInstanceOwner
:
:
IsRemoteDrawingCoreAnimation
(
)
{
if
(
!
mInstance
)
return
false
;
bool
coreAnimation
;
if
(
!
NS_SUCCEEDED
(
mInstance
-
>
IsRemoteDrawingCoreAnimation
(
&
coreAnimation
)
)
)
return
false
;
return
coreAnimation
;
}
NPEventModel
nsPluginInstanceOwner
:
:
GetEventModel
(
)
{
return
mEventModel
;
}
#
define
DEFAULT_REFRESH_RATE
20
/
/
50
FPS
StaticRefPtr
<
nsITimer
>
nsPluginInstanceOwner
:
:
sCATimer
;
nsTArray
<
nsPluginInstanceOwner
*
>
*
nsPluginInstanceOwner
:
:
sCARefreshListeners
=
nullptr
;
void
nsPluginInstanceOwner
:
:
CARefresh
(
nsITimer
*
aTimer
void
*
aClosure
)
{
if
(
!
sCARefreshListeners
)
{
return
;
}
for
(
size_t
i
=
0
;
i
<
sCARefreshListeners
-
>
Length
(
)
;
i
+
+
)
{
nsPluginInstanceOwner
*
instanceOwner
=
(
*
sCARefreshListeners
)
[
i
]
;
NPWindow
*
window
;
instanceOwner
-
>
GetWindow
(
window
)
;
if
(
!
window
)
{
continue
;
}
NPRect
r
;
r
.
left
=
0
;
r
.
top
=
0
;
r
.
right
=
window
-
>
width
;
r
.
bottom
=
window
-
>
height
;
instanceOwner
-
>
InvalidateRect
(
&
r
)
;
}
}
void
nsPluginInstanceOwner
:
:
AddToCARefreshTimer
(
)
{
if
(
!
mInstance
)
{
return
;
}
const
char
*
mime
=
nullptr
;
if
(
NS_SUCCEEDED
(
mInstance
-
>
GetMIMEType
(
&
mime
)
)
&
&
mime
&
&
nsPluginHost
:
:
GetSpecialType
(
nsDependentCString
(
mime
)
)
=
=
nsPluginHost
:
:
eSpecialType_Flash
)
{
return
;
}
if
(
!
sCARefreshListeners
)
{
sCARefreshListeners
=
new
nsTArray
<
nsPluginInstanceOwner
*
>
(
)
;
}
if
(
sCARefreshListeners
-
>
Contains
(
this
)
)
{
return
;
}
sCARefreshListeners
-
>
AppendElement
(
this
)
;
if
(
sCARefreshListeners
-
>
Length
(
)
=
=
1
)
{
nsCOMPtr
<
nsITimer
>
timer
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
timer
)
CARefresh
nullptr
DEFAULT_REFRESH_RATE
nsITimer
:
:
TYPE_REPEATING_SLACK
"
nsPluginInstanceOwner
:
:
CARefresh
"
)
;
sCATimer
=
timer
.
forget
(
)
;
}
}
void
nsPluginInstanceOwner
:
:
RemoveFromCARefreshTimer
(
)
{
if
(
!
sCARefreshListeners
|
|
sCARefreshListeners
-
>
Contains
(
this
)
=
=
false
)
{
return
;
}
sCARefreshListeners
-
>
RemoveElement
(
this
)
;
if
(
sCARefreshListeners
-
>
Length
(
)
=
=
0
)
{
if
(
sCATimer
)
{
sCATimer
-
>
Cancel
(
)
;
sCATimer
=
nullptr
;
}
delete
sCARefreshListeners
;
sCARefreshListeners
=
nullptr
;
}
}
void
nsPluginInstanceOwner
:
:
SetPluginPort
(
)
{
void
*
pluginPort
=
GetPluginPort
(
)
;
if
(
!
pluginPort
|
|
!
mPluginWindow
)
return
;
mPluginWindow
-
>
window
=
pluginPort
;
}
#
endif
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
XP_WIN
)
nsresult
nsPluginInstanceOwner
:
:
ContentsScaleFactorChanged
(
double
aContentsScaleFactor
)
{
if
(
!
mInstance
)
{
return
NS_ERROR_NULL_POINTER
;
}
return
mInstance
-
>
ContentsScaleFactorChanged
(
aContentsScaleFactor
)
;
}
#
endif
uint32_t
nsPluginInstanceOwner
:
:
GetEventloopNestingLevel
(
)
{
nsCOMPtr
<
nsIAppShell
>
appShell
=
do_GetService
(
kAppShellCID
)
;
uint32_t
currentLevel
=
0
;
if
(
appShell
)
{
appShell
-
>
GetEventloopNestingLevel
(
&
currentLevel
)
;
#
ifdef
XP_MACOSX
currentLevel
+
+
;
#
endif
}
if
(
!
currentLevel
)
{
currentLevel
+
+
;
}
return
currentLevel
;
}
nsresult
nsPluginInstanceOwner
:
:
DispatchFocusToPlugin
(
Event
*
aFocusEvent
)
{
#
ifndef
XP_MACOSX
if
(
!
mPluginWindow
|
|
(
mPluginWindow
-
>
type
=
=
NPWindowTypeWindow
)
)
{
aFocusEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
#
endif
WidgetEvent
*
theEvent
=
aFocusEvent
-
>
WidgetEventPtr
(
)
;
if
(
theEvent
)
{
WidgetGUIEvent
focusEvent
(
theEvent
-
>
IsTrusted
(
)
theEvent
-
>
mMessage
nullptr
)
;
nsEventStatus
rv
=
ProcessEvent
(
focusEvent
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
rv
)
{
aFocusEvent
-
>
PreventDefault
(
)
;
aFocusEvent
-
>
StopPropagation
(
)
;
}
}
return
NS_OK
;
}
nsresult
nsPluginInstanceOwner
:
:
ProcessKeyPress
(
Event
*
aKeyEvent
)
{
if
(
!
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
&
&
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mInSystemGroup
)
{
return
NS_OK
;
}
#
ifdef
XP_MACOSX
return
DispatchKeyToPlugin
(
aKeyEvent
)
;
#
else
if
(
SendNativeEvents
(
)
)
DispatchKeyToPlugin
(
aKeyEvent
)
;
if
(
mInstance
)
{
aKeyEvent
-
>
PreventDefault
(
)
;
aKeyEvent
-
>
StopPropagation
(
)
;
}
return
NS_OK
;
#
endif
}
nsresult
nsPluginInstanceOwner
:
:
DispatchKeyToPlugin
(
Event
*
aKeyEvent
)
{
#
if
!
defined
(
XP_MACOSX
)
if
(
!
mPluginWindow
|
|
(
mPluginWindow
-
>
type
=
=
NPWindowTypeWindow
)
)
{
aKeyEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
#
endif
if
(
mInstance
)
{
WidgetKeyboardEvent
*
keyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
keyEvent
&
&
keyEvent
-
>
mClass
=
=
eKeyboardEventClass
)
{
nsEventStatus
rv
=
ProcessEvent
(
*
keyEvent
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
rv
)
{
aKeyEvent
-
>
PreventDefault
(
)
;
aKeyEvent
-
>
StopPropagation
(
)
;
}
}
}
return
NS_OK
;
}
nsresult
nsPluginInstanceOwner
:
:
ProcessMouseDown
(
Event
*
aMouseEvent
)
{
#
if
!
defined
(
XP_MACOSX
)
if
(
!
mPluginWindow
|
|
(
mPluginWindow
-
>
type
=
=
NPWindowTypeWindow
)
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
#
endif
if
(
mPluginFrame
&
&
mPluginWindow
&
&
mPluginWindow
-
>
type
=
=
NPWindowTypeDrawable
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsCOMPtr
<
Element
>
elem
=
do_QueryReferent
(
mContent
)
;
fm
-
>
SetFocus
(
elem
0
)
;
}
}
WidgetMouseEvent
*
mouseEvent
=
aMouseEvent
-
>
WidgetEventPtr
(
)
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
mClass
=
=
eMouseEventClass
)
{
mLastMouseDownButtonType
=
mouseEvent
-
>
button
;
nsEventStatus
rv
=
ProcessEvent
(
*
mouseEvent
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
rv
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
}
return
NS_OK
;
}
nsresult
nsPluginInstanceOwner
:
:
DispatchMouseToPlugin
(
Event
*
aMouseEvent
bool
aAllowPropagate
)
{
#
if
!
defined
(
XP_MACOSX
)
if
(
!
mPluginWindow
|
|
(
mPluginWindow
-
>
type
=
=
NPWindowTypeWindow
)
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
#
endif
if
(
!
mWidgetVisible
)
return
NS_OK
;
WidgetMouseEvent
*
mouseEvent
=
aMouseEvent
-
>
WidgetEventPtr
(
)
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
mClass
=
=
eMouseEventClass
)
{
nsEventStatus
rv
=
ProcessEvent
(
*
mouseEvent
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
rv
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
if
(
!
aAllowPropagate
)
{
aMouseEvent
-
>
StopPropagation
(
)
;
}
}
if
(
mouseEvent
-
>
mMessage
=
=
eMouseUp
)
{
mLastMouseDownButtonType
=
-
1
;
}
}
return
NS_OK
;
}
#
ifdef
XP_WIN
void
nsPluginInstanceOwner
:
:
CallDefaultProc
(
const
WidgetGUIEvent
*
aEvent
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetContainingWidgetIfOffset
(
)
;
if
(
!
widget
)
{
widget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
;
}
}
const
NPEvent
*
npEvent
=
static_cast
<
const
NPEvent
*
>
(
aEvent
-
>
mPluginEvent
)
;
if
(
NS_WARN_IF
(
!
npEvent
)
)
{
return
;
}
WidgetPluginEvent
pluginEvent
(
true
ePluginInputEvent
widget
)
;
pluginEvent
.
mPluginEvent
.
Copy
(
*
npEvent
)
;
widget
-
>
DefaultProcOfPluginEvent
(
pluginEvent
)
;
}
already_AddRefed
<
TextComposition
>
nsPluginInstanceOwner
:
:
GetTextComposition
(
)
{
if
(
NS_WARN_IF
(
!
mPluginFrame
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
GetContainingWidgetIfOffset
(
)
;
if
(
!
widget
)
{
widget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
nullptr
;
}
}
RefPtr
<
TextComposition
>
composition
=
IMEStateManager
:
:
GetTextCompositionFor
(
widget
)
;
if
(
NS_WARN_IF
(
!
composition
)
)
{
return
nullptr
;
}
return
composition
.
forget
(
)
;
}
void
nsPluginInstanceOwner
:
:
HandleNoConsumedCompositionMessage
(
WidgetCompositionEvent
*
aCompositionEvent
const
NPEvent
*
aPluginEvent
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetContainingWidgetIfOffset
(
)
;
if
(
!
widget
)
{
widget
=
GetRootWidgetForPluginFrame
(
mPluginFrame
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
;
}
}
NPEvent
npevent
;
if
(
aPluginEvent
-
>
lParam
&
GCS_RESULTSTR
)
{
for
(
size_t
i
=
0
;
i
<
aCompositionEvent
-
>
mData
.
Length
(
)
;
i
+
+
)
{
WidgetPluginEvent
charEvent
(
true
ePluginInputEvent
widget
)
;
npevent
.
event
=
WM_CHAR
;
npevent
.
wParam
=
aCompositionEvent
-
>
mData
[
i
]
;
npevent
.
lParam
=
0
;
charEvent
.
mPluginEvent
.
Copy
(
npevent
)
;
ProcessEvent
(
charEvent
)
;
}
return
;
}
if
(
!
mSentStartComposition
)
{
WidgetPluginEvent
startEvent
(
true
ePluginInputEvent
widget
)
;
npevent
.
event
=
WM_IME_STARTCOMPOSITION
;
npevent
.
wParam
=
0
;
npevent
.
lParam
=
0
;
startEvent
.
mPluginEvent
.
Copy
(
npevent
)
;
CallDefaultProc
(
&
startEvent
)
;
mSentStartComposition
=
true
;
}
CallDefaultProc
(
aCompositionEvent
)
;
}
#
endif
nsresult
nsPluginInstanceOwner
:
:
DispatchCompositionToPlugin
(
Event
*
aEvent
)
{
#
ifdef
XP_WIN
if
(
!
mPluginWindow
)
{
return
NS_OK
;
}
WidgetCompositionEvent
*
compositionEvent
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsCompositionEvent
(
)
;
if
(
NS_WARN_IF
(
!
compositionEvent
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
compositionEvent
-
>
mMessage
=
=
eCompositionChange
)
{
RefPtr
<
TextComposition
>
composition
=
GetTextComposition
(
)
;
if
(
NS_WARN_IF
(
!
composition
)
)
{
return
NS_ERROR_FAILURE
;
}
TextComposition
:
:
CompositionChangeEventHandlingMarker
compositionChangeEventHandlingMarker
(
composition
compositionEvent
)
;
}
const
NPEvent
*
pPluginEvent
=
static_cast
<
const
NPEvent
*
>
(
compositionEvent
-
>
mPluginEvent
)
;
if
(
pPluginEvent
&
&
pPluginEvent
-
>
event
=
=
WM_IME_COMPOSITION
&
&
mPluginDidNotHandleIMEComposition
)
{
HandleNoConsumedCompositionMessage
(
compositionEvent
pPluginEvent
)
;
aEvent
-
>
StopImmediatePropagation
(
)
;
return
NS_OK
;
}
AutoRestore
<
bool
>
restore
(
mGotCompositionData
)
;
mGotCompositionData
=
false
;
nsEventStatus
status
=
ProcessEvent
(
*
compositionEvent
)
;
aEvent
-
>
StopImmediatePropagation
(
)
;
if
(
NS_WARN_IF
(
!
pPluginEvent
)
)
{
return
NS_OK
;
}
if
(
pPluginEvent
-
>
event
=
=
WM_IME_STARTCOMPOSITION
)
{
if
(
nsEventStatus_eConsumeNoDefault
!
=
status
)
{
CallDefaultProc
(
compositionEvent
)
;
mSentStartComposition
=
true
;
}
else
{
mSentStartComposition
=
false
;
}
mPluginDidNotHandleIMEComposition
=
false
;
return
NS_OK
;
}
if
(
pPluginEvent
-
>
event
=
=
WM_IME_ENDCOMPOSITION
)
{
CallDefaultProc
(
compositionEvent
)
;
return
NS_OK
;
}
if
(
pPluginEvent
-
>
event
=
=
WM_IME_COMPOSITION
&
&
!
mGotCompositionData
)
{
mPluginDidNotHandleIMEComposition
=
true
;
HandleNoConsumedCompositionMessage
(
compositionEvent
pPluginEvent
)
;
}
#
endif
return
NS_OK
;
}
nsresult
nsPluginInstanceOwner
:
:
HandleEvent
(
Event
*
aEvent
)
{
NS_ASSERTION
(
mInstance
"
Should
have
a
valid
plugin
instance
or
not
receive
events
.
"
)
;
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
#
ifdef
XP_MACOSX
if
(
eventType
.
EqualsLiteral
(
"
activate
"
)
|
|
eventType
.
EqualsLiteral
(
"
deactivate
"
)
)
{
WindowFocusMayHaveChanged
(
)
;
return
NS_OK
;
}
if
(
eventType
.
EqualsLiteral
(
"
MozPerformDelayedBlur
"
)
)
{
if
(
mShouldBlurOnActivate
)
{
WidgetGUIEvent
blurEvent
(
true
eBlur
nullptr
)
;
ProcessEvent
(
blurEvent
)
;
mShouldBlurOnActivate
=
false
;
}
return
NS_OK
;
}
#
endif
if
(
eventType
.
EqualsLiteral
(
"
focus
"
)
)
{
mContentFocused
=
true
;
return
DispatchFocusToPlugin
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
blur
"
)
)
{
mContentFocused
=
false
;
return
DispatchFocusToPlugin
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mousedown
"
)
)
{
return
ProcessMouseDown
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mouseup
"
)
)
{
return
DispatchMouseToPlugin
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mousemove
"
)
)
{
return
DispatchMouseToPlugin
(
aEvent
true
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
click
"
)
|
|
eventType
.
EqualsLiteral
(
"
dblclick
"
)
|
|
eventType
.
EqualsLiteral
(
"
mouseover
"
)
|
|
eventType
.
EqualsLiteral
(
"
mouseout
"
)
)
{
return
DispatchMouseToPlugin
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keydown
"
)
|
|
eventType
.
EqualsLiteral
(
"
keyup
"
)
)
{
return
DispatchKeyToPlugin
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keypress
"
)
)
{
return
ProcessKeyPress
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
compositionstart
"
)
|
|
eventType
.
EqualsLiteral
(
"
compositionend
"
)
|
|
eventType
.
EqualsLiteral
(
"
text
"
)
)
{
return
DispatchCompositionToPlugin
(
aEvent
)
;
}
DragEvent
*
dragEvent
=
aEvent
-
>
AsDragEvent
(
)
;
if
(
dragEvent
&
&
mInstance
)
{
WidgetEvent
*
ievent
=
aEvent
-
>
WidgetEventPtr
(
)
;
if
(
ievent
&
&
ievent
-
>
IsTrusted
(
)
&
&
ievent
-
>
mMessage
!
=
eDragEnter
&
&
ievent
-
>
mMessage
!
=
eDragOver
)
{
aEvent
-
>
PreventDefault
(
)
;
}
aEvent
-
>
StopPropagation
(
)
;
}
return
NS_OK
;
}
#
ifdef
MOZ_X11
static
unsigned
int
XInputEventState
(
const
WidgetInputEvent
&
anEvent
)
{
unsigned
int
state
=
0
;
if
(
anEvent
.
IsShift
(
)
)
state
|
=
ShiftMask
;
if
(
anEvent
.
IsControl
(
)
)
state
|
=
ControlMask
;
if
(
anEvent
.
IsAlt
(
)
)
state
|
=
Mod1Mask
;
if
(
anEvent
.
IsMeta
(
)
)
state
|
=
Mod4Mask
;
return
state
;
}
#
endif
#
ifdef
XP_MACOSX
static
bool
ContentIsFocusedWithinWindow
(
nsIContent
*
aContent
)
{
nsPIDOMWindowOuter
*
outerWindow
=
aContent
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
;
if
(
!
outerWindow
)
{
return
false
;
}
nsPIDOMWindowOuter
*
rootWindow
=
outerWindow
-
>
GetPrivateRoot
(
)
;
if
(
!
rootWindow
)
{
return
false
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedFrame
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
rootWindow
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
focusedFrame
)
)
;
return
(
focusedContent
.
get
(
)
=
=
aContent
)
;
}
static
NPCocoaEventType
CocoaEventTypeForEvent
(
const
WidgetGUIEvent
&
anEvent
nsIFrame
*
aObjectFrame
)
{
const
NPCocoaEvent
*
event
=
static_cast
<
const
NPCocoaEvent
*
>
(
anEvent
.
mPluginEvent
)
;
if
(
event
)
{
return
event
-
>
type
;
}
switch
(
anEvent
.
mMessage
)
{
case
eMouseOver
:
return
NPCocoaEventMouseEntered
;
case
eMouseOut
:
return
NPCocoaEventMouseExited
;
case
eMouseMove
:
{
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
)
{
return
NPCocoaEventMouseDragged
;
}
return
NPCocoaEventMouseMoved
;
}
case
eMouseDown
:
return
NPCocoaEventMouseDown
;
case
eMouseUp
:
return
NPCocoaEventMouseUp
;
case
eKeyDown
:
return
NPCocoaEventKeyDown
;
case
eKeyUp
:
return
NPCocoaEventKeyUp
;
case
eFocus
:
case
eBlur
:
return
NPCocoaEventFocusChanged
;
case
eLegacyMouseLineOrPageScroll
:
return
NPCocoaEventScrollWheel
;
default
:
return
(
NPCocoaEventType
)
0
;
}
}
static
NPCocoaEvent
TranslateToNPCocoaEvent
(
WidgetGUIEvent
*
anEvent
nsIFrame
*
aObjectFrame
)
{
NPCocoaEvent
cocoaEvent
;
InitializeNPCocoaEvent
(
&
cocoaEvent
)
;
cocoaEvent
.
type
=
CocoaEventTypeForEvent
(
*
anEvent
aObjectFrame
)
;
if
(
anEvent
-
>
mMessage
=
=
eMouseMove
|
|
anEvent
-
>
mMessage
=
=
eMouseDown
|
|
anEvent
-
>
mMessage
=
=
eMouseUp
|
|
anEvent
-
>
mMessage
=
=
eLegacyMouseLineOrPageScroll
|
|
anEvent
-
>
mMessage
=
=
eMouseOver
|
|
anEvent
-
>
mMessage
=
=
eMouseOut
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
anEvent
aObjectFrame
)
-
aObjectFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
;
nsPresContext
*
presContext
=
aObjectFrame
-
>
PresContext
(
)
;
double
scaleFactor
=
double
(
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
/
aObjectFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
size_t
intScaleFactor
=
ceil
(
scaleFactor
)
;
nsIntPoint
ptPx
(
presContext
-
>
AppUnitsToDevPixels
(
pt
.
x
)
/
intScaleFactor
presContext
-
>
AppUnitsToDevPixels
(
pt
.
y
)
/
intScaleFactor
)
;
cocoaEvent
.
data
.
mouse
.
pluginX
=
double
(
ptPx
.
x
)
;
cocoaEvent
.
data
.
mouse
.
pluginY
=
double
(
ptPx
.
y
)
;
}
switch
(
anEvent
-
>
mMessage
)
{
case
eMouseDown
:
case
eMouseUp
:
{
WidgetMouseEvent
*
mouseEvent
=
anEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
)
{
switch
(
mouseEvent
-
>
button
)
{
case
WidgetMouseEvent
:
:
eLeftButton
:
cocoaEvent
.
data
.
mouse
.
buttonNumber
=
0
;
break
;
case
WidgetMouseEvent
:
:
eRightButton
:
cocoaEvent
.
data
.
mouse
.
buttonNumber
=
1
;
break
;
case
WidgetMouseEvent
:
:
eMiddleButton
:
cocoaEvent
.
data
.
mouse
.
buttonNumber
=
2
;
break
;
default
:
NS_WARNING
(
"
Mouse
button
we
don
'
t
know
about
?
"
)
;
}
cocoaEvent
.
data
.
mouse
.
clickCount
=
mouseEvent
-
>
mClickCount
;
}
else
{
NS_WARNING
(
"
eMouseUp
/
DOWN
is
not
a
WidgetMouseEvent
?
"
)
;
}
break
;
}
case
eLegacyMouseLineOrPageScroll
:
{
WidgetWheelEvent
*
wheelEvent
=
anEvent
-
>
AsWheelEvent
(
)
;
if
(
wheelEvent
)
{
cocoaEvent
.
data
.
mouse
.
deltaX
=
wheelEvent
-
>
mLineOrPageDeltaX
;
cocoaEvent
.
data
.
mouse
.
deltaY
=
wheelEvent
-
>
mLineOrPageDeltaY
;
}
else
{
NS_WARNING
(
"
eLegacyMouseLineOrPageScroll
is
not
a
WidgetWheelEvent
?
"
"
(
could
be
haven
'
t
checked
)
"
)
;
}
break
;
}
case
eKeyDown
:
case
eKeyUp
:
{
WidgetKeyboardEvent
*
keyEvent
=
anEvent
-
>
AsKeyboardEvent
(
)
;
if
(
anEvent
-
>
mMessage
=
=
eKeyDown
&
&
!
keyEvent
-
>
mPluginTextEventString
.
IsEmpty
(
)
)
{
cocoaEvent
.
type
=
NPCocoaEventTextInput
;
const
char16_t
*
pluginTextEventString
=
keyEvent
-
>
mPluginTextEventString
.
get
(
)
;
cocoaEvent
.
data
.
text
.
text
=
(
NPNSString
*
)
:
:
CFStringCreateWithCharacters
(
NULL
reinterpret_cast
<
const
UniChar
*
>
(
pluginTextEventString
)
keyEvent
-
>
mPluginTextEventString
.
Length
(
)
)
;
}
else
{
cocoaEvent
.
data
.
key
.
keyCode
=
keyEvent
-
>
mNativeKeyCode
;
cocoaEvent
.
data
.
key
.
isARepeat
=
keyEvent
-
>
mIsRepeat
;
cocoaEvent
.
data
.
key
.
modifierFlags
=
keyEvent
-
>
mNativeModifierFlags
;
const
char16_t
*
nativeChars
=
keyEvent
-
>
mNativeCharacters
.
get
(
)
;
cocoaEvent
.
data
.
key
.
characters
=
(
NPNSString
*
)
:
:
CFStringCreateWithCharacters
(
NULL
reinterpret_cast
<
const
UniChar
*
>
(
nativeChars
)
keyEvent
-
>
mNativeCharacters
.
Length
(
)
)
;
const
char16_t
*
nativeCharsIgnoringModifiers
=
keyEvent
-
>
mNativeCharactersIgnoringModifiers
.
get
(
)
;
cocoaEvent
.
data
.
key
.
charactersIgnoringModifiers
=
(
NPNSString
*
)
:
:
CFStringCreateWithCharacters
(
NULL
reinterpret_cast
<
const
UniChar
*
>
(
nativeCharsIgnoringModifiers
)
keyEvent
-
>
mNativeCharactersIgnoringModifiers
.
Length
(
)
)
;
}
break
;
}
case
eFocus
:
case
eBlur
:
cocoaEvent
.
data
.
focus
.
hasFocus
=
(
anEvent
-
>
mMessage
=
=
eFocus
)
;
break
;
default
:
break
;
}
return
cocoaEvent
;
}
void
nsPluginInstanceOwner
:
:
PerformDelayedBlurs
(
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
nsCOMPtr
<
EventTarget
>
windowRoot
=
content
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
-
>
GetTopWindowRoot
(
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
content
-
>
OwnerDoc
(
)
windowRoot
NS_LITERAL_STRING
(
"
MozPerformDelayedBlur
"
)
CanBubble
:
:
eNo
Cancelable
:
:
eNo
nullptr
)
;
}
#
endif
nsEventStatus
nsPluginInstanceOwner
:
:
ProcessEvent
(
const
WidgetGUIEvent
&
anEvent
)
{
nsEventStatus
rv
=
nsEventStatus_eIgnore
;
if
(
!
mInstance
|
|
!
mPluginFrame
)
{
return
nsEventStatus_eIgnore
;
}
#
ifdef
XP_MACOSX
NPEventModel
eventModel
=
GetEventModel
(
)
;
if
(
eventModel
!
=
NPEventModelCocoa
)
{
return
nsEventStatus_eIgnore
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
anEvent
.
mMessage
=
=
eBlur
&
&
ContentIsFocusedWithinWindow
(
content
)
)
{
mShouldBlurOnActivate
=
true
;
return
nsEventStatus_eIgnore
;
}
if
(
anEvent
.
mMessage
=
=
eFocus
&
&
mLastContentFocused
=
=
true
)
{
mShouldBlurOnActivate
=
false
;
return
nsEventStatus_eIgnore
;
}
if
(
anEvent
.
mMessage
=
=
eFocus
|
|
anEvent
.
mMessage
=
=
eBlur
)
{
mLastContentFocused
=
(
anEvent
.
mMessage
=
=
eFocus
)
;
mShouldBlurOnActivate
=
false
;
PerformDelayedBlurs
(
)
;
}
NPCocoaEvent
cocoaEvent
=
TranslateToNPCocoaEvent
(
const_cast
<
WidgetGUIEvent
*
>
(
&
anEvent
)
mPluginFrame
)
;
if
(
cocoaEvent
.
type
=
=
(
NPCocoaEventType
)
0
)
{
return
nsEventStatus_eIgnore
;
}
if
(
cocoaEvent
.
type
=
=
NPCocoaEventTextInput
)
{
mInstance
-
>
HandleEvent
(
&
cocoaEvent
nullptr
)
;
return
nsEventStatus_eConsumeNoDefault
;
}
int16_t
response
=
kNPEventNotHandled
;
mInstance
-
>
HandleEvent
(
&
cocoaEvent
&
response
NS_PLUGIN_CALL_SAFE_TO_REENTER_GECKO
)
;
if
(
(
response
=
=
kNPEventStartIME
)
&
&
(
cocoaEvent
.
type
=
=
NPCocoaEventKeyDown
)
)
{
nsIWidget
*
widget
=
mPluginFrame
-
>
GetNearestWidget
(
)
;
if
(
widget
)
{
const
WidgetKeyboardEvent
*
keyEvent
=
anEvent
.
AsKeyboardEvent
(
)
;
double
screenX
screenY
;
ConvertPoint
(
0
.
0
mPluginFrame
-
>
GetScreenRect
(
)
.
height
NPCoordinateSpacePlugin
&
screenX
&
screenY
NPCoordinateSpaceScreen
)
;
nsAutoString
outText
;
if
(
NS_SUCCEEDED
(
widget
-
>
StartPluginIME
(
*
keyEvent
screenX
screenY
outText
)
)
&
&
!
outText
.
IsEmpty
(
)
)
{
CFStringRef
cfString
=
:
:
CFStringCreateWithCharacters
(
kCFAllocatorDefault
reinterpret_cast
<
const
UniChar
*
>
(
outText
.
get
(
)
)
outText
.
Length
(
)
)
;
NPCocoaEvent
textEvent
;
InitializeNPCocoaEvent
(
&
textEvent
)
;
textEvent
.
type
=
NPCocoaEventTextInput
;
textEvent
.
data
.
text
.
text
=
(
NPNSString
*
)
cfString
;
mInstance
-
>
HandleEvent
(
&
textEvent
nullptr
)
;
}
}
}
bool
handled
=
(
response
=
=
kNPEventHandled
|
|
response
=
=
kNPEventStartIME
)
;
bool
leftMouseButtonDown
=
(
anEvent
.
mMessage
=
=
eMouseDown
)
&
&
(
anEvent
.
AsMouseEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
;
if
(
handled
&
&
!
(
leftMouseButtonDown
&
&
!
mContentFocused
)
)
{
rv
=
nsEventStatus_eConsumeNoDefault
;
}
#
endif
#
ifdef
XP_WIN
const
NPEvent
*
pPluginEvent
=
static_cast
<
const
NPEvent
*
>
(
anEvent
.
mPluginEvent
)
;
NPEvent
pluginEvent
;
if
(
anEvent
.
mClass
=
=
eMouseEventClass
|
|
anEvent
.
mClass
=
=
eWheelEventClass
)
{
if
(
!
pPluginEvent
)
{
pluginEvent
.
event
=
0
;
bool
initWParamWithCurrentState
=
true
;
switch
(
anEvent
.
mMessage
)
{
case
eMouseMove
:
{
pluginEvent
.
event
=
WM_MOUSEMOVE
;
break
;
}
case
eMouseDown
:
{
static
const
int
downMsgs
[
]
=
{
WM_LBUTTONDOWN
WM_MBUTTONDOWN
WM_RBUTTONDOWN
}
;
static
const
int
dblClickMsgs
[
]
=
{
WM_LBUTTONDBLCLK
WM_MBUTTONDBLCLK
WM_RBUTTONDBLCLK
}
;
const
WidgetMouseEvent
*
mouseEvent
=
anEvent
.
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
mClickCount
=
=
2
)
{
pluginEvent
.
event
=
dblClickMsgs
[
mouseEvent
-
>
button
]
;
}
else
{
pluginEvent
.
event
=
downMsgs
[
mouseEvent
-
>
button
]
;
}
break
;
}
case
eMouseUp
:
{
static
const
int
upMsgs
[
]
=
{
WM_LBUTTONUP
WM_MBUTTONUP
WM_RBUTTONUP
}
;
const
WidgetMouseEvent
*
mouseEvent
=
anEvent
.
AsMouseEvent
(
)
;
pluginEvent
.
event
=
upMsgs
[
mouseEvent
-
>
button
]
;
break
;
}
case
eWheel
:
{
const
WidgetWheelEvent
*
wheelEvent
=
anEvent
.
AsWheelEvent
(
)
;
int32_t
delta
=
0
;
if
(
wheelEvent
-
>
mLineOrPageDeltaY
)
{
switch
(
wheelEvent
-
>
mDeltaMode
)
{
case
WheelEvent_Binding
:
:
DOM_DELTA_PAGE
:
pluginEvent
.
event
=
WM_MOUSEWHEEL
;
delta
=
-
WHEEL_DELTA
*
wheelEvent
-
>
mLineOrPageDeltaY
;
break
;
case
WheelEvent_Binding
:
:
DOM_DELTA_LINE
:
{
UINT
linesPerWheelDelta
=
0
;
if
(
NS_WARN_IF
(
!
:
:
SystemParametersInfo
(
SPI_GETWHEELSCROLLLINES
0
&
linesPerWheelDelta
0
)
)
)
{
linesPerWheelDelta
=
3
;
}
if
(
!
linesPerWheelDelta
)
{
break
;
}
pluginEvent
.
event
=
WM_MOUSEWHEEL
;
delta
=
-
WHEEL_DELTA
/
linesPerWheelDelta
;
delta
*
=
wheelEvent
-
>
mLineOrPageDeltaY
;
break
;
}
case
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
:
default
:
MOZ_ASSERT
(
!
pluginEvent
.
event
)
;
break
;
}
}
else
if
(
wheelEvent
-
>
mLineOrPageDeltaX
)
{
switch
(
wheelEvent
-
>
mDeltaMode
)
{
case
WheelEvent_Binding
:
:
DOM_DELTA_PAGE
:
pluginEvent
.
event
=
WM_MOUSEHWHEEL
;
delta
=
-
WHEEL_DELTA
*
wheelEvent
-
>
mLineOrPageDeltaX
;
break
;
case
WheelEvent_Binding
:
:
DOM_DELTA_LINE
:
{
pluginEvent
.
event
=
WM_MOUSEHWHEEL
;
UINT
charsPerWheelDelta
=
0
;
if
(
:
:
SystemParametersInfo
(
SPI_GETWHEELSCROLLCHARS
0
&
charsPerWheelDelta
0
)
)
{
charsPerWheelDelta
=
3
;
}
if
(
!
charsPerWheelDelta
)
{
break
;
}
delta
=
WHEEL_DELTA
/
charsPerWheelDelta
;
delta
*
=
wheelEvent
-
>
mLineOrPageDeltaX
;
break
;
}
case
WheelEvent_Binding
:
:
DOM_DELTA_PIXEL
:
default
:
MOZ_ASSERT
(
!
pluginEvent
.
event
)
;
break
;
}
}
if
(
!
pluginEvent
.
event
)
{
break
;
}
initWParamWithCurrentState
=
false
;
int32_t
modifiers
=
(
wheelEvent
-
>
IsControl
(
)
?
MK_CONTROL
:
0
)
|
(
wheelEvent
-
>
IsShift
(
)
?
MK_SHIFT
:
0
)
|
(
wheelEvent
-
>
IsLeftButtonPressed
(
)
?
MK_LBUTTON
:
0
)
|
(
wheelEvent
-
>
IsMiddleButtonPressed
(
)
?
MK_MBUTTON
:
0
)
|
(
wheelEvent
-
>
IsRightButtonPressed
(
)
?
MK_RBUTTON
:
0
)
|
(
wheelEvent
-
>
Is4thButtonPressed
(
)
?
MK_XBUTTON1
:
0
)
|
(
wheelEvent
-
>
Is5thButtonPressed
(
)
?
MK_XBUTTON2
:
0
)
;
pluginEvent
.
wParam
=
MAKEWPARAM
(
modifiers
delta
)
;
pPluginEvent
=
&
pluginEvent
;
break
;
}
default
:
break
;
}
if
(
pluginEvent
.
event
&
&
initWParamWithCurrentState
)
{
pPluginEvent
=
&
pluginEvent
;
pluginEvent
.
wParam
=
(
:
:
GetKeyState
(
VK_CONTROL
)
?
MK_CONTROL
:
0
)
|
(
:
:
GetKeyState
(
VK_SHIFT
)
?
MK_SHIFT
:
0
)
|
(
:
:
GetKeyState
(
VK_LBUTTON
)
?
MK_LBUTTON
:
0
)
|
(
:
:
GetKeyState
(
VK_MBUTTON
)
?
MK_MBUTTON
:
0
)
|
(
:
:
GetKeyState
(
VK_RBUTTON
)
?
MK_RBUTTON
:
0
)
|
(
:
:
GetKeyState
(
VK_XBUTTON1
)
?
MK_XBUTTON1
:
0
)
|
(
:
:
GetKeyState
(
VK_XBUTTON2
)
?
MK_XBUTTON2
:
0
)
;
}
}
if
(
pPluginEvent
)
{
NS_ASSERTION
(
anEvent
.
mMessage
=
=
eMouseDown
|
|
anEvent
.
mMessage
=
=
eMouseUp
|
|
anEvent
.
mMessage
=
=
eMouseDoubleClick
|
|
anEvent
.
mMessage
=
=
eMouseAuxClick
|
|
anEvent
.
mMessage
=
=
eMouseOver
|
|
anEvent
.
mMessage
=
=
eMouseOut
|
|
anEvent
.
mMessage
=
=
eMouseMove
|
|
anEvent
.
mMessage
=
=
eWheel
"
Incorrect
event
type
for
coordinate
translation
"
)
;
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
&
anEvent
mPluginFrame
)
-
mPluginFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
;
nsPresContext
*
presContext
=
mPluginFrame
-
>
PresContext
(
)
;
nsIntPoint
ptPx
(
presContext
-
>
AppUnitsToDevPixels
(
pt
.
x
)
presContext
-
>
AppUnitsToDevPixels
(
pt
.
y
)
)
;
nsIntPoint
widgetPtPx
=
ptPx
+
mPluginFrame
-
>
GetWindowOriginInPixels
(
true
)
;
const_cast
<
NPEvent
*
>
(
pPluginEvent
)
-
>
lParam
=
MAKELPARAM
(
widgetPtPx
.
x
widgetPtPx
.
y
)
;
}
}
else
if
(
!
pPluginEvent
)
{
switch
(
anEvent
.
mMessage
)
{
case
eFocus
:
pluginEvent
.
event
=
WM_SETFOCUS
;
pluginEvent
.
wParam
=
0
;
pluginEvent
.
lParam
=
0
;
pPluginEvent
=
&
pluginEvent
;
break
;
case
eBlur
:
pluginEvent
.
event
=
WM_KILLFOCUS
;
pluginEvent
.
wParam
=
0
;
pluginEvent
.
lParam
=
0
;
pPluginEvent
=
&
pluginEvent
;
break
;
default
:
break
;
}
}
if
(
pPluginEvent
&
&
!
pPluginEvent
-
>
event
)
{
NS_WARNING
(
"
nsPluginFrame
ProcessEvent
:
trying
to
send
null
event
to
plugin
.
"
)
;
return
rv
;
}
if
(
pPluginEvent
)
{
int16_t
response
=
kNPEventNotHandled
;
mInstance
-
>
HandleEvent
(
const_cast
<
NPEvent
*
>
(
pPluginEvent
)
&
response
NS_PLUGIN_CALL_SAFE_TO_REENTER_GECKO
)
;
if
(
response
=
=
kNPEventHandled
)
rv
=
nsEventStatus_eConsumeNoDefault
;
}
#
endif
#
ifdef
MOZ_X11
nsIWidget
*
widget
=
anEvent
.
mWidget
;
XEvent
pluginEvent
=
XEvent
(
)
;
pluginEvent
.
type
=
0
;
switch
(
anEvent
.
mClass
)
{
case
eMouseEventClass
:
{
switch
(
anEvent
.
mMessage
)
{
case
eMouseClick
:
case
eMouseDoubleClick
:
case
eMouseAuxClick
:
return
rv
;
default
:
break
;
}
const
nsPresContext
*
presContext
=
mPluginFrame
-
>
PresContext
(
)
;
nsPoint
appPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
&
anEvent
mPluginFrame
)
-
mPluginFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
;
nsIntPoint
pluginPoint
(
presContext
-
>
AppUnitsToDevPixels
(
appPoint
.
x
)
presContext
-
>
AppUnitsToDevPixels
(
appPoint
.
y
)
)
;
const
WidgetMouseEvent
&
mouseEvent
=
*
anEvent
.
AsMouseEvent
(
)
;
LayoutDeviceIntPoint
rootPoint
(
-
1
-
1
)
;
if
(
widget
)
{
rootPoint
=
anEvent
.
mRefPoint
+
widget
-
>
WidgetToScreenOffset
(
)
;
}
#
ifdef
MOZ_WIDGET_GTK
Window
root
=
GDK_ROOT_WINDOW
(
)
;
#
else
Window
root
=
X11None
;
#
endif
switch
(
anEvent
.
mMessage
)
{
case
eMouseOver
:
case
eMouseOut
:
{
XCrossingEvent
&
event
=
pluginEvent
.
xcrossing
;
event
.
type
=
anEvent
.
mMessage
=
=
eMouseOver
?
EnterNotify
:
LeaveNotify
;
event
.
root
=
root
;
event
.
time
=
anEvent
.
mTime
;
event
.
x
=
pluginPoint
.
x
;
event
.
y
=
pluginPoint
.
y
;
event
.
x_root
=
rootPoint
.
x
;
event
.
y_root
=
rootPoint
.
y
;
event
.
state
=
XInputEventState
(
mouseEvent
)
;
event
.
subwindow
=
X11None
;
event
.
mode
=
-
1
;
event
.
detail
=
NotifyDetailNone
;
event
.
same_screen
=
True
;
event
.
focus
=
mContentFocused
;
}
break
;
case
eMouseMove
:
{
XMotionEvent
&
event
=
pluginEvent
.
xmotion
;
event
.
type
=
MotionNotify
;
event
.
root
=
root
;
event
.
time
=
anEvent
.
mTime
;
event
.
x
=
pluginPoint
.
x
;
event
.
y
=
pluginPoint
.
y
;
event
.
x_root
=
rootPoint
.
x
;
event
.
y_root
=
rootPoint
.
y
;
event
.
state
=
XInputEventState
(
mouseEvent
)
;
event
.
subwindow
=
X11None
;
event
.
is_hint
=
NotifyNormal
;
event
.
same_screen
=
True
;
}
break
;
case
eMouseDown
:
case
eMouseUp
:
{
XButtonEvent
&
event
=
pluginEvent
.
xbutton
;
event
.
type
=
anEvent
.
mMessage
=
=
eMouseDown
?
ButtonPress
:
ButtonRelease
;
event
.
root
=
root
;
event
.
time
=
anEvent
.
mTime
;
event
.
x
=
pluginPoint
.
x
;
event
.
y
=
pluginPoint
.
y
;
event
.
x_root
=
rootPoint
.
x
;
event
.
y_root
=
rootPoint
.
y
;
event
.
state
=
XInputEventState
(
mouseEvent
)
;
switch
(
mouseEvent
.
button
)
{
case
WidgetMouseEvent
:
:
eMiddleButton
:
event
.
button
=
2
;
break
;
case
WidgetMouseEvent
:
:
eRightButton
:
event
.
button
=
3
;
break
;
default
:
event
.
button
=
1
;
break
;
}
event
.
subwindow
=
X11None
;
event
.
same_screen
=
True
;
}
break
;
default
:
break
;
}
}
break
;
case
eKeyboardEventClass
:
if
(
anEvent
.
mPluginEvent
)
{
XKeyEvent
&
event
=
pluginEvent
.
xkey
;
#
ifdef
MOZ_WIDGET_GTK
event
.
root
=
GDK_ROOT_WINDOW
(
)
;
event
.
time
=
anEvent
.
mTime
;
const
GdkEventKey
*
gdkEvent
=
static_cast
<
const
GdkEventKey
*
>
(
anEvent
.
mPluginEvent
)
;
event
.
keycode
=
gdkEvent
-
>
hardware_keycode
;
event
.
state
=
gdkEvent
-
>
state
;
switch
(
anEvent
.
mMessage
)
{
case
eKeyDown
:
if
(
gdkEvent
-
>
is_modifier
)
event
.
type
=
XKeyPress
;
break
;
case
eKeyPress
:
event
.
type
=
XKeyPress
;
break
;
case
eKeyUp
:
event
.
type
=
KeyRelease
;
break
;
default
:
break
;
}
#
endif
event
.
subwindow
=
X11None
;
event
.
x
=
0
;
event
.
y
=
0
;
event
.
x_root
=
-
1
;
event
.
y_root
=
-
1
;
event
.
same_screen
=
False
;
}
else
{
NS_WARNING
(
"
Synthesized
key
event
not
sent
to
plugin
"
)
;
}
break
;
default
:
switch
(
anEvent
.
mMessage
)
{
case
eFocus
:
case
eBlur
:
{
XFocusChangeEvent
&
event
=
pluginEvent
.
xfocus
;
event
.
type
=
anEvent
.
mMessage
=
=
eFocus
?
FocusIn
:
FocusOut
;
event
.
mode
=
-
1
;
event
.
detail
=
NotifyDetailNone
;
}
break
;
default
:
break
;
}
}
if
(
!
pluginEvent
.
type
)
{
return
rv
;
}
XAnyEvent
&
event
=
pluginEvent
.
xany
;
event
.
display
=
widget
?
static_cast
<
Display
*
>
(
widget
-
>
GetNativeData
(
NS_NATIVE_DISPLAY
)
)
:
nullptr
;
event
.
window
=
X11None
;
event
.
serial
=
0
;
event
.
send_event
=
False
;
int16_t
response
=
kNPEventNotHandled
;
mInstance
-
>
HandleEvent
(
&
pluginEvent
&
response
NS_PLUGIN_CALL_SAFE_TO_REENTER_GECKO
)
;
if
(
response
=
=
kNPEventHandled
)
rv
=
nsEventStatus_eConsumeNoDefault
;
#
endif
return
rv
;
}
nsresult
nsPluginInstanceOwner
:
:
Destroy
(
)
{
SetFrame
(
nullptr
)
;
#
ifdef
XP_MACOSX
RemoveFromCARefreshTimer
(
)
;
#
endif
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
mCXMenuListener
)
{
mCXMenuListener
-
>
Destroy
(
content
)
;
mCXMenuListener
=
nullptr
;
}
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
focus
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mouseup
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
click
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
dblclick
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mouseover
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mouseout
"
)
this
false
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
true
)
;
content
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
keyup
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
drop
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
drag
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
dragenter
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
dragover
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
dragleave
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
dragexit
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
dragstart
"
)
this
true
)
;
content
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
dragend
"
)
this
true
)
;
content
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
compositionstart
"
)
this
true
)
;
content
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
compositionend
"
)
this
true
)
;
content
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
text
"
)
this
true
)
;
if
(
mWidget
)
{
if
(
mPluginWindow
)
{
mPluginWindow
-
>
SetPluginWidget
(
nullptr
)
;
}
nsCOMPtr
<
nsIPluginWidget
>
pluginWidget
=
do_QueryInterface
(
mWidget
)
;
if
(
pluginWidget
)
{
pluginWidget
-
>
SetPluginInstanceOwner
(
nullptr
)
;
}
mWidget
-
>
Destroy
(
)
;
}
return
NS_OK
;
}
#
ifdef
XP_MACOSX
void
nsPluginInstanceOwner
:
:
Paint
(
const
gfxRect
&
aDirtyRect
CGContextRef
cgContext
)
{
if
(
!
mInstance
|
|
!
mPluginFrame
)
return
;
gfxRect
dirtyRectCopy
=
aDirtyRect
;
double
scaleFactor
=
1
.
0
;
GetContentsScaleFactor
(
&
scaleFactor
)
;
if
(
scaleFactor
!
=
1
.
0
)
{
:
:
CGContextScaleCTM
(
cgContext
scaleFactor
scaleFactor
)
;
dirtyRectCopy
.
ScaleRoundOut
(
1
.
0
/
scaleFactor
)
;
}
DoCocoaEventDrawRect
(
dirtyRectCopy
cgContext
)
;
}
void
nsPluginInstanceOwner
:
:
DoCocoaEventDrawRect
(
const
gfxRect
&
aDrawRect
CGContextRef
cgContext
)
{
if
(
!
mInstance
|
|
!
mPluginFrame
)
return
;
NPCocoaEvent
updateEvent
;
InitializeNPCocoaEvent
(
&
updateEvent
)
;
updateEvent
.
type
=
NPCocoaEventDrawRect
;
updateEvent
.
data
.
draw
.
context
=
cgContext
;
updateEvent
.
data
.
draw
.
x
=
aDrawRect
.
X
(
)
;
updateEvent
.
data
.
draw
.
y
=
aDrawRect
.
Y
(
)
;
updateEvent
.
data
.
draw
.
width
=
aDrawRect
.
Width
(
)
;
updateEvent
.
data
.
draw
.
height
=
aDrawRect
.
Height
(
)
;
mInstance
-
>
HandleEvent
(
&
updateEvent
nullptr
)
;
}
#
endif
#
ifdef
XP_WIN
void
nsPluginInstanceOwner
:
:
Paint
(
const
RECT
&
aDirty
HDC
aDC
)
{
if
(
!
mInstance
|
|
!
mPluginFrame
)
return
;
NPEvent
pluginEvent
;
pluginEvent
.
event
=
WM_PAINT
;
pluginEvent
.
wParam
=
WPARAM
(
aDC
)
;
pluginEvent
.
lParam
=
LPARAM
(
&
aDirty
)
;
mInstance
-
>
HandleEvent
(
&
pluginEvent
nullptr
)
;
}
#
endif
#
if
defined
(
MOZ_X11
)
void
nsPluginInstanceOwner
:
:
Paint
(
gfxContext
*
aContext
const
gfxRect
&
aFrameRect
const
gfxRect
&
aDirtyRect
)
{
if
(
!
mInstance
|
|
!
mPluginFrame
)
return
;
gfxRect
pluginRect
=
aFrameRect
;
if
(
aContext
-
>
UserToDevicePixelSnapped
(
pluginRect
)
)
{
pluginRect
=
aContext
-
>
DeviceToUser
(
pluginRect
)
;
}
gfxRect
dirtyRect
=
aDirtyRect
-
pluginRect
.
TopLeft
(
)
;
dirtyRect
.
RoundOut
(
)
;
nsIntSize
pluginSize
(
NS_lround
(
pluginRect
.
width
)
NS_lround
(
pluginRect
.
height
)
)
;
nsIntRect
pluginDirtyRect
(
int32_t
(
dirtyRect
.
x
)
int32_t
(
dirtyRect
.
y
)
int32_t
(
dirtyRect
.
width
)
int32_t
(
dirtyRect
.
height
)
)
;
if
(
!
pluginDirtyRect
.
IntersectRect
(
nsIntRect
(
0
0
pluginSize
.
width
pluginSize
.
height
)
pluginDirtyRect
)
)
return
;
NPWindow
*
window
;
GetWindow
(
window
)
;
uint32_t
rendererFlags
=
0
;
if
(
!
mFlash10Quirks
)
{
rendererFlags
|
=
Renderer
:
:
DRAW_SUPPORTS_CLIP_RECT
|
Renderer
:
:
DRAW_SUPPORTS_ALTERNATE_VISUAL
;
}
bool
transparent
;
mInstance
-
>
IsTransparent
(
&
transparent
)
;
if
(
!
transparent
)
rendererFlags
|
=
Renderer
:
:
DRAW_IS_OPAQUE
;
gfxContextAutoSaveRestore
autoSR
(
aContext
)
;
aContext
-
>
SetMatrixDouble
(
aContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
pluginRect
.
TopLeft
(
)
)
)
;
Renderer
renderer
(
window
this
pluginSize
pluginDirtyRect
)
;
Display
*
dpy
=
mozilla
:
:
DefaultXDisplay
(
)
;
Screen
*
screen
=
DefaultScreenOfDisplay
(
dpy
)
;
Visual
*
visual
=
DefaultVisualOfScreen
(
screen
)
;
renderer
.
Draw
(
aContext
nsIntSize
(
window
-
>
width
window
-
>
height
)
rendererFlags
screen
visual
)
;
}
nsresult
nsPluginInstanceOwner
:
:
Renderer
:
:
DrawWithXlib
(
cairo_surface_t
*
xsurface
nsIntPoint
offset
nsIntRect
*
clipRects
uint32_t
numClipRects
)
{
Screen
*
screen
=
cairo_xlib_surface_get_screen
(
xsurface
)
;
Colormap
colormap
;
Visual
*
visual
;
if
(
!
gfxXlibSurface
:
:
GetColormapAndVisual
(
xsurface
&
colormap
&
visual
)
)
{
NS_ERROR
(
"
Failed
to
get
visual
and
colormap
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
nsNPAPIPluginInstance
*
instance
=
mInstanceOwner
-
>
mInstance
;
if
(
!
instance
)
return
NS_ERROR_FAILURE
;
bool
doupdatewindow
=
false
;
if
(
mWindow
-
>
x
!
=
offset
.
x
|
|
mWindow
-
>
y
!
=
offset
.
y
)
{
mWindow
-
>
x
=
offset
.
x
;
mWindow
-
>
y
=
offset
.
y
;
doupdatewindow
=
true
;
}
if
(
nsIntSize
(
mWindow
-
>
width
mWindow
-
>
height
)
!
=
mPluginSize
)
{
mWindow
-
>
width
=
mPluginSize
.
width
;
mWindow
-
>
height
=
mPluginSize
.
height
;
doupdatewindow
=
true
;
}
NS_ASSERTION
(
numClipRects
<
=
1
"
We
don
'
t
support
multiple
clip
rectangles
!
"
)
;
nsIntRect
clipRect
;
if
(
numClipRects
)
{
clipRect
.
x
=
clipRects
[
0
]
.
x
;
clipRect
.
y
=
clipRects
[
0
]
.
y
;
clipRect
.
width
=
clipRects
[
0
]
.
width
;
clipRect
.
height
=
clipRects
[
0
]
.
height
;
NS_ASSERTION
(
clipRect
.
x
>
=
0
&
&
clipRect
.
y
>
=
0
"
Clip
rectangle
offsets
are
negative
!
"
)
;
}
else
{
clipRect
.
x
=
offset
.
x
;
clipRect
.
y
=
offset
.
y
;
clipRect
.
width
=
mWindow
-
>
width
;
clipRect
.
height
=
mWindow
-
>
height
;
clipRect
.
IntersectRect
(
clipRect
nsIntRect
(
0
0
cairo_xlib_surface_get_width
(
xsurface
)
cairo_xlib_surface_get_height
(
xsurface
)
)
)
;
}
NPRect
newClipRect
;
newClipRect
.
left
=
clipRect
.
x
;
newClipRect
.
top
=
clipRect
.
y
;
newClipRect
.
right
=
clipRect
.
XMost
(
)
;
newClipRect
.
bottom
=
clipRect
.
YMost
(
)
;
if
(
mWindow
-
>
clipRect
.
left
!
=
newClipRect
.
left
|
|
mWindow
-
>
clipRect
.
top
!
=
newClipRect
.
top
|
|
mWindow
-
>
clipRect
.
right
!
=
newClipRect
.
right
|
|
mWindow
-
>
clipRect
.
bottom
!
=
newClipRect
.
bottom
)
{
mWindow
-
>
clipRect
=
newClipRect
;
doupdatewindow
=
true
;
}
NPSetWindowCallbackStruct
*
ws_info
=
static_cast
<
NPSetWindowCallbackStruct
*
>
(
mWindow
-
>
ws_info
)
;
#
ifdef
MOZ_X11
if
(
ws_info
-
>
visual
!
=
visual
|
|
ws_info
-
>
colormap
!
=
colormap
)
{
ws_info
-
>
visual
=
visual
;
ws_info
-
>
colormap
=
colormap
;
ws_info
-
>
depth
=
gfxXlibSurface
:
:
DepthOfVisual
(
screen
visual
)
;
doupdatewindow
=
true
;
}
#
endif
{
if
(
doupdatewindow
)
instance
-
>
SetWindow
(
mWindow
)
;
}
nsIntRect
dirtyRect
=
mDirtyRect
+
offset
;
if
(
mInstanceOwner
-
>
mFlash10Quirks
)
{
dirtyRect
.
SetRect
(
offset
.
x
offset
.
y
mDirtyRect
.
XMost
(
)
mDirtyRect
.
YMost
(
)
)
;
}
if
(
!
dirtyRect
.
IntersectRect
(
dirtyRect
clipRect
)
)
return
NS_OK
;
{
XEvent
pluginEvent
=
XEvent
(
)
;
XGraphicsExposeEvent
&
exposeEvent
=
pluginEvent
.
xgraphicsexpose
;
exposeEvent
.
type
=
GraphicsExpose
;
exposeEvent
.
display
=
DisplayOfScreen
(
screen
)
;
exposeEvent
.
drawable
=
cairo_xlib_surface_get_drawable
(
xsurface
)
;
exposeEvent
.
x
=
dirtyRect
.
x
;
exposeEvent
.
y
=
dirtyRect
.
y
;
exposeEvent
.
width
=
dirtyRect
.
width
;
exposeEvent
.
height
=
dirtyRect
.
height
;
exposeEvent
.
count
=
0
;
exposeEvent
.
serial
=
0
;
exposeEvent
.
send_event
=
False
;
exposeEvent
.
major_code
=
0
;
exposeEvent
.
minor_code
=
0
;
instance
-
>
HandleEvent
(
&
pluginEvent
nullptr
)
;
}
return
NS_OK
;
}
#
endif
nsresult
nsPluginInstanceOwner
:
:
Init
(
nsIContent
*
aContent
)
{
mLastEventloopNestingLevel
=
GetEventloopNestingLevel
(
)
;
mContent
=
do_GetWeakReference
(
aContent
)
;
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
nsIObjectFrame
*
iObjFrame
=
do_QueryFrame
(
frame
)
;
nsPluginFrame
*
objFrame
=
static_cast
<
nsPluginFrame
*
>
(
iObjFrame
)
;
if
(
objFrame
)
{
SetFrame
(
objFrame
)
;
objFrame
-
>
PresContext
(
)
-
>
EnsureVisible
(
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
not
be
initializing
plugin
without
a
frame
"
)
;
return
NS_ERROR_FAILURE
;
}
mCXMenuListener
=
new
nsPluginDOMContextMenuListener
(
aContent
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
focus
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mouseup
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
click
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
dblclick
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mouseover
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mouseout
"
)
this
false
false
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
true
)
;
aContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
keyup
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
drop
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
drag
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
dragenter
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
dragover
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
dragleave
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
dragexit
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
dragstart
"
)
this
true
)
;
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
dragend
"
)
this
true
)
;
aContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
compositionstart
"
)
this
true
)
;
aContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
compositionend
"
)
this
true
)
;
aContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
text
"
)
this
true
)
;
return
NS_OK
;
}
void
*
nsPluginInstanceOwner
:
:
GetPluginPort
(
)
{
void
*
result
=
nullptr
;
if
(
mWidget
)
{
#
ifdef
XP_WIN
if
(
!
mPluginWindow
|
|
mPluginWindow
-
>
type
=
=
NPWindowTypeWindow
)
#
endif
result
=
mWidget
-
>
GetNativeData
(
NS_NATIVE_PLUGIN_PORT
)
;
}
return
result
;
}
void
nsPluginInstanceOwner
:
:
ReleasePluginPort
(
void
*
pluginPort
)
{
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
CreateWidget
(
void
)
{
NS_ENSURE_TRUE
(
mPluginWindow
NS_ERROR_NULL_POINTER
)
;
if
(
mWidget
)
{
NS_WARNING
(
"
Trying
to
create
a
plugin
widget
twice
!
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
windowless
=
false
;
mInstance
-
>
IsWindowless
(
&
windowless
)
;
if
(
!
windowless
)
{
#
ifndef
XP_WIN
MOZ_ASSERT_UNREACHABLE
(
)
;
return
NS_ERROR_FAILURE
;
#
else
nsresult
rv
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
nsIDocument
*
doc
=
nullptr
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
content
)
{
doc
=
content
-
>
OwnerDoc
(
)
;
parentWidget
=
nsContentUtils
:
:
WidgetForDocument
(
doc
)
;
if
(
XRE_IsContentProcess
(
)
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
doc
-
>
GetWindow
(
)
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
window
-
>
GetTop
(
)
)
{
dom
:
:
TabChild
*
tc
=
dom
:
:
TabChild
:
:
GetFrom
(
topWindow
)
;
if
(
tc
)
{
rv
=
tc
-
>
CreatePluginWidget
(
parentWidget
.
get
(
)
getter_AddRefs
(
mWidget
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
}
}
}
if
(
!
mWidget
&
&
XRE_IsContentProcess
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
mWidget
)
{
mWidget
=
do_CreateInstance
(
kWidgetCID
&
rv
)
;
nsWidgetInitData
initData
;
initData
.
mWindowType
=
eWindowType_plugin
;
initData
.
mUnicode
=
false
;
initData
.
clipChildren
=
true
;
initData
.
clipSiblings
=
true
;
rv
=
mWidget
-
>
Create
(
parentWidget
.
get
(
)
nullptr
LayoutDeviceIntRect
(
0
0
0
0
)
&
initData
)
;
if
(
NS_FAILED
(
rv
)
)
{
mWidget
-
>
Destroy
(
)
;
mWidget
=
nullptr
;
return
rv
;
}
}
mWidget
-
>
EnableDragDrop
(
true
)
;
mWidget
-
>
Show
(
false
)
;
mWidget
-
>
Enable
(
false
)
;
#
endif
}
if
(
mPluginFrame
)
{
mPluginFrame
-
>
PrepForDrawing
(
mWidget
)
;
}
if
(
windowless
)
{
mPluginWindow
-
>
type
=
NPWindowTypeDrawable
;
mPluginWindow
-
>
window
=
nullptr
;
#
ifdef
MOZ_X11
NPSetWindowCallbackStruct
*
ws_info
=
static_cast
<
NPSetWindowCallbackStruct
*
>
(
mPluginWindow
-
>
ws_info
)
;
ws_info
-
>
display
=
DefaultXDisplay
(
)
;
nsAutoCString
description
;
GetPluginDescription
(
description
)
;
NS_NAMED_LITERAL_CSTRING
(
flash10Head
"
Shockwave
Flash
10
.
"
)
;
mFlash10Quirks
=
StringBeginsWith
(
description
flash10Head
)
;
#
endif
}
else
if
(
mWidget
)
{
mPluginWindow
-
>
type
=
NPWindowTypeWindow
;
mPluginWindow
-
>
window
=
GetPluginPort
(
)
;
mPluginWindow
-
>
SetPluginWidget
(
mWidget
)
;
nsCOMPtr
<
nsIPluginWidget
>
pluginWidget
=
do_QueryInterface
(
mWidget
)
;
if
(
pluginWidget
)
{
pluginWidget
-
>
SetPluginInstanceOwner
(
this
)
;
}
}
#
ifdef
XP_MACOSX
if
(
GetDrawingModel
(
)
=
=
NPDrawingModelCoreAnimation
)
{
AddToCARefreshTimer
(
)
;
}
#
endif
mWidgetCreationComplete
=
true
;
return
NS_OK
;
}
#
ifdef
XP_MACOSX
void
nsPluginInstanceOwner
:
:
FixUpPluginWindow
(
int32_t
inPaintState
)
{
if
(
!
mPluginWindow
|
|
!
mInstance
|
|
!
mPluginFrame
)
{
return
;
}
SetPluginPort
(
)
;
LayoutDeviceIntSize
widgetClip
=
mPluginFrame
-
>
GetWidgetlessClipRect
(
)
.
Size
(
)
;
mPluginWindow
-
>
x
=
0
;
mPluginWindow
-
>
y
=
0
;
NPRect
oldClipRect
=
mPluginWindow
-
>
clipRect
;
mPluginWindow
-
>
clipRect
.
top
=
0
;
mPluginWindow
-
>
clipRect
.
left
=
0
;
if
(
inPaintState
=
=
ePluginPaintDisable
)
{
mPluginWindow
-
>
clipRect
.
bottom
=
mPluginWindow
-
>
clipRect
.
top
;
mPluginWindow
-
>
clipRect
.
right
=
mPluginWindow
-
>
clipRect
.
left
;
}
else
if
(
inPaintState
=
=
ePluginPaintEnable
)
{
mPluginWindow
-
>
clipRect
.
bottom
=
mPluginWindow
-
>
clipRect
.
top
+
widgetClip
.
height
;
mPluginWindow
-
>
clipRect
.
right
=
mPluginWindow
-
>
clipRect
.
left
+
widgetClip
.
width
;
}
if
(
mPluginWindow
-
>
clipRect
.
left
!
=
oldClipRect
.
left
|
|
mPluginWindow
-
>
clipRect
.
top
!
=
oldClipRect
.
top
|
|
mPluginWindow
-
>
clipRect
.
right
!
=
oldClipRect
.
right
|
|
mPluginWindow
-
>
clipRect
.
bottom
!
=
oldClipRect
.
bottom
)
{
if
(
UseAsyncRendering
(
)
)
{
mInstance
-
>
AsyncSetWindow
(
mPluginWindow
)
;
}
else
{
mPluginWindow
-
>
CallSetWindow
(
mInstance
)
;
}
}
if
(
!
mSentInitialTopLevelWindowEvent
)
{
mSentInitialTopLevelWindowEvent
=
true
;
bool
isActive
=
WindowIsActive
(
)
;
SendWindowFocusChanged
(
isActive
)
;
mLastWindowIsActive
=
isActive
;
}
}
void
nsPluginInstanceOwner
:
:
WindowFocusMayHaveChanged
(
)
{
if
(
!
mSentInitialTopLevelWindowEvent
)
{
return
;
}
bool
isActive
=
WindowIsActive
(
)
;
if
(
isActive
!
=
mLastWindowIsActive
)
{
SendWindowFocusChanged
(
isActive
)
;
mLastWindowIsActive
=
isActive
;
}
}
bool
nsPluginInstanceOwner
:
:
WindowIsActive
(
)
{
if
(
!
mPluginFrame
)
{
return
false
;
}
EventStates
docState
=
mPluginFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
GetDocumentState
(
)
;
return
!
docState
.
HasState
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
)
;
}
void
nsPluginInstanceOwner
:
:
SendWindowFocusChanged
(
bool
aIsActive
)
{
if
(
!
mInstance
)
{
return
;
}
NPCocoaEvent
cocoaEvent
;
InitializeNPCocoaEvent
(
&
cocoaEvent
)
;
cocoaEvent
.
type
=
NPCocoaEventWindowFocusChanged
;
cocoaEvent
.
data
.
focus
.
hasFocus
=
aIsActive
;
mInstance
-
>
HandleEvent
(
&
cocoaEvent
nullptr
NS_PLUGIN_CALL_SAFE_TO_REENTER_GECKO
)
;
}
void
nsPluginInstanceOwner
:
:
HidePluginWindow
(
)
{
if
(
!
mPluginWindow
|
|
!
mInstance
)
{
return
;
}
mPluginWindow
-
>
clipRect
.
bottom
=
mPluginWindow
-
>
clipRect
.
top
;
mPluginWindow
-
>
clipRect
.
right
=
mPluginWindow
-
>
clipRect
.
left
;
mWidgetVisible
=
false
;
if
(
UseAsyncRendering
(
)
)
{
mInstance
-
>
AsyncSetWindow
(
mPluginWindow
)
;
}
else
{
mInstance
-
>
SetWindow
(
mPluginWindow
)
;
}
}
#
else
void
nsPluginInstanceOwner
:
:
UpdateWindowPositionAndClipRect
(
bool
aSetWindow
)
{
if
(
!
mPluginWindow
)
return
;
if
(
aSetWindow
&
&
!
mWidget
&
&
mPluginWindowVisible
&
&
!
UseAsyncRendering
(
)
)
return
;
const
NPWindow
oldWindow
=
*
mPluginWindow
;
bool
windowless
=
(
mPluginWindow
-
>
type
=
=
NPWindowTypeDrawable
)
;
nsIntPoint
origin
=
mPluginFrame
-
>
GetWindowOriginInPixels
(
windowless
)
;
mPluginWindow
-
>
x
=
origin
.
x
;
mPluginWindow
-
>
y
=
origin
.
y
;
mPluginWindow
-
>
clipRect
.
left
=
0
;
mPluginWindow
-
>
clipRect
.
top
=
0
;
if
(
mPluginWindowVisible
&
&
mPluginDocumentActiveState
)
{
mPluginWindow
-
>
clipRect
.
right
=
mPluginWindow
-
>
width
;
mPluginWindow
-
>
clipRect
.
bottom
=
mPluginWindow
-
>
height
;
}
else
{
mPluginWindow
-
>
clipRect
.
right
=
0
;
mPluginWindow
-
>
clipRect
.
bottom
=
0
;
}
if
(
!
aSetWindow
)
return
;
if
(
mPluginWindow
-
>
x
!
=
oldWindow
.
x
|
|
mPluginWindow
-
>
y
!
=
oldWindow
.
y
|
|
mPluginWindow
-
>
clipRect
.
left
!
=
oldWindow
.
clipRect
.
left
|
|
mPluginWindow
-
>
clipRect
.
top
!
=
oldWindow
.
clipRect
.
top
|
|
mPluginWindow
-
>
clipRect
.
right
!
=
oldWindow
.
clipRect
.
right
|
|
mPluginWindow
-
>
clipRect
.
bottom
!
=
oldWindow
.
clipRect
.
bottom
)
{
CallSetWindow
(
)
;
}
}
void
nsPluginInstanceOwner
:
:
UpdateWindowVisibility
(
bool
aVisible
)
{
mPluginWindowVisible
=
aVisible
;
UpdateWindowPositionAndClipRect
(
true
)
;
}
#
endif
void
nsPluginInstanceOwner
:
:
ResolutionMayHaveChanged
(
)
{
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
XP_WIN
)
double
scaleFactor
=
1
.
0
;
GetContentsScaleFactor
(
&
scaleFactor
)
;
if
(
scaleFactor
!
=
mLastScaleFactor
)
{
ContentsScaleFactorChanged
(
scaleFactor
)
;
mLastScaleFactor
=
scaleFactor
;
}
#
endif
float
zoomFactor
=
1
.
0
;
GetCSSZoomFactor
(
&
zoomFactor
)
;
if
(
zoomFactor
!
=
mLastCSSZoomFactor
)
{
if
(
mInstance
)
{
mInstance
-
>
CSSZoomFactorChanged
(
zoomFactor
)
;
}
mLastCSSZoomFactor
=
zoomFactor
;
}
}
void
nsPluginInstanceOwner
:
:
UpdateDocumentActiveState
(
bool
aIsActive
)
{
AUTO_PROFILER_LABEL
(
"
nsPluginInstanceOwner
:
:
UpdateDocumentActiveState
"
OTHER
)
;
mPluginDocumentActiveState
=
aIsActive
;
#
ifndef
XP_MACOSX
UpdateWindowPositionAndClipRect
(
true
)
;
if
(
mWidget
&
&
XRE_IsContentProcess
(
)
)
{
mWidget
-
>
Show
(
aIsActive
)
;
mWidget
-
>
Enable
(
aIsActive
)
;
}
#
endif
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
CallSetWindow
(
)
{
if
(
!
mWidgetCreationComplete
)
{
return
NS_OK
;
}
if
(
mPluginFrame
)
{
mPluginFrame
-
>
CallSetWindow
(
false
)
;
}
else
if
(
mInstance
)
{
if
(
UseAsyncRendering
(
)
)
{
mInstance
-
>
AsyncSetWindow
(
mPluginWindow
)
;
}
else
{
mInstance
-
>
SetWindow
(
mPluginWindow
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
GetContentsScaleFactor
(
double
*
result
)
{
NS_ENSURE_ARG_POINTER
(
result
)
;
double
scaleFactor
=
1
.
0
;
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
XP_WIN
)
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
nsIPresShell
*
presShell
=
nsContentUtils
:
:
FindPresShellForDocument
(
content
-
>
OwnerDoc
(
)
)
;
if
(
presShell
)
{
scaleFactor
=
double
(
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
/
presShell
-
>
GetPresContext
(
)
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
}
#
endif
*
result
=
scaleFactor
;
return
NS_OK
;
}
void
nsPluginInstanceOwner
:
:
GetCSSZoomFactor
(
float
*
result
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
nsIPresShell
*
presShell
=
nsContentUtils
:
:
FindPresShellForDocument
(
content
-
>
OwnerDoc
(
)
)
;
if
(
presShell
)
{
*
result
=
presShell
-
>
GetPresContext
(
)
-
>
DeviceContext
(
)
-
>
GetFullZoom
(
)
;
}
else
{
*
result
=
1
.
0
;
}
}
void
nsPluginInstanceOwner
:
:
SetFrame
(
nsPluginFrame
*
aFrame
)
{
if
(
mPluginFrame
=
=
aFrame
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
mPluginFrame
)
{
if
(
content
&
&
content
-
>
OwnerDoc
(
)
&
&
content
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
EventTarget
>
windowRoot
=
content
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
-
>
GetTopWindowRoot
(
)
;
if
(
windowRoot
)
{
windowRoot
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
activate
"
)
this
false
)
;
windowRoot
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
deactivate
"
)
this
false
)
;
windowRoot
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
MozPerformDelayedBlur
"
)
this
false
)
;
}
}
mPluginFrame
-
>
SetInstanceOwner
(
nullptr
)
;
}
mPluginFrame
=
aFrame
;
if
(
mPluginFrame
)
{
mPluginFrame
-
>
SetInstanceOwner
(
this
)
;
if
(
mWidgetCreationComplete
)
{
mPluginFrame
-
>
PrepForDrawing
(
mWidget
)
;
}
mPluginFrame
-
>
FixupWindow
(
mPluginFrame
-
>
GetContentRectRelativeToSelf
(
)
.
Size
(
)
)
;
mPluginFrame
-
>
InvalidateFrame
(
)
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
const
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
fm
&
&
content
)
{
mContentFocused
=
(
content
=
=
fm
-
>
GetFocusedElement
(
)
)
;
}
if
(
content
&
&
content
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
EventTarget
>
windowRoot
=
content
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
-
>
GetTopWindowRoot
(
)
;
if
(
windowRoot
)
{
windowRoot
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
activate
"
)
this
false
false
)
;
windowRoot
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
deactivate
"
)
this
false
false
)
;
windowRoot
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
MozPerformDelayedBlur
"
)
this
false
false
)
;
}
}
}
}
nsPluginFrame
*
nsPluginInstanceOwner
:
:
GetFrame
(
)
{
return
mPluginFrame
;
}
NS_IMETHODIMP
nsPluginInstanceOwner
:
:
PrivateModeChanged
(
bool
aEnabled
)
{
return
mInstance
?
mInstance
-
>
PrivateModeStateChanged
(
aEnabled
)
:
NS_OK
;
}
already_AddRefed
<
nsIURI
>
nsPluginInstanceOwner
:
:
GetBaseURI
(
)
const
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryReferent
(
mContent
)
;
if
(
!
content
)
{
return
nullptr
;
}
return
content
-
>
GetBaseURI
(
)
;
}
void
nsPluginInstanceOwner
:
:
GeneratePluginEvent
(
const
WidgetCompositionEvent
*
aSrcCompositionEvent
WidgetCompositionEvent
*
aDistCompositionEvent
)
{
#
ifdef
XP_WIN
NPEvent
newEvent
;
switch
(
aDistCompositionEvent
-
>
mMessage
)
{
case
eCompositionChange
:
{
newEvent
.
event
=
WM_IME_COMPOSITION
;
newEvent
.
wParam
=
0
;
if
(
aSrcCompositionEvent
&
&
(
aSrcCompositionEvent
-
>
mMessage
=
=
eCompositionCommit
|
|
aSrcCompositionEvent
-
>
mMessage
=
=
eCompositionCommitAsIs
)
)
{
newEvent
.
lParam
=
GCS_RESULTSTR
;
}
else
{
newEvent
.
lParam
=
GCS_COMPSTR
|
GCS_COMPATTR
|
GCS_COMPCLAUSE
;
}
TextRangeArray
*
ranges
=
aDistCompositionEvent
-
>
mRanges
;
if
(
ranges
&
&
ranges
-
>
HasCaret
(
)
)
{
newEvent
.
lParam
|
=
GCS_CURSORPOS
;
}
break
;
}
case
eCompositionStart
:
newEvent
.
event
=
WM_IME_STARTCOMPOSITION
;
newEvent
.
wParam
=
0
;
newEvent
.
lParam
=
0
;
break
;
case
eCompositionEnd
:
newEvent
.
event
=
WM_IME_ENDCOMPOSITION
;
newEvent
.
wParam
=
0
;
newEvent
.
lParam
=
0
;
break
;
default
:
return
;
}
aDistCompositionEvent
-
>
mPluginEvent
.
Copy
(
newEvent
)
;
#
endif
}
nsPluginDOMContextMenuListener
:
:
nsPluginDOMContextMenuListener
(
nsIContent
*
aContent
)
{
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
contextmenu
"
)
this
true
)
;
}
nsPluginDOMContextMenuListener
:
:
~
nsPluginDOMContextMenuListener
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsPluginDOMContextMenuListener
nsIDOMEventListener
)
NS_IMETHODIMP
nsPluginDOMContextMenuListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
aEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
void
nsPluginDOMContextMenuListener
:
:
Destroy
(
nsIContent
*
aContent
)
{
aContent
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
contextmenu
"
)
this
true
)
;
}
