#
include
"
nsPluginHost
.
h
"
#
include
<
inttypes
.
h
>
#
include
<
stdio
.
h
>
#
include
<
string
.
h
>
#
include
<
cstdlib
>
#
include
<
new
>
#
include
<
utility
>
#
include
"
ReferrerInfo
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
PluginLibrary
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FakePluginTagInitBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ReferrerPolicyBinding
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
ipc
/
URIParams
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
mozilla
/
mozalloc
.
h
"
#
include
"
mozilla
/
plugins
/
PluginTypes
.
h
"
#
include
"
npapi
.
h
"
#
include
"
npfunctions
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsIBlocklistService
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPluginInstanceOwner
.
h
"
#
include
"
nsIPluginTag
.
h
"
#
include
"
nsIPrefBranch
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIReferrerInfo
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIScriptChannel
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIUploadChannel
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNPAPIPlugin
.
h
"
#
include
"
nsNPAPIPluginInstance
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsPluginInstanceOwner
.
h
"
#
include
"
nsPluginLogging
.
h
"
#
include
"
nsPluginNativeWindow
.
h
"
#
include
"
nsPluginTags
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTLiteralString
.
h
"
#
include
"
nsTPromiseFlatString
.
h
"
#
include
"
nsTStringRepr
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsVersionComparator
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nscore
.
h
"
#
include
"
plstr
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
<
windows
.
h
>
#
include
<
winbase
.
h
>
#
endif
#
if
(
MOZ_WIDGET_GTK
)
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
dom
:
:
Document
;
using
mozilla
:
:
dom
:
:
FakePluginMimeEntry
;
using
mozilla
:
:
dom
:
:
FakePluginTagInit
;
using
mozilla
:
:
dom
:
:
Promise
;
#
define
NS_ITERATIVE_UNREF_LIST
(
type_
list_
mNext_
)
\
{
\
while
(
list_
)
{
\
type_
temp
=
list_
-
>
mNext_
;
\
list_
-
>
mNext_
=
nullptr
;
\
list_
=
temp
;
\
}
\
}
static
const
char
*
kPrefDisableFullPage
=
"
plugin
.
disable_full_page_plugin_for_types
"
;
LazyLogModule
nsPluginLogging
:
:
gNPNLog
(
NPN_LOG_NAME
)
;
LazyLogModule
nsPluginLogging
:
:
gNPPLog
(
NPP_LOG_NAME
)
;
LazyLogModule
nsPluginLogging
:
:
gPluginLog
(
PLUGIN_LOG_NAME
)
;
#
define
NS_PREF_MAX_NUM_CACHED_INSTANCES
\
"
browser
.
plugins
.
max_num_cached_plugins
"
#
define
DEFAULT_NUMBER_OF_STOPPED_INSTANCES
50
nsIFile
*
nsPluginHost
:
:
sPluginTempDir
;
StaticRefPtr
<
nsPluginHost
>
nsPluginHost
:
:
sInst
;
static
bool
IsTypeInList
(
const
nsCString
&
aMimeType
nsCString
aTypeList
)
{
nsAutoCString
searchStr
;
searchStr
.
Assign
(
'
'
)
;
searchStr
.
Append
(
aTypeList
)
;
searchStr
.
Append
(
'
'
)
;
nsACString
:
:
const_iterator
start
end
;
searchStr
.
BeginReading
(
start
)
;
searchStr
.
EndReading
(
end
)
;
nsAutoCString
commaSeparated
;
commaSeparated
.
Assign
(
'
'
)
;
commaSeparated
+
=
aMimeType
;
commaSeparated
.
Append
(
'
'
)
;
ToLowerCase
(
searchStr
)
;
ToLowerCase
(
commaSeparated
)
;
return
FindInReadable
(
commaSeparated
start
end
)
;
}
namespace
mozilla
:
:
plugins
{
class
BlocklistPromiseHandler
final
:
public
mozilla
:
:
dom
:
:
PromiseNativeHandler
{
public
:
NS_DECL_ISUPPORTS
BlocklistPromiseHandler
(
nsPluginTag
*
aTag
const
bool
aShouldSoftblock
)
:
mTag
(
aTag
)
mShouldDisableWhenSoftblocked
(
aShouldSoftblock
)
{
MOZ_ASSERT
(
mTag
"
Should
always
be
passed
a
plugin
tag
"
)
;
sPendingBlocklistStateRequests
+
+
;
}
void
MaybeWriteBlocklistChanges
(
)
{
if
(
!
mTag
)
{
return
;
}
mTag
=
nullptr
;
sPendingBlocklistStateRequests
-
-
;
if
(
!
sPendingBlocklistStateRequests
)
{
if
(
sPluginBlocklistStatesChangedSinceLastWrite
)
{
sPluginBlocklistStatesChangedSinceLastWrite
=
false
;
RefPtr
<
nsPluginHost
>
host
=
nsPluginHost
:
:
GetInst
(
)
;
host
-
>
IncrementChromeEpoch
(
)
;
host
-
>
BroadcastPluginsToContent
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
nullptr
"
plugin
-
blocklist
-
updates
-
finished
"
nullptr
)
;
}
}
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
if
(
!
aValue
.
isInt32
(
)
)
{
MOZ_ASSERT
(
false
"
Blocklist
should
always
return
int32
"
)
;
return
;
}
int32_t
newState
=
aValue
.
toInt32
(
)
;
MOZ_ASSERT
(
newState
>
=
0
&
&
newState
<
nsIBlocklistService
:
:
STATE_MAX
"
Shouldn
'
t
get
an
out
of
bounds
blocklist
state
"
)
;
uint32_t
oldState
=
mTag
-
>
GetBlocklistState
(
)
;
bool
changed
=
oldState
!
=
(
uint32_t
)
newState
;
mTag
-
>
SetBlocklistState
(
newState
)
;
if
(
newState
=
=
nsIBlocklistService
:
:
STATE_SOFTBLOCKED
&
&
mShouldDisableWhenSoftblocked
)
{
mTag
-
>
SetEnabledState
(
nsIPluginTag
:
:
STATE_DISABLED
)
;
changed
=
true
;
}
sPluginBlocklistStatesChangedSinceLastWrite
|
=
changed
;
MaybeWriteBlocklistChanges
(
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_ASSERT
(
false
"
Shouldn
'
t
reject
plugin
blocklist
state
request
"
)
;
MaybeWriteBlocklistChanges
(
)
;
}
private
:
~
BlocklistPromiseHandler
(
)
{
MaybeWriteBlocklistChanges
(
)
;
}
RefPtr
<
nsPluginTag
>
mTag
;
bool
mShouldDisableWhenSoftblocked
;
static
bool
sPluginBlocklistStatesChangedSinceLastWrite
;
static
uint32_t
sPendingBlocklistStateRequests
;
}
;
NS_IMPL_ISUPPORTS0
(
BlocklistPromiseHandler
)
bool
BlocklistPromiseHandler
:
:
sPluginBlocklistStatesChangedSinceLastWrite
=
false
;
uint32_t
BlocklistPromiseHandler
:
:
sPendingBlocklistStateRequests
=
0
;
}
nsPluginHost
:
:
nsPluginHost
(
)
:
mPluginsLoaded
(
false
)
mOverrideInternalTypes
(
false
)
mPluginsDisabled
(
false
)
mPluginEpoch
(
0
)
{
mOverrideInternalTypes
=
Preferences
:
:
GetBool
(
"
plugin
.
override_internal_types
"
false
)
;
bool
waylandBackend
=
false
;
#
if
defined
(
MOZ_WIDGET_GTK
)
waylandBackend
=
mozilla
:
:
widget
:
:
GdkIsWaylandDisplay
(
)
;
#
endif
mPluginsDisabled
=
Preferences
:
:
GetBool
(
"
plugin
.
disable
"
false
)
|
|
waylandBackend
;
if
(
!
waylandBackend
)
{
Preferences
:
:
AddStrongObserver
(
this
"
plugin
.
disable
"
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
}
#
ifdef
PLUGIN_LOGGING
MOZ_LOG
(
nsPluginLogging
:
:
gNPNLog
PLUGIN_LOG_ALWAYS
(
"
NPN
Logging
Active
!
\
n
"
)
)
;
MOZ_LOG
(
nsPluginLogging
:
:
gPluginLog
PLUGIN_LOG_ALWAYS
(
"
General
Plugin
Logging
Active
!
(
nsPluginHost
:
:
ctor
)
\
n
"
)
)
;
MOZ_LOG
(
nsPluginLogging
:
:
gNPPLog
PLUGIN_LOG_ALWAYS
(
"
NPP
Logging
Active
!
\
n
"
)
)
;
PLUGIN_LOG
(
PLUGIN_LOG_ALWAYS
(
"
nsPluginHost
:
:
ctor
\
n
"
)
)
;
PR_LogFlush
(
)
;
#
endif
nsPluginTag
:
:
EnsureSandboxInformation
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
IncrementChromeEpoch
(
)
;
LoadPlugins
(
)
;
}
}
nsPluginHost
:
:
~
nsPluginHost
(
)
{
PLUGIN_LOG
(
PLUGIN_LOG_ALWAYS
(
"
nsPluginHost
:
:
dtor
\
n
"
)
)
;
UnloadPlugins
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsPluginHost
nsIObserver
nsITimerCallback
nsISupportsWeakReference
nsINamed
)
already_AddRefed
<
nsPluginHost
>
nsPluginHost
:
:
GetInst
(
)
{
if
(
!
sInst
)
{
sInst
=
new
nsPluginHost
(
)
;
ClearOnShutdown
(
&
sInst
)
;
}
return
do_AddRef
(
sInst
)
;
}
bool
nsPluginHost
:
:
IsRunningPlugin
(
nsPluginTag
*
aPluginTag
)
{
return
false
;
}
nsresult
nsPluginHost
:
:
ReloadPlugins
(
)
{
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
ReloadPlugins
\
n
"
)
)
;
return
NS_ERROR_PLUGINS_PLUGINSNOTCHANGED
;
}
void
nsPluginHost
:
:
ClearNonRunningPlugins
(
)
{
RefPtr
<
nsPluginTag
>
prev
;
RefPtr
<
nsPluginTag
>
next
;
for
(
RefPtr
<
nsPluginTag
>
p
=
mPlugins
;
p
!
=
nullptr
;
)
{
next
=
p
-
>
mNext
;
if
(
!
IsRunningPlugin
(
p
)
)
{
if
(
p
=
=
mPlugins
)
mPlugins
=
next
;
else
prev
-
>
mNext
=
next
;
p
-
>
mNext
=
nullptr
;
p
-
>
TryUnloadPlugin
(
false
)
;
p
=
next
;
continue
;
}
prev
=
p
;
p
=
next
;
}
}
nsresult
nsPluginHost
:
:
ActuallyReloadPlugins
(
)
{
nsresult
rv
=
NS_OK
;
ClearNonRunningPlugins
(
)
;
mPluginsLoaded
=
false
;
rv
=
LoadPlugins
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
BroadcastPluginsToContent
(
)
;
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
ReloadPlugins
End
\
n
"
)
)
;
return
rv
;
}
#
define
NS_RETURN_UASTRING_SIZE
128
nsresult
nsPluginHost
:
:
UserAgent
(
const
char
*
*
retstring
)
{
static
char
resultString
[
NS_RETURN_UASTRING_SIZE
]
;
nsresult
res
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
nsAutoCString
uaString
;
res
=
http
-
>
GetUserAgent
(
uaString
)
;
if
(
NS_SUCCEEDED
(
res
)
)
{
if
(
NS_RETURN_UASTRING_SIZE
>
uaString
.
Length
(
)
)
{
PL_strcpy
(
resultString
uaString
.
get
(
)
)
;
}
else
{
PL_strncpy
(
resultString
uaString
.
get
(
)
NS_RETURN_UASTRING_SIZE
)
;
for
(
int
i
=
NS_RETURN_UASTRING_SIZE
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
i
=
=
0
)
{
resultString
[
NS_RETURN_UASTRING_SIZE
-
1
]
=
'
\
0
'
;
}
else
if
(
resultString
[
i
]
=
=
'
'
)
{
resultString
[
i
]
=
'
\
0
'
;
break
;
}
}
}
*
retstring
=
resultString
;
}
else
{
*
retstring
=
nullptr
;
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
UserAgent
return
=
%
s
\
n
"
*
retstring
)
)
;
return
res
;
}
nsresult
nsPluginHost
:
:
UnloadPlugins
(
)
{
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
UnloadPlugins
Called
\
n
"
)
)
;
if
(
!
mPluginsLoaded
)
return
NS_OK
;
DestroyRunningInstances
(
nullptr
)
;
nsPluginTag
*
pluginTag
;
for
(
pluginTag
=
mPlugins
;
pluginTag
;
pluginTag
=
pluginTag
-
>
mNext
)
{
pluginTag
-
>
TryUnloadPlugin
(
true
)
;
}
NS_ITERATIVE_UNREF_LIST
(
RefPtr
<
nsPluginTag
>
mPlugins
mNext
)
;
if
(
sPluginTempDir
)
{
sPluginTempDir
-
>
Remove
(
true
)
;
NS_RELEASE
(
sPluginTempDir
)
;
}
mPluginsLoaded
=
false
;
return
NS_OK
;
}
void
nsPluginHost
:
:
OnPluginInstanceDestroyed
(
nsPluginTag
*
aPluginTag
)
{
}
nsPluginTag
*
nsPluginHost
:
:
FindTagForLibrary
(
PRLibrary
*
aLibrary
)
{
nsPluginTag
*
pluginTag
;
for
(
pluginTag
=
mPlugins
;
pluginTag
;
pluginTag
=
pluginTag
-
>
mNext
)
{
if
(
pluginTag
-
>
mLibrary
=
=
aLibrary
)
{
return
pluginTag
;
}
}
return
nullptr
;
}
bool
nsPluginHost
:
:
HavePluginForType
(
const
nsACString
&
aMimeType
PluginFilter
aFilter
)
{
bool
checkEnabled
=
aFilter
&
eExcludeDisabled
;
bool
allowFake
=
!
(
aFilter
&
eExcludeFake
)
;
return
FindPluginForType
(
aMimeType
allowFake
checkEnabled
)
;
}
nsIInternalPluginTag
*
nsPluginHost
:
:
FindPluginForType
(
const
nsACString
&
aMimeType
bool
aIncludeFake
bool
aCheckEnabled
)
{
if
(
aIncludeFake
)
{
nsFakePluginTag
*
fakeTag
=
FindFakePluginForType
(
aMimeType
aCheckEnabled
)
;
if
(
fakeTag
)
{
return
fakeTag
;
}
}
return
FindNativePluginForType
(
aMimeType
aCheckEnabled
)
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetPluginTagForType
(
const
nsACString
&
aMimeType
uint32_t
aExcludeFlags
nsIPluginTag
*
*
aResult
)
{
bool
includeFake
=
!
(
aExcludeFlags
&
eExcludeFake
)
;
bool
includeDisabled
=
!
(
aExcludeFlags
&
eExcludeDisabled
)
;
RefPtr
<
nsIInternalPluginTag
>
tag
=
FindPluginForType
(
aMimeType
includeFake
true
)
;
if
(
!
tag
&
&
includeDisabled
)
{
tag
=
FindPluginForType
(
aMimeType
includeFake
false
)
;
}
if
(
tag
)
{
tag
.
forget
(
aResult
)
;
return
NS_OK
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetPermissionStringForTag
(
nsIPluginTag
*
aTag
uint32_t
aExcludeFlags
nsACString
&
aPermissionString
)
{
NS_ENSURE_TRUE
(
aTag
NS_ERROR_FAILURE
)
;
aPermissionString
.
Truncate
(
)
;
uint32_t
blocklistState
;
nsresult
rv
=
aTag
-
>
GetBlocklistState
(
&
blocklistState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aPermissionString
.
AssignLiteral
(
"
plugin
:
"
)
;
nsCString
niceName
;
rv
=
aTag
-
>
GetNiceName
(
niceName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
!
niceName
.
IsEmpty
(
)
NS_ERROR_FAILURE
)
;
aPermissionString
.
Append
(
niceName
)
;
return
NS_OK
;
}
bool
nsPluginHost
:
:
HavePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
PluginFilter
aFilter
)
{
if
(
!
aExtension
.
LowerCaseEqualsLiteral
(
"
swf
"
)
&
&
!
aExtension
.
LowerCaseEqualsLiteral
(
"
tst
"
)
)
{
return
false
;
}
bool
checkEnabled
=
aFilter
&
eExcludeDisabled
;
bool
allowFake
=
!
(
aFilter
&
eExcludeFake
)
;
return
FindNativePluginForExtension
(
aExtension
aMimeType
checkEnabled
)
|
|
(
allowFake
&
&
FindFakePluginForExtension
(
aExtension
aMimeType
checkEnabled
)
)
;
}
void
nsPluginHost
:
:
GetPlugins
(
nsTArray
<
nsCOMPtr
<
nsIInternalPluginTag
>
>
&
aPluginArray
bool
aIncludeDisabled
)
{
aPluginArray
.
Clear
(
)
;
LoadPlugins
(
)
;
uint32_t
numFake
=
mFakePlugins
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numFake
;
i
+
+
)
{
aPluginArray
.
AppendElement
(
mFakePlugins
[
i
]
)
;
}
nsPluginTag
*
plugin
=
mPlugins
;
while
(
plugin
!
=
nullptr
)
{
if
(
plugin
-
>
IsEnabled
(
)
|
|
aIncludeDisabled
)
{
aPluginArray
.
AppendElement
(
plugin
)
;
}
plugin
=
plugin
-
>
mNext
;
}
}
nsPluginTag
*
nsPluginHost
:
:
FindPreferredPlugin
(
const
nsTArray
<
nsPluginTag
*
>
&
matches
)
{
if
(
matches
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsPluginTag
*
preferredPlugin
=
matches
[
0
]
;
for
(
unsigned
int
i
=
1
;
i
<
matches
.
Length
(
)
;
i
+
+
)
{
if
(
mozilla
:
:
Version
(
matches
[
i
]
-
>
Version
(
)
.
get
(
)
)
>
preferredPlugin
-
>
Version
(
)
.
get
(
)
)
{
preferredPlugin
=
matches
[
i
]
;
}
}
return
preferredPlugin
;
}
nsFakePluginTag
*
nsPluginHost
:
:
FindFakePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
if
(
aExtension
.
IsEmpty
(
)
)
{
return
nullptr
;
}
int32_t
numFakePlugins
=
mFakePlugins
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
numFakePlugins
;
i
+
+
)
{
nsFakePluginTag
*
plugin
=
mFakePlugins
[
i
]
;
bool
active
;
if
(
(
!
aCheckEnabled
|
|
(
NS_SUCCEEDED
(
plugin
-
>
GetActive
(
&
active
)
)
&
&
active
)
)
&
&
plugin
-
>
HasExtension
(
aExtension
aMimeType
)
)
{
return
plugin
;
}
}
return
nullptr
;
}
nsFakePluginTag
*
nsPluginHost
:
:
FindFakePluginForType
(
const
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
int32_t
numFakePlugins
=
mFakePlugins
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
numFakePlugins
;
i
+
+
)
{
nsFakePluginTag
*
plugin
=
mFakePlugins
[
i
]
;
bool
active
;
if
(
(
!
aCheckEnabled
|
|
(
NS_SUCCEEDED
(
plugin
-
>
GetActive
(
&
active
)
)
&
&
active
)
)
&
&
plugin
-
>
HasMimeType
(
aMimeType
)
)
{
return
plugin
;
}
}
return
nullptr
;
}
nsPluginTag
*
nsPluginHost
:
:
FindNativePluginForType
(
const
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
if
(
aMimeType
.
IsEmpty
(
)
)
{
return
nullptr
;
}
if
(
!
nsPluginHost
:
:
CanUsePluginForMIMEType
(
aMimeType
)
)
{
return
nullptr
;
}
LoadPlugins
(
)
;
nsTArray
<
nsPluginTag
*
>
matchingPlugins
;
nsPluginTag
*
plugin
=
mPlugins
;
while
(
plugin
)
{
if
(
(
!
aCheckEnabled
|
|
plugin
-
>
IsActive
(
)
)
&
&
plugin
-
>
HasMimeType
(
aMimeType
)
)
{
matchingPlugins
.
AppendElement
(
plugin
)
;
}
plugin
=
plugin
-
>
mNext
;
}
return
FindPreferredPlugin
(
matchingPlugins
)
;
}
nsPluginTag
*
nsPluginHost
:
:
FindNativePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
if
(
aExtension
.
IsEmpty
(
)
)
{
return
nullptr
;
}
LoadPlugins
(
)
;
nsTArray
<
nsPluginTag
*
>
matchingPlugins
;
nsCString
matchingMime
;
nsPluginTag
*
plugin
=
mPlugins
;
while
(
plugin
)
{
if
(
!
aCheckEnabled
|
|
plugin
-
>
IsActive
(
)
)
{
if
(
plugin
-
>
HasExtension
(
aExtension
matchingMime
)
)
{
matchingPlugins
.
AppendElement
(
plugin
)
;
}
}
plugin
=
plugin
-
>
mNext
;
}
nsPluginTag
*
preferredPlugin
=
FindPreferredPlugin
(
matchingPlugins
)
;
if
(
!
preferredPlugin
)
{
return
nullptr
;
}
preferredPlugin
-
>
HasExtension
(
aExtension
aMimeType
)
;
return
preferredPlugin
;
}
nsresult
nsPluginHost
:
:
EnsurePluginLoaded
(
nsPluginTag
*
aPluginTag
)
{
return
NS_ERROR_FAILURE
;
}
class
nsPluginUnloadRunnable
:
public
Runnable
{
public
:
explicit
nsPluginUnloadRunnable
(
uint32_t
aPluginId
)
:
Runnable
(
"
nsPluginUnloadRunnable
"
)
mPluginId
(
aPluginId
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
nsPluginHost
>
host
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
!
host
)
{
return
NS_OK
;
}
nsPluginTag
*
pluginTag
=
host
-
>
PluginWithId
(
mPluginId
)
;
if
(
!
pluginTag
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
pluginTag
-
>
mContentProcessRunningCount
>
0
)
;
pluginTag
-
>
mContentProcessRunningCount
-
-
;
if
(
!
pluginTag
-
>
mContentProcessRunningCount
)
{
if
(
!
host
-
>
IsRunningPlugin
(
pluginTag
)
)
{
pluginTag
-
>
TryUnloadPlugin
(
false
)
;
}
}
return
NS_OK
;
}
protected
:
uint32_t
mPluginId
;
}
;
void
nsPluginHost
:
:
NotifyContentModuleDestroyed
(
uint32_t
aPluginId
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
nsPluginUnloadRunnable
>
runnable
=
new
nsPluginUnloadRunnable
(
aPluginId
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
nsresult
nsPluginHost
:
:
NormalizeHostname
(
nsCString
&
host
)
{
if
(
IsAscii
(
host
)
)
{
ToLowerCase
(
host
)
;
return
NS_OK
;
}
if
(
!
mIDNService
)
{
nsresult
rv
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
mIDNService
-
>
ConvertUTF8toACE
(
host
host
)
;
}
nsresult
nsPluginHost
:
:
EnumerateSiteData
(
const
nsACString
&
domain
const
nsTArray
<
nsCString
>
&
sites
nsTArray
<
nsCString
>
&
result
bool
firstMatchOnly
)
{
NS_ASSERTION
(
!
domain
.
IsVoid
(
)
"
null
domain
string
"
)
;
nsresult
rv
;
if
(
!
mTLDService
)
{
mTLDService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCString
baseDomain
;
rv
=
mTLDService
-
>
GetBaseDomainFromHost
(
domain
0
baseDomain
)
;
bool
isIP
=
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
;
if
(
isIP
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
baseDomain
=
domain
;
rv
=
NormalizeHostname
(
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
uint32_t
i
=
0
;
i
<
sites
.
Length
(
)
;
+
+
i
)
{
const
nsCString
&
site
=
sites
[
i
]
;
bool
siteIsIP
=
site
.
Length
(
)
>
=
2
&
&
site
.
First
(
)
=
=
'
[
'
&
&
site
.
Last
(
)
=
=
'
]
'
;
if
(
siteIsIP
!
=
isIP
)
continue
;
nsCString
siteBaseDomain
;
if
(
siteIsIP
)
{
siteBaseDomain
=
Substring
(
site
1
site
.
Length
(
)
-
2
)
;
}
else
{
rv
=
mTLDService
-
>
GetBaseDomainFromHost
(
site
0
siteBaseDomain
)
;
if
(
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
siteBaseDomain
=
site
;
rv
=
NormalizeHostname
(
siteBaseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
baseDomain
!
=
siteBaseDomain
)
{
continue
;
}
result
.
AppendElement
(
site
)
;
if
(
firstMatchOnly
)
{
break
;
}
}
return
NS_OK
;
}
static
bool
MimeTypeIsAllowedForFakePlugin
(
const
nsString
&
aMimeType
)
{
static
const
char
*
const
allowedFakePlugins
[
]
=
{
"
application
/
x
-
shockwave
-
flash
"
"
application
/
pdf
"
"
application
/
vnd
.
adobe
.
pdf
"
"
application
/
vnd
.
adobe
.
pdfxml
"
"
application
/
vnd
.
adobe
.
x
-
mars
"
"
application
/
vnd
.
adobe
.
xdp
+
xml
"
"
application
/
vnd
.
adobe
.
xfdf
"
"
application
/
vnd
.
adobe
.
xfd
+
xml
"
"
application
/
vnd
.
fdf
"
}
;
for
(
const
auto
allowed
:
allowedFakePlugins
)
{
if
(
aMimeType
.
EqualsASCII
(
allowed
)
)
{
return
true
;
}
}
return
false
;
}
nsPluginHost
:
:
SpecialType
nsPluginHost
:
:
GetSpecialType
(
const
nsACString
&
aMIMEType
)
{
if
(
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
x
-
test
"
)
)
{
return
eSpecialType_Test
;
}
if
(
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
x
-
shockwave
-
flash
"
)
|
|
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
futuresplash
"
)
|
|
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
x
-
shockwave
-
flash
-
test
"
)
)
{
return
eSpecialType_Flash
;
}
return
eSpecialType_None
;
}
bool
nsPluginHost
:
:
IsLiveTag
(
nsIPluginTag
*
aPluginTag
)
{
nsCOMPtr
<
nsIInternalPluginTag
>
internalTag
(
do_QueryInterface
(
aPluginTag
)
)
;
uint32_t
fakeCount
=
mFakePlugins
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
fakeCount
;
i
+
+
)
{
if
(
mFakePlugins
[
i
]
=
=
internalTag
)
{
return
true
;
}
}
nsPluginTag
*
tag
;
for
(
tag
=
mPlugins
;
tag
;
tag
=
tag
-
>
mNext
)
{
if
(
tag
=
=
internalTag
)
{
return
true
;
}
}
return
false
;
}
nsPluginTag
*
nsPluginHost
:
:
HaveSamePlugin
(
const
nsPluginTag
*
aPluginTag
)
{
for
(
nsPluginTag
*
tag
=
mPlugins
;
tag
;
tag
=
tag
-
>
mNext
)
{
if
(
tag
-
>
HasSameNameAndMimes
(
aPluginTag
)
)
{
return
tag
;
}
}
return
nullptr
;
}
nsPluginTag
*
nsPluginHost
:
:
PluginWithId
(
uint32_t
aId
)
{
for
(
nsPluginTag
*
tag
=
mPlugins
;
tag
;
tag
=
tag
-
>
mNext
)
{
if
(
tag
-
>
mId
=
=
aId
)
{
return
tag
;
}
}
return
nullptr
;
}
void
nsPluginHost
:
:
AddPluginTag
(
nsPluginTag
*
aPluginTag
)
{
aPluginTag
-
>
mNext
=
mPlugins
;
mPlugins
=
aPluginTag
;
if
(
aPluginTag
-
>
IsActive
(
)
)
{
nsAutoCString
disableFullPage
;
Preferences
:
:
GetCString
(
kPrefDisableFullPage
disableFullPage
)
;
for
(
uint32_t
i
=
0
;
i
<
aPluginTag
-
>
MimeTypes
(
)
.
Length
(
)
;
i
+
+
)
{
if
(
!
IsTypeInList
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
disableFullPage
)
)
{
RegisterWithCategoryManager
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
ePluginRegister
)
;
}
}
}
}
void
nsPluginHost
:
:
IncrementChromeEpoch
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mPluginEpoch
+
+
;
}
uint32_t
nsPluginHost
:
:
ChromeEpoch
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
mPluginEpoch
;
}
uint32_t
nsPluginHost
:
:
ChromeEpochForContent
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
return
mPluginEpoch
;
}
void
nsPluginHost
:
:
SetChromeEpochForContent
(
uint32_t
aEpoch
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
mPluginEpoch
=
aEpoch
;
}
already_AddRefed
<
nsIAsyncShutdownClient
>
GetProfileChangeTeardownPhase
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
asyncShutdownSvc
=
services
:
:
GetAsyncShutdownService
(
)
;
MOZ_ASSERT
(
asyncShutdownSvc
)
;
if
(
NS_WARN_IF
(
!
asyncShutdownSvc
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
shutdownPhase
;
DebugOnly
<
nsresult
>
rv
=
asyncShutdownSvc
-
>
GetProfileChangeTeardown
(
getter_AddRefs
(
shutdownPhase
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
shutdownPhase
.
forget
(
)
;
}
nsresult
nsPluginHost
:
:
LoadPlugins
(
)
{
return
NS_OK
;
}
void
nsPluginHost
:
:
FindingFinished
(
)
{
}
nsresult
nsPluginHost
:
:
UpdateCachedSerializablePluginList
(
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
nsPluginHost
:
:
BroadcastPluginsToContent
(
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
nsPluginHost
:
:
SendPluginsToContent
(
dom
:
:
ContentParent
*
parent
)
{
return
NS_ERROR_FAILURE
;
}
void
nsPluginHost
:
:
UpdateInMemoryPluginInfo
(
nsPluginTag
*
aPluginTag
)
{
if
(
!
aPluginTag
)
{
return
;
}
nsAutoCString
disableFullPage
;
Preferences
:
:
GetCString
(
kPrefDisableFullPage
disableFullPage
)
;
for
(
uint32_t
i
=
0
;
i
<
aPluginTag
-
>
MimeTypes
(
)
.
Length
(
)
;
i
+
+
)
{
nsRegisterType
shouldRegister
;
if
(
IsTypeInList
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
disableFullPage
)
)
{
shouldRegister
=
ePluginUnregister
;
}
else
{
nsPluginTag
*
plugin
=
FindNativePluginForType
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
true
)
;
shouldRegister
=
plugin
?
ePluginRegister
:
ePluginUnregister
;
}
RegisterWithCategoryManager
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
shouldRegister
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
obsService
-
>
NotifyObservers
(
nullptr
"
plugin
-
info
-
updated
"
nullptr
)
;
}
void
nsPluginHost
:
:
UpdatePluginInfo
(
nsPluginTag
*
aPluginTag
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
IncrementChromeEpoch
(
)
;
UpdateInMemoryPluginInfo
(
aPluginTag
)
;
}
void
nsPluginHost
:
:
RegisterWithCategoryManager
(
const
nsCString
&
aMimeType
nsRegisterType
aType
)
{
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginTag
:
:
RegisterWithCategoryManager
type
=
%
s
removing
=
%
s
\
n
"
aMimeType
.
get
(
)
aType
=
=
ePluginUnregister
?
"
yes
"
:
"
no
"
)
)
;
nsCOMPtr
<
nsICategoryManager
>
catMan
=
do_GetService
(
NS_CATEGORYMANAGER_CONTRACTID
)
;
if
(
!
catMan
)
{
return
;
}
constexpr
auto
contractId
=
"
mozilla
.
org
/
content
/
plugin
/
document
-
loader
-
factory
;
1
"
_ns
;
if
(
aType
=
=
ePluginRegister
)
{
catMan
-
>
AddCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
aMimeType
contractId
false
mOverrideInternalTypes
)
;
}
else
{
if
(
aType
=
=
ePluginMaybeUnregister
)
{
if
(
HavePluginForType
(
aMimeType
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
aType
=
=
ePluginUnregister
"
Unknown
nsRegisterType
"
)
;
}
nsCString
value
;
nsresult
rv
=
catMan
-
>
GetCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
aMimeType
value
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
value
=
=
contractId
)
{
catMan
-
>
DeleteCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
aMimeType
true
)
;
}
}
}
nsresult
nsPluginHost
:
:
AddHeadersToChannel
(
const
char
*
aHeadersData
uint32_t
aHeadersDataLen
nsIChannel
*
aGenericChannel
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIHttpChannel
>
aChannel
=
do_QueryInterface
(
aGenericChannel
)
;
if
(
!
aChannel
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsAutoCString
headersString
;
nsAutoCString
oneHeader
;
nsAutoCString
headerName
;
nsAutoCString
headerValue
;
int32_t
crlf
=
0
;
int32_t
colon
=
0
;
headersString
=
aHeadersData
;
while
(
true
)
{
crlf
=
headersString
.
Find
(
"
\
r
\
n
"
true
)
;
if
(
-
1
=
=
crlf
)
{
rv
=
NS_OK
;
return
rv
;
}
headersString
.
Mid
(
oneHeader
0
crlf
)
;
headersString
.
Cut
(
0
crlf
+
2
)
;
oneHeader
.
StripWhitespace
(
)
;
colon
=
oneHeader
.
Find
(
"
:
"
)
;
if
(
-
1
=
=
colon
)
{
rv
=
NS_ERROR_NULL_POINTER
;
return
rv
;
}
oneHeader
.
Left
(
headerName
colon
)
;
colon
+
+
;
oneHeader
.
Mid
(
headerValue
colon
oneHeader
.
Length
(
)
-
colon
)
;
rv
=
aChannel
-
>
SetRequestHeader
(
headerName
headerValue
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_ERROR_NULL_POINTER
;
return
rv
;
}
}
}
nsresult
nsPluginHost
:
:
StopPluginInstance
(
nsNPAPIPluginInstance
*
aInstance
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
nsPluginHost
:
:
NewPluginStreamListener
(
nsIURI
*
aURI
nsNPAPIPluginInstance
*
aInstance
nsIStreamListener
*
*
aStreamListener
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsPluginHost
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
!
strcmp
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
aTopic
)
)
{
UnloadPlugins
(
)
;
}
if
(
!
strcmp
(
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
aTopic
)
)
{
mPluginsDisabled
=
Preferences
:
:
GetBool
(
"
plugin
.
disable
"
false
)
;
if
(
mPluginsDisabled
)
{
UnloadPlugins
(
)
;
}
else
{
LoadPlugins
(
)
;
}
}
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
ParsePostBufferToFixHeaders
(
const
char
*
inPostData
uint32_t
inPostDataLen
char
*
*
outPostData
uint32_t
*
outPostDataLen
)
{
if
(
!
inPostData
|
|
!
outPostData
|
|
!
outPostDataLen
)
return
NS_ERROR_NULL_POINTER
;
*
outPostData
=
0
;
*
outPostDataLen
=
0
;
const
char
CR
=
'
\
r
'
;
const
char
LF
=
'
\
n
'
;
const
char
CRLFCRLF
[
]
=
{
CR
LF
CR
LF
'
\
0
'
}
;
const
char
ContentLenHeader
[
]
=
"
Content
-
length
"
;
AutoTArray
<
const
char
*
8
>
singleLF
;
const
char
*
pSCntlh
=
0
;
const
char
*
pSod
=
0
;
const
char
*
pEoh
=
0
;
const
char
*
pEod
=
inPostData
+
inPostDataLen
;
if
(
*
inPostData
=
=
LF
)
{
pSod
=
inPostData
+
1
;
}
else
{
const
char
*
s
=
inPostData
;
while
(
s
<
pEod
)
{
if
(
!
pSCntlh
&
&
(
*
s
=
=
'
C
'
|
|
*
s
=
=
'
c
'
)
&
&
(
s
+
sizeof
(
ContentLenHeader
)
-
1
<
pEod
)
&
&
(
!
PL_strncasecmp
(
s
ContentLenHeader
sizeof
(
ContentLenHeader
)
-
1
)
)
)
{
const
char
*
p
=
pSCntlh
=
s
;
p
+
=
sizeof
(
ContentLenHeader
)
-
1
;
for
(
;
p
<
pEod
;
p
+
+
)
{
if
(
*
p
=
=
CR
|
|
*
p
=
=
LF
)
{
if
(
*
(
p
-
1
)
>
=
'
0
'
&
&
*
(
p
-
1
)
<
=
'
9
'
)
{
s
=
p
;
}
break
;
}
}
if
(
pSCntlh
=
=
s
)
{
pSCntlh
=
0
;
break
;
}
}
if
(
*
s
=
=
CR
)
{
if
(
pSCntlh
&
&
(
(
s
+
sizeof
(
CRLFCRLF
)
-
1
)
<
=
pEod
)
&
&
!
memcmp
(
s
CRLFCRLF
sizeof
(
CRLFCRLF
)
-
1
)
)
{
s
+
=
sizeof
(
CRLFCRLF
)
-
1
;
pEoh
=
pSod
=
s
;
break
;
}
}
else
if
(
*
s
=
=
LF
)
{
if
(
*
(
s
-
1
)
!
=
CR
)
{
singleLF
.
AppendElement
(
s
)
;
}
if
(
pSCntlh
&
&
(
s
+
1
<
pEod
)
&
&
(
*
(
s
+
1
)
=
=
LF
)
)
{
s
+
+
;
singleLF
.
AppendElement
(
s
)
;
s
+
+
;
pEoh
=
pSod
=
s
;
break
;
}
}
s
+
+
;
}
}
if
(
!
pSod
)
{
pSod
=
inPostData
;
}
uint32_t
newBufferLen
=
0
;
uint32_t
dataLen
=
pEod
-
pSod
;
uint32_t
headersLen
=
pEoh
?
pSod
-
inPostData
:
0
;
char
*
p
;
if
(
headersLen
)
{
newBufferLen
=
dataLen
+
headersLen
;
int
cntSingleLF
=
singleLF
.
Length
(
)
;
newBufferLen
+
=
cntSingleLF
;
*
outPostData
=
p
=
(
char
*
)
moz_xmalloc
(
newBufferLen
)
;
const
char
*
s
=
inPostData
;
if
(
cntSingleLF
)
{
for
(
int
i
=
0
;
i
<
cntSingleLF
;
i
+
+
)
{
const
char
*
plf
=
singleLF
.
ElementAt
(
i
)
;
int
n
=
plf
-
s
;
if
(
n
)
{
memcpy
(
p
s
n
)
;
p
+
=
n
;
}
*
p
+
+
=
CR
;
s
=
plf
;
*
p
+
+
=
*
s
+
+
;
}
}
headersLen
=
pEoh
-
s
;
if
(
headersLen
)
{
memcpy
(
p
s
headersLen
)
;
p
+
=
headersLen
;
}
}
else
if
(
dataLen
)
{
uint32_t
l
=
sizeof
(
ContentLenHeader
)
+
sizeof
(
CRLFCRLF
)
+
32
;
newBufferLen
=
dataLen
+
l
;
*
outPostData
=
p
=
(
char
*
)
moz_xmalloc
(
newBufferLen
)
;
headersLen
=
snprintf
(
p
l
"
%
s
:
%
u
%
s
"
ContentLenHeader
dataLen
CRLFCRLF
)
;
if
(
headersLen
=
=
l
)
{
free
(
p
)
;
*
outPostData
=
0
;
return
NS_ERROR_FAILURE
;
}
p
+
=
headersLen
;
newBufferLen
=
headersLen
+
dataLen
;
}
if
(
dataLen
)
{
memcpy
(
p
pSod
dataLen
)
;
}
*
outPostDataLen
=
newBufferLen
;
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
GetPluginName
(
nsNPAPIPluginInstance
*
aPluginInstance
const
char
*
*
aPluginName
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
nsPluginHost
:
:
GetPluginTagForInstance
(
nsNPAPIPluginInstance
*
aPluginInstance
nsIPluginTag
*
*
aPluginTag
)
{
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsPluginHost
:
:
Notify
(
nsITimer
*
timer
)
{
RefPtr
<
nsPluginTag
>
pluginTag
=
mPlugins
;
while
(
pluginTag
)
{
if
(
pluginTag
-
>
mUnloadTimer
=
=
timer
)
{
if
(
!
IsRunningPlugin
(
pluginTag
)
)
{
pluginTag
-
>
TryUnloadPlugin
(
false
)
;
}
return
NS_OK
;
}
pluginTag
=
pluginTag
-
>
mNext
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
nsPluginHost
"
)
;
return
NS_OK
;
}
#
ifdef
XP_WIN
static
void
CheckForDisabledWindows
(
)
{
nsCOMPtr
<
nsIWindowMediator
>
wm
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
wm
)
return
;
nsCOMPtr
<
nsISimpleEnumerator
>
windowList
;
wm
-
>
GetAppWindowEnumerator
(
nullptr
getter_AddRefs
(
windowList
)
)
;
if
(
!
windowList
)
return
;
bool
haveWindows
;
do
{
windowList
-
>
HasMoreElements
(
&
haveWindows
)
;
if
(
!
haveWindows
)
return
;
nsCOMPtr
<
nsISupports
>
supportsWindow
;
windowList
-
>
GetNext
(
getter_AddRefs
(
supportsWindow
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWin
(
do_QueryInterface
(
supportsWindow
)
)
;
if
(
baseWin
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
baseWin
-
>
GetMainWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
&
&
!
widget
-
>
GetParent
(
)
&
&
widget
-
>
IsVisible
(
)
&
&
!
widget
-
>
IsEnabled
(
)
)
{
nsIWidget
*
child
=
widget
-
>
GetFirstChild
(
)
;
bool
enable
=
true
;
while
(
child
)
{
if
(
child
-
>
WindowType
(
)
=
=
eWindowType_dialog
)
{
enable
=
false
;
break
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
if
(
enable
)
{
widget
-
>
Enable
(
true
)
;
}
}
}
}
while
(
haveWindows
)
;
}
#
endif
nsNPAPIPluginInstance
*
nsPluginHost
:
:
FindInstance
(
const
char
*
mimetype
)
{
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
]
;
const
char
*
mt
;
nsresult
rv
=
instance
-
>
GetMIMEType
(
&
mt
)
;
if
(
NS_FAILED
(
rv
)
)
continue
;
if
(
PL_strcasecmp
(
mt
mimetype
)
=
=
0
)
return
instance
;
}
return
nullptr
;
}
nsNPAPIPluginInstance
*
nsPluginHost
:
:
FindOldestStoppedInstance
(
)
{
nsNPAPIPluginInstance
*
oldestInstance
=
nullptr
;
TimeStamp
oldestTime
=
TimeStamp
:
:
Now
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
]
;
if
(
instance
-
>
IsRunning
(
)
)
continue
;
TimeStamp
time
=
instance
-
>
StopTime
(
)
;
if
(
time
<
oldestTime
)
{
oldestTime
=
time
;
oldestInstance
=
instance
;
}
}
return
oldestInstance
;
}
uint32_t
nsPluginHost
:
:
StoppedInstanceCount
(
)
{
uint32_t
stoppedCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
]
;
if
(
!
instance
-
>
IsRunning
(
)
)
stoppedCount
+
+
;
}
return
stoppedCount
;
}
nsTArray
<
RefPtr
<
nsNPAPIPluginInstance
>
>
*
nsPluginHost
:
:
InstanceArray
(
)
{
return
&
mInstances
;
}
void
nsPluginHost
:
:
DestroyRunningInstances
(
nsPluginTag
*
aPluginTag
)
{
}
bool
nsPluginHost
:
:
CanUsePluginForMIMEType
(
const
nsACString
&
aMIMEType
)
{
if
(
nsPluginHost
:
:
GetSpecialType
(
aMIMEType
)
=
=
nsPluginHost
:
:
eSpecialType_Flash
|
|
MimeTypeIsAllowedForFakePlugin
(
NS_ConvertUTF8toUTF16
(
aMIMEType
)
)
|
|
aMIMEType
.
LowerCaseEqualsLiteral
(
"
application
/
x
-
test
"
)
)
{
return
true
;
}
return
false
;
}
class
nsPluginDestroyRunnable
:
public
Runnable
public
mozilla
:
:
LinkedListElement
<
nsPluginDestroyRunnable
>
{
public
:
explicit
nsPluginDestroyRunnable
(
nsNPAPIPluginInstance
*
aInstance
)
:
Runnable
(
"
nsPluginDestroyRunnable
"
)
mInstance
(
aInstance
)
{
sRunnableList
.
insertBack
(
this
)
;
}
~
nsPluginDestroyRunnable
(
)
override
{
this
-
>
remove
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
nsNPAPIPluginInstance
>
instance
;
instance
.
swap
(
mInstance
)
;
if
(
PluginDestructionGuard
:
:
DelayDestroy
(
instance
)
)
{
return
NS_OK
;
}
for
(
auto
r
:
sRunnableList
)
{
if
(
r
!
=
this
&
&
r
-
>
mInstance
=
=
instance
)
{
return
NS_OK
;
}
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
Doing
delayed
destroy
of
instance
%
p
\
n
"
instance
.
get
(
)
)
)
;
RefPtr
<
nsPluginHost
>
host
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
host
)
host
-
>
StopPluginInstance
(
instance
)
;
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
Done
with
delayed
destroy
of
instance
%
p
\
n
"
instance
.
get
(
)
)
)
;
return
NS_OK
;
}
protected
:
RefPtr
<
nsNPAPIPluginInstance
>
mInstance
;
static
mozilla
:
:
LinkedList
<
nsPluginDestroyRunnable
>
sRunnableList
;
}
;
mozilla
:
:
LinkedList
<
nsPluginDestroyRunnable
>
nsPluginDestroyRunnable
:
:
sRunnableList
;
mozilla
:
:
LinkedList
<
PluginDestructionGuard
>
PluginDestructionGuard
:
:
sList
;
PluginDestructionGuard
:
:
PluginDestructionGuard
(
nsNPAPIPluginInstance
*
aInstance
)
:
mInstance
(
aInstance
)
{
Init
(
)
;
}
PluginDestructionGuard
:
:
PluginDestructionGuard
(
NPP
npp
)
:
mInstance
(
npp
?
static_cast
<
nsNPAPIPluginInstance
*
>
(
npp
-
>
ndata
)
:
nullptr
)
{
Init
(
)
;
}
PluginDestructionGuard
:
:
~
PluginDestructionGuard
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
"
)
;
this
-
>
remove
(
)
;
if
(
mDelayedDestroy
)
{
RefPtr
<
nsPluginDestroyRunnable
>
evt
=
new
nsPluginDestroyRunnable
(
mInstance
)
;
NS_DispatchToMainThread
(
evt
)
;
}
}
bool
PluginDestructionGuard
:
:
DelayDestroy
(
nsNPAPIPluginInstance
*
aInstance
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
"
)
;
NS_ASSERTION
(
aInstance
"
Uh
I
need
an
instance
!
"
)
;
for
(
auto
g
:
sList
)
{
if
(
g
-
>
mInstance
=
=
aInstance
)
{
g
-
>
mDelayedDestroy
=
true
;
return
true
;
}
}
return
false
;
}
