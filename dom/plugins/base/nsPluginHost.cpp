#
include
"
nscore
.
h
"
#
include
"
nsPluginHost
.
h
"
#
include
<
cstdlib
>
#
include
<
stdio
.
h
>
#
include
"
nsNPAPIPlugin
.
h
"
#
include
"
nsNPAPIPluginStreamListener
.
h
"
#
include
"
nsNPAPIPluginInstance
.
h
"
#
include
"
nsPluginInstanceOwner
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsIEventTarget
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIHttpProtocolHandler
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIUploadChannel
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsISeekableStream
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIStringStream
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPluginLogging
.
h
"
#
include
"
nsIScriptChannel
.
h
"
#
include
"
nsIBlocklistService
.
h
"
#
include
"
nsVersionComparator
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsPluginStreamListenerPeer
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FakePluginTagInitBinding
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
plugins
/
PluginBridge
.
h
"
#
include
"
mozilla
/
plugins
/
PluginTypes
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ipc
/
URIUtils
.
h
"
#
include
"
nsEnumeratorUtils
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsPluginNativeWindow
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsVersionComparator
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
PluginFinder
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
windows
.
h
"
#
include
"
winbase
.
h
"
#
endif
#
if
(
MOZ_WIDGET_GTK
)
#
include
<
gdk
/
gdk
.
h
>
#
include
<
gdk
/
gdkx
.
h
>
#
endif
#
include
"
npapi
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
dom
:
:
Document
;
using
mozilla
:
:
dom
:
:
FakePluginMimeEntry
;
using
mozilla
:
:
dom
:
:
FakePluginTagInit
;
using
mozilla
:
:
dom
:
:
Promise
;
using
mozilla
:
:
plugins
:
:
FakePluginTag
;
using
mozilla
:
:
plugins
:
:
PluginTag
;
#
define
NS_ITERATIVE_UNREF_LIST
(
type_
list_
mNext_
)
\
{
\
while
(
list_
)
{
\
type_
temp
=
list_
-
>
mNext_
;
\
list_
-
>
mNext_
=
nullptr
;
\
list_
=
temp
;
\
}
\
}
static
const
char
*
kPrefDisableFullPage
=
"
plugin
.
disable_full_page_plugin_for_types
"
;
LazyLogModule
nsPluginLogging
:
:
gNPNLog
(
NPN_LOG_NAME
)
;
LazyLogModule
nsPluginLogging
:
:
gNPPLog
(
NPP_LOG_NAME
)
;
LazyLogModule
nsPluginLogging
:
:
gPluginLog
(
PLUGIN_LOG_NAME
)
;
#
define
NS_PREF_MAX_NUM_CACHED_INSTANCES
\
"
browser
.
plugins
.
max_num_cached_plugins
"
#
define
DEFAULT_NUMBER_OF_STOPPED_INSTANCES
50
nsIFile
*
nsPluginHost
:
:
sPluginTempDir
;
StaticRefPtr
<
nsPluginHost
>
nsPluginHost
:
:
sInst
;
static
bool
IsTypeInList
(
const
nsCString
&
aMimeType
nsCString
aTypeList
)
{
nsAutoCString
searchStr
;
searchStr
.
Assign
(
'
'
)
;
searchStr
.
Append
(
aTypeList
)
;
searchStr
.
Append
(
'
'
)
;
nsACString
:
:
const_iterator
start
end
;
searchStr
.
BeginReading
(
start
)
;
searchStr
.
EndReading
(
end
)
;
nsAutoCString
commaSeparated
;
commaSeparated
.
Assign
(
'
'
)
;
commaSeparated
+
=
aMimeType
;
commaSeparated
.
Append
(
'
'
)
;
ToLowerCase
(
searchStr
)
;
ToLowerCase
(
commaSeparated
)
;
return
FindInReadable
(
commaSeparated
start
end
)
;
}
namespace
mozilla
:
:
plugins
{
class
BlocklistPromiseHandler
final
:
public
mozilla
:
:
dom
:
:
PromiseNativeHandler
{
public
:
NS_DECL_ISUPPORTS
BlocklistPromiseHandler
(
nsPluginTag
*
aTag
const
bool
aShouldSoftblock
)
:
mTag
(
aTag
)
mShouldDisableWhenSoftblocked
(
aShouldSoftblock
)
{
MOZ_ASSERT
(
mTag
"
Should
always
be
passed
a
plugin
tag
"
)
;
sPendingBlocklistStateRequests
+
+
;
}
void
MaybeWriteBlocklistChanges
(
)
{
if
(
!
mTag
)
{
return
;
}
mTag
=
nullptr
;
sPendingBlocklistStateRequests
-
-
;
if
(
!
sPendingBlocklistStateRequests
)
{
if
(
sPluginBlocklistStatesChangedSinceLastWrite
)
{
sPluginBlocklistStatesChangedSinceLastWrite
=
false
;
RefPtr
<
nsPluginHost
>
host
=
nsPluginHost
:
:
GetInst
(
)
;
PluginFinder
:
:
WritePluginInfo
(
host
-
>
mFlashOnly
host
-
>
mPlugins
)
;
host
-
>
IncrementChromeEpoch
(
)
;
host
-
>
BroadcastPluginsToContent
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
nullptr
"
plugin
-
blocklist
-
updates
-
finished
"
nullptr
)
;
}
}
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
if
(
!
aValue
.
isInt32
(
)
)
{
MOZ_ASSERT
(
false
"
Blocklist
should
always
return
int32
"
)
;
return
;
}
int32_t
newState
=
aValue
.
toInt32
(
)
;
MOZ_ASSERT
(
newState
>
=
0
&
&
newState
<
nsIBlocklistService
:
:
STATE_MAX
"
Shouldn
'
t
get
an
out
of
bounds
blocklist
state
"
)
;
uint32_t
oldState
=
mTag
-
>
GetBlocklistState
(
)
;
bool
changed
=
oldState
!
=
(
uint32_t
)
newState
;
mTag
-
>
SetBlocklistState
(
newState
)
;
if
(
newState
=
=
nsIBlocklistService
:
:
STATE_SOFTBLOCKED
&
&
mShouldDisableWhenSoftblocked
)
{
mTag
-
>
SetEnabledState
(
nsIPluginTag
:
:
STATE_DISABLED
)
;
changed
=
true
;
}
sPluginBlocklistStatesChangedSinceLastWrite
|
=
changed
;
MaybeWriteBlocklistChanges
(
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_ASSERT
(
false
"
Shouldn
'
t
reject
plugin
blocklist
state
request
"
)
;
MaybeWriteBlocklistChanges
(
)
;
}
private
:
~
BlocklistPromiseHandler
(
)
{
MaybeWriteBlocklistChanges
(
)
;
}
RefPtr
<
nsPluginTag
>
mTag
;
bool
mShouldDisableWhenSoftblocked
;
static
bool
sPluginBlocklistStatesChangedSinceLastWrite
;
static
uint32_t
sPendingBlocklistStateRequests
;
}
;
NS_IMPL_ISUPPORTS0
(
BlocklistPromiseHandler
)
bool
BlocklistPromiseHandler
:
:
sPluginBlocklistStatesChangedSinceLastWrite
=
false
;
uint32_t
BlocklistPromiseHandler
:
:
sPendingBlocklistStateRequests
=
0
;
}
nsPluginHost
:
:
nsPluginHost
(
)
:
mPluginsLoaded
(
false
)
mOverrideInternalTypes
(
false
)
mPluginsDisabled
(
false
)
mFlashOnly
(
true
)
mDoReloadOnceFindingFinished
(
false
)
mAddedFinderShutdownBlocker
(
false
)
mPluginEpoch
(
0
)
{
mOverrideInternalTypes
=
Preferences
:
:
GetBool
(
"
plugin
.
override_internal_types
"
false
)
;
if
(
xpc
:
:
IsInAutomation
(
)
)
{
mFlashOnly
=
Preferences
:
:
GetBool
(
"
plugin
.
load_flash_only
"
true
)
;
}
bool
waylandBackend
=
false
;
#
if
MOZ_WIDGET_GTK
GdkDisplay
*
display
=
gdk_display_get_default
(
)
;
if
(
display
)
{
waylandBackend
=
!
GDK_IS_X11_DISPLAY
(
display
)
;
}
#
endif
mPluginsDisabled
=
Preferences
:
:
GetBool
(
"
plugin
.
disable
"
false
)
|
|
waylandBackend
;
if
(
!
waylandBackend
)
{
Preferences
:
:
AddStrongObserver
(
this
"
plugin
.
disable
"
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
AddObserver
(
this
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
if
(
XRE_IsParentProcess
(
)
)
{
obsService
-
>
AddObserver
(
this
"
plugin
-
blocklist
-
updated
"
false
)
;
}
}
#
ifdef
PLUGIN_LOGGING
MOZ_LOG
(
nsPluginLogging
:
:
gNPNLog
PLUGIN_LOG_ALWAYS
(
"
NPN
Logging
Active
!
\
n
"
)
)
;
MOZ_LOG
(
nsPluginLogging
:
:
gPluginLog
PLUGIN_LOG_ALWAYS
(
"
General
Plugin
Logging
Active
!
(
nsPluginHost
:
:
ctor
)
\
n
"
)
)
;
MOZ_LOG
(
nsPluginLogging
:
:
gNPPLog
PLUGIN_LOG_ALWAYS
(
"
NPP
Logging
Active
!
\
n
"
)
)
;
PLUGIN_LOG
(
PLUGIN_LOG_ALWAYS
(
"
nsPluginHost
:
:
ctor
\
n
"
)
)
;
PR_LogFlush
(
)
;
#
endif
nsPluginTag
:
:
EnsureSandboxInformation
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
IncrementChromeEpoch
(
)
;
LoadPlugins
(
)
;
}
}
nsPluginHost
:
:
~
nsPluginHost
(
)
{
PLUGIN_LOG
(
PLUGIN_LOG_ALWAYS
(
"
nsPluginHost
:
:
dtor
\
n
"
)
)
;
UnloadPlugins
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsPluginHost
nsIPluginHost
nsIObserver
nsITimerCallback
nsISupportsWeakReference
nsINamed
)
already_AddRefed
<
nsPluginHost
>
nsPluginHost
:
:
GetInst
(
)
{
if
(
!
sInst
)
{
sInst
=
new
nsPluginHost
(
)
;
ClearOnShutdown
(
&
sInst
)
;
}
return
do_AddRef
(
sInst
)
;
}
bool
nsPluginHost
:
:
IsRunningPlugin
(
nsPluginTag
*
aPluginTag
)
{
if
(
!
aPluginTag
|
|
!
aPluginTag
-
>
mPlugin
)
{
return
false
;
}
if
(
aPluginTag
-
>
mContentProcessRunningCount
)
{
return
true
;
}
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
]
.
get
(
)
;
if
(
instance
&
&
instance
-
>
GetPlugin
(
)
=
=
aPluginTag
-
>
mPlugin
&
&
instance
-
>
IsRunning
(
)
)
{
return
true
;
}
}
return
false
;
}
nsresult
nsPluginHost
:
:
ReloadPlugins
(
)
{
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
ReloadPlugins
Begin
\
n
"
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
Unused
<
<
mozilla
:
:
dom
:
:
ContentChild
:
:
GetSingleton
(
)
-
>
SendMaybeReloadPlugins
(
)
;
return
NS_ERROR_PLUGINS_PLUGINSNOTCHANGED
;
}
if
(
!
mPluginsLoaded
)
return
LoadPlugins
(
)
;
if
(
mPendingFinder
)
{
mDoReloadOnceFindingFinished
=
true
;
return
NS_ERROR_PLUGINS_PLUGINSNOTCHANGED
;
}
RefPtr
<
PluginFinder
>
pf
=
new
PluginFinder
(
mFlashOnly
)
;
bool
pluginschanged
;
MOZ_TRY
(
pf
-
>
HavePluginsChanged
(
[
&
pluginschanged
]
(
bool
aPluginsChanged
)
{
pluginschanged
=
aPluginsChanged
;
}
)
)
;
pf
-
>
Run
(
)
;
if
(
!
pluginschanged
)
return
NS_ERROR_PLUGINS_PLUGINSNOTCHANGED
;
return
ActuallyReloadPlugins
(
)
;
}
void
nsPluginHost
:
:
ClearNonRunningPlugins
(
)
{
RefPtr
<
nsPluginTag
>
prev
;
RefPtr
<
nsPluginTag
>
next
;
for
(
RefPtr
<
nsPluginTag
>
p
=
mPlugins
;
p
!
=
nullptr
;
)
{
next
=
p
-
>
mNext
;
if
(
!
IsRunningPlugin
(
p
)
)
{
if
(
p
=
=
mPlugins
)
mPlugins
=
next
;
else
prev
-
>
mNext
=
next
;
p
-
>
mNext
=
nullptr
;
p
-
>
TryUnloadPlugin
(
false
)
;
p
=
next
;
continue
;
}
prev
=
p
;
p
=
next
;
}
}
nsresult
nsPluginHost
:
:
ActuallyReloadPlugins
(
)
{
nsresult
rv
=
NS_OK
;
ClearNonRunningPlugins
(
)
;
mPluginsLoaded
=
false
;
rv
=
LoadPlugins
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
BroadcastPluginsToContent
(
)
;
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
ReloadPlugins
End
\
n
"
)
)
;
return
rv
;
}
#
define
NS_RETURN_UASTRING_SIZE
128
nsresult
nsPluginHost
:
:
UserAgent
(
const
char
*
*
retstring
)
{
static
char
resultString
[
NS_RETURN_UASTRING_SIZE
]
;
nsresult
res
;
nsCOMPtr
<
nsIHttpProtocolHandler
>
http
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
http
"
&
res
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
nsAutoCString
uaString
;
res
=
http
-
>
GetUserAgent
(
uaString
)
;
if
(
NS_SUCCEEDED
(
res
)
)
{
if
(
NS_RETURN_UASTRING_SIZE
>
uaString
.
Length
(
)
)
{
PL_strcpy
(
resultString
uaString
.
get
(
)
)
;
}
else
{
PL_strncpy
(
resultString
uaString
.
get
(
)
NS_RETURN_UASTRING_SIZE
)
;
for
(
int
i
=
NS_RETURN_UASTRING_SIZE
-
1
;
i
>
=
0
;
i
-
-
)
{
if
(
i
=
=
0
)
{
resultString
[
NS_RETURN_UASTRING_SIZE
-
1
]
=
'
\
0
'
;
}
else
if
(
resultString
[
i
]
=
=
'
'
)
{
resultString
[
i
]
=
'
\
0
'
;
break
;
}
}
}
*
retstring
=
resultString
;
}
else
{
*
retstring
=
nullptr
;
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
UserAgent
return
=
%
s
\
n
"
*
retstring
)
)
;
return
res
;
}
nsresult
nsPluginHost
:
:
GetURL
(
nsISupports
*
pluginInst
const
char
*
url
const
char
*
target
nsNPAPIPluginStreamListener
*
streamListener
const
char
*
altHost
const
char
*
referrer
bool
forceJSEnabled
)
{
return
GetURLWithHeaders
(
static_cast
<
nsNPAPIPluginInstance
*
>
(
pluginInst
)
url
target
streamListener
altHost
referrer
forceJSEnabled
0
nullptr
)
;
}
nsresult
nsPluginHost
:
:
GetURLWithHeaders
(
nsNPAPIPluginInstance
*
pluginInst
const
char
*
url
const
char
*
target
nsNPAPIPluginStreamListener
*
streamListener
const
char
*
altHost
const
char
*
referrer
bool
forceJSEnabled
uint32_t
getHeadersLength
const
char
*
getHeaders
)
{
if
(
!
target
&
&
!
streamListener
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
nsresult
rv
=
NS_OK
;
if
(
target
)
{
RefPtr
<
nsPluginInstanceOwner
>
owner
=
pluginInst
-
>
GetOwner
(
)
;
if
(
owner
)
{
rv
=
owner
-
>
GetURL
(
url
target
nullptr
nullptr
0
true
)
;
}
}
if
(
streamListener
)
{
rv
=
NewPluginURLStream
(
NS_ConvertUTF8toUTF16
(
url
)
pluginInst
streamListener
nullptr
getHeaders
getHeadersLength
)
;
}
return
rv
;
}
nsresult
nsPluginHost
:
:
PostURL
(
nsISupports
*
pluginInst
const
char
*
url
uint32_t
postDataLen
const
char
*
postData
const
char
*
target
nsNPAPIPluginStreamListener
*
streamListener
const
char
*
altHost
const
char
*
referrer
bool
forceJSEnabled
uint32_t
postHeadersLength
const
char
*
postHeaders
)
{
nsresult
rv
;
if
(
!
target
&
&
!
streamListener
)
return
NS_ERROR_ILLEGAL_VALUE
;
nsNPAPIPluginInstance
*
instance
=
static_cast
<
nsNPAPIPluginInstance
*
>
(
pluginInst
)
;
nsCOMPtr
<
nsIInputStream
>
postStream
;
char
*
dataToPost
;
uint32_t
newDataToPostLen
;
ParsePostBufferToFixHeaders
(
postData
postDataLen
&
dataToPost
&
newDataToPostLen
)
;
if
(
!
dataToPost
)
return
NS_ERROR_UNEXPECTED
;
nsCOMPtr
<
nsIStringInputStream
>
sis
=
do_CreateInstance
(
"
mozilla
.
org
/
io
/
string
-
input
-
stream
;
1
"
&
rv
)
;
if
(
!
sis
)
{
free
(
dataToPost
)
;
return
rv
;
}
postDataLen
=
newDataToPostLen
;
sis
-
>
AdoptData
(
dataToPost
postDataLen
)
;
postStream
=
sis
;
if
(
target
)
{
RefPtr
<
nsPluginInstanceOwner
>
owner
=
instance
-
>
GetOwner
(
)
;
if
(
owner
)
{
rv
=
owner
-
>
GetURL
(
url
target
postStream
(
void
*
)
postHeaders
postHeadersLength
true
)
;
}
}
if
(
streamListener
)
{
rv
=
NewPluginURLStream
(
NS_ConvertUTF8toUTF16
(
url
)
instance
streamListener
postStream
postHeaders
postHeadersLength
)
;
}
return
rv
;
}
nsresult
nsPluginHost
:
:
UnloadPlugins
(
)
{
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
UnloadPlugins
Called
\
n
"
)
)
;
if
(
!
mPluginsLoaded
)
return
NS_OK
;
DestroyRunningInstances
(
nullptr
)
;
nsPluginTag
*
pluginTag
;
for
(
pluginTag
=
mPlugins
;
pluginTag
;
pluginTag
=
pluginTag
-
>
mNext
)
{
pluginTag
-
>
TryUnloadPlugin
(
true
)
;
}
NS_ITERATIVE_UNREF_LIST
(
RefPtr
<
nsPluginTag
>
mPlugins
mNext
)
;
if
(
sPluginTempDir
)
{
sPluginTempDir
-
>
Remove
(
true
)
;
NS_RELEASE
(
sPluginTempDir
)
;
}
mSerializablePlugins
.
Clear
(
)
;
mSerializableFakePlugins
.
Clear
(
)
;
mPluginsLoaded
=
false
;
return
NS_OK
;
}
void
nsPluginHost
:
:
OnPluginInstanceDestroyed
(
nsPluginTag
*
aPluginTag
)
{
bool
hasInstance
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
if
(
TagForPlugin
(
mInstances
[
i
]
-
>
GetPlugin
(
)
)
=
=
aPluginTag
)
{
hasInstance
=
true
;
break
;
}
}
if
(
!
hasInstance
)
{
if
(
UnloadPluginsASAP
(
)
)
{
aPluginTag
-
>
TryUnloadPlugin
(
false
)
;
}
else
{
if
(
aPluginTag
-
>
mUnloadTimer
)
{
aPluginTag
-
>
mUnloadTimer
-
>
Cancel
(
)
;
}
else
{
aPluginTag
-
>
mUnloadTimer
=
NS_NewTimer
(
)
;
}
uint32_t
unloadTimeout
=
StaticPrefs
:
:
dom_ipc_plugins_unloadTimeoutSecs
(
)
;
aPluginTag
-
>
mUnloadTimer
-
>
InitWithCallback
(
this
1000
*
unloadTimeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
}
}
nsresult
nsPluginHost
:
:
InstantiatePluginInstance
(
const
nsACString
&
aMimeType
nsIURI
*
aURL
nsObjectLoadingContent
*
aContent
nsPluginInstanceOwner
*
*
aOwner
)
{
NS_ENSURE_ARG_POINTER
(
aOwner
)
;
#
ifdef
PLUGIN_LOGGING
nsAutoCString
urlSpec
;
if
(
aURL
)
aURL
-
>
GetAsciiSpec
(
urlSpec
)
;
MOZ_LOG
(
nsPluginLogging
:
:
gPluginLog
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
InstantiatePlugin
Begin
mime
=
%
s
url
=
%
s
\
n
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
urlSpec
.
get
(
)
)
)
;
PR_LogFlush
(
)
;
#
endif
if
(
aMimeType
.
IsEmpty
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Attempting
to
spawn
a
plugin
with
no
mime
type
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsPluginInstanceOwner
>
instanceOwner
=
new
nsPluginInstanceOwner
(
)
;
if
(
!
instanceOwner
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsCOMPtr
<
nsIContent
>
ourContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
aContent
)
)
;
nsresult
rv
=
instanceOwner
-
>
Init
(
ourContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsPluginTagType
tagType
;
rv
=
instanceOwner
-
>
GetTagType
(
&
tagType
)
;
if
(
NS_FAILED
(
rv
)
)
{
instanceOwner
-
>
Destroy
(
)
;
return
rv
;
}
if
(
tagType
!
=
nsPluginTagType_Embed
&
&
tagType
!
=
nsPluginTagType_Object
)
{
instanceOwner
-
>
Destroy
(
)
;
return
NS_ERROR_FAILURE
;
}
rv
=
SetUpPluginInstance
(
aMimeType
aURL
instanceOwner
)
;
if
(
NS_FAILED
(
rv
)
)
{
instanceOwner
-
>
Destroy
(
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsNPAPIPluginInstance
>
instance
=
instanceOwner
-
>
GetInstance
(
)
;
if
(
instance
)
{
CreateWidget
(
instanceOwner
)
;
}
instanceOwner
.
forget
(
aOwner
)
;
#
ifdef
PLUGIN_LOGGING
nsAutoCString
urlSpec2
;
if
(
aURL
!
=
nullptr
)
aURL
-
>
GetAsciiSpec
(
urlSpec2
)
;
MOZ_LOG
(
nsPluginLogging
:
:
gPluginLog
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
InstantiatePlugin
Finished
mime
=
%
s
rv
=
%
"
PRIu32
"
url
=
%
s
\
n
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
urlSpec2
.
get
(
)
)
)
;
PR_LogFlush
(
)
;
#
endif
return
NS_OK
;
}
nsPluginTag
*
nsPluginHost
:
:
FindTagForLibrary
(
PRLibrary
*
aLibrary
)
{
nsPluginTag
*
pluginTag
;
for
(
pluginTag
=
mPlugins
;
pluginTag
;
pluginTag
=
pluginTag
-
>
mNext
)
{
if
(
pluginTag
-
>
mLibrary
=
=
aLibrary
)
{
return
pluginTag
;
}
}
return
nullptr
;
}
nsPluginTag
*
nsPluginHost
:
:
TagForPlugin
(
nsNPAPIPlugin
*
aPlugin
)
{
nsPluginTag
*
pluginTag
;
for
(
pluginTag
=
mPlugins
;
pluginTag
;
pluginTag
=
pluginTag
-
>
mNext
)
{
if
(
pluginTag
-
>
mPlugin
=
=
aPlugin
)
{
return
pluginTag
;
}
}
NS_ERROR
(
"
TagForPlugin
has
failed
"
)
;
return
nullptr
;
}
nsresult
nsPluginHost
:
:
SetUpPluginInstance
(
const
nsACString
&
aMimeType
nsIURI
*
aURL
nsPluginInstanceOwner
*
aOwner
)
{
NS_ENSURE_ARG_POINTER
(
aOwner
)
;
nsresult
rv
=
TrySetUpPluginInstance
(
aMimeType
aURL
aOwner
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
Document
>
document
;
aOwner
-
>
GetDocument
(
getter_AddRefs
(
document
)
)
;
nsCOMPtr
<
Document
>
currentdocument
=
do_QueryReferent
(
mCurrentDocument
)
;
if
(
document
=
=
currentdocument
)
{
return
rv
;
}
mCurrentDocument
=
do_GetWeakReference
(
document
)
;
if
(
ReloadPlugins
(
)
=
=
NS_ERROR_PLUGINS_PLUGINSNOTCHANGED
)
{
return
rv
;
}
return
TrySetUpPluginInstance
(
aMimeType
aURL
aOwner
)
;
}
nsresult
nsPluginHost
:
:
TrySetUpPluginInstance
(
const
nsACString
&
aMimeType
nsIURI
*
aURL
nsPluginInstanceOwner
*
aOwner
)
{
#
ifdef
PLUGIN_LOGGING
MOZ_LOG
(
nsPluginLogging
:
:
gPluginLog
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
TrySetupPluginInstance
Begin
mime
=
%
s
owner
=
%
p
url
=
%
s
\
n
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
aOwner
aURL
?
aURL
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
PR_LogFlush
(
)
;
#
endif
#
ifdef
XP_WIN
bool
changed
;
if
(
(
mRegKeyHKLM
&
&
NS_SUCCEEDED
(
mRegKeyHKLM
-
>
HasChanged
(
&
changed
)
)
&
&
changed
)
|
|
(
mRegKeyHKCU
&
&
NS_SUCCEEDED
(
mRegKeyHKCU
-
>
HasChanged
(
&
changed
)
)
&
&
changed
)
)
{
ReloadPlugins
(
)
;
}
#
endif
RefPtr
<
nsNPAPIPlugin
>
plugin
;
GetPlugin
(
aMimeType
getter_AddRefs
(
plugin
)
)
;
if
(
!
plugin
)
{
return
NS_ERROR_FAILURE
;
}
nsPluginTag
*
pluginTag
=
FindNativePluginForType
(
aMimeType
true
)
;
NS_ASSERTION
(
pluginTag
"
Must
have
plugin
tag
here
!
"
)
;
plugin
-
>
GetLibrary
(
)
-
>
SetHasLocalInstance
(
)
;
RefPtr
<
nsNPAPIPluginInstance
>
instance
=
new
nsNPAPIPluginInstance
(
)
;
aOwner
-
>
SetInstance
(
instance
.
get
(
)
)
;
mInstances
.
AppendElement
(
instance
.
get
(
)
)
;
nsresult
rv
=
instance
-
>
Initialize
(
plugin
.
get
(
)
aOwner
aMimeType
)
;
if
(
NS_FAILED
(
rv
)
)
{
mInstances
.
RemoveElement
(
instance
.
get
(
)
)
;
aOwner
-
>
SetInstance
(
nullptr
)
;
return
rv
;
}
if
(
pluginTag
-
>
mUnloadTimer
)
{
pluginTag
-
>
mUnloadTimer
-
>
Cancel
(
)
;
}
#
ifdef
PLUGIN_LOGGING
MOZ_LOG
(
nsPluginLogging
:
:
gPluginLog
PLUGIN_LOG_BASIC
(
"
nsPluginHost
:
:
TrySetupPluginInstance
Finished
mime
=
%
s
rv
=
%
"
PRIu32
"
owner
=
%
p
url
=
%
s
\
n
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
aOwner
aURL
?
aURL
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
PR_LogFlush
(
)
;
#
endif
return
rv
;
}
bool
nsPluginHost
:
:
HavePluginForType
(
const
nsACString
&
aMimeType
PluginFilter
aFilter
)
{
bool
checkEnabled
=
aFilter
&
eExcludeDisabled
;
bool
allowFake
=
!
(
aFilter
&
eExcludeFake
)
;
return
FindPluginForType
(
aMimeType
allowFake
checkEnabled
)
;
}
nsIInternalPluginTag
*
nsPluginHost
:
:
FindPluginForType
(
const
nsACString
&
aMimeType
bool
aIncludeFake
bool
aCheckEnabled
)
{
if
(
aIncludeFake
)
{
nsFakePluginTag
*
fakeTag
=
FindFakePluginForType
(
aMimeType
aCheckEnabled
)
;
if
(
fakeTag
)
{
return
fakeTag
;
}
}
return
FindNativePluginForType
(
aMimeType
aCheckEnabled
)
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetPluginTagForType
(
const
nsACString
&
aMimeType
uint32_t
aExcludeFlags
nsIPluginTag
*
*
aResult
)
{
bool
includeFake
=
!
(
aExcludeFlags
&
eExcludeFake
)
;
bool
includeDisabled
=
!
(
aExcludeFlags
&
eExcludeDisabled
)
;
RefPtr
<
nsIInternalPluginTag
>
tag
=
FindPluginForType
(
aMimeType
includeFake
true
)
;
if
(
!
tag
&
&
includeDisabled
)
{
tag
=
FindPluginForType
(
aMimeType
includeFake
false
)
;
}
if
(
tag
)
{
tag
.
forget
(
aResult
)
;
return
NS_OK
;
}
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetStateForType
(
const
nsACString
&
aMimeType
uint32_t
aExcludeFlags
uint32_t
*
aResult
)
{
nsCOMPtr
<
nsIPluginTag
>
tag
;
nsresult
rv
=
GetPluginTagForType
(
aMimeType
aExcludeFlags
getter_AddRefs
(
tag
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
tag
-
>
GetEnabledState
(
aResult
)
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetBlocklistStateForType
(
const
nsACString
&
aMimeType
uint32_t
aExcludeFlags
uint32_t
*
aState
)
{
nsCOMPtr
<
nsIPluginTag
>
tag
;
nsresult
rv
=
GetPluginTagForType
(
aMimeType
aExcludeFlags
getter_AddRefs
(
tag
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
tag
-
>
GetBlocklistState
(
aState
)
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetPermissionStringForType
(
const
nsACString
&
aMimeType
uint32_t
aExcludeFlags
nsACString
&
aPermissionString
)
{
nsCOMPtr
<
nsIPluginTag
>
tag
;
nsresult
rv
=
GetPluginTagForType
(
aMimeType
aExcludeFlags
getter_AddRefs
(
tag
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetPermissionStringForTag
(
tag
aExcludeFlags
aPermissionString
)
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetPermissionStringForTag
(
nsIPluginTag
*
aTag
uint32_t
aExcludeFlags
nsACString
&
aPermissionString
)
{
NS_ENSURE_TRUE
(
aTag
NS_ERROR_FAILURE
)
;
aPermissionString
.
Truncate
(
)
;
uint32_t
blocklistState
;
nsresult
rv
=
aTag
-
>
GetBlocklistState
(
&
blocklistState
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
blocklistState
=
=
nsIBlocklistService
:
:
STATE_VULNERABLE_UPDATE_AVAILABLE
|
|
blocklistState
=
=
nsIBlocklistService
:
:
STATE_VULNERABLE_NO_UPDATE
)
{
aPermissionString
.
AssignLiteral
(
"
plugin
-
vulnerable
:
"
)
;
}
else
{
aPermissionString
.
AssignLiteral
(
"
plugin
:
"
)
;
}
nsCString
niceName
;
rv
=
aTag
-
>
GetNiceName
(
niceName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
!
niceName
.
IsEmpty
(
)
NS_ERROR_FAILURE
)
;
aPermissionString
.
Append
(
niceName
)
;
return
NS_OK
;
}
bool
nsPluginHost
:
:
HavePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
PluginFilter
aFilter
)
{
if
(
!
aExtension
.
LowerCaseEqualsLiteral
(
"
swf
"
)
&
&
!
aExtension
.
LowerCaseEqualsLiteral
(
"
tst
"
)
)
{
return
false
;
}
bool
checkEnabled
=
aFilter
&
eExcludeDisabled
;
bool
allowFake
=
!
(
aFilter
&
eExcludeFake
)
;
return
FindNativePluginForExtension
(
aExtension
aMimeType
checkEnabled
)
|
|
(
allowFake
&
&
FindFakePluginForExtension
(
aExtension
aMimeType
checkEnabled
)
)
;
}
void
nsPluginHost
:
:
GetPlugins
(
nsTArray
<
nsCOMPtr
<
nsIInternalPluginTag
>
>
&
aPluginArray
bool
aIncludeDisabled
)
{
aPluginArray
.
Clear
(
)
;
LoadPlugins
(
)
;
uint32_t
numFake
=
mFakePlugins
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numFake
;
i
+
+
)
{
aPluginArray
.
AppendElement
(
mFakePlugins
[
i
]
)
;
}
nsPluginTag
*
plugin
=
mPlugins
;
while
(
plugin
!
=
nullptr
)
{
if
(
plugin
-
>
IsEnabled
(
)
|
|
aIncludeDisabled
)
{
aPluginArray
.
AppendElement
(
plugin
)
;
}
plugin
=
plugin
-
>
mNext
;
}
}
NS_IMETHODIMP
nsPluginHost
:
:
GetPluginTags
(
nsTArray
<
RefPtr
<
nsIPluginTag
>
>
&
aResults
)
{
LoadPlugins
(
)
;
for
(
nsPluginTag
*
plugin
=
mPlugins
;
plugin
;
plugin
=
plugin
-
>
mNext
)
{
aResults
.
AppendElement
(
plugin
)
;
}
for
(
nsIInternalPluginTag
*
plugin
:
mFakePlugins
)
{
aResults
.
AppendElement
(
plugin
)
;
}
return
NS_OK
;
}
nsPluginTag
*
nsPluginHost
:
:
FindPreferredPlugin
(
const
nsTArray
<
nsPluginTag
*
>
&
matches
)
{
if
(
matches
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsPluginTag
*
preferredPlugin
=
matches
[
0
]
;
for
(
unsigned
int
i
=
1
;
i
<
matches
.
Length
(
)
;
i
+
+
)
{
if
(
mozilla
:
:
Version
(
matches
[
i
]
-
>
Version
(
)
.
get
(
)
)
>
preferredPlugin
-
>
Version
(
)
.
get
(
)
)
{
preferredPlugin
=
matches
[
i
]
;
}
}
return
preferredPlugin
;
}
nsFakePluginTag
*
nsPluginHost
:
:
FindFakePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
if
(
aExtension
.
IsEmpty
(
)
)
{
return
nullptr
;
}
int32_t
numFakePlugins
=
mFakePlugins
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
numFakePlugins
;
i
+
+
)
{
nsFakePluginTag
*
plugin
=
mFakePlugins
[
i
]
;
bool
active
;
if
(
(
!
aCheckEnabled
|
|
(
NS_SUCCEEDED
(
plugin
-
>
GetActive
(
&
active
)
)
&
&
active
)
)
&
&
plugin
-
>
HasExtension
(
aExtension
aMimeType
)
)
{
return
plugin
;
}
}
return
nullptr
;
}
nsFakePluginTag
*
nsPluginHost
:
:
FindFakePluginForType
(
const
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
int32_t
numFakePlugins
=
mFakePlugins
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
numFakePlugins
;
i
+
+
)
{
nsFakePluginTag
*
plugin
=
mFakePlugins
[
i
]
;
bool
active
;
if
(
(
!
aCheckEnabled
|
|
(
NS_SUCCEEDED
(
plugin
-
>
GetActive
(
&
active
)
)
&
&
active
)
)
&
&
plugin
-
>
HasMimeType
(
aMimeType
)
)
{
return
plugin
;
}
}
return
nullptr
;
}
nsPluginTag
*
nsPluginHost
:
:
FindNativePluginForType
(
const
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
if
(
aMimeType
.
IsEmpty
(
)
)
{
return
nullptr
;
}
if
(
!
nsPluginHost
:
:
CanUsePluginForMIMEType
(
aMimeType
)
)
{
return
nullptr
;
}
LoadPlugins
(
)
;
nsTArray
<
nsPluginTag
*
>
matchingPlugins
;
nsPluginTag
*
plugin
=
mPlugins
;
while
(
plugin
)
{
if
(
(
!
aCheckEnabled
|
|
plugin
-
>
IsActive
(
)
)
&
&
plugin
-
>
HasMimeType
(
aMimeType
)
)
{
matchingPlugins
.
AppendElement
(
plugin
)
;
}
plugin
=
plugin
-
>
mNext
;
}
return
FindPreferredPlugin
(
matchingPlugins
)
;
}
nsPluginTag
*
nsPluginHost
:
:
FindNativePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
bool
aCheckEnabled
)
{
if
(
aExtension
.
IsEmpty
(
)
)
{
return
nullptr
;
}
LoadPlugins
(
)
;
nsTArray
<
nsPluginTag
*
>
matchingPlugins
;
nsCString
matchingMime
;
nsPluginTag
*
plugin
=
mPlugins
;
while
(
plugin
)
{
if
(
!
aCheckEnabled
|
|
plugin
-
>
IsActive
(
)
)
{
if
(
plugin
-
>
HasExtension
(
aExtension
matchingMime
)
)
{
matchingPlugins
.
AppendElement
(
plugin
)
;
}
}
plugin
=
plugin
-
>
mNext
;
}
nsPluginTag
*
preferredPlugin
=
FindPreferredPlugin
(
matchingPlugins
)
;
if
(
!
preferredPlugin
)
{
return
nullptr
;
}
preferredPlugin
-
>
HasExtension
(
aExtension
aMimeType
)
;
return
preferredPlugin
;
}
static
nsresult
CreateNPAPIPlugin
(
nsPluginTag
*
aPluginTag
nsNPAPIPlugin
*
*
aOutNPAPIPlugin
)
{
nsresult
rv
;
rv
=
nsNPAPIPlugin
:
:
CreatePlugin
(
aPluginTag
aOutNPAPIPlugin
)
;
return
rv
;
}
nsresult
nsPluginHost
:
:
EnsurePluginLoaded
(
nsPluginTag
*
aPluginTag
)
{
RefPtr
<
nsNPAPIPlugin
>
plugin
=
aPluginTag
-
>
mPlugin
;
if
(
!
plugin
)
{
nsresult
rv
=
CreateNPAPIPlugin
(
aPluginTag
getter_AddRefs
(
plugin
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aPluginTag
-
>
mPlugin
=
plugin
;
}
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
GetPluginForContentProcess
(
uint32_t
aPluginId
nsNPAPIPlugin
*
*
aPlugin
)
{
AUTO_PROFILER_LABEL
(
"
nsPluginHost
:
:
GetPluginForContentProcess
"
OTHER
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
LoadPlugins
(
)
;
nsPluginTag
*
pluginTag
=
PluginWithId
(
aPluginId
)
;
if
(
pluginTag
)
{
if
(
pluginTag
-
>
IsBlocklisted
(
)
)
{
return
NS_ERROR_PLUGIN_BLOCKLISTED
;
}
nsresult
rv
=
EnsurePluginLoaded
(
pluginTag
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
pluginTag
-
>
mContentProcessRunningCount
+
+
;
NS_ADDREF
(
*
aPlugin
=
pluginTag
-
>
mPlugin
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
class
nsPluginUnloadRunnable
:
public
Runnable
{
public
:
explicit
nsPluginUnloadRunnable
(
uint32_t
aPluginId
)
:
Runnable
(
"
nsPluginUnloadRunnable
"
)
mPluginId
(
aPluginId
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
nsPluginHost
>
host
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
!
host
)
{
return
NS_OK
;
}
nsPluginTag
*
pluginTag
=
host
-
>
PluginWithId
(
mPluginId
)
;
if
(
!
pluginTag
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
pluginTag
-
>
mContentProcessRunningCount
>
0
)
;
pluginTag
-
>
mContentProcessRunningCount
-
-
;
if
(
!
pluginTag
-
>
mContentProcessRunningCount
)
{
if
(
!
host
-
>
IsRunningPlugin
(
pluginTag
)
)
{
pluginTag
-
>
TryUnloadPlugin
(
false
)
;
}
}
return
NS_OK
;
}
protected
:
uint32_t
mPluginId
;
}
;
void
nsPluginHost
:
:
NotifyContentModuleDestroyed
(
uint32_t
aPluginId
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
nsPluginUnloadRunnable
>
runnable
=
new
nsPluginUnloadRunnable
(
aPluginId
)
;
NS_DispatchToMainThread
(
runnable
)
;
}
nsresult
nsPluginHost
:
:
GetPlugin
(
const
nsACString
&
aMimeType
nsNPAPIPlugin
*
*
aPlugin
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
*
aPlugin
=
nullptr
;
LoadPlugins
(
)
;
nsPluginTag
*
pluginTag
=
FindNativePluginForType
(
aMimeType
true
)
;
if
(
pluginTag
)
{
rv
=
NS_OK
;
PLUGIN_LOG
(
PLUGIN_LOG_BASIC
(
"
nsPluginHost
:
:
GetPlugin
Begin
mime
=
%
s
plugin
=
%
s
\
n
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
pluginTag
-
>
FileName
(
)
.
get
(
)
)
)
;
#
ifdef
DEBUG
if
(
!
pluginTag
-
>
FileName
(
)
.
IsEmpty
(
)
)
printf
(
"
For
%
s
found
plugin
%
s
\
n
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
pluginTag
-
>
FileName
(
)
.
get
(
)
)
;
#
endif
rv
=
EnsurePluginLoaded
(
pluginTag
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
NS_ADDREF
(
*
aPlugin
=
pluginTag
-
>
mPlugin
)
;
return
NS_OK
;
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
GetPlugin
End
mime
=
%
s
rv
=
%
"
PRIu32
"
plugin
=
%
p
name
=
%
s
\
n
"
PromiseFlatCString
(
aMimeType
)
.
get
(
)
static_cast
<
uint32_t
>
(
rv
)
*
aPlugin
(
pluginTag
?
pluginTag
-
>
FileName
(
)
.
get
(
)
:
"
(
not
found
)
"
)
)
)
;
return
rv
;
}
nsresult
nsPluginHost
:
:
NormalizeHostname
(
nsCString
&
host
)
{
if
(
IsAscii
(
host
)
)
{
ToLowerCase
(
host
)
;
return
NS_OK
;
}
if
(
!
mIDNService
)
{
nsresult
rv
;
mIDNService
=
do_GetService
(
NS_IDNSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
mIDNService
-
>
ConvertUTF8toACE
(
host
host
)
;
}
nsresult
nsPluginHost
:
:
EnumerateSiteData
(
const
nsACString
&
domain
const
nsTArray
<
nsCString
>
&
sites
nsTArray
<
nsCString
>
&
result
bool
firstMatchOnly
)
{
NS_ASSERTION
(
!
domain
.
IsVoid
(
)
"
null
domain
string
"
)
;
nsresult
rv
;
if
(
!
mTLDService
)
{
mTLDService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCString
baseDomain
;
rv
=
mTLDService
-
>
GetBaseDomainFromHost
(
domain
0
baseDomain
)
;
bool
isIP
=
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
;
if
(
isIP
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
baseDomain
=
domain
;
rv
=
NormalizeHostname
(
baseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
uint32_t
i
=
0
;
i
<
sites
.
Length
(
)
;
+
+
i
)
{
const
nsCString
&
site
=
sites
[
i
]
;
bool
siteIsIP
=
site
.
Length
(
)
>
=
2
&
&
site
.
First
(
)
=
=
'
[
'
&
&
site
.
Last
(
)
=
=
'
]
'
;
if
(
siteIsIP
!
=
isIP
)
continue
;
nsCString
siteBaseDomain
;
if
(
siteIsIP
)
{
siteBaseDomain
=
Substring
(
site
1
site
.
Length
(
)
-
2
)
;
}
else
{
rv
=
mTLDService
-
>
GetBaseDomainFromHost
(
site
0
siteBaseDomain
)
;
if
(
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
siteBaseDomain
=
site
;
rv
=
NormalizeHostname
(
siteBaseDomain
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
baseDomain
!
=
siteBaseDomain
)
{
continue
;
}
result
.
AppendElement
(
site
)
;
if
(
firstMatchOnly
)
{
break
;
}
}
return
NS_OK
;
}
static
bool
MimeTypeIsAllowedForFakePlugin
(
const
nsString
&
aMimeType
)
{
static
const
char
*
const
allowedFakePlugins
[
]
=
{
"
application
/
x
-
shockwave
-
flash
"
"
application
/
pdf
"
"
application
/
vnd
.
adobe
.
pdf
"
"
application
/
vnd
.
adobe
.
pdfxml
"
"
application
/
vnd
.
adobe
.
x
-
mars
"
"
application
/
vnd
.
adobe
.
xdp
+
xml
"
"
application
/
vnd
.
adobe
.
xfdf
"
"
application
/
vnd
.
adobe
.
xfd
+
xml
"
"
application
/
vnd
.
fdf
"
}
;
for
(
const
auto
allowed
:
allowedFakePlugins
)
{
if
(
aMimeType
.
EqualsASCII
(
allowed
)
)
{
return
true
;
}
}
return
false
;
}
NS_IMETHODIMP
nsPluginHost
:
:
RegisterFakePlugin
(
JS
:
:
Handle
<
JS
:
:
Value
>
aInitDictionary
JSContext
*
aCx
nsIFakePluginTag
*
*
aResult
)
{
FakePluginTagInit
initDictionary
;
if
(
!
initDictionary
.
Init
(
aCx
aInitDictionary
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
const
FakePluginMimeEntry
&
mimeEntry
:
initDictionary
.
mMimeEntries
)
{
if
(
!
MimeTypeIsAllowedForFakePlugin
(
mimeEntry
.
mType
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
nsFakePluginTag
>
newTag
;
nsresult
rv
=
nsFakePluginTag
:
:
Create
(
initDictionary
getter_AddRefs
(
newTag
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
const
auto
&
existingTag
:
mFakePlugins
)
{
if
(
newTag
-
>
HandlerURIMatches
(
existingTag
-
>
HandlerURI
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
mFakePlugins
.
AppendElement
(
newTag
)
;
nsAutoCString
disableFullPage
;
Preferences
:
:
GetCString
(
kPrefDisableFullPage
disableFullPage
)
;
for
(
uint32_t
i
=
0
;
i
<
newTag
-
>
MimeTypes
(
)
.
Length
(
)
;
i
+
+
)
{
if
(
!
IsTypeInList
(
newTag
-
>
MimeTypes
(
)
[
i
]
disableFullPage
)
)
{
RegisterWithCategoryManager
(
newTag
-
>
MimeTypes
(
)
[
i
]
ePluginRegister
)
;
}
}
newTag
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginHost
:
:
CreateFakePlugin
(
JS
:
:
Handle
<
JS
:
:
Value
>
aInitDictionary
JSContext
*
aCx
nsIFakePluginTag
*
*
aResult
)
{
FakePluginTagInit
initDictionary
;
if
(
!
initDictionary
.
Init
(
aCx
aInitDictionary
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsFakePluginTag
>
newTag
;
nsresult
rv
=
nsFakePluginTag
:
:
Create
(
initDictionary
getter_AddRefs
(
newTag
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
newTag
.
forget
(
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginHost
:
:
UnregisterFakePlugin
(
const
nsACString
&
aHandlerURI
)
{
nsCOMPtr
<
nsIURI
>
handlerURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
handlerURI
)
aHandlerURI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
for
(
uint32_t
i
=
0
;
i
<
mFakePlugins
.
Length
(
)
;
+
+
i
)
{
if
(
mFakePlugins
[
i
]
-
>
HandlerURIMatches
(
handlerURI
)
)
{
mFakePlugins
.
RemoveElementAt
(
i
)
;
return
NS_OK
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetFakePlugin
(
const
nsACString
&
aMimeType
nsIFakePluginTag
*
*
aResult
)
{
RefPtr
<
nsFakePluginTag
>
result
=
FindFakePluginForType
(
aMimeType
false
)
;
if
(
result
)
{
result
.
forget
(
aResult
)
;
return
NS_OK
;
}
*
aResult
=
nullptr
;
return
NS_ERROR_NOT_AVAILABLE
;
}
#
define
ClearDataFromSitesClosure_CID
\
{
\
0x9fb21761
0x2403
0x41ad
{
\
0x9e
0xfd
0x36
0x7e
0xc4
0x4f
0xa4
0x5e
\
}
\
}
class
ClearDataFromSitesClosure
:
public
nsIClearSiteDataCallback
public
nsIGetSitesWithDataCallback
{
public
:
ClearDataFromSitesClosure
(
nsIPluginTag
*
plugin
const
nsACString
&
domain
uint64_t
flags
int64_t
maxAge
nsCOMPtr
<
nsIClearSiteDataCallback
>
callback
nsPluginHost
*
host
)
:
domain
(
domain
)
callback
(
callback
)
tag
(
plugin
)
flags
(
flags
)
maxAge
(
maxAge
)
host
(
host
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
Callback
(
nsresult
rv
)
override
{
if
(
NS_FAILED
(
rv
)
)
{
callback
-
>
Callback
(
rv
)
;
return
NS_OK
;
}
if
(
!
matches
.
Length
(
)
)
{
callback
-
>
Callback
(
NS_OK
)
;
return
NS_OK
;
}
const
nsCString
match
(
matches
[
0
]
)
;
matches
.
RemoveElement
(
match
)
;
PluginLibrary
*
library
=
static_cast
<
nsPluginTag
*
>
(
tag
)
-
>
mPlugin
-
>
GetLibrary
(
)
;
rv
=
library
-
>
NPP_ClearSiteData
(
match
.
get
(
)
flags
maxAge
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
callback
-
>
Callback
(
rv
)
;
return
NS_OK
;
}
return
NS_OK
;
}
NS_IMETHOD
SitesWithData
(
nsTArray
<
nsCString
>
&
sites
)
override
{
nsresult
rv
=
host
-
>
EnumerateSiteData
(
domain
sites
matches
false
)
;
Callback
(
rv
)
;
return
NS_OK
;
}
nsCString
domain
;
nsCOMPtr
<
nsIClearSiteDataCallback
>
callback
;
nsTArray
<
nsCString
>
matches
;
nsIPluginTag
*
tag
;
uint64_t
flags
;
int64_t
maxAge
;
nsPluginHost
*
host
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
ClearDataFromSitesClosure_CID
)
private
:
virtual
~
ClearDataFromSitesClosure
(
)
=
default
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
ClearDataFromSitesClosure
ClearDataFromSitesClosure_CID
)
NS_IMPL_ADDREF
(
ClearDataFromSitesClosure
)
NS_IMPL_RELEASE
(
ClearDataFromSitesClosure
)
NS_INTERFACE_MAP_BEGIN
(
ClearDataFromSitesClosure
)
NS_INTERFACE_MAP_ENTRY
(
nsIClearSiteDataCallback
)
NS_INTERFACE_MAP_ENTRY
(
nsIGetSitesWithDataCallback
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIClearSiteDataCallback
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP
nsPluginHost
:
:
ClearSiteData
(
nsIPluginTag
*
plugin
const
nsACString
&
domain
uint64_t
flags
int64_t
maxAge
nsIClearSiteDataCallback
*
callbackFunc
)
{
nsCOMPtr
<
nsIClearSiteDataCallback
>
callback
(
callbackFunc
)
;
NS_ENSURE_ARG
(
maxAge
>
=
0
|
|
maxAge
=
=
-
1
)
;
if
(
!
IsLiveTag
(
plugin
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsPluginTag
*
tag
=
static_cast
<
nsPluginTag
*
>
(
plugin
)
;
if
(
!
tag
-
>
IsEnabled
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
tag
-
>
mIsFlashPlugin
&
&
!
tag
-
>
mPlugin
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EnsurePluginLoaded
(
tag
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
PluginLibrary
*
library
=
tag
-
>
mPlugin
-
>
GetLibrary
(
)
;
if
(
domain
.
IsVoid
(
)
)
{
return
library
-
>
NPP_ClearSiteData
(
nullptr
flags
maxAge
callback
)
;
}
nsCOMPtr
<
nsIGetSitesWithDataCallback
>
closure
(
new
ClearDataFromSitesClosure
(
plugin
domain
flags
maxAge
callback
this
)
)
;
rv
=
library
-
>
NPP_GetSitesWithData
(
closure
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
#
define
GetSitesClosure_CID
\
{
\
0x4c9268ac
0x2fd1
0x4f2a
{
\
0x9a
0x10
0x7a
0x09
0xf1
0xb7
0x60
0x3a
\
}
\
}
class
GetSitesClosure
:
public
nsIGetSitesWithDataCallback
{
public
:
NS_DECL_ISUPPORTS
GetSitesClosure
(
const
nsACString
&
domain
nsPluginHost
*
host
)
:
domain
(
domain
)
host
(
host
)
result
{
false
}
keepWaiting
(
true
)
retVal
(
NS_ERROR_NOT_INITIALIZED
)
{
}
NS_IMETHOD
SitesWithData
(
nsTArray
<
nsCString
>
&
sites
)
override
{
retVal
=
HandleGetSites
(
sites
)
;
keepWaiting
=
false
;
return
NS_OK
;
}
nsresult
HandleGetSites
(
nsTArray
<
nsCString
>
&
sites
)
{
if
(
sites
.
IsEmpty
(
)
)
{
result
=
false
;
return
NS_OK
;
}
if
(
domain
.
IsVoid
(
)
)
{
result
=
true
;
return
NS_OK
;
}
nsTArray
<
nsCString
>
matches
;
nsresult
rv
=
host
-
>
EnumerateSiteData
(
domain
sites
matches
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
result
=
!
matches
.
IsEmpty
(
)
;
return
NS_OK
;
}
nsCString
domain
;
RefPtr
<
nsPluginHost
>
host
;
bool
result
;
bool
keepWaiting
;
nsresult
retVal
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
GetSitesClosure_CID
)
private
:
virtual
~
GetSitesClosure
(
)
=
default
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
GetSitesClosure
GetSitesClosure_CID
)
NS_IMPL_ISUPPORTS
(
GetSitesClosure
GetSitesClosure
nsIGetSitesWithDataCallback
)
NS_IMETHODIMP
nsPluginHost
:
:
SiteHasData
(
nsIPluginTag
*
plugin
const
nsACString
&
domain
bool
*
result
)
{
if
(
!
IsLiveTag
(
plugin
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsPluginTag
*
tag
=
static_cast
<
nsPluginTag
*
>
(
plugin
)
;
if
(
!
tag
-
>
mIsFlashPlugin
&
&
!
tag
-
>
mPlugin
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
EnsurePluginLoaded
(
tag
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
PluginLibrary
*
library
=
tag
-
>
mPlugin
-
>
GetLibrary
(
)
;
nsCOMPtr
<
GetSitesClosure
>
closure
(
new
GetSitesClosure
(
domain
this
)
)
;
rv
=
library
-
>
NPP_GetSitesWithData
(
nsCOMPtr
<
nsIGetSitesWithDataCallback
>
(
closure
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
!
closure
-
>
keepWaiting
;
}
)
;
*
result
=
closure
-
>
result
;
return
closure
-
>
retVal
;
}
nsPluginHost
:
:
SpecialType
nsPluginHost
:
:
GetSpecialType
(
const
nsACString
&
aMIMEType
)
{
if
(
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
x
-
test
"
)
)
{
return
eSpecialType_Test
;
}
if
(
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
x
-
shockwave
-
flash
"
)
|
|
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
futuresplash
"
)
|
|
aMIMEType
.
LowerCaseEqualsASCII
(
"
application
/
x
-
shockwave
-
flash
-
test
"
)
)
{
return
eSpecialType_Flash
;
}
return
eSpecialType_None
;
}
bool
nsPluginHost
:
:
IsLiveTag
(
nsIPluginTag
*
aPluginTag
)
{
nsCOMPtr
<
nsIInternalPluginTag
>
internalTag
(
do_QueryInterface
(
aPluginTag
)
)
;
uint32_t
fakeCount
=
mFakePlugins
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
fakeCount
;
i
+
+
)
{
if
(
mFakePlugins
[
i
]
=
=
internalTag
)
{
return
true
;
}
}
nsPluginTag
*
tag
;
for
(
tag
=
mPlugins
;
tag
;
tag
=
tag
-
>
mNext
)
{
if
(
tag
=
=
internalTag
)
{
return
true
;
}
}
return
false
;
}
nsPluginTag
*
nsPluginHost
:
:
HaveSamePlugin
(
const
nsPluginTag
*
aPluginTag
)
{
for
(
nsPluginTag
*
tag
=
mPlugins
;
tag
;
tag
=
tag
-
>
mNext
)
{
if
(
tag
-
>
HasSameNameAndMimes
(
aPluginTag
)
)
{
return
tag
;
}
}
return
nullptr
;
}
nsPluginTag
*
nsPluginHost
:
:
PluginWithId
(
uint32_t
aId
)
{
for
(
nsPluginTag
*
tag
=
mPlugins
;
tag
;
tag
=
tag
-
>
mNext
)
{
if
(
tag
-
>
mId
=
=
aId
)
{
return
tag
;
}
}
return
nullptr
;
}
void
nsPluginHost
:
:
AddPluginTag
(
nsPluginTag
*
aPluginTag
)
{
aPluginTag
-
>
mNext
=
mPlugins
;
mPlugins
=
aPluginTag
;
if
(
aPluginTag
-
>
IsActive
(
)
)
{
nsAutoCString
disableFullPage
;
Preferences
:
:
GetCString
(
kPrefDisableFullPage
disableFullPage
)
;
for
(
uint32_t
i
=
0
;
i
<
aPluginTag
-
>
MimeTypes
(
)
.
Length
(
)
;
i
+
+
)
{
if
(
!
IsTypeInList
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
disableFullPage
)
)
{
RegisterWithCategoryManager
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
ePluginRegister
)
;
}
}
}
}
typedef
NS_NPAPIPLUGIN_CALLBACK
(
char
*
NP_GETMIMEDESCRIPTION
)
(
void
)
;
void
nsPluginHost
:
:
UpdatePluginBlocklistState
(
nsPluginTag
*
aPluginTag
bool
aShouldSoftblock
)
{
nsCOMPtr
<
nsIBlocklistService
>
blocklist
=
do_GetService
(
"
mozilla
.
org
/
extensions
/
blocklist
;
1
"
)
;
MOZ_ASSERT
(
blocklist
"
Should
be
able
to
access
the
blocklist
"
)
;
if
(
!
blocklist
)
{
return
;
}
RefPtr
<
Promise
>
promise
;
blocklist
-
>
GetPluginBlocklistState
(
aPluginTag
EmptyString
(
)
EmptyString
(
)
getter_AddRefs
(
promise
)
)
;
MOZ_ASSERT
(
promise
"
Should
always
get
a
promise
for
plugin
blocklist
state
.
"
)
;
if
(
promise
)
{
promise
-
>
AppendNativeHandler
(
new
mozilla
:
:
plugins
:
:
BlocklistPromiseHandler
(
aPluginTag
aShouldSoftblock
)
)
;
}
}
void
nsPluginHost
:
:
IncrementChromeEpoch
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
mPluginEpoch
+
+
;
}
uint32_t
nsPluginHost
:
:
ChromeEpoch
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
mPluginEpoch
;
}
uint32_t
nsPluginHost
:
:
ChromeEpochForContent
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
return
mPluginEpoch
;
}
void
nsPluginHost
:
:
SetChromeEpochForContent
(
uint32_t
aEpoch
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
mPluginEpoch
=
aEpoch
;
}
#
ifdef
XP_WIN
static
void
WatchRegKey
(
uint32_t
aRoot
nsCOMPtr
<
nsIWindowsRegKey
>
&
aKey
)
{
if
(
aKey
)
{
return
;
}
aKey
=
do_CreateInstance
(
"
mozilla
.
org
/
windows
-
registry
-
key
;
1
"
)
;
if
(
!
aKey
)
{
return
;
}
nsresult
rv
=
aKey
-
>
Open
(
aRoot
NS_LITERAL_STRING
(
"
Software
\
\
MozillaPlugins
"
)
nsIWindowsRegKey
:
:
ACCESS_READ
|
nsIWindowsRegKey
:
:
ACCESS_NOTIFY
)
;
if
(
NS_FAILED
(
rv
)
)
{
aKey
=
nullptr
;
return
;
}
aKey
-
>
StartWatching
(
true
)
;
}
#
endif
already_AddRefed
<
nsIAsyncShutdownClient
>
GetProfileChangeTeardownPhase
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
asyncShutdownSvc
=
services
:
:
GetAsyncShutdown
(
)
;
MOZ_ASSERT
(
asyncShutdownSvc
)
;
if
(
NS_WARN_IF
(
!
asyncShutdownSvc
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
shutdownPhase
;
DebugOnly
<
nsresult
>
rv
=
asyncShutdownSvc
-
>
GetProfileChangeTeardown
(
getter_AddRefs
(
shutdownPhase
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
return
shutdownPhase
.
forget
(
)
;
}
nsresult
nsPluginHost
:
:
LoadPlugins
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
NS_OK
;
}
if
(
mPluginsLoaded
)
return
NS_OK
;
if
(
mPendingFinder
)
{
mDoReloadOnceFindingFinished
=
true
;
return
NS_OK
;
}
if
(
mPluginsDisabled
)
return
NS_OK
;
#
ifdef
XP_WIN
WatchRegKey
(
nsIWindowsRegKey
:
:
ROOT_KEY_LOCAL_MACHINE
mRegKeyHKLM
)
;
WatchRegKey
(
nsIWindowsRegKey
:
:
ROOT_KEY_CURRENT_USER
mRegKeyHKCU
)
;
#
endif
mPendingFinder
=
new
PluginFinder
(
mFlashOnly
)
;
mDoReloadOnceFindingFinished
=
false
;
mAddedFinderShutdownBlocker
=
false
;
RefPtr
<
nsPluginHost
>
self
=
this
;
nsresult
rv
=
mPendingFinder
-
>
DoFullSearch
(
[
self
]
(
bool
aPluginsChanged
RefPtr
<
nsPluginTag
>
aPlugins
const
nsTArray
<
std
:
:
pair
<
bool
RefPtr
<
nsPluginTag
>
>
>
&
aBlocklistRequests
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Callback
should
only
be
called
on
the
main
thread
.
"
)
;
self
-
>
mPluginsLoaded
=
true
;
if
(
aPluginsChanged
)
{
self
-
>
ClearNonRunningPlugins
(
)
;
while
(
aPlugins
)
{
RefPtr
<
nsPluginTag
>
pluginTag
=
aPlugins
;
aPlugins
=
aPlugins
-
>
mNext
;
self
-
>
AddPluginTag
(
pluginTag
)
;
}
self
-
>
IncrementChromeEpoch
(
)
;
self
-
>
BroadcastPluginsToContent
(
)
;
}
for
(
auto
pair
:
aBlocklistRequests
)
{
RefPtr
<
nsPluginTag
>
pluginTag
=
pair
.
second
;
bool
shouldSoftblock
=
pair
.
first
;
self
-
>
UpdatePluginBlocklistState
(
pluginTag
shouldSoftblock
)
;
}
if
(
aPluginsChanged
)
{
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
nullptr
"
plugins
-
list
-
updated
"
nullptr
)
;
}
}
}
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPendingFinder
=
nullptr
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
bool
dispatched
=
false
;
if
(
mFlashOnly
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
shutdownPhase
=
GetProfileChangeTeardownPhase
(
)
;
if
(
shutdownPhase
)
{
rv
=
shutdownPhase
-
>
AddBlocker
(
mPendingFinder
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
"
)
)
;
mAddedFinderShutdownBlocker
=
NS_SUCCEEDED
(
rv
)
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
target
-
>
Dispatch
(
mPendingFinder
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
dispatched
=
NS_SUCCEEDED
(
rv
)
;
}
if
(
mAddedFinderShutdownBlocker
&
&
!
dispatched
)
{
shutdownPhase
-
>
RemoveBlocker
(
mPendingFinder
)
;
mAddedFinderShutdownBlocker
=
false
;
}
}
if
(
!
dispatched
)
{
mPendingFinder
-
>
Run
(
)
;
mPendingFinder
=
nullptr
;
}
return
NS_OK
;
}
void
nsPluginHost
:
:
FindingFinished
(
)
{
if
(
mAddedFinderShutdownBlocker
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
shutdownPhase
=
GetProfileChangeTeardownPhase
(
)
;
shutdownPhase
-
>
RemoveBlocker
(
mPendingFinder
)
;
mAddedFinderShutdownBlocker
=
false
;
}
mPendingFinder
=
nullptr
;
if
(
mDoReloadOnceFindingFinished
)
{
Unused
<
<
ReloadPlugins
(
)
;
}
}
nsresult
nsPluginHost
:
:
SetPluginsInContent
(
uint32_t
aPluginEpoch
nsTArray
<
mozilla
:
:
plugins
:
:
PluginTag
>
&
aPlugins
nsTArray
<
mozilla
:
:
plugins
:
:
FakePluginTag
>
&
aFakePlugins
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
nsTArray
<
PluginTag
>
plugins
;
nsTArray
<
FakePluginTag
>
fakePlugins
;
if
(
aPluginEpoch
!
=
ChromeEpochForContent
(
)
)
{
ClearNonRunningPlugins
(
)
;
SetChromeEpochForContent
(
aPluginEpoch
)
;
for
(
auto
tag
:
aPlugins
)
{
if
(
nsPluginTag
*
existing
=
PluginWithId
(
tag
.
id
(
)
)
)
{
UpdateInMemoryPluginInfo
(
existing
)
;
existing
-
>
SetBlocklistState
(
tag
.
blocklistState
(
)
)
;
continue
;
}
nsPluginTag
*
pluginTag
=
new
nsPluginTag
(
tag
.
id
(
)
tag
.
name
(
)
.
get
(
)
tag
.
description
(
)
.
get
(
)
tag
.
filename
(
)
.
get
(
)
"
"
tag
.
version
(
)
.
get
(
)
nsTArray
<
nsCString
>
(
tag
.
mimeTypes
(
)
)
nsTArray
<
nsCString
>
(
tag
.
mimeDescriptions
(
)
)
nsTArray
<
nsCString
>
(
tag
.
extensions
(
)
)
tag
.
isFlashPlugin
(
)
tag
.
supportsAsyncRender
(
)
tag
.
lastModifiedTime
(
)
tag
.
sandboxLevel
(
)
tag
.
blocklistState
(
)
)
;
AddPluginTag
(
pluginTag
)
;
}
for
(
const
auto
&
tag
:
aFakePlugins
)
{
for
(
const
auto
&
existingTag
:
mFakePlugins
)
{
if
(
existingTag
-
>
Id
(
)
=
=
tag
.
id
(
)
)
{
continue
;
}
}
RefPtr
<
nsFakePluginTag
>
pluginTag
=
*
mFakePlugins
.
AppendElement
(
new
nsFakePluginTag
(
tag
.
id
(
)
mozilla
:
:
ipc
:
:
DeserializeURI
(
tag
.
handlerURI
(
)
)
tag
.
name
(
)
.
get
(
)
tag
.
description
(
)
.
get
(
)
tag
.
mimeTypes
(
)
tag
.
mimeDescriptions
(
)
tag
.
extensions
(
)
tag
.
niceName
(
)
tag
.
sandboxScript
(
)
)
)
;
nsAutoCString
disableFullPage
;
Preferences
:
:
GetCString
(
kPrefDisableFullPage
disableFullPage
)
;
for
(
uint32_t
i
=
0
;
i
<
pluginTag
-
>
MimeTypes
(
)
.
Length
(
)
;
i
+
+
)
{
if
(
!
IsTypeInList
(
pluginTag
-
>
MimeTypes
(
)
[
i
]
disableFullPage
)
)
{
RegisterWithCategoryManager
(
pluginTag
-
>
MimeTypes
(
)
[
i
]
ePluginRegister
)
;
}
}
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
nullptr
"
plugins
-
list
-
updated
"
nullptr
)
;
}
}
mPluginsLoaded
=
true
;
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
UpdateCachedSerializablePluginList
(
)
{
nsTArray
<
nsCOMPtr
<
nsIInternalPluginTag
>
>
plugins
;
GetPlugins
(
plugins
true
)
;
mSerializablePlugins
.
Clear
(
)
;
mSerializableFakePlugins
.
Clear
(
)
;
for
(
size_t
i
=
0
;
i
<
plugins
.
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIInternalPluginTag
>
basetag
=
plugins
[
i
]
;
nsCOMPtr
<
nsIFakePluginTag
>
faketag
=
do_QueryInterface
(
basetag
)
;
if
(
faketag
)
{
nsFakePluginTag
*
tag
=
static_cast
<
nsFakePluginTag
*
>
(
basetag
.
get
(
)
)
;
mozilla
:
:
ipc
:
:
URIParams
handlerURI
;
SerializeURI
(
tag
-
>
HandlerURI
(
)
handlerURI
)
;
mSerializableFakePlugins
.
AppendElement
(
FakePluginTag
(
tag
-
>
Id
(
)
handlerURI
tag
-
>
Name
(
)
tag
-
>
Description
(
)
tag
-
>
MimeTypes
(
)
tag
-
>
MimeDescriptions
(
)
tag
-
>
Extensions
(
)
tag
-
>
GetNiceFileName
(
)
tag
-
>
SandboxScript
(
)
)
)
;
continue
;
}
nsPluginTag
*
tag
=
static_cast
<
nsPluginTag
*
>
(
basetag
.
get
(
)
)
;
uint32_t
blocklistState
;
if
(
NS_WARN_IF
(
NS_FAILED
(
tag
-
>
GetBlocklistState
(
&
blocklistState
)
)
)
)
{
return
NS_ERROR_FAILURE
;
}
mSerializablePlugins
.
AppendElement
(
PluginTag
(
tag
-
>
mId
tag
-
>
Name
(
)
tag
-
>
Description
(
)
tag
-
>
MimeTypes
(
)
tag
-
>
MimeDescriptions
(
)
tag
-
>
Extensions
(
)
tag
-
>
mIsFlashPlugin
tag
-
>
mSupportsAsyncRender
tag
-
>
FileName
(
)
tag
-
>
Version
(
)
tag
-
>
mLastModifiedTime
tag
-
>
mSandboxLevel
blocklistState
)
)
;
}
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
BroadcastPluginsToContent
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsresult
rv
=
LoadPlugins
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
UpdateCachedSerializablePluginList
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
newPluginEpoch
=
ChromeEpoch
(
)
;
nsTArray
<
dom
:
:
ContentParent
*
>
parents
;
dom
:
:
ContentParent
:
:
GetAll
(
parents
)
;
for
(
auto
p
:
parents
)
{
Unused
<
<
p
-
>
SendSetPluginList
(
newPluginEpoch
mSerializablePlugins
mSerializableFakePlugins
)
;
}
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
SendPluginsToContent
(
dom
:
:
ContentParent
*
parent
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
parent
)
;
nsresult
rv
=
LoadPlugins
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Unused
<
<
parent
-
>
SendSetPluginList
(
ChromeEpoch
(
)
mSerializablePlugins
mSerializableFakePlugins
)
;
return
NS_OK
;
}
void
nsPluginHost
:
:
UpdateInMemoryPluginInfo
(
nsPluginTag
*
aPluginTag
)
{
if
(
!
aPluginTag
)
{
return
;
}
nsAutoCString
disableFullPage
;
Preferences
:
:
GetCString
(
kPrefDisableFullPage
disableFullPage
)
;
for
(
uint32_t
i
=
0
;
i
<
aPluginTag
-
>
MimeTypes
(
)
.
Length
(
)
;
i
+
+
)
{
nsRegisterType
shouldRegister
;
if
(
IsTypeInList
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
disableFullPage
)
)
{
shouldRegister
=
ePluginUnregister
;
}
else
{
nsPluginTag
*
plugin
=
FindNativePluginForType
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
true
)
;
shouldRegister
=
plugin
?
ePluginRegister
:
ePluginUnregister
;
}
RegisterWithCategoryManager
(
aPluginTag
-
>
MimeTypes
(
)
[
i
]
shouldRegister
)
;
}
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
obsService
-
>
NotifyObservers
(
nullptr
"
plugin
-
info
-
updated
"
nullptr
)
;
}
void
nsPluginHost
:
:
UpdatePluginInfo
(
nsPluginTag
*
aPluginTag
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
IncrementChromeEpoch
(
)
;
UpdateInMemoryPluginInfo
(
aPluginTag
)
;
}
void
nsPluginHost
:
:
RegisterWithCategoryManager
(
const
nsCString
&
aMimeType
nsRegisterType
aType
)
{
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginTag
:
:
RegisterWithCategoryManager
type
=
%
s
removing
=
%
s
\
n
"
aMimeType
.
get
(
)
aType
=
=
ePluginUnregister
?
"
yes
"
:
"
no
"
)
)
;
nsCOMPtr
<
nsICategoryManager
>
catMan
=
do_GetService
(
NS_CATEGORYMANAGER_CONTRACTID
)
;
if
(
!
catMan
)
{
return
;
}
NS_NAMED_LITERAL_CSTRING
(
contractId
"
mozilla
.
org
/
content
/
plugin
/
document
-
loader
-
factory
;
1
"
)
;
if
(
aType
=
=
ePluginRegister
)
{
catMan
-
>
AddCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
aMimeType
contractId
false
mOverrideInternalTypes
)
;
}
else
{
if
(
aType
=
=
ePluginMaybeUnregister
)
{
if
(
HavePluginForType
(
aMimeType
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
aType
=
=
ePluginUnregister
"
Unknown
nsRegisterType
"
)
;
}
nsCString
value
;
nsresult
rv
=
catMan
-
>
GetCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
aMimeType
value
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
value
=
=
contractId
)
{
catMan
-
>
DeleteCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
aMimeType
true
)
;
}
}
}
nsresult
nsPluginHost
:
:
NewPluginURLStream
(
const
nsString
&
aURL
nsNPAPIPluginInstance
*
aInstance
nsNPAPIPluginStreamListener
*
aListener
nsIInputStream
*
aPostStream
const
char
*
aHeadersData
uint32_t
aHeadersDataLen
)
{
nsCOMPtr
<
nsIURI
>
url
;
nsAutoString
absUrl
;
if
(
aURL
.
Length
(
)
<
=
0
)
return
NS_OK
;
RefPtr
<
nsPluginInstanceOwner
>
owner
=
aInstance
-
>
GetOwner
(
)
;
if
(
owner
)
{
NS_MakeAbsoluteURI
(
absUrl
aURL
owner
-
>
GetBaseURI
(
)
)
;
}
if
(
absUrl
.
IsEmpty
(
)
)
absUrl
.
Assign
(
aURL
)
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
url
)
absUrl
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsPluginStreamListenerPeer
>
listenerPeer
=
new
nsPluginStreamListenerPeer
(
)
;
NS_ENSURE_TRUE
(
listenerPeer
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
listenerPeer
-
>
Initialize
(
url
aInstance
aListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
dom
:
:
Element
>
element
;
nsCOMPtr
<
Document
>
doc
;
if
(
owner
)
{
owner
-
>
GetDOMElement
(
getter_AddRefs
(
element
)
)
;
owner
-
>
GetDocument
(
getter_AddRefs
(
doc
)
)
;
}
NS_ENSURE_TRUE
(
element
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
url
element
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
|
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
nsIContentPolicy
:
:
TYPE_OBJECT_SUBREQUEST
nullptr
nullptr
listenerPeer
nsIRequest
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
doc
)
{
nsCOMPtr
<
nsIScriptChannel
>
scriptChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
scriptChannel
)
{
scriptChannel
-
>
SetExecutionPolicy
(
nsIScriptChannel
:
:
EXECUTE_NORMAL
)
;
scriptChannel
-
>
SetExecuteAsync
(
false
)
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
if
(
!
aPostStream
)
{
nsCOMPtr
<
nsIURI
>
referer
;
dom
:
:
ReferrerPolicy
referrerPolicy
=
dom
:
:
ReferrerPolicy
:
:
_empty
;
nsCOMPtr
<
nsIObjectLoadingContent
>
olc
=
do_QueryInterface
(
element
)
;
if
(
olc
)
olc
-
>
GetSrcURI
(
getter_AddRefs
(
referer
)
)
;
if
(
!
referer
)
{
if
(
!
doc
)
{
return
NS_ERROR_FAILURE
;
}
referer
=
doc
-
>
GetDocumentURIAsReferrer
(
)
;
referrerPolicy
=
doc
-
>
GetReferrerPolicy
(
)
;
}
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
dom
:
:
ReferrerInfo
(
referer
referrerPolicy
)
;
rv
=
httpChannel
-
>
SetReferrerInfoWithoutClone
(
referrerInfo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
aPostStream
)
{
nsCOMPtr
<
nsISeekableStream
>
postDataSeekable
(
do_QueryInterface
(
aPostStream
)
)
;
if
(
postDataSeekable
)
postDataSeekable
-
>
Seek
(
nsISeekableStream
:
:
NS_SEEK_SET
0
)
;
nsCOMPtr
<
nsIUploadChannel
>
uploadChannel
(
do_QueryInterface
(
httpChannel
)
)
;
NS_ASSERTION
(
uploadChannel
"
http
must
support
nsIUploadChannel
"
)
;
uploadChannel
-
>
SetUploadStream
(
aPostStream
EmptyCString
(
)
-
1
)
;
}
if
(
aHeadersData
)
{
rv
=
AddHeadersToChannel
(
aHeadersData
aHeadersDataLen
httpChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
rv
=
channel
-
>
AsyncOpen
(
listenerPeer
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
listenerPeer
-
>
TrackRequest
(
channel
)
;
return
rv
;
}
nsresult
nsPluginHost
:
:
AddHeadersToChannel
(
const
char
*
aHeadersData
uint32_t
aHeadersDataLen
nsIChannel
*
aGenericChannel
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIHttpChannel
>
aChannel
=
do_QueryInterface
(
aGenericChannel
)
;
if
(
!
aChannel
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsAutoCString
headersString
;
nsAutoCString
oneHeader
;
nsAutoCString
headerName
;
nsAutoCString
headerValue
;
int32_t
crlf
=
0
;
int32_t
colon
=
0
;
headersString
=
aHeadersData
;
while
(
true
)
{
crlf
=
headersString
.
Find
(
"
\
r
\
n
"
true
)
;
if
(
-
1
=
=
crlf
)
{
rv
=
NS_OK
;
return
rv
;
}
headersString
.
Mid
(
oneHeader
0
crlf
)
;
headersString
.
Cut
(
0
crlf
+
2
)
;
oneHeader
.
StripWhitespace
(
)
;
colon
=
oneHeader
.
Find
(
"
:
"
)
;
if
(
-
1
=
=
colon
)
{
rv
=
NS_ERROR_NULL_POINTER
;
return
rv
;
}
oneHeader
.
Left
(
headerName
colon
)
;
colon
+
+
;
oneHeader
.
Mid
(
headerValue
colon
oneHeader
.
Length
(
)
-
colon
)
;
rv
=
aChannel
-
>
SetRequestHeader
(
headerName
headerValue
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_ERROR_NULL_POINTER
;
return
rv
;
}
}
}
nsresult
nsPluginHost
:
:
StopPluginInstance
(
nsNPAPIPluginInstance
*
aInstance
)
{
AUTO_PROFILER_LABEL
(
"
nsPluginHost
:
:
StopPluginInstance
"
OTHER
)
;
if
(
PluginDestructionGuard
:
:
DelayDestroy
(
aInstance
)
)
{
return
NS_OK
;
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
nsPluginHost
:
:
StopPluginInstance
called
instance
=
%
p
\
n
"
aInstance
)
)
;
if
(
aInstance
-
>
HasStartedDestroying
(
)
)
{
return
NS_OK
;
}
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
PLUGIN_SHUTDOWN_MS
>
timer
;
aInstance
-
>
Stop
(
)
;
bool
doCache
=
aInstance
-
>
ShouldCache
(
)
;
if
(
doCache
)
{
uint32_t
cachedInstanceLimit
=
Preferences
:
:
GetUint
(
NS_PREF_MAX_NUM_CACHED_INSTANCES
DEFAULT_NUMBER_OF_STOPPED_INSTANCES
)
;
if
(
StoppedInstanceCount
(
)
>
=
cachedInstanceLimit
)
{
nsNPAPIPluginInstance
*
oldestInstance
=
FindOldestStoppedInstance
(
)
;
if
(
oldestInstance
)
{
nsPluginTag
*
pluginTag
=
TagForPlugin
(
oldestInstance
-
>
GetPlugin
(
)
)
;
oldestInstance
-
>
Destroy
(
)
;
mInstances
.
RemoveElement
(
oldestInstance
)
;
if
(
pluginTag
)
{
OnPluginInstanceDestroyed
(
pluginTag
)
;
}
}
}
}
else
{
nsPluginTag
*
pluginTag
=
TagForPlugin
(
aInstance
-
>
GetPlugin
(
)
)
;
aInstance
-
>
Destroy
(
)
;
mInstances
.
RemoveElement
(
aInstance
)
;
if
(
pluginTag
)
{
OnPluginInstanceDestroyed
(
pluginTag
)
;
}
}
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
NewPluginStreamListener
(
nsIURI
*
aURI
nsNPAPIPluginInstance
*
aInstance
nsIStreamListener
*
*
aStreamListener
)
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
NS_ENSURE_ARG_POINTER
(
aStreamListener
)
;
RefPtr
<
nsPluginStreamListenerPeer
>
listener
=
new
nsPluginStreamListenerPeer
(
)
;
nsresult
rv
=
listener
-
>
Initialize
(
aURI
aInstance
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
listener
.
forget
(
aStreamListener
)
;
return
NS_OK
;
}
void
nsPluginHost
:
:
CreateWidget
(
nsPluginInstanceOwner
*
aOwner
)
{
aOwner
-
>
CreateWidget
(
)
;
aOwner
-
>
CallSetWindow
(
)
;
}
NS_IMETHODIMP
nsPluginHost
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
someData
)
{
if
(
!
strcmp
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
aTopic
)
)
{
UnloadPlugins
(
)
;
}
if
(
!
strcmp
(
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
aTopic
)
)
{
mPluginsDisabled
=
Preferences
:
:
GetBool
(
"
plugin
.
disable
"
false
)
;
if
(
mPluginsDisabled
)
{
UnloadPlugins
(
)
;
}
else
{
LoadPlugins
(
)
;
}
}
if
(
XRE_IsParentProcess
(
)
&
&
!
strcmp
(
"
plugin
-
blocklist
-
updated
"
aTopic
)
)
{
nsPluginTag
*
plugin
=
mPlugins
;
while
(
plugin
)
{
UpdatePluginBlocklistState
(
plugin
)
;
plugin
=
plugin
-
>
mNext
;
}
}
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
ParsePostBufferToFixHeaders
(
const
char
*
inPostData
uint32_t
inPostDataLen
char
*
*
outPostData
uint32_t
*
outPostDataLen
)
{
if
(
!
inPostData
|
|
!
outPostData
|
|
!
outPostDataLen
)
return
NS_ERROR_NULL_POINTER
;
*
outPostData
=
0
;
*
outPostDataLen
=
0
;
const
char
CR
=
'
\
r
'
;
const
char
LF
=
'
\
n
'
;
const
char
CRLFCRLF
[
]
=
{
CR
LF
CR
LF
'
\
0
'
}
;
const
char
ContentLenHeader
[
]
=
"
Content
-
length
"
;
AutoTArray
<
const
char
*
8
>
singleLF
;
const
char
*
pSCntlh
=
0
;
const
char
*
pSod
=
0
;
const
char
*
pEoh
=
0
;
const
char
*
pEod
=
inPostData
+
inPostDataLen
;
if
(
*
inPostData
=
=
LF
)
{
pSod
=
inPostData
+
1
;
}
else
{
const
char
*
s
=
inPostData
;
while
(
s
<
pEod
)
{
if
(
!
pSCntlh
&
&
(
*
s
=
=
'
C
'
|
|
*
s
=
=
'
c
'
)
&
&
(
s
+
sizeof
(
ContentLenHeader
)
-
1
<
pEod
)
&
&
(
!
PL_strncasecmp
(
s
ContentLenHeader
sizeof
(
ContentLenHeader
)
-
1
)
)
)
{
const
char
*
p
=
pSCntlh
=
s
;
p
+
=
sizeof
(
ContentLenHeader
)
-
1
;
for
(
;
p
<
pEod
;
p
+
+
)
{
if
(
*
p
=
=
CR
|
|
*
p
=
=
LF
)
{
if
(
*
(
p
-
1
)
>
=
'
0
'
&
&
*
(
p
-
1
)
<
=
'
9
'
)
{
s
=
p
;
}
break
;
}
}
if
(
pSCntlh
=
=
s
)
{
pSCntlh
=
0
;
break
;
}
}
if
(
*
s
=
=
CR
)
{
if
(
pSCntlh
&
&
(
(
s
+
sizeof
(
CRLFCRLF
)
-
1
)
<
=
pEod
)
&
&
!
memcmp
(
s
CRLFCRLF
sizeof
(
CRLFCRLF
)
-
1
)
)
{
s
+
=
sizeof
(
CRLFCRLF
)
-
1
;
pEoh
=
pSod
=
s
;
break
;
}
}
else
if
(
*
s
=
=
LF
)
{
if
(
*
(
s
-
1
)
!
=
CR
)
{
singleLF
.
AppendElement
(
s
)
;
}
if
(
pSCntlh
&
&
(
s
+
1
<
pEod
)
&
&
(
*
(
s
+
1
)
=
=
LF
)
)
{
s
+
+
;
singleLF
.
AppendElement
(
s
)
;
s
+
+
;
pEoh
=
pSod
=
s
;
break
;
}
}
s
+
+
;
}
}
if
(
!
pSod
)
{
pSod
=
inPostData
;
}
uint32_t
newBufferLen
=
0
;
uint32_t
dataLen
=
pEod
-
pSod
;
uint32_t
headersLen
=
pEoh
?
pSod
-
inPostData
:
0
;
char
*
p
;
if
(
headersLen
)
{
newBufferLen
=
dataLen
+
headersLen
;
int
cntSingleLF
=
singleLF
.
Length
(
)
;
newBufferLen
+
=
cntSingleLF
;
*
outPostData
=
p
=
(
char
*
)
moz_xmalloc
(
newBufferLen
)
;
const
char
*
s
=
inPostData
;
if
(
cntSingleLF
)
{
for
(
int
i
=
0
;
i
<
cntSingleLF
;
i
+
+
)
{
const
char
*
plf
=
singleLF
.
ElementAt
(
i
)
;
int
n
=
plf
-
s
;
if
(
n
)
{
memcpy
(
p
s
n
)
;
p
+
=
n
;
}
*
p
+
+
=
CR
;
s
=
plf
;
*
p
+
+
=
*
s
+
+
;
}
}
headersLen
=
pEoh
-
s
;
if
(
headersLen
)
{
memcpy
(
p
s
headersLen
)
;
p
+
=
headersLen
;
}
}
else
if
(
dataLen
)
{
uint32_t
l
=
sizeof
(
ContentLenHeader
)
+
sizeof
(
CRLFCRLF
)
+
32
;
newBufferLen
=
dataLen
+
l
;
*
outPostData
=
p
=
(
char
*
)
moz_xmalloc
(
newBufferLen
)
;
headersLen
=
snprintf
(
p
l
"
%
s
:
%
u
%
s
"
ContentLenHeader
dataLen
CRLFCRLF
)
;
if
(
headersLen
=
=
l
)
{
free
(
p
)
;
*
outPostData
=
0
;
return
NS_ERROR_FAILURE
;
}
p
+
=
headersLen
;
newBufferLen
=
headersLen
+
dataLen
;
}
if
(
dataLen
)
{
memcpy
(
p
pSod
dataLen
)
;
}
*
outPostDataLen
=
newBufferLen
;
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
NewPluginNativeWindow
(
nsPluginNativeWindow
*
*
aPluginNativeWindow
)
{
return
PLUG_NewPluginNativeWindow
(
aPluginNativeWindow
)
;
}
nsresult
nsPluginHost
:
:
GetPluginName
(
nsNPAPIPluginInstance
*
aPluginInstance
const
char
*
*
aPluginName
)
{
nsNPAPIPluginInstance
*
instance
=
static_cast
<
nsNPAPIPluginInstance
*
>
(
aPluginInstance
)
;
if
(
!
instance
)
return
NS_ERROR_FAILURE
;
nsNPAPIPlugin
*
plugin
=
instance
-
>
GetPlugin
(
)
;
if
(
!
plugin
)
return
NS_ERROR_FAILURE
;
*
aPluginName
=
TagForPlugin
(
plugin
)
-
>
Name
(
)
.
get
(
)
;
return
NS_OK
;
}
nsresult
nsPluginHost
:
:
GetPluginTagForInstance
(
nsNPAPIPluginInstance
*
aPluginInstance
nsIPluginTag
*
*
aPluginTag
)
{
NS_ENSURE_ARG_POINTER
(
aPluginInstance
)
;
NS_ENSURE_ARG_POINTER
(
aPluginTag
)
;
nsNPAPIPlugin
*
plugin
=
aPluginInstance
-
>
GetPlugin
(
)
;
if
(
!
plugin
)
return
NS_ERROR_FAILURE
;
*
aPluginTag
=
TagForPlugin
(
plugin
)
;
NS_ADDREF
(
*
aPluginTag
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsPluginHost
:
:
Notify
(
nsITimer
*
timer
)
{
RefPtr
<
nsPluginTag
>
pluginTag
=
mPlugins
;
while
(
pluginTag
)
{
if
(
pluginTag
-
>
mUnloadTimer
=
=
timer
)
{
if
(
!
IsRunningPlugin
(
pluginTag
)
)
{
pluginTag
-
>
TryUnloadPlugin
(
false
)
;
}
return
NS_OK
;
}
pluginTag
=
pluginTag
-
>
mNext
;
}
return
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsPluginHost
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
nsPluginHost
"
)
;
return
NS_OK
;
}
#
ifdef
XP_WIN
static
void
CheckForDisabledWindows
(
)
{
nsCOMPtr
<
nsIWindowMediator
>
wm
(
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
)
;
if
(
!
wm
)
return
;
nsCOMPtr
<
nsISimpleEnumerator
>
windowList
;
wm
-
>
GetAppWindowEnumerator
(
nullptr
getter_AddRefs
(
windowList
)
)
;
if
(
!
windowList
)
return
;
bool
haveWindows
;
do
{
windowList
-
>
HasMoreElements
(
&
haveWindows
)
;
if
(
!
haveWindows
)
return
;
nsCOMPtr
<
nsISupports
>
supportsWindow
;
windowList
-
>
GetNext
(
getter_AddRefs
(
supportsWindow
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWin
(
do_QueryInterface
(
supportsWindow
)
)
;
if
(
baseWin
)
{
nsCOMPtr
<
nsIWidget
>
widget
;
baseWin
-
>
GetMainWidget
(
getter_AddRefs
(
widget
)
)
;
if
(
widget
&
&
!
widget
-
>
GetParent
(
)
&
&
widget
-
>
IsVisible
(
)
&
&
!
widget
-
>
IsEnabled
(
)
)
{
nsIWidget
*
child
=
widget
-
>
GetFirstChild
(
)
;
bool
enable
=
true
;
while
(
child
)
{
if
(
child
-
>
WindowType
(
)
=
=
eWindowType_dialog
)
{
enable
=
false
;
break
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
if
(
enable
)
{
widget
-
>
Enable
(
true
)
;
}
}
}
}
while
(
haveWindows
)
;
}
#
endif
void
nsPluginHost
:
:
PluginCrashed
(
nsNPAPIPlugin
*
aPlugin
const
nsAString
&
aPluginDumpID
const
nsACString
&
aAdditionalMinidumps
)
{
nsPluginTag
*
crashedPluginTag
=
TagForPlugin
(
aPlugin
)
;
MOZ_ASSERT
(
crashedPluginTag
)
;
bool
submittedCrashReport
=
false
;
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
nsCOMPtr
<
nsIWritablePropertyBag2
>
propbag
=
do_CreateInstance
(
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
)
;
if
(
obsService
&
&
propbag
)
{
uint32_t
runID
=
0
;
PluginLibrary
*
library
=
aPlugin
-
>
GetLibrary
(
)
;
if
(
!
NS_WARN_IF
(
!
library
)
)
{
library
-
>
GetRunID
(
&
runID
)
;
}
propbag
-
>
SetPropertyAsUint32
(
NS_LITERAL_STRING
(
"
runID
"
)
runID
)
;
nsCString
pluginName
;
crashedPluginTag
-
>
GetName
(
pluginName
)
;
propbag
-
>
SetPropertyAsAString
(
NS_LITERAL_STRING
(
"
pluginName
"
)
NS_ConvertUTF8toUTF16
(
pluginName
)
)
;
propbag
-
>
SetPropertyAsAString
(
NS_LITERAL_STRING
(
"
pluginDumpID
"
)
aPluginDumpID
)
;
propbag
-
>
SetPropertyAsACString
(
NS_LITERAL_STRING
(
"
additionalMinidumps
"
)
aAdditionalMinidumps
)
;
propbag
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
submittedCrashReport
"
)
submittedCrashReport
)
;
obsService
-
>
NotifyObservers
(
propbag
"
plugin
-
crashed
"
nullptr
)
;
propbag
-
>
GetPropertyAsBool
(
NS_LITERAL_STRING
(
"
submittedCrashReport
"
)
&
submittedCrashReport
)
;
}
for
(
uint32_t
i
=
mInstances
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
-
1
]
;
if
(
instance
-
>
GetPlugin
(
)
=
=
aPlugin
)
{
RefPtr
<
dom
:
:
Element
>
domElement
;
instance
-
>
GetDOMElement
(
getter_AddRefs
(
domElement
)
)
;
nsCOMPtr
<
nsIObjectLoadingContent
>
objectContent
(
do_QueryInterface
(
domElement
)
)
;
if
(
objectContent
)
{
objectContent
-
>
PluginCrashed
(
crashedPluginTag
aPluginDumpID
submittedCrashReport
)
;
}
instance
-
>
Destroy
(
)
;
mInstances
.
RemoveElement
(
instance
)
;
OnPluginInstanceDestroyed
(
crashedPluginTag
)
;
}
}
crashedPluginTag
-
>
mPlugin
=
nullptr
;
crashedPluginTag
-
>
mContentProcessRunningCount
=
0
;
#
ifdef
XP_WIN
CheckForDisabledWindows
(
)
;
#
endif
}
nsNPAPIPluginInstance
*
nsPluginHost
:
:
FindInstance
(
const
char
*
mimetype
)
{
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
]
;
const
char
*
mt
;
nsresult
rv
=
instance
-
>
GetMIMEType
(
&
mt
)
;
if
(
NS_FAILED
(
rv
)
)
continue
;
if
(
PL_strcasecmp
(
mt
mimetype
)
=
=
0
)
return
instance
;
}
return
nullptr
;
}
nsNPAPIPluginInstance
*
nsPluginHost
:
:
FindOldestStoppedInstance
(
)
{
nsNPAPIPluginInstance
*
oldestInstance
=
nullptr
;
TimeStamp
oldestTime
=
TimeStamp
:
:
Now
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
]
;
if
(
instance
-
>
IsRunning
(
)
)
continue
;
TimeStamp
time
=
instance
-
>
StopTime
(
)
;
if
(
time
<
oldestTime
)
{
oldestTime
=
time
;
oldestInstance
=
instance
;
}
}
return
oldestInstance
;
}
uint32_t
nsPluginHost
:
:
StoppedInstanceCount
(
)
{
uint32_t
stoppedCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mInstances
.
Length
(
)
;
i
+
+
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
]
;
if
(
!
instance
-
>
IsRunning
(
)
)
stoppedCount
+
+
;
}
return
stoppedCount
;
}
nsTArray
<
RefPtr
<
nsNPAPIPluginInstance
>
>
*
nsPluginHost
:
:
InstanceArray
(
)
{
return
&
mInstances
;
}
void
nsPluginHost
:
:
DestroyRunningInstances
(
nsPluginTag
*
aPluginTag
)
{
for
(
int32_t
i
=
mInstances
.
Length
(
)
;
i
>
0
;
i
-
-
)
{
nsNPAPIPluginInstance
*
instance
=
mInstances
[
i
-
1
]
;
if
(
instance
-
>
IsRunning
(
)
&
&
(
!
aPluginTag
|
|
aPluginTag
=
=
TagForPlugin
(
instance
-
>
GetPlugin
(
)
)
)
)
{
instance
-
>
SetWindow
(
nullptr
)
;
instance
-
>
Stop
(
)
;
nsPluginTag
*
pluginTag
=
TagForPlugin
(
instance
-
>
GetPlugin
(
)
)
;
instance
-
>
SetWindow
(
nullptr
)
;
RefPtr
<
dom
:
:
Element
>
domElement
;
instance
-
>
GetDOMElement
(
getter_AddRefs
(
domElement
)
)
;
nsCOMPtr
<
nsIObjectLoadingContent
>
objectContent
=
do_QueryInterface
(
domElement
)
;
instance
-
>
Destroy
(
)
;
mInstances
.
RemoveElement
(
instance
)
;
OnPluginInstanceDestroyed
(
pluginTag
)
;
if
(
objectContent
)
{
objectContent
-
>
PluginDestroyed
(
)
;
}
}
}
}
bool
nsPluginHost
:
:
CanUsePluginForMIMEType
(
const
nsACString
&
aMIMEType
)
{
if
(
nsPluginHost
:
:
GetSpecialType
(
aMIMEType
)
=
=
nsPluginHost
:
:
eSpecialType_Flash
|
|
MimeTypeIsAllowedForFakePlugin
(
NS_ConvertUTF8toUTF16
(
aMIMEType
)
)
|
|
aMIMEType
.
LowerCaseEqualsLiteral
(
"
application
/
x
-
test
"
)
|
|
aMIMEType
.
LowerCaseEqualsLiteral
(
"
application
/
x
-
second
-
test
"
)
|
|
aMIMEType
.
LowerCaseEqualsLiteral
(
"
application
/
x
-
third
-
test
"
)
)
{
return
true
;
}
return
false
;
}
class
nsPluginDestroyRunnable
:
public
Runnable
public
mozilla
:
:
LinkedListElement
<
nsPluginDestroyRunnable
>
{
public
:
explicit
nsPluginDestroyRunnable
(
nsNPAPIPluginInstance
*
aInstance
)
:
Runnable
(
"
nsPluginDestroyRunnable
"
)
mInstance
(
aInstance
)
{
sRunnableList
.
insertBack
(
this
)
;
}
~
nsPluginDestroyRunnable
(
)
override
{
this
-
>
remove
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
nsNPAPIPluginInstance
>
instance
;
instance
.
swap
(
mInstance
)
;
if
(
PluginDestructionGuard
:
:
DelayDestroy
(
instance
)
)
{
return
NS_OK
;
}
for
(
auto
r
:
sRunnableList
)
{
if
(
r
!
=
this
&
&
r
-
>
mInstance
=
=
instance
)
{
return
NS_OK
;
}
}
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
Doing
delayed
destroy
of
instance
%
p
\
n
"
instance
.
get
(
)
)
)
;
RefPtr
<
nsPluginHost
>
host
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
host
)
host
-
>
StopPluginInstance
(
instance
)
;
PLUGIN_LOG
(
PLUGIN_LOG_NORMAL
(
"
Done
with
delayed
destroy
of
instance
%
p
\
n
"
instance
.
get
(
)
)
)
;
return
NS_OK
;
}
protected
:
RefPtr
<
nsNPAPIPluginInstance
>
mInstance
;
static
mozilla
:
:
LinkedList
<
nsPluginDestroyRunnable
>
sRunnableList
;
}
;
mozilla
:
:
LinkedList
<
nsPluginDestroyRunnable
>
nsPluginDestroyRunnable
:
:
sRunnableList
;
mozilla
:
:
LinkedList
<
PluginDestructionGuard
>
PluginDestructionGuard
:
:
sList
;
PluginDestructionGuard
:
:
PluginDestructionGuard
(
nsNPAPIPluginInstance
*
aInstance
)
:
mInstance
(
aInstance
)
{
Init
(
)
;
}
PluginDestructionGuard
:
:
PluginDestructionGuard
(
NPP
npp
)
:
mInstance
(
npp
?
static_cast
<
nsNPAPIPluginInstance
*
>
(
npp
-
>
ndata
)
:
nullptr
)
{
Init
(
)
;
}
PluginDestructionGuard
:
:
~
PluginDestructionGuard
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
"
)
;
this
-
>
remove
(
)
;
if
(
mDelayedDestroy
)
{
RefPtr
<
nsPluginDestroyRunnable
>
evt
=
new
nsPluginDestroyRunnable
(
mInstance
)
;
NS_DispatchToMainThread
(
evt
)
;
}
}
bool
PluginDestructionGuard
:
:
DelayDestroy
(
nsNPAPIPluginInstance
*
aInstance
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
"
)
;
NS_ASSERTION
(
aInstance
"
Uh
I
need
an
instance
!
"
)
;
for
(
auto
g
:
sList
)
{
if
(
g
-
>
mInstance
=
=
aInstance
)
{
g
-
>
mDelayedDestroy
=
true
;
return
true
;
}
}
return
false
;
}
