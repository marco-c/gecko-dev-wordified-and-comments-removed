#
ifndef
nsPluginHost_h_
#
define
nsPluginHost_h_
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsIPluginHost
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
prlink
.
h
"
#
include
"
nsIPluginTag
.
h
"
#
include
"
nsPluginsDir
.
h
"
#
include
"
nsPluginDirServiceProvider
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsPluginTags
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIIDNService
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
ifdef
XP_WIN
#
include
<
minwindef
.
h
>
#
include
"
nsIWindowsRegKey
.
h
"
#
endif
namespace
mozilla
{
namespace
plugins
{
class
FakePluginTag
;
class
PluginTag
;
class
BlocklistPromiseHandler
;
}
}
class
nsNPAPIPlugin
;
class
nsIFile
;
class
nsIChannel
;
class
nsPluginNativeWindow
;
class
nsObjectLoadingContent
;
class
nsPluginInstanceOwner
;
class
nsPluginUnloadRunnable
;
class
nsNPAPIPluginInstance
;
class
nsNPAPIPluginStreamListener
;
class
nsIPluginInstanceOwner
;
class
nsIInputStream
;
class
nsIStreamListener
;
#
ifndef
npapi_h_
struct
_NPP
;
typedef
_NPP
*
NPP
;
#
endif
class
nsInvalidPluginTag
:
public
nsISupports
{
virtual
~
nsInvalidPluginTag
(
)
;
public
:
explicit
nsInvalidPluginTag
(
const
char
*
aFullPath
int64_t
aLastModifiedTime
=
0
)
;
NS_DECL_ISUPPORTS
nsCString
mFullPath
;
int64_t
mLastModifiedTime
;
bool
mSeen
;
RefPtr
<
nsInvalidPluginTag
>
mPrev
;
RefPtr
<
nsInvalidPluginTag
>
mNext
;
}
;
class
nsPluginHost
final
:
public
nsIPluginHost
public
nsIObserver
public
nsITimerCallback
public
nsSupportsWeakReference
public
nsINamed
{
friend
class
nsPluginTag
;
friend
class
nsFakePluginTag
;
virtual
~
nsPluginHost
(
)
;
public
:
nsPluginHost
(
)
;
static
already_AddRefed
<
nsPluginHost
>
GetInst
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIPLUGINHOST
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
NS_DECL_NSINAMED
enum
PluginFilter
{
eExcludeNone
=
nsIPluginHost
:
:
EXCLUDE_NONE
eExcludeDisabled
=
nsIPluginHost
:
:
EXCLUDE_DISABLED
eExcludeFake
=
nsIPluginHost
:
:
EXCLUDE_FAKE
}
;
bool
HavePluginForType
(
const
nsACString
&
aMimeType
PluginFilter
aFilter
=
eExcludeDisabled
)
;
bool
HavePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
PluginFilter
aFilter
=
eExcludeDisabled
)
;
void
GetPlugins
(
nsTArray
<
nsCOMPtr
<
nsIInternalPluginTag
>
>
&
aPluginArray
bool
aIncludeDisabled
=
false
)
;
nsresult
GetURL
(
nsISupports
*
pluginInst
const
char
*
url
const
char
*
target
nsNPAPIPluginStreamListener
*
streamListener
const
char
*
altHost
const
char
*
referrer
bool
forceJSEnabled
)
;
nsresult
PostURL
(
nsISupports
*
pluginInst
const
char
*
url
uint32_t
postDataLen
const
char
*
postData
const
char
*
target
nsNPAPIPluginStreamListener
*
streamListener
const
char
*
altHost
const
char
*
referrer
bool
forceJSEnabled
uint32_t
postHeadersLength
const
char
*
postHeaders
)
;
nsresult
UserAgent
(
const
char
*
*
retstring
)
;
nsresult
ParsePostBufferToFixHeaders
(
const
char
*
inPostData
uint32_t
inPostDataLen
char
*
*
outPostData
uint32_t
*
outPostDataLen
)
;
nsresult
NewPluginNativeWindow
(
nsPluginNativeWindow
*
*
aPluginNativeWindow
)
;
void
AddIdleTimeTarget
(
nsIPluginInstanceOwner
*
objectFrame
bool
isVisible
)
;
void
RemoveIdleTimeTarget
(
nsIPluginInstanceOwner
*
objectFrame
)
;
nsresult
GetPluginName
(
nsNPAPIPluginInstance
*
aPluginInstance
const
char
*
*
aPluginName
)
;
nsresult
StopPluginInstance
(
nsNPAPIPluginInstance
*
aInstance
)
;
nsresult
GetPluginTagForInstance
(
nsNPAPIPluginInstance
*
aPluginInstance
nsIPluginTag
*
*
aPluginTag
)
;
nsresult
NewPluginURLStream
(
const
nsString
&
aURL
nsNPAPIPluginInstance
*
aInstance
nsNPAPIPluginStreamListener
*
aListener
nsIInputStream
*
aPostStream
=
nullptr
const
char
*
aHeadersData
=
nullptr
uint32_t
aHeadersDataLen
=
0
)
;
nsresult
GetURLWithHeaders
(
nsNPAPIPluginInstance
*
pluginInst
const
char
*
url
const
char
*
target
=
nullptr
nsNPAPIPluginStreamListener
*
streamListener
=
nullptr
const
char
*
altHost
=
nullptr
const
char
*
referrer
=
nullptr
bool
forceJSEnabled
=
false
uint32_t
getHeadersLength
=
0
const
char
*
getHeaders
=
nullptr
)
;
nsresult
AddHeadersToChannel
(
const
char
*
aHeadersData
uint32_t
aHeadersDataLen
nsIChannel
*
aGenericChannel
)
;
static
bool
IsTypeWhitelisted
(
const
char
*
aType
)
;
static
bool
ShouldLoadTypeInParent
(
const
nsACString
&
aMimeType
)
;
static
bool
CanUsePluginForMIMEType
(
const
nsACString
&
aMIMEType
)
;
enum
SpecialType
{
eSpecialType_None
eSpecialType_Test
eSpecialType_Flash
}
;
static
SpecialType
GetSpecialType
(
const
nsACString
&
aMIMEType
)
;
static
nsresult
PostPluginUnloadEvent
(
PRLibrary
*
aLibrary
)
;
void
PluginCrashed
(
nsNPAPIPlugin
*
plugin
const
nsAString
&
pluginDumpID
const
nsAString
&
browserDumpID
)
;
nsNPAPIPluginInstance
*
FindInstance
(
const
char
*
mimetype
)
;
nsNPAPIPluginInstance
*
FindOldestStoppedInstance
(
)
;
uint32_t
StoppedInstanceCount
(
)
;
nsTArray
<
RefPtr
<
nsNPAPIPluginInstance
>
>
*
InstanceArray
(
)
;
nsPluginTag
*
FindTagForLibrary
(
PRLibrary
*
aLibrary
)
;
nsresult
InstantiatePluginInstance
(
const
nsACString
&
aMimeType
nsIURI
*
aURL
nsObjectLoadingContent
*
aContent
nsPluginInstanceOwner
*
*
aOwner
)
;
nsPluginTag
*
TagForPlugin
(
nsNPAPIPlugin
*
aPlugin
)
;
nsPluginTag
*
PluginWithId
(
uint32_t
aId
)
;
nsresult
GetPlugin
(
const
nsACString
&
aMimeType
nsNPAPIPlugin
*
*
aPlugin
)
;
nsresult
GetPluginForContentProcess
(
uint32_t
aPluginId
nsNPAPIPlugin
*
*
aPlugin
)
;
void
NotifyContentModuleDestroyed
(
uint32_t
aPluginId
)
;
nsresult
NewPluginStreamListener
(
nsIURI
*
aURL
nsNPAPIPluginInstance
*
aInstance
nsIStreamListener
*
*
aStreamListener
)
;
void
CreateWidget
(
nsPluginInstanceOwner
*
aOwner
)
;
nsresult
EnumerateSiteData
(
const
nsACString
&
domain
const
nsTArray
<
nsCString
>
&
sites
nsTArray
<
nsCString
>
&
result
bool
firstMatchOnly
)
;
nsresult
SendPluginsToContent
(
)
;
nsresult
SetPluginsInContent
(
uint32_t
aPluginEpoch
nsTArray
<
mozilla
:
:
plugins
:
:
PluginTag
>
&
aPlugins
nsTArray
<
mozilla
:
:
plugins
:
:
FakePluginTag
>
&
aFakePlugins
)
;
private
:
nsresult
LoadPlugins
(
)
;
nsresult
UnloadPlugins
(
)
;
nsresult
SetUpPluginInstance
(
const
nsACString
&
aMimeType
nsIURI
*
aURL
nsPluginInstanceOwner
*
aOwner
)
;
friend
class
nsPluginUnloadRunnable
;
friend
class
mozilla
:
:
plugins
:
:
BlocklistPromiseHandler
;
void
DestroyRunningInstances
(
nsPluginTag
*
aPluginTag
)
;
void
UpdatePluginInfo
(
nsPluginTag
*
aPluginTag
)
;
nsresult
TrySetUpPluginInstance
(
const
nsACString
&
aMimeType
nsIURI
*
aURL
nsPluginInstanceOwner
*
aOwner
)
;
nsPluginTag
*
FindPreferredPlugin
(
const
nsTArray
<
nsPluginTag
*
>
&
matches
)
;
nsIInternalPluginTag
*
FindPluginForType
(
const
nsACString
&
aMimeType
bool
aIncludeFake
bool
aCheckEnabled
)
;
nsFakePluginTag
*
FindFakePluginForType
(
const
nsACString
&
aMimeType
bool
aCheckEnabled
)
;
nsFakePluginTag
*
FindFakePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
bool
aCheckEnabled
)
;
nsPluginTag
*
FindNativePluginForType
(
const
nsACString
&
aMimeType
bool
aCheckEnabled
)
;
nsPluginTag
*
FindNativePluginForExtension
(
const
nsACString
&
aExtension
nsACString
&
aMimeType
bool
aCheckEnabled
)
;
nsresult
FindStoppedPluginForURL
(
nsIURI
*
aURL
nsIPluginInstanceOwner
*
aOwner
)
;
nsresult
FindPlugins
(
bool
aCreatePluginList
bool
*
aPluginsChanged
)
;
enum
nsRegisterType
{
ePluginRegister
ePluginUnregister
ePluginMaybeUnregister
}
;
void
RegisterWithCategoryManager
(
const
nsCString
&
aMimeType
nsRegisterType
aType
)
;
bool
ShouldAddPlugin
(
const
nsPluginInfo
&
aInfo
)
;
void
AddPluginTag
(
nsPluginTag
*
aPluginTag
)
;
void
UpdatePluginBlocklistState
(
nsPluginTag
*
aPluginTag
bool
aShouldSoftblock
=
false
)
;
nsresult
ScanPluginsDirectory
(
nsIFile
*
pluginsDir
bool
aCreatePluginList
bool
*
aPluginsChanged
)
;
nsresult
ScanPluginsDirectoryList
(
nsISimpleEnumerator
*
dirEnum
bool
aCreatePluginList
bool
*
aPluginsChanged
)
;
nsresult
EnsurePluginLoaded
(
nsPluginTag
*
aPluginTag
)
;
bool
IsRunningPlugin
(
nsPluginTag
*
aPluginTag
)
;
nsresult
EnsurePluginReg
(
)
;
nsresult
ReadPluginInfo
(
)
;
nsresult
WritePluginInfo
(
)
;
nsresult
ReadPluginInfoFromDisk
(
)
;
nsresult
ReadFlashInfo
(
)
;
nsresult
WriteFlashInfo
(
)
;
void
RemoveCachedPluginsInfo
(
const
char
*
filePath
nsPluginTag
*
*
result
)
;
bool
IsLiveTag
(
nsIPluginTag
*
tag
)
;
nsPluginTag
*
HaveSamePlugin
(
const
nsPluginTag
*
aPluginTag
)
;
nsPluginTag
*
FirstPluginWithPath
(
const
nsCString
&
path
)
;
nsresult
EnsurePrivateDirServiceProvider
(
)
;
void
OnPluginInstanceDestroyed
(
nsPluginTag
*
aPluginTag
)
;
void
IncrementChromeEpoch
(
)
;
uint32_t
ChromeEpoch
(
)
;
uint32_t
ChromeEpochForContent
(
)
;
void
SetChromeEpochForContent
(
uint32_t
aEpoch
)
;
void
UpdateInMemoryPluginInfo
(
nsPluginTag
*
aPluginTag
)
;
nsresult
ActuallyReloadPlugins
(
)
;
RefPtr
<
nsPluginTag
>
mPlugins
;
RefPtr
<
nsPluginTag
>
mCachedPlugins
;
RefPtr
<
nsInvalidPluginTag
>
mInvalidPlugins
;
nsTArray
<
RefPtr
<
nsFakePluginTag
>
>
mFakePlugins
;
bool
mPluginsLoaded
;
bool
mOverrideInternalTypes
;
bool
mPluginsDisabled
;
bool
mFlashOnly
;
nsTArray
<
RefPtr
<
nsNPAPIPluginInstance
>
>
mInstances
;
nsCOMPtr
<
nsIFile
>
mPluginRegFile
;
#
ifdef
XP_WIN
RefPtr
<
nsPluginDirServiceProvider
>
mPrivateDirServiceProvider
;
nsCOMPtr
<
nsIWindowsRegKey
>
mRegKeyHKLM
;
nsCOMPtr
<
nsIWindowsRegKey
>
mRegKeyHKCU
;
#
endif
nsCOMPtr
<
nsIEffectiveTLDService
>
mTLDService
;
nsCOMPtr
<
nsIIDNService
>
mIDNService
;
nsresult
NormalizeHostname
(
nsCString
&
host
)
;
nsWeakPtr
mCurrentDocument
;
uint32_t
mPluginEpoch
;
static
nsIFile
*
sPluginTempDir
;
static
mozilla
:
:
StaticRefPtr
<
nsPluginHost
>
sInst
;
}
;
class
PluginDestructionGuard
:
public
mozilla
:
:
LinkedListElement
<
PluginDestructionGuard
>
{
public
:
explicit
PluginDestructionGuard
(
nsNPAPIPluginInstance
*
aInstance
)
;
explicit
PluginDestructionGuard
(
NPP
npp
)
;
~
PluginDestructionGuard
(
)
;
static
bool
DelayDestroy
(
nsNPAPIPluginInstance
*
aInstance
)
;
protected
:
void
Init
(
)
{
NS_ASSERTION
(
NS_IsMainThread
(
)
"
Should
be
on
the
main
thread
"
)
;
mDelayedDestroy
=
false
;
sList
.
insertBack
(
this
)
;
}
RefPtr
<
nsNPAPIPluginInstance
>
mInstance
;
bool
mDelayedDestroy
;
static
mozilla
:
:
LinkedList
<
PluginDestructionGuard
>
sList
;
}
;
#
endif
