#
ifndef
mozilla_plugins_BrowserStreamChild_h
#
define
mozilla_plugins_BrowserStreamChild_h
1
#
include
"
mozilla
/
plugins
/
PBrowserStreamChild
.
h
"
#
include
"
mozilla
/
plugins
/
AStream
.
h
"
#
include
"
base
/
task
.
h
"
#
include
"
base
/
timer
.
h
"
namespace
mozilla
{
namespace
plugins
{
class
PluginInstanceChild
;
class
StreamNotifyChild
;
class
BrowserStreamChild
:
public
PBrowserStreamChild
public
AStream
{
public
:
BrowserStreamChild
(
PluginInstanceChild
*
instance
const
nsCString
&
url
const
uint32_t
&
length
const
uint32_t
&
lastmodified
StreamNotifyChild
*
notifyData
const
nsCString
&
headers
)
;
virtual
~
BrowserStreamChild
(
)
;
virtual
bool
IsBrowserStream
(
)
override
{
return
true
;
}
NPError
StreamConstructed
(
const
nsCString
&
mimeType
const
bool
&
seekable
uint16_t
*
stype
)
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvWrite
(
const
int32_t
&
offset
const
uint32_t
&
newsize
const
Buffer
&
data
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
RecvNPP_DestroyStream
(
const
NPReason
&
reason
)
override
;
virtual
mozilla
:
:
ipc
:
:
IPCResult
Recv__delete__
(
)
override
;
void
EnsureCorrectInstance
(
PluginInstanceChild
*
i
)
{
if
(
i
!
=
mInstance
)
MOZ_CRASH
(
"
Incorrect
stream
instance
"
)
;
}
void
EnsureCorrectStream
(
NPStream
*
s
)
{
if
(
s
!
=
&
mStream
)
MOZ_CRASH
(
"
Incorrect
stream
data
"
)
;
}
void
NotifyPending
(
)
{
NS_ASSERTION
(
!
mNotifyPending
"
Pending
twice
?
"
)
;
mNotifyPending
=
true
;
EnsureDeliveryPending
(
)
;
}
bool
InstanceDying
(
)
{
if
(
DELETING
=
=
mState
)
return
false
;
mInstanceDying
=
true
;
return
true
;
}
void
FinishDelivery
(
)
{
NS_ASSERTION
(
mInstanceDying
"
Should
only
be
called
after
InstanceDying
"
)
;
NS_ASSERTION
(
DELETING
!
=
mState
"
InstanceDying
didn
'
t
work
?
"
)
;
mStreamStatus
=
NPRES_USER_BREAK
;
Deliver
(
)
;
NS_ASSERTION
(
!
mStreamNotify
"
Didn
'
t
deliver
NPN_URLNotify
?
"
)
;
}
private
:
friend
class
StreamNotifyChild
;
void
EnsureDeliveryPending
(
)
;
void
Deliver
(
)
;
bool
DeliverPendingData
(
)
;
void
SetSuspendedTimer
(
)
;
void
ClearSuspendedTimer
(
)
;
PluginInstanceChild
*
mInstance
;
NPStream
mStream
;
static
const
NPReason
kStreamOpen
=
-
1
;
NPReason
mStreamStatus
;
enum
{
NOT_DESTROYED
DESTROY_PENDING
DESTROYED
}
mDestroyPending
;
bool
mNotifyPending
;
bool
mInstanceDying
;
enum
{
CONSTRUCTING
ALIVE
DYING
DELETING
}
mState
;
nsCString
mURL
;
nsCString
mHeaders
;
StreamNotifyChild
*
mStreamNotify
;
struct
PendingData
{
int32_t
offset
;
Buffer
data
;
int32_t
curpos
;
}
;
nsTArray
<
PendingData
>
mPendingData
;
ScopedRunnableMethodFactory
<
BrowserStreamChild
>
mDeliveryTracker
;
base
:
:
RepeatingTimer
<
BrowserStreamChild
>
mSuspendedTimer
;
}
;
}
}
#
endif
