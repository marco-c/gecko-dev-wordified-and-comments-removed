#
ifndef
dom_plugins_ipc_functionhook_h
#
define
dom_plugins_ipc_functionhook_h
1
#
include
"
IpdlTuple
.
h
"
#
include
"
base
/
process
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
if
defined
(
XP_WIN
)
#
include
"
nsWindowsDllInterceptor
.
h
"
#
endif
namespace
mozilla
{
template
<
class
T
>
class
StaticAutoPtr
;
namespace
plugins
{
extern
mozilla
:
:
LazyLogModule
sPluginHooksLog
;
#
define
HOOK_LOG
(
lvl
msg
)
MOZ_LOG
(
mozilla
:
:
plugins
:
:
sPluginHooksLog
lvl
msg
)
;
inline
const
char
*
SuccessMsg
(
bool
aVal
)
{
return
aVal
?
"
succeeded
"
:
"
failed
"
;
}
class
FunctionHook
;
class
FunctionHookArray
;
class
FunctionHook
{
public
:
virtual
~
FunctionHook
(
)
=
default
;
virtual
FunctionHookId
FunctionId
(
)
const
=
0
;
virtual
bool
Register
(
int
aQuirks
)
=
0
;
virtual
bool
RunOriginalFunction
(
base
:
:
ProcessId
aClientId
const
IPC
:
:
IpdlTuple
&
aInTuple
IPC
:
:
IpdlTuple
*
aOutTuple
)
const
=
0
;
static
void
HookFunctions
(
int
aQuirks
)
;
static
FunctionHookArray
*
GetHooks
(
)
;
#
if
defined
(
XP_WIN
)
static
void
HookProtectedMode
(
)
;
static
WindowsDllInterceptor
*
GetDllInterceptorFor
(
const
char
*
aModuleName
)
;
static
void
ClearDllInterceptorCache
(
)
;
#
endif
private
:
static
StaticAutoPtr
<
FunctionHookArray
>
sFunctionHooks
;
static
void
AddFunctionHooks
(
FunctionHookArray
&
aHooks
)
;
}
;
class
FunctionHookArray
:
public
nsTArray
<
FunctionHook
*
>
{
public
:
~
FunctionHookArray
(
)
{
for
(
uint32_t
idx
=
0
;
idx
<
Length
(
)
;
+
+
idx
)
{
FunctionHook
*
elt
=
ElementAt
(
idx
)
;
MOZ_ASSERT
(
elt
)
;
delete
elt
;
}
}
}
;
typedef
bool
(
ShouldHookFunc
)
(
int
aQuirks
)
;
template
<
FunctionHookId
functionId
typename
FunctionType
>
class
BasicFunctionHook
:
public
FunctionHook
{
#
if
defined
(
XP_WIN
)
using
FuncHookType
=
WindowsDllInterceptor
:
:
FuncHookType
<
FunctionType
*
>
;
#
endif
public
:
BasicFunctionHook
(
const
char
*
aModuleName
const
char
*
aFunctionName
FunctionType
*
aOldFunction
FunctionType
*
aNewFunction
)
:
mOldFunction
(
aOldFunction
)
mRegistration
(
UNREGISTERED
)
mModuleName
(
aModuleName
)
mFunctionName
(
aFunctionName
)
mNewFunction
(
aNewFunction
)
{
MOZ_ASSERT
(
mOldFunction
)
;
MOZ_ASSERT
(
mNewFunction
)
;
}
bool
Register
(
int
aQuirks
)
override
;
bool
RunOriginalFunction
(
base
:
:
ProcessId
aClientId
const
IPC
:
:
IpdlTuple
&
aInTuple
IPC
:
:
IpdlTuple
*
aOutTuple
)
const
override
{
return
false
;
}
FunctionHookId
FunctionId
(
)
const
override
{
return
functionId
;
}
FunctionType
*
OriginalFunction
(
)
const
{
return
mOldFunction
;
}
protected
:
Atomic
<
FunctionType
*
>
mOldFunction
;
#
if
defined
(
XP_WIN
)
FuncHookType
mStub
;
#
endif
enum
RegistrationStatus
{
UNREGISTERED
FAILED
SUCCEEDED
}
;
RegistrationStatus
mRegistration
;
const
nsCString
mModuleName
;
const
nsCString
mFunctionName
;
FunctionType
*
const
mNewFunction
;
static
ShouldHookFunc
*
const
mShouldHook
;
}
;
extern
bool
AlwaysHook
(
int
)
;
template
<
FunctionHookId
functionId
typename
FunctionType
>
ShouldHookFunc
*
const
BasicFunctionHook
<
functionId
FunctionType
>
:
:
mShouldHook
=
AlwaysHook
;
template
<
FunctionHookId
functionId
typename
FunctionType
>
bool
BasicFunctionHook
<
functionId
FunctionType
>
:
:
Register
(
int
aQuirks
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsPluginProcess
(
)
)
;
if
(
mRegistration
!
=
UNREGISTERED
|
|
!
mShouldHook
(
aQuirks
)
)
{
return
true
;
}
bool
isHooked
=
false
;
mRegistration
=
FAILED
;
#
if
defined
(
XP_WIN
)
WindowsDllInterceptor
*
dllInterceptor
=
FunctionHook
:
:
GetDllInterceptorFor
(
mModuleName
.
Data
(
)
)
;
if
(
!
dllInterceptor
)
{
return
false
;
}
isHooked
=
mStub
.
Set
(
*
dllInterceptor
mFunctionName
.
Data
(
)
mNewFunction
)
;
#
endif
if
(
isHooked
)
{
#
if
defined
(
XP_WIN
)
mOldFunction
=
mStub
.
GetStub
(
)
;
#
endif
mRegistration
=
SUCCEEDED
;
}
HOOK_LOG
(
LogLevel
:
:
Debug
(
"
Registering
to
intercept
function
'
%
s
'
:
'
%
s
'
"
mFunctionName
.
Data
(
)
SuccessMsg
(
isHooked
)
)
)
;
return
isHooked
;
}
}
}
#
endif
