#
ifndef
dom_plugins_ipc_functionbrokeripcutils_h
#
define
dom_plugins_ipc_functionbrokeripcutils_h
1
#
include
"
PluginMessageUtils
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
commdlg
.
h
>
#
endif
namespace
mozilla
{
namespace
plugins
{
enum
FunctionHookId
{
#
if
defined
(
XP_WIN
)
ID_GetWindowInfo
=
0
ID_GetKeyState
ID_SetCursorPos
ID_GetSaveFileNameW
ID_GetOpenFileNameW
ID_FunctionHookCount
#
else
ID_FunctionHookCount
#
endif
}
;
static
const
uint32_t
MAX_BLOB_CHARS_TO_LOG
=
12
;
inline
nsCString
FormatBlob
(
const
nsACString
&
aParam
)
{
if
(
aParam
.
IsVoid
(
)
|
|
aParam
.
IsEmpty
(
)
)
{
return
nsCString
(
aParam
.
IsVoid
(
)
?
"
<
void
>
"
:
"
<
empty
>
"
)
;
}
nsCString
str
;
uint32_t
totalLen
=
std
:
:
min
(
MAX_BLOB_CHARS_TO_LOG
aParam
.
Length
(
)
)
;
const
char
*
maybeEllipsis
=
(
MAX_BLOB_CHARS_TO_LOG
<
aParam
.
Length
(
)
)
?
"
.
.
.
"
:
"
"
;
for
(
uint32_t
idx
=
0
;
idx
<
totalLen
;
+
+
idx
)
{
str
.
AppendPrintf
(
"
0x
%
2x
"
aParam
.
Data
(
)
[
idx
]
&
0xff
)
;
}
str
.
AppendPrintf
(
"
%
s
|
'
"
maybeEllipsis
)
;
for
(
uint32_t
idx
=
0
;
idx
<
totalLen
;
+
+
idx
)
{
str
.
AppendPrintf
(
"
%
c
"
(
aParam
.
Data
(
)
[
idx
]
>
0
)
?
aParam
.
Data
(
)
[
idx
]
:
'
.
'
)
;
}
str
.
AppendPrintf
(
"
'
%
s
"
maybeEllipsis
)
;
return
str
;
}
#
if
defined
(
XP_WIN
)
enum
GetFileNameFunc
{
OPEN_FUNC
SAVE_FUNC
}
;
typedef
struct
_OpenFileNameIPC
{
void
AllocateOfnStrings
(
LPOPENFILENAMEW
aLpofn
)
const
;
static
void
FreeOfnStrings
(
LPOPENFILENAMEW
aLpofn
)
;
void
AddToOfn
(
LPOPENFILENAMEW
aLpofn
)
const
;
void
CopyFromOfn
(
LPOPENFILENAMEW
aLpofn
)
;
bool
operator
=
=
(
const
_OpenFileNameIPC
&
o
)
const
{
return
(
o
.
mHwndOwner
=
=
mHwndOwner
)
&
&
(
o
.
mFilter
=
=
mFilter
)
&
&
(
o
.
mHasFilter
=
=
mHasFilter
)
&
&
(
o
.
mCustomFilterIn
=
=
mCustomFilterIn
)
&
&
(
o
.
mHasCustomFilter
=
=
mHasCustomFilter
)
&
&
(
o
.
mNMaxCustFilterOut
=
=
mNMaxCustFilterOut
)
&
&
(
o
.
mFilterIndex
=
=
mFilterIndex
)
&
&
(
o
.
mFile
=
=
mFile
)
&
&
(
o
.
mNMaxFile
=
=
mNMaxFile
)
&
&
(
o
.
mNMaxFileTitle
=
=
mNMaxFileTitle
)
&
&
(
o
.
mInitialDir
=
=
mInitialDir
)
&
&
(
o
.
mHasInitialDir
=
=
mHasInitialDir
)
&
&
(
o
.
mTitle
=
=
mTitle
)
&
&
(
o
.
mHasTitle
=
=
mHasTitle
)
&
&
(
o
.
mFlags
=
=
mFlags
)
&
&
(
o
.
mDefExt
=
=
mDefExt
)
&
&
(
o
.
mHasDefExt
=
=
mHasDefExt
)
&
&
(
o
.
mFlagsEx
=
=
mFlagsEx
)
;
}
NativeWindowHandle
mHwndOwner
;
std
:
:
wstring
mFilter
;
bool
mHasFilter
;
std
:
:
wstring
mCustomFilterIn
;
bool
mHasCustomFilter
;
uint32_t
mNMaxCustFilterOut
;
uint32_t
mFilterIndex
;
std
:
:
wstring
mFile
;
uint32_t
mNMaxFile
;
uint32_t
mNMaxFileTitle
;
std
:
:
wstring
mInitialDir
;
bool
mHasInitialDir
;
std
:
:
wstring
mTitle
;
bool
mHasTitle
;
uint32_t
mFlags
;
std
:
:
wstring
mDefExt
;
bool
mHasDefExt
;
uint32_t
mFlagsEx
;
}
OpenFileNameIPC
;
typedef
struct
_OpenFileNameRetIPC
{
void
CopyFromOfn
(
LPOPENFILENAMEW
aLpofn
)
;
void
AddToOfn
(
LPOPENFILENAMEW
aLpofn
)
const
;
bool
operator
=
=
(
const
_OpenFileNameRetIPC
&
o
)
const
{
return
(
o
.
mCustomFilterOut
=
=
mCustomFilterOut
)
&
&
(
o
.
mFile
=
=
mFile
)
&
&
(
o
.
mFileTitle
=
=
mFileTitle
)
&
&
(
o
.
mFileOffset
=
=
mFileOffset
)
&
&
(
o
.
mFileExtension
=
=
mFileExtension
)
;
}
std
:
:
wstring
mCustomFilterOut
;
std
:
:
wstring
mFile
;
std
:
:
wstring
mFileTitle
;
uint16_t
mFileOffset
;
uint16_t
mFileExtension
;
}
OpenFileNameRetIPC
;
#
endif
}
}
namespace
IPC
{
using
mozilla
:
:
plugins
:
:
FunctionHookId
;
#
if
defined
(
XP_WIN
)
using
mozilla
:
:
plugins
:
:
OpenFileNameIPC
;
using
mozilla
:
:
plugins
:
:
OpenFileNameRetIPC
;
using
mozilla
:
:
plugins
:
:
NativeWindowHandle
;
using
mozilla
:
:
plugins
:
:
StringArray
;
template
<
>
struct
ParamTraits
<
OpenFileNameIPC
>
{
typedef
OpenFileNameIPC
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mHwndOwner
)
;
WriteParam
(
aMsg
aParam
.
mFilter
)
;
WriteParam
(
aMsg
aParam
.
mHasFilter
)
;
WriteParam
(
aMsg
aParam
.
mCustomFilterIn
)
;
WriteParam
(
aMsg
aParam
.
mHasCustomFilter
)
;
WriteParam
(
aMsg
aParam
.
mNMaxCustFilterOut
)
;
WriteParam
(
aMsg
aParam
.
mFilterIndex
)
;
WriteParam
(
aMsg
aParam
.
mFile
)
;
WriteParam
(
aMsg
aParam
.
mNMaxFile
)
;
WriteParam
(
aMsg
aParam
.
mNMaxFileTitle
)
;
WriteParam
(
aMsg
aParam
.
mInitialDir
)
;
WriteParam
(
aMsg
aParam
.
mHasInitialDir
)
;
WriteParam
(
aMsg
aParam
.
mTitle
)
;
WriteParam
(
aMsg
aParam
.
mHasTitle
)
;
WriteParam
(
aMsg
aParam
.
mFlags
)
;
WriteParam
(
aMsg
aParam
.
mDefExt
)
;
WriteParam
(
aMsg
aParam
.
mHasDefExt
)
;
WriteParam
(
aMsg
aParam
.
mFlagsEx
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
if
(
ReadParam
(
aMsg
aIter
&
aResult
-
>
mHwndOwner
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFilter
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mHasFilter
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mCustomFilterIn
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mHasCustomFilter
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mNMaxCustFilterOut
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFilterIndex
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFile
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mNMaxFile
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mNMaxFileTitle
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mInitialDir
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mHasInitialDir
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mTitle
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mHasTitle
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFlags
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mDefExt
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mHasDefExt
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFlagsEx
)
)
{
return
true
;
}
return
false
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
[
%
S
%
S
%
S
%
S
]
"
aParam
.
mFilter
.
c_str
(
)
aParam
.
mCustomFilterIn
.
c_str
(
)
aParam
.
mFile
.
c_str
(
)
aParam
.
mTitle
.
c_str
(
)
)
)
;
}
}
;
template
<
>
struct
ParamTraits
<
OpenFileNameRetIPC
>
{
typedef
OpenFileNameRetIPC
paramType
;
static
void
Write
(
Message
*
aMsg
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
mCustomFilterOut
)
;
WriteParam
(
aMsg
aParam
.
mFile
)
;
WriteParam
(
aMsg
aParam
.
mFileTitle
)
;
WriteParam
(
aMsg
aParam
.
mFileOffset
)
;
WriteParam
(
aMsg
aParam
.
mFileExtension
)
;
}
static
bool
Read
(
const
Message
*
aMsg
PickleIterator
*
aIter
paramType
*
aResult
)
{
if
(
ReadParam
(
aMsg
aIter
&
aResult
-
>
mCustomFilterOut
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFile
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFileTitle
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFileOffset
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
mFileExtension
)
)
{
return
true
;
}
return
false
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
aLog
-
>
append
(
StringPrintf
(
L
"
[
%
S
%
S
%
S
%
d
%
d
]
"
aParam
.
mCustomFilterOut
.
c_str
(
)
aParam
.
mFile
.
c_str
(
)
aParam
.
mFileTitle
.
c_str
(
)
aParam
.
mFileOffset
aParam
.
mFileExtension
)
)
;
}
}
;
template
<
>
struct
ParamTraits
<
mozilla
:
:
plugins
:
:
GetFileNameFunc
>
:
public
ContiguousEnumSerializerInclusive
<
mozilla
:
:
plugins
:
:
GetFileNameFunc
mozilla
:
:
plugins
:
:
OPEN_FUNC
mozilla
:
:
plugins
:
:
SAVE_FUNC
>
{
}
;
#
endif
template
<
>
struct
ParamTraits
<
FunctionHookId
>
:
public
ContiguousEnumSerializer
<
FunctionHookId
static_cast
<
FunctionHookId
>
(
0
)
FunctionHookId
:
:
ID_FunctionHookCount
>
{
}
;
}
#
endif
