#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
FunctionHook
.
h
"
#
include
"
FunctionBroker
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
shlobj
.
h
>
#
include
"
PluginModuleChild
.
h
"
#
endif
namespace
mozilla
{
namespace
plugins
{
StaticAutoPtr
<
FunctionHookArray
>
FunctionHook
:
:
sFunctionHooks
;
bool
AlwaysHook
(
int
)
{
return
true
;
}
FunctionHookArray
*
FunctionHook
:
:
GetHooks
(
)
{
if
(
sFunctionHooks
)
{
return
sFunctionHooks
;
}
sFunctionHooks
=
new
FunctionHookArray
(
)
;
ClearOnShutdown
(
&
sFunctionHooks
)
;
sFunctionHooks
-
>
SetLength
(
ID_FunctionHookCount
)
;
AddFunctionHooks
(
*
sFunctionHooks
)
;
AddBrokeredFunctionHooks
(
*
sFunctionHooks
)
;
return
sFunctionHooks
;
}
void
FunctionHook
:
:
HookFunctions
(
int
aQuirks
)
{
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Plugin
)
;
FunctionHookArray
*
hooks
=
FunctionHook
:
:
GetHooks
(
)
;
MOZ_ASSERT
(
hooks
)
;
for
(
size_t
i
=
0
;
i
<
hooks
-
>
Length
(
)
;
+
+
i
)
{
FunctionHook
*
mhb
=
hooks
-
>
ElementAt
(
i
)
;
MOZ_ASSERT
(
(
size_t
)
mhb
-
>
FunctionId
(
)
=
=
i
)
;
mhb
-
>
Register
(
aQuirks
)
;
}
}
#
if
defined
(
XP_WIN
)
typedef
nsClassHashtable
<
nsStringHashKey
WindowsDllInterceptor
>
DllInterceptors
;
DllInterceptors
*
sDllInterceptorCache
=
nullptr
;
WindowsDllInterceptor
*
FunctionHook
:
:
GetDllInterceptorFor
(
const
char
*
aModuleName
)
{
if
(
!
sDllInterceptorCache
)
{
sDllInterceptorCache
=
new
DllInterceptors
(
)
;
}
MOZ_ASSERT
(
IsAsciiNullTerminated
(
aModuleName
)
"
Non
-
ASCII
module
names
are
not
supported
"
)
;
NS_ConvertASCIItoUTF16
moduleName
(
aModuleName
)
;
WindowsDllInterceptor
*
ret
=
sDllInterceptorCache
-
>
LookupOrAdd
(
moduleName
)
;
MOZ_ASSERT
(
ret
)
;
ret
-
>
Init
(
moduleName
.
get
(
)
)
;
return
ret
;
}
void
FunctionHook
:
:
ClearDllInterceptorCache
(
)
{
delete
sDllInterceptorCache
;
sDllInterceptorCache
=
nullptr
;
}
typedef
BasicFunctionHook
<
ID_GetWindowInfo
decltype
(
GetWindowInfo
)
>
GetWindowInfoFH
;
template
<
>
ShouldHookFunc
*
const
GetWindowInfoFH
:
:
mShouldHook
=
&
CheckQuirks
<
QUIRK_FLASH_HOOK_GETWINDOWINFO
>
;
static
const
wchar_t
*
kMozillaWindowClass
=
L
"
MozillaWindowClass
"
;
static
HWND
sBrowserHwnd
=
nullptr
;
INTERCEPTOR_DISABLE_CFGUARD
BOOL
WINAPI
GetWindowInfoHook
(
HWND
hWnd
PWINDOWINFO
pwi
)
{
if
(
!
pwi
)
{
return
FALSE
;
}
MOZ_ASSERT
(
ID_GetWindowInfo
<
FunctionHook
:
:
GetHooks
(
)
-
>
Length
(
)
)
;
GetWindowInfoFH
*
functionHook
=
static_cast
<
GetWindowInfoFH
*
>
(
FunctionHook
:
:
GetHooks
(
)
-
>
ElementAt
(
ID_GetWindowInfo
)
)
;
if
(
!
functionHook
-
>
OriginalFunction
(
)
)
{
NS_ASSERTION
(
FALSE
"
Something
is
horribly
wrong
in
PHGetWindowInfoHook
!
"
)
;
return
FALSE
;
}
if
(
!
sBrowserHwnd
)
{
wchar_t
szClass
[
20
]
;
int
nameLen
=
GetClassNameW
(
hWnd
szClass
ArrayLength
(
szClass
)
)
;
if
(
(
nameLen
<
(
int
)
ArrayLength
(
szClass
)
)
&
&
!
wcscmp
(
szClass
kMozillaWindowClass
)
)
{
sBrowserHwnd
=
hWnd
;
}
}
typedef
BOOL
(
WINAPI
*
GetWindowInfoPtr
)
(
HWND
hwnd
PWINDOWINFO
pwi
)
;
GetWindowInfoPtr
gwiFunc
=
static_cast
<
GetWindowInfoPtr
>
(
functionHook
-
>
OriginalFunction
(
)
)
;
BOOL
result
=
gwiFunc
(
hWnd
pwi
)
;
if
(
sBrowserHwnd
&
&
sBrowserHwnd
=
=
hWnd
)
{
pwi
-
>
rcWindow
=
pwi
-
>
rcClient
;
}
return
result
;
}
typedef
BasicFunctionHook
<
ID_PrintDlgW
decltype
(
PrintDlgW
)
>
PrintDlgWFH
;
template
<
>
ShouldHookFunc
*
const
PrintDlgWFH
:
:
mShouldHook
=
&
CheckQuirks
<
QUIRK_FLASH_HOOK_PRINTDLGW
>
;
INTERCEPTOR_DISABLE_CFGUARD
BOOL
WINAPI
PrintDlgWHook
(
LPPRINTDLGW
aDlg
)
{
HWND
hwnd
=
aDlg
-
>
hwndOwner
;
aDlg
-
>
hwndOwner
=
0
;
MOZ_ASSERT
(
ID_PrintDlgW
<
FunctionHook
:
:
GetHooks
(
)
-
>
Length
(
)
)
;
PrintDlgWFH
*
functionHook
=
static_cast
<
PrintDlgWFH
*
>
(
FunctionHook
:
:
GetHooks
(
)
-
>
ElementAt
(
ID_PrintDlgW
)
)
;
MOZ_ASSERT
(
functionHook
)
;
BOOL
ret
=
functionHook
-
>
OriginalFunction
(
)
(
aDlg
)
;
aDlg
-
>
hwndOwner
=
hwnd
;
return
ret
;
}
static
WindowsDllInterceptor
sKernel32Intercept
;
typedef
HANDLE
(
WINAPI
*
CreateFileWPtr
)
(
LPCWSTR
aFname
DWORD
aAccess
DWORD
aShare
LPSECURITY_ATTRIBUTES
aSecurity
DWORD
aCreation
DWORD
aFlags
HANDLE
aFTemplate
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
CreateFileWPtr
>
sCreateFileWStub
;
typedef
HANDLE
(
WINAPI
*
CreateFileAPtr
)
(
LPCSTR
aFname
DWORD
aAccess
DWORD
aShare
LPSECURITY_ATTRIBUTES
aSecurity
DWORD
aCreation
DWORD
aFlags
HANDLE
aFTemplate
)
;
static
WindowsDllInterceptor
:
:
FuncHookType
<
CreateFileAPtr
>
sCreateFileAStub
;
static
HANDLE
WINAPI
CreateFileAHookFn
(
LPCSTR
aFname
DWORD
aAccess
DWORD
aShare
LPSECURITY_ATTRIBUTES
aSecurity
DWORD
aCreation
DWORD
aFlags
HANDLE
aFTemplate
)
{
while
(
true
)
{
WCHAR
unicodeName
[
MAX_PATH
]
;
size_t
len
=
strlen
(
aFname
)
;
if
(
len
>
=
MAX_PATH
)
{
break
;
}
int
newLen
=
MultiByteToWideChar
(
CP_ACP
MB_ERR_INVALID_CHARS
aFname
len
unicodeName
MAX_PATH
)
;
if
(
newLen
=
=
0
|
|
newLen
>
=
MAX_PATH
)
{
break
;
}
unicodeName
[
newLen
]
=
'
\
0
'
;
return
CreateFileW
(
unicodeName
aAccess
aShare
aSecurity
aCreation
aFlags
aFTemplate
)
;
}
return
sCreateFileAStub
(
aFname
aAccess
aShare
aSecurity
aCreation
aFlags
aFTemplate
)
;
}
static
bool
GetLocalLowTempPath
(
size_t
aLen
LPWSTR
aPath
)
{
constexpr
auto
tempname
=
u
"
\
\
Temp
"
_ns
;
LPWSTR
path
;
if
(
SUCCEEDED
(
SHGetKnownFolderPath
(
FOLDERID_LocalAppDataLow
0
nullptr
&
path
)
)
)
{
if
(
wcslen
(
path
)
+
tempname
.
Length
(
)
<
aLen
)
{
wcscpy
(
aPath
path
)
;
wcscat
(
aPath
tempname
.
get
(
)
)
;
CoTaskMemFree
(
path
)
;
return
true
;
}
CoTaskMemFree
(
path
)
;
}
if
(
!
GetTempPathW
(
aLen
aPath
)
)
{
return
false
;
}
return
true
;
}
HANDLE
WINAPI
CreateFileWHookFn
(
LPCWSTR
aFname
DWORD
aAccess
DWORD
aShare
LPSECURITY_ATTRIBUTES
aSecurity
DWORD
aCreation
DWORD
aFlags
HANDLE
aFTemplate
)
{
static
const
WCHAR
kConfigFile
[
]
=
L
"
mms
.
cfg
"
;
static
const
size_t
kConfigLength
=
ArrayLength
(
kConfigFile
)
-
1
;
while
(
true
)
{
size_t
len
=
wcslen
(
aFname
)
;
if
(
len
<
kConfigLength
)
{
break
;
}
if
(
wcscmp
(
aFname
+
len
-
kConfigLength
kConfigFile
)
!
=
0
)
{
break
;
}
WCHAR
tempPath
[
MAX_PATH
+
1
]
;
if
(
GetLocalLowTempPath
(
MAX_PATH
tempPath
)
=
=
0
)
{
break
;
}
WCHAR
tempFile
[
MAX_PATH
+
1
]
;
if
(
GetTempFileNameW
(
tempPath
L
"
fx
"
0
tempFile
)
=
=
0
)
{
break
;
}
HANDLE
replacement
=
sCreateFileWStub
(
tempFile
GENERIC_READ
|
GENERIC_WRITE
aShare
aSecurity
TRUNCATE_EXISTING
FILE_ATTRIBUTE_TEMPORARY
|
FILE_FLAG_DELETE_ON_CLOSE
nullptr
)
;
if
(
replacement
=
=
INVALID_HANDLE_VALUE
)
{
break
;
}
HANDLE
original
=
sCreateFileWStub
(
aFname
aAccess
aShare
aSecurity
aCreation
aFlags
aFTemplate
)
;
if
(
original
!
=
INVALID_HANDLE_VALUE
)
{
static
const
size_t
kBufferSize
=
1024
;
char
buffer
[
kBufferSize
]
;
DWORD
bytes
;
while
(
ReadFile
(
original
buffer
kBufferSize
&
bytes
NULL
)
)
{
if
(
bytes
=
=
0
)
{
break
;
}
DWORD
wbytes
;
WriteFile
(
replacement
buffer
bytes
&
wbytes
NULL
)
;
if
(
bytes
<
kBufferSize
)
{
break
;
}
}
CloseHandle
(
original
)
;
}
static
const
char
kSettingString
[
]
=
"
\
nProtectedMode
=
0
\
n
"
;
DWORD
wbytes
;
WriteFile
(
replacement
static_cast
<
const
void
*
>
(
kSettingString
)
sizeof
(
kSettingString
)
-
1
&
wbytes
NULL
)
;
SetFilePointer
(
replacement
0
NULL
FILE_BEGIN
)
;
return
replacement
;
}
return
sCreateFileWStub
(
aFname
aAccess
aShare
aSecurity
aCreation
aFlags
aFTemplate
)
;
}
void
FunctionHook
:
:
HookProtectedMode
(
)
{
sKernel32Intercept
.
Init
(
"
kernel32
.
dll
"
)
;
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Plugin
)
;
sCreateFileWStub
.
Set
(
sKernel32Intercept
"
CreateFileW
"
&
CreateFileWHookFn
)
;
sCreateFileAStub
.
Set
(
sKernel32Intercept
"
CreateFileA
"
&
CreateFileAHookFn
)
;
}
#
if
defined
(
MOZ_SANDBOX
)
typedef
BasicFunctionHook
<
ID_GetFileAttributesW
decltype
(
GetFileAttributesW
)
>
GetFileAttributesWFH
;
INTERCEPTOR_DISABLE_CFGUARD
DWORD
WINAPI
GetFileAttributesWHook
(
LPCWSTR
aFilename
)
{
MOZ_ASSERT
(
ID_GetFileAttributesW
<
FunctionHook
:
:
GetHooks
(
)
-
>
Length
(
)
)
;
GetFileAttributesWFH
*
functionHook
=
static_cast
<
GetFileAttributesWFH
*
>
(
FunctionHook
:
:
GetHooks
(
)
-
>
ElementAt
(
ID_GetFileAttributesW
)
)
;
if
(
!
functionHook
-
>
OriginalFunction
(
)
)
{
NS_ASSERTION
(
FALSE
"
Something
is
horribly
wrong
in
GetFileAttributesWHook
!
"
)
;
return
FALSE
;
}
DWORD
ret
=
functionHook
-
>
OriginalFunction
(
)
(
aFilename
)
;
if
(
ret
!
=
INVALID_FILE_ATTRIBUTES
)
{
return
ret
;
}
size_t
len
=
wcslen
(
aFilename
)
;
std
:
:
wstring
roamingPath
=
PluginModuleChild
:
:
GetFlashRoamingPath
(
)
;
bool
isParent
=
(
len
>
0
)
&
&
(
aFilename
[
len
-
1
]
=
=
L
'
\
\
'
)
&
&
(
_wcsnicmp
(
aFilename
roamingPath
.
c_str
(
)
len
)
=
=
0
)
;
if
(
!
isParent
)
{
return
ret
;
}
return
FILE_ATTRIBUTE_DIRECTORY
;
}
#
endif
#
endif
#
define
FUN_HOOK
(
x
)
static_cast
<
FunctionHook
*
>
(
x
)
void
FunctionHook
:
:
AddFunctionHooks
(
FunctionHookArray
&
aHooks
)
{
#
if
defined
(
XP_WIN
)
aHooks
[
ID_GetWindowInfo
]
=
FUN_HOOK
(
new
GetWindowInfoFH
(
"
user32
.
dll
"
"
GetWindowInfo
"
&
GetWindowInfo
&
GetWindowInfoHook
)
)
;
aHooks
[
ID_PrintDlgW
]
=
FUN_HOOK
(
new
PrintDlgWFH
(
"
comdlg32
.
dll
"
"
PrintDlgW
"
&
PrintDlgW
PrintDlgWHook
)
)
;
#
if
defined
(
MOZ_SANDBOX
)
aHooks
[
ID_GetFileAttributesW
]
=
FUN_HOOK
(
new
GetFileAttributesWFH
(
"
kernel32
.
dll
"
"
GetFileAttributesW
"
&
GetFileAttributesW
&
GetFileAttributesWHook
)
)
;
#
endif
#
endif
}
#
undef
FUN_HOOK
}
}
