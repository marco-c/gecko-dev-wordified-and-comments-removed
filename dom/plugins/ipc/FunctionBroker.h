#
ifndef
dom_plugins_ipc_PluginHooksWin_h
#
define
dom_plugins_ipc_PluginHooksWin_h
1
#
include
<
map
>
#
include
<
algorithm
>
#
include
<
utility
>
#
include
"
base
/
task
.
h
"
#
include
"
mozilla
/
ipc
/
ProcessChild
.
h
"
#
include
"
FunctionBrokerChild
.
h
"
#
include
"
mtransport
/
runnable_utils
.
h
"
#
include
"
PluginMessageUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
FunctionHook
.
h
"
#
include
"
FunctionBrokerIPCUtils
.
h
"
#
if
defined
(
XP_WIN
)
#
define
SECURITY_WIN32
#
include
<
security
.
h
>
#
include
<
wininet
.
h
>
#
include
<
schnlsp
.
h
>
#
if
defined
(
MOZ_SANDBOX
)
#
include
"
sandboxPermissions
.
h
"
#
endif
#
endif
namespace
mozilla
{
namespace
plugins
{
#
if
defined
(
XP_WIN
)
#
define
HOOK_CALL
WINAPI
typedef
std
:
:
pair
<
ULONG_PTR
ULONG_PTR
>
UlongPair
;
typedef
std
:
:
map
<
UlongPair
uint64_t
>
UlongPairToIdMap
;
extern
UlongPairToIdMap
sPairToIdMap
;
typedef
std
:
:
map
<
uint64_t
UlongPair
>
IdToUlongPairMap
;
extern
IdToUlongPairMap
sIdToPairMap
;
typedef
std
:
:
map
<
void
*
uint64_t
>
PtrToIdMap
;
extern
PtrToIdMap
sPtrToIdMap
;
typedef
std
:
:
map
<
uint64_t
void
*
>
IdToPtrMap
;
extern
IdToPtrMap
sIdToPtrMap
;
#
else
#
define
HOOK_CALL
#
endif
inline
bool
IsOdd
(
uint64_t
aVal
)
{
return
aVal
&
1
;
}
enum
Endpoint
{
SERVER
CLIENT
}
;
inline
const
char
*
EndpointMsg
(
Endpoint
aVal
)
{
return
aVal
=
=
SERVER
?
"
SERVER
"
:
"
CLIENT
"
;
}
template
<
typename
ParamType
>
inline
void
LogParameterValue
(
int
aIndex
const
ParamType
&
aParam
)
{
#
ifdef
DEBUG
if
(
!
MOZ_LOG_TEST
(
sPluginHooksLog
LogLevel
:
:
Verbose
)
)
{
return
;
}
std
:
:
wstring
paramString
;
IPC
:
:
LogParam
(
aParam
&
paramString
)
;
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
Parameter
%
d
:
%
S
"
aIndex
paramString
.
c_str
(
)
)
)
;
#
endif
}
template
<
typename
ParamType
>
inline
void
LogParameterValue
(
int
aIndex
ParamType
*
const
&
aParam
)
{
#
ifdef
DEBUG
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
Parameter
%
d
:
pointer
value
-
%
p
"
aIndex
aParam
)
)
;
#
endif
}
template
<
>
inline
void
LogParameterValue
(
int
aIndex
const
nsDependentCSubstring
&
aParam
)
{
#
ifdef
DEBUG
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
Parameter
%
d
:
%
s
"
aIndex
FormatBlob
(
aParam
)
.
Data
(
)
)
)
;
#
endif
}
template
<
>
inline
void
LogParameterValue
(
int
aIndex
char
*
const
&
aParam
)
{
#
ifdef
DEBUG
nsDependentCSubstring
str
;
if
(
aParam
)
{
str
.
Rebind
(
const_cast
<
char
*
>
(
aParam
)
strnlen
(
aParam
MAX_BLOB_CHARS_TO_LOG
)
)
;
}
else
{
str
.
SetIsVoid
(
true
)
;
}
LogParameterValue
(
aIndex
str
)
;
#
endif
}
template
<
>
inline
void
LogParameterValue
(
int
aIndex
const
char
*
const
&
aParam
)
{
#
ifdef
DEBUG
LogParameterValue
(
aIndex
const_cast
<
char
*
const
&
>
(
aParam
)
)
;
#
endif
}
#
if
defined
(
XP_WIN
)
template
<
>
inline
void
LogParameterValue
(
int
aIndex
const
SEC_GET_KEY_FN
&
aParam
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aParam
=
=
nullptr
)
;
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
Parameter
%
d
:
null
function
.
"
aIndex
)
)
;
#
endif
}
template
<
>
inline
void
LogParameterValue
(
int
aIndex
LPVOID
*
const
&
aParam
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aParam
=
=
nullptr
)
;
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
Parameter
%
d
:
null
void
pointer
.
"
aIndex
)
)
;
#
endif
}
#
endif
template
<
typename
ParamType
>
inline
bool
ParameterEquality
(
const
ParamType
&
aParam1
const
ParamType
&
aParam2
)
{
return
aParam1
=
=
aParam2
;
}
template
<
>
inline
bool
ParameterEquality
(
char
*
const
&
aParam1
char
*
const
&
aParam2
)
{
return
(
(
!
aParam1
&
&
!
aParam2
)
|
|
(
aParam1
&
&
aParam2
&
&
!
strcmp
(
aParam1
aParam2
)
)
)
;
}
template
<
>
inline
bool
ParameterEquality
(
const
char
*
const
&
aParam1
const
char
*
const
&
aParam2
)
{
return
ParameterEquality
(
const_cast
<
char
*
const
&
>
(
aParam1
)
const_cast
<
char
*
const
&
>
(
aParam2
)
)
;
}
template
<
typename
OrigType
>
struct
IPCTypeMap
{
typedef
OrigType
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
char
*
>
{
typedef
nsDependentCSubstring
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
const
char
*
>
{
typedef
nsDependentCSubstring
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
long
>
{
typedef
int32_t
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
unsigned
long
>
{
typedef
uint32_t
ipc_type
;
}
;
#
if
defined
(
XP_WIN
)
template
<
>
struct
IPCTypeMap
<
PSecHandle
>
{
typedef
uint64_t
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
PTimeStamp
>
{
typedef
uint64_t
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
void
*
>
{
typedef
uint64_t
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
HWND
>
{
typedef
NativeWindowHandle
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
PSCHANNEL_CRED
>
{
typedef
IPCSchannelCred
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
LPINTERNET_BUFFERSA
>
{
typedef
IPCInternetBuffers
ipc_type
;
}
;
template
<
>
struct
IPCTypeMap
<
LPDWORD
>
{
typedef
uint32_t
ipc_type
;
}
;
#
endif
template
<
typename
AllocType
>
static
void
DeleteDestructor
(
void
*
aObj
)
{
delete
static_cast
<
AllocType
*
>
(
aObj
)
;
}
extern
void
FreeDestructor
(
void
*
aObj
)
;
class
ServerCallData
{
public
:
typedef
void
(
DestructorType
)
(
void
*
)
;
template
<
typename
AllocType
>
AllocType
*
Allocate
(
DestructorType
*
aDestructor
=
&
DeleteDestructor
<
AllocType
>
)
{
AllocType
*
ret
=
new
AllocType
(
)
;
mList
.
AppendElement
(
FreeItem
(
ret
aDestructor
)
)
;
return
ret
;
}
template
<
typename
AllocType
>
AllocType
*
Allocate
(
const
AllocType
&
aValueToCopy
DestructorType
*
aDestructor
=
&
DeleteDestructor
<
AllocType
>
)
{
AllocType
*
ret
=
Allocate
<
AllocType
>
(
aDestructor
)
;
*
ret
=
aValueToCopy
;
return
ret
;
}
template
<
typename
PtrType
>
void
AllocateMemory
(
unsigned
long
aBufLen
PtrType
&
aBuf
)
{
if
(
aBufLen
)
{
aBuf
=
static_cast
<
PtrType
>
(
malloc
(
aBufLen
)
)
;
mList
.
AppendElement
(
FreeItem
(
aBuf
FreeDestructor
)
)
;
}
else
{
aBuf
=
nullptr
;
}
}
template
<
typename
PtrType
>
void
AllocateString
(
const
nsACString
&
aStr
PtrType
&
aBuf
bool
aCopyNullTerminator
=
true
)
{
uint32_t
nullByte
=
aCopyNullTerminator
?
1
:
0
;
char
*
tempBuf
=
static_cast
<
char
*
>
(
malloc
(
aStr
.
Length
(
)
+
nullByte
)
)
;
memcpy
(
tempBuf
aStr
.
Data
(
)
aStr
.
Length
(
)
+
nullByte
)
;
mList
.
AppendElement
(
FreeItem
(
tempBuf
FreeDestructor
)
)
;
aBuf
=
tempBuf
;
}
void
PostDestructor
(
void
*
aMem
DestructorType
*
aDestructor
)
{
mList
.
AppendElement
(
FreeItem
(
aMem
aDestructor
)
)
;
}
#
if
defined
(
XP_WIN
)
template
<
typename
PtrType
>
void
AllocateMemory
(
DWORD
aBufLen
PtrType
&
aBuf
LPDWORD
&
aBufLenCopy
)
{
aBufLenCopy
=
static_cast
<
LPDWORD
>
(
malloc
(
sizeof
(
DWORD
)
)
)
;
*
aBufLenCopy
=
aBufLen
;
mList
.
AppendElement
(
FreeItem
(
aBufLenCopy
FreeDestructor
)
)
;
AllocateMemory
(
aBufLen
aBuf
)
;
}
#
endif
private
:
class
FreeItem
{
void
*
mPtr
;
DestructorType
*
mDestructor
;
FreeItem
(
FreeItem
&
aOther
)
;
public
:
explicit
FreeItem
(
void
*
aPtr
DestructorType
*
aDestructor
)
:
mPtr
(
aPtr
)
mDestructor
(
aDestructor
)
{
MOZ_ASSERT
(
mDestructor
|
|
!
aPtr
)
;
}
FreeItem
(
FreeItem
&
&
aOther
)
:
mPtr
(
aOther
.
mPtr
)
mDestructor
(
aOther
.
mDestructor
)
{
aOther
.
mPtr
=
nullptr
;
aOther
.
mDestructor
=
nullptr
;
}
~
FreeItem
(
)
{
if
(
mDestructor
)
{
mDestructor
(
mPtr
)
;
}
}
}
;
typedef
nsTArray
<
FreeItem
>
FreeItemList
;
FreeItemList
mList
;
}
;
class
IpdlTupleContext
{
public
:
explicit
IpdlTupleContext
(
const
IpdlTuple
*
aTuple
ServerCallData
*
aScd
=
nullptr
)
:
mTuple
(
aTuple
)
mScd
(
aScd
)
{
MOZ_ASSERT
(
aTuple
)
;
}
ServerCallData
*
GetServerCallData
(
)
{
return
mScd
;
}
const
IpdlTuple
*
GetIpdlTuple
(
)
{
return
mTuple
;
}
private
:
const
IpdlTuple
*
mTuple
;
ServerCallData
*
mScd
;
}
;
template
<
typename
DestType
typename
SrcType
>
inline
void
Copy
(
DestType
&
aDest
const
SrcType
&
aSrc
)
{
aDest
=
(
DestType
)
aSrc
;
}
template
<
>
inline
void
Copy
(
nsDependentCSubstring
&
aDest
const
nsDependentCSubstring
&
aSrc
)
{
if
(
aSrc
.
IsVoid
(
)
)
{
aDest
.
SetIsVoid
(
true
)
;
}
else
{
aDest
.
Rebind
(
aSrc
.
Data
(
)
aSrc
.
Length
(
)
)
;
}
}
#
if
defined
(
XP_WIN
)
template
<
>
inline
void
Copy
(
uint64_t
&
aDest
const
PTimeStamp
&
aSrc
)
{
aDest
=
static_cast
<
uint64_t
>
(
aSrc
-
>
QuadPart
)
;
}
template
<
>
inline
void
Copy
(
PTimeStamp
&
aDest
const
uint64_t
&
aSrc
)
{
aDest
-
>
QuadPart
=
static_cast
<
LONGLONG
>
(
aSrc
)
;
}
#
endif
template
<
Endpoint
e
>
struct
EndpointHandler
;
template
<
>
struct
EndpointHandler
<
CLIENT
>
{
static
const
Endpoint
OtherSide
=
SERVER
;
template
<
typename
DestType
typename
SrcType
>
inline
static
void
Copy
(
ServerCallData
*
aScd
DestType
&
aDest
const
SrcType
&
aSrc
)
{
MOZ_ASSERT
(
!
aScd
)
;
Copy
(
aDest
aSrc
)
;
}
template
<
typename
DestType
typename
SrcType
>
inline
static
void
Copy
(
DestType
&
aDest
const
SrcType
&
aSrc
)
{
mozilla
:
:
plugins
:
:
Copy
(
aDest
aSrc
)
;
}
}
;
#
if
defined
(
XP_WIN
)
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
uint64_t
&
aDest
const
PSecHandle
&
aSrc
)
{
MOZ_ASSERT
(
(
aSrc
-
>
dwLower
=
=
aSrc
-
>
dwUpper
)
&
&
IsOdd
(
aSrc
-
>
dwLower
)
)
;
aDest
=
static_cast
<
uint64_t
>
(
aSrc
-
>
dwLower
)
;
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
PSecHandle
&
aDest
const
uint64_t
&
aSrc
)
{
MOZ_ASSERT
(
IsOdd
(
aSrc
)
)
;
aDest
-
>
dwLower
=
static_cast
<
ULONG_PTR
>
(
aSrc
)
;
aDest
-
>
dwUpper
=
static_cast
<
ULONG_PTR
>
(
aSrc
)
;
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
OpenFileNameIPC
&
aDest
const
LPOPENFILENAMEW
&
aSrc
)
{
aDest
.
CopyFromOfn
(
aSrc
)
;
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
LPOPENFILENAMEW
&
aDest
const
OpenFileNameRetIPC
&
aSrc
)
{
aSrc
.
AddToOfn
(
aDest
)
;
}
#
endif
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
nsDependentCSubstring
&
aDest
const
char
*
const
&
aSrc
)
{
if
(
aSrc
)
{
aDest
.
Rebind
(
aSrc
strlen
(
aSrc
)
)
;
}
else
{
aDest
.
SetIsVoid
(
true
)
;
}
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
const
char
*
&
aDest
const
nsDependentCSubstring
&
aSrc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Cannot
return
const
parameters
.
"
)
;
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
nsDependentCSubstring
&
aDest
char
*
const
&
aSrc
)
{
if
(
aSrc
)
{
aDest
.
Rebind
(
aSrc
strlen
(
aSrc
)
)
;
}
else
{
aDest
.
SetIsVoid
(
true
)
;
}
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
char
*
&
aDest
const
nsDependentCSubstring
&
aSrc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Returning
char
*
parameters
is
not
yet
suported
.
"
)
;
}
#
if
defined
(
XP_WIN
)
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
IPCSchannelCred
&
aDest
const
PSCHANNEL_CRED
&
aSrc
)
{
if
(
aSrc
)
{
aDest
.
CopyFrom
(
aSrc
)
;
}
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
IPCInternetBuffers
&
aDest
const
LPINTERNET_BUFFERSA
&
aSrc
)
{
aDest
.
CopyFrom
(
aSrc
)
;
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
uint32_t
&
aDest
const
LPDWORD
&
aSrc
)
{
aDest
=
*
aSrc
;
}
template
<
>
inline
void
EndpointHandler
<
CLIENT
>
:
:
Copy
(
LPDWORD
&
aDest
const
uint32_t
&
aSrc
)
{
*
aDest
=
aSrc
;
}
#
endif
template
<
>
struct
EndpointHandler
<
SERVER
>
{
static
const
Endpoint
OtherSide
=
CLIENT
;
template
<
typename
DestType
typename
SrcType
>
inline
static
void
Copy
(
ServerCallData
*
aScd
DestType
&
aDest
const
SrcType
&
aSrc
)
{
Copy
(
aDest
aSrc
)
;
}
template
<
typename
DestType
typename
SrcType
>
inline
static
void
Copy
(
DestType
&
aDest
const
SrcType
&
aSrc
)
{
mozilla
:
:
plugins
:
:
Copy
(
aDest
aSrc
)
;
}
}
;
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
nsDependentCSubstring
&
aDest
const
nsDependentCSubstring
&
aSrc
)
{
aDest
.
Rebind
(
aSrc
.
Data
(
)
aSrc
.
Length
(
)
)
;
aDest
.
SetIsVoid
(
aSrc
.
IsVoid
(
)
)
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
nsDependentCSubstring
&
aDest
const
char
*
const
&
aSrc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Const
parameter
cannot
be
returned
by
brokering
process
.
"
)
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
nsDependentCSubstring
&
aDest
char
*
const
&
aSrc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Returning
char
*
parameters
is
not
yet
suported
.
"
)
;
}
#
if
defined
(
XP_WIN
)
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
uint64_t
&
aDest
const
PSecHandle
&
aSrc
)
{
static
uint64_t
sNextVal
=
1
;
UlongPair
key
(
aSrc
-
>
dwLower
aSrc
-
>
dwUpper
)
;
uint64_t
&
val
=
sPairToIdMap
[
key
]
;
if
(
val
=
=
0
)
{
MOZ_ASSERT
(
IsOdd
(
sNextVal
)
)
;
val
=
sNextVal
;
sIdToPairMap
[
val
]
=
key
;
sNextVal
+
=
2
;
}
aDest
=
val
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
uint64_t
&
aDest
void
*
const
&
aSrc
)
{
if
(
!
aSrc
)
{
aDest
=
0
;
return
;
}
static
uint64_t
sNextVal
=
1
;
uint64_t
&
val
=
sPtrToIdMap
[
aSrc
]
;
if
(
val
=
=
0
)
{
MOZ_ASSERT
(
IsOdd
(
sNextVal
)
)
;
val
=
sNextVal
;
sIdToPtrMap
[
val
]
=
aSrc
;
sNextVal
+
=
2
;
}
aDest
=
val
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
void
*
&
aDest
const
uint64_t
&
aSrc
)
{
aDest
=
nullptr
;
MOZ_RELEASE_ASSERT
(
IsOdd
(
aSrc
)
)
;
void
*
ptr
=
sIdToPtrMap
[
aSrc
]
;
aDest
=
reinterpret_cast
<
void
*
>
(
ptr
)
;
MOZ_RELEASE_ASSERT
(
aDest
)
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
OpenFileNameRetIPC
&
aDest
const
LPOPENFILENAMEW
&
aSrc
)
{
aDest
.
CopyFromOfn
(
aSrc
)
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
PSCHANNEL_CRED
&
aDest
const
IPCSchannelCred
&
aSrc
)
{
if
(
aDest
)
{
aSrc
.
CopyTo
(
aDest
)
;
}
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
uint32_t
&
aDest
const
LPDWORD
&
aSrc
)
{
aDest
=
*
aSrc
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
LPDWORD
&
aDest
const
uint32_t
&
aSrc
)
{
MOZ_RELEASE_ASSERT
(
aDest
)
;
*
aDest
=
aSrc
;
}
#
endif
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
ServerCallData
*
aScd
char
*
&
aDest
const
nsDependentCSubstring
&
aSrc
)
{
MOZ_ASSERT
(
aScd
)
;
if
(
aSrc
.
IsVoid
(
)
)
{
aDest
=
nullptr
;
return
;
}
aScd
-
>
AllocateMemory
(
aSrc
.
Length
(
)
+
1
aDest
)
;
memcpy
(
aDest
aSrc
.
Data
(
)
aSrc
.
Length
(
)
)
;
aDest
[
aSrc
.
Length
(
)
]
=
'
\
0
'
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
ServerCallData
*
aScd
const
char
*
&
aDest
const
nsDependentCSubstring
&
aSrc
)
{
char
*
nonConstDest
;
Copy
(
aScd
nonConstDest
aSrc
)
;
aDest
=
nonConstDest
;
}
#
if
defined
(
XP_WIN
)
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
ServerCallData
*
aScd
PSecHandle
&
aDest
const
uint64_t
&
aSrc
)
{
MOZ_ASSERT
(
!
aDest
)
;
MOZ_RELEASE_ASSERT
(
IsOdd
(
aSrc
)
)
;
aDest
=
aScd
-
>
Allocate
<
SecHandle
>
(
)
;
const
UlongPair
&
pair
=
sIdToPairMap
[
aSrc
]
;
MOZ_RELEASE_ASSERT
(
pair
.
first
|
|
pair
.
second
)
;
aDest
-
>
dwLower
=
pair
.
first
;
aDest
-
>
dwUpper
=
pair
.
second
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
ServerCallData
*
aScd
PTimeStamp
&
aDest
const
uint64_t
&
aSrc
)
{
MOZ_ASSERT
(
!
aDest
)
;
aDest
=
aScd
-
>
Allocate
<
:
:
TimeStamp
>
(
)
;
Copy
(
aDest
aSrc
)
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
ServerCallData
*
aScd
LPOPENFILENAMEW
&
aDest
const
OpenFileNameIPC
&
aSrc
)
{
MOZ_ASSERT
(
!
aDest
)
;
ServerCallData
:
:
DestructorType
*
destructor
=
[
]
(
void
*
aObj
)
{
OpenFileNameIPC
:
:
FreeOfnStrings
(
static_cast
<
LPOPENFILENAMEW
>
(
aObj
)
)
;
DeleteDestructor
<
OPENFILENAMEW
>
(
aObj
)
;
}
;
aDest
=
aScd
-
>
Allocate
<
OPENFILENAMEW
>
(
destructor
)
;
aSrc
.
AllocateOfnStrings
(
aDest
)
;
aSrc
.
AddToOfn
(
aDest
)
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
ServerCallData
*
aScd
PSCHANNEL_CRED
&
aDest
const
IPCSchannelCred
&
aSrc
)
{
MOZ_ASSERT
(
!
aDest
)
;
aDest
=
aScd
-
>
Allocate
<
SCHANNEL_CRED
>
(
)
;
Copy
(
aDest
aSrc
)
;
}
template
<
>
inline
void
EndpointHandler
<
SERVER
>
:
:
Copy
(
ServerCallData
*
aScd
LPINTERNET_BUFFERSA
&
aDest
const
IPCInternetBuffers
&
aSrc
)
{
MOZ_ASSERT
(
!
aDest
)
;
aSrc
.
CopyTo
(
aDest
)
;
ServerCallData
:
:
DestructorType
*
destructor
=
[
]
(
void
*
aObj
)
{
LPINTERNET_BUFFERSA
inetBuf
=
static_cast
<
LPINTERNET_BUFFERSA
>
(
aObj
)
;
IPCInternetBuffers
:
:
FreeBuffers
(
inetBuf
)
;
FreeDestructor
(
inetBuf
)
;
}
;
aScd
-
>
PostDestructor
(
aDest
destructor
)
;
}
#
endif
template
<
Endpoint
endpoint
typename
PhaseHandler
>
struct
Marshaler
{
template
<
int
firstIndex
=
0
typename
.
.
.
VarParams
>
static
void
Marshal
(
IpdlTuple
&
aMarshaledTuple
const
VarParams
&
.
.
.
aParams
)
{
MarshalParameters
<
firstIndex
>
(
aMarshaledTuple
aParams
.
.
.
)
;
}
template
<
int
firstIndex
=
0
typename
.
.
.
VarParams
>
static
bool
Unmarshal
(
IpdlTupleContext
&
aUnmarshaledTuple
VarParams
&
.
.
.
aParams
)
{
return
UnmarshalParameters
<
firstIndex
>
(
aUnmarshaledTuple
0
aParams
.
.
.
)
;
}
template
<
int
paramIndex
typename
OrigType
bool
shouldMarshal
=
PhaseHandler
:
:
Info
:
:
template
ShouldMarshal
<
paramIndex
>
:
:
value
>
struct
MaybeMarshalParameter
{
}
;
template
<
int
paramIndex
typename
OrigType
>
struct
MaybeMarshalParameter
<
paramIndex
OrigType
true
>
{
template
<
typename
IPCType
=
typename
PhaseHandler
:
:
template
IPCTypeMap
<
OrigType
>
:
:
ipc_type
>
static
void
MarshalParameter
(
IpdlTuple
&
aMarshaledTuple
const
OrigType
&
aParam
)
{
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
%
s
marshaling
parameter
%
d
.
"
EndpointMsg
(
endpoint
)
paramIndex
)
)
;
IPCType
ipcObject
;
EndpointHandler
<
endpoint
>
:
:
Copy
(
ipcObject
aParam
)
;
LogParameterValue
(
paramIndex
ipcObject
)
;
aMarshaledTuple
.
AddElement
(
ipcObject
)
;
}
}
;
template
<
int
paramIndex
typename
OrigType
>
struct
MaybeMarshalParameter
<
paramIndex
OrigType
false
>
{
static
void
MarshalParameter
(
IpdlTuple
&
aMarshaledTuple
const
OrigType
&
aParam
)
{
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
%
s
not
marshaling
parameter
%
d
.
"
EndpointMsg
(
endpoint
)
paramIndex
)
)
;
}
}
;
template
<
int
paramIndex
typename
VarParam
typename
.
.
.
VarParams
>
static
void
MarshalParameters
(
IpdlTuple
&
aMarshaledTuple
const
VarParam
&
aFirstParam
const
VarParams
&
.
.
.
aRemainingParams
)
{
MaybeMarshalParameter
<
paramIndex
VarParam
>
:
:
MarshalParameter
(
aMarshaledTuple
aFirstParam
)
;
MarshalParameters
<
paramIndex
+
1
VarParams
.
.
.
>
(
aMarshaledTuple
aRemainingParams
.
.
.
)
;
}
template
<
int
paramIndex
>
static
void
MarshalParameters
(
IpdlTuple
&
aMarshaledTuple
)
{
}
template
<
int
tupleIndex
typename
OrigType
bool
shouldMarshal
=
PhaseHandler
:
:
Info
:
:
template
ShouldMarshal
<
tupleIndex
>
:
:
value
bool
hasFixedValue
=
PhaseHandler
:
:
Info
:
:
template
HasFixedValue
<
tupleIndex
>
:
:
value
>
struct
MaybeUnmarshalParameter
{
}
;
template
<
int
tupleIndex
typename
VarParam
>
struct
MaybeUnmarshalParameter
<
tupleIndex
VarParam
true
false
>
{
template
<
typename
IPCType
=
typename
PhaseHandler
:
:
template
IPCTypeMap
<
VarParam
>
:
:
ipc_type
>
static
inline
bool
UnmarshalParameter
(
IpdlTupleContext
&
aUnmarshaledTuple
int
&
aNextTupleIdx
VarParam
&
aParam
)
{
const
IPCType
*
ipcObject
=
aUnmarshaledTuple
.
GetIpdlTuple
(
)
-
>
Element
<
IPCType
>
(
aNextTupleIdx
)
;
if
(
!
ipcObject
)
{
HOOK_LOG
(
LogLevel
:
:
Error
(
"
%
s
failed
to
unmarshal
parameter
%
d
.
"
EndpointMsg
(
endpoint
)
tupleIndex
)
)
;
return
false
;
}
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
%
s
unmarshaled
parameter
%
d
.
"
EndpointMsg
(
endpoint
)
tupleIndex
)
)
;
LogParameterValue
(
tupleIndex
*
ipcObject
)
;
EndpointHandler
<
endpoint
>
:
:
Copy
(
aUnmarshaledTuple
.
GetServerCallData
(
)
aParam
*
ipcObject
)
;
+
+
aNextTupleIdx
;
return
true
;
}
}
;
template
<
int
tupleIndex
>
struct
MaybeUnmarshalParameter
<
tupleIndex
nsDependentCSubstring
true
false
>
{
static
inline
bool
UnmarshalParameter
(
IpdlTupleContext
&
aUnmarshaledTuple
int
&
aNextTupleIdx
nsDependentCSubstring
&
aParam
)
{
const
nsCString
*
ipcObject
=
aUnmarshaledTuple
.
GetIpdlTuple
(
)
-
>
Element
<
nsCString
>
(
aNextTupleIdx
)
;
if
(
!
ipcObject
)
{
HOOK_LOG
(
LogLevel
:
:
Error
(
"
%
s
failed
to
unmarshal
parameter
%
d
.
"
EndpointMsg
(
endpoint
)
tupleIndex
)
)
;
return
false
;
}
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
%
s
unmarshaled
parameter
%
d
.
"
EndpointMsg
(
endpoint
)
tupleIndex
)
)
;
aParam
.
Rebind
(
ipcObject
-
>
Data
(
)
ipcObject
-
>
Length
(
)
)
;
aParam
.
SetIsVoid
(
ipcObject
-
>
IsVoid
(
)
)
;
LogParameterValue
(
tupleIndex
aParam
)
;
+
+
aNextTupleIdx
;
return
true
;
}
}
;
template
<
int
tupleIndex
>
struct
MaybeUnmarshalParameter
<
tupleIndex
char
*
true
false
>
{
static
inline
bool
UnmarshalParameter
(
IpdlTupleContext
&
aUnmarshaledTuple
int
&
aNextTupleIdx
char
*
&
aParam
)
{
nsDependentCSubstring
tempStr
;
bool
ret
=
MaybeUnmarshalParameter
<
tupleIndex
nsDependentCSubstring
true
false
>
:
:
UnmarshalParameter
(
aUnmarshaledTuple
aNextTupleIdx
tempStr
)
;
EndpointHandler
<
endpoint
>
:
:
Copy
(
aUnmarshaledTuple
.
GetServerCallData
(
)
aParam
tempStr
)
;
return
ret
;
}
}
;
template
<
int
tupleIndex
>
struct
MaybeUnmarshalParameter
<
tupleIndex
const
char
*
true
false
>
{
static
inline
bool
UnmarshalParameter
(
IpdlTupleContext
&
aUnmarshaledTuple
int
&
aNextTupleIdx
const
char
*
&
aParam
)
{
char
*
tempStr
;
bool
ret
=
MaybeUnmarshalParameter
<
tupleIndex
char
*
true
false
>
:
:
UnmarshalParameter
(
aUnmarshaledTuple
aNextTupleIdx
tempStr
)
;
aParam
=
tempStr
;
return
ret
;
}
}
;
template
<
int
tupleIndex
typename
VarParam
>
struct
MaybeUnmarshalParameter
<
tupleIndex
VarParam
false
true
>
{
static
inline
bool
UnmarshalParameter
(
IpdlTupleContext
&
aUnmarshaledTuple
int
&
aNextTupleIdx
VarParam
&
aParam
)
{
PhaseHandler
:
:
template
CopyFixedParam
<
tupleIndex
VarParam
>
(
aParam
)
;
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
%
s
parameter
%
d
not
unmarshaling
-
-
using
fixed
value
.
"
EndpointMsg
(
endpoint
)
tupleIndex
)
)
;
LogParameterValue
(
tupleIndex
aParam
)
;
return
true
;
}
}
;
template
<
int
tupleIndex
typename
VarParam
>
struct
MaybeUnmarshalParameter
<
tupleIndex
VarParam
false
false
>
{
static
inline
bool
UnmarshalParameter
(
IpdlTupleContext
&
aUnmarshaledTuple
int
&
aNextTupleIdx
VarParam
&
aParam
)
{
HOOK_LOG
(
LogLevel
:
:
Verbose
(
"
%
s
parameter
%
d
not
automatically
unmarshaling
.
"
EndpointMsg
(
endpoint
)
tupleIndex
)
)
;
return
true
;
}
}
;
template
<
int
tupleIndex
typename
VarParam
typename
.
.
.
VarParams
>
static
bool
UnmarshalParameters
(
IpdlTupleContext
&
aUnmarshaledTuple
int
aNextTupleIdx
VarParam
&
aFirstParam
VarParams
&
.
.
.
aRemainingParams
)
{
if
(
!
MaybeUnmarshalParameter
<
tupleIndex
VarParam
>
:
:
UnmarshalParameter
(
aUnmarshaledTuple
aNextTupleIdx
aFirstParam
)
)
{
return
false
;
}
return
UnmarshalParameters
<
tupleIndex
+
1
VarParams
.
.
.
>
(
aUnmarshaledTuple
aNextTupleIdx
aRemainingParams
.
.
.
)
;
}
template
<
int
>
static
bool
UnmarshalParameters
(
IpdlTupleContext
&
aUnmarshaledTuple
int
aNextTupleIdx
)
{
return
true
;
}
}
;
template
<
FunctionHookId
functionId
>
struct
RequestInfo
{
template
<
int
paramIndex
>
struct
FixedValue
;
template
<
int
paramIndex
typename
=
int
>
struct
HasFixedValue
{
static
const
bool
value
=
false
;
}
;
template
<
int
paramIndex
>
struct
HasFixedValue
<
paramIndex
decltype
(
FixedValue
<
paramIndex
>
:
:
value
0
)
>
{
static
const
bool
value
=
true
;
}
;
template
<
int
paramIndex
>
struct
ShouldMarshal
{
static
const
bool
value
=
!
HasFixedValue
<
paramIndex
>
:
:
value
;
}
;
}
;
struct
RequestHandlerBase
{
template
<
typename
OrigType
>
struct
IPCTypeMap
{
typedef
typename
mozilla
:
:
plugins
:
:
IPCTypeMap
<
OrigType
>
:
:
ipc_type
ipc_type
;
}
;
}
;
#
if
defined
(
XP_WIN
)
template
<
>
struct
RequestHandlerBase
:
:
IPCTypeMap
<
LPOPENFILENAMEW
>
{
typedef
OpenFileNameIPC
ipc_type
;
}
;
#
endif
template
<
FunctionHookId
functionId
typename
FunctionType
>
struct
RequestHandler
;
template
<
FunctionHookId
functionId
typename
ResultType
typename
.
.
.
ParamTypes
>
struct
RequestHandler
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
:
public
RequestHandlerBase
{
typedef
ResultType
(
HOOK_CALL
FunctionType
)
(
ParamTypes
.
.
.
)
;
typedef
RequestHandler
<
functionId
FunctionType
>
SelfType
;
typedef
RequestInfo
<
functionId
>
Info
;
static
void
Marshal
(
IpdlTuple
&
aTuple
const
ParamTypes
&
.
.
.
aParams
)
{
ReqMarshaler
:
:
Marshal
(
aTuple
aParams
.
.
.
)
;
}
static
bool
Unmarshal
(
ServerCallData
&
aScd
const
IpdlTuple
&
aTuple
ParamTypes
&
.
.
.
aParams
)
{
IpdlTupleContext
cxt
(
&
aTuple
&
aScd
)
;
return
ReqUnmarshaler
:
:
Unmarshal
(
cxt
aParams
.
.
.
)
;
}
typedef
Marshaler
<
CLIENT
SelfType
>
ReqMarshaler
;
typedef
Marshaler
<
SERVER
SelfType
>
ReqUnmarshaler
;
static
bool
ShouldBroker
(
Endpoint
aEndpoint
const
ParamTypes
&
.
.
.
aParams
)
{
return
CheckFixedParams
(
aParams
.
.
.
)
;
}
template
<
int
paramIndex
typename
VarParam
>
static
void
CopyFixedParam
(
VarParam
&
aParam
)
{
aParam
=
Info
:
:
template
FixedValue
<
paramIndex
>
:
:
value
;
}
protected
:
static
bool
CheckFixedParams
(
const
ParamTypes
&
.
.
.
aParams
)
{
return
CheckFixedParamsHelper
<
0
>
(
aParams
.
.
.
)
;
}
template
<
int
paramIndex
typename
=
int
>
struct
CheckFixedParam
{
template
<
typename
ParamType
>
static
inline
bool
Check
(
const
ParamType
&
aParam
)
{
return
true
;
}
}
;
template
<
int
paramIndex
>
struct
CheckFixedParam
<
paramIndex
decltype
(
Info
:
:
template
FixedValue
<
paramIndex
>
:
:
value
0
)
>
{
template
<
typename
ParamType
>
static
inline
bool
Check
(
ParamType
&
aParam
)
{
return
ParameterEquality
(
aParam
Info
:
:
template
FixedValue
<
paramIndex
>
:
:
value
)
;
}
}
;
template
<
int
index
typename
VarParam
typename
.
.
.
VarParams
>
static
bool
CheckFixedParamsHelper
(
const
VarParam
&
aParam
const
VarParams
&
.
.
.
aParams
)
{
if
(
!
CheckFixedParam
<
index
>
:
:
Check
(
aParam
)
)
{
return
false
;
}
return
CheckFixedParamsHelper
<
index
+
1
>
(
aParams
.
.
.
)
;
}
template
<
int
>
static
bool
CheckFixedParamsHelper
(
)
{
return
true
;
}
}
;
template
<
FunctionHookId
functionId
>
struct
ResponseInfo
{
template
<
int
paramIndex
>
struct
HasFixedValue
{
static
const
bool
value
=
RequestInfo
<
functionId
>
:
:
template
HasFixedValue
<
paramIndex
>
:
:
value
;
}
;
template
<
int
paramIndex
>
struct
ShouldMarshal
{
static
const
bool
value
=
(
paramIndex
=
=
-
1
)
;
}
;
template
<
typename
ResultType
>
static
bool
ShouldTransmitError
(
const
ResultType
&
aResult
)
{
return
!
static_cast
<
bool
>
(
aResult
)
;
}
}
;
struct
ResponseHandlerBase
{
template
<
typename
OrigType
>
struct
IPCTypeMap
{
typedef
typename
mozilla
:
:
plugins
:
:
IPCTypeMap
<
OrigType
>
:
:
ipc_type
ipc_type
;
}
;
}
;
#
if
defined
(
XP_WIN
)
template
<
>
struct
ResponseHandlerBase
:
:
IPCTypeMap
<
LPOPENFILENAMEW
>
{
typedef
OpenFileNameRetIPC
ipc_type
;
}
;
#
endif
template
<
FunctionHookId
functionId
typename
FunctionType
>
struct
ResponseHandler
;
template
<
FunctionHookId
functionId
typename
ResultType
typename
.
.
.
ParamTypes
>
struct
ResponseHandler
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
:
public
ResponseHandlerBase
{
typedef
ResultType
(
HOOK_CALL
FunctionType
)
(
ParamTypes
.
.
.
)
;
typedef
ResponseHandler
<
functionId
FunctionType
>
SelfType
;
typedef
ResponseInfo
<
functionId
>
Info
;
static
void
Marshal
(
IpdlTuple
&
aTuple
const
ResultType
&
aResult
const
ParamTypes
&
.
.
.
aParams
)
{
RspMarshaler
:
:
template
Marshal
<
-
1
>
(
aTuple
aResult
aParams
.
.
.
)
;
}
static
bool
Unmarshal
(
const
IpdlTuple
&
aTuple
ResultType
&
aResult
ParamTypes
&
.
.
.
aParams
)
{
IpdlTupleContext
cxt
(
&
aTuple
)
;
return
RspUnmarshaler
:
:
template
Unmarshal
<
-
1
>
(
cxt
aResult
aParams
.
.
.
)
;
}
typedef
Marshaler
<
SERVER
SelfType
>
RspMarshaler
;
typedef
Marshaler
<
CLIENT
SelfType
>
RspUnmarshaler
;
template
<
int
tupleIndex
typename
VarParam
>
static
void
CopyFixedParam
(
VarParam
&
aParam
)
{
}
}
;
template
<
FunctionHookId
functionId
typename
FunctionType
>
class
FunctionBroker
;
template
<
FunctionHookId
functionId
typename
ResultType
typename
.
.
.
ParamTypes
>
class
FunctionBroker
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
:
public
BasicFunctionHook
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
{
public
:
typedef
Tuple
<
ParamTypes
.
.
.
>
TupleParamTypes
;
typedef
Tuple
<
mozilla
:
:
Maybe
<
ParamTypes
>
.
.
.
>
TupleMaybeParamTypes
;
typedef
Tuple
<
ParamTypes
*
.
.
.
>
TupleParamPtrTypes
;
typedef
Tuple
<
ParamTypes
&
.
.
.
>
TupleParamRefTypes
;
static
const
size_t
numParams
=
sizeof
.
.
.
(
ParamTypes
)
;
typedef
ResultType
(
HOOK_CALL
FunctionType
)
(
ParamTypes
.
.
.
)
;
typedef
FunctionBroker
<
functionId
FunctionType
>
SelfType
;
typedef
BasicFunctionHook
<
functionId
FunctionType
>
FunctionHookInfoType
;
typedef
FunctionHookInfoType
BaseType
;
typedef
RequestHandler
<
functionId
FunctionType
>
Request
;
typedef
ResponseHandler
<
functionId
FunctionType
>
Response
;
FunctionBroker
(
const
char
*
aModuleName
const
char
*
aMethodName
FunctionType
*
aOriginalFunction
)
:
BasicFunctionHook
<
functionId
FunctionType
>
(
aModuleName
aMethodName
aOriginalFunction
InterceptorStub
)
{
}
static
ResultType
HOOK_CALL
InterceptorStub
(
ParamTypes
.
.
.
aParams
)
{
MOZ_ASSERT
(
functionId
<
FunctionHook
:
:
GetHooks
(
)
-
>
Length
(
)
)
;
FunctionHook
*
self
=
FunctionHook
:
:
GetHooks
(
)
-
>
ElementAt
(
functionId
)
;
MOZ_ASSERT
(
self
&
&
self
-
>
FunctionId
(
)
=
=
functionId
)
;
const
SelfType
*
broker
=
static_cast
<
const
SelfType
*
>
(
self
)
;
return
broker
-
>
MaybeBrokerCallClient
(
aParams
.
.
.
)
;
}
ResultType
MaybeBrokerCallClient
(
ParamTypes
&
.
.
.
aParameters
)
const
;
bool
RunOriginalFunction
(
base
:
:
ProcessId
aClientId
const
IPC
:
:
IpdlTuple
&
aInTuple
IPC
:
:
IpdlTuple
*
aOutTuple
)
const
override
{
return
BrokerCallServer
(
aClientId
aInTuple
aOutTuple
)
;
}
protected
:
bool
BrokerCallServer
(
base
:
:
ProcessId
aClientId
const
IpdlTuple
&
aInTuple
IpdlTuple
*
aOutTuple
)
const
{
return
BrokerCallServer
(
aClientId
aInTuple
aOutTuple
std
:
:
index_sequence_for
<
ParamTypes
.
.
.
>
{
}
)
;
}
bool
BrokerCallClient
(
uint32_t
&
aWinError
ResultType
&
aResult
ParamTypes
&
.
.
.
aParameters
)
const
;
bool
PostToDispatchThread
(
uint32_t
&
aWinError
ResultType
&
aRet
ParamTypes
&
.
.
.
aParameters
)
const
;
static
void
PostToDispatchHelper
(
const
SelfType
*
bmhi
Monitor
*
monitor
bool
*
notified
bool
*
ok
uint32_t
*
winErr
ResultType
*
r
ParamTypes
*
.
.
.
p
)
{
MOZ_ASSERT
(
bmhi
&
&
monitor
&
&
notified
&
&
ok
&
&
winErr
&
&
r
)
;
MOZ_ASSERT
(
*
notified
=
=
false
)
;
*
ok
=
bmhi
-
>
BrokerCallClient
(
*
winErr
*
r
*
p
.
.
.
)
;
MonitorAutoLock
lock
(
*
monitor
)
;
*
notified
=
true
;
monitor
-
>
Notify
(
)
;
}
;
template
<
typename
.
.
.
VarParams
>
ResultType
RunFunction
(
FunctionType
*
aFunction
base
:
:
ProcessId
aClientId
VarParams
&
.
.
.
aParams
)
const
{
return
aFunction
(
aParams
.
.
.
)
;
}
;
bool
BrokerCallServer
(
base
:
:
ProcessId
aClientId
const
IpdlTuple
&
aInTuple
IpdlTuple
*
aOutTuple
ParamTypes
&
.
.
.
aParams
)
const
;
template
<
size_t
.
.
.
Indices
>
bool
BrokerCallServer
(
base
:
:
ProcessId
aClientId
const
IpdlTuple
&
aInTuple
IpdlTuple
*
aOutTuple
std
:
:
index_sequence
<
Indices
.
.
.
>
)
const
{
TupleParamTypes
paramTuple
;
return
BrokerCallServer
(
aClientId
aInTuple
aOutTuple
Get
<
Indices
>
(
paramTuple
)
.
.
.
)
;
}
}
;
template
<
FunctionHookId
functionId
typename
ResultType
typename
.
.
.
ParamTypes
>
ResultType
FunctionBroker
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
:
:
MaybeBrokerCallClient
(
ParamTypes
&
.
.
.
aParameters
)
const
{
MOZ_ASSERT
(
FunctionBrokerChild
:
:
GetInstance
(
)
)
;
if
(
!
FunctionBrokerChild
:
:
GetInstance
(
)
)
{
HOOK_LOG
(
LogLevel
:
:
Error
(
"
[
%
s
]
Client
attempted
to
broker
call
without
actor
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
}
else
if
(
Request
:
:
ShouldBroker
(
CLIENT
aParameters
.
.
.
)
)
{
HOOK_LOG
(
LogLevel
:
:
Debug
(
"
[
%
s
]
Client
attempting
to
broker
call
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
uint32_t
winError
;
ResultType
ret
;
bool
success
=
BrokerCallClient
(
winError
ret
aParameters
.
.
.
)
;
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Client
brokering
%
s
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
SuccessMsg
(
success
)
)
)
;
if
(
success
)
{
#
if
defined
(
XP_WIN
)
if
(
Response
:
:
Info
:
:
ShouldTransmitError
(
ret
)
)
{
HOOK_LOG
(
LogLevel
:
:
Debug
(
"
[
%
s
]
Client
setting
thread
error
code
:
%
08x
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
winError
)
)
;
:
:
SetLastError
(
winError
)
;
}
#
endif
return
ret
;
}
}
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Client
could
not
broker
.
Running
original
version
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
return
FunctionHookInfoType
:
:
mOldFunction
(
aParameters
.
.
.
)
;
}
template
<
FunctionHookId
functionId
typename
ResultType
typename
.
.
.
ParamTypes
>
bool
FunctionBroker
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
:
:
BrokerCallClient
(
uint32_t
&
aWinError
ResultType
&
aResult
ParamTypes
&
.
.
.
aParameters
)
const
{
if
(
!
FunctionBrokerChild
:
:
GetInstance
(
)
-
>
IsDispatchThread
(
)
)
{
return
PostToDispatchThread
(
aWinError
aResult
aParameters
.
.
.
)
;
}
if
(
FunctionBrokerChild
:
:
GetInstance
(
)
)
{
IpdlTuple
sending
returned
;
HOOK_LOG
(
LogLevel
:
:
Debug
(
"
[
%
s
]
Client
marshaling
parameters
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
Request
:
:
Marshal
(
sending
aParameters
.
.
.
)
;
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Client
sending
broker
message
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
if
(
FunctionBrokerChild
:
:
GetInstance
(
)
-
>
SendBrokerFunction
(
FunctionHookInfoType
:
:
FunctionId
(
)
sending
&
returned
)
)
{
HOOK_LOG
(
LogLevel
:
:
Debug
(
"
[
%
s
]
Client
received
broker
message
response
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
bool
success
=
Response
:
:
Unmarshal
(
returned
aResult
aParameters
.
.
.
)
;
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Client
response
unmarshaling
:
%
s
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
SuccessMsg
(
success
)
)
)
;
#
if
defined
(
XP_WIN
)
if
(
success
&
&
Response
:
:
Info
:
:
ShouldTransmitError
(
aResult
)
)
{
uint32_t
*
winError
=
returned
.
Element
<
UINT32
>
(
returned
.
NumElements
(
)
-
1
)
;
if
(
!
winError
)
{
HOOK_LOG
(
LogLevel
:
:
Error
(
"
[
%
s
]
Client
failed
to
unmarshal
error
code
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
return
false
;
}
HOOK_LOG
(
LogLevel
:
:
Debug
(
"
[
%
s
]
Client
response
unmarshaled
error
code
:
%
08x
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
*
winError
)
)
;
aWinError
=
*
winError
;
}
#
endif
return
success
;
}
}
HOOK_LOG
(
LogLevel
:
:
Error
(
"
[
%
s
]
Client
failed
to
broker
call
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
return
false
;
}
template
<
FunctionHookId
functionId
typename
ResultType
typename
.
.
.
ParamTypes
>
bool
FunctionBroker
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
:
:
BrokerCallServer
(
base
:
:
ProcessId
aClientId
const
IpdlTuple
&
aInTuple
IpdlTuple
*
aOutTuple
ParamTypes
&
.
.
.
aParams
)
const
{
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Server
brokering
function
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
ServerCallData
scd
;
if
(
!
Request
:
:
Unmarshal
(
scd
aInTuple
aParams
.
.
.
)
)
{
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Server
failed
to
unmarshal
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
return
false
;
}
if
(
!
Request
:
:
ShouldBroker
(
SERVER
aParams
.
.
.
)
)
{
HOOK_LOG
(
LogLevel
:
:
Error
(
"
[
%
s
]
Server
rejected
brokering
request
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
return
false
;
}
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Server
broker
running
function
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
ResultType
ret
=
RunFunction
(
FunctionHookInfoType
:
:
mOldFunction
aClientId
aParams
.
.
.
)
;
#
if
defined
(
XP_WIN
)
uint32_t
err
=
UINT_MAX
;
bool
transmitError
=
Response
:
:
Info
:
:
ShouldTransmitError
(
ret
)
;
if
(
transmitError
)
{
err
=
:
:
GetLastError
(
)
;
HOOK_LOG
(
LogLevel
:
:
Info
(
"
[
%
s
]
Server
returning
thread
error
code
:
%
08x
.
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
err
)
)
;
}
#
endif
Response
:
:
Marshal
(
*
aOutTuple
ret
aParams
.
.
.
)
;
#
if
defined
(
XP_WIN
)
if
(
transmitError
)
{
aOutTuple
-
>
AddElement
(
err
)
;
}
#
endif
return
true
;
}
template
<
FunctionHookId
functionId
typename
ResultType
typename
.
.
.
ParamTypes
>
bool
FunctionBroker
<
functionId
ResultType
HOOK_CALL
(
ParamTypes
.
.
.
)
>
:
:
PostToDispatchThread
(
uint32_t
&
aWinError
ResultType
&
aRet
ParamTypes
&
.
.
.
aParameters
)
const
{
MOZ_ASSERT
(
!
FunctionBrokerChild
:
:
GetInstance
(
)
-
>
IsDispatchThread
(
)
)
;
HOOK_LOG
(
LogLevel
:
:
Debug
(
"
Posting
broker
task
'
%
s
'
to
dispatch
thread
"
FunctionHookInfoType
:
:
mFunctionName
.
Data
(
)
)
)
;
Monitor
monitor
(
"
FunctionDispatchThread
Lock
"
)
;
MonitorAutoLock
lock
(
monitor
)
;
bool
success
=
false
;
bool
notified
=
false
;
FunctionBrokerChild
:
:
GetInstance
(
)
-
>
PostToDispatchThread
(
NewRunnableFunction
(
"
FunctionDispatchThreadRunnable
"
&
PostToDispatchHelper
this
&
monitor
&
notified
&
success
&
aWinError
&
aRet
&
aParameters
.
.
.
)
)
;
while
(
!
notified
)
{
monitor
.
Wait
(
)
;
}
return
success
;
}
void
AddBrokeredFunctionHooks
(
FunctionHookArray
&
aHooks
)
;
}
}
#
endif
