#
include
"
nptest_platform
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
<
CoreServices
/
CoreServices
.
h
>
#
include
<
algorithm
>
bool
pluginSupportsWindowMode
(
)
{
return
false
;
}
bool
pluginSupportsWindowlessMode
(
)
{
return
true
;
}
NPError
pluginInstanceInit
(
InstanceData
*
instanceData
)
{
NPP
npp
=
instanceData
-
>
npp
;
NPBool
supportsCoreGraphics
=
false
;
if
(
(
NPN_GetValue
(
npp
NPNVsupportsCoreGraphicsBool
&
supportsCoreGraphics
)
=
=
NPERR_NO_ERROR
)
&
&
supportsCoreGraphics
)
{
NPN_SetValue
(
npp
NPPVpluginDrawingModel
(
void
*
)
NPDrawingModelCoreGraphics
)
;
}
else
{
printf
(
"
CoreGraphics
drawing
model
not
supported
can
'
t
create
a
plugin
instance
.
\
n
"
)
;
return
NPERR_INCOMPATIBLE_VERSION_ERROR
;
}
NPBool
supportsCocoaEvents
=
false
;
if
(
(
NPN_GetValue
(
npp
NPNVsupportsCocoaBool
&
supportsCocoaEvents
)
=
=
NPERR_NO_ERROR
)
&
&
supportsCocoaEvents
)
{
NPN_SetValue
(
npp
NPPVpluginEventModel
(
void
*
)
NPEventModelCocoa
)
;
instanceData
-
>
eventModel
=
NPEventModelCocoa
;
}
else
{
printf
(
"
Cocoa
event
model
not
supported
can
'
t
create
a
plugin
instance
.
\
n
"
)
;
return
NPERR_INCOMPATIBLE_VERSION_ERROR
;
}
return
NPERR_NO_ERROR
;
}
void
pluginInstanceShutdown
(
InstanceData
*
instanceData
)
{
}
static
bool
RectEquals
(
const
NPRect
&
r1
const
NPRect
&
r2
)
{
return
r1
.
left
=
=
r2
.
left
&
&
r1
.
top
=
=
r2
.
top
&
&
r1
.
right
=
=
r2
.
right
&
&
r1
.
bottom
=
=
r2
.
bottom
;
}
void
pluginDoSetWindow
(
InstanceData
*
instanceData
NPWindow
*
newWindow
)
{
int32_t
oldX
=
instanceData
-
>
window
.
x
;
int32_t
oldY
=
instanceData
-
>
window
.
y
;
bool
clipChanged
=
!
RectEquals
(
instanceData
-
>
window
.
clipRect
newWindow
-
>
clipRect
)
;
instanceData
-
>
window
=
*
newWindow
;
if
(
!
clipChanged
)
{
instanceData
-
>
window
.
x
=
oldX
;
instanceData
-
>
window
.
y
=
oldY
;
}
}
void
pluginWidgetInit
(
InstanceData
*
instanceData
void
*
oldWindow
)
{
}
static
void
GetColorsFromRGBA
(
uint32_t
rgba
float
*
r
float
*
g
float
*
b
float
*
a
)
{
*
b
=
(
rgba
&
0xFF
)
/
255
.
0
;
*
g
=
(
(
rgba
&
0xFF00
)
>
>
8
)
/
255
.
0
;
*
r
=
(
(
rgba
&
0xFF0000
)
>
>
16
)
/
255
.
0
;
*
a
=
(
(
rgba
&
0xFF000000
)
>
>
24
)
/
255
.
0
;
}
static
void
pluginDraw
(
InstanceData
*
instanceData
NPCocoaEvent
*
event
)
{
if
(
!
instanceData
)
return
;
notifyDidPaint
(
instanceData
)
;
NPP
npp
=
instanceData
-
>
npp
;
if
(
!
npp
)
return
;
const
char
*
uaString
=
NPN_UserAgent
(
npp
)
;
if
(
!
uaString
)
return
;
NPWindow
window
=
instanceData
-
>
window
;
CGContextRef
cgContext
=
event
-
>
data
.
draw
.
context
;
float
windowWidth
=
window
.
width
;
float
windowHeight
=
window
.
height
;
switch
(
instanceData
-
>
scriptableObject
-
>
drawMode
)
{
case
DM_DEFAULT
:
{
CFStringRef
uaCFString
=
CFStringCreateWithCString
(
kCFAllocatorDefault
uaString
kCFStringEncodingASCII
)
;
CGContextSaveGState
(
cgContext
)
;
CGContextTranslateCTM
(
cgContext
0
.
0
windowHeight
)
;
CGContextScaleCTM
(
cgContext
1
.
0
-
1
.
0
)
;
CGContextAddRect
(
cgContext
CGRectMake
(
0
0
windowWidth
windowHeight
)
)
;
CGContextSetGrayFillColor
(
cgContext
0
.
5
1
.
0
)
;
CGContextDrawPath
(
cgContext
kCGPathFill
)
;
CGContextAddRect
(
cgContext
CGRectMake
(
0
0
windowWidth
windowHeight
)
)
;
CGContextSetGrayStrokeColor
(
cgContext
0
.
0
1
.
0
)
;
CGContextSetLineWidth
(
cgContext
6
.
0
)
;
CGContextStrokePath
(
cgContext
)
;
CGContextSetTextMatrix
(
cgContext
CGAffineTransformIdentity
)
;
CGMutablePathRef
path
=
CGPathCreateMutable
(
)
;
CGRect
bounds
=
CGRectMake
(
10
.
0
10
.
0
std
:
:
max
(
0
.
0
windowWidth
-
20
.
0
)
std
:
:
max
(
0
.
0
windowHeight
-
20
.
0
)
)
;
CGPathAddRect
(
path
NULL
bounds
)
;
CFMutableAttributedStringRef
attrString
=
CFAttributedStringCreateMutable
(
kCFAllocatorDefault
0
)
;
CFAttributedStringReplaceString
(
attrString
CFRangeMake
(
0
0
)
uaCFString
)
;
CGColorSpaceRef
rgbColorSpace
=
CGColorSpaceCreateDeviceRGB
(
)
;
CGFloat
components
[
]
=
{
0
.
0
0
.
0
0
.
0
1
.
0
}
;
CGColorRef
red
=
CGColorCreate
(
rgbColorSpace
components
)
;
CGColorSpaceRelease
(
rgbColorSpace
)
;
CFAttributedStringSetAttribute
(
attrString
CFRangeMake
(
0
50
)
kCTForegroundColorAttributeName
red
)
;
CTFramesetterRef
framesetter
=
CTFramesetterCreateWithAttributedString
(
attrString
)
;
CFRelease
(
attrString
)
;
CTFrameRef
frame
=
CTFramesetterCreateFrame
(
framesetter
CFRangeMake
(
0
0
)
path
NULL
)
;
CFRelease
(
framesetter
)
;
if
(
frame
)
{
CTFrameDraw
(
frame
cgContext
)
;
CFRelease
(
frame
)
;
}
CGContextRestoreGState
(
cgContext
)
;
break
;
}
case
DM_SOLID_COLOR
:
{
CGContextSaveGState
(
cgContext
)
;
CGContextTranslateCTM
(
cgContext
0
.
0
windowHeight
)
;
CGContextScaleCTM
(
cgContext
1
.
0
-
1
.
0
)
;
CGContextAddRect
(
cgContext
CGRectMake
(
0
0
windowWidth
windowHeight
)
)
;
float
r
g
b
a
;
GetColorsFromRGBA
(
instanceData
-
>
scriptableObject
-
>
drawColor
&
r
&
g
&
b
&
a
)
;
CGContextSetRGBFillColor
(
cgContext
r
g
b
a
)
;
CGContextDrawPath
(
cgContext
kCGPathFill
)
;
CGContextRestoreGState
(
cgContext
)
;
break
;
}
}
}
int16_t
pluginHandleEvent
(
InstanceData
*
instanceData
void
*
event
)
{
NPCocoaEvent
*
cocoaEvent
=
(
NPCocoaEvent
*
)
event
;
if
(
!
cocoaEvent
)
return
kNPEventNotHandled
;
switch
(
cocoaEvent
-
>
type
)
{
case
NPCocoaEventDrawRect
:
pluginDraw
(
instanceData
cocoaEvent
)
;
break
;
case
NPCocoaEventMouseDown
:
case
NPCocoaEventMouseUp
:
case
NPCocoaEventMouseMoved
:
case
NPCocoaEventMouseDragged
:
instanceData
-
>
lastMouseX
=
(
int32_t
)
cocoaEvent
-
>
data
.
mouse
.
pluginX
;
instanceData
-
>
lastMouseY
=
(
int32_t
)
cocoaEvent
-
>
data
.
mouse
.
pluginY
;
if
(
cocoaEvent
-
>
type
=
=
NPCocoaEventMouseUp
)
{
instanceData
-
>
mouseUpEventCount
+
+
;
}
break
;
case
NPCocoaEventWindowFocusChanged
:
instanceData
-
>
topLevelWindowActivationState
=
cocoaEvent
-
>
data
.
focus
.
hasFocus
?
ACTIVATION_STATE_ACTIVATED
:
ACTIVATION_STATE_DEACTIVATED
;
instanceData
-
>
topLevelWindowActivationEventCount
=
instanceData
-
>
topLevelWindowActivationEventCount
+
1
;
break
;
case
NPCocoaEventFocusChanged
:
instanceData
-
>
focusState
=
cocoaEvent
-
>
data
.
focus
.
hasFocus
?
ACTIVATION_STATE_ACTIVATED
:
ACTIVATION_STATE_DEACTIVATED
;
instanceData
-
>
focusEventCount
=
instanceData
-
>
focusEventCount
+
1
;
break
;
default
:
return
kNPEventNotHandled
;
}
return
kNPEventHandled
;
}
int32_t
pluginGetEdge
(
InstanceData
*
instanceData
RectEdge
edge
)
{
NPWindow
*
w
=
&
instanceData
-
>
window
;
switch
(
edge
)
{
case
EDGE_LEFT
:
return
w
-
>
x
;
case
EDGE_TOP
:
return
w
-
>
y
;
case
EDGE_RIGHT
:
return
w
-
>
x
+
w
-
>
width
;
case
EDGE_BOTTOM
:
return
w
-
>
y
+
w
-
>
height
;
}
MOZ_CRASH
(
"
Unexpected
RectEdge
?
!
"
)
;
}
int32_t
pluginGetClipRegionRectCount
(
InstanceData
*
instanceData
)
{
return
1
;
}
int32_t
pluginGetClipRegionRectEdge
(
InstanceData
*
instanceData
int32_t
rectIndex
RectEdge
edge
)
{
if
(
rectIndex
!
=
0
)
return
NPTEST_INT32_ERROR
;
static
const
int
COCOA_TITLEBAR_HEIGHT
=
22
;
NPWindow
*
w
=
&
instanceData
-
>
window
;
switch
(
edge
)
{
case
EDGE_LEFT
:
return
w
-
>
clipRect
.
left
;
case
EDGE_TOP
:
return
w
-
>
clipRect
.
top
+
COCOA_TITLEBAR_HEIGHT
;
case
EDGE_RIGHT
:
return
w
-
>
clipRect
.
right
;
case
EDGE_BOTTOM
:
return
w
-
>
clipRect
.
bottom
+
COCOA_TITLEBAR_HEIGHT
;
}
MOZ_CRASH
(
"
Unexpected
RectEdge
?
!
"
)
;
}
void
pluginDoInternalConsistencyCheck
(
InstanceData
*
instanceData
std
:
:
string
&
error
)
{
}
