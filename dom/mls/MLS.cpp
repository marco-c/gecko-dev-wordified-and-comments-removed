#
include
"
mozilla
/
dom
/
MLS
.
h
"
#
include
"
MLSGroupView
.
h
"
#
include
"
MLSLogging
.
h
"
#
include
"
MLSTypeUtils
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
dom
/
MLSGroupView
.
h
"
#
include
"
mozilla
/
dom
/
MLSTransactionChild
.
h
"
#
include
"
mozilla
/
dom
/
MLSTransactionMessage
.
h
"
#
include
"
mozilla
/
dom
/
PMLSTransaction
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
MLS
mGlobalObject
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
MLS
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
MLS
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
MLS
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
mozilla
:
:
LazyLogModule
gMlsLog
(
"
MLS
"
)
;
already_AddRefed
<
MLS
>
MLS
:
:
Constructor
(
GlobalObject
&
aGlobalObject
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
Constructor
(
)
"
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
(
do_QueryInterface
(
aGlobalObject
.
GetAsSupports
(
)
)
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsIPrincipal
*
principal
=
global
-
>
PrincipalOrNull
(
)
;
if
(
!
principal
|
|
!
principal
-
>
GetIsContentPrincipal
(
)
|
|
principal
-
>
GetIsInPrivateBrowsing
(
)
)
{
aRv
.
ThrowSecurityError
(
"
Cannot
create
MLS
store
for
origin
"
)
;
return
nullptr
;
}
mozilla
:
:
ipc
:
:
Endpoint
<
PMLSTransactionParent
>
parentEndpoint
;
mozilla
:
:
ipc
:
:
Endpoint
<
PMLSTransactionChild
>
childEndpoint
;
MOZ_ALWAYS_SUCCEEDS
(
PMLSTransaction
:
:
CreateEndpoints
(
&
parentEndpoint
&
childEndpoint
)
)
;
mozilla
:
:
ipc
:
:
PBackgroundChild
*
backgroundChild
=
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
!
backgroundChild
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
MLSTransactionChild
>
actor
=
new
MLSTransactionChild
(
)
;
MOZ_ALWAYS_TRUE
(
childEndpoint
.
Bind
(
actor
)
)
;
MOZ_ALWAYS_TRUE
(
backgroundChild
-
>
SendCreateMLSTransaction
(
std
:
:
move
(
parentEndpoint
)
WrapNotNull
(
principal
)
)
)
;
return
MakeAndAddRef
<
MLS
>
(
global
actor
)
;
}
MLS
:
:
MLS
(
nsIGlobalObject
*
aGlobalObject
MLSTransactionChild
*
aActor
)
:
mGlobalObject
(
aGlobalObject
)
mTransactionChild
(
aActor
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
MLS
(
)
"
)
)
;
}
MLS
:
:
~
MLS
(
)
{
if
(
mTransactionChild
)
{
mTransactionChild
-
>
Close
(
)
;
}
}
JSObject
*
MLS
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MLS_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
DeleteState
(
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
DeleteState
(
)
"
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestStateDelete
(
[
promise
]
(
bool
result
)
{
if
(
result
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
}
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
deleteState
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
GenerateIdentity
(
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GenerateIdentity
(
)
"
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestGenerateIdentityKeypair
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
]
(
Maybe
<
RawBytes
>
&
&
result
)
{
if
(
result
.
isNothing
(
)
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
generateIdentityKeypair
failed
"
)
;
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
self
-
>
mGlobalObject
)
)
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
generateIdentityKeypair
failed
"
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
error
;
JS
:
:
Rooted
<
JSObject
*
>
content
(
cx
Uint8Array
:
:
Create
(
cx
result
-
>
data
(
)
error
)
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
return
;
}
RootedDictionary
<
MLSBytes
>
rvalue
(
cx
)
;
rvalue
.
mType
=
MLSObjectType
:
:
Client_identifier
;
rvalue
.
mContent
.
Init
(
content
)
;
promise
-
>
MaybeResolve
(
rvalue
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
generateIdentity
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
GenerateCredential
(
const
MLSBytesOrUint8ArrayOrUTF8String
&
aJsCredContent
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GenerateCredentialBasic
(
)
"
)
)
;
nsTArray
<
uint8_t
>
credContent
=
ExtractMLSBytesOrUint8ArrayOrUTF8String
(
MLSObjectType
:
:
Credential_basic
aJsCredContent
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
credContent
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
credential
content
must
not
be
empty
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestGenerateCredentialBasic
(
credContent
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
]
(
Maybe
<
RawBytes
>
&
&
result
)
{
if
(
result
.
isNothing
(
)
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
generateCredentialBasic
failed
"
)
;
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
self
-
>
mGlobalObject
)
)
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
generateCredentialBasic
failed
"
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
error
;
JS
:
:
Rooted
<
JSObject
*
>
content
(
cx
Uint8Array
:
:
Create
(
cx
result
-
>
data
(
)
error
)
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
return
;
}
RootedDictionary
<
MLSBytes
>
rvalue
(
cx
)
;
rvalue
.
mType
=
MLSObjectType
:
:
Credential_basic
;
rvalue
.
mContent
.
Init
(
content
)
;
promise
-
>
MaybeResolve
(
rvalue
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
generateCredentialBasic
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
GenerateKeyPackage
(
const
MLSBytesOrUint8Array
&
aJsClientIdentifier
const
MLSBytesOrUint8Array
&
aJsCredential
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GenerateKeyPackage
(
)
"
)
)
;
nsTArray
<
uint8_t
>
clientIdentifier
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Client_identifier
aJsClientIdentifier
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
clientIdentifier
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
client
identifier
must
not
be
empty
"
)
;
return
nullptr
;
}
nsTArray
<
uint8_t
>
credential
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Credential_basic
aJsCredential
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
credential
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
credential
must
not
be
empty
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestGenerateKeyPackage
(
clientIdentifier
credential
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
]
(
Maybe
<
RawBytes
>
&
&
keyPackage
)
{
if
(
keyPackage
.
isNothing
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
self
-
>
mGlobalObject
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
error
;
JS
:
:
Rooted
<
JSObject
*
>
content
(
cx
Uint8Array
:
:
Create
(
cx
keyPackage
-
>
data
(
)
error
)
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
return
;
}
RootedDictionary
<
MLSBytes
>
rvalue
(
cx
)
;
rvalue
.
mType
=
MLSObjectType
:
:
Key_package
;
rvalue
.
mContent
.
Init
(
content
)
;
promise
-
>
MaybeResolve
(
rvalue
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
generateKeyPackage
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
GroupCreate
(
const
MLSBytesOrUint8Array
&
aJsClientIdentifier
const
MLSBytesOrUint8Array
&
aJsCredential
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GroupCreate
(
)
"
)
)
;
nsTArray
<
uint8_t
>
clientIdentifier
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Client_identifier
aJsClientIdentifier
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
clientIdentifier
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
client
identifier
must
not
be
empty
"
)
;
return
nullptr
;
}
nsTArray
<
uint8_t
>
credential
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Credential_basic
aJsCredential
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
credential
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
credential
must
not
be
empty
"
)
;
return
nullptr
;
}
if
(
MOZ_LOG_TEST
(
gMlsLog
LogLevel
:
:
Debug
)
)
{
nsAutoCString
clientIdHex
;
for
(
uint8_t
byte
:
clientIdentifier
)
{
clientIdHex
.
AppendPrintf
(
"
%
02X
"
byte
)
;
}
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
clientIdentifier
in
hex
:
%
s
\
n
"
clientIdHex
.
get
(
)
)
)
;
}
AutoTArray
<
uint8_t
1
>
groupIdentifier
{
0xFF
}
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestGroupCreate
(
clientIdentifier
credential
groupIdentifier
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
clientIdentifier
(
std
:
:
move
(
clientIdentifier
)
)
]
(
Maybe
<
mozilla
:
:
security
:
:
mls
:
:
GkGroupIdEpoch
>
&
&
groupIdEpoch
)
mutable
{
if
(
groupIdEpoch
.
isNothing
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
MLSGroupView
>
group
=
new
MLSGroupView
(
self
std
:
:
move
(
groupIdEpoch
-
>
group_id
)
std
:
:
move
(
clientIdentifier
)
)
;
promise
-
>
MaybeResolve
(
group
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Error
(
"
IPC
message
rejected
with
reason
:
%
d
"
static_cast
<
int
>
(
aReason
)
)
)
;
promise
-
>
MaybeRejectWithUnknownError
(
"
groupCreate
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
MLS
:
:
GroupGet
(
const
MLSBytesOrUint8Array
&
aJsGroupIdentifier
const
MLSBytesOrUint8Array
&
aJsClientIdentifier
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GroupGet
(
)
"
)
)
;
nsTArray
<
uint8_t
>
groupIdentifier
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Group_identifier
aJsGroupIdentifier
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
groupIdentifier
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
group
identifier
must
not
be
empty
"
)
;
return
nullptr
;
}
nsTArray
<
uint8_t
>
clientIdentifier
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Client_identifier
aJsClientIdentifier
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
clientIdentifier
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
client
identifier
must
not
be
empty
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
AutoTArray
<
uint8_t
7
>
label
{
'
l
'
'
i
'
'
v
'
'
e
'
'
n
'
'
e
'
'
s
'
'
s
'
}
;
AutoTArray
<
uint8_t
1
>
context
{
0x00
}
;
uint64_t
len
=
32
;
mTransactionChild
-
>
SendRequestExportSecret
(
groupIdentifier
clientIdentifier
label
context
len
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
groupIdentifier
(
std
:
:
move
(
groupIdentifier
)
)
clientIdentifier
(
std
:
:
move
(
clientIdentifier
)
)
]
(
Maybe
<
mozilla
:
:
security
:
:
mls
:
:
GkExporterOutput
>
&
&
exporterOutput
)
mutable
{
if
(
exporterOutput
.
isNothing
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
MLSGroupView
>
group
=
new
MLSGroupView
(
self
std
:
:
move
(
exporterOutput
-
>
group_id
)
std
:
:
move
(
clientIdentifier
)
)
;
promise
-
>
MaybeResolve
(
group
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
exportSecret
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
GroupJoin
(
const
MLSBytesOrUint8Array
&
aJsClientIdentifier
const
MLSBytesOrUint8Array
&
aJsWelcome
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GroupJoin
(
)
"
)
)
;
nsTArray
<
uint8_t
>
clientIdentifier
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Client_identifier
aJsClientIdentifier
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
clientIdentifier
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
client
identifier
must
not
be
empty
"
)
;
return
nullptr
;
}
nsTArray
<
uint8_t
>
welcome
=
ExtractMLSBytesOrUint8Array
(
MLSObjectType
:
:
Welcome
aJsWelcome
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
welcome
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
welcome
must
not
be
empty
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestGroupJoin
(
clientIdentifier
welcome
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
clientIdentifier
(
std
:
:
move
(
clientIdentifier
)
)
]
(
Maybe
<
mozilla
:
:
security
:
:
mls
:
:
GkGroupIdEpoch
>
&
&
groupIdEpoch
)
mutable
{
if
(
groupIdEpoch
.
isNothing
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
MLSGroupView
>
group
=
new
MLSGroupView
(
self
std
:
:
move
(
groupIdEpoch
-
>
group_id
)
std
:
:
move
(
clientIdentifier
)
)
;
promise
-
>
MaybeResolve
(
group
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
groupJoin
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
GetGroupIdFromMessage
(
const
MLSBytesOrUint8Array
&
aJsMessage
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GetGroupIdFromMessage
(
)
"
)
)
;
nsTArray
<
uint8_t
>
message
=
ExtractMLSBytesOrUint8ArrayWithUnknownType
(
aJsMessage
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
message
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
message
must
not
be
empty
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestGetGroupIdentifier
(
message
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
message
(
std
:
:
move
(
message
)
)
]
(
Maybe
<
RawBytes
>
&
&
result
)
{
if
(
result
.
isNothing
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
self
-
>
mGlobalObject
)
)
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Error
(
"
Failed
to
initialize
JSAPI
"
)
)
;
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
error
;
JS
:
:
Rooted
<
JSObject
*
>
jsGroupId
(
cx
Uint8Array
:
:
Create
(
cx
result
-
>
data
(
)
error
)
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
return
;
}
RootedDictionary
<
MLSBytes
>
rvalue
(
cx
)
;
rvalue
.
mType
=
MLSObjectType
:
:
Group_identifier
;
rvalue
.
mContent
.
Init
(
jsGroupId
)
;
if
(
MOZ_LOG_TEST
(
gMlsLog
LogLevel
:
:
Debug
)
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
Successfully
constructed
MLSBytes
"
)
)
;
}
promise
-
>
MaybeResolve
(
rvalue
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Error
(
"
IPC
call
rejected
with
reason
:
%
d
"
static_cast
<
int
>
(
aReason
)
)
)
;
promise
-
>
MaybeRejectWithUnknownError
(
"
getGroupIdFromMessage
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
MLS
:
:
GetGroupEpochFromMessage
(
const
MLSBytesOrUint8Array
&
aJsMessage
ErrorResult
&
aRv
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
MLS
:
:
GetGroupEpochFromMessage
(
)
"
)
)
;
nsTArray
<
uint8_t
>
message
=
ExtractMLSBytesOrUint8ArrayWithUnknownType
(
aJsMessage
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
message
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowTypeError
(
"
The
message
must
not
be
empty
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
mGlobalObject
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
mTransactionChild
-
>
SendRequestGetGroupEpoch
(
message
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
self
=
RefPtr
{
this
}
message
(
std
:
:
move
(
message
)
)
]
(
Maybe
<
RawBytes
>
&
&
result
)
{
if
(
result
.
isNothing
(
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
self
-
>
mGlobalObject
)
)
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Error
(
"
Failed
to
initialize
JSAPI
"
)
)
;
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
error
;
JS
:
:
Rooted
<
JSObject
*
>
jsGroupId
(
cx
Uint8Array
:
:
Create
(
cx
result
-
>
data
(
)
error
)
)
;
error
.
WouldReportJSException
(
)
;
if
(
error
.
Failed
(
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
error
)
)
;
return
;
}
RootedDictionary
<
MLSBytes
>
rvalue
(
cx
)
;
rvalue
.
mType
=
MLSObjectType
:
:
Group_epoch
;
rvalue
.
mContent
.
Init
(
jsGroupId
)
;
if
(
MOZ_LOG_TEST
(
gMlsLog
LogLevel
:
:
Debug
)
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
Successfully
constructed
MLSBytes
"
)
)
;
}
promise
-
>
MaybeResolve
(
rvalue
)
;
}
[
promise
]
(
:
:
mozilla
:
:
ipc
:
:
ResponseRejectReason
aReason
)
{
MOZ_LOG
(
gMlsLog
mozilla
:
:
LogLevel
:
:
Error
(
"
IPC
call
rejected
with
reason
:
%
d
"
static_cast
<
int
>
(
aReason
)
)
)
;
promise
-
>
MaybeRejectWithUnknownError
(
"
getGroupEpochFromMessage
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
}
