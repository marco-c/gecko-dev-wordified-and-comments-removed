#
ifndef
nsXMLContentSerializer_h__
#
define
nsXMLContentSerializer_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsIContentSerializer
.
h
"
#
include
"
nsISupportsUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
define
kIndentStr
u
"
"
_ns
#
define
kEndTag
u
"
<
/
"
_ns
class
nsAtom
;
class
nsINode
;
namespace
mozilla
{
class
Encoding
;
}
class
nsXMLContentSerializer
:
public
nsIContentSerializer
{
public
:
nsXMLContentSerializer
(
)
;
NS_DECL_ISUPPORTS
NS_IMETHOD
Init
(
uint32_t
flags
uint32_t
aWrapColumn
const
mozilla
:
:
Encoding
*
aEncoding
bool
aIsCopying
bool
aRewriteEncodingDeclaration
bool
*
aNeedsPreformatScanning
nsAString
&
aOutput
)
override
;
NS_IMETHOD
AppendText
(
nsIContent
*
aText
int32_t
aStartOffset
int32_t
aEndOffset
)
override
;
NS_IMETHOD
AppendCDATASection
(
nsIContent
*
aCDATASection
int32_t
aStartOffset
int32_t
aEndOffset
)
override
;
NS_IMETHOD
AppendProcessingInstruction
(
mozilla
:
:
dom
:
:
ProcessingInstruction
*
aPI
int32_t
aStartOffset
int32_t
aEndOffset
)
override
;
NS_IMETHOD
AppendComment
(
mozilla
:
:
dom
:
:
Comment
*
aComment
int32_t
aStartOffset
int32_t
aEndOffset
)
override
;
NS_IMETHOD
AppendDoctype
(
mozilla
:
:
dom
:
:
DocumentType
*
aDoctype
)
override
;
NS_IMETHOD
AppendElementStart
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
dom
:
:
Element
*
aOriginalElement
)
override
;
NS_IMETHOD
AppendElementEnd
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
dom
:
:
Element
*
aOriginalElement
)
override
;
NS_IMETHOD
FlushAndFinish
(
)
override
{
return
NS_OK
;
}
NS_IMETHOD
Finish
(
)
override
;
NS_IMETHOD
GetOutputLength
(
uint32_t
&
aLength
)
const
override
;
NS_IMETHOD
AppendDocumentStart
(
mozilla
:
:
dom
:
:
Document
*
aDocument
)
override
;
NS_IMETHOD
ScanElementForPreformat
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
override
{
return
NS_OK
;
}
NS_IMETHOD
ForgetElementForPreformat
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
override
{
return
NS_OK
;
}
protected
:
virtual
~
nsXMLContentSerializer
(
)
;
MOZ_MUST_USE
bool
AppendToString
(
const
char16_t
aChar
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendToString
(
const
nsAString
&
aStr
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendToStringConvertLF
(
const
nsAString
&
aStr
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendToStringWrapped
(
const
nsAString
&
aStr
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendToStringFormatedWrapped
(
const
nsAString
&
aStr
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendWrapped_WhitespaceSequence
(
nsAString
:
:
const_char_iterator
&
aPos
const
nsAString
:
:
const_char_iterator
aEnd
const
nsAString
:
:
const_char_iterator
aSequenceStart
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendFormatedWrapped_WhitespaceSequence
(
nsAString
:
:
const_char_iterator
&
aPos
const
nsAString
:
:
const_char_iterator
aEnd
const
nsAString
:
:
const_char_iterator
aSequenceStart
bool
&
aMayIgnoreStartOfLineWhitespaceSequence
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendWrapped_NonWhitespaceSequence
(
nsAString
:
:
const_char_iterator
&
aPos
const
nsAString
:
:
const_char_iterator
aEnd
const
nsAString
:
:
const_char_iterator
aSequenceStart
bool
&
aMayIgnoreStartOfLineWhitespaceSequence
bool
&
aSequenceStartAfterAWhiteSpace
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
bool
AppendNewLineToString
(
nsAString
&
aOutputStr
)
;
MOZ_MUST_USE
virtual
bool
AppendAndTranslateEntities
(
const
nsAString
&
aStr
nsAString
&
aOutputStr
)
;
private
:
MOZ_MUST_USE
static
bool
AppendAndTranslateEntities
(
const
nsAString
&
aStr
nsAString
&
aOutputStr
const
uint8_t
aEntityTable
[
]
uint16_t
aMaxTableIndex
const
char
*
const
aStringTable
[
]
)
;
protected
:
template
<
uint16_t
LargestIndex
uint16_t
TableLength
>
MOZ_MUST_USE
bool
AppendAndTranslateEntities
(
const
nsAString
&
aStr
nsAString
&
aOutputStr
const
uint8_t
(
&
aEntityTable
)
[
TableLength
]
const
char
*
const
aStringTable
[
]
)
{
static_assert
(
LargestIndex
<
TableLength
"
Largest
allowed
index
must
be
smaller
than
table
length
"
)
;
return
AppendAndTranslateEntities
(
aStr
aOutputStr
aEntityTable
LargestIndex
aStringTable
)
;
}
static
const
uint16_t
kGTVal
=
62
;
nsresult
AppendTextData
(
nsIContent
*
aNode
int32_t
aStartOffset
int32_t
aEndOffset
nsAString
&
aStr
bool
aTranslateEntities
)
;
virtual
nsresult
PushNameSpaceDecl
(
const
nsAString
&
aPrefix
const
nsAString
&
aURI
nsIContent
*
aOwner
)
;
void
PopNameSpaceDeclsFor
(
nsIContent
*
aOwner
)
;
bool
ConfirmPrefix
(
nsAString
&
aPrefix
const
nsAString
&
aURI
nsIContent
*
aElement
bool
aIsAttribute
)
;
void
GenerateNewPrefix
(
nsAString
&
aPrefix
)
;
uint32_t
ScanNamespaceDeclarations
(
mozilla
:
:
dom
:
:
Element
*
aContent
mozilla
:
:
dom
:
:
Element
*
aOriginalElement
const
nsAString
&
aTagNamespaceURI
)
;
MOZ_MUST_USE
virtual
bool
SerializeAttributes
(
mozilla
:
:
dom
:
:
Element
*
aContent
mozilla
:
:
dom
:
:
Element
*
aOriginalElement
nsAString
&
aTagPrefix
const
nsAString
&
aTagNamespaceURI
nsAtom
*
aTagName
nsAString
&
aStr
uint32_t
aSkipAttr
bool
aAddNSAttr
)
;
MOZ_MUST_USE
bool
SerializeAttr
(
const
nsAString
&
aPrefix
const
nsAString
&
aName
const
nsAString
&
aValue
nsAString
&
aStr
bool
aDoEscapeEntities
)
;
bool
IsJavaScript
(
nsIContent
*
aContent
nsAtom
*
aAttrNameAtom
int32_t
aAttrNamespaceID
const
nsAString
&
aValueString
)
;
virtual
bool
CheckElementStart
(
mozilla
:
:
dom
:
:
Element
*
aElement
bool
&
aForceFormat
nsAString
&
aStr
nsresult
&
aResult
)
;
MOZ_MUST_USE
bool
AppendEndOfElementStart
(
mozilla
:
:
dom
:
:
Element
*
aEleemnt
mozilla
:
:
dom
:
:
Element
*
aOriginalElement
nsAString
&
aStr
)
;
MOZ_MUST_USE
virtual
bool
AfterElementStart
(
nsIContent
*
aContent
nsIContent
*
aOriginalElement
nsAString
&
aStr
)
{
return
true
;
}
;
virtual
bool
CheckElementEnd
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
dom
:
:
Element
*
aOriginalElement
bool
&
aForceFormat
nsAString
&
aStr
)
;
virtual
void
AfterElementEnd
(
nsIContent
*
aContent
nsAString
&
aStr
)
{
}
;
virtual
bool
LineBreakBeforeOpen
(
int32_t
aNamespaceID
nsAtom
*
aName
)
;
virtual
bool
LineBreakAfterOpen
(
int32_t
aNamespaceID
nsAtom
*
aName
)
;
virtual
bool
LineBreakBeforeClose
(
int32_t
aNamespaceID
nsAtom
*
aName
)
;
virtual
bool
LineBreakAfterClose
(
int32_t
aNamespaceID
nsAtom
*
aName
)
;
MOZ_MUST_USE
bool
AppendIndentation
(
nsAString
&
aStr
)
;
MOZ_MUST_USE
bool
IncrIndentation
(
nsAtom
*
aName
)
;
void
DecrIndentation
(
nsAtom
*
aName
)
;
MOZ_MUST_USE
bool
MaybeAddNewlineForRootNode
(
nsAString
&
aStr
)
;
void
MaybeFlagNewlineForRootNode
(
nsINode
*
aNode
)
;
virtual
void
MaybeEnterInPreContent
(
nsIContent
*
aNode
)
;
virtual
void
MaybeLeaveFromPreContent
(
nsIContent
*
aNode
)
;
bool
ShouldMaintainPreLevel
(
)
const
;
int32_t
PreLevel
(
)
const
{
MOZ_ASSERT
(
ShouldMaintainPreLevel
(
)
)
;
return
mPreLevel
;
}
int32_t
&
PreLevel
(
)
{
MOZ_ASSERT
(
ShouldMaintainPreLevel
(
)
)
;
return
mPreLevel
;
}
bool
MaybeSerializeIsValue
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAString
&
aStr
)
;
int32_t
mPrefixIndex
;
struct
NameSpaceDecl
{
nsString
mPrefix
;
nsString
mURI
;
nsIContent
*
mOwner
;
}
;
nsTArray
<
NameSpaceDecl
>
mNameSpaceStack
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
mFlags
;
nsString
mLineBreak
;
nsCString
mCharset
;
uint32_t
mColPos
;
MOZ_INIT_OUTSIDE_CTOR
bool
mDoFormat
;
MOZ_INIT_OUTSIDE_CTOR
bool
mDoRaw
;
MOZ_INIT_OUTSIDE_CTOR
bool
mDoWrap
;
MOZ_INIT_OUTSIDE_CTOR
bool
mAllowLineBreaking
;
MOZ_INIT_OUTSIDE_CTOR
uint32_t
mMaxColumn
;
nsString
mIndent
;
int32_t
mIndentOverflow
;
bool
mIsIndentationAddedOnCurrentLine
;
bool
mInAttribute
;
bool
mAddNewlineForRootNode
;
bool
mAddSpace
;
bool
mMayIgnoreLineBreakSequence
;
bool
mBodyOnly
;
int32_t
mInBody
;
nsAString
*
mOutput
;
private
:
MOZ_INIT_OUTSIDE_CTOR
int32_t
mPreLevel
;
static
const
uint8_t
kEntities
[
]
;
static
const
uint8_t
kAttrEntities
[
]
;
static
const
char
*
const
kEntityStrings
[
]
;
}
;
nsresult
NS_NewXMLContentSerializer
(
nsIContentSerializer
*
*
aSerializer
)
;
#
endif
