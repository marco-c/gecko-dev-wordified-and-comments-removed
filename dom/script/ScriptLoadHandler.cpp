#
include
"
ScriptLoadHandler
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
utility
>
#
include
"
ScriptLoader
.
h
"
#
include
"
ScriptTrace
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
loader
/
ScriptLoadRequest
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
SRICheck
.
h
"
#
include
"
mozilla
/
dom
/
ScriptDecoding
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
dom
{
#
undef
LOG
#
define
LOG
(
args
)
\
MOZ_LOG
(
ScriptLoader
:
:
gScriptLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
ScriptLoader
:
:
gScriptLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
)
ScriptLoadHandler
:
:
ScriptLoadHandler
(
ScriptLoader
*
aScriptLoader
JS
:
:
loader
:
:
ScriptLoadRequest
*
aRequest
UniquePtr
<
SRICheckDataVerifier
>
&
&
aSRIDataVerifier
)
:
mScriptLoader
(
aScriptLoader
)
mRequest
(
aRequest
)
mSRIDataVerifier
(
std
:
:
move
(
aSRIDataVerifier
)
)
mSRIStatus
(
NS_OK
)
mDecoder
(
)
{
MOZ_ASSERT
(
mRequest
-
>
IsUnknownDataType
(
)
)
;
MOZ_ASSERT
(
mRequest
-
>
IsFetching
(
)
)
;
}
ScriptLoadHandler
:
:
~
ScriptLoadHandler
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
ScriptLoadHandler
nsIIncrementalStreamLoaderObserver
)
template
<
typename
Unit
>
nsresult
ScriptLoadHandler
:
:
DecodeRawDataHelper
(
const
uint8_t
*
aData
uint32_t
aDataLength
bool
aEndOfStream
)
{
CheckedInt
<
size_t
>
needed
=
ScriptDecoding
<
Unit
>
:
:
MaxBufferLength
(
mDecoder
aDataLength
)
;
if
(
!
needed
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
JS
:
:
loader
:
:
ScriptLoadRequest
:
:
ScriptTextBuffer
<
Unit
>
&
scriptText
=
mRequest
-
>
ScriptText
<
Unit
>
(
)
;
uint32_t
haveRead
=
scriptText
.
length
(
)
;
CheckedInt
<
uint32_t
>
capacity
=
haveRead
;
capacity
+
=
needed
.
value
(
)
;
if
(
!
capacity
.
isValid
(
)
|
|
!
scriptText
.
resize
(
capacity
.
value
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
size_t
written
=
ScriptDecoding
<
Unit
>
:
:
DecodeInto
(
mDecoder
Span
(
aData
aDataLength
)
Span
(
scriptText
.
begin
(
)
+
haveRead
needed
.
value
(
)
)
aEndOfStream
)
;
MOZ_ASSERT
(
written
<
=
needed
.
value
(
)
)
;
haveRead
+
=
written
;
MOZ_ASSERT
(
haveRead
<
=
capacity
.
value
(
)
"
mDecoder
produced
more
data
than
expected
"
)
;
MOZ_ALWAYS_TRUE
(
scriptText
.
resize
(
haveRead
)
)
;
mRequest
-
>
mScriptTextLength
=
scriptText
.
length
(
)
;
return
NS_OK
;
}
nsresult
ScriptLoadHandler
:
:
DecodeRawData
(
const
uint8_t
*
aData
uint32_t
aDataLength
bool
aEndOfStream
)
{
if
(
mRequest
-
>
IsUTF16Text
(
)
)
{
return
DecodeRawDataHelper
<
char16_t
>
(
aData
aDataLength
aEndOfStream
)
;
}
return
DecodeRawDataHelper
<
Utf8Unit
>
(
aData
aDataLength
aEndOfStream
)
;
}
NS_IMETHODIMP
ScriptLoadHandler
:
:
OnIncrementalData
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
uint32_t
aDataLength
const
uint8_t
*
aData
uint32_t
*
aConsumedLength
)
{
nsCOMPtr
<
nsIRequest
>
channelRequest
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channelRequest
)
)
;
if
(
!
mPreloadStartNotified
)
{
mPreloadStartNotified
=
true
;
mRequest
-
>
GetScriptLoadContext
(
)
-
>
NotifyStart
(
channelRequest
)
;
}
if
(
mRequest
-
>
IsCanceled
(
)
)
{
*
aConsumedLength
=
aDataLength
;
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
if
(
mRequest
-
>
IsUnknownDataType
(
)
)
{
rv
=
EnsureKnownDataType
(
aLoader
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mRequest
-
>
IsTextSource
(
)
)
{
if
(
!
EnsureDecoder
(
aLoader
aData
aDataLength
false
)
)
{
return
NS_OK
;
}
*
aConsumedLength
=
aDataLength
;
rv
=
DecodeRawData
(
aData
aDataLength
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mSRIDataVerifier
&
&
NS_SUCCEEDED
(
mSRIStatus
)
)
{
mSRIStatus
=
mSRIDataVerifier
-
>
Update
(
aDataLength
aData
)
;
}
}
else
{
MOZ_ASSERT
(
mRequest
-
>
IsBytecode
(
)
)
;
if
(
!
mRequest
-
>
mScriptBytecode
.
append
(
aData
aDataLength
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
*
aConsumedLength
=
aDataLength
;
uint32_t
sriLength
=
0
;
rv
=
MaybeDecodeSRI
(
&
sriLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
channelRequest
-
>
Cancel
(
mScriptLoader
-
>
RestartLoad
(
mRequest
)
)
;
}
if
(
sriLength
)
{
mRequest
-
>
mBytecodeOffset
=
JS
:
:
AlignTranscodingBytecodeOffset
(
sriLength
)
;
}
}
return
rv
;
}
bool
ScriptLoadHandler
:
:
TrySetDecoder
(
nsIIncrementalStreamLoader
*
aLoader
const
uint8_t
*
aData
uint32_t
aDataLength
bool
aEndOfStream
)
{
MOZ_ASSERT
(
mDecoder
=
=
nullptr
"
can
'
t
have
a
decoder
already
if
we
'
re
trying
to
set
one
"
)
;
if
(
mRequest
-
>
IsModuleRequest
(
)
)
{
mDecoder
=
UTF_8_ENCODING
-
>
NewDecoderWithBOMRemoval
(
)
;
return
true
;
}
if
(
!
aEndOfStream
&
&
(
aDataLength
<
3
)
)
{
return
false
;
}
const
Encoding
*
encoding
;
std
:
:
tie
(
encoding
std
:
:
ignore
)
=
Encoding
:
:
ForBOM
(
Span
(
aData
aDataLength
)
)
;
if
(
encoding
)
{
mDecoder
=
encoding
-
>
NewDecoderWithBOMRemoval
(
)
;
return
true
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
channel
)
{
nsAutoCString
label
;
if
(
NS_SUCCEEDED
(
channel
-
>
GetContentCharset
(
label
)
)
&
&
(
encoding
=
Encoding
:
:
ForLabel
(
label
)
)
)
{
mDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
return
true
;
}
}
nsAutoString
hintCharset
;
if
(
!
mRequest
-
>
GetScriptLoadContext
(
)
-
>
IsPreload
(
)
)
{
mRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElement
(
)
-
>
GetScriptCharset
(
hintCharset
)
;
}
else
{
nsTArray
<
ScriptLoader
:
:
PreloadInfo
>
:
:
index_type
i
=
mScriptLoader
-
>
mPreloads
.
IndexOf
(
mRequest
0
ScriptLoader
:
:
PreloadRequestComparator
(
)
)
;
NS_ASSERTION
(
i
!
=
mScriptLoader
-
>
mPreloads
.
NoIndex
"
Incorrect
preload
bookkeeping
"
)
;
hintCharset
=
mScriptLoader
-
>
mPreloads
[
i
]
.
mCharset
;
}
if
(
(
encoding
=
Encoding
:
:
ForLabel
(
hintCharset
)
)
)
{
mDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
return
true
;
}
if
(
mScriptLoader
-
>
mDocument
)
{
encoding
=
mScriptLoader
-
>
mDocument
-
>
GetDocumentCharacterSet
(
)
;
mDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
return
true
;
}
mDecoder
=
WINDOWS_1252_ENCODING
-
>
NewDecoderWithoutBOMHandling
(
)
;
return
true
;
}
nsresult
ScriptLoadHandler
:
:
MaybeDecodeSRI
(
uint32_t
*
sriLength
)
{
*
sriLength
=
0
;
if
(
!
mSRIDataVerifier
|
|
mSRIDataVerifier
-
>
IsComplete
(
)
|
|
NS_FAILED
(
mSRIStatus
)
)
{
return
NS_OK
;
}
if
(
mRequest
-
>
mScriptBytecode
.
length
(
)
<
=
mSRIDataVerifier
-
>
DataSummaryLength
(
)
)
{
return
NS_OK
;
}
mSRIStatus
=
mSRIDataVerifier
-
>
ImportDataSummary
(
mRequest
-
>
mScriptBytecode
.
length
(
)
mRequest
-
>
mScriptBytecode
.
begin
(
)
)
;
if
(
NS_FAILED
(
mSRIStatus
)
)
{
LOG
(
(
"
ScriptLoadHandler
:
:
MaybeDecodeSRI
failed
to
decode
SRI
restart
"
"
request
"
)
)
;
return
mSRIStatus
;
}
*
sriLength
=
mSRIDataVerifier
-
>
DataSummaryLength
(
)
;
MOZ_ASSERT
(
*
sriLength
>
0
)
;
return
NS_OK
;
}
nsresult
ScriptLoadHandler
:
:
EnsureKnownDataType
(
nsIIncrementalStreamLoader
*
aLoader
)
{
MOZ_ASSERT
(
mRequest
-
>
IsUnknownDataType
(
)
)
;
MOZ_ASSERT
(
mRequest
-
>
IsFetching
(
)
)
;
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
MOZ_ASSERT
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mRequest
-
>
mFetchSourceOnly
)
{
mRequest
-
>
SetTextSource
(
)
;
TRACE_FOR_TEST
(
mRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_load_source
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsICacheInfoChannel
>
cic
(
do_QueryInterface
(
req
)
)
;
if
(
cic
)
{
nsAutoCString
altDataType
;
cic
-
>
GetAlternativeDataType
(
altDataType
)
;
if
(
altDataType
.
Equals
(
ScriptLoader
:
:
BytecodeMimeTypeFor
(
mRequest
)
)
)
{
mRequest
-
>
SetBytecode
(
)
;
TRACE_FOR_TEST
(
mRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_load_bytecode
"
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
altDataType
.
IsEmpty
(
)
)
;
}
mRequest
-
>
SetTextSource
(
)
;
TRACE_FOR_TEST
(
mRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_load_source
"
)
;
MOZ_ASSERT
(
!
mRequest
-
>
IsUnknownDataType
(
)
)
;
MOZ_ASSERT
(
mRequest
-
>
IsFetching
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ScriptLoadHandler
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aDataLength
const
uint8_t
*
aData
)
{
nsresult
rv
=
NS_OK
;
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
url
;
mRequest
-
>
mURI
-
>
GetAsciiSpec
(
url
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Stream
complete
(
url
=
%
s
)
"
mRequest
.
get
(
)
url
.
get
(
)
)
)
;
}
nsCOMPtr
<
nsIRequest
>
channelRequest
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channelRequest
)
)
;
if
(
!
mPreloadStartNotified
)
{
mPreloadStartNotified
=
true
;
mRequest
-
>
GetScriptLoadContext
(
)
-
>
NotifyStart
(
channelRequest
)
;
}
auto
notifyStop
=
MakeScopeExit
(
[
&
]
{
mRequest
-
>
GetScriptLoadContext
(
)
-
>
NotifyStop
(
channelRequest
rv
)
;
}
)
;
if
(
!
mRequest
-
>
IsCanceled
(
)
)
{
if
(
mRequest
-
>
IsUnknownDataType
(
)
)
{
rv
=
EnsureKnownDataType
(
aLoader
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mRequest
-
>
IsTextSource
(
)
)
{
DebugOnly
<
bool
>
encoderSet
=
EnsureDecoder
(
aLoader
aData
aDataLength
true
)
;
MOZ_ASSERT
(
encoderSet
)
;
rv
=
DecodeRawData
(
aData
aDataLength
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Source
length
in
code
units
=
%
u
"
mRequest
.
get
(
)
unsigned
(
mRequest
-
>
ScriptTextLength
(
)
)
)
)
;
if
(
mSRIDataVerifier
&
&
NS_SUCCEEDED
(
mSRIStatus
)
)
{
mSRIStatus
=
mSRIDataVerifier
-
>
Update
(
aDataLength
aData
)
;
}
}
else
{
MOZ_ASSERT
(
mRequest
-
>
IsBytecode
(
)
)
;
if
(
!
mRequest
-
>
mScriptBytecode
.
append
(
aData
aDataLength
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
length
=
%
u
"
mRequest
.
get
(
)
unsigned
(
mRequest
-
>
mScriptBytecode
.
length
(
)
)
)
)
;
uint32_t
unused
;
rv
=
MaybeDecodeSRI
(
&
unused
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
channelRequest
-
>
Cancel
(
mScriptLoader
-
>
RestartLoad
(
mRequest
)
)
;
}
uint32_t
sriLength
;
rv
=
SRICheckDataVerifier
:
:
DataSummaryLength
(
mRequest
-
>
mScriptBytecode
.
length
(
)
mRequest
-
>
mScriptBytecode
.
begin
(
)
&
sriLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
channelRequest
-
>
Cancel
(
mScriptLoader
-
>
RestartLoad
(
mRequest
)
)
;
}
mRequest
-
>
mBytecodeOffset
=
JS
:
:
AlignTranscodingBytecodeOffset
(
sriLength
)
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
mRequest
-
>
IsSource
(
)
&
&
StaticPrefs
:
:
dom_script_loader_bytecode_cache_enabled
(
)
)
{
mRequest
-
>
mCacheInfo
=
do_QueryInterface
(
channelRequest
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
nsICacheInfoChannel
=
%
p
"
mRequest
.
get
(
)
mRequest
-
>
mCacheInfo
.
get
(
)
)
)
;
}
rv
=
mScriptLoader
-
>
OnStreamComplete
(
aLoader
mRequest
aStatus
mSRIStatus
mSRIDataVerifier
.
get
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mRequest
-
>
mCacheInfo
=
nullptr
;
}
return
rv
;
}
#
undef
LOG_ENABLED
#
undef
LOG
}
