#
include
"
ScriptElement
.
h
"
#
include
"
ScriptLoader
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentSink
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMETHODIMP
ScriptElement
:
:
ScriptAvailable
(
nsresult
aResult
nsIScriptElement
*
aElement
bool
aIsInlineClassicScript
nsIURI
*
aURI
uint32_t
aLineNo
)
{
if
(
!
aIsInlineClassicScript
&
&
NS_FAILED
(
aResult
)
)
{
nsCOMPtr
<
nsIParser
>
parser
=
do_QueryReferent
(
mCreatorParser
)
;
if
(
parser
)
{
nsCOMPtr
<
nsIContentSink
>
sink
=
parser
-
>
GetContentSink
(
)
;
if
(
sink
)
{
nsCOMPtr
<
Document
>
parserDoc
=
do_QueryInterface
(
sink
-
>
GetTarget
(
)
)
;
if
(
GetAsContent
(
)
-
>
OwnerDoc
(
)
!
=
parserDoc
)
{
return
NS_OK
;
}
}
}
if
(
parser
)
{
parser
-
>
IncrementScriptNestingLevel
(
)
;
}
nsresult
rv
=
FireErrorEvent
(
)
;
if
(
parser
)
{
parser
-
>
DecrementScriptNestingLevel
(
)
;
}
return
rv
;
}
return
NS_OK
;
}
nsresult
ScriptElement
:
:
FireErrorEvent
(
)
{
nsIContent
*
cont
=
GetAsContent
(
)
;
return
nsContentUtils
:
:
DispatchTrustedEvent
(
cont
-
>
OwnerDoc
(
)
cont
u
"
error
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
}
NS_IMETHODIMP
ScriptElement
:
:
ScriptEvaluated
(
nsresult
aResult
nsIScriptElement
*
aElement
bool
aIsInline
)
{
nsresult
rv
=
NS_OK
;
if
(
!
aIsInline
)
{
nsCOMPtr
<
nsIContent
>
cont
=
GetAsContent
(
)
;
RefPtr
<
nsPresContext
>
presContext
=
nsContentUtils
:
:
GetContextForContent
(
cont
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventMessage
message
=
NS_SUCCEEDED
(
aResult
)
?
eLoad
:
eLoadError
;
WidgetEvent
event
(
true
message
)
;
event
.
mFlags
.
mBubbles
=
(
message
!
=
eLoad
)
;
EventDispatcher
:
:
Dispatch
(
cont
presContext
&
event
nullptr
&
status
)
;
}
return
rv
;
}
void
ScriptElement
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
MaybeProcessScript
(
)
;
}
void
ScriptElement
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
aElement
-
>
IsSVGElement
(
)
&
&
(
(
aNameSpaceID
!
=
kNameSpaceID_XLink
&
&
aNameSpaceID
!
=
kNameSpaceID_None
)
|
|
aAttribute
!
=
nsGkAtoms
:
:
href
)
)
{
return
;
}
if
(
aElement
-
>
IsHTMLElement
(
)
&
&
(
aNameSpaceID
!
=
kNameSpaceID_None
|
|
aAttribute
!
=
nsGkAtoms
:
:
src
)
)
{
return
;
}
if
(
mParserCreated
=
=
NOT_FROM_PARSER
&
&
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
)
{
auto
*
cont
=
GetAsContent
(
)
;
if
(
cont
-
>
IsInComposedDoc
(
)
)
{
MaybeProcessScript
(
)
;
}
}
}
void
ScriptElement
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
MaybeProcessScript
(
)
;
}
void
ScriptElement
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
MaybeProcessScript
(
)
;
}
bool
ScriptElement
:
:
MaybeProcessScript
(
)
{
nsIContent
*
cont
=
GetAsContent
(
)
;
NS_ASSERTION
(
cont
-
>
DebugGetSlots
(
)
-
>
mMutationObservers
.
contains
(
this
)
"
You
forgot
to
add
self
as
observer
"
)
;
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
ScriptElement
:
:
MaybeProcessScript
"
[
]
(
)
{
nsAutoMicroTask
mt
;
}
)
)
;
if
(
mAlreadyStarted
|
|
!
mDoneAddingChildren
|
|
!
cont
-
>
GetComposedDoc
(
)
|
|
mMalformed
)
{
return
false
;
}
if
(
!
HasScriptContent
(
)
)
{
if
(
mKind
=
=
JS
:
:
loader
:
:
ScriptKind
:
:
eClassic
&
&
!
mExternal
)
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
ScriptElement
:
:
MaybeProcessScript
"
[
]
(
)
{
nsAutoMicroTask
mt
;
}
)
)
;
}
return
false
;
}
nsAutoString
type
;
bool
hasType
=
GetScriptType
(
type
)
;
if
(
!
type
.
IsEmpty
(
)
)
{
NS_ENSURE_TRUE
(
nsContentUtils
:
:
IsJavascriptMIMEType
(
type
)
|
|
type
.
LowerCaseEqualsASCII
(
"
module
"
)
|
|
type
.
LowerCaseEqualsASCII
(
"
importmap
"
)
false
)
;
}
else
if
(
!
hasType
)
{
if
(
cont
-
>
IsHTMLElement
(
)
)
{
nsAutoString
language
;
cont
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
language
language
)
;
if
(
!
language
.
IsEmpty
(
)
&
&
!
nsContentUtils
:
:
IsJavaScriptLanguage
(
language
)
)
{
return
false
;
}
}
}
Document
*
ownerDoc
=
cont
-
>
OwnerDoc
(
)
;
FreezeExecutionAttrs
(
ownerDoc
)
;
mAlreadyStarted
=
true
;
nsCOMPtr
<
nsIParser
>
parser
=
(
(
nsIScriptElement
*
)
this
)
-
>
GetCreatorParser
(
)
;
if
(
parser
)
{
nsCOMPtr
<
nsIContentSink
>
sink
=
parser
-
>
GetContentSink
(
)
;
if
(
sink
)
{
nsCOMPtr
<
Document
>
parserDoc
=
do_QueryInterface
(
sink
-
>
GetTarget
(
)
)
;
if
(
ownerDoc
!
=
parserDoc
)
{
return
false
;
}
}
}
RefPtr
<
ScriptLoader
>
loader
=
ownerDoc
-
>
ScriptLoader
(
)
;
return
loader
-
>
ProcessScriptElement
(
this
type
)
;
}
bool
ScriptElement
:
:
GetScriptType
(
nsAString
&
aType
)
{
Element
*
element
=
GetAsContent
(
)
-
>
AsElement
(
)
;
nsAutoString
type
;
if
(
!
element
-
>
GetAttr
(
nsGkAtoms
:
:
type
type
)
)
{
return
false
;
}
static
const
char
kASCIIWhitespace
[
]
=
"
\
t
\
n
\
f
\
r
"
;
const
bool
wasEmptyBeforeTrim
=
type
.
IsEmpty
(
)
;
type
.
Trim
(
kASCIIWhitespace
)
;
if
(
!
wasEmptyBeforeTrim
&
&
type
.
IsEmpty
(
)
)
{
return
element
-
>
GetAttr
(
nsGkAtoms
:
:
type
aType
)
;
}
aType
.
Assign
(
type
)
;
return
true
;
}
