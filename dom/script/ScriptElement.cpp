#
include
"
ScriptElement
.
h
"
#
include
"
ScriptLoader
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
TrustedTypeUtils
.
h
"
#
include
"
mozilla
/
dom
/
TrustedTypesConstants
.
h
"
#
include
"
nsContentSink
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIMutationObserver
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsThreadUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMETHODIMP
ScriptElement
:
:
ScriptAvailable
(
nsresult
aResult
nsIScriptElement
*
aElement
bool
aIsInlineClassicScript
nsIURI
*
aURI
uint32_t
aLineNo
)
{
if
(
!
aIsInlineClassicScript
&
&
NS_FAILED
(
aResult
)
)
{
nsCOMPtr
<
nsIParser
>
parser
=
do_QueryReferent
(
mCreatorParser
)
;
if
(
parser
)
{
nsCOMPtr
<
nsIContentSink
>
sink
=
parser
-
>
GetContentSink
(
)
;
if
(
sink
)
{
nsCOMPtr
<
Document
>
parserDoc
=
do_QueryInterface
(
sink
-
>
GetTarget
(
)
)
;
if
(
GetAsContent
(
)
-
>
OwnerDoc
(
)
!
=
parserDoc
)
{
return
NS_OK
;
}
}
}
if
(
parser
)
{
parser
-
>
IncrementScriptNestingLevel
(
)
;
}
nsresult
rv
=
FireErrorEvent
(
)
;
if
(
parser
)
{
parser
-
>
DecrementScriptNestingLevel
(
)
;
}
return
rv
;
}
return
NS_OK
;
}
nsresult
ScriptElement
:
:
FireErrorEvent
(
)
{
nsIContent
*
cont
=
GetAsContent
(
)
;
return
nsContentUtils
:
:
DispatchTrustedEvent
(
cont
-
>
OwnerDoc
(
)
cont
u
"
error
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
}
NS_IMETHODIMP
ScriptElement
:
:
ScriptEvaluated
(
nsresult
aResult
nsIScriptElement
*
aElement
bool
aIsInline
)
{
nsresult
rv
=
NS_OK
;
if
(
!
aIsInline
)
{
nsCOMPtr
<
nsIContent
>
cont
=
GetAsContent
(
)
;
RefPtr
<
nsPresContext
>
presContext
=
nsContentUtils
:
:
GetContextForContent
(
cont
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventMessage
message
=
NS_SUCCEEDED
(
aResult
)
?
eLoad
:
eLoadError
;
WidgetEvent
event
(
true
message
)
;
event
.
mFlags
.
mBubbles
=
(
message
!
=
eLoad
)
;
EventDispatcher
:
:
Dispatch
(
cont
presContext
&
event
nullptr
&
status
)
;
}
return
rv
;
}
void
ScriptElement
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
UpdateTrustWorthiness
(
aInfo
.
mMutationEffectOnScript
)
;
MaybeProcessScript
(
)
;
}
void
ScriptElement
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
aElement
-
>
IsSVGElement
(
)
&
&
(
(
aNameSpaceID
!
=
kNameSpaceID_XLink
&
&
aNameSpaceID
!
=
kNameSpaceID_None
)
|
|
aAttribute
!
=
nsGkAtoms
:
:
href
)
)
{
return
;
}
if
(
aElement
-
>
IsHTMLElement
(
)
&
&
(
aNameSpaceID
!
=
kNameSpaceID_None
|
|
aAttribute
!
=
nsGkAtoms
:
:
src
)
)
{
return
;
}
if
(
mParserCreated
=
=
NOT_FROM_PARSER
&
&
aModType
=
=
AttrModType
:
:
Addition
)
{
auto
*
cont
=
GetAsContent
(
)
;
if
(
cont
-
>
IsInComposedDoc
(
)
)
{
MaybeProcessScript
(
)
;
}
}
}
void
ScriptElement
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
const
ContentAppendInfo
&
aInfo
)
{
UpdateTrustWorthiness
(
aInfo
.
mMutationEffectOnScript
)
;
MaybeProcessScript
(
)
;
}
void
ScriptElement
:
:
ContentInserted
(
nsIContent
*
aChild
const
ContentInsertInfo
&
aInfo
)
{
UpdateTrustWorthiness
(
aInfo
.
mMutationEffectOnScript
)
;
MaybeProcessScript
(
)
;
}
void
ScriptElement
:
:
ContentWillBeRemoved
(
nsIContent
*
aChild
const
ContentRemoveInfo
&
aInfo
)
{
UpdateTrustWorthiness
(
aInfo
.
mMutationEffectOnScript
)
;
}
bool
ScriptElement
:
:
MaybeProcessScript
(
)
{
nsIContent
*
cont
=
GetAsContent
(
)
;
NS_ASSERTION
(
cont
-
>
DebugGetSlots
(
)
-
>
mMutationObservers
.
contains
(
this
)
"
You
forgot
to
add
self
as
observer
"
)
;
if
(
mAlreadyStarted
|
|
!
mDoneAddingChildren
|
|
!
cont
-
>
GetComposedDoc
(
)
|
|
mMalformed
)
{
return
false
;
}
if
(
!
HasExternalScriptContent
(
)
&
&
!
mIsTrusted
)
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
ScriptElement
:
:
MaybeProcessScript
"
[
self
=
RefPtr
<
nsIScriptElement
>
(
this
)
]
(
)
MOZ_CAN_RUN_SCRIPT_BOUNDARY_LAMBDA
{
nsString
sourceText
;
self
-
>
GetTrustedTypesCompliantInlineScriptText
(
sourceText
)
;
(
(
ScriptElement
*
)
self
.
get
(
)
)
-
>
MaybeProcessScript
(
sourceText
)
;
}
)
)
;
return
false
;
}
return
MaybeProcessScript
(
VoidString
(
)
)
;
}
bool
ScriptElement
:
:
MaybeProcessScript
(
const
nsAString
&
aSourceText
)
{
nsIContent
*
cont
=
GetAsContent
(
)
;
if
(
!
HasExternalScriptContent
(
)
)
{
bool
hasInlineScriptContent
=
mIsTrusted
?
nsContentUtils
:
:
HasNonEmptyTextContent
(
cont
)
:
!
aSourceText
.
IsEmpty
(
)
;
if
(
!
hasInlineScriptContent
)
{
if
(
mKind
=
=
JS
:
:
loader
:
:
ScriptKind
:
:
eClassic
&
&
!
mExternal
)
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
ScriptElement
:
:
MaybeProcessScript
"
[
]
(
)
{
nsAutoMicroTask
mt
;
}
)
)
;
}
return
false
;
}
MOZ_ASSERT
(
mIsTrusted
=
=
aSourceText
.
IsVoid
(
)
)
;
}
nsAutoString
type
;
bool
hasType
=
GetScriptType
(
type
)
;
if
(
!
type
.
IsEmpty
(
)
)
{
if
(
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
type
)
&
&
!
type
.
LowerCaseEqualsASCII
(
"
module
"
)
&
&
!
type
.
LowerCaseEqualsASCII
(
"
importmap
"
)
)
{
#
ifdef
DEBUG
if
(
!
type
.
LowerCaseEqualsASCII
(
"
x
-
shader
/
x
-
vertex
"
)
&
&
!
type
.
LowerCaseEqualsASCII
(
"
x
-
shader
/
x
-
fragment
"
)
&
&
!
type
.
LowerCaseEqualsASCII
(
"
text
/
something
-
not
-
javascript
"
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Unknown
script
type
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
type
)
.
get
(
)
)
.
get
(
)
)
;
}
#
endif
return
false
;
}
}
else
if
(
!
hasType
)
{
if
(
cont
-
>
IsHTMLElement
(
)
)
{
nsAutoString
language
;
cont
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
language
language
)
;
if
(
!
language
.
IsEmpty
(
)
&
&
!
nsContentUtils
:
:
IsJavaScriptLanguage
(
language
)
)
{
return
false
;
}
}
}
Document
*
ownerDoc
=
cont
-
>
OwnerDoc
(
)
;
FreezeExecutionAttrs
(
ownerDoc
)
;
mAlreadyStarted
=
true
;
nsCOMPtr
<
nsIParser
>
parser
=
(
(
nsIScriptElement
*
)
this
)
-
>
GetCreatorParser
(
)
;
if
(
parser
)
{
nsCOMPtr
<
nsIContentSink
>
sink
=
parser
-
>
GetContentSink
(
)
;
if
(
sink
)
{
nsCOMPtr
<
Document
>
parserDoc
=
do_QueryInterface
(
sink
-
>
GetTarget
(
)
)
;
if
(
ownerDoc
!
=
parserDoc
)
{
return
false
;
}
}
}
RefPtr
<
ScriptLoader
>
loader
=
ownerDoc
-
>
ScriptLoader
(
)
;
return
loader
-
>
ProcessScriptElement
(
this
aSourceText
)
;
}
bool
ScriptElement
:
:
GetScriptType
(
nsAString
&
aType
)
{
Element
*
element
=
GetAsContent
(
)
-
>
AsElement
(
)
;
nsAutoString
type
;
if
(
!
element
-
>
GetAttr
(
nsGkAtoms
:
:
type
type
)
)
{
return
false
;
}
static
const
char
kASCIIWhitespace
[
]
=
"
\
t
\
n
\
f
\
r
"
;
const
bool
wasEmptyBeforeTrim
=
type
.
IsEmpty
(
)
;
type
.
Trim
(
kASCIIWhitespace
)
;
if
(
!
wasEmptyBeforeTrim
&
&
type
.
IsEmpty
(
)
)
{
return
element
-
>
GetAttr
(
nsGkAtoms
:
:
type
aType
)
;
}
aType
.
Assign
(
type
)
;
return
true
;
}
void
ScriptElement
:
:
UpdateTrustWorthiness
(
MutationEffectOnScript
aMutationEffectOnScript
)
{
if
(
aMutationEffectOnScript
=
=
MutationEffectOnScript
:
:
DropTrustWorthiness
&
&
StaticPrefs
:
:
dom_security_trusted_types_enabled
(
)
)
{
mIsTrusted
=
false
;
}
}
nsresult
ScriptElement
:
:
GetTrustedTypesCompliantInlineScriptText
(
nsString
&
aSourceText
)
{
MOZ_ASSERT
(
!
mIsTrusted
)
;
RefPtr
<
Element
>
element
=
GetAsContent
(
)
-
>
AsElement
(
)
;
nsAutoString
sourceText
;
GetScriptText
(
sourceText
)
;
MOZ_ASSERT
(
element
-
>
IsHTMLElement
(
)
|
|
element
-
>
IsSVGElement
(
)
)
;
Maybe
<
nsAutoString
>
compliantStringHolder
;
constexpr
nsLiteralString
htmlSinkName
=
u
"
HTMLScriptElement
text
"
_ns
;
constexpr
nsLiteralString
svgSinkName
=
u
"
SVGScriptElement
text
"
_ns
;
ErrorResult
error
;
nsCOMPtr
<
nsIPrincipal
>
subjectPrincipal
;
if
(
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
)
{
subjectPrincipal
=
nsContentUtils
:
:
SubjectPrincipal
(
cx
)
;
}
const
nsAString
*
compliantString
=
TrustedTypeUtils
:
:
GetTrustedTypesCompliantStringForTrustedScript
(
sourceText
element
-
>
IsHTMLElement
(
)
?
htmlSinkName
:
svgSinkName
kTrustedTypesOnlySinkGroup
*
element
subjectPrincipal
compliantStringHolder
error
)
;
if
(
!
error
.
Failed
(
)
)
{
aSourceText
.
Assign
(
*
compliantString
)
;
}
return
error
.
StealNSResult
(
)
;
}
