#
include
"
ScriptLoader
.
h
"
#
include
"
ScriptLoadHandler
.
h
"
#
include
"
ScriptLoadRequest
.
h
"
#
include
"
ScriptTrace
.
h
"
#
include
"
LoadedScript
.
h
"
#
include
"
ModuleLoadRequest
.
h
"
#
include
"
ModuleLoader
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
MemoryFunctions
.
h
"
#
include
"
js
/
Modules
.
h
"
#
include
"
js
/
OffThreadScriptCompilation
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
Realm
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
mozilla
/
dom
/
AutoEntryScript
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
JSExecutionContext
.
h
"
#
include
"
mozilla
/
dom
/
ScriptDecoding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
SRILogHelper
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
using
JS
:
:
SourceText
;
using
mozilla
:
:
Telemetry
:
:
LABELS_DOM_SCRIPT_PRELOAD_RESULT
;
namespace
mozilla
:
:
dom
{
LazyLogModule
ScriptLoader
:
:
gCspPRLog
(
"
CSP
"
)
;
LazyLogModule
ScriptLoader
:
:
gScriptLoaderLog
(
"
ScriptLoader
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
\
MOZ_LOG
(
ScriptLoader
:
:
gScriptLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
ScriptLoader
:
:
gScriptLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
)
static
constexpr
auto
kNullMimeType
=
"
javascript
/
null
"
_ns
;
NS_IMPL_ISUPPORTS
(
AsyncCompileShutdownObserver
nsIObserver
)
void
AsyncCompileShutdownObserver
:
:
OnShutdown
(
)
{
if
(
mScriptLoader
)
{
mScriptLoader
-
>
Destroy
(
)
;
MOZ_ASSERT
(
!
mScriptLoader
)
;
}
}
void
AsyncCompileShutdownObserver
:
:
Unregister
(
)
{
if
(
mScriptLoader
)
{
mScriptLoader
=
nullptr
;
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
}
}
NS_IMETHODIMP
AsyncCompileShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
OnShutdown
(
)
;
return
NS_OK
;
}
inline
void
ImplCycleCollectionUnlink
(
ScriptLoader
:
:
PreloadInfo
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mRequest
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ScriptLoader
:
:
PreloadInfo
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mRequest
aName
aFlags
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ScriptLoader
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
ScriptLoader
mNonAsyncExternalScriptInsertedRequests
mLoadingAsyncRequests
mLoadedAsyncRequests
mOffThreadCompilingRequests
mDeferRequests
mXSLTRequests
mParserBlockingRequest
mBytecodeEncodingQueue
mPreloads
mPendingChildLoaders
mModuleLoader
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ScriptLoader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ScriptLoader
)
ScriptLoader
:
:
ScriptLoader
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
mParserBlockingBlockerCount
(
0
)
mBlockerCount
(
0
)
mNumberOfProcessors
(
0
)
mTotalFullParseSize
(
0
)
mPhysicalSizeOfMemory
(
-
1
)
mEnabled
(
true
)
mDeferEnabled
(
false
)
mSpeculativeOMTParsingEnabled
(
false
)
mDeferCheckpointReached
(
false
)
mBlockingDOMContentLoaded
(
false
)
mLoadEventFired
(
false
)
mGiveUpEncoding
(
false
)
mReporter
(
new
ConsoleReportCollector
(
)
)
mModuleLoader
(
new
ModuleLoader
(
this
)
)
{
LOG
(
(
"
ScriptLoader
:
:
ScriptLoader
%
p
"
this
)
)
;
mSpeculativeOMTParsingEnabled
=
StaticPrefs
:
:
dom_script_loader_external_scripts_speculative_omt_parse_enabled
(
)
;
mShutdownObserver
=
new
AsyncCompileShutdownObserver
(
this
)
;
nsContentUtils
:
:
RegisterShutdownObserver
(
mShutdownObserver
)
;
}
ScriptLoader
:
:
~
ScriptLoader
(
)
{
LOG
(
(
"
ScriptLoader
:
:
~
ScriptLoader
%
p
"
this
)
)
;
mObservers
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
GetLoadContext
(
)
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mXSLTRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
GetLoadContext
(
)
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mDeferRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
GetLoadContext
(
)
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadingAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
GetLoadContext
(
)
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadedAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
GetLoadContext
(
)
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
GetLoadContext
(
)
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
uint32_t
j
=
0
;
j
<
mPendingChildLoaders
.
Length
(
)
;
+
+
j
)
{
mPendingChildLoaders
[
j
]
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
for
(
size_t
i
=
0
;
i
<
mPreloads
.
Length
(
)
;
i
+
+
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_PRELOAD_RESULT
:
:
NotUsed
)
;
}
if
(
mShutdownObserver
)
{
mShutdownObserver
-
>
Unregister
(
)
;
mShutdownObserver
=
nullptr
;
}
mModuleLoader
=
nullptr
;
}
static
void
CollectScriptTelemetry
(
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
if
(
!
CanRecordExtended
(
)
)
{
return
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_KIND
:
:
ModuleScript
)
;
}
else
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_KIND
:
:
ClassicScript
)
;
}
if
(
aRequest
-
>
IsLoadingSource
(
)
)
{
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
Inline
)
;
}
else
if
(
aRequest
-
>
IsTextSource
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
SourceFallback
)
;
}
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
if
(
aRequest
-
>
IsTextSource
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
Source
)
;
}
else
if
(
aRequest
-
>
IsBytecode
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
AltData
)
;
}
}
}
static
bool
IsScriptEventHandler
(
ScriptKind
kind
nsIContent
*
aScriptElement
)
{
if
(
kind
!
=
ScriptKind
:
:
eClassic
)
{
return
false
;
}
if
(
!
aScriptElement
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
nsAutoString
forAttr
eventAttr
;
if
(
!
aScriptElement
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
forAttr
)
|
|
!
aScriptElement
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
event
eventAttr
)
)
{
return
false
;
}
const
nsAString
&
for_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
forAttr
)
;
if
(
!
for_str
.
LowerCaseEqualsLiteral
(
"
window
"
)
)
{
return
true
;
}
const
nsAString
&
event_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
eventAttr
false
)
;
if
(
!
StringBeginsWith
(
event_str
u
"
onload
"
_ns
nsCaseInsensitiveStringComparator
)
)
{
return
true
;
}
nsAutoString
:
:
const_iterator
start
end
;
event_str
.
BeginReading
(
start
)
;
event_str
.
EndReading
(
end
)
;
start
.
advance
(
6
)
;
if
(
start
!
=
end
&
&
*
start
!
=
'
(
'
&
&
*
start
!
=
'
'
)
{
return
true
;
}
return
false
;
}
nsContentPolicyType
ScriptLoadRequestToContentPolicyType
(
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsPreload
(
)
)
{
return
aRequest
-
>
IsModuleRequest
(
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
;
}
return
aRequest
-
>
IsModuleRequest
(
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
}
nsresult
ScriptLoader
:
:
CheckContentPolicy
(
Document
*
aDocument
nsISupports
*
aContext
const
nsAString
&
aType
ScriptLoadRequest
*
aRequest
)
{
nsContentPolicyType
contentPolicyType
=
ScriptLoadRequestToContentPolicyType
(
aRequest
)
;
nsCOMPtr
<
nsINode
>
requestingNode
=
do_QueryInterface
(
aContext
)
;
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
net
:
:
LoadInfo
(
aDocument
-
>
NodePrincipal
(
)
aDocument
-
>
NodePrincipal
(
)
requestingNode
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
contentPolicyType
)
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aContext
)
;
if
(
node
)
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
node
-
>
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
secCheckLoadInfo
-
>
SetCspNonce
(
*
cspNonce
)
;
}
}
}
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
aRequest
-
>
mURI
secCheckLoadInfo
NS_LossyConvertUTF16toASCII
(
aType
)
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
NS_FAILED
(
rv
)
|
|
shouldLoad
!
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
return
NS_OK
;
}
bool
ScriptLoader
:
:
IsAboutPageLoadingChromeURI
(
ScriptLoadRequest
*
aRequest
Document
*
aDocument
)
{
if
(
!
aRequest
-
>
mURI
-
>
SchemeIs
(
"
chrome
"
)
)
{
return
false
;
}
uint32_t
aboutModuleFlags
=
0
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aRequest
-
>
TriggeringPrincipal
(
)
;
if
(
triggeringPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
if
(
!
triggeringPrincipal
-
>
SchemeIs
(
"
about
"
)
)
{
return
false
;
}
rv
=
triggeringPrincipal
-
>
GetAboutModuleFlags
(
&
aboutModuleFlags
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
}
else
if
(
triggeringPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
nsCOMPtr
<
nsIURI
>
docURI
=
aDocument
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
-
>
SchemeIs
(
"
about
"
)
)
{
return
false
;
}
nsCOMPtr
<
nsIAboutModule
>
aboutModule
;
rv
=
NS_GetAboutModule
(
docURI
getter_AddRefs
(
aboutModule
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
aboutModule
)
{
return
false
;
}
rv
=
aboutModule
-
>
GetURIFlags
(
docURI
&
aboutModuleFlags
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
}
else
{
return
false
;
}
if
(
aboutModuleFlags
&
nsIAboutModule
:
:
MAKE_LINKABLE
)
{
return
false
;
}
return
true
;
}
nsIURI
*
ScriptLoader
:
:
GetBaseURI
(
)
const
{
MOZ_ASSERT
(
mDocument
)
;
return
mDocument
-
>
GetDocBaseURI
(
)
;
}
static
ScriptLoader
*
GetCurrentScriptLoader
(
JSContext
*
aCx
)
{
auto
reportError
=
mozilla
:
:
MakeScopeExit
(
[
aCx
]
(
)
{
JS_ReportErrorASCII
(
aCx
"
No
ScriptLoader
found
for
the
current
context
"
)
;
}
)
;
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
if
(
!
object
)
{
return
nullptr
;
}
nsIGlobalObject
*
global
=
xpc
:
:
NativeGlobal
(
object
)
;
if
(
!
global
)
{
return
nullptr
;
}
nsGlobalWindowInner
*
innerWindow
=
nullptr
;
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
global
)
)
{
innerWindow
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
}
else
{
innerWindow
=
xpc
:
:
SandboxWindowOrNull
(
object
aCx
)
;
}
if
(
!
innerWindow
)
{
return
nullptr
;
}
Document
*
document
=
innerWindow
-
>
GetDocument
(
)
;
if
(
!
document
)
{
return
nullptr
;
}
ScriptLoader
*
loader
=
document
-
>
ScriptLoader
(
)
;
if
(
!
loader
)
{
return
nullptr
;
}
reportError
.
release
(
)
;
return
loader
;
}
static
LoadedScript
*
GetLoadedScriptOrNull
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
)
{
if
(
aReferencingPrivate
.
isUndefined
(
)
)
{
return
nullptr
;
}
auto
*
script
=
static_cast
<
LoadedScript
*
>
(
aReferencingPrivate
.
toPrivate
(
)
)
;
if
(
script
-
>
IsEventScript
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT_IF
(
script
-
>
IsModuleScript
(
)
JS
:
:
GetModulePrivate
(
script
-
>
AsModuleScript
(
)
-
>
ModuleRecord
(
)
)
=
=
aReferencingPrivate
)
;
return
script
;
}
bool
HostGetSupportedImportAssertions
(
JSContext
*
aCx
JS
:
:
ImportAssertionVector
&
aValues
)
{
MOZ_ASSERT
(
aValues
.
empty
(
)
)
;
if
(
!
aValues
.
reserve
(
1
)
)
{
JS_ReportOutOfMemory
(
aCx
)
;
return
false
;
}
aValues
.
infallibleAppend
(
JS
:
:
ImportAssertion
:
:
Type
)
;
return
true
;
}
JSObject
*
HostResolveImportedModule
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
JS
:
:
Handle
<
JSObject
*
>
aModuleRequest
)
{
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
)
;
{
RefPtr
<
LoadedScript
>
script
(
GetLoadedScriptOrNull
(
aCx
aReferencingPrivate
)
)
;
JS
:
:
Rooted
<
JSString
*
>
specifierString
(
aCx
JS
:
:
GetModuleRequestSpecifier
(
aCx
aModuleRequest
)
)
;
if
(
!
specifierString
)
{
return
nullptr
;
}
nsAutoJSString
string
;
if
(
!
string
.
init
(
aCx
specifierString
)
)
{
return
nullptr
;
}
RefPtr
<
ScriptLoader
>
loader
=
GetCurrentScriptLoader
(
aCx
)
;
if
(
!
loader
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
=
ModuleLoader
:
:
ResolveModuleSpecifier
(
loader
script
string
)
;
MOZ_ASSERT
(
uri
"
Failed
to
resolve
previously
-
resolved
module
specifier
"
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
;
if
(
BasePrincipal
:
:
Cast
(
nsContentUtils
:
:
SubjectPrincipal
(
aCx
)
)
-
>
ContentScriptAddonPolicy
(
)
)
{
global
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
MOZ_ASSERT
(
global
)
;
MOZ_ASSERT
(
xpc
:
:
IsWebExtensionContentScriptSandbox
(
global
-
>
GetGlobalJSObject
(
)
)
)
;
}
ModuleScript
*
ms
=
loader
-
>
GetModuleLoader
(
)
-
>
GetFetchedModule
(
uri
global
)
;
MOZ_ASSERT
(
ms
"
Resolved
module
not
found
in
module
map
"
)
;
MOZ_ASSERT
(
!
ms
-
>
HasParseError
(
)
)
;
MOZ_ASSERT
(
ms
-
>
ModuleRecord
(
)
)
;
module
.
set
(
ms
-
>
ModuleRecord
(
)
)
;
}
return
module
;
}
bool
HostPopulateImportMeta
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
JS
:
:
Handle
<
JSObject
*
>
aMetaObject
)
{
RefPtr
<
ModuleScript
>
script
=
static_cast
<
ModuleScript
*
>
(
aReferencingPrivate
.
toPrivate
(
)
)
;
MOZ_ASSERT
(
script
-
>
IsModuleScript
(
)
)
;
MOZ_ASSERT
(
JS
:
:
GetModulePrivate
(
script
-
>
ModuleRecord
(
)
)
=
=
aReferencingPrivate
)
;
nsAutoCString
url
;
MOZ_DIAGNOSTIC_ASSERT
(
script
-
>
BaseURL
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
script
-
>
BaseURL
(
)
-
>
GetAsciiSpec
(
url
)
)
;
JS
:
:
Rooted
<
JSString
*
>
urlString
(
aCx
JS_NewStringCopyZ
(
aCx
url
.
get
(
)
)
)
;
if
(
!
urlString
)
{
JS_ReportOutOfMemory
(
aCx
)
;
return
false
;
}
return
JS_DefineProperty
(
aCx
aMetaObject
"
url
"
urlString
JSPROP_ENUMERATE
)
;
}
bool
HostImportModuleDynamically
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
JS
:
:
Handle
<
JSObject
*
>
aModuleRequest
JS
:
:
Handle
<
JSObject
*
>
aPromise
)
{
RefPtr
<
LoadedScript
>
script
(
GetLoadedScriptOrNull
(
aCx
aReferencingPrivate
)
)
;
JS
:
:
Rooted
<
JSString
*
>
specifierString
(
aCx
JS
:
:
GetModuleRequestSpecifier
(
aCx
aModuleRequest
)
)
;
if
(
!
specifierString
)
{
return
false
;
}
nsAutoJSString
specifier
;
if
(
!
specifier
.
init
(
aCx
specifierString
)
)
{
return
false
;
}
RefPtr
<
ScriptLoader
>
loader
=
GetCurrentScriptLoader
(
aCx
)
;
if
(
!
loader
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
=
ModuleLoader
:
:
ResolveModuleSpecifier
(
loader
script
specifier
)
;
if
(
!
uri
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
nsresult
rv
=
ModuleLoader
:
:
HandleResolveFailure
(
aCx
script
specifier
0
0
&
error
)
;
if
(
NS_FAILED
(
rv
)
)
{
JS_ReportOutOfMemory
(
aCx
)
;
return
false
;
}
JS_SetPendingException
(
aCx
error
)
;
return
false
;
}
ScriptFetchOptions
*
options
;
nsIURI
*
baseURL
;
if
(
script
)
{
options
=
script
-
>
GetFetchOptions
(
)
;
baseURL
=
script
-
>
BaseURL
(
)
;
}
else
{
Document
*
document
=
loader
-
>
GetDocument
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
nsContentUtils
:
:
SubjectPrincipal
(
aCx
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
CurrentNativeGlobal
(
aCx
)
;
if
(
!
BasePrincipal
:
:
Cast
(
principal
)
-
>
ContentScriptAddonPolicy
(
)
)
{
principal
=
document
-
>
NodePrincipal
(
)
;
MOZ_ASSERT
(
global
)
;
global
=
nullptr
;
}
else
{
MOZ_ASSERT
(
xpc
:
:
IsWebExtensionContentScriptSandbox
(
global
-
>
GetGlobalJSObject
(
)
)
)
;
}
options
=
new
ScriptFetchOptions
(
mozilla
:
:
CORS_NONE
document
-
>
GetReferrerPolicy
(
)
nullptr
principal
global
)
;
baseURL
=
document
-
>
GetDocBaseURI
(
)
;
}
RefPtr
<
ModuleLoadRequest
>
request
=
ModuleLoadRequest
:
:
CreateDynamicImport
(
uri
options
baseURL
loader
aReferencingPrivate
specifierString
aPromise
)
;
loader
-
>
GetModuleLoader
(
)
-
>
StartDynamicImport
(
request
)
;
return
true
;
}
void
DynamicImportPrefChangedCallback
(
const
char
*
aPrefName
void
*
aClosure
)
{
bool
enabled
=
Preferences
:
:
GetBool
(
aPrefName
)
;
JS
:
:
ModuleDynamicImportHook
hook
=
enabled
?
HostImportModuleDynamically
:
nullptr
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSRuntime
*
rt
=
JS_GetRuntime
(
jsapi
.
cx
(
)
)
;
JS
:
:
SetModuleDynamicImportHook
(
rt
hook
)
;
}
void
ScriptLoader
:
:
EnsureModuleHooksInitialized
(
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSRuntime
*
rt
=
JS_GetRuntime
(
jsapi
.
cx
(
)
)
;
if
(
JS
:
:
GetModuleResolveHook
(
rt
)
)
{
return
;
}
JS
:
:
SetModuleResolveHook
(
rt
HostResolveImportedModule
)
;
JS
:
:
SetModuleMetadataHook
(
rt
HostPopulateImportMeta
)
;
JS
:
:
SetScriptPrivateReferenceHooks
(
rt
HostAddRefTopLevelScript
HostReleaseTopLevelScript
)
;
JS
:
:
SetSupportedAssertionsHook
(
rt
HostGetSupportedImportAssertions
)
;
Preferences
:
:
RegisterCallbackAndCall
(
DynamicImportPrefChangedCallback
"
javascript
.
options
.
dynamicImport
"
(
void
*
)
nullptr
)
;
}
class
ScriptRequestProcessor
:
public
Runnable
{
private
:
RefPtr
<
ScriptLoader
>
mLoader
;
RefPtr
<
ScriptLoadRequest
>
mRequest
;
public
:
ScriptRequestProcessor
(
ScriptLoader
*
aLoader
ScriptLoadRequest
*
aRequest
)
:
Runnable
(
"
dom
:
:
ScriptRequestProcessor
"
)
mLoader
(
aLoader
)
mRequest
(
aRequest
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mRequest
-
>
IsModuleRequest
(
)
&
&
mRequest
-
>
AsModuleRequest
(
)
-
>
IsDynamicImport
(
)
)
{
mLoader
-
>
GetModuleLoader
(
)
-
>
ProcessDynamicImport
(
mRequest
-
>
AsModuleRequest
(
)
)
;
return
NS_OK
;
}
return
mLoader
-
>
ProcessRequest
(
mRequest
)
;
}
}
;
void
ScriptLoader
:
:
RunScriptWhenSafe
(
ScriptLoadRequest
*
aRequest
)
{
auto
*
runnable
=
new
ScriptRequestProcessor
(
this
aRequest
)
;
nsContentUtils
:
:
AddScriptRunner
(
runnable
)
;
}
void
ScriptLoader
:
:
ProcessLoadedModuleTree
(
ModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsReadyToRun
(
)
)
;
if
(
aRequest
-
>
IsTopLevel
(
)
)
{
if
(
aRequest
-
>
IsDynamicImport
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
isInList
(
)
)
;
RefPtr
<
ScriptLoadRequest
>
req
=
mModuleLoader
-
>
mDynamicImportRequests
.
Steal
(
aRequest
)
;
RunScriptWhenSafe
(
aRequest
)
;
}
else
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
&
&
aRequest
-
>
GetLoadContext
(
)
-
>
GetParserCreated
(
)
=
=
NOT_FROM_PARSER
)
{
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
RunScriptWhenSafe
(
aRequest
)
;
}
else
{
MaybeMoveToLoadedList
(
aRequest
)
;
ProcessPendingRequests
(
)
;
}
}
aRequest
-
>
GetLoadContext
(
)
-
>
MaybeUnblockOnload
(
)
;
}
nsresult
ScriptLoader
:
:
RestartLoad
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsBytecode
(
)
)
;
aRequest
-
>
mScriptBytecode
.
clearAndFree
(
)
;
TRACE_FOR_TEST
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_fallback
"
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
NotifyRestart
(
mDocument
)
;
aRequest
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
eLoading_Source
;
nsresult
rv
=
StartLoad
(
aRequest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_BINDING_RETARGETED
;
}
nsresult
ScriptLoader
:
:
StartClassicLoad
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NULL_POINTER
)
;
aRequest
-
>
SetUnknownDataType
(
)
;
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
NS_OK
;
}
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
url
;
aRequest
-
>
mURI
-
>
GetAsciiSpec
(
url
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Start
Classic
Load
(
url
=
%
s
)
"
aRequest
url
.
get
(
)
)
)
;
}
nsSecurityFlags
securityFlags
=
aRequest
-
>
CORSMode
(
)
=
=
CORS_NONE
?
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
:
nsILoadInfo
:
:
SEC_REQUIRE_CORS_INHERITS_SEC_CONTEXT
;
if
(
aRequest
-
>
CORSMode
(
)
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
aRequest
-
>
CORSMode
(
)
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsresult
rv
=
StartLoadInternal
(
aRequest
securityFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
StartModuleLoad
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NULL_POINTER
)
;
aRequest
-
>
SetUnknownDataType
(
)
;
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
NS_OK
;
}
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
url
;
aRequest
-
>
mURI
-
>
GetAsciiSpec
(
url
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Start
Module
Load
(
url
=
%
s
)
"
aRequest
url
.
get
(
)
)
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aRequest
-
>
TriggeringPrincipal
(
)
;
if
(
BasePrincipal
:
:
Cast
(
principal
)
-
>
ContentScriptAddonPolicy
(
)
&
&
!
aRequest
-
>
mURI
-
>
SchemeIs
(
"
moz
-
extension
"
)
)
{
return
NS_ERROR_DOM_WEBEXT_CONTENT_SCRIPT_URI
;
}
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
mModuleLoader
-
>
ModuleMapContainsURL
(
request
-
>
mURI
aRequest
-
>
GetWebExtGlobal
(
)
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Waiting
for
module
fetch
"
aRequest
)
)
;
mModuleLoader
-
>
WaitForModuleFetch
(
request
-
>
mURI
aRequest
-
>
GetWebExtGlobal
(
)
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
request
&
ModuleLoadRequest
:
:
ModuleLoaded
&
ModuleLoadRequest
:
:
LoadFailed
)
;
return
NS_OK
;
}
nsSecurityFlags
securityFlags
;
if
(
IsAboutPageLoadingChromeURI
(
aRequest
mDocument
)
)
{
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
;
}
else
{
securityFlags
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_INHERITS_SEC_CONTEXT
;
if
(
aRequest
-
>
CORSMode
(
)
=
=
CORS_NONE
|
|
aRequest
-
>
CORSMode
(
)
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
{
MOZ_ASSERT
(
aRequest
-
>
CORSMode
(
)
=
=
CORS_USE_CREDENTIALS
)
;
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsresult
rv
=
StartLoadInternal
(
aRequest
securityFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mModuleLoader
-
>
SetModuleFetchStarted
(
aRequest
-
>
AsModuleRequest
(
)
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Start
fetching
module
"
aRequest
)
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
StartLoadInternal
(
ScriptLoadRequest
*
aRequest
nsSecurityFlags
securityFlags
)
{
nsContentPolicyType
contentPolicyType
=
ScriptLoadRequestToContentPolicyType
(
aRequest
)
;
nsCOMPtr
<
nsINode
>
context
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
)
{
context
=
do_QueryInterface
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
)
;
}
else
{
context
=
mDocument
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_NULL_POINTER
)
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
prompter
(
do_QueryInterface
(
docshell
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannelWithTriggeringPrincipal
(
getter_AddRefs
(
channel
)
aRequest
-
>
mURI
context
aRequest
-
>
TriggeringPrincipal
(
)
securityFlags
contentPolicyType
nullptr
loadGroup
prompter
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
|
|
contentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
)
{
if
(
context
)
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
context
-
>
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetCspNonce
(
*
cspNonce
)
;
}
}
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
WebExtGlobal
:
:
Ignore
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
aRequest
-
>
mCacheInfo
=
nullptr
;
nsCOMPtr
<
nsICacheInfoChannel
>
cic
(
do_QueryInterface
(
channel
)
)
;
if
(
cic
&
&
StaticPrefs
:
:
dom_script_loader_bytecode_cache_enabled
(
)
&
&
!
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
GetWebExtGlobal
(
)
"
Can
not
bytecode
cache
WebExt
code
"
)
;
if
(
!
aRequest
-
>
IsLoadingSource
(
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Maybe
request
bytecode
"
aRequest
)
)
;
cic
-
>
PreferAlternativeDataType
(
nsContentUtils
:
:
JSBytecodeMimeType
(
)
"
"
_ns
nsICacheInfoChannel
:
:
PreferredAlternativeDataDeliveryType
:
:
ASYNC
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Request
saving
bytecode
later
"
aRequest
)
)
;
cic
-
>
PreferAlternativeDataType
(
kNullMimeType
"
"
_ns
nsICacheInfoChannel
:
:
PreferredAlternativeDataDeliveryType
:
:
ASYNC
)
;
}
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
mode
=
%
u
tracking
=
%
d
"
aRequest
unsigned
(
aRequest
-
>
GetLoadContext
(
)
-
>
mScriptMode
)
aRequest
-
>
GetLoadContext
(
)
-
>
IsTracking
(
)
)
)
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
{
DOMScriptLoadContext
:
:
PrioritizeAsPreload
(
channel
)
;
DOMScriptLoadContext
:
:
AddLoadBackgroundFlag
(
channel
)
;
}
else
if
(
nsCOMPtr
<
nsIClassOfService
>
cos
=
do_QueryInterface
(
channel
)
)
{
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mScriptFromHead
&
&
aRequest
-
>
GetLoadContext
(
)
-
>
IsBlockingScript
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
else
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsDeferredScript
(
)
&
&
!
StaticPrefs
:
:
network_http_tailing_enabled
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
TailForbidden
)
;
}
else
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Unblocked
)
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsAsyncScript
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
TailAllowed
)
;
}
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
nsAutoCString
acceptTypes
(
"
*
/
*
"
)
;
rv
=
httpChannel
-
>
SetRequestHeader
(
"
Accept
"
_ns
acceptTypes
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
aRequest
-
>
mReferrer
aRequest
-
>
ReferrerPolicy
(
)
)
;
rv
=
httpChannel
-
>
SetReferrerInfoWithoutClone
(
referrerInfo
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
internalChannel
)
{
rv
=
internalChannel
-
>
SetIntegrityMetadata
(
aRequest
-
>
mIntegrity
.
GetIntegrityString
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
mozilla
:
:
net
:
:
PredictorLearn
(
aRequest
-
>
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChannel
)
{
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
{
timedChannel
-
>
SetInitiatorType
(
u
"
link
"
_ns
)
;
}
else
{
timedChannel
-
>
SetInitiatorType
(
u
"
script
"
_ns
)
;
}
}
UniquePtr
<
mozilla
:
:
dom
:
:
SRICheckDataVerifier
>
sriDataVerifier
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
)
{
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
sriDataVerifier
=
MakeUnique
<
SRICheckDataVerifier
>
(
aRequest
-
>
mIntegrity
sourceUri
mReporter
)
;
}
RefPtr
<
ScriptLoadHandler
>
handler
=
new
ScriptLoadHandler
(
this
aRequest
std
:
:
move
(
sriDataVerifier
)
)
;
nsCOMPtr
<
nsIIncrementalStreamLoader
>
loader
;
rv
=
NS_NewIncrementalStreamLoader
(
getter_AddRefs
(
loader
)
handler
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
key
=
PreloadHashKey
:
:
CreateAsScript
(
aRequest
-
>
mURI
aRequest
-
>
CORSMode
(
)
aRequest
-
>
mKind
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
NotifyOpen
(
key
channel
mDocument
aRequest
-
>
GetLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
;
rv
=
channel
-
>
AsyncOpen
(
loader
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRequest
-
>
GetLoadContext
(
)
-
>
NotifyStart
(
channel
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
NotifyStop
(
rv
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
bool
ScriptLoader
:
:
PreloadURIComparator
:
:
Equals
(
const
PreloadInfo
&
aPi
nsIURI
*
const
&
aURI
)
const
{
bool
same
;
return
NS_SUCCEEDED
(
aPi
.
mRequest
-
>
mURI
-
>
Equals
(
aURI
&
same
)
)
&
&
same
;
}
static
bool
CSPAllowsInlineScript
(
nsIScriptElement
*
aElement
Document
*
aDocument
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
nsresult
rv
=
NS_OK
;
if
(
!
csp
)
{
return
true
;
}
nsCOMPtr
<
Element
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
nsAutoString
nonce
;
if
(
scriptContent
)
{
nsString
*
cspNonce
=
static_cast
<
nsString
*
>
(
scriptContent
-
>
GetProperty
(
nsGkAtoms
:
:
nonce
)
)
;
if
(
cspNonce
)
{
nonce
=
*
cspNonce
;
}
}
bool
parserCreated
=
aElement
-
>
GetParserCreated
(
)
!
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
;
bool
allowInlineScript
=
false
;
rv
=
csp
-
>
GetAllowsInline
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_DIRECTIVE
nonce
parserCreated
scriptContent
nullptr
u
"
"
_ns
aElement
-
>
GetScriptLineNumber
(
)
aElement
-
>
GetScriptColumnNumber
(
)
&
allowInlineScript
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
allowInlineScript
;
}
ScriptLoadRequest
*
ScriptLoader
:
:
CreateLoadRequest
(
ScriptKind
aKind
nsIURI
*
aURI
nsIScriptElement
*
aElement
nsIPrincipal
*
aTriggeringPrincipal
CORSMode
aCORSMode
const
SRIMetadata
&
aIntegrity
ReferrerPolicy
aReferrerPolicy
)
{
nsIURI
*
referrer
=
mDocument
-
>
GetDocumentURIAsReferrer
(
)
;
nsCOMPtr
<
Element
>
domElement
=
do_QueryInterface
(
aElement
)
;
ScriptFetchOptions
*
fetchOptions
=
new
ScriptFetchOptions
(
aCORSMode
aReferrerPolicy
domElement
aTriggeringPrincipal
nullptr
)
;
if
(
aKind
=
=
ScriptKind
:
:
eClassic
)
{
ScriptLoadRequest
*
aRequest
=
new
ScriptLoadRequest
(
aKind
aURI
fetchOptions
aIntegrity
referrer
)
;
DOMScriptLoadContext
*
aContext
=
new
DOMScriptLoadContext
(
aRequest
)
;
aRequest
-
>
mLoadContext
=
aContext
;
return
aRequest
;
}
MOZ_ASSERT
(
aKind
=
=
ScriptKind
:
:
eModule
)
;
return
ModuleLoadRequest
:
:
CreateTopLevel
(
aURI
fetchOptions
aIntegrity
referrer
this
)
;
}
bool
ScriptLoader
:
:
ProcessScriptElement
(
nsIScriptElement
*
aElement
)
{
NS_ENSURE_TRUE
(
mDocument
false
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
false
;
}
NS_ASSERTION
(
!
aElement
-
>
IsMalformed
(
)
"
Executing
malformed
script
"
)
;
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
nsAutoString
type
;
bool
hasType
=
aElement
-
>
GetScriptType
(
type
)
;
ScriptKind
scriptKind
=
aElement
-
>
GetScriptIsModule
(
)
?
ScriptKind
:
:
eModule
:
ScriptKind
:
:
eClassic
;
if
(
IsScriptEventHandler
(
scriptKind
scriptContent
)
)
{
return
false
;
}
if
(
scriptKind
=
=
ScriptKind
:
:
eClassic
)
{
if
(
!
type
.
IsEmpty
(
)
)
{
NS_ENSURE_TRUE
(
nsContentUtils
:
:
IsJavascriptMIMEType
(
type
)
false
)
;
}
else
if
(
!
hasType
)
{
if
(
scriptContent
-
>
IsHTMLElement
(
)
)
{
nsAutoString
language
;
scriptContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
language
language
)
;
if
(
!
language
.
IsEmpty
(
)
)
{
if
(
!
nsContentUtils
:
:
IsJavaScriptLanguage
(
language
)
)
{
return
false
;
}
}
}
}
}
if
(
mDocument
-
>
ModuleScriptsEnabled
(
)
&
&
scriptKind
=
=
ScriptKind
:
:
eClassic
&
&
scriptContent
-
>
IsHTMLElement
(
)
&
&
scriptContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
nomodule
)
)
{
return
false
;
}
if
(
aElement
-
>
GetScriptExternal
(
)
)
{
return
ProcessExternalScript
(
aElement
scriptKind
type
scriptContent
)
;
}
return
ProcessInlineScript
(
aElement
scriptKind
)
;
}
bool
ScriptLoader
:
:
ProcessExternalScript
(
nsIScriptElement
*
aElement
ScriptKind
aScriptKind
const
nsAutoString
&
aTypeAttr
nsIContent
*
aScriptContent
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Process
external
script
for
element
%
p
"
this
aElement
)
)
;
nsCOMPtr
<
nsIURI
>
scriptURI
=
aElement
-
>
GetScriptURI
(
)
;
if
(
!
scriptURI
)
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
SRIMetadata
sriMetadata
;
{
nsAutoString
integrity
;
aScriptContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
integrity
integrity
)
;
GetSRIMetadata
(
integrity
&
sriMetadata
)
;
}
RefPtr
<
ScriptLoadRequest
>
request
=
LookupPreloadRequest
(
aElement
aScriptKind
sriMetadata
)
;
if
(
request
&
&
NS_FAILED
(
CheckContentPolicy
(
mDocument
aElement
aTypeAttr
request
)
)
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
content
policy
check
failed
for
preload
"
this
)
)
;
request
-
>
Cancel
(
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_PRELOAD_RESULT
:
:
RejectedByPolicy
)
;
return
false
;
}
if
(
request
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Using
preload
request
"
request
.
get
(
)
)
)
;
request
-
>
GetLoadContext
(
)
-
>
SetScriptMode
(
aElement
-
>
GetScriptDeferred
(
)
aElement
-
>
GetScriptAsync
(
)
false
)
;
if
(
request
-
>
GetLoadContext
(
)
-
>
mInCompilingList
)
{
mOffThreadCompilingRequests
.
Remove
(
request
)
;
request
-
>
GetLoadContext
(
)
-
>
mInCompilingList
=
false
;
}
AccumulateCategorical
(
LABELS_DOM_SCRIPT_PRELOAD_RESULT
:
:
Used
)
;
}
else
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aElement
-
>
GetScriptURITriggeringPrincipal
(
)
;
if
(
!
principal
)
{
principal
=
aScriptContent
-
>
NodePrincipal
(
)
;
}
CORSMode
ourCORSMode
=
aElement
-
>
GetCORSMode
(
)
;
ReferrerPolicy
referrerPolicy
=
GetReferrerPolicy
(
aElement
)
;
request
=
CreateLoadRequest
(
aScriptKind
scriptURI
aElement
principal
ourCORSMode
sriMetadata
referrerPolicy
)
;
request
-
>
GetLoadContext
(
)
-
>
mIsInline
=
false
;
request
-
>
GetLoadContext
(
)
-
>
SetScriptMode
(
aElement
-
>
GetScriptDeferred
(
)
aElement
-
>
GetScriptAsync
(
)
false
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Created
request
for
external
script
"
request
.
get
(
)
)
)
;
nsresult
rv
=
StartLoad
(
request
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportErrorToConsole
(
request
rv
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
;
if
(
mDocument
)
{
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
runnable
)
;
}
return
false
;
}
}
NS_ASSERTION
(
SpeculativeOMTParsingEnabled
(
)
|
|
!
request
-
>
GetLoadContext
(
)
-
>
CompileStarted
(
)
|
|
request
-
>
IsModuleRequest
(
)
"
Request
should
not
yet
be
in
compiling
stage
.
"
)
;
if
(
request
-
>
GetLoadContext
(
)
-
>
IsAsyncScript
(
)
)
{
AddAsyncRequest
(
request
)
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
false
;
}
if
(
!
aElement
-
>
GetParserCreated
(
)
)
{
request
-
>
GetLoadContext
(
)
-
>
mIsNonAsyncScriptInserted
=
true
;
mNonAsyncExternalScriptInsertedRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
false
;
}
if
(
request
-
>
GetLoadContext
(
)
-
>
IsDeferredScript
(
)
)
{
NS_ASSERTION
(
mDocument
-
>
GetCurrentContentSink
(
)
|
|
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
"
Non
-
XSLT
Defer
script
on
a
document
without
an
active
"
"
parser
;
bug
592366
.
"
)
;
AddDeferRequest
(
request
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
request
-
>
GetLoadContext
(
)
-
>
mIsXSLT
=
true
;
mXSLTRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
true
;
}
if
(
request
-
>
IsReadyToRun
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
ProcessPendingRequestsAsync
(
)
;
return
true
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
return
true
;
}
bool
ScriptLoader
:
:
ProcessInlineScript
(
nsIScriptElement
*
aElement
ScriptKind
aScriptKind
)
{
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
false
;
}
if
(
!
CSPAllowsInlineScript
(
aElement
mDocument
)
)
{
return
false
;
}
CORSMode
corsMode
=
CORS_NONE
;
if
(
aScriptKind
=
=
ScriptKind
:
:
eModule
)
{
corsMode
=
aElement
-
>
GetCORSMode
(
)
;
}
ReferrerPolicy
referrerPolicy
=
GetReferrerPolicy
(
aElement
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
CreateLoadRequest
(
aScriptKind
mDocument
-
>
GetDocumentURI
(
)
aElement
mDocument
-
>
NodePrincipal
(
)
corsMode
SRIMetadata
(
)
referrerPolicy
)
;
request
-
>
GetLoadContext
(
)
-
>
mIsInline
=
true
;
request
-
>
mLineNo
=
aElement
-
>
GetScriptLineNumber
(
)
;
request
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
eLoading_Source
;
request
-
>
SetTextSource
(
)
;
TRACE_FOR_TEST_BOOL
(
request
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_load_source
"
)
;
CollectScriptTelemetry
(
request
)
;
MOZ_ASSERT
(
!
aElement
-
>
GetScriptDeferred
(
)
)
;
MOZ_ASSERT_IF
(
!
request
-
>
IsModuleRequest
(
)
!
aElement
-
>
GetScriptAsync
(
)
)
;
request
-
>
GetLoadContext
(
)
-
>
SetScriptMode
(
false
aElement
-
>
GetScriptAsync
(
)
false
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Created
request
for
inline
script
"
request
.
get
(
)
)
)
;
request
-
>
mBaseURL
=
mDocument
-
>
GetDocBaseURI
(
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
modReq
=
request
-
>
AsModuleRequest
(
)
;
if
(
aElement
-
>
GetParserCreated
(
)
!
=
NOT_FROM_PARSER
)
{
if
(
aElement
-
>
GetScriptAsync
(
)
)
{
AddAsyncRequest
(
modReq
)
;
}
else
{
AddDeferRequest
(
modReq
)
;
}
}
nsresult
rv
=
mModuleLoader
-
>
ProcessFetchedModuleSource
(
modReq
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportErrorToConsole
(
modReq
rv
)
;
HandleLoadError
(
modReq
rv
)
;
}
return
false
;
}
request
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
eReady
;
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
&
&
(
!
ReadyToExecuteParserBlockingScripts
(
)
|
|
!
mXSLTRequests
.
isEmpty
(
)
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mXSLTRequests
.
AppendElement
(
request
)
;
return
true
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
NOT_FROM_PARSER
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
A
script
-
inserted
script
is
inserted
without
an
update
batch
?
"
)
;
RunScriptWhenSafe
(
request
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
&
&
!
ReadyToExecuteParserBlockingScripts
(
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
mParserBlockingRequest
=
request
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
return
true
;
}
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Not
safe
to
run
a
parser
-
inserted
script
?
"
)
;
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
ScriptLoadRequest
*
ScriptLoader
:
:
LookupPreloadRequest
(
nsIScriptElement
*
aElement
ScriptKind
aScriptKind
const
SRIMetadata
&
aSRIMetadata
)
{
MOZ_ASSERT
(
aElement
)
;
nsTArray
<
PreloadInfo
>
:
:
index_type
i
=
mPreloads
.
IndexOf
(
aElement
-
>
GetScriptURI
(
)
0
PreloadURIComparator
(
)
)
;
if
(
i
=
=
nsTArray
<
PreloadInfo
>
:
:
NoIndex
)
{
return
nullptr
;
}
RefPtr
<
ScriptLoadRequest
>
request
=
mPreloads
[
i
]
.
mRequest
;
request
-
>
GetLoadContext
(
)
-
>
SetIsLoadRequest
(
aElement
)
;
if
(
request
-
>
GetLoadContext
(
)
-
>
mWasCompiledOMT
&
&
!
request
-
>
IsModuleRequest
(
)
)
{
request
-
>
SetReady
(
)
;
}
nsString
preloadCharset
(
mPreloads
[
i
]
.
mCharset
)
;
mPreloads
.
RemoveElementAt
(
i
)
;
nsAutoString
elementCharset
;
aElement
-
>
GetScriptCharset
(
elementCharset
)
;
if
(
!
elementCharset
.
Equals
(
preloadCharset
)
|
|
aElement
-
>
GetCORSMode
(
)
!
=
request
-
>
CORSMode
(
)
|
|
aScriptKind
!
=
request
-
>
mKind
)
{
request
-
>
Cancel
(
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_PRELOAD_RESULT
:
:
RequestMismatch
)
;
return
nullptr
;
}
if
(
!
aSRIMetadata
.
CanTrustBeDelegatedTo
(
request
-
>
mIntegrity
)
)
{
if
(
!
request
-
>
GetLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
{
request
-
>
Cancel
(
)
;
}
return
nullptr
;
}
ReportPreloadErrorsToConsole
(
request
)
;
request
-
>
GetLoadContext
(
)
-
>
NotifyUsage
(
)
;
request
-
>
GetLoadContext
(
)
-
>
RemoveSelf
(
mDocument
)
;
return
request
;
}
void
ScriptLoader
:
:
GetSRIMetadata
(
const
nsAString
&
aIntegrityAttr
SRIMetadata
*
aMetadataOut
)
{
MOZ_ASSERT
(
aMetadataOut
-
>
IsEmpty
(
)
)
;
if
(
aIntegrityAttr
.
IsEmpty
(
)
)
{
return
;
}
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
ScriptLoader
:
:
GetSRIMetadata
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrityAttr
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
aIntegrityAttr
sourceUri
mReporter
aMetadataOut
)
;
}
ReferrerPolicy
ScriptLoader
:
:
GetReferrerPolicy
(
nsIScriptElement
*
aElement
)
{
ReferrerPolicy
scriptReferrerPolicy
=
aElement
-
>
GetReferrerPolicy
(
)
;
if
(
scriptReferrerPolicy
!
=
ReferrerPolicy
:
:
_empty
)
{
return
scriptReferrerPolicy
;
}
return
mDocument
-
>
GetReferrerPolicy
(
)
;
}
namespace
{
class
NotifyOffThreadScriptLoadCompletedRunnable
:
public
Runnable
{
RefPtr
<
ScriptLoadRequest
>
mRequest
;
RefPtr
<
ScriptLoader
>
mLoader
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
JS
:
:
OffThreadToken
*
mToken
;
public
:
ScriptLoadRequest
*
GetScriptLoadRequest
(
)
{
return
mRequest
;
}
NotifyOffThreadScriptLoadCompletedRunnable
(
ScriptLoadRequest
*
aRequest
ScriptLoader
*
aLoader
)
:
Runnable
(
"
dom
:
:
NotifyOffThreadScriptLoadCompletedRunnable
"
)
mRequest
(
aRequest
)
mLoader
(
aLoader
)
mToken
(
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
DocGroup
*
docGroup
=
aLoader
-
>
GetDocGroup
(
)
)
{
mEventTarget
=
docGroup
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
}
virtual
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
;
void
SetToken
(
JS
:
:
OffThreadToken
*
aToken
)
{
MOZ_ASSERT
(
aToken
&
&
!
mToken
)
;
mToken
=
aToken
;
}
static
void
Dispatch
(
already_AddRefed
<
NotifyOffThreadScriptLoadCompletedRunnable
>
&
&
aSelf
)
{
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
self
=
aSelf
;
nsCOMPtr
<
nsISerialEventTarget
>
eventTarget
=
self
-
>
mEventTarget
;
eventTarget
-
>
Dispatch
(
self
.
forget
(
)
)
;
}
NS_DECL_NSIRUNNABLE
}
;
}
void
ScriptLoader
:
:
CancelScriptLoadRequests
(
)
{
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
Cancel
(
)
;
}
for
(
ScriptLoadRequest
*
req
=
mXSLTRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
Cancel
(
)
;
}
for
(
ScriptLoadRequest
*
req
=
mDeferRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
Cancel
(
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadingAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
Cancel
(
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadedAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
Cancel
(
)
;
}
for
(
ScriptLoadRequest
*
req
=
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
Cancel
(
)
;
}
for
(
size_t
i
=
0
;
i
<
mPreloads
.
Length
(
)
;
i
+
+
)
{
mPreloads
[
i
]
.
mRequest
-
>
Cancel
(
)
;
}
mOffThreadCompilingRequests
.
CancelRequestsAndClear
(
)
;
}
nsresult
ScriptLoader
:
:
ProcessOffThreadRequest
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mProgress
=
=
ScriptLoadRequest
:
:
Progress
:
:
eCompiling
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mWasCompiledOMT
)
;
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
NS_OK
;
}
aRequest
-
>
GetLoadContext
(
)
-
>
mWasCompiledOMT
=
true
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mInCompilingList
)
{
mOffThreadCompilingRequests
.
Remove
(
aRequest
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mInCompilingList
=
false
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
;
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
return
mModuleLoader
-
>
ProcessFetchedModuleSource
(
request
)
;
}
MOZ_ASSERT_IF
(
!
SpeculativeOMTParsingEnabled
(
)
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
)
;
if
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
)
{
aRequest
-
>
GetLoadContext
(
)
-
>
MaybeUnblockOnload
(
)
;
return
NS_OK
;
}
aRequest
-
>
SetReady
(
)
;
if
(
aRequest
=
=
mParserBlockingRequest
)
{
if
(
!
ReadyToExecuteParserBlockingScripts
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
return
NS_OK
;
}
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
aRequest
)
;
ProcessRequest
(
aRequest
)
;
ContinueParserAsync
(
aRequest
)
;
return
NS_OK
;
}
if
(
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsAsyncScript
(
)
|
|
aRequest
-
>
GetLoadContext
(
)
-
>
IsBlockingScript
(
)
)
&
&
!
aRequest
-
>
isInList
(
)
)
{
return
ProcessRequest
(
aRequest
)
;
}
ProcessPendingRequests
(
)
;
return
NS_OK
;
}
NotifyOffThreadScriptLoadCompletedRunnable
:
:
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
{
if
(
MOZ_UNLIKELY
(
mRequest
|
|
mLoader
)
&
&
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThread
(
"
NotifyOffThreadScriptLoadCompletedRunnable
:
:
mRequest
"
mRequest
.
forget
(
)
)
;
NS_ReleaseOnMainThread
(
"
NotifyOffThreadScriptLoadCompletedRunnable
:
:
mLoader
"
mLoader
.
forget
(
)
)
;
}
}
NS_IMETHODIMP
NotifyOffThreadScriptLoadCompletedRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
std
:
:
move
(
mRequest
)
;
MOZ_ASSERT
(
!
request
-
>
GetLoadContext
(
)
-
>
mRunnable
)
;
if
(
profiler_is_active
(
)
)
{
ProfilerString8View
scriptSourceString
;
if
(
request
-
>
IsTextSource
(
)
)
{
scriptSourceString
=
"
ScriptCompileOffThread
"
;
}
else
{
MOZ_ASSERT
(
request
-
>
IsBytecode
(
)
)
;
scriptSourceString
=
"
BytecodeDecodeOffThread
"
;
}
nsAutoCString
profilerLabelString
;
request
-
>
GetLoadContext
(
)
-
>
GetProfilerLabel
(
profilerLabelString
)
;
PROFILER_MARKER_TEXT
(
scriptSourceString
JS
MarkerTiming
:
:
Interval
(
request
-
>
GetLoadContext
(
)
-
>
mOffThreadParseStartTime
request
-
>
GetLoadContext
(
)
-
>
mOffThreadParseStopTime
)
profilerLabelString
)
;
}
RefPtr
<
ScriptLoader
>
loader
=
std
:
:
move
(
mLoader
)
;
if
(
!
request
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
{
return
NS_OK
;
}
return
loader
-
>
ProcessOffThreadRequest
(
request
)
;
}
static
void
OffThreadScriptLoaderCallback
(
JS
:
:
OffThreadToken
*
aToken
void
*
aCallbackData
)
{
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
aRunnable
=
dont_AddRef
(
static_cast
<
NotifyOffThreadScriptLoadCompletedRunnable
*
>
(
aCallbackData
)
)
;
MOZ_ASSERT
(
aRunnable
.
get
(
)
=
=
aRunnable
-
>
GetScriptLoadRequest
(
)
-
>
GetLoadContext
(
)
-
>
mRunnable
)
;
aRunnable
-
>
GetScriptLoadRequest
(
)
-
>
GetLoadContext
(
)
-
>
mOffThreadParseStopTime
=
TimeStamp
:
:
Now
(
)
;
LogRunnable
:
:
Run
run
(
aRunnable
)
;
aRunnable
-
>
SetToken
(
aToken
)
;
if
(
!
aRunnable
-
>
GetScriptLoadRequest
(
)
-
>
GetLoadContext
(
)
-
>
mRunnable
.
exchange
(
nullptr
)
)
{
return
;
}
NotifyOffThreadScriptLoadCompletedRunnable
:
:
Dispatch
(
aRunnable
.
forget
(
)
)
;
}
nsresult
ScriptLoader
:
:
AttemptAsyncScriptCompile
(
ScriptLoadRequest
*
aRequest
bool
*
aCouldCompileOut
)
{
MOZ_ASSERT_IF
(
!
SpeculativeOMTParsingEnabled
(
)
&
&
!
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
IsReadyToRun
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mWasCompiledOMT
)
;
MOZ_ASSERT
(
aCouldCompileOut
&
&
!
*
aCouldCompileOut
)
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
GetGlobalForRequest
(
aRequest
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
globalObject
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
JS
:
:
RootedScript
dummyIntroductionScript
(
cx
)
;
nsresult
rv
=
FillCompileOptionsForRequest
(
cx
aRequest
global
&
options
&
dummyIntroductionScript
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aRequest
-
>
IsTextSource
(
)
)
{
if
(
!
JS
:
:
CanCompileOffThread
(
cx
options
aRequest
-
>
ScriptTextLength
(
)
)
)
{
return
NS_OK
;
}
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsBytecode
(
)
)
;
size_t
length
=
aRequest
-
>
mScriptBytecode
.
length
(
)
-
aRequest
-
>
mBytecodeOffset
;
JS
:
:
DecodeOptions
decodeOptions
(
options
)
;
if
(
!
JS
:
:
CanDecodeOffThread
(
cx
decodeOptions
length
)
)
{
return
NS_OK
;
}
}
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
runnable
=
new
NotifyOffThreadScriptLoadCompletedRunnable
(
aRequest
this
)
;
LogRunnable
:
:
LogDispatch
(
runnable
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadParseStartTime
=
TimeStamp
:
:
Now
(
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mRunnable
=
runnable
.
get
(
)
;
auto
signalOOM
=
mozilla
:
:
MakeScopeExit
(
[
&
aRequest
]
(
)
{
aRequest
-
>
GetLoadContext
(
)
-
>
mRunnable
=
nullptr
;
}
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
MaybeSourceText
maybeSource
;
nsresult
rv
=
aRequest
-
>
GetScriptSource
(
cx
&
maybeSource
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
=
maybeSource
.
constructed
<
SourceText
<
char16_t
>
>
(
)
?
JS
:
:
CompileModuleToStencilOffThread
(
cx
options
maybeSource
.
ref
<
SourceText
<
char16_t
>
>
(
)
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
:
JS
:
:
CompileModuleToStencilOffThread
(
cx
options
maybeSource
.
ref
<
SourceText
<
Utf8Unit
>
>
(
)
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
;
if
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
if
(
aRequest
-
>
IsBytecode
(
)
)
{
JS
:
:
DecodeOptions
decodeOptions
(
options
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
=
JS
:
:
DecodeStencilOffThread
(
cx
decodeOptions
aRequest
-
>
mScriptBytecode
aRequest
-
>
mBytecodeOffset
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
;
if
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
if
(
ShouldFullParse
(
aRequest
)
)
{
options
.
setForceFullParse
(
)
;
mTotalFullParseSize
+
=
aRequest
-
>
ScriptTextLength
(
)
>
0
?
static_cast
<
uint32_t
>
(
aRequest
-
>
ScriptTextLength
(
)
)
:
0
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Full
Parsing
Enabled
for
url
=
%
s
"
"
mTotalFullParseSize
=
%
u
"
aRequest
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
mTotalFullParseSize
)
)
;
}
MaybeSourceText
maybeSource
;
nsresult
rv
=
aRequest
-
>
GetScriptSource
(
cx
&
maybeSource
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
=
maybeSource
.
constructed
<
SourceText
<
char16_t
>
>
(
)
?
JS
:
:
CompileToStencilOffThread
(
cx
options
maybeSource
.
ref
<
SourceText
<
char16_t
>
>
(
)
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
:
JS
:
:
CompileToStencilOffThread
(
cx
options
maybeSource
.
ref
<
SourceText
<
Utf8Unit
>
>
(
)
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
;
if
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
signalOOM
.
release
(
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
BlockOnload
(
mDocument
)
;
aRequest
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
eCompiling
;
if
(
aRequest
-
>
IsTopLevel
(
)
&
&
!
aRequest
-
>
isInList
(
)
)
{
mOffThreadCompilingRequests
.
AppendElement
(
aRequest
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mInCompilingList
=
true
;
}
*
aCouldCompileOut
=
true
;
Unused
<
<
runnable
.
forget
(
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
CompileOffThreadOrProcessRequest
(
ScriptLoadRequest
*
aRequest
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
if
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
&
&
!
aRequest
-
>
GetLoadContext
(
)
-
>
CompileStarted
(
)
)
{
bool
couldCompile
=
false
;
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
&
couldCompile
)
;
if
(
NS_FAILED
(
rv
)
)
{
HandleLoadError
(
aRequest
rv
)
;
return
rv
;
}
if
(
couldCompile
)
{
return
NS_OK
;
}
}
return
ProcessRequest
(
aRequest
)
;
}
nsresult
ScriptLoader
:
:
ProcessRequest
(
ScriptLoadRequest
*
aRequest
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Process
request
"
aRequest
)
)
;
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
aRequest
-
>
IsReadyToRun
(
)
"
Processing
a
request
that
is
not
ready
to
run
.
"
)
;
NS_ENSURE_ARG
(
aRequest
)
;
auto
unblockOnload
=
MakeScopeExit
(
[
&
]
{
aRequest
-
>
GetLoadContext
(
)
-
>
MaybeUnblockOnload
(
)
;
}
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
request
-
>
mModuleScript
)
{
if
(
!
mModuleLoader
-
>
InstantiateModuleTree
(
request
)
)
{
request
-
>
mModuleScript
=
nullptr
;
}
}
if
(
!
request
-
>
mModuleScript
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Error
loading
request
firing
error
"
aRequest
)
)
;
FireScriptAvailable
(
NS_ERROR_FAILURE
aRequest
)
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsINode
>
scriptElem
=
do_QueryInterface
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
)
;
nsCOMPtr
<
Document
>
doc
;
if
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
|
|
aRequest
-
>
IsModuleRequest
(
)
)
{
doc
=
scriptElem
-
>
OwnerDoc
(
)
;
}
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
;
uint32_t
parserCreated
=
aRequest
-
>
GetLoadContext
(
)
-
>
GetParserCreated
(
)
;
if
(
parserCreated
)
{
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
;
}
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
-
>
BeginEvaluating
(
)
;
FireScriptAvailable
(
NS_OK
aRequest
)
;
{
nsAutoMicroTask
mt
;
}
nsPIDOMWindowInner
*
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
bool
runScript
=
!
!
pwin
;
if
(
runScript
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
u
"
beforescriptexecute
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eYes
&
runScript
)
;
}
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
runScript
=
false
;
}
nsresult
rv
=
NS_OK
;
if
(
runScript
)
{
if
(
doc
)
{
doc
-
>
IncrementIgnoreDestructiveWritesCounter
(
)
;
}
rv
=
EvaluateScriptElement
(
aRequest
)
;
if
(
doc
)
{
doc
-
>
DecrementIgnoreDestructiveWritesCounter
(
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
u
"
afterscriptexecute
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
FireScriptEvaluated
(
rv
aRequest
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
-
>
EndEvaluating
(
)
;
if
(
parserCreated
)
{
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
MaybeCancelOffThreadScript
(
)
;
}
aRequest
-
>
ClearScriptSource
(
)
;
if
(
aRequest
-
>
IsBytecode
(
)
)
{
aRequest
-
>
mScriptBytecode
.
clearAndFree
(
)
;
}
return
rv
;
}
void
ScriptLoader
:
:
FireScriptAvailable
(
nsresult
aResult
ScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptAvailable
(
aResult
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
aRequest
-
>
mURI
aRequest
-
>
mLineNo
)
;
}
aRequest
-
>
GetLoadContext
(
)
-
>
FireScriptAvailable
(
aResult
)
;
}
void
ScriptLoader
:
:
FireScriptEvaluated
(
nsresult
aResult
ScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
RefPtr
<
nsIScriptElement
>
scriptElement
=
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
;
obs
-
>
ScriptEvaluated
(
aResult
scriptElement
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
)
;
}
aRequest
-
>
GetLoadContext
(
)
-
>
FireScriptEvaluated
(
aResult
)
;
}
already_AddRefed
<
nsIGlobalObject
>
ScriptLoader
:
:
GetGlobalForRequest
(
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
GetWebExtGlobal
(
)
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
aRequest
-
>
GetWebExtGlobal
(
)
;
return
global
.
forget
(
)
;
}
return
GetScriptGlobalObject
(
WebExtGlobal
:
:
Handled
)
;
}
already_AddRefed
<
nsIScriptGlobalObject
>
ScriptLoader
:
:
GetScriptGlobalObject
(
WebExtGlobal
)
{
if
(
!
mDocument
)
{
return
nullptr
;
}
nsPIDOMWindowInner
*
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
do_QueryInterface
(
pwin
)
;
NS_ASSERTION
(
globalObject
"
windows
must
be
global
objects
"
)
;
nsresult
rv
=
globalObject
-
>
EnsureScriptEnvironment
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
globalObject
.
forget
(
)
;
}
nsresult
ScriptLoader
:
:
FillCompileOptionsForRequest
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
JS
:
:
Handle
<
JSObject
*
>
aScopeChain
JS
:
:
CompileOptions
*
aOptions
JS
:
:
MutableHandle
<
JSScript
*
>
aIntroductionScript
)
{
nsresult
rv
=
aRequest
-
>
mURI
-
>
GetSpec
(
aRequest
-
>
mURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mDocument
)
{
mDocument
-
>
NoteScriptTrackingStatus
(
aRequest
-
>
mURL
aRequest
-
>
GetLoadContext
(
)
-
>
IsTracking
(
)
)
;
}
const
char
*
introductionType
;
if
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
{
introductionType
=
"
importedModule
"
;
}
else
if
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
)
{
introductionType
=
"
srcScript
"
;
}
else
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
introductionType
=
"
inlineScript
"
;
}
else
{
introductionType
=
"
injectedScript
"
;
}
aOptions
-
>
setIntroductionInfoToCaller
(
aCx
introductionType
aIntroductionScript
)
;
aOptions
-
>
setFileAndLine
(
aRequest
-
>
mURL
.
get
(
)
aRequest
-
>
mLineNo
)
;
aOptions
-
>
setIsRunOnce
(
true
)
;
aOptions
-
>
setNoScriptRval
(
true
)
;
if
(
aRequest
-
>
mSourceMapURL
)
{
aOptions
-
>
setSourceMapURL
(
aRequest
-
>
mSourceMapURL
-
>
get
(
)
)
;
}
if
(
aRequest
-
>
mOriginPrincipal
)
{
nsIPrincipal
*
scriptPrin
=
nsContentUtils
:
:
ObjectPrincipal
(
aScopeChain
)
;
bool
subsumes
=
scriptPrin
-
>
Subsumes
(
aRequest
-
>
mOriginPrincipal
)
;
aOptions
-
>
setMutedErrors
(
!
subsumes
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
aOptions
-
>
setHideScriptFromDebugger
(
true
)
;
}
aOptions
-
>
setDeferDebugMetadata
(
true
)
;
aOptions
-
>
borrowBuffer
=
true
;
aOptions
-
>
allocateInstantiationStorage
=
true
;
return
NS_OK
;
}
bool
ScriptLoader
:
:
ShouldCacheBytecode
(
ScriptLoadRequest
*
aRequest
)
{
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
if
(
!
aRequest
-
>
mCacheInfo
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
cache
anything
(
cacheInfo
=
%
p
)
"
aRequest
aRequest
-
>
mCacheInfo
.
get
(
)
)
)
;
return
false
;
}
int32_t
strategy
=
StaticPrefs
:
:
dom_script_loader_bytecode_cache_strategy
(
)
;
bool
hasSourceLengthMin
=
false
;
bool
hasFetchCountMin
=
false
;
size_t
sourceLengthMin
=
100
;
int32_t
fetchCountMin
=
4
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
strategy
=
%
d
.
"
aRequest
strategy
)
)
;
switch
(
strategy
)
{
case
-
2
:
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Encoding
disabled
.
"
aRequest
)
)
;
return
false
;
}
case
-
1
:
{
hasSourceLengthMin
=
false
;
hasFetchCountMin
=
false
;
break
;
}
default
:
case
0
:
{
hasSourceLengthMin
=
true
;
hasFetchCountMin
=
true
;
sourceLengthMin
=
1024
;
fetchCountMin
=
4
;
break
;
}
}
if
(
hasSourceLengthMin
)
{
size_t
sourceLength
;
size_t
minLength
;
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
sourceLength
=
aRequest
-
>
mScriptTextLength
;
minLength
=
sourceLengthMin
;
if
(
sourceLength
<
minLength
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Script
is
too
small
.
"
aRequest
)
)
;
return
false
;
}
}
if
(
hasFetchCountMin
)
{
int32_t
fetchCount
=
0
;
if
(
NS_FAILED
(
aRequest
-
>
mCacheInfo
-
>
GetCacheTokenFetchCount
(
&
fetchCount
)
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Cannot
get
fetchCount
.
"
aRequest
)
)
;
return
false
;
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
fetchCount
=
%
d
.
"
aRequest
fetchCount
)
)
;
if
(
fetchCount
<
fetchCountMin
)
{
return
false
;
}
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Trigger
encoding
.
"
aRequest
)
)
;
return
true
;
}
class
MOZ_RAII
AutoSetProcessingScriptTag
{
nsCOMPtr
<
nsIScriptContext
>
mContext
;
bool
mOldTag
;
public
:
explicit
AutoSetProcessingScriptTag
(
nsIScriptContext
*
aContext
)
:
mContext
(
aContext
)
mOldTag
(
mContext
-
>
GetProcessingScriptTag
(
)
)
{
mContext
-
>
SetProcessingScriptTag
(
true
)
;
}
~
AutoSetProcessingScriptTag
(
)
{
mContext
-
>
SetProcessingScriptTag
(
mOldTag
)
;
}
}
;
static
nsresult
ExecuteCompiledScript
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
JSExecutionContext
&
aExec
ClassicScript
*
aLoaderScript
)
{
JS
:
:
Rooted
<
JSScript
*
>
script
(
aCx
aExec
.
GetScript
(
)
)
;
if
(
!
script
)
{
return
NS_OK
;
}
if
(
JS
:
:
GetScriptPrivate
(
script
)
.
isUndefined
(
)
)
{
aLoaderScript
-
>
AssociateWithScript
(
script
)
;
}
return
aExec
.
ExecScript
(
)
;
}
nsresult
ScriptLoader
:
:
EvaluateScriptElement
(
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
MOZ_ASSERT
(
aRequest
-
>
IsReadyToRun
(
)
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
scriptContent
(
do_QueryInterface
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
)
)
;
MOZ_ASSERT
(
scriptContent
)
;
Document
*
ownerDoc
=
scriptContent
-
>
OwnerDoc
(
)
;
if
(
ownerDoc
!
=
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIGlobalObject
>
globalObject
;
nsCOMPtr
<
nsIScriptContext
>
context
;
if
(
aRequest
-
>
GetWebExtGlobal
(
)
)
{
globalObject
=
aRequest
-
>
GetWebExtGlobal
(
)
;
}
else
{
nsCOMPtr
<
nsIScriptGlobalObject
>
scriptGlobal
=
GetScriptGlobalObject
(
WebExtGlobal
:
:
Handled
)
;
if
(
!
scriptGlobal
)
{
return
NS_ERROR_FAILURE
;
}
context
=
scriptGlobal
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
globalObject
=
scriptGlobal
;
}
nsIScriptElement
*
currentScript
=
aRequest
-
>
IsModuleRequest
(
)
?
nullptr
:
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
;
AutoCurrentScriptUpdater
scriptUpdater
(
this
currentScript
)
;
Maybe
<
AutoSetProcessingScriptTag
>
setProcessingScriptTag
;
if
(
context
)
{
setProcessingScriptTag
.
emplace
(
context
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
return
mModuleLoader
-
>
EvaluateModule
(
globalObject
aRequest
)
;
}
return
EvaluateScript
(
globalObject
aRequest
)
;
}
nsresult
ScriptLoader
:
:
CompileOrFinishModuleScript
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
JS
:
:
CompileOptions
&
aOptions
ModuleLoadRequest
*
aRequest
JS
:
:
MutableHandle
<
JSObject
*
>
aModule
)
{
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mWasCompiledOMT
)
{
JS
:
:
Rooted
<
JS
:
:
InstantiationStorage
>
storage
(
aCx
)
;
RefPtr
<
JS
:
:
Stencil
>
stencil
=
JS
:
:
FinishCompileModuleToStencilOffThread
(
aCx
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
storage
.
address
(
)
)
;
if
(
stencil
)
{
JS
:
:
InstantiateOptions
instantiateOptions
(
aOptions
)
;
aModule
.
set
(
JS
:
:
InstantiateModuleStencil
(
aCx
instantiateOptions
stencil
storage
.
address
(
)
)
)
;
}
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
=
nullptr
;
return
aModule
?
NS_OK
:
NS_ERROR_FAILURE
;
}
MaybeSourceText
maybeSource
;
nsresult
rv
=
aRequest
-
>
GetScriptSource
(
aCx
&
maybeSource
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
maybeSource
.
constructed
<
SourceText
<
char16_t
>
>
(
)
?
nsJSUtils
:
:
CompileModule
(
aCx
maybeSource
.
ref
<
SourceText
<
char16_t
>
>
(
)
aGlobal
aOptions
aModule
)
:
nsJSUtils
:
:
CompileModule
(
aCx
maybeSource
.
ref
<
SourceText
<
Utf8Unit
>
>
(
)
aGlobal
aOptions
aModule
)
;
}
return
rv
;
}
nsresult
ScriptLoader
:
:
CompileOrDecodeClassicScript
(
JSContext
*
aCx
JSExecutionContext
&
aExec
ScriptLoadRequest
*
aRequest
)
{
nsAutoCString
profilerLabelString
;
aRequest
-
>
GetLoadContext
(
)
-
>
GetProfilerLabel
(
profilerLabelString
)
;
nsresult
rv
;
if
(
aRequest
-
>
IsBytecode
(
)
)
{
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Decode
Bytecode
&
Join
and
Execute
"
aRequest
)
)
;
rv
=
aExec
.
JoinDecode
(
&
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Decode
Bytecode
and
Execute
"
aRequest
)
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
BytecodeDecodeMainThread
"
JS
MarkerInnerWindowIdFromJSContext
(
aCx
)
profilerLabelString
)
;
rv
=
aExec
.
Decode
(
aRequest
-
>
mScriptBytecode
aRequest
-
>
mBytecodeOffset
)
;
}
MOZ_ASSERT
(
!
aRequest
-
>
mCacheInfo
)
;
return
rv
;
}
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
bool
encodeBytecode
=
ShouldCacheBytecode
(
aRequest
)
;
aExec
.
SetEncodeBytecode
(
encodeBytecode
)
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Join
(
off
-
thread
parsing
)
and
"
"
Execute
"
aRequest
)
)
;
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
rv
=
aExec
.
JoinCompile
(
&
aRequest
-
>
GetLoadContext
(
)
-
>
mOffThreadToken
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Compile
And
Exec
"
aRequest
)
)
;
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
MaybeSourceText
maybeSource
;
rv
=
aRequest
-
>
GetScriptSource
(
aCx
&
maybeSource
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
AUTO_PROFILER_MARKER_TEXT
(
"
ScriptCompileMainThread
"
JS
MarkerInnerWindowIdFromJSContext
(
aCx
)
profilerLabelString
)
;
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
rv
=
maybeSource
.
constructed
<
SourceText
<
char16_t
>
>
(
)
?
aExec
.
Compile
(
maybeSource
.
ref
<
SourceText
<
char16_t
>
>
(
)
)
:
aExec
.
Compile
(
maybeSource
.
ref
<
SourceText
<
Utf8Unit
>
>
(
)
)
;
mMainThreadParseTime
+
=
TimeStamp
:
:
Now
(
)
-
startTime
;
}
}
return
rv
;
}
nsresult
ScriptLoader
:
:
MaybePrepareForBytecodeEncoding
(
JS
:
:
Handle
<
JSScript
*
>
aScript
ScriptLoadRequest
*
aRequest
nsresult
aRv
)
{
bool
encodeBytecode
=
ShouldCacheBytecode
(
aRequest
)
;
if
(
aScript
&
&
encodeBytecode
)
{
aRequest
-
>
SetScript
(
aScript
)
;
TRACE_FOR_TEST
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_encode
"
)
;
MOZ_ASSERT
(
aRequest
-
>
mBytecodeOffset
=
=
aRequest
-
>
mScriptBytecode
.
length
(
)
)
;
RegisterForBytecodeEncoding
(
aRequest
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
disabled
(
rv
=
%
X
"
"
script
=
%
p
)
"
aRequest
unsigned
(
aRv
)
aScript
.
get
(
)
)
)
;
TRACE_FOR_TEST_NONE
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_no_encode
"
)
;
aRequest
-
>
mCacheInfo
=
nullptr
;
}
return
aRv
;
}
nsresult
ScriptLoader
:
:
EvaluateScript
(
nsIGlobalObject
*
aGlobalObject
ScriptLoadRequest
*
aRequest
)
{
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
aGlobalObject
"
EvaluateScript
"
true
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
aGlobalObject
-
>
GetGlobalJSObject
(
)
)
;
nsAutoCString
profilerLabelString
;
aRequest
-
>
GetLoadContext
(
)
-
>
GetProfilerLabel
(
profilerLabelString
)
;
RefPtr
<
ClassicScript
>
classicScript
=
new
ClassicScript
(
aRequest
-
>
mFetchOptions
aRequest
-
>
mBaseURL
)
;
JS
:
:
RootedValue
classicScriptValue
(
cx
JS
:
:
PrivateValue
(
classicScript
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
JS
:
:
RootedScript
introductionScript
(
cx
)
;
nsresult
rv
=
FillCompileOptionsForRequest
(
cx
aRequest
global
&
options
&
introductionScript
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
TRACE_FOR_TEST
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_execute
"
)
;
JSExecutionContext
exec
(
cx
global
options
classicScriptValue
introductionScript
)
;
rv
=
CompileOrDecodeClassicScript
(
cx
exec
aRequest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
JS
:
:
Rooted
<
JSScript
*
>
script
(
cx
)
;
if
(
rv
=
=
NS_OK
)
{
script
=
exec
.
GetScript
(
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Evaluate
Script
"
aRequest
)
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
ScriptExecution
"
JS
MarkerInnerWindowIdFromJSContext
(
cx
)
profilerLabelString
)
;
rv
=
ExecuteCompiledScript
(
cx
aRequest
exec
classicScript
)
;
}
rv
=
MaybePrepareForBytecodeEncoding
(
script
aRequest
rv
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
ScriptLoader
=
%
p
"
aRequest
this
)
)
;
MaybeTriggerBytecodeEncoding
(
)
;
return
rv
;
}
LoadedScript
*
ScriptLoader
:
:
GetActiveScript
(
JSContext
*
aCx
)
{
JS
:
:
Value
value
=
JS
:
:
GetScriptedCallerPrivate
(
aCx
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
LoadedScript
*
>
(
value
.
toPrivate
(
)
)
;
}
void
ScriptLoader
:
:
RegisterForBytecodeEncoding
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mCacheInfo
)
;
MOZ_ASSERT
(
aRequest
-
>
mScript
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
mBytecodeEncodingQueue
.
AppendElement
(
aRequest
)
;
}
void
ScriptLoader
:
:
LoadEventFired
(
)
{
mLoadEventFired
=
true
;
MaybeTriggerBytecodeEncoding
(
)
;
if
(
!
mMainThreadParseTime
.
IsZero
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PAGELOAD_PARSE_MS
static_cast
<
uint32_t
>
(
mMainThreadParseTime
.
ToMilliseconds
(
)
)
)
;
}
}
void
ScriptLoader
:
:
Destroy
(
)
{
if
(
mShutdownObserver
)
{
mShutdownObserver
-
>
Unregister
(
)
;
mShutdownObserver
=
nullptr
;
}
CancelScriptLoadRequests
(
)
;
GiveUpBytecodeEncoding
(
)
;
}
void
ScriptLoader
:
:
MaybeTriggerBytecodeEncoding
(
)
{
if
(
mGiveUpEncoding
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Keep
giving
-
up
bytecode
encoding
.
"
this
)
)
;
GiveUpBytecodeEncoding
(
)
;
return
;
}
if
(
!
mLoadEventFired
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Wait
for
the
load
-
end
event
to
fire
.
"
this
)
)
;
return
;
}
if
(
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
No
script
in
queue
to
be
encoded
.
"
this
)
)
;
return
;
}
if
(
HasPendingRequests
(
)
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Wait
for
other
pending
request
to
finish
.
"
this
)
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
encoder
=
NewRunnableMethod
(
"
ScriptLoader
:
:
EncodeBytecode
"
this
&
ScriptLoader
:
:
EncodeBytecode
)
;
if
(
NS_FAILED
(
NS_DispatchToCurrentThreadQueue
(
encoder
.
forget
(
)
EventQueuePriority
:
:
Idle
)
)
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Schedule
bytecode
encoding
.
"
this
)
)
;
}
void
ScriptLoader
:
:
EncodeBytecode
(
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Start
bytecode
encoding
.
"
this
)
)
;
if
(
HasPendingRequests
(
)
)
{
return
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
WebExtGlobal
:
:
Ignore
)
;
if
(
!
globalObject
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
AutoEntryScript
aes
(
globalObject
"
encode
bytecode
"
true
)
;
RefPtr
<
ScriptLoadRequest
>
request
;
while
(
!
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
request
=
mBytecodeEncodingQueue
.
StealFirst
(
)
;
MOZ_ASSERT
(
!
request
-
>
IsModuleRequest
(
)
)
;
MOZ_ASSERT
(
!
request
-
>
GetWebExtGlobal
(
)
"
Not
handling
global
above
"
)
;
EncodeRequestBytecode
(
aes
.
cx
(
)
request
)
;
request
-
>
mScriptBytecode
.
clearAndFree
(
)
;
request
-
>
DropBytecodeCacheReferences
(
)
;
}
}
void
ScriptLoader
:
:
EncodeRequestBytecode
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
nsresult
rv
=
NS_OK
;
MOZ_ASSERT
(
aRequest
-
>
mCacheInfo
)
;
auto
bytecodeFailed
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
TRACE_FOR_TEST_NONE
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_bytecode_failed
"
)
;
}
)
;
JS
:
:
RootedScript
script
(
aCx
aRequest
-
>
mScript
)
;
if
(
!
JS
:
:
FinishIncrementalEncoding
(
aCx
script
aRequest
-
>
mScriptBytecode
)
)
{
JS_ClearPendingException
(
aCx
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
serialize
bytecode
"
aRequest
)
)
;
return
;
}
if
(
aRequest
-
>
mScriptBytecode
.
length
(
)
>
=
UINT32_MAX
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
cache
is
too
large
to
be
decoded
"
"
correctly
.
"
aRequest
)
)
;
return
;
}
nsCOMPtr
<
nsIAsyncOutputStream
>
output
;
rv
=
aRequest
-
>
mCacheInfo
-
>
OpenAlternativeOutputStream
(
nsContentUtils
:
:
JSBytecodeMimeType
(
)
aRequest
-
>
mScriptBytecode
.
length
(
)
getter_AddRefs
(
output
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
open
bytecode
cache
(
rv
=
%
X
output
"
"
=
%
p
)
"
aRequest
unsigned
(
rv
)
output
.
get
(
)
)
)
;
return
;
}
MOZ_ASSERT
(
output
)
;
auto
closeOutStream
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
rv
=
output
-
>
CloseWithStatus
(
rv
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Closing
(
rv
=
%
X
)
"
aRequest
unsigned
(
rv
)
)
)
;
}
)
;
uint32_t
n
;
rv
=
output
-
>
Write
(
reinterpret_cast
<
char
*
>
(
aRequest
-
>
mScriptBytecode
.
begin
(
)
)
aRequest
-
>
mScriptBytecode
.
length
(
)
&
n
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Write
bytecode
cache
(
rv
=
%
X
length
=
%
u
"
"
written
=
%
u
)
"
aRequest
unsigned
(
rv
)
unsigned
(
aRequest
-
>
mScriptBytecode
.
length
(
)
)
n
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
aRequest
-
>
mScriptBytecode
.
length
(
)
=
=
n
)
;
bytecodeFailed
.
release
(
)
;
TRACE_FOR_TEST_NONE
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_bytecode_saved
"
)
;
}
void
ScriptLoader
:
:
GiveUpBytecodeEncoding
(
)
{
mGiveUpEncoding
=
true
;
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
WebExtGlobal
:
:
Ignore
)
;
AutoAllowLegacyScriptExecution
exemption
;
Maybe
<
AutoEntryScript
>
aes
;
if
(
globalObject
)
{
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
context
)
{
aes
.
emplace
(
globalObject
"
give
-
up
bytecode
encoding
"
true
)
;
}
}
while
(
!
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
request
=
mBytecodeEncodingQueue
.
StealFirst
(
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
serialize
bytecode
"
request
.
get
(
)
)
)
;
TRACE_FOR_TEST_NONE
(
request
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
"
scriptloader_bytecode_failed
"
)
;
MOZ_ASSERT
(
!
request
-
>
IsModuleRequest
(
)
)
;
MOZ_ASSERT
(
!
request
-
>
GetWebExtGlobal
(
)
)
;
if
(
aes
.
isSome
(
)
)
{
JS
:
:
RootedScript
script
(
aes
-
>
cx
(
)
request
-
>
mScript
)
;
if
(
!
JS
:
:
FinishIncrementalEncoding
(
aes
-
>
cx
(
)
script
request
-
>
mScriptBytecode
)
)
{
JS_ClearPendingException
(
aes
-
>
cx
(
)
)
;
}
}
request
-
>
mScriptBytecode
.
clearAndFree
(
)
;
request
-
>
DropBytecodeCacheReferences
(
)
;
}
}
bool
ScriptLoader
:
:
HasPendingRequests
(
)
{
return
mParserBlockingRequest
|
|
!
mXSLTRequests
.
isEmpty
(
)
|
|
!
mLoadedAsyncRequests
.
isEmpty
(
)
|
|
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
|
|
!
mDeferRequests
.
isEmpty
(
)
|
|
!
mModuleLoader
-
>
mDynamicImportRequests
.
isEmpty
(
)
|
|
!
mPendingChildLoaders
.
IsEmpty
(
)
;
}
void
ScriptLoader
:
:
ProcessPendingRequestsAsync
(
)
{
if
(
HasPendingRequests
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NewRunnableMethod
(
"
dom
:
:
ScriptLoader
:
:
ProcessPendingRequests
"
this
&
ScriptLoader
:
:
ProcessPendingRequests
)
;
if
(
mDocument
)
{
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
task
.
forget
(
)
)
;
}
}
}
void
ScriptLoader
:
:
ProcessPendingRequests
(
)
{
RefPtr
<
ScriptLoadRequest
>
request
;
if
(
mParserBlockingRequest
&
&
mParserBlockingRequest
-
>
IsReadyToRun
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
request
.
swap
(
mParserBlockingRequest
)
;
UnblockParser
(
request
)
;
ProcessRequest
(
request
)
;
ContinueParserAsync
(
request
)
;
}
while
(
ReadyToExecuteParserBlockingScripts
(
)
&
&
!
mXSLTRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mXSLTRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mLoadedAsyncRequests
.
isEmpty
(
)
)
{
request
=
mLoadedAsyncRequests
.
StealFirst
(
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
ProcessRequest
(
request
)
;
}
else
{
CompileOffThreadOrProcessRequest
(
request
)
;
}
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mNonAsyncExternalScriptInsertedRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
if
(
mDeferCheckpointReached
&
&
mXSLTRequests
.
isEmpty
(
)
)
{
while
(
ReadyToExecuteScripts
(
)
&
&
!
mDeferRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mDeferRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
}
while
(
!
mPendingChildLoaders
.
IsEmpty
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
RefPtr
<
ScriptLoader
>
child
=
mPendingChildLoaders
[
0
]
;
mPendingChildLoaders
.
RemoveElementAt
(
0
)
;
child
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
if
(
mDeferCheckpointReached
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
&
&
MaybeRemovedDeferRequests
(
)
)
{
return
ProcessPendingRequests
(
)
;
}
if
(
mDeferCheckpointReached
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mLoadingAsyncRequests
.
isEmpty
(
)
&
&
mLoadedAsyncRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
)
{
mDeferCheckpointReached
=
false
;
mDocument
-
>
UnblockOnload
(
true
)
;
}
}
bool
ScriptLoader
:
:
ReadyToExecuteParserBlockingScripts
(
)
{
if
(
!
SelfReadyToExecuteParserBlockingScripts
(
)
)
{
return
false
;
}
if
(
mDocument
&
&
mDocument
-
>
GetWindowContext
(
)
)
{
for
(
WindowContext
*
wc
=
mDocument
-
>
GetWindowContext
(
)
-
>
GetParentWindowContext
(
)
;
wc
;
wc
=
wc
-
>
GetParentWindowContext
(
)
)
{
if
(
Document
*
doc
=
wc
-
>
GetDocument
(
)
)
{
ScriptLoader
*
ancestor
=
doc
-
>
ScriptLoader
(
)
;
if
(
!
ancestor
-
>
SelfReadyToExecuteParserBlockingScripts
(
)
&
&
ancestor
-
>
AddPendingChildLoader
(
this
)
)
{
AddParserBlockingScriptExecutionBlocker
(
)
;
return
false
;
}
}
}
}
return
true
;
}
template
<
typename
Unit
>
static
nsresult
ConvertToUnicode
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
Document
*
aDocument
Unit
*
&
aBufOut
size_t
&
aLengthOut
)
{
if
(
!
aLength
)
{
aBufOut
=
nullptr
;
aLengthOut
=
0
;
return
NS_OK
;
}
auto
data
=
Span
(
aData
aLength
)
;
UniquePtr
<
Decoder
>
unicodeDecoder
;
const
Encoding
*
encoding
;
std
:
:
tie
(
encoding
std
:
:
ignore
)
=
Encoding
:
:
ForBOM
(
data
)
;
if
(
encoding
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithBOMRemoval
(
)
;
}
if
(
!
unicodeDecoder
&
&
aChannel
)
{
nsAutoCString
label
;
if
(
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
label
)
)
&
&
(
encoding
=
Encoding
:
:
ForLabel
(
label
)
)
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
}
if
(
!
unicodeDecoder
&
&
(
encoding
=
Encoding
:
:
ForLabel
(
aHintCharset
)
)
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
if
(
!
unicodeDecoder
&
&
aDocument
)
{
unicodeDecoder
=
aDocument
-
>
GetDocumentCharacterSet
(
)
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
if
(
!
unicodeDecoder
)
{
unicodeDecoder
=
WINDOWS_1252_ENCODING
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
auto
signalOOM
=
mozilla
:
:
MakeScopeExit
(
[
&
aBufOut
&
aLengthOut
]
(
)
{
aBufOut
=
nullptr
;
aLengthOut
=
0
;
}
)
;
CheckedInt
<
size_t
>
bufferLength
=
ScriptDecoding
<
Unit
>
:
:
MaxBufferLength
(
unicodeDecoder
aLength
)
;
if
(
!
bufferLength
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
CheckedInt
<
size_t
>
bufferByteSize
=
bufferLength
*
sizeof
(
Unit
)
;
if
(
!
bufferByteSize
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aBufOut
=
static_cast
<
Unit
*
>
(
js_malloc
(
bufferByteSize
.
value
(
)
)
)
;
if
(
!
aBufOut
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
signalOOM
.
release
(
)
;
aLengthOut
=
ScriptDecoding
<
Unit
>
:
:
DecodeInto
(
unicodeDecoder
data
Span
(
aBufOut
bufferLength
.
value
(
)
)
true
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
ConvertToUTF16
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
Document
*
aDocument
char16_t
*
&
aBufOut
size_t
&
aLengthOut
)
{
return
ConvertToUnicode
(
aChannel
aData
aLength
aHintCharset
aDocument
aBufOut
aLengthOut
)
;
}
nsresult
ScriptLoader
:
:
ConvertToUTF8
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
Document
*
aDocument
Utf8Unit
*
&
aBufOut
size_t
&
aLengthOut
)
{
return
ConvertToUnicode
(
aChannel
aData
aLength
aHintCharset
aDocument
aBufOut
aLengthOut
)
;
}
nsresult
ScriptLoader
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
ScriptLoadRequest
*
aRequest
nsresult
aChannelStatus
nsresult
aSRIStatus
SRICheckDataVerifier
*
aSRIDataVerifier
)
{
NS_ASSERTION
(
aRequest
"
null
request
in
stream
complete
handler
"
)
;
NS_ENSURE_TRUE
(
aRequest
NS_ERROR_FAILURE
)
;
nsresult
rv
=
VerifySRI
(
aRequest
aLoader
aSRIStatus
aSRIDataVerifier
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
aRequest
-
>
IsSource
(
)
)
{
uint32_t
sriLength
=
0
;
rv
=
SaveSRIHash
(
aRequest
aSRIDataVerifier
&
sriLength
)
;
MOZ_ASSERT_IF
(
NS_SUCCEEDED
(
rv
)
aRequest
-
>
mScriptBytecode
.
length
(
)
=
=
sriLength
)
;
aRequest
-
>
mBytecodeOffset
=
JS
:
:
AlignTranscodingBytecodeOffset
(
sriLength
)
;
if
(
aRequest
-
>
mBytecodeOffset
!
=
sriLength
)
{
if
(
!
aRequest
-
>
mScriptBytecode
.
resize
(
aRequest
-
>
mBytecodeOffset
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
PrepareLoadedRequest
(
aRequest
aLoader
aChannelStatus
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
ReportErrorToConsole
(
aRequest
rv
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
aChannelStatus
!
=
NS_BINDING_RETARGETED
)
{
HandleLoadError
(
aRequest
rv
)
;
}
}
ProcessPendingRequests
(
)
;
return
rv
;
}
nsresult
ScriptLoader
:
:
VerifySRI
(
ScriptLoadRequest
*
aRequest
nsIIncrementalStreamLoader
*
aLoader
nsresult
aSRIStatus
SRICheckDataVerifier
*
aSRIDataVerifier
)
const
{
nsCOMPtr
<
nsIRequest
>
channelRequest
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channelRequest
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
channel
=
do_QueryInterface
(
channelRequest
)
;
nsresult
rv
=
NS_OK
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
&
&
NS_SUCCEEDED
(
(
rv
=
aSRIStatus
)
)
)
{
MOZ_ASSERT
(
aSRIDataVerifier
)
;
MOZ_ASSERT
(
mReporter
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
rv
=
aSRIDataVerifier
-
>
Verify
(
aRequest
-
>
mIntegrity
channel
sourceUri
mReporter
)
;
if
(
channelRequest
)
{
mReporter
-
>
FlushReportsToConsole
(
nsContentUtils
:
:
GetInnerWindowID
(
channelRequest
)
)
;
}
else
{
mReporter
-
>
FlushConsoleReports
(
mDocument
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_ERROR_SRI_CORRUPT
;
}
}
return
rv
;
}
nsresult
ScriptLoader
:
:
SaveSRIHash
(
ScriptLoadRequest
*
aRequest
SRICheckDataVerifier
*
aSRIDataVerifier
uint32_t
*
sriLength
)
const
{
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
MOZ_ASSERT
(
aRequest
-
>
mScriptBytecode
.
empty
(
)
)
;
uint32_t
len
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
&
&
aSRIDataVerifier
-
>
IsComplete
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
mScriptBytecode
.
length
(
)
=
=
0
)
;
len
=
aSRIDataVerifier
-
>
DataSummaryLength
(
)
;
if
(
!
aRequest
-
>
mScriptBytecode
.
resize
(
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
DebugOnly
<
nsresult
>
res
=
aSRIDataVerifier
-
>
ExportDataSummary
(
len
aRequest
-
>
mScriptBytecode
.
begin
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
res
)
)
;
}
else
{
MOZ_ASSERT
(
aRequest
-
>
mScriptBytecode
.
length
(
)
=
=
0
)
;
len
=
SRICheckDataVerifier
:
:
EmptyDataSummaryLength
(
)
;
if
(
!
aRequest
-
>
mScriptBytecode
.
resize
(
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
DebugOnly
<
nsresult
>
res
=
SRICheckDataVerifier
:
:
ExportEmptyDataSummary
(
len
aRequest
-
>
mScriptBytecode
.
begin
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
res
)
)
;
}
mozilla
:
:
DebugOnly
<
uint32_t
>
srilen
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
SRICheckDataVerifier
:
:
DataSummaryLength
(
len
aRequest
-
>
mScriptBytecode
.
begin
(
)
&
srilen
)
)
)
;
MOZ_ASSERT
(
srilen
=
=
len
)
;
*
sriLength
=
len
;
return
NS_OK
;
}
void
ScriptLoader
:
:
ReportErrorToConsole
(
ScriptLoadRequest
*
aRequest
nsresult
aResult
)
const
{
MOZ_ASSERT
(
aRequest
)
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsPreload
(
)
)
{
aRequest
-
>
GetLoadContext
(
)
-
>
mUnreportedPreloadError
=
aResult
;
return
;
}
bool
isScript
=
!
aRequest
-
>
IsModuleRequest
(
)
;
const
char
*
message
;
if
(
aResult
=
=
NS_ERROR_MALFORMED_URI
)
{
message
=
isScript
?
"
ScriptSourceMalformed
"
:
"
ModuleSourceMalformed
"
;
}
else
if
(
aResult
=
=
NS_ERROR_DOM_BAD_URI
)
{
message
=
isScript
?
"
ScriptSourceNotAllowed
"
:
"
ModuleSourceNotAllowed
"
;
}
else
if
(
aResult
=
=
NS_ERROR_DOM_WEBEXT_CONTENT_SCRIPT_URI
)
{
MOZ_ASSERT
(
!
isScript
)
;
message
=
"
WebExtContentScriptModuleSourceNotAllowed
"
;
}
else
if
(
net
:
:
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aResult
)
)
{
return
;
}
else
{
message
=
isScript
?
"
ScriptSourceLoadFailed
"
:
"
ModuleSourceLoadFailed
"
;
}
AutoTArray
<
nsString
1
>
params
;
CopyUTF8toUTF16
(
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
*
params
.
AppendElement
(
)
)
;
nsIScriptElement
*
element
=
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
;
uint32_t
lineNo
=
element
?
element
-
>
GetScriptLineNumber
(
)
:
0
;
uint32_t
columnNo
=
element
?
element
-
>
GetScriptColumnNumber
(
)
:
0
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Script
Loader
"
_ns
mDocument
nsContentUtils
:
:
eDOM_PROPERTIES
message
params
nullptr
u
"
"
_ns
lineNo
columnNo
)
;
}
void
ScriptLoader
:
:
ReportPreloadErrorsToConsole
(
ScriptLoadRequest
*
aRequest
)
{
if
(
NS_FAILED
(
aRequest
-
>
GetLoadContext
(
)
-
>
mUnreportedPreloadError
)
)
{
ReportErrorToConsole
(
aRequest
aRequest
-
>
GetLoadContext
(
)
-
>
mUnreportedPreloadError
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mUnreportedPreloadError
=
NS_OK
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
for
(
const
auto
&
childRequest
:
aRequest
-
>
AsModuleRequest
(
)
-
>
mImports
)
{
ReportPreloadErrorsToConsole
(
childRequest
)
;
}
}
}
void
ScriptLoader
:
:
HandleLoadError
(
ScriptLoadRequest
*
aRequest
nsresult
aResult
)
{
if
(
net
:
:
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aResult
)
)
{
nsCOMPtr
<
nsIContent
>
cont
=
do_QueryInterface
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
)
;
mDocument
-
>
AddBlockedNodeByClassifier
(
cont
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
GetLoadContext
(
)
-
>
mIsInline
)
{
auto
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
mModuleLoader
-
>
SetModuleFetchFinishedAndResumeWaitingRequests
(
request
aResult
)
;
}
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mInDeferList
)
{
MOZ_ASSERT_IF
(
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mDeferRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mInAsyncList
)
{
MOZ_ASSERT_IF
(
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mIsNonAsyncScriptInserted
)
{
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mNonAsyncExternalScriptInsertedRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mIsXSLT
)
{
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mXSLTRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsPreload
(
)
)
{
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
aRequest
-
>
Cancel
(
)
;
}
if
(
aRequest
-
>
IsTopLevel
(
)
)
{
MOZ_ALWAYS_TRUE
(
mPreloads
.
RemoveElement
(
aRequest
PreloadRequestComparator
(
)
)
)
;
}
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_PRELOAD_RESULT
:
:
LoadError
)
;
}
else
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
modReq
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
modReq
-
>
IsDynamicImport
(
)
)
{
MOZ_ASSERT
(
modReq
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mModuleLoader
-
>
mDynamicImportRequests
.
Steal
(
aRequest
)
;
modReq
-
>
Cancel
(
)
;
mModuleLoader
-
>
FinishDynamicImportAndReject
(
modReq
aResult
)
;
}
}
else
{
MOZ_ASSERT
(
!
modReq
-
>
IsTopLevel
(
)
)
;
MOZ_ASSERT
(
!
modReq
-
>
isInList
(
)
)
;
modReq
-
>
Cancel
(
)
;
}
}
else
if
(
mParserBlockingRequest
=
=
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
aRequest
)
;
MOZ_ASSERT
(
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
-
>
GetParserCreated
(
)
)
;
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
;
FireScriptAvailable
(
aResult
aRequest
)
;
ContinueParserAsync
(
aRequest
)
;
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsCanceled
(
)
|
|
aRequest
-
>
GetLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
}
}
void
ScriptLoader
:
:
UnblockParser
(
ScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
-
>
UnblockParser
(
)
;
}
void
ScriptLoader
:
:
ContinueParserAsync
(
ScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
GetLoadContext
(
)
-
>
GetScriptElement
(
)
-
>
ContinueParserAsync
(
)
;
}
uint32_t
ScriptLoader
:
:
NumberOfProcessors
(
)
{
if
(
mNumberOfProcessors
>
0
)
{
return
mNumberOfProcessors
;
}
int32_t
numProcs
=
PR_GetNumberOfProcessors
(
)
;
if
(
numProcs
>
0
)
{
mNumberOfProcessors
=
numProcs
;
}
return
mNumberOfProcessors
;
}
int32_t
ScriptLoader
:
:
PhysicalSizeOfMemoryInGB
(
)
{
if
(
mPhysicalSizeOfMemory
>
=
0
)
{
return
mPhysicalSizeOfMemory
;
}
mPhysicalSizeOfMemory
=
static_cast
<
int32_t
>
(
PR_GetPhysicalMemorySize
(
)
>
>
30
)
;
return
mPhysicalSizeOfMemory
;
}
static
bool
IsInternalURIScheme
(
nsIURI
*
uri
)
{
return
uri
-
>
SchemeIs
(
"
moz
-
extension
"
)
|
|
uri
-
>
SchemeIs
(
"
resource
"
)
|
|
uri
-
>
SchemeIs
(
"
chrome
"
)
;
}
bool
ScriptLoader
:
:
ShouldFullParse
(
ScriptLoadRequest
*
aRequest
)
{
if
(
StaticPrefs
:
:
dom_script_loader_full_parse_max_size
(
)
<
0
)
{
return
true
;
}
if
(
PhysicalSizeOfMemoryInGB
(
)
<
=
StaticPrefs
:
:
dom_script_loader_full_parse_min_mem
(
)
)
{
return
false
;
}
uint32_t
max_size
=
static_cast
<
uint32_t
>
(
StaticPrefs
:
:
dom_script_loader_full_parse_max_size
(
)
)
;
uint32_t
script_size
=
aRequest
-
>
ScriptTextLength
(
)
>
0
?
static_cast
<
uint32_t
>
(
aRequest
-
>
ScriptTextLength
(
)
)
:
0
;
if
(
mTotalFullParseSize
+
script_size
<
max_size
)
{
return
true
;
}
if
(
LOG_ENABLED
(
)
)
{
nsCString
url
=
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Full
Parsing
Disabled
for
(
%
s
)
with
size
=
%
u
"
"
because
mTotalFullParseSize
=
%
u
would
exceed
max_size
=
%
u
"
aRequest
url
.
get
(
)
script_size
mTotalFullParseSize
max_size
)
)
;
}
return
false
;
}
bool
ScriptLoader
:
:
ShouldCompileOffThread
(
ScriptLoadRequest
*
aRequest
)
{
if
(
NumberOfProcessors
(
)
<
=
1
)
{
return
false
;
}
if
(
aRequest
=
=
mParserBlockingRequest
)
{
return
true
;
}
if
(
SpeculativeOMTParsingEnabled
(
)
)
{
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mIsNonAsyncScriptInserted
&
&
!
StaticPrefs
:
:
dom_script_loader_external_scripts_speculate_non_parser_inserted_enabled
(
)
)
{
return
false
;
}
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsAsyncScript
(
)
&
&
!
StaticPrefs
:
:
dom_script_loader_external_scripts_speculate_async_enabled
(
)
)
{
return
false
;
}
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
&
&
!
StaticPrefs
:
:
dom_script_loader_external_scripts_speculate_link_preload_enabled
(
)
)
{
return
false
;
}
return
true
;
}
return
false
;
}
nsresult
ScriptLoader
:
:
PrepareLoadedRequest
(
ScriptLoadRequest
*
aRequest
nsIIncrementalStreamLoader
*
aLoader
nsresult
aStatus
)
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
aStatus
;
}
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
NS_BINDING_ABORTED
;
}
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
CollectScriptTelemetry
(
aRequest
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
req
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
rv
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
requestSucceeded
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
sourceMapURL
;
if
(
nsContentUtils
:
:
GetSourceMapURL
(
httpChannel
sourceMapURL
)
)
{
aRequest
-
>
mSourceMapURL
=
Some
(
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
)
;
}
nsCOMPtr
<
nsIClassifiedChannel
>
classifiedChannel
=
do_QueryInterface
(
req
)
;
MOZ_ASSERT
(
classifiedChannel
)
;
if
(
classifiedChannel
&
&
classifiedChannel
-
>
IsThirdPartyTrackingResource
(
)
)
{
aRequest
-
>
GetLoadContext
(
)
-
>
SetIsTracking
(
)
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
!
aRequest
-
>
IsModuleRequest
(
)
&
&
aRequest
-
>
CORSMode
(
)
=
=
CORS_NONE
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
aRequest
-
>
mOriginPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ASSERTION
(
mDeferRequests
.
Contains
(
aRequest
)
|
|
mLoadingAsyncRequests
.
Contains
(
aRequest
)
|
|
mNonAsyncExternalScriptInsertedRequests
.
Contains
(
aRequest
)
|
|
mXSLTRequests
.
Contains
(
aRequest
)
|
|
mModuleLoader
-
>
mDynamicImportRequests
.
Contains
(
aRequest
)
|
|
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
&
&
!
aRequest
-
>
isInList
(
)
)
|
|
mPreloads
.
Contains
(
aRequest
PreloadRequestComparator
(
)
)
|
|
mParserBlockingRequest
=
=
aRequest
"
aRequest
should
be
pending
!
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
channel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
uri
&
&
IsInternalURIScheme
(
uri
)
)
{
aRequest
-
>
mBaseURL
=
uri
;
}
else
{
channel
-
>
GetURI
(
getter_AddRefs
(
aRequest
-
>
mBaseURL
)
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
nsAutoCString
mimeType
;
channel
-
>
GetContentType
(
mimeType
)
;
NS_ConvertUTF8toUTF16
typeString
(
mimeType
)
;
if
(
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
typeString
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
couldCompile
=
false
;
rv
=
AttemptAsyncScriptCompile
(
request
&
couldCompile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
couldCompile
)
{
return
NS_OK
;
}
return
mModuleLoader
-
>
ProcessFetchedModuleSource
(
request
)
;
}
aRequest
-
>
SetReady
(
)
;
if
(
ShouldCompileOffThread
(
aRequest
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
bool
couldCompile
=
false
;
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
&
couldCompile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
couldCompile
)
{
MOZ_ASSERT
(
aRequest
-
>
mProgress
=
=
ScriptLoadRequest
:
:
Progress
:
:
eCompiling
"
Request
should
be
off
-
thread
compiling
now
.
"
)
;
return
NS_OK
;
}
}
MaybeMoveToLoadedList
(
aRequest
)
;
return
NS_OK
;
}
void
ScriptLoader
:
:
DeferCheckpointReached
(
)
{
if
(
mDeferEnabled
)
{
mDeferCheckpointReached
=
true
;
}
mDeferEnabled
=
false
;
ProcessPendingRequests
(
)
;
}
void
ScriptLoader
:
:
ParsingComplete
(
bool
aTerminated
)
{
if
(
!
aTerminated
)
{
return
;
}
mDeferRequests
.
CancelRequestsAndClear
(
)
;
mLoadingAsyncRequests
.
CancelRequestsAndClear
(
)
;
mLoadedAsyncRequests
.
CancelRequestsAndClear
(
)
;
mNonAsyncExternalScriptInsertedRequests
.
CancelRequestsAndClear
(
)
;
mXSLTRequests
.
CancelRequestsAndClear
(
)
;
mModuleLoader
-
>
CancelAndClearDynamicImports
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
Cancel
(
)
;
mParserBlockingRequest
=
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
mPreloads
.
Length
(
)
;
i
+
+
)
{
mPreloads
[
i
]
.
mRequest
-
>
GetLoadContext
(
)
-
>
MaybeCancelOffThreadScript
(
)
;
}
DeferCheckpointReached
(
)
;
}
void
ScriptLoader
:
:
PreloadURI
(
nsIURI
*
aURI
const
nsAString
&
aCharset
const
nsAString
&
aType
const
nsAString
&
aCrossOrigin
const
nsAString
&
aIntegrity
bool
aScriptFromHead
bool
aAsync
bool
aDefer
bool
aNoModule
bool
aLinkPreload
const
ReferrerPolicy
aReferrerPolicy
)
{
NS_ENSURE_TRUE_VOID
(
mDocument
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
;
}
ScriptKind
scriptKind
=
ScriptKind
:
:
eClassic
;
if
(
mDocument
-
>
ModuleScriptsEnabled
(
)
)
{
if
(
aNoModule
)
{
return
;
}
static
const
char
kASCIIWhitespace
[
]
=
"
\
t
\
n
\
f
\
r
"
;
nsAutoString
type
(
aType
)
;
type
.
Trim
(
kASCIIWhitespace
)
;
if
(
type
.
LowerCaseEqualsASCII
(
"
module
"
)
)
{
scriptKind
=
ScriptKind
:
:
eModule
;
}
}
if
(
scriptKind
=
=
ScriptKind
:
:
eClassic
&
&
!
aType
.
IsEmpty
(
)
&
&
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
aType
)
)
{
return
;
}
SRIMetadata
sriMetadata
;
GetSRIMetadata
(
aIntegrity
&
sriMetadata
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
CreateLoadRequest
(
scriptKind
aURI
nullptr
mDocument
-
>
NodePrincipal
(
)
Element
:
:
StringToCORSMode
(
aCrossOrigin
)
sriMetadata
aReferrerPolicy
)
;
request
-
>
GetLoadContext
(
)
-
>
mIsInline
=
false
;
request
-
>
GetLoadContext
(
)
-
>
mScriptFromHead
=
aScriptFromHead
;
request
-
>
GetLoadContext
(
)
-
>
SetScriptMode
(
aDefer
aAsync
aLinkPreload
)
;
request
-
>
GetLoadContext
(
)
-
>
SetIsPreloadRequest
(
)
;
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
url
;
aURI
-
>
GetAsciiSpec
(
url
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Created
preload
request
for
%
s
"
request
.
get
(
)
url
.
get
(
)
)
)
;
}
nsresult
rv
=
StartLoad
(
request
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
PreloadInfo
*
pi
=
mPreloads
.
AppendElement
(
)
;
pi
-
>
mRequest
=
request
;
pi
-
>
mCharset
=
aCharset
;
}
void
ScriptLoader
:
:
AddDeferRequest
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsDeferredScript
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mInDeferList
&
&
!
aRequest
-
>
GetLoadContext
(
)
-
>
mInAsyncList
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mInCompilingList
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mInDeferList
=
true
;
mDeferRequests
.
AppendElement
(
aRequest
)
;
if
(
mDeferEnabled
&
&
aRequest
=
=
mDeferRequests
.
getFirst
(
)
&
&
mDocument
&
&
!
mBlockingDOMContentLoaded
)
{
MOZ_ASSERT
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_LOADING
)
;
mBlockingDOMContentLoaded
=
true
;
mDocument
-
>
BlockDOMContentLoaded
(
)
;
}
}
void
ScriptLoader
:
:
AddAsyncRequest
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
GetLoadContext
(
)
-
>
IsAsyncScript
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mInDeferList
&
&
!
aRequest
-
>
GetLoadContext
(
)
-
>
mInAsyncList
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetLoadContext
(
)
-
>
mInCompilingList
)
;
aRequest
-
>
GetLoadContext
(
)
-
>
mInAsyncList
=
true
;
if
(
aRequest
-
>
IsReadyToRun
(
)
)
{
mLoadedAsyncRequests
.
AppendElement
(
aRequest
)
;
}
else
{
mLoadingAsyncRequests
.
AppendElement
(
aRequest
)
;
}
}
void
ScriptLoader
:
:
MaybeMoveToLoadedList
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsReadyToRun
(
)
)
;
if
(
aRequest
-
>
GetLoadContext
(
)
-
>
mInAsyncList
)
{
MOZ_ASSERT
(
aRequest
-
>
isInList
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
mLoadedAsyncRequests
.
AppendElement
(
req
)
;
}
}
}
bool
ScriptLoader
:
:
MaybeRemovedDeferRequests
(
)
{
if
(
mDeferRequests
.
isEmpty
(
)
&
&
mDocument
&
&
mBlockingDOMContentLoaded
)
{
mBlockingDOMContentLoaded
=
false
;
mDocument
-
>
UnblockDOMContentLoaded
(
)
;
return
true
;
}
return
false
;
}
DocGroup
*
ScriptLoader
:
:
GetDocGroup
(
)
const
{
return
mDocument
-
>
GetDocGroup
(
)
;
}
void
ScriptLoader
:
:
BeginDeferringScripts
(
)
{
mDeferEnabled
=
true
;
if
(
mDeferCheckpointReached
)
{
mDeferCheckpointReached
=
false
;
}
else
{
if
(
mDocument
)
{
mDocument
-
>
BlockOnload
(
)
;
}
}
}
nsAutoScriptLoaderDisabler
:
:
nsAutoScriptLoaderDisabler
(
Document
*
aDoc
)
{
mLoader
=
aDoc
-
>
ScriptLoader
(
)
;
mWasEnabled
=
mLoader
-
>
GetEnabled
(
)
;
if
(
mWasEnabled
)
{
mLoader
-
>
SetEnabled
(
false
)
;
}
}
nsAutoScriptLoaderDisabler
:
:
~
nsAutoScriptLoaderDisabler
(
)
{
if
(
mWasEnabled
)
{
mLoader
-
>
SetEnabled
(
true
)
;
}
}
#
undef
TRACE_FOR_TEST
#
undef
TRACE_FOR_TEST_BOOL
#
undef
TRACE_FOR_TEST_NONE
#
undef
LOG
}
