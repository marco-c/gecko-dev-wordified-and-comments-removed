#
include
"
ScriptLoader
.
h
"
#
include
"
ScriptLoadHandler
.
h
"
#
include
"
ScriptTrace
.
h
"
#
include
"
ModuleLoader
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
SharedScriptCache
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
FetchPriority
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
js
/
ColumnNumber
.
h
"
#
include
"
js
/
CompilationAndEvaluation
.
h
"
#
include
"
js
/
CompileOptions
.
h
"
#
include
"
js
/
ContextOptions
.
h
"
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
experimental
/
CompileScript
.
h
"
#
include
"
js
/
loader
/
ScriptLoadRequest
.
h
"
#
include
"
ScriptCompression
.
h
"
#
include
"
js
/
loader
/
LoadedScript
.
h
"
#
include
"
js
/
loader
/
ModuleLoadRequest
.
h
"
#
include
"
js
/
MemoryFunctions
.
h
"
#
include
"
js
/
Modules
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
Transcoding
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
mozilla
/
dom
/
AutoEntryScript
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
JSExecutionContext
.
h
"
#
include
"
mozilla
/
dom
/
ScriptDecoding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
SRILogHelper
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
net
/
HttpBaseChannel
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentSecurityUtils
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TaskController
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
js
/
loader
/
ModuleLoaderBase
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
using
namespace
JS
:
:
loader
;
namespace
mozilla
:
:
dom
{
LazyLogModule
ScriptLoader
:
:
gCspPRLog
(
"
CSP
"
)
;
LazyLogModule
ScriptLoader
:
:
gScriptLoaderLog
(
"
ScriptLoader
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
\
MOZ_LOG
(
ScriptLoader
:
:
gScriptLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
ScriptLoader
:
:
gScriptLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
)
static
constexpr
auto
kNullMimeType
=
"
javascript
/
null
"
_ns
;
NS_IMPL_ISUPPORTS
(
AsyncCompileShutdownObserver
nsIObserver
)
void
AsyncCompileShutdownObserver
:
:
OnShutdown
(
)
{
if
(
mScriptLoader
)
{
mScriptLoader
-
>
Destroy
(
)
;
MOZ_ASSERT
(
!
mScriptLoader
)
;
}
}
void
AsyncCompileShutdownObserver
:
:
Unregister
(
)
{
if
(
mScriptLoader
)
{
mScriptLoader
=
nullptr
;
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
}
}
NS_IMETHODIMP
AsyncCompileShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
OnShutdown
(
)
;
return
NS_OK
;
}
inline
void
ImplCycleCollectionUnlink
(
ScriptLoader
:
:
PreloadInfo
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mRequest
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ScriptLoader
:
:
PreloadInfo
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mRequest
aName
aFlags
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ScriptLoader
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ScriptLoader
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ScriptLoader
)
if
(
tmp
-
>
mDocument
)
{
tmp
-
>
DropDocumentReference
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNonAsyncExternalScriptInsertedRequests
mLoadingAsyncRequests
mLoadedAsyncRequests
mOffThreadCompilingRequests
mDeferRequests
mXSLTRequests
mParserBlockingRequest
mBytecodeEncodingQueue
mPreloads
mPendingChildLoaders
mModuleLoader
mWebExtModuleLoaders
mShadowRealmModuleLoaders
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
ScriptLoader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNonAsyncExternalScriptInsertedRequests
mLoadingAsyncRequests
mLoadedAsyncRequests
mOffThreadCompilingRequests
mDeferRequests
mXSLTRequests
mParserBlockingRequest
mBytecodeEncodingQueue
mPreloads
mPendingChildLoaders
mModuleLoader
mWebExtModuleLoaders
mShadowRealmModuleLoaders
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ScriptLoader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ScriptLoader
)
ScriptLoader
:
:
ScriptLoader
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
mParserBlockingBlockerCount
(
0
)
mBlockerCount
(
0
)
mNumberOfProcessors
(
0
)
mTotalFullParseSize
(
0
)
mPhysicalSizeOfMemory
(
-
1
)
mEnabled
(
true
)
mDeferEnabled
(
false
)
mSpeculativeOMTParsingEnabled
(
false
)
mDeferCheckpointReached
(
false
)
mBlockingDOMContentLoaded
(
false
)
mLoadEventFired
(
false
)
mGiveUpEncoding
(
false
)
mReporter
(
new
ConsoleReportCollector
(
)
)
{
LOG
(
(
"
ScriptLoader
:
:
ScriptLoader
%
p
"
this
)
)
;
mSpeculativeOMTParsingEnabled
=
StaticPrefs
:
:
dom_script_loader_external_scripts_speculative_omt_parse_enabled
(
)
;
#
ifdef
NIGHTLY_BUILD
if
(
StaticPrefs
:
:
dom_script_loader_navigation_cache
(
)
)
{
mCache
=
SharedScriptCache
:
:
Get
(
)
;
RegisterToCache
(
)
;
}
#
endif
mShutdownObserver
=
new
AsyncCompileShutdownObserver
(
this
)
;
nsContentUtils
:
:
RegisterShutdownObserver
(
mShutdownObserver
)
;
}
ScriptLoader
:
:
~
ScriptLoader
(
)
{
LOG
(
(
"
ScriptLoader
:
:
~
ScriptLoader
%
p
"
this
)
)
;
mObservers
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
FireScriptAvailable
(
NS_ERROR_ABORT
mParserBlockingRequest
)
;
}
for
(
ScriptLoadRequest
*
req
=
mXSLTRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
FireScriptAvailable
(
NS_ERROR_ABORT
req
)
;
}
for
(
ScriptLoadRequest
*
req
=
mDeferRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
FireScriptAvailable
(
NS_ERROR_ABORT
req
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadingAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
FireScriptAvailable
(
NS_ERROR_ABORT
req
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadedAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
FireScriptAvailable
(
NS_ERROR_ABORT
req
)
;
}
for
(
ScriptLoadRequest
*
req
=
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
FireScriptAvailable
(
NS_ERROR_ABORT
req
)
;
}
for
(
uint32_t
j
=
0
;
j
<
mPendingChildLoaders
.
Length
(
)
;
+
+
j
)
{
mPendingChildLoaders
[
j
]
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
if
(
mShutdownObserver
)
{
mShutdownObserver
-
>
Unregister
(
)
;
mShutdownObserver
=
nullptr
;
}
mModuleLoader
=
nullptr
;
if
(
mProcessPendingRequestsAsyncBypassParserBlocking
)
{
mProcessPendingRequestsAsyncBypassParserBlocking
-
>
Cancel
(
)
;
}
}
void
ScriptLoader
:
:
SetGlobalObject
(
nsIGlobalObject
*
aGlobalObject
)
{
if
(
!
aGlobalObject
)
{
CancelAndClearScriptLoadRequests
(
)
;
return
;
}
MOZ_ASSERT
(
!
HasPendingRequests
(
)
)
;
if
(
!
mModuleLoader
)
{
mModuleLoader
=
new
ModuleLoader
(
this
aGlobalObject
ModuleLoader
:
:
Normal
)
;
}
MOZ_ASSERT
(
mModuleLoader
-
>
GetGlobalObject
(
)
=
=
aGlobalObject
)
;
MOZ_ASSERT
(
aGlobalObject
-
>
GetModuleLoader
(
dom
:
:
danger
:
:
GetJSContext
(
)
)
=
=
mModuleLoader
)
;
}
void
ScriptLoader
:
:
DropDocumentReference
(
)
{
if
(
mDocument
&
&
mCache
)
{
DeregisterFromCache
(
)
;
}
mDocument
=
nullptr
;
}
void
ScriptLoader
:
:
RegisterToCache
(
)
{
if
(
mCache
)
{
MOZ_ASSERT
(
mDocument
)
;
mCache
-
>
RegisterLoader
(
*
this
)
;
}
}
void
ScriptLoader
:
:
DeregisterFromCache
(
)
{
if
(
mCache
)
{
MOZ_ASSERT
(
mDocument
)
;
mCache
-
>
CancelLoadsForLoader
(
*
this
)
;
mCache
-
>
UnregisterLoader
(
*
this
)
;
}
}
nsIPrincipal
*
ScriptLoader
:
:
LoaderPrincipal
(
)
const
{
return
mDocument
-
>
NodePrincipal
(
)
;
}
nsIPrincipal
*
ScriptLoader
:
:
PartitionedPrincipal
(
)
const
{
if
(
mDocument
&
&
StaticPrefs
:
:
privacy_partition_network_state
(
)
)
{
return
mDocument
-
>
PartitionedPrincipal
(
)
;
}
return
LoaderPrincipal
(
)
;
}
bool
ScriptLoader
:
:
ShouldBypassCache
(
)
const
{
return
mDocument
&
&
nsContentUtils
:
:
ShouldBypassSubResourceCache
(
mDocument
)
;
}
void
ScriptLoader
:
:
RegisterContentScriptModuleLoader
(
ModuleLoader
*
aLoader
)
{
MOZ_ASSERT
(
aLoader
)
;
MOZ_ASSERT
(
aLoader
-
>
GetScriptLoader
(
)
=
=
this
)
;
mWebExtModuleLoaders
.
AppendElement
(
aLoader
)
;
}
void
ScriptLoader
:
:
RegisterShadowRealmModuleLoader
(
ModuleLoader
*
aLoader
)
{
MOZ_ASSERT
(
aLoader
)
;
MOZ_ASSERT
(
aLoader
-
>
GetScriptLoader
(
)
=
=
this
)
;
mShadowRealmModuleLoaders
.
AppendElement
(
aLoader
)
;
}
static
void
CollectScriptTelemetry
(
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
MOZ_ASSERT
(
aRequest
-
>
IsFetching
(
)
)
;
if
(
!
CanRecordExtended
(
)
)
{
return
;
}
if
(
aRequest
-
>
mFetchSourceOnly
)
{
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
Inline
)
;
}
else
if
(
aRequest
-
>
IsTextSource
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
SourceFallback
)
;
}
}
else
{
if
(
aRequest
-
>
IsTextSource
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
Source
)
;
}
else
if
(
aRequest
-
>
IsBytecode
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
AltData
)
;
}
}
}
static
bool
IsScriptEventHandler
(
ScriptKind
kind
nsIContent
*
aScriptElement
)
{
if
(
kind
!
=
ScriptKind
:
:
eClassic
)
{
return
false
;
}
if
(
!
aScriptElement
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
nsAutoString
forAttr
eventAttr
;
if
(
!
aScriptElement
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
_for
forAttr
)
|
|
!
aScriptElement
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
event
eventAttr
)
)
{
return
false
;
}
const
nsAString
&
for_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
forAttr
)
;
if
(
!
for_str
.
LowerCaseEqualsLiteral
(
"
window
"
)
)
{
return
true
;
}
const
nsAString
&
event_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
eventAttr
false
)
;
if
(
!
StringBeginsWith
(
event_str
u
"
onload
"
_ns
nsCaseInsensitiveStringComparator
)
)
{
return
true
;
}
nsAutoString
:
:
const_iterator
start
end
;
event_str
.
BeginReading
(
start
)
;
event_str
.
EndReading
(
end
)
;
start
.
advance
(
6
)
;
if
(
start
!
=
end
&
&
*
start
!
=
'
(
'
&
&
*
start
!
=
'
'
)
{
return
true
;
}
return
false
;
}
nsContentPolicyType
ScriptLoadRequestToContentPolicyType
(
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsPreload
(
)
)
{
return
aRequest
-
>
IsModuleRequest
(
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
;
}
return
aRequest
-
>
IsModuleRequest
(
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_MODULE
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
}
nsresult
ScriptLoader
:
:
CheckContentPolicy
(
Document
*
aDocument
nsIScriptElement
*
aElement
const
nsAString
&
aNonce
ScriptLoadRequest
*
aRequest
)
{
nsContentPolicyType
contentPolicyType
=
ScriptLoadRequestToContentPolicyType
(
aRequest
)
;
nsCOMPtr
<
nsINode
>
requestingNode
=
do_QueryInterface
(
aElement
)
;
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
net
:
:
LoadInfo
(
aDocument
-
>
NodePrincipal
(
)
aDocument
-
>
NodePrincipal
(
)
requestingNode
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
contentPolicyType
)
;
secCheckLoadInfo
-
>
SetParserCreatedScript
(
aElement
-
>
GetParserCreated
(
)
!
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
secCheckLoadInfo
-
>
SetCspNonce
(
aNonce
)
;
if
(
aRequest
-
>
mIntegrity
.
IsValid
(
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
)
;
secCheckLoadInfo
-
>
SetIntegrityMetadata
(
aRequest
-
>
mIntegrity
.
GetIntegrityString
(
)
)
;
}
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
aRequest
-
>
mURI
secCheckLoadInfo
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
NS_FAILED
(
rv
)
|
|
shouldLoad
!
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
return
NS_OK
;
}
bool
ScriptLoader
:
:
IsAboutPageLoadingChromeURI
(
ScriptLoadRequest
*
aRequest
Document
*
aDocument
)
{
if
(
!
aRequest
-
>
mURI
-
>
SchemeIs
(
"
chrome
"
)
)
{
return
false
;
}
uint32_t
aboutModuleFlags
=
0
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
aRequest
-
>
TriggeringPrincipal
(
)
;
if
(
triggeringPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
if
(
!
triggeringPrincipal
-
>
SchemeIs
(
"
about
"
)
)
{
return
false
;
}
rv
=
triggeringPrincipal
-
>
GetAboutModuleFlags
(
&
aboutModuleFlags
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
}
else
if
(
triggeringPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
nsCOMPtr
<
nsIURI
>
docURI
=
aDocument
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
-
>
SchemeIs
(
"
about
"
)
)
{
return
false
;
}
nsCOMPtr
<
nsIAboutModule
>
aboutModule
;
rv
=
NS_GetAboutModule
(
docURI
getter_AddRefs
(
aboutModule
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
aboutModule
)
{
return
false
;
}
rv
=
aboutModule
-
>
GetURIFlags
(
docURI
&
aboutModuleFlags
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
}
else
{
return
false
;
}
if
(
aboutModuleFlags
&
nsIAboutModule
:
:
MAKE_LINKABLE
)
{
return
false
;
}
return
true
;
}
nsIURI
*
ScriptLoader
:
:
GetBaseURI
(
)
const
{
MOZ_ASSERT
(
mDocument
)
;
return
mDocument
-
>
GetDocBaseURI
(
)
;
}
class
ScriptRequestProcessor
:
public
Runnable
{
private
:
RefPtr
<
ScriptLoader
>
mLoader
;
RefPtr
<
ScriptLoadRequest
>
mRequest
;
public
:
ScriptRequestProcessor
(
ScriptLoader
*
aLoader
ScriptLoadRequest
*
aRequest
)
:
Runnable
(
"
dom
:
:
ScriptRequestProcessor
"
)
mLoader
(
aLoader
)
mRequest
(
aRequest
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mLoader
-
>
ProcessRequest
(
mRequest
)
;
}
}
;
void
ScriptLoader
:
:
RunScriptWhenSafe
(
ScriptLoadRequest
*
aRequest
)
{
auto
*
runnable
=
new
ScriptRequestProcessor
(
this
aRequest
)
;
nsContentUtils
:
:
AddScriptRunner
(
runnable
)
;
}
nsresult
ScriptLoader
:
:
RestartLoad
(
ScriptLoadRequest
*
aRequest
)
{
aRequest
-
>
DropBytecode
(
)
;
TRACE_FOR_TEST
(
aRequest
"
scriptloader_fallback
"
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
NotifyRestart
(
mDocument
)
;
aRequest
-
>
mFetchSourceOnly
=
true
;
nsresult
rv
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
rv
=
aRequest
-
>
AsModuleRequest
(
)
-
>
RestartModuleLoad
(
)
;
}
else
{
rv
=
StartLoad
(
aRequest
Nothing
(
)
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_BINDING_RETARGETED
;
}
nsresult
ScriptLoader
:
:
StartLoad
(
ScriptLoadRequest
*
aRequest
const
Maybe
<
nsAutoString
>
&
aCharsetForPreload
)
{
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
return
aRequest
-
>
AsModuleRequest
(
)
-
>
StartModuleLoad
(
)
;
}
return
StartClassicLoad
(
aRequest
aCharsetForPreload
)
;
}
static
nsSecurityFlags
CORSModeToSecurityFlags
(
CORSMode
aCORSMode
)
{
nsSecurityFlags
securityFlags
=
nsContentSecurityManager
:
:
ComputeSecurityFlags
(
aCORSMode
nsContentSecurityManager
:
:
CORSSecurityMapping
:
:
CORS_NONE_MAPS_TO_DISABLED_CORS_CHECKS
)
;
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
return
securityFlags
;
}
nsresult
ScriptLoader
:
:
StartClassicLoad
(
ScriptLoadRequest
*
aRequest
const
Maybe
<
nsAutoString
>
&
aCharsetForPreload
)
{
MOZ_ASSERT
(
aRequest
-
>
IsFetching
(
)
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NULL_POINTER
)
;
aRequest
-
>
SetUnknownDataType
(
)
;
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
NS_OK
;
}
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
url
;
aRequest
-
>
mURI
-
>
GetAsciiSpec
(
url
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Start
Classic
Load
(
url
=
%
s
)
"
aRequest
url
.
get
(
)
)
)
;
}
nsSecurityFlags
securityFlags
=
CORSModeToSecurityFlags
(
aRequest
-
>
CORSMode
(
)
)
;
nsresult
rv
=
StartLoadInternal
(
aRequest
securityFlags
aCharsetForPreload
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
static
bool
IsWebExtensionRequest
(
ScriptLoadRequest
*
aRequest
)
{
if
(
!
aRequest
-
>
IsModuleRequest
(
)
)
{
return
false
;
}
ModuleLoader
*
loader
=
ModuleLoader
:
:
From
(
aRequest
-
>
AsModuleRequest
(
)
-
>
mLoader
)
;
return
loader
-
>
GetKind
(
)
=
=
ModuleLoader
:
:
WebExtension
;
}
static
nsresult
CreateChannelForScriptLoading
(
nsIChannel
*
*
aOutChannel
Document
*
aDocument
nsIURI
*
aURI
nsINode
*
aContext
nsIPrincipal
*
aTriggeringPrincipal
nsSecurityFlags
aSecurityFlags
nsContentPolicyType
aContentPolicyType
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aDocument
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
aDocument
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_NULL_POINTER
)
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
prompter
(
do_QueryInterface
(
docshell
)
)
;
return
NS_NewChannelWithTriggeringPrincipal
(
aOutChannel
aURI
aContext
aTriggeringPrincipal
aSecurityFlags
aContentPolicyType
nullptr
loadGroup
prompter
)
;
}
static
nsresult
CreateChannelForScriptLoading
(
nsIChannel
*
*
aOutChannel
Document
*
aDocument
ScriptLoadRequest
*
aRequest
nsSecurityFlags
aSecurityFlags
)
{
nsContentPolicyType
contentPolicyType
=
ScriptLoadRequestToContentPolicyType
(
aRequest
)
;
nsCOMPtr
<
nsINode
>
context
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
HasScriptElement
(
)
)
{
context
=
do_QueryInterface
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForLoadingNode
(
)
)
;
}
else
{
context
=
aDocument
;
}
return
CreateChannelForScriptLoading
(
aOutChannel
aDocument
aRequest
-
>
mURI
context
aRequest
-
>
TriggeringPrincipal
(
)
aSecurityFlags
contentPolicyType
)
;
}
static
void
PrepareLoadInfoForScriptLoading
(
nsIChannel
*
aChannel
const
ScriptLoadRequest
*
aRequest
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetParserCreatedScript
(
aRequest
-
>
ParserMetadata
(
)
=
=
ParserMetadata
:
:
ParserInserted
)
;
loadInfo
-
>
SetCspNonce
(
aRequest
-
>
Nonce
(
)
)
;
if
(
aRequest
-
>
mIntegrity
.
IsValid
(
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
)
;
loadInfo
-
>
SetIntegrityMetadata
(
aRequest
-
>
mIntegrity
.
GetIntegrityString
(
)
)
;
}
}
void
ScriptLoader
:
:
PrepareCacheInfoChannel
(
nsIChannel
*
aChannel
ScriptLoadRequest
*
aRequest
)
{
aRequest
-
>
mCacheInfo
=
nullptr
;
nsCOMPtr
<
nsICacheInfoChannel
>
cic
(
do_QueryInterface
(
aChannel
)
)
;
if
(
cic
&
&
StaticPrefs
:
:
dom_script_loader_bytecode_cache_enabled
(
)
)
{
MOZ_ASSERT
(
!
IsWebExtensionRequest
(
aRequest
)
"
Can
not
bytecode
cache
WebExt
code
"
)
;
if
(
!
aRequest
-
>
mFetchSourceOnly
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Maybe
request
bytecode
"
aRequest
)
)
;
cic
-
>
PreferAlternativeDataType
(
ScriptLoader
:
:
BytecodeMimeTypeFor
(
aRequest
)
"
"
_ns
nsICacheInfoChannel
:
:
PreferredAlternativeDataDeliveryType
:
:
ASYNC
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Request
saving
bytecode
later
"
aRequest
)
)
;
cic
-
>
PreferAlternativeDataType
(
kNullMimeType
"
"
_ns
nsICacheInfoChannel
:
:
PreferredAlternativeDataDeliveryType
:
:
ASYNC
)
;
}
}
}
static
void
AdjustPriorityAndClassOfServiceForLinkPreloadScripts
(
nsIChannel
*
aChannel
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
;
ScriptLoadContext
:
:
PrioritizeAsPreload
(
aChannel
)
;
if
(
!
StaticPrefs
:
:
network_fetchpriority_enabled
(
)
)
{
return
;
}
if
(
nsCOMPtr
<
nsISupportsPriority
>
supportsPriority
=
do_QueryInterface
(
aChannel
)
)
{
LOG
(
(
"
Is
<
link
rel
=
[
module
]
preload
"
)
)
;
const
auto
fetchPriority
=
ToFetchPriority
(
aRequest
-
>
FetchPriority
(
)
)
;
const
int32_t
supportsPriorityDelta
=
FETCH_PRIORITY_ADJUSTMENT_FOR
(
link_preload_script
fetchPriority
)
;
supportsPriority
-
>
AdjustPriority
(
supportsPriorityDelta
)
;
#
ifdef
DEBUG
int32_t
adjustedPriority
;
supportsPriority
-
>
GetPriority
(
&
adjustedPriority
)
;
LogPriorityMapping
(
ScriptLoader
:
:
gScriptLoaderLog
fetchPriority
adjustedPriority
)
;
#
endif
}
}
void
AdjustPriorityForNonLinkPreloadScripts
(
nsIChannel
*
aChannel
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
;
if
(
!
StaticPrefs
:
:
network_fetchpriority_enabled
(
)
)
{
return
;
}
if
(
nsCOMPtr
<
nsISupportsPriority
>
supportsPriority
=
do_QueryInterface
(
aChannel
)
)
{
LOG
(
(
"
Is
not
<
link
rel
=
[
module
]
preload
"
)
)
;
const
auto
fetchPriority
=
ToFetchPriority
(
aRequest
-
>
FetchPriority
(
)
)
;
const
int32_t
supportsPriorityDelta
=
[
&
]
(
)
{
const
ScriptLoadContext
*
scriptLoadContext
=
aRequest
-
>
GetScriptLoadContext
(
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
return
FETCH_PRIORITY_ADJUSTMENT_FOR
(
module_script
fetchPriority
)
;
}
if
(
scriptLoadContext
-
>
IsAsyncScript
(
)
|
|
scriptLoadContext
-
>
IsDeferredScript
(
)
)
{
return
FETCH_PRIORITY_ADJUSTMENT_FOR
(
async_or_defer_script
fetchPriority
)
;
}
if
(
scriptLoadContext
-
>
mScriptFromHead
)
{
return
FETCH_PRIORITY_ADJUSTMENT_FOR
(
script_in_head
fetchPriority
)
;
}
return
FETCH_PRIORITY_ADJUSTMENT_FOR
(
other_script
fetchPriority
)
;
}
(
)
;
if
(
supportsPriorityDelta
)
{
supportsPriority
-
>
AdjustPriority
(
supportsPriorityDelta
)
;
#
ifdef
DEBUG
int32_t
adjustedPriority
;
supportsPriority
-
>
GetPriority
(
&
adjustedPriority
)
;
LogPriorityMapping
(
ScriptLoader
:
:
gScriptLoaderLog
fetchPriority
adjustedPriority
)
;
#
endif
}
}
}
void
ScriptLoader
:
:
PrepareRequestPriorityAndRequestDependencies
(
nsIChannel
*
aChannel
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
{
AdjustPriorityAndClassOfServiceForLinkPreloadScripts
(
aChannel
aRequest
)
;
ScriptLoadContext
:
:
AddLoadBackgroundFlag
(
aChannel
)
;
}
else
if
(
nsCOMPtr
<
nsIClassOfService
>
cos
=
do_QueryInterface
(
aChannel
)
)
{
AdjustPriorityForNonLinkPreloadScripts
(
aChannel
aRequest
)
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mScriptFromHead
&
&
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsBlockingScript
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
else
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsDeferredScript
(
)
&
&
!
StaticPrefs
:
:
network_http_tailing_enabled
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
TailForbidden
)
;
}
else
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Unblocked
)
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsAsyncScript
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
TailAllowed
)
;
}
}
}
}
nsresult
ScriptLoader
:
:
PrepareHttpRequestAndInitiatorType
(
nsIChannel
*
aChannel
ScriptLoadRequest
*
aRequest
const
Maybe
<
nsAutoString
>
&
aCharsetForPreload
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aChannel
)
)
;
nsresult
rv
=
NS_OK
;
if
(
httpChannel
)
{
nsAutoCString
acceptTypes
(
"
*
/
*
"
)
;
rv
=
httpChannel
-
>
SetRequestHeader
(
"
Accept
"
_ns
acceptTypes
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
aRequest
-
>
mReferrer
aRequest
-
>
ReferrerPolicy
(
)
)
;
rv
=
httpChannel
-
>
SetReferrerInfoWithoutClone
(
referrerInfo
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
internalChannel
)
{
rv
=
internalChannel
-
>
SetIntegrityMetadata
(
aRequest
-
>
mIntegrity
.
GetIntegrityString
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsAutoString
hintCharset
;
if
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsPreload
(
)
&
&
aRequest
-
>
GetScriptLoadContext
(
)
-
>
HasScriptElement
(
)
)
{
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetHintCharset
(
hintCharset
)
;
}
else
if
(
aCharsetForPreload
.
isSome
(
)
)
{
hintCharset
=
aCharsetForPreload
.
ref
(
)
;
}
rv
=
httpChannel
-
>
SetClassicScriptHintCharset
(
hintCharset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChannel
)
{
if
(
aRequest
-
>
mEarlyHintPreloaderId
)
{
timedChannel
-
>
SetInitiatorType
(
u
"
early
-
hints
"
_ns
)
;
}
else
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
{
timedChannel
-
>
SetInitiatorType
(
u
"
link
"
_ns
)
;
}
else
{
timedChannel
-
>
SetInitiatorType
(
u
"
script
"
_ns
)
;
}
}
return
rv
;
}
nsresult
ScriptLoader
:
:
PrepareIncrementalStreamLoader
(
nsIIncrementalStreamLoader
*
*
aOutLoader
nsIChannel
*
aChannel
ScriptLoadRequest
*
aRequest
)
{
UniquePtr
<
mozilla
:
:
dom
:
:
SRICheckDataVerifier
>
sriDataVerifier
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
)
{
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
sriDataVerifier
=
MakeUnique
<
SRICheckDataVerifier
>
(
aRequest
-
>
mIntegrity
sourceUri
mReporter
)
;
}
RefPtr
<
ScriptLoadHandler
>
handler
=
new
ScriptLoadHandler
(
this
aRequest
std
:
:
move
(
sriDataVerifier
)
)
;
aChannel
-
>
SetNotificationCallbacks
(
handler
)
;
nsresult
rv
=
NS_NewIncrementalStreamLoader
(
aOutLoader
handler
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
nsresult
ScriptLoader
:
:
StartLoadInternal
(
ScriptLoadRequest
*
aRequest
nsSecurityFlags
securityFlags
const
Maybe
<
nsAutoString
>
&
aCharsetForPreload
)
{
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
CreateChannelForScriptLoading
(
getter_AddRefs
(
channel
)
mDocument
aRequest
securityFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aRequest
-
>
mEarlyHintPreloaderId
)
{
nsCOMPtr
<
nsIHttpChannelInternal
>
channelInternal
=
do_QueryInterface
(
channel
)
;
NS_ENSURE_TRUE
(
channelInternal
!
=
nullptr
NS_ERROR_FAILURE
)
;
rv
=
channelInternal
-
>
SetEarlyHintPreloaderId
(
aRequest
-
>
mEarlyHintPreloaderId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
PrepareLoadInfoForScriptLoading
(
channel
aRequest
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
scriptGlobal
=
GetScriptGlobalObject
(
)
;
if
(
!
scriptGlobal
)
{
return
NS_ERROR_FAILURE
;
}
ScriptLoader
:
:
PrepareCacheInfoChannel
(
channel
aRequest
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
mode
=
%
u
tracking
=
%
d
"
aRequest
unsigned
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mScriptMode
)
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsTracking
(
)
)
)
;
PrepareRequestPriorityAndRequestDependencies
(
channel
aRequest
)
;
rv
=
PrepareHttpRequestAndInitiatorType
(
channel
aRequest
aCharsetForPreload
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mozilla
:
:
net
:
:
PredictorLearn
(
aRequest
-
>
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
)
;
nsCOMPtr
<
nsIIncrementalStreamLoader
>
loader
;
rv
=
PrepareIncrementalStreamLoader
(
getter_AddRefs
(
loader
)
channel
aRequest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
auto
key
=
PreloadHashKey
:
:
CreateAsScript
(
aRequest
-
>
mURI
aRequest
-
>
CORSMode
(
)
aRequest
-
>
mKind
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
NotifyOpen
(
key
channel
mDocument
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
aRequest
-
>
IsModuleRequest
(
)
)
;
rv
=
channel
-
>
AsyncOpen
(
loader
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRequest
-
>
GetScriptLoadContext
(
)
-
>
NotifyStart
(
channel
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
NotifyStop
(
rv
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
bool
ScriptLoader
:
:
PreloadURIComparator
:
:
Equals
(
const
PreloadInfo
&
aPi
nsIURI
*
const
&
aURI
)
const
{
bool
same
;
return
NS_SUCCEEDED
(
aPi
.
mRequest
-
>
mURI
-
>
Equals
(
aURI
&
same
)
)
&
&
same
;
}
static
bool
CSPAllowsInlineScript
(
nsIScriptElement
*
aElement
const
nsAString
&
aNonce
Document
*
aDocument
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
aDocument
-
>
GetCsp
(
)
;
if
(
!
csp
)
{
return
true
;
}
bool
parserCreated
=
aElement
-
>
GetParserCreated
(
)
!
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
;
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aElement
)
;
bool
allowInlineScript
=
false
;
nsresult
rv
=
csp
-
>
GetAllowsInline
(
nsIContentSecurityPolicy
:
:
SCRIPT_SRC_ELEM_DIRECTIVE
false
aNonce
parserCreated
element
nullptr
u
"
"
_ns
aElement
-
>
GetScriptLineNumber
(
)
aElement
-
>
GetScriptColumnNumber
(
)
.
oneOriginValue
(
)
&
allowInlineScript
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
allowInlineScript
;
}
namespace
{
RequestPriority
FetchPriorityToRequestPriority
(
const
FetchPriority
aFetchPriority
)
{
switch
(
aFetchPriority
)
{
case
FetchPriority
:
:
High
:
return
RequestPriority
:
:
High
;
case
FetchPriority
:
:
Low
:
return
RequestPriority
:
:
Low
;
case
FetchPriority
:
:
Auto
:
return
RequestPriority
:
:
Auto
;
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
RequestPriority
:
:
Auto
;
}
}
void
ScriptLoader
:
:
NotifyObserversForCachedScript
(
nsIURI
*
aURI
nsINode
*
aContext
nsIPrincipal
*
aTriggeringPrincipal
nsSecurityFlags
aSecurityFlags
nsContentPolicyType
aContentPolicyType
)
{
nsCOMPtr
<
nsIObserverService
>
obsService
=
services
:
:
GetObserverService
(
)
;
if
(
!
obsService
-
>
HasObservers
(
"
http
-
on
-
resource
-
cache
-
response
"
)
)
{
return
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
CreateChannelForScriptLoading
(
getter_AddRefs
(
channel
)
mDocument
aURI
aContext
aTriggeringPrincipal
aSecurityFlags
aContentPolicyType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
RefPtr
<
net
:
:
HttpBaseChannel
>
httpBaseChannel
=
do_QueryObject
(
channel
)
;
if
(
httpBaseChannel
)
{
httpBaseChannel
-
>
SetDummyChannelForCachedResource
(
)
;
}
obsService
-
>
NotifyObservers
(
channel
"
http
-
on
-
resource
-
cache
-
response
"
nullptr
)
;
}
already_AddRefed
<
ScriptLoadRequest
>
ScriptLoader
:
:
CreateLoadRequest
(
ScriptKind
aKind
nsIURI
*
aURI
nsIScriptElement
*
aElement
nsIPrincipal
*
aTriggeringPrincipal
CORSMode
aCORSMode
const
nsAString
&
aNonce
RequestPriority
aRequestPriority
const
SRIMetadata
&
aIntegrity
ReferrerPolicy
aReferrerPolicy
ParserMetadata
aParserMetadata
RequestType
requestType
)
{
nsIURI
*
referrer
=
mDocument
-
>
GetDocumentURIAsReferrer
(
)
;
RefPtr
<
ScriptFetchOptions
>
fetchOptions
=
new
ScriptFetchOptions
(
aCORSMode
aNonce
aRequestPriority
aParserMetadata
aTriggeringPrincipal
)
;
RefPtr
<
ScriptLoadContext
>
context
=
new
ScriptLoadContext
(
aElement
)
;
if
(
aKind
=
=
ScriptKind
:
:
eClassic
|
|
aKind
=
=
ScriptKind
:
:
eImportMap
)
{
RefPtr
<
ScriptLoadRequest
>
aRequest
=
new
ScriptLoadRequest
(
aKind
aURI
aReferrerPolicy
fetchOptions
aIntegrity
referrer
context
)
;
if
(
requestType
=
=
RequestType
:
:
External
&
&
mCache
)
{
ScriptHashKey
key
(
this
aRequest
)
;
auto
cacheResult
=
mCache
-
>
Lookup
(
*
this
key
true
)
;
if
(
cacheResult
.
mState
=
=
CachedSubResourceState
:
:
Complete
)
{
if
(
NS_FAILED
(
CheckContentPolicy
(
mDocument
aElement
aNonce
aRequest
)
)
)
{
aRequest
-
>
NoCacheEntryFound
(
)
;
return
aRequest
.
forget
(
)
;
}
nsCOMPtr
<
nsINode
>
context
;
if
(
aElement
)
{
context
=
do_QueryInterface
(
aElement
)
;
}
else
{
context
=
mDocument
;
}
NotifyObserversForCachedScript
(
aURI
context
aTriggeringPrincipal
CORSModeToSecurityFlags
(
aCORSMode
)
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
)
;
aRequest
-
>
CacheEntryFound
(
cacheResult
.
mCompleteValue
)
;
return
aRequest
.
forget
(
)
;
}
aRequest
-
>
NoCacheEntryFound
(
)
;
return
aRequest
.
forget
(
)
;
}
aRequest
-
>
NoCacheEntryFound
(
)
;
return
aRequest
.
forget
(
)
;
}
MOZ_ASSERT
(
aKind
=
=
ScriptKind
:
:
eModule
)
;
RefPtr
<
ModuleLoadRequest
>
aRequest
=
ModuleLoader
:
:
CreateTopLevel
(
aURI
aReferrerPolicy
fetchOptions
aIntegrity
referrer
this
context
)
;
return
aRequest
.
forget
(
)
;
}
bool
ScriptLoader
:
:
ProcessScriptElement
(
nsIScriptElement
*
aElement
)
{
NS_ENSURE_TRUE
(
mDocument
false
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
false
;
}
NS_ASSERTION
(
!
aElement
-
>
IsMalformed
(
)
"
Executing
malformed
script
"
)
;
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
ScriptKind
scriptKind
;
if
(
aElement
-
>
GetScriptIsModule
(
)
)
{
scriptKind
=
ScriptKind
:
:
eModule
;
}
else
if
(
aElement
-
>
GetScriptIsImportMap
(
)
)
{
scriptKind
=
ScriptKind
:
:
eImportMap
;
}
else
{
scriptKind
=
ScriptKind
:
:
eClassic
;
}
if
(
IsScriptEventHandler
(
scriptKind
scriptContent
)
)
{
return
false
;
}
if
(
scriptKind
=
=
ScriptKind
:
:
eClassic
&
&
scriptContent
-
>
IsHTMLElement
(
)
&
&
scriptContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
nomodule
)
)
{
return
false
;
}
if
(
aElement
-
>
GetScriptExternal
(
)
)
{
return
ProcessExternalScript
(
aElement
scriptKind
scriptContent
)
;
}
return
ProcessInlineScript
(
aElement
scriptKind
)
;
}
static
ParserMetadata
GetParserMetadata
(
nsIScriptElement
*
aElement
)
{
return
aElement
-
>
GetParserCreated
(
)
=
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
?
ParserMetadata
:
:
NotParserInserted
:
ParserMetadata
:
:
ParserInserted
;
}
bool
ScriptLoader
:
:
ProcessExternalScript
(
nsIScriptElement
*
aElement
ScriptKind
aScriptKind
nsIContent
*
aScriptContent
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Process
external
script
for
element
%
p
"
this
aElement
)
)
;
if
(
aScriptKind
=
=
ScriptKind
:
:
eImportMap
)
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Script
Loader
"
_ns
mDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
ImportMapExternalNotSupported
"
)
;
return
false
;
}
nsCOMPtr
<
nsIURI
>
scriptURI
=
aElement
-
>
GetScriptURI
(
)
;
if
(
!
scriptURI
)
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
nsString
nonce
=
nsContentSecurityUtils
:
:
GetIsElementNonceableNonce
(
*
aScriptContent
-
>
AsElement
(
)
)
;
SRIMetadata
sriMetadata
;
{
nsAutoString
integrity
;
aScriptContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
integrity
integrity
)
;
GetSRIMetadata
(
integrity
&
sriMetadata
)
;
}
RefPtr
<
ScriptLoadRequest
>
request
=
LookupPreloadRequest
(
aElement
aScriptKind
sriMetadata
)
;
if
(
request
)
{
if
(
NS_FAILED
(
CheckContentPolicy
(
mDocument
aElement
nonce
request
)
)
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
content
policy
check
failed
for
preload
"
this
)
)
;
request
-
>
Cancel
(
)
;
return
false
;
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Using
preload
request
"
request
.
get
(
)
)
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Disallow
further
import
maps
.
"
request
.
get
(
)
)
)
;
mModuleLoader
-
>
DisallowImportMaps
(
)
;
}
request
-
>
GetScriptLoadContext
(
)
-
>
SetScriptMode
(
aElement
-
>
GetScriptDeferred
(
)
aElement
-
>
GetScriptAsync
(
)
false
)
;
if
(
request
-
>
GetScriptLoadContext
(
)
-
>
mInCompilingList
)
{
mOffThreadCompilingRequests
.
Remove
(
request
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
mInCompilingList
=
false
;
}
}
else
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aElement
-
>
GetScriptURITriggeringPrincipal
(
)
;
if
(
!
principal
)
{
principal
=
aScriptContent
-
>
NodePrincipal
(
)
;
}
CORSMode
ourCORSMode
=
aElement
-
>
GetCORSMode
(
)
;
const
FetchPriority
fetchPriority
=
aElement
-
>
GetFetchPriority
(
)
;
ReferrerPolicy
referrerPolicy
=
GetReferrerPolicy
(
aElement
)
;
ParserMetadata
parserMetadata
=
GetParserMetadata
(
aElement
)
;
request
=
CreateLoadRequest
(
aScriptKind
scriptURI
aElement
principal
ourCORSMode
nonce
FetchPriorityToRequestPriority
(
fetchPriority
)
sriMetadata
referrerPolicy
parserMetadata
RequestType
:
:
External
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
=
false
;
request
-
>
GetScriptLoadContext
(
)
-
>
SetScriptMode
(
aElement
-
>
GetScriptDeferred
(
)
aElement
-
>
GetScriptAsync
(
)
false
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Created
request
for
external
script
"
request
.
get
(
)
)
)
;
if
(
!
request
-
>
IsStencil
(
)
)
{
nsresult
rv
=
StartLoad
(
request
Nothing
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportErrorToConsole
(
request
rv
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
;
if
(
mDocument
)
{
mDocument
-
>
Dispatch
(
runnable
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
runnable
.
forget
(
)
)
;
}
return
false
;
}
}
}
NS_ASSERTION
(
SpeculativeOMTParsingEnabled
(
)
|
|
!
request
-
>
GetScriptLoadContext
(
)
-
>
CompileStarted
(
)
|
|
request
-
>
IsModuleRequest
(
)
"
Request
should
not
yet
be
in
compiling
stage
.
"
)
;
if
(
request
-
>
GetScriptLoadContext
(
)
-
>
IsAsyncScript
(
)
)
{
AddAsyncRequest
(
request
)
;
if
(
request
-
>
IsFinished
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
false
;
}
if
(
!
aElement
-
>
GetParserCreated
(
)
)
{
request
-
>
GetScriptLoadContext
(
)
-
>
mIsNonAsyncScriptInserted
=
true
;
mNonAsyncExternalScriptInsertedRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsFinished
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
false
;
}
if
(
request
-
>
GetScriptLoadContext
(
)
-
>
IsDeferredScript
(
)
)
{
NS_ASSERTION
(
mDocument
-
>
GetCurrentContentSink
(
)
|
|
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
"
Non
-
XSLT
Defer
script
on
a
document
without
an
active
"
"
parser
;
bug
592366
.
"
)
;
AddDeferRequest
(
request
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
mIsXSLT
=
true
;
mXSLTRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsFinished
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
true
;
}
if
(
request
-
>
IsFinished
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
ProcessPendingRequestsAsync
(
)
;
return
true
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
return
true
;
}
bool
ScriptLoader
:
:
ProcessInlineScript
(
nsIScriptElement
*
aElement
ScriptKind
aScriptKind
)
{
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
false
;
}
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
aElement
)
;
nsString
nonce
=
nsContentSecurityUtils
:
:
GetIsElementNonceableNonce
(
*
element
)
;
if
(
!
CSPAllowsInlineScript
(
aElement
nonce
mDocument
)
)
{
return
false
;
}
if
(
aScriptKind
=
=
ScriptKind
:
:
eImportMap
)
{
if
(
!
mModuleLoader
-
>
IsImportMapAllowed
(
)
)
{
NS_WARNING
(
"
ScriptLoader
:
import
maps
allowed
is
false
.
"
)
;
const
char
*
msg
=
mModuleLoader
-
>
HasImportMapRegistered
(
)
?
"
ImportMapNotAllowedMultiple
"
:
"
ImportMapNotAllowedAfterModuleLoad
"
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Script
Loader
"
_ns
mDocument
nsContentUtils
:
:
eDOM_PROPERTIES
msg
)
;
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
}
CORSMode
corsMode
=
CORS_NONE
;
if
(
aScriptKind
=
=
ScriptKind
:
:
eModule
)
{
corsMode
=
aElement
-
>
GetCORSMode
(
)
;
}
const
auto
fetchPriority
=
aElement
-
>
GetFetchPriority
(
)
;
ReferrerPolicy
referrerPolicy
=
GetReferrerPolicy
(
aElement
)
;
ParserMetadata
parserMetadata
=
GetParserMetadata
(
aElement
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
CreateLoadRequest
(
aScriptKind
mDocument
-
>
GetDocumentURI
(
)
aElement
mDocument
-
>
NodePrincipal
(
)
corsMode
nonce
FetchPriorityToRequestPriority
(
fetchPriority
)
SRIMetadata
(
)
referrerPolicy
parserMetadata
RequestType
:
:
Inline
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
=
true
;
request
-
>
GetScriptLoadContext
(
)
-
>
mLineNo
=
aElement
-
>
GetScriptLineNumber
(
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
mColumnNo
=
aElement
-
>
GetScriptColumnNumber
(
)
;
request
-
>
mFetchSourceOnly
=
true
;
request
-
>
SetTextSource
(
request
-
>
mLoadContext
.
get
(
)
)
;
TRACE_FOR_TEST_BOOL
(
request
"
scriptloader_load_source
"
)
;
CollectScriptTelemetry
(
request
)
;
MOZ_ASSERT
(
!
aElement
-
>
GetScriptDeferred
(
)
)
;
MOZ_ASSERT_IF
(
!
request
-
>
IsModuleRequest
(
)
!
aElement
-
>
GetScriptAsync
(
)
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
SetScriptMode
(
false
aElement
-
>
GetScriptAsync
(
)
false
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Created
request
for
inline
script
"
request
.
get
(
)
)
)
;
request
-
>
mBaseURL
=
mDocument
-
>
GetDocBaseURI
(
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
mModuleLoader
-
>
DisallowImportMaps
(
)
;
ModuleLoadRequest
*
modReq
=
request
-
>
AsModuleRequest
(
)
;
if
(
aElement
-
>
GetParserCreated
(
)
!
=
NOT_FROM_PARSER
)
{
if
(
aElement
-
>
GetScriptAsync
(
)
)
{
AddAsyncRequest
(
modReq
)
;
}
else
{
AddDeferRequest
(
modReq
)
;
}
}
nsresult
rv
=
modReq
-
>
OnFetchComplete
(
NS_OK
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReportErrorToConsole
(
modReq
rv
)
;
HandleLoadError
(
modReq
rv
)
;
}
return
false
;
}
if
(
request
-
>
IsImportMapRequest
(
)
)
{
MOZ_ASSERT
(
mModuleLoader
-
>
IsImportMapAllowed
(
)
)
;
mModuleLoader
-
>
DisallowImportMaps
(
)
;
UniquePtr
<
ImportMap
>
importMap
=
mModuleLoader
-
>
ParseImportMap
(
request
)
;
if
(
!
importMap
)
{
return
false
;
}
mPreloads
.
RemoveElementsBy
(
[
]
(
const
PreloadInfo
&
info
)
{
if
(
info
.
mRequest
-
>
IsModuleRequest
(
)
)
{
info
.
mRequest
-
>
Cancel
(
)
;
return
true
;
}
return
false
;
}
)
;
mModuleLoader
-
>
RegisterImportMap
(
std
:
:
move
(
importMap
)
)
;
return
false
;
}
request
-
>
mState
=
ScriptLoadRequest
:
:
State
:
:
Ready
;
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
&
&
(
!
ReadyToExecuteParserBlockingScripts
(
)
|
|
!
mXSLTRequests
.
isEmpty
(
)
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mXSLTRequests
.
AppendElement
(
request
)
;
return
true
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
NOT_FROM_PARSER
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
A
script
-
inserted
script
is
inserted
without
an
update
batch
?
"
)
;
RunScriptWhenSafe
(
request
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
&
&
!
ReadyToExecuteParserBlockingScripts
(
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
mParserBlockingRequest
=
request
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
return
true
;
}
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Not
safe
to
run
a
parser
-
inserted
script
?
"
)
;
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
ScriptLoadRequest
*
ScriptLoader
:
:
LookupPreloadRequest
(
nsIScriptElement
*
aElement
ScriptKind
aScriptKind
const
SRIMetadata
&
aSRIMetadata
)
{
MOZ_ASSERT
(
aElement
)
;
nsTArray
<
PreloadInfo
>
:
:
index_type
i
=
mPreloads
.
IndexOf
(
aElement
-
>
GetScriptURI
(
)
0
PreloadURIComparator
(
)
)
;
if
(
i
=
=
nsTArray
<
PreloadInfo
>
:
:
NoIndex
)
{
return
nullptr
;
}
RefPtr
<
ScriptLoadRequest
>
request
=
mPreloads
[
i
]
.
mRequest
;
if
(
aScriptKind
!
=
request
-
>
mKind
)
{
return
nullptr
;
}
request
-
>
GetScriptLoadContext
(
)
-
>
SetIsLoadRequest
(
aElement
)
;
if
(
request
-
>
GetScriptLoadContext
(
)
-
>
mWasCompiledOMT
&
&
!
request
-
>
IsModuleRequest
(
)
)
{
request
-
>
SetReady
(
)
;
}
nsString
preloadCharset
(
mPreloads
[
i
]
.
mCharset
)
;
mPreloads
.
RemoveElementAt
(
i
)
;
nsAutoString
elementCharset
;
aElement
-
>
GetScriptCharset
(
elementCharset
)
;
if
(
!
request
-
>
IsModuleRequest
(
)
&
&
(
!
elementCharset
.
Equals
(
preloadCharset
)
|
|
aElement
-
>
GetCORSMode
(
)
!
=
request
-
>
CORSMode
(
)
)
)
{
request
-
>
Cancel
(
)
;
return
nullptr
;
}
if
(
!
aSRIMetadata
.
CanTrustBeDelegatedTo
(
request
-
>
mIntegrity
)
)
{
if
(
!
request
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
{
request
-
>
Cancel
(
)
;
}
return
nullptr
;
}
ReportPreloadErrorsToConsole
(
request
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
NotifyUsage
(
mDocument
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
RemoveSelf
(
mDocument
)
;
return
request
;
}
void
ScriptLoader
:
:
GetSRIMetadata
(
const
nsAString
&
aIntegrityAttr
SRIMetadata
*
aMetadataOut
)
{
MOZ_ASSERT
(
aMetadataOut
-
>
IsEmpty
(
)
)
;
if
(
aIntegrityAttr
.
IsEmpty
(
)
)
{
return
;
}
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
ScriptLoader
:
:
GetSRIMetadata
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrityAttr
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
aIntegrityAttr
sourceUri
mReporter
aMetadataOut
)
;
}
ReferrerPolicy
ScriptLoader
:
:
GetReferrerPolicy
(
nsIScriptElement
*
aElement
)
{
ReferrerPolicy
scriptReferrerPolicy
=
aElement
-
>
GetReferrerPolicy
(
)
;
if
(
scriptReferrerPolicy
!
=
ReferrerPolicy
:
:
_empty
)
{
return
scriptReferrerPolicy
;
}
return
mDocument
-
>
GetReferrerPolicy
(
)
;
}
void
ScriptLoader
:
:
CancelAndClearScriptLoadRequests
(
)
{
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
Cancel
(
)
;
mParserBlockingRequest
=
nullptr
;
}
mDeferRequests
.
CancelRequestsAndClear
(
)
;
mLoadingAsyncRequests
.
CancelRequestsAndClear
(
)
;
mLoadedAsyncRequests
.
CancelRequestsAndClear
(
)
;
mNonAsyncExternalScriptInsertedRequests
.
CancelRequestsAndClear
(
)
;
mXSLTRequests
.
CancelRequestsAndClear
(
)
;
mOffThreadCompilingRequests
.
CancelRequestsAndClear
(
)
;
if
(
mModuleLoader
)
{
mModuleLoader
-
>
CancelAndClearDynamicImports
(
)
;
}
for
(
ModuleLoader
*
loader
:
mWebExtModuleLoaders
)
{
loader
-
>
CancelAndClearDynamicImports
(
)
;
}
for
(
ModuleLoader
*
loader
:
mShadowRealmModuleLoaders
)
{
loader
-
>
CancelAndClearDynamicImports
(
)
;
}
for
(
size_t
i
=
0
;
i
<
mPreloads
.
Length
(
)
;
i
+
+
)
{
mPreloads
[
i
]
.
mRequest
-
>
Cancel
(
)
;
}
mPreloads
.
Clear
(
)
;
}
nsresult
ScriptLoader
:
:
CompileOffThreadOrProcessRequest
(
ScriptLoadRequest
*
aRequest
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
if
(
!
aRequest
-
>
IsStencil
(
)
&
&
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mCompileOrDecodeTask
&
&
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
CompileStarted
(
)
)
{
bool
couldCompile
=
false
;
nsresult
rv
=
AttemptOffThreadScriptCompile
(
aRequest
&
couldCompile
)
;
if
(
NS_FAILED
(
rv
)
)
{
HandleLoadError
(
aRequest
rv
)
;
return
rv
;
}
if
(
couldCompile
)
{
return
NS_OK
;
}
}
return
ProcessRequest
(
aRequest
)
;
}
namespace
{
class
OffThreadCompilationCompleteTask
:
public
Task
{
public
:
OffThreadCompilationCompleteTask
(
ScriptLoadRequest
*
aRequest
ScriptLoader
*
aLoader
)
:
Task
(
Kind
:
:
MainThreadOnly
EventQueuePriority
:
:
Normal
)
mRequest
(
aRequest
)
mLoader
(
aLoader
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
RecordStartTime
(
)
{
mStartTime
=
TimeStamp
:
:
Now
(
)
;
}
void
RecordStopTime
(
)
{
mStopTime
=
TimeStamp
:
:
Now
(
)
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
bool
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
dom
:
:
OffThreadCompilationCompleteTask
"
)
;
return
true
;
}
#
endif
TaskResult
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ScriptLoadContext
>
context
=
mRequest
-
>
GetScriptLoadContext
(
)
;
if
(
!
context
-
>
mCompileOrDecodeTask
)
{
return
TaskResult
:
:
Complete
;
}
RecordStopTime
(
)
;
if
(
profiler_is_active
(
)
)
{
ProfilerString8View
scriptSourceString
;
if
(
mRequest
-
>
IsTextSource
(
)
)
{
scriptSourceString
=
"
ScriptCompileOffThread
"
;
}
else
{
MOZ_ASSERT
(
mRequest
-
>
IsBytecode
(
)
)
;
scriptSourceString
=
"
BytecodeDecodeOffThread
"
;
}
nsAutoCString
profilerLabelString
;
mRequest
-
>
GetScriptLoadContext
(
)
-
>
GetProfilerLabel
(
profilerLabelString
)
;
PROFILER_MARKER_TEXT
(
scriptSourceString
JS
MarkerTiming
:
:
Interval
(
mStartTime
mStopTime
)
profilerLabelString
)
;
}
(
void
)
mLoader
-
>
ProcessOffThreadRequest
(
mRequest
)
;
mRequest
=
nullptr
;
mLoader
=
nullptr
;
return
TaskResult
:
:
Complete
;
}
private
:
RefPtr
<
ScriptLoadRequest
>
mRequest
;
RefPtr
<
ScriptLoader
>
mLoader
;
TimeStamp
mStartTime
;
TimeStamp
mStopTime
;
}
;
}
static
constexpr
size_t
OffThreadMinimumTextLength
=
5
*
1000
;
static
constexpr
size_t
OffThreadMinimumBytecodeLength
=
5
*
1000
;
nsresult
ScriptLoader
:
:
AttemptOffThreadScriptCompile
(
ScriptLoadRequest
*
aRequest
bool
*
aCouldCompileOut
)
{
MOZ_ASSERT_IF
(
!
SpeculativeOMTParsingEnabled
(
)
&
&
!
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
IsFinished
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mWasCompiledOMT
)
;
MOZ_ASSERT
(
aCouldCompileOut
&
&
!
*
aCouldCompileOut
)
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
)
{
return
NS_OK
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
&
&
aRequest
-
>
AsModuleRequest
(
)
-
>
mModuleType
=
=
JS
:
:
ModuleType
:
:
JSON
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
GetGlobalForRequest
(
aRequest
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
globalObject
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
JS
:
:
Rooted
<
JSScript
*
>
dummyIntroductionScript
(
cx
)
;
nsresult
rv
=
FillCompileOptionsForRequest
(
cx
aRequest
&
options
&
dummyIntroductionScript
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aRequest
-
>
IsTextSource
(
)
)
{
if
(
!
StaticPrefs
:
:
javascript_options_parallel_parsing
(
)
|
|
aRequest
-
>
ScriptTextLength
(
)
<
OffThreadMinimumTextLength
)
{
TRACE_FOR_TEST
(
aRequest
"
scriptloader_main_thread_compile
"
)
;
return
NS_OK
;
}
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsBytecode
(
)
)
;
JS
:
:
TranscodeRange
bytecode
=
aRequest
-
>
Bytecode
(
)
;
if
(
!
StaticPrefs
:
:
javascript_options_parallel_parsing
(
)
|
|
bytecode
.
length
(
)
<
OffThreadMinimumBytecodeLength
)
{
return
NS_OK
;
}
}
RefPtr
<
CompileOrDecodeTask
>
compileOrDecodeTask
;
rv
=
CreateOffThreadTask
(
cx
aRequest
options
getter_AddRefs
(
compileOrDecodeTask
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
OffThreadCompilationCompleteTask
>
completeTask
=
new
OffThreadCompilationCompleteTask
(
aRequest
this
)
;
completeTask
-
>
RecordStartTime
(
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mCompileOrDecodeTask
=
compileOrDecodeTask
;
completeTask
-
>
AddDependency
(
compileOrDecodeTask
)
;
TaskController
:
:
Get
(
)
-
>
AddTask
(
compileOrDecodeTask
.
forget
(
)
)
;
TaskController
:
:
Get
(
)
-
>
AddTask
(
completeTask
.
forget
(
)
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
BlockOnload
(
mDocument
)
;
aRequest
-
>
mState
=
ScriptLoadRequest
:
:
State
:
:
Compiling
;
if
(
aRequest
-
>
IsTopLevel
(
)
&
&
!
aRequest
-
>
isInList
(
)
)
{
mOffThreadCompilingRequests
.
AppendElement
(
aRequest
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInCompilingList
=
true
;
}
*
aCouldCompileOut
=
true
;
return
NS_OK
;
}
CompileOrDecodeTask
:
:
CompileOrDecodeTask
(
)
:
Task
(
Kind
:
:
OffMainThreadOnly
EventQueuePriority
:
:
Normal
)
mMutex
(
"
CompileOrDecodeTask
"
)
mOptions
(
JS
:
:
OwningCompileOptions
:
:
ForFrontendContext
(
)
)
{
}
CompileOrDecodeTask
:
:
~
CompileOrDecodeTask
(
)
{
if
(
mFrontendContext
)
{
JS
:
:
DestroyFrontendContext
(
mFrontendContext
)
;
mFrontendContext
=
nullptr
;
}
}
nsresult
CompileOrDecodeTask
:
:
InitFrontendContext
(
)
{
mFrontendContext
=
JS
:
:
NewFrontendContext
(
)
;
if
(
!
mFrontendContext
)
{
mIsCancelled
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
CompileOrDecodeTask
:
:
DidRunTask
(
const
MutexAutoLock
&
aProofOfLock
RefPtr
<
JS
:
:
Stencil
>
&
&
aStencil
)
{
if
(
aStencil
)
{
if
(
!
JS
:
:
PrepareForInstantiate
(
mFrontendContext
*
aStencil
mInstantiationStorage
)
)
{
aStencil
=
nullptr
;
}
}
mStencil
=
std
:
:
move
(
aStencil
)
;
}
already_AddRefed
<
JS
:
:
Stencil
>
CompileOrDecodeTask
:
:
StealResult
(
JSContext
*
aCx
JS
:
:
InstantiationStorage
*
aInstantiationStorage
)
{
JS
:
:
FrontendContext
*
fc
=
mFrontendContext
;
mFrontendContext
=
nullptr
;
auto
destroyFrontendContext
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
JS
:
:
DestroyFrontendContext
(
fc
)
;
}
)
;
MOZ_ASSERT
(
fc
)
;
if
(
JS
:
:
HadFrontendErrors
(
fc
)
)
{
(
void
)
JS
:
:
ConvertFrontendErrorsToRuntimeErrors
(
aCx
fc
mOptions
)
;
return
nullptr
;
}
if
(
!
mStencil
&
&
JS
:
:
IsTranscodeFailureResult
(
mResult
)
)
{
JS_ReportErrorASCII
(
aCx
"
failed
to
decode
cache
"
)
;
return
nullptr
;
}
if
(
!
JS
:
:
ConvertFrontendErrorsToRuntimeErrors
(
aCx
fc
mOptions
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mStencil
"
If
this
task
is
cancelled
StealResult
shouldn
'
t
be
called
"
)
;
*
aInstantiationStorage
=
std
:
:
move
(
mInstantiationStorage
)
;
return
mStencil
.
forget
(
)
;
}
void
CompileOrDecodeTask
:
:
Cancel
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mIsCancelled
=
true
;
}
enum
class
CompilationTarget
{
Script
Module
}
;
template
<
CompilationTarget
target
>
class
ScriptOrModuleCompileTask
final
:
public
CompileOrDecodeTask
{
public
:
explicit
ScriptOrModuleCompileTask
(
ScriptLoader
:
:
MaybeSourceText
&
&
aMaybeSource
)
:
CompileOrDecodeTask
(
)
mMaybeSource
(
std
:
:
move
(
aMaybeSource
)
)
{
}
nsresult
Init
(
JS
:
:
CompileOptions
&
aOptions
)
{
nsresult
rv
=
InitFrontendContext
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mOptions
.
copy
(
mFrontendContext
aOptions
)
)
{
mIsCancelled
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
TaskResult
Run
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
IsCancelled
(
lock
)
)
{
return
TaskResult
:
:
Complete
;
}
RefPtr
<
JS
:
:
Stencil
>
stencil
=
Compile
(
)
;
DidRunTask
(
lock
std
:
:
move
(
stencil
)
)
;
return
TaskResult
:
:
Complete
;
}
private
:
already_AddRefed
<
JS
:
:
Stencil
>
Compile
(
)
{
size_t
stackSize
=
TaskController
:
:
GetThreadStackSize
(
)
;
JS
:
:
SetNativeStackQuota
(
mFrontendContext
JS
:
:
ThreadStackQuotaForSize
(
stackSize
)
)
;
auto
compile
=
[
&
]
(
auto
&
source
)
{
if
constexpr
(
target
=
=
CompilationTarget
:
:
Script
)
{
return
JS
:
:
CompileGlobalScriptToStencil
(
mFrontendContext
mOptions
source
)
;
}
return
JS
:
:
CompileModuleScriptToStencil
(
mFrontendContext
mOptions
source
)
;
}
;
return
mMaybeSource
.
mapNonEmpty
(
compile
)
;
}
public
:
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
bool
GetName
(
nsACString
&
aName
)
override
{
if
constexpr
(
target
=
=
CompilationTarget
:
:
Script
)
{
aName
.
AssignLiteral
(
"
ScriptCompileTask
"
)
;
}
else
{
aName
.
AssignLiteral
(
"
ModuleCompileTask
"
)
;
}
return
true
;
}
#
endif
private
:
ScriptLoader
:
:
MaybeSourceText
mMaybeSource
;
}
;
using
ScriptCompileTask
=
class
ScriptOrModuleCompileTask
<
CompilationTarget
:
:
Script
>
;
using
ModuleCompileTask
=
class
ScriptOrModuleCompileTask
<
CompilationTarget
:
:
Module
>
;
class
ScriptDecodeTask
final
:
public
CompileOrDecodeTask
{
public
:
explicit
ScriptDecodeTask
(
const
JS
:
:
TranscodeRange
&
aRange
)
:
mRange
(
aRange
)
{
}
nsresult
Init
(
JS
:
:
DecodeOptions
&
aOptions
)
{
nsresult
rv
=
InitFrontendContext
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mDecodeOptions
.
copy
(
mFrontendContext
aOptions
)
)
{
mIsCancelled
=
true
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
TaskResult
Run
(
)
override
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
IsCancelled
(
lock
)
)
{
return
TaskResult
:
:
Complete
;
}
RefPtr
<
JS
:
:
Stencil
>
stencil
=
Decode
(
)
;
JS
:
:
OwningCompileOptions
compileOptions
(
(
JS
:
:
OwningCompileOptions
:
:
ForFrontendContext
(
)
)
)
;
mOptions
.
steal
(
std
:
:
move
(
mDecodeOptions
)
)
;
DidRunTask
(
lock
std
:
:
move
(
stencil
)
)
;
return
TaskResult
:
:
Complete
;
}
private
:
already_AddRefed
<
JS
:
:
Stencil
>
Decode
(
)
{
RefPtr
<
JS
:
:
Stencil
>
stencil
;
mResult
=
JS
:
:
DecodeStencil
(
mFrontendContext
mDecodeOptions
mRange
getter_AddRefs
(
stencil
)
)
;
return
stencil
.
forget
(
)
;
}
public
:
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
bool
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
ScriptDecodeTask
"
)
;
return
true
;
}
#
endif
private
:
JS
:
:
OwningDecodeOptions
mDecodeOptions
;
JS
:
:
TranscodeRange
mRange
;
}
;
nsresult
ScriptLoader
:
:
CreateOffThreadTask
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
JS
:
:
CompileOptions
&
aOptions
CompileOrDecodeTask
*
*
aCompileOrDecodeTask
)
{
if
(
aRequest
-
>
IsBytecode
(
)
)
{
JS
:
:
TranscodeRange
bytecode
=
aRequest
-
>
Bytecode
(
)
;
JS
:
:
DecodeOptions
decodeOptions
(
aOptions
)
;
RefPtr
<
ScriptDecodeTask
>
decodeTask
=
new
ScriptDecodeTask
(
bytecode
)
;
nsresult
rv
=
decodeTask
-
>
Init
(
decodeOptions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
decodeTask
.
forget
(
aCompileOrDecodeTask
)
;
return
NS_OK
;
}
MaybeSourceText
maybeSource
;
nsresult
rv
=
aRequest
-
>
GetScriptSource
(
aCx
&
maybeSource
aRequest
-
>
mLoadContext
.
get
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ShouldApplyDelazifyStrategy
(
aRequest
)
)
{
ApplyDelazifyStrategy
(
&
aOptions
)
;
mTotalFullParseSize
+
=
aRequest
-
>
ScriptTextLength
(
)
>
0
?
static_cast
<
uint32_t
>
(
aRequest
-
>
ScriptTextLength
(
)
)
:
0
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
non
-
on
-
demand
-
only
(
omt
)
Parsing
Enabled
"
"
for
url
=
%
s
mTotalFullParseSize
=
%
u
"
aRequest
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
mTotalFullParseSize
)
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
RefPtr
<
ModuleCompileTask
>
compileTask
=
new
ModuleCompileTask
(
std
:
:
move
(
maybeSource
)
)
;
rv
=
compileTask
-
>
Init
(
aOptions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
compileTask
.
forget
(
aCompileOrDecodeTask
)
;
return
NS_OK
;
}
if
(
StaticPrefs
:
:
dom_expose_test_interfaces
(
)
)
{
switch
(
aOptions
.
eagerDelazificationStrategy
(
)
)
{
case
JS
:
:
DelazificationOption
:
:
OnDemandOnly
:
TRACE_FOR_TEST
(
aRequest
"
delazification_on_demand_only
"
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
CheckConcurrentWithOnDemand
:
case
JS
:
:
DelazificationOption
:
:
ConcurrentDepthFirst
:
TRACE_FOR_TEST
(
aRequest
"
delazification_concurrent_depth_first
"
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
ConcurrentLargeFirst
:
TRACE_FOR_TEST
(
aRequest
"
delazification_concurrent_large_first
"
)
;
break
;
case
JS
:
:
DelazificationOption
:
:
ParseEverythingEagerly
:
TRACE_FOR_TEST
(
aRequest
"
delazification_parse_everything_eagerly
"
)
;
break
;
}
}
RefPtr
<
ScriptCompileTask
>
compileTask
=
new
ScriptCompileTask
(
std
:
:
move
(
maybeSource
)
)
;
rv
=
compileTask
-
>
Init
(
aOptions
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
compileTask
.
forget
(
aCompileOrDecodeTask
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
ProcessOffThreadRequest
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsCompiling
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mWasCompiledOMT
)
;
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
NS_OK
;
}
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mWasCompiledOMT
=
true
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInCompilingList
)
{
mOffThreadCompilingRequests
.
Remove
(
aRequest
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInCompilingList
=
false
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mCompileOrDecodeTask
)
;
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
return
request
-
>
OnFetchComplete
(
NS_OK
)
;
}
MOZ_ASSERT_IF
(
!
SpeculativeOMTParsingEnabled
(
)
aRequest
-
>
GetScriptLoadContext
(
)
-
>
HasScriptElement
(
)
)
;
if
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
HasScriptElement
(
)
)
{
aRequest
-
>
GetScriptLoadContext
(
)
-
>
MaybeUnblockOnload
(
)
;
return
NS_OK
;
}
aRequest
-
>
SetReady
(
)
;
if
(
aRequest
!
=
mParserBlockingRequest
&
&
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsAsyncScript
(
)
|
|
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsBlockingScript
(
)
)
&
&
!
aRequest
-
>
isInList
(
)
)
{
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsAsyncScript
(
)
)
{
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInAsyncList
=
false
;
AddAsyncRequest
(
aRequest
)
;
}
else
{
MOZ_ASSERT
(
false
"
This
should
not
run
ever
with
the
current
default
prefs
.
The
"
"
request
should
not
run
synchronously
but
added
to
some
queue
.
"
)
;
return
ProcessRequest
(
aRequest
)
;
}
}
ProcessPendingRequests
(
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
ProcessRequest
(
ScriptLoadRequest
*
aRequest
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Process
request
"
aRequest
)
)
;
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
aRequest
-
>
IsFinished
(
)
"
Processing
a
request
that
is
not
ready
to
run
.
"
)
;
NS_ENSURE_ARG
(
aRequest
)
;
auto
unblockOnload
=
MakeScopeExit
(
[
&
]
{
aRequest
-
>
GetScriptLoadContext
(
)
-
>
MaybeUnblockOnload
(
)
;
}
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
request
-
>
IsDynamicImport
(
)
)
{
request
-
>
ProcessDynamicImport
(
)
;
return
NS_OK
;
}
if
(
request
-
>
mModuleScript
)
{
if
(
!
request
-
>
InstantiateModuleGraph
(
)
)
{
request
-
>
mModuleScript
=
nullptr
;
}
}
if
(
!
request
-
>
mModuleScript
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Error
loading
request
firing
error
"
aRequest
)
)
;
FireScriptAvailable
(
NS_ERROR_FAILURE
aRequest
)
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsINode
>
scriptElem
=
do_QueryInterface
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForExecuteEvents
(
)
)
;
nsCOMPtr
<
Document
>
doc
;
if
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
|
|
aRequest
-
>
IsModuleRequest
(
)
)
{
doc
=
scriptElem
-
>
OwnerDoc
(
)
;
}
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
;
uint32_t
parserCreated
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetParserCreated
(
)
;
if
(
parserCreated
)
{
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForCurrentParserInsertedScript
(
)
;
}
aRequest
-
>
GetScriptLoadContext
(
)
-
>
BeginEvaluatingTopLevel
(
)
;
FireScriptAvailable
(
NS_OK
aRequest
)
;
{
nsAutoMicroTask
mt
;
}
nsPIDOMWindowInner
*
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
bool
runScript
=
!
!
pwin
;
if
(
runScript
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
u
"
beforescriptexecute
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eYes
&
runScript
)
;
}
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
runScript
=
false
;
}
nsresult
rv
=
NS_OK
;
if
(
runScript
)
{
if
(
doc
)
{
doc
-
>
IncrementIgnoreDestructiveWritesCounter
(
)
;
}
rv
=
EvaluateScriptElement
(
aRequest
)
;
if
(
doc
)
{
doc
-
>
DecrementIgnoreDestructiveWritesCounter
(
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
u
"
afterscriptexecute
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
FireScriptEvaluated
(
rv
aRequest
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
EndEvaluatingTopLevel
(
)
;
if
(
parserCreated
)
{
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mCompileOrDecodeTask
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
MaybeCancelOffThreadScript
(
)
;
}
aRequest
-
>
ClearScriptSource
(
)
;
if
(
aRequest
-
>
IsBytecode
(
)
)
{
aRequest
-
>
DropBytecode
(
)
;
}
return
rv
;
}
void
ScriptLoader
:
:
FireScriptAvailable
(
nsresult
aResult
ScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptAvailable
(
aResult
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForObserver
(
)
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
aRequest
-
>
mURI
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mLineNo
)
;
}
bool
isInlineClassicScript
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
&
&
!
aRequest
-
>
IsModuleRequest
(
)
;
RefPtr
<
nsIScriptElement
>
scriptElement
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForObserver
(
)
;
scriptElement
-
>
ScriptAvailable
(
aResult
scriptElement
isInlineClassicScript
aRequest
-
>
mURI
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mLineNo
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
ScriptLoader
:
:
FireScriptEvaluated
(
nsresult
aResult
ScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
RefPtr
<
nsIScriptElement
>
scriptElement
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForObserver
(
)
;
obs
-
>
ScriptEvaluated
(
aResult
scriptElement
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
)
;
}
RefPtr
<
nsIScriptElement
>
scriptElement
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForObserver
(
)
;
scriptElement
-
>
ScriptEvaluated
(
aResult
scriptElement
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
)
;
}
already_AddRefed
<
nsIGlobalObject
>
ScriptLoader
:
:
GetGlobalForRequest
(
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoader
*
loader
=
ModuleLoader
:
:
From
(
aRequest
-
>
AsModuleRequest
(
)
-
>
mLoader
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
loader
-
>
GetGlobalObject
(
)
;
return
global
.
forget
(
)
;
}
return
GetScriptGlobalObject
(
)
;
}
already_AddRefed
<
nsIScriptGlobalObject
>
ScriptLoader
:
:
GetScriptGlobalObject
(
)
{
if
(
!
mDocument
)
{
return
nullptr
;
}
nsPIDOMWindowInner
*
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
do_QueryInterface
(
pwin
)
;
NS_ASSERTION
(
globalObject
"
windows
must
be
global
objects
"
)
;
nsresult
rv
=
globalObject
-
>
EnsureScriptEnvironment
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
globalObject
.
forget
(
)
;
}
nsresult
ScriptLoader
:
:
FillCompileOptionsForRequest
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
JS
:
:
CompileOptions
*
aOptions
JS
:
:
MutableHandle
<
JSScript
*
>
aIntroductionScript
)
{
nsresult
rv
=
aRequest
-
>
mURI
-
>
GetSpec
(
aRequest
-
>
mURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mDocument
)
{
mDocument
-
>
NoteScriptTrackingStatus
(
aRequest
-
>
mURL
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsTracking
(
)
)
;
}
const
char
*
introductionType
;
if
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
{
introductionType
=
"
importedModule
"
;
}
else
if
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
)
{
introductionType
=
"
srcScript
"
;
}
else
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
introductionType
=
"
inlineScript
"
;
}
else
{
introductionType
=
"
injectedScript
"
;
}
aOptions
-
>
setIntroductionInfoToCaller
(
aCx
introductionType
aIntroductionScript
)
;
aOptions
-
>
setFileAndLine
(
aRequest
-
>
mURL
.
get
(
)
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mLineNo
)
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
&
&
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
aOptions
-
>
setColumn
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mColumnNo
)
;
}
aOptions
-
>
setIsRunOnce
(
true
)
;
aOptions
-
>
setNoScriptRval
(
true
)
;
if
(
aRequest
-
>
mSourceMapURL
)
{
aOptions
-
>
setSourceMapURL
(
aRequest
-
>
mSourceMapURL
-
>
get
(
)
)
;
}
if
(
aRequest
-
>
mOriginPrincipal
)
{
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
GetGlobalForRequest
(
aRequest
)
;
nsIPrincipal
*
scriptPrin
=
globalObject
-
>
PrincipalOrNull
(
)
;
MOZ_ASSERT
(
scriptPrin
)
;
bool
subsumes
=
scriptPrin
-
>
Subsumes
(
aRequest
-
>
mOriginPrincipal
)
;
aOptions
-
>
setMutedErrors
(
!
subsumes
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
aOptions
-
>
setHideScriptFromDebugger
(
true
)
;
}
aOptions
-
>
setDeferDebugMetadata
(
true
)
;
aOptions
-
>
borrowBuffer
=
true
;
return
NS_OK
;
}
void
ScriptLoader
:
:
CalculateBytecodeCacheFlag
(
ScriptLoadRequest
*
aRequest
)
{
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
if
(
aRequest
-
>
IsStencil
(
)
)
{
aRequest
-
>
MarkPassedConditionForBytecodeEncoding
(
)
;
return
;
}
if
(
!
aRequest
-
>
mCacheInfo
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
cache
anything
(
cacheInfo
=
%
p
)
"
aRequest
aRequest
-
>
mCacheInfo
.
get
(
)
)
)
;
aRequest
-
>
MarkSkippedBytecodeEncoding
(
)
;
return
;
}
int32_t
strategy
=
StaticPrefs
:
:
dom_script_loader_bytecode_cache_strategy
(
)
;
bool
hasSourceLengthMin
=
false
;
bool
hasFetchCountMin
=
false
;
size_t
sourceLengthMin
=
100
;
uint32_t
fetchCountMin
=
4
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
strategy
=
%
d
.
"
aRequest
strategy
)
)
;
switch
(
strategy
)
{
case
-
2
:
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Encoding
disabled
.
"
aRequest
)
)
;
aRequest
-
>
MarkSkippedBytecodeEncoding
(
)
;
return
;
}
case
-
1
:
{
hasSourceLengthMin
=
false
;
hasFetchCountMin
=
false
;
break
;
}
default
:
case
0
:
{
hasSourceLengthMin
=
true
;
hasFetchCountMin
=
true
;
sourceLengthMin
=
1024
;
fetchCountMin
=
4
;
break
;
}
}
if
(
hasSourceLengthMin
)
{
size_t
sourceLength
;
size_t
minLength
;
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
sourceLength
=
aRequest
-
>
ReceivedScriptTextLength
(
)
;
minLength
=
sourceLengthMin
;
if
(
sourceLength
<
minLength
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Script
is
too
small
.
"
aRequest
)
)
;
aRequest
-
>
MarkSkippedBytecodeEncoding
(
)
;
return
;
}
}
if
(
hasFetchCountMin
)
{
uint32_t
fetchCount
=
0
;
if
(
NS_FAILED
(
aRequest
-
>
mCacheInfo
-
>
GetCacheTokenFetchCount
(
&
fetchCount
)
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Cannot
get
fetchCount
.
"
aRequest
)
)
;
aRequest
-
>
MarkSkippedBytecodeEncoding
(
)
;
return
;
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
fetchCount
=
%
d
.
"
aRequest
fetchCount
)
)
;
if
(
fetchCount
<
fetchCountMin
)
{
aRequest
-
>
MarkSkippedBytecodeEncoding
(
)
;
return
;
}
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Trigger
encoding
.
"
aRequest
)
)
;
aRequest
-
>
MarkPassedConditionForBytecodeEncoding
(
)
;
}
class
MOZ_RAII
AutoSetProcessingScriptTag
{
nsCOMPtr
<
nsIScriptContext
>
mContext
;
bool
mOldTag
;
public
:
explicit
AutoSetProcessingScriptTag
(
nsIScriptContext
*
aContext
)
:
mContext
(
aContext
)
mOldTag
(
mContext
-
>
GetProcessingScriptTag
(
)
)
{
mContext
-
>
SetProcessingScriptTag
(
true
)
;
}
~
AutoSetProcessingScriptTag
(
)
{
mContext
-
>
SetProcessingScriptTag
(
mOldTag
)
;
}
}
;
static
nsresult
ExecuteCompiledScript
(
JSContext
*
aCx
JSExecutionContext
&
aExec
ClassicScript
*
aLoaderScript
)
{
JS
:
:
Rooted
<
JSScript
*
>
script
(
aCx
aExec
.
GetScript
(
)
)
;
if
(
!
script
)
{
return
NS_OK
;
}
if
(
JS
:
:
GetScriptPrivate
(
script
)
.
isUndefined
(
)
)
{
aLoaderScript
-
>
AssociateWithScript
(
script
)
;
}
return
aExec
.
ExecScript
(
)
;
}
nsresult
ScriptLoader
:
:
EvaluateScriptElement
(
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
MOZ_ASSERT
(
aRequest
-
>
IsFinished
(
)
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
Document
*
ownerDoc
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptOwnerDocument
(
)
;
if
(
ownerDoc
!
=
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIGlobalObject
>
globalObject
;
nsCOMPtr
<
nsIScriptContext
>
context
;
if
(
!
IsWebExtensionRequest
(
aRequest
)
)
{
nsCOMPtr
<
nsIScriptGlobalObject
>
scriptGlobal
=
GetScriptGlobalObject
(
)
;
if
(
!
scriptGlobal
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT_IF
(
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
AsModuleRequest
(
)
-
>
GetGlobalObject
(
)
=
=
scriptGlobal
)
;
context
=
scriptGlobal
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
globalObject
=
scriptGlobal
;
}
nsIScriptElement
*
currentScript
=
aRequest
-
>
IsModuleRequest
(
)
?
nullptr
:
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForCurrentScript
(
)
;
AutoCurrentScriptUpdater
scriptUpdater
(
this
currentScript
)
;
Maybe
<
AutoSetProcessingScriptTag
>
setProcessingScriptTag
;
if
(
context
)
{
setProcessingScriptTag
.
emplace
(
context
)
;
}
MOZ_ASSERT
(
!
aRequest
-
>
IsImportMapRequest
(
)
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
return
aRequest
-
>
AsModuleRequest
(
)
-
>
EvaluateModule
(
)
;
}
return
EvaluateScript
(
globalObject
aRequest
)
;
}
nsresult
ScriptLoader
:
:
InstantiateClassicScriptFromMaybeEncodedSource
(
JSContext
*
aCx
JSExecutionContext
&
aExec
ScriptLoadRequest
*
aRequest
)
{
nsAutoCString
profilerLabelString
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetProfilerLabel
(
profilerLabelString
)
;
nsresult
rv
;
if
(
aRequest
-
>
IsBytecode
(
)
)
{
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mCompileOrDecodeTask
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Decode
Bytecode
&
instantiate
and
Execute
"
aRequest
)
)
;
rv
=
aExec
.
JoinOffThread
(
aRequest
-
>
GetScriptLoadContext
(
)
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Decode
Bytecode
and
Execute
"
aRequest
)
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
BytecodeDecodeMainThread
"
JS
MarkerInnerWindowIdFromJSContext
(
aCx
)
profilerLabelString
)
;
rv
=
aExec
.
Decode
(
aRequest
-
>
Bytecode
(
)
)
;
}
MOZ_ASSERT
(
!
aRequest
-
>
mCacheInfo
)
;
return
rv
;
}
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
CalculateBytecodeCacheFlag
(
aRequest
)
;
aExec
.
SetEncodeBytecode
(
aRequest
-
>
PassedConditionForBytecodeEncoding
(
)
)
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mCompileOrDecodeTask
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
instantiate
off
-
thread
result
and
"
"
Execute
"
aRequest
)
)
;
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
rv
=
aExec
.
JoinOffThread
(
aRequest
-
>
GetScriptLoadContext
(
)
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Compile
And
Exec
"
aRequest
)
)
;
MOZ_ASSERT
(
aRequest
-
>
IsTextSource
(
)
)
;
MaybeSourceText
maybeSource
;
rv
=
aRequest
-
>
GetScriptSource
(
aCx
&
maybeSource
aRequest
-
>
mLoadContext
.
get
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
AUTO_PROFILER_MARKER_TEXT
(
"
ScriptCompileMainThread
"
JS
MarkerInnerWindowIdFromJSContext
(
aCx
)
profilerLabelString
)
;
auto
compile
=
[
&
]
(
auto
&
source
)
{
return
aExec
.
Compile
(
source
)
;
}
;
MOZ_ASSERT
(
!
maybeSource
.
empty
(
)
)
;
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
rv
=
maybeSource
.
mapNonEmpty
(
compile
)
;
mMainThreadParseTime
+
=
TimeStamp
:
:
Now
(
)
-
startTime
;
}
}
return
rv
;
}
nsresult
ScriptLoader
:
:
InstantiateClassicScriptFromCachedStencil
(
JSContext
*
aCx
JSExecutionContext
&
aExec
ScriptLoadRequest
*
aRequest
JS
:
:
Stencil
*
aStencil
)
{
RefPtr
<
JS
:
:
Stencil
>
stencil
=
JS
:
:
DuplicateStencil
(
aCx
aStencil
)
;
if
(
!
stencil
)
{
return
NS_ERROR_FAILURE
;
}
aExec
.
SetEncodeBytecode
(
true
)
;
bool
incrementalEncodingAlreadyStarted
=
false
;
nsresult
rv
=
aExec
.
InstantiateStencil
(
std
:
:
move
(
stencil
)
incrementalEncodingAlreadyStarted
)
;
if
(
incrementalEncodingAlreadyStarted
)
{
aRequest
-
>
MarkSkippedBytecodeEncoding
(
)
;
}
return
rv
;
}
nsresult
ScriptLoader
:
:
InstantiateClassicScriptFromAny
(
JSContext
*
aCx
JSExecutionContext
&
aExec
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
IsStencil
(
)
)
{
RefPtr
<
JS
:
:
Stencil
>
stencil
=
aRequest
-
>
GetStencil
(
)
;
return
InstantiateClassicScriptFromCachedStencil
(
aCx
aExec
aRequest
stencil
)
;
}
bool
createCache
=
false
;
if
(
mCache
)
{
createCache
=
aRequest
-
>
IsCacheable
(
)
;
ScriptHashKey
key
(
this
aRequest
)
;
auto
cacheResult
=
mCache
-
>
Lookup
(
*
this
key
true
)
;
if
(
cacheResult
.
mState
=
=
CachedSubResourceState
:
:
Complete
)
{
createCache
=
false
;
}
if
(
createCache
)
{
aExec
.
SetKeepStencil
(
)
;
}
}
nsresult
rv
=
InstantiateClassicScriptFromMaybeEncodedSource
(
aCx
aExec
aRequest
)
;
if
(
rv
=
=
NS_OK
)
{
if
(
createCache
)
{
MOZ_ASSERT
(
mCache
)
;
aRequest
-
>
SetStencil
(
aExec
.
StealStencil
(
)
)
;
auto
loadData
=
MakeRefPtr
<
ScriptLoadData
>
(
this
aRequest
)
;
mCache
-
>
Insert
(
*
loadData
)
;
}
}
return
rv
;
}
nsCString
&
ScriptLoader
:
:
BytecodeMimeTypeFor
(
ScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
return
nsContentUtils
:
:
JSModuleBytecodeMimeType
(
)
;
}
return
nsContentUtils
:
:
JSScriptBytecodeMimeType
(
)
;
}
void
ScriptLoader
:
:
MaybePrepareForBytecodeEncodingBeforeExecute
(
ScriptLoadRequest
*
aRequest
JS
:
:
Handle
<
JSScript
*
>
aScript
)
{
if
(
!
aRequest
-
>
PassedConditionForBytecodeEncoding
(
)
)
{
return
;
}
aRequest
-
>
MarkScriptForBytecodeEncoding
(
aScript
)
;
}
nsresult
ScriptLoader
:
:
MaybePrepareForBytecodeEncodingAfterExecute
(
ScriptLoadRequest
*
aRequest
nsresult
aRv
)
{
if
(
aRequest
-
>
IsMarkedForBytecodeEncoding
(
)
)
{
TRACE_FOR_TEST
(
aRequest
"
scriptloader_encode
"
)
;
MOZ_ASSERT_IF
(
!
aRequest
-
>
IsStencil
(
)
aRequest
-
>
GetSRILength
(
)
=
=
aRequest
-
>
SRIAndBytecode
(
)
.
length
(
)
)
;
RegisterForBytecodeEncoding
(
aRequest
)
;
MOZ_ASSERT
(
IsAlreadyHandledForBytecodeEncodingPreparation
(
aRequest
)
)
;
return
aRv
;
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
disabled
(
rv
=
%
X
)
"
aRequest
unsigned
(
aRv
)
)
)
;
TRACE_FOR_TEST_NONE
(
aRequest
"
scriptloader_no_encode
"
)
;
aRequest
-
>
mCacheInfo
=
nullptr
;
MOZ_ASSERT
(
IsAlreadyHandledForBytecodeEncodingPreparation
(
aRequest
)
)
;
return
aRv
;
}
bool
ScriptLoader
:
:
IsAlreadyHandledForBytecodeEncodingPreparation
(
ScriptLoadRequest
*
aRequest
)
{
return
aRequest
-
>
isInList
(
)
|
|
!
aRequest
-
>
mCacheInfo
;
}
void
ScriptLoader
:
:
MaybePrepareModuleForBytecodeEncodingBeforeExecute
(
JSContext
*
aCx
ModuleLoadRequest
*
aRequest
)
{
{
ModuleScript
*
moduleScript
=
aRequest
-
>
mModuleScript
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
moduleScript
-
>
ModuleRecord
(
)
)
;
if
(
aRequest
-
>
IsMarkedForBytecodeEncoding
(
)
)
{
return
;
}
if
(
aRequest
-
>
PassedConditionForBytecodeEncoding
(
)
)
{
aRequest
-
>
MarkModuleForBytecodeEncoding
(
)
;
}
}
for
(
ModuleLoadRequest
*
childRequest
:
aRequest
-
>
mImports
)
{
MaybePrepareModuleForBytecodeEncodingBeforeExecute
(
aCx
childRequest
)
;
}
}
nsresult
ScriptLoader
:
:
MaybePrepareModuleForBytecodeEncodingAfterExecute
(
ModuleLoadRequest
*
aRequest
nsresult
aRv
)
{
if
(
IsAlreadyHandledForBytecodeEncodingPreparation
(
aRequest
)
)
{
return
aRv
;
}
aRv
=
MaybePrepareForBytecodeEncodingAfterExecute
(
aRequest
aRv
)
;
for
(
ModuleLoadRequest
*
childRequest
:
aRequest
-
>
mImports
)
{
aRv
=
MaybePrepareModuleForBytecodeEncodingAfterExecute
(
childRequest
aRv
)
;
}
return
aRv
;
}
nsresult
ScriptLoader
:
:
EvaluateScript
(
nsIGlobalObject
*
aGlobalObject
ScriptLoadRequest
*
aRequest
)
{
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
aGlobalObject
"
EvaluateScript
"
true
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
nsAutoCString
profilerLabelString
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetProfilerLabel
(
profilerLabelString
)
;
MOZ_ASSERT
(
aRequest
-
>
mLoadedScript
-
>
IsClassicScript
(
)
)
;
MOZ_ASSERT
(
aRequest
-
>
mLoadedScript
-
>
GetFetchOptions
(
)
-
>
IsCompatible
(
aRequest
-
>
mFetchOptions
)
)
;
#
ifdef
DEBUG
{
bool
equals
;
(
void
)
aRequest
-
>
mLoadedScript
-
>
GetURI
(
)
-
>
Equals
(
aRequest
-
>
mURI
&
equals
)
;
MOZ_ASSERT
(
equals
)
;
}
#
endif
if
(
aRequest
-
>
IsStencil
(
)
)
{
#
ifdef
DEBUG
bool
equals
;
(
void
)
aRequest
-
>
mLoadedScript
-
>
BaseURL
(
)
-
>
Equals
(
aRequest
-
>
mBaseURL
&
equals
)
;
MOZ_ASSERT
(
equals
)
;
#
endif
}
else
{
aRequest
-
>
mLoadedScript
-
>
SetBaseURL
(
aRequest
-
>
mBaseURL
)
;
}
RefPtr
<
ClassicScript
>
classicScript
=
aRequest
-
>
mLoadedScript
-
>
AsClassicScript
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
classicScriptValue
(
cx
JS
:
:
PrivateValue
(
classicScript
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
JS
:
:
Rooted
<
JSScript
*
>
introductionScript
(
cx
)
;
nsresult
rv
=
FillCompileOptionsForRequest
(
cx
aRequest
&
options
&
introductionScript
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aRequest
-
>
IsTextSource
(
)
&
&
aRequest
-
>
ScriptTextLength
(
)
<
OffThreadMinimumTextLength
&
&
ShouldApplyDelazifyStrategy
(
aRequest
)
)
{
ApplyDelazifyStrategy
(
&
options
)
;
mTotalFullParseSize
+
=
aRequest
-
>
ScriptTextLength
(
)
>
0
?
static_cast
<
uint32_t
>
(
aRequest
-
>
ScriptTextLength
(
)
)
:
0
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
non
-
on
-
demand
-
only
(
non
-
omt
)
Parsing
Enabled
"
"
for
url
=
%
s
mTotalFullParseSize
=
%
u
"
aRequest
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
mTotalFullParseSize
)
)
;
}
TRACE_FOR_TEST
(
aRequest
"
scriptloader_execute
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
aGlobalObject
-
>
GetGlobalJSObject
(
)
)
;
JSExecutionContext
exec
(
cx
global
options
classicScriptValue
introductionScript
)
;
rv
=
InstantiateClassicScriptFromAny
(
cx
exec
aRequest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
rv
=
=
NS_OK
)
{
JS
:
:
Rooted
<
JSScript
*
>
script
(
cx
exec
.
GetScript
(
)
)
;
MaybePrepareForBytecodeEncodingBeforeExecute
(
aRequest
script
)
;
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Evaluate
Script
"
aRequest
)
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
ScriptExecution
"
JS
MarkerInnerWindowIdFromJSContext
(
cx
)
profilerLabelString
)
;
rv
=
ExecuteCompiledScript
(
cx
exec
classicScript
)
;
}
}
rv
=
MaybePrepareForBytecodeEncodingAfterExecute
(
aRequest
rv
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
ScriptLoader
=
%
p
"
aRequest
this
)
)
;
MaybeTriggerBytecodeEncoding
(
)
;
return
rv
;
}
LoadedScript
*
ScriptLoader
:
:
GetActiveScript
(
JSContext
*
aCx
)
{
JS
:
:
Value
value
=
JS
:
:
GetScriptedCallerPrivate
(
aCx
)
;
if
(
value
.
isUndefined
(
)
)
{
return
nullptr
;
}
return
static_cast
<
LoadedScript
*
>
(
value
.
toPrivate
(
)
)
;
}
void
ScriptLoader
:
:
RegisterForBytecodeEncoding
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT_IF
(
!
aRequest
-
>
IsStencil
(
)
aRequest
-
>
mCacheInfo
)
;
MOZ_ASSERT
(
aRequest
-
>
IsMarkedForBytecodeEncoding
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
mBytecodeEncodingQueue
.
AppendElement
(
aRequest
)
;
}
void
ScriptLoader
:
:
LoadEventFired
(
)
{
mLoadEventFired
=
true
;
MaybeTriggerBytecodeEncoding
(
)
;
if
(
!
mMainThreadParseTime
.
IsZero
(
)
)
{
glean
:
:
javascript_pageload
:
:
parse_time
.
AccumulateRawDuration
(
mMainThreadParseTime
)
;
}
}
void
ScriptLoader
:
:
Destroy
(
)
{
if
(
mShutdownObserver
)
{
mShutdownObserver
-
>
Unregister
(
)
;
mShutdownObserver
=
nullptr
;
}
CancelAndClearScriptLoadRequests
(
)
;
GiveUpBytecodeEncoding
(
)
;
}
void
ScriptLoader
:
:
MaybeTriggerBytecodeEncoding
(
)
{
if
(
mGiveUpEncoding
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Keep
giving
-
up
bytecode
encoding
.
"
this
)
)
;
GiveUpBytecodeEncoding
(
)
;
return
;
}
if
(
!
mLoadEventFired
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Wait
for
the
load
-
end
event
to
fire
.
"
this
)
)
;
return
;
}
if
(
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
No
script
in
queue
to
be
encoded
.
"
this
)
)
;
return
;
}
if
(
HasPendingRequests
(
)
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Wait
for
other
pending
request
to
finish
.
"
this
)
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
encoder
=
NewRunnableMethod
(
"
ScriptLoader
:
:
EncodeBytecode
"
this
&
ScriptLoader
:
:
EncodeBytecode
)
;
if
(
NS_FAILED
(
NS_DispatchToCurrentThreadQueue
(
encoder
.
forget
(
)
EventQueuePriority
:
:
Idle
)
)
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Schedule
bytecode
encoding
.
"
this
)
)
;
}
void
ScriptLoader
:
:
EncodeBytecode
(
)
{
LOG
(
(
"
ScriptLoader
(
%
p
)
:
Start
bytecode
encoding
.
"
this
)
)
;
if
(
HasPendingRequests
(
)
)
{
return
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
AutoEntryScript
aes
(
globalObject
"
encode
bytecode
"
true
)
;
RefPtr
<
ScriptLoadRequest
>
request
;
while
(
!
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
request
=
mBytecodeEncodingQueue
.
StealFirst
(
)
;
MOZ_ASSERT
(
!
IsWebExtensionRequest
(
request
)
"
Bytecode
for
web
extension
content
scrips
is
not
cached
"
)
;
EncodeRequestBytecode
(
aes
.
cx
(
)
request
)
;
request
-
>
DropBytecode
(
)
;
request
-
>
DropBytecodeCacheReferences
(
)
;
}
}
void
ScriptLoader
:
:
EncodeRequestBytecode
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
nsresult
rv
=
NS_OK
;
MOZ_ASSERT_IF
(
!
aRequest
-
>
IsStencil
(
)
aRequest
-
>
mCacheInfo
)
;
auto
bytecodeFailed
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
TRACE_FOR_TEST_NONE
(
aRequest
"
scriptloader_bytecode_failed
"
)
;
}
)
;
bool
result
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
aRequest
-
>
mScriptForBytecodeEncoding
=
nullptr
;
ModuleScript
*
moduleScript
=
aRequest
-
>
AsModuleRequest
(
)
-
>
mModuleScript
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
moduleScript
-
>
ModuleRecord
(
)
)
;
result
=
JS
:
:
FinishIncrementalEncoding
(
aCx
module
aRequest
-
>
SRIAndBytecode
(
)
)
;
}
else
if
(
mCache
)
{
RefPtr
<
JS
:
:
Stencil
>
stencil
;
JS
:
:
Rooted
<
JSScript
*
>
script
(
aCx
aRequest
-
>
mScriptForBytecodeEncoding
)
;
aRequest
-
>
mScriptForBytecodeEncoding
=
nullptr
;
result
=
JS
:
:
FinishIncrementalEncoding
(
aCx
script
getter_AddRefs
(
stencil
)
)
;
if
(
result
)
{
aRequest
-
>
SetStencil
(
stencil
.
forget
(
)
)
;
bytecodeFailed
.
release
(
)
;
return
;
}
}
else
{
JS
:
:
Rooted
<
JSScript
*
>
script
(
aCx
aRequest
-
>
mScriptForBytecodeEncoding
)
;
result
=
JS
:
:
FinishIncrementalEncoding
(
aCx
script
aRequest
-
>
SRIAndBytecode
(
)
)
;
aRequest
-
>
mScriptForBytecodeEncoding
=
nullptr
;
}
if
(
!
result
)
{
JS_ClearPendingException
(
aCx
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
serialize
bytecode
"
aRequest
)
)
;
return
;
}
Vector
<
uint8_t
>
compressedBytecode
;
if
(
!
ScriptBytecodeCompress
(
aRequest
-
>
SRIAndBytecode
(
)
aRequest
-
>
GetSRILength
(
)
compressedBytecode
)
)
{
return
;
}
if
(
compressedBytecode
.
length
(
)
>
=
UINT32_MAX
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
cache
is
too
large
to
be
decoded
"
"
correctly
.
"
aRequest
)
)
;
return
;
}
nsCOMPtr
<
nsIAsyncOutputStream
>
output
;
rv
=
aRequest
-
>
mCacheInfo
-
>
OpenAlternativeOutputStream
(
BytecodeMimeTypeFor
(
aRequest
)
static_cast
<
int64_t
>
(
compressedBytecode
.
length
(
)
)
getter_AddRefs
(
output
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
open
bytecode
cache
(
rv
=
%
X
output
"
"
=
%
p
)
"
aRequest
unsigned
(
rv
)
output
.
get
(
)
)
)
;
return
;
}
MOZ_ASSERT
(
output
)
;
auto
closeOutStream
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
rv
=
output
-
>
CloseWithStatus
(
rv
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Closing
(
rv
=
%
X
)
"
aRequest
unsigned
(
rv
)
)
)
;
}
)
;
uint32_t
n
;
rv
=
output
-
>
Write
(
reinterpret_cast
<
char
*
>
(
compressedBytecode
.
begin
(
)
)
compressedBytecode
.
length
(
)
&
n
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Write
bytecode
cache
(
rv
=
%
X
length
=
%
u
"
"
written
=
%
u
)
"
aRequest
unsigned
(
rv
)
unsigned
(
compressedBytecode
.
length
(
)
)
n
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
compressedBytecode
.
length
(
)
=
=
n
)
;
bytecodeFailed
.
release
(
)
;
TRACE_FOR_TEST_NONE
(
aRequest
"
scriptloader_bytecode_saved
"
)
;
}
void
ScriptLoader
:
:
GiveUpBytecodeEncoding
(
)
{
mGiveUpEncoding
=
true
;
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
AutoAllowLegacyScriptExecution
exemption
;
Maybe
<
AutoEntryScript
>
aes
;
if
(
globalObject
)
{
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
context
)
{
aes
.
emplace
(
globalObject
"
give
-
up
bytecode
encoding
"
true
)
;
}
}
while
(
!
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
request
=
mBytecodeEncodingQueue
.
StealFirst
(
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
serialize
bytecode
"
request
.
get
(
)
)
)
;
TRACE_FOR_TEST_NONE
(
request
"
scriptloader_bytecode_failed
"
)
;
MOZ_ASSERT
(
!
IsWebExtensionRequest
(
request
)
)
;
if
(
aes
.
isSome
(
)
)
{
if
(
request
-
>
IsModuleRequest
(
)
)
{
ModuleScript
*
moduleScript
=
request
-
>
AsModuleRequest
(
)
-
>
mModuleScript
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
aes
-
>
cx
(
)
moduleScript
-
>
ModuleRecord
(
)
)
;
JS
:
:
AbortIncrementalEncoding
(
module
)
;
}
else
{
JS
:
:
Rooted
<
JSScript
*
>
script
(
aes
-
>
cx
(
)
request
-
>
mScriptForBytecodeEncoding
)
;
request
-
>
mScriptForBytecodeEncoding
=
nullptr
;
JS
:
:
AbortIncrementalEncoding
(
script
)
;
}
}
request
-
>
DropBytecode
(
)
;
request
-
>
DropBytecodeCacheReferences
(
)
;
}
}
bool
ScriptLoader
:
:
HasPendingRequests
(
)
const
{
return
mParserBlockingRequest
|
|
!
mXSLTRequests
.
isEmpty
(
)
|
|
!
mLoadedAsyncRequests
.
isEmpty
(
)
|
|
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
|
|
!
mDeferRequests
.
isEmpty
(
)
|
|
HasPendingDynamicImports
(
)
|
|
!
mPendingChildLoaders
.
IsEmpty
(
)
;
}
bool
ScriptLoader
:
:
HasPendingDynamicImports
(
)
const
{
if
(
mModuleLoader
&
&
mModuleLoader
-
>
HasPendingDynamicImports
(
)
)
{
return
true
;
}
for
(
ModuleLoader
*
loader
:
mWebExtModuleLoaders
)
{
if
(
loader
-
>
HasPendingDynamicImports
(
)
)
{
return
true
;
}
}
for
(
ModuleLoader
*
loader
:
mShadowRealmModuleLoaders
)
{
if
(
loader
-
>
HasPendingDynamicImports
(
)
)
{
return
true
;
}
}
return
false
;
}
void
ScriptLoader
:
:
ProcessPendingRequestsAsync
(
)
{
if
(
HasPendingRequests
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NewRunnableMethod
<
bool
>
(
"
dom
:
:
ScriptLoader
:
:
ProcessPendingRequests
"
this
&
ScriptLoader
:
:
ProcessPendingRequests
false
)
;
if
(
mDocument
)
{
mDocument
-
>
Dispatch
(
task
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
task
.
forget
(
)
)
;
}
}
}
void
ProcessPendingRequestsCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
ScriptLoader
>
sl
=
static_cast
<
ScriptLoader
*
>
(
aClosure
)
;
sl
-
>
ProcessPendingRequests
(
true
)
;
}
void
ScriptLoader
:
:
ProcessPendingRequestsAsyncBypassParserBlocking
(
)
{
MOZ_ASSERT
(
HasPendingRequests
(
)
)
;
if
(
!
mProcessPendingRequestsAsyncBypassParserBlocking
)
{
mProcessPendingRequestsAsyncBypassParserBlocking
=
NS_NewTimer
(
)
;
}
mProcessPendingRequestsAsyncBypassParserBlocking
-
>
InitWithNamedFuncCallback
(
ProcessPendingRequestsCallback
this
2500
nsITimer
:
:
TYPE_ONE_SHOT
"
ProcessPendingRequestsAsyncBypassParserBlocking
"
)
;
}
void
ScriptLoader
:
:
ProcessPendingRequests
(
bool
aAllowBypassingParserBlocking
)
{
RefPtr
<
ScriptLoadRequest
>
request
;
if
(
mProcessPendingRequestsAsyncBypassParserBlocking
)
{
mProcessPendingRequestsAsyncBypassParserBlocking
-
>
Cancel
(
)
;
}
if
(
mParserBlockingRequest
)
{
if
(
mParserBlockingRequest
-
>
IsFinished
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
request
.
swap
(
mParserBlockingRequest
)
;
UnblockParser
(
request
)
;
ProcessRequest
(
request
)
;
ContinueParserAsync
(
request
)
;
ProcessPendingRequestsAsync
(
)
;
return
;
}
if
(
!
aAllowBypassingParserBlocking
)
{
ProcessPendingRequestsAsyncBypassParserBlocking
(
)
;
return
;
}
}
while
(
ReadyToExecuteParserBlockingScripts
(
)
&
&
!
mXSLTRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
getFirst
(
)
-
>
IsFinished
(
)
)
{
request
=
mXSLTRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mLoadedAsyncRequests
.
isEmpty
(
)
)
{
request
=
mLoadedAsyncRequests
.
StealFirst
(
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
ProcessRequest
(
request
)
;
}
else
{
CompileOffThreadOrProcessRequest
(
request
)
;
}
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
-
>
IsFinished
(
)
)
{
request
=
mNonAsyncExternalScriptInsertedRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
if
(
mDeferCheckpointReached
&
&
mXSLTRequests
.
isEmpty
(
)
)
{
while
(
ReadyToExecuteScripts
(
)
&
&
!
mDeferRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
getFirst
(
)
-
>
IsFinished
(
)
)
{
request
=
mDeferRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
}
while
(
!
mPendingChildLoaders
.
IsEmpty
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
RefPtr
<
ScriptLoader
>
child
=
mPendingChildLoaders
[
0
]
;
mPendingChildLoaders
.
RemoveElementAt
(
0
)
;
child
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
if
(
mDeferCheckpointReached
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
&
&
MaybeRemovedDeferRequests
(
)
)
{
return
ProcessPendingRequests
(
)
;
}
if
(
mDeferCheckpointReached
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mLoadingAsyncRequests
.
isEmpty
(
)
&
&
mLoadedAsyncRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
)
{
mDeferCheckpointReached
=
false
;
mDocument
-
>
UnblockOnload
(
true
)
;
}
}
bool
ScriptLoader
:
:
ReadyToExecuteParserBlockingScripts
(
)
{
if
(
!
SelfReadyToExecuteParserBlockingScripts
(
)
)
{
return
false
;
}
if
(
mDocument
&
&
mDocument
-
>
GetWindowContext
(
)
)
{
for
(
WindowContext
*
wc
=
mDocument
-
>
GetWindowContext
(
)
-
>
GetParentWindowContext
(
)
;
wc
;
wc
=
wc
-
>
GetParentWindowContext
(
)
)
{
if
(
Document
*
doc
=
wc
-
>
GetDocument
(
)
)
{
ScriptLoader
*
ancestor
=
doc
-
>
ScriptLoader
(
)
;
if
(
!
ancestor
-
>
SelfReadyToExecuteParserBlockingScripts
(
)
&
&
ancestor
-
>
AddPendingChildLoader
(
this
)
)
{
AddParserBlockingScriptExecutionBlocker
(
)
;
return
false
;
}
}
}
}
return
true
;
}
template
<
typename
Unit
>
static
nsresult
ConvertToUnicode
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
Document
*
aDocument
Unit
*
&
aBufOut
size_t
&
aLengthOut
)
{
if
(
!
aLength
)
{
aBufOut
=
nullptr
;
aLengthOut
=
0
;
return
NS_OK
;
}
auto
data
=
Span
(
aData
aLength
)
;
UniquePtr
<
Decoder
>
unicodeDecoder
;
const
Encoding
*
encoding
;
std
:
:
tie
(
encoding
std
:
:
ignore
)
=
Encoding
:
:
ForBOM
(
data
)
;
if
(
encoding
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithBOMRemoval
(
)
;
}
if
(
!
unicodeDecoder
&
&
aChannel
)
{
nsAutoCString
label
;
if
(
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
label
)
)
&
&
(
encoding
=
Encoding
:
:
ForLabel
(
label
)
)
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
}
if
(
!
unicodeDecoder
&
&
(
encoding
=
Encoding
:
:
ForLabel
(
aHintCharset
)
)
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
if
(
!
unicodeDecoder
&
&
aDocument
)
{
unicodeDecoder
=
aDocument
-
>
GetDocumentCharacterSet
(
)
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
if
(
!
unicodeDecoder
)
{
unicodeDecoder
=
WINDOWS_1252_ENCODING
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
auto
signalOOM
=
mozilla
:
:
MakeScopeExit
(
[
&
aBufOut
&
aLengthOut
]
(
)
{
aBufOut
=
nullptr
;
aLengthOut
=
0
;
}
)
;
CheckedInt
<
size_t
>
bufferLength
=
ScriptDecoding
<
Unit
>
:
:
MaxBufferLength
(
unicodeDecoder
aLength
)
;
if
(
!
bufferLength
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
CheckedInt
<
size_t
>
bufferByteSize
=
bufferLength
*
sizeof
(
Unit
)
;
if
(
!
bufferByteSize
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aBufOut
=
static_cast
<
Unit
*
>
(
js_malloc
(
bufferByteSize
.
value
(
)
)
)
;
if
(
!
aBufOut
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
signalOOM
.
release
(
)
;
aLengthOut
=
ScriptDecoding
<
Unit
>
:
:
DecodeInto
(
unicodeDecoder
data
Span
(
aBufOut
bufferLength
.
value
(
)
)
true
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
ConvertToUTF16
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
Document
*
aDocument
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
&
aBufOut
size_t
&
aLengthOut
)
{
char16_t
*
bufOut
;
nsresult
rv
=
ConvertToUnicode
(
aChannel
aData
aLength
aHintCharset
aDocument
bufOut
aLengthOut
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aBufOut
.
reset
(
bufOut
)
;
}
return
rv
;
}
nsresult
ScriptLoader
:
:
ConvertToUTF8
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
Document
*
aDocument
UniquePtr
<
Utf8Unit
[
]
JS
:
:
FreePolicy
>
&
aBufOut
size_t
&
aLengthOut
)
{
Utf8Unit
*
bufOut
;
nsresult
rv
=
ConvertToUnicode
(
aChannel
aData
aLength
aHintCharset
aDocument
bufOut
aLengthOut
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aBufOut
.
reset
(
bufOut
)
;
}
return
rv
;
}
nsresult
ScriptLoader
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
ScriptLoadRequest
*
aRequest
nsresult
aChannelStatus
nsresult
aSRIStatus
SRICheckDataVerifier
*
aSRIDataVerifier
)
{
NS_ASSERTION
(
aRequest
"
null
request
in
stream
complete
handler
"
)
;
NS_ENSURE_TRUE
(
aRequest
NS_ERROR_FAILURE
)
;
nsresult
rv
=
VerifySRI
(
aRequest
aLoader
aSRIStatus
aSRIDataVerifier
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
aRequest
-
>
IsSource
(
)
)
{
rv
=
SaveSRIHash
(
aRequest
aSRIDataVerifier
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
PrepareLoadedRequest
(
aRequest
aLoader
aChannelStatus
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
ReportErrorToConsole
(
aRequest
rv
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
aChannelStatus
!
=
NS_BINDING_RETARGETED
)
{
HandleLoadError
(
aRequest
rv
)
;
}
}
ProcessPendingRequests
(
)
;
return
rv
;
}
nsresult
ScriptLoader
:
:
VerifySRI
(
ScriptLoadRequest
*
aRequest
nsIIncrementalStreamLoader
*
aLoader
nsresult
aSRIStatus
SRICheckDataVerifier
*
aSRIDataVerifier
)
const
{
nsCOMPtr
<
nsIRequest
>
channelRequest
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channelRequest
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
channel
=
do_QueryInterface
(
channelRequest
)
;
nsresult
rv
=
NS_OK
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
&
&
NS_SUCCEEDED
(
(
rv
=
aSRIStatus
)
)
)
{
MOZ_ASSERT
(
aSRIDataVerifier
)
;
MOZ_ASSERT
(
mReporter
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
rv
=
aSRIDataVerifier
-
>
Verify
(
aRequest
-
>
mIntegrity
channel
sourceUri
mReporter
)
;
if
(
channelRequest
)
{
mReporter
-
>
FlushReportsToConsole
(
nsContentUtils
:
:
GetInnerWindowID
(
channelRequest
)
)
;
}
else
{
mReporter
-
>
FlushConsoleReports
(
mDocument
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_ERROR_SRI_CORRUPT
;
}
}
return
rv
;
}
nsresult
ScriptLoader
:
:
SaveSRIHash
(
ScriptLoadRequest
*
aRequest
SRICheckDataVerifier
*
aSRIDataVerifier
)
const
{
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
JS
:
:
TranscodeBuffer
&
bytecode
=
aRequest
-
>
SRIAndBytecode
(
)
;
MOZ_ASSERT
(
bytecode
.
empty
(
)
)
;
uint32_t
len
=
0
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
&
&
aSRIDataVerifier
-
>
IsComplete
(
)
)
{
MOZ_ASSERT
(
bytecode
.
length
(
)
=
=
0
)
;
len
=
aSRIDataVerifier
-
>
DataSummaryLength
(
)
;
if
(
!
bytecode
.
resize
(
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
DebugOnly
<
nsresult
>
res
=
aSRIDataVerifier
-
>
ExportDataSummary
(
len
bytecode
.
begin
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
res
)
)
;
}
else
{
MOZ_ASSERT
(
bytecode
.
length
(
)
=
=
0
)
;
len
=
SRICheckDataVerifier
:
:
EmptyDataSummaryLength
(
)
;
if
(
!
bytecode
.
resize
(
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
DebugOnly
<
nsresult
>
res
=
SRICheckDataVerifier
:
:
ExportEmptyDataSummary
(
len
bytecode
.
begin
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
res
)
)
;
}
DebugOnly
<
uint32_t
>
srilen
{
}
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
SRICheckDataVerifier
:
:
DataSummaryLength
(
len
bytecode
.
begin
(
)
&
srilen
)
)
)
;
MOZ_ASSERT
(
srilen
=
=
len
)
;
MOZ_ASSERT
(
bytecode
.
length
(
)
=
=
len
)
;
aRequest
-
>
SetSRILength
(
len
)
;
if
(
aRequest
-
>
GetSRILength
(
)
!
=
len
)
{
if
(
!
bytecode
.
resize
(
aRequest
-
>
GetSRILength
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
return
NS_OK
;
}
void
ScriptLoader
:
:
ReportErrorToConsole
(
ScriptLoadRequest
*
aRequest
nsresult
aResult
)
const
{
MOZ_ASSERT
(
aRequest
)
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsPreload
(
)
)
{
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mUnreportedPreloadError
=
aResult
;
return
;
}
bool
isScript
=
!
aRequest
-
>
IsModuleRequest
(
)
;
const
char
*
message
;
if
(
aResult
=
=
NS_ERROR_MALFORMED_URI
)
{
message
=
isScript
?
"
ScriptSourceMalformed
"
:
"
ModuleSourceMalformed
"
;
}
else
if
(
aResult
=
=
NS_ERROR_DOM_BAD_URI
)
{
message
=
isScript
?
"
ScriptSourceNotAllowed
"
:
"
ModuleSourceNotAllowed
"
;
}
else
if
(
aResult
=
=
NS_ERROR_DOM_WEBEXT_CONTENT_SCRIPT_URI
)
{
MOZ_ASSERT
(
!
isScript
)
;
message
=
"
WebExtContentScriptModuleSourceNotAllowed
"
;
}
else
if
(
net
:
:
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aResult
)
)
{
return
;
}
else
{
message
=
isScript
?
"
ScriptSourceLoadFailed
"
:
"
ModuleSourceLoadFailed
"
;
}
AutoTArray
<
nsString
1
>
params
;
CopyUTF8toUTF16
(
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
*
params
.
AppendElement
(
)
)
;
uint32_t
lineNo
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptLineNumber
(
)
;
JS
:
:
ColumnNumberOneOrigin
columnNo
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptColumnNumber
(
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Script
Loader
"
_ns
mDocument
nsContentUtils
:
:
eDOM_PROPERTIES
message
params
SourceLocation
{
mDocument
-
>
GetDocumentURI
(
)
lineNo
columnNo
.
oneOriginValue
(
)
}
)
;
}
void
ScriptLoader
:
:
ReportWarningToConsole
(
ScriptLoadRequest
*
aRequest
const
char
*
aMessageName
const
nsTArray
<
nsString
>
&
aParams
)
const
{
uint32_t
lineNo
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptLineNumber
(
)
;
JS
:
:
ColumnNumberOneOrigin
columnNo
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptColumnNumber
(
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Script
Loader
"
_ns
mDocument
nsContentUtils
:
:
eDOM_PROPERTIES
aMessageName
aParams
SourceLocation
{
mDocument
-
>
GetDocumentURI
(
)
lineNo
columnNo
.
oneOriginValue
(
)
}
)
;
}
void
ScriptLoader
:
:
ReportPreloadErrorsToConsole
(
ScriptLoadRequest
*
aRequest
)
{
if
(
NS_FAILED
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mUnreportedPreloadError
)
)
{
ReportErrorToConsole
(
aRequest
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mUnreportedPreloadError
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mUnreportedPreloadError
=
NS_OK
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
for
(
const
auto
&
childRequest
:
aRequest
-
>
AsModuleRequest
(
)
-
>
mImports
)
{
ReportPreloadErrorsToConsole
(
childRequest
)
;
}
}
}
void
ScriptLoader
:
:
HandleLoadError
(
ScriptLoadRequest
*
aRequest
nsresult
aResult
)
{
if
(
net
:
:
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aResult
)
)
{
nsCOMPtr
<
nsIContent
>
cont
=
do_QueryInterface
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForUrlClassifier
(
)
)
;
mDocument
-
>
AddBlockedNodeByClassifier
(
cont
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
)
;
aRequest
-
>
AsModuleRequest
(
)
-
>
OnFetchComplete
(
aResult
)
;
}
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInDeferList
)
{
MOZ_ASSERT_IF
(
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mDeferRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInAsyncList
)
{
MOZ_ASSERT_IF
(
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsNonAsyncScriptInserted
)
{
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mNonAsyncExternalScriptInsertedRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsXSLT
)
{
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mXSLTRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
aResult
req
)
;
}
}
else
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsPreload
(
)
)
{
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
aRequest
-
>
Cancel
(
)
;
}
if
(
aRequest
-
>
IsTopLevel
(
)
)
{
mPreloads
.
RemoveElement
(
aRequest
PreloadRequestComparator
(
)
)
;
}
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
}
else
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
modReq
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
modReq
-
>
IsDynamicImport
(
)
)
{
MOZ_ASSERT
(
modReq
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
modReq
-
>
CancelDynamicImport
(
aResult
)
;
}
}
else
{
MOZ_ASSERT
(
!
modReq
-
>
isInList
(
)
)
;
modReq
-
>
Cancel
(
)
;
}
}
else
if
(
mParserBlockingRequest
=
=
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
aRequest
)
;
MOZ_ASSERT
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetParserCreated
(
)
)
;
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
GetScriptLoadContext
(
)
-
>
GetScriptElementForCurrentParserInsertedScript
(
)
;
FireScriptAvailable
(
aResult
aRequest
)
;
ContinueParserAsync
(
aRequest
)
;
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsCanceled
(
)
|
|
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
}
}
void
ScriptLoader
:
:
UnblockParser
(
ScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
GetScriptLoadContext
(
)
-
>
UnblockParser
(
)
;
}
void
ScriptLoader
:
:
ContinueParserAsync
(
ScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
GetScriptLoadContext
(
)
-
>
ContinueParserAsync
(
)
;
}
uint32_t
ScriptLoader
:
:
NumberOfProcessors
(
)
{
if
(
mNumberOfProcessors
>
0
)
{
return
mNumberOfProcessors
;
}
int32_t
numProcs
=
PR_GetNumberOfProcessors
(
)
;
if
(
numProcs
>
0
)
{
mNumberOfProcessors
=
numProcs
;
}
return
mNumberOfProcessors
;
}
int32_t
ScriptLoader
:
:
PhysicalSizeOfMemoryInGB
(
)
{
if
(
mPhysicalSizeOfMemory
>
=
0
)
{
return
mPhysicalSizeOfMemory
;
}
mPhysicalSizeOfMemory
=
static_cast
<
int32_t
>
(
PR_GetPhysicalMemorySize
(
)
>
>
30
)
;
return
mPhysicalSizeOfMemory
;
}
bool
ScriptLoader
:
:
ShouldApplyDelazifyStrategy
(
ScriptLoadRequest
*
aRequest
)
{
if
(
StaticPrefs
:
:
dom_script_loader_delazification_max_size
(
)
<
0
)
{
return
true
;
}
if
(
PhysicalSizeOfMemoryInGB
(
)
<
=
StaticPrefs
:
:
dom_script_loader_delazification_min_mem
(
)
)
{
return
false
;
}
uint32_t
max_size
=
static_cast
<
uint32_t
>
(
StaticPrefs
:
:
dom_script_loader_delazification_max_size
(
)
)
;
uint32_t
script_size
=
aRequest
-
>
ScriptTextLength
(
)
>
0
?
static_cast
<
uint32_t
>
(
aRequest
-
>
ScriptTextLength
(
)
)
:
0
;
if
(
mTotalFullParseSize
+
script_size
<
max_size
)
{
return
true
;
}
if
(
LOG_ENABLED
(
)
)
{
nsCString
url
=
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
non
-
on
-
demand
-
only
Parsing
Disabled
for
(
%
s
)
"
"
with
size
=
%
u
because
mTotalFullParseSize
=
%
u
would
exceed
max_size
=
%
u
"
aRequest
url
.
get
(
)
script_size
mTotalFullParseSize
max_size
)
)
;
}
return
false
;
}
void
ScriptLoader
:
:
ApplyDelazifyStrategy
(
JS
:
:
CompileOptions
*
aOptions
)
{
JS
:
:
DelazificationOption
strategy
=
JS
:
:
DelazificationOption
:
:
ParseEverythingEagerly
;
uint32_t
strategyIndex
=
StaticPrefs
:
:
dom_script_loader_delazification_strategy
(
)
;
#
ifdef
DEBUG
uint32_t
count
=
0
;
uint32_t
mask
=
0
;
#
define
_COUNT_ENTRIES
(
Name
)
count
+
+
;
#
define
_MASK_ENTRIES
(
Name
)
\
mask
|
=
1
<
<
uint32_t
(
JS
:
:
DelazificationOption
:
:
Name
)
;
FOREACH_DELAZIFICATION_STRATEGY
(
_COUNT_ENTRIES
)
;
MOZ_ASSERT
(
count
=
=
uint32_t
(
strategy
)
+
1
)
;
FOREACH_DELAZIFICATION_STRATEGY
(
_MASK_ENTRIES
)
;
MOZ_ASSERT
(
(
(
mask
+
1
)
&
mask
)
=
=
0
)
;
#
undef
_COUNT_ENTRIES
#
undef
_MASK_ENTRIES
#
endif
if
(
strategyIndex
<
=
uint32_t
(
strategy
)
)
{
strategy
=
JS
:
:
DelazificationOption
(
uint8_t
(
strategyIndex
)
)
;
}
aOptions
-
>
setEagerDelazificationStrategy
(
strategy
)
;
}
bool
ScriptLoader
:
:
ShouldCompileOffThread
(
ScriptLoadRequest
*
aRequest
)
{
if
(
NumberOfProcessors
(
)
<
=
1
)
{
return
false
;
}
if
(
aRequest
=
=
mParserBlockingRequest
)
{
return
true
;
}
if
(
SpeculativeOMTParsingEnabled
(
)
)
{
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mIsNonAsyncScriptInserted
&
&
!
StaticPrefs
:
:
dom_script_loader_external_scripts_speculate_non_parser_inserted_enabled
(
)
)
{
return
false
;
}
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsAsyncScript
(
)
&
&
!
StaticPrefs
:
:
dom_script_loader_external_scripts_speculate_async_enabled
(
)
)
{
return
false
;
}
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsLinkPreloadScript
(
)
&
&
!
StaticPrefs
:
:
dom_script_loader_external_scripts_speculate_link_preload_enabled
(
)
)
{
return
false
;
}
return
true
;
}
return
false
;
}
static
bool
MimeTypeMatchesExpectedModuleType
(
nsIChannel
*
aChannel
JS
:
:
ModuleType
expectedModuleType
)
{
nsAutoCString
mimeType
;
aChannel
-
>
GetContentType
(
mimeType
)
;
NS_ConvertUTF8toUTF16
typeString
(
mimeType
)
;
if
(
expectedModuleType
=
=
JS
:
:
ModuleType
:
:
JavaScript
&
&
nsContentUtils
:
:
IsJavascriptMIMEType
(
typeString
)
)
{
return
true
;
}
if
(
expectedModuleType
=
=
JS
:
:
ModuleType
:
:
JSON
&
&
nsContentUtils
:
:
IsJsonMimeType
(
typeString
)
)
{
return
true
;
}
return
false
;
}
nsresult
ScriptLoader
:
:
PrepareLoadedRequest
(
ScriptLoadRequest
*
aRequest
nsIIncrementalStreamLoader
*
aLoader
nsresult
aStatus
)
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
aStatus
;
}
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
NS_BINDING_ABORTED
;
}
MOZ_ASSERT
(
aRequest
-
>
IsFetching
(
)
)
;
CollectScriptTelemetry
(
aRequest
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
req
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
rv
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
requestSucceeded
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ReferrerPolicy
policy
=
nsContentUtils
:
:
GetReferrerPolicyFromChannel
(
httpChannel
)
;
if
(
policy
!
=
ReferrerPolicy
:
:
_empty
)
{
aRequest
-
>
UpdateReferrerPolicy
(
policy
)
;
}
}
nsAutoCString
sourceMapURL
;
if
(
nsContentUtils
:
:
GetSourceMapURL
(
httpChannel
sourceMapURL
)
)
{
aRequest
-
>
mSourceMapURL
=
Some
(
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
)
;
}
nsCOMPtr
<
nsIClassifiedChannel
>
classifiedChannel
=
do_QueryInterface
(
req
)
;
MOZ_ASSERT
(
classifiedChannel
)
;
if
(
classifiedChannel
&
&
classifiedChannel
-
>
IsThirdPartyTrackingResource
(
)
)
{
aRequest
-
>
GetScriptLoadContext
(
)
-
>
SetIsTracking
(
)
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
!
aRequest
-
>
IsModuleRequest
(
)
&
&
aRequest
-
>
CORSMode
(
)
=
=
CORS_NONE
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
aRequest
-
>
mOriginPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ASSERTION
(
mDeferRequests
.
Contains
(
aRequest
)
|
|
mLoadingAsyncRequests
.
Contains
(
aRequest
)
|
|
mNonAsyncExternalScriptInsertedRequests
.
Contains
(
aRequest
)
|
|
mXSLTRequests
.
Contains
(
aRequest
)
|
|
(
aRequest
-
>
IsModuleRequest
(
)
&
&
(
aRequest
-
>
AsModuleRequest
(
)
-
>
IsRegisteredDynamicImport
(
)
|
|
!
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
)
|
|
mPreloads
.
Contains
(
aRequest
PreloadRequestComparator
(
)
)
|
|
mParserBlockingRequest
=
=
aRequest
"
aRequest
should
be
pending
!
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
channel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aRequest
-
>
SetBaseURLFromChannelAndOriginalURI
(
channel
uri
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
!
MimeTypeMatchesExpectedModuleType
(
channel
request
-
>
mModuleType
)
)
{
return
NS_ERROR_FAILURE
;
}
bool
couldCompile
=
false
;
rv
=
AttemptOffThreadScriptCompile
(
request
&
couldCompile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
couldCompile
)
{
return
NS_OK
;
}
return
request
-
>
OnFetchComplete
(
NS_OK
)
;
}
aRequest
-
>
SetReady
(
)
;
if
(
ShouldCompileOffThread
(
aRequest
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
bool
couldCompile
=
false
;
nsresult
rv
=
AttemptOffThreadScriptCompile
(
aRequest
&
couldCompile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
couldCompile
)
{
MOZ_ASSERT
(
aRequest
-
>
mState
=
=
ScriptLoadRequest
:
:
State
:
:
Compiling
"
Request
should
be
off
-
thread
compiling
now
.
"
)
;
return
NS_OK
;
}
}
MaybeMoveToLoadedList
(
aRequest
)
;
return
NS_OK
;
}
void
ScriptLoader
:
:
DeferCheckpointReached
(
)
{
if
(
mDeferEnabled
)
{
mDeferCheckpointReached
=
true
;
}
mDeferEnabled
=
false
;
ProcessPendingRequests
(
)
;
}
void
ScriptLoader
:
:
ParsingComplete
(
bool
aTerminated
)
{
if
(
aTerminated
)
{
CancelAndClearScriptLoadRequests
(
)
;
DeferCheckpointReached
(
)
;
}
}
void
ScriptLoader
:
:
PreloadURI
(
nsIURI
*
aURI
const
nsAString
&
aCharset
const
nsAString
&
aType
const
nsAString
&
aCrossOrigin
const
nsAString
&
aNonce
const
nsAString
&
aFetchPriority
const
nsAString
&
aIntegrity
bool
aScriptFromHead
bool
aAsync
bool
aDefer
bool
aLinkPreload
const
ReferrerPolicy
aReferrerPolicy
uint64_t
aEarlyHintPreloaderId
)
{
NS_ENSURE_TRUE_VOID
(
mDocument
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
;
}
ScriptKind
scriptKind
=
ScriptKind
:
:
eClassic
;
static
const
char
kASCIIWhitespace
[
]
=
"
\
t
\
n
\
f
\
r
"
;
nsAutoString
type
(
aType
)
;
type
.
Trim
(
kASCIIWhitespace
)
;
if
(
type
.
LowerCaseEqualsASCII
(
"
module
"
)
)
{
scriptKind
=
ScriptKind
:
:
eModule
;
}
if
(
scriptKind
=
=
ScriptKind
:
:
eClassic
&
&
!
aType
.
IsEmpty
(
)
&
&
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
aType
)
)
{
return
;
}
SRIMetadata
sriMetadata
;
GetSRIMetadata
(
aIntegrity
&
sriMetadata
)
;
const
auto
requestPriority
=
FetchPriorityToRequestPriority
(
nsGenericHTMLElement
:
:
ToFetchPriority
(
aFetchPriority
)
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
CreateLoadRequest
(
scriptKind
aURI
nullptr
mDocument
-
>
NodePrincipal
(
)
Element
:
:
StringToCORSMode
(
aCrossOrigin
)
aNonce
requestPriority
sriMetadata
aReferrerPolicy
aLinkPreload
?
ParserMetadata
:
:
NotParserInserted
:
ParserMetadata
:
:
ParserInserted
RequestType
:
:
Preload
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
mIsInline
=
false
;
request
-
>
GetScriptLoadContext
(
)
-
>
mScriptFromHead
=
aScriptFromHead
;
request
-
>
GetScriptLoadContext
(
)
-
>
SetScriptMode
(
aDefer
aAsync
aLinkPreload
)
;
request
-
>
GetScriptLoadContext
(
)
-
>
SetIsPreloadRequest
(
)
;
request
-
>
mEarlyHintPreloaderId
=
aEarlyHintPreloaderId
;
if
(
LOG_ENABLED
(
)
)
{
nsAutoCString
url
;
aURI
-
>
GetAsciiSpec
(
url
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Created
preload
request
for
%
s
"
request
.
get
(
)
url
.
get
(
)
)
)
;
}
nsAutoString
charset
(
aCharset
)
;
nsresult
rv
=
StartLoad
(
request
Some
(
charset
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
PreloadInfo
*
pi
=
mPreloads
.
AppendElement
(
)
;
pi
-
>
mRequest
=
request
;
pi
-
>
mCharset
=
aCharset
;
}
void
ScriptLoader
:
:
AddDeferRequest
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsDeferredScript
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInDeferList
&
&
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInAsyncList
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInCompilingList
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInDeferList
=
true
;
mDeferRequests
.
AppendElement
(
aRequest
)
;
if
(
mDeferEnabled
&
&
aRequest
=
=
mDeferRequests
.
getFirst
(
)
&
&
mDocument
&
&
!
mBlockingDOMContentLoaded
)
{
MOZ_ASSERT
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_LOADING
)
;
mBlockingDOMContentLoaded
=
true
;
mDocument
-
>
BlockDOMContentLoaded
(
)
;
}
}
void
ScriptLoader
:
:
AddAsyncRequest
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
IsAsyncScript
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInDeferList
&
&
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInAsyncList
)
;
MOZ_ASSERT
(
!
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInCompilingList
)
;
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInAsyncList
=
true
;
if
(
aRequest
-
>
IsFinished
(
)
)
{
mLoadedAsyncRequests
.
AppendElement
(
aRequest
)
;
}
else
{
mLoadingAsyncRequests
.
AppendElement
(
aRequest
)
;
}
}
void
ScriptLoader
:
:
MaybeMoveToLoadedList
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsFinished
(
)
)
;
MOZ_ASSERT
(
aRequest
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
GetScriptLoadContext
(
)
-
>
mInAsyncList
)
{
MOZ_ASSERT
(
aRequest
-
>
isInList
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
mLoadedAsyncRequests
.
AppendElement
(
req
)
;
}
}
else
if
(
aRequest
-
>
IsModuleRequest
(
)
&
&
aRequest
-
>
AsModuleRequest
(
)
-
>
IsDynamicImport
(
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
mLoadedAsyncRequests
.
AppendElement
(
aRequest
)
;
}
}
bool
ScriptLoader
:
:
MaybeRemovedDeferRequests
(
)
{
if
(
mDeferRequests
.
isEmpty
(
)
&
&
mDocument
&
&
mBlockingDOMContentLoaded
)
{
mBlockingDOMContentLoaded
=
false
;
mDocument
-
>
UnblockDOMContentLoaded
(
)
;
return
true
;
}
return
false
;
}
DocGroup
*
ScriptLoader
:
:
GetDocGroup
(
)
const
{
return
mDocument
-
>
GetDocGroup
(
)
;
}
void
ScriptLoader
:
:
BeginDeferringScripts
(
)
{
mDeferEnabled
=
true
;
if
(
mDeferCheckpointReached
)
{
mDeferCheckpointReached
=
false
;
}
else
{
if
(
mDocument
)
{
mDocument
-
>
BlockOnload
(
)
;
}
}
}
nsAutoScriptLoaderDisabler
:
:
nsAutoScriptLoaderDisabler
(
Document
*
aDoc
)
{
mLoader
=
aDoc
-
>
ScriptLoader
(
)
;
mWasEnabled
=
mLoader
-
>
GetEnabled
(
)
;
if
(
mWasEnabled
)
{
mLoader
-
>
SetEnabled
(
false
)
;
}
}
nsAutoScriptLoaderDisabler
:
:
~
nsAutoScriptLoaderDisabler
(
)
{
if
(
mWasEnabled
)
{
mLoader
-
>
SetEnabled
(
true
)
;
}
}
#
undef
TRACE_FOR_TEST
#
undef
TRACE_FOR_TEST_BOOL
#
undef
TRACE_FOR_TEST_NONE
#
undef
LOG
}
