#
include
"
ScriptLoader
.
h
"
#
include
"
ScriptLoadHandler
.
h
"
#
include
"
ScriptLoadRequest
.
h
"
#
include
"
ScriptTrace
.
h
"
#
include
"
ModuleLoadRequest
.
h
"
#
include
"
ModuleScript
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
SRILogHelper
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIDOMHTMLScriptElement
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIOutputStream
.
h
"
using
JS
:
:
SourceBufferHolder
;
namespace
mozilla
{
namespace
dom
{
LazyLogModule
ScriptLoader
:
:
gCspPRLog
(
"
CSP
"
)
;
LazyLogModule
ScriptLoader
:
:
gScriptLoaderLog
(
"
ScriptLoader
"
)
;
#
define
LOG
(
args
)
\
MOZ_LOG
(
gScriptLoaderLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
NS_NAMED_LITERAL_CSTRING
(
kNullMimeType
"
javascript
/
null
"
)
;
inline
void
ImplCycleCollectionUnlink
(
ScriptLoader
:
:
PreloadInfo
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mRequest
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ScriptLoader
:
:
PreloadInfo
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mRequest
aName
aFlags
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ScriptLoader
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
ScriptLoader
mNonAsyncExternalScriptInsertedRequests
mLoadingAsyncRequests
mLoadedAsyncRequests
mDeferRequests
mXSLTRequests
mParserBlockingRequest
mPreloads
mPendingChildLoaders
mFetchedModules
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ScriptLoader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ScriptLoader
)
ScriptLoader
:
:
ScriptLoader
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
mParserBlockingBlockerCount
(
0
)
mBlockerCount
(
0
)
mNumberOfProcessors
(
0
)
mEnabled
(
true
)
mDeferEnabled
(
false
)
mDocumentParsingDone
(
false
)
mBlockingDOMContentLoaded
(
false
)
mLoadEventFired
(
false
)
mReporter
(
new
ConsoleReportCollector
(
)
)
{
}
ScriptLoader
:
:
~
ScriptLoader
(
)
{
mObservers
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mXSLTRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mDeferRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadingAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mLoadedAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
ScriptLoadRequest
*
req
=
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
uint32_t
j
=
0
;
j
<
mPendingChildLoaders
.
Length
(
)
;
+
+
j
)
{
mPendingChildLoaders
[
j
]
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
}
static
void
CollectScriptTelemetry
(
nsIIncrementalStreamLoader
*
aLoader
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
if
(
!
CanRecordExtended
(
)
)
{
return
;
}
if
(
aRequest
-
>
IsLoadingSource
(
)
)
{
if
(
aRequest
-
>
mIsInline
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
Inline
)
;
nsAutoString
inlineData
;
aRequest
-
>
mElement
-
>
GetScriptText
(
inlineData
)
;
Accumulate
(
DOM_SCRIPT_INLINE_SIZE
inlineData
.
Length
(
)
)
;
}
else
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
SourceFallback
)
;
Accumulate
(
DOM_SCRIPT_SOURCE_SIZE
aRequest
-
>
mScriptText
.
length
(
)
)
;
}
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
if
(
aRequest
-
>
IsSource
(
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
Source
)
;
Accumulate
(
DOM_SCRIPT_SOURCE_SIZE
aRequest
-
>
mScriptText
.
length
(
)
)
;
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsBytecode
(
)
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_LOADING_SOURCE
:
:
AltData
)
;
Accumulate
(
DOM_SCRIPT_BYTECODE_SIZE
aRequest
-
>
mScriptBytecode
.
length
(
)
)
;
}
}
if
(
!
aLoader
)
{
return
;
}
nsCOMPtr
<
nsIRequest
>
channel
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channel
)
)
;
nsCOMPtr
<
nsICacheInfoChannel
>
cic
(
do_QueryInterface
(
channel
)
)
;
if
(
!
cic
)
{
return
;
}
int32_t
fetchCount
=
0
;
if
(
NS_SUCCEEDED
(
cic
-
>
GetCacheTokenFetchCount
(
&
fetchCount
)
)
)
{
Accumulate
(
DOM_SCRIPT_FETCH_COUNT
fetchCount
)
;
}
}
static
bool
IsScriptEventHandler
(
nsIContent
*
aScriptElement
)
{
if
(
!
aScriptElement
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
nsAutoString
forAttr
eventAttr
;
if
(
!
aScriptElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
forAttr
)
|
|
!
aScriptElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
event
eventAttr
)
)
{
return
false
;
}
const
nsAString
&
for_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
forAttr
)
;
if
(
!
for_str
.
LowerCaseEqualsLiteral
(
"
window
"
)
)
{
return
true
;
}
const
nsAString
&
event_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
eventAttr
false
)
;
if
(
!
StringBeginsWith
(
event_str
NS_LITERAL_STRING
(
"
onload
"
)
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
nsAutoString
:
:
const_iterator
start
end
;
event_str
.
BeginReading
(
start
)
;
event_str
.
EndReading
(
end
)
;
start
.
advance
(
6
)
;
if
(
start
!
=
end
&
&
*
start
!
=
'
(
'
&
&
*
start
!
=
'
'
)
{
return
true
;
}
return
false
;
}
nsresult
ScriptLoader
:
:
CheckContentPolicy
(
nsIDocument
*
aDocument
nsISupports
*
aContext
nsIURI
*
aURI
const
nsAString
&
aType
bool
aIsPreLoad
)
{
nsContentPolicyType
contentPolicyType
=
aIsPreLoad
?
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
contentPolicyType
aURI
aDocument
-
>
NodePrincipal
(
)
aContext
NS_LossyConvertUTF16toASCII
(
aType
)
nullptr
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
NS_FAILED
(
rv
)
|
|
shouldLoad
!
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
return
NS_OK
;
}
bool
ScriptLoader
:
:
ModuleScriptsEnabled
(
)
{
static
bool
sEnabledForContent
=
false
;
static
bool
sCachedPref
=
false
;
if
(
!
sCachedPref
)
{
sCachedPref
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sEnabledForContent
"
dom
.
moduleScripts
.
enabled
"
false
)
;
}
return
nsContentUtils
:
:
IsChromeDoc
(
mDocument
)
|
|
sEnabledForContent
;
}
bool
ScriptLoader
:
:
ModuleMapContainsModule
(
ModuleLoadRequest
*
aRequest
)
const
{
return
mFetchingModules
.
Contains
(
aRequest
-
>
mURI
)
|
|
mFetchedModules
.
Contains
(
aRequest
-
>
mURI
)
;
}
bool
ScriptLoader
:
:
IsFetchingModule
(
ModuleLoadRequest
*
aRequest
)
const
{
bool
fetching
=
mFetchingModules
.
Contains
(
aRequest
-
>
mURI
)
;
MOZ_ASSERT_IF
(
fetching
!
mFetchedModules
.
Contains
(
aRequest
-
>
mURI
)
)
;
return
fetching
;
}
void
ScriptLoader
:
:
SetModuleFetchStarted
(
ModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
MOZ_ASSERT
(
!
ModuleMapContainsModule
(
aRequest
)
)
;
mFetchingModules
.
Put
(
aRequest
-
>
mURI
nullptr
)
;
}
void
ScriptLoader
:
:
SetModuleFetchFinishedAndResumeWaitingRequests
(
ModuleLoadRequest
*
aRequest
nsresult
aResult
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsReadyToRun
(
)
)
;
RefPtr
<
GenericPromise
:
:
Private
>
promise
;
MOZ_ALWAYS_TRUE
(
mFetchingModules
.
Remove
(
aRequest
-
>
mURI
getter_AddRefs
(
promise
)
)
)
;
RefPtr
<
ModuleScript
>
ms
(
aRequest
-
>
mModuleScript
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aResult
)
=
=
(
ms
!
=
nullptr
)
)
;
mFetchedModules
.
Put
(
aRequest
-
>
mURI
ms
)
;
if
(
promise
)
{
if
(
ms
)
{
promise
-
>
Resolve
(
true
__func__
)
;
}
else
{
promise
-
>
Reject
(
aResult
__func__
)
;
}
}
}
RefPtr
<
GenericPromise
>
ScriptLoader
:
:
WaitForModuleFetch
(
ModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
ModuleMapContainsModule
(
aRequest
)
)
;
if
(
auto
entry
=
mFetchingModules
.
Lookup
(
aRequest
-
>
mURI
)
)
{
if
(
!
entry
.
Data
(
)
)
{
entry
.
Data
(
)
=
new
GenericPromise
:
:
Private
(
__func__
)
;
}
return
entry
.
Data
(
)
;
}
RefPtr
<
ModuleScript
>
ms
;
MOZ_ALWAYS_TRUE
(
mFetchedModules
.
Get
(
aRequest
-
>
mURI
getter_AddRefs
(
ms
)
)
)
;
if
(
!
ms
|
|
ms
-
>
InstantiationFailed
(
)
)
{
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
ModuleScript
*
ScriptLoader
:
:
GetFetchedModule
(
nsIURI
*
aURL
)
const
{
bool
found
;
ModuleScript
*
ms
=
mFetchedModules
.
GetWeak
(
aURL
&
found
)
;
MOZ_ASSERT
(
found
)
;
return
ms
;
}
nsresult
ScriptLoader
:
:
ProcessFetchedModuleSource
(
ModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
mModuleScript
)
;
nsresult
rv
=
CreateModuleScript
(
aRequest
)
;
SetModuleFetchFinishedAndResumeWaitingRequests
(
aRequest
rv
)
;
aRequest
-
>
mScriptText
.
clearAndFree
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
StartFetchingModuleDependencies
(
aRequest
)
;
}
return
rv
;
}
nsresult
ScriptLoader
:
:
CreateModuleScript
(
ModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
mModuleScript
)
;
MOZ_ASSERT
(
aRequest
-
>
mBaseURL
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
globalObject
"
CompileModule
"
true
)
;
bool
oldProcessingScriptTag
=
context
-
>
GetProcessingScriptTag
(
)
;
context
-
>
SetProcessingScriptTag
(
true
)
;
nsresult
rv
;
{
AutoCurrentScriptUpdater
scriptUpdater
(
this
aRequest
-
>
mElement
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
cx
)
;
if
(
aRequest
-
>
mWasCompiledOMT
)
{
module
=
JS
:
:
FinishOffThreadModule
(
cx
aRequest
-
>
mOffThreadToken
)
;
aRequest
-
>
mOffThreadToken
=
nullptr
;
rv
=
module
?
NS_OK
:
NS_ERROR_FAILURE
;
}
else
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
rv
=
FillCompileOptionsForRequest
(
aes
aRequest
global
&
options
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
inlineData
;
SourceBufferHolder
srcBuf
=
GetScriptSource
(
aRequest
inlineData
)
;
rv
=
nsJSUtils
:
:
CompileModule
(
cx
srcBuf
global
options
&
module
)
;
}
}
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
=
=
(
module
!
=
nullptr
)
)
;
if
(
module
)
{
aRequest
-
>
mModuleScript
=
new
ModuleScript
(
this
aRequest
-
>
mBaseURL
module
)
;
}
}
context
-
>
SetProcessingScriptTag
(
oldProcessingScriptTag
)
;
return
rv
;
}
static
bool
ThrowTypeError
(
JSContext
*
aCx
ModuleScript
*
aScript
const
nsString
&
aMessage
)
{
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
aScript
-
>
ModuleRecord
(
)
)
;
JS
:
:
Rooted
<
JSScript
*
>
script
(
aCx
JS
:
:
GetModuleScript
(
aCx
module
)
)
;
JS
:
:
Rooted
<
JSString
*
>
filename
(
aCx
)
;
filename
=
JS_NewStringCopyZ
(
aCx
JS_GetScriptFilename
(
script
)
)
;
if
(
!
filename
)
{
return
false
;
}
JS
:
:
Rooted
<
JSString
*
>
message
(
aCx
JS_NewUCStringCopyZ
(
aCx
aMessage
.
get
(
)
)
)
;
if
(
!
message
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
if
(
!
JS
:
:
CreateError
(
aCx
JSEXN_TYPEERR
nullptr
filename
0
0
nullptr
message
&
error
)
)
{
return
false
;
}
JS_SetPendingException
(
aCx
error
)
;
return
false
;
}
static
bool
HandleResolveFailure
(
JSContext
*
aCx
ModuleScript
*
aScript
const
nsAString
&
aSpecifier
)
{
nsAutoString
message
(
NS_LITERAL_STRING
(
"
Error
resolving
module
specifier
:
"
)
)
;
message
.
Append
(
aSpecifier
)
;
return
ThrowTypeError
(
aCx
aScript
message
)
;
}
static
bool
HandleModuleNotFound
(
JSContext
*
aCx
ModuleScript
*
aScript
const
nsAString
&
aSpecifier
)
{
nsAutoString
message
(
NS_LITERAL_STRING
(
"
Resolved
module
not
found
in
map
:
"
)
)
;
message
.
Append
(
aSpecifier
)
;
return
ThrowTypeError
(
aCx
aScript
message
)
;
}
static
already_AddRefed
<
nsIURI
>
ResolveModuleSpecifier
(
ModuleScript
*
aScript
const
nsAString
&
aSpecifier
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
uri
.
forget
(
)
;
}
if
(
rv
!
=
NS_ERROR_MALFORMED_URI
)
{
return
nullptr
;
}
if
(
!
StringBeginsWith
(
aSpecifier
NS_LITERAL_STRING
(
"
/
"
)
)
&
&
!
StringBeginsWith
(
aSpecifier
NS_LITERAL_STRING
(
"
.
/
"
)
)
&
&
!
StringBeginsWith
(
aSpecifier
NS_LITERAL_STRING
(
"
.
.
/
"
)
)
)
{
return
nullptr
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
nullptr
aScript
-
>
BaseURL
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
uri
.
forget
(
)
;
}
return
nullptr
;
}
static
nsresult
RequestedModuleIsInAncestorList
(
ModuleLoadRequest
*
aRequest
nsIURI
*
aURL
bool
*
aResult
)
{
const
size_t
ImportDepthLimit
=
100
;
*
aResult
=
false
;
size_t
depth
=
0
;
while
(
aRequest
)
{
if
(
depth
+
+
=
=
ImportDepthLimit
)
{
return
NS_ERROR_FAILURE
;
}
bool
equal
;
nsresult
rv
=
aURL
-
>
Equals
(
aRequest
-
>
mURI
&
equal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
equal
)
{
*
aResult
=
true
;
return
NS_OK
;
}
aRequest
=
aRequest
-
>
mParent
;
}
return
NS_OK
;
}
static
nsresult
ResolveRequestedModules
(
ModuleLoadRequest
*
aRequest
nsCOMArray
<
nsIURI
>
&
aUrls
)
{
ModuleScript
*
ms
=
aRequest
-
>
mModuleScript
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
ms
-
>
ModuleRecord
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
moduleRecord
(
cx
ms
-
>
ModuleRecord
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
specifiers
(
cx
JS
:
:
GetRequestedModules
(
cx
moduleRecord
)
)
;
uint32_t
length
;
if
(
!
JS_GetArrayLength
(
cx
specifiers
&
length
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
!
JS_GetElement
(
cx
specifiers
i
&
val
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoJSString
specifier
;
if
(
!
specifier
.
init
(
cx
val
)
)
{
return
NS_ERROR_FAILURE
;
}
ModuleScript
*
ms
=
aRequest
-
>
mModuleScript
;
nsCOMPtr
<
nsIURI
>
uri
=
ResolveModuleSpecifier
(
ms
specifier
)
;
if
(
!
uri
)
{
HandleResolveFailure
(
cx
ms
specifier
)
;
return
NS_ERROR_FAILURE
;
}
bool
isAncestor
;
nsresult
rv
=
RequestedModuleIsInAncestorList
(
aRequest
uri
&
isAncestor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isAncestor
)
{
aUrls
.
AppendElement
(
uri
.
forget
(
)
)
;
}
}
return
NS_OK
;
}
void
ScriptLoader
:
:
StartFetchingModuleDependencies
(
ModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mModuleScript
)
;
MOZ_ASSERT
(
!
aRequest
-
>
mModuleScript
-
>
InstantiationFailed
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
IsReadyToRun
(
)
)
;
aRequest
-
>
mProgress
=
ModuleLoadRequest
:
:
Progress
:
:
FetchingImports
;
nsCOMArray
<
nsIURI
>
urls
;
nsresult
rv
=
ResolveRequestedModules
(
aRequest
urls
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRequest
-
>
LoadFailed
(
)
;
return
;
}
if
(
urls
.
Length
(
)
=
=
0
)
{
aRequest
-
>
DependenciesLoaded
(
)
;
return
;
}
nsTArray
<
RefPtr
<
GenericPromise
>
>
importsReady
;
for
(
size_t
i
=
0
;
i
<
urls
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
GenericPromise
>
childReady
=
StartFetchingModuleAndDependencies
(
aRequest
urls
[
i
]
)
;
importsReady
.
AppendElement
(
childReady
)
;
}
RefPtr
<
GenericPromise
:
:
AllPromiseType
>
allReady
=
GenericPromise
:
:
All
(
GetMainThreadSerialEventTarget
(
)
importsReady
)
;
allReady
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
aRequest
&
ModuleLoadRequest
:
:
DependenciesLoaded
&
ModuleLoadRequest
:
:
LoadFailed
)
;
}
RefPtr
<
GenericPromise
>
ScriptLoader
:
:
StartFetchingModuleAndDependencies
(
ModuleLoadRequest
*
aRequest
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
RefPtr
<
ModuleLoadRequest
>
childRequest
=
new
ModuleLoadRequest
(
aRequest
-
>
mElement
aRequest
-
>
mJSVersion
aRequest
-
>
mCORSMode
aRequest
-
>
mIntegrity
this
)
;
childRequest
-
>
mIsTopLevel
=
false
;
childRequest
-
>
mURI
=
aURI
;
childRequest
-
>
mIsInline
=
false
;
childRequest
-
>
mReferrerPolicy
=
aRequest
-
>
mReferrerPolicy
;
childRequest
-
>
mParent
=
aRequest
;
RefPtr
<
GenericPromise
>
ready
=
childRequest
-
>
mReady
.
Ensure
(
__func__
)
;
nsresult
rv
=
StartLoad
(
childRequest
)
;
if
(
NS_FAILED
(
rv
)
)
{
childRequest
-
>
mReady
.
Reject
(
rv
__func__
)
;
return
ready
;
}
aRequest
-
>
mImports
.
AppendElement
(
childRequest
)
;
return
ready
;
}
bool
HostResolveImportedModule
(
JSContext
*
aCx
unsigned
argc
JS
:
:
Value
*
vp
)
{
MOZ_ASSERT
(
argc
=
=
2
)
;
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
&
args
[
0
]
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JSString
*
>
specifier
(
aCx
args
[
1
]
.
toString
(
)
)
;
JS
:
:
Value
value
=
JS
:
:
GetModuleHostDefinedField
(
module
)
;
auto
script
=
static_cast
<
ModuleScript
*
>
(
value
.
toPrivate
(
)
)
;
MOZ_ASSERT
(
script
-
>
ModuleRecord
(
)
=
=
module
)
;
nsAutoJSString
string
;
if
(
!
string
.
init
(
aCx
specifier
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
=
ResolveModuleSpecifier
(
script
string
)
;
if
(
!
uri
)
{
return
HandleResolveFailure
(
aCx
script
string
)
;
}
ModuleScript
*
ms
=
script
-
>
Loader
(
)
-
>
GetFetchedModule
(
uri
)
;
if
(
!
ms
)
{
return
HandleModuleNotFound
(
aCx
script
string
)
;
}
if
(
ms
-
>
InstantiationFailed
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
aCx
ms
-
>
Exception
(
)
)
;
JS_SetPendingException
(
aCx
exception
)
;
return
false
;
}
*
vp
=
JS
:
:
ObjectValue
(
*
ms
-
>
ModuleRecord
(
)
)
;
return
true
;
}
static
nsresult
EnsureModuleResolveHook
(
JSContext
*
aCx
)
{
if
(
JS
:
:
GetModuleResolveHook
(
aCx
)
)
{
return
NS_OK
;
}
JS
:
:
Rooted
<
JSFunction
*
>
func
(
aCx
)
;
func
=
JS_NewFunction
(
aCx
HostResolveImportedModule
2
0
"
HostResolveImportedModule
"
)
;
if
(
!
func
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
SetModuleResolveHook
(
aCx
func
)
;
return
NS_OK
;
}
void
ScriptLoader
:
:
ProcessLoadedModuleTree
(
ModuleLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
IsTopLevel
(
)
)
{
MaybeMoveToLoadedList
(
aRequest
)
;
ProcessPendingRequests
(
)
;
}
if
(
aRequest
-
>
mWasCompiledOMT
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
}
}
bool
ScriptLoader
:
:
InstantiateModuleTree
(
ModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
)
;
ModuleScript
*
ms
=
aRequest
-
>
mModuleScript
;
MOZ_ASSERT
(
ms
)
;
if
(
!
ms
-
>
ModuleRecord
(
)
)
{
return
false
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
ms
-
>
ModuleRecord
(
)
)
)
)
{
return
false
;
}
nsresult
rv
=
EnsureModuleResolveHook
(
jsapi
.
cx
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
jsapi
.
cx
(
)
ms
-
>
ModuleRecord
(
)
)
;
bool
ok
=
NS_SUCCEEDED
(
nsJSUtils
:
:
ModuleDeclarationInstantiation
(
jsapi
.
cx
(
)
module
)
)
;
JS
:
:
RootedValue
exception
(
jsapi
.
cx
(
)
)
;
if
(
!
ok
)
{
MOZ_ASSERT
(
jsapi
.
HasException
(
)
)
;
if
(
!
jsapi
.
StealException
(
&
exception
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
exception
.
isUndefined
(
)
)
;
}
mozilla
:
:
Vector
<
ModuleLoadRequest
*
1
>
requests
;
if
(
!
requests
.
append
(
aRequest
)
)
{
return
false
;
}
while
(
!
requests
.
empty
(
)
)
{
ModuleLoadRequest
*
request
=
requests
.
popCopy
(
)
;
ModuleScript
*
ms
=
request
-
>
mModuleScript
;
if
(
!
ms
-
>
IsUninstantiated
(
)
)
{
continue
;
}
ms
-
>
SetInstantiationResult
(
exception
)
;
for
(
auto
import
:
request
-
>
mImports
)
{
if
(
import
-
>
mModuleScript
-
>
IsUninstantiated
(
)
&
&
!
requests
.
append
(
import
)
)
{
return
false
;
}
}
}
return
true
;
}
nsresult
ScriptLoader
:
:
RestartLoad
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsBytecode
(
)
)
;
aRequest
-
>
mScriptBytecode
.
clearAndFree
(
)
;
TRACE_FOR_TEST
(
aRequest
-
>
mElement
"
scriptloader_fallback
"
)
;
aRequest
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
Loading_Source
;
nsresult
rv
=
StartLoad
(
aRequest
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_BINDING_RETARGETED
;
}
nsresult
ScriptLoader
:
:
StartLoad
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NULL_POINTER
)
;
aRequest
-
>
mDataType
=
ScriptLoadRequest
:
:
DataType
:
:
Unknown
;
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
NS_OK
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
ModuleMapContainsModule
(
request
)
)
{
WaitForModuleFetch
(
request
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
request
&
ModuleLoadRequest
:
:
ModuleLoaded
&
ModuleLoadRequest
:
:
LoadFailed
)
;
return
NS_OK
;
}
SetModuleFetchStarted
(
request
)
;
}
nsContentPolicyType
contentPolicyType
=
aRequest
-
>
IsPreload
(
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
nsCOMPtr
<
nsINode
>
context
;
if
(
aRequest
-
>
mElement
)
{
context
=
do_QueryInterface
(
aRequest
-
>
mElement
)
;
}
else
{
context
=
mDocument
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_NULL_POINTER
)
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
prompter
(
do_QueryInterface
(
docshell
)
)
;
nsSecurityFlags
securityFlags
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
securityFlags
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
aRequest
-
>
mCORSMode
=
=
CORS_NONE
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_OMIT
;
}
else
if
(
aRequest
-
>
mCORSMode
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
{
MOZ_ASSERT
(
aRequest
-
>
mCORSMode
=
=
CORS_USE_CREDENTIALS
)
;
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
}
else
{
securityFlags
=
aRequest
-
>
mCORSMode
=
=
CORS_NONE
?
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
:
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
aRequest
-
>
mCORSMode
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
aRequest
-
>
mCORSMode
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aRequest
-
>
mURI
context
securityFlags
contentPolicyType
loadGroup
prompter
nsIRequest
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aRequest
-
>
mCacheInfo
=
nullptr
;
nsCOMPtr
<
nsICacheInfoChannel
>
cic
(
do_QueryInterface
(
channel
)
)
;
if
(
cic
&
&
nsContentUtils
:
:
IsBytecodeCacheEnabled
(
)
&
&
aRequest
-
>
mJSVersion
=
=
JSVERSION_DEFAULT
)
{
if
(
!
aRequest
-
>
IsLoadingSource
(
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Maybe
request
bytecode
"
aRequest
)
)
;
cic
-
>
PreferAlternativeDataType
(
nsContentUtils
:
:
JSBytecodeMimeType
(
)
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Request
saving
bytecode
later
"
aRequest
)
)
;
cic
-
>
PreferAlternativeDataType
(
kNullMimeType
)
;
}
}
nsIScriptElement
*
script
=
aRequest
-
>
mElement
;
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
channel
)
)
;
if
(
cos
)
{
if
(
aRequest
-
>
mScriptFromHead
&
&
!
(
script
&
&
(
script
-
>
GetScriptAsync
(
)
|
|
script
-
>
GetScriptDeferred
(
)
)
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
else
if
(
!
(
script
&
&
script
-
>
GetScriptDeferred
(
)
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Unblocked
)
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Accept
"
)
NS_LITERAL_CSTRING
(
"
*
/
*
"
)
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
httpChannel
-
>
SetReferrerWithPolicy
(
mDocument
-
>
GetDocumentURI
(
)
aRequest
-
>
mReferrerPolicy
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
internalChannel
)
{
rv
=
internalChannel
-
>
SetIntegrityMetadata
(
aRequest
-
>
mIntegrity
.
GetIntegrityString
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
mozilla
:
:
net
:
:
PredictorLearn
(
aRequest
-
>
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
mDocument
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
script
"
)
)
;
}
nsAutoPtr
<
mozilla
:
:
dom
:
:
SRICheckDataVerifier
>
sriDataVerifier
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
)
{
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
sriDataVerifier
=
new
SRICheckDataVerifier
(
aRequest
-
>
mIntegrity
sourceUri
mReporter
)
;
}
RefPtr
<
ScriptLoadHandler
>
handler
=
new
ScriptLoadHandler
(
this
aRequest
sriDataVerifier
.
forget
(
)
)
;
nsCOMPtr
<
nsIIncrementalStreamLoader
>
loader
;
rv
=
NS_NewIncrementalStreamLoader
(
getter_AddRefs
(
loader
)
handler
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
channel
-
>
AsyncOpen2
(
loader
)
;
}
bool
ScriptLoader
:
:
PreloadURIComparator
:
:
Equals
(
const
PreloadInfo
&
aPi
nsIURI
*
const
&
aURI
)
const
{
bool
same
;
return
NS_SUCCEEDED
(
aPi
.
mRequest
-
>
mURI
-
>
Equals
(
aURI
&
same
)
)
&
&
same
;
}
class
ScriptRequestProcessor
:
public
Runnable
{
private
:
RefPtr
<
ScriptLoader
>
mLoader
;
RefPtr
<
ScriptLoadRequest
>
mRequest
;
public
:
ScriptRequestProcessor
(
ScriptLoader
*
aLoader
ScriptLoadRequest
*
aRequest
)
:
Runnable
(
"
dom
:
:
ScriptRequestProcessor
"
)
mLoader
(
aLoader
)
mRequest
(
aRequest
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mLoader
-
>
ProcessRequest
(
mRequest
)
;
}
}
;
static
inline
bool
ParseTypeAttribute
(
const
nsAString
&
aType
JSVersion
*
aVersion
)
{
MOZ_ASSERT
(
!
aType
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aVersion
)
;
MOZ_ASSERT
(
*
aVersion
=
=
JSVERSION_DEFAULT
)
;
nsContentTypeParser
parser
(
aType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
mimeType
)
)
{
return
false
;
}
nsAutoString
versionName
;
rv
=
parser
.
GetParameter
(
"
version
"
versionName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aVersion
=
nsContentUtils
:
:
ParseJavascriptVersion
(
versionName
)
;
}
else
if
(
rv
!
=
NS_ERROR_INVALID_ARG
)
{
return
false
;
}
return
true
;
}
static
bool
CSPAllowsInlineScript
(
nsIScriptElement
*
aElement
nsIDocument
*
aDocument
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
nsresult
rv
=
aDocument
-
>
NodePrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
csp
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
nsAutoString
nonce
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
nonce
nonce
)
;
bool
parserCreated
=
aElement
-
>
GetParserCreated
(
)
!
=
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
;
nsAutoString
scriptText
;
aElement
-
>
GetScriptText
(
scriptText
)
;
bool
allowInlineScript
=
false
;
rv
=
csp
-
>
GetAllowsInline
(
nsIContentPolicy
:
:
TYPE_SCRIPT
nonce
parserCreated
scriptText
aElement
-
>
GetScriptLineNumber
(
)
&
allowInlineScript
)
;
return
allowInlineScript
;
}
ScriptLoadRequest
*
ScriptLoader
:
:
CreateLoadRequest
(
ScriptKind
aKind
nsIScriptElement
*
aElement
uint32_t
aVersion
CORSMode
aCORSMode
const
SRIMetadata
&
aIntegrity
)
{
if
(
aKind
=
=
ScriptKind
:
:
Classic
)
{
return
new
ScriptLoadRequest
(
aKind
aElement
aVersion
aCORSMode
aIntegrity
)
;
}
MOZ_ASSERT
(
aKind
=
=
ScriptKind
:
:
Module
)
;
return
new
ModuleLoadRequest
(
aElement
aVersion
aCORSMode
aIntegrity
this
)
;
}
bool
ScriptLoader
:
:
ProcessScriptElement
(
nsIScriptElement
*
aElement
)
{
NS_ENSURE_TRUE
(
mDocument
false
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
false
;
}
NS_ASSERTION
(
!
aElement
-
>
IsMalformed
(
)
"
Executing
malformed
script
"
)
;
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
if
(
IsScriptEventHandler
(
scriptContent
)
)
{
return
false
;
}
JSVersion
version
=
JSVERSION_DEFAULT
;
nsAutoString
type
;
bool
hasType
=
aElement
-
>
GetScriptType
(
type
)
;
ScriptKind
scriptKind
=
ScriptKind
:
:
Classic
;
if
(
!
type
.
IsEmpty
(
)
)
{
if
(
ModuleScriptsEnabled
(
)
&
&
type
.
LowerCaseEqualsASCII
(
"
module
"
)
)
{
scriptKind
=
ScriptKind
:
:
Module
;
}
else
{
NS_ENSURE_TRUE
(
ParseTypeAttribute
(
type
&
version
)
false
)
;
}
}
else
if
(
!
hasType
)
{
if
(
scriptContent
-
>
IsHTMLElement
(
)
)
{
nsAutoString
language
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
language
language
)
;
if
(
!
language
.
IsEmpty
(
)
)
{
if
(
!
nsContentUtils
:
:
IsJavaScriptLanguage
(
language
)
)
{
return
false
;
}
}
}
}
if
(
ModuleScriptsEnabled
(
)
&
&
scriptKind
=
=
ScriptKind
:
:
Classic
&
&
scriptContent
-
>
IsHTMLElement
(
)
&
&
scriptContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
nomodule
)
)
{
return
false
;
}
nsresult
rv
=
NS_OK
;
RefPtr
<
ScriptLoadRequest
>
request
;
if
(
aElement
-
>
GetScriptExternal
(
)
)
{
nsCOMPtr
<
nsIURI
>
scriptURI
=
aElement
-
>
GetScriptURI
(
)
;
if
(
!
scriptURI
)
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
mozilla
:
:
net
:
:
ReferrerPolicy
ourRefPolicy
=
mDocument
-
>
GetReferrerPolicy
(
)
;
CORSMode
ourCORSMode
=
aElement
-
>
GetCORSMode
(
)
;
nsTArray
<
PreloadInfo
>
:
:
index_type
i
=
mPreloads
.
IndexOf
(
scriptURI
.
get
(
)
0
PreloadURIComparator
(
)
)
;
if
(
i
!
=
nsTArray
<
PreloadInfo
>
:
:
NoIndex
)
{
request
=
mPreloads
[
i
]
.
mRequest
;
request
-
>
mElement
=
aElement
;
nsString
preloadCharset
(
mPreloads
[
i
]
.
mCharset
)
;
mPreloads
.
RemoveElementAt
(
i
)
;
nsAutoString
elementCharset
;
aElement
-
>
GetScriptCharset
(
elementCharset
)
;
if
(
elementCharset
.
Equals
(
preloadCharset
)
&
&
ourCORSMode
=
=
request
-
>
mCORSMode
&
&
ourRefPolicy
=
=
request
-
>
mReferrerPolicy
&
&
scriptKind
=
=
request
-
>
mKind
)
{
rv
=
CheckContentPolicy
(
mDocument
aElement
request
-
>
mURI
type
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
request
-
>
Cancel
(
)
;
return
false
;
}
}
else
{
request
=
nullptr
;
}
}
if
(
!
request
)
{
SRIMetadata
sriMetadata
;
{
nsAutoString
integrity
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
integrity
integrity
)
;
if
(
!
integrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
ScriptLoader
:
:
ProcessScriptElement
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
integrity
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
integrity
sourceUri
mReporter
&
sriMetadata
)
;
}
}
request
=
CreateLoadRequest
(
scriptKind
aElement
version
ourCORSMode
sriMetadata
)
;
request
-
>
mURI
=
scriptURI
;
request
-
>
mIsInline
=
false
;
request
-
>
mReferrerPolicy
=
ourRefPolicy
;
rv
=
StartLoad
(
request
)
;
if
(
NS_FAILED
(
rv
)
)
{
const
char
*
message
=
"
ScriptSourceLoadFailed
"
;
if
(
rv
=
=
NS_ERROR_MALFORMED_URI
)
{
message
=
"
ScriptSourceMalformed
"
;
}
else
if
(
rv
=
=
NS_ERROR_DOM_BAD_URI
)
{
message
=
"
ScriptSourceNotAllowed
"
;
}
NS_ConvertUTF8toUTF16
url
(
scriptURI
-
>
GetSpecOrDefault
(
)
)
;
const
char16_t
*
params
[
]
=
{
url
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Script
Loader
"
)
mDocument
nsContentUtils
:
:
eDOM_PROPERTIES
message
params
ArrayLength
(
params
)
nullptr
EmptyString
(
)
aElement
-
>
GetScriptLineNumber
(
)
)
;
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
"
nsIScriptElement
:
:
FireErrorEvent
"
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
}
NS_ASSERTION
(
!
request
-
>
InCompilingStage
(
)
"
Request
should
not
yet
be
in
compiling
stage
.
"
)
;
request
-
>
mJSVersion
=
version
;
if
(
aElement
-
>
GetScriptAsync
(
)
)
{
request
-
>
mIsAsync
=
true
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
mLoadedAsyncRequests
.
AppendElement
(
request
)
;
ProcessPendingRequestsAsync
(
)
;
}
else
{
mLoadingAsyncRequests
.
AppendElement
(
request
)
;
}
return
false
;
}
if
(
!
aElement
-
>
GetParserCreated
(
)
)
{
request
-
>
mIsNonAsyncScriptInserted
=
true
;
mNonAsyncExternalScriptInsertedRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
false
;
}
if
(
aElement
-
>
GetScriptDeferred
(
)
|
|
request
-
>
IsModuleRequest
(
)
)
{
NS_ASSERTION
(
mDocument
-
>
GetCurrentContentSink
(
)
|
|
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
"
Non
-
XSLT
Defer
script
on
a
document
without
an
active
parser
;
bug
592366
.
"
)
;
AddDeferRequest
(
request
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
request
-
>
mIsXSLT
=
true
;
mXSLTRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
true
;
}
if
(
request
-
>
IsReadyToRun
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
ProcessPendingRequestsAsync
(
)
;
return
true
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
return
true
;
}
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
false
;
}
if
(
!
CSPAllowsInlineScript
(
aElement
mDocument
)
)
{
return
false
;
}
request
=
CreateLoadRequest
(
scriptKind
aElement
version
CORS_NONE
SRIMetadata
(
)
)
;
request
-
>
mJSVersion
=
version
;
request
-
>
mIsInline
=
true
;
request
-
>
mURI
=
mDocument
-
>
GetDocumentURI
(
)
;
request
-
>
mLineNo
=
aElement
-
>
GetScriptLineNumber
(
)
;
request
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
Loading_Source
;
request
-
>
mDataType
=
ScriptLoadRequest
:
:
DataType
:
:
Source
;
TRACE_FOR_TEST_BOOL
(
request
-
>
mElement
"
scriptloader_load_source
"
)
;
CollectScriptTelemetry
(
nullptr
request
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
modReq
=
request
-
>
AsModuleRequest
(
)
;
modReq
-
>
mBaseURL
=
mDocument
-
>
GetDocBaseURI
(
)
;
rv
=
CreateModuleScript
(
modReq
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
StartFetchingModuleDependencies
(
modReq
)
;
if
(
aElement
-
>
GetScriptAsync
(
)
)
{
mLoadingAsyncRequests
.
AppendElement
(
request
)
;
}
else
{
AddDeferRequest
(
request
)
;
}
return
false
;
}
request
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
Ready
;
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
&
&
(
!
ReadyToExecuteParserBlockingScripts
(
)
|
|
!
mXSLTRequests
.
isEmpty
(
)
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mXSLTRequests
.
AppendElement
(
request
)
;
return
true
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
NOT_FROM_PARSER
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
A
script
-
inserted
script
is
inserted
without
an
update
batch
?
"
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
ScriptRequestProcessor
(
this
request
)
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
&
&
!
ReadyToExecuteParserBlockingScripts
(
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
mParserBlockingRequest
=
request
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
return
true
;
}
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Not
safe
to
run
a
parser
-
inserted
script
?
"
)
;
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
namespace
{
class
NotifyOffThreadScriptLoadCompletedRunnable
:
public
Runnable
{
RefPtr
<
ScriptLoadRequest
>
mRequest
;
RefPtr
<
ScriptLoader
>
mLoader
;
RefPtr
<
DocGroup
>
mDocGroup
;
void
*
mToken
;
public
:
NotifyOffThreadScriptLoadCompletedRunnable
(
ScriptLoadRequest
*
aRequest
ScriptLoader
*
aLoader
)
:
Runnable
(
"
dom
:
:
NotifyOffThreadScriptLoadCompletedRunnable
"
)
mRequest
(
aRequest
)
mLoader
(
aLoader
)
mDocGroup
(
aLoader
-
>
GetDocGroup
(
)
)
mToken
(
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
virtual
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
;
void
SetToken
(
void
*
aToken
)
{
MOZ_ASSERT
(
aToken
&
&
!
mToken
)
;
mToken
=
aToken
;
}
static
void
Dispatch
(
already_AddRefed
<
NotifyOffThreadScriptLoadCompletedRunnable
>
&
&
aSelf
)
{
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
self
=
aSelf
;
RefPtr
<
DocGroup
>
docGroup
=
self
-
>
mDocGroup
;
docGroup
-
>
Dispatch
(
TaskCategory
:
:
Other
self
.
forget
(
)
)
;
}
NS_DECL_NSIRUNNABLE
}
;
}
nsresult
ScriptLoader
:
:
ProcessOffThreadRequest
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mProgress
=
=
ScriptLoadRequest
:
:
Progress
:
:
Compiling
)
;
MOZ_ASSERT
(
!
aRequest
-
>
mWasCompiledOMT
)
;
aRequest
-
>
mWasCompiledOMT
=
true
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
mOffThreadToken
)
;
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
nsresult
rv
=
ProcessFetchedModuleSource
(
request
)
;
if
(
NS_FAILED
(
rv
)
)
{
request
-
>
LoadFailed
(
)
;
}
return
rv
;
}
aRequest
-
>
SetReady
(
)
;
if
(
aRequest
=
=
mParserBlockingRequest
)
{
if
(
!
ReadyToExecuteParserBlockingScripts
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
return
NS_OK
;
}
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
aRequest
)
;
ProcessRequest
(
aRequest
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
ContinueParserAsync
(
aRequest
)
;
return
NS_OK
;
}
nsresult
rv
=
ProcessRequest
(
aRequest
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
return
rv
;
}
NotifyOffThreadScriptLoadCompletedRunnable
:
:
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
{
if
(
MOZ_UNLIKELY
(
mRequest
|
|
mLoader
)
&
&
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThreadSystemGroup
(
"
NotifyOffThreadScriptLoadCompletedRunnable
:
:
mRequest
"
mRequest
.
forget
(
)
)
;
NS_ReleaseOnMainThreadSystemGroup
(
"
NotifyOffThreadScriptLoadCompletedRunnable
:
:
mLoader
"
mLoader
.
forget
(
)
)
;
}
}
NS_IMETHODIMP
NotifyOffThreadScriptLoadCompletedRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ScriptLoadRequest
>
request
=
mRequest
.
forget
(
)
;
RefPtr
<
ScriptLoader
>
loader
=
mLoader
.
forget
(
)
;
request
-
>
mOffThreadToken
=
mToken
;
nsresult
rv
=
loader
-
>
ProcessOffThreadRequest
(
request
)
;
return
rv
;
}
static
void
OffThreadScriptLoaderCallback
(
void
*
aToken
void
*
aCallbackData
)
{
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
aRunnable
=
dont_AddRef
(
static_cast
<
NotifyOffThreadScriptLoadCompletedRunnable
*
>
(
aCallbackData
)
)
;
aRunnable
-
>
SetToken
(
aToken
)
;
NotifyOffThreadScriptLoadCompletedRunnable
:
:
Dispatch
(
aRunnable
.
forget
(
)
)
;
}
nsresult
ScriptLoader
:
:
AttemptAsyncScriptCompile
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT_IF
(
!
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
IsReadyToRun
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
mWasCompiledOMT
)
;
if
(
aRequest
-
>
mIsInline
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
globalObject
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
nsresult
rv
=
FillCompileOptionsForRequest
(
jsapi
aRequest
global
&
options
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aRequest
-
>
IsSource
(
)
)
{
if
(
!
JS
:
:
CanCompileOffThread
(
cx
options
aRequest
-
>
mScriptText
.
length
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
if
(
!
JS
:
:
CanDecodeOffThread
(
cx
options
aRequest
-
>
mScriptBytecode
.
length
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
runnable
=
new
NotifyOffThreadScriptLoadCompletedRunnable
(
aRequest
this
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
if
(
!
JS
:
:
CompileOffThreadModule
(
cx
options
aRequest
-
>
mScriptText
.
begin
(
)
aRequest
-
>
mScriptText
.
length
(
)
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
if
(
aRequest
-
>
IsSource
(
)
)
{
if
(
!
JS
:
:
CompileOffThread
(
cx
options
aRequest
-
>
mScriptText
.
begin
(
)
aRequest
-
>
mScriptText
.
length
(
)
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsBytecode
(
)
)
;
if
(
!
JS
:
:
DecodeOffThreadScript
(
cx
options
aRequest
-
>
mScriptBytecode
aRequest
-
>
mBytecodeOffset
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
mDocument
-
>
BlockOnload
(
)
;
aRequest
-
>
mProgress
=
ScriptLoadRequest
:
:
Progress
:
:
Compiling
;
Unused
<
<
runnable
.
forget
(
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
CompileOffThreadOrProcessRequest
(
ScriptLoadRequest
*
aRequest
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
!
aRequest
-
>
mOffThreadToken
"
Candidate
for
off
-
thread
compile
is
already
parsed
off
-
thread
"
)
;
NS_ASSERTION
(
!
aRequest
-
>
InCompilingStage
(
)
"
Candidate
for
off
-
thread
compile
is
already
in
compiling
stage
.
"
)
;
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
return
ProcessRequest
(
aRequest
)
;
}
SourceBufferHolder
ScriptLoader
:
:
GetScriptSource
(
ScriptLoadRequest
*
aRequest
nsAutoString
&
inlineData
)
{
if
(
aRequest
-
>
mIsInline
)
{
aRequest
-
>
mElement
-
>
GetScriptText
(
inlineData
)
;
return
SourceBufferHolder
(
inlineData
.
get
(
)
inlineData
.
Length
(
)
SourceBufferHolder
:
:
NoOwnership
)
;
}
return
SourceBufferHolder
(
aRequest
-
>
mScriptText
.
begin
(
)
aRequest
-
>
mScriptText
.
length
(
)
SourceBufferHolder
:
:
NoOwnership
)
;
}
nsresult
ScriptLoader
:
:
ProcessRequest
(
ScriptLoadRequest
*
aRequest
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
aRequest
-
>
IsReadyToRun
(
)
"
Processing
a
request
that
is
not
ready
to
run
.
"
)
;
NS_ENSURE_ARG
(
aRequest
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
AsModuleRequest
(
)
-
>
mModuleScript
)
{
FireScriptAvailable
(
NS_ERROR_FAILURE
aRequest
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
scriptElem
=
do_QueryInterface
(
aRequest
-
>
mElement
)
;
nsCOMPtr
<
nsIDocument
>
doc
;
if
(
!
aRequest
-
>
mIsInline
)
{
doc
=
scriptElem
-
>
OwnerDoc
(
)
;
}
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
;
uint32_t
parserCreated
=
aRequest
-
>
mElement
-
>
GetParserCreated
(
)
;
if
(
parserCreated
)
{
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
mElement
;
}
aRequest
-
>
mElement
-
>
BeginEvaluating
(
)
;
FireScriptAvailable
(
NS_OK
aRequest
)
;
{
nsAutoMicroTask
mt
;
}
nsPIDOMWindowInner
*
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
bool
runScript
=
!
!
pwin
;
if
(
runScript
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
NS_LITERAL_STRING
(
"
beforescriptexecute
"
)
true
true
&
runScript
)
;
}
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
runScript
=
false
;
}
nsresult
rv
=
NS_OK
;
if
(
runScript
)
{
if
(
doc
)
{
doc
-
>
BeginEvaluatingExternalScript
(
)
;
}
rv
=
EvaluateScript
(
aRequest
)
;
if
(
doc
)
{
doc
-
>
EndEvaluatingExternalScript
(
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
NS_LITERAL_STRING
(
"
afterscriptexecute
"
)
true
false
)
;
}
FireScriptEvaluated
(
rv
aRequest
)
;
aRequest
-
>
mElement
-
>
EndEvaluating
(
)
;
if
(
parserCreated
)
{
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
if
(
aRequest
-
>
mOffThreadToken
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
aRequest
-
>
MaybeCancelOffThreadScript
(
)
;
}
aRequest
-
>
mScriptText
.
clearAndFree
(
)
;
return
rv
;
}
void
ScriptLoader
:
:
FireScriptAvailable
(
nsresult
aResult
ScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptAvailable
(
aResult
aRequest
-
>
mElement
aRequest
-
>
mIsInline
aRequest
-
>
mURI
aRequest
-
>
mLineNo
)
;
}
aRequest
-
>
FireScriptAvailable
(
aResult
)
;
}
void
ScriptLoader
:
:
FireScriptEvaluated
(
nsresult
aResult
ScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptEvaluated
(
aResult
aRequest
-
>
mElement
aRequest
-
>
mIsInline
)
;
}
aRequest
-
>
FireScriptEvaluated
(
aResult
)
;
}
already_AddRefed
<
nsIScriptGlobalObject
>
ScriptLoader
:
:
GetScriptGlobalObject
(
)
{
if
(
!
mDocument
)
{
return
nullptr
;
}
nsPIDOMWindowInner
*
pwin
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
do_QueryInterface
(
pwin
)
;
NS_ASSERTION
(
globalObject
"
windows
must
be
global
objects
"
)
;
nsresult
rv
=
globalObject
-
>
EnsureScriptEnvironment
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
globalObject
.
forget
(
)
;
}
nsresult
ScriptLoader
:
:
FillCompileOptionsForRequest
(
const
AutoJSAPI
&
jsapi
ScriptLoadRequest
*
aRequest
JS
:
:
Handle
<
JSObject
*
>
aScopeChain
JS
:
:
CompileOptions
*
aOptions
)
{
nsresult
rv
;
nsContentUtils
:
:
GetWrapperSafeScriptFilename
(
mDocument
aRequest
-
>
mURI
aRequest
-
>
mURL
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mDocument
)
{
mDocument
-
>
NoteScriptTrackingStatus
(
aRequest
-
>
mURL
aRequest
-
>
IsTracking
(
)
)
;
}
bool
isScriptElement
=
!
aRequest
-
>
IsModuleRequest
(
)
|
|
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
;
aOptions
-
>
setIntroductionType
(
isScriptElement
?
"
scriptElement
"
:
"
importedModule
"
)
;
aOptions
-
>
setFileAndLine
(
aRequest
-
>
mURL
.
get
(
)
aRequest
-
>
mLineNo
)
;
aOptions
-
>
setVersion
(
JSVersion
(
aRequest
-
>
mJSVersion
)
)
;
aOptions
-
>
setIsRunOnce
(
true
)
;
aOptions
-
>
setNoScriptRval
(
true
)
;
if
(
aRequest
-
>
mHasSourceMapURL
)
{
aOptions
-
>
setSourceMapURL
(
aRequest
-
>
mSourceMapURL
.
get
(
)
)
;
}
if
(
aRequest
-
>
mOriginPrincipal
)
{
nsIPrincipal
*
scriptPrin
=
nsContentUtils
:
:
ObjectPrincipal
(
aScopeChain
)
;
bool
subsumes
=
scriptPrin
-
>
Subsumes
(
aRequest
-
>
mOriginPrincipal
)
;
aOptions
-
>
setMutedErrors
(
!
subsumes
)
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
elementVal
(
cx
)
;
MOZ_ASSERT
(
aRequest
-
>
mElement
)
;
if
(
NS_SUCCEEDED
(
nsContentUtils
:
:
WrapNative
(
cx
aRequest
-
>
mElement
&
elementVal
true
)
)
)
{
MOZ_ASSERT
(
elementVal
.
isObject
(
)
)
;
aOptions
-
>
setElement
(
&
elementVal
.
toObject
(
)
)
;
}
return
NS_OK
;
}
bool
ScriptLoader
:
:
ShouldCacheBytecode
(
ScriptLoadRequest
*
aRequest
)
{
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
TimeDuration
;
if
(
!
aRequest
-
>
mCacheInfo
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
cache
anything
(
cacheInfo
=
%
p
)
"
aRequest
aRequest
-
>
mCacheInfo
.
get
(
)
)
)
;
return
false
;
}
int32_t
strategy
=
nsContentUtils
:
:
BytecodeCacheStrategy
(
)
;
bool
hasSourceLengthMin
=
false
;
bool
hasFetchCountMin
=
false
;
bool
hasTimeSinceLastFetched
=
false
;
size_t
sourceLengthMin
=
100
;
int32_t
fetchCountMin
=
5
;
TimeDuration
timeSinceLastFetched
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
strategy
=
%
d
.
"
aRequest
strategy
)
)
;
switch
(
strategy
)
{
case
-
2
:
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Encoding
disabled
.
"
aRequest
)
)
;
return
false
;
}
case
-
1
:
{
hasSourceLengthMin
=
false
;
hasFetchCountMin
=
false
;
hasTimeSinceLastFetched
=
false
;
break
;
}
default
:
case
0
:
{
hasSourceLengthMin
=
true
;
hasFetchCountMin
=
true
;
hasTimeSinceLastFetched
=
true
;
sourceLengthMin
=
1024
;
fetchCountMin
=
5
;
timeSinceLastFetched
=
TimeDuration
:
:
FromSeconds
(
72
*
3600
)
;
break
;
}
case
1
:
{
hasSourceLengthMin
=
true
;
hasFetchCountMin
=
true
;
hasTimeSinceLastFetched
=
false
;
sourceLengthMin
=
1024
;
fetchCountMin
=
5
;
break
;
}
case
2
:
{
hasSourceLengthMin
=
true
;
hasFetchCountMin
=
false
;
hasTimeSinceLastFetched
=
true
;
sourceLengthMin
=
1024
;
timeSinceLastFetched
=
TimeDuration
:
:
FromSeconds
(
72
*
3600
)
;
break
;
}
case
3
:
{
hasSourceLengthMin
=
false
;
hasFetchCountMin
=
true
;
hasTimeSinceLastFetched
=
true
;
fetchCountMin
=
5
;
timeSinceLastFetched
=
TimeDuration
:
:
FromSeconds
(
72
*
3600
)
;
break
;
}
case
4
:
{
hasSourceLengthMin
=
false
;
hasFetchCountMin
=
false
;
hasTimeSinceLastFetched
=
true
;
timeSinceLastFetched
=
TimeDuration
:
:
FromSeconds
(
72
*
3600
)
;
break
;
}
case
5
:
{
hasSourceLengthMin
=
false
;
hasFetchCountMin
=
true
;
hasTimeSinceLastFetched
=
false
;
fetchCountMin
=
5
;
break
;
}
case
6
:
{
hasSourceLengthMin
=
true
;
hasFetchCountMin
=
false
;
hasTimeSinceLastFetched
=
false
;
sourceLengthMin
=
1024
;
break
;
}
}
if
(
hasSourceLengthMin
&
&
aRequest
-
>
mScriptText
.
length
(
)
<
sourceLengthMin
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Script
is
too
small
.
"
aRequest
)
)
;
return
false
;
}
if
(
hasFetchCountMin
)
{
int32_t
fetchCount
=
0
;
if
(
NS_FAILED
(
aRequest
-
>
mCacheInfo
-
>
GetCacheTokenFetchCount
(
&
fetchCount
)
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Cannot
get
fetchCount
.
"
aRequest
)
)
;
return
false
;
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
fetchCount
=
%
d
.
"
aRequest
fetchCount
)
)
;
if
(
fetchCount
<
fetchCountMin
)
{
return
false
;
}
}
if
(
hasTimeSinceLastFetched
)
{
uint32_t
lastFetched
=
0
;
if
(
NS_FAILED
(
aRequest
-
>
mCacheInfo
-
>
GetCacheTokenLastFetched
(
&
lastFetched
)
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Cannot
get
lastFetched
.
"
aRequest
)
)
;
return
false
;
}
uint32_t
now
=
PR_Now
(
)
/
PR_USEC_PER_SEC
;
if
(
now
<
lastFetched
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
(
What
?
)
lastFetched
set
in
the
future
.
"
aRequest
)
)
;
return
false
;
}
TimeDuration
since
=
TimeDuration
:
:
FromSeconds
(
now
-
lastFetched
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
lastFetched
=
%
f
sec
.
ago
.
"
aRequest
since
.
ToSeconds
(
)
)
)
;
if
(
since
>
=
timeSinceLastFetched
)
{
return
false
;
}
}
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
Trigger
encoding
.
"
aRequest
)
)
;
return
true
;
}
nsresult
ScriptLoader
:
:
EvaluateScript
(
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
MOZ_ASSERT
(
aRequest
-
>
IsReadyToRun
(
)
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
scriptContent
(
do_QueryInterface
(
aRequest
-
>
mElement
)
)
;
nsIDocument
*
ownerDoc
=
scriptContent
-
>
OwnerDoc
(
)
;
if
(
ownerDoc
!
=
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
mDocument
-
>
SetDocumentIncCounter
(
IncCounter
:
:
eIncCounter_ScriptTag
)
;
NS_ASSERTION
(
scriptContent
"
no
content
-
what
is
default
script
-
type
?
"
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
JSVersion
version
=
JSVersion
(
aRequest
-
>
mJSVersion
)
;
if
(
version
=
=
JSVERSION_UNKNOWN
)
{
return
NS_OK
;
}
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
globalObject
"
<
script
>
element
"
true
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aes
.
cx
(
)
globalObject
-
>
GetGlobalJSObject
(
)
)
;
bool
oldProcessingScriptTag
=
context
-
>
GetProcessingScriptTag
(
)
;
context
-
>
SetProcessingScriptTag
(
true
)
;
nsresult
rv
;
{
AutoCurrentScriptUpdater
scriptUpdater
(
this
aRequest
-
>
mElement
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsBytecode
(
)
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Evaluate
Module
"
aRequest
)
)
;
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
MOZ_ASSERT
(
request
-
>
mModuleScript
)
;
MOZ_ASSERT
(
!
request
-
>
mOffThreadToken
)
;
ModuleScript
*
ms
=
request
-
>
mModuleScript
;
MOZ_ASSERT
(
!
ms
-
>
IsUninstantiated
(
)
)
;
if
(
ms
-
>
InstantiationFailed
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
aes
.
cx
(
)
ms
-
>
Exception
(
)
)
;
JS_SetPendingException
(
aes
.
cx
(
)
exception
)
;
rv
=
NS_ERROR_FAILURE
;
}
else
{
JS
:
:
Rooted
<
JSObject
*
>
module
(
aes
.
cx
(
)
ms
-
>
ModuleRecord
(
)
)
;
MOZ_ASSERT
(
module
)
;
rv
=
nsJSUtils
:
:
ModuleEvaluation
(
aes
.
cx
(
)
module
)
;
}
aRequest
-
>
mCacheInfo
=
nullptr
;
}
else
{
JS
:
:
CompileOptions
options
(
aes
.
cx
(
)
)
;
rv
=
FillCompileOptionsForRequest
(
aes
aRequest
global
&
options
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
aRequest
-
>
IsBytecode
(
)
)
{
TRACE_FOR_TEST
(
aRequest
-
>
mElement
"
scriptloader_execute
"
)
;
nsJSUtils
:
:
ExecutionContext
exec
(
aes
.
cx
(
)
global
)
;
if
(
aRequest
-
>
mOffThreadToken
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Decode
Bytecode
&
Join
and
Execute
"
aRequest
)
)
;
AutoTimer
<
DOM_SCRIPT_OFF_THREAD_DECODE_EXEC_MS
>
timer
;
rv
=
exec
.
DecodeJoinAndExec
(
&
aRequest
-
>
mOffThreadToken
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Decode
Bytecode
and
Execute
"
aRequest
)
)
;
AutoTimer
<
DOM_SCRIPT_MAIN_THREAD_DECODE_EXEC_MS
>
timer
;
rv
=
exec
.
DecodeAndExec
(
options
aRequest
-
>
mScriptBytecode
aRequest
-
>
mBytecodeOffset
)
;
}
MOZ_ASSERT
(
!
aRequest
-
>
mCacheInfo
)
;
}
else
{
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
JS
:
:
Rooted
<
JSScript
*
>
script
(
aes
.
cx
(
)
)
;
bool
encodeBytecode
=
ShouldCacheBytecode
(
aRequest
)
;
TimeStamp
start
;
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
if
(
aRequest
-
>
mCacheInfo
&
&
aRequest
-
>
mScriptText
.
length
(
)
>
=
1024
)
{
start
=
TimeStamp
:
:
Now
(
)
;
}
}
{
nsJSUtils
:
:
ExecutionContext
exec
(
aes
.
cx
(
)
global
)
;
exec
.
SetEncodeBytecode
(
encodeBytecode
)
;
TRACE_FOR_TEST
(
aRequest
-
>
mElement
"
scriptloader_execute
"
)
;
if
(
aRequest
-
>
mOffThreadToken
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Join
(
off
-
thread
parsing
)
and
Execute
"
aRequest
)
)
;
rv
=
exec
.
JoinAndExec
(
&
aRequest
-
>
mOffThreadToken
&
script
)
;
if
(
start
)
{
AccumulateTimeDelta
(
encodeBytecode
?
DOM_SCRIPT_OFF_THREAD_PARSE_ENCODE_EXEC_MS
:
DOM_SCRIPT_OFF_THREAD_PARSE_EXEC_MS
start
)
;
}
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Compile
And
Exec
"
aRequest
)
)
;
nsAutoString
inlineData
;
SourceBufferHolder
srcBuf
=
GetScriptSource
(
aRequest
inlineData
)
;
rv
=
exec
.
CompileAndExec
(
options
srcBuf
&
script
)
;
if
(
start
)
{
AccumulateTimeDelta
(
encodeBytecode
?
DOM_SCRIPT_MAIN_THREAD_PARSE_ENCODE_EXEC_MS
:
DOM_SCRIPT_MAIN_THREAD_PARSE_EXEC_MS
start
)
;
}
}
}
if
(
script
&
&
encodeBytecode
)
{
aRequest
-
>
mScript
=
script
;
HoldJSObjects
(
aRequest
)
;
TRACE_FOR_TEST
(
aRequest
-
>
mElement
"
scriptloader_encode
"
)
;
MOZ_ASSERT
(
aRequest
-
>
mBytecodeOffset
=
=
aRequest
-
>
mScriptBytecode
.
length
(
)
)
;
RegisterForBytecodeEncoding
(
aRequest
)
;
}
else
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
-
cache
:
disabled
(
rv
=
%
X
script
=
%
p
)
"
aRequest
unsigned
(
rv
)
script
.
get
(
)
)
)
;
TRACE_FOR_TEST_NONE
(
aRequest
-
>
mElement
"
scriptloader_no_encode
"
)
;
aRequest
-
>
mCacheInfo
=
nullptr
;
}
}
}
}
MaybeTriggerBytecodeEncoding
(
)
;
}
context
-
>
SetProcessingScriptTag
(
oldProcessingScriptTag
)
;
return
rv
;
}
void
ScriptLoader
:
:
RegisterForBytecodeEncoding
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mCacheInfo
)
;
MOZ_ASSERT
(
aRequest
-
>
mScript
)
;
mBytecodeEncodingQueue
.
AppendElement
(
aRequest
)
;
}
void
ScriptLoader
:
:
LoadEventFired
(
)
{
mLoadEventFired
=
true
;
MaybeTriggerBytecodeEncoding
(
)
;
}
void
ScriptLoader
:
:
MaybeTriggerBytecodeEncoding
(
)
{
if
(
!
mLoadEventFired
)
{
return
;
}
if
(
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
return
;
}
if
(
HasPendingRequests
(
)
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
encoder
=
NewRunnableMethod
(
"
ScriptLoader
:
:
EncodeBytecode
"
this
&
ScriptLoader
:
:
EncodeBytecode
)
;
if
(
NS_FAILED
(
NS_IdleDispatchToCurrentThread
(
encoder
.
forget
(
)
)
)
)
{
GiveUpBytecodeEncoding
(
)
;
}
}
void
ScriptLoader
:
:
EncodeBytecode
(
)
{
if
(
HasPendingRequests
(
)
)
{
return
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
GiveUpBytecodeEncoding
(
)
;
return
;
}
Telemetry
:
:
AutoTimer
<
Telemetry
:
:
DOM_SCRIPT_ENCODING_MS_PER_DOCUMENT
>
timer
;
AutoEntryScript
aes
(
globalObject
"
encode
bytecode
"
true
)
;
RefPtr
<
ScriptLoadRequest
>
request
;
while
(
!
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
request
=
mBytecodeEncodingQueue
.
StealFirst
(
)
;
EncodeRequestBytecode
(
aes
.
cx
(
)
request
)
;
request
-
>
mScriptBytecode
.
clearAndFree
(
)
;
request
-
>
DropBytecodeCacheReferences
(
)
;
}
}
void
ScriptLoader
:
:
EncodeRequestBytecode
(
JSContext
*
aCx
ScriptLoadRequest
*
aRequest
)
{
using
namespace
mozilla
:
:
Telemetry
;
nsresult
rv
=
NS_OK
;
MOZ_ASSERT
(
aRequest
-
>
mCacheInfo
)
;
auto
bytecodeFailed
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
TRACE_FOR_TEST_NONE
(
aRequest
-
>
mElement
"
scriptloader_bytecode_failed
"
)
;
}
)
;
JS
:
:
RootedScript
script
(
aCx
aRequest
-
>
mScript
)
;
if
(
!
JS
:
:
FinishIncrementalEncoding
(
aCx
script
aRequest
-
>
mScriptBytecode
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
serialize
bytecode
"
aRequest
)
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_ENCODING_STATUS
:
:
EncodingFailure
)
;
return
;
}
if
(
aRequest
-
>
mScriptBytecode
.
length
(
)
>
=
UINT32_MAX
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Bytecode
cache
is
too
large
to
be
decoded
correctly
.
"
aRequest
)
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_ENCODING_STATUS
:
:
BufferTooLarge
)
;
return
;
}
nsCOMPtr
<
nsIOutputStream
>
output
;
rv
=
aRequest
-
>
mCacheInfo
-
>
OpenAlternativeOutputStream
(
nsContentUtils
:
:
JSBytecodeMimeType
(
)
getter_AddRefs
(
output
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
open
bytecode
cache
(
rv
=
%
X
output
=
%
p
)
"
aRequest
unsigned
(
rv
)
output
.
get
(
)
)
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_ENCODING_STATUS
:
:
OpenFailure
)
;
return
;
}
MOZ_ASSERT
(
output
)
;
auto
closeOutStream
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
nsresult
rv
=
output
-
>
Close
(
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Closing
(
rv
=
%
X
)
"
aRequest
unsigned
(
rv
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_ENCODING_STATUS
:
:
CloseFailure
)
;
}
}
)
;
uint32_t
n
;
rv
=
output
-
>
Write
(
reinterpret_cast
<
char
*
>
(
aRequest
-
>
mScriptBytecode
.
begin
(
)
)
aRequest
-
>
mScriptBytecode
.
length
(
)
&
n
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Write
bytecode
cache
(
rv
=
%
X
length
=
%
u
written
=
%
u
)
"
aRequest
unsigned
(
rv
)
unsigned
(
aRequest
-
>
mScriptBytecode
.
length
(
)
)
n
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
AccumulateCategorical
(
LABELS_DOM_SCRIPT_ENCODING_STATUS
:
:
WriteFailure
)
;
return
;
}
bytecodeFailed
.
release
(
)
;
TRACE_FOR_TEST_NONE
(
aRequest
-
>
mElement
"
scriptloader_bytecode_saved
"
)
;
AccumulateCategorical
(
LABELS_DOM_SCRIPT_ENCODING_STATUS
:
:
EncodingSuccess
)
;
}
void
ScriptLoader
:
:
GiveUpBytecodeEncoding
(
)
{
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
Maybe
<
AutoEntryScript
>
aes
;
if
(
globalObject
)
{
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
context
)
{
aes
.
emplace
(
globalObject
"
give
-
up
bytecode
encoding
"
true
)
;
}
}
while
(
!
mBytecodeEncodingQueue
.
isEmpty
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
request
=
mBytecodeEncodingQueue
.
StealFirst
(
)
;
LOG
(
(
"
ScriptLoadRequest
(
%
p
)
:
Cannot
serialize
bytecode
"
request
.
get
(
)
)
)
;
TRACE_FOR_TEST_NONE
(
request
-
>
mElement
"
scriptloader_bytecode_failed
"
)
;
if
(
aes
.
isSome
(
)
)
{
JS
:
:
RootedScript
script
(
aes
-
>
cx
(
)
request
-
>
mScript
)
;
Unused
<
<
JS
:
:
FinishIncrementalEncoding
(
aes
-
>
cx
(
)
script
request
-
>
mScriptBytecode
)
;
}
request
-
>
mScriptBytecode
.
clearAndFree
(
)
;
request
-
>
DropBytecodeCacheReferences
(
)
;
}
}
bool
ScriptLoader
:
:
HasPendingRequests
(
)
{
return
mParserBlockingRequest
|
|
!
mXSLTRequests
.
isEmpty
(
)
|
|
!
mLoadedAsyncRequests
.
isEmpty
(
)
|
|
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
|
|
!
mDeferRequests
.
isEmpty
(
)
|
|
!
mPendingChildLoaders
.
IsEmpty
(
)
;
}
void
ScriptLoader
:
:
ProcessPendingRequestsAsync
(
)
{
if
(
HasPendingRequests
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
NewRunnableMethod
(
"
dom
:
:
ScriptLoader
:
:
ProcessPendingRequests
"
this
&
ScriptLoader
:
:
ProcessPendingRequests
)
;
if
(
mDocument
)
{
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Other
task
.
forget
(
)
)
;
}
else
{
NS_DispatchToCurrentThread
(
task
.
forget
(
)
)
;
}
}
}
void
ScriptLoader
:
:
ProcessPendingRequests
(
)
{
RefPtr
<
ScriptLoadRequest
>
request
;
if
(
mParserBlockingRequest
&
&
mParserBlockingRequest
-
>
IsReadyToRun
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
request
.
swap
(
mParserBlockingRequest
)
;
UnblockParser
(
request
)
;
ProcessRequest
(
request
)
;
if
(
request
-
>
mWasCompiledOMT
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
}
ContinueParserAsync
(
request
)
;
}
while
(
ReadyToExecuteParserBlockingScripts
(
)
&
&
!
mXSLTRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mXSLTRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mLoadedAsyncRequests
.
isEmpty
(
)
)
{
request
=
mLoadedAsyncRequests
.
StealFirst
(
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
ProcessRequest
(
request
)
;
}
else
{
CompileOffThreadOrProcessRequest
(
request
)
;
}
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mNonAsyncExternalScriptInsertedRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
if
(
mDocumentParsingDone
&
&
mXSLTRequests
.
isEmpty
(
)
)
{
while
(
ReadyToExecuteScripts
(
)
&
&
!
mDeferRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mDeferRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
}
while
(
!
mPendingChildLoaders
.
IsEmpty
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
RefPtr
<
ScriptLoader
>
child
=
mPendingChildLoaders
[
0
]
;
mPendingChildLoaders
.
RemoveElementAt
(
0
)
;
child
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
if
(
mDocumentParsingDone
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
&
&
MaybeRemovedDeferRequests
(
)
)
{
return
ProcessPendingRequests
(
)
;
}
if
(
mDocumentParsingDone
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mLoadingAsyncRequests
.
isEmpty
(
)
&
&
mLoadedAsyncRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
)
{
mDocumentParsingDone
=
false
;
mDocument
-
>
UnblockOnload
(
true
)
;
}
}
bool
ScriptLoader
:
:
ReadyToExecuteParserBlockingScripts
(
)
{
if
(
!
SelfReadyToExecuteParserBlockingScripts
(
)
)
{
return
false
;
}
for
(
nsIDocument
*
doc
=
mDocument
;
doc
;
doc
=
doc
-
>
GetParentDocument
(
)
)
{
ScriptLoader
*
ancestor
=
doc
-
>
ScriptLoader
(
)
;
if
(
!
ancestor
-
>
SelfReadyToExecuteParserBlockingScripts
(
)
&
&
ancestor
-
>
AddPendingChildLoader
(
this
)
)
{
AddParserBlockingScriptExecutionBlocker
(
)
;
return
false
;
}
}
return
true
;
}
nsresult
ScriptLoader
:
:
ConvertToUTF16
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
nsIDocument
*
aDocument
char16_t
*
&
aBufOut
size_t
&
aLengthOut
)
{
if
(
!
aLength
)
{
aBufOut
=
nullptr
;
aLengthOut
=
0
;
return
NS_OK
;
}
auto
data
=
MakeSpan
(
aData
aLength
)
;
UniquePtr
<
Decoder
>
unicodeDecoder
;
const
Encoding
*
encoding
;
size_t
bomLength
;
Tie
(
encoding
bomLength
)
=
Encoding
:
:
ForBOM
(
data
)
;
if
(
encoding
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithBOMRemoval
(
)
;
}
if
(
!
unicodeDecoder
&
&
aChannel
)
{
nsAutoCString
label
;
if
(
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
label
)
)
&
&
(
encoding
=
Encoding
:
:
ForLabel
(
label
)
)
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
}
if
(
!
unicodeDecoder
&
&
(
encoding
=
Encoding
:
:
ForLabel
(
aHintCharset
)
)
)
{
unicodeDecoder
=
encoding
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
if
(
!
unicodeDecoder
&
&
aDocument
)
{
unicodeDecoder
=
aDocument
-
>
GetDocumentCharacterSet
(
)
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
if
(
!
unicodeDecoder
)
{
unicodeDecoder
=
WINDOWS_1252_ENCODING
-
>
NewDecoderWithoutBOMHandling
(
)
;
}
CheckedInt
<
size_t
>
unicodeLength
=
unicodeDecoder
-
>
MaxUTF16BufferLength
(
aLength
)
;
if
(
!
unicodeLength
.
isValid
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aBufOut
=
static_cast
<
char16_t
*
>
(
js_malloc
(
unicodeLength
.
value
(
)
*
sizeof
(
char16_t
)
)
)
;
if
(
!
aBufOut
)
{
aLengthOut
=
0
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
uint32_t
result
;
size_t
read
;
size_t
written
;
bool
hadErrors
;
Tie
(
result
read
written
hadErrors
)
=
unicodeDecoder
-
>
DecodeToUTF16
(
data
MakeSpan
(
aBufOut
unicodeLength
.
value
(
)
)
true
)
;
MOZ_ASSERT
(
result
=
=
kInputEmpty
)
;
MOZ_ASSERT
(
read
=
=
aLength
)
;
MOZ_ASSERT
(
written
<
=
unicodeLength
.
value
(
)
)
;
Unused
<
<
hadErrors
;
aLengthOut
=
written
;
nsAutoCString
charset
;
unicodeDecoder
-
>
Encoding
(
)
-
>
Name
(
charset
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
DOM_SCRIPT_SRC_ENCODING
charset
)
;
return
NS_OK
;
}
nsresult
ScriptLoader
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
ScriptLoadRequest
*
aRequest
nsresult
aChannelStatus
nsresult
aSRIStatus
mozilla
:
:
dom
:
:
SRICheckDataVerifier
*
aSRIDataVerifier
)
{
NS_ASSERTION
(
aRequest
"
null
request
in
stream
complete
handler
"
)
;
NS_ENSURE_TRUE
(
aRequest
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIRequest
>
channelRequest
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channelRequest
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
channel
=
do_QueryInterface
(
channelRequest
)
;
nsresult
rv
=
NS_OK
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
&
&
NS_SUCCEEDED
(
(
rv
=
aSRIStatus
)
)
)
{
MOZ_ASSERT
(
aSRIDataVerifier
)
;
MOZ_ASSERT
(
mReporter
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
rv
=
aSRIDataVerifier
-
>
Verify
(
aRequest
-
>
mIntegrity
channel
sourceUri
mReporter
)
;
if
(
channelRequest
)
{
mReporter
-
>
FlushReportsToConsole
(
nsContentUtils
:
:
GetInnerWindowID
(
channelRequest
)
)
;
}
else
{
mReporter
-
>
FlushConsoleReports
(
mDocument
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_ERROR_SRI_CORRUPT
;
}
}
else
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
&
&
loadInfo
-
>
GetEnforceSRI
(
)
)
{
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
ScriptLoader
:
:
OnStreamComplete
required
SRI
not
found
"
)
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
loadInfo
-
>
LoadingPrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
nsAutoCString
violationURISpec
;
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
violationURISpec
)
;
uint32_t
lineNo
=
aRequest
-
>
mElement
?
aRequest
-
>
mElement
-
>
GetScriptLineNumber
(
)
:
0
;
csp
-
>
LogViolationDetails
(
nsIContentSecurityPolicy
:
:
VIOLATION_TYPE_REQUIRE_SRI_FOR_SCRIPT
NS_ConvertUTF8toUTF16
(
violationURISpec
)
EmptyString
(
)
lineNo
EmptyString
(
)
EmptyString
(
)
)
;
rv
=
NS_ERROR_SRI_CORRUPT
;
}
}
bool
sriOk
=
NS_SUCCEEDED
(
rv
)
;
if
(
sriOk
&
&
aRequest
-
>
IsSource
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
mScriptBytecode
.
empty
(
)
)
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
&
&
aSRIDataVerifier
-
>
IsComplete
(
)
)
{
uint32_t
len
=
aSRIDataVerifier
-
>
DataSummaryLength
(
)
;
if
(
!
aRequest
-
>
mScriptBytecode
.
growBy
(
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aRequest
-
>
mBytecodeOffset
=
len
;
DebugOnly
<
nsresult
>
res
=
aSRIDataVerifier
-
>
ExportDataSummary
(
aRequest
-
>
mScriptBytecode
.
length
(
)
aRequest
-
>
mScriptBytecode
.
begin
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
res
)
)
;
}
else
{
uint32_t
len
=
SRICheckDataVerifier
:
:
EmptyDataSummaryLength
(
)
;
if
(
!
aRequest
-
>
mScriptBytecode
.
growBy
(
len
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aRequest
-
>
mBytecodeOffset
=
len
;
DebugOnly
<
nsresult
>
res
=
SRICheckDataVerifier
:
:
ExportEmptyDataSummary
(
aRequest
-
>
mScriptBytecode
.
length
(
)
aRequest
-
>
mScriptBytecode
.
begin
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
res
)
)
;
}
mozilla
:
:
DebugOnly
<
uint32_t
>
srilen
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
SRICheckDataVerifier
:
:
DataSummaryLength
(
aRequest
-
>
mScriptBytecode
.
length
(
)
aRequest
-
>
mScriptBytecode
.
begin
(
)
&
srilen
)
)
)
;
MOZ_ASSERT
(
srilen
=
=
aRequest
-
>
mBytecodeOffset
)
;
}
if
(
sriOk
)
{
rv
=
PrepareLoadedRequest
(
aRequest
aLoader
aChannelStatus
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
sriOk
&
&
aRequest
-
>
mElement
)
{
uint32_t
lineNo
=
aRequest
-
>
mElement
-
>
GetScriptLineNumber
(
)
;
nsAutoString
url
;
if
(
aRequest
-
>
mURI
)
{
AppendUTF8toUTF16
(
aRequest
-
>
mURI
-
>
GetSpecOrDefault
(
)
url
)
;
}
const
char16_t
*
params
[
]
=
{
url
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Script
Loader
"
)
mDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
ScriptSourceLoadFailed
"
params
ArrayLength
(
params
)
nullptr
EmptyString
(
)
lineNo
)
;
}
if
(
rv
=
=
NS_ERROR_TRACKING_URI
)
{
nsCOMPtr
<
nsIContent
>
cont
=
do_QueryInterface
(
aRequest
-
>
mElement
)
;
mDocument
-
>
AddBlockedTrackingNode
(
cont
)
;
}
if
(
aChannelStatus
=
=
NS_BINDING_RETARGETED
)
{
}
else
if
(
aRequest
-
>
mIsDefer
)
{
MOZ_ASSERT_IF
(
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mDeferRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
aRequest
-
>
mIsAsync
)
{
MOZ_ASSERT_IF
(
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
aRequest
-
>
mIsNonAsyncScriptInserted
)
{
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mNonAsyncExternalScriptInsertedRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
aRequest
-
>
mIsXSLT
)
{
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mXSLTRequests
.
Steal
(
aRequest
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
ModuleLoadRequest
*
modReq
=
aRequest
-
>
AsModuleRequest
(
)
;
MOZ_ASSERT
(
!
modReq
-
>
IsTopLevel
(
)
)
;
MOZ_ASSERT
(
!
modReq
-
>
isInList
(
)
)
;
modReq
-
>
Cancel
(
)
;
FireScriptAvailable
(
rv
aRequest
)
;
}
else
if
(
mParserBlockingRequest
=
=
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
isInList
(
)
)
;
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
aRequest
)
;
MOZ_ASSERT
(
aRequest
-
>
mElement
-
>
GetParserCreated
(
)
)
;
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
mElement
;
FireScriptAvailable
(
rv
aRequest
)
;
ContinueParserAsync
(
aRequest
)
;
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
else
{
mPreloads
.
RemoveElement
(
aRequest
PreloadRequestComparator
(
)
)
;
}
}
ProcessPendingRequests
(
)
;
return
NS_OK
;
}
void
ScriptLoader
:
:
UnblockParser
(
ScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
mElement
-
>
UnblockParser
(
)
;
}
void
ScriptLoader
:
:
ContinueParserAsync
(
ScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
mElement
-
>
ContinueParserAsync
(
)
;
}
uint32_t
ScriptLoader
:
:
NumberOfProcessors
(
)
{
if
(
mNumberOfProcessors
>
0
)
return
mNumberOfProcessors
;
int32_t
numProcs
=
PR_GetNumberOfProcessors
(
)
;
if
(
numProcs
>
0
)
mNumberOfProcessors
=
numProcs
;
return
mNumberOfProcessors
;
}
void
ScriptLoader
:
:
MaybeMoveToLoadedList
(
ScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsReadyToRun
(
)
)
;
if
(
aRequest
-
>
mIsAsync
)
{
MOZ_ASSERT
(
aRequest
-
>
isInList
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
mLoadedAsyncRequests
.
AppendElement
(
req
)
;
}
}
}
nsresult
ScriptLoader
:
:
PrepareLoadedRequest
(
ScriptLoadRequest
*
aRequest
nsIIncrementalStreamLoader
*
aLoader
nsresult
aStatus
)
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
aStatus
;
}
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
NS_BINDING_ABORTED
;
}
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
CollectScriptTelemetry
(
aLoader
aRequest
)
;
if
(
!
mDocument
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
req
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
rv
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
requestSucceeded
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
sourceMapURL
;
if
(
nsContentUtils
:
:
GetSourceMapURL
(
httpChannel
sourceMapURL
)
)
{
aRequest
-
>
mHasSourceMapURL
=
true
;
aRequest
-
>
mSourceMapURL
=
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
;
}
if
(
httpChannel
-
>
GetIsTrackingResource
(
)
)
{
aRequest
-
>
SetIsTracking
(
)
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
aRequest
-
>
mCORSMode
=
=
CORS_NONE
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
aRequest
-
>
mOriginPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ASSERTION
(
mDeferRequests
.
Contains
(
aRequest
)
|
|
mLoadingAsyncRequests
.
Contains
(
aRequest
)
|
|
mNonAsyncExternalScriptInsertedRequests
.
Contains
(
aRequest
)
|
|
mXSLTRequests
.
Contains
(
aRequest
)
|
|
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
&
&
!
aRequest
-
>
isInList
(
)
)
|
|
mPreloads
.
Contains
(
aRequest
PreloadRequestComparator
(
)
)
|
|
mParserBlockingRequest
"
aRequest
should
be
pending
!
"
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
IsSource
(
)
)
;
ModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
nsAutoCString
mimeType
;
channel
-
>
GetContentType
(
mimeType
)
;
NS_ConvertUTF8toUTF16
typeString
(
mimeType
)
;
if
(
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
typeString
)
)
{
return
NS_ERROR_FAILURE
;
}
channel
-
>
GetURI
(
getter_AddRefs
(
request
-
>
mBaseURL
)
)
;
rv
=
AttemptAsyncScriptCompile
(
request
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
return
ProcessFetchedModuleSource
(
request
)
;
}
aRequest
-
>
SetReady
(
)
;
if
(
aRequest
=
=
mParserBlockingRequest
&
&
NumberOfProcessors
(
)
>
1
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
)
;
if
(
rv
=
=
NS_OK
)
{
MOZ_ASSERT
(
aRequest
-
>
mProgress
=
=
ScriptLoadRequest
:
:
Progress
:
:
Compiling
"
Request
should
be
off
-
thread
compiling
now
.
"
)
;
return
NS_OK
;
}
if
(
rv
!
=
NS_ERROR_FAILURE
)
{
return
rv
;
}
}
MaybeMoveToLoadedList
(
aRequest
)
;
return
NS_OK
;
}
void
ScriptLoader
:
:
ParsingComplete
(
bool
aTerminated
)
{
if
(
mDeferEnabled
)
{
mDocumentParsingDone
=
true
;
}
mDeferEnabled
=
false
;
if
(
aTerminated
)
{
mDeferRequests
.
Clear
(
)
;
mLoadingAsyncRequests
.
Clear
(
)
;
mLoadedAsyncRequests
.
Clear
(
)
;
mNonAsyncExternalScriptInsertedRequests
.
Clear
(
)
;
mXSLTRequests
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
Cancel
(
)
;
mParserBlockingRequest
=
nullptr
;
}
}
ProcessPendingRequests
(
)
;
}
void
ScriptLoader
:
:
PreloadURI
(
nsIURI
*
aURI
const
nsAString
&
aCharset
const
nsAString
&
aType
const
nsAString
&
aCrossOrigin
const
nsAString
&
aIntegrity
bool
aScriptFromHead
const
mozilla
:
:
net
:
:
ReferrerPolicy
aReferrerPolicy
)
{
NS_ENSURE_TRUE_VOID
(
mDocument
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
;
}
if
(
ModuleScriptsEnabled
(
)
&
&
aType
.
LowerCaseEqualsASCII
(
"
module
"
)
)
{
return
;
}
SRIMetadata
sriMetadata
;
if
(
!
aIntegrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
ScriptLoader
:
:
PreloadURI
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrity
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
aIntegrity
sourceUri
mReporter
&
sriMetadata
)
;
}
RefPtr
<
ScriptLoadRequest
>
request
=
CreateLoadRequest
(
ScriptKind
:
:
Classic
nullptr
0
Element
:
:
StringToCORSMode
(
aCrossOrigin
)
sriMetadata
)
;
request
-
>
mURI
=
aURI
;
request
-
>
mIsInline
=
false
;
request
-
>
mReferrerPolicy
=
aReferrerPolicy
;
request
-
>
mScriptFromHead
=
aScriptFromHead
;
nsresult
rv
=
StartLoad
(
request
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
PreloadInfo
*
pi
=
mPreloads
.
AppendElement
(
)
;
pi
-
>
mRequest
=
request
;
pi
-
>
mCharset
=
aCharset
;
}
void
ScriptLoader
:
:
AddDeferRequest
(
ScriptLoadRequest
*
aRequest
)
{
aRequest
-
>
mIsDefer
=
true
;
mDeferRequests
.
AppendElement
(
aRequest
)
;
if
(
mDeferEnabled
&
&
aRequest
=
=
mDeferRequests
.
getFirst
(
)
&
&
mDocument
&
&
!
mBlockingDOMContentLoaded
)
{
MOZ_ASSERT
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
nsIDocument
:
:
READYSTATE_LOADING
)
;
mBlockingDOMContentLoaded
=
true
;
mDocument
-
>
BlockDOMContentLoaded
(
)
;
}
}
bool
ScriptLoader
:
:
MaybeRemovedDeferRequests
(
)
{
if
(
mDeferRequests
.
isEmpty
(
)
&
&
mDocument
&
&
mBlockingDOMContentLoaded
)
{
mBlockingDOMContentLoaded
=
false
;
mDocument
-
>
UnblockDOMContentLoaded
(
)
;
return
true
;
}
return
false
;
}
#
undef
TRACE_FOR_TEST
#
undef
TRACE_FOR_TEST_BOOL
#
undef
TRACE_FOR_TEST_NONE
#
undef
LOG
}
}
