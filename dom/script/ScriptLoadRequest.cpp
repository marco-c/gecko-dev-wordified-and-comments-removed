#
include
"
ModuleLoadRequest
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
ScriptLoadRequest
.
h
"
#
include
"
ScriptSettings
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ScriptLoadRequest
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCacheInfo
)
tmp
-
>
DropBytecodeCacheReferences
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
ScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCacheInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
ScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mScript
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
ScriptLoadRequest
:
:
ScriptLoadRequest
(
ScriptKind
aKind
nsIURI
*
aURI
nsIScriptElement
*
aElement
ValidJSVersion
aValidJSVersion
mozilla
:
:
CORSMode
aCORSMode
const
mozilla
:
:
dom
:
:
SRIMetadata
&
aIntegrity
)
:
mKind
(
aKind
)
mElement
(
aElement
)
mScriptFromHead
(
false
)
mProgress
(
Progress
:
:
Loading
)
mDataType
(
DataType
:
:
Unknown
)
mIsInline
(
true
)
mHasSourceMapURL
(
false
)
mIsDefer
(
false
)
mIsAsync
(
false
)
mPreloadAsAsync
(
false
)
mPreloadAsDefer
(
false
)
mIsNonAsyncScriptInserted
(
false
)
mIsXSLT
(
false
)
mIsCanceled
(
false
)
mWasCompiledOMT
(
false
)
mIsTracking
(
false
)
mOffThreadToken
(
nullptr
)
mScriptText
(
)
mScriptBytecode
(
)
mBytecodeOffset
(
0
)
mValidJSVersion
(
aValidJSVersion
)
mURI
(
aURI
)
mLineNo
(
1
)
mCORSMode
(
aCORSMode
)
mIntegrity
(
aIntegrity
)
mReferrerPolicy
(
mozilla
:
:
net
:
:
RP_Unset
)
{
}
ScriptLoadRequest
:
:
~
ScriptLoadRequest
(
)
{
MOZ_ASSERT
(
!
mOffThreadToken
)
;
MaybeCancelOffThreadScript
(
)
;
if
(
mScript
)
{
DropBytecodeCacheReferences
(
)
;
}
}
void
ScriptLoadRequest
:
:
SetReady
(
)
{
MOZ_ASSERT
(
mProgress
!
=
Progress
:
:
Ready
)
;
mProgress
=
Progress
:
:
Ready
;
}
void
ScriptLoadRequest
:
:
Cancel
(
)
{
MaybeCancelOffThreadScript
(
)
;
mIsCanceled
=
true
;
}
void
ScriptLoadRequest
:
:
MaybeCancelOffThreadScript
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mOffThreadToken
)
{
return
;
}
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
if
(
IsModuleRequest
(
)
)
{
JS
:
:
CancelOffThreadModule
(
cx
mOffThreadToken
)
;
}
else
if
(
IsSource
(
)
)
{
JS
:
:
CancelOffThreadScript
(
cx
mOffThreadToken
)
;
}
else
{
MOZ_ASSERT
(
IsBytecode
(
)
)
;
JS
:
:
CancelOffThreadScriptDecoder
(
cx
mOffThreadToken
)
;
}
mOffThreadToken
=
nullptr
;
}
void
ScriptLoadRequest
:
:
DropBytecodeCacheReferences
(
)
{
mCacheInfo
=
nullptr
;
mScript
=
nullptr
;
DropJSObjects
(
this
)
;
}
inline
ModuleLoadRequest
*
ScriptLoadRequest
:
:
AsModuleRequest
(
)
{
MOZ_ASSERT
(
IsModuleRequest
(
)
)
;
return
static_cast
<
ModuleLoadRequest
*
>
(
this
)
;
}
ScriptLoadRequestList
:
:
~
ScriptLoadRequestList
(
)
{
Clear
(
)
;
}
void
ScriptLoadRequestList
:
:
Clear
(
)
{
while
(
!
isEmpty
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
first
=
StealFirst
(
)
;
first
-
>
Cancel
(
)
;
}
}
#
ifdef
DEBUG
bool
ScriptLoadRequestList
:
:
Contains
(
ScriptLoadRequest
*
aElem
)
const
{
for
(
const
ScriptLoadRequest
*
req
=
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
if
(
req
=
=
aElem
)
{
return
true
;
}
}
return
false
;
}
#
endif
inline
void
ImplCycleCollectionUnlink
(
ScriptLoadRequestList
&
aField
)
{
while
(
!
aField
.
isEmpty
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
first
=
aField
.
StealFirst
(
)
;
}
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ScriptLoadRequestList
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
for
(
ScriptLoadRequest
*
request
=
aField
.
getFirst
(
)
;
request
;
request
=
request
-
>
getNext
(
)
)
{
CycleCollectionNoteChild
(
aCallback
request
aName
aFlags
)
;
}
}
}
}
