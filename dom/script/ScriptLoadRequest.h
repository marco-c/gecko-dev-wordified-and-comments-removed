#
ifndef
mozilla_dom_ScriptLoadRequest_h
#
define
mozilla_dom_ScriptLoadRequest_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
SRIMetadata
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PreloaderBase
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
ScriptKind
.
h
"
class
nsICacheInfoChannel
;
namespace
mozilla
{
namespace
dom
{
class
ModuleLoadRequest
;
class
ScriptLoadRequestList
;
class
ScriptFetchOptions
{
~
ScriptFetchOptions
(
)
;
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
ScriptFetchOptions
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
ScriptFetchOptions
)
ScriptFetchOptions
(
mozilla
:
:
CORSMode
aCORSMode
enum
ReferrerPolicy
aReferrerPolicy
Element
*
aElement
nsIPrincipal
*
aTriggeringPrincipal
)
;
const
mozilla
:
:
CORSMode
mCORSMode
;
const
enum
ReferrerPolicy
mReferrerPolicy
;
bool
mIsPreload
;
nsCOMPtr
<
Element
>
mElement
;
nsCOMPtr
<
nsIPrincipal
>
mTriggeringPrincipal
;
}
;
class
ScriptLoadRequest
:
public
PreloaderBase
private
mozilla
:
:
LinkedListElement
<
ScriptLoadRequest
>
{
typedef
LinkedListElement
<
ScriptLoadRequest
>
super
;
friend
class
mozilla
:
:
LinkedListElement
<
ScriptLoadRequest
>
;
friend
class
ScriptLoadRequestList
;
protected
:
virtual
~
ScriptLoadRequest
(
)
;
public
:
ScriptLoadRequest
(
ScriptKind
aKind
nsIURI
*
aURI
ScriptFetchOptions
*
aFetchOptions
const
SRIMetadata
&
aIntegrity
nsIURI
*
aReferrer
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ScriptLoadRequest
)
static
void
PrioritizeAsPreload
(
nsIChannel
*
aChannel
)
;
virtual
void
PrioritizeAsPreload
(
)
override
;
bool
IsModuleRequest
(
)
const
{
return
mKind
=
=
ScriptKind
:
:
eModule
;
}
ModuleLoadRequest
*
AsModuleRequest
(
)
;
#
ifdef
MOZ_GECKO_PROFILER
TimeStamp
mOffThreadParseStartTime
;
TimeStamp
mOffThreadParseStopTime
;
#
endif
void
FireScriptAvailable
(
nsresult
aResult
)
{
bool
isInlineClassicScript
=
mIsInline
&
&
!
IsModuleRequest
(
)
;
GetScriptElement
(
)
-
>
ScriptAvailable
(
aResult
GetScriptElement
(
)
isInlineClassicScript
mURI
mLineNo
)
;
}
void
FireScriptEvaluated
(
nsresult
aResult
)
{
GetScriptElement
(
)
-
>
ScriptEvaluated
(
aResult
GetScriptElement
(
)
mIsInline
)
;
}
bool
IsPreload
(
)
const
{
MOZ_ASSERT_IF
(
mFetchOptions
-
>
mIsPreload
!
GetScriptElement
(
)
)
;
return
mFetchOptions
-
>
mIsPreload
;
}
virtual
void
Cancel
(
)
;
bool
IsCanceled
(
)
const
{
return
mIsCanceled
;
}
virtual
void
SetReady
(
)
;
JS
:
:
OffThreadToken
*
*
OffThreadTokenPtr
(
)
{
return
mOffThreadToken
?
&
mOffThreadToken
:
nullptr
;
}
bool
IsTracking
(
)
const
{
return
mIsTracking
;
}
void
SetIsTracking
(
)
{
MOZ_ASSERT
(
!
mIsTracking
)
;
mIsTracking
=
true
;
}
void
BlockOnload
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
!
mLoadBlockedDocument
)
;
aDocument
-
>
BlockOnload
(
)
;
mLoadBlockedDocument
=
aDocument
;
}
void
MaybeUnblockOnload
(
)
{
if
(
mLoadBlockedDocument
)
{
mLoadBlockedDocument
-
>
UnblockOnload
(
false
)
;
mLoadBlockedDocument
=
nullptr
;
}
}
enum
class
Progress
:
uint8_t
{
eLoading
eLoading_Source
eCompiling
eFetchingImports
eReady
}
;
bool
IsReadyToRun
(
)
const
{
return
mProgress
=
=
Progress
:
:
eReady
;
}
bool
IsLoading
(
)
const
{
return
mProgress
=
=
Progress
:
:
eLoading
|
|
mProgress
=
=
Progress
:
:
eLoading_Source
;
}
bool
IsLoadingSource
(
)
const
{
return
mProgress
=
=
Progress
:
:
eLoading_Source
;
}
bool
InCompilingStage
(
)
const
{
return
mProgress
=
=
Progress
:
:
eCompiling
|
|
(
IsReadyToRun
(
)
&
&
mWasCompiledOMT
)
;
}
enum
class
DataType
:
uint8_t
{
eUnknown
eTextSource
eBinASTSource
eBytecode
}
;
bool
IsUnknownDataType
(
)
const
{
return
mDataType
=
=
DataType
:
:
eUnknown
;
}
bool
IsTextSource
(
)
const
{
return
mDataType
=
=
DataType
:
:
eTextSource
;
}
bool
IsBinASTSource
(
)
const
{
return
false
;
}
bool
IsSource
(
)
const
{
return
IsTextSource
(
)
|
|
IsBinASTSource
(
)
;
}
bool
IsBytecode
(
)
const
{
return
mDataType
=
=
DataType
:
:
eBytecode
;
}
void
SetUnknownDataType
(
)
;
void
SetTextSource
(
)
;
void
SetBinASTSource
(
)
;
void
SetBytecode
(
)
;
template
<
typename
Unit
>
using
ScriptTextBuffer
=
Vector
<
Unit
0
JSMallocAllocPolicy
>
;
using
BinASTSourceBuffer
=
Vector
<
uint8_t
>
;
bool
IsUTF16Text
(
)
const
{
return
mScriptData
-
>
is
<
ScriptTextBuffer
<
char16_t
>
>
(
)
;
}
bool
IsUTF8Text
(
)
const
{
return
mScriptData
-
>
is
<
ScriptTextBuffer
<
Utf8Unit
>
>
(
)
;
}
template
<
typename
Unit
>
const
ScriptTextBuffer
<
Unit
>
&
ScriptText
(
)
const
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
mScriptData
-
>
as
<
ScriptTextBuffer
<
Unit
>
>
(
)
;
}
template
<
typename
Unit
>
ScriptTextBuffer
<
Unit
>
&
ScriptText
(
)
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
mScriptData
-
>
as
<
ScriptTextBuffer
<
Unit
>
>
(
)
;
}
const
BinASTSourceBuffer
&
ScriptBinASTData
(
)
const
{
MOZ_ASSERT
(
IsBinASTSource
(
)
)
;
return
mScriptData
-
>
as
<
BinASTSourceBuffer
>
(
)
;
}
BinASTSourceBuffer
&
ScriptBinASTData
(
)
{
MOZ_ASSERT
(
IsBinASTSource
(
)
)
;
return
mScriptData
-
>
as
<
BinASTSourceBuffer
>
(
)
;
}
size_t
ScriptTextLength
(
)
const
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
IsUTF16Text
(
)
?
ScriptText
<
char16_t
>
(
)
.
length
(
)
:
ScriptText
<
Utf8Unit
>
(
)
.
length
(
)
;
}
void
ClearScriptText
(
)
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
IsUTF16Text
(
)
?
ScriptText
<
char16_t
>
(
)
.
clearAndFree
(
)
:
ScriptText
<
Utf8Unit
>
(
)
.
clearAndFree
(
)
;
}
enum
class
ScriptMode
:
uint8_t
{
eBlocking
eDeferred
eAsync
eLinkPreload
}
;
void
SetScriptMode
(
bool
aDeferAttr
bool
aAsyncAttr
bool
aLinkPreload
)
;
bool
IsLinkPreloadScript
(
)
const
{
return
mScriptMode
=
=
ScriptMode
:
:
eLinkPreload
;
}
bool
IsBlockingScript
(
)
const
{
return
mScriptMode
=
=
ScriptMode
:
:
eBlocking
;
}
bool
IsDeferredScript
(
)
const
{
return
mScriptMode
=
=
ScriptMode
:
:
eDeferred
;
}
bool
IsAsyncScript
(
)
const
{
return
mScriptMode
=
=
ScriptMode
:
:
eAsync
;
}
virtual
bool
IsTopLevel
(
)
const
{
return
true
;
}
mozilla
:
:
CORSMode
CORSMode
(
)
const
{
return
mFetchOptions
-
>
mCORSMode
;
}
enum
ReferrerPolicy
ReferrerPolicy
(
)
const
{
return
mFetchOptions
-
>
mReferrerPolicy
;
}
nsIScriptElement
*
GetScriptElement
(
)
const
{
nsCOMPtr
<
nsIScriptElement
>
scriptElement
=
do_QueryInterface
(
mFetchOptions
-
>
mElement
)
;
return
scriptElement
;
}
nsIPrincipal
*
TriggeringPrincipal
(
)
const
{
return
mFetchOptions
-
>
mTriggeringPrincipal
;
}
void
SetIsPreloadRequest
(
)
{
MOZ_ASSERT
(
!
GetScriptElement
(
)
)
;
MOZ_ASSERT
(
!
IsPreload
(
)
)
;
mFetchOptions
-
>
mIsPreload
=
true
;
}
void
SetIsLoadRequest
(
nsIScriptElement
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
!
GetScriptElement
(
)
)
;
MOZ_ASSERT
(
IsPreload
(
)
)
;
mFetchOptions
-
>
mElement
=
do_QueryInterface
(
aElement
)
;
mFetchOptions
-
>
mIsPreload
=
false
;
}
FromParser
GetParserCreated
(
)
const
{
nsIScriptElement
*
element
=
GetScriptElement
(
)
;
if
(
!
element
)
{
return
NOT_FROM_PARSER
;
}
return
element
-
>
GetParserCreated
(
)
;
}
bool
ShouldAcceptBinASTEncoding
(
)
const
;
void
ClearScriptSource
(
)
;
void
SetScript
(
JSScript
*
aScript
)
;
void
MaybeCancelOffThreadScript
(
)
;
void
DropBytecodeCacheReferences
(
)
;
using
super
:
:
getNext
;
using
super
:
:
isInList
;
const
ScriptKind
mKind
;
ScriptMode
mScriptMode
;
Progress
mProgress
;
DataType
mDataType
;
bool
mScriptFromHead
;
bool
mIsInline
;
bool
mInDeferList
;
bool
mInAsyncList
;
bool
mIsNonAsyncScriptInserted
;
bool
mIsXSLT
;
bool
mIsCanceled
;
bool
mWasCompiledOMT
;
bool
mIsTracking
;
RefPtr
<
ScriptFetchOptions
>
mFetchOptions
;
JS
:
:
OffThreadToken
*
mOffThreadToken
;
Maybe
<
nsString
>
mSourceMapURL
;
Atomic
<
Runnable
*
>
mRunnable
;
JS
:
:
Heap
<
JSScript
*
>
mScript
;
Maybe
<
Variant
<
ScriptTextBuffer
<
char16_t
>
ScriptTextBuffer
<
Utf8Unit
>
BinASTSourceBuffer
>
>
mScriptData
;
size_t
mScriptTextLength
;
mozilla
:
:
Vector
<
uint8_t
>
mScriptBytecode
;
uint32_t
mBytecodeOffset
;
const
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsIPrincipal
>
mOriginPrincipal
;
nsAutoCString
mURL
;
int32_t
mLineNo
;
const
SRIMetadata
mIntegrity
;
const
nsCOMPtr
<
nsIURI
>
mReferrer
;
RefPtr
<
Document
>
mLoadBlockedDocument
;
nsCOMPtr
<
nsICacheInfoChannel
>
mCacheInfo
;
nsCOMPtr
<
nsIURI
>
mBaseURL
;
nsresult
mUnreportedPreloadError
;
}
;
class
ScriptLoadRequestList
:
private
mozilla
:
:
LinkedList
<
ScriptLoadRequest
>
{
typedef
mozilla
:
:
LinkedList
<
ScriptLoadRequest
>
super
;
public
:
~
ScriptLoadRequestList
(
)
;
void
Clear
(
)
;
#
ifdef
DEBUG
bool
Contains
(
ScriptLoadRequest
*
aElem
)
const
;
#
endif
using
super
:
:
getFirst
;
using
super
:
:
isEmpty
;
void
AppendElement
(
ScriptLoadRequest
*
aElem
)
{
MOZ_ASSERT
(
!
aElem
-
>
isInList
(
)
)
;
NS_ADDREF
(
aElem
)
;
insertBack
(
aElem
)
;
}
MOZ_MUST_USE
already_AddRefed
<
ScriptLoadRequest
>
Steal
(
ScriptLoadRequest
*
aElem
)
{
aElem
-
>
removeFrom
(
*
this
)
;
return
dont_AddRef
(
aElem
)
;
}
MOZ_MUST_USE
already_AddRefed
<
ScriptLoadRequest
>
StealFirst
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
return
Steal
(
getFirst
(
)
)
;
}
void
Remove
(
ScriptLoadRequest
*
aElem
)
{
aElem
-
>
removeFrom
(
*
this
)
;
NS_RELEASE
(
aElem
)
;
}
}
;
void
ImplCycleCollectionUnlink
(
ScriptLoadRequestList
&
aField
)
;
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ScriptLoadRequestList
&
aField
const
char
*
aName
uint32_t
aFlags
)
;
}
}
#
endif
