#
include
"
FileHandleBase
.
h
"
#
include
"
ActorsChild
.
h
"
#
include
"
BackgroundChildImpl
.
h
"
#
include
"
FileRequestBase
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundFileHandle
.
h
"
#
include
"
mozilla
/
dom
/
UnionConversions
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
MutableFileBase
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsString
.
h
"
namespace
mozilla
{
namespace
dom
{
using
namespace
mozilla
:
:
ipc
;
FileHandleBase
:
:
FileHandleBase
(
DEBUGONLY
(
PRThread
*
aOwningThread
)
FileMode
aMode
)
:
RefCountedThreadObject
(
DEBUGONLY
(
aOwningThread
)
)
mBackgroundActor
(
nullptr
)
mLocation
(
0
)
mPendingRequestCount
(
0
)
mReadyState
(
INITIAL
)
mMode
(
aMode
)
mAborted
(
false
)
mCreating
(
false
)
DEBUGONLY
(
mSentFinishOrAbort
(
false
)
)
DEBUGONLY
(
mFiredCompleteOrAbort
(
false
)
)
{
AssertIsOnOwningThread
(
)
;
}
FileHandleBase
:
:
~
FileHandleBase
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mPendingRequestCount
)
;
MOZ_ASSERT
(
!
mCreating
)
;
MOZ_ASSERT
(
mSentFinishOrAbort
)
;
MOZ_ASSERT_IF
(
mBackgroundActor
mFiredCompleteOrAbort
)
;
if
(
mBackgroundActor
)
{
mBackgroundActor
-
>
SendDeleteMeInternal
(
)
;
MOZ_ASSERT
(
!
mBackgroundActor
"
SendDeleteMeInternal
should
have
cleared
!
"
)
;
}
}
FileHandleBase
*
FileHandleBase
:
:
GetCurrent
(
)
{
MOZ_ASSERT
(
BackgroundChild
:
:
GetForCurrentThread
(
)
)
;
BackgroundChildImpl
:
:
ThreadLocal
*
threadLocal
=
BackgroundChildImpl
:
:
GetThreadLocalForCurrentThread
(
)
;
MOZ_ASSERT
(
threadLocal
)
;
return
threadLocal
-
>
mCurrentFileHandle
;
}
void
FileHandleBase
:
:
SetBackgroundActor
(
BackgroundFileHandleChild
*
aActor
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aActor
)
;
MOZ_ASSERT
(
!
mBackgroundActor
)
;
mBackgroundActor
=
aActor
;
}
void
FileHandleBase
:
:
StartRequest
(
FileRequestBase
*
aFileRequest
const
FileRequestParams
&
aParams
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aFileRequest
)
;
MOZ_ASSERT
(
aParams
.
type
(
)
!
=
FileRequestParams
:
:
T__None
)
;
BackgroundFileRequestChild
*
actor
=
new
BackgroundFileRequestChild
(
DEBUGONLY
(
mBackgroundActor
-
>
OwningThread
(
)
)
aFileRequest
)
;
mBackgroundActor
-
>
SendPBackgroundFileRequestConstructor
(
actor
aParams
)
;
OnNewRequest
(
)
;
}
void
FileHandleBase
:
:
OnNewRequest
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
mPendingRequestCount
)
{
MOZ_ASSERT
(
mReadyState
=
=
INITIAL
)
;
mReadyState
=
LOADING
;
}
+
+
mPendingRequestCount
;
}
void
FileHandleBase
:
:
OnRequestFinished
(
bool
aActorDestroyedNormally
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mPendingRequestCount
)
;
-
-
mPendingRequestCount
;
if
(
!
mPendingRequestCount
&
&
!
MutableFile
(
)
-
>
IsInvalidated
(
)
)
{
mReadyState
=
FINISHING
;
if
(
aActorDestroyedNormally
)
{
if
(
!
mAborted
)
{
SendFinish
(
)
;
}
else
{
SendAbort
(
)
;
}
}
else
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mSentFinishOrAbort
)
;
mSentFinishOrAbort
=
true
;
#
endif
}
}
}
bool
FileHandleBase
:
:
IsOpen
(
)
const
{
AssertIsOnOwningThread
(
)
;
if
(
mReadyState
=
=
INITIAL
)
{
return
true
;
}
if
(
mReadyState
=
=
LOADING
&
&
(
mCreating
|
|
GetCurrent
(
)
=
=
this
)
)
{
return
true
;
}
return
false
;
}
void
FileHandleBase
:
:
Abort
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
IsFinishingOrDone
(
)
)
{
return
;
}
const
bool
isInvalidated
=
MutableFile
(
)
-
>
IsInvalidated
(
)
;
bool
needToSendAbort
=
mReadyState
=
=
INITIAL
&
&
!
isInvalidated
;
#
ifdef
DEBUG
if
(
isInvalidated
)
{
mSentFinishOrAbort
=
true
;
}
#
endif
mAborted
=
true
;
mReadyState
=
DONE
;
if
(
needToSendAbort
)
{
SendAbort
(
)
;
}
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
Read
(
uint64_t
aSize
bool
aHasEncoding
const
nsAString
&
aEncoding
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CheckStateAndArgumentsForRead
(
aSize
aRv
)
)
{
return
nullptr
;
}
if
(
!
CheckWindow
(
)
)
{
return
nullptr
;
}
FileRequestReadParams
params
;
params
.
offset
(
)
=
mLocation
;
params
.
size
(
)
=
aSize
;
nsRefPtr
<
FileRequestBase
>
fileRequest
=
GenerateFileRequest
(
)
;
if
(
aHasEncoding
)
{
fileRequest
-
>
SetEncoding
(
aEncoding
)
;
}
StartRequest
(
fileRequest
params
)
;
mLocation
+
=
aSize
;
return
fileRequest
.
forget
(
)
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
Truncate
(
const
Optional
<
uint64_t
>
&
aSize
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CheckStateForWrite
(
aRv
)
)
{
return
nullptr
;
}
uint64_t
location
;
if
(
aSize
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
aSize
.
Value
(
)
!
=
UINT64_MAX
"
Passed
wrong
size
!
"
)
;
location
=
aSize
.
Value
(
)
;
}
else
{
if
(
mLocation
=
=
UINT64_MAX
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR
)
;
return
nullptr
;
}
location
=
mLocation
;
}
if
(
!
CheckWindow
(
)
)
{
return
nullptr
;
}
FileRequestTruncateParams
params
;
params
.
offset
(
)
=
location
;
nsRefPtr
<
FileRequestBase
>
fileRequest
=
GenerateFileRequest
(
)
;
StartRequest
(
fileRequest
params
)
;
if
(
aSize
.
WasPassed
(
)
)
{
mLocation
=
aSize
.
Value
(
)
;
}
return
fileRequest
.
forget
(
)
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
Flush
(
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CheckStateForWrite
(
aRv
)
)
{
return
nullptr
;
}
if
(
!
CheckWindow
(
)
)
{
return
nullptr
;
}
FileRequestFlushParams
params
;
nsRefPtr
<
FileRequestBase
>
fileRequest
=
GenerateFileRequest
(
)
;
StartRequest
(
fileRequest
params
)
;
return
fileRequest
.
forget
(
)
;
}
void
FileHandleBase
:
:
Abort
(
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
IsFinishingOrDone
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR
)
;
return
;
}
Abort
(
)
;
}
void
FileHandleBase
:
:
HandleCompleteOrAbort
(
bool
aAborted
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mFiredCompleteOrAbort
)
;
mReadyState
=
DONE
;
DEBUGONLY
(
mFiredCompleteOrAbort
=
true
;
)
}
void
FileHandleBase
:
:
OnReturnToEventLoop
(
)
{
AssertIsOnOwningThread
(
)
;
mCreating
=
false
;
if
(
mReadyState
=
=
INITIAL
)
{
mReadyState
=
DONE
;
SendFinish
(
)
;
}
}
bool
FileHandleBase
:
:
CheckState
(
ErrorResult
&
aRv
)
{
if
(
!
IsOpen
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_INACTIVE_ERR
)
;
return
false
;
}
return
true
;
}
bool
FileHandleBase
:
:
CheckStateAndArgumentsForRead
(
uint64_t
aSize
ErrorResult
&
aRv
)
{
if
(
!
CheckState
(
aRv
)
)
{
return
false
;
}
if
(
mLocation
=
=
UINT64_MAX
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR
)
;
return
false
;
}
if
(
!
aSize
)
{
aRv
.
ThrowTypeError
<
MSG_INVALID_READ_SIZE
>
(
)
;
return
false
;
}
return
true
;
}
bool
FileHandleBase
:
:
CheckStateForWrite
(
ErrorResult
&
aRv
)
{
if
(
!
CheckState
(
aRv
)
)
{
return
false
;
}
if
(
mMode
!
=
FileMode
:
:
Readwrite
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_READ_ONLY_ERR
)
;
return
false
;
}
return
true
;
}
bool
FileHandleBase
:
:
CheckStateForWriteOrAppend
(
bool
aAppend
ErrorResult
&
aRv
)
{
if
(
!
CheckStateForWrite
(
aRv
)
)
{
return
false
;
}
if
(
!
aAppend
&
&
mLocation
=
=
UINT64_MAX
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_NOT_ALLOWED_ERR
)
;
return
false
;
}
return
true
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
WriteOrAppend
(
const
StringOrArrayBufferOrArrayBufferViewOrBlob
&
aValue
bool
aAppend
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
aValue
.
IsString
(
)
)
{
return
WriteOrAppend
(
aValue
.
GetAsString
(
)
aAppend
aRv
)
;
}
if
(
aValue
.
IsArrayBuffer
(
)
)
{
return
WriteOrAppend
(
aValue
.
GetAsArrayBuffer
(
)
aAppend
aRv
)
;
}
if
(
aValue
.
IsArrayBufferView
(
)
)
{
return
WriteOrAppend
(
aValue
.
GetAsArrayBufferView
(
)
aAppend
aRv
)
;
}
MOZ_ASSERT
(
aValue
.
IsBlob
(
)
)
;
return
WriteOrAppend
(
aValue
.
GetAsBlob
(
)
aAppend
aRv
)
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
WriteOrAppend
(
const
nsAString
&
aValue
bool
aAppend
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CheckStateForWriteOrAppend
(
aAppend
aRv
)
)
{
return
nullptr
;
}
NS_ConvertUTF16toUTF8
cstr
(
aValue
)
;
uint64_t
dataLength
=
cstr
.
Length
(
)
;
;
if
(
!
dataLength
)
{
return
nullptr
;
}
FileRequestStringData
stringData
(
cstr
)
;
if
(
!
CheckWindow
(
)
)
{
return
nullptr
;
}
return
WriteInternal
(
stringData
dataLength
aAppend
aRv
)
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
WriteOrAppend
(
const
ArrayBuffer
&
aValue
bool
aAppend
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CheckStateForWriteOrAppend
(
aAppend
aRv
)
)
{
return
nullptr
;
}
aValue
.
ComputeLengthAndData
(
)
;
uint64_t
dataLength
=
aValue
.
Length
(
)
;
;
if
(
!
dataLength
)
{
return
nullptr
;
}
const
char
*
data
=
reinterpret_cast
<
const
char
*
>
(
aValue
.
Data
(
)
)
;
FileRequestStringData
stringData
;
if
(
NS_WARN_IF
(
!
stringData
.
string
(
)
.
Assign
(
data
aValue
.
Length
(
)
fallible_t
(
)
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR
)
;
return
nullptr
;
}
if
(
!
CheckWindow
(
)
)
{
return
nullptr
;
}
return
WriteInternal
(
stringData
dataLength
aAppend
aRv
)
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
WriteOrAppend
(
const
ArrayBufferView
&
aValue
bool
aAppend
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CheckStateForWriteOrAppend
(
aAppend
aRv
)
)
{
return
nullptr
;
}
aValue
.
ComputeLengthAndData
(
)
;
uint64_t
dataLength
=
aValue
.
Length
(
)
;
;
if
(
!
dataLength
)
{
return
nullptr
;
}
const
char
*
data
=
reinterpret_cast
<
const
char
*
>
(
aValue
.
Data
(
)
)
;
FileRequestStringData
stringData
;
if
(
NS_WARN_IF
(
!
stringData
.
string
(
)
.
Assign
(
data
aValue
.
Length
(
)
fallible_t
(
)
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR
)
;
return
nullptr
;
}
if
(
!
CheckWindow
(
)
)
{
return
nullptr
;
}
return
WriteInternal
(
stringData
dataLength
aAppend
aRv
)
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
WriteOrAppend
(
Blob
&
aValue
bool
aAppend
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
if
(
!
CheckStateForWriteOrAppend
(
aAppend
aRv
)
)
{
return
nullptr
;
}
ErrorResult
rv
;
uint64_t
dataLength
=
aValue
.
GetSize
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR
)
;
return
nullptr
;
}
if
(
!
dataLength
)
{
return
nullptr
;
}
PBackgroundChild
*
backgroundActor
=
BackgroundChild
:
:
GetForCurrentThread
(
)
;
MOZ_ASSERT
(
backgroundActor
)
;
PBlobChild
*
blobActor
=
BackgroundChild
:
:
GetOrCreateActorForBlob
(
backgroundActor
&
aValue
)
;
if
(
NS_WARN_IF
(
!
blobActor
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_FILEHANDLE_UNKNOWN_ERR
)
;
return
nullptr
;
}
FileRequestBlobData
blobData
;
blobData
.
blobChild
(
)
=
blobActor
;
if
(
!
CheckWindow
(
)
)
{
return
nullptr
;
}
return
WriteInternal
(
blobData
dataLength
aAppend
aRv
)
;
}
already_AddRefed
<
FileRequestBase
>
FileHandleBase
:
:
WriteInternal
(
const
FileRequestData
&
aData
uint64_t
aDataLength
bool
aAppend
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
DebugOnly
<
ErrorResult
>
error
;
MOZ_ASSERT
(
CheckStateForWrite
(
error
)
)
;
MOZ_ASSERT_IF
(
!
aAppend
mLocation
!
=
UINT64_MAX
)
;
MOZ_ASSERT
(
aDataLength
)
;
MOZ_ASSERT
(
CheckWindow
(
)
)
;
FileRequestWriteParams
params
;
params
.
offset
(
)
=
aAppend
?
UINT64_MAX
:
mLocation
;
params
.
data
(
)
=
aData
;
params
.
dataLength
(
)
=
aDataLength
;
nsRefPtr
<
FileRequestBase
>
fileRequest
=
GenerateFileRequest
(
)
;
MOZ_ASSERT
(
fileRequest
)
;
StartRequest
(
fileRequest
params
)
;
if
(
aAppend
)
{
mLocation
=
UINT64_MAX
;
}
else
{
mLocation
+
=
aDataLength
;
}
return
fileRequest
.
forget
(
)
;
}
void
FileHandleBase
:
:
SendFinish
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
!
mAborted
)
;
MOZ_ASSERT
(
IsFinishingOrDone
(
)
)
;
MOZ_ASSERT
(
!
mSentFinishOrAbort
)
;
MOZ_ASSERT
(
!
mPendingRequestCount
)
;
MOZ_ASSERT
(
mBackgroundActor
)
;
mBackgroundActor
-
>
SendFinish
(
)
;
DEBUGONLY
(
mSentFinishOrAbort
=
true
;
)
}
void
FileHandleBase
:
:
SendAbort
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mAborted
)
;
MOZ_ASSERT
(
IsFinishingOrDone
(
)
)
;
MOZ_ASSERT
(
!
mSentFinishOrAbort
)
;
MOZ_ASSERT
(
mBackgroundActor
)
;
mBackgroundActor
-
>
SendAbort
(
)
;
DEBUGONLY
(
mSentFinishOrAbort
=
true
;
)
}
}
}
