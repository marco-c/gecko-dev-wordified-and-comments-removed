#
include
"
ClientChannelHelper
.
h
"
#
include
"
ClientManager
.
h
"
#
include
"
ClientSource
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
using
mozilla
:
:
ipc
:
:
PrincipalInfoToPrincipal
;
namespace
{
class
ClientChannelHelper
:
public
nsIInterfaceRequestor
public
nsIChannelEventSink
{
protected
:
nsCOMPtr
<
nsIInterfaceRequestor
>
mOuter
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
virtual
~
ClientChannelHelper
(
)
=
default
;
NS_IMETHOD
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResultOut
)
override
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
*
aResultOut
=
static_cast
<
nsIChannelEventSink
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
if
(
mOuter
)
{
return
mOuter
-
>
GetInterface
(
aIID
aResultOut
)
;
}
return
NS_ERROR_NO_INTERFACE
;
}
virtual
void
CreateClient
(
nsILoadInfo
*
aLoadInfo
nsIPrincipal
*
aPrincipal
)
{
CreateClientForPrincipal
(
aLoadInfo
aPrincipal
mEventTarget
)
;
}
NS_IMETHOD
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
aOldChannel
aNewChannel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_DOM_BAD_URI
)
)
{
return
rv
;
}
nsCOMPtr
<
nsILoadInfo
>
oldLoadInfo
=
aOldChannel
-
>
LoadInfo
(
)
;
nsCOMPtr
<
nsILoadInfo
>
newLoadInfo
=
aNewChannel
-
>
LoadInfo
(
)
;
UniquePtr
<
ClientSource
>
reservedClient
=
oldLoadInfo
-
>
TakeReservedClientSource
(
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
if
(
reservedClient
)
{
newLoadInfo
-
>
GiveReservedClientSource
(
std
:
:
move
(
reservedClient
)
)
;
}
else
if
(
oldLoadInfo
!
=
newLoadInfo
)
{
const
Maybe
<
ClientInfo
>
&
reservedClientInfo
=
oldLoadInfo
-
>
GetReservedClientInfo
(
)
;
const
Maybe
<
ClientInfo
>
&
initialClientInfo
=
oldLoadInfo
-
>
GetInitialClientInfo
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
reservedClientInfo
.
isNothing
(
)
|
|
initialClientInfo
.
isNothing
(
)
)
;
if
(
reservedClientInfo
.
isSome
(
)
)
{
newLoadInfo
-
>
SetReservedClientInfo
(
reservedClientInfo
.
ref
(
)
)
;
}
if
(
initialClientInfo
.
isSome
(
)
)
{
newLoadInfo
-
>
SetInitialClientInfo
(
initialClientInfo
.
ref
(
)
)
;
}
}
}
else
{
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ssm
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
ssm
-
>
GetChannelResultPrincipal
(
aNewChannel
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
reservedClient
.
reset
(
)
;
CreateClient
(
newLoadInfo
principal
)
;
}
uint32_t
redirectMode
=
nsIHttpChannelInternal
:
:
REDIRECT_MODE_MANUAL
;
nsCOMPtr
<
nsIHttpChannelInternal
>
http
=
do_QueryInterface
(
aOldChannel
)
;
if
(
http
)
{
MOZ_ALWAYS_SUCCEEDS
(
http
-
>
GetRedirectMode
(
&
redirectMode
)
)
;
}
if
(
!
(
aFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
&
&
redirectMode
!
=
nsIHttpChannelInternal
:
:
REDIRECT_MODE_FOLLOW
)
{
newLoadInfo
-
>
ClearController
(
)
;
}
nsCOMPtr
<
nsIChannelEventSink
>
outerSink
=
do_GetInterface
(
mOuter
)
;
if
(
outerSink
)
{
return
outerSink
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
aCallback
)
;
}
aCallback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
public
:
ClientChannelHelper
(
nsIInterfaceRequestor
*
aOuter
nsISerialEventTarget
*
aEventTarget
)
:
mOuter
(
aOuter
)
mEventTarget
(
aEventTarget
)
{
}
NS_DECL_ISUPPORTS
static
void
CreateClientForPrincipal
(
nsILoadInfo
*
aLoadInfo
nsIPrincipal
*
aPrincipal
nsISerialEventTarget
*
aEventTarget
)
{
UniquePtr
<
ClientSource
>
reservedClient
=
ClientManager
:
:
CreateSource
(
ClientType
:
:
Window
aEventTarget
aPrincipal
)
;
MOZ_DIAGNOSTIC_ASSERT
(
reservedClient
)
;
aLoadInfo
-
>
GiveReservedClientSource
(
std
:
:
move
(
reservedClient
)
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
ClientChannelHelper
nsIInterfaceRequestor
nsIChannelEventSink
)
;
class
ClientChannelHelperParent
final
:
public
ClientChannelHelper
{
~
ClientChannelHelperParent
(
)
=
default
;
void
CreateClient
(
nsILoadInfo
*
aLoadInfo
nsIPrincipal
*
aPrincipal
)
override
{
CreateClientForPrincipal
(
aLoadInfo
aPrincipal
mEventTarget
)
;
}
public
:
static
void
CreateClientForPrincipal
(
nsILoadInfo
*
aLoadInfo
nsIPrincipal
*
aPrincipal
nsISerialEventTarget
*
aEventTarget
)
{
Maybe
<
ClientInfo
>
reservedInfo
=
ClientManager
:
:
CreateInfo
(
ClientType
:
:
Window
aPrincipal
)
;
if
(
reservedInfo
)
{
aLoadInfo
-
>
SetReservedClientInfo
(
*
reservedInfo
)
;
}
}
ClientChannelHelperParent
(
nsIInterfaceRequestor
*
aOuter
nsISerialEventTarget
*
aEventTarget
)
:
ClientChannelHelper
(
aOuter
nullptr
)
{
}
}
;
class
ClientChannelHelperChild
final
:
public
ClientChannelHelper
{
~
ClientChannelHelperChild
(
)
=
default
;
NS_IMETHOD
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
CreateReservedSourceIfNeeded
(
aNewChannel
mEventTarget
)
;
nsCOMPtr
<
nsIChannelEventSink
>
outerSink
=
do_GetInterface
(
mOuter
)
;
if
(
outerSink
)
{
return
outerSink
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
aCallback
)
;
}
aCallback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
public
:
ClientChannelHelperChild
(
nsIInterfaceRequestor
*
aOuter
nsISerialEventTarget
*
aEventTarget
)
:
ClientChannelHelper
(
aOuter
aEventTarget
)
{
}
}
;
}
template
<
typename
T
>
nsresult
AddClientChannelHelperInternal
(
nsIChannel
*
aChannel
Maybe
<
ClientInfo
>
&
&
aReservedClientInfo
Maybe
<
ClientInfo
>
&
&
aInitialClientInfo
nsISerialEventTarget
*
aEventTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
ClientInfo
>
initialClientInfo
(
std
:
:
move
(
aInitialClientInfo
)
)
;
Maybe
<
ClientInfo
>
reservedClientInfo
(
std
:
:
move
(
aReservedClientInfo
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
reservedClientInfo
.
isNothing
(
)
|
|
initialClientInfo
.
isNothing
(
)
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
NS_ENSURE_TRUE
(
ssm
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIPrincipal
>
channelPrincipal
;
nsresult
rv
=
ssm
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
channelPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
initialClientInfo
.
isSome
(
)
)
{
auto
initialPrincipalOrErr
=
PrincipalInfoToPrincipal
(
initialClientInfo
.
ref
(
)
.
PrincipalInfo
(
)
)
;
bool
equals
=
false
;
rv
=
initialPrincipalOrErr
.
isErr
(
)
?
initialPrincipalOrErr
.
unwrapErr
(
)
:
initialPrincipalOrErr
.
unwrap
(
)
-
>
Equals
(
channelPrincipal
&
equals
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
equals
)
{
initialClientInfo
.
reset
(
)
;
}
}
if
(
reservedClientInfo
.
isSome
(
)
)
{
auto
reservedPrincipalOrErr
=
PrincipalInfoToPrincipal
(
reservedClientInfo
.
ref
(
)
.
PrincipalInfo
(
)
)
;
bool
equals
=
false
;
rv
=
reservedPrincipalOrErr
.
isErr
(
)
?
reservedPrincipalOrErr
.
unwrapErr
(
)
:
reservedPrincipalOrErr
.
unwrap
(
)
-
>
Equals
(
channelPrincipal
&
equals
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
equals
)
{
reservedClientInfo
.
reset
(
)
;
}
}
nsCOMPtr
<
nsIInterfaceRequestor
>
outerCallbacks
;
rv
=
aChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
outerCallbacks
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
initialClientInfo
.
isNothing
(
)
&
&
reservedClientInfo
.
isNothing
(
)
)
{
T
:
:
CreateClientForPrincipal
(
loadInfo
channelPrincipal
aEventTarget
)
;
}
RefPtr
<
ClientChannelHelper
>
helper
=
new
T
(
outerCallbacks
aEventTarget
)
;
rv
=
aChannel
-
>
SetNotificationCallbacks
(
helper
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
initialClientInfo
.
isSome
(
)
)
{
loadInfo
-
>
SetInitialClientInfo
(
initialClientInfo
.
ref
(
)
)
;
}
if
(
reservedClientInfo
.
isSome
(
)
)
{
loadInfo
-
>
SetReservedClientInfo
(
reservedClientInfo
.
ref
(
)
)
;
}
return
NS_OK
;
}
nsresult
AddClientChannelHelper
(
nsIChannel
*
aChannel
Maybe
<
ClientInfo
>
&
&
aReservedClientInfo
Maybe
<
ClientInfo
>
&
&
aInitialClientInfo
nsISerialEventTarget
*
aEventTarget
)
{
return
AddClientChannelHelperInternal
<
ClientChannelHelper
>
(
aChannel
std
:
:
move
(
aReservedClientInfo
)
std
:
:
move
(
aInitialClientInfo
)
aEventTarget
)
;
}
nsresult
AddClientChannelHelperInParent
(
nsIChannel
*
aChannel
Maybe
<
ClientInfo
>
&
&
aInitialClientInfo
)
{
Maybe
<
ClientInfo
>
emptyReservedInfo
;
return
AddClientChannelHelperInternal
<
ClientChannelHelperParent
>
(
aChannel
std
:
:
move
(
emptyReservedInfo
)
std
:
:
move
(
aInitialClientInfo
)
nullptr
)
;
}
nsresult
AddClientChannelHelperInChild
(
nsIChannel
*
aChannel
nsISerialEventTarget
*
aEventTarget
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
outerCallbacks
;
nsresult
rv
=
aChannel
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
outerCallbacks
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
ClientChannelHelper
>
helper
=
new
ClientChannelHelperChild
(
outerCallbacks
aEventTarget
)
;
rv
=
aChannel
-
>
SetNotificationCallbacks
(
helper
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
CreateReservedSourceIfNeeded
(
nsIChannel
*
aChannel
nsISerialEventTarget
*
aEventTarget
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
const
Maybe
<
ClientInfo
>
&
reservedClientInfo
=
loadInfo
-
>
GetReservedClientInfo
(
)
;
if
(
reservedClientInfo
)
{
UniquePtr
<
ClientSource
>
reservedClient
=
ClientManager
:
:
CreateSourceFromInfo
(
*
reservedClientInfo
aEventTarget
)
;
loadInfo
-
>
GiveReservedClientSource
(
std
:
:
move
(
reservedClient
)
)
;
}
}
}
}
