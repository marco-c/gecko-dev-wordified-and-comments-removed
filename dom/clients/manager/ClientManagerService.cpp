#
include
"
ClientManagerService
.
h
"
#
include
"
ClientManagerParent
.
h
"
#
include
"
ClientNavigateOpParent
.
h
"
#
include
"
ClientOpenWindowUtils
.
h
"
#
include
"
ClientPrincipalUtils
.
h
"
#
include
"
ClientSourceParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
SystemGroup
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsProxyRelease
.
h
"
namespace
mozilla
{
namespace
dom
{
using
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
;
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
namespace
{
ClientManagerService
*
sClientManagerServiceInstance
=
nullptr
;
bool
sClientManagerServiceShutdownRegistered
=
false
;
class
ClientShutdownBlocker
final
:
public
nsIAsyncShutdownBlocker
{
RefPtr
<
GenericPromise
:
:
Private
>
mPromise
;
~
ClientShutdownBlocker
(
)
=
default
;
public
:
explicit
ClientShutdownBlocker
(
GenericPromise
:
:
Private
*
aPromise
)
:
mPromise
(
aPromise
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPromise
)
;
}
NS_IMETHOD
GetName
(
nsAString
&
aNameOut
)
override
{
aNameOut
=
NS_LITERAL_STRING
(
"
ClientManagerService
:
start
destroying
IPC
actors
early
"
)
;
return
NS_OK
;
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aClient
)
override
{
mPromise
-
>
Resolve
(
true
__func__
)
;
aClient
-
>
RemoveBlocker
(
this
)
;
return
NS_OK
;
}
NS_IMETHOD
GetState
(
nsIPropertyBag
*
*
)
override
{
return
NS_OK
;
}
NS_DECL_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
ClientShutdownBlocker
nsIAsyncShutdownBlocker
)
RefPtr
<
GenericPromise
>
OnShutdown
(
)
{
RefPtr
<
GenericPromise
:
:
Private
>
ref
=
new
GenericPromise
:
:
Private
(
__func__
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
ClientManagerServer
:
:
OnShutdown
"
[
ref
]
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdown
(
)
;
if
(
!
svc
)
{
ref
-
>
Resolve
(
true
__func__
)
;
return
;
}
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
;
MOZ_ALWAYS_SUCCEEDS
(
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
phase
)
)
)
;
if
(
!
phase
)
{
ref
-
>
Resolve
(
true
__func__
)
;
return
;
}
nsCOMPtr
<
nsIAsyncShutdownBlocker
>
blocker
=
new
ClientShutdownBlocker
(
ref
)
;
nsresult
rv
=
phase
-
>
AddBlocker
(
blocker
NS_LITERAL_STRING
(
__FILE__
)
__LINE__
NS_LITERAL_STRING
(
"
ClientManagerService
shutdown
"
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
ref
-
>
Resolve
(
true
__func__
)
;
return
;
}
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
)
;
return
ref
;
}
}
ClientManagerService
:
:
FutureClientSourceParent
:
:
FutureClientSourceParent
(
const
IPCClientInfo
&
aClientInfo
)
:
mPrincipalInfo
(
aClientInfo
.
principalInfo
(
)
)
{
}
ClientManagerService
:
:
ClientManagerService
(
)
:
mShutdown
(
false
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
!
sClientManagerServiceShutdownRegistered
)
{
sClientManagerServiceShutdownRegistered
=
true
;
OnShutdown
(
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
]
(
)
{
RefPtr
<
ClientManagerService
>
svc
=
ClientManagerService
:
:
GetInstance
(
)
;
if
(
svc
)
{
svc
-
>
Shutdown
(
)
;
}
}
)
;
}
}
ClientManagerService
:
:
~
ClientManagerService
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mSourceTable
.
Count
(
)
=
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mManagerList
.
IsEmpty
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sClientManagerServiceInstance
=
=
this
)
;
sClientManagerServiceInstance
=
nullptr
;
}
void
ClientManagerService
:
:
Shutdown
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sClientManagerServiceShutdownRegistered
)
;
if
(
mShutdown
)
{
return
;
}
mShutdown
=
true
;
AutoTArray
<
ClientManagerParent
*
16
>
list
(
mManagerList
)
;
for
(
auto
actor
:
list
)
{
Unused
<
<
PClientManagerParent
:
:
Send__delete__
(
actor
)
;
}
}
already_AddRefed
<
ClientManagerService
>
ClientManagerService
:
:
GetOrCreateInstance
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
!
sClientManagerServiceInstance
)
{
sClientManagerServiceInstance
=
new
ClientManagerService
(
)
;
}
RefPtr
<
ClientManagerService
>
ref
(
sClientManagerServiceInstance
)
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
ClientManagerService
>
ClientManagerService
:
:
GetInstance
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
!
sClientManagerServiceInstance
)
{
return
nullptr
;
}
RefPtr
<
ClientManagerService
>
ref
(
sClientManagerServiceInstance
)
;
return
ref
.
forget
(
)
;
}
bool
ClientManagerService
:
:
AddSource
(
ClientSourceParent
*
aSource
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aSource
)
;
auto
entry
=
mSourceTable
.
LookupForAdd
(
aSource
-
>
Info
(
)
.
Id
(
)
)
;
if
(
NS_WARN_IF
(
!
!
entry
)
)
{
return
false
;
}
entry
.
OrInsert
(
[
&
]
{
return
aSource
;
}
)
;
auto
*
handles
=
mPendingHandles
.
GetValue
(
aSource
-
>
Info
(
)
.
Id
(
)
)
;
if
(
handles
)
{
for
(
auto
handle
:
*
handles
)
{
handle
-
>
FoundSource
(
aSource
)
;
}
}
mPendingHandles
.
Remove
(
aSource
-
>
Info
(
)
.
Id
(
)
)
;
return
true
;
}
bool
ClientManagerService
:
:
RemoveSource
(
ClientSourceParent
*
aSource
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aSource
)
;
auto
entry
=
mSourceTable
.
Lookup
(
aSource
-
>
Info
(
)
.
Id
(
)
)
;
if
(
NS_WARN_IF
(
!
entry
)
)
{
return
false
;
}
entry
.
Remove
(
)
;
return
true
;
}
ClientSourceParent
*
ClientManagerService
:
:
FindSource
(
const
nsID
&
aID
const
PrincipalInfo
&
aPrincipalInfo
)
{
AssertIsOnBackgroundThread
(
)
;
auto
entry
=
mSourceTable
.
Lookup
(
aID
)
;
if
(
!
entry
)
{
return
nullptr
;
}
ClientSourceParent
*
source
=
entry
.
Data
(
)
;
if
(
source
-
>
IsFrozen
(
)
|
|
!
ClientMatchPrincipalInfo
(
source
-
>
Info
(
)
.
PrincipalInfo
(
)
aPrincipalInfo
)
)
{
return
nullptr
;
}
return
source
;
}
void
ClientManagerService
:
:
WaitForSource
(
ClientHandleParent
*
aHandle
const
nsID
&
aID
)
{
auto
&
entry
=
mPendingHandles
.
GetOrInsert
(
aID
)
;
entry
.
AppendElement
(
aHandle
)
;
}
void
ClientManagerService
:
:
StopWaitingForSource
(
ClientHandleParent
*
aHandle
const
nsID
&
aID
)
{
auto
*
entry
=
mPendingHandles
.
GetValue
(
aID
)
;
if
(
entry
)
{
entry
-
>
RemoveElement
(
aHandle
)
;
}
}
void
ClientManagerService
:
:
AddManager
(
ClientManagerParent
*
aManager
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
!
mManagerList
.
Contains
(
aManager
)
)
;
mManagerList
.
AppendElement
(
aManager
)
;
if
(
mShutdown
)
{
Unused
<
<
PClientManagerParent
:
:
Send__delete__
(
aManager
)
;
}
}
void
ClientManagerService
:
:
RemoveManager
(
ClientManagerParent
*
aManager
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aManager
)
;
DebugOnly
<
bool
>
removed
=
mManagerList
.
RemoveElement
(
aManager
)
;
MOZ_ASSERT
(
removed
)
;
}
RefPtr
<
ClientOpPromise
>
ClientManagerService
:
:
Navigate
(
const
ClientNavigateArgs
&
aArgs
)
{
ClientSourceParent
*
source
=
FindSource
(
aArgs
.
target
(
)
.
id
(
)
aArgs
.
target
(
)
.
principalInfo
(
)
)
;
if
(
!
source
)
{
CopyableErrorResult
rv
;
rv
.
ThrowInvalidStateError
(
"
Unknown
client
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
PClientManagerParent
*
manager
=
source
-
>
Manager
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
manager
)
;
ClientNavigateOpConstructorArgs
args
;
args
.
url
(
)
=
aArgs
.
url
(
)
;
args
.
baseURL
(
)
=
aArgs
.
baseURL
(
)
;
args
.
targetParent
(
)
=
source
;
RefPtr
<
ClientOpPromise
:
:
Private
>
promise
=
new
ClientOpPromise
:
:
Private
(
__func__
)
;
ClientNavigateOpParent
*
op
=
new
ClientNavigateOpParent
(
args
promise
)
;
PClientNavigateOpParent
*
result
=
manager
-
>
SendPClientNavigateOpConstructor
(
op
args
)
;
if
(
!
result
)
{
CopyableErrorResult
rv
;
rv
.
ThrowInvalidStateError
(
"
Client
is
aborted
"
)
;
promise
-
>
Reject
(
rv
__func__
)
;
}
return
promise
;
}
namespace
{
class
PromiseListHolder
final
{
RefPtr
<
ClientOpPromise
:
:
Private
>
mResultPromise
;
nsTArray
<
RefPtr
<
ClientOpPromise
>
>
mPromiseList
;
nsTArray
<
ClientInfoAndState
>
mResultList
;
uint32_t
mOutstandingPromiseCount
;
void
ProcessSuccess
(
const
ClientInfoAndState
&
aResult
)
{
mResultList
.
AppendElement
(
aResult
)
;
ProcessCompletion
(
)
;
}
void
ProcessCompletion
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mOutstandingPromiseCount
>
0
)
;
mOutstandingPromiseCount
-
=
1
;
MaybeFinish
(
)
;
}
~
PromiseListHolder
(
)
=
default
;
public
:
PromiseListHolder
(
)
:
mResultPromise
(
new
ClientOpPromise
:
:
Private
(
__func__
)
)
mOutstandingPromiseCount
(
0
)
{
}
RefPtr
<
ClientOpPromise
>
GetResultPromise
(
)
{
RefPtr
<
PromiseListHolder
>
kungFuDeathGrip
=
this
;
return
mResultPromise
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
kungFuDeathGrip
]
(
const
ClientOpPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
return
ClientOpPromise
:
:
CreateAndResolveOrReject
(
aValue
__func__
)
;
}
)
;
}
void
AddPromise
(
RefPtr
<
ClientOpPromise
>
&
&
aPromise
)
{
mPromiseList
.
AppendElement
(
std
:
:
move
(
aPromise
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPromiseList
.
LastElement
(
)
)
;
mOutstandingPromiseCount
+
=
1
;
RefPtr
<
PromiseListHolder
>
self
(
this
)
;
mPromiseList
.
LastElement
(
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
]
(
const
ClientOpResult
&
aResult
)
{
if
(
aResult
.
type
(
)
=
=
ClientOpResult
:
:
TClientInfoAndState
)
{
self
-
>
ProcessSuccess
(
aResult
.
get_ClientInfoAndState
(
)
)
;
}
else
{
self
-
>
ProcessCompletion
(
)
;
}
}
[
self
]
(
const
CopyableErrorResult
&
aResult
)
{
self
-
>
ProcessCompletion
(
)
;
}
)
;
}
void
MaybeFinish
(
)
{
if
(
!
mOutstandingPromiseCount
)
{
mResultPromise
-
>
Resolve
(
mResultList
__func__
)
;
}
}
NS_INLINE_DECL_REFCOUNTING
(
PromiseListHolder
)
}
;
}
RefPtr
<
ClientOpPromise
>
ClientManagerService
:
:
MatchAll
(
const
ClientMatchAllArgs
&
aArgs
)
{
AssertIsOnBackgroundThread
(
)
;
ServiceWorkerDescriptor
swd
(
aArgs
.
serviceWorker
(
)
)
;
const
PrincipalInfo
&
principalInfo
=
swd
.
PrincipalInfo
(
)
;
RefPtr
<
PromiseListHolder
>
promiseList
=
new
PromiseListHolder
(
)
;
for
(
auto
iter
=
mSourceTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ClientSourceParent
*
source
=
iter
.
UserData
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
source
)
;
if
(
source
-
>
IsFrozen
(
)
|
|
!
source
-
>
ExecutionReady
(
)
)
{
continue
;
}
if
(
aArgs
.
type
(
)
!
=
ClientType
:
:
All
&
&
source
-
>
Info
(
)
.
Type
(
)
!
=
aArgs
.
type
(
)
)
{
continue
;
}
if
(
!
ClientMatchPrincipalInfo
(
source
-
>
Info
(
)
.
PrincipalInfo
(
)
principalInfo
)
)
{
continue
;
}
if
(
!
aArgs
.
includeUncontrolled
(
)
)
{
const
Maybe
<
ServiceWorkerDescriptor
>
&
controller
=
source
-
>
GetController
(
)
;
if
(
controller
.
isNothing
(
)
)
{
continue
;
}
if
(
controller
.
ref
(
)
.
Id
(
)
!
=
swd
.
Id
(
)
|
|
controller
.
ref
(
)
.
Scope
(
)
!
=
swd
.
Scope
(
)
)
{
continue
;
}
}
promiseList
-
>
AddPromise
(
source
-
>
StartOp
(
ClientGetInfoAndStateArgs
(
source
-
>
Info
(
)
.
Id
(
)
source
-
>
Info
(
)
.
PrincipalInfo
(
)
)
)
)
;
}
promiseList
-
>
MaybeFinish
(
)
;
return
promiseList
-
>
GetResultPromise
(
)
;
}
namespace
{
RefPtr
<
ClientOpPromise
>
ClaimOnMainThread
(
const
ClientInfo
&
aClientInfo
const
ServiceWorkerDescriptor
&
aDescriptor
)
{
RefPtr
<
ClientOpPromise
:
:
Private
>
promise
=
new
ClientOpPromise
:
:
Private
(
__func__
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
promise
clientInfo
=
std
:
:
move
(
aClientInfo
)
desc
=
std
:
:
move
(
aDescriptor
)
]
(
)
{
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
nsPrintfCString
err
(
"
Service
worker
at
<
%
s
>
can
'
t
claim
Client
at
<
%
s
>
"
desc
.
ScriptURL
(
)
.
get
(
)
clientInfo
.
URL
(
)
.
get
(
)
)
;
CopyableErrorResult
rv
;
rv
.
ThrowInvalidStateError
(
err
)
;
promise
-
>
Reject
(
rv
__func__
)
;
}
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE_VOID
(
swm
)
;
RefPtr
<
GenericErrorResultPromise
>
inner
=
swm
-
>
MaybeClaimClient
(
clientInfo
desc
)
;
inner
-
>
Then
(
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
__func__
[
promise
]
(
bool
aResult
)
{
promise
-
>
Resolve
(
CopyableErrorResult
(
)
__func__
)
;
}
[
promise
]
(
const
CopyableErrorResult
&
aRv
)
{
promise
-
>
Reject
(
aRv
__func__
)
;
}
)
;
scopeExit
.
release
(
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SystemGroup
:
:
Dispatch
(
TaskCategory
:
:
Other
r
.
forget
(
)
)
)
;
return
promise
;
}
}
RefPtr
<
ClientOpPromise
>
ClientManagerService
:
:
Claim
(
const
ClientClaimArgs
&
aArgs
)
{
AssertIsOnBackgroundThread
(
)
;
const
IPCServiceWorkerDescriptor
&
serviceWorker
=
aArgs
.
serviceWorker
(
)
;
const
PrincipalInfo
&
principalInfo
=
serviceWorker
.
principalInfo
(
)
;
RefPtr
<
PromiseListHolder
>
promiseList
=
new
PromiseListHolder
(
)
;
for
(
auto
iter
=
mSourceTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
ClientSourceParent
*
source
=
iter
.
UserData
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
source
)
;
if
(
source
-
>
IsFrozen
(
)
)
{
continue
;
}
if
(
!
ClientMatchPrincipalInfo
(
source
-
>
Info
(
)
.
PrincipalInfo
(
)
principalInfo
)
)
{
continue
;
}
const
Maybe
<
ServiceWorkerDescriptor
>
&
controller
=
source
-
>
GetController
(
)
;
if
(
controller
.
isSome
(
)
&
&
controller
.
ref
(
)
.
Scope
(
)
=
=
serviceWorker
.
scope
(
)
&
&
controller
.
ref
(
)
.
Id
(
)
=
=
serviceWorker
.
id
(
)
)
{
continue
;
}
if
(
!
source
-
>
ExecutionReady
(
)
|
|
source
-
>
Info
(
)
.
Type
(
)
=
=
ClientType
:
:
Serviceworker
|
|
source
-
>
Info
(
)
.
URL
(
)
.
Find
(
serviceWorker
.
scope
(
)
)
!
=
0
)
{
continue
;
}
if
(
ServiceWorkerParentInterceptEnabled
(
)
)
{
promiseList
-
>
AddPromise
(
ClaimOnMainThread
(
source
-
>
Info
(
)
ServiceWorkerDescriptor
(
serviceWorker
)
)
)
;
}
else
{
promiseList
-
>
AddPromise
(
source
-
>
StartOp
(
aArgs
)
)
;
}
}
promiseList
-
>
MaybeFinish
(
)
;
return
promiseList
-
>
GetResultPromise
(
)
;
}
RefPtr
<
ClientOpPromise
>
ClientManagerService
:
:
GetInfoAndState
(
const
ClientGetInfoAndStateArgs
&
aArgs
)
{
ClientSourceParent
*
source
=
FindSource
(
aArgs
.
id
(
)
aArgs
.
principalInfo
(
)
)
;
if
(
!
source
)
{
CopyableErrorResult
rv
;
rv
.
ThrowInvalidStateError
(
"
Unknown
client
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
if
(
!
source
-
>
ExecutionReady
(
)
)
{
RefPtr
<
ClientManagerService
>
self
=
this
;
return
source
-
>
ExecutionReadyPromise
(
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
aArgs
]
(
)
-
>
RefPtr
<
ClientOpPromise
>
{
ClientSourceParent
*
source
=
self
-
>
FindSource
(
aArgs
.
id
(
)
aArgs
.
principalInfo
(
)
)
;
if
(
!
source
)
{
CopyableErrorResult
rv
;
rv
.
ThrowInvalidStateError
(
"
Unknown
client
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
return
source
-
>
StartOp
(
aArgs
)
;
}
)
;
}
return
source
-
>
StartOp
(
aArgs
)
;
}
RefPtr
<
ClientOpPromise
>
ClientManagerService
:
:
OpenWindow
(
const
ClientOpenWindowArgs
&
aArgs
)
{
return
InvokeAsync
(
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
__func__
[
aArgs
]
(
)
{
return
ClientOpenWindow
(
aArgs
)
;
}
)
;
}
bool
ClientManagerService
:
:
HasWindow
(
const
Maybe
<
ContentParentId
>
&
aContentParentId
const
PrincipalInfo
&
aPrincipalInfo
const
nsID
&
aClientId
)
{
AssertIsOnBackgroundThread
(
)
;
ClientSourceParent
*
source
=
FindSource
(
aClientId
aPrincipalInfo
)
;
if
(
!
source
)
{
return
false
;
}
if
(
!
source
-
>
ExecutionReady
(
)
)
{
return
false
;
}
if
(
source
-
>
Info
(
)
.
Type
(
)
!
=
ClientType
:
:
Window
)
{
return
false
;
}
if
(
aContentParentId
&
&
!
source
-
>
IsOwnedByProcess
(
aContentParentId
.
value
(
)
)
)
{
return
false
;
}
return
true
;
}
}
}
