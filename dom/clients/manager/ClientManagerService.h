#
ifndef
_mozilla_dom_ClientManagerService_h
#
define
_mozilla_dom_ClientManagerService_h
#
include
"
ClientOpPromise
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
IdType
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
nsDataHashtable
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
PrincipalInfo
;
}
namespace
dom
{
class
ClientManagerParent
;
class
ClientSourceParent
;
class
ClientHandleParent
;
typedef
MozPromise
<
ClientSourceParent
*
nsresult
false
>
SourcePromise
;
class
ClientManagerService
final
{
public
:
static
already_AddRefed
<
ClientManagerService
>
GetOrCreateInstance
(
)
;
static
already_AddRefed
<
ClientManagerService
>
GetInstance
(
)
;
bool
AddSource
(
ClientSourceParent
*
aSource
)
;
bool
RemoveSource
(
ClientSourceParent
*
aSource
)
;
bool
ExpectFutureSource
(
const
IPCClientInfo
&
aClientInfo
)
;
bool
ForgetFutureSource
(
const
IPCClientInfo
&
aClientInfo
)
;
RefPtr
<
SourcePromise
>
FindSource
(
const
nsID
&
aID
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
)
const
;
void
AddManager
(
ClientManagerParent
*
aManager
)
;
void
RemoveManager
(
ClientManagerParent
*
aManager
)
;
RefPtr
<
ClientOpPromise
>
Navigate
(
const
ClientNavigateArgs
&
aArgs
)
;
RefPtr
<
ClientOpPromise
>
MatchAll
(
const
ClientMatchAllArgs
&
aArgs
)
;
RefPtr
<
ClientOpPromise
>
Claim
(
const
ClientClaimArgs
&
aArgs
)
;
RefPtr
<
ClientOpPromise
>
GetInfoAndState
(
const
ClientGetInfoAndStateArgs
&
aArgs
)
;
RefPtr
<
ClientOpPromise
>
OpenWindow
(
const
ClientOpenWindowArgs
&
aArgs
already_AddRefed
<
ContentParent
>
aSourceProcess
)
;
bool
HasWindow
(
const
Maybe
<
ContentParentId
>
&
aContentParentId
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
const
nsID
&
aClientId
)
;
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
dom
:
:
ClientManagerService
)
private
:
ClientManagerService
(
)
;
~
ClientManagerService
(
)
;
void
Shutdown
(
)
;
ClientSourceParent
*
FindExistingSource
(
const
nsID
&
aID
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
aPrincipalInfo
)
const
;
class
FutureClientSourceParent
{
public
:
explicit
FutureClientSourceParent
(
const
IPCClientInfo
&
aClientInfo
)
;
const
mozilla
:
:
ipc
:
:
PrincipalInfo
&
PrincipalInfo
(
)
const
{
return
mPrincipalInfo
;
}
already_AddRefed
<
SourcePromise
>
Promise
(
)
{
return
mPromiseHolder
.
Ensure
(
__func__
)
;
}
void
ResolvePromiseIfExists
(
ClientSourceParent
*
aSource
)
{
mPromiseHolder
.
ResolveIfExists
(
aSource
__func__
)
;
}
void
RejectPromiseIfExists
(
nsresult
aRv
)
{
mPromiseHolder
.
RejectIfExists
(
aRv
__func__
)
;
}
private
:
const
mozilla
:
:
ipc
:
:
PrincipalInfo
mPrincipalInfo
;
MozPromiseHolder
<
SourcePromise
>
mPromiseHolder
;
}
;
using
SourceTableEntry
=
Variant
<
FutureClientSourceParent
ClientSourceParent
*
>
;
friend
inline
ClientSourceParent
*
MaybeUnwrapAsExistingSource
(
const
SourceTableEntry
&
aEntry
)
;
struct
nsIDHasher
{
using
Key
=
nsID
;
using
Lookup
=
Key
;
static
HashNumber
hash
(
const
Lookup
&
aLookup
)
{
return
HashBytes
(
&
aLookup
sizeof
(
Lookup
)
)
;
}
static
bool
match
(
const
Key
&
aKey
const
Lookup
&
aLookup
)
{
return
aKey
.
Equals
(
aLookup
)
;
}
}
;
HashMap
<
nsID
SourceTableEntry
nsIDHasher
>
mSourceTable
;
nsTArray
<
ClientManagerParent
*
>
mManagerList
;
bool
mShutdown
;
}
;
}
}
#
endif
