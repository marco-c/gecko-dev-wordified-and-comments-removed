#
ifndef
_mozilla_dom_ClientSource_h
#
define
_mozilla_dom_ClientSource_h
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ClientOpPromise
.
h
"
#
include
"
mozilla
/
dom
/
ClientThing
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
ifdef
XP_WIN
#
undef
PostMessage
#
endif
class
nsIDocShell
;
class
nsISerialEventTarget
;
class
nsPIDOMWindowInner
;
namespace
mozilla
{
namespace
dom
{
class
ClientClaimArgs
;
class
ClientControlledArgs
;
class
ClientFocusArgs
;
class
ClientGetInfoAndStateArgs
;
class
ClientManager
;
class
ClientPostMessageArgs
;
class
ClientSourceChild
;
class
ClientSourceConstructorArgs
;
class
ClientSourceExecutionReadyArgs
;
class
ClientState
;
class
ClientWindowState
;
class
PClientManagerChild
;
class
WorkerPrivate
;
class
ClientSource
final
:
public
ClientThing
<
ClientSourceChild
>
{
friend
class
ClientManager
;
NS_DECL_OWNINGTHREAD
RefPtr
<
ClientManager
>
mManager
;
nsCOMPtr
<
nsISerialEventTarget
>
mEventTarget
;
Variant
<
Nothing
RefPtr
<
nsPIDOMWindowInner
>
nsCOMPtr
<
nsIDocShell
>
WorkerPrivate
*
>
mOwner
;
ClientInfo
mClientInfo
;
Maybe
<
ServiceWorkerDescriptor
>
mController
;
AutoTArray
<
nsCString
1
>
mRegisteringScopeList
;
void
Shutdown
(
)
;
void
ExecutionReady
(
const
ClientSourceExecutionReadyArgs
&
aArgs
)
;
WorkerPrivate
*
GetWorkerPrivate
(
)
const
;
nsIDocShell
*
GetDocShell
(
)
const
;
void
MaybeCreateInitialDocument
(
)
;
nsresult
SnapshotWindowState
(
ClientState
*
aStateOut
)
;
ClientSource
(
ClientManager
*
aManager
nsISerialEventTarget
*
aEventTarget
const
ClientSourceConstructorArgs
&
aArgs
)
;
void
Activate
(
PClientManagerChild
*
aActor
)
;
public
:
~
ClientSource
(
)
;
nsPIDOMWindowInner
*
GetInnerWindow
(
)
const
;
void
WorkerExecutionReady
(
WorkerPrivate
*
aWorkerPrivate
)
;
nsresult
WindowExecutionReady
(
nsPIDOMWindowInner
*
aInnerWindow
)
;
nsresult
DocShellExecutionReady
(
nsIDocShell
*
aDocShell
)
;
void
Freeze
(
)
;
void
Thaw
(
)
;
const
ClientInfo
&
Info
(
)
const
;
void
WorkerSyncPing
(
WorkerPrivate
*
aWorkerPrivate
)
;
void
SetController
(
const
ServiceWorkerDescriptor
&
aServiceWorker
)
;
RefPtr
<
ClientOpPromise
>
Control
(
const
ClientControlledArgs
&
aArgs
)
;
const
Maybe
<
ServiceWorkerDescriptor
>
&
GetController
(
)
const
;
RefPtr
<
ClientOpPromise
>
Focus
(
const
ClientFocusArgs
&
aArgs
)
;
RefPtr
<
ClientOpPromise
>
PostMessage
(
const
ClientPostMessageArgs
&
aArgs
)
;
RefPtr
<
ClientOpPromise
>
Claim
(
const
ClientClaimArgs
&
aArgs
)
;
RefPtr
<
ClientOpPromise
>
GetInfoAndState
(
const
ClientGetInfoAndStateArgs
&
aArgs
)
;
nsresult
SnapshotState
(
ClientState
*
aStateOut
)
;
nsISerialEventTarget
*
EventTarget
(
)
const
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCallback
const
char
*
aName
uint32_t
aFlags
)
;
void
NoteCalledRegisterForServiceWorkerScope
(
const
nsACString
&
aScope
)
;
bool
CalledRegisterForServiceWorkerScope
(
const
nsACString
&
aScope
)
;
}
;
inline
void
ImplCycleCollectionUnlink
(
UniquePtr
<
ClientSource
>
&
aField
)
{
aField
.
reset
(
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
UniquePtr
<
ClientSource
>
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
if
(
aField
)
{
aField
-
>
Traverse
(
aCallback
aName
aFlags
)
;
}
}
}
}
#
endif
