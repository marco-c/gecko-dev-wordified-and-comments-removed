#
include
"
ClientNavigateOpChild
.
h
"
#
include
"
ClientState
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsIWebProgressListener
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
ReferrerInfo
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
class
NavigateLoadListener
final
:
public
nsIWebProgressListener
public
nsSupportsWeakReference
{
RefPtr
<
ClientOpPromise
:
:
Private
>
mPromise
;
RefPtr
<
nsPIDOMWindowOuter
>
mOuterWindow
;
nsCOMPtr
<
nsIURI
>
mBaseURL
;
~
NavigateLoadListener
(
)
=
default
;
public
:
NavigateLoadListener
(
ClientOpPromise
:
:
Private
*
aPromise
nsPIDOMWindowOuter
*
aOuterWindow
nsIURI
*
aBaseURL
)
:
mPromise
(
aPromise
)
mOuterWindow
(
aOuterWindow
)
mBaseURL
(
aBaseURL
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPromise
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOuterWindow
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mBaseURL
)
;
}
NS_IMETHOD
OnStateChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aStateFlags
nsresult
aResult
)
override
{
if
(
!
(
aStateFlags
&
STATE_IS_DOCUMENT
)
|
|
!
(
aStateFlags
&
(
STATE_STOP
|
STATE_TRANSFERRING
)
)
)
{
return
NS_OK
;
}
aWebProgress
-
>
RemoveProgressListener
(
this
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
channel
)
{
CopyableErrorResult
result
;
result
.
ThrowDOMException
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
Bad
request
"
)
;
mPromise
-
>
Reject
(
result
__func__
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
channelURL
;
nsresult
rv
=
NS_GetFinalChannelURI
(
channel
getter_AddRefs
(
channelURL
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
CopyableErrorResult
result
;
result
.
Throw
(
rv
)
;
mPromise
-
>
Reject
(
result
__func__
)
;
return
NS_OK
;
}
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
ssm
)
;
rv
=
ssm
-
>
CheckSameOriginURI
(
mBaseURL
channelURL
false
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPromise
-
>
Resolve
(
CopyableErrorResult
(
)
__func__
)
;
return
NS_OK
;
}
nsPIDOMWindowInner
*
innerWindow
=
mOuterWindow
-
>
GetCurrentInnerWindow
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
innerWindow
)
;
Maybe
<
ClientInfo
>
clientInfo
=
innerWindow
-
>
GetClientInfo
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
clientInfo
.
isSome
(
)
)
;
Maybe
<
ClientState
>
clientState
=
innerWindow
-
>
GetClientState
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
clientState
.
isSome
(
)
)
;
mPromise
-
>
Resolve
(
ClientInfoAndState
(
clientInfo
.
ref
(
)
.
ToIPC
(
)
clientState
.
ref
(
)
.
ToIPC
(
)
)
__func__
)
;
return
NS_OK
;
}
NS_IMETHOD
OnProgressChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
int32_t
aCurSelfProgress
int32_t
aMaxSelfProgress
int32_t
aCurTotalProgress
int32_t
aMaxTotalProgress
)
override
{
MOZ_CRASH
(
"
Unexpected
notification
.
"
)
;
return
NS_OK
;
}
NS_IMETHOD
OnLocationChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsIURI
*
aLocation
uint32_t
aFlags
)
override
{
MOZ_CRASH
(
"
Unexpected
notification
.
"
)
;
return
NS_OK
;
}
NS_IMETHOD
OnStatusChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
nsresult
aStatus
const
char16_t
*
aMessage
)
override
{
MOZ_CRASH
(
"
Unexpected
notification
.
"
)
;
return
NS_OK
;
}
NS_IMETHOD
OnSecurityChange
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aState
)
override
{
MOZ_CRASH
(
"
Unexpected
notification
.
"
)
;
return
NS_OK
;
}
NS_IMETHOD
OnContentBlockingEvent
(
nsIWebProgress
*
aWebProgress
nsIRequest
*
aRequest
uint32_t
aEvent
)
override
{
MOZ_CRASH
(
"
Unexpected
notification
.
"
)
;
return
NS_OK
;
}
NS_DECL_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
NavigateLoadListener
nsIWebProgressListener
nsISupportsWeakReference
)
;
}
RefPtr
<
ClientOpPromise
>
ClientNavigateOpChild
:
:
DoNavigate
(
const
ClientNavigateOpConstructorArgs
&
aArgs
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
;
{
ClientSourceChild
*
targetActor
=
static_cast
<
ClientSourceChild
*
>
(
aArgs
.
targetChild
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
targetActor
)
;
ClientSource
*
target
=
targetActor
-
>
GetSource
(
)
;
if
(
!
target
)
{
CopyableErrorResult
rv
;
rv
.
ThrowDOMException
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
Unknown
Client
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
window
=
target
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
CopyableErrorResult
rv
;
rv
.
ThrowDOMException
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
Client
load
for
a
destroyed
Window
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSerialEventTarget
=
window
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
nsCOMPtr
<
nsIURI
>
baseURL
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
baseURL
)
aArgs
.
baseURL
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
CopyableErrorResult
result
;
result
.
ThrowDOMException
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
Invalid
worker
URL
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
result
__func__
)
;
}
bool
shouldUseBaseURL
=
true
;
nsAutoCString
scheme
;
if
(
NS_SUCCEEDED
(
net_ExtractURLScheme
(
aArgs
.
url
(
)
scheme
)
)
&
&
scheme
.
LowerCaseEqualsLiteral
(
"
view
-
source
"
)
)
{
shouldUseBaseURL
=
false
;
}
nsCOMPtr
<
nsIURI
>
url
;
rv
=
NS_NewURI
(
getter_AddRefs
(
url
)
aArgs
.
url
(
)
nullptr
shouldUseBaseURL
?
baseURL
.
get
(
)
:
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsPrintfCString
err
(
"
Invalid
URL
\
"
%
s
\
"
"
aArgs
.
url
(
)
.
get
(
)
)
;
CopyableErrorResult
result
;
result
.
ThrowTypeError
(
NS_ConvertUTF8toUTF16
(
err
)
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
result
__func__
)
;
}
if
(
url
-
>
GetSpecOrDefault
(
)
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
CopyableErrorResult
result
;
result
.
ThrowTypeError
(
u
"
Client
.
navigate
to
\
"
about
:
blank
\
"
is
not
allowed
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
result
__func__
)
;
}
RefPtr
<
Document
>
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
doc
|
|
!
doc
-
>
IsActive
(
)
)
{
CopyableErrorResult
result
;
result
.
ThrowDOMException
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
Document
is
not
active
.
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
result
__func__
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
doc
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
window
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIWebProgress
>
webProgress
=
do_GetInterface
(
docShell
)
;
if
(
!
docShell
|
|
!
webProgress
)
{
CopyableErrorResult
result
;
result
.
ThrowDOMException
(
NS_ERROR_DOM_INVALID_STATE_ERR
"
Document
'
s
browsing
context
has
been
discarded
"
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
result
__func__
)
;
}
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
url
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
new
ReferrerInfo
(
)
;
referrerInfo
-
>
InitWithDocument
(
doc
)
;
loadState
-
>
SetTriggeringPrincipal
(
principal
)
;
loadState
-
>
SetCsp
(
doc
-
>
GetCsp
(
)
)
;
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
loadState
-
>
SetLoadType
(
LOAD_STOP_CONTENT
)
;
loadState
-
>
SetSourceDocShell
(
docShell
)
;
loadState
-
>
SetLoadFlags
(
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
)
;
loadState
-
>
SetFirstParty
(
true
)
;
rv
=
docShell
-
>
LoadURI
(
loadState
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
nsPrintfCString
err
(
"
Invalid
URL
\
"
%
s
\
"
"
aArgs
.
url
(
)
.
get
(
)
)
;
CopyableErrorResult
result
;
result
.
ThrowTypeError
(
NS_ConvertUTF8toUTF16
(
err
)
)
;
return
ClientOpPromise
:
:
CreateAndReject
(
result
__func__
)
;
}
RefPtr
<
ClientOpPromise
:
:
Private
>
promise
=
new
ClientOpPromise
:
:
Private
(
__func__
)
;
nsCOMPtr
<
nsIWebProgressListener
>
listener
=
new
NavigateLoadListener
(
promise
window
-
>
GetOuterWindow
(
)
baseURL
)
;
rv
=
webProgress
-
>
AddProgressListener
(
listener
nsIWebProgress
:
:
NOTIFY_STATE_DOCUMENT
)
;
if
(
NS_FAILED
(
rv
)
)
{
CopyableErrorResult
result
;
result
.
Throw
(
rv
)
;
promise
-
>
Reject
(
result
__func__
)
;
return
promise
.
forget
(
)
;
}
return
promise
-
>
Then
(
mSerialEventTarget
__func__
[
listener
]
(
const
ClientOpPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
return
ClientOpPromise
:
:
CreateAndResolveOrReject
(
aValue
__func__
)
;
}
)
;
}
void
ClientNavigateOpChild
:
:
ActorDestroy
(
ActorDestroyReason
aReason
)
{
mPromiseRequestHolder
.
DisconnectIfExists
(
)
;
}
void
ClientNavigateOpChild
:
:
Init
(
const
ClientNavigateOpConstructorArgs
&
aArgs
)
{
RefPtr
<
ClientOpPromise
>
promise
=
DoNavigate
(
aArgs
)
;
if
(
!
mSerialEventTarget
)
{
mSerialEventTarget
=
GetCurrentThreadSerialEventTarget
(
)
;
}
promise
-
>
Then
(
mSerialEventTarget
__func__
[
this
]
(
const
ClientOpResult
&
aResult
)
{
mPromiseRequestHolder
.
Complete
(
)
;
PClientNavigateOpChild
:
:
Send__delete__
(
this
aResult
)
;
}
[
this
]
(
const
CopyableErrorResult
&
aResult
)
{
mPromiseRequestHolder
.
Complete
(
)
;
PClientNavigateOpChild
:
:
Send__delete__
(
this
aResult
)
;
}
)
-
>
Track
(
mPromiseRequestHolder
)
;
}
}
}
