#
ifndef
DOM_NOTIFICATION_NOTIFICATIONUTILS_H_
#
define
DOM_NOTIFICATION_NOTIFICATIONUTILS_H_
#
include
<
cstdint
>
#
include
"
mozilla
/
dom
/
DOMTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINotificationStorage
.
h
"
#
include
"
nsStringFwd
.
h
"
enum
class
nsresult
:
uint32_t
;
class
nsIAlertNotification
;
class
nsIPrincipal
;
class
nsINotificationStorage
;
namespace
mozilla
:
:
dom
{
enum
class
NotificationPermission
:
uint8_t
;
class
Document
;
}
namespace
mozilla
:
:
dom
:
:
notification
{
static
constexpr
uint8_t
kMaxActions
=
2
;
NotificationPermission
GetRawNotificationPermission
(
nsIPrincipal
*
aPrincipal
)
;
enum
class
PermissionCheckPurpose
:
uint8_t
{
PermissionRequest
PermissionAttribute
NotificationShow
}
;
bool
IsNotificationAllowedFor
(
nsIPrincipal
*
aPrincipal
)
;
bool
IsNotificationForbiddenFor
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aEffectiveStoragePrincipal
bool
isSecureContext
PermissionCheckPurpose
aPurpose
Document
*
aRequestorDoc
=
nullptr
)
;
NotificationPermission
GetNotificationPermission
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aEffectiveStoragePrincipal
bool
isSecureContext
PermissionCheckPurpose
aPurpose
)
;
nsCOMPtr
<
nsINotificationStorage
>
GetNotificationStorage
(
bool
isPrivate
)
;
using
NotificationsPromise
=
MozPromise
<
CopyableTArray
<
IPCNotification
>
nsresult
false
>
;
already_AddRefed
<
NotificationsPromise
>
GetStoredNotificationsForScope
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
const
nsAString
&
aTag
)
;
nsresult
GetOrigin
(
nsIPrincipal
*
aPrincipal
nsString
&
aOrigin
)
;
nsresult
PersistNotification
(
nsIPrincipal
*
aPrincipal
const
IPCNotification
&
aNotification
const
nsString
&
aScope
)
;
nsresult
UnpersistNotification
(
nsIPrincipal
*
aPrincipal
const
nsString
&
aId
)
;
enum
class
CloseMode
{
CloseMethod
InactiveGlobal
}
;
void
UnregisterNotification
(
nsIPrincipal
*
aPrincipal
const
nsString
&
aId
)
;
nsresult
ShowAlertWithCleanup
(
nsIAlertNotification
*
aAlert
nsIObserver
*
aAlertListener
)
;
nsresult
RemovePermission
(
nsIPrincipal
*
aPrincipal
)
;
nsresult
OpenSettings
(
nsIPrincipal
*
aPrincipal
)
;
enum
class
NotificationStatusChange
{
Shown
Closed
}
;
nsresult
AdjustPushQuota
(
nsIPrincipal
*
aPrincipal
NotificationStatusChange
aChange
)
;
class
NotificationActionStorageEntry
:
public
nsINotificationActionStorageEntry
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSINOTIFICATIONACTIONSTORAGEENTRY
explicit
NotificationActionStorageEntry
(
const
IPCNotificationAction
&
aIPCAction
)
:
mIPCAction
(
aIPCAction
)
{
}
static
Result
<
IPCNotificationAction
nsresult
>
ToIPC
(
nsINotificationActionStorageEntry
&
aEntry
)
;
private
:
virtual
~
NotificationActionStorageEntry
(
)
=
default
;
IPCNotificationAction
mIPCAction
;
}
;
class
NotificationStorageEntry
:
public
nsINotificationStorageEntry
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSINOTIFICATIONSTORAGEENTRY
explicit
NotificationStorageEntry
(
const
IPCNotification
&
aIPCNotification
)
:
mIPCNotification
(
aIPCNotification
)
{
}
static
Result
<
IPCNotification
nsresult
>
ToIPC
(
nsINotificationStorageEntry
&
aEntry
)
;
private
:
virtual
~
NotificationStorageEntry
(
)
=
default
;
IPCNotification
mIPCNotification
;
}
;
}
#
endif
