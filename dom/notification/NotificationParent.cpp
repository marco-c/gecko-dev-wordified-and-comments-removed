#
include
"
NotificationParent
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
NotificationUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIAlertsService
.
h
"
#
include
"
nsIServiceWorkerManager
.
h
"
namespace
mozilla
:
:
dom
:
:
notification
{
NS_IMPL_ISUPPORTS
(
NotificationParent
nsIObserver
)
NS_IMETHODIMP
NotificationParent
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
"
alertdisablecallback
"
aTopic
)
)
{
return
RemovePermission
(
mPrincipal
)
;
}
if
(
!
strcmp
(
"
alertsettingscallback
"
aTopic
)
)
{
return
OpenSettings
(
mPrincipal
)
;
}
if
(
!
strcmp
(
"
alertclickcallback
"
aTopic
)
)
{
return
FireClickEvent
(
)
;
}
if
(
!
strcmp
(
"
alertshow
"
aTopic
)
)
{
if
(
!
mResolver
)
{
#
ifdef
ANDROID
return
NS_OK
;
#
else
MOZ_ASSERT_UNREACHABLE
(
"
Are
we
getting
double
show
events
?
"
)
;
return
NS_ERROR_FAILURE
;
#
endif
}
(
void
)
NS_WARN_IF
(
NS_FAILED
(
AdjustPushQuota
(
mPrincipal
NotificationStatusChange
:
:
Shown
)
)
)
;
nsresult
rv
=
PersistNotification
(
mPrincipal
IPCNotification
(
mId
mOptions
)
mScope
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Could
not
persist
Notification
"
)
;
}
mResolver
.
take
(
)
.
value
(
)
(
CopyableErrorResult
(
)
)
;
return
NS_OK
;
}
if
(
!
strcmp
(
"
alertfinished
"
aTopic
)
)
{
if
(
mResolver
)
{
mResolver
.
take
(
)
.
value
(
)
(
CopyableErrorResult
(
NS_ERROR_FAILURE
)
)
;
}
else
{
(
void
)
NS_WARN_IF
(
NS_FAILED
(
AdjustPushQuota
(
mPrincipal
NotificationStatusChange
:
:
Closed
)
)
)
;
(
void
)
NS_WARN_IF
(
NS_FAILED
(
UnpersistNotification
(
mPrincipal
mId
)
)
)
;
(
void
)
NS_WARN_IF
(
NS_FAILED
(
FireCloseEvent
(
)
)
)
;
}
mDangling
=
true
;
Close
(
)
;
return
NS_OK
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
notification
topic
"
)
;
return
NS_OK
;
}
nsresult
NotificationParent
:
:
FireClickEvent
(
)
{
if
(
mScope
.
IsEmpty
(
)
)
{
if
(
SendNotifyClick
(
)
)
{
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
if
(
nsCOMPtr
<
nsIServiceWorkerManager
>
swm
=
mozilla
:
:
components
:
:
ServiceWorkerManager
:
:
Service
(
)
)
{
nsAutoCString
originSuffix
;
MOZ_TRY
(
mPrincipal
-
>
GetOriginSuffix
(
originSuffix
)
)
;
MOZ_TRY
(
swm
-
>
SendNotificationClickEvent
(
originSuffix
mScope
IPCNotification
(
mId
mOptions
)
)
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
NotificationParent
:
:
FireCloseEvent
(
)
{
if
(
nsCOMPtr
<
nsIServiceWorkerManager
>
swm
=
mozilla
:
:
components
:
:
ServiceWorkerManager
:
:
Service
(
)
)
{
nsAutoCString
originSuffix
;
MOZ_TRY
(
mPrincipal
-
>
GetOriginSuffix
(
originSuffix
)
)
;
MOZ_TRY
(
swm
-
>
SendNotificationCloseEvent
(
originSuffix
mScope
IPCNotification
(
mId
mOptions
)
)
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
mozilla
:
:
ipc
:
:
IPCResult
NotificationParent
:
:
RecvShow
(
ShowResolver
&
&
aResolver
)
{
MOZ_ASSERT
(
mId
.
IsEmpty
(
)
"
ID
should
not
be
given
for
a
new
notification
"
)
;
mResolver
.
emplace
(
std
:
:
move
(
aResolver
)
)
;
NotificationPermission
permission
=
GetNotificationPermission
(
mPrincipal
mEffectiveStoragePrincipal
mIsSecureContext
PermissionCheckPurpose
:
:
NotificationShow
)
;
if
(
permission
!
=
NotificationPermission
:
:
Granted
)
{
CopyableErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Permission
to
show
Notification
denied
.
"
)
;
mResolver
.
take
(
)
.
value
(
)
(
rv
)
;
mDangling
=
true
;
return
IPC_OK
(
)
;
}
nsresult
rv
=
Show
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
mResolver
)
{
mResolver
.
take
(
)
.
value
(
)
(
CopyableErrorResult
(
rv
)
)
;
}
return
IPC_OK
(
)
;
}
nsresult
NotificationParent
:
:
Show
(
)
{
nsString
obsoleteCookie
=
u
"
notification
:
"
_ns
;
bool
requireInteraction
=
mOptions
.
requireInteraction
(
)
;
if
(
!
StaticPrefs
:
:
dom_webnotifications_requireinteraction_enabled
(
)
)
{
requireInteraction
=
false
;
}
nsCOMPtr
<
nsIAlertNotification
>
alert
=
do_CreateInstance
(
ALERT_NOTIFICATION_CONTRACTID
)
;
if
(
!
alert
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
MOZ_TRY
(
alert
-
>
Init
(
mOptions
.
tag
(
)
mOptions
.
icon
(
)
mOptions
.
title
(
)
mOptions
.
body
(
)
true
obsoleteCookie
NS_ConvertASCIItoUTF16
(
GetEnumString
(
mOptions
.
dir
(
)
)
)
mOptions
.
lang
(
)
mOptions
.
dataSerialized
(
)
mPrincipal
mPrincipal
-
>
GetIsInPrivateBrowsing
(
)
requireInteraction
mOptions
.
silent
(
)
mOptions
.
vibrate
(
)
)
)
;
MOZ_TRY
(
alert
-
>
GetId
(
mId
)
)
;
nsCOMPtr
<
nsIAlertsService
>
alertService
=
components
:
:
Alerts
:
:
Service
(
)
;
MOZ_TRY
(
alertService
-
>
ShowAlert
(
alert
this
)
)
;
#
ifdef
ANDROID
Observe
(
nullptr
"
alertshow
"
nullptr
)
;
#
endif
return
NS_OK
;
}
mozilla
:
:
ipc
:
:
IPCResult
NotificationParent
:
:
RecvClose
(
)
{
Unregister
(
CloseMode
:
:
CloseMethod
)
;
Close
(
)
;
return
IPC_OK
(
)
;
}
void
NotificationParent
:
:
Unregister
(
CloseMode
aCloseMode
)
{
if
(
mDangling
)
{
return
;
}
mDangling
=
true
;
UnregisterNotification
(
mPrincipal
mId
aCloseMode
)
;
}
nsresult
NotificationParent
:
:
BindToMainThread
(
Endpoint
<
PNotificationParent
>
&
&
aParentEndpoint
PBackgroundParent
:
:
CreateNotificationParentResolver
&
&
aResolver
)
{
nsCOMPtr
<
nsIThread
>
thread
=
NS_GetCurrentThread
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
NotificationParent
:
:
BindToMainThread
"
[
self
=
RefPtr
(
this
)
endpoint
=
std
:
:
move
(
aParentEndpoint
)
resolver
=
std
:
:
move
(
aResolver
)
thread
]
(
)
mutable
{
bool
result
=
endpoint
.
Bind
(
self
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
NotificationParent
:
:
BindToMainThreadResult
"
[
result
resolver
=
std
:
:
move
(
resolver
)
]
(
)
{
resolver
(
result
)
;
}
)
)
;
}
)
)
;
return
NS_OK
;
}
void
NotificationParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
Unregister
(
CloseMode
:
:
InactiveGlobal
)
;
}
}
