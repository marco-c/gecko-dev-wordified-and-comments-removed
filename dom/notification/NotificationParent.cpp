#
include
"
NotificationParent
.
h
"
#
include
"
NotificationHandler
.
h
"
#
include
"
NotificationUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
AlertNotification
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
ipc
/
Endpoint
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIServiceWorkerManager
.
h
"
namespace
mozilla
:
:
dom
:
:
notification
{
NS_IMPL_ISUPPORTS0
(
NotificationParent
)
class
NotificationObserver
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NotificationObserver
(
const
nsAString
&
aScope
nsIPrincipal
*
aPrincipal
IPCNotification
aNotification
NotificationParent
&
aParent
)
:
mScope
(
aScope
)
mPrincipal
(
aPrincipal
)
mNotification
(
std
:
:
move
(
aNotification
)
)
mActor
(
&
aParent
)
{
}
NS_IMETHODIMP
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
AlertTopic
topic
=
ToAlertTopic
(
aTopic
)
;
if
(
topic
=
=
AlertTopic
:
:
Disable
)
{
return
RemovePermission
(
mPrincipal
)
;
}
if
(
topic
=
=
AlertTopic
:
:
Settings
)
{
return
OpenSettings
(
mPrincipal
)
;
}
RefPtr
<
NotificationParent
>
actor
(
mActor
)
;
if
(
actor
&
&
actor
-
>
CanSend
(
)
)
{
actor
-
>
HandleAlertTopic
(
topic
)
;
if
(
mScope
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
}
else
if
(
mScope
.
IsEmpty
(
)
)
{
if
(
topic
=
=
AlertTopic
:
:
Click
)
{
return
OpenWindowFor
(
mPrincipal
)
;
}
return
NS_OK
;
}
MOZ_ASSERT
(
!
mScope
.
IsEmpty
(
)
)
;
if
(
topic
=
=
AlertTopic
:
:
Show
)
{
(
void
)
NS_WARN_IF
(
NS_FAILED
(
AdjustPushQuota
(
mPrincipal
NotificationStatusChange
:
:
Shown
)
)
)
;
nsresult
rv
=
PersistNotification
(
mPrincipal
mNotification
mScope
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Could
not
persist
Notification
"
)
;
}
return
NS_OK
;
}
MOZ_ASSERT
(
topic
=
=
AlertTopic
:
:
Click
|
|
topic
=
=
AlertTopic
:
:
Finished
)
;
if
(
topic
=
=
AlertTopic
:
:
Click
)
{
nsCOMPtr
<
nsIAlertAction
>
action
=
do_QueryInterface
(
aSubject
)
;
nsAutoString
actionName
;
if
(
action
)
{
MOZ_TRY
(
action
-
>
GetAction
(
actionName
)
)
;
}
return
RespondOnClick
(
mPrincipal
mScope
mNotification
actionName
)
;
}
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
!
swm
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoCString
originSuffix
;
MOZ_TRY
(
mPrincipal
-
>
GetOriginSuffix
(
originSuffix
)
)
;
MOZ_ASSERT
(
topic
=
=
AlertTopic
:
:
Finished
)
;
(
void
)
NS_WARN_IF
(
NS_FAILED
(
AdjustPushQuota
(
mPrincipal
NotificationStatusChange
:
:
Closed
)
)
)
;
(
void
)
NS_WARN_IF
(
NS_FAILED
(
UnpersistNotification
(
mPrincipal
mNotification
.
id
(
)
)
)
)
;
(
void
)
swm
-
>
SendNotificationCloseEvent
(
originSuffix
mScope
mNotification
)
;
return
NS_OK
;
}
private
:
virtual
~
NotificationObserver
(
)
=
default
;
static
AlertTopic
ToAlertTopic
(
const
char
*
aTopic
)
{
if
(
!
strcmp
(
"
alertdisablecallback
"
aTopic
)
)
{
return
AlertTopic
:
:
Disable
;
}
if
(
!
strcmp
(
"
alertsettingscallback
"
aTopic
)
)
{
return
AlertTopic
:
:
Settings
;
}
if
(
!
strcmp
(
"
alertclickcallback
"
aTopic
)
)
{
return
AlertTopic
:
:
Click
;
}
if
(
!
strcmp
(
"
alertshow
"
aTopic
)
)
{
return
AlertTopic
:
:
Show
;
}
if
(
!
strcmp
(
"
alertfinished
"
aTopic
)
)
{
return
AlertTopic
:
:
Finished
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
alert
topic
"
)
;
return
AlertTopic
:
:
Finished
;
}
nsString
mScope
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
IPCNotification
mNotification
;
WeakPtr
<
NotificationParent
>
mActor
;
}
;
NS_IMPL_ISUPPORTS
(
NotificationObserver
nsIObserver
)
nsresult
NotificationParent
:
:
HandleAlertTopic
(
AlertTopic
aTopic
)
{
if
(
aTopic
=
=
AlertTopic
:
:
Click
)
{
return
FireClickEvent
(
)
;
}
if
(
aTopic
=
=
AlertTopic
:
:
Show
)
{
if
(
!
mResolver
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Are
we
getting
double
show
events
?
"
)
;
return
NS_ERROR_FAILURE
;
}
mResolver
.
take
(
)
.
value
(
)
(
CopyableErrorResult
(
)
)
;
return
NS_OK
;
}
if
(
aTopic
=
=
AlertTopic
:
:
Finished
)
{
if
(
mResolver
)
{
CopyableErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Failed
to
show
notification
potentially
because
the
browser
did
"
"
not
have
the
corresponding
OS
-
level
permission
.
"
_ns
)
;
mResolver
.
take
(
)
.
value
(
)
(
rv
)
;
}
mDangling
=
true
;
Close
(
)
;
return
NS_OK
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
notification
topic
"
)
;
return
NS_OK
;
}
nsresult
NotificationParent
:
:
FireClickEvent
(
)
{
if
(
!
mArgs
.
mScope
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
if
(
SendNotifyClick
(
)
)
{
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
mozilla
:
:
ipc
:
:
IPCResult
NotificationParent
:
:
RecvShow
(
ShowResolver
&
&
aResolver
)
{
MOZ_ASSERT
(
mId
.
IsEmpty
(
)
"
ID
should
not
be
given
for
a
new
notification
"
)
;
mResolver
.
emplace
(
std
:
:
move
(
aResolver
)
)
;
NotificationPermission
permission
=
GetNotificationPermission
(
mArgs
.
mPrincipal
mArgs
.
mEffectiveStoragePrincipal
mArgs
.
mIsSecureContext
PermissionCheckPurpose
:
:
NotificationShow
)
;
if
(
permission
!
=
NotificationPermission
:
:
Granted
)
{
CopyableErrorResult
rv
;
rv
.
ThrowTypeError
(
"
Permission
to
show
Notification
denied
.
"
)
;
mResolver
.
take
(
)
.
value
(
)
(
rv
)
;
mDangling
=
true
;
return
IPC_OK
(
)
;
}
nsresult
rv
=
Show
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
mResolver
)
{
mResolver
.
take
(
)
.
value
(
)
(
CopyableErrorResult
(
rv
)
)
;
}
return
IPC_OK
(
)
;
}
nsresult
NotificationParent
:
:
Show
(
)
{
nsString
obsoleteCookie
=
u
"
notification
:
"
_ns
;
const
IPCNotificationOptions
&
options
=
mArgs
.
mNotification
.
options
(
)
;
bool
requireInteraction
=
options
.
requireInteraction
(
)
;
if
(
!
StaticPrefs
:
:
dom_webnotifications_requireinteraction_enabled
(
)
)
{
requireInteraction
=
false
;
}
nsCOMPtr
<
nsIAlertNotification
>
alert
=
do_CreateInstance
(
ALERT_NOTIFICATION_CONTRACTID
)
;
if
(
!
alert
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
mArgs
.
mPrincipal
;
MOZ_TRY
(
alert
-
>
Init
(
options
.
tag
(
)
options
.
icon
(
)
options
.
title
(
)
options
.
body
(
)
true
obsoleteCookie
NS_ConvertASCIItoUTF16
(
GetEnumString
(
options
.
dir
(
)
)
)
options
.
lang
(
)
options
.
dataSerialized
(
)
principal
principal
-
>
GetIsInPrivateBrowsing
(
)
requireInteraction
options
.
silent
(
)
options
.
vibrate
(
)
)
)
;
nsTArray
<
RefPtr
<
nsIAlertAction
>
>
actions
;
MOZ_ASSERT
(
options
.
actions
(
)
.
Length
(
)
<
=
kMaxActions
)
;
for
(
const
auto
&
action
:
options
.
actions
(
)
)
{
actions
.
AppendElement
(
new
AlertAction
(
action
.
name
(
)
action
.
title
(
)
)
)
;
}
alert
-
>
SetActions
(
actions
)
;
MOZ_TRY
(
alert
-
>
GetId
(
mId
)
)
;
RefPtr
<
NotificationObserver
>
observer
=
new
NotificationObserver
(
mArgs
.
mScope
principal
IPCNotification
(
mId
options
)
*
this
)
;
MOZ_TRY
(
ShowAlertWithCleanup
(
alert
observer
)
)
;
return
NS_OK
;
}
mozilla
:
:
ipc
:
:
IPCResult
NotificationParent
:
:
RecvClose
(
)
{
Unregister
(
)
;
Close
(
)
;
return
IPC_OK
(
)
;
}
void
NotificationParent
:
:
Unregister
(
)
{
if
(
mDangling
)
{
return
;
}
mDangling
=
true
;
UnregisterNotification
(
mArgs
.
mPrincipal
mId
)
;
}
nsresult
NotificationParent
:
:
CreateOnMainThread
(
NotificationParentArgs
&
&
mArgs
Endpoint
<
PNotificationParent
>
&
&
aParentEndpoint
PBackgroundParent
:
:
CreateNotificationParentResolver
&
&
aResolver
)
{
if
(
mArgs
.
mNotification
.
options
(
)
.
actions
(
)
.
Length
(
)
>
kMaxActions
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIThread
>
thread
=
NS_GetCurrentThread
(
)
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
NotificationParent
:
:
BindToMainThread
"
[
args
=
std
:
:
move
(
mArgs
)
endpoint
=
std
:
:
move
(
aParentEndpoint
)
resolver
=
std
:
:
move
(
aResolver
)
thread
]
(
)
mutable
{
RefPtr
<
NotificationParent
>
actor
=
new
NotificationParent
(
std
:
:
move
(
args
)
)
;
bool
result
=
endpoint
.
Bind
(
actor
)
;
thread
-
>
Dispatch
(
NS_NewRunnableFunction
(
"
NotificationParent
:
:
BindToMainThreadResult
"
[
result
resolver
=
std
:
:
move
(
resolver
)
]
(
)
{
resolver
(
result
)
;
}
)
)
;
}
)
)
;
return
NS_OK
;
}
}
