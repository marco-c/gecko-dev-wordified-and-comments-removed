#
ifndef
mozilla_dom_notification_h__
#
define
mozilla_dom_notification_h__
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
GlobalFreezeObserver
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
NotificationBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaCommon
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsIPrincipal
;
class
nsIVariant
;
namespace
mozilla
:
:
dom
{
class
NotificationRef
;
class
WorkerNotificationObserver
;
class
Promise
;
class
StrongWorkerRef
;
namespace
notification
{
enum
class
PermissionCheckPurpose
:
uint8_t
;
}
class
Notification
:
public
DOMEventTargetHelper
public
GlobalFreezeObserver
{
friend
class
CloseNotificationRunnable
;
friend
class
NotificationTask
;
friend
class
NotificationPermissionRequest
;
friend
class
MainThreadNotificationObserver
;
friend
class
NotificationStorageCallback
;
friend
class
ServiceWorkerNotificationObserver
;
friend
class
WorkerGetRunnable
;
friend
class
WorkerNotificationObserver
;
public
:
IMPL_EVENT_HANDLER
(
click
)
IMPL_EVENT_HANDLER
(
show
)
IMPL_EVENT_HANDLER
(
error
)
IMPL_EVENT_HANDLER
(
close
)
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
Notification
DOMEventTargetHelper
)
static
bool
PrefEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
;
static
already_AddRefed
<
Notification
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aTitle
const
NotificationOptions
&
aOption
ErrorResult
&
aRv
)
;
static
Result
<
already_AddRefed
<
Notification
>
QMResult
>
ConstructFromFields
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aServiceWorkerRegistrationScope
)
;
void
GetID
(
nsAString
&
aRetval
)
{
aRetval
=
mID
;
}
void
GetTitle
(
nsAString
&
aRetval
)
{
aRetval
=
mTitle
;
}
NotificationDirection
Dir
(
)
{
return
mDir
;
}
void
GetLang
(
nsAString
&
aRetval
)
{
aRetval
=
mLang
;
}
void
GetBody
(
nsAString
&
aRetval
)
{
aRetval
=
mBody
;
}
void
GetTag
(
nsAString
&
aRetval
)
{
aRetval
=
mTag
;
}
void
GetIcon
(
nsAString
&
aRetval
)
{
aRetval
=
mIconUrl
;
}
void
SetStoredState
(
bool
val
)
{
mIsStored
=
val
;
}
bool
IsStored
(
)
{
return
mIsStored
;
}
static
bool
RequestPermissionEnabledForScope
(
JSContext
*
aCx
JSObject
*
)
;
static
already_AddRefed
<
Promise
>
RequestPermission
(
const
GlobalObject
&
aGlobal
const
Optional
<
OwningNonNull
<
NotificationPermissionCallback
>
>
&
aCallback
ErrorResult
&
aRv
)
;
static
NotificationPermission
GetPermission
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
Get
(
nsPIDOMWindowInner
*
aWindow
const
GetNotificationOptions
&
aFilter
const
nsAString
&
aScope
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
WorkerGet
(
WorkerPrivate
*
aWorkerPrivate
const
GetNotificationOptions
&
aFilter
const
nsAString
&
aScope
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
ShowPersistentNotification
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
const
nsAString
&
aScope
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
ErrorResult
&
aRv
)
;
void
Close
(
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetOwnerGlobal
(
)
;
}
JSObject
*
WrapObject
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
bool
RequireInteraction
(
)
const
;
bool
Silent
(
)
const
;
void
GetVibrate
(
nsTArray
<
uint32_t
>
&
aRetval
)
const
;
void
GetData
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
;
void
InitFromJSVal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aData
ErrorResult
&
aRv
)
;
Result
<
Ok
QMResult
>
InitFromBase64
(
const
nsAString
&
aData
)
;
void
AssertIsOnTargetThread
(
)
const
{
MOZ_ASSERT
(
IsTargetThread
(
)
)
;
}
CheckedUnsafePtr
<
WorkerPrivate
>
mWorkerPrivate
;
bool
mWorkerUseRegularPrincipal
=
false
;
WorkerNotificationObserver
*
mObserver
;
UniquePtr
<
NotificationRef
>
mTempRef
;
bool
AddRefObject
(
)
;
void
ReleaseObject
(
)
;
static
NotificationPermission
GetPermission
(
nsIGlobalObject
*
aGlobal
notification
:
:
PermissionCheckPurpose
aPurpose
ErrorResult
&
aRv
)
;
bool
DispatchClickEvent
(
)
;
static
nsresult
RemovePermission
(
nsIPrincipal
*
aPrincipal
)
;
static
nsresult
OpenSettings
(
nsIPrincipal
*
aPrincipal
)
;
nsresult
DispatchToMainThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
protected
:
Notification
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aBody
NotificationDirection
aDir
const
nsAString
&
aLang
const
nsAString
&
aTag
const
nsAString
&
aIconUrl
bool
aRequireInteraction
bool
aSilent
nsTArray
<
uint32_t
>
&
&
aVibrate
const
NotificationBehavior
&
aBehavior
)
;
static
already_AddRefed
<
Notification
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
;
nsresult
MaybeObserveWindowFrozen
(
)
;
bool
IsInPrivateBrowsing
(
)
;
void
ShowInternal
(
)
;
void
CloseInternal
(
bool
aContextClosed
=
false
)
;
void
DisconnectFromOwner
(
)
override
;
void
FrozenCallback
(
nsIGlobalObject
*
aOwner
)
override
;
static
NotificationPermission
GetPermissionInternal
(
nsPIDOMWindowInner
*
aWindow
notification
:
:
PermissionCheckPurpose
aPurpose
ErrorResult
&
rv
)
;
static
nsresult
GetOrigin
(
nsIPrincipal
*
aPrincipal
nsString
&
aOrigin
)
;
void
GetAlertName
(
nsAString
&
aRetval
)
{
AssertIsOnMainThread
(
)
;
if
(
mAlertName
.
IsEmpty
(
)
)
{
SetAlertName
(
)
;
}
aRetval
=
mAlertName
;
}
void
GetScope
(
nsAString
&
aScope
)
{
aScope
=
mScope
;
}
void
SetScope
(
const
nsAString
&
aScope
)
{
MOZ_ASSERT
(
mScope
.
IsEmpty
(
)
)
;
mScope
=
aScope
;
}
const
nsString
mID
;
const
nsString
mTitle
;
const
nsString
mBody
;
const
NotificationDirection
mDir
;
const
nsString
mLang
;
const
nsString
mTag
;
const
nsString
mIconUrl
;
const
bool
mRequireInteraction
;
const
bool
mSilent
;
nsTArray
<
uint32_t
>
mVibrate
;
nsString
mDataAsBase64
;
const
NotificationBehavior
mBehavior
;
JS
:
:
Heap
<
JS
:
:
Value
>
mData
;
nsString
mAlertName
;
nsString
mScope
;
bool
mIsClosed
;
bool
mIsStored
;
static
uint32_t
sCount
;
private
:
virtual
~
Notification
(
)
;
static
already_AddRefed
<
Notification
>
CreateAndShow
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
const
nsAString
&
aScope
ErrorResult
&
aRv
)
;
nsIPrincipal
*
GetPrincipal
(
)
;
nsresult
PersistNotification
(
)
;
void
UnpersistNotification
(
)
;
void
SetAlertName
(
)
;
bool
IsTargetThread
(
)
const
{
return
NS_IsMainThread
(
)
=
=
!
mWorkerPrivate
;
}
bool
CreateWorkerRef
(
)
;
static
nsresult
ResolveIconAndSoundURL
(
nsIGlobalObject
*
aGlobal
nsString
&
iconUrl
nsString
&
soundUrl
)
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
uint32_t
mTaskCount
;
}
;
}
#
endif
