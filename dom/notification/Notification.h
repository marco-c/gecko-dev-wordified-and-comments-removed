#
ifndef
mozilla_dom_notification_h__
#
define
mozilla_dom_notification_h__
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
NotificationBinding
.
h
"
#
include
"
mozilla
/
dom
/
workers
/
bindings
/
WorkerHolder
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsWeakReference
.
h
"
#
define
NOTIFICATIONTELEMETRYSERVICE_CONTRACTID
\
"
mozilla
.
org
/
notificationTelemetryService
;
1
"
class
nsIPrincipal
;
class
nsIVariant
;
namespace
mozilla
{
namespace
dom
{
class
NotificationRef
;
class
WorkerNotificationObserver
;
class
Promise
;
namespace
workers
{
class
WorkerPrivate
;
}
class
Notification
;
class
NotificationWorkerHolder
final
:
public
workers
:
:
WorkerHolder
{
Notification
*
mNotification
;
public
:
explicit
NotificationWorkerHolder
(
Notification
*
aNotification
)
;
bool
Notify
(
workers
:
:
Status
aStatus
)
override
;
}
;
class
NotificationTelemetryService
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NotificationTelemetryService
(
)
;
static
already_AddRefed
<
NotificationTelemetryService
>
GetInstance
(
)
;
nsresult
Init
(
)
;
void
RecordDNDSupported
(
)
;
void
RecordPermissions
(
)
;
nsresult
RecordSender
(
nsIPrincipal
*
aPrincipal
)
;
private
:
virtual
~
NotificationTelemetryService
(
)
;
nsresult
AddPermissionChangeObserver
(
)
;
nsresult
RemovePermissionChangeObserver
(
)
;
bool
GetNotificationPermission
(
nsISupports
*
aSupports
uint32_t
*
aCapability
)
;
bool
mDNDRecorded
;
nsTHashtable
<
nsStringHashKey
>
mOrigins
;
}
;
class
Notification
:
public
DOMEventTargetHelper
public
nsIObserver
public
nsSupportsWeakReference
{
friend
class
CloseNotificationRunnable
;
friend
class
NotificationTask
;
friend
class
NotificationPermissionRequest
;
friend
class
MainThreadNotificationObserver
;
friend
class
NotificationStorageCallback
;
friend
class
ServiceWorkerNotificationObserver
;
friend
class
WorkerGetRunnable
;
friend
class
WorkerNotificationObserver
;
friend
class
NotificationTelemetryService
;
public
:
IMPL_EVENT_HANDLER
(
click
)
IMPL_EVENT_HANDLER
(
show
)
IMPL_EVENT_HANDLER
(
error
)
IMPL_EVENT_HANDLER
(
close
)
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
Notification
DOMEventTargetHelper
)
NS_DECL_NSIOBSERVER
static
bool
PrefEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
;
static
bool
IsGetEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
;
static
already_AddRefed
<
Notification
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aTitle
const
NotificationOptions
&
aOption
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Notification
>
ConstructFromFields
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aServiceWorkerRegistrationScope
ErrorResult
&
aRv
)
;
void
GetID
(
nsAString
&
aRetval
)
{
aRetval
=
mID
;
}
void
GetTitle
(
nsAString
&
aRetval
)
{
aRetval
=
mTitle
;
}
NotificationDirection
Dir
(
)
{
return
mDir
;
}
void
GetLang
(
nsAString
&
aRetval
)
{
aRetval
=
mLang
;
}
void
GetBody
(
nsAString
&
aRetval
)
{
aRetval
=
mBody
;
}
void
GetTag
(
nsAString
&
aRetval
)
{
aRetval
=
mTag
;
}
void
GetIcon
(
nsAString
&
aRetval
)
{
aRetval
=
mIconUrl
;
}
void
SetStoredState
(
bool
val
)
{
mIsStored
=
val
;
}
bool
IsStored
(
)
{
return
mIsStored
;
}
static
bool
RequestPermissionEnabledForScope
(
JSContext
*
aCx
JSObject
*
)
;
static
already_AddRefed
<
Promise
>
RequestPermission
(
const
GlobalObject
&
aGlobal
const
Optional
<
OwningNonNull
<
NotificationPermissionCallback
>
>
&
aCallback
ErrorResult
&
aRv
)
;
static
NotificationPermission
GetPermission
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
Get
(
nsPIDOMWindowInner
*
aWindow
const
GetNotificationOptions
&
aFilter
const
nsAString
&
aScope
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
Get
(
const
GlobalObject
&
aGlobal
const
GetNotificationOptions
&
aFilter
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
WorkerGet
(
workers
:
:
WorkerPrivate
*
aWorkerPrivate
const
GetNotificationOptions
&
aFilter
const
nsAString
&
aScope
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
ShowPersistentNotification
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
const
nsAString
&
aScope
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
Close
(
)
;
nsPIDOMWindowInner
*
GetParentObject
(
)
{
return
GetOwner
(
)
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
bool
RequireInteraction
(
)
const
;
void
GetData
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
;
void
InitFromJSVal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aData
ErrorResult
&
aRv
)
;
void
InitFromBase64
(
const
nsAString
&
aData
ErrorResult
&
aRv
)
;
void
AssertIsOnTargetThread
(
)
const
{
MOZ_ASSERT
(
IsTargetThread
(
)
)
;
}
workers
:
:
WorkerPrivate
*
mWorkerPrivate
;
WorkerNotificationObserver
*
mObserver
;
UniquePtr
<
NotificationRef
>
mTempRef
;
bool
AddRefObject
(
)
;
void
ReleaseObject
(
)
;
static
NotificationPermission
GetPermission
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
;
static
NotificationPermission
GetPermissionInternal
(
nsIPrincipal
*
aPrincipal
ErrorResult
&
rv
)
;
static
NotificationPermission
TestPermission
(
nsIPrincipal
*
aPrincipal
)
;
bool
DispatchClickEvent
(
)
;
bool
DispatchNotificationClickEvent
(
)
;
static
nsresult
RemovePermission
(
nsIPrincipal
*
aPrincipal
)
;
static
nsresult
OpenSettings
(
nsIPrincipal
*
aPrincipal
)
;
protected
:
Notification
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aBody
NotificationDirection
aDir
const
nsAString
&
aLang
const
nsAString
&
aTag
const
nsAString
&
aIconUrl
bool
aRequireNotification
const
NotificationBehavior
&
aBehavior
)
;
static
already_AddRefed
<
Notification
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
const
nsAString
&
aID
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
)
;
nsresult
Init
(
)
;
bool
IsInPrivateBrowsing
(
)
;
void
ShowInternal
(
)
;
void
CloseInternal
(
)
;
static
NotificationPermission
GetPermissionInternal
(
nsISupports
*
aGlobal
ErrorResult
&
rv
)
;
static
const
nsString
DirectionToString
(
NotificationDirection
aDirection
)
{
switch
(
aDirection
)
{
case
NotificationDirection
:
:
Ltr
:
return
NS_LITERAL_STRING
(
"
ltr
"
)
;
case
NotificationDirection
:
:
Rtl
:
return
NS_LITERAL_STRING
(
"
rtl
"
)
;
default
:
return
NS_LITERAL_STRING
(
"
auto
"
)
;
}
}
static
NotificationDirection
StringToDirection
(
const
nsAString
&
aDirection
)
{
if
(
aDirection
.
EqualsLiteral
(
"
ltr
"
)
)
{
return
NotificationDirection
:
:
Ltr
;
}
if
(
aDirection
.
EqualsLiteral
(
"
rtl
"
)
)
{
return
NotificationDirection
:
:
Rtl
;
}
return
NotificationDirection
:
:
Auto
;
}
static
nsresult
GetOrigin
(
nsIPrincipal
*
aPrincipal
nsString
&
aOrigin
)
;
void
GetAlertName
(
nsAString
&
aRetval
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
if
(
mAlertName
.
IsEmpty
(
)
)
{
SetAlertName
(
)
;
}
aRetval
=
mAlertName
;
}
void
GetScope
(
nsAString
&
aScope
)
{
aScope
=
mScope
;
}
void
SetScope
(
const
nsAString
&
aScope
)
{
MOZ_ASSERT
(
mScope
.
IsEmpty
(
)
)
;
mScope
=
aScope
;
}
const
nsString
mID
;
const
nsString
mTitle
;
const
nsString
mBody
;
const
NotificationDirection
mDir
;
const
nsString
mLang
;
const
nsString
mTag
;
const
nsString
mIconUrl
;
const
bool
mRequireInteraction
;
nsString
mDataAsBase64
;
const
NotificationBehavior
mBehavior
;
JS
:
:
Heap
<
JS
:
:
Value
>
mData
;
nsString
mAlertName
;
nsString
mScope
;
bool
mIsClosed
;
bool
mIsStored
;
static
uint32_t
sCount
;
private
:
virtual
~
Notification
(
)
;
static
already_AddRefed
<
Notification
>
CreateAndShow
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
const
nsAString
&
aScope
ErrorResult
&
aRv
)
;
nsIPrincipal
*
GetPrincipal
(
)
;
nsresult
PersistNotification
(
)
;
void
UnpersistNotification
(
)
;
void
SetAlertName
(
)
;
bool
IsTargetThread
(
)
const
{
return
NS_IsMainThread
(
)
=
=
!
mWorkerPrivate
;
}
bool
RegisterWorkerHolder
(
)
;
void
UnregisterWorkerHolder
(
)
;
nsresult
ResolveIconAndSoundURL
(
nsString
&
nsString
&
)
;
UniquePtr
<
NotificationWorkerHolder
>
mWorkerHolder
;
uint32_t
mTaskCount
;
}
;
}
}
#
endif
