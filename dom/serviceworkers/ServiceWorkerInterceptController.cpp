#
include
"
ServiceWorkerInterceptController
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_ISUPPORTS
(
ServiceWorkerInterceptController
nsINetworkInterceptController
)
NS_IMETHODIMP
ServiceWorkerInterceptController
:
:
ShouldPrepareForIntercept
(
nsIURI
*
aURI
nsIChannel
*
aChannel
bool
*
aShouldIntercept
)
{
*
aShouldIntercept
=
false
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
!
nsContentUtils
:
:
IsNonSubresourceRequest
(
aChannel
)
)
{
const
Maybe
<
ServiceWorkerDescriptor
>
&
controller
=
loadInfo
-
>
GetController
(
)
;
if
(
controller
.
isSome
(
)
)
{
*
aShouldIntercept
=
controller
.
ref
(
)
.
HandlesFetch
(
)
;
if
(
!
*
aShouldIntercept
&
&
swm
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
controller
.
ref
(
)
.
GetPrincipal
(
)
.
unwrap
(
)
;
RefPtr
<
ServiceWorkerRegistrationInfo
>
registration
=
swm
-
>
GetRegistration
(
principal
controller
.
ref
(
)
.
Scope
(
)
)
;
if
(
NS_WARN_IF
(
!
registration
)
)
{
return
NS_OK
;
}
registration
-
>
MaybeScheduleTimeCheckAndUpdate
(
)
;
}
}
else
{
*
aShouldIntercept
=
false
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
StoragePrincipalHelper
:
:
GetPrincipal
(
aChannel
StoragePrincipalHelper
:
:
eForeignPartitionedPrincipal
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
swm
|
|
!
swm
-
>
IsAvailable
(
principal
aURI
aChannel
)
)
{
return
NS_OK
;
}
if
(
!
nsContentUtils
:
:
ComputeIsSecureContext
(
aChannel
)
&
&
!
StaticPrefs
:
:
dom_serviceWorkers_testing_enabled
(
)
)
{
return
NS_OK
;
}
if
(
StorageAllowedForChannel
(
aChannel
)
!
=
StorageAccess
:
:
eAllow
)
{
return
NS_OK
;
}
*
aShouldIntercept
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
ServiceWorkerInterceptController
:
:
ChannelIntercepted
(
nsIInterceptedChannel
*
aChannel
)
{
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
!
swm
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
swm
-
>
DispatchFetchEvent
(
aChannel
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
}
}
