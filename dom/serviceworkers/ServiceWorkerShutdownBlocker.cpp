#
include
"
ServiceWorkerShutdownBlocker
.
h
"
#
include
<
chrono
>
#
include
<
utility
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_ISUPPORTS
(
ServiceWorkerShutdownBlocker
nsIAsyncShutdownBlocker
)
NS_IMETHODIMP
ServiceWorkerShutdownBlocker
:
:
GetName
(
nsAString
&
aNameOut
)
{
aNameOut
=
nsLiteralString
(
u
"
ServiceWorkerShutdownBlocker
:
shutting
down
Service
Workers
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ServiceWorkerShutdownBlocker
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aClient
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mShutdownClient
)
;
MOZ_ASSERT
(
mServiceWorkerManager
)
;
mShutdownClient
=
aClient
;
(
*
mServiceWorkerManager
)
-
>
MaybeStartShutdown
(
)
;
mServiceWorkerManager
.
destroy
(
)
;
MaybeUnblockShutdown
(
)
;
MaybeInitUnblockShutdownTimer
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ServiceWorkerShutdownBlocker
:
:
GetState
(
nsIPropertyBag
*
*
aBagOut
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aBagOut
)
;
nsCOMPtr
<
nsIWritablePropertyBag2
>
propertyBag
=
do_CreateInstance
(
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
)
;
if
(
NS_WARN_IF
(
!
propertyBag
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
nsresult
rv
=
propertyBag
-
>
SetPropertyAsBool
(
u
"
acceptingPromises
"
_ns
IsAcceptingPromises
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
propertyBag
-
>
SetPropertyAsUint32
(
u
"
pendingPromises
"
_ns
GetPendingPromises
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
shutdownStates
;
for
(
auto
iter
=
mShutdownStates
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
shutdownStates
.
Append
(
iter
.
get
(
)
.
value
(
)
.
GetProgressString
(
)
)
;
shutdownStates
.
Append
(
"
"
)
;
}
rv
=
propertyBag
-
>
SetPropertyAsACString
(
u
"
shutdownStates
"
_ns
shutdownStates
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
propertyBag
.
forget
(
aBagOut
)
;
return
NS_OK
;
}
already_AddRefed
<
ServiceWorkerShutdownBlocker
>
ServiceWorkerShutdownBlocker
:
:
CreateAndRegisterOn
(
nsIAsyncShutdownClient
&
aShutdownBarrier
ServiceWorkerManager
&
aServiceWorkerManager
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
ServiceWorkerShutdownBlocker
>
blocker
=
new
ServiceWorkerShutdownBlocker
(
aServiceWorkerManager
)
;
nsresult
rv
=
aShutdownBarrier
.
AddBlocker
(
blocker
.
get
(
)
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
u
"
Service
Workers
shutdown
"
_ns
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
return
blocker
.
forget
(
)
;
}
void
ServiceWorkerShutdownBlocker
:
:
WaitOnPromise
(
GenericNonExclusivePromise
*
aPromise
uint32_t
aShutdownStateId
)
{
AssertIsOnMainThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsAcceptingPromises
(
)
)
;
MOZ_ASSERT
(
aPromise
)
;
MOZ_ASSERT
(
mShutdownStates
.
has
(
aShutdownStateId
)
)
;
+
+
mState
.
as
<
AcceptingPromises
>
(
)
.
mPendingPromises
;
RefPtr
<
ServiceWorkerShutdownBlocker
>
self
=
this
;
aPromise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
std
:
:
move
(
self
)
shutdownStateId
=
aShutdownStateId
]
(
const
GenericNonExclusivePromise
:
:
ResolveOrRejectValue
&
)
{
self
-
>
mShutdownStates
.
remove
(
shutdownStateId
)
;
if
(
!
self
-
>
PromiseSettled
(
)
)
{
self
-
>
MaybeUnblockShutdown
(
)
;
}
}
)
;
}
void
ServiceWorkerShutdownBlocker
:
:
StopAcceptingPromises
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
IsAcceptingPromises
(
)
)
;
mState
=
AsVariant
(
NotAcceptingPromises
(
mState
.
as
<
AcceptingPromises
>
(
)
)
)
;
MaybeUnblockShutdown
(
)
;
MaybeInitUnblockShutdownTimer
(
)
;
}
uint32_t
ServiceWorkerShutdownBlocker
:
:
CreateShutdownState
(
)
{
AssertIsOnMainThread
(
)
;
static
uint32_t
nextShutdownStateId
=
1
;
MOZ_ALWAYS_TRUE
(
mShutdownStates
.
putNew
(
nextShutdownStateId
ServiceWorkerShutdownState
(
)
)
)
;
return
nextShutdownStateId
+
+
;
}
void
ServiceWorkerShutdownBlocker
:
:
ReportShutdownProgress
(
uint32_t
aShutdownStateId
Progress
aProgress
)
{
AssertIsOnMainThread
(
)
;
MOZ_RELEASE_ASSERT
(
aShutdownStateId
!
=
kInvalidShutdownStateId
)
;
auto
lookup
=
mShutdownStates
.
lookup
(
aShutdownStateId
)
;
if
(
!
lookup
)
{
return
;
}
lookup
-
>
value
(
)
.
SetProgress
(
aProgress
)
;
if
(
aProgress
=
=
Progress
:
:
ShutdownCompleted
)
{
mShutdownStates
.
remove
(
lookup
)
;
}
}
ServiceWorkerShutdownBlocker
:
:
ServiceWorkerShutdownBlocker
(
ServiceWorkerManager
&
aServiceWorkerManager
)
:
mState
(
VariantType
<
AcceptingPromises
>
(
)
)
mServiceWorkerManager
(
WrapNotNull
(
&
aServiceWorkerManager
)
)
{
AssertIsOnMainThread
(
)
;
}
ServiceWorkerShutdownBlocker
:
:
~
ServiceWorkerShutdownBlocker
(
)
{
MOZ_ASSERT
(
!
IsAcceptingPromises
(
)
)
;
MOZ_ASSERT
(
!
GetPendingPromises
(
)
)
;
MOZ_ASSERT
(
!
mShutdownClient
)
;
MOZ_ASSERT
(
!
mServiceWorkerManager
)
;
}
void
ServiceWorkerShutdownBlocker
:
:
MaybeUnblockShutdown
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mShutdownClient
|
|
IsAcceptingPromises
(
)
|
|
GetPendingPromises
(
)
)
{
return
;
}
UnblockShutdown
(
)
;
}
void
ServiceWorkerShutdownBlocker
:
:
UnblockShutdown
(
)
{
MOZ_ASSERT
(
mShutdownClient
)
;
mShutdownClient
-
>
RemoveBlocker
(
this
)
;
mShutdownClient
=
nullptr
;
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
}
}
uint32_t
ServiceWorkerShutdownBlocker
:
:
PromiseSettled
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
GetPendingPromises
(
)
)
;
if
(
IsAcceptingPromises
(
)
)
{
return
-
-
mState
.
as
<
AcceptingPromises
>
(
)
.
mPendingPromises
;
}
return
-
-
mState
.
as
<
NotAcceptingPromises
>
(
)
.
mPendingPromises
;
}
bool
ServiceWorkerShutdownBlocker
:
:
IsAcceptingPromises
(
)
const
{
AssertIsOnMainThread
(
)
;
return
mState
.
is
<
AcceptingPromises
>
(
)
;
}
uint32_t
ServiceWorkerShutdownBlocker
:
:
GetPendingPromises
(
)
const
{
AssertIsOnMainThread
(
)
;
if
(
IsAcceptingPromises
(
)
)
{
return
mState
.
as
<
AcceptingPromises
>
(
)
.
mPendingPromises
;
}
return
mState
.
as
<
NotAcceptingPromises
>
(
)
.
mPendingPromises
;
}
ServiceWorkerShutdownBlocker
:
:
NotAcceptingPromises
:
:
NotAcceptingPromises
(
AcceptingPromises
aPreviousState
)
:
mPendingPromises
(
aPreviousState
.
mPendingPromises
)
{
AssertIsOnMainThread
(
)
;
}
NS_IMETHODIMP
ServiceWorkerShutdownBlocker
:
:
Notify
(
nsITimer
*
)
{
UnblockShutdown
(
)
;
return
NS_OK
;
}
#
ifdef
RELEASE_OR_BETA
#
define
SW_UNBLOCK_SHUTDOWN_TIMER_DURATION
10s
#
else
#
define
SW_UNBLOCK_SHUTDOWN_TIMER_DURATION
200s
#
endif
void
ServiceWorkerShutdownBlocker
:
:
MaybeInitUnblockShutdownTimer
(
)
{
AssertIsOnMainThread
(
)
;
if
(
mTimer
|
|
!
mShutdownClient
|
|
IsAcceptingPromises
(
)
)
{
return
;
}
MOZ_ASSERT
(
GetPendingPromises
(
)
"
Shouldn
'
t
be
blocking
shutdown
with
zero
pending
promises
.
"
)
;
using
namespace
std
:
:
chrono_literals
;
static
constexpr
auto
delay
=
std
:
:
chrono
:
:
duration_cast
<
std
:
:
chrono
:
:
milliseconds
>
(
SW_UNBLOCK_SHUTDOWN_TIMER_DURATION
)
;
mTimer
=
NS_NewTimer
(
)
;
mTimer
-
>
InitWithCallback
(
this
delay
.
count
(
)
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
}
}
