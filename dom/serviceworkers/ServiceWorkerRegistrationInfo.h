#
ifndef
mozilla_dom_serviceworkerregistrationinfo_h
#
define
mozilla_dom_serviceworkerregistrationinfo_h
#
include
<
functional
>
#
include
"
mozilla
/
dom
/
IPCNavigationPreloadState
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerInfo
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrationBinding
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrationDescriptor
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsTObserverArray
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ServiceWorkerRegistrationListener
;
class
ServiceWorkerRegistrationInfo
final
:
public
nsIServiceWorkerRegistrationInfo
{
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
ServiceWorkerRegistrationDescriptor
mDescriptor
;
nsTArray
<
nsCOMPtr
<
nsIServiceWorkerRegistrationInfoListener
>
>
mListeners
;
nsTObserverArray
<
ServiceWorkerRegistrationListener
*
>
mInstanceList
;
struct
VersionEntry
{
const
ServiceWorkerRegistrationDescriptor
mDescriptor
;
TimeStamp
mTimeStamp
;
explicit
VersionEntry
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
:
mDescriptor
(
aDescriptor
)
mTimeStamp
(
TimeStamp
:
:
Now
(
)
)
{
}
}
;
nsTArray
<
UniquePtr
<
VersionEntry
>
>
mVersionList
;
const
nsID
mAgentClusterId
=
nsContentUtils
:
:
GenerateUUID
(
)
;
uint32_t
mControlledClientsCounter
;
uint32_t
mDelayMultiplier
;
enum
{
NoUpdate
NeedTimeCheckAndUpdate
NeedUpdate
}
mUpdateState
;
PRTime
mCreationTime
;
TimeStamp
mCreationTimeStamp
;
PRTime
mLastUpdateTime
;
RefPtr
<
ServiceWorkerInfo
>
mEvaluatingWorker
;
RefPtr
<
ServiceWorkerInfo
>
mActiveWorker
;
RefPtr
<
ServiceWorkerInfo
>
mWaitingWorker
;
RefPtr
<
ServiceWorkerInfo
>
mInstallingWorker
;
virtual
~
ServiceWorkerRegistrationInfo
(
)
;
bool
mUnregistered
;
bool
mCorrupt
;
IPCNavigationPreloadState
mNavigationPreloadState
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISERVICEWORKERREGISTRATIONINFO
using
TryToActivateCallback
=
std
:
:
function
<
void
(
)
>
;
ServiceWorkerRegistrationInfo
(
const
nsACString
&
aScope
nsIPrincipal
*
aPrincipal
ServiceWorkerUpdateViaCache
aUpdateViaCache
IPCNavigationPreloadState
&
&
aNavigationPreloadState
)
;
void
AddInstance
(
ServiceWorkerRegistrationListener
*
aInstance
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
;
void
RemoveInstance
(
ServiceWorkerRegistrationListener
*
aInstance
)
;
const
nsCString
&
Scope
(
)
const
;
nsIPrincipal
*
Principal
(
)
const
;
bool
IsUnregistered
(
)
const
;
void
SetUnregistered
(
)
;
already_AddRefed
<
ServiceWorkerInfo
>
Newest
(
)
const
{
RefPtr
<
ServiceWorkerInfo
>
newest
;
if
(
mInstallingWorker
)
{
newest
=
mInstallingWorker
;
}
else
if
(
mWaitingWorker
)
{
newest
=
mWaitingWorker
;
}
else
{
newest
=
mActiveWorker
;
}
return
newest
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorkerInfo
>
NewestIncludingEvaluating
(
)
const
{
if
(
mEvaluatingWorker
)
{
RefPtr
<
ServiceWorkerInfo
>
newest
=
mEvaluatingWorker
;
return
newest
.
forget
(
)
;
}
return
Newest
(
)
;
}
already_AddRefed
<
ServiceWorkerInfo
>
GetServiceWorkerInfoById
(
uint64_t
aId
)
;
void
StartControllingClient
(
)
{
+
+
mControlledClientsCounter
;
mDelayMultiplier
=
0
;
}
void
StopControllingClient
(
)
{
MOZ_ASSERT
(
mControlledClientsCounter
)
;
-
-
mControlledClientsCounter
;
}
bool
IsControllingClients
(
)
const
{
return
mActiveWorker
&
&
mControlledClientsCounter
;
}
void
ShutdownWorkers
(
)
;
void
Clear
(
)
;
void
ClearAsCorrupt
(
)
;
bool
IsCorrupt
(
)
const
;
void
TryToActivateAsync
(
TryToActivateCallback
&
&
aCallback
=
nullptr
)
;
void
TryToActivate
(
TryToActivateCallback
&
&
aCallback
)
;
void
Activate
(
)
;
void
FinishActivate
(
bool
aSuccess
)
;
void
RefreshLastUpdateCheckTime
(
)
;
bool
IsLastUpdateCheckTimeOverOneDay
(
)
const
;
void
MaybeScheduleTimeCheckAndUpdate
(
)
;
void
MaybeScheduleUpdate
(
)
;
bool
CheckAndClearIfUpdateNeeded
(
)
;
ServiceWorkerInfo
*
GetEvaluating
(
)
const
;
ServiceWorkerInfo
*
GetInstalling
(
)
const
;
ServiceWorkerInfo
*
GetWaiting
(
)
const
;
ServiceWorkerInfo
*
GetActive
(
)
const
;
ServiceWorkerInfo
*
GetByDescriptor
(
const
ServiceWorkerDescriptor
&
aDescriptor
)
const
;
void
SetEvaluating
(
ServiceWorkerInfo
*
aServiceWorker
)
;
void
ClearEvaluating
(
)
;
void
ClearInstalling
(
)
;
void
TransitionEvaluatingToInstalling
(
)
;
void
TransitionInstallingToWaiting
(
)
;
void
SetActive
(
ServiceWorkerInfo
*
aServiceWorker
)
;
void
TransitionWaitingToActive
(
)
;
bool
IsIdle
(
)
const
;
ServiceWorkerUpdateViaCache
GetUpdateViaCache
(
)
const
;
void
SetUpdateViaCache
(
ServiceWorkerUpdateViaCache
aUpdateViaCache
)
;
int64_t
GetLastUpdateTime
(
)
const
;
void
SetLastUpdateTime
(
const
int64_t
aTime
)
;
const
ServiceWorkerRegistrationDescriptor
&
Descriptor
(
)
const
;
uint64_t
Id
(
)
const
;
uint64_t
Version
(
)
const
;
uint32_t
GetUpdateDelay
(
const
bool
aWithMultiplier
=
true
)
;
void
FireUpdateFound
(
)
;
void
NotifyCleared
(
)
;
void
ClearWhenIdle
(
)
;
const
nsID
&
AgentClusterId
(
)
const
;
void
SetNavigationPreloadEnabled
(
const
bool
&
aEnabled
)
;
void
SetNavigationPreloadHeader
(
const
nsCString
&
aHeader
)
;
IPCNavigationPreloadState
GetNavigationPreloadState
(
)
const
;
private
:
void
UpdateRegistrationState
(
)
;
void
UpdateRegistrationState
(
ServiceWorkerUpdateViaCache
aUpdateViaCache
)
;
void
NotifyChromeRegistrationListeners
(
)
;
static
uint64_t
GetNextId
(
)
;
static
uint64_t
GetNextVersion
(
)
;
void
ForEachWorker
(
void
(
*
aFunc
)
(
RefPtr
<
ServiceWorkerInfo
>
&
)
)
;
}
;
}
}
#
endif
