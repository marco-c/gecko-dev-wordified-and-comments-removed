#
include
"
ServiceWorkerContainerProxy
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerContainerParent
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
namespace
mozilla
:
:
dom
{
using
mozilla
:
:
ipc
:
:
AssertIsOnBackgroundThread
;
ServiceWorkerContainerProxy
:
:
~
ServiceWorkerContainerProxy
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mActor
)
;
}
ServiceWorkerContainerProxy
:
:
ServiceWorkerContainerProxy
(
ServiceWorkerContainerParent
*
aActor
)
:
mActor
(
aActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mActor
)
;
}
void
ServiceWorkerContainerProxy
:
:
RevokeActor
(
ServiceWorkerContainerParent
*
aActor
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mActor
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mActor
=
=
aActor
)
;
mActor
=
nullptr
;
}
RefPtr
<
ServiceWorkerRegistrationPromise
>
ServiceWorkerContainerProxy
:
:
Register
(
const
ClientInfo
&
aClientInfo
const
nsACString
&
aScopeURL
const
nsACString
&
aScriptURL
ServiceWorkerUpdateViaCache
aUpdateViaCache
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
ServiceWorkerRegistrationPromise
:
:
Private
>
promise
=
new
ServiceWorkerRegistrationPromise
:
:
Private
(
__func__
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
aClientInfo
aScopeURL
=
nsCString
(
aScopeURL
)
aScriptURL
=
nsCString
(
aScriptURL
)
aUpdateViaCache
promise
]
(
)
mutable
{
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
promise
-
>
Reject
(
NS_ERROR_DOM_INVALID_STATE_ERR
__func__
)
;
}
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE_VOID
(
swm
)
;
swm
-
>
Register
(
aClientInfo
aScopeURL
aScriptURL
aUpdateViaCache
)
-
>
ChainTo
(
promise
.
forget
(
)
__func__
)
;
scopeExit
.
release
(
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
return
promise
;
}
RefPtr
<
ServiceWorkerRegistrationPromise
>
ServiceWorkerContainerProxy
:
:
GetRegistration
(
const
ClientInfo
&
aClientInfo
const
nsACString
&
aURL
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
ServiceWorkerRegistrationPromise
:
:
Private
>
promise
=
new
ServiceWorkerRegistrationPromise
:
:
Private
(
__func__
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
aClientInfo
aURL
=
nsCString
(
aURL
)
promise
]
(
)
mutable
{
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
promise
-
>
Reject
(
NS_ERROR_DOM_INVALID_STATE_ERR
__func__
)
;
}
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE_VOID
(
swm
)
;
swm
-
>
GetRegistration
(
aClientInfo
aURL
)
-
>
ChainTo
(
promise
.
forget
(
)
__func__
)
;
scopeExit
.
release
(
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
return
promise
;
}
RefPtr
<
ServiceWorkerRegistrationListPromise
>
ServiceWorkerContainerProxy
:
:
GetRegistrations
(
const
ClientInfo
&
aClientInfo
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
ServiceWorkerRegistrationListPromise
:
:
Private
>
promise
=
new
ServiceWorkerRegistrationListPromise
:
:
Private
(
__func__
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
aClientInfo
promise
]
(
)
mutable
{
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
promise
-
>
Reject
(
NS_ERROR_DOM_INVALID_STATE_ERR
__func__
)
;
}
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE_VOID
(
swm
)
;
swm
-
>
GetRegistrations
(
aClientInfo
)
-
>
ChainTo
(
promise
.
forget
(
)
__func__
)
;
scopeExit
.
release
(
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
return
promise
;
}
RefPtr
<
ServiceWorkerRegistrationPromise
>
ServiceWorkerContainerProxy
:
:
GetReady
(
const
ClientInfo
&
aClientInfo
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
ServiceWorkerRegistrationPromise
:
:
Private
>
promise
=
new
ServiceWorkerRegistrationPromise
:
:
Private
(
__func__
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
__func__
[
aClientInfo
promise
]
(
)
mutable
{
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
promise
-
>
Reject
(
NS_ERROR_DOM_INVALID_STATE_ERR
__func__
)
;
}
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE_VOID
(
swm
)
;
swm
-
>
WhenReady
(
aClientInfo
)
-
>
ChainTo
(
promise
.
forget
(
)
__func__
)
;
scopeExit
.
release
(
)
;
}
)
;
MOZ_ALWAYS_SUCCEEDS
(
SchedulerGroup
:
:
Dispatch
(
r
.
forget
(
)
)
)
;
return
promise
;
}
}
