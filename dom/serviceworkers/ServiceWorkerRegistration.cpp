#
include
"
ServiceWorkerRegistration
.
h
"
#
include
"
ServiceWorkerRegistrationChild
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
dom
/
CookieStoreManager
.
h
"
#
include
"
mozilla
/
dom
/
DOMMozPromiseRequestHolder
.
h
"
#
include
"
mozilla
/
dom
/
NavigationPreloadManager
.
h
"
#
include
"
mozilla
/
dom
/
NavigationPreloadManagerBinding
.
h
"
#
include
"
mozilla
/
dom
/
Notification
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PushManager
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorker
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
using
mozilla
:
:
ipc
:
:
ResponseRejectReason
;
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
ServiceWorkerRegistration
DOMEventTargetHelper
mInstallingWorker
mWaitingWorker
mActiveWorker
mNavigationPreloadManager
mPushManager
mCookieStoreManager
)
;
NS_IMPL_ADDREF_INHERITED
(
ServiceWorkerRegistration
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
ServiceWorkerRegistration
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ServiceWorkerRegistration
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
ServiceWorkerRegistration
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
namespace
{
const
uint64_t
kInvalidUpdateFoundId
=
0
;
}
ServiceWorkerRegistration
:
:
ServiceWorkerRegistration
(
nsIGlobalObject
*
aGlobal
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
:
DOMEventTargetHelper
(
aGlobal
)
mDescriptor
(
aDescriptor
)
mShutdown
(
false
)
mScheduledUpdateFoundId
(
kInvalidUpdateFoundId
)
mDispatchedUpdateFoundId
(
kInvalidUpdateFoundId
)
{
:
:
mozilla
:
:
ipc
:
:
PBackgroundChild
*
parentActor
=
:
:
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
parentActor
)
)
{
Shutdown
(
)
;
return
;
}
auto
actor
=
ServiceWorkerRegistrationChild
:
:
Create
(
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
Shutdown
(
)
;
return
;
}
Maybe
<
ClientInfo
>
clientInfo
=
aGlobal
-
>
GetClientInfo
(
)
;
if
(
clientInfo
.
isNothing
(
)
)
{
Shutdown
(
)
;
return
;
}
PServiceWorkerRegistrationChild
*
sentActor
=
parentActor
-
>
SendPServiceWorkerRegistrationConstructor
(
actor
aDescriptor
.
ToIPC
(
)
clientInfo
.
ref
(
)
.
ToIPC
(
)
)
;
if
(
NS_WARN_IF
(
!
sentActor
)
)
{
Shutdown
(
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
sentActor
=
=
actor
)
;
mActor
=
std
:
:
move
(
actor
)
;
mActor
-
>
SetOwner
(
this
)
;
KeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onupdatefound
)
;
}
ServiceWorkerRegistration
:
:
~
ServiceWorkerRegistration
(
)
{
Shutdown
(
)
;
}
JSObject
*
ServiceWorkerRegistration
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ServiceWorkerRegistration_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
ServiceWorkerRegistration
>
ServiceWorkerRegistration
:
:
CreateForMainThread
(
nsPIDOMWindowInner
*
aWindow
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ServiceWorkerRegistration
>
registration
=
new
ServiceWorkerRegistration
(
aWindow
-
>
AsGlobal
(
)
aDescriptor
)
;
registration
-
>
UpdateState
(
aDescriptor
)
;
return
registration
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorkerRegistration
>
ServiceWorkerRegistration
:
:
CreateForWorker
(
WorkerPrivate
*
aWorkerPrivate
nsIGlobalObject
*
aGlobal
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aWorkerPrivate
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aGlobal
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
ServiceWorkerRegistration
>
registration
=
new
ServiceWorkerRegistration
(
aGlobal
aDescriptor
)
;
registration
-
>
UpdateState
(
aDescriptor
)
;
return
registration
.
forget
(
)
;
}
void
ServiceWorkerRegistration
:
:
DisconnectFromOwner
(
)
{
DOMEventTargetHelper
:
:
DisconnectFromOwner
(
)
;
Shutdown
(
)
;
}
void
ServiceWorkerRegistration
:
:
RegistrationCleared
(
)
{
UpdateStateInternal
(
Maybe
<
ServiceWorkerDescriptor
>
(
)
Maybe
<
ServiceWorkerDescriptor
>
(
)
Maybe
<
ServiceWorkerDescriptor
>
(
)
)
;
IgnoreKeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onupdatefound
)
;
}
already_AddRefed
<
ServiceWorker
>
ServiceWorkerRegistration
:
:
GetInstalling
(
)
const
{
RefPtr
<
ServiceWorker
>
ref
=
mInstallingWorker
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorker
>
ServiceWorkerRegistration
:
:
GetWaiting
(
)
const
{
RefPtr
<
ServiceWorker
>
ref
=
mWaitingWorker
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorker
>
ServiceWorkerRegistration
:
:
GetActive
(
)
const
{
RefPtr
<
ServiceWorker
>
ref
=
mActiveWorker
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
NavigationPreloadManager
>
ServiceWorkerRegistration
:
:
NavigationPreload
(
)
{
RefPtr
<
ServiceWorkerRegistration
>
reg
=
this
;
if
(
!
mNavigationPreloadManager
)
{
mNavigationPreloadManager
=
MakeRefPtr
<
NavigationPreloadManager
>
(
reg
)
;
}
RefPtr
<
NavigationPreloadManager
>
ref
=
mNavigationPreloadManager
;
return
ref
.
forget
(
)
;
}
CookieStoreManager
*
ServiceWorkerRegistration
:
:
GetCookies
(
ErrorResult
&
aRv
)
{
if
(
!
mCookieStoreManager
)
{
nsIGlobalObject
*
globalObject
=
GetParentObject
(
)
;
if
(
!
globalObject
)
{
aRv
.
ThrowInvalidStateError
(
"
No
global
"
)
;
return
nullptr
;
}
mCookieStoreManager
=
new
CookieStoreManager
(
globalObject
mDescriptor
.
Scope
(
)
)
;
}
return
mCookieStoreManager
;
}
void
ServiceWorkerRegistration
:
:
UpdateState
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
MatchesDescriptor
(
aDescriptor
)
)
;
mDescriptor
=
aDescriptor
;
UpdateStateInternal
(
aDescriptor
.
GetInstalling
(
)
aDescriptor
.
GetWaiting
(
)
aDescriptor
.
GetActive
(
)
)
;
nsTArray
<
UniquePtr
<
VersionCallback
>
>
callbackList
=
std
:
:
move
(
mVersionCallbackList
)
;
for
(
auto
&
cb
:
callbackList
)
{
if
(
cb
-
>
mVersion
>
mDescriptor
.
Version
(
)
)
{
mVersionCallbackList
.
AppendElement
(
std
:
:
move
(
cb
)
)
;
continue
;
}
cb
-
>
mFunc
(
cb
-
>
mVersion
=
=
mDescriptor
.
Version
(
)
)
;
}
}
bool
ServiceWorkerRegistration
:
:
MatchesDescriptor
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
const
{
return
aDescriptor
.
Id
(
)
=
=
mDescriptor
.
Id
(
)
&
&
aDescriptor
.
PrincipalInfo
(
)
=
=
mDescriptor
.
PrincipalInfo
(
)
&
&
aDescriptor
.
Scope
(
)
=
=
mDescriptor
.
Scope
(
)
;
}
void
ServiceWorkerRegistration
:
:
GetScope
(
nsAString
&
aScope
)
const
{
CopyUTF8toUTF16
(
mDescriptor
.
Scope
(
)
aScope
)
;
}
ServiceWorkerUpdateViaCache
ServiceWorkerRegistration
:
:
GetUpdateViaCache
(
ErrorResult
&
aRv
)
const
{
return
mDescriptor
.
UpdateViaCache
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
Update
(
ErrorResult
&
aRv
)
{
AUTO_PROFILER_MARKER_UNTYPED
(
"
ServiceWorkerRegistration
:
:
Update
"
DOM
{
}
)
;
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
outer
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
const
Maybe
<
ServiceWorkerDescriptor
>
newestWorkerDescriptor
=
mDescriptor
.
Newest
(
)
;
if
(
newestWorkerDescriptor
.
isNothing
(
)
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
outer
.
forget
(
)
;
}
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
if
(
workerPrivate
-
>
IsServiceWorker
(
)
&
&
(
workerPrivate
-
>
GetServiceWorkerDescriptor
(
)
.
State
(
)
=
=
ServiceWorkerState
:
:
Installing
)
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
outer
.
forget
(
)
;
}
}
RefPtr
<
ServiceWorkerRegistration
>
self
=
this
;
if
(
!
mActor
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
outer
.
forget
(
)
;
}
mActor
-
>
SendUpdate
(
newestWorkerDescriptor
.
ref
(
)
.
ScriptURL
(
)
[
outer
self
=
std
:
:
move
(
self
)
]
(
const
IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult
&
aResult
)
{
AUTO_PROFILER_MARKER_UNTYPED
(
"
ServiceWorkerRegistration
:
:
Update
(
inner
)
"
DOM
{
}
)
;
if
(
aResult
.
type
(
)
=
=
IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult
:
:
TCopyableErrorResult
)
{
const
auto
&
rv
=
aResult
.
get_CopyableErrorResult
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
rv
.
Failed
(
)
)
;
outer
-
>
MaybeReject
(
CopyableErrorResult
(
rv
)
)
;
return
;
}
const
auto
&
ipcDesc
=
aResult
.
get_IPCServiceWorkerRegistrationDescriptor
(
)
;
nsIGlobalObject
*
global
=
self
-
>
GetParentObject
(
)
;
MOZ_ASSERT_DEBUG_OR_FUZZING
(
global
)
;
if
(
!
global
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
RefPtr
<
ServiceWorkerRegistration
>
ref
=
global
-
>
GetOrCreateServiceWorkerRegistration
(
ServiceWorkerRegistrationDescriptor
(
ipcDesc
)
)
;
if
(
!
ref
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
outer
-
>
MaybeResolve
(
ref
)
;
}
[
outer
]
(
ResponseRejectReason
&
&
aReason
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
}
)
;
return
outer
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
Unregister
(
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
outer
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
!
mActor
)
{
outer
-
>
MaybeResolve
(
false
)
;
return
outer
.
forget
(
)
;
}
RefPtr
<
ServiceWorkerRegistration
>
self
=
this
;
mActor
-
>
SendUnregister
(
[
self
=
std
:
:
move
(
self
)
outer
]
(
std
:
:
tuple
<
bool
CopyableErrorResult
>
&
&
aResult
)
{
if
(
std
:
:
get
<
1
>
(
aResult
)
.
Failed
(
)
)
{
std
:
:
get
<
1
>
(
aResult
)
.
SuppressException
(
)
;
outer
-
>
MaybeResolve
(
false
)
;
return
;
}
outer
-
>
MaybeResolve
(
std
:
:
get
<
0
>
(
aResult
)
)
;
}
[
outer
]
(
ResponseRejectReason
&
&
aReason
)
{
outer
-
>
MaybeResolve
(
false
)
;
}
)
;
return
outer
.
forget
(
)
;
}
already_AddRefed
<
PushManager
>
ServiceWorkerRegistration
:
:
GetPushManager
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
!
mPushManager
)
{
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
GetParentObject
(
)
;
if
(
!
globalObject
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
GlobalObject
global
(
aCx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
mPushManager
=
PushManager
:
:
Constructor
(
global
NS_ConvertUTF8toUTF16
(
mDescriptor
.
Scope
(
)
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
RefPtr
<
PushManager
>
ret
=
mPushManager
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
ShowNotification
(
JSContext
*
aCx
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mDescriptor
.
GetActive
(
)
.
isNothing
(
)
&
&
NS_IsMainThread
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_NO_ACTIVE_WORKER
>
(
mDescriptor
.
Scope
(
)
)
;
return
nullptr
;
}
NS_ConvertUTF8toUTF16
scope
(
mDescriptor
.
Scope
(
)
)
;
RefPtr
<
Promise
>
p
=
Notification
:
:
ShowPersistentNotification
(
aCx
global
scope
aTitle
aOptions
mDescriptor
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
GetNotifications
(
const
GetNotificationOptions
&
aOptions
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetParentObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
CreateInfallible
(
global
)
;
if
(
!
mActor
)
{
promise
-
>
MaybeResolve
(
nsTArray
<
RefPtr
<
Notification
>
>
(
)
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
ServiceWorkerRegistration
>
self
=
this
;
mActor
-
>
SendGetNotifications
(
aOptions
.
mTag
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
=
std
:
:
move
(
self
)
promise
scope
=
NS_ConvertUTF8toUTF16
(
mDescriptor
.
Scope
(
)
)
]
(
const
PServiceWorkerRegistrationChild
:
:
GetNotificationsPromise
:
:
ResolveOrRejectValue
&
&
aValue
)
{
if
(
aValue
.
IsReject
(
)
)
{
promise
-
>
MaybeResolve
(
nsTArray
<
RefPtr
<
Notification
>
>
(
)
)
;
return
;
}
if
(
aValue
.
ResolveValue
(
)
.
type
(
)
=
=
IPCNotificationsOrError
:
:
Tnsresult
)
{
promise
-
>
MaybeRejectWithInvalidStateError
(
"
Could
not
retrieve
notifications
"
_ns
)
;
return
;
}
const
nsTArray
<
IPCNotification
>
&
notifications
=
aValue
.
ResolveValue
(
)
.
get_ArrayOfIPCNotification
(
)
;
nsTArray
<
RefPtr
<
Notification
>
>
objects
(
notifications
.
Length
(
)
)
;
for
(
const
IPCNotification
&
ipcNotification
:
notifications
)
{
auto
result
=
Notification
:
:
ConstructFromIPC
(
promise
-
>
GetParentObject
(
)
ipcNotification
scope
)
;
if
(
result
.
isErr
(
)
)
{
continue
;
}
RefPtr
<
Notification
>
n
=
result
.
unwrap
(
)
;
objects
.
AppendElement
(
n
.
forget
(
)
)
;
}
promise
-
>
MaybeResolve
(
std
:
:
move
(
objects
)
)
;
}
)
;
return
promise
.
forget
(
)
;
}
void
ServiceWorkerRegistration
:
:
SetNavigationPreloadEnabled
(
bool
aEnabled
ServiceWorkerBoolCallback
&
&
aSuccessCB
ServiceWorkerFailureCallback
&
&
aFailureCB
)
{
if
(
!
mActor
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
RefPtr
<
ServiceWorkerRegistration
>
self
=
this
;
mActor
-
>
SendSetNavigationPreloadEnabled
(
aEnabled
[
self
=
std
:
:
move
(
self
)
successCB
=
std
:
:
move
(
aSuccessCB
)
aFailureCB
]
(
bool
aResult
)
{
if
(
!
aResult
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
successCB
(
aResult
)
;
}
[
aFailureCB
]
(
ResponseRejectReason
&
&
aReason
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
}
)
;
}
void
ServiceWorkerRegistration
:
:
SetNavigationPreloadHeader
(
const
nsCString
&
aHeader
ServiceWorkerBoolCallback
&
&
aSuccessCB
ServiceWorkerFailureCallback
&
&
aFailureCB
)
{
if
(
!
mActor
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
RefPtr
<
ServiceWorkerRegistration
>
self
=
this
;
mActor
-
>
SendSetNavigationPreloadHeader
(
aHeader
[
self
=
std
:
:
move
(
self
)
successCB
=
std
:
:
move
(
aSuccessCB
)
aFailureCB
]
(
bool
aResult
)
{
if
(
!
aResult
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
successCB
(
aResult
)
;
}
[
aFailureCB
]
(
ResponseRejectReason
&
&
aReason
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
}
)
;
}
void
ServiceWorkerRegistration
:
:
GetNavigationPreloadState
(
NavigationPreloadGetStateCallback
&
&
aSuccessCB
ServiceWorkerFailureCallback
&
&
aFailureCB
)
{
if
(
!
mActor
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
RefPtr
<
ServiceWorkerRegistration
>
self
=
this
;
mActor
-
>
SendGetNavigationPreloadState
(
[
self
=
std
:
:
move
(
self
)
successCB
=
std
:
:
move
(
aSuccessCB
)
aFailureCB
]
(
Maybe
<
IPCNavigationPreloadState
>
&
&
aState
)
{
if
(
NS_WARN_IF
(
!
aState
)
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
NavigationPreloadState
state
;
state
.
mEnabled
=
aState
.
ref
(
)
.
enabled
(
)
;
state
.
mHeaderValue
.
Construct
(
std
:
:
move
(
aState
.
ref
(
)
.
headerValue
(
)
)
)
;
successCB
(
std
:
:
move
(
state
)
)
;
}
[
aFailureCB
]
(
ResponseRejectReason
&
&
aReason
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
}
)
;
}
const
ServiceWorkerRegistrationDescriptor
&
ServiceWorkerRegistration
:
:
Descriptor
(
)
const
{
return
mDescriptor
;
}
void
ServiceWorkerRegistration
:
:
WhenVersionReached
(
uint64_t
aVersion
ServiceWorkerBoolCallback
&
&
aCallback
)
{
if
(
aVersion
<
=
mDescriptor
.
Version
(
)
)
{
aCallback
(
aVersion
=
=
mDescriptor
.
Version
(
)
)
;
return
;
}
mVersionCallbackList
.
AppendElement
(
MakeUnique
<
VersionCallback
>
(
aVersion
std
:
:
move
(
aCallback
)
)
)
;
}
void
ServiceWorkerRegistration
:
:
MaybeScheduleUpdateFound
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aInstallingDescriptor
)
{
uint64_t
newId
=
aInstallingDescriptor
.
isSome
(
)
?
aInstallingDescriptor
.
ref
(
)
.
Id
(
)
:
kInvalidUpdateFoundId
;
if
(
mScheduledUpdateFoundId
!
=
kInvalidUpdateFoundId
)
{
if
(
mScheduledUpdateFoundId
=
=
newId
)
{
return
;
}
MaybeDispatchUpdateFound
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mScheduledUpdateFoundId
=
=
kInvalidUpdateFoundId
)
;
}
bool
updateFound
=
newId
!
=
kInvalidUpdateFoundId
&
&
mDispatchedUpdateFoundId
!
=
newId
;
if
(
!
updateFound
)
{
return
;
}
mScheduledUpdateFoundId
=
newId
;
}
void
ServiceWorkerRegistration
:
:
MaybeDispatchUpdateFound
(
)
{
uint64_t
scheduledId
=
mScheduledUpdateFoundId
;
mScheduledUpdateFoundId
=
kInvalidUpdateFoundId
;
if
(
scheduledId
=
=
kInvalidUpdateFoundId
|
|
scheduledId
=
=
mDispatchedUpdateFoundId
)
{
return
;
}
mDispatchedUpdateFoundId
=
scheduledId
;
DispatchTrustedEvent
(
u
"
updatefound
"
_ns
)
;
}
void
ServiceWorkerRegistration
:
:
UpdateStateInternal
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aInstalling
const
Maybe
<
ServiceWorkerDescriptor
>
&
aWaiting
const
Maybe
<
ServiceWorkerDescriptor
>
&
aActive
)
{
MaybeScheduleUpdateFound
(
aInstalling
)
;
AutoTArray
<
RefPtr
<
ServiceWorker
>
3
>
oldWorkerList
(
{
std
:
:
move
(
mInstallingWorker
)
std
:
:
move
(
mWaitingWorker
)
std
:
:
move
(
mActiveWorker
)
}
)
;
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
for
(
auto
&
oldWorker
:
oldWorkerList
)
{
if
(
!
oldWorker
|
|
oldWorker
=
=
mInstallingWorker
|
|
oldWorker
=
=
mWaitingWorker
|
|
oldWorker
=
=
mActiveWorker
)
{
continue
;
}
oldWorker
-
>
SetState
(
ServiceWorkerState
:
:
Redundant
)
;
}
if
(
mInstallingWorker
)
{
mInstallingWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
if
(
mWaitingWorker
)
{
mWaitingWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
if
(
mActiveWorker
)
{
mActiveWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
for
(
auto
&
oldWorker
:
oldWorkerList
)
{
if
(
!
oldWorker
)
{
continue
;
}
oldWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
}
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetParentObject
(
)
;
if
(
!
global
)
{
return
;
}
if
(
aActive
.
isSome
(
)
)
{
if
(
(
mActiveWorker
=
global
-
>
GetOrCreateServiceWorker
(
aActive
.
ref
(
)
)
)
)
{
mActiveWorker
-
>
SetState
(
aActive
.
ref
(
)
.
State
(
)
)
;
}
}
else
{
mActiveWorker
=
nullptr
;
}
if
(
aWaiting
.
isSome
(
)
)
{
if
(
(
mWaitingWorker
=
global
-
>
GetOrCreateServiceWorker
(
aWaiting
.
ref
(
)
)
)
)
{
mWaitingWorker
-
>
SetState
(
aWaiting
.
ref
(
)
.
State
(
)
)
;
}
}
else
{
mWaitingWorker
=
nullptr
;
}
if
(
aInstalling
.
isSome
(
)
)
{
if
(
(
mInstallingWorker
=
global
-
>
GetOrCreateServiceWorker
(
aInstalling
.
ref
(
)
)
)
)
{
mInstallingWorker
-
>
SetState
(
aInstalling
.
ref
(
)
.
State
(
)
)
;
}
}
else
{
mInstallingWorker
=
nullptr
;
}
}
void
ServiceWorkerRegistration
:
:
RevokeActor
(
ServiceWorkerRegistrationChild
*
aActor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mActor
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mActor
=
=
aActor
)
;
mActor
-
>
RevokeOwner
(
this
)
;
mActor
=
nullptr
;
mShutdown
=
true
;
RegistrationCleared
(
)
;
}
void
ServiceWorkerRegistration
:
:
Shutdown
(
)
{
if
(
mShutdown
)
{
return
;
}
mShutdown
=
true
;
if
(
mActor
)
{
mActor
-
>
RevokeOwner
(
this
)
;
mActor
-
>
Shutdown
(
)
;
mActor
=
nullptr
;
}
}
}
