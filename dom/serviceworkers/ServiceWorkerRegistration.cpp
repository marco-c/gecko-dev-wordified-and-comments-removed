#
include
"
ServiceWorkerRegistration
.
h
"
#
include
"
mozilla
/
dom
/
DOMMozPromiseRequestHolder
.
h
"
#
include
"
mozilla
/
dom
/
NavigationPreloadManager
.
h
"
#
include
"
mozilla
/
dom
/
NavigationPreloadManagerBinding
.
h
"
#
include
"
mozilla
/
dom
/
Notification
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PushManager
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorker
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrationBinding
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
ServiceWorkerRegistrationChild
.
h
"
using
mozilla
:
:
ipc
:
:
ResponseRejectReason
;
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
ServiceWorkerRegistration
DOMEventTargetHelper
mInstallingWorker
mWaitingWorker
mActiveWorker
mNavigationPreloadManager
mPushManager
)
;
NS_IMPL_ADDREF_INHERITED
(
ServiceWorkerRegistration
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
ServiceWorkerRegistration
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ServiceWorkerRegistration
)
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
ServiceWorkerRegistration
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
namespace
{
const
uint64_t
kInvalidUpdateFoundId
=
0
;
}
ServiceWorkerRegistration
:
:
ServiceWorkerRegistration
(
nsIGlobalObject
*
aGlobal
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
:
DOMEventTargetHelper
(
aGlobal
)
mDescriptor
(
aDescriptor
)
mShutdown
(
false
)
mScheduledUpdateFoundId
(
kInvalidUpdateFoundId
)
mDispatchedUpdateFoundId
(
kInvalidUpdateFoundId
)
{
:
:
mozilla
:
:
ipc
:
:
PBackgroundChild
*
parentActor
=
:
:
mozilla
:
:
ipc
:
:
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
parentActor
)
)
{
Shutdown
(
)
;
return
;
}
auto
actor
=
ServiceWorkerRegistrationChild
:
:
Create
(
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
Shutdown
(
)
;
return
;
}
PServiceWorkerRegistrationChild
*
sentActor
=
parentActor
-
>
SendPServiceWorkerRegistrationConstructor
(
actor
aDescriptor
.
ToIPC
(
)
)
;
if
(
NS_WARN_IF
(
!
sentActor
)
)
{
Shutdown
(
)
;
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
sentActor
=
=
actor
)
;
mActor
=
std
:
:
move
(
actor
)
;
mActor
-
>
SetOwner
(
this
)
;
KeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onupdatefound
)
;
}
ServiceWorkerRegistration
:
:
~
ServiceWorkerRegistration
(
)
{
Shutdown
(
)
;
}
JSObject
*
ServiceWorkerRegistration
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ServiceWorkerRegistration_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
ServiceWorkerRegistration
>
ServiceWorkerRegistration
:
:
CreateForMainThread
(
nsPIDOMWindowInner
*
aWindow
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
MOZ_ASSERT
(
aWindow
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ServiceWorkerRegistration
>
registration
=
new
ServiceWorkerRegistration
(
aWindow
-
>
AsGlobal
(
)
aDescriptor
)
;
registration
-
>
UpdateState
(
aDescriptor
)
;
return
registration
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorkerRegistration
>
ServiceWorkerRegistration
:
:
CreateForWorker
(
WorkerPrivate
*
aWorkerPrivate
nsIGlobalObject
*
aGlobal
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aWorkerPrivate
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aGlobal
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
RefPtr
<
ServiceWorkerRegistration
>
registration
=
new
ServiceWorkerRegistration
(
aGlobal
aDescriptor
)
;
registration
-
>
UpdateState
(
aDescriptor
)
;
return
registration
.
forget
(
)
;
}
void
ServiceWorkerRegistration
:
:
DisconnectFromOwner
(
)
{
DOMEventTargetHelper
:
:
DisconnectFromOwner
(
)
;
}
void
ServiceWorkerRegistration
:
:
RegistrationCleared
(
)
{
UpdateStateInternal
(
Maybe
<
ServiceWorkerDescriptor
>
(
)
Maybe
<
ServiceWorkerDescriptor
>
(
)
Maybe
<
ServiceWorkerDescriptor
>
(
)
)
;
IgnoreKeepAliveIfHasListenersFor
(
nsGkAtoms
:
:
onupdatefound
)
;
}
already_AddRefed
<
ServiceWorker
>
ServiceWorkerRegistration
:
:
GetInstalling
(
)
const
{
RefPtr
<
ServiceWorker
>
ref
=
mInstallingWorker
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorker
>
ServiceWorkerRegistration
:
:
GetWaiting
(
)
const
{
RefPtr
<
ServiceWorker
>
ref
=
mWaitingWorker
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorker
>
ServiceWorkerRegistration
:
:
GetActive
(
)
const
{
RefPtr
<
ServiceWorker
>
ref
=
mActiveWorker
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
NavigationPreloadManager
>
ServiceWorkerRegistration
:
:
NavigationPreload
(
)
{
RefPtr
<
ServiceWorkerRegistration
>
reg
=
this
;
if
(
!
mNavigationPreloadManager
)
{
mNavigationPreloadManager
=
MakeRefPtr
<
NavigationPreloadManager
>
(
reg
)
;
}
RefPtr
<
NavigationPreloadManager
>
ref
=
mNavigationPreloadManager
;
return
ref
.
forget
(
)
;
}
void
ServiceWorkerRegistration
:
:
UpdateState
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
MatchesDescriptor
(
aDescriptor
)
)
;
mDescriptor
=
aDescriptor
;
UpdateStateInternal
(
aDescriptor
.
GetInstalling
(
)
aDescriptor
.
GetWaiting
(
)
aDescriptor
.
GetActive
(
)
)
;
nsTArray
<
UniquePtr
<
VersionCallback
>
>
callbackList
=
std
:
:
move
(
mVersionCallbackList
)
;
for
(
auto
&
cb
:
callbackList
)
{
if
(
cb
-
>
mVersion
>
mDescriptor
.
Version
(
)
)
{
mVersionCallbackList
.
AppendElement
(
std
:
:
move
(
cb
)
)
;
continue
;
}
cb
-
>
mFunc
(
cb
-
>
mVersion
=
=
mDescriptor
.
Version
(
)
)
;
}
}
bool
ServiceWorkerRegistration
:
:
MatchesDescriptor
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
const
{
return
aDescriptor
.
Id
(
)
=
=
mDescriptor
.
Id
(
)
&
&
aDescriptor
.
PrincipalInfo
(
)
=
=
mDescriptor
.
PrincipalInfo
(
)
&
&
aDescriptor
.
Scope
(
)
=
=
mDescriptor
.
Scope
(
)
;
}
void
ServiceWorkerRegistration
:
:
GetScope
(
nsAString
&
aScope
)
const
{
CopyUTF8toUTF16
(
mDescriptor
.
Scope
(
)
aScope
)
;
}
ServiceWorkerUpdateViaCache
ServiceWorkerRegistration
:
:
GetUpdateViaCache
(
ErrorResult
&
aRv
)
const
{
return
mDescriptor
.
UpdateViaCache
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
Update
(
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
outer
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
const
Maybe
<
ServiceWorkerDescriptor
>
newestWorkerDescriptor
=
mDescriptor
.
Newest
(
)
;
if
(
newestWorkerDescriptor
.
isNothing
(
)
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
outer
.
forget
(
)
;
}
if
(
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
if
(
workerPrivate
-
>
IsServiceWorker
(
)
&
&
(
workerPrivate
-
>
GetServiceWorkerDescriptor
(
)
.
State
(
)
=
=
ServiceWorkerState
:
:
Installing
)
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
outer
.
forget
(
)
;
}
}
RefPtr
<
ServiceWorkerRegistration
>
self
=
this
;
if
(
!
mActor
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
outer
.
forget
(
)
;
}
mActor
-
>
SendUpdate
(
newestWorkerDescriptor
.
ref
(
)
.
ScriptURL
(
)
[
outer
self
]
(
const
IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult
&
aResult
)
{
if
(
aResult
.
type
(
)
=
=
IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult
:
:
TCopyableErrorResult
)
{
const
auto
&
rv
=
aResult
.
get_CopyableErrorResult
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
rv
.
Failed
(
)
)
;
outer
-
>
MaybeReject
(
CopyableErrorResult
(
rv
)
)
;
return
;
}
const
auto
&
ipcDesc
=
aResult
.
get_IPCServiceWorkerRegistrationDescriptor
(
)
;
nsIGlobalObject
*
global
=
self
-
>
GetParentObject
(
)
;
if
(
!
global
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
RefPtr
<
ServiceWorkerRegistration
>
ref
=
global
-
>
GetOrCreateServiceWorkerRegistration
(
ServiceWorkerRegistrationDescriptor
(
ipcDesc
)
)
;
if
(
!
ref
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
outer
-
>
MaybeResolve
(
ref
)
;
}
[
outer
]
(
ResponseRejectReason
&
&
aReason
)
{
outer
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
}
)
;
return
outer
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
Unregister
(
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
outer
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
!
mActor
)
{
outer
-
>
MaybeResolve
(
false
)
;
return
outer
.
forget
(
)
;
}
mActor
-
>
SendUnregister
(
[
outer
]
(
std
:
:
tuple
<
bool
CopyableErrorResult
>
&
&
aResult
)
{
if
(
std
:
:
get
<
1
>
(
aResult
)
.
Failed
(
)
)
{
std
:
:
get
<
1
>
(
aResult
)
.
SuppressException
(
)
;
outer
-
>
MaybeResolve
(
false
)
;
return
;
}
outer
-
>
MaybeResolve
(
std
:
:
get
<
0
>
(
aResult
)
)
;
}
[
outer
]
(
ResponseRejectReason
&
&
aReason
)
{
outer
-
>
MaybeResolve
(
false
)
;
}
)
;
return
outer
.
forget
(
)
;
}
already_AddRefed
<
PushManager
>
ServiceWorkerRegistration
:
:
GetPushManager
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
!
mPushManager
)
{
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
GetParentObject
(
)
;
if
(
!
globalObject
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
GlobalObject
global
(
aCx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
mPushManager
=
PushManager
:
:
Constructor
(
global
NS_ConvertUTF8toUTF16
(
mDescriptor
.
Scope
(
)
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
RefPtr
<
PushManager
>
ret
=
mPushManager
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
ShowNotification
(
JSContext
*
aCx
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mDescriptor
.
GetActive
(
)
.
isNothing
(
)
&
&
NS_IsMainThread
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_NO_ACTIVE_WORKER
>
(
mDescriptor
.
Scope
(
)
)
;
return
nullptr
;
}
NS_ConvertUTF8toUTF16
scope
(
mDescriptor
.
Scope
(
)
)
;
RefPtr
<
Promise
>
p
=
Notification
:
:
ShowPersistentNotification
(
aCx
global
scope
aTitle
aOptions
mDescriptor
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
ServiceWorkerRegistration
:
:
GetNotifications
(
const
GetNotificationOptions
&
aOptions
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
NS_ConvertUTF8toUTF16
scope
(
mDescriptor
.
Scope
(
)
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
global
)
;
if
(
NS_WARN_IF
(
!
window
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
return
Notification
:
:
Get
(
window
aOptions
scope
aRv
)
;
}
WorkerPrivate
*
worker
=
GetCurrentThreadWorkerPrivate
(
)
;
worker
-
>
AssertIsOnWorkerThread
(
)
;
return
Notification
:
:
WorkerGet
(
worker
aOptions
scope
aRv
)
;
}
void
ServiceWorkerRegistration
:
:
SetNavigationPreloadEnabled
(
bool
aEnabled
ServiceWorkerBoolCallback
&
&
aSuccessCB
ServiceWorkerFailureCallback
&
&
aFailureCB
)
{
if
(
!
mActor
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
mActor
-
>
SendSetNavigationPreloadEnabled
(
aEnabled
[
successCB
=
std
:
:
move
(
aSuccessCB
)
aFailureCB
]
(
bool
aResult
)
{
if
(
!
aResult
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
successCB
(
aResult
)
;
}
[
aFailureCB
]
(
ResponseRejectReason
&
&
aReason
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
}
)
;
}
void
ServiceWorkerRegistration
:
:
SetNavigationPreloadHeader
(
const
nsCString
&
aHeader
ServiceWorkerBoolCallback
&
&
aSuccessCB
ServiceWorkerFailureCallback
&
&
aFailureCB
)
{
if
(
!
mActor
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
mActor
-
>
SendSetNavigationPreloadHeader
(
aHeader
[
successCB
=
std
:
:
move
(
aSuccessCB
)
aFailureCB
]
(
bool
aResult
)
{
if
(
!
aResult
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
successCB
(
aResult
)
;
}
[
aFailureCB
]
(
ResponseRejectReason
&
&
aReason
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
}
)
;
}
void
ServiceWorkerRegistration
:
:
GetNavigationPreloadState
(
NavigationPreloadGetStateCallback
&
&
aSuccessCB
ServiceWorkerFailureCallback
&
&
aFailureCB
)
{
if
(
!
mActor
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
mActor
-
>
SendGetNavigationPreloadState
(
[
successCB
=
std
:
:
move
(
aSuccessCB
)
aFailureCB
]
(
Maybe
<
IPCNavigationPreloadState
>
&
&
aState
)
{
if
(
NS_WARN_IF
(
!
aState
)
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
return
;
}
NavigationPreloadState
state
;
state
.
mEnabled
=
aState
.
ref
(
)
.
enabled
(
)
;
state
.
mHeaderValue
.
Construct
(
std
:
:
move
(
aState
.
ref
(
)
.
headerValue
(
)
)
)
;
successCB
(
std
:
:
move
(
state
)
)
;
}
[
aFailureCB
]
(
ResponseRejectReason
&
&
aReason
)
{
aFailureCB
(
CopyableErrorResult
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
;
}
)
;
}
const
ServiceWorkerRegistrationDescriptor
&
ServiceWorkerRegistration
:
:
Descriptor
(
)
const
{
return
mDescriptor
;
}
void
ServiceWorkerRegistration
:
:
WhenVersionReached
(
uint64_t
aVersion
ServiceWorkerBoolCallback
&
&
aCallback
)
{
if
(
aVersion
<
=
mDescriptor
.
Version
(
)
)
{
aCallback
(
aVersion
=
=
mDescriptor
.
Version
(
)
)
;
return
;
}
mVersionCallbackList
.
AppendElement
(
MakeUnique
<
VersionCallback
>
(
aVersion
std
:
:
move
(
aCallback
)
)
)
;
}
void
ServiceWorkerRegistration
:
:
MaybeScheduleUpdateFound
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aInstallingDescriptor
)
{
uint64_t
newId
=
aInstallingDescriptor
.
isSome
(
)
?
aInstallingDescriptor
.
ref
(
)
.
Id
(
)
:
kInvalidUpdateFoundId
;
if
(
mScheduledUpdateFoundId
!
=
kInvalidUpdateFoundId
)
{
if
(
mScheduledUpdateFoundId
=
=
newId
)
{
return
;
}
MaybeDispatchUpdateFound
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mScheduledUpdateFoundId
=
=
kInvalidUpdateFoundId
)
;
}
bool
updateFound
=
newId
!
=
kInvalidUpdateFoundId
&
&
mDispatchedUpdateFoundId
!
=
newId
;
if
(
!
updateFound
)
{
return
;
}
mScheduledUpdateFoundId
=
newId
;
}
void
ServiceWorkerRegistration
:
:
MaybeDispatchUpdateFoundRunnable
(
)
{
if
(
mScheduledUpdateFoundId
=
=
kInvalidUpdateFoundId
)
{
return
;
}
nsIGlobalObject
*
global
=
GetParentObject
(
)
;
NS_ENSURE_TRUE_VOID
(
global
)
;
nsCOMPtr
<
nsIRunnable
>
r
=
NewCancelableRunnableMethod
(
"
ServiceWorkerRegistration
:
:
MaybeDispatchUpdateFound
"
this
&
ServiceWorkerRegistration
:
:
MaybeDispatchUpdateFound
)
;
Unused
<
<
global
-
>
SerialEventTarget
(
)
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
void
ServiceWorkerRegistration
:
:
MaybeDispatchUpdateFound
(
)
{
uint64_t
scheduledId
=
mScheduledUpdateFoundId
;
mScheduledUpdateFoundId
=
kInvalidUpdateFoundId
;
if
(
scheduledId
=
=
kInvalidUpdateFoundId
|
|
scheduledId
=
=
mDispatchedUpdateFoundId
)
{
return
;
}
mDispatchedUpdateFoundId
=
scheduledId
;
DispatchTrustedEvent
(
u
"
updatefound
"
_ns
)
;
}
void
ServiceWorkerRegistration
:
:
UpdateStateInternal
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aInstalling
const
Maybe
<
ServiceWorkerDescriptor
>
&
aWaiting
const
Maybe
<
ServiceWorkerDescriptor
>
&
aActive
)
{
MaybeScheduleUpdateFound
(
aInstalling
)
;
AutoTArray
<
RefPtr
<
ServiceWorker
>
3
>
oldWorkerList
(
{
std
:
:
move
(
mInstallingWorker
)
std
:
:
move
(
mWaitingWorker
)
std
:
:
move
(
mActiveWorker
)
}
)
;
auto
scopeExit
=
MakeScopeExit
(
[
&
]
{
for
(
auto
&
oldWorker
:
oldWorkerList
)
{
if
(
!
oldWorker
|
|
oldWorker
=
=
mInstallingWorker
|
|
oldWorker
=
=
mWaitingWorker
|
|
oldWorker
=
=
mActiveWorker
)
{
continue
;
}
oldWorker
-
>
SetState
(
ServiceWorkerState
:
:
Redundant
)
;
}
if
(
mInstallingWorker
)
{
mInstallingWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
if
(
mWaitingWorker
)
{
mWaitingWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
if
(
mActiveWorker
)
{
mActiveWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
for
(
auto
&
oldWorker
:
oldWorkerList
)
{
if
(
!
oldWorker
)
{
continue
;
}
oldWorker
-
>
MaybeDispatchStateChangeEvent
(
)
;
}
}
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
GetParentObject
(
)
;
if
(
!
global
|
|
!
NS_IsMainThread
(
)
)
{
return
;
}
if
(
aActive
.
isSome
(
)
)
{
if
(
(
mActiveWorker
=
global
-
>
GetOrCreateServiceWorker
(
aActive
.
ref
(
)
)
)
)
{
mActiveWorker
-
>
SetState
(
aActive
.
ref
(
)
.
State
(
)
)
;
}
}
else
{
mActiveWorker
=
nullptr
;
}
if
(
aWaiting
.
isSome
(
)
)
{
if
(
(
mWaitingWorker
=
global
-
>
GetOrCreateServiceWorker
(
aWaiting
.
ref
(
)
)
)
)
{
mWaitingWorker
-
>
SetState
(
aWaiting
.
ref
(
)
.
State
(
)
)
;
}
}
else
{
mWaitingWorker
=
nullptr
;
}
if
(
aInstalling
.
isSome
(
)
)
{
if
(
(
mInstallingWorker
=
global
-
>
GetOrCreateServiceWorker
(
aInstalling
.
ref
(
)
)
)
)
{
mInstallingWorker
-
>
SetState
(
aInstalling
.
ref
(
)
.
State
(
)
)
;
}
}
else
{
mInstallingWorker
=
nullptr
;
}
}
void
ServiceWorkerRegistration
:
:
RevokeActor
(
ServiceWorkerRegistrationChild
*
aActor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mActor
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mActor
=
=
aActor
)
;
mActor
-
>
RevokeOwner
(
this
)
;
mActor
=
nullptr
;
mShutdown
=
true
;
RegistrationCleared
(
)
;
}
void
ServiceWorkerRegistration
:
:
Shutdown
(
)
{
if
(
mShutdown
)
{
return
;
}
mShutdown
=
true
;
if
(
mActor
)
{
mActor
-
>
RevokeOwner
(
this
)
;
mActor
-
>
MaybeStartTeardown
(
)
;
mActor
=
nullptr
;
}
}
}
