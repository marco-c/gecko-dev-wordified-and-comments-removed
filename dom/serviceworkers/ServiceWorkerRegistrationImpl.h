#
ifndef
mozilla_dom_serviceworkerregistrationimpl_h
#
define
mozilla_dom_serviceworkerregistrationimpl_h
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
ServiceWorkerRegistration
.
h
"
#
include
"
ServiceWorkerRegistrationListener
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Promise
;
class
PushManager
;
class
ServiceWorker
;
class
WeakWorkerRef
;
class
ServiceWorkerRegistrationMainThread
final
:
public
ServiceWorkerRegistration
:
:
Inner
public
ServiceWorkerRegistrationListener
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ServiceWorkerRegistrationMainThread
override
)
explicit
ServiceWorkerRegistrationMainThread
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
;
void
SetServiceWorkerRegistration
(
ServiceWorkerRegistration
*
aReg
)
override
;
void
ClearServiceWorkerRegistration
(
ServiceWorkerRegistration
*
aReg
)
override
;
RefPtr
<
ServiceWorkerRegistrationPromise
>
Update
(
ErrorResult
&
aRv
)
override
;
RefPtr
<
GenericPromise
>
Unregister
(
)
override
;
already_AddRefed
<
Promise
>
ShowNotification
(
JSContext
*
aCx
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
override
;
already_AddRefed
<
Promise
>
GetNotifications
(
const
GetNotificationOptions
&
aOptions
ErrorResult
&
aRv
)
override
;
void
UpdateFound
(
)
override
;
void
UpdateState
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
override
;
void
RegistrationRemoved
(
)
override
;
void
GetScope
(
nsAString
&
aScope
)
const
override
{
aScope
=
mScope
;
}
bool
MatchesDescriptor
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
override
;
private
:
~
ServiceWorkerRegistrationMainThread
(
)
;
void
StartListeningForEvents
(
)
;
void
StopListeningForEvents
(
)
;
void
RegistrationRemovedInternal
(
)
;
ServiceWorkerRegistration
*
mOuter
;
ServiceWorkerRegistrationDescriptor
mDescriptor
;
const
nsString
mScope
;
bool
mListeningForEvents
;
}
;
class
WorkerListener
;
class
ServiceWorkerRegistrationWorkerThread
final
:
public
ServiceWorkerRegistration
:
:
Inner
{
friend
class
WorkerListener
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
ServiceWorkerRegistrationWorkerThread
override
)
explicit
ServiceWorkerRegistrationWorkerThread
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
;
void
RegistrationRemoved
(
)
;
void
SetServiceWorkerRegistration
(
ServiceWorkerRegistration
*
aReg
)
override
;
void
ClearServiceWorkerRegistration
(
ServiceWorkerRegistration
*
aReg
)
override
;
RefPtr
<
ServiceWorkerRegistrationPromise
>
Update
(
ErrorResult
&
aRv
)
override
;
RefPtr
<
GenericPromise
>
Unregister
(
)
override
;
already_AddRefed
<
Promise
>
ShowNotification
(
JSContext
*
aCx
const
nsAString
&
aTitle
const
NotificationOptions
&
aOptions
ErrorResult
&
aRv
)
override
;
already_AddRefed
<
Promise
>
GetNotifications
(
const
GetNotificationOptions
&
aOptions
ErrorResult
&
aRv
)
override
;
void
UpdateFound
(
)
;
private
:
~
ServiceWorkerRegistrationWorkerThread
(
)
;
void
InitListener
(
)
;
void
ReleaseListener
(
)
;
WorkerPrivate
*
GetWorkerPrivate
(
const
MutexAutoLock
&
aProofOfLock
)
;
ServiceWorkerRegistration
*
mOuter
;
const
ServiceWorkerRegistrationDescriptor
mDescriptor
;
const
nsString
mScope
;
RefPtr
<
WorkerListener
>
mListener
;
RefPtr
<
WeakWorkerRef
>
mWorkerRef
;
}
;
}
}
#
endif
