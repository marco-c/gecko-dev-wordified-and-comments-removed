#
include
"
ServiceWorkerPrivate
.
h
"
#
include
"
ServiceWorkerCloneData
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsIPushErrorReporter
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
JSObjectHolder
.
h
"
#
include
"
mozilla
/
dom
/
Client
.
h
"
#
include
"
mozilla
/
dom
/
ClientIPCTypes
.
h
"
#
include
"
mozilla
/
dom
/
FetchUtil
.
h
"
#
include
"
mozilla
/
dom
/
IndexedDatabaseManager
.
h
"
#
include
"
mozilla
/
dom
/
InternalHeaders
.
h
"
#
include
"
mozilla
/
dom
/
NotificationEvent
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
PushEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkerDebugger
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
dom
/
WorkerScope
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StructuredCloneData
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
dom
{
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
NS_IMPL_CYCLE_COLLECTING_NATIVE_ADDREF
(
ServiceWorkerPrivate
)
NS_IMPL_CYCLE_COLLECTING_NATIVE_RELEASE
(
ServiceWorkerPrivate
)
NS_IMPL_CYCLE_COLLECTION
(
ServiceWorkerPrivate
mSupportsArray
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
ServiceWorkerPrivate
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
ServiceWorkerPrivate
Release
)
Atomic
<
uint32_t
>
gDOMDisableOpenClickDelay
(
0
)
;
class
KeepAliveToken
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveToken
(
ServiceWorkerPrivate
*
aPrivate
)
:
mPrivate
(
aPrivate
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrivate
)
;
mPrivate
-
>
AddToken
(
)
;
}
private
:
~
KeepAliveToken
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mPrivate
-
>
ReleaseToken
(
)
;
}
RefPtr
<
ServiceWorkerPrivate
>
mPrivate
;
}
;
NS_IMPL_ISUPPORTS0
(
KeepAliveToken
)
ServiceWorkerPrivate
:
:
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
:
mInfo
(
aInfo
)
mDebuggerCount
(
0
)
mTokenCount
(
0
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aInfo
)
;
mIdleWorkerTimer
=
NS_NewTimer
(
)
;
MOZ_ASSERT
(
mIdleWorkerTimer
)
;
}
ServiceWorkerPrivate
:
:
~
ServiceWorkerPrivate
(
)
{
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
MOZ_ASSERT
(
!
mTokenCount
)
;
MOZ_ASSERT
(
!
mInfo
)
;
MOZ_ASSERT
(
mSupportsArray
.
IsEmpty
(
)
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
}
namespace
{
class
CheckScriptEvaluationWithCallback
final
:
public
WorkerRunnable
{
nsMainThreadPtrHandle
<
ServiceWorkerPrivate
>
mServiceWorkerPrivate
;
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
RefPtr
<
LifeCycleEventCallback
>
mScriptEvaluationCallback
;
#
ifdef
DEBUG
bool
mDone
;
#
endif
public
:
CheckScriptEvaluationWithCallback
(
WorkerPrivate
*
aWorkerPrivate
ServiceWorkerPrivate
*
aServiceWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
LifeCycleEventCallback
*
aScriptEvaluationCallback
)
:
WorkerRunnable
(
aWorkerPrivate
)
mServiceWorkerPrivate
(
new
nsMainThreadPtrHolder
<
ServiceWorkerPrivate
>
(
"
CheckScriptEvaluationWithCallback
:
:
mServiceWorkerPrivate
"
aServiceWorkerPrivate
)
)
mKeepAliveToken
(
new
nsMainThreadPtrHolder
<
KeepAliveToken
>
(
"
CheckScriptEvaluationWithCallback
:
:
mKeepAliveToken
"
aKeepAliveToken
)
)
mScriptEvaluationCallback
(
aScriptEvaluationCallback
)
#
ifdef
DEBUG
mDone
(
false
)
#
endif
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
~
CheckScriptEvaluationWithCallback
(
)
{
MOZ_ASSERT
(
mDone
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
bool
fetchHandlerWasAdded
=
aWorkerPrivate
-
>
FetchHandlerWasAdded
(
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
<
bool
>
(
"
dom
:
:
CheckScriptEvaluationWithCallback
:
:
ReportFetchFlag
"
this
&
CheckScriptEvaluationWithCallback
:
:
ReportFetchFlag
fetchHandlerWasAdded
)
;
aWorkerPrivate
-
>
DispatchToMainThread
(
runnable
.
forget
(
)
)
;
ReportScriptEvaluationResult
(
aWorkerPrivate
-
>
WorkerScriptExecutedSuccessfully
(
)
)
;
return
true
;
}
void
ReportFetchFlag
(
bool
aFetchHandlerWasAdded
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mServiceWorkerPrivate
-
>
SetHandlesFetch
(
aFetchHandlerWasAdded
)
;
}
nsresult
Cancel
(
)
override
{
ReportScriptEvaluationResult
(
false
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
private
:
void
ReportScriptEvaluationResult
(
bool
aScriptEvaluationResult
)
{
#
ifdef
DEBUG
mDone
=
true
;
#
endif
mScriptEvaluationCallback
-
>
SetResult
(
aScriptEvaluationResult
)
;
MOZ_ALWAYS_SUCCEEDS
(
mWorkerPrivate
-
>
DispatchToMainThread
(
mScriptEvaluationCallback
)
)
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
CheckScriptEvaluation
(
LifeCycleEventCallback
*
aScriptEvaluationCallback
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
LifeCycleEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
KeepAliveToken
>
token
=
CreateEventKeepAliveToken
(
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
CheckScriptEvaluationWithCallback
(
mWorkerPrivate
this
token
aScriptEvaluationCallback
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
enum
ExtendableEventResult
{
Rejected
=
0
Resolved
}
;
class
ExtendableEventCallback
{
public
:
virtual
void
FinishedWithResult
(
ExtendableEventResult
aResult
)
=
0
;
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
}
;
class
KeepAliveHandler
final
:
public
ExtendableEvent
:
:
ExtensionsHandler
public
PromiseNativeHandler
{
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
RefPtr
<
KeepAliveHandler
>
mSelfRef
;
RefPtr
<
ExtendableEventCallback
>
mCallback
;
uint32_t
mPendingPromisesCount
;
bool
mRejected
;
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveHandler
(
const
nsMainThreadPtrHandle
<
KeepAliveToken
>
&
aKeepAliveToken
ExtendableEventCallback
*
aCallback
)
:
mKeepAliveToken
(
aKeepAliveToken
)
mCallback
(
aCallback
)
mPendingPromisesCount
(
0
)
mRejected
(
false
)
{
MOZ_ASSERT
(
mKeepAliveToken
)
;
}
bool
Init
(
)
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
RefPtr
<
KeepAliveHandler
>
self
=
this
;
mWorkerRef
=
StrongWorkerRef
:
:
Create
(
GetCurrentThreadWorkerPrivate
(
)
"
KeepAliveHandler
"
[
self
]
(
)
{
self
-
>
MaybeCleanup
(
)
;
}
)
;
if
(
NS_WARN_IF
(
!
mWorkerRef
)
)
{
return
false
;
}
return
true
;
}
bool
WaitOnPromise
(
Promise
&
aPromise
)
override
{
if
(
!
mKeepAliveToken
)
{
MOZ_ASSERT
(
!
mSelfRef
"
We
shouldn
'
t
be
holding
a
self
reference
!
"
)
;
return
false
;
}
if
(
!
mSelfRef
)
{
MOZ_ASSERT
(
!
mPendingPromisesCount
)
;
mSelfRef
=
this
;
}
+
+
mPendingPromisesCount
;
aPromise
.
AppendNativeHandler
(
this
)
;
return
true
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
RemovePromise
(
Resolved
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
RemovePromise
(
Rejected
)
;
}
void
MaybeDone
(
)
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
if
(
mPendingPromisesCount
|
|
!
mKeepAliveToken
)
{
return
;
}
if
(
mCallback
)
{
mCallback
-
>
FinishedWithResult
(
mRejected
?
Rejected
:
Resolved
)
;
}
MaybeCleanup
(
)
;
}
private
:
~
KeepAliveHandler
(
)
{
MaybeCleanup
(
)
;
}
void
MaybeCleanup
(
)
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
if
(
!
mKeepAliveToken
)
{
return
;
}
mWorkerRef
=
nullptr
;
mKeepAliveToken
=
nullptr
;
mSelfRef
=
nullptr
;
}
class
MaybeDoneRunner
:
public
MicroTaskRunnable
{
public
:
explicit
MaybeDoneRunner
(
KeepAliveHandler
*
aHandler
)
:
mHandler
(
aHandler
)
{
}
virtual
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
mHandler
-
>
MaybeDone
(
)
;
}
RefPtr
<
KeepAliveHandler
>
mHandler
;
}
;
void
RemovePromise
(
ExtendableEventResult
aResult
)
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPendingPromisesCount
>
0
)
;
mRejected
|
=
(
aResult
=
=
Rejected
)
;
-
-
mPendingPromisesCount
;
if
(
mPendingPromisesCount
)
{
return
;
}
CycleCollectedJSContext
*
cx
=
CycleCollectedJSContext
:
:
Get
(
)
;
MOZ_ASSERT
(
cx
)
;
RefPtr
<
MaybeDoneRunner
>
r
=
new
MaybeDoneRunner
(
this
)
;
cx
-
>
DispatchToMicroTask
(
r
.
forget
(
)
)
;
}
}
;
NS_IMPL_ISUPPORTS0
(
KeepAliveHandler
)
class
RegistrationUpdateRunnable
:
public
Runnable
{
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
mRegistration
;
const
bool
mNeedTimeCheck
;
public
:
RegistrationUpdateRunnable
(
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
bool
aNeedTimeCheck
)
:
Runnable
(
"
dom
:
:
RegistrationUpdateRunnable
"
)
mRegistration
(
aRegistration
)
mNeedTimeCheck
(
aNeedTimeCheck
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mRegistration
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mNeedTimeCheck
)
{
mRegistration
-
>
MaybeScheduleTimeCheckAndUpdate
(
)
;
}
else
{
mRegistration
-
>
MaybeScheduleUpdate
(
)
;
}
return
NS_OK
;
}
}
;
class
ExtendableEventWorkerRunnable
:
public
WorkerRunnable
{
protected
:
nsMainThreadPtrHandle
<
KeepAliveToken
>
mKeepAliveToken
;
public
:
ExtendableEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
)
:
WorkerRunnable
(
aWorkerPrivate
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aKeepAliveToken
)
;
mKeepAliveToken
=
new
nsMainThreadPtrHolder
<
KeepAliveToken
>
(
"
ExtendableEventWorkerRunnable
:
:
mKeepAliveToken
"
aKeepAliveToken
)
;
}
nsresult
DispatchExtendableEventOnWorkerScope
(
JSContext
*
aCx
WorkerGlobalScope
*
aWorkerScope
ExtendableEvent
*
aEvent
ExtendableEventCallback
*
aCallback
)
{
MOZ_ASSERT
(
aWorkerScope
)
;
MOZ_ASSERT
(
aEvent
)
;
nsCOMPtr
<
nsIGlobalObject
>
sgo
=
aWorkerScope
;
WidgetEvent
*
internalEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
RefPtr
<
KeepAliveHandler
>
keepAliveHandler
=
new
KeepAliveHandler
(
mKeepAliveToken
aCallback
)
;
if
(
NS_WARN_IF
(
!
keepAliveHandler
-
>
Init
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
aEvent
-
>
SetKeepAliveHandler
(
keepAliveHandler
)
;
ErrorResult
result
;
aWorkerScope
-
>
DispatchEvent
(
*
aEvent
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
NS_ERROR_FAILURE
;
}
keepAliveHandler
-
>
MaybeDone
(
)
;
if
(
internalEvent
-
>
mFlags
.
mExceptionWasRaised
)
{
result
.
SuppressException
(
)
;
return
NS_ERROR_XPC_JS_THREW_EXCEPTION
;
}
return
NS_OK
;
}
}
;
class
SendMessageEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
const
ClientInfoAndState
mClientInfoAndState
;
RefPtr
<
ServiceWorkerCloneData
>
mData
;
public
:
SendMessageEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
const
ClientInfoAndState
&
aClientInfoAndState
RefPtr
<
ServiceWorkerCloneData
>
&
&
aData
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mClientInfoAndState
(
aClientInfoAndState
)
mData
(
std
:
:
move
(
aData
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mData
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
JS
:
:
Rooted
<
JS
:
:
Value
>
messageData
(
aCx
)
;
nsCOMPtr
<
nsIGlobalObject
>
sgo
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
ErrorResult
rv
;
mData
-
>
Read
(
aCx
&
messageData
rv
)
;
bool
deserializationFailed
=
rv
.
ErrorCodeIs
(
NS_ERROR_DOM_DATA_CLONE_ERR
)
;
if
(
!
deserializationFailed
&
&
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
true
;
}
Sequence
<
OwningNonNull
<
MessagePort
>
>
ports
;
if
(
!
mData
-
>
TakeTransferredPortsAsSequence
(
ports
)
)
{
return
true
;
}
RootedDictionary
<
ExtendableMessageEventInit
>
init
(
aCx
)
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
if
(
!
deserializationFailed
)
{
init
.
mData
=
messageData
;
init
.
mPorts
=
ports
;
}
init
.
mSource
.
SetValue
(
)
.
SetAsClient
(
)
=
new
Client
(
sgo
mClientInfoAndState
)
;
rv
=
NS_OK
;
RefPtr
<
EventTarget
>
target
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
RefPtr
<
ExtendableMessageEvent
>
extendableEvent
=
ExtendableMessageEvent
:
:
Constructor
(
target
deserializationFailed
?
NS_LITERAL_STRING
(
"
messageerror
"
)
:
NS_LITERAL_STRING
(
"
message
"
)
init
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
rv
.
SuppressException
(
)
;
return
false
;
}
extendableEvent
-
>
SetTrusted
(
true
)
;
return
NS_SUCCEEDED
(
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
extendableEvent
nullptr
)
)
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
SendMessageEvent
(
RefPtr
<
ServiceWorkerCloneData
>
&
&
aData
const
ClientInfoAndState
&
aClientInfoAndState
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsresult
rv
=
SpawnWorkerIfNeeded
(
MessageEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
KeepAliveToken
>
token
=
CreateEventKeepAliveToken
(
)
;
RefPtr
<
SendMessageEventRunnable
>
runnable
=
new
SendMessageEventRunnable
(
mWorkerPrivate
token
aClientInfoAndState
std
:
:
move
(
aData
)
)
;
if
(
!
runnable
-
>
Dispatch
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
ExtendableFunctionalEventWorkerRunnable
:
public
ExtendableEventWorkerRunnable
{
protected
:
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
mRegistration
;
public
:
ExtendableFunctionalEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mRegistration
(
aRegistration
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aRegistration
)
;
}
void
PostRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
bool
aRunResult
)
override
{
if
(
mRegistration
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
RegistrationUpdateRunnable
(
mRegistration
true
)
;
aWorkerPrivate
-
>
DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
ExtendableEventWorkerRunnable
:
:
PostRun
(
aCx
aWorkerPrivate
aRunResult
)
;
}
}
;
class
LifecycleEventWorkerRunnable
:
public
ExtendableEventWorkerRunnable
{
nsString
mEventName
;
RefPtr
<
LifeCycleEventCallback
>
mCallback
;
public
:
LifecycleEventWorkerRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aToken
const
nsAString
&
aEventName
LifeCycleEventCallback
*
aCallback
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aToken
)
mEventName
(
aEventName
)
mCallback
(
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
return
DispatchLifecycleEvent
(
aCx
aWorkerPrivate
)
;
}
nsresult
Cancel
(
)
override
{
mCallback
-
>
SetResult
(
false
)
;
MOZ_ALWAYS_SUCCEEDS
(
mWorkerPrivate
-
>
DispatchToMainThread
(
mCallback
)
)
;
return
WorkerRunnable
:
:
Cancel
(
)
;
}
private
:
bool
DispatchLifecycleEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
;
}
;
class
LifeCycleEventWatcher
final
:
public
ExtendableEventCallback
{
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
RefPtr
<
LifeCycleEventCallback
>
mCallback
;
~
LifeCycleEventWatcher
(
)
{
ReportResult
(
false
)
;
}
public
:
NS_INLINE_DECL_REFCOUNTING
(
LifeCycleEventWatcher
override
)
explicit
LifeCycleEventWatcher
(
LifeCycleEventCallback
*
aCallback
)
:
mCallback
(
aCallback
)
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
}
bool
Init
(
)
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
RefPtr
<
LifeCycleEventWatcher
>
self
=
this
;
mWorkerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
LifeCycleEventWatcher
"
[
self
]
(
)
{
self
-
>
ReportResult
(
false
)
;
}
)
;
if
(
NS_WARN_IF
(
!
mWorkerRef
)
)
{
mCallback
-
>
SetResult
(
false
)
;
nsresult
rv
=
workerPrivate
-
>
DispatchToMainThread
(
mCallback
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
return
false
;
}
return
true
;
}
void
ReportResult
(
bool
aResult
)
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
if
(
!
mWorkerRef
)
{
return
;
}
mCallback
-
>
SetResult
(
aResult
)
;
nsresult
rv
=
mWorkerRef
-
>
Private
(
)
-
>
DispatchToMainThread
(
mCallback
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MOZ_CRASH
(
"
Failed
to
dispatch
life
cycle
event
handler
.
"
)
;
}
mWorkerRef
=
nullptr
;
}
void
FinishedWithResult
(
ExtendableEventResult
aResult
)
override
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
ReportResult
(
aResult
=
=
Resolved
)
;
}
}
;
bool
LifecycleEventWorkerRunnable
:
:
DispatchLifecycleEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
RefPtr
<
ExtendableEvent
>
event
;
RefPtr
<
EventTarget
>
target
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
if
(
mEventName
.
EqualsASCII
(
"
install
"
)
|
|
mEventName
.
EqualsASCII
(
"
activate
"
)
)
{
ExtendableEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
event
=
ExtendableEvent
:
:
Constructor
(
target
mEventName
init
)
;
}
else
{
MOZ_CRASH
(
"
Unexpected
lifecycle
event
"
)
;
}
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
LifeCycleEventWatcher
>
watcher
=
new
LifeCycleEventWatcher
(
mCallback
)
;
if
(
!
watcher
-
>
Init
(
)
)
{
return
true
;
}
nsresult
rv
=
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
watcher
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_XPC_JS_THREW_EXCEPTION
)
{
watcher
-
>
ReportResult
(
false
)
;
}
return
true
;
}
}
nsresult
ServiceWorkerPrivate
:
:
SendLifeCycleEvent
(
const
nsAString
&
aEventType
LifeCycleEventCallback
*
aCallback
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
LifeCycleEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
KeepAliveToken
>
token
=
CreateEventKeepAliveToken
(
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
LifecycleEventWorkerRunnable
(
mWorkerPrivate
token
aEventType
aCallback
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
PushErrorReporter
final
:
public
ExtendableEventCallback
{
WorkerPrivate
*
mWorkerPrivate
;
nsString
mMessageId
;
~
PushErrorReporter
(
)
{
}
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PushErrorReporter
override
)
PushErrorReporter
(
WorkerPrivate
*
aWorkerPrivate
const
nsAString
&
aMessageId
)
:
mWorkerPrivate
(
aWorkerPrivate
)
mMessageId
(
aMessageId
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
}
void
FinishedWithResult
(
ExtendableEventResult
aResult
)
override
{
if
(
aResult
=
=
Rejected
)
{
Report
(
nsIPushErrorReporter
:
:
DELIVERY_UNHANDLED_REJECTION
)
;
}
}
void
Report
(
uint16_t
aReason
=
nsIPushErrorReporter
:
:
DELIVERY_INTERNAL_ERROR
)
{
WorkerPrivate
*
workerPrivate
=
mWorkerPrivate
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
NS_WARN_IF
(
aReason
>
nsIPushErrorReporter
:
:
DELIVERY_INTERNAL_ERROR
)
|
|
mMessageId
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
<
uint16_t
>
(
"
dom
:
:
PushErrorReporter
:
:
ReportOnMainThread
"
this
&
PushErrorReporter
:
:
ReportOnMainThread
aReason
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
workerPrivate
-
>
DispatchToMainThread
(
runnable
.
forget
(
)
)
)
)
;
}
void
ReportOnMainThread
(
uint16_t
aReason
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIPushErrorReporter
>
reporter
=
do_GetService
(
"
mozilla
.
org
/
push
/
Service
;
1
"
)
;
if
(
reporter
)
{
nsresult
rv
=
reporter
-
>
ReportDeliveryError
(
mMessageId
aReason
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
}
}
;
class
SendPushEventRunnable
final
:
public
ExtendableFunctionalEventWorkerRunnable
{
nsString
mMessageId
;
Maybe
<
nsTArray
<
uint8_t
>
>
mData
;
public
:
SendPushEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
const
nsAString
&
aMessageId
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
aRegistration
)
:
ExtendableFunctionalEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
aRegistration
)
mMessageId
(
aMessageId
)
mData
(
aData
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
GlobalObject
globalObj
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
GetWrapper
(
)
)
;
RefPtr
<
PushErrorReporter
>
errorReporter
=
new
PushErrorReporter
(
aWorkerPrivate
mMessageId
)
;
PushEventInit
pei
;
if
(
mData
)
{
const
nsTArray
<
uint8_t
>
&
bytes
=
mData
.
ref
(
)
;
JSObject
*
data
=
Uint8Array
:
:
Create
(
aCx
bytes
.
Length
(
)
bytes
.
Elements
(
)
)
;
if
(
!
data
)
{
errorReporter
-
>
Report
(
)
;
return
false
;
}
pei
.
mData
.
Construct
(
)
.
SetAsArrayBufferView
(
)
.
Init
(
data
)
;
}
pei
.
mBubbles
=
false
;
pei
.
mCancelable
=
false
;
ErrorResult
result
;
RefPtr
<
PushEvent
>
event
=
PushEvent
:
:
Constructor
(
globalObj
NS_LITERAL_STRING
(
"
push
"
)
pei
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
errorReporter
-
>
Report
(
)
;
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
nsresult
rv
=
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
errorReporter
)
;
if
(
NS_FAILED
(
rv
)
)
{
errorReporter
-
>
Report
(
nsIPushErrorReporter
:
:
DELIVERY_UNCAUGHT_EXCEPTION
)
;
}
return
true
;
}
}
;
class
SendPushSubscriptionChangeEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
public
:
explicit
SendPushSubscriptionChangeEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
RefPtr
<
EventTarget
>
target
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
ExtendableEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
RefPtr
<
ExtendableEvent
>
event
=
ExtendableEvent
:
:
Constructor
(
target
NS_LITERAL_STRING
(
"
pushsubscriptionchange
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
nullptr
)
;
return
true
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
SendPushEvent
(
const
nsAString
&
aMessageId
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
ServiceWorkerRegistrationInfo
*
aRegistration
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
PushEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
KeepAliveToken
>
token
=
CreateEventKeepAliveToken
(
)
;
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
regInfo
(
new
nsMainThreadPtrHolder
<
ServiceWorkerRegistrationInfo
>
(
"
ServiceWorkerRegistrationInfoProxy
"
aRegistration
false
)
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
SendPushEventRunnable
(
mWorkerPrivate
token
aMessageId
aData
regInfo
)
;
if
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activating
)
{
mPendingFunctionalEvents
.
AppendElement
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activated
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
SendPushSubscriptionChangeEvent
(
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
PushSubscriptionChangeEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
KeepAliveToken
>
token
=
CreateEventKeepAliveToken
(
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
SendPushSubscriptionChangeEventRunnable
(
mWorkerPrivate
token
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
AllowWindowInteractionHandler
final
:
public
ExtendableEventCallback
public
nsITimerCallback
public
nsINamed
{
nsCOMPtr
<
nsITimer
>
mTimer
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
~
AllowWindowInteractionHandler
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mTimer
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mWorkerRef
)
;
}
void
ClearWindowAllowed
(
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
if
(
!
mTimer
)
{
return
;
}
WorkerGlobalScope
*
globalScope
=
aWorkerPrivate
-
>
GlobalScope
(
)
;
if
(
!
globalScope
)
{
return
;
}
globalScope
-
>
ConsumeWindowInteraction
(
)
;
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
mWorkerRef
=
nullptr
;
}
void
StartClearWindowTimer
(
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mTimer
)
;
nsresult
rv
;
nsCOMPtr
<
nsITimer
>
timer
=
NS_NewTimer
(
aWorkerPrivate
-
>
ControlEventTarget
(
)
)
;
if
(
NS_WARN_IF
(
!
timer
)
)
{
return
;
}
MOZ_ASSERT
(
!
mWorkerRef
)
;
RefPtr
<
AllowWindowInteractionHandler
>
self
=
this
;
mWorkerRef
=
StrongWorkerRef
:
:
Create
(
aWorkerPrivate
"
AllowWindowInteractionHandler
"
[
self
]
(
)
{
self
-
>
ClearWindowAllowed
(
self
-
>
mWorkerRef
-
>
Private
(
)
)
;
}
)
;
if
(
!
mWorkerRef
)
{
return
;
}
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
AllowWindowInteraction
(
)
;
timer
.
swap
(
mTimer
)
;
rv
=
mTimer
-
>
InitWithCallback
(
this
gDOMDisableOpenClickDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ClearWindowAllowed
(
aWorkerPrivate
)
;
return
;
}
}
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
mTimer
=
=
aTimer
)
;
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
ClearWindowAllowed
(
workerPrivate
)
;
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
AllowWindowInteractionHandler
"
)
;
return
NS_OK
;
}
public
:
NS_DECL_THREADSAFE_ISUPPORTS
explicit
AllowWindowInteractionHandler
(
WorkerPrivate
*
aWorkerPrivate
)
{
StartClearWindowTimer
(
aWorkerPrivate
)
;
}
void
FinishedWithResult
(
ExtendableEventResult
)
override
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
ClearWindowAllowed
(
workerPrivate
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
AllowWindowInteractionHandler
nsITimerCallback
nsINamed
)
class
SendNotificationEventRunnable
final
:
public
ExtendableEventWorkerRunnable
{
const
nsString
mEventName
;
const
nsString
mID
;
const
nsString
mTitle
;
const
nsString
mDir
;
const
nsString
mLang
;
const
nsString
mBody
;
const
nsString
mTag
;
const
nsString
mIcon
;
const
nsString
mData
;
const
nsString
mBehavior
;
const
nsString
mScope
;
public
:
SendNotificationEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
const
nsAString
&
aEventName
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
:
ExtendableEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
)
mEventName
(
aEventName
)
mID
(
aID
)
mTitle
(
aTitle
)
mDir
(
aDir
)
mLang
(
aLang
)
mBody
(
aBody
)
mTag
(
aTag
)
mIcon
(
aIcon
)
mData
(
aData
)
mBehavior
(
aBehavior
)
mScope
(
aScope
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
RefPtr
<
EventTarget
>
target
=
do_QueryObject
(
aWorkerPrivate
-
>
GlobalScope
(
)
)
;
ErrorResult
result
;
RefPtr
<
Notification
>
notification
=
Notification
:
:
ConstructFromFields
(
aWorkerPrivate
-
>
GlobalScope
(
)
mID
mTitle
mDir
mLang
mBody
mTag
mIcon
mData
mScope
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
false
;
}
NotificationEventInit
nei
;
nei
.
mNotification
=
notification
;
nei
.
mBubbles
=
false
;
nei
.
mCancelable
=
false
;
RefPtr
<
NotificationEvent
>
event
=
NotificationEvent
:
:
Constructor
(
target
mEventName
nei
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
return
false
;
}
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
AllowWindowInteractionHandler
>
allowWindowInteraction
;
if
(
mEventName
.
EqualsLiteral
(
NOTIFICATION_CLICK_EVENT_NAME
)
)
{
allowWindowInteraction
=
new
AllowWindowInteractionHandler
(
aWorkerPrivate
)
;
}
nsresult
rv
=
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
allowWindowInteraction
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_XPC_JS_THREW_EXCEPTION
&
&
allowWindowInteraction
)
{
allowWindowInteraction
-
>
FinishedWithResult
(
Rejected
)
;
}
return
true
;
}
}
;
}
nsresult
ServiceWorkerPrivate
:
:
SendNotificationEvent
(
const
nsAString
&
aEventName
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
{
WakeUpReason
why
;
if
(
aEventName
.
EqualsLiteral
(
NOTIFICATION_CLICK_EVENT_NAME
)
)
{
why
=
NotificationClickEvent
;
gDOMDisableOpenClickDelay
=
Preferences
:
:
GetInt
(
"
dom
.
serviceWorkers
.
disable_open_click_delay
"
)
;
}
else
if
(
aEventName
.
EqualsLiteral
(
NOTIFICATION_CLOSE_EVENT_NAME
)
)
{
why
=
NotificationCloseEvent
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
notification
event
name
"
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
SpawnWorkerIfNeeded
(
why
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
KeepAliveToken
>
token
=
CreateEventKeepAliveToken
(
)
;
RefPtr
<
WorkerRunnable
>
r
=
new
SendNotificationEventRunnable
(
mWorkerPrivate
token
aEventName
aID
aTitle
aDir
aLang
aBody
aTag
aIcon
aData
aBehavior
aScope
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
namespace
{
class
FetchEventRunnable
:
public
ExtendableFunctionalEventWorkerRunnable
public
nsIHttpHeaderVisitor
{
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
mInterceptedChannel
;
const
nsCString
mScriptSpec
;
nsTArray
<
nsCString
>
mHeaderNames
;
nsTArray
<
nsCString
>
mHeaderValues
;
nsCString
mSpec
;
nsCString
mFragment
;
nsCString
mMethod
;
nsString
mClientId
;
nsString
mResultingClientId
;
bool
mIsReload
;
bool
mMarkLaunchServiceWorkerEnd
;
RequestCache
mCacheMode
;
RequestMode
mRequestMode
;
RequestRedirect
mRequestRedirect
;
RequestCredentials
mRequestCredentials
;
nsContentPolicyType
mContentPolicyType
;
nsCOMPtr
<
nsIInputStream
>
mUploadStream
;
int64_t
mUploadStreamContentLength
;
nsCString
mReferrer
;
ReferrerPolicy
mReferrerPolicy
;
nsString
mIntegrity
;
const
bool
mIsNonSubresourceRequest
;
public
:
FetchEventRunnable
(
WorkerPrivate
*
aWorkerPrivate
KeepAliveToken
*
aKeepAliveToken
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
&
aChannel
const
nsACString
&
aScriptSpec
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
const
nsAString
&
aClientId
const
nsAString
&
aResultingClientId
bool
aIsReload
bool
aMarkLaunchServiceWorkerEnd
bool
aIsNonSubresourceRequest
)
:
ExtendableFunctionalEventWorkerRunnable
(
aWorkerPrivate
aKeepAliveToken
aRegistration
)
mInterceptedChannel
(
aChannel
)
mScriptSpec
(
aScriptSpec
)
mClientId
(
aClientId
)
mResultingClientId
(
aResultingClientId
)
mIsReload
(
aIsReload
)
mMarkLaunchServiceWorkerEnd
(
aMarkLaunchServiceWorkerEnd
)
mCacheMode
(
RequestCache
:
:
Default
)
mRequestMode
(
RequestMode
:
:
No_cors
)
mRequestRedirect
(
RequestRedirect
:
:
Follow
)
mRequestCredentials
(
RequestCredentials
:
:
Same_origin
)
mContentPolicyType
(
nsIContentPolicy
:
:
TYPE_INVALID
)
mUploadStreamContentLength
(
-
1
)
mReferrer
(
kFETCH_CLIENT_REFERRER_STR
)
mReferrerPolicy
(
ReferrerPolicy
:
:
_empty
)
mIsNonSubresourceRequest
(
aIsNonSubresourceRequest
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
}
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
mHeaderNames
.
AppendElement
(
aHeader
)
;
mHeaderValues
.
AppendElement
(
aValue
)
;
return
NS_OK
;
}
nsresult
Init
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
mInterceptedChannel
-
>
GetChannel
(
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
mInterceptedChannel
-
>
GetSecureUpgradedChannelURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uriNoFragment
;
rv
=
NS_GetURIWithoutRef
(
uri
getter_AddRefs
(
uriNoFragment
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uriNoFragment
-
>
GetSpec
(
mSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
uri
-
>
GetRef
(
mFragment
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
loadFlags
;
rv
=
channel
-
>
GetLoadFlags
(
&
loadFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
channel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
loadInfo
)
;
mContentPolicyType
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
channel
)
;
MOZ_ASSERT
(
httpChannel
"
How
come
we
don
'
t
have
an
HTTP
channel
?
"
)
;
nsAutoCString
referrer
;
Unused
<
<
httpChannel
-
>
GetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Referer
"
)
referrer
)
;
if
(
!
referrer
.
IsEmpty
(
)
)
{
mReferrer
=
referrer
;
}
else
{
mReferrer
=
EmptyCString
(
)
;
}
uint32_t
referrerPolicy
=
0
;
rv
=
httpChannel
-
>
GetReferrerPolicy
(
&
referrerPolicy
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
switch
(
referrerPolicy
)
{
case
nsIHttpChannel
:
:
REFERRER_POLICY_UNSET
:
mReferrerPolicy
=
ReferrerPolicy
:
:
_empty
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_NO_REFERRER
:
mReferrerPolicy
=
ReferrerPolicy
:
:
No_referrer
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_ORIGIN
:
mReferrerPolicy
=
ReferrerPolicy
:
:
Origin
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_NO_REFERRER_WHEN_DOWNGRADE
:
mReferrerPolicy
=
ReferrerPolicy
:
:
No_referrer_when_downgrade
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_ORIGIN_WHEN_XORIGIN
:
mReferrerPolicy
=
ReferrerPolicy
:
:
Origin_when_cross_origin
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_UNSAFE_URL
:
mReferrerPolicy
=
ReferrerPolicy
:
:
Unsafe_url
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_SAME_ORIGIN
:
mReferrerPolicy
=
ReferrerPolicy
:
:
Same_origin
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_STRICT_ORIGIN_WHEN_XORIGIN
:
mReferrerPolicy
=
ReferrerPolicy
:
:
Strict_origin_when_cross_origin
;
break
;
case
nsIHttpChannel
:
:
REFERRER_POLICY_STRICT_ORIGIN
:
mReferrerPolicy
=
ReferrerPolicy
:
:
Strict_origin
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
Referrer
Policy
enum
value
?
"
)
;
break
;
}
rv
=
httpChannel
-
>
GetRequestMethod
(
mMethod
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
httpChannel
)
;
NS_ENSURE_TRUE
(
internalChannel
NS_ERROR_NOT_AVAILABLE
)
;
mRequestMode
=
InternalRequest
:
:
MapChannelToRequestMode
(
channel
)
;
uint32_t
redirectMode
;
rv
=
internalChannel
-
>
GetRedirectMode
(
&
redirectMode
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mRequestRedirect
=
static_cast
<
RequestRedirect
>
(
redirectMode
)
;
uint32_t
cacheMode
;
rv
=
internalChannel
-
>
GetFetchCacheMode
(
&
cacheMode
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mCacheMode
=
static_cast
<
RequestCache
>
(
cacheMode
)
;
rv
=
internalChannel
-
>
GetIntegrityMetadata
(
mIntegrity
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mRequestCredentials
=
InternalRequest
:
:
MapChannelToRequestCredentials
(
channel
)
;
rv
=
httpChannel
-
>
VisitNonDefaultRequestHeaders
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIUploadChannel2
>
uploadChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
uploadChannel
)
{
MOZ_ASSERT
(
!
mUploadStream
)
;
nsCOMPtr
<
nsIInputStream
>
uploadStream
;
rv
=
uploadChannel
-
>
CloneUploadStream
(
&
mUploadStreamContentLength
getter_AddRefs
(
uploadStream
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mUploadStream
=
uploadStream
;
}
return
NS_OK
;
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
if
(
mMarkLaunchServiceWorkerEnd
)
{
mInterceptedChannel
-
>
SetLaunchServiceWorkerEnd
(
TimeStamp
:
:
Now
(
)
)
;
TimeStamp
launchStartTime
=
TimeStamp
(
)
;
mInterceptedChannel
-
>
GetLaunchServiceWorkerStart
(
&
launchStartTime
)
;
TimeStamp
launchEndTime
=
TimeStamp
(
)
;
mInterceptedChannel
-
>
GetLaunchServiceWorkerEnd
(
&
launchEndTime
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
SERVICE_WORKER_LAUNCH_TIME
launchStartTime
launchEndTime
)
;
}
mInterceptedChannel
-
>
SetDispatchFetchEventEnd
(
TimeStamp
:
:
Now
(
)
)
;
return
DispatchFetchEvent
(
aCx
aWorkerPrivate
)
;
}
nsresult
Cancel
(
)
override
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
ResumeRequest
(
mInterceptedChannel
)
;
if
(
NS_FAILED
(
mWorkerPrivate
-
>
DispatchToMainThread
(
runnable
)
)
)
{
NS_WARNING
(
"
Failed
to
resume
channel
on
FetchEventRunnable
:
:
Cancel
(
)
!
\
n
"
)
;
}
WorkerRunnable
:
:
Cancel
(
)
;
return
NS_OK
;
}
private
:
~
FetchEventRunnable
(
)
{
}
class
ResumeRequest
final
:
public
Runnable
{
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
mChannel
;
public
:
explicit
ResumeRequest
(
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
&
aChannel
)
:
Runnable
(
"
dom
:
:
FetchEventRunnable
:
:
ResumeRequest
"
)
mChannel
(
aChannel
)
{
mChannel
-
>
SetFinishResponseStart
(
TimeStamp
:
:
Now
(
)
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
TimeStamp
timeStamp
=
TimeStamp
:
:
Now
(
)
;
mChannel
-
>
SetHandleFetchEventEnd
(
timeStamp
)
;
mChannel
-
>
SetChannelResetEnd
(
timeStamp
)
;
mChannel
-
>
SaveTimeStamps
(
)
;
nsresult
rv
=
mChannel
-
>
ResetInterception
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
resume
intercepted
network
request
"
)
;
mChannel
-
>
CancelInterception
(
rv
)
;
}
return
rv
;
}
}
;
bool
DispatchFetchEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aWorkerPrivate
)
;
MOZ_ASSERT
(
aWorkerPrivate
-
>
IsServiceWorker
(
)
)
;
GlobalObject
globalObj
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
-
>
GetWrapper
(
)
)
;
RefPtr
<
InternalHeaders
>
internalHeaders
=
new
InternalHeaders
(
HeadersGuardEnum
:
:
Request
)
;
MOZ_ASSERT
(
mHeaderNames
.
Length
(
)
=
=
mHeaderValues
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mHeaderNames
.
Length
(
)
;
i
+
+
)
{
ErrorResult
result
;
internalHeaders
-
>
Set
(
mHeaderNames
[
i
]
mHeaderValues
[
i
]
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
}
ErrorResult
result
;
internalHeaders
-
>
SetGuard
(
HeadersGuardEnum
:
:
Immutable
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
RefPtr
<
InternalRequest
>
internalReq
=
new
InternalRequest
(
mSpec
mFragment
mMethod
internalHeaders
.
forget
(
)
mCacheMode
mRequestMode
mRequestRedirect
mRequestCredentials
NS_ConvertUTF8toUTF16
(
mReferrer
)
mReferrerPolicy
mContentPolicyType
mIntegrity
)
;
internalReq
-
>
SetBody
(
mUploadStream
mUploadStreamContentLength
)
;
internalReq
-
>
SetCreatedByFetchEvent
(
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
mInterceptedChannel
-
>
GetChannel
(
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsCOMPtr
<
nsICacheInfoChannel
>
cic
=
do_QueryInterface
(
channel
)
;
if
(
cic
&
&
!
cic
-
>
PreferredAlternativeDataTypes
(
)
.
IsEmpty
(
)
)
{
nsAutoCString
alternativeDataType
;
alternativeDataType
.
Assign
(
mozilla
:
:
Get
<
0
>
(
cic
-
>
PreferredAlternativeDataTypes
(
)
[
0
]
)
)
;
internalReq
-
>
SetPreferredAlternativeDataType
(
alternativeDataType
)
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
globalObj
.
GetAsSupports
(
)
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
false
;
}
RefPtr
<
Request
>
request
=
new
Request
(
global
internalReq
nullptr
)
;
MOZ_ASSERT_IF
(
internalReq
-
>
IsNavigationRequest
(
)
request
-
>
Redirect
(
)
=
=
RequestRedirect
:
:
Manual
)
;
RootedDictionary
<
FetchEventInit
>
init
(
aCx
)
;
init
.
mRequest
=
request
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
true
;
if
(
!
mClientId
.
IsEmpty
(
)
&
&
!
internalReq
-
>
IsNavigationRequest
(
)
)
{
init
.
mClientId
=
mClientId
;
}
if
(
!
mResultingClientId
.
IsEmpty
(
)
&
&
mIsNonSubresourceRequest
&
&
internalReq
-
>
Destination
(
)
!
=
RequestDestination
:
:
Report
)
{
init
.
mResultingClientId
=
mResultingClientId
;
}
init
.
mIsReload
=
mIsReload
;
RefPtr
<
FetchEvent
>
event
=
FetchEvent
:
:
Constructor
(
globalObj
NS_LITERAL_STRING
(
"
fetch
"
)
init
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
result
.
SuppressException
(
)
;
return
false
;
}
event
-
>
PostInit
(
mInterceptedChannel
mRegistration
mScriptSpec
)
;
event
-
>
SetTrusted
(
true
)
;
mInterceptedChannel
-
>
SetHandleFetchEventStart
(
TimeStamp
:
:
Now
(
)
)
;
nsresult
rv2
=
DispatchExtendableEventOnWorkerScope
(
aCx
aWorkerPrivate
-
>
GlobalScope
(
)
event
nullptr
)
;
if
(
(
NS_WARN_IF
(
NS_FAILED
(
rv2
)
)
&
&
rv2
!
=
NS_ERROR_XPC_JS_THREW_EXCEPTION
)
|
|
!
event
-
>
WaitToRespond
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
;
MOZ_ASSERT
(
!
aWorkerPrivate
-
>
UsesSystemPrincipal
(
)
"
We
don
'
t
support
system
-
principal
serviceworkers
"
)
;
if
(
event
-
>
DefaultPrevented
(
CallerType
:
:
NonSystem
)
)
{
runnable
=
new
CancelChannelRunnable
(
mInterceptedChannel
mRegistration
NS_ERROR_INTERCEPTION_FAILED
)
;
}
else
{
runnable
=
new
ResumeRequest
(
mInterceptedChannel
)
;
}
MOZ_ALWAYS_SUCCEEDS
(
mWorkerPrivate
-
>
DispatchToMainThread
(
runnable
.
forget
(
)
)
)
;
}
return
true
;
}
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
FetchEventRunnable
WorkerRunnable
nsIHttpHeaderVisitor
)
}
nsresult
ServiceWorkerPrivate
:
:
SendFetchEvent
(
nsIInterceptedChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
const
nsAString
&
aClientId
const
nsAString
&
aResultingClientId
bool
aIsReload
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
mInfo
|
|
!
swm
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
ServiceWorkerRegistrationInfo
>
registration
=
swm
-
>
GetRegistration
(
mInfo
-
>
Principal
(
)
mInfo
-
>
Scope
(
)
)
;
if
(
!
registration
)
{
nsresult
rv
=
aChannel
-
>
ResetInterception
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
resume
intercepted
network
request
"
)
;
aChannel
-
>
CancelInterception
(
rv
)
;
}
return
NS_OK
;
}
if
(
!
mInfo
-
>
HandlesFetch
(
)
)
{
nsresult
rv
=
aChannel
-
>
ResetInterception
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
resume
intercepted
network
request
"
)
;
aChannel
-
>
CancelInterception
(
rv
)
;
}
registration
-
>
MaybeScheduleTimeCheckAndUpdate
(
)
;
return
NS_OK
;
}
aChannel
-
>
SetLaunchServiceWorkerStart
(
TimeStamp
:
:
Now
(
)
)
;
aChannel
-
>
SetDispatchFetchEventStart
(
TimeStamp
:
:
Now
(
)
)
;
bool
newWorkerCreated
=
false
;
nsresult
rv
=
SpawnWorkerIfNeeded
(
FetchEvent
&
newWorkerCreated
aLoadGroup
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
newWorkerCreated
)
{
aChannel
-
>
SetLaunchServiceWorkerEnd
(
TimeStamp
:
:
Now
(
)
)
;
}
nsMainThreadPtrHandle
<
nsIInterceptedChannel
>
handle
(
new
nsMainThreadPtrHolder
<
nsIInterceptedChannel
>
(
"
nsIInterceptedChannel
"
aChannel
false
)
)
;
nsMainThreadPtrHandle
<
ServiceWorkerRegistrationInfo
>
regInfo
(
new
nsMainThreadPtrHolder
<
ServiceWorkerRegistrationInfo
>
(
"
ServiceWorkerRegistrationInfoProxy
"
registration
false
)
)
;
RefPtr
<
KeepAliveToken
>
token
=
CreateEventKeepAliveToken
(
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
aChannel
-
>
GetChannel
(
getter_AddRefs
(
channel
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
isNonSubresourceRequest
=
nsContentUtils
:
:
IsNonSubresourceRequest
(
channel
)
;
RefPtr
<
FetchEventRunnable
>
r
=
new
FetchEventRunnable
(
mWorkerPrivate
token
handle
mInfo
-
>
ScriptSpec
(
)
regInfo
aClientId
aResultingClientId
aIsReload
newWorkerCreated
isNonSubresourceRequest
)
;
rv
=
r
-
>
Init
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activating
)
{
mPendingFunctionalEvents
.
AppendElement
(
r
.
forget
(
)
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mInfo
-
>
State
(
)
=
=
ServiceWorkerState
:
:
Activated
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
SpawnWorkerIfNeeded
(
WakeUpReason
aWhy
bool
*
aNewWorkerCreated
nsILoadGroup
*
aLoadGroup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aNewWorkerCreated
)
{
*
aNewWorkerCreated
=
false
;
}
if
(
mWorkerPrivate
&
&
mWorkerPrivate
-
>
ParentStatusProtected
(
)
>
Running
)
{
TerminateWorker
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mWorkerPrivate
)
;
}
if
(
mWorkerPrivate
)
{
mWorkerPrivate
-
>
UpdateOverridenLoadGroup
(
aLoadGroup
)
;
RenewKeepAliveToken
(
aWhy
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
mSupportsArray
.
IsEmpty
(
)
)
;
if
(
NS_WARN_IF
(
!
mInfo
)
)
{
NS_WARNING
(
"
Trying
to
wake
up
a
dead
service
worker
.
"
)
;
return
NS_ERROR_FAILURE
;
}
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE
(
swm
NS_ERROR_FAILURE
)
;
RefPtr
<
ServiceWorkerRegistrationInfo
>
reg
=
swm
-
>
GetRegistration
(
mInfo
-
>
Principal
(
)
mInfo
-
>
Scope
(
)
)
;
NS_ENSURE_TRUE
(
reg
NS_ERROR_FAILURE
)
;
Unused
<
<
NS_WARN_IF
(
!
IndexedDatabaseManager
:
:
GetOrCreate
(
)
)
;
WorkerLoadInfo
info
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
info
.
mBaseURI
)
mInfo
-
>
ScriptSpec
(
)
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
info
.
mResolvedScriptURI
=
info
.
mBaseURI
;
MOZ_ASSERT
(
!
mInfo
-
>
CacheName
(
)
.
IsEmpty
(
)
)
;
info
.
mServiceWorkerCacheName
=
mInfo
-
>
CacheName
(
)
;
info
.
mServiceWorkerDescriptor
.
emplace
(
mInfo
-
>
Descriptor
(
)
)
;
info
.
mServiceWorkerRegistrationDescriptor
.
emplace
(
reg
-
>
Descriptor
(
)
)
;
info
.
mLoadGroup
=
aLoadGroup
;
info
.
mLoadFlags
=
mInfo
-
>
GetImportsLoadFlags
(
)
|
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
;
rv
=
info
.
mBaseURI
-
>
GetHost
(
info
.
mDomain
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
mInfo
-
>
Principal
(
)
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
NS_WARN_IF
(
!
uri
)
)
{
return
NS_ERROR_FAILURE
;
}
info
.
mPrincipal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
uri
mInfo
-
>
GetOriginAttributes
(
)
)
;
if
(
NS_WARN_IF
(
!
info
.
mPrincipal
)
)
{
return
NS_ERROR_FAILURE
;
}
info
.
mLoadingPrincipal
=
info
.
mPrincipal
;
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForServiceWorker
(
info
.
mPrincipal
)
;
info
.
mStorageAllowed
=
access
>
nsContentUtils
:
:
StorageAccess
:
:
ePrivateBrowsing
;
info
.
mOriginAttributes
=
mInfo
-
>
GetOriginAttributes
(
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
Unused
<
<
info
.
mPrincipal
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
csp
)
;
#
endif
info
.
mEvalAllowed
=
true
;
info
.
mReportCSPViolations
=
false
;
WorkerPrivate
:
:
OverrideLoadInfoLoadGroup
(
info
info
.
mPrincipal
)
;
rv
=
info
.
SetPrincipalOnMainThread
(
info
.
mPrincipal
info
.
mLoadGroup
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
ErrorResult
error
;
NS_ConvertUTF8toUTF16
scriptSpec
(
mInfo
-
>
ScriptSpec
(
)
)
;
mWorkerPrivate
=
WorkerPrivate
:
:
Constructor
(
jsapi
.
cx
(
)
scriptSpec
false
WorkerTypeService
VoidString
(
)
EmptyCString
(
)
&
info
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
RenewKeepAliveToken
(
aWhy
)
;
if
(
aNewWorkerCreated
)
{
*
aNewWorkerCreated
=
true
;
}
return
NS_OK
;
}
bool
ServiceWorkerPrivate
:
:
MaybeStoreISupports
(
nsISupports
*
aSupports
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mWorkerPrivate
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mSupportsArray
.
IsEmpty
(
)
)
;
return
false
;
}
MOZ_ASSERT
(
!
mSupportsArray
.
Contains
(
aSupports
)
)
;
mSupportsArray
.
AppendElement
(
aSupports
)
;
return
true
;
}
void
ServiceWorkerPrivate
:
:
RemoveISupports
(
nsISupports
*
aSupports
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSupportsArray
.
RemoveElement
(
aSupports
)
;
}
void
ServiceWorkerPrivate
:
:
TerminateWorker
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
mIdleKeepAliveToken
=
nullptr
;
if
(
mWorkerPrivate
)
{
if
(
StaticPrefs
:
:
dom_serviceWorkers_testing_enabled
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
NotifyObservers
(
nullptr
"
service
-
worker
-
shutdown
"
nullptr
)
;
}
}
Unused
<
<
NS_WARN_IF
(
!
mWorkerPrivate
-
>
Cancel
(
)
)
;
RefPtr
<
WorkerPrivate
>
workerPrivate
(
mWorkerPrivate
.
forget
(
)
)
;
mSupportsArray
.
Clear
(
)
;
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
pendingEvents
;
mPendingFunctionalEvents
.
SwapElements
(
pendingEvents
)
;
for
(
uint32_t
i
=
0
;
i
<
pendingEvents
.
Length
(
)
;
+
+
i
)
{
pendingEvents
[
i
]
-
>
Cancel
(
)
;
}
}
}
void
ServiceWorkerPrivate
:
:
NoteDeadServiceWorkerInfo
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mInfo
=
nullptr
;
TerminateWorker
(
)
;
}
namespace
{
class
UpdateStateControlRunnable
final
:
public
MainThreadWorkerControlRunnable
{
const
ServiceWorkerState
mState
;
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_DIAGNOSTIC_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
UpdateServiceWorkerState
(
mState
)
;
return
true
;
}
public
:
UpdateStateControlRunnable
(
WorkerPrivate
*
aWorkerPrivate
ServiceWorkerState
aState
)
:
MainThreadWorkerControlRunnable
(
aWorkerPrivate
)
mState
(
aState
)
{
}
}
;
}
void
ServiceWorkerPrivate
:
:
UpdateState
(
ServiceWorkerState
aState
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mWorkerPrivate
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPendingFunctionalEvents
.
IsEmpty
(
)
)
;
return
;
}
RefPtr
<
WorkerRunnable
>
r
=
new
UpdateStateControlRunnable
(
mWorkerPrivate
aState
)
;
Unused
<
<
r
-
>
Dispatch
(
)
;
if
(
aState
!
=
ServiceWorkerState
:
:
Activated
)
{
return
;
}
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
pendingEvents
;
mPendingFunctionalEvents
.
SwapElements
(
pendingEvents
)
;
for
(
uint32_t
i
=
0
;
i
<
pendingEvents
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
WorkerRunnable
>
r
=
pendingEvents
[
i
]
.
forget
(
)
;
if
(
NS_WARN_IF
(
!
r
-
>
Dispatch
(
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
pending
functional
event
!
"
)
;
}
}
}
nsresult
ServiceWorkerPrivate
:
:
GetDebugger
(
nsIWorkerDebugger
*
*
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aResult
)
;
if
(
!
mDebuggerCount
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mWorkerPrivate
)
;
nsCOMPtr
<
nsIWorkerDebugger
>
debugger
=
mWorkerPrivate
-
>
Debugger
(
)
;
debugger
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
AttachDebugger
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mDebuggerCount
)
{
nsresult
rv
=
SpawnWorkerIfNeeded
(
AttachEvent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIdleWorkerTimer
-
>
Cancel
(
)
;
}
+
+
mDebuggerCount
;
return
NS_OK
;
}
nsresult
ServiceWorkerPrivate
:
:
DetachDebugger
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mDebuggerCount
)
{
return
NS_ERROR_UNEXPECTED
;
}
-
-
mDebuggerCount
;
if
(
!
mDebuggerCount
)
{
if
(
mTokenCount
)
{
ResetIdleTimeout
(
)
;
}
else
{
TerminateWorker
(
)
;
}
}
return
NS_OK
;
}
bool
ServiceWorkerPrivate
:
:
IsIdle
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mTokenCount
=
=
0
|
|
(
mTokenCount
=
=
1
&
&
mIdleKeepAliveToken
)
;
}
namespace
{
class
ServiceWorkerPrivateTimerCallback
final
:
public
nsITimerCallback
public
nsINamed
{
public
:
typedef
void
(
ServiceWorkerPrivate
:
:
*
Method
)
(
nsITimer
*
)
;
ServiceWorkerPrivateTimerCallback
(
ServiceWorkerPrivate
*
aServiceWorkerPrivate
Method
aMethod
)
:
mServiceWorkerPrivate
(
aServiceWorkerPrivate
)
mMethod
(
aMethod
)
{
}
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
(
mServiceWorkerPrivate
-
>
*
mMethod
)
(
aTimer
)
;
mServiceWorkerPrivate
=
nullptr
;
return
NS_OK
;
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
ServiceWorkerPrivateTimerCallback
"
)
;
return
NS_OK
;
}
private
:
~
ServiceWorkerPrivateTimerCallback
(
)
=
default
;
RefPtr
<
ServiceWorkerPrivate
>
mServiceWorkerPrivate
;
Method
mMethod
;
NS_DECL_THREADSAFE_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
ServiceWorkerPrivateTimerCallback
nsITimerCallback
nsINamed
)
;
}
void
ServiceWorkerPrivate
:
:
NoteIdleWorkerCallback
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aTimer
=
=
mIdleWorkerTimer
"
Invalid
timer
!
"
)
;
mIdleKeepAliveToken
=
nullptr
;
if
(
mWorkerPrivate
)
{
uint32_t
timeout
=
Preferences
:
:
GetInt
(
"
dom
.
serviceWorkers
.
idle_extended_timeout
"
)
;
nsCOMPtr
<
nsITimerCallback
>
cb
=
new
ServiceWorkerPrivateTimerCallback
(
this
&
ServiceWorkerPrivate
:
:
TerminateWorkerCallback
)
;
DebugOnly
<
nsresult
>
rv
=
mIdleWorkerTimer
-
>
InitWithCallback
(
cb
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
void
ServiceWorkerPrivate
:
:
TerminateWorkerCallback
(
nsITimer
*
aTimer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aTimer
=
=
this
-
>
mIdleWorkerTimer
"
Invalid
timer
!
"
)
;
ServiceWorkerManager
:
:
LocalizeAndReportToAllClients
(
mInfo
-
>
Scope
(
)
"
ServiceWorkerGraceTimeoutTermination
"
nsTArray
<
nsString
>
{
NS_ConvertUTF8toUTF16
(
mInfo
-
>
Scope
(
)
)
}
)
;
TerminateWorker
(
)
;
}
void
ServiceWorkerPrivate
:
:
RenewKeepAliveToken
(
WakeUpReason
aWhy
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
if
(
!
mDebuggerCount
)
{
ResetIdleTimeout
(
)
;
}
if
(
!
mIdleKeepAliveToken
)
{
mIdleKeepAliveToken
=
new
KeepAliveToken
(
this
)
;
}
}
void
ServiceWorkerPrivate
:
:
ResetIdleTimeout
(
)
{
uint32_t
timeout
=
Preferences
:
:
GetInt
(
"
dom
.
serviceWorkers
.
idle_timeout
"
)
;
nsCOMPtr
<
nsITimerCallback
>
cb
=
new
ServiceWorkerPrivateTimerCallback
(
this
&
ServiceWorkerPrivate
:
:
NoteIdleWorkerCallback
)
;
DebugOnly
<
nsresult
>
rv
=
mIdleWorkerTimer
-
>
InitWithCallback
(
cb
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
void
ServiceWorkerPrivate
:
:
AddToken
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
+
+
mTokenCount
;
}
void
ServiceWorkerPrivate
:
:
ReleaseToken
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTokenCount
>
0
)
;
-
-
mTokenCount
;
if
(
!
mTokenCount
)
{
TerminateWorker
(
)
;
}
else
if
(
mInfo
&
&
IsIdle
(
)
)
{
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
swm
)
{
swm
-
>
WorkerIsIdle
(
mInfo
)
;
}
}
}
already_AddRefed
<
KeepAliveToken
>
ServiceWorkerPrivate
:
:
CreateEventKeepAliveToken
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mWorkerPrivate
)
;
MOZ_ASSERT
(
mIdleKeepAliveToken
)
;
RefPtr
<
KeepAliveToken
>
ref
=
new
KeepAliveToken
(
this
)
;
return
ref
.
forget
(
)
;
}
void
ServiceWorkerPrivate
:
:
SetHandlesFetch
(
bool
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_WARN_IF
(
!
mInfo
)
)
{
return
;
}
mInfo
-
>
SetHandlesFetch
(
aValue
)
;
}
}
}
