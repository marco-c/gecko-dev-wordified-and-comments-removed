#
include
"
FetchEventOpParent
.
h
"
#
include
"
mozilla
/
dom
/
FetchTypes
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
FetchEventOpProxyParent
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerControllerParent
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
Maybe
<
ParentToChildInternalResponse
>
FetchEventOpParent
:
:
OnStart
(
MovingNotNull
<
RefPtr
<
FetchEventOpProxyParent
>
>
aFetchEventOpProxyParent
)
{
Maybe
<
ParentToChildInternalResponse
>
preloadResponse
=
std
:
:
move
(
mState
.
as
<
Pending
>
(
)
.
mPreloadResponse
)
;
mState
=
AsVariant
(
Started
{
std
:
:
move
(
aFetchEventOpProxyParent
)
}
)
;
return
preloadResponse
;
}
void
FetchEventOpParent
:
:
OnFinish
(
)
{
MOZ_ASSERT
(
mState
.
is
<
Started
>
(
)
)
;
mState
=
AsVariant
(
Finished
(
)
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
FetchEventOpParent
:
:
RecvPreloadResponse
(
ParentToParentInternalResponse
&
&
aResponse
)
{
AssertIsOnBackgroundThread
(
)
;
ParentToChildInternalResponse
internalResponse
;
mState
.
match
(
[
&
internalResponse
]
(
Pending
&
aPending
)
{
MOZ_ASSERT
(
aPending
.
mPreloadResponse
.
isNothing
(
)
)
;
aPending
.
mPreloadResponse
=
Some
(
std
:
:
move
(
internalResponse
)
)
;
}
[
&
internalResponse
]
(
Started
&
aStarted
)
{
Unused
<
<
aStarted
.
mFetchEventOpProxyParent
-
>
SendPreloadResponse
(
internalResponse
)
;
}
[
]
(
const
Finished
&
)
{
}
)
;
return
IPC_OK
(
)
;
}
void
FetchEventOpParent
:
:
ActorDestroy
(
ActorDestroyReason
)
{
AssertIsOnBackgroundThread
(
)
;
}
}
}
