#
ifndef
mozilla_dom_serviceworkerop_h__
#
define
mozilla_dom_serviceworkerop_h__
#
include
<
functional
>
#
include
"
nsISupportsImpl
.
h
"
#
include
"
ServiceWorkerEvents
.
h
"
#
include
"
ServiceWorkerOpPromise
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerChild
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerOpArgs
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
namespace
mozilla
{
namespace
dom
{
class
FetchEventOpProxyChild
;
class
ServiceWorkerOp
:
public
RemoteWorkerChild
:
:
Op
{
public
:
static
already_AddRefed
<
ServiceWorkerOp
>
Create
(
const
ServiceWorkerOpArgs
&
aArgs
std
:
:
function
<
void
(
const
ServiceWorkerOpResult
&
)
>
&
&
aCallback
)
;
ServiceWorkerOp
(
const
ServiceWorkerOpArgs
&
aArgs
std
:
:
function
<
void
(
const
ServiceWorkerOpResult
&
)
>
&
&
aCallback
)
;
ServiceWorkerOp
(
const
ServiceWorkerOp
&
)
=
delete
;
ServiceWorkerOp
&
operator
=
(
const
ServiceWorkerOp
&
)
=
delete
;
ServiceWorkerOp
(
ServiceWorkerOp
&
&
)
=
default
;
ServiceWorkerOp
&
operator
=
(
ServiceWorkerOp
&
&
)
=
default
;
bool
MaybeStart
(
RemoteWorkerChild
*
aOwner
RemoteWorkerChild
:
:
State
&
aState
)
final
;
void
Cancel
(
)
final
;
protected
:
~
ServiceWorkerOp
(
)
;
bool
Started
(
)
const
;
bool
IsTerminationOp
(
)
const
;
virtual
RefPtr
<
WorkerRunnable
>
GetRunnable
(
WorkerPrivate
*
aWorkerPrivate
)
;
virtual
bool
Exec
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
=
0
;
virtual
void
RejectAll
(
nsresult
aStatus
)
;
ServiceWorkerOpArgs
mArgs
;
MozPromiseHolder
<
ServiceWorkerOpPromise
>
mPromiseHolder
;
private
:
class
ServiceWorkerOpRunnable
;
bool
mStarted
=
false
;
}
;
class
ExtendableEventOp
:
public
ServiceWorkerOp
public
ExtendableEventCallback
{
using
ServiceWorkerOp
:
:
ServiceWorkerOp
;
protected
:
~
ExtendableEventOp
(
)
=
default
;
void
FinishedWithResult
(
ExtendableEventResult
aResult
)
override
;
}
;
class
FetchEventOp
final
:
public
ExtendableEventOp
public
PromiseNativeHandler
{
using
ExtendableEventOp
:
:
ExtendableEventOp
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
void
SetActor
(
RefPtr
<
FetchEventOpProxyChild
>
aActor
)
;
void
RevokeActor
(
FetchEventOpProxyChild
*
aActor
)
;
RefPtr
<
FetchEventRespondWithPromise
>
GetRespondWithPromise
(
)
;
void
RespondWithCalledAt
(
const
nsCString
&
aRespondWithScriptSpec
uint32_t
aRespondWithLineNumber
uint32_t
aRespondWithColumnNumber
)
;
void
ReportCanceled
(
const
nsCString
&
aPreventDefaultScriptSpec
uint32_t
aPreventDefaultLineNumber
uint32_t
aPreventDefaultColumnNumber
)
;
private
:
class
AutoCancel
;
~
FetchEventOp
(
)
;
bool
Exec
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
;
void
RejectAll
(
nsresult
aStatus
)
override
;
void
FinishedWithResult
(
ExtendableEventResult
aResult
)
override
;
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
;
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
;
void
MaybeFinished
(
)
;
void
AsyncLog
(
const
nsCString
&
aMessageName
nsTArray
<
nsString
>
aParams
)
;
void
AsyncLog
(
const
nsCString
&
aScriptSpec
uint32_t
aLineNumber
uint32_t
aColumnNumber
const
nsCString
&
aMessageName
nsTArray
<
nsString
>
aParams
)
;
void
GetRequestURL
(
nsAString
&
aOutRequestURL
)
;
nsresult
DispatchFetchEvent
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
;
RefPtr
<
FetchEventOpProxyChild
>
mActor
;
MozPromiseHolder
<
FetchEventRespondWithPromise
>
mRespondWithPromiseHolder
;
Maybe
<
ExtendableEventResult
>
mResult
;
bool
mPostDispatchChecksDone
=
false
;
Maybe
<
FetchEventRespondWithClosure
>
mRespondWithClosure
;
}
;
}
}
#
endif
