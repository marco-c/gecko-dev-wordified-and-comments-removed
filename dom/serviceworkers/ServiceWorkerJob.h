#
ifndef
mozilla_dom_workers_serviceworkerjob_h
#
define
mozilla_dom_workers_serviceworkerjob_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIPrincipal
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
namespace
workers
{
class
ServiceWorkerJob
{
public
:
class
Callback
{
public
:
virtual
void
JobFinished
(
ServiceWorkerJob
*
aJob
ErrorResult
&
aStatus
)
=
0
;
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
}
;
enum
class
Type
{
Register
Update
Unregister
}
;
enum
class
State
{
Initial
Started
Finished
}
;
Type
GetType
(
)
const
;
State
GetState
(
)
const
;
bool
Canceled
(
)
const
;
bool
ResultCallbacksInvoked
(
)
const
;
bool
IsEquivalentTo
(
ServiceWorkerJob
*
aJob
)
const
;
void
AppendResultCallback
(
Callback
*
aCallback
)
;
void
StealResultCallbacksFrom
(
ServiceWorkerJob
*
aJob
)
;
void
Start
(
Callback
*
aFinalCallback
)
;
void
Cancel
(
)
;
protected
:
ServiceWorkerJob
(
Type
aType
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
const
nsACString
&
aScriptSpec
)
;
virtual
~
ServiceWorkerJob
(
)
;
void
InvokeResultCallbacks
(
ErrorResult
&
aRv
)
;
void
InvokeResultCallbacks
(
nsresult
aRv
)
;
void
Finish
(
ErrorResult
&
aRv
)
;
void
Finish
(
nsresult
aRv
)
;
virtual
void
AsyncExecute
(
)
=
0
;
const
Type
mType
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
const
nsCString
mScope
;
const
nsCString
mScriptSpec
;
private
:
RefPtr
<
Callback
>
mFinalCallback
;
nsTArray
<
RefPtr
<
Callback
>
>
mResultCallbackList
;
State
mState
;
bool
mCanceled
;
bool
mResultCallbacksInvoked
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
ServiceWorkerJob
)
}
;
}
}
}
#
endif
