#
include
"
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrarTypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsPrintfCString
.
h
"
namespace
mozilla
{
namespace
dom
{
bool
ServiceWorkerParentInterceptEnabled
(
)
{
static
Atomic
<
bool
>
sEnabled
;
static
Atomic
<
bool
>
sInitialized
;
if
(
!
sInitialized
)
{
AssertIsOnMainThread
(
)
;
sInitialized
=
true
;
sEnabled
=
Preferences
:
:
GetBool
(
"
dom
.
serviceWorkers
.
parent_intercept
"
false
)
;
}
return
sEnabled
;
}
bool
ServiceWorkerRegistrationDataIsValid
(
const
ServiceWorkerRegistrationData
&
aData
)
{
return
!
aData
.
scope
(
)
.
IsEmpty
(
)
&
&
!
aData
.
currentWorkerURL
(
)
.
IsEmpty
(
)
&
&
!
aData
.
cacheName
(
)
.
IsEmpty
(
)
;
}
namespace
{
void
CheckForSlashEscapedCharsInPath
(
nsIURI
*
aURI
const
char
*
aURLDescription
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aURI
)
;
nsCOMPtr
<
nsIURL
>
url
(
do_QueryInterface
(
aURI
)
)
;
if
(
NS_WARN_IF
(
!
url
)
)
{
aRv
.
ThrowInvalidStateError
(
"
http
:
or
https
:
URL
without
a
concept
of
path
"
)
;
return
;
}
nsAutoCString
path
;
nsresult
rv
=
url
-
>
GetFilePath
(
path
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
ThrowInvalidStateError
(
"
http
:
or
https
:
URL
without
a
concept
of
path
"
)
;
return
;
}
ToLowerCase
(
path
)
;
if
(
path
.
Find
(
"
%
2f
"
)
!
=
kNotFound
|
|
path
.
Find
(
"
%
5c
"
)
!
=
kNotFound
)
{
nsPrintfCString
err
(
"
%
s
contains
%
%
2f
or
%
%
5c
"
aURLDescription
)
;
aRv
.
ThrowTypeError
(
err
)
;
}
}
}
void
ServiceWorkerScopeAndScriptAreValid
(
const
ClientInfo
&
aClientInfo
nsIURI
*
aScopeURI
nsIURI
*
aScriptURI
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aScopeURI
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aScriptURI
)
;
auto
principalOrErr
=
aClientInfo
.
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
principalOrErr
.
isErr
(
)
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Can
'
t
make
security
decisions
about
Client
"
)
;
return
;
}
auto
hasHTTPScheme
=
[
]
(
nsIURI
*
aURI
)
-
>
bool
{
return
aURI
-
>
SchemeIs
(
"
http
"
)
|
|
aURI
-
>
SchemeIs
(
"
https
"
)
;
}
;
auto
hasMozExtScheme
=
[
]
(
nsIURI
*
aURI
)
-
>
bool
{
return
aURI
-
>
SchemeIs
(
"
moz
-
extension
"
)
;
}
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
principalOrErr
.
unwrap
(
)
;
auto
isExtension
=
!
!
BasePrincipal
:
:
Cast
(
principal
)
-
>
AddonPolicy
(
)
;
auto
hasValidURISchemes
=
!
isExtension
?
hasHTTPScheme
:
hasMozExtScheme
;
if
(
!
hasValidURISchemes
(
aScriptURI
)
)
{
auto
message
=
!
isExtension
?
"
Script
URL
'
s
scheme
is
not
'
http
'
or
'
https
'
"
_ns
:
"
Script
URL
'
s
scheme
is
not
'
moz
-
extension
'
"
_ns
;
aRv
.
ThrowTypeError
(
message
)
;
return
;
}
CheckForSlashEscapedCharsInPath
(
aScriptURI
"
script
URL
"
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
!
hasValidURISchemes
(
aScopeURI
)
)
{
auto
message
=
!
isExtension
?
"
Scope
URL
'
s
scheme
is
not
'
http
'
or
'
https
'
"
_ns
:
"
Scope
URL
'
s
scheme
is
not
'
moz
-
extension
'
"
_ns
;
aRv
.
ThrowTypeError
(
message
)
;
return
;
}
CheckForSlashEscapedCharsInPath
(
aScopeURI
"
scope
URL
"
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
nsAutoCString
ref
;
Unused
<
<
aScopeURI
-
>
GetRef
(
ref
)
;
if
(
NS_WARN_IF
(
!
ref
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowSecurityError
(
"
Non
-
empty
fragment
on
scope
URL
"
)
;
return
;
}
Unused
<
<
aScriptURI
-
>
GetRef
(
ref
)
;
if
(
NS_WARN_IF
(
!
ref
.
IsEmpty
(
)
)
)
{
aRv
.
ThrowSecurityError
(
"
Non
-
empty
fragment
on
script
URL
"
)
;
return
;
}
nsresult
rv
=
principal
-
>
CheckMayLoadWithReporting
(
aScopeURI
false
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
ThrowSecurityError
(
"
Scope
URL
is
not
same
-
origin
with
Client
"
)
;
return
;
}
rv
=
principal
-
>
CheckMayLoadWithReporting
(
aScriptURI
false
0
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
ThrowSecurityError
(
"
Script
URL
is
not
same
-
origin
with
Client
"
)
;
return
;
}
}
}
}
