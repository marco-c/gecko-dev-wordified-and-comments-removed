#
include
"
MainThreadUtils
.
h
"
#
include
"
ServiceWorkerQuotaUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
dom
/
quota
/
QuotaManagerService
.
h
"
#
include
"
nsIClearDataService
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIQuotaCallbacks
.
h
"
#
include
"
nsIQuotaRequests
.
h
"
#
include
"
nsIQuotaResults
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
using
mozilla
:
:
dom
:
:
quota
:
:
QuotaManagerService
;
namespace
mozilla
:
:
dom
{
class
QuotaUsageChecker
final
:
public
nsIQuotaCallback
public
nsIQuotaUsageCallback
public
nsIClearDataCallback
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIQUOTACALLBACK
NS_DECL_NSIQUOTAUSAGECALLBACK
NS_DECL_NSICLEARDATACALLBACK
QuotaUsageChecker
(
nsIPrincipal
*
aPrincipal
ServiceWorkerQuotaMitigationCallback
&
&
aCallback
)
;
void
Start
(
)
;
void
RunCallback
(
bool
aResult
)
;
private
:
~
QuotaUsageChecker
(
)
=
default
;
template
<
typename
T
typename
U
>
nsresult
GetResult
(
T
*
aRequest
U
&
)
;
void
CheckQuotaHeadroom
(
)
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
ServiceWorkerQuotaMitigationCallback
mCallback
;
bool
mGettingOriginUsageDone
;
bool
mGettingGroupUsageDone
;
bool
mIsChecking
;
uint64_t
mOriginUsage
;
uint64_t
mGroupUsage
;
uint64_t
mGroupLimit
;
}
;
NS_IMPL_ISUPPORTS
(
QuotaUsageChecker
nsIQuotaCallback
nsIQuotaUsageCallback
nsIClearDataCallback
)
QuotaUsageChecker
:
:
QuotaUsageChecker
(
nsIPrincipal
*
aPrincipal
ServiceWorkerQuotaMitigationCallback
&
&
aCallback
)
:
mPrincipal
(
aPrincipal
)
mCallback
(
std
:
:
move
(
aCallback
)
)
mGettingOriginUsageDone
(
false
)
mGettingGroupUsageDone
(
false
)
mIsChecking
(
false
)
mOriginUsage
(
0
)
mGroupUsage
(
0
)
mGroupLimit
(
0
)
{
}
void
QuotaUsageChecker
:
:
Start
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mIsChecking
)
{
return
;
}
mIsChecking
=
true
;
RefPtr
<
QuotaUsageChecker
>
self
=
this
;
auto
scopeExit
=
MakeScopeExit
(
[
self
]
(
)
{
self
-
>
RunCallback
(
false
)
;
}
)
;
RefPtr
<
QuotaManagerService
>
qms
=
QuotaManagerService
:
:
GetOrCreate
(
)
;
MOZ_ASSERT
(
qms
)
;
nsCOMPtr
<
nsIQuotaUsageRequest
>
usageRequest
;
if
(
NS_WARN_IF
(
NS_FAILED
(
qms
-
>
GetUsageForPrincipal
(
mPrincipal
this
getter_AddRefs
(
usageRequest
)
)
)
)
)
{
return
;
}
nsCOMPtr
<
nsIQuotaRequest
>
request
;
if
(
NS_WARN_IF
(
NS_FAILED
(
qms
-
>
Estimate
(
mPrincipal
getter_AddRefs
(
request
)
)
)
)
)
{
return
;
}
request
-
>
SetCallback
(
this
)
;
scopeExit
.
release
(
)
;
}
void
QuotaUsageChecker
:
:
RunCallback
(
bool
aResult
)
{
MOZ_ASSERT
(
mIsChecking
&
&
mCallback
)
;
if
(
!
mIsChecking
)
{
return
;
}
mIsChecking
=
false
;
mGettingOriginUsageDone
=
false
;
mGettingGroupUsageDone
=
false
;
mCallback
(
aResult
)
;
mCallback
=
nullptr
;
}
template
<
typename
T
typename
U
>
nsresult
QuotaUsageChecker
:
:
GetResult
(
T
*
aRequest
U
&
aResult
)
{
nsCOMPtr
<
nsIVariant
>
result
;
nsresult
rv
=
aRequest
-
>
GetResult
(
getter_AddRefs
(
result
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsID
*
iid
;
nsCOMPtr
<
nsISupports
>
supports
;
rv
=
result
-
>
GetAsInterface
(
&
iid
getter_AddRefs
(
supports
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
free
(
iid
)
;
aResult
=
do_QueryInterface
(
supports
)
;
return
NS_OK
;
}
void
QuotaUsageChecker
:
:
CheckQuotaHeadroom
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
const
uint64_t
groupHeadroom
=
static_cast
<
uint64_t
>
(
StaticPrefs
:
:
dom_serviceWorkers_mitigations_group_usage_headroom_kb
(
)
)
*
1024
;
const
uint64_t
groupAvailable
=
mGroupLimit
-
mGroupUsage
;
if
(
groupAvailable
>
groupHeadroom
)
{
RunCallback
(
true
)
;
return
;
}
RefPtr
<
QuotaUsageChecker
>
self
=
this
;
auto
scopeExit
=
MakeScopeExit
(
[
self
]
(
)
{
self
-
>
RunCallback
(
false
)
;
}
)
;
nsCOMPtr
<
nsIClearDataService
>
csd
=
do_GetService
(
"
mozilla
.
org
/
clear
-
data
-
service
;
1
"
)
;
MOZ_ASSERT
(
csd
)
;
if
(
(
groupAvailable
+
mOriginUsage
)
<
groupHeadroom
)
{
nsAutoCString
host
;
nsresult
rv
=
mPrincipal
-
>
GetHost
(
host
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
rv
=
csd
-
>
DeleteDataFromBaseDomain
(
host
false
nsIClearDataService
:
:
CLEAR_DOM_QUOTA
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
else
{
nsresult
rv
=
csd
-
>
DeleteDataFromPrincipal
(
mPrincipal
false
nsIClearDataService
:
:
CLEAR_DOM_QUOTA
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
scopeExit
.
release
(
)
;
}
NS_IMETHODIMP
QuotaUsageChecker
:
:
OnUsageResult
(
nsIQuotaUsageRequest
*
aUsageRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aUsageRequest
)
;
RefPtr
<
QuotaUsageChecker
>
self
=
this
;
auto
scopeExit
=
MakeScopeExit
(
[
self
]
(
)
{
self
-
>
RunCallback
(
false
)
;
}
)
;
nsresult
resultCode
;
nsresult
rv
=
aUsageRequest
-
>
GetResultCode
(
&
resultCode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
resultCode
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIQuotaOriginUsageResult
>
usageResult
;
rv
=
GetResult
(
aUsageRequest
usageResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
usageResult
)
;
rv
=
usageResult
-
>
GetUsage
(
&
mOriginUsage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
!
mGettingOriginUsageDone
)
;
mGettingOriginUsageDone
=
true
;
scopeExit
.
release
(
)
;
if
(
mGettingOriginUsageDone
&
&
mGettingGroupUsageDone
)
{
CheckQuotaHeadroom
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
QuotaUsageChecker
:
:
OnComplete
(
nsIQuotaRequest
*
aRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aRequest
)
;
RefPtr
<
QuotaUsageChecker
>
self
=
this
;
auto
scopeExit
=
MakeScopeExit
(
[
self
]
(
)
{
self
-
>
RunCallback
(
false
)
;
}
)
;
nsresult
resultCode
;
nsresult
rv
=
aRequest
-
>
GetResultCode
(
&
resultCode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
resultCode
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIQuotaEstimateResult
>
estimateResult
;
rv
=
GetResult
(
aRequest
estimateResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
estimateResult
)
;
rv
=
estimateResult
-
>
GetUsage
(
&
mGroupUsage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
estimateResult
-
>
GetLimit
(
&
mGroupLimit
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MOZ_ASSERT
(
!
mGettingGroupUsageDone
)
;
mGettingGroupUsageDone
=
true
;
scopeExit
.
release
(
)
;
if
(
mGettingOriginUsageDone
&
&
mGettingGroupUsageDone
)
{
CheckQuotaHeadroom
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
QuotaUsageChecker
:
:
OnDataDeleted
(
uint32_t
aFailedFlags
)
{
RunCallback
(
true
)
;
return
NS_OK
;
}
void
ClearQuotaUsageIfNeeded
(
nsIPrincipal
*
aPrincipal
ServiceWorkerQuotaMitigationCallback
&
&
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
RefPtr
<
QuotaUsageChecker
>
checker
=
MakeRefPtr
<
QuotaUsageChecker
>
(
aPrincipal
std
:
:
move
(
aCallback
)
)
;
checker
-
>
Start
(
)
;
}
}
