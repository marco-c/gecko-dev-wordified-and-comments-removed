#
include
"
ServiceWorkerScriptCache
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
PropertyAndElement
.
h
"
#
include
"
js
/
Utility
.
h
"
#
include
"
mozilla
/
TaskQueue
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
CacheBinding
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheStorage
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
Cache
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseWorkerProxy
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_extensions
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIStreamLoader
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
nsStringStream
.
h
"
using
mozilla
:
:
dom
:
:
cache
:
:
Cache
;
using
mozilla
:
:
dom
:
:
cache
:
:
CacheStorage
;
using
mozilla
:
:
ipc
:
:
PrincipalInfo
;
namespace
mozilla
:
:
dom
:
:
serviceWorkerScriptCache
{
namespace
{
already_AddRefed
<
CacheStorage
>
CreateCacheStorage
(
JSContext
*
aCx
nsIPrincipal
*
aPrincipal
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsIXPConnect
*
xpc
=
nsContentUtils
:
:
XPConnect
(
)
;
MOZ_ASSERT
(
xpc
"
This
should
never
be
null
!
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
sandbox
(
aCx
)
;
aRv
=
xpc
-
>
CreateSandbox
(
aCx
aPrincipal
sandbox
.
address
(
)
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
JS_IsGlobalObject
(
sandbox
)
)
;
nsCOMPtr
<
nsIGlobalObject
>
sandboxGlobalObject
=
xpc
:
:
NativeGlobal
(
sandbox
)
;
if
(
!
sandboxGlobalObject
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
CacheStorage
:
:
CreateOnMainThread
(
cache
:
:
CHROME_ONLY_NAMESPACE
sandboxGlobalObject
aPrincipal
true
aRv
)
;
}
class
CompareManager
;
class
CompareCache
;
class
CompareNetwork
final
:
public
nsIStreamLoaderObserver
public
nsIRequestObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLOADEROBSERVER
NS_DECL_NSIREQUESTOBSERVER
CompareNetwork
(
CompareManager
*
aManager
ServiceWorkerRegistrationInfo
*
aRegistration
bool
aIsMainScript
)
:
mManager
(
aManager
)
mRegistration
(
aRegistration
)
mInternalHeaders
(
new
InternalHeaders
(
)
)
mLoadFlags
(
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
)
mState
(
WaitingForInitialization
)
mNetworkResult
(
NS_OK
)
mCacheResult
(
NS_OK
)
mIsMainScript
(
aIsMainScript
)
mIsFromCache
(
false
)
{
MOZ_ASSERT
(
aManager
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
nsresult
Initialize
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aURL
Cache
*
const
aCache
)
;
void
Abort
(
)
;
void
NetworkFinish
(
nsresult
aRv
)
;
void
CacheFinish
(
nsresult
aRv
)
;
const
nsCString
&
URL
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mURL
;
}
const
nsString
&
Buffer
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mBuffer
;
}
const
ChannelInfo
&
GetChannelInfo
(
)
const
{
return
mChannelInfo
;
}
already_AddRefed
<
InternalHeaders
>
GetInternalHeaders
(
)
const
{
RefPtr
<
InternalHeaders
>
internalHeaders
=
mInternalHeaders
;
return
internalHeaders
.
forget
(
)
;
}
UniquePtr
<
PrincipalInfo
>
TakePrincipalInfo
(
)
{
return
std
:
:
move
(
mPrincipalInfo
)
;
}
bool
Succeeded
(
)
const
{
return
NS_SUCCEEDED
(
mNetworkResult
)
;
}
const
nsTArray
<
nsCString
>
&
URLList
(
)
const
{
return
mURLList
;
}
private
:
~
CompareNetwork
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mCC
)
;
}
void
Finish
(
)
;
nsresult
SetPrincipalInfo
(
nsIChannel
*
aChannel
)
;
RefPtr
<
CompareManager
>
mManager
;
RefPtr
<
CompareCache
>
mCC
;
RefPtr
<
ServiceWorkerRegistrationInfo
>
mRegistration
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsString
mBuffer
;
nsCString
mURL
;
ChannelInfo
mChannelInfo
;
RefPtr
<
InternalHeaders
>
mInternalHeaders
;
UniquePtr
<
PrincipalInfo
>
mPrincipalInfo
;
nsTArray
<
nsCString
>
mURLList
;
nsCString
mMaxScope
;
nsLoadFlags
mLoadFlags
;
enum
{
WaitingForInitialization
WaitingForBothFinished
WaitingForNetworkFinished
WaitingForCacheFinished
Finished
}
mState
;
nsresult
mNetworkResult
;
nsresult
mCacheResult
;
const
bool
mIsMainScript
;
bool
mIsFromCache
;
}
;
NS_IMPL_ISUPPORTS
(
CompareNetwork
nsIStreamLoaderObserver
nsIRequestObserver
)
class
CompareCache
final
:
public
PromiseNativeHandler
public
nsIStreamLoaderObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLOADEROBSERVER
explicit
CompareCache
(
CompareNetwork
*
aCN
)
:
mCN
(
aCN
)
mState
(
WaitingForInitialization
)
mInCache
(
false
)
{
MOZ_ASSERT
(
aCN
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
nsresult
Initialize
(
Cache
*
const
aCache
const
nsACString
&
aURL
)
;
void
Finish
(
nsresult
aStatus
bool
aInCache
)
;
void
Abort
(
)
;
virtual
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
virtual
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
const
nsString
&
Buffer
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mBuffer
;
}
bool
InCache
(
)
{
return
mInCache
;
}
private
:
~
CompareCache
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
ManageValueResult
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
RefPtr
<
CompareNetwork
>
mCN
;
nsCOMPtr
<
nsIInputStreamPump
>
mPump
;
nsCString
mURL
;
nsString
mBuffer
;
enum
{
WaitingForInitialization
WaitingForScript
Finished
}
mState
;
bool
mInCache
;
}
;
NS_IMPL_ISUPPORTS
(
CompareCache
nsIStreamLoaderObserver
)
class
CompareManager
final
:
public
PromiseNativeHandler
{
public
:
NS_DECL_ISUPPORTS
explicit
CompareManager
(
ServiceWorkerRegistrationInfo
*
aRegistration
CompareCallback
*
aCallback
)
:
mRegistration
(
aRegistration
)
mCallback
(
aCallback
)
mLoadFlags
(
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
)
mState
(
WaitingForInitialization
)
mPendingCount
(
0
)
mOnFailure
(
OnFailure
:
:
DoNothing
)
mAreScriptsEqual
(
true
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aRegistration
)
;
}
nsresult
Initialize
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aURL
const
nsAString
&
aCacheName
)
;
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
CacheStorage
*
CacheStorage_
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mCacheStorage
)
;
return
mCacheStorage
;
}
void
ComparisonFinished
(
nsresult
aStatus
bool
aIsMainScript
bool
aIsEqual
const
nsACString
&
aMaxScope
nsLoadFlags
aLoadFlags
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
=
=
Finished
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForScriptOrComparisonResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aStatus
)
)
)
{
Fail
(
aStatus
)
;
return
;
}
mAreScriptsEqual
=
mAreScriptsEqual
&
&
aIsEqual
;
if
(
aIsMainScript
)
{
mMaxScope
=
aMaxScope
;
mLoadFlags
=
aLoadFlags
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mPendingCount
>
0
)
;
if
(
-
-
mPendingCount
)
{
return
;
}
if
(
mAreScriptsEqual
)
{
MOZ_ASSERT
(
mCallback
)
;
mCallback
-
>
ComparisonResult
(
aStatus
true
mOnFailure
u
"
"
_ns
mMaxScope
mLoadFlags
)
;
Cleanup
(
)
;
return
;
}
WriteNetworkBufferToNewCache
(
)
;
}
private
:
~
CompareManager
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mCNList
.
Length
(
)
=
=
0
)
;
}
void
Fail
(
nsresult
aStatus
)
;
void
Cleanup
(
)
;
nsresult
FetchScript
(
const
nsACString
&
aURL
bool
aIsMainScript
Cache
*
const
aCache
=
nullptr
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForInitialization
|
|
mState
=
=
WaitingForScriptOrComparisonResult
)
;
RefPtr
<
CompareNetwork
>
cn
=
new
CompareNetwork
(
this
mRegistration
aIsMainScript
)
;
mCNList
.
AppendElement
(
cn
)
;
mPendingCount
+
=
1
;
nsresult
rv
=
cn
-
>
Initialize
(
mPrincipal
aURL
aCache
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
void
ManageOldCache
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForExistingOpen
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
Fail
(
rv
)
;
}
)
;
if
(
NS_WARN_IF
(
!
aValue
.
isObject
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
!
mOldCache
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
aValue
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
!
obj
)
|
|
NS_WARN_IF
(
NS_FAILED
(
UNWRAP_OBJECT
(
Cache
obj
mOldCache
)
)
)
)
{
return
;
}
Optional
<
RequestOrUTF8String
>
request
;
CacheQueryOptions
options
;
ErrorResult
error
;
RefPtr
<
Promise
>
promise
=
mOldCache
-
>
Keys
(
aCx
request
options
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
error
.
IsJSException
(
)
)
;
rv
=
error
.
StealNSResult
(
)
;
return
;
}
mState
=
WaitingForExistingKeys
;
promise
-
>
AppendNativeHandler
(
this
)
;
guard
.
release
(
)
;
}
void
ManageOldKeys
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForExistingKeys
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
Fail
(
rv
)
;
}
)
;
if
(
NS_WARN_IF
(
!
aValue
.
isObject
(
)
)
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
aValue
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
!
obj
)
)
{
return
;
}
uint32_t
len
=
0
;
if
(
!
JS
:
:
GetArrayLength
(
aCx
obj
&
len
)
)
{
return
;
}
MOZ_ASSERT
(
mPendingCount
=
=
0
)
;
mState
=
WaitingForScriptOrComparisonResult
;
bool
hasMainScript
=
false
;
AutoTArray
<
nsCString
8
>
urlList
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCx
)
;
if
(
NS_WARN_IF
(
!
JS_GetElement
(
aCx
obj
i
&
val
)
)
|
|
NS_WARN_IF
(
!
val
.
isObject
(
)
)
)
{
return
;
}
Request
*
request
;
JS
:
:
Rooted
<
JSObject
*
>
requestObj
(
aCx
&
val
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
UNWRAP_OBJECT
(
Request
&
requestObj
request
)
)
)
)
{
return
;
}
;
nsCString
url
;
request
-
>
GetUrl
(
url
)
;
if
(
!
hasMainScript
&
&
url
=
=
mURL
)
{
hasMainScript
=
true
;
}
urlList
.
AppendElement
(
std
:
:
move
(
url
)
)
;
}
if
(
!
hasMainScript
)
{
mOnFailure
=
OnFailure
:
:
Uninstall
;
}
rv
=
FetchScript
(
mURL
true
mOldCache
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
for
(
const
auto
&
url
:
urlList
)
{
if
(
mURL
=
=
url
)
{
continue
;
}
rv
=
FetchScript
(
url
false
mOldCache
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
guard
.
release
(
)
;
}
void
ManageNewCache
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForOpen
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
Fail
(
rv
)
;
}
)
;
if
(
NS_WARN_IF
(
!
aValue
.
isObject
(
)
)
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
aValue
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
!
obj
)
)
{
return
;
}
Cache
*
cache
=
nullptr
;
rv
=
UNWRAP_OBJECT
(
Cache
&
obj
cache
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
RefPtr
<
Cache
>
kungfuDeathGrip
=
cache
;
MOZ_ASSERT
(
mPendingCount
=
=
0
)
;
for
(
uint32_t
i
=
0
;
i
<
mCNList
.
Length
(
)
;
+
+
i
)
{
rv
=
WriteToCache
(
aCx
cache
mCNList
[
i
]
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
mState
=
WaitingForPut
;
guard
.
release
(
)
;
}
void
WriteNetworkBufferToNewCache
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mCNList
.
Length
(
)
!
=
0
)
;
MOZ_ASSERT
(
mCacheStorage
)
;
MOZ_ASSERT
(
mNewCacheName
.
IsEmpty
(
)
)
;
ErrorResult
result
;
result
=
serviceWorkerScriptCache
:
:
GenerateCacheName
(
mNewCacheName
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
result
.
IsErrorWithMessage
(
)
)
;
Fail
(
result
.
StealNSResult
(
)
)
;
return
;
}
RefPtr
<
Promise
>
cacheOpenPromise
=
mCacheStorage
-
>
Open
(
mNewCacheName
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
result
.
IsErrorWithMessage
(
)
)
;
Fail
(
result
.
StealNSResult
(
)
)
;
return
;
}
mState
=
WaitingForOpen
;
cacheOpenPromise
-
>
AppendNativeHandler
(
this
)
;
}
nsresult
WriteToCache
(
JSContext
*
aCx
Cache
*
aCache
CompareNetwork
*
aCN
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aCache
)
;
MOZ_ASSERT
(
aCN
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForOpen
)
;
if
(
!
aCN
-
>
Succeeded
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIInputStream
>
body
;
nsresult
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
body
)
NS_ConvertUTF16toUTF8
(
aCN
-
>
Buffer
(
)
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
SafeRefPtr
<
InternalResponse
>
ir
=
MakeSafeRefPtr
<
InternalResponse
>
(
200
"
OK
"
_ns
)
;
ir
-
>
SetBody
(
body
aCN
-
>
Buffer
(
)
.
Length
(
)
)
;
ir
-
>
SetURLList
(
aCN
-
>
URLList
(
)
)
;
ir
-
>
InitChannelInfo
(
aCN
-
>
GetChannelInfo
(
)
)
;
UniquePtr
<
PrincipalInfo
>
principalInfo
=
aCN
-
>
TakePrincipalInfo
(
)
;
if
(
principalInfo
)
{
ir
-
>
SetPrincipalInfo
(
std
:
:
move
(
principalInfo
)
)
;
}
RefPtr
<
InternalHeaders
>
internalHeaders
=
aCN
-
>
GetInternalHeaders
(
)
;
ir
-
>
Headers
(
)
-
>
Fill
(
*
(
internalHeaders
.
get
(
)
)
IgnoreErrors
(
)
)
;
RefPtr
<
Response
>
response
=
new
Response
(
aCache
-
>
GetGlobalObject
(
)
std
:
:
move
(
ir
)
nullptr
)
;
RequestOrUTF8String
request
;
request
.
SetAsUTF8String
(
)
.
ShareOrDependUpon
(
aCN
-
>
URL
(
)
)
;
ErrorResult
result
;
RefPtr
<
Promise
>
cachePromise
=
aCache
-
>
Put
(
aCx
request
*
response
result
)
;
result
.
WouldReportJSException
(
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
result
.
IsJSException
(
)
)
;
MOZ_ASSERT
(
!
result
.
IsErrorWithMessage
(
)
)
;
return
result
.
StealNSResult
(
)
;
}
mPendingCount
+
=
1
;
cachePromise
-
>
AppendNativeHandler
(
this
)
;
return
NS_OK
;
}
RefPtr
<
ServiceWorkerRegistrationInfo
>
mRegistration
;
RefPtr
<
CompareCallback
>
mCallback
;
RefPtr
<
CacheStorage
>
mCacheStorage
;
nsTArray
<
RefPtr
<
CompareNetwork
>
>
mCNList
;
nsCString
mURL
;
RefPtr
<
nsIPrincipal
>
mPrincipal
;
RefPtr
<
Cache
>
mOldCache
;
nsString
mNewCacheName
;
nsCString
mMaxScope
;
nsLoadFlags
mLoadFlags
;
enum
{
WaitingForInitialization
WaitingForExistingOpen
WaitingForExistingKeys
WaitingForScriptOrComparisonResult
WaitingForOpen
WaitingForPut
Finished
}
mState
;
uint32_t
mPendingCount
;
OnFailure
mOnFailure
;
bool
mAreScriptsEqual
;
}
;
NS_IMPL_ISUPPORTS0
(
CompareManager
)
nsresult
CompareNetwork
:
:
Initialize
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aURL
Cache
*
const
aCache
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mURL
=
aURL
;
mURLList
.
AppendElement
(
mURL
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
rv
=
NS_NewLoadGroup
(
getter_AddRefs
(
loadGroup
)
aPrincipal
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mLoadFlags
=
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
;
ServiceWorkerUpdateViaCache
uvc
=
mRegistration
-
>
GetUpdateViaCache
(
)
;
if
(
uvc
=
=
ServiceWorkerUpdateViaCache
:
:
None
|
|
(
uvc
=
=
ServiceWorkerUpdateViaCache
:
:
Imports
&
&
mIsMainScript
)
)
{
mLoadFlags
|
=
nsIRequest
:
:
VALIDATE_ALWAYS
;
}
if
(
mRegistration
-
>
IsLastUpdateCheckTimeOverOneDay
(
)
)
{
mLoadFlags
|
=
nsIRequest
:
:
LOAD_BYPASS_CACHE
;
}
uint32_t
secFlags
=
mIsMainScript
?
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
:
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT
;
nsContentPolicyType
contentPolicyType
=
mIsMainScript
?
nsIContentPolicy
:
:
TYPE_INTERNAL_SERVICE_WORKER
:
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER_IMPORT_SCRIPTS
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
mozilla
:
:
net
:
:
CookieJarSettings
:
:
Create
(
aPrincipal
)
;
if
(
!
aPrincipal
-
>
OriginAttributesRef
(
)
.
mPartitionKey
.
IsEmpty
(
)
)
{
net
:
:
CookieJarSettings
:
:
Cast
(
cookieJarSettings
)
-
>
SetPartitionKey
(
aPrincipal
-
>
OriginAttributesRef
(
)
.
mPartitionKey
)
;
}
else
{
net
:
:
CookieJarSettings
:
:
Cast
(
cookieJarSettings
)
-
>
SetPartitionKey
(
uri
false
)
;
}
rv
=
NS_NewChannel
(
getter_AddRefs
(
mChannel
)
uri
aPrincipal
secFlags
contentPolicyType
cookieJarSettings
nullptr
loadGroup
nullptr
mLoadFlags
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
aPrincipal
-
>
OriginAttributesRef
(
)
.
mPartitionKey
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
rv
=
loadInfo
-
>
SetIsInThirdPartyContext
(
true
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
mChannel
)
;
if
(
httpChannel
)
{
if
(
mIsMainScript
)
{
rv
=
httpChannel
-
>
SetRedirectionLimit
(
0
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
rv
=
httpChannel
-
>
SetRequestHeader
(
"
Service
-
Worker
"
_ns
"
script
"
_ns
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
nsCOMPtr
<
nsIStreamLoader
>
loader
;
rv
=
NS_NewStreamLoader
(
getter_AddRefs
(
loader
)
this
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
rv
=
mChannel
-
>
AsyncOpen
(
loader
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
aCache
)
{
mCC
=
new
CompareCache
(
this
)
;
rv
=
mCC
-
>
Initialize
(
aCache
aURL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Abort
(
)
;
return
rv
;
}
mState
=
WaitingForBothFinished
;
return
NS_OK
;
}
mState
=
WaitingForNetworkFinished
;
return
NS_OK
;
}
void
CompareNetwork
:
:
Finish
(
)
{
if
(
mState
=
=
Finished
)
{
return
;
}
bool
same
=
true
;
nsresult
rv
=
NS_OK
;
if
(
NS_FAILED
(
mNetworkResult
)
)
{
rv
=
mIsMainScript
?
mNetworkResult
:
NS_OK
;
same
=
true
;
}
else
if
(
mCC
&
&
NS_FAILED
(
mCacheResult
)
)
{
rv
=
mCacheResult
;
}
else
{
same
=
mCC
&
&
mCC
-
>
InCache
(
)
&
&
mCC
-
>
Buffer
(
)
.
Equals
(
mBuffer
)
;
}
mManager
-
>
ComparisonFinished
(
rv
mIsMainScript
same
mMaxScope
mLoadFlags
)
;
mCC
=
nullptr
;
}
void
CompareNetwork
:
:
NetworkFinish
(
nsresult
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForBothFinished
|
|
mState
=
=
WaitingForNetworkFinished
)
;
mNetworkResult
=
aRv
;
if
(
mState
=
=
WaitingForBothFinished
)
{
mState
=
WaitingForCacheFinished
;
return
;
}
if
(
mState
=
=
WaitingForNetworkFinished
)
{
Finish
(
)
;
return
;
}
}
void
CompareNetwork
:
:
CacheFinish
(
nsresult
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForBothFinished
|
|
mState
=
=
WaitingForCacheFinished
)
;
mCacheResult
=
aRv
;
if
(
mState
=
=
WaitingForBothFinished
)
{
mState
=
WaitingForNetworkFinished
;
return
;
}
if
(
mState
=
=
WaitingForCacheFinished
)
{
Finish
(
)
;
return
;
}
}
void
CompareNetwork
:
:
Abort
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
!
=
Finished
)
{
mState
=
Finished
;
MOZ_ASSERT
(
mChannel
)
;
mChannel
-
>
CancelWithReason
(
NS_BINDING_ABORTED
"
CompareNetwork
:
:
Abort
"
_ns
)
;
mChannel
=
nullptr
;
if
(
mCC
)
{
mCC
-
>
Abort
(
)
;
mCC
=
nullptr
;
}
}
}
NS_IMETHODIMP
CompareNetwork
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
=
=
Finished
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
MOZ_ASSERT_IF
(
mIsMainScript
channel
=
=
mChannel
)
;
mChannel
=
channel
;
MOZ_ASSERT
(
!
mChannelInfo
.
IsInitialized
(
)
)
;
mChannelInfo
.
InitFromChannel
(
mChannel
)
;
nsresult
rv
=
SetPrincipalInfo
(
mChannel
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mInternalHeaders
-
>
FillResponseHeaders
(
mChannel
)
;
nsCOMPtr
<
nsICacheInfoChannel
>
cacheChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
cacheChannel
)
{
cacheChannel
-
>
IsFromCache
(
&
mIsFromCache
)
;
}
return
NS_OK
;
}
nsresult
CompareNetwork
:
:
SetPrincipalInfo
(
nsIChannel
*
aChannel
)
{
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
!
ssm
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPrincipal
>
channelPrincipal
;
nsresult
rv
=
ssm
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
channelPrincipal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
UniquePtr
<
PrincipalInfo
>
principalInfo
=
MakeUnique
<
PrincipalInfo
>
(
)
;
rv
=
PrincipalToPrincipalInfo
(
channelPrincipal
principalInfo
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mPrincipalInfo
=
std
:
:
move
(
principalInfo
)
;
return
NS_OK
;
}
NS_IMETHODIMP
CompareNetwork
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatusCode
)
{
return
NS_OK
;
}
NS_IMETHODIMP
CompareNetwork
:
:
OnStreamComplete
(
nsIStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aLen
const
uint8_t
*
aString
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
=
=
Finished
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_ERROR_FAILURE
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
NetworkFinish
(
rv
)
;
}
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aStatus
)
)
)
{
rv
=
(
aStatus
=
=
NS_ERROR_REDIRECT_LOOP
)
?
NS_ERROR_DOM_SECURITY_ERR
:
aStatus
;
return
NS_OK
;
}
nsCOMPtr
<
nsIRequest
>
request
;
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
request
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
request
)
;
MOZ_ASSERT
(
channel
"
How
come
we
don
'
t
have
any
channel
?
"
)
;
nsCOMPtr
<
nsIURI
>
uri
;
channel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
;
bool
isExtension
=
uri
-
>
SchemeIs
(
"
moz
-
extension
"
)
;
if
(
isExtension
&
&
!
StaticPrefs
:
:
extensions_backgroundServiceWorker_enabled_AtStartup
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
isExtension
)
{
nsCOMPtr
<
nsIURI
>
channelURL
;
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
channelURL
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
channelURLSpec
;
MOZ_ALWAYS_SUCCEEDS
(
channelURL
-
>
GetSpec
(
channelURLSpec
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mURLList
.
IsEmpty
(
)
)
;
if
(
channelURLSpec
!
=
mURLList
[
0
]
)
{
mURLList
.
AppendElement
(
channelURLSpec
)
;
}
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
buffer
;
size_t
len
=
0
;
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
channel
aString
aLen
u
"
UTF
-
8
"
_ns
nullptr
buffer
len
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mBuffer
.
Adopt
(
buffer
.
release
(
)
len
)
;
rv
=
NS_OK
;
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
request
)
;
if
(
!
httpChannel
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsMainScript
"
Unexpected
ServiceWorker
main
script
redirected
"
)
;
if
(
mIsMainScript
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsIPrincipal
>
channelPrincipal
;
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
!
ssm
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsresult
rv
=
ssm
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
channelPrincipal
)
)
;
if
(
channelPrincipal
-
>
SchemeIs
(
"
moz
-
extension
"
)
)
{
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
buffer
;
size_t
len
=
0
;
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
channel
aString
aLen
u
"
UTF
-
8
"
_ns
nullptr
buffer
len
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mBuffer
.
Adopt
(
buffer
.
release
(
)
len
)
;
return
NS_OK
;
}
MOZ_DIAGNOSTIC_CRASH
(
"
ServiceWorker
imported
script
redirected
to
an
url
"
"
with
an
unexpected
scheme
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
bool
requestSucceeded
;
rv
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_OK
;
}
if
(
NS_WARN_IF
(
!
requestSucceeded
)
)
{
uint32_t
status
=
0
;
Unused
<
<
httpChannel
-
>
GetResponseStatus
(
&
status
)
;
nsAutoString
statusAsText
;
statusAsText
.
AppendInt
(
status
)
;
ServiceWorkerManager
:
:
LocalizeAndReportToAllClients
(
mRegistration
-
>
Scope
(
)
"
ServiceWorkerRegisterNetworkError
"
nsTArray
<
nsString
>
{
NS_ConvertUTF8toUTF16
(
mRegistration
-
>
Scope
(
)
)
statusAsText
NS_ConvertUTF8toUTF16
(
mURL
)
}
)
;
rv
=
NS_ERROR_FAILURE
;
return
NS_OK
;
}
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
"
Service
-
Worker
-
Allowed
"
_ns
mMaxScope
)
;
if
(
!
mIsFromCache
)
{
mRegistration
-
>
RefreshLastUpdateCheckTime
(
)
;
}
nsAutoCString
mimeType
;
rv
=
httpChannel
-
>
GetContentType
(
mimeType
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
rv
=
NS_ERROR_DOM_SECURITY_ERR
;
return
rv
;
}
if
(
mimeType
.
IsEmpty
(
)
|
|
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
NS_ConvertUTF8toUTF16
(
mimeType
)
)
)
{
ServiceWorkerManager
:
:
LocalizeAndReportToAllClients
(
mRegistration
-
>
Scope
(
)
"
ServiceWorkerRegisterMimeTypeError2
"
nsTArray
<
nsString
>
{
NS_ConvertUTF8toUTF16
(
mRegistration
-
>
Scope
(
)
)
NS_ConvertUTF8toUTF16
(
mimeType
)
NS_ConvertUTF8toUTF16
(
mURL
)
}
)
;
rv
=
NS_ERROR_DOM_SECURITY_ERR
;
return
rv
;
}
nsCOMPtr
<
nsIURI
>
channelURL
;
rv
=
httpChannel
-
>
GetURI
(
getter_AddRefs
(
channelURL
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
channelURLSpec
;
MOZ_ALWAYS_SUCCEEDS
(
channelURL
-
>
GetSpec
(
channelURLSpec
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mURLList
.
IsEmpty
(
)
)
;
if
(
channelURLSpec
!
=
mURLList
[
0
]
)
{
mURLList
.
AppendElement
(
channelURLSpec
)
;
}
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
buffer
;
size_t
len
=
0
;
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
httpChannel
aString
aLen
u
"
UTF
-
8
"
_ns
nullptr
buffer
len
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mBuffer
.
Adopt
(
buffer
.
release
(
)
len
)
;
rv
=
NS_OK
;
return
NS_OK
;
}
nsresult
CompareCache
:
:
Initialize
(
Cache
*
const
aCache
const
nsACString
&
aURL
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aCache
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForInitialization
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
RequestOrUTF8String
request
;
request
.
SetAsUTF8String
(
)
.
ShareOrDependUpon
(
aURL
)
;
ErrorResult
error
;
CacheQueryOptions
params
;
RefPtr
<
Promise
>
promise
=
aCache
-
>
Match
(
jsapi
.
cx
(
)
request
params
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
error
.
IsJSException
(
)
)
;
mState
=
Finished
;
return
error
.
StealNSResult
(
)
;
}
mState
=
WaitingForScript
;
promise
-
>
AppendNativeHandler
(
this
)
;
return
NS_OK
;
}
void
CompareCache
:
:
Finish
(
nsresult
aStatus
bool
aInCache
)
{
if
(
mState
!
=
Finished
)
{
mState
=
Finished
;
mInCache
=
aInCache
;
mCN
-
>
CacheFinish
(
aStatus
)
;
}
}
void
CompareCache
:
:
Abort
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
!
=
Finished
)
{
mState
=
Finished
;
if
(
mPump
)
{
mPump
-
>
CancelWithReason
(
NS_BINDING_ABORTED
"
CompareCache
:
:
Abort
"
_ns
)
;
mPump
=
nullptr
;
}
}
}
NS_IMETHODIMP
CompareCache
:
:
OnStreamComplete
(
nsIStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aLen
const
uint8_t
*
aString
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
=
=
Finished
)
{
return
aStatus
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
aStatus
)
)
)
{
Finish
(
aStatus
false
)
;
return
aStatus
;
}
UniquePtr
<
char16_t
[
]
JS
:
:
FreePolicy
>
buffer
;
size_t
len
=
0
;
nsresult
rv
=
ScriptLoader
:
:
ConvertToUTF16
(
nullptr
aString
aLen
u
"
UTF
-
8
"
_ns
nullptr
buffer
len
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Finish
(
rv
false
)
;
return
rv
;
}
mBuffer
.
Adopt
(
buffer
.
release
(
)
len
)
;
Finish
(
NS_OK
true
)
;
return
NS_OK
;
}
void
CompareCache
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
mState
)
{
case
Finished
:
return
;
case
WaitingForScript
:
ManageValueResult
(
aCx
aValue
)
;
return
;
default
:
MOZ_CRASH
(
"
Unacceptable
state
.
"
)
;
}
}
void
CompareCache
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
!
=
Finished
)
{
Finish
(
NS_ERROR_FAILURE
false
)
;
return
;
}
}
void
CompareCache
:
:
ManageValueResult
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aValue
.
isUndefined
(
)
)
{
Finish
(
NS_OK
false
)
;
return
;
}
MOZ_ASSERT
(
aValue
.
isObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
aValue
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
!
obj
)
)
{
Finish
(
NS_ERROR_FAILURE
false
)
;
return
;
}
Response
*
response
=
nullptr
;
nsresult
rv
=
UNWRAP_OBJECT
(
Response
&
obj
response
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Finish
(
rv
false
)
;
return
;
}
MOZ_ASSERT
(
response
-
>
Ok
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
inputStream
;
response
-
>
GetBody
(
getter_AddRefs
(
inputStream
)
)
;
MOZ_ASSERT
(
inputStream
)
;
MOZ_ASSERT
(
!
mPump
)
;
rv
=
NS_NewInputStreamPump
(
getter_AddRefs
(
mPump
)
inputStream
.
forget
(
)
0
0
false
GetMainThreadSerialEventTarget
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Finish
(
rv
false
)
;
return
;
}
nsCOMPtr
<
nsIStreamLoader
>
loader
;
rv
=
NS_NewStreamLoader
(
getter_AddRefs
(
loader
)
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Finish
(
rv
false
)
;
return
;
}
rv
=
mPump
-
>
AsyncRead
(
loader
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mPump
=
nullptr
;
Finish
(
rv
false
)
;
return
;
}
nsCOMPtr
<
nsIThreadRetargetableRequest
>
rr
=
do_QueryInterface
(
mPump
)
;
if
(
rr
)
{
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
)
;
RefPtr
<
TaskQueue
>
queue
=
TaskQueue
:
:
Create
(
sts
.
forget
(
)
"
CompareCache
STS
Delivery
Queue
"
)
;
rv
=
rr
-
>
RetargetDeliveryTo
(
queue
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mPump
=
nullptr
;
Finish
(
rv
false
)
;
return
;
}
}
}
nsresult
CompareManager
:
:
Initialize
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aURL
const
nsAString
&
aCacheName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
mPendingCount
=
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
WaitingForInitialization
)
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
Cleanup
(
)
;
}
)
;
mURL
=
aURL
;
mPrincipal
=
aPrincipal
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
ErrorResult
result
;
mCacheStorage
=
CreateCacheStorage
(
jsapi
.
cx
(
)
aPrincipal
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
result
.
IsErrorWithMessage
(
)
)
;
return
result
.
StealNSResult
(
)
;
}
if
(
aCacheName
.
IsEmpty
(
)
)
{
mState
=
WaitingForScriptOrComparisonResult
;
nsresult
rv
=
FetchScript
(
aURL
true
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
guard
.
release
(
)
;
return
NS_OK
;
}
RefPtr
<
Promise
>
promise
=
mCacheStorage
-
>
Open
(
aCacheName
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
MOZ_ASSERT
(
!
result
.
IsErrorWithMessage
(
)
)
;
return
result
.
StealNSResult
(
)
;
}
mState
=
WaitingForExistingOpen
;
promise
-
>
AppendNativeHandler
(
this
)
;
guard
.
release
(
)
;
return
NS_OK
;
}
void
CompareManager
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mCallback
)
;
switch
(
mState
)
{
case
Finished
:
return
;
case
WaitingForExistingOpen
:
ManageOldCache
(
aCx
aValue
)
;
return
;
case
WaitingForExistingKeys
:
ManageOldKeys
(
aCx
aValue
)
;
return
;
case
WaitingForOpen
:
ManageNewCache
(
aCx
aValue
)
;
return
;
case
WaitingForPut
:
MOZ_DIAGNOSTIC_ASSERT
(
mPendingCount
>
0
)
;
if
(
-
-
mPendingCount
=
=
0
)
{
mCallback
-
>
ComparisonResult
(
NS_OK
false
mOnFailure
mNewCacheName
mMaxScope
mLoadFlags
)
;
Cleanup
(
)
;
}
return
;
default
:
MOZ_DIAGNOSTIC_CRASH
(
"
Missing
case
in
CompareManager
:
:
ResolvedCallback
"
)
;
}
}
void
CompareManager
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
switch
(
mState
)
{
case
Finished
:
return
;
case
WaitingForExistingOpen
:
NS_WARNING
(
"
Could
not
open
the
existing
cache
.
"
)
;
break
;
case
WaitingForExistingKeys
:
NS_WARNING
(
"
Could
not
get
the
existing
URLs
.
"
)
;
break
;
case
WaitingForOpen
:
NS_WARNING
(
"
Could
not
open
cache
.
"
)
;
break
;
case
WaitingForPut
:
NS_WARNING
(
"
Could
not
write
to
cache
.
"
)
;
break
;
default
:
MOZ_DIAGNOSTIC_CRASH
(
"
Missing
case
in
CompareManager
:
:
RejectedCallback
"
)
;
}
Fail
(
NS_ERROR_FAILURE
)
;
}
void
CompareManager
:
:
Fail
(
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mCallback
-
>
ComparisonResult
(
aStatus
false
mOnFailure
u
"
"
_ns
"
"
_ns
mLoadFlags
)
;
Cleanup
(
)
;
}
void
CompareManager
:
:
Cleanup
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
!
=
Finished
)
{
mState
=
Finished
;
MOZ_ASSERT
(
mCallback
)
;
mCallback
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mCNList
.
Length
(
)
;
+
+
i
)
{
mCNList
[
i
]
-
>
Abort
(
)
;
}
mCNList
.
Clear
(
)
;
}
}
}
nsresult
PurgeCache
(
nsIPrincipal
*
aPrincipal
const
nsAString
&
aCacheName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPrincipal
)
;
if
(
aCacheName
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
ErrorResult
rv
;
RefPtr
<
CacheStorage
>
cacheStorage
=
CreateCacheStorage
(
jsapi
.
cx
(
)
aPrincipal
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
RefPtr
<
Promise
>
promise
=
cacheStorage
-
>
Delete
(
aCacheName
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
MOZ_ALWAYS_TRUE
(
promise
-
>
SetAnyPromiseIsHandled
(
)
)
;
return
NS_OK
;
}
nsresult
GenerateCacheName
(
nsAString
&
aName
)
{
nsresult
rv
;
nsCOMPtr
<
nsIUUIDGenerator
>
uuidGenerator
=
do_GetService
(
"
mozilla
.
org
/
uuid
-
generator
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsID
id
;
rv
=
uuidGenerator
-
>
GenerateUUIDInPlace
(
&
id
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
char
chars
[
NSID_LENGTH
]
;
id
.
ToProvidedString
(
chars
)
;
aName
.
AssignASCII
(
chars
NSID_LENGTH
-
1
)
;
return
NS_OK
;
}
nsresult
Compare
(
ServiceWorkerRegistrationInfo
*
aRegistration
nsIPrincipal
*
aPrincipal
const
nsAString
&
aCacheName
const
nsACString
&
aURL
CompareCallback
*
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aRegistration
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
!
aURL
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aCallback
)
;
RefPtr
<
CompareManager
>
cm
=
new
CompareManager
(
aRegistration
aCallback
)
;
nsresult
rv
=
cm
-
>
Initialize
(
aPrincipal
aURL
aCacheName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
}
