#
ifndef
mozilla_dom_serviceworkershutdownblocker_h__
#
define
mozilla_dom_serviceworkershutdownblocker_h__
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
ServiceWorkerShutdownState
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ServiceWorkerShutdownBlocker
final
:
public
nsIAsyncShutdownBlocker
{
public
:
using
Progress
=
ServiceWorkerShutdownState
:
:
Progress
;
static
const
uint32_t
kInvalidShutdownStateId
=
0
;
NS_DECL_ISUPPORTS
NS_DECL_NSIASYNCSHUTDOWNBLOCKER
static
already_AddRefed
<
ServiceWorkerShutdownBlocker
>
CreateAndRegisterOn
(
nsIAsyncShutdownClient
*
aShutdownBarrier
)
;
void
WaitOnPromise
(
GenericNonExclusivePromise
*
aPromise
uint32_t
aShutdownStateId
)
;
void
StopAcceptingPromises
(
)
;
uint32_t
CreateShutdownState
(
)
;
void
ReportShutdownProgress
(
uint32_t
aShutdownStateId
Progress
aProgress
)
;
private
:
ServiceWorkerShutdownBlocker
(
)
;
~
ServiceWorkerShutdownBlocker
(
)
;
void
MaybeUnblockShutdown
(
)
;
uint32_t
PromiseSettled
(
)
;
bool
IsAcceptingPromises
(
)
const
;
uint32_t
GetPendingPromises
(
)
const
;
struct
AcceptingPromises
{
uint32_t
mPendingPromises
=
0
;
}
;
struct
NotAcceptingPromises
{
explicit
NotAcceptingPromises
(
AcceptingPromises
aPreviousState
)
;
uint32_t
mPendingPromises
=
0
;
}
;
Variant
<
AcceptingPromises
NotAcceptingPromises
>
mState
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
mShutdownClient
;
HashMap
<
uint32_t
ServiceWorkerShutdownState
>
mShutdownStates
;
}
;
}
}
#
endif
