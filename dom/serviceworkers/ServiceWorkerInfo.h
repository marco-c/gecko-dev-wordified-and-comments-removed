#
ifndef
mozilla_dom_serviceworkerinfo_h
#
define
mozilla_dom_serviceworkerinfo_h
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerBinding
.
h
"
#
include
"
mozilla
/
dom
/
workers
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
nsIServiceWorkerManager
.
h
"
namespace
mozilla
{
namespace
dom
{
class
ServiceWorker
;
class
ServiceWorkerPrivate
;
class
ServiceWorkerInfo
final
:
public
nsIServiceWorkerInfo
{
private
:
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
ServiceWorkerDescriptor
mDescriptor
;
const
nsCString
mScriptSpec
;
const
nsString
mCacheName
;
OriginAttributes
mOriginAttributes
;
const
nsLoadFlags
mImportsLoadFlags
;
PRTime
mCreationTime
;
TimeStamp
mCreationTimeStamp
;
PRTime
mInstalledTime
;
PRTime
mActivatedTime
;
PRTime
mRedundantTime
;
AutoTArray
<
ServiceWorker
*
1
>
mInstances
;
RefPtr
<
ServiceWorkerPrivate
>
mServiceWorkerPrivate
;
bool
mSkipWaitingFlag
;
enum
{
Unknown
Enabled
Disabled
}
mHandlesFetch
;
~
ServiceWorkerInfo
(
)
;
uint64_t
GetNextID
(
)
const
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISERVICEWORKERINFO
class
ServiceWorkerPrivate
*
WorkerPrivate
(
)
const
{
MOZ_ASSERT
(
mServiceWorkerPrivate
)
;
return
mServiceWorkerPrivate
;
}
nsIPrincipal
*
Principal
(
)
const
{
return
mPrincipal
;
}
const
nsCString
&
ScriptSpec
(
)
const
{
return
mScriptSpec
;
}
const
nsCString
&
Scope
(
)
const
{
return
mDescriptor
.
Scope
(
)
;
}
bool
SkipWaitingFlag
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mSkipWaitingFlag
;
}
void
SetSkipWaitingFlag
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mSkipWaitingFlag
=
true
;
}
ServiceWorkerInfo
(
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
const
nsACString
&
aScriptSpec
const
nsAString
&
aCacheName
nsLoadFlags
aLoadFlags
)
;
ServiceWorkerState
State
(
)
const
{
return
mDescriptor
.
State
(
)
;
}
const
OriginAttributes
&
GetOriginAttributes
(
)
const
{
return
mOriginAttributes
;
}
const
nsString
&
CacheName
(
)
const
{
return
mCacheName
;
}
nsLoadFlags
GetImportsLoadFlags
(
)
const
{
return
mImportsLoadFlags
;
}
uint64_t
ID
(
)
const
{
return
mDescriptor
.
Id
(
)
;
}
const
ServiceWorkerDescriptor
&
Descriptor
(
)
const
{
return
mDescriptor
;
}
void
UpdateState
(
ServiceWorkerState
aState
)
;
void
SetActivateStateUncheckedWithoutEvent
(
ServiceWorkerState
aState
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDescriptor
.
SetState
(
aState
)
;
}
void
SetHandlesFetch
(
bool
aHandlesFetch
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mHandlesFetch
=
=
Unknown
)
;
mHandlesFetch
=
aHandlesFetch
?
Enabled
:
Disabled
;
}
bool
HandlesFetch
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mHandlesFetch
!
=
Unknown
)
;
return
mHandlesFetch
!
=
Disabled
;
}
void
AppendWorker
(
ServiceWorker
*
aWorker
)
;
void
RemoveWorker
(
ServiceWorker
*
aWorker
)
;
already_AddRefed
<
ServiceWorker
>
GetOrCreateInstance
(
nsPIDOMWindowInner
*
aWindow
)
;
void
UpdateInstalledTime
(
)
;
void
UpdateActivatedTime
(
)
;
void
UpdateRedundantTime
(
)
;
int64_t
GetInstalledTime
(
)
const
{
return
mInstalledTime
;
}
void
SetInstalledTime
(
const
int64_t
aTime
)
{
if
(
aTime
=
=
0
)
{
return
;
}
mInstalledTime
=
aTime
;
}
int64_t
GetActivatedTime
(
)
const
{
return
mActivatedTime
;
}
void
SetActivatedTime
(
const
int64_t
aTime
)
{
if
(
aTime
=
=
0
)
{
return
;
}
mActivatedTime
=
aTime
;
}
}
;
}
}
#
endif
