#
include
"
ServiceWorkerJob
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
:
:
dom
{
ServiceWorkerJob
:
:
Type
ServiceWorkerJob
:
:
GetType
(
)
const
{
return
mType
;
}
ServiceWorkerJob
:
:
State
ServiceWorkerJob
:
:
GetState
(
)
const
{
return
mState
;
}
bool
ServiceWorkerJob
:
:
Canceled
(
)
const
{
return
mCanceled
;
}
bool
ServiceWorkerJob
:
:
ResultCallbacksInvoked
(
)
const
{
return
mResultCallbacksInvoked
;
}
bool
ServiceWorkerJob
:
:
IsEquivalentTo
(
ServiceWorkerJob
*
aJob
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aJob
)
;
return
mType
=
=
aJob
-
>
mType
&
&
mScope
.
Equals
(
aJob
-
>
mScope
)
&
&
mScriptSpec
.
Equals
(
aJob
-
>
mScriptSpec
)
&
&
mPrincipal
-
>
Equals
(
aJob
-
>
mPrincipal
)
;
}
void
ServiceWorkerJob
:
:
AppendResultCallback
(
Callback
*
aCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
!
=
State
:
:
Finished
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aCallback
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mFinalCallback
!
=
aCallback
)
;
MOZ_ASSERT
(
!
mResultCallbackList
.
Contains
(
aCallback
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mResultCallbacksInvoked
)
;
mResultCallbackList
.
AppendElement
(
aCallback
)
;
}
void
ServiceWorkerJob
:
:
StealResultCallbacksFrom
(
ServiceWorkerJob
*
aJob
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aJob
)
;
MOZ_ASSERT
(
aJob
-
>
mState
=
=
State
:
:
Initial
)
;
nsTArray
<
RefPtr
<
Callback
>
>
callbackList
=
std
:
:
move
(
aJob
-
>
mResultCallbackList
)
;
for
(
RefPtr
<
Callback
>
&
callback
:
callbackList
)
{
AppendResultCallback
(
callback
)
;
}
}
void
ServiceWorkerJob
:
:
Start
(
Callback
*
aFinalCallback
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mCanceled
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFinalCallback
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mFinalCallback
)
;
MOZ_ASSERT
(
!
mResultCallbackList
.
Contains
(
aFinalCallback
)
)
;
mFinalCallback
=
aFinalCallback
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
State
:
:
Initial
)
;
mState
=
State
:
:
Started
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
ServiceWorkerJob
:
:
AsyncExecute
"
this
&
ServiceWorkerJob
:
:
AsyncExecute
)
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
!
swm
)
{
return
;
}
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
)
)
;
}
void
ServiceWorkerJob
:
:
Cancel
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mCanceled
)
;
mCanceled
=
true
;
if
(
GetState
(
)
!
=
State
:
:
Started
)
{
MOZ_ASSERT
(
GetState
(
)
=
=
State
:
:
Initial
)
;
ErrorResult
error
(
NS_ERROR_DOM_ABORT_ERR
)
;
InvokeResultCallbacks
(
error
)
;
error
.
SuppressException
(
)
;
}
}
ServiceWorkerJob
:
:
ServiceWorkerJob
(
Type
aType
nsIPrincipal
*
aPrincipal
const
nsACString
&
aScope
nsCString
aScriptSpec
)
:
mType
(
aType
)
mPrincipal
(
aPrincipal
)
mScope
(
aScope
)
mScriptSpec
(
std
:
:
move
(
aScriptSpec
)
)
mState
(
State
:
:
Initial
)
mCanceled
(
false
)
mResultCallbacksInvoked
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPrincipal
)
;
MOZ_ASSERT
(
!
mScope
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
(
mType
=
=
Type
:
:
Unregister
)
=
=
mScriptSpec
.
IsEmpty
(
)
)
;
}
ServiceWorkerJob
:
:
~
ServiceWorkerJob
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mState
!
=
State
:
:
Started
)
;
MOZ_ASSERT_IF
(
mState
=
=
State
:
:
Finished
mResultCallbacksInvoked
)
;
}
void
ServiceWorkerJob
:
:
InvokeResultCallbacks
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
!
=
State
:
:
Finished
)
;
MOZ_DIAGNOSTIC_ASSERT_IF
(
mState
=
=
State
:
:
Initial
Canceled
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mResultCallbacksInvoked
)
;
mResultCallbacksInvoked
=
true
;
nsTArray
<
RefPtr
<
Callback
>
>
callbackList
=
std
:
:
move
(
mResultCallbackList
)
;
for
(
RefPtr
<
Callback
>
&
callback
:
callbackList
)
{
ErrorResult
rv
;
aRv
.
CloneTo
(
rv
)
;
if
(
GetState
(
)
=
=
State
:
:
Started
)
{
callback
-
>
JobFinished
(
this
rv
)
;
}
else
{
callback
-
>
JobDiscarded
(
rv
)
;
}
rv
.
SuppressException
(
)
;
}
}
void
ServiceWorkerJob
:
:
InvokeResultCallbacks
(
nsresult
aRv
)
{
ErrorResult
converted
(
aRv
)
;
InvokeResultCallbacks
(
converted
)
;
}
void
ServiceWorkerJob
:
:
Finish
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mState
!
=
State
:
:
Started
)
{
return
;
}
if
(
aRv
.
Failed
(
)
&
&
!
aRv
.
ErrorCodeIs
(
NS_ERROR_DOM_SECURITY_ERR
)
&
&
!
aRv
.
ErrorCodeIs
(
NS_ERROR_INTERNAL_ERRORRESULT_TYPEERROR
)
&
&
!
aRv
.
ErrorCodeIs
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
)
{
aRv
.
SuppressException
(
)
;
ErrorResult
&
rv
=
aRv
;
rv
.
ThrowTypeError
<
MSG_SW_INSTALL_ERROR
>
(
mScriptSpec
mScope
)
;
}
RefPtr
<
ServiceWorkerJob
>
kungFuDeathGrip
=
this
;
if
(
!
mResultCallbacksInvoked
)
{
InvokeResultCallbacks
(
aRv
)
;
}
mState
=
State
:
:
Finished
;
MOZ_DIAGNOSTIC_ASSERT
(
mFinalCallback
)
;
if
(
mFinalCallback
)
{
mFinalCallback
-
>
JobFinished
(
this
aRv
)
;
mFinalCallback
=
nullptr
;
}
aRv
.
SuppressException
(
)
;
NS_ReleaseOnMainThread
(
"
ServiceWorkerJobProxyRunnable
"
kungFuDeathGrip
.
forget
(
)
true
)
;
}
void
ServiceWorkerJob
:
:
Finish
(
nsresult
aRv
)
{
ErrorResult
converted
(
aRv
)
;
Finish
(
converted
)
;
}
}
