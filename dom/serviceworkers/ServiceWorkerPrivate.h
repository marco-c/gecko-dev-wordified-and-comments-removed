#
ifndef
mozilla_dom_serviceworkerprivate_h
#
define
mozilla_dom_serviceworkerprivate_h
#
include
<
functional
>
#
include
<
type_traits
>
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
FetchService
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerController
.
h
"
#
include
"
mozilla
/
dom
/
RemoteWorkerTypes
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerOpArgs
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
#
define
NOTIFICATION_CLICK_EVENT_NAME
u
"
notificationclick
"
#
define
NOTIFICATION_CLOSE_EVENT_NAME
u
"
notificationclose
"
class
nsIInterceptedChannel
;
class
nsIWorkerDebugger
;
namespace
mozilla
{
template
<
typename
T
>
class
Maybe
;
class
JSObjectHolder
;
namespace
dom
{
class
ClientInfoAndState
;
class
RemoteWorkerControllerChild
;
class
ServiceWorkerCloneData
;
class
ServiceWorkerInfo
;
class
ServiceWorkerPrivate
;
class
ServiceWorkerRegistrationInfo
;
namespace
ipc
{
class
StructuredCloneData
;
}
class
LifeCycleEventCallback
:
public
Runnable
{
public
:
LifeCycleEventCallback
(
)
:
Runnable
(
"
dom
:
:
LifeCycleEventCallback
"
)
{
}
virtual
void
SetResult
(
bool
aResult
)
=
0
;
}
;
class
KeepAliveToken
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveToken
(
ServiceWorkerPrivate
*
aPrivate
)
;
private
:
~
KeepAliveToken
(
)
;
RefPtr
<
ServiceWorkerPrivate
>
mPrivate
;
}
;
class
ServiceWorkerPrivate
final
:
public
RemoteWorkerObserver
{
friend
class
KeepAliveToken
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
ServiceWorkerPrivate
override
)
;
using
PromiseExtensionWorkerHasListener
=
MozPromise
<
bool
nsresult
false
>
;
public
:
explicit
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
;
nsresult
SendMessageEvent
(
RefPtr
<
ServiceWorkerCloneData
>
&
&
aData
const
ClientInfoAndState
&
aClientInfoAndState
)
;
nsresult
CheckScriptEvaluation
(
RefPtr
<
LifeCycleEventCallback
>
aCallback
)
;
nsresult
SendLifeCycleEvent
(
const
nsAString
&
aEventType
RefPtr
<
LifeCycleEventCallback
>
aCallback
)
;
nsresult
SendPushEvent
(
const
nsAString
&
aMessageId
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
RefPtr
<
ServiceWorkerRegistrationInfo
>
aRegistration
)
;
nsresult
SendPushSubscriptionChangeEvent
(
)
;
nsresult
SendNotificationEvent
(
const
nsAString
&
aEventName
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
;
nsresult
SendFetchEvent
(
nsCOMPtr
<
nsIInterceptedChannel
>
aChannel
nsILoadGroup
*
aLoadGroup
const
nsAString
&
aClientId
const
nsAString
&
aResultingClientId
)
;
Result
<
RefPtr
<
PromiseExtensionWorkerHasListener
>
nsresult
>
WakeForExtensionAPIEvent
(
const
nsAString
&
aExtensionAPINamespace
const
nsAString
&
aEXtensionAPIEventName
)
;
void
TerminateWorker
(
)
;
void
NoteDeadServiceWorkerInfo
(
)
;
void
NoteStoppedControllingDocuments
(
)
;
void
UpdateState
(
ServiceWorkerState
aState
)
;
nsresult
GetDebugger
(
nsIWorkerDebugger
*
*
aResult
)
;
nsresult
AttachDebugger
(
)
;
nsresult
DetachDebugger
(
)
;
bool
IsIdle
(
)
const
;
RefPtr
<
GenericPromise
>
GetIdlePromise
(
)
;
void
SetHandlesFetch
(
bool
aValue
)
;
RefPtr
<
GenericPromise
>
SetSkipWaitingFlag
(
)
;
static
void
RunningShutdown
(
)
{
UpdateRunning
(
0
0
)
;
MOZ_ASSERT
(
sRunningServiceWorkers
=
=
0
)
;
MOZ_ASSERT
(
sRunningServiceWorkersFetch
=
=
0
)
;
}
static
void
UpdateRunning
(
int32_t
aDelta
int32_t
aFetchDelta
)
;
private
:
void
NoteIdleWorkerCallback
(
nsITimer
*
aTimer
)
;
void
TerminateWorkerCallback
(
nsITimer
*
aTimer
)
;
void
RenewKeepAliveToken
(
)
;
void
ResetIdleTimeout
(
)
;
void
AddToken
(
)
;
void
ReleaseToken
(
)
;
already_AddRefed
<
KeepAliveToken
>
CreateEventKeepAliveToken
(
)
;
nsresult
SpawnWorkerIfNeeded
(
)
;
~
ServiceWorkerPrivate
(
)
;
nsresult
Initialize
(
)
;
void
CreationFailed
(
)
override
;
void
CreationSucceeded
(
)
override
;
void
ErrorReceived
(
const
ErrorValue
&
aError
)
override
;
void
LockNotified
(
bool
aCreated
)
final
{
}
void
WebTransportNotified
(
bool
aCreated
)
final
{
}
void
Terminated
(
)
override
;
void
RefreshRemoteWorkerData
(
const
RefPtr
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
)
;
nsresult
SendPushEventInternal
(
RefPtr
<
ServiceWorkerRegistrationInfo
>
&
&
aRegistration
ServiceWorkerPushEventOpArgs
&
&
aArgs
)
;
RefPtr
<
FetchServicePromises
>
SetupNavigationPreload
(
nsCOMPtr
<
nsIInterceptedChannel
>
&
aChannel
const
RefPtr
<
ServiceWorkerRegistrationInfo
>
&
aRegistration
)
;
nsresult
SendFetchEventInternal
(
RefPtr
<
ServiceWorkerRegistrationInfo
>
&
&
aRegistration
ParentToParentServiceWorkerFetchEventOpArgs
&
&
aArgs
nsCOMPtr
<
nsIInterceptedChannel
>
&
&
aChannel
RefPtr
<
FetchServicePromises
>
&
&
aPreloadResponseReadyPromises
)
;
void
Shutdown
(
)
;
RefPtr
<
GenericNonExclusivePromise
>
ShutdownInternal
(
uint32_t
aShutdownStateId
)
;
nsresult
ExecServiceWorkerOp
(
ServiceWorkerOpArgs
&
&
aArgs
std
:
:
function
<
void
(
ServiceWorkerOpResult
&
&
)
>
&
&
aSuccessCallback
std
:
:
function
<
void
(
)
>
&
&
aFailureCallback
=
[
]
{
}
)
;
class
PendingFunctionalEvent
{
public
:
PendingFunctionalEvent
(
ServiceWorkerPrivate
*
aOwner
RefPtr
<
ServiceWorkerRegistrationInfo
>
&
&
aRegistration
)
;
virtual
~
PendingFunctionalEvent
(
)
;
virtual
nsresult
Send
(
)
=
0
;
protected
:
ServiceWorkerPrivate
*
const
MOZ_NON_OWNING_REF
mOwner
;
RefPtr
<
ServiceWorkerRegistrationInfo
>
mRegistration
;
}
;
class
PendingPushEvent
final
:
public
PendingFunctionalEvent
{
public
:
PendingPushEvent
(
ServiceWorkerPrivate
*
aOwner
RefPtr
<
ServiceWorkerRegistrationInfo
>
&
&
aRegistration
ServiceWorkerPushEventOpArgs
&
&
aArgs
)
;
nsresult
Send
(
)
override
;
private
:
ServiceWorkerPushEventOpArgs
mArgs
;
}
;
class
PendingFetchEvent
final
:
public
PendingFunctionalEvent
{
public
:
PendingFetchEvent
(
ServiceWorkerPrivate
*
aOwner
RefPtr
<
ServiceWorkerRegistrationInfo
>
&
&
aRegistration
ParentToParentServiceWorkerFetchEventOpArgs
&
&
aArgs
nsCOMPtr
<
nsIInterceptedChannel
>
&
&
aChannel
RefPtr
<
FetchServicePromises
>
&
&
aPreloadResponseReadyPromises
)
;
nsresult
Send
(
)
override
;
~
PendingFetchEvent
(
)
;
private
:
ParentToParentServiceWorkerFetchEventOpArgs
mArgs
;
nsCOMPtr
<
nsIInterceptedChannel
>
mChannel
;
RefPtr
<
FetchServicePromises
>
mPreloadResponseReadyPromises
;
}
;
nsTArray
<
UniquePtr
<
PendingFunctionalEvent
>
>
mPendingFunctionalEvents
;
class
RAIIActorPtrHolder
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
RAIIActorPtrHolder
)
explicit
RAIIActorPtrHolder
(
already_AddRefed
<
RemoteWorkerControllerChild
>
aActor
)
;
RAIIActorPtrHolder
(
const
RAIIActorPtrHolder
&
aOther
)
=
delete
;
RAIIActorPtrHolder
&
operator
=
(
const
RAIIActorPtrHolder
&
aOther
)
=
delete
;
RAIIActorPtrHolder
(
RAIIActorPtrHolder
&
&
aOther
)
=
delete
;
RAIIActorPtrHolder
&
operator
=
(
RAIIActorPtrHolder
&
&
aOther
)
=
delete
;
RemoteWorkerControllerChild
*
operator
-
>
(
)
const
MOZ_NO_ADDREF_RELEASE_ON_RETURN
;
RemoteWorkerControllerChild
*
get
(
)
const
;
RefPtr
<
GenericPromise
>
OnDestructor
(
)
;
private
:
~
RAIIActorPtrHolder
(
)
;
MozPromiseHolder
<
GenericPromise
>
mDestructorPromiseHolder
;
const
RefPtr
<
RemoteWorkerControllerChild
>
mActor
;
}
;
RefPtr
<
RAIIActorPtrHolder
>
mControllerChild
;
RemoteWorkerData
mRemoteWorkerData
;
TimeStamp
mServiceWorkerLaunchTimeStart
;
static
uint32_t
sRunningServiceWorkers
;
static
uint32_t
sRunningServiceWorkersFetch
;
static
uint32_t
sRunningServiceWorkersMax
;
static
uint32_t
sRunningServiceWorkersFetchMax
;
enum
{
Unknown
Enabled
Disabled
}
mHandlesFetch
{
Unknown
}
;
ServiceWorkerInfo
*
MOZ_NON_OWNING_REF
mInfo
;
nsCOMPtr
<
nsITimer
>
mIdleWorkerTimer
;
RefPtr
<
KeepAliveToken
>
mIdleKeepAliveToken
;
uint64_t
mDebuggerCount
;
uint64_t
mTokenCount
;
MozPromiseHolder
<
GenericPromise
>
mIdlePromiseHolder
;
#
ifdef
DEBUG
bool
mIdlePromiseObtained
=
false
;
#
endif
}
;
}
}
#
endif
