#
ifndef
mozilla_dom_serviceworkerprivate_h
#
define
mozilla_dom_serviceworkerprivate_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
define
NOTIFICATION_CLICK_EVENT_NAME
"
notificationclick
"
#
define
NOTIFICATION_CLOSE_EVENT_NAME
"
notificationclose
"
class
nsIInterceptedChannel
;
class
nsIWorkerDebugger
;
namespace
mozilla
{
class
JSObjectHolder
;
namespace
dom
{
class
ClientInfoAndState
;
class
ServiceWorkerCloneData
;
class
ServiceWorkerInfo
;
class
ServiceWorkerPrivate
;
class
ServiceWorkerPrivateImpl
;
class
ServiceWorkerRegistrationInfo
;
namespace
ipc
{
class
StructuredCloneData
;
}
class
LifeCycleEventCallback
:
public
Runnable
{
public
:
LifeCycleEventCallback
(
)
:
Runnable
(
"
dom
:
:
LifeCycleEventCallback
"
)
{
}
virtual
void
SetResult
(
bool
aResult
)
=
0
;
}
;
class
KeepAliveToken
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
explicit
KeepAliveToken
(
ServiceWorkerPrivate
*
aPrivate
)
;
private
:
~
KeepAliveToken
(
)
;
RefPtr
<
ServiceWorkerPrivate
>
mPrivate
;
}
;
class
ServiceWorkerPrivate
final
{
friend
class
KeepAliveToken
;
friend
class
ServiceWorkerPrivateImpl
;
public
:
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
)
;
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
ServiceWorkerPrivate
)
typedef
mozilla
:
:
FalseType
HasThreadSafeRefCnt
;
protected
:
nsCycleCollectingAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
public
:
class
Inner
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
nsresult
SendMessageEvent
(
RefPtr
<
ServiceWorkerCloneData
>
&
&
aData
const
ClientInfoAndState
&
aClientInfoAndState
)
=
0
;
virtual
nsresult
CheckScriptEvaluation
(
RefPtr
<
LifeCycleEventCallback
>
aScriptEvaluationCallback
)
=
0
;
virtual
nsresult
SendLifeCycleEvent
(
const
nsAString
&
aEventName
RefPtr
<
LifeCycleEventCallback
>
aCallback
)
=
0
;
virtual
nsresult
SendPushEvent
(
RefPtr
<
ServiceWorkerRegistrationInfo
>
aRegistration
const
nsAString
&
aMessageId
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
)
=
0
;
virtual
nsresult
SendPushSubscriptionChangeEvent
(
)
=
0
;
virtual
nsresult
SendNotificationEvent
(
const
nsAString
&
aEventName
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
uint32_t
aDisableOpenClickDelay
)
=
0
;
virtual
nsresult
SendFetchEvent
(
RefPtr
<
ServiceWorkerRegistrationInfo
>
aRegistration
nsCOMPtr
<
nsIInterceptedChannel
>
aChannel
const
nsAString
&
aClientId
const
nsAString
&
aResultingClientId
)
=
0
;
virtual
nsresult
SpawnWorkerIfNeeded
(
)
=
0
;
virtual
void
TerminateWorker
(
)
=
0
;
virtual
void
UpdateState
(
ServiceWorkerState
aState
)
=
0
;
virtual
void
NoteDeadOuter
(
)
=
0
;
virtual
bool
WorkerIsDead
(
)
const
=
0
;
}
;
explicit
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
;
nsresult
SendMessageEvent
(
RefPtr
<
ServiceWorkerCloneData
>
&
&
aData
const
ClientInfoAndState
&
aClientInfoAndState
)
;
nsresult
CheckScriptEvaluation
(
LifeCycleEventCallback
*
aCallback
)
;
nsresult
SendLifeCycleEvent
(
const
nsAString
&
aEventType
LifeCycleEventCallback
*
aCallback
)
;
nsresult
SendPushEvent
(
const
nsAString
&
aMessageId
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
nsresult
SendPushSubscriptionChangeEvent
(
)
;
nsresult
SendNotificationEvent
(
const
nsAString
&
aEventName
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
;
nsresult
SendFetchEvent
(
nsIInterceptedChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
const
nsAString
&
aClientId
const
nsAString
&
aResultingClientId
)
;
bool
MaybeStoreISupports
(
nsISupports
*
aSupports
)
;
void
RemoveISupports
(
nsISupports
*
aSupports
)
;
void
TerminateWorker
(
)
;
void
NoteDeadServiceWorkerInfo
(
)
;
void
NoteStoppedControllingDocuments
(
)
;
void
UpdateState
(
ServiceWorkerState
aState
)
;
nsresult
GetDebugger
(
nsIWorkerDebugger
*
*
aResult
)
;
nsresult
AttachDebugger
(
)
;
nsresult
DetachDebugger
(
)
;
bool
IsIdle
(
)
const
;
RefPtr
<
GenericPromise
>
GetIdlePromise
(
)
;
void
SetHandlesFetch
(
bool
aValue
)
;
private
:
enum
WakeUpReason
{
FetchEvent
=
0
PushEvent
PushSubscriptionChangeEvent
MessageEvent
NotificationClickEvent
NotificationCloseEvent
LifeCycleEvent
AttachEvent
Unknown
}
;
void
NoteIdleWorkerCallback
(
nsITimer
*
aTimer
)
;
void
TerminateWorkerCallback
(
nsITimer
*
aTimer
)
;
void
RenewKeepAliveToken
(
WakeUpReason
aWhy
)
;
void
ResetIdleTimeout
(
)
;
void
AddToken
(
)
;
void
ReleaseToken
(
)
;
nsresult
SpawnWorkerIfNeeded
(
WakeUpReason
aWhy
bool
*
aNewWorkerCreated
=
nullptr
nsILoadGroup
*
aLoadGroup
=
nullptr
)
;
~
ServiceWorkerPrivate
(
)
;
already_AddRefed
<
KeepAliveToken
>
CreateEventKeepAliveToken
(
)
;
ServiceWorkerInfo
*
MOZ_NON_OWNING_REF
mInfo
;
RefPtr
<
WorkerPrivate
>
mWorkerPrivate
;
nsCOMPtr
<
nsITimer
>
mIdleWorkerTimer
;
RefPtr
<
KeepAliveToken
>
mIdleKeepAliveToken
;
uint64_t
mDebuggerCount
;
uint64_t
mTokenCount
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
mSupportsArray
;
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
mPendingFunctionalEvents
;
RefPtr
<
Inner
>
mInner
;
MozPromiseHolder
<
GenericPromise
>
mIdlePromiseHolder
;
#
ifdef
DEBUG
bool
mIdlePromiseObtained
=
false
;
#
endif
}
;
}
}
#
endif
