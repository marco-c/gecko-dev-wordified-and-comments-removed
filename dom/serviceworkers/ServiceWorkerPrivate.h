#
ifndef
mozilla_dom_serviceworkerprivate_h
#
define
mozilla_dom_serviceworkerprivate_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
define
NOTIFICATION_CLICK_EVENT_NAME
"
notificationclick
"
#
define
NOTIFICATION_CLOSE_EVENT_NAME
"
notificationclose
"
class
nsIInterceptedChannel
;
namespace
mozilla
{
namespace
dom
{
class
ClientInfoAndState
;
class
KeepAliveToken
;
class
ServiceWorkerInfo
;
class
ServiceWorkerRegistrationInfo
;
class
LifeCycleEventCallback
:
public
Runnable
{
public
:
LifeCycleEventCallback
(
)
:
Runnable
(
"
dom
:
:
LifeCycleEventCallback
"
)
{
}
virtual
void
SetResult
(
bool
aResult
)
=
0
;
}
;
class
ServiceWorkerPrivate
final
{
friend
class
KeepAliveToken
;
public
:
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
)
;
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
ServiceWorkerPrivate
)
typedef
mozilla
:
:
FalseType
HasThreadSafeRefCnt
;
protected
:
nsCycleCollectingAutoRefCnt
mRefCnt
;
NS_DECL_OWNINGTHREAD
public
:
explicit
ServiceWorkerPrivate
(
ServiceWorkerInfo
*
aInfo
)
;
nsresult
SendMessageEvent
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
const
ClientInfoAndState
&
aClientInfoAndState
)
;
nsresult
CheckScriptEvaluation
(
LifeCycleEventCallback
*
aCallback
)
;
nsresult
SendLifeCycleEvent
(
const
nsAString
&
aEventType
LifeCycleEventCallback
*
aCallback
nsIRunnable
*
aLoadFailure
)
;
nsresult
SendPushEvent
(
const
nsAString
&
aMessageId
const
Maybe
<
nsTArray
<
uint8_t
>
>
&
aData
ServiceWorkerRegistrationInfo
*
aRegistration
)
;
nsresult
SendPushSubscriptionChangeEvent
(
)
;
nsresult
SendNotificationEvent
(
const
nsAString
&
aEventName
const
nsAString
&
aID
const
nsAString
&
aTitle
const
nsAString
&
aDir
const
nsAString
&
aLang
const
nsAString
&
aBody
const
nsAString
&
aTag
const
nsAString
&
aIcon
const
nsAString
&
aData
const
nsAString
&
aBehavior
const
nsAString
&
aScope
)
;
nsresult
SendFetchEvent
(
nsIInterceptedChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
const
nsAString
&
aClientId
bool
aIsReload
)
;
void
StoreISupports
(
nsISupports
*
aSupports
)
;
void
RemoveISupports
(
nsISupports
*
aSupports
)
;
void
TerminateWorker
(
)
;
void
NoteDeadServiceWorkerInfo
(
)
;
void
NoteStoppedControllingDocuments
(
)
;
void
UpdateState
(
ServiceWorkerState
aState
)
;
nsresult
GetDebugger
(
nsIWorkerDebugger
*
*
aResult
)
;
nsresult
AttachDebugger
(
)
;
nsresult
DetachDebugger
(
)
;
bool
IsIdle
(
)
const
;
void
SetHandlesFetch
(
bool
aValue
)
;
private
:
enum
WakeUpReason
{
FetchEvent
=
0
PushEvent
PushSubscriptionChangeEvent
MessageEvent
NotificationClickEvent
NotificationCloseEvent
LifeCycleEvent
AttachEvent
}
;
void
NoteIdleWorkerCallback
(
nsITimer
*
aTimer
)
;
void
TerminateWorkerCallback
(
nsITimer
*
aTimer
)
;
void
RenewKeepAliveToken
(
WakeUpReason
aWhy
)
;
void
ResetIdleTimeout
(
)
;
void
AddToken
(
)
;
void
ReleaseToken
(
)
;
nsresult
SpawnWorkerIfNeeded
(
WakeUpReason
aWhy
nsIRunnable
*
aLoadFailedRunnable
bool
*
aNewWorkerCreated
=
nullptr
nsILoadGroup
*
aLoadGroup
=
nullptr
)
;
~
ServiceWorkerPrivate
(
)
;
already_AddRefed
<
KeepAliveToken
>
CreateEventKeepAliveToken
(
)
;
ServiceWorkerInfo
*
MOZ_NON_OWNING_REF
mInfo
;
RefPtr
<
WorkerPrivate
>
mWorkerPrivate
;
nsCOMPtr
<
nsITimer
>
mIdleWorkerTimer
;
RefPtr
<
KeepAliveToken
>
mIdleKeepAliveToken
;
uint64_t
mDebuggerCount
;
uint64_t
mTokenCount
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
mSupportsArray
;
nsTArray
<
RefPtr
<
WorkerRunnable
>
>
mPendingFunctionalEvents
;
}
;
}
}
#
endif
