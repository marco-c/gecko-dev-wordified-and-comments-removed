const
DIR_PATH
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
"
)
.
slice
(
0
-
1
)
;
const
SWM
=
Cc
[
"
mozilla
.
org
/
serviceworkers
/
manager
;
1
"
]
.
getService
(
Ci
.
nsIServiceWorkerManager
)
;
const
kMinimumOriginUsageBytes
=
98304
;
function
getPrincipal
(
url
attrs
)
{
const
uri
=
Services
.
io
.
newURI
(
url
)
;
if
(
!
attrs
)
{
attrs
=
{
}
;
}
return
Services
.
scriptSecurityManager
.
createContentPrincipal
(
uri
attrs
)
;
}
async
function
_qm_requestFinished
(
request
)
{
await
new
Promise
(
function
(
resolve
)
{
request
.
callback
=
function
(
)
{
resolve
(
)
;
}
;
}
)
;
if
(
request
.
resultCode
!
=
=
Cr
.
NS_OK
)
{
throw
new
RequestError
(
request
.
resultCode
request
.
resultName
)
;
}
return
request
.
result
;
}
async
function
qm_reset_storage
(
)
{
return
new
Promise
(
resolve
=
>
{
let
request
=
Services
.
qms
.
reset
(
)
;
request
.
callback
=
resolve
;
}
)
;
}
async
function
get_qm_origin_usage
(
origin
)
{
return
new
Promise
(
resolve
=
>
{
const
principal
=
Services
.
scriptSecurityManager
.
createContentPrincipalFromOrigin
(
origin
)
;
Services
.
qms
.
getUsageForPrincipal
(
principal
request
=
>
{
info
(
QM
says
usage
of
{
origin
}
is
{
request
.
result
.
usage
}
)
;
resolve
(
request
.
result
.
usage
)
;
}
)
;
}
)
;
}
async
function
clear_qm_origin_group_via_clearData
(
origin
)
{
const
uri
=
Services
.
io
.
newURI
(
origin
)
;
const
baseDomain
=
Services
.
eTLD
.
getBaseDomain
(
uri
)
;
info
(
Clearing
storage
on
domain
{
baseDomain
}
(
from
origin
{
origin
}
)
)
;
await
new
Promise
(
(
resolve
reject
)
=
>
{
Services
.
clearData
.
deleteDataFromSite
(
baseDomain
{
}
false
Services
.
clearData
.
CLEAR_DOM_QUOTA
failedFlags
=
>
{
if
(
failedFlags
)
{
reject
(
failedFlags
)
;
}
else
{
resolve
(
)
;
}
}
)
;
}
)
;
}
function
swm_lookup_reg
(
swDesc
)
{
const
fullScope
=
{
swDesc
.
origin
}
/
{
DIR_PATH
}
/
{
swDesc
.
scope
}
;
const
principal
=
getPrincipal
(
fullScope
)
;
const
reg
=
SWM
.
getRegistrationByPrincipal
(
principal
fullScope
)
;
return
reg
;
}
async
function
install_sw
(
swDesc
)
{
info
(
Installing
ServiceWorker
{
swDesc
.
script
}
at
{
swDesc
.
scope
}
on
origin
{
swDesc
.
origin
}
)
;
const
pageUrlStr
=
{
swDesc
.
origin
}
/
{
DIR_PATH
}
/
empty_with_utils
.
html
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
pageUrlStr
}
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
{
swScript
:
swDesc
.
script
swScope
:
swDesc
.
scope
}
]
async
function
(
{
swScript
swScope
}
)
{
await
content
.
wrappedJSObject
.
registerAndWaitForActive
(
swScript
swScope
)
;
}
)
;
}
)
;
info
(
ServiceWorker
installed
)
;
return
swm_lookup_reg
(
swDesc
)
;
}
async
function
createMessagingHelperTab
(
origin
channelName
)
{
const
pageUrlStr
=
{
origin
}
/
{
DIR_PATH
}
/
empty_with_utils
.
html
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
pageUrlStr
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
channelName
]
channelName
=
>
{
content
.
wrappedJSObject
.
setupMessagingChannel
(
channelName
)
;
}
)
;
return
{
async
postMessageScopeAndWaitFor
(
scope
messageToSend
messageToWaitFor
)
{
info
(
Sending
message
to
SW
scope
{
scope
}
via
helper
page
:
{
messageToSend
}
)
;
info
(
Waiting
for
message
via
helper
page
:
{
messageToWaitFor
}
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
channelName
scope
messageToSend
messageToWaitFor
]
async
(
channelName
scope
messageToSend
messageToWaitFor
)
=
>
{
await
content
.
wrappedJSObject
.
postMessageScopeAndWaitFor
(
channelName
scope
messageToSend
messageToWaitFor
)
;
}
)
;
ok
(
true
"
Expected
message
received
"
)
;
}
async
broadcastAndWaitFor
(
messageToBroadcast
messageToWaitFor
)
{
info
(
Sending
messageToBroadcast
via
helper
page
:
{
messageToBroadcast
}
)
;
info
(
Waiting
for
message
via
helper
page
:
{
messageToWaitFor
}
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
channelName
messageToBroadcast
messageToWaitFor
]
async
(
channelName
messageToBroadcast
messageToWaitFor
)
=
>
{
await
content
.
wrappedJSObject
.
broadcastAndWaitFor
(
channelName
messageToBroadcast
messageToWaitFor
)
;
}
)
;
ok
(
true
"
Expected
message
received
"
)
;
}
async
updateScopeAndWaitFor
(
scope
messageToWaitFor
)
{
info
(
Updating
scope
{
scope
}
via
helper
page
)
;
info
(
Waiting
for
message
via
helper
page
:
{
messageToWaitFor
}
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
channelName
scope
messageToWaitFor
]
async
(
channelName
scope
messageToWaitFor
)
=
>
{
await
content
.
wrappedJSObject
.
updateScopeAndWaitFor
(
channelName
scope
messageToWaitFor
)
;
}
)
;
ok
(
true
"
Expected
message
received
"
)
;
}
async
closeHelperTab
(
)
{
await
BrowserTestUtils
.
removeTab
(
tab
)
;
tab
=
null
;
}
}
;
}
async
function
consume_storage
(
origin
storageDesc
)
{
info
(
Consuming
storage
on
origin
{
origin
}
)
;
const
pageUrlStr
=
{
origin
}
/
{
DIR_PATH
}
/
empty_with_utils
.
html
;
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
pageUrlStr
}
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
storageDesc
]
async
function
(
{
cacheBytes
idbBytes
}
)
{
await
content
.
wrappedJSObject
.
fillStorage
(
cacheBytes
idbBytes
)
;
}
)
;
}
)
;
}
function
is_minimum_origin_usage
(
originUsageBytes
)
{
return
originUsageBytes
<
=
kMinimumOriginUsageBytes
;
}
async
function
navigate_and_get_body
(
swDesc
debugTag
)
{
let
pageUrlStr
=
{
swDesc
.
origin
}
/
{
DIR_PATH
}
/
{
swDesc
.
scope
}
;
if
(
debugTag
)
{
pageUrlStr
+
=
"
?
"
+
debugTag
;
}
info
(
Navigating
to
{
pageUrlStr
}
)
;
const
tabResult
=
await
BrowserTestUtils
.
withNewTab
(
{
gBrowser
url
:
pageUrlStr
waitForLoad
:
false
waitForStateStop
:
true
}
async
browser
=
>
{
info
(
Tab
opened
querying
body
content
.
)
;
const
spawnResult
=
await
SpecialPowers
.
spawn
(
browser
[
]
function
(
)
{
const
controlled
=
!
!
content
.
navigator
.
serviceWorker
.
controller
;
let
loc
=
content
.
document
.
documentURI
;
if
(
loc
.
startsWith
(
"
about
:
"
)
)
{
const
idxQuestion
=
loc
.
indexOf
(
"
?
"
)
;
if
(
idxQuestion
!
=
=
-
1
)
{
loc
=
loc
.
substring
(
0
idxQuestion
)
;
}
return
{
controlled
body
:
loc
}
;
}
return
{
controlled
body
:
content
.
document
?
.
body
?
.
textContent
?
.
trim
(
)
}
;
}
)
;
return
spawnResult
;
}
)
;
return
tabResult
;
}
function
waitForIframeLoad
(
iframe
)
{
return
new
Promise
(
function
(
resolve
)
{
iframe
.
onload
=
resolve
;
}
)
;
}
function
waitForRegister
(
scope
callback
)
{
return
new
Promise
(
function
(
resolve
)
{
let
listener
=
{
onRegister
(
registration
)
{
if
(
registration
.
scope
!
=
=
scope
)
{
return
;
}
SWM
.
removeListener
(
listener
)
;
resolve
(
callback
?
callback
(
registration
)
:
registration
)
;
}
}
;
SWM
.
addListener
(
listener
)
;
}
)
;
}
function
waitForUnregister
(
scope
)
{
return
new
Promise
(
function
(
resolve
)
{
let
listener
=
{
onUnregister
(
registration
)
{
if
(
registration
.
scope
!
=
=
scope
)
{
return
;
}
SWM
.
removeListener
(
listener
)
;
resolve
(
registration
)
;
}
}
;
SWM
.
addListener
(
listener
)
;
}
)
;
}
function
waitForQuotaUsageCheckFinish
(
scope
)
{
return
new
Promise
(
function
(
resolve
)
{
let
listener
=
{
onQuotaUsageCheckFinish
(
registration
)
{
if
(
registration
.
scope
!
=
=
scope
)
{
return
;
}
SWM
.
removeListener
(
listener
)
;
resolve
(
registration
)
;
}
}
;
SWM
.
addListener
(
listener
)
;
}
)
;
}
function
waitForServiceWorkerRegistrationChange
(
registration
callback
)
{
return
new
Promise
(
function
(
resolve
)
{
let
listener
=
{
onChange
(
)
{
registration
.
removeListener
(
listener
)
;
if
(
callback
)
{
callback
(
)
;
}
resolve
(
callback
?
callback
(
)
:
undefined
)
;
}
}
;
registration
.
addListener
(
listener
)
;
}
)
;
}
function
waitForServiceWorkerShutdown
(
)
{
return
new
Promise
(
function
(
resolve
)
{
let
observer
=
{
observe
(
subject
topic
data
)
{
if
(
topic
!
=
=
"
service
-
worker
-
shutdown
"
)
{
return
;
}
SpecialPowers
.
removeObserver
(
observer
"
service
-
worker
-
shutdown
"
)
;
resolve
(
)
;
}
}
;
SpecialPowers
.
addObserver
(
observer
"
service
-
worker
-
shutdown
"
)
;
}
)
;
}
