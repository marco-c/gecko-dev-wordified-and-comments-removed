function
waitForState
(
worker
state
context
)
{
return
new
Promise
(
resolve
=
>
{
function
onStateChange
(
)
{
if
(
worker
.
state
=
=
=
state
)
{
worker
.
removeEventListener
(
"
statechange
"
onStateChange
)
;
resolve
(
context
)
;
}
}
worker
.
addEventListener
(
"
statechange
"
onStateChange
)
;
onStateChange
(
)
;
}
)
;
}
async
function
registerAndWaitForActive
(
script
maybeScope
)
{
console
.
log
(
"
.
.
.
calling
register
"
)
;
let
opts
=
undefined
;
if
(
maybeScope
)
{
opts
=
{
scope
:
maybeScope
}
;
}
const
reg
=
await
navigator
.
serviceWorker
.
register
(
script
opts
)
;
console
.
log
(
"
.
.
.
waiting
for
activation
"
)
;
await
waitForState
(
reg
.
installing
"
activated
"
reg
)
;
console
.
log
(
"
.
.
.
activated
!
"
)
;
return
reg
;
}
function
createIframeAndWaitForMessage
(
url
)
{
const
iframe
=
document
.
createElement
(
"
iframe
"
)
;
document
.
body
.
appendChild
(
iframe
)
;
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
message
"
event
=
>
{
resolve
(
event
.
data
)
;
}
{
once
:
true
}
)
;
iframe
.
src
=
url
;
}
)
;
}
function
createNestedIframeAndWaitForMessage
(
url
)
{
const
iframe
=
document
.
getElementsByTagName
(
"
iframe
"
)
[
0
]
;
iframe
.
contentWindow
.
postMessage
(
"
create
nested
iframe
"
"
*
"
)
;
return
new
Promise
(
resolve
=
>
{
window
.
addEventListener
(
"
message
"
event
=
>
{
resolve
(
event
.
data
)
;
}
{
once
:
true
}
)
;
}
)
;
}
async
function
unregisterAll
(
)
{
const
registrations
=
await
navigator
.
serviceWorker
.
getRegistrations
(
)
;
for
(
const
reg
of
registrations
)
{
await
reg
.
unregister
(
)
;
}
}
function
makeRandomBlob
(
size
)
{
const
arr
=
new
Uint8Array
(
size
)
;
let
offset
=
0
;
while
(
offset
<
size
)
{
const
nextSize
=
Math
.
min
(
size
-
offset
65536
)
;
window
.
crypto
.
getRandomValues
(
new
Uint8Array
(
arr
.
buffer
offset
nextSize
)
)
;
offset
+
=
nextSize
;
}
return
new
Blob
(
[
arr
]
{
type
:
"
application
/
octet
-
stream
"
}
)
;
}
async
function
fillStorage
(
cacheBytes
idbBytes
)
{
const
cache
=
await
caches
.
open
(
"
filler
"
)
;
await
cache
.
put
(
"
fill
"
new
Response
(
makeRandomBlob
(
cacheBytes
)
)
)
;
const
storeName
=
"
filler
"
;
let
db
=
await
new
Promise
(
(
resolve
reject
)
=
>
{
let
openReq
=
indexedDB
.
open
(
"
filler
"
1
)
;
openReq
.
onerror
=
event
=
>
{
reject
(
event
.
target
.
error
)
;
}
;
openReq
.
onsuccess
=
event
=
>
{
resolve
(
event
.
target
.
result
)
;
}
;
openReq
.
onupgradeneeded
=
event
=
>
{
const
useDB
=
event
.
target
.
result
;
useDB
.
onerror
=
error
=
>
{
reject
(
error
)
;
}
;
const
store
=
useDB
.
createObjectStore
(
storeName
)
;
store
.
put
(
{
blob
:
makeRandomBlob
(
idbBytes
)
}
"
filler
-
blob
"
)
;
}
;
}
)
;
}
const
messagingChannels
=
{
}
;
function
setupMessagingChannel
(
name
)
{
if
(
messagingChannels
[
name
]
)
{
return
;
}
messagingChannels
[
name
]
=
new
BroadcastChannel
(
name
)
;
}
function
waitForBroadcastMessage
(
channelName
messageToWaitFor
)
{
if
(
!
messagingChannels
[
channelName
]
)
{
throw
new
Error
(
You
forgot
to
call
setupMessagingChannel
(
{
channelName
}
)
)
;
}
return
new
Promise
(
(
resolve
reject
)
=
>
{
const
channel
=
messagingChannels
[
channelName
]
;
const
listener
=
evt
=
>
{
console
.
log
(
"
Helper
seeing
message
"
evt
.
data
"
on
channel
"
channelName
)
;
if
(
evt
.
data
=
=
=
messageToWaitFor
)
{
resolve
(
)
;
channel
.
removeEventListener
(
"
message
"
listener
)
;
}
else
if
(
evt
.
data
?
.
error
)
{
reject
(
evt
.
data
)
;
channel
.
removeEventListener
(
"
message
"
listener
)
;
}
}
;
channel
.
addEventListener
(
"
message
"
listener
)
;
}
)
;
}
async
function
postMessageScopeAndWaitFor
(
channelName
scope
messageToSend
messageToWaitFor
)
{
const
waitPromise
=
waitForBroadcastMessage
(
channelName
messageToWaitFor
)
;
const
channel
=
messagingChannels
[
channelName
]
;
const
reg
=
await
navigator
.
serviceWorker
.
getRegistration
(
scope
)
;
if
(
!
reg
)
{
throw
new
Error
(
Unable
to
find
registration
for
scope
:
{
scope
}
)
;
}
if
(
!
reg
.
active
)
{
throw
new
Error
(
There
is
no
active
SW
on
the
reg
for
scope
:
{
scope
}
)
;
}
reg
.
active
.
postMessage
(
messageToSend
)
;
await
waitPromise
;
}
async
function
broadcastAndWaitFor
(
channelName
messageToBroadcast
messageToWaitFor
)
{
const
waitPromise
=
waitForBroadcastMessage
(
channelName
messageToWaitFor
)
;
const
channel
=
messagingChannels
[
channelName
]
;
channel
.
postMessage
(
messageToBroadcast
)
;
await
waitPromise
;
}
async
function
updateScopeAndWaitFor
(
channelName
scope
messageToWaitFor
)
{
const
waitPromise
=
waitForBroadcastMessage
(
channelName
messageToWaitFor
)
;
const
channel
=
messagingChannels
[
channelName
]
;
const
reg
=
await
navigator
.
serviceWorker
.
getRegistration
(
scope
)
;
if
(
!
reg
)
{
throw
new
Error
(
Unable
to
find
registration
for
scope
:
{
scope
}
)
;
}
reg
.
update
(
)
;
await
waitPromise
;
}
