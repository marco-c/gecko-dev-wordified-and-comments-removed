const
BEHAVIOR_ACCEPT
=
Ci
.
nsICookieService
.
BEHAVIOR_ACCEPT
;
const
BEHAVIOR_REJECT_TRACKER
=
Ci
.
nsICookieService
.
BEHAVIOR_REJECT_TRACKER
;
let
{
UrlClassifierTestUtils
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
testing
-
common
/
UrlClassifierTestUtils
.
jsm
"
)
;
const
TOP_DOMAIN
=
"
http
:
/
/
mochi
.
test
:
8888
/
"
;
const
SW_DOMAIN
=
"
https
:
/
/
tracking
.
example
.
org
/
"
;
const
TOP_TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
TOP_DOMAIN
)
;
const
SW_TEST_ROOT
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
SW_DOMAIN
)
;
const
TOP_EMPTY_PAGE
=
{
TOP_TEST_ROOT
}
empty_with_utils
.
html
;
const
SW_REGISTER_PAGE
=
{
SW_TEST_ROOT
}
empty_with_utils
.
html
;
const
SW_IFRAME_PAGE
=
{
SW_TEST_ROOT
}
page_post_controlled
.
html
;
const
SW_REL_SW_SCRIPT
=
"
empty
.
js
"
;
add_task
(
async
function
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
[
[
'
dom
.
serviceWorkers
.
enabled
'
true
]
[
'
dom
.
serviceWorkers
.
exemptFromPerDomainMax
'
true
]
[
'
dom
.
serviceWorkers
.
testing
.
enabled
'
true
]
[
'
network
.
cookie
.
cookieBehavior
'
BEHAVIOR_ACCEPT
]
]
}
)
;
info
(
"
Opening
a
new
tab
:
"
+
SW_REGISTER_PAGE
)
;
let
topTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
SW_REGISTER_PAGE
}
)
;
info
(
"
Installing
SW
"
)
;
await
ContentTask
.
spawn
(
topTab
.
linkedBrowser
{
sw
:
SW_REL_SW_SCRIPT
}
async
function
(
{
sw
}
)
{
await
content
.
wrappedJSObject
.
registerAndWaitForActive
(
sw
)
;
}
)
;
await
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
[
[
'
privacy
.
trackingprotection
.
enabled
'
false
]
[
"
privacy
.
trackingprotection
.
pbmode
.
enabled
"
false
]
[
"
privacy
.
trackingprotection
.
annotate_channels
"
true
]
[
'
network
.
cookie
.
cookieBehavior
'
BEHAVIOR_REJECT_TRACKER
]
]
}
)
;
await
UrlClassifierTestUtils
.
addTestTrackers
(
)
;
info
(
"
Loading
a
new
top
-
level
URL
:
"
+
TOP_EMPTY_PAGE
)
;
let
browserLoadedPromise
=
BrowserTestUtils
.
browserLoaded
(
topTab
.
linkedBrowser
)
;
await
BrowserTestUtils
.
loadURI
(
topTab
.
linkedBrowser
TOP_EMPTY_PAGE
)
;
await
browserLoadedPromise
;
let
{
controlled
}
=
await
ContentTask
.
spawn
(
topTab
.
linkedBrowser
{
url
:
SW_IFRAME_PAGE
}
async
function
(
{
url
}
)
{
const
payload
=
await
content
.
wrappedJSObject
.
createIframeAndWaitForMessage
(
url
)
;
return
payload
;
}
)
;
ok
(
!
controlled
"
Should
not
be
controlled
!
"
)
;
info
(
"
Loading
the
SW
unregister
page
:
"
+
SW_REGISTER_PAGE
)
;
browserLoadedPromise
=
BrowserTestUtils
.
browserLoaded
(
topTab
.
linkedBrowser
)
;
await
BrowserTestUtils
.
loadURI
(
topTab
.
linkedBrowser
SW_REGISTER_PAGE
)
;
await
browserLoadedPromise
;
await
ContentTask
.
spawn
(
topTab
.
linkedBrowser
null
async
function
(
)
{
await
content
.
wrappedJSObject
.
unregisterAll
(
)
;
}
)
;
BrowserTestUtils
.
removeTab
(
topTab
)
;
}
)
;
