Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
dom
/
serviceworkers
/
test
/
browser_head
.
js
"
this
)
;
const
TEST_ORIGIN
=
"
https
:
/
/
test1
.
example
.
org
"
;
async
function
test_post_message_between_service_workers
(
)
{
info
(
"
#
#
Installing
the
ServiceWorkers
"
)
;
const
aSwDesc
=
{
origin
:
TEST_ORIGIN
scope
:
"
sw
-
a
"
script
:
"
sw_inter_sw_postmessage
.
js
?
a
"
}
;
const
bSwDesc
=
{
origin
:
TEST_ORIGIN
scope
:
"
sw
-
b
"
script
:
"
sw_inter_sw_postmessage
.
js
?
b
"
}
;
registerCleanupFunction
(
async
(
)
=
>
{
await
clear_qm_origin_group_via_clearData
(
TEST_ORIGIN
)
;
}
)
;
const
aReg
=
await
install_sw
(
aSwDesc
)
;
const
bReg
=
await
install_sw
(
bSwDesc
)
;
info
(
"
#
#
Terminating
the
ServiceWorkers
"
)
;
const
aSWInfo
=
aReg
.
activeWorker
;
await
aSWInfo
.
terminateWorker
(
)
;
const
bSWInfo
=
bReg
.
activeWorker
;
await
bSWInfo
.
terminateWorker
(
)
;
is
(
aSWInfo
.
lifetimeDeadline
0
"
SW
A
not
running
.
"
)
;
is
(
bSWInfo
.
lifetimeDeadline
0
"
SW
B
not
running
.
"
)
;
is
(
aSWInfo
.
launchCount
1
"
SW
A
did
run
once
though
.
"
)
;
is
(
bSWInfo
.
launchCount
1
"
SW
B
did
run
once
though
.
"
)
;
info
(
"
#
#
Beginning
PostMessage
Checks
"
)
;
let
testStart
=
ChromeUtils
.
now
(
)
;
const
{
closeHelperTab
postMessageScopeAndWaitFor
broadcastAndWaitFor
}
=
await
createMessagingHelperTab
(
TEST_ORIGIN
"
inter
-
sw
-
postmessage
"
)
;
registerCleanupFunction
(
closeHelperTab
)
;
await
postMessageScopeAndWaitFor
(
"
sw
-
a
"
"
Hello
the
contents
of
this
message
don
'
t
matter
!
"
"
a
:
received
-
post
-
message
-
from
:
wc
-
helper
"
)
;
let
aLifetime
=
aSWInfo
.
lifetimeDeadline
;
Assert
.
greater
(
aLifetime
testStart
"
SW
A
should
be
running
with
a
deadline
in
the
future
.
"
)
;
is
(
bSWInfo
.
lifetimeDeadline
0
"
SW
B
not
running
.
"
)
;
is
(
aSWInfo
.
launchCount
2
"
SW
A
was
launched
by
our
postMessage
.
"
)
;
is
(
bSWInfo
.
launchCount
1
"
SW
B
has
not
been
re
-
launched
yet
.
"
)
;
await
broadcastAndWaitFor
(
"
a
:
post
-
message
-
to
:
reg
-
sw
-
b
"
"
b
:
received
-
post
-
message
-
from
:
sw
-
a
"
)
;
is
(
bSWInfo
.
lifetimeDeadline
aLifetime
"
SW
B
has
same
deadline
as
SW
A
after
cross
-
SW
postMessage
"
)
;
await
broadcastAndWaitFor
(
"
b
:
post
-
message
-
to
:
reg
-
sw
-
a
"
"
a
:
received
-
post
-
message
-
from
:
sw
-
b
"
)
;
is
(
bSWInfo
.
lifetimeDeadline
aLifetime
"
SW
A
still
has
the
same
deadline
after
B
'
s
cross
-
SW
postMessage
"
)
;
is
(
bSWInfo
.
launchCount
2
"
SW
B
was
re
-
launched
.
"
)
;
is
(
aSWInfo
.
lifetimeDeadline
aLifetime
"
SW
A
deadline
unchanged
"
)
;
is
(
aSWInfo
.
launchCount
2
"
SW
A
launch
count
unchanged
.
"
)
;
await
postMessageScopeAndWaitFor
(
"
sw
-
b
"
"
Hello
the
contents
of
this
message
don
'
t
matter
!
"
"
b
:
received
-
post
-
message
-
from
:
wc
-
helper
"
)
;
let
bLifetime
=
bSWInfo
.
lifetimeDeadline
;
Assert
.
greater
(
bLifetime
aLifetime
"
SW
B
should
have
a
deadline
after
A
'
s
after
the
page
postMessage
"
)
;
is
(
aSWInfo
.
lifetimeDeadline
aLifetime
"
SW
A
deadline
unchanged
"
)
;
is
(
aSWInfo
.
launchCount
2
"
SW
A
launch
count
unchanged
.
"
)
;
await
broadcastAndWaitFor
(
"
b
:
post
-
message
-
to
:
reg
-
sw
-
a
"
"
a
:
received
-
post
-
message
-
from
:
sw
-
b
"
)
;
is
(
aSWInfo
.
lifetimeDeadline
bLifetime
"
SW
A
should
have
the
same
deadline
as
B
after
B
'
s
cross
-
SW
postMessage
"
)
;
is
(
aSWInfo
.
launchCount
2
"
SW
A
launch
count
unchanged
.
"
)
;
is
(
bSWInfo
.
lifetimeDeadline
bLifetime
"
SW
B
deadline
unchanged
"
)
;
is
(
bSWInfo
.
launchCount
2
"
SW
B
launch
count
unchanged
.
"
)
;
}
add_task
(
test_post_message_between_service_workers
)
;
async
function
test_eternally_updating_service_worker
(
)
{
info
(
"
#
#
Installing
the
Eternally
Updating
ServiceWorker
"
)
;
const
swDesc
=
{
origin
:
TEST_ORIGIN
scope
:
"
sw
-
u
"
script
:
"
sw_always_updating_inter_sw_postmessage
.
sjs
?
u
"
}
;
registerCleanupFunction
(
async
(
)
=
>
{
await
clear_qm_origin_group_via_clearData
(
TEST_ORIGIN
)
;
}
)
;
let
testStart
=
ChromeUtils
.
now
(
)
;
const
reg
=
await
install_sw
(
swDesc
)
;
const
firstInfo
=
reg
.
activeWorker
;
const
firstLifetime
=
firstInfo
.
lifetimeDeadline
;
Assert
.
greater
(
firstLifetime
testStart
"
The
first
generation
should
be
running
with
a
deadline
in
the
future
.
"
)
;
const
{
closeHelperTab
broadcastAndWaitFor
updateScopeAndWaitFor
}
=
await
createMessagingHelperTab
(
TEST_ORIGIN
"
inter
-
sw
-
postmessage
"
)
;
registerCleanupFunction
(
closeHelperTab
)
;
info
(
"
#
#
Beginning
Self
-
Update
Requests
"
)
;
await
broadcastAndWaitFor
(
"
u
#
1
:
update
-
reg
:
sw
-
u
"
"
u
:
version
-
activated
:
2
"
)
;
const
secondInfo
=
reg
.
activeWorker
;
const
secondLifetime
=
secondInfo
.
lifetimeDeadline
;
is
(
firstLifetime
secondLifetime
"
Version
2
has
same
lifetime
as
1
.
"
)
;
await
broadcastAndWaitFor
(
"
u
#
2
:
update
-
reg
:
sw
-
u
"
"
u
:
version
-
activated
:
3
"
)
;
const
thirdInfo
=
reg
.
activeWorker
;
const
thirdLifetime
=
thirdInfo
.
lifetimeDeadline
;
is
(
firstLifetime
thirdLifetime
"
Version
3
has
same
lifetime
as
1
and
2
.
"
)
;
await
updateScopeAndWaitFor
(
"
sw
-
u
"
"
u
:
version
-
activated
:
4
"
)
;
const
fourthInfo
=
reg
.
activeWorker
;
const
fourthLifetime
=
fourthInfo
.
lifetimeDeadline
;
Assert
.
greater
(
fourthLifetime
firstLifetime
"
Version
4
has
a
fresh
lifetime
.
"
)
;
await
broadcastAndWaitFor
(
"
u
#
4
:
update
-
reg
:
sw
-
u
"
"
u
:
version
-
activated
:
5
"
)
;
const
fifthInfo
=
reg
.
activeWorker
;
const
fifthLifetime
=
fifthInfo
.
lifetimeDeadline
;
is
(
fourthLifetime
fifthLifetime
"
Version
5
has
same
lifetime
as
4
.
"
)
;
}
add_task
(
test_eternally_updating_service_worker
)
;
async
function
test_service_worker_creating_new_registrations
(
)
{
info
(
"
#
#
Installing
the
Bootstrap
ServiceWorker
"
)
;
const
cSwDesc
=
{
origin
:
TEST_ORIGIN
scope
:
"
sw
-
c
"
script
:
"
sw_inter_sw_postmessage
.
js
?
c
"
}
;
registerCleanupFunction
(
async
(
)
=
>
{
await
clear_qm_origin_group_via_clearData
(
TEST_ORIGIN
)
;
}
)
;
let
testStart
=
ChromeUtils
.
now
(
)
;
const
cReg
=
await
install_sw
(
cSwDesc
)
;
const
cSWInfo
=
cReg
.
activeWorker
;
const
cLifetime
=
cSWInfo
.
lifetimeDeadline
;
Assert
.
greater
(
cLifetime
testStart
"
The
bootstrap
registration
worker
should
be
running
with
a
deadline
in
the
future
.
"
)
;
const
{
closeHelperTab
broadcastAndWaitFor
updateScopeAndWaitFor
}
=
await
createMessagingHelperTab
(
TEST_ORIGIN
"
inter
-
sw
-
postmessage
"
)
;
registerCleanupFunction
(
closeHelperTab
)
;
info
(
"
#
#
Beginning
Propagating
Registrations
"
)
;
await
broadcastAndWaitFor
(
"
c
:
install
-
reg
:
d
"
"
d
:
version
-
activated
:
0
"
)
;
const
dSwDesc
=
{
origin
:
TEST_ORIGIN
scope
:
"
sw
-
d
"
script
:
"
sw_inter_sw_postmessage
.
js
?
d
"
}
;
const
dReg
=
swm_lookup_reg
(
dSwDesc
)
;
ok
(
dReg
"
found
the
new
'
d
'
registration
"
)
;
const
dSWInfo
=
dReg
.
activeWorker
;
ok
(
dSWInfo
"
The
'
d
'
registration
has
the
expected
active
worker
.
"
)
;
const
dLifetime
=
dSWInfo
.
lifetimeDeadline
;
is
(
dLifetime
cLifetime
"
The
new
worker
has
the
same
lifetime
as
the
worker
that
triggered
its
installation
.
"
)
;
}
add_task
(
test_service_worker_creating_new_registrations
)
;
async
function
test_respawn_immediately_after_termination
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
workers
.
testing
.
enabled
"
true
]
]
}
)
;
if
(
!
Services
.
appinfo
.
fissionAutostart
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processCount
"
1
]
]
}
)
;
}
info
(
"
#
#
Installing
the
ServiceWorker
we
will
terminate
and
respawn
"
)
;
const
tSwDesc
=
{
origin
:
TEST_ORIGIN
scope
:
"
sw
-
t
"
script
:
"
sw_inter_sw_postmessage
.
js
?
t
"
}
;
registerCleanupFunction
(
async
(
)
=
>
{
await
clear_qm_origin_group_via_clearData
(
TEST_ORIGIN
)
;
}
)
;
const
tReg
=
await
install_sw
(
tSwDesc
)
;
const
tSWInfo
=
tReg
.
activeWorker
;
info
(
"
#
#
Induce
the
SW
to
acquire
a
WorkerRef
that
prevents
shutdown
.
"
)
;
const
{
closeHelperTab
broadcastAndWaitFor
postMessageScopeAndWaitFor
}
=
await
createMessagingHelperTab
(
TEST_ORIGIN
"
inter
-
sw
-
postmessage
"
)
;
registerCleanupFunction
(
closeHelperTab
)
;
await
broadcastAndWaitFor
(
"
t
:
block
:
serviceworker
-
t
-
release
"
"
t
:
blocking
:
serviceworker
-
t
-
release
"
)
;
info
(
"
#
#
Terminating
and
respawning
the
ServiceWorker
via
attachDebugger
"
)
;
const
terminationPromise
=
tSWInfo
.
terminateWorker
(
)
;
await
postMessageScopeAndWaitFor
(
"
sw
-
t
"
"
Hello
the
contents
of
this
message
don
'
t
matter
!
"
"
t
:
received
-
post
-
message
-
from
:
wc
-
helper
"
)
;
await
broadcastAndWaitFor
(
"
t
:
notify
-
observer
:
serviceworker
-
t
-
release
"
"
t
:
notified
-
observer
:
serviceworker
-
t
-
release
"
)
;
info
(
"
#
#
Awaiting
the
termination
"
)
;
await
terminationPromise
;
}
add_task
(
test_respawn_immediately_after_termination
)
;
