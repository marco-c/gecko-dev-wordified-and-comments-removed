requestLongerTimeout
(
2
)
;
Services
.
scriptloader
.
loadSubScript
(
"
chrome
:
/
/
mochitests
/
content
/
browser
/
dom
/
serviceworkers
/
test
/
browser_head
.
js
"
this
)
;
const
TEST_ORIGIN
=
"
https
:
/
/
test1
.
example
.
org
"
;
const
SAME_GROUP_ORIGIN
=
"
https
:
/
/
test2
.
example
.
org
"
;
const
TEST_SW_SETUP
=
{
origin
:
TEST_ORIGIN
scope
:
"
network_with_utils
.
html
"
script
:
"
sw_respondwith_serviceworker
.
js
"
}
;
const
TEST_STORAGE_SETUP
=
{
cacheBytes
:
4
*
1024
*
1024
idbBytes
:
4
*
1024
*
1024
}
;
const
FAULTS_BEFORE_MITIGATION
=
3
;
async
function
do_fault_injection_test
(
{
name
useError
errorPage
consumeQuotaOrigin
}
)
{
info
(
#
#
#
testing
:
error
:
{
name
}
(
{
useError
}
)
consumeQuotaOrigin
:
{
consumeQuotaOrigin
}
)
;
await
clear_qm_origin_group_via_clearData
(
TEST_ORIGIN
)
;
const
reg
=
await
install_sw
(
TEST_SW_SETUP
)
;
const
sw
=
reg
.
activeWorker
;
if
(
consumeQuotaOrigin
)
{
await
consume_storage
(
consumeQuotaOrigin
TEST_STORAGE_SETUP
)
;
}
info
(
#
#
Checking
normal
operation
.
)
;
{
const
debugTag
=
err
=
{
name
}
&
fault
=
0
;
const
docInfo
=
await
navigate_and_get_body
(
TEST_SW_SETUP
debugTag
)
;
is
(
docInfo
.
body
"
SERVICEWORKER
"
"
navigation
without
injected
fault
originates
from
ServiceWorker
"
)
;
is
(
docInfo
.
controlled
true
"
successfully
intercepted
navigation
should
be
controlled
"
)
;
}
const
unregisteredPromise
=
waitForUnregister
(
reg
.
scope
)
;
const
quotaUsageCheckFinishPromise
=
waitForQuotaUsageCheckFinish
(
reg
.
scope
)
;
sw
.
testingInjectCancellation
=
useError
;
for
(
let
iFault
=
0
;
iFault
<
FAULTS_BEFORE_MITIGATION
;
iFault
+
+
)
{
info
(
#
#
Testing
with
injected
fault
number
{
iFault
+
1
}
)
;
is
(
reg
.
quotaUsageCheckCount
0
"
No
quota
usage
check
yet
"
)
;
const
debugTag
=
err
=
{
name
}
&
fault
=
{
iFault
+
1
}
;
const
docInfo
=
await
navigate_and_get_body
(
TEST_SW_SETUP
debugTag
)
;
is
(
docInfo
.
body
"
NETWORK
"
"
navigation
with
injected
fault
originates
from
network
"
)
;
is
(
docInfo
.
controlled
false
"
bypassed
pages
shouldn
'
t
be
controlled
"
)
;
is
(
sw
.
navigationFaultCount
iFault
+
1
"
navigation
fault
increased
(
to
expected
value
)
"
)
;
}
await
unregisteredPromise
;
is
(
reg
.
unregistered
true
"
registration
should
be
unregistered
"
)
;
await
quotaUsageCheckFinishPromise
;
if
(
consumeQuotaOrigin
)
{
const
originUsage
=
await
get_qm_origin_usage
(
TEST_ORIGIN
)
;
ok
(
is_minimum_origin_usage
(
originUsage
)
"
origin
usage
should
be
mitigated
"
)
;
if
(
consumeQuotaOrigin
=
=
=
SAME_GROUP_ORIGIN
)
{
const
sameGroupUsage
=
await
get_qm_origin_usage
(
SAME_GROUP_ORIGIN
)
;
ok
(
sameGroupUsage
=
=
=
0
"
same
group
usage
should
be
mitigated
"
)
;
}
}
}
add_task
(
async
function
test_navigation_fetch_fault_handling
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
mitigations
.
bypass_on_fault
"
true
]
[
"
dom
.
serviceWorkers
.
mitigations
.
group_usage_headroom_kb
"
5
*
1024
]
[
"
dom
.
quotaManager
.
testing
"
true
]
[
"
dom
.
quotaManager
.
temporaryStorage
.
fixedLimit
"
10
*
1024
]
]
}
)
;
await
qm_reset_storage
(
)
;
const
quotaOriginVariations
=
[
undefined
TEST_ORIGIN
SAME_GROUP_ORIGIN
]
;
for
(
const
consumeQuotaOrigin
of
quotaOriginVariations
)
{
await
do_fault_injection_test
(
{
name
:
"
NS_ERROR_DOM_ABORT_ERR
"
useError
:
0x80530014
errorPage
:
"
about
:
blank
"
consumeQuotaOrigin
}
)
;
await
do_fault_injection_test
(
{
name
:
"
NS_ERROR_INTERCEPTION_FAILED
"
useError
:
0x804b0064
errorPage
:
"
about
:
neterror
"
consumeQuotaOrigin
}
)
;
}
await
clear_qm_origin_group_via_clearData
(
TEST_ORIGIN
)
;
}
)
;
