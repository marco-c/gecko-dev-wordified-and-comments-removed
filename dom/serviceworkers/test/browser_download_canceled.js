ChromeUtils
.
import
(
'
resource
:
/
/
gre
/
modules
/
Services
.
jsm
'
)
;
const
{
Downloads
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
{
}
)
;
async
function
clearDownloads
(
)
{
const
downloads
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
downloads
.
removeFinished
(
)
;
}
function
promiseClickDownloadDialogButton
(
buttonAction
)
{
return
new
Promise
(
resolve
=
>
{
Services
.
ww
.
registerNotification
(
function
onOpen
(
win
topic
data
)
{
if
(
topic
=
=
=
"
domwindowopened
"
&
&
win
instanceof
Ci
.
nsIDOMWindow
)
{
win
.
addEventListener
(
"
load
"
function
(
)
{
info
(
found
window
of
type
:
{
win
.
document
.
documentURI
}
)
;
if
(
win
.
document
.
documentURI
=
=
=
"
chrome
:
/
/
mozapps
/
content
/
downloads
/
unknownContentType
.
xul
"
)
{
Services
.
ww
.
unregisterNotification
(
onOpen
)
;
executeSoon
(
function
(
)
{
setTimeout
(
function
(
)
{
const
button
=
win
.
document
.
documentElement
.
getButton
(
buttonAction
)
;
button
.
disabled
=
false
;
info
(
clicking
{
buttonAction
}
button
)
;
button
.
click
(
)
;
resolve
(
)
;
}
0
)
;
}
)
;
}
}
{
once
:
true
}
)
;
}
}
)
;
}
)
;
}
async
function
performCanceledDownload
(
tab
path
)
{
info
(
"
watching
for
download
popup
"
)
;
const
cancelDownload
=
promiseClickDownloadDialogButton
(
"
cancel
"
)
;
info
(
triggering
download
of
"
{
path
}
"
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
path
function
(
path
)
{
content
.
wrappedJSObject
.
trackStreamClosure
(
path
)
;
const
link
=
content
.
document
.
createElement
(
'
a
'
)
;
link
.
href
=
path
;
link
.
download
=
path
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
info
(
"
waiting
for
download
popup
"
)
;
await
cancelDownload
;
ok
(
true
"
canceled
download
"
)
;
info
(
wait
for
the
{
path
}
stream
to
close
.
)
;
const
why
=
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
path
function
(
path
)
{
return
content
.
wrappedJSObject
.
streamClosed
[
path
]
.
promise
;
}
)
;
is
(
why
.
why
"
canceled
"
"
Ensure
the
stream
canceled
instead
of
timing
out
.
"
)
;
info
(
Cancellation
reason
:
{
why
.
message
}
after
{
why
.
ticks
}
ticks
)
;
}
const
gTestRoot
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
const
PAGE_URL
=
{
gTestRoot
}
download_canceled
/
page_download_canceled
.
html
;
add_task
(
async
function
interruptedDownloads
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
'
set
'
:
[
[
'
dom
.
serviceWorkers
.
enabled
'
true
]
[
'
dom
.
serviceWorkers
.
exemptFromPerDomainMax
'
true
]
[
'
dom
.
serviceWorkers
.
testing
.
enabled
'
true
]
[
"
javascript
.
options
.
streams
"
true
]
[
"
dom
.
streams
.
enabled
"
true
]
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
PAGE_URL
}
)
;
const
controlled
=
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
function
(
)
{
return
content
.
wrappedJSObject
.
controlled
;
}
)
;
is
(
controlled
"
controlled
"
"
page
became
controlled
"
)
;
await
performCanceledDownload
(
tab
"
sw
-
passthrough
-
download
"
)
;
await
performCanceledDownload
(
tab
"
sw
-
stream
-
download
"
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
null
function
(
)
{
return
content
.
wrappedJSObject
.
registration
.
unregister
(
)
;
}
)
;
await
BrowserTestUtils
.
removeTab
(
tab
)
;
await
clearDownloads
(
)
;
}
)
;
