const
{
Downloads
}
=
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
Downloads
.
jsm
"
)
;
async
function
clearDownloads
(
)
{
const
downloads
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
downloads
.
removeFinished
(
)
;
}
function
promiseClickDownloadDialogButton
(
buttonAction
)
{
const
uri
=
"
chrome
:
/
/
mozapps
/
content
/
downloads
/
unknownContentType
.
xhtml
"
;
return
BrowserTestUtils
.
promiseAlertDialogOpen
(
buttonAction
uri
{
async
callback
(
win
)
{
await
TestUtils
.
waitForTick
(
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
0
)
)
;
const
button
=
win
.
document
.
getElementById
(
"
unknownContentType
"
)
.
getButton
(
buttonAction
)
;
button
.
disabled
=
false
;
info
(
clicking
{
buttonAction
}
button
)
;
button
.
click
(
)
;
}
}
)
;
}
async
function
performCanceledDownload
(
tab
path
)
{
let
cancelledDownload
;
if
(
Services
.
prefs
.
getBoolPref
(
"
browser
.
download
.
always_ask_before_handling_new_types
"
false
)
)
{
cancelledDownload
=
promiseClickDownloadDialogButton
(
"
cancel
"
)
;
info
(
"
waiting
for
download
popup
"
)
;
}
else
{
let
downloadView
;
cancelledDownload
=
new
Promise
(
resolve
=
>
{
downloadView
=
{
onDownloadAdded
(
aDownload
)
{
aDownload
.
cancel
(
)
;
resolve
(
)
;
}
}
;
}
)
;
const
downloadList
=
await
Downloads
.
getList
(
Downloads
.
ALL
)
;
await
downloadList
.
addView
(
downloadView
)
;
}
info
(
triggering
download
of
"
{
path
}
"
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
path
]
function
(
path
)
{
content
.
wrappedJSObject
.
trackStreamClosure
(
path
)
;
const
link
=
content
.
document
.
createElement
(
"
a
"
)
;
link
.
href
=
path
;
link
.
download
=
path
;
content
.
document
.
body
.
appendChild
(
link
)
;
link
.
click
(
)
;
}
)
;
await
cancelledDownload
;
info
(
"
cancelled
download
"
)
;
info
(
wait
for
the
{
path
}
stream
to
close
.
)
;
const
why
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
path
]
function
(
path
)
{
return
content
.
wrappedJSObject
.
streamClosed
[
path
]
.
promise
;
}
)
;
is
(
why
.
why
"
canceled
"
"
Ensure
the
stream
canceled
instead
of
timing
out
.
"
)
;
info
(
Cancellation
reason
:
{
why
.
message
}
after
{
why
.
ticks
}
ticks
)
;
}
const
gTestRoot
=
getRootDirectory
(
gTestPath
)
.
replace
(
"
chrome
:
/
/
mochitests
/
content
/
"
"
http
:
/
/
mochi
.
test
:
8888
/
"
)
;
const
PAGE_URL
=
{
gTestRoot
}
download_canceled
/
page_download_canceled
.
html
;
add_task
(
async
function
interruptedDownloads
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
serviceWorkers
.
enabled
"
true
]
[
"
dom
.
serviceWorkers
.
exemptFromPerDomainMax
"
true
]
[
"
dom
.
serviceWorkers
.
testing
.
enabled
"
true
]
]
}
)
;
const
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
PAGE_URL
}
)
;
const
controlled
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
function
(
)
{
return
content
.
wrappedJSObject
.
controlled
;
}
)
;
is
(
controlled
"
controlled
"
"
page
became
controlled
"
)
;
await
performCanceledDownload
(
tab
"
sw
-
passthrough
-
download
"
)
;
await
performCanceledDownload
(
tab
"
sw
-
stream
-
download
"
)
;
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
function
(
)
{
return
content
.
wrappedJSObject
.
registration
.
unregister
(
)
;
}
)
;
BrowserTestUtils
.
removeTab
(
tab
)
;
await
clearDownloads
(
)
;
}
)
;
