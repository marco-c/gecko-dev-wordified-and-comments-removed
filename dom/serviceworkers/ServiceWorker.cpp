#
include
"
ServiceWorker
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
RemoteServiceWorkerImpl
.
h
"
#
include
"
ServiceWorkerCloneData
.
h
"
#
include
"
ServiceWorkerImpl
.
h
"
#
include
"
ServiceWorkerManager
.
h
"
#
include
"
ServiceWorkerPrivate
.
h
"
#
include
"
ServiceWorkerRegistration
.
h
"
#
include
"
ServiceWorkerUtils
.
h
"
#
include
"
mozilla
/
dom
/
ClientIPCTypes
.
h
"
#
include
"
mozilla
/
dom
/
ClientState
.
h
"
#
include
"
mozilla
/
dom
/
MessagePortBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerGlobalScopeBinding
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
ifdef
XP_WIN
#
undef
PostMessage
#
endif
using
mozilla
:
:
ErrorResult
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
dom
{
bool
ServiceWorkerVisible
(
JSContext
*
aCx
JSObject
*
aObj
)
{
if
(
NS_IsMainThread
(
)
)
{
return
StaticPrefs
:
:
dom_serviceWorkers_enabled
(
)
;
}
return
IS_INSTANCE_OF
(
ServiceWorkerGlobalScope
aObj
)
;
}
already_AddRefed
<
ServiceWorker
>
ServiceWorker
:
:
Create
(
nsIGlobalObject
*
aOwner
const
ServiceWorkerDescriptor
&
aDescriptor
)
{
RefPtr
<
ServiceWorker
>
ref
;
RefPtr
<
ServiceWorker
:
:
Inner
>
inner
;
if
(
ServiceWorkerParentInterceptEnabled
(
)
)
{
inner
=
new
RemoteServiceWorkerImpl
(
aDescriptor
)
;
}
else
{
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE
(
swm
nullptr
)
;
RefPtr
<
ServiceWorkerRegistrationInfo
>
reg
=
swm
-
>
GetRegistration
(
aDescriptor
.
PrincipalInfo
(
)
aDescriptor
.
Scope
(
)
)
;
NS_ENSURE_TRUE
(
reg
nullptr
)
;
RefPtr
<
ServiceWorkerInfo
>
info
=
reg
-
>
GetByDescriptor
(
aDescriptor
)
;
NS_ENSURE_TRUE
(
info
nullptr
)
;
inner
=
new
ServiceWorkerImpl
(
info
reg
)
;
}
NS_ENSURE_TRUE
(
inner
nullptr
)
;
ref
=
new
ServiceWorker
(
aOwner
aDescriptor
inner
)
;
return
ref
.
forget
(
)
;
}
ServiceWorker
:
:
ServiceWorker
(
nsIGlobalObject
*
aGlobal
const
ServiceWorkerDescriptor
&
aDescriptor
ServiceWorker
:
:
Inner
*
aInner
)
:
DOMEventTargetHelper
(
aGlobal
)
mDescriptor
(
aDescriptor
)
mInner
(
aInner
)
mLastNotifiedState
(
ServiceWorkerState
:
:
Installing
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aGlobal
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mInner
)
;
KeepAliveIfHasListenersFor
(
NS_LITERAL_STRING
(
"
statechange
"
)
)
;
mInner
-
>
AddServiceWorker
(
this
)
;
RefPtr
<
ServiceWorkerRegistration
>
reg
=
aGlobal
-
>
GetServiceWorkerRegistration
(
ServiceWorkerRegistrationDescriptor
(
mDescriptor
.
RegistrationId
(
)
mDescriptor
.
RegistrationVersion
(
)
mDescriptor
.
PrincipalInfo
(
)
mDescriptor
.
Scope
(
)
ServiceWorkerUpdateViaCache
:
:
Imports
)
)
;
if
(
reg
)
{
MaybeAttachToRegistration
(
reg
)
;
}
else
{
RefPtr
<
ServiceWorker
>
self
=
this
;
mInner
-
>
GetRegistration
(
[
self
=
std
:
:
move
(
self
)
]
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
nsIGlobalObject
*
global
=
self
-
>
GetParentObject
(
)
;
NS_ENSURE_TRUE_VOID
(
global
)
;
RefPtr
<
ServiceWorkerRegistration
>
reg
=
global
-
>
GetOrCreateServiceWorkerRegistration
(
aDescriptor
)
;
self
-
>
MaybeAttachToRegistration
(
reg
)
;
}
[
]
(
ErrorResult
&
&
aRv
)
{
aRv
.
SuppressException
(
)
;
}
)
;
}
}
ServiceWorker
:
:
~
ServiceWorker
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mInner
-
>
RemoveServiceWorker
(
this
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
ServiceWorker
DOMEventTargetHelper
mRegistration
)
;
NS_IMPL_ADDREF_INHERITED
(
ServiceWorker
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
ServiceWorker
DOMEventTargetHelper
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ServiceWorker
)
NS_INTERFACE_MAP_ENTRY
(
ServiceWorker
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
JSObject
*
ServiceWorker
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
ServiceWorker_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
ServiceWorkerState
ServiceWorker
:
:
State
(
)
const
{
return
mDescriptor
.
State
(
)
;
}
void
ServiceWorker
:
:
SetState
(
ServiceWorkerState
aState
)
{
NS_ENSURE_TRUE_VOID
(
aState
>
=
mDescriptor
.
State
(
)
)
;
mDescriptor
.
SetState
(
aState
)
;
}
void
ServiceWorker
:
:
MaybeDispatchStateChangeEvent
(
)
{
if
(
mDescriptor
.
State
(
)
<
=
mLastNotifiedState
|
|
!
GetParentObject
(
)
)
{
return
;
}
mLastNotifiedState
=
mDescriptor
.
State
(
)
;
DOMEventTargetHelper
:
:
DispatchTrustedEvent
(
NS_LITERAL_STRING
(
"
statechange
"
)
)
;
if
(
mLastNotifiedState
=
=
ServiceWorkerState
:
:
Redundant
)
{
IgnoreKeepAliveIfHasListenersFor
(
NS_LITERAL_STRING
(
"
statechange
"
)
)
;
}
}
void
ServiceWorker
:
:
GetScriptURL
(
nsString
&
aURL
)
const
{
CopyUTF8toUTF16
(
mDescriptor
.
ScriptURL
(
)
aURL
)
;
}
void
ServiceWorker
:
:
PostMessage
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
Sequence
<
JSObject
*
>
&
aTransferable
ErrorResult
&
aRv
)
{
if
(
State
(
)
=
=
ServiceWorkerState
:
:
Redundant
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsPIDOMWindowInner
*
window
=
GetOwner
(
)
;
if
(
NS_WARN_IF
(
!
window
|
|
!
window
-
>
GetExtantDoc
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
auto
storageAllowed
=
StorageAllowedForWindow
(
window
)
;
if
(
storageAllowed
!
=
StorageAccess
:
:
eAllow
)
{
ServiceWorkerManager
:
:
LocalizeAndReportToAllClients
(
mDescriptor
.
Scope
(
)
"
ServiceWorkerPostMessageStorageError
"
nsTArray
<
nsString
>
{
NS_ConvertUTF8toUTF16
(
mDescriptor
.
Scope
(
)
)
}
)
;
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
Maybe
<
ClientInfo
>
clientInfo
=
window
-
>
GetClientInfo
(
)
;
Maybe
<
ClientState
>
clientState
=
window
-
>
GetClientState
(
)
;
if
(
NS_WARN_IF
(
clientInfo
.
isNothing
(
)
|
|
clientState
.
isNothing
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
transferable
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
aRv
=
nsContentUtils
:
:
CreateJSValueFromSequenceOfObject
(
aCx
aTransferable
&
transferable
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
RefPtr
<
ServiceWorkerCloneData
>
data
=
new
ServiceWorkerCloneData
(
)
;
data
-
>
Write
(
aCx
aMessage
transferable
JS
:
:
CloneDataPolicy
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
mInner
-
>
PostMessage
(
std
:
:
move
(
data
)
clientInfo
.
ref
(
)
clientState
.
ref
(
)
)
;
}
void
ServiceWorker
:
:
PostMessage
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
PostMessageOptions
&
aOptions
ErrorResult
&
aRv
)
{
PostMessage
(
aCx
aMessage
aOptions
.
mTransfer
aRv
)
;
}
const
ServiceWorkerDescriptor
&
ServiceWorker
:
:
Descriptor
(
)
const
{
return
mDescriptor
;
}
void
ServiceWorker
:
:
DisconnectFromOwner
(
)
{
DOMEventTargetHelper
:
:
DisconnectFromOwner
(
)
;
}
void
ServiceWorker
:
:
MaybeAttachToRegistration
(
ServiceWorkerRegistration
*
aRegistration
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aRegistration
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mRegistration
)
;
if
(
!
aRegistration
-
>
Descriptor
(
)
.
HasWorker
(
mDescriptor
)
)
{
SetState
(
ServiceWorkerState
:
:
Redundant
)
;
MaybeDispatchStateChangeEvent
(
)
;
return
;
}
mRegistration
=
aRegistration
;
}
}
}
