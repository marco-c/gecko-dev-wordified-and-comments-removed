#
ifndef
nsDeviceStorage_h
#
define
nsDeviceStorage_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
devicestorage
/
DeviceStorageRequestChild
.
h
"
#
include
"
DOMRequest
.
h
"
#
include
"
DOMCursor
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDOMClassInfoID
.
h
"
#
include
"
nsIClassInfo
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsWeakPtr
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
prtime
.
h
"
#
include
"
DeviceStorage
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
class
BlobImpl
;
class
DeviceStorageParams
;
}
}
class
nsDOMDeviceStorage
;
class
DeviceStorageCursorRequest
;
#
ifdef
DS_LOGGING
#
define
DS_LOG_DEBUG
(
msg
.
.
.
)
printf_stderr
(
"
[
%
s
:
%
d
]
"
msg
"
\
n
"
__func__
__LINE__
#
#
__VA_ARGS__
)
#
define
DS_LOG_INFO
DS_LOG_DEBUG
#
define
DS_LOG_WARN
DS_LOG_DEBUG
#
define
DS_LOG_ERROR
DS_LOG_DEBUG
#
else
#
define
DS_LOG_DEBUG
(
msg
.
.
.
)
#
define
DS_LOG_INFO
(
msg
.
.
.
)
#
define
DS_LOG_WARN
(
msg
.
.
.
)
#
define
DS_LOG_ERROR
(
msg
.
.
.
)
#
endif
#
define
POST_ERROR_EVENT_FILE_EXISTS
"
NoModificationAllowedError
"
#
define
POST_ERROR_EVENT_FILE_DOES_NOT_EXIST
"
NotFoundError
"
#
define
POST_ERROR_EVENT_FILE_NOT_ENUMERABLE
"
TypeMismatchError
"
#
define
POST_ERROR_EVENT_PERMISSION_DENIED
"
SecurityError
"
#
define
POST_ERROR_EVENT_ILLEGAL_TYPE
"
TypeMismatchError
"
#
define
POST_ERROR_EVENT_UNKNOWN
"
Unknown
"
enum
DeviceStorageRequestType
{
DEVICE_STORAGE_REQUEST_READ
DEVICE_STORAGE_REQUEST_WRITE
DEVICE_STORAGE_REQUEST_APPEND
DEVICE_STORAGE_REQUEST_CREATE
DEVICE_STORAGE_REQUEST_DELETE
DEVICE_STORAGE_REQUEST_WATCH
DEVICE_STORAGE_REQUEST_FREE_SPACE
DEVICE_STORAGE_REQUEST_USED_SPACE
DEVICE_STORAGE_REQUEST_AVAILABLE
DEVICE_STORAGE_REQUEST_STATUS
DEVICE_STORAGE_REQUEST_FORMAT
DEVICE_STORAGE_REQUEST_MOUNT
DEVICE_STORAGE_REQUEST_UNMOUNT
DEVICE_STORAGE_REQUEST_CREATEFD
DEVICE_STORAGE_REQUEST_CURSOR
}
;
enum
DeviceStorageAccessType
{
DEVICE_STORAGE_ACCESS_READ
DEVICE_STORAGE_ACCESS_WRITE
DEVICE_STORAGE_ACCESS_CREATE
DEVICE_STORAGE_ACCESS_UNDEFINED
DEVICE_STORAGE_ACCESS_COUNT
}
;
class
DeviceStorageUsedSpaceCache
final
{
public
:
static
DeviceStorageUsedSpaceCache
*
CreateOrGet
(
)
;
DeviceStorageUsedSpaceCache
(
)
;
~
DeviceStorageUsedSpaceCache
(
)
;
class
InvalidateRunnable
final
:
public
mozilla
:
:
Runnable
{
public
:
InvalidateRunnable
(
DeviceStorageUsedSpaceCache
*
aCache
const
nsAString
&
aStorageName
)
:
mCache
(
aCache
)
mStorageName
(
aStorageName
)
{
}
~
InvalidateRunnable
(
)
{
}
NS_IMETHOD
Run
(
)
override
{
RefPtr
<
DeviceStorageUsedSpaceCache
:
:
CacheEntry
>
cacheEntry
;
cacheEntry
=
mCache
-
>
GetCacheEntry
(
mStorageName
)
;
if
(
cacheEntry
)
{
cacheEntry
-
>
mDirty
=
true
;
}
return
NS_OK
;
}
private
:
DeviceStorageUsedSpaceCache
*
mCache
;
nsString
mStorageName
;
}
;
void
Invalidate
(
const
nsAString
&
aStorageName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mIOThread
)
;
mIOThread
-
>
Dispatch
(
new
InvalidateRunnable
(
this
aStorageName
)
NS_DISPATCH_NORMAL
)
;
}
void
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mIOThread
)
;
mIOThread
-
>
Dispatch
(
mozilla
:
:
Move
(
aRunnable
)
NS_DISPATCH_NORMAL
)
;
}
nsresult
AccumUsedSizes
(
const
nsAString
&
aStorageName
uint64_t
*
aPictureSize
uint64_t
*
aVideosSize
uint64_t
*
aMusicSize
uint64_t
*
aTotalSize
)
;
void
SetUsedSizes
(
const
nsAString
&
aStorageName
uint64_t
aPictureSize
uint64_t
aVideosSize
uint64_t
aMusicSize
uint64_t
aTotalSize
)
;
private
:
friend
class
InvalidateRunnable
;
struct
CacheEntry
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
CacheEntry
)
bool
mDirty
;
nsString
mStorageName
;
int64_t
mFreeBytes
;
uint64_t
mPicturesUsedSize
;
uint64_t
mVideosUsedSize
;
uint64_t
mMusicUsedSize
;
uint64_t
mTotalUsedSize
;
private
:
~
CacheEntry
(
)
{
}
}
;
already_AddRefed
<
CacheEntry
>
GetCacheEntry
(
const
nsAString
&
aStorageName
)
;
nsTArray
<
RefPtr
<
CacheEntry
>
>
mCacheEntries
;
nsCOMPtr
<
nsIThread
>
mIOThread
;
static
mozilla
:
:
StaticAutoPtr
<
DeviceStorageUsedSpaceCache
>
sDeviceStorageUsedSpaceCache
;
}
;
class
DeviceStorageTypeChecker
final
{
public
:
static
DeviceStorageTypeChecker
*
CreateOrGet
(
)
;
DeviceStorageTypeChecker
(
)
;
~
DeviceStorageTypeChecker
(
)
;
void
InitFromBundle
(
nsIStringBundle
*
aBundle
)
;
bool
Check
(
const
nsAString
&
aType
mozilla
:
:
dom
:
:
BlobImpl
*
aBlob
)
;
bool
Check
(
const
nsAString
&
aType
nsIFile
*
aFile
)
;
bool
Check
(
const
nsAString
&
aType
const
nsString
&
aPath
)
;
void
GetTypeFromFile
(
nsIFile
*
aFile
nsAString
&
aType
)
;
void
GetTypeFromFileName
(
const
nsAString
&
aFileName
nsAString
&
aType
)
;
static
nsresult
GetPermissionForType
(
const
nsAString
&
aType
nsACString
&
aPermissionResult
)
;
static
nsresult
GetAccessForRequest
(
const
DeviceStorageRequestType
aRequestType
nsACString
&
aAccessResult
)
;
static
nsresult
GetAccessForIndex
(
size_t
aAccessIndex
nsACString
&
aAccessResult
)
;
static
size_t
GetAccessIndexForRequest
(
const
DeviceStorageRequestType
aRequestType
)
;
static
bool
IsVolumeBased
(
const
nsAString
&
aType
)
;
static
bool
IsSharedMediaRoot
(
const
nsAString
&
aType
)
;
private
:
nsString
mPicturesExtensions
;
nsString
mVideosExtensions
;
nsString
mMusicExtensions
;
static
mozilla
:
:
StaticAutoPtr
<
DeviceStorageTypeChecker
>
sDeviceStorageTypeChecker
;
}
;
class
nsDOMDeviceStorageCursor
final
:
public
mozilla
:
:
dom
:
:
DOMCursor
{
public
:
NS_FORWARD_NSIDOMDOMCURSOR
(
mozilla
:
:
dom
:
:
DOMCursor
:
:
)
virtual
void
Continue
(
mozilla
:
:
ErrorResult
&
aRv
)
override
;
nsDOMDeviceStorageCursor
(
nsIGlobalObject
*
aGlobal
DeviceStorageCursorRequest
*
aRequest
)
;
void
FireSuccess
(
JS
:
:
Handle
<
JS
:
:
Value
>
aResult
)
;
void
FireError
(
const
nsString
&
aReason
)
;
void
FireDone
(
)
;
private
:
virtual
~
nsDOMDeviceStorageCursor
(
)
;
bool
mOkToCallContinue
;
RefPtr
<
DeviceStorageCursorRequest
>
mRequest
;
}
;
class
DeviceStorageRequestManager
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
DeviceStorageRequestManager
)
static
const
uint32_t
INVALID_ID
=
0
;
DeviceStorageRequestManager
(
)
;
bool
IsOwningThread
(
)
;
nsresult
DispatchToOwningThread
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
void
StorePermission
(
size_t
aAccess
bool
aAllow
)
;
uint32_t
CheckPermission
(
size_t
aAccess
)
;
uint32_t
Create
(
nsDOMDeviceStorage
*
aDeviceStorage
mozilla
:
:
dom
:
:
DOMRequest
*
*
aRequest
)
;
uint32_t
Create
(
nsDOMDeviceStorage
*
aDeviceStorage
DeviceStorageCursorRequest
*
aRequest
nsDOMDeviceStorageCursor
*
*
aCursor
)
;
nsresult
Resolve
(
uint32_t
aId
bool
aForceDispatch
)
;
nsresult
Resolve
(
uint32_t
aId
const
nsString
&
aValue
bool
aForceDispatch
)
;
nsresult
Resolve
(
uint32_t
aId
uint64_t
aValue
bool
aForceDispatch
)
;
nsresult
Resolve
(
uint32_t
aId
DeviceStorageFile
*
aValue
bool
aForceDispatch
)
;
nsresult
Resolve
(
uint32_t
aId
mozilla
:
:
dom
:
:
BlobImpl
*
aValue
bool
aForceDispatch
)
;
nsresult
Reject
(
uint32_t
aId
const
nsString
&
aReason
)
;
nsresult
Reject
(
uint32_t
aId
const
char
*
aReason
)
;
void
Shutdown
(
)
;
private
:
DeviceStorageRequestManager
(
const
DeviceStorageRequestManager
&
)
=
delete
;
DeviceStorageRequestManager
&
operator
=
(
const
DeviceStorageRequestManager
&
)
=
delete
;
struct
ListEntry
{
RefPtr
<
mozilla
:
:
dom
:
:
DOMRequest
>
mRequest
;
uint32_t
mId
;
bool
mCursor
;
}
;
typedef
nsTArray
<
ListEntry
>
ListType
;
typedef
ListType
:
:
index_type
ListIndex
;
virtual
~
DeviceStorageRequestManager
(
)
;
uint32_t
CreateInternal
(
mozilla
:
:
dom
:
:
DOMRequest
*
aRequest
bool
aCursor
)
;
nsresult
ResolveInternal
(
ListIndex
aIndex
JS
:
:
HandleValue
aResult
)
;
nsresult
RejectInternal
(
ListIndex
aIndex
const
nsString
&
aReason
)
;
nsresult
DispatchOrAbandon
(
uint32_t
aId
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
;
ListType
:
:
index_type
Find
(
uint32_t
aId
)
;
nsCOMPtr
<
nsIThread
>
mOwningThread
;
ListType
mPending
;
mozilla
:
:
Mutex
mMutex
;
uint32_t
mPermissionCache
[
DEVICE_STORAGE_ACCESS_COUNT
]
;
bool
mShutdown
;
static
mozilla
:
:
Atomic
<
uint32_t
>
sLastRequestId
;
}
;
class
DeviceStorageRequest
:
public
mozilla
:
:
Runnable
{
protected
:
DeviceStorageRequest
(
)
;
public
:
virtual
void
Initialize
(
DeviceStorageRequestManager
*
aManager
already_AddRefed
<
DeviceStorageFile
>
&
&
aFile
uint32_t
aRequest
)
;
virtual
void
Initialize
(
DeviceStorageRequestManager
*
aManager
already_AddRefed
<
DeviceStorageFile
>
&
&
aFile
uint32_t
aRequest
mozilla
:
:
dom
:
:
BlobImpl
*
aBlob
)
;
virtual
void
Initialize
(
DeviceStorageRequestManager
*
aManager
already_AddRefed
<
DeviceStorageFile
>
&
&
aFile
uint32_t
aRequest
DeviceStorageFileDescriptor
*
aDSFileDescriptor
)
;
DeviceStorageAccessType
GetAccess
(
)
const
;
void
GetStorageType
(
nsAString
&
aType
)
const
;
DeviceStorageFile
*
GetFile
(
)
const
;
DeviceStorageFileDescriptor
*
GetFileDescriptor
(
)
const
;
DeviceStorageRequestManager
*
GetManager
(
)
const
;
uint32_t
GetId
(
)
const
{
return
mId
;
}
void
PermissionCacheMissed
(
)
{
mPermissionCached
=
false
;
}
nsresult
Cancel
(
)
;
nsresult
Allow
(
)
;
nsresult
Resolve
(
)
{
uint32_t
id
=
mId
;
mId
=
DeviceStorageRequestManager
:
:
INVALID_ID
;
return
mManager
-
>
Resolve
(
id
true
)
;
}
template
<
class
T
>
nsresult
Resolve
(
T
aValue
)
{
uint32_t
id
=
mId
;
if
(
!
mMultipleResolve
)
{
mId
=
DeviceStorageRequestManager
:
:
INVALID_ID
;
}
return
mManager
-
>
Resolve
(
id
aValue
ForceDispatch
(
)
)
;
}
template
<
class
T
>
nsresult
Reject
(
T
aReason
)
{
uint32_t
id
=
mId
;
mId
=
DeviceStorageRequestManager
:
:
INVALID_ID
;
return
mManager
-
>
Reject
(
id
aReason
)
;
}
protected
:
bool
ForceDispatch
(
)
const
{
return
!
mSendToParent
&
&
mPermissionCached
;
}
virtual
~
DeviceStorageRequest
(
)
;
virtual
nsresult
Prepare
(
)
;
virtual
nsresult
CreateSendParams
(
mozilla
:
:
dom
:
:
DeviceStorageParams
&
aParams
)
;
nsresult
AllowInternal
(
)
;
nsresult
SendToParentProcess
(
)
;
RefPtr
<
DeviceStorageRequestManager
>
mManager
;
RefPtr
<
DeviceStorageFile
>
mFile
;
uint32_t
mId
;
RefPtr
<
mozilla
:
:
dom
:
:
BlobImpl
>
mBlob
;
RefPtr
<
DeviceStorageFileDescriptor
>
mDSFileDescriptor
;
DeviceStorageAccessType
mAccess
;
bool
mSendToParent
;
bool
mUseMainThread
;
bool
mUseStreamTransport
;
bool
mCheckFile
;
bool
mCheckBlob
;
bool
mMultipleResolve
;
bool
mPermissionCached
;
private
:
DeviceStorageRequest
(
const
DeviceStorageRequest
&
)
=
delete
;
DeviceStorageRequest
&
operator
=
(
const
DeviceStorageRequest
&
)
=
delete
;
}
;
class
DeviceStorageCursorRequest
final
:
public
DeviceStorageRequest
{
public
:
DeviceStorageCursorRequest
(
)
;
using
DeviceStorageRequest
:
:
Initialize
;
virtual
void
Initialize
(
DeviceStorageRequestManager
*
aManager
already_AddRefed
<
DeviceStorageFile
>
&
&
aFile
uint32_t
aRequest
PRTime
aSince
)
;
void
AddFiles
(
size_t
aSize
)
;
void
AddFile
(
already_AddRefed
<
DeviceStorageFile
>
aFile
)
;
nsresult
Continue
(
)
;
NS_IMETHOD
Run
(
)
override
;
protected
:
virtual
~
DeviceStorageCursorRequest
(
)
{
}
;
nsresult
SendContinueToParentProcess
(
)
;
nsresult
CreateSendParams
(
mozilla
:
:
dom
:
:
DeviceStorageParams
&
aParams
)
override
;
size_t
mIndex
;
PRTime
mSince
;
nsString
mStorageType
;
nsTArray
<
RefPtr
<
DeviceStorageFile
>
>
mFiles
;
}
;
#
endif
