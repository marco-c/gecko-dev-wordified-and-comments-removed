#
include
<
cmath
>
#
include
"
GeolocationUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
{
double
CalculateDeltaInMeter
(
double
aLat
double
aLon
double
aLastLat
double
aLastLon
)
{
const
double
radsInDeg
=
M_PI
/
180
.
0
;
const
double
rNewLat
=
aLat
*
radsInDeg
;
const
double
rNewLon
=
aLon
*
radsInDeg
;
const
double
rOldLat
=
aLastLat
*
radsInDeg
;
const
double
rOldLon
=
aLastLon
*
radsInDeg
;
double
cosDelta
=
(
sin
(
rNewLat
)
*
sin
(
rOldLat
)
)
+
(
cos
(
rNewLat
)
*
cos
(
rOldLat
)
*
cos
(
rOldLon
-
rNewLon
)
)
;
if
(
cosDelta
>
1
.
0
)
{
cosDelta
=
1
.
0
;
}
else
if
(
cosDelta
<
-
1
.
0
)
{
cosDelta
=
-
1
.
0
;
}
return
acos
(
cosDelta
)
*
6378137
;
}
bool
DecodeGsmDefaultToString
(
UniquePtr
<
char
[
]
>
&
aMessage
nsString
&
aWideStr
)
{
if
(
!
aMessage
|
|
!
aMessage
.
get
(
)
)
{
return
false
;
}
int
lengthBytes
=
strlen
(
aMessage
.
get
(
)
)
;
if
(
lengthBytes
<
=
0
)
{
return
false
;
}
int
lengthSeptets
=
(
lengthBytes
*
8
)
/
7
;
if
(
lengthBytes
%
7
=
=
0
)
{
char
PADDING_CHAR
=
0x00
;
if
(
aMessage
[
lengthBytes
-
1
]
>
>
1
=
=
PADDING_CHAR
)
{
lengthSeptets
-
=
1
;
}
}
bool
prevCharWasEscape
=
false
;
nsString
languageTableToChar
=
NS_LITERAL_STRING
(
"
\
u00a3
\
u00a5
\
u00e8
\
u00e9
\
u00f9
\
u00ec
\
u00f2
\
u00c7
\
n
\
u00d8
\
u00f8
\
r
\
u00c5
\
u00e5
"
"
\
u0394_
\
u03a6
\
u0393
\
u039b
\
u03a9
\
u03a0
\
u03a8
\
u03a3
\
u0398
\
u039e
?
\
u00c6
\
u00e6
\
u00df
\
u00c9
"
"
!
\
"
#
\
u00a4
%
&
'
(
)
*
+
-
.
/
"
"
0123456789
:
;
<
=
>
?
"
"
\
u00a1ABCDEFGHIJKLMNO
"
"
PQRSTUVWXYZ
\
u00c4
\
u00d6
\
u00d1
\
u00dc
\
u00a7
"
"
\
u00bfabcdefghijklmno
"
"
pqrstuvwxyz
\
u00e4
\
u00f6
\
u00f1
\
u00fc
\
u00e0
"
)
;
nsString
shiftTableToChar
=
NS_LITERAL_STRING
(
"
\
u000c
\
ufffe
"
"
^
\
uffff
"
"
{
}
\
\
"
"
[
~
]
"
"
|
"
"
"
"
\
u20ac
"
"
"
)
;
nsString
output
;
for
(
int
i
=
0
;
i
<
lengthSeptets
;
i
+
+
)
{
int
bitOffset
=
7
*
i
;
int
byteOffset
=
bitOffset
/
8
;
int
shift
=
bitOffset
%
8
;
int
gsmVal
;
gsmVal
=
0x7f
&
(
aMessage
[
byteOffset
]
>
>
shift
)
;
if
(
shift
>
1
)
{
gsmVal
&
=
0x7f
>
>
(
shift
-
1
)
;
gsmVal
|
=
0x7f
&
(
aMessage
[
byteOffset
+
1
]
<
<
(
8
-
shift
)
)
;
}
const
char
GSM_EXTENDED_ESCAPE
=
0x1B
;
if
(
prevCharWasEscape
)
{
if
(
gsmVal
=
=
GSM_EXTENDED_ESCAPE
)
{
output
.
AppendLiteral
(
"
"
)
;
}
else
{
char16_t
c
=
shiftTableToChar
.
CharAt
(
gsmVal
)
;
if
(
c
=
=
MOZ_UTF16
(
'
'
)
)
{
c
=
languageTableToChar
.
CharAt
(
gsmVal
)
;
}
output
+
=
c
;
}
prevCharWasEscape
=
false
;
}
else
if
(
gsmVal
=
=
GSM_EXTENDED_ESCAPE
)
{
prevCharWasEscape
=
true
;
}
else
{
char16_t
c
=
languageTableToChar
.
CharAt
(
gsmVal
)
;
output
+
=
c
;
}
}
aWideStr
=
output
;
return
true
;
}
nsString
DecodeNIString
(
const
char
*
aMessage
GpsNiEncodingType
aEncodingType
)
{
nsString
wide_str
;
bool
little_endian
=
true
;
int
starthexIndex
=
0
byteIndex
=
0
;
int
hexstring_length
=
strlen
(
aMessage
)
;
if
(
(
hexstring_length
=
=
0
)
|
|
(
hexstring_length
%
2
!
=
0
)
)
{
nsContentUtils
:
:
LogMessageToConsole
(
"
DecodeNIString
-
Failed
to
decode
string
(
length
%
d
)
"
hexstring_length
)
;
wide_str
.
AssignLiteral
(
"
Failed
to
decode
string
.
"
)
;
return
wide_str
;
}
int
byteArrayLen
=
(
hexstring_length
/
2
)
;
if
(
aEncodingType
=
=
GPS_ENC_SUPL_UTF8
|
|
aEncodingType
=
=
GPS_ENC_SUPL_GSM_DEFAULT
)
{
byteArrayLen
+
=
1
;
}
else
if
(
aEncodingType
=
=
GPS_ENC_SUPL_UCS2
)
{
byteArrayLen
+
=
2
;
if
(
hexstring_length
>
=
4
)
{
const
char
bom_be
[
]
=
"
FEFF
"
;
const
char
bom_le
[
]
=
"
FFFE
"
;
if
(
memcmp
(
bom_be
aMessage
sizeof
(
bom_be
)
-
1
)
=
=
0
)
{
little_endian
=
false
;
starthexIndex
+
=
4
;
}
else
if
(
memcmp
(
bom_le
aMessage
sizeof
(
bom_le
)
-
1
)
=
=
0
)
{
starthexIndex
+
=
4
;
}
}
}
UniquePtr
<
char
[
]
>
byteArray
=
MakeUnique
<
char
[
]
>
(
byteArrayLen
)
;
for
(
;
starthexIndex
<
=
hexstring_length
-
4
;
starthexIndex
+
=
4
byteIndex
+
=
2
)
{
char
hexArray1
[
3
]
=
{
aMessage
[
starthexIndex
]
aMessage
[
starthexIndex
+
1
]
'
\
0
'
}
;
char
hexArray2
[
3
]
=
{
aMessage
[
starthexIndex
+
2
]
aMessage
[
starthexIndex
+
3
]
'
\
0
'
}
;
if
(
little_endian
)
{
byteArray
[
byteIndex
]
=
(
char
)
strtol
(
hexArray1
nullptr
16
)
;
byteArray
[
byteIndex
+
1
]
=
(
char
)
strtol
(
hexArray2
nullptr
16
)
;
}
else
{
byteArray
[
byteIndex
]
=
(
char
)
strtol
(
hexArray2
nullptr
16
)
;
byteArray
[
byteIndex
+
1
]
=
(
char
)
strtol
(
hexArray1
nullptr
16
)
;
}
}
if
(
starthexIndex
<
=
hexstring_length
-
2
)
{
char
hexArray
[
3
]
=
{
aMessage
[
starthexIndex
]
aMessage
[
starthexIndex
+
1
]
'
\
0
'
}
;
byteArray
[
byteIndex
]
=
(
char
)
strtol
(
hexArray
nullptr
16
)
;
}
if
(
aEncodingType
=
=
GPS_ENC_SUPL_UTF8
)
{
nsCString
str
(
byteArray
.
get
(
)
)
;
wide_str
.
Append
(
NS_ConvertUTF8toUTF16
(
str
)
)
;
}
else
if
(
aEncodingType
=
=
GPS_ENC_SUPL_UCS2
)
{
wide_str
.
Append
(
(
const
char16_t
*
)
byteArray
.
get
(
)
)
;
}
else
if
(
aEncodingType
=
=
GPS_ENC_SUPL_GSM_DEFAULT
)
{
if
(
!
DecodeGsmDefaultToString
(
byteArray
wide_str
)
)
{
nsContentUtils
:
:
LogMessageToConsole
(
"
DecodeNIString
-
Decode
Failed
!
"
)
;
wide_str
.
AssignLiteral
(
"
Failed
to
decode
string
"
)
;
}
}
else
{
nsContentUtils
:
:
LogMessageToConsole
(
"
DecodeNIString
-
UnknownEncoding
.
"
)
;
wide_str
.
AssignLiteral
(
"
Failed
to
decode
string
"
)
;
}
wide_str
.
ReplaceSubstring
(
MOZ_UTF16
(
"
\
\
"
)
MOZ_UTF16
(
"
\
\
\
\
"
)
)
;
wide_str
.
ReplaceSubstring
(
MOZ_UTF16
(
"
"
)
MOZ_UTF16
(
"
\
\
"
)
)
;
return
wide_str
;
}
}
