"
use
strict
"
;
importScripts
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
WorkerSimpleTest
.
js
"
)
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
ObjectUtils
.
jsm
"
)
;
importScripts
(
"
resource
:
/
/
gre
/
modules
/
osfile
.
jsm
"
)
;
self
.
onmessage
=
async
function
(
msg
)
{
const
tmpDir
=
OS
.
Constants
.
Path
.
tmpDir
;
await
test_api_is_available_on_worker
(
)
;
await
test_full_read_and_write
(
)
;
await
test_move_file
(
)
;
finish
(
)
;
info
(
"
test_ioutils_worker
.
xhtml
:
Test
finished
"
)
;
async
function
test_api_is_available_on_worker
(
)
{
ok
(
self
.
IOUtils
"
IOUtils
is
present
in
web
workers
"
)
;
}
async
function
test_full_read_and_write
(
)
{
const
tmpFileName
=
OS
.
Path
.
join
(
tmpDir
"
test_ioutils_numbers
.
tmp
"
)
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
const
bytesWritten
=
await
self
.
IOUtils
.
writeAtomic
(
tmpFileName
bytes
)
;
is
(
bytesWritten
50
"
IOUtils
:
:
writeAtomic
can
write
entire
byte
array
to
file
"
)
;
let
fileContents
=
await
self
.
IOUtils
.
read
(
tmpFileName
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes
fileContents
)
&
&
bytes
.
length
=
=
fileContents
.
length
"
IOUtils
:
:
read
can
read
back
entire
file
"
)
;
const
tooManyBytes
=
bytes
.
length
+
1
;
fileContents
=
await
self
.
IOUtils
.
read
(
tmpFileName
tooManyBytes
)
;
ok
(
ObjectUtils
.
deepEqual
(
bytes
fileContents
)
&
&
fileContents
.
length
=
=
bytes
.
length
"
IOUtils
:
:
read
can
read
entire
file
when
requested
maxBytes
is
too
large
"
)
;
cleanup
(
tmpFileName
)
;
}
async
function
test_move_file
(
)
{
const
src
=
OS
.
Path
.
join
(
tmpDir
"
test_move_file_src
.
tmp
"
)
;
const
dest
=
OS
.
Path
.
join
(
tmpDir
"
test_move_file_dest
.
tmp
"
)
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
await
self
.
IOUtils
.
writeAtomic
(
src
bytes
)
;
await
self
.
IOUtils
.
move
(
src
dest
)
;
ok
(
!
OS
.
File
.
exists
(
src
)
&
&
OS
.
File
.
exists
(
dest
)
"
IOUtils
:
:
move
can
move
files
from
a
worker
"
)
;
cleanup
(
dest
)
;
}
}
;
function
cleanup
(
.
.
.
files
)
{
files
.
forEach
(
file
=
>
{
OS
.
File
.
remove
(
file
)
;
ok
(
!
OS
.
File
.
exists
(
file
)
Removed
temporary
file
:
{
file
}
)
;
}
)
;
}
