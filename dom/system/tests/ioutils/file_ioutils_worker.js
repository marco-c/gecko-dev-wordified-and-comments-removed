"
use
strict
"
;
importScripts
(
"
chrome
:
/
/
mochikit
/
content
/
tests
/
SimpleTest
/
WorkerSimpleTest
.
js
"
)
;
importScripts
(
"
file_ioutils_test_fixtures
.
js
"
)
;
self
.
onmessage
=
async
function
(
)
{
const
tmpDir
=
await
PathUtils
.
getTempDir
(
)
;
await
test_api_is_available_on_worker
(
)
;
await
test_full_read_and_write
(
)
;
await
test_move_file
(
)
;
await
test_copy_file
(
)
;
await
test_make_directory
(
)
;
finish
(
)
;
info
(
"
test_ioutils_worker
.
xhtml
:
Test
finished
"
)
;
async
function
test_api_is_available_on_worker
(
)
{
ok
(
self
.
IOUtils
"
IOUtils
is
present
in
web
workers
"
)
;
}
async
function
test_full_read_and_write
(
)
{
const
tmpFileName
=
PathUtils
.
join
(
tmpDir
"
test_ioutils_numbers
.
tmp
"
)
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
const
bytesWritten
=
await
IOUtils
.
write
(
tmpFileName
bytes
)
;
is
(
bytesWritten
50
"
IOUtils
:
:
write
can
write
entire
byte
array
to
file
"
)
;
let
fileContents
=
await
IOUtils
.
read
(
tmpFileName
)
;
ok
(
_deepEqual
(
bytes
fileContents
)
&
&
bytes
.
length
=
=
fileContents
.
length
"
IOUtils
:
:
read
can
read
back
entire
file
"
)
;
const
tooManyBytes
=
bytes
.
length
+
1
;
fileContents
=
await
IOUtils
.
read
(
tmpFileName
{
maxBytes
:
tooManyBytes
}
)
;
ok
(
_deepEqual
(
bytes
fileContents
)
&
&
fileContents
.
length
=
=
bytes
.
length
"
IOUtils
:
:
read
can
read
entire
file
when
requested
maxBytes
is
too
large
"
)
;
await
cleanup
(
tmpFileName
)
;
}
async
function
test_move_file
(
)
{
const
src
=
PathUtils
.
join
(
tmpDir
"
test_move_file_src
.
tmp
"
)
;
const
dest
=
PathUtils
.
join
(
tmpDir
"
test_move_file_dest
.
tmp
"
)
;
const
bytes
=
Uint8Array
.
of
(
.
.
.
new
Array
(
50
)
.
keys
(
)
)
;
await
IOUtils
.
write
(
src
bytes
)
;
await
IOUtils
.
move
(
src
dest
)
;
ok
(
!
(
await
fileExists
(
src
)
)
&
&
(
await
fileExists
(
dest
)
)
"
IOUtils
:
:
move
can
move
files
from
a
worker
"
)
;
await
cleanup
(
dest
)
;
}
async
function
test_copy_file
(
)
{
const
tmpFileName
=
PathUtils
.
join
(
tmpDir
"
test_ioutils_orig
.
tmp
"
)
;
const
destFileName
=
PathUtils
.
join
(
tmpDir
"
test_ioutils_copy
.
tmp
"
)
;
await
createFile
(
tmpFileName
"
original
"
)
;
await
IOUtils
.
copy
(
tmpFileName
destFileName
)
;
ok
(
(
await
fileExists
(
tmpFileName
)
)
&
&
(
await
fileHasTextContents
(
destFileName
"
original
"
)
)
"
IOUtils
:
:
copy
can
copy
source
to
dest
in
same
directory
"
)
;
await
cleanup
(
tmpFileName
destFileName
)
;
}
async
function
test_make_directory
(
)
{
const
dir
=
PathUtils
.
join
(
tmpDir
"
test_make_dir
.
tmp
.
d
"
)
;
await
IOUtils
.
makeDirectory
(
dir
)
;
const
stat
=
await
IOUtils
.
stat
(
dir
)
;
is
(
stat
.
type
"
directory
"
"
IOUtils
:
:
makeDirectory
can
make
a
new
directory
from
a
worker
"
)
;
await
cleanup
(
dir
)
;
}
}
;
function
_deepEqual
(
a
b
)
{
if
(
a
=
=
=
b
)
{
return
true
;
}
let
aIsDate
=
instanceOf
(
a
"
Date
"
)
;
let
bIsDate
=
instanceOf
(
b
"
Date
"
)
;
if
(
aIsDate
|
|
bIsDate
)
{
if
(
!
aIsDate
|
|
!
bIsDate
)
{
return
false
;
}
if
(
isNaN
(
a
.
getTime
(
)
)
&
&
isNaN
(
b
.
getTime
(
)
)
)
{
return
true
;
}
return
a
.
getTime
(
)
=
=
=
b
.
getTime
(
)
;
}
let
aIsRegExp
=
instanceOf
(
a
"
RegExp
"
)
;
let
bIsRegExp
=
instanceOf
(
b
"
RegExp
"
)
;
if
(
aIsRegExp
|
|
bIsRegExp
)
{
return
(
aIsRegExp
&
&
bIsRegExp
&
&
a
.
source
=
=
=
b
.
source
&
&
a
.
global
=
=
=
b
.
global
&
&
a
.
multiline
=
=
=
b
.
multiline
&
&
a
.
lastIndex
=
=
=
b
.
lastIndex
&
&
a
.
ignoreCase
=
=
=
b
.
ignoreCase
)
;
}
if
(
typeof
a
!
=
"
object
"
|
|
typeof
b
!
=
"
object
"
)
{
return
a
=
=
b
;
}
return
objEquiv
(
a
b
)
;
}
function
instanceOf
(
object
type
)
{
return
Object
.
prototype
.
toString
.
call
(
object
)
=
=
"
[
object
"
+
type
+
"
]
"
;
}
function
isUndefinedOrNull
(
value
)
{
return
value
=
=
=
null
|
|
value
=
=
=
undefined
;
}
function
isArguments
(
object
)
{
return
instanceOf
(
object
"
Arguments
"
)
;
}
function
objEquiv
(
a
b
)
{
if
(
isUndefinedOrNull
(
a
)
|
|
isUndefinedOrNull
(
b
)
)
{
return
false
;
}
if
(
(
a
.
prototype
|
|
undefined
)
!
=
(
b
.
prototype
|
|
undefined
)
)
{
return
false
;
}
if
(
isArguments
(
a
)
)
{
if
(
!
isArguments
(
b
)
)
{
return
false
;
}
a
=
Array
.
prototype
.
slice
.
call
(
a
)
;
b
=
Array
.
prototype
.
slice
.
call
(
b
)
;
return
_deepEqual
(
a
b
)
;
}
let
ka
kb
;
try
{
ka
=
Object
.
keys
(
a
)
;
kb
=
Object
.
keys
(
b
)
;
}
catch
(
e
)
{
return
false
;
}
if
(
ka
.
length
!
=
kb
.
length
)
{
return
false
;
}
ka
.
sort
(
)
;
kb
.
sort
(
)
;
for
(
let
key
of
ka
)
{
if
(
!
_deepEqual
(
a
[
key
]
b
[
key
]
)
)
{
return
false
;
}
}
return
true
;
}
