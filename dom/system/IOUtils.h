#
ifndef
mozilla_dom_IOUtils__
#
define
mozilla_dom_IOUtils__
#
include
"
js
/
Utility
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Buffer
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
IOUtilsBinding
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
prio
.
h
"
class
nsFileRandomAccessStream
;
namespace
mozilla
{
class
PR_CloseDelete
{
public
:
constexpr
PR_CloseDelete
(
)
=
default
;
PR_CloseDelete
(
const
PR_CloseDelete
&
aOther
)
=
default
;
PR_CloseDelete
(
PR_CloseDelete
&
&
aOther
)
=
default
;
PR_CloseDelete
&
operator
=
(
const
PR_CloseDelete
&
aOther
)
=
default
;
PR_CloseDelete
&
operator
=
(
PR_CloseDelete
&
&
aOther
)
=
default
;
void
operator
(
)
(
PRFileDesc
*
aPtr
)
const
{
PR_Close
(
aPtr
)
;
}
}
;
namespace
dom
{
class
IOUtils
final
{
public
:
class
IOError
;
enum
class
ShutdownPhase
:
uint8_t
{
ProfileBeforeChange
SendTelemetry
XpcomWillShutdown
Count
}
;
template
<
typename
T
>
using
PhaseArray
=
EnumeratedArray
<
IOUtils
:
:
ShutdownPhase
IOUtils
:
:
ShutdownPhase
:
:
Count
T
>
;
static
already_AddRefed
<
Promise
>
Read
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
ReadOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
ReadUTF8
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
ReadUTF8Options
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
ReadJSON
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
ReadUTF8Options
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
Write
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Uint8Array
&
aData
const
WriteOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
WriteUTF8
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
nsACString
&
aString
const
WriteOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
WriteJSON
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
const
WriteOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
Move
(
GlobalObject
&
aGlobal
const
nsAString
&
aSourcePath
const
nsAString
&
aDestPath
const
MoveOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
Remove
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
RemoveOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
MakeDirectory
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
MakeDirectoryOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
Stat
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
Copy
(
GlobalObject
&
aGlobal
const
nsAString
&
aSourcePath
const
nsAString
&
aDestPath
const
CopyOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
SetAccessTime
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Optional
<
int64_t
>
&
aAccess
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
SetModificationTime
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Optional
<
int64_t
>
&
aModification
ErrorResult
&
aError
)
;
private
:
using
SetTimeFn
=
decltype
(
&
nsIFile
:
:
SetLastAccessedTime
)
;
static_assert
(
std
:
:
is_same_v
<
SetTimeFn
decltype
(
&
nsIFile
:
:
SetLastModifiedTime
)
>
)
;
static
already_AddRefed
<
Promise
>
SetTime
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Optional
<
int64_t
>
&
aNewTime
SetTimeFn
aSetTimeFn
ErrorResult
&
aError
)
;
public
:
static
already_AddRefed
<
Promise
>
GetChildren
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
GetChildrenOptions
&
aOptions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
SetPermissions
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
uint32_t
aPermissions
const
bool
aHonorUmask
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
Exists
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
CreateUniqueFile
(
GlobalObject
&
aGlobal
const
nsAString
&
aParent
const
nsAString
&
aPrefix
const
uint32_t
aPermissions
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
CreateUniqueDirectory
(
GlobalObject
&
aGlobal
const
nsAString
&
aParent
const
nsAString
&
aPrefix
const
uint32_t
aPermissions
ErrorResult
&
aError
)
;
private
:
static
already_AddRefed
<
Promise
>
CreateUnique
(
GlobalObject
&
aGlobal
const
nsAString
&
aParent
const
nsAString
&
aPrefix
const
uint32_t
aFileType
const
uint32_t
aPermissions
ErrorResult
&
aError
)
;
public
:
static
already_AddRefed
<
Promise
>
ComputeHexDigest
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
HashAlgorithm
aAlgorithm
ErrorResult
&
aError
)
;
#
if
defined
(
XP_WIN
)
static
already_AddRefed
<
Promise
>
GetWindowsAttributes
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
SetWindowsAttributes
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
mozilla
:
:
dom
:
:
WindowsFileAttributes
&
aAttrs
ErrorResult
&
aError
)
;
#
elif
defined
(
XP_MACOSX
)
static
already_AddRefed
<
Promise
>
HasMacXAttr
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
nsACString
&
aAttr
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
GetMacXAttr
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
nsACString
&
aAttr
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
SetMacXAttr
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
nsACString
&
aAttr
const
Uint8Array
&
aValue
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
DelMacXAttr
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
nsACString
&
aAttr
ErrorResult
&
aError
)
;
#
endif
#
ifdef
XP_UNIX
using
UnixString
=
OwningUTF8StringOrUint8Array
;
static
uint32_t
LaunchProcess
(
GlobalObject
&
aGlobal
const
Sequence
<
UnixString
>
&
aArgv
const
LaunchOptions
&
aOptions
ErrorResult
&
aRv
)
;
#
endif
static
already_AddRefed
<
Promise
>
GetFile
(
GlobalObject
&
aGlobal
const
Sequence
<
nsString
>
&
aComponents
ErrorResult
&
aError
)
;
static
already_AddRefed
<
Promise
>
GetDirectory
(
GlobalObject
&
aGlobal
const
Sequence
<
nsString
>
&
aComponents
ErrorResult
&
aError
)
;
static
void
GetProfileBeforeChange
(
GlobalObject
&
aGlobal
JS
:
:
MutableHandle
<
JS
:
:
Value
>
ErrorResult
&
aRv
)
;
static
void
GetSendTelemetry
(
GlobalObject
&
aGlobal
JS
:
:
MutableHandle
<
JS
:
:
Value
>
ErrorResult
&
aRv
)
;
static
RefPtr
<
SyncReadFile
>
OpenFileForSyncReading
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
ErrorResult
&
aRv
)
;
class
JsBuffer
;
enum
class
BufferKind
{
String
Uint8Array
}
;
private
:
~
IOUtils
(
)
=
default
;
template
<
typename
T
>
using
IOPromise
=
MozPromise
<
T
IOError
true
>
;
friend
class
IOUtilsShutdownBlocker
;
struct
InternalFileInfo
;
struct
InternalWriteOpts
;
class
MozLZ4
;
class
EventQueue
;
class
State
;
template
<
typename
Fn
>
static
already_AddRefed
<
Promise
>
WithPromiseAndState
(
GlobalObject
&
aGlobal
ErrorResult
&
aError
Fn
aFn
)
;
template
<
typename
OkT
typename
Fn
>
static
void
DispatchAndResolve
(
EventQueue
*
aQueue
Promise
*
aPromise
Fn
aFunc
)
;
static
already_AddRefed
<
Promise
>
CreateJSPromise
(
GlobalObject
&
aGlobal
ErrorResult
&
aError
)
;
friend
bool
ToJSValue
(
JSContext
*
aCx
const
InternalFileInfo
&
aInternalFileInfo
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
static
Result
<
JsBuffer
IOError
>
ReadSync
(
nsIFile
*
aFile
const
uint64_t
aOffset
const
Maybe
<
uint32_t
>
aMaxBytes
const
bool
aDecompress
BufferKind
aBufferKind
)
;
static
Result
<
JsBuffer
IOError
>
ReadUTF8Sync
(
nsIFile
*
aFile
const
bool
aDecompress
)
;
static
Result
<
uint32_t
IOError
>
WriteSync
(
nsIFile
*
aFile
const
Span
<
const
uint8_t
>
&
aByteArray
const
InternalWriteOpts
&
aOptions
)
;
static
Result
<
Ok
IOError
>
MoveSync
(
nsIFile
*
aSourceFile
nsIFile
*
aDestFile
bool
aNoOverwrite
)
;
static
Result
<
Ok
IOError
>
CopySync
(
nsIFile
*
aSourceFile
nsIFile
*
aDestFile
bool
aNoOverWrite
bool
aRecursive
)
;
template
<
typename
CopyOrMoveFn
>
static
Result
<
Ok
IOError
>
CopyOrMoveSync
(
CopyOrMoveFn
aMethod
const
char
*
aMethodName
nsIFile
*
aSource
nsIFile
*
aDest
bool
aNoOverwrite
)
;
static
Result
<
Ok
IOError
>
RemoveSync
(
nsIFile
*
aFile
bool
aIgnoreAbsent
bool
aRecursive
bool
aRetryReadonly
)
;
static
Result
<
Ok
IOError
>
MakeDirectorySync
(
nsIFile
*
aFile
bool
aCreateAncestors
bool
aIgnoreExisting
int32_t
aMode
=
0777
)
;
static
Result
<
IOUtils
:
:
InternalFileInfo
IOError
>
StatSync
(
nsIFile
*
aFile
)
;
static
Result
<
int64_t
IOError
>
SetTimeSync
(
nsIFile
*
aFile
SetTimeFn
aSetTimeFn
int64_t
aNewTime
)
;
static
Result
<
nsTArray
<
nsString
>
IOError
>
GetChildrenSync
(
nsIFile
*
aFile
bool
aIgnoreAbsent
)
;
static
Result
<
Ok
IOError
>
SetPermissionsSync
(
nsIFile
*
aFile
const
uint32_t
aPermissions
)
;
static
Result
<
bool
IOError
>
ExistsSync
(
nsIFile
*
aFile
)
;
static
Result
<
nsString
IOError
>
CreateUniqueSync
(
nsIFile
*
aFile
const
uint32_t
aFileType
const
uint32_t
aPermissions
)
;
static
Result
<
nsCString
IOError
>
ComputeHexDigestSync
(
nsIFile
*
aFile
const
HashAlgorithm
aAlgorithm
)
;
#
if
defined
(
XP_WIN
)
static
Result
<
uint32_t
IOError
>
GetWindowsAttributesSync
(
nsIFile
*
aFile
)
;
static
Result
<
Ok
IOError
>
SetWindowsAttributesSync
(
nsIFile
*
aFile
const
uint32_t
aSetAttrs
const
uint32_t
aClearAttrs
)
;
#
elif
defined
(
XP_MACOSX
)
static
Result
<
bool
IOError
>
HasMacXAttrSync
(
nsIFile
*
aFile
const
nsCString
&
aAttr
)
;
static
Result
<
nsTArray
<
uint8_t
>
IOError
>
GetMacXAttrSync
(
nsIFile
*
aFile
const
nsCString
&
aAttr
)
;
static
Result
<
Ok
IOError
>
SetMacXAttrSync
(
nsIFile
*
aFile
const
nsCString
&
aAttr
const
nsTArray
<
uint8_t
>
&
aValue
)
;
static
Result
<
Ok
IOError
>
DelMacXAttrSync
(
nsIFile
*
aFile
const
nsCString
&
aAttr
)
;
#
endif
static
void
GetShutdownClient
(
GlobalObject
&
aGlobal
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aClient
ErrorResult
&
aRv
const
ShutdownPhase
aPhase
)
;
enum
class
EventQueueStatus
{
Uninitialized
Initialized
Shutdown
}
;
enum
class
ShutdownBlockerStatus
{
Uninitialized
Initialized
Failed
}
;
class
State
{
public
:
StaticAutoPtr
<
EventQueue
>
mEventQueue
;
EventQueueStatus
mQueueStatus
=
EventQueueStatus
:
:
Uninitialized
;
ShutdownBlockerStatus
mBlockerStatus
=
ShutdownBlockerStatus
:
:
Uninitialized
;
void
SetShutdownHooks
(
)
;
}
;
using
StateMutex
=
StaticDataMutex
<
State
>
;
static
Maybe
<
StateMutex
:
:
AutoLock
>
GetState
(
)
;
static
StateMutex
sState
;
}
;
class
IOUtils
:
:
EventQueue
final
{
friend
void
IOUtils
:
:
State
:
:
SetShutdownHooks
(
)
;
public
:
EventQueue
(
)
;
EventQueue
(
const
EventQueue
&
)
=
delete
;
EventQueue
(
EventQueue
&
&
)
=
delete
;
EventQueue
&
operator
=
(
const
EventQueue
&
)
=
delete
;
EventQueue
&
operator
=
(
EventQueue
&
&
)
=
delete
;
template
<
typename
OkT
typename
Fn
>
RefPtr
<
IOPromise
<
OkT
>
>
Dispatch
(
Fn
aFunc
)
;
Result
<
already_AddRefed
<
nsIAsyncShutdownBarrier
>
nsresult
>
GetShutdownBarrier
(
const
ShutdownPhase
aPhase
)
;
Result
<
already_AddRefed
<
nsIAsyncShutdownClient
>
nsresult
>
GetShutdownClient
(
const
ShutdownPhase
aPhase
)
;
private
:
nsresult
SetShutdownHooks
(
)
;
nsCOMPtr
<
nsISerialEventTarget
>
mBackgroundEventTarget
;
IOUtils
:
:
PhaseArray
<
nsCOMPtr
<
nsIAsyncShutdownBarrier
>
>
mBarriers
;
}
;
class
IOUtils
:
:
IOError
{
public
:
MOZ_IMPLICIT
IOError
(
nsresult
aCode
)
:
mCode
(
aCode
)
mMessage
(
Nothing
(
)
)
{
}
template
<
typename
.
.
.
Args
>
IOError
WithMessage
(
const
char
*
const
aMessage
Args
.
.
.
aArgs
)
{
mMessage
.
emplace
(
nsPrintfCString
(
aMessage
aArgs
.
.
.
)
)
;
return
*
this
;
}
IOError
WithMessage
(
const
char
*
const
aMessage
)
{
mMessage
.
emplace
(
nsCString
(
aMessage
)
)
;
return
*
this
;
}
IOError
WithMessage
(
const
nsCString
&
aMessage
)
{
mMessage
.
emplace
(
aMessage
)
;
return
*
this
;
}
nsresult
Code
(
)
const
{
return
mCode
;
}
const
Maybe
<
nsCString
>
&
Message
(
)
const
{
return
mMessage
;
}
private
:
nsresult
mCode
;
Maybe
<
nsCString
>
mMessage
;
}
;
struct
IOUtils
:
:
InternalFileInfo
{
nsString
mPath
;
FileType
mType
=
FileType
:
:
Other
;
uint64_t
mSize
=
0
;
Maybe
<
PRTime
>
mCreationTime
;
PRTime
mLastAccessed
=
0
;
PRTime
mLastModified
=
0
;
uint32_t
mPermissions
=
0
;
}
;
struct
IOUtils
:
:
InternalWriteOpts
{
RefPtr
<
nsIFile
>
mBackupFile
;
RefPtr
<
nsIFile
>
mTmpFile
;
WriteMode
mMode
;
bool
mFlush
=
false
;
bool
mCompress
=
false
;
static
Result
<
InternalWriteOpts
IOUtils
:
:
IOError
>
FromBinding
(
const
WriteOptions
&
aOptions
)
;
}
;
class
IOUtils
:
:
MozLZ4
{
public
:
static
constexpr
std
:
:
array
<
uint8_t
8
>
MAGIC_NUMBER
{
{
'
m
'
'
o
'
'
z
'
'
L
'
'
z
'
'
4
'
'
0
'
'
\
0
'
}
}
;
static
const
uint32_t
HEADER_SIZE
=
8
+
sizeof
(
uint32_t
)
;
static
Result
<
nsTArray
<
uint8_t
>
IOError
>
Compress
(
Span
<
const
uint8_t
>
aUncompressed
)
;
static
Result
<
IOUtils
:
:
JsBuffer
IOError
>
Decompress
(
Span
<
const
uint8_t
>
aFileContents
IOUtils
:
:
BufferKind
)
;
}
;
class
IOUtilsShutdownBlocker
:
public
nsIAsyncShutdownBlocker
public
nsIAsyncShutdownCompletionCallback
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIASYNCSHUTDOWNBLOCKER
NS_DECL_NSIASYNCSHUTDOWNCOMPLETIONCALLBACK
explicit
IOUtilsShutdownBlocker
(
const
IOUtils
:
:
ShutdownPhase
aPhase
)
:
mPhase
(
aPhase
)
{
}
private
:
virtual
~
IOUtilsShutdownBlocker
(
)
=
default
;
void
OnFlush
(
)
;
static
constexpr
IOUtils
:
:
PhaseArray
<
const
char16_t
*
>
PHASE_NAMES
{
u
"
profile
-
before
-
change
"
u
"
profile
-
before
-
change
-
telemetry
"
u
"
xpcom
-
will
-
shutdown
"
}
;
static
constexpr
auto
LAST_IO_PHASE
=
IOUtils
:
:
ShutdownPhase
:
:
SendTelemetry
;
IOUtils
:
:
ShutdownPhase
mPhase
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
mParentClient
;
}
;
class
IOUtils
:
:
JsBuffer
final
{
public
:
static
Result
<
JsBuffer
IOUtils
:
:
IOError
>
Create
(
IOUtils
:
:
BufferKind
aBufferKind
size_t
aCapacity
)
;
static
JsBuffer
CreateEmpty
(
IOUtils
:
:
BufferKind
aBufferKind
)
;
JsBuffer
(
const
JsBuffer
&
)
=
delete
;
JsBuffer
(
JsBuffer
&
&
aOther
)
noexcept
;
JsBuffer
&
operator
=
(
const
JsBuffer
&
)
=
delete
;
JsBuffer
&
operator
=
(
JsBuffer
&
&
aOther
)
noexcept
;
size_t
Length
(
)
{
return
mLength
;
}
char
*
Elements
(
)
{
return
mBuffer
.
get
(
)
;
}
void
SetLength
(
size_t
aNewLength
)
{
MOZ_RELEASE_ASSERT
(
aNewLength
<
=
mCapacity
)
;
mLength
=
aNewLength
;
}
Span
<
char
>
BeginWriting
(
)
{
MOZ_RELEASE_ASSERT
(
mBuffer
.
get
(
)
)
;
return
Span
(
mBuffer
.
get
(
)
mCapacity
)
;
}
Span
<
const
char
>
BeginReading
(
)
const
{
MOZ_RELEASE_ASSERT
(
mBuffer
.
get
(
)
|
|
mLength
=
=
0
)
;
return
Span
(
mBuffer
.
get
(
)
mLength
)
;
}
static
JSString
*
IntoString
(
JSContext
*
aCx
JsBuffer
aBuffer
)
;
static
JSObject
*
IntoUint8Array
(
JSContext
*
aCx
JsBuffer
aBuffer
)
;
friend
bool
ToJSValue
(
JSContext
*
aCx
JsBuffer
&
&
aBuffer
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
;
private
:
IOUtils
:
:
BufferKind
mBufferKind
;
size_t
mCapacity
;
size_t
mLength
;
JS
:
:
UniqueChars
mBuffer
;
JsBuffer
(
BufferKind
aBufferKind
size_t
aCapacity
)
;
}
;
class
SyncReadFile
:
public
nsISupports
public
nsWrapperCache
{
public
:
SyncReadFile
(
nsISupports
*
aParent
RefPtr
<
nsFileRandomAccessStream
>
&
&
aStream
int64_t
aSize
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
SyncReadFile
)
nsISupports
*
GetParentObject
(
)
const
{
return
mParent
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
int64_t
Size
(
)
const
{
return
mSize
;
}
void
ReadBytesInto
(
const
Uint8Array
&
const
int64_t
ErrorResult
&
aRv
)
;
void
Close
(
)
;
private
:
virtual
~
SyncReadFile
(
)
;
nsCOMPtr
<
nsISupports
>
mParent
;
RefPtr
<
nsFileRandomAccessStream
>
mStream
;
int64_t
mSize
=
0
;
}
;
}
}
#
endif
