#
include
"
GpsdLocationProvider
.
h
"
#
include
<
errno
.
h
>
#
include
<
gps
.
h
>
#
include
"
MLSFallback
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
LazyIdleThread
.
h
"
#
include
"
mozilla
/
dom
/
GeolocationPositionErrorBinding
.
h
"
#
include
"
nsGeoPosition
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
class
GpsdLocationProvider
:
:
MLSGeolocationUpdate
final
:
public
nsIGeolocationUpdate
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIGEOLOCATIONUPDATE
explicit
MLSGeolocationUpdate
(
nsIGeolocationUpdate
*
aCallback
)
;
protected
:
~
MLSGeolocationUpdate
(
)
=
default
;
private
:
nsCOMPtr
<
nsIGeolocationUpdate
>
mCallback
;
}
;
GpsdLocationProvider
:
:
MLSGeolocationUpdate
:
:
MLSGeolocationUpdate
(
nsIGeolocationUpdate
*
aCallback
)
:
mCallback
(
aCallback
)
{
MOZ_ASSERT
(
mCallback
)
;
}
NS_IMPL_ISUPPORTS
(
GpsdLocationProvider
:
:
MLSGeolocationUpdate
nsIGeolocationUpdate
)
;
NS_IMETHODIMP
GpsdLocationProvider
:
:
MLSGeolocationUpdate
:
:
Update
(
nsIDOMGeoPosition
*
aPosition
)
{
nsCOMPtr
<
nsIDOMGeoPositionCoords
>
coords
;
aPosition
-
>
GetCoords
(
getter_AddRefs
(
coords
)
)
;
if
(
!
coords
)
{
return
NS_ERROR_FAILURE
;
}
return
mCallback
-
>
Update
(
aPosition
)
;
}
NS_IMETHODIMP
GpsdLocationProvider
:
:
MLSGeolocationUpdate
:
:
NotifyError
(
uint16_t
aError
)
{
return
mCallback
-
>
NotifyError
(
aError
)
;
}
class
GpsdLocationProvider
:
:
UpdateRunnable
final
:
public
Runnable
{
public
:
UpdateRunnable
(
const
nsMainThreadPtrHandle
<
GpsdLocationProvider
>
&
aLocationProvider
nsIDOMGeoPosition
*
aPosition
)
:
mLocationProvider
(
aLocationProvider
)
mPosition
(
aPosition
)
{
MOZ_ASSERT
(
mLocationProvider
)
;
MOZ_ASSERT
(
mPosition
)
;
}
NS_IMETHOD
Run
(
)
override
{
mLocationProvider
-
>
Update
(
mPosition
)
;
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
GpsdLocationProvider
>
mLocationProvider
;
RefPtr
<
nsIDOMGeoPosition
>
mPosition
;
}
;
class
GpsdLocationProvider
:
:
NotifyErrorRunnable
final
:
public
Runnable
{
public
:
NotifyErrorRunnable
(
const
nsMainThreadPtrHandle
<
GpsdLocationProvider
>
&
aLocationProvider
int
aError
)
:
mLocationProvider
(
aLocationProvider
)
mError
(
aError
)
{
MOZ_ASSERT
(
mLocationProvider
)
;
}
NS_IMETHOD
Run
(
)
override
{
mLocationProvider
-
>
NotifyError
(
mError
)
;
return
NS_OK
;
}
private
:
nsMainThreadPtrHandle
<
GpsdLocationProvider
>
mLocationProvider
;
int
mError
;
}
;
class
GpsdLocationProvider
:
:
PollRunnable
final
:
public
Runnable
{
public
:
PollRunnable
(
const
nsMainThreadPtrHandle
<
GpsdLocationProvider
>
&
aLocationProvider
)
:
mLocationProvider
(
aLocationProvider
)
mRunning
(
true
)
{
MOZ_ASSERT
(
mLocationProvider
)
;
}
static
bool
IsSupported
(
)
{
return
GPSD_API_MAJOR_VERSION
=
=
5
;
}
bool
IsRunning
(
)
const
{
return
mRunning
;
}
void
StopRunning
(
)
{
mRunning
=
false
;
}
NS_IMETHOD
Run
(
)
override
{
int
err
;
switch
(
GPSD_API_MAJOR_VERSION
)
{
case
5
:
err
=
PollLoop5
(
)
;
break
;
default
:
err
=
GeolocationPositionError_Binding
:
:
POSITION_UNAVAILABLE
;
break
;
}
if
(
err
)
{
NS_DispatchToMainThread
(
MakeAndAddRef
<
NotifyErrorRunnable
>
(
mLocationProvider
err
)
)
;
}
mLocationProvider
=
nullptr
;
return
NS_OK
;
}
protected
:
int
PollLoop5
(
)
{
#
if
GPSD_API_MAJOR_VERSION
=
=
5
static
const
int
GPSD_WAIT_TIMEOUT_US
=
1000000
;
struct
gps_data_t
gpsData
;
auto
res
=
gps_open
(
nullptr
nullptr
&
gpsData
)
;
if
(
res
<
0
)
{
return
ErrnoToError
(
errno
)
;
}
gps_stream
(
&
gpsData
WATCH_ENABLE
|
WATCH_JSON
NULL
)
;
int
err
=
0
;
double
lat
=
0
;
double
lon
=
0
;
double
alt
=
UnspecifiedNaN
<
double
>
(
)
;
double
hError
=
0
;
double
vError
=
UnspecifiedNaN
<
double
>
(
)
;
double
heading
=
UnspecifiedNaN
<
double
>
(
)
;
double
speed
=
UnspecifiedNaN
<
double
>
(
)
;
while
(
IsRunning
(
)
)
{
errno
=
0
;
auto
hasGpsData
=
gps_waiting
(
&
gpsData
GPSD_WAIT_TIMEOUT_US
)
;
if
(
errno
)
{
err
=
ErrnoToError
(
errno
)
;
break
;
}
if
(
!
hasGpsData
)
{
continue
;
}
res
=
gps_read
(
&
gpsData
)
;
if
(
res
<
0
)
{
err
=
ErrnoToError
(
errno
)
;
break
;
}
else
if
(
!
res
)
{
continue
;
}
if
(
gpsData
.
status
=
=
STATUS_NO_FIX
)
{
continue
;
}
switch
(
gpsData
.
fix
.
mode
)
{
case
MODE_3D
:
if
(
!
IsNaN
(
gpsData
.
fix
.
altitude
)
)
{
alt
=
gpsData
.
fix
.
altitude
;
}
MOZ_FALLTHROUGH
;
case
MODE_2D
:
if
(
!
IsNaN
(
gpsData
.
fix
.
latitude
)
)
{
lat
=
gpsData
.
fix
.
latitude
;
}
if
(
!
IsNaN
(
gpsData
.
fix
.
longitude
)
)
{
lon
=
gpsData
.
fix
.
longitude
;
}
if
(
!
IsNaN
(
gpsData
.
fix
.
epx
)
&
&
!
IsNaN
(
gpsData
.
fix
.
epy
)
)
{
hError
=
std
:
:
max
(
gpsData
.
fix
.
epx
gpsData
.
fix
.
epy
)
;
}
else
if
(
!
IsNaN
(
gpsData
.
fix
.
epx
)
)
{
hError
=
gpsData
.
fix
.
epx
;
}
else
if
(
!
IsNaN
(
gpsData
.
fix
.
epy
)
)
{
hError
=
gpsData
.
fix
.
epy
;
}
if
(
!
IsNaN
(
gpsData
.
fix
.
altitude
)
)
{
alt
=
gpsData
.
fix
.
altitude
;
}
if
(
!
IsNaN
(
gpsData
.
fix
.
epv
)
)
{
vError
=
gpsData
.
fix
.
epv
;
}
if
(
!
IsNaN
(
gpsData
.
fix
.
track
)
)
{
heading
=
gpsData
.
fix
.
track
;
}
if
(
!
IsNaN
(
gpsData
.
fix
.
speed
)
)
{
speed
=
gpsData
.
fix
.
speed
;
}
break
;
default
:
continue
;
}
NS_DispatchToMainThread
(
MakeAndAddRef
<
UpdateRunnable
>
(
mLocationProvider
new
nsGeoPosition
(
lat
lon
alt
hError
vError
heading
speed
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
)
)
;
}
gps_stream
(
&
gpsData
WATCH_DISABLE
NULL
)
;
gps_close
(
&
gpsData
)
;
return
err
;
#
else
return
GeolocationPositionError_Binding
:
:
POSITION_UNAVAILABLE
;
#
endif
}
static
int
ErrnoToError
(
int
aErrno
)
{
switch
(
aErrno
)
{
case
EACCES
:
MOZ_FALLTHROUGH
;
case
EPERM
:
MOZ_FALLTHROUGH
;
case
EROFS
:
return
GeolocationPositionError_Binding
:
:
PERMISSION_DENIED
;
case
ETIME
:
MOZ_FALLTHROUGH
;
case
ETIMEDOUT
:
return
GeolocationPositionError_Binding
:
:
TIMEOUT
;
default
:
return
GeolocationPositionError_Binding
:
:
POSITION_UNAVAILABLE
;
}
}
private
:
nsMainThreadPtrHandle
<
GpsdLocationProvider
>
mLocationProvider
;
Atomic
<
bool
>
mRunning
;
}
;
const
uint32_t
GpsdLocationProvider
:
:
GPSD_POLL_THREAD_TIMEOUT_MS
=
5000
;
GpsdLocationProvider
:
:
GpsdLocationProvider
(
)
{
}
GpsdLocationProvider
:
:
~
GpsdLocationProvider
(
)
{
}
void
GpsdLocationProvider
:
:
Update
(
nsIDOMGeoPosition
*
aPosition
)
{
if
(
!
mCallback
|
|
!
mPollRunnable
)
{
return
;
}
if
(
mMLSProvider
)
{
mMLSProvider
-
>
Shutdown
(
)
;
mMLSProvider
=
nullptr
;
}
mCallback
-
>
Update
(
aPosition
)
;
}
void
GpsdLocationProvider
:
:
NotifyError
(
int
aError
)
{
if
(
!
mCallback
)
{
return
;
}
if
(
!
mMLSProvider
)
{
mMLSProvider
=
MakeAndAddRef
<
MLSFallback
>
(
)
;
mMLSProvider
-
>
Startup
(
new
MLSGeolocationUpdate
(
mCallback
)
)
;
}
mCallback
-
>
NotifyError
(
aError
)
;
}
NS_IMPL_ISUPPORTS
(
GpsdLocationProvider
nsIGeolocationProvider
)
NS_IMETHODIMP
GpsdLocationProvider
:
:
Startup
(
)
{
if
(
!
PollRunnable
:
:
IsSupported
(
)
)
{
return
NS_OK
;
}
if
(
mPollRunnable
)
{
return
NS_OK
;
}
RefPtr
<
PollRunnable
>
pollRunnable
=
MakeAndAddRef
<
PollRunnable
>
(
nsMainThreadPtrHandle
<
GpsdLocationProvider
>
(
new
nsMainThreadPtrHolder
<
GpsdLocationProvider
>
(
this
)
)
)
;
RefPtr
<
LazyIdleThread
>
pollThread
=
mPollThread
;
if
(
!
pollThread
)
{
pollThread
=
MakeAndAddRef
<
LazyIdleThread
>
(
GPSD_POLL_THREAD_TIMEOUT_MS
NS_LITERAL_CSTRING
(
"
Gpsd
poll
thread
"
)
LazyIdleThread
:
:
ManualShutdown
)
;
}
auto
rv
=
pollThread
-
>
Dispatch
(
pollRunnable
NS_DISPATCH_NORMAL
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mPollRunnable
=
pollRunnable
.
forget
(
)
;
mPollThread
=
pollThread
.
forget
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GpsdLocationProvider
:
:
Watch
(
nsIGeolocationUpdate
*
aCallback
)
{
mCallback
=
aCallback
;
mMLSProvider
=
MakeAndAddRef
<
MLSFallback
>
(
)
;
mMLSProvider
-
>
Startup
(
new
MLSGeolocationUpdate
(
aCallback
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
GpsdLocationProvider
:
:
Shutdown
(
)
{
if
(
mMLSProvider
)
{
mMLSProvider
-
>
Shutdown
(
)
;
mMLSProvider
=
nullptr
;
}
if
(
!
mPollRunnable
)
{
return
NS_OK
;
}
mPollRunnable
-
>
StopRunning
(
)
;
mPollRunnable
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
GpsdLocationProvider
:
:
SetHighAccuracy
(
bool
aHigh
)
{
return
NS_OK
;
}
}
}
