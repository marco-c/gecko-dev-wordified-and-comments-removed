#
include
<
algorithm
>
#
include
"
mozilla
/
dom
/
IOUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nspr
/
prio
.
h
"
#
include
"
nspr
/
private
/
pprio
.
h
"
#
include
"
nspr
/
prtypes
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsThreadManager
.
h
"
#
if
defined
(
__unix__
)
|
|
(
defined
(
__APPLE__
)
&
&
defined
(
__MACH__
)
)
#
include
<
fcntl
.
h
>
#
endif
#
define
REJECT_IF_NULL_EVENT_TARGET
(
aEventTarget
aJSPromise
)
\
do
{
\
if
(
!
(
aEventTarget
)
)
{
\
(
aJSPromise
)
\
-
>
MaybeRejectWithAbortError
(
\
"
Could
not
dispatch
task
to
background
thread
"
)
;
\
return
(
aJSPromise
)
.
forget
(
)
;
\
}
\
}
while
(
false
)
#
define
REJECT_IF_SHUTTING_DOWN
(
aJSPromise
)
\
do
{
\
if
(
sShutdownStarted
)
{
\
(
aJSPromise
)
\
-
>
MaybeRejectWithNotAllowedError
(
\
"
Shutting
down
and
refusing
additional
I
/
O
tasks
"
)
;
\
return
(
aJSPromise
)
.
forget
(
)
;
\
}
\
}
while
(
false
)
#
define
REJECT_IF_RELATIVE_PATH
(
aPath
aJSPromise
)
\
do
{
\
if
(
!
IsAbsolutePath
(
aPath
)
)
{
\
(
aJSPromise
)
\
-
>
MaybeRejectWithOperationError
(
nsPrintfCString
(
\
"
Refusing
to
work
with
path
(
%
s
)
because
only
absolute
"
\
"
file
paths
are
permitted
"
\
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
\
return
(
aJSPromise
)
.
forget
(
)
;
\
}
\
}
while
(
false
)
namespace
mozilla
{
namespace
dom
{
static
bool
IsFileNotFound
(
nsresult
aResult
)
{
switch
(
aResult
)
{
case
NS_ERROR_FILE_NOT_FOUND
:
case
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
:
return
true
;
default
:
return
false
;
}
}
template
<
typename
.
.
.
Args
>
static
nsCString
FormatErrorMessage
(
nsresult
aError
const
char
*
const
aMessage
Args
.
.
.
aArgs
)
{
nsPrintfCString
msg
(
aMessage
aArgs
.
.
.
)
;
if
(
const
char
*
errName
=
GetStaticErrorName
(
aError
)
)
{
msg
.
AppendPrintf
(
"
:
%
s
"
errName
)
;
}
else
{
msg
.
AppendPrintf
(
"
:
0x
%
"
PRIX32
static_cast
<
uint32_t
>
(
aError
)
)
;
}
return
std
:
:
move
(
msg
)
;
}
static
nsCString
FormatErrorMessage
(
nsresult
aError
const
char
*
const
aMessage
)
{
const
char
*
errName
=
GetStaticErrorName
(
aError
)
;
if
(
errName
)
{
return
nsPrintfCString
(
"
%
s
:
%
s
"
aMessage
errName
)
;
}
return
nsPrintfCString
(
"
%
s
:
0x
%
"
PRIX32
aMessage
static_cast
<
uint32_t
>
(
aError
)
)
;
}
template
<
class
PromiseT
class
OkT
class
ErrT
>
static
RefPtr
<
PromiseT
>
ToMozPromise
(
Result
<
OkT
ErrT
>
&
aResult
const
char
*
aCallSite
)
{
if
(
aResult
.
isErr
(
)
)
{
return
PromiseT
:
:
CreateAndReject
(
aResult
.
unwrapErr
(
)
aCallSite
)
;
}
return
PromiseT
:
:
CreateAndResolve
(
aResult
.
unwrap
(
)
aCallSite
)
;
}
MOZ_MUST_USE
inline
bool
ToJSValue
(
JSContext
*
aCx
const
IOUtils
:
:
InternalFileInfo
&
aInternalFileInfo
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
FileInfo
info
;
info
.
mPath
.
Construct
(
aInternalFileInfo
.
mPath
)
;
info
.
mType
.
Construct
(
aInternalFileInfo
.
mType
)
;
info
.
mSize
.
Construct
(
aInternalFileInfo
.
mSize
)
;
info
.
mLastModified
.
Construct
(
aInternalFileInfo
.
mLastModified
)
;
return
ToJSValue
(
aCx
info
aValue
)
;
}
#
ifdef
XP_WIN
constexpr
char
PathSeparator
=
u
'
\
\
'
;
#
else
constexpr
char
PathSeparator
=
u
'
/
'
;
#
endif
bool
IOUtils
:
:
IsAbsolutePath
(
const
nsAString
&
aPath
)
{
const
size_t
length
=
aPath
.
Length
(
)
;
#
ifdef
XP_WIN
if
(
length
>
3
&
&
mozilla
:
:
IsAsciiAlpha
(
aPath
.
CharAt
(
0
)
)
&
&
aPath
.
CharAt
(
1
)
=
=
u
'
:
'
&
&
aPath
.
CharAt
(
2
)
=
=
u
'
\
\
'
)
{
return
true
;
}
#
endif
return
length
>
0
&
&
aPath
.
CharAt
(
0
)
=
=
PathSeparator
;
}
StaticDataMutex
<
StaticRefPtr
<
nsISerialEventTarget
>
>
IOUtils
:
:
sBackgroundEventTarget
(
"
sBackgroundEventTarget
"
)
;
StaticRefPtr
<
nsIAsyncShutdownClient
>
IOUtils
:
:
sBarrier
;
Atomic
<
bool
>
IOUtils
:
:
sShutdownStarted
=
Atomic
<
bool
>
(
false
)
;
already_AddRefed
<
Promise
>
IOUtils
:
:
Read
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Optional
<
uint32_t
>
&
aMaxBytes
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
REJECT_IF_RELATIVE_PATH
(
aPath
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
Maybe
<
uint32_t
>
toRead
=
Nothing
(
)
;
if
(
aMaxBytes
.
WasPassed
(
)
)
{
if
(
aMaxBytes
.
Value
(
)
=
=
0
)
{
nsTArray
<
uint8_t
>
arr
(
0
)
;
TypedArrayCreator
<
Uint8Array
>
arrCreator
(
arr
)
;
promise
-
>
MaybeResolve
(
arrCreator
)
;
return
promise
.
forget
(
)
;
}
toRead
.
emplace
(
aMaxBytes
.
Value
(
)
)
;
}
InvokeAsync
(
bg
__func__
[
path
=
nsAutoString
(
aPath
)
toRead
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
rv
=
IOUtils
:
:
ReadSync
(
path
toRead
)
;
return
ToMozPromise
<
IOReadMozPromise
nsTArray
<
uint8_t
>
IOError
>
(
rv
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
nsTArray
<
uint8_t
>
&
aBuf
)
{
const
TypedArrayCreator
<
Uint8Array
>
arrayCreator
(
aBuf
)
;
promise
-
>
MaybeResolve
(
arrayCreator
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
IOError
&
aError
)
{
RejectJSPromise
(
promise
aError
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
WriteAtomic
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Uint8Array
&
aData
const
WriteAtomicOptions
&
aOptions
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
REJECT_IF_RELATIVE_PATH
(
aPath
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
aData
.
ComputeState
(
)
;
FallibleTArray
<
uint8_t
>
toWrite
;
if
(
!
toWrite
.
InsertElementsAt
(
0
aData
.
Data
(
)
aData
.
Length
(
)
fallible
)
)
{
promise
-
>
MaybeRejectWithOperationError
(
"
Out
of
memory
"
)
;
return
promise
.
forget
(
)
;
}
InvokeAsync
(
bg
__func__
[
destPath
=
nsString
(
aPath
)
toWrite
=
std
:
:
move
(
toWrite
)
aOptions
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
rv
=
WriteAtomicSync
(
destPath
toWrite
aOptions
)
;
return
ToMozPromise
<
IOWriteMozPromise
uint32_t
IOError
>
(
rv
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
uint32_t
&
aBytesWritten
)
{
promise
-
>
MaybeResolve
(
aBytesWritten
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
IOError
&
aError
)
{
RejectJSPromise
(
promise
aError
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
Move
(
GlobalObject
&
aGlobal
const
nsAString
&
aSourcePath
const
nsAString
&
aDestPath
const
MoveOptions
&
aOptions
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
REJECT_IF_RELATIVE_PATH
(
aSourcePath
promise
)
;
REJECT_IF_RELATIVE_PATH
(
aDestPath
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
bool
noOverwrite
=
false
;
if
(
aOptions
.
IsAnyMemberPresent
(
)
)
{
noOverwrite
=
aOptions
.
mNoOverwrite
;
}
InvokeAsync
(
bg
__func__
[
srcPathString
=
nsAutoString
(
aSourcePath
)
destPathString
=
nsAutoString
(
aDestPath
)
noOverwrite
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
rv
=
MoveSync
(
srcPathString
destPathString
noOverwrite
)
;
return
ToMozPromise
<
IOMozPromise
Ok
IOError
>
(
rv
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
Ok
&
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
IOError
&
aError
)
{
RejectJSPromise
(
promise
aError
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
Remove
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
RemoveOptions
&
aOptions
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
REJECT_IF_RELATIVE_PATH
(
aPath
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
InvokeAsync
(
bg
__func__
[
path
=
nsAutoString
(
aPath
)
aOptions
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
rv
=
RemoveSync
(
path
aOptions
.
mIgnoreAbsent
aOptions
.
mRecursive
)
;
return
ToMozPromise
<
IOMozPromise
Ok
IOError
>
(
rv
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
Ok
&
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
IOError
&
aError
)
{
RejectJSPromise
(
promise
aError
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
MakeDirectory
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
MakeDirectoryOptions
&
aOptions
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
REJECT_IF_RELATIVE_PATH
(
aPath
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
InvokeAsync
(
bg
__func__
[
path
=
nsAutoString
(
aPath
)
aOptions
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
rv
=
CreateDirectorySync
(
path
aOptions
.
mCreateAncestors
aOptions
.
mIgnoreExisting
)
;
return
ToMozPromise
<
IOMozPromise
Ok
IOError
>
(
rv
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
Ok
&
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
IOError
&
aError
)
{
RejectJSPromise
(
promise
aError
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
Stat
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
REJECT_IF_RELATIVE_PATH
(
aPath
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
InvokeAsync
(
bg
__func__
[
path
=
nsAutoString
(
aPath
)
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
auto
rv
=
StatSync
(
path
)
;
return
ToMozPromise
<
IOStatMozPromise
InternalFileInfo
IOError
>
(
rv
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
InternalFileInfo
&
aInfo
)
{
promise
-
>
MaybeResolve
(
aInfo
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
IOError
&
aError
)
{
RejectJSPromise
(
promise
aError
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
nsISerialEventTarget
>
IOUtils
:
:
GetBackgroundEventTarget
(
)
{
if
(
sShutdownStarted
)
{
return
nullptr
;
}
auto
lockedBackgroundEventTarget
=
sBackgroundEventTarget
.
Lock
(
)
;
if
(
!
lockedBackgroundEventTarget
.
ref
(
)
)
{
RefPtr
<
nsISerialEventTarget
>
et
;
MOZ_ALWAYS_SUCCEEDS
(
NS_CreateBackgroundTaskQueue
(
"
IOUtils
:
:
BackgroundIOThread
"
getter_AddRefs
(
et
)
)
)
;
MOZ_ASSERT
(
et
)
;
*
lockedBackgroundEventTarget
=
et
;
if
(
NS_IsMainThread
(
)
)
{
IOUtils
:
:
SetShutdownHooks
(
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
__func__
[
]
(
)
{
IOUtils
:
:
SetShutdownHooks
(
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
}
return
do_AddRef
(
*
lockedBackgroundEventTarget
)
;
}
already_AddRefed
<
nsIAsyncShutdownClient
>
IOUtils
:
:
GetShutdownBarrier
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sBarrier
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdownService
(
)
;
MOZ_ASSERT
(
svc
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
;
nsresult
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
barrier
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
sBarrier
=
barrier
;
}
return
do_AddRef
(
sBarrier
)
;
}
void
IOUtils
:
:
SetShutdownHooks
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
nsCOMPtr
<
nsIAsyncShutdownBlocker
>
blocker
=
new
IOUtilsShutdownBlocker
(
)
;
nsresult
rv
=
barrier
-
>
AddBlocker
(
blocker
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
u
"
IOUtils
:
waiting
for
pending
I
/
O
to
finish
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
sShutdownStarted
=
true
;
}
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
CreateJSPromise
(
GlobalObject
&
aGlobal
)
{
ErrorResult
er
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
er
)
;
if
(
er
.
Failed
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
promise
)
;
return
do_AddRef
(
promise
)
;
}
void
IOUtils
:
:
RejectJSPromise
(
const
RefPtr
<
Promise
>
&
aPromise
const
IOError
&
aError
)
{
const
auto
&
errMsg
=
aError
.
Message
(
)
;
switch
(
aError
.
Code
(
)
)
{
case
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
:
case
NS_ERROR_FILE_NOT_FOUND
:
aPromise
-
>
MaybeRejectWithNotFoundError
(
errMsg
.
refOr
(
"
File
not
found
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_ACCESS_DENIED
:
aPromise
-
>
MaybeRejectWithNotAllowedError
(
errMsg
.
refOr
(
"
Access
was
denied
to
the
target
file
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_TOO_BIG
:
aPromise
-
>
MaybeRejectWithNotReadableError
(
errMsg
.
refOr
(
"
Target
file
is
too
big
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_ALREADY_EXISTS
:
aPromise
-
>
MaybeRejectWithNoModificationAllowedError
(
errMsg
.
refOr
(
"
Target
file
already
exists
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_COPY_OR_MOVE_FAILED
:
aPromise
-
>
MaybeRejectWithOperationError
(
errMsg
.
refOr
(
"
Failed
to
copy
or
move
the
target
file
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_READ_ONLY
:
aPromise
-
>
MaybeRejectWithReadOnlyError
(
errMsg
.
refOr
(
"
Target
file
is
read
only
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_NOT_DIRECTORY
:
case
NS_ERROR_FILE_DESTINATION_NOT_DIR
:
aPromise
-
>
MaybeRejectWithInvalidAccessError
(
errMsg
.
refOr
(
"
Target
file
is
not
a
directory
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_UNRECOGNIZED_PATH
:
aPromise
-
>
MaybeRejectWithOperationError
(
errMsg
.
refOr
(
"
Target
file
path
is
not
recognized
"
_ns
)
)
;
break
;
case
NS_ERROR_FILE_DIR_NOT_EMPTY
:
aPromise
-
>
MaybeRejectWithOperationError
(
errMsg
.
refOr
(
"
Target
directory
is
not
empty
"
_ns
)
)
;
break
;
default
:
aPromise
-
>
MaybeRejectWithUnknownError
(
errMsg
.
refOr
(
FormatErrorMessage
(
aError
.
Code
(
)
"
Unexpected
error
"
)
)
)
;
}
}
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
IOUtils
:
:
OpenExistingSync
(
const
nsAString
&
aPath
int32_t
aFlags
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
(
aFlags
&
(
PR_CREATE_FILE
|
PR_EXCL
)
)
=
=
0
)
;
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
)
;
nsresult
rv
=
file
-
>
InitWithPath
(
aPath
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
PRFileDesc
*
fd
;
rv
=
file
-
>
OpenNSPRFileDesc
(
aFlags
0
&
fd
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
(
fd
)
;
}
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
IOUtils
:
:
CreateFileSync
(
const
nsAString
&
aPath
int32_t
aFlags
int32_t
aMode
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
)
;
nsresult
rv
=
file
-
>
InitWithPath
(
aPath
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
PRFileDesc
*
fd
;
rv
=
file
-
>
OpenNSPRFileDesc
(
aFlags
|
PR_CREATE_FILE
|
PR_EXCL
aMode
&
fd
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
(
fd
)
;
}
Result
<
nsTArray
<
uint8_t
>
IOUtils
:
:
IOError
>
IOUtils
:
:
ReadSync
(
const
nsAString
&
aPath
const
Maybe
<
uint32_t
>
&
aMaxBytes
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
fd
=
OpenExistingSync
(
aPath
PR_RDONLY
)
;
if
(
!
fd
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_NOT_FOUND
)
.
WithMessage
(
"
Could
not
open
the
file
at
%
s
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
uint32_t
bufSize
;
if
(
aMaxBytes
.
isNothing
(
)
)
{
PRFileInfo64
info
;
if
(
PR_FAILURE
=
=
PR_GetOpenFileInfo64
(
fd
.
get
(
)
&
info
)
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_ACCESS_DENIED
)
.
WithMessage
(
"
Could
not
get
info
for
the
file
at
%
s
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
if
(
static_cast
<
uint64_t
>
(
info
.
size
)
>
UINT32_MAX
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_TOO_BIG
)
.
WithMessage
(
"
Could
not
read
the
file
at
%
s
because
it
is
too
"
"
large
(
size
=
%
"
PRIu64
"
bytes
)
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
static_cast
<
uint64_t
>
(
info
.
size
)
)
)
;
}
bufSize
=
static_cast
<
uint32_t
>
(
info
.
size
)
;
}
else
{
bufSize
=
aMaxBytes
.
value
(
)
;
}
nsTArray
<
uint8_t
>
buffer
;
if
(
!
buffer
.
SetCapacity
(
bufSize
fallible
)
)
{
return
Err
(
IOError
(
NS_ERROR_OUT_OF_MEMORY
)
)
;
}
#
if
defined
(
HAVE_POSIX_FADVISE
)
posix_fadvise
(
PR_FileDesc2NativeHandle
(
fd
.
get
(
)
)
0
0
POSIX_FADV_SEQUENTIAL
)
;
#
endif
uint32_t
totalRead
=
0
;
while
(
totalRead
!
=
bufSize
)
{
int32_t
nRead
=
PR_Read
(
fd
.
get
(
)
buffer
.
Elements
(
)
+
totalRead
bufSize
-
totalRead
)
;
if
(
nRead
=
=
0
)
{
break
;
}
if
(
nRead
<
0
)
{
return
Err
(
IOError
(
NS_ERROR_UNEXPECTED
)
.
WithMessage
(
"
Encountered
an
unexpected
error
while
reading
%
s
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
totalRead
+
=
nRead
;
DebugOnly
<
bool
>
success
=
buffer
.
SetLength
(
totalRead
fallible
)
;
MOZ_ASSERT
(
success
)
;
}
return
std
:
:
move
(
buffer
)
;
}
Result
<
uint32_t
IOUtils
:
:
IOError
>
IOUtils
:
:
WriteAtomicSync
(
const
nsAString
&
aDestPath
const
nsTArray
<
uint8_t
>
&
aByteArray
const
WriteAtomicOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
const
bool
&
noOverwrite
=
aOptions
.
mNoOverwrite
;
bool
exists
=
false
;
{
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
fd
=
OpenExistingSync
(
aDestPath
PR_RDONLY
)
;
exists
=
!
!
fd
;
}
if
(
noOverwrite
&
&
exists
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_ALREADY_EXISTS
)
.
WithMessage
(
"
Refusing
to
overwrite
the
file
at
%
s
\
n
"
"
Specify
noOverwrite
:
false
to
allow
"
"
overwriting
the
destination
"
NS_ConvertUTF16toUTF8
(
aDestPath
)
.
get
(
)
)
)
;
}
if
(
exists
&
&
aOptions
.
mBackupFile
.
WasPassed
(
)
&
&
MoveSync
(
aDestPath
aOptions
.
mBackupFile
.
Value
(
)
noOverwrite
)
.
isErr
(
)
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_COPY_OR_MOVE_FAILED
)
.
WithMessage
(
"
Failed
to
backup
the
source
file
(
%
s
)
to
%
s
"
NS_ConvertUTF16toUTF8
(
aDestPath
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aOptions
.
mBackupFile
.
Value
(
)
)
.
get
(
)
)
)
;
}
nsAutoString
tmpPath
;
if
(
aOptions
.
mTmpPath
.
WasPassed
(
)
)
{
tmpPath
=
aOptions
.
mTmpPath
.
Value
(
)
;
}
else
{
tmpPath
=
aDestPath
;
}
int32_t
flags
=
PR_WRONLY
|
PR_TRUNCATE
|
PR_APPEND
;
if
(
aOptions
.
mFlush
)
{
flags
|
=
PR_SYNC
;
}
uint32_t
result
=
0
;
{
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
fd
=
OpenExistingSync
(
tmpPath
flags
)
;
if
(
!
fd
)
{
fd
=
CreateFileSync
(
tmpPath
flags
)
;
}
if
(
!
fd
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_ACCESS_DENIED
)
.
WithMessage
(
"
Could
not
open
the
file
at
%
s
for
writing
"
NS_ConvertUTF16toUTF8
(
tmpPath
)
.
get
(
)
)
)
;
}
auto
rv
=
WriteSync
(
fd
.
get
(
)
NS_ConvertUTF16toUTF8
(
tmpPath
)
aByteArray
)
;
if
(
rv
.
isErr
(
)
)
{
return
rv
.
propagateErr
(
)
;
}
result
=
rv
.
unwrap
(
)
;
}
if
(
aDestPath
!
=
tmpPath
&
&
MoveSync
(
tmpPath
aDestPath
false
)
.
isErr
(
)
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_COPY_OR_MOVE_FAILED
)
.
WithMessage
(
"
Could
not
move
temporary
file
(
%
s
)
to
destination
(
%
s
)
"
NS_ConvertUTF16toUTF8
(
tmpPath
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aDestPath
)
.
get
(
)
)
)
;
}
return
result
;
}
Result
<
uint32_t
IOUtils
:
:
IOError
>
IOUtils
:
:
WriteSync
(
PRFileDesc
*
aFd
const
nsACString
&
aPath
const
nsTArray
<
uint8_t
>
&
aBytes
)
{
MOZ_ASSERT
(
aBytes
.
Length
(
)
<
=
UINT32_MAX
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
aBytes
.
Length
(
)
=
=
0
)
{
return
0
;
}
uint32_t
bytesWritten
=
0
;
uint32_t
chunkSize
=
PR_INT32_MAX
;
uint32_t
pendingBytes
=
aBytes
.
Length
(
)
;
while
(
pendingBytes
>
0
)
{
if
(
pendingBytes
<
chunkSize
)
{
chunkSize
=
pendingBytes
;
}
int32_t
rv
=
PR_Write
(
aFd
aBytes
.
Elements
(
)
+
bytesWritten
chunkSize
)
;
if
(
rv
<
0
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_CORRUPTED
)
.
WithMessage
(
"
Could
not
write
chunk
(
size
=
%
"
PRIu32
"
)
to
%
s
\
n
"
"
The
file
may
be
corrupt
"
chunkSize
aPath
.
BeginReading
(
)
)
)
;
}
pendingBytes
-
=
rv
;
bytesWritten
+
=
rv
;
}
return
bytesWritten
;
}
Result
<
Ok
IOUtils
:
:
IOError
>
IOUtils
:
:
MoveSync
(
const
nsAString
&
aSourcePath
const
nsAString
&
aDestPath
bool
noOverwrite
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIFile
>
srcFile
=
new
nsLocalFile
(
)
;
MOZ_TRY
(
srcFile
-
>
InitWithPath
(
aSourcePath
)
)
;
bool
srcExists
;
MOZ_TRY
(
srcFile
-
>
Exists
(
&
srcExists
)
)
;
if
(
!
srcExists
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_NOT_FOUND
)
.
WithMessage
(
"
Could
not
move
source
file
(
%
s
)
because
it
does
not
exist
"
NS_ConvertUTF16toUTF8
(
aSourcePath
)
.
get
(
)
)
)
;
}
MOZ_TRY
(
srcFile
-
>
Normalize
(
)
)
;
nsCOMPtr
<
nsIFile
>
destFile
=
new
nsLocalFile
(
)
;
MOZ_TRY
(
destFile
-
>
InitWithPath
(
aDestPath
)
)
;
rv
=
destFile
-
>
Normalize
(
)
;
if
(
NS_FAILED
(
rv
)
&
&
!
IsFileNotFound
(
rv
)
)
{
return
Err
(
IOError
(
rv
)
)
;
}
bool
destIsDir
=
false
;
bool
destExists
=
true
;
rv
=
destFile
-
>
IsDirectory
(
&
destIsDir
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
destIsDir
)
{
rv
=
srcFile
-
>
MoveTo
(
destFile
EmptyString
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
IOError
(
rv
)
.
WithMessage
(
"
Could
not
move
source
file
(
%
s
)
to
destination
(
%
s
)
"
NS_ConvertUTF16toUTF8
(
aSourcePath
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aDestPath
)
.
get
(
)
)
)
;
}
return
Ok
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
!
IsFileNotFound
(
rv
)
)
{
return
Err
(
IOError
(
rv
)
)
;
}
destExists
=
false
;
}
if
(
noOverwrite
&
&
destExists
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_ALREADY_EXISTS
)
.
WithMessage
(
"
Could
not
move
source
file
(
%
s
)
to
destination
(
%
s
)
because
the
"
"
destination
already
exists
and
overwrites
are
not
allowed
\
n
"
"
Specify
the
noOverwrite
:
false
option
to
mitigate
this
"
"
error
"
NS_ConvertUTF16toUTF8
(
aDestPath
)
.
get
(
)
)
)
;
}
if
(
destExists
&
&
!
destIsDir
)
{
bool
srcIsDir
=
false
;
MOZ_TRY
(
srcFile
-
>
IsDirectory
(
&
srcIsDir
)
)
;
if
(
srcIsDir
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_DESTINATION_NOT_DIR
)
.
WithMessage
(
"
Could
not
move
the
source
directory
(
%
s
)
to
"
"
the
destination
(
%
s
)
"
"
because
the
destination
is
not
a
directory
"
NS_ConvertUTF16toUTF8
(
aSourcePath
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aDestPath
)
.
get
(
)
)
)
;
}
}
nsCOMPtr
<
nsIFile
>
destDir
;
nsAutoString
destName
;
MOZ_TRY
(
destFile
-
>
GetLeafName
(
destName
)
)
;
MOZ_TRY
(
destFile
-
>
GetParent
(
getter_AddRefs
(
destDir
)
)
)
;
rv
=
srcFile
-
>
MoveTo
(
destDir
destName
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
IOError
(
rv
)
.
WithMessage
(
"
Could
not
move
the
source
file
(
%
s
)
to
the
destination
(
%
s
)
"
NS_ConvertUTF16toUTF8
(
aSourcePath
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
aDestPath
)
.
get
(
)
)
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
IOUtils
:
:
IOError
>
IOUtils
:
:
RemoveSync
(
const
nsAString
&
aPath
bool
aIgnoreAbsent
bool
aRecursive
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
)
;
MOZ_TRY
(
file
-
>
InitWithPath
(
aPath
)
)
;
nsresult
rv
=
file
-
>
Remove
(
aRecursive
)
;
if
(
aIgnoreAbsent
&
&
IsFileNotFound
(
rv
)
)
{
return
Ok
(
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
IOError
err
(
rv
)
;
if
(
IsFileNotFound
(
rv
)
)
{
return
Err
(
err
.
WithMessage
(
"
Could
not
remove
the
file
at
%
s
because
it
does
not
exist
.
\
n
"
"
Specify
the
ignoreAbsent
:
true
option
to
mitigate
this
error
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
if
(
rv
=
=
NS_ERROR_FILE_DIR_NOT_EMPTY
)
{
return
Err
(
err
.
WithMessage
(
"
Could
not
remove
the
non
-
empty
directory
at
%
s
.
\
n
"
"
Specify
the
recursive
:
true
option
to
mitigate
this
error
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
return
Err
(
err
.
WithMessage
(
"
Could
not
remove
the
file
at
%
s
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
return
Ok
(
)
;
}
Result
<
Ok
IOUtils
:
:
IOError
>
IOUtils
:
:
CreateDirectorySync
(
const
nsAString
&
aPath
bool
aCreateAncestors
bool
aIgnoreExisting
int32_t
aMode
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
nsLocalFile
>
targetFile
=
new
nsLocalFile
(
)
;
MOZ_TRY
(
targetFile
-
>
InitWithPath
(
aPath
)
)
;
if
(
!
aCreateAncestors
)
{
nsCOMPtr
<
nsIFile
>
parent
;
MOZ_TRY
(
targetFile
-
>
GetParent
(
getter_AddRefs
(
parent
)
)
)
;
bool
parentExists
;
MOZ_TRY
(
parent
-
>
Exists
(
&
parentExists
)
)
;
if
(
!
parentExists
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_NOT_FOUND
)
.
WithMessage
(
"
Could
not
create
directory
at
%
s
because
"
"
the
path
has
missing
"
"
ancestor
components
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
}
nsresult
rv
=
targetFile
-
>
Create
(
nsIFile
:
:
DIRECTORY_TYPE
aMode
)
;
if
(
NS_FAILED
(
rv
)
)
{
IOError
err
(
rv
)
;
if
(
rv
=
=
NS_ERROR_FILE_ALREADY_EXISTS
)
{
bool
isDirectory
;
MOZ_TRY
(
targetFile
-
>
IsDirectory
(
&
isDirectory
)
)
;
if
(
!
isDirectory
)
{
return
Err
(
IOError
(
NS_ERROR_FILE_NOT_DIRECTORY
)
.
WithMessage
(
"
Could
not
create
directory
because
the
"
"
target
file
(
%
s
)
exists
"
"
and
is
not
a
directory
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
if
(
aIgnoreExisting
)
{
return
Ok
(
)
;
}
return
Err
(
err
.
WithMessage
(
"
Could
not
create
directory
because
it
already
exists
at
%
s
\
n
"
"
Specify
the
ignoreExisting
:
true
option
to
mitigate
this
"
"
error
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
return
Err
(
err
.
WithMessage
(
"
Could
not
create
directory
at
%
s
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
return
Ok
(
)
;
}
Result
<
IOUtils
:
:
InternalFileInfo
IOUtils
:
:
IOError
>
IOUtils
:
:
StatSync
(
const
nsAString
&
aPath
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
RefPtr
<
nsLocalFile
>
file
=
new
nsLocalFile
(
)
;
MOZ_TRY
(
file
-
>
InitWithPath
(
aPath
)
)
;
InternalFileInfo
info
;
info
.
mPath
=
nsString
(
aPath
)
;
bool
isRegular
;
nsresult
rv
=
file
-
>
IsFile
(
&
isRegular
)
;
if
(
NS_FAILED
(
rv
)
)
{
IOError
err
(
rv
)
;
if
(
IsFileNotFound
(
rv
)
)
{
return
Err
(
err
.
WithMessage
(
"
Could
not
stat
file
(
%
s
)
because
it
does
not
exist
"
NS_ConvertUTF16toUTF8
(
aPath
)
.
get
(
)
)
)
;
}
return
Err
(
err
)
;
}
info
.
mType
=
FileType
:
:
Regular
;
if
(
!
isRegular
)
{
bool
isDir
;
MOZ_TRY
(
file
-
>
IsDirectory
(
&
isDir
)
)
;
if
(
isDir
)
{
info
.
mType
=
FileType
:
:
Directory
;
}
else
{
info
.
mType
=
FileType
:
:
Other
;
}
}
int64_t
size
=
-
1
;
if
(
info
.
mType
=
=
FileType
:
:
Regular
)
{
MOZ_TRY
(
file
-
>
GetFileSize
(
&
size
)
)
;
}
info
.
mSize
=
size
;
PRTime
lastModified
=
0
;
MOZ_TRY
(
file
-
>
GetLastModifiedTime
(
&
lastModified
)
)
;
info
.
mLastModified
=
static_cast
<
int64_t
>
(
lastModified
)
;
return
info
;
}
NS_IMPL_ISUPPORTS
(
IOUtilsShutdownBlocker
nsIAsyncShutdownBlocker
)
;
NS_IMETHODIMP
IOUtilsShutdownBlocker
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
u
"
IOUtils
Blocker
"
_ns
;
return
NS_OK
;
}
NS_IMETHODIMP
IOUtilsShutdownBlocker
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aBarrierClient
)
{
nsCOMPtr
<
nsISerialEventTarget
>
et
=
IOUtils
:
:
GetBackgroundEventTarget
(
)
;
IOUtils
:
:
sShutdownStarted
=
true
;
if
(
!
IOUtils
:
:
sBarrier
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
nsIRunnable
>
backgroundRunnable
=
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
this
)
]
(
)
{
nsCOMPtr
<
nsIRunnable
>
mainThreadRunnable
=
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
self
)
]
(
)
{
IOUtils
:
:
sBarrier
-
>
RemoveBlocker
(
self
)
;
auto
lockedBackgroundET
=
IOUtils
:
:
sBackgroundEventTarget
.
Lock
(
)
;
*
lockedBackgroundET
=
nullptr
;
IOUtils
:
:
sBarrier
=
nullptr
;
}
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
mainThreadRunnable
.
forget
(
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
)
;
return
et
-
>
Dispatch
(
backgroundRunnable
.
forget
(
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
IOUtilsShutdownBlocker
:
:
GetState
(
nsIPropertyBag
*
*
aState
)
{
return
NS_OK
;
}
}
}
#
undef
REJECT_IF_NULL_EVENT_TARGET
#
undef
REJECT_IF_SHUTTING_DOWN
#
undef
REJECT_IF_RELATIVE_PATH
