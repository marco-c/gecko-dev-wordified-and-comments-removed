#
include
<
algorithm
>
#
include
"
mozilla
/
dom
/
IOUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
ErrorNames
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
nspr
/
prio
.
h
"
#
include
"
nspr
/
private
/
pprio
.
h
"
#
include
"
nspr
/
prtypes
.
h
"
#
include
"
nsDirectoryServiceDefs
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
SpecialSystemDirectory
.
h
"
#
if
defined
(
__unix__
)
|
|
(
defined
(
__APPLE__
)
&
&
defined
(
__MACH__
)
)
#
include
<
fcntl
.
h
>
#
endif
#
define
REJECT_IF_NULL_EVENT_TARGET
(
aEventTarget
aJSPromise
)
\
do
{
\
if
(
!
(
aEventTarget
)
)
{
\
(
aJSPromise
)
\
-
>
MaybeRejectWithAbortError
(
\
"
Could
not
dispatch
task
to
background
thread
"
)
;
\
return
(
aJSPromise
)
.
forget
(
)
;
\
}
\
}
while
(
false
)
#
define
REJECT_IF_SHUTTING_DOWN
(
aJSPromise
)
\
do
{
\
if
(
sShutdownStarted
)
{
\
(
aJSPromise
)
\
-
>
MaybeRejectWithNotAllowedError
(
\
"
Shutting
down
and
refusing
additional
I
/
O
tasks
"
)
;
\
return
(
aJSPromise
)
.
forget
(
)
;
\
}
\
}
while
(
false
)
namespace
mozilla
{
namespace
dom
{
static
bool
IsFileNotFound
(
nsresult
aResult
)
{
switch
(
aResult
)
{
case
NS_ERROR_FILE_NOT_FOUND
:
case
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
:
return
true
;
default
:
return
false
;
}
}
static
nsCString
FormatErrorMessage
(
nsresult
aError
const
char
*
const
aMessage
)
{
const
char
*
errName
=
GetStaticErrorName
(
aError
)
;
if
(
errName
)
{
return
nsPrintfCString
(
"
%
s
:
%
s
"
aMessage
errName
)
;
}
return
nsPrintfCString
(
"
%
s
:
0x
%
"
PRIX32
aMessage
static_cast
<
uint32_t
>
(
aError
)
)
;
}
StaticDataMutex
<
StaticRefPtr
<
nsISerialEventTarget
>
>
IOUtils
:
:
sBackgroundEventTarget
(
"
sBackgroundEventTarget
"
)
;
StaticRefPtr
<
nsIAsyncShutdownClient
>
IOUtils
:
:
sBarrier
;
Atomic
<
bool
>
IOUtils
:
:
sShutdownStarted
=
Atomic
<
bool
>
(
false
)
;
already_AddRefed
<
Promise
>
IOUtils
:
:
Read
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Optional
<
uint32_t
>
&
aMaxBytes
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
uint32_t
toRead
=
0
;
if
(
aMaxBytes
.
WasPassed
(
)
)
{
toRead
=
aMaxBytes
.
Value
(
)
;
if
(
toRead
=
=
0
)
{
nsTArray
<
uint8_t
>
arr
(
0
)
;
TypedArrayCreator
<
Uint8Array
>
arrCreator
(
arr
)
;
promise
-
>
MaybeResolve
(
arrCreator
)
;
return
promise
.
forget
(
)
;
}
}
NS_ConvertUTF16toUTF8
path
(
aPath
)
;
InvokeAsync
(
bg
__func__
[
path
toRead
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
fd
=
OpenExistingSync
(
path
.
get
(
)
PR_RDONLY
)
;
if
(
!
fd
)
{
return
IOReadMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
Could
not
open
file
"
)
__func__
)
;
}
uint32_t
bufSize
;
if
(
toRead
=
=
0
)
{
PRFileInfo64
info
;
if
(
PR_FAILURE
=
=
PR_GetOpenFileInfo64
(
fd
.
get
(
)
&
info
)
)
{
return
IOReadMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
Could
not
get
file
info
"
)
__func__
)
;
}
uint32_t
fileSize
=
info
.
size
;
if
(
fileSize
>
UINT32_MAX
)
{
return
IOReadMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
File
is
too
large
to
read
"
)
__func__
)
;
}
bufSize
=
fileSize
;
}
else
{
bufSize
=
toRead
;
}
nsTArray
<
uint8_t
>
fileContents
;
nsresult
er
=
IOUtils
:
:
ReadSync
(
fd
.
get
(
)
bufSize
fileContents
)
;
if
(
NS_SUCCEEDED
(
er
)
)
{
return
IOReadMozPromise
:
:
CreateAndResolve
(
std
:
:
move
(
fileContents
)
__func__
)
;
}
if
(
er
=
=
NS_ERROR_OUT_OF_MEMORY
)
{
return
IOReadMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
Out
of
memory
"
)
__func__
)
;
}
return
IOReadMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
Unexpected
error
reading
file
"
)
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
nsTArray
<
uint8_t
>
&
aBuf
)
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
promise
-
>
GetGlobalObject
(
)
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
const
TypedArrayCreator
<
Uint8Array
>
arrayCreator
(
aBuf
)
;
promise
-
>
MaybeResolve
(
arrayCreator
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
nsACString
&
aMsg
)
{
promise
-
>
MaybeRejectWithOperationError
(
aMsg
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
WriteAtomic
(
GlobalObject
&
aGlobal
const
nsAString
&
aPath
const
Uint8Array
&
aData
const
WriteAtomicOptions
&
aOptions
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
aData
.
ComputeState
(
)
;
FallibleTArray
<
uint8_t
>
toWrite
;
if
(
!
toWrite
.
InsertElementsAt
(
0
aData
.
Data
(
)
aData
.
Length
(
)
fallible
)
)
{
promise
-
>
MaybeRejectWithOperationError
(
"
Out
of
memory
"
)
;
return
promise
.
forget
(
)
;
}
int32_t
flags
=
PR_WRONLY
|
PR_TRUNCATE
|
PR_APPEND
;
bool
noOverwrite
=
false
;
if
(
aOptions
.
IsAnyMemberPresent
(
)
)
{
if
(
aOptions
.
mBackupFile
.
WasPassed
(
)
|
|
aOptions
.
mTmpPath
.
WasPassed
(
)
)
{
promise
-
>
MaybeRejectWithNotSupportedError
(
"
Unsupported
options
were
passed
"
)
;
return
promise
.
forget
(
)
;
}
if
(
aOptions
.
mFlush
)
{
flags
|
=
PR_SYNC
;
}
noOverwrite
=
aOptions
.
mNoOverwrite
;
}
NS_ConvertUTF16toUTF8
path
(
aPath
)
;
InvokeAsync
(
bg
__func__
[
path
flags
noOverwrite
toWrite
=
std
:
:
move
(
toWrite
)
]
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
fd
=
OpenExistingSync
(
path
.
get
(
)
flags
)
;
if
(
noOverwrite
&
&
fd
)
{
return
IOWriteMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
Refusing
to
overwrite
file
"
)
__func__
)
;
}
if
(
!
fd
)
{
fd
=
CreateFileSync
(
path
.
get
(
)
flags
)
;
}
if
(
!
fd
)
{
return
IOWriteMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
Could
not
open
file
"
)
__func__
)
;
}
uint32_t
result
;
nsresult
er
=
IOUtils
:
:
WriteSync
(
fd
.
get
(
)
toWrite
result
)
;
if
(
NS_SUCCEEDED
(
er
)
)
{
return
IOWriteMozPromise
:
:
CreateAndResolve
(
result
__func__
)
;
}
return
IOWriteMozPromise
:
:
CreateAndReject
(
nsLiteralCString
(
"
Unexpected
error
writing
file
"
)
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
uint32_t
&
aBytesWritten
)
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
promise
-
>
GetGlobalObject
(
)
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
promise
-
>
MaybeResolve
(
aBytesWritten
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
nsACString
&
aMsg
)
{
promise
-
>
MaybeRejectWithOperationError
(
aMsg
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
Move
(
GlobalObject
&
aGlobal
const
nsAString
&
aSourcePath
const
nsAString
&
aDestPath
const
MoveOptions
&
aOptions
)
{
RefPtr
<
Promise
>
promise
=
CreateJSPromise
(
aGlobal
)
;
NS_ENSURE_TRUE
(
!
!
promise
nullptr
)
;
REJECT_IF_SHUTTING_DOWN
(
promise
)
;
RefPtr
<
nsISerialEventTarget
>
bg
=
GetBackgroundEventTarget
(
)
;
REJECT_IF_NULL_EVENT_TARGET
(
bg
promise
)
;
bool
noOverwrite
=
false
;
if
(
aOptions
.
IsAnyMemberPresent
(
)
)
{
noOverwrite
=
aOptions
.
mNoOverwrite
;
}
InvokeAsync
(
bg
__func__
[
srcPathString
=
nsAutoString
(
aSourcePath
)
destPathString
=
nsAutoString
(
aDestPath
)
noOverwrite
]
(
)
{
nsresult
rv
=
MoveSync
(
srcPathString
destPathString
noOverwrite
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
IOMoveMozPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
return
IOMoveMozPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
=
RefPtr
(
promise
)
]
(
const
bool
&
)
{
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
promise
-
>
GetGlobalObject
(
)
)
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
=
RefPtr
(
promise
)
]
(
const
nsresult
&
aError
)
{
switch
(
aError
)
{
case
NS_ERROR_FILE_ACCESS_DENIED
:
promise
-
>
MaybeRejectWithInvalidAccessError
(
"
Access
denied
"
)
;
break
;
case
NS_ERROR_FILE_TARGET_DOES_NOT_EXIST
:
case
NS_ERROR_FILE_NOT_FOUND
:
promise
-
>
MaybeRejectWithNotFoundError
(
"
Source
file
does
not
exist
"
)
;
break
;
case
NS_ERROR_FILE_ALREADY_EXISTS
:
promise
-
>
MaybeRejectWithNoModificationAllowedError
(
"
Destination
file
exists
and
overwrites
are
not
allowed
"
)
;
break
;
case
NS_ERROR_FILE_READ_ONLY
:
promise
-
>
MaybeRejectWithNoModificationAllowedError
(
"
Destination
is
read
only
"
)
;
break
;
case
NS_ERROR_FILE_DESTINATION_NOT_DIR
:
promise
-
>
MaybeRejectWithInvalidAccessError
(
"
Source
is
a
directory
but
destination
is
not
"
)
;
break
;
case
NS_ERROR_FILE_UNRECOGNIZED_PATH
:
promise
-
>
MaybeRejectWithOperationError
(
"
Only
absolute
file
paths
are
permitted
"
)
;
break
;
default
:
{
promise
-
>
MaybeRejectWithUnknownError
(
FormatErrorMessage
(
aError
"
Unexpected
error
moving
file
"
)
)
;
}
}
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
nsISerialEventTarget
>
IOUtils
:
:
GetBackgroundEventTarget
(
)
{
if
(
sShutdownStarted
)
{
return
nullptr
;
}
auto
lockedBackgroundEventTarget
=
sBackgroundEventTarget
.
Lock
(
)
;
if
(
!
lockedBackgroundEventTarget
.
ref
(
)
)
{
RefPtr
<
nsISerialEventTarget
>
et
;
MOZ_ALWAYS_SUCCEEDS
(
NS_CreateBackgroundTaskQueue
(
"
IOUtils
:
:
BackgroundIOThread
"
getter_AddRefs
(
et
)
)
)
;
MOZ_ASSERT
(
et
)
;
*
lockedBackgroundEventTarget
=
et
;
if
(
NS_IsMainThread
(
)
)
{
IOUtils
:
:
SetShutdownHooks
(
)
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
__func__
[
]
(
)
{
IOUtils
:
:
SetShutdownHooks
(
)
;
}
)
;
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
}
return
do_AddRef
(
*
lockedBackgroundEventTarget
)
;
}
already_AddRefed
<
nsIAsyncShutdownClient
>
IOUtils
:
:
GetShutdownBarrier
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sBarrier
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdownService
(
)
;
MOZ_ASSERT
(
svc
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
;
nsresult
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
barrier
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
sBarrier
=
barrier
;
}
return
do_AddRef
(
sBarrier
)
;
}
void
IOUtils
:
:
SetShutdownHooks
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
barrier
=
GetShutdownBarrier
(
)
;
nsCOMPtr
<
nsIAsyncShutdownBlocker
>
blocker
=
new
IOUtilsShutdownBlocker
(
)
;
nsresult
rv
=
barrier
-
>
AddBlocker
(
blocker
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
u
"
IOUtils
:
waiting
for
pending
I
/
O
to
finish
"
_ns
)
;
if
(
NS_FAILED
(
rv
)
)
{
sShutdownStarted
=
true
;
}
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
already_AddRefed
<
Promise
>
IOUtils
:
:
CreateJSPromise
(
GlobalObject
&
aGlobal
)
{
ErrorResult
er
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
er
)
;
if
(
er
.
Failed
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
promise
)
;
return
do_AddRef
(
promise
)
;
}
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
IOUtils
:
:
OpenExistingSync
(
const
char
*
aPath
int32_t
aFlags
)
{
MOZ_ASSERT
(
(
aFlags
&
(
PR_CREATE_FILE
|
PR_EXCL
)
)
=
=
0
)
;
return
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
(
PR_Open
(
aPath
aFlags
0
)
)
;
}
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
IOUtils
:
:
CreateFileSync
(
const
char
*
aPath
int32_t
aFlags
int32_t
aMode
)
{
return
UniquePtr
<
PRFileDesc
PR_CloseDelete
>
(
PR_Open
(
aPath
aFlags
|
PR_CREATE_FILE
|
PR_EXCL
aMode
)
)
;
}
nsresult
IOUtils
:
:
ReadSync
(
PRFileDesc
*
aFd
const
uint32_t
aBufSize
nsTArray
<
uint8_t
>
&
aResult
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsTArray
<
uint8_t
>
buffer
;
if
(
!
buffer
.
SetCapacity
(
aBufSize
fallible
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
#
if
defined
(
HAVE_POSIX_FADVISE
)
posix_fadvise
(
PR_FileDesc2NativeHandle
(
aFd
)
0
0
POSIX_FADV_SEQUENTIAL
)
;
#
endif
uint32_t
totalRead
=
0
;
while
(
totalRead
!
=
aBufSize
)
{
int32_t
nRead
=
PR_Read
(
aFd
buffer
.
Elements
(
)
+
totalRead
aBufSize
-
totalRead
)
;
if
(
nRead
=
=
0
)
{
break
;
}
if
(
nRead
<
0
)
{
return
NS_ERROR_UNEXPECTED
;
}
totalRead
+
=
nRead
;
DebugOnly
<
bool
>
success
=
buffer
.
SetLength
(
totalRead
fallible
)
;
MOZ_ASSERT
(
success
)
;
}
aResult
=
std
:
:
move
(
buffer
)
;
return
NS_OK
;
}
nsresult
IOUtils
:
:
WriteSync
(
PRFileDesc
*
aFd
const
nsTArray
<
uint8_t
>
&
aBytes
uint32_t
&
aResult
)
{
MOZ_ASSERT
(
aBytes
.
Length
(
)
<
=
UINT32_MAX
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
aBytes
.
Length
(
)
=
=
0
)
{
aResult
=
0
;
return
NS_OK
;
}
uint32_t
bytesWritten
=
0
;
uint32_t
chunkSize
=
PR_INT32_MAX
;
uint32_t
pendingBytes
=
aBytes
.
Length
(
)
;
while
(
pendingBytes
>
0
)
{
if
(
pendingBytes
<
chunkSize
)
{
chunkSize
=
pendingBytes
;
}
int32_t
rv
=
PR_Write
(
aFd
aBytes
.
Elements
(
)
+
bytesWritten
chunkSize
)
;
if
(
rv
<
0
)
{
return
NS_ERROR_FILE_CORRUPTED
;
}
pendingBytes
-
=
rv
;
bytesWritten
+
=
rv
;
}
aResult
=
bytesWritten
;
return
NS_OK
;
}
nsresult
IOUtils
:
:
MoveSync
(
const
nsAString
&
aSourcePath
const
nsAString
&
aDestPath
bool
noOverwrite
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIFile
>
srcFile
=
new
nsLocalFile
(
)
;
MOZ_TRY
(
srcFile
-
>
InitWithPath
(
aSourcePath
)
)
;
MOZ_TRY
(
srcFile
-
>
Normalize
(
)
)
;
nsCOMPtr
<
nsIFile
>
destFile
=
new
nsLocalFile
(
)
;
MOZ_TRY
(
destFile
-
>
InitWithPath
(
aDestPath
)
)
;
rv
=
destFile
-
>
Normalize
(
)
;
if
(
!
IsFileNotFound
(
rv
)
)
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
bool
destIsDir
=
false
;
bool
destExists
=
true
;
rv
=
destFile
-
>
IsDirectory
(
&
destIsDir
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
destIsDir
)
{
return
srcFile
-
>
MoveTo
(
destFile
EmptyString
(
)
)
;
}
if
(
IsFileNotFound
(
rv
)
)
{
destExists
=
false
;
}
else
{
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
noOverwrite
&
&
destExists
)
{
return
NS_ERROR_FILE_ALREADY_EXISTS
;
}
if
(
destExists
&
&
!
destIsDir
)
{
bool
srcIsDir
=
false
;
MOZ_TRY
(
srcFile
-
>
IsDirectory
(
&
srcIsDir
)
)
;
if
(
srcIsDir
)
{
return
NS_ERROR_FILE_DESTINATION_NOT_DIR
;
}
}
nsCOMPtr
<
nsIFile
>
destDir
;
nsAutoString
destName
;
MOZ_TRY
(
destFile
-
>
GetLeafName
(
destName
)
)
;
MOZ_TRY
(
destFile
-
>
GetParent
(
getter_AddRefs
(
destDir
)
)
)
;
return
srcFile
-
>
MoveTo
(
destDir
destName
)
;
}
NS_IMPL_ISUPPORTS
(
IOUtilsShutdownBlocker
nsIAsyncShutdownBlocker
)
;
NS_IMETHODIMP
IOUtilsShutdownBlocker
:
:
GetName
(
nsAString
&
aName
)
{
aName
=
u
"
IOUtils
Blocker
"
_ns
;
return
NS_OK
;
}
NS_IMETHODIMP
IOUtilsShutdownBlocker
:
:
BlockShutdown
(
nsIAsyncShutdownClient
*
aBarrierClient
)
{
nsCOMPtr
<
nsISerialEventTarget
>
et
=
IOUtils
:
:
GetBackgroundEventTarget
(
)
;
IOUtils
:
:
sShutdownStarted
=
true
;
if
(
!
IOUtils
:
:
sBarrier
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
nsIRunnable
>
backgroundRunnable
=
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
this
)
]
(
)
{
nsCOMPtr
<
nsIRunnable
>
mainThreadRunnable
=
NS_NewRunnableFunction
(
__func__
[
self
=
RefPtr
(
self
)
]
(
)
{
IOUtils
:
:
sBarrier
-
>
RemoveBlocker
(
self
)
;
auto
lockedBackgroundET
=
IOUtils
:
:
sBackgroundEventTarget
.
Lock
(
)
;
*
lockedBackgroundET
=
nullptr
;
IOUtils
:
:
sBarrier
=
nullptr
;
}
)
;
nsresult
er
=
NS_DispatchToMainThread
(
mainThreadRunnable
.
forget
(
)
)
;
NS_ENSURE_SUCCESS_VOID
(
er
)
;
}
)
;
return
et
-
>
Dispatch
(
backgroundRunnable
.
forget
(
)
nsIEventTarget
:
:
DISPATCH_NORMAL
)
;
}
NS_IMETHODIMP
IOUtilsShutdownBlocker
:
:
GetState
(
nsIPropertyBag
*
*
aState
)
{
return
NS_OK
;
}
}
}
#
undef
REJECT_IF_NULL_EVENT_TARGET
#
undef
REJECT_IF_SHUTTING_DOWN
