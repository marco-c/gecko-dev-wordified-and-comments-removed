#
include
"
GeolocationSystem
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsIGeolocationUIUtilsWin
.
h
"
#
include
"
nsIWifiListener
.
h
"
#
include
"
nsIWifiMonitor
.
h
"
#
include
<
windows
.
system
.
h
>
#
include
<
windows
.
security
.
authorization
.
appcapabilityaccess
.
h
>
#
include
<
wrl
.
h
>
namespace
mozilla
:
:
dom
:
:
geolocation
{
using
namespace
ABI
:
:
Windows
:
:
Foundation
;
using
namespace
ABI
:
:
Windows
:
:
Security
:
:
Authorization
:
:
AppCapabilityAccess
;
using
namespace
ABI
:
:
Windows
:
:
System
;
using
namespace
Microsoft
:
:
WRL
;
using
Wrappers
:
:
HStringReference
;
namespace
{
const
auto
&
kAppCapabilityGuid
=
RuntimeClass_Windows_Security_Authorization_AppCapabilityAccess_AppCapability
;
const
auto
&
kLauncherGuid
=
RuntimeClass_Windows_System_Launcher
;
const
auto
&
kUriGuid
=
RuntimeClass_Windows_Foundation_Uri
;
const
wchar_t
kLocationSettingsPage
[
]
=
L
"
ms
-
settings
:
privacy
-
location
"
;
template
<
typename
TypeToCreate
>
ComPtr
<
TypeToCreate
>
CreateFromActivationFactory
(
const
wchar_t
*
aNamespace
)
{
ComPtr
<
TypeToCreate
>
newObject
;
GetActivationFactory
(
HStringReference
(
aNamespace
)
.
Get
(
)
&
newObject
)
;
return
newObject
;
}
RefPtr
<
IAppCapability
>
GetWifiControlAppCapability
(
)
{
ComPtr
<
IAppCapabilityStatics
>
appCapabilityStatics
=
CreateFromActivationFactory
<
IAppCapabilityStatics
>
(
kAppCapabilityGuid
)
;
NS_ENSURE_TRUE
(
appCapabilityStatics
nullptr
)
;
RefPtr
<
IAppCapability
>
appCapability
;
HRESULT
hr
=
appCapabilityStatics
-
>
Create
(
HStringReference
(
L
"
wifiControl
"
)
.
Get
(
)
getter_AddRefs
(
appCapability
)
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
nullptr
)
;
NS_ENSURE_TRUE
(
appCapability
nullptr
)
;
return
appCapability
;
}
Maybe
<
AppCapabilityAccessStatus
>
GetWifiControlAccess
(
IAppCapability
*
aWifiControlAppCapability
)
{
NS_ENSURE_TRUE
(
aWifiControlAppCapability
Nothing
(
)
)
;
AppCapabilityAccessStatus
status
;
HRESULT
hr
=
aWifiControlAppCapability
-
>
CheckAccess
(
&
status
)
;
NS_ENSURE_TRUE
(
SUCCEEDED
(
hr
)
Nothing
(
)
)
;
return
Some
(
status
)
;
}
Maybe
<
AppCapabilityAccessStatus
>
GetWifiControlAccess
(
)
{
RefPtr
wifiControlAppCapability
=
GetWifiControlAppCapability
(
)
;
return
GetWifiControlAccess
(
wifiControlAppCapability
.
get
(
)
)
;
}
bool
SystemWillPromptForPermissionHint
(
Maybe
<
AppCapabilityAccessStatus
>
aWifiAccess
)
{
if
(
aWifiAccess
!
=
mozilla
:
:
Some
(
AppCapabilityAccessStatus
:
:
AppCapabilityAccessStatus_UserPromptRequired
)
)
{
return
false
;
}
nsCOMPtr
<
nsIWifiMonitor
>
wifiMonitor
=
components
:
:
WifiMonitor
:
:
Service
(
)
;
NS_ENSURE_TRUE
(
wifiMonitor
false
)
;
return
wifiMonitor
-
>
GetHasWifiAdapter
(
)
;
}
bool
LocationIsPermittedHint
(
Maybe
<
AppCapabilityAccessStatus
>
aWifiAccess
)
{
return
aWifiAccess
.
isNothing
(
)
|
|
*
aWifiAccess
=
=
AppCapabilityAccessStatus
:
:
AppCapabilityAccessStatus_Allowed
;
}
class
WindowsGeolocationPermissionRequest
final
:
public
SystemGeolocationPermissionRequest
public
SupportsThreadSafeWeakPtr
<
WindowsGeolocationPermissionRequest
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
WindowsGeolocationPermissionRequest
)
;
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
WindowsGeolocationPermissionRequest
SupportsThreadSafeWeakPtr
<
WindowsGeolocationPermissionRequest
>
)
;
WindowsGeolocationPermissionRequest
(
BrowsingContext
*
aBrowsingContext
ParentRequestResolver
&
&
aResolver
)
:
mResolver
(
std
:
:
move
(
aResolver
)
)
mBrowsingContext
(
aBrowsingContext
)
{
}
void
Initialize
(
)
{
MOZ_ASSERT
(
!
mIsRunning
)
;
auto
failedToWatch
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
!
mIsRunning
)
{
mAppCapability
=
nullptr
;
mToken
=
EventRegistrationToken
{
}
;
mResolver
(
GeolocationPermissionStatus
:
:
Error
)
;
}
}
)
;
mAppCapability
=
GetWifiControlAppCapability
(
)
;
if
(
!
mAppCapability
)
{
return
;
}
using
AccessChangedHandler
=
ITypedEventHandler
<
AppCapability
*
AppCapabilityAccessChangedEventArgs
*
>
;
ComPtr
<
AccessChangedHandler
>
acHandlerRef
=
Callback
<
Implements
<
RuntimeClassFlags
<
ClassicCom
>
AccessChangedHandler
FtmBase
>
>
(
[
weakSelf
=
ThreadSafeWeakPtr
<
WindowsGeolocationPermissionRequest
>
(
this
)
]
(
IAppCapability
*
IAppCapabilityAccessChangedEventArgs
*
)
{
if
(
!
NS_IsMainThread
(
)
)
{
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
__func__
[
weakSelf
]
(
)
{
RefPtr
<
WindowsGeolocationPermissionRequest
>
self
(
weakSelf
)
;
if
(
self
)
{
self
-
>
StopIfLocationIsPermitted
(
)
;
}
}
)
)
;
return
S_OK
;
}
RefPtr
<
WindowsGeolocationPermissionRequest
>
self
(
weakSelf
)
;
if
(
self
)
{
self
-
>
StopIfLocationIsPermitted
(
)
;
}
return
S_OK
;
}
)
;
if
(
!
acHandlerRef
)
{
return
;
}
HRESULT
hr
=
mAppCapability
-
>
add_AccessChanged
(
acHandlerRef
.
Get
(
)
&
mToken
)
;
NS_ENSURE_TRUE_VOID
(
SUCCEEDED
(
hr
)
)
;
MOZ_ASSERT
(
mToken
.
value
)
;
mIsRunning
=
true
;
failedToWatch
.
release
(
)
;
StopIfLocationIsPermitted
(
)
;
}
protected
:
void
Stop
(
Maybe
<
AppCapabilityAccessStatus
>
aWifiAccess
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mIsRunning
)
{
return
;
}
mIsRunning
=
false
;
if
(
LocationIsPermittedHint
(
aWifiAccess
)
)
{
mResolver
(
GeolocationPermissionStatus
:
:
Granted
)
;
}
else
{
mResolver
(
GeolocationPermissionStatus
:
:
Canceled
)
;
}
nsresult
rv
=
DismissPrompt
(
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
MOZ_ASSERT
(
mAppCapability
)
;
mAppCapability
-
>
remove_AccessChanged
(
mToken
)
;
mAppCapability
=
nullptr
;
mToken
=
EventRegistrationToken
{
}
;
}
public
:
void
Stop
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mIsRunning
)
{
return
;
}
Stop
(
GetWifiControlAccess
(
mAppCapability
)
)
;
}
bool
IsStopped
(
)
{
return
!
mIsRunning
;
}
protected
:
friend
SupportsThreadSafeWeakPtr
<
WindowsGeolocationPermissionRequest
>
;
virtual
~
WindowsGeolocationPermissionRequest
(
)
{
Stop
(
)
;
MOZ_ASSERT
(
mToken
.
value
=
=
0
)
;
}
void
StopIfLocationIsPermitted
(
)
{
auto
wifiAccess
=
GetWifiControlAccess
(
mAppCapability
)
;
if
(
LocationIsPermittedHint
(
wifiAccess
)
)
{
Stop
(
wifiAccess
)
;
}
}
nsresult
DismissPrompt
(
)
{
nsresult
rv
;
nsCOMPtr
<
nsIGeolocationUIUtilsWin
>
utils
=
do_GetService
(
"
mozilla
.
org
/
geolocation
/
ui
-
utils
-
win
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
utils
-
>
DismissPrompts
(
mBrowsingContext
)
;
}
RefPtr
<
IAppCapability
>
mAppCapability
;
ParentRequestResolver
mResolver
;
RefPtr
<
BrowsingContext
>
mBrowsingContext
;
EventRegistrationToken
mToken
;
bool
mIsRunning
=
false
;
}
;
void
OpenWindowsLocationSettings
(
SystemGeolocationPermissionRequest
*
aPermissionRequest
)
{
auto
cancelRequest
=
MakeScopeExit
(
[
&
]
(
)
{
aPermissionRequest
-
>
Stop
(
)
;
}
)
;
ComPtr
<
IUriRuntimeClassFactory
>
uriFactory
=
CreateFromActivationFactory
<
IUriRuntimeClassFactory
>
(
kUriGuid
)
;
NS_ENSURE_TRUE_VOID
(
uriFactory
)
;
RefPtr
<
IUriRuntimeClass
>
uri
;
HRESULT
hr
=
uriFactory
-
>
CreateUri
(
HStringReference
(
kLocationSettingsPage
)
.
Get
(
)
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_TRUE_VOID
(
SUCCEEDED
(
hr
)
)
;
ComPtr
<
ILauncherStatics
>
launcherStatics
=
CreateFromActivationFactory
<
ILauncherStatics
>
(
kLauncherGuid
)
;
NS_ENSURE_TRUE_VOID
(
launcherStatics
)
;
RefPtr
<
IAsyncOperation
<
bool
>
>
handler
;
hr
=
launcherStatics
-
>
LaunchUriAsync
(
uri
getter_AddRefs
(
handler
)
)
;
NS_ENSURE_TRUE_VOID
(
SUCCEEDED
(
hr
)
)
;
handler
-
>
put_Completed
(
Callback
<
IAsyncOperationCompletedHandler
<
bool
>
>
(
[
permissionRequest
=
RefPtr
{
aPermissionRequest
}
]
(
IAsyncOperation
<
bool
>
*
asyncInfo
AsyncStatus
status
)
{
unsigned
char
verdict
=
0
;
asyncInfo
-
>
GetResults
(
&
verdict
)
;
if
(
!
verdict
)
{
permissionRequest
-
>
Stop
(
)
;
}
return
S_OK
;
}
)
.
Get
(
)
)
;
cancelRequest
.
release
(
)
;
}
class
LocationPermissionWifiScanListener
final
:
public
nsIWifiListener
{
public
:
NS_DECL_ISUPPORTS
explicit
LocationPermissionWifiScanListener
(
SystemGeolocationPermissionRequest
*
aRequest
)
:
mRequest
(
aRequest
)
{
}
NS_IMETHOD
OnChange
(
const
nsTArray
<
RefPtr
<
nsIWifiAccessPoint
>
>
&
)
override
{
RefPtr
<
LocationPermissionWifiScanListener
>
self
=
this
;
return
PermissionWasDecided
(
)
;
}
NS_IMETHOD
OnError
(
nsresult
)
override
{
RefPtr
<
LocationPermissionWifiScanListener
>
self
=
this
;
return
PermissionWasDecided
(
)
;
}
private
:
virtual
~
LocationPermissionWifiScanListener
(
)
=
default
;
RefPtr
<
SystemGeolocationPermissionRequest
>
mRequest
;
nsresult
PermissionWasDecided
(
)
{
nsCOMPtr
<
nsIWifiMonitor
>
wifiMonitor
=
components
:
:
WifiMonitor
:
:
Service
(
)
;
NS_ENSURE_TRUE
(
wifiMonitor
NS_ERROR_FAILURE
)
;
wifiMonitor
-
>
StopWatching
(
this
)
;
mRequest
-
>
Stop
(
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
LocationPermissionWifiScanListener
nsIWifiListener
)
}
SystemGeolocationPermissionBehavior
GetGeolocationPermissionBehavior
(
)
{
auto
wifiAccess
=
GetWifiControlAccess
(
)
;
if
(
SystemWillPromptForPermissionHint
(
wifiAccess
)
)
{
return
SystemGeolocationPermissionBehavior
:
:
SystemWillPromptUser
;
}
if
(
!
LocationIsPermittedHint
(
wifiAccess
)
)
{
return
SystemGeolocationPermissionBehavior
:
:
GeckoWillPromptUser
;
}
return
SystemGeolocationPermissionBehavior
:
:
NoPrompt
;
}
already_AddRefed
<
SystemGeolocationPermissionRequest
>
RequestLocationPermissionFromUser
(
BrowsingContext
*
aBrowsingContext
ParentRequestResolver
&
&
aResolver
)
{
RefPtr
<
WindowsGeolocationPermissionRequest
>
permissionRequest
=
new
WindowsGeolocationPermissionRequest
(
aBrowsingContext
std
:
:
move
(
aResolver
)
)
;
permissionRequest
-
>
Initialize
(
)
;
if
(
permissionRequest
-
>
IsStopped
(
)
)
{
return
nullptr
;
}
if
(
SystemWillPromptForPermissionHint
(
GetWifiControlAccess
(
)
)
)
{
nsCOMPtr
<
nsIWifiMonitor
>
wifiMonitor
=
components
:
:
WifiMonitor
:
:
Service
(
)
;
NS_ENSURE_TRUE
(
wifiMonitor
nullptr
)
;
auto
listener
=
MakeRefPtr
<
LocationPermissionWifiScanListener
>
(
permissionRequest
)
;
wifiMonitor
-
>
StartWatching
(
listener
false
)
;
}
else
{
OpenWindowsLocationSettings
(
permissionRequest
)
;
}
return
permissionRequest
.
forget
(
)
;
}
}
