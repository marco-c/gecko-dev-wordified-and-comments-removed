#
include
"
RefMessageBodyService
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StructuredCloneData
.
h
"
#
include
"
nsContentUtils
.
h
"
namespace
mozilla
:
:
dom
{
StaticMutex
sRefMessageBodyServiceMutex
;
RefMessageBodyService
*
sService
;
already_AddRefed
<
RefMessageBodyService
>
RefMessageBodyService
:
:
GetOrCreate
(
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
RefPtr
<
RefMessageBodyService
>
service
=
GetOrCreateInternal
(
lock
)
;
return
service
.
forget
(
)
;
}
RefMessageBodyService
*
RefMessageBodyService
:
:
GetOrCreateInternal
(
const
StaticMutexAutoLock
&
aProofOfLock
)
{
if
(
!
sService
)
{
sService
=
new
RefMessageBodyService
(
)
;
}
return
sService
;
}
RefMessageBodyService
:
:
RefMessageBodyService
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sService
=
=
nullptr
)
;
}
RefMessageBodyService
:
:
~
RefMessageBodyService
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sService
=
=
this
)
;
sService
=
nullptr
;
}
const
nsID
RefMessageBodyService
:
:
Register
(
already_AddRefed
<
RefMessageBody
>
aBody
ErrorResult
&
aRv
)
{
RefPtr
<
RefMessageBody
>
body
=
aBody
;
MOZ_ASSERT
(
body
)
;
nsID
uuid
=
{
}
;
aRv
=
nsContentUtils
:
:
GenerateUUIDInPlace
(
uuid
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nsID
(
)
;
}
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
GetOrCreateInternal
(
lock
)
-
>
mMessages
.
Put
(
uuid
std
:
:
move
(
body
)
)
;
return
uuid
;
}
already_AddRefed
<
RefMessageBody
>
RefMessageBodyService
:
:
Steal
(
const
nsID
&
aID
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
if
(
!
sService
)
{
return
nullptr
;
}
RefPtr
<
RefMessageBody
>
body
;
sService
-
>
mMessages
.
Remove
(
aID
getter_AddRefs
(
body
)
)
;
return
body
.
forget
(
)
;
}
already_AddRefed
<
RefMessageBody
>
RefMessageBodyService
:
:
GetAndCount
(
const
nsID
&
aID
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
if
(
!
sService
)
{
return
nullptr
;
}
RefPtr
<
RefMessageBody
>
body
=
sService
-
>
mMessages
.
Get
(
aID
)
;
if
(
!
body
)
{
return
nullptr
;
}
+
+
body
-
>
mCount
;
MOZ_ASSERT_IF
(
body
-
>
mMaxCount
.
isSome
(
)
body
-
>
mCount
<
=
body
-
>
mMaxCount
.
value
(
)
)
;
if
(
body
-
>
mMaxCount
.
isSome
(
)
&
&
body
-
>
mCount
>
=
body
-
>
mMaxCount
.
value
(
)
)
{
sService
-
>
mMessages
.
Remove
(
aID
)
;
}
return
body
.
forget
(
)
;
}
void
RefMessageBodyService
:
:
SetMaxCount
(
const
nsID
&
aID
uint32_t
aMaxCount
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
if
(
!
sService
)
{
return
;
}
RefPtr
<
RefMessageBody
>
body
=
sService
-
>
mMessages
.
Get
(
aID
)
;
if
(
!
body
)
{
return
;
}
MOZ_ASSERT
(
body
-
>
mMaxCount
.
isNothing
(
)
)
;
body
-
>
mMaxCount
.
emplace
(
aMaxCount
)
;
MOZ_ASSERT
(
body
-
>
mCount
<
=
body
-
>
mMaxCount
.
value
(
)
)
;
if
(
body
-
>
mCount
>
=
body
-
>
mMaxCount
.
value
(
)
)
{
sService
-
>
mMessages
.
Remove
(
aID
)
;
}
}
void
RefMessageBodyService
:
:
ForgetPort
(
const
nsID
&
aPortID
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
if
(
!
sService
)
{
return
;
}
for
(
auto
iter
=
sService
-
>
mMessages
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
UserData
(
)
-
>
PortID
(
)
=
=
aPortID
)
{
iter
.
Remove
(
)
;
}
}
}
RefMessageBody
:
:
RefMessageBody
(
const
nsID
&
aPortID
UniquePtr
<
ipc
:
:
StructuredCloneData
>
&
&
aCloneData
)
:
mPortID
(
aPortID
)
mMutex
(
"
RefMessageBody
:
:
mMutex
"
)
mCloneData
(
std
:
:
move
(
aCloneData
)
)
mMaxCount
(
Nothing
(
)
)
mCount
(
0
)
{
}
void
RefMessageBody
:
:
Read
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
const
JS
:
:
CloneDataPolicy
&
aCloneDataPolicy
ErrorResult
&
aRv
)
{
MutexAutoLock
lock
(
mMutex
)
;
mCloneData
-
>
Read
(
aCx
aValue
aCloneDataPolicy
aRv
)
;
}
bool
RefMessageBody
:
:
TakeTransferredPortsAsSequence
(
Sequence
<
OwningNonNull
<
mozilla
:
:
dom
:
:
MessagePort
>
>
&
aPorts
)
{
MOZ_ASSERT
(
mMaxCount
.
isNothing
(
)
)
;
return
mCloneData
-
>
TakeTransferredPortsAsSequence
(
aPorts
)
;
}
}
