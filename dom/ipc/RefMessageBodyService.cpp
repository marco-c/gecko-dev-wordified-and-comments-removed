#
include
"
RefMessageBodyService
.
h
"
namespace
mozilla
{
namespace
dom
{
StaticMutex
sRefMessageBodyServiceMutex
;
RefMessageBodyService
*
sService
;
already_AddRefed
<
RefMessageBodyService
>
RefMessageBodyService
:
:
GetOrCreate
(
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
RefPtr
<
RefMessageBodyService
>
service
=
GetOrCreateInternal
(
lock
)
;
return
service
.
forget
(
)
;
}
RefMessageBodyService
*
RefMessageBodyService
:
:
GetOrCreateInternal
(
const
StaticMutexAutoLock
&
aProofOfLock
)
{
if
(
!
sService
)
{
sService
=
new
RefMessageBodyService
(
)
;
}
return
sService
;
}
RefMessageBodyService
:
:
RefMessageBodyService
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sService
=
=
nullptr
)
;
}
RefMessageBodyService
:
:
~
RefMessageBodyService
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sService
=
=
this
)
;
sService
=
nullptr
;
}
nsID
RefMessageBodyService
:
:
Register
(
already_AddRefed
<
RefMessageBody
>
aBody
ErrorResult
&
aRv
)
{
RefPtr
<
RefMessageBody
>
body
=
aBody
;
MOZ_ASSERT
(
body
)
;
nsID
uuid
=
{
}
;
aRv
=
nsContentUtils
:
:
GenerateUUIDInPlace
(
uuid
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nsID
(
)
;
}
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
GetOrCreateInternal
(
lock
)
-
>
mMessages
.
Put
(
uuid
body
)
;
return
uuid
;
}
already_AddRefed
<
RefMessageBody
>
RefMessageBodyService
:
:
Steal
(
nsID
&
aID
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
if
(
!
sService
)
{
return
nullptr
;
}
RefPtr
<
RefMessageBody
>
body
;
sService
-
>
mMessages
.
Remove
(
aID
getter_AddRefs
(
body
)
)
;
return
body
.
forget
(
)
;
}
void
RefMessageBodyService
:
:
ForgetPort
(
nsID
&
aPortID
)
{
StaticMutexAutoLock
lock
(
sRefMessageBodyServiceMutex
)
;
if
(
!
sService
)
{
return
;
}
for
(
auto
iter
=
sService
-
>
mMessages
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
UserData
(
)
-
>
PortID
(
)
=
=
aPortID
)
{
iter
.
Remove
(
)
;
}
}
}
}
}
