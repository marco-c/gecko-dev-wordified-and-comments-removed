#
include
"
mozilla
/
dom
/
JSWindowActorService
.
h
"
#
include
"
mozilla
/
dom
/
ChromeUtilsBinding
.
h
"
#
include
"
mozilla
/
dom
/
EventTargetBinding
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
StaticRefPtr
<
JSWindowActorService
>
gJSWindowActorService
;
}
template
<
typename
T
>
nsresult
CallJSActorMethod
(
nsWrapperCache
*
aActor
const
char
*
aName
T
&
aNativeArg
JS
:
:
MutableHandleValue
aRetVal
)
{
aRetVal
.
setUndefined
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
actor
(
RootingCx
(
)
aActor
-
>
GetWrapper
(
)
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
AutoEntryScript
aes
(
actor
"
CallJSActorMethod
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JSAutoRealm
ar
(
cx
actor
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
func
(
cx
)
;
if
(
NS_WARN_IF
(
!
JS_GetProperty
(
cx
actor
aName
&
func
)
|
|
func
.
isPrimitive
(
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
argv
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
aNativeArg
&
argv
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
JS_CallFunctionValue
(
cx
actor
func
JS
:
:
HandleValueArray
(
argv
)
aRetVal
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
class
JSWindowActorProtocol
final
:
public
nsIObserver
public
nsIDOMEventListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIDOMEVENTLISTENER
static
already_AddRefed
<
JSWindowActorProtocol
>
FromIPC
(
const
JSWindowActorInfo
&
aInfo
)
;
JSWindowActorInfo
ToIPC
(
)
;
static
already_AddRefed
<
JSWindowActorProtocol
>
FromWebIDLOptions
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
;
struct
Sided
{
nsCString
mModuleURI
;
}
;
struct
ParentSide
:
public
Sided
{
}
;
struct
EventDecl
{
nsString
mName
;
EventListenerFlags
mFlags
;
Optional
<
bool
>
mPassive
;
}
;
struct
ChildSide
:
public
Sided
{
nsTArray
<
EventDecl
>
mEvents
;
nsTArray
<
nsCString
>
mObservers
;
}
;
const
nsAString
&
Name
(
)
const
{
return
mName
;
}
const
ParentSide
&
Parent
(
)
const
{
return
mParent
;
}
const
ChildSide
&
Child
(
)
const
{
return
mChild
;
}
void
RegisterListenersFor
(
EventTarget
*
aRoot
)
;
void
UnregisterListenersFor
(
EventTarget
*
aRoot
)
;
void
AddObservers
(
)
;
void
RemoveObservers
(
)
;
private
:
explicit
JSWindowActorProtocol
(
const
nsAString
&
aName
)
:
mName
(
aName
)
{
}
~
JSWindowActorProtocol
(
)
=
default
;
nsString
mName
;
ParentSide
mParent
;
ChildSide
mChild
;
}
;
NS_IMPL_ISUPPORTS
(
JSWindowActorProtocol
nsIObserver
nsIDOMEventListener
)
;
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromIPC
(
const
JSWindowActorInfo
&
aInfo
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aInfo
.
name
(
)
)
;
proto
-
>
mChild
.
mModuleURI
.
Assign
(
aInfo
.
url
(
)
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
aInfo
.
events
(
)
.
Length
(
)
)
;
for
(
auto
&
ipc
:
aInfo
.
events
(
)
)
{
auto
*
event
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
event
-
>
mName
.
Assign
(
ipc
.
name
(
)
)
;
event
-
>
mFlags
.
mCapture
=
ipc
.
capture
(
)
;
event
-
>
mFlags
.
mInSystemGroup
=
ipc
.
systemGroup
(
)
;
event
-
>
mFlags
.
mAllowUntrustedEvents
=
ipc
.
allowUntrusted
(
)
;
if
(
ipc
.
hasPassive
(
)
)
{
event
-
>
mPassive
.
Construct
(
ipc
.
passive
(
)
)
;
}
}
proto
-
>
mChild
.
mObservers
=
aInfo
.
observers
(
)
;
return
proto
.
forget
(
)
;
}
JSWindowActorInfo
JSWindowActorProtocol
:
:
ToIPC
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
JSWindowActorInfo
info
;
info
.
name
(
)
=
mName
;
info
.
url
(
)
=
mChild
.
mModuleURI
;
info
.
events
(
)
.
SetCapacity
(
mChild
.
mEvents
.
Length
(
)
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
auto
*
ipc
=
info
.
events
(
)
.
AppendElement
(
)
;
ipc
-
>
name
(
)
.
Assign
(
event
.
mName
)
;
ipc
-
>
capture
(
)
=
event
.
mFlags
.
mCapture
;
ipc
-
>
systemGroup
(
)
=
event
.
mFlags
.
mInSystemGroup
;
ipc
-
>
allowUntrusted
(
)
=
event
.
mFlags
.
mAllowUntrustedEvents
;
ipc
-
>
hasPassive
(
)
=
event
.
mPassive
.
WasPassed
(
)
;
if
(
event
.
mPassive
.
WasPassed
(
)
)
{
ipc
-
>
passive
(
)
=
event
.
mPassive
.
Value
(
)
;
}
}
info
.
observers
(
)
=
mChild
.
mObservers
;
return
info
;
}
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aName
)
;
proto
-
>
mParent
.
mModuleURI
=
aOptions
.
mParent
.
mModuleURI
;
proto
-
>
mChild
.
mModuleURI
=
aOptions
.
mChild
.
mModuleURI
;
if
(
aOptions
.
mChild
.
mEvents
.
WasPassed
(
)
)
{
auto
&
entries
=
aOptions
.
mChild
.
mEvents
.
Value
(
)
.
Entries
(
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
entries
.
Length
(
)
)
;
for
(
auto
&
entry
:
entries
)
{
if
(
entry
.
mValue
.
mOnce
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
EventDecl
*
evt
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
evt
-
>
mName
=
entry
.
mKey
;
evt
-
>
mFlags
.
mCapture
=
entry
.
mValue
.
mCapture
;
evt
-
>
mFlags
.
mInSystemGroup
=
entry
.
mValue
.
mMozSystemGroup
;
evt
-
>
mFlags
.
mAllowUntrustedEvents
=
entry
.
mValue
.
mWantUntrusted
.
WasPassed
(
)
?
entry
.
mValue
.
mWantUntrusted
.
Value
(
)
:
false
;
if
(
entry
.
mValue
.
mPassive
.
WasPassed
(
)
)
{
evt
-
>
mPassive
.
Construct
(
entry
.
mValue
.
mPassive
.
Value
(
)
)
;
}
}
}
if
(
aOptions
.
mChild
.
mObservers
.
WasPassed
(
)
)
{
proto
-
>
mChild
.
mObservers
=
aOptions
.
mChild
.
mObservers
.
Value
(
)
;
}
return
proto
.
forget
(
)
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
HandleEvent
(
Event
*
aEvent
)
{
EventTarget
*
target
=
aEvent
-
>
GetOriginalTarget
(
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
target
-
>
GetOwnerGlobal
(
)
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
WindowGlobalChild
>
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
JSWindowActorChild
>
actor
=
wgc
-
>
GetActor
(
mName
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
dummy
(
RootingCx
(
)
)
;
return
CallJSActorMethod
(
actor
"
handleEvent
"
aEvent
&
dummy
)
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
aSubject
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
WindowGlobalChild
>
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
JSWindowActorChild
>
actor
=
wgc
-
>
GetActor
(
mName
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
RootingCx
(
)
actor
-
>
GetWrapper
(
)
)
;
if
(
NS_WARN_IF
(
!
obj
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
AutoEntryScript
aes
(
obj
"
JSWindowActorProtocol
:
:
Observe
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JSAutoRealm
ar
(
cx
obj
)
;
JS
:
:
AutoValueArray
<
3
>
argv
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
aSubject
argv
[
0
]
)
|
|
!
NonVoidByteStringToJsval
(
cx
nsDependentCString
(
aTopic
)
argv
[
1
]
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_FAILURE
;
}
if
(
aData
)
{
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
nsDependentString
(
aData
)
argv
[
2
]
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_FAILURE
;
}
}
else
{
argv
[
2
]
.
setNull
(
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
dummy
(
cx
)
;
if
(
NS_WARN_IF
(
!
JS_CallFunctionName
(
cx
obj
"
observe
"
JS
:
:
HandleValueArray
(
argv
)
&
dummy
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
void
JSWindowActorProtocol
:
:
RegisterListenersFor
(
EventTarget
*
aRoot
)
{
EventListenerManager
*
elm
=
aRoot
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
AddEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
event
.
mPassive
)
;
}
}
void
JSWindowActorProtocol
:
:
UnregisterListenersFor
(
EventTarget
*
aRoot
)
{
EventListenerManager
*
elm
=
aRoot
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
RemoveEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
)
;
}
}
void
JSWindowActorProtocol
:
:
AddObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
AddObserver
(
this
topic
.
get
(
)
false
)
;
}
}
void
JSWindowActorProtocol
:
:
RemoveObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
RemoveObserver
(
this
topic
.
get
(
)
)
;
}
}
JSWindowActorService
:
:
JSWindowActorService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
JSWindowActorService
:
:
~
JSWindowActorService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
already_AddRefed
<
JSWindowActorService
>
JSWindowActorService
:
:
GetSingleton
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gJSWindowActorService
)
{
gJSWindowActorService
=
new
JSWindowActorService
(
)
;
ClearOnShutdown
(
&
gJSWindowActorService
)
;
}
RefPtr
<
JSWindowActorService
>
service
=
gJSWindowActorService
.
get
(
)
;
return
service
.
forget
(
)
;
}
void
JSWindowActorService
:
:
RegisterWindowActor
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
auto
entry
=
mDescriptors
.
LookupForAdd
(
aName
)
;
if
(
entry
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
RefPtr
<
JSWindowActorProtocol
>
proto
=
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
aName
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
entry
.
OrInsert
(
[
&
]
{
return
proto
;
}
)
;
AutoTArray
<
JSWindowActorInfo
1
>
ipcInfos
{
proto
-
>
ToIPC
(
)
}
;
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendInitJSWindowActorInfos
(
ipcInfos
)
;
}
for
(
EventTarget
*
root
:
mRoots
)
{
proto
-
>
RegisterListenersFor
(
root
)
;
}
proto
-
>
AddObservers
(
)
;
}
void
JSWindowActorService
:
:
UnregisterWindowActor
(
const
nsAString
&
aName
)
{
nsAutoString
name
(
aName
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
;
if
(
mDescriptors
.
Remove
(
aName
getter_AddRefs
(
proto
)
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendUnregisterJSWindowActor
(
name
)
;
}
}
for
(
EventTarget
*
root
:
mRoots
)
{
proto
-
>
UnregisterListenersFor
(
root
)
;
}
proto
-
>
RemoveObservers
(
)
;
}
}
void
JSWindowActorService
:
:
LoadJSWindowActorInfos
(
nsTArray
<
JSWindowActorInfo
>
&
aInfos
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
for
(
uint32_t
i
=
0
len
=
aInfos
.
Length
(
)
;
i
<
len
;
i
+
+
)
{
RefPtr
<
JSWindowActorProtocol
>
proto
=
JSWindowActorProtocol
:
:
FromIPC
(
aInfos
[
i
]
)
;
mDescriptors
.
Put
(
aInfos
[
i
]
.
name
(
)
proto
)
;
for
(
EventTarget
*
root
:
mRoots
)
{
proto
-
>
RegisterListenersFor
(
root
)
;
}
proto
-
>
AddObservers
(
)
;
}
}
void
JSWindowActorService
:
:
GetJSWindowActorInfos
(
nsTArray
<
JSWindowActorInfo
>
&
aInfos
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
for
(
auto
iter
=
mDescriptors
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aInfos
.
AppendElement
(
iter
.
Data
(
)
-
>
ToIPC
(
)
)
;
}
}
void
JSWindowActorService
:
:
ConstructActor
(
const
nsAString
&
aName
bool
aParentSide
JS
:
:
MutableHandleObject
aActor
ErrorResult
&
aRv
)
{
MOZ_ASSERT_IF
(
aParentSide
XRE_IsParentProcess
(
)
)
;
AutoEntryScript
aes
(
xpc
:
:
PrivilegedJunkScope
(
)
"
JSWindowActor
construction
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
mDescriptors
.
Get
(
aName
)
;
if
(
!
proto
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
const
JSWindowActorProtocol
:
:
Sided
*
side
;
if
(
aParentSide
)
{
side
=
&
proto
-
>
Parent
(
)
;
}
else
{
side
=
&
proto
-
>
Child
(
)
;
}
RefPtr
<
mozJSComponentLoader
>
loader
=
mozJSComponentLoader
:
:
Get
(
)
;
MOZ_ASSERT
(
loader
)
;
JS
:
:
RootedObject
global
(
cx
)
;
JS
:
:
RootedObject
exports
(
cx
)
;
aRv
=
loader
-
>
Import
(
cx
side
-
>
mModuleURI
&
global
&
exports
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
exports
"
null
exports
!
"
)
;
JS
:
:
RootedValue
ctor
(
cx
)
;
nsAutoString
ctorName
(
aName
)
;
ctorName
.
Append
(
aParentSide
?
NS_LITERAL_STRING
(
"
Parent
"
)
:
NS_LITERAL_STRING
(
"
Child
"
)
)
;
if
(
!
JS_GetUCProperty
(
cx
exports
ctorName
.
get
(
)
ctorName
.
Length
(
)
&
ctor
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
if
(
!
JS
:
:
Construct
(
cx
ctor
JS
:
:
HandleValueArray
:
:
empty
(
)
aActor
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
}
void
JSWindowActorService
:
:
ReceiveMessage
(
JS
:
:
RootedObject
&
aObj
const
nsString
&
aMessageName
ipc
:
:
StructuredCloneData
&
aData
)
{
IgnoredErrorResult
error
;
AutoEntryScript
aes
(
aObj
"
WindowGlobalChild
Message
Handler
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JSAutoRealm
ar
(
cx
aObj
)
;
JS
:
:
RootedValue
json
(
cx
JS
:
:
NullValue
(
)
)
;
aData
.
Read
(
aes
.
cx
(
)
&
json
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
;
}
RootedDictionary
<
ReceiveMessageArgument
>
argument
(
cx
)
;
argument
.
mObjects
=
JS_NewPlainObject
(
cx
)
;
argument
.
mName
=
aMessageName
;
argument
.
mData
=
json
;
argument
.
mJson
=
json
;
JS
:
:
RootedValue
argv
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
argument
&
argv
)
)
)
{
return
;
}
JS
:
:
RootedValue
dummy
(
cx
)
;
if
(
NS_WARN_IF
(
!
JS_CallFunctionName
(
cx
aObj
"
recvAsyncMessage
"
JS
:
:
HandleValueArray
(
argv
)
&
dummy
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
;
}
}
void
JSWindowActorService
:
:
RegisterWindowRoot
(
EventTarget
*
aRoot
)
{
MOZ_ASSERT
(
!
mRoots
.
Contains
(
aRoot
)
)
;
mRoots
.
AppendElement
(
aRoot
)
;
for
(
auto
iter
=
mDescriptors
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
RegisterListenersFor
(
aRoot
)
;
}
}
void
JSWindowActorService
:
:
UnregisterWindowRoot
(
EventTarget
*
aRoot
)
{
if
(
gJSWindowActorService
)
{
gJSWindowActorService
-
>
mRoots
.
RemoveElement
(
aRoot
)
;
}
}
}
}
