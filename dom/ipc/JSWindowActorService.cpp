#
include
"
mozilla
/
dom
/
JSWindowActorService
.
h
"
#
include
"
mozilla
/
dom
/
ChromeUtilsBinding
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
StaticRefPtr
<
JSWindowActorService
>
gJSWindowActorService
;
}
template
<
typename
T
>
nsresult
CallJSActorMethod
(
nsWrapperCache
*
aActor
const
char
*
aName
T
&
aNativeArg
JS
:
:
MutableHandleValue
aRetVal
)
{
aRetVal
.
setUndefined
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
actor
(
RootingCx
(
)
aActor
-
>
GetWrapper
(
)
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
AutoEntryScript
aes
(
actor
"
CallJSActorMethod
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JSAutoRealm
ar
(
cx
actor
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
func
(
cx
)
;
if
(
NS_WARN_IF
(
!
JS_GetProperty
(
cx
actor
aName
&
func
)
|
|
func
.
isPrimitive
(
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
argv
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
aNativeArg
&
argv
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
JS_CallFunctionValue
(
cx
actor
func
JS
:
:
HandleValueArray
(
argv
)
aRetVal
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
class
JSWindowActorProtocol
final
:
public
nsISupports
{
public
:
NS_DECL_ISUPPORTS
static
already_AddRefed
<
JSWindowActorProtocol
>
FromIPC
(
const
JSWindowActorInfo
&
aInfo
)
;
JSWindowActorInfo
ToIPC
(
)
;
static
already_AddRefed
<
JSWindowActorProtocol
>
FromWebIDLOptions
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
;
struct
Sided
{
nsCString
mModuleURI
;
}
;
struct
ParentSide
:
public
Sided
{
}
;
struct
ChildSide
:
public
Sided
{
}
;
const
nsAString
&
Name
(
)
const
{
return
mName
;
}
const
ParentSide
&
Parent
(
)
const
{
return
mParent
;
}
const
ChildSide
&
Child
(
)
const
{
return
mChild
;
}
void
RegisterListenersFor
(
EventTarget
*
aRoot
)
;
void
UnregisterListenersFor
(
EventTarget
*
aRoot
)
;
private
:
explicit
JSWindowActorProtocol
(
const
nsAString
&
aName
)
:
mName
(
aName
)
{
}
~
JSWindowActorProtocol
(
)
=
default
;
nsString
mName
;
ParentSide
mParent
;
ChildSide
mChild
;
}
;
NS_IMPL_ISUPPORTS0
(
JSWindowActorProtocol
)
;
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromIPC
(
const
JSWindowActorInfo
&
aInfo
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aInfo
.
name
(
)
)
;
proto
-
>
mChild
.
mModuleURI
.
Assign
(
aInfo
.
url
(
)
)
;
return
proto
.
forget
(
)
;
}
JSWindowActorInfo
JSWindowActorProtocol
:
:
ToIPC
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
JSWindowActorInfo
info
;
info
.
name
(
)
=
mName
;
info
.
url
(
)
=
mChild
.
mModuleURI
;
return
info
;
}
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aName
)
;
proto
-
>
mParent
.
mModuleURI
=
aOptions
.
mParent
.
mModuleURI
;
proto
-
>
mChild
.
mModuleURI
=
aOptions
.
mChild
.
mModuleURI
;
return
proto
.
forget
(
)
;
}
JSWindowActorService
:
:
JSWindowActorService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
JSWindowActorService
:
:
~
JSWindowActorService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
already_AddRefed
<
JSWindowActorService
>
JSWindowActorService
:
:
GetSingleton
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gJSWindowActorService
)
{
gJSWindowActorService
=
new
JSWindowActorService
(
)
;
ClearOnShutdown
(
&
gJSWindowActorService
)
;
}
RefPtr
<
JSWindowActorService
>
service
=
gJSWindowActorService
.
get
(
)
;
return
service
.
forget
(
)
;
}
void
JSWindowActorService
:
:
RegisterWindowActor
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
auto
entry
=
mDescriptors
.
LookupForAdd
(
aName
)
;
if
(
entry
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
RefPtr
<
JSWindowActorProtocol
>
proto
=
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
aName
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
entry
.
OrInsert
(
[
&
]
{
return
proto
;
}
)
;
AutoTArray
<
JSWindowActorInfo
1
>
ipcInfos
{
proto
-
>
ToIPC
(
)
}
;
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendInitJSWindowActorInfos
(
ipcInfos
)
;
}
}
void
JSWindowActorService
:
:
UnregisterWindowActor
(
const
nsAString
&
aName
)
{
mDescriptors
.
Remove
(
aName
)
;
}
void
JSWindowActorService
:
:
LoadJSWindowActorInfos
(
nsTArray
<
JSWindowActorInfo
>
&
aInfos
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
for
(
uint32_t
i
=
0
len
=
aInfos
.
Length
(
)
;
i
<
len
;
i
+
+
)
{
RefPtr
<
JSWindowActorProtocol
>
proto
=
JSWindowActorProtocol
:
:
FromIPC
(
aInfos
[
i
]
)
;
mDescriptors
.
Put
(
aInfos
[
i
]
.
name
(
)
proto
)
;
}
}
void
JSWindowActorService
:
:
GetJSWindowActorInfos
(
nsTArray
<
JSWindowActorInfo
>
&
aInfos
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
for
(
auto
iter
=
mDescriptors
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aInfos
.
AppendElement
(
iter
.
Data
(
)
-
>
ToIPC
(
)
)
;
}
}
void
JSWindowActorService
:
:
ConstructActor
(
const
nsAString
&
aName
bool
aParentSide
JS
:
:
MutableHandleObject
aActor
ErrorResult
&
aRv
)
{
MOZ_ASSERT_IF
(
aParentSide
XRE_IsParentProcess
(
)
)
;
AutoEntryScript
aes
(
xpc
:
:
PrivilegedJunkScope
(
)
"
JSWindowActor
construction
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
mDescriptors
.
Get
(
aName
)
;
if
(
!
proto
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
const
JSWindowActorProtocol
:
:
Sided
*
side
;
if
(
aParentSide
)
{
side
=
&
proto
-
>
Parent
(
)
;
}
else
{
side
=
&
proto
-
>
Child
(
)
;
}
RefPtr
<
mozJSComponentLoader
>
loader
=
mozJSComponentLoader
:
:
Get
(
)
;
MOZ_ASSERT
(
loader
)
;
JS
:
:
RootedObject
global
(
cx
)
;
JS
:
:
RootedObject
exports
(
cx
)
;
aRv
=
loader
-
>
Import
(
cx
side
-
>
mModuleURI
&
global
&
exports
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
exports
"
null
exports
!
"
)
;
JS
:
:
RootedValue
ctor
(
cx
)
;
nsAutoString
ctorName
(
aName
)
;
ctorName
.
Append
(
aParentSide
?
NS_LITERAL_STRING
(
"
Parent
"
)
:
NS_LITERAL_STRING
(
"
Child
"
)
)
;
if
(
!
JS_GetUCProperty
(
cx
exports
ctorName
.
get
(
)
ctorName
.
Length
(
)
&
ctor
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
if
(
!
JS
:
:
Construct
(
cx
ctor
JS
:
:
HandleValueArray
:
:
empty
(
)
aActor
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
}
void
JSWindowActorService
:
:
ReceiveMessage
(
JS
:
:
RootedObject
&
aObj
const
nsString
&
aMessageName
ipc
:
:
StructuredCloneData
&
aData
)
{
IgnoredErrorResult
error
;
AutoEntryScript
aes
(
js
:
:
CheckedUnwrap
(
aObj
)
"
WindowGlobalChild
Message
Handler
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JSAutoRealm
ar
(
cx
aObj
)
;
JS
:
:
RootedValue
json
(
cx
JS
:
:
NullValue
(
)
)
;
aData
.
Read
(
aes
.
cx
(
)
&
json
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
;
}
RootedDictionary
<
ReceiveMessageArgument
>
argument
(
cx
)
;
argument
.
mObjects
=
JS_NewPlainObject
(
cx
)
;
argument
.
mName
=
aMessageName
;
argument
.
mData
=
json
;
argument
.
mJson
=
json
;
JS
:
:
RootedValue
argv
(
cx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
cx
argument
&
argv
)
)
)
{
return
;
}
JS
:
:
RootedValue
dummy
(
cx
)
;
if
(
NS_WARN_IF
(
!
JS_CallFunctionName
(
cx
aObj
"
recvAsyncMessage
"
JS
:
:
HandleValueArray
(
argv
)
&
dummy
)
)
)
{
JS_ClearPendingException
(
cx
)
;
return
;
}
}
}
}
