#
include
"
mozilla
/
dom
/
JSWindowActorService
.
h
"
#
include
"
mozilla
/
dom
/
ChromeUtilsBinding
.
h
"
#
include
"
mozilla
/
dom
/
EventListenerBinding
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventTargetBinding
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
#
include
"
mozilla
/
dom
/
MessageManagerBinding
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
StaticRefPtr
<
JSWindowActorService
>
gJSWindowActorService
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
JSWindowActorProtocol
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
JSWindowActorProtocol
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
JSWindowActorProtocol
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
JSWindowActorProtocol
mURIMatcher
)
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromIPC
(
const
JSWindowActorInfo
&
aInfo
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aInfo
.
name
(
)
)
;
proto
-
>
mIncludeChrome
=
false
;
proto
-
>
mAllFrames
=
aInfo
.
allFrames
(
)
;
proto
-
>
mMatches
=
aInfo
.
matches
(
)
;
proto
-
>
mRemoteTypes
=
aInfo
.
remoteTypes
(
)
;
proto
-
>
mChild
.
mModuleURI
=
aInfo
.
url
(
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
aInfo
.
events
(
)
.
Length
(
)
)
;
for
(
auto
&
ipc
:
aInfo
.
events
(
)
)
{
auto
*
event
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
event
-
>
mName
.
Assign
(
ipc
.
name
(
)
)
;
event
-
>
mFlags
.
mCapture
=
ipc
.
capture
(
)
;
event
-
>
mFlags
.
mInSystemGroup
=
ipc
.
systemGroup
(
)
;
event
-
>
mFlags
.
mAllowUntrustedEvents
=
ipc
.
allowUntrusted
(
)
;
if
(
ipc
.
passive
(
)
)
{
event
-
>
mPassive
.
Construct
(
ipc
.
passive
(
)
.
value
(
)
)
;
}
}
proto
-
>
mChild
.
mObservers
=
aInfo
.
observers
(
)
;
return
proto
.
forget
(
)
;
}
JSWindowActorInfo
JSWindowActorProtocol
:
:
ToIPC
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
JSWindowActorInfo
info
;
info
.
name
(
)
=
mName
;
info
.
allFrames
(
)
=
mAllFrames
;
info
.
matches
(
)
=
mMatches
;
info
.
remoteTypes
(
)
=
mRemoteTypes
;
info
.
url
(
)
=
mChild
.
mModuleURI
;
info
.
events
(
)
.
SetCapacity
(
mChild
.
mEvents
.
Length
(
)
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
auto
*
ipc
=
info
.
events
(
)
.
AppendElement
(
)
;
ipc
-
>
name
(
)
.
Assign
(
event
.
mName
)
;
ipc
-
>
capture
(
)
=
event
.
mFlags
.
mCapture
;
ipc
-
>
systemGroup
(
)
=
event
.
mFlags
.
mInSystemGroup
;
ipc
-
>
allowUntrusted
(
)
=
event
.
mFlags
.
mAllowUntrustedEvents
;
if
(
event
.
mPassive
.
WasPassed
(
)
)
{
ipc
-
>
passive
(
)
=
Some
(
event
.
mPassive
.
Value
(
)
)
;
}
}
info
.
observers
(
)
=
mChild
.
mObservers
;
return
info
;
}
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aName
)
;
proto
-
>
mAllFrames
=
aOptions
.
mAllFrames
;
proto
-
>
mIncludeChrome
=
aOptions
.
mIncludeChrome
;
if
(
aOptions
.
mMatches
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
aOptions
.
mMatches
.
Value
(
)
.
Length
(
)
)
;
proto
-
>
mMatches
=
aOptions
.
mMatches
.
Value
(
)
;
}
if
(
aOptions
.
mRemoteTypes
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
aOptions
.
mRemoteTypes
.
Value
(
)
.
Length
(
)
)
;
proto
-
>
mRemoteTypes
=
aOptions
.
mRemoteTypes
.
Value
(
)
;
}
if
(
aOptions
.
mParent
.
WasPassed
(
)
)
{
proto
-
>
mParent
.
mModuleURI
.
emplace
(
aOptions
.
mParent
.
Value
(
)
.
mModuleURI
)
;
}
if
(
aOptions
.
mChild
.
WasPassed
(
)
)
{
proto
-
>
mChild
.
mModuleURI
.
emplace
(
aOptions
.
mChild
.
Value
(
)
.
mModuleURI
)
;
}
if
(
!
aOptions
.
mChild
.
WasPassed
(
)
&
&
!
aOptions
.
mParent
.
WasPassed
(
)
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
NS_LITERAL_CSTRING
(
"
No
point
registering
an
actor
with
neither
child
"
"
nor
parent
specifications
.
"
)
)
;
return
nullptr
;
}
if
(
aOptions
.
mChild
.
WasPassed
(
)
&
&
aOptions
.
mChild
.
Value
(
)
.
mEvents
.
WasPassed
(
)
)
{
auto
&
entries
=
aOptions
.
mChild
.
Value
(
)
.
mEvents
.
Value
(
)
.
Entries
(
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
entries
.
Length
(
)
)
;
for
(
auto
&
entry
:
entries
)
{
if
(
entry
.
mValue
.
mOnce
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
EventDecl
*
evt
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
evt
-
>
mName
=
entry
.
mKey
;
evt
-
>
mFlags
.
mCapture
=
entry
.
mValue
.
mCapture
;
evt
-
>
mFlags
.
mInSystemGroup
=
entry
.
mValue
.
mMozSystemGroup
;
evt
-
>
mFlags
.
mAllowUntrustedEvents
=
entry
.
mValue
.
mWantUntrusted
.
WasPassed
(
)
?
entry
.
mValue
.
mWantUntrusted
.
Value
(
)
:
false
;
if
(
entry
.
mValue
.
mPassive
.
WasPassed
(
)
)
{
evt
-
>
mPassive
.
Construct
(
entry
.
mValue
.
mPassive
.
Value
(
)
)
;
}
}
}
if
(
aOptions
.
mChild
.
WasPassed
(
)
&
&
aOptions
.
mChild
.
Value
(
)
.
mObservers
.
WasPassed
(
)
)
{
proto
-
>
mChild
.
mObservers
=
aOptions
.
mChild
.
Value
(
)
.
mObservers
.
Value
(
)
;
}
return
proto
.
forget
(
)
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
HandleEvent
(
Event
*
aEvent
)
{
EventTarget
*
target
=
aEvent
-
>
GetOriginalTarget
(
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
target
-
>
GetOwnerGlobal
(
)
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
WindowGlobalChild
>
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
JSWindowActorChild
>
actor
=
wgc
-
>
GetActor
(
mName
error
)
;
if
(
error
.
Failed
(
)
)
{
nsresult
rv
=
error
.
StealNSResult
(
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
RootingCx
(
)
JS
:
:
GetNonCCWObjectGlobal
(
actor
-
>
GetWrapper
(
)
)
)
;
RefPtr
<
EventListener
>
eventListener
=
new
EventListener
(
actor
-
>
GetWrapper
(
)
global
nullptr
nullptr
)
;
eventListener
-
>
HandleEvent
(
*
aEvent
"
JSWindowActorProtocol
:
:
HandleEvent
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
aSubject
)
;
RefPtr
<
WindowGlobalChild
>
wgc
;
if
(
!
inner
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
do_QueryInterface
(
aSubject
)
;
if
(
NS_WARN_IF
(
!
outer
)
|
|
NS_WARN_IF
(
!
outer
-
>
GetCurrentInnerWindow
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
wgc
=
outer
-
>
GetCurrentInnerWindow
(
)
-
>
GetWindowGlobalChild
(
)
;
}
else
{
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
}
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
JSWindowActorChild
>
actor
=
wgc
-
>
GetActor
(
mName
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
nsresult
rv
=
error
.
StealNSResult
(
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
RootingCx
(
)
JS
:
:
GetNonCCWObjectGlobal
(
actor
-
>
GetWrapper
(
)
)
)
;
RefPtr
<
MozObserverCallback
>
observerCallback
=
new
MozObserverCallback
(
actor
-
>
GetWrapper
(
)
global
nullptr
nullptr
)
;
observerCallback
-
>
Observe
(
aSubject
nsDependentCString
(
aTopic
)
aData
?
nsDependentString
(
aData
)
:
VoidString
(
)
)
;
return
NS_OK
;
}
void
JSWindowActorProtocol
:
:
RegisterListenersFor
(
EventTarget
*
aTarget
)
{
EventListenerManager
*
elm
=
aTarget
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
AddEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
event
.
mPassive
)
;
}
}
void
JSWindowActorProtocol
:
:
UnregisterListenersFor
(
EventTarget
*
aTarget
)
{
EventListenerManager
*
elm
=
aTarget
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
RemoveEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
)
;
}
}
void
JSWindowActorProtocol
:
:
AddObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
AddObserver
(
this
topic
.
get
(
)
false
)
;
}
}
void
JSWindowActorProtocol
:
:
RemoveObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
RemoveObserver
(
this
topic
.
get
(
)
)
;
}
}
extensions
:
:
MatchPatternSet
*
JSWindowActorProtocol
:
:
GetURIMatcher
(
)
{
if
(
mURIMatcher
|
|
mMatches
.
IsEmpty
(
)
)
{
return
mURIMatcher
;
}
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
GlobalObject
global
(
jsapi
.
cx
(
)
xpc
:
:
PrivilegedJunkScope
(
)
)
;
nsTArray
<
OwningStringOrMatchPattern
>
patterns
;
patterns
.
SetCapacity
(
mMatches
.
Length
(
)
)
;
for
(
nsString
&
s
:
mMatches
)
{
auto
*
entry
=
patterns
.
AppendElement
(
)
;
entry
-
>
SetAsString
(
)
=
s
;
}
MatchPatternOptions
matchPatternOptions
;
matchPatternOptions
.
mRestrictSchemes
=
false
;
mURIMatcher
=
extensions
:
:
MatchPatternSet
:
:
Constructor
(
global
patterns
matchPatternOptions
IgnoreErrors
(
)
)
;
return
mURIMatcher
;
}
bool
JSWindowActorProtocol
:
:
RemoteTypePrefixMatches
(
const
nsDependentSubstring
&
aRemoteType
)
{
for
(
auto
&
remoteType
:
mRemoteTypes
)
{
if
(
StringBeginsWith
(
aRemoteType
remoteType
)
)
{
return
true
;
}
}
return
false
;
}
bool
JSWindowActorProtocol
:
:
Matches
(
BrowsingContext
*
aBrowsingContext
nsIURI
*
aURI
const
nsAString
&
aRemoteType
)
{
MOZ_ASSERT
(
aBrowsingContext
"
DocShell
without
a
BrowsingContext
!
"
)
;
MOZ_ASSERT
(
aURI
"
Must
have
URI
!
"
)
;
if
(
!
mAllFrames
&
&
aBrowsingContext
-
>
GetParent
(
)
)
{
return
false
;
}
if
(
!
mIncludeChrome
&
&
!
aBrowsingContext
-
>
IsContent
(
)
)
{
return
false
;
}
if
(
!
mRemoteTypes
.
IsEmpty
(
)
&
&
!
RemoteTypePrefixMatches
(
RemoteTypePrefix
(
aRemoteType
)
)
)
{
return
false
;
}
if
(
extensions
:
:
MatchPatternSet
*
uriMatcher
=
GetURIMatcher
(
)
)
{
if
(
!
uriMatcher
-
>
Matches
(
aURI
)
)
{
return
false
;
}
}
return
true
;
}
JSWindowActorService
:
:
JSWindowActorService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
JSWindowActorService
:
:
~
JSWindowActorService
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
already_AddRefed
<
JSWindowActorService
>
JSWindowActorService
:
:
GetSingleton
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
gJSWindowActorService
)
{
gJSWindowActorService
=
new
JSWindowActorService
(
)
;
ClearOnShutdown
(
&
gJSWindowActorService
)
;
}
RefPtr
<
JSWindowActorService
>
service
=
gJSWindowActorService
.
get
(
)
;
return
service
.
forget
(
)
;
}
void
JSWindowActorService
:
:
RegisterWindowActor
(
const
nsAString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
auto
entry
=
mDescriptors
.
LookupForAdd
(
aName
)
;
if
(
entry
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
nsPrintfCString
(
"
'
%
s
'
actor
is
already
registered
.
"
NS_ConvertUTF16toUTF8
(
aName
)
.
get
(
)
)
)
;
return
;
}
RefPtr
<
JSWindowActorProtocol
>
proto
=
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
aName
aOptions
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
entry
.
OrRemove
(
)
;
return
;
}
entry
.
OrInsert
(
[
&
]
{
return
proto
;
}
)
;
AutoTArray
<
JSWindowActorInfo
1
>
ipcInfos
{
proto
-
>
ToIPC
(
)
}
;
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendInitJSWindowActorInfos
(
ipcInfos
)
;
}
for
(
EventTarget
*
target
:
mChromeEventTargets
)
{
proto
-
>
RegisterListenersFor
(
target
)
;
}
proto
-
>
AddObservers
(
)
;
}
void
JSWindowActorService
:
:
UnregisterWindowActor
(
const
nsAString
&
aName
)
{
nsAutoString
name
(
aName
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
;
if
(
mDescriptors
.
Remove
(
aName
getter_AddRefs
(
proto
)
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
for
(
auto
*
cp
:
ContentParent
:
:
AllProcesses
(
ContentParent
:
:
eLive
)
)
{
Unused
<
<
cp
-
>
SendUnregisterJSWindowActor
(
name
)
;
}
}
for
(
EventTarget
*
target
:
mChromeEventTargets
)
{
proto
-
>
UnregisterListenersFor
(
target
)
;
}
proto
-
>
RemoveObservers
(
)
;
}
}
void
JSWindowActorService
:
:
LoadJSWindowActorInfos
(
nsTArray
<
JSWindowActorInfo
>
&
aInfos
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
for
(
uint32_t
i
=
0
len
=
aInfos
.
Length
(
)
;
i
<
len
;
i
+
+
)
{
RefPtr
<
JSWindowActorProtocol
>
proto
=
JSWindowActorProtocol
:
:
FromIPC
(
aInfos
[
i
]
)
;
mDescriptors
.
Put
(
aInfos
[
i
]
.
name
(
)
proto
)
;
for
(
EventTarget
*
target
:
mChromeEventTargets
)
{
proto
-
>
RegisterListenersFor
(
target
)
;
}
proto
-
>
AddObservers
(
)
;
}
}
void
JSWindowActorService
:
:
GetJSWindowActorInfos
(
nsTArray
<
JSWindowActorInfo
>
&
aInfos
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
for
(
auto
iter
=
mDescriptors
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aInfos
.
AppendElement
(
iter
.
Data
(
)
-
>
ToIPC
(
)
)
;
}
}
void
JSWindowActorService
:
:
RegisterChromeEventTarget
(
EventTarget
*
aTarget
)
{
MOZ_ASSERT
(
!
mChromeEventTargets
.
Contains
(
aTarget
)
)
;
mChromeEventTargets
.
AppendElement
(
aTarget
)
;
for
(
auto
iter
=
mDescriptors
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
RegisterListenersFor
(
aTarget
)
;
}
}
void
JSWindowActorService
:
:
UnregisterChromeEventTarget
(
EventTarget
*
aTarget
)
{
if
(
gJSWindowActorService
)
{
gJSWindowActorService
-
>
mChromeEventTargets
.
RemoveElement
(
aTarget
)
;
}
}
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorService
:
:
GetProtocol
(
const
nsAString
&
aName
)
{
return
mDescriptors
.
Get
(
aName
)
;
}
}
}
