#
include
"
mozilla
/
net
/
OpaqueResponseUtils
.
h
"
#
include
"
mozilla
/
dom
/
JSValidatorParent
.
h
"
#
include
"
mozilla
/
dom
/
JSValidatorUtils
.
h
"
#
include
"
mozilla
/
dom
/
JSOracleParent
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
namespace
mozilla
:
:
dom
{
already_AddRefed
<
JSValidatorParent
>
JSValidatorParent
:
:
Create
(
)
{
RefPtr
<
JSValidatorParent
>
validator
=
new
JSValidatorParent
(
)
;
JSOracleParent
:
:
WithJSOracle
(
[
validator
]
(
JSOracleParent
*
aParent
)
{
MOZ_ASSERT_IF
(
aParent
aParent
-
>
CanSend
(
)
)
;
if
(
aParent
)
{
MOZ_ALWAYS_TRUE
(
aParent
-
>
SendPJSValidatorConstructor
(
validator
)
)
;
}
}
)
;
return
validator
.
forget
(
)
;
}
void
JSValidatorParent
:
:
IsOpaqueResponseAllowed
(
const
std
:
:
function
<
void
(
Maybe
<
Shmem
>
ValidatorResult
)
>
&
aCallback
)
{
JSOracleParent
:
:
WithJSOracle
(
[
=
self
=
RefPtr
{
this
}
]
(
const
auto
*
aParent
)
{
if
(
aParent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
self
-
>
CanSend
(
)
)
;
self
-
>
SendIsOpaqueResponseAllowed
(
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
[
aCallback
]
(
const
IsOpaqueResponseAllowedPromise
:
:
ResolveOrRejectValue
&
aResult
)
{
if
(
aResult
.
IsResolve
(
)
)
{
Maybe
<
Shmem
>
data
;
ValidatorResult
result
;
Tie
(
data
result
)
=
aResult
.
ResolveValue
(
)
;
aCallback
(
std
:
:
move
(
data
)
result
)
;
}
else
{
aCallback
(
Nothing
(
)
ValidatorResult
:
:
Failure
)
;
}
}
)
;
}
else
{
aCallback
(
Nothing
(
)
ValidatorResult
:
:
Failure
)
;
}
}
)
;
}
void
JSValidatorParent
:
:
OnDataAvailable
(
const
nsACString
&
aData
)
{
JSOracleParent
:
:
WithJSOracle
(
[
self
=
RefPtr
{
this
}
data
=
nsCString
{
aData
}
]
(
const
auto
*
aParent
)
{
if
(
!
aParent
)
{
return
;
}
if
(
self
-
>
CanSend
(
)
)
{
Shmem
sharedData
;
nsresult
rv
=
JSValidatorUtils
:
:
CopyCStringToShmem
(
self
data
sharedData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
Unused
<
<
self
-
>
SendOnDataAvailable
(
std
:
:
move
(
sharedData
)
)
;
}
}
)
;
}
void
JSValidatorParent
:
:
OnStopRequest
(
nsresult
aResult
)
{
JSOracleParent
:
:
WithJSOracle
(
[
self
=
RefPtr
{
this
}
aResult
]
(
const
auto
*
aParent
)
{
if
(
!
aParent
)
{
return
;
}
if
(
self
-
>
CanSend
(
)
)
{
Unused
<
<
self
-
>
SendOnStopRequest
(
aResult
)
;
}
}
)
;
}
}
