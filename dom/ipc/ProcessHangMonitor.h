#
ifndef
mozilla_ProcessHangMonitor_h
#
define
mozilla_ProcessHangMonitor_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIRemoteTab
.
h
"
#
include
"
nsStringFwd
.
h
"
class
nsIRunnable
;
class
nsIBrowserChild
;
class
nsIThread
;
namespace
mozilla
{
namespace
dom
{
class
ContentParent
;
class
BrowserParent
;
struct
CancelContentJSOptions
;
}
namespace
layers
{
struct
LayersObserverEpoch
;
}
class
PProcessHangMonitorParent
;
class
ProcessHangMonitor
final
:
public
nsIObserver
{
private
:
ProcessHangMonitor
(
)
;
virtual
~
ProcessHangMonitor
(
)
;
public
:
static
ProcessHangMonitor
*
Get
(
)
{
return
sInstance
;
}
static
ProcessHangMonitor
*
GetOrCreate
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
already_AddRefed
<
PProcessHangMonitorParent
>
AddProcess
(
dom
:
:
ContentParent
*
aContentParent
)
;
static
void
RemoveProcess
(
PProcessHangMonitorParent
*
aParent
)
;
static
void
ClearHang
(
)
;
static
void
PaintWhileInterruptingJS
(
PProcessHangMonitorParent
*
aParent
dom
:
:
BrowserParent
*
aTab
const
layers
:
:
LayersObserverEpoch
&
aEpoch
)
;
static
void
UnloadLayersWhileInterruptingJS
(
PProcessHangMonitorParent
*
aParent
dom
:
:
BrowserParent
*
aTab
const
layers
:
:
LayersObserverEpoch
&
aEpoch
)
;
static
void
ClearPaintWhileInterruptingJS
(
const
layers
:
:
LayersObserverEpoch
&
aEpoch
)
;
static
void
MaybeStartPaintWhileInterruptingJS
(
)
;
static
void
CancelContentJSExecutionIfRunning
(
PProcessHangMonitorParent
*
aParent
dom
:
:
BrowserParent
*
aTab
nsIRemoteTab
:
:
NavigationType
aNavigationType
const
dom
:
:
CancelContentJSOptions
&
aCancelContentJSOptions
)
;
enum
SlowScriptAction
{
Continue
Terminate
StartDebugger
}
;
SlowScriptAction
NotifySlowScript
(
nsIBrowserChild
*
aBrowserChild
const
char
*
aFileName
const
nsString
&
aAddonId
const
double
aDuration
)
;
void
NotifyPluginHang
(
uint32_t
aPluginId
)
;
bool
IsDebuggerStartupComplete
(
)
;
void
InitiateCPOWTimeout
(
)
;
bool
ShouldTimeOutCPOWs
(
)
;
nsresult
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
;
bool
IsOnThread
(
)
;
private
:
static
ProcessHangMonitor
*
sInstance
;
Atomic
<
bool
>
mCPOWTimeout
;
nsCOMPtr
<
nsIThread
>
mThread
;
}
;
}
#
endif
