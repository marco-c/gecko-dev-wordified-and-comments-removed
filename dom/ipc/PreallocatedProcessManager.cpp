#
include
"
mozilla
/
PreallocatedProcessManager
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
ProcessPriorityManager
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIXULRuntime
.
h
"
using
namespace
mozilla
:
:
hal
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
class
PreallocatedProcessManagerImpl
final
:
public
nsIObserver
{
public
:
static
PreallocatedProcessManagerImpl
*
Singleton
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
AddBlocker
(
ContentParent
*
aParent
)
;
void
RemoveBlocker
(
ContentParent
*
aParent
)
;
already_AddRefed
<
ContentParent
>
Take
(
)
;
bool
Provide
(
ContentParent
*
aParent
)
;
private
:
static
const
char
*
const
kObserverTopics
[
]
;
static
mozilla
:
:
StaticRefPtr
<
PreallocatedProcessManagerImpl
>
sSingleton
;
PreallocatedProcessManagerImpl
(
)
;
~
PreallocatedProcessManagerImpl
(
)
;
DISALLOW_EVIL_CONSTRUCTORS
(
PreallocatedProcessManagerImpl
)
;
void
Init
(
)
;
bool
CanAllocate
(
)
;
void
AllocateAfterDelay
(
)
;
void
AllocateOnIdle
(
)
;
void
AllocateNow
(
)
;
void
RereadPrefs
(
)
;
void
Enable
(
)
;
void
Disable
(
)
;
void
CloseProcess
(
)
;
void
ObserveProcessShutdown
(
nsISupports
*
aSubject
)
;
bool
mEnabled
;
bool
mShutdown
;
bool
mLaunchInProgress
;
RefPtr
<
ContentParent
>
mPreallocatedProcess
;
nsTHashtable
<
nsUint64HashKey
>
mBlockers
;
bool
IsEmpty
(
)
const
{
return
!
mPreallocatedProcess
&
&
!
mLaunchInProgress
;
}
}
;
const
char
*
const
PreallocatedProcessManagerImpl
:
:
kObserverTopics
[
]
=
{
"
ipc
:
content
-
shutdown
"
"
memory
-
pressure
"
"
profile
-
change
-
teardown
"
NS_XPCOM_SHUTDOWN_OBSERVER_ID
}
;
StaticRefPtr
<
PreallocatedProcessManagerImpl
>
PreallocatedProcessManagerImpl
:
:
sSingleton
;
PreallocatedProcessManagerImpl
*
PreallocatedProcessManagerImpl
:
:
Singleton
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sSingleton
)
{
sSingleton
=
new
PreallocatedProcessManagerImpl
(
)
;
sSingleton
-
>
Init
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
sSingleton
;
}
NS_IMPL_ISUPPORTS
(
PreallocatedProcessManagerImpl
nsIObserver
)
PreallocatedProcessManagerImpl
:
:
PreallocatedProcessManagerImpl
(
)
:
mEnabled
(
false
)
mShutdown
(
false
)
mLaunchInProgress
(
false
)
{
}
PreallocatedProcessManagerImpl
:
:
~
PreallocatedProcessManagerImpl
(
)
{
MOZ_RELEASE_ASSERT
(
!
mLaunchInProgress
)
;
}
void
PreallocatedProcessManagerImpl
:
:
Init
(
)
{
Preferences
:
:
AddStrongObserver
(
this
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Preferences
:
:
AddStrongObserver
(
this
"
dom
.
ipc
.
processCount
"
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
os
)
;
for
(
auto
topic
:
kObserverTopics
)
{
os
-
>
AddObserver
(
this
topic
false
)
;
}
RereadPrefs
(
)
;
}
NS_IMETHODIMP
PreallocatedProcessManagerImpl
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
"
ipc
:
content
-
shutdown
"
aTopic
)
)
{
ObserveProcessShutdown
(
aSubject
)
;
}
else
if
(
!
strcmp
(
"
nsPref
:
changed
"
aTopic
)
)
{
RereadPrefs
(
)
;
}
else
if
(
!
strcmp
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
aTopic
)
|
|
!
strcmp
(
"
profile
-
change
-
teardown
"
aTopic
)
)
{
Preferences
:
:
RemoveObserver
(
this
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Preferences
:
:
RemoveObserver
(
this
"
dom
.
ipc
.
processCount
"
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
os
)
;
for
(
auto
topic
:
kObserverTopics
)
{
os
-
>
RemoveObserver
(
this
topic
)
;
}
mShutdown
=
true
;
}
else
if
(
!
strcmp
(
"
memory
-
pressure
"
aTopic
)
)
{
CloseProcess
(
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
topic
"
)
;
}
return
NS_OK
;
}
void
PreallocatedProcessManagerImpl
:
:
RereadPrefs
(
)
{
if
(
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
&
&
Preferences
:
:
GetBool
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
)
{
Enable
(
)
;
}
else
{
Disable
(
)
;
}
if
(
ContentParent
:
:
IsMaxProcessCountReached
(
NS_LITERAL_STRING
(
DEFAULT_REMOTE_TYPE
)
)
)
{
CloseProcess
(
)
;
}
}
already_AddRefed
<
ContentParent
>
PreallocatedProcessManagerImpl
:
:
Take
(
)
{
if
(
!
mEnabled
|
|
mShutdown
)
{
return
nullptr
;
}
if
(
mPreallocatedProcess
)
{
ProcessPriorityManager
:
:
SetProcessPriority
(
mPreallocatedProcess
PROCESS_PRIORITY_FOREGROUND
)
;
AllocateOnIdle
(
)
;
}
return
mPreallocatedProcess
.
forget
(
)
;
}
bool
PreallocatedProcessManagerImpl
:
:
Provide
(
ContentParent
*
aParent
)
{
if
(
mEnabled
&
&
!
mShutdown
&
&
!
mPreallocatedProcess
)
{
mPreallocatedProcess
=
aParent
;
}
return
aParent
=
=
mPreallocatedProcess
;
}
void
PreallocatedProcessManagerImpl
:
:
Enable
(
)
{
if
(
mEnabled
)
{
return
;
}
mEnabled
=
true
;
AllocateAfterDelay
(
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AddBlocker
(
ContentParent
*
aParent
)
{
uint64_t
childID
=
aParent
-
>
ChildID
(
)
;
MOZ_ASSERT
(
!
mBlockers
.
Contains
(
childID
)
)
;
mBlockers
.
PutEntry
(
childID
)
;
}
void
PreallocatedProcessManagerImpl
:
:
RemoveBlocker
(
ContentParent
*
aParent
)
{
uint64_t
childID
=
aParent
-
>
ChildID
(
)
;
mBlockers
.
RemoveEntry
(
childID
)
;
if
(
IsEmpty
(
)
&
&
mBlockers
.
IsEmpty
(
)
)
{
AllocateAfterDelay
(
)
;
}
}
bool
PreallocatedProcessManagerImpl
:
:
CanAllocate
(
)
{
return
mEnabled
&
&
mBlockers
.
IsEmpty
(
)
&
&
IsEmpty
(
)
&
&
!
mShutdown
&
&
!
ContentParent
:
:
IsMaxProcessCountReached
(
NS_LITERAL_STRING
(
DEFAULT_REMOTE_TYPE
)
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AllocateAfterDelay
(
)
{
if
(
!
mEnabled
)
{
return
;
}
NS_DelayedDispatchToCurrentThread
(
NewRunnableMethod
(
"
PreallocatedProcessManagerImpl
:
:
AllocateOnIdle
"
this
&
PreallocatedProcessManagerImpl
:
:
AllocateOnIdle
)
StaticPrefs
:
:
dom_ipc_processPrelaunch_delayMs
(
)
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AllocateOnIdle
(
)
{
if
(
!
mEnabled
)
{
return
;
}
NS_DispatchToCurrentThreadQueue
(
NewRunnableMethod
(
"
PreallocatedProcessManagerImpl
:
:
AllocateNow
"
this
&
PreallocatedProcessManagerImpl
:
:
AllocateNow
)
EventQueuePriority
:
:
Idle
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AllocateNow
(
)
{
if
(
!
CanAllocate
(
)
)
{
if
(
mEnabled
&
&
!
mShutdown
&
&
IsEmpty
(
)
&
&
!
mBlockers
.
IsEmpty
(
)
)
{
AllocateAfterDelay
(
)
;
}
return
;
}
RefPtr
<
PreallocatedProcessManagerImpl
>
self
(
this
)
;
mLaunchInProgress
=
true
;
ContentParent
:
:
PreallocateProcess
(
)
-
>
Then
(
GetCurrentThreadSerialEventTarget
(
)
__func__
[
self
this
]
(
const
RefPtr
<
ContentParent
>
&
process
)
{
mLaunchInProgress
=
false
;
if
(
CanAllocate
(
)
)
{
mPreallocatedProcess
=
process
;
}
else
{
process
-
>
ShutDownProcess
(
ContentParent
:
:
SEND_SHUTDOWN_MESSAGE
)
;
}
}
[
self
this
]
(
ContentParent
:
:
LaunchError
err
)
{
mLaunchInProgress
=
false
;
}
)
;
}
void
PreallocatedProcessManagerImpl
:
:
Disable
(
)
{
if
(
!
mEnabled
)
{
return
;
}
mEnabled
=
false
;
CloseProcess
(
)
;
}
void
PreallocatedProcessManagerImpl
:
:
CloseProcess
(
)
{
if
(
mPreallocatedProcess
)
{
mPreallocatedProcess
-
>
ShutDownProcess
(
ContentParent
:
:
SEND_SHUTDOWN_MESSAGE
)
;
mPreallocatedProcess
=
nullptr
;
}
}
void
PreallocatedProcessManagerImpl
:
:
ObserveProcessShutdown
(
nsISupports
*
aSubject
)
{
nsCOMPtr
<
nsIPropertyBag2
>
props
=
do_QueryInterface
(
aSubject
)
;
NS_ENSURE_TRUE_VOID
(
props
)
;
uint64_t
childID
=
CONTENT_PROCESS_ID_UNKNOWN
;
props
-
>
GetPropertyAsUint64
(
NS_LITERAL_STRING
(
"
childID
"
)
&
childID
)
;
NS_ENSURE_TRUE_VOID
(
childID
!
=
CONTENT_PROCESS_ID_UNKNOWN
)
;
if
(
mPreallocatedProcess
&
&
childID
=
=
mPreallocatedProcess
-
>
ChildID
(
)
)
{
mPreallocatedProcess
=
nullptr
;
}
mBlockers
.
RemoveEntry
(
childID
)
;
}
inline
PreallocatedProcessManagerImpl
*
GetPPMImpl
(
)
{
return
PreallocatedProcessManagerImpl
:
:
Singleton
(
)
;
}
void
PreallocatedProcessManager
:
:
AddBlocker
(
ContentParent
*
aParent
)
{
GetPPMImpl
(
)
-
>
AddBlocker
(
aParent
)
;
}
void
PreallocatedProcessManager
:
:
RemoveBlocker
(
ContentParent
*
aParent
)
{
GetPPMImpl
(
)
-
>
RemoveBlocker
(
aParent
)
;
}
already_AddRefed
<
ContentParent
>
PreallocatedProcessManager
:
:
Take
(
)
{
return
GetPPMImpl
(
)
-
>
Take
(
)
;
}
bool
PreallocatedProcessManager
:
:
Provide
(
ContentParent
*
aParent
)
{
return
GetPPMImpl
(
)
-
>
Provide
(
aParent
)
;
}
}
