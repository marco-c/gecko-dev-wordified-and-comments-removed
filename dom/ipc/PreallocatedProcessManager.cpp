#
include
"
mozilla
/
PreallocatedProcessManager
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
ProcessPriorityManager
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
<
deque
>
using
namespace
mozilla
:
:
hal
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
class
PreallocatedProcessManagerImpl
final
:
public
nsIObserver
{
friend
class
PreallocatedProcessManager
;
public
:
static
PreallocatedProcessManagerImpl
*
Singleton
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
AddBlocker
(
ContentParent
*
aParent
)
;
void
RemoveBlocker
(
ContentParent
*
aParent
)
;
already_AddRefed
<
ContentParent
>
Take
(
const
nsAString
&
aRemoteType
)
;
bool
Provide
(
ContentParent
*
aParent
)
;
void
Erase
(
ContentParent
*
aParent
)
;
private
:
static
const
char
*
const
kObserverTopics
[
]
;
static
StaticRefPtr
<
PreallocatedProcessManagerImpl
>
sSingleton
;
PreallocatedProcessManagerImpl
(
)
;
~
PreallocatedProcessManagerImpl
(
)
;
DISALLOW_EVIL_CONSTRUCTORS
(
PreallocatedProcessManagerImpl
)
;
void
Init
(
)
;
bool
CanAllocate
(
)
;
void
AllocateAfterDelay
(
)
;
void
AllocateOnIdle
(
)
;
void
AllocateNow
(
)
;
void
RereadPrefs
(
)
;
void
Enable
(
uint32_t
aProcesses
)
;
void
Disable
(
)
;
void
CloseProcesses
(
)
;
bool
IsEmpty
(
)
const
{
return
mPreallocatedProcesses
.
empty
(
)
&
&
!
mLaunchInProgress
;
}
bool
mEnabled
;
static
bool
sShutdown
;
bool
mLaunchInProgress
;
uint32_t
mNumberPreallocs
;
std
:
:
deque
<
RefPtr
<
ContentParent
>
>
mPreallocatedProcesses
;
RefPtr
<
ContentParent
>
mPreallocatedE10SProcess
;
static
uint32_t
sNumBlockers
;
TimeStamp
mBlockingStartTime
;
}
;
uint32_t
PreallocatedProcessManagerImpl
:
:
sNumBlockers
=
0
;
bool
PreallocatedProcessManagerImpl
:
:
sShutdown
=
false
;
const
char
*
const
PreallocatedProcessManagerImpl
:
:
kObserverTopics
[
]
=
{
"
memory
-
pressure
"
"
profile
-
change
-
teardown
"
NS_XPCOM_SHUTDOWN_OBSERVER_ID
}
;
StaticRefPtr
<
PreallocatedProcessManagerImpl
>
PreallocatedProcessManagerImpl
:
:
sSingleton
;
PreallocatedProcessManagerImpl
*
PreallocatedProcessManagerImpl
:
:
Singleton
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sSingleton
)
{
sSingleton
=
new
PreallocatedProcessManagerImpl
;
sSingleton
-
>
Init
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
return
sSingleton
;
}
NS_IMPL_ISUPPORTS
(
PreallocatedProcessManagerImpl
nsIObserver
)
PreallocatedProcessManagerImpl
:
:
PreallocatedProcessManagerImpl
(
)
:
mEnabled
(
false
)
mLaunchInProgress
(
false
)
mNumberPreallocs
(
1
)
{
}
PreallocatedProcessManagerImpl
:
:
~
PreallocatedProcessManagerImpl
(
)
{
MOZ_RELEASE_ASSERT
(
!
mLaunchInProgress
)
;
}
void
PreallocatedProcessManagerImpl
:
:
Init
(
)
{
Preferences
:
:
AddStrongObserver
(
this
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Preferences
:
:
AddStrongObserver
(
this
"
dom
.
ipc
.
processCount
"
)
;
Preferences
:
:
AddStrongObserver
(
this
"
dom
.
ipc
.
processPrelaunch
.
fission
.
number
"
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
os
)
;
for
(
auto
topic
:
kObserverTopics
)
{
os
-
>
AddObserver
(
this
topic
false
)
;
}
RereadPrefs
(
)
;
}
NS_IMETHODIMP
PreallocatedProcessManagerImpl
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
"
nsPref
:
changed
"
aTopic
)
)
{
RereadPrefs
(
)
;
}
else
if
(
!
strcmp
(
NS_XPCOM_SHUTDOWN_OBSERVER_ID
aTopic
)
|
|
!
strcmp
(
"
profile
-
change
-
teardown
"
aTopic
)
)
{
Preferences
:
:
RemoveObserver
(
this
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
;
Preferences
:
:
RemoveObserver
(
this
"
dom
.
ipc
.
processCount
"
)
;
Preferences
:
:
RemoveObserver
(
this
"
dom
.
ipc
.
processPrelaunch
.
fission
.
number
"
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
MOZ_ASSERT
(
os
)
;
for
(
auto
topic
:
kObserverTopics
)
{
os
-
>
RemoveObserver
(
this
topic
)
;
}
sShutdown
=
true
;
}
else
if
(
!
strcmp
(
"
memory
-
pressure
"
aTopic
)
)
{
CloseProcesses
(
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
topic
"
)
;
}
return
NS_OK
;
}
void
PreallocatedProcessManagerImpl
:
:
RereadPrefs
(
)
{
if
(
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
&
&
Preferences
:
:
GetBool
(
"
dom
.
ipc
.
processPrelaunch
.
enabled
"
)
)
{
int32_t
number
=
1
;
if
(
mozilla
:
:
FissionAutostart
(
)
)
{
number
=
StaticPrefs
:
:
dom_ipc_processPrelaunch_fission_number
(
)
;
}
if
(
number
>
=
0
)
{
Enable
(
number
)
;
if
(
static_cast
<
uint64_t
>
(
number
)
<
mPreallocatedProcesses
.
size
(
)
)
{
CloseProcesses
(
)
;
}
}
}
else
{
Disable
(
)
;
}
}
already_AddRefed
<
ContentParent
>
PreallocatedProcessManagerImpl
:
:
Take
(
const
nsAString
&
aRemoteType
)
{
if
(
!
mEnabled
|
|
sShutdown
)
{
return
nullptr
;
}
RefPtr
<
ContentParent
>
process
;
if
(
aRemoteType
.
EqualsLiteral
(
DEFAULT_REMOTE_TYPE
)
)
{
process
=
mPreallocatedE10SProcess
.
forget
(
)
;
if
(
process
)
{
MOZ_LOG
(
ContentParent
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
Reuse
"
DEFAULT_REMOTE_TYPE
"
process
%
p
"
process
.
get
(
)
)
)
;
}
}
if
(
!
process
&
&
!
mPreallocatedProcesses
.
empty
(
)
)
{
process
=
mPreallocatedProcesses
.
front
(
)
.
forget
(
)
;
mPreallocatedProcesses
.
pop_front
(
)
;
AllocateOnIdle
(
)
;
MOZ_LOG
(
ContentParent
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
Use
"
PREALLOC_REMOTE_TYPE
"
process
%
p
"
process
.
get
(
)
)
)
;
}
if
(
process
)
{
ProcessPriorityManager
:
:
SetProcessPriority
(
process
PROCESS_PRIORITY_FOREGROUND
)
;
}
return
process
.
forget
(
)
;
}
bool
PreallocatedProcessManagerImpl
:
:
Provide
(
ContentParent
*
aParent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aParent
-
>
GetRemoteType
(
)
.
EqualsLiteral
(
DEFAULT_REMOTE_TYPE
)
)
;
if
(
mEnabled
&
&
!
sShutdown
&
&
!
mPreallocatedE10SProcess
)
{
MOZ_LOG
(
ContentParent
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
Store
for
reuse
"
DEFAULT_REMOTE_TYPE
"
process
%
p
"
aParent
)
)
;
ProcessPriorityManager
:
:
SetProcessPriority
(
aParent
PROCESS_PRIORITY_BACKGROUND
)
;
mPreallocatedE10SProcess
=
aParent
;
return
true
;
}
return
aParent
=
=
mPreallocatedE10SProcess
;
}
void
PreallocatedProcessManagerImpl
:
:
Erase
(
ContentParent
*
aParent
)
{
for
(
auto
it
=
mPreallocatedProcesses
.
begin
(
)
;
it
!
=
mPreallocatedProcesses
.
end
(
)
;
it
+
+
)
{
if
(
*
it
=
=
aParent
)
{
mPreallocatedProcesses
.
erase
(
it
)
;
break
;
}
}
if
(
mPreallocatedE10SProcess
=
=
aParent
)
{
mPreallocatedE10SProcess
=
nullptr
;
}
}
void
PreallocatedProcessManagerImpl
:
:
Enable
(
uint32_t
aProcesses
)
{
mNumberPreallocs
=
aProcesses
;
if
(
mEnabled
)
{
return
;
}
mEnabled
=
true
;
AllocateAfterDelay
(
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AddBlocker
(
ContentParent
*
aParent
)
{
if
(
sNumBlockers
=
=
0
)
{
mBlockingStartTime
=
TimeStamp
:
:
Now
(
)
;
}
sNumBlockers
+
+
;
}
void
PreallocatedProcessManagerImpl
:
:
RemoveBlocker
(
ContentParent
*
aParent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sNumBlockers
>
0
)
;
sNumBlockers
-
-
;
if
(
sNumBlockers
=
=
0
)
{
MOZ_LOG
(
ContentParent
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
Blocked
preallocation
for
%
fms
"
(
TimeStamp
:
:
Now
(
)
-
mBlockingStartTime
)
.
ToMilliseconds
(
)
)
)
;
PROFILER_ADD_TEXT_MARKER
(
"
Process
"
NS_LITERAL_CSTRING
(
"
Blocked
preallocation
"
)
JS
:
:
ProfilingCategoryPair
:
:
DOM
mBlockingStartTime
TimeStamp
:
:
Now
(
)
)
;
if
(
IsEmpty
(
)
)
{
AllocateAfterDelay
(
)
;
}
}
}
bool
PreallocatedProcessManagerImpl
:
:
CanAllocate
(
)
{
return
mEnabled
&
&
sNumBlockers
=
=
0
&
&
mPreallocatedProcesses
.
size
(
)
<
mNumberPreallocs
&
&
!
sShutdown
&
&
(
FissionAutostart
(
)
|
|
!
ContentParent
:
:
IsMaxProcessCountReached
(
NS_LITERAL_STRING
(
DEFAULT_REMOTE_TYPE
)
)
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AllocateAfterDelay
(
)
{
if
(
!
mEnabled
)
{
return
;
}
NS_DelayedDispatchToCurrentThread
(
NewRunnableMethod
(
"
PreallocatedProcessManagerImpl
:
:
AllocateOnIdle
"
this
&
PreallocatedProcessManagerImpl
:
:
AllocateOnIdle
)
StaticPrefs
:
:
dom_ipc_processPrelaunch_delayMs
(
)
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AllocateOnIdle
(
)
{
if
(
!
mEnabled
)
{
return
;
}
NS_DispatchToCurrentThreadQueue
(
NewRunnableMethod
(
"
PreallocatedProcessManagerImpl
:
:
AllocateNow
"
this
&
PreallocatedProcessManagerImpl
:
:
AllocateNow
)
EventQueuePriority
:
:
Idle
)
;
}
void
PreallocatedProcessManagerImpl
:
:
AllocateNow
(
)
{
if
(
!
CanAllocate
(
)
)
{
if
(
mEnabled
&
&
!
sShutdown
&
&
IsEmpty
(
)
&
&
sNumBlockers
>
0
)
{
AllocateAfterDelay
(
)
;
}
return
;
}
RefPtr
<
PreallocatedProcessManagerImpl
>
self
(
this
)
;
mLaunchInProgress
=
true
;
ContentParent
:
:
PreallocateProcess
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
this
]
(
const
RefPtr
<
ContentParent
>
&
process
)
{
mLaunchInProgress
=
false
;
if
(
CanAllocate
(
)
)
{
mPreallocatedProcesses
.
push_back
(
process
)
;
MOZ_LOG
(
ContentParent
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
Preallocated
=
%
lu
of
%
d
processes
"
(
unsigned
long
)
mPreallocatedProcesses
.
size
(
)
mNumberPreallocs
)
)
;
if
(
mPreallocatedProcesses
.
size
(
)
<
mNumberPreallocs
)
{
AllocateOnIdle
(
)
;
}
}
else
{
process
-
>
ShutDownProcess
(
ContentParent
:
:
SEND_SHUTDOWN_MESSAGE
)
;
}
}
[
self
this
]
(
ContentParent
:
:
LaunchError
err
)
{
mLaunchInProgress
=
false
;
}
)
;
}
void
PreallocatedProcessManagerImpl
:
:
Disable
(
)
{
if
(
!
mEnabled
)
{
return
;
}
mEnabled
=
false
;
CloseProcesses
(
)
;
}
void
PreallocatedProcessManagerImpl
:
:
CloseProcesses
(
)
{
while
(
!
mPreallocatedProcesses
.
empty
(
)
)
{
RefPtr
<
ContentParent
>
process
(
mPreallocatedProcesses
.
front
(
)
.
forget
(
)
)
;
mPreallocatedProcesses
.
pop_front
(
)
;
process
-
>
ShutDownProcess
(
ContentParent
:
:
SEND_SHUTDOWN_MESSAGE
)
;
}
if
(
mPreallocatedE10SProcess
)
{
mPreallocatedE10SProcess
-
>
ShutDownProcess
(
ContentParent
:
:
SEND_SHUTDOWN_MESSAGE
)
;
mPreallocatedE10SProcess
=
nullptr
;
}
}
inline
PreallocatedProcessManagerImpl
*
PreallocatedProcessManager
:
:
GetPPMImpl
(
)
{
if
(
PreallocatedProcessManagerImpl
:
:
sShutdown
)
{
return
nullptr
;
}
return
PreallocatedProcessManagerImpl
:
:
Singleton
(
)
;
}
void
PreallocatedProcessManager
:
:
AddBlocker
(
const
nsAString
&
aRemoteType
ContentParent
*
aParent
)
{
MOZ_LOG
(
ContentParent
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
AddBlocker
:
%
s
%
p
(
sNumBlockers
=
%
d
)
"
NS_ConvertUTF16toUTF8
(
aRemoteType
)
.
get
(
)
aParent
PreallocatedProcessManagerImpl
:
:
sNumBlockers
)
)
;
if
(
auto
impl
=
GetPPMImpl
(
)
)
{
impl
-
>
AddBlocker
(
aParent
)
;
}
}
void
PreallocatedProcessManager
:
:
RemoveBlocker
(
const
nsAString
&
aRemoteType
ContentParent
*
aParent
)
{
MOZ_LOG
(
ContentParent
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
RemoveBlocker
:
%
s
%
p
(
sNumBlockers
=
%
d
)
"
NS_ConvertUTF16toUTF8
(
aRemoteType
)
.
get
(
)
aParent
PreallocatedProcessManagerImpl
:
:
sNumBlockers
)
)
;
if
(
auto
impl
=
GetPPMImpl
(
)
)
{
impl
-
>
RemoveBlocker
(
aParent
)
;
}
}
already_AddRefed
<
ContentParent
>
PreallocatedProcessManager
:
:
Take
(
const
nsAString
&
aRemoteType
)
{
if
(
auto
impl
=
GetPPMImpl
(
)
)
{
return
impl
-
>
Take
(
aRemoteType
)
;
}
return
nullptr
;
}
bool
PreallocatedProcessManager
:
:
Provide
(
ContentParent
*
aParent
)
{
if
(
auto
impl
=
GetPPMImpl
(
)
)
{
return
impl
-
>
Provide
(
aParent
)
;
}
return
false
;
}
void
PreallocatedProcessManager
:
:
Erase
(
ContentParent
*
aParent
)
{
if
(
auto
impl
=
GetPPMImpl
(
)
)
{
impl
-
>
Erase
(
aParent
)
;
}
}
}
