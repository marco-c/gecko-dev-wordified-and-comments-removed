#
include
"
ProcessPriorityManager
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
Hal
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
StaticPtr
.
h
"
#
include
"
nsIMozBrowserFrame
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsQueryObject
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
hal
;
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
#
ifdef
LOG
#
undef
LOG
#
endif
#
if
defined
(
ANDROID
)
&
&
defined
(
ENABLE_LOGGING
)
#
include
<
android
/
log
.
h
>
#
define
LOG
(
fmt
.
.
.
)
\
__android_log_print
(
ANDROID_LOG_INFO
"
Gecko
:
ProcessPriorityManager
"
fmt
\
#
#
__VA_ARGS__
)
#
define
LOGP
(
fmt
.
.
.
)
\
__android_log_print
(
\
ANDROID_LOG_INFO
"
Gecko
:
ProcessPriorityManager
"
\
"
[
%
schild
-
id
=
%
"
PRIu64
"
pid
=
%
d
]
"
fmt
NameWithComma
(
)
.
get
(
)
\
static_cast
<
uint64_t
>
(
ChildID
(
)
)
Pid
(
)
#
#
__VA_ARGS__
)
#
elif
defined
(
ENABLE_LOGGING
)
#
define
LOG
(
fmt
.
.
.
)
\
printf
(
"
ProcessPriorityManager
-
"
fmt
"
\
n
"
#
#
__VA_ARGS__
)
#
define
LOGP
(
fmt
.
.
.
)
\
printf
(
"
ProcessPriorityManager
[
%
schild
-
id
=
%
"
PRIu64
"
pid
=
%
d
]
-
"
fmt
\
"
\
n
"
\
NameWithComma
(
)
.
get
(
)
static_cast
<
uint64_t
>
(
ChildID
(
)
)
Pid
(
)
\
#
#
__VA_ARGS__
)
#
else
static
LogModule
*
GetPPMLog
(
)
{
static
LazyLogModule
sLog
(
"
ProcessPriorityManager
"
)
;
return
sLog
;
}
#
define
LOG
(
fmt
.
.
.
)
\
MOZ_LOG
(
GetPPMLog
(
)
LogLevel
:
:
Debug
\
(
"
ProcessPriorityManager
-
"
fmt
#
#
__VA_ARGS__
)
)
#
define
LOGP
(
fmt
.
.
.
)
\
MOZ_LOG
(
GetPPMLog
(
)
LogLevel
:
:
Debug
\
(
"
ProcessPriorityManager
[
%
schild
-
id
=
%
"
PRIu64
"
pid
=
%
d
]
-
"
fmt
\
NameWithComma
(
)
.
get
(
)
static_cast
<
uint64_t
>
(
ChildID
(
)
)
Pid
(
)
\
#
#
__VA_ARGS__
)
)
#
endif
namespace
{
class
ParticularProcessPriorityManager
;
class
ProcessPriorityManagerImpl
final
:
public
nsIObserver
public
nsSupportsWeakReference
{
public
:
static
ProcessPriorityManagerImpl
*
GetSingleton
(
)
;
static
void
StaticInit
(
)
;
static
bool
PrefsEnabled
(
)
;
static
bool
TestMode
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
SetProcessPriority
(
ContentParent
*
aContentParent
ProcessPriority
aPriority
)
;
void
FireTestOnlyObserverNotification
(
const
char
*
aTopic
const
nsACString
&
aData
=
EmptyCString
(
)
)
;
void
NotifyProcessPriorityChanged
(
ParticularProcessPriorityManager
*
aParticularManager
hal
:
:
ProcessPriority
aOldPriority
)
;
void
TabActivityChanged
(
TabParent
*
aTabParent
bool
aIsActive
)
;
private
:
static
bool
sPrefsEnabled
;
static
bool
sRemoteTabsDisabled
;
static
bool
sTestMode
;
static
bool
sPrefListenersRegistered
;
static
bool
sInitialized
;
static
StaticRefPtr
<
ProcessPriorityManagerImpl
>
sSingleton
;
static
void
PrefChangedCallback
(
const
char
*
aPref
void
*
aClosure
)
;
ProcessPriorityManagerImpl
(
)
;
~
ProcessPriorityManagerImpl
(
)
;
DISALLOW_EVIL_CONSTRUCTORS
(
ProcessPriorityManagerImpl
)
;
void
Init
(
)
;
already_AddRefed
<
ParticularProcessPriorityManager
>
GetParticularProcessPriorityManager
(
ContentParent
*
aContentParent
)
;
void
ObserveContentParentCreated
(
nsISupports
*
aContentParent
)
;
void
ObserveContentParentDestroyed
(
nsISupports
*
aSubject
)
;
nsDataHashtable
<
nsUint64HashKey
RefPtr
<
ParticularProcessPriorityManager
>
>
mParticularManagers
;
nsTHashtable
<
nsUint64HashKey
>
mHighPriorityChildIDs
;
}
;
class
ProcessPriorityManagerChild
final
:
public
nsIObserver
{
public
:
static
void
StaticInit
(
)
;
static
ProcessPriorityManagerChild
*
Singleton
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
bool
CurrentProcessIsForeground
(
)
;
private
:
static
StaticRefPtr
<
ProcessPriorityManagerChild
>
sSingleton
;
ProcessPriorityManagerChild
(
)
;
~
ProcessPriorityManagerChild
(
)
{
}
DISALLOW_EVIL_CONSTRUCTORS
(
ProcessPriorityManagerChild
)
;
void
Init
(
)
;
hal
:
:
ProcessPriority
mCachedPriority
;
}
;
class
ParticularProcessPriorityManager
final
:
public
WakeLockObserver
public
nsIObserver
public
nsITimerCallback
public
nsINamed
public
nsSupportsWeakReference
{
~
ParticularProcessPriorityManager
(
)
;
public
:
explicit
ParticularProcessPriorityManager
(
ContentParent
*
aContentParent
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSITIMERCALLBACK
virtual
void
Notify
(
const
WakeLockInformation
&
aInfo
)
override
;
static
void
StaticInit
(
)
;
void
Init
(
)
;
int32_t
Pid
(
)
const
;
uint64_t
ChildID
(
)
const
;
const
nsAutoCString
&
NameWithComma
(
)
;
void
OnRemoteBrowserFrameShown
(
nsISupports
*
aSubject
)
;
void
OnTabParentDestroyed
(
nsISupports
*
aSubject
)
;
ProcessPriority
CurrentPriority
(
)
;
ProcessPriority
ComputePriority
(
)
;
enum
TimeoutPref
{
BACKGROUND_PERCEIVABLE_GRACE_PERIOD
BACKGROUND_GRACE_PERIOD
}
;
void
ScheduleResetPriority
(
TimeoutPref
aTimeoutPref
)
;
void
ResetPriority
(
)
;
void
ResetPriorityNow
(
)
;
void
SetPriorityNow
(
ProcessPriority
aPriority
)
;
void
TabActivityChanged
(
TabParent
*
aTabParent
bool
aIsActive
)
;
void
ShutDown
(
)
;
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
.
AssignLiteral
(
"
ParticularProcessPriorityManager
"
)
;
return
NS_OK
;
}
private
:
static
uint32_t
sBackgroundPerceivableGracePeriodMS
;
static
uint32_t
sBackgroundGracePeriodMS
;
void
FireTestOnlyObserverNotification
(
const
char
*
aTopic
const
nsACString
&
aData
=
EmptyCString
(
)
)
;
void
FireTestOnlyObserverNotification
(
const
char
*
aTopic
const
char
*
aData
=
nullptr
)
;
bool
IsHoldingWakeLock
(
const
nsAString
&
aTopic
)
;
ContentParent
*
mContentParent
;
uint64_t
mChildID
;
ProcessPriority
mPriority
;
bool
mHoldsCPUWakeLock
;
bool
mHoldsHighPriorityWakeLock
;
bool
mHoldsPlayingAudioWakeLock
;
bool
mHoldsPlayingVideoWakeLock
;
nsAutoCString
mNameWithComma
;
nsCOMPtr
<
nsITimer
>
mResetPriorityTimer
;
nsTHashtable
<
nsUint64HashKey
>
mActiveTabParents
;
}
;
bool
ProcessPriorityManagerImpl
:
:
sInitialized
=
false
;
bool
ProcessPriorityManagerImpl
:
:
sPrefsEnabled
=
false
;
bool
ProcessPriorityManagerImpl
:
:
sRemoteTabsDisabled
=
true
;
bool
ProcessPriorityManagerImpl
:
:
sTestMode
=
false
;
bool
ProcessPriorityManagerImpl
:
:
sPrefListenersRegistered
=
false
;
StaticRefPtr
<
ProcessPriorityManagerImpl
>
ProcessPriorityManagerImpl
:
:
sSingleton
;
uint32_t
ParticularProcessPriorityManager
:
:
sBackgroundPerceivableGracePeriodMS
=
0
;
uint32_t
ParticularProcessPriorityManager
:
:
sBackgroundGracePeriodMS
=
0
;
NS_IMPL_ISUPPORTS
(
ProcessPriorityManagerImpl
nsIObserver
nsISupportsWeakReference
)
;
void
ProcessPriorityManagerImpl
:
:
PrefChangedCallback
(
const
char
*
aPref
void
*
aClosure
)
{
StaticInit
(
)
;
if
(
!
PrefsEnabled
(
)
&
&
sSingleton
)
{
sSingleton
=
nullptr
;
sInitialized
=
false
;
}
}
bool
ProcessPriorityManagerImpl
:
:
PrefsEnabled
(
)
{
return
sPrefsEnabled
&
&
hal
:
:
SetProcessPrioritySupported
(
)
&
&
!
sRemoteTabsDisabled
;
}
bool
ProcessPriorityManagerImpl
:
:
TestMode
(
)
{
return
sTestMode
;
}
void
ProcessPriorityManagerImpl
:
:
StaticInit
(
)
{
if
(
sInitialized
)
{
return
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
sInitialized
=
true
;
return
;
}
if
(
!
sPrefListenersRegistered
)
{
Preferences
:
:
AddBoolVarCache
(
&
sPrefsEnabled
"
dom
.
ipc
.
processPriorityManager
.
enabled
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sRemoteTabsDisabled
"
dom
.
ipc
.
tabs
.
disabled
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sTestMode
"
dom
.
ipc
.
processPriorityManager
.
testMode
"
)
;
}
if
(
!
PrefsEnabled
(
)
)
{
LOG
(
"
InitProcessPriorityManager
bailing
due
to
prefs
.
"
)
;
if
(
!
sPrefListenersRegistered
)
{
sPrefListenersRegistered
=
true
;
Preferences
:
:
RegisterCallback
(
PrefChangedCallback
"
dom
.
ipc
.
processPriorityManager
.
enabled
"
)
;
Preferences
:
:
RegisterCallback
(
PrefChangedCallback
"
dom
.
ipc
.
tabs
.
disabled
"
)
;
}
return
;
}
sInitialized
=
true
;
sSingleton
=
new
ProcessPriorityManagerImpl
(
)
;
sSingleton
-
>
Init
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
ProcessPriorityManagerImpl
*
ProcessPriorityManagerImpl
:
:
GetSingleton
(
)
{
if
(
!
sSingleton
)
{
StaticInit
(
)
;
}
return
sSingleton
;
}
ProcessPriorityManagerImpl
:
:
ProcessPriorityManagerImpl
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
}
ProcessPriorityManagerImpl
:
:
~
ProcessPriorityManagerImpl
(
)
=
default
;
void
ProcessPriorityManagerImpl
:
:
Init
(
)
{
LOG
(
"
Starting
up
.
This
is
the
master
process
.
"
)
;
hal
:
:
SetProcessPriority
(
getpid
(
)
PROCESS_PRIORITY_MASTER
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
ipc
:
content
-
created
"
true
)
;
os
-
>
AddObserver
(
this
"
ipc
:
content
-
shutdown
"
true
)
;
}
}
NS_IMETHODIMP
ProcessPriorityManagerImpl
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
nsDependentCString
topic
(
aTopic
)
;
if
(
topic
.
EqualsLiteral
(
"
ipc
:
content
-
created
"
)
)
{
ObserveContentParentCreated
(
aSubject
)
;
}
else
if
(
topic
.
EqualsLiteral
(
"
ipc
:
content
-
shutdown
"
)
)
{
ObserveContentParentDestroyed
(
aSubject
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
}
return
NS_OK
;
}
already_AddRefed
<
ParticularProcessPriorityManager
>
ProcessPriorityManagerImpl
:
:
GetParticularProcessPriorityManager
(
ContentParent
*
aContentParent
)
{
uint64_t
cpId
=
aContentParent
-
>
ChildID
(
)
;
auto
entry
=
mParticularManagers
.
LookupForAdd
(
cpId
)
;
RefPtr
<
ParticularProcessPriorityManager
>
pppm
=
entry
.
OrInsert
(
[
aContentParent
]
(
)
{
return
new
ParticularProcessPriorityManager
(
aContentParent
)
;
}
)
;
if
(
!
entry
)
{
pppm
-
>
Init
(
)
;
FireTestOnlyObserverNotification
(
"
process
-
created
"
nsPrintfCString
(
"
%
"
PRIu64
cpId
)
)
;
}
return
pppm
.
forget
(
)
;
}
void
ProcessPriorityManagerImpl
:
:
SetProcessPriority
(
ContentParent
*
aContentParent
ProcessPriority
aPriority
)
{
MOZ_ASSERT
(
aContentParent
)
;
RefPtr
<
ParticularProcessPriorityManager
>
pppm
=
GetParticularProcessPriorityManager
(
aContentParent
)
;
if
(
pppm
)
{
pppm
-
>
SetPriorityNow
(
aPriority
)
;
}
}
void
ProcessPriorityManagerImpl
:
:
ObserveContentParentCreated
(
nsISupports
*
aContentParent
)
{
RefPtr
<
ContentParent
>
cp
=
do_QueryObject
(
aContentParent
)
;
RefPtr
<
ParticularProcessPriorityManager
>
pppm
=
GetParticularProcessPriorityManager
(
cp
)
;
}
void
ProcessPriorityManagerImpl
:
:
ObserveContentParentDestroyed
(
nsISupports
*
aSubject
)
{
nsCOMPtr
<
nsIPropertyBag2
>
props
=
do_QueryInterface
(
aSubject
)
;
NS_ENSURE_TRUE_VOID
(
props
)
;
uint64_t
childID
=
CONTENT_PROCESS_ID_UNKNOWN
;
props
-
>
GetPropertyAsUint64
(
NS_LITERAL_STRING
(
"
childID
"
)
&
childID
)
;
NS_ENSURE_TRUE_VOID
(
childID
!
=
CONTENT_PROCESS_ID_UNKNOWN
)
;
if
(
auto
entry
=
mParticularManagers
.
Lookup
(
childID
)
)
{
entry
.
Data
(
)
-
>
ShutDown
(
)
;
mHighPriorityChildIDs
.
RemoveEntry
(
childID
)
;
entry
.
Remove
(
)
;
}
}
void
ProcessPriorityManagerImpl
:
:
NotifyProcessPriorityChanged
(
ParticularProcessPriorityManager
*
aParticularManager
ProcessPriority
aOldPriority
)
{
ProcessPriority
newPriority
=
aParticularManager
-
>
CurrentPriority
(
)
;
if
(
newPriority
>
=
PROCESS_PRIORITY_FOREGROUND_HIGH
&
&
aOldPriority
<
PROCESS_PRIORITY_FOREGROUND_HIGH
)
{
mHighPriorityChildIDs
.
PutEntry
(
aParticularManager
-
>
ChildID
(
)
)
;
}
else
if
(
newPriority
<
PROCESS_PRIORITY_FOREGROUND_HIGH
&
&
aOldPriority
>
=
PROCESS_PRIORITY_FOREGROUND_HIGH
)
{
mHighPriorityChildIDs
.
RemoveEntry
(
aParticularManager
-
>
ChildID
(
)
)
;
}
}
void
ProcessPriorityManagerImpl
:
:
TabActivityChanged
(
TabParent
*
aTabParent
bool
aIsActive
)
{
RefPtr
<
ParticularProcessPriorityManager
>
pppm
=
GetParticularProcessPriorityManager
(
aTabParent
-
>
Manager
(
)
)
;
if
(
!
pppm
)
{
return
;
}
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
DOM_CONTENTPROCESS_OS_PRIORITY_CHANGE_CONSIDERED
1
)
;
pppm
-
>
TabActivityChanged
(
aTabParent
aIsActive
)
;
}
NS_IMPL_ISUPPORTS
(
ParticularProcessPriorityManager
nsIObserver
nsITimerCallback
nsISupportsWeakReference
nsINamed
)
;
ParticularProcessPriorityManager
:
:
ParticularProcessPriorityManager
(
ContentParent
*
aContentParent
)
:
mContentParent
(
aContentParent
)
mChildID
(
aContentParent
-
>
ChildID
(
)
)
mPriority
(
PROCESS_PRIORITY_UNKNOWN
)
mHoldsCPUWakeLock
(
false
)
mHoldsHighPriorityWakeLock
(
false
)
mHoldsPlayingAudioWakeLock
(
false
)
mHoldsPlayingVideoWakeLock
(
false
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
LOGP
(
"
Creating
ParticularProcessPriorityManager
.
"
)
;
}
void
ParticularProcessPriorityManager
:
:
StaticInit
(
)
{
Preferences
:
:
AddUintVarCache
(
&
sBackgroundPerceivableGracePeriodMS
"
dom
.
ipc
.
processPriorityManager
.
backgroundPerceivableGracePeriodMS
"
)
;
Preferences
:
:
AddUintVarCache
(
&
sBackgroundGracePeriodMS
"
dom
.
ipc
.
processPriorityManager
.
backgroundGracePeriodMS
"
)
;
}
void
ParticularProcessPriorityManager
:
:
Init
(
)
{
RegisterWakeLockObserver
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
remote
-
browser
-
shown
"
true
)
;
os
-
>
AddObserver
(
this
"
ipc
:
browser
-
destroyed
"
true
)
;
}
mHoldsCPUWakeLock
=
IsHoldingWakeLock
(
NS_LITERAL_STRING
(
"
cpu
"
)
)
;
mHoldsHighPriorityWakeLock
=
IsHoldingWakeLock
(
NS_LITERAL_STRING
(
"
high
-
priority
"
)
)
;
mHoldsPlayingAudioWakeLock
=
IsHoldingWakeLock
(
NS_LITERAL_STRING
(
"
audio
-
playing
"
)
)
;
mHoldsPlayingVideoWakeLock
=
IsHoldingWakeLock
(
NS_LITERAL_STRING
(
"
video
-
playing
"
)
)
;
LOGP
(
"
Done
starting
up
.
mHoldsCPUWakeLock
=
%
d
"
"
mHoldsHighPriorityWakeLock
=
%
d
mHoldsPlayingAudioWakeLock
=
%
d
"
"
mHoldsPlayingVideoWakeLock
=
%
d
"
mHoldsCPUWakeLock
mHoldsHighPriorityWakeLock
mHoldsPlayingAudioWakeLock
mHoldsPlayingVideoWakeLock
)
;
}
bool
ParticularProcessPriorityManager
:
:
IsHoldingWakeLock
(
const
nsAString
&
aTopic
)
{
WakeLockInformation
info
;
GetWakeLockInfo
(
aTopic
&
info
)
;
return
info
.
lockingProcesses
(
)
.
Contains
(
ChildID
(
)
)
;
}
ParticularProcessPriorityManager
:
:
~
ParticularProcessPriorityManager
(
)
{
LOGP
(
"
Destroying
ParticularProcessPriorityManager
.
"
)
;
if
(
mContentParent
)
{
UnregisterWakeLockObserver
(
this
)
;
}
}
void
ParticularProcessPriorityManager
:
:
Notify
(
const
WakeLockInformation
&
aInfo
)
{
if
(
!
mContentParent
)
{
return
;
}
bool
*
dest
=
nullptr
;
if
(
aInfo
.
topic
(
)
.
EqualsLiteral
(
"
cpu
"
)
)
{
dest
=
&
mHoldsCPUWakeLock
;
}
else
if
(
aInfo
.
topic
(
)
.
EqualsLiteral
(
"
high
-
priority
"
)
)
{
dest
=
&
mHoldsHighPriorityWakeLock
;
}
else
if
(
aInfo
.
topic
(
)
.
EqualsLiteral
(
"
audio
-
playing
"
)
)
{
dest
=
&
mHoldsPlayingAudioWakeLock
;
}
else
if
(
aInfo
.
topic
(
)
.
EqualsLiteral
(
"
video
-
playing
"
)
)
{
dest
=
&
mHoldsPlayingVideoWakeLock
;
}
if
(
dest
)
{
bool
thisProcessLocks
=
aInfo
.
lockingProcesses
(
)
.
Contains
(
ChildID
(
)
)
;
if
(
thisProcessLocks
!
=
*
dest
)
{
*
dest
=
thisProcessLocks
;
LOGP
(
"
Got
wake
lock
changed
event
.
"
"
Now
mHoldsCPUWakeLock
=
%
d
mHoldsHighPriorityWakeLock
=
%
d
"
"
mHoldsPlayingAudioWakeLock
=
%
d
mHoldsPlayingVideoWakeLock
=
%
d
"
mHoldsCPUWakeLock
mHoldsHighPriorityWakeLock
mHoldsPlayingAudioWakeLock
mHoldsPlayingVideoWakeLock
)
;
ResetPriority
(
)
;
}
}
}
NS_IMETHODIMP
ParticularProcessPriorityManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
mContentParent
)
{
return
NS_OK
;
}
nsDependentCString
topic
(
aTopic
)
;
if
(
topic
.
EqualsLiteral
(
"
remote
-
browser
-
shown
"
)
)
{
OnRemoteBrowserFrameShown
(
aSubject
)
;
}
else
if
(
topic
.
EqualsLiteral
(
"
ipc
:
browser
-
destroyed
"
)
)
{
OnTabParentDestroyed
(
aSubject
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
}
return
NS_OK
;
}
uint64_t
ParticularProcessPriorityManager
:
:
ChildID
(
)
const
{
return
mChildID
;
}
int32_t
ParticularProcessPriorityManager
:
:
Pid
(
)
const
{
return
mContentParent
?
mContentParent
-
>
Pid
(
)
:
-
1
;
}
const
nsAutoCString
&
ParticularProcessPriorityManager
:
:
NameWithComma
(
)
{
mNameWithComma
.
Truncate
(
)
;
if
(
!
mContentParent
)
{
return
mNameWithComma
;
}
nsAutoString
name
;
mContentParent
-
>
FriendlyName
(
name
)
;
if
(
name
.
IsEmpty
(
)
)
{
return
mNameWithComma
;
}
mNameWithComma
=
NS_ConvertUTF16toUTF8
(
name
)
;
mNameWithComma
.
AppendLiteral
(
"
"
)
;
return
mNameWithComma
;
}
void
ParticularProcessPriorityManager
:
:
OnRemoteBrowserFrameShown
(
nsISupports
*
aSubject
)
{
RefPtr
<
nsFrameLoader
>
fl
=
do_QueryObject
(
aSubject
)
;
NS_ENSURE_TRUE_VOID
(
fl
)
;
TabParent
*
tp
=
TabParent
:
:
GetFrom
(
fl
)
;
NS_ENSURE_TRUE_VOID
(
tp
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
tp
-
>
Manager
(
)
!
=
mContentParent
)
{
return
;
}
if
(
fl
-
>
OwnerIsMozBrowserFrame
(
)
)
{
ResetPriority
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
this
"
remote
-
browser
-
shown
"
)
;
}
}
void
ParticularProcessPriorityManager
:
:
OnTabParentDestroyed
(
nsISupports
*
aSubject
)
{
nsCOMPtr
<
nsIRemoteTab
>
tp
=
do_QueryInterface
(
aSubject
)
;
NS_ENSURE_TRUE_VOID
(
tp
)
;
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
TabParent
:
:
GetFrom
(
tp
)
-
>
Manager
(
)
!
=
mContentParent
)
{
return
;
}
uint64_t
tabId
;
if
(
NS_WARN_IF
(
NS_FAILED
(
tp
-
>
GetTabId
(
&
tabId
)
)
)
)
{
return
;
}
mActiveTabParents
.
RemoveEntry
(
tabId
)
;
ResetPriority
(
)
;
}
void
ParticularProcessPriorityManager
:
:
ResetPriority
(
)
{
ProcessPriority
processPriority
=
ComputePriority
(
)
;
if
(
mPriority
=
=
PROCESS_PRIORITY_UNKNOWN
|
|
mPriority
>
processPriority
)
{
if
(
mPriority
=
=
PROCESS_PRIORITY_BACKGROUND_PERCEIVABLE
)
{
ScheduleResetPriority
(
BACKGROUND_PERCEIVABLE_GRACE_PERIOD
)
;
}
else
{
ScheduleResetPriority
(
BACKGROUND_GRACE_PERIOD
)
;
}
return
;
}
SetPriorityNow
(
processPriority
)
;
}
void
ParticularProcessPriorityManager
:
:
ResetPriorityNow
(
)
{
SetPriorityNow
(
ComputePriority
(
)
)
;
}
void
ParticularProcessPriorityManager
:
:
ScheduleResetPriority
(
TimeoutPref
aTimeoutPref
)
{
if
(
mResetPriorityTimer
)
{
LOGP
(
"
ScheduleResetPriority
bailing
;
the
timer
is
already
running
.
"
)
;
return
;
}
uint32_t
timeout
=
0
;
switch
(
aTimeoutPref
)
{
case
BACKGROUND_PERCEIVABLE_GRACE_PERIOD
:
timeout
=
sBackgroundPerceivableGracePeriodMS
;
break
;
case
BACKGROUND_GRACE_PERIOD
:
timeout
=
sBackgroundGracePeriodMS
;
break
;
default
:
MOZ_ASSERT
(
false
"
Unrecognized
timeout
pref
"
)
;
break
;
}
LOGP
(
"
Scheduling
reset
timer
to
fire
in
%
dms
.
"
timeout
)
;
NS_NewTimerWithCallback
(
getter_AddRefs
(
mResetPriorityTimer
)
this
timeout
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
NS_IMETHODIMP
ParticularProcessPriorityManager
:
:
Notify
(
nsITimer
*
aTimer
)
{
LOGP
(
"
Reset
priority
timer
callback
;
about
to
ResetPriorityNow
.
"
)
;
ResetPriorityNow
(
)
;
mResetPriorityTimer
=
nullptr
;
return
NS_OK
;
}
ProcessPriority
ParticularProcessPriorityManager
:
:
CurrentPriority
(
)
{
return
mPriority
;
}
ProcessPriority
ParticularProcessPriorityManager
:
:
ComputePriority
(
)
{
if
(
!
mActiveTabParents
.
IsEmpty
(
)
|
|
mContentParent
-
>
GetRemoteType
(
)
.
EqualsLiteral
(
EXTENSION_REMOTE_TYPE
)
|
|
mHoldsPlayingAudioWakeLock
)
{
return
PROCESS_PRIORITY_FOREGROUND
;
}
if
(
mHoldsCPUWakeLock
|
|
mHoldsHighPriorityWakeLock
|
|
mHoldsPlayingVideoWakeLock
)
{
return
PROCESS_PRIORITY_BACKGROUND_PERCEIVABLE
;
}
return
PROCESS_PRIORITY_BACKGROUND
;
}
void
ParticularProcessPriorityManager
:
:
SetPriorityNow
(
ProcessPriority
aPriority
)
{
if
(
aPriority
=
=
PROCESS_PRIORITY_UNKNOWN
)
{
MOZ_ASSERT
(
false
)
;
return
;
}
if
(
!
ProcessPriorityManagerImpl
:
:
PrefsEnabled
(
)
|
|
!
mContentParent
|
|
mPriority
=
=
aPriority
)
{
return
;
}
if
(
mPriority
=
=
aPriority
)
{
hal
:
:
SetProcessPriority
(
Pid
(
)
mPriority
)
;
return
;
}
LOGP
(
"
Changing
priority
from
%
s
to
%
s
.
"
ProcessPriorityToString
(
mPriority
)
ProcessPriorityToString
(
aPriority
)
)
;
ProcessPriority
oldPriority
=
mPriority
;
mPriority
=
aPriority
;
if
(
oldPriority
<
mPriority
&
&
oldPriority
!
=
PROCESS_PRIORITY_UNKNOWN
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
DOM_CONTENTPROCESS_OS_PRIORITY_RAISED
1
)
;
}
else
if
(
oldPriority
>
mPriority
)
{
Telemetry
:
:
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
DOM_CONTENTPROCESS_OS_PRIORITY_LOWERED
1
)
;
}
hal
:
:
SetProcessPriority
(
Pid
(
)
mPriority
)
;
if
(
oldPriority
!
=
mPriority
)
{
ProcessPriorityManagerImpl
:
:
GetSingleton
(
)
-
>
NotifyProcessPriorityChanged
(
this
oldPriority
)
;
Unused
<
<
mContentParent
-
>
SendNotifyProcessPriorityChanged
(
mPriority
)
;
}
FireTestOnlyObserverNotification
(
"
process
-
priority
-
set
"
ProcessPriorityToString
(
mPriority
)
)
;
}
void
ParticularProcessPriorityManager
:
:
TabActivityChanged
(
TabParent
*
aTabParent
bool
aIsActive
)
{
MOZ_ASSERT
(
aTabParent
)
;
if
(
!
aIsActive
)
{
mActiveTabParents
.
RemoveEntry
(
aTabParent
-
>
GetTabId
(
)
)
;
}
else
{
mActiveTabParents
.
PutEntry
(
aTabParent
-
>
GetTabId
(
)
)
;
}
ResetPriority
(
)
;
}
void
ParticularProcessPriorityManager
:
:
ShutDown
(
)
{
MOZ_ASSERT
(
mContentParent
)
;
UnregisterWakeLockObserver
(
this
)
;
if
(
mResetPriorityTimer
)
{
mResetPriorityTimer
-
>
Cancel
(
)
;
mResetPriorityTimer
=
nullptr
;
}
mContentParent
=
nullptr
;
}
void
ProcessPriorityManagerImpl
:
:
FireTestOnlyObserverNotification
(
const
char
*
aTopic
const
nsACString
&
aData
)
{
if
(
!
TestMode
(
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE_VOID
(
os
)
;
nsPrintfCString
topic
(
"
process
-
priority
-
manager
:
TEST
-
ONLY
:
%
s
"
aTopic
)
;
LOG
(
"
Notifying
observer
%
s
data
%
s
"
topic
.
get
(
)
PromiseFlatCString
(
aData
)
.
get
(
)
)
;
os
-
>
NotifyObservers
(
nullptr
topic
.
get
(
)
NS_ConvertUTF8toUTF16
(
aData
)
.
get
(
)
)
;
}
void
ParticularProcessPriorityManager
:
:
FireTestOnlyObserverNotification
(
const
char
*
aTopic
const
char
*
aData
)
{
if
(
!
ProcessPriorityManagerImpl
:
:
TestMode
(
)
)
{
return
;
}
nsAutoCString
data
;
if
(
aData
)
{
data
.
AppendASCII
(
aData
)
;
}
FireTestOnlyObserverNotification
(
aTopic
data
)
;
}
void
ParticularProcessPriorityManager
:
:
FireTestOnlyObserverNotification
(
const
char
*
aTopic
const
nsACString
&
aData
)
{
if
(
!
ProcessPriorityManagerImpl
:
:
TestMode
(
)
)
{
return
;
}
nsAutoCString
data
(
nsPrintfCString
(
"
%
"
PRIu64
ChildID
(
)
)
)
;
if
(
!
aData
.
IsEmpty
(
)
)
{
data
.
Append
(
'
:
'
)
;
data
.
Append
(
aData
)
;
}
ProcessPriorityManagerImpl
:
:
GetSingleton
(
)
-
>
FireTestOnlyObserverNotification
(
aTopic
data
)
;
}
StaticRefPtr
<
ProcessPriorityManagerChild
>
ProcessPriorityManagerChild
:
:
sSingleton
;
void
ProcessPriorityManagerChild
:
:
StaticInit
(
)
{
if
(
!
sSingleton
)
{
sSingleton
=
new
ProcessPriorityManagerChild
(
)
;
sSingleton
-
>
Init
(
)
;
ClearOnShutdown
(
&
sSingleton
)
;
}
}
ProcessPriorityManagerChild
*
ProcessPriorityManagerChild
:
:
Singleton
(
)
{
StaticInit
(
)
;
return
sSingleton
;
}
NS_IMPL_ISUPPORTS
(
ProcessPriorityManagerChild
nsIObserver
)
ProcessPriorityManagerChild
:
:
ProcessPriorityManagerChild
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
mCachedPriority
=
PROCESS_PRIORITY_MASTER
;
}
else
{
mCachedPriority
=
PROCESS_PRIORITY_UNKNOWN
;
}
}
void
ProcessPriorityManagerChild
:
:
Init
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
NS_ENSURE_TRUE_VOID
(
os
)
;
os
-
>
AddObserver
(
this
"
ipc
:
process
-
priority
-
changed
"
false
)
;
}
}
NS_IMETHODIMP
ProcessPriorityManagerChild
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
!
strcmp
(
aTopic
"
ipc
:
process
-
priority
-
changed
"
)
)
;
nsCOMPtr
<
nsIPropertyBag2
>
props
=
do_QueryInterface
(
aSubject
)
;
NS_ENSURE_TRUE
(
props
NS_OK
)
;
int32_t
priority
=
static_cast
<
int32_t
>
(
PROCESS_PRIORITY_UNKNOWN
)
;
props
-
>
GetPropertyAsInt32
(
NS_LITERAL_STRING
(
"
priority
"
)
&
priority
)
;
NS_ENSURE_TRUE
(
ProcessPriority
(
priority
)
!
=
PROCESS_PRIORITY_UNKNOWN
NS_OK
)
;
mCachedPriority
=
static_cast
<
ProcessPriority
>
(
priority
)
;
return
NS_OK
;
}
bool
ProcessPriorityManagerChild
:
:
CurrentProcessIsForeground
(
)
{
return
mCachedPriority
=
=
PROCESS_PRIORITY_UNKNOWN
|
|
mCachedPriority
>
=
PROCESS_PRIORITY_FOREGROUND
;
}
}
namespace
mozilla
{
void
ProcessPriorityManager
:
:
Init
(
)
{
ProcessPriorityManagerImpl
:
:
StaticInit
(
)
;
ProcessPriorityManagerChild
:
:
StaticInit
(
)
;
ParticularProcessPriorityManager
:
:
StaticInit
(
)
;
}
void
ProcessPriorityManager
:
:
SetProcessPriority
(
ContentParent
*
aContentParent
ProcessPriority
aPriority
)
{
MOZ_ASSERT
(
aContentParent
)
;
ProcessPriorityManagerImpl
*
singleton
=
ProcessPriorityManagerImpl
:
:
GetSingleton
(
)
;
if
(
singleton
)
{
singleton
-
>
SetProcessPriority
(
aContentParent
aPriority
)
;
}
}
bool
ProcessPriorityManager
:
:
CurrentProcessIsForeground
(
)
{
return
ProcessPriorityManagerChild
:
:
Singleton
(
)
-
>
CurrentProcessIsForeground
(
)
;
}
void
ProcessPriorityManager
:
:
TabActivityChanged
(
TabParent
*
aTabParent
bool
aIsActive
)
{
MOZ_ASSERT
(
aTabParent
)
;
ProcessPriorityManagerImpl
*
singleton
=
ProcessPriorityManagerImpl
:
:
GetSingleton
(
)
;
if
(
!
singleton
)
{
return
;
}
singleton
-
>
TabActivityChanged
(
aTabParent
aIsActive
)
;
}
}
