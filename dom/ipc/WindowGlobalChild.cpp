#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
MozFrameLoaderOwnerBinding
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalActorsBinding
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
ipc
/
InProcessChild
.
h
"
#
include
"
mozilla
/
ipc
/
InProcessParent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorService
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIURIMutator
.
h
"
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
dom
:
:
ipc
;
namespace
mozilla
{
namespace
dom
{
typedef
nsRefPtrHashtable
<
nsUint64HashKey
WindowGlobalChild
>
WGCByIdMap
;
static
StaticAutoPtr
<
WGCByIdMap
>
gWindowGlobalChildById
;
WindowGlobalChild
:
:
WindowGlobalChild
(
const
WindowGlobalInit
&
aInit
nsGlobalWindowInner
*
aWindow
)
:
mWindowGlobal
(
aWindow
)
mBrowsingContext
(
aInit
.
browsingContext
(
)
)
mDocumentPrincipal
(
aInit
.
principal
(
)
)
mDocumentURI
(
aInit
.
documentURI
(
)
)
mInnerWindowId
(
aInit
.
innerWindowId
(
)
)
mOuterWindowId
(
aInit
.
outerWindowId
(
)
)
mBeforeUnloadListeners
(
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mBrowsingContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mDocumentPrincipal
)
;
MOZ_ASSERT_IF
(
aWindow
mInnerWindowId
=
=
aWindow
-
>
WindowID
(
)
)
;
MOZ_ASSERT_IF
(
aWindow
mOuterWindowId
=
=
aWindow
-
>
GetOuterWindow
(
)
-
>
WindowID
(
)
)
;
}
already_AddRefed
<
WindowGlobalChild
>
WindowGlobalChild
:
:
Create
(
nsGlobalWindowInner
*
aWindow
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aWindow
-
>
GetPrincipal
(
)
;
MOZ_ASSERT
(
principal
)
;
RefPtr
<
nsDocShell
>
docshell
=
nsDocShell
:
:
Cast
(
aWindow
-
>
GetDocShell
(
)
)
;
MOZ_ASSERT
(
docshell
)
;
RefPtr
<
dom
:
:
BrowsingContext
>
bc
=
docshell
-
>
GetBrowsingContext
(
)
;
nsCOMPtr
<
nsIChannel
>
chan
=
aWindow
-
>
GetDocument
(
)
-
>
GetChannel
(
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
?
chan
-
>
LoadInfo
(
)
:
nullptr
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChan
=
do_QueryInterface
(
chan
)
;
nsILoadInfo
:
:
CrossOriginOpenerPolicy
policy
;
if
(
httpChan
&
&
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
&
&
NS_SUCCEEDED
(
httpChan
-
>
GetCrossOriginOpenerPolicy
(
&
policy
)
)
)
{
bc
-
>
SetOpenerPolicy
(
policy
)
;
}
WindowGlobalInit
init
(
principal
aWindow
-
>
GetDocumentURI
(
)
bc
aWindow
-
>
WindowID
(
)
aWindow
-
>
GetOuterWindow
(
)
-
>
WindowID
(
)
)
;
auto
wgc
=
MakeRefPtr
<
WindowGlobalChild
>
(
init
aWindow
)
;
if
(
bc
-
>
IsDiscarded
(
)
)
{
wgc
-
>
ActorDestroy
(
FailedConstructor
)
;
return
wgc
.
forget
(
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
InProcessChild
*
ipChild
=
InProcessChild
:
:
Singleton
(
)
;
InProcessParent
*
ipParent
=
InProcessParent
:
:
Singleton
(
)
;
if
(
!
ipChild
|
|
!
ipParent
)
{
return
nullptr
;
}
ManagedEndpoint
<
PWindowGlobalParent
>
endpoint
=
ipChild
-
>
OpenPWindowGlobalEndpoint
(
wgc
)
;
auto
wgp
=
MakeRefPtr
<
WindowGlobalParent
>
(
init
true
)
;
ipParent
-
>
BindPWindowGlobalEndpoint
(
std
:
:
move
(
endpoint
)
wgp
)
;
wgp
-
>
Init
(
init
)
;
}
else
{
RefPtr
<
BrowserChild
>
browserChild
=
BrowserChild
:
:
GetFrom
(
static_cast
<
mozIDOMWindow
*
>
(
aWindow
)
)
;
MOZ_ASSERT
(
browserChild
)
;
ManagedEndpoint
<
PWindowGlobalParent
>
endpoint
=
browserChild
-
>
OpenPWindowGlobalEndpoint
(
wgc
)
;
browserChild
-
>
SendNewWindowGlobal
(
std
:
:
move
(
endpoint
)
init
)
;
}
wgc
-
>
Init
(
)
;
return
wgc
.
forget
(
)
;
}
void
WindowGlobalChild
:
:
Init
(
)
{
if
(
!
mDocumentURI
)
{
NS_NewURI
(
getter_AddRefs
(
mDocumentURI
)
"
about
:
blank
"
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
mWindowContext
=
GetParentActor
(
)
;
}
else
{
mWindowContext
=
WindowContext
:
:
Create
(
this
)
;
}
if
(
!
gWindowGlobalChildById
)
{
gWindowGlobalChildById
=
new
WGCByIdMap
(
)
;
ClearOnShutdown
(
&
gWindowGlobalChildById
)
;
}
auto
entry
=
gWindowGlobalChildById
-
>
LookupForAdd
(
mInnerWindowId
)
;
MOZ_RELEASE_ASSERT
(
!
entry
"
Duplicate
WindowGlobalChild
entry
for
ID
!
"
)
;
entry
.
OrInsert
(
[
&
]
{
return
this
;
}
)
;
}
void
WindowGlobalChild
:
:
InitWindowGlobal
(
nsGlobalWindowInner
*
aWindow
)
{
mWindowGlobal
=
aWindow
;
}
already_AddRefed
<
WindowGlobalChild
>
WindowGlobalChild
:
:
GetByInnerWindowId
(
uint64_t
aInnerWindowId
)
{
if
(
!
gWindowGlobalChildById
)
{
return
nullptr
;
}
return
gWindowGlobalChildById
-
>
Get
(
aInnerWindowId
)
;
}
bool
WindowGlobalChild
:
:
IsCurrentGlobal
(
)
{
return
CanSend
(
)
&
&
mWindowGlobal
-
>
IsCurrentInnerWindow
(
)
;
}
already_AddRefed
<
WindowGlobalParent
>
WindowGlobalChild
:
:
GetParentActor
(
)
{
if
(
!
CanSend
(
)
)
{
return
nullptr
;
}
IProtocol
*
otherSide
=
InProcessChild
:
:
ParentActorFor
(
this
)
;
return
do_AddRef
(
static_cast
<
WindowGlobalParent
*
>
(
otherSide
)
)
;
}
already_AddRefed
<
BrowserChild
>
WindowGlobalChild
:
:
GetBrowserChild
(
)
{
if
(
IsInProcess
(
)
|
|
!
CanSend
(
)
)
{
return
nullptr
;
}
return
do_AddRef
(
static_cast
<
BrowserChild
*
>
(
Manager
(
)
)
)
;
}
uint64_t
WindowGlobalChild
:
:
ContentParentId
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
return
0
;
}
return
ContentChild
:
:
GetSingleton
(
)
-
>
GetID
(
)
;
}
bool
WindowGlobalChild
:
:
IsProcessRoot
(
)
{
if
(
!
BrowsingContext
(
)
-
>
GetParent
(
)
)
{
return
true
;
}
return
!
BrowsingContext
(
)
-
>
GetEmbedderElement
(
)
;
}
void
WindowGlobalChild
:
:
BeforeUnloadAdded
(
)
{
if
(
mBeforeUnloadListeners
=
=
0
&
&
CanSend
(
)
)
{
SendSetHasBeforeUnload
(
true
)
;
}
mBeforeUnloadListeners
+
+
;
MOZ_ASSERT
(
mBeforeUnloadListeners
>
0
)
;
}
void
WindowGlobalChild
:
:
BeforeUnloadRemoved
(
)
{
mBeforeUnloadListeners
-
-
;
MOZ_ASSERT
(
mBeforeUnloadListeners
>
=
0
)
;
if
(
mBeforeUnloadListeners
=
=
0
&
&
CanSend
(
)
)
{
SendSetHasBeforeUnload
(
false
)
;
}
}
void
WindowGlobalChild
:
:
Destroy
(
)
{
nsTArray
<
RefPtr
<
JSWindowActorChild
>
>
windowActors
(
mWindowActors
.
Count
(
)
)
;
for
(
auto
iter
=
mWindowActors
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
windowActors
.
AppendElement
(
iter
.
UserData
(
)
)
;
}
for
(
auto
&
windowActor
:
windowActors
)
{
windowActor
-
>
StartDestroy
(
)
;
}
RefPtr
<
BrowserChild
>
browserChild
=
GetBrowserChild
(
)
;
if
(
!
browserChild
|
|
!
browserChild
-
>
IsDestroyed
(
)
)
{
SendDestroy
(
)
;
}
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvMakeFrameLocal
(
dom
:
:
BrowsingContext
*
aFrameContext
uint64_t
aPendingSwitchId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_LOG
(
aFrameContext
-
>
GetLog
(
)
LogLevel
:
:
Debug
(
"
RecvMakeFrameLocal
ID
=
%
"
PRIx64
aFrameContext
-
>
Id
(
)
)
)
;
RefPtr
<
Element
>
embedderElt
=
aFrameContext
-
>
GetEmbedderElement
(
)
;
if
(
NS_WARN_IF
(
!
embedderElt
)
)
{
return
IPC_OK
(
)
;
}
if
(
NS_WARN_IF
(
embedderElt
-
>
GetOwnerGlobal
(
)
!
=
WindowGlobal
(
)
)
)
{
return
IPC_OK
(
)
;
}
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
embedderElt
)
;
MOZ_DIAGNOSTIC_ASSERT
(
flo
"
Embedder
must
be
a
nsFrameLoaderOwner
"
)
;
RemotenessOptions
options
;
options
.
mRemoteType
.
Assign
(
VoidString
(
)
)
;
options
.
mPendingSwitchID
.
Construct
(
aPendingSwitchId
)
;
flo
-
>
ChangeRemoteness
(
options
IgnoreErrors
(
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvMakeFrameRemote
(
dom
:
:
BrowsingContext
*
aFrameContext
ManagedEndpoint
<
PBrowserBridgeChild
>
&
&
aEndpoint
const
TabId
&
aTabId
MakeFrameRemoteResolver
&
&
aResolve
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_LOG
(
aFrameContext
-
>
GetLog
(
)
LogLevel
:
:
Debug
(
"
RecvMakeFrameRemote
ID
=
%
"
PRIx64
aFrameContext
-
>
Id
(
)
)
)
;
aResolve
(
true
)
;
RefPtr
<
BrowserBridgeChild
>
bridge
=
new
BrowserBridgeChild
(
aFrameContext
aTabId
)
;
RefPtr
<
BrowserChild
>
manager
=
GetBrowserChild
(
)
;
if
(
NS_WARN_IF
(
!
manager
-
>
BindPBrowserBridgeEndpoint
(
std
:
:
move
(
aEndpoint
)
bridge
)
)
)
{
return
IPC_OK
(
)
;
}
RefPtr
<
Element
>
embedderElt
=
aFrameContext
-
>
GetEmbedderElement
(
)
;
if
(
NS_WARN_IF
(
!
embedderElt
)
)
{
BrowserBridgeChild
:
:
Send__delete__
(
bridge
)
;
return
IPC_OK
(
)
;
}
if
(
NS_WARN_IF
(
embedderElt
-
>
GetOwnerGlobal
(
)
!
=
WindowGlobal
(
)
)
)
{
BrowserBridgeChild
:
:
Send__delete__
(
bridge
)
;
return
IPC_OK
(
)
;
}
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
embedderElt
)
;
MOZ_DIAGNOSTIC_ASSERT
(
flo
"
Embedder
must
be
a
nsFrameLoaderOwner
"
)
;
IgnoredErrorResult
rv
;
flo
-
>
ChangeRemotenessWithBridge
(
bridge
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
BrowserBridgeChild
:
:
Send__delete__
(
bridge
)
;
return
IPC_OK
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvDrawSnapshot
(
const
Maybe
<
IntRect
>
&
aRect
const
float
&
aScale
const
nscolor
&
aBackgroundColor
const
uint32_t
&
aFlags
DrawSnapshotResolver
&
&
aResolve
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
BrowsingContext
(
)
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
aResolve
(
gfx
:
:
PaintFragment
{
}
)
;
return
IPC_OK
(
)
;
}
aResolve
(
gfx
:
:
PaintFragment
:
:
Record
(
docShell
aRect
aScale
aBackgroundColor
(
gfx
:
:
CrossProcessPaintFlags
)
aFlags
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvGetSecurityInfo
(
GetSecurityInfoResolver
&
&
aResolve
)
{
Maybe
<
nsCString
>
result
;
if
(
nsCOMPtr
<
Document
>
doc
=
mWindowGlobal
-
>
GetDoc
(
)
)
{
nsCOMPtr
<
nsISupports
>
secInfo
;
nsresult
rv
=
NS_OK
;
if
(
nsIChannel
*
failedChannel
=
doc
-
>
GetFailedChannel
(
)
)
{
rv
=
failedChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
secInfo
)
)
;
}
else
{
secInfo
=
doc
-
>
GetSecurityInfo
(
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
secInfo
)
{
nsCOMPtr
<
nsISerializable
>
secInfoSer
=
do_QueryInterface
(
secInfo
)
;
result
.
emplace
(
)
;
NS_SerializeToString
(
secInfoSer
result
.
ref
(
)
)
;
}
}
aResolve
(
result
)
;
return
IPC_OK
(
)
;
}
IPCResult
WindowGlobalChild
:
:
RecvRawMessage
(
const
JSWindowActorMessageMeta
&
aMeta
const
ClonedMessageData
&
aData
const
ClonedMessageData
&
aStack
)
{
StructuredCloneData
data
;
data
.
BorrowFromClonedMessageDataForChild
(
aData
)
;
StructuredCloneData
stack
;
stack
.
BorrowFromClonedMessageDataForChild
(
aStack
)
;
ReceiveRawMessage
(
aMeta
std
:
:
move
(
data
)
std
:
:
move
(
stack
)
)
;
return
IPC_OK
(
)
;
}
void
WindowGlobalChild
:
:
ReceiveRawMessage
(
const
JSWindowActorMessageMeta
&
aMeta
StructuredCloneData
&
&
aData
StructuredCloneData
&
&
aStack
)
{
RefPtr
<
JSWindowActorChild
>
actor
=
GetActor
(
aMeta
.
actorName
(
)
IgnoreErrors
(
)
)
;
if
(
actor
)
{
actor
-
>
ReceiveRawMessage
(
aMeta
std
:
:
move
(
aData
)
std
:
:
move
(
aStack
)
)
;
}
}
void
WindowGlobalChild
:
:
SetDocumentURI
(
nsIURI
*
aDocumentURI
)
{
#
ifdef
MOZ_GECKO_PROFILER
uint64_t
embedderInnerWindowID
=
0
;
if
(
mBrowsingContext
-
>
GetParent
(
)
)
{
embedderInnerWindowID
=
mBrowsingContext
-
>
GetEmbedderInnerWindowId
(
)
;
}
profiler_register_page
(
mBrowsingContext
-
>
Id
(
)
mInnerWindowId
aDocumentURI
-
>
GetSpecOrDefault
(
)
embedderInnerWindowID
)
;
#
endif
mDocumentURI
=
aDocumentURI
;
SendUpdateDocumentURI
(
aDocumentURI
)
;
}
const
nsAString
&
WindowGlobalChild
:
:
GetRemoteType
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
ContentChild
:
:
GetSingleton
(
)
-
>
GetRemoteType
(
)
;
}
return
VoidString
(
)
;
}
already_AddRefed
<
JSWindowActorChild
>
WindowGlobalChild
:
:
GetActor
(
const
nsAString
&
aName
ErrorResult
&
aRv
)
{
if
(
!
CanSend
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mWindowActors
.
Contains
(
aName
)
)
{
return
do_AddRef
(
mWindowActors
.
GetWeak
(
aName
)
)
;
}
JS
:
:
RootedObject
obj
(
RootingCx
(
)
)
;
ConstructActor
(
aName
&
obj
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
JSWindowActorChild
>
actor
;
if
(
NS_FAILED
(
UNWRAP_OBJECT
(
JSWindowActorChild
&
obj
actor
)
)
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
!
actor
-
>
GetManager
(
)
"
mManager
was
already
initialized
once
!
"
)
;
actor
-
>
Init
(
aName
this
)
;
mWindowActors
.
Put
(
aName
actor
)
;
return
actor
.
forget
(
)
;
}
void
WindowGlobalChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
gWindowGlobalChildById
-
>
Remove
(
mInnerWindowId
)
;
#
ifdef
MOZ_GECKO_PROFILER
profiler_unregister_page
(
mInnerWindowId
)
;
#
endif
nsRefPtrHashtable
<
nsStringHashKey
JSWindowActorChild
>
windowActors
;
mWindowActors
.
SwapElements
(
windowActors
)
;
for
(
auto
iter
=
windowActors
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
RejectPendingQueries
(
)
;
iter
.
Data
(
)
-
>
AfterDestroy
(
)
;
}
windowActors
.
Clear
(
)
;
}
WindowGlobalChild
:
:
~
WindowGlobalChild
(
)
{
MOZ_ASSERT
(
!
gWindowGlobalChildById
|
|
!
gWindowGlobalChildById
-
>
Contains
(
mInnerWindowId
)
)
;
MOZ_ASSERT
(
!
mWindowActors
.
Count
(
)
)
;
}
JSObject
*
WindowGlobalChild
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WindowGlobalChild_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsISupports
*
WindowGlobalChild
:
:
GetParentObject
(
)
{
return
xpc
:
:
NativeGlobal
(
xpc
:
:
PrivilegedJunkScope
(
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
WindowGlobalChild
mWindowGlobal
mBrowsingContext
mWindowActors
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WindowGlobalChild
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WindowGlobalChild
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WindowGlobalChild
)
}
}
