#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
AntiTrackingUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
MozFrameLoaderOwnerBinding
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
SecurityPolicyViolationEvent
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalActorsBinding
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
ipc
/
InProcessChild
.
h
"
#
include
"
mozilla
/
ipc
/
InProcessParent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
#
include
"
mozilla
/
dom
/
JSActorService
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIURIMutator
.
h
"
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
dom
:
:
ipc
;
namespace
mozilla
{
namespace
dom
{
typedef
nsRefPtrHashtable
<
nsUint64HashKey
WindowGlobalChild
>
WGCByIdMap
;
static
StaticAutoPtr
<
WGCByIdMap
>
gWindowGlobalChildById
;
WindowGlobalChild
:
:
WindowGlobalChild
(
dom
:
:
WindowContext
*
aWindowContext
nsIPrincipal
*
aPrincipal
nsIURI
*
aDocumentURI
)
:
mWindowContext
(
aWindowContext
)
mDocumentPrincipal
(
aPrincipal
)
mDocumentURI
(
aDocumentURI
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWindowContext
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mDocumentPrincipal
)
;
if
(
!
mDocumentURI
)
{
NS_NewURI
(
getter_AddRefs
(
mDocumentURI
)
"
about
:
blank
"
)
;
}
#
ifdef
MOZ_GECKO_PROFILER
uint64_t
embedderInnerWindowID
=
0
;
if
(
BrowsingContext
(
)
-
>
GetParent
(
)
)
{
embedderInnerWindowID
=
BrowsingContext
(
)
-
>
GetEmbedderInnerWindowId
(
)
;
}
profiler_register_page
(
BrowsingContext
(
)
-
>
Id
(
)
InnerWindowId
(
)
aDocumentURI
-
>
GetSpecOrDefault
(
)
embedderInnerWindowID
)
;
#
endif
}
already_AddRefed
<
WindowGlobalChild
>
WindowGlobalChild
:
:
Create
(
nsGlobalWindowInner
*
aWindow
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsCOMPtr
<
nsIChannel
>
chan
=
aWindow
-
>
GetDocument
(
)
-
>
GetChannel
(
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
?
chan
-
>
LoadInfo
(
)
:
nullptr
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChan
=
do_QueryInterface
(
chan
)
;
nsILoadInfo
:
:
CrossOriginOpenerPolicy
policy
;
if
(
httpChan
&
&
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
&
&
NS_SUCCEEDED
(
httpChan
-
>
GetCrossOriginOpenerPolicy
(
&
policy
)
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
policy
=
=
aWindow
-
>
GetBrowsingContext
(
)
-
>
GetOpenerPolicy
(
)
)
;
}
#
endif
WindowGlobalInit
init
=
WindowGlobalActor
:
:
WindowInitializer
(
aWindow
)
;
RefPtr
<
WindowGlobalChild
>
wgc
=
CreateDisconnected
(
init
)
;
if
(
XRE_IsParentProcess
(
)
)
{
InProcessChild
*
ipChild
=
InProcessChild
:
:
Singleton
(
)
;
InProcessParent
*
ipParent
=
InProcessParent
:
:
Singleton
(
)
;
if
(
!
ipChild
|
|
!
ipParent
)
{
return
nullptr
;
}
ManagedEndpoint
<
PWindowGlobalParent
>
endpoint
=
ipChild
-
>
OpenPWindowGlobalEndpoint
(
wgc
)
;
ipParent
-
>
BindPWindowGlobalEndpoint
(
std
:
:
move
(
endpoint
)
wgc
-
>
WindowContext
(
)
-
>
Canonical
(
)
)
;
}
else
{
RefPtr
<
BrowserChild
>
browserChild
=
BrowserChild
:
:
GetFrom
(
static_cast
<
mozIDOMWindow
*
>
(
aWindow
)
)
;
MOZ_ASSERT
(
browserChild
)
;
ManagedEndpoint
<
PWindowGlobalParent
>
endpoint
=
browserChild
-
>
OpenPWindowGlobalEndpoint
(
wgc
)
;
browserChild
-
>
SendNewWindowGlobal
(
std
:
:
move
(
endpoint
)
init
)
;
}
wgc
-
>
Init
(
)
;
wgc
-
>
InitWindowGlobal
(
aWindow
)
;
return
wgc
.
forget
(
)
;
}
already_AddRefed
<
WindowGlobalChild
>
WindowGlobalChild
:
:
CreateDisconnected
(
const
WindowGlobalInit
&
aInit
)
{
RefPtr
<
dom
:
:
BrowsingContext
>
browsingContext
=
dom
:
:
BrowsingContext
:
:
Get
(
aInit
.
context
(
)
.
mBrowsingContextId
)
;
RefPtr
<
dom
:
:
WindowContext
>
windowContext
=
dom
:
:
WindowContext
:
:
GetById
(
aInit
.
context
(
)
.
mInnerWindowId
)
;
MOZ_RELEASE_ASSERT
(
!
windowContext
"
Creating
duplicate
WindowContext
"
)
;
if
(
XRE_IsParentProcess
(
)
)
{
windowContext
=
WindowGlobalParent
:
:
CreateDisconnected
(
aInit
true
)
;
}
else
{
dom
:
:
WindowContext
:
:
FieldTuple
fields
=
aInit
.
context
(
)
.
mFields
;
windowContext
=
new
dom
:
:
WindowContext
(
browsingContext
aInit
.
context
(
)
.
mInnerWindowId
aInit
.
context
(
)
.
mOuterWindowId
true
std
:
:
move
(
fields
)
)
;
}
RefPtr
<
WindowGlobalChild
>
windowChild
=
new
WindowGlobalChild
(
windowContext
aInit
.
principal
(
)
aInit
.
documentURI
(
)
)
;
return
windowChild
.
forget
(
)
;
}
void
WindowGlobalChild
:
:
Init
(
)
{
mWindowContext
-
>
Init
(
)
;
if
(
!
gWindowGlobalChildById
)
{
gWindowGlobalChildById
=
new
WGCByIdMap
(
)
;
ClearOnShutdown
(
&
gWindowGlobalChildById
)
;
}
auto
entry
=
gWindowGlobalChildById
-
>
LookupForAdd
(
InnerWindowId
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
entry
"
Duplicate
WindowGlobalChild
entry
for
ID
!
"
)
;
entry
.
OrInsert
(
[
&
]
{
return
this
;
}
)
;
}
void
WindowGlobalChild
:
:
InitWindowGlobal
(
nsGlobalWindowInner
*
aWindow
)
{
mWindowGlobal
=
aWindow
;
}
void
WindowGlobalChild
:
:
OnNewDocument
(
Document
*
aDocument
)
{
MOZ_RELEASE_ASSERT
(
mWindowGlobal
)
;
MOZ_RELEASE_ASSERT
(
aDocument
)
;
SetDocumentURI
(
aDocument
-
>
GetDocumentURI
(
)
)
;
SetDocumentPrincipal
(
aDocument
-
>
NodePrincipal
(
)
)
;
nsCOMPtr
<
nsITransportSecurityInfo
>
securityInfo
;
if
(
nsCOMPtr
<
nsIChannel
>
channel
=
aDocument
-
>
GetChannel
(
)
)
{
nsCOMPtr
<
nsISupports
>
securityInfoSupports
;
channel
-
>
GetSecurityInfo
(
getter_AddRefs
(
securityInfoSupports
)
)
;
securityInfo
=
do_QueryInterface
(
securityInfoSupports
)
;
}
SendUpdateDocumentSecurityInfo
(
securityInfo
)
;
SendUpdateDocumentCspSettings
(
aDocument
-
>
GetBlockAllMixedContent
(
false
)
aDocument
-
>
GetUpgradeInsecureRequests
(
false
)
)
;
SendUpdateSandboxFlags
(
aDocument
-
>
GetSandboxFlags
(
)
)
;
net
:
:
CookieJarSettingsArgs
csArgs
;
net
:
:
CookieJarSettings
:
:
Cast
(
aDocument
-
>
CookieJarSettings
(
)
)
-
>
Serialize
(
csArgs
)
;
if
(
!
SendUpdateCookieJarSettings
(
csArgs
)
)
{
NS_WARNING
(
"
Failed
to
update
document
'
s
cookie
jar
settings
on
the
"
"
WindowGlobalParent
"
)
;
}
SendUpdateHttpsOnlyStatus
(
aDocument
-
>
HttpsOnlyStatus
(
)
)
;
WindowContext
:
:
Transaction
txn
;
txn
.
SetCookieBehavior
(
Some
(
aDocument
-
>
CookieJarSettings
(
)
-
>
GetCookieBehavior
(
)
)
)
;
txn
.
SetIsOnContentBlockingAllowList
(
aDocument
-
>
CookieJarSettings
(
)
-
>
GetIsOnContentBlockingAllowList
(
)
)
;
txn
.
SetIsThirdPartyWindow
(
aDocument
-
>
HasThirdPartyChannel
(
)
)
;
txn
.
SetIsThirdPartyTrackingResourceWindow
(
nsContentUtils
:
:
IsThirdPartyTrackingResourceWindow
(
mWindowGlobal
)
)
;
txn
.
SetIsSecureContext
(
mWindowGlobal
-
>
IsSecureContext
(
)
)
;
auto
policy
=
aDocument
-
>
GetEmbedderPolicyFromHTTP
(
)
;
if
(
policy
.
isSome
(
)
)
{
txn
.
SetEmbedderPolicy
(
policy
.
ref
(
)
)
;
}
nsCOMPtr
<
nsIURI
>
innerDocURI
=
NS_GetInnermostURI
(
aDocument
-
>
GetDocumentURI
(
)
)
;
if
(
innerDocURI
)
{
txn
.
SetIsSecure
(
innerDocURI
-
>
SchemeIs
(
"
https
"
)
)
;
}
nsCOMPtr
<
nsIChannel
>
mixedChannel
;
mWindowGlobal
-
>
GetDocShell
(
)
-
>
GetMixedContentChannel
(
getter_AddRefs
(
mixedChannel
)
)
;
if
(
mixedChannel
&
&
(
mixedChannel
=
=
aDocument
-
>
GetChannel
(
)
)
)
{
txn
.
SetAllowMixedContent
(
true
)
;
}
txn
.
Commit
(
mWindowContext
)
;
}
already_AddRefed
<
WindowGlobalChild
>
WindowGlobalChild
:
:
GetByInnerWindowId
(
uint64_t
aInnerWindowId
)
{
if
(
!
gWindowGlobalChildById
)
{
return
nullptr
;
}
return
gWindowGlobalChildById
-
>
Get
(
aInnerWindowId
)
;
}
dom
:
:
BrowsingContext
*
WindowGlobalChild
:
:
BrowsingContext
(
)
{
return
mWindowContext
-
>
GetBrowsingContext
(
)
;
}
uint64_t
WindowGlobalChild
:
:
InnerWindowId
(
)
{
return
mWindowContext
-
>
InnerWindowId
(
)
;
}
uint64_t
WindowGlobalChild
:
:
OuterWindowId
(
)
{
return
mWindowContext
-
>
OuterWindowId
(
)
;
}
bool
WindowGlobalChild
:
:
IsCurrentGlobal
(
)
{
return
CanSend
(
)
&
&
mWindowGlobal
-
>
IsCurrentInnerWindow
(
)
;
}
already_AddRefed
<
WindowGlobalParent
>
WindowGlobalChild
:
:
GetParentActor
(
)
{
if
(
!
CanSend
(
)
)
{
return
nullptr
;
}
IProtocol
*
otherSide
=
InProcessChild
:
:
ParentActorFor
(
this
)
;
return
do_AddRef
(
static_cast
<
WindowGlobalParent
*
>
(
otherSide
)
)
;
}
already_AddRefed
<
BrowserChild
>
WindowGlobalChild
:
:
GetBrowserChild
(
)
{
if
(
IsInProcess
(
)
|
|
!
CanSend
(
)
)
{
return
nullptr
;
}
return
do_AddRef
(
static_cast
<
BrowserChild
*
>
(
Manager
(
)
)
)
;
}
uint64_t
WindowGlobalChild
:
:
ContentParentId
(
)
{
if
(
XRE_IsParentProcess
(
)
)
{
return
0
;
}
return
ContentChild
:
:
GetSingleton
(
)
-
>
GetID
(
)
;
}
bool
WindowGlobalChild
:
:
IsProcessRoot
(
)
{
if
(
!
BrowsingContext
(
)
-
>
GetParent
(
)
)
{
return
true
;
}
return
!
BrowsingContext
(
)
-
>
GetEmbedderElement
(
)
;
}
void
WindowGlobalChild
:
:
BeforeUnloadAdded
(
)
{
if
(
mBeforeUnloadListeners
=
=
0
&
&
CanSend
(
)
)
{
SendSetHasBeforeUnload
(
true
)
;
}
mBeforeUnloadListeners
+
+
;
MOZ_ASSERT
(
mBeforeUnloadListeners
>
0
)
;
}
void
WindowGlobalChild
:
:
BeforeUnloadRemoved
(
)
{
mBeforeUnloadListeners
-
-
;
MOZ_ASSERT
(
mBeforeUnloadListeners
>
=
0
)
;
if
(
mBeforeUnloadListeners
=
=
0
&
&
CanSend
(
)
)
{
SendSetHasBeforeUnload
(
false
)
;
}
}
void
WindowGlobalChild
:
:
Destroy
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
WindowGlobalChild
:
:
Destroy
"
[
self
=
RefPtr
<
WindowGlobalChild
>
(
this
)
]
(
)
{
nsTArray
<
RefPtr
<
JSWindowActorChild
>
>
windowActors
(
self
-
>
mWindowActors
.
Count
(
)
)
;
for
(
auto
iter
=
self
-
>
mWindowActors
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
windowActors
.
AppendElement
(
iter
.
UserData
(
)
)
;
}
for
(
auto
&
windowActor
:
windowActors
)
{
windowActor
-
>
StartDestroy
(
)
;
}
RefPtr
<
BrowserChild
>
browserChild
=
self
-
>
GetBrowserChild
(
)
;
if
(
!
browserChild
|
|
!
browserChild
-
>
IsDestroyed
(
)
)
{
self
-
>
SendDestroy
(
)
;
}
}
)
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvMakeFrameLocal
(
const
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
&
aFrameContext
uint64_t
aPendingSwitchId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_LOG
(
BrowsingContext
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
RecvMakeFrameLocal
ID
=
%
"
PRIx64
aFrameContext
.
ContextId
(
)
)
)
;
if
(
NS_WARN_IF
(
aFrameContext
.
IsNullOrDiscarded
(
)
)
)
{
return
IPC_OK
(
)
;
}
dom
:
:
BrowsingContext
*
frameContext
=
aFrameContext
.
get
(
)
;
RefPtr
<
Element
>
embedderElt
=
frameContext
-
>
GetEmbedderElement
(
)
;
if
(
NS_WARN_IF
(
!
embedderElt
)
)
{
return
IPC_OK
(
)
;
}
if
(
NS_WARN_IF
(
embedderElt
-
>
GetOwnerGlobal
(
)
!
=
GetWindowGlobal
(
)
)
)
{
return
IPC_OK
(
)
;
}
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
embedderElt
)
;
MOZ_DIAGNOSTIC_ASSERT
(
flo
"
Embedder
must
be
a
nsFrameLoaderOwner
"
)
;
RemotenessOptions
options
;
options
.
mRemoteType
.
Assign
(
VoidString
(
)
)
;
options
.
mPendingSwitchID
.
Construct
(
aPendingSwitchId
)
;
options
.
mSwitchingInProgressLoad
=
true
;
flo
-
>
ChangeRemoteness
(
options
IgnoreErrors
(
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvMakeFrameRemote
(
const
MaybeDiscarded
<
dom
:
:
BrowsingContext
>
&
aFrameContext
ManagedEndpoint
<
PBrowserBridgeChild
>
&
&
aEndpoint
const
TabId
&
aTabId
const
LayersId
&
aLayersId
MakeFrameRemoteResolver
&
&
aResolve
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_LOG
(
BrowsingContext
:
:
GetLog
(
)
LogLevel
:
:
Debug
(
"
RecvMakeFrameRemote
ID
=
%
"
PRIx64
aFrameContext
.
ContextId
(
)
)
)
;
aResolve
(
true
)
;
if
(
!
aLayersId
.
IsValid
(
)
)
{
return
IPC_FAIL
(
this
"
Received
an
invalid
LayersId
"
)
;
}
RefPtr
<
dom
:
:
BrowsingContext
>
frameContext
;
if
(
!
aFrameContext
.
IsDiscarded
(
)
)
{
frameContext
=
aFrameContext
.
get
(
)
;
}
RefPtr
<
BrowserBridgeChild
>
bridge
=
new
BrowserBridgeChild
(
frameContext
aTabId
aLayersId
)
;
RefPtr
<
BrowserChild
>
manager
=
GetBrowserChild
(
)
;
if
(
NS_WARN_IF
(
!
manager
-
>
BindPBrowserBridgeEndpoint
(
std
:
:
move
(
aEndpoint
)
bridge
)
)
)
{
return
IPC_OK
(
)
;
}
if
(
NS_WARN_IF
(
aFrameContext
.
IsNullOrDiscarded
(
)
)
)
{
BrowserBridgeChild
:
:
Send__delete__
(
bridge
)
;
return
IPC_OK
(
)
;
}
RefPtr
<
Element
>
embedderElt
=
frameContext
-
>
GetEmbedderElement
(
)
;
if
(
NS_WARN_IF
(
!
embedderElt
)
)
{
BrowserBridgeChild
:
:
Send__delete__
(
bridge
)
;
return
IPC_OK
(
)
;
}
if
(
NS_WARN_IF
(
embedderElt
-
>
GetOwnerGlobal
(
)
!
=
GetWindowGlobal
(
)
)
)
{
BrowserBridgeChild
:
:
Send__delete__
(
bridge
)
;
return
IPC_OK
(
)
;
}
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
embedderElt
)
;
MOZ_DIAGNOSTIC_ASSERT
(
flo
"
Embedder
must
be
a
nsFrameLoaderOwner
"
)
;
IgnoredErrorResult
rv
;
flo
-
>
ChangeRemotenessWithBridge
(
bridge
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
BrowserBridgeChild
:
:
Send__delete__
(
bridge
)
;
return
IPC_OK
(
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvDrawSnapshot
(
const
Maybe
<
IntRect
>
&
aRect
const
float
&
aScale
const
nscolor
&
aBackgroundColor
const
uint32_t
&
aFlags
DrawSnapshotResolver
&
&
aResolve
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
BrowsingContext
(
)
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
aResolve
(
gfx
:
:
PaintFragment
{
}
)
;
return
IPC_OK
(
)
;
}
aResolve
(
gfx
:
:
PaintFragment
:
:
Record
(
docShell
aRect
aScale
aBackgroundColor
(
gfx
:
:
CrossProcessPaintFlags
)
aFlags
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvGetSecurityInfo
(
GetSecurityInfoResolver
&
&
aResolve
)
{
Maybe
<
nsCString
>
result
;
if
(
nsCOMPtr
<
Document
>
doc
=
mWindowGlobal
-
>
GetDoc
(
)
)
{
nsCOMPtr
<
nsISupports
>
secInfo
;
nsresult
rv
=
NS_OK
;
if
(
nsIChannel
*
failedChannel
=
doc
-
>
GetFailedChannel
(
)
)
{
rv
=
failedChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
secInfo
)
)
;
}
else
{
secInfo
=
doc
-
>
GetSecurityInfo
(
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
secInfo
)
{
nsCOMPtr
<
nsISerializable
>
secInfoSer
=
do_QueryInterface
(
secInfo
)
;
result
.
emplace
(
)
;
NS_SerializeToString
(
secInfoSer
result
.
ref
(
)
)
;
}
}
aResolve
(
result
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvSaveStorageAccessPermissionGranted
(
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
GetWindowGlobal
(
)
;
if
(
inner
)
{
inner
-
>
SaveStorageAccessPermissionGranted
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
inner
)
;
if
(
outer
)
{
nsGlobalWindowOuter
:
:
Cast
(
outer
)
-
>
SetStorageAccessPermissionGranted
(
true
)
;
}
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvDispatchSecurityPolicyViolation
(
const
nsString
&
aViolationEventJSON
)
{
nsGlobalWindowInner
*
window
=
GetWindowGlobal
(
)
;
if
(
!
window
)
{
return
IPC_OK
(
)
;
}
Document
*
doc
=
window
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
IPC_OK
(
)
;
}
SecurityPolicyViolationEventInit
violationEvent
;
if
(
!
violationEvent
.
Init
(
aViolationEventJSON
)
)
{
return
IPC_OK
(
)
;
}
RefPtr
<
Event
>
event
=
SecurityPolicyViolationEvent
:
:
Constructor
(
doc
NS_LITERAL_STRING
(
"
securitypolicyviolation
"
)
violationEvent
)
;
event
-
>
SetTrusted
(
true
)
;
doc
-
>
DispatchEvent
(
*
event
IgnoreErrors
(
)
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
WindowGlobalChild
:
:
RecvAddBlockedFrameNodeByClassifier
(
const
MaybeDiscardedBrowsingContext
&
aNode
)
{
if
(
aNode
.
IsNullOrDiscarded
(
)
)
{
return
IPC_OK
(
)
;
}
nsGlobalWindowInner
*
window
=
GetWindowGlobal
(
)
;
if
(
!
window
)
{
return
IPC_OK
(
)
;
}
Document
*
doc
=
window
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
IPC_OK
(
)
;
}
MOZ_ASSERT
(
aNode
.
get
(
)
-
>
GetEmbedderElement
(
)
-
>
OwnerDoc
(
)
=
=
doc
)
;
doc
-
>
AddBlockedNodeByClassifier
(
aNode
.
get
(
)
-
>
GetEmbedderElement
(
)
)
;
return
IPC_OK
(
)
;
}
IPCResult
WindowGlobalChild
:
:
RecvRawMessage
(
const
JSActorMessageMeta
&
aMeta
const
ClonedMessageData
&
aData
const
ClonedMessageData
&
aStack
)
{
StructuredCloneData
data
;
data
.
BorrowFromClonedMessageDataForChild
(
aData
)
;
StructuredCloneData
stack
;
stack
.
BorrowFromClonedMessageDataForChild
(
aStack
)
;
ReceiveRawMessage
(
aMeta
std
:
:
move
(
data
)
std
:
:
move
(
stack
)
)
;
return
IPC_OK
(
)
;
}
void
WindowGlobalChild
:
:
ReceiveRawMessage
(
const
JSActorMessageMeta
&
aMeta
StructuredCloneData
&
&
aData
StructuredCloneData
&
&
aStack
)
{
RefPtr
<
JSWindowActorChild
>
actor
=
GetActor
(
aMeta
.
actorName
(
)
IgnoreErrors
(
)
)
;
if
(
actor
)
{
actor
-
>
ReceiveRawMessage
(
aMeta
std
:
:
move
(
aData
)
std
:
:
move
(
aStack
)
)
;
}
}
void
WindowGlobalChild
:
:
SetDocumentURI
(
nsIURI
*
aDocumentURI
)
{
#
ifdef
MOZ_GECKO_PROFILER
uint64_t
embedderInnerWindowID
=
0
;
if
(
BrowsingContext
(
)
-
>
GetParent
(
)
)
{
embedderInnerWindowID
=
BrowsingContext
(
)
-
>
GetEmbedderInnerWindowId
(
)
;
}
profiler_register_page
(
BrowsingContext
(
)
-
>
Id
(
)
InnerWindowId
(
)
aDocumentURI
-
>
GetSpecOrDefault
(
)
embedderInnerWindowID
)
;
#
endif
mDocumentURI
=
aDocumentURI
;
SendUpdateDocumentURI
(
aDocumentURI
)
;
}
void
WindowGlobalChild
:
:
SetDocumentPrincipal
(
nsIPrincipal
*
aNewDocumentPrincipal
)
{
MOZ_ASSERT
(
mDocumentPrincipal
-
>
Equals
(
aNewDocumentPrincipal
)
)
;
mDocumentPrincipal
=
aNewDocumentPrincipal
;
SendUpdateDocumentPrincipal
(
aNewDocumentPrincipal
)
;
}
const
nsAString
&
WindowGlobalChild
:
:
GetRemoteType
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
ContentChild
:
:
GetSingleton
(
)
-
>
GetRemoteType
(
)
;
}
return
VoidString
(
)
;
}
already_AddRefed
<
JSWindowActorChild
>
WindowGlobalChild
:
:
GetActor
(
const
nsACString
&
aName
ErrorResult
&
aRv
)
{
if
(
!
CanSend
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mWindowActors
.
Contains
(
aName
)
)
{
return
do_AddRef
(
mWindowActors
.
GetWeak
(
aName
)
)
;
}
JS
:
:
RootedObject
obj
(
RootingCx
(
)
)
;
ConstructActor
(
aName
&
obj
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
JSWindowActorChild
>
actor
;
if
(
NS_FAILED
(
UNWRAP_OBJECT
(
JSWindowActorChild
&
obj
actor
)
)
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
!
actor
-
>
GetManager
(
)
"
mManager
was
already
initialized
once
!
"
)
;
actor
-
>
Init
(
aName
this
)
;
mWindowActors
.
Put
(
aName
RefPtr
{
actor
}
)
;
return
actor
.
forget
(
)
;
}
void
WindowGlobalChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Destroying
WindowGlobalChild
can
run
script
"
)
;
gWindowGlobalChildById
-
>
Remove
(
InnerWindowId
(
)
)
;
#
ifdef
MOZ_GECKO_PROFILER
profiler_unregister_page
(
InnerWindowId
(
)
)
;
#
endif
nsRefPtrHashtable
<
nsCStringHashKey
JSWindowActorChild
>
windowActors
;
mWindowActors
.
SwapElements
(
windowActors
)
;
for
(
auto
iter
=
windowActors
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
RejectPendingQueries
(
)
;
iter
.
Data
(
)
-
>
AfterDestroy
(
)
;
}
windowActors
.
Clear
(
)
;
}
WindowGlobalChild
:
:
~
WindowGlobalChild
(
)
{
MOZ_ASSERT
(
!
gWindowGlobalChildById
|
|
!
gWindowGlobalChildById
-
>
Contains
(
InnerWindowId
(
)
)
)
;
MOZ_ASSERT
(
!
mWindowActors
.
Count
(
)
)
;
}
JSObject
*
WindowGlobalChild
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WindowGlobalChild_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsISupports
*
WindowGlobalChild
:
:
GetParentObject
(
)
{
return
xpc
:
:
NativeGlobal
(
xpc
:
:
PrivilegedJunkScope
(
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
WindowGlobalChild
mWindowGlobal
mWindowActors
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WindowGlobalChild
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
WindowGlobalChild
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
WindowGlobalChild
)
}
}
