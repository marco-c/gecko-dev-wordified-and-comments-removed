#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
MozFrameLoaderOwnerBinding
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalActorsBinding
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
ipc
/
InProcessChild
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorService
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
dom
:
:
ipc
;
namespace
mozilla
{
namespace
dom
{
typedef
nsRefPtrHashtable
<
nsUint64HashKey
WindowGlobalChild
>
WGCByIdMap
;
static
StaticAutoPtr
<
WGCByIdMap
>
gWindowGlobalChildById
;
WindowGlobalChild
:
:
WindowGlobalChild
(
nsGlobalWindowInner
*
aWindow
dom
:
:
BrowsingContext
*
aBrowsingContext
)
:
mWindowGlobal
(
aWindow
)
mBrowsingContext
(
aBrowsingContext
)
mInnerWindowId
(
aWindow
-
>
WindowID
(
)
)
mOuterWindowId
(
aWindow
-
>
GetOuterWindow
(
)
-
>
WindowID
(
)
)
mIPCClosed
(
true
)
{
}
already_AddRefed
<
WindowGlobalChild
>
WindowGlobalChild
:
:
Create
(
nsGlobalWindowInner
*
aWindow
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aWindow
-
>
GetPrincipal
(
)
;
MOZ_ASSERT
(
principal
)
;
RefPtr
<
nsDocShell
>
docshell
=
nsDocShell
:
:
Cast
(
aWindow
-
>
GetDocShell
(
)
)
;
MOZ_ASSERT
(
docshell
)
;
RefPtr
<
dom
:
:
BrowsingContext
>
bc
=
docshell
-
>
GetBrowsingContext
(
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
chan
=
do_QueryInterface
(
aWindow
-
>
GetDocument
(
)
-
>
GetChannel
(
)
)
;
nsILoadInfo
:
:
CrossOriginOpenerPolicy
policy
;
if
(
chan
&
&
NS_SUCCEEDED
(
chan
-
>
GetCrossOriginOpenerPolicy
(
&
policy
)
)
)
{
bc
-
>
SetOpenerPolicy
(
policy
)
;
}
RefPtr
<
WindowGlobalChild
>
wgc
=
new
WindowGlobalChild
(
aWindow
bc
)
;
if
(
bc
-
>
GetClosed
(
)
)
{
wgc
-
>
ActorDestroy
(
FailedConstructor
)
;
return
wgc
.
forget
(
)
;
}
WindowGlobalInit
init
(
principal
aWindow
-
>
GetDocumentURI
(
)
bc
wgc
-
>
mInnerWindowId
wgc
-
>
mOuterWindowId
)
;
if
(
XRE_IsParentProcess
(
)
)
{
InProcessChild
*
ipc
=
InProcessChild
:
:
Singleton
(
)
;
if
(
!
ipc
)
{
return
nullptr
;
}
ipc
-
>
SendPWindowGlobalConstructor
(
do_AddRef
(
wgc
)
.
take
(
)
init
)
;
}
else
{
RefPtr
<
TabChild
>
tabChild
=
TabChild
:
:
GetFrom
(
static_cast
<
mozIDOMWindow
*
>
(
aWindow
)
)
;
MOZ_ASSERT
(
tabChild
)
;
tabChild
-
>
SendPWindowGlobalConstructor
(
do_AddRef
(
wgc
)
.
take
(
)
init
)
;
}
wgc
-
>
mIPCClosed
=
false
;
if
(
!
gWindowGlobalChildById
)
{
gWindowGlobalChildById
=
new
WGCByIdMap
(
)
;
ClearOnShutdown
(
&
gWindowGlobalChildById
)
;
}
auto
entry
=
gWindowGlobalChildById
-
>
LookupForAdd
(
wgc
-
>
mInnerWindowId
)
;
MOZ_RELEASE_ASSERT
(
!
entry
"
Duplicate
WindowGlobalChild
entry
for
ID
!
"
)
;
entry
.
OrInsert
(
[
&
]
{
return
wgc
;
}
)
;
return
wgc
.
forget
(
)
;
}
already_AddRefed
<
WindowGlobalChild
>
WindowGlobalChild
:
:
GetByInnerWindowId
(
uint64_t
aInnerWindowId
)
{
if
(
!
gWindowGlobalChildById
)
{
return
nullptr
;
}
return
gWindowGlobalChildById
-
>
Get
(
aInnerWindowId
)
;
}
bool
WindowGlobalChild
:
:
IsCurrentGlobal
(
)
{
return
!
mIPCClosed
&
&
mWindowGlobal
-
>
IsCurrentInnerWindow
(
)
;
}
already_AddRefed
<
WindowGlobalParent
>
WindowGlobalChild
:
:
GetParentActor
(
)
{
if
(
mIPCClosed
)
{
return
nullptr
;
}
IProtocol
*
otherSide
=
InProcessChild
:
:
ParentActorFor
(
this
)
;
return
do_AddRef
(
static_cast
<
WindowGlobalParent
*
>
(
otherSide
)
)
;
}
already_AddRefed
<
TabChild
>
WindowGlobalChild
:
:
GetTabChild
(
)
{
if
(
IsInProcess
(
)
|
|
mIPCClosed
)
{
return
nullptr
;
}
return
do_AddRef
(
static_cast
<
TabChild
*
>
(
Manager
(
)
)
)
;
}
void
WindowGlobalChild
:
:
Destroy
(
)
{
RefPtr
<
TabChild
>
tabChild
=
GetTabChild
(
)
;
if
(
!
tabChild
|
|
!
tabChild
-
>
IsDestroyed
(
)
)
{
SendDestroy
(
)
;
}
mIPCClosed
=
true
;
}
static
nsresult
ChangeFrameRemoteness
(
WindowGlobalChild
*
aWgc
BrowsingContext
*
aBc
const
nsString
&
aRemoteType
uint64_t
aPendingSwitchId
BrowserBridgeChild
*
*
aBridge
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
"
This
doesn
'
t
make
sense
in
the
parent
"
)
;
RefPtr
<
Element
>
embedderElt
=
aBc
-
>
GetEmbedderElement
(
)
;
if
(
!
embedderElt
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
NS_WARN_IF
(
embedderElt
-
>
GetOwnerGlobal
(
)
!
=
aWgc
-
>
WindowGlobal
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
embedderElt
)
;
MOZ_ASSERT
(
flo
"
Embedder
must
be
a
nsFrameLoaderOwner
!
"
)
;
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
RemotenessOptions
options
;
options
.
mRemoteType
.
Construct
(
aRemoteType
)
;
options
.
mPendingSwitchID
.
Construct
(
aPendingSwitchId
)
;
ErrorResult
error
;
flo
-
>
ChangeRemoteness
(
options
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
RefPtr
<
nsFrameLoader
>
frameLoader
=
flo
-
>
GetFrameLoader
(
)
;
if
(
NS_WARN_IF
(
!
frameLoader
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
BrowserBridgeChild
>
bbc
;
if
(
frameLoader
-
>
IsRemoteFrame
(
)
)
{
bbc
=
frameLoader
-
>
GetBrowserBridgeChild
(
)
;
if
(
NS_WARN_IF
(
!
bbc
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
nsDocShell
*
ds
=
frameLoader
-
>
GetDocShell
(
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
if
(
NS_WARN_IF
(
!
ds
)
)
{
return
NS_ERROR_FAILURE
;
}
}
bbc
.
forget
(
aBridge
)
;
return
NS_OK
;
}
IPCResult
WindowGlobalChild
:
:
RecvChangeFrameRemoteness
(
dom
:
:
BrowsingContext
*
aBc
const
nsString
&
aRemoteType
uint64_t
aPendingSwitchId
ChangeFrameRemotenessResolver
&
&
aResolver
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
"
This
doesn
'
t
make
sense
in
the
parent
"
)
;
RefPtr
<
BrowserBridgeChild
>
bbc
;
nsresult
rv
=
ChangeFrameRemoteness
(
this
aBc
aRemoteType
aPendingSwitchId
getter_AddRefs
(
bbc
)
)
;
aResolver
(
Tuple
<
const
nsresult
&
PBrowserBridgeChild
*
>
(
rv
bbc
)
)
;
return
IPC_OK
(
)
;
}
IPCResult
WindowGlobalChild
:
:
RecvRawMessage
(
const
JSWindowActorMessageMeta
&
aMeta
const
ClonedMessageData
&
aData
)
{
StructuredCloneData
data
;
data
.
BorrowFromClonedMessageDataForChild
(
aData
)
;
ReceiveRawMessage
(
aMeta
std
:
:
move
(
data
)
)
;
return
IPC_OK
(
)
;
}
void
WindowGlobalChild
:
:
ReceiveRawMessage
(
const
JSWindowActorMessageMeta
&
aMeta
StructuredCloneData
&
&
aData
)
{
RefPtr
<
JSWindowActorChild
>
actor
=
GetActor
(
aMeta
.
actorName
(
)
IgnoreErrors
(
)
)
;
if
(
actor
)
{
actor
-
>
ReceiveRawMessage
(
aMeta
std
:
:
move
(
aData
)
)
;
}
}
already_AddRefed
<
JSWindowActorChild
>
WindowGlobalChild
:
:
GetActor
(
const
nsAString
&
aName
ErrorResult
&
aRv
)
{
if
(
mIPCClosed
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
mWindowActors
.
Contains
(
aName
)
)
{
return
do_AddRef
(
mWindowActors
.
GetWeak
(
aName
)
)
;
}
RefPtr
<
JSWindowActorService
>
actorSvc
=
JSWindowActorService
:
:
GetSingleton
(
)
;
if
(
!
actorSvc
)
{
return
nullptr
;
}
nsAutoString
remoteType
;
if
(
XRE_IsContentProcess
(
)
)
{
remoteType
=
ContentChild
:
:
GetSingleton
(
)
-
>
GetRemoteType
(
)
;
}
else
{
remoteType
=
VoidString
(
)
;
}
JS
:
:
RootedObject
obj
(
RootingCx
(
)
)
;
actorSvc
-
>
ConstructActor
(
aName
false
mBrowsingContext
mWindowGlobal
-
>
GetDocumentURI
(
)
remoteType
&
obj
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
JSWindowActorChild
>
actor
;
if
(
NS_FAILED
(
UNWRAP_OBJECT
(
JSWindowActorChild
&
obj
actor
)
)
)
{
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
!
actor
-
>
Manager
(
)
"
mManager
was
already
initialized
once
!
"
)
;
actor
-
>
Init
(
aName
this
)
;
mWindowActors
.
Put
(
aName
actor
)
;
return
actor
.
forget
(
)
;
}
void
WindowGlobalChild
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
mIPCClosed
=
true
;
gWindowGlobalChildById
-
>
Remove
(
mInnerWindowId
)
;
nsRefPtrHashtable
<
nsStringHashKey
JSWindowActorChild
>
windowActors
;
mWindowActors
.
SwapElements
(
windowActors
)
;
for
(
auto
iter
=
windowActors
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
RejectPendingQueries
(
)
;
}
}
WindowGlobalChild
:
:
~
WindowGlobalChild
(
)
{
MOZ_ASSERT
(
!
gWindowGlobalChildById
|
|
!
gWindowGlobalChildById
-
>
Contains
(
mInnerWindowId
)
)
;
}
JSObject
*
WindowGlobalChild
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
WindowGlobalChild_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsISupports
*
WindowGlobalChild
:
:
GetParentObject
(
)
{
return
xpc
:
:
NativeGlobal
(
xpc
:
:
PrivilegedJunkScope
(
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
WindowGlobalChild
mWindowGlobal
mBrowsingContext
mWindowActors
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
WindowGlobalChild
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
WindowGlobalChild
Release
)
}
}
