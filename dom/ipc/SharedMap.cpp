#
include
"
SharedMap
.
h
"
#
include
"
MemMapSnapshot
.
h
"
#
include
"
ScriptPreloader
-
inl
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ProcessGlobal
.
h
"
using
namespace
mozilla
:
:
loader
;
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
namespace
ipc
{
constexpr
size_t
kStructuredCloneAlign
=
sizeof
(
uintptr_t
)
;
static
inline
void
AlignTo
(
size_t
*
aOffset
size_t
aAlign
)
{
if
(
auto
mod
=
*
aOffset
%
aAlign
)
{
*
aOffset
+
=
aAlign
-
mod
;
}
}
SharedMap
:
:
SharedMap
(
)
{
}
SharedMap
:
:
SharedMap
(
nsIGlobalObject
*
aGlobal
const
FileDescriptor
&
aMapFile
size_t
aMapSize
)
{
mMapFile
.
reset
(
new
FileDescriptor
(
aMapFile
)
)
;
mMapSize
=
aMapSize
;
}
bool
SharedMap
:
:
Has
(
const
nsACString
&
aName
)
{
return
mEntries
.
Contains
(
aName
)
;
}
void
SharedMap
:
:
Get
(
JSContext
*
aCx
const
nsACString
&
aName
JS
:
:
MutableHandleValue
aRetVal
ErrorResult
&
aRv
)
{
auto
res
=
MaybeRebuild
(
)
;
if
(
res
.
isErr
(
)
)
{
aRv
.
Throw
(
res
.
unwrapErr
(
)
)
;
return
;
}
Entry
*
entry
=
mEntries
.
Get
(
aName
)
;
if
(
!
entry
)
{
aRetVal
.
setNull
(
)
;
return
;
}
entry
-
>
Read
(
aCx
aRetVal
aRv
)
;
}
void
SharedMap
:
:
Entry
:
:
Read
(
JSContext
*
aCx
JS
:
:
MutableHandleValue
aRetVal
ErrorResult
&
aRv
)
{
if
(
mData
.
is
<
StructuredCloneData
>
(
)
)
{
auto
&
holder
=
mData
.
as
<
StructuredCloneData
>
(
)
;
holder
.
Read
(
aCx
aRetVal
aRv
)
;
return
;
}
StructuredCloneData
holder
;
if
(
!
holder
.
CopyExternalData
(
Data
(
)
Size
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
holder
.
Read
(
aCx
aRetVal
aRv
)
;
}
FileDescriptor
SharedMap
:
:
CloneMapFile
(
)
{
if
(
mMap
.
initialized
(
)
)
{
return
mMap
.
cloneHandle
(
)
;
}
return
*
mMapFile
;
}
void
SharedMap
:
:
Update
(
const
FileDescriptor
&
aMapFile
size_t
aMapSize
nsTArray
<
nsCString
>
&
&
aChangedKeys
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mWritable
)
;
mMap
.
reset
(
)
;
if
(
mMapFile
)
{
*
mMapFile
=
aMapFile
;
}
else
{
mMapFile
.
reset
(
new
FileDescriptor
(
aMapFile
)
)
;
}
mMapSize
=
aMapSize
;
mEntries
.
Clear
(
)
;
}
void
SharedMap
:
:
Entry
:
:
TakeData
(
StructuredCloneData
&
&
aHolder
)
{
mData
=
AsVariant
(
std
:
:
move
(
aHolder
)
)
;
mSize
=
Holder
(
)
.
Data
(
)
.
Size
(
)
;
}
void
SharedMap
:
:
Entry
:
:
ExtractData
(
char
*
aDestPtr
uint32_t
aNewOffset
)
{
if
(
mData
.
is
<
StructuredCloneData
>
(
)
)
{
char
*
ptr
=
aDestPtr
;
Holder
(
)
.
Data
(
)
.
ForEachDataChunk
(
[
&
]
(
const
char
*
aData
size_t
aSize
)
{
memcpy
(
ptr
aData
aSize
)
;
ptr
+
=
aSize
;
return
true
;
}
)
;
MOZ_ASSERT
(
ptr
-
aDestPtr
=
=
mSize
)
;
}
else
{
memcpy
(
aDestPtr
Data
(
)
mSize
)
;
}
mData
=
AsVariant
(
aNewOffset
)
;
}
Result
<
Ok
nsresult
>
SharedMap
:
:
MaybeRebuild
(
)
{
if
(
!
mMapFile
)
{
return
Ok
(
)
;
}
MOZ_TRY
(
mMap
.
initWithHandle
(
*
mMapFile
mMapSize
)
)
;
mMapFile
.
reset
(
)
;
Range
<
uint8_t
>
range
(
&
mMap
.
get
<
uint8_t
>
(
)
[
0
]
mMap
.
size
(
)
)
;
InputBuffer
buffer
(
range
)
;
uint32_t
count
;
buffer
.
codeUint32
(
count
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
auto
entry
=
MakeUnique
<
Entry
>
(
*
this
)
;
entry
-
>
Code
(
buffer
)
;
MOZ_RELEASE_ASSERT
(
!
buffer
.
error
(
)
)
;
mEntries
.
Put
(
entry
-
>
Name
(
)
entry
.
get
(
)
)
;
Unused
<
<
entry
.
release
(
)
;
}
return
Ok
(
)
;
}
void
SharedMap
:
:
MaybeRebuild
(
)
const
{
Unused
<
<
const_cast
<
SharedMap
*
>
(
this
)
-
>
MaybeRebuild
(
)
;
}
WritableSharedMap
:
:
WritableSharedMap
(
)
:
SharedMap
(
)
{
mWritable
=
true
;
Unused
<
<
Serialize
(
)
;
MOZ_RELEASE_ASSERT
(
mMap
.
initialized
(
)
)
;
}
SharedMap
*
WritableSharedMap
:
:
GetReadOnly
(
)
{
if
(
!
mReadOnly
)
{
mReadOnly
=
new
SharedMap
(
ProcessGlobal
:
:
Get
(
)
CloneMapFile
(
)
MapSize
(
)
)
;
}
return
mReadOnly
;
}
Result
<
Ok
nsresult
>
WritableSharedMap
:
:
Serialize
(
)
{
uint32_t
count
=
mEntries
.
Count
(
)
;
size_t
dataSize
=
0
;
size_t
headerSize
=
sizeof
(
count
)
;
for
(
auto
&
entry
:
IterHash
(
mEntries
)
)
{
headerSize
+
=
entry
-
>
HeaderSize
(
)
;
dataSize
+
=
entry
-
>
Size
(
)
;
AlignTo
(
&
dataSize
kStructuredCloneAlign
)
;
}
size_t
offset
=
headerSize
;
AlignTo
(
&
offset
kStructuredCloneAlign
)
;
OutputBuffer
header
;
header
.
codeUint32
(
count
)
;
MemMapSnapshot
mem
;
MOZ_TRY
(
mem
.
Init
(
offset
+
dataSize
)
)
;
auto
ptr
=
mem
.
Get
<
char
>
(
)
;
for
(
auto
&
entry
:
IterHash
(
mEntries
)
)
{
AlignTo
(
&
offset
kStructuredCloneAlign
)
;
entry
-
>
ExtractData
(
&
ptr
[
offset
]
offset
)
;
entry
-
>
Code
(
header
)
;
offset
+
=
entry
-
>
Size
(
)
;
}
memcpy
(
ptr
.
get
(
)
header
.
Get
(
)
header
.
cursor
(
)
)
;
mMap
.
reset
(
)
;
MOZ_RELEASE_ASSERT
(
mem
.
Finalize
(
mMap
)
.
isOk
(
)
)
;
return
Ok
(
)
;
}
void
WritableSharedMap
:
:
BroadcastChanges
(
)
{
if
(
mChangedKeys
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
Serialize
(
)
.
isOk
(
)
)
{
return
;
}
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
for
(
auto
&
parent
:
parents
)
{
Unused
<
<
parent
-
>
SendUpdateSharedData
(
CloneMapFile
(
)
mMap
.
size
(
)
mChangedKeys
)
;
}
if
(
mReadOnly
)
{
mReadOnly
-
>
Update
(
CloneMapFile
(
)
mMap
.
size
(
)
std
:
:
move
(
mChangedKeys
)
)
;
}
mChangedKeys
.
Clear
(
)
;
}
void
WritableSharedMap
:
:
Delete
(
const
nsACString
&
aName
)
{
if
(
mEntries
.
Remove
(
aName
)
)
{
KeyChanged
(
aName
)
;
}
}
void
WritableSharedMap
:
:
Set
(
JSContext
*
aCx
const
nsACString
&
aName
JS
:
:
HandleValue
aValue
ErrorResult
&
aRv
)
{
StructuredCloneData
holder
;
holder
.
Write
(
aCx
aValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
holder
.
BlobImpls
(
)
.
IsEmpty
(
)
|
|
!
holder
.
InputStreams
(
)
.
IsEmpty
(
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
Entry
*
entry
=
mEntries
.
LookupOrAdd
(
aName
*
this
aName
)
;
entry
-
>
TakeData
(
std
:
:
move
(
holder
)
)
;
KeyChanged
(
aName
)
;
}
void
WritableSharedMap
:
:
Flush
(
)
{
BroadcastChanges
(
)
;
}
void
WritableSharedMap
:
:
KeyChanged
(
const
nsACString
&
aName
)
{
if
(
!
mChangedKeys
.
ContainsSorted
(
aName
)
)
{
mChangedKeys
.
InsertElementSorted
(
aName
)
;
}
}
NS_IMPL_ISUPPORTS0
(
SharedMap
)
}
}
}
