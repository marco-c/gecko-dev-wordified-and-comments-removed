#
include
"
SharedMap
.
h
"
#
include
"
MemMapSnapshot
.
h
"
#
include
"
ScriptPreloader
-
inl
.
h
"
#
include
"
SharedMapChangeEvent
.
h
"
#
include
"
mozilla
/
IOBuffers
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ScriptPreloader
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
"
mozilla
/
dom
/
AutoEntryScript
.
h
"
#
include
"
mozilla
/
dom
/
BlobImpl
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
IPCBlobUtils
.
h
"
#
include
"
mozilla
/
dom
/
RootedDictionary
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
using
namespace
mozilla
:
:
loader
;
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
:
:
ipc
{
constexpr
size_t
kStructuredCloneAlign
=
sizeof
(
uintptr_t
)
;
static
inline
void
AlignTo
(
size_t
*
aOffset
size_t
aAlign
)
{
if
(
auto
mod
=
*
aOffset
%
aAlign
)
{
*
aOffset
+
=
aAlign
-
mod
;
}
}
SharedMap
:
:
SharedMap
(
)
=
default
;
SharedMap
:
:
SharedMap
(
nsIGlobalObject
*
aGlobal
SharedMemoryHandle
&
&
aMapHandle
nsTArray
<
RefPtr
<
BlobImpl
>
>
&
&
aBlobs
)
:
DOMEventTargetHelper
(
aGlobal
)
mBlobImpls
(
std
:
:
move
(
aBlobs
)
)
mHandle
(
std
:
:
move
(
aMapHandle
)
)
{
}
bool
SharedMap
:
:
Has
(
const
nsACString
&
aName
)
{
Unused
<
<
MaybeRebuild
(
)
;
return
mEntries
.
Contains
(
aName
)
;
}
void
SharedMap
:
:
Get
(
JSContext
*
aCx
const
nsACString
&
aName
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
aRv
)
{
auto
res
=
MaybeRebuild
(
)
;
if
(
res
.
isErr
(
)
)
{
aRv
.
Throw
(
res
.
unwrapErr
(
)
)
;
return
;
}
Entry
*
entry
=
mEntries
.
Get
(
aName
)
;
if
(
!
entry
)
{
aRetVal
.
setNull
(
)
;
return
;
}
entry
-
>
Read
(
aCx
aRetVal
aRv
)
;
}
void
SharedMap
:
:
Entry
:
:
Read
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
aRv
)
{
if
(
mData
.
is
<
UniquePtr
<
StructuredCloneData
>
>
(
)
)
{
auto
&
holder
=
mData
.
as
<
UniquePtr
<
StructuredCloneData
>
>
(
)
;
holder
-
>
Read
(
aCx
aRetVal
aRv
)
;
return
;
}
StructuredCloneData
holder
;
if
(
!
holder
.
CopyExternalData
(
Data
(
)
Size
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
mBlobCount
)
{
holder
.
BlobImpls
(
)
.
AppendElements
(
Blobs
(
)
)
;
}
holder
.
Read
(
aCx
aRetVal
aRv
)
;
}
void
SharedMap
:
:
Update
(
SharedMemoryHandle
&
&
aMapHandle
nsTArray
<
RefPtr
<
BlobImpl
>
>
&
&
aBlobs
nsTArray
<
nsCString
>
&
&
aChangedKeys
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mWritable
)
;
mMapping
=
nullptr
;
mHandle
=
std
:
:
move
(
aMapHandle
)
;
mEntries
.
Clear
(
)
;
mEntryArray
.
reset
(
)
;
mBlobImpls
=
std
:
:
move
(
aBlobs
)
;
AutoEntryScript
aes
(
GetParentObject
(
)
"
SharedMap
change
event
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
RootedDictionary
<
MozSharedMapChangeEventInit
>
init
(
cx
)
;
if
(
!
init
.
mChangedKeys
.
SetCapacity
(
aChangedKeys
.
Length
(
)
fallible
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
SharedMap
change
event
"
)
;
return
;
}
for
(
auto
&
key
:
aChangedKeys
)
{
Unused
<
<
init
.
mChangedKeys
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
key
)
fallible
)
;
}
RefPtr
<
SharedMapChangeEvent
>
event
=
SharedMapChangeEvent
:
:
Constructor
(
this
u
"
change
"
_ns
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchEvent
(
*
event
)
;
}
const
nsTArray
<
SharedMap
:
:
Entry
*
>
&
SharedMap
:
:
EntryArray
(
)
const
{
if
(
mEntryArray
.
isNothing
(
)
)
{
MaybeRebuild
(
)
;
mEntryArray
.
emplace
(
mEntries
.
Count
(
)
)
;
auto
&
array
=
mEntryArray
.
ref
(
)
;
for
(
auto
&
entry
:
mEntries
)
{
array
.
AppendElement
(
entry
.
GetWeak
(
)
)
;
}
}
return
mEntryArray
.
ref
(
)
;
}
const
nsString
SharedMap
:
:
GetKeyAtIndex
(
uint32_t
aIndex
)
const
{
return
NS_ConvertUTF8toUTF16
(
EntryArray
(
)
[
aIndex
]
-
>
Name
(
)
)
;
}
bool
SharedMap
:
:
GetValueAtIndex
(
JSContext
*
aCx
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
const
{
ErrorResult
rv
;
EntryArray
(
)
[
aIndex
]
-
>
Read
(
aCx
aResult
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
aCx
)
)
{
return
false
;
}
return
true
;
}
void
SharedMap
:
:
Entry
:
:
TakeData
(
UniquePtr
<
StructuredCloneData
>
aHolder
)
{
mData
=
AsVariant
(
std
:
:
move
(
aHolder
)
)
;
mSize
=
Holder
(
)
.
Data
(
)
.
Size
(
)
;
mBlobCount
=
Holder
(
)
.
BlobImpls
(
)
.
Length
(
)
;
}
void
SharedMap
:
:
Entry
:
:
ExtractData
(
char
*
aDestPtr
uint32_t
aNewOffset
uint16_t
aNewBlobOffset
)
{
if
(
mData
.
is
<
UniquePtr
<
StructuredCloneData
>
>
(
)
)
{
char
*
ptr
=
aDestPtr
;
Holder
(
)
.
Data
(
)
.
ForEachDataChunk
(
[
&
]
(
const
char
*
aData
size_t
aSize
)
{
memcpy
(
ptr
aData
aSize
)
;
ptr
+
=
aSize
;
return
true
;
}
)
;
MOZ_ASSERT
(
uint32_t
(
ptr
-
aDestPtr
)
=
=
mSize
)
;
}
else
{
memcpy
(
aDestPtr
Data
(
)
mSize
)
;
}
mData
=
AsVariant
(
aNewOffset
)
;
mBlobOffset
=
aNewBlobOffset
;
}
Result
<
Ok
nsresult
>
SharedMap
:
:
MaybeRebuild
(
)
{
if
(
mMapping
|
|
!
mHandle
)
{
return
Ok
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mWritable
)
;
mMapping
=
mHandle
.
Map
(
)
;
if
(
!
mMapping
)
{
return
Err
(
NS_ERROR_FAILURE
)
;
}
mHandle
=
nullptr
;
Range
<
const
uint8_t
>
inputRange
(
mMapping
.
DataAsSpan
<
uint8_t
>
(
)
)
;
InputBuffer
buffer
(
inputRange
)
;
uint32_t
count
;
buffer
.
codeUint32
(
count
)
;
MOZ_ASSERT
(
mEntries
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mEntryArray
.
isNothing
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
auto
entry
=
MakeUnique
<
Entry
>
(
*
this
)
;
entry
-
>
Code
(
buffer
)
;
MOZ_RELEASE_ASSERT
(
!
buffer
.
error
(
)
)
;
const
auto
&
name
=
entry
-
>
Name
(
)
;
mEntries
.
InsertOrUpdate
(
name
std
:
:
move
(
entry
)
)
;
}
return
Ok
(
)
;
}
void
SharedMap
:
:
MaybeRebuild
(
)
const
{
Unused
<
<
const_cast
<
SharedMap
*
>
(
this
)
-
>
MaybeRebuild
(
)
;
}
WritableSharedMap
:
:
WritableSharedMap
(
)
{
mWritable
=
true
;
Unused
<
<
Serialize
(
)
;
MOZ_RELEASE_ASSERT
(
mHandle
.
IsValid
(
)
&
&
mMapping
.
IsValid
(
)
)
;
}
SharedMap
*
WritableSharedMap
:
:
GetReadOnly
(
)
{
if
(
!
mReadOnly
)
{
nsTArray
<
RefPtr
<
BlobImpl
>
>
blobs
(
mBlobImpls
.
Clone
(
)
)
;
mReadOnly
=
new
SharedMap
(
ContentProcessMessageManager
:
:
Get
(
)
-
>
GetParentObject
(
)
mHandle
.
Clone
(
)
std
:
:
move
(
blobs
)
)
;
}
return
mReadOnly
;
}
Result
<
Ok
nsresult
>
WritableSharedMap
:
:
Serialize
(
)
{
uint32_t
count
=
mEntries
.
Count
(
)
;
size_t
dataSize
=
0
;
size_t
headerSize
=
sizeof
(
count
)
;
size_t
blobCount
=
0
;
for
(
const
auto
&
entry
:
mEntries
.
Values
(
)
)
{
headerSize
+
=
entry
-
>
HeaderSize
(
)
;
blobCount
+
=
entry
-
>
BlobCount
(
)
;
dataSize
+
=
entry
-
>
Size
(
)
;
AlignTo
(
&
dataSize
kStructuredCloneAlign
)
;
}
size_t
offset
=
headerSize
;
AlignTo
(
&
offset
kStructuredCloneAlign
)
;
OutputBuffer
header
;
header
.
codeUint32
(
count
)
;
MemMapSnapshot
mem
;
MOZ_TRY
(
mem
.
Init
(
offset
+
dataSize
)
)
;
auto
ptr
=
mem
.
Get
<
char
>
(
)
;
nsTArray
<
RefPtr
<
BlobImpl
>
>
blobImpls
(
blobCount
)
;
for
(
const
auto
&
entry
:
mEntries
.
Values
(
)
)
{
AlignTo
(
&
offset
kStructuredCloneAlign
)
;
size_t
blobOffset
=
blobImpls
.
Length
(
)
;
if
(
entry
-
>
BlobCount
(
)
)
{
blobImpls
.
AppendElements
(
entry
-
>
Blobs
(
)
)
;
}
entry
-
>
ExtractData
(
&
ptr
[
offset
]
offset
blobOffset
)
;
entry
-
>
Code
(
header
)
;
offset
+
=
entry
-
>
Size
(
)
;
}
mBlobImpls
=
std
:
:
move
(
blobImpls
)
;
MOZ_ASSERT
(
header
.
cursor
(
)
=
=
headerSize
)
;
memcpy
(
ptr
.
get
(
)
header
.
Get
(
)
header
.
cursor
(
)
)
;
auto
result
=
mem
.
Finalize
(
)
;
MOZ_RELEASE_ASSERT
(
result
.
isOk
(
)
)
;
mHandle
=
result
.
unwrap
(
)
;
mMapping
=
mHandle
.
Map
(
)
;
MOZ_RELEASE_ASSERT
(
mMapping
.
IsValid
(
)
)
;
return
Ok
(
)
;
}
void
WritableSharedMap
:
:
SendTo
(
ContentParent
*
aParent
)
const
{
nsTArray
<
IPCBlob
>
blobs
(
mBlobImpls
.
Length
(
)
)
;
for
(
auto
&
blobImpl
:
mBlobImpls
)
{
nsresult
rv
=
IPCBlobUtils
:
:
Serialize
(
blobImpl
*
blobs
.
AppendElement
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
}
Unused
<
<
aParent
-
>
SendUpdateSharedData
(
mHandle
.
Clone
(
)
blobs
mChangedKeys
)
;
}
void
WritableSharedMap
:
:
BroadcastChanges
(
)
{
if
(
mChangedKeys
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
Serialize
(
)
.
isOk
(
)
)
{
return
;
}
nsTArray
<
ContentParent
*
>
parents
;
ContentParent
:
:
GetAll
(
parents
)
;
for
(
auto
&
parent
:
parents
)
{
SendTo
(
parent
)
;
}
if
(
mReadOnly
)
{
nsTArray
<
RefPtr
<
BlobImpl
>
>
blobImpls
(
mBlobImpls
.
Clone
(
)
)
;
mReadOnly
-
>
Update
(
mHandle
.
Clone
(
)
std
:
:
move
(
blobImpls
)
std
:
:
move
(
mChangedKeys
)
)
;
}
mChangedKeys
.
Clear
(
)
;
}
void
WritableSharedMap
:
:
Delete
(
const
nsACString
&
aName
)
{
if
(
mEntries
.
Remove
(
aName
)
)
{
KeyChanged
(
aName
)
;
}
}
void
WritableSharedMap
:
:
Set
(
JSContext
*
aCx
const
nsACString
&
aName
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
auto
holder
=
MakeUnique
<
StructuredCloneData
>
(
)
;
holder
-
>
Write
(
aCx
aValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
holder
-
>
InputStreams
(
)
.
IsEmpty
(
)
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
Entry
*
entry
=
mEntries
.
GetOrInsertNew
(
aName
*
this
aName
)
;
entry
-
>
TakeData
(
std
:
:
move
(
holder
)
)
;
KeyChanged
(
aName
)
;
}
void
WritableSharedMap
:
:
Flush
(
)
{
BroadcastChanges
(
)
;
}
void
WritableSharedMap
:
:
IdleFlush
(
)
{
mPendingFlush
=
false
;
Flush
(
)
;
}
nsresult
WritableSharedMap
:
:
KeyChanged
(
const
nsACString
&
aName
)
{
if
(
!
mChangedKeys
.
ContainsSorted
(
aName
)
)
{
mChangedKeys
.
InsertElementSorted
(
aName
)
;
}
mEntryArray
.
reset
(
)
;
if
(
!
mPendingFlush
)
{
MOZ_TRY
(
NS_DispatchToCurrentThreadQueue
(
NewRunnableMethod
(
"
WritableSharedMap
:
:
IdleFlush
"
this
&
WritableSharedMap
:
:
IdleFlush
)
EventQueuePriority
:
:
Idle
)
)
;
mPendingFlush
=
true
;
}
return
NS_OK
;
}
JSObject
*
SharedMap
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MozSharedMap_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
JSObject
*
WritableSharedMap
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
MozWritableSharedMap_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
SharedMapChangeEvent
>
SharedMapChangeEvent
:
:
Constructor
(
EventTarget
*
aEventTarget
const
nsAString
&
aType
const
MozSharedMapChangeEventInit
&
aInit
)
{
RefPtr
<
SharedMapChangeEvent
>
event
=
new
SharedMapChangeEvent
(
aEventTarget
)
;
bool
trusted
=
event
-
>
Init
(
aEventTarget
)
;
event
-
>
InitEvent
(
aType
aInit
.
mBubbles
aInit
.
mCancelable
)
;
event
-
>
SetTrusted
(
trusted
)
;
event
-
>
SetComposed
(
aInit
.
mComposed
)
;
event
-
>
mChangedKeys
=
aInit
.
mChangedKeys
;
return
event
.
forget
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
WritableSharedMap
SharedMap
mReadOnly
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WritableSharedMap
)
NS_INTERFACE_MAP_END_INHERITING
(
SharedMap
)
NS_IMPL_ADDREF_INHERITED
(
WritableSharedMap
SharedMap
)
NS_IMPL_RELEASE_INHERITED
(
WritableSharedMap
SharedMap
)
}
}
