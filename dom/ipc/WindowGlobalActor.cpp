#
include
"
mozilla
/
dom
/
WindowGlobalActor
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozJSComponentLoader
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorService
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorParent
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
namespace
mozilla
{
namespace
dom
{
WindowGlobalInit
WindowGlobalActor
:
:
AboutBlankInitializer
(
dom
:
:
BrowsingContext
*
aBrowsingContext
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aBrowsingContext
)
;
MOZ_ASSERT
(
aPrincipal
)
;
nsCOMPtr
<
nsIURI
>
documentURI
;
Unused
<
<
NS_NewURI
(
getter_AddRefs
(
documentURI
)
"
about
:
blank
"
)
;
uint64_t
outerWindowId
=
nsContentUtils
:
:
GenerateWindowId
(
)
;
uint64_t
innerWindowId
=
nsContentUtils
:
:
GenerateWindowId
(
)
;
return
WindowGlobalInit
(
aPrincipal
documentURI
aBrowsingContext
innerWindowId
outerWindowId
)
;
}
void
WindowGlobalActor
:
:
ConstructActor
(
const
nsAString
&
aName
JS
:
:
MutableHandleObject
aActor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
JSWindowActor
:
:
Type
actorType
=
GetSide
(
)
;
MOZ_ASSERT_IF
(
actorType
=
=
JSWindowActor
:
:
Type
:
:
Parent
XRE_IsParentProcess
(
)
)
;
AutoEntryScript
aes
(
xpc
:
:
PrivilegedJunkScope
(
)
"
WindowGlobalActor
construction
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
RefPtr
<
JSWindowActorService
>
actorSvc
=
JSWindowActorService
:
:
GetSingleton
(
)
;
if
(
!
actorSvc
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
RefPtr
<
JSWindowActorProtocol
>
proto
=
actorSvc
-
>
GetProtocol
(
aName
)
;
if
(
!
proto
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
if
(
!
proto
-
>
Matches
(
BrowsingContext
(
)
GetDocumentURI
(
)
GetRemoteType
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
RefPtr
<
mozJSComponentLoader
>
loader
=
mozJSComponentLoader
:
:
Get
(
)
;
MOZ_ASSERT
(
loader
)
;
JS
:
:
RootedObject
global
(
cx
)
;
JS
:
:
RootedObject
exports
(
cx
)
;
const
JSWindowActorProtocol
:
:
Sided
*
side
;
if
(
actorType
=
=
JSWindowActor
:
:
Type
:
:
Parent
)
{
side
=
&
proto
-
>
Parent
(
)
;
}
else
{
side
=
&
proto
-
>
Child
(
)
;
}
if
(
!
side
-
>
mModuleURI
)
{
RefPtr
<
JSWindowActor
>
actor
;
if
(
actorType
=
=
JSWindowActor
:
:
Type
:
:
Parent
)
{
actor
=
new
JSWindowActorParent
(
)
;
}
else
{
actor
=
new
JSWindowActorChild
(
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
wrapper
(
cx
)
;
if
(
!
ToJSValue
(
cx
actor
&
wrapper
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
MOZ_ASSERT
(
wrapper
.
isObject
(
)
)
;
aActor
.
set
(
&
wrapper
.
toObject
(
)
)
;
return
;
}
aRv
=
loader
-
>
Import
(
cx
side
-
>
mModuleURI
.
ref
(
)
&
global
&
exports
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
exports
"
null
exports
!
"
)
;
JS
:
:
RootedValue
ctor
(
cx
)
;
nsAutoString
ctorName
(
aName
)
;
ctorName
.
Append
(
actorType
=
=
JSWindowActor
:
:
Type
:
:
Parent
?
NS_LITERAL_STRING
(
"
Parent
"
)
:
NS_LITERAL_STRING
(
"
Child
"
)
)
;
if
(
!
JS_GetUCProperty
(
cx
exports
ctorName
.
get
(
)
ctorName
.
Length
(
)
&
ctor
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
if
(
NS_WARN_IF
(
!
ctor
.
isObject
(
)
)
)
{
nsPrintfCString
message
(
"
Could
not
find
actor
constructor
'
%
s
'
"
NS_ConvertUTF16toUTF8
(
ctorName
)
.
get
(
)
)
;
aRv
.
ThrowNotFoundError
(
message
)
;
return
;
}
if
(
!
JS
:
:
Construct
(
cx
ctor
JS
:
:
HandleValueArray
:
:
empty
(
)
aActor
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
}
}
}
