#
ifndef
mozilla_dom_ipc_StructuredCloneData_h
#
define
mozilla_dom_ipc_StructuredCloneData_h
#
include
<
algorithm
>
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneHolder
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISupportsImpl
.
h
"
namespace
IPC
{
class
Message
;
class
MessageReader
;
class
MessageWriter
;
}
class
PickleIterator
;
namespace
mozilla
{
namespace
ipc
{
class
PBackgroundChild
;
class
PBackgroundParent
;
}
namespace
dom
{
class
ContentChild
;
class
ContentParent
;
namespace
ipc
{
class
SharedJSAllocatedData
final
{
public
:
explicit
SharedJSAllocatedData
(
JSStructuredCloneData
&
&
aData
)
:
mData
(
std
:
:
move
(
aData
)
)
{
}
static
already_AddRefed
<
SharedJSAllocatedData
>
CreateFromExternalData
(
const
char
*
aData
size_t
aDataLength
)
{
JSStructuredCloneData
buf
(
JS
:
:
StructuredCloneScope
:
:
DifferentProcess
)
;
NS_ENSURE_TRUE
(
buf
.
AppendBytes
(
aData
aDataLength
)
nullptr
)
;
RefPtr
<
SharedJSAllocatedData
>
sharedData
=
new
SharedJSAllocatedData
(
std
:
:
move
(
buf
)
)
;
return
sharedData
.
forget
(
)
;
}
static
already_AddRefed
<
SharedJSAllocatedData
>
CreateFromExternalData
(
const
JSStructuredCloneData
&
aData
)
{
JSStructuredCloneData
buf
(
aData
.
scope
(
)
)
;
NS_ENSURE_TRUE
(
buf
.
Append
(
aData
)
nullptr
)
;
RefPtr
<
SharedJSAllocatedData
>
sharedData
=
new
SharedJSAllocatedData
(
std
:
:
move
(
buf
)
)
;
return
sharedData
.
forget
(
)
;
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
SharedJSAllocatedData
)
JSStructuredCloneData
&
Data
(
)
{
return
mData
;
}
size_t
DataLength
(
)
const
{
return
mData
.
Size
(
)
;
}
private
:
~
SharedJSAllocatedData
(
)
=
default
;
JSStructuredCloneData
mData
;
}
;
class
StructuredCloneData
:
public
StructuredCloneHolder
{
public
:
StructuredCloneData
(
)
;
StructuredCloneData
(
const
StructuredCloneData
&
)
=
delete
;
StructuredCloneData
(
StructuredCloneData
&
&
aOther
)
;
StructuredCloneData
(
StructuredCloneScope
aScope
TransferringSupport
aSupportsTransferring
)
;
~
StructuredCloneData
(
)
;
StructuredCloneData
&
operator
=
(
const
StructuredCloneData
&
aOther
)
=
delete
;
StructuredCloneData
&
operator
=
(
StructuredCloneData
&
&
aOther
)
;
const
nsTArray
<
RefPtr
<
BlobImpl
>
>
&
BlobImpls
(
)
const
{
return
mBlobImplArray
;
}
nsTArray
<
RefPtr
<
BlobImpl
>
>
&
BlobImpls
(
)
{
return
mBlobImplArray
;
}
const
nsTArray
<
nsCOMPtr
<
nsIInputStream
>
>
&
InputStreams
(
)
const
{
return
mInputStreamArray
;
}
nsTArray
<
nsCOMPtr
<
nsIInputStream
>
>
&
InputStreams
(
)
{
return
mInputStreamArray
;
}
bool
Copy
(
const
StructuredCloneData
&
aData
)
;
void
Read
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
;
void
Read
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
const
JS
:
:
CloneDataPolicy
&
aCloneDataPolicy
ErrorResult
&
aRv
)
;
void
Write
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
void
Write
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfers
const
JS
:
:
CloneDataPolicy
&
aCloneDataPolicy
ErrorResult
&
aRv
)
override
;
bool
BuildClonedMessageData
(
ClonedMessageData
&
aClonedData
)
;
void
BorrowFromClonedMessageData
(
const
ClonedMessageData
&
aClonedData
)
;
void
CopyFromClonedMessageData
(
const
ClonedMessageData
&
aClonedData
)
;
void
StealFromClonedMessageData
(
ClonedMessageData
&
aClonedData
)
;
bool
UseExternalData
(
const
JSStructuredCloneData
&
aData
)
{
auto
iter
=
aData
.
Start
(
)
;
bool
success
=
false
;
mExternalData
=
aData
.
Borrow
(
iter
aData
.
Size
(
)
&
success
)
;
mInitialized
=
true
;
return
success
;
}
bool
CopyExternalData
(
const
char
*
aData
size_t
aDataLength
)
;
bool
CopyExternalData
(
const
JSStructuredCloneData
&
aData
)
;
bool
StealExternalData
(
JSStructuredCloneData
&
aData
)
;
JSStructuredCloneData
&
Data
(
)
{
return
mSharedData
?
mSharedData
-
>
Data
(
)
:
mExternalData
;
}
const
JSStructuredCloneData
&
Data
(
)
const
{
return
mSharedData
?
mSharedData
-
>
Data
(
)
:
mExternalData
;
}
void
InitScope
(
JS
:
:
StructuredCloneScope
aScope
)
{
Data
(
)
.
initScope
(
aScope
)
;
}
size_t
DataLength
(
)
const
{
return
mSharedData
?
mSharedData
-
>
DataLength
(
)
:
mExternalData
.
Size
(
)
;
}
SharedJSAllocatedData
*
SharedData
(
)
const
{
return
mSharedData
;
}
bool
SupportsTransferring
(
)
{
return
mSupportsTransferring
;
}
void
WriteIPCParams
(
IPC
:
:
MessageWriter
*
aWriter
)
const
;
bool
ReadIPCParams
(
IPC
:
:
MessageReader
*
aReader
)
;
protected
:
already_AddRefed
<
SharedJSAllocatedData
>
TakeSharedData
(
)
;
private
:
JSStructuredCloneData
mExternalData
;
RefPtr
<
SharedJSAllocatedData
>
mSharedData
;
bool
mInitialized
;
}
;
}
}
}
#
endif
