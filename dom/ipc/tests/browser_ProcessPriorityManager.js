"
use
strict
"
;
const
PRIORITY_SET_TOPIC
=
"
process
-
priority
-
manager
:
TEST
-
ONLY
:
process
-
priority
-
set
"
;
const
PROCESS_PRIORITY_FOREGROUND
=
"
FOREGROUND
"
;
const
PROCESS_PRIORITY_BACKGROUND_PERCEIVABLE
=
"
BACKGROUND_PERCEIVABLE
"
;
const
PROCESS_PRIORITY_BACKGROUND
=
"
BACKGROUND
"
;
const
WAIT_FOR_CHANGE_TIME_MS
=
2000
;
class
TabPriorityWatcher
{
constructor
(
tabbrowser
)
{
this
.
tabbrowser
=
tabbrowser
;
Assert
.
equal
(
tabbrowser
.
tabs
.
length
1
"
TabPriorityWatcher
must
be
constructed
in
a
window
"
+
"
with
a
single
tab
to
start
.
"
)
;
this
.
priorityMap
=
new
WeakMap
(
)
;
this
.
priorityMap
.
set
(
this
.
tabbrowser
.
selectedBrowser
PROCESS_PRIORITY_FOREGROUND
)
;
this
.
noChangeBrowsers
=
new
WeakMap
(
)
;
Services
.
obs
.
addObserver
(
this
PRIORITY_SET_TOPIC
)
;
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
PRIORITY_SET_TOPIC
)
;
this
.
window
=
null
;
}
async
waitForPriorityChange
(
browser
expectedPriority
)
{
return
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
currentPriority
=
this
.
priorityMap
.
get
(
browser
)
;
if
(
currentPriority
=
=
expectedPriority
)
{
Assert
.
ok
(
true
Browser
at
{
browser
.
currentURI
.
spec
}
reached
expected
+
priority
:
{
currentPriority
}
)
;
return
true
;
}
return
false
;
}
Waiting
for
browser
at
{
browser
.
currentURI
.
spec
}
to
reach
priority
+
expectedPriority
)
;
}
async
ensureNoPriorityChange
(
browser
)
{
this
.
noChangeBrowsers
.
set
(
browser
null
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
WAIT_FOR_CHANGE_TIME_MS
)
)
;
let
priority
=
this
.
noChangeBrowsers
.
get
(
browser
)
;
Assert
.
equal
(
priority
null
Should
have
seen
no
process
priority
change
for
a
browser
at
{
browser
.
currentURI
.
spec
}
)
;
this
.
noChangeBrowsers
.
delete
(
browser
)
;
}
ensureForegroundRegistered
(
browser
)
{
if
(
!
this
.
priorityMap
.
has
(
browser
)
)
{
this
.
priorityMap
.
set
(
browser
PROCESS_PRIORITY_FOREGROUND
)
;
}
}
currentPriority
(
browser
)
{
return
this
.
priorityMap
.
get
(
browser
)
;
}
parsePPMData
(
ppmDataString
)
{
let
[
childIDStr
priority
]
=
ppmDataString
.
split
(
"
:
"
)
;
return
{
childID
:
parseInt
(
childIDStr
10
)
priority
}
;
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
PRIORITY_SET_TOPIC
)
{
Assert
.
ok
(
false
"
TabPriorityWatcher
is
observing
the
wrong
topic
"
)
;
return
;
}
let
{
childID
priority
}
=
this
.
parsePPMData
(
data
)
;
for
(
let
browser
of
this
.
tabbrowser
.
browsers
)
{
if
(
browser
.
frameLoader
.
childID
=
=
childID
)
{
info
(
Browser
at
:
{
browser
.
currentURI
.
spec
}
transitioning
to
{
priority
}
)
;
if
(
this
.
noChangeBrowsers
.
has
(
browser
)
)
{
this
.
noChangeBrowsers
.
set
(
browser
priority
)
;
}
this
.
priorityMap
.
set
(
browser
priority
)
;
}
}
}
}
let
gTabPriorityWatcher
;
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processPriorityManager
.
testMode
"
true
]
[
"
dom
.
ipc
.
processPriorityManager
.
enabled
"
true
]
]
}
)
;
gTabPriorityWatcher
=
new
TabPriorityWatcher
(
gBrowser
)
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
gTabPriorityWatcher
.
destroy
(
)
;
gTabPriorityWatcher
=
null
;
}
)
;
async
function
assertPriorityChangeOnBackground
(
{
fromTab
toTab
fromTabExpectedPriority
}
)
{
let
fromBrowser
=
fromTab
.
linkedBrowser
;
let
toBrowser
=
toTab
.
linkedBrowser
;
Assert
.
notEqual
(
toBrowser
.
frameLoader
.
remoteTab
.
osPid
fromBrowser
.
frameLoader
.
remoteTab
.
osPid
"
Tabs
should
be
running
in
separate
processes
.
"
)
;
gTabPriorityWatcher
.
ensureForegroundRegistered
(
fromBrowser
)
;
let
fromPromise
;
if
(
gTabPriorityWatcher
.
currentPriority
(
fromBrowser
)
=
=
fromTabExpectedPriority
)
{
fromPromise
=
gTabPriorityWatcher
.
ensureNoPriorityChange
(
fromBrowser
)
;
}
else
{
fromPromise
=
gTabPriorityWatcher
.
waitForPriorityChange
(
fromBrowser
fromTabExpectedPriority
)
;
}
let
toPromise
;
if
(
gTabPriorityWatcher
.
currentPriority
(
toBrowser
)
=
=
PROCESS_PRIORITY_FOREGROUND
)
{
toPromise
=
gTabPriorityWatcher
.
ensureNoPriorityChange
(
toBrowser
)
;
}
else
{
toPromise
=
gTabPriorityWatcher
.
waitForPriorityChange
(
toBrowser
PROCESS_PRIORITY_FOREGROUND
)
;
}
await
BrowserTestUtils
.
switchTab
(
gBrowser
toTab
)
;
await
Promise
.
all
(
[
fromPromise
toPromise
]
)
;
}
add_task
(
async
function
test_normal_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
"
async
browser
=
>
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_video_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
"
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
video
=
content
.
document
.
createElement
(
"
video
"
)
;
video
.
src
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
dom
/
ipc
/
tests
/
short
.
mp4
"
;
video
.
muted
=
true
;
content
.
document
.
body
.
appendChild
(
video
)
;
video
.
loop
=
true
;
await
video
.
play
(
)
;
}
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND_PERCEIVABLE
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
video
=
content
.
document
.
querySelector
(
"
video
"
)
;
video
.
muted
=
false
;
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_FOREGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_audio_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
"
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
audio
=
content
.
document
.
createElement
(
"
audio
"
)
;
audio
.
src
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
dom
/
ipc
/
tests
/
owl
.
mp3
"
;
audio
.
muted
=
true
;
content
.
document
.
body
.
appendChild
(
audio
)
;
audio
.
loop
=
true
;
await
audio
.
play
(
)
;
}
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
audio
=
content
.
document
.
querySelector
(
"
audio
"
)
;
let
seeked
=
ContentTaskUtils
.
waitForEvent
(
audio
"
seeked
"
)
;
audio
.
muted
=
false
;
audio
.
playbackRate
=
0
.
25
;
audio
.
currentTime
=
0
;
await
seeked
;
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_FOREGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_web_audio_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
http
:
/
/
example
.
com
"
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
audioCtx
=
new
content
.
AudioContext
(
)
;
let
oscillator
=
audioCtx
.
createOscillator
(
)
;
oscillator
.
type
=
"
square
"
;
oscillator
.
frequency
.
setValueAtTime
(
440
audioCtx
.
currentTime
)
;
oscillator
.
connect
(
audioCtx
.
destination
)
;
oscillator
.
start
(
)
;
while
(
audioCtx
.
state
!
=
"
running
"
)
{
info
(
wait
until
AudioContext
starts
running
)
;
await
new
Promise
(
r
=
>
(
audioCtx
.
onstatechange
=
r
)
)
;
}
content
.
audioCtx
=
audioCtx
;
}
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_FOREGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
content
.
audioCtx
.
suspend
(
)
;
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
