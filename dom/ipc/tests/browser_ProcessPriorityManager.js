"
use
strict
"
;
const
PRIORITY_SET_TOPIC
=
"
process
-
priority
-
manager
:
TEST
-
ONLY
:
process
-
priority
-
set
"
;
const
PROCESS_PRIORITY_FOREGROUND
=
"
FOREGROUND
"
;
const
PROCESS_PRIORITY_BACKGROUND_PERCEIVABLE
=
"
BACKGROUND_PERCEIVABLE
"
;
const
PROCESS_PRIORITY_BACKGROUND
=
"
BACKGROUND
"
;
const
WAIT_FOR_CHANGE_TIME_MS
=
2000
;
function
browsingContextChildID
(
bc
)
{
return
bc
.
currentWindowGlobal
?
.
domProcess
.
childID
;
}
class
TabPriorityWatcher
{
constructor
(
tabbrowser
)
{
this
.
tabbrowser
=
tabbrowser
;
Assert
.
equal
(
tabbrowser
.
tabs
.
length
1
"
TabPriorityWatcher
must
be
constructed
in
a
window
"
+
"
with
a
single
tab
to
start
.
"
)
;
this
.
priorityMap
=
new
Map
(
)
;
this
.
noChangeChildIDs
=
new
Map
(
)
;
Services
.
obs
.
addObserver
(
this
PRIORITY_SET_TOPIC
)
;
}
destroy
(
)
{
Services
.
obs
.
removeObserver
(
this
PRIORITY_SET_TOPIC
)
;
}
async
waitForPriorityChange
(
childID
expectedPriority
)
{
await
TestUtils
.
waitForCondition
(
(
)
=
>
{
let
currentPriority
=
this
.
priorityMap
.
get
(
childID
)
;
if
(
currentPriority
=
=
expectedPriority
)
{
Assert
.
ok
(
true
Process
with
child
ID
{
childID
}
reached
expected
+
priority
:
{
currentPriority
}
)
;
return
true
;
}
return
false
;
}
Waiting
for
process
with
child
ID
{
childID
}
to
reach
priority
{
expectedPriority
}
)
;
}
async
ensureNoPriorityChange
(
childID
)
{
this
.
noChangeChildIDs
.
set
(
childID
null
)
;
await
new
Promise
(
resolve
=
>
setTimeout
(
resolve
WAIT_FOR_CHANGE_TIME_MS
)
)
;
let
priority
=
this
.
noChangeChildIDs
.
get
(
childID
)
;
Assert
.
equal
(
priority
null
Should
have
seen
no
process
priority
change
for
child
ID
{
childID
}
)
;
this
.
noChangeChildIDs
.
delete
(
childID
)
;
}
async
waitForBrowserTreePriority
(
browser
expectedPriority
)
{
let
childIDs
=
new
Set
(
browser
.
browsingContext
.
getAllBrowsingContextsInSubtree
(
)
.
map
(
browsingContextChildID
)
)
;
let
promises
=
[
]
;
for
(
let
childID
of
childIDs
)
{
let
currentPriority
=
this
.
priorityMap
.
get
(
childID
)
;
promises
.
push
(
currentPriority
=
=
expectedPriority
?
this
.
ensureNoPriorityChange
(
childID
)
:
this
.
waitForPriorityChange
(
childID
expectedPriority
)
)
;
}
await
Promise
.
all
(
promises
)
;
}
currentPriority
(
childID
)
{
return
this
.
priorityMap
.
get
(
childID
)
;
}
parsePPMData
(
ppmDataString
)
{
let
[
childIDStr
priority
]
=
ppmDataString
.
split
(
"
:
"
)
;
return
{
childID
:
parseInt
(
childIDStr
10
)
priority
}
;
}
observe
(
subject
topic
data
)
{
if
(
topic
!
=
PRIORITY_SET_TOPIC
)
{
Assert
.
ok
(
false
"
TabPriorityWatcher
is
observing
the
wrong
topic
"
)
;
return
;
}
let
{
childID
priority
}
=
this
.
parsePPMData
(
data
)
;
if
(
this
.
noChangeChildIDs
.
has
(
childID
)
)
{
this
.
noChangeChildIDs
.
set
(
childID
priority
)
;
}
this
.
priorityMap
.
set
(
childID
priority
)
;
}
}
let
gTabPriorityWatcher
;
add_task
(
async
function
setup
(
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
ipc
.
processPriorityManager
.
testMode
"
true
]
[
"
dom
.
ipc
.
processPriorityManager
.
enabled
"
true
]
]
}
)
;
gTabPriorityWatcher
=
new
TabPriorityWatcher
(
gBrowser
)
;
}
)
;
registerCleanupFunction
(
(
)
=
>
{
gTabPriorityWatcher
.
destroy
(
)
;
gTabPriorityWatcher
=
null
;
}
)
;
async
function
assertPriorityChangeOnBackground
(
{
fromTab
toTab
fromTabExpectedPriority
}
)
{
let
fromBrowser
=
fromTab
.
linkedBrowser
;
let
toBrowser
=
toTab
.
linkedBrowser
;
Assert
.
notEqual
(
toBrowser
.
frameLoader
.
remoteTab
.
osPid
fromBrowser
.
frameLoader
.
remoteTab
.
osPid
"
Tabs
should
be
running
in
separate
processes
.
"
)
;
let
fromPromise
=
gTabPriorityWatcher
.
waitForBrowserTreePriority
(
fromBrowser
fromTabExpectedPriority
)
;
let
toPromise
=
gTabPriorityWatcher
.
waitForBrowserTreePriority
(
toBrowser
PROCESS_PRIORITY_FOREGROUND
)
;
await
BrowserTestUtils
.
switchTab
(
gBrowser
toTab
)
;
await
Promise
.
all
(
[
fromPromise
toPromise
]
)
;
}
add_task
(
async
function
test_normal_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
/
browser
/
dom
/
ipc
/
tests
/
file_cross_frame
.
html
"
async
browser
=
>
{
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_iframe_navigate
(
)
{
let
iframeURI2
=
"
https
:
/
/
example
.
net
/
browser
/
dom
/
ipc
/
tests
/
file_dummy
.
html
"
;
let
newIFrameTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
iframeURI2
)
;
let
newIFrameTabChildID
=
browsingContextChildID
(
gBrowser
.
selectedBrowser
.
browsingContext
)
;
Assert
.
equal
(
gTabPriorityWatcher
.
currentPriority
(
newIFrameTabChildID
)
PROCESS_PRIORITY_FOREGROUND
"
Loading
a
new
tab
should
make
it
prioritized
"
)
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
/
browser
/
dom
/
ipc
/
tests
/
file_cross_frame
.
html
"
async
browser
=
>
{
Assert
.
equal
(
gTabPriorityWatcher
.
currentPriority
(
newIFrameTabChildID
)
PROCESS_PRIORITY_BACKGROUND
"
Switching
to
a
new
tab
should
deprioritize
the
old
one
"
)
;
let
iframe
=
browser
.
browsingContext
.
children
[
0
]
;
let
iframeChildID1
=
browsingContextChildID
(
iframe
)
;
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
true
iframeURI2
)
;
await
SpecialPowers
.
spawn
(
iframe
[
iframeURI2
]
async
function
(
_iframeURI2
)
{
content
.
location
=
_iframeURI2
;
}
)
;
await
loaded
;
let
iframeChildID2
=
browsingContextChildID
(
iframe
)
;
let
iframePriority1
=
gTabPriorityWatcher
.
currentPriority
(
iframeChildID1
)
;
let
iframePriority2
=
gTabPriorityWatcher
.
currentPriority
(
iframeChildID2
)
;
if
(
SpecialPowers
.
useRemoteSubframes
)
{
Assert
.
equal
(
newIFrameTabChildID
iframeChildID2
"
The
same
site
should
get
loaded
into
the
same
process
"
)
;
Assert
.
notEqual
(
iframeChildID1
iframeChildID2
"
Navigation
should
have
switched
processes
"
)
;
Assert
.
equal
(
iframePriority1
PROCESS_PRIORITY_BACKGROUND
"
The
old
iframe
process
should
have
been
deprioritized
"
)
;
}
else
{
Assert
.
equal
(
iframeChildID1
iframeChildID2
"
Navigation
should
not
have
switched
processes
"
)
;
}
Assert
.
equal
(
iframePriority2
PROCESS_PRIORITY_FOREGROUND
"
The
new
iframe
process
should
be
prioritized
"
)
;
}
)
;
await
BrowserTestUtils
.
removeTab
(
newIFrameTab
)
;
}
)
;
add_task
(
async
function
test_cross_group_navigate
(
)
{
let
coopPage
=
"
https
:
/
/
example
.
com
/
browser
/
dom
/
tests
/
browser
/
file_coop_coep
.
html
"
;
let
backgroundTab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
gBrowser
coopPage
)
;
let
backgroundTabChildID
=
browsingContextChildID
(
gBrowser
.
selectedBrowser
.
browsingContext
)
;
Assert
.
equal
(
gTabPriorityWatcher
.
currentPriority
(
backgroundTabChildID
)
PROCESS_PRIORITY_FOREGROUND
"
Loading
a
new
tab
should
make
it
prioritized
"
)
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
org
/
browser
/
dom
/
ipc
/
tests
/
file_cross_frame
.
html
"
async
browser
=
>
{
Assert
.
equal
(
gTabPriorityWatcher
.
currentPriority
(
backgroundTabChildID
)
PROCESS_PRIORITY_BACKGROUND
"
Switching
to
a
new
tab
should
deprioritize
the
old
one
"
)
;
let
dotOrgChildID
=
browsingContextChildID
(
browser
.
browsingContext
)
;
BrowserTestUtils
.
loadURI
(
browser
coopPage
)
;
await
BrowserTestUtils
.
browserLoaded
(
browser
)
;
let
coopChildID
=
browsingContextChildID
(
browser
.
browsingContext
)
;
let
coopPriority
=
gTabPriorityWatcher
.
currentPriority
(
coopChildID
)
;
let
dotOrgPriority
=
gTabPriorityWatcher
.
currentPriority
(
dotOrgChildID
)
;
Assert
.
equal
(
backgroundTabChildID
coopChildID
"
The
same
site
should
get
loaded
into
the
same
process
"
)
;
Assert
.
notEqual
(
dotOrgChildID
coopChildID
"
Navigation
should
have
switched
processes
"
)
;
Assert
.
equal
(
dotOrgPriority
PROCESS_PRIORITY_BACKGROUND
"
The
old
page
process
should
have
been
deprioritized
"
)
;
Assert
.
equal
(
coopPriority
PROCESS_PRIORITY_FOREGROUND
"
The
new
page
process
should
be
prioritized
"
)
;
}
)
;
await
BrowserTestUtils
.
removeTab
(
backgroundTab
)
;
}
)
;
add_task
(
async
function
test_video_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
"
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
video
=
content
.
document
.
createElement
(
"
video
"
)
;
video
.
src
=
"
https
:
/
/
example
.
net
/
browser
/
dom
/
ipc
/
tests
/
short
.
mp4
"
;
video
.
muted
=
true
;
content
.
document
.
body
.
appendChild
(
video
)
;
video
.
loop
=
true
;
await
video
.
play
(
)
;
}
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND_PERCEIVABLE
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
video
=
content
.
document
.
querySelector
(
"
video
"
)
;
video
.
muted
=
false
;
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_FOREGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_audio_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
"
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
audio
=
content
.
document
.
createElement
(
"
audio
"
)
;
audio
.
src
=
"
https
:
/
/
example
.
net
/
browser
/
dom
/
ipc
/
tests
/
owl
.
mp3
"
;
audio
.
muted
=
true
;
content
.
document
.
body
.
appendChild
(
audio
)
;
audio
.
loop
=
true
;
await
audio
.
play
(
)
;
}
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
audio
=
content
.
document
.
querySelector
(
"
audio
"
)
;
let
seeked
=
ContentTaskUtils
.
waitForEvent
(
audio
"
seeked
"
)
;
audio
.
muted
=
false
;
audio
.
playbackRate
=
0
.
25
;
audio
.
currentTime
=
0
;
await
seeked
;
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_FOREGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_web_audio_background_tab
(
)
{
let
originalTab
=
gBrowser
.
selectedTab
;
await
BrowserTestUtils
.
withNewTab
(
"
https
:
/
/
example
.
com
"
async
browser
=
>
{
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
let
audioCtx
=
new
content
.
AudioContext
(
)
;
let
oscillator
=
audioCtx
.
createOscillator
(
)
;
oscillator
.
type
=
"
square
"
;
oscillator
.
frequency
.
setValueAtTime
(
440
audioCtx
.
currentTime
)
;
oscillator
.
connect
(
audioCtx
.
destination
)
;
oscillator
.
start
(
)
;
while
(
audioCtx
.
state
!
=
"
running
"
)
{
info
(
wait
until
AudioContext
starts
running
)
;
await
new
Promise
(
r
=
>
(
audioCtx
.
onstatechange
=
r
)
)
;
}
content
.
audioCtx
=
audioCtx
;
}
)
;
let
tab
=
gBrowser
.
getTabForBrowser
(
browser
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_FOREGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
SpecialPowers
.
spawn
(
browser
[
]
async
(
)
=
>
{
content
.
audioCtx
.
suspend
(
)
;
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
tab
toTab
:
originalTab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
await
assertPriorityChangeOnBackground
(
{
fromTab
:
originalTab
toTab
:
tab
fromTabExpectedPriority
:
PROCESS_PRIORITY_BACKGROUND
}
)
;
}
)
;
}
)
;
add_task
(
async
function
test_audio_background_tab
(
)
{
let
page1
=
"
https
:
/
/
example
.
com
"
;
let
page2
=
page1
+
"
/
?
2
"
;
await
BrowserTestUtils
.
withNewTab
(
page1
async
browser
=
>
{
let
childID
=
browsingContextChildID
(
browser
.
browsingContext
)
;
Assert
.
equal
(
gTabPriorityWatcher
.
currentPriority
(
childID
)
PROCESS_PRIORITY_FOREGROUND
"
Loading
a
new
tab
should
make
it
prioritized
.
"
)
;
let
loaded
=
BrowserTestUtils
.
browserLoaded
(
browser
false
page2
)
;
BrowserTestUtils
.
loadURI
(
browser
page2
)
;
await
loaded
;
childID
=
browsingContextChildID
(
browser
.
browsingContext
)
;
Assert
.
equal
(
gTabPriorityWatcher
.
currentPriority
(
childID
)
PROCESS_PRIORITY_FOREGROUND
"
Loading
a
new
page
should
keep
the
tab
prioritized
.
"
)
;
let
pageShowPromise
=
BrowserTestUtils
.
waitForContentEvent
(
browser
"
pageshow
"
)
;
browser
.
goBack
(
)
;
await
pageShowPromise
;
childID
=
browsingContextChildID
(
browser
.
browsingContext
)
;
Assert
.
equal
(
gTabPriorityWatcher
.
currentPriority
(
childID
)
PROCESS_PRIORITY_FOREGROUND
"
Loading
a
page
from
the
bfcache
should
keep
the
tab
prioritized
.
"
)
;
}
)
;
}
)
;
