"
use
strict
"
;
requestLongerTimeout
(
10
)
;
const
TEST_PAGE
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
dom
/
ipc
/
tests
/
file_cancel_content_js
.
html
"
;
const
NEXT_PAGE
=
"
http
:
/
/
mochi
.
test
:
8888
/
browser
/
dom
/
ipc
/
tests
/
"
;
const
JS_URI
=
"
javascript
:
void
(
document
.
title
=
'
foo
'
)
"
;
async
function
test_navigation
(
nextPage
shouldCancel
)
{
await
SpecialPowers
.
pushPrefEnv
(
{
set
:
[
[
"
dom
.
max_script_run_time
"
20
]
[
"
dom
.
ipc
.
processCount
"
1
]
[
"
dom
.
ipc
.
processCount
.
webIsolated
"
1
]
]
}
)
;
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
opening
:
TEST_PAGE
}
)
;
const
loopEnded
=
ContentTask
.
spawn
(
tab
.
linkedBrowser
[
]
async
function
(
)
{
await
new
Promise
(
resolve
=
>
{
content
.
addEventListener
(
"
LongLoopEnded
"
resolve
{
once
:
true
}
)
;
}
)
;
}
)
;
await
ContentTask
.
spawn
(
tab
.
linkedBrowser
[
]
function
(
)
{
content
.
dispatchEvent
(
new
content
.
Event
(
"
StartLongLoop
"
)
)
;
}
)
;
info
(
navigating
to
{
nextPage
}
)
;
const
nextPageLoaded
=
BrowserTestUtils
.
waitForContentEvent
(
tab
.
linkedBrowser
"
DOMTitleChanged
"
)
;
BrowserTestUtils
.
startLoadingURIString
(
gBrowser
nextPage
)
;
const
result
=
await
Promise
.
race
(
[
nextPageLoaded
loopEnded
.
then
(
(
)
=
>
"
timeout
"
)
]
)
;
const
timedOut
=
result
=
=
=
"
timeout
"
;
if
(
shouldCancel
)
{
Assert
.
strictEqual
(
timedOut
false
"
expected
next
page
to
be
loaded
"
)
;
}
else
{
Assert
.
strictEqual
(
timedOut
true
"
expected
timeout
"
)
;
}
BrowserTestUtils
.
removeTab
(
tab
)
;
}
add_task
(
async
(
)
=
>
test_navigation
(
NEXT_PAGE
true
)
)
;
add_task
(
async
(
)
=
>
test_navigation
(
JS_URI
false
)
)
;
