"
use
strict
"
;
async
function
openTestTabs
(
numTabs
)
{
let
iframeBC
=
null
;
for
(
let
count
=
0
;
count
<
numTabs
;
count
+
+
)
{
let
tab
=
await
BrowserTestUtils
.
openNewForegroundTab
(
{
gBrowser
url
:
"
about
:
blank
"
}
)
;
iframeBC
=
await
SpecialPowers
.
spawn
(
tab
.
linkedBrowser
[
]
async
(
)
=
>
{
let
iframe
=
content
.
document
.
createElement
(
"
iframe
"
)
;
iframe
.
setAttribute
(
"
src
"
"
http
:
/
/
example
.
com
"
)
;
content
.
document
.
body
.
appendChild
(
iframe
)
;
await
ContentTaskUtils
.
waitForEvent
(
iframe
"
load
"
)
;
return
iframe
.
frameLoader
.
browsingContext
;
}
)
;
}
return
iframeBC
;
}
async
function
testFrameCrash
(
numTabs
)
{
let
iframeBC
=
await
openTestTabs
(
numTabs
)
;
let
browser
=
gBrowser
.
selectedBrowser
;
let
rootBC
=
browser
.
browsingContext
;
is
(
iframeBC
.
parent
rootBC
"
oop
frame
has
root
as
parent
"
)
;
let
eventFiredPromise
=
BrowserTestUtils
.
waitForEvent
(
browser
"
oop
-
browser
-
crashed
"
)
;
BrowserTestUtils
.
crashFrame
(
browser
true
true
iframeBC
)
;
let
notificationPromise
=
BrowserTestUtils
.
waitForNotificationBar
(
gBrowser
browser
"
subframe
-
crashed
"
)
;
info
(
"
Waiting
for
oop
-
browser
-
crashed
event
.
"
)
;
await
eventFiredPromise
.
then
(
event
=
>
{
ok
(
!
event
.
isTopFrame
"
should
not
be
reporting
top
-
level
frame
crash
"
)
;
ok
(
event
.
childID
!
=
0
"
childID
is
non
-
zero
"
)
;
isnot
(
event
.
browsingContextId
rootBC
"
top
frame
browsing
context
id
not
expected
.
"
)
;
is
(
event
.
browsingContextId
iframeBC
.
id
"
oop
frame
browsing
context
id
expected
.
"
)
;
}
)
;
if
(
numTabs
=
=
1
)
{
let
{
subject
:
windowGlobal
}
=
await
BrowserUtils
.
promiseObserved
(
"
window
-
global
-
created
"
wgp
=
>
wgp
.
documentURI
.
spec
.
startsWith
(
"
about
:
framecrashed
"
)
)
;
is
(
windowGlobal
iframeBC
.
currentWindowGlobal
"
Resolved
on
expected
window
global
"
)
;
let
newIframeURI
=
await
SpecialPowers
.
spawn
(
iframeBC
[
]
async
(
)
=
>
{
return
content
.
document
.
documentURI
;
}
)
;
ok
(
newIframeURI
.
startsWith
(
"
about
:
framecrashed
"
)
"
The
iframe
is
now
pointing
at
about
:
framecrashed
"
)
;
}
await
notificationPromise
;
for
(
let
count
=
1
;
count
<
=
numTabs
;
count
+
+
)
{
let
notificationBox
=
gBrowser
.
getNotificationBox
(
gBrowser
.
browsers
[
count
]
)
;
let
notification
=
notificationBox
.
currentNotification
;
ok
(
notification
"
Notification
"
+
count
+
"
should
be
visible
"
)
;
is
(
notification
.
getAttribute
(
"
value
"
)
"
subframe
-
crashed
"
"
Should
be
showing
the
right
notification
"
+
count
)
;
let
buttons
=
notification
.
querySelectorAll
(
"
.
notification
-
button
"
)
;
is
(
buttons
.
length
2
"
Notification
"
+
count
+
"
should
have
only
two
buttons
.
"
)
;
}
let
notificationBox
=
gBrowser
.
getNotificationBox
(
gBrowser
.
selectedBrowser
)
;
let
notification
=
notificationBox
.
currentNotification
;
notification
.
dismiss
(
)
;
for
(
let
count
=
1
;
count
<
=
numTabs
;
count
+
+
)
{
let
nb
=
gBrowser
.
getNotificationBox
(
gBrowser
.
browsers
[
count
]
)
;
await
TestUtils
.
waitForCondition
(
(
)
=
>
!
nb
.
currentNotification
"
notification
closed
"
)
;
ok
(
!
nb
.
currentNotification
"
notification
"
+
count
+
"
closed
when
dismiss
button
is
pressed
"
)
;
}
for
(
let
count
=
1
;
count
<
=
numTabs
;
count
+
+
)
{
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
}
add_task
(
async
function
test_crashframe
(
)
{
ok
(
SpecialPowers
.
useRemoteSubframes
"
This
test
only
makes
sense
of
we
can
use
OOP
iframes
.
"
)
;
const
uAppDataPath
=
Services
.
dirsvc
.
get
(
"
UAppData
"
Ci
.
nsIFile
)
.
path
;
let
path
=
PathUtils
.
join
(
uAppDataPath
"
Crash
Reports
"
"
pending
"
)
;
await
IOUtils
.
makeDirectory
(
path
{
ignoreExisting
:
true
}
)
;
await
testFrameCrash
(
1
)
;
await
testFrameCrash
(
4
)
;
}
)
;
add_task
(
async
function
test_nominidump
(
)
{
for
(
let
dumpID
of
[
null
"
8888
"
]
)
{
let
iframeBC
=
await
openTestTabs
(
1
)
;
let
childID
=
iframeBC
.
currentWindowGlobal
.
domProcess
.
childID
;
gBrowser
.
selectedBrowser
.
dispatchEvent
(
new
FrameCrashedEvent
(
"
oop
-
browser
-
crashed
"
{
browsingContextID
:
iframeBC
childID
isTopFrame
:
false
bubbles
:
true
}
)
)
;
let
bag
=
Cc
[
"
mozilla
.
org
/
hash
-
property
-
bag
;
1
"
]
.
createInstance
(
Ci
.
nsIWritablePropertyBag
)
;
bag
.
setProperty
(
"
abnormal
"
"
true
"
)
;
bag
.
setProperty
(
"
childID
"
iframeBC
.
currentWindowGlobal
.
domProcess
.
childID
)
;
if
(
dumpID
)
{
bag
.
setProperty
(
"
dumpID
"
dumpID
)
;
}
Services
.
obs
.
notifyObservers
(
bag
"
ipc
:
content
-
shutdown
"
)
;
let
notificationBox
=
gBrowser
.
getNotificationBox
(
gBrowser
.
selectedBrowser
)
;
let
notification
=
notificationBox
.
currentNotification
;
ok
(
dumpID
?
notification
:
!
notification
"
notification
shown
for
browser
with
no
minidump
"
)
;
BrowserTestUtils
.
removeTab
(
gBrowser
.
selectedTab
)
;
}
}
)
;
