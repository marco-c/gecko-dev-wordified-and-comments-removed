#
include
"
mozilla
/
dom
/
ProcessIsolation
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
RemoteType
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
ContentPrincipal
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
PermissionManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIChromeRegistry
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsSHistory
.
h
"
#
include
"
nsURLHelper
.
h
"
namespace
mozilla
:
:
dom
{
mozilla
:
:
LazyLogModule
gProcessIsolationLog
{
"
ProcessIsolation
"
}
;
namespace
{
enum
class
WebContentIsolationStrategy
:
uint32_t
{
IsolateNothing
=
0
IsolateEverything
=
1
IsolateHighValue
=
2
}
;
struct
CommaSeparatedPref
{
public
:
explicit
constexpr
CommaSeparatedPref
(
nsLiteralCString
aPrefName
)
:
mPrefName
(
aPrefName
)
{
}
void
OnChange
(
)
{
if
(
mValues
)
{
mValues
-
>
Clear
(
)
;
nsAutoCString
prefValue
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
mPrefName
.
get
(
)
prefValue
)
)
)
{
for
(
const
auto
&
value
:
nsCCharSeparatedTokenizer
(
prefValue
'
'
)
.
ToRange
(
)
)
{
mValues
-
>
EmplaceBack
(
value
)
;
}
}
}
}
const
nsTArray
<
nsCString
>
&
Get
(
)
{
if
(
!
mValues
)
{
mValues
=
new
nsTArray
<
nsCString
>
;
Preferences
:
:
RegisterCallbackAndCall
(
[
]
(
const
char
*
void
*
aData
)
{
static_cast
<
CommaSeparatedPref
*
>
(
aData
)
-
>
OnChange
(
)
;
}
mPrefName
this
)
;
RunOnShutdown
(
[
this
]
{
delete
this
-
>
mValues
;
this
-
>
mValues
=
nullptr
;
}
)
;
}
return
*
mValues
;
}
auto
begin
(
)
{
return
Get
(
)
.
cbegin
(
)
;
}
auto
end
(
)
{
return
Get
(
)
.
cend
(
)
;
}
private
:
nsLiteralCString
mPrefName
;
nsTArray
<
nsCString
>
*
MOZ_OWNING_REF
mValues
=
nullptr
;
}
;
CommaSeparatedPref
sSeparatedMozillaDomains
{
"
browser
.
tabs
.
remote
.
separatedMozillaDomains
"
_ns
}
;
enum
class
IsolationBehavior
{
WebContent
ForceWebRemoteType
PrivilegedAbout
Extension
File
PrivilegedMozilla
Parent
Anywhere
Inherit
AboutReader
Error
}
;
static
const
char
*
IsolationBehaviorName
(
IsolationBehavior
aBehavior
)
{
switch
(
aBehavior
)
{
case
IsolationBehavior
:
:
WebContent
:
return
"
WebContent
"
;
case
IsolationBehavior
:
:
ForceWebRemoteType
:
return
"
ForceWebRemoteType
"
;
case
IsolationBehavior
:
:
PrivilegedAbout
:
return
"
PrivilegedAbout
"
;
case
IsolationBehavior
:
:
Extension
:
return
"
Extension
"
;
case
IsolationBehavior
:
:
File
:
return
"
File
"
;
case
IsolationBehavior
:
:
PrivilegedMozilla
:
return
"
PrivilegedMozilla
"
;
case
IsolationBehavior
:
:
Parent
:
return
"
Parent
"
;
case
IsolationBehavior
:
:
Anywhere
:
return
"
Anywhere
"
;
case
IsolationBehavior
:
:
Inherit
:
return
"
Inherit
"
;
case
IsolationBehavior
:
:
AboutReader
:
return
"
AboutReader
"
;
case
IsolationBehavior
:
:
Error
:
return
"
Error
"
;
default
:
return
"
Unknown
"
;
}
}
static
IsolationBehavior
IsolationBehaviorForURI
(
nsIURI
*
aURI
bool
aIsSubframe
bool
aForChannelCreationURI
)
{
nsAutoCString
scheme
;
MOZ_ALWAYS_SUCCEEDS
(
aURI
-
>
GetScheme
(
scheme
)
)
;
if
(
scheme
=
=
"
chrome
"
_ns
)
{
nsCOMPtr
<
nsIXULChromeRegistry
>
chromeReg
=
do_GetService
(
"
mozilla
.
org
/
chrome
/
chrome
-
registry
;
1
"
)
;
bool
mustLoadRemotely
=
false
;
if
(
NS_SUCCEEDED
(
chromeReg
-
>
MustLoadURLRemotely
(
aURI
&
mustLoadRemotely
)
)
&
&
mustLoadRemotely
)
{
return
IsolationBehavior
:
:
ForceWebRemoteType
;
}
bool
canLoadRemotely
=
false
;
if
(
NS_SUCCEEDED
(
chromeReg
-
>
CanLoadURLRemotely
(
aURI
&
canLoadRemotely
)
)
&
&
canLoadRemotely
)
{
return
IsolationBehavior
:
:
Anywhere
;
}
return
IsolationBehavior
:
:
Parent
;
}
if
(
scheme
=
=
"
about
"
_ns
)
{
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
NS_GetAboutModuleName
(
aURI
path
)
)
;
if
(
path
=
=
"
blank
"
_ns
|
|
path
=
=
"
srcdoc
"
_ns
)
{
return
IsolationBehavior
:
:
WebContent
;
}
if
(
path
=
=
"
reader
"
_ns
&
&
aForChannelCreationURI
)
{
return
IsolationBehavior
:
:
AboutReader
;
}
nsCOMPtr
<
nsIAboutModule
>
aboutModule
;
if
(
NS_FAILED
(
NS_GetAboutModule
(
aURI
getter_AddRefs
(
aboutModule
)
)
)
|
|
!
aboutModule
)
{
return
IsolationBehavior
:
:
WebContent
;
}
uint32_t
flags
=
0
;
if
(
NS_FAILED
(
aboutModule
-
>
GetURIFlags
(
aURI
&
flags
)
)
)
{
NS_WARNING
(
"
nsIAboutModule
:
:
GetURIFlags
unexpectedly
failed
.
Abort
the
load
"
)
;
return
IsolationBehavior
:
:
Error
;
}
if
(
flags
&
nsIAboutModule
:
:
URI_MUST_LOAD_IN_EXTENSION_PROCESS
)
{
return
IsolationBehavior
:
:
Extension
;
}
if
(
flags
&
nsIAboutModule
:
:
URI_MUST_LOAD_IN_CHILD
)
{
if
(
flags
&
nsIAboutModule
:
:
URI_CAN_LOAD_IN_PRIVILEGEDABOUT_PROCESS
)
{
return
IsolationBehavior
:
:
PrivilegedAbout
;
}
return
IsolationBehavior
:
:
ForceWebRemoteType
;
}
if
(
flags
&
nsIAboutModule
:
:
URI_CAN_LOAD_IN_CHILD
)
{
return
IsolationBehavior
:
:
Anywhere
;
}
return
IsolationBehavior
:
:
Parent
;
}
if
(
StaticPrefs
:
:
browser_tabs_remote_dataUriInDefaultWebProcess
(
)
&
&
scheme
=
=
"
data
"
_ns
)
{
return
IsolationBehavior
:
:
ForceWebRemoteType
;
}
nsCOMPtr
<
nsIURI
>
inner
;
if
(
nsCOMPtr
<
nsINestedURI
>
nested
=
do_QueryInterface
(
aURI
)
;
nested
&
&
NS_SUCCEEDED
(
nested
-
>
GetInnerURI
(
getter_AddRefs
(
inner
)
)
)
)
{
return
IsolationBehaviorForURI
(
inner
aIsSubframe
aForChannelCreationURI
)
;
}
if
(
aForChannelCreationURI
)
{
return
IsolationBehavior
:
:
WebContent
;
}
if
(
scheme
=
=
"
imap
"
_ns
|
|
scheme
=
=
"
mailbox
"
_ns
|
|
scheme
=
=
"
news
"
_ns
|
|
scheme
=
=
"
nntp
"
_ns
|
|
scheme
=
=
"
snews
"
_ns
)
{
return
IsolationBehavior
:
:
Parent
;
}
if
(
scheme
=
=
"
moz
-
extension
"
_ns
)
{
if
(
aIsSubframe
)
{
return
IsolationBehavior
:
:
Inherit
;
}
return
IsolationBehavior
:
:
Extension
;
}
if
(
scheme
=
=
"
file
"
_ns
)
{
return
IsolationBehavior
:
:
File
;
}
if
(
scheme
=
=
"
https
"
_ns
&
&
StaticPrefs
:
:
browser_tabs_remote_separatePrivilegedMozillaWebContentProcess
(
)
)
{
nsAutoCString
host
;
if
(
NS_SUCCEEDED
(
aURI
-
>
GetAsciiHost
(
host
)
)
)
{
for
(
const
auto
&
separatedDomain
:
sSeparatedMozillaDomains
)
{
if
(
separatedDomain
=
=
host
|
|
(
separatedDomain
.
Length
(
)
<
host
.
Length
(
)
&
&
host
.
CharAt
(
host
.
Length
(
)
-
separatedDomain
.
Length
(
)
-
1
)
=
=
'
.
'
&
&
StringEndsWith
(
host
separatedDomain
)
)
)
{
return
IsolationBehavior
:
:
PrivilegedMozilla
;
}
}
}
}
nsCOMPtr
<
nsIScriptSecurityManager
>
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
bool
inFileURIAllowList
=
false
;
if
(
NS_SUCCEEDED
(
secMan
-
>
InFileURIAllowlist
(
aURI
&
inFileURIAllowList
)
)
&
&
inFileURIAllowList
)
{
return
IsolationBehavior
:
:
File
;
}
return
IsolationBehavior
:
:
WebContent
;
}
static
nsAutoCString
OriginString
(
nsIPrincipal
*
aPrincipal
)
{
nsAutoCString
origin
;
aPrincipal
-
>
GetOrigin
(
origin
)
;
return
origin
;
}
static
already_AddRefed
<
BasePrincipal
>
GetAboutReaderURLPrincipal
(
nsIURI
*
aURI
const
OriginAttributes
&
aAttrs
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aURI
-
>
SchemeIs
(
"
about
"
)
)
;
nsAutoCString
path
;
MOZ_ALWAYS_SUCCEEDS
(
NS_GetAboutModuleName
(
aURI
path
)
)
;
MOZ_ASSERT
(
path
=
=
"
reader
"
_ns
)
;
#
endif
nsAutoCString
query
;
MOZ_ALWAYS_SUCCEEDS
(
aURI
-
>
GetQuery
(
query
)
)
;
nsAutoString
readerSpec
;
if
(
URLParams
:
:
Extract
(
query
u
"
url
"
_ns
readerSpec
)
)
{
nsCOMPtr
<
nsIURI
>
readerUri
;
if
(
NS_SUCCEEDED
(
NS_NewURI
(
getter_AddRefs
(
readerUri
)
readerSpec
)
)
)
{
return
BasePrincipal
:
:
CreateContentPrincipal
(
readerUri
aAttrs
)
;
}
}
return
nullptr
;
}
static
bool
IsLargeAllocationLoad
(
CanonicalBrowsingContext
*
aBrowsingContext
nsIChannel
*
aChannel
)
{
if
(
!
StaticPrefs
:
:
dom_largeAllocationHeader_enabled
(
)
|
|
aBrowsingContext
-
>
UseRemoteSubframes
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
!
httpChannel
)
{
return
false
;
}
nsAutoCString
ignoredHeaderValue
;
nsresult
rv
=
httpChannel
-
>
GetResponseHeader
(
"
Large
-
Allocation
"
_ns
ignoredHeaderValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
#
if
defined
(
XP_WIN
)
&
&
defined
(
_X86_
)
return
true
;
#
else
return
StaticPrefs
:
:
dom_largeAllocation_forceEnable
(
)
;
#
endif
}
static
bool
ShouldIsolateSite
(
nsIPrincipal
*
aPrincipal
CanonicalBrowsingContext
*
aTopBC
)
{
if
(
aTopBC
&
&
!
aTopBC
-
>
UseRemoteSubframes
(
)
)
{
return
false
;
}
if
(
!
aTopBC
&
&
!
mozilla
:
:
FissionAutostart
(
)
)
{
return
false
;
}
if
(
!
aPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
return
false
;
}
switch
(
WebContentIsolationStrategy
(
StaticPrefs
:
:
fission_webContentIsolationStrategy
(
)
)
)
{
case
WebContentIsolationStrategy
:
:
IsolateNothing
:
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Not
isolating
'
%
s
'
as
isolation
is
disabled
"
OriginString
(
aPrincipal
)
.
get
(
)
)
)
;
return
false
;
case
WebContentIsolationStrategy
:
:
IsolateEverything
:
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Isolating
'
%
s
'
as
isolation
is
enabled
for
all
sites
"
OriginString
(
aPrincipal
)
.
get
(
)
)
)
;
return
true
;
case
WebContentIsolationStrategy
:
:
IsolateHighValue
:
{
RefPtr
<
PermissionManager
>
perms
=
PermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
perms
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Permission
manager
is
missing
"
)
;
return
true
;
}
static
constexpr
nsLiteralCString
kHighValuePermissions
[
]
=
{
mozilla
:
:
dom
:
:
kHighValueCOOPPermission
mozilla
:
:
dom
:
:
kHighValueHasSavedLoginPermission
mozilla
:
:
dom
:
:
kHighValueIsLoggedInPermission
}
;
for
(
const
auto
&
type
:
kHighValuePermissions
)
{
uint32_t
permission
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
;
if
(
NS_SUCCEEDED
(
perms
-
>
TestPermissionFromPrincipal
(
aPrincipal
type
&
permission
)
)
&
&
permission
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Isolating
'
%
s
'
due
to
high
-
value
permission
'
%
s
'
"
OriginString
(
aPrincipal
)
.
get
(
)
type
.
get
(
)
)
)
;
return
true
;
}
}
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Not
isolating
'
%
s
'
as
it
is
not
high
-
value
"
OriginString
(
aPrincipal
)
.
get
(
)
)
)
;
return
false
;
}
default
:
NS_WARNING
(
"
Invalid
pref
value
for
fission
.
webContentIsolationStrategy
"
)
;
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Isolating
'
%
s
'
due
to
unknown
strategy
pref
value
"
OriginString
(
aPrincipal
)
.
get
(
)
)
)
;
return
true
;
}
}
enum
class
WebProcessType
{
Web
WebIsolated
WebCoopCoep
}
;
}
Result
<
NavigationIsolationOptions
nsresult
>
IsolationOptionsForNavigation
(
CanonicalBrowsingContext
*
aTopBC
WindowGlobalParent
*
aParentWindow
nsIURI
*
aChannelCreationURI
nsIChannel
*
aChannel
const
nsACString
&
aCurrentRemoteType
bool
aHasCOOPMismatch
uint32_t
aLoadStateLoadType
const
Maybe
<
uint64_t
>
&
aChannelId
const
Maybe
<
nsCString
>
&
aRemoteTypeOverride
)
{
nsCOMPtr
<
nsIPrincipal
>
resultPrincipal
;
nsresult
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
resultPrincipal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Error
(
"
failed
to
get
channel
result
principal
"
)
)
;
return
Err
(
rv
)
;
}
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
IsolationOptionsForNavigation
principal
:
%
s
uri
:
%
s
parentUri
:
%
s
"
OriginString
(
resultPrincipal
)
.
get
(
)
aChannelCreationURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
aParentWindow
?
aParentWindow
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
bool
principalIsSandboxed
=
false
;
nsCOMPtr
<
nsIPrincipal
>
resultOrPrecursor
(
resultPrincipal
)
;
if
(
nsCOMPtr
<
nsIPrincipal
>
precursor
=
resultOrPrecursor
-
>
GetPrecursorPrincipal
(
)
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
using
null
principal
precursor
origin
%
s
"
OriginString
(
precursor
)
.
get
(
)
)
)
;
resultOrPrecursor
=
precursor
;
principalIsSandboxed
=
true
;
}
NavigationIsolationOptions
options
;
options
.
mReplaceBrowsingContext
=
aHasCOOPMismatch
;
if
(
aRemoteTypeOverride
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_IsAboutBlank
(
aChannelCreationURI
)
"
Should
only
have
aRemoteTypeOverride
for
about
:
blank
URIs
"
)
;
if
(
NS_WARN_IF
(
!
resultPrincipal
-
>
GetIsNullPrincipal
(
)
)
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Error
(
"
invalid
remote
type
override
on
non
-
null
principal
"
)
)
;
return
Err
(
NS_ERROR_DOM_SECURITY_ERR
)
;
}
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
using
remote
type
override
(
%
s
)
for
load
"
aRemoteTypeOverride
-
>
get
(
)
)
)
;
options
.
mRemoteType
=
*
aRemoteTypeOverride
;
return
options
;
}
auto
behavior
=
IsolationBehaviorForURI
(
aChannelCreationURI
aParentWindow
true
)
;
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Channel
Creation
Isolation
Behavior
:
%
s
"
IsolationBehaviorName
(
behavior
)
)
)
;
if
(
behavior
=
=
IsolationBehavior
:
:
AboutReader
)
{
if
(
RefPtr
<
BasePrincipal
>
readerURIPrincipal
=
GetAboutReaderURLPrincipal
(
aChannelCreationURI
resultOrPrecursor
-
>
OriginAttributesRef
(
)
)
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
using
about
:
reader
'
s
url
origin
%
s
"
OriginString
(
readerURIPrincipal
)
.
get
(
)
)
)
;
resultOrPrecursor
=
readerURIPrincipal
;
}
behavior
=
IsolationBehavior
:
:
WebContent
;
}
if
(
StaticPrefs
:
:
browser_tabs_remote_systemTriggeredAboutBlankAnywhere
(
)
&
&
NS_IsAboutBlank
(
aChannelCreationURI
)
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
if
(
loadInfo
-
>
TriggeringPrincipal
(
)
-
>
IsSystemPrincipal
(
)
&
&
resultOrPrecursor
-
>
GetIsNullPrincipal
(
)
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Warning
(
"
Forcing
system
-
principal
triggered
about
:
blank
load
to
"
"
complete
in
the
current
process
"
)
)
;
behavior
=
IsolationBehavior
:
:
Anywhere
;
}
}
if
(
auto
*
addonPolicy
=
BasePrincipal
:
:
Cast
(
resultOrPrecursor
)
-
>
AddonPolicy
(
)
)
{
if
(
aParentWindow
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Loading
extension
subframe
in
same
process
as
parent
"
)
)
;
behavior
=
IsolationBehavior
:
:
Inherit
;
}
else
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Found
extension
frame
with
addon
policy
.
Will
use
group
id
%
"
PRIx64
"
(
currentId
:
%
"
PRIx64
"
)
"
addonPolicy
-
>
GetBrowsingContextGroupId
(
)
aTopBC
-
>
Group
(
)
-
>
Id
(
)
)
)
;
behavior
=
IsolationBehavior
:
:
Extension
;
if
(
aTopBC
-
>
Group
(
)
-
>
Id
(
)
!
=
addonPolicy
-
>
GetBrowsingContextGroupId
(
)
)
{
options
.
mReplaceBrowsingContext
=
true
;
options
.
mSpecificGroupId
=
addonPolicy
-
>
GetBrowsingContextGroupId
(
)
;
}
}
}
if
(
behavior
=
=
IsolationBehavior
:
:
WebContent
)
{
if
(
resultOrPrecursor
-
>
IsSystemPrincipal
(
)
)
{
bool
isUIResource
=
false
;
if
(
aCurrentRemoteType
.
IsEmpty
(
)
&
&
(
aChannelCreationURI
-
>
SchemeIs
(
"
about
"
)
|
|
(
NS_SUCCEEDED
(
NS_URIChainHasFlags
(
aChannelCreationURI
nsIProtocolHandler
:
:
URI_IS_UI_RESOURCE
&
isUIResource
)
)
&
&
isUIResource
)
)
)
{
behavior
=
IsolationBehavior
:
:
Parent
;
}
else
{
behavior
=
IsolationBehavior
:
:
ForceWebRemoteType
;
}
}
else
if
(
nsCOMPtr
<
nsIURI
>
principalURI
=
resultOrPrecursor
-
>
GetURI
(
)
)
{
behavior
=
IsolationBehaviorForURI
(
principalURI
aParentWindow
false
)
;
}
}
if
(
!
aParentWindow
&
&
aCurrentRemoteType
=
=
EXTENSION_REMOTE_TYPE
&
&
behavior
!
=
IsolationBehavior
:
:
Extension
&
&
behavior
!
=
IsolationBehavior
:
:
Anywhere
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Forcing
BC
replacement
to
leave
extension
BrowsingContextGroup
"
"
%
"
PRIx64
"
on
navigation
"
aTopBC
-
>
Group
(
)
-
>
Id
(
)
)
)
;
options
.
mReplaceBrowsingContext
=
true
;
}
if
(
behavior
=
=
IsolationBehavior
:
:
Parent
&
&
principalIsSandboxed
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Debug
(
"
Ensuring
sandboxed
null
-
principal
load
doesn
'
t
occur
in
the
"
"
parent
process
"
)
)
;
behavior
=
IsolationBehavior
:
:
ForceWebRemoteType
;
}
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Debug
(
"
Using
IsolationBehavior
%
s
for
%
s
(
original
uri
%
s
)
"
IsolationBehaviorName
(
behavior
)
OriginString
(
resultOrPrecursor
)
.
get
(
)
aChannelCreationURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
if
(
mozilla
:
:
BFCacheInParent
(
)
&
&
nsSHistory
:
:
GetMaxTotalViewers
(
)
>
0
&
&
!
aParentWindow
&
&
!
aTopBC
-
>
HadOriginalOpener
(
)
&
&
behavior
!
=
IsolationBehavior
:
:
Parent
&
&
(
ExtensionPolicyService
:
:
GetSingleton
(
)
.
UseRemoteExtensions
(
)
|
|
behavior
!
=
IsolationBehavior
:
:
Extension
)
&
&
!
aCurrentRemoteType
.
IsEmpty
(
)
&
&
aTopBC
-
>
GetHasLoadedNonInitialDocument
(
)
&
&
(
aLoadStateLoadType
=
=
LOAD_NORMAL
|
|
aLoadStateLoadType
=
=
LOAD_HISTORY
|
|
aLoadStateLoadType
=
=
LOAD_LINK
|
|
aLoadStateLoadType
=
=
LOAD_STOP_CONTENT
|
|
aLoadStateLoadType
=
=
LOAD_STOP_CONTENT_AND_REPLACE
)
&
&
(
!
aTopBC
-
>
GetActiveSessionHistoryEntry
(
)
|
|
aTopBC
-
>
GetActiveSessionHistoryEntry
(
)
-
>
GetSaveLayoutStateFlag
(
)
)
)
{
if
(
nsCOMPtr
<
nsIURI
>
uri
=
aTopBC
-
>
GetCurrentURI
(
)
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
current
uri
:
%
s
"
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
}
options
.
mTryUseBFCache
=
aTopBC
-
>
AllowedInBFCache
(
aChannelId
)
;
if
(
options
.
mTryUseBFCache
)
{
options
.
mReplaceBrowsingContext
=
true
;
options
.
mActiveSessionHistoryEntry
=
aTopBC
-
>
GetActiveSessionHistoryEntry
(
)
;
}
}
if
(
behavior
!
=
IsolationBehavior
:
:
WebContent
)
{
switch
(
behavior
)
{
case
IsolationBehavior
:
:
ForceWebRemoteType
:
options
.
mRemoteType
=
WEB_REMOTE_TYPE
;
break
;
case
IsolationBehavior
:
:
PrivilegedAbout
:
options
.
mRemoteType
=
PRIVILEGEDABOUT_REMOTE_TYPE
;
break
;
case
IsolationBehavior
:
:
Extension
:
if
(
ExtensionPolicyService
:
:
GetSingleton
(
)
.
UseRemoteExtensions
(
)
)
{
options
.
mRemoteType
=
EXTENSION_REMOTE_TYPE
;
}
else
{
options
.
mRemoteType
=
NOT_REMOTE_TYPE
;
}
break
;
case
IsolationBehavior
:
:
File
:
if
(
StaticPrefs
:
:
browser_tabs_remote_separateFileUriProcess
(
)
)
{
options
.
mRemoteType
=
FILE_REMOTE_TYPE
;
}
else
{
options
.
mRemoteType
=
WEB_REMOTE_TYPE
;
}
break
;
case
IsolationBehavior
:
:
PrivilegedMozilla
:
options
.
mRemoteType
=
PRIVILEGEDMOZILLA_REMOTE_TYPE
;
break
;
case
IsolationBehavior
:
:
Parent
:
options
.
mRemoteType
=
NOT_REMOTE_TYPE
;
break
;
case
IsolationBehavior
:
:
Anywhere
:
options
.
mRemoteType
=
aCurrentRemoteType
;
break
;
case
IsolationBehavior
:
:
Inherit
:
MOZ_DIAGNOSTIC_ASSERT
(
aParentWindow
)
;
options
.
mRemoteType
=
aParentWindow
-
>
GetRemoteType
(
)
;
break
;
case
IsolationBehavior
:
:
WebContent
:
case
IsolationBehavior
:
:
AboutReader
:
MOZ_ASSERT_UNREACHABLE
(
)
;
return
Err
(
NS_ERROR_UNEXPECTED
)
;
case
IsolationBehavior
:
:
Error
:
return
Err
(
NS_ERROR_UNEXPECTED
)
;
}
if
(
options
.
mRemoteType
!
=
aCurrentRemoteType
&
&
(
options
.
mRemoteType
.
IsEmpty
(
)
|
|
aCurrentRemoteType
.
IsEmpty
(
)
)
)
{
options
.
mReplaceBrowsingContext
=
true
;
}
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Debug
(
"
Selecting
specific
remote
type
(
%
s
)
due
to
a
special
case
isolation
"
"
behavior
%
s
"
options
.
mRemoteType
.
get
(
)
IsolationBehaviorName
(
behavior
)
)
)
;
return
options
;
}
if
(
aCurrentRemoteType
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
aParentWindow
)
;
options
.
mReplaceBrowsingContext
=
true
;
}
if
(
!
aTopBC
-
>
UseRemoteSubframes
(
)
)
{
MOZ_ASSERT
(
!
aParentWindow
"
subframe
switch
when
UseRemoteSubframes
(
)
is
false
?
"
)
;
bool
singleToplevel
=
aTopBC
-
>
Group
(
)
-
>
Toplevels
(
)
.
Length
(
)
=
=
1
;
bool
isLargeAllocLoad
=
IsLargeAllocationLoad
(
aTopBC
aChannel
)
;
if
(
isLargeAllocLoad
&
&
singleToplevel
)
{
options
.
mRemoteType
=
LARGE_ALLOCATION_REMOTE_TYPE
;
options
.
mReplaceBrowsingContext
=
true
;
return
options
;
}
if
(
aCurrentRemoteType
=
=
LARGE_ALLOCATION_REMOTE_TYPE
)
{
if
(
!
singleToplevel
)
{
options
.
mRemoteType
=
LARGE_ALLOCATION_REMOTE_TYPE
;
return
options
;
}
options
.
mReplaceBrowsingContext
=
true
;
}
}
nsAutoCString
siteOriginNoSuffix
;
MOZ_TRY
(
resultOrPrecursor
-
>
GetSiteOriginNoSuffix
(
siteOriginNoSuffix
)
)
;
if
(
!
options
.
mReplaceBrowsingContext
)
{
auto
principalIsSameSite
=
[
&
]
(
nsIPrincipal
*
aDocumentPrincipal
)
-
>
bool
{
nsCOMPtr
<
nsIPrincipal
>
documentPrincipal
(
aDocumentPrincipal
)
;
if
(
nsCOMPtr
<
nsIPrincipal
>
precursor
=
documentPrincipal
-
>
GetPrecursorPrincipal
(
)
)
{
documentPrincipal
=
precursor
;
}
nsAutoCString
documentSiteOrigin
;
return
resultOrPrecursor
-
>
Equals
(
documentPrincipal
)
|
|
(
documentPrincipal
-
>
GetIsContentPrincipal
(
)
&
&
resultOrPrecursor
-
>
GetIsContentPrincipal
(
)
&
&
NS_SUCCEEDED
(
documentPrincipal
-
>
GetSiteOriginNoSuffix
(
documentSiteOrigin
)
)
&
&
documentSiteOrigin
=
=
siteOriginNoSuffix
)
;
}
;
AutoTArray
<
RefPtr
<
BrowsingContext
>
8
>
contexts
;
aTopBC
-
>
Group
(
)
-
>
GetToplevels
(
contexts
)
;
while
(
!
contexts
.
IsEmpty
(
)
)
{
auto
bc
=
contexts
.
PopLastElement
(
)
;
for
(
const
auto
&
wc
:
bc
-
>
GetWindowContexts
(
)
)
{
WindowGlobalParent
*
wgp
=
wc
-
>
Canonical
(
)
;
if
(
!
wgp
-
>
GetRemoteType
(
)
.
IsEmpty
(
)
&
&
principalIsSameSite
(
wgp
-
>
DocumentPrincipal
(
)
)
)
{
MOZ_LOG
(
gProcessIsolationLog
LogLevel
:
:
Debug
(
"
Found
existing
frame
with
matching
principal
"
"
(
remoteType
:
(
%
s
)
origin
:
%
s
)
"
PromiseFlatCString
(
wgp
-
>
GetRemoteType
(
)
)
.
get
(
)
OriginString
(
wgp
-
>
DocumentPrincipal
(
)
)
.
get
(
)
)
)
;
options
.
mRemoteType
=
wgp
-
>
GetRemoteType
(
)
;
return
options
;
}
contexts
.
AppendElements
(
wc
-
>
Children
(
)
)
;
}
}
}
nsAutoCString
originSuffix
;
OriginAttributes
attrs
=
resultOrPrecursor
-
>
OriginAttributesRef
(
)
;
attrs
.
StripAttributes
(
OriginAttributes
:
:
STRIP_FIRST_PARTY_DOMAIN
|
OriginAttributes
:
:
STRIP_PARITION_KEY
)
;
attrs
.
CreateSuffix
(
originSuffix
)
;
WebProcessType
webProcessType
=
WebProcessType
:
:
Web
;
if
(
ShouldIsolateSite
(
resultOrPrecursor
aTopBC
)
)
{
webProcessType
=
WebProcessType
:
:
WebIsolated
;
}
nsILoadInfo
:
:
CrossOriginOpenerPolicy
coop
=
nsILoadInfo
:
:
OPENER_POLICY_UNSAFE_NONE
;
if
(
aParentWindow
)
{
coop
=
aTopBC
-
>
GetOpenerPolicy
(
)
;
}
else
if
(
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannel
=
do_QueryInterface
(
aChannel
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
httpChannel
-
>
GetCrossOriginOpenerPolicy
(
&
coop
)
)
;
}
if
(
coop
=
=
nsILoadInfo
:
:
OPENER_POLICY_SAME_ORIGIN_EMBEDDER_POLICY_REQUIRE_CORP
)
{
webProcessType
=
WebProcessType
:
:
WebCoopCoep
;
}
switch
(
webProcessType
)
{
case
WebProcessType
:
:
Web
:
options
.
mRemoteType
=
WEB_REMOTE_TYPE
;
break
;
case
WebProcessType
:
:
WebIsolated
:
options
.
mRemoteType
=
FISSION_WEB_REMOTE_TYPE
"
=
"
_ns
+
siteOriginNoSuffix
+
originSuffix
;
break
;
case
WebProcessType
:
:
WebCoopCoep
:
options
.
mRemoteType
=
WITH_COOP_COEP_REMOTE_TYPE
"
=
"
_ns
+
siteOriginNoSuffix
+
originSuffix
;
break
;
}
return
options
;
}
void
AddHighValuePermission
(
nsIPrincipal
*
aResultPrincipal
const
nsACString
&
aPermissionType
)
{
RefPtr
<
PermissionManager
>
perms
=
PermissionManager
:
:
GetInstance
(
)
;
if
(
NS_WARN_IF
(
!
perms
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
resultOrPrecursor
(
aResultPrincipal
)
;
if
(
!
aResultPrincipal
-
>
GetIsContentPrincipal
(
)
)
{
resultOrPrecursor
=
aResultPrincipal
-
>
GetPrecursorPrincipal
(
)
;
if
(
!
resultOrPrecursor
)
{
return
;
}
}
nsAutoCString
siteOrigin
;
if
(
NS_FAILED
(
resultOrPrecursor
-
>
GetSiteOrigin
(
siteOrigin
)
)
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
sitePrincipal
=
BasePrincipal
:
:
CreateContentPrincipal
(
siteOrigin
)
;
if
(
!
sitePrincipal
|
|
!
sitePrincipal
-
>
GetIsContentPrincipal
(
)
)
{
return
;
}
MOZ_LOG
(
dom
:
:
gProcessIsolationLog
LogLevel
:
:
Verbose
(
"
Adding
%
s
Permission
for
site
'
%
s
'
"
aPermissionType
.
BeginReading
(
)
siteOrigin
.
get
(
)
)
)
;
uint32_t
expiration
=
0
;
if
(
aPermissionType
.
Equals
(
mozilla
:
:
dom
:
:
kHighValueCOOPPermission
)
)
{
expiration
=
StaticPrefs
:
:
fission_highValue_coop_expiration
(
)
;
}
else
if
(
aPermissionType
.
Equals
(
mozilla
:
:
dom
:
:
kHighValueHasSavedLoginPermission
)
|
|
aPermissionType
.
Equals
(
mozilla
:
:
dom
:
:
kHighValueIsLoggedInPermission
)
)
{
expiration
=
StaticPrefs
:
:
fission_highValue_login_expiration
(
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
permission
type
"
)
;
}
int64_t
expirationTime
=
(
PR_Now
(
)
/
PR_USEC_PER_MSEC
)
+
(
int64_t
(
expiration
)
*
PR_MSEC_PER_SEC
)
;
Unused
<
<
perms
-
>
AddFromPrincipal
(
sitePrincipal
aPermissionType
nsIPermissionManager
:
:
ALLOW_ACTION
nsIPermissionManager
:
:
EXPIRE_TIME
expirationTime
)
;
}
void
AddHighValuePermission
(
const
nsACString
&
aOrigin
const
nsACString
&
aPermissionType
)
{
nsIScriptSecurityManager
*
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
ssm
-
>
CreateContentPrincipalFromOrigin
(
aOrigin
getter_AddRefs
(
principal
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
AddHighValuePermission
(
principal
aPermissionType
)
;
}
bool
IsIsolateHighValueSiteEnabled
(
)
{
return
mozilla
:
:
FissionAutostart
(
)
&
&
WebContentIsolationStrategy
(
StaticPrefs
:
:
fission_webContentIsolationStrategy
(
)
)
=
=
WebContentIsolationStrategy
:
:
IsolateHighValue
;
}
}
