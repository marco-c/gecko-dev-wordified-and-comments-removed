#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundParent
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
NuwaParent
.
h
"
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
dom
;
using
namespace
IPC
;
namespace
mozilla
{
namespace
dom
{
NuwaParent
*
NuwaParent
:
:
Alloc
(
)
{
RefPtr
<
NuwaParent
>
actor
=
new
NuwaParent
(
)
;
return
actor
.
forget
(
)
.
take
(
)
;
}
bool
NuwaParent
:
:
ActorConstructed
(
mozilla
:
:
dom
:
:
PNuwaParent
*
aActor
)
{
NuwaParent
*
actor
=
static_cast
<
NuwaParent
*
>
(
aActor
)
;
actor
-
>
ActorConstructed
(
)
;
return
true
;
}
bool
NuwaParent
:
:
Dealloc
(
mozilla
:
:
dom
:
:
PNuwaParent
*
aActor
)
{
RefPtr
<
NuwaParent
>
actor
=
dont_AddRef
(
static_cast
<
NuwaParent
*
>
(
aActor
)
)
;
return
true
;
}
NuwaParent
:
:
NuwaParent
(
)
:
mBlocked
(
false
)
mMonitor
(
"
NuwaParent
"
)
mClonedActor
(
nullptr
)
mWorkerThread
(
do_GetCurrentThread
(
)
)
mNewProcessPid
(
0
)
{
AssertIsOnBackgroundThread
(
)
;
}
NuwaParent
:
:
~
NuwaParent
(
)
{
MOZ_ASSERT
(
!
mContentParent
)
;
}
inline
void
NuwaParent
:
:
AssertIsOnWorkerThread
(
)
{
nsCOMPtr
<
nsIThread
>
currentThread
=
do_GetCurrentThread
(
)
;
MOZ_ASSERT
(
currentThread
=
=
mWorkerThread
)
;
}
bool
NuwaParent
:
:
ActorConstructed
(
)
{
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
Manager
(
)
)
;
MOZ_ASSERT
(
!
mContentParent
)
;
mContentParent
=
BackgroundParent
:
:
GetContentParent
(
Manager
(
)
)
;
if
(
!
mContentParent
)
{
return
false
;
}
mContentParent
-
>
SetNuwaParent
(
this
)
;
return
true
;
}
mozilla
:
:
ipc
:
:
IProtocol
*
NuwaParent
:
:
CloneProtocol
(
Channel
*
aChannel
ProtocolCloneContext
*
aCtx
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
NuwaParent
>
self
=
this
;
MonitorAutoLock
lock
(
mMonitor
)
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
self
]
(
)
-
>
void
{
MonitorAutoLock
lock
(
self
-
>
mMonitor
)
;
self
-
>
mClonedActor
=
self
-
>
Alloc
(
)
;
lock
.
Notify
(
)
;
}
)
;
MOZ_ASSERT
(
runnable
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mWorkerThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
)
;
while
(
!
mClonedActor
)
{
lock
.
Wait
(
)
;
}
RefPtr
<
NuwaParent
>
actor
=
mClonedActor
;
mClonedActor
=
nullptr
;
runnable
=
NS_NewRunnableFunction
(
[
actor
]
(
)
-
>
void
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
nested
=
NS_NewRunnableFunction
(
[
actor
]
(
)
-
>
void
{
AssertIsOnBackgroundThread
(
)
;
actor
-
>
ActorConstructed
(
)
;
mozilla
:
:
Unused
<
<
actor
-
>
Send__delete__
(
actor
)
;
}
)
;
MOZ_ASSERT
(
nested
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
actor
-
>
mWorkerThread
-
>
Dispatch
(
nested
NS_DISPATCH_NORMAL
)
)
)
;
}
)
;
MOZ_ASSERT
(
runnable
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
)
)
)
;
return
actor
;
}
void
NuwaParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnWorkerThread
(
)
;
RefPtr
<
NuwaParent
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
self
]
(
)
-
>
void
{
RefPtr
<
ContentParent
>
contentParent
=
self
-
>
mContentParent
;
contentParent
-
>
SetNuwaParent
(
nullptr
)
;
self
-
>
mContentParent
=
nullptr
;
}
)
;
MOZ_ASSERT
(
runnable
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
)
)
)
;
}
bool
NuwaParent
:
:
RecvNotifyReady
(
)
{
#
ifdef
MOZ_NUWA_PROCESS
if
(
!
mContentParent
|
|
!
mContentParent
-
>
IsNuwaProcess
(
)
)
{
NS_ERROR
(
"
Received
NotifyReady
(
)
message
from
a
non
-
Nuwa
process
.
"
)
;
return
false
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewNonOwningRunnableMethod
(
mContentParent
.
get
(
)
&
ContentParent
:
:
OnNuwaReady
)
;
MOZ_ASSERT
(
runnable
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
)
)
)
;
return
true
;
#
else
NS_ERROR
(
"
NuwaParent
:
:
RecvNotifyReady
(
)
not
implemented
!
"
)
;
return
false
;
#
endif
}
bool
NuwaParent
:
:
RecvAddNewProcess
(
const
uint32_t
&
aPid
nsTArray
<
ProtocolFdMapping
>
&
&
aFds
)
{
#
ifdef
MOZ_NUWA_PROCESS
if
(
!
mContentParent
|
|
!
mContentParent
-
>
IsNuwaProcess
(
)
)
{
NS_ERROR
(
"
Received
AddNewProcess
(
)
message
from
a
non
-
Nuwa
process
.
"
)
;
return
false
;
}
mNewProcessPid
=
aPid
;
mNewProcessFds
-
>
SwapElements
(
aFds
)
;
MonitorAutoLock
lock
(
mMonitor
)
;
if
(
mBlocked
)
{
mMonitor
.
Notify
(
)
;
mBlocked
=
false
;
}
else
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewNonOwningRunnableMethodWithArgs
<
uint32_t
UniquePtr
<
nsTArray
<
ProtocolFdMapping
>
>
&
&
>
(
mContentParent
.
get
(
)
&
ContentParent
:
:
OnNewProcessCreated
mNewProcessPid
Move
(
mNewProcessFds
)
)
;
MOZ_ASSERT
(
runnable
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
NS_DispatchToMainThread
(
runnable
)
)
)
;
}
return
true
;
#
else
NS_ERROR
(
"
NuwaParent
:
:
RecvAddNewProcess
(
)
not
implemented
!
"
)
;
return
false
;
#
endif
}
bool
NuwaParent
:
:
ForkNewProcess
(
uint32_t
&
aPid
UniquePtr
<
nsTArray
<
ProtocolFdMapping
>
>
&
&
aFds
bool
aBlocking
)
{
MOZ_ASSERT
(
mWorkerThread
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mNewProcessFds
=
Move
(
aFds
)
;
RefPtr
<
NuwaParent
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
runnable
=
NS_NewRunnableFunction
(
[
self
]
(
)
-
>
void
{
mozilla
:
:
Unused
<
<
self
-
>
SendFork
(
)
;
}
)
;
MOZ_ASSERT
(
runnable
)
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
mWorkerThread
-
>
Dispatch
(
runnable
NS_DISPATCH_NORMAL
)
)
)
;
if
(
!
aBlocking
)
{
return
false
;
}
MonitorAutoLock
lock
(
mMonitor
)
;
mBlocked
=
true
;
while
(
mBlocked
)
{
lock
.
Wait
(
)
;
}
if
(
!
mNewProcessPid
)
{
return
false
;
}
aPid
=
mNewProcessPid
;
aFds
=
Move
(
mNewProcessFds
)
;
mNewProcessPid
=
0
;
return
true
;
}
}
}
