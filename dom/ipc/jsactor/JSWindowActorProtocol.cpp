#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
JSActorBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSActorService
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorBinding
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorChild
.
h
"
#
include
"
mozilla
/
dom
/
JSWindowActorProtocol
.
h
"
#
include
"
mozilla
/
dom
/
PContent
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
extensions
/
MatchPattern
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
JSActorProtocolUtils
.
h
"
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
JSWindowActorProtocol
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
JSWindowActorProtocol
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
JSWindowActorProtocol
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
JSWindowActorProtocol
)
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromIPC
(
const
JSWindowActorInfo
&
aInfo
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aInfo
.
name
(
)
)
;
JSActorProtocolUtils
:
:
FromIPCShared
(
proto
aInfo
)
;
proto
-
>
mIncludeChrome
=
false
;
proto
-
>
mAllFrames
=
aInfo
.
allFrames
(
)
;
proto
-
>
mMatches
=
aInfo
.
matches
(
)
.
Clone
(
)
;
proto
-
>
mMessageManagerGroups
=
aInfo
.
messageManagerGroups
(
)
.
Clone
(
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
aInfo
.
events
(
)
.
Length
(
)
)
;
for
(
auto
&
ipc
:
aInfo
.
events
(
)
)
{
auto
event
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
event
-
>
mName
.
Assign
(
ipc
.
name
(
)
)
;
event
-
>
mFlags
.
mCapture
=
ipc
.
capture
(
)
;
event
-
>
mFlags
.
mInSystemGroup
=
ipc
.
systemGroup
(
)
;
event
-
>
mFlags
.
mAllowUntrustedEvents
=
ipc
.
allowUntrusted
(
)
;
if
(
ipc
.
passive
(
)
)
{
event
-
>
mPassive
.
Construct
(
ipc
.
passive
(
)
.
value
(
)
)
;
}
event
-
>
mCreateActor
=
ipc
.
createActor
(
)
;
}
return
proto
.
forget
(
)
;
}
JSWindowActorInfo
JSWindowActorProtocol
:
:
ToIPC
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
JSWindowActorInfo
info
;
JSActorProtocolUtils
:
:
ToIPCShared
(
info
this
)
;
info
.
allFrames
(
)
=
mAllFrames
;
info
.
matches
(
)
=
mMatches
.
Clone
(
)
;
info
.
messageManagerGroups
(
)
=
mMessageManagerGroups
.
Clone
(
)
;
info
.
events
(
)
.
SetCapacity
(
mChild
.
mEvents
.
Length
(
)
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
auto
ipc
=
info
.
events
(
)
.
AppendElement
(
)
;
ipc
-
>
name
(
)
.
Assign
(
event
.
mName
)
;
ipc
-
>
capture
(
)
=
event
.
mFlags
.
mCapture
;
ipc
-
>
systemGroup
(
)
=
event
.
mFlags
.
mInSystemGroup
;
ipc
-
>
allowUntrusted
(
)
=
event
.
mFlags
.
mAllowUntrustedEvents
;
if
(
event
.
mPassive
.
WasPassed
(
)
)
{
ipc
-
>
passive
(
)
=
Some
(
event
.
mPassive
.
Value
(
)
)
;
}
ipc
-
>
createActor
(
)
=
event
.
mCreateActor
;
}
return
info
;
}
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
const
nsACString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aName
)
;
if
(
!
JSActorProtocolUtils
:
:
FromWebIDLOptionsShared
(
proto
aOptions
aRv
)
)
{
return
nullptr
;
}
proto
-
>
mAllFrames
=
aOptions
.
mAllFrames
;
proto
-
>
mIncludeChrome
=
aOptions
.
mIncludeChrome
;
if
(
aOptions
.
mMatches
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
aOptions
.
mMatches
.
Value
(
)
.
Length
(
)
)
;
proto
-
>
mMatches
=
aOptions
.
mMatches
.
Value
(
)
;
}
if
(
aOptions
.
mMessageManagerGroups
.
WasPassed
(
)
)
{
proto
-
>
mMessageManagerGroups
=
aOptions
.
mMessageManagerGroups
.
Value
(
)
;
}
if
(
aOptions
.
mChild
.
WasPassed
(
)
&
&
aOptions
.
mChild
.
Value
(
)
.
mEvents
.
WasPassed
(
)
)
{
auto
&
entries
=
aOptions
.
mChild
.
Value
(
)
.
mEvents
.
Value
(
)
.
Entries
(
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
entries
.
Length
(
)
)
;
for
(
auto
&
entry
:
entries
)
{
if
(
entry
.
mValue
.
mOnce
)
{
aRv
.
ThrowNotSupportedError
(
"
mOnce
is
not
supported
"
)
;
return
nullptr
;
}
EventDecl
*
evt
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
evt
-
>
mName
=
entry
.
mKey
;
evt
-
>
mFlags
.
mCapture
=
entry
.
mValue
.
mCapture
;
evt
-
>
mFlags
.
mInSystemGroup
=
entry
.
mValue
.
mMozSystemGroup
;
evt
-
>
mFlags
.
mAllowUntrustedEvents
=
entry
.
mValue
.
mWantUntrusted
.
WasPassed
(
)
?
entry
.
mValue
.
mWantUntrusted
.
Value
(
)
:
false
;
if
(
entry
.
mValue
.
mPassive
.
WasPassed
(
)
)
{
evt
-
>
mPassive
.
Construct
(
entry
.
mValue
.
mPassive
.
Value
(
)
)
;
}
evt
-
>
mCreateActor
=
entry
.
mValue
.
mCreateActor
;
}
}
return
proto
.
forget
(
)
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
HandleEvent
(
Event
*
aEvent
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
EventTarget
*
target
=
aEvent
-
>
GetOriginalTarget
(
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
target
-
>
GetOwnerGlobal
(
)
)
;
if
(
!
inner
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
WindowGlobalChild
>
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aEvent
-
>
ShouldIgnoreChromeEventTargetListener
(
)
)
{
return
NS_OK
;
}
RefPtr
<
JSActor
>
actor
=
wgc
-
>
GetExistingActor
(
mName
)
;
if
(
!
actor
)
{
bool
createActor
=
true
;
nsAutoString
typeStr
;
aEvent
-
>
GetType
(
typeStr
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
if
(
event
.
mName
=
=
typeStr
)
{
createActor
=
event
.
mCreateActor
;
break
;
}
}
if
(
createActor
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
actor
=
wgc
-
>
GetActor
(
jsapi
.
cx
(
)
mName
IgnoreErrors
(
)
)
;
}
}
if
(
!
actor
|
|
NS_WARN_IF
(
!
actor
-
>
GetWrapperPreserveColor
(
)
)
)
{
return
NS_OK
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
RootingCx
(
)
JS
:
:
GetNonCCWObjectGlobal
(
actor
-
>
GetWrapper
(
)
)
)
;
RefPtr
<
EventListener
>
eventListener
=
new
EventListener
(
actor
-
>
GetWrapper
(
)
global
nullptr
nullptr
)
;
eventListener
-
>
HandleEvent
(
*
aEvent
"
JSWindowActorProtocol
:
:
HandleEvent
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
aSubject
)
;
RefPtr
<
WindowGlobalChild
>
wgc
;
if
(
!
inner
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
do_QueryInterface
(
aSubject
)
;
if
(
NS_WARN_IF
(
!
outer
)
)
{
nsContentUtils
:
:
LogSimpleConsoleError
(
NS_ConvertUTF8toUTF16
(
nsPrintfCString
(
"
JSWindowActor
%
s
:
expected
window
subject
for
topic
'
%
s
'
.
"
mName
.
get
(
)
aTopic
)
)
"
JSActor
"
_ns
false
true
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
outer
-
>
GetCurrentInnerWindow
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
wgc
=
outer
-
>
GetCurrentInnerWindow
(
)
-
>
GetWindowGlobalChild
(
)
;
}
else
{
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
}
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
RefPtr
<
JSActor
>
actor
=
wgc
-
>
GetActor
(
jsapi
.
cx
(
)
mName
IgnoreErrors
(
)
)
;
if
(
!
actor
|
|
NS_WARN_IF
(
!
actor
-
>
GetWrapperPreserveColor
(
)
)
)
{
return
NS_OK
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
jsapi
.
cx
(
)
JS
:
:
GetNonCCWObjectGlobal
(
actor
-
>
GetWrapper
(
)
)
)
;
RefPtr
<
MozObserverCallback
>
observerCallback
=
new
MozObserverCallback
(
actor
-
>
GetWrapper
(
)
global
nullptr
nullptr
)
;
observerCallback
-
>
Observe
(
aSubject
nsDependentCString
(
aTopic
)
aData
?
nsDependentString
(
aData
)
:
VoidString
(
)
)
;
return
NS_OK
;
}
void
JSWindowActorProtocol
:
:
RegisterListenersFor
(
EventTarget
*
aTarget
)
{
EventListenerManager
*
elm
=
aTarget
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
AddEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
event
.
mPassive
)
;
}
}
void
JSWindowActorProtocol
:
:
UnregisterListenersFor
(
EventTarget
*
aTarget
)
{
EventListenerManager
*
elm
=
aTarget
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
RemoveEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
)
;
}
}
void
JSWindowActorProtocol
:
:
AddObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
AddObserver
(
this
topic
.
get
(
)
false
)
;
}
}
void
JSWindowActorProtocol
:
:
RemoveObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
RemoveObserver
(
this
topic
.
get
(
)
)
;
}
}
extensions
:
:
MatchPatternSetCore
*
JSWindowActorProtocol
:
:
GetURIMatcher
(
)
{
if
(
mURIMatcher
|
|
mMatches
.
IsEmpty
(
)
)
{
return
mURIMatcher
;
}
nsTArray
<
RefPtr
<
extensions
:
:
MatchPatternCore
>
>
patterns
(
mMatches
.
Length
(
)
)
;
for
(
const
nsString
&
pattern
:
mMatches
)
{
patterns
.
AppendElement
(
new
extensions
:
:
MatchPatternCore
(
pattern
false
false
IgnoreErrors
(
)
)
)
;
}
mURIMatcher
=
new
extensions
:
:
MatchPatternSetCore
(
std
:
:
move
(
patterns
)
)
;
return
mURIMatcher
;
}
bool
JSWindowActorProtocol
:
:
RemoteTypePrefixMatches
(
const
nsDependentCSubstring
&
aRemoteType
)
{
for
(
auto
&
remoteType
:
mRemoteTypes
)
{
if
(
StringBeginsWith
(
aRemoteType
remoteType
)
)
{
return
true
;
}
}
return
false
;
}
bool
JSWindowActorProtocol
:
:
MessageManagerGroupMatches
(
BrowsingContext
*
aBrowsingContext
)
{
BrowsingContext
*
top
=
aBrowsingContext
-
>
Top
(
)
;
for
(
auto
&
group
:
mMessageManagerGroups
)
{
if
(
group
=
=
top
-
>
GetMessageManagerGroup
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
JSWindowActorProtocol
:
:
Matches
(
BrowsingContext
*
aBrowsingContext
nsIURI
*
aURI
const
nsACString
&
aRemoteType
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aBrowsingContext
"
DocShell
without
a
BrowsingContext
!
"
)
;
MOZ_ASSERT
(
aURI
"
Must
have
URI
!
"
)
;
if
(
!
mAllFrames
&
&
aBrowsingContext
-
>
GetParent
(
)
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Window
protocol
'
%
s
'
doesn
'
t
match
subframes
"
mName
.
get
(
)
)
)
;
return
false
;
}
if
(
!
mIncludeChrome
&
&
!
aBrowsingContext
-
>
IsContent
(
)
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Window
protocol
'
%
s
'
doesn
'
t
match
chrome
browsing
contexts
"
mName
.
get
(
)
)
)
;
return
false
;
}
if
(
!
mRemoteTypes
.
IsEmpty
(
)
&
&
!
RemoteTypePrefixMatches
(
RemoteTypePrefix
(
aRemoteType
)
)
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Window
protocol
'
%
s
'
doesn
'
t
match
remote
type
'
%
s
'
"
mName
.
get
(
)
PromiseFlatCString
(
aRemoteType
)
.
get
(
)
)
)
;
return
false
;
}
if
(
!
mMessageManagerGroups
.
IsEmpty
(
)
&
&
!
MessageManagerGroupMatches
(
aBrowsingContext
)
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Window
protocol
'
%
s
'
doesn
'
t
match
message
manager
group
"
mName
.
get
(
)
)
)
;
return
false
;
}
if
(
extensions
:
:
MatchPatternSetCore
*
uriMatcher
=
GetURIMatcher
(
)
)
{
if
(
!
uriMatcher
-
>
Matches
(
aURI
)
)
{
aRv
.
ThrowNotSupportedError
(
nsPrintfCString
(
"
Window
protocol
'
%
s
'
doesn
'
t
match
uri
%
s
"
mName
.
get
(
)
nsContentUtils
:
:
TruncatedURLForDisplay
(
aURI
)
.
get
(
)
)
)
;
return
false
;
}
}
return
true
;
}
}
