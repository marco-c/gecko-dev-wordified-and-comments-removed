#
include
"
mozilla
/
dom
/
JSActorService
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
JSWindowActorProtocol
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
JSWindowActorProtocol
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
JSWindowActorProtocol
)
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
JSWindowActorProtocol
mURIMatcher
)
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromIPC
(
const
JSWindowActorInfo
&
aInfo
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsContentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aInfo
.
name
(
)
)
;
proto
-
>
mIncludeChrome
=
false
;
proto
-
>
mAllFrames
=
aInfo
.
allFrames
(
)
;
proto
-
>
mMatches
=
aInfo
.
matches
(
)
.
Clone
(
)
;
proto
-
>
mRemoteTypes
=
aInfo
.
remoteTypes
(
)
.
Clone
(
)
;
proto
-
>
mMessageManagerGroups
=
aInfo
.
messageManagerGroups
(
)
.
Clone
(
)
;
proto
-
>
mChild
.
mModuleURI
=
aInfo
.
url
(
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
aInfo
.
events
(
)
.
Length
(
)
)
;
for
(
auto
&
ipc
:
aInfo
.
events
(
)
)
{
auto
event
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
event
-
>
mName
.
Assign
(
ipc
.
name
(
)
)
;
event
-
>
mFlags
.
mCapture
=
ipc
.
capture
(
)
;
event
-
>
mFlags
.
mInSystemGroup
=
ipc
.
systemGroup
(
)
;
event
-
>
mFlags
.
mAllowUntrustedEvents
=
ipc
.
allowUntrusted
(
)
;
if
(
ipc
.
passive
(
)
)
{
event
-
>
mPassive
.
Construct
(
ipc
.
passive
(
)
.
value
(
)
)
;
}
}
proto
-
>
mChild
.
mObservers
=
aInfo
.
observers
(
)
.
Clone
(
)
;
return
proto
.
forget
(
)
;
}
JSWindowActorInfo
JSWindowActorProtocol
:
:
ToIPC
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
JSWindowActorInfo
info
;
info
.
name
(
)
=
mName
;
info
.
allFrames
(
)
=
mAllFrames
;
info
.
matches
(
)
=
mMatches
.
Clone
(
)
;
info
.
remoteTypes
(
)
=
mRemoteTypes
.
Clone
(
)
;
info
.
messageManagerGroups
(
)
=
mMessageManagerGroups
.
Clone
(
)
;
info
.
url
(
)
=
mChild
.
mModuleURI
;
info
.
events
(
)
.
SetCapacity
(
mChild
.
mEvents
.
Length
(
)
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
auto
ipc
=
info
.
events
(
)
.
AppendElement
(
)
;
ipc
-
>
name
(
)
.
Assign
(
event
.
mName
)
;
ipc
-
>
capture
(
)
=
event
.
mFlags
.
mCapture
;
ipc
-
>
systemGroup
(
)
=
event
.
mFlags
.
mInSystemGroup
;
ipc
-
>
allowUntrusted
(
)
=
event
.
mFlags
.
mAllowUntrustedEvents
;
if
(
event
.
mPassive
.
WasPassed
(
)
)
{
ipc
-
>
passive
(
)
=
Some
(
event
.
mPassive
.
Value
(
)
)
;
}
}
info
.
observers
(
)
=
mChild
.
mObservers
.
Clone
(
)
;
return
info
;
}
already_AddRefed
<
JSWindowActorProtocol
>
JSWindowActorProtocol
:
:
FromWebIDLOptions
(
const
nsACString
&
aName
const
WindowActorOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
JSWindowActorProtocol
>
proto
=
new
JSWindowActorProtocol
(
aName
)
;
proto
-
>
mAllFrames
=
aOptions
.
mAllFrames
;
proto
-
>
mIncludeChrome
=
aOptions
.
mIncludeChrome
;
if
(
aOptions
.
mMatches
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
aOptions
.
mMatches
.
Value
(
)
.
Length
(
)
)
;
proto
-
>
mMatches
=
aOptions
.
mMatches
.
Value
(
)
;
}
if
(
aOptions
.
mRemoteTypes
.
WasPassed
(
)
)
{
MOZ_ASSERT
(
aOptions
.
mRemoteTypes
.
Value
(
)
.
Length
(
)
)
;
proto
-
>
mRemoteTypes
=
aOptions
.
mRemoteTypes
.
Value
(
)
;
}
if
(
aOptions
.
mMessageManagerGroups
.
WasPassed
(
)
)
{
proto
-
>
mMessageManagerGroups
=
aOptions
.
mMessageManagerGroups
.
Value
(
)
;
}
if
(
aOptions
.
mParent
.
WasPassed
(
)
)
{
proto
-
>
mParent
.
mModuleURI
.
emplace
(
aOptions
.
mParent
.
Value
(
)
.
mModuleURI
)
;
}
if
(
aOptions
.
mChild
.
WasPassed
(
)
)
{
proto
-
>
mChild
.
mModuleURI
.
emplace
(
aOptions
.
mChild
.
Value
(
)
.
mModuleURI
)
;
}
if
(
!
aOptions
.
mChild
.
WasPassed
(
)
&
&
!
aOptions
.
mParent
.
WasPassed
(
)
)
{
aRv
.
ThrowNotSupportedError
(
"
No
point
registering
an
actor
with
neither
child
nor
parent
"
"
specifications
.
"
)
;
return
nullptr
;
}
if
(
aOptions
.
mChild
.
WasPassed
(
)
&
&
aOptions
.
mChild
.
Value
(
)
.
mEvents
.
WasPassed
(
)
)
{
auto
&
entries
=
aOptions
.
mChild
.
Value
(
)
.
mEvents
.
Value
(
)
.
Entries
(
)
;
proto
-
>
mChild
.
mEvents
.
SetCapacity
(
entries
.
Length
(
)
)
;
for
(
auto
&
entry
:
entries
)
{
if
(
entry
.
mValue
.
mOnce
)
{
aRv
.
ThrowNotSupportedError
(
"
mOnce
is
not
supported
"
)
;
return
nullptr
;
}
EventDecl
*
evt
=
proto
-
>
mChild
.
mEvents
.
AppendElement
(
)
;
evt
-
>
mName
=
entry
.
mKey
;
evt
-
>
mFlags
.
mCapture
=
entry
.
mValue
.
mCapture
;
evt
-
>
mFlags
.
mInSystemGroup
=
entry
.
mValue
.
mMozSystemGroup
;
evt
-
>
mFlags
.
mAllowUntrustedEvents
=
entry
.
mValue
.
mWantUntrusted
.
WasPassed
(
)
?
entry
.
mValue
.
mWantUntrusted
.
Value
(
)
:
false
;
if
(
entry
.
mValue
.
mPassive
.
WasPassed
(
)
)
{
evt
-
>
mPassive
.
Construct
(
entry
.
mValue
.
mPassive
.
Value
(
)
)
;
}
}
}
if
(
aOptions
.
mChild
.
WasPassed
(
)
&
&
aOptions
.
mChild
.
Value
(
)
.
mObservers
.
WasPassed
(
)
)
{
proto
-
>
mChild
.
mObservers
=
aOptions
.
mChild
.
Value
(
)
.
mObservers
.
Value
(
)
;
}
return
proto
.
forget
(
)
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
HandleEvent
(
Event
*
aEvent
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
EventTarget
*
target
=
aEvent
-
>
GetOriginalTarget
(
)
;
if
(
NS_WARN_IF
(
!
target
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
target
-
>
GetOwnerGlobal
(
)
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
WindowGlobalChild
>
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
JSWindowActorChild
>
actor
=
wgc
-
>
GetActor
(
mName
error
)
;
if
(
error
.
Failed
(
)
)
{
nsresult
rv
=
error
.
StealNSResult
(
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
RootingCx
(
)
JS
:
:
GetNonCCWObjectGlobal
(
actor
-
>
GetWrapper
(
)
)
)
;
RefPtr
<
EventListener
>
eventListener
=
new
EventListener
(
actor
-
>
GetWrapper
(
)
global
nullptr
nullptr
)
;
eventListener
-
>
HandleEvent
(
*
aEvent
"
JSWindowActorProtocol
:
:
HandleEvent
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
JSWindowActorProtocol
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
aSubject
)
;
RefPtr
<
WindowGlobalChild
>
wgc
;
if
(
!
inner
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
do_QueryInterface
(
aSubject
)
;
if
(
NS_WARN_IF
(
!
outer
)
|
|
NS_WARN_IF
(
!
outer
-
>
GetCurrentInnerWindow
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
wgc
=
outer
-
>
GetCurrentInnerWindow
(
)
-
>
GetWindowGlobalChild
(
)
;
}
else
{
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
}
if
(
NS_WARN_IF
(
!
wgc
)
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
error
;
RefPtr
<
JSWindowActorChild
>
actor
=
wgc
-
>
GetActor
(
mName
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
nsresult
rv
=
error
.
StealNSResult
(
)
;
if
(
rv
=
=
NS_ERROR_NOT_AVAILABLE
)
{
return
NS_OK
;
}
return
rv
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
RootingCx
(
)
JS
:
:
GetNonCCWObjectGlobal
(
actor
-
>
GetWrapper
(
)
)
)
;
RefPtr
<
MozObserverCallback
>
observerCallback
=
new
MozObserverCallback
(
actor
-
>
GetWrapper
(
)
global
nullptr
nullptr
)
;
observerCallback
-
>
Observe
(
aSubject
nsDependentCString
(
aTopic
)
aData
?
nsDependentString
(
aData
)
:
VoidString
(
)
)
;
return
NS_OK
;
}
void
JSWindowActorProtocol
:
:
RegisterListenersFor
(
EventTarget
*
aTarget
)
{
EventListenerManager
*
elm
=
aTarget
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
AddEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
event
.
mPassive
)
;
}
}
void
JSWindowActorProtocol
:
:
UnregisterListenersFor
(
EventTarget
*
aTarget
)
{
EventListenerManager
*
elm
=
aTarget
-
>
GetOrCreateListenerManager
(
)
;
for
(
auto
&
event
:
mChild
.
mEvents
)
{
elm
-
>
RemoveEventListenerByType
(
EventListenerHolder
(
this
)
event
.
mName
event
.
mFlags
)
;
}
}
void
JSWindowActorProtocol
:
:
AddObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
AddObserver
(
this
topic
.
get
(
)
false
)
;
}
}
void
JSWindowActorProtocol
:
:
RemoveObservers
(
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
for
(
auto
&
topic
:
mChild
.
mObservers
)
{
os
-
>
RemoveObserver
(
this
topic
.
get
(
)
)
;
}
}
extensions
:
:
MatchPatternSet
*
JSWindowActorProtocol
:
:
GetURIMatcher
(
)
{
if
(
mURIMatcher
|
|
mMatches
.
IsEmpty
(
)
)
{
return
mURIMatcher
;
}
AutoJSAPI
jsapi
;
MOZ_ALWAYS_TRUE
(
jsapi
.
Init
(
xpc
:
:
PrivilegedJunkScope
(
)
)
)
;
GlobalObject
global
(
jsapi
.
cx
(
)
xpc
:
:
PrivilegedJunkScope
(
)
)
;
nsTArray
<
OwningStringOrMatchPattern
>
patterns
;
patterns
.
SetCapacity
(
mMatches
.
Length
(
)
)
;
for
(
nsString
&
s
:
mMatches
)
{
auto
entry
=
patterns
.
AppendElement
(
)
;
entry
-
>
SetAsString
(
)
=
s
;
}
MatchPatternOptions
matchPatternOptions
;
matchPatternOptions
.
mRestrictSchemes
=
false
;
mURIMatcher
=
extensions
:
:
MatchPatternSet
:
:
Constructor
(
global
patterns
matchPatternOptions
IgnoreErrors
(
)
)
;
return
mURIMatcher
;
}
bool
JSWindowActorProtocol
:
:
RemoteTypePrefixMatches
(
const
nsDependentSubstring
&
aRemoteType
)
{
for
(
auto
&
remoteType
:
mRemoteTypes
)
{
if
(
StringBeginsWith
(
aRemoteType
remoteType
)
)
{
return
true
;
}
}
return
false
;
}
bool
JSWindowActorProtocol
:
:
MessageManagerGroupMatches
(
BrowsingContext
*
aBrowsingContext
)
{
BrowsingContext
*
top
=
aBrowsingContext
-
>
Top
(
)
;
for
(
auto
&
group
:
mMessageManagerGroups
)
{
if
(
group
=
=
top
-
>
GetMessageManagerGroup
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
JSWindowActorProtocol
:
:
Matches
(
BrowsingContext
*
aBrowsingContext
nsIURI
*
aURI
const
nsAString
&
aRemoteType
)
{
MOZ_ASSERT
(
aBrowsingContext
"
DocShell
without
a
BrowsingContext
!
"
)
;
MOZ_ASSERT
(
aURI
"
Must
have
URI
!
"
)
;
if
(
!
mAllFrames
&
&
aBrowsingContext
-
>
GetParent
(
)
)
{
return
false
;
}
if
(
!
mIncludeChrome
&
&
!
aBrowsingContext
-
>
IsContent
(
)
)
{
return
false
;
}
if
(
!
mRemoteTypes
.
IsEmpty
(
)
&
&
!
RemoteTypePrefixMatches
(
RemoteTypePrefix
(
aRemoteType
)
)
)
{
return
false
;
}
if
(
!
mMessageManagerGroups
.
IsEmpty
(
)
&
&
!
MessageManagerGroupMatches
(
aBrowsingContext
)
)
{
return
false
;
}
if
(
extensions
:
:
MatchPatternSet
*
uriMatcher
=
GetURIMatcher
(
)
)
{
if
(
!
uriMatcher
-
>
Matches
(
aURI
)
)
{
return
false
;
}
}
return
true
;
}
}
}
