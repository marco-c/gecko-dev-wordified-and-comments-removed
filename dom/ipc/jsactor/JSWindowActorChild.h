#
ifndef
mozilla_dom_JSWindowActorChild_h
#
define
mozilla_dom_JSWindowActorChild_h
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
JSActor
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsStringFwd
.
h
"
class
nsIDocShell
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
template
<
typename
>
struct
Nullable
;
class
BrowsingContext
;
class
Document
;
class
WindowProxyHolder
;
}
}
namespace
mozilla
:
:
dom
{
class
JSWindowActorChild
final
:
public
JSActor
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
JSWindowActorChild
JSActor
)
explicit
JSWindowActorChild
(
nsISupports
*
aGlobal
=
nullptr
)
:
JSActor
(
aGlobal
)
{
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
already_AddRefed
<
JSWindowActorChild
>
Constructor
(
GlobalObject
&
aGlobal
)
{
return
MakeAndAddRef
<
JSWindowActorChild
>
(
aGlobal
.
GetAsSupports
(
)
)
;
}
WindowGlobalChild
*
GetManager
(
)
const
;
WindowContext
*
GetWindowContext
(
)
const
;
void
Init
(
const
nsACString
&
aName
WindowGlobalChild
*
aManager
)
;
void
ClearManager
(
)
override
;
Document
*
GetDocument
(
ErrorResult
&
aRv
)
;
BrowsingContext
*
GetBrowsingContext
(
ErrorResult
&
aRv
)
;
nsIDocShell
*
GetDocShell
(
ErrorResult
&
aRv
)
;
Nullable
<
WindowProxyHolder
>
GetContentWindow
(
ErrorResult
&
aRv
)
;
protected
:
void
SendRawMessage
(
const
JSActorMessageMeta
&
aMeta
UniquePtr
<
ipc
:
:
StructuredCloneData
>
aData
UniquePtr
<
ipc
:
:
StructuredCloneData
>
aStack
ErrorResult
&
aRv
)
override
;
private
:
~
JSWindowActorChild
(
)
;
RefPtr
<
WindowGlobalChild
>
mManager
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
}
;
}
#
endif
