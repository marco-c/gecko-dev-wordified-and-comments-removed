#
ifndef
dom_ipc_SharedStringMap_h
#
define
dom_ipc_SharedStringMap_h
#
include
"
mozilla
/
AutoMemMap
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsDataHashtable
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
ipc
{
class
SharedStringMapBuilder
;
class
SharedStringMap
{
using
FileDescriptor
=
mozilla
:
:
ipc
:
:
FileDescriptor
;
public
:
struct
Header
{
uint32_t
mEntryCount
;
size_t
mKeyStringsOffset
;
size_t
mKeyStringsSize
;
size_t
mValueStringsOffset
;
size_t
mValueStringsSize
;
}
;
struct
StringEntry
{
uint32_t
mOffset
;
uint32_t
mLength
;
}
;
struct
Entry
{
StringEntry
mKey
;
StringEntry
mValue
;
}
;
NS_INLINE_DECL_REFCOUNTING
(
SharedStringMap
)
explicit
SharedStringMap
(
const
FileDescriptor
&
size_t
)
;
explicit
SharedStringMap
(
SharedStringMapBuilder
&
&
)
;
bool
Has
(
const
nsCString
&
aKey
)
;
bool
Get
(
const
nsCString
&
aKey
nsAString
&
aValue
)
;
private
:
bool
Find
(
const
nsCString
&
aKey
size_t
*
aIndex
)
;
public
:
uint32_t
Count
(
)
const
{
return
EntryCount
(
)
;
}
nsCString
GetKeyAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
Count
(
)
)
;
return
KeyTable
(
)
.
Get
(
Entries
(
)
[
aIndex
]
.
mKey
)
;
}
nsString
GetValueAt
(
uint32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
<
Count
(
)
)
;
return
ValueTable
(
)
.
Get
(
Entries
(
)
[
aIndex
]
.
mValue
)
;
}
FileDescriptor
CloneFileDescriptor
(
)
const
;
size_t
MapSize
(
)
const
{
return
mMap
.
size
(
)
;
}
protected
:
~
SharedStringMap
(
)
=
default
;
private
:
template
<
typename
StringType
>
class
StringTable
{
using
ElemType
=
decltype
(
DeclVal
<
StringType
>
(
)
[
0
]
)
;
public
:
MOZ_IMPLICIT
StringTable
(
const
RangedPtr
<
uint8_t
>
&
aBuffer
)
:
mBuffer
(
aBuffer
.
ReinterpretCast
<
ElemType
>
(
)
)
{
MOZ_ASSERT
(
uintptr_t
(
aBuffer
.
get
(
)
)
%
alignof
(
ElemType
)
=
=
0
"
Got
misalinged
buffer
"
)
;
}
StringType
Get
(
const
StringEntry
&
aEntry
)
const
{
StringType
res
;
res
.
AssignLiteral
(
GetBare
(
aEntry
)
aEntry
.
mLength
)
;
return
res
;
}
const
ElemType
*
GetBare
(
const
StringEntry
&
aEntry
)
const
{
return
&
mBuffer
[
aEntry
.
mOffset
]
;
}
private
:
RangedPtr
<
ElemType
>
mBuffer
;
}
;
const
Header
&
GetHeader
(
)
const
{
return
mMap
.
get
<
Header
>
(
)
[
0
]
;
}
RangedPtr
<
const
Entry
>
Entries
(
)
const
{
return
{
reinterpret_cast
<
const
Entry
*
>
(
&
GetHeader
(
)
+
1
)
EntryCount
(
)
}
;
}
uint32_t
EntryCount
(
)
const
{
return
GetHeader
(
)
.
mEntryCount
;
}
StringTable
<
nsCString
>
KeyTable
(
)
const
{
auto
&
header
=
GetHeader
(
)
;
return
{
{
&
mMap
.
get
<
uint8_t
>
(
)
[
header
.
mKeyStringsOffset
]
header
.
mKeyStringsSize
}
}
;
}
StringTable
<
nsString
>
ValueTable
(
)
const
{
auto
&
header
=
GetHeader
(
)
;
return
{
{
&
mMap
.
get
<
uint8_t
>
(
)
[
header
.
mValueStringsOffset
]
header
.
mValueStringsSize
}
}
;
}
loader
:
:
AutoMemMap
mMap
;
}
;
class
MOZ_RAII
SharedStringMapBuilder
{
public
:
SharedStringMapBuilder
(
)
=
default
;
void
Add
(
const
nsCString
&
aKey
const
nsString
&
aValue
)
;
Result
<
Ok
nsresult
>
Finalize
(
loader
:
:
AutoMemMap
&
aMap
)
;
private
:
template
<
typename
KeyType
typename
StringType
>
class
StringTableBuilder
{
public
:
using
ElemType
=
typename
StringType
:
:
char_type
;
uint32_t
Add
(
const
StringType
&
aKey
)
{
auto
entry
=
mEntries
.
LookupForAdd
(
aKey
)
.
OrInsert
(
[
&
]
(
)
{
Entry
newEntry
{
mSize
aKey
}
;
mSize
+
=
aKey
.
Length
(
)
+
1
;
return
newEntry
;
}
)
;
return
entry
.
mOffset
;
}
void
Write
(
const
RangedPtr
<
uint8_t
>
&
aBuffer
)
{
auto
buffer
=
aBuffer
.
ReinterpretCast
<
ElemType
>
(
)
;
for
(
auto
iter
=
mEntries
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
&
entry
=
iter
.
Data
(
)
;
memcpy
(
&
buffer
[
entry
.
mOffset
]
entry
.
mValue
.
BeginReading
(
)
sizeof
(
ElemType
)
*
(
entry
.
mValue
.
Length
(
)
+
1
)
)
;
}
}
uint32_t
Count
(
)
const
{
return
mEntries
.
Count
(
)
;
}
uint32_t
Size
(
)
const
{
return
mSize
*
sizeof
(
ElemType
)
;
}
void
Clear
(
)
{
mEntries
.
Clear
(
)
;
}
private
:
struct
Entry
{
uint32_t
mOffset
;
StringType
mValue
;
}
;
nsDataHashtable
<
KeyType
Entry
>
mEntries
;
uint32_t
mSize
=
0
;
}
;
using
Entry
=
SharedStringMap
:
:
Entry
;
StringTableBuilder
<
nsCStringHashKey
nsCString
>
mKeyTable
;
StringTableBuilder
<
nsStringHashKey
nsString
>
mValueTable
;
nsDataHashtable
<
nsCStringHashKey
Entry
>
mEntries
;
}
;
}
}
}
#
endif
