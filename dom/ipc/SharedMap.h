#
ifndef
dom_ipc_SharedMap_h
#
define
dom_ipc_SharedMap_h
#
include
"
mozilla
/
AutoMemMap
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StructuredCloneData
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
{
namespace
dom
{
namespace
ipc
{
class
SharedMap
:
public
nsISupports
{
using
FileDescriptor
=
mozilla
:
:
ipc
:
:
FileDescriptor
;
public
:
NS_DECL_ISUPPORTS
SharedMap
(
)
;
SharedMap
(
nsIGlobalObject
*
aGlobal
const
FileDescriptor
&
size_t
)
;
bool
Has
(
const
nsACString
&
name
)
;
void
Get
(
JSContext
*
cx
const
nsACString
&
name
JS
:
:
MutableHandleValue
aRetVal
ErrorResult
&
aRv
)
;
FileDescriptor
CloneMapFile
(
)
;
size_t
MapSize
(
)
const
{
return
mMap
.
size
(
)
;
}
void
Update
(
const
FileDescriptor
&
aMapFile
size_t
aMapSize
nsTArray
<
nsCString
>
&
&
aChangedKeys
)
;
protected
:
virtual
~
SharedMap
(
)
=
default
;
class
Entry
{
public
:
Entry
(
Entry
&
&
)
=
delete
;
explicit
Entry
(
SharedMap
&
aMap
const
nsACString
&
aName
=
EmptyCString
(
)
)
:
mMap
(
aMap
)
mName
(
aName
)
mData
(
AsVariant
(
uint32_t
(
0
)
)
)
{
}
~
Entry
(
)
=
default
;
template
<
typename
Buffer
>
void
Code
(
Buffer
&
buffer
)
{
DebugOnly
<
size_t
>
startOffset
=
buffer
.
cursor
(
)
;
buffer
.
codeString
(
mName
)
;
buffer
.
codeUint32
(
DataOffset
(
)
)
;
buffer
.
codeUint32
(
mSize
)
;
MOZ_ASSERT
(
buffer
.
cursor
(
)
=
=
startOffset
+
HeaderSize
(
)
)
;
}
size_t
HeaderSize
(
)
const
{
return
(
sizeof
(
uint16_t
)
+
mName
.
Length
(
)
+
sizeof
(
DataOffset
(
)
)
+
sizeof
(
mSize
)
)
;
}
void
TakeData
(
StructuredCloneData
&
&
)
;
void
ExtractData
(
char
*
aDestPtr
uint32_t
aNewOffset
)
;
const
nsCString
&
Name
(
)
const
{
return
mName
;
}
void
Read
(
JSContext
*
aCx
JS
:
:
MutableHandleValue
aRetVal
ErrorResult
&
aRv
)
;
uint32_t
Size
(
)
const
{
return
mSize
;
}
private
:
const
char
*
Data
(
)
const
{
return
mMap
.
Data
(
)
+
DataOffset
(
)
;
}
uint32_t
&
DataOffset
(
)
{
return
mData
.
as
<
uint32_t
>
(
)
;
}
const
uint32_t
&
DataOffset
(
)
const
{
return
mData
.
as
<
uint32_t
>
(
)
;
}
const
StructuredCloneData
&
Holder
(
)
const
{
return
mData
.
as
<
StructuredCloneData
>
(
)
;
}
SharedMap
&
mMap
;
nsCString
mName
;
Variant
<
uint32_t
StructuredCloneData
>
mData
;
uint32_t
mSize
=
0
;
}
;
Result
<
Ok
nsresult
>
MaybeRebuild
(
)
;
void
MaybeRebuild
(
)
const
;
UniquePtr
<
FileDescriptor
>
mMapFile
;
size_t
mMapSize
=
0
;
mutable
nsClassHashtable
<
nsCStringHashKey
Entry
>
mEntries
;
loader
:
:
AutoMemMap
mMap
;
bool
mWritable
=
false
;
char
*
Data
(
)
{
return
mMap
.
get
<
char
>
(
)
.
get
(
)
;
}
}
;
class
WritableSharedMap
final
:
public
SharedMap
{
public
:
WritableSharedMap
(
)
;
void
Set
(
JSContext
*
cx
const
nsACString
&
name
JS
:
:
HandleValue
value
ErrorResult
&
aRv
)
;
void
Delete
(
const
nsACString
&
name
)
;
void
Flush
(
)
;
SharedMap
*
GetReadOnly
(
)
;
protected
:
~
WritableSharedMap
(
)
override
=
default
;
private
:
nsTArray
<
nsCString
>
mChangedKeys
;
RefPtr
<
SharedMap
>
mReadOnly
;
Result
<
Ok
nsresult
>
Serialize
(
)
;
void
BroadcastChanges
(
)
;
void
KeyChanged
(
const
nsACString
&
aName
)
;
}
;
}
}
}
#
endif
