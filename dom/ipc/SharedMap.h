#
ifndef
dom_ipc_SharedMap_h
#
define
dom_ipc_SharedMap_h
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
dom
/
MozSharedMapBinding
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StructuredCloneData
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryHandle
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryMapping
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
:
:
dom
{
class
ContentParent
;
namespace
ipc
{
class
SharedMap
:
public
DOMEventTargetHelper
{
protected
:
using
SharedMemoryMapping
=
mozilla
:
:
ipc
:
:
ReadOnlySharedMemoryMapping
;
using
SharedMemoryHandle
=
mozilla
:
:
ipc
:
:
ReadOnlySharedMemoryHandle
;
public
:
SharedMap
(
)
;
SharedMap
(
nsIGlobalObject
*
aGlobal
SharedMemoryHandle
&
&
nsTArray
<
RefPtr
<
BlobImpl
>
>
&
&
aBlobs
)
;
bool
Has
(
const
nsACString
&
name
)
;
void
Get
(
JSContext
*
cx
const
nsACString
&
name
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
aRv
)
;
bool
Has
(
const
nsAString
&
aName
)
{
return
Has
(
NS_ConvertUTF16toUTF8
(
aName
)
)
;
}
void
Get
(
JSContext
*
aCx
const
nsAString
&
aName
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
aRv
)
{
return
Get
(
aCx
NS_ConvertUTF16toUTF8
(
aName
)
aRetVal
aRv
)
;
}
uint32_t
GetIterableLength
(
)
const
{
return
EntryArray
(
)
.
Length
(
)
;
}
const
nsString
GetKeyAtIndex
(
uint32_t
aIndex
)
const
;
bool
GetValueAtIndex
(
JSContext
*
aCx
uint32_t
aIndex
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
)
const
;
size_t
MapSize
(
)
const
{
return
mMapping
.
Size
(
)
;
}
void
Update
(
SharedMemoryHandle
&
&
aMapHandle
nsTArray
<
RefPtr
<
BlobImpl
>
>
&
&
aBlobs
nsTArray
<
nsCString
>
&
&
aChangedKeys
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
protected
:
~
SharedMap
(
)
override
=
default
;
class
Entry
{
public
:
Entry
(
Entry
&
&
)
=
delete
;
explicit
Entry
(
SharedMap
&
aMap
const
nsACString
&
aName
=
"
"
_ns
)
:
mMap
(
aMap
)
mName
(
aName
)
mData
(
AsVariant
(
uint32_t
(
0
)
)
)
{
}
~
Entry
(
)
=
default
;
template
<
typename
Buffer
>
void
Code
(
Buffer
&
buffer
)
{
DebugOnly
<
size_t
>
startOffset
=
buffer
.
cursor
(
)
;
buffer
.
codeString
(
mName
)
;
buffer
.
codeUint32
(
DataOffset
(
)
)
;
buffer
.
codeUint32
(
mSize
)
;
buffer
.
codeUint16
(
mBlobOffset
)
;
buffer
.
codeUint16
(
mBlobCount
)
;
MOZ_ASSERT
(
buffer
.
cursor
(
)
=
=
startOffset
+
HeaderSize
(
)
)
;
}
size_t
HeaderSize
(
)
const
{
return
(
sizeof
(
uint16_t
)
+
mName
.
Length
(
)
+
sizeof
(
DataOffset
(
)
)
+
sizeof
(
mSize
)
+
sizeof
(
mBlobOffset
)
+
sizeof
(
mBlobCount
)
)
;
}
void
TakeData
(
UniquePtr
<
StructuredCloneData
>
aHolder
)
;
void
ExtractData
(
char
*
aDestPtr
uint32_t
aNewOffset
uint16_t
aNewBlobOffset
)
;
const
nsCString
&
Name
(
)
const
{
return
mName
;
}
void
Read
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
ErrorResult
&
aRv
)
;
uint32_t
Size
(
)
const
{
return
mSize
;
}
private
:
const
char
*
Data
(
)
const
{
return
mMap
.
Data
(
)
+
DataOffset
(
)
;
}
uint32_t
&
DataOffset
(
)
{
return
mData
.
as
<
uint32_t
>
(
)
;
}
const
uint32_t
&
DataOffset
(
)
const
{
return
mData
.
as
<
uint32_t
>
(
)
;
}
public
:
uint16_t
BlobOffset
(
)
const
{
return
mBlobOffset
;
}
uint16_t
BlobCount
(
)
const
{
return
mBlobCount
;
}
Span
<
const
RefPtr
<
BlobImpl
>
>
Blobs
(
)
{
if
(
mData
.
is
<
UniquePtr
<
StructuredCloneData
>
>
(
)
)
{
return
mData
.
as
<
UniquePtr
<
StructuredCloneData
>
>
(
)
-
>
BlobImpls
(
)
;
}
return
{
&
mMap
.
mBlobImpls
[
mBlobOffset
]
BlobCount
(
)
}
;
}
private
:
const
StructuredCloneData
&
Holder
(
)
const
{
return
*
mData
.
as
<
UniquePtr
<
StructuredCloneData
>
>
(
)
;
}
SharedMap
&
mMap
;
nsCString
mName
;
Variant
<
uint32_t
UniquePtr
<
StructuredCloneData
>
>
mData
;
uint32_t
mSize
=
0
;
uint16_t
mBlobOffset
=
0
;
uint16_t
mBlobCount
=
0
;
}
;
const
nsTArray
<
Entry
*
>
&
EntryArray
(
)
const
;
nsTArray
<
RefPtr
<
BlobImpl
>
>
mBlobImpls
;
Result
<
Ok
nsresult
>
MaybeRebuild
(
)
;
void
MaybeRebuild
(
)
const
;
mutable
nsClassHashtable
<
nsCStringHashKey
Entry
>
mEntries
;
mutable
Maybe
<
nsTArray
<
Entry
*
>
>
mEntryArray
;
SharedMemoryHandle
mHandle
;
SharedMemoryMapping
mMapping
;
bool
mWritable
=
false
;
const
char
*
Data
(
)
{
return
mMapping
.
DataAs
<
char
>
(
)
;
}
}
;
class
WritableSharedMap
final
:
public
SharedMap
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
WritableSharedMap
SharedMap
)
WritableSharedMap
(
)
;
void
Set
(
JSContext
*
cx
const
nsACString
&
name
JS
:
:
Handle
<
JS
:
:
Value
>
value
ErrorResult
&
aRv
)
;
void
Delete
(
const
nsACString
&
name
)
;
void
Set
(
JSContext
*
aCx
const
nsAString
&
aName
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
return
Set
(
aCx
NS_ConvertUTF16toUTF8
(
aName
)
aValue
aRv
)
;
}
void
Delete
(
const
nsAString
&
aName
)
{
return
Delete
(
NS_ConvertUTF16toUTF8
(
aName
)
)
;
}
void
Flush
(
)
;
void
SendTo
(
ContentParent
*
aContentParent
)
const
;
SharedMap
*
GetReadOnly
(
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
protected
:
~
WritableSharedMap
(
)
override
=
default
;
private
:
nsTArray
<
nsCString
>
mChangedKeys
;
RefPtr
<
SharedMap
>
mReadOnly
;
bool
mPendingFlush
=
false
;
Result
<
Ok
nsresult
>
Serialize
(
)
;
void
IdleFlush
(
)
;
void
BroadcastChanges
(
)
;
nsresult
KeyChanged
(
const
nsACString
&
aName
)
;
}
;
}
}
#
endif
