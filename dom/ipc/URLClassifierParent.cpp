#
include
"
URLClassifierParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureResult
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsIUrlClassifierFeature
.
h
"
#
include
"
nsNetCID
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
nsIUrlClassifierExceptionList
;
NS_IMPL_ISUPPORTS
(
URLClassifierParent
nsIURIClassifierCallback
)
mozilla
:
:
ipc
:
:
IPCResult
URLClassifierParent
:
:
StartClassify
(
nsIPrincipal
*
aPrincipal
bool
*
aSuccess
)
{
*
aSuccess
=
false
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIURIClassifier
>
uriClassifier
=
do_GetService
(
NS_URICLASSIFIERSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
uriClassifier
-
>
Classify
(
aPrincipal
this
aSuccess
)
;
}
if
(
NS_FAILED
(
rv
)
|
|
!
*
aSuccess
)
{
*
aSuccess
=
false
;
ClassificationFailed
(
)
;
}
return
IPC_OK
(
)
;
}
namespace
{
class
IPCFeature
final
:
public
nsIUrlClassifierFeature
{
public
:
NS_DECL_ISUPPORTS
IPCFeature
(
nsIURI
*
aURI
const
IPCURLClassifierFeature
&
aFeature
)
:
mURI
(
aURI
)
mIPCFeature
(
aFeature
)
{
}
NS_IMETHOD
GetName
(
nsACString
&
aName
)
override
{
aName
=
mIPCFeature
.
featureName
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetTables
(
nsIUrlClassifierFeature
:
:
listType
nsTArray
<
nsCString
>
&
aTables
)
override
{
aTables
.
AppendElements
(
mIPCFeature
.
tables
(
)
)
;
return
NS_OK
;
}
NS_IMETHOD
HasTable
(
const
nsACString
&
aTable
nsIUrlClassifierFeature
:
:
listType
bool
*
aResult
)
override
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
mIPCFeature
.
tables
(
)
.
Contains
(
aTable
)
;
return
NS_OK
;
}
NS_IMETHOD
HasHostInPreferences
(
const
nsACString
&
aHost
nsIUrlClassifierFeature
:
:
listType
nsACString
&
aTableName
bool
*
aResult
)
override
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
*
aResult
=
false
;
return
NS_OK
;
}
NS_IMETHOD
GetExceptionList
(
nsIUrlClassifierExceptionList
*
*
aList
)
override
{
return
NS_OK
;
}
NS_IMETHOD
ProcessChannel
(
nsIChannel
*
aChannel
const
nsTArray
<
nsCString
>
&
aList
const
nsTArray
<
nsCString
>
&
aHashes
bool
*
aShouldContinue
)
override
{
NS_ENSURE_ARG_POINTER
(
aShouldContinue
)
;
*
aShouldContinue
=
true
;
return
NS_OK
;
}
NS_IMETHOD
GetURIByListType
(
nsIChannel
*
aChannel
nsIUrlClassifierFeature
:
:
listType
aListType
nsIUrlClassifierFeature
:
:
URIType
*
aURIType
nsIURI
*
*
aURI
)
override
{
NS_ENSURE_ARG_POINTER
(
aURI
)
;
nsCOMPtr
<
nsIURI
>
uri
=
mURI
;
uri
.
forget
(
aURI
)
;
*
aURIType
=
aListType
=
=
nsIUrlClassifierFeature
:
:
blocklist
?
nsIUrlClassifierFeature
:
:
URIType
:
:
blocklistURI
:
nsIUrlClassifierFeature
:
:
URIType
:
:
entitylistURI
;
return
NS_OK
;
}
private
:
~
IPCFeature
(
)
=
default
;
nsCOMPtr
<
nsIURI
>
mURI
;
IPCURLClassifierFeature
mIPCFeature
;
}
;
NS_IMPL_ISUPPORTS
(
IPCFeature
nsIUrlClassifierFeature
)
}
NS_IMPL_ISUPPORTS
(
URLClassifierLocalParent
nsIUrlClassifierFeatureCallback
)
mozilla
:
:
ipc
:
:
IPCResult
URLClassifierLocalParent
:
:
StartClassify
(
nsIURI
*
aURI
const
nsTArray
<
IPCURLClassifierFeature
>
&
aFeatures
)
{
MOZ_ASSERT
(
aURI
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIURIClassifier
>
uriClassifier
=
do_GetService
(
NS_URICLASSIFIERSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
OnClassifyComplete
(
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
(
)
)
;
return
IPC_OK
(
)
;
}
nsTArray
<
RefPtr
<
nsIUrlClassifierFeature
>
>
features
;
for
(
const
IPCURLClassifierFeature
&
feature
:
aFeatures
)
{
features
.
AppendElement
(
new
IPCFeature
(
aURI
feature
)
)
;
}
rv
=
uriClassifier
-
>
AsyncClassifyLocalWithFeatures
(
aURI
features
nsIUrlClassifierFeature
:
:
blocklist
this
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
OnClassifyComplete
(
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
(
)
)
;
return
IPC_OK
(
)
;
}
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
URLClassifierLocalParent
:
:
OnClassifyComplete
(
const
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
&
aResults
)
{
if
(
mIPCOpen
)
{
nsTArray
<
URLClassifierLocalResult
>
ipcResults
;
for
(
nsIUrlClassifierFeatureResult
*
result
:
aResults
)
{
URLClassifierLocalResult
*
ipcResult
=
ipcResults
.
AppendElement
(
)
;
net
:
:
UrlClassifierFeatureResult
*
r
=
static_cast
<
net
:
:
UrlClassifierFeatureResult
*
>
(
result
)
;
ipcResult
-
>
uri
(
)
=
r
-
>
URI
(
)
;
r
-
>
Feature
(
)
-
>
GetName
(
ipcResult
-
>
featureName
(
)
)
;
ipcResult
-
>
matchingList
(
)
=
r
-
>
List
(
)
;
}
Unused
<
<
Send__delete__
(
this
ipcResults
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
URLClassifierLocalByNameParent
nsIUrlClassifierFeatureCallback
)
mozilla
:
:
ipc
:
:
IPCResult
URLClassifierLocalByNameParent
:
:
StartClassify
(
nsIURI
*
aURI
const
nsTArray
<
IPCURLClassifierFeature
>
&
aFeatures
nsIUrlClassifierFeature
:
:
listType
aListType
)
{
MOZ_ASSERT
(
aURI
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIURIClassifier
>
uriClassifier
=
do_GetService
(
NS_URICLASSIFIERSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
OnClassifyComplete
(
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
(
)
)
;
return
IPC_OK
(
)
;
}
nsTArray
<
RefPtr
<
nsIUrlClassifierFeature
>
>
features
;
for
(
const
IPCURLClassifierFeature
&
feature
:
aFeatures
)
{
features
.
AppendElement
(
new
IPCFeature
(
aURI
feature
)
)
;
}
rv
=
uriClassifier
-
>
AsyncClassifyLocalWithFeatures
(
aURI
features
aListType
this
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
OnClassifyComplete
(
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
(
)
)
;
return
IPC_OK
(
)
;
}
return
IPC_OK
(
)
;
}
NS_IMETHODIMP
URLClassifierLocalByNameParent
:
:
OnClassifyComplete
(
const
nsTArray
<
RefPtr
<
nsIUrlClassifierFeatureResult
>
>
&
aResults
)
{
if
(
mIPCOpen
)
{
nsTArray
<
URLClassifierLocalResult
>
ipcResults
;
for
(
nsIUrlClassifierFeatureResult
*
result
:
aResults
)
{
URLClassifierLocalResult
*
ipcResult
=
ipcResults
.
AppendElement
(
)
;
net
:
:
UrlClassifierFeatureResult
*
r
=
static_cast
<
net
:
:
UrlClassifierFeatureResult
*
>
(
result
)
;
ipcResult
-
>
uri
(
)
=
r
-
>
URI
(
)
;
r
-
>
Feature
(
)
-
>
GetName
(
ipcResult
-
>
featureName
(
)
)
;
ipcResult
-
>
matchingList
(
)
=
r
-
>
List
(
)
;
}
Unused
<
<
Send__delete__
(
this
ipcResults
)
;
}
return
NS_OK
;
}
