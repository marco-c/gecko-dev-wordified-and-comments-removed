#
ifndef
mozilla_dom_Promise_inl_h
#
define
mozilla_dom_Promise_inl_h
#
include
<
type_traits
>
#
include
<
utility
>
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
TupleCycleCollection
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
namespace
mozilla
{
namespace
dom
{
class
PromiseNativeThenHandlerBase
:
public
PromiseNativeHandler
{
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PromiseNativeThenHandlerBase
)
PromiseNativeThenHandlerBase
(
Promise
*
aPromise
)
:
mPromise
(
aPromise
)
{
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
protected
:
virtual
~
PromiseNativeThenHandlerBase
(
)
=
default
;
virtual
already_AddRefed
<
Promise
>
CallResolveCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
=
0
;
virtual
already_AddRefed
<
Promise
>
CallRejectCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
=
0
;
virtual
void
Traverse
(
nsCycleCollectionTraversalCallback
&
)
=
0
;
virtual
void
Unlink
(
)
=
0
;
RefPtr
<
Promise
>
mPromise
;
}
;
namespace
{
template
<
typename
T
bool
=
IsRefcounted
<
std
:
:
remove_pointer_t
<
T
>
>
:
:
value
bool
=
(
std
:
:
is_convertible_v
<
T
nsISupports
*
>
|
|
std
:
:
is_convertible_v
<
T
*
nsISupports
*
>
)
>
struct
StorageTypeHelper
{
using
Type
=
T
;
}
;
template
<
typename
T
>
struct
StorageTypeHelper
<
T
true
true
>
{
using
Type
=
nsCOMPtr
<
T
>
;
}
;
template
<
typename
T
>
struct
StorageTypeHelper
<
nsCOMPtr
<
T
>
true
true
>
{
using
Type
=
nsCOMPtr
<
T
>
;
}
;
template
<
typename
T
>
struct
StorageTypeHelper
<
T
*
true
false
>
{
using
Type
=
RefPtr
<
T
>
;
}
;
template
<
template
<
typename
>
class
SmartPtr
typename
T
>
struct
StorageTypeHelper
<
SmartPtr
<
T
>
true
false
>
:
std
:
:
enable_if
<
std
:
:
is_convertible_v
<
SmartPtr
<
T
>
T
*
>
RefPtr
<
T
>
>
{
using
Type
=
typename
StorageTypeHelper
:
:
enable_if
:
:
type
;
}
;
template
<
typename
T
>
using
StorageType
=
typename
StorageTypeHelper
<
std
:
:
decay_t
<
T
>
>
:
:
Type
;
template
<
template
<
typename
>
class
SmartPtr
typename
T
>
decltype
(
std
:
:
declval
<
SmartPtr
<
T
>
>
(
)
.
get
(
)
)
ArgType
(
SmartPtr
<
T
>
&
aVal
)
{
return
aVal
.
get
(
)
;
}
template
<
typename
T
>
T
&
&
ArgType
(
T
&
aVal
)
{
return
std
:
:
move
(
aVal
)
;
}
using
:
:
ImplCycleCollectionUnlink
;
template
<
typename
ResolveCallback
typename
RejectCallback
typename
.
.
.
Args
>
class
NativeThenHandler
final
:
public
PromiseNativeThenHandlerBase
{
public
:
NativeThenHandler
(
Promise
*
aPromise
ResolveCallback
&
&
aOnResolve
RejectCallback
&
&
aOnReject
Args
&
&
.
.
.
aArgs
)
:
PromiseNativeThenHandlerBase
(
aPromise
)
mOnResolve
(
std
:
:
forward
<
ResolveCallback
>
(
aOnResolve
)
)
mOnReject
(
std
:
:
forward
<
RejectCallback
>
(
aOnReject
)
)
mArgs
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
{
}
protected
:
void
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
override
{
auto
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mArgs
)
}
void
Unlink
(
)
override
{
auto
*
tmp
=
this
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mArgs
)
}
already_AddRefed
<
Promise
>
CallResolveCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
return
CallCallback
(
aCx
mOnResolve
aValue
aRv
)
;
}
already_AddRefed
<
Promise
>
CallRejectCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
return
CallCallback
(
aCx
mOnReject
aValue
aRv
)
;
}
template
<
typename
TCallback
size_t
.
.
.
Indices
>
already_AddRefed
<
Promise
>
CallCallback
(
JSContext
*
aCx
const
TCallback
&
aHandler
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
return
aHandler
(
aCx
aValue
aRv
ArgType
(
Get
<
Indices
>
(
mArgs
)
)
.
.
.
)
;
}
template
<
typename
TCallback
>
auto
CallCallback
(
JSContext
*
aCx
const
TCallback
&
aHandler
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
return
CallCallback
(
aCx
aHandler
aValue
aRv
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
}
ResolveCallback
mOnResolve
;
RejectCallback
mOnReject
;
Tuple
<
StorageType
<
Args
>
.
.
.
>
mArgs
;
}
;
}
template
<
typename
ResolveCallback
typename
RejectCallback
typename
.
.
.
Args
>
Promise
:
:
ThenResult
<
ResolveCallback
Args
.
.
.
>
Promise
:
:
ThenCatchWithCycleCollectedArgs
(
ResolveCallback
&
&
aOnResolve
RejectCallback
&
&
aOnReject
Args
&
&
.
.
.
aArgs
)
{
using
HandlerType
=
NativeThenHandler
<
ResolveCallback
RejectCallback
Args
.
.
.
>
;
ErrorResult
rv
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetParentObject
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
rv
.
StealNSResult
(
)
)
;
}
auto
*
handler
=
new
(
fallible
)
HandlerType
(
promise
std
:
:
forward
<
ResolveCallback
>
(
aOnResolve
)
std
:
:
forward
<
RejectCallback
>
(
aOnReject
)
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
if
(
!
handler
)
{
return
Err
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
AppendNativeHandler
(
handler
)
;
return
std
:
:
move
(
promise
)
;
}
template
<
typename
Callback
typename
.
.
.
Args
>
Promise
:
:
ThenResult
<
Callback
Args
.
.
.
>
Promise
:
:
ThenWithCycleCollectedArgs
(
Callback
&
&
aOnResolve
Args
&
&
.
.
.
aArgs
)
{
return
ThenCatchWithCycleCollectedArgs
(
std
:
:
forward
<
Callback
>
(
aOnResolve
)
[
]
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
value
ErrorResult
&
aRv
StorageType
<
Args
>
&
&
.
.
.
)
-
>
already_AddRefed
<
Promise
>
{
aRv
.
MightThrowJSException
(
)
;
aRv
.
ThrowJSException
(
aCx
value
)
;
return
nullptr
;
}
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
}
}
#
endif
