#
include
"
js
/
Value
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
CycleCollectedJSRuntime
.
h
"
#
include
"
mozilla
/
ThreadLocal
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseDebugging
.
h
"
#
include
"
mozilla
/
dom
/
PromiseDebuggingBinding
.
h
"
namespace
mozilla
{
namespace
dom
{
class
FlushRejections
:
public
CancelableRunnable
{
public
:
static
void
Init
(
)
{
if
(
!
sDispatched
.
init
(
)
)
{
MOZ_CRASH
(
"
Could
not
initialize
FlushRejections
:
:
sDispatched
"
)
;
}
sDispatched
.
set
(
false
)
;
}
static
void
DispatchNeeded
(
)
{
if
(
sDispatched
.
get
(
)
)
{
return
;
}
sDispatched
.
set
(
true
)
;
NS_DispatchToCurrentThread
(
new
FlushRejections
(
)
)
;
}
static
void
FlushSync
(
)
{
sDispatched
.
set
(
false
)
;
PromiseDebugging
:
:
FlushUncaughtRejectionsInternal
(
)
;
}
NS_IMETHOD
Run
(
)
{
FlushSync
(
)
;
return
NS_OK
;
}
private
:
static
MOZ_THREAD_LOCAL
(
bool
)
sDispatched
;
}
;
MOZ_THREAD_LOCAL
(
bool
)
FlushRejections
:
:
sDispatched
;
#
ifndef
SPIDERMONKEY_PROMISE
static
Promise
*
UnwrapPromise
(
JS
:
:
Handle
<
JSObject
*
>
aPromise
ErrorResult
&
aRv
)
{
Promise
*
promise
;
if
(
NS_WARN_IF
(
NS_FAILED
(
UNWRAP_OBJECT
(
Promise
aPromise
promise
)
)
)
)
{
aRv
.
ThrowTypeError
<
MSG_IS_NOT_PROMISE
>
(
NS_LITERAL_STRING
(
"
Argument
"
)
)
;
return
nullptr
;
}
return
promise
;
}
#
endif
#
ifdef
SPIDERMONKEY_PROMISE
void
PromiseDebugging
:
:
GetState
(
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromise
PromiseDebuggingStateHolder
&
aState
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
js
:
:
CheckedUnwrap
(
aPromise
)
)
;
if
(
!
obj
|
|
!
JS
:
:
IsPromiseObject
(
obj
)
)
{
aRv
.
ThrowTypeError
<
MSG_IS_NOT_PROMISE
>
(
NS_LITERAL_STRING
(
"
Argument
of
PromiseDebugging
.
getState
"
)
)
;
return
;
}
switch
(
JS
:
:
GetPromiseState
(
obj
)
)
{
case
JS
:
:
PromiseState
:
:
Pending
:
aState
.
mState
=
PromiseDebuggingState
:
:
Pending
;
break
;
case
JS
:
:
PromiseState
:
:
Fulfilled
:
aState
.
mState
=
PromiseDebuggingState
:
:
Fulfilled
;
aState
.
mValue
=
JS
:
:
GetPromiseResult
(
obj
)
;
break
;
case
JS
:
:
PromiseState
:
:
Rejected
:
aState
.
mState
=
PromiseDebuggingState
:
:
Rejected
;
aState
.
mReason
=
JS
:
:
GetPromiseResult
(
obj
)
;
break
;
}
}
void
PromiseDebugging
:
:
GetPromiseID
(
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromise
nsString
&
aID
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
js
:
:
CheckedUnwrap
(
aPromise
)
)
;
if
(
!
obj
|
|
!
JS
:
:
IsPromiseObject
(
obj
)
)
{
aRv
.
ThrowTypeError
<
MSG_IS_NOT_PROMISE
>
(
NS_LITERAL_STRING
(
"
Argument
of
PromiseDebugging
.
getState
"
)
)
;
return
;
}
uint64_t
promiseID
=
JS
:
:
GetPromiseID
(
obj
)
;
aID
=
sIDPrefix
;
aID
.
AppendInt
(
promiseID
)
;
}
void
PromiseDebugging
:
:
GetAllocationStack
(
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromise
JS
:
:
MutableHandle
<
JSObject
*
>
aStack
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
js
:
:
CheckedUnwrap
(
aPromise
)
)
;
if
(
!
obj
|
|
!
JS
:
:
IsPromiseObject
(
obj
)
)
{
aRv
.
ThrowTypeError
<
MSG_IS_NOT_PROMISE
>
(
NS_LITERAL_STRING
(
"
Argument
of
PromiseDebugging
.
getAllocationStack
"
)
)
;
return
;
}
aStack
.
set
(
JS
:
:
GetPromiseAllocationSite
(
obj
)
)
;
}
void
PromiseDebugging
:
:
GetRejectionStack
(
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromise
JS
:
:
MutableHandle
<
JSObject
*
>
aStack
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
js
:
:
CheckedUnwrap
(
aPromise
)
)
;
if
(
!
obj
|
|
!
JS
:
:
IsPromiseObject
(
obj
)
)
{
aRv
.
ThrowTypeError
<
MSG_IS_NOT_PROMISE
>
(
NS_LITERAL_STRING
(
"
Argument
of
PromiseDebugging
.
getRejectionStack
"
)
)
;
return
;
}
aStack
.
set
(
JS
:
:
GetPromiseResolutionSite
(
obj
)
)
;
}
void
PromiseDebugging
:
:
GetFullfillmentStack
(
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromise
JS
:
:
MutableHandle
<
JSObject
*
>
aStack
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
js
:
:
CheckedUnwrap
(
aPromise
)
)
;
if
(
!
obj
|
|
!
JS
:
:
IsPromiseObject
(
obj
)
)
{
aRv
.
ThrowTypeError
<
MSG_IS_NOT_PROMISE
>
(
NS_LITERAL_STRING
(
"
Argument
of
PromiseDebugging
.
getFulfillmentStack
"
)
)
;
return
;
}
aStack
.
set
(
JS
:
:
GetPromiseResolutionSite
(
obj
)
)
;
}
#
else
void
PromiseDebugging
:
:
GetState
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
PromiseDebuggingStateHolder
&
aState
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
switch
(
promise
-
>
mState
)
{
case
Promise
:
:
Pending
:
aState
.
mState
=
PromiseDebuggingState
:
:
Pending
;
break
;
case
Promise
:
:
Resolved
:
aState
.
mState
=
PromiseDebuggingState
:
:
Fulfilled
;
JS
:
:
ExposeValueToActiveJS
(
promise
-
>
mResult
)
;
aState
.
mValue
=
promise
-
>
mResult
;
break
;
case
Promise
:
:
Rejected
:
aState
.
mState
=
PromiseDebuggingState
:
:
Rejected
;
JS
:
:
ExposeValueToActiveJS
(
promise
-
>
mResult
)
;
aState
.
mReason
=
promise
-
>
mResult
;
break
;
}
}
#
endif
nsString
PromiseDebugging
:
:
sIDPrefix
;
void
PromiseDebugging
:
:
Init
(
)
{
FlushRejections
:
:
Init
(
)
;
sIDPrefix
=
NS_LITERAL_STRING
(
"
PromiseDebugging
.
"
)
;
if
(
XRE_IsContentProcess
(
)
)
{
sIDPrefix
.
AppendInt
(
ContentChild
:
:
GetSingleton
(
)
-
>
GetID
(
)
)
;
sIDPrefix
.
Append
(
'
.
'
)
;
}
else
{
sIDPrefix
.
AppendLiteral
(
"
0
.
"
)
;
}
}
void
PromiseDebugging
:
:
Shutdown
(
)
{
sIDPrefix
.
SetIsVoid
(
true
)
;
}
void
PromiseDebugging
:
:
FlushUncaughtRejections
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
FlushRejections
:
:
FlushSync
(
)
;
}
#
ifndef
SPIDERMONKEY_PROMISE
void
PromiseDebugging
:
:
GetAllocationStack
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
JS
:
:
MutableHandle
<
JSObject
*
>
aStack
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aStack
.
set
(
promise
-
>
mAllocationStack
)
;
}
void
PromiseDebugging
:
:
GetRejectionStack
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
JS
:
:
MutableHandle
<
JSObject
*
>
aStack
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aStack
.
set
(
promise
-
>
mRejectionStack
)
;
}
void
PromiseDebugging
:
:
GetFullfillmentStack
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
JS
:
:
MutableHandle
<
JSObject
*
>
aStack
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aStack
.
set
(
promise
-
>
mFullfillmentStack
)
;
}
void
PromiseDebugging
:
:
GetDependentPromises
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromises
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
promise
-
>
GetDependentPromises
(
aPromises
)
;
}
double
PromiseDebugging
:
:
GetPromiseLifetime
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
0
;
}
return
(
TimeStamp
:
:
Now
(
)
-
promise
-
>
mCreationTimestamp
)
.
ToMilliseconds
(
)
;
}
double
PromiseDebugging
:
:
GetTimeToSettle
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
0
;
}
if
(
promise
-
>
mState
=
=
Promise
:
:
Pending
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
0
;
}
return
(
promise
-
>
mSettlementTimestamp
-
promise
-
>
mCreationTimestamp
)
.
ToMilliseconds
(
)
;
}
#
endif
void
PromiseDebugging
:
:
AddUncaughtRejectionObserver
(
GlobalObject
&
UncaughtRejectionObserver
&
aObserver
)
{
CycleCollectedJSRuntime
*
storage
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
observers
=
storage
-
>
mUncaughtRejectionObservers
;
observers
.
AppendElement
(
&
aObserver
)
;
}
bool
PromiseDebugging
:
:
RemoveUncaughtRejectionObserver
(
GlobalObject
&
UncaughtRejectionObserver
&
aObserver
)
{
CycleCollectedJSRuntime
*
storage
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
observers
=
storage
-
>
mUncaughtRejectionObservers
;
for
(
size_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
UncaughtRejectionObserver
*
observer
=
static_cast
<
UncaughtRejectionObserver
*
>
(
observers
[
i
]
.
get
(
)
)
;
if
(
*
observer
=
=
aObserver
)
{
observers
.
RemoveElementAt
(
i
)
;
return
true
;
}
}
return
false
;
}
#
ifdef
SPIDERMONKEY_PROMISE
void
PromiseDebugging
:
:
AddUncaughtRejection
(
JS
:
:
HandleObject
aPromise
)
{
if
(
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
mUncaughtRejections
.
append
(
aPromise
)
)
{
FlushRejections
:
:
DispatchNeeded
(
)
;
}
}
void
PromiseDebugging
:
:
AddConsumedRejection
(
JS
:
:
HandleObject
aPromise
)
{
auto
&
uncaughtRejections
=
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
mUncaughtRejections
;
for
(
size_t
i
=
0
;
i
<
uncaughtRejections
.
length
(
)
;
i
+
+
)
{
if
(
uncaughtRejections
[
i
]
=
=
aPromise
)
{
uncaughtRejections
[
i
]
.
set
(
nullptr
)
;
return
;
}
}
if
(
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
mConsumedRejections
.
append
(
aPromise
)
)
{
FlushRejections
:
:
DispatchNeeded
(
)
;
}
}
void
PromiseDebugging
:
:
FlushUncaughtRejectionsInternal
(
)
{
CycleCollectedJSRuntime
*
storage
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
auto
&
uncaught
=
storage
-
>
mUncaughtRejections
;
auto
&
consumed
=
storage
-
>
mConsumedRejections
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
auto
&
observers
=
storage
-
>
mUncaughtRejectionObservers
;
for
(
size_t
i
=
0
;
i
<
uncaught
.
length
(
)
;
i
+
+
)
{
JS
:
:
RootedObject
promise
(
cx
uncaught
[
i
]
)
;
if
(
!
promise
)
{
continue
;
}
for
(
size_t
j
=
0
;
j
<
observers
.
Length
(
)
;
+
+
j
)
{
RefPtr
<
UncaughtRejectionObserver
>
obs
=
static_cast
<
UncaughtRejectionObserver
*
>
(
observers
[
j
]
.
get
(
)
)
;
IgnoredErrorResult
err
;
obs
-
>
OnLeftUncaught
(
promise
err
)
;
}
JSAutoCompartment
ac
(
cx
promise
)
;
Promise
:
:
ReportRejectedPromise
(
cx
promise
)
;
}
storage
-
>
mUncaughtRejections
.
clear
(
)
;
for
(
size_t
i
=
0
;
i
<
consumed
.
length
(
)
;
i
+
+
)
{
JS
:
:
RootedObject
promise
(
cx
consumed
[
i
]
)
;
for
(
size_t
j
=
0
;
j
<
observers
.
Length
(
)
;
+
+
j
)
{
RefPtr
<
UncaughtRejectionObserver
>
obs
=
static_cast
<
UncaughtRejectionObserver
*
>
(
observers
[
j
]
.
get
(
)
)
;
IgnoredErrorResult
err
;
obs
-
>
OnConsumed
(
promise
err
)
;
}
}
storage
-
>
mConsumedRejections
.
clear
(
)
;
}
#
else
void
PromiseDebugging
:
:
AddUncaughtRejection
(
Promise
&
aPromise
)
{
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
mUncaughtRejections
.
AppendElement
(
&
aPromise
)
;
FlushRejections
:
:
DispatchNeeded
(
)
;
}
void
PromiseDebugging
:
:
AddConsumedRejection
(
Promise
&
aPromise
)
{
CycleCollectedJSRuntime
:
:
Get
(
)
-
>
mConsumedRejections
.
AppendElement
(
&
aPromise
)
;
FlushRejections
:
:
DispatchNeeded
(
)
;
}
void
PromiseDebugging
:
:
GetPromiseID
(
GlobalObject
&
JS
:
:
Handle
<
JSObject
*
>
aPromise
nsString
&
aID
ErrorResult
&
aRv
)
{
Promise
*
promise
=
UnwrapPromise
(
aPromise
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
uint64_t
promiseID
=
promise
-
>
GetID
(
)
;
aID
=
sIDPrefix
;
aID
.
AppendInt
(
promiseID
)
;
}
void
PromiseDebugging
:
:
FlushUncaughtRejectionsInternal
(
)
{
CycleCollectedJSRuntime
*
storage
=
CycleCollectedJSRuntime
:
:
Get
(
)
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
uncaught
;
storage
-
>
mUncaughtRejections
.
SwapElements
(
uncaught
)
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
consumed
;
storage
-
>
mConsumedRejections
.
SwapElements
(
consumed
)
;
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
&
observers
=
storage
-
>
mUncaughtRejectionObservers
;
nsresult
rv
;
for
(
size_t
i
=
0
;
i
<
uncaught
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
Promise
>
promise
=
do_QueryInterface
(
uncaught
[
i
]
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
promise
-
>
IsLastInChain
(
)
)
{
continue
;
}
for
(
size_t
j
=
0
;
j
<
observers
.
Length
(
)
;
+
+
j
)
{
ErrorResult
err
;
RefPtr
<
UncaughtRejectionObserver
>
obs
=
static_cast
<
UncaughtRejectionObserver
*
>
(
observers
[
j
]
.
get
(
)
)
;
obs
-
>
OnLeftUncaught
(
*
promise
err
)
;
}
promise
-
>
SetNotifiedAsUncaught
(
)
;
}
for
(
size_t
i
=
0
;
i
<
consumed
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
Promise
>
promise
=
do_QueryInterface
(
consumed
[
i
]
&
rv
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
!
promise
-
>
WasNotifiedAsUncaught
(
)
)
{
continue
;
}
MOZ_ASSERT
(
!
promise
-
>
IsLastInChain
(
)
)
;
for
(
size_t
j
=
0
;
j
<
observers
.
Length
(
)
;
+
+
j
)
{
ErrorResult
err
;
RefPtr
<
UncaughtRejectionObserver
>
obs
=
static_cast
<
UncaughtRejectionObserver
*
>
(
observers
[
j
]
.
get
(
)
)
;
obs
-
>
OnConsumed
(
*
promise
err
)
;
}
}
}
#
endif
}
}
