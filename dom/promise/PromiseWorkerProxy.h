#
ifndef
mozilla_dom_PromiseWorkerProxy_h
#
define
mozilla_dom_PromiseWorkerProxy_h
#
include
<
cstdint
>
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneHolder
.
h
"
#
include
"
nsISupports
.
h
"
struct
JSStructuredCloneReader
;
struct
JSStructuredCloneWriter
;
namespace
JS
{
class
CloneDataPolicy
;
}
namespace
mozilla
:
:
dom
{
class
ThreadSafeWorkerRef
;
class
WorkerPrivate
;
class
PromiseWorkerProxy
:
public
PromiseNativeHandler
public
StructuredCloneHolderBase
public
SingleWriterLockOwner
{
friend
class
PromiseWorkerProxyRunnable
;
NS_DECL_THREADSAFE_ISUPPORTS
public
:
typedef
JSObject
*
(
*
ReadCallbackOp
)
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
const
PromiseWorkerProxy
*
aProxy
uint32_t
aTag
uint32_t
aData
)
;
typedef
bool
(
*
WriteCallbackOp
)
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWorker
PromiseWorkerProxy
*
aProxy
JS
:
:
Handle
<
JSObject
*
>
aObj
)
;
bool
OnWritingThread
(
)
const
override
;
struct
PromiseWorkerProxyStructuredCloneCallbacks
{
ReadCallbackOp
Read
;
WriteCallbackOp
Write
;
}
;
static
already_AddRefed
<
PromiseWorkerProxy
>
Create
(
WorkerPrivate
*
aWorkerPrivate
Promise
*
aWorkerPromise
const
PromiseWorkerProxyStructuredCloneCallbacks
*
aCallbacks
=
nullptr
)
;
WorkerPrivate
*
GetWorkerPrivate
(
)
const
NO_THREAD_SAFETY_ANALYSIS
;
Promise
*
WorkerPromise
(
)
const
;
void
CleanUp
(
)
;
Mutex
&
Lock
(
)
RETURN_CAPABILITY
(
mCleanUpLock
)
{
return
mCleanUpLock
;
}
bool
CleanedUp
(
)
const
REQUIRES
(
mCleanUpLock
)
{
mCleanUpLock
.
AssertCurrentThreadOwns
(
)
;
return
mCleanedUp
;
}
JSObject
*
CustomReadHandler
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
const
JS
:
:
CloneDataPolicy
&
aCloneDataPolicy
uint32_t
aTag
uint32_t
aIndex
)
override
;
bool
CustomWriteHandler
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
JS
:
:
Handle
<
JSObject
*
>
aObj
bool
*
aSameProcessScopeRequired
)
override
;
protected
:
virtual
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
virtual
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
;
private
:
explicit
PromiseWorkerProxy
(
Promise
*
aWorkerPromise
const
PromiseWorkerProxyStructuredCloneCallbacks
*
aCallbacks
=
nullptr
)
;
virtual
~
PromiseWorkerProxy
(
)
;
typedef
void
(
Promise
:
:
*
RunCallbackFunc
)
(
JSContext
*
JS
:
:
Handle
<
JS
:
:
Value
>
)
;
void
RunCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
RunCallbackFunc
aFunc
)
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
RefPtr
<
Promise
>
mWorkerPromise
;
bool
mCleanedUp
GUARDED_BY
(
mCleanUpLock
)
;
const
PromiseWorkerProxyStructuredCloneCallbacks
*
mCallbacks
;
Mutex
mCleanUpLock
;
}
;
}
#
endif
