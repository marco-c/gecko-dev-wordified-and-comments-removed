#
ifndef
mozilla_dom_Promise_h
#
define
mozilla_dom_Promise_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
jspubtd
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
{
namespace
dom
{
class
AnyCallback
;
class
MediaStreamError
;
class
PromiseInit
;
class
PromiseNativeHandler
;
class
PromiseDebugging
;
class
Promise
:
public
SupportsWeakPtr
<
Promise
>
{
friend
class
PromiseTask
;
friend
class
PromiseWorkerProxy
;
friend
class
PromiseWorkerProxyRunnable
;
public
:
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
Promise
)
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
Promise
)
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
Promise
)
static
already_AddRefed
<
Promise
>
Create
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
;
static
void
ReportRejectedPromise
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
)
;
typedef
void
(
Promise
:
:
*
MaybeFunc
)
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
void
MaybeResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
void
MaybeReject
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
void
MaybeResolve
(
const
T
&
aArg
)
{
MaybeSomething
(
aArg
&
Promise
:
:
MaybeResolve
)
;
}
void
MaybeResolveWithUndefined
(
)
;
inline
void
MaybeReject
(
nsresult
aArg
)
{
MOZ_ASSERT
(
NS_FAILED
(
aArg
)
)
;
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
inline
void
MaybeReject
(
ErrorResult
&
aArg
)
{
MOZ_ASSERT
(
aArg
.
Failed
(
)
)
;
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
void
MaybeReject
(
const
RefPtr
<
MediaStreamError
>
&
aArg
)
;
void
MaybeRejectWithUndefined
(
)
;
template
<
typename
T
>
void
MaybeRejectBrokenly
(
const
T
&
aArg
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
mGlobal
;
}
static
already_AddRefed
<
Promise
>
Resolve
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
Reject
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
All
(
JSContext
*
aCx
const
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromiseList
ErrorResult
&
aRv
)
;
void
Then
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCalleeGlobal
AnyCallback
*
aResolveCallback
AnyCallback
*
aRejectCallback
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
;
JSObject
*
PromiseObj
(
)
const
{
return
mPromiseObj
;
}
void
AppendNativeHandler
(
PromiseNativeHandler
*
aRunnable
)
;
JSObject
*
GlobalJSObject
(
)
const
;
JSCompartment
*
Compartment
(
)
const
;
static
already_AddRefed
<
Promise
>
CreateFromExisting
(
nsIGlobalObject
*
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromiseObj
)
;
enum
class
PromiseState
{
Pending
Resolved
Rejected
}
;
PromiseState
State
(
)
const
;
protected
:
struct
PromiseCapability
;
explicit
Promise
(
nsIGlobalObject
*
aGlobal
)
;
virtual
~
Promise
(
)
;
void
CreateWrapper
(
JS
:
:
Handle
<
JSObject
*
>
aDesiredProto
ErrorResult
&
aRv
)
;
private
:
template
<
typename
T
>
void
MaybeSomething
(
T
&
aArgument
MaybeFunc
aFunc
)
{
MOZ_ASSERT
(
PromiseObj
(
)
)
;
AutoEntryScript
aes
(
mGlobal
"
Promise
resolution
or
rejection
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
if
(
!
ToJSValue
(
cx
aArgument
&
val
)
)
{
HandleException
(
cx
)
;
return
;
}
(
this
-
>
*
aFunc
)
(
cx
val
)
;
}
void
HandleException
(
JSContext
*
aCx
)
;
RefPtr
<
nsIGlobalObject
>
mGlobal
;
JS
:
:
Heap
<
JSObject
*
>
mPromiseObj
;
}
;
}
}
#
endif
