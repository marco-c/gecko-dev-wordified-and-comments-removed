#
ifndef
mozilla_dom_Promise_h
#
define
mozilla_dom_Promise_h
#
include
<
utility
>
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
jspubtd
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
{
namespace
dom
{
class
AnyCallback
;
class
MediaStreamError
;
class
PromiseInit
;
class
PromiseNativeHandler
;
class
PromiseDebugging
;
#
define
NS_PROMISE_IID
\
{
\
0x1b8d6215
0x3e67
0x43ba
{
\
0x8a
0xf9
0x31
0x5e
0x8f
0xce
0x75
0x65
\
}
\
}
class
Promise
:
public
nsISupports
public
SupportsWeakPtr
<
Promise
>
{
friend
class
PromiseTask
;
friend
class
PromiseWorkerProxy
;
friend
class
PromiseWorkerProxyRunnable
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PROMISE_IID
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS_FINAL
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
Promise
)
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
Promise
)
enum
PropagateUserInteraction
{
eDontPropagateUserInteraction
ePropagateUserInteraction
}
;
static
already_AddRefed
<
Promise
>
Create
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
=
eDontPropagateUserInteraction
)
;
static
void
ReportRejectedPromise
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
)
;
typedef
void
(
Promise
:
:
*
MaybeFunc
)
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
void
MaybeResolve
(
T
&
&
aArg
)
{
MaybeSomething
(
std
:
:
forward
<
T
>
(
aArg
)
&
Promise
:
:
MaybeResolve
)
;
}
void
MaybeResolveWithUndefined
(
)
;
void
MaybeReject
(
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MaybeSomething
(
aValue
&
Promise
:
:
MaybeReject
)
;
}
inline
void
MaybeReject
(
nsresult
aArg
)
{
MOZ_ASSERT
(
NS_FAILED
(
aArg
)
)
;
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
inline
void
MaybeReject
(
ErrorResult
&
&
aArg
)
{
MOZ_ASSERT
(
aArg
.
Failed
(
)
)
;
MaybeSomething
(
std
:
:
move
(
aArg
)
&
Promise
:
:
MaybeReject
)
;
MOZ_ASSERT
(
!
aArg
.
Failed
(
)
)
;
}
void
MaybeReject
(
const
RefPtr
<
MediaStreamError
>
&
aArg
)
;
void
MaybeRejectWithUndefined
(
)
;
void
MaybeResolveWithClone
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
void
MaybeRejectWithClone
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
#
define
DOMEXCEPTION
(
name
err
)
\
inline
void
MaybeRejectWith
#
#
name
(
const
nsACString
&
aMessage
)
{
\
ErrorResult
res
;
\
res
.
Throw
#
#
name
(
aMessage
)
;
\
MaybeReject
(
std
:
:
move
(
res
)
)
;
\
}
\
template
<
int
N
>
\
void
MaybeRejectWith
#
#
name
(
const
char
(
&
aMessage
)
[
N
]
)
{
\
MaybeRejectWith
#
#
name
(
nsLiteralCString
(
aMessage
)
)
;
\
}
#
include
"
mozilla
/
dom
/
DOMExceptionNames
.
h
"
#
undef
DOMEXCEPTION
template
<
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
MaybeRejectWithTypeError
(
Ts
&
&
.
.
.
aMessageArgs
)
{
ErrorResult
res
;
res
.
ThrowTypeError
<
errorNumber
>
(
std
:
:
forward
<
Ts
>
(
aMessageArgs
)
.
.
.
)
;
MaybeReject
(
std
:
:
move
(
res
)
)
;
}
inline
void
MaybeRejectWithTypeError
(
const
nsAString
&
aMessage
)
{
ErrorResult
res
;
res
.
ThrowTypeError
(
aMessage
)
;
MaybeReject
(
std
:
:
move
(
res
)
)
;
}
template
<
int
N
>
void
MaybeRejectWithTypeError
(
const
char16_t
(
&
aMessage
)
[
N
]
)
{
MaybeRejectWithTypeError
(
nsLiteralString
(
aMessage
)
)
;
}
template
<
ErrNum
errorNumber
typename
.
.
.
Ts
>
void
MaybeRejectWithRangeError
(
Ts
&
&
.
.
.
aMessageArgs
)
{
ErrorResult
res
;
res
.
ThrowRangeError
<
errorNumber
>
(
std
:
:
forward
<
Ts
>
(
aMessageArgs
)
.
.
.
)
;
MaybeReject
(
std
:
:
move
(
res
)
)
;
}
inline
void
MaybeRejectWithRangeError
(
const
nsAString
&
aMessage
)
{
ErrorResult
res
;
res
.
ThrowRangeError
(
aMessage
)
;
MaybeReject
(
std
:
:
move
(
res
)
)
;
}
template
<
int
N
>
void
MaybeRejectWithRangeError
(
const
char16_t
(
&
aMessage
)
[
N
]
)
{
MaybeRejectWithRangeError
(
nsLiteralString
(
aMessage
)
)
;
}
template
<
typename
T
>
void
MaybeRejectBrokenly
(
const
T
&
aArg
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetGlobalObject
(
)
;
}
static
already_AddRefed
<
Promise
>
Resolve
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
=
eDontPropagateUserInteraction
)
;
static
already_AddRefed
<
Promise
>
Reject
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
All
(
JSContext
*
aCx
const
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromiseList
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
=
eDontPropagateUserInteraction
)
;
void
Then
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCalleeGlobal
AnyCallback
*
aResolveCallback
AnyCallback
*
aRejectCallback
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
;
template
<
typename
Callback
typename
.
.
.
Args
>
using
IsHandlerCallback
=
IsSame
<
already_AddRefed
<
Promise
>
decltype
(
DeclVal
<
Callback
>
(
)
(
(
JSContext
*
)
(
nullptr
)
DeclVal
<
JS
:
:
Handle
<
JS
:
:
Value
>
>
(
)
DeclVal
<
Args
>
(
)
.
.
.
)
)
>
;
template
<
typename
Callback
typename
.
.
.
Args
>
using
ThenResult
=
typename
EnableIf
<
IsHandlerCallback
<
Callback
Args
.
.
.
>
:
:
value
Result
<
RefPtr
<
Promise
>
nsresult
>
>
:
:
Type
;
template
<
typename
Callback
typename
.
.
.
Args
>
ThenResult
<
Callback
Args
.
.
.
>
ThenWithCycleCollectedArgs
(
Callback
&
&
aOnResolve
Args
&
&
.
.
.
aArgs
)
;
Result
<
RefPtr
<
Promise
>
nsresult
>
ThenWithoutCycleCollection
(
const
std
:
:
function
<
already_AddRefed
<
Promise
>
(
JSContext
*
JS
:
:
HandleValue
)
>
&
aCallback
)
;
JSObject
*
PromiseObj
(
)
const
{
return
mPromiseObj
;
}
void
AppendNativeHandler
(
PromiseNativeHandler
*
aRunnable
)
;
nsIGlobalObject
*
GetGlobalObject
(
)
const
{
return
mGlobal
;
}
static
already_AddRefed
<
Promise
>
CreateFromExisting
(
nsIGlobalObject
*
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromiseObj
PropagateUserInteraction
aPropagateUserInteraction
=
eDontPropagateUserInteraction
)
;
enum
class
PromiseState
{
Pending
Resolved
Rejected
}
;
PromiseState
State
(
)
const
;
protected
:
inline
void
MaybeRejectWithDOMException
(
nsresult
rv
const
nsACString
&
aMessage
)
{
ErrorResult
res
;
res
.
ThrowDOMException
(
rv
aMessage
)
;
MaybeReject
(
std
:
:
move
(
res
)
)
;
}
struct
PromiseCapability
;
explicit
Promise
(
nsIGlobalObject
*
aGlobal
)
;
virtual
~
Promise
(
)
;
void
CreateWrapper
(
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
=
eDontPropagateUserInteraction
)
;
private
:
void
MaybeResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
void
MaybeReject
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
template
<
typename
T
>
void
MaybeSomething
(
T
&
&
aArgument
MaybeFunc
aFunc
)
{
MOZ_ASSERT
(
PromiseObj
(
)
)
;
AutoEntryScript
aes
(
mGlobal
"
Promise
resolution
or
rejection
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
if
(
!
ToJSValue
(
cx
std
:
:
forward
<
T
>
(
aArgument
)
&
val
)
)
{
HandleException
(
cx
)
;
return
;
}
(
this
-
>
*
aFunc
)
(
cx
val
)
;
}
void
HandleException
(
JSContext
*
aCx
)
;
bool
MaybePropagateUserInputEventHandling
(
)
;
RefPtr
<
nsIGlobalObject
>
mGlobal
;
JS
:
:
Heap
<
JSObject
*
>
mPromiseObj
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
Promise
NS_PROMISE_IID
)
}
}
#
endif
