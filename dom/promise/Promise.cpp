#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
Promise
-
inl
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
DOMExceptionBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamError
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
StructuredClone
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
PromiseDebugging
.
h
"
#
include
"
PromiseNativeHandler
.
h
"
#
include
"
PromiseWorkerProxy
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
xpcprivate
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
Atomic
<
uintptr_t
>
gIDGenerator
(
0
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Promise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Promise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGlobal
)
tmp
-
>
mPromiseObj
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Promise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGlobal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
Promise
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mPromiseObj
)
;
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Promise
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
Promise
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Promise
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_ENTRY
(
Promise
)
NS_INTERFACE_MAP_END
Promise
:
:
Promise
(
nsIGlobalObject
*
aGlobal
)
:
mGlobal
(
aGlobal
)
mPromiseObj
(
nullptr
)
{
MOZ_ASSERT
(
mGlobal
)
;
mozilla
:
:
HoldJSObjects
(
this
)
;
}
Promise
:
:
~
Promise
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Create
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
)
{
if
(
!
aGlobal
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
p
=
new
Promise
(
aGlobal
)
;
p
-
>
CreateWrapper
(
nullptr
aRv
aPropagateUserInteraction
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
bool
Promise
:
:
MaybePropagateUserInputEventHandling
(
)
{
JS
:
:
PromiseUserInputEventHandlingState
state
=
EventStateManager
:
:
IsHandlingUserInput
(
)
?
JS
:
:
PromiseUserInputEventHandlingState
:
:
HadUserInteractionAtCreation
:
JS
:
:
PromiseUserInputEventHandlingState
:
:
DidntHaveUserInteractionAtCreation
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
RootingCx
(
)
mPromiseObj
)
;
return
JS
:
:
SetPromiseUserInputEventHandlingState
(
p
state
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Resolve
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
)
{
JSAutoRealm
ar
(
aCx
aGlobal
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
JS
:
:
CallOriginalPromiseResolve
(
aCx
aValue
)
)
;
if
(
!
p
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
nullptr
;
}
return
CreateFromExisting
(
aGlobal
p
aPropagateUserInteraction
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Reject
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
JSAutoRealm
ar
(
aCx
aGlobal
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
JS
:
:
CallOriginalPromiseReject
(
aCx
aValue
)
)
;
if
(
!
p
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
nullptr
;
}
return
CreateFromExisting
(
aGlobal
p
eDontPropagateUserInteraction
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
All
(
JSContext
*
aCx
const
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromiseList
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
)
{
JS
:
:
Rooted
<
JSObject
*
>
globalObj
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
if
(
!
globalObj
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
globalObj
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
JS
:
:
RootedVector
<
JSObject
*
>
promises
(
aCx
)
;
if
(
!
promises
.
reserve
(
aPromiseList
.
Length
(
)
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
nullptr
;
}
for
(
auto
&
promise
:
aPromiseList
)
{
JS
:
:
Rooted
<
JSObject
*
>
promiseObj
(
aCx
promise
-
>
PromiseObj
(
)
)
;
if
(
!
JS_WrapObject
(
aCx
&
promiseObj
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
nullptr
;
}
promises
.
infallibleAppend
(
promiseObj
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
result
(
aCx
JS
:
:
GetWaitForAllPromise
(
aCx
promises
)
)
;
if
(
!
result
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
nullptr
;
}
return
CreateFromExisting
(
global
result
aPropagateUserInteraction
)
;
}
void
Promise
:
:
Then
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCalleeGlobal
AnyCallback
*
aResolveCallback
AnyCallback
*
aRejectCallback
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JSObject
*
>
promise
(
aCx
PromiseObj
(
)
)
;
if
(
!
JS_WrapObject
(
aCx
&
promise
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
resolveCallback
(
aCx
)
;
if
(
aResolveCallback
)
{
resolveCallback
=
aResolveCallback
-
>
CallbackOrNull
(
)
;
if
(
!
JS_WrapObject
(
aCx
&
resolveCallback
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
rejectCallback
(
aCx
)
;
if
(
aRejectCallback
)
{
rejectCallback
=
aRejectCallback
-
>
CallbackOrNull
(
)
;
if
(
!
JS_WrapObject
(
aCx
&
rejectCallback
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
retval
(
aCx
)
;
retval
=
JS
:
:
CallOriginalPromiseThen
(
aCx
promise
resolveCallback
rejectCallback
)
;
if
(
!
retval
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
aRetval
.
setObject
(
*
retval
)
;
}
void
PromiseNativeThenHandlerBase
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
RefPtr
<
Promise
>
promise
=
CallResolveCallback
(
aCx
aValue
)
;
if
(
promise
)
{
mPromise
-
>
MaybeResolve
(
promise
)
;
}
else
{
mPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
}
void
PromiseNativeThenHandlerBase
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
mPromise
-
>
MaybeReject
(
aValue
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
PromiseNativeThenHandlerBase
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
PromiseNativeThenHandlerBase
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPromise
)
tmp
-
>
Traverse
(
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
PromiseNativeThenHandlerBase
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPromise
)
tmp
-
>
Unlink
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PromiseNativeThenHandlerBase
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
PromiseNativeThenHandlerBase
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
PromiseNativeThenHandlerBase
)
Result
<
RefPtr
<
Promise
>
nsresult
>
Promise
:
:
ThenWithoutCycleCollection
(
const
std
:
:
function
<
already_AddRefed
<
Promise
>
(
JSContext
*
aCx
JS
:
:
HandleValue
aValue
)
>
&
aCallback
)
{
return
ThenWithCycleCollectedArgs
(
aCallback
)
;
}
void
Promise
:
:
CreateWrapper
(
JS
:
:
Handle
<
JSObject
*
>
aDesiredProto
ErrorResult
&
aRv
PropagateUserInteraction
aPropagateUserInteraction
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mGlobal
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
mPromiseObj
=
JS
:
:
NewPromiseObject
(
cx
nullptr
aDesiredProto
)
;
if
(
!
mPromiseObj
)
{
JS_ClearPendingException
(
cx
)
;
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
if
(
aPropagateUserInteraction
=
=
ePropagateUserInteraction
)
{
Unused
<
<
MaybePropagateUserInputEventHandling
(
)
;
}
}
void
Promise
:
:
MaybeResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
PromiseObj
(
)
)
;
if
(
!
JS
:
:
ResolvePromise
(
aCx
p
aValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
}
void
Promise
:
:
MaybeReject
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
PromiseObj
(
)
)
;
if
(
!
JS
:
:
RejectPromise
(
aCx
p
aValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
}
#
define
SLOT_NATIVEHANDLER
0
#
define
SLOT_NATIVEHANDLER_TASK
1
enum
class
NativeHandlerTask
:
int32_t
{
Resolve
Reject
}
;
MOZ_CAN_RUN_SCRIPT
static
bool
NativeHandlerCallback
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
Value
v
=
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
SLOT_NATIVEHANDLER
)
;
MOZ_ASSERT
(
v
.
isObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
v
.
toObject
(
)
)
;
PromiseNativeHandler
*
handler
=
nullptr
;
if
(
NS_FAILED
(
UNWRAP_OBJECT
(
PromiseNativeHandler
&
obj
handler
)
)
)
{
return
Throw
(
aCx
NS_ERROR_UNEXPECTED
)
;
}
v
=
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
SLOT_NATIVEHANDLER_TASK
)
;
NativeHandlerTask
task
=
static_cast
<
NativeHandlerTask
>
(
v
.
toInt32
(
)
)
;
if
(
task
=
=
NativeHandlerTask
:
:
Resolve
)
{
MOZ_KnownLive
(
handler
)
-
>
ResolvedCallback
(
aCx
args
.
get
(
0
)
)
;
}
else
{
MOZ_ASSERT
(
task
=
=
NativeHandlerTask
:
:
Reject
)
;
MOZ_KnownLive
(
handler
)
-
>
RejectedCallback
(
aCx
args
.
get
(
0
)
)
;
}
return
true
;
}
static
JSObject
*
CreateNativeHandlerFunction
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aHolder
NativeHandlerTask
aTask
)
{
JSFunction
*
func
=
js
:
:
NewFunctionWithReserved
(
aCx
NativeHandlerCallback
1
0
nullptr
)
;
if
(
!
func
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
JS_GetFunctionObject
(
func
)
)
;
JS
:
:
AssertObjectIsNotGray
(
aHolder
)
;
js
:
:
SetFunctionNativeReserved
(
obj
SLOT_NATIVEHANDLER
JS
:
:
ObjectValue
(
*
aHolder
)
)
;
js
:
:
SetFunctionNativeReserved
(
obj
SLOT_NATIVEHANDLER_TASK
JS
:
:
Int32Value
(
static_cast
<
int32_t
>
(
aTask
)
)
)
;
return
obj
;
}
namespace
{
class
PromiseNativeHandlerShim
final
:
public
PromiseNativeHandler
{
RefPtr
<
PromiseNativeHandler
>
mInner
;
~
PromiseNativeHandlerShim
(
)
{
}
public
:
explicit
PromiseNativeHandlerShim
(
PromiseNativeHandler
*
aInner
)
:
mInner
(
aInner
)
{
MOZ_ASSERT
(
mInner
)
;
}
MOZ_CAN_RUN_SCRIPT
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
RefPtr
<
PromiseNativeHandler
>
inner
=
mInner
.
forget
(
)
;
inner
-
>
ResolvedCallback
(
aCx
aValue
)
;
MOZ_ASSERT
(
!
mInner
)
;
}
MOZ_CAN_RUN_SCRIPT
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
RefPtr
<
PromiseNativeHandler
>
inner
=
mInner
.
forget
(
)
;
inner
-
>
RejectedCallback
(
aCx
aValue
)
;
MOZ_ASSERT
(
!
mInner
)
;
}
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aWrapper
)
{
return
PromiseNativeHandler_Binding
:
:
Wrap
(
aCx
this
aGivenProto
aWrapper
)
;
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PromiseNativeHandlerShim
)
}
;
NS_IMPL_CYCLE_COLLECTION
(
PromiseNativeHandlerShim
mInner
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
PromiseNativeHandlerShim
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
PromiseNativeHandlerShim
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PromiseNativeHandlerShim
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
}
void
Promise
:
:
AppendNativeHandler
(
PromiseNativeHandler
*
aRunnable
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mGlobal
)
)
)
{
return
;
}
RefPtr
<
PromiseNativeHandlerShim
>
shim
=
new
PromiseNativeHandlerShim
(
aRunnable
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
handlerWrapper
(
cx
)
;
if
(
NS_WARN_IF
(
!
shim
-
>
WrapObject
(
cx
nullptr
&
handlerWrapper
)
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
resolveFunc
(
cx
)
;
resolveFunc
=
CreateNativeHandlerFunction
(
cx
handlerWrapper
NativeHandlerTask
:
:
Resolve
)
;
if
(
NS_WARN_IF
(
!
resolveFunc
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
rejectFunc
(
cx
)
;
rejectFunc
=
CreateNativeHandlerFunction
(
cx
handlerWrapper
NativeHandlerTask
:
:
Reject
)
;
if
(
NS_WARN_IF
(
!
rejectFunc
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
promiseObj
(
cx
PromiseObj
(
)
)
;
if
(
NS_WARN_IF
(
!
JS
:
:
AddPromiseReactions
(
cx
promiseObj
resolveFunc
rejectFunc
)
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
}
void
Promise
:
:
HandleException
(
JSContext
*
aCx
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
aCx
)
;
if
(
JS_GetPendingException
(
aCx
&
exn
)
)
{
JS_ClearPendingException
(
aCx
)
;
MaybeReject
(
aCx
exn
)
;
}
}
already_AddRefed
<
Promise
>
Promise
:
:
CreateFromExisting
(
nsIGlobalObject
*
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromiseObj
PropagateUserInteraction
aPropagateUserInteraction
)
{
MOZ_ASSERT
(
js
:
:
GetObjectCompartment
(
aGlobal
-
>
GetGlobalJSObjectPreserveColor
(
)
)
=
=
js
:
:
GetObjectCompartment
(
aPromiseObj
)
)
;
RefPtr
<
Promise
>
p
=
new
Promise
(
aGlobal
)
;
p
-
>
mPromiseObj
=
aPromiseObj
;
if
(
aPropagateUserInteraction
=
=
ePropagateUserInteraction
&
&
!
p
-
>
MaybePropagateUserInputEventHandling
(
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
void
Promise
:
:
MaybeResolveWithUndefined
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeResolve
(
JS
:
:
UndefinedHandleValue
)
;
}
void
Promise
:
:
MaybeReject
(
const
RefPtr
<
MediaStreamError
>
&
aArg
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
void
Promise
:
:
MaybeRejectWithUndefined
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeSomething
(
JS
:
:
UndefinedHandleValue
&
Promise
:
:
MaybeReject
)
;
}
void
Promise
:
:
ReportRejectedPromise
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
)
{
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
aPromise
)
)
;
MOZ_ASSERT
(
JS
:
:
GetPromiseState
(
aPromise
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
aCx
JS
:
:
GetPromiseResult
(
aPromise
)
)
;
RefPtr
<
xpc
:
:
ErrorReport
>
xpcReport
=
new
xpc
:
:
ErrorReport
(
)
;
bool
isMainThread
=
MOZ_LIKELY
(
NS_IsMainThread
(
)
)
;
bool
isChrome
=
isMainThread
?
nsContentUtils
:
:
IsSystemPrincipal
(
nsContentUtils
:
:
ObjectPrincipal
(
aPromise
)
)
:
IsCurrentThreadRunningChromeWorker
(
)
;
nsGlobalWindowInner
*
win
=
isMainThread
?
xpc
:
:
WindowGlobalOrNull
(
aPromise
)
:
nullptr
;
js
:
:
ErrorReport
report
(
aCx
)
;
RefPtr
<
Exception
>
exn
;
if
(
result
.
isObject
(
)
&
&
(
NS_SUCCEEDED
(
UNWRAP_OBJECT
(
DOMException
&
result
exn
)
)
|
|
NS_SUCCEEDED
(
UNWRAP_OBJECT
(
Exception
&
result
exn
)
)
)
)
{
xpcReport
-
>
Init
(
aCx
exn
isChrome
win
?
win
-
>
WindowID
(
)
:
0
)
;
}
else
if
(
report
.
init
(
aCx
result
js
:
:
ErrorReport
:
:
NoSideEffects
)
)
{
xpcReport
-
>
Init
(
report
.
report
(
)
report
.
toStringResult
(
)
.
c_str
(
)
isChrome
win
?
win
-
>
WindowID
(
)
:
0
)
;
}
else
{
JS_ClearPendingException
(
aCx
)
;
return
;
}
RefPtr
<
nsIRunnable
>
event
=
new
AsyncErrorReporter
(
xpcReport
)
;
if
(
win
)
{
win
-
>
Dispatch
(
mozilla
:
:
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
else
{
NS_DispatchToMainThread
(
event
)
;
}
}
void
Promise
:
:
MaybeResolveWithClone
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
JS
:
:
Rooted
<
JSObject
*
>
sourceScope
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
AutoEntryScript
aes
(
GetParentObject
(
)
"
Promise
resolution
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
aValue
)
;
xpc
:
:
StackScopedCloneOptions
options
;
options
.
wrapReflectors
=
true
;
if
(
!
StackScopedClone
(
cx
options
sourceScope
&
value
)
)
{
HandleException
(
cx
)
;
return
;
}
MaybeResolve
(
aCx
value
)
;
}
void
Promise
:
:
MaybeRejectWithClone
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
JS
:
:
Rooted
<
JSObject
*
>
sourceScope
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
AutoEntryScript
aes
(
GetParentObject
(
)
"
Promise
rejection
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
aValue
)
;
xpc
:
:
StackScopedCloneOptions
options
;
options
.
wrapReflectors
=
true
;
if
(
!
StackScopedClone
(
cx
options
sourceScope
&
value
)
)
{
HandleException
(
cx
)
;
return
;
}
MaybeReject
(
aCx
value
)
;
}
class
PromiseWorkerProxyRunnable
:
public
WorkerRunnable
{
public
:
PromiseWorkerProxyRunnable
(
PromiseWorkerProxy
*
aPromiseWorkerProxy
PromiseWorkerProxy
:
:
RunCallbackFunc
aFunc
)
:
WorkerRunnable
(
aPromiseWorkerProxy
-
>
GetWorkerPrivate
(
)
WorkerThreadUnchangedBusyCount
)
mPromiseWorkerProxy
(
aPromiseWorkerProxy
)
mFunc
(
aFunc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPromiseWorkerProxy
)
;
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
=
=
mWorkerPrivate
)
;
MOZ_ASSERT
(
mPromiseWorkerProxy
)
;
RefPtr
<
Promise
>
workerPromise
=
mPromiseWorkerProxy
-
>
WorkerPromise
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
mPromiseWorkerProxy
-
>
Read
(
aCx
&
value
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
false
;
}
(
workerPromise
-
>
*
mFunc
)
(
aCx
value
)
;
mPromiseWorkerProxy
-
>
CleanUp
(
)
;
return
true
;
}
protected
:
~
PromiseWorkerProxyRunnable
(
)
{
}
private
:
RefPtr
<
PromiseWorkerProxy
>
mPromiseWorkerProxy
;
PromiseWorkerProxy
:
:
RunCallbackFunc
mFunc
;
}
;
already_AddRefed
<
PromiseWorkerProxy
>
PromiseWorkerProxy
:
:
Create
(
WorkerPrivate
*
aWorkerPrivate
Promise
*
aWorkerPromise
const
PromiseWorkerProxyStructuredCloneCallbacks
*
aCb
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPromise
)
;
MOZ_ASSERT_IF
(
aCb
!
!
aCb
-
>
Write
&
&
!
!
aCb
-
>
Read
)
;
RefPtr
<
PromiseWorkerProxy
>
proxy
=
new
PromiseWorkerProxy
(
aWorkerPromise
aCb
)
;
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
aWorkerPrivate
"
PromiseWorkerProxy
"
[
proxy
]
(
)
{
proxy
-
>
CleanUp
(
)
;
}
)
;
if
(
NS_WARN_IF
(
!
workerRef
)
)
{
proxy
-
>
CleanProperties
(
)
;
return
nullptr
;
}
proxy
-
>
mWorkerRef
=
new
ThreadSafeWorkerRef
(
workerRef
)
;
proxy
.
get
(
)
-
>
AddRef
(
)
;
return
proxy
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS0
(
PromiseWorkerProxy
)
PromiseWorkerProxy
:
:
PromiseWorkerProxy
(
Promise
*
aWorkerPromise
const
PromiseWorkerProxyStructuredCloneCallbacks
*
aCallbacks
)
:
mWorkerPromise
(
aWorkerPromise
)
mCleanedUp
(
false
)
mCallbacks
(
aCallbacks
)
mCleanUpLock
(
"
cleanUpLock
"
)
{
}
PromiseWorkerProxy
:
:
~
PromiseWorkerProxy
(
)
{
MOZ_ASSERT
(
mCleanedUp
)
;
MOZ_ASSERT
(
!
mWorkerPromise
)
;
MOZ_ASSERT
(
!
mWorkerRef
)
;
}
void
PromiseWorkerProxy
:
:
CleanProperties
(
)
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
mCleanedUp
=
true
;
mWorkerPromise
=
nullptr
;
mWorkerRef
=
nullptr
;
Clear
(
)
;
}
WorkerPrivate
*
PromiseWorkerProxy
:
:
GetWorkerPrivate
(
)
const
{
#
ifdef
DEBUG
if
(
NS_IsMainThread
(
)
)
{
mCleanUpLock
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
MOZ_ASSERT
(
!
mCleanedUp
)
;
MOZ_ASSERT
(
mWorkerRef
)
;
return
mWorkerRef
-
>
Private
(
)
;
}
Promise
*
PromiseWorkerProxy
:
:
WorkerPromise
(
)
const
{
MOZ_ASSERT
(
IsCurrentThreadRunningWorker
(
)
)
;
MOZ_ASSERT
(
mWorkerPromise
)
;
return
mWorkerPromise
;
}
void
PromiseWorkerProxy
:
:
RunCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
RunCallbackFunc
aFunc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
Lock
(
)
)
;
if
(
CleanedUp
(
)
)
{
return
;
}
if
(
!
Write
(
aCx
aValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
MOZ_ASSERT
(
false
"
cannot
serialize
the
value
with
the
StructuredCloneAlgorithm
!
"
)
;
}
RefPtr
<
PromiseWorkerProxyRunnable
>
runnable
=
new
PromiseWorkerProxyRunnable
(
this
aFunc
)
;
runnable
-
>
Dispatch
(
)
;
}
void
PromiseWorkerProxy
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
RunCallback
(
aCx
aValue
&
Promise
:
:
MaybeResolve
)
;
}
void
PromiseWorkerProxy
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
RunCallback
(
aCx
aValue
&
Promise
:
:
MaybeReject
)
;
}
void
PromiseWorkerProxy
:
:
CleanUp
(
)
{
{
MutexAutoLock
lock
(
Lock
(
)
)
;
if
(
CleanedUp
(
)
)
{
return
;
}
MOZ_ASSERT
(
mWorkerRef
)
;
mWorkerRef
-
>
Private
(
)
-
>
AssertIsOnWorkerThread
(
)
;
mWorkerRef
=
nullptr
;
CleanProperties
(
)
;
}
Release
(
)
;
}
JSObject
*
PromiseWorkerProxy
:
:
CustomReadHandler
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
uint32_t
aTag
uint32_t
aIndex
)
{
if
(
NS_WARN_IF
(
!
mCallbacks
)
)
{
return
nullptr
;
}
return
mCallbacks
-
>
Read
(
aCx
aReader
this
aTag
aIndex
)
;
}
bool
PromiseWorkerProxy
:
:
CustomWriteHandler
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
JS
:
:
Handle
<
JSObject
*
>
aObj
)
{
if
(
NS_WARN_IF
(
!
mCallbacks
)
)
{
return
false
;
}
return
mCallbacks
-
>
Write
(
aCx
aWriter
this
aObj
)
;
}
template
<
>
void
Promise
:
:
MaybeRejectBrokenly
(
const
RefPtr
<
DOMException
>
&
aArg
)
{
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
template
<
>
void
Promise
:
:
MaybeRejectBrokenly
(
const
nsAString
&
aArg
)
{
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
Promise
:
:
PromiseState
Promise
:
:
State
(
)
const
{
JS
:
:
Rooted
<
JSObject
*
>
p
(
RootingCx
(
)
PromiseObj
(
)
)
;
const
JS
:
:
PromiseState
state
=
JS
:
:
GetPromiseState
(
p
)
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
{
return
PromiseState
:
:
Resolved
;
}
if
(
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
{
return
PromiseState
:
:
Rejected
;
}
return
PromiseState
:
:
Pending
;
}
}
}
