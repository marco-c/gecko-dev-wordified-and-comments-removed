#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
js
/
Debug
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
DOMError
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
DOMExceptionBinding
.
h
"
#
include
"
mozilla
/
dom
/
MediaStreamError
.
h
"
#
include
"
mozilla
/
dom
/
PromiseBinding
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
StructuredClone
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
PromiseCallback
.
h
"
#
include
"
PromiseDebugging
.
h
"
#
include
"
PromiseNativeHandler
.
h
"
#
include
"
PromiseWorkerProxy
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
xpcpublic
.
h
"
#
ifdef
MOZ_CRASHREPORTER
#
include
"
nsExceptionHandler
.
h
"
#
endif
namespace
mozilla
{
namespace
dom
{
namespace
{
Atomic
<
uintptr_t
>
gIDGenerator
(
0
)
;
}
using
namespace
workers
;
#
ifndef
SPIDERMONKEY_PROMISE
class
PromiseReactionJob
final
:
public
Runnable
{
public
:
PromiseReactionJob
(
Promise
*
aPromise
PromiseCallback
*
aCallback
const
JS
:
:
Value
&
aValue
)
:
mPromise
(
aPromise
)
mCallback
(
aCallback
)
mValue
(
CycleCollectedJSContext
:
:
Get
(
)
-
>
Context
(
)
aValue
)
{
MOZ_ASSERT
(
aPromise
)
;
MOZ_ASSERT
(
aCallback
)
;
MOZ_COUNT_CTOR
(
PromiseReactionJob
)
;
}
virtual
~
PromiseReactionJob
(
)
{
NS_ASSERT_OWNINGTHREAD
(
PromiseReactionJob
)
;
MOZ_COUNT_DTOR
(
PromiseReactionJob
)
;
}
protected
:
NS_IMETHOD
Run
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
PromiseReactionJob
)
;
MOZ_ASSERT
(
mPromise
-
>
GetWrapper
(
)
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mPromise
-
>
GetWrapper
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
mValue
)
;
if
(
!
MaybeWrapValue
(
cx
&
value
)
)
{
NS_WARNING
(
"
Failed
to
wrap
value
into
the
right
compartment
.
"
)
;
JS_ClearPendingException
(
cx
)
;
return
NS_OK
;
}
JS
:
:
Rooted
<
JSObject
*
>
asyncStack
(
cx
mPromise
-
>
mAllocationStack
)
;
{
Maybe
<
JS
:
:
AutoSetAsyncStackForNewCalls
>
sas
;
if
(
asyncStack
)
{
sas
.
emplace
(
cx
asyncStack
"
Promise
"
)
;
}
mCallback
-
>
Call
(
cx
value
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
PromiseCallback
>
mCallback
;
JS
:
:
PersistentRooted
<
JS
:
:
Value
>
mValue
;
NS_DECL_OWNINGTHREAD
;
}
;
namespace
{
void
LinkThenableCallables
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aResolveFunc
JS
:
:
Handle
<
JSObject
*
>
aRejectFunc
)
{
js
:
:
SetFunctionNativeReserved
(
aResolveFunc
Promise
:
:
SLOT_DATA
JS
:
:
ObjectValue
(
*
aRejectFunc
)
)
;
js
:
:
SetFunctionNativeReserved
(
aRejectFunc
Promise
:
:
SLOT_DATA
JS
:
:
ObjectValue
(
*
aResolveFunc
)
)
;
}
bool
MarkAsCalledIfNotCalledBefore
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aFunc
)
{
JS
:
:
Value
otherFuncVal
=
js
:
:
GetFunctionNativeReserved
(
aFunc
Promise
:
:
SLOT_DATA
)
;
if
(
!
otherFuncVal
.
isObject
(
)
)
{
return
false
;
}
JSObject
*
otherFuncObj
=
&
otherFuncVal
.
toObject
(
)
;
MOZ_ASSERT
(
js
:
:
GetFunctionNativeReserved
(
otherFuncObj
Promise
:
:
SLOT_DATA
)
.
isObject
(
)
)
;
js
:
:
SetFunctionNativeReserved
(
aFunc
Promise
:
:
SLOT_DATA
JS
:
:
UndefinedValue
(
)
)
;
js
:
:
SetFunctionNativeReserved
(
otherFuncObj
Promise
:
:
SLOT_DATA
JS
:
:
UndefinedValue
(
)
)
;
return
true
;
}
Promise
*
GetPromise
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aFunc
)
{
JS
:
:
Value
promiseVal
=
js
:
:
GetFunctionNativeReserved
(
aFunc
Promise
:
:
SLOT_PROMISE
)
;
MOZ_ASSERT
(
promiseVal
.
isObject
(
)
)
;
Promise
*
promise
;
UNWRAP_OBJECT
(
Promise
&
promiseVal
.
toObject
(
)
promise
)
;
return
promise
;
}
}
class
PromiseResolveThenableJob
final
:
public
Runnable
{
public
:
PromiseResolveThenableJob
(
Promise
*
aPromise
JS
:
:
Handle
<
JSObject
*
>
aThenable
PromiseInit
*
aThen
)
:
mPromise
(
aPromise
)
mThenable
(
CycleCollectedJSContext
:
:
Get
(
)
-
>
Context
(
)
aThenable
)
mThen
(
aThen
)
{
MOZ_ASSERT
(
aPromise
)
;
MOZ_COUNT_CTOR
(
PromiseResolveThenableJob
)
;
}
virtual
~
PromiseResolveThenableJob
(
)
{
NS_ASSERT_OWNINGTHREAD
(
PromiseResolveThenableJob
)
;
MOZ_COUNT_DTOR
(
PromiseResolveThenableJob
)
;
}
protected
:
NS_IMETHOD
Run
(
)
override
{
NS_ASSERT_OWNINGTHREAD
(
PromiseResolveThenableJob
)
;
MOZ_ASSERT
(
mPromise
-
>
GetWrapper
(
)
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mPromise
-
>
GetWrapper
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
resolveFunc
(
cx
mPromise
-
>
CreateThenableFunction
(
cx
mPromise
PromiseCallback
:
:
Resolve
)
)
;
if
(
!
resolveFunc
)
{
mPromise
-
>
HandleException
(
cx
)
;
return
NS_OK
;
}
JS
:
:
Rooted
<
JSObject
*
>
rejectFunc
(
cx
mPromise
-
>
CreateThenableFunction
(
cx
mPromise
PromiseCallback
:
:
Reject
)
)
;
if
(
!
rejectFunc
)
{
mPromise
-
>
HandleException
(
cx
)
;
return
NS_OK
;
}
LinkThenableCallables
(
cx
resolveFunc
rejectFunc
)
;
ErrorResult
rv
;
JS
:
:
Rooted
<
JSObject
*
>
rootedThenable
(
cx
mThenable
)
;
mThen
-
>
Call
(
rootedThenable
resolveFunc
rejectFunc
rv
"
promise
thenable
"
CallbackObject
:
:
eRethrowExceptions
mPromise
-
>
Compartment
(
)
)
;
rv
.
WouldReportJSException
(
)
;
if
(
rv
.
Failed
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
cx
)
;
{
JSAutoCompartment
ac
(
cx
mPromise
-
>
GlobalJSObject
(
)
)
;
DebugOnly
<
bool
>
conversionResult
=
ToJSValue
(
cx
rv
&
exn
)
;
MOZ_ASSERT
(
conversionResult
)
;
}
bool
couldMarkAsCalled
=
MarkAsCalledIfNotCalledBefore
(
cx
resolveFunc
)
;
if
(
couldMarkAsCalled
)
{
bool
ok
=
JS_WrapValue
(
cx
&
exn
)
;
MOZ_ASSERT
(
ok
)
;
if
(
!
ok
)
{
NS_WARNING
(
"
Failed
to
wrap
value
into
the
right
compartment
.
"
)
;
}
mPromise
-
>
RejectInternal
(
cx
exn
)
;
}
}
return
rv
.
StealNSResult
(
)
;
}
private
:
RefPtr
<
Promise
>
mPromise
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mThenable
;
RefPtr
<
PromiseInit
>
mThen
;
NS_DECL_OWNINGTHREAD
;
}
;
struct
MOZ_STACK_CLASS
Promise
:
:
PromiseCapability
{
explicit
PromiseCapability
(
JSContext
*
aCx
)
:
mPromise
(
aCx
)
mResolve
(
aCx
)
mReject
(
aCx
)
{
}
void
RejectWithException
(
JSContext
*
aCx
ErrorResult
&
aRv
)
;
JS
:
:
Value
PromiseValue
(
)
const
;
JS
:
:
Rooted
<
JSObject
*
>
mPromise
;
JS
:
:
Rooted
<
JS
:
:
Value
>
mResolve
;
JS
:
:
Rooted
<
JS
:
:
Value
>
mReject
;
RefPtr
<
Promise
>
mNativePromise
;
private
:
PromiseCapability
(
const
PromiseCapability
&
)
=
delete
;
PromiseCapability
(
PromiseCapability
&
&
)
=
delete
;
}
;
void
Promise
:
:
PromiseCapability
:
:
RejectWithException
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
)
;
MOZ_ASSERT
(
mNativePromise
|
|
mPromise
"
NewPromiseCapability
didn
'
t
succeed
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
aCx
)
;
if
(
!
JS_GetPendingException
(
aCx
&
exn
)
)
{
aRv
.
ThrowUncatchableException
(
)
;
return
;
}
JS_ClearPendingException
(
aCx
)
;
if
(
mNativePromise
)
{
mNativePromise
-
>
MaybeRejectInternal
(
aCx
exn
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
ignored
(
aCx
)
;
if
(
!
JS
:
:
Call
(
aCx
JS
:
:
UndefinedHandleValue
mReject
JS
:
:
HandleValueArray
(
exn
)
&
ignored
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
}
}
JS
:
:
Value
Promise
:
:
PromiseCapability
:
:
PromiseValue
(
)
const
{
MOZ_ASSERT
(
mNativePromise
|
|
mPromise
"
NewPromiseCapability
didn
'
t
succeed
"
)
;
if
(
mNativePromise
)
{
return
JS
:
:
ObjectValue
(
*
mNativePromise
-
>
GetWrapper
(
)
)
;
}
return
JS
:
:
ObjectValue
(
*
mPromise
)
;
}
#
endif
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Promise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Promise
)
#
ifndef
SPIDERMONKEY_PROMISE
#
if
defined
(
DOM_PROMISE_DEPRECATED_REPORTING
)
tmp
-
>
MaybeReportRejectedOnce
(
)
;
#
else
tmp
-
>
mResult
=
JS
:
:
UndefinedValue
(
)
;
#
endif
#
endif
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGlobal
)
#
ifndef
SPIDERMONKEY_PROMISE
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mResolveCallbacks
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRejectCallbacks
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
#
else
tmp
-
>
mPromiseObj
=
nullptr
;
#
endif
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Promise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGlobal
)
#
ifndef
SPIDERMONKEY_PROMISE
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mResolveCallbacks
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRejectCallbacks
)
#
endif
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
Promise
)
#
ifndef
SPIDERMONKEY_PROMISE
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mResult
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mAllocationStack
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mRejectionStack
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mFullfillmentStack
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
#
else
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mPromiseObj
)
;
#
endif
NS_IMPL_CYCLE_COLLECTION_TRACE_END
#
ifndef
SPIDERMONKEY_PROMISE
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
Promise
)
if
(
tmp
-
>
IsBlack
(
)
)
{
tmp
-
>
mResult
.
exposeToActiveJS
(
)
;
tmp
-
>
mAllocationStack
.
exposeToActiveJS
(
)
;
tmp
-
>
mRejectionStack
.
exposeToActiveJS
(
)
;
tmp
-
>
mFullfillmentStack
.
exposeToActiveJS
(
)
;
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
Promise
)
return
tmp
-
>
IsBlackAndDoesNotNeedTracing
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
Promise
)
return
tmp
-
>
IsBlack
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
#
endif
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Promise
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
Promise
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Promise
)
#
ifndef
SPIDERMONKEY_PROMISE
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
#
endif
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_ENTRY
(
Promise
)
NS_INTERFACE_MAP_END
Promise
:
:
Promise
(
nsIGlobalObject
*
aGlobal
)
:
mGlobal
(
aGlobal
)
#
ifndef
SPIDERMONKEY_PROMISE
mResult
(
JS
:
:
UndefinedValue
(
)
)
mAllocationStack
(
nullptr
)
mRejectionStack
(
nullptr
)
mFullfillmentStack
(
nullptr
)
mState
(
Pending
)
#
if
defined
(
DOM_PROMISE_DEPRECATED_REPORTING
)
mHadRejectCallback
(
false
)
#
endif
mTaskPending
(
false
)
mResolvePending
(
false
)
mIsLastInChain
(
true
)
mWasNotifiedAsUncaught
(
false
)
mID
(
0
)
#
else
mPromiseObj
(
nullptr
)
#
endif
{
MOZ_ASSERT
(
mGlobal
)
;
mozilla
:
:
HoldJSObjects
(
this
)
;
#
ifndef
SPIDERMONKEY_PROMISE
mCreationTimestamp
=
TimeStamp
:
:
Now
(
)
;
#
endif
}
Promise
:
:
~
Promise
(
)
{
#
ifndef
SPIDERMONKEY_PROMISE
#
if
defined
(
DOM_PROMISE_DEPRECATED_REPORTING
)
MaybeReportRejectedOnce
(
)
;
#
endif
#
endif
mozilla
:
:
DropJSObjects
(
this
)
;
}
#
ifdef
SPIDERMONKEY_PROMISE
bool
Promise
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aWrapper
)
{
#
ifdef
DEBUG
binding_detail
:
:
AssertReflectorHasGivenProto
(
aCx
mPromiseObj
aGivenProto
)
;
#
endif
aWrapper
.
set
(
mPromiseObj
)
;
return
true
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Create
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
{
if
(
!
aGlobal
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
p
=
new
Promise
(
aGlobal
)
;
p
-
>
CreateWrapper
(
nullptr
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Resolve
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
JSAutoCompartment
ac
(
aCx
aGlobal
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
JS
:
:
CallOriginalPromiseResolve
(
aCx
aValue
)
)
;
if
(
!
p
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
nullptr
;
}
return
CreateFromExisting
(
aGlobal
p
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Reject
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
JSAutoCompartment
ac
(
aCx
aGlobal
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
JS
:
:
CallOriginalPromiseReject
(
aCx
aValue
)
)
;
if
(
!
p
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
nullptr
;
}
return
CreateFromExisting
(
aGlobal
p
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
All
(
const
GlobalObject
&
aGlobal
const
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromiseList
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
;
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
AutoObjectVector
promises
(
cx
)
;
if
(
!
promises
.
reserve
(
aPromiseList
.
Length
(
)
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
nullptr
;
}
for
(
auto
&
promise
:
aPromiseList
)
{
JS
:
:
Rooted
<
JSObject
*
>
promiseObj
(
cx
promise
-
>
PromiseObj
(
)
)
;
if
(
!
JS_WrapObject
(
cx
&
promiseObj
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
nullptr
;
}
promises
.
infallibleAppend
(
promiseObj
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
result
(
cx
JS
:
:
GetWaitForAllPromise
(
cx
promises
)
)
;
if
(
!
result
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
nullptr
;
}
return
CreateFromExisting
(
global
result
)
;
}
void
Promise
:
:
Then
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCalleeGlobal
AnyCallback
*
aResolveCallback
AnyCallback
*
aRejectCallback
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JSObject
*
>
promise
(
aCx
PromiseObj
(
)
)
;
if
(
!
JS_WrapObject
(
aCx
&
promise
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
resolveCallback
(
aCx
)
;
if
(
aResolveCallback
)
{
resolveCallback
=
aResolveCallback
-
>
Callback
(
)
;
if
(
!
JS_WrapObject
(
aCx
&
resolveCallback
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
rejectCallback
(
aCx
)
;
if
(
aRejectCallback
)
{
rejectCallback
=
aRejectCallback
-
>
Callback
(
)
;
if
(
!
JS_WrapObject
(
aCx
&
rejectCallback
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
}
JS
:
:
Rooted
<
JSObject
*
>
retval
(
aCx
)
;
retval
=
JS
:
:
CallOriginalPromiseThen
(
aCx
promise
resolveCallback
rejectCallback
)
;
if
(
!
retval
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
aRetval
.
setObject
(
*
retval
)
;
}
static
bool
DoNothingPromiseExecutor
(
JSContext
*
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
void
Promise
:
:
CreateWrapper
(
JS
:
:
Handle
<
JSObject
*
>
aDesiredProto
ErrorResult
&
aRv
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mGlobal
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JSFunction
*
doNothingFunc
=
JS_NewFunction
(
cx
DoNothingPromiseExecutor
2
0
nullptr
)
;
if
(
!
doNothingFunc
)
{
JS_ClearPendingException
(
cx
)
;
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
doNothingObj
(
cx
JS_GetFunctionObject
(
doNothingFunc
)
)
;
mPromiseObj
=
JS
:
:
NewPromiseObject
(
cx
doNothingObj
aDesiredProto
)
;
if
(
!
mPromiseObj
)
{
JS_ClearPendingException
(
cx
)
;
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
}
void
Promise
:
:
MaybeResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
PromiseObj
(
)
)
;
if
(
!
JS
:
:
ResolvePromise
(
aCx
p
aValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
}
void
Promise
:
:
MaybeReject
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JSObject
*
>
p
(
aCx
PromiseObj
(
)
)
;
if
(
!
JS
:
:
RejectPromise
(
aCx
p
aValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
}
}
#
define
SLOT_NATIVEHANDLER
0
#
define
SLOT_NATIVEHANDLER_TASK
1
enum
class
NativeHandlerTask
:
int32_t
{
Resolve
Reject
}
;
static
bool
NativeHandlerCallback
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aCx
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
SLOT_NATIVEHANDLER
)
)
;
MOZ_ASSERT
(
v
.
isObject
(
)
)
;
PromiseNativeHandler
*
handler
=
nullptr
;
if
(
NS_FAILED
(
UNWRAP_OBJECT
(
PromiseNativeHandler
&
v
.
toObject
(
)
handler
)
)
)
{
return
Throw
(
aCx
NS_ERROR_UNEXPECTED
)
;
}
v
=
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
SLOT_NATIVEHANDLER_TASK
)
;
NativeHandlerTask
task
=
static_cast
<
NativeHandlerTask
>
(
v
.
toInt32
(
)
)
;
if
(
task
=
=
NativeHandlerTask
:
:
Resolve
)
{
handler
-
>
ResolvedCallback
(
aCx
args
.
get
(
0
)
)
;
}
else
{
MOZ_ASSERT
(
task
=
=
NativeHandlerTask
:
:
Reject
)
;
handler
-
>
RejectedCallback
(
aCx
args
.
get
(
0
)
)
;
}
return
true
;
}
static
JSObject
*
CreateNativeHandlerFunction
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aHolder
NativeHandlerTask
aTask
)
{
JSFunction
*
func
=
js
:
:
NewFunctionWithReserved
(
aCx
NativeHandlerCallback
1
0
nullptr
)
;
if
(
!
func
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
JS_GetFunctionObject
(
func
)
)
;
JS
:
:
ExposeObjectToActiveJS
(
aHolder
)
;
js
:
:
SetFunctionNativeReserved
(
obj
SLOT_NATIVEHANDLER
JS
:
:
ObjectValue
(
*
aHolder
)
)
;
js
:
:
SetFunctionNativeReserved
(
obj
SLOT_NATIVEHANDLER_TASK
JS
:
:
Int32Value
(
static_cast
<
int32_t
>
(
aTask
)
)
)
;
return
obj
;
}
namespace
{
class
PromiseNativeHandlerShim
final
:
public
PromiseNativeHandler
{
RefPtr
<
PromiseNativeHandler
>
mInner
;
~
PromiseNativeHandlerShim
(
)
{
}
public
:
explicit
PromiseNativeHandlerShim
(
PromiseNativeHandler
*
aInner
)
:
mInner
(
aInner
)
{
MOZ_ASSERT
(
mInner
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
mInner
-
>
ResolvedCallback
(
aCx
aValue
)
;
mInner
=
nullptr
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
mInner
-
>
RejectedCallback
(
aCx
aValue
)
;
mInner
=
nullptr
;
}
bool
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
JS
:
:
MutableHandle
<
JSObject
*
>
aWrapper
)
{
return
PromiseNativeHandlerBinding
:
:
Wrap
(
aCx
this
aGivenProto
aWrapper
)
;
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
PromiseNativeHandlerShim
)
}
;
NS_IMPL_CYCLE_COLLECTION
(
PromiseNativeHandlerShim
mInner
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
PromiseNativeHandlerShim
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
PromiseNativeHandlerShim
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
PromiseNativeHandlerShim
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
}
void
Promise
:
:
AppendNativeHandler
(
PromiseNativeHandler
*
aRunnable
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mGlobal
)
)
)
{
return
;
}
RefPtr
<
PromiseNativeHandlerShim
>
shim
=
new
PromiseNativeHandlerShim
(
aRunnable
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
handlerWrapper
(
cx
)
;
if
(
NS_WARN_IF
(
!
shim
-
>
WrapObject
(
cx
nullptr
&
handlerWrapper
)
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
resolveFunc
(
cx
)
;
resolveFunc
=
CreateNativeHandlerFunction
(
cx
handlerWrapper
NativeHandlerTask
:
:
Resolve
)
;
if
(
NS_WARN_IF
(
!
resolveFunc
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
rejectFunc
(
cx
)
;
rejectFunc
=
CreateNativeHandlerFunction
(
cx
handlerWrapper
NativeHandlerTask
:
:
Reject
)
;
if
(
NS_WARN_IF
(
!
rejectFunc
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
promiseObj
(
cx
PromiseObj
(
)
)
;
if
(
NS_WARN_IF
(
!
JS
:
:
AddPromiseReactions
(
cx
promiseObj
resolveFunc
rejectFunc
)
)
)
{
jsapi
.
ClearException
(
)
;
return
;
}
}
void
Promise
:
:
HandleException
(
JSContext
*
aCx
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
aCx
)
;
if
(
JS_GetPendingException
(
aCx
&
exn
)
)
{
JS_ClearPendingException
(
aCx
)
;
MaybeReject
(
aCx
exn
)
;
}
}
already_AddRefed
<
Promise
>
Promise
:
:
CreateFromExisting
(
nsIGlobalObject
*
aGlobal
JS
:
:
Handle
<
JSObject
*
>
aPromiseObj
)
{
MOZ_ASSERT
(
js
:
:
GetObjectCompartment
(
aGlobal
-
>
GetGlobalJSObject
(
)
)
=
=
js
:
:
GetObjectCompartment
(
aPromiseObj
)
)
;
RefPtr
<
Promise
>
p
=
new
Promise
(
aGlobal
)
;
p
-
>
mPromiseObj
=
aPromiseObj
;
return
p
.
forget
(
)
;
}
#
else
JSObject
*
Promise
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
PromiseBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Create
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
JS
:
:
Handle
<
JSObject
*
>
aDesiredProto
)
{
if
(
!
aGlobal
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
p
=
new
Promise
(
aGlobal
)
;
p
-
>
CreateWrapper
(
aDesiredProto
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
p
.
forget
(
)
;
}
void
Promise
:
:
CreateWrapper
(
JS
:
:
Handle
<
JSObject
*
>
aDesiredProto
ErrorResult
&
aRv
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mGlobal
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
wrapper
(
cx
)
;
if
(
!
GetOrCreateDOMReflector
(
cx
this
&
wrapper
aDesiredProto
)
)
{
JS_ClearPendingException
(
cx
)
;
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
dom
:
:
PreserveWrapper
(
this
)
;
if
(
!
CaptureStack
(
cx
mAllocationStack
)
)
{
JS_ClearPendingException
(
cx
)
;
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
JS
:
:
RootedObject
obj
(
cx
&
wrapper
.
toObject
(
)
)
;
JS
:
:
dbg
:
:
onNewPromise
(
cx
obj
)
;
}
void
Promise
:
:
MaybeResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeResolveInternal
(
aCx
aValue
)
;
}
void
Promise
:
:
MaybeReject
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeRejectInternal
(
aCx
aValue
)
;
}
#
endif
void
Promise
:
:
MaybeResolveWithUndefined
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeResolve
(
JS
:
:
UndefinedHandleValue
)
;
}
void
Promise
:
:
MaybeReject
(
const
RefPtr
<
MediaStreamError
>
&
aArg
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
void
Promise
:
:
MaybeRejectWithUndefined
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
MaybeSomething
(
JS
:
:
UndefinedHandleValue
&
Promise
:
:
MaybeReject
)
;
}
#
ifdef
SPIDERMONKEY_PROMISE
void
Promise
:
:
ReportRejectedPromise
(
JSContext
*
aCx
JS
:
:
HandleObject
aPromise
)
{
MOZ_ASSERT
(
!
js
:
:
IsWrapper
(
aPromise
)
)
;
MOZ_ASSERT
(
JS
:
:
GetPromiseState
(
aPromise
)
=
=
JS
:
:
PromiseState
:
:
Rejected
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
aCx
JS
:
:
GetPromiseResult
(
aPromise
)
)
;
js
:
:
ErrorReport
report
(
aCx
)
;
if
(
!
report
.
init
(
aCx
result
js
:
:
ErrorReport
:
:
NoSideEffects
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
;
}
RefPtr
<
xpc
:
:
ErrorReport
>
xpcReport
=
new
xpc
:
:
ErrorReport
(
)
;
bool
isMainThread
=
MOZ_LIKELY
(
NS_IsMainThread
(
)
)
;
bool
isChrome
=
isMainThread
?
nsContentUtils
:
:
IsSystemPrincipal
(
nsContentUtils
:
:
ObjectPrincipal
(
aPromise
)
)
:
GetCurrentThreadWorkerPrivate
(
)
-
>
IsChromeWorker
(
)
;
nsGlobalWindow
*
win
=
isMainThread
?
xpc
:
:
WindowGlobalOrNull
(
aPromise
)
:
nullptr
;
xpcReport
-
>
Init
(
report
.
report
(
)
report
.
toStringResult
(
)
.
c_str
(
)
isChrome
win
?
win
-
>
AsInner
(
)
-
>
WindowID
(
)
:
0
)
;
NS_DispatchToMainThread
(
new
AsyncErrorReporter
(
xpcReport
)
)
;
}
#
endif
bool
Promise
:
:
PerformMicroTaskCheckpoint
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
CycleCollectedJSContext
*
context
=
CycleCollectedJSContext
:
:
Get
(
)
;
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
&
microtaskQueue
=
context
-
>
GetPromiseMicroTaskQueue
(
)
;
if
(
microtaskQueue
.
empty
(
)
)
{
return
false
;
}
AutoSlowOperation
aso
;
do
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
microtaskQueue
.
front
(
)
.
forget
(
)
;
MOZ_ASSERT
(
runnable
)
;
microtaskQueue
.
pop
(
)
;
nsresult
rv
=
runnable
-
>
Run
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
aso
.
CheckForInterrupt
(
)
;
context
-
>
AfterProcessMicrotask
(
)
;
}
while
(
!
microtaskQueue
.
empty
(
)
)
;
return
true
;
}
void
Promise
:
:
PerformWorkerMicroTaskCheckpoint
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
CycleCollectedJSContext
*
context
=
CycleCollectedJSContext
:
:
Get
(
)
;
for
(
;
;
)
{
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
*
microtaskQueue
=
&
context
-
>
GetDebuggerPromiseMicroTaskQueue
(
)
;
if
(
microtaskQueue
-
>
empty
(
)
)
{
microtaskQueue
=
&
context
-
>
GetPromiseMicroTaskQueue
(
)
;
if
(
microtaskQueue
-
>
empty
(
)
)
{
break
;
}
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
microtaskQueue
-
>
front
(
)
.
forget
(
)
;
MOZ_ASSERT
(
runnable
)
;
microtaskQueue
-
>
pop
(
)
;
nsresult
rv
=
runnable
-
>
Run
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
context
-
>
AfterProcessMicrotask
(
)
;
}
}
void
Promise
:
:
PerformWorkerDebuggerMicroTaskCheckpoint
(
)
{
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
"
Wrong
thread
!
"
)
;
CycleCollectedJSContext
*
context
=
CycleCollectedJSContext
:
:
Get
(
)
;
for
(
;
;
)
{
std
:
:
queue
<
nsCOMPtr
<
nsIRunnable
>
>
*
microtaskQueue
=
&
context
-
>
GetDebuggerPromiseMicroTaskQueue
(
)
;
if
(
microtaskQueue
-
>
empty
(
)
)
{
break
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
microtaskQueue
-
>
front
(
)
.
forget
(
)
;
MOZ_ASSERT
(
runnable
)
;
microtaskQueue
-
>
pop
(
)
;
nsresult
rv
=
runnable
-
>
Run
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
context
-
>
AfterProcessMicrotask
(
)
;
}
}
#
ifndef
SPIDERMONKEY_PROMISE
bool
Promise
:
:
JSCallback
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aCx
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
SLOT_PROMISE
)
)
;
MOZ_ASSERT
(
v
.
isObject
(
)
)
;
Promise
*
promise
;
if
(
NS_FAILED
(
UNWRAP_OBJECT
(
Promise
&
v
.
toObject
(
)
promise
)
)
)
{
return
Throw
(
aCx
NS_ERROR_UNEXPECTED
)
;
}
v
=
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
SLOT_DATA
)
;
PromiseCallback
:
:
Task
task
=
static_cast
<
PromiseCallback
:
:
Task
>
(
v
.
toInt32
(
)
)
;
if
(
task
=
=
PromiseCallback
:
:
Resolve
)
{
if
(
!
promise
-
>
CaptureStack
(
aCx
promise
-
>
mFullfillmentStack
)
)
{
return
false
;
}
promise
-
>
MaybeResolveInternal
(
aCx
args
.
get
(
0
)
)
;
}
else
{
promise
-
>
MaybeRejectInternal
(
aCx
args
.
get
(
0
)
)
;
if
(
!
promise
-
>
CaptureStack
(
aCx
promise
-
>
mRejectionStack
)
)
{
return
false
;
}
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
Promise
:
:
ThenableResolverCommon
(
JSContext
*
aCx
uint32_t
aTask
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
Rooted
<
JSObject
*
>
thisFunc
(
aCx
&
args
.
callee
(
)
)
;
if
(
!
MarkAsCalledIfNotCalledBefore
(
aCx
thisFunc
)
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
Promise
*
promise
=
GetPromise
(
aCx
thisFunc
)
;
MOZ_ASSERT
(
promise
)
;
if
(
aTask
=
=
PromiseCallback
:
:
Resolve
)
{
promise
-
>
ResolveInternal
(
aCx
args
.
get
(
0
)
)
;
}
else
{
promise
-
>
RejectInternal
(
aCx
args
.
get
(
0
)
)
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
bool
Promise
:
:
JSCallbackThenableResolver
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
return
ThenableResolverCommon
(
aCx
PromiseCallback
:
:
Resolve
aArgc
aVp
)
;
}
bool
Promise
:
:
JSCallbackThenableRejecter
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
return
ThenableResolverCommon
(
aCx
PromiseCallback
:
:
Reject
aArgc
aVp
)
;
}
JSObject
*
Promise
:
:
CreateFunction
(
JSContext
*
aCx
Promise
*
aPromise
int32_t
aTask
)
{
JSFunction
*
func
=
js
:
:
NewFunctionWithReserved
(
aCx
JSCallback
1
0
nullptr
)
;
if
(
!
func
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
JS_GetFunctionObject
(
func
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
promiseObj
(
aCx
)
;
if
(
!
dom
:
:
GetOrCreateDOMReflector
(
aCx
aPromise
&
promiseObj
)
)
{
return
nullptr
;
}
JS
:
:
ExposeValueToActiveJS
(
promiseObj
)
;
js
:
:
SetFunctionNativeReserved
(
obj
SLOT_PROMISE
promiseObj
)
;
js
:
:
SetFunctionNativeReserved
(
obj
SLOT_DATA
JS
:
:
Int32Value
(
aTask
)
)
;
return
obj
;
}
JSObject
*
Promise
:
:
CreateThenableFunction
(
JSContext
*
aCx
Promise
*
aPromise
uint32_t
aTask
)
{
JSNative
whichFunc
=
aTask
=
=
PromiseCallback
:
:
Resolve
?
JSCallbackThenableResolver
:
JSCallbackThenableRejecter
;
JSFunction
*
func
=
js
:
:
NewFunctionWithReserved
(
aCx
whichFunc
1
0
nullptr
)
;
if
(
!
func
)
{
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
JS_GetFunctionObject
(
func
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
promiseObj
(
aCx
)
;
if
(
!
dom
:
:
GetOrCreateDOMReflector
(
aCx
aPromise
&
promiseObj
)
)
{
return
nullptr
;
}
JS
:
:
ExposeValueToActiveJS
(
promiseObj
)
;
js
:
:
SetFunctionNativeReserved
(
obj
SLOT_PROMISE
promiseObj
)
;
return
obj
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Constructor
(
const
GlobalObject
&
aGlobal
PromiseInit
&
aInit
ErrorResult
&
aRv
JS
:
:
Handle
<
JSObject
*
>
aDesiredProto
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
;
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Create
(
global
aRv
aDesiredProto
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
CallInitFunction
(
aGlobal
aInit
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
return
promise
.
forget
(
)
;
}
void
Promise
:
:
CallInitFunction
(
const
GlobalObject
&
aGlobal
PromiseInit
&
aInit
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
resolveFunc
(
cx
CreateFunction
(
cx
this
PromiseCallback
:
:
Resolve
)
)
;
if
(
!
resolveFunc
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
rejectFunc
(
cx
CreateFunction
(
cx
this
PromiseCallback
:
:
Reject
)
)
;
if
(
!
rejectFunc
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
aInit
.
Call
(
resolveFunc
rejectFunc
aRv
"
promise
initializer
"
CallbackObject
:
:
eRethrowExceptions
Compartment
(
)
)
;
aRv
.
WouldReportJSException
(
)
;
if
(
aRv
.
Failed
(
)
)
{
if
(
aRv
.
IsUncatchableException
(
)
)
{
return
;
}
MaybeReject
(
aRv
)
;
}
}
#
define
GET_CAPABILITIES_EXECUTOR_RESOLVE_SLOT
0
#
define
GET_CAPABILITIES_EXECUTOR_REJECT_SLOT
1
namespace
{
bool
GetCapabilitiesExecutor
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
if
(
!
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
GET_CAPABILITIES_EXECUTOR_RESOLVE_SLOT
)
.
isUndefined
(
)
|
|
!
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
GET_CAPABILITIES_EXECUTOR_REJECT_SLOT
)
.
isUndefined
(
)
)
{
ErrorResult
rv
;
rv
.
ThrowTypeError
<
MSG_PROMISE_CAPABILITY_HAS_SOMETHING_ALREADY
>
(
)
;
return
!
rv
.
MaybeSetPendingException
(
aCx
)
;
}
js
:
:
SetFunctionNativeReserved
(
&
args
.
callee
(
)
GET_CAPABILITIES_EXECUTOR_RESOLVE_SLOT
args
.
get
(
0
)
)
;
js
:
:
SetFunctionNativeReserved
(
&
args
.
callee
(
)
GET_CAPABILITIES_EXECUTOR_REJECT_SLOT
args
.
get
(
1
)
)
;
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
}
void
Promise
:
:
NewPromiseCapability
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
JS
:
:
Handle
<
JS
:
:
Value
>
aConstructor
bool
aForceCallbackCreation
PromiseCapability
&
aCapability
ErrorResult
&
aRv
)
{
if
(
!
aConstructor
.
isObject
(
)
|
|
!
JS
:
:
IsConstructor
(
&
aConstructor
.
toObject
(
)
)
)
{
aRv
.
ThrowTypeError
<
MSG_ILLEGAL_PROMISE_CONSTRUCTOR
>
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
aGlobal
-
>
GetGlobalJSObject
(
)
)
;
{
JS
:
:
Rooted
<
JSObject
*
>
callerGlobal
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
JSAutoCompartment
ac
(
aCx
global
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
constructorValue
(
aCx
aConstructor
)
;
if
(
!
MaybeWrapObjectValue
(
aCx
&
constructorValue
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
JSObject
*
defaultCtor
=
PromiseBinding
:
:
GetConstructorObject
(
aCx
)
;
if
(
!
defaultCtor
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
if
(
defaultCtor
=
=
&
constructorValue
.
toObject
(
)
)
{
aCapability
.
mNativePromise
=
Promise
:
:
Create
(
aGlobal
aRv
)
;
if
(
aForceCallbackCreation
)
{
MOZ_ASSERT
(
xpc
:
:
WrapperFactory
:
:
IsXrayWrapper
(
&
aConstructor
.
toObject
(
)
)
|
|
callerGlobal
=
=
global
)
;
JSAutoCompartment
ac2
(
aCx
callerGlobal
)
;
JSObject
*
resolveFuncObj
=
CreateFunction
(
aCx
aCapability
.
mNativePromise
PromiseCallback
:
:
Resolve
)
;
if
(
!
resolveFuncObj
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
aCapability
.
mResolve
.
setObject
(
*
resolveFuncObj
)
;
JSObject
*
rejectFuncObj
=
CreateFunction
(
aCx
aCapability
.
mNativePromise
PromiseCallback
:
:
Reject
)
;
if
(
!
rejectFuncObj
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
aCapability
.
mReject
.
setObject
(
*
rejectFuncObj
)
;
}
return
;
}
}
JSFunction
*
getCapabilitiesFunc
=
js
:
:
NewFunctionWithReserved
(
aCx
GetCapabilitiesExecutor
2
0
nullptr
)
;
if
(
!
getCapabilitiesFunc
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
getCapabilitiesObj
(
aCx
)
;
getCapabilitiesObj
=
JS_GetFunctionObject
(
getCapabilitiesFunc
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
getCapabilities
(
aCx
JS
:
:
ObjectValue
(
*
getCapabilitiesObj
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
promiseObj
(
aCx
)
;
if
(
!
JS
:
:
Construct
(
aCx
aConstructor
JS
:
:
HandleValueArray
(
getCapabilities
)
&
promiseObj
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aCx
)
;
v
=
js
:
:
GetFunctionNativeReserved
(
getCapabilitiesObj
GET_CAPABILITIES_EXECUTOR_RESOLVE_SLOT
)
;
if
(
!
v
.
isObject
(
)
|
|
!
JS
:
:
IsCallable
(
&
v
.
toObject
(
)
)
)
{
aRv
.
ThrowTypeError
<
MSG_PROMISE_RESOLVE_FUNCTION_NOT_CALLABLE
>
(
)
;
return
;
}
aCapability
.
mResolve
=
v
;
v
=
js
:
:
GetFunctionNativeReserved
(
getCapabilitiesObj
GET_CAPABILITIES_EXECUTOR_REJECT_SLOT
)
;
if
(
!
v
.
isObject
(
)
|
|
!
JS
:
:
IsCallable
(
&
v
.
toObject
(
)
)
)
{
aRv
.
ThrowTypeError
<
MSG_PROMISE_REJECT_FUNCTION_NOT_CALLABLE
>
(
)
;
return
;
}
aCapability
.
mReject
=
v
;
aCapability
.
mPromise
=
promiseObj
;
}
void
Promise
:
:
Resolve
(
const
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JS
:
:
Value
>
aThisv
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
!
aThisv
.
isObject
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_ILLEGAL_PROMISE_CONSTRUCTOR
>
(
)
;
return
;
}
if
(
aValue
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
valueObj
(
cx
&
aValue
.
toObject
(
)
)
;
Promise
*
nextPromise
;
nsresult
rv
=
UNWRAP_OBJECT
(
Promise
valueObj
nextPromise
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
constructor
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
valueObj
"
constructor
"
&
constructor
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
if
(
aThisv
=
=
constructor
)
{
aRetval
.
setObject
(
*
valueObj
)
;
return
;
}
}
}
PromiseCapability
capability
(
cx
)
;
NewPromiseCapability
(
cx
global
aThisv
false
capability
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
Promise
*
p
=
capability
.
mNativePromise
;
if
(
p
)
{
p
-
>
MaybeResolveInternal
(
cx
aValue
)
;
p
-
>
mFullfillmentStack
=
p
-
>
mAllocationStack
;
}
else
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
aValue
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
ignored
(
cx
)
;
if
(
!
JS
:
:
Call
(
cx
JS
:
:
UndefinedHandleValue
capability
.
mResolve
JS
:
:
HandleValueArray
(
value
)
&
ignored
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
}
aRetval
.
set
(
capability
.
PromiseValue
(
)
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Resolve
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
Create
(
aGlobal
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
MaybeResolveInternal
(
aCx
aValue
)
;
return
promise
.
forget
(
)
;
}
void
Promise
:
:
Reject
(
const
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JS
:
:
Value
>
aThisv
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
!
aThisv
.
isObject
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_ILLEGAL_PROMISE_CONSTRUCTOR
>
(
)
;
return
;
}
PromiseCapability
capability
(
cx
)
;
NewPromiseCapability
(
cx
global
aThisv
false
capability
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
Promise
*
p
=
capability
.
mNativePromise
;
if
(
p
)
{
p
-
>
MaybeRejectInternal
(
cx
aValue
)
;
p
-
>
mRejectionStack
=
p
-
>
mAllocationStack
;
}
else
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
aValue
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
ignored
(
cx
)
;
if
(
!
JS
:
:
Call
(
cx
JS
:
:
UndefinedHandleValue
capability
.
mReject
JS
:
:
HandleValueArray
(
value
)
&
ignored
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
}
aRetval
.
set
(
capability
.
PromiseValue
(
)
)
;
}
already_AddRefed
<
Promise
>
Promise
:
:
Reject
(
nsIGlobalObject
*
aGlobal
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
promise
=
Create
(
aGlobal
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
promise
-
>
MaybeRejectInternal
(
aCx
aValue
)
;
return
promise
.
forget
(
)
;
}
namespace
{
void
SpeciesConstructor
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
promise
JS
:
:
Handle
<
JS
:
:
Value
>
defaultCtor
JS
:
:
MutableHandle
<
JS
:
:
Value
>
ctor
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
promise
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
constructorVal
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
promise
"
constructor
"
&
constructorVal
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
if
(
constructorVal
.
isUndefined
(
)
)
{
ctor
.
set
(
defaultCtor
)
;
return
;
}
if
(
!
constructorVal
.
isObject
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_ILLEGAL_PROMISE_CONSTRUCTOR
>
(
)
;
return
;
}
JS
:
:
Rooted
<
jsid
>
species
(
aCx
SYMBOL_TO_JSID
(
JS
:
:
GetWellKnownSymbol
(
aCx
JS
:
:
SymbolCode
:
:
species
)
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
speciesVal
(
aCx
)
;
JS
:
:
Rooted
<
JSObject
*
>
constructorObj
(
aCx
&
constructorVal
.
toObject
(
)
)
;
if
(
!
JS_GetPropertyById
(
aCx
constructorObj
species
&
speciesVal
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
if
(
speciesVal
.
isNullOrUndefined
(
)
)
{
ctor
.
set
(
defaultCtor
)
;
return
;
}
if
(
speciesVal
.
isObject
(
)
&
&
JS
:
:
IsConstructor
(
&
speciesVal
.
toObject
(
)
)
)
{
ctor
.
set
(
speciesVal
)
;
return
;
}
aRv
.
ThrowTypeError
<
MSG_ILLEGAL_PROMISE_CONSTRUCTOR
>
(
)
;
}
}
void
Promise
:
:
Then
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCalleeGlobal
AnyCallback
*
aResolveCallback
AnyCallback
*
aRejectCallback
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
promiseVal
(
aCx
JS
:
:
ObjectValue
(
*
GetWrapper
(
)
)
)
;
if
(
!
MaybeWrapObjectValue
(
aCx
&
promiseVal
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
promiseObj
(
aCx
&
promiseVal
.
toObject
(
)
)
;
MOZ_ASSERT
(
promiseObj
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
defaultCtorVal
(
aCx
)
;
{
JSAutoCompartment
ac
(
aCx
aCalleeGlobal
)
;
JSObject
*
defaultCtor
=
PromiseBinding
:
:
GetConstructorObject
(
aCx
)
;
if
(
!
defaultCtor
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
defaultCtorVal
.
setObject
(
*
defaultCtor
)
;
}
if
(
!
MaybeWrapObjectValue
(
aCx
&
defaultCtorVal
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
constructor
(
aCx
)
;
SpeciesConstructor
(
aCx
promiseObj
defaultCtorVal
&
constructor
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
GlobalObject
globalObj
(
aCx
GetWrapper
(
)
)
;
if
(
globalObj
.
Failed
(
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
nsCOMPtr
<
nsIGlobalObject
>
globalObject
=
do_QueryInterface
(
globalObj
.
GetAsSupports
(
)
)
;
if
(
!
globalObject
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
PromiseCapability
capability
(
aCx
)
;
NewPromiseCapability
(
aCx
globalObject
constructor
false
capability
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
if
(
capability
.
mNativePromise
)
{
Promise
*
promise
=
capability
.
mNativePromise
;
RefPtr
<
PromiseCallback
>
resolveCb
=
PromiseCallback
:
:
Factory
(
promise
global
aResolveCallback
PromiseCallback
:
:
Resolve
)
;
RefPtr
<
PromiseCallback
>
rejectCb
=
PromiseCallback
:
:
Factory
(
promise
global
aRejectCallback
PromiseCallback
:
:
Reject
)
;
AppendCallbacks
(
resolveCb
rejectCb
)
;
}
else
{
JS
:
:
Rooted
<
JSObject
*
>
resolveObj
(
aCx
&
capability
.
mResolve
.
toObject
(
)
)
;
RefPtr
<
AnyCallback
>
resolveFunc
=
new
AnyCallback
(
aCx
resolveObj
GetIncumbentGlobal
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
rejectObj
(
aCx
&
capability
.
mReject
.
toObject
(
)
)
;
RefPtr
<
AnyCallback
>
rejectFunc
=
new
AnyCallback
(
aCx
rejectObj
GetIncumbentGlobal
(
)
)
;
if
(
!
capability
.
mPromise
)
{
aRv
.
ThrowTypeError
<
MSG_ILLEGAL_PROMISE_CONSTRUCTOR
>
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
newPromiseObj
(
aCx
capability
.
mPromise
)
;
newPromiseObj
=
js
:
:
CheckedUnwrap
(
newPromiseObj
)
;
if
(
!
newPromiseObj
)
{
aRv
.
ThrowTypeError
<
MSG_ILLEGAL_PROMISE_CONSTRUCTOR
>
(
)
;
return
;
}
RefPtr
<
PromiseCallback
>
resolveCb
;
if
(
aResolveCallback
)
{
resolveCb
=
new
WrapperPromiseCallback
(
global
aResolveCallback
newPromiseObj
resolveFunc
rejectFunc
)
;
}
else
{
resolveCb
=
new
InvokePromiseFuncCallback
(
global
newPromiseObj
resolveFunc
)
;
}
RefPtr
<
PromiseCallback
>
rejectCb
;
if
(
aRejectCallback
)
{
rejectCb
=
new
WrapperPromiseCallback
(
global
aRejectCallback
newPromiseObj
resolveFunc
rejectFunc
)
;
}
else
{
rejectCb
=
new
InvokePromiseFuncCallback
(
global
newPromiseObj
rejectFunc
)
;
}
AppendCallbacks
(
resolveCb
rejectCb
)
;
}
aRetval
.
set
(
capability
.
PromiseValue
(
)
)
;
}
void
Promise
:
:
Catch
(
JSContext
*
aCx
AnyCallback
*
aRejectCallback
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
promiseVal
(
aCx
JS
:
:
ObjectValue
(
*
GetWrapper
(
)
)
)
;
if
(
!
MaybeWrapObjectValue
(
aCx
&
promiseVal
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
promiseObj
(
aCx
&
promiseVal
.
toObject
(
)
)
;
MOZ_ASSERT
(
promiseObj
)
;
JS
:
:
AutoValueArray
<
2
>
callbacks
(
aCx
)
;
callbacks
[
0
]
.
setUndefined
(
)
;
if
(
aRejectCallback
)
{
callbacks
[
1
]
.
setObject
(
*
aRejectCallback
-
>
Callable
(
)
)
;
if
(
!
MaybeWrapObjectValue
(
aCx
callbacks
[
1
]
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
}
else
{
callbacks
[
1
]
.
setNull
(
)
;
}
if
(
!
JS_CallFunctionName
(
aCx
promiseObj
"
then
"
callbacks
aRetval
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
}
}
class
CountdownHolder
final
:
public
nsISupports
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
CountdownHolder
)
CountdownHolder
(
const
GlobalObject
&
aGlobal
Promise
*
aPromise
uint32_t
aCountdown
)
:
mPromise
(
aPromise
)
mCountdown
(
aCountdown
)
{
MOZ_ASSERT
(
aCountdown
!
=
0
)
;
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
JSAutoCompartment
ac
(
cx
aGlobal
.
Get
(
)
)
;
mValues
=
JS_NewArrayObject
(
cx
aCountdown
)
;
mozilla
:
:
HoldJSObjects
(
this
)
;
}
private
:
~
CountdownHolder
(
)
{
mozilla
:
:
DropJSObjects
(
this
)
;
}
public
:
void
SetValue
(
uint32_t
index
const
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
MOZ_ASSERT
(
mCountdown
>
0
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
mValues
)
)
{
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
aValue
)
;
JS
:
:
Rooted
<
JSObject
*
>
values
(
cx
mValues
)
;
if
(
!
JS_WrapValue
(
cx
&
value
)
|
|
!
JS_DefineElement
(
cx
values
index
value
JSPROP_ENUMERATE
)
)
{
MOZ_ASSERT
(
JS_IsExceptionPending
(
cx
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
cx
)
;
if
(
!
jsapi
.
StealException
(
&
exn
)
)
{
mPromise
-
>
MaybeReject
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
else
{
mPromise
-
>
MaybeReject
(
cx
exn
)
;
}
}
-
-
mCountdown
;
if
(
mCountdown
=
=
0
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
JS
:
:
ObjectValue
(
*
mValues
)
)
;
mPromise
-
>
MaybeResolve
(
cx
result
)
;
}
}
private
:
RefPtr
<
Promise
>
mPromise
;
uint32_t
mCountdown
;
JS
:
:
Heap
<
JSObject
*
>
mValues
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
CountdownHolder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
CountdownHolder
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
CountdownHolder
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CountdownHolder
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
CountdownHolder
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mValues
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
CountdownHolder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
CountdownHolder
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPromise
)
tmp
-
>
mValues
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
class
AllResolveElementFunction
final
:
public
PromiseNativeHandler
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
AllResolveElementFunction
)
AllResolveElementFunction
(
CountdownHolder
*
aHolder
uint32_t
aIndex
)
:
mCountdownHolder
(
aHolder
)
mIndex
(
aIndex
)
{
MOZ_ASSERT
(
aHolder
)
;
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
mCountdownHolder
-
>
SetValue
(
mIndex
aValue
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
MOZ_CRASH
(
"
AllResolveElementFunction
should
never
be
attached
to
a
Promise
'
s
reject
handler
!
"
)
;
}
private
:
~
AllResolveElementFunction
(
)
{
}
RefPtr
<
CountdownHolder
>
mCountdownHolder
;
uint32_t
mIndex
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
AllResolveElementFunction
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
AllResolveElementFunction
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
AllResolveElementFunction
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
AllResolveElementFunction
mCountdownHolder
)
static
const
JSClass
PromiseAllDataHolderClass
=
{
"
PromiseAllDataHolder
"
JSCLASS_HAS_RESERVED_SLOTS
(
3
)
}
;
#
define
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
0
#
define
DATA_HOLDER_VALUES_ARRAY_SLOT
1
#
define
DATA_HOLDER_RESOLVE_FUNCTION_SLOT
2
#
define
RESOLVE_ELEMENT_INDEX_SLOT
0
#
define
RESOLVE_ELEMENT_DATA_HOLDER_SLOT
1
static
bool
PromiseAllResolveElement
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
int32_t
index
=
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
RESOLVE_ELEMENT_INDEX_SLOT
)
.
toInt32
(
)
;
if
(
index
=
=
INT32_MIN
)
{
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
js
:
:
SetFunctionNativeReserved
(
&
args
.
callee
(
)
RESOLVE_ELEMENT_INDEX_SLOT
JS
:
:
Int32Value
(
INT32_MIN
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
dataHolder
(
aCx
&
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
RESOLVE_ELEMENT_DATA_HOLDER_SLOT
)
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
values
(
aCx
js
:
:
GetReservedSlot
(
dataHolder
DATA_HOLDER_VALUES_ARRAY_SLOT
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
resolveFunc
(
aCx
js
:
:
GetReservedSlot
(
dataHolder
DATA_HOLDER_RESOLVE_FUNCTION_SLOT
)
)
;
int32_t
remainingElements
=
js
:
:
GetReservedSlot
(
dataHolder
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
)
.
toInt32
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
valuesObj
(
aCx
&
values
.
toObject
(
)
)
;
if
(
!
JS_DefineElement
(
aCx
valuesObj
index
args
.
get
(
0
)
JSPROP_ENUMERATE
)
)
{
return
false
;
}
remainingElements
-
=
1
;
js
:
:
SetReservedSlot
(
dataHolder
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
JS
:
:
Int32Value
(
remainingElements
)
)
;
if
(
remainingElements
=
=
0
)
{
return
JS
:
:
Call
(
aCx
JS
:
:
UndefinedHandleValue
resolveFunc
JS
:
:
HandleValueArray
(
values
)
args
.
rval
(
)
)
;
}
args
.
rval
(
)
.
setUndefined
(
)
;
return
true
;
}
void
Promise
:
:
All
(
const
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JS
:
:
Value
>
aThisv
JS
:
:
Handle
<
JS
:
:
Value
>
aIterable
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
PromiseCapability
capability
(
cx
)
;
NewPromiseCapability
(
cx
global
aThisv
true
capability
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
aThisv
.
isObject
(
)
"
How
did
NewPromiseCapability
succeed
?
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
constructorObj
(
cx
&
aThisv
.
toObject
(
)
)
;
aRetval
.
set
(
capability
.
PromiseValue
(
)
)
;
if
(
!
MaybeWrapValue
(
cx
aRetval
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
JS
:
:
AutoValueArray
<
2
>
callbackFunctions
(
cx
)
;
callbackFunctions
[
1
]
.
set
(
capability
.
mReject
)
;
JS
:
:
ForOfIterator
iter
(
cx
)
;
if
(
!
iter
.
init
(
aIterable
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
if
(
!
iter
.
valueIsIterable
(
)
)
{
ThrowErrorMessage
(
cx
MSG_PROMISE_ARG_NOT_ITERABLE
"
Argument
of
Promise
.
all
"
)
;
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
dataHolder
(
cx
)
;
dataHolder
=
JS_NewObjectWithGivenProto
(
cx
&
PromiseAllDataHolderClass
nullptr
)
;
if
(
!
dataHolder
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
reflectorGlobal
(
cx
global
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
valuesArray
(
cx
)
;
{
JSAutoCompartment
ac
(
cx
reflectorGlobal
)
;
valuesArray
=
JS_NewArrayObject
(
cx
0
)
;
}
if
(
!
valuesArray
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
valuesArrayVal
(
cx
JS
:
:
ObjectValue
(
*
valuesArray
)
)
;
if
(
!
MaybeWrapObjectValue
(
cx
&
valuesArrayVal
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
js
:
:
SetReservedSlot
(
dataHolder
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
JS
:
:
Int32Value
(
1
)
)
;
js
:
:
SetReservedSlot
(
dataHolder
DATA_HOLDER_VALUES_ARRAY_SLOT
valuesArrayVal
)
;
js
:
:
SetReservedSlot
(
dataHolder
DATA_HOLDER_RESOLVE_FUNCTION_SLOT
capability
.
mResolve
)
;
CheckedInt32
index
=
0
;
JS
:
:
Rooted
<
JS
:
:
Value
>
nextValue
(
cx
)
;
while
(
true
)
{
bool
done
;
if
(
!
iter
.
next
(
&
nextValue
&
done
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
if
(
done
)
{
int32_t
remainingCount
=
js
:
:
GetReservedSlot
(
dataHolder
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
)
.
toInt32
(
)
;
remainingCount
-
=
1
;
if
(
remainingCount
=
=
0
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
ignored
(
cx
)
;
if
(
!
JS
:
:
Call
(
cx
JS
:
:
UndefinedHandleValue
capability
.
mResolve
JS
:
:
HandleValueArray
(
valuesArrayVal
)
&
ignored
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
}
return
;
}
js
:
:
SetReservedSlot
(
dataHolder
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
JS
:
:
Int32Value
(
remainingCount
)
)
;
return
;
}
{
JSAutoCompartment
ac
(
cx
valuesArray
)
;
if
(
!
JS_DefineElement
(
cx
valuesArray
index
.
value
(
)
JS
:
:
UndefinedHandleValue
JSPROP_ENUMERATE
)
)
{
JSAutoCompartment
ac2
(
cx
&
capability
.
mReject
.
toObject
(
)
)
;
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
}
JS
:
:
Rooted
<
JS
:
:
Value
>
nextPromise
(
cx
)
;
if
(
!
JS_CallFunctionName
(
cx
constructorObj
"
resolve
"
JS
:
:
HandleValueArray
(
nextValue
)
&
nextPromise
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
resolveElement
(
cx
)
;
JSFunction
*
resolveFunc
=
js
:
:
NewFunctionWithReserved
(
cx
PromiseAllResolveElement
1
0
nullptr
)
;
if
(
!
resolveFunc
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
resolveElement
=
JS_GetFunctionObject
(
resolveFunc
)
;
js
:
:
SetFunctionNativeReserved
(
resolveElement
RESOLVE_ELEMENT_INDEX_SLOT
JS
:
:
Int32Value
(
index
.
value
(
)
)
)
;
js
:
:
SetFunctionNativeReserved
(
resolveElement
RESOLVE_ELEMENT_DATA_HOLDER_SLOT
JS
:
:
ObjectValue
(
*
dataHolder
)
)
;
int32_t
remainingElements
=
js
:
:
GetReservedSlot
(
dataHolder
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
)
.
toInt32
(
)
;
js
:
:
SetReservedSlot
(
dataHolder
DATA_HOLDER_REMAINING_ELEMENTS_SLOT
JS
:
:
Int32Value
(
remainingElements
+
1
)
)
;
callbackFunctions
[
0
]
.
setObject
(
*
resolveElement
)
;
JS
:
:
Rooted
<
JSObject
*
>
nextPromiseObj
(
cx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
ignored
(
cx
)
;
if
(
!
JS_ValueToObject
(
cx
nextPromise
&
nextPromiseObj
)
|
|
!
JS_CallFunctionName
(
cx
nextPromiseObj
"
then
"
callbackFunctions
&
ignored
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
}
index
+
=
1
;
if
(
!
index
.
isValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
capability
.
RejectWithException
(
cx
aRv
)
;
}
}
}
already_AddRefed
<
Promise
>
Promise
:
:
All
(
const
GlobalObject
&
aGlobal
const
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromiseList
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
if
(
aPromiseList
.
IsEmpty
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
empty
(
cx
JS_NewArrayObject
(
cx
0
)
)
;
if
(
!
empty
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
JS
:
:
ObjectValue
(
*
empty
)
)
;
return
Promise
:
:
Resolve
(
global
cx
value
aRv
)
;
}
RefPtr
<
Promise
>
promise
=
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
CountdownHolder
>
holder
=
new
CountdownHolder
(
aGlobal
promise
aPromiseList
.
Length
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
if
(
!
obj
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
RefPtr
<
PromiseCallback
>
rejectCb
=
new
RejectPromiseCallback
(
promise
obj
)
;
for
(
uint32_t
i
=
0
;
i
<
aPromiseList
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
PromiseNativeHandler
>
resolveHandler
=
new
AllResolveElementFunction
(
holder
i
)
;
RefPtr
<
PromiseCallback
>
resolveCb
=
new
NativePromiseCallback
(
resolveHandler
Resolved
)
;
aPromiseList
[
i
]
-
>
AppendCallbacks
(
resolveCb
rejectCb
)
;
}
return
promise
.
forget
(
)
;
}
void
Promise
:
:
Race
(
const
GlobalObject
&
aGlobal
JS
:
:
Handle
<
JS
:
:
Value
>
aThisv
JS
:
:
Handle
<
JS
:
:
Value
>
aIterable
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsIGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
JSContext
*
cx
=
aGlobal
.
Context
(
)
;
PromiseCapability
capability
(
cx
)
;
NewPromiseCapability
(
cx
global
aThisv
true
capability
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
aThisv
.
isObject
(
)
"
How
did
NewPromiseCapability
succeed
?
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
constructorObj
(
cx
&
aThisv
.
toObject
(
)
)
;
aRetval
.
set
(
capability
.
PromiseValue
(
)
)
;
if
(
!
MaybeWrapValue
(
cx
aRetval
)
)
{
aRv
.
NoteJSContextException
(
cx
)
;
return
;
}
JS
:
:
AutoValueArray
<
2
>
callbackFunctions
(
cx
)
;
callbackFunctions
[
0
]
.
set
(
capability
.
mResolve
)
;
callbackFunctions
[
1
]
.
set
(
capability
.
mReject
)
;
JS
:
:
ForOfIterator
iter
(
cx
)
;
if
(
!
iter
.
init
(
aIterable
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
if
(
!
iter
.
valueIsIterable
(
)
)
{
ThrowErrorMessage
(
cx
MSG_PROMISE_ARG_NOT_ITERABLE
"
Argument
of
Promise
.
race
"
)
;
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
nextValue
(
cx
)
;
while
(
true
)
{
bool
done
;
if
(
!
iter
.
next
(
&
nextValue
&
done
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
if
(
done
)
{
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
nextPromise
(
cx
)
;
if
(
!
JS_CallFunctionName
(
cx
constructorObj
"
resolve
"
JS
:
:
HandleValueArray
(
nextValue
)
&
nextPromise
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
nextPromiseObj
(
cx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
ignored
(
cx
)
;
if
(
!
JS_ValueToObject
(
cx
nextPromise
&
nextPromiseObj
)
|
|
!
JS_CallFunctionName
(
cx
nextPromiseObj
"
then
"
callbackFunctions
&
ignored
)
)
{
capability
.
RejectWithException
(
cx
aRv
)
;
}
}
}
bool
Promise
:
:
PromiseSpecies
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
args
.
rval
(
)
.
set
(
args
.
thisv
(
)
)
;
return
true
;
}
void
Promise
:
:
AppendNativeHandler
(
PromiseNativeHandler
*
aRunnable
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
RefPtr
<
PromiseCallback
>
resolveCb
=
new
NativePromiseCallback
(
aRunnable
Resolved
)
;
RefPtr
<
PromiseCallback
>
rejectCb
=
new
NativePromiseCallback
(
aRunnable
Rejected
)
;
AppendCallbacks
(
resolveCb
rejectCb
)
;
}
#
endif
JSObject
*
Promise
:
:
GlobalJSObject
(
)
const
{
return
mGlobal
-
>
GetGlobalJSObject
(
)
;
}
JSCompartment
*
Promise
:
:
Compartment
(
)
const
{
return
js
:
:
GetObjectCompartment
(
GlobalJSObject
(
)
)
;
}
#
ifndef
SPIDERMONKEY_PROMISE
void
Promise
:
:
AppendCallbacks
(
PromiseCallback
*
aResolveCallback
PromiseCallback
*
aRejectCallback
)
{
if
(
!
mGlobal
|
|
mGlobal
-
>
IsDying
(
)
)
{
return
;
}
MOZ_ASSERT
(
aResolveCallback
)
;
MOZ_ASSERT
(
aRejectCallback
)
;
if
(
mIsLastInChain
&
&
mState
=
=
PromiseState
:
:
Rejected
)
{
PromiseDebugging
:
:
AddConsumedRejection
(
*
this
)
;
}
mIsLastInChain
=
false
;
#
if
defined
(
DOM_PROMISE_DEPRECATED_REPORTING
)
mHadRejectCallback
=
true
;
RemoveWorkerHolder
(
)
;
#
endif
mResolveCallbacks
.
AppendElement
(
aResolveCallback
)
;
mRejectCallbacks
.
AppendElement
(
aRejectCallback
)
;
if
(
mState
!
=
Pending
)
{
TriggerPromiseReactions
(
)
;
}
}
#
endif
#
ifndef
SPIDERMONKEY_PROMISE
#
if
defined
(
DOM_PROMISE_DEPRECATED_REPORTING
)
void
Promise
:
:
MaybeReportRejected
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
if
(
mState
!
=
Rejected
|
|
mHadRejectCallback
|
|
mResult
.
isUndefined
(
)
)
{
return
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
GetWrapper
(
)
)
;
MOZ_ASSERT
(
obj
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
mResult
)
;
JSAutoCompartment
ac
(
cx
obj
)
;
if
(
!
JS_WrapValue
(
cx
&
val
)
)
{
JS_ClearPendingException
(
cx
)
;
return
;
}
js
:
:
ErrorReport
report
(
cx
)
;
RefPtr
<
Exception
>
exp
;
bool
isObject
=
val
.
isObject
(
)
;
if
(
!
isObject
|
|
NS_FAILED
(
UNWRAP_OBJECT
(
Exception
&
val
.
toObject
(
)
exp
)
)
)
{
if
(
!
isObject
|
|
NS_FAILED
(
UNWRAP_OBJECT
(
DOMException
&
val
.
toObject
(
)
exp
)
)
)
{
if
(
!
report
.
init
(
cx
val
js
:
:
ErrorReport
:
:
NoSideEffects
)
)
{
NS_WARNING
(
"
Couldn
'
t
convert
the
unhandled
rejected
value
to
an
exception
.
"
)
;
JS_ClearPendingException
(
cx
)
;
return
;
}
}
}
RefPtr
<
xpc
:
:
ErrorReport
>
xpcReport
=
new
xpc
:
:
ErrorReport
(
)
;
bool
isMainThread
=
MOZ_LIKELY
(
NS_IsMainThread
(
)
)
;
bool
isChrome
=
isMainThread
?
nsContentUtils
:
:
IsSystemPrincipal
(
nsContentUtils
:
:
ObjectPrincipal
(
obj
)
)
:
GetCurrentThreadWorkerPrivate
(
)
-
>
IsChromeWorker
(
)
;
nsGlobalWindow
*
win
=
isMainThread
?
xpc
:
:
WindowGlobalOrNull
(
obj
)
:
nullptr
;
uint64_t
windowID
=
win
?
win
-
>
AsInner
(
)
-
>
WindowID
(
)
:
0
;
if
(
exp
)
{
xpcReport
-
>
Init
(
cx
exp
isChrome
windowID
)
;
}
else
{
xpcReport
-
>
Init
(
report
.
report
(
)
report
.
toStringResult
(
)
isChrome
windowID
)
;
}
nsCOMPtr
<
nsIThread
>
mainThread
=
do_GetMainThread
(
)
;
if
(
NS_WARN_IF
(
!
mainThread
)
)
{
NS_WARNING
(
"
!
!
!
Trying
to
report
rejected
Promise
after
MainThread
shutdown
"
)
;
}
if
(
mainThread
)
{
RefPtr
<
AsyncErrorReporter
>
r
=
new
AsyncErrorReporter
(
xpcReport
)
;
mainThread
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
}
}
#
endif
void
Promise
:
:
MaybeResolveInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
if
(
mResolvePending
)
{
return
;
}
ResolveInternal
(
aCx
aValue
)
;
}
void
Promise
:
:
MaybeRejectInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
if
(
mResolvePending
)
{
return
;
}
RejectInternal
(
aCx
aValue
)
;
}
void
Promise
:
:
HandleException
(
JSContext
*
aCx
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
exn
(
aCx
)
;
if
(
JS_GetPendingException
(
aCx
&
exn
)
)
{
JS_ClearPendingException
(
aCx
)
;
RejectInternal
(
aCx
exn
)
;
}
}
void
Promise
:
:
ResolveInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
CycleCollectedJSContext
*
context
=
CycleCollectedJSContext
:
:
Get
(
)
;
mResolvePending
=
true
;
if
(
aValue
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
valueObj
(
aCx
&
aValue
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
then
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
valueObj
"
then
"
&
then
)
)
{
HandleException
(
aCx
)
;
return
;
}
if
(
then
.
isObject
(
)
&
&
JS
:
:
IsCallable
(
&
then
.
toObject
(
)
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
thenObj
(
aCx
&
then
.
toObject
(
)
)
;
RefPtr
<
PromiseInit
>
thenCallback
=
new
PromiseInit
(
nullptr
thenObj
mozilla
:
:
dom
:
:
GetIncumbentGlobal
(
)
)
;
RefPtr
<
PromiseResolveThenableJob
>
task
=
new
PromiseResolveThenableJob
(
this
valueObj
thenCallback
)
;
context
-
>
DispatchToMicroTask
(
task
.
forget
(
)
)
;
return
;
}
}
MaybeSettle
(
aValue
Resolved
)
;
}
void
Promise
:
:
RejectInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
mResolvePending
=
true
;
MaybeSettle
(
aValue
Rejected
)
;
}
void
Promise
:
:
Settle
(
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
PromiseState
aState
)
{
MOZ_ASSERT
(
mGlobal
"
We
really
should
have
a
global
here
.
Except
we
sometimes
don
'
t
"
"
in
the
wild
for
some
odd
reason
"
)
;
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
if
(
!
mGlobal
|
|
mGlobal
-
>
IsDying
(
)
)
{
return
;
}
mSettlementTimestamp
=
TimeStamp
:
:
Now
(
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
RootedObject
wrapper
(
cx
GetWrapper
(
)
)
;
MOZ_ASSERT
(
wrapper
)
;
JSAutoCompartment
ac
(
cx
wrapper
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
cx
aValue
)
;
if
(
!
JS_WrapValue
(
cx
&
value
)
)
{
JS_ClearPendingException
(
cx
)
;
value
=
JS
:
:
UndefinedValue
(
)
;
}
SetResult
(
value
)
;
SetState
(
aState
)
;
JS
:
:
dbg
:
:
onPromiseSettled
(
cx
wrapper
)
;
if
(
aState
=
=
PromiseState
:
:
Rejected
&
&
mIsLastInChain
)
{
PromiseDebugging
:
:
AddUncaughtRejection
(
*
this
)
;
}
#
if
defined
(
DOM_PROMISE_DEPRECATED_REPORTING
)
if
(
aState
=
=
PromiseState
:
:
Rejected
&
&
!
mHadRejectCallback
&
&
!
NS_IsMainThread
(
)
)
{
WorkerPrivate
*
worker
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
worker
)
;
worker
-
>
AssertIsOnWorkerThread
(
)
;
mWorkerHolder
=
new
PromiseReportRejectWorkerHolder
(
this
)
;
if
(
NS_WARN_IF
(
!
mWorkerHolder
-
>
HoldWorker
(
worker
Closing
)
)
)
{
mWorkerHolder
=
nullptr
;
MaybeReportRejectedOnce
(
)
;
}
}
#
endif
TriggerPromiseReactions
(
)
;
}
void
Promise
:
:
MaybeSettle
(
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
PromiseState
aState
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
if
(
mState
!
=
Pending
)
{
return
;
}
Settle
(
aValue
aState
)
;
}
void
Promise
:
:
TriggerPromiseReactions
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
CycleCollectedJSContext
*
runtime
=
CycleCollectedJSContext
:
:
Get
(
)
;
nsTArray
<
RefPtr
<
PromiseCallback
>
>
callbacks
;
callbacks
.
SwapElements
(
mState
=
=
Resolved
?
mResolveCallbacks
:
mRejectCallbacks
)
;
mResolveCallbacks
.
Clear
(
)
;
mRejectCallbacks
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
callbacks
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
PromiseReactionJob
>
task
=
new
PromiseReactionJob
(
this
callbacks
[
i
]
mResult
)
;
runtime
-
>
DispatchToMicroTask
(
task
.
forget
(
)
)
;
}
}
#
if
defined
(
DOM_PROMISE_DEPRECATED_REPORTING
)
void
Promise
:
:
RemoveWorkerHolder
(
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
mWorkerHolder
=
nullptr
;
}
bool
PromiseReportRejectWorkerHolder
:
:
Notify
(
Status
aStatus
)
{
MOZ_ASSERT
(
aStatus
>
Running
)
;
mPromise
-
>
MaybeReportRejectedOnce
(
)
;
return
true
;
}
#
endif
bool
Promise
:
:
CaptureStack
(
JSContext
*
aCx
JS
:
:
Heap
<
JSObject
*
>
&
aTarget
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
JS
:
:
Rooted
<
JSObject
*
>
stack
(
aCx
)
;
if
(
!
JS
:
:
CaptureCurrentStack
(
aCx
&
stack
)
)
{
return
false
;
}
aTarget
=
stack
;
return
true
;
}
void
Promise
:
:
GetDependentPromises
(
nsTArray
<
RefPtr
<
Promise
>
>
&
aPromises
)
{
NS_ASSERT_OWNINGTHREAD
(
Promise
)
;
for
(
size_t
i
=
0
;
i
<
mRejectCallbacks
.
Length
(
)
;
+
+
i
)
{
Promise
*
p
=
mRejectCallbacks
[
i
]
-
>
GetDependentPromise
(
)
;
if
(
p
)
{
aPromises
.
AppendElement
(
p
)
;
}
}
}
#
endif
class
PromiseWorkerProxyRunnable
:
public
WorkerRunnable
{
public
:
PromiseWorkerProxyRunnable
(
PromiseWorkerProxy
*
aPromiseWorkerProxy
PromiseWorkerProxy
:
:
RunCallbackFunc
aFunc
)
:
WorkerRunnable
(
aPromiseWorkerProxy
-
>
GetWorkerPrivate
(
)
WorkerThreadUnchangedBusyCount
)
mPromiseWorkerProxy
(
aPromiseWorkerProxy
)
mFunc
(
aFunc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPromiseWorkerProxy
)
;
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPrivate
=
=
mWorkerPrivate
)
;
MOZ_ASSERT
(
mPromiseWorkerProxy
)
;
RefPtr
<
Promise
>
workerPromise
=
mPromiseWorkerProxy
-
>
WorkerPromise
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
mPromiseWorkerProxy
-
>
Read
(
aCx
&
value
)
)
{
JS_ClearPendingException
(
aCx
)
;
return
false
;
}
(
workerPromise
-
>
*
mFunc
)
(
aCx
value
)
;
mPromiseWorkerProxy
-
>
CleanUp
(
)
;
return
true
;
}
protected
:
~
PromiseWorkerProxyRunnable
(
)
{
}
private
:
RefPtr
<
PromiseWorkerProxy
>
mPromiseWorkerProxy
;
PromiseWorkerProxy
:
:
RunCallbackFunc
mFunc
;
}
;
class
PromiseWorkerHolder
final
:
public
WorkerHolder
{
PromiseWorkerProxy
*
mProxy
;
public
:
explicit
PromiseWorkerHolder
(
PromiseWorkerProxy
*
aProxy
)
:
mProxy
(
aProxy
)
{
MOZ_ASSERT
(
aProxy
)
;
}
bool
Notify
(
Status
aStatus
)
override
{
if
(
aStatus
>
=
Canceling
)
{
mProxy
-
>
CleanUp
(
)
;
}
return
true
;
}
}
;
already_AddRefed
<
PromiseWorkerProxy
>
PromiseWorkerProxy
:
:
Create
(
WorkerPrivate
*
aWorkerPrivate
Promise
*
aWorkerPromise
const
PromiseWorkerProxyStructuredCloneCallbacks
*
aCb
)
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
aWorkerPromise
)
;
MOZ_ASSERT_IF
(
aCb
!
!
aCb
-
>
Write
&
&
!
!
aCb
-
>
Read
)
;
RefPtr
<
PromiseWorkerProxy
>
proxy
=
new
PromiseWorkerProxy
(
aWorkerPrivate
aWorkerPromise
aCb
)
;
if
(
!
proxy
-
>
AddRefObject
(
)
)
{
proxy
-
>
CleanProperties
(
)
;
return
nullptr
;
}
return
proxy
.
forget
(
)
;
}
NS_IMPL_ISUPPORTS0
(
PromiseWorkerProxy
)
PromiseWorkerProxy
:
:
PromiseWorkerProxy
(
WorkerPrivate
*
aWorkerPrivate
Promise
*
aWorkerPromise
const
PromiseWorkerProxyStructuredCloneCallbacks
*
aCallbacks
)
:
mWorkerPrivate
(
aWorkerPrivate
)
mWorkerPromise
(
aWorkerPromise
)
mCleanedUp
(
false
)
mCallbacks
(
aCallbacks
)
mCleanUpLock
(
"
cleanUpLock
"
)
{
}
PromiseWorkerProxy
:
:
~
PromiseWorkerProxy
(
)
{
MOZ_ASSERT
(
mCleanedUp
)
;
MOZ_ASSERT
(
!
mWorkerHolder
)
;
MOZ_ASSERT
(
!
mWorkerPromise
)
;
MOZ_ASSERT
(
!
mWorkerPrivate
)
;
}
void
PromiseWorkerProxy
:
:
CleanProperties
(
)
{
#
ifdef
DEBUG
WorkerPrivate
*
worker
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
worker
)
;
worker
-
>
AssertIsOnWorkerThread
(
)
;
#
endif
mCleanedUp
=
true
;
mWorkerPromise
=
nullptr
;
mWorkerPrivate
=
nullptr
;
Clear
(
)
;
}
bool
PromiseWorkerProxy
:
:
AddRefObject
(
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
!
mWorkerHolder
)
;
mWorkerHolder
.
reset
(
new
PromiseWorkerHolder
(
this
)
)
;
if
(
NS_WARN_IF
(
!
mWorkerHolder
-
>
HoldWorker
(
mWorkerPrivate
Canceling
)
)
)
{
mWorkerHolder
=
nullptr
;
return
false
;
}
AddRef
(
)
;
return
true
;
}
WorkerPrivate
*
PromiseWorkerProxy
:
:
GetWorkerPrivate
(
)
const
{
#
ifdef
DEBUG
if
(
NS_IsMainThread
(
)
)
{
mCleanUpLock
.
AssertCurrentThreadOwns
(
)
;
}
#
endif
MOZ_ASSERT
(
!
mCleanedUp
)
;
MOZ_ASSERT
(
mWorkerHolder
)
;
return
mWorkerPrivate
;
}
Promise
*
PromiseWorkerProxy
:
:
WorkerPromise
(
)
const
{
#
ifdef
DEBUG
WorkerPrivate
*
worker
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
worker
)
;
worker
-
>
AssertIsOnWorkerThread
(
)
;
#
endif
MOZ_ASSERT
(
mWorkerPromise
)
;
return
mWorkerPromise
;
}
void
PromiseWorkerProxy
:
:
StoreISupports
(
nsISupports
*
aSupports
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsMainThreadPtrHandle
<
nsISupports
>
supports
(
new
nsMainThreadPtrHolder
<
nsISupports
>
(
aSupports
)
)
;
mSupportsArray
.
AppendElement
(
supports
)
;
}
void
PromiseWorkerProxy
:
:
RunCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
RunCallbackFunc
aFunc
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
Lock
(
)
)
;
if
(
CleanedUp
(
)
)
{
return
;
}
if
(
!
Write
(
aCx
aValue
)
)
{
JS_ClearPendingException
(
aCx
)
;
MOZ_ASSERT
(
false
"
cannot
serialize
the
value
with
the
StructuredCloneAlgorithm
!
"
)
;
}
RefPtr
<
PromiseWorkerProxyRunnable
>
runnable
=
new
PromiseWorkerProxyRunnable
(
this
aFunc
)
;
runnable
-
>
Dispatch
(
)
;
}
void
PromiseWorkerProxy
:
:
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
RunCallback
(
aCx
aValue
&
Promise
:
:
MaybeResolve
)
;
}
void
PromiseWorkerProxy
:
:
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
{
RunCallback
(
aCx
aValue
&
Promise
:
:
MaybeReject
)
;
}
void
PromiseWorkerProxy
:
:
CleanUp
(
)
{
{
MutexAutoLock
lock
(
Lock
(
)
)
;
if
(
CleanedUp
(
)
)
{
return
;
}
MOZ_ASSERT
(
mWorkerPrivate
)
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
MOZ_ASSERT
(
mWorkerHolder
)
;
mWorkerHolder
=
nullptr
;
CleanProperties
(
)
;
}
Release
(
)
;
}
JSObject
*
PromiseWorkerProxy
:
:
CustomReadHandler
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
uint32_t
aTag
uint32_t
aIndex
)
{
if
(
NS_WARN_IF
(
!
mCallbacks
)
)
{
return
nullptr
;
}
return
mCallbacks
-
>
Read
(
aCx
aReader
this
aTag
aIndex
)
;
}
bool
PromiseWorkerProxy
:
:
CustomWriteHandler
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
JS
:
:
Handle
<
JSObject
*
>
aObj
)
{
if
(
NS_WARN_IF
(
!
mCallbacks
)
)
{
return
false
;
}
return
mCallbacks
-
>
Write
(
aCx
aWriter
this
aObj
)
;
}
template
<
>
void
Promise
:
:
MaybeRejectBrokenly
(
const
RefPtr
<
DOMError
>
&
aArg
)
{
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
template
<
>
void
Promise
:
:
MaybeRejectBrokenly
(
const
nsAString
&
aArg
)
{
MaybeSomething
(
aArg
&
Promise
:
:
MaybeReject
)
;
}
#
ifndef
SPIDERMONKEY_PROMISE
uint64_t
Promise
:
:
GetID
(
)
{
if
(
mID
!
=
0
)
{
return
mID
;
}
return
mID
=
+
+
gIDGenerator
;
}
#
endif
#
ifndef
SPIDERMONKEY_PROMISE
Promise
:
:
PromiseState
Promise
:
:
State
(
)
const
{
return
mState
;
}
#
else
Promise
:
:
PromiseState
Promise
:
:
State
(
)
const
{
JS
:
:
Rooted
<
JSObject
*
>
p
(
RootingCx
(
)
PromiseObj
(
)
)
;
const
JS
:
:
PromiseState
state
=
JS
:
:
GetPromiseState
(
p
)
;
if
(
state
=
=
JS
:
:
PromiseState
:
:
Fulfilled
)
{
return
PromiseState
:
:
Resolved
;
}
if
(
state
=
=
JS
:
:
PromiseState
:
:
Rejected
)
{
return
PromiseState
:
:
Rejected
;
}
return
PromiseState
:
:
Pending
;
}
#
endif
}
}
