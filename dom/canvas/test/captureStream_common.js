"
use
strict
"
;
function
CaptureStreamTestHelper
(
width
height
)
{
this
.
cout
=
document
.
createElement
(
'
canvas
'
)
;
if
(
width
)
{
this
.
elemWidth
=
width
;
}
if
(
height
)
{
this
.
elemHeight
=
height
;
}
this
.
cout
.
width
=
this
.
elemWidth
;
this
.
cout
.
height
=
this
.
elemHeight
;
document
.
body
.
appendChild
(
this
.
cout
)
;
}
CaptureStreamTestHelper
.
prototype
=
{
black
:
{
data
:
[
0
0
0
255
]
name
:
"
black
"
}
blackTransparent
:
{
data
:
[
0
0
0
0
]
name
:
"
blackTransparent
"
}
green
:
{
data
:
[
0
255
0
255
]
name
:
"
green
"
}
red
:
{
data
:
[
255
0
0
255
]
name
:
"
red
"
}
grey
:
{
data
:
[
128
128
128
255
]
name
:
"
grey
"
}
elemWidth
:
100
elemHeight
:
100
startDrawing
:
function
(
f
)
{
var
stop
=
false
;
var
draw
=
(
)
=
>
{
f
(
)
;
if
(
!
stop
)
{
window
.
requestAnimationFrame
(
draw
)
;
}
}
;
draw
(
)
;
return
{
stop
:
(
)
=
>
stop
=
true
}
;
}
requestFrame
:
function
(
video
)
{
info
(
"
Requesting
frame
from
"
+
video
.
id
)
;
video
.
srcObject
.
requestFrame
(
)
;
}
getPixel
:
function
(
video
offsetX
offsetY
)
{
offsetX
=
offsetX
|
|
0
;
offsetY
=
offsetY
|
|
0
;
var
ctxout
=
this
.
cout
.
getContext
(
'
2d
'
)
;
ctxout
.
drawImage
(
video
0
0
)
;
return
ctxout
.
getImageData
(
offsetX
offsetY
1
1
)
.
data
;
}
isPixel
:
function
(
px
refColor
threshold
)
{
threshold
=
threshold
|
|
0
;
return
px
.
every
(
(
ch
i
)
=
>
Math
.
abs
(
ch
-
refColor
.
data
[
i
]
)
<
=
threshold
)
;
}
isPixelNot
:
function
(
px
refColor
threshold
)
{
if
(
threshold
=
=
=
undefined
)
{
threshold
=
127
;
}
return
px
.
some
(
(
ch
i
)
=
>
Math
.
abs
(
ch
-
refColor
.
data
[
i
]
)
>
threshold
)
;
}
waitForPixel
:
function
(
video
offsetX
offsetY
test
timeout
)
{
return
new
Promise
(
resolve
=
>
{
const
startTime
=
video
.
currentTime
;
CaptureStreamTestHelper2D
.
prototype
.
clear
.
call
(
this
this
.
cout
)
;
var
ontimeupdate
=
(
)
=
>
{
var
pixelMatch
=
false
;
try
{
pixelMatch
=
test
(
this
.
getPixel
(
video
offsetX
offsetY
)
)
;
}
catch
(
NS_ERROR_NOT_AVAILABLE
)
{
info
(
"
Waiting
for
pixel
but
no
video
available
"
)
;
}
if
(
!
pixelMatch
&
&
(
!
timeout
|
|
video
.
currentTime
<
startTime
+
(
timeout
/
1000
.
0
)
)
)
{
return
;
}
video
.
removeEventListener
(
"
timeupdate
"
ontimeupdate
)
;
resolve
(
pixelMatch
)
;
}
;
video
.
addEventListener
(
"
timeupdate
"
ontimeupdate
)
;
}
)
;
}
waitForPixelColor
:
function
(
video
refColor
threshold
infoString
)
{
info
(
"
Waiting
for
video
"
+
video
.
id
+
"
to
match
[
"
+
refColor
.
data
.
join
(
'
'
)
+
"
]
-
"
+
refColor
.
name
+
"
(
"
+
infoString
+
"
)
"
)
;
return
this
.
waitForPixel
(
video
0
0
px
=
>
this
.
isPixel
(
px
refColor
threshold
)
)
.
then
(
(
)
=
>
ok
(
true
video
.
id
+
"
"
+
infoString
)
)
;
}
waitForPixelColorTimeout
:
function
(
video
refColor
threshold
timeout
infoString
)
{
info
(
"
Waiting
for
"
+
video
.
id
+
"
to
time
out
after
"
+
timeout
+
"
ms
against
[
"
+
refColor
.
data
.
join
(
'
'
)
+
"
]
-
"
+
refColor
.
name
)
;
return
this
.
waitForPixel
(
video
0
0
px
=
>
this
.
isPixel
(
px
refColor
threshold
)
timeout
)
.
then
(
result
=
>
ok
(
!
result
video
.
id
+
"
"
+
infoString
)
)
;
}
createAndAppendElement
:
function
(
type
id
)
{
var
e
=
document
.
createElement
(
type
)
;
e
.
id
=
id
;
e
.
width
=
this
.
elemWidth
;
e
.
height
=
this
.
elemHeight
;
if
(
type
=
=
=
'
video
'
)
{
e
.
autoplay
=
true
;
}
document
.
body
.
appendChild
(
e
)
;
return
e
;
}
}
function
CaptureStreamTestHelper2D
(
width
height
)
{
CaptureStreamTestHelper
.
call
(
this
width
height
)
;
}
CaptureStreamTestHelper2D
.
prototype
=
Object
.
create
(
CaptureStreamTestHelper
.
prototype
)
;
CaptureStreamTestHelper2D
.
prototype
.
constructor
=
CaptureStreamTestHelper2D
;
CaptureStreamTestHelper2D
.
prototype
.
clear
=
function
(
canvas
)
{
var
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
ctx
.
clearRect
(
0
0
canvas
.
width
canvas
.
height
)
;
}
;
CaptureStreamTestHelper2D
.
prototype
.
drawColor
=
function
(
canvas
color
)
{
var
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
var
rgba
=
color
.
data
.
slice
(
)
;
rgba
[
3
]
=
rgba
[
3
]
/
255
.
0
;
info
(
"
Drawing
color
"
+
rgba
.
join
(
'
'
)
)
;
ctx
.
fillStyle
=
"
rgba
(
"
+
rgba
.
join
(
'
'
)
+
"
)
"
;
ctx
.
fillRect
(
0
0
canvas
.
width
/
2
canvas
.
height
/
2
)
;
}
;
CaptureStreamTestHelper2D
.
prototype
.
testNotClean
=
function
(
canvas
)
{
var
ctx
=
canvas
.
getContext
(
'
2d
'
)
;
var
error
=
"
OK
"
;
try
{
var
data
=
ctx
.
getImageData
(
0
0
1
1
)
;
}
catch
(
e
)
{
error
=
e
.
name
;
}
is
(
error
"
SecurityError
"
"
Canvas
'
"
+
canvas
.
id
+
"
'
should
not
be
origin
-
clean
"
)
;
}
;
function
CaptureStreamTestHelperWebGL
(
width
height
)
{
CaptureStreamTestHelper
.
call
(
this
width
height
)
;
}
CaptureStreamTestHelperWebGL
.
prototype
=
Object
.
create
(
CaptureStreamTestHelper
.
prototype
)
;
CaptureStreamTestHelperWebGL
.
prototype
.
constructor
=
CaptureStreamTestHelperWebGL
;
CaptureStreamTestHelperWebGL
.
prototype
.
setFragmentColorLocation
=
function
(
colorLocation
)
{
this
.
colorLocation
=
colorLocation
;
}
;
CaptureStreamTestHelperWebGL
.
prototype
.
clearColor
=
function
(
canvas
color
)
{
info
(
"
WebGL
:
clearColor
(
"
+
color
.
name
+
"
)
"
)
;
var
gl
=
canvas
.
getContext
(
'
webgl
'
)
;
var
conv
=
color
.
data
.
map
(
i
=
>
i
/
255
.
0
)
;
gl
.
clearColor
(
conv
[
0
]
conv
[
1
]
conv
[
2
]
conv
[
3
]
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
}
;
CaptureStreamTestHelperWebGL
.
prototype
.
drawColor
=
function
(
canvas
color
)
{
info
(
"
WebGL
:
drawArrays
(
"
+
color
.
name
+
"
)
"
)
;
var
gl
=
canvas
.
getContext
(
'
webgl
'
)
;
var
conv
=
color
.
data
.
map
(
i
=
>
i
/
255
.
0
)
;
gl
.
uniform4f
(
this
.
colorLocation
conv
[
0
]
conv
[
1
]
conv
[
2
]
conv
[
3
]
)
;
gl
.
drawArrays
(
gl
.
TRIANGLE_STRIP
0
4
)
;
}
;
