"
use
strict
"
;
function
CaptureStreamTestHelper
(
width
height
)
{
if
(
width
)
{
this
.
elemWidth
=
width
;
}
if
(
height
)
{
this
.
elemHeight
=
height
;
}
this
.
cout
=
document
.
createElement
(
"
canvas
"
)
;
this
.
cout
.
width
=
1
;
this
.
cout
.
height
=
1
;
}
CaptureStreamTestHelper
.
prototype
=
{
black
:
{
data
:
[
0
0
0
255
]
name
:
"
black
"
}
blackTransparent
:
{
data
:
[
0
0
0
0
]
name
:
"
blackTransparent
"
}
white
:
{
data
:
[
255
255
255
255
]
name
:
"
white
"
}
green
:
{
data
:
[
0
255
0
255
]
name
:
"
green
"
}
red
:
{
data
:
[
255
0
0
255
]
name
:
"
red
"
}
blue
:
{
data
:
[
0
0
255
255
]
name
:
"
blue
"
}
grey
:
{
data
:
[
128
128
128
255
]
name
:
"
grey
"
}
elemWidth
:
100
elemHeight
:
100
startDrawing
(
f
)
{
var
stop
=
false
;
var
draw
=
(
)
=
>
{
if
(
stop
)
{
return
;
}
f
(
)
;
window
.
requestAnimationFrame
(
draw
)
;
}
;
draw
(
)
;
return
{
stop
:
(
)
=
>
(
stop
=
true
)
}
;
}
requestFrame
(
video
)
{
info
(
"
Requesting
frame
from
"
+
video
.
id
)
;
video
.
srcObject
.
requestFrame
(
)
;
}
getPixel
(
video
offsetX
=
0
offsetY
=
0
)
{
CaptureStreamTestHelper2D
.
prototype
.
clear
.
call
(
this
this
.
cout
)
;
var
ctxout
=
this
.
cout
.
getContext
(
"
2d
"
)
;
ctxout
.
drawImage
(
video
offsetX
offsetY
1
1
0
0
1
1
)
;
return
ctxout
.
getImageData
(
0
0
1
1
)
.
data
;
}
isPixel
(
px
refColor
threshold
=
0
)
{
return
px
.
every
(
(
ch
i
)
=
>
Math
.
abs
(
ch
-
refColor
.
data
[
i
]
)
<
=
threshold
)
;
}
isPixelNot
(
px
refColor
threshold
=
127
)
{
return
px
.
some
(
(
ch
i
)
=
>
Math
.
abs
(
ch
-
refColor
.
data
[
i
]
)
>
threshold
)
;
}
isOpaquePixelNot
(
px
refColor
threshold
)
{
px
[
3
]
=
refColor
.
data
[
3
]
;
return
this
.
isPixelNot
(
px
refColor
threshold
)
;
}
async
waitForPixel
(
video
test
{
offsetX
=
0
offsetY
=
0
width
=
0
height
=
0
cancel
=
new
Promise
(
(
)
=
>
{
}
)
}
=
{
}
)
{
let
aborted
=
false
;
cancel
.
then
(
e
=
>
(
aborted
=
true
)
)
;
while
(
true
)
{
await
Promise
.
race
(
[
new
Promise
(
resolve
=
>
video
.
addEventListener
(
"
timeupdate
"
resolve
{
once
:
true
}
)
)
cancel
]
)
;
if
(
aborted
)
{
throw
await
cancel
;
}
if
(
test
(
this
.
getPixel
(
video
offsetX
offsetY
width
height
)
)
)
{
return
;
}
}
}
async
pixelMustBecome
(
video
refColor
{
threshold
=
0
infoString
=
"
n
/
a
"
cancel
=
new
Promise
(
(
)
=
>
{
}
)
}
=
{
}
)
{
info
(
"
Waiting
for
video
"
+
video
.
id
+
"
to
match
[
"
+
refColor
.
data
.
join
(
"
"
)
+
"
]
-
"
+
refColor
.
name
+
"
(
"
+
infoString
+
"
)
"
)
;
var
paintedFrames
=
video
.
mozPaintedFrames
-
1
;
await
this
.
waitForPixel
(
video
px
=
>
{
if
(
paintedFrames
!
=
video
.
mozPaintedFrames
)
{
info
(
"
Frame
:
"
+
video
.
mozPaintedFrames
+
"
IsPixel
ref
=
"
+
refColor
.
data
+
"
threshold
=
"
+
threshold
+
"
value
=
"
+
px
)
;
paintedFrames
=
video
.
mozPaintedFrames
;
}
return
this
.
isPixel
(
px
refColor
threshold
)
;
}
{
offsetX
:
0
offsetY
:
0
width
:
0
height
:
0
cancel
}
)
;
ok
(
true
video
.
id
+
"
"
+
infoString
)
;
}
async
pixelMustNotBecome
(
video
refColor
{
threshold
=
0
time
=
5000
infoString
=
"
n
/
a
"
}
=
{
}
)
{
info
(
"
Waiting
for
"
+
video
.
id
+
"
to
time
out
after
"
+
time
+
"
ms
against
[
"
+
refColor
.
data
.
join
(
"
"
)
+
"
]
-
"
+
refColor
.
name
)
;
let
timeout
=
new
Promise
(
resolve
=
>
setTimeout
(
resolve
time
)
)
;
let
analysis
=
async
(
)
=
>
{
await
this
.
waitForPixel
(
video
px
=
>
this
.
isPixel
(
px
refColor
threshold
)
{
offsetX
:
0
offsetY
:
0
width
:
0
height
:
0
}
)
;
throw
new
Error
(
"
Got
color
"
+
refColor
.
name
+
"
.
"
+
infoString
)
;
}
;
await
Promise
.
race
(
[
timeout
analysis
(
)
]
)
;
ok
(
true
video
.
id
+
"
"
+
infoString
)
;
}
createAndAppendElement
(
type
id
)
{
var
e
=
document
.
createElement
(
type
)
;
e
.
id
=
id
;
e
.
width
=
this
.
elemWidth
;
e
.
height
=
this
.
elemHeight
;
if
(
type
=
=
=
"
video
"
)
{
e
.
autoplay
=
true
;
}
document
.
body
.
appendChild
(
e
)
;
return
e
;
}
}
;
function
CaptureStreamTestHelper2D
(
width
height
)
{
CaptureStreamTestHelper
.
call
(
this
width
height
)
;
}
CaptureStreamTestHelper2D
.
prototype
=
Object
.
create
(
CaptureStreamTestHelper
.
prototype
)
;
CaptureStreamTestHelper2D
.
prototype
.
constructor
=
CaptureStreamTestHelper2D
;
CaptureStreamTestHelper2D
.
prototype
.
clear
=
function
(
canvas
)
{
var
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
ctx
.
clearRect
(
0
0
canvas
.
width
canvas
.
height
)
;
}
;
CaptureStreamTestHelper2D
.
prototype
.
drawColor
=
function
(
canvas
color
{
offsetX
=
0
offsetY
=
0
width
=
canvas
.
width
/
2
height
=
canvas
.
height
/
2
}
=
{
}
)
{
var
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
var
rgba
=
color
.
data
.
slice
(
)
;
rgba
[
3
]
=
rgba
[
3
]
/
255
.
0
;
info
(
"
Drawing
color
"
+
rgba
.
join
(
"
"
)
)
;
ctx
.
fillStyle
=
"
rgba
(
"
+
rgba
.
join
(
"
"
)
+
"
)
"
;
ctx
.
fillRect
(
offsetX
offsetY
width
height
)
;
}
;
CaptureStreamTestHelper2D
.
prototype
.
testNotClean
=
function
(
canvas
)
{
var
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
var
error
=
"
OK
"
;
try
{
var
data
=
ctx
.
getImageData
(
0
0
1
1
)
;
}
catch
(
e
)
{
error
=
e
.
name
;
}
is
(
error
"
SecurityError
"
"
Canvas
'
"
+
canvas
.
id
+
"
'
should
not
be
origin
-
clean
"
)
;
}
;
function
CaptureStreamTestHelperWebGL
(
width
height
)
{
CaptureStreamTestHelper
.
call
(
this
width
height
)
;
}
CaptureStreamTestHelperWebGL
.
prototype
=
Object
.
create
(
CaptureStreamTestHelper
.
prototype
)
;
CaptureStreamTestHelperWebGL
.
prototype
.
constructor
=
CaptureStreamTestHelperWebGL
;
CaptureStreamTestHelperWebGL
.
prototype
.
setFragmentColorLocation
=
function
(
colorLocation
)
{
this
.
colorLocation
=
colorLocation
;
}
;
CaptureStreamTestHelperWebGL
.
prototype
.
clearColor
=
function
(
canvas
color
)
{
info
(
"
WebGL
:
clearColor
(
"
+
color
.
name
+
"
)
"
)
;
var
gl
=
canvas
.
getContext
(
"
webgl
"
)
;
var
conv
=
color
.
data
.
map
(
i
=
>
i
/
255
.
0
)
;
gl
.
clearColor
(
conv
[
0
]
conv
[
1
]
conv
[
2
]
conv
[
3
]
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
}
;
CaptureStreamTestHelperWebGL
.
prototype
.
drawColor
=
function
(
canvas
color
)
{
info
(
"
WebGL
:
drawArrays
(
"
+
color
.
name
+
"
)
"
)
;
var
gl
=
canvas
.
getContext
(
"
webgl
"
)
;
var
conv
=
color
.
data
.
map
(
i
=
>
i
/
255
.
0
)
;
gl
.
uniform4f
(
this
.
colorLocation
conv
[
0
]
conv
[
1
]
conv
[
2
]
conv
[
3
]
)
;
gl
.
drawArrays
(
gl
.
TRIANGLE_STRIP
0
4
)
;
}
;
