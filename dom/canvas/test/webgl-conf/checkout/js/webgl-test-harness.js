WebGLTestHarnessModule
=
function
(
)
{
var
log
=
function
(
msg
)
{
if
(
window
.
console
&
&
window
.
console
.
log
)
{
window
.
console
.
log
(
msg
)
;
}
}
;
var
loadTextFileAsynchronous
=
function
(
url
callback
)
{
log
(
"
loading
:
"
+
url
)
;
var
error
=
'
loadTextFileSynchronous
failed
to
load
url
"
'
+
url
+
'
"
'
;
var
request
;
if
(
window
.
XMLHttpRequest
)
{
request
=
new
XMLHttpRequest
(
)
;
if
(
request
.
overrideMimeType
)
{
request
.
overrideMimeType
(
'
text
/
plain
'
)
;
}
}
else
{
throw
'
XMLHttpRequest
is
disabled
'
;
}
try
{
request
.
open
(
'
GET
'
url
true
)
;
request
.
onreadystatechange
=
function
(
)
{
if
(
request
.
readyState
=
=
4
)
{
var
text
=
'
'
;
var
success
=
request
.
status
=
=
200
|
|
request
.
status
=
=
0
;
if
(
success
)
{
text
=
request
.
responseText
;
}
log
(
"
loaded
:
"
+
url
)
;
callback
(
success
text
)
;
}
}
;
request
.
send
(
null
)
;
}
catch
(
e
)
{
log
(
"
failed
to
load
:
"
+
url
)
;
callback
(
false
'
'
)
;
}
}
;
var
getMajorVersion
=
function
(
versionString
)
{
if
(
!
versionString
)
{
return
1
;
}
return
parseInt
(
versionString
.
split
(
"
"
)
[
0
]
.
split
(
"
.
"
)
[
0
]
10
)
;
}
;
var
getURLWithOptions
=
function
(
url
options
)
{
var
queryArgs
=
0
;
for
(
i
in
options
)
{
url
+
=
queryArgs
?
"
&
"
:
"
?
"
;
url
+
=
i
+
"
=
"
+
options
[
i
]
;
queryArgs
+
+
;
}
return
url
;
}
;
var
greaterThanOrEqualToVersion
=
function
(
have
want
)
{
have
=
have
.
split
(
"
"
)
[
0
]
.
split
(
"
.
"
)
;
want
=
want
.
split
(
"
"
)
[
0
]
.
split
(
"
.
"
)
;
for
(
var
ii
=
0
;
ii
<
want
.
length
;
+
+
ii
)
{
var
wantNum
=
parseInt
(
want
[
ii
]
)
;
var
haveNum
=
have
[
ii
]
?
parseInt
(
have
[
ii
]
)
:
0
if
(
haveNum
>
wantNum
)
{
return
true
;
}
if
(
haveNum
<
wantNum
)
{
return
false
;
}
}
return
true
;
}
;
var
getFileList
=
function
(
url
callback
options
)
{
var
files
=
[
]
;
var
copyObject
=
function
(
obj
)
{
return
JSON
.
parse
(
JSON
.
stringify
(
obj
)
)
;
}
;
var
toCamelCase
=
function
(
str
)
{
return
str
.
replace
(
/
-
(
[
a
-
z
]
)
/
g
function
(
g
)
{
return
g
[
1
]
.
toUpperCase
(
)
}
)
;
}
;
var
globalOptions
=
copyObject
(
options
)
;
globalOptions
.
defaultVersion
=
"
1
.
0
"
;
globalOptions
.
defaultMaxVersion
=
null
;
var
getFileListImpl
=
function
(
prefix
line
lineNum
hierarchicalOptions
callback
)
{
var
files
=
[
]
;
var
args
=
line
.
split
(
/
\
s
+
/
)
;
var
nonOptions
=
[
]
;
var
useTest
=
true
;
var
testOptions
=
{
}
;
for
(
var
jj
=
0
;
jj
<
args
.
length
;
+
+
jj
)
{
var
arg
=
args
[
jj
]
;
if
(
arg
[
0
]
=
=
'
-
'
)
{
if
(
arg
[
1
]
!
=
'
-
'
)
{
throw
(
"
bad
option
at
in
"
+
url
+
"
:
"
+
lineNum
+
"
:
"
+
arg
)
;
}
var
option
=
arg
.
substring
(
2
)
;
switch
(
option
)
{
case
'
slow
'
:
testOptions
[
toCamelCase
(
option
)
]
=
true
;
break
;
case
'
min
-
version
'
:
case
'
max
-
version
'
:
+
+
jj
;
testOptions
[
toCamelCase
(
option
)
]
=
args
[
jj
]
;
break
;
default
:
throw
(
"
bad
unknown
option
'
"
+
option
+
"
'
at
in
"
+
url
+
"
:
"
+
lineNum
+
"
:
"
+
arg
)
;
}
}
else
{
nonOptions
.
push
(
arg
)
;
}
}
var
url
=
prefix
+
nonOptions
.
join
(
"
"
)
;
if
(
url
.
substr
(
url
.
length
-
4
)
!
=
'
.
txt
'
)
{
var
minVersion
=
testOptions
.
minVersion
;
if
(
!
minVersion
)
{
minVersion
=
hierarchicalOptions
.
defaultVersion
;
}
var
maxVersion
=
testOptions
.
maxVersion
;
if
(
!
maxVersion
)
{
maxVersion
=
hierarchicalOptions
.
defaultMaxVersion
;
}
var
slow
=
testOptions
.
slow
;
if
(
!
slow
)
{
slow
=
hierarchicalOptions
.
defaultSlow
;
}
if
(
globalOptions
.
fast
&
&
slow
)
{
useTest
=
false
;
}
else
if
(
globalOptions
.
minVersion
)
{
useTest
=
greaterThanOrEqualToVersion
(
minVersion
globalOptions
.
minVersion
)
;
}
else
if
(
globalOptions
.
maxVersion
&
&
maxVersion
)
{
useTest
=
greaterThanOrEqualToVersion
(
globalOptions
.
maxVersion
maxVersion
)
;
}
else
{
useTest
=
greaterThanOrEqualToVersion
(
globalOptions
.
version
minVersion
)
;
if
(
maxVersion
)
{
useTest
=
useTest
&
&
greaterThanOrEqualToVersion
(
maxVersion
globalOptions
.
version
)
;
}
}
}
if
(
!
useTest
)
{
callback
(
true
[
]
)
;
return
;
}
if
(
url
.
substr
(
url
.
length
-
4
)
=
=
'
.
txt
'
)
{
if
(
testOptions
.
minVersion
)
{
hierarchicalOptions
.
defaultVersion
=
testOptions
.
minVersion
;
}
if
(
testOptions
.
maxVersion
)
{
hierarchicalOptions
.
defaultMaxVersion
=
testOptions
.
maxVersion
;
}
if
(
testOptions
.
slow
)
{
hierarchicalOptions
.
defaultSlow
=
testOptions
.
slow
;
}
loadTextFileAsynchronous
(
url
function
(
)
{
return
function
(
success
text
)
{
if
(
!
success
)
{
callback
(
false
'
'
)
;
return
;
}
var
lines
=
text
.
split
(
'
\
n
'
)
;
var
prefix
=
'
'
;
var
lastSlash
=
url
.
lastIndexOf
(
'
/
'
)
;
if
(
lastSlash
>
=
0
)
{
prefix
=
url
.
substr
(
0
lastSlash
+
1
)
;
}
var
fail
=
false
;
var
count
=
1
;
var
index
=
0
;
for
(
var
ii
=
0
;
ii
<
lines
.
length
;
+
+
ii
)
{
var
str
=
lines
[
ii
]
.
replace
(
/
^
\
s
\
s
*
/
'
'
)
.
replace
(
/
\
s
\
s
*
/
'
'
)
;
if
(
str
.
length
>
4
&
&
str
[
0
]
!
=
'
#
'
&
&
str
[
0
]
!
=
"
;
"
&
&
str
.
substr
(
0
2
)
!
=
"
/
/
"
)
{
+
+
count
;
getFileListImpl
(
prefix
str
ii
+
1
copyObject
(
hierarchicalOptions
)
function
(
index
)
{
return
function
(
success
new_files
)
{
if
(
success
)
{
files
[
index
]
=
new_files
;
}
finish
(
success
)
;
}
;
}
(
index
+
+
)
)
;
}
}
finish
(
true
)
;
function
finish
(
success
)
{
if
(
!
success
)
{
fail
=
true
;
}
-
-
count
;
if
(
!
count
)
{
callback
(
!
fail
files
)
;
}
}
}
}
(
)
)
;
}
else
{
files
.
push
(
url
)
;
callback
(
true
files
)
;
}
}
;
getFileListImpl
(
'
'
url
1
globalOptions
function
(
success
files
)
{
var
flat
=
[
]
;
flatten
(
files
)
;
function
flatten
(
files
)
{
for
(
var
ii
=
0
;
ii
<
files
.
length
;
+
+
ii
)
{
var
value
=
files
[
ii
]
;
if
(
typeof
(
value
)
=
=
"
string
"
)
{
flat
.
push
(
value
)
;
}
else
{
flatten
(
value
)
;
}
}
}
callback
(
success
flat
)
;
}
)
;
}
;
var
FilterURL
=
(
function
(
)
{
var
prefix
=
window
.
location
.
pathname
;
prefix
=
prefix
.
substring
(
0
prefix
.
lastIndexOf
(
"
/
"
)
+
1
)
;
return
function
(
url
)
{
if
(
url
.
substring
(
0
prefix
.
length
)
=
=
prefix
)
{
url
=
url
.
substring
(
prefix
.
length
)
;
}
return
url
;
}
;
}
(
)
)
;
var
TestFile
=
function
(
url
)
{
this
.
url
=
url
;
}
;
var
Test
=
function
(
file
)
{
this
.
file
=
file
;
}
;
var
TestHarness
=
function
(
iframe
filelistUrl
reportFunc
options
)
{
this
.
window
=
window
;
this
.
iframes
=
iframe
.
length
?
iframe
:
[
iframe
]
;
this
.
reportFunc
=
reportFunc
;
this
.
timeoutDelay
=
20000
;
this
.
files
=
[
]
;
this
.
allowSkip
=
options
.
allowSkip
;
this
.
webglVersion
=
getMajorVersion
(
options
.
version
)
;
this
.
dumpShaders
=
options
.
dumpShaders
;
this
.
quiet
=
options
.
quiet
;
var
that
=
this
;
getFileList
(
filelistUrl
function
(
)
{
return
function
(
success
files
)
{
that
.
addFiles_
(
success
files
)
;
}
;
}
(
)
options
)
;
}
;
TestHarness
.
reportType
=
{
ADD_PAGE
:
1
READY
:
2
START_PAGE
:
3
TEST_RESULT
:
4
FINISH_PAGE
:
5
FINISHED_ALL_TESTS
:
6
}
;
TestHarness
.
prototype
.
addFiles_
=
function
(
success
files
)
{
if
(
!
success
)
{
this
.
reportFunc
(
TestHarness
.
reportType
.
FINISHED_ALL_TESTS
'
'
'
Unable
to
load
tests
.
Are
you
running
locally
?
\
n
'
+
'
You
need
to
run
from
a
server
or
configure
your
\
n
'
+
'
browser
to
allow
access
to
local
files
(
not
recommended
)
.
\
n
\
n
'
+
'
Note
:
An
easy
way
to
run
from
a
server
:
\
n
\
n
'
+
'
\
tcd
path_to_tests
\
n
'
+
'
\
tpython
-
m
SimpleHTTPServer
\
n
\
n
'
+
'
then
point
your
browser
to
'
+
'
<
a
href
=
"
http
:
/
/
localhost
:
8000
/
webgl
-
conformance
-
tests
.
html
"
>
'
+
'
http
:
/
/
localhost
:
8000
/
webgl
-
conformance
-
tests
.
html
<
/
a
>
'
false
)
return
;
}
log
(
"
total
files
:
"
+
files
.
length
)
;
for
(
var
ii
=
0
;
ii
<
files
.
length
;
+
+
ii
)
{
log
(
"
"
+
ii
+
"
:
"
+
files
[
ii
]
)
;
this
.
files
.
push
(
new
TestFile
(
files
[
ii
]
)
)
;
this
.
reportFunc
(
TestHarness
.
reportType
.
ADD_PAGE
'
'
files
[
ii
]
undefined
)
;
}
this
.
reportFunc
(
TestHarness
.
reportType
.
READY
'
'
undefined
undefined
)
;
}
TestHarness
.
prototype
.
runTests
=
function
(
opt_options
)
{
var
options
=
opt_options
|
|
{
}
;
options
.
start
=
options
.
start
|
|
0
;
options
.
count
=
options
.
count
|
|
this
.
files
.
length
;
this
.
idleIFrames
=
this
.
iframes
.
slice
(
0
)
;
this
.
runningTests
=
{
}
;
var
testsToRun
=
[
]
;
for
(
var
ii
=
0
;
ii
<
options
.
count
;
+
+
ii
)
{
testsToRun
.
push
(
ii
+
options
.
start
)
;
}
this
.
numTestsRemaining
=
options
.
count
;
this
.
testsToRun
=
testsToRun
;
this
.
startNextTest
(
)
;
}
;
TestHarness
.
prototype
.
_bumpTimeout
=
function
(
test
)
{
const
newTimeoutAt
=
performance
.
now
(
)
+
this
.
timeoutDelay
;
if
(
test
.
timeoutAt
)
{
test
.
timeoutAt
=
newTimeoutAt
;
return
;
}
test
.
timeoutAt
=
newTimeoutAt
;
const
harness
=
this
;
function
enqueueWatchdog
(
)
{
const
remaining
=
test
.
timeoutAt
-
performance
.
now
(
)
;
this
.
window
.
setTimeout
(
(
)
=
>
{
if
(
!
test
.
timeoutAt
)
return
;
const
remainingAtCheckTime
=
test
.
timeoutAt
-
performance
.
now
(
)
;
if
(
performance
.
now
(
)
>
=
test
.
timeoutAt
)
{
harness
.
timeout
(
test
)
;
return
;
}
enqueueWatchdog
(
)
;
}
remaining
)
;
}
enqueueWatchdog
(
)
;
}
;
TestHarness
.
prototype
.
clearTimeout
=
function
(
test
)
{
test
.
timeoutAt
=
null
;
}
;
TestHarness
.
prototype
.
startNextTest
=
function
(
)
{
if
(
this
.
numTestsRemaining
=
=
0
)
{
log
(
"
done
"
)
;
this
.
reportFunc
(
TestHarness
.
reportType
.
FINISHED_ALL_TESTS
'
'
'
'
true
)
;
}
else
{
while
(
this
.
testsToRun
.
length
>
0
&
&
this
.
idleIFrames
.
length
>
0
)
{
var
testId
=
this
.
testsToRun
.
shift
(
)
;
var
iframe
=
this
.
idleIFrames
.
shift
(
)
;
this
.
startTest
(
iframe
this
.
files
[
testId
]
this
.
webglVersion
)
;
}
}
}
;
TestHarness
.
prototype
.
startTest
=
function
(
iframe
testFile
webglVersion
)
{
var
test
=
{
iframe
:
iframe
testFile
:
testFile
}
;
var
url
=
testFile
.
url
;
this
.
runningTests
[
url
]
=
test
;
log
(
"
loading
:
"
+
url
)
;
if
(
this
.
reportFunc
(
TestHarness
.
reportType
.
START_PAGE
url
url
undefined
)
)
{
iframe
.
src
=
getURLWithOptions
(
url
{
"
webglVersion
"
:
webglVersion
"
dumpShaders
"
:
this
.
dumpShaders
"
quiet
"
:
this
.
quiet
}
)
;
this
.
_bumpTimeout
(
test
)
;
}
else
{
this
.
reportResults
(
url
!
!
this
.
allowSkip
"
skipped
"
true
)
;
this
.
notifyFinished
(
url
)
;
}
}
;
TestHarness
.
prototype
.
getTest
=
function
(
url
)
{
var
test
=
this
.
runningTests
[
FilterURL
(
url
)
]
;
if
(
!
test
)
{
throw
(
"
unknown
test
:
"
+
url
)
;
}
return
test
;
}
;
TestHarness
.
prototype
.
reportResults
=
function
(
url
success
msg
skipped
)
{
url
=
FilterURL
(
url
)
;
var
test
=
this
.
getTest
(
url
)
;
if
(
0
)
{
log
(
(
success
?
"
PASS
"
:
"
FAIL
"
)
+
"
:
"
+
msg
)
;
}
this
.
reportFunc
(
TestHarness
.
reportType
.
TEST_RESULT
url
msg
success
skipped
)
;
this
.
_bumpTimeout
(
test
)
;
}
;
TestHarness
.
prototype
.
dequeTest
=
function
(
test
)
{
this
.
clearTimeout
(
test
)
;
this
.
idleIFrames
.
push
(
test
.
iframe
)
;
delete
this
.
runningTests
[
test
.
testFile
.
url
]
;
-
-
this
.
numTestsRemaining
;
}
TestHarness
.
prototype
.
notifyFinished
=
function
(
url
)
{
url
=
FilterURL
(
url
)
;
var
test
=
this
.
getTest
(
url
)
;
log
(
url
+
"
:
finished
"
)
;
this
.
dequeTest
(
test
)
;
this
.
reportFunc
(
TestHarness
.
reportType
.
FINISH_PAGE
url
url
true
)
;
this
.
startNextTest
(
)
;
}
;
TestHarness
.
prototype
.
timeout
=
function
(
test
)
{
this
.
dequeTest
(
test
)
;
var
url
=
test
.
testFile
.
url
;
log
(
url
+
"
:
timeout
"
)
;
this
.
reportFunc
(
TestHarness
.
reportType
.
FINISH_PAGE
url
url
undefined
)
;
this
.
startNextTest
(
)
;
}
;
TestHarness
.
prototype
.
setTimeoutDelay
=
function
(
x
)
{
this
.
timeoutDelay
=
x
;
}
;
return
{
'
TestHarness
'
:
TestHarness
'
getMajorVersion
'
:
getMajorVersion
'
getURLWithOptions
'
:
getURLWithOptions
}
;
}
(
)
;
