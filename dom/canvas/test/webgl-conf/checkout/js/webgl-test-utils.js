var
WebGLTestUtils
=
(
function
(
)
{
"
use
strict
"
;
var
log
=
function
(
msg
)
{
bufferedLogToConsole
(
msg
)
;
}
;
var
error
=
function
(
msg
)
{
log
(
msg
)
;
}
;
var
loggingOff
=
function
(
)
{
log
=
function
(
)
{
}
;
error
=
function
(
)
{
}
;
}
;
var
glEnumToString
=
function
(
gl
value
)
{
if
(
gl
.
NO_ERROR
=
=
=
undefined
|
|
value
=
=
=
undefined
)
{
return
undefined
;
}
if
(
value
=
=
=
gl
.
NO_ERROR
)
{
return
"
NO_ERROR
"
;
}
for
(
var
p
in
gl
)
{
if
(
gl
[
p
]
=
=
value
)
{
if
(
p
=
=
'
drawingBufferWidth
'
|
|
p
=
=
'
drawingBufferHeight
'
)
{
continue
;
}
return
p
;
}
}
return
"
0x
"
+
Number
(
value
)
.
toString
(
16
)
;
}
;
var
lastError
=
"
"
;
var
getLastError
=
function
(
)
{
return
lastError
;
}
;
var
endsWith
=
function
(
haystack
needle
)
{
return
haystack
.
substr
(
haystack
.
length
-
needle
.
length
)
=
=
=
needle
;
}
;
var
startsWith
=
function
(
haystack
needle
)
{
return
haystack
.
substr
(
0
needle
.
length
)
=
=
=
needle
;
}
;
var
simpleTextureVertexShader
=
[
'
attribute
vec4
vPosition
;
'
'
attribute
vec2
texCoord0
;
'
'
varying
vec2
texCoord
;
'
'
void
main
(
)
{
'
'
gl_Position
=
vPosition
;
'
'
texCoord
=
texCoord0
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleTextureFragmentShader
=
[
'
precision
mediump
float
;
'
'
uniform
sampler2D
tex
;
'
'
varying
vec2
texCoord
;
'
'
void
main
(
)
{
'
'
gl_FragData
[
0
]
=
texture2D
(
tex
texCoord
)
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleCubeMapTextureFragmentShader
=
[
'
precision
mediump
float
;
'
'
uniform
samplerCube
tex
;
'
'
uniform
highp
int
face
;
'
'
varying
vec2
texCoord
;
'
'
void
main
(
)
{
'
'
vec2
texC2
=
(
texCoord
*
2
.
)
-
1
.
;
'
'
vec3
texCube
=
vec3
(
0
.
0
.
0
.
)
;
'
'
if
(
face
=
=
34069
)
{
'
'
texCube
=
vec3
(
1
.
-
texC2
.
y
-
texC2
.
x
)
;
'
'
}
else
if
(
face
=
=
34070
)
{
'
'
texCube
=
vec3
(
-
1
.
-
texC2
.
y
texC2
.
x
)
;
'
'
}
else
if
(
face
=
=
34071
)
{
'
'
texCube
=
vec3
(
texC2
.
x
1
.
texC2
.
y
)
;
'
'
}
else
if
(
face
=
=
34072
)
{
'
'
texCube
=
vec3
(
texC2
.
x
-
1
.
-
texC2
.
y
)
;
'
'
}
else
if
(
face
=
=
34073
)
{
'
'
texCube
=
vec3
(
texC2
.
x
-
texC2
.
y
1
.
)
;
'
'
}
else
if
(
face
=
=
34074
)
{
'
'
texCube
=
vec3
(
-
texC2
.
x
-
texC2
.
y
-
1
.
)
;
'
'
}
'
'
gl_FragData
[
0
]
=
textureCube
(
tex
texCube
)
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
noTexCoordTextureVertexShader
=
[
'
attribute
vec4
vPosition
;
'
'
varying
vec2
texCoord
;
'
'
void
main
(
)
{
'
'
gl_Position
=
vPosition
;
'
'
texCoord
=
vPosition
.
xy
*
0
.
5
+
0
.
5
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleVertexShader
=
[
'
attribute
vec4
vPosition
;
'
'
void
main
(
)
{
'
'
gl_Position
=
vPosition
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleVertexShaderESSL300
=
[
'
#
version
300
es
'
'
in
vec4
vPosition
;
'
'
void
main
(
)
{
'
'
gl_Position
=
vPosition
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleColorFragmentShader
=
[
'
precision
mediump
float
;
'
'
uniform
vec4
u_color
;
'
'
void
main
(
)
{
'
'
gl_FragData
[
0
]
=
u_color
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleColorFragmentShaderESSL300
=
[
'
#
version
300
es
'
'
precision
mediump
float
;
'
'
out
vec4
out_color
;
'
'
uniform
vec4
u_color
;
'
'
void
main
(
)
{
'
'
out_color
=
u_color
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleVertexColorVertexShader
=
[
'
attribute
vec4
vPosition
;
'
'
attribute
vec4
a_color
;
'
'
varying
vec4
v_color
;
'
'
void
main
(
)
{
'
'
gl_Position
=
vPosition
;
'
'
v_color
=
a_color
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
simpleVertexColorFragmentShader
=
[
'
precision
mediump
float
;
'
'
varying
vec4
v_color
;
'
'
void
main
(
)
{
'
'
gl_FragData
[
0
]
=
v_color
;
'
'
}
'
]
.
join
(
'
\
n
'
)
;
var
setupProgram
=
function
(
gl
shaders
opt_attribs
opt_locations
opt_logShaders
)
{
var
realShaders
=
[
]
;
var
program
=
gl
.
createProgram
(
)
;
var
shaderCount
=
0
;
for
(
var
ii
=
0
;
ii
<
shaders
.
length
;
+
+
ii
)
{
var
shader
=
shaders
[
ii
]
;
var
shaderType
=
undefined
;
if
(
typeof
shader
=
=
'
string
'
)
{
var
element
=
document
.
getElementById
(
shader
)
;
if
(
element
)
{
if
(
element
.
type
!
=
"
x
-
shader
/
x
-
vertex
"
&
&
element
.
type
!
=
"
x
-
shader
/
x
-
fragment
"
)
shaderType
=
ii
?
gl
.
FRAGMENT_SHADER
:
gl
.
VERTEX_SHADER
;
shader
=
loadShaderFromScript
(
gl
shader
shaderType
undefined
opt_logShaders
)
;
}
else
if
(
endsWith
(
shader
"
.
vert
"
)
)
{
shader
=
loadShaderFromFile
(
gl
shader
gl
.
VERTEX_SHADER
undefined
opt_logShaders
)
;
}
else
if
(
endsWith
(
shader
"
.
frag
"
)
)
{
shader
=
loadShaderFromFile
(
gl
shader
gl
.
FRAGMENT_SHADER
undefined
opt_logShaders
)
;
}
else
{
shader
=
loadShader
(
gl
shader
ii
?
gl
.
FRAGMENT_SHADER
:
gl
.
VERTEX_SHADER
undefined
opt_logShaders
)
;
}
}
else
if
(
opt_logShaders
)
{
throw
'
Shader
source
logging
requested
but
no
shader
source
provided
'
;
}
if
(
shader
)
{
+
+
shaderCount
;
gl
.
attachShader
(
program
shader
)
;
}
}
if
(
shaderCount
!
=
2
)
{
error
(
"
Error
in
compiling
shader
"
)
;
return
null
;
}
if
(
opt_attribs
)
{
for
(
var
ii
=
0
;
ii
<
opt_attribs
.
length
;
+
+
ii
)
{
gl
.
bindAttribLocation
(
program
opt_locations
?
opt_locations
[
ii
]
:
ii
opt_attribs
[
ii
]
)
;
}
}
gl
.
linkProgram
(
program
)
;
var
linked
=
gl
.
getProgramParameter
(
program
gl
.
LINK_STATUS
)
;
if
(
!
linked
)
{
lastError
=
gl
.
getProgramInfoLog
(
program
)
;
error
(
"
Error
in
program
linking
:
"
+
lastError
)
;
gl
.
deleteProgram
(
program
)
;
return
null
;
}
gl
.
useProgram
(
program
)
;
return
program
;
}
;
var
setupTransformFeedbackProgram
=
function
(
gl
shaders
varyings
bufferMode
opt_attribs
opt_locations
opt_logShaders
opt_skipCompileStatus
)
{
var
realShaders
=
[
]
;
var
program
=
gl
.
createProgram
(
)
;
var
shaderCount
=
0
;
for
(
var
ii
=
0
;
ii
<
shaders
.
length
;
+
+
ii
)
{
var
shader
=
shaders
[
ii
]
;
var
shaderType
=
undefined
;
if
(
typeof
shader
=
=
'
string
'
)
{
var
element
=
document
.
getElementById
(
shader
)
;
if
(
element
)
{
if
(
element
.
type
!
=
"
x
-
shader
/
x
-
vertex
"
&
&
element
.
type
!
=
"
x
-
shader
/
x
-
fragment
"
)
shaderType
=
ii
?
gl
.
FRAGMENT_SHADER
:
gl
.
VERTEX_SHADER
;
shader
=
loadShaderFromScript
(
gl
shader
shaderType
undefined
opt_logShaders
opt_skipCompileStatus
)
;
}
else
if
(
endsWith
(
shader
"
.
vert
"
)
)
{
shader
=
loadShaderFromFile
(
gl
shader
gl
.
VERTEX_SHADER
undefined
opt_logShaders
opt_skipCompileStatus
)
;
}
else
if
(
endsWith
(
shader
"
.
frag
"
)
)
{
shader
=
loadShaderFromFile
(
gl
shader
gl
.
FRAGMENT_SHADER
undefined
opt_logShaders
opt_skipCompileStatus
)
;
}
else
{
shader
=
loadShader
(
gl
shader
ii
?
gl
.
FRAGMENT_SHADER
:
gl
.
VERTEX_SHADER
undefined
opt_logShaders
undefined
undefined
opt_skipCompileStatus
)
;
}
}
else
if
(
opt_logShaders
)
{
throw
'
Shader
source
logging
requested
but
no
shader
source
provided
'
;
}
if
(
shader
)
{
+
+
shaderCount
;
gl
.
attachShader
(
program
shader
)
;
}
}
if
(
shaderCount
!
=
2
)
{
error
(
"
Error
in
compiling
shader
"
)
;
return
null
;
}
if
(
opt_attribs
)
{
for
(
var
ii
=
0
;
ii
<
opt_attribs
.
length
;
+
+
ii
)
{
gl
.
bindAttribLocation
(
program
opt_locations
?
opt_locations
[
ii
]
:
ii
opt_attribs
[
ii
]
)
;
}
}
gl
.
transformFeedbackVaryings
(
program
varyings
bufferMode
)
;
gl
.
linkProgram
(
program
)
;
var
linked
=
gl
.
getProgramParameter
(
program
gl
.
LINK_STATUS
)
;
if
(
!
linked
)
{
lastError
=
gl
.
getProgramInfoLog
(
program
)
;
error
(
"
Error
in
program
linking
:
"
+
lastError
)
;
gl
.
deleteProgram
(
program
)
;
return
null
;
}
gl
.
useProgram
(
program
)
;
return
program
;
}
;
var
setupNoTexCoordTextureProgram
=
function
(
gl
)
{
return
setupProgram
(
gl
[
noTexCoordTextureVertexShader
simpleTextureFragmentShader
]
[
'
vPosition
'
]
[
0
]
)
;
}
;
var
setupSimpleTextureProgram
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
)
{
opt_positionLocation
=
opt_positionLocation
|
|
0
;
opt_texcoordLocation
=
opt_texcoordLocation
|
|
1
;
return
setupProgram
(
gl
[
simpleTextureVertexShader
simpleTextureFragmentShader
]
[
'
vPosition
'
'
texCoord0
'
]
[
opt_positionLocation
opt_texcoordLocation
]
)
;
}
;
var
setupSimpleCubeMapTextureProgram
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
)
{
opt_positionLocation
=
opt_positionLocation
|
|
0
;
opt_texcoordLocation
=
opt_texcoordLocation
|
|
1
;
return
setupProgram
(
gl
[
simpleTextureVertexShader
simpleCubeMapTextureFragmentShader
]
[
'
vPosition
'
'
texCoord0
'
]
[
opt_positionLocation
opt_texcoordLocation
]
)
;
}
;
var
setupSimpleVertexColorProgram
=
function
(
gl
opt_positionLocation
opt_vertexColorLocation
)
{
opt_positionLocation
=
opt_positionLocation
|
|
0
;
opt_vertexColorLocation
=
opt_vertexColorLocation
|
|
1
;
return
setupProgram
(
gl
[
simpleVertexColorVertexShader
simpleVertexColorFragmentShader
]
[
'
vPosition
'
'
a_color
'
]
[
opt_positionLocation
opt_vertexColorLocation
]
)
;
}
;
var
setupSimpleColorProgram
=
function
(
gl
opt_positionLocation
)
{
opt_positionLocation
=
opt_positionLocation
|
|
0
;
return
setupProgram
(
gl
[
simpleVertexShader
simpleColorFragmentShader
]
[
'
vPosition
'
]
[
opt_positionLocation
]
)
;
}
;
var
setupUnitQuad
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
options
)
{
return
setupQuadWithTexCoords
(
gl
[
0
.
0
0
.
0
]
[
1
.
0
1
.
0
]
opt_positionLocation
opt_texcoordLocation
options
)
;
}
;
var
setupQuadWithTexCoords
=
function
(
gl
lowerLeftTexCoords
upperRightTexCoords
opt_positionLocation
opt_texcoordLocation
options
)
{
var
defaultOptions
=
{
positionLocation
:
opt_positionLocation
|
|
0
texcoordLocation
:
opt_texcoordLocation
|
|
1
lowerLeftTexCoords
:
lowerLeftTexCoords
upperRightTexCoords
:
upperRightTexCoords
}
;
if
(
options
)
{
for
(
var
prop
in
options
)
{
defaultOptions
[
prop
]
=
options
[
prop
]
}
}
return
setupQuad
(
gl
defaultOptions
)
;
}
;
var
setupQuad
=
function
(
gl
options
)
{
var
positionLocation
=
options
.
positionLocation
|
|
0
;
var
scale
=
options
.
scale
|
|
1
;
var
objects
=
[
]
;
var
vertexObject
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
vertexObject
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Float32Array
(
[
1
.
0
*
scale
1
.
0
*
scale
-
1
.
0
*
scale
1
.
0
*
scale
-
1
.
0
*
scale
-
1
.
0
*
scale
1
.
0
*
scale
1
.
0
*
scale
-
1
.
0
*
scale
-
1
.
0
*
scale
1
.
0
*
scale
-
1
.
0
*
scale
]
)
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
positionLocation
)
;
gl
.
vertexAttribPointer
(
positionLocation
2
gl
.
FLOAT
false
0
0
)
;
objects
.
push
(
vertexObject
)
;
if
(
options
.
texcoordLocation
!
=
=
undefined
)
{
var
llx
=
options
.
lowerLeftTexCoords
[
0
]
;
var
lly
=
options
.
lowerLeftTexCoords
[
1
]
;
var
urx
=
options
.
upperRightTexCoords
[
0
]
;
var
ury
=
options
.
upperRightTexCoords
[
1
]
;
vertexObject
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
vertexObject
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Float32Array
(
[
urx
ury
llx
ury
llx
lly
urx
ury
llx
lly
urx
lly
]
)
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
options
.
texcoordLocation
)
;
gl
.
vertexAttribPointer
(
options
.
texcoordLocation
2
gl
.
FLOAT
false
0
0
)
;
objects
.
push
(
vertexObject
)
;
}
return
objects
;
}
;
var
setupTexturedQuad
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
options
)
{
var
program
=
setupSimpleTextureProgram
(
gl
opt_positionLocation
opt_texcoordLocation
)
;
setupUnitQuad
(
gl
opt_positionLocation
opt_texcoordLocation
options
)
;
return
program
;
}
;
var
setupColorQuad
=
function
(
gl
opt_positionLocation
options
)
{
opt_positionLocation
=
opt_positionLocation
|
|
0
;
var
program
=
setupSimpleColorProgram
(
gl
opt_positionLocation
)
;
setupUnitQuad
(
gl
opt_positionLocation
0
options
)
;
return
program
;
}
;
var
setupTexturedQuadWithTexCoords
=
function
(
gl
lowerLeftTexCoords
upperRightTexCoords
opt_positionLocation
opt_texcoordLocation
)
{
var
program
=
setupSimpleTextureProgram
(
gl
opt_positionLocation
opt_texcoordLocation
)
;
setupQuadWithTexCoords
(
gl
lowerLeftTexCoords
upperRightTexCoords
opt_positionLocation
opt_texcoordLocation
)
;
return
program
;
}
;
var
setupTexturedQuadWithCubeMap
=
function
(
gl
opt_positionLocation
opt_texcoordLocation
)
{
var
program
=
setupSimpleCubeMapTextureProgram
(
gl
opt_positionLocation
opt_texcoordLocation
)
;
setupUnitQuad
(
gl
opt_positionLocation
opt_texcoordLocation
undefined
)
;
return
program
;
}
;
var
setupIndexedQuad
=
function
(
gl
gridRes
opt_positionLocation
opt_flipOddTriangles
)
{
return
setupIndexedQuadWithOptions
(
gl
{
gridRes
:
gridRes
positionLocation
:
opt_positionLocation
flipOddTriangles
:
opt_flipOddTriangles
}
)
;
}
;
var
setupIndexedQuadWithOptions
=
function
(
gl
options
)
{
var
positionLocation
=
options
.
positionLocation
|
|
0
;
var
objects
=
[
]
;
var
gridRes
=
options
.
gridRes
|
|
1
;
var
positionOffset
=
options
.
positionOffset
|
|
0
;
var
positionMult
=
options
.
positionMult
|
|
1
;
var
vertsAcross
=
gridRes
+
1
;
var
numVerts
=
vertsAcross
*
vertsAcross
;
var
positions
=
new
Float32Array
(
numVerts
*
3
)
;
var
indices
=
new
Uint16Array
(
6
*
gridRes
*
gridRes
)
;
var
poffset
=
0
;
for
(
var
yy
=
0
;
yy
<
=
gridRes
;
+
+
yy
)
{
for
(
var
xx
=
0
;
xx
<
=
gridRes
;
+
+
xx
)
{
positions
[
poffset
+
0
]
=
(
-
1
+
2
*
xx
/
gridRes
)
*
positionMult
+
positionOffset
;
positions
[
poffset
+
1
]
=
(
-
1
+
2
*
yy
/
gridRes
)
*
positionMult
+
positionOffset
;
positions
[
poffset
+
2
]
=
0
;
poffset
+
=
3
;
}
}
var
buf
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
buf
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
positions
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
positionLocation
)
;
gl
.
vertexAttribPointer
(
positionLocation
3
gl
.
FLOAT
false
0
0
)
;
objects
.
push
(
buf
)
;
if
(
options
.
colorLocation
!
=
=
undefined
)
{
var
colors
=
new
Float32Array
(
numVerts
*
4
)
;
for
(
var
yy
=
0
;
yy
<
=
gridRes
;
+
+
yy
)
{
for
(
var
xx
=
0
;
xx
<
=
gridRes
;
+
+
xx
)
{
if
(
options
.
color
!
=
=
undefined
)
{
colors
[
poffset
+
0
]
=
options
.
color
[
0
]
;
colors
[
poffset
+
1
]
=
options
.
color
[
1
]
;
colors
[
poffset
+
2
]
=
options
.
color
[
2
]
;
colors
[
poffset
+
3
]
=
options
.
color
[
3
]
;
}
else
{
colors
[
poffset
+
0
]
=
xx
/
gridRes
;
colors
[
poffset
+
1
]
=
yy
/
gridRes
;
colors
[
poffset
+
2
]
=
(
xx
/
gridRes
)
*
(
yy
/
gridRes
)
;
colors
[
poffset
+
3
]
=
(
yy
%
2
)
*
0
.
5
+
0
.
5
;
}
poffset
+
=
4
;
}
}
buf
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
buf
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
colors
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
options
.
colorLocation
)
;
gl
.
vertexAttribPointer
(
options
.
colorLocation
4
gl
.
FLOAT
false
0
0
)
;
objects
.
push
(
buf
)
;
}
var
tbase
=
0
;
for
(
var
yy
=
0
;
yy
<
gridRes
;
+
+
yy
)
{
var
index
=
yy
*
vertsAcross
;
for
(
var
xx
=
0
;
xx
<
gridRes
;
+
+
xx
)
{
indices
[
tbase
+
0
]
=
index
+
0
;
indices
[
tbase
+
1
]
=
index
+
1
;
indices
[
tbase
+
2
]
=
index
+
vertsAcross
;
indices
[
tbase
+
3
]
=
index
+
vertsAcross
;
indices
[
tbase
+
4
]
=
index
+
1
;
indices
[
tbase
+
5
]
=
index
+
vertsAcross
+
1
;
if
(
options
.
flipOddTriangles
)
{
indices
[
tbase
+
4
]
=
index
+
vertsAcross
+
1
;
indices
[
tbase
+
5
]
=
index
+
1
;
}
index
+
=
1
;
tbase
+
=
6
;
}
}
buf
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ELEMENT_ARRAY_BUFFER
buf
)
;
gl
.
bufferData
(
gl
.
ELEMENT_ARRAY_BUFFER
indices
gl
.
STATIC_DRAW
)
;
objects
.
push
(
buf
)
;
return
objects
;
}
;
var
glTypeToTypedArrayType
=
function
(
gl
type
)
{
switch
(
type
)
{
case
gl
.
BYTE
:
return
window
.
Int8Array
;
case
gl
.
UNSIGNED_BYTE
:
return
window
.
Uint8Array
;
case
gl
.
SHORT
:
return
window
.
Int16Array
;
case
gl
.
UNSIGNED_SHORT
:
case
gl
.
UNSIGNED_SHORT_5_6_5
:
case
gl
.
UNSIGNED_SHORT_4_4_4_4
:
case
gl
.
UNSIGNED_SHORT_5_5_5_1
:
return
window
.
Uint16Array
;
case
gl
.
INT
:
return
window
.
Int32Array
;
case
gl
.
UNSIGNED_INT
:
case
gl
.
UNSIGNED_INT_5_9_9_9_REV
:
case
gl
.
UNSIGNED_INT_10F_11F_11F_REV
:
case
gl
.
UNSIGNED_INT_2_10_10_10_REV
:
case
gl
.
UNSIGNED_INT_24_8
:
return
window
.
Uint32Array
;
case
gl
.
HALF_FLOAT
:
case
0x8D61
:
return
window
.
Uint16Array
;
case
gl
.
FLOAT
:
return
window
.
Float32Array
;
default
:
throw
'
unknown
gl
type
'
+
glEnumToString
(
gl
type
)
;
}
}
;
var
getBytesPerComponent
=
function
(
gl
type
)
{
switch
(
type
)
{
case
gl
.
BYTE
:
case
gl
.
UNSIGNED_BYTE
:
return
1
;
case
gl
.
SHORT
:
case
gl
.
UNSIGNED_SHORT
:
case
gl
.
UNSIGNED_SHORT_5_6_5
:
case
gl
.
UNSIGNED_SHORT_4_4_4_4
:
case
gl
.
UNSIGNED_SHORT_5_5_5_1
:
case
gl
.
HALF_FLOAT
:
case
0x8D61
:
return
2
;
case
gl
.
INT
:
case
gl
.
UNSIGNED_INT
:
case
gl
.
UNSIGNED_INT_5_9_9_9_REV
:
case
gl
.
UNSIGNED_INT_10F_11F_11F_REV
:
case
gl
.
UNSIGNED_INT_2_10_10_10_REV
:
case
gl
.
UNSIGNED_INT_24_8
:
case
gl
.
FLOAT
:
return
4
;
default
:
throw
'
unknown
gl
type
'
+
glEnumToString
(
gl
type
)
;
}
}
;
var
getTypedArrayElementsPerPixel
=
function
(
gl
format
type
)
{
switch
(
type
)
{
case
gl
.
UNSIGNED_SHORT_5_6_5
:
case
gl
.
UNSIGNED_SHORT_4_4_4_4
:
case
gl
.
UNSIGNED_SHORT_5_5_5_1
:
return
1
;
case
gl
.
UNSIGNED_BYTE
:
break
;
default
:
throw
'
not
a
gl
type
for
color
information
'
+
glEnumToString
(
gl
type
)
;
}
switch
(
format
)
{
case
gl
.
RGBA
:
return
4
;
case
gl
.
RGB
:
return
3
;
case
gl
.
LUMINANCE_ALPHA
:
return
2
;
case
gl
.
LUMINANCE
:
case
gl
.
ALPHA
:
return
1
;
default
:
throw
'
unknown
gl
format
'
+
glEnumToString
(
gl
format
)
;
}
}
;
var
fillTexture
=
function
(
gl
tex
width
height
color
opt_level
opt_format
opt_type
opt_internalFormat
)
{
opt_level
=
opt_level
|
|
0
;
opt_format
=
opt_format
|
|
gl
.
RGBA
;
opt_type
=
opt_type
|
|
gl
.
UNSIGNED_BYTE
;
opt_internalFormat
=
opt_internalFormat
|
|
opt_format
;
var
pack
=
gl
.
getParameter
(
gl
.
UNPACK_ALIGNMENT
)
;
var
numComponents
=
color
.
length
;
var
bytesPerComponent
=
getBytesPerComponent
(
gl
opt_type
)
;
var
rowSize
=
numComponents
*
width
*
bytesPerComponent
;
var
paddedRowLength
;
if
(
bytesPerComponent
>
=
pack
)
paddedRowLength
=
numComponents
*
width
;
else
paddedRowLength
=
Math
.
floor
(
(
rowSize
+
pack
-
1
)
/
pack
)
*
pack
/
bytesPerComponent
;
var
size
=
width
*
numComponents
+
(
height
-
1
)
*
paddedRowLength
;
var
buf
=
new
(
glTypeToTypedArrayType
(
gl
opt_type
)
)
(
size
)
;
for
(
var
yy
=
0
;
yy
<
height
;
+
+
yy
)
{
var
off
=
yy
*
paddedRowLength
;
for
(
var
xx
=
0
;
xx
<
width
;
+
+
xx
)
{
for
(
var
jj
=
0
;
jj
<
numComponents
;
+
+
jj
)
{
buf
[
off
+
+
]
=
color
[
jj
]
;
}
}
}
gl
.
bindTexture
(
gl
.
TEXTURE_2D
tex
)
;
gl
.
texImage2D
(
gl
.
TEXTURE_2D
opt_level
opt_internalFormat
width
height
0
opt_format
opt_type
buf
)
;
}
;
var
createColoredTexture
=
function
(
gl
width
height
color
)
{
var
tex
=
gl
.
createTexture
(
)
;
fillTexture
(
gl
tex
width
height
color
)
;
return
tex
;
}
;
var
ubyteToFloat
=
function
(
c
)
{
return
c
/
255
;
}
;
var
ubyteColorToFloatColor
=
function
(
color
)
{
var
floatColor
=
[
]
;
for
(
var
ii
=
0
;
ii
<
color
.
length
;
+
+
ii
)
{
floatColor
[
ii
]
=
ubyteToFloat
(
color
[
ii
]
)
;
}
return
floatColor
;
}
;
var
setFloatDrawColor
=
function
(
gl
color
)
{
var
program
=
gl
.
getParameter
(
gl
.
CURRENT_PROGRAM
)
;
var
colorLocation
=
gl
.
getUniformLocation
(
program
"
u_color
"
)
;
gl
.
uniform4fv
(
colorLocation
color
)
;
}
;
var
setUByteDrawColor
=
function
(
gl
color
)
{
setFloatDrawColor
(
gl
ubyteColorToFloatColor
(
color
)
)
;
}
;
var
drawFloatColorQuad
=
function
(
gl
color
)
{
var
program
=
gl
.
getParameter
(
gl
.
CURRENT_PROGRAM
)
;
var
colorLocation
=
gl
.
getUniformLocation
(
program
"
u_color
"
)
;
gl
.
uniform4fv
(
colorLocation
color
)
;
gl
.
drawArrays
(
gl
.
TRIANGLES
0
6
)
;
}
;
var
drawUByteColorQuad
=
function
(
gl
color
)
{
drawFloatColorQuad
(
gl
ubyteColorToFloatColor
(
color
)
)
;
}
;
var
drawUnitQuad
=
function
(
gl
)
{
gl
.
drawArrays
(
gl
.
TRIANGLES
0
6
)
;
}
;
var
dummySetProgramAndDrawNothing
=
function
(
gl
)
{
if
(
!
gl
.
_wtuDummyProgram
)
{
gl
.
_wtuDummyProgram
=
setupProgram
(
gl
[
"
void
main
(
)
{
gl_Position
=
vec4
(
0
.
0
)
;
}
"
"
void
main
(
)
{
gl_FragColor
=
vec4
(
0
.
0
)
;
}
"
]
[
]
[
]
)
;
}
gl
.
useProgram
(
gl
.
_wtuDummyProgram
)
;
gl
.
drawArrays
(
gl
.
TRIANGLES
0
3
)
;
}
;
var
clearAndDrawUnitQuad
=
function
(
gl
opt_color
)
{
opt_color
=
opt_color
|
|
[
255
255
255
255
]
;
gl
.
clearColor
(
opt_color
[
0
]
/
255
opt_color
[
1
]
/
255
opt_color
[
2
]
/
255
opt_color
[
3
]
/
255
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
)
;
drawUnitQuad
(
gl
)
;
}
;
var
drawIndexedQuad
=
function
(
gl
gridRes
)
{
gl
.
drawElements
(
gl
.
TRIANGLES
gridRes
*
gridRes
*
6
gl
.
UNSIGNED_SHORT
0
)
;
}
;
var
clearAndDrawIndexedQuad
=
function
(
gl
gridRes
opt_color
)
{
opt_color
=
opt_color
|
|
[
255
255
255
255
]
;
gl
.
clearColor
(
opt_color
[
0
]
/
255
opt_color
[
1
]
/
255
opt_color
[
2
]
/
255
opt_color
[
3
]
/
255
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
)
;
drawIndexedQuad
(
gl
gridRes
)
;
}
;
var
clipToRange
=
function
(
value
extent
min
max
)
{
if
(
value
<
min
)
{
extent
-
=
min
-
value
;
value
=
min
;
}
var
end
=
value
+
extent
;
if
(
end
>
max
)
{
extent
-
=
end
-
max
;
}
if
(
extent
<
0
)
{
value
=
max
;
extent
=
0
;
}
return
{
value
:
value
extent
:
extent
}
;
}
;
var
isWebGLContext
=
function
(
ctx
)
{
if
(
ctx
instanceof
WebGLRenderingContext
)
return
true
;
if
(
'
WebGL2RenderingContext
'
in
window
&
&
ctx
instanceof
WebGL2RenderingContext
)
return
true
;
return
false
;
}
;
var
makeCheckRect
=
function
(
x
y
width
height
color
msg
errorRange
)
{
var
rect
=
{
'
x
'
:
x
'
y
'
:
y
'
width
'
:
width
'
height
'
:
height
'
color
'
:
color
'
msg
'
:
msg
'
errorRange
'
:
errorRange
'
checkRect
'
:
function
(
buf
l
b
w
)
{
for
(
var
px
=
(
x
-
l
)
;
px
<
(
x
+
width
-
l
)
;
+
+
px
)
{
for
(
var
py
=
(
y
-
b
)
;
py
<
(
y
+
height
-
b
)
;
+
+
py
)
{
var
offset
=
(
py
*
w
+
px
)
*
4
;
for
(
var
j
=
0
;
j
<
color
.
length
;
+
+
j
)
{
if
(
Math
.
abs
(
buf
[
offset
+
j
]
-
color
[
j
]
)
>
errorRange
)
{
testFailed
(
msg
)
;
var
was
=
buf
[
offset
+
0
]
.
toString
(
)
;
for
(
j
=
1
;
j
<
color
.
length
;
+
+
j
)
{
was
+
=
"
"
+
buf
[
offset
+
j
]
;
}
debug
(
'
at
(
'
+
px
+
'
'
+
py
+
'
)
expected
:
'
+
color
+
'
was
'
+
was
)
;
return
;
}
}
}
}
testPassed
(
msg
)
;
}
}
return
rect
;
}
;
var
checkCanvasRects
=
function
(
gl
rects
)
{
if
(
rects
.
length
>
0
)
{
var
left
=
rects
[
0
]
.
x
;
var
right
=
rects
[
0
]
.
x
+
rects
[
1
]
.
width
;
var
bottom
=
rects
[
0
]
.
y
;
var
top
=
rects
[
0
]
.
y
+
rects
[
0
]
.
height
;
for
(
var
i
=
1
;
i
<
rects
.
length
;
+
+
i
)
{
left
=
Math
.
min
(
left
rects
[
i
]
.
x
)
;
right
=
Math
.
max
(
right
rects
[
i
]
.
x
+
rects
[
i
]
.
width
)
;
bottom
=
Math
.
min
(
bottom
rects
[
i
]
.
y
)
;
top
=
Math
.
max
(
top
rects
[
i
]
.
y
+
rects
[
i
]
.
height
)
;
}
var
width
=
right
-
left
;
var
height
=
top
-
bottom
;
var
buf
=
new
Uint8Array
(
width
*
height
*
4
)
;
gl
.
readPixels
(
left
bottom
width
height
gl
.
RGBA
gl
.
UNSIGNED_BYTE
buf
)
;
for
(
var
i
=
0
;
i
<
rects
.
length
;
+
+
i
)
{
rects
[
i
]
.
checkRect
(
buf
left
bottom
width
)
;
}
}
}
;
var
checkCanvasRectColor
=
function
(
gl
x
y
width
height
color
opt_errorRange
sameFn
differentFn
logFn
opt_readBackBuf
opt_readBackType
)
{
if
(
isWebGLContext
(
gl
)
&
&
!
gl
.
getParameter
(
gl
.
FRAMEBUFFER_BINDING
)
)
{
var
xr
=
clipToRange
(
x
width
0
gl
.
canvas
.
width
)
;
var
yr
=
clipToRange
(
y
height
0
gl
.
canvas
.
height
)
;
if
(
!
xr
.
extent
|
|
!
yr
.
extent
)
{
logFn
(
"
checking
rect
:
effective
width
or
height
is
zero
"
)
;
sameFn
(
)
;
return
;
}
x
=
xr
.
value
;
y
=
yr
.
value
;
width
=
xr
.
extent
;
height
=
yr
.
extent
;
}
var
errorRange
=
opt_errorRange
|
|
0
;
if
(
!
errorRange
.
length
)
{
errorRange
=
[
errorRange
errorRange
errorRange
errorRange
]
}
var
buf
;
if
(
isWebGLContext
(
gl
)
)
{
buf
=
opt_readBackBuf
?
opt_readBackBuf
:
new
Uint8Array
(
width
*
height
*
4
)
;
var
readBackType
=
opt_readBackType
?
opt_readBackType
:
gl
.
UNSIGNED_BYTE
;
gl
.
readPixels
(
x
y
width
height
gl
.
RGBA
readBackType
buf
)
;
}
else
{
buf
=
gl
.
getImageData
(
x
y
width
height
)
.
data
;
}
for
(
var
i
=
0
;
i
<
width
*
height
;
+
+
i
)
{
var
offset
=
i
*
4
;
for
(
var
j
=
0
;
j
<
color
.
length
;
+
+
j
)
{
if
(
Math
.
abs
(
buf
[
offset
+
j
]
-
color
[
j
]
)
>
errorRange
[
j
]
)
{
var
was
=
buf
[
offset
+
0
]
.
toString
(
)
;
for
(
j
=
1
;
j
<
color
.
length
;
+
+
j
)
{
was
+
=
"
"
+
buf
[
offset
+
j
]
;
}
differentFn
(
'
at
(
'
+
(
x
+
(
i
%
width
)
)
+
'
'
+
(
y
+
Math
.
floor
(
i
/
width
)
)
+
'
)
expected
:
'
+
color
+
'
was
'
+
was
)
;
return
;
}
}
}
sameFn
(
)
;
}
;
var
checkCanvasRect
=
function
(
gl
x
y
width
height
color
opt_msg
opt_errorRange
opt_readBackBuf
opt_readBackType
)
{
checkCanvasRectColor
(
gl
x
y
width
height
color
opt_errorRange
function
(
)
{
var
msg
=
opt_msg
;
if
(
msg
=
=
=
undefined
)
msg
=
"
should
be
"
+
color
.
toString
(
)
;
testPassed
(
msg
)
;
}
function
(
differentMsg
)
{
var
msg
=
opt_msg
;
if
(
msg
=
=
=
undefined
)
msg
=
"
should
be
"
+
color
.
toString
(
)
;
testFailed
(
msg
+
"
\
n
"
+
differentMsg
)
;
}
debug
opt_readBackBuf
opt_readBackType
)
;
}
;
var
checkCanvas
=
function
(
gl
color
msg
errorRange
)
{
checkCanvasRect
(
gl
0
0
gl
.
canvas
.
width
gl
.
canvas
.
height
color
msg
errorRange
)
;
}
;
var
checkAreaInAndOut
=
function
(
gl
x
y
width
height
innerColor
outerColor
opt_edgeSize
opt_outerDimensions
)
{
var
outerDimensions
=
opt_outerDimensions
|
|
{
width
:
gl
.
canvas
.
width
height
:
gl
.
canvas
.
height
}
;
var
edgeSize
=
opt_edgeSize
|
|
0
;
checkCanvasRect
(
gl
x
+
edgeSize
y
+
edgeSize
width
-
edgeSize
*
2
height
-
edgeSize
*
2
innerColor
)
;
checkCanvasRect
(
gl
0
0
x
-
edgeSize
outerDimensions
.
height
outerColor
)
;
checkCanvasRect
(
gl
x
+
width
+
edgeSize
0
outerDimensions
.
width
-
x
-
width
-
edgeSize
outerDimensions
.
height
outerColor
)
;
checkCanvasRect
(
gl
0
0
outerDimensions
.
width
y
-
edgeSize
outerColor
)
;
checkCanvasRect
(
gl
0
y
+
height
+
edgeSize
outerDimensions
.
width
outerDimensions
.
height
-
y
-
height
-
edgeSize
outerColor
)
;
}
;
var
checkFloatBuffer
=
function
(
gl
target
expected
opt_msg
opt_errorRange
)
{
if
(
opt_msg
=
=
=
undefined
)
opt_msg
=
"
buffer
should
match
expected
values
"
;
if
(
opt_errorRange
=
=
=
undefined
)
opt_errorRange
=
0
.
001
;
var
floatArray
=
new
Float32Array
(
expected
.
length
)
;
gl
.
getBufferSubData
(
target
0
floatArray
)
;
for
(
var
i
=
0
;
i
<
expected
.
length
;
i
+
+
)
{
if
(
Math
.
abs
(
floatArray
[
i
]
-
expected
[
i
]
)
>
opt_errorRange
)
{
testFailed
(
opt_msg
)
;
debug
(
'
at
[
'
+
i
+
'
]
expected
:
'
+
expected
[
i
]
+
'
was
'
+
floatArray
[
i
]
)
;
return
;
}
}
testPassed
(
opt_msg
)
;
}
;
var
loadTexture
=
function
(
gl
url
callback
)
{
var
texture
=
gl
.
createTexture
(
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
texture
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
var
image
=
new
Image
(
)
;
image
.
onload
=
function
(
)
{
gl
.
bindTexture
(
gl
.
TEXTURE_2D
texture
)
;
gl
.
pixelStorei
(
gl
.
UNPACK_FLIP_Y_WEBGL
true
)
;
gl
.
texImage2D
(
gl
.
TEXTURE_2D
0
gl
.
RGBA
gl
.
RGBA
gl
.
UNSIGNED_BYTE
image
)
;
callback
(
image
)
;
}
;
image
.
src
=
url
;
return
texture
;
}
;
var
checkTextureSize
=
function
(
gl
width
height
opt_format
opt_type
)
{
opt_format
=
opt_format
|
|
gl
.
RGBA
;
opt_type
=
opt_type
|
|
gl
.
UNSIGNED_BYTE
;
var
numElements
=
getTypedArrayElementsPerPixel
(
gl
opt_format
opt_type
)
;
var
buf
=
new
(
glTypeToTypedArrayType
(
gl
opt_type
)
)
(
numElements
)
;
var
errors
=
0
;
gl
.
texSubImage2D
(
gl
.
TEXTURE_2D
0
width
-
1
height
-
1
1
1
opt_format
opt_type
buf
)
;
if
(
gl
.
getError
(
)
!
=
gl
.
NO_ERROR
)
{
testFailed
(
"
Texture
was
smaller
than
the
expected
size
"
+
width
+
"
x
"
+
height
)
;
+
+
errors
;
}
gl
.
texSubImage2D
(
gl
.
TEXTURE_2D
0
width
-
1
height
1
1
opt_format
opt_type
buf
)
;
if
(
gl
.
getError
(
)
=
=
gl
.
NO_ERROR
)
{
testFailed
(
"
Texture
was
taller
than
"
+
height
)
;
+
+
errors
;
}
gl
.
texSubImage2D
(
gl
.
TEXTURE_2D
0
width
height
-
1
1
1
opt_format
opt_type
buf
)
;
if
(
gl
.
getError
(
)
=
=
gl
.
NO_ERROR
)
{
testFailed
(
"
Texture
was
wider
than
"
+
width
)
;
+
+
errors
;
}
if
(
errors
=
=
0
)
{
testPassed
(
"
Texture
had
the
expected
size
"
+
width
+
"
x
"
+
height
)
;
}
}
;
var
shallowCopyObject
=
function
(
src
)
{
var
dst
=
{
}
;
for
(
var
attr
in
src
)
{
if
(
src
.
hasOwnProperty
(
attr
)
)
{
dst
[
attr
]
=
src
[
attr
]
;
}
}
return
dst
;
}
;
var
hasAttributeCaseInsensitive
=
function
(
obj
attr
)
{
var
lower
=
attr
.
toLowerCase
(
)
;
for
(
var
key
in
obj
)
{
if
(
obj
.
hasOwnProperty
(
key
)
&
&
key
.
toLowerCase
(
)
=
=
lower
)
{
return
key
;
}
}
}
;
var
getUrlOptions
=
(
function
(
)
{
var
_urlOptionsParsed
=
false
;
var
_urlOptions
=
{
}
;
return
function
(
)
{
if
(
!
_urlOptionsParsed
)
{
var
s
=
window
.
location
.
href
;
var
q
=
s
.
indexOf
(
"
?
"
)
;
var
e
=
s
.
indexOf
(
"
#
"
)
;
if
(
e
<
0
)
{
e
=
s
.
length
;
}
var
query
=
s
.
substring
(
q
+
1
e
)
;
var
pairs
=
query
.
split
(
"
&
"
)
;
for
(
var
ii
=
0
;
ii
<
pairs
.
length
;
+
+
ii
)
{
var
keyValue
=
pairs
[
ii
]
.
split
(
"
=
"
)
;
var
key
=
keyValue
[
0
]
;
var
value
=
decodeURIComponent
(
keyValue
[
1
]
)
;
_urlOptions
[
key
]
=
value
;
}
_urlOptionsParsed
=
true
;
}
return
_urlOptions
;
}
}
)
(
)
;
var
default3DContextVersion
=
1
;
var
setDefault3DContextVersion
=
function
(
version
)
{
default3DContextVersion
=
version
;
}
;
var
getDefault3DContextVersion
=
function
(
)
{
return
parseInt
(
getUrlOptions
(
)
.
webglVersion
10
)
|
|
default3DContextVersion
;
}
;
var
create3DContext
=
function
(
opt_canvas
opt_attributes
opt_version
)
{
if
(
window
.
initTestingHarness
)
{
window
.
initTestingHarness
(
)
;
}
var
attributes
=
shallowCopyObject
(
opt_attributes
|
|
{
}
)
;
if
(
!
hasAttributeCaseInsensitive
(
attributes
"
antialias
"
)
)
{
attributes
.
antialias
=
false
;
}
if
(
!
opt_version
)
{
opt_version
=
parseInt
(
getUrlOptions
(
)
.
webglVersion
10
)
|
|
default3DContextVersion
;
}
opt_canvas
=
opt_canvas
|
|
document
.
createElement
(
"
canvas
"
)
;
if
(
typeof
opt_canvas
=
=
'
string
'
)
{
opt_canvas
=
document
.
getElementById
(
opt_canvas
)
;
}
var
context
=
null
;
var
names
;
switch
(
opt_version
)
{
case
2
:
names
=
[
"
webgl2
"
]
;
break
;
default
:
names
=
[
"
webgl
"
"
experimental
-
webgl
"
]
;
break
;
}
for
(
var
i
=
0
;
i
<
names
.
length
;
+
+
i
)
{
try
{
context
=
opt_canvas
.
getContext
(
names
[
i
]
attributes
)
;
}
catch
(
e
)
{
}
if
(
context
)
{
break
;
}
}
if
(
!
context
)
{
testFailed
(
"
Unable
to
fetch
WebGL
rendering
context
for
Canvas
"
)
;
}
return
context
;
}
;
function
GLErrorException
(
message
error
)
{
this
.
message
=
message
;
this
.
name
=
"
GLErrorException
"
;
this
.
error
=
error
;
}
;
var
createGLErrorWrapper
=
function
(
context
fname
)
{
return
function
(
)
{
var
rv
=
context
[
fname
]
.
apply
(
context
arguments
)
;
var
err
=
context
.
getError
(
)
;
if
(
err
!
=
context
.
NO_ERROR
)
{
var
msg
=
"
GL
error
"
+
glEnumToString
(
context
err
)
+
"
in
"
+
fname
;
throw
new
GLErrorException
(
msg
err
)
;
}
return
rv
;
}
;
}
;
function
create3DContextWithWrapperThatThrowsOnGLError
(
canvas
opt_attributes
opt_version
)
{
var
context
=
create3DContext
(
canvas
opt_attributes
opt_version
)
;
var
wrap
=
{
}
;
for
(
var
i
in
context
)
{
try
{
if
(
typeof
context
[
i
]
=
=
'
function
'
)
{
wrap
[
i
]
=
createGLErrorWrapper
(
context
i
)
;
}
else
{
wrap
[
i
]
=
context
[
i
]
;
}
}
catch
(
e
)
{
error
(
"
createContextWrapperThatThrowsOnGLError
:
Error
accessing
"
+
i
)
;
}
}
wrap
.
getError
=
function
(
)
{
return
context
.
getError
(
)
;
}
;
return
wrap
;
}
;
var
shouldGenerateGLError
=
function
(
gl
glErrors
evalStr
opt_msg
)
{
var
exception
;
try
{
eval
(
evalStr
)
;
}
catch
(
e
)
{
exception
=
e
;
}
if
(
exception
)
{
testFailed
(
evalStr
+
"
threw
exception
"
+
exception
)
;
return
-
1
;
}
else
{
if
(
!
opt_msg
)
{
opt_msg
=
"
after
evaluating
:
"
+
evalStr
;
}
return
glErrorShouldBe
(
gl
glErrors
opt_msg
)
;
}
}
;
var
failIfGLError
=
function
(
gl
evalStr
)
{
var
exception
;
try
{
eval
(
evalStr
)
;
}
catch
(
e
)
{
exception
=
e
;
}
if
(
exception
)
{
testFailed
(
evalStr
+
"
threw
exception
"
+
exception
)
;
}
else
{
glErrorShouldBeImpl
(
gl
gl
.
NO_ERROR
false
"
after
evaluating
:
"
+
evalStr
)
;
}
}
;
var
glErrorShouldBe
=
function
(
gl
glErrors
opt_msg
)
{
return
glErrorShouldBeImpl
(
gl
glErrors
true
opt_msg
)
;
}
;
var
glErrorShouldBeImpl
=
function
(
gl
glErrors
reportSuccesses
opt_msg
)
{
if
(
!
glErrors
.
length
)
{
glErrors
=
[
glErrors
]
;
}
opt_msg
=
opt_msg
|
|
"
"
;
var
err
=
gl
.
getError
(
)
;
var
ndx
=
glErrors
.
indexOf
(
err
)
;
var
errStrs
=
[
]
;
for
(
var
ii
=
0
;
ii
<
glErrors
.
length
;
+
+
ii
)
{
errStrs
.
push
(
glEnumToString
(
gl
glErrors
[
ii
]
)
)
;
}
var
expected
=
errStrs
.
join
(
"
or
"
)
;
if
(
ndx
<
0
)
{
var
msg
=
"
getError
expected
"
+
(
(
glErrors
.
length
>
1
)
?
"
one
of
:
"
:
"
:
"
)
;
testFailed
(
msg
+
expected
+
"
.
Was
"
+
glEnumToString
(
gl
err
)
+
"
:
"
+
opt_msg
)
;
}
else
if
(
reportSuccesses
)
{
var
msg
=
"
getError
was
"
+
(
(
glErrors
.
length
>
1
)
?
"
one
of
:
"
:
"
expected
value
:
"
)
;
testPassed
(
msg
+
expected
+
"
:
"
+
opt_msg
)
;
}
return
err
;
}
;
var
linkProgram
=
function
(
gl
program
opt_errorCallback
)
{
var
errFn
=
opt_errorCallback
|
|
testFailed
;
gl
.
linkProgram
(
program
)
;
var
linked
=
gl
.
getProgramParameter
(
program
gl
.
LINK_STATUS
)
;
if
(
!
linked
)
{
var
error
=
gl
.
getProgramInfoLog
(
program
)
;
errFn
(
"
Error
in
program
linking
:
"
+
error
)
;
gl
.
deleteProgram
(
program
)
;
}
}
;
var
loadTextFileAsync
=
function
(
url
callback
)
{
log
(
"
loading
:
"
+
url
)
;
var
error
=
'
loadTextFileAsync
failed
to
load
url
"
'
+
url
+
'
"
'
;
var
request
;
if
(
window
.
XMLHttpRequest
)
{
request
=
new
XMLHttpRequest
(
)
;
if
(
request
.
overrideMimeType
)
{
request
.
overrideMimeType
(
'
text
/
plain
'
)
;
}
}
else
{
throw
'
XMLHttpRequest
is
disabled
'
;
}
try
{
request
.
open
(
'
GET
'
url
true
)
;
request
.
onreadystatechange
=
function
(
)
{
if
(
request
.
readyState
=
=
4
)
{
var
text
=
'
'
;
var
success
=
request
.
status
=
=
200
|
|
request
.
status
=
=
0
;
if
(
success
)
{
text
=
request
.
responseText
;
log
(
"
completed
load
request
:
"
+
url
)
;
}
else
{
log
(
"
loading
"
+
url
+
"
resulted
in
unexpected
status
:
"
+
request
.
status
+
"
"
+
request
.
statusText
)
;
}
callback
(
success
text
)
;
}
}
;
request
.
onerror
=
function
(
errorEvent
)
{
log
(
"
error
occurred
loading
"
+
url
)
;
callback
(
false
'
'
)
;
}
;
request
.
send
(
null
)
;
}
catch
(
err
)
{
log
(
"
failed
to
load
:
"
+
url
+
"
with
exception
"
+
err
.
message
)
;
callback
(
false
'
'
)
;
}
}
;
var
getFileListAsync
=
function
(
url
callback
)
{
var
files
=
[
]
;
var
getFileListImpl
=
function
(
url
callback
)
{
var
files
=
[
]
;
if
(
url
.
substr
(
url
.
length
-
4
)
=
=
'
.
txt
'
)
{
loadTextFileAsync
(
url
function
(
)
{
return
function
(
success
text
)
{
if
(
!
success
)
{
callback
(
false
'
'
)
;
return
;
}
var
lines
=
text
.
split
(
'
\
n
'
)
;
var
prefix
=
'
'
;
var
lastSlash
=
url
.
lastIndexOf
(
'
/
'
)
;
if
(
lastSlash
>
=
0
)
{
prefix
=
url
.
substr
(
0
lastSlash
+
1
)
;
}
var
fail
=
false
;
var
count
=
1
;
var
index
=
0
;
for
(
var
ii
=
0
;
ii
<
lines
.
length
;
+
+
ii
)
{
var
str
=
lines
[
ii
]
.
replace
(
/
^
\
s
\
s
*
/
'
'
)
.
replace
(
/
\
s
\
s
*
/
'
'
)
;
if
(
str
.
length
>
4
&
&
str
[
0
]
!
=
'
#
'
&
&
str
[
0
]
!
=
"
;
"
&
&
str
.
substr
(
0
2
)
!
=
"
/
/
"
)
{
var
names
=
str
.
split
(
/
+
/
)
;
var
new_url
=
prefix
+
str
;
if
(
names
.
length
=
=
1
)
{
new_url
=
prefix
+
str
;
+
+
count
;
getFileListImpl
(
new_url
function
(
index
)
{
return
function
(
success
new_files
)
{
log
(
"
got
files
:
"
+
new_files
.
length
)
;
if
(
success
)
{
files
[
index
]
=
new_files
;
}
finish
(
success
)
;
}
;
}
(
index
+
+
)
)
;
}
else
{
var
s
=
"
"
;
var
p
=
"
"
;
for
(
var
jj
=
0
;
jj
<
names
.
length
;
+
+
jj
)
{
s
+
=
p
+
prefix
+
names
[
jj
]
;
p
=
"
"
;
}
files
[
index
+
+
]
=
s
;
}
}
}
finish
(
true
)
;
function
finish
(
success
)
{
if
(
!
success
)
{
fail
=
true
;
}
-
-
count
;
log
(
"
count
:
"
+
count
)
;
if
(
!
count
)
{
callback
(
!
fail
files
)
;
}
}
}
}
(
)
)
;
}
else
{
files
.
push
(
url
)
;
callback
(
true
files
)
;
}
}
;
getFileListImpl
(
url
function
(
success
files
)
{
var
flat
=
[
]
;
flatten
(
files
)
;
function
flatten
(
files
)
{
for
(
var
ii
=
0
;
ii
<
files
.
length
;
+
+
ii
)
{
var
value
=
files
[
ii
]
;
if
(
typeof
(
value
)
=
=
"
string
"
)
{
flat
.
push
(
value
)
;
}
else
{
flatten
(
value
)
;
}
}
}
callback
(
success
flat
)
;
}
)
;
}
;
var
readFile
=
function
(
file
)
{
var
xhr
=
new
XMLHttpRequest
(
)
;
xhr
.
open
(
"
GET
"
file
false
)
;
xhr
.
overrideMimeType
(
"
text
/
plain
"
)
;
xhr
.
send
(
)
;
return
xhr
.
responseText
.
replace
(
/
\
r
/
g
"
"
)
;
}
;
var
readFileList
=
function
(
url
)
{
var
files
=
[
]
;
if
(
url
.
substr
(
url
.
length
-
4
)
=
=
'
.
txt
'
)
{
var
lines
=
readFile
(
url
)
.
split
(
'
\
n
'
)
;
var
prefix
=
'
'
;
var
lastSlash
=
url
.
lastIndexOf
(
'
/
'
)
;
if
(
lastSlash
>
=
0
)
{
prefix
=
url
.
substr
(
0
lastSlash
+
1
)
;
}
for
(
var
ii
=
0
;
ii
<
lines
.
length
;
+
+
ii
)
{
var
str
=
lines
[
ii
]
.
replace
(
/
^
\
s
\
s
*
/
'
'
)
.
replace
(
/
\
s
\
s
*
/
'
'
)
;
if
(
str
.
length
>
4
&
&
str
[
0
]
!
=
'
#
'
&
&
str
[
0
]
!
=
"
;
"
&
&
str
.
substr
(
0
2
)
!
=
"
/
/
"
)
{
var
names
=
str
.
split
(
/
+
/
)
;
if
(
names
.
length
=
=
1
)
{
var
new_url
=
prefix
+
str
;
files
=
files
.
concat
(
readFileList
(
new_url
)
)
;
}
else
{
var
s
=
"
"
;
var
p
=
"
"
;
for
(
var
jj
=
0
;
jj
<
names
.
length
;
+
+
jj
)
{
s
+
=
p
+
prefix
+
names
[
jj
]
;
p
=
"
"
;
}
files
.
push
(
s
)
;
}
}
}
}
else
{
files
.
push
(
url
)
;
}
return
files
;
}
;
var
loadShader
=
function
(
gl
shaderSource
shaderType
opt_errorCallback
opt_logShaders
opt_shaderLabel
opt_url
opt_skipCompileStatus
)
{
var
errFn
=
opt_errorCallback
|
|
error
;
var
shader
=
gl
.
createShader
(
shaderType
)
;
if
(
shader
=
=
null
)
{
errFn
(
"
*
*
*
Error
:
unable
to
create
shader
'
"
+
shaderSource
+
"
'
"
)
;
return
null
;
}
gl
.
shaderSource
(
shader
shaderSource
)
;
gl
.
compileShader
(
shader
)
;
if
(
opt_logShaders
)
{
var
label
=
shaderType
=
=
gl
.
VERTEX_SHADER
?
'
vertex
shader
'
:
'
fragment_shader
'
;
if
(
opt_shaderLabel
)
{
label
=
opt_shaderLabel
+
'
'
+
label
;
}
addShaderSources
(
gl
document
.
getElementById
(
'
console
'
)
label
shader
shaderSource
opt_url
)
;
}
if
(
!
opt_skipCompileStatus
)
{
var
compiled
=
gl
.
getShaderParameter
(
shader
gl
.
COMPILE_STATUS
)
;
if
(
!
compiled
)
{
lastError
=
gl
.
getShaderInfoLog
(
shader
)
;
errFn
(
"
*
*
*
Error
compiling
"
+
glEnumToString
(
gl
shaderType
)
+
"
'
"
+
shader
+
"
'
:
"
+
lastError
)
;
gl
.
deleteShader
(
shader
)
;
return
null
;
}
}
return
shader
;
}
var
loadShaderFromFile
=
function
(
gl
file
type
opt_errorCallback
opt_logShaders
opt_skipCompileStatus
)
{
var
shaderSource
=
readFile
(
file
)
;
return
loadShader
(
gl
shaderSource
type
opt_errorCallback
opt_logShaders
undefined
file
opt_skipCompileStatus
)
;
}
;
var
loadShaderFromFileAsync
=
function
(
gl
file
type
opt_errorCallback
opt_logShaders
opt_skipCompileStatus
callback
)
{
loadTextFileAsync
(
file
function
(
gl
type
opt_errorCallback
opt_logShaders
file
opt_skipCompileStatus
)
{
return
function
(
success
shaderSource
)
{
if
(
success
)
{
var
shader
=
loadShader
(
gl
shaderSource
type
opt_errorCallback
opt_logShaders
undefined
file
opt_skipCompileStatus
)
;
callback
(
true
shader
)
;
}
else
{
callback
(
false
null
)
;
}
}
}
(
gl
type
opt_errorCallback
opt_logShaders
file
opt_skipCompileStatus
)
)
;
}
;
var
getScript
=
function
(
scriptId
)
{
var
shaderScript
=
document
.
getElementById
(
scriptId
)
;
if
(
!
shaderScript
)
{
throw
(
"
*
*
*
Error
:
unknown
script
element
"
+
scriptId
)
;
}
return
shaderScript
.
text
;
}
;
var
loadShaderFromScript
=
function
(
gl
scriptId
opt_shaderType
opt_errorCallback
opt_logShaders
opt_skipCompileStatus
)
{
var
shaderSource
=
"
"
;
var
shaderScript
=
document
.
getElementById
(
scriptId
)
;
if
(
!
shaderScript
)
{
throw
(
"
*
*
*
Error
:
unknown
script
element
"
+
scriptId
)
;
}
shaderSource
=
shaderScript
.
text
;
if
(
!
opt_shaderType
)
{
if
(
shaderScript
.
type
=
=
"
x
-
shader
/
x
-
vertex
"
)
{
opt_shaderType
=
gl
.
VERTEX_SHADER
;
}
else
if
(
shaderScript
.
type
=
=
"
x
-
shader
/
x
-
fragment
"
)
{
opt_shaderType
=
gl
.
FRAGMENT_SHADER
;
}
else
{
throw
(
"
*
*
*
Error
:
unknown
shader
type
"
)
;
return
null
;
}
}
return
loadShader
(
gl
shaderSource
opt_shaderType
opt_errorCallback
opt_logShaders
undefined
undefined
opt_skipCompileStatus
)
;
}
;
var
loadStandardProgram
=
function
(
gl
)
{
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
loadStandardVertexShader
(
gl
)
)
;
gl
.
attachShader
(
program
loadStandardFragmentShader
(
gl
)
)
;
gl
.
bindAttribLocation
(
program
0
"
a_vertex
"
)
;
gl
.
bindAttribLocation
(
program
1
"
a_normal
"
)
;
linkProgram
(
gl
program
)
;
return
program
;
}
;
var
loadStandardProgramAsync
=
function
(
gl
callback
)
{
loadStandardVertexShaderAsync
(
gl
function
(
gl
)
{
return
function
(
success
vs
)
{
if
(
success
)
{
loadStandardFragmentShaderAsync
(
gl
function
(
vs
)
{
return
function
(
success
fs
)
{
if
(
success
)
{
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
vs
)
;
gl
.
attachShader
(
program
fs
)
;
gl
.
bindAttribLocation
(
program
0
"
a_vertex
"
)
;
gl
.
bindAttribLocation
(
program
1
"
a_normal
"
)
;
linkProgram
(
gl
program
)
;
callback
(
true
program
)
;
}
else
{
callback
(
false
null
)
;
}
}
;
}
(
vs
)
)
;
}
else
{
callback
(
false
null
)
;
}
}
;
}
(
gl
)
)
;
}
;
var
loadProgramFromFile
=
function
(
gl
vertexShaderPath
fragmentShaderPath
opt_errorCallback
)
{
var
program
=
gl
.
createProgram
(
)
;
var
vs
=
loadShaderFromFile
(
gl
vertexShaderPath
gl
.
VERTEX_SHADER
opt_errorCallback
)
;
var
fs
=
loadShaderFromFile
(
gl
fragmentShaderPath
gl
.
FRAGMENT_SHADER
opt_errorCallback
)
;
if
(
vs
&
&
fs
)
{
gl
.
attachShader
(
program
vs
)
;
gl
.
attachShader
(
program
fs
)
;
linkProgram
(
gl
program
opt_errorCallback
)
;
}
if
(
vs
)
{
gl
.
deleteShader
(
vs
)
;
}
if
(
fs
)
{
gl
.
deleteShader
(
fs
)
;
}
return
program
;
}
;
var
loadProgramFromScript
=
function
loadProgramFromScript
(
gl
vertexScriptId
fragmentScriptId
opt_errorCallback
)
{
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
loadShaderFromScript
(
gl
vertexScriptId
gl
.
VERTEX_SHADER
opt_errorCallback
)
)
;
gl
.
attachShader
(
program
loadShaderFromScript
(
gl
fragmentScriptId
gl
.
FRAGMENT_SHADER
opt_errorCallback
)
)
;
linkProgram
(
gl
program
opt_errorCallback
)
;
return
program
;
}
;
var
createProgram
=
function
(
gl
vertexShader
fragmentShader
opt_errorCallback
)
{
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
vertexShader
)
;
gl
.
attachShader
(
program
fragmentShader
)
;
linkProgram
(
gl
program
opt_errorCallback
)
;
return
program
;
}
;
var
loadProgram
=
function
(
gl
vertexShader
fragmentShader
opt_errorCallback
opt_logShaders
)
{
var
program
;
var
vs
=
loadShader
(
gl
vertexShader
gl
.
VERTEX_SHADER
opt_errorCallback
opt_logShaders
)
;
var
fs
=
loadShader
(
gl
fragmentShader
gl
.
FRAGMENT_SHADER
opt_errorCallback
opt_logShaders
)
;
if
(
vs
&
&
fs
)
{
program
=
createProgram
(
gl
vs
fs
opt_errorCallback
)
}
if
(
vs
)
{
gl
.
deleteShader
(
vs
)
;
}
if
(
fs
)
{
gl
.
deleteShader
(
fs
)
;
}
return
program
;
}
;
var
loadProgramFromScriptExpectError
=
function
(
gl
vertexShaderScriptId
fragmentShaderScriptId
)
{
var
vertexShader
=
loadShaderFromScript
(
gl
vertexShaderScriptId
)
;
if
(
!
vertexShader
)
{
return
null
;
}
var
fragmentShader
=
loadShaderFromScript
(
gl
fragmentShaderScriptId
)
;
if
(
!
fragmentShader
)
{
return
null
;
}
var
linkSuccess
=
true
;
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
vertexShader
)
;
gl
.
attachShader
(
program
fragmentShader
)
;
linkSuccess
=
true
;
linkProgram
(
gl
program
function
(
)
{
linkSuccess
=
false
;
}
)
;
return
linkSuccess
?
program
:
null
;
}
;
var
getActiveMap
=
function
(
gl
program
typeInfo
)
{
var
numVariables
=
gl
.
getProgramParameter
(
program
gl
[
typeInfo
.
param
]
)
;
var
variables
=
{
}
;
for
(
var
ii
=
0
;
ii
<
numVariables
;
+
+
ii
)
{
var
info
=
gl
[
typeInfo
.
activeFn
]
(
program
ii
)
;
variables
[
info
.
name
]
=
{
name
:
info
.
name
size
:
info
.
size
type
:
info
.
type
location
:
gl
[
typeInfo
.
locFn
]
(
program
info
.
name
)
}
;
}
return
variables
;
}
;
var
getAttribMap
=
function
(
gl
program
)
{
return
getActiveMap
(
gl
program
{
param
:
"
ACTIVE_ATTRIBUTES
"
activeFn
:
"
getActiveAttrib
"
locFn
:
"
getAttribLocation
"
}
)
;
}
;
var
getUniformMap
=
function
(
gl
program
)
{
return
getActiveMap
(
gl
program
{
param
:
"
ACTIVE_UNIFORMS
"
activeFn
:
"
getActiveUniform
"
locFn
:
"
getUniformLocation
"
}
)
;
}
;
var
basePath
;
var
getResourcePath
=
function
(
)
{
if
(
!
basePath
)
{
var
expectedBase
=
"
js
/
webgl
-
test
-
utils
.
js
"
;
var
scripts
=
document
.
getElementsByTagName
(
'
script
'
)
;
for
(
var
script
i
=
0
;
script
=
scripts
[
i
]
;
i
+
+
)
{
var
src
=
script
.
src
;
var
l
=
src
.
length
;
if
(
src
.
substr
(
l
-
expectedBase
.
length
)
=
=
expectedBase
)
{
basePath
=
src
.
substr
(
0
l
-
expectedBase
.
length
)
;
}
}
}
return
basePath
+
"
resources
/
"
;
}
;
var
loadStandardVertexShader
=
function
(
gl
)
{
return
loadShaderFromFile
(
gl
getResourcePath
(
)
+
"
vertexShader
.
vert
"
gl
.
VERTEX_SHADER
)
;
}
;
var
loadStandardVertexShaderAsync
=
function
(
gl
callback
)
{
loadShaderFromFileAsync
(
gl
getResourcePath
(
)
+
"
vertexShader
.
vert
"
gl
.
VERTEX_SHADER
undefined
undefined
undefined
callback
)
;
}
;
var
loadStandardFragmentShader
=
function
(
gl
)
{
return
loadShaderFromFile
(
gl
getResourcePath
(
)
+
"
fragmentShader
.
frag
"
gl
.
FRAGMENT_SHADER
)
;
}
;
var
loadStandardFragmentShaderAsync
=
function
(
gl
callback
)
{
loadShaderFromFileAsync
(
gl
getResourcePath
(
)
+
"
fragmentShader
.
frag
"
gl
.
FRAGMENT_SHADER
undefined
undefined
undefined
callback
)
;
}
;
var
loadUniformBlockProgram
=
function
(
gl
)
{
var
program
=
gl
.
createProgram
(
)
;
gl
.
attachShader
(
program
loadUniformBlockVertexShader
(
gl
)
)
;
gl
.
attachShader
(
program
loadUniformBlockFragmentShader
(
gl
)
)
;
gl
.
bindAttribLocation
(
program
0
"
a_vertex
"
)
;
gl
.
bindAttribLocation
(
program
1
"
a_normal
"
)
;
linkProgram
(
gl
program
)
;
return
program
;
}
;
var
loadUniformBlockVertexShader
=
function
(
gl
)
{
return
loadShaderFromFile
(
gl
getResourcePath
(
)
+
"
uniformBlockShader
.
vert
"
gl
.
VERTEX_SHADER
)
;
}
;
var
loadUniformBlockFragmentShader
=
function
(
gl
)
{
return
loadShaderFromFile
(
gl
getResourcePath
(
)
+
"
uniformBlockShader
.
frag
"
gl
.
FRAGMENT_SHADER
)
;
}
;
var
loadImageAsync
=
function
(
url
callback
)
{
var
img
=
document
.
createElement
(
'
img
'
)
;
img
.
onload
=
function
(
)
{
callback
(
img
)
;
}
;
img
.
src
=
url
;
}
;
var
loadImagesAsync
=
function
(
urls
callback
)
{
var
count
=
1
;
var
images
=
{
}
;
function
countDown
(
)
{
-
-
count
;
if
(
count
=
=
0
)
{
log
(
"
loadImagesAsync
:
all
images
loaded
"
)
;
callback
(
images
)
;
}
}
function
imageLoaded
(
url
)
{
return
function
(
img
)
{
images
[
url
]
=
img
;
log
(
"
loadImagesAsync
:
loaded
"
+
url
)
;
countDown
(
)
;
}
}
for
(
var
ii
=
0
;
ii
<
urls
.
length
;
+
+
ii
)
{
+
+
count
;
loadImageAsync
(
urls
[
ii
]
imageLoaded
(
urls
[
ii
]
)
)
;
}
countDown
(
)
;
}
;
var
getUrlArguments
=
function
(
)
{
var
args
=
{
}
;
try
{
var
s
=
window
.
location
.
href
;
var
q
=
s
.
indexOf
(
"
?
"
)
;
var
e
=
s
.
indexOf
(
"
#
"
)
;
if
(
e
<
0
)
{
e
=
s
.
length
;
}
var
query
=
s
.
substring
(
q
+
1
e
)
;
var
pairs
=
query
.
split
(
"
&
"
)
;
for
(
var
ii
=
0
;
ii
<
pairs
.
length
;
+
+
ii
)
{
var
keyValue
=
pairs
[
ii
]
.
split
(
"
=
"
)
;
var
key
=
keyValue
[
0
]
;
var
value
=
decodeURIComponent
(
keyValue
[
1
]
)
;
args
[
key
]
=
value
;
}
}
catch
(
e
)
{
throw
"
could
not
parse
url
"
;
}
return
args
;
}
;
var
makeImage
=
function
(
src
onload
onerror
)
{
var
img
=
document
.
createElement
(
'
img
'
)
;
if
(
onload
)
{
img
.
onload
=
onload
;
}
if
(
onerror
)
{
img
.
onerror
=
onerror
;
}
else
{
img
.
onerror
=
function
(
)
{
log
(
"
WARNING
:
creating
image
failed
;
src
:
"
+
this
.
src
)
;
}
;
}
if
(
src
)
{
img
.
src
=
src
;
}
return
img
;
}
var
makeImageFromCanvas
=
function
(
canvas
onload
imageFormat
)
{
return
makeImage
(
canvas
.
toDataURL
(
imageFormat
)
onload
)
;
}
;
var
makeVideo
=
function
(
src
onerror
)
{
var
vid
=
document
.
createElement
(
'
video
'
)
;
if
(
onerror
)
{
vid
.
onerror
=
onerror
;
}
else
{
vid
.
onerror
=
function
(
)
{
log
(
"
WARNING
:
creating
video
failed
;
src
:
"
+
this
.
src
)
;
}
;
}
if
(
src
)
{
vid
.
src
=
src
;
}
return
vid
;
}
var
insertImage
=
function
(
element
caption
img
)
{
var
div
=
document
.
createElement
(
"
div
"
)
;
var
label
=
document
.
createElement
(
"
div
"
)
;
label
.
appendChild
(
document
.
createTextNode
(
caption
)
)
;
div
.
appendChild
(
label
)
;
div
.
appendChild
(
img
)
;
element
.
appendChild
(
div
)
;
}
;
var
addShaderSource
=
function
(
element
label
source
opt_url
)
{
var
div
=
document
.
createElement
(
"
div
"
)
;
var
s
=
document
.
createElement
(
"
pre
"
)
;
s
.
className
=
"
shader
-
source
"
;
s
.
style
.
display
=
"
none
"
;
var
ol
=
document
.
createElement
(
"
ol
"
)
;
var
lines
=
source
.
split
(
"
\
n
"
)
;
for
(
var
ii
=
0
;
ii
<
lines
.
length
;
+
+
ii
)
{
var
line
=
lines
[
ii
]
;
var
li
=
document
.
createElement
(
"
li
"
)
;
li
.
appendChild
(
document
.
createTextNode
(
line
)
)
;
ol
.
appendChild
(
li
)
;
}
s
.
appendChild
(
ol
)
;
var
l
=
document
.
createElement
(
"
a
"
)
;
l
.
href
=
"
show
-
shader
-
source
"
;
l
.
appendChild
(
document
.
createTextNode
(
label
)
)
;
l
.
addEventListener
(
'
click
'
function
(
event
)
{
if
(
event
.
preventDefault
)
{
event
.
preventDefault
(
)
;
}
s
.
style
.
display
=
(
s
.
style
.
display
=
=
'
none
'
)
?
'
block
'
:
'
none
'
;
return
false
;
}
false
)
;
div
.
appendChild
(
l
)
;
if
(
opt_url
)
{
var
u
=
document
.
createElement
(
"
a
"
)
;
u
.
href
=
opt_url
;
div
.
appendChild
(
document
.
createTextNode
(
"
"
)
)
;
u
.
appendChild
(
document
.
createTextNode
(
"
(
"
+
opt_url
+
"
)
"
)
)
;
div
.
appendChild
(
u
)
;
}
div
.
appendChild
(
s
)
;
element
.
appendChild
(
div
)
;
}
;
var
addShaderSources
=
function
(
gl
element
label
shader
shaderSource
opt_url
)
{
addShaderSource
(
element
label
shaderSource
opt_url
)
;
var
debugShaders
=
gl
.
getExtension
(
'
WEBGL_debug_shaders
'
)
;
if
(
debugShaders
&
&
shader
)
{
var
translatedSource
=
debugShaders
.
getTranslatedShaderSource
(
shader
)
;
if
(
translatedSource
!
=
'
'
)
{
addShaderSource
(
element
label
+
'
translated
for
driver
'
translatedSource
)
;
}
}
}
;
var
dumpShadersInfo
=
function
(
gl
url
passMsg
vInfo
fInfo
)
{
var
shaderInfo
=
{
}
;
shaderInfo
.
url
=
url
;
shaderInfo
.
testDescription
=
passMsg
;
shaderInfo
.
vLabel
=
vInfo
.
label
;
shaderInfo
.
vShouldCompile
=
vInfo
.
shaderSuccess
;
shaderInfo
.
vSource
=
vInfo
.
source
;
shaderInfo
.
fLabel
=
fInfo
.
label
;
shaderInfo
.
fShouldCompile
=
fInfo
.
shaderSuccess
;
shaderInfo
.
fSource
=
fInfo
.
source
;
shaderInfo
.
vTranslatedSource
=
null
;
shaderInfo
.
fTranslatedSource
=
null
;
var
debugShaders
=
gl
.
getExtension
(
'
WEBGL_debug_shaders
'
)
;
if
(
debugShaders
)
{
if
(
vInfo
.
shader
)
shaderInfo
.
vTranslatedSource
=
debugShaders
.
getTranslatedShaderSource
(
vInfo
.
shader
)
;
if
(
fInfo
.
shader
)
shaderInfo
.
fTranslatedSource
=
debugShaders
.
getTranslatedShaderSource
(
fInfo
.
shader
)
;
}
var
dumpShaderInfoRequest
=
new
XMLHttpRequest
(
)
;
dumpShaderInfoRequest
.
open
(
'
POST
'
"
/
dumpShaderInfo
"
true
)
;
dumpShaderInfoRequest
.
setRequestHeader
(
"
Content
-
Type
"
"
text
/
plain
"
)
;
dumpShaderInfoRequest
.
send
(
JSON
.
stringify
(
shaderInfo
)
)
;
}
;
var
browserPrefixes
=
[
"
"
"
MOZ_
"
"
OP_
"
"
WEBKIT_
"
]
;
var
getSupportedExtensionWithKnownPrefixes
=
function
(
gl
name
)
{
var
supported
=
gl
.
getSupportedExtensions
(
)
;
for
(
var
ii
=
0
;
ii
<
browserPrefixes
.
length
;
+
+
ii
)
{
var
prefixedName
=
browserPrefixes
[
ii
]
+
name
;
if
(
supported
.
indexOf
(
prefixedName
)
>
=
0
)
{
return
prefixedName
;
}
}
}
;
var
runExtensionSupportedTest
=
function
(
gl
name
extensionEnabled
)
{
var
prefixedName
=
getSupportedExtensionWithKnownPrefixes
(
gl
name
)
;
if
(
prefixedName
!
=
=
undefined
)
{
if
(
extensionEnabled
)
{
testPassed
(
name
+
"
listed
as
supported
and
getExtension
succeeded
"
)
;
}
else
{
testFailed
(
name
+
"
listed
as
supported
but
getExtension
failed
"
)
;
}
}
else
{
if
(
extensionEnabled
)
{
testFailed
(
name
+
"
not
listed
as
supported
but
getExtension
succeeded
"
)
;
}
else
{
testPassed
(
name
+
"
not
listed
as
supported
and
getExtension
failed
-
-
this
is
legal
"
)
;
}
}
}
var
getExtensionWithKnownPrefixes
=
function
(
gl
name
)
{
for
(
var
ii
=
0
;
ii
<
browserPrefixes
.
length
;
+
+
ii
)
{
var
prefixedName
=
browserPrefixes
[
ii
]
+
name
;
var
ext
=
gl
.
getExtension
(
prefixedName
)
;
if
(
ext
)
{
return
ext
;
}
}
}
;
var
getExtensionPrefixedNames
=
function
(
name
)
{
var
unprefix
=
function
(
name
)
{
for
(
var
ii
=
0
;
ii
<
browserPrefixes
.
length
;
+
+
ii
)
{
if
(
browserPrefixes
[
ii
]
.
length
>
0
&
&
name
.
substring
(
0
browserPrefixes
[
ii
]
.
length
)
.
toLowerCase
(
)
=
=
=
browserPrefixes
[
ii
]
.
toLowerCase
(
)
)
{
return
name
.
substring
(
browserPrefixes
[
ii
]
.
length
)
;
}
}
return
name
;
}
var
unprefixed
=
unprefix
(
name
)
;
var
variations
=
[
]
;
for
(
var
ii
=
0
;
ii
<
browserPrefixes
.
length
;
+
+
ii
)
{
variations
.
push
(
browserPrefixes
[
ii
]
+
unprefixed
)
;
}
return
variations
;
}
;
var
replaceRE
=
/
\
\
(
(
\
w
+
)
\
)
/
g
;
var
replaceParams
=
function
(
str
)
{
var
args
=
arguments
;
return
str
.
replace
(
replaceRE
function
(
str
p1
offset
s
)
{
for
(
var
ii
=
1
;
ii
<
args
.
length
;
+
+
ii
)
{
if
(
args
[
ii
]
[
p1
]
!
=
=
undefined
)
{
return
args
[
ii
]
[
p1
]
;
}
}
throw
"
unknown
string
param
'
"
+
p1
+
"
'
"
;
}
)
;
}
;
var
upperCaseFirstLetter
=
function
(
str
)
{
return
str
.
substring
(
0
1
)
.
toUpperCase
(
)
+
str
.
substring
(
1
)
;
}
;
var
propertyPrefixes
=
[
"
"
"
moz
"
"
ms
"
"
o
"
"
webkit
"
]
;
var
getPrefixedProperty
=
function
(
obj
propertyName
)
{
for
(
var
ii
=
0
;
ii
<
propertyPrefixes
.
length
;
+
+
ii
)
{
var
prefix
=
propertyPrefixes
[
ii
]
;
var
name
=
prefix
+
propertyName
;
log
(
name
)
;
var
property
=
obj
[
name
]
;
if
(
property
)
{
return
property
;
}
if
(
ii
=
=
0
)
{
propertyName
=
upperCaseFirstLetter
(
propertyName
)
;
}
}
return
undefined
;
}
;
var
_requestAnimFrame
;
var
requestAnimFrame
=
function
(
callback
)
{
if
(
!
_requestAnimFrame
)
{
_requestAnimFrame
=
getPrefixedProperty
(
window
"
requestAnimationFrame
"
)
|
|
function
(
callback
element
)
{
return
window
.
setTimeout
(
callback
1000
/
70
)
;
}
;
}
_requestAnimFrame
.
call
(
window
callback
)
;
}
;
var
_cancelAnimFrame
;
var
cancelAnimFrame
=
function
(
request
)
{
if
(
!
_cancelAnimFrame
)
{
_cancelAnimFrame
=
getPrefixedProperty
(
window
"
cancelAnimationFrame
"
)
|
|
window
.
clearTimeout
;
}
_cancelAnimFrame
.
call
(
window
request
)
;
}
;
var
requestFullScreen
=
function
(
element
)
{
var
fn
=
getPrefixedProperty
(
element
"
requestFullScreen
"
)
;
if
(
fn
)
{
fn
.
call
(
element
)
;
}
}
;
var
cancelFullScreen
=
function
(
)
{
var
fn
=
getPrefixedProperty
(
document
"
cancelFullScreen
"
)
;
if
(
fn
)
{
fn
.
call
(
document
)
;
}
}
;
var
fullScreenStateName
;
(
function
(
)
{
var
fullScreenStateNames
=
[
"
isFullScreen
"
"
fullScreen
"
]
;
for
(
var
ii
=
0
;
ii
<
fullScreenStateNames
.
length
;
+
+
ii
)
{
var
propertyName
=
fullScreenStateNames
[
ii
]
;
for
(
var
jj
=
0
;
jj
<
propertyPrefixes
.
length
;
+
+
jj
)
{
var
prefix
=
propertyPrefixes
[
jj
]
;
if
(
prefix
.
length
)
{
propertyName
=
upperCaseFirstLetter
(
propertyName
)
;
fullScreenStateName
=
prefix
+
propertyName
;
if
(
document
[
fullScreenStateName
]
!
=
=
undefined
)
{
return
;
}
}
}
fullScreenStateName
=
undefined
;
}
}
(
)
)
;
var
getFullScreenState
=
function
(
)
{
log
(
"
fullscreenstatename
:
"
+
fullScreenStateName
)
;
log
(
document
[
fullScreenStateName
]
)
;
return
document
[
fullScreenStateName
]
;
}
;
var
onFullScreenChange
=
function
(
element
callback
)
{
propertyPrefixes
.
forEach
(
function
(
prefix
)
{
var
eventName
=
prefix
+
"
fullscreenchange
"
;
log
(
"
addevent
:
"
+
eventName
)
;
document
.
addEventListener
(
eventName
function
(
event
)
{
log
(
"
event
:
"
+
eventName
)
;
callback
(
getFullScreenState
(
)
)
;
}
)
;
}
)
;
}
;
var
setupFullscreen
=
function
(
buttonId
fullscreenId
callback
)
{
if
(
!
fullScreenStateName
)
{
return
false
;
}
var
fullscreenElement
=
document
.
getElementById
(
fullscreenId
)
;
onFullScreenChange
(
fullscreenElement
callback
)
;
var
toggleFullScreen
=
function
(
event
)
{
if
(
getFullScreenState
(
)
)
{
cancelFullScreen
(
fullscreenElement
)
;
}
else
{
requestFullScreen
(
fullscreenElement
)
;
}
event
.
preventDefault
(
)
;
return
false
;
}
;
var
buttonElement
=
document
.
getElementById
(
buttonId
)
;
buttonElement
.
addEventListener
(
'
click
'
toggleFullScreen
)
;
return
true
;
}
;
var
waitForComposite
=
function
(
callback
)
{
var
frames
=
5
;
var
countDown
=
function
(
)
{
if
(
frames
=
=
0
)
{
callback
(
)
;
}
else
{
-
-
frames
;
requestAnimFrame
.
call
(
window
countDown
)
;
}
}
;
countDown
(
)
;
}
;
var
setZeroTimeout
=
(
function
(
)
{
var
timeouts
=
[
]
;
var
messageName
=
"
zero
-
timeout
-
message
"
;
function
setZeroTimeout
(
fn
)
{
timeouts
.
push
(
fn
)
;
window
.
postMessage
(
messageName
"
*
"
)
;
}
function
handleMessage
(
event
)
{
if
(
event
.
source
=
=
window
&
&
event
.
data
=
=
messageName
)
{
event
.
stopPropagation
(
)
;
if
(
timeouts
.
length
>
0
)
{
var
fn
=
timeouts
.
shift
(
)
;
fn
(
)
;
}
}
}
window
.
addEventListener
(
"
message
"
handleMessage
true
)
;
return
setZeroTimeout
;
}
)
(
)
;
var
runSteps
=
function
(
steps
)
{
if
(
!
steps
.
length
)
{
return
;
}
var
stepsToRun
=
steps
.
slice
(
)
;
var
currentStep
=
0
;
var
runNextStep
=
function
(
)
{
stepsToRun
[
currentStep
+
+
]
(
)
;
if
(
currentStep
<
stepsToRun
.
length
)
{
setTimeout
(
runNextStep
1
)
;
}
}
;
runNextStep
(
)
;
}
;
var
startPlayingAndWaitForVideo
=
function
(
video
callback
)
{
var
timeWatcher
=
function
(
)
{
if
(
video
.
currentTime
>
0
)
{
callback
(
video
)
;
}
else
{
requestAnimFrame
.
call
(
window
timeWatcher
)
;
}
}
;
requestAnimFrame
.
call
(
window
timeWatcher
)
;
video
.
loop
=
true
;
video
.
play
(
)
;
}
;
var
getHost
=
function
(
url
)
{
url
=
url
.
replace
(
"
\
\
"
"
/
"
)
;
var
pos
=
url
.
indexOf
(
"
:
/
/
"
)
;
if
(
pos
>
=
0
)
{
url
=
url
.
substr
(
pos
+
3
)
;
}
var
parts
=
url
.
split
(
'
/
'
)
;
return
parts
[
0
]
;
}
var
getBaseDomain
=
function
(
host
)
{
var
parts
=
host
.
split
(
"
:
"
)
;
var
hostname
=
parts
[
0
]
;
var
port
=
parts
[
1
]
|
|
"
80
"
;
parts
=
hostname
.
split
(
"
.
"
)
;
if
(
parts
.
length
<
2
)
return
hostname
+
"
:
"
+
port
;
var
tld
=
parts
[
parts
.
length
-
1
]
;
var
domain
=
parts
[
parts
.
length
-
2
]
;
return
domain
+
"
.
"
+
tld
+
"
:
"
+
port
;
}
var
runningOnLocalhost
=
function
(
)
{
return
window
.
location
.
hostname
.
indexOf
(
"
localhost
"
)
!
=
-
1
|
|
window
.
location
.
hostname
.
indexOf
(
"
127
.
0
.
0
.
1
"
)
!
=
-
1
;
}
var
getLocalCrossOrigin
=
function
(
)
{
var
domain
;
if
(
window
.
location
.
host
.
indexOf
(
"
localhost
"
)
!
=
-
1
)
{
domain
=
"
127
.
0
.
0
.
1
"
;
}
else
{
domain
=
"
localhost
"
;
}
var
port
=
window
.
location
.
port
|
|
"
80
"
;
return
window
.
location
.
protocol
+
"
/
/
"
+
domain
+
"
:
"
+
port
}
var
getRelativePath
=
function
(
path
)
{
var
relparts
=
window
.
location
.
pathname
.
split
(
"
/
"
)
;
relparts
.
pop
(
)
;
var
pathparts
=
path
.
split
(
"
/
"
)
;
var
i
;
for
(
i
=
0
;
i
<
pathparts
.
length
;
+
+
i
)
{
switch
(
pathparts
[
i
]
)
{
case
"
"
:
break
;
case
"
.
"
:
break
;
case
"
.
.
"
:
relparts
.
pop
(
)
;
break
;
default
:
relparts
.
push
(
pathparts
[
i
]
)
;
break
;
}
}
return
relparts
.
join
(
"
/
"
)
;
}
var
setupImageForCrossOriginTest
=
function
(
img
imgUrl
localUrl
callback
)
{
window
.
addEventListener
(
"
load
"
function
(
)
{
if
(
typeof
(
img
)
=
=
"
string
"
)
img
=
document
.
querySelector
(
img
)
;
if
(
!
img
)
img
=
new
Image
(
)
;
img
.
addEventListener
(
"
load
"
callback
false
)
;
img
.
addEventListener
(
"
error
"
callback
false
)
;
if
(
runningOnLocalhost
(
)
)
img
.
src
=
getLocalCrossOrigin
(
)
+
getRelativePath
(
localUrl
)
;
else
img
.
src
=
getUrlOptions
(
)
.
imgUrl
|
|
imgUrl
;
}
false
)
;
}
var
sRGBToLinear
=
function
(
color
)
{
return
[
sRGBChannelToLinear
(
color
[
0
]
)
sRGBChannelToLinear
(
color
[
1
]
)
sRGBChannelToLinear
(
color
[
2
]
)
color
[
3
]
]
}
var
linearToSRGB
=
function
(
color
)
{
return
[
linearChannelToSRGB
(
color
[
0
]
)
linearChannelToSRGB
(
color
[
1
]
)
linearChannelToSRGB
(
color
[
2
]
)
color
[
3
]
]
}
function
sRGBChannelToLinear
(
value
)
{
value
=
value
/
255
;
if
(
value
<
=
0
.
04045
)
value
=
value
/
12
.
92
;
else
value
=
Math
.
pow
(
(
value
+
0
.
055
)
/
1
.
055
2
.
4
)
;
return
Math
.
trunc
(
value
*
255
+
0
.
5
)
;
}
function
linearChannelToSRGB
(
value
)
{
value
=
value
/
255
;
if
(
value
<
=
0
.
0
)
{
value
=
0
.
0
;
}
else
if
(
value
<
0
.
0031308
)
{
value
=
value
*
12
.
92
;
}
else
if
(
value
<
1
)
{
value
=
Math
.
pow
(
value
0
.
41666
)
*
1
.
055
-
0
.
055
;
}
else
{
value
=
1
.
0
;
}
return
Math
.
trunc
(
value
*
255
+
0
.
5
)
;
}
function
comparePixels
(
cmp
ref
tolerance
diff
)
{
if
(
cmp
.
length
!
=
ref
.
length
)
{
testFailed
(
"
invalid
pixel
size
.
"
)
;
}
var
count
=
0
;
for
(
var
i
=
0
;
i
<
cmp
.
length
;
i
+
+
)
{
if
(
diff
)
{
diff
[
i
*
4
]
=
0
;
diff
[
i
*
4
+
1
]
=
255
;
diff
[
i
*
4
+
2
]
=
0
;
diff
[
i
*
4
+
3
]
=
255
;
}
if
(
Math
.
abs
(
cmp
[
i
*
4
]
-
ref
[
i
*
4
]
)
>
tolerance
|
|
Math
.
abs
(
cmp
[
i
*
4
+
1
]
-
ref
[
i
*
4
+
1
]
)
>
tolerance
|
|
Math
.
abs
(
cmp
[
i
*
4
+
2
]
-
ref
[
i
*
4
+
2
]
)
>
tolerance
|
|
Math
.
abs
(
cmp
[
i
*
4
+
3
]
-
ref
[
i
*
4
+
3
]
)
>
tolerance
)
{
if
(
count
<
10
)
{
testFailed
(
"
Pixel
"
+
i
+
"
:
expected
(
"
+
[
ref
[
i
*
4
]
ref
[
i
*
4
+
1
]
ref
[
i
*
4
+
2
]
ref
[
i
*
4
+
3
]
]
+
"
)
got
(
"
+
[
cmp
[
i
*
4
]
cmp
[
i
*
4
+
1
]
cmp
[
i
*
4
+
2
]
cmp
[
i
*
4
+
3
]
]
+
"
)
"
)
;
}
count
+
+
;
if
(
diff
)
{
diff
[
i
*
4
]
=
255
;
diff
[
i
*
4
+
1
]
=
0
;
}
}
}
return
count
;
}
function
displayImageDiff
(
cmp
ref
diff
width
height
)
{
var
div
=
document
.
createElement
(
"
div
"
)
;
var
cmpImg
=
createImageFromPixel
(
cmp
width
height
)
;
var
refImg
=
createImageFromPixel
(
ref
width
height
)
;
var
diffImg
=
createImageFromPixel
(
diff
width
height
)
;
wtu
.
insertImage
(
div
"
Reference
"
refImg
)
;
wtu
.
insertImage
(
div
"
Result
"
cmpImg
)
;
wtu
.
insertImage
(
div
"
Difference
"
diffImg
)
;
var
console
=
document
.
getElementById
(
"
console
"
)
;
console
.
appendChild
(
div
)
;
}
function
createImageFromPixel
(
buf
width
height
)
{
var
canvas
=
document
.
createElement
(
"
canvas
"
)
;
canvas
.
width
=
width
;
canvas
.
height
=
height
;
var
ctx
=
canvas
.
getContext
(
"
2d
"
)
;
var
imgData
=
ctx
.
getImageData
(
0
0
width
height
)
;
for
(
var
i
=
0
;
i
<
buf
.
length
;
i
+
+
)
imgData
.
data
[
i
]
=
buf
[
i
]
;
ctx
.
putImageData
(
imgData
0
0
)
;
var
img
=
wtu
.
makeImageFromCanvas
(
canvas
)
;
return
img
;
}
var
API
=
{
addShaderSource
:
addShaderSource
addShaderSources
:
addShaderSources
cancelAnimFrame
:
cancelAnimFrame
create3DContext
:
create3DContext
GLErrorException
:
GLErrorException
create3DContextWithWrapperThatThrowsOnGLError
:
create3DContextWithWrapperThatThrowsOnGLError
checkAreaInAndOut
:
checkAreaInAndOut
checkCanvas
:
checkCanvas
checkCanvasRect
:
checkCanvasRect
checkCanvasRectColor
:
checkCanvasRectColor
checkCanvasRects
:
checkCanvasRects
checkFloatBuffer
:
checkFloatBuffer
checkTextureSize
:
checkTextureSize
clipToRange
:
clipToRange
createColoredTexture
:
createColoredTexture
createProgram
:
createProgram
clearAndDrawUnitQuad
:
clearAndDrawUnitQuad
clearAndDrawIndexedQuad
:
clearAndDrawIndexedQuad
comparePixels
:
comparePixels
dispatchTask
:
setZeroTimeout
displayImageDiff
:
displayImageDiff
drawUnitQuad
:
drawUnitQuad
drawIndexedQuad
:
drawIndexedQuad
drawUByteColorQuad
:
drawUByteColorQuad
drawFloatColorQuad
:
drawFloatColorQuad
dummySetProgramAndDrawNothing
:
dummySetProgramAndDrawNothing
dumpShadersInfo
:
dumpShadersInfo
endsWith
:
endsWith
failIfGLError
:
failIfGLError
fillTexture
:
fillTexture
getBytesPerComponent
:
getBytesPerComponent
getDefault3DContextVersion
:
getDefault3DContextVersion
getExtensionPrefixedNames
:
getExtensionPrefixedNames
getExtensionWithKnownPrefixes
:
getExtensionWithKnownPrefixes
getFileListAsync
:
getFileListAsync
getLastError
:
getLastError
getPrefixedProperty
:
getPrefixedProperty
getScript
:
getScript
getSupportedExtensionWithKnownPrefixes
:
getSupportedExtensionWithKnownPrefixes
getTypedArrayElementsPerPixel
:
getTypedArrayElementsPerPixel
getUrlArguments
:
getUrlArguments
getUrlOptions
:
getUrlOptions
getAttribMap
:
getAttribMap
getUniformMap
:
getUniformMap
glEnumToString
:
glEnumToString
glErrorShouldBe
:
glErrorShouldBe
glTypeToTypedArrayType
:
glTypeToTypedArrayType
hasAttributeCaseInsensitive
:
hasAttributeCaseInsensitive
insertImage
:
insertImage
loadImageAsync
:
loadImageAsync
loadImagesAsync
:
loadImagesAsync
loadProgram
:
loadProgram
loadProgramFromFile
:
loadProgramFromFile
loadProgramFromScript
:
loadProgramFromScript
loadProgramFromScriptExpectError
:
loadProgramFromScriptExpectError
loadShader
:
loadShader
loadShaderFromFile
:
loadShaderFromFile
loadShaderFromScript
:
loadShaderFromScript
loadStandardProgram
:
loadStandardProgram
loadStandardProgramAsync
:
loadStandardProgramAsync
loadStandardVertexShader
:
loadStandardVertexShader
loadStandardVertexShaderAsync
:
loadStandardVertexShaderAsync
loadStandardFragmentShader
:
loadStandardFragmentShader
loadStandardFragmentShaderAsync
:
loadStandardFragmentShaderAsync
loadUniformBlockProgram
:
loadUniformBlockProgram
loadUniformBlockVertexShader
:
loadUniformBlockVertexShader
loadUniformBlockFragmentShader
:
loadUniformBlockFragmentShader
loadTextFileAsync
:
loadTextFileAsync
loadTexture
:
loadTexture
log
:
log
loggingOff
:
loggingOff
makeCheckRect
:
makeCheckRect
makeImage
:
makeImage
makeImageFromCanvas
:
makeImageFromCanvas
makeVideo
:
makeVideo
error
:
error
runExtensionSupportedTest
:
runExtensionSupportedTest
shallowCopyObject
:
shallowCopyObject
setDefault3DContextVersion
:
setDefault3DContextVersion
setupColorQuad
:
setupColorQuad
setupProgram
:
setupProgram
setupTransformFeedbackProgram
:
setupTransformFeedbackProgram
setupQuad
:
setupQuad
setupQuadWithTexCoords
:
setupQuadWithTexCoords
setupIndexedQuad
:
setupIndexedQuad
setupIndexedQuadWithOptions
:
setupIndexedQuadWithOptions
setupSimpleColorProgram
:
setupSimpleColorProgram
setupSimpleTextureProgram
:
setupSimpleTextureProgram
setupSimpleCubeMapTextureProgram
:
setupSimpleCubeMapTextureProgram
setupSimpleVertexColorProgram
:
setupSimpleVertexColorProgram
setupNoTexCoordTextureProgram
:
setupNoTexCoordTextureProgram
setupTexturedQuad
:
setupTexturedQuad
setupTexturedQuadWithTexCoords
:
setupTexturedQuadWithTexCoords
setupTexturedQuadWithCubeMap
:
setupTexturedQuadWithCubeMap
setupUnitQuad
:
setupUnitQuad
setFloatDrawColor
:
setFloatDrawColor
setUByteDrawColor
:
setUByteDrawColor
startPlayingAndWaitForVideo
:
startPlayingAndWaitForVideo
startsWith
:
startsWith
shouldGenerateGLError
:
shouldGenerateGLError
readFile
:
readFile
readFileList
:
readFileList
replaceParams
:
replaceParams
requestAnimFrame
:
requestAnimFrame
runSteps
:
runSteps
waitForComposite
:
waitForComposite
setupFullscreen
:
setupFullscreen
sRGBToLinear
:
sRGBToLinear
linearToSRGB
:
linearToSRGB
getHost
:
getHost
getBaseDomain
:
getBaseDomain
runningOnLocalhost
:
runningOnLocalhost
getLocalCrossOrigin
:
getLocalCrossOrigin
getRelativePath
:
getRelativePath
setupImageForCrossOriginTest
:
setupImageForCrossOriginTest
none
:
false
}
;
Object
.
defineProperties
(
API
{
noTexCoordTextureVertexShader
:
{
value
:
noTexCoordTextureVertexShader
writable
:
false
}
simpleTextureVertexShader
:
{
value
:
simpleTextureVertexShader
writable
:
false
}
simpleColorFragmentShader
:
{
value
:
simpleColorFragmentShader
writable
:
false
}
simpleColorFragmentShaderESSL300
:
{
value
:
simpleColorFragmentShaderESSL300
writable
:
false
}
simpleVertexShader
:
{
value
:
simpleVertexShader
writable
:
false
}
simpleVertexShaderESSL300
:
{
value
:
simpleVertexShaderESSL300
writable
:
false
}
simpleTextureFragmentShader
:
{
value
:
simpleTextureFragmentShader
writable
:
false
}
simpleCubeMapTextureFragmentShader
:
{
value
:
simpleCubeMapTextureFragmentShader
writable
:
false
}
simpleVertexColorFragmentShader
:
{
value
:
simpleVertexColorFragmentShader
writable
:
false
}
simpleVertexColorVertexShader
:
{
value
:
simpleVertexColorVertexShader
writable
:
false
}
}
)
;
return
API
;
}
(
)
)
;
