'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsShaderExecUtil
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuMatrix
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuMatrixUtil
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluDrawUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluVarType
'
)
;
goog
.
scope
(
function
(
)
{
var
glsShaderExecUtil
=
modules
.
shared
.
glsShaderExecUtil
;
var
gluVarType
=
framework
.
opengl
.
gluVarType
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
gluDrawUtil
=
framework
.
opengl
.
gluDrawUtil
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuMatrix
=
framework
.
common
.
tcuMatrix
;
var
tcuMatrixUtil
=
framework
.
common
.
tcuMatrixUtil
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
var
setParentClass
=
function
(
child
parent
)
{
child
.
prototype
=
Object
.
create
(
parent
.
prototype
)
;
child
.
prototype
.
constructor
=
child
;
}
;
glsShaderExecUtil
.
Symbol
=
function
(
name
varType
)
{
name
=
name
=
=
=
undefined
?
'
<
unnamed
>
'
:
name
;
this
.
name
=
name
;
this
.
varType
=
varType
|
|
null
;
}
;
glsShaderExecUtil
.
ShaderSpec
=
function
(
)
{
this
.
version
=
gluShaderUtil
.
GLSLVersion
.
V300_ES
;
this
.
inputs
=
[
]
;
this
.
outputs
=
[
]
;
this
.
globalDeclarations
=
'
'
;
this
.
source
;
}
;
glsShaderExecUtil
.
ShaderExecutor
=
function
(
shaderSpec
)
{
this
.
m_inputs
=
shaderSpec
.
inputs
;
this
.
m_outputs
=
shaderSpec
.
outputs
;
}
;
glsShaderExecUtil
.
ShaderExecutor
.
prototype
.
useProgram
=
function
(
)
{
DE_ASSERT
(
this
.
isOk
)
;
gl
.
useProgram
(
this
.
getProgram
(
)
)
;
}
;
glsShaderExecUtil
.
ShaderExecutor
.
prototype
.
isOk
=
function
(
)
{
throw
new
Error
(
'
Virtual
function
.
Please
override
.
'
)
;
}
;
glsShaderExecUtil
.
ShaderExecutor
.
prototype
.
getProgram
=
function
(
)
{
throw
new
Error
(
'
Virtual
function
.
Please
override
.
'
)
;
}
;
glsShaderExecUtil
.
ShaderExecutor
.
prototype
.
execute
=
function
(
numValues
inputs
)
{
throw
new
Error
(
'
Virtual
function
.
Please
override
.
'
)
;
}
;
glsShaderExecUtil
.
createExecutor
=
function
(
shaderType
shaderSpec
)
{
switch
(
shaderType
)
{
case
gluShaderProgram
.
shaderType
.
VERTEX
:
return
new
glsShaderExecUtil
.
VertexShaderExecutor
(
shaderSpec
)
;
case
gluShaderProgram
.
shaderType
.
FRAGMENT
:
return
new
glsShaderExecUtil
.
FragmentShaderExecutor
(
shaderSpec
)
;
default
:
throw
new
Error
(
'
Unsupported
shader
type
:
'
+
shaderType
)
;
}
}
;
glsShaderExecUtil
.
generateVertexShader
=
function
(
shaderSpec
)
{
var
usesInout
=
true
;
var
in_
=
usesInout
?
'
in
'
:
'
attribute
'
;
var
out
=
usesInout
?
'
out
'
:
'
varying
'
;
var
src
=
'
'
;
var
vecSize
;
var
intBaseType
;
src
+
=
'
#
version
300
es
\
n
'
;
if
(
shaderSpec
.
globalDeclarations
.
length
>
0
)
src
+
=
(
shaderSpec
.
globalDeclarations
+
'
\
n
'
)
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
inputs
.
length
;
+
+
i
)
src
+
=
(
in_
+
'
'
+
gluVarType
.
declareVariable
(
shaderSpec
.
inputs
[
i
]
.
varType
shaderSpec
.
inputs
[
i
]
.
name
)
+
'
;
\
n
'
)
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
outputs
.
length
;
i
+
+
)
{
var
output
=
shaderSpec
.
outputs
[
i
]
;
DE_ASSERT
(
output
.
varType
.
isBasicType
(
)
)
;
if
(
gluShaderUtil
.
isDataTypeBoolOrBVec
(
output
.
varType
.
getBasicType
(
)
)
)
{
vecSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
output
.
varType
.
getBasicType
(
)
)
;
intBaseType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeVector
(
gluShaderUtil
.
DataType
.
INT
vecSize
)
:
gluShaderUtil
.
DataType
.
INT
;
var
intType
=
new
gluVarType
.
VarType
(
)
.
VarTypeBasic
(
intBaseType
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
src
+
=
(
'
flat
'
+
out
+
'
'
+
gluVarType
.
declareVariable
(
intType
'
o_
'
+
output
.
name
)
+
'
;
\
n
'
)
;
}
else
src
+
=
(
'
flat
'
+
out
+
'
'
+
gluVarType
.
declareVariable
(
output
.
varType
output
.
name
)
+
'
;
\
n
'
)
;
}
src
+
=
'
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
vec4
(
0
.
0
)
;
\
n
'
+
'
gl_PointSize
=
1
.
0
;
\
n
\
n
'
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
outputs
.
length
;
i
+
+
)
{
if
(
gluShaderUtil
.
isDataTypeBoolOrBVec
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
)
src
+
=
(
'
\
t
'
+
gluVarType
.
declareVariable
(
shaderSpec
.
outputs
[
i
]
.
varType
shaderSpec
.
outputs
[
i
]
.
name
)
+
'
;
\
n
'
)
;
}
src
+
=
shaderSpec
.
source
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
outputs
.
length
;
i
+
+
)
{
if
(
gluShaderUtil
.
isDataTypeBoolOrBVec
(
output
.
varType
.
getBasicType
(
)
)
)
{
vecSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
output
.
varType
.
getBasicType
(
)
)
;
intBaseType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeVector
(
gluShaderUtil
.
DataType
.
INT
vecSize
)
:
gluShaderUtil
.
DataType
.
INT
;
src
+
=
(
'
\
to_
'
+
output
.
name
+
'
=
'
+
gluShaderUtil
.
getDataTypeName
(
intBaseType
)
+
'
(
'
+
output
.
name
+
'
)
;
\
n
'
)
;
}
}
src
+
=
'
}
\
n
'
;
return
src
;
}
;
glsShaderExecUtil
.
generateEmptyFragmentSource
=
function
(
)
{
var
customOut
=
true
;
var
src
;
src
=
'
#
version
300
es
\
n
'
;
src
+
=
'
void
main
(
void
)
\
n
{
\
n
'
;
if
(
!
customOut
)
src
+
=
'
gl
.
FragColor
=
vec4
(
0
.
0
)
;
\
n
'
;
src
+
=
'
}
\
n
'
;
return
src
;
}
;
glsShaderExecUtil
.
generatePassthroughVertexShader
=
function
(
shaderSpec
inputPrefix
outputPrefix
)
{
var
src
;
src
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
inputs
.
length
;
i
+
+
)
{
src
+
=
(
'
in
'
+
gluVarType
.
declareVariable
(
shaderSpec
.
inputs
[
i
]
.
varType
inputPrefix
+
shaderSpec
.
inputs
[
i
]
.
name
)
+
'
;
\
n
'
+
'
flat
out
'
+
gluVarType
.
declareVariable
(
shaderSpec
.
inputs
[
i
]
.
varType
outputPrefix
+
shaderSpec
.
inputs
[
i
]
.
name
)
+
'
;
\
n
'
)
;
}
src
+
=
'
\
nvoid
main
(
void
)
\
n
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
gl_PointSize
=
1
.
0
;
\
n
'
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
inputs
.
length
;
i
+
+
)
src
+
=
(
'
\
t
'
+
outputPrefix
+
shaderSpec
.
inputs
[
i
]
.
name
+
'
=
'
+
inputPrefix
+
shaderSpec
.
inputs
[
i
]
.
name
+
'
;
\
n
'
)
;
src
+
=
'
}
\
n
'
;
return
src
;
}
;
glsShaderExecUtil
.
generateFragmentShader
=
function
(
shaderSpec
useIntOutputs
outLocationMap
)
{
var
vecSize
;
var
numVecs
;
var
intBasicType
;
var
uintBasicType
;
var
uintType
;
var
intType
;
var
src
;
src
=
'
#
version
300
es
\
n
'
;
if
(
!
shaderSpec
.
globalDeclarations
.
length
>
0
)
src
+
=
(
shaderSpec
.
globalDeclarations
+
'
\
n
'
)
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
inputs
.
length
;
i
+
+
)
src
+
=
(
'
flat
in
'
+
gluVarType
.
declareVariable
(
shaderSpec
.
inputs
[
i
]
.
varType
shaderSpec
.
inputs
[
i
]
.
name
)
+
'
;
\
n
'
)
;
for
(
var
outNdx
=
0
;
outNdx
<
shaderSpec
.
outputs
.
length
;
+
+
outNdx
)
{
var
output
=
shaderSpec
.
outputs
[
outNdx
]
;
var
location
=
outLocationMap
[
output
.
name
]
;
var
outVarName
=
'
o_
'
+
output
.
name
;
var
decl
=
new
gluVarType
.
VariableDeclaration
(
output
.
varType
outVarName
gluVarType
.
Storage
.
STORAGE_OUT
undefined
new
gluVarType
.
Layout
(
location
)
)
;
DE_ASSERT
(
output
.
varType
.
isBasicType
(
)
)
;
if
(
useIntOutputs
&
&
gluShaderUtil
.
isDataTypeFloatOrVec
(
output
.
varType
.
getBasicType
(
)
)
)
{
vecSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
output
.
varType
.
getBasicType
(
)
)
;
uintBasicType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeVector
(
gluShaderUtil
.
DataType
.
UINT
vecSize
)
:
gluShaderUtil
.
DataType
.
UINT
;
uintType
=
gluVarType
.
newTypeBasic
(
uintBasicType
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
decl
.
varType
=
uintType
;
src
+
=
(
decl
+
'
;
\
n
'
)
;
}
else
if
(
gluShaderUtil
.
isDataTypeBoolOrBVec
(
output
.
varType
.
getBasicType
(
)
)
)
{
vecSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
output
.
varType
.
getBasicType
(
)
)
;
intBasicType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeVector
(
gluShaderUtil
.
DataType
.
INT
vecSize
)
:
gluShaderUtil
.
DataType
.
INT
;
intType
=
gluVarType
.
newTypeBasic
(
intBasicType
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
decl
.
varType
=
intType
;
src
+
=
(
decl
+
'
;
\
n
'
)
;
}
else
if
(
gluShaderUtil
.
isDataTypeMatrix
(
output
.
varType
.
getBasicType
(
)
)
)
{
vecSize
=
gluShaderUtil
.
getDataTypeMatrixNumRows
(
output
.
varType
.
getBasicType
(
)
)
;
numVecs
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
output
.
varType
.
getBasicType
(
)
)
;
uintBasicType
=
gluShaderUtil
.
getDataTypeVector
(
gluShaderUtil
.
DataType
.
UINT
vecSize
)
;
uintType
=
gluVarType
.
newTypeBasic
(
uintBasicType
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
decl
.
varType
=
uintType
;
for
(
var
vecNdx
=
0
;
vecNdx
<
numVecs
;
+
+
vecNdx
)
{
decl
.
name
=
outVarName
+
'
_
'
+
(
vecNdx
)
;
decl
.
layout
.
location
=
location
+
vecNdx
;
src
+
=
(
decl
+
'
;
\
n
'
)
;
}
}
else
src
+
=
new
gluVarType
.
VariableDeclaration
(
output
.
varType
output
.
name
gluVarType
.
Storage
.
STORAGE_OUT
undefined
new
gluVarType
.
Layout
(
location
)
)
+
'
;
\
n
'
;
}
src
+
=
'
\
nvoid
main
(
void
)
\
n
{
\
n
'
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
outputs
.
length
;
i
+
+
)
{
if
(
(
useIntOutputs
&
&
gluShaderUtil
.
isDataTypeFloatOrVec
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
)
|
|
gluShaderUtil
.
isDataTypeBoolOrBVec
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
|
|
gluShaderUtil
.
isDataTypeMatrix
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
)
src
+
=
(
'
\
t
'
+
gluVarType
.
declareVariable
(
shaderSpec
.
outputs
[
i
]
.
varType
shaderSpec
.
outputs
[
i
]
.
name
)
+
'
;
\
n
'
)
;
}
src
+
=
shaderSpec
.
source
;
for
(
var
i
=
0
;
i
<
shaderSpec
.
outputs
.
length
;
i
+
+
)
{
if
(
useIntOutputs
&
&
gluShaderUtil
.
isDataTypeFloatOrVec
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
)
src
+
=
(
'
o_
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
=
floatBitsToUint
(
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
)
;
\
n
'
)
;
else
if
(
gluShaderUtil
.
isDataTypeMatrix
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
)
{
numVecs
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
;
for
(
var
vecNdx
=
0
;
vecNdx
<
numVecs
;
+
+
vecNdx
)
if
(
useIntOutputs
)
src
+
=
(
'
\
to_
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
_
'
+
vecNdx
+
'
=
floatBitsToUint
(
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
[
'
+
vecNdx
+
'
]
)
;
\
n
'
)
;
else
src
+
=
(
'
\
to_
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
_
'
+
vecNdx
+
'
=
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
[
'
+
vecNdx
+
'
]
;
\
n
'
)
;
}
else
if
(
gluShaderUtil
.
isDataTypeBoolOrBVec
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
)
{
vecSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
shaderSpec
.
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
;
intBasicType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeVector
(
gluShaderUtil
.
DataType
.
INT
vecSize
)
:
gluShaderUtil
.
DataType
.
INT
;
src
+
=
(
'
\
to_
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
=
'
+
gluShaderUtil
.
getDataTypeName
(
intBasicType
)
+
'
(
'
+
shaderSpec
.
outputs
[
i
]
.
name
+
'
)
;
\
n
'
)
;
}
}
src
+
=
'
}
\
n
'
;
return
src
;
}
;
glsShaderExecUtil
.
getTFVaryings
=
function
(
outputs
)
{
var
names
=
[
]
;
for
(
var
i
=
0
;
i
<
outputs
.
length
;
i
+
+
)
{
if
(
gluShaderUtil
.
isDataTypeBoolOrBVec
(
outputs
[
i
]
.
varType
.
getBasicType
(
)
)
)
{
names
.
push
(
'
o_
'
+
outputs
[
i
]
.
name
)
;
}
else
{
names
.
push
(
outputs
[
i
]
.
name
)
;
}
}
return
new
gluShaderProgram
.
TransformFeedbackVaryings
(
names
)
;
}
;
glsShaderExecUtil
.
VertexProcessorExecutor
=
function
(
shaderSpec
sources
)
{
sources
.
add
(
glsShaderExecUtil
.
getTFVaryings
(
shaderSpec
.
outputs
)
)
;
sources
.
add
(
new
gluShaderProgram
.
TransformFeedbackMode
(
gl
.
INTERLEAVED_ATTRIBS
)
)
;
glsShaderExecUtil
.
ShaderExecutor
.
call
(
this
shaderSpec
)
;
this
.
m_program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
sources
)
;
}
;
setParentClass
(
glsShaderExecUtil
.
VertexProcessorExecutor
glsShaderExecUtil
.
ShaderExecutor
)
;
glsShaderExecUtil
.
VertexProcessorExecutor
.
prototype
.
isOk
=
function
(
)
{
return
this
.
m_program
.
isOk
(
)
;
}
;
glsShaderExecUtil
.
VertexProcessorExecutor
.
prototype
.
getProgram
=
function
(
)
{
return
this
.
m_program
.
getProgram
(
)
;
}
;
glsShaderExecUtil
.
computeTotalScalarSize
=
function
(
arr
)
{
var
size
=
0
;
for
(
var
i
=
0
;
i
<
arr
.
length
;
i
+
+
)
size
+
=
arr
[
i
]
.
varType
.
getScalarSize
(
)
;
return
size
;
}
;
glsShaderExecUtil
.
getColumn
=
function
(
ptr
colNdx
size
)
{
var
begin
=
colNdx
*
size
;
var
end
=
(
colNdx
+
1
)
*
size
;
return
ptr
.
slice
(
begin
end
)
;
}
;
glsShaderExecUtil
.
VertexProcessorExecutor
.
prototype
.
execute
=
function
(
numValues
inputs
)
{
var
symbol
;
var
outputs
=
[
]
;
var
useTFObject
=
true
;
var
vertexArrays
=
[
]
;
var
transformFeedback
=
gl
.
createTransformFeedback
(
)
;
var
outputBuffer
=
gl
.
createBuffer
(
)
;
var
outputBufferStride
=
glsShaderExecUtil
.
computeTotalScalarSize
(
this
.
m_outputs
)
*
4
;
for
(
var
inputNdx
=
0
;
inputNdx
<
this
.
m_inputs
.
length
;
inputNdx
+
+
)
{
symbol
=
this
.
m_inputs
[
inputNdx
]
;
var
ptr
=
inputs
[
inputNdx
]
;
var
basicType
=
symbol
.
varType
.
getBasicType
(
)
;
var
vecSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
basicType
)
;
if
(
gluShaderUtil
.
isDataTypeFloatOrVec
(
basicType
)
)
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
symbol
.
name
vecSize
numValues
0
ptr
)
)
;
else
if
(
gluShaderUtil
.
isDataTypeIntOrIVec
(
basicType
)
)
vertexArrays
.
push
(
gluDrawUtil
.
newInt32VertexArrayBinding
(
symbol
.
name
vecSize
numValues
0
ptr
)
)
;
else
if
(
gluShaderUtil
.
isDataTypeUintOrUVec
(
basicType
)
)
vertexArrays
.
push
(
gluDrawUtil
.
newUint32VertexArrayBinding
(
symbol
.
name
vecSize
numValues
0
ptr
)
)
;
else
if
(
gluShaderUtil
.
isDataTypeMatrix
(
basicType
)
)
{
var
numRows
=
gluShaderUtil
.
getDataTypeMatrixNumRows
(
basicType
)
;
var
numCols
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
basicType
)
;
var
stride
=
0
;
for
(
var
colNdx
=
0
;
colNdx
<
numCols
;
+
+
colNdx
)
vertexArrays
.
push
(
gluDrawUtil
.
newFloatColumnVertexArrayBinding
(
symbol
.
name
colNdx
numRows
numValues
stride
glsShaderExecUtil
.
getColumn
(
ptr
colNdx
numRows
*
numValues
)
)
)
;
}
else
DE_ASSERT
(
false
)
;
}
if
(
useTFObject
)
gl
.
bindTransformFeedback
(
gl
.
TRANSFORM_FEEDBACK
transformFeedback
)
;
gl
.
bindBuffer
(
gl
.
TRANSFORM_FEEDBACK_BUFFER
outputBuffer
)
;
gl
.
bufferData
(
gl
.
TRANSFORM_FEEDBACK_BUFFER
outputBufferStride
*
numValues
gl
.
STREAM_READ
)
;
gl
.
bindBufferBase
(
gl
.
TRANSFORM_FEEDBACK_BUFFER
0
outputBuffer
)
;
gl
.
beginTransformFeedback
(
gl
.
POINTS
)
;
gl
.
enable
(
gl
.
RASTERIZER_DISCARD
)
;
gluDrawUtil
.
draw
(
gl
this
.
m_program
.
getProgram
(
)
vertexArrays
new
gluDrawUtil
.
PrimitiveList
(
gluDrawUtil
.
primitiveType
.
POINTS
numValues
)
)
;
gl
.
disable
(
gl
.
RASTERIZER_DISCARD
)
;
gl
.
endTransformFeedback
(
)
;
var
result
=
new
ArrayBuffer
(
outputBufferStride
*
numValues
)
;
gl
.
getBufferSubData
(
gl
.
TRANSFORM_FEEDBACK_BUFFER
0
result
)
;
var
curOffset
=
0
;
for
(
var
outputNdx
=
0
;
outputNdx
<
this
.
m_outputs
.
length
;
outputNdx
+
+
)
{
symbol
=
this
.
m_outputs
[
outputNdx
]
;
var
scalarSize
=
symbol
.
varType
.
getScalarSize
(
)
;
var
readPtr
=
new
Uint8Array
(
result
curOffset
)
;
if
(
scalarSize
*
4
=
=
=
outputBufferStride
)
outputs
[
outputNdx
]
=
readPtr
;
else
{
var
dstPtr
=
new
Uint8Array
(
scalarSize
*
numValues
*
4
)
;
for
(
var
ndx
=
0
;
ndx
<
numValues
;
ndx
+
+
)
for
(
var
j
=
0
;
j
<
scalarSize
*
4
;
j
+
+
)
{
dstPtr
[
scalarSize
*
4
*
ndx
+
j
]
=
readPtr
[
ndx
*
outputBufferStride
+
j
]
;
}
outputs
[
outputNdx
]
=
dstPtr
;
}
curOffset
+
=
scalarSize
*
4
;
}
if
(
useTFObject
)
gl
.
bindTransformFeedback
(
gl
.
TRANSFORM_FEEDBACK
null
)
;
gl
.
bindBuffer
(
gl
.
TRANSFORM_FEEDBACK_BUFFER
null
)
;
return
outputs
;
}
;
glsShaderExecUtil
.
VertexShaderExecutor
=
function
(
shaderSpec
)
{
var
sources
=
gluShaderProgram
.
makeVtxFragSources
(
glsShaderExecUtil
.
generateVertexShader
(
shaderSpec
)
glsShaderExecUtil
.
generateEmptyFragmentSource
(
)
)
;
glsShaderExecUtil
.
VertexProcessorExecutor
.
call
(
this
shaderSpec
sources
)
;
}
;
setParentClass
(
glsShaderExecUtil
.
VertexShaderExecutor
glsShaderExecUtil
.
VertexProcessorExecutor
)
;
glsShaderExecUtil
.
FragmentShaderExecutor
=
function
(
shaderSpec
)
{
glsShaderExecUtil
.
ShaderExecutor
.
call
(
this
shaderSpec
)
;
this
.
m_outLocationSymbols
=
[
]
;
this
.
m_outLocationMap
=
glsShaderExecUtil
.
generateLocationMap
(
this
.
m_outputs
this
.
m_outLocationSymbols
)
;
var
sources
=
gluShaderProgram
.
makeVtxFragSources
(
glsShaderExecUtil
.
generatePassthroughVertexShader
(
shaderSpec
'
a_
'
'
'
)
glsShaderExecUtil
.
generateFragmentShader
(
shaderSpec
true
this
.
m_outLocationMap
)
)
;
this
.
m_program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
sources
)
;
}
;
setParentClass
(
glsShaderExecUtil
.
FragmentShaderExecutor
glsShaderExecUtil
.
ShaderExecutor
)
;
glsShaderExecUtil
.
FragmentShaderExecutor
.
prototype
.
isOk
=
function
(
)
{
return
this
.
m_program
.
isOk
(
)
;
}
;
glsShaderExecUtil
.
FragmentShaderExecutor
.
prototype
.
getProgram
=
function
(
)
{
return
this
.
m_program
.
getProgram
(
)
;
}
;
glsShaderExecUtil
.
getRenderbufferFormatForOutput
=
function
(
outputType
useIntOutputs
)
{
var
channelOrderMap
=
[
tcuTexture
.
ChannelOrder
.
R
tcuTexture
.
ChannelOrder
.
RG
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelOrder
.
RGBA
]
;
var
basicType
=
outputType
.
getBasicType
(
)
;
var
numComps
=
gluShaderUtil
.
getDataTypeNumComponents
(
basicType
)
;
var
channelType
;
switch
(
gluShaderUtil
.
getDataTypeScalarType
(
basicType
)
)
{
case
'
uint
'
:
channelType
=
tcuTexture
.
ChannelType
.
UNSIGNED_INT32
;
break
;
case
'
int
'
:
channelType
=
tcuTexture
.
ChannelType
.
SIGNED_INT32
;
break
;
case
'
bool
'
:
channelType
=
tcuTexture
.
ChannelType
.
SIGNED_INT32
;
break
;
case
'
float
'
:
channelType
=
useIntOutputs
?
tcuTexture
.
ChannelType
.
UNSIGNED_INT32
:
tcuTexture
.
ChannelType
.
FLOAT
;
break
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
+
gluShaderUtil
.
getDataTypeScalarType
(
basicType
)
)
;
}
return
new
tcuTexture
.
TextureFormat
(
channelOrderMap
[
numComps
-
1
]
channelType
)
;
}
;
glsShaderExecUtil
.
FragmentShaderExecutor
.
prototype
.
execute
=
function
(
numValues
inputs
)
{
var
useIntOutputs
=
true
;
var
symbol
;
var
outputs
=
[
]
;
var
maxRenderbufferSize
=
(
gl
.
getParameter
(
gl
.
MAX_RENDERBUFFER_SIZE
)
)
;
var
framebufferW
=
Math
.
min
(
maxRenderbufferSize
numValues
)
;
var
framebufferH
=
Math
.
ceil
(
numValues
/
framebufferW
)
;
var
framebuffer
=
gl
.
createFramebuffer
(
)
;
var
renderbuffers
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
m_outLocationSymbols
.
length
;
i
+
+
)
renderbuffers
.
push
(
gl
.
createRenderbuffer
(
)
)
;
var
vertexArrays
=
[
]
;
var
positions
=
[
]
;
if
(
framebufferH
>
maxRenderbufferSize
)
throw
new
Error
(
'
Value
count
is
too
high
for
maximum
supported
renderbuffer
size
'
)
;
for
(
var
valNdx
=
0
;
valNdx
<
numValues
;
valNdx
+
+
)
{
var
ix
=
valNdx
%
framebufferW
;
var
iy
=
Math
.
floor
(
valNdx
/
framebufferW
)
;
var
fx
=
-
1
+
2
*
(
ix
+
0
.
5
)
/
framebufferW
;
var
fy
=
-
1
+
2
*
(
iy
+
0
.
5
)
/
framebufferH
;
positions
[
2
*
valNdx
]
=
fx
;
positions
[
2
*
valNdx
+
1
]
=
fy
;
}
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
'
a_position
'
2
numValues
0
positions
)
)
;
for
(
var
inputNdx
=
0
;
inputNdx
<
this
.
m_inputs
.
length
;
inputNdx
+
+
)
{
symbol
=
this
.
m_inputs
[
inputNdx
]
;
var
attribName
=
'
a_
'
+
symbol
.
name
;
var
ptr
=
inputs
[
inputNdx
]
;
var
basicType
=
symbol
.
varType
.
getBasicType
(
)
;
var
vecSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
basicType
)
;
if
(
gluShaderUtil
.
isDataTypeFloatOrVec
(
basicType
)
)
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
attribName
vecSize
numValues
0
ptr
)
)
;
else
if
(
gluShaderUtil
.
isDataTypeIntOrIVec
(
basicType
)
)
vertexArrays
.
push
(
gluDrawUtil
.
newInt32VertexArrayBinding
(
attribName
vecSize
numValues
0
ptr
)
)
;
else
if
(
gluShaderUtil
.
isDataTypeUintOrUVec
(
basicType
)
)
vertexArrays
.
push
(
gluDrawUtil
.
newUint32VertexArrayBinding
(
attribName
vecSize
numValues
0
ptr
)
)
;
else
if
(
gluShaderUtil
.
isDataTypeMatrix
(
basicType
)
)
{
var
numRows
=
gluShaderUtil
.
getDataTypeMatrixNumRows
(
basicType
)
;
var
numCols
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
basicType
)
;
var
stride
=
0
;
for
(
var
colNdx
=
0
;
colNdx
<
numCols
;
+
+
colNdx
)
vertexArrays
.
push
(
gluDrawUtil
.
newFloatColumnVertexArrayBinding
(
attribName
colNdx
numRows
numValues
stride
glsShaderExecUtil
.
getColumn
(
ptr
colNdx
numRows
*
numValues
)
)
)
;
}
else
DE_ASSERT
(
false
)
;
}
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
framebuffer
)
;
for
(
var
outNdx
=
0
;
outNdx
<
this
.
m_outLocationSymbols
.
length
;
+
+
outNdx
)
{
symbol
=
this
.
m_outLocationSymbols
[
outNdx
]
;
var
renderbuffer
=
renderbuffers
[
outNdx
]
;
var
format
=
gluTextureUtil
.
getInternalFormat
(
glsShaderExecUtil
.
getRenderbufferFormatForOutput
(
symbol
.
varType
useIntOutputs
)
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
renderbuffer
)
;
gl
.
renderbufferStorage
(
gl
.
RENDERBUFFER
format
framebufferW
framebufferH
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
+
outNdx
gl
.
RENDERBUFFER
renderbuffer
)
;
}
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
null
)
;
assertMsgOptions
(
gl
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
=
=
gl
.
FRAMEBUFFER_COMPLETE
'
Framebuffer
is
incomplete
'
false
true
)
;
var
drawBuffers
=
[
]
;
for
(
var
ndx
=
0
;
ndx
<
this
.
m_outLocationSymbols
.
length
;
ndx
+
+
)
drawBuffers
[
ndx
]
=
gl
.
COLOR_ATTACHMENT0
+
ndx
;
gl
.
drawBuffers
(
drawBuffers
)
;
gl
.
viewport
(
0
0
framebufferW
framebufferH
)
;
gluDrawUtil
.
draw
(
gl
this
.
m_program
.
getProgram
(
)
vertexArrays
new
gluDrawUtil
.
PrimitiveList
(
gluDrawUtil
.
primitiveType
.
POINTS
numValues
)
)
;
for
(
var
outNdx
=
0
;
outNdx
<
this
.
m_outputs
.
length
;
+
+
outNdx
)
{
symbol
=
this
.
m_outputs
[
outNdx
]
;
var
outSize
=
symbol
.
varType
.
getScalarSize
(
)
;
var
outVecSize
=
gluShaderUtil
.
getDataTypeNumComponents
(
symbol
.
varType
.
getBasicType
(
)
)
;
var
outNumLocs
=
gluShaderUtil
.
getDataTypeNumLocations
(
symbol
.
varType
.
getBasicType
(
)
)
;
var
format
=
glsShaderExecUtil
.
getRenderbufferFormatForOutput
(
symbol
.
varType
useIntOutputs
)
;
var
readFormat
=
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
format
.
type
)
;
var
transferFormat
=
gluTextureUtil
.
getTransferFormat
(
readFormat
)
;
var
outLocation
=
this
.
m_outLocationMap
[
symbol
.
name
]
;
var
tmpBuf
=
new
tcuTexture
.
TextureLevel
(
readFormat
framebufferW
framebufferH
)
;
for
(
var
locNdx
=
0
;
locNdx
<
outNumLocs
;
+
+
locNdx
)
{
gl
.
readBuffer
(
gl
.
COLOR_ATTACHMENT0
+
outLocation
+
locNdx
)
;
gl
.
readPixels
(
0
0
framebufferW
framebufferH
transferFormat
.
format
transferFormat
.
dataType
tmpBuf
.
getAccess
(
)
.
getDataPtr
(
)
)
;
if
(
outSize
=
=
4
&
&
outNumLocs
=
=
1
)
{
outputs
[
outNdx
]
=
new
Uint8Array
(
tmpBuf
.
getAccess
(
)
.
getBuffer
(
)
)
;
}
else
{
if
(
locNdx
=
=
0
)
outputs
[
outNdx
]
=
new
Uint32Array
(
numValues
*
outVecSize
)
;
var
srcPtr
=
new
Uint32Array
(
tmpBuf
.
getAccess
(
)
.
getBuffer
(
)
)
;
for
(
var
valNdx
=
0
;
valNdx
<
numValues
;
valNdx
+
+
)
{
var
srcOffset
=
valNdx
*
4
;
var
dstOffset
=
outSize
*
valNdx
+
outVecSize
*
locNdx
;
for
(
var
j
=
0
;
j
<
outVecSize
;
j
+
+
)
outputs
[
outNdx
]
[
dstOffset
+
j
]
=
srcPtr
[
srcOffset
+
j
]
;
}
}
}
}
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
return
outputs
;
}
;
glsShaderExecUtil
.
generateLocationMap
=
function
(
symbols
locationSymbols
)
{
var
ret
=
[
]
;
locationSymbols
.
length
=
0
;
var
location
=
0
;
for
(
var
i
=
0
;
i
<
symbols
.
length
;
i
+
+
)
{
var
symbol
=
symbols
[
i
]
;
var
numLocations
=
gluShaderUtil
.
getDataTypeNumLocations
(
symbol
.
varType
.
getBasicType
(
)
)
;
ret
[
symbol
.
name
]
=
location
;
location
+
=
numLocations
;
for
(
var
ndx
=
0
;
ndx
<
numLocations
;
+
+
ndx
)
locationSymbols
.
push
(
symbol
)
;
}
return
ret
;
}
;
}
)
;
