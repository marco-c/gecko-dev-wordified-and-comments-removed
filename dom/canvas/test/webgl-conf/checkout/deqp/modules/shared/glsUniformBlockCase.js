'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsUniformBlockCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluDrawUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
glsUniformBlockCase
=
modules
.
shared
.
glsUniformBlockCase
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluDrawUtil
=
framework
.
opengl
.
gluDrawUtil
;
var
deUtil
=
framework
.
delibs
.
debase
.
deUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
var
littleEndian
=
(
function
(
)
{
var
buffer
=
new
ArrayBuffer
(
2
)
;
new
DataView
(
buffer
)
.
setInt16
(
0
256
true
)
;
return
new
Int16Array
(
buffer
)
[
0
]
=
=
=
256
;
}
)
(
)
;
glsUniformBlockCase
.
BlockPointers
=
function
(
)
{
this
.
data
;
this
.
offsets
=
[
]
;
this
.
sizes
=
[
]
;
}
;
glsUniformBlockCase
.
BlockPointers
.
prototype
.
push
=
function
(
offset
size
)
{
this
.
offsets
.
push
(
offset
)
;
this
.
sizes
.
push
(
size
)
;
}
;
glsUniformBlockCase
.
BlockPointers
.
prototype
.
find
=
function
(
index
)
{
return
new
Uint8Array
(
this
.
data
this
.
offsets
[
index
]
this
.
sizes
[
index
]
)
;
}
;
glsUniformBlockCase
.
BlockPointers
.
prototype
.
resize
=
function
(
newsize
)
{
this
.
data
=
new
ArrayBuffer
(
newsize
)
;
}
;
glsUniformBlockCase
.
isSupportedGLSLVersion
=
function
(
version
)
{
return
version
>
=
gluShaderUtil
.
GLSLVersion
.
V300_ES
;
}
;
glsUniformBlockCase
.
UniformFlags
=
{
PRECISION_LOW
:
(
1
<
<
0
)
PRECISION_MEDIUM
:
(
1
<
<
1
)
PRECISION_HIGH
:
(
1
<
<
2
)
LAYOUT_SHARED
:
(
1
<
<
3
)
LAYOUT_PACKED
:
(
1
<
<
4
)
LAYOUT_STD140
:
(
1
<
<
5
)
LAYOUT_ROW_MAJOR
:
(
1
<
<
6
)
LAYOUT_COLUMN_MAJOR
:
(
1
<
<
7
)
DECLARE_VERTEX
:
(
1
<
<
8
)
DECLARE_FRAGMENT
:
(
1
<
<
9
)
UNUSED_VERTEX
:
(
1
<
<
10
)
UNUSED_FRAGMENT
:
(
1
<
<
11
)
}
;
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MASK
=
glsUniformBlockCase
.
UniformFlags
.
PRECISION_LOW
|
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MEDIUM
|
glsUniformBlockCase
.
UniformFlags
.
PRECISION_HIGH
;
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_MASK
=
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_SHARED
|
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_PACKED
|
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_STD140
|
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_ROW_MAJOR
|
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_COLUMN_MAJOR
;
glsUniformBlockCase
.
UniformFlags
.
DECLARE_BOTH
=
glsUniformBlockCase
.
UniformFlags
.
DECLARE_VERTEX
|
glsUniformBlockCase
.
UniformFlags
.
DECLARE_FRAGMENT
;
glsUniformBlockCase
.
UniformFlags
.
UNUSED_BOTH
=
glsUniformBlockCase
.
UniformFlags
.
UNUSED_VERTEX
|
glsUniformBlockCase
.
UniformFlags
.
UNUSED_FRAGMENT
;
glsUniformBlockCase
.
Type
=
{
TYPE_BASIC
:
0
TYPE_ARRAY
:
1
TYPE_STRUCT
:
2
}
;
glsUniformBlockCase
.
Type
.
TYPE_LAST
=
Object
.
keys
(
glsUniformBlockCase
.
Type
)
.
length
;
glsUniformBlockCase
.
TypeArray
=
function
(
elementType
arraySize
)
{
this
.
elementType
=
elementType
;
this
.
size
=
arraySize
;
}
;
glsUniformBlockCase
.
VarType
=
function
(
)
{
this
.
m_type
;
this
.
m_flags
=
0
;
this
.
m_data
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
VarTypeBasic
=
function
(
basicType
flags
)
{
this
.
m_type
=
glsUniformBlockCase
.
Type
.
TYPE_BASIC
;
this
.
m_flags
=
flags
;
this
.
m_data
=
basicType
;
return
this
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
VarTypeArray
=
function
(
elementType
arraySize
)
{
this
.
m_type
=
glsUniformBlockCase
.
Type
.
TYPE_ARRAY
;
this
.
m_flags
=
0
;
this
.
m_data
=
new
glsUniformBlockCase
.
TypeArray
(
elementType
arraySize
)
;
return
this
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
VarTypeStruct
=
function
(
structPtr
)
{
this
.
m_type
=
glsUniformBlockCase
.
Type
.
TYPE_STRUCT
;
this
.
m_flags
=
0
;
this
.
m_data
=
structPtr
;
return
this
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
isBasicType
=
function
(
)
{
return
this
.
m_type
=
=
glsUniformBlockCase
.
Type
.
TYPE_BASIC
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
isArrayType
=
function
(
)
{
return
this
.
m_type
=
=
glsUniformBlockCase
.
Type
.
TYPE_ARRAY
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
isStructType
=
function
(
)
{
return
this
.
m_type
=
=
glsUniformBlockCase
.
Type
.
TYPE_STRUCT
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
getFlags
=
function
(
)
{
return
this
.
m_flags
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
getBasicType
=
function
(
)
{
return
(
this
.
m_data
)
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
getElementType
=
function
(
)
{
return
this
.
m_data
.
elementType
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
getArraySize
=
function
(
)
{
return
this
.
m_data
.
size
;
}
;
glsUniformBlockCase
.
VarType
.
prototype
.
getStruct
=
function
(
)
{
return
(
this
.
m_data
)
;
}
;
glsUniformBlockCase
.
newVarTypeBasic
=
function
(
basicType
flags
)
{
return
new
glsUniformBlockCase
.
VarType
(
)
.
VarTypeBasic
(
basicType
flags
)
;
}
;
glsUniformBlockCase
.
newVarTypeArray
=
function
(
elementType
arraySize
)
{
return
new
glsUniformBlockCase
.
VarType
(
)
.
VarTypeArray
(
elementType
arraySize
)
;
}
;
glsUniformBlockCase
.
newVarTypeStruct
=
function
(
structPtr
)
{
return
new
glsUniformBlockCase
.
VarType
(
)
.
VarTypeStruct
(
structPtr
)
;
}
;
glsUniformBlockCase
.
StructMember
=
function
(
)
{
this
.
m_name
;
this
.
m_type
;
this
.
m_flags
=
0
;
}
;
glsUniformBlockCase
.
StructMember
.
prototype
.
Constructor
=
function
(
name
type
flags
)
{
this
.
m_type
=
type
;
this
.
m_name
=
name
;
this
.
m_flags
=
flags
;
return
this
;
}
;
glsUniformBlockCase
.
StructMember
.
prototype
.
getName
=
function
(
)
{
return
this
.
m_name
;
}
;
glsUniformBlockCase
.
StructMember
.
prototype
.
getType
=
function
(
)
{
return
this
.
m_type
;
}
;
glsUniformBlockCase
.
StructMember
.
prototype
.
getFlags
=
function
(
)
{
return
this
.
m_flags
;
}
;
glsUniformBlockCase
.
newStructMember
=
function
(
name
type
flags
)
{
return
new
glsUniformBlockCase
.
StructMember
(
)
.
Constructor
(
name
type
flags
)
;
}
;
glsUniformBlockCase
.
StructType
=
function
(
)
{
this
.
m_typeName
;
this
.
m_members
=
[
]
;
}
;
glsUniformBlockCase
.
StructType
.
prototype
.
Constructor
=
function
(
typeName
)
{
this
.
m_typeName
=
typeName
;
return
this
;
}
;
glsUniformBlockCase
.
StructType
.
prototype
.
getTypeName
=
function
(
)
{
return
this
.
m_typeName
;
}
;
glsUniformBlockCase
.
StructType
.
prototype
.
getMember
=
function
(
memberNdx
)
{
if
(
memberNdx
>
=
0
&
&
memberNdx
<
this
.
m_members
.
length
)
return
this
.
m_members
[
memberNdx
]
;
else
{
throw
new
Error
(
"
Invalid
member
index
for
glsUniformBlockCase
.
StructType
'
s
members
"
)
;
}
}
;
glsUniformBlockCase
.
StructType
.
prototype
.
getSize
=
function
(
)
{
return
this
.
m_members
.
length
;
}
;
glsUniformBlockCase
.
StructType
.
prototype
.
addMember
=
function
(
member_name
member_type
member_flags
)
{
var
member
=
glsUniformBlockCase
.
newStructMember
(
member_name
member_type
member_flags
)
;
this
.
m_members
.
push
(
member
)
;
}
;
glsUniformBlockCase
.
newStructType
=
function
(
name
)
{
return
new
glsUniformBlockCase
.
StructType
(
)
.
Constructor
(
name
)
;
}
;
glsUniformBlockCase
.
Uniform
=
function
(
name
type
flags
)
{
this
.
m_name
=
name
;
this
.
m_type
=
type
;
this
.
m_flags
=
(
typeof
flags
=
=
=
'
undefined
'
)
?
0
:
flags
;
}
;
glsUniformBlockCase
.
Uniform
.
prototype
.
getName
=
function
(
)
{
return
this
.
m_name
;
}
;
glsUniformBlockCase
.
Uniform
.
prototype
.
getType
=
function
(
)
{
return
this
.
m_type
;
}
;
glsUniformBlockCase
.
Uniform
.
prototype
.
getFlags
=
function
(
)
{
return
this
.
m_flags
;
}
;
glsUniformBlockCase
.
UniformBlock
=
function
(
blockName
)
{
this
.
m_blockName
=
blockName
;
this
.
m_instanceName
;
this
.
m_uniforms
=
[
]
;
this
.
m_arraySize
=
0
;
this
.
m_flags
=
0
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
getBlockName
=
function
(
)
{
return
this
.
m_blockName
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
getInstanceName
=
function
(
)
{
return
this
.
m_instanceName
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
isArray
=
function
(
)
{
return
this
.
m_arraySize
>
0
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
getArraySize
=
function
(
)
{
return
this
.
m_arraySize
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
getFlags
=
function
(
)
{
return
this
.
m_flags
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
setInstanceName
=
function
(
name
)
{
this
.
m_instanceName
=
name
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
setFlags
=
function
(
flags
)
{
this
.
m_flags
=
flags
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
setArraySize
=
function
(
arraySize
)
{
this
.
m_arraySize
=
arraySize
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
addUniform
=
function
(
uniform
)
{
this
.
m_uniforms
.
push
(
uniform
)
;
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
getUniform
=
function
(
index
)
{
if
(
index
>
=
0
&
&
index
<
this
.
m_uniforms
.
length
)
return
this
.
m_uniforms
[
index
]
;
else
{
throw
new
Error
(
"
Invalid
uniform
index
for
glsUniformBlockCase
.
UniformBlock
'
s
uniforms
"
)
;
}
}
;
glsUniformBlockCase
.
UniformBlock
.
prototype
.
countUniforms
=
function
(
)
{
return
this
.
m_uniforms
.
length
;
}
;
glsUniformBlockCase
.
ShaderInterface
=
function
(
)
{
this
.
m_structs
=
[
]
;
this
.
m_uniformBlocks
=
[
]
;
}
;
glsUniformBlockCase
.
ShaderInterface
.
prototype
.
allocStruct
=
function
(
name
)
{
this
.
m_structs
.
push
(
glsUniformBlockCase
.
newStructType
(
name
)
)
;
return
this
.
m_structs
[
this
.
m_structs
.
length
-
1
]
;
}
;
glsUniformBlockCase
.
ShaderInterface
.
prototype
.
findStruct
=
function
(
name
)
{
for
(
var
pos
=
0
;
pos
<
this
.
m_structs
.
length
;
pos
+
+
)
{
if
(
this
.
m_structs
[
pos
]
.
getTypeName
(
)
=
=
name
)
return
this
.
m_structs
[
pos
]
;
}
return
null
;
}
;
glsUniformBlockCase
.
ShaderInterface
.
prototype
.
getNamedStructs
=
function
(
structs
)
{
for
(
var
pos
=
0
;
pos
<
this
.
m_structs
.
length
;
pos
+
+
)
{
if
(
this
.
m_structs
[
pos
]
.
getTypeName
(
)
!
=
undefined
)
structs
.
push
(
this
.
m_structs
[
pos
]
)
;
}
}
;
glsUniformBlockCase
.
ShaderInterface
.
prototype
.
allocBlock
=
function
(
name
)
{
this
.
m_uniformBlocks
.
push
(
new
glsUniformBlockCase
.
UniformBlock
(
name
)
)
;
return
this
.
m_uniformBlocks
[
this
.
m_uniformBlocks
.
length
-
1
]
;
}
;
glsUniformBlockCase
.
ShaderInterface
.
prototype
.
getNumUniformBlocks
=
function
(
)
{
return
this
.
m_uniformBlocks
.
length
;
}
;
glsUniformBlockCase
.
ShaderInterface
.
prototype
.
getUniformBlock
=
function
(
ndx
)
{
return
this
.
m_uniformBlocks
[
ndx
]
;
}
;
glsUniformBlockCase
.
BlockLayoutEntry
=
function
(
)
{
return
{
size
:
0
name
:
'
'
activeUniformIndices
:
[
]
}
;
}
;
glsUniformBlockCase
.
UniformLayoutEntry
=
function
(
)
{
return
{
name
:
'
'
type
:
gluShaderUtil
.
DataType
.
INVALID
size
:
0
blockNdx
:
-
1
offset
:
-
1
arrayStride
:
-
1
matrixStride
:
-
1
isRowMajor
:
false
}
;
}
;
glsUniformBlockCase
.
UniformLayout
=
function
(
)
{
this
.
blocks
=
[
]
;
this
.
uniforms
=
[
]
;
}
;
glsUniformBlockCase
.
UniformLayout
.
prototype
.
getUniformIndex
=
function
(
name
)
{
for
(
var
ndx
=
0
;
ndx
<
this
.
uniforms
.
length
;
ndx
+
+
)
{
if
(
this
.
uniforms
[
ndx
]
.
name
=
=
name
)
return
ndx
;
}
return
-
1
;
}
;
glsUniformBlockCase
.
UniformLayout
.
prototype
.
getBlockIndex
=
function
(
name
)
{
for
(
var
ndx
=
0
;
ndx
<
this
.
blocks
.
length
;
ndx
+
+
)
{
if
(
this
.
blocks
[
ndx
]
.
name
=
=
name
)
return
ndx
;
}
return
-
1
;
}
;
glsUniformBlockCase
.
BufferMode
=
{
BUFFERMODE_SINGLE
:
0
BUFFERMODE_PER_BLOCK
:
1
}
;
glsUniformBlockCase
.
BufferMode
.
BUFFERMODE_LAST
=
Object
.
keys
(
glsUniformBlockCase
.
BufferMode
)
.
length
;
glsUniformBlockCase
.
PrecisionFlagsFmt
=
function
(
flags
)
{
DE_ASSERT
(
deMath
.
dePop32
(
flags
&
(
glsUniformBlockCase
.
UniformFlags
.
PRECISION_LOW
|
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MEDIUM
|
glsUniformBlockCase
.
UniformFlags
.
PRECISION_HIGH
)
)
<
=
1
)
;
var
str
=
'
'
;
str
+
=
(
flags
&
glsUniformBlockCase
.
UniformFlags
.
PRECISION_LOW
?
'
lowp
'
:
flags
&
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MEDIUM
?
'
mediump
'
:
flags
&
glsUniformBlockCase
.
UniformFlags
.
PRECISION_HIGH
?
'
highp
'
:
'
'
)
;
return
str
;
}
;
glsUniformBlockCase
.
LayoutFlagsFmt
=
function
(
flags_
)
{
var
str
=
'
'
;
var
bitDesc
=
[
{
bit
:
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_SHARED
token
:
'
shared
'
}
{
bit
:
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_PACKED
token
:
'
packed
'
}
{
bit
:
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_STD140
token
:
'
std140
'
}
{
bit
:
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_ROW_MAJOR
token
:
'
row_major
'
}
{
bit
:
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_COLUMN_MAJOR
token
:
'
column_major
'
}
]
;
var
remBits
=
flags_
;
for
(
var
descNdx
=
0
;
descNdx
<
bitDesc
.
length
;
descNdx
+
+
)
{
if
(
remBits
&
bitDesc
[
descNdx
]
.
bit
)
{
if
(
remBits
!
=
flags_
)
str
+
=
'
'
;
str
+
=
bitDesc
[
descNdx
]
.
token
;
remBits
&
=
(
~
bitDesc
[
descNdx
]
.
bit
)
&
0xFFFFFFFF
;
}
}
DE_ASSERT
(
remBits
=
=
0
)
;
return
str
;
}
;
glsUniformBlockCase
.
UniformBufferManager
=
function
(
renderCtx
)
{
this
.
m_renderCtx
=
renderCtx
;
this
.
m_buffers
=
[
]
;
}
;
glsUniformBlockCase
.
UniformBufferManager
.
prototype
.
allocBuffer
=
function
(
)
{
var
buf
=
this
.
m_renderCtx
.
createBuffer
(
)
;
this
.
m_buffers
.
push
(
buf
)
;
return
buf
;
}
;
glsUniformBlockCase
.
UniformBlockCase
=
function
(
name
description
bufferMode
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_name
=
name
;
this
.
m_description
=
description
;
this
.
m_bufferMode
=
bufferMode
;
this
.
m_interface
=
new
glsUniformBlockCase
.
ShaderInterface
(
)
;
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
constructor
=
glsUniformBlockCase
.
UniformBlockCase
;
glsUniformBlockCase
.
getDataTypeByteSize
=
function
(
type
)
{
return
gluShaderUtil
.
getDataTypeScalarSize
(
type
)
*
deMath
.
INT32_SIZE
;
}
;
glsUniformBlockCase
.
getDataTypeByteAlignment
=
function
(
type
)
{
switch
(
type
)
{
case
gluShaderUtil
.
DataType
.
FLOAT
:
case
gluShaderUtil
.
DataType
.
INT
:
case
gluShaderUtil
.
DataType
.
UINT
:
case
gluShaderUtil
.
DataType
.
BOOL
:
return
1
*
deMath
.
INT32_SIZE
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC2
:
case
gluShaderUtil
.
DataType
.
INT_VEC2
:
case
gluShaderUtil
.
DataType
.
UINT_VEC2
:
case
gluShaderUtil
.
DataType
.
BOOL_VEC2
:
return
2
*
deMath
.
INT32_SIZE
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC3
:
case
gluShaderUtil
.
DataType
.
INT_VEC3
:
case
gluShaderUtil
.
DataType
.
UINT_VEC3
:
case
gluShaderUtil
.
DataType
.
BOOL_VEC3
:
case
gluShaderUtil
.
DataType
.
FLOAT_VEC4
:
case
gluShaderUtil
.
DataType
.
INT_VEC4
:
case
gluShaderUtil
.
DataType
.
UINT_VEC4
:
case
gluShaderUtil
.
DataType
.
BOOL_VEC4
:
return
4
*
deMath
.
INT32_SIZE
;
default
:
DE_ASSERT
(
false
)
;
return
0
;
}
}
;
glsUniformBlockCase
.
getDataTypeArrayStride
=
function
(
type
)
{
DE_ASSERT
(
!
gluShaderUtil
.
isDataTypeMatrix
(
type
)
)
;
var
baseStride
=
glsUniformBlockCase
.
getDataTypeByteSize
(
type
)
;
var
vec4Alignment
=
deMath
.
INT32_SIZE
*
4
;
DE_ASSERT
(
baseStride
<
=
vec4Alignment
)
;
return
Math
.
max
(
baseStride
vec4Alignment
)
;
}
;
glsUniformBlockCase
.
deRoundUp32
=
function
(
a
b
)
{
var
d
=
Math
.
trunc
(
a
/
b
)
;
return
d
*
b
=
=
a
?
a
:
(
d
+
1
)
*
b
;
}
;
glsUniformBlockCase
.
computeStd140BaseAlignment
=
function
(
type
)
{
var
vec4Alignment
=
deMath
.
INT32_SIZE
*
4
;
if
(
type
.
isBasicType
(
)
)
{
var
basicType
=
type
.
getBasicType
(
)
;
if
(
gluShaderUtil
.
isDataTypeMatrix
(
basicType
)
)
{
var
isRowMajor
=
!
!
(
type
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_ROW_MAJOR
)
;
var
vecSize
=
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
basicType
)
:
gluShaderUtil
.
getDataTypeMatrixNumRows
(
basicType
)
;
return
glsUniformBlockCase
.
getDataTypeArrayStride
(
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
)
;
}
else
return
glsUniformBlockCase
.
getDataTypeByteAlignment
(
basicType
)
;
}
else
if
(
type
.
isArrayType
(
)
)
{
var
elemAlignment
=
glsUniformBlockCase
.
computeStd140BaseAlignment
(
type
.
getElementType
(
)
)
;
return
glsUniformBlockCase
.
deRoundUp32
(
elemAlignment
vec4Alignment
)
;
}
else
{
DE_ASSERT
(
type
.
isStructType
(
)
)
;
var
maxBaseAlignment
=
0
;
for
(
var
memberNdx
=
0
;
memberNdx
<
type
.
getStruct
(
)
.
getSize
(
)
;
memberNdx
+
+
)
{
var
memberIter
=
type
.
getStruct
(
)
.
getMember
(
memberNdx
)
;
maxBaseAlignment
=
Math
.
max
(
maxBaseAlignment
glsUniformBlockCase
.
computeStd140BaseAlignment
(
memberIter
.
getType
(
)
)
)
;
}
return
glsUniformBlockCase
.
deRoundUp32
(
maxBaseAlignment
vec4Alignment
)
;
}
}
;
glsUniformBlockCase
.
mergeLayoutFlags
=
function
(
prevFlags
newFlags
)
{
var
packingMask
=
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_PACKED
|
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_SHARED
|
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_STD140
;
var
matrixMask
=
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_ROW_MAJOR
|
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_COLUMN_MAJOR
;
var
mergedFlags
=
0
;
mergedFlags
|
=
(
(
newFlags
&
packingMask
)
?
newFlags
:
prevFlags
)
&
packingMask
;
mergedFlags
|
=
(
(
newFlags
&
matrixMask
)
?
newFlags
:
prevFlags
)
&
matrixMask
;
return
mergedFlags
;
}
;
glsUniformBlockCase
.
computeStd140Layout_B
=
function
(
layout
curOffset
curBlockNdx
curPrefix
type
layoutFlags
)
{
var
baseAlignment
=
glsUniformBlockCase
.
computeStd140BaseAlignment
(
type
)
;
var
entry
;
var
stride
;
var
elemBasicType
;
var
isRowMajor
;
var
vecSize
;
var
numVecs
;
curOffset
=
deMath
.
deAlign32
(
curOffset
baseAlignment
)
;
if
(
type
.
isBasicType
(
)
)
{
var
basicType
=
type
.
getBasicType
(
)
;
entry
=
new
glsUniformBlockCase
.
UniformLayoutEntry
(
)
;
entry
.
name
=
curPrefix
;
entry
.
type
=
basicType
;
entry
.
size
=
1
;
entry
.
arrayStride
=
0
;
entry
.
matrixStride
=
0
;
entry
.
blockNdx
=
curBlockNdx
;
if
(
gluShaderUtil
.
isDataTypeMatrix
(
basicType
)
)
{
isRowMajor
=
!
!
(
layoutFlags
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_ROW_MAJOR
)
;
vecSize
=
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
basicType
)
:
gluShaderUtil
.
getDataTypeMatrixNumRows
(
basicType
)
;
numVecs
=
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumRows
(
basicType
)
:
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
basicType
)
;
stride
=
glsUniformBlockCase
.
getDataTypeArrayStride
(
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
)
;
entry
.
offset
=
curOffset
;
entry
.
matrixStride
=
stride
;
entry
.
isRowMajor
=
isRowMajor
;
curOffset
+
=
numVecs
*
stride
;
}
else
{
entry
.
offset
=
curOffset
;
curOffset
+
=
glsUniformBlockCase
.
getDataTypeByteSize
(
basicType
)
;
}
layout
.
uniforms
.
push
(
entry
)
;
}
else
if
(
type
.
isArrayType
(
)
)
{
var
elemType
=
type
.
getElementType
(
)
;
if
(
elemType
.
isBasicType
(
)
&
&
!
gluShaderUtil
.
isDataTypeMatrix
(
elemType
.
getBasicType
(
)
)
)
{
elemBasicType
=
elemType
.
getBasicType
(
)
;
entry
=
new
glsUniformBlockCase
.
UniformLayoutEntry
(
)
;
stride
=
glsUniformBlockCase
.
getDataTypeArrayStride
(
elemBasicType
)
;
entry
.
name
=
curPrefix
+
'
[
0
]
'
;
entry
.
type
=
elemBasicType
;
entry
.
blockNdx
=
curBlockNdx
;
entry
.
offset
=
curOffset
;
entry
.
size
=
type
.
getArraySize
(
)
;
entry
.
arrayStride
=
stride
;
entry
.
matrixStride
=
0
;
curOffset
+
=
stride
*
type
.
getArraySize
(
)
;
layout
.
uniforms
.
push
(
entry
)
;
}
else
if
(
elemType
.
isBasicType
(
)
&
&
gluShaderUtil
.
isDataTypeMatrix
(
elemType
.
getBasicType
(
)
)
)
{
elemBasicType
=
elemType
.
getBasicType
(
)
;
isRowMajor
=
!
!
(
layoutFlags
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_ROW_MAJOR
)
;
vecSize
=
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
elemBasicType
)
:
gluShaderUtil
.
getDataTypeMatrixNumRows
(
elemBasicType
)
;
numVecs
=
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumRows
(
elemBasicType
)
:
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
elemBasicType
)
;
stride
=
glsUniformBlockCase
.
getDataTypeArrayStride
(
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
)
;
entry
=
new
glsUniformBlockCase
.
UniformLayoutEntry
(
)
;
entry
.
name
=
curPrefix
+
'
[
0
]
'
;
entry
.
type
=
elemBasicType
;
entry
.
blockNdx
=
curBlockNdx
;
entry
.
offset
=
curOffset
;
entry
.
size
=
type
.
getArraySize
(
)
;
entry
.
arrayStride
=
stride
*
numVecs
;
entry
.
matrixStride
=
stride
;
entry
.
isRowMajor
=
isRowMajor
;
curOffset
+
=
numVecs
*
type
.
getArraySize
(
)
*
stride
;
layout
.
uniforms
.
push
(
entry
)
;
}
else
{
DE_ASSERT
(
elemType
.
isStructType
(
)
|
|
elemType
.
isArrayType
(
)
)
;
for
(
var
elemNdx
=
0
;
elemNdx
<
type
.
getArraySize
(
)
;
elemNdx
+
+
)
curOffset
=
glsUniformBlockCase
.
computeStd140Layout_B
(
layout
curOffset
curBlockNdx
curPrefix
+
'
[
'
+
elemNdx
+
'
]
'
type
.
getElementType
(
)
layoutFlags
)
;
}
}
else
{
DE_ASSERT
(
type
.
isStructType
(
)
)
;
for
(
var
memberNdx
=
0
;
memberNdx
<
type
.
getStruct
(
)
.
getSize
(
)
;
memberNdx
+
+
)
{
var
memberIter
=
type
.
getStruct
(
)
.
getMember
(
memberNdx
)
;
curOffset
=
glsUniformBlockCase
.
computeStd140Layout_B
(
layout
curOffset
curBlockNdx
curPrefix
+
'
.
'
+
memberIter
.
getName
(
)
memberIter
.
getType
(
)
layoutFlags
)
;
}
curOffset
=
deMath
.
deAlign32
(
curOffset
baseAlignment
)
;
}
return
curOffset
;
}
;
glsUniformBlockCase
.
computeStd140Layout
=
function
(
layout
sinterface
)
{
var
numUniformBlocks
=
sinterface
.
getNumUniformBlocks
(
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numUniformBlocks
;
blockNdx
+
+
)
{
var
block
=
sinterface
.
getUniformBlock
(
blockNdx
)
;
var
hasInstanceName
=
block
.
getInstanceName
(
)
!
=
=
undefined
;
var
blockPrefix
=
hasInstanceName
?
(
block
.
getBlockName
(
)
+
'
.
'
)
:
'
'
;
var
curOffset
=
0
;
var
activeBlockNdx
=
layout
.
blocks
.
length
;
var
firstUniformNdx
=
layout
.
uniforms
.
length
;
for
(
var
ubNdx
=
0
;
ubNdx
<
block
.
countUniforms
(
)
;
ubNdx
+
+
)
{
var
uniform
=
block
.
getUniform
(
ubNdx
)
;
curOffset
=
glsUniformBlockCase
.
computeStd140Layout_B
(
layout
curOffset
activeBlockNdx
blockPrefix
+
uniform
.
getName
(
)
uniform
.
getType
(
)
glsUniformBlockCase
.
mergeLayoutFlags
(
block
.
getFlags
(
)
uniform
.
getFlags
(
)
)
)
;
}
var
uniformIndicesEnd
=
layout
.
uniforms
.
length
;
var
blockSize
=
curOffset
;
var
numInstances
=
block
.
isArray
(
)
?
block
.
getArraySize
(
)
:
1
;
for
(
var
instanceNdx
=
0
;
instanceNdx
<
numInstances
;
instanceNdx
+
+
)
{
layout
.
blocks
.
push
(
new
glsUniformBlockCase
.
BlockLayoutEntry
(
)
)
;
var
blockEntry
=
layout
.
blocks
[
layout
.
blocks
.
length
-
1
]
;
blockEntry
.
name
=
block
.
getBlockName
(
)
;
blockEntry
.
size
=
blockSize
;
for
(
var
uniformNdx
=
firstUniformNdx
;
uniformNdx
<
uniformIndicesEnd
;
uniformNdx
+
+
)
blockEntry
.
activeUniformIndices
.
push
(
uniformNdx
)
;
if
(
block
.
isArray
(
)
)
blockEntry
.
name
+
=
'
[
'
+
instanceNdx
+
'
]
'
;
}
}
}
;
glsUniformBlockCase
.
generateValue
=
function
(
entry
basePtr
rnd
)
{
var
scalarType
=
gluShaderUtil
.
getDataTypeScalarTypeAsDataType
(
entry
.
type
)
;
var
scalarSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
entry
.
type
)
;
var
isMatrix
=
gluShaderUtil
.
isDataTypeMatrix
(
entry
.
type
)
;
var
numVecs
=
isMatrix
?
(
entry
.
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumRows
(
entry
.
type
)
:
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
entry
.
type
)
)
:
1
;
var
vecSize
=
scalarSize
/
numVecs
;
var
isArray
=
entry
.
size
>
1
;
var
compSize
=
deMath
.
INT32_SIZE
;
DE_ASSERT
(
scalarSize
%
numVecs
=
=
0
)
;
for
(
var
elemNdx
=
0
;
elemNdx
<
entry
.
size
;
elemNdx
+
+
)
{
var
elemPtr
=
basePtr
.
subarray
(
entry
.
offset
+
(
isArray
?
elemNdx
*
entry
.
arrayStride
:
0
)
)
;
for
(
var
vecNdx
=
0
;
vecNdx
<
numVecs
;
vecNdx
+
+
)
{
var
vecPtr
=
elemPtr
.
subarray
(
isMatrix
?
vecNdx
*
entry
.
matrixStride
:
0
)
;
for
(
var
compNdx
=
0
;
compNdx
<
vecSize
;
compNdx
+
+
)
{
var
compPtr
=
vecPtr
.
subarray
(
compSize
*
compNdx
)
;
var
_random
;
var
_size
=
glsUniformBlockCase
.
getDataTypeByteSize
(
scalarType
)
;
var
nbuffer
=
new
ArrayBuffer
(
_size
)
;
var
nview
=
new
DataView
(
nbuffer
)
;
switch
(
scalarType
)
{
case
gluShaderUtil
.
DataType
.
FLOAT
:
_random
=
rnd
.
getInt
(
-
9
9
)
;
nview
.
setFloat32
(
0
_random
littleEndian
)
;
break
;
case
gluShaderUtil
.
DataType
.
INT
:
_random
=
rnd
.
getInt
(
-
9
9
)
;
nview
.
setInt32
(
0
_random
littleEndian
)
;
break
;
case
gluShaderUtil
.
DataType
.
UINT
:
_random
=
rnd
.
getInt
(
0
9
)
;
nview
.
setUint32
(
0
_random
littleEndian
)
;
break
;
case
gluShaderUtil
.
DataType
.
BOOL
:
_random
=
rnd
.
getBool
(
)
?
1
:
0
;
nview
.
setUint32
(
0
_random
littleEndian
)
;
break
;
default
:
DE_ASSERT
(
false
)
;
}
for
(
var
i
=
0
;
i
<
_size
;
i
+
+
)
{
compPtr
[
i
]
=
nview
.
getUint8
(
i
)
;
}
}
}
}
}
;
glsUniformBlockCase
.
generateValues
=
function
(
layout
blockPointers
seed
)
{
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
var
numBlocks
=
layout
.
blocks
.
length
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
var
basePtr
=
blockPointers
.
find
(
blockNdx
)
;
var
numEntries
=
layout
.
blocks
[
blockNdx
]
.
activeUniformIndices
.
length
;
for
(
var
entryNdx
=
0
;
entryNdx
<
numEntries
;
entryNdx
+
+
)
{
var
entry
=
layout
.
uniforms
[
layout
.
blocks
[
blockNdx
]
.
activeUniformIndices
[
entryNdx
]
]
;
glsUniformBlockCase
.
generateValue
(
entry
basePtr
rnd
)
;
}
}
}
;
glsUniformBlockCase
.
getCompareFuncForType
=
function
(
type
)
{
switch
(
type
)
{
case
gluShaderUtil
.
DataType
.
FLOAT
:
return
'
mediump
float
compare_float
(
highp
float
a
highp
float
b
)
{
return
abs
(
a
-
b
)
<
0
.
05
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC2
:
return
'
mediump
float
compare_vec2
(
highp
vec2
a
highp
vec2
b
)
{
return
compare_float
(
a
.
x
b
.
x
)
*
compare_float
(
a
.
y
b
.
y
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC3
:
return
'
mediump
float
compare_vec3
(
highp
vec3
a
highp
vec3
b
)
{
return
compare_float
(
a
.
x
b
.
x
)
*
compare_float
(
a
.
y
b
.
y
)
*
compare_float
(
a
.
z
b
.
z
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC4
:
return
'
mediump
float
compare_vec4
(
highp
vec4
a
highp
vec4
b
)
{
return
compare_float
(
a
.
x
b
.
x
)
*
compare_float
(
a
.
y
b
.
y
)
*
compare_float
(
a
.
z
b
.
z
)
*
compare_float
(
a
.
w
b
.
w
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2
:
return
'
mediump
float
compare_mat2
(
highp
mat2
a
highp
mat2
b
)
{
return
compare_vec2
(
a
[
0
]
b
[
0
]
)
*
compare_vec2
(
a
[
1
]
b
[
1
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2X3
:
return
'
mediump
float
compare_mat2x3
(
highp
mat2x3
a
highp
mat2x3
b
)
{
return
compare_vec3
(
a
[
0
]
b
[
0
]
)
*
compare_vec3
(
a
[
1
]
b
[
1
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2X4
:
return
'
mediump
float
compare_mat2x4
(
highp
mat2x4
a
highp
mat2x4
b
)
{
return
compare_vec4
(
a
[
0
]
b
[
0
]
)
*
compare_vec4
(
a
[
1
]
b
[
1
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3X2
:
return
'
mediump
float
compare_mat3x2
(
highp
mat3x2
a
highp
mat3x2
b
)
{
return
compare_vec2
(
a
[
0
]
b
[
0
]
)
*
compare_vec2
(
a
[
1
]
b
[
1
]
)
*
compare_vec2
(
a
[
2
]
b
[
2
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3
:
return
'
mediump
float
compare_mat3
(
highp
mat3
a
highp
mat3
b
)
{
return
compare_vec3
(
a
[
0
]
b
[
0
]
)
*
compare_vec3
(
a
[
1
]
b
[
1
]
)
*
compare_vec3
(
a
[
2
]
b
[
2
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3X4
:
return
'
mediump
float
compare_mat3x4
(
highp
mat3x4
a
highp
mat3x4
b
)
{
return
compare_vec4
(
a
[
0
]
b
[
0
]
)
*
compare_vec4
(
a
[
1
]
b
[
1
]
)
*
compare_vec4
(
a
[
2
]
b
[
2
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4X2
:
return
'
mediump
float
compare_mat4x2
(
highp
mat4x2
a
highp
mat4x2
b
)
{
return
compare_vec2
(
a
[
0
]
b
[
0
]
)
*
compare_vec2
(
a
[
1
]
b
[
1
]
)
*
compare_vec2
(
a
[
2
]
b
[
2
]
)
*
compare_vec2
(
a
[
3
]
b
[
3
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4X3
:
return
'
mediump
float
compare_mat4x3
(
highp
mat4x3
a
highp
mat4x3
b
)
{
return
compare_vec3
(
a
[
0
]
b
[
0
]
)
*
compare_vec3
(
a
[
1
]
b
[
1
]
)
*
compare_vec3
(
a
[
2
]
b
[
2
]
)
*
compare_vec3
(
a
[
3
]
b
[
3
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4
:
return
'
mediump
float
compare_mat4
(
highp
mat4
a
highp
mat4
b
)
{
return
compare_vec4
(
a
[
0
]
b
[
0
]
)
*
compare_vec4
(
a
[
1
]
b
[
1
]
)
*
compare_vec4
(
a
[
2
]
b
[
2
]
)
*
compare_vec4
(
a
[
3
]
b
[
3
]
)
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
INT
:
return
'
mediump
float
compare_int
(
highp
int
a
highp
int
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
INT_VEC2
:
return
'
mediump
float
compare_ivec2
(
highp
ivec2
a
highp
ivec2
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
INT_VEC3
:
return
'
mediump
float
compare_ivec3
(
highp
ivec3
a
highp
ivec3
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
INT_VEC4
:
return
'
mediump
float
compare_ivec4
(
highp
ivec4
a
highp
ivec4
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
UINT
:
return
'
mediump
float
compare_uint
(
highp
uint
a
highp
uint
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
UINT_VEC2
:
return
'
mediump
float
compare_uvec2
(
highp
uvec2
a
highp
uvec2
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
UINT_VEC3
:
return
'
mediump
float
compare_uvec3
(
highp
uvec3
a
highp
uvec3
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
UINT_VEC4
:
return
'
mediump
float
compare_uvec4
(
highp
uvec4
a
highp
uvec4
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
BOOL
:
return
'
mediump
float
compare_bool
(
bool
a
bool
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
BOOL_VEC2
:
return
'
mediump
float
compare_bvec2
(
bvec2
a
bvec2
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
BOOL_VEC3
:
return
'
mediump
float
compare_bvec3
(
bvec3
a
bvec3
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
case
gluShaderUtil
.
DataType
.
BOOL_VEC4
:
return
'
mediump
float
compare_bvec4
(
bvec4
a
bvec4
b
)
{
return
a
=
=
b
?
1
.
0
:
0
.
0
;
}
\
n
'
;
default
:
throw
new
Error
(
'
Type
"
'
+
type
+
'
"
not
supported
.
'
)
;
}
}
;
glsUniformBlockCase
.
getCompareDependencies
=
function
(
compareFuncs
basicType
)
{
switch
(
basicType
)
{
case
gluShaderUtil
.
DataType
.
FLOAT_VEC2
:
case
gluShaderUtil
.
DataType
.
FLOAT_VEC3
:
case
gluShaderUtil
.
DataType
.
FLOAT_VEC4
:
deUtil
.
dePushUniqueToArray
(
compareFuncs
gluShaderUtil
.
DataType
.
FLOAT
)
;
deUtil
.
dePushUniqueToArray
(
compareFuncs
basicType
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2X3
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2X4
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3X2
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3X4
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4X2
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4X3
:
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4
:
deUtil
.
dePushUniqueToArray
(
compareFuncs
gluShaderUtil
.
DataType
.
FLOAT
)
;
deUtil
.
dePushUniqueToArray
(
compareFuncs
gluShaderUtil
.
getDataTypeFloatVec
(
gluShaderUtil
.
getDataTypeMatrixNumRows
(
basicType
)
)
)
;
deUtil
.
dePushUniqueToArray
(
compareFuncs
basicType
)
;
break
;
default
:
deUtil
.
dePushUniqueToArray
(
compareFuncs
basicType
)
;
break
;
}
}
;
glsUniformBlockCase
.
collectUniqueBasicTypes_B
=
function
(
basicTypes
type
)
{
if
(
type
.
isStructType
(
)
)
{
var
stype
=
type
.
getStruct
(
)
;
for
(
var
memberNdx
=
0
;
memberNdx
<
stype
.
getSize
(
)
;
memberNdx
+
+
)
glsUniformBlockCase
.
collectUniqueBasicTypes_B
(
basicTypes
stype
.
getMember
(
memberNdx
)
.
getType
(
)
)
;
}
else
if
(
type
.
isArrayType
(
)
)
glsUniformBlockCase
.
collectUniqueBasicTypes_B
(
basicTypes
type
.
getElementType
(
)
)
;
else
{
DE_ASSERT
(
type
.
isBasicType
(
)
)
;
deUtil
.
dePushUniqueToArray
(
basicTypes
type
.
getBasicType
(
)
)
;
}
}
;
glsUniformBlockCase
.
collectUniqueBasicTypes_A
=
function
(
basicTypes
uniformBlock
)
{
for
(
var
uniformNdx
=
0
;
uniformNdx
<
uniformBlock
.
countUniforms
(
)
;
uniformNdx
+
+
)
glsUniformBlockCase
.
collectUniqueBasicTypes_B
(
basicTypes
uniformBlock
.
getUniform
(
uniformNdx
)
.
getType
(
)
)
;
}
;
glsUniformBlockCase
.
collectUniqueBasicTypes
=
function
(
basicTypes
sinterface
)
{
for
(
var
ndx
=
0
;
ndx
<
sinterface
.
getNumUniformBlocks
(
)
;
+
+
ndx
)
glsUniformBlockCase
.
collectUniqueBasicTypes_A
(
basicTypes
sinterface
.
getUniformBlock
(
ndx
)
)
;
}
;
glsUniformBlockCase
.
generateCompareFuncs
=
function
(
sinterface
)
{
var
str
=
'
'
;
var
types
=
[
]
;
var
compareFuncs
=
[
]
;
glsUniformBlockCase
.
collectUniqueBasicTypes
(
types
sinterface
)
;
for
(
var
typeNdx
=
0
;
typeNdx
<
types
.
length
;
typeNdx
+
+
)
glsUniformBlockCase
.
getCompareDependencies
(
compareFuncs
types
[
typeNdx
]
)
;
for
(
var
type
in
gluShaderUtil
.
DataType
)
{
if
(
compareFuncs
.
indexOf
(
gluShaderUtil
.
DataType
[
type
]
)
>
-
1
)
str
+
=
glsUniformBlockCase
.
getCompareFuncForType
(
gluShaderUtil
.
DataType
[
type
]
)
;
}
return
str
;
}
;
glsUniformBlockCase
.
Indent
=
function
(
level_
)
{
var
str
=
'
'
;
for
(
var
i
=
0
;
i
<
level_
;
i
+
+
)
str
+
=
'
\
t
'
;
return
str
;
}
;
glsUniformBlockCase
.
generateDeclaration_C
=
function
(
structType
indentLevel
)
{
var
src
=
'
'
;
DE_ASSERT
(
structType
.
getTypeName
(
)
!
=
=
undefined
)
;
src
+
=
glsUniformBlockCase
.
generateFullDeclaration
(
structType
indentLevel
)
;
src
+
=
'
;
\
n
'
;
return
src
;
}
;
glsUniformBlockCase
.
generateFullDeclaration
=
function
(
structType
indentLevel
)
{
var
src
=
'
struct
'
;
if
(
structType
.
getTypeName
(
)
)
src
+
=
'
'
+
structType
.
getTypeName
(
)
;
src
+
=
'
\
n
'
+
glsUniformBlockCase
.
Indent
(
indentLevel
)
+
'
{
\
n
'
;
for
(
var
memberNdx
=
0
;
memberNdx
<
structType
.
getSize
(
)
;
memberNdx
+
+
)
{
src
+
=
glsUniformBlockCase
.
Indent
(
indentLevel
+
1
)
;
var
memberIter
=
structType
.
getMember
(
memberNdx
)
;
src
+
=
glsUniformBlockCase
.
generateDeclaration_B
(
memberIter
.
getType
(
)
memberIter
.
getName
(
)
indentLevel
+
1
memberIter
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
UNUSED_BOTH
)
;
}
src
+
=
glsUniformBlockCase
.
Indent
(
indentLevel
)
+
'
}
'
;
return
src
;
}
;
glsUniformBlockCase
.
generateLocalDeclaration
=
function
(
structType
indentLevel
)
{
var
src
=
'
'
;
if
(
structType
.
getTypeName
(
)
=
=
=
undefined
)
src
+
=
glsUniformBlockCase
.
generateFullDeclaration
(
structType
indentLevel
)
;
else
src
+
=
structType
.
getTypeName
(
)
;
return
src
;
}
;
glsUniformBlockCase
.
generateDeclaration_B
=
function
(
type
name
indentLevel
unusedHints
)
{
var
src
=
'
'
;
var
flags
=
type
.
getFlags
(
)
;
if
(
(
flags
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_MASK
)
!
=
0
)
src
+
=
'
layout
(
'
+
glsUniformBlockCase
.
LayoutFlagsFmt
(
flags
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_MASK
)
+
'
)
'
;
if
(
(
flags
&
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MASK
)
!
=
0
)
src
+
=
glsUniformBlockCase
.
PrecisionFlagsFmt
(
flags
&
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MASK
)
+
'
'
;
if
(
type
.
isBasicType
(
)
)
src
+
=
gluShaderUtil
.
getDataTypeName
(
type
.
getBasicType
(
)
)
+
'
'
+
name
;
else
if
(
type
.
isArrayType
(
)
)
{
var
arraySizes
=
[
]
;
var
curType
=
type
;
while
(
curType
.
isArrayType
(
)
)
{
arraySizes
.
push
(
curType
.
getArraySize
(
)
)
;
curType
=
curType
.
getElementType
(
)
;
}
if
(
curType
.
isBasicType
(
)
)
{
if
(
(
curType
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MASK
)
!
=
0
)
src
+
=
glsUniformBlockCase
.
PrecisionFlagsFmt
(
curType
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
PRECISION_MASK
)
+
'
'
;
src
+
=
gluShaderUtil
.
getDataTypeName
(
curType
.
getBasicType
(
)
)
;
}
else
{
DE_ASSERT
(
curType
.
isStructType
(
)
)
;
src
+
=
glsUniformBlockCase
.
generateLocalDeclaration
(
curType
.
getStruct
(
)
indentLevel
+
1
)
;
}
src
+
=
'
'
+
name
;
for
(
var
sizeNdx
=
0
;
sizeNdx
<
arraySizes
.
length
;
sizeNdx
+
+
)
src
+
=
'
[
'
+
arraySizes
[
sizeNdx
]
+
'
]
'
;
}
else
{
src
+
=
glsUniformBlockCase
.
generateLocalDeclaration
(
type
.
getStruct
(
)
indentLevel
+
1
)
;
src
+
=
'
'
+
name
;
}
src
+
=
'
;
'
;
if
(
unusedHints
!
=
0
)
src
+
=
'
/
/
unused
in
'
+
(
unusedHints
=
=
glsUniformBlockCase
.
UniformFlags
.
UNUSED_BOTH
?
'
both
shaders
'
:
unusedHints
=
=
glsUniformBlockCase
.
UniformFlags
.
UNUSED_VERTEX
?
'
vertex
shader
'
:
unusedHints
=
=
glsUniformBlockCase
.
UniformFlags
.
UNUSED_FRAGMENT
?
'
fragment
shader
'
:
'
?
?
?
'
)
;
src
+
=
'
\
n
'
;
return
src
;
}
;
glsUniformBlockCase
.
generateDeclaration_A
=
function
(
uniform
indentLevel
)
{
var
src
=
'
'
;
if
(
(
uniform
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_MASK
)
!
=
0
)
src
+
=
'
layout
(
'
+
glsUniformBlockCase
.
LayoutFlagsFmt
(
uniform
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_MASK
)
+
'
)
'
;
src
+
=
glsUniformBlockCase
.
generateDeclaration_B
(
uniform
.
getType
(
)
uniform
.
getName
(
)
indentLevel
uniform
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
UNUSED_BOTH
)
;
return
src
;
}
;
glsUniformBlockCase
.
generateDeclaration
=
function
(
block
)
{
var
src
=
'
'
;
if
(
(
block
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_MASK
)
!
=
0
)
src
+
=
'
layout
(
'
+
glsUniformBlockCase
.
LayoutFlagsFmt
(
block
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_MASK
)
+
'
)
'
;
src
+
=
'
uniform
'
+
block
.
getBlockName
(
)
;
src
+
=
'
\
n
{
\
n
'
;
for
(
var
uniformNdx
=
0
;
uniformNdx
<
block
.
countUniforms
(
)
;
uniformNdx
+
+
)
{
src
+
=
glsUniformBlockCase
.
Indent
(
1
)
;
src
+
=
glsUniformBlockCase
.
generateDeclaration_A
(
block
.
getUniform
(
uniformNdx
)
1
)
;
}
src
+
=
'
}
'
;
if
(
block
.
getInstanceName
(
)
!
=
=
undefined
)
{
src
+
=
'
'
+
block
.
getInstanceName
(
)
;
if
(
block
.
isArray
(
)
)
src
+
=
'
[
'
+
block
.
getArraySize
(
)
+
'
]
'
;
}
else
DE_ASSERT
(
!
block
.
isArray
(
)
)
;
src
+
=
'
;
\
n
'
;
return
src
;
}
;
glsUniformBlockCase
.
newArrayBufferFromView
=
function
(
view
)
{
var
buffer
=
new
ArrayBuffer
(
view
.
length
*
view
.
BYTES_PER_ELEMENT
)
;
var
copyview
;
switch
(
view
.
BYTES_PER_ELEMENT
)
{
case
1
:
copyview
=
new
Uint8Array
(
buffer
)
;
break
;
case
2
:
copyview
=
new
Uint16Array
(
buffer
)
;
break
;
case
4
:
copyview
=
new
Uint32Array
(
buffer
)
;
break
;
default
:
assertMsgOptions
(
false
'
Unexpected
value
for
BYTES_PER_ELEMENT
in
view
'
false
true
)
;
}
for
(
var
i
=
0
;
i
<
view
.
length
;
i
+
+
)
copyview
[
i
]
=
view
[
i
]
;
return
buffer
;
}
;
glsUniformBlockCase
.
generateValueSrc
=
function
(
entry
basePtr
elementNdx
)
{
var
src
=
'
'
;
var
scalarType
=
gluShaderUtil
.
getDataTypeScalarTypeAsDataType
(
entry
.
type
)
;
var
scalarSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
entry
.
type
)
;
var
isArray
=
entry
.
size
>
1
;
var
elemPtr
=
basePtr
.
subarray
(
entry
.
offset
+
(
isArray
?
elementNdx
*
entry
.
arrayStride
:
0
)
)
;
var
compSize
=
deMath
.
INT32_SIZE
;
var
compPtr
;
if
(
scalarSize
>
1
)
src
+
=
gluShaderUtil
.
getDataTypeName
(
entry
.
type
)
+
'
(
'
;
if
(
gluShaderUtil
.
isDataTypeMatrix
(
entry
.
type
)
)
{
var
numRows
=
gluShaderUtil
.
getDataTypeMatrixNumRows
(
entry
.
type
)
;
var
numCols
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
entry
.
type
)
;
DE_ASSERT
(
scalarType
=
=
gluShaderUtil
.
DataType
.
FLOAT
)
;
for
(
var
colNdx
=
0
;
colNdx
<
numCols
;
colNdx
+
+
)
{
for
(
var
rowNdx
=
0
;
rowNdx
<
numRows
;
rowNdx
+
+
)
{
compPtr
=
elemPtr
.
subarray
(
entry
.
isRowMajor
?
rowNdx
*
entry
.
matrixStride
+
colNdx
*
compSize
:
colNdx
*
entry
.
matrixStride
+
rowNdx
*
compSize
)
;
if
(
colNdx
>
0
|
|
rowNdx
>
0
)
src
+
=
'
'
;
var
newbuffer
=
new
Uint8Array
(
compPtr
.
subarray
(
0
4
)
)
.
buffer
;
var
newview
=
new
DataView
(
newbuffer
)
;
src
+
=
parseFloat
(
newview
.
getFloat32
(
0
littleEndian
)
)
.
toFixed
(
1
)
;
}
}
}
else
{
for
(
var
scalarNdx
=
0
;
scalarNdx
<
scalarSize
;
scalarNdx
+
+
)
{
compPtr
=
elemPtr
.
subarray
(
scalarNdx
*
compSize
)
;
if
(
scalarNdx
>
0
)
src
+
=
'
'
;
var
newbuffer
=
glsUniformBlockCase
.
newArrayBufferFromView
(
compPtr
.
subarray
(
0
4
)
)
;
var
newview
=
new
DataView
(
newbuffer
)
;
switch
(
scalarType
)
{
case
gluShaderUtil
.
DataType
.
FLOAT
:
src
+
=
parseFloat
(
newview
.
getFloat32
(
0
littleEndian
)
*
100
/
100
)
.
toFixed
(
1
)
;
break
;
case
gluShaderUtil
.
DataType
.
INT
:
src
+
=
newview
.
getInt32
(
0
littleEndian
)
;
break
;
case
gluShaderUtil
.
DataType
.
UINT
:
src
+
=
newview
.
getUint32
(
0
littleEndian
)
+
'
u
'
;
break
;
case
gluShaderUtil
.
DataType
.
BOOL
:
src
+
=
(
newview
.
getUint32
(
0
littleEndian
)
!
=
0
?
'
true
'
:
'
false
'
)
;
break
;
default
:
DE_ASSERT
(
false
)
;
}
}
}
if
(
scalarSize
>
1
)
src
+
=
'
)
'
;
return
src
;
}
;
glsUniformBlockCase
.
generateCompareSrc_A
=
function
(
resultVar
type
srcName
apiName
layout
basePtr
unusedMask
)
{
var
src
=
'
'
;
var
op
;
var
elementType
;
if
(
type
.
isBasicType
(
)
|
|
(
type
.
isArrayType
(
)
&
&
type
.
getElementType
(
)
.
isBasicType
(
)
)
)
{
var
isArray
=
type
.
isArrayType
(
)
;
elementType
=
isArray
?
type
.
getElementType
(
)
.
getBasicType
(
)
:
type
.
getBasicType
(
)
;
var
typeName
=
gluShaderUtil
.
getDataTypeName
(
elementType
)
;
var
fullApiName
=
apiName
+
(
isArray
?
'
[
0
]
'
:
'
'
)
;
var
uniformNdx
=
layout
.
getUniformIndex
(
fullApiName
)
;
var
entry
=
layout
.
uniforms
[
uniformNdx
]
;
if
(
isArray
)
{
for
(
var
elemNdx
=
0
;
elemNdx
<
type
.
getArraySize
(
)
;
elemNdx
+
+
)
{
src
+
=
'
\
tresult
*
=
compare_
'
+
typeName
+
'
(
'
+
srcName
+
'
[
'
+
elemNdx
+
'
]
'
;
src
+
=
glsUniformBlockCase
.
generateValueSrc
(
entry
basePtr
elemNdx
)
;
src
+
=
'
)
;
\
n
'
;
}
}
else
{
src
+
=
'
\
tresult
*
=
compare_
'
+
typeName
+
'
(
'
+
srcName
+
'
'
;
src
+
=
glsUniformBlockCase
.
generateValueSrc
(
entry
basePtr
0
)
;
src
+
=
'
)
;
\
n
'
;
}
}
else
if
(
type
.
isArrayType
(
)
)
{
elementType
=
type
.
getElementType
(
)
;
for
(
var
elementNdx
=
0
;
elementNdx
<
type
.
getArraySize
(
)
;
elementNdx
+
+
)
{
op
=
'
[
'
+
elementNdx
+
'
]
'
;
src
+
=
glsUniformBlockCase
.
generateCompareSrc_A
(
resultVar
elementType
srcName
+
op
apiName
+
op
layout
basePtr
unusedMask
)
;
}
}
else
{
DE_ASSERT
(
type
.
isStructType
(
)
)
;
var
stype
=
type
.
getStruct
(
)
;
for
(
var
memberNdx
=
0
;
memberNdx
<
stype
.
getSize
(
)
;
memberNdx
+
+
)
{
var
memberIter
=
stype
.
getMember
(
memberNdx
)
;
if
(
memberIter
.
getFlags
(
)
&
unusedMask
)
continue
;
op
=
'
.
'
+
memberIter
.
getName
(
)
;
src
+
=
glsUniformBlockCase
.
generateCompareSrc_A
(
resultVar
memberIter
.
getType
(
)
srcName
+
op
apiName
+
op
layout
basePtr
unusedMask
)
;
}
}
return
src
;
}
;
glsUniformBlockCase
.
generateCompareSrc
=
function
(
resultVar
sinterface
layout
blockPointers
isVertex
)
{
var
src
=
'
'
;
var
unusedMask
=
isVertex
?
glsUniformBlockCase
.
UniformFlags
.
UNUSED_VERTEX
:
glsUniformBlockCase
.
UniformFlags
.
UNUSED_FRAGMENT
;
for
(
var
blockNdx
=
0
;
blockNdx
<
sinterface
.
getNumUniformBlocks
(
)
;
blockNdx
+
+
)
{
var
block
=
sinterface
.
getUniformBlock
(
blockNdx
)
;
if
(
(
block
.
getFlags
(
)
&
(
isVertex
?
glsUniformBlockCase
.
UniformFlags
.
DECLARE_VERTEX
:
glsUniformBlockCase
.
UniformFlags
.
DECLARE_FRAGMENT
)
)
=
=
0
)
continue
;
var
hasInstanceName
=
block
.
getInstanceName
(
)
!
=
=
undefined
;
var
isArray
=
block
.
isArray
(
)
;
var
numInstances
=
isArray
?
block
.
getArraySize
(
)
:
1
;
var
apiPrefix
=
hasInstanceName
?
block
.
getBlockName
(
)
+
'
.
'
:
'
'
;
DE_ASSERT
(
!
isArray
|
|
hasInstanceName
)
;
for
(
var
instanceNdx
=
0
;
instanceNdx
<
numInstances
;
instanceNdx
+
+
)
{
var
instancePostfix
=
isArray
?
'
[
'
+
instanceNdx
+
'
]
'
:
'
'
;
var
blockInstanceName
=
block
.
getBlockName
(
)
+
instancePostfix
;
var
srcPrefix
=
hasInstanceName
?
block
.
getInstanceName
(
)
+
instancePostfix
+
'
.
'
:
'
'
;
var
activeBlockNdx
=
layout
.
getBlockIndex
(
blockInstanceName
)
;
var
basePtr
=
blockPointers
.
find
(
activeBlockNdx
)
;
for
(
var
uniformNdx
=
0
;
uniformNdx
<
block
.
countUniforms
(
)
;
uniformNdx
+
+
)
{
var
uniform
=
block
.
getUniform
(
uniformNdx
)
;
if
(
uniform
.
getFlags
(
)
&
unusedMask
)
continue
;
src
+
=
glsUniformBlockCase
.
generateCompareSrc_A
(
resultVar
uniform
.
getType
(
)
srcPrefix
+
uniform
.
getName
(
)
apiPrefix
+
uniform
.
getName
(
)
layout
basePtr
unusedMask
)
;
}
}
}
return
src
;
}
;
glsUniformBlockCase
.
generateVertexShader
=
function
(
sinterface
layout
blockPointers
)
{
var
src
=
'
'
;
DE_ASSERT
(
glsUniformBlockCase
.
isSupportedGLSLVersion
(
gluShaderUtil
.
getGLSLVersion
(
gl
)
)
)
;
src
+
=
gluShaderUtil
.
getGLSLVersionDeclaration
(
gluShaderUtil
.
getGLSLVersion
(
gl
)
)
+
'
\
n
'
;
src
+
=
'
in
highp
vec4
a_position
;
\
n
'
;
src
+
=
'
out
mediump
float
v_vtxResult
;
\
n
'
;
src
+
=
'
\
n
'
;
var
namedStructs
=
[
]
;
sinterface
.
getNamedStructs
(
namedStructs
)
;
for
(
var
structNdx
=
0
;
structNdx
<
namedStructs
.
length
;
structNdx
+
+
)
src
+
=
glsUniformBlockCase
.
generateDeclaration_C
(
namedStructs
[
structNdx
]
0
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
sinterface
.
getNumUniformBlocks
(
)
;
blockNdx
+
+
)
{
var
block
=
sinterface
.
getUniformBlock
(
blockNdx
)
;
if
(
block
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
DECLARE_VERTEX
)
src
+
=
glsUniformBlockCase
.
generateDeclaration
(
block
)
;
}
src
+
=
'
\
n
'
;
src
+
=
glsUniformBlockCase
.
generateCompareFuncs
(
sinterface
)
;
src
+
=
'
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
mediump
float
result
=
1
.
0
;
\
n
'
;
src
+
=
glsUniformBlockCase
.
generateCompareSrc
(
'
result
'
sinterface
layout
blockPointers
true
)
;
src
+
=
'
v_vtxResult
=
result
;
\
n
'
+
'
}
\
n
'
;
return
src
;
}
;
glsUniformBlockCase
.
generateFragmentShader
=
function
(
sinterface
layout
blockPointers
)
{
var
src
=
'
'
;
DE_ASSERT
(
glsUniformBlockCase
.
isSupportedGLSLVersion
(
gluShaderUtil
.
getGLSLVersion
(
gl
)
)
)
;
src
+
=
gluShaderUtil
.
getGLSLVersionDeclaration
(
gluShaderUtil
.
getGLSLVersion
(
gl
)
)
+
'
\
n
'
;
src
+
=
'
in
mediump
float
v_vtxResult
;
\
n
'
;
src
+
=
'
layout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
;
src
+
=
'
\
n
'
;
var
namedStructs
=
[
]
;
sinterface
.
getNamedStructs
(
namedStructs
)
;
for
(
var
structNdx
=
0
;
structNdx
<
namedStructs
.
length
;
structNdx
+
+
)
src
+
=
glsUniformBlockCase
.
generateDeclaration_C
(
namedStructs
[
structNdx
]
0
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
sinterface
.
getNumUniformBlocks
(
)
;
blockNdx
+
+
)
{
var
block
=
sinterface
.
getUniformBlock
(
blockNdx
)
;
if
(
block
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
DECLARE_FRAGMENT
)
src
+
=
glsUniformBlockCase
.
generateDeclaration
(
block
)
;
}
src
+
=
'
\
n
'
;
src
+
=
glsUniformBlockCase
.
generateCompareFuncs
(
sinterface
)
;
src
+
=
'
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
mediump
float
result
=
1
.
0
;
\
n
'
;
src
+
=
glsUniformBlockCase
.
generateCompareSrc
(
'
result
'
sinterface
layout
blockPointers
false
)
;
src
+
=
'
dEQP_FragColor
=
vec4
(
1
.
0
v_vtxResult
result
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
return
src
;
}
;
glsUniformBlockCase
.
getGLUniformLayout
=
function
(
gl
layout
program
)
{
var
numActiveUniforms
=
0
;
var
numActiveBlocks
=
0
;
numActiveUniforms
=
(
gl
.
getProgramParameter
(
program
gl
.
ACTIVE_UNIFORMS
)
)
;
numActiveBlocks
=
(
gl
.
getProgramParameter
(
program
gl
.
ACTIVE_UNIFORM_BLOCKS
)
)
;
var
entryBlock
;
var
entryUniform
;
var
size
;
var
nameLen
;
var
nameBuf
;
var
numBlockUniforms
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numActiveBlocks
;
blockNdx
+
+
)
{
entryBlock
=
new
glsUniformBlockCase
.
BlockLayoutEntry
(
)
;
size
=
(
gl
.
getActiveUniformBlockParameter
(
program
blockNdx
gl
.
UNIFORM_BLOCK_DATA_SIZE
)
)
;
numBlockUniforms
=
(
gl
.
getActiveUniformBlockParameter
(
program
blockNdx
gl
.
UNIFORM_BLOCK_ACTIVE_UNIFORMS
)
)
;
nameBuf
=
gl
.
getActiveUniformBlockName
(
program
blockNdx
)
;
entryBlock
.
name
=
nameBuf
;
entryBlock
.
size
=
size
;
if
(
numBlockUniforms
>
0
)
entryBlock
.
activeUniformIndices
=
gl
.
getActiveUniformBlockParameter
(
program
blockNdx
gl
.
UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES
)
;
layout
.
blocks
.
push
(
entryBlock
)
;
}
if
(
numActiveUniforms
>
0
)
{
var
uniformIndices
=
[
]
;
for
(
var
i
=
0
;
i
<
numActiveUniforms
;
i
+
+
)
uniformIndices
.
push
(
i
)
;
var
types
=
[
]
;
var
sizes
=
[
]
;
var
nameLengths
=
[
]
;
var
blockIndices
=
[
]
;
var
offsets
=
[
]
;
var
arrayStrides
=
[
]
;
var
matrixStrides
=
[
]
;
var
rowMajorFlags
=
[
]
;
types
=
gl
.
getActiveUniforms
(
program
uniformIndices
gl
.
UNIFORM_TYPE
)
;
sizes
=
gl
.
getActiveUniforms
(
program
uniformIndices
gl
.
UNIFORM_SIZE
)
;
blockIndices
=
gl
.
getActiveUniforms
(
program
uniformIndices
gl
.
UNIFORM_BLOCK_INDEX
)
;
offsets
=
gl
.
getActiveUniforms
(
program
uniformIndices
gl
.
UNIFORM_OFFSET
)
;
arrayStrides
=
gl
.
getActiveUniforms
(
program
uniformIndices
gl
.
UNIFORM_ARRAY_STRIDE
)
;
matrixStrides
=
gl
.
getActiveUniforms
(
program
uniformIndices
gl
.
UNIFORM_MATRIX_STRIDE
)
;
rowMajorFlags
=
gl
.
getActiveUniforms
(
program
uniformIndices
gl
.
UNIFORM_IS_ROW_MAJOR
)
;
for
(
var
uniformNdx
=
0
;
uniformNdx
<
numActiveUniforms
;
uniformNdx
+
+
)
{
entryUniform
=
new
glsUniformBlockCase
.
UniformLayoutEntry
(
)
;
size
=
0
;
var
type
=
gl
.
NONE
;
var
uniform
=
gl
.
getActiveUniform
(
program
uniformNdx
)
;
nameBuf
=
uniform
.
name
;
size
=
uniform
.
size
;
type
=
uniform
.
type
;
if
(
size
!
=
sizes
[
uniformNdx
]
|
|
type
!
=
types
[
uniformNdx
]
)
testFailedOptions
(
"
Values
returned
by
gl
.
getActiveUniform
(
)
don
'
t
match
with
values
queried
with
gl
.
getActiveUniforms
(
)
.
"
true
)
;
entryUniform
.
name
=
nameBuf
;
entryUniform
.
type
=
gluShaderUtil
.
getDataTypeFromGLType
(
types
[
uniformNdx
]
)
;
entryUniform
.
size
=
sizes
[
uniformNdx
]
;
entryUniform
.
blockNdx
=
blockIndices
[
uniformNdx
]
;
entryUniform
.
offset
=
offsets
[
uniformNdx
]
;
entryUniform
.
arrayStride
=
arrayStrides
[
uniformNdx
]
;
entryUniform
.
matrixStride
=
matrixStrides
[
uniformNdx
]
;
entryUniform
.
isRowMajor
=
rowMajorFlags
[
uniformNdx
]
!
=
false
;
layout
.
uniforms
.
push
(
entryUniform
)
;
}
}
}
;
glsUniformBlockCase
.
copyUniformData_A
=
function
(
dstEntry
dstBlockPtr
srcEntry
srcBlockPtr
)
{
var
dstBasePtr
=
dstBlockPtr
.
subarray
(
dstEntry
.
offset
)
;
var
srcBasePtr
=
srcBlockPtr
.
subarray
(
srcEntry
.
offset
)
;
DE_ASSERT
(
dstEntry
.
size
<
=
srcEntry
.
size
)
;
DE_ASSERT
(
dstEntry
.
type
=
=
srcEntry
.
type
)
;
var
scalarSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
dstEntry
.
type
)
;
var
isMatrix
=
gluShaderUtil
.
isDataTypeMatrix
(
dstEntry
.
type
)
;
var
compSize
=
deMath
.
INT32_SIZE
;
for
(
var
elementNdx
=
0
;
elementNdx
<
dstEntry
.
size
;
elementNdx
+
+
)
{
var
dstElemPtr
=
dstBasePtr
.
subarray
(
elementNdx
*
dstEntry
.
arrayStride
)
;
var
srcElemPtr
=
srcBasePtr
.
subarray
(
elementNdx
*
srcEntry
.
arrayStride
)
;
if
(
isMatrix
)
{
var
numRows
=
gluShaderUtil
.
getDataTypeMatrixNumRows
(
dstEntry
.
type
)
;
var
numCols
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
dstEntry
.
type
)
;
for
(
var
colNdx
=
0
;
colNdx
<
numCols
;
colNdx
+
+
)
{
for
(
var
rowNdx
=
0
;
rowNdx
<
numRows
;
rowNdx
+
+
)
{
var
srcoffset
=
dstEntry
.
isRowMajor
?
rowNdx
*
dstEntry
.
matrixStride
+
colNdx
*
compSize
:
colNdx
*
dstEntry
.
matrixStride
+
rowNdx
*
compSize
;
var
dstCompPtr
=
dstElemPtr
.
subarray
(
srcoffset
srcoffset
+
compSize
)
;
var
dstoffset
=
srcEntry
.
isRowMajor
?
rowNdx
*
srcEntry
.
matrixStride
+
colNdx
*
compSize
:
colNdx
*
srcEntry
.
matrixStride
+
rowNdx
*
compSize
;
var
srcCompPtr
=
srcElemPtr
.
subarray
(
dstoffset
dstoffset
+
compSize
)
;
for
(
var
i
=
0
;
i
<
compSize
;
i
+
+
)
dstCompPtr
[
i
]
=
srcCompPtr
[
i
]
;
}
}
}
else
for
(
var
i
=
0
;
i
<
scalarSize
*
compSize
;
i
+
+
)
dstElemPtr
[
i
]
=
srcElemPtr
[
i
]
;
}
}
;
glsUniformBlockCase
.
copyUniformData
=
function
(
dstLayout
dstBlockPointers
srcLayout
srcBlockPointers
)
{
var
numBlocks
=
srcLayout
.
blocks
.
length
;
for
(
var
srcBlockNdx
=
0
;
srcBlockNdx
<
numBlocks
;
srcBlockNdx
+
+
)
{
var
srcBlock
=
srcLayout
.
blocks
[
srcBlockNdx
]
;
var
srcBlockPtr
=
srcBlockPointers
.
find
(
srcBlockNdx
)
;
var
dstBlockNdx
=
dstLayout
.
getBlockIndex
(
srcBlock
.
name
)
;
var
dstBlockPtr
=
dstBlockNdx
>
=
0
?
dstBlockPointers
.
find
(
dstBlockNdx
)
:
null
;
if
(
dstBlockNdx
<
0
)
continue
;
for
(
var
srcUniformNdx
=
0
;
srcUniformNdx
<
srcBlock
.
activeUniformIndices
.
length
;
srcUniformNdx
+
+
)
{
var
srcUniformNdxIter
=
srcBlock
.
activeUniformIndices
[
srcUniformNdx
]
;
var
srcEntry
=
srcLayout
.
uniforms
[
srcUniformNdxIter
]
;
var
dstUniformNdx
=
dstLayout
.
getUniformIndex
(
srcEntry
.
name
)
;
if
(
dstUniformNdx
<
0
)
continue
;
glsUniformBlockCase
.
copyUniformData_A
(
dstLayout
.
uniforms
[
dstUniformNdx
]
dstBlockPtr
srcEntry
srcBlockPtr
)
;
}
}
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
iterate
=
function
(
)
{
var
refLayout
=
new
glsUniformBlockCase
.
UniformLayout
(
)
;
var
blockPointers
=
new
glsUniformBlockCase
.
BlockPointers
(
)
;
glsUniformBlockCase
.
computeStd140Layout
(
refLayout
this
.
m_interface
)
;
var
totalSize
=
0
;
for
(
var
blockNdx
=
0
;
blockNdx
<
refLayout
.
blocks
.
length
;
blockNdx
+
+
)
{
var
blockIter
=
refLayout
.
blocks
[
blockNdx
]
;
totalSize
+
=
blockIter
.
size
;
}
blockPointers
.
resize
(
totalSize
)
;
var
curOffset
=
0
;
for
(
var
blockNdx
=
0
;
blockNdx
<
refLayout
.
blocks
.
length
;
blockNdx
+
+
)
{
var
size
=
refLayout
.
blocks
[
blockNdx
]
.
size
;
blockPointers
.
push
(
curOffset
size
)
;
curOffset
+
=
size
;
}
glsUniformBlockCase
.
generateValues
(
refLayout
blockPointers
1
)
;
var
vtxSrc
=
glsUniformBlockCase
.
generateVertexShader
(
this
.
m_interface
refLayout
blockPointers
)
;
var
fragSrc
=
glsUniformBlockCase
.
generateFragmentShader
(
this
.
m_interface
refLayout
blockPointers
)
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vtxSrc
fragSrc
)
)
;
bufferedLogToConsole
(
program
.
getProgramInfo
(
)
.
infoLog
)
;
if
(
!
program
.
isOk
(
)
)
{
testFailedOptions
(
'
Compile
failed
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
var
glLayout
=
new
glsUniformBlockCase
.
UniformLayout
(
)
;
glsUniformBlockCase
.
getGLUniformLayout
(
gl
glLayout
program
.
getProgram
(
)
)
;
bufferedLogToConsole
(
'
Active
glsUniformBlockCase
.
Uniform
Blocks
'
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
glLayout
.
blocks
.
length
;
blockNdx
+
+
)
bufferedLogToConsole
(
blockNdx
+
'
:
'
+
glLayout
.
blocks
[
blockNdx
]
)
;
bufferedLogToConsole
(
'
Active
Uniforms
'
)
;
for
(
var
uniformNdx
=
0
;
uniformNdx
<
glLayout
.
uniforms
.
length
;
uniformNdx
+
+
)
bufferedLogToConsole
(
uniformNdx
+
'
:
'
+
glLayout
.
uniforms
[
uniformNdx
]
)
;
if
(
!
this
.
checkLayoutIndices
(
glLayout
)
|
|
!
this
.
checkLayoutBounds
(
glLayout
)
|
|
!
this
.
compareTypes
(
refLayout
glLayout
)
)
{
testFailedOptions
(
'
Invalid
layout
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
if
(
!
this
.
compareStd140Blocks
(
refLayout
glLayout
)
)
testFailedOptions
(
'
Invalid
std140
layout
'
false
)
;
if
(
!
this
.
compareSharedBlocks
(
refLayout
glLayout
)
)
testFailedOptions
(
'
Invalid
shared
layout
'
false
)
;
if
(
!
this
.
checkIndexQueries
(
program
.
getProgram
(
)
glLayout
)
)
testFailedOptions
(
'
Inconsintent
block
index
query
results
'
false
)
;
gl
.
useProgram
(
program
.
getProgram
(
)
)
;
var
binding
;
var
buffer
;
for
(
var
blockNdx
=
0
;
blockNdx
<
glLayout
.
blocks
.
length
;
blockNdx
+
+
)
{
binding
=
blockNdx
;
gl
.
uniformBlockBinding
(
program
.
getProgram
(
)
blockNdx
binding
)
;
}
var
numBlocks
;
var
glBlockPointers
;
var
bufferManager
=
new
glsUniformBlockCase
.
UniformBufferManager
(
gl
)
;
if
(
this
.
m_bufferMode
=
=
glsUniformBlockCase
.
BufferMode
.
BUFFERMODE_PER_BLOCK
)
{
numBlocks
=
glLayout
.
blocks
.
length
;
glBlockPointers
=
new
glsUniformBlockCase
.
BlockPointers
(
)
;
var
totalsize
=
0
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
totalsize
+
=
glLayout
.
blocks
[
blockNdx
]
.
size
;
glBlockPointers
.
resize
(
totalsize
)
;
var
offset
=
0
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
glBlockPointers
.
push
(
offset
glLayout
.
blocks
[
blockNdx
]
.
size
)
;
offset
+
=
glLayout
.
blocks
[
blockNdx
]
.
size
;
}
glsUniformBlockCase
.
copyUniformData
(
glLayout
glBlockPointers
refLayout
blockPointers
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
buffer
=
bufferManager
.
allocBuffer
(
)
;
binding
=
blockNdx
;
gl
.
bindBuffer
(
gl
.
UNIFORM_BUFFER
buffer
)
;
gl
.
bufferData
(
gl
.
UNIFORM_BUFFER
glBlockPointers
.
find
(
blockNdx
)
gl
.
STATIC_DRAW
)
;
gl
.
bindBufferBase
(
gl
.
UNIFORM_BUFFER
binding
buffer
)
;
}
}
else
{
DE_ASSERT
(
this
.
m_bufferMode
=
=
glsUniformBlockCase
.
BufferMode
.
BUFFERMODE_SINGLE
)
;
totalSize
=
0
;
curOffset
=
0
;
numBlocks
=
glLayout
.
blocks
.
length
;
var
bindingAlignment
=
0
;
glBlockPointers
=
new
glsUniformBlockCase
.
BlockPointers
(
)
;
bindingAlignment
=
(
gl
.
getParameter
(
gl
.
UNIFORM_BUFFER_OFFSET_ALIGNMENT
)
)
;
curOffset
=
0
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
if
(
bindingAlignment
>
0
)
curOffset
=
glsUniformBlockCase
.
deRoundUp32
(
curOffset
bindingAlignment
)
;
glBlockPointers
.
push
(
curOffset
glLayout
.
blocks
[
blockNdx
]
.
size
)
;
curOffset
+
=
glLayout
.
blocks
[
blockNdx
]
.
size
;
}
totalSize
=
curOffset
;
glBlockPointers
.
resize
(
totalSize
)
;
glsUniformBlockCase
.
copyUniformData
(
glLayout
glBlockPointers
refLayout
blockPointers
)
;
buffer
=
bufferManager
.
allocBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
UNIFORM_BUFFER
buffer
)
;
if
(
glBlockPointers
.
data
.
byteLength
>
0
)
gl
.
bufferData
(
gl
.
UNIFORM_BUFFER
glBlockPointers
.
find
(
blockNdx
)
gl
.
STATIC_DRAW
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
binding
=
blockNdx
;
gl
.
bindBufferRange
(
gl
.
UNIFORM_BUFFER
binding
buffer
glBlockPointers
.
offsets
[
blockNdx
]
glLayout
.
blocks
[
blockNdx
]
.
size
)
;
}
}
var
renderOk
=
this
.
render
(
program
)
;
if
(
!
renderOk
)
testFailedOptions
(
'
Image
compare
failed
'
false
)
;
else
assertMsgOptions
(
renderOk
'
'
true
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
compareStd140Blocks
=
function
(
refLayout
cmpLayout
)
{
var
isOk
=
true
;
var
numBlocks
=
this
.
m_interface
.
getNumUniformBlocks
(
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
var
block
=
this
.
m_interface
.
getUniformBlock
(
blockNdx
)
;
var
isArray
=
block
.
isArray
(
)
;
var
instanceName
=
block
.
getBlockName
(
)
+
(
isArray
?
'
[
0
]
'
:
'
'
)
;
var
refBlockNdx
=
refLayout
.
getBlockIndex
(
instanceName
)
;
var
cmpBlockNdx
=
cmpLayout
.
getBlockIndex
(
instanceName
)
;
var
isUsed
=
(
block
.
getFlags
(
)
&
(
glsUniformBlockCase
.
UniformFlags
.
DECLARE_VERTEX
|
glsUniformBlockCase
.
UniformFlags
.
DECLARE_FRAGMENT
)
)
!
=
0
;
if
(
(
block
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_STD140
)
=
=
0
)
continue
;
DE_ASSERT
(
refBlockNdx
>
=
0
)
;
if
(
cmpBlockNdx
<
0
)
{
if
(
isUsed
)
{
bufferedLogToConsole
(
"
Error
:
glsUniformBlockCase
.
Uniform
block
'
"
+
instanceName
+
"
'
not
found
"
)
;
isOk
=
false
;
}
continue
;
}
var
refBlockLayout
=
refLayout
.
blocks
[
refBlockNdx
]
;
var
cmpBlockLayout
=
cmpLayout
.
blocks
[
cmpBlockNdx
]
;
if
(
refBlockLayout
.
activeUniformIndices
.
length
!
=
cmpBlockLayout
.
activeUniformIndices
.
length
)
{
bufferedLogToConsole
(
"
Error
:
Number
of
active
uniforms
differ
in
block
'
"
+
instanceName
+
"
'
(
expected
"
+
refBlockLayout
.
activeUniformIndices
.
length
+
'
got
'
+
cmpBlockLayout
.
activeUniformIndices
.
length
+
'
)
'
)
;
isOk
=
false
;
}
for
(
var
ndx
=
0
;
ndx
<
refBlockLayout
.
activeUniformIndices
.
length
;
ndx
+
+
)
{
var
ndxIter
=
refBlockLayout
.
activeUniformIndices
[
ndx
]
;
var
refEntry
=
refLayout
.
uniforms
[
ndxIter
]
;
var
cmpEntryNdx
=
cmpLayout
.
getUniformIndex
(
refEntry
.
name
)
;
if
(
cmpEntryNdx
<
0
)
{
bufferedLogToConsole
(
"
Error
:
glsUniformBlockCase
.
Uniform
'
"
+
refEntry
.
name
+
"
'
not
found
"
)
;
isOk
=
false
;
continue
;
}
var
cmpEntry
=
cmpLayout
.
uniforms
[
cmpEntryNdx
]
;
if
(
refEntry
.
type
!
=
cmpEntry
.
type
|
|
refEntry
.
size
!
=
cmpEntry
.
size
|
|
refEntry
.
offset
!
=
cmpEntry
.
offset
|
|
refEntry
.
arrayStride
!
=
cmpEntry
.
arrayStride
|
|
refEntry
.
matrixStride
!
=
cmpEntry
.
matrixStride
|
|
refEntry
.
isRowMajor
!
=
cmpEntry
.
isRowMajor
)
{
bufferedLogToConsole
(
"
Error
:
Layout
mismatch
in
'
"
+
refEntry
.
name
+
"
'
:
\
n
"
+
'
expected
:
type
=
'
+
gluShaderUtil
.
getDataTypeName
(
refEntry
.
type
)
+
'
size
=
'
+
refEntry
.
size
+
'
row
major
=
'
+
(
refEntry
.
isRowMajor
?
'
true
'
:
'
false
'
)
+
'
\
n
'
+
'
got
:
type
=
'
+
gluShaderUtil
.
getDataTypeName
(
cmpEntry
.
type
)
+
'
size
=
'
+
cmpEntry
.
size
+
'
row
major
=
'
+
(
cmpEntry
.
isRowMajor
?
'
true
'
:
'
false
'
)
)
;
isOk
=
false
;
}
}
}
return
isOk
;
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
compareSharedBlocks
=
function
(
refLayout
cmpLayout
)
{
var
isOk
=
true
;
var
numBlocks
=
this
.
m_interface
.
getNumUniformBlocks
(
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
var
block
=
this
.
m_interface
.
getUniformBlock
(
blockNdx
)
;
var
isArray
=
block
.
isArray
(
)
;
var
instanceName
=
block
.
getBlockName
(
)
+
(
isArray
?
'
[
0
]
'
:
'
'
)
;
var
refBlockNdx
=
refLayout
.
getBlockIndex
(
instanceName
)
;
var
cmpBlockNdx
=
cmpLayout
.
getBlockIndex
(
instanceName
)
;
var
isUsed
=
(
block
.
getFlags
(
)
&
(
glsUniformBlockCase
.
UniformFlags
.
DECLARE_VERTEX
|
glsUniformBlockCase
.
UniformFlags
.
DECLARE_FRAGMENT
)
)
!
=
0
;
if
(
(
block
.
getFlags
(
)
&
glsUniformBlockCase
.
UniformFlags
.
LAYOUT_SHARED
)
=
=
0
)
continue
;
DE_ASSERT
(
refBlockNdx
>
=
0
)
;
if
(
cmpBlockNdx
<
0
)
{
if
(
isUsed
)
{
bufferedLogToConsole
(
"
Error
:
glsUniformBlockCase
.
Uniform
block
'
"
+
instanceName
+
"
'
not
found
"
)
;
isOk
=
false
;
}
continue
;
}
var
refBlockLayout
=
refLayout
.
blocks
[
refBlockNdx
]
;
var
cmpBlockLayout
=
cmpLayout
.
blocks
[
cmpBlockNdx
]
;
if
(
refBlockLayout
.
activeUniformIndices
.
length
!
=
cmpBlockLayout
.
activeUniformIndices
.
length
)
{
bufferedLogToConsole
(
"
Error
:
Number
of
active
uniforms
differ
in
block
'
"
+
instanceName
+
"
'
(
expected
"
+
refBlockLayout
.
activeUniformIndices
.
length
+
'
got
'
+
cmpBlockLayout
.
activeUniformIndices
.
length
+
'
)
'
)
;
isOk
=
false
;
}
for
(
var
ndx
=
0
;
ndx
<
refBlockLayout
.
activeUniformIndices
.
length
;
ndx
+
+
)
{
var
ndxIter
=
refBlockLayout
.
activeUniformIndices
[
ndx
]
;
var
refEntry
=
refLayout
.
uniforms
[
ndxIter
]
;
var
cmpEntryNdx
=
cmpLayout
.
getUniformIndex
(
refEntry
.
name
)
;
if
(
cmpEntryNdx
<
0
)
{
bufferedLogToConsole
(
"
Error
:
glsUniformBlockCase
.
Uniform
'
"
+
refEntry
.
name
+
"
'
not
found
"
)
;
isOk
=
false
;
continue
;
}
var
cmpEntry
=
cmpLayout
.
uniforms
[
cmpEntryNdx
]
;
if
(
refEntry
.
type
!
=
cmpEntry
.
type
|
|
refEntry
.
size
!
=
cmpEntry
.
size
|
|
refEntry
.
isRowMajor
!
=
cmpEntry
.
isRowMajor
)
{
bufferedLogToConsole
(
"
Error
:
Layout
mismatch
in
'
"
+
refEntry
.
name
+
"
'
:
\
n
"
+
'
expected
:
type
=
'
+
gluShaderUtil
.
getDataTypeName
(
refEntry
.
type
)
+
'
size
=
'
+
refEntry
.
size
+
'
row
major
=
'
+
(
refEntry
.
isRowMajor
?
'
true
'
:
'
false
'
)
+
'
\
n
'
+
'
got
:
type
=
'
+
gluShaderUtil
.
getDataTypeName
(
cmpEntry
.
type
)
+
'
size
=
'
+
cmpEntry
.
size
+
'
row
major
=
'
+
(
cmpEntry
.
isRowMajor
?
'
true
'
:
'
false
'
)
)
;
isOk
=
false
;
}
}
}
return
isOk
;
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
compareTypes
=
function
(
refLayout
cmpLayout
)
{
var
isOk
=
true
;
var
numBlocks
=
this
.
m_interface
.
getNumUniformBlocks
(
)
;
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
var
block
=
this
.
m_interface
.
getUniformBlock
(
blockNdx
)
;
var
isArray
=
block
.
isArray
(
)
;
var
numInstances
=
isArray
?
block
.
getArraySize
(
)
:
1
;
for
(
var
instanceNdx
=
0
;
instanceNdx
<
numInstances
;
instanceNdx
+
+
)
{
var
instanceName
;
instanceName
+
=
block
.
getBlockName
(
)
;
if
(
isArray
)
instanceName
=
instanceName
+
'
[
'
+
instanceNdx
+
'
]
'
;
var
cmpBlockNdx
=
cmpLayout
.
getBlockIndex
(
instanceName
)
;
if
(
cmpBlockNdx
<
0
)
continue
;
var
cmpBlockLayout
=
cmpLayout
.
blocks
[
cmpBlockNdx
]
;
for
(
var
ndx
=
0
;
ndx
<
cmpBlockLayout
.
activeUniformIndices
.
length
;
ndx
+
+
)
{
var
ndxIter
=
cmpBlockLayout
.
activeUniformIndices
[
ndx
]
;
var
cmpEntry
=
cmpLayout
.
uniforms
[
ndxIter
]
;
var
refEntryNdx
=
refLayout
.
getUniformIndex
(
cmpEntry
.
name
)
;
if
(
refEntryNdx
<
0
)
{
bufferedLogToConsole
(
"
Error
:
glsUniformBlockCase
.
Uniform
'
"
+
cmpEntry
.
name
+
"
'
not
found
in
reference
layout
"
)
;
isOk
=
false
;
continue
;
}
var
refEntry
=
refLayout
.
uniforms
[
refEntryNdx
]
;
if
(
refEntry
.
type
!
=
cmpEntry
.
type
)
{
bufferedLogToConsole
(
"
Error
:
glsUniformBlockCase
.
Uniform
type
mismatch
in
'
"
+
refEntry
.
name
+
"
'
:
<
/
br
>
"
+
"
'
expected
:
'
"
+
gluShaderUtil
.
getDataTypeName
(
refEntry
.
type
)
+
"
'
<
/
br
>
"
+
"
'
got
:
'
"
+
gluShaderUtil
.
getDataTypeName
(
cmpEntry
.
type
)
+
"
'
"
)
;
isOk
=
false
;
}
}
}
}
return
isOk
;
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
checkLayoutIndices
=
function
(
layout
)
{
var
numUniforms
=
layout
.
uniforms
.
length
;
var
numBlocks
=
layout
.
blocks
.
length
;
var
isOk
=
true
;
for
(
var
uniformNdx
=
0
;
uniformNdx
<
numUniforms
;
uniformNdx
+
+
)
{
var
uniform
=
layout
.
uniforms
[
uniformNdx
]
;
if
(
uniform
.
blockNdx
<
0
|
|
!
deMath
.
deInBounds32
(
uniform
.
blockNdx
0
numBlocks
)
)
{
bufferedLogToConsole
(
"
Error
:
Invalid
block
index
in
uniform
'
"
+
uniform
.
name
+
"
'
"
)
;
isOk
=
false
;
}
}
for
(
var
blockNdx
=
0
;
blockNdx
<
numBlocks
;
blockNdx
+
+
)
{
var
block
=
layout
.
blocks
[
blockNdx
]
;
for
(
var
uniformNdx
=
0
;
uniformNdx
<
block
.
activeUniformIndices
.
length
;
uniformNdx
+
+
)
{
var
activeUniformNdx
=
block
.
activeUniformIndices
[
uniformNdx
]
;
if
(
!
deMath
.
deInBounds32
(
activeUniformNdx
0
numUniforms
)
)
{
bufferedLogToConsole
(
'
Error
:
Invalid
active
uniform
index
'
+
activeUniformNdx
+
"
in
block
'
"
+
block
.
name
)
;
isOk
=
false
;
}
}
}
return
isOk
;
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
checkLayoutBounds
=
function
(
layout
)
{
var
numUniforms
=
layout
.
uniforms
.
length
;
var
isOk
=
true
;
for
(
var
uniformNdx
=
0
;
uniformNdx
<
numUniforms
;
uniformNdx
+
+
)
{
var
uniform
=
layout
.
uniforms
[
uniformNdx
]
;
if
(
uniform
.
blockNdx
<
0
)
continue
;
var
block
=
layout
.
blocks
[
uniform
.
blockNdx
]
;
var
isMatrix
=
gluShaderUtil
.
isDataTypeMatrix
(
uniform
.
type
)
;
var
numVecs
=
isMatrix
?
(
uniform
.
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumRows
(
uniform
.
type
)
:
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
uniform
.
type
)
)
:
1
;
var
numComps
=
isMatrix
?
(
uniform
.
isRowMajor
?
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
uniform
.
type
)
:
gluShaderUtil
.
getDataTypeMatrixNumRows
(
uniform
.
type
)
)
:
gluShaderUtil
.
getDataTypeScalarSize
(
uniform
.
type
)
;
var
numElements
=
uniform
.
size
;
var
compSize
=
deMath
.
INT32_SIZE
;
var
vecSize
=
numComps
*
compSize
;
var
minOffset
=
0
;
var
maxOffset
=
0
;
minOffset
=
Math
.
min
(
minOffset
(
numVecs
-
1
)
*
uniform
.
matrixStride
)
;
minOffset
=
Math
.
min
(
minOffset
(
numElements
-
1
)
*
uniform
.
arrayStride
)
;
minOffset
=
Math
.
min
(
minOffset
(
numElements
-
1
)
*
uniform
.
arrayStride
+
(
numVecs
-
1
)
*
uniform
.
matrixStride
)
;
maxOffset
=
Math
.
max
(
maxOffset
vecSize
)
;
maxOffset
=
Math
.
max
(
maxOffset
(
numVecs
-
1
)
*
uniform
.
matrixStride
+
vecSize
)
;
maxOffset
=
Math
.
max
(
maxOffset
(
numElements
-
1
)
*
uniform
.
arrayStride
+
vecSize
)
;
maxOffset
=
Math
.
max
(
maxOffset
(
numElements
-
1
)
*
uniform
.
arrayStride
+
(
numVecs
-
1
)
*
uniform
.
matrixStride
+
vecSize
)
;
if
(
uniform
.
offset
+
minOffset
<
0
|
|
uniform
.
offset
+
maxOffset
>
block
.
size
)
{
bufferedLogToConsole
(
"
Error
:
glsUniformBlockCase
.
Uniform
'
"
+
uniform
.
name
+
"
'
out
of
block
bounds
"
)
;
isOk
=
false
;
}
}
return
isOk
;
}
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
checkIndexQueries
=
function
(
program
layout
)
{
var
allOk
=
true
;
for
(
var
blockNdx
=
0
;
blockNdx
<
layout
.
blocks
.
length
;
blockNdx
+
+
)
{
var
block
=
layout
.
blocks
[
blockNdx
]
;
var
queriedNdx
=
gl
.
getUniformBlockIndex
(
program
block
.
name
)
;
if
(
queriedNdx
!
=
blockNdx
)
{
bufferedLogToConsole
(
'
ERROR
:
glGetUniformBlockIndex
(
'
+
block
.
name
+
'
)
returned
'
+
queriedNdx
+
'
expected
'
+
blockNdx
+
'
!
'
)
;
allOk
=
false
;
}
}
return
allOk
;
}
;
glsUniformBlockCase
.
VIEWPORT_WIDTH
=
128
;
glsUniformBlockCase
.
VIEWPORT_HEIGHT
=
128
;
glsUniformBlockCase
.
UniformBlockCase
.
prototype
.
render
=
function
(
program
)
{
var
rnd
=
new
deRandom
.
Random
(
deString
.
deStringHash
(
this
.
name
)
)
;
var
viewportW
=
Math
.
min
(
gl
.
canvas
.
width
glsUniformBlockCase
.
VIEWPORT_WIDTH
)
;
var
viewportH
=
Math
.
min
(
gl
.
canvas
.
height
glsUniformBlockCase
.
VIEWPORT_HEIGHT
)
;
var
viewportX
=
rnd
.
getInt
(
0
gl
.
canvas
.
width
)
;
var
viewportY
=
rnd
.
getInt
(
0
gl
.
canvas
.
height
)
;
gl
.
clearColor
(
0
.
125
0
.
25
0
.
5
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
var
position
=
[
-
1
.
0
-
1
.
0
0
.
0
1
.
0
-
1
.
0
1
.
0
0
.
0
1
.
0
1
.
0
-
1
.
0
0
.
0
1
.
0
1
.
0
1
.
0
0
.
0
1
.
0
]
;
var
indices
=
[
0
1
2
2
1
3
]
;
gl
.
viewport
(
viewportX
viewportY
viewportW
viewportH
)
;
var
posLoc
=
gl
.
getAttribLocation
(
program
.
getProgram
(
)
'
a_position
'
)
;
var
posArray
=
[
new
gluDrawUtil
.
VertexArrayBinding
(
gl
.
FLOAT
posLoc
4
4
position
)
]
;
gluDrawUtil
.
draw
(
gl
program
.
getProgram
(
)
posArray
gluDrawUtil
.
triangles
(
indices
)
)
;
var
pixels
=
new
gluDrawUtil
.
Surface
(
)
;
var
numFailedPixels
=
0
;
var
readPixelsX
=
(
viewportX
+
viewportW
)
>
gl
.
canvas
.
width
?
(
gl
.
canvas
.
width
-
viewportX
)
:
viewportW
;
var
readPixelsY
=
(
viewportY
+
viewportH
)
>
gl
.
canvas
.
height
?
(
gl
.
canvas
.
height
-
viewportY
)
:
viewportH
;
var
buffer
=
pixels
.
readSurface
(
gl
viewportX
viewportY
readPixelsX
readPixelsY
)
;
var
whitePixel
=
new
gluDrawUtil
.
Pixel
(
[
255
.
0
255
.
0
255
.
0
255
.
0
]
)
;
for
(
var
y
=
0
;
y
<
readPixelsY
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
readPixelsX
;
x
+
+
)
{
if
(
!
pixels
.
getPixel
(
x
y
)
.
equals
(
whitePixel
)
)
numFailedPixels
+
=
1
;
}
}
if
(
numFailedPixels
>
0
)
{
bufferedLogToConsole
(
'
Image
comparison
failed
got
'
+
numFailedPixels
+
'
non
-
white
pixels
.
'
)
;
}
return
numFailedPixels
=
=
0
;
}
;
}
)
;
