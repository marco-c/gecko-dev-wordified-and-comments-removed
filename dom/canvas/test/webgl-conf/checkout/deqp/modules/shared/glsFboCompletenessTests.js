'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsFboCompletenessTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluObjectWrapper
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluStrUtil
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsFboUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
glsFboCompletenessTests
=
modules
.
shared
.
glsFboCompletenessTests
;
var
glsFboUtil
=
modules
.
shared
.
glsFboUtil
;
var
gluObjectWrapper
=
framework
.
opengl
.
gluObjectWrapper
;
var
gluStrUtil
=
framework
.
opengl
.
gluStrUtil
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
glsFboCompletenessTests
.
initGlDependents
=
function
(
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
glsFboCompletenessTests
.
s_oesDepthTextureFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
DEPTH_COMPONENT
gl
.
UNSIGNED_SHORT
)
glsFboUtil
.
formatkey
(
gl
.
DEPTH_COMPONENT
gl
.
UNSIGNED_INT
)
]
;
glsFboCompletenessTests
.
s_oesPackedDepthStencilSizedFormats
=
[
gl
.
DEPTH24_STENCIL8
]
;
glsFboCompletenessTests
.
s_oesPackedDepthStencilTexFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
DEPTH_STENCIL
gl
.
UNSIGNED_INT_24_8
)
]
;
glsFboCompletenessTests
.
s_oesRequiredInternalFormatColorFormats
=
[
gl
.
RGB5_A1
gl
.
RGBA8
gl
.
RGBA4
gl
.
RGB565
]
;
glsFboCompletenessTests
.
s_oesRequiredInternalFormatDepthFormats
=
[
gl
.
DEPTH_COMPONENT16
]
;
glsFboCompletenessTests
.
s_extColorBufferHalfFloatFormats
=
[
gl
.
RGBA16F
gl
.
RGB16F
gl
.
RG16F
gl
.
R16F
]
;
glsFboCompletenessTests
.
s_oesDepth24SizedFormats
=
[
gl
.
DEPTH_COMPONENT24
]
;
glsFboCompletenessTests
.
s_oesDepth32SizedFormats
=
[
gl
[
'
DEPTH_COMPONENT32
'
]
]
;
glsFboCompletenessTests
.
s_oesRgb8Rgba8RboFormats
=
[
gl
.
RGB8
gl
.
RGBA8
]
;
glsFboCompletenessTests
.
s_oesRequiredInternalFormatRgb8ColorFormat
=
[
gl
.
RGB8
]
;
glsFboCompletenessTests
.
s_extTextureType2101010RevFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
RGBA
gl
.
UNSIGNED_INT_2_10_10_10_REV
)
glsFboUtil
.
formatkey
(
gl
.
RGB
gl
.
UNSIGNED_INT_2_10_10_10_REV
)
]
;
glsFboCompletenessTests
.
s_oesRequiredInternalFormat10bitColorFormats
=
[
gl
.
RGB10_A2
gl
[
'
RGB10
'
]
]
;
glsFboCompletenessTests
.
s_extTextureRgRboFormats
=
[
gl
.
R8
gl
.
RG8
]
;
glsFboCompletenessTests
.
s_extTextureRgTexFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
RED
gl
.
UNSIGNED_BYTE
)
glsFboUtil
.
formatkey
(
gl
.
RG
gl
.
UNSIGNED_BYTE
)
]
;
glsFboCompletenessTests
.
s_extTextureRgFloatTexFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
RED
gl
.
FLOAT
)
glsFboUtil
.
formatkey
(
gl
.
RG
gl
.
FLOAT
)
]
;
glsFboCompletenessTests
.
s_extTextureRgHalfFloatTexFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
RED
gl
[
'
HALF_FLOAT_OES
'
]
)
glsFboUtil
.
formatkey
(
gl
.
RG
gl
[
'
HALF_FLOAT_OES
'
]
)
]
;
glsFboCompletenessTests
.
s_nvPackedFloatRboFormats
=
[
gl
.
R11F_G11F_B10F
]
;
glsFboCompletenessTests
.
s_nvPackedFloatTexFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
RGB
gl
.
UNSIGNED_INT_10F_11F_11F_REV
)
]
;
glsFboCompletenessTests
.
s_extSrgbRboFormats
=
[
gl
.
SRGB8_ALPHA8
]
;
glsFboCompletenessTests
.
s_extSrgbRenderableTexFormats
=
[
glsFboUtil
.
formatkey
(
gl
[
'
SRGB_ALPHA
'
]
gl
.
UNSIGNED_BYTE
)
]
;
glsFboCompletenessTests
.
s_extSrgbNonRenderableTexFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
SRGB
gl
.
UNSIGNED_BYTE
)
gl
.
SRGB8
]
;
glsFboCompletenessTests
.
s_nvSrgbFormatsRboFormats
=
[
gl
.
SRGB8
]
;
glsFboCompletenessTests
.
s_nvSrgbFormatsTextureFormats
=
[
gl
.
SRGB8
glsFboUtil
.
formatkey
(
gl
.
SRGB
gl
.
UNSIGNED_BYTE
)
]
;
glsFboCompletenessTests
.
s_oesRgb8Rgba8TexFormats
=
[
glsFboUtil
.
formatkey
(
gl
.
RGB
gl
.
UNSIGNED_BYTE
)
glsFboUtil
.
formatkey
(
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
]
;
var
fmt
=
glsFboUtil
.
FormatFlags
;
glsFboCompletenessTests
.
s_esExtFormats
=
[
new
glsFboUtil
.
FormatExtEntry
(
'
OES_depth_texture
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
DEPTH_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesDepthTextureFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_packed_depth_stencil
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
DEPTH_RENDERABLE
|
fmt
.
STENCIL_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesPackedDepthStencilSizedFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_packed_depth_stencil
OES_required_internalformat
'
fmt
.
DEPTH_RENDERABLE
|
fmt
.
STENCIL_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesPackedDepthStencilTexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_texture_half_float
EXT_color_buffer_half_float
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
COLOR_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extColorBufferHalfFloatFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_required_internalformat
'
fmt
.
COLOR_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesRequiredInternalFormatColorFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_required_internalformat
'
fmt
.
DEPTH_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesRequiredInternalFormatDepthFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_texture_rg
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
COLOR_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extTextureRgRboFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_texture_rg
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extTextureRgTexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_texture_rg
OES_texture_float
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extTextureRgFloatTexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_texture_rg
OES_texture_half_float
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extTextureRgHalfFloatTexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_packed_float
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_nvPackedFloatTexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_packed_float
EXT_color_buffer_half_float
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
COLOR_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_nvPackedFloatRboFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_sRGB
'
fmt
.
COLOR_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extSrgbRenderableTexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_sRGB
'
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extSrgbNonRenderableTexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_sRGB
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
COLOR_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extSrgbRboFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
NV_sRGB_formats
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
COLOR_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_nvSrgbFormatsRboFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
NV_sRGB_formats
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
COLOR_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_nvSrgbFormatsTextureFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_rgb8_rgba8
'
fmt
.
COLOR_RENDERABLE
|
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesRgb8Rgba8TexFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_rgb8_rgba8
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
COLOR_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesRgb8Rgba8RboFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_rgb8_rgba8
OES_required_internalformat
'
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesRequiredInternalFormatRgb8ColorFormat
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_depth24
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
DEPTH_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesDepth24SizedFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_depth24
OES_required_internalformat
OES_depth_texture
'
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesDepth24SizedFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_depth32
'
fmt
.
REQUIRED_RENDERABLE
|
fmt
.
DEPTH_RENDERABLE
|
fmt
.
RENDERBUFFER_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesDepth32SizedFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
OES_depth32
OES_required_internalformat
OES_depth_texture
'
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesDepth32SizedFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_texture_type_2_10_10_10_REV
'
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_extTextureType2101010RevFormats
)
)
new
glsFboUtil
.
FormatExtEntry
(
'
EXT_texture_type_2_10_10_10_REV
OES_required_internalformat
'
fmt
.
TEXTURE_VALID
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_oesRequiredInternalFormat10bitColorFormats
)
)
]
;
}
;
glsFboCompletenessTests
.
Context
=
function
(
testCtx
renderCtx
factory
)
{
this
.
m_testCtx
=
testCtx
;
this
.
m_renderCtx
=
renderCtx
;
this
.
m_ctxFormats
=
new
glsFboUtil
.
FormatDB
(
)
;
this
.
m_minFormats
=
new
glsFboUtil
.
FormatDB
(
)
;
this
.
m_maxFormats
=
new
glsFboUtil
.
FormatDB
(
)
;
this
.
m_verifier
=
new
glsFboUtil
.
FboVerifier
(
this
.
m_ctxFormats
factory
)
;
this
.
m_haveMultiColorAtts
=
false
;
var
extRange
=
glsFboUtil
.
rangeArray
(
glsFboCompletenessTests
.
s_esExtFormats
)
;
this
.
addExtFormats
(
extRange
)
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
getRenderContext
=
function
(
)
{
return
this
.
m_renderCtx
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
getTestContext
=
function
(
)
{
return
this
.
m_testCtx
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
getVerifier
=
function
(
)
{
return
this
.
m_verifier
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
getMinFormats
=
function
(
)
{
return
this
.
m_minFormats
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
getCtxFormats
=
function
(
)
{
return
this
.
m_ctxFormats
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
haveMultiColorAtts
=
function
(
)
{
return
this
.
m_haveMultiColorAtts
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
setHaveMulticolorAtts
=
function
(
have
)
{
this
.
m_haveMultiColorAtts
=
(
have
=
=
true
)
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
addFormats
=
function
(
fmtRange
)
{
glsFboUtil
.
addFormats
(
this
.
m_minFormats
fmtRange
)
;
glsFboUtil
.
addFormats
(
this
.
m_ctxFormats
fmtRange
)
;
glsFboUtil
.
addFormats
(
this
.
m_maxFormats
fmtRange
)
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
addExtFormats
=
function
(
extRange
)
{
glsFboUtil
.
addExtFormats
(
this
.
m_ctxFormats
extRange
this
.
m_renderCtx
)
;
glsFboUtil
.
addExtFormats
(
this
.
m_maxFormats
extRange
this
.
m_renderCtx
)
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
createRenderableTests
=
function
(
gl
)
{
var
renderableTests
=
tcuTestCase
.
newTest
(
'
renderable
'
'
Tests
for
support
of
renderable
image
formats
'
)
;
var
rbRenderableTests
=
tcuTestCase
.
newTest
(
'
renderbuffer
'
'
Tests
for
renderbuffer
formats
'
)
;
var
texRenderableTests
=
tcuTestCase
.
newTest
(
'
texture
'
'
Tests
for
texture
formats
'
)
;
var
attPoints
=
[
[
gl
.
DEPTH_ATTACHMENT
'
depth
'
'
Tests
for
depth
attachments
'
]
[
gl
.
STENCIL_ATTACHMENT
'
stencil
'
'
Tests
for
stencil
attachments
'
]
[
gl
.
COLOR_ATTACHMENT0
'
color0
'
'
Tests
for
color
attachments
'
]
]
;
var
rboFmts
=
this
.
m_maxFormats
.
getFormats
(
glsFboUtil
.
FormatFlags
.
ANY_FORMAT
)
;
var
texFmts
=
this
.
m_maxFormats
.
getFormats
(
glsFboUtil
.
FormatFlags
.
ANY_FORMAT
)
;
for
(
var
i
=
0
l_attPoints
=
attPoints
.
length
;
i
<
l_attPoints
;
+
+
i
)
{
var
rbAttTests
=
tcuTestCase
.
newTest
(
attPoints
[
i
]
[
1
]
attPoints
[
i
]
[
2
]
)
;
var
texAttTests
=
tcuTestCase
.
newTest
(
attPoints
[
i
]
[
1
]
attPoints
[
i
]
[
2
]
)
;
for
(
var
j
=
0
l_rboFmts
=
rboFmts
.
length
;
j
<
l_rboFmts
;
+
+
j
)
{
var
params
=
glsFboCompletenessTests
.
renderableParams
(
attPoints
[
i
]
[
0
]
gl
.
RENDERBUFFER
rboFmts
[
j
]
)
;
rbAttTests
.
addChild
(
new
glsFboCompletenessTests
.
RenderableTest
(
glsFboCompletenessTests
.
renderableParams
.
getName
(
params
)
glsFboCompletenessTests
.
renderableParams
.
getDescription
(
params
)
this
params
)
)
;
}
rbRenderableTests
.
addChild
(
rbAttTests
)
;
for
(
var
j
=
0
l_texFmts
=
texFmts
.
length
;
j
<
l_texFmts
;
+
+
j
)
{
var
params
=
glsFboCompletenessTests
.
renderableParams
(
attPoints
[
i
]
[
0
]
gl
.
TEXTURE
texFmts
[
j
]
)
;
texAttTests
.
addChild
(
new
glsFboCompletenessTests
.
RenderableTest
(
glsFboCompletenessTests
.
renderableParams
.
getName
(
params
)
glsFboCompletenessTests
.
renderableParams
.
getDescription
(
params
)
this
params
)
)
;
}
texRenderableTests
.
addChild
(
texAttTests
)
;
}
renderableTests
.
addChild
(
rbRenderableTests
)
;
renderableTests
.
addChild
(
texRenderableTests
)
;
return
renderableTests
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
createAttachmentTests
=
function
(
gl
)
{
var
attCombTests
=
tcuTestCase
.
newTest
(
'
attachment_combinations
'
'
Tests
for
attachment
combinations
'
)
;
var
s_bufTypes
=
[
gl
.
NONE
gl
.
RENDERBUFFER
gl
.
TEXTURE
]
;
var
ls_bufTypes
=
s_bufTypes
.
length
;
for
(
var
col0
=
0
;
col0
<
ls_bufTypes
;
+
+
col0
)
for
(
var
coln
=
0
;
coln
<
ls_bufTypes
;
+
+
coln
)
for
(
var
dep
=
0
;
dep
<
ls_bufTypes
;
+
+
dep
)
for
(
var
stc
=
0
;
stc
<
ls_bufTypes
;
+
+
stc
)
{
var
params
=
glsFboCompletenessTests
.
attachmentParams
(
s_bufTypes
[
col0
]
s_bufTypes
[
coln
]
s_bufTypes
[
dep
]
s_bufTypes
[
stc
]
)
;
attCombTests
.
addChild
(
new
glsFboCompletenessTests
.
AttachmentTest
(
glsFboCompletenessTests
.
attachmentParams
.
getName
(
params
)
glsFboCompletenessTests
.
attachmentParams
.
getDescription
(
params
)
this
params
)
)
;
}
return
attCombTests
;
}
;
glsFboCompletenessTests
.
Context
.
prototype
.
createSizeTests
=
function
(
gl
)
{
var
sizeTests
=
tcuTestCase
.
newTest
(
'
size
'
'
Tests
for
attachment
sizes
'
)
;
sizeTests
.
addChild
(
new
glsFboCompletenessTests
.
EmptyImageTest
(
'
zero
'
'
Test
for
zero
-
sized
image
attachment
'
this
)
)
;
return
sizeTests
;
}
;
glsFboCompletenessTests
.
TestBase
=
function
(
name
desc
params
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
desc
)
;
this
.
m_params
=
params
;
}
;
glsFboCompletenessTests
.
TestBase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
glsFboCompletenessTests
.
TestBase
.
prototype
.
constructor
=
glsFboCompletenessTests
.
TestBase
;
glsFboCompletenessTests
.
TestBase
.
prototype
.
getContext
=
function
(
)
{
return
tcuTestCase
.
runner
;
}
;
glsFboCompletenessTests
.
TestBase
.
prototype
.
getDefaultFormat
=
function
(
attPoint
bufType
gl
)
{
gl
=
gl
|
|
window
.
gl
;
if
(
bufType
=
=
gl
.
NONE
)
{
return
glsFboUtil
.
ImageFormat
.
none
(
)
;
}
var
formats
=
this
.
m_ctx
.
getMinFormats
(
)
.
getFormats
(
glsFboUtil
.
formatFlag
(
attPoint
gl
)
|
glsFboUtil
.
formatFlag
(
bufType
gl
)
)
;
if
(
!
formats
.
length
)
{
formats
=
this
.
m_ctx
.
getCtxFormats
(
)
.
getFormats
(
glsFboUtil
.
formatFlag
(
attPoint
gl
)
|
glsFboUtil
.
formatFlag
(
bufType
gl
)
)
;
}
if
(
!
formats
.
length
)
{
throw
new
Error
(
'
Unsupported
attachment
kind
for
attachment
point
'
)
;
}
return
formats
[
0
]
;
}
;
glsFboCompletenessTests
.
makeImage
=
function
(
bufType
format
width
height
builder
gl
)
{
gl
=
gl
|
|
window
.
gl
;
var
image
=
0
;
switch
(
bufType
)
{
case
gl
.
NONE
:
return
null
;
break
;
case
gl
.
RENDERBUFFER
:
image
=
(
builder
.
makeConfig
(
glsFboUtil
.
Renderbuffer
)
)
;
break
;
case
gl
.
TEXTURE
:
image
=
(
builder
.
makeConfig
(
glsFboUtil
.
Texture2D
)
)
;
break
;
default
:
throw
new
Error
(
'
Impossible
case
'
)
;
}
image
.
internalFormat
=
format
;
image
.
width
=
width
;
image
.
height
=
height
;
return
image
;
}
;
glsFboCompletenessTests
.
makeAttachment
=
function
(
bufType
format
width
height
builder
gl
)
{
gl
=
gl
|
|
window
.
gl
;
var
cfg
=
glsFboCompletenessTests
.
makeImage
(
bufType
format
width
height
builder
gl
)
;
if
(
cfg
=
=
null
)
return
null
;
var
att
=
null
;
var
img
=
0
;
var
mask
=
glsFboUtil
.
Config
.
s_types
.
RENDERBUFFER
|
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D
;
switch
(
cfg
.
type
&
mask
)
{
case
glsFboUtil
.
Config
.
s_types
.
RENDERBUFFER
:
img
=
builder
.
glCreateRbo
(
(
cfg
)
)
;
att
=
(
builder
.
makeConfig
(
glsFboUtil
.
RenderbufferAttachment
)
)
;
break
;
case
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D
:
img
=
builder
.
glCreateTexture
(
(
cfg
)
)
;
att
=
(
builder
.
makeConfig
(
glsFboUtil
.
TextureFlatAttachment
)
)
;
att
.
texTarget
=
gl
.
TEXTURE_2D
;
break
;
default
:
throw
new
Error
(
'
Unsupported
config
.
'
)
;
}
att
.
imageName
=
img
;
return
att
;
}
;
glsFboCompletenessTests
.
TestBase
.
prototype
.
attachTargetToNew
=
function
(
target
bufType
format
width
height
builder
gl
)
{
var
imgFmt
=
format
;
if
(
imgFmt
.
format
=
=
gl
.
NONE
)
imgFmt
=
this
.
getDefaultFormat
(
target
bufType
gl
)
;
var
att
=
glsFboCompletenessTests
.
makeAttachment
(
bufType
imgFmt
width
height
builder
gl
)
;
builder
.
glAttach
(
target
att
)
;
}
;
glsFboCompletenessTests
.
statusName
=
function
(
status
gl
)
{
gl
=
gl
|
|
window
.
gl
;
var
errorName
=
gluStrUtil
.
getErrorName
(
status
)
;
if
(
status
!
=
gl
.
NO_ERROR
&
&
errorName
!
=
'
'
)
return
errorName
+
'
(
during
FBO
initialization
)
'
;
var
fbStatusName
=
gluStrUtil
.
getFramebufferStatusName
(
status
)
;
if
(
fbStatusName
!
=
'
'
)
return
fbStatusName
;
return
'
unknown
value
(
'
+
status
+
'
)
'
;
}
;
glsFboCompletenessTests
.
TestBase
.
prototype
.
iterate
=
function
(
)
{
var
gl
=
window
.
gl
;
var
fbo
=
new
gluObjectWrapper
.
Framebuffer
(
gl
)
;
var
builder
=
new
glsFboUtil
.
FboBuilder
(
fbo
.
get
(
)
gl
.
FRAMEBUFFER
gl
)
;
var
ret
=
this
.
build
(
builder
gl
)
;
var
statuses
=
this
.
m_ctx
.
getVerifier
(
)
.
validStatusCodes
(
builder
gl
)
;
var
errorCode
=
builder
.
getError
(
)
;
if
(
errorCode
!
=
gl
.
NO_ERROR
)
{
bufferedLogToConsole
(
'
Received
'
+
gluStrUtil
.
getErrorName
(
errorCode
)
+
'
(
during
FBO
initialization
)
.
'
)
;
if
(
statuses
.
isErrorCodeValid
(
errorCode
)
)
testPassed
(
)
;
else
if
(
statuses
.
isErrorCodeRequired
(
gl
.
NO_ERROR
)
)
testFailedOptions
(
'
Excepted
no
error
but
got
'
+
gluStrUtil
.
getErrorName
(
errorCode
)
true
)
;
else
testFailedOptions
(
'
Got
wrong
error
code
'
true
)
;
}
else
{
var
fboStatus
=
gl
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
var
validStatus
=
statuses
.
isFBOStatusValid
(
fboStatus
)
;
bufferedLogToConsole
(
'
Received
'
+
gluStrUtil
.
getFramebufferStatusName
(
fboStatus
)
)
;
if
(
!
validStatus
)
{
if
(
fboStatus
=
=
gl
.
FRAMEBUFFER_COMPLETE
)
{
testFailedOptions
(
'
Framebuffer
checked
as
complete
expected
incomplete
'
true
)
;
}
else
if
(
statuses
.
isFBOStatusRequired
(
gl
.
FRAMEBUFFER_COMPLETE
)
)
{
testFailedOptions
(
'
Framebuffer
checked
as
incomplete
expected
complete
'
true
)
;
}
else
{
testFailedOptions
(
'
Framebuffer
checked
as
incomplete
but
with
wrong
status
'
true
)
;
}
}
else
if
(
fboStatus
!
=
gl
.
FRAMEBUFFER_COMPLETE
&
&
statuses
.
isFBOStatusValid
(
gl
.
FRAMEBUFFER_COMPLETE
)
)
{
testPassedOptions
(
'
Warning
:
framebuffer
object
could
have
checked
as
complete
but
did
not
.
'
true
)
;
}
else
{
testPassed
(
)
;
}
}
builder
.
deinit
(
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
glsFboCompletenessTests
.
formatName
=
function
(
format
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
GL
object
'
)
;
var
s
=
gluStrUtil
.
getPixelFormatName
(
format
.
format
)
.
substr
(
3
)
.
toLowerCase
(
)
;
if
(
format
.
unsizedType
!
=
gl
.
NONE
)
s
+
=
'
_
'
+
gluStrUtil
.
getTypeName
(
format
.
unsizedType
)
.
substr
(
3
)
.
toLowerCase
(
)
;
return
s
;
}
;
glsFboCompletenessTests
.
formatDesc
=
function
(
format
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
GL
object
'
)
;
var
s
=
gluStrUtil
.
getPixelFormatName
(
format
.
format
)
;
if
(
format
.
unsizedType
!
=
gl
.
NONE
)
s
+
=
'
with
type
'
+
gluStrUtil
.
getTypeName
(
format
.
unsizedType
)
;
return
s
;
}
;
glsFboCompletenessTests
.
renderableParamsT
;
glsFboCompletenessTests
.
renderableParams
=
function
(
attPoint
bufType
format
)
{
var
ret
=
{
attPoint
:
attPoint
bufType
:
bufType
format
:
format
}
;
return
ret
;
}
;
glsFboCompletenessTests
.
renderableParams
.
getName
=
function
(
params
gl
)
{
return
glsFboCompletenessTests
.
formatName
(
params
.
format
gl
)
;
}
;
glsFboCompletenessTests
.
renderableParams
.
getDescription
=
function
(
params
gl
)
{
return
glsFboCompletenessTests
.
formatDesc
(
params
.
format
gl
)
;
}
;
glsFboCompletenessTests
.
RenderableTest
=
function
(
name
desc
ctx
params
)
{
glsFboCompletenessTests
.
TestBase
.
call
(
this
name
desc
params
)
;
this
.
m_ctx
=
ctx
;
}
;
glsFboCompletenessTests
.
RenderableTest
.
prototype
=
Object
.
create
(
glsFboCompletenessTests
.
TestBase
.
prototype
)
;
glsFboCompletenessTests
.
RenderableTest
.
prototype
.
constructor
=
glsFboCompletenessTests
.
RenderableTest
;
glsFboCompletenessTests
.
RenderableTest
.
prototype
.
build
=
function
(
builder
gl
)
{
this
.
attachTargetToNew
(
this
.
m_params
.
attPoint
this
.
m_params
.
bufType
this
.
m_params
.
format
64
64
builder
gl
)
;
return
true
;
}
;
glsFboCompletenessTests
.
attTypeName
=
function
(
bufType
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
GL
object
'
)
;
switch
(
bufType
)
{
case
gl
.
NONE
:
return
'
none
'
;
case
gl
.
RENDERBUFFER
:
return
'
rbo
'
;
case
gl
.
TEXTURE
:
return
'
tex
'
;
default
:
break
;
}
throw
new
Error
(
'
Impossible
case
'
)
;
}
;
glsFboCompletenessTests
.
attachmentParamsT
;
glsFboCompletenessTests
.
attachmentParams
=
function
(
color0Kind
colornKind
depthKind
stencilKind
)
{
var
ret
=
{
color0Kind
:
color0Kind
colornKind
:
colornKind
depthKind
:
depthKind
stencilKind
:
stencilKind
}
;
return
ret
;
}
;
glsFboCompletenessTests
.
attachmentParams
.
getName
=
function
(
params
gl
)
{
return
(
glsFboCompletenessTests
.
attTypeName
(
params
.
color0Kind
gl
)
+
'
_
'
+
glsFboCompletenessTests
.
attTypeName
(
params
.
colornKind
gl
)
+
'
_
'
+
glsFboCompletenessTests
.
attTypeName
(
params
.
depthKind
gl
)
+
'
_
'
+
glsFboCompletenessTests
.
attTypeName
(
params
.
stencilKind
gl
)
)
;
}
;
glsFboCompletenessTests
.
attachmentParams
.
getDescription
=
glsFboCompletenessTests
.
attachmentParams
.
getName
;
glsFboCompletenessTests
.
AttachmentTest
=
function
(
name
desc
ctx
params
)
{
glsFboCompletenessTests
.
TestBase
.
call
(
this
name
desc
params
)
;
this
.
m_ctx
=
ctx
;
}
;
glsFboCompletenessTests
.
AttachmentTest
.
prototype
=
Object
.
create
(
glsFboCompletenessTests
.
TestBase
.
prototype
)
;
glsFboCompletenessTests
.
AttachmentTest
.
prototype
.
constructor
=
glsFboCompletenessTests
.
AttachmentTest
;
glsFboCompletenessTests
.
AttachmentTest
.
prototype
.
makeDepthAndStencil
=
function
(
builder
gl
)
{
var
att
=
null
;
if
(
this
.
m_params
.
stencilKind
=
=
this
.
m_params
.
depthKind
)
{
var
flags
=
glsFboUtil
.
FormatFlags
.
DEPTH_RENDERABLE
|
glsFboUtil
.
FormatFlags
.
STENCIL_RENDERABLE
|
glsFboUtil
.
formatFlag
(
this
.
m_params
.
stencilKind
gl
)
;
var
formats
=
this
.
m_ctx
.
getMinFormats
(
)
.
getFormats
(
flags
)
;
if
(
formats
.
length
)
{
var
format
=
formats
[
0
]
;
att
=
glsFboCompletenessTests
.
makeAttachment
(
this
.
m_params
.
depthKind
format
64
64
builder
gl
)
;
builder
.
glAttach
(
gl
.
DEPTH_ATTACHMENT
att
)
;
builder
.
glAttach
(
gl
.
STENCIL_ATTACHMENT
att
)
;
return
;
}
}
this
.
attachTargetToNew
(
gl
.
STENCIL_ATTACHMENT
this
.
m_params
.
stencilKind
glsFboUtil
.
ImageFormat
.
none
(
)
64
64
builder
gl
)
;
this
.
attachTargetToNew
(
gl
.
DEPTH_ATTACHMENT
this
.
m_params
.
depthKind
glsFboUtil
.
ImageFormat
.
none
(
)
64
64
builder
gl
)
;
}
;
glsFboCompletenessTests
.
AttachmentTest
.
prototype
.
build
=
function
(
builder
gl
)
{
this
.
attachTargetToNew
(
gl
.
COLOR_ATTACHMENT0
this
.
m_params
.
color0Kind
glsFboUtil
.
ImageFormat
.
none
(
)
64
64
builder
gl
)
;
if
(
this
.
m_params
.
colornKind
!
=
gl
.
NONE
)
{
if
(
this
.
m_ctx
.
haveMultiColorAtts
(
)
)
throw
new
Error
(
'
Multiple
attachments
not
supported
'
)
;
var
maxAttachments
=
gl
.
getParameter
(
gl
.
MAX_COLOR_ATTACHMENTS
)
;
for
(
var
i
=
0
;
i
<
maxAttachments
;
+
+
i
)
{
this
.
attachTargetToNew
(
gl
.
COLOR_ATTACHMENT0
+
i
this
.
m_params
.
colornKind
glsFboUtil
.
ImageFormat
.
none
(
)
64
64
builder
gl
)
;
}
}
this
.
makeDepthAndStencil
(
builder
gl
)
;
return
true
;
}
;
glsFboCompletenessTests
.
EmptyImageTest
=
function
(
name
desc
ctx
)
{
glsFboCompletenessTests
.
TestBase
.
call
(
this
name
desc
null
)
;
this
.
m_ctx
=
ctx
;
}
;
glsFboCompletenessTests
.
EmptyImageTest
.
prototype
=
Object
.
create
(
glsFboCompletenessTests
.
TestBase
.
prototype
)
;
glsFboCompletenessTests
.
EmptyImageTest
.
prototype
.
constructor
=
glsFboCompletenessTests
.
EmptyImageTest
;
glsFboCompletenessTests
.
EmptyImageTest
.
prototype
.
build
=
function
(
builder
gl
)
{
this
.
attachTargetToNew
(
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
glsFboUtil
.
ImageFormat
.
none
(
)
0
0
builder
gl
)
;
return
true
;
}
;
}
)
;
