'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsFboUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluStrUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
glsFboUtil
=
modules
.
shared
.
glsFboUtil
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gluStrUtil
=
framework
.
opengl
.
gluStrUtil
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
glsFboUtil
.
Map
=
function
(
comparefnc
)
{
this
.
store
=
[
]
;
this
.
compare
=
comparefnc
;
this
.
length
=
0
;
}
;
glsFboUtil
.
Map
.
compareNumber
=
function
(
num1
num2
)
{
return
num1
<
num2
;
}
;
glsFboUtil
.
Map
.
prototype
.
pair
=
function
(
key
value
)
{
return
{
first
:
key
second
:
value
}
;
}
;
glsFboUtil
.
Map
.
prototype
.
findInsertionPoint
=
function
(
key
)
{
var
i
length
;
for
(
i
=
0
length
=
this
.
store
.
length
;
i
<
length
;
+
+
i
)
{
if
(
!
this
.
compare
(
key
this
.
store
[
i
]
.
first
)
)
break
;
}
return
i
;
}
;
glsFboUtil
.
Map
.
prototype
.
foundIndexMatches
=
function
(
key
index
)
{
return
(
this
.
store
[
index
]
!
=
=
undefined
&
&
!
this
.
compare
(
this
.
store
[
index
]
.
first
key
)
)
;
}
;
glsFboUtil
.
Map
.
prototype
.
isset
=
function
(
key
)
{
return
this
.
foundIndexMatches
(
key
this
.
findInsertionPoint
(
key
)
)
;
}
;
glsFboUtil
.
Map
.
prototype
.
set
=
function
(
key
value
)
{
var
index
=
this
.
findInsertionPoint
(
key
)
;
if
(
this
.
foundIndexMatches
(
key
index
)
)
{
this
.
store
[
index
]
.
second
=
value
;
}
else
{
this
.
store
.
splice
(
index
0
this
.
pair
(
key
value
)
)
;
+
+
this
.
length
;
}
}
;
glsFboUtil
.
Map
.
prototype
.
remove
=
function
(
key
)
{
var
index
=
this
.
findInsertionPoint
(
key
)
;
var
ret
=
null
;
if
(
this
.
foundIndexMatches
(
key
index
)
)
{
ret
=
this
.
store
[
index
]
.
second
;
this
.
store
.
splice
(
index
1
)
;
-
-
this
.
length
;
}
return
ret
;
}
;
glsFboUtil
.
Map
.
prototype
.
get
=
function
(
key
)
{
var
index
=
this
.
findInsertionPoint
(
key
)
;
if
(
this
.
foundIndexMatches
(
key
index
)
)
return
this
.
store
[
index
]
;
return
null
;
}
;
glsFboUtil
.
Map
.
prototype
.
getValue
=
function
(
key
)
{
var
index
=
this
.
findInsertionPoint
(
key
)
;
if
(
this
.
foundIndexMatches
(
key
index
)
)
return
this
.
store
[
index
]
.
second
;
return
null
;
}
;
glsFboUtil
.
Map
.
prototype
.
lookupDefault
=
function
(
key
fallback
)
{
var
index
=
this
.
findInsertionPoint
(
key
)
;
if
(
this
.
foundIndexMatches
(
key
index
)
)
return
this
.
store
[
index
]
.
second
;
return
fallback
;
}
;
glsFboUtil
.
Map
.
prototype
.
getIndex
=
function
(
index
)
{
return
this
.
store
[
index
]
;
}
;
glsFboUtil
.
Map
.
prototype
.
transform
=
function
(
key
callback
)
{
var
index
=
this
.
findInsertionPoint
(
key
)
;
if
(
this
.
foundIndexMatches
(
key
index
)
)
{
this
.
store
[
index
]
.
second
=
callback
(
this
.
store
[
index
]
.
second
)
;
}
else
{
this
.
store
.
splice
(
index
0
this
.
pair
(
key
callback
(
)
)
)
;
+
+
this
.
length
;
}
}
;
glsFboUtil
.
Map
.
prototype
.
clear
=
function
(
)
{
this
.
store
.
splice
(
0
this
.
length
)
;
this
.
length
=
0
;
}
;
glsFboUtil
.
FormatDB
=
function
(
)
{
this
.
m_map
=
(
new
glsFboUtil
.
Map
(
glsFboUtil
.
ImageFormat
.
lessthan
)
)
;
}
;
glsFboUtil
.
FormatDB
.
prototype
.
addFormat
=
function
(
format
newFlags
)
{
this
.
m_map
.
transform
(
format
function
(
flags
)
{
return
flags
|
newFlags
;
}
)
;
}
;
glsFboUtil
.
FormatDB
.
prototype
.
getFormats
=
function
(
requirements
)
{
var
ret
=
[
]
;
for
(
var
i
=
0
;
i
<
this
.
m_map
.
length
;
+
+
i
)
{
var
pair
=
this
.
m_map
.
getIndex
(
i
)
;
if
(
(
pair
.
second
&
requirements
)
=
=
requirements
)
ret
.
push
(
pair
.
first
)
;
}
return
ret
;
}
;
glsFboUtil
.
FormatDB
.
prototype
.
getFormatInfo
=
function
(
format
fallback
)
{
return
this
.
m_map
.
lookupDefault
(
format
fallback
)
;
}
;
glsFboUtil
.
lookupDefault
=
function
(
map
key
fallback
)
{
return
(
map
[
key
]
!
=
=
undefined
)
?
map
[
key
]
:
fallback
;
}
;
glsFboUtil
.
contains
=
function
(
array
item
)
{
var
l
=
array
.
length
;
for
(
var
i
=
0
;
i
<
l
;
+
+
i
)
if
(
array
[
i
]
=
=
item
)
return
true
;
return
false
;
}
;
glsFboUtil
.
formatT
;
glsFboUtil
.
addFormats
=
function
(
db
stdFmts
)
{
for
(
var
set
=
stdFmts
.
reset
(
)
;
set
=
stdFmts
.
current
(
)
;
stdFmts
.
next
(
)
)
{
for
(
var
fmt
=
set
[
1
]
.
reset
(
)
;
fmt
=
set
[
1
]
.
current
(
)
;
set
[
1
]
.
next
(
)
)
{
db
.
addFormat
(
glsFboUtil
.
formatKeyInfo
(
fmt
)
set
[
0
]
)
;
}
}
}
;
glsFboUtil
.
addExtFormats
=
function
(
db
extFmts
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
var
extensions
=
gl
.
getSupportedExtensions
(
)
;
for
(
var
ext
=
extFmts
.
reset
(
)
;
ext
=
extFmts
.
current
(
)
;
extFmts
.
next
(
)
)
{
var
tokens
=
ext
.
extensions
.
split
(
/
\
s
+
/
)
;
var
supported
=
function
(
)
{
for
(
var
i
=
0
l
=
tokens
.
length
;
i
<
l
;
+
+
i
)
if
(
extensions
.
indexOf
(
tokens
[
i
]
)
=
=
=
-
1
)
return
false
;
return
true
;
}
(
)
;
if
(
supported
)
{
for
(
var
format
=
ext
.
formats
.
reset
(
)
;
format
=
ext
.
formats
.
current
(
)
;
ext
.
formats
.
next
(
)
)
{
db
.
addFormat
(
glsFboUtil
.
formatKeyInfo
(
format
)
ext
.
flags
)
;
}
}
}
}
;
glsFboUtil
.
formatFlag
=
function
(
glenum
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
switch
(
glenum
)
{
case
gl
.
NONE
:
return
glsFboUtil
.
FormatFlags
.
ANY_FORMAT
;
case
gl
.
RENDERBUFFER
:
return
glsFboUtil
.
FormatFlags
.
RENDERBUFFER_VALID
;
case
gl
.
TEXTURE
:
return
glsFboUtil
.
FormatFlags
.
TEXTURE_VALID
;
case
gl
.
STENCIL_ATTACHMENT
:
return
glsFboUtil
.
FormatFlags
.
STENCIL_RENDERABLE
;
case
gl
.
DEPTH_ATTACHMENT
:
return
glsFboUtil
.
FormatFlags
.
DEPTH_RENDERABLE
;
default
:
if
(
glenum
<
gl
.
COLOR_ATTACHMENT0
|
|
glenum
>
gl
.
COLOR_ATTACHMENT15
)
{
throw
new
Error
(
'
glenum
out
of
range
'
)
;
}
}
return
glsFboUtil
.
FormatFlags
.
COLOR_RENDERABLE
;
}
;
glsFboUtil
.
remove_from_array
=
function
(
array
value
)
{
var
index
=
0
;
while
(
(
index
=
array
.
indexOf
(
value
)
)
!
=
-
1
)
{
array
.
splice
(
index
1
)
;
}
}
;
glsFboUtil
.
FormatExtEntry
=
function
(
extensions
flags
formats
)
{
this
.
extensions
=
null
;
this
.
flags
=
null
;
this
.
formats
=
null
;
if
(
extensions
!
=
=
undefined
)
{
this
.
extensions
=
extensions
;
if
(
flags
!
=
=
undefined
)
{
this
.
flags
=
flags
;
if
(
formats
!
=
=
undefined
)
this
.
formats
=
formats
;
}
}
}
;
glsFboUtil
.
Range
=
function
(
array
begin
end
)
{
this
.
m_begin
=
(
begin
=
=
=
undefined
?
0
:
begin
)
;
this
.
m_end
=
end
|
|
array
.
length
;
this
.
m_array
=
array
;
this
.
m_index
=
this
.
m_begin
;
}
;
glsFboUtil
.
Range
.
prototype
.
array
=
function
(
)
{
return
this
.
m_array
;
}
;
glsFboUtil
.
Range
.
prototype
.
begin
=
function
(
)
{
return
this
.
m_begin
;
}
;
glsFboUtil
.
Range
.
prototype
.
end
=
function
(
)
{
return
this
.
m_end
;
}
;
glsFboUtil
.
Range
.
prototype
.
get
=
function
(
id
)
{
return
{
first
:
id
second
:
this
.
m_array
[
id
]
}
;
}
;
glsFboUtil
.
Range
.
prototype
.
reset
=
function
(
)
{
this
.
m_index
=
this
.
m_begin
;
return
this
.
current
(
)
;
}
;
glsFboUtil
.
Range
.
prototype
.
current
=
function
(
)
{
return
this
.
m_index
<
this
.
m_end
?
this
.
m_array
[
this
.
m_index
]
:
null
;
}
;
glsFboUtil
.
Range
.
prototype
.
next
=
function
(
)
{
+
+
this
.
m_index
;
}
;
glsFboUtil
.
rangeArray
=
function
(
array
)
{
return
new
glsFboUtil
.
Range
(
array
)
;
}
;
glsFboUtil
.
ImageFormat
=
function
(
format
unsizedType
)
{
this
.
format
=
format
|
|
0
;
this
.
unsizedType
=
unsizedType
|
|
0
;
}
;
glsFboUtil
.
ImageFormat
.
lessthan
=
function
(
obj1
obj2
)
{
return
(
(
obj1
.
format
<
obj2
.
format
)
|
|
(
obj1
.
format
=
=
obj2
.
format
&
&
obj1
.
unsizedType
<
obj2
.
unsizedType
)
)
;
}
;
glsFboUtil
.
ImageFormat
.
prototype
.
none
=
function
(
)
{
this
.
format
=
0
;
this
.
unsizedType
=
0
;
}
;
glsFboUtil
.
ImageFormat
.
none
=
function
(
)
{
var
obj
=
new
glsFboUtil
.
ImageFormat
(
)
;
obj
.
none
(
)
;
return
obj
;
}
;
glsFboUtil
.
formatKeyInfo
=
function
(
key
)
{
return
new
glsFboUtil
.
ImageFormat
(
(
key
&
0x0000ffff
)
(
key
&
0xffff0000
)
>
>
>
16
)
;
}
;
glsFboUtil
.
Config
=
function
(
)
{
this
.
type
=
glsFboUtil
.
Config
.
s_types
.
CONFIG
;
this
.
target
=
glsFboUtil
.
Config
.
s_target
.
NONE
;
}
;
glsFboUtil
.
Config
.
s_target
=
{
NONE
:
0
RENDERBUFFER
:
0x8D41
TEXTURE_2D
:
0x0DE1
TEXTURE_CUBE_MAP
:
0x8513
TEXTURE_3D
:
0x806F
TEXTURE_2D_ARRAY
:
0x8C1A
FRAMEBUFFER
:
0x8D40
}
;
glsFboUtil
.
Config
.
s_types
=
{
CONFIG
:
0x000001
IMAGE
:
0x000010
RENDERBUFFER
:
0x000020
TEXTURE
:
0x000040
TEXTURE_FLAT
:
0x000080
TEXTURE_2D
:
0x000100
TEXTURE_CUBE_MAP
:
0x000200
TEXTURE_LAYERED
:
0x000400
TEXTURE_3D
:
0x000800
TEXTURE_2D_ARRAY
:
0x001000
ATTACHMENT
:
0x010000
ATT_RENDERBUFFER
:
0x020000
ATT_TEXTURE
:
0x040000
ATT_TEXTURE_FLAT
:
0x080000
ATT_TEXTURE_LAYER
:
0x100000
UNUSED
:
0xFFE0E00E
}
;
glsFboUtil
.
Image
=
function
(
)
{
glsFboUtil
.
Config
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
IMAGE
;
this
.
width
=
0
;
this
.
height
=
0
;
this
.
internalFormat
=
new
glsFboUtil
.
ImageFormat
(
)
;
}
;
glsFboUtil
.
Renderbuffer
=
function
(
)
{
glsFboUtil
.
Image
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
RENDERBUFFER
;
this
.
target
=
glsFboUtil
.
Config
.
s_target
.
RENDERBUFFER
;
this
.
numSamples
=
0
;
}
;
glsFboUtil
.
Texture
=
function
(
)
{
glsFboUtil
.
Image
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
TEXTURE
;
this
.
numLevels
=
1
;
}
;
glsFboUtil
.
TextureFlat
=
function
(
)
{
glsFboUtil
.
Texture
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
TEXTURE_FLAT
;
}
;
glsFboUtil
.
Texture2D
=
function
(
)
{
glsFboUtil
.
TextureFlat
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D
;
this
.
target
=
glsFboUtil
.
Config
.
s_target
.
TEXTURE_2D
;
}
;
glsFboUtil
.
TextureCubeMap
=
function
(
)
{
glsFboUtil
.
TextureFlat
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
TEXTURE_CUBE_MAP
;
this
.
target
=
glsFboUtil
.
Config
.
s_target
.
TEXTURE_CUBE_MAP
;
}
;
glsFboUtil
.
TextureLayered
=
function
(
)
{
glsFboUtil
.
Texture
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
TEXTURE_LAYERED
;
this
.
numLayers
=
1
;
}
;
glsFboUtil
.
Texture3D
=
function
(
)
{
glsFboUtil
.
TextureLayered
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
TEXTURE_3D
;
this
.
target
=
glsFboUtil
.
Config
.
s_target
.
TEXTURE_3D
;
}
;
glsFboUtil
.
Texture2DArray
=
function
(
)
{
glsFboUtil
.
TextureLayered
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D_ARRAY
;
this
.
target
=
glsFboUtil
.
Config
.
s_target
.
TEXTURE_2D_ARRAY
;
}
;
glsFboUtil
.
Attachment
=
function
(
)
{
glsFboUtil
.
Config
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
ATTACHMENT
;
this
.
target
=
glsFboUtil
.
Config
.
s_target
.
FRAMEBUFFER
;
this
.
imageName
=
null
;
}
;
glsFboUtil
.
Attachment
.
prototype
.
isComplete
=
function
(
attPoint
image
vfr
)
{
}
;
glsFboUtil
.
RenderbufferAttachment
=
function
(
)
{
glsFboUtil
.
Attachment
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
ATT_RENDERBUFFER
;
this
.
renderbufferTarget
=
glsFboUtil
.
Config
.
s_target
.
RENDERBUFFER
;
}
;
glsFboUtil
.
RenderbufferAttachment
.
prototype
=
Object
.
create
(
glsFboUtil
.
Attachment
.
prototype
)
;
glsFboUtil
.
RenderbufferAttachment
.
prototype
.
constructor
=
glsFboUtil
.
RenderbufferAttachment
;
glsFboUtil
.
TextureAttachment
=
function
(
)
{
glsFboUtil
.
Attachment
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE
;
this
.
level
=
0
;
}
;
glsFboUtil
.
TextureAttachment
.
prototype
=
Object
.
create
(
glsFboUtil
.
Attachment
.
prototype
)
;
glsFboUtil
.
TextureAttachment
.
prototype
.
constructor
=
glsFboUtil
.
TextureAttachment
;
glsFboUtil
.
TextureFlatAttachment
=
function
(
)
{
glsFboUtil
.
TextureAttachment
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_FLAT
;
this
.
texTarget
=
glsFboUtil
.
Config
.
s_target
.
NONE
;
}
;
glsFboUtil
.
TextureFlatAttachment
.
prototype
=
Object
.
create
(
glsFboUtil
.
TextureAttachment
.
prototype
)
;
glsFboUtil
.
TextureFlatAttachment
.
prototype
.
constructor
=
glsFboUtil
.
TextureFlatAttachment
;
glsFboUtil
.
TextureLayerAttachment
=
function
(
)
{
glsFboUtil
.
TextureAttachment
.
call
(
this
)
;
this
.
type
|
=
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_LAYER
;
this
.
layer
=
0
;
}
;
glsFboUtil
.
TextureLayerAttachment
.
prototype
=
Object
.
create
(
glsFboUtil
.
TextureAttachment
.
prototype
)
;
glsFboUtil
.
TextureLayerAttachment
.
prototype
.
constructor
=
glsFboUtil
.
TextureLayerAttachment
;
glsFboUtil
.
glsup
=
function
(
)
{
var
glInit
=
function
(
cfg
gl
)
{
if
(
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D
)
!
=
0
)
{
glInitFlat
(
cfg
glTarget
(
cfg
gl
)
gl
)
;
}
else
if
(
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
TEXTURE_CUBE_MAP
)
!
=
0
)
{
for
(
var
i
=
gl
.
TEXTURE_CUBE_MAP_NEGATIVE_X
;
i
<
=
gl
.
TEXTURE_CUBE_MAP_POSITIVE_Z
;
+
+
i
)
glInitFlat
(
cfg
i
gl
)
;
}
else
if
(
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
TEXTURE_3D
)
!
=
0
)
{
glInitLayered
(
cfg
2
gl
)
;
}
else
if
(
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D_ARRAY
)
!
=
0
)
{
glInitLayered
(
cfg
1
gl
)
;
}
}
;
var
glInitFlat
=
function
(
cfg
target
gl
)
{
var
format
=
glsFboUtil
.
transferImageFormat
(
cfg
.
internalFormat
gl
)
;
var
w
=
cfg
.
width
;
var
h
=
cfg
.
height
;
for
(
var
level
=
0
;
level
<
cfg
.
numLevels
;
+
+
level
)
{
gl
.
texImage2D
(
target
level
cfg
.
internalFormat
.
format
w
h
0
format
.
format
format
.
dataType
null
)
;
w
=
Math
.
max
(
1
w
/
2
)
;
h
=
Math
.
max
(
1
h
/
2
)
;
}
}
;
var
glInitLayered
=
function
(
cfg
depth_divider
gl
)
{
var
format
=
glsFboUtil
.
transferImageFormat
(
cfg
.
internalFormat
gl
)
;
var
w
=
cfg
.
width
;
var
h
=
cfg
.
height
;
var
depth
=
cfg
.
numLayers
;
for
(
var
level
=
0
;
level
<
cfg
.
numLevels
;
+
+
level
)
{
gl
.
texImage3D
(
glTarget
(
cfg
gl
)
level
cfg
.
internalFormat
.
format
w
h
depth
0
format
.
format
format
.
dataType
null
)
;
w
=
Math
.
max
(
1
w
/
2
)
;
h
=
Math
.
max
(
1
h
/
2
)
;
depth
=
Math
.
max
(
1
depth
/
depth_divider
)
;
}
}
;
var
glCreate
=
function
(
cfg
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
if
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
RENDERBUFFER
)
{
var
ret
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
ret
)
;
if
(
cfg
.
numSamples
=
=
0
)
{
gl
.
renderbufferStorage
(
gl
.
RENDERBUFFER
cfg
.
internalFormat
.
format
cfg
.
width
cfg
.
height
)
;
}
else
{
gl
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
cfg
.
numSamples
cfg
.
internalFormat
.
format
cfg
.
width
cfg
.
height
)
;
}
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
null
)
;
}
else
if
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
TEXTURE
)
{
var
ret
=
gl
.
createTexture
(
)
;
gl
.
bindTexture
(
glTarget
(
cfg
gl
)
ret
)
;
glInit
(
cfg
gl
)
;
gl
.
bindTexture
(
glTarget
(
cfg
gl
)
null
)
;
}
else
{
throw
new
Error
(
'
Impossible
image
type
'
)
;
}
return
ret
;
}
;
var
glTarget
=
function
(
cfg
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
var
mask
=
(
glsFboUtil
.
Config
.
s_types
.
RENDERBUFFER
|
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D
|
glsFboUtil
.
Config
.
s_types
.
TEXTURE_CUBE_MAP
|
glsFboUtil
.
Config
.
s_types
.
TEXTURE_3D
|
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D_ARRAY
)
;
switch
(
cfg
.
type
&
mask
)
{
case
glsFboUtil
.
Config
.
s_types
.
RENDERBUFFER
:
return
gl
.
RENDERBUFFER
;
case
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D
:
return
gl
.
TEXTURE_2D
;
case
glsFboUtil
.
Config
.
s_types
.
TEXTURE_CUBE_MAP
:
return
gl
.
TEXTURE_CUBE_MAP
;
case
glsFboUtil
.
Config
.
s_types
.
TEXTURE_3D
:
return
gl
.
TEXTURE_3D
;
case
glsFboUtil
.
Config
.
s_types
.
TEXTURE_2D_ARRAY
:
return
gl
.
TEXTURE_2D_ARRAY
;
default
:
break
;
}
throw
new
Error
(
'
Impossible
image
type
.
'
)
;
}
;
var
glDelete
=
function
(
cfg
img
gl
)
{
if
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
RENDERBUFFER
)
gl
.
deleteRenderbuffer
(
img
)
;
else
if
(
cfg
.
type
&
glsFboUtil
.
Config
.
s_types
.
TEXTURE
)
gl
.
deleteTexture
(
img
)
;
else
throw
new
Error
(
'
Impossible
image
type
'
)
;
}
;
return
{
create
:
glCreate
remove
:
glDelete
}
;
}
(
)
;
glsFboUtil
.
imageNumSamples
=
function
(
img
)
{
return
(
img
.
numSamples
!
=
undefined
)
?
img
.
numSamples
:
0
;
}
;
glsFboUtil
.
attachAttachment
=
function
(
att
attPoint
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
var
mask
=
(
glsFboUtil
.
Config
.
s_types
.
ATT_RENDERBUFFER
|
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_FLAT
|
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_LAYER
)
;
switch
(
att
.
type
&
mask
)
{
case
glsFboUtil
.
Config
.
s_types
.
ATT_RENDERBUFFER
:
gl
.
framebufferRenderbuffer
(
att
.
target
attPoint
att
.
renderbufferTarget
(
att
.
imageName
)
)
;
break
;
case
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_FLAT
:
gl
.
framebufferTexture2D
(
att
.
target
attPoint
att
.
texTarget
(
att
.
imageName
)
att
.
level
)
;
break
;
case
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_LAYER
:
gl
.
framebufferTextureLayer
(
att
.
target
attPoint
(
att
.
imageName
)
att
.
level
att
.
layer
)
;
break
;
default
:
throw
new
Error
(
'
Impossible
attachment
type
'
)
;
}
}
;
glsFboUtil
.
attachmentType
=
function
(
att
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
if
(
att
.
type
&
glsFboUtil
.
Config
.
s_types
.
ATT_RENDERBUFFER
)
{
return
gl
.
RENDERBUFFER
;
}
if
(
att
.
type
&
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE
)
{
return
gl
.
TEXTURE
;
}
throw
new
Error
(
'
Impossible
attachment
type
.
'
)
;
}
;
glsFboUtil
.
textureLayer
=
function
(
att
)
{
if
(
att
.
type
&
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_FLAT
)
return
0
;
if
(
att
.
type
&
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE_LAYER
)
return
att
.
layer
;
throw
new
Error
(
'
Impossible
attachment
type
.
'
)
;
}
;
glsFboUtil
.
checkAttachmentCompleteness
=
function
(
cctx
att
attPoint
image
db
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
if
(
(
att
.
type
&
glsFboUtil
.
Config
.
s_types
.
ATT_TEXTURE
)
&
&
(
image
.
type
&
glsFboUtil
.
Config
.
s_types
.
TEXTURE_LAYERED
)
)
{
cctx
.
addFBOStatus
(
glsFboUtil
.
textureLayer
(
att
)
<
image
.
numLayers
gl
.
FRAMEBUFFER_INCOMPLETE_ATTACHMENT
)
;
}
cctx
.
addFBOStatus
(
image
.
width
>
0
&
&
image
.
height
>
0
gl
.
FRAMEBUFFER_INCOMPLETE_ATTACHMENT
)
;
var
flags
=
db
.
getFormatInfo
(
image
.
internalFormat
glsFboUtil
.
FormatFlags
.
ANY_FORMAT
)
;
cctx
.
addFBOStatus
(
(
flags
&
glsFboUtil
.
formatFlag
(
attPoint
)
)
!
=
0
gl
.
FRAMEBUFFER_INCOMPLETE_ATTACHMENT
)
;
cctx
.
addPotentialFBOStatus
(
(
flags
&
glsFboUtil
.
FormatFlags
.
REQUIRED_RENDERABLE
)
!
=
0
gl
.
FRAMEBUFFER_INCOMPLETE_ATTACHMENT
)
;
}
;
glsFboUtil
.
formatkey
=
function
(
format
type
)
{
return
(
(
type
<
<
16
)
>
>
>
0
|
format
)
&
0xFFFFFFFF
;
}
;
glsFboUtil
.
FormatFlags
=
{
ANY_FORMAT
:
0x00
COLOR_RENDERABLE
:
0x01
DEPTH_RENDERABLE
:
0x02
STENCIL_RENDERABLE
:
0x04
RENDERBUFFER_VALID
:
0x08
TEXTURE_VALID
:
0x10
REQUIRED_RENDERABLE
:
0x20
}
;
glsFboUtil
.
Framebuffer
=
function
(
gl
)
{
this
.
m_gl
=
gl
|
|
window
.
gl
;
this
.
fbid
=
0
;
var
fbidCompare
=
function
(
obj1
obj2
)
{
return
obj1
.
_fbid
<
obj2
.
_fbid
;
}
;
this
.
attachments
=
(
new
glsFboUtil
.
Map
(
glsFboUtil
.
Map
.
compareNumber
)
)
;
this
.
textures
=
(
new
glsFboUtil
.
Map
(
fbidCompare
)
)
;
this
.
rbos
=
(
new
glsFboUtil
.
Map
(
fbidCompare
)
)
;
}
;
glsFboUtil
.
Framebuffer
.
prototype
.
attach
=
function
(
attPoint
att
)
{
if
(
!
att
)
{
this
.
attachments
.
remove
(
attPoint
)
;
}
else
{
this
.
attachments
.
set
(
attPoint
att
)
;
}
}
;
glsFboUtil
.
Framebuffer
.
prototype
.
setTexture
=
function
(
texName
texCfg
)
{
texName
.
_fbid
=
this
.
fbid
+
+
;
this
.
textures
.
set
(
texName
texCfg
)
;
}
;
glsFboUtil
.
Framebuffer
.
prototype
.
setRbo
=
function
(
rbName
rbCfg
)
{
rbName
.
_fbid
=
this
.
fbid
+
+
;
this
.
rbos
.
set
(
rbName
rbCfg
)
;
}
;
glsFboUtil
.
Framebuffer
.
prototype
.
getImage
=
function
(
type
imgName
)
{
switch
(
type
)
{
case
this
.
m_gl
.
TEXTURE
:
return
this
.
textures
.
lookupDefault
(
(
imgName
)
null
)
;
case
this
.
m_gl
.
RENDERBUFFER
:
return
this
.
rbos
.
lookupDefault
(
(
imgName
)
null
)
;
default
:
break
;
}
throw
new
Error
(
'
Bad
image
type
.
'
)
;
}
;
glsFboUtil
.
FboBuilder
=
function
(
fbo
target
gl
)
{
glsFboUtil
.
Framebuffer
.
call
(
this
gl
)
;
this
.
m_gl
=
gl
|
|
window
.
gl
;
this
.
m_target
=
target
;
this
.
m_configs
=
[
]
;
this
.
m_error
=
this
.
m_gl
.
NO_ERROR
;
this
.
m_gl
.
bindFramebuffer
(
this
.
m_target
fbo
)
;
}
;
glsFboUtil
.
FboBuilder
.
prototype
=
Object
.
create
(
glsFboUtil
.
Framebuffer
.
prototype
)
;
glsFboUtil
.
FboBuilder
.
prototype
.
constructor
=
glsFboUtil
.
FboBuilder
;
glsFboUtil
.
FboBuilder
.
prototype
.
deinit
=
function
(
)
{
var
pair
;
for
(
var
i
=
0
;
i
<
this
.
textures
.
length
;
+
+
i
)
{
pair
=
this
.
textures
.
getIndex
(
i
)
;
glsFboUtil
.
glsup
.
remove
(
pair
.
second
pair
.
first
this
.
m_gl
)
;
}
this
.
textures
.
clear
(
)
;
for
(
var
i
=
0
;
i
<
this
.
rbos
.
length
;
+
+
i
)
{
pair
=
this
.
rbos
.
getIndex
(
i
)
;
glsFboUtil
.
glsup
.
remove
(
pair
.
second
pair
.
first
this
.
m_gl
)
;
}
this
.
rbos
.
clear
(
)
;
this
.
m_gl
.
bindFramebuffer
(
this
.
m_target
null
)
;
}
;
glsFboUtil
.
FboBuilder
.
prototype
.
glAttach
=
function
(
attPoint
att
)
{
if
(
!
att
)
{
this
.
m_gl
.
framebufferRenderbuffer
(
this
.
m_target
attPoint
this
.
m_gl
.
RENDERBUFFER
null
)
;
}
else
{
glsFboUtil
.
attachAttachment
(
att
attPoint
this
.
m_gl
)
;
}
this
.
checkError
(
)
;
this
.
attach
(
attPoint
att
)
;
}
;
glsFboUtil
.
FboBuilder
.
prototype
.
glCreateTexture
=
function
(
texCfg
)
{
var
texName
=
glsFboUtil
.
glsup
.
create
(
texCfg
this
.
m_gl
)
;
this
.
checkError
(
)
;
this
.
setTexture
(
texName
texCfg
)
;
return
texName
;
}
;
glsFboUtil
.
FboBuilder
.
prototype
.
glCreateRbo
=
function
(
rbCfg
)
{
var
rbName
=
glsFboUtil
.
glsup
.
create
(
rbCfg
this
.
m_gl
)
;
this
.
checkError
(
)
;
this
.
setRbo
(
rbName
rbCfg
)
;
return
rbName
;
}
;
glsFboUtil
.
FboBuilder
.
prototype
.
makeConfig
=
function
(
Definition
)
{
var
cfg
=
new
Definition
(
)
;
this
.
m_configs
.
push
(
cfg
)
;
return
cfg
;
}
;
glsFboUtil
.
FboBuilder
.
prototype
.
checkError
=
function
(
)
{
var
error
=
this
.
m_gl
.
getError
(
)
;
if
(
error
!
=
this
.
m_gl
.
NO_ERROR
&
&
this
.
m_error
=
=
this
.
m_gl
.
NO_ERROR
)
{
this
.
m_error
=
error
;
}
}
;
glsFboUtil
.
FboBuilder
.
prototype
.
getError
=
function
(
)
{
return
this
.
m_error
;
}
;
glsFboUtil
.
isFramebufferStatus
=
function
(
fboStatus
)
{
return
gluStrUtil
.
getFramebufferStatusName
(
fboStatus
)
!
=
'
'
;
}
glsFboUtil
.
isErrorCode
=
function
(
errorCode
)
{
return
gluStrUtil
.
getErrorName
(
errorCode
)
!
=
'
'
;
}
glsFboUtil
.
ValidStatusCodes
=
function
(
)
{
this
.
m_errorCodes
=
[
]
;
this
.
m_errorStatusCodes
=
[
]
;
this
.
m_allowComplete
=
false
;
}
;
glsFboUtil
.
ValidStatusCodes
.
prototype
.
isFBOStatusValid
=
function
(
fboStatus
)
{
if
(
fboStatus
=
=
gl
.
FRAMEBUFFER_COMPLETE
)
return
this
.
m_allowComplete
;
else
{
for
(
var
ndx
=
0
;
ndx
<
this
.
m_errorStatusCodes
.
length
;
+
+
ndx
)
{
if
(
this
.
m_errorStatusCodes
[
ndx
]
=
=
fboStatus
)
return
true
;
}
return
false
;
}
}
;
glsFboUtil
.
ValidStatusCodes
.
prototype
.
isFBOStatusRequired
=
function
(
fboStatus
)
{
if
(
fboStatus
=
=
gl
.
FRAMEBUFFER_COMPLETE
)
return
this
.
m_allowComplete
&
&
this
.
m_errorStatusCodes
.
length
=
=
0
;
else
return
!
this
.
m_allowComplete
&
&
this
.
m_errorStatusCodes
.
length
=
=
1
&
&
this
.
m_errorStatusCodes
[
0
]
=
=
fboStatus
;
}
;
glsFboUtil
.
ValidStatusCodes
.
prototype
.
isErrorCodeValid
=
function
(
errorCode
)
{
if
(
errorCode
=
=
gl
.
NO_ERROR
)
return
this
.
m_errorCodes
.
length
=
=
0
;
else
{
for
(
var
ndx
=
0
;
ndx
<
this
.
m_errorCodes
.
length
;
+
+
ndx
)
{
if
(
this
.
m_errorCodes
[
ndx
]
=
=
errorCode
)
return
true
;
}
return
false
;
}
}
;
glsFboUtil
.
ValidStatusCodes
.
prototype
.
isErrorCodeRequired
=
function
(
errorCode
)
{
if
(
this
.
m_errorCodes
.
length
=
=
0
&
&
errorCode
=
=
gl
.
NO_ERROR
)
return
true
;
else
return
this
.
m_errorCodes
.
length
=
=
1
&
&
merrorCodes
[
0
]
=
=
errorCode
;
}
;
glsFboUtil
.
ValidStatusCodes
.
prototype
.
addErrorCode
=
function
(
error
)
{
DE_ASSERT
(
glsFboUtil
.
isErrorCode
(
error
)
)
;
DE_ASSERT
(
error
!
=
gl
.
NO_ERROR
)
this
.
m_errorCodes
.
push
(
error
)
;
}
;
glsFboUtil
.
ValidStatusCodes
.
prototype
.
addFBOErrorStatus
=
function
(
status
)
{
DE_ASSERT
(
glsFboUtil
.
isFramebufferStatus
(
status
)
)
;
DE_ASSERT
(
status
!
=
gl
.
FRAMEBUFFER_COMPLETE
)
this
.
m_errorStatusCodes
.
push
(
status
)
;
}
;
glsFboUtil
.
ValidStatusCodes
.
prototype
.
setAllowComplete
=
function
(
b
)
{
this
.
m_allowComplete
=
b
;
}
;
glsFboUtil
.
CheckerFactory
;
glsFboUtil
.
Checker
=
function
(
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
this
.
m_statusCodes
=
new
glsFboUtil
.
ValidStatusCodes
(
)
;
this
.
m_statusCodes
.
setAllowComplete
(
true
)
;
if
(
typeof
(
this
.
check
)
!
=
'
function
'
)
throw
new
Error
(
'
Constructor
called
on
virtual
class
:
glsFboUtil
.
Checker
'
)
;
}
;
glsFboUtil
.
Checker
.
prototype
.
addGLError
=
function
(
condition
error
)
{
if
(
!
condition
)
{
this
.
m_statusCodes
.
addErrorCode
(
error
)
;
this
.
m_statusCodes
.
setAllowComplete
(
false
)
;
}
}
;
glsFboUtil
.
Checker
.
prototype
.
addPotentialGLError
=
function
(
condition
error
)
{
if
(
!
condition
)
{
this
.
m_statusCodes
.
addErrorCode
(
error
)
;
}
}
;
glsFboUtil
.
Checker
.
prototype
.
addFBOStatus
=
function
(
condition
status
)
{
if
(
!
condition
)
{
this
.
m_statusCodes
.
addFBOErrorStatus
(
status
)
;
this
.
m_statusCodes
.
setAllowComplete
(
false
)
;
}
}
;
glsFboUtil
.
Checker
.
prototype
.
addPotentialFBOStatus
=
function
(
condition
status
)
{
if
(
!
condition
)
{
this
.
m_statusCodes
.
addFBOErrorStatus
(
status
)
;
}
}
;
glsFboUtil
.
Checker
.
prototype
.
getStatusCodes
=
function
(
)
{
return
this
.
m_statusCodes
;
}
;
glsFboUtil
.
transferImageFormat
=
function
(
imgFormat
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
if
(
imgFormat
.
unsizedType
=
=
gl
.
NONE
)
return
gluTextureUtil
.
getTransferFormat
(
gluTextureUtil
.
mapGLInternalFormat
(
imgFormat
.
format
)
)
;
else
return
new
gluTextureUtil
.
TransferFormat
(
imgFormat
.
format
imgFormat
.
unsizedType
)
;
}
;
glsFboUtil
.
FboVerifier
=
function
(
formats
factory
)
{
this
.
m_formats
=
formats
;
this
.
m_factory
=
factory
;
}
;
glsFboUtil
.
FboVerifier
.
prototype
.
validStatusCodes
=
function
(
cfg
gl
)
{
if
(
!
(
gl
=
gl
|
|
window
.
gl
)
)
throw
new
Error
(
'
Invalid
gl
object
'
)
;
var
cctx
=
this
.
m_factory
(
)
;
for
(
var
id
=
0
;
id
<
cfg
.
textures
.
length
;
+
+
id
)
{
var
flags
=
this
.
m_formats
.
getFormatInfo
(
cfg
.
textures
.
getIndex
(
id
)
.
second
.
internalFormat
glsFboUtil
.
FormatFlags
.
ANY_FORMAT
)
;
var
textureIsValid
=
(
flags
&
glsFboUtil
.
FormatFlags
.
TEXTURE_VALID
)
!
=
0
;
cctx
.
addGLError
(
textureIsValid
gl
.
INVALID_ENUM
)
;
cctx
.
addGLError
(
textureIsValid
gl
.
INVALID_OPERATION
)
;
cctx
.
addGLError
(
textureIsValid
gl
.
INVALID_VALUE
)
;
}
for
(
var
id
=
0
;
id
<
cfg
.
rbos
.
length
;
+
+
id
)
{
var
flags
=
this
.
m_formats
.
getFormatInfo
(
cfg
.
rbos
.
getIndex
(
id
)
.
second
.
internalFormat
glsFboUtil
.
FormatFlags
.
ANY_FORMAT
)
;
var
rboIsValid
=
(
flags
&
glsFboUtil
.
FormatFlags
.
RENDERBUFFER_VALID
)
!
=
0
;
cctx
.
addGLError
(
rboIsValid
gl
.
INVALID_ENUM
)
;
}
var
count
=
0
;
for
(
var
index
=
0
;
index
<
cfg
.
attachments
.
length
;
+
+
index
)
{
var
attPoint
=
cfg
.
attachments
.
getIndex
(
index
)
.
first
;
var
att
=
cfg
.
attachments
.
getIndex
(
index
)
.
second
;
var
image
=
cfg
.
getImage
(
glsFboUtil
.
attachmentType
(
att
gl
)
att
.
imageName
)
;
glsFboUtil
.
checkAttachmentCompleteness
(
cctx
att
attPoint
image
this
.
m_formats
gl
)
;
cctx
.
check
(
attPoint
att
image
)
;
+
+
count
;
}
cctx
.
addFBOStatus
(
count
>
0
gl
.
FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT
)
;
return
cctx
.
getStatusCodes
(
)
;
}
;
}
)
;
