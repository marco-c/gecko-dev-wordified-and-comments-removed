'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsVertexArrayTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuFloat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuLogImage
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuPixelFormat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrGLContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrReferenceContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrShaderProgram
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrFragmentOperations
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrGenericVector
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrShadingContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexAttrib
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexPacket
'
)
;
goog
.
scope
(
function
(
)
{
var
glsVertexArrayTests
=
modules
.
shared
.
glsVertexArrayTests
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuFloat
=
framework
.
common
.
tcuFloat
;
var
tcuPixelFormat
=
framework
.
common
.
tcuPixelFormat
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuLogImage
=
framework
.
common
.
tcuLogImage
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
sglrGLContext
=
framework
.
opengl
.
simplereference
.
sglrGLContext
;
var
sglrReferenceContext
=
framework
.
opengl
.
simplereference
.
sglrReferenceContext
;
var
sglrShaderProgram
=
framework
.
opengl
.
simplereference
.
sglrShaderProgram
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
rrFragmentOperations
=
framework
.
referencerenderer
.
rrFragmentOperations
;
var
rrGenericVector
=
framework
.
referencerenderer
.
rrGenericVector
;
var
rrShadingContext
=
framework
.
referencerenderer
.
rrShadingContext
;
var
rrVertexAttrib
=
framework
.
referencerenderer
.
rrVertexAttrib
;
var
rrVertexPacket
=
framework
.
referencerenderer
.
rrVertexPacket
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
glsVertexArrayTests
.
deArray
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
Target
=
{
ELEMENT_ARRAY
:
0
ARRAY
:
1
}
;
glsVertexArrayTests
.
deArray
.
InputType
=
{
FLOAT
:
0
BYTE
:
1
SHORT
:
2
UNSIGNED_BYTE
:
3
UNSIGNED_SHORT
:
4
INT
:
5
UNSIGNED_INT
:
6
HALF
:
7
UNSIGNED_INT_2_10_10_10
:
8
INT_2_10_10_10
:
9
}
;
glsVertexArrayTests
.
deArray
.
OutputType
=
{
FLOAT
:
0
VEC2
:
1
VEC3
:
2
VEC4
:
3
INT
:
4
UINT
:
5
IVEC2
:
6
IVEC3
:
7
IVEC4
:
8
UVEC2
:
9
UVEC3
:
10
UVEC4
:
11
}
;
glsVertexArrayTests
.
deArray
.
Usage
=
{
DYNAMIC_DRAW
:
0
STATIC_DRAW
:
1
STREAM_DRAW
:
2
STREAM_READ
:
3
STREAM_COPY
:
4
STATIC_READ
:
5
STATIC_COPY
:
6
DYNAMIC_READ
:
7
DYNAMIC_COPY
:
8
}
;
glsVertexArrayTests
.
deArray
.
Storage
=
{
USER
:
0
BUFFER
:
1
}
;
glsVertexArrayTests
.
deArray
.
Primitive
=
{
POINTS
:
0
TRIANGLES
:
1
TRIANGLE_FAN
:
2
TRIANGLE_STRIP
:
3
}
;
glsVertexArrayTests
.
deArray
.
targetToString
=
function
(
target
)
{
DE_ASSERT
(
target
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Target
)
.
length
)
;
var
targets
=
[
'
element_array
'
'
array
'
]
;
DE_ASSERT
(
targets
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Target
)
.
length
)
;
return
targets
[
target
]
;
}
;
glsVertexArrayTests
.
deArray
.
inputTypeToString
=
function
(
type
)
{
DE_ASSERT
(
type
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
InputType
)
.
length
)
;
var
types
=
[
'
float
'
'
byte
'
'
short
'
'
unsigned_byte
'
'
unsigned_short
'
'
int
'
'
unsigned_int
'
'
half
'
'
usigned_int2_10_10_10
'
'
int2_10_10_10
'
]
;
DE_ASSERT
(
types
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
InputType
)
.
length
)
;
return
types
[
type
]
;
}
;
glsVertexArrayTests
.
deArray
.
outputTypeToString
=
function
(
type
)
{
DE_ASSERT
(
type
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
OutputType
)
.
length
)
;
var
types
=
[
'
float
'
'
vec2
'
'
vec3
'
'
vec4
'
'
int
'
'
uint
'
'
ivec2
'
'
ivec3
'
'
ivec4
'
'
uvec2
'
'
uvec3
'
'
uvec4
'
]
;
DE_ASSERT
(
types
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
OutputType
)
.
length
)
;
return
types
[
type
]
;
}
;
glsVertexArrayTests
.
deArray
.
usageTypeToString
=
function
(
usage
)
{
DE_ASSERT
(
usage
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Usage
)
.
length
)
;
var
usages
=
[
'
dynamic_draw
'
'
static_draw
'
'
stream_draw
'
'
stream_read
'
'
stream_copy
'
'
static_read
'
'
static_copy
'
'
dynamic_read
'
'
dynamic_copy
'
]
;
DE_ASSERT
(
usages
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Usage
)
.
length
)
;
return
usages
[
usage
]
;
}
;
glsVertexArrayTests
.
deArray
.
storageToString
=
function
(
storage
)
{
DE_ASSERT
(
storage
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Storage
)
.
length
)
;
var
storages
=
[
'
user_ptr
'
'
buffer
'
]
;
DE_ASSERT
(
storages
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Storage
)
.
length
)
;
return
storages
[
storage
]
;
}
;
glsVertexArrayTests
.
deArray
.
primitiveToString
=
function
(
primitive
)
{
DE_ASSERT
(
primitive
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Primitive
)
.
length
)
;
var
primitives
=
[
'
points
'
'
triangles
'
'
triangle_fan
'
'
triangle_strip
'
]
;
DE_ASSERT
(
primitives
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Primitive
)
.
length
)
;
return
primitives
[
primitive
]
;
}
;
glsVertexArrayTests
.
deArray
.
inputTypeSize
=
function
(
type
)
{
DE_ASSERT
(
type
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
InputType
)
.
length
)
;
var
size
=
[
4
1
2
1
2
4
4
2
4
/
4
4
/
4
]
;
DE_ASSERT
(
size
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
InputType
)
.
length
)
;
return
size
[
type
]
;
}
;
glsVertexArrayTests
.
inputTypeIsFloatType
=
function
(
type
)
{
if
(
type
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
)
return
true
;
if
(
type
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
)
return
true
;
return
false
;
}
;
glsVertexArrayTests
.
outputTypeIsFloatType
=
function
(
type
)
{
if
(
type
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
|
|
type
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC2
|
|
type
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
|
|
type
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
return
true
;
return
false
;
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
data
=
function
(
target
size
data
usage
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
subdata
=
function
(
target
offset
size
data
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
bind
=
function
(
attribNdx
offset
size
inType
outType
normalized
stride
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
unBind
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
isBound
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getComponentCount
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getTarget
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getInputType
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getOutputType
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getStorageType
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getNormalized
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getStride
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
getAttribNdx
=
function
(
)
{
}
;
glsVertexArrayTests
.
deArray
.
prototype
.
setAttribNdx
=
function
(
attribNdx
)
{
}
;
glsVertexArrayTests
.
ContextArray
=
function
(
storage
context
)
{
this
.
m_storage
=
storage
;
this
.
m_ctx
=
context
;
this
.
m_glBuffer
=
null
;
this
.
m_bound
=
false
;
this
.
m_attribNdx
=
0
;
this
.
m_size
=
0
;
this
.
m_data
=
null
;
this
.
m_componentCount
=
1
;
this
.
m_target
=
glsVertexArrayTests
.
deArray
.
Target
.
ARRAY
;
this
.
m_inputType
=
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
;
this
.
m_outputType
=
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
;
this
.
m_normalize
=
false
;
this
.
m_stride
=
0
;
this
.
m_offset
=
0
;
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
BUFFER
)
{
this
.
m_glBuffer
=
this
.
m_ctx
.
createBuffer
(
)
;
}
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
unBind
=
function
(
)
{
this
.
m_bound
=
false
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
isBound
=
function
(
)
{
return
this
.
m_bound
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getComponentCount
=
function
(
)
{
return
this
.
m_componentCount
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getTarget
=
function
(
)
{
return
this
.
m_target
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getInputType
=
function
(
)
{
return
this
.
m_inputType
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getOutputType
=
function
(
)
{
return
this
.
m_outputType
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getStorageType
=
function
(
)
{
return
this
.
m_storage
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getNormalized
=
function
(
)
{
return
this
.
m_normalize
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getStride
=
function
(
)
{
return
this
.
m_stride
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
getAttribNdx
=
function
(
)
{
return
this
.
m_attribNdx
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
setAttribNdx
=
function
(
attribNdx
)
{
this
.
m_attribNdx
=
attribNdx
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
data
=
function
(
target
size
ptr
usage
)
{
this
.
m_size
=
size
;
this
.
m_target
=
target
;
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
target
)
this
.
m_glBuffer
)
;
this
.
m_ctx
.
bufferData
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
target
)
ptr
glsVertexArrayTests
.
ContextArray
.
usageToGL
(
usage
)
)
;
}
else
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
USER
)
{
this
.
m_data
=
new
Uint8Array
(
size
)
;
for
(
var
i
=
0
;
i
<
size
;
i
+
+
)
this
.
m_data
[
i
]
=
ptr
[
i
]
;
}
else
throw
new
Error
(
'
glsVertexArrayTests
.
ContextArray
.
prototype
.
data
-
Invalid
storage
type
specified
'
)
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
subdata
=
function
(
target
offset
size
ptr
)
{
this
.
m_target
=
target
;
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
target
)
this
.
m_glBuffer
)
;
this
.
m_ctx
.
bufferSubData
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
target
)
offset
ptr
)
;
}
else
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
USER
)
for
(
var
i
=
offset
;
i
<
size
;
i
+
+
)
this
.
m_data
[
i
]
=
ptr
[
i
]
;
else
throw
new
Error
(
'
glsVertexArrayTests
.
ContextArray
.
prototype
.
subdata
-
Invalid
storage
type
specified
'
)
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
bind
=
function
(
attribNdx
offset
size
inType
outType
normalized
stride
)
{
this
.
m_attribNdx
=
attribNdx
;
this
.
m_bound
=
true
;
this
.
m_componentCount
=
size
;
this
.
m_inputType
=
inType
;
this
.
m_outputType
=
outType
;
this
.
m_normalize
=
normalized
;
this
.
m_stride
=
stride
;
this
.
m_offset
=
offset
;
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
bindIndexArray
=
function
(
target
)
{
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
USER
)
{
}
else
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
target
)
this
.
m_glBuffer
)
;
}
}
;
glsVertexArrayTests
.
ContextArray
.
prototype
.
glBind
=
function
(
loc
)
{
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
this
.
m_target
)
this
.
m_glBuffer
)
;
if
(
!
glsVertexArrayTests
.
inputTypeIsFloatType
(
this
.
m_inputType
)
)
{
if
(
glsVertexArrayTests
.
outputTypeIsFloatType
(
this
.
m_outputType
)
)
{
this
.
m_ctx
.
vertexAttribPointer
(
loc
this
.
m_componentCount
glsVertexArrayTests
.
ContextArray
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_normalize
this
.
m_stride
this
.
m_offset
)
;
}
else
{
this
.
m_ctx
.
vertexAttribIPointer
(
loc
this
.
m_componentCount
glsVertexArrayTests
.
ContextArray
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_stride
this
.
m_offset
)
;
}
}
else
{
DE_ASSERT
(
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
|
|
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC2
|
|
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
|
|
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
;
this
.
m_ctx
.
vertexAttribPointer
(
loc
this
.
m_componentCount
glsVertexArrayTests
.
ContextArray
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_normalize
this
.
m_stride
this
.
m_offset
)
;
}
this
.
m_ctx
.
bindBuffer
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
this
.
m_target
)
null
)
;
}
else
if
(
this
.
m_storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
USER
)
{
this
.
m_ctx
.
bindBuffer
(
glsVertexArrayTests
.
ContextArray
.
targetToGL
(
this
.
m_target
)
null
)
;
if
(
!
glsVertexArrayTests
.
inputTypeIsFloatType
(
this
.
m_inputType
)
)
{
if
(
glsVertexArrayTests
.
outputTypeIsFloatType
(
this
.
m_outputType
)
)
{
this
.
m_ctx
.
vertexAttribPointer
(
loc
this
.
m_componentCount
glsVertexArrayTests
.
ContextArray
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_normalize
this
.
m_stride
this
.
m_data
.
subarray
(
this
.
m_offset
)
)
;
}
else
{
this
.
m_ctx
.
vertexAttribIPointer
(
loc
this
.
m_componentCount
glsVertexArrayTests
.
ContextArray
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_stride
this
.
m_data
.
subarray
(
this
.
m_offset
)
)
;
}
}
else
{
DE_ASSERT
(
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
|
|
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC2
|
|
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
|
|
this
.
m_outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
;
this
.
m_ctx
.
vertexAttribPointer
(
loc
this
.
m_componentCount
glsVertexArrayTests
.
ContextArray
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_normalize
this
.
m_stride
this
.
m_data
.
subarray
(
this
.
m_offset
)
)
;
}
}
else
throw
new
Error
(
'
glsVertexArrayTests
.
ContextArray
.
prototype
.
glBind
-
Invalid
storage
type
specified
'
)
;
}
;
glsVertexArrayTests
.
ContextArray
.
targetToGL
=
function
(
target
)
{
DE_ASSERT
(
target
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Target
)
.
length
)
;
var
targets
=
[
gl
.
ELEMENT_ARRAY_BUFFER
gl
.
ARRAY_BUFFER
]
;
return
targets
[
target
]
;
}
;
glsVertexArrayTests
.
ContextArray
.
usageToGL
=
function
(
usage
)
{
DE_ASSERT
(
usage
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Usage
)
.
length
)
;
var
usages
=
[
gl
.
DYNAMIC_DRAW
gl
.
STATIC_DRAW
gl
.
STREAM_DRAW
gl
.
STREAM_READ
gl
.
STREAM_COPY
gl
.
STATIC_READ
gl
.
STATIC_COPY
gl
.
DYNAMIC_READ
gl
.
DYNAMIC_COPY
]
;
DE_ASSERT
(
usages
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Usage
)
.
length
)
;
return
usages
[
usage
]
;
}
;
glsVertexArrayTests
.
ContextArray
.
inputTypeToGL
=
function
(
type
)
{
DE_ASSERT
(
type
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
InputType
)
.
length
)
;
var
types
=
[
gl
.
FLOAT
gl
.
BYTE
gl
.
SHORT
gl
.
UNSIGNED_BYTE
gl
.
UNSIGNED_SHORT
gl
.
INT
gl
.
UNSIGNED_INT
gl
.
HALF_FLOAT
gl
.
UNSIGNED_INT_2_10_10_10_REV
gl
.
INT_2_10_10_10_REV
]
;
DE_ASSERT
(
types
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
InputType
)
.
length
)
;
return
types
[
type
]
;
}
;
glsVertexArrayTests
.
ContextArray
.
outputTypeToGLType
=
function
(
type
)
{
DE_ASSERT
(
type
<
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
OutputType
)
.
length
)
;
var
types
=
[
'
float
'
'
vec2
'
'
vec3
'
'
vec4
'
'
int
'
'
uint
'
'
ivec2
'
'
ivec3
'
'
ivec4
'
'
uvec2
'
'
uvec3
'
'
uvec4
'
]
;
DE_ASSERT
(
types
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
OutputType
)
.
length
)
;
return
types
[
type
]
;
}
;
glsVertexArrayTests
.
ContextArray
.
primitiveToGL
=
function
(
primitive
)
{
var
primitives
=
[
gl
.
POINTS
gl
.
TRIANGLES
gl
.
TRIANGLE_FAN
gl
.
TRIANGLE_STRIP
]
;
DE_ASSERT
(
primitives
.
length
=
=
Object
.
keys
(
glsVertexArrayTests
.
deArray
.
Primitive
)
.
length
)
;
return
primitives
[
primitive
]
;
}
;
glsVertexArrayTests
.
ContextArrayPack
=
function
(
drawContext
)
{
this
.
m_renderCtx
=
gl
;
this
.
m_ctx
=
drawContext
;
this
.
m_arrays
=
[
]
;
this
.
m_program
;
this
.
m_screen
=
new
tcuSurface
.
Surface
(
Math
.
min
(
512
canvas
.
width
)
Math
.
min
(
512
canvas
.
height
)
)
;
}
;
glsVertexArrayTests
.
ContextArrayPack
.
prototype
.
getArrayCount
=
function
(
)
{
return
this
.
m_arrays
.
length
;
}
;
glsVertexArrayTests
.
ContextArrayPack
.
prototype
.
newArray
=
function
(
storage
)
{
this
.
m_arrays
.
push
(
new
glsVertexArrayTests
.
ContextArray
(
storage
this
.
m_ctx
)
)
;
}
;
glsVertexArrayTests
.
ContextArrayPack
.
prototype
.
getArray
=
function
(
i
)
{
return
this
.
m_arrays
[
i
]
;
}
;
glsVertexArrayTests
.
ContextArrayPack
.
prototype
.
updateProgram
=
function
(
)
{
this
.
m_program
=
new
glsVertexArrayTests
.
ContextShaderProgram
(
this
.
m_renderCtx
this
.
m_arrays
)
;
}
;
glsVertexArrayTests
.
ContextArrayPack
.
prototype
.
render
=
function
(
primitive
firstVertex
vertexCount
useVao
coordScale
colorScale
)
{
var
program
;
var
vaoID
=
null
;
this
.
updateProgram
(
)
;
this
.
m_ctx
.
viewport
(
0
0
this
.
m_screen
.
getWidth
(
)
this
.
m_screen
.
getHeight
(
)
)
;
this
.
m_ctx
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
this
.
m_ctx
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
program
=
this
.
m_ctx
.
createProgram
(
this
.
m_program
)
;
this
.
m_ctx
.
useProgram
(
program
)
;
this
.
m_ctx
.
uniform1f
(
this
.
m_ctx
.
getUniformLocation
(
program
'
u_coordScale
'
)
coordScale
)
;
this
.
m_ctx
.
uniform1f
(
this
.
m_ctx
.
getUniformLocation
(
program
'
u_colorScale
'
)
colorScale
)
;
if
(
useVao
)
{
vaoID
=
this
.
m_ctx
.
createVertexArray
(
)
;
this
.
m_ctx
.
bindVertexArray
(
vaoID
)
;
}
var
attribName
;
var
loc
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
this
.
m_arrays
.
length
;
arrayNdx
+
+
)
{
if
(
this
.
m_arrays
[
arrayNdx
]
.
isBound
(
)
)
{
attribName
=
'
a_
'
+
this
.
m_arrays
[
arrayNdx
]
.
getAttribNdx
(
)
;
loc
=
this
.
m_ctx
.
getAttribLocation
(
program
attribName
)
;
this
.
m_ctx
.
enableVertexAttribArray
(
loc
)
;
this
.
m_arrays
[
arrayNdx
]
.
glBind
(
loc
)
;
}
}
DE_ASSERT
(
(
firstVertex
%
6
)
=
=
0
)
;
this
.
m_ctx
.
drawQuads
(
gl
.
TRIANGLES
firstVertex
vertexCount
-
firstVertex
)
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
this
.
m_arrays
.
length
;
arrayNdx
+
+
)
{
if
(
this
.
m_arrays
[
arrayNdx
]
.
isBound
(
)
)
{
attribName
=
'
a_
'
+
this
.
m_arrays
[
arrayNdx
]
.
getAttribNdx
(
)
;
loc
=
this
.
m_ctx
.
getAttribLocation
(
program
attribName
)
;
this
.
m_ctx
.
disableVertexAttribArray
(
loc
)
;
}
}
if
(
useVao
)
vaoID
=
this
.
m_ctx
.
deleteVertexArray
(
vaoID
)
;
this
.
m_ctx
.
deleteProgram
(
program
)
;
this
.
m_ctx
.
useProgram
(
null
)
;
this
.
m_ctx
.
readPixels
(
0
0
this
.
m_screen
.
getWidth
(
)
this
.
m_screen
.
getHeight
(
)
gl
.
RGBA
gl
.
UNSIGNED_BYTE
this
.
m_screen
.
getAccess
(
)
.
getDataPtr
(
)
)
;
}
;
glsVertexArrayTests
.
ContextArrayPack
.
prototype
.
getSurface
=
function
(
)
{
return
this
.
m_screen
;
}
;
glsVertexArrayTests
.
ContextShaderProgram
=
function
(
ctx
arrays
)
{
sglrShaderProgram
.
ShaderProgram
.
call
(
this
this
.
createProgramDeclaration
(
ctx
arrays
)
)
;
this
.
m_componentCount
=
new
Array
(
arrays
.
length
)
;
this
.
m_attrType
=
new
Array
(
arrays
.
length
)
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
{
this
.
m_componentCount
[
arrayNdx
]
=
this
.
getComponentCount
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
;
this
.
m_attrType
[
arrayNdx
]
=
this
.
mapOutputType
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
;
}
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
=
Object
.
create
(
sglrShaderProgram
.
ShaderProgram
.
prototype
)
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
constructor
=
glsVertexArrayTests
.
ContextShaderProgram
;
glsVertexArrayTests
.
calcShaderColorCoord
=
function
(
coord
color
attribValue
isCoordinate
numComponents
)
{
if
(
isCoordinate
)
switch
(
numComponents
)
{
case
1
:
coord
[
0
]
=
attribValue
[
0
]
;
coord
[
1
]
=
attribValue
[
0
]
;
break
;
case
2
:
coord
[
0
]
=
attribValue
[
0
]
;
coord
[
1
]
=
attribValue
[
1
]
;
break
;
case
3
:
coord
[
0
]
=
attribValue
[
0
]
+
attribValue
[
2
]
;
coord
[
1
]
=
attribValue
[
1
]
;
break
;
case
4
:
coord
[
0
]
=
attribValue
[
0
]
+
attribValue
[
2
]
;
coord
[
1
]
=
attribValue
[
1
]
+
attribValue
[
3
]
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
calcShaderColorCoord
-
Invalid
number
of
components
'
)
;
}
else
{
switch
(
numComponents
)
{
case
1
:
color
[
0
]
=
color
[
0
]
*
attribValue
[
0
]
;
break
;
case
2
:
color
[
0
]
=
color
[
0
]
*
attribValue
[
0
]
;
color
[
1
]
=
color
[
1
]
*
attribValue
[
1
]
;
break
;
case
3
:
color
[
0
]
=
color
[
0
]
*
attribValue
[
0
]
;
color
[
1
]
=
color
[
1
]
*
attribValue
[
1
]
;
color
[
2
]
=
color
[
2
]
*
attribValue
[
2
]
;
break
;
case
4
:
color
[
0
]
=
color
[
0
]
*
attribValue
[
0
]
*
attribValue
[
3
]
;
color
[
1
]
=
color
[
1
]
*
attribValue
[
1
]
*
attribValue
[
3
]
;
color
[
2
]
=
color
[
2
]
*
attribValue
[
2
]
*
attribValue
[
3
]
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
calcShaderColorCoord
-
Invalid
number
of
components
'
)
;
}
}
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
shadeVertices
=
function
(
inputs
packets
numPackets
)
{
var
u_coordScale
=
this
.
getUniformByName
(
'
u_coordScale
'
)
.
value
[
0
]
;
var
u_colorScale
=
this
.
getUniformByName
(
'
u_colorScale
'
)
.
value
[
0
]
;
for
(
var
packetNdx
=
0
;
packetNdx
<
numPackets
;
+
+
packetNdx
)
{
var
varyingLocColor
=
0
;
var
packet
=
packets
[
packetNdx
]
;
var
coord
=
[
1
.
0
1
.
0
]
;
var
color
=
[
1
.
0
1
.
0
1
.
0
]
;
for
(
var
attribNdx
=
0
;
attribNdx
<
this
.
m_attrType
.
length
;
attribNdx
+
+
)
{
var
numComponents
=
this
.
m_componentCount
[
attribNdx
]
;
glsVertexArrayTests
.
calcShaderColorCoord
(
coord
color
rrVertexAttrib
.
readVertexAttrib
(
inputs
[
attribNdx
]
packet
.
instanceNdx
packet
.
vertexNdx
this
.
m_attrType
[
attribNdx
]
)
attribNdx
=
=
0
numComponents
)
;
}
packet
.
position
=
[
u_coordScale
*
coord
[
0
]
u_coordScale
*
coord
[
1
]
1
.
0
1
.
0
]
;
packet
.
outputs
[
varyingLocColor
]
=
[
u_colorScale
*
color
[
0
]
u_colorScale
*
color
[
1
]
u_colorScale
*
color
[
2
]
1
.
0
]
;
}
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
shadeFragments
=
function
(
packets
context
)
{
var
varyingLocColor
=
0
;
for
(
var
packetNdx
=
0
;
packetNdx
<
packets
.
length
;
+
+
packetNdx
)
packets
[
packetNdx
]
.
value
=
rrShadingContext
.
readTriangleVarying
(
packets
[
packetNdx
]
context
varyingLocColor
)
;
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
genVertexSource
=
function
(
arrays
)
{
var
vertexShaderSrc
=
'
'
;
var
params
=
[
]
;
params
[
'
VTX_IN
'
]
=
'
in
'
;
params
[
'
VTX_OUT
'
]
=
'
out
'
;
params
[
'
FRAG_IN
'
]
=
'
in
'
;
params
[
'
FRAG_COLOR
'
]
=
'
dEQP_FragColor
'
;
params
[
'
VTX_HDR
'
]
=
'
#
version
300
es
\
n
'
;
params
[
'
FRAG_HDR
'
]
=
'
#
version
300
es
\
nlayout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
;
vertexShaderSrc
+
=
params
[
'
VTX_HDR
'
]
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
{
vertexShaderSrc
+
=
params
[
'
VTX_IN
'
]
+
'
highp
'
+
glsVertexArrayTests
.
ContextArray
.
outputTypeToGLType
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
+
'
a_
'
+
arrays
[
arrayNdx
]
.
getAttribNdx
(
)
+
'
;
\
n
'
;
}
vertexShaderSrc
+
=
'
uniform
highp
float
u_coordScale
;
\
n
'
+
'
uniform
highp
float
u_colorScale
;
\
n
'
+
params
[
'
VTX_OUT
'
]
+
'
mediump
vec4
v_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
\
tgl_PointSize
=
1
.
0
;
\
n
'
+
'
\
thighp
vec2
coord
=
vec2
(
1
.
0
1
.
0
)
;
\
n
'
+
'
\
thighp
vec3
color
=
vec3
(
1
.
0
1
.
0
1
.
0
)
;
\
n
'
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
{
if
(
arrays
[
arrayNdx
]
.
getAttribNdx
(
)
=
=
0
)
{
switch
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
{
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
)
:
vertexShaderSrc
+
=
'
\
tcoord
=
vec2
(
a_0
)
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC2
)
:
vertexShaderSrc
+
=
'
\
tcoord
=
a_0
.
xy
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
)
:
vertexShaderSrc
+
=
'
\
tcoord
=
a_0
.
xy
;
\
n
'
+
'
\
tcoord
.
x
=
coord
.
x
+
a_0
.
z
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
:
vertexShaderSrc
+
=
'
\
tcoord
=
a_0
.
xy
;
\
n
'
+
'
\
tcoord
+
=
a_0
.
zw
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC2
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC2
)
:
vertexShaderSrc
+
=
'
\
tcoord
=
vec2
(
a_0
.
xy
)
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC3
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC3
)
:
vertexShaderSrc
+
=
'
\
tcoord
=
vec2
(
a_0
.
xy
)
;
\
n
'
+
'
\
tcoord
.
x
=
coord
.
x
+
float
(
a_0
.
z
)
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC4
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC4
)
:
vertexShaderSrc
+
=
'
\
tcoord
=
vec2
(
a_0
.
xy
)
;
\
n
'
+
'
\
tcoord
+
=
vec2
(
a_0
.
zw
)
;
\
n
'
;
break
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
break
;
}
continue
;
}
switch
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
{
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
)
:
vertexShaderSrc
+
=
'
\
tcolor
=
color
*
a_
'
+
arrays
[
arrayNdx
]
.
getAttribNdx
(
)
+
'
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC2
)
:
vertexShaderSrc
+
=
'
\
tcolor
.
rg
=
color
.
rg
*
a_
'
+
arrays
[
arrayNdx
]
.
getAttribNdx
(
)
+
'
.
xy
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
)
:
vertexShaderSrc
+
=
'
\
tcolor
=
color
.
rgb
*
a_
'
+
arrays
[
arrayNdx
]
.
getAttribNdx
(
)
+
'
.
xyz
;
\
n
'
;
break
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
:
vertexShaderSrc
+
=
'
\
tcolor
=
color
.
rgb
*
a_
'
+
arrays
[
arrayNdx
]
.
getAttribNdx
(
)
+
'
.
xyz
*
a_
'
+
arrays
[
arrayNdx
]
.
getAttribNdx
(
)
+
'
.
w
;
\
n
'
;
break
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
break
;
}
}
vertexShaderSrc
+
=
'
\
tv_color
=
vec4
(
u_colorScale
*
color
1
.
0
)
;
\
n
'
+
'
\
tgl_Position
=
vec4
(
u_coordScale
*
coord
1
.
0
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
return
vertexShaderSrc
;
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
genFragmentSource
=
function
(
)
{
var
params
=
[
]
;
params
[
'
VTX_IN
'
]
=
'
in
'
;
params
[
'
VTX_OUT
'
]
=
'
out
'
;
params
[
'
FRAG_IN
'
]
=
'
in
'
;
params
[
'
FRAG_COLOR
'
]
=
'
dEQP_FragColor
'
;
params
[
'
VTX_HDR
'
]
=
'
#
version
300
es
\
n
'
;
params
[
'
FRAG_HDR
'
]
=
'
#
version
300
es
\
nlayout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
;
var
fragmentShaderSrc
=
params
[
'
FRAG_HDR
'
]
+
params
[
'
FRAG_IN
'
]
+
'
mediump
vec4
v_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
\
t
'
+
params
[
'
FRAG_COLOR
'
]
+
'
=
v_color
;
\
n
'
+
'
}
\
n
'
;
return
fragmentShaderSrc
;
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
mapOutputType
=
function
(
type
)
{
switch
(
type
)
{
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC2
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
:
return
rrGenericVector
.
GenericVecType
.
FLOAT
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
INT
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC2
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC3
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC4
)
:
return
rrGenericVector
.
GenericVecType
.
INT32
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UINT
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC2
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC3
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC4
)
:
return
rrGenericVector
.
GenericVecType
.
UINT32
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
}
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
getComponentCount
=
function
(
type
)
{
switch
(
type
)
{
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
FLOAT
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
INT
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UINT
)
:
return
1
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC2
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC2
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC2
)
:
return
2
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC3
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC3
)
:
return
3
;
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC4
)
:
case
(
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC4
)
:
return
4
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
}
}
;
glsVertexArrayTests
.
ContextShaderProgram
.
prototype
.
createProgramDeclaration
=
function
(
ctx
arrays
)
{
var
decl
=
new
sglrShaderProgram
.
ShaderProgramDeclaration
(
)
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
decl
.
pushVertexAttribute
(
new
sglrShaderProgram
.
VertexAttribute
(
'
a_
'
+
arrayNdx
this
.
mapOutputType
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
)
)
;
decl
.
pushVertexToFragmentVarying
(
new
sglrShaderProgram
.
VertexToFragmentVarying
(
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushFragmentOutput
(
new
sglrShaderProgram
.
FragmentOutput
(
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushVertexSource
(
new
sglrShaderProgram
.
VertexSource
(
this
.
genVertexSource
(
arrays
)
)
)
;
decl
.
pushFragmentSource
(
new
sglrShaderProgram
.
FragmentSource
(
this
.
genFragmentSource
(
)
)
)
;
decl
.
pushUniform
(
new
sglrShaderProgram
.
Uniform
(
'
u_coordScale
'
gluShaderUtil
.
DataType
.
FLOAT
)
)
;
decl
.
pushUniform
(
new
sglrShaderProgram
.
Uniform
(
'
u_colorScale
'
gluShaderUtil
.
DataType
.
FLOAT
)
)
;
return
decl
;
}
;
glsVertexArrayTests
.
GLValue
=
function
(
)
{
this
.
m_value
=
[
0
]
;
this
.
m_type
;
}
;
glsVertexArrayTests
.
copyGLValueToArray
=
function
(
dst
val
)
{
var
val8
=
new
Uint8Array
(
val
.
m_value
.
buffer
)
;
dst
.
set
(
val8
)
;
}
;
glsVertexArrayTests
.
copyArray
=
function
(
dst
src
)
{
var
src8
=
new
Uint8Array
(
src
.
buffer
)
.
subarray
(
src
.
byteOffset
src
.
byteOffset
+
src
.
byteLength
)
;
dst
.
set
(
src8
)
;
}
;
glsVertexArrayTests
.
GLValue
.
typeToTypedArray
=
function
(
value
type
)
{
var
array
;
switch
(
type
)
{
case
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
:
array
=
new
Float32Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
BYTE
:
array
=
new
Int8Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
SHORT
:
array
=
new
Int16Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_BYTE
:
array
=
new
Uint8Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_SHORT
:
array
=
new
Uint16Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT
:
array
=
new
Int32Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT
:
array
=
new
Uint32Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
:
array
=
new
Uint16Array
(
1
)
;
value
=
glsVertexArrayTests
.
GLValue
.
floatToHalf
(
value
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT_2_10_10_10
:
array
=
new
Uint32Array
(
1
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT_2_10_10_10
:
array
=
new
Int32Array
(
1
)
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
GLValue
.
typeToTypedArray
-
Invalid
InputType
'
)
;
}
array
[
0
]
=
value
;
return
array
;
}
;
glsVertexArrayTests
.
GLValue
.
create
=
function
(
value
type
)
{
var
v
=
new
glsVertexArrayTests
.
GLValue
(
)
;
v
.
m_value
=
glsVertexArrayTests
.
GLValue
.
typeToTypedArray
(
value
type
)
;
v
.
m_type
=
type
;
return
v
;
}
;
glsVertexArrayTests
.
GLValue
.
halfToFloat
=
function
(
value
)
{
return
tcuFloat
.
halfFloatToNumberNoDenorm
(
value
)
;
}
;
glsVertexArrayTests
.
GLValue
.
floatToHalf
=
function
(
f
)
{
return
tcuFloat
.
numberToHalfFloatNoDenorm
(
f
)
;
}
;
glsVertexArrayTests
.
GLValue
.
getMaxValue
=
function
(
type
)
{
var
value
;
switch
(
type
)
{
case
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
:
value
=
127
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
BYTE
:
value
=
127
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
SHORT
:
value
=
32760
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_BYTE
:
value
=
255
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_SHORT
:
value
=
65530
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT
:
value
=
2147483647
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT
:
value
=
4294967295
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
:
value
=
256
;
break
;
default
:
return
new
glsVertexArrayTests
.
GLValue
(
)
;
}
return
glsVertexArrayTests
.
GLValue
.
create
(
value
type
)
;
}
;
glsVertexArrayTests
.
GLValue
.
getMinValue
=
function
(
type
)
{
var
value
;
switch
(
type
)
{
case
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
:
value
=
-
127
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
BYTE
:
value
=
-
127
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
SHORT
:
value
=
-
32760
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_BYTE
:
value
=
0
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_SHORT
:
value
=
0
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT
:
value
=
-
2147483647
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT
:
value
=
0
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
:
value
=
-
256
;
break
;
default
:
return
new
glsVertexArrayTests
.
GLValue
(
)
;
}
return
glsVertexArrayTests
.
GLValue
.
create
(
value
type
)
;
}
;
glsVertexArrayTests
.
GLValue
.
getRandom
=
function
(
rnd
min
max
)
{
DE_ASSERT
(
min
.
getType
(
)
=
=
max
.
getType
(
)
)
;
var
minv
=
min
.
interpret
(
)
;
var
maxv
=
max
.
interpret
(
)
;
var
type
=
min
.
getType
(
)
;
var
value
;
if
(
maxv
<
minv
)
return
min
;
switch
(
type
)
{
case
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
:
{
return
glsVertexArrayTests
.
GLValue
.
create
(
minv
+
rnd
.
getFloat
(
)
*
(
maxv
-
minv
)
type
)
;
break
;
}
case
glsVertexArrayTests
.
deArray
.
InputType
.
SHORT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_SHORT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
BYTE
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_BYTE
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT
:
{
return
glsVertexArrayTests
.
GLValue
.
create
(
minv
+
rnd
.
getInt
(
)
%
(
maxv
-
minv
)
type
)
;
break
;
}
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
GLValue
.
getRandom
-
Invalid
input
type
'
)
;
break
;
}
}
;
glsVertexArrayTests
.
GLValue
.
minValue
=
function
(
type
)
{
switch
(
type
)
{
case
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
BYTE
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
:
return
glsVertexArrayTests
.
GLValue
.
create
(
4
type
)
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
SHORT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_SHORT
:
return
glsVertexArrayTests
.
GLValue
.
create
(
4
*
256
type
)
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_BYTE
:
return
glsVertexArrayTests
.
GLValue
.
create
(
4
*
2
type
)
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT
:
return
glsVertexArrayTests
.
GLValue
.
create
(
4
*
16777216
type
)
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
GLValue
.
minValue
-
Invalid
input
type
'
)
;
}
}
;
glsVertexArrayTests
.
GLValue
.
abs
=
function
(
val
)
{
var
type
=
val
.
getType
(
)
;
switch
(
type
)
{
case
glsVertexArrayTests
.
deArray
.
InputType
.
SHORT
:
return
glsVertexArrayTests
.
GLValue
.
create
(
0x7FFF
&
val
.
getValue
(
)
type
)
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
BYTE
:
return
glsVertexArrayTests
.
GLValue
.
create
(
0x7F
&
val
.
getValue
(
)
type
)
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_BYTE
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_SHORT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT
:
return
val
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
:
return
glsVertexArrayTests
.
GLValue
.
create
(
Math
.
abs
(
val
.
interpret
(
)
)
type
)
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT
:
return
glsVertexArrayTests
.
GLValue
.
create
(
0x7FFFFFFF
&
val
.
getValue
(
)
type
)
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
GLValue
.
abs
-
Invalid
input
type
'
)
;
}
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
getType
=
function
(
)
{
return
this
.
m_type
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
toFloat
=
function
(
)
{
return
this
.
interpret
(
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
getValue
=
function
(
)
{
return
this
.
m_value
[
0
]
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
interpret
=
function
(
)
{
if
(
this
.
m_type
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
)
return
glsVertexArrayTests
.
GLValue
.
halfToFloat
(
this
.
m_value
[
0
]
)
;
return
this
.
m_value
[
0
]
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
add
=
function
(
other
)
{
return
glsVertexArrayTests
.
GLValue
.
create
(
this
.
interpret
(
)
+
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
mul
=
function
(
other
)
{
return
glsVertexArrayTests
.
GLValue
.
create
(
this
.
interpret
(
)
*
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
div
=
function
(
other
)
{
return
glsVertexArrayTests
.
GLValue
.
create
(
this
.
interpret
(
)
/
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
sub
=
function
(
other
)
{
return
glsVertexArrayTests
.
GLValue
.
create
(
this
.
interpret
(
)
-
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
addToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
+
other
.
interpret
(
)
;
return
this
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
subToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
-
other
.
interpret
(
)
;
return
this
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
mulToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
*
other
.
interpret
(
)
;
return
this
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
divToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
/
other
.
interpret
(
)
;
return
this
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
equals
=
function
(
other
)
{
return
this
.
m_value
[
0
]
=
=
other
.
getValue
(
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
lessThan
=
function
(
other
)
{
return
this
.
interpret
(
)
<
other
.
interpret
(
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
greaterThan
=
function
(
other
)
{
return
this
.
interpret
(
)
>
other
.
interpret
(
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
lessOrEqualThan
=
function
(
other
)
{
return
this
.
interpret
(
)
<
=
other
.
interpret
(
)
;
}
;
glsVertexArrayTests
.
GLValue
.
prototype
.
greaterOrEqualThan
=
function
(
other
)
{
return
this
.
interpret
(
)
>
=
other
.
interpret
(
)
;
}
;
glsVertexArrayTests
.
RandomArrayGenerator
=
function
(
)
{
}
;
glsVertexArrayTests
.
RandomArrayGenerator
.
setData
=
function
(
data
type
rnd
min
max
)
{
var
value
=
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
min
max
)
;
DE_ASSERT
(
value
.
getType
(
)
=
=
type
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
data
value
)
;
}
;
glsVertexArrayTests
.
RandomArrayGenerator
.
generateArray
=
function
(
seed
min
max
count
componentCount
stride
type
)
{
var
data
;
var
data8
;
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
if
(
stride
=
=
0
)
stride
=
componentCount
*
glsVertexArrayTests
.
deArray
.
inputTypeSize
(
type
)
;
data
=
new
ArrayBuffer
(
stride
*
count
)
;
data8
=
new
Uint8Array
(
data
)
;
for
(
var
vertexNdx
=
0
;
vertexNdx
<
count
;
vertexNdx
+
+
)
{
for
(
var
componentNdx
=
0
;
componentNdx
<
componentCount
;
componentNdx
+
+
)
{
glsVertexArrayTests
.
RandomArrayGenerator
.
setData
(
data8
.
subarray
(
vertexNdx
*
stride
+
glsVertexArrayTests
.
deArray
.
inputTypeSize
(
type
)
*
componentNdx
)
type
rnd
min
max
)
;
}
}
return
data
;
}
;
glsVertexArrayTests
.
RandomArrayGenerator
.
generateQuads
=
function
(
seed
count
componentCount
offset
stride
primitive
type
min
max
scale
)
{
var
data
;
switch
(
type
)
{
case
glsVertexArrayTests
.
deArray
.
InputType
.
FLOAT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
BYTE
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
SHORT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_BYTE
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_SHORT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
HALF
:
data
=
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuads
(
seed
count
componentCount
offset
stride
primitive
min
max
scale
)
;
break
;
case
glsVertexArrayTests
.
deArray
.
InputType
.
INT_2_10_10_10
:
case
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT_2_10_10_10
:
data
=
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuadsPacked
(
seed
count
componentCount
offset
stride
primitive
)
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
RandomArrayGenerator
.
generateQuads
-
Invalid
input
type
'
)
;
break
;
}
return
data
;
}
;
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuadsPacked
=
function
(
seed
count
componentCount
offset
stride
primitive
)
{
DE_ASSERT
(
componentCount
=
=
4
)
;
var
quadStride
=
0
;
if
(
stride
=
=
0
)
stride
=
deMath
.
INT32_SIZE
;
switch
(
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
quadStride
=
stride
*
6
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuadsPacked
-
Invalid
primitive
'
)
;
break
;
}
var
_data
=
new
ArrayBuffer
(
offset
+
quadStride
*
(
count
-
1
)
+
stride
*
5
+
componentCount
*
glsVertexArrayTests
.
deArray
.
inputTypeSize
(
glsVertexArrayTests
.
deArray
.
InputType
.
INT_2_10_10_10
)
)
;
var
resultData
=
new
Uint8Array
(
_data
)
.
subarray
(
offset
)
;
var
max
=
1024
;
var
min
=
10
;
var
max2
=
4
;
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
switch
(
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
{
for
(
var
quadNdx
=
0
;
quadNdx
<
count
;
quadNdx
+
+
)
{
var
x1
=
min
+
rnd
.
getInt
(
)
%
(
max
-
min
)
;
var
x2
=
min
+
rnd
.
getInt
(
)
%
(
max
-
x1
)
;
var
y1
=
min
+
rnd
.
getInt
(
)
%
(
max
-
min
)
;
var
y2
=
min
+
rnd
.
getInt
(
)
%
(
max
-
y1
)
;
var
z
=
min
+
rnd
.
getInt
(
)
%
(
max
-
min
)
;
var
w
=
rnd
.
getInt
(
)
%
max2
;
var
val1
=
(
w
<
<
30
)
|
(
z
<
<
20
)
|
(
y1
<
<
10
)
|
x1
;
var
val2
=
(
w
<
<
30
)
|
(
z
<
<
20
)
|
(
y1
<
<
10
)
|
x2
;
var
val3
=
(
w
<
<
30
)
|
(
z
<
<
20
)
|
(
y2
<
<
10
)
|
x1
;
var
val4
=
(
w
<
<
30
)
|
(
z
<
<
20
)
|
(
y2
<
<
10
)
|
x1
;
var
val5
=
(
w
<
<
30
)
|
(
z
<
<
20
)
|
(
y1
<
<
10
)
|
x2
;
var
val6
=
(
w
<
<
30
)
|
(
z
<
<
20
)
|
(
y2
<
<
10
)
|
x2
;
glsVertexArrayTests
.
copyArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
0
)
new
Uint32Array
(
[
val1
]
)
)
;
glsVertexArrayTests
.
copyArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
1
)
new
Uint32Array
(
[
val2
]
)
)
;
glsVertexArrayTests
.
copyArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
2
)
new
Uint32Array
(
[
val3
]
)
)
;
glsVertexArrayTests
.
copyArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
3
)
new
Uint32Array
(
[
val4
]
)
)
;
glsVertexArrayTests
.
copyArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
4
)
new
Uint32Array
(
[
val5
]
)
)
;
glsVertexArrayTests
.
copyArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
5
)
new
Uint32Array
(
[
val6
]
)
)
;
}
break
;
}
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuadsPacked
-
Invalid
primitive
'
)
;
break
;
}
return
_data
;
}
;
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuads
=
function
(
seed
count
componentCount
offset
stride
primitive
min
max
scale
)
{
var
componentStride
=
min
.
m_value
.
byteLength
;
var
quadStride
=
0
;
var
type
=
min
.
getType
(
)
;
if
(
stride
=
=
0
)
stride
=
componentCount
*
componentStride
;
DE_ASSERT
(
stride
>
=
componentCount
*
componentStride
)
;
switch
(
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
quadStride
=
stride
*
6
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuads
-
Invalid
primitive
'
)
;
break
;
}
var
_data
=
new
ArrayBuffer
(
offset
+
quadStride
*
count
)
;
var
resultData
=
new
Uint8Array
(
_data
)
.
subarray
(
offset
)
;
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
switch
(
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
{
for
(
var
quadNdx
=
0
;
quadNdx
<
count
;
+
+
quadNdx
)
{
var
x1
=
null
;
var
x2
=
null
;
var
y1
=
null
;
var
y2
=
null
;
var
z
=
null
;
var
w
=
null
;
for
(
var
attemptNdx
=
0
;
attemptNdx
<
4
;
+
+
attemptNdx
)
{
x1
=
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
min
max
)
;
x2
=
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
glsVertexArrayTests
.
GLValue
.
minValue
(
type
)
glsVertexArrayTests
.
GLValue
.
abs
(
max
.
sub
(
x1
)
)
)
;
y1
=
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
min
max
)
;
y2
=
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
glsVertexArrayTests
.
GLValue
.
minValue
(
type
)
glsVertexArrayTests
.
GLValue
.
abs
(
max
.
sub
(
y1
)
)
)
;
z
=
(
componentCount
>
2
)
?
(
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
min
max
)
)
:
(
glsVertexArrayTests
.
GLValue
.
create
(
0
type
)
)
;
w
=
(
componentCount
>
3
)
?
(
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
min
max
)
)
:
(
glsVertexArrayTests
.
GLValue
.
create
(
1
type
)
)
;
if
(
componentCount
<
=
2
)
break
;
if
(
(
Math
.
abs
(
x2
.
interpret
(
)
+
z
.
interpret
(
)
)
<
glsVertexArrayTests
.
GLValue
.
minValue
(
type
)
.
interpret
(
)
)
|
|
(
Math
.
abs
(
y2
.
interpret
(
)
+
w
.
interpret
(
)
)
<
glsVertexArrayTests
.
GLValue
.
minValue
(
type
)
.
interpret
(
)
)
)
continue
;
break
;
}
x2
=
x1
.
add
(
x2
)
;
y2
=
y1
.
add
(
y2
)
;
var
round
=
function
(
pos
scale
offset
range
)
{
var
val
=
(
pos
.
interpret
(
)
+
offset
)
*
scale
;
var
half
=
range
/
2
;
val
=
val
*
half
+
half
;
val
=
Math
.
round
(
val
)
;
val
=
(
val
-
half
)
/
half
;
val
=
val
/
scale
-
offset
;
return
glsVertexArrayTests
.
GLValue
.
create
(
val
pos
.
m_type
)
;
}
;
var
viewport
=
gl
.
getParameter
(
gl
.
VIEWPORT
)
;
var
voffset
=
0
;
if
(
componentCount
>
2
)
voffset
=
z
.
interpret
(
)
;
x1
=
round
(
x1
scale
voffset
viewport
[
2
]
)
;
x2
=
round
(
x2
scale
voffset
viewport
[
2
]
)
;
voffset
=
1
;
if
(
componentCount
>
3
)
voffset
=
w
.
interpret
(
)
;
y1
=
round
(
y1
scale
voffset
viewport
[
3
]
)
;
y2
=
round
(
y2
scale
voffset
viewport
[
3
]
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
)
x1
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
componentStride
)
y1
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
)
x2
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
+
componentStride
)
y1
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
2
)
x1
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
2
+
componentStride
)
y2
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
3
)
x1
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
3
+
componentStride
)
y2
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
4
)
x2
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
4
+
componentStride
)
y1
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
5
)
x2
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
5
+
componentStride
)
y2
)
;
if
(
componentCount
>
2
)
{
for
(
var
i
=
0
;
i
<
6
;
i
+
+
)
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
i
+
componentStride
*
2
)
z
)
;
}
if
(
componentCount
>
3
)
{
for
(
var
i
=
0
;
i
<
6
;
i
+
+
)
glsVertexArrayTests
.
copyGLValueToArray
(
resultData
.
subarray
(
quadNdx
*
quadStride
+
stride
*
i
+
componentStride
*
3
)
w
)
;
}
}
break
;
}
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
RandomArrayGenerator
.
createQuads
-
Invalid
primitive
'
)
;
break
;
}
return
_data
;
}
;
glsVertexArrayTests
.
RandomArrayGenerator
.
generatePerQuad
=
function
(
seed
count
componentCount
stride
primitive
type
min
max
)
{
var
data
=
null
;
data
=
glsVertexArrayTests
.
RandomArrayGenerator
.
createPerQuads
(
seed
count
componentCount
stride
primitive
min
max
)
;
return
data
;
}
;
glsVertexArrayTests
.
RandomArrayGenerator
.
createPerQuads
=
function
(
seed
count
componentCount
stride
primitive
min
max
)
{
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
var
componentStride
=
min
.
m_value
.
byteLength
;
if
(
stride
=
=
0
)
stride
=
componentStride
*
componentCount
;
var
quadStride
=
0
;
switch
(
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
quadStride
=
stride
*
6
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
RandomArrayGenerator
.
createPerQuads
-
Invalid
primitive
'
)
;
break
;
}
var
data
=
new
ArrayBuffer
(
count
*
quadStride
)
;
for
(
var
quadNdx
=
0
;
quadNdx
<
count
;
quadNdx
+
+
)
{
for
(
var
componentNdx
=
0
;
componentNdx
<
componentCount
;
componentNdx
+
+
)
{
var
val
=
glsVertexArrayTests
.
GLValue
.
getRandom
(
rnd
min
max
)
;
var
data8
=
new
Uint8Array
(
data
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
data8
.
subarray
(
quadNdx
*
quadStride
+
stride
*
0
+
componentStride
*
componentNdx
)
val
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
data8
.
subarray
(
quadNdx
*
quadStride
+
stride
*
1
+
componentStride
*
componentNdx
)
val
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
data8
.
subarray
(
quadNdx
*
quadStride
+
stride
*
2
+
componentStride
*
componentNdx
)
val
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
data8
.
subarray
(
quadNdx
*
quadStride
+
stride
*
3
+
componentStride
*
componentNdx
)
val
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
data8
.
subarray
(
quadNdx
*
quadStride
+
stride
*
4
+
componentStride
*
componentNdx
)
val
)
;
glsVertexArrayTests
.
copyGLValueToArray
(
data8
.
subarray
(
quadNdx
*
quadStride
+
stride
*
5
+
componentStride
*
componentNdx
)
val
)
;
}
}
return
data
;
}
;
glsVertexArrayTests
.
VertexArrayTest
=
function
(
name
description
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
var
r
=
(
gl
.
getParameter
(
gl
.
RED_BITS
)
)
;
var
g
=
(
gl
.
getParameter
(
gl
.
GREEN_BITS
)
)
;
var
b
=
(
gl
.
getParameter
(
gl
.
BLUE_BITS
)
)
;
var
a
=
(
gl
.
getParameter
(
gl
.
ALPHA_BITS
)
)
;
this
.
m_pixelformat
=
new
tcuPixelFormat
.
PixelFormat
(
r
g
b
a
)
;
this
.
m_refBuffers
=
null
;
this
.
m_refContext
=
null
;
this
.
m_glesContext
=
null
;
this
.
m_glArrayPack
=
null
;
this
.
m_rrArrayPack
=
null
;
this
.
m_isOk
=
false
;
this
.
m_maxDiffRed
=
Math
.
ceil
(
256
.
0
*
(
2
.
0
/
(
1
<
<
this
.
m_pixelformat
.
redBits
)
)
)
;
this
.
m_maxDiffGreen
=
Math
.
ceil
(
256
.
0
*
(
2
.
0
/
(
1
<
<
this
.
m_pixelformat
.
greenBits
)
)
)
;
this
.
m_maxDiffBlue
=
Math
.
ceil
(
256
.
0
*
(
2
.
0
/
(
1
<
<
this
.
m_pixelformat
.
blueBits
)
)
)
;
}
;
glsVertexArrayTests
.
VertexArrayTest
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
glsVertexArrayTests
.
VertexArrayTest
.
prototype
.
constructor
=
glsVertexArrayTests
.
VertexArrayTest
;
glsVertexArrayTests
.
VertexArrayTest
.
prototype
.
init
=
function
(
)
{
var
renderTargetWidth
=
Math
.
min
(
512
canvas
.
width
)
;
var
renderTargetHeight
=
Math
.
min
(
512
canvas
.
height
)
;
var
limits
=
new
sglrReferenceContext
.
ReferenceContextLimits
(
gl
)
;
this
.
m_glesContext
=
new
sglrGLContext
.
GLContext
(
gl
)
;
this
.
m_refBuffers
=
new
sglrReferenceContext
.
ReferenceContextBuffers
(
this
.
m_pixelformat
0
0
renderTargetWidth
renderTargetHeight
)
;
this
.
m_refContext
=
new
sglrReferenceContext
.
ReferenceContext
(
limits
this
.
m_refBuffers
.
getColorbuffer
(
)
this
.
m_refBuffers
.
getDepthbuffer
(
)
this
.
m_refBuffers
.
getStencilbuffer
(
)
)
;
this
.
m_glArrayPack
=
new
glsVertexArrayTests
.
ContextArrayPack
(
this
.
m_glesContext
)
;
this
.
m_rrArrayPack
=
new
glsVertexArrayTests
.
ContextArrayPack
(
this
.
m_refContext
)
;
}
;
glsVertexArrayTests
.
VertexArrayTest
.
prototype
.
compare
=
function
(
)
{
var
ref
=
this
.
m_rrArrayPack
.
getSurface
(
)
;
var
screen
=
this
.
m_glArrayPack
.
getSurface
(
)
;
if
(
(
this
.
m_glesContext
.
getParameter
(
gl
.
SAMPLES
)
)
>
1
)
{
bufferedLogToConsole
(
'
Warning
:
Comparison
of
result
from
multisample
render
targets
are
not
as
strict
as
without
multisampling
.
Might
produce
false
positives
!
'
)
;
this
.
m_isOk
=
tcuImageCompare
.
fuzzyCompare
(
'
Compare
Results
'
'
Compare
Results
'
ref
.
getAccess
(
)
screen
.
getAccess
(
)
1
.
5
)
;
}
else
{
var
threshold
=
tcuRGBA
.
newRGBAComponents
(
this
.
m_maxDiffRed
this
.
m_maxDiffGreen
this
.
m_maxDiffBlue
255
)
;
var
error
=
new
tcuSurface
.
Surface
(
ref
.
getWidth
(
)
ref
.
getHeight
(
)
)
;
this
.
m_isOk
=
true
;
for
(
var
y
=
1
;
y
<
ref
.
getHeight
(
)
-
1
;
y
+
+
)
{
for
(
var
x
=
1
;
x
<
ref
.
getWidth
(
)
-
1
;
x
+
+
)
{
var
refPixel
=
tcuRGBA
.
newRGBAFromArray
(
ref
.
getPixel
(
x
y
)
)
;
var
screenPixel
=
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
y
)
)
;
var
isOkPixel
=
false
;
var
refThin
=
(
!
tcuRGBA
.
compareThreshold
(
refPixel
tcuRGBA
.
newRGBAFromArray
(
ref
.
getPixel
(
x
-
1
y
)
)
threshold
)
&
&
!
tcuRGBA
.
compareThreshold
(
refPixel
tcuRGBA
.
newRGBAFromArray
(
ref
.
getPixel
(
x
+
1
y
)
)
threshold
)
)
|
|
(
!
tcuRGBA
.
compareThreshold
(
refPixel
tcuRGBA
.
newRGBAFromArray
(
ref
.
getPixel
(
x
y
-
1
)
)
threshold
)
&
&
!
tcuRGBA
.
compareThreshold
(
refPixel
tcuRGBA
.
newRGBAFromArray
(
ref
.
getPixel
(
x
y
+
1
)
)
threshold
)
)
;
var
screenThin
=
(
!
tcuRGBA
.
compareThreshold
(
screenPixel
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
-
1
y
)
)
threshold
)
&
&
!
tcuRGBA
.
compareThreshold
(
screenPixel
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
+
1
y
)
)
threshold
)
)
|
|
(
!
tcuRGBA
.
compareThreshold
(
screenPixel
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
y
-
1
)
)
threshold
)
&
&
!
tcuRGBA
.
compareThreshold
(
screenPixel
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
y
+
1
)
)
threshold
)
)
;
if
(
refThin
&
&
screenThin
)
isOkPixel
=
true
;
else
{
for
(
var
dy
=
-
1
;
dy
<
2
&
&
!
isOkPixel
;
dy
+
+
)
{
for
(
var
dx
=
-
1
;
dx
<
2
&
&
!
isOkPixel
;
dx
+
+
)
{
var
screenCmpPixel
=
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
+
dx
y
+
dy
)
)
;
var
r
=
Math
.
abs
(
refPixel
.
getRed
(
)
-
screenCmpPixel
.
getRed
(
)
)
;
var
g
=
Math
.
abs
(
refPixel
.
getGreen
(
)
-
screenCmpPixel
.
getGreen
(
)
)
;
var
b
=
Math
.
abs
(
refPixel
.
getBlue
(
)
-
screenCmpPixel
.
getBlue
(
)
)
;
if
(
r
<
=
this
.
m_maxDiffRed
&
&
g
<
=
this
.
m_maxDiffGreen
&
&
b
<
=
this
.
m_maxDiffBlue
)
isOkPixel
=
true
;
var
refCmpPixel
=
tcuRGBA
.
newRGBAFromArray
(
ref
.
getPixel
(
x
+
dx
y
+
dy
)
)
;
r
=
Math
.
abs
(
refCmpPixel
.
getRed
(
)
-
screenPixel
.
getRed
(
)
)
;
g
=
Math
.
abs
(
refCmpPixel
.
getGreen
(
)
-
screenPixel
.
getGreen
(
)
)
;
b
=
Math
.
abs
(
refCmpPixel
.
getBlue
(
)
-
screenPixel
.
getBlue
(
)
)
;
if
(
r
<
=
this
.
m_maxDiffRed
&
&
g
<
=
this
.
m_maxDiffGreen
&
&
b
<
=
this
.
m_maxDiffBlue
)
isOkPixel
=
true
;
}
}
}
if
(
isOkPixel
)
error
.
setPixel
(
x
y
[
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
y
)
)
.
getRed
(
)
(
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
y
)
)
.
getGreen
(
)
+
255
)
/
2
tcuRGBA
.
newRGBAFromArray
(
screen
.
getPixel
(
x
y
)
)
.
getBlue
(
)
255
]
)
;
else
{
error
.
setPixel
(
x
y
[
255
0
0
255
]
)
;
this
.
m_isOk
=
false
;
}
}
}
if
(
!
this
.
m_isOk
)
{
debug
(
'
Image
comparison
failed
threshold
=
(
'
+
this
.
m_maxDiffRed
+
'
'
+
this
.
m_maxDiffGreen
+
'
'
+
this
.
m_maxDiffBlue
+
'
)
'
)
;
tcuImageCompare
.
displayImages
(
screen
.
getAccess
(
)
ref
.
getAccess
(
)
error
.
getAccess
(
)
)
;
}
else
{
tcuLogImage
.
logImage
(
'
Result
'
'
'
screen
.
getAccess
(
)
)
;
}
}
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
=
function
(
spec
name
desc
)
{
glsVertexArrayTests
.
VertexArrayTest
.
call
(
this
name
desc
)
;
this
.
m_spec
=
spec
;
this
.
m_iteration
=
0
;
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
prototype
=
Object
.
create
(
glsVertexArrayTests
.
VertexArrayTest
.
prototype
)
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
prototype
.
constructor
=
glsVertexArrayTests
.
MultiVertexArrayTest
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
Spec
=
function
(
)
{
this
.
primitive
;
this
.
drawCount
=
0
;
this
.
first
=
0
;
this
.
arrays
=
[
]
;
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
Spec
.
ArraySpec
=
function
(
inputType_
outputType_
storage_
usage_
componentCount_
offset_
stride_
normalize_
min_
max_
)
{
this
.
inputType
=
inputType_
;
this
.
outputType
=
outputType_
;
this
.
storage
=
storage_
;
this
.
usage
=
usage_
;
this
.
componentCount
=
componentCount_
;
this
.
offset
=
offset_
;
this
.
stride
=
stride_
;
this
.
normalize
=
normalize_
;
this
.
min
=
min_
;
this
.
max
=
max_
;
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
Spec
.
prototype
.
getName
=
function
(
)
{
var
name
=
'
'
;
for
(
var
ndx
=
0
;
ndx
<
this
.
arrays
.
length
;
+
+
ndx
)
{
var
array
=
this
.
arrays
[
ndx
]
;
if
(
this
.
arrays
.
length
>
1
)
name
+
=
'
array
'
+
ndx
+
'
_
'
;
name
+
=
glsVertexArrayTests
.
deArray
.
storageToString
(
array
.
storage
)
+
'
_
'
+
array
.
offset
+
'
_
'
+
array
.
stride
+
'
_
'
+
glsVertexArrayTests
.
deArray
.
inputTypeToString
(
array
.
inputType
)
;
if
(
array
.
inputType
!
=
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT_2_10_10_10
&
&
array
.
inputType
!
=
glsVertexArrayTests
.
deArray
.
InputType
.
INT_2_10_10_10
)
name
+
=
array
.
componentCount
;
name
+
=
'
_
'
+
(
array
.
normalize
?
'
normalized_
'
:
'
'
)
+
glsVertexArrayTests
.
deArray
.
outputTypeToString
(
array
.
outputType
)
+
'
_
'
+
glsVertexArrayTests
.
deArray
.
usageTypeToString
(
array
.
usage
)
+
'
_
'
;
}
if
(
this
.
first
)
name
+
=
'
first
'
+
this
.
first
+
'
_
'
;
switch
(
this
.
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
name
+
=
'
quads_
'
;
break
;
case
glsVertexArrayTests
.
deArray
.
Primitive
.
POINTS
:
name
+
=
'
points_
'
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
MultiVertexArrayTest
.
Spec
.
getName
-
Invalid
primitive
type
'
)
;
break
;
}
name
+
=
this
.
drawCount
;
return
name
;
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
Spec
.
prototype
.
getDesc
=
function
(
)
{
var
desc
=
'
'
;
for
(
var
ndx
=
0
;
ndx
<
this
.
arrays
.
length
;
+
+
ndx
)
{
var
array
=
this
.
arrays
[
ndx
]
;
desc
+
=
'
Array
'
+
ndx
+
'
:
'
+
'
Storage
in
'
+
glsVertexArrayTests
.
deArray
.
storageToString
(
array
.
storage
)
+
'
'
+
'
stride
'
+
array
.
stride
+
'
'
+
'
input
datatype
'
+
glsVertexArrayTests
.
deArray
.
inputTypeToString
(
array
.
inputType
)
+
'
'
+
'
input
component
count
'
+
array
.
componentCount
+
'
'
+
(
array
.
normalize
?
'
normalized
'
:
'
'
)
+
'
used
as
'
+
glsVertexArrayTests
.
deArray
.
outputTypeToString
(
array
.
outputType
)
+
'
'
;
}
desc
+
=
'
drawArrays
(
)
'
+
'
first
'
+
this
.
first
+
'
'
+
this
.
drawCount
;
switch
(
this
.
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
desc
+
=
'
quads
'
;
break
;
case
glsVertexArrayTests
.
deArray
.
Primitive
.
POINTS
:
desc
+
=
'
points
'
;
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
MultiVertexArrayTest
.
Spec
.
getDesc
-
Invalid
primitive
type
'
)
;
break
;
}
return
desc
;
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
prototype
.
iterate
=
function
(
)
{
if
(
this
.
m_iteration
=
=
0
)
{
var
primitiveSize
=
(
this
.
m_spec
.
primitive
=
=
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
)
?
(
6
)
:
(
1
)
;
var
coordScale
=
1
.
0
;
var
colorScale
=
1
.
0
;
var
useVao
=
true
;
bufferedLogToConsole
(
this
.
m_spec
.
getDesc
(
)
)
;
var
arraySpec
=
this
.
m_spec
.
arrays
[
0
]
;
if
(
arraySpec
.
inputType
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT_2_10_10_10
)
{
if
(
arraySpec
.
normalize
)
coordScale
=
1
;
else
coordScale
=
1
/
1024
;
}
else
if
(
arraySpec
.
inputType
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
INT_2_10_10_10
)
{
if
(
arraySpec
.
normalize
)
coordScale
=
1
.
0
;
else
coordScale
=
1
.
0
/
512
.
0
;
}
else
coordScale
=
arraySpec
.
normalize
&
&
!
glsVertexArrayTests
.
inputTypeIsFloatType
(
arraySpec
.
inputType
)
?
1
.
0
:
0
.
9
/
arraySpec
.
max
.
toFloat
(
)
;
if
(
arraySpec
.
outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC3
|
|
arraySpec
.
outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
|
|
arraySpec
.
outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC3
|
|
arraySpec
.
outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
IVEC4
|
|
arraySpec
.
outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC3
|
|
arraySpec
.
outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
UVEC4
)
coordScale
=
coordScale
*
0
.
5
;
for
(
var
arrayNdx
=
1
;
arrayNdx
<
this
.
m_spec
.
arrays
.
length
;
arrayNdx
+
+
)
{
arraySpec
=
this
.
m_spec
.
arrays
[
arrayNdx
]
;
colorScale
*
=
(
arraySpec
.
normalize
&
&
!
glsVertexArrayTests
.
inputTypeIsFloatType
(
arraySpec
.
inputType
)
?
1
.
0
:
1
.
0
/
arraySpec
.
max
.
toFloat
(
)
)
;
if
(
arraySpec
.
outputType
=
=
glsVertexArrayTests
.
deArray
.
OutputType
.
VEC4
)
colorScale
*
=
(
arraySpec
.
normalize
&
&
!
glsVertexArrayTests
.
inputTypeIsFloatType
(
arraySpec
.
inputType
)
?
1
.
0
:
1
.
0
/
arraySpec
.
max
.
toFloat
(
)
)
;
}
for
(
var
arrayNdx
=
0
;
arrayNdx
<
this
.
m_spec
.
arrays
.
length
;
arrayNdx
+
+
)
{
arraySpec
=
this
.
m_spec
.
arrays
[
arrayNdx
]
;
var
seed
=
arraySpec
.
inputType
+
10
*
arraySpec
.
outputType
+
100
*
arraySpec
.
storage
+
1000
*
this
.
m_spec
.
primitive
+
10000
*
arraySpec
.
usage
+
this
.
m_spec
.
drawCount
+
12
*
arraySpec
.
componentCount
+
arraySpec
.
stride
+
arraySpec
.
normalize
;
var
data
=
null
;
var
stride
=
arraySpec
.
stride
=
=
0
?
arraySpec
.
componentCount
*
glsVertexArrayTests
.
deArray
.
inputTypeSize
(
arraySpec
.
inputType
)
:
arraySpec
.
stride
;
var
bufferSize
=
arraySpec
.
offset
+
stride
*
(
this
.
m_spec
.
drawCount
*
primitiveSize
-
1
)
+
arraySpec
.
componentCount
*
glsVertexArrayTests
.
deArray
.
inputTypeSize
(
arraySpec
.
inputType
)
;
switch
(
this
.
m_spec
.
primitive
)
{
case
glsVertexArrayTests
.
deArray
.
Primitive
.
TRIANGLES
:
if
(
arrayNdx
=
=
0
)
{
data
=
glsVertexArrayTests
.
RandomArrayGenerator
.
generateQuads
(
seed
this
.
m_spec
.
drawCount
arraySpec
.
componentCount
arraySpec
.
offset
arraySpec
.
stride
this
.
m_spec
.
primitive
arraySpec
.
inputType
arraySpec
.
min
arraySpec
.
max
coordScale
)
;
}
else
{
DE_ASSERT
(
arraySpec
.
offset
=
=
0
)
;
data
=
glsVertexArrayTests
.
RandomArrayGenerator
.
generatePerQuad
(
seed
this
.
m_spec
.
drawCount
arraySpec
.
componentCount
arraySpec
.
stride
this
.
m_spec
.
primitive
arraySpec
.
inputType
arraySpec
.
min
arraySpec
.
max
)
;
}
break
;
default
:
throw
new
Error
(
'
glsVertexArrayTests
.
MultiVertexArrayTest
.
prototype
.
iterate
-
Invalid
primitive
type
'
)
;
break
;
}
this
.
m_glArrayPack
.
newArray
(
arraySpec
.
storage
)
;
this
.
m_rrArrayPack
.
newArray
(
arraySpec
.
storage
)
;
this
.
m_glArrayPack
.
getArray
(
arrayNdx
)
.
data
(
glsVertexArrayTests
.
deArray
.
Target
.
ARRAY
bufferSize
new
Uint8Array
(
data
)
arraySpec
.
usage
)
;
this
.
m_rrArrayPack
.
getArray
(
arrayNdx
)
.
data
(
glsVertexArrayTests
.
deArray
.
Target
.
ARRAY
bufferSize
new
Uint8Array
(
data
)
arraySpec
.
usage
)
;
this
.
m_glArrayPack
.
getArray
(
arrayNdx
)
.
bind
(
arrayNdx
arraySpec
.
offset
arraySpec
.
componentCount
arraySpec
.
inputType
arraySpec
.
outputType
arraySpec
.
normalize
arraySpec
.
stride
)
;
this
.
m_rrArrayPack
.
getArray
(
arrayNdx
)
.
bind
(
arrayNdx
arraySpec
.
offset
arraySpec
.
componentCount
arraySpec
.
inputType
arraySpec
.
outputType
arraySpec
.
normalize
arraySpec
.
stride
)
;
}
try
{
this
.
m_glArrayPack
.
render
(
this
.
m_spec
.
primitive
this
.
m_spec
.
first
this
.
m_spec
.
drawCount
*
primitiveSize
useVao
coordScale
colorScale
)
;
this
.
m_rrArrayPack
.
render
(
this
.
m_spec
.
primitive
this
.
m_spec
.
first
this
.
m_spec
.
drawCount
*
primitiveSize
useVao
coordScale
colorScale
)
;
}
catch
(
err
)
{
bufferedLogToConsole
(
'
Got
error
:
'
+
err
.
message
)
;
if
(
this
.
isUnalignedBufferOffsetTest
(
)
)
testFailedOptions
(
'
Failed
to
draw
with
unaligned
buffers
'
false
)
;
else
if
(
this
.
isUnalignedBufferStrideTest
(
)
)
testFailedOptions
(
'
Failed
to
draw
with
unaligned
stride
'
false
)
;
else
throw
new
Error
(
err
.
message
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
this
.
m_iteration
+
+
;
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
}
else
if
(
this
.
m_iteration
=
=
1
)
{
this
.
compare
(
)
;
if
(
this
.
m_isOk
)
{
testPassedOptions
(
'
'
true
)
;
}
else
{
if
(
this
.
isUnalignedBufferOffsetTest
(
)
)
testFailedOptions
(
'
Failed
to
draw
with
unaligned
buffers
'
false
)
;
else
if
(
this
.
isUnalignedBufferStrideTest
(
)
)
testFailedOptions
(
'
Failed
to
draw
with
unaligned
stride
'
false
)
;
else
testFailedOptions
(
'
Image
comparison
failed
'
false
)
;
}
this
.
m_iteration
+
+
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
else
{
testFailedOptions
(
'
glsVertexArrayTests
.
MultiVertexArrayTest
.
iterate
-
Invalid
iteration
stage
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
prototype
.
isUnalignedBufferOffsetTest
=
function
(
)
{
for
(
var
i
=
0
;
i
<
this
.
m_spec
.
arrays
.
length
;
+
+
i
)
{
if
(
this
.
m_spec
.
arrays
[
i
]
.
storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
BUFFER
)
{
var
inputTypePacked
=
this
.
m_spec
.
arrays
[
i
]
.
inputType
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT_2_10_10_10
|
|
this
.
m_spec
.
arrays
[
i
]
.
inputType
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
INT_2_10_10_10
;
var
dataTypeSize
=
glsVertexArrayTests
.
deArray
.
inputTypeSize
(
this
.
m_spec
.
arrays
[
i
]
.
inputType
)
;
if
(
inputTypePacked
)
dataTypeSize
=
4
;
if
(
this
.
m_spec
.
arrays
[
i
]
.
offset
%
dataTypeSize
!
=
0
)
return
true
;
}
}
return
false
;
}
;
glsVertexArrayTests
.
MultiVertexArrayTest
.
prototype
.
isUnalignedBufferStrideTest
=
function
(
)
{
for
(
var
i
=
0
;
i
<
this
.
m_spec
.
arrays
.
length
;
+
+
i
)
{
if
(
this
.
m_spec
.
arrays
[
i
]
.
storage
=
=
glsVertexArrayTests
.
deArray
.
Storage
.
BUFFER
)
{
var
inputTypePacked
=
this
.
m_spec
.
arrays
[
i
]
.
inputType
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
UNSIGNED_INT_2_10_10_10
|
|
this
.
m_spec
.
arrays
[
i
]
.
inputType
=
=
glsVertexArrayTests
.
deArray
.
InputType
.
INT_2_10_10_10
;
var
dataTypeSize
=
glsVertexArrayTests
.
deArray
.
inputTypeSize
(
this
.
m_spec
.
arrays
[
i
]
.
inputType
)
;
if
(
inputTypePacked
)
dataTypeSize
=
4
;
if
(
this
.
m_spec
.
arrays
[
i
]
.
stride
%
dataTypeSize
!
=
0
)
return
true
;
}
}
return
false
;
}
;
}
)
;
