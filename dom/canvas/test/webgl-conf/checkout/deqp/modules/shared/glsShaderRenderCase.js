'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsShaderRenderCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuMatrix
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluDrawUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTexture
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
scope
(
function
(
)
{
var
glsShaderRenderCase
=
modules
.
shared
.
glsShaderRenderCase
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gluTexture
=
framework
.
opengl
.
gluTexture
;
var
gluDrawUtil
=
framework
.
opengl
.
gluDrawUtil
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuMatrix
=
framework
.
common
.
tcuMatrix
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
glsShaderRenderCase
.
ShaderEvalFunc
;
glsShaderRenderCase
.
GRID_SIZE
=
64
;
glsShaderRenderCase
.
MAX_RENDER_WIDTH
=
128
;
glsShaderRenderCase
.
MAX_RENDER_HEIGHT
=
112
;
glsShaderRenderCase
.
DEFAULT_CLEAR_COLOR
=
[
0
.
125
0
.
25
0
.
5
1
.
0
]
;
glsShaderRenderCase
.
MAX_USER_ATTRIBS
=
4
;
glsShaderRenderCase
.
MAX_TEXTURES
=
4
;
glsShaderRenderCase
.
toRGBA
=
function
(
a
)
{
return
tcuRGBA
.
newRGBAComponents
(
deMath
.
clamp
(
Math
.
round
(
a
[
0
]
*
255
.
0
)
0
255
)
deMath
.
clamp
(
Math
.
round
(
a
[
1
]
*
255
.
0
)
0
255
)
deMath
.
clamp
(
Math
.
round
(
a
[
2
]
*
255
.
0
)
0
255
)
deMath
.
clamp
(
Math
.
round
(
a
[
3
]
*
255
.
0
)
0
255
)
)
;
}
;
glsShaderRenderCase
.
getTextureType
=
function
(
tex
)
{
if
(
tex
=
=
=
null
|
|
tex
.
getType
(
)
<
=
0
)
return
gluTexture
.
Type
.
TYPE_NONE
;
else
return
tex
.
getType
(
)
;
}
;
glsShaderRenderCase
.
LineStream
=
function
(
indent
)
{
indent
=
indent
=
=
=
undefined
?
0
:
indent
;
this
.
m_indent
=
indent
;
this
.
m_stream
;
this
.
m_string
;
}
;
glsShaderRenderCase
.
LineStream
.
prototype
.
str
=
function
(
)
{
this
.
m_string
=
this
.
m_stream
;
return
this
.
m_string
;
}
;
glsShaderRenderCase
.
TextureBinding
=
function
(
tex
sampler
)
{
tex
=
tex
=
=
=
undefined
?
null
:
tex
;
sampler
=
sampler
=
=
=
undefined
?
null
:
sampler
;
this
.
m_type
=
glsShaderRenderCase
.
getTextureType
(
tex
)
;
this
.
m_sampler
=
sampler
;
this
.
m_binding
=
tex
;
}
;
glsShaderRenderCase
.
TextureBinding
.
prototype
.
setSampler
=
function
(
sampler
)
{
this
.
m_sampler
=
sampler
;
}
;
glsShaderRenderCase
.
TextureBinding
.
prototype
.
setTexture
=
function
(
tex
)
{
this
.
m_type
=
glsShaderRenderCase
.
getTextureType
(
tex
)
;
this
.
m_binding
=
tex
;
}
;
glsShaderRenderCase
.
TextureBinding
.
prototype
.
getType
=
function
(
)
{
return
this
.
m_type
;
}
;
glsShaderRenderCase
.
TextureBinding
.
prototype
.
getSampler
=
function
(
)
{
return
this
.
m_sampler
;
}
;
glsShaderRenderCase
.
TextureBinding
.
prototype
.
getBinding
=
function
(
)
{
return
this
.
m_binding
;
}
;
glsShaderRenderCase
.
QuadGrid
=
function
(
gridSize
width
height
constCoords
userAttribTransforms
textures
)
{
this
.
m_gridSize
=
gridSize
;
this
.
m_numVertices
=
(
gridSize
+
1
)
*
(
gridSize
+
1
)
;
this
.
m_numTriangles
=
(
gridSize
*
gridSize
*
2
)
;
this
.
m_constCoords
=
constCoords
;
this
.
m_userAttribTransforms
=
userAttribTransforms
;
this
.
m_textures
=
textures
;
this
.
m_screenPos
=
[
]
;
this
.
m_positions
=
[
]
;
this
.
m_coords
=
[
]
;
this
.
m_unitCoords
=
[
]
;
this
.
m_attribOne
=
[
]
;
this
.
m_userAttribs
=
[
]
;
for
(
var
attribNdx
=
0
;
attribNdx
<
this
.
getNumUserAttribs
(
)
;
attribNdx
+
+
)
this
.
m_userAttribs
[
attribNdx
]
=
[
]
;
this
.
m_indices
=
[
]
;
var
viewportScale
=
[
width
height
0
0
]
;
for
(
var
y
=
0
;
y
<
gridSize
+
1
;
y
+
+
)
for
(
var
x
=
0
;
x
<
gridSize
+
1
;
x
+
+
)
{
var
sx
=
x
/
gridSize
;
var
sy
=
y
/
gridSize
;
var
fx
=
2
.
0
*
sx
-
1
.
0
;
var
fy
=
2
.
0
*
sy
-
1
.
0
;
var
vtxNdx
=
(
(
y
*
(
gridSize
+
1
)
)
+
x
)
;
this
.
m_positions
[
vtxNdx
]
=
[
fx
fy
0
.
0
1
.
0
]
;
this
.
m_attribOne
[
vtxNdx
]
=
1
.
0
;
this
.
m_screenPos
[
vtxNdx
]
=
deMath
.
multiply
(
[
sx
sy
0
.
0
1
.
0
]
viewportScale
)
;
this
.
m_coords
[
vtxNdx
]
=
this
.
getCoords
(
sx
sy
)
;
this
.
m_unitCoords
[
vtxNdx
]
=
this
.
getUnitCoords
(
sx
sy
)
;
for
(
var
attribNdx
=
0
;
attribNdx
<
this
.
getNumUserAttribs
(
)
;
attribNdx
+
+
)
this
.
m_userAttribs
[
attribNdx
]
[
vtxNdx
]
=
this
.
getUserAttrib
(
attribNdx
sx
sy
)
;
}
for
(
var
y
=
0
;
y
<
gridSize
;
y
+
+
)
for
(
var
x
=
0
;
x
<
gridSize
;
x
+
+
)
{
var
stride
=
gridSize
+
1
;
var
v00
=
(
y
*
stride
)
+
x
;
var
v01
=
(
y
*
stride
)
+
x
+
1
;
var
v10
=
(
(
y
+
1
)
*
stride
)
+
x
;
var
v11
=
(
(
y
+
1
)
*
stride
)
+
x
+
1
;
var
baseNdx
=
(
(
y
*
gridSize
)
+
x
)
*
6
;
this
.
m_indices
[
baseNdx
+
0
]
=
v10
;
this
.
m_indices
[
baseNdx
+
1
]
=
v00
;
this
.
m_indices
[
baseNdx
+
2
]
=
v01
;
this
.
m_indices
[
baseNdx
+
3
]
=
v10
;
this
.
m_indices
[
baseNdx
+
4
]
=
v01
;
this
.
m_indices
[
baseNdx
+
5
]
=
v11
;
}
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getGridSize
=
function
(
)
{
return
this
.
m_gridSize
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getNumVertices
=
function
(
)
{
return
this
.
m_numVertices
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getNumTriangles
=
function
(
)
{
return
this
.
m_numTriangles
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getConstCoords
=
function
(
)
{
return
this
.
m_constCoords
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getUserAttribTransforms
=
function
(
)
{
return
this
.
m_userAttribTransforms
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getTextures
=
function
(
)
{
return
this
.
m_textures
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getPositions
=
function
(
)
{
return
this
.
m_positions
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getAttribOne
=
function
(
)
{
return
this
.
m_attribOne
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getCoordsArray
=
function
(
)
{
return
this
.
m_coords
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getUnitCoordsArray
=
function
(
)
{
return
this
.
m_unitCoords
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getUserAttribByIndex
=
function
(
attribNdx
)
{
return
this
.
m_userAttribs
[
attribNdx
]
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getIndices
=
function
(
)
{
return
this
.
m_indices
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getCoords
=
function
(
sx
sy
)
{
var
fx
=
2
.
0
*
sx
-
1
.
0
;
var
fy
=
2
.
0
*
sy
-
1
.
0
;
return
[
fx
fy
-
fx
+
0
.
33
*
fy
-
0
.
275
*
fx
-
fy
]
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getUnitCoords
=
function
(
sx
sy
)
{
return
[
sx
sy
0
.
33
*
sx
+
0
.
5
*
sy
0
.
5
*
sx
+
0
.
25
*
sy
]
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getNumUserAttribs
=
function
(
)
{
return
this
.
m_userAttribTransforms
.
length
;
}
;
glsShaderRenderCase
.
QuadGrid
.
prototype
.
getUserAttrib
=
function
(
attribNdx
sx
sy
)
{
return
tcuMatrix
.
multiplyMatVec
(
this
.
m_userAttribTransforms
[
attribNdx
]
[
sx
sy
0
.
0
1
.
0
]
)
;
}
;
glsShaderRenderCase
.
ShaderSampler
=
function
(
)
{
this
.
sampler
;
this
.
tex2D
=
null
;
this
.
texCube
=
null
;
this
.
tex2DArray
=
null
;
this
.
tex3D
=
null
;
}
;
glsShaderRenderCase
.
ShaderEvalContext
=
function
(
quadGrid_
)
{
this
.
coords
=
[
0
0
0
0
]
this
.
unitCoords
=
[
0
0
0
0
]
this
.
constCoords
=
quadGrid_
.
getConstCoords
(
)
;
this
.
in_
=
[
]
;
this
.
textures
=
[
]
;
this
.
color
=
[
0
0
0
0
.
0
]
;
this
.
isDiscarded
=
false
;
this
.
quadGrid
=
quadGrid_
;
var
bindings
=
this
.
quadGrid
.
getTextures
(
)
;
assertMsgOptions
(
bindings
.
length
<
=
glsShaderRenderCase
.
MAX_TEXTURES
'
Too
many
bindings
.
'
false
true
)
;
for
(
var
ndx
=
0
;
ndx
<
bindings
.
length
;
ndx
+
+
)
{
var
binding
=
bindings
[
ndx
]
;
this
.
textures
[
ndx
]
=
new
glsShaderRenderCase
.
ShaderSampler
(
)
;
if
(
binding
.
getType
(
)
=
=
gluTexture
.
Type
.
TYPE_NONE
)
continue
;
this
.
textures
[
ndx
]
.
sampler
=
binding
.
getSampler
(
)
;
switch
(
binding
.
getType
(
)
)
{
case
gluTexture
.
Type
.
TYPE_2D
:
this
.
textures
[
ndx
]
.
tex2D
=
binding
.
getBinding
(
)
.
getRefTexture
(
)
;
break
;
case
gluTexture
.
Type
.
TYPE_CUBE_MAP
:
this
.
textures
[
ndx
]
.
texCube
=
binding
.
getBinding
(
)
.
getRefTexture
(
)
;
break
;
case
gluTexture
.
Type
.
TYPE_2D_ARRAY
:
this
.
textures
[
ndx
]
.
tex2DArray
=
binding
.
getBinding
(
)
.
getRefTexture
(
)
;
break
;
case
gluTexture
.
Type
.
TYPE_3D
:
this
.
textures
[
ndx
]
.
tex3D
=
binding
.
getBinding
(
)
.
getRefTexture
(
)
;
break
;
default
:
throw
new
Error
(
"
Binding
type
not
supported
"
)
;
}
}
}
;
glsShaderRenderCase
.
ShaderEvalContext
.
prototype
.
reset
=
function
(
sx
sy
)
{
this
.
color
=
[
0
.
0
0
.
0
0
.
0
1
.
0
]
;
this
.
isDiscarded
=
false
;
this
.
coords
=
this
.
quadGrid
.
getCoords
(
sx
sy
)
;
this
.
unitCoords
=
this
.
quadGrid
.
getUnitCoords
(
sx
sy
)
;
var
numAttribs
=
this
.
quadGrid
.
getNumUserAttribs
(
)
;
assertMsgOptions
(
numAttribs
<
=
glsShaderRenderCase
.
MAX_USER_ATTRIBS
'
numAttribs
out
of
range
'
false
true
)
;
for
(
var
attribNdx
=
0
;
attribNdx
<
numAttribs
;
attribNdx
+
+
)
this
.
in_
[
attribNdx
]
=
this
.
quadGrid
.
getUserAttrib
(
attribNdx
sx
sy
)
;
}
;
glsShaderRenderCase
.
ShaderEvalContext
.
prototype
.
discard
=
function
(
)
{
this
.
isDiscarded
=
true
;
}
;
glsShaderRenderCase
.
ShaderEvalContext
.
prototype
.
texture2D
=
function
(
unitNdx
coords
)
{
if
(
this
.
textures
.
length
>
0
&
&
this
.
textures
[
unitNdx
]
.
tex2D
)
return
this
.
textures
[
unitNdx
]
.
tex2D
.
getView
(
)
.
sample
(
this
.
textures
[
unitNdx
]
.
sampler
coords
0
.
0
)
;
else
return
[
0
.
0
0
.
0
0
.
0
1
.
0
]
;
}
;
glsShaderRenderCase
.
evalCoordsPassthroughX
=
function
(
c
)
{
c
.
color
[
0
]
=
c
.
coords
[
0
]
;
}
;
glsShaderRenderCase
.
evalCoordsPassthroughXY
=
function
(
c
)
{
var
swizzle01
=
deMath
.
swizzle
(
c
.
coords
[
0
1
]
)
;
c
.
color
[
0
]
=
swizzle01
[
0
]
;
c
.
color
[
1
]
=
swizzle01
[
1
]
;
}
;
glsShaderRenderCase
.
evalCoordsPassthroughXYZ
=
function
(
c
)
{
var
swizzle012
=
deMath
.
swizzle
(
c
.
coords
[
0
1
2
]
)
;
c
.
color
[
0
]
=
swizzle012
[
0
]
;
c
.
color
[
1
]
=
swizzle012
[
1
]
;
c
.
color
[
2
]
=
swizzle012
[
2
]
;
}
;
glsShaderRenderCase
.
evalCoordsPassthrough
=
function
(
c
)
{
c
.
color
=
c
.
coords
;
}
;
glsShaderRenderCase
.
evalCoordsSwizzleWZYX
=
function
(
c
)
{
c
.
color
=
deMath
.
swizzle
(
c
.
coords
[
3
2
1
0
]
)
;
}
;
glsShaderRenderCase
.
ShaderEvaluator
=
function
(
evalFunc
)
{
this
.
m_evalFunc
=
evalFunc
|
|
null
;
}
;
glsShaderRenderCase
.
ShaderEvaluator
.
prototype
.
evaluate
=
function
(
ctx
)
{
assertMsgOptions
(
this
.
m_evalFunc
!
=
=
null
'
No
evaluation
function
specified
.
'
false
true
)
;
this
.
m_evalFunc
(
ctx
)
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
=
function
(
name
description
isVertexCase
evalFunc
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_isVertexCase
=
isVertexCase
;
this
.
m_defaultEvaluator
=
evalFunc
|
|
null
;
this
.
m_evaluator
=
new
glsShaderRenderCase
.
ShaderEvaluator
(
this
.
m_defaultEvaluator
)
;
this
.
m_vertShaderSource
=
'
'
;
this
.
m_fragShaderSource
=
'
'
;
this
.
m_clearColor
=
glsShaderRenderCase
.
DEFAULT_CLEAR_COLOR
;
this
.
m_userAttribTransforms
=
[
]
;
this
.
m_textures
=
[
]
;
this
.
m_program
=
null
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
newWithEvaluator
=
function
(
name
description
isVertexCase
evaluator
)
{
var
renderCase
=
new
glsShaderRenderCase
.
ShaderRenderCase
(
name
description
isVertexCase
)
;
renderCase
.
m_evaluator
=
evaluator
;
return
renderCase
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
constructor
=
glsShaderRenderCase
.
ShaderRenderCase
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
deinit
=
function
(
)
{
this
.
m_program
=
null
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
init
=
function
(
)
{
this
.
postinit
(
)
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
postinit
=
function
(
)
{
if
(
this
.
m_vertShaderSource
.
length
=
=
=
0
|
|
this
.
m_fragShaderSource
.
length
=
=
=
0
)
{
assertMsgOptions
(
this
.
m_vertShaderSource
.
length
=
=
=
0
&
&
this
.
m_fragShaderSource
.
length
=
=
=
0
'
No
shader
source
.
'
false
true
)
;
this
.
setupShaderData
(
)
;
}
assertMsgOptions
(
!
this
.
m_program
'
Program
defined
.
'
false
true
)
;
this
.
m_program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
this
.
m_vertShaderSource
this
.
m_fragShaderSource
)
)
;
try
{
bufferedLogToConsole
(
this
.
m_program
.
program
.
info
.
infoLog
)
;
if
(
!
this
.
m_program
.
isOk
(
)
)
throw
new
Error
(
"
Shader
compile
error
.
"
)
;
}
catch
(
exception
)
{
this
.
deinit
(
)
;
throw
exception
;
}
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
postiterate
=
function
(
)
{
assertMsgOptions
(
this
.
m_program
!
=
=
null
'
Program
not
specified
.
'
false
true
)
;
var
programID
=
this
.
m_program
.
getProgram
(
)
;
gl
.
useProgram
(
programID
)
;
var
viewportSize
=
this
.
getViewportSize
(
)
;
var
width
=
viewportSize
[
0
]
;
var
height
=
viewportSize
[
1
]
;
var
quadGrid
=
new
glsShaderRenderCase
.
QuadGrid
(
this
.
m_isVertexCase
?
glsShaderRenderCase
.
GRID_SIZE
:
4
width
height
[
0
.
125
0
.
25
0
.
5
1
.
0
]
this
.
m_userAttribTransforms
this
.
m_textures
)
;
var
resImage
=
new
tcuSurface
.
Surface
(
width
height
)
;
this
.
render
(
resImage
programID
quadGrid
)
;
var
refImage
=
new
tcuSurface
.
Surface
(
width
height
)
;
if
(
this
.
m_isVertexCase
)
this
.
computeVertexReference
(
refImage
quadGrid
)
;
else
this
.
computeFragmentReference
(
refImage
quadGrid
)
;
var
testOk
=
this
.
compareImages
(
resImage
refImage
0
.
05
)
;
gl
.
useProgram
(
null
)
;
if
(
!
testOk
)
testFailedOptions
(
"
Fail
"
false
)
;
else
testPassedOptions
(
"
Pass
"
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
iterate
=
function
(
)
{
return
this
.
postiterate
(
)
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
setupShaderData
=
function
(
)
{
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
setup
=
function
(
programId
)
{
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
setupUniforms
=
function
(
programId
constCoords
)
{
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
getViewportSize
=
function
(
)
{
return
[
Math
.
min
(
gl
.
canvas
.
width
glsShaderRenderCase
.
MAX_RENDER_WIDTH
)
Math
.
min
(
gl
.
canvas
.
height
glsShaderRenderCase
.
MAX_RENDER_HEIGHT
)
]
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
setupDefaultInputs
=
function
(
programId
)
{
glsShaderRenderCase
.
setupDefaultUniforms
(
programId
)
;
for
(
var
ndx
=
0
;
ndx
<
this
.
m_textures
.
length
;
ndx
+
+
)
{
var
tex
=
this
.
m_textures
[
ndx
]
;
var
sampler
=
tex
.
getSampler
(
)
;
var
texTarget
=
gl
.
NONE
;
var
texObj
=
0
;
if
(
tex
.
getType
(
)
=
=
=
gluTexture
.
Type
.
TYPE_NONE
)
continue
;
switch
(
tex
.
getType
(
)
)
{
case
gluTexture
.
Type
.
TYPE_2D
:
texTarget
=
gl
.
TEXTURE_2D
;
texObj
=
tex
.
getBinding
(
)
.
getGLTexture
(
)
;
break
;
case
gluTexture
.
Type
.
TYPE_CUBE_MAP
:
texTarget
=
gl
.
TEXTURE_CUBE_MAP
;
texObj
=
tex
.
getBinding
(
)
.
getGLTexture
(
)
;
break
;
case
gluTexture
.
Type
.
TYPE_2D_ARRAY
:
texTarget
=
gl
.
TEXTURE_2D_ARRAY
;
texObj
=
tex
.
getBinding
(
)
.
getGLTexture
(
)
;
break
;
case
gluTexture
.
Type
.
TYPE_3D
:
texTarget
=
gl
.
TEXTURE_3D
;
texObj
=
tex
.
getBinding
(
)
.
getGLTexture
(
)
;
break
;
default
:
throw
new
Error
(
"
Type
not
supported
"
)
;
}
gl
.
activeTexture
(
gl
.
TEXTURE0
+
ndx
)
;
gl
.
bindTexture
(
texTarget
texObj
)
;
gl
.
texParameteri
(
texTarget
gl
.
TEXTURE_WRAP_S
gluTextureUtil
.
getGLWrapMode
(
sampler
.
wrapS
)
)
;
gl
.
texParameteri
(
texTarget
gl
.
TEXTURE_WRAP_T
gluTextureUtil
.
getGLWrapMode
(
sampler
.
wrapT
)
)
;
gl
.
texParameteri
(
texTarget
gl
.
TEXTURE_MIN_FILTER
gluTextureUtil
.
getGLFilterMode
(
sampler
.
minFilter
)
)
;
gl
.
texParameteri
(
texTarget
gl
.
TEXTURE_MAG_FILTER
gluTextureUtil
.
getGLFilterMode
(
sampler
.
magFilter
)
)
;
if
(
texTarget
=
=
=
gl
.
TEXTURE_3D
)
gl
.
texParameteri
(
texTarget
gl
.
TEXTURE_WRAP_R
gluTextureUtil
.
getGLWrapMode
(
sampler
.
wrapR
)
)
;
if
(
sampler
.
compare
!
=
tcuTexture
.
CompareMode
.
COMPAREMODE_NONE
)
{
gl
.
texParameteri
(
texTarget
gl
.
TEXTURE_COMPARE_MODE
gl
.
COMPARE_REF_TO_TEXTURE
)
;
gl
.
texParameteri
(
texTarget
gl
.
TEXTURE_COMPARE_FUNC
gluTextureUtil
.
getGLCompareFunc
(
sampler
.
compare
)
)
;
}
}
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
render
=
function
(
result
programId
quadGrid
)
{
var
width
=
result
.
getWidth
(
)
;
var
height
=
result
.
getHeight
(
)
;
var
xOffsetMax
=
gl
.
drawingBufferWidth
-
width
;
var
yOffsetMax
=
gl
.
drawingBufferHeight
-
height
;
var
hash
=
deString
.
deStringHash
(
this
.
m_vertShaderSource
)
+
deString
.
deStringHash
(
this
.
m_fragShaderSource
)
;
var
rnd
=
new
deRandom
.
Random
(
hash
)
;
var
xOffset
=
rnd
.
getInt
(
0
xOffsetMax
)
;
var
yOffset
=
rnd
.
getInt
(
0
yOffsetMax
)
;
gl
.
viewport
(
xOffset
yOffset
width
height
)
;
this
.
setupUniforms
(
programId
quadGrid
.
getConstCoords
(
)
)
;
this
.
setupDefaultInputs
(
programId
)
;
gl
.
clearColor
(
this
.
m_clearColor
[
0
]
this
.
m_clearColor
[
1
]
this
.
m_clearColor
[
2
]
this
.
m_clearColor
[
3
]
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
var
vertexArrays
=
[
]
;
var
numElements
=
quadGrid
.
getNumTriangles
(
)
*
3
;
glsShaderRenderCase
.
getDefaultVertexArrays
(
quadGrid
programId
vertexArrays
)
;
gluDrawUtil
.
draw
(
gl
programId
vertexArrays
gluDrawUtil
.
triangles
(
quadGrid
.
getIndices
(
)
)
)
;
result
.
readViewport
(
gl
[
xOffset
yOffset
width
height
]
)
;
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
computeVertexReference
=
function
(
result
quadGrid
)
{
var
width
=
result
.
getWidth
(
)
;
var
height
=
result
.
getHeight
(
)
;
var
gridSize
=
quadGrid
.
getGridSize
(
)
;
var
stride
=
gridSize
+
1
;
var
hasAlpha
=
gl
.
getContextAttributes
(
)
.
alpha
;
var
evalCtx
=
new
glsShaderRenderCase
.
ShaderEvalContext
(
quadGrid
)
;
var
color
=
[
]
;
var
colors
=
[
]
;
for
(
var
y
=
0
;
y
<
gridSize
+
1
;
y
+
+
)
for
(
var
x
=
0
;
x
<
gridSize
+
1
;
x
+
+
)
{
var
sx
=
x
/
gridSize
;
var
sy
=
y
/
gridSize
;
var
vtxNdx
=
(
(
y
*
(
gridSize
+
1
)
)
+
x
)
;
evalCtx
.
reset
(
sx
sy
)
;
this
.
m_evaluator
.
evaluate
(
evalCtx
)
;
assertMsgOptions
(
!
evalCtx
.
isDiscarded
'
Discard
is
not
available
in
vertex
shader
.
'
false
true
)
;
color
=
evalCtx
.
color
;
if
(
!
hasAlpha
)
color
[
3
]
=
1
.
0
;
colors
[
vtxNdx
]
=
color
;
}
for
(
var
y
=
0
;
y
<
gridSize
;
y
+
+
)
for
(
var
x
=
0
;
x
<
gridSize
;
x
+
+
)
{
var
x0
=
x
/
gridSize
;
var
x1
=
(
x
+
1
)
/
gridSize
;
var
y0
=
y
/
gridSize
;
var
y1
=
(
y
+
1
)
/
gridSize
;
var
sx0
=
x0
*
width
;
var
sx1
=
x1
*
width
;
var
sy0
=
y0
*
height
;
var
sy1
=
y1
*
height
;
var
oosx
=
1
.
0
/
(
sx1
-
sx0
)
;
var
oosy
=
1
.
0
/
(
sy1
-
sy0
)
;
var
ix0
=
Math
.
ceil
(
sx0
-
0
.
5
)
;
var
ix1
=
Math
.
ceil
(
sx1
-
0
.
5
)
;
var
iy0
=
Math
.
ceil
(
sy0
-
0
.
5
)
;
var
iy1
=
Math
.
ceil
(
sy1
-
0
.
5
)
;
var
v00
=
(
y
*
stride
)
+
x
;
var
v01
=
(
y
*
stride
)
+
x
+
1
;
var
v10
=
(
(
y
+
1
)
*
stride
)
+
x
;
var
v11
=
(
(
y
+
1
)
*
stride
)
+
x
+
1
;
var
c00
=
colors
[
v00
]
;
var
c01
=
colors
[
v01
]
;
var
c10
=
colors
[
v10
]
;
var
c11
=
colors
[
v11
]
;
for
(
var
iy
=
iy0
;
iy
<
iy1
;
iy
+
+
)
for
(
var
ix
=
ix0
;
ix
<
ix1
;
ix
+
+
)
{
assertMsgOptions
(
deMath
.
deInBounds32
(
ix
0
width
)
'
Out
of
bounds
.
'
false
true
)
;
assertMsgOptions
(
deMath
.
deInBounds32
(
iy
0
height
)
'
Out
of
bounds
.
'
false
true
)
;
var
sfx
=
ix
+
0
.
5
;
var
sfy
=
iy
+
0
.
5
;
var
fx1
=
deMath
.
clamp
(
(
sfx
-
sx0
)
*
oosx
0
.
0
1
.
0
)
;
var
fy1
=
deMath
.
clamp
(
(
sfy
-
sy0
)
*
oosy
0
.
0
1
.
0
)
;
var
tri
=
fx1
+
fy1
<
=
1
.
0
;
var
tx
=
tri
?
fx1
:
(
1
.
0
-
fx1
)
;
var
ty
=
tri
?
fy1
:
(
1
.
0
-
fy1
)
;
var
t0
=
tri
?
c00
:
c11
;
var
t1
=
tri
?
c01
:
c10
;
var
t2
=
tri
?
c10
:
c01
;
color
=
deMath
.
add
(
t0
deMath
.
add
(
deMath
.
scale
(
deMath
.
subtract
(
t1
t0
)
tx
)
deMath
.
scale
(
deMath
.
subtract
(
t2
t0
)
ty
)
)
)
;
result
.
setPixel
(
ix
iy
glsShaderRenderCase
.
toRGBA
(
color
)
.
toIVec
(
)
)
;
}
}
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
computeFragmentReference
=
function
(
result
quadGrid
)
{
var
width
=
result
.
getWidth
(
)
;
var
height
=
result
.
getHeight
(
)
;
var
hasAlpha
=
gl
.
getContextAttributes
(
)
.
alpha
;
var
evalCtx
=
new
glsShaderRenderCase
.
ShaderEvalContext
(
quadGrid
)
;
for
(
var
y
=
0
;
y
<
height
;
y
+
+
)
for
(
var
x
=
0
;
x
<
width
;
x
+
+
)
{
var
sx
=
(
x
+
0
.
5
)
/
width
;
var
sy
=
(
y
+
0
.
5
)
/
height
;
evalCtx
.
reset
(
sx
sy
)
;
this
.
m_evaluator
.
evaluate
(
evalCtx
)
;
var
color
=
evalCtx
.
isDiscarded
?
this
.
m_clearColor
:
evalCtx
.
color
;
if
(
!
hasAlpha
)
color
[
3
]
=
1
.
0
;
result
.
setPixel
(
x
y
glsShaderRenderCase
.
toRGBA
(
color
)
.
toIVec
(
)
)
;
}
}
;
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
.
compareImages
=
function
(
resImage
refImage
errorThreshold
)
{
return
tcuImageCompare
.
fuzzyCompare
(
"
ComparisonResult
"
"
Image
comparison
result
"
refImage
.
getAccess
(
)
resImage
.
getAccess
(
)
errorThreshold
)
;
}
;
glsShaderRenderCase
.
getIntUniformName
=
function
(
number
)
{
switch
(
number
)
{
case
0
:
return
"
ui_zero
"
;
case
1
:
return
"
ui_one
"
;
case
2
:
return
"
ui_two
"
;
case
3
:
return
"
ui_three
"
;
case
4
:
return
"
ui_four
"
;
case
5
:
return
"
ui_five
"
;
case
6
:
return
"
ui_six
"
;
case
7
:
return
"
ui_seven
"
;
case
8
:
return
"
ui_eight
"
;
case
101
:
return
"
ui_oneHundredOne
"
;
default
:
throw
new
Error
(
"
Uniform
not
supported
.
"
)
;
}
}
;
glsShaderRenderCase
.
getFloatUniformName
=
function
(
number
)
{
switch
(
number
)
{
case
0
:
return
"
uf_zero
"
;
case
1
:
return
"
uf_one
"
;
case
2
:
return
"
uf_two
"
;
case
3
:
return
"
uf_three
"
;
case
4
:
return
"
uf_four
"
;
case
5
:
return
"
uf_five
"
;
case
6
:
return
"
uf_six
"
;
case
7
:
return
"
uf_seven
"
;
case
8
:
return
"
uf_eight
"
;
default
:
throw
new
Error
(
"
Uniform
not
supported
.
"
)
;
}
}
;
glsShaderRenderCase
.
getFloatFractionUniformName
=
function
(
number
)
{
switch
(
number
)
{
case
1
:
return
"
uf_one
"
;
case
2
:
return
"
uf_half
"
;
case
3
:
return
"
uf_third
"
;
case
4
:
return
"
uf_fourth
"
;
case
5
:
return
"
uf_fifth
"
;
case
6
:
return
"
uf_sixth
"
;
case
7
:
return
"
uf_seventh
"
;
case
8
:
return
"
uf_eighth
"
;
default
:
throw
new
Error
(
"
Uniform
not
supported
.
"
)
;
}
}
;
glsShaderRenderCase
.
setupDefaultUniforms
=
function
(
programID
)
{
var
uniLoc
;
var
BoolUniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_boolUniforms
=
[
new
BoolUniform
(
"
ub_true
"
true
)
new
BoolUniform
(
"
ub_false
"
false
)
]
;
for
(
var
i
=
0
;
i
<
s_boolUniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_boolUniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform1i
(
uniLoc
s_boolUniforms
[
i
]
.
value
?
1
:
0
)
;
}
var
BVec4Uniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_bvec4Uniforms
=
[
new
BVec4Uniform
(
"
ub4_true
"
[
true
true
true
true
]
)
new
BVec4Uniform
(
"
ub4_false
"
[
false
false
false
false
]
)
]
;
for
(
var
i
=
0
;
i
<
s_bvec4Uniforms
.
length
;
i
+
+
)
{
var
uni
=
s_bvec4Uniforms
[
i
]
;
var
arr
=
[
]
;
arr
[
0
]
=
uni
.
value
[
0
]
?
1
:
0
;
arr
[
1
]
=
uni
.
value
[
1
]
?
1
:
0
;
arr
[
2
]
=
uni
.
value
[
2
]
?
1
:
0
;
arr
[
3
]
=
uni
.
value
[
3
]
?
1
:
0
;
uniLoc
=
gl
.
getUniformLocation
(
programID
uni
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform4iv
(
uniLoc
new
Int32Array
(
arr
)
)
;
}
var
IntUniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_intUniforms
=
[
new
IntUniform
(
"
ui_minusOne
"
-
1
)
new
IntUniform
(
"
ui_zero
"
0
)
new
IntUniform
(
"
ui_one
"
1
)
new
IntUniform
(
"
ui_two
"
2
)
new
IntUniform
(
"
ui_three
"
3
)
new
IntUniform
(
"
ui_four
"
4
)
new
IntUniform
(
"
ui_five
"
5
)
new
IntUniform
(
"
ui_six
"
6
)
new
IntUniform
(
"
ui_seven
"
7
)
new
IntUniform
(
"
ui_eight
"
8
)
new
IntUniform
(
"
ui_oneHundredOne
"
101
)
]
;
for
(
var
i
=
0
;
i
<
s_intUniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_intUniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform1i
(
uniLoc
s_intUniforms
[
i
]
.
value
)
;
}
var
IVec2Uniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_ivec2Uniforms
=
[
new
IVec2Uniform
(
"
ui2_minusOne
"
[
-
1
-
1
]
)
new
IVec2Uniform
(
"
ui2_zero
"
[
0
0
]
)
new
IVec2Uniform
(
"
ui2_one
"
[
1
1
]
)
new
IVec2Uniform
(
"
ui2_two
"
[
2
2
]
)
new
IVec2Uniform
(
"
ui2_four
"
[
4
4
]
)
new
IVec2Uniform
(
"
ui2_five
"
[
5
5
]
)
]
;
for
(
var
i
=
0
;
i
<
s_ivec2Uniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_ivec2Uniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform2iv
(
uniLoc
new
Int32Array
(
s_ivec2Uniforms
[
i
]
.
value
)
)
;
}
var
IVec3Uniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_ivec3Uniforms
=
[
new
IVec3Uniform
(
"
ui3_minusOne
"
[
-
1
-
1
-
1
]
)
new
IVec3Uniform
(
"
ui3_zero
"
[
0
0
0
]
)
new
IVec3Uniform
(
"
ui3_one
"
[
1
1
1
]
)
new
IVec3Uniform
(
"
ui3_two
"
[
2
2
2
]
)
new
IVec3Uniform
(
"
ui3_four
"
[
4
4
4
]
)
new
IVec3Uniform
(
"
ui3_five
"
[
5
5
5
]
)
]
;
for
(
var
i
=
0
;
i
<
s_ivec3Uniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_ivec3Uniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform3iv
(
uniLoc
new
Int32Array
(
s_ivec3Uniforms
[
i
]
.
value
)
)
;
}
var
IVec4Uniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_ivec4Uniforms
=
[
new
IVec4Uniform
(
"
ui4_minusOne
"
[
-
1
-
1
-
1
-
1
]
)
new
IVec4Uniform
(
"
ui4_zero
"
[
0
0
0
0
]
)
new
IVec4Uniform
(
"
ui4_one
"
[
1
1
1
1
]
)
new
IVec4Uniform
(
"
ui4_two
"
[
2
2
2
2
]
)
new
IVec4Uniform
(
"
ui4_four
"
[
4
4
4
4
]
)
new
IVec4Uniform
(
"
ui4_five
"
[
5
5
5
5
]
)
]
;
for
(
var
i
=
0
;
i
<
s_ivec4Uniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_ivec4Uniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform4iv
(
uniLoc
new
Int32Array
(
s_ivec4Uniforms
[
i
]
.
value
)
)
;
}
var
FloatUniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_floatUniforms
=
[
new
FloatUniform
(
"
uf_zero
"
0
.
0
)
new
FloatUniform
(
"
uf_one
"
1
.
0
)
new
FloatUniform
(
"
uf_two
"
2
.
0
)
new
FloatUniform
(
"
uf_three
"
3
.
0
)
new
FloatUniform
(
"
uf_four
"
4
.
0
)
new
FloatUniform
(
"
uf_five
"
5
.
0
)
new
FloatUniform
(
"
uf_six
"
6
.
0
)
new
FloatUniform
(
"
uf_seven
"
7
.
0
)
new
FloatUniform
(
"
uf_eight
"
8
.
0
)
new
FloatUniform
(
"
uf_half
"
1
.
0
/
2
.
0
)
new
FloatUniform
(
"
uf_third
"
1
.
0
/
3
.
0
)
new
FloatUniform
(
"
uf_fourth
"
1
.
0
/
4
.
0
)
new
FloatUniform
(
"
uf_fifth
"
1
.
0
/
5
.
0
)
new
FloatUniform
(
"
uf_sixth
"
1
.
0
/
6
.
0
)
new
FloatUniform
(
"
uf_seventh
"
1
.
0
/
7
.
0
)
new
FloatUniform
(
"
uf_eighth
"
1
.
0
/
8
.
0
)
]
;
for
(
var
i
=
0
;
i
<
s_floatUniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_floatUniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform1f
(
uniLoc
s_floatUniforms
[
i
]
.
value
)
;
}
var
Vec2Uniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_vec2Uniforms
=
[
new
Vec2Uniform
(
"
uv2_minusOne
"
[
-
1
.
0
-
1
.
0
]
)
new
Vec2Uniform
(
"
uv2_zero
"
[
0
.
0
0
.
0
]
)
new
Vec2Uniform
(
"
uv2_half
"
[
0
.
5
0
.
5
]
)
new
Vec2Uniform
(
"
uv2_one
"
[
1
.
0
1
.
0
]
)
new
Vec2Uniform
(
"
uv2_two
"
[
2
.
0
2
.
0
]
)
]
;
for
(
var
i
=
0
;
i
<
s_vec2Uniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_vec2Uniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform2fv
(
uniLoc
new
Float32Array
(
s_vec2Uniforms
[
i
]
.
value
)
)
;
}
var
Vec3Uniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_vec3Uniforms
=
[
new
Vec3Uniform
(
"
uv3_minusOne
"
[
-
1
.
0
-
1
.
0
-
1
.
0
]
)
new
Vec3Uniform
(
"
uv3_zero
"
[
0
.
0
0
.
0
0
.
0
]
)
new
Vec3Uniform
(
"
uv3_half
"
[
0
.
5
0
.
5
0
.
5
]
)
new
Vec3Uniform
(
"
uv3_one
"
[
1
.
0
1
.
0
1
.
0
]
)
new
Vec3Uniform
(
"
uv3_two
"
[
2
.
0
2
.
0
2
.
0
]
)
]
;
for
(
var
i
=
0
;
i
<
s_vec3Uniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_vec3Uniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform3fv
(
uniLoc
new
Float32Array
(
s_vec3Uniforms
[
i
]
.
value
)
)
;
}
var
Vec4Uniform
=
function
(
name
value
)
{
this
.
name
=
name
;
this
.
value
=
value
;
}
;
var
s_vec4Uniforms
=
[
new
Vec4Uniform
(
"
uv4_minusOne
"
[
-
1
.
0
-
1
.
0
-
1
.
0
-
1
.
0
]
)
new
Vec4Uniform
(
"
uv4_zero
"
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
new
Vec4Uniform
(
"
uv4_half
"
[
0
.
5
0
.
5
0
.
5
0
.
5
]
)
new
Vec4Uniform
(
"
uv4_one
"
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
new
Vec4Uniform
(
"
uv4_two
"
[
2
.
0
2
.
0
2
.
0
2
.
0
]
)
new
Vec4Uniform
(
"
uv4_black
"
[
0
.
0
0
.
0
0
.
0
1
.
0
]
)
new
Vec4Uniform
(
"
uv4_gray
"
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
new
Vec4Uniform
(
"
uv4_white
"
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
]
;
for
(
var
i
=
0
;
i
<
s_vec4Uniforms
.
length
;
i
+
+
)
{
uniLoc
=
gl
.
getUniformLocation
(
programID
s_vec4Uniforms
[
i
]
.
name
)
;
if
(
uniLoc
!
=
null
)
gl
.
uniform4fv
(
uniLoc
new
Float32Array
(
s_vec4Uniforms
[
i
]
.
value
)
)
;
}
}
;
glsShaderRenderCase
.
getDefaultVertexArrays
=
function
(
quadGrid
program
vertexArrays
)
{
var
numElements
=
quadGrid
.
getNumVertices
(
)
;
var
posArray
=
[
]
.
concat
.
apply
(
[
]
quadGrid
.
getPositions
(
)
)
;
var
coordsArray
=
[
]
.
concat
.
apply
(
[
]
quadGrid
.
getCoordsArray
(
)
)
;
var
unitCoordsArray
=
[
]
.
concat
.
apply
(
[
]
quadGrid
.
getUnitCoordsArray
(
)
)
;
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
"
a_position
"
4
numElements
0
posArray
)
)
;
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
"
a_coords
"
4
numElements
0
coordsArray
)
)
;
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
"
a_unitCoords
"
4
numElements
0
unitCoordsArray
)
)
;
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
"
a_one
"
1
numElements
0
quadGrid
.
getAttribOne
(
)
)
)
;
for
(
var
userNdx
=
0
;
userNdx
<
quadGrid
.
getNumUserAttribs
(
)
;
userNdx
+
+
)
{
var
name
=
"
a_in
"
+
userNdx
;
var
userAttribArray
=
[
]
.
concat
.
apply
(
[
]
quadGrid
.
getUserAttribByIndex
(
userNdx
)
)
;
vertexArrays
.
push
(
gluDrawUtil
.
newFloatVertexArrayBinding
(
name
4
numElements
0
userAttribArray
)
)
;
}
var
Matrix
=
function
(
name
cols
rows
)
{
this
.
name
=
name
;
this
.
numCols
=
cols
;
this
.
numRows
=
rows
;
}
;
var
matrices
=
[
new
Matrix
(
'
a_mat2
'
2
2
)
new
Matrix
(
'
a_mat2x3
'
2
3
)
new
Matrix
(
'
a_mat2x4
'
2
4
)
new
Matrix
(
'
a_mat3x2
'
3
2
)
new
Matrix
(
'
a_mat3
'
3
3
)
new
Matrix
(
'
a_mat3x4
'
3
4
)
new
Matrix
(
'
a_mat4x2
'
4
2
)
new
Matrix
(
'
a_mat4x3
'
4
3
)
new
Matrix
(
'
a_mat4
'
4
4
)
]
;
for
(
var
matNdx
=
0
;
matNdx
<
matrices
.
length
;
matNdx
+
+
)
{
var
loc
=
gl
.
getAttribLocation
(
program
matrices
[
matNdx
]
.
name
)
;
if
(
loc
<
0
)
continue
;
var
numRows
=
matrices
[
matNdx
]
.
numRows
;
var
numCols
=
matrices
[
matNdx
]
.
numCols
;
for
(
var
colNdx
=
0
;
colNdx
<
numCols
;
colNdx
+
+
)
{
var
data
=
[
]
.
concat
.
apply
(
[
]
quadGrid
.
getUserAttribByIndex
(
colNdx
)
)
;
vertexArrays
.
push
(
gluDrawUtil
.
newFloatColumnVertexArrayBinding
(
matrices
[
matNdx
]
.
name
colNdx
numRows
numElements
4
*
4
data
)
)
;
}
}
}
;
}
)
;
