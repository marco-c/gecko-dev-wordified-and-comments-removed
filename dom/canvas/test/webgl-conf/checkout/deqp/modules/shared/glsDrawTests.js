'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsDrawTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuFloat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuPixelFormat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluStrUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrGLContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrReferenceContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrShaderProgram
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrFragmentOperations
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrGenericVector
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrShadingContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexAttrib
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexPacket
'
)
;
goog
.
scope
(
function
(
)
{
var
glsDrawTests
=
modules
.
shared
.
glsDrawTests
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuFloat
=
framework
.
common
.
tcuFloat
;
var
tcuPixelFormat
=
framework
.
common
.
tcuPixelFormat
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluStrUtil
=
framework
.
opengl
.
gluStrUtil
;
var
sglrGLContext
=
framework
.
opengl
.
simplereference
.
sglrGLContext
;
var
sglrReferenceContext
=
framework
.
opengl
.
simplereference
.
sglrReferenceContext
;
var
sglrShaderProgram
=
framework
.
opengl
.
simplereference
.
sglrShaderProgram
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
rrFragmentOperations
=
framework
.
referencerenderer
.
rrFragmentOperations
;
var
rrGenericVector
=
framework
.
referencerenderer
.
rrGenericVector
;
var
rrShadingContext
=
framework
.
referencerenderer
.
rrShadingContext
;
var
rrVertexAttrib
=
framework
.
referencerenderer
.
rrVertexAttrib
;
var
rrVertexPacket
=
framework
.
referencerenderer
.
rrVertexPacket
;
glsDrawTests
.
MAX_RENDER_TARGET_SIZE
=
512
;
glsDrawTests
.
targetToGL
=
function
(
target
)
{
assertMsgOptions
(
target
!
=
null
'
Target
is
null
'
false
true
)
;
var
targets
=
[
gl
.
ELEMENT_ARRAY_BUFFER
gl
.
ARRAY_BUFFER
]
;
return
targets
[
target
]
;
}
;
glsDrawTests
.
usageToGL
=
function
(
usage
)
{
assertMsgOptions
(
usage
!
=
null
'
Usage
is
null
'
false
true
)
;
var
usages
=
[
gl
.
DYNAMIC_DRAW
gl
.
STATIC_DRAW
gl
.
STREAM_DRAW
gl
.
STREAM_READ
gl
.
STREAM_COPY
gl
.
STATIC_READ
gl
.
STATIC_COPY
gl
.
DYNAMIC_READ
gl
.
DYNAMIC_COPY
]
;
assertMsgOptions
(
usages
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
Usage
)
.
length
'
Amount
of
usage
gl
vlaues
is
different
from
amount
of
usages
'
false
true
)
;
return
usages
[
usage
]
;
}
;
glsDrawTests
.
inputTypeToGL
=
function
(
type
)
{
assertMsgOptions
(
type
!
=
null
'
Input
type
is
null
'
false
true
)
;
var
types
=
[
gl
.
FLOAT
gl
.
BYTE
gl
.
SHORT
gl
.
UNSIGNED_BYTE
gl
.
UNSIGNED_SHORT
gl
.
INT
gl
.
UNSIGNED_INT
gl
.
HALF_FLOAT
gl
.
UNSIGNED_INT_2_10_10_10_REV
gl
.
INT_2_10_10_10_REV
]
;
assertMsgOptions
(
types
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
InputType
)
.
length
'
Amount
of
gl
input
types
is
different
from
amount
of
input
types
'
false
true
)
;
return
types
[
type
]
;
}
;
glsDrawTests
.
outputTypeToGLType
=
function
(
type
)
{
assertMsgOptions
(
type
!
=
null
'
Output
type
is
null
'
false
true
)
;
var
types
=
[
'
float
'
'
vec2
'
'
vec3
'
'
vec4
'
'
int
'
'
uint
'
'
ivec2
'
'
ivec3
'
'
ivec4
'
'
uvec2
'
'
uvec3
'
'
uvec4
'
]
;
assertMsgOptions
(
types
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
OutputType
)
.
length
'
Amount
of
output
type
names
is
different
than
amount
of
output
types
'
false
true
)
;
return
types
[
type
]
;
}
;
glsDrawTests
.
primitiveToGL
=
function
(
primitive
)
{
var
primitives
=
[
gl
.
POINTS
gl
.
TRIANGLES
gl
.
TRIANGLE_FAN
gl
.
TRIANGLE_STRIP
gl
.
LINES
gl
.
LINE_STRIP
gl
.
LINE_LOOP
]
;
assertMsgOptions
(
primitives
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
Primitive
)
.
length
'
Amount
of
gl
primitive
values
is
different
than
amount
of
primitives
'
false
true
)
;
return
primitives
[
primitive
]
;
}
;
glsDrawTests
.
indexTypeToGL
=
function
(
indexType
)
{
var
indexTypes
=
[
gl
.
UNSIGNED_BYTE
gl
.
UNSIGNED_SHORT
gl
.
UNSIGNED_INT
]
;
assertMsgOptions
(
indexTypes
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
IndexType
)
.
length
'
Amount
of
gl
index
types
is
different
than
amount
of
index
types
'
false
true
)
;
return
indexTypes
[
indexType
]
;
}
;
glsDrawTests
.
indexTypeToInputType
=
function
(
indexType
)
{
var
inputTypes
=
[
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
]
;
assertMsgOptions
(
inputTypes
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
IndexType
)
.
length
'
Amount
of
relevant
input
types
is
different
than
amount
of
index
types
'
false
true
)
;
return
inputTypes
[
indexType
]
;
}
;
glsDrawTests
.
inputTypeIsFloatType
=
function
(
type
)
{
if
(
type
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
)
return
true
;
if
(
type
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
)
return
true
;
return
false
;
}
;
glsDrawTests
.
outputTypeIsFloatType
=
function
(
type
)
{
if
(
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
)
return
true
;
return
false
;
}
;
glsDrawTests
.
outputTypeIsIntType
=
function
(
type
)
{
if
(
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC2
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
)
return
true
;
return
false
;
}
;
glsDrawTests
.
outputTypeIsUintType
=
function
(
type
)
{
if
(
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
)
return
true
;
return
false
;
}
;
glsDrawTests
.
getElementCount
=
function
(
primitive
primitiveCount
)
{
switch
(
primitive
)
{
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
:
return
primitiveCount
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
:
return
primitiveCount
*
3
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
:
return
primitiveCount
+
2
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
:
return
primitiveCount
+
2
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINES
:
return
primitiveCount
*
2
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_STRIP
:
return
primitiveCount
+
1
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_LOOP
:
return
(
primitiveCount
=
=
1
)
?
(
2
)
:
(
primitiveCount
)
;
default
:
throw
new
Error
(
'
Invalid
primitive
'
)
;
}
}
;
glsDrawTests
.
MethodInfo
=
{
indexed
:
false
instanced
:
false
ranged
:
false
first
:
false
}
;
glsDrawTests
.
getMethodInfo
=
function
(
method
)
{
var
infos
=
[
{
indexed
:
false
instanced
:
false
ranged
:
false
first
:
true
}
{
indexed
:
false
instanced
:
true
ranged
:
false
first
:
true
}
{
indexed
:
true
instanced
:
false
ranged
:
false
first
:
false
}
{
indexed
:
true
instanced
:
false
ranged
:
true
first
:
false
}
{
indexed
:
true
instanced
:
true
ranged
:
false
first
:
false
}
]
;
assertMsgOptions
(
infos
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
DrawMethod
)
.
length
'
Number
of
info
names
'
false
true
)
;
assertMsgOptions
(
method
<
infos
.
length
'
Invalid
method
'
false
true
)
;
return
(
infos
[
method
]
)
;
}
;
glsDrawTests
.
checkSpecsShaderCompatible
=
function
(
a
b
)
{
if
(
a
.
attribs
.
length
!
=
b
.
attribs
.
length
)
return
false
;
for
(
var
ndx
=
0
;
ndx
<
a
.
attribs
.
length
;
+
+
ndx
)
{
if
(
a
.
attribs
[
ndx
]
.
additionalPositionAttribute
!
=
b
.
attribs
[
ndx
]
.
additionalPositionAttribute
)
return
false
;
if
(
glsDrawTests
.
outputTypeIsFloatType
(
a
.
attribs
[
ndx
]
.
outputType
)
&
&
glsDrawTests
.
outputTypeIsFloatType
(
b
.
attribs
[
ndx
]
.
outputType
)
)
continue
;
if
(
glsDrawTests
.
outputTypeIsIntType
(
a
.
attribs
[
ndx
]
.
outputType
)
&
&
glsDrawTests
.
outputTypeIsIntType
(
b
.
attribs
[
ndx
]
.
outputType
)
)
continue
;
if
(
glsDrawTests
.
outputTypeIsUintType
(
a
.
attribs
[
ndx
]
.
outputType
)
&
&
glsDrawTests
.
outputTypeIsUintType
(
b
.
attribs
[
ndx
]
.
outputType
)
)
continue
;
return
false
;
}
return
true
;
}
;
glsDrawTests
.
generateRandomVec4
=
function
(
random
)
{
var
retVal
=
[
]
;
for
(
var
i
=
0
;
i
<
4
;
+
+
i
)
retVal
[
i
]
=
random
.
getFloat
(
)
;
return
retVal
;
}
;
glsDrawTests
.
generateRandomIVec4
=
function
(
random
)
{
var
retVal
=
[
]
;
for
(
var
i
=
0
;
i
<
4
;
+
+
i
)
retVal
[
i
]
=
random
.
getInt
(
)
;
return
retVal
;
}
;
glsDrawTests
.
generateRandomUVec4
=
function
(
random
)
{
var
retVal
=
[
]
;
for
(
var
i
=
0
;
i
<
4
;
+
+
i
)
retVal
[
i
]
=
Math
.
abs
(
random
.
getInt
(
)
)
;
return
retVal
;
}
;
glsDrawTests
.
GLValue
=
function
(
)
{
this
.
m_value
=
[
0
]
;
this
.
m_type
;
}
;
glsDrawTests
.
copyGLValueToArray
=
function
(
dst
val
)
{
var
dst8
=
new
Uint8Array
(
dst
.
buffer
)
.
subarray
(
dst
.
byteOffset
dst
.
byteOffset
+
dst
.
byteLength
)
;
var
val8
=
new
Uint8Array
(
val
.
m_value
.
buffer
)
;
dst8
.
set
(
val8
)
;
}
;
glsDrawTests
.
copyArray
=
function
(
dst
src
)
{
var
dst8
=
new
Uint8Array
(
dst
.
buffer
)
.
subarray
(
dst
.
byteOffset
dst
.
byteOffset
+
dst
.
byteLength
)
;
var
src8
=
new
Uint8Array
(
src
.
buffer
)
.
subarray
(
src
.
byteOffset
src
.
byteOffset
+
src
.
byteLength
)
;
dst8
.
set
(
src8
)
;
}
;
glsDrawTests
.
GLValue
.
typeToTypedArray
=
function
(
value
type
)
{
var
array
;
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
array
=
new
Float32Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
:
array
=
new
Int8Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
:
array
=
new
Int16Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
:
array
=
new
Uint8Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
:
array
=
new
Uint16Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
array
=
new
Int32Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
array
=
new
Uint32Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
:
array
=
new
Uint16Array
(
1
)
;
value
=
glsDrawTests
.
GLValue
.
floatToHalf
(
value
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
:
array
=
new
Uint32Array
(
1
)
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
:
array
=
new
Int32Array
(
1
)
;
break
;
default
:
throw
new
Error
(
'
glsDrawTests
.
GLValue
.
typeToTypedArray
-
Invalid
InputType
'
)
;
}
array
[
0
]
=
value
;
return
array
;
}
;
glsDrawTests
.
GLValue
.
create
=
function
(
value
type
)
{
var
v
=
new
glsDrawTests
.
GLValue
(
)
;
v
.
m_value
=
glsDrawTests
.
GLValue
.
typeToTypedArray
(
value
type
)
;
v
.
m_type
=
type
;
return
v
;
}
;
glsDrawTests
.
GLValue
.
halfToFloat
=
function
(
value
)
{
return
tcuFloat
.
halfFloatToNumberNoDenorm
(
value
)
;
}
;
glsDrawTests
.
GLValue
.
floatToHalf
=
function
(
f
)
{
return
tcuFloat
.
numberToHalfFloatNoDenorm
(
f
)
;
}
;
glsDrawTests
.
GLValue
.
getMaxValue
=
function
(
type
)
{
var
value
=
0
;
assertMsgOptions
(
type
>
=
0
&
&
type
<
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
InputType
)
.
length
'
Invalid
type
for
GLValue
'
false
true
)
;
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
value
=
127
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
:
value
=
127
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
:
value
=
32760
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
:
value
=
255
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
:
value
=
65530
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
value
=
2147483647
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
value
=
4294967295
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
:
value
=
256
;
break
;
default
:
value
=
0
;
}
return
glsDrawTests
.
GLValue
.
create
(
value
type
)
;
}
;
glsDrawTests
.
GLValue
.
getMinValue
=
function
(
type
)
{
var
value
=
0
;
assertMsgOptions
(
type
>
=
0
&
&
type
<
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
InputType
)
.
length
'
Invalid
type
for
GLValue
'
false
true
)
;
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
value
=
-
127
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
:
value
=
-
127
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
:
value
=
-
32760
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
:
value
=
0
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
:
value
=
0
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
value
=
-
2147483647
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
value
=
0
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
:
value
=
-
256
;
break
;
default
:
value
=
0
;
}
return
glsDrawTests
.
GLValue
.
create
(
value
type
)
;
}
;
glsDrawTests
.
GLValue
.
getRandom
=
function
(
rnd
min
max
)
{
assertMsgOptions
(
min
.
getType
(
)
=
=
max
.
getType
(
)
'
Min
and
max
types
differ
'
false
true
)
;
var
minv
=
min
.
interpret
(
)
;
var
maxv
=
max
.
interpret
(
)
;
var
type
=
min
.
getType
(
)
;
var
value
;
if
(
maxv
<
minv
)
return
min
;
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
:
{
return
glsDrawTests
.
GLValue
.
create
(
minv
+
rnd
.
getFloat
(
)
*
(
maxv
-
minv
)
type
)
;
break
;
}
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
{
return
glsDrawTests
.
GLValue
.
create
(
minv
+
rnd
.
getInt
(
)
%
(
maxv
-
minv
)
type
)
;
break
;
}
default
:
throw
new
Error
(
'
glsDrawTests
.
GLValue
.
getRandom
-
Invalid
input
type
'
)
;
break
;
}
}
;
glsDrawTests
.
GLValue
.
minValue
=
function
(
type
)
{
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
:
return
glsDrawTests
.
GLValue
.
create
(
4
type
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
:
return
glsDrawTests
.
GLValue
.
create
(
4
*
256
type
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
:
return
glsDrawTests
.
GLValue
.
create
(
4
*
2
type
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
return
glsDrawTests
.
GLValue
.
create
(
4
*
16777216
type
)
;
default
:
throw
new
Error
(
'
glsDrawTests
.
GLValue
.
minValue
-
Invalid
input
type
'
)
;
}
}
;
glsDrawTests
.
GLValue
.
abs
=
function
(
val
)
{
var
type
=
val
.
getType
(
)
;
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
:
return
glsDrawTests
.
GLValue
.
create
(
0x7FFF
&
val
.
getValue
(
)
type
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
:
return
glsDrawTests
.
GLValue
.
create
(
0x7F
&
val
.
getValue
(
)
type
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
return
val
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
:
return
glsDrawTests
.
GLValue
.
create
(
Math
.
abs
(
val
.
interpret
(
)
)
type
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
return
glsDrawTests
.
GLValue
.
create
(
0x7FFFFFFF
&
val
.
getValue
(
)
type
)
;
default
:
throw
new
Error
(
'
glsDrawTests
.
GLValue
.
abs
-
Invalid
input
type
'
)
;
}
}
;
glsDrawTests
.
GLValue
.
prototype
.
getType
=
function
(
)
{
return
this
.
m_type
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
toFloat
=
function
(
)
{
return
this
.
interpret
(
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
getValue
=
function
(
)
{
return
this
.
m_value
[
0
]
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
interpret
=
function
(
)
{
if
(
this
.
m_type
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
)
return
glsDrawTests
.
GLValue
.
halfToFloat
(
this
.
m_value
[
0
]
)
;
return
this
.
m_value
[
0
]
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
add
=
function
(
other
)
{
return
glsDrawTests
.
GLValue
.
create
(
this
.
interpret
(
)
+
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
mul
=
function
(
other
)
{
return
glsDrawTests
.
GLValue
.
create
(
this
.
interpret
(
)
*
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
div
=
function
(
other
)
{
return
glsDrawTests
.
GLValue
.
create
(
this
.
interpret
(
)
/
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
sub
=
function
(
other
)
{
return
glsDrawTests
.
GLValue
.
create
(
this
.
interpret
(
)
-
other
.
interpret
(
)
this
.
m_type
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
addToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
+
other
.
interpret
(
)
;
return
this
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
subToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
-
other
.
interpret
(
)
;
return
this
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
mulToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
*
other
.
interpret
(
)
;
return
this
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
divToSelf
=
function
(
other
)
{
this
.
m_value
[
0
]
=
this
.
interpret
(
)
/
other
.
interpret
(
)
;
return
this
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
equals
=
function
(
other
)
{
return
this
.
m_value
[
0
]
=
=
other
.
getValue
(
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
lessThan
=
function
(
other
)
{
return
this
.
interpret
(
)
<
other
.
interpret
(
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
greaterThan
=
function
(
other
)
{
return
this
.
interpret
(
)
>
other
.
interpret
(
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
lessOrEqualThan
=
function
(
other
)
{
return
this
.
interpret
(
)
<
=
other
.
interpret
(
)
;
}
;
glsDrawTests
.
GLValue
.
prototype
.
greaterOrEqualThan
=
function
(
other
)
{
return
this
.
interpret
(
)
>
=
other
.
interpret
(
)
;
}
;
glsDrawTests
.
AttributeArray
=
function
(
storage
context
)
{
this
.
m_storage
=
storage
;
this
.
m_ctx
=
context
;
this
.
m_glBuffer
;
this
.
m_size
=
0
;
this
.
m_data
;
this
.
m_componentCount
;
this
.
m_bound
=
false
;
this
.
m_target
=
glsDrawTests
.
DrawTestSpec
.
Target
.
ARRAY
;
this
.
m_inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
this
.
m_outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
;
this
.
m_normalize
=
false
;
this
.
m_stride
=
0
;
this
.
m_offset
=
0
;
this
.
m_defaultAttrib
;
this
.
m_instanceDivisor
=
0
;
this
.
m_isPositionAttr
=
false
;
if
(
this
.
m_storage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
this
.
m_glBuffer
=
this
.
m_ctx
.
createBuffer
(
)
;
}
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
getComponentCount
=
function
(
)
{
return
this
.
m_componentCount
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
getTarget
=
function
(
)
{
return
this
.
m_target
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
getInputType
=
function
(
)
{
return
this
.
m_inputType
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
getOutputType
=
function
(
)
{
return
this
.
m_outputType
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
getStorageType
=
function
(
)
{
return
this
.
m_storage
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
getNormalized
=
function
(
)
{
return
this
.
m_normalize
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
getStride
=
function
(
)
{
return
this
.
m_stride
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
isBound
=
function
(
)
{
return
this
.
m_bound
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
isPositionAttribute
=
function
(
)
{
return
this
.
m_isPositionAttr
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
data
=
function
(
target
size
ptr
usage
)
{
this
.
m_size
=
size
;
this
.
m_target
=
target
;
if
(
this
.
m_storage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsDrawTests
.
targetToGL
(
target
)
this
.
m_glBuffer
)
;
this
.
m_ctx
.
bufferData
(
glsDrawTests
.
targetToGL
(
target
)
ptr
glsDrawTests
.
usageToGL
(
usage
)
)
;
}
else
throw
new
Error
(
'
Wrong
storage
type
'
)
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
subdata
=
function
(
target
offset
size
ptr
)
{
this
.
m_target
=
target
;
if
(
this
.
m_storage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsDrawTests
.
targetToGL
(
target
)
this
.
m_glBuffer
)
;
this
.
m_ctx
.
bufferSubData
(
glsDrawTests
.
targetToGL
(
target
)
offset
size
ptr
)
;
}
else
throw
new
Error
(
'
Wrong
storage
type
'
)
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
setupArray
=
function
(
bound
offset
size
inputType
outType
normalized
stride
instanceDivisor
defaultAttrib
isPositionAttr
)
{
this
.
m_componentCount
=
size
;
this
.
m_bound
=
bound
;
this
.
m_inputType
=
inputType
;
this
.
m_outputType
=
outType
;
this
.
m_normalize
=
normalized
;
this
.
m_stride
=
stride
;
this
.
m_offset
=
offset
;
this
.
m_defaultAttrib
=
defaultAttrib
;
this
.
m_instanceDivisor
=
instanceDivisor
;
this
.
m_isPositionAttr
=
isPositionAttr
;
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
bindAttribute
=
function
(
loc
)
{
if
(
!
this
.
isBound
(
)
)
{
var
attr
=
this
.
m_defaultAttrib
;
switch
(
this
.
m_inputType
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
{
switch
(
this
.
m_componentCount
)
{
case
1
:
this
.
m_ctx
.
vertexAttrib1f
(
loc
attr
[
0
]
)
;
break
;
case
2
:
this
.
m_ctx
.
vertexAttrib2f
(
loc
attr
[
0
]
attr
[
1
]
)
;
break
;
case
3
:
this
.
m_ctx
.
vertexAttrib3f
(
loc
attr
[
0
]
attr
[
1
]
attr
[
2
]
)
;
break
;
case
4
:
this
.
m_ctx
.
vertexAttrib4f
(
loc
attr
[
0
]
attr
[
1
]
attr
[
2
]
attr
[
3
]
)
;
break
;
default
:
throw
new
Error
(
'
Invalid
component
count
'
)
;
break
;
}
break
;
}
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
{
this
.
m_ctx
.
vertexAttribI4i
(
loc
attr
[
0
]
attr
[
1
]
attr
[
2
]
attr
[
3
]
)
;
break
;
}
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
{
this
.
m_ctx
.
vertexAttribI4ui
(
loc
attr
[
0
]
attr
[
1
]
attr
[
2
]
attr
[
3
]
)
;
break
;
}
default
:
throw
new
Error
(
'
Invalid
input
type
'
)
;
break
;
}
}
else
{
var
basePtr
=
null
;
if
(
this
.
m_storage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsDrawTests
.
targetToGL
(
this
.
m_target
)
this
.
m_glBuffer
)
;
basePtr
=
null
;
}
else
throw
new
Error
(
'
Invalid
storage
type
'
)
;
if
(
!
glsDrawTests
.
inputTypeIsFloatType
(
this
.
m_inputType
)
)
{
if
(
glsDrawTests
.
outputTypeIsFloatType
(
this
.
m_outputType
)
)
{
var
size
=
this
.
m_componentCount
;
this
.
m_ctx
.
vertexAttribPointer
(
loc
size
glsDrawTests
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_normalize
this
.
m_stride
this
.
m_offset
)
;
}
else
{
this
.
m_ctx
.
vertexAttribIPointer
(
loc
this
.
m_componentCount
glsDrawTests
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_stride
this
.
m_offset
)
;
}
}
else
{
assertMsgOptions
(
glsDrawTests
.
outputTypeIsFloatType
(
this
.
m_outputType
)
'
Output
type
is
not
float
'
false
true
)
;
this
.
m_ctx
.
vertexAttribPointer
(
loc
this
.
m_componentCount
glsDrawTests
.
inputTypeToGL
(
this
.
m_inputType
)
this
.
m_normalize
this
.
m_stride
this
.
m_offset
)
;
}
if
(
this
.
m_instanceDivisor
)
this
.
m_ctx
.
vertexAttribDivisor
(
loc
this
.
m_instanceDivisor
)
;
}
}
;
glsDrawTests
.
AttributeArray
.
prototype
.
bindIndexArray
=
function
(
target
)
{
if
(
this
.
m_storage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
this
.
m_ctx
.
bindBuffer
(
glsDrawTests
.
targetToGL
(
target
)
this
.
m_glBuffer
)
;
}
}
;
glsDrawTests
.
DrawTestShaderProgram
=
function
(
arrays
)
{
sglrShaderProgram
.
ShaderProgram
.
call
(
this
this
.
createProgramDeclaration
(
arrays
)
)
;
this
.
m_componentCount
=
[
]
;
this
.
m_isCoord
=
[
]
;
this
.
m_attrType
=
[
]
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
{
this
.
m_componentCount
[
arrayNdx
]
=
this
.
getComponentCount
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
;
this
.
m_isCoord
[
arrayNdx
]
=
arrays
[
arrayNdx
]
.
isPositionAttribute
(
)
;
this
.
m_attrType
[
arrayNdx
]
=
this
.
mapOutputType
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
;
}
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
=
Object
.
create
(
sglrShaderProgram
.
ShaderProgram
.
prototype
)
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
constructor
=
glsDrawTests
.
DrawTestShaderProgram
;
glsDrawTests
.
calcShaderColor
=
function
(
color
attribValue
numComponents
)
{
switch
(
numComponents
)
{
case
1
:
color
[
0
]
=
deMath
.
scale
(
color
attribValue
[
0
]
)
[
0
]
;
break
;
case
2
:
color
[
0
]
=
color
[
0
]
*
attribValue
[
0
]
;
color
[
1
]
=
color
[
1
]
*
attribValue
[
1
]
;
break
;
case
3
:
color
[
0
]
=
color
[
0
]
*
attribValue
[
0
]
;
color
[
1
]
=
color
[
1
]
*
attribValue
[
1
]
;
color
[
2
]
=
color
[
2
]
*
attribValue
[
2
]
;
break
;
case
4
:
color
[
0
]
=
color
[
0
]
*
attribValue
[
0
]
*
attribValue
[
3
]
;
color
[
1
]
=
color
[
1
]
*
attribValue
[
1
]
*
attribValue
[
3
]
;
color
[
2
]
=
color
[
2
]
*
attribValue
[
2
]
*
attribValue
[
3
]
;
break
;
default
:
throw
new
Error
(
'
Invalid
component
count
'
)
;
}
return
color
;
}
;
glsDrawTests
.
calcShaderCoord
=
function
(
coord
attribValue
numComponents
)
{
switch
(
numComponents
)
{
case
1
:
coord
=
deMath
.
add
(
coord
[
attribValue
[
0
]
attribValue
[
0
]
]
)
;
coord
[
0
]
=
coord
[
0
]
;
coord
[
1
]
=
coord
[
1
]
;
break
;
case
2
:
coord
=
deMath
.
add
(
coord
[
attribValue
[
0
]
attribValue
[
1
]
]
)
;
coord
[
0
]
=
coord
[
0
]
;
coord
[
1
]
=
coord
[
1
]
;
break
;
case
3
:
coord
=
deMath
.
add
(
coord
[
attribValue
[
0
]
+
attribValue
[
2
]
attribValue
[
1
]
]
)
;
coord
[
0
]
=
coord
[
0
]
;
coord
[
1
]
=
coord
[
1
]
;
coord
[
2
]
=
coord
[
2
]
;
break
;
case
4
:
coord
=
deMath
.
add
(
coord
[
attribValue
[
0
]
+
attribValue
[
2
]
attribValue
[
1
]
+
attribValue
[
3
]
]
)
;
coord
[
0
]
=
coord
[
0
]
;
coord
[
1
]
=
coord
[
1
]
;
coord
[
2
]
=
coord
[
2
]
;
coord
[
3
]
=
coord
[
3
]
;
break
;
default
:
throw
new
Error
(
'
Invalid
component
count
'
)
;
}
return
coord
;
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
shadeVertices
=
function
(
inputs
packets
numPackets
)
{
var
u_coordScale
=
this
.
getUniformByName
(
'
u_coordScale
'
)
.
value
;
var
u_colorScale
=
this
.
getUniformByName
(
'
u_colorScale
'
)
.
value
;
for
(
var
packetNdx
=
0
;
packetNdx
<
numPackets
;
+
+
packetNdx
)
{
var
varyingLocColor
=
0
;
var
packet
=
packets
[
packetNdx
]
;
var
coord
=
[
0
.
0
0
.
0
]
;
var
color
=
[
1
.
0
1
.
0
1
.
0
]
;
for
(
var
attribNdx
=
0
;
attribNdx
<
this
.
m_attrType
.
length
;
attribNdx
+
+
)
{
var
numComponents
=
this
.
m_componentCount
[
attribNdx
]
;
var
isCoord
=
this
.
m_isCoord
[
attribNdx
]
;
var
attrib
=
rrVertexAttrib
.
readVertexAttrib
(
inputs
[
attribNdx
]
packet
.
instanceNdx
packet
.
vertexNdx
this
.
m_attrType
[
attribNdx
]
)
;
if
(
isCoord
)
{
coord
=
glsDrawTests
.
calcShaderCoord
(
coord
attrib
numComponents
)
;
}
else
{
color
=
glsDrawTests
.
calcShaderColor
(
color
attrib
numComponents
)
;
}
}
packet
.
position
=
[
u_coordScale
*
coord
[
0
]
u_coordScale
*
coord
[
1
]
1
.
0
1
.
0
]
;
packet
.
pointSize
=
1
.
0
;
packet
.
outputs
[
varyingLocColor
]
=
deMath
.
add
(
deMath
.
scale
(
[
u_colorScale
*
color
[
0
]
u_colorScale
*
color
[
1
]
u_colorScale
*
color
[
2
]
1
.
0
]
0
.
5
)
[
0
.
5
0
.
5
0
.
5
0
.
5
]
)
;
}
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
shadeFragments
=
function
(
packets
context
)
{
var
varyingLocColor
=
0
;
for
(
var
packetNdx
=
0
;
packetNdx
<
packets
.
length
;
+
+
packetNdx
)
{
var
packet
=
packets
[
packetNdx
]
;
packet
.
value
=
rrShadingContext
.
readVarying
(
packet
context
varyingLocColor
)
;
}
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
genVertexSource
=
function
(
arrays
)
{
var
params
;
var
vertexShaderTmpl
=
'
'
;
params
=
this
.
generateShaderParams
(
)
;
vertexShaderTmpl
+
=
params
[
'
VTX_HDR
'
]
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
{
vertexShaderTmpl
+
=
params
[
'
VTX_IN
'
]
+
'
highp
'
+
glsDrawTests
.
outputTypeToGLType
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
+
'
a_
'
+
arrayNdx
+
'
;
\
n
'
;
}
vertexShaderTmpl
+
=
'
uniform
highp
float
u_coordScale
;
\
n
'
+
'
uniform
highp
float
u_colorScale
;
\
n
'
+
params
[
'
VTX_OUT
'
]
+
'
'
+
params
[
'
COL_PRECISION
'
]
+
'
vec4
v_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
\
tgl_PointSize
=
1
.
0
;
\
n
'
+
'
\
thighp
vec2
coord
=
vec2
(
0
.
0
0
.
0
)
;
\
n
'
+
'
\
thighp
vec3
color
=
vec3
(
1
.
0
1
.
0
1
.
0
)
;
\
n
'
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
{
var
isPositionAttr
=
arrays
[
arrayNdx
]
.
isPositionAttribute
(
)
;
if
(
isPositionAttr
)
{
switch
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
{
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
:
vertexShaderTmpl
+
=
'
\
tcoord
+
=
vec2
(
float
(
a_
'
+
arrayNdx
+
'
)
float
(
a_
'
+
arrayNdx
+
'
)
)
;
\
n
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
:
vertexShaderTmpl
+
=
'
\
tcoord
+
=
vec2
(
a_
'
+
arrayNdx
+
'
.
xy
)
;
\
n
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
:
vertexShaderTmpl
+
=
'
\
tcoord
+
=
vec2
(
a_
'
+
arrayNdx
+
'
.
xy
)
;
\
n
'
+
'
\
tcoord
.
x
+
=
float
(
a_
'
+
arrayNdx
+
'
.
z
)
;
\
n
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
:
vertexShaderTmpl
+
=
'
\
tcoord
+
=
vec2
(
a_
'
+
arrayNdx
+
'
.
xy
)
;
\
n
'
+
'
\
tcoord
+
=
vec2
(
a_
'
+
arrayNdx
+
'
.
zw
)
;
\
n
'
;
break
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
break
;
}
}
else
{
switch
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
{
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
:
vertexShaderTmpl
+
=
'
\
tcolor
=
color
*
float
(
a_
'
+
arrayNdx
+
'
)
;
\
n
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
:
vertexShaderTmpl
+
=
'
\
tcolor
.
rg
=
color
.
rg
*
vec2
(
a_
'
+
arrayNdx
+
'
.
xy
)
;
\
n
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
:
vertexShaderTmpl
+
=
'
\
tcolor
=
color
.
rgb
*
vec3
(
a_
'
+
arrayNdx
+
'
.
xyz
)
;
\
n
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
:
vertexShaderTmpl
+
=
'
\
tcolor
=
color
.
rgb
*
vec3
(
a_
'
+
arrayNdx
+
'
.
xyz
)
*
float
(
a_
'
+
arrayNdx
+
'
.
w
)
;
\
n
'
;
break
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
break
;
}
}
}
vertexShaderTmpl
+
=
'
\
tv_color
=
vec4
(
u_colorScale
*
color
1
.
0
)
*
0
.
5
+
vec4
(
0
.
5
0
.
5
0
.
5
0
.
5
)
;
\
n
'
+
'
\
tgl_Position
=
vec4
(
u_coordScale
*
coord
1
.
0
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
return
vertexShaderTmpl
;
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
genFragmentSource
=
function
(
)
{
var
params
;
params
=
this
.
generateShaderParams
(
)
;
var
fragmentShaderTmpl
=
params
[
'
FRAG_HDR
'
]
+
params
[
'
FRAG_IN
'
]
+
'
'
+
params
[
'
COL_PRECISION
'
]
+
'
vec4
v_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
\
t
'
+
params
[
'
FRAG_COLOR
'
]
+
'
=
v_color
;
\
n
'
+
'
}
\
n
'
;
return
fragmentShaderTmpl
;
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
generateShaderParams
=
function
(
)
{
var
params
=
[
]
;
if
(
gluShaderUtil
.
isGLSLVersionSupported
(
gl
gluShaderUtil
.
GLSLVersion
.
V300_ES
)
)
{
params
[
'
VTX_IN
'
]
=
'
in
'
;
params
[
'
VTX_OUT
'
]
=
'
out
'
;
params
[
'
FRAG_IN
'
]
=
'
in
'
;
params
[
'
FRAG_COLOR
'
]
=
'
dEQP_FragColor
'
;
params
[
'
VTX_HDR
'
]
=
'
#
version
300
es
\
n
'
;
params
[
'
FRAG_HDR
'
]
=
'
#
version
300
es
\
nlayout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
;
params
[
'
COL_PRECISION
'
]
=
'
mediump
'
;
}
else
if
(
gluShaderUtil
.
isGLSLVersionSupported
(
gl
gluShaderUtil
.
GLSLVersion
.
V100_ES
)
)
{
params
[
'
VTX_IN
'
]
=
'
attribute
'
;
params
[
'
VTX_OUT
'
]
=
'
varying
'
;
params
[
'
FRAG_IN
'
]
=
'
varying
'
;
params
[
'
FRAG_COLOR
'
]
=
'
gl_FragColor
'
;
params
[
'
VTX_HDR
'
]
=
'
'
;
params
[
'
FRAG_HDR
'
]
=
'
'
;
params
[
'
COL_PRECISION
'
]
=
'
mediump
'
;
}
else
throw
new
Error
(
'
Invalid
GL
version
'
)
;
return
params
;
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
mapOutputType
=
function
(
type
)
{
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
:
return
rrGenericVector
.
GenericVecType
.
FLOAT
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
:
return
rrGenericVector
.
GenericVecType
.
INT32
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
:
return
rrGenericVector
.
GenericVecType
.
UINT32
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
}
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
getComponentCount
=
function
(
type
)
{
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
:
return
1
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC2
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
:
return
2
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
:
return
3
;
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
:
case
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
:
return
4
;
default
:
throw
new
Error
(
'
Invalid
output
type
'
)
;
}
}
;
glsDrawTests
.
DrawTestShaderProgram
.
prototype
.
createProgramDeclaration
=
function
(
arrays
)
{
var
decl
=
new
sglrShaderProgram
.
ShaderProgramDeclaration
(
)
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
arrays
.
length
;
arrayNdx
+
+
)
decl
.
pushVertexAttribute
(
new
sglrShaderProgram
.
VertexAttribute
(
'
a_
'
+
arrayNdx
this
.
mapOutputType
(
arrays
[
arrayNdx
]
.
getOutputType
(
)
)
)
)
;
decl
.
pushVertexToFragmentVarying
(
new
sglrShaderProgram
.
VertexToFragmentVarying
(
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushFragmentOutput
(
new
sglrShaderProgram
.
FragmentOutput
(
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushVertexSource
(
new
sglrShaderProgram
.
VertexSource
(
this
.
genVertexSource
(
arrays
)
)
)
;
decl
.
pushFragmentSource
(
new
sglrShaderProgram
.
FragmentSource
(
this
.
genFragmentSource
(
)
)
)
;
decl
.
pushUniform
(
new
sglrShaderProgram
.
Uniform
(
'
u_coordScale
'
gluShaderUtil
.
DataType
.
FLOAT
)
)
;
decl
.
pushUniform
(
new
sglrShaderProgram
.
Uniform
(
'
u_colorScale
'
gluShaderUtil
.
DataType
.
FLOAT
)
)
;
return
decl
;
}
;
glsDrawTests
.
RandomArrayGenerator
=
{
}
;
glsDrawTests
.
RandomArrayGenerator
.
setData
=
function
(
data
type
rnd
min
max
)
{
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
:
glsDrawTests
.
copyGLValueToArray
(
data
glsDrawTests
.
GLValue
.
getRandom
(
rnd
min
max
)
)
;
break
;
default
:
throw
new
Error
(
'
Invalid
input
type
'
)
;
}
}
;
glsDrawTests
.
RandomArrayGenerator
.
createArray
=
function
(
seed
elementCount
componentCount
offset
stride
type
first
primitive
indices
indexSize
)
{
assertMsgOptions
(
componentCount
>
=
1
&
&
componentCount
<
=
4
'
Unacceptable
number
of
components
'
false
true
)
;
var
min
=
glsDrawTests
.
GLValue
.
getMinValue
(
type
)
;
var
max
=
glsDrawTests
.
GLValue
.
getMaxValue
(
type
)
;
var
packed
=
type
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
|
|
type
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
;
var
limit10
=
(
1
<
<
10
)
;
var
limit2
=
(
1
<
<
2
)
;
var
componentSize
=
glsDrawTests
.
DrawTestSpec
.
inputTypeSize
(
type
)
;
var
elementSize
=
componentSize
*
componentCount
;
var
bufferSize
=
offset
+
Math
.
max
(
elementCount
*
stride
elementCount
*
elementSize
)
;
var
data
=
new
ArrayBuffer
(
bufferSize
)
;
var
writePtr
=
new
Uint8Array
(
data
offset
)
;
var
previousComponentsFloat
=
[
0
0
0
0
]
;
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
for
(
var
vertexNdx
=
0
;
vertexNdx
<
elementCount
;
vertexNdx
+
+
)
{
var
components
=
[
]
;
for
(
var
componentNdx
=
0
;
componentNdx
<
componentCount
;
componentNdx
+
+
)
{
var
getRandomComponent
=
function
(
)
{
if
(
packed
)
{
if
(
componentNdx
=
=
3
)
{
return
rnd
.
getInt
(
)
%
limit2
;
}
else
{
return
rnd
.
getInt
(
)
%
limit10
;
}
}
else
{
return
glsDrawTests
.
GLValue
.
getRandom
(
rnd
min
max
)
;
}
}
;
var
component
=
getRandomComponent
(
)
;
var
componentFloat
=
(
component
instanceof
glsDrawTests
.
GLValue
)
?
component
.
toFloat
(
)
:
component
;
if
(
vertexNdx
!
=
0
&
&
Math
.
abs
(
componentFloat
-
previousComponentsFloat
[
componentNdx
]
)
<
min
.
toFloat
(
)
)
{
component
=
getRandomComponent
(
)
;
componentFloat
=
(
component
instanceof
glsDrawTests
.
GLValue
)
?
component
.
toFloat
(
)
:
component
;
}
components
.
push
(
component
)
;
previousComponentsFloat
[
componentNdx
]
=
componentFloat
;
}
if
(
packed
)
{
var
packedValue
=
deMath
.
binaryOp
(
deMath
.
shiftLeft
(
(
components
)
[
3
]
30
)
deMath
.
binaryOp
(
deMath
.
shiftLeft
(
(
components
)
[
2
]
20
)
deMath
.
binaryOp
(
deMath
.
shiftLeft
(
(
components
)
[
1
]
10
)
(
components
)
[
0
]
deMath
.
BinaryOp
.
OR
)
deMath
.
BinaryOp
.
OR
)
deMath
.
BinaryOp
.
OR
)
;
glsDrawTests
.
copyArray
(
writePtr
new
Uint32Array
(
[
packedValue
]
)
)
;
}
else
{
for
(
var
componentNdx
=
0
;
componentNdx
<
componentCount
;
componentNdx
+
+
)
{
glsDrawTests
.
copyGLValueToArray
(
writePtr
.
subarray
(
componentNdx
*
componentSize
)
components
[
componentNdx
]
)
;
}
}
writePtr
=
writePtr
.
subarray
(
stride
)
;
}
return
new
Uint8Array
(
data
)
;
}
;
glsDrawTests
.
RandomArrayGenerator
.
generateIndices
=
function
(
seed
elementCount
type
offset
min
max
)
{
return
glsDrawTests
.
RandomArrayGenerator
.
createIndices
(
seed
elementCount
offset
min
max
type
)
;
}
;
glsDrawTests
.
RandomArrayGenerator
.
createIndices
=
function
(
seed
elementCount
offset
min
max
type
)
{
var
elementSize
=
glsDrawTests
.
DrawTestSpec
.
indexTypeSize
(
type
)
;
var
bufferSize
=
offset
+
elementCount
*
elementSize
;
var
data
=
new
ArrayBuffer
(
bufferSize
)
;
var
writePtr
=
new
Uint8Array
(
data
)
.
subarray
(
offset
)
;
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
var
keys
=
[
]
;
for
(
var
key
=
0
;
key
<
elementCount
;
key
+
+
)
keys
.
push
(
glsDrawTests
.
GLValue
.
create
(
key
glsDrawTests
.
indexTypeToInputType
(
type
)
)
)
;
for
(
var
elementNdx
=
0
;
elementNdx
<
elementCount
;
+
+
elementNdx
)
{
var
randomkey
=
rnd
.
getInt
(
0
keys
.
length
-
1
)
;
var
ndx
=
keys
[
randomkey
]
;
keys
.
splice
(
randomkey
1
)
;
glsDrawTests
.
copyArray
(
writePtr
.
subarray
(
elementSize
*
elementNdx
)
new
Uint8Array
(
ndx
.
m_value
.
buffer
)
)
;
}
return
new
Uint8Array
(
data
)
;
}
;
glsDrawTests
.
RandomArrayGenerator
.
generateAttributeValue
=
function
(
seed
type
)
{
var
random
=
new
deRandom
.
Random
(
seed
)
;
switch
(
type
)
{
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
:
return
glsDrawTests
.
generateRandomVec4
(
random
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
:
return
glsDrawTests
.
generateRandomIVec4
(
random
)
;
case
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
:
return
glsDrawTests
.
generateRandomUVec4
(
random
)
;
default
:
throw
new
Error
(
'
Invalid
attribute
type
'
)
;
}
}
;
glsDrawTests
.
AttributePack
=
function
(
drawContext
screenSize
useVao
logEnabled
)
{
this
.
m_ctx
=
drawContext
;
this
.
m_arrays
=
[
]
;
this
.
m_program
;
this
.
m_screen
=
new
tcuSurface
.
Surface
(
screenSize
[
0
]
screenSize
[
1
]
)
;
this
.
m_useVao
=
useVao
;
this
.
m_logEnabled
=
logEnabled
;
this
.
m_programID
=
null
;
this
.
m_vaoID
=
null
;
if
(
this
.
m_useVao
)
this
.
m_vaoID
=
this
.
m_ctx
.
createVertexArray
(
)
;
}
;
glsDrawTests
.
AttributePack
.
prototype
.
getSurface
=
function
(
)
{
return
this
.
m_screen
;
}
;
glsDrawTests
.
AttributePack
.
prototype
.
getArray
=
function
(
i
)
{
return
this
.
m_arrays
[
i
]
;
}
;
glsDrawTests
.
AttributePack
.
prototype
.
getArrayCount
=
function
(
)
{
return
this
.
m_arrays
.
length
;
}
;
glsDrawTests
.
AttributePack
.
prototype
.
newArray
=
function
(
storage
)
{
this
.
m_arrays
.
push
(
new
glsDrawTests
.
AttributeArray
(
storage
this
.
m_ctx
)
)
;
}
;
glsDrawTests
.
AttributePack
.
prototype
.
clearArrays
=
function
(
)
{
this
.
m_arrays
.
length
=
0
;
}
;
glsDrawTests
.
AttributePack
.
prototype
.
updateProgram
=
function
(
)
{
if
(
this
.
m_programID
)
this
.
m_ctx
.
deleteProgram
(
this
.
m_programID
)
;
this
.
m_program
=
new
glsDrawTests
.
DrawTestShaderProgram
(
this
.
m_arrays
)
;
this
.
m_programID
=
this
.
m_ctx
.
createProgram
(
this
.
m_program
)
;
}
;
glsDrawTests
.
AttributePack
.
prototype
.
render
=
function
(
primitive
drawMethod
firstVertex
vertexCount
indexType
indexOffset
rangeStart
rangeEnd
instanceCount
coordScale
colorScale
indexArray
)
{
assertMsgOptions
(
this
.
m_program
!
=
null
'
Program
is
null
'
false
true
)
;
assertMsgOptions
(
this
.
m_programID
!
=
null
'
No
context
created
program
'
false
true
)
;
this
.
m_ctx
.
viewport
(
0
0
this
.
m_screen
.
getWidth
(
)
this
.
m_screen
.
getHeight
(
)
)
;
this
.
m_ctx
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
this
.
m_ctx
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
this
.
m_ctx
.
useProgram
(
this
.
m_programID
)
;
this
.
m_ctx
.
uniform1f
(
this
.
m_ctx
.
getUniformLocation
(
this
.
m_programID
'
u_coordScale
'
)
coordScale
)
;
this
.
m_ctx
.
uniform1f
(
this
.
m_ctx
.
getUniformLocation
(
this
.
m_programID
'
u_colorScale
'
)
colorScale
)
;
if
(
this
.
m_useVao
)
this
.
m_ctx
.
bindVertexArray
(
this
.
m_vaoID
)
;
if
(
indexArray
)
indexArray
.
bindIndexArray
(
glsDrawTests
.
DrawTestSpec
.
Target
.
ELEMENT_ARRAY
)
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
this
.
m_arrays
.
length
;
arrayNdx
+
+
)
{
var
attribName
=
'
'
;
attribName
+
=
'
a_
'
+
arrayNdx
;
var
loc
=
this
.
m_ctx
.
getAttribLocation
(
this
.
m_programID
attribName
)
;
if
(
this
.
m_arrays
[
arrayNdx
]
.
isBound
(
)
)
this
.
m_ctx
.
enableVertexAttribArray
(
loc
)
;
this
.
m_arrays
[
arrayNdx
]
.
bindAttribute
(
loc
)
;
}
if
(
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS
)
this
.
m_ctx
.
drawArrays
(
glsDrawTests
.
primitiveToGL
(
primitive
)
firstVertex
vertexCount
)
;
else
if
(
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS_INSTANCED
)
this
.
m_ctx
.
drawArraysInstanced
(
glsDrawTests
.
primitiveToGL
(
primitive
)
firstVertex
vertexCount
instanceCount
)
;
else
if
(
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS
)
this
.
m_ctx
.
drawElements
(
glsDrawTests
.
primitiveToGL
(
primitive
)
vertexCount
glsDrawTests
.
indexTypeToGL
(
indexType
)
indexOffset
)
;
else
if
(
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
)
this
.
m_ctx
.
drawRangeElements
(
glsDrawTests
.
primitiveToGL
(
primitive
)
rangeStart
rangeEnd
vertexCount
glsDrawTests
.
indexTypeToGL
(
indexType
)
indexOffset
)
;
else
if
(
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_INSTANCED
)
this
.
m_ctx
.
drawElementsInstanced
(
glsDrawTests
.
primitiveToGL
(
primitive
)
vertexCount
glsDrawTests
.
indexTypeToGL
(
indexType
)
indexOffset
instanceCount
)
;
else
throw
new
Error
(
'
Invalid
draw
method
'
)
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
this
.
m_arrays
.
length
;
arrayNdx
+
+
)
{
if
(
this
.
m_arrays
[
arrayNdx
]
.
isBound
(
)
)
{
var
attribName
=
'
'
;
attribName
+
=
'
a_
'
+
arrayNdx
;
var
loc
=
this
.
m_ctx
.
getAttribLocation
(
this
.
m_programID
attribName
)
;
this
.
m_ctx
.
disableVertexAttribArray
(
loc
)
;
}
}
if
(
this
.
m_useVao
)
this
.
m_ctx
.
bindVertexArray
(
null
)
;
this
.
m_ctx
.
useProgram
(
null
)
;
this
.
m_screen
.
readViewport
(
this
.
m_ctx
[
0
0
this
.
m_screen
.
getWidth
(
)
this
.
m_screen
.
getHeight
(
)
]
)
;
}
;
glsDrawTests
.
DrawTestSpec
=
function
(
)
{
this
.
primitive
=
null
;
this
.
primitiveCount
=
0
;
this
.
drawMethod
=
null
;
this
.
indexType
=
null
;
this
.
indexPointerOffset
=
0
;
this
.
indexStorage
=
null
;
this
.
first
=
0
;
this
.
indexMin
=
0
;
this
.
indexMax
=
0
;
this
.
instanceCount
=
0
;
this
.
indirectOffset
=
0
;
this
.
baseVertex
=
0
;
this
.
attribs
=
[
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
targetToString
=
function
(
target
)
{
assertMsgOptions
(
target
!
=
null
'
Target
is
null
'
false
true
)
;
var
targets
=
[
'
element_array
'
'
array
'
]
;
assertMsgOptions
(
targets
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
Target
)
.
length
'
The
amount
of
target
names
is
different
than
the
amount
of
targets
'
false
true
)
;
return
targets
[
target
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
=
function
(
type
)
{
assertMsgOptions
(
type
!
=
null
'
Type
is
null
'
false
true
)
;
var
types
=
[
'
float
'
'
byte
'
'
short
'
'
unsigned_byte
'
'
unsigned_short
'
'
int
'
'
unsigned_int
'
'
half
'
'
unsigned_int2_10_10_10
'
'
int2_10_10_10
'
]
;
assertMsgOptions
(
types
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
InputType
)
.
length
'
The
amount
of
type
names
is
different
than
the
amount
of
types
'
false
true
)
;
return
types
[
type
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
=
function
(
type
)
{
assertMsgOptions
(
type
!
=
null
'
Type
is
null
'
false
true
)
;
var
types
=
[
'
float
'
'
vec2
'
'
vec3
'
'
vec4
'
'
int
'
'
uint
'
'
ivec2
'
'
ivec3
'
'
ivec4
'
'
uvec2
'
'
uvec3
'
'
uvec4
'
]
;
assertMsgOptions
(
types
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
OutputType
)
.
length
'
The
amount
of
type
names
is
different
than
the
amount
of
types
'
false
true
)
;
return
types
[
type
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
usageTypeToString
=
function
(
usage
)
{
assertMsgOptions
(
usage
!
=
null
'
Usage
is
null
'
false
true
)
;
var
usages
=
[
'
dynamic_draw
'
'
static_draw
'
'
stream_draw
'
'
stream_read
'
'
stream_copy
'
'
static_read
'
'
static_copy
'
'
dynamic_read
'
'
dynamic_copy
'
]
;
assertMsgOptions
(
usages
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
Usage
)
.
length
'
The
amount
of
usage
names
is
different
than
the
amount
of
usages
'
false
true
)
;
return
usages
[
usage
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
storageToString
=
function
(
storage
)
{
assertMsgOptions
(
storage
!
=
null
'
Storage
is
null
'
false
true
)
;
var
storages
=
[
'
user_ptr
'
'
buffer
'
]
;
assertMsgOptions
(
storages
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
Storage
)
.
length
'
The
amount
of
storage
names
is
different
than
the
amount
of
storages
'
false
true
)
;
return
storages
[
storage
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
primitiveToString
=
function
(
primitive
)
{
assertMsgOptions
(
primitive
!
=
null
'
Primitive
is
null
'
false
true
)
;
var
primitives
=
[
'
points
'
'
triangles
'
'
triangle_fan
'
'
triangle_strip
'
'
lines
'
'
line_strip
'
'
line_loop
'
]
;
assertMsgOptions
(
primitives
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
Primitive
)
.
length
'
The
amount
of
primitive
names
is
different
than
the
amount
of
primitives
'
false
true
)
;
return
primitives
[
primitive
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
=
function
(
type
)
{
assertMsgOptions
(
type
!
=
null
'
Index
type
is
null
'
false
true
)
;
var
indexTypes
=
[
'
byte
'
'
short
'
'
int
'
]
;
assertMsgOptions
(
indexTypes
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
IndexType
)
.
length
'
The
amount
of
index
type
names
is
different
than
the
amount
of
index
types
'
false
true
)
;
return
indexTypes
[
type
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
drawMethodToString
=
function
(
method
)
{
assertMsgOptions
(
method
!
=
null
'
Method
is
null
'
false
true
)
;
var
methods
=
[
'
draw_arrays
'
'
draw_arrays_instanced
'
'
draw_elements
'
'
draw_range_elements
'
'
draw_elements_instanced
'
]
;
assertMsgOptions
(
methods
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
DrawMethod
)
.
length
'
The
amount
of
method
names
is
different
than
the
amount
of
methods
'
false
true
)
;
return
methods
[
method
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
inputTypeSize
=
function
(
type
)
{
assertMsgOptions
(
type
!
=
null
'
Input
type
is
null
'
false
true
)
;
var
size
=
[
4
1
2
1
2
4
4
2
4
/
4
4
/
4
]
;
assertMsgOptions
(
size
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
InputType
)
.
length
'
The
amount
of
type
names
is
different
than
the
amount
of
types
'
false
true
)
;
return
size
[
type
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
indexTypeSize
=
function
(
type
)
{
assertMsgOptions
(
type
!
=
null
'
Type
is
null
'
false
true
)
;
var
size
=
[
1
2
4
]
;
assertMsgOptions
(
size
.
length
=
=
Object
.
keys
(
glsDrawTests
.
DrawTestSpec
.
IndexType
)
.
length
'
The
amount
of
type
names
is
different
than
the
amount
of
types
'
false
true
)
;
return
size
[
type
]
;
}
;
glsDrawTests
.
DrawTestSpec
.
prototype
.
getName
=
function
(
)
{
var
methodInfo
=
glsDrawTests
.
getMethodInfo
(
this
.
drawMethod
)
;
var
hasFirst
=
methodInfo
.
first
;
var
instanced
=
methodInfo
.
instanced
;
var
ranged
=
methodInfo
.
ranged
;
var
indexed
=
methodInfo
.
indexed
;
var
name
=
'
'
;
for
(
var
ndx
=
0
;
ndx
<
this
.
attribs
.
length
;
+
+
ndx
)
{
var
attrib
=
this
.
attribs
[
ndx
]
;
if
(
this
.
attribs
.
length
>
1
)
name
+
=
'
attrib
'
+
ndx
+
'
_
'
;
if
(
ndx
=
=
0
|
|
attrib
.
additionalPositionAttribute
)
name
+
=
'
pos_
'
;
else
name
+
=
'
col_
'
;
if
(
attrib
.
useDefaultAttribute
)
{
name
+
=
'
non_array_
'
+
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
(
(
attrib
.
inputType
)
)
+
'
_
'
+
attrib
.
componentCount
+
'
_
'
+
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
(
attrib
.
outputType
)
+
'
_
'
;
}
else
{
name
+
=
glsDrawTests
.
DrawTestSpec
.
storageToString
(
attrib
.
storage
)
+
'
_
'
+
attrib
.
offset
+
'
_
'
+
attrib
.
stride
+
'
_
'
+
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
(
(
attrib
.
inputType
)
)
;
if
(
attrib
.
inputType
!
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
&
&
attrib
.
inputType
!
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
)
name
+
=
attrib
.
componentCount
;
name
+
=
'
_
'
+
(
attrib
.
normalize
?
'
normalized_
'
:
'
'
)
+
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
(
attrib
.
outputType
)
+
'
_
'
+
glsDrawTests
.
DrawTestSpec
.
usageTypeToString
(
attrib
.
usage
)
+
'
_
'
+
attrib
.
instanceDivisor
+
'
_
'
;
}
}
if
(
indexed
)
name
+
=
'
index_
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
this
.
indexType
)
+
'
_
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
this
.
indexStorage
)
+
'
_
'
+
'
offset
'
+
this
.
indexPointerOffset
+
'
_
'
;
if
(
hasFirst
)
name
+
=
'
first
'
+
this
.
first
+
'
_
'
;
if
(
ranged
)
name
+
=
'
ranged_
'
+
this
.
indexMin
+
'
_
'
+
this
.
indexMax
+
'
_
'
;
if
(
instanced
)
name
+
=
'
instances
'
+
this
.
instanceCount
+
'
_
'
;
switch
(
this
.
primitive
)
{
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
:
name
+
=
'
points_
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
:
name
+
=
'
triangles_
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
:
name
+
=
'
triangle_fan_
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
:
name
+
=
'
triangle_strip_
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINES
:
name
+
=
'
lines_
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_STRIP
:
name
+
=
'
line_strip_
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_LOOP
:
name
+
=
'
line_loop_
'
;
break
;
default
:
throw
new
Error
(
'
Invalid
primitive
'
)
;
break
;
}
name
+
=
this
.
primitiveCount
;
return
name
;
}
;
glsDrawTests
.
DrawTestSpec
.
prototype
.
getDesc
=
function
(
)
{
var
desc
=
'
'
;
for
(
var
ndx
=
0
;
ndx
<
this
.
attribs
.
length
;
+
+
ndx
)
{
var
attrib
=
this
.
attribs
[
ndx
]
;
if
(
attrib
.
useDefaultAttribute
)
{
desc
+
=
'
Attribute
'
+
ndx
+
'
:
default
'
+
(
(
ndx
=
=
0
|
|
attrib
.
additionalPositionAttribute
)
?
(
'
position
'
)
:
(
'
color
'
)
)
+
'
input
datatype
'
+
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
(
(
attrib
.
inputType
)
)
+
'
'
+
'
input
component
count
'
+
attrib
.
componentCount
+
'
'
+
'
used
as
'
+
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
(
attrib
.
outputType
)
+
'
'
;
}
else
{
desc
+
=
'
Attribute
'
+
ndx
+
'
:
'
+
(
(
ndx
=
=
0
|
|
attrib
.
additionalPositionAttribute
)
?
(
'
position
'
)
:
(
'
color
'
)
)
+
'
Storage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
attrib
.
storage
)
+
'
'
+
'
stride
'
+
attrib
.
stride
+
'
'
+
'
input
datatype
'
+
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
(
(
attrib
.
inputType
)
)
+
'
'
+
'
input
component
count
'
+
attrib
.
componentCount
+
'
'
+
(
attrib
.
normalize
?
'
normalized
'
:
'
'
)
+
'
used
as
'
+
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
(
attrib
.
outputType
)
+
'
'
+
'
instance
divisor
'
+
attrib
.
instanceDivisor
+
'
'
;
}
}
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS
)
{
desc
+
=
'
drawArrays
(
)
'
+
'
first
'
+
this
.
first
+
'
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS_INSTANCED
)
{
desc
+
=
'
drawArraysInstanced
(
)
'
+
'
first
'
+
this
.
first
+
'
'
+
'
instance
count
'
+
this
.
instanceCount
+
'
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS
)
{
desc
+
=
'
drawElements
(
)
'
+
'
index
type
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
this
.
indexType
)
+
'
'
+
'
index
storage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
this
.
indexStorage
)
+
'
'
+
'
index
offset
'
+
this
.
indexPointerOffset
+
'
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
)
{
desc
+
=
'
drawElementsRanged
(
)
'
+
'
index
type
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
this
.
indexType
)
+
'
'
+
'
index
storage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
this
.
indexStorage
)
+
'
'
+
'
index
offset
'
+
this
.
indexPointerOffset
+
'
'
+
'
range
start
'
+
this
.
indexMin
+
'
'
+
'
range
end
'
+
this
.
indexMax
+
'
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_INSTANCED
)
{
desc
+
=
'
drawElementsInstanced
(
)
'
+
'
index
type
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
this
.
indexType
)
+
'
'
+
'
index
storage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
this
.
indexStorage
)
+
'
'
+
'
index
offset
'
+
this
.
indexPointerOffset
+
'
'
+
'
instance
count
'
+
this
.
instanceCount
+
'
'
;
}
else
throw
new
Error
(
'
Invalid
draw
method
'
)
;
desc
+
=
this
.
primitiveCount
;
switch
(
this
.
primitive
)
{
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
:
desc
+
=
'
points
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
:
desc
+
=
'
triangles
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
:
desc
+
=
'
triangles
(
fan
)
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
:
desc
+
=
'
triangles
(
strip
)
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINES
:
desc
+
=
'
lines
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_STRIP
:
desc
+
=
'
lines
(
strip
)
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_LOOP
:
desc
+
=
'
lines
(
loop
)
'
;
break
;
default
:
throw
new
Error
(
'
Invalid
primitive
'
)
;
break
;
}
return
desc
;
}
;
glsDrawTests
.
DrawTestSpec
.
prototype
.
getMultilineDesc
=
function
(
)
{
var
desc
=
'
'
;
for
(
var
ndx
=
0
;
ndx
<
this
.
attribs
.
length
;
+
+
ndx
)
{
var
attrib
=
this
.
attribs
[
ndx
]
;
if
(
attrib
.
useDefaultAttribute
)
{
desc
+
=
'
Attribute
'
+
ndx
+
'
:
default
'
+
(
(
ndx
=
=
0
|
|
attrib
.
additionalPositionAttribute
)
?
(
'
position
\
n
'
)
:
(
'
color
\
n
'
)
)
+
'
\
tinput
datatype
'
+
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
(
(
attrib
.
inputType
)
)
+
'
\
n
'
+
'
\
tinput
component
count
'
+
attrib
.
componentCount
+
'
\
n
'
+
'
\
tused
as
'
+
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
(
attrib
.
outputType
)
+
'
\
n
'
;
}
else
{
desc
+
=
'
Attribute
'
+
ndx
+
'
:
'
+
(
(
ndx
=
=
0
|
|
attrib
.
additionalPositionAttribute
)
?
(
'
position
\
n
'
)
:
(
'
color
\
n
'
)
)
+
'
\
tStorage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
attrib
.
storage
)
+
'
\
n
'
+
'
\
tstride
'
+
attrib
.
stride
+
'
\
n
'
+
'
\
tinput
datatype
'
+
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
(
(
attrib
.
inputType
)
)
+
'
\
n
'
+
'
\
tinput
component
count
'
+
attrib
.
componentCount
+
'
\
n
'
+
(
attrib
.
normalize
?
'
\
tnormalized
\
n
'
:
'
'
)
+
'
\
tused
as
'
+
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
(
attrib
.
outputType
)
+
'
\
n
'
+
'
\
tinstance
divisor
'
+
attrib
.
instanceDivisor
+
'
\
n
'
;
}
}
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS
)
{
desc
+
=
'
drawArrays
(
)
\
n
'
+
'
\
tfirst
'
+
this
.
first
+
'
\
n
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS_INSTANCED
)
{
desc
+
=
'
drawArraysInstanced
(
)
\
n
'
+
'
\
tfirst
'
+
this
.
first
+
'
\
n
'
+
'
\
tinstance
count
'
+
this
.
instanceCount
+
'
\
n
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS
)
{
desc
+
=
'
drawElements
(
)
\
n
'
+
'
\
tindex
type
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
this
.
indexType
)
+
'
\
n
'
+
'
\
tindex
storage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
this
.
indexStorage
)
+
'
\
n
'
+
'
\
tindex
offset
'
+
this
.
indexPointerOffset
+
'
\
n
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
)
{
desc
+
=
'
drawElementsRanged
(
)
\
n
'
+
'
\
tindex
type
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
this
.
indexType
)
+
'
\
n
'
+
'
\
tindex
storage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
this
.
indexStorage
)
+
'
\
n
'
+
'
\
tindex
offset
'
+
this
.
indexPointerOffset
+
'
\
n
'
+
'
\
trange
start
'
+
this
.
indexMin
+
'
\
n
'
+
'
\
trange
end
'
+
this
.
indexMax
+
'
\
n
'
;
}
else
if
(
this
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_INSTANCED
)
{
desc
+
=
'
drawElementsInstanced
(
)
\
n
'
+
'
\
tindex
type
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
this
.
indexType
)
+
'
\
n
'
+
'
\
tindex
storage
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
this
.
indexStorage
)
+
'
\
n
'
+
'
\
tindex
offset
'
+
this
.
indexPointerOffset
+
'
\
n
'
+
'
\
tinstance
count
'
+
this
.
instanceCount
+
'
\
n
'
;
}
else
throw
new
Error
(
'
Invalid
draw
method
'
)
;
desc
+
=
'
\
t
'
+
this
.
primitiveCount
+
'
'
;
switch
(
this
.
primitive
)
{
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
:
desc
+
=
'
points
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
:
desc
+
=
'
triangles
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
:
desc
+
=
'
triangles
(
fan
)
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
:
desc
+
=
'
triangles
(
strip
)
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINES
:
desc
+
=
'
lines
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_STRIP
:
desc
+
=
'
lines
(
strip
)
'
;
break
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_LOOP
:
desc
+
=
'
lines
(
loop
)
'
;
break
;
default
:
throw
new
Error
(
'
Invalid
primitive
'
)
;
break
;
}
desc
+
=
'
\
n
'
;
return
desc
;
}
;
glsDrawTests
.
DrawTestSpec
.
Target
=
{
ELEMENT_ARRAY
:
0
ARRAY
:
1
}
;
glsDrawTests
.
DrawTestSpec
.
InputType
=
{
FLOAT
:
0
BYTE
:
1
SHORT
:
2
UNSIGNED_BYTE
:
3
UNSIGNED_SHORT
:
4
INT
:
5
UNSIGNED_INT
:
6
HALF
:
7
UNSIGNED_INT_2_10_10_10
:
8
INT_2_10_10_10
:
9
}
;
glsDrawTests
.
DrawTestSpec
.
OutputType
=
{
FLOAT
:
0
VEC2
:
1
VEC3
:
2
VEC4
:
3
INT
:
4
UINT
:
5
IVEC2
:
6
IVEC3
:
7
IVEC4
:
8
UVEC2
:
9
UVEC3
:
10
UVEC4
:
11
}
;
glsDrawTests
.
DrawTestSpec
.
Usage
=
{
DYNAMIC_DRAW
:
0
STATIC_DRAW
:
1
STREAM_DRAW
:
2
STREAM_READ
:
3
STREAM_COPY
:
4
STATIC_READ
:
5
STATIC_COPY
:
6
DYNAMIC_READ
:
7
DYNAMIC_COPY
:
8
}
;
glsDrawTests
.
DrawTestSpec
.
Storage
=
{
USER
:
0
BUFFER
:
1
}
;
glsDrawTests
.
DrawTestSpec
.
Primitive
=
{
POINTS
:
0
TRIANGLES
:
1
TRIANGLE_FAN
:
2
TRIANGLE_STRIP
:
3
LINES
:
4
LINE_STRIP
:
5
LINE_LOOP
:
6
}
;
glsDrawTests
.
DrawTestSpec
.
IndexType
=
{
BYTE
:
0
SHORT
:
1
INT
:
2
}
;
glsDrawTests
.
DrawTestSpec
.
DrawMethod
=
{
DRAWARRAYS
:
0
DRAWARRAYS_INSTANCED
:
1
DRAWELEMENTS
:
2
DRAWELEMENTS_RANGED
:
3
DRAWELEMENTS_INSTANCED
:
4
}
;
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
=
{
NONE
:
0
UNALIGNED_OFFSET
:
1
UNALIGNED_STRIDE
:
2
}
;
glsDrawTests
.
DrawTestSpec
.
prototype
.
hash
=
function
(
)
{
var
methodInfo
=
glsDrawTests
.
getMethodInfo
(
this
.
drawMethod
)
;
var
arrayed
=
methodInfo
.
first
;
var
instanced
=
methodInfo
.
instanced
;
var
ranged
=
methodInfo
.
ranged
;
var
indexed
=
methodInfo
.
indexed
;
var
indexHash
=
(
!
indexed
)
?
(
0
)
:
(
this
.
indexType
+
10
*
this
.
indexPointerOffset
+
100
*
this
.
indexStorage
)
;
var
arrayHash
=
(
!
arrayed
)
?
(
0
)
:
(
this
.
first
)
;
var
indexRangeHash
=
(
!
ranged
)
?
(
0
)
:
(
this
.
indexMin
+
10
*
this
.
indexMax
)
;
var
instanceHash
=
(
!
instanced
)
?
(
0
)
:
(
this
.
instanceCount
)
;
var
basicHash
=
this
.
primitive
+
10
*
this
.
primitiveCount
+
100
*
this
.
drawMethod
;
return
indexHash
+
3
*
arrayHash
+
5
*
indexRangeHash
+
7
*
instanceHash
+
13
*
basicHash
+
17
*
this
.
attribs
.
length
+
19
*
this
.
primitiveCount
;
}
;
glsDrawTests
.
DrawTestSpec
.
prototype
.
valid
=
function
(
)
{
assertMsgOptions
(
this
.
primitive
!
=
null
'
Primitive
is
null
'
false
true
)
;
assertMsgOptions
(
this
.
drawMethod
!
=
null
'
Draw
method
is
null
'
false
true
)
;
var
methodInfo
=
glsDrawTests
.
getMethodInfo
(
this
.
drawMethod
)
;
if
(
methodInfo
.
ranged
)
{
var
maxIndexValue
=
0
;
if
(
this
.
indexType
=
=
glsDrawTests
.
DrawTestSpec
.
IndexType
.
BYTE
)
maxIndexValue
=
glsDrawTests
.
GLValue
.
getMaxValue
(
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
)
.
interpret
(
)
;
else
if
(
this
.
indexType
=
=
glsDrawTests
.
DrawTestSpec
.
IndexType
.
SHORT
)
maxIndexValue
=
glsDrawTests
.
GLValue
.
getMaxValue
(
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
)
.
interpret
(
)
;
else
if
(
this
.
indexType
=
=
glsDrawTests
.
DrawTestSpec
.
IndexType
.
INT
)
maxIndexValue
=
glsDrawTests
.
GLValue
.
getMaxValue
(
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
)
.
interpret
(
)
;
else
throw
new
Error
(
'
Invalid
index
type
'
)
;
if
(
this
.
indexMin
>
this
.
indexMax
)
return
false
;
if
(
this
.
indexMin
<
0
|
|
this
.
indexMax
<
0
)
return
false
;
if
(
this
.
indexMin
>
maxIndexValue
|
|
this
.
indexMax
>
maxIndexValue
)
return
false
;
}
if
(
methodInfo
.
first
&
&
this
.
first
<
0
)
return
false
;
return
true
;
}
;
glsDrawTests
.
DrawTestSpec
.
prototype
.
isCompatibilityTest
=
function
(
)
{
var
methodInfo
=
glsDrawTests
.
getMethodInfo
(
this
.
drawMethod
)
;
var
bufferAlignmentBad
=
false
;
var
strideAlignmentBad
=
false
;
for
(
var
ndx
=
0
;
ndx
<
this
.
attribs
.
length
;
+
+
ndx
)
if
(
!
this
.
attribs
[
ndx
]
.
isBufferAligned
(
)
)
bufferAlignmentBad
=
true
;
for
(
var
ndx
=
0
;
ndx
<
this
.
attribs
.
length
;
+
+
ndx
)
if
(
!
this
.
attribs
[
ndx
]
.
isBufferStrideAligned
(
)
)
strideAlignmentBad
=
true
;
if
(
methodInfo
.
indexed
)
{
if
(
this
.
indexStorage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
var
indexSize
=
0
;
if
(
this
.
indexType
=
=
glsDrawTests
.
DrawTestSpec
.
IndexType
.
BYTE
)
indexSize
=
1
;
else
if
(
this
.
indexType
=
=
glsDrawTests
.
DrawTestSpec
.
IndexType
.
SHORT
)
indexSize
=
2
;
else
if
(
this
.
indexType
=
=
glsDrawTests
.
DrawTestSpec
.
IndexType
.
INT
)
indexSize
=
4
;
else
throw
new
Error
(
'
'
)
;
if
(
this
.
indexPointerOffset
%
indexSize
!
=
0
)
bufferAlignmentBad
=
true
;
}
}
if
(
bufferAlignmentBad
)
return
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_OFFSET
;
else
if
(
strideAlignmentBad
)
return
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_STRIDE
;
else
return
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
NONE
;
}
;
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
=
function
(
)
{
this
.
inputType
=
null
;
this
.
outputType
=
null
;
this
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
this
.
usage
=
null
;
this
.
componentCount
=
0
;
this
.
offset
=
0
;
this
.
stride
=
0
;
this
.
normalize
=
false
;
this
.
instanceDivisor
=
0
;
this
.
useDefaultAttribute
=
false
;
this
.
additionalPositionAttribute
=
false
;
}
;
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
.
createAttributeArray
=
function
(
inputType
outputType
storage
usage
componentCount
offset
stride
normalize
instanceDivisor
)
{
var
spec
;
spec
.
inputType
=
inputType
;
spec
.
outputType
=
outputType
;
spec
.
storage
=
storage
;
spec
.
usage
=
usage
;
spec
.
componentCount
=
componentCount
;
spec
.
offset
=
offset
;
spec
.
stride
=
stride
;
spec
.
normalize
=
normalize
;
spec
.
instanceDivisor
=
instanceDivisor
;
spec
.
useDefaultAttribute
=
false
;
return
spec
;
}
;
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
.
createDefaultAttribute
=
function
(
inputType
outputType
componentCount
)
{
assertMsgOptions
(
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
|
|
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
|
|
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
'
Invalid
input
type
'
false
true
)
;
assertMsgOptions
(
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
|
|
componentCount
=
=
4
'
If
not
float
input
type
should
have
4
components
'
false
true
)
;
var
spec
;
spec
.
inputType
=
inputType
;
spec
.
outputType
=
outputType
;
spec
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
usage
=
null
;
spec
.
componentCount
=
componentCount
;
spec
.
offset
=
0
;
spec
.
stride
=
0
;
spec
.
normalize
=
false
;
spec
.
instanceDivisor
=
0
;
spec
.
useDefaultAttribute
=
true
;
return
spec
;
}
;
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
.
prototype
.
hash
=
function
(
)
{
if
(
this
.
useDefaultAttribute
)
{
return
1
*
this
.
inputType
+
7
*
this
.
outputType
+
13
*
this
.
componentCount
;
}
else
{
return
1
*
this
.
inputType
+
2
*
this
.
outputType
+
3
*
this
.
storage
+
5
*
this
.
usage
+
7
*
this
.
componentCount
+
11
*
this
.
offset
+
13
*
this
.
stride
+
17
*
(
this
.
normalize
?
0
:
1
)
+
19
*
this
.
instanceDivisor
;
}
}
;
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
.
prototype
.
valid
=
function
(
)
{
var
inputTypeFloat
=
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
;
var
inputTypeUnsignedInteger
=
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
;
var
inputTypeSignedInteger
=
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
;
var
inputTypePacked
=
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
;
var
outputTypeFloat
=
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
;
var
outputTypeSignedInteger
=
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC2
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
;
var
outputTypeUnsignedInteger
=
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
|
|
this
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
;
if
(
this
.
useDefaultAttribute
)
{
if
(
this
.
inputType
!
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
&
&
this
.
inputType
!
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
&
&
this
.
inputType
!
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
)
return
false
;
if
(
this
.
inputType
!
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
&
&
this
.
componentCount
!
=
4
)
return
false
;
if
(
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
&
&
!
outputTypeSignedInteger
)
return
false
;
if
(
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
&
&
!
outputTypeUnsignedInteger
)
return
false
;
}
if
(
inputTypePacked
&
&
this
.
componentCount
!
=
4
)
return
false
;
if
(
inputTypeFloat
&
&
!
outputTypeFloat
)
return
false
;
if
(
inputTypeUnsignedInteger
&
&
outputTypeSignedInteger
)
return
false
;
if
(
inputTypeSignedInteger
&
&
outputTypeUnsignedInteger
)
return
false
;
if
(
inputTypePacked
&
&
!
outputTypeFloat
)
return
false
;
if
(
this
.
normalize
&
&
!
outputTypeFloat
)
return
false
;
return
true
;
}
;
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
.
prototype
.
isBufferAligned
=
function
(
)
{
var
inputTypePacked
=
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
;
if
(
this
.
storage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
var
dataTypeSize
=
glsDrawTests
.
DrawTestSpec
.
inputTypeSize
(
this
.
inputType
)
;
if
(
inputTypePacked
)
dataTypeSize
=
4
;
if
(
this
.
offset
%
dataTypeSize
!
=
0
)
return
false
;
}
return
true
;
}
;
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
.
prototype
.
isBufferStrideAligned
=
function
(
)
{
var
inputTypePacked
=
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
|
|
this
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
;
if
(
this
.
storage
=
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
{
var
dataTypeSize
=
glsDrawTests
.
DrawTestSpec
.
inputTypeSize
(
this
.
inputType
)
;
if
(
inputTypePacked
)
dataTypeSize
=
4
;
if
(
this
.
stride
%
dataTypeSize
!
=
0
)
return
false
;
}
return
true
;
}
;
glsDrawTests
.
DrawTest
=
function
(
spec
name
desc
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
desc
spec
)
;
this
.
m_renderCtx
=
gl
;
this
.
m_pixelformat
=
new
tcuPixelFormat
.
PixelFormat
(
(
gl
.
getParameter
(
gl
.
RED_BITS
)
)
(
gl
.
getParameter
(
gl
.
GREEN_BITS
)
)
(
gl
.
getParameter
(
gl
.
BLUE_BITS
)
)
(
gl
.
getParameter
(
gl
.
ALPHA_BITS
)
)
)
;
this
.
m_refBuffers
=
null
;
this
.
m_refContext
=
null
;
this
.
m_glesContext
=
null
;
this
.
m_glArrayPack
=
null
;
this
.
m_rrArrayPack
=
null
;
this
.
m_maxDiffRed
=
-
1
;
this
.
m_maxDiffGreen
=
-
1
;
this
.
m_maxDiffBlue
=
-
1
;
this
.
m_specs
=
[
]
;
this
.
m_iteration_descriptions
=
[
]
;
this
.
m_iteration
=
0
;
if
(
spec
)
this
.
addIteration
(
spec
)
;
}
;
glsDrawTests
.
DrawTest
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
glsDrawTests
.
DrawTest
.
prototype
.
constructor
=
glsDrawTests
.
DrawTest
;
glsDrawTests
.
DrawTest
.
prototype
.
addIteration
=
function
(
spec
description
)
{
var
validSpec
=
spec
.
valid
(
)
;
if
(
!
validSpec
)
return
;
this
.
m_specs
.
push
(
spec
)
;
if
(
description
)
this
.
m_iteration_descriptions
.
push
(
description
)
;
else
this
.
m_iteration_descriptions
.
push
(
'
'
)
;
}
;
glsDrawTests
.
DrawTest
.
prototype
.
init
=
function
(
)
{
var
renderTargetWidth
=
Math
.
min
(
glsDrawTests
.
MAX_RENDER_TARGET_SIZE
gl
.
canvas
.
width
)
;
var
renderTargetHeight
=
Math
.
min
(
glsDrawTests
.
MAX_RENDER_TARGET_SIZE
gl
.
canvas
.
height
)
;
var
limits
=
new
sglrReferenceContext
.
ReferenceContextLimits
(
gl
)
;
var
useVao
=
true
;
this
.
m_glesContext
=
new
sglrGLContext
.
GLContext
(
gl
)
;
assertMsgOptions
(
this
.
m_specs
.
length
>
0
'
Specs
is
empty
'
false
true
)
;
this
.
m_refBuffers
=
new
sglrReferenceContext
.
ReferenceContextBuffers
(
this
.
m_pixelformat
0
0
renderTargetWidth
renderTargetHeight
)
;
this
.
m_refContext
=
new
sglrReferenceContext
.
ReferenceContext
(
limits
this
.
m_refBuffers
.
getColorbuffer
(
)
this
.
m_refBuffers
.
getDepthbuffer
(
)
this
.
m_refBuffers
.
getStencilbuffer
(
)
)
;
this
.
m_glArrayPack
=
new
glsDrawTests
.
AttributePack
(
this
.
m_glesContext
[
renderTargetWidth
renderTargetHeight
]
useVao
true
)
;
this
.
m_rrArrayPack
=
new
glsDrawTests
.
AttributePack
(
this
.
m_refContext
[
renderTargetWidth
renderTargetHeight
]
useVao
false
)
;
this
.
m_maxDiffRed
=
Math
.
ceil
(
256
.
0
*
(
15
.
0
/
(
1
<
<
this
.
m_pixelformat
.
redBits
)
)
)
;
this
.
m_maxDiffGreen
=
Math
.
ceil
(
256
.
0
*
(
15
.
0
/
(
1
<
<
this
.
m_pixelformat
.
greenBits
)
)
)
;
this
.
m_maxDiffBlue
=
Math
.
ceil
(
256
.
0
*
(
15
.
0
/
(
1
<
<
this
.
m_pixelformat
.
blueBits
)
)
)
;
}
;
glsDrawTests
.
DrawTest
.
prototype
.
iterate
=
function
(
)
{
var
specNdx
=
Math
.
floor
(
this
.
m_iteration
/
2
)
;
var
drawStep
=
(
this
.
m_iteration
%
2
)
=
=
0
;
var
compareStep
=
(
this
.
m_iteration
%
2
)
=
=
1
;
var
iterateResult
=
(
this
.
m_iteration
+
1
=
=
this
.
m_specs
.
length
*
2
)
?
(
tcuTestCase
.
IterateResult
.
STOP
)
:
(
tcuTestCase
.
IterateResult
.
CONTINUE
)
;
var
spec
=
this
.
m_specs
[
specNdx
]
;
var
updateProgram
=
(
this
.
m_iteration
=
=
0
)
|
|
(
drawStep
&
&
!
glsDrawTests
.
checkSpecsShaderCompatible
(
this
.
m_specs
[
specNdx
]
this
.
m_specs
[
specNdx
-
1
]
)
)
;
if
(
drawStep
&
&
this
.
m_specs
.
length
!
=
1
)
debug
(
'
Iteration
'
+
specNdx
+
'
of
'
+
(
this
.
m_specs
.
length
-
1
)
+
'
:
'
+
this
.
m_iteration_descriptions
[
specNdx
]
)
;
this
.
m_iteration
+
+
;
if
(
drawStep
)
{
var
methodInfo
=
glsDrawTests
.
getMethodInfo
(
spec
.
drawMethod
)
;
var
indexed
=
methodInfo
.
indexed
;
var
instanced
=
methodInfo
.
instanced
;
var
ranged
=
methodInfo
.
ranged
;
var
hasFirst
=
methodInfo
.
first
;
var
primitiveElementCount
=
glsDrawTests
.
getElementCount
(
spec
.
primitive
spec
.
primitiveCount
)
;
var
indexMin
=
(
ranged
)
?
(
spec
.
indexMin
)
:
(
0
)
;
var
firstAddition
=
(
hasFirst
)
?
(
spec
.
first
)
:
(
0
)
;
var
elementCount
=
primitiveElementCount
+
indexMin
+
firstAddition
;
var
maxElementIndex
=
primitiveElementCount
+
indexMin
+
firstAddition
-
1
;
var
indexMax
=
Math
.
max
(
0
(
ranged
)
?
(
deMath
.
clamp
(
spec
.
indexMax
0
maxElementIndex
)
)
:
(
maxElementIndex
)
)
;
var
coordScale
=
this
.
getCoordScale
(
spec
)
;
var
colorScale
=
this
.
getColorScale
(
spec
)
;
var
nullAttribValue
=
[
]
;
bufferedLogToConsole
(
spec
.
getMultilineDesc
(
)
)
;
this
.
m_glArrayPack
.
clearArrays
(
)
;
this
.
m_rrArrayPack
.
clearArrays
(
)
;
var
seed
;
var
indexElementSize
;
var
indexArraySize
;
var
indexArray
;
var
indexPointer
;
var
glArray
;
var
rrArray
;
if
(
indexed
)
{
seed
=
spec
.
hash
(
)
;
indexElementSize
=
glsDrawTests
.
DrawTestSpec
.
indexTypeSize
(
spec
.
indexType
)
;
indexArraySize
=
spec
.
indexPointerOffset
+
indexElementSize
*
elementCount
;
indexArray
=
glsDrawTests
.
RandomArrayGenerator
.
generateIndices
(
seed
elementCount
spec
.
indexType
spec
.
indexPointerOffset
indexMin
indexMax
)
;
indexPointer
=
indexArray
.
subarray
(
spec
.
indexPointerOffset
)
;
glArray
=
new
glsDrawTests
.
AttributeArray
(
spec
.
indexStorage
this
.
m_glesContext
)
;
rrArray
=
new
glsDrawTests
.
AttributeArray
(
spec
.
indexStorage
this
.
m_refContext
)
;
glArray
.
data
(
glsDrawTests
.
DrawTestSpec
.
Target
.
ELEMENT_ARRAY
indexArraySize
indexArray
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
)
;
rrArray
.
data
(
glsDrawTests
.
DrawTestSpec
.
Target
.
ELEMENT_ARRAY
indexArraySize
indexArray
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
)
;
indexArray
=
null
;
}
for
(
var
attribNdx
=
0
;
attribNdx
<
spec
.
attribs
.
length
;
attribNdx
+
+
)
{
var
attribSpec
=
spec
.
attribs
[
attribNdx
]
;
var
isPositionAttr
=
(
attribNdx
=
=
0
)
|
|
(
attribSpec
.
additionalPositionAttribute
)
;
if
(
attribSpec
.
useDefaultAttribute
)
{
seed
=
10
*
attribSpec
.
hash
(
)
+
100
*
spec
.
hash
(
)
+
attribNdx
;
var
attribValue
=
glsDrawTests
.
RandomArrayGenerator
.
generateAttributeValue
(
seed
attribSpec
.
inputType
)
;
this
.
m_glArrayPack
.
newArray
(
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
;
this
.
m_rrArrayPack
.
newArray
(
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
;
this
.
m_glArrayPack
.
getArray
(
attribNdx
)
.
setupArray
(
false
0
attribSpec
.
componentCount
attribSpec
.
inputType
attribSpec
.
outputType
false
0
0
attribValue
isPositionAttr
)
;
this
.
m_rrArrayPack
.
getArray
(
attribNdx
)
.
setupArray
(
false
0
attribSpec
.
componentCount
attribSpec
.
inputType
attribSpec
.
outputType
false
0
0
attribValue
isPositionAttr
)
;
}
else
{
seed
=
attribSpec
.
hash
(
)
+
100
*
spec
.
hash
(
)
+
attribNdx
;
var
elementSize
=
attribSpec
.
componentCount
*
glsDrawTests
.
DrawTestSpec
.
inputTypeSize
(
attribSpec
.
inputType
)
;
var
stride
=
(
attribSpec
.
stride
=
=
0
)
?
(
elementSize
)
:
(
attribSpec
.
stride
)
;
var
evaluatedElementCount
=
(
instanced
&
&
attribSpec
.
instanceDivisor
>
0
)
?
(
spec
.
instanceCount
/
attribSpec
.
instanceDivisor
+
1
)
:
(
elementCount
)
;
var
referencedElementCount
=
(
ranged
)
?
(
Math
.
max
(
evaluatedElementCount
spec
.
indexMax
+
1
)
)
:
(
evaluatedElementCount
)
;
var
bufferSize
=
attribSpec
.
offset
+
stride
*
(
referencedElementCount
-
1
)
+
elementSize
;
var
data
=
glsDrawTests
.
RandomArrayGenerator
.
createArray
(
seed
referencedElementCount
attribSpec
.
componentCount
attribSpec
.
offset
stride
attribSpec
.
inputType
indexed
?
0
:
spec
.
first
spec
.
primitive
indexed
?
indexPointer
:
null
indexElementSize
)
;
this
.
m_glArrayPack
.
newArray
(
attribSpec
.
storage
)
;
this
.
m_rrArrayPack
.
newArray
(
attribSpec
.
storage
)
;
this
.
m_glArrayPack
.
getArray
(
attribNdx
)
.
data
(
glsDrawTests
.
DrawTestSpec
.
Target
.
ARRAY
bufferSize
data
attribSpec
.
usage
)
;
this
.
m_rrArrayPack
.
getArray
(
attribNdx
)
.
data
(
glsDrawTests
.
DrawTestSpec
.
Target
.
ARRAY
bufferSize
data
attribSpec
.
usage
)
;
this
.
m_glArrayPack
.
getArray
(
attribNdx
)
.
setupArray
(
true
attribSpec
.
offset
attribSpec
.
componentCount
attribSpec
.
inputType
attribSpec
.
outputType
attribSpec
.
normalize
attribSpec
.
stride
attribSpec
.
instanceDivisor
nullAttribValue
isPositionAttr
)
;
this
.
m_rrArrayPack
.
getArray
(
attribNdx
)
.
setupArray
(
true
attribSpec
.
offset
attribSpec
.
componentCount
attribSpec
.
inputType
attribSpec
.
outputType
attribSpec
.
normalize
attribSpec
.
stride
attribSpec
.
instanceDivisor
nullAttribValue
isPositionAttr
)
;
data
=
null
;
}
}
if
(
updateProgram
)
{
this
.
m_glArrayPack
.
updateProgram
(
)
;
this
.
m_rrArrayPack
.
updateProgram
(
)
;
}
var
ctype
;
try
{
if
(
indexed
)
{
this
.
m_glArrayPack
.
render
(
spec
.
primitive
spec
.
drawMethod
0
primitiveElementCount
spec
.
indexType
spec
.
indexPointerOffset
spec
.
indexMin
spec
.
indexMax
spec
.
instanceCount
coordScale
colorScale
glArray
)
;
this
.
m_rrArrayPack
.
render
(
spec
.
primitive
spec
.
drawMethod
0
primitiveElementCount
spec
.
indexType
spec
.
indexPointerOffset
spec
.
indexMin
spec
.
indexMax
spec
.
instanceCount
coordScale
colorScale
rrArray
)
;
}
else
{
this
.
m_glArrayPack
.
render
(
spec
.
primitive
spec
.
drawMethod
spec
.
first
primitiveElementCount
null
0
0
0
spec
.
instanceCount
coordScale
colorScale
null
)
;
this
.
m_rrArrayPack
.
render
(
spec
.
primitive
spec
.
drawMethod
spec
.
first
primitiveElementCount
null
0
0
0
spec
.
instanceCount
coordScale
colorScale
null
)
;
}
}
catch
(
err
)
{
if
(
err
instanceof
wtu
.
GLErrorException
)
{
ctype
=
spec
.
isCompatibilityTest
(
)
;
bufferedLogToConsole
(
'
Got
error
:
'
+
err
.
message
)
;
if
(
ctype
=
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_OFFSET
)
checkMessage
(
false
'
Failed
to
draw
with
unaligned
buffers
.
'
)
;
else
if
(
ctype
=
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_STRIDE
)
checkMessage
(
false
'
Failed
to
draw
with
unaligned
stride
.
'
)
;
else
throw
err
;
}
}
}
else
if
(
compareStep
)
{
if
(
!
this
.
compare
(
spec
.
primitive
)
)
{
ctype
=
spec
.
isCompatibilityTest
(
)
;
if
(
ctype
=
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_OFFSET
)
checkMessage
(
false
'
Failed
to
draw
with
unaligned
buffers
.
'
)
;
else
if
(
ctype
=
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_STRIDE
)
checkMessage
(
false
'
Failed
to
draw
with
unaligned
stride
.
'
)
;
else
testFailedOptions
(
'
Image
comparison
failed
.
'
false
)
;
return
iterateResult
;
}
}
else
{
testFailedOptions
(
'
Image
comparison
failed
.
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
if
(
iterateResult
=
=
tcuTestCase
.
IterateResult
.
STOP
)
testPassed
(
'
'
)
;
return
iterateResult
;
}
;
glsDrawTests
.
PrimitiveClass
=
{
POINT
:
0
LINE
:
1
TRIANGLE
:
2
}
;
glsDrawTests
.
getDrawPrimitiveClass
=
function
(
primitiveType
)
{
switch
(
primitiveType
)
{
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
:
return
glsDrawTests
.
PrimitiveClass
.
POINT
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINES
:
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_STRIP
:
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_LOOP
:
return
glsDrawTests
.
PrimitiveClass
.
LINE
;
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
:
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
:
case
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
:
return
glsDrawTests
.
PrimitiveClass
.
TRIANGLE
;
default
:
throw
new
Error
(
'
Invalid
primitive
type
'
)
;
}
}
;
glsDrawTests
.
compareUintRGB8
=
function
(
c1
c2
threshold
)
{
return
(
Math
.
abs
(
(
(
c1
>
>
16
)
&
0xff
)
-
(
(
c2
>
>
16
)
&
0xff
)
)
<
=
threshold
[
0
]
&
&
Math
.
abs
(
(
(
c1
>
>
8
)
&
0xff
)
-
(
(
c2
>
>
8
)
&
0xff
)
)
<
=
threshold
[
1
]
&
&
Math
.
abs
(
(
c1
&
0xff
)
-
(
c2
&
0xff
)
)
<
=
threshold
[
2
]
)
;
}
;
glsDrawTests
.
isEdgeTripletComponent
=
function
(
c1
c2
c3
renderTargetDifference
)
{
var
roundingDifference
=
2
*
renderTargetDifference
;
var
d1
=
c2
-
c1
;
var
d2
=
c3
-
c2
;
var
rampDiff
=
Math
.
abs
(
d2
-
d1
)
;
return
rampDiff
>
roundingDifference
;
}
;
glsDrawTests
.
isEdgeTriplet
=
function
(
c1
c2
c3
renderTargetThreshold
)
{
var
b1
=
c1
=
=
0x000000
;
var
b2
=
c2
=
=
0x000000
;
var
b3
=
c3
=
=
0x000000
;
if
(
(
b1
&
&
b2
&
&
b3
)
=
=
false
&
&
(
b1
|
|
b2
|
|
b3
)
=
=
true
)
return
true
;
if
(
b1
&
&
b2
&
&
b3
)
return
false
;
assertMsgOptions
(
!
b1
&
&
!
b2
&
&
!
b3
'
All
colors
with
coverage
'
false
true
)
;
return
glsDrawTests
.
isEdgeTripletComponent
(
(
c1
>
>
16
)
&
&
0xff
(
c2
>
>
16
)
&
&
0xff
(
c3
>
>
16
)
&
&
0xff
renderTargetThreshold
[
0
]
)
|
|
glsDrawTests
.
isEdgeTripletComponent
(
(
c1
>
>
8
)
&
&
0xff
(
c2
>
>
8
)
&
&
0xff
(
c3
>
>
8
)
&
&
0xff
renderTargetThreshold
[
1
]
)
|
|
glsDrawTests
.
isEdgeTripletComponent
(
c1
&
&
0xff
c2
&
&
0xff
c3
&
&
0xff
renderTargetThreshold
[
2
]
)
;
}
;
glsDrawTests
.
pixelNearEdge
=
function
(
x
y
ref
renderTargetThreshold
)
{
assertMsgOptions
(
x
>
=
1
&
&
x
<
=
ref
.
getWidth
(
)
-
2
'
The
pixel
was
on
the
edge
'
false
true
)
;
assertMsgOptions
(
y
>
=
1
&
&
y
<
=
ref
.
getHeight
(
)
-
2
'
The
pixel
was
on
the
edge
'
false
true
)
;
var
c1
;
var
c2
;
var
c3
;
for
(
var
dy
=
-
1
;
dy
<
2
;
+
+
dy
)
{
c1
=
ref
.
getPixelUintRGB8
(
x
-
1
y
+
dy
)
;
c2
=
ref
.
getPixelUintRGB8
(
x
y
+
dy
)
;
c3
=
ref
.
getPixelUintRGB8
(
x
+
1
y
+
dy
)
;
if
(
glsDrawTests
.
isEdgeTriplet
(
c1
c2
c3
renderTargetThreshold
)
)
return
true
;
}
for
(
var
dx
=
-
1
;
dx
<
2
;
+
+
dx
)
{
c1
=
ref
.
getPixelUintRGB8
(
x
+
dx
y
-
1
)
;
c2
=
ref
.
getPixelUintRGB8
(
x
+
dx
y
)
;
c3
=
ref
.
getPixelUintRGB8
(
x
+
dx
y
+
1
)
;
if
(
glsDrawTests
.
isEdgeTriplet
(
c1
c2
c3
renderTargetThreshold
)
)
return
true
;
}
return
false
;
}
;
glsDrawTests
.
getVisualizationGrayscaleColorUintRGB8
=
function
(
c
)
{
if
(
c
=
=
0x000000
)
return
0
;
else
return
50
+
Math
.
floor
(
(
(
(
c
>
>
16
)
&
0xff
)
+
(
(
c
>
>
8
)
&
0xff
)
+
(
c
&
0xff
)
)
/
8
)
;
}
;
glsDrawTests
.
pixelNearLineIntersection
=
function
(
x
y
target
)
{
assertMsgOptions
(
x
>
=
1
&
&
x
<
=
target
.
getWidth
(
)
-
2
'
Pixel
is
in
the
edge
'
false
true
)
;
assertMsgOptions
(
y
>
=
1
&
&
y
<
=
target
.
getHeight
(
)
-
2
'
Pixel
is
in
the
edge
'
false
true
)
;
var
coveredPixels
=
0
;
for
(
var
dy
=
-
1
;
dy
<
2
;
dy
+
+
)
for
(
var
dx
=
-
1
;
dx
<
2
;
dx
+
+
)
{
var
targetCoverage
=
target
.
getPixelUintRGB8
(
x
+
dx
y
+
dy
)
;
if
(
targetCoverage
)
{
+
+
coveredPixels
;
if
(
coveredPixels
>
=
4
)
return
true
;
}
}
return
false
;
}
;
glsDrawTests
.
pixelNeighborhoodContainsColor
=
function
(
target
x
y
color
compareThreshold
)
{
assertMsgOptions
(
x
>
=
1
&
&
x
<
=
target
.
getWidth
(
)
-
2
'
Pixel
is
in
the
edge
'
false
true
)
;
assertMsgOptions
(
y
>
=
1
&
&
y
<
=
target
.
getHeight
(
)
-
2
'
Pixel
is
in
the
edge
'
false
true
)
;
for
(
var
dy
=
-
1
;
dy
<
2
;
dy
+
+
)
for
(
var
dx
=
-
1
;
dx
<
2
;
dx
+
+
)
{
if
(
glsDrawTests
.
compareUintRGB8
(
color
target
.
getPixelUintRGB8
(
x
+
dx
y
+
dy
)
compareThreshold
)
)
return
true
;
}
return
false
;
}
;
glsDrawTests
.
pixelNeighborhoodContainsCoverage
=
function
(
target
x
y
coverage
)
{
assertMsgOptions
(
x
>
=
1
&
&
x
<
=
target
.
getWidth
(
)
-
2
'
Pixel
is
in
the
edge
'
false
true
)
;
assertMsgOptions
(
y
>
=
1
&
&
y
<
=
target
.
getHeight
(
)
-
2
'
Pixel
is
in
the
edge
'
false
true
)
;
for
(
var
dy
=
-
1
;
dy
<
2
;
dy
+
+
)
for
(
var
dx
=
-
1
;
dx
<
2
;
dx
+
+
)
{
var
targetCmpCoverage
=
target
.
getPixelUintRGB8
(
x
+
dx
y
+
dy
)
!
=
0x000000
;
if
(
targetCmpCoverage
=
=
coverage
)
return
true
;
}
return
false
;
}
;
glsDrawTests
.
edgeRelaxedImageCompare
=
function
(
imageSetName
imageSetDesc
reference
result
compareThreshold
renderTargetThreshold
maxAllowedInvalidPixels
)
{
assertMsgOptions
(
result
.
getWidth
(
)
=
=
reference
.
getWidth
(
)
&
&
result
.
getHeight
(
)
=
=
reference
.
getHeight
(
)
'
Reference
and
result
images
have
different
dimensions
'
false
true
)
;
var
green
=
[
0
255
0
255
]
;
var
errorColor
=
[
255
0
0
255
]
;
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
errorMask
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
numFailingPixels
=
0
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
0
0
0
width
1
1
)
.
clear
(
green
)
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
0
height
-
1
0
width
1
1
)
.
clear
(
green
)
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
0
0
0
1
height
1
)
.
clear
(
green
)
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
width
-
1
0
0
1
height
1
)
.
clear
(
green
)
;
for
(
var
y
=
1
;
y
<
height
-
1
;
+
+
y
)
for
(
var
x
=
1
;
x
<
width
-
1
;
+
+
x
)
{
var
refPixel
=
reference
.
getPixelUintRGB8
(
x
y
)
;
var
screenPixel
=
result
.
getPixelUintRGB8
(
x
y
)
;
var
isOkReferencePixel
=
glsDrawTests
.
pixelNeighborhoodContainsColor
(
result
x
y
refPixel
compareThreshold
)
;
var
isOkScreenPixel
=
glsDrawTests
.
pixelNeighborhoodContainsColor
(
reference
x
y
screenPixel
compareThreshold
)
;
if
(
isOkScreenPixel
&
&
isOkReferencePixel
)
{
var
grayscaleValue
=
glsDrawTests
.
getVisualizationGrayscaleColorUintRGB8
(
screenPixel
)
;
errorMask
.
getAccess
(
)
.
setPixel
(
[
grayscaleValue
/
255
1
grayscaleValue
/
255
1
]
x
y
)
;
}
else
if
(
!
glsDrawTests
.
pixelNearEdge
(
x
y
reference
renderTargetThreshold
)
)
{
errorMask
.
getAccess
(
)
.
setPixel
(
deMath
.
scale
(
errorColor
1
/
255
)
x
y
)
;
+
+
numFailingPixels
;
}
else
{
var
referenceCoverage
=
refPixel
!
=
0x000000
;
var
screenCoverage
=
screenPixel
!
=
0x000000
;
var
isOkReferenceCoverage
=
glsDrawTests
.
pixelNeighborhoodContainsCoverage
(
result
x
y
referenceCoverage
)
;
var
isOkScreenCoverage
=
glsDrawTests
.
pixelNeighborhoodContainsCoverage
(
reference
x
y
screenCoverage
)
;
if
(
isOkScreenCoverage
&
&
isOkReferenceCoverage
)
{
var
grayscaleValue
=
glsDrawTests
.
getVisualizationGrayscaleColorUintRGB8
(
screenPixel
)
;
errorMask
.
getAccess
(
)
.
setPixel
(
[
grayscaleValue
/
255
1
grayscaleValue
/
255
1
]
x
y
)
;
}
else
{
errorMask
.
getAccess
(
)
.
setPixel
(
deMath
.
scale
(
errorColor
1
/
255
)
x
y
)
;
+
+
numFailingPixels
;
}
}
}
bufferedLogToConsole
(
'
Comparing
images
:
<
/
br
>
'
+
'
<
span
>
<
/
span
>
allowed
deviation
in
pixel
positions
=
1
<
/
br
>
'
+
'
<
span
>
<
/
span
>
number
of
allowed
invalid
pixels
=
'
+
maxAllowedInvalidPixels
+
'
<
/
br
>
'
+
'
<
span
>
<
/
span
>
number
of
invalid
pixels
=
'
+
numFailingPixels
)
;
if
(
numFailingPixels
>
maxAllowedInvalidPixels
)
{
debug
(
'
Image
comparison
failed
.
Color
threshold
=
(
'
+
compareThreshold
[
0
]
+
'
'
+
compareThreshold
[
1
]
+
'
'
+
compareThreshold
[
2
]
+
'
)
'
)
;
tcuImageCompare
.
displayImages
(
result
.
getAccess
(
)
reference
.
getAccess
(
)
errorMask
.
getAccess
(
)
)
;
return
false
;
}
else
{
return
true
;
}
}
;
glsDrawTests
.
intersectionRelaxedLineImageCompare
=
function
(
imageSetName
imageSetDesc
reference
result
compareThreshold
maxAllowedInvalidPixels
)
{
assertMsgOptions
(
result
.
getWidth
(
)
=
=
reference
.
getWidth
(
)
&
&
result
.
getHeight
(
)
=
=
reference
.
getHeight
(
)
'
Reference
and
result
images
have
different
dimensions
'
false
true
)
;
var
green
=
[
0
255
0
255
]
;
var
errorColor
=
[
255
0
0
255
]
;
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
errorMask
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
numFailingPixels
=
0
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
0
0
0
width
1
1
)
.
clear
(
green
)
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
0
height
-
1
0
width
1
1
)
.
clear
(
green
)
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
0
0
0
1
height
1
)
.
clear
(
green
)
;
tcuTextureUtil
.
getSubregion
(
errorMask
.
getAccess
(
)
width
-
1
0
0
1
height
1
)
.
clear
(
green
)
;
for
(
var
y
=
1
;
y
<
height
-
1
;
+
+
y
)
for
(
var
x
=
1
;
x
<
width
-
1
;
+
+
x
)
{
var
refPixel
=
reference
.
getPixelUintRGB8
(
x
y
)
;
var
screenPixel
=
result
.
getPixelUintRGB8
(
x
y
)
;
var
isOkScreenPixel
=
glsDrawTests
.
pixelNeighborhoodContainsColor
(
reference
x
y
screenPixel
compareThreshold
)
;
var
isOkReferencePixel
=
glsDrawTests
.
pixelNeighborhoodContainsColor
(
result
x
y
refPixel
compareThreshold
)
;
var
grayscaleValue
;
if
(
isOkScreenPixel
&
&
isOkReferencePixel
)
{
grayscaleValue
=
glsDrawTests
.
getVisualizationGrayscaleColorUintRGB8
(
screenPixel
)
;
errorMask
.
getAccess
(
)
.
setPixel
(
[
grayscaleValue
/
255
1
grayscaleValue
/
255
1
]
x
y
)
;
}
else
if
(
!
glsDrawTests
.
pixelNearLineIntersection
(
x
y
reference
)
&
&
!
glsDrawTests
.
pixelNearLineIntersection
(
x
y
result
)
)
{
errorMask
.
getAccess
(
)
.
setPixel
(
deMath
.
scale
(
errorColor
1
/
255
)
x
y
)
;
+
+
numFailingPixels
;
}
else
{
var
referenceCoverage
=
refPixel
!
=
0x000000
;
var
screenCoverage
=
screenPixel
!
=
0x000000
;
var
isOkScreenCoverage
=
glsDrawTests
.
pixelNeighborhoodContainsCoverage
(
reference
x
y
screenCoverage
)
;
var
isOkReferenceCoverage
=
glsDrawTests
.
pixelNeighborhoodContainsCoverage
(
result
x
y
referenceCoverage
)
;
if
(
isOkScreenCoverage
&
&
isOkReferenceCoverage
)
{
grayscaleValue
=
glsDrawTests
.
getVisualizationGrayscaleColorUintRGB8
(
screenPixel
)
;
errorMask
.
getAccess
(
)
.
setPixel
(
[
grayscaleValue
/
255
1
grayscaleValue
/
255
1
]
x
y
)
;
}
else
{
errorMask
.
getAccess
(
)
.
setPixel
(
deMath
.
scale
(
errorColor
1
/
255
)
x
y
)
;
+
+
numFailingPixels
;
}
}
}
bufferedLogToConsole
(
'
Comparing
images
:
<
/
br
>
'
+
'
<
span
>
<
/
span
>
allowed
deviation
in
pixel
positions
=
1
<
/
br
>
'
+
'
<
span
>
<
/
span
>
number
of
allowed
invalid
pixels
=
'
+
maxAllowedInvalidPixels
+
'
<
/
br
>
'
+
'
<
span
>
<
/
span
>
number
of
invalid
pixels
=
'
+
numFailingPixels
)
;
if
(
numFailingPixels
>
maxAllowedInvalidPixels
)
{
debug
(
'
Image
comparison
failed
.
Color
threshold
=
(
'
+
compareThreshold
[
0
]
+
'
'
+
compareThreshold
[
1
]
+
'
'
+
compareThreshold
[
2
]
+
'
)
'
)
;
tcuImageCompare
.
displayImages
(
result
.
getAccess
(
)
reference
.
getAccess
(
)
errorMask
.
getAccess
(
)
)
;
return
false
;
}
else
{
return
true
;
}
}
;
glsDrawTests
.
DrawTest
.
prototype
.
compare
=
function
(
primitiveType
)
{
var
ref
=
this
.
m_rrArrayPack
.
getSurface
(
)
;
var
screen
=
this
.
m_glArrayPack
.
getSurface
(
)
;
if
(
(
gl
.
getParameter
(
gl
.
SAMPLES
)
)
>
1
)
{
bufferedLogToConsole
(
'
Warning
:
Comparision
of
result
from
multisample
render
targets
are
not
as
strict
as
without
multisampling
.
Might
produce
false
positives
!
'
)
;
return
tcuImageCompare
.
fuzzyCompare
(
'
Compare
Results
'
'
Compare
Results
'
ref
.
getAccess
(
)
screen
.
getAccess
(
)
0
.
3
tcuImageCompare
.
CompareLogMode
.
RESULT
)
;
}
else
{
var
primitiveClass
=
glsDrawTests
.
getDrawPrimitiveClass
(
primitiveType
)
;
switch
(
primitiveClass
)
{
case
glsDrawTests
.
PrimitiveClass
.
POINT
:
{
var
maxAllowedInvalidPixelsWithPoints
=
0
;
return
tcuImageCompare
.
intThresholdPositionDeviationErrorThresholdCompare
(
'
CompareResult
'
'
Result
of
rendering
'
ref
.
getAccess
(
)
screen
.
getAccess
(
)
[
this
.
m_maxDiffRed
this
.
m_maxDiffGreen
this
.
m_maxDiffBlue
256
]
[
1
1
0
]
true
maxAllowedInvalidPixelsWithPoints
)
;
}
case
glsDrawTests
.
PrimitiveClass
.
LINE
:
{
var
maxAllowedInvalidPixelsWithLines
=
15
;
return
glsDrawTests
.
intersectionRelaxedLineImageCompare
(
'
CompareResult
'
'
Result
of
rendering
'
ref
screen
[
this
.
m_maxDiffRed
this
.
m_maxDiffGreen
this
.
m_maxDiffBlue
]
maxAllowedInvalidPixelsWithLines
)
;
}
case
glsDrawTests
.
PrimitiveClass
.
TRIANGLE
:
{
var
maxAllowedInvalidPixelsWithTriangles
=
10
;
var
renderTargetThreshold
=
[
3
3
3
3
]
;
return
glsDrawTests
.
edgeRelaxedImageCompare
(
'
CompareResult
'
'
Result
of
rendering
'
ref
screen
[
this
.
m_maxDiffRed
this
.
m_maxDiffGreen
this
.
m_maxDiffBlue
]
renderTargetThreshold
maxAllowedInvalidPixelsWithTriangles
)
;
}
default
:
throw
new
Error
(
'
Invalid
primitive
class
'
)
;
}
}
}
;
glsDrawTests
.
DrawTest
.
prototype
.
getCoordScale
=
function
(
spec
)
{
var
maxValue
=
1
.
0
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
spec
.
attribs
.
length
;
arrayNdx
+
+
)
{
var
attribSpec
=
spec
.
attribs
[
arrayNdx
]
;
var
isPositionAttr
=
(
arrayNdx
=
=
0
)
|
|
(
attribSpec
.
additionalPositionAttribute
)
;
var
attrMaxValue
=
0
;
if
(
!
isPositionAttr
)
continue
;
if
(
attribSpec
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
)
{
if
(
attribSpec
.
normalize
)
attrMaxValue
+
=
1
.
0
;
else
attrMaxValue
+
=
1024
.
0
;
}
else
if
(
attribSpec
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
)
{
if
(
attribSpec
.
normalize
)
attrMaxValue
+
=
1
.
0
;
else
attrMaxValue
+
=
512
.
0
;
}
else
{
var
max
=
glsDrawTests
.
GLValue
.
getMaxValue
(
attribSpec
.
inputType
)
.
getValue
(
)
;
attrMaxValue
+
=
(
attribSpec
.
normalize
&
&
!
glsDrawTests
.
inputTypeIsFloatType
(
attribSpec
.
inputType
)
)
?
(
1
.
0
)
:
(
max
*
1
.
1
)
;
}
if
(
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
|
|
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
|
|
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
|
|
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
|
|
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
|
|
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
)
attrMaxValue
*
=
2
;
maxValue
+
=
attrMaxValue
;
}
return
1
.
0
/
maxValue
;
}
;
glsDrawTests
.
DrawTest
.
prototype
.
getColorScale
=
function
(
spec
)
{
var
colorScale
=
1
.
0
;
for
(
var
arrayNdx
=
1
;
arrayNdx
<
spec
.
attribs
.
length
;
arrayNdx
+
+
)
{
var
attribSpec
=
spec
.
attribs
[
arrayNdx
]
;
var
isPositionAttr
=
(
arrayNdx
=
=
0
)
|
|
(
attribSpec
.
additionalPositionAttribute
)
;
if
(
isPositionAttr
)
continue
;
if
(
attribSpec
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
)
{
if
(
!
attribSpec
.
normalize
)
colorScale
*
=
1
.
0
/
1024
.
0
;
}
else
if
(
attribSpec
.
inputType
=
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
)
{
if
(
!
attribSpec
.
normalize
)
colorScale
*
=
1
.
0
/
512
.
0
;
}
else
{
var
max
=
glsDrawTests
.
GLValue
.
getMaxValue
(
attribSpec
.
inputType
)
.
toFloat
(
)
;
colorScale
*
=
(
attribSpec
.
normalize
&
&
!
glsDrawTests
.
inputTypeIsFloatType
(
attribSpec
.
inputType
)
?
1
.
0
:
(
1
.
0
/
max
)
)
;
if
(
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
|
|
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
|
|
attribSpec
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
)
colorScale
*
=
(
attribSpec
.
normalize
&
&
!
glsDrawTests
.
inputTypeIsFloatType
(
attribSpec
.
inputType
)
?
1
.
0
:
1
.
0
/
max
)
;
}
}
return
colorScale
;
}
;
}
)
;
