'
use
strict
'
;
goog
.
provide
(
'
modules
.
shared
.
glsShaderLibraryCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluDrawUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
glsShaderLibraryCase
=
modules
.
shared
.
glsShaderLibraryCase
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluDrawUtil
=
framework
.
opengl
.
gluDrawUtil
;
glsShaderLibraryCase
.
VIEWPORT_WIDTH
=
128
;
glsShaderLibraryCase
.
VIEWPORT_HEIGHT
=
128
;
glsShaderLibraryCase
.
expectResult
=
{
EXPECT_PASS
:
0
EXPECT_COMPILE_FAIL
:
1
EXPECT_LINK_FAIL
:
2
EXPECT_COMPILE_LINK_FAIL
:
3
EXPECT_VALIDATION_FAIL
:
4
EXPECT_BUILD_SUCCESSFUL
:
5
}
;
glsShaderLibraryCase
.
caseType
=
{
CASETYPE_COMPLETE
:
0
CASETYPE_VERTEX_ONLY
:
1
CASETYPE_FRAGMENT_ONLY
:
2
}
;
glsShaderLibraryCase
.
targetType
=
{
PROGRAM
:
0
PIPELINE
:
1
}
;
glsShaderLibraryCase
.
shaderCase
=
{
STORAGE_INPUT
:
0
STORAGE_OUTPUT
:
1
STORAGE_UNIFORM
:
2
}
;
glsShaderLibraryCase
.
usesShaderInoutQualifiers
=
function
(
version
)
{
switch
(
version
)
{
case
'
100
'
:
case
'
130
'
:
case
'
140
'
:
case
'
150
'
:
return
false
;
default
:
return
true
;
}
}
;
glsShaderLibraryCase
.
supportsFragmentHighp
=
function
(
version
)
{
return
version
!
=
=
'
100
'
;
}
;
glsShaderLibraryCase
.
genVertexShader
=
function
(
valueBlock
)
{
var
res
=
'
'
;
var
state
=
tcuTestCase
.
runner
;
var
usesInout
=
glsShaderLibraryCase
.
usesShaderInoutQualifiers
(
state
.
currentTest
.
spec
.
targetVersion
)
;
var
vtxIn
=
usesInout
?
'
in
'
:
'
attribute
'
;
var
vtxOut
=
usesInout
?
'
out
'
:
'
varying
'
;
res
+
=
'
#
version
'
+
state
.
currentTest
.
spec
.
targetVersion
+
'
\
n
'
;
res
+
=
'
precision
highp
float
;
\
n
'
;
res
+
=
'
precision
highp
int
;
\
n
'
;
res
+
=
'
\
n
'
;
res
+
=
vtxIn
+
'
highp
vec4
dEQP_Position
;
\
n
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_INPUT
)
{
var
floatType
=
gluShaderUtil
.
getDataTypeFloatScalars
(
val
.
dataType
)
;
res
+
=
vtxIn
+
'
'
+
floatType
+
'
a_
'
+
val
.
valueName
+
'
;
\
n
'
;
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
res
+
=
vtxOut
+
'
'
+
floatType
+
'
'
+
val
.
valueName
+
'
;
\
n
'
;
else
res
+
=
vtxOut
+
'
'
+
floatType
+
'
v_
'
+
val
.
valueName
+
'
;
\
n
'
;
}
}
res
+
=
'
\
n
'
;
res
+
=
'
void
main
(
)
\
n
'
;
res
+
=
'
{
\
n
'
;
res
+
=
'
\
tgl_Position
=
dEQP_Position
;
\
n
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_INPUT
)
{
var
name
=
val
.
valueName
;
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
res
+
=
'
\
t
'
+
name
+
'
=
a_
'
+
name
+
'
;
\
n
'
;
else
res
+
=
'
\
tv_
'
+
name
+
'
=
a_
'
+
name
+
'
;
\
n
'
;
}
}
res
+
=
'
}
\
n
'
;
return
res
;
}
;
glsShaderLibraryCase
.
genCompareFunctions
=
function
(
valueBlock
useFloatTypes
)
{
var
cmpTypeFound
=
{
}
;
var
stream
=
'
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_OUTPUT
)
cmpTypeFound
[
gluShaderUtil
.
getDataTypeName
(
val
.
dataType
)
]
=
true
;
}
if
(
useFloatTypes
)
{
if
(
cmpTypeFound
[
'
bool
'
]
)
stream
+
=
'
bool
isOk
(
float
a
bool
b
)
{
return
(
(
a
>
0
.
5
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
bvec2
'
]
)
stream
+
=
'
bool
isOk
(
vec2
a
bvec2
b
)
{
return
(
greaterThan
(
a
vec2
(
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
bvec3
'
]
)
stream
+
=
'
bool
isOk
(
vec3
a
bvec3
b
)
{
return
(
greaterThan
(
a
vec3
(
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
bvec4
'
]
)
stream
+
=
'
bool
isOk
(
vec4
a
bvec4
b
)
{
return
(
greaterThan
(
a
vec4
(
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
int
'
]
)
stream
+
=
'
bool
isOk
(
float
a
int
b
)
{
float
atemp
=
a
+
0
.
5
;
return
(
float
(
b
)
<
=
atemp
&
&
atemp
<
=
float
(
b
+
1
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
ivec2
'
]
)
stream
+
=
'
bool
isOk
(
vec2
a
ivec2
b
)
{
return
(
ivec2
(
floor
(
a
+
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
ivec3
'
]
)
stream
+
=
'
bool
isOk
(
vec3
a
ivec3
b
)
{
return
(
ivec3
(
floor
(
a
+
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
ivec4
'
]
)
stream
+
=
'
bool
isOk
(
vec4
a
ivec4
b
)
{
return
(
ivec4
(
floor
(
a
+
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uint
'
]
)
stream
+
=
'
bool
isOk
(
float
a
uint
b
)
{
float
atemp
=
a
+
0
.
5
;
return
(
float
(
b
)
<
=
atemp
&
&
atemp
<
=
float
(
b
+
1u
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uvec2
'
]
)
stream
+
=
'
bool
isOk
(
vec2
a
uvec2
b
)
{
return
(
uvec2
(
floor
(
a
+
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uvec3
'
]
)
stream
+
=
'
bool
isOk
(
vec3
a
uvec3
b
)
{
return
(
uvec3
(
floor
(
a
+
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uvec4
'
]
)
stream
+
=
'
bool
isOk
(
vec4
a
uvec4
b
)
{
return
(
uvec4
(
floor
(
a
+
0
.
5
)
)
=
=
b
)
;
}
\
n
'
;
}
else
{
if
(
cmpTypeFound
[
'
bool
'
]
)
stream
+
=
'
bool
isOk
(
bool
a
bool
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
bvec2
'
]
)
stream
+
=
'
bool
isOk
(
bvec2
a
bvec2
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
bvec3
'
]
)
stream
+
=
'
bool
isOk
(
bvec3
a
bvec3
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
bvec4
'
]
)
stream
+
=
'
bool
isOk
(
bvec4
a
bvec4
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
int
'
]
)
stream
+
=
'
bool
isOk
(
int
a
int
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
ivec2
'
]
)
stream
+
=
'
bool
isOk
(
ivec2
a
ivec2
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
ivec3
'
]
)
stream
+
=
'
bool
isOk
(
ivec3
a
ivec3
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
ivec4
'
]
)
stream
+
=
'
bool
isOk
(
ivec4
a
ivec4
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uint
'
]
)
stream
+
=
'
bool
isOk
(
uint
a
uint
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uvec2
'
]
)
stream
+
=
'
bool
isOk
(
uvec2
a
uvec2
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uvec3
'
]
)
stream
+
=
'
bool
isOk
(
uvec3
a
uvec3
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
uvec4
'
]
)
stream
+
=
'
bool
isOk
(
uvec4
a
uvec4
b
)
{
return
(
a
=
=
b
)
;
}
\
n
'
;
}
if
(
cmpTypeFound
[
'
float
'
]
)
stream
+
=
'
bool
isOk
(
float
a
float
b
float
eps
)
{
return
(
abs
(
a
-
b
)
<
=
(
eps
*
abs
(
b
)
+
eps
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
vec2
'
]
)
stream
+
=
'
bool
isOk
(
vec2
a
vec2
b
float
eps
)
{
return
all
(
lessThanEqual
(
abs
(
a
-
b
)
(
eps
*
abs
(
b
)
+
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
vec3
'
]
)
stream
+
=
'
bool
isOk
(
vec3
a
vec3
b
float
eps
)
{
return
all
(
lessThanEqual
(
abs
(
a
-
b
)
(
eps
*
abs
(
b
)
+
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
vec4
'
]
)
stream
+
=
'
bool
isOk
(
vec4
a
vec4
b
float
eps
)
{
return
all
(
lessThanEqual
(
abs
(
a
-
b
)
(
eps
*
abs
(
b
)
+
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat2
'
]
)
stream
+
=
'
bool
isOk
(
mat2
a
mat2
b
float
eps
)
{
vec2
diff
=
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
;
return
all
(
lessThanEqual
(
diff
vec2
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat2x3
'
]
)
stream
+
=
'
bool
isOk
(
mat2x3
a
mat2x3
b
float
eps
)
{
vec3
diff
=
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
;
return
all
(
lessThanEqual
(
diff
vec3
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat2x4
'
]
)
stream
+
=
'
bool
isOk
(
mat2x4
a
mat2x4
b
float
eps
)
{
vec4
diff
=
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
;
return
all
(
lessThanEqual
(
diff
vec4
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat3x2
'
]
)
stream
+
=
'
bool
isOk
(
mat3x2
a
mat3x2
b
float
eps
)
{
vec2
diff
=
max
(
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
abs
(
a
[
2
]
-
b
[
2
]
)
)
;
return
all
(
lessThanEqual
(
diff
vec2
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat3
'
]
)
stream
+
=
'
bool
isOk
(
mat3
a
mat3
b
float
eps
)
{
vec3
diff
=
max
(
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
abs
(
a
[
2
]
-
b
[
2
]
)
)
;
return
all
(
lessThanEqual
(
diff
vec3
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat3x4
'
]
)
stream
+
=
'
bool
isOk
(
mat3x4
a
mat3x4
b
float
eps
)
{
vec4
diff
=
max
(
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
abs
(
a
[
2
]
-
b
[
2
]
)
)
;
return
all
(
lessThanEqual
(
diff
vec4
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat4x2
'
]
)
stream
+
=
'
bool
isOk
(
mat4x2
a
mat4x2
b
float
eps
)
{
vec2
diff
=
max
(
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
max
(
abs
(
a
[
2
]
-
b
[
2
]
)
abs
(
a
[
3
]
-
b
[
3
]
)
)
)
;
return
all
(
lessThanEqual
(
diff
vec2
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat4x3
'
]
)
stream
+
=
'
bool
isOk
(
mat4x3
a
mat4x3
b
float
eps
)
{
vec3
diff
=
max
(
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
max
(
abs
(
a
[
2
]
-
b
[
2
]
)
abs
(
a
[
3
]
-
b
[
3
]
)
)
)
;
return
all
(
lessThanEqual
(
diff
vec3
(
eps
)
)
)
;
}
\
n
'
;
if
(
cmpTypeFound
[
'
mat4
'
]
)
stream
+
=
'
bool
isOk
(
mat4
a
mat4
b
float
eps
)
{
vec4
diff
=
max
(
max
(
abs
(
a
[
0
]
-
b
[
0
]
)
abs
(
a
[
1
]
-
b
[
1
]
)
)
max
(
abs
(
a
[
2
]
-
b
[
2
]
)
abs
(
a
[
3
]
-
b
[
3
]
)
)
)
;
return
all
(
lessThanEqual
(
diff
vec4
(
eps
)
)
)
;
}
\
n
'
;
return
stream
;
}
;
glsShaderLibraryCase
.
genCompareOp
=
function
(
dstVec4Var
valueBlock
nonFloatNamePrefix
checkVarName
)
{
var
isFirstOutput
=
true
;
var
output
=
'
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
var
valueName
=
val
.
valueName
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_OUTPUT
)
{
if
(
checkVarName
&
&
(
valueName
!
=
=
checkVarName
)
)
continue
;
if
(
isFirstOutput
)
{
output
+
=
'
bool
RES
=
'
;
isFirstOutput
=
false
;
}
else
output
+
=
'
RES
=
RES
&
&
'
;
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
output
+
=
'
isOk
(
'
+
valueName
+
'
ref_
'
+
valueName
+
'
0
.
05
)
;
\
n
'
;
else
output
+
=
'
isOk
(
'
+
nonFloatNamePrefix
+
valueName
+
'
ref_
'
+
valueName
+
'
)
;
\
n
'
;
}
}
if
(
isFirstOutput
)
output
+
=
dstVec4Var
+
'
=
vec4
(
1
.
0
)
;
\
n
'
;
else
output
+
=
dstVec4Var
+
'
=
vec4
(
RES
RES
RES
1
.
0
)
;
\
n
'
;
return
output
;
}
;
glsShaderLibraryCase
.
genFragmentShader
=
function
(
valueBlock
)
{
var
shader
=
'
'
;
var
state
=
tcuTestCase
.
runner
;
var
usesInout
=
glsShaderLibraryCase
.
usesShaderInoutQualifiers
(
state
.
currentTest
.
spec
.
targetVersion
)
;
var
vtxIn
=
usesInout
?
'
in
'
:
'
attribute
'
;
var
vtxOut
=
usesInout
?
'
out
'
:
'
varying
'
;
var
customColorOut
=
usesInout
;
var
fragIn
=
usesInout
?
'
in
'
:
'
varying
'
;
var
prec
=
glsShaderLibraryCase
.
supportsFragmentHighp
(
state
.
currentTest
.
spec
.
targetVersion
)
?
'
highp
'
:
'
mediump
'
;
shader
+
=
'
#
version
'
+
state
.
currentTest
.
spec
.
targetVersion
+
'
\
n
'
;
shader
+
=
'
precision
'
+
prec
+
'
float
;
\
n
'
;
shader
+
=
'
precision
'
+
prec
+
'
int
;
\
n
'
;
shader
+
=
'
\
n
'
;
if
(
customColorOut
)
{
shader
+
=
'
layout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
;
shader
+
=
'
\
n
'
;
}
shader
+
=
glsShaderLibraryCase
.
genCompareFunctions
(
valueBlock
true
)
;
shader
+
=
'
\
n
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
var
floatType
=
gluShaderUtil
.
getDataTypeFloatScalars
(
val
.
dataType
)
;
var
refType
=
gluShaderUtil
.
getDataTypeName
(
val
.
dataType
)
;
if
(
val
.
storageType
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_OUTPUT
)
{
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
shader
+
=
fragIn
+
'
'
+
floatType
+
'
'
+
val
.
valueName
+
'
;
\
n
'
;
else
shader
+
=
fragIn
+
'
'
+
floatType
+
'
v_
'
+
val
.
valueName
+
'
;
\
n
'
;
shader
+
=
'
uniform
'
+
refType
+
'
ref_
'
+
val
.
valueName
+
'
;
\
n
'
;
}
}
shader
+
=
'
\
n
'
;
shader
+
=
'
void
main
(
)
\
n
'
;
shader
+
=
'
{
\
n
'
;
shader
+
=
'
\
t
'
;
shader
+
=
glsShaderLibraryCase
.
genCompareOp
(
customColorOut
?
'
dEQP_FragColor
'
:
'
gl_FragColor
'
valueBlock
'
v_
'
null
)
;
shader
+
=
'
}
\
n
'
;
return
shader
;
}
;
glsShaderLibraryCase
.
caseRequirement
=
(
function
(
)
{
var
CaseRequirement
=
function
(
)
{
this
.
isAffected
=
function
(
shaderType
)
{
for
(
var
i
=
0
;
i
<
this
.
shaderTypes
.
length
;
i
+
+
)
if
(
this
.
shaderTypes
[
i
]
=
=
=
shaderType
)
return
true
;
return
false
;
}
;
this
.
checkRequirements
=
function
(
gl
)
{
if
(
this
.
type
=
=
=
requirementType
.
EXTENSION
)
{
var
extns
=
gl
.
getSupportedExtensions
(
)
;
for
(
var
i
=
0
;
i
<
extns
.
length
;
i
+
+
)
for
(
var
j
=
0
;
j
<
this
.
requirements
.
length
;
j
+
+
)
if
(
extns
[
i
]
=
=
=
this
.
requirements
[
j
]
)
{
this
.
supportedExtension
=
this
.
requirements
[
j
]
;
return
true
;
}
if
(
this
.
requirements
.
length
=
=
=
1
)
throw
Error
(
'
Test
requires
extension
of
'
+
this
.
requirements
[
0
]
)
;
else
throw
Error
(
'
Test
requires
any
extension
of
'
+
this
.
requirements
)
;
}
else
if
(
this
.
type
=
=
=
requirementType
.
IMPLEMENTATION_LIMIT
)
{
var
value
=
gl
.
getParameter
(
this
.
enumName
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
Failed
to
read
parameter
'
+
this
.
enumName
false
true
)
;
if
(
!
(
value
>
this
.
referenceValue
)
)
throw
Error
(
'
Test
requires
'
+
this
.
enumName
+
'
(
'
+
value
+
'
)
>
'
+
this
.
referenceValue
)
;
}
}
;
this
.
getSupportedExtension
=
function
(
)
{
return
this
.
supportedExtension
;
}
;
}
;
var
createAnyExtensionRequirement
=
function
(
requirements
shaderTypes
)
{
var
cr
=
new
CaseRequirement
(
)
;
cr
.
type
=
requirementType
.
EXTENSION
;
cr
.
requirements
=
requirements
;
cr
.
shaderTypes
=
shaderTypes
;
return
cr
;
}
;
var
createLimitRequirement
=
function
(
enumName
ref
)
{
var
cr
=
new
CaseRequirement
(
)
;
cr
.
type
=
requirementType
.
IMPLEMENTATION_LIMIT
;
cr
.
enumName
=
enumName
;
cr
.
referenceValue
=
ref
;
}
;
var
requirementType
=
{
EXTENSION
:
0
IMPLEMENTATION_LIMIT
:
1
}
;
return
{
createAnyExtensionRequirement
:
createAnyExtensionRequirement
createLimitRequirement
:
createLimitRequirement
requirementType
:
requirementType
}
;
}
(
)
)
;
glsShaderLibraryCase
.
injectExtensionRequirements
=
function
(
baseCode
shaderType
requirements
)
{
var
generateExtensionStatements
=
function
(
requirements
shaderType
)
{
var
buf
=
'
'
;
if
(
requirements
)
for
(
var
ndx
=
0
;
ndx
<
requirements
.
length
;
ndx
+
+
)
if
(
requirements
[
ndx
]
.
type
=
=
=
glsShaderLibraryCase
.
caseRequirement
.
requirementType
.
EXTENSION
&
&
requirements
[
ndx
]
.
isAffected
(
shaderType
)
)
buf
+
=
'
#
extension
'
+
requirements
[
ndx
]
.
getSupportedExtension
(
)
+
'
:
require
\
n
'
;
return
buf
;
}
;
var
extensions
=
generateExtensionStatements
(
requirements
shaderType
)
;
if
(
extensions
.
length
=
=
=
0
)
return
baseCode
;
var
splitLines
=
baseCode
.
split
(
'
\
n
'
)
;
var
firstNonPreprocessorLine
=
true
;
var
resultBuf
=
'
'
;
for
(
var
i
=
0
;
i
<
splitLines
.
length
;
i
+
+
)
{
var
isPreprocessorDirective
=
(
splitLines
[
i
]
.
match
(
/
^
\
s
*
#
/
)
!
=
=
null
)
;
if
(
!
isPreprocessorDirective
&
&
firstNonPreprocessorLine
)
{
firstNonPreprocessorLine
=
false
;
resultBuf
+
=
extensions
;
}
resultBuf
+
=
splitLines
[
i
]
+
'
\
n
'
;
}
return
resultBuf
;
}
;
glsShaderLibraryCase
.
specializeVertexShader
=
function
(
src
valueBlock
)
{
var
decl
=
'
'
;
var
setup
=
'
'
;
var
output
=
'
'
;
var
state
=
tcuTestCase
.
runner
;
var
usesInout
=
glsShaderLibraryCase
.
usesShaderInoutQualifiers
(
state
.
currentTest
.
spec
.
targetVersion
)
;
var
vtxIn
=
usesInout
?
'
in
'
:
'
attribute
'
;
var
vtxOut
=
usesInout
?
'
out
'
:
'
varying
'
;
output
+
=
'
gl_Position
=
dEQP_Position
;
\
n
'
;
decl
+
=
vtxIn
+
'
highp
vec4
dEQP_Position
;
\
n
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
var
valueName
=
val
.
valueName
;
var
floatType
=
gluShaderUtil
.
getDataTypeFloatScalars
(
val
.
dataType
)
;
var
dataTypeName
=
gluShaderUtil
.
getDataTypeName
(
val
.
dataType
)
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_INPUT
)
{
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
{
decl
+
=
vtxIn
+
'
'
+
floatType
+
'
'
+
valueName
+
'
;
\
n
'
;
}
else
{
decl
+
=
vtxIn
+
'
'
+
floatType
+
'
a_
'
+
valueName
+
'
;
\
n
'
;
setup
+
=
dataTypeName
+
'
'
+
valueName
+
'
=
'
+
dataTypeName
+
'
(
a_
'
+
valueName
+
'
)
;
\
n
'
;
}
}
else
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_OUTPUT
)
{
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
decl
+
=
vtxOut
+
'
'
+
floatType
+
'
'
+
valueName
+
'
;
\
n
'
;
else
{
decl
+
=
vtxOut
+
'
'
+
floatType
+
'
v_
'
+
valueName
+
'
;
\
n
'
;
decl
+
=
dataTypeName
+
'
'
+
valueName
+
'
;
\
n
'
;
output
+
=
'
v_
'
+
valueName
+
'
=
'
+
floatType
+
'
(
'
+
valueName
+
'
)
;
\
n
'
;
}
}
}
var
baseSrc
=
src
.
replace
(
/
\
\
{
DECLARATIONS
\
}
/
g
decl
)
.
replace
(
/
\
\
{
DECLARATIONS
:
single
-
line
\
}
/
g
decl
.
replace
(
/
\
n
/
g
'
'
)
)
.
replace
(
/
\
\
{
SETUP
\
}
/
g
setup
)
.
replace
(
/
\
\
{
OUTPUT
\
}
/
g
output
)
.
replace
(
/
\
\
{
POSITION_FRAG_COLOR
\
}
/
g
'
gl_Position
'
)
;
var
withExt
=
glsShaderLibraryCase
.
injectExtensionRequirements
(
baseSrc
gluShaderProgram
.
shaderType
.
VERTEX
state
.
currentTest
.
spec
.
requirements
)
;
return
withExt
;
}
;
glsShaderLibraryCase
.
specializeVertexOnly
=
function
(
src
valueBlock
)
{
var
decl
=
'
'
;
var
setup
=
'
'
;
var
output
=
'
'
;
var
state
=
tcuTestCase
.
runner
;
var
usesInout
=
glsShaderLibraryCase
.
usesShaderInoutQualifiers
(
state
.
currentTest
.
spec
.
targetVersion
)
;
var
vtxIn
=
usesInout
?
'
in
'
:
'
attribute
'
;
output
+
=
'
gl_Position
=
dEQP_Position
;
\
n
'
;
decl
+
=
vtxIn
+
'
highp
vec4
dEQP_Position
;
\
n
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
var
valueName
=
val
.
valueName
;
var
type
=
gluShaderUtil
.
getDataTypeName
(
val
.
dataType
)
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_INPUT
)
{
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
{
decl
+
=
vtxIn
+
'
'
+
type
+
'
'
+
valueName
+
'
;
\
n
'
;
}
else
{
var
floatType
=
gluShaderUtil
.
getDataTypeFloatScalars
(
val
.
dataType
)
;
decl
+
=
vtxIn
+
'
'
+
floatType
+
'
a_
'
+
valueName
+
'
;
\
n
'
;
setup
+
=
type
+
'
'
+
valueName
+
'
=
'
+
type
+
'
(
a_
'
+
valueName
+
'
)
;
\
n
'
;
}
}
else
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_UNIFORM
&
&
!
val
.
valueName
.
match
(
'
\
\
.
'
)
)
decl
+
=
'
uniform
'
+
type
+
'
'
+
valueName
+
'
;
\
n
'
;
}
var
baseSrc
=
src
.
replace
(
/
\
\
{
VERTEX_DECLARATIONS
\
}
/
g
decl
)
.
replace
(
/
\
\
{
VERTEX_DECLARATIONS
:
single
-
line
\
}
/
g
decl
.
replace
(
/
\
n
/
g
'
'
)
)
.
replace
(
/
\
\
{
VERTEX_SETUP
\
}
/
g
setup
)
.
replace
(
/
\
\
{
VERTEX_OUTPUT
\
}
/
g
output
)
;
var
withExt
=
glsShaderLibraryCase
.
injectExtensionRequirements
(
baseSrc
gluShaderProgram
.
shaderType
.
VERTEX
state
.
currentTest
.
spec
.
requirements
)
;
return
withExt
;
}
;
glsShaderLibraryCase
.
specializeFragmentShader
=
function
(
src
valueBlock
)
{
var
decl
=
'
'
;
var
setup
=
'
'
;
var
output
=
'
'
;
var
state
=
tcuTestCase
.
runner
;
var
usesInout
=
glsShaderLibraryCase
.
usesShaderInoutQualifiers
(
state
.
currentTest
.
spec
.
targetVersion
)
;
var
customColorOut
=
usesInout
;
var
fragIn
=
usesInout
?
'
in
'
:
'
varying
'
;
var
fragColor
=
customColorOut
?
'
dEQP_FragColor
'
:
'
gl_FragColor
'
;
decl
+
=
glsShaderLibraryCase
.
genCompareFunctions
(
valueBlock
false
)
;
output
+
=
glsShaderLibraryCase
.
genCompareOp
(
fragColor
valueBlock
'
'
null
)
;
if
(
customColorOut
)
decl
+
=
'
layout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
var
valueName
=
val
.
valueName
;
var
floatType
=
gluShaderUtil
.
getDataTypeFloatScalars
(
val
.
dataType
)
;
var
refType
=
gluShaderUtil
.
getDataTypeName
(
val
.
dataType
)
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_INPUT
)
{
if
(
gluShaderUtil
.
getDataTypeScalarType
(
val
.
dataType
)
=
=
=
'
float
'
)
decl
+
=
fragIn
+
'
'
+
floatType
+
'
'
+
valueName
+
'
;
\
n
'
;
else
{
decl
+
=
fragIn
+
'
'
+
floatType
+
'
v_
'
+
valueName
+
'
;
\
n
'
;
var
offset
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
val
.
dataType
)
?
'
*
1
.
0025
'
:
'
'
;
setup
+
=
refType
+
'
'
+
valueName
+
'
=
'
+
refType
+
'
(
v_
'
+
valueName
+
offset
+
'
)
;
\
n
'
;
}
}
else
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_OUTPUT
)
{
decl
+
=
'
uniform
'
+
refType
+
'
ref_
'
+
valueName
+
'
;
\
n
'
;
decl
+
=
refType
+
'
'
+
valueName
+
'
;
\
n
'
;
}
}
var
baseSrc
=
src
.
replace
(
/
\
\
{
DECLARATIONS
\
}
/
g
decl
)
.
replace
(
/
\
\
{
DECLARATIONS
:
single
-
line
\
}
/
g
decl
.
replace
(
/
\
n
/
g
'
'
)
)
.
replace
(
/
\
\
{
SETUP
\
}
/
g
setup
)
.
replace
(
/
\
\
{
OUTPUT
\
}
/
g
output
)
.
replace
(
/
\
\
{
POSITION_FRAG_COLOR
\
}
/
g
fragColor
)
;
var
withExt
=
glsShaderLibraryCase
.
injectExtensionRequirements
(
baseSrc
gluShaderProgram
.
shaderType
.
FRAGMENT
state
.
currentTest
.
spec
.
requirements
)
;
return
withExt
;
}
;
glsShaderLibraryCase
.
specializeFragmentOnly
=
function
(
src
valueBlock
)
{
var
decl
=
'
'
;
var
output
=
'
'
;
var
state
=
tcuTestCase
.
runner
;
var
usesInout
=
glsShaderLibraryCase
.
usesShaderInoutQualifiers
(
state
.
currentTest
.
spec
.
targetVersion
)
;
var
customColorOut
=
usesInout
;
var
fragIn
=
usesInout
?
'
in
'
:
'
varying
'
;
var
fragColor
=
customColorOut
?
'
dEQP_FragColor
'
:
'
gl_FragColor
'
;
decl
+
=
glsShaderLibraryCase
.
genCompareFunctions
(
valueBlock
false
)
;
output
+
=
glsShaderLibraryCase
.
genCompareOp
(
fragColor
valueBlock
'
'
null
)
;
if
(
customColorOut
)
decl
+
=
'
layout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
;
for
(
var
ndx
=
0
;
ndx
<
valueBlock
.
values
.
length
;
ndx
+
+
)
{
var
val
=
valueBlock
.
values
[
ndx
]
;
var
valueName
=
val
.
valueName
;
var
floatType
=
gluShaderUtil
.
getDataTypeFloatScalars
(
val
.
dataType
)
;
var
refType
=
gluShaderUtil
.
getDataTypeName
(
val
.
dataType
)
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_OUTPUT
)
{
decl
+
=
'
uniform
'
+
refType
+
'
ref_
'
+
valueName
+
'
;
\
n
'
;
decl
+
=
refType
+
'
'
+
valueName
+
'
;
\
n
'
;
}
else
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_UNIFORM
&
&
!
valueName
.
match
(
'
\
\
.
'
)
)
decl
+
=
'
uniform
'
+
refType
+
'
'
+
valueName
+
'
;
\
n
'
;
}
var
baseSrc
=
src
.
replace
(
/
\
\
{
FRAGMENT_DECLARATIONS
\
}
/
g
decl
)
.
replace
(
/
\
\
{
FRAGMENT_DECLARATIONS
:
single
-
line
\
}
/
g
decl
.
replace
(
/
\
n
/
g
'
'
)
)
.
replace
(
/
\
\
{
FRAGMENT_OUTPUT
\
}
/
g
output
)
.
replace
(
/
\
\
{
FRAG_COLOR
\
}
/
g
fragColor
)
;
var
withExt
=
glsShaderLibraryCase
.
injectExtensionRequirements
(
baseSrc
gluShaderProgram
.
shaderType
.
FRAGMENT
state
.
currentTest
.
spec
.
requirements
)
;
return
withExt
;
}
;
glsShaderLibraryCase
.
isTessellationPresent
=
function
(
)
{
return
false
;
}
;
glsShaderLibraryCase
.
setUniformValue
=
function
(
gl
pipelinePrograms
name
val
arrayNdx
)
{
var
foundAnyMatch
=
false
;
for
(
var
programNdx
=
0
;
programNdx
<
pipelinePrograms
.
length
;
+
+
programNdx
)
{
var
loc
=
gl
.
getUniformLocation
(
pipelinePrograms
[
programNdx
]
name
)
;
var
scalarSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
val
.
dataType
)
;
var
elemNdx
=
(
val
.
arrayLength
=
=
=
1
)
?
(
0
)
:
(
arrayNdx
*
scalarSize
)
;
if
(
!
loc
)
continue
;
foundAnyMatch
=
true
;
gl
.
useProgram
(
pipelinePrograms
[
programNdx
]
)
;
var
element
=
val
.
elements
.
slice
(
elemNdx
elemNdx
+
scalarSize
)
;
switch
(
val
.
dataType
)
{
case
gluShaderUtil
.
DataType
.
FLOAT
:
gl
.
uniform1fv
(
loc
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC2
:
gl
.
uniform2fv
(
loc
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC3
:
gl
.
uniform3fv
(
loc
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC4
:
gl
.
uniform4fv
(
loc
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2
:
gl
.
uniformMatrix2fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3
:
gl
.
uniformMatrix3fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4
:
gl
.
uniformMatrix4fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
INT
:
gl
.
uniform1iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
INT_VEC2
:
gl
.
uniform2iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
INT_VEC3
:
gl
.
uniform3iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
INT_VEC4
:
gl
.
uniform4iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
BOOL
:
gl
.
uniform1iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
BOOL_VEC2
:
gl
.
uniform2iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
BOOL_VEC3
:
gl
.
uniform3iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
BOOL_VEC4
:
gl
.
uniform4iv
(
loc
new
Int32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
UINT
:
gl
.
uniform1uiv
(
loc
new
Uint32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
UINT_VEC2
:
gl
.
uniform2uiv
(
loc
new
Uint32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
UINT_VEC3
:
gl
.
uniform3uiv
(
loc
new
Uint32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
UINT_VEC4
:
gl
.
uniform4uiv
(
loc
new
Uint32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2X3
:
gl
.
uniformMatrix2x3fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT2X4
:
gl
.
uniformMatrix2x4fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3X2
:
gl
.
uniformMatrix3x2fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT3X4
:
gl
.
uniformMatrix3x4fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4X2
:
gl
.
uniformMatrix4x2fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_MAT4X3
:
gl
.
uniformMatrix4x3fv
(
loc
false
new
Float32Array
(
element
)
)
;
break
;
default
:
testFailed
(
'
Unknown
data
type
'
+
val
.
dataType
)
;
}
}
if
(
!
foundAnyMatch
)
bufferedLogToConsole
(
'
WARNING
/
/
Uniform
\
"
'
+
name
+
'
\
"
location
is
not
valid
location
=
-
1
.
Cannot
set
value
to
the
uniform
.
'
)
;
}
;
glsShaderLibraryCase
.
checkPixels
=
function
(
surface
minX
maxX
minY
maxY
)
{
var
allWhite
=
true
;
var
allBlack
=
true
;
var
anyUnexpected
=
false
;
assertMsgOptions
(
(
maxX
>
minX
)
&
&
(
maxY
>
minY
)
'
glsShaderLibraryCase
.
checkPixels
sanity
check
'
false
true
)
;
for
(
var
y
=
minY
;
y
<
=
maxY
;
y
+
+
)
{
for
(
var
x
=
minX
;
x
<
=
maxX
;
x
+
+
)
{
var
pixel
=
surface
.
getPixelUintRGB8
(
x
y
)
;
var
isWhite
=
(
pixel
=
=
0xFFFFFF
)
;
var
isBlack
=
(
pixel
=
=
0x000000
)
;
allWhite
=
allWhite
&
&
isWhite
;
allBlack
=
allBlack
&
&
isBlack
;
anyUnexpected
=
anyUnexpected
|
|
(
!
isWhite
&
&
!
isBlack
)
;
if
(
!
allWhite
&
&
!
allBlack
)
break
;
}
}
if
(
!
allWhite
)
{
if
(
anyUnexpected
)
testFailed
(
'
WARNING
:
expecting
all
rendered
pixels
to
be
white
or
black
but
got
other
colors
as
well
!
'
)
;
else
if
(
!
allBlack
)
testFailed
(
'
WARNING
:
got
inconsistent
results
over
the
image
when
all
pixels
should
be
the
same
color
!
'
)
;
return
false
;
}
return
true
;
}
;
glsShaderLibraryCase
.
init
=
function
(
)
{
var
state
=
tcuTestCase
.
runner
;
var
test
=
state
.
currentTest
;
bufferedLogToConsole
(
'
Processing
'
+
test
.
fullName
(
)
)
;
if
(
!
test
.
spec
.
valueBlockList
.
length
)
test
.
spec
.
valueBlockList
.
push
(
glsShaderLibraryCase
.
genValueBlock
(
)
)
;
var
valueBlock
=
test
.
spec
.
valueBlockList
[
0
]
;
if
(
test
.
spec
.
requirements
)
for
(
var
ndx
=
0
;
ndx
<
test
.
spec
.
requirements
.
length
;
+
+
ndx
)
test
.
spec
.
requirements
[
ndx
]
.
checkRequirements
(
)
;
var
sources
=
[
]
;
if
(
test
.
spec
.
caseType
=
=
=
glsShaderLibraryCase
.
caseType
.
CASETYPE_COMPLETE
)
{
var
vertex
=
glsShaderLibraryCase
.
specializeVertexOnly
(
test
.
spec
.
vertexSource
valueBlock
)
;
var
fragment
=
glsShaderLibraryCase
.
specializeFragmentOnly
(
test
.
spec
.
fragmentSource
valueBlock
)
;
sources
.
push
(
gluShaderProgram
.
genVertexSource
(
vertex
)
)
;
sources
.
push
(
gluShaderProgram
.
genFragmentSource
(
fragment
)
)
;
}
else
if
(
test
.
spec
.
caseType
=
=
=
glsShaderLibraryCase
.
caseType
.
CASETYPE_VERTEX_ONLY
)
{
sources
.
push
(
gluShaderProgram
.
genVertexSource
(
glsShaderLibraryCase
.
specializeVertexShader
(
test
.
spec
.
vertexSource
valueBlock
)
)
)
;
sources
.
push
(
gluShaderProgram
.
genFragmentSource
(
glsShaderLibraryCase
.
genFragmentShader
(
valueBlock
)
)
)
;
}
else
if
(
test
.
spec
.
caseType
=
=
=
glsShaderLibraryCase
.
caseType
.
CASETYPE_FRAGMENT_ONLY
)
{
sources
.
push
(
gluShaderProgram
.
genVertexSource
(
glsShaderLibraryCase
.
genVertexShader
(
valueBlock
)
)
)
;
sources
.
push
(
gluShaderProgram
.
genFragmentSource
(
glsShaderLibraryCase
.
specializeFragmentShader
(
test
.
spec
.
fragmentSource
valueBlock
)
)
)
;
}
test
.
programs
=
[
]
;
test
.
programs
.
push
(
{
programSources
:
{
sources
:
sources
}
}
)
;
}
;
glsShaderLibraryCase
.
execute
=
function
(
)
{
var
quadSize
=
1
.
0
;
var
s_positions
=
[
-
quadSize
-
quadSize
0
.
0
1
.
0
-
quadSize
+
quadSize
0
.
0
1
.
0
+
quadSize
-
quadSize
0
.
0
1
.
0
+
quadSize
+
quadSize
0
.
0
1
.
0
]
;
var
s_indices
=
[
0
1
2
1
3
2
]
;
var
wtu
=
WebGLTestUtils
;
var
gl
=
wtu
.
create3DContext
(
'
canvas
'
)
;
var
state
=
tcuTestCase
.
runner
;
var
test
=
state
.
currentTest
;
var
spec
=
test
.
spec
;
var
width
=
Math
.
min
(
canvas
.
width
glsShaderLibraryCase
.
VIEWPORT_WIDTH
)
;
var
height
=
Math
.
min
(
canvas
.
height
glsShaderLibraryCase
.
VIEWPORT_HEIGHT
)
;
var
viewportX
=
0
;
var
viewportY
=
0
;
var
numVerticesPerDraw
=
4
;
var
tessellationPresent
=
glsShaderLibraryCase
.
isTessellationPresent
(
)
;
var
allCompilesOk
=
true
;
var
allLinksOk
=
true
;
var
failReason
=
null
;
var
vertexProgramID
=
-
1
;
var
pipelineProgramIDs
=
[
]
;
var
programs
=
[
]
;
var
programPipeline
;
setCurrentTestName
(
test
.
fullName
(
)
)
;
debug
(
'
Start
testcase
:
'
+
test
.
fullName
(
)
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
Start
testcase
:
'
+
test
.
fullName
(
)
false
true
)
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
test
.
programs
[
0
]
.
programSources
)
;
vertexProgramID
=
program
.
getProgram
(
)
;
pipelineProgramIDs
.
push
(
program
.
getProgram
(
)
)
;
programs
.
push
(
program
)
;
for
(
var
i
=
0
;
i
<
program
.
shaders
.
length
;
i
+
+
)
{
if
(
!
program
.
shaders
[
i
]
.
info
.
compileOk
)
allCompilesOk
=
false
;
}
if
(
!
program
.
getProgramInfo
(
)
.
linkOk
)
allLinksOk
=
false
;
switch
(
spec
.
expectResult
)
{
case
glsShaderLibraryCase
.
expectResult
.
EXPECT_PASS
:
case
glsShaderLibraryCase
.
expectResult
.
EXPECT_VALIDATION_FAIL
:
case
glsShaderLibraryCase
.
expectResult
.
EXPECT_BUILD_SUCCESSFUL
:
if
(
!
allCompilesOk
)
failReason
=
'
expected
shaders
to
compile
and
link
properly
but
failed
to
compile
.
'
;
else
if
(
!
allLinksOk
)
failReason
=
'
expected
shaders
to
compile
and
link
properly
but
failed
to
link
.
'
;
break
;
case
glsShaderLibraryCase
.
expectResult
.
EXPECT_COMPILE_FAIL
:
if
(
allCompilesOk
&
&
!
allLinksOk
)
failReason
=
'
expected
compilation
to
fail
but
shaders
compiled
and
link
failed
.
'
;
else
if
(
allCompilesOk
)
failReason
=
'
expected
compilation
to
fail
but
shaders
compiled
correctly
.
'
;
break
;
case
glsShaderLibraryCase
.
expectResult
.
EXPECT_LINK_FAIL
:
if
(
!
allCompilesOk
)
failReason
=
'
expected
linking
to
fail
but
unable
to
compile
.
'
;
else
if
(
allLinksOk
)
failReason
=
'
expected
linking
to
fail
but
passed
.
'
;
break
;
case
glsShaderLibraryCase
.
expectResult
.
EXPECT_COMPILE_LINK_FAIL
:
if
(
allCompilesOk
&
&
allLinksOk
)
failReason
=
'
expected
compile
or
link
to
fail
but
passed
.
'
;
break
;
default
:
testFailedOptions
(
'
Unknown
expected
result
'
true
)
;
return
false
;
}
if
(
failReason
!
=
null
)
{
if
(
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_COMPILE_FAIL
&
&
allCompilesOk
&
&
!
allLinksOk
)
bufferedLogToConsole
(
'
Quality
warning
:
implementation
parses
shader
at
link
time
:
'
+
failReason
)
;
else
{
bufferedLogToConsole
(
'
ERROR
:
'
+
failReason
)
;
testFailedOptions
(
failReason
true
)
;
}
return
false
;
}
if
(
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_COMPILE_FAIL
|
|
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_COMPILE_LINK_FAIL
|
|
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_LINK_FAIL
|
|
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_BUILD_SUCCESSFUL
)
{
if
(
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_BUILD_SUCCESSFUL
)
{
testPassedOptions
(
'
Compile
/
link
is
expected
to
succeed
'
true
)
;
}
else
{
testPassedOptions
(
'
Compile
/
link
is
expected
to
fail
'
true
)
;
}
setCurrentTestName
(
'
'
)
;
return
(
failReason
=
=
=
null
)
;
}
gl
.
viewport
(
viewportX
viewportY
width
height
)
;
gl
.
useProgram
(
vertexProgramID
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
glUseProgram
(
)
'
false
true
)
;
var
positionLoc
=
gl
.
getAttribLocation
(
vertexProgramID
'
dEQP_Position
'
)
;
if
(
positionLoc
=
=
=
-
1
)
{
testFailedOptions
(
"
no
location
found
for
attribute
'
dEQP_Position
'
"
true
)
;
return
false
;
}
for
(
var
blockNdx
=
0
;
blockNdx
<
spec
.
valueBlockList
.
length
;
blockNdx
+
+
)
{
var
block
=
spec
.
valueBlockList
[
blockNdx
]
;
var
numRenderPasses
=
Math
.
max
(
block
.
arrayLength
1
)
;
for
(
var
arrayNdx
=
0
;
arrayNdx
<
numRenderPasses
;
arrayNdx
+
+
)
{
var
numValues
=
block
.
values
.
length
;
var
vertexArrays
=
[
]
;
var
attribValueNdx
=
0
;
var
postDrawError
;
vertexArrays
.
push
(
new
gluDrawUtil
.
VertexArrayBinding
(
gl
.
FLOAT
positionLoc
4
numVerticesPerDraw
s_positions
)
)
;
for
(
var
valNdx
=
0
;
valNdx
<
numValues
;
valNdx
+
+
)
{
var
val
=
block
.
values
[
valNdx
]
;
var
valueName
=
val
.
valueName
;
var
dataType
=
val
.
dataType
;
var
scalarSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
val
.
dataType
)
;
if
(
val
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_INPUT
)
{
var
scalars
=
[
]
;
for
(
var
repNdx
=
0
;
repNdx
<
numVerticesPerDraw
;
repNdx
+
+
)
for
(
var
ndx
=
0
;
ndx
<
scalarSize
;
ndx
+
+
)
scalars
[
repNdx
*
scalarSize
+
ndx
]
=
val
.
elements
[
arrayNdx
*
scalarSize
+
ndx
]
;
var
attribPrefix
=
'
'
;
if
(
(
spec
.
caseType
=
=
=
glsShaderLibraryCase
.
caseType
.
CASETYPE_FRAGMENT_ONLY
)
|
|
(
gluShaderUtil
.
getDataTypeScalarType
(
dataType
)
!
=
=
'
float
'
)
)
attribPrefix
=
'
a_
'
;
var
attribName
=
attribPrefix
+
valueName
;
var
attribLoc
=
gl
.
getAttribLocation
(
vertexProgramID
attribName
)
;
if
(
attribLoc
=
=
=
-
1
)
{
bufferedLogToConsole
(
"
Warning
:
no
location
found
for
attribute
'
"
+
attribName
+
"
'
"
)
;
continue
;
}
if
(
gluShaderUtil
.
isDataTypeMatrix
(
dataType
)
)
{
var
numCols
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
dataType
)
;
var
numRows
=
gluShaderUtil
.
getDataTypeMatrixNumRows
(
dataType
)
;
assertMsgOptions
(
scalarSize
=
=
=
numCols
*
numRows
'
Matrix
size
sanity
check
'
false
true
)
;
for
(
var
i
=
0
;
i
<
numCols
;
i
+
+
)
vertexArrays
.
push
(
new
gluDrawUtil
.
VertexArrayBinding
(
gl
.
FLOAT
attribLoc
+
i
numRows
numVerticesPerDraw
scalars
scalarSize
*
4
i
*
numRows
*
4
)
)
;
}
else
vertexArrays
.
push
(
new
gluDrawUtil
.
VertexArrayBinding
(
gl
.
FLOAT
attribLoc
scalarSize
numVerticesPerDraw
scalars
)
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
set
vertex
attrib
array
'
false
true
)
;
}
}
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
before
set
uniforms
'
false
true
)
;
for
(
var
valNdx
=
0
;
valNdx
<
numValues
;
valNdx
+
+
)
{
var
val1
=
block
.
values
[
valNdx
]
;
var
valueName1
=
val1
.
valueName
;
if
(
val1
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_OUTPUT
)
{
glsShaderLibraryCase
.
setUniformValue
(
gl
pipelineProgramIDs
'
ref_
'
+
valueName1
val1
arrayNdx
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
set
reference
uniforms
'
false
true
)
;
}
else
if
(
val1
.
storageType
=
=
=
glsShaderLibraryCase
.
shaderCase
.
STORAGE_UNIFORM
)
{
glsShaderLibraryCase
.
setUniformValue
(
gl
pipelineProgramIDs
valueName1
val1
arrayNdx
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
set
uniforms
'
false
true
)
;
}
}
gl
.
clearColor
(
0
.
125
0
.
25
0
.
5
1
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
clear
buffer
'
false
true
)
;
if
(
spec
.
separatePrograms
)
gl
.
useProgram
(
null
)
;
else
gl
.
useProgram
(
vertexProgramID
)
;
gluDrawUtil
.
draw
(
gl
vertexProgramID
vertexArrays
gluDrawUtil
.
triangles
(
s_indices
)
)
;
postDrawError
=
gl
.
getError
(
)
;
if
(
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_PASS
)
{
var
surface
=
new
gluDrawUtil
.
Surface
(
)
;
var
w
=
s_positions
[
3
]
;
var
minY
=
Math
.
ceil
(
(
(
-
quadSize
/
w
)
*
0
.
5
+
0
.
5
)
*
height
+
1
.
0
)
;
var
maxY
=
Math
.
floor
(
(
(
+
quadSize
/
w
)
*
0
.
5
+
0
.
5
)
*
height
-
0
.
5
)
;
var
minX
=
Math
.
ceil
(
(
(
-
quadSize
/
w
)
*
0
.
5
+
0
.
5
)
*
width
+
1
.
0
)
;
var
maxX
=
Math
.
floor
(
(
(
+
quadSize
/
w
)
*
0
.
5
+
0
.
5
)
*
width
-
0
.
5
)
;
assertMsgOptions
(
postDrawError
=
=
=
gl
.
NO_ERROR
'
draw
'
false
true
)
;
surface
.
readSurface
(
gl
viewportX
viewportY
width
height
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
read
pixels
'
false
true
)
;
if
(
!
glsShaderLibraryCase
.
checkPixels
(
surface
minX
maxX
minY
maxY
)
)
{
testFailedOptions
(
(
'
INCORRECT
RESULT
for
(
value
block
'
+
(
blockNdx
+
1
)
+
'
of
'
+
spec
.
valueBlockList
.
length
+
'
sub
-
case
'
+
(
arrayNdx
+
1
)
+
'
of
'
+
block
.
arrayLength
+
'
)
:
'
)
true
)
;
gl
.
useProgram
(
null
)
;
return
false
;
}
}
else
if
(
spec
.
expectResult
=
=
=
glsShaderLibraryCase
.
expectResult
.
EXPECT_VALIDATION_FAIL
)
{
testFailedOptions
(
'
Unsupported
test
case
'
true
)
;
}
}
}
gl
.
useProgram
(
null
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
=
gl
.
NO_ERROR
'
'
true
true
)
;
setCurrentTestName
(
'
'
)
;
return
true
;
}
;
glsShaderLibraryCase
.
runTestCases
=
function
(
)
{
var
state
=
tcuTestCase
.
runner
;
if
(
state
.
next
(
)
)
{
try
{
glsShaderLibraryCase
.
init
(
)
;
glsShaderLibraryCase
.
execute
(
)
;
}
catch
(
err
)
{
bufferedLogToConsole
(
err
)
;
}
tcuTestCase
.
runner
.
runCallback
(
glsShaderLibraryCase
.
runTestCases
)
;
}
else
tcuTestCase
.
runner
.
terminate
(
)
;
}
;
glsShaderLibraryCase
.
genValueBlock
=
function
(
)
{
return
{
values
:
[
]
arrayLength
:
0
}
;
}
;
}
)
;
