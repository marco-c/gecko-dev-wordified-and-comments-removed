'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fReadPixelTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fReadPixelTests
=
functional
.
gles3
.
es3fReadPixelTests
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
es3fReadPixelTests
.
ReadPixelsTest
=
function
(
name
description
chooseFormat
alignment
rowLength
skipRows
skipPixels
format
type
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_seed
=
deString
.
deStringHash
(
name
)
;
this
.
m_chooseFormat
=
chooseFormat
;
this
.
m_alignment
=
alignment
;
this
.
m_rowLength
=
rowLength
;
this
.
m_skipRows
=
skipRows
;
this
.
m_skipPixels
=
skipPixels
;
this
.
m_format
=
format
!
=
=
undefined
?
format
:
gl
.
RGBA
;
this
.
m_type
=
type
!
=
=
undefined
?
type
:
gl
.
UNSIGNED_BYTE
;
this
.
m_width
=
13
;
this
.
m_height
=
13
;
}
;
es3fReadPixelTests
.
ReadPixelsTest
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fReadPixelTests
.
ReadPixelsTest
.
prototype
.
constructor
=
es3fReadPixelTests
.
ReadPixelsTest
;
es3fReadPixelTests
.
ReadPixelsTest
.
prototype
.
render
=
function
(
reference
)
{
var
refType
=
(
reference
.
getFormat
(
)
.
type
)
;
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
level0
=
reference
.
getLevel
(
0
)
;
var
vertexSource
=
'
#
version
300
es
\
n
'
+
'
in
mediump
vec2
i_coord
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
\
tgl_Position
=
vec4
(
i_coord
0
.
0
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
var
fragmentSource
=
'
#
version
300
es
\
n
'
;
if
(
refType
=
=
=
tcuTexture
.
ChannelType
.
SIGNED_INT32
)
fragmentSource
+
=
'
layout
(
location
=
0
)
out
mediump
ivec4
o_color
;
\
n
'
;
else
if
(
refType
=
=
=
tcuTexture
.
ChannelType
.
UNSIGNED_INT32
)
fragmentSource
+
=
'
layout
(
location
=
0
)
out
mediump
uvec4
o_color
;
\
n
'
;
else
fragmentSource
+
=
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
;
fragmentSource
+
=
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
;
if
(
refType
=
=
=
tcuTexture
.
ChannelType
.
UNSIGNED_INT32
)
fragmentSource
+
=
'
\
to_color
=
uvec4
(
0
0
0
1000
)
;
\
n
'
;
else
if
(
refType
=
=
=
tcuTexture
.
ChannelType
.
SIGNED_INT32
)
fragmentSource
+
=
'
\
to_color
=
ivec4
(
0
0
0
1000
)
;
\
n
'
;
else
fragmentSource
+
=
'
\
to_color
=
vec4
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
\
n
'
;
fragmentSource
+
=
'
}
\
n
'
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vertexSource
fragmentSource
)
)
;
assertMsgOptions
(
program
.
isOk
(
)
'
Program
failed
'
false
true
)
;
gl
.
useProgram
(
program
.
getProgram
(
)
)
;
var
coords
=
[
-
0
.
5
-
0
.
5
0
.
5
-
0
.
5
0
.
5
0
.
5
0
.
5
0
.
5
-
0
.
5
0
.
5
-
0
.
5
-
0
.
5
]
;
var
coordLoc
;
coordLoc
=
gl
.
getAttribLocation
(
program
.
getProgram
(
)
'
i_coord
'
)
;
gl
.
enableVertexAttribArray
(
coordLoc
)
;
var
coordsGLBuffer
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
coordsGLBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Float32Array
(
coords
)
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribPointer
(
coordLoc
2
gl
.
FLOAT
false
0
0
)
;
gl
.
drawArrays
(
gl
.
TRIANGLES
0
6
)
;
gl
.
disableVertexAttribArray
(
coordLoc
)
;
var
coordX1
=
Math
.
floor
(
(
-
0
.
5
*
width
/
2
.
0
)
+
width
/
2
.
0
)
;
var
coordY1
=
Math
.
floor
(
(
-
0
.
5
*
height
/
2
.
0
)
+
height
/
2
.
0
)
;
var
coordX2
=
Math
.
floor
(
(
0
.
5
*
width
/
2
.
0
)
+
width
/
2
.
0
)
;
var
coordY2
=
Math
.
floor
(
(
0
.
5
*
height
/
2
.
0
)
+
height
/
2
.
0
)
;
for
(
var
x
=
0
;
x
<
width
;
x
+
+
)
{
if
(
x
<
coordX1
|
|
x
>
coordX2
)
continue
;
for
(
var
y
=
0
;
y
<
height
;
y
+
+
)
{
if
(
y
>
=
coordY1
&
&
y
<
=
coordY2
)
{
if
(
refType
=
=
=
tcuTexture
.
ChannelType
.
SIGNED_INT32
)
level0
.
setPixelInt
(
[
0
0
0
1000
]
x
y
)
;
else
if
(
refType
=
=
=
tcuTexture
.
ChannelType
.
UNSIGNED_INT32
)
level0
.
setPixelInt
(
[
0
0
0
1000
]
x
y
)
;
else
level0
.
setPixel
(
[
0
.
0
0
.
0
0
.
0
1
.
0
]
x
y
)
;
}
}
}
}
;
es3fReadPixelTests
.
ReadPixelsTest
.
prototype
.
getFormatInfo
=
function
(
)
{
if
(
this
.
m_chooseFormat
)
{
this
.
m_format
=
(
gl
.
getParameter
(
gl
.
IMPLEMENTATION_COLOR_READ_FORMAT
)
)
;
this
.
m_type
=
(
gl
.
getParameter
(
gl
.
IMPLEMENTATION_COLOR_READ_TYPE
)
)
;
}
var
fmt
=
gluTextureUtil
.
mapGLTransferFormat
(
this
.
m_format
this
.
m_type
)
;
var
align_
;
switch
(
this
.
m_type
)
{
case
gl
.
BYTE
:
case
gl
.
UNSIGNED_BYTE
:
case
gl
.
SHORT
:
case
gl
.
UNSIGNED_SHORT
:
case
gl
.
INT
:
case
gl
.
UNSIGNED_INT
:
case
gl
.
FLOAT
:
case
gl
.
HALF_FLOAT
:
align_
=
true
;
break
;
case
gl
.
UNSIGNED_SHORT_5_6_5
:
case
gl
.
UNSIGNED_SHORT_4_4_4_4
:
case
gl
.
UNSIGNED_SHORT_5_5_5_1
:
case
gl
.
UNSIGNED_INT_2_10_10_10_REV
:
case
gl
.
UNSIGNED_INT_10F_11F_11F_REV
:
case
gl
.
UNSIGNED_INT_24_8
:
case
gl
.
FLOAT_32_UNSIGNED_INT_24_8_REV
:
case
gl
.
UNSIGNED_INT_5_9_9_9_REV
:
align_
=
false
;
break
;
default
:
throw
new
Error
(
'
Unsupported
format
'
)
;
}
var
pxSize
=
fmt
.
getPixelSize
(
)
;
return
{
format
:
fmt
pixelSize
:
pxSize
align
:
align_
}
;
}
;
es3fReadPixelTests
.
ReadPixelsTest
.
prototype
.
clearColor
=
function
(
reference
align
pixelSize
)
{
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
level0
=
reference
.
getLevel
(
0
)
;
var
rnd
=
new
deRandom
.
Random
(
this
.
m_seed
)
;
var
framebuffer
;
var
renderbuffer
;
var
red
;
var
green
;
var
blue
;
var
alpha
;
var
color
;
if
(
this
.
m_format
=
=
=
gl
.
RGBA_INTEGER
)
{
if
(
this
.
m_type
=
=
=
gl
.
UNSIGNED_INT
)
{
renderbuffer
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
renderbuffer
)
;
gl
.
renderbufferStorage
(
gl
.
RENDERBUFFER
gl
.
RGBA32UI
this
.
m_width
this
.
m_height
)
;
}
else
if
(
this
.
m_type
=
=
=
gl
.
INT
)
{
renderbuffer
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
renderbuffer
)
;
gl
.
renderbufferStorage
(
gl
.
RENDERBUFFER
gl
.
RGBA32I
this
.
m_width
this
.
m_height
)
;
}
else
throw
new
Error
(
'
Type
not
supported
'
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
renderbuffer
)
;
framebuffer
=
gl
.
createFramebuffer
(
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
framebuffer
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
renderbuffer
)
;
}
else
if
(
this
.
m_format
=
=
=
gl
.
RGBA
|
|
this
.
m_format
=
=
=
gl
.
RGB
)
{
}
else
throw
new
Error
(
'
Format
not
supported
'
)
;
gl
.
viewport
(
0
0
width
height
)
;
if
(
this
.
m_format
=
=
=
gl
.
RGBA
|
|
this
.
m_format
=
=
=
gl
.
RGB
)
{
red
=
rnd
.
getFloat
(
)
;
green
=
rnd
.
getFloat
(
)
;
blue
=
rnd
.
getFloat
(
)
;
alpha
=
rnd
.
getFloat
(
)
;
color
=
[
red
green
blue
alpha
]
;
gl
.
clearColor
(
red
green
blue
alpha
)
;
bufferedLogToConsole
(
'
ClearColor
:
(
'
+
red
+
'
'
+
green
+
'
'
+
blue
+
'
)
'
)
;
gl
.
clearBufferfv
(
gl
.
COLOR
0
color
)
;
level0
.
clear
(
color
)
;
}
else
if
(
this
.
m_format
=
=
=
gl
.
RGBA_INTEGER
)
{
if
(
this
.
m_type
=
=
=
gl
.
INT
)
{
red
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
green
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
blue
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
alpha
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
color
=
[
red
green
blue
alpha
]
;
bufferedLogToConsole
(
'
ClearColor
:
(
'
+
red
+
'
'
+
green
+
'
'
+
blue
+
'
)
'
)
;
gl
.
clearBufferiv
(
gl
.
COLOR
0
color
)
;
level0
.
clear
(
[
red
green
blue
alpha
]
)
;
}
else
if
(
this
.
m_type
=
=
=
gl
.
UNSIGNED_INT
)
{
red
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
green
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
blue
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
alpha
=
Math
.
abs
(
rnd
.
getInt
(
)
)
;
color
=
[
red
green
blue
alpha
]
;
bufferedLogToConsole
(
'
ClearColor
:
(
'
+
red
+
'
'
+
green
+
'
'
+
blue
+
'
)
'
)
;
gl
.
clearBufferuiv
(
gl
.
COLOR
0
color
)
;
level0
.
clear
(
color
)
;
}
else
throw
new
Error
(
'
Type
not
supported
.
'
)
;
}
else
throw
new
Error
(
'
Format
not
supported
.
'
)
;
this
.
render
(
reference
)
;
var
rowWidth
=
(
this
.
m_rowLength
=
=
=
0
?
this
.
m_width
:
this
.
m_rowLength
)
+
this
.
m_skipPixels
;
var
rowPitch
=
(
align
?
this
.
m_alignment
*
Math
.
ceil
(
pixelSize
*
rowWidth
/
this
.
m_alignment
)
:
rowWidth
*
pixelSize
)
;
var
arrayType
=
tcuTexture
.
getTypedArray
(
reference
.
getFormat
(
)
.
type
)
;
var
pixelData
=
new
arrayType
(
rowPitch
*
(
this
.
m_height
+
this
.
m_skipRows
)
)
;
gl
.
readPixels
(
0
0
this
.
m_width
this
.
m_height
this
.
m_format
this
.
m_type
pixelData
)
;
if
(
framebuffer
)
gl
.
deleteFramebuffer
(
framebuffer
)
;
if
(
renderbuffer
)
gl
.
deleteRenderbuffer
(
renderbuffer
)
;
return
pixelData
;
}
;
es3fReadPixelTests
.
ReadPixelsTest
.
prototype
.
iterate
=
function
(
)
{
var
format
=
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
;
var
pixelSize
;
var
align
;
var
formatInfo
=
this
.
getFormatInfo
(
)
;
format
=
formatInfo
.
format
;
align
=
formatInfo
.
align
;
pixelSize
=
formatInfo
.
pixelSize
;
bufferedLogToConsole
(
'
Format
:
'
+
this
.
m_format
+
'
Type
:
'
+
this
.
m_type
)
;
var
reference
=
new
tcuTexture
.
Texture2D
(
format
this
.
m_width
this
.
m_height
)
;
reference
.
allocLevel
(
0
)
;
var
level0
=
reference
.
getLevel
(
0
)
;
this
.
m_alignment
=
(
gl
.
getParameter
(
gl
.
PACK_ALIGNMENT
)
)
;
bufferedLogToConsole
(
'
gl
.
PACK_ALIGNMENT
:
'
+
this
.
m_alignment
)
;
this
.
m_rowLength
=
(
gl
.
getParameter
(
gl
.
PACK_ROW_LENGTH
)
)
;
bufferedLogToConsole
(
'
gl
.
PACK_ROW_LENGTH
:
'
+
this
.
m_rowLength
)
;
this
.
m_skipRows
=
(
gl
.
getParameter
(
gl
.
PACK_SKIP_ROWS
)
)
;
bufferedLogToConsole
(
'
gl
.
PACK_SKIP_ROWS
:
'
+
this
.
m_skipRows
)
;
this
.
m_skipPixels
=
(
gl
.
getParameter
(
gl
.
PACK_SKIP_PIXELS
)
)
;
bufferedLogToConsole
(
'
gl
.
PACK_SKIP_PIXELS
:
'
+
this
.
m_skipPixels
)
;
gl
.
viewport
(
0
0
this
.
m_width
this
.
m_height
)
;
var
pixelData
=
this
.
clearColor
(
reference
align
pixelSize
)
;
var
rowWidth
=
(
this
.
m_rowLength
=
=
=
0
?
this
.
m_width
:
this
.
m_rowLength
)
;
var
rowPitch
=
(
align
?
this
.
m_alignment
*
Math
.
ceil
(
pixelSize
*
rowWidth
/
this
.
m_alignment
)
:
rowWidth
*
pixelSize
)
;
var
formatBitDepths
=
[
]
;
var
redThreshold
;
var
greenThreshold
;
var
blueThreshold
;
var
alphaThreshold
;
var
redBits
=
(
gl
.
getParameter
(
gl
.
RED_BITS
)
)
;
var
blueBits
=
(
gl
.
getParameter
(
gl
.
BLUE_BITS
)
)
;
var
greenBits
=
(
gl
.
getParameter
(
gl
.
GREEN_BITS
)
)
;
var
alphaBits
=
(
gl
.
getParameter
(
gl
.
ALPHA_BITS
)
)
;
var
threshold
;
var
result
;
if
(
this
.
m_format
!
=
=
gl
.
RGBA_INTEGER
&
&
(
gl
.
getParameter
(
gl
.
SAMPLES
)
)
>
1
)
{
formatBitDepths
=
tcuTextureUtil
.
getTextureFormatBitDepth
(
format
)
;
redThreshold
=
Math
.
ceil
(
256
.
0
*
(
2
.
0
/
(
1
<
<
Math
.
min
(
redBits
formatBitDepths
[
0
]
)
)
)
)
;
greenThreshold
=
Math
.
ceil
(
256
.
0
*
(
2
.
0
/
(
1
<
<
Math
.
min
(
greenBits
formatBitDepths
[
1
]
)
)
)
)
;
blueThreshold
=
Math
.
ceil
(
256
.
0
*
(
2
.
0
/
(
1
<
<
Math
.
min
(
blueBits
formatBitDepths
[
2
]
)
)
)
)
;
alphaThreshold
=
Math
.
ceil
(
256
.
0
*
(
2
.
0
/
(
1
<
<
Math
.
min
(
alphaBits
formatBitDepths
[
3
]
)
)
)
)
;
result
=
tcuTexture
.
PixelBufferAccess
.
newFromTextureFormat
(
format
this
.
m_width
this
.
m_height
1
rowPitch
0
pixelData
.
buffer
)
;
threshold
=
new
tcuRGBA
.
RGBA
(
[
redThreshold
greenThreshold
blueThreshold
alphaThreshold
]
)
;
if
(
tcuImageCompare
.
bilinearCompare
(
'
Result
'
'
Result
'
level0
result
threshold
)
)
testPassedOptions
(
'
Pass
'
true
)
;
else
testFailedOptions
(
'
Fail
'
false
)
;
}
else
{
formatBitDepths
=
tcuTextureUtil
.
getTextureFormatBitDepth
(
format
)
;
redThreshold
=
2
.
0
/
(
1
<
<
Math
.
min
(
redBits
formatBitDepths
[
0
]
)
)
;
greenThreshold
=
2
.
0
/
(
1
<
<
Math
.
min
(
greenBits
formatBitDepths
[
1
]
)
)
;
blueThreshold
=
2
.
0
/
(
1
<
<
Math
.
min
(
blueBits
formatBitDepths
[
2
]
)
)
;
alphaThreshold
=
2
.
0
/
(
1
<
<
Math
.
min
(
alphaBits
formatBitDepths
[
3
]
)
)
;
result
=
new
tcuTexture
.
PixelBufferAccess
(
{
format
:
format
width
:
this
.
m_width
height
:
this
.
m_height
rowPitch
:
rowPitch
data
:
pixelData
.
buffer
offset
:
pixelSize
*
this
.
m_skipPixels
+
this
.
m_skipRows
*
rowPitch
}
)
;
threshold
=
[
redThreshold
greenThreshold
blueThreshold
alphaThreshold
]
;
if
(
tcuImageCompare
.
floatThresholdCompare
(
'
Result
'
'
Result
'
level0
result
threshold
)
)
testPassedOptions
(
'
Pass
'
true
)
;
else
testFailedOptions
(
'
Fail
'
false
)
;
}
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fReadPixelTests
.
ReadPixelTests
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
read_pixels
'
'
ReadPixel
tests
'
)
;
}
;
es3fReadPixelTests
.
ReadPixelTests
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fReadPixelTests
.
ReadPixelTests
.
prototype
.
constructor
=
es3fReadPixelTests
.
ReadPixelTests
;
es3fReadPixelTests
.
ReadPixelTests
.
prototype
.
init
=
function
(
)
{
var
groupAlignment
=
tcuTestCase
.
newTest
(
'
alignment
'
'
Read
pixels
pack
alignment
parameter
tests
'
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_1
'
'
'
false
1
0
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_2
'
'
'
false
2
0
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_4
'
'
'
false
4
0
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_8
'
'
'
false
8
0
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_1
'
'
'
false
1
0
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_2
'
'
'
false
2
0
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_4
'
'
'
false
4
0
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_8
'
'
'
false
8
0
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_1
'
'
'
false
1
0
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_2
'
'
'
false
2
0
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_4
'
'
'
false
4
0
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_8
'
'
'
false
8
0
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_1
'
'
'
true
1
0
0
0
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_2
'
'
'
true
2
0
0
0
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_4
'
'
'
true
4
0
0
0
)
)
;
groupAlignment
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_8
'
'
'
true
8
0
0
0
)
)
;
this
.
addChild
(
groupAlignment
)
;
var
groupRowLength
=
tcuTestCase
.
newTest
(
'
rowlength
'
'
Read
pixels
rowlength
test
'
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_17
'
'
'
false
4
17
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_19
'
'
'
false
4
19
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_23
'
'
'
false
4
23
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_29
'
'
'
false
4
29
0
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_17
'
'
'
false
4
17
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_19
'
'
'
false
4
19
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_23
'
'
'
false
4
23
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_29
'
'
'
false
4
29
0
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_17
'
'
'
false
4
17
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_19
'
'
'
false
4
19
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_23
'
'
'
false
4
23
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_29
'
'
'
false
4
29
0
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_17
'
'
'
true
4
17
0
0
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_19
'
'
'
true
4
19
0
0
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_23
'
'
'
true
4
23
0
0
)
)
;
groupRowLength
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_29
'
'
'
true
4
29
0
0
)
)
;
this
.
addChild
(
groupRowLength
)
;
var
groupSkip
=
tcuTestCase
.
newTest
(
'
skip
'
'
Read
pixels
skip
pixels
and
rows
test
'
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_0_3
'
'
'
false
4
17
0
3
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_3_0
'
'
'
false
4
17
3
0
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_3_3
'
'
'
false
4
17
3
3
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_ubyte_3_5
'
'
'
false
4
17
3
5
gl
.
RGBA
gl
.
UNSIGNED_BYTE
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_0_3
'
'
'
false
4
17
0
3
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_3_0
'
'
'
false
4
17
3
0
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_3_3
'
'
'
false
4
17
3
3
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_int_3_5
'
'
'
false
4
17
3
5
gl
.
RGBA_INTEGER
gl
.
INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_0_3
'
'
'
false
4
17
0
3
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_3_0
'
'
'
false
4
17
3
0
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_3_3
'
'
'
false
4
17
3
3
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
rgba_uint_3_5
'
'
'
false
4
17
3
5
gl
.
RGBA_INTEGER
gl
.
UNSIGNED_INT
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_0_3
'
'
'
true
4
17
0
3
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_3_0
'
'
'
true
4
17
3
0
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_3_3
'
'
'
true
4
17
3
3
)
)
;
groupSkip
.
addChild
(
new
es3fReadPixelTests
.
ReadPixelsTest
(
'
choose_3_5
'
'
'
true
4
17
3
5
)
)
;
this
.
addChild
(
groupSkip
)
;
}
;
es3fReadPixelTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
state
.
setRoot
(
new
es3fReadPixelTests
.
ReadPixelTests
(
)
)
;
setCurrentTestName
(
state
.
testCases
.
fullName
(
)
)
;
description
(
state
.
testCases
.
getDescription
(
)
)
;
try
{
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fReadPixelTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
