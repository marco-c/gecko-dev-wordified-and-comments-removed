'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fTextureWrapTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuCompressedTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuPixelFormat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexLookupVerifier
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTexture
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsTextureTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
gl
;
var
es3fTextureWrapTests
=
functional
.
gles3
.
es3fTextureWrapTests
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
gluTexture
=
framework
.
opengl
.
gluTexture
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
glsTextureTestUtil
=
modules
.
shared
.
glsTextureTestUtil
;
var
tcuCompressedTexture
=
framework
.
common
.
tcuCompressedTexture
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
tcuPixelFormat
=
framework
.
common
.
tcuPixelFormat
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTexLookupVerifier
=
framework
.
common
.
tcuTexLookupVerifier
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
Viewport
=
{
WIDTH
:
256
HEIGHT
:
256
}
;
es3fTextureWrapTests
.
Case
=
function
(
bl
tr
)
{
this
.
bottomLeft
=
bl
|
|
null
;
this
.
topRight
=
tr
|
|
null
;
}
;
es3fTextureWrapTests
.
TextureWrapCase
=
function
(
name
description
compressedFormat
wrapS
wrapT
minFilter
magFilter
width
height
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_format
=
gl
.
NONE
;
this
.
m_dataType
=
gl
.
NONE
;
this
.
m_compressedFormat
=
compressedFormat
;
this
.
m_wrapS
=
wrapS
;
this
.
m_wrapT
=
wrapT
;
this
.
m_minFilter
=
minFilter
;
this
.
m_magFilter
=
magFilter
;
this
.
m_width
=
width
;
this
.
m_height
=
height
;
this
.
m_cases
=
[
]
;
this
.
m_caseNdx
=
0
;
this
.
m_texture
=
null
;
this
.
m_renderer
=
new
glsTextureTestUtil
.
TextureRenderer
(
gluShaderUtil
.
getGLSLVersionString
(
gluShaderUtil
.
GLSLVersion
.
V300_ES
)
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
)
;
}
;
es3fTextureWrapTests
.
TextureWrapCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fTextureWrapTests
.
TextureWrapCase
.
prototype
.
constructor
=
es3fTextureWrapTests
.
TextureWrapCase
;
es3fTextureWrapTests
.
textureWrapCaseFromFormat
=
function
(
name
description
format
dataType
wrapS
wrapT
minFilter
magFilter
width
height
)
{
var
texWrapCase
=
new
es3fTextureWrapTests
.
TextureWrapCase
(
name
description
null
wrapS
wrapT
minFilter
magFilter
width
height
)
;
texWrapCase
.
m_format
=
gl
.
RGBA
;
texWrapCase
.
m_dataType
=
gl
.
UNSIGNED_BYTE
;
return
texWrapCase
;
}
;
es3fTextureWrapTests
.
TextureWrapCase
.
prototype
.
init
=
function
(
)
{
if
(
this
.
m_compressedFormat
!
=
=
null
)
{
assertMsgOptions
(
this
.
m_format
=
=
gl
.
NONE
&
&
this
.
m_dataType
=
=
gl
.
NONE
'
init
/
compressedFormat
'
false
true
)
;
if
(
tcuCompressedTexture
.
isEtcFormat
(
this
.
m_compressedFormat
)
)
{
var
compressedTexture
=
new
tcuCompressedTexture
.
CompressedTexture
(
this
.
m_compressedFormat
this
.
m_width
this
.
m_height
)
;
var
dataSize
=
compressedTexture
.
getDataSize
(
)
;
var
data
=
compressedTexture
.
getData
(
)
;
var
rnd
=
new
deRandom
.
Random
(
deString
.
deStringHash
(
this
.
name
)
)
;
for
(
var
i
=
0
;
i
<
dataSize
;
i
+
+
)
data
[
i
]
=
rnd
.
getFloat
(
)
&
0xff
;
this
.
m_texture
=
gluTexture
.
texture2DFromCompressedTexture
(
gl
1
[
compressedTexture
]
)
;
}
else
throw
new
Error
(
'
Only
ETC2
and
EAC
are
supported
.
'
)
;
}
else
{
this
.
m_texture
=
gluTexture
.
texture2DFromFormat
(
gl
this
.
m_format
this
.
m_dataType
this
.
m_width
this
.
m_height
)
;
this
.
m_texture
.
getRefTexture
(
)
.
allocLevel
(
0
)
;
tcuTextureUtil
.
fillWithComponentGradients
(
this
.
m_texture
.
getRefTexture
(
)
.
getLevel
(
0
)
[
-
0
.
5
-
0
.
5
-
0
.
5
2
.
0
]
[
1
.
0
1
.
0
1
.
0
0
.
0
]
)
;
this
.
m_texture
.
upload
(
)
;
}
this
.
m_cases
.
push
(
new
es3fTextureWrapTests
.
Case
(
[
-
1
.
5
-
3
.
0
]
[
1
.
5
2
.
5
]
)
)
;
this
.
m_cases
.
push
(
new
es3fTextureWrapTests
.
Case
(
[
-
0
.
5
0
.
75
]
[
0
.
25
1
.
25
]
)
)
;
assertMsgOptions
(
this
.
m_caseNdx
=
=
0
'
m_caseNdx
!
=
0
'
false
true
)
;
}
;
es3fTextureWrapTests
.
TextureWrapCase
.
prototype
.
iterate
=
function
(
)
{
var
viewport
=
new
glsTextureTestUtil
.
RandomViewport
(
gl
.
canvas
Viewport
.
WIDTH
Viewport
.
HEIGHT
deString
.
deStringHash
(
this
.
name
)
+
this
.
m_caseNdx
)
;
var
renderedFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
referenceFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
refParams
=
new
glsTextureTestUtil
.
ReferenceParams
(
glsTextureTestUtil
.
textureType
.
TEXTURETYPE_2D
)
;
var
texFormat
=
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
;
var
texCoord
;
var
texFormatInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
texFormat
)
;
var
useDefaultColorScaleAndBias
=
true
;
gl
.
activeTexture
(
gl
.
TEXTURE0
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
this
.
m_wrapS
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
this
.
m_wrapT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
this
.
m_minFilter
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
this
.
m_magFilter
)
;
refParams
.
sampler
=
gluTextureUtil
.
mapGLSamplerWrapST
(
this
.
m_wrapS
this
.
m_wrapT
this
.
m_minFilter
this
.
m_magFilter
)
;
refParams
.
lodMode
=
glsTextureTestUtil
.
lodMode
.
EXACT
;
refParams
.
samplerType
=
glsTextureTestUtil
.
getSamplerType
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
refParams
.
colorScale
=
useDefaultColorScaleAndBias
?
texFormatInfo
.
lookupScale
:
[
1
.
0
1
.
0
1
.
0
1
.
0
]
;
refParams
.
colorBias
=
useDefaultColorScaleAndBias
?
texFormatInfo
.
lookupBias
:
[
0
0
0
0
]
;
gl
.
viewport
(
viewport
.
x
viewport
.
y
viewport
.
width
viewport
.
height
)
;
texCoord
=
glsTextureTestUtil
.
computeQuadTexCoord2D
(
this
.
m_cases
[
this
.
m_caseNdx
]
.
bottomLeft
this
.
m_cases
[
this
.
m_caseNdx
]
.
topRight
)
;
this
.
m_renderer
.
renderQuad
(
0
texCoord
refParams
)
;
var
pixelSize
=
renderedFrame
.
getAccess
(
)
.
getFormat
(
)
.
getPixelSize
(
)
;
var
param
=
deMath
.
deIsPowerOfTwo32
(
pixelSize
)
?
Math
.
min
(
pixelSize
8
)
:
1
;
gl
.
pixelStorei
(
gl
.
PACK_ALIGNMENT
param
)
;
var
format
=
gluTextureUtil
.
getTransferFormat
(
renderedFrame
.
getAccess
(
)
.
getFormat
(
)
)
;
renderedFrame
.
readViewport
(
gl
viewport
)
;
var
isNearestOnly
=
this
.
m_minFilter
=
=
gl
.
NEAREST
&
&
this
.
m_magFilter
=
=
gl
.
NEAREST
;
var
isSRGB
=
texFormat
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGB
|
|
texFormat
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGBA
;
var
pixelFormat
=
new
tcuPixelFormat
.
PixelFormat
(
8
8
8
8
)
;
var
colorBits
=
deMath
.
max
(
deMath
.
subtract
(
glsTextureTestUtil
.
getBitsVec
(
pixelFormat
)
(
isNearestOnly
&
&
!
isSRGB
?
[
1
1
1
1
]
:
[
2
2
2
2
]
)
)
[
0
0
0
0
]
)
;
var
lodPrecision
=
new
tcuTexLookupVerifier
.
LodPrecision
(
18
5
)
;
var
lookupPrecision
=
new
tcuTexLookupVerifier
.
LookupPrecision
(
[
20
20
0
]
[
5
5
0
]
deMath
.
divide
(
tcuTexLookupVerifier
.
computeFixedPointThreshold
(
colorBits
)
refParams
.
colorScale
)
glsTextureTestUtil
.
getCompareMask
(
pixelFormat
)
)
;
var
isOk
=
glsTextureTestUtil
.
verifyTexture2DResult
(
renderedFrame
.
getAccess
(
)
this
.
m_texture
.
getRefTexture
(
)
texCoord
refParams
lookupPrecision
lodPrecision
pixelFormat
)
;
if
(
!
isOk
)
testFailedOptions
(
'
Case
'
+
this
.
m_caseNdx
+
'
:
verifyTexture2DResult
is
false
'
false
)
;
else
testPassedOptions
(
'
Case
'
+
this
.
m_caseNdx
+
'
:
OK
'
true
)
;
this
.
m_caseNdx
+
+
;
return
this
.
m_caseNdx
<
this
.
m_cases
.
length
?
tcuTestCase
.
IterateResult
.
CONTINUE
:
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fTextureWrapTests
.
init
=
function
(
)
{
var
testGroup
=
tcuTestCase
.
runner
.
testCases
;
var
name
;
var
WrapMode
=
function
(
name
mode
)
{
this
.
name
=
name
;
this
.
mode
=
mode
;
}
;
var
wrapModes
=
[
new
WrapMode
(
'
clamp
'
gl
.
CLAMP_TO_EDGE
)
new
WrapMode
(
'
repeat
'
gl
.
REPEAT
)
new
WrapMode
(
'
mirror
'
gl
.
MIRRORED_REPEAT
)
]
;
var
FilteringMode
=
function
(
name
mode
)
{
this
.
name
=
name
;
this
.
mode
=
mode
;
}
;
var
filteringModes
=
[
new
FilteringMode
(
'
nearest
'
gl
.
NEAREST
)
new
FilteringMode
(
'
linear
'
gl
.
LINEAR
)
]
;
var
Rgba8Size
=
function
(
name
width
height
)
{
this
.
name
=
name
;
this
.
width
=
width
;
this
.
height
=
height
;
}
;
var
rgba8Sizes
=
[
new
Rgba8Size
(
'
pot
'
64
128
)
new
Rgba8Size
(
'
npot
'
63
112
)
]
;
for
(
var
size
=
0
;
size
<
rgba8Sizes
.
length
;
size
+
+
)
{
var
rgba8Group
=
tcuTestCase
.
newTest
(
'
rgba8
'
'
'
)
;
testGroup
.
addChild
(
rgba8Group
)
;
for
(
var
wrapS
=
0
;
wrapS
<
wrapModes
.
length
;
wrapS
+
+
)
{
for
(
var
wrapT
=
0
;
wrapT
<
wrapModes
.
length
;
wrapT
+
+
)
{
for
(
var
filter
=
0
;
filter
<
filteringModes
.
length
;
filter
+
+
)
{
name
=
[
wrapModes
[
wrapS
]
.
name
wrapModes
[
wrapT
]
.
name
filteringModes
[
filter
]
.
name
rgba8Sizes
[
size
]
.
name
]
.
join
(
'
_
'
)
;
rgba8Group
.
addChild
(
es3fTextureWrapTests
.
textureWrapCaseFromFormat
(
name
'
'
gl
.
RGBA
gl
.
UNSIGNED_BYTE
wrapModes
[
wrapS
]
.
mode
wrapModes
[
wrapT
]
.
mode
filteringModes
[
filter
]
.
mode
filteringModes
[
filter
]
.
mode
rgba8Sizes
[
size
]
.
width
rgba8Sizes
[
size
]
.
height
)
)
;
}
}
}
}
var
Etc2Format
=
function
(
name
format
)
{
this
.
name
=
name
;
this
.
format
=
format
;
}
;
var
etc2Formats
=
[
new
Etc2Format
(
'
eac_r11
'
tcuCompressedTexture
.
Format
.
EAC_R11
)
new
Etc2Format
(
'
eac_signed_r11
'
tcuCompressedTexture
.
Format
.
EAC_SIGNED_R11
)
new
Etc2Format
(
'
eac_rg11
'
tcuCompressedTexture
.
Format
.
EAC_RG11
)
new
Etc2Format
(
'
eac_signed_rg11
'
tcuCompressedTexture
.
Format
.
EAC_SIGNED_RG11
)
new
Etc2Format
(
'
etc2_rgb8
'
tcuCompressedTexture
.
Format
.
ETC2_RGB8
)
new
Etc2Format
(
'
etc2_srgb8
'
tcuCompressedTexture
.
Format
.
ETC2_SRGB8
)
new
Etc2Format
(
'
etc2_rgb8_punchthrough_alpha1
'
tcuCompressedTexture
.
Format
.
ETC2_RGB8_PUNCHTHROUGH_ALPHA1
)
new
Etc2Format
(
'
etc2_srgb8_punchthrough_alpha1
'
tcuCompressedTexture
.
Format
.
ETC2_SRGB8_PUNCHTHROUGH_ALPHA1
)
new
Etc2Format
(
'
etc2_eac_rgba8
'
tcuCompressedTexture
.
Format
.
ETC2_EAC_RGBA8
)
new
Etc2Format
(
'
etc2_eac_srgb8_alpha8
'
tcuCompressedTexture
.
Format
.
ETC2_EAC_SRGB8_ALPHA8
)
]
;
var
Etc2Size
=
function
(
name
width
height
)
{
this
.
name
=
name
;
this
.
width
=
width
;
this
.
height
=
height
;
}
;
var
etc2Sizes
=
[
new
Etc2Size
(
'
pot
'
64
128
)
new
Etc2Size
(
'
npot
'
123
107
)
]
;
for
(
var
formatNdx
=
0
;
formatNdx
<
etc2Formats
.
length
;
formatNdx
+
+
)
{
for
(
var
size
=
0
;
size
<
etc2Sizes
.
length
;
size
+
+
)
{
var
formatGroup
=
tcuTestCase
.
newTest
(
etc2Formats
[
formatNdx
]
.
name
'
'
)
;
testGroup
.
addChild
(
formatGroup
)
;
for
(
var
wrapS
=
0
;
wrapS
<
wrapModes
.
length
;
wrapS
+
+
)
{
for
(
var
wrapT
=
0
;
wrapT
<
wrapModes
.
length
;
wrapT
+
+
)
{
for
(
var
filter
=
0
;
filter
<
filteringModes
.
length
;
filter
+
+
)
{
name
=
[
wrapModes
[
wrapS
]
.
name
wrapModes
[
wrapT
]
.
name
filteringModes
[
filter
]
.
name
etc2Sizes
[
size
]
.
name
]
.
join
(
'
_
'
)
;
formatGroup
.
addChild
(
new
es3fTextureWrapTests
.
TextureWrapCase
(
name
'
'
etc2Formats
[
formatNdx
]
.
format
wrapModes
[
wrapS
]
.
mode
wrapModes
[
wrapT
]
.
mode
filteringModes
[
filter
]
.
mode
filteringModes
[
filter
]
.
mode
etc2Sizes
[
size
]
.
width
etc2Sizes
[
size
]
.
height
)
)
;
}
}
}
}
}
}
;
es3fTextureWrapTests
.
run
=
function
(
context
range
)
{
gl
=
context
;
var
testName
=
'
texture_wrap
'
;
var
testDescription
=
'
Texture
Wrap
Tests
'
;
var
state
=
tcuTestCase
.
runner
;
state
.
testName
=
testName
;
state
.
setRoot
(
tcuTestCase
.
newTest
(
testName
testDescription
null
)
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
es3fTextureWrapTests
.
init
(
)
;
if
(
range
)
state
.
setRange
(
range
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fTextureWrapTests
.
run
tests
'
false
)
;
state
.
terminate
(
)
;
}
}
;
}
)
;
