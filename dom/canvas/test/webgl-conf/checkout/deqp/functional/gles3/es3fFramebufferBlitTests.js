'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fFramebufferBlitTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrGLContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrReferenceContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrUtil
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestCase
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fFramebufferBlitTests
=
functional
.
gles3
.
es3fFramebufferBlitTests
;
var
es3fFboTestCase
=
functional
.
gles3
.
es3fFboTestCase
;
var
es3fFboTestUtil
=
functional
.
gles3
.
es3fFboTestUtil
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
rrUtil
=
framework
.
referencerenderer
.
rrUtil
;
var
sglrReferenceContext
=
framework
.
opengl
.
simplereference
.
sglrReferenceContext
;
var
sglrGLContext
=
framework
.
opengl
.
simplereference
.
sglrGLContext
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
var
gl
;
es3fFramebufferBlitTests
.
BlitRectCase
=
function
(
name
desc
filter
srcSize
srcRect
dstSize
dstRect
cellSize
)
{
es3fFboTestCase
.
FboTestCase
.
call
(
this
name
desc
)
;
this
.
m_filter
=
filter
;
this
.
m_srcSize
=
srcSize
;
this
.
m_srcRect
=
srcRect
;
this
.
m_dstSize
=
dstSize
;
this
.
m_dstRect
=
dstRect
;
this
.
m_cellSize
=
cellSize
=
=
=
undefined
?
8
:
cellSize
;
this
.
m_gridCellColorA
=
[
0
.
2
0
.
7
0
.
1
1
.
0
]
;
this
.
m_gridCellColorB
=
[
0
.
7
0
.
1
0
.
5
0
.
8
]
;
}
;
es3fFramebufferBlitTests
.
BlitRectCase
.
prototype
=
Object
.
create
(
es3fFboTestCase
.
FboTestCase
.
prototype
)
;
es3fFramebufferBlitTests
.
BlitRectCase
.
prototype
.
constructor
=
es3fFramebufferBlitTests
.
BlitRectCase
;
es3fFramebufferBlitTests
.
BlitRectCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
colorFormat
=
gl
.
RGBA8
;
var
gradShader
=
new
es3fFboTestUtil
.
GradientShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
texShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
gradShaderID
=
ctx
.
createProgram
(
gradShader
)
;
var
texShaderID
=
ctx
.
createProgram
(
texShader
)
;
var
srcFbo
;
var
dstFbo
;
var
srcRbo
;
var
dstRbo
;
gradShader
.
setGradient
(
ctx
gradShaderID
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
texShader
.
setUniforms
(
ctx
texShaderID
)
;
var
size
;
srcFbo
=
ctx
.
createFramebuffer
(
)
;
srcRbo
=
ctx
.
createRenderbuffer
(
)
;
size
=
this
.
m_srcSize
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
srcRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
colorFormat
size
[
0
]
size
[
1
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
srcFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
srcRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
dstFbo
=
ctx
.
createFramebuffer
(
)
;
dstRbo
=
ctx
.
createRenderbuffer
(
)
;
size
=
this
.
m_dstSize
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
dstRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
colorFormat
size
[
0
]
size
[
1
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
dstFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
dstRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
dstFbo
)
;
ctx
.
viewport
(
0
0
this
.
m_dstSize
[
0
]
this
.
m_dstSize
[
1
]
)
;
rrUtil
.
drawQuad
(
ctx
gradShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
var
format
=
gl
.
RGBA
;
var
dataType
=
gl
.
UNSIGNED_BYTE
;
var
texW
=
this
.
m_srcSize
[
0
]
;
var
texH
=
this
.
m_srcSize
[
1
]
;
var
gridTex
;
var
data
=
new
tcuTexture
.
TextureLevel
(
gluTextureUtil
.
mapGLTransferFormat
(
format
dataType
)
texW
texH
1
)
;
tcuTextureUtil
.
fillWithGrid
(
data
.
getAccess
(
)
this
.
m_cellSize
this
.
m_gridCellColorA
this
.
m_gridCellColorB
)
;
gridTex
=
ctx
.
createTexture
(
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
gridTex
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
ctx
.
texImage2D
(
gl
.
TEXTURE_2D
0
format
texW
texH
0
format
dataType
data
.
getAccess
(
)
.
getDataPtr
(
)
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
srcFbo
)
;
ctx
.
viewport
(
0
0
this
.
m_srcSize
[
0
]
this
.
m_srcSize
[
1
]
)
;
rrUtil
.
drawQuad
(
ctx
texShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
srcFbo
)
;
ctx
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
dstFbo
)
;
ctx
.
blitFramebuffer
(
this
.
m_srcRect
[
0
]
this
.
m_srcRect
[
1
]
this
.
m_srcRect
[
2
]
this
.
m_srcRect
[
3
]
this
.
m_dstRect
[
0
]
this
.
m_dstRect
[
1
]
this
.
m_dstRect
[
2
]
this
.
m_dstRect
[
3
]
gl
.
COLOR_BUFFER_BIT
this
.
m_filter
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
dstFbo
)
;
this
.
readPixelsUsingFormat
(
dst
0
0
this
.
m_dstSize
[
0
]
this
.
m_dstSize
[
1
]
gluTextureUtil
.
mapGLInternalFormat
(
colorFormat
)
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
;
es3fFramebufferBlitTests
.
BlitRectCase
.
prototype
.
compare
=
function
(
reference
result
)
{
var
threshold
=
[
7
7
7
7
]
;
return
tcuImageCompare
.
pixelThresholdCompare
(
'
Result
'
'
Image
comparison
result
'
reference
result
threshold
)
;
}
;
es3fFramebufferBlitTests
.
BlitNearestFilterConsistencyCase
=
function
(
name
desc
srcSize
srcRect
dstSize
dstRect
)
{
es3fFramebufferBlitTests
.
BlitRectCase
.
call
(
this
name
desc
gl
.
NEAREST
srcSize
srcRect
dstSize
dstRect
1
)
;
}
;
es3fFramebufferBlitTests
.
BlitNearestFilterConsistencyCase
.
prototype
=
Object
.
create
(
es3fFramebufferBlitTests
.
BlitRectCase
.
prototype
)
;
es3fFramebufferBlitTests
.
BlitNearestFilterConsistencyCase
.
prototype
.
constructor
=
es3fFramebufferBlitTests
.
BlitNearestFilterConsistencyCase
;
es3fFramebufferBlitTests
.
BlitNearestFilterConsistencyCase
.
prototype
.
compare
=
function
(
reference
result
)
{
assertMsgOptions
(
result
.
getWidth
(
)
=
=
reference
.
getWidth
(
)
&
&
result
.
getHeight
(
)
=
=
reference
.
getHeight
(
)
'
Reference
and
result
images
have
different
dimensions
'
false
true
)
;
DE_ASSERT
(
Math
.
min
(
this
.
m_dstRect
[
0
]
this
.
m_dstRect
[
2
]
)
>
=
0
)
;
DE_ASSERT
(
Math
.
min
(
this
.
m_dstRect
[
1
]
this
.
m_dstRect
[
3
]
)
>
=
0
)
;
var
cellColorA
=
tcuRGBA
.
newRGBAFromArray
(
this
.
m_gridCellColorA
)
;
var
cellColorB
=
tcuRGBA
.
newRGBAFromArray
(
this
.
m_gridCellColorB
)
;
var
threshold
=
tcuRGBA
.
newRGBAComponents
(
7
7
7
7
)
;
var
destinationArea
=
[
deMath
.
clamp
(
Math
.
min
(
this
.
m_dstRect
[
0
]
this
.
m_dstRect
[
2
]
)
0
result
.
getWidth
(
)
)
deMath
.
clamp
(
Math
.
min
(
this
.
m_dstRect
[
1
]
this
.
m_dstRect
[
3
]
)
0
result
.
getHeight
(
)
)
deMath
.
clamp
(
Math
.
max
(
this
.
m_dstRect
[
0
]
this
.
m_dstRect
[
2
]
)
0
result
.
getWidth
(
)
)
deMath
.
clamp
(
Math
.
max
(
this
.
m_dstRect
[
1
]
this
.
m_dstRect
[
3
]
)
0
result
.
getHeight
(
)
)
]
;
var
baseColor
=
new
tcuRGBA
.
RGBA
(
result
.
getPixel
(
destinationArea
[
0
]
destinationArea
[
1
]
)
)
;
var
signConfig
=
tcuRGBA
.
compareThreshold
(
baseColor
cellColorA
threshold
)
;
var
error
=
false
;
var
errorMask
=
new
tcuSurface
.
Surface
(
result
.
getWidth
(
)
result
.
getHeight
(
)
)
;
var
horisontalSign
=
[
]
;
var
verticalSign
=
[
]
;
errorMask
.
getAccess
(
)
.
clear
(
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
var
color
;
for
(
var
dy
=
0
;
dy
<
destinationArea
[
3
]
-
destinationArea
[
1
]
;
+
+
dy
)
{
for
(
var
dx
=
0
;
dx
<
destinationArea
[
2
]
-
destinationArea
[
0
]
;
+
+
dx
)
{
color
=
new
tcuRGBA
.
RGBA
(
result
.
getPixel
(
destinationArea
[
0
]
+
dx
destinationArea
[
1
]
+
dy
)
)
;
var
isValidColor
=
tcuRGBA
.
compareThreshold
(
color
cellColorA
threshold
)
|
|
tcuRGBA
.
compareThreshold
(
color
cellColorB
threshold
)
;
if
(
!
isValidColor
)
{
errorMask
.
setPixel
(
destinationArea
[
0
]
+
dx
destinationArea
[
1
]
+
dy
tcuRGBA
.
RGBA
.
red
.
toVec
(
)
)
;
error
=
true
;
}
}
}
if
(
error
)
{
return
false
;
}
for
(
var
dx
=
0
;
dx
<
destinationArea
[
2
]
-
destinationArea
[
0
]
;
+
+
dx
)
{
color
=
new
tcuRGBA
.
RGBA
(
result
.
getPixel
(
destinationArea
[
0
]
+
dx
destinationArea
[
1
]
)
)
;
if
(
tcuRGBA
.
compareThreshold
(
color
cellColorA
threshold
)
)
horisontalSign
[
dx
]
=
true
;
else
if
(
tcuRGBA
.
compareThreshold
(
color
cellColorB
threshold
)
)
horisontalSign
[
dx
]
=
false
;
else
DE_ASSERT
(
false
)
;
}
for
(
var
dy
=
0
;
dy
<
destinationArea
[
3
]
-
destinationArea
[
1
]
;
+
+
dy
)
{
color
=
new
tcuRGBA
.
RGBA
(
result
.
getPixel
(
destinationArea
[
0
]
destinationArea
[
1
]
+
dy
)
)
;
if
(
tcuRGBA
.
compareThreshold
(
color
cellColorA
threshold
)
)
verticalSign
[
dy
]
=
true
;
else
if
(
tcuRGBA
.
compareThreshold
(
color
cellColorB
threshold
)
)
verticalSign
[
dy
]
=
false
;
else
DE_ASSERT
(
false
)
;
}
for
(
var
dy
=
0
;
dy
<
destinationArea
[
3
]
-
destinationArea
[
1
]
;
+
+
dy
)
{
for
(
var
dx
=
0
;
dx
<
destinationArea
[
2
]
-
destinationArea
[
0
]
;
+
+
dx
)
{
color
=
new
tcuRGBA
.
RGBA
(
result
.
getPixel
(
destinationArea
[
0
]
+
dx
destinationArea
[
1
]
+
dy
)
)
;
var
resultSign
=
tcuRGBA
.
compareThreshold
(
cellColorA
color
threshold
)
;
var
correctSign
=
(
horisontalSign
[
dx
]
=
=
verticalSign
[
dy
]
)
=
=
signConfig
;
if
(
resultSign
!
=
correctSign
)
{
errorMask
.
setPixel
(
destinationArea
[
0
]
+
dx
destinationArea
[
1
]
+
dy
tcuRGBA
.
RGBA
.
red
.
toVec
(
)
)
;
error
=
true
;
}
}
}
return
!
error
;
}
;
es3fFramebufferBlitTests
.
FramebufferBlitTests
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
blit
'
'
Framebuffer
blit
tests
'
)
;
}
;
es3fFramebufferBlitTests
.
FramebufferBlitTests
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fFramebufferBlitTests
.
FramebufferBlitTests
.
prototype
.
constructor
=
es3fFramebufferBlitTests
.
FramebufferBlitTests
;
es3fFramebufferBlitTests
.
FramebufferBlitTests
.
prototype
.
init
=
function
(
)
{
var
colorFormats
=
[
gl
.
RGBA32I
gl
.
RGBA32UI
gl
.
RGBA16I
gl
.
RGBA16UI
gl
.
RGBA8
gl
.
RGBA8I
gl
.
RGBA8UI
gl
.
SRGB8_ALPHA8
gl
.
RGB10_A2
gl
.
RGB10_A2UI
gl
.
RGBA4
gl
.
RGB5_A1
gl
.
RGB8
gl
.
RGB565
gl
.
RG32I
gl
.
RG32UI
gl
.
RG16I
gl
.
RG16UI
gl
.
RG8
gl
.
RG8I
gl
.
RG8UI
gl
.
R32I
gl
.
R32UI
gl
.
R16I
gl
.
R16UI
gl
.
R8
gl
.
R8I
gl
.
R8UI
gl
.
RGBA32F
gl
.
RGBA16F
gl
.
R11F_G11F_B10F
gl
.
RG32F
gl
.
RG16F
gl
.
R32F
gl
.
R16F
]
;
var
depthStencilFormats
=
[
gl
.
DEPTH_COMPONENT32F
gl
.
DEPTH_COMPONENT24
gl
.
DEPTH_COMPONENT16
gl
.
DEPTH32F_STENCIL8
gl
.
DEPTH24_STENCIL8
gl
.
STENCIL_INDEX8
]
;
var
CopyRect
=
function
(
name
srcRect
dstRect
)
{
this
.
name
=
name
;
this
.
srcRect
=
srcRect
;
this
.
dstRect
=
dstRect
;
}
;
var
copyRects
=
[
new
CopyRect
(
'
basic
'
[
10
20
65
100
]
[
45
5
100
85
]
)
new
CopyRect
(
'
scale
'
[
10
20
65
100
]
[
25
30
125
94
]
)
new
CopyRect
(
'
out_of_bounds
'
[
-
10
-
15
100
63
]
[
50
30
136
144
]
)
]
;
var
filterConsistencyRects
=
[
new
CopyRect
(
'
mag
'
[
20
10
74
88
]
[
10
10
91
101
]
)
new
CopyRect
(
'
min
'
[
10
20
78
100
]
[
20
20
71
80
]
)
new
CopyRect
(
'
out_of_bounds_mag
'
[
21
10
73
82
]
[
11
43
141
151
]
)
new
CopyRect
(
'
out_of_bounds_min
'
[
11
21
77
97
]
[
80
82
135
139
]
)
]
;
var
Swizzle
=
function
(
name
srcSwizzle
dstSwizzle
)
{
this
.
name
=
name
;
this
.
srcSwizzle
=
srcSwizzle
;
this
.
dstSwizzle
=
dstSwizzle
;
}
;
var
swizzles
=
[
new
Swizzle
(
null
[
0
1
2
3
]
[
0
1
2
3
]
)
new
Swizzle
(
'
reverse_src_x
'
[
2
1
0
3
]
[
0
1
2
3
]
)
new
Swizzle
(
'
reverse_src_y
'
[
0
3
2
1
]
[
0
1
2
3
]
)
new
Swizzle
(
'
reverse_dst_x
'
[
0
1
2
3
]
[
2
1
0
3
]
)
new
Swizzle
(
'
reverse_dst_y
'
[
0
1
2
3
]
[
0
3
2
1
]
)
new
Swizzle
(
'
reverse_src_dst_x
'
[
2
1
0
3
]
[
2
1
0
3
]
)
new
Swizzle
(
'
reverse_src_dst_y
'
[
0
3
2
1
]
[
0
3
2
1
]
)
]
;
var
srcSize
=
[
127
119
]
;
var
dstSize
=
[
132
128
]
;
var
rectGroup
=
tcuTestCase
.
newTest
(
'
rect
'
'
Blit
rectangle
tests
'
)
;
this
.
addChild
(
rectGroup
)
;
for
(
var
rectNdx
=
0
;
rectNdx
<
copyRects
.
length
;
rectNdx
+
+
)
{
for
(
var
swzNdx
=
0
;
swzNdx
<
swizzles
.
length
;
swzNdx
+
+
)
{
var
name
=
copyRects
[
rectNdx
]
.
name
+
(
swizzles
[
swzNdx
]
.
name
?
(
'
_
'
+
swizzles
[
swzNdx
]
.
name
)
:
'
'
)
;
var
srcSwz
=
swizzles
[
swzNdx
]
.
srcSwizzle
;
var
dstSwz
=
swizzles
[
swzNdx
]
.
dstSwizzle
;
var
srcRect
=
deMath
.
swizzle
(
copyRects
[
rectNdx
]
.
srcRect
srcSwz
)
;
var
dstRect
=
deMath
.
swizzle
(
copyRects
[
rectNdx
]
.
dstRect
dstSwz
)
;
rectGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitRectCase
(
(
name
+
'
_nearest
'
)
'
'
gl
.
NEAREST
srcSize
srcRect
dstSize
dstRect
)
)
;
rectGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitRectCase
(
(
name
+
'
_linear
'
)
'
'
gl
.
LINEAR
srcSize
srcRect
dstSize
dstRect
)
)
;
}
}
for
(
var
rectNdx
=
0
;
rectNdx
<
filterConsistencyRects
.
length
;
rectNdx
+
+
)
{
for
(
var
swzNdx
=
0
;
swzNdx
<
swizzles
.
length
;
swzNdx
+
+
)
{
var
name
=
'
nearest_consistency_
'
+
filterConsistencyRects
[
rectNdx
]
.
name
+
(
swizzles
[
swzNdx
]
.
name
?
(
'
_
'
+
swizzles
[
swzNdx
]
.
name
)
:
'
'
)
;
var
srcSwz
=
swizzles
[
swzNdx
]
.
srcSwizzle
;
var
dstSwz
=
swizzles
[
swzNdx
]
.
dstSwizzle
;
var
srcRect
=
deMath
.
swizzle
(
filterConsistencyRects
[
rectNdx
]
.
srcRect
srcSwz
)
;
var
dstRect
=
deMath
.
swizzle
(
filterConsistencyRects
[
rectNdx
]
.
dstRect
dstSwz
)
;
rectGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitNearestFilterConsistencyCase
(
name
'
Test
consistency
of
the
nearest
filter
'
srcSize
srcRect
dstSize
dstRect
)
)
;
}
}
var
conversionGroup
=
tcuTestCase
.
newTest
(
'
conversion
'
'
Color
conversion
tests
'
)
;
this
.
addChild
(
conversionGroup
)
;
for
(
var
srcFmtNdx
=
0
;
srcFmtNdx
<
colorFormats
.
length
;
srcFmtNdx
+
+
)
{
for
(
var
dstFmtNdx
=
0
;
dstFmtNdx
<
colorFormats
.
length
;
dstFmtNdx
+
+
)
{
var
srcFormat
=
colorFormats
[
srcFmtNdx
]
;
var
srcTexFmt
=
gluTextureUtil
.
mapGLInternalFormat
(
srcFormat
)
;
var
srcType
=
tcuTexture
.
getTextureChannelClass
(
srcTexFmt
.
type
)
;
var
dstFormat
=
colorFormats
[
dstFmtNdx
]
;
var
dstTexFmt
=
gluTextureUtil
.
mapGLInternalFormat
(
dstFormat
)
;
var
dstType
=
tcuTexture
.
getTextureChannelClass
(
dstTexFmt
.
type
)
;
if
(
(
(
srcType
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
|
|
srcType
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
!
=
(
dstType
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
|
|
dstType
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
)
|
|
(
(
srcType
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_INTEGER
)
!
=
(
dstType
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_INTEGER
)
)
|
|
(
(
srcType
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_INTEGER
)
!
=
(
dstType
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_INTEGER
)
)
)
continue
;
var
name
=
es3fFboTestUtil
.
getFormatName
(
srcFormat
)
+
'
_to_
'
+
es3fFboTestUtil
.
getFormatName
(
dstFormat
)
;
conversionGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitColorConversionCase
(
name
'
'
srcFormat
dstFormat
[
127
113
]
)
)
;
}
}
var
depthStencilGroup
=
tcuTestCase
.
newTest
(
'
depth_stencil
'
'
Depth
and
stencil
blits
'
)
;
this
.
addChild
(
depthStencilGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
depthStencilFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
depthStencilFormats
[
fmtNdx
]
;
var
texFmt
=
gluTextureUtil
.
mapGLInternalFormat
(
format
)
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
var
depth
=
texFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
D
|
|
texFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
DS
;
var
stencil
=
texFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
S
|
|
texFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
DS
;
var
buffers
=
(
depth
?
gl
.
DEPTH_BUFFER_BIT
:
0
)
|
(
stencil
?
gl
.
STENCIL_BUFFER_BIT
:
0
)
;
depthStencilGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitDepthStencilCase
(
(
fmtName
+
'
_basic
'
)
'
'
format
buffers
[
128
128
]
[
0
0
128
128
]
buffers
[
128
128
]
[
0
0
128
128
]
buffers
)
)
;
depthStencilGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitDepthStencilCase
(
(
fmtName
+
'
_scale
'
)
'
'
format
buffers
[
127
119
]
[
10
30
100
70
]
buffers
[
111
130
]
[
20
5
80
130
]
buffers
)
)
;
if
(
depth
&
&
stencil
)
{
depthStencilGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitDepthStencilCase
(
(
fmtName
+
'
_depth_only
'
)
'
'
format
buffers
[
128
128
]
[
0
0
128
128
]
buffers
[
128
128
]
[
0
0
128
128
]
gl
.
DEPTH_BUFFER_BIT
)
)
;
depthStencilGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitDepthStencilCase
(
(
fmtName
+
'
_stencil_only
'
)
'
'
format
buffers
[
128
128
]
[
0
0
128
128
]
buffers
[
128
128
]
[
0
0
128
128
]
gl
.
STENCIL_BUFFER_BIT
)
)
;
}
}
var
Area
=
function
(
name
area
)
{
this
.
name
=
name
;
this
.
area
=
area
;
}
;
var
areas
=
[
new
Area
(
'
scale
'
es3fFramebufferBlitTests
.
BlitArea
.
AREA_SCALE
)
new
Area
(
'
out_of_bounds
'
es3fFramebufferBlitTests
.
BlitArea
.
AREA_OUT_OF_BOUNDS
)
]
;
var
defaultFbGroup
=
tcuTestCase
.
newTest
(
'
default_framebuffer
'
'
Blits
with
default
framebuffer
'
)
;
this
.
addChild
(
defaultFbGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
colorFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
colorFormats
[
fmtNdx
]
;
var
texFmt
=
gluTextureUtil
.
mapGLInternalFormat
(
format
)
;
var
fmtClass
=
tcuTexture
.
getTextureChannelClass
(
texFmt
.
type
)
;
var
filter
=
gluTextureUtil
.
isGLInternalColorFormatFilterable
(
format
)
?
gl
.
LINEAR
:
gl
.
NEAREST
;
var
filterable
=
gluTextureUtil
.
isGLInternalColorFormatFilterable
(
format
)
;
if
(
fmtClass
!
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
&
&
fmtClass
!
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
&
&
fmtClass
!
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
)
continue
;
defaultFbGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
(
es3fFboTestUtil
.
getFormatName
(
format
)
'
'
format
filter
)
)
;
for
(
var
areaNdx
=
0
;
areaNdx
<
areas
.
length
;
areaNdx
+
+
)
{
var
name
=
areas
[
areaNdx
]
.
name
;
var
addLinear
=
filterable
;
var
addNearest
=
!
addLinear
|
|
(
areas
[
areaNdx
]
.
area
!
=
es3fFramebufferBlitTests
.
BlitArea
.
AREA_OUT_OF_BOUNDS
)
;
if
(
addNearest
)
{
defaultFbGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
(
(
es3fFboTestUtil
.
getFormatName
(
format
)
+
'
_nearest_
'
+
name
+
'
_blit_from_default
'
)
'
'
format
gl
.
NEAREST
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
areas
[
areaNdx
]
.
area
)
)
;
defaultFbGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
(
(
es3fFboTestUtil
.
getFormatName
(
format
)
+
'
_nearest_
'
+
name
+
'
_blit_to_default
'
)
'
'
format
gl
.
NEAREST
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_TO_DEFAULT_FROM_TARGET
areas
[
areaNdx
]
.
area
)
)
;
}
if
(
addLinear
)
{
defaultFbGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
(
(
es3fFboTestUtil
.
getFormatName
(
format
)
+
'
_linear_
'
+
name
+
'
_blit_from_default
'
)
'
'
format
gl
.
LINEAR
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
areas
[
areaNdx
]
.
area
)
)
;
defaultFbGroup
.
addChild
(
new
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
(
(
es3fFboTestUtil
.
getFormatName
(
format
)
+
'
_linear_
'
+
name
+
'
_blit_to_default
'
)
'
'
format
gl
.
LINEAR
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_TO_DEFAULT_FROM_TARGET
areas
[
areaNdx
]
.
area
)
)
;
}
}
}
}
;
es3fFramebufferBlitTests
.
getChannelMask
=
function
(
order
)
{
switch
(
order
)
{
case
tcuTexture
.
ChannelOrder
.
R
:
return
[
true
false
false
false
]
;
case
tcuTexture
.
ChannelOrder
.
RG
:
return
[
true
true
false
false
]
;
case
tcuTexture
.
ChannelOrder
.
RGB
:
return
[
true
true
true
false
]
;
case
tcuTexture
.
ChannelOrder
.
RGBA
:
return
[
true
true
true
true
]
;
case
tcuTexture
.
ChannelOrder
.
sRGB
:
return
[
true
true
true
false
]
;
case
tcuTexture
.
ChannelOrder
.
sRGBA
:
return
[
true
true
true
true
]
;
default
:
DE_ASSERT
(
false
)
;
return
[
false
false
false
false
]
;
}
}
;
es3fFramebufferBlitTests
.
BlitColorConversionCase
=
function
(
name
desc
srcFormat
dstFormat
size
)
{
es3fFboTestCase
.
FboTestCase
.
call
(
this
name
desc
)
;
this
.
m_srcFormat
=
srcFormat
;
this
.
m_dstFormat
=
dstFormat
;
this
.
m_size
=
size
;
}
;
es3fFramebufferBlitTests
.
BlitColorConversionCase
.
prototype
=
Object
.
create
(
es3fFboTestCase
.
FboTestCase
.
prototype
)
;
es3fFramebufferBlitTests
.
BlitColorConversionCase
.
prototype
.
constructor
=
es3fFramebufferBlitTests
.
BlitColorConversionCase
;
es3fFramebufferBlitTests
.
BlitColorConversionCase
.
prototype
.
preCheck
=
function
(
)
{
this
.
checkFormatSupport
(
this
.
m_srcFormat
)
;
this
.
checkFormatSupport
(
this
.
m_dstFormat
)
;
}
;
es3fFramebufferBlitTests
.
BlitColorConversionCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
srcFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_srcFormat
)
;
var
dstFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_dstFormat
)
;
var
srcOutputType
=
es3fFboTestUtil
.
getFragmentOutputType
(
srcFormat
)
;
var
dstOutputType
=
es3fFboTestUtil
.
getFragmentOutputType
(
dstFormat
)
;
var
srcFmtRangeInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
srcFormat
)
;
var
dstFmtRangeInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
dstFormat
)
;
var
copyMask
=
deMath
.
logicalAndBool
(
es3fFramebufferBlitTests
.
getChannelMask
(
srcFormat
.
order
)
es3fFramebufferBlitTests
.
getChannelMask
(
dstFormat
.
order
)
)
;
var
srcIsGreater
=
deMath
.
greaterThan
(
deMath
.
subtract
(
srcFmtRangeInfo
.
valueMax
srcFmtRangeInfo
.
valueMin
)
deMath
.
subtract
(
dstFmtRangeInfo
.
valueMax
dstFmtRangeInfo
.
valueMin
)
)
;
var
srcRangeInfo
=
new
tcuTextureUtil
.
TextureFormatInfo
(
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
valueMin
srcFmtRangeInfo
.
valueMin
deMath
.
logicalAndBool
(
copyMask
srcIsGreater
)
)
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
valueMax
srcFmtRangeInfo
.
valueMax
deMath
.
logicalAndBool
(
copyMask
srcIsGreater
)
)
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
lookupScale
srcFmtRangeInfo
.
lookupScale
deMath
.
logicalAndBool
(
copyMask
srcIsGreater
)
)
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
lookupBias
srcFmtRangeInfo
.
lookupBias
deMath
.
logicalAndBool
(
copyMask
srcIsGreater
)
)
)
;
var
dstRangeInfo
=
new
tcuTextureUtil
.
TextureFormatInfo
(
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
valueMin
srcFmtRangeInfo
.
valueMin
deMath
.
logicalOrBool
(
deMath
.
logicalNotBool
(
copyMask
)
srcIsGreater
)
)
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
valueMax
srcFmtRangeInfo
.
valueMax
deMath
.
logicalOrBool
(
deMath
.
logicalNotBool
(
copyMask
)
srcIsGreater
)
)
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
lookupScale
srcFmtRangeInfo
.
lookupScale
deMath
.
logicalOrBool
(
deMath
.
logicalNotBool
(
copyMask
)
srcIsGreater
)
)
tcuTextureUtil
.
select
(
dstFmtRangeInfo
.
lookupBias
srcFmtRangeInfo
.
lookupBias
deMath
.
logicalOrBool
(
deMath
.
logicalNotBool
(
copyMask
)
srcIsGreater
)
)
)
;
var
gradientToSrcShader
=
new
es3fFboTestUtil
.
GradientShader
(
srcOutputType
)
;
var
gradientToDstShader
=
new
es3fFboTestUtil
.
GradientShader
(
dstOutputType
)
;
var
gradShaderSrcID
=
ctx
.
createProgram
(
gradientToSrcShader
)
;
var
gradShaderDstID
=
ctx
.
createProgram
(
gradientToDstShader
)
;
var
srcFbo
;
var
dstFbo
;
var
srcRbo
;
var
dstRbo
;
srcFbo
=
ctx
.
createFramebuffer
(
)
;
srcRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
srcRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
this
.
m_srcFormat
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
srcFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
srcRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
dstFbo
=
ctx
.
createFramebuffer
(
)
;
dstRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
dstRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
this
.
m_dstFormat
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
dstFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
dstRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
viewport
(
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
srcFbo
)
;
gradientToDstShader
.
setGradient
(
ctx
gradShaderDstID
dstRangeInfo
.
valueMin
dstRangeInfo
.
valueMax
)
;
rrUtil
.
drawQuad
(
ctx
gradShaderDstID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
dstFbo
)
;
gradientToSrcShader
.
setGradient
(
ctx
gradShaderSrcID
srcRangeInfo
.
valueMin
dstRangeInfo
.
valueMax
)
;
rrUtil
.
drawQuad
(
ctx
gradShaderSrcID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
srcFbo
)
;
ctx
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
dstFbo
)
;
ctx
.
blitFramebuffer
(
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
gl
.
COLOR_BUFFER_BIT
gl
.
NEAREST
)
;
this
.
checkError
(
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
dstFbo
)
;
this
.
readPixelsUsingFormat
(
dst
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
dstFormat
dstRangeInfo
.
lookupScale
dstRangeInfo
.
lookupBias
)
;
}
;
es3fFramebufferBlitTests
.
BlitColorConversionCase
.
prototype
.
compare
=
function
(
reference
result
)
{
var
srcFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_srcFormat
)
;
var
dstFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_dstFormat
)
;
var
srcIsSRGB
=
(
srcFormat
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGBA
)
;
var
dstIsSRGB
=
(
dstFormat
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGBA
)
;
var
threshold
=
new
tcuRGBA
.
RGBA
(
)
;
if
(
dstIsSRGB
)
threshold
=
es3fFboTestUtil
.
getToSRGBConversionThreshold
(
srcFormat
dstFormat
)
;
else
{
var
srcMaxDiff
=
es3fFboTestUtil
.
getThresholdFromTextureFormat
(
srcFormat
)
;
var
dstMaxDiff
=
es3fFboTestUtil
.
getThresholdFromTextureFormat
(
dstFormat
)
;
if
(
srcIsSRGB
)
srcMaxDiff
=
tcuRGBA
.
multiply
(
srcMaxDiff
2
)
;
threshold
=
tcuRGBA
.
max
(
srcMaxDiff
dstMaxDiff
)
;
}
return
tcuImageCompare
.
pixelThresholdCompare
(
'
Result
'
'
Image
comparison
result
'
reference
result
threshold
.
toIVec
(
)
)
;
}
;
es3fFramebufferBlitTests
.
BlitDepthStencilCase
=
function
(
name
desc
format
srcBuffers
srcSize
srcRect
dstBuffers
dstSize
dstRect
copyBuffers
)
{
es3fFboTestCase
.
FboTestCase
.
call
(
this
name
desc
)
;
this
.
m_format
=
format
;
this
.
m_srcBuffers
=
srcBuffers
;
this
.
m_srcSize
=
srcSize
;
this
.
m_srcRect
=
srcRect
;
this
.
m_dstBuffers
=
dstBuffers
;
this
.
m_dstSize
=
dstSize
;
this
.
m_dstRect
=
dstRect
;
this
.
m_copyBuffers
=
copyBuffers
;
}
;
es3fFramebufferBlitTests
.
BlitDepthStencilCase
.
prototype
=
Object
.
create
(
es3fFboTestCase
.
FboTestCase
.
prototype
)
;
es3fFramebufferBlitTests
.
BlitDepthStencilCase
.
prototype
.
constructor
=
es3fFramebufferBlitTests
.
BlitDepthStencilCase
;
es3fFramebufferBlitTests
.
BlitDepthStencilCase
.
prototype
.
preCheck
=
function
(
)
{
this
.
checkFormatSupport
(
this
.
m_format
)
;
}
;
es3fFramebufferBlitTests
.
BlitDepthStencilCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
colorFormat
=
gl
.
RGBA8
;
var
gradShader
=
new
es3fFboTestUtil
.
GradientShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
texShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShaderID
=
ctx
.
createProgram
(
flatShader
)
;
var
texShaderID
=
ctx
.
createProgram
(
texShader
)
;
var
gradShaderID
=
ctx
.
createProgram
(
gradShader
)
;
var
srcFbo
;
var
dstFbo
;
var
srcColorRbo
;
var
dstColorRbo
;
var
srcDepthStencilRbo
;
var
dstDepthStencilRbo
;
gradShader
.
setGradient
(
ctx
gradShaderID
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
texShader
.
setUniforms
(
ctx
texShaderID
)
;
srcFbo
=
ctx
.
createFramebuffer
(
)
;
srcColorRbo
=
ctx
.
createRenderbuffer
(
)
;
srcDepthStencilRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
srcColorRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
colorFormat
this
.
m_srcSize
[
0
]
this
.
m_srcSize
[
1
]
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
srcDepthStencilRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
this
.
m_format
this
.
m_srcSize
[
0
]
this
.
m_srcSize
[
1
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
srcFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
srcColorRbo
)
;
if
(
this
.
m_srcBuffers
&
gl
.
DEPTH_BUFFER_BIT
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
DEPTH_ATTACHMENT
gl
.
RENDERBUFFER
srcDepthStencilRbo
)
;
if
(
this
.
m_srcBuffers
&
gl
.
STENCIL_BUFFER_BIT
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
STENCIL_ATTACHMENT
gl
.
RENDERBUFFER
srcDepthStencilRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
clearBufferfi
(
gl
.
DEPTH_STENCIL
0
1
.
0
0
)
;
dstFbo
=
ctx
.
createFramebuffer
(
)
;
dstColorRbo
=
ctx
.
createRenderbuffer
(
)
;
dstDepthStencilRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
dstColorRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
colorFormat
this
.
m_dstSize
[
0
]
this
.
m_dstSize
[
1
]
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
dstDepthStencilRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
this
.
m_format
this
.
m_dstSize
[
0
]
this
.
m_dstSize
[
1
]
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
dstFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
dstColorRbo
)
;
if
(
this
.
m_dstBuffers
&
gl
.
DEPTH_BUFFER_BIT
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
DEPTH_ATTACHMENT
gl
.
RENDERBUFFER
dstDepthStencilRbo
)
;
if
(
this
.
m_dstBuffers
&
gl
.
STENCIL_BUFFER_BIT
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
STENCIL_ATTACHMENT
gl
.
RENDERBUFFER
dstDepthStencilRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
clearBufferfi
(
gl
.
DEPTH_STENCIL
0
1
.
0
0
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
srcFbo
)
;
ctx
.
viewport
(
0
0
this
.
m_srcSize
[
0
]
this
.
m_srcSize
[
1
]
)
;
ctx
.
enable
(
gl
.
DEPTH_TEST
)
;
ctx
.
enable
(
gl
.
STENCIL_TEST
)
;
ctx
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
REPLACE
)
;
ctx
.
stencilFunc
(
gl
.
ALWAYS
7
0xff
)
;
rrUtil
.
drawQuad
(
ctx
gradShaderID
[
-
1
-
1
-
1
]
[
1
1
1
]
)
;
var
format
=
gl
.
RGBA
;
var
dataType
=
gl
.
UNSIGNED_BYTE
;
var
texW
=
this
.
m_srcSize
[
0
]
;
var
texH
=
this
.
m_srcSize
[
1
]
;
var
gridTex
=
null
;
var
data
=
new
tcuTexture
.
TextureLevel
(
gluTextureUtil
.
mapGLTransferFormat
(
format
dataType
)
texW
texH
1
)
;
tcuTextureUtil
.
fillWithGrid
(
data
.
getAccess
(
)
8
[
0
.
2
0
.
7
0
.
1
1
.
0
]
[
0
.
7
0
.
1
0
.
5
0
.
8
]
)
;
gridTex
=
ctx
.
createTexture
(
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
gridTex
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
ctx
.
texImage2D
(
gl
.
TEXTURE_2D
0
format
texW
texH
0
format
dataType
data
.
getAccess
(
)
.
getDataPtr
(
)
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
dstFbo
)
;
ctx
.
viewport
(
0
0
this
.
m_dstSize
[
0
]
this
.
m_dstSize
[
1
]
)
;
ctx
.
stencilFunc
(
gl
.
ALWAYS
1
0xff
)
;
rrUtil
.
drawQuad
(
ctx
texShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
srcFbo
)
;
ctx
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
dstFbo
)
;
ctx
.
blitFramebuffer
(
this
.
m_srcRect
[
0
]
this
.
m_srcRect
[
1
]
this
.
m_srcRect
[
2
]
this
.
m_srcRect
[
3
]
this
.
m_dstRect
[
0
]
this
.
m_dstRect
[
1
]
this
.
m_dstRect
[
2
]
this
.
m_dstRect
[
3
]
this
.
m_copyBuffers
gl
.
NEAREST
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
dstFbo
)
;
ctx
.
viewport
(
0
0
this
.
m_dstSize
[
0
]
this
.
m_dstSize
[
1
]
)
;
ctx
.
stencilOp
(
gl
.
KEEP
gl
.
DECR
gl
.
KEEP
)
;
ctx
.
stencilFunc
(
gl
.
ALWAYS
0
0xff
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
0
.
0
0
.
0
1
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
ctx
flatShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
if
(
this
.
m_dstBuffers
&
gl
.
STENCIL_BUFFER_BIT
)
{
ctx
.
disable
(
gl
.
DEPTH_TEST
)
;
ctx
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
KEEP
)
;
ctx
.
stencilFunc
(
gl
.
EQUAL
6
0xff
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
ctx
flatShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
}
this
.
readPixelsUsingFormat
(
dst
0
0
this
.
m_dstSize
[
0
]
this
.
m_dstSize
[
1
]
gluTextureUtil
.
mapGLInternalFormat
(
colorFormat
)
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
;
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
=
function
(
name
desc
format
filter
)
{
es3fFboTestCase
.
FboTestCase
.
call
(
this
name
desc
)
;
this
.
m_format
=
format
;
this
.
m_filter
=
filter
;
}
;
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
.
prototype
=
Object
.
create
(
es3fFboTestCase
.
FboTestCase
.
prototype
)
;
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
.
prototype
.
constructor
=
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
;
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
.
prototype
.
preCheck
=
function
(
)
{
this
.
checkFormatSupport
(
this
.
m_format
)
;
}
;
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
colorFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_format
)
;
var
transferFmt
=
gluTextureUtil
.
getTransferFormat
(
colorFormat
)
;
var
gradShader
=
new
es3fFboTestUtil
.
GradientShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
texShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluTextureUtil
.
getSampler2DType
(
colorFormat
)
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
gradShaderID
=
ctx
.
createProgram
(
gradShader
)
;
var
texShaderID
=
ctx
.
createProgram
(
texShader
)
;
var
fbo
;
var
tex
;
var
texW
=
128
;
var
texH
=
128
;
gradShader
.
setGradient
(
ctx
gradShaderID
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
texShader
.
setUniforms
(
ctx
texShaderID
)
;
fbo
=
ctx
.
createFramebuffer
(
)
;
tex
=
ctx
.
createTexture
(
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
tex
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
this
.
m_filter
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
this
.
m_filter
)
;
ctx
.
texImage2D
(
gl
.
TEXTURE_2D
0
this
.
m_format
texW
texH
0
transferFmt
.
format
transferFmt
.
dataType
null
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
)
;
ctx
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
TEXTURE_2D
tex
0
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
rrUtil
.
drawQuad
(
ctx
gradShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
ctx
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
fbo
)
;
ctx
.
blitFramebuffer
(
0
0
ctx
.
getWidth
(
)
ctx
.
getHeight
(
)
0
0
texW
texH
gl
.
COLOR_BUFFER_BIT
this
.
m_filter
)
;
ctx
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
null
)
;
ctx
.
clearBufferfv
(
gl
.
COLOR
0
[
1
.
0
0
.
0
0
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
ctx
texShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
fbo
)
;
ctx
.
blitFramebuffer
(
0
0
texW
texH
Math
.
floor
(
ctx
.
getWidth
(
)
/
2
)
0
ctx
.
getWidth
(
)
ctx
.
getHeight
(
)
gl
.
COLOR_BUFFER_BIT
this
.
m_filter
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
null
)
;
this
.
readPixels
(
dst
0
0
ctx
.
getWidth
(
)
ctx
.
getHeight
(
)
)
;
}
;
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
.
prototype
.
compare
=
function
(
reference
result
)
{
var
threshold
=
tcuRGBA
.
max
(
es3fFboTestUtil
.
getFormatThreshold
(
this
.
m_format
)
tcuRGBA
.
newRGBAComponents
(
12
12
12
12
)
)
;
return
tcuImageCompare
.
bilinearCompare
(
'
Result
'
'
Image
comparison
result
'
reference
.
getAccess
(
)
result
.
getAccess
(
)
threshold
)
;
}
;
es3fFramebufferBlitTests
.
BlitDirection
=
{
BLIT_DEFAULT_TO_TARGET
:
0
BLIT_TO_DEFAULT_FROM_TARGET
:
1
}
;
es3fFramebufferBlitTests
.
BlitArea
=
{
AREA_SCALE
:
0
AREA_OUT_OF_BOUNDS
:
1
}
;
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
=
function
(
name
desc
format
filter
dir
area
)
{
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
.
call
(
this
name
desc
format
filter
)
;
this
.
m_blitDir
=
dir
;
this
.
m_blitArea
=
area
;
this
.
m_srcRect
=
[
-
1
-
1
-
1
-
1
]
;
this
.
m_dstRect
=
[
-
1
-
1
-
1
-
1
]
;
this
.
m_interestingArea
=
[
-
1
-
1
-
1
-
1
]
;
}
;
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
.
prototype
=
Object
.
create
(
es3fFramebufferBlitTests
.
BlitDefaultFramebufferCase
.
prototype
)
;
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
.
prototype
.
constructor
=
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
;
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
.
prototype
.
init
=
function
(
)
{
var
minViewportSize
=
128
;
if
(
gl
.
drawingBufferWidth
<
minViewportSize
|
|
gl
.
drawingBufferHeight
<
minViewportSize
)
throw
new
Error
(
'
Viewport
size
'
+
minViewportSize
+
'
x
'
+
minViewportSize
+
'
required
'
)
;
this
.
m_viewportWidth
=
gl
.
drawingBufferWidth
;
this
.
m_viewportHeight
=
gl
.
drawingBufferHeight
;
if
(
this
.
m_blitArea
=
=
es3fFramebufferBlitTests
.
BlitArea
.
AREA_SCALE
)
{
this
.
m_srcRect
=
[
10
20
65
100
]
;
this
.
m_dstRect
=
[
25
30
125
94
]
;
this
.
m_interestingArea
=
[
0
0
128
128
]
;
}
else
if
(
this
.
m_blitArea
=
=
es3fFramebufferBlitTests
.
BlitArea
.
AREA_OUT_OF_BOUNDS
)
{
var
ubound
=
(
this
.
m_blitDir
=
=
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
)
?
(
[
128
128
]
)
:
(
[
gl
.
drawingBufferWidth
gl
.
drawingBufferHeight
]
)
;
this
.
m_srcRect
=
[
-
10
-
15
100
63
]
;
this
.
m_dstRect
=
deMath
.
add
(
deMath
.
swizzle
(
ubound
[
0
1
0
1
]
)
[
-
75
-
99
8
16
]
)
;
this
.
m_interestingArea
=
[
ubound
[
0
]
-
128
ubound
[
1
]
-
128
ubound
[
0
]
ubound
[
1
]
]
;
}
}
;
es3fFramebufferBlitTests
.
DefaultFramebufferBlitCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
colorFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_format
)
;
var
transferFmt
=
gluTextureUtil
.
getTransferFormat
(
colorFormat
)
;
var
targetClass
=
(
this
.
m_blitDir
=
=
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
)
?
(
tcuTexture
.
getTextureChannelClass
(
colorFormat
.
type
)
)
:
(
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
;
var
fbo
;
var
fboTex
;
var
fboTexW
=
128
;
var
fboTexH
=
128
;
var
sourceWidth
=
(
this
.
m_blitDir
=
=
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
)
?
(
ctx
.
getWidth
(
)
)
:
(
fboTexW
)
;
var
sourceHeight
=
(
this
.
m_blitDir
=
=
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
)
?
(
ctx
.
getHeight
(
)
)
:
(
fboTexH
)
;
var
gridRenderWidth
=
Math
.
min
(
256
sourceWidth
)
;
var
gridRenderHeight
=
Math
.
min
(
256
sourceHeight
)
;
var
targetFbo
;
var
sourceFbo
;
fbo
=
ctx
.
createFramebuffer
(
)
;
fboTex
=
ctx
.
createTexture
(
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
fboTex
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
this
.
m_filter
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
this
.
m_filter
)
;
ctx
.
texImage2D
(
gl
.
TEXTURE_2D
0
this
.
m_format
fboTexW
fboTexH
0
transferFmt
.
format
transferFmt
.
dataType
null
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
)
;
ctx
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
TEXTURE_2D
fboTex
0
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
targetFbo
=
(
this
.
m_blitDir
=
=
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
)
?
(
fbo
)
:
(
null
)
;
sourceFbo
=
(
this
.
m_blitDir
=
=
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_DEFAULT_TO_TARGET
)
?
(
null
)
:
(
fbo
)
;
var
texShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
texShaderID
=
this
.
getCurrentContext
(
)
.
createProgram
(
texShader
)
;
var
internalFormat
=
gl
.
RGBA8
;
var
format
=
gl
.
RGBA
;
var
dataType
=
gl
.
UNSIGNED_BYTE
;
var
gridTexW
=
128
;
var
gridTexH
=
128
;
var
gridTex
=
null
;
var
data
=
new
tcuTexture
.
TextureLevel
(
gluTextureUtil
.
mapGLTransferFormat
(
format
dataType
)
gridTexW
gridTexH
1
)
;
tcuTextureUtil
.
fillWithGrid
(
data
.
getAccess
(
)
9
[
0
.
9
0
.
5
0
.
1
0
.
9
]
[
0
.
2
0
.
8
0
.
2
0
.
7
]
)
;
gridTex
=
ctx
.
createTexture
(
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
gridTex
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
ctx
.
texImage2D
(
gl
.
TEXTURE_2D
0
internalFormat
gridTexW
gridTexH
0
format
dataType
data
.
getAccess
(
)
.
getDataPtr
(
)
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
sourceFbo
)
;
ctx
.
viewport
(
0
0
gridRenderWidth
gridRenderHeight
)
;
ctx
.
clearBufferfv
(
gl
.
COLOR
0
[
1
.
0
0
.
0
0
.
0
1
.
0
]
)
;
texShader
.
setUniforms
(
this
.
getCurrentContext
(
)
texShaderID
)
;
rrUtil
.
drawQuad
(
ctx
texShaderID
[
-
1
-
1
0
]
[
1
1
0
]
)
;
ctx
.
useProgram
(
null
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
sourceFbo
)
;
ctx
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
targetFbo
)
;
this
.
checkError
(
)
;
if
(
targetClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
|
|
targetClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
|
|
targetClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
ctx
.
clearBufferfv
(
gl
.
COLOR
0
[
1
.
0
1
.
0
0
.
0
1
.
0
]
)
;
else
if
(
targetClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_INTEGER
)
ctx
.
clearBufferiv
(
gl
.
COLOR
0
[
0
0
0
0
]
)
;
else
if
(
targetClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_INTEGER
)
ctx
.
clearBufferuiv
(
gl
.
COLOR
0
[
0
0
0
0
]
)
;
else
DE_ASSERT
(
false
)
;
ctx
.
blitFramebuffer
(
this
.
m_srcRect
[
0
]
this
.
m_srcRect
[
1
]
this
.
m_srcRect
[
2
]
this
.
m_srcRect
[
3
]
this
.
m_dstRect
[
0
]
this
.
m_dstRect
[
1
]
this
.
m_dstRect
[
2
]
this
.
m_dstRect
[
3
]
gl
.
COLOR_BUFFER_BIT
this
.
m_filter
)
;
this
.
checkError
(
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
targetFbo
)
;
if
(
this
.
m_blitDir
=
=
es3fFramebufferBlitTests
.
BlitDirection
.
BLIT_TO_DEFAULT_FROM_TARGET
)
this
.
readPixels
(
dst
this
.
m_interestingArea
[
0
]
this
.
m_interestingArea
[
1
]
this
.
m_interestingArea
[
2
]
-
this
.
m_interestingArea
[
0
]
this
.
m_interestingArea
[
3
]
-
this
.
m_interestingArea
[
1
]
)
;
else
this
.
readPixelsUsingFormat
(
dst
this
.
m_interestingArea
[
0
]
this
.
m_interestingArea
[
1
]
this
.
m_interestingArea
[
2
]
-
this
.
m_interestingArea
[
0
]
this
.
m_interestingArea
[
3
]
-
this
.
m_interestingArea
[
1
]
colorFormat
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
this
.
checkError
(
)
;
}
;
es3fFramebufferBlitTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
var
test
=
new
es3fFramebufferBlitTests
.
FramebufferBlitTests
(
)
;
var
testName
=
test
.
fullName
(
)
;
var
testDescription
=
test
.
getDescription
(
)
|
|
'
'
;
state
.
testName
=
testName
;
state
.
setRoot
(
test
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
test
.
init
(
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
console
.
log
(
err
)
;
testFailedOptions
(
'
Failed
to
es3fFramebufferBlitTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
