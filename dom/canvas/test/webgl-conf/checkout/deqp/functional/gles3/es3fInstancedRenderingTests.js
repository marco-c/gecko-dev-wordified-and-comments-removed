'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fInstancedRenderingTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fInstancedRenderingTests
=
functional
.
gles3
.
es3fInstancedRenderingTests
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
gl
;
es3fInstancedRenderingTests
.
MAX_RENDER_WIDTH
=
128
;
es3fInstancedRenderingTests
.
MAX_RENDER_HEIGHT
=
128
;
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
=
127
;
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_R
=
3
;
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_G
=
2
;
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_B
=
1
;
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
=
3
;
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
=
100
.
0
;
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
=
-
50
.
0
;
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
=
100
.
0
;
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
=
0
.
0
;
var
DE_ASSERT
=
function
(
expression
)
{
if
(
!
expression
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
es3fInstancedRenderingTests
.
TCU_FAIL
=
function
(
message
)
{
throw
new
Error
(
message
)
;
}
;
es3fInstancedRenderingTests
.
DrawFunction
=
{
FUNCTION_DRAW_ARRAYS_INSTANCED
:
0
FUNCTION_DRAW_ELEMENTS_INSTANCED
:
1
}
;
es3fInstancedRenderingTests
.
InstancingType
=
{
TYPE_INSTANCE_ID
:
0
TYPE_ATTRIB_DIVISOR
:
1
TYPE_MIXED
:
2
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
=
function
(
name
description
drawFunction
instancingType
rgbAttrType
numInstances
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_function
=
drawFunction
;
this
.
m_instancingType
=
instancingType
;
this
.
m_rgbAttrType
=
rgbAttrType
;
this
.
m_numInstances
=
numInstances
;
this
.
m_program
=
null
;
this
.
m_gridVertexPositions
=
[
]
;
this
.
m_gridIndices
=
[
]
;
this
.
m_instanceOffsets
=
[
]
;
this
.
m_instanceColorR
=
[
]
;
this
.
m_instanceColorG
=
[
]
;
this
.
m_instanceColorB
=
[
]
;
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
constructor
=
es3fInstancedRenderingTests
.
InstancedRenderingCase
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
pushVarCompAttrib
=
function
(
vec
val
)
{
var
isFloatCase
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
this
.
m_rgbAttrType
)
;
var
isIntCase
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
this
.
m_rgbAttrType
)
;
var
isUintCase
=
gluShaderUtil
.
isDataTypeUintOrUVec
(
this
.
m_rgbAttrType
)
;
var
isMatCase
=
gluShaderUtil
.
isDataTypeMatrix
(
this
.
m_rgbAttrType
)
;
if
(
isFloatCase
|
|
isMatCase
)
vec
.
push
(
val
)
;
else
if
(
isIntCase
)
vec
.
push
(
val
*
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
)
;
else
if
(
isUintCase
)
vec
.
push
(
val
*
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
)
;
else
throw
new
Error
(
'
Invalid
attribute
type
.
'
)
;
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
init
=
function
(
)
{
gl
.
getError
(
)
;
var
isFloatCase
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
this
.
m_rgbAttrType
)
;
var
isIntCase
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
this
.
m_rgbAttrType
)
;
var
isUintCase
=
gluShaderUtil
.
isDataTypeUintOrUVec
(
this
.
m_rgbAttrType
)
;
var
isMatCase
=
gluShaderUtil
.
isDataTypeMatrix
(
this
.
m_rgbAttrType
)
;
var
typeSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
this
.
m_rgbAttrType
)
;
var
isScalarCase
=
typeSize
=
=
1
;
var
swizzleFirst
=
isScalarCase
?
'
'
:
'
.
x
'
;
var
typeName
=
gluShaderUtil
.
getDataTypeName
(
this
.
m_rgbAttrType
)
;
var
floatIntScaleStr
=
'
(
'
+
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
.
toFixed
(
3
)
+
'
)
'
;
var
floatIntBiasStr
=
'
(
'
+
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
.
toFixed
(
3
)
+
'
)
'
;
var
floatUintScaleStr
=
'
(
'
+
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
.
toFixed
(
3
)
+
'
)
'
;
var
floatUintBiasStr
=
'
(
'
+
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
.
toFixed
(
3
)
+
'
)
'
;
DE_ASSERT
(
isFloatCase
|
|
isIntCase
|
|
isUintCase
|
|
isMatCase
)
;
var
numInstancesStr
=
this
.
m_numInstances
.
toString
(
)
+
'
.
0
'
;
var
instanceAttribs
=
'
'
;
var
posExpression
=
'
'
;
var
colorRExpression
=
'
'
;
var
colorGExpression
=
'
'
;
var
colorBExpression
=
'
'
;
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_INSTANCE_ID
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
)
{
posExpression
=
'
a_position
+
vec4
(
float
(
gl_InstanceID
)
*
2
.
0
/
'
+
numInstancesStr
+
'
0
.
0
0
.
0
0
.
0
)
'
;
colorRExpression
=
'
float
(
gl_InstanceID
)
/
'
+
numInstancesStr
;
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_INSTANCE_ID
)
{
colorGExpression
=
'
float
(
gl_InstanceID
)
*
2
.
0
/
'
+
numInstancesStr
;
colorBExpression
=
'
1
.
0
-
float
(
gl_InstanceID
)
/
'
+
numInstancesStr
;
}
}
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
)
{
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
)
{
posExpression
=
'
a_position
+
vec4
(
a_instanceOffset
'
;
DE_ASSERT
(
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
>
=
1
&
&
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
<
=
4
)
;
for
(
var
i
=
0
;
i
<
4
-
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
;
i
+
+
)
posExpression
+
=
'
0
.
0
'
;
posExpression
+
=
'
)
'
;
if
(
isFloatCase
)
colorRExpression
=
'
a_instanceR
'
+
swizzleFirst
;
else
if
(
isIntCase
)
colorRExpression
=
'
(
float
(
a_instanceR
'
+
swizzleFirst
+
'
)
-
'
+
floatIntBiasStr
+
'
)
/
'
+
floatIntScaleStr
;
else
if
(
isUintCase
)
colorRExpression
=
'
(
float
(
a_instanceR
'
+
swizzleFirst
+
'
)
-
'
+
floatUintBiasStr
+
'
)
/
'
+
floatUintScaleStr
;
else
if
(
isMatCase
)
colorRExpression
=
'
a_instanceR
[
0
]
[
0
]
'
;
else
DE_ASSERT
(
false
)
;
instanceAttribs
+
=
'
in
highp
'
+
(
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
=
=
1
?
'
float
'
:
'
vec
'
+
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
.
toString
(
)
)
+
'
a_instanceOffset
;
\
n
'
;
instanceAttribs
+
=
'
in
mediump
'
+
typeName
+
'
a_instanceR
;
\
n
'
;
}
if
(
isFloatCase
)
{
colorGExpression
=
'
a_instanceG
'
+
swizzleFirst
;
colorBExpression
=
'
a_instanceB
'
+
swizzleFirst
;
}
else
if
(
isIntCase
)
{
colorGExpression
=
'
(
float
(
a_instanceG
'
+
swizzleFirst
+
'
)
-
'
+
floatIntBiasStr
+
'
)
/
'
+
floatIntScaleStr
;
colorBExpression
=
'
(
float
(
a_instanceB
'
+
swizzleFirst
+
'
)
-
'
+
floatIntBiasStr
+
'
)
/
'
+
floatIntScaleStr
;
}
else
if
(
isUintCase
)
{
colorGExpression
=
'
(
float
(
a_instanceG
'
+
swizzleFirst
+
'
)
-
'
+
floatUintBiasStr
+
'
)
/
'
+
floatUintScaleStr
;
colorBExpression
=
'
(
float
(
a_instanceB
'
+
swizzleFirst
+
'
)
-
'
+
floatUintBiasStr
+
'
)
/
'
+
floatUintScaleStr
;
}
else
if
(
isMatCase
)
{
colorGExpression
=
'
a_instanceG
[
0
]
[
0
]
'
;
colorBExpression
=
'
a_instanceB
[
0
]
[
0
]
'
;
}
else
DE_ASSERT
(
false
)
;
instanceAttribs
+
=
'
in
mediump
'
+
typeName
+
'
a_instanceG
;
\
n
'
;
instanceAttribs
+
=
'
in
mediump
'
+
typeName
+
'
a_instanceB
;
\
n
'
;
}
DE_ASSERT
(
!
(
posExpression
.
length
=
=
0
)
)
;
DE_ASSERT
(
!
(
colorRExpression
.
length
=
=
0
)
)
;
DE_ASSERT
(
!
(
colorGExpression
.
length
=
=
0
)
)
;
DE_ASSERT
(
!
(
colorBExpression
.
length
=
=
0
)
)
;
var
vertShaderSourceStr
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
instanceAttribs
+
'
out
mediump
vec4
v_color
;
\
n
'
+
'
\
n
'
+
'
void
main
(
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
'
+
posExpression
+
'
;
\
n
'
+
'
v_color
.
r
=
'
+
colorRExpression
+
'
;
\
n
'
+
'
v_color
.
g
=
'
+
colorGExpression
+
'
;
\
n
'
+
'
v_color
.
b
=
'
+
colorBExpression
+
'
;
\
n
'
+
'
v_color
.
a
=
1
.
0
;
\
n
'
+
'
}
\
n
'
;
var
fragShaderSource
=
'
#
version
300
es
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
in
mediump
vec4
v_color
;
\
n
'
+
'
\
n
'
+
'
void
main
(
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
v_color
;
\
n
'
+
'
}
\
n
'
;
DE_ASSERT
(
!
this
.
m_program
)
;
this
.
m_program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vertShaderSourceStr
fragShaderSource
)
)
;
assertMsgOptions
(
this
.
m_program
.
isOk
(
)
'
Failed
to
compile
shader
'
false
true
)
;
if
(
this
.
m_function
=
=
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ELEMENTS_INSTANCED
)
{
for
(
var
y
=
0
;
y
<
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
+
1
;
y
+
+
)
for
(
var
x
=
0
;
x
<
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
+
1
;
x
+
+
)
{
var
fx
=
-
1
.
0
+
x
/
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
*
2
.
0
/
this
.
m_numInstances
;
var
fy
=
-
1
.
0
+
y
/
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
*
2
.
0
;
this
.
m_gridVertexPositions
.
push
(
fx
)
;
this
.
m_gridVertexPositions
.
push
(
fy
)
;
}
for
(
var
y
=
0
;
y
<
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
;
y
+
+
)
for
(
var
x
=
0
;
x
<
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
;
x
+
+
)
{
var
ndx00
=
y
*
(
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
+
1
)
+
x
;
var
ndx10
=
y
*
(
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
+
1
)
+
x
+
1
;
var
ndx01
=
(
y
+
1
)
*
(
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
+
1
)
+
x
;
var
ndx11
=
(
y
+
1
)
*
(
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
+
1
)
+
x
+
1
;
this
.
m_gridIndices
.
push
(
ndx00
)
;
this
.
m_gridIndices
.
push
(
ndx10
)
;
this
.
m_gridIndices
.
push
(
ndx01
)
;
this
.
m_gridIndices
.
push
(
ndx11
)
;
this
.
m_gridIndices
.
push
(
ndx01
)
;
this
.
m_gridIndices
.
push
(
ndx10
)
;
}
}
else
{
DE_ASSERT
(
this
.
m_function
=
=
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ARRAYS_INSTANCED
)
;
for
(
var
y
=
0
;
y
<
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
;
y
+
+
)
for
(
var
x
=
0
;
x
<
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
;
x
+
+
)
{
var
fx0
=
-
1
.
0
+
(
x
+
0
)
/
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
*
2
.
0
/
this
.
m_numInstances
;
var
fx1
=
-
1
.
0
+
(
x
+
1
)
/
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
*
2
.
0
/
this
.
m_numInstances
;
var
fy0
=
-
1
.
0
+
(
y
+
0
)
/
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
*
2
.
0
;
var
fy1
=
-
1
.
0
+
(
y
+
1
)
/
es3fInstancedRenderingTests
.
QUAD_GRID_SIZE
*
2
.
0
;
this
.
m_gridVertexPositions
.
push
(
fx0
)
;
this
.
m_gridVertexPositions
.
push
(
fy0
)
;
this
.
m_gridVertexPositions
.
push
(
fx1
)
;
this
.
m_gridVertexPositions
.
push
(
fy0
)
;
this
.
m_gridVertexPositions
.
push
(
fx0
)
;
this
.
m_gridVertexPositions
.
push
(
fy1
)
;
this
.
m_gridVertexPositions
.
push
(
fx1
)
;
this
.
m_gridVertexPositions
.
push
(
fy1
)
;
this
.
m_gridVertexPositions
.
push
(
fx0
)
;
this
.
m_gridVertexPositions
.
push
(
fy1
)
;
this
.
m_gridVertexPositions
.
push
(
fx1
)
;
this
.
m_gridVertexPositions
.
push
(
fy0
)
;
}
}
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
)
{
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
)
{
for
(
var
i
=
0
;
i
<
this
.
m_numInstances
;
i
+
+
)
{
this
.
m_instanceOffsets
.
push
(
i
*
2
.
0
/
this
.
m_numInstances
)
;
DE_ASSERT
(
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
>
=
1
&
&
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
<
=
4
)
;
for
(
var
j
=
0
;
j
<
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
-
1
;
j
+
+
)
this
.
m_instanceOffsets
.
push
(
0
.
0
)
;
}
var
rInstances
=
Math
.
floor
(
this
.
m_numInstances
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_R
)
+
(
this
.
m_numInstances
%
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_R
=
=
0
?
0
:
1
)
;
for
(
var
i
=
0
;
i
<
rInstances
;
i
+
+
)
{
this
.
pushVarCompAttrib
(
this
.
m_instanceColorR
i
/
rInstances
)
;
for
(
var
j
=
0
;
j
<
typeSize
-
1
;
j
+
+
)
this
.
pushVarCompAttrib
(
this
.
m_instanceColorR
0
.
0
)
;
}
}
var
gInstances
=
Math
.
floor
(
this
.
m_numInstances
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_G
)
+
(
this
.
m_numInstances
%
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_G
=
=
0
?
0
:
1
)
;
for
(
var
i
=
0
;
i
<
gInstances
;
i
+
+
)
{
this
.
pushVarCompAttrib
(
this
.
m_instanceColorG
i
*
2
.
0
/
gInstances
)
;
for
(
var
j
=
0
;
j
<
typeSize
-
1
;
j
+
+
)
this
.
pushVarCompAttrib
(
this
.
m_instanceColorG
0
.
0
)
;
}
var
bInstances
=
Math
.
floor
(
this
.
m_numInstances
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_B
)
+
(
this
.
m_numInstances
%
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_B
=
=
0
?
0
:
1
)
;
for
(
var
i
=
0
;
i
<
bInstances
;
i
+
+
)
{
this
.
pushVarCompAttrib
(
this
.
m_instanceColorB
1
.
0
-
i
/
bInstances
)
;
for
(
var
j
=
0
;
j
<
typeSize
-
1
;
j
+
+
)
this
.
pushVarCompAttrib
(
this
.
m_instanceColorB
0
.
0
)
;
}
}
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
deinit
=
function
(
)
{
var
numVertexAttribArrays
=
(
gl
.
getParameter
(
gl
.
MAX_VERTEX_ATTRIBS
)
)
;
for
(
var
idx
=
0
;
idx
<
numVertexAttribArrays
;
idx
+
+
)
{
gl
.
disableVertexAttribArray
(
idx
)
;
gl
.
vertexAttribDivisor
(
idx
0
)
;
}
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
iterate
=
function
(
)
{
var
width
=
Math
.
min
(
gl
.
drawingBufferWidth
es3fInstancedRenderingTests
.
MAX_RENDER_WIDTH
)
;
var
height
=
Math
.
min
(
gl
.
drawingBufferHeight
es3fInstancedRenderingTests
.
MAX_RENDER_HEIGHT
)
;
var
xOffsetMax
=
gl
.
drawingBufferWidth
-
width
;
var
yOffsetMax
=
gl
.
drawingBufferHeight
-
height
;
var
rnd
=
new
deRandom
.
Random
(
deString
.
deStringHash
(
this
.
name
)
)
;
var
xOffset
=
rnd
.
getInt
(
0
xOffsetMax
)
;
var
yOffset
=
rnd
.
getInt
(
0
yOffsetMax
)
;
var
referenceImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
resultImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
gl
.
viewport
(
xOffset
yOffset
width
height
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
this
.
setupAndRender
(
)
;
var
resImg
=
resultImg
.
getAccess
(
)
;
var
resImgTransferFormat
=
gluTextureUtil
.
getTransferFormat
(
resImg
.
getFormat
(
)
)
;
gl
.
readPixels
(
xOffset
yOffset
resImg
.
m_width
resImg
.
m_height
resImgTransferFormat
.
format
resImgTransferFormat
.
dataType
resultImg
.
m_pixels
)
;
this
.
computeReference
(
referenceImg
)
;
var
testOk
=
tcuImageCompare
.
fuzzyCompare
(
'
ComparisonResult
'
'
Image
comparison
result
'
referenceImg
.
getAccess
(
)
resultImg
.
getAccess
(
)
0
.
05
)
;
assertMsgOptions
(
testOk
'
'
true
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
setupVarAttribPointer
=
function
(
attrPtr
location
divisor
)
{
var
isFloatCase
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
this
.
m_rgbAttrType
)
;
var
isIntCase
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
this
.
m_rgbAttrType
)
;
var
isUintCase
=
gluShaderUtil
.
isDataTypeUintOrUVec
(
this
.
m_rgbAttrType
)
;
var
isMatCase
=
gluShaderUtil
.
isDataTypeMatrix
(
this
.
m_rgbAttrType
)
;
var
typeSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
this
.
m_rgbAttrType
)
;
var
numSlots
=
isMatCase
?
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
this
.
m_rgbAttrType
)
:
1
;
for
(
var
slotNdx
=
0
;
slotNdx
<
numSlots
;
slotNdx
+
+
)
{
var
curLoc
=
location
+
slotNdx
;
gl
.
enableVertexAttribArray
(
curLoc
)
;
gl
.
vertexAttribDivisor
(
curLoc
divisor
)
;
var
curLocGlBuffer
=
gl
.
createBuffer
(
)
;
if
(
isFloatCase
)
{
var
bufferCurLoc
=
new
Float32Array
(
attrPtr
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
curLocGlBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
bufferCurLoc
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribPointer
(
curLoc
typeSize
gl
.
FLOAT
false
0
0
)
;
}
else
if
(
isIntCase
)
{
var
bufferCurLoc
=
new
Int32Array
(
attrPtr
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
curLocGlBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
bufferCurLoc
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribIPointer
(
curLoc
typeSize
gl
.
INT
0
0
)
;
}
else
if
(
isUintCase
)
{
var
bufferCurLoc
=
new
Uint32Array
(
attrPtr
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
curLocGlBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
bufferCurLoc
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribIPointer
(
curLoc
typeSize
gl
.
UNSIGNED_INT
0
0
)
;
}
else
if
(
isMatCase
)
{
var
numRows
=
gluShaderUtil
.
getDataTypeMatrixNumRows
(
this
.
m_rgbAttrType
)
;
var
numCols
=
gluShaderUtil
.
getDataTypeMatrixNumColumns
(
this
.
m_rgbAttrType
)
;
var
bufferCurLoc
=
new
Float32Array
(
attrPtr
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
curLocGlBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
bufferCurLoc
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribPointer
(
curLoc
numRows
gl
.
FLOAT
false
numCols
*
numRows
*
4
0
)
;
}
else
DE_ASSERT
(
false
)
;
}
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
setupAndRender
=
function
(
)
{
var
program
=
this
.
m_program
.
getProgram
(
)
;
gl
.
useProgram
(
program
)
;
var
positionLoc
=
gl
.
getAttribLocation
(
program
'
a_position
'
)
;
gl
.
enableVertexAttribArray
(
positionLoc
)
;
var
positionBuffer
=
gl
.
createBuffer
(
)
;
var
bufferGridVertexPosition
=
new
Float32Array
(
this
.
m_gridVertexPositions
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
positionBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
bufferGridVertexPosition
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribPointer
(
positionLoc
2
gl
.
FLOAT
false
0
0
)
;
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
)
{
if
(
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
)
{
var
offsetLoc
=
gl
.
getAttribLocation
(
program
'
a_instanceOffset
'
)
;
gl
.
enableVertexAttribArray
(
offsetLoc
)
;
gl
.
vertexAttribDivisor
(
offsetLoc
1
)
;
var
offsetLocGlBuffer
=
gl
.
createBuffer
(
)
;
var
bufferOffsetLoc
=
new
Float32Array
(
this
.
m_instanceOffsets
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
offsetLocGlBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
bufferOffsetLoc
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribPointer
(
offsetLoc
es3fInstancedRenderingTests
.
OFFSET_COMPONENTS
gl
.
FLOAT
false
0
0
)
;
var
rLoc
=
gl
.
getAttribLocation
(
program
'
a_instanceR
'
)
;
this
.
setupVarAttribPointer
(
this
.
m_instanceColorR
rLoc
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_R
)
;
}
var
gLoc
=
gl
.
getAttribLocation
(
program
'
a_instanceG
'
)
;
this
.
setupVarAttribPointer
(
this
.
m_instanceColorG
gLoc
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_G
)
;
var
bLoc
=
gl
.
getAttribLocation
(
program
'
a_instanceB
'
)
;
this
.
setupVarAttribPointer
(
this
.
m_instanceColorB
bLoc
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_B
)
;
}
if
(
this
.
m_function
=
=
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ARRAYS_INSTANCED
)
{
var
numPositionComponents
=
2
;
gl
.
drawArraysInstanced
(
gl
.
TRIANGLES
0
Math
.
floor
(
this
.
m_gridVertexPositions
.
length
/
numPositionComponents
)
this
.
m_numInstances
)
;
}
else
{
var
gridIndicesGLBuffer
=
gl
.
createBuffer
(
)
;
var
bufferGridIndices
=
new
Uint16Array
(
this
.
m_gridIndices
)
;
gl
.
bindBuffer
(
gl
.
ELEMENT_ARRAY_BUFFER
gridIndicesGLBuffer
)
;
gl
.
bufferData
(
gl
.
ELEMENT_ARRAY_BUFFER
bufferGridIndices
gl
.
STATIC_DRAW
)
;
gl
.
drawElementsInstanced
(
gl
.
TRIANGLES
this
.
m_gridIndices
.
length
gl
.
UNSIGNED_SHORT
0
this
.
m_numInstances
)
;
}
gl
.
useProgram
(
null
)
;
}
;
es3fInstancedRenderingTests
.
InstancedRenderingCase
.
prototype
.
computeReference
=
function
(
dst
)
{
var
wid
=
dst
.
getWidth
(
)
;
var
hei
=
dst
.
getHeight
(
)
;
for
(
var
instanceNdx
=
0
;
instanceNdx
<
this
.
m_numInstances
;
instanceNdx
+
+
)
{
var
xStart
=
Math
.
floor
(
instanceNdx
*
wid
/
this
.
m_numInstances
)
;
var
xEnd
=
Math
.
floor
(
(
instanceNdx
+
1
)
*
wid
/
this
.
m_numInstances
)
;
var
clrNdxR
=
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
?
Math
.
floor
(
instanceNdx
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_R
)
:
instanceNdx
;
var
clrNdxG
=
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
?
Math
.
floor
(
instanceNdx
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_G
)
:
instanceNdx
;
var
clrNdxB
=
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
?
Math
.
floor
(
instanceNdx
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_B
)
:
instanceNdx
;
var
rInstances
=
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
?
Math
.
floor
(
this
.
m_numInstances
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_R
)
+
(
this
.
m_numInstances
%
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_R
=
=
0
?
0
:
1
)
:
this
.
m_numInstances
;
var
gInstances
=
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
?
Math
.
floor
(
this
.
m_numInstances
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_G
)
+
(
this
.
m_numInstances
%
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_G
=
=
0
?
0
:
1
)
:
this
.
m_numInstances
;
var
bInstances
=
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
|
|
this
.
m_instancingType
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
?
Math
.
floor
(
this
.
m_numInstances
/
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_B
)
+
(
this
.
m_numInstances
%
es3fInstancedRenderingTests
.
ATTRIB_DIVISOR_B
=
=
0
?
0
:
1
)
:
this
.
m_numInstances
;
var
r
=
clrNdxR
/
rInstances
;
var
g
=
clrNdxG
*
2
.
0
/
gInstances
;
var
b
=
1
.
0
-
clrNdxB
/
bInstances
;
if
(
gluShaderUtil
.
isDataTypeIntOrIVec
(
this
.
m_rgbAttrType
)
)
{
var
intR
=
(
r
*
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
)
;
var
intG
=
(
g
*
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
)
;
var
intB
=
(
b
*
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
)
;
r
=
(
intR
-
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
)
/
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
;
g
=
(
intG
-
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
)
/
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
;
b
=
(
intB
-
es3fInstancedRenderingTests
.
FLOAT_INT_BIAS
)
/
es3fInstancedRenderingTests
.
FLOAT_INT_SCALE
;
}
else
if
(
gluShaderUtil
.
isDataTypeUintOrUVec
(
this
.
m_rgbAttrType
)
)
{
var
uintR
=
(
r
*
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
)
;
var
uintG
=
(
g
*
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
)
;
var
uintB
=
(
b
*
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
+
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
)
;
r
=
(
uintR
-
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
)
/
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
;
g
=
(
uintG
-
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
)
/
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
;
b
=
(
uintB
-
es3fInstancedRenderingTests
.
FLOAT_UINT_BIAS
)
/
es3fInstancedRenderingTests
.
FLOAT_UINT_SCALE
;
}
var
color
=
deMath
.
add
(
deMath
.
scale
(
[
r
g
b
1
.
0
]
255
)
[
0
.
5
0
.
5
0
.
5
0
.
5
]
)
;
color
=
deMath
.
clampVector
(
color
0
255
)
;
for
(
var
y
=
0
;
y
<
hei
;
y
+
+
)
for
(
var
x
=
xStart
;
x
<
xEnd
;
x
+
+
)
dst
.
setPixel
(
x
y
color
)
;
}
}
;
es3fInstancedRenderingTests
.
init
=
function
(
)
{
var
testGroup
=
tcuTestCase
.
runner
.
testCases
;
var
instanceCounts
=
[
1
2
4
20
]
;
for
(
var
_function
in
es3fInstancedRenderingTests
.
DrawFunction
)
{
var
functionName
=
es3fInstancedRenderingTests
.
DrawFunction
[
_function
]
=
=
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ARRAYS_INSTANCED
?
'
draw_arrays_instanced
'
:
es3fInstancedRenderingTests
.
DrawFunction
[
_function
]
=
=
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ELEMENTS_INSTANCED
?
'
draw_elements_instanced
'
:
null
;
var
functionDesc
=
es3fInstancedRenderingTests
.
DrawFunction
[
_function
]
=
=
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ARRAYS_INSTANCED
?
'
Use
glDrawArraysInstanced
(
)
'
:
es3fInstancedRenderingTests
.
DrawFunction
[
_function
]
=
=
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ELEMENTS_INSTANCED
?
'
Use
glDrawElementsInstanced
(
)
'
:
null
;
DE_ASSERT
(
functionName
!
=
null
)
;
DE_ASSERT
(
functionDesc
!
=
null
)
;
var
functionGroup
=
tcuTestCase
.
newTest
(
functionName
functionDesc
)
;
testGroup
.
addChild
(
functionGroup
)
;
for
(
var
instancingType
in
es3fInstancedRenderingTests
.
InstancingType
)
{
var
instancingTypeName
=
es3fInstancedRenderingTests
.
InstancingType
[
instancingType
]
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_INSTANCE_ID
?
'
instance_id
'
:
es3fInstancedRenderingTests
.
InstancingType
[
instancingType
]
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
?
'
attribute_divisor
'
:
es3fInstancedRenderingTests
.
InstancingType
[
instancingType
]
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
?
'
mixed
'
:
null
;
var
instancingTypeDesc
=
es3fInstancedRenderingTests
.
InstancingType
[
instancingType
]
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_INSTANCE_ID
?
'
Use
gl_InstanceID
for
instancing
'
:
es3fInstancedRenderingTests
.
InstancingType
[
instancingType
]
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
?
'
Use
vertex
attribute
divisors
for
instancing
'
:
es3fInstancedRenderingTests
.
InstancingType
[
instancingType
]
=
=
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_MIXED
?
'
Use
both
gl_InstanceID
and
vertex
attribute
divisors
for
instancing
'
:
null
;
DE_ASSERT
(
instancingTypeName
!
=
null
)
;
DE_ASSERT
(
instancingTypeDesc
!
=
null
)
;
var
instancingTypeGroup
=
tcuTestCase
.
newTest
(
instancingTypeName
instancingTypeDesc
)
;
functionGroup
.
addChild
(
instancingTypeGroup
)
;
for
(
var
countNdx
in
instanceCounts
)
{
var
countName
=
instanceCounts
[
countNdx
]
.
toString
(
)
+
'
_instances
'
;
instancingTypeGroup
.
addChild
(
new
es3fInstancedRenderingTests
.
InstancedRenderingCase
(
countName
'
'
es3fInstancedRenderingTests
.
DrawFunction
[
_function
]
es3fInstancedRenderingTests
.
InstancingType
[
instancingType
]
gluShaderUtil
.
DataType
.
FLOAT
instanceCounts
[
countNdx
]
)
)
;
}
}
}
var
s_testTypes
=
[
gluShaderUtil
.
DataType
.
FLOAT
gluShaderUtil
.
DataType
.
FLOAT_VEC2
gluShaderUtil
.
DataType
.
FLOAT_VEC3
gluShaderUtil
.
DataType
.
FLOAT_VEC4
gluShaderUtil
.
DataType
.
FLOAT_MAT2
gluShaderUtil
.
DataType
.
FLOAT_MAT2X3
gluShaderUtil
.
DataType
.
FLOAT_MAT2X4
gluShaderUtil
.
DataType
.
FLOAT_MAT3X2
gluShaderUtil
.
DataType
.
FLOAT_MAT3
gluShaderUtil
.
DataType
.
FLOAT_MAT3X4
gluShaderUtil
.
DataType
.
FLOAT_MAT4X2
gluShaderUtil
.
DataType
.
FLOAT_MAT4X3
gluShaderUtil
.
DataType
.
FLOAT_MAT4
gluShaderUtil
.
DataType
.
INT
gluShaderUtil
.
DataType
.
INT_VEC2
gluShaderUtil
.
DataType
.
INT_VEC3
gluShaderUtil
.
DataType
.
INT_VEC4
gluShaderUtil
.
DataType
.
UINT
gluShaderUtil
.
DataType
.
UINT_VEC2
gluShaderUtil
.
DataType
.
UINT_VEC3
gluShaderUtil
.
DataType
.
UINT_VEC4
]
;
var
typeTestNumInstances
=
4
;
var
typesGroup
=
tcuTestCase
.
newTest
(
'
types
'
'
Tests
for
instanced
attributes
of
particular
data
types
'
)
;
testGroup
.
addChild
(
typesGroup
)
;
for
(
var
typeNdx
in
s_testTypes
)
{
var
type
=
s_testTypes
[
typeNdx
]
;
typesGroup
.
addChild
(
new
es3fInstancedRenderingTests
.
InstancedRenderingCase
(
gluShaderUtil
.
getDataTypeName
(
type
)
'
'
es3fInstancedRenderingTests
.
DrawFunction
.
FUNCTION_DRAW_ARRAYS_INSTANCED
es3fInstancedRenderingTests
.
InstancingType
.
TYPE_ATTRIB_DIVISOR
type
typeTestNumInstances
)
)
;
}
}
;
es3fInstancedRenderingTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
testName
=
'
instanced_rendering
'
;
var
testDescription
=
'
Instanced
Rendering
Tests
'
;
var
state
=
tcuTestCase
.
runner
;
state
.
testName
=
testName
;
state
.
setRoot
(
tcuTestCase
.
newTest
(
testName
testDescription
null
)
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
es3fInstancedRenderingTests
.
init
(
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fInstancedRenderingTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
