'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fShaderBuiltinVarTests
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuLogImage
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuPixelFormat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluDrawUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluVarType
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrReferenceContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrShaderProgram
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrFragmentOperations
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrGenericVector
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrMultisamplePixelBufferAccess
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrRenderer
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrRenderState
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrShadingContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexAttrib
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexPacket
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsShaderRenderCase
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsShaderExecUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fShaderBuiltinVarTests
=
functional
.
gles3
.
es3fShaderBuiltinVarTests
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
glsShaderExecUtil
=
modules
.
shared
.
glsShaderExecUtil
;
var
glsShaderRenderCase
=
modules
.
shared
.
glsShaderRenderCase
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluDrawUtil
=
framework
.
opengl
.
gluDrawUtil
;
var
gluVarType
=
framework
.
opengl
.
gluVarType
;
var
tcuPixelFormat
=
framework
.
common
.
tcuPixelFormat
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuLogImage
=
framework
.
common
.
tcuLogImage
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
rrGenericVector
=
framework
.
referencerenderer
.
rrGenericVector
;
var
rrFragmentOperations
=
framework
.
referencerenderer
.
rrFragmentOperations
;
var
rrMultisamplePixelBufferAccess
=
framework
.
referencerenderer
.
rrMultisamplePixelBufferAccess
;
var
rrRenderer
=
framework
.
referencerenderer
.
rrRenderer
;
var
rrRenderState
=
framework
.
referencerenderer
.
rrRenderState
;
var
rrShadingContext
=
framework
.
referencerenderer
.
rrShadingContext
;
var
rrVertexAttrib
=
framework
.
referencerenderer
.
rrVertexAttrib
;
var
rrVertexPacket
=
framework
.
referencerenderer
.
rrVertexPacket
;
var
sglrShaderProgram
=
framework
.
opengl
.
simplereference
.
sglrShaderProgram
;
var
sglrReferenceContext
=
framework
.
opengl
.
simplereference
.
sglrReferenceContext
;
es3fShaderBuiltinVarTests
.
GetConstantValueFunc
;
es3fShaderBuiltinVarTests
.
getInteger
=
function
(
pname
)
{
return
(
gl
.
getParameter
(
pname
)
)
;
}
;
es3fShaderBuiltinVarTests
.
getVectorsFromComps
=
function
(
pname
)
{
var
value
=
(
gl
.
getParameter
(
pname
)
)
;
assertMsgOptions
(
value
%
4
=
=
=
0
'
Expected
value
to
be
divisible
by
4
.
'
false
true
)
;
return
value
/
4
;
}
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
=
function
(
name
desc
varName
getValue
shaderType
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
desc
)
;
this
.
m_varName
=
varName
;
this
.
m_getValue
=
getValue
;
this
.
m_shaderType
=
shaderType
;
}
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
.
prototype
.
deinit
=
function
(
)
{
console
.
log
(
'
ShaderBuildInConstantCase
.
deinit
(
)
'
)
;
gl
.
useProgram
(
null
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
null
)
;
gl
.
bindBuffer
(
gl
.
ELEMENT_ARRAY_BUFFER
null
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
null
)
;
}
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
.
prototype
.
createGetConstantExecutor
=
function
(
shaderType
varName
)
{
var
shaderSpec
=
new
glsShaderExecUtil
.
ShaderSpec
(
)
;
shaderSpec
.
version
=
gluShaderUtil
.
GLSLVersion
.
V300_ES
;
shaderSpec
.
source
=
'
result
=
'
+
varName
+
'
;
\
n
'
;
shaderSpec
.
outputs
.
push
(
new
glsShaderExecUtil
.
Symbol
(
'
result
'
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
INT
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
)
)
;
return
glsShaderExecUtil
.
createExecutor
(
shaderType
shaderSpec
)
;
}
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
.
prototype
.
iterate
=
function
(
)
{
var
shaderExecutor
=
this
.
createGetConstantExecutor
(
this
.
m_shaderType
this
.
m_varName
)
;
var
reference
=
this
.
m_getValue
(
)
;
var
shaderExecutorResult
;
var
result
;
if
(
!
shaderExecutor
.
isOk
(
)
)
assertMsgOptions
(
false
'
Compile
failed
'
false
true
)
;
shaderExecutor
.
useProgram
(
)
;
shaderExecutorResult
=
shaderExecutor
.
execute
(
1
null
)
;
result
=
new
Int32Array
(
shaderExecutorResult
[
0
]
.
buffer
)
[
0
]
;
bufferedLogToConsole
(
this
.
m_varName
+
'
=
'
+
result
)
;
if
(
result
!
=
reference
)
{
bufferedLogToConsole
(
'
ERROR
:
Expected
'
+
this
.
m_varName
+
'
=
'
+
reference
+
'
\
n
'
+
'
Test
shader
:
'
+
shaderExecutor
.
m_program
.
getProgramInfo
(
)
.
infoLog
)
;
testFailedOptions
(
'
Invalid
builtin
constant
value
'
false
)
;
}
else
testPassedOptions
(
'
Pass
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fShaderBuiltinVarTests
.
DepthRangeParams
=
function
(
near
far
)
{
this
.
zNear
=
near
=
=
=
undefined
?
0
.
0
:
near
;
this
.
zFar
=
far
=
=
=
undefined
?
1
.
0
:
far
;
}
;
es3fShaderBuiltinVarTests
.
DepthRangeEvaluator
=
function
(
params
)
{
this
.
m_params
=
params
;
}
;
es3fShaderBuiltinVarTests
.
DepthRangeEvaluator
.
prototype
=
Object
.
create
(
glsShaderRenderCase
.
ShaderEvaluator
.
prototype
)
;
es3fShaderBuiltinVarTests
.
DepthRangeEvaluator
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
DepthRangeEvaluator
;
es3fShaderBuiltinVarTests
.
DepthRangeEvaluator
.
prototype
.
evaluate
=
function
(
c
)
{
var
zNear
=
deMath
.
clamp
(
this
.
m_params
.
zNear
0
.
0
1
.
0
)
;
var
zFar
=
deMath
.
clamp
(
this
.
m_params
.
zFar
0
.
0
1
.
0
)
;
var
diff
=
zFar
-
zNear
;
c
.
color
[
0
]
=
zNear
;
c
.
color
[
1
]
=
zFar
;
c
.
color
[
2
]
=
diff
*
0
.
5
+
0
.
5
;
}
;
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
=
function
(
name
desc
isVertexCase
)
{
glsShaderRenderCase
.
ShaderRenderCase
.
call
(
this
name
desc
isVertexCase
)
;
this
.
m_depthRange
=
new
es3fShaderBuiltinVarTests
.
DepthRangeParams
(
)
;
this
.
m_evaluator
=
new
es3fShaderBuiltinVarTests
.
DepthRangeEvaluator
(
this
.
m_depthRange
)
;
this
.
m_iterNdx
=
0
;
}
;
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
.
prototype
=
Object
.
create
(
glsShaderRenderCase
.
ShaderRenderCase
.
prototype
)
;
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
;
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
.
prototype
.
init
=
function
(
)
{
var
defaultVertSrc
=
'
'
+
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
}
\
n
'
;
var
defaultFragSrc
=
'
'
+
'
#
version
300
es
\
n
'
+
'
in
mediump
vec4
v_color
;
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
v_color
;
\
n
'
+
'
}
\
n
'
;
var
src
=
'
#
version
300
es
\
n
'
;
if
(
this
.
m_isVertexCase
)
src
+
=
'
in
highp
vec4
a_position
;
\
n
'
+
'
out
mediump
vec4
v_color
;
\
n
'
;
else
src
+
=
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
;
src
+
=
'
void
main
(
void
)
\
n
{
\
n
'
+
'
\
t
'
+
(
this
.
m_isVertexCase
?
'
v_color
'
:
'
o_color
'
)
+
'
=
vec4
(
gl_DepthRange
.
near
gl_DepthRange
.
far
gl_DepthRange
.
diff
*
0
.
5
+
0
.
5
1
.
0
)
;
\
n
'
;
if
(
this
.
m_isVertexCase
)
src
+
=
'
\
tgl_Position
=
a_position
;
\
n
'
;
src
+
=
'
}
\
n
'
;
this
.
m_vertShaderSource
=
this
.
m_isVertexCase
?
src
:
defaultVertSrc
;
this
.
m_fragShaderSource
=
this
.
m_isVertexCase
?
defaultFragSrc
:
src
;
this
.
postinit
(
)
;
}
;
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
.
prototype
.
iterate
=
function
(
)
{
var
cases
=
[
new
es3fShaderBuiltinVarTests
.
DepthRangeParams
(
0
.
0
1
.
0
)
]
;
this
.
m_depthRange
=
cases
[
this
.
m_iterNdx
]
;
bufferedLogToConsole
(
'
gl
.
depthRange
(
'
+
this
.
m_depthRange
.
zNear
+
'
'
+
this
.
m_depthRange
.
zFar
+
'
)
'
)
;
gl
.
depthRange
(
this
.
m_depthRange
.
zNear
this
.
m_depthRange
.
zFar
)
;
this
.
postiterate
(
)
;
this
.
m_iterNdx
+
=
1
;
if
(
this
.
m_iterNdx
=
=
cases
.
length
)
return
tcuTestCase
.
IterateResult
.
STOP
;
else
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
}
;
es3fShaderBuiltinVarTests
.
FragCoordXYZCase
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
fragcoord_xyz
'
'
gl_FragCoord
.
xyz
Test
'
)
;
}
;
es3fShaderBuiltinVarTests
.
FragCoordXYZCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderBuiltinVarTests
.
FragCoordXYZCase
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
FragCoordXYZCase
;
es3fShaderBuiltinVarTests
.
FragCoordXYZCase
.
prototype
.
iterate
=
function
(
)
{
var
width
=
gl
.
drawingBufferWidth
;
var
height
=
gl
.
drawingBufferHeight
;
var
threshold
=
deMath
.
add
(
[
1
1
1
1
]
tcuPixelFormat
.
PixelFormatFromContext
(
gl
)
.
getColorThreshold
(
)
)
;
var
scale
=
[
1
.
/
width
1
.
/
height
1
.
0
]
;
var
testImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
refImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
vtxSource
=
'
'
+
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
}
\
n
'
;
var
fragSource
=
'
'
+
'
#
version
300
es
\
n
'
+
'
uniform
highp
vec3
u_scale
;
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
vec4
(
gl_FragCoord
.
xyz
*
u_scale
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vtxSource
fragSource
)
)
;
bufferedLogToConsole
(
program
.
getProgramInfo
(
)
.
infoLog
)
;
if
(
!
program
.
isOk
(
)
)
throw
new
Error
(
'
Compile
failed
'
)
;
var
positions
=
[
-
1
.
0
1
.
0
-
1
.
0
1
.
0
-
1
.
0
-
1
.
0
0
.
0
1
.
0
1
.
0
1
.
0
0
.
0
1
.
0
1
.
0
-
1
.
0
1
.
0
1
.
0
]
;
var
indices
=
[
0
1
2
2
1
3
]
;
var
scaleLoc
=
gl
.
getUniformLocation
(
program
.
getProgram
(
)
'
u_scale
'
)
;
var
posBinding
=
gluDrawUtil
.
newFloatVertexArrayBinding
(
'
a_position
'
4
4
0
positions
)
;
gl
.
useProgram
(
program
.
getProgram
(
)
)
;
gl
.
uniform3fv
(
scaleLoc
scale
)
;
gl
.
viewport
(
0
0
width
height
)
;
gluDrawUtil
.
draw
(
gl
program
.
getProgram
(
)
[
posBinding
]
gluDrawUtil
.
triangles
(
indices
)
)
;
testImg
.
readViewport
(
gl
[
0
0
width
height
]
)
;
for
(
var
y
=
0
;
y
<
refImg
.
getHeight
(
)
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
refImg
.
getWidth
(
)
;
x
+
+
)
{
var
xf
=
(
x
+
.
5
)
/
refImg
.
getWidth
(
)
;
var
yf
=
(
refImg
.
getHeight
(
)
-
y
-
1
+
.
5
)
/
refImg
.
getHeight
(
)
;
var
z
=
(
xf
+
yf
)
/
2
.
0
;
var
fragCoord
=
[
x
+
.
5
y
+
.
5
z
]
;
var
scaledFC
=
deMath
.
multiply
(
fragCoord
scale
)
;
var
color
=
[
deMath
.
clamp
(
Math
.
floor
(
scaledFC
[
0
]
*
255
+
0
.
5
)
0
255
)
deMath
.
clamp
(
Math
.
floor
(
scaledFC
[
1
]
*
255
+
0
.
5
)
0
255
)
deMath
.
clamp
(
Math
.
floor
(
scaledFC
[
2
]
*
255
+
0
.
5
)
0
255
)
255
]
;
refImg
.
setPixel
(
x
y
color
)
;
}
}
var
isOk
=
tcuImageCompare
.
pixelThresholdCompare
(
'
Result
'
'
Image
comparison
result
'
refImg
testImg
threshold
)
;
if
(
!
isOk
)
testFailedOptions
(
'
Image
comparison
failed
'
false
)
;
else
testPassedOptions
(
'
Pass
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fShaderBuiltinVarTests
.
projectedTriInterpolate
=
function
(
s
w
nx
ny
)
{
return
(
s
[
0
]
*
(
1
.
0
-
nx
-
ny
)
/
w
[
0
]
+
s
[
1
]
*
ny
/
w
[
1
]
+
s
[
2
]
*
nx
/
w
[
2
]
)
/
(
(
1
.
0
-
nx
-
ny
)
/
w
[
0
]
+
ny
/
w
[
1
]
+
nx
/
w
[
2
]
)
;
}
;
es3fShaderBuiltinVarTests
.
FragCoordWCase
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
fragcoord_w
'
'
gl_FragCoord
.
w
Test
'
)
;
}
;
es3fShaderBuiltinVarTests
.
FragCoordWCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderBuiltinVarTests
.
FragCoordWCase
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
FragCoordWCase
;
es3fShaderBuiltinVarTests
.
FragCoordWCase
.
prototype
.
iterate
=
function
(
)
{
var
width
=
gl
.
drawingBufferWidth
;
var
height
=
gl
.
drawingBufferHeight
;
var
threshold
=
deMath
.
add
(
[
1
1
1
1
]
tcuPixelFormat
.
PixelFormatFromContext
(
gl
)
.
getColorThreshold
(
)
)
;
var
testImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
refImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
w
=
[
1
.
7
2
.
0
1
.
2
1
.
0
]
;
var
vtxSource
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
}
\
n
'
;
var
fragSource
=
'
#
version
300
es
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
vec4
(
0
.
0
1
.
0
/
gl_FragCoord
.
w
-
1
.
0
0
.
0
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vtxSource
fragSource
)
)
;
bufferedLogToConsole
(
program
.
getProgramInfo
(
)
.
infoLog
)
;
if
(
!
program
.
isOk
(
)
)
throw
new
Error
(
'
Compile
failed
'
)
;
var
positions
=
[
-
w
[
0
]
w
[
0
]
0
.
0
w
[
0
]
-
w
[
1
]
-
w
[
1
]
0
.
0
w
[
1
]
w
[
2
]
w
[
2
]
0
.
0
w
[
2
]
w
[
3
]
-
w
[
3
]
0
.
0
w
[
3
]
]
;
var
indices
=
[
0
1
2
2
1
3
]
;
var
posBinding
=
gluDrawUtil
.
newFloatVertexArrayBinding
(
'
a_position
'
4
4
0
positions
)
;
gl
.
useProgram
(
program
.
getProgram
(
)
)
;
gluDrawUtil
.
draw
(
gl
program
.
getProgram
(
)
[
posBinding
]
gluDrawUtil
.
triangles
(
indices
)
)
;
testImg
.
readViewport
(
gl
[
0
0
width
height
]
)
;
for
(
var
y
=
0
;
y
<
refImg
.
getHeight
(
)
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
refImg
.
getWidth
(
)
;
x
+
+
)
{
var
xf
=
(
x
+
0
.
5
)
/
refImg
.
getWidth
(
)
;
var
yf
=
(
refImg
.
getHeight
(
)
-
y
-
1
+
0
.
5
)
/
refImg
.
getHeight
(
)
;
var
oow
=
(
(
xf
+
yf
)
<
1
.
0
)
?
es3fShaderBuiltinVarTests
.
projectedTriInterpolate
(
[
w
[
0
]
w
[
1
]
w
[
2
]
]
[
w
[
0
]
w
[
1
]
w
[
2
]
]
xf
yf
)
:
es3fShaderBuiltinVarTests
.
projectedTriInterpolate
(
[
w
[
3
]
w
[
2
]
w
[
1
]
]
[
w
[
3
]
w
[
2
]
w
[
1
]
]
1
.
0
-
xf
1
.
0
-
yf
)
;
var
color
=
[
0
deMath
.
clamp
(
Math
.
floor
(
(
oow
-
1
.
0
)
*
255
+
0
.
5
)
0
255
)
0
255
]
;
refImg
.
setPixel
(
x
y
color
)
;
}
}
var
isOk
=
tcuImageCompare
.
pixelThresholdCompare
(
'
Result
'
'
Image
comparison
result
'
refImg
testImg
threshold
)
;
if
(
!
isOk
)
{
testFailedOptions
(
'
Image
comparison
failed
'
false
)
;
}
else
testPassedOptions
(
'
Pass
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fShaderBuiltinVarTests
.
PointCoordCase
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
pointcoord
'
'
gl_PointCoord
Test
'
)
;
}
;
es3fShaderBuiltinVarTests
.
PointCoordCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderBuiltinVarTests
.
PointCoordCase
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
PointCoordCase
;
es3fShaderBuiltinVarTests
.
PointCoordCase
.
prototype
.
iterate
=
function
(
)
{
var
width
=
Math
.
min
(
256
gl
.
drawingBufferWidth
)
;
var
height
=
Math
.
min
(
256
gl
.
drawingBufferHeight
)
;
var
threshold
=
0
.
02
;
var
numPoints
=
8
;
var
coords
=
[
]
;
var
pointSizeRange
=
[
0
.
0
0
.
0
]
;
var
rnd
=
new
deRandom
.
Random
(
0x145fa
)
;
var
testImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
refImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
pointSizeRange
=
(
gl
.
getParameter
(
gl
.
ALIASED_POINT_SIZE_RANGE
)
)
;
if
(
pointSizeRange
[
0
]
<
=
0
.
0
|
|
pointSizeRange
[
1
]
<
=
0
.
0
|
|
pointSizeRange
[
1
]
<
pointSizeRange
[
0
]
)
throw
new
Error
(
'
Invalid
gl
.
ALIASED_POINT_SIZE_RANGE
'
)
;
for
(
var
i
=
0
;
i
<
numPoints
;
i
+
+
)
coords
.
push
(
[
rnd
.
getFloat
(
-
0
.
9
0
.
9
)
rnd
.
getFloat
(
-
0
.
9
0
.
9
)
rnd
.
getFloat
(
pointSizeRange
[
0
]
pointSizeRange
[
1
]
)
]
)
;
var
vtxSource
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec3
a_positionSize
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
vec4
(
a_positionSize
.
xy
0
.
0
1
.
0
)
;
\
n
'
+
'
gl_PointSize
=
a_positionSize
.
z
;
\
n
'
+
'
}
\
n
'
;
var
fragSource
=
'
#
version
300
es
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
vec4
(
gl_PointCoord
0
.
0
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vtxSource
fragSource
)
)
;
bufferedLogToConsole
(
program
.
getProgramInfo
(
)
.
infoLog
)
;
if
(
!
program
.
isOk
(
)
)
throw
new
Error
(
'
Compile
failed
'
)
;
var
newCoords
=
[
]
.
concat
.
apply
(
[
]
coords
)
;
var
posBinding
=
gluDrawUtil
.
newFloatVertexArrayBinding
(
'
a_positionSize
'
3
coords
.
length
12
newCoords
)
;
var
viewportX
=
rnd
.
getInt
(
0
gl
.
drawingBufferWidth
-
width
)
;
var
viewportY
=
rnd
.
getInt
(
0
gl
.
drawingBufferHeight
-
height
)
;
gl
.
viewport
(
viewportX
viewportY
width
height
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
gl
.
useProgram
(
program
.
getProgram
(
)
)
;
gluDrawUtil
.
draw
(
gl
program
.
getProgram
(
)
[
posBinding
]
gluDrawUtil
.
pointsFromElements
(
coords
.
length
)
)
;
testImg
.
readViewport
(
gl
[
viewportX
viewportY
width
height
]
)
;
refImg
.
getAccess
(
)
.
clear
(
[
0
.
0
0
.
0
0
.
0
1
.
0
]
)
;
for
(
var
i
=
0
;
i
<
coords
.
length
;
i
+
+
)
{
var
x0
=
Math
.
round
(
width
*
(
coords
[
i
]
[
0
]
*
0
.
5
+
0
.
5
)
-
coords
[
i
]
[
2
]
*
0
.
5
)
;
var
y0
=
Math
.
round
(
height
*
(
coords
[
i
]
[
1
]
*
0
.
5
+
0
.
5
)
-
coords
[
i
]
[
2
]
*
0
.
5
)
;
var
x1
=
Math
.
round
(
width
*
(
coords
[
i
]
[
0
]
*
0
.
5
+
0
.
5
)
+
coords
[
i
]
[
2
]
*
0
.
5
)
;
var
y1
=
Math
.
round
(
height
*
(
coords
[
i
]
[
1
]
*
0
.
5
+
0
.
5
)
+
coords
[
i
]
[
2
]
*
0
.
5
)
;
var
w
=
x1
-
x0
;
var
h
=
y1
-
y0
;
for
(
var
yo
=
0
;
yo
<
h
;
yo
+
+
)
{
for
(
var
xo
=
0
;
xo
<
w
;
xo
+
+
)
{
var
xf
=
(
xo
+
0
.
5
)
/
w
;
var
yf
=
(
(
h
-
yo
-
1
)
+
0
.
5
)
/
h
;
var
dx
=
x0
+
xo
;
var
dy
=
y0
+
yo
;
var
color
=
[
deMath
.
clamp
(
Math
.
floor
(
xf
*
255
+
0
.
5
)
0
255
)
deMath
.
clamp
(
Math
.
floor
(
yf
*
255
+
0
.
5
)
0
255
)
0
255
]
;
if
(
deMath
.
deInBounds32
(
dx
0
refImg
.
getWidth
(
)
)
&
&
deMath
.
deInBounds32
(
dy
0
refImg
.
getHeight
(
)
)
)
refImg
.
setPixel
(
dx
dy
color
)
;
}
}
}
var
isOk
=
tcuImageCompare
.
fuzzyCompare
(
'
Result
'
'
Image
comparison
result
'
refImg
.
getAccess
(
)
testImg
.
getAccess
(
)
threshold
)
;
if
(
!
isOk
)
{
testFailedOptions
(
'
Image
comparison
failed
'
false
)
;
}
else
testPassedOptions
(
'
Pass
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fShaderBuiltinVarTests
.
FrontFacingCase
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
frontfacing
'
'
gl_FrontFacing
Test
'
)
;
}
;
es3fShaderBuiltinVarTests
.
FrontFacingCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderBuiltinVarTests
.
FrontFacingCase
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
FrontFacingCase
;
es3fShaderBuiltinVarTests
.
FrontFacingCase
.
prototype
.
iterate
=
function
(
)
{
var
rnd
=
new
deRandom
.
Random
(
0x89f2c
)
;
var
width
=
Math
.
min
(
64
gl
.
drawingBufferWidth
)
;
var
height
=
Math
.
min
(
64
gl
.
drawingBufferHeight
)
;
var
viewportX
=
rnd
.
getInt
(
0
gl
.
drawingBufferWidth
-
width
)
;
var
viewportY
=
rnd
.
getInt
(
0
gl
.
drawingBufferHeight
-
height
)
;
var
threshold
=
deMath
.
add
(
[
1
1
1
1
]
tcuPixelFormat
.
PixelFormatFromContext
(
gl
)
.
getColorThreshold
(
)
)
;
var
testImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
refImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
vtxSource
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
}
\
n
'
;
var
fragSource
=
'
#
version
300
es
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
if
(
gl_FrontFacing
)
\
n
'
+
'
o_color
=
vec4
(
0
.
0
1
.
0
0
.
0
1
.
0
)
;
\
n
'
+
'
else
\
n
'
+
'
o_color
=
vec4
(
0
.
0
0
.
0
1
.
0
1
.
0
)
;
\
n
'
+
'
}
\
n
'
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vtxSource
fragSource
)
)
;
bufferedLogToConsole
(
program
.
getProgramInfo
(
)
.
infoLog
)
;
if
(
!
program
.
isOk
(
)
)
throw
new
Error
(
'
Compile
failed
'
)
;
var
positions
=
[
-
1
.
0
1
.
0
0
.
0
1
.
0
-
1
.
0
-
1
.
0
0
.
0
1
.
0
1
.
0
1
.
0
0
.
0
1
.
0
1
.
0
-
1
.
0
0
.
0
1
.
0
]
;
var
indicesCCW
=
[
0
1
2
2
1
3
]
;
var
indicesCW
=
[
2
1
0
3
1
2
]
;
var
posBinding
=
gluDrawUtil
.
newFloatVertexArrayBinding
(
'
a_position
'
4
4
0
positions
)
;
gl
.
useProgram
(
program
.
getProgram
(
)
)
;
gl
.
viewport
(
viewportX
viewportY
Math
.
floor
(
width
/
2
)
height
)
;
gluDrawUtil
.
draw
(
gl
program
.
getProgram
(
)
[
posBinding
]
gluDrawUtil
.
triangles
(
indicesCCW
)
)
;
gl
.
viewport
(
viewportX
+
Math
.
floor
(
width
/
2
)
viewportY
width
-
Math
.
floor
(
width
/
2
)
height
)
;
gluDrawUtil
.
draw
(
gl
program
.
getProgram
(
)
[
posBinding
]
gluDrawUtil
.
triangles
(
indicesCW
)
)
;
testImg
.
readViewport
(
gl
[
viewportX
viewportY
width
height
]
)
;
for
(
var
y
=
0
;
y
<
refImg
.
getHeight
(
)
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
Math
.
floor
(
refImg
.
getWidth
(
)
/
2
)
;
x
+
+
)
refImg
.
setPixel
(
x
y
tcuRGBA
.
RGBA
.
green
.
toIVec
(
)
)
;
for
(
var
x
=
Math
.
floor
(
refImg
.
getWidth
(
)
/
2
)
;
x
<
refImg
.
getWidth
(
)
;
x
+
+
)
refImg
.
setPixel
(
x
y
tcuRGBA
.
RGBA
.
blue
.
toIVec
(
)
)
;
}
var
isOk
=
tcuImageCompare
.
pixelThresholdCompare
(
'
Result
'
'
Image
comparison
result
'
refImg
testImg
threshold
)
;
if
(
!
isOk
)
{
testFailedOptions
(
'
Image
comparison
failed
'
false
)
;
}
else
testPassedOptions
(
'
Pass
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fShaderBuiltinVarTests
.
VertexIDCase
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
vertex_id
'
'
gl_VertexID
Test
'
)
;
this
.
m_program
=
null
;
this
.
m_positionBuffer
=
null
;
this
.
m_elementBuffer
=
null
;
this
.
m_viewportW
=
0
;
this
.
m_viewportH
=
0
;
this
.
m_iterNdx
=
0
;
this
.
m_positions
=
[
]
;
this
.
m_colors
=
[
]
;
}
;
es3fShaderBuiltinVarTests
.
VertexIDCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderBuiltinVarTests
.
VertexIDCase
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
VertexIDCase
;
es3fShaderBuiltinVarTests
.
VertexIDCase
.
MAX_VERTICES
=
24
;
es3fShaderBuiltinVarTests
.
VertexIDCase
.
prototype
.
init
=
function
(
)
{
var
width
=
gl
.
drawingBufferWidth
;
var
height
=
gl
.
drawingBufferHeight
;
var
quadWidth
=
32
;
var
quadHeight
=
32
;
if
(
width
<
quadWidth
)
throw
new
Error
(
'
Too
small
render
target
'
)
;
var
maxQuadsX
=
Math
.
floor
(
width
/
quadWidth
)
;
var
numVertices
=
es3fShaderBuiltinVarTests
.
VertexIDCase
.
MAX_VERTICES
;
var
numQuads
=
Math
.
floor
(
numVertices
/
6
)
+
(
numVertices
%
6
!
=
0
?
1
:
0
)
;
var
viewportW
=
Math
.
min
(
numQuads
maxQuadsX
)
*
quadWidth
;
var
viewportH
=
(
Math
.
floor
(
numQuads
/
maxQuadsX
)
+
(
numQuads
%
maxQuadsX
!
=
0
?
1
:
0
)
)
*
quadHeight
;
if
(
viewportH
>
height
)
throw
new
Error
(
'
Too
small
render
target
'
)
;
assertMsgOptions
(
viewportW
<
=
width
&
&
viewportH
<
=
height
'
Unexpected
viewport
dimensions
.
'
false
true
)
;
assertMsgOptions
(
!
this
.
m_program
'
Program
should
not
be
defined
at
this
point
.
'
false
true
)
;
var
vtxSource
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
out
mediump
vec4
v_color
;
\
n
'
+
'
uniform
highp
vec4
u_colors
[
24
]
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
v_color
=
u_colors
[
gl_VertexID
]
;
\
n
'
+
'
}
\
n
'
;
var
fragSource
=
'
#
version
300
es
\
n
'
+
'
in
mediump
vec4
v_color
;
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
v_color
;
\
n
'
+
'
}
\
n
'
;
this
.
m_program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vtxSource
fragSource
)
)
;
bufferedLogToConsole
(
this
.
m_program
.
getProgramInfo
(
)
.
infoLog
)
;
if
(
!
this
.
m_program
.
isOk
(
)
)
{
this
.
m_program
=
null
;
throw
new
Error
(
'
Compile
failed
'
)
;
}
this
.
m_positionBuffer
=
gl
.
createBuffer
(
)
;
this
.
m_elementBuffer
=
gl
.
createBuffer
(
)
;
this
.
m_colors
[
0
]
=
[
0
.
0
0
.
0
0
.
0
1
.
0
]
;
this
.
m_colors
[
1
]
=
[
0
.
5
1
.
0
0
.
5
1
.
0
]
;
this
.
m_colors
[
2
]
=
[
0
.
0
0
.
5
1
.
0
1
.
0
]
;
this
.
m_colors
[
3
]
=
[
0
.
0
1
.
0
0
.
0
1
.
0
]
;
this
.
m_colors
[
4
]
=
[
0
.
0
1
.
0
1
.
0
1
.
0
]
;
this
.
m_colors
[
5
]
=
[
0
.
5
0
.
0
0
.
0
1
.
0
]
;
this
.
m_colors
[
6
]
=
[
0
.
5
0
.
0
1
.
0
1
.
0
]
;
this
.
m_colors
[
7
]
=
[
0
.
5
0
.
0
0
.
5
1
.
0
]
;
this
.
m_colors
[
8
]
=
[
1
.
0
0
.
0
0
.
0
1
.
0
]
;
this
.
m_colors
[
9
]
=
[
0
.
5
1
.
0
0
.
0
1
.
0
]
;
this
.
m_colors
[
10
]
=
[
0
.
0
0
.
5
0
.
0
1
.
0
]
;
this
.
m_colors
[
11
]
=
[
0
.
5
1
.
0
1
.
0
1
.
0
]
;
this
.
m_colors
[
12
]
=
[
0
.
0
0
.
0
1
.
0
1
.
0
]
;
this
.
m_colors
[
13
]
=
[
1
.
0
0
.
0
0
.
5
1
.
0
]
;
this
.
m_colors
[
14
]
=
[
0
.
0
0
.
5
0
.
5
1
.
0
]
;
this
.
m_colors
[
15
]
=
[
1
.
0
1
.
0
0
.
5
1
.
0
]
;
this
.
m_colors
[
16
]
=
[
1
.
0
0
.
0
1
.
0
1
.
0
]
;
this
.
m_colors
[
17
]
=
[
1
.
0
0
.
5
0
.
0
1
.
0
]
;
this
.
m_colors
[
18
]
=
[
0
.
0
1
.
0
0
.
5
1
.
0
]
;
this
.
m_colors
[
19
]
=
[
1
.
0
0
.
5
1
.
0
1
.
0
]
;
this
.
m_colors
[
20
]
=
[
1
.
0
1
.
0
0
.
0
1
.
0
]
;
this
.
m_colors
[
21
]
=
[
1
.
0
0
.
5
0
.
5
1
.
0
]
;
this
.
m_colors
[
22
]
=
[
0
.
0
0
.
0
0
.
5
1
.
0
]
;
this
.
m_colors
[
23
]
=
[
1
.
0
1
.
0
1
.
0
1
.
0
]
;
assertMsgOptions
(
numVertices
%
3
=
=
0
'
Number
of
vertices
should
be
multiple
of
3
.
'
false
true
)
;
for
(
var
vtxNdx
=
0
;
vtxNdx
<
numVertices
;
vtxNdx
+
=
3
)
{
var
h
=
2
.
0
*
quadHeight
/
viewportH
;
var
w
=
2
.
0
*
quadWidth
/
viewportW
;
var
triNdx
=
Math
.
floor
(
vtxNdx
/
3
)
;
var
quadNdx
=
Math
.
floor
(
triNdx
/
2
)
;
var
quadY
=
Math
.
floor
(
quadNdx
/
maxQuadsX
)
;
var
quadX
=
quadNdx
%
maxQuadsX
;
var
x0
=
-
1
.
0
+
quadX
*
w
;
var
y0
=
-
1
.
0
+
quadY
*
h
;
if
(
triNdx
%
2
=
=
=
0
)
{
this
.
m_positions
[
vtxNdx
+
0
]
=
[
x0
y0
0
.
0
1
.
0
]
;
this
.
m_positions
[
vtxNdx
+
1
]
=
[
x0
+
w
y0
+
h
0
.
0
1
.
0
]
;
this
.
m_positions
[
vtxNdx
+
2
]
=
[
x0
y0
+
h
0
.
0
1
.
0
]
;
}
else
{
this
.
m_positions
[
vtxNdx
+
0
]
=
[
x0
+
w
y0
+
h
0
.
0
1
.
0
]
;
this
.
m_positions
[
vtxNdx
+
1
]
=
[
x0
y0
0
.
0
1
.
0
]
;
this
.
m_positions
[
vtxNdx
+
2
]
=
[
x0
+
w
y0
0
.
0
1
.
0
]
;
}
}
this
.
m_viewportW
=
viewportW
;
this
.
m_viewportH
=
viewportH
;
this
.
m_iterNdx
=
0
;
}
;
es3fShaderBuiltinVarTests
.
VertexIDCase
.
prototype
.
deinit
=
function
(
)
{
this
.
m_program
=
null
;
if
(
this
.
m_positionBuffer
)
{
gl
.
deleteBuffer
(
this
.
m_positionBuffer
)
;
this
.
m_positionBuffer
=
null
;
}
if
(
this
.
m_elementBuffer
)
{
gl
.
deleteBuffer
(
this
.
m_elementBuffer
)
;
this
.
m_elementBuffer
=
null
;
}
this
.
m_positions
=
[
]
;
this
.
m_colors
=
[
]
;
}
;
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
=
function
(
)
{
var
declaration
=
new
sglrShaderProgram
.
ShaderProgramDeclaration
(
)
;
declaration
.
pushVertexAttribute
(
new
sglrShaderProgram
.
VertexAttribute
(
'
'
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
declaration
.
pushVertexAttribute
(
new
sglrShaderProgram
.
VertexAttribute
(
'
'
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
declaration
.
pushVertexToFragmentVarying
(
new
sglrShaderProgram
.
VertexToFragmentVarying
(
rrGenericVector
.
GenericVecType
.
FLOAT
new
sglrShaderProgram
.
VaryingFlags
(
)
)
)
;
declaration
.
pushFragmentOutput
(
new
sglrShaderProgram
.
FragmentOutput
(
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
declaration
.
pushVertexSource
(
new
sglrShaderProgram
.
VertexSource
(
'
'
)
)
;
declaration
.
pushFragmentSource
(
new
sglrShaderProgram
.
FragmentSource
(
'
'
)
)
;
sglrShaderProgram
.
ShaderProgram
.
call
(
this
declaration
)
;
}
;
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
.
prototype
=
Object
.
create
(
sglrShaderProgram
.
ShaderProgram
.
prototype
)
;
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
;
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
.
VARYINGLOC_COLOR
=
0
;
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
.
prototype
.
shadeVertices
=
function
(
inputs
packets
)
{
for
(
var
packetNdx
=
0
;
packetNdx
<
packets
.
length
;
+
+
packetNdx
)
{
var
positionAttrLoc
=
0
;
var
colorAttrLoc
=
1
;
var
packet
=
packets
[
packetNdx
]
;
packet
.
position
=
rrVertexAttrib
.
readVertexAttrib
(
inputs
[
positionAttrLoc
]
packet
.
instanceNdx
packet
.
vertexNdx
rrGenericVector
.
GenericVecType
.
FLOAT
)
;
packet
.
outputs
[
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
.
VARYINGLOC_COLOR
]
=
rrVertexAttrib
.
readVertexAttrib
(
inputs
[
colorAttrLoc
]
packet
.
instanceNdx
packet
.
vertexNdx
rrGenericVector
.
GenericVecType
.
FLOAT
)
;
}
}
;
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
.
prototype
.
shadeFragments
=
function
(
packets
context
)
{
for
(
var
packetNdx
=
0
;
packetNdx
<
packets
.
length
;
+
+
packetNdx
)
{
var
packet
=
packets
[
packetNdx
]
;
packet
.
value
=
rrShadingContext
.
readVarying
(
packet
context
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
.
VARYINGLOC_COLOR
)
;
}
}
;
es3fShaderBuiltinVarTests
.
VertexIDCase
.
prototype
.
renderReference
=
function
(
dst
indices
positions
colors
)
{
var
referenceState
=
new
rrRenderState
.
RenderState
(
new
rrRenderState
.
ViewportState
(
rrMultisamplePixelBufferAccess
.
MultisamplePixelBufferAccess
.
fromSinglesampleAccess
(
dst
)
)
)
;
var
referenceTarget
=
new
rrRenderer
.
RenderTarget
(
rrMultisamplePixelBufferAccess
.
MultisamplePixelBufferAccess
.
fromSinglesampleAccess
(
dst
)
)
;
var
referenceShaderProgram
=
new
es3fShaderBuiltinVarTests
.
VertexIDReferenceShader
(
)
;
var
attribs
=
[
]
;
attribs
[
0
]
=
new
rrVertexAttrib
.
VertexAttrib
(
)
;
attribs
[
0
]
.
type
=
rrVertexAttrib
.
VertexAttribType
.
FLOAT
;
attribs
[
0
]
.
size
=
4
;
attribs
[
0
]
.
stride
=
0
;
attribs
[
0
]
.
instanceDivisor
=
0
;
attribs
[
0
]
.
pointer
=
positions
.
buffer
;
attribs
[
1
]
=
new
rrVertexAttrib
.
VertexAttrib
(
)
;
attribs
[
1
]
.
type
=
rrVertexAttrib
.
VertexAttribType
.
FLOAT
;
attribs
[
1
]
.
size
=
4
;
attribs
[
1
]
.
stride
=
0
;
attribs
[
1
]
.
instanceDivisor
=
0
;
attribs
[
1
]
.
pointer
=
colors
.
buffer
;
rrRenderer
.
drawTriangles
(
referenceState
referenceTarget
referenceShaderProgram
attribs
rrRenderer
.
PrimitiveType
.
TRIANGLES
0
indices
.
length
0
)
;
}
;
es3fShaderBuiltinVarTests
.
VertexIDCase
.
prototype
.
iterate
=
function
(
)
{
var
width
=
gl
.
drawingBufferWidth
;
var
height
=
gl
.
drawingBufferHeight
;
var
viewportW
=
this
.
m_viewportW
;
var
viewportH
=
this
.
m_viewportH
;
var
threshold
=
0
.
02
;
var
rnd
=
new
deRandom
.
Random
(
0xcf23ab1
^
deString
.
deStringHash
(
this
.
m_iterNdx
.
toString
(
)
)
)
;
var
refImg
=
new
tcuSurface
.
Surface
(
viewportW
viewportH
)
;
var
testImg
=
new
tcuSurface
.
Surface
(
viewportW
viewportH
)
;
var
viewportX
=
rnd
.
getInt
(
0
width
-
viewportW
)
;
var
viewportY
=
rnd
.
getInt
(
0
height
-
viewportH
)
;
var
posLoc
=
gl
.
getAttribLocation
(
this
.
m_program
.
getProgram
(
)
'
a_position
'
)
;
var
colorsLoc
=
gl
.
getUniformLocation
(
this
.
m_program
.
getProgram
(
)
'
u_colors
[
0
]
'
)
;
var
clearColor
=
[
0
.
0
0
.
0
0
.
0
1
.
0
]
;
var
indices
=
[
]
;
var
mappedPos
=
[
]
;
var
flatColorArray
;
var
flatPosArray
;
gl
.
viewport
(
viewportX
viewportY
viewportW
viewportH
)
;
gl
.
useProgram
(
this
.
m_program
.
getProgram
(
)
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
this
.
m_positionBuffer
)
;
gl
.
enableVertexAttribArray
(
posLoc
)
;
gl
.
vertexAttribPointer
(
posLoc
4
gl
.
FLOAT
false
0
0
)
;
gl
.
uniform4fv
(
colorsLoc
[
]
.
concat
.
apply
(
[
]
this
.
m_colors
)
)
;
gl
.
clearColor
(
clearColor
[
0
]
clearColor
[
1
]
clearColor
[
2
]
clearColor
[
3
]
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
refImg
.
getAccess
(
)
.
clear
(
clearColor
)
;
if
(
this
.
m_iterNdx
=
=
=
0
)
{
bufferedLogToConsole
(
'
Iter0
:
glDrawArrays
(
)
'
)
;
flatPosArray
=
new
Float32Array
(
[
]
.
concat
.
apply
(
[
]
this
.
m_positions
)
)
;
flatColorArray
=
new
Float32Array
(
[
]
.
concat
.
apply
(
[
]
this
.
m_colors
)
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
flatPosArray
.
buffer
gl
.
DYNAMIC_DRAW
)
;
gl
.
drawArrays
(
gl
.
TRIANGLES
0
Math
.
floor
(
flatPosArray
.
length
/
4
)
)
;
testImg
.
readViewport
(
gl
[
viewportX
viewportY
viewportW
viewportH
]
)
;
for
(
var
ndx
=
0
;
ndx
<
this
.
m_positions
.
length
;
ndx
+
+
)
indices
.
push
(
ndx
)
;
this
.
renderReference
(
refImg
.
getAccess
(
)
indices
flatPosArray
flatColorArray
)
;
}
else
if
(
this
.
m_iterNdx
=
=
=
1
)
{
bufferedLogToConsole
(
'
Iter1
:
glDrawElements
(
)
indices
in
buffer
'
)
;
for
(
var
ndx
=
0
;
ndx
<
this
.
m_positions
.
length
;
ndx
+
+
)
indices
.
push
(
ndx
)
;
for
(
var
ndx
=
0
;
ndx
<
indices
.
length
;
ndx
+
+
)
mappedPos
[
indices
[
ndx
]
]
=
this
.
m_positions
[
ndx
]
;
gl
.
bindBuffer
(
gl
.
ELEMENT_ARRAY_BUFFER
this
.
m_elementBuffer
)
;
gl
.
bufferData
(
gl
.
ELEMENT_ARRAY_BUFFER
(
new
Uint16Array
(
indices
)
)
.
buffer
gl
.
DYNAMIC_DRAW
)
;
flatPosArray
=
new
Float32Array
(
[
]
.
concat
.
apply
(
[
]
mappedPos
)
)
;
flatColorArray
=
new
Float32Array
(
[
]
.
concat
.
apply
(
[
]
this
.
m_colors
)
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
flatPosArray
.
buffer
gl
.
DYNAMIC_DRAW
)
;
gl
.
drawElements
(
gl
.
TRIANGLES
indices
.
length
gl
.
UNSIGNED_SHORT
0
)
;
testImg
.
readViewport
(
gl
[
viewportX
viewportY
viewportW
viewportH
]
)
;
refImg
.
getAccess
(
)
.
clear
(
clearColor
)
;
this
.
renderReference
(
refImg
.
getAccess
(
)
indices
flatPosArray
flatColorArray
)
;
}
else
throw
new
Error
(
'
Iteration
count
exceeded
.
'
)
;
if
(
!
tcuImageCompare
.
fuzzyCompare
(
'
Result
'
'
Image
comparison
result
'
refImg
.
getAccess
(
)
testImg
.
getAccess
(
)
threshold
)
)
testFailedOptions
(
'
Image
comparison
failed
'
false
)
;
else
testPassedOptions
(
'
Pass
'
true
)
;
this
.
m_iterNdx
+
=
1
;
return
(
this
.
m_iterNdx
<
2
)
?
tcuTestCase
.
IterateResult
.
CONTINUE
:
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinVarTests
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
builtin_variable
'
'
Built
-
in
Variable
Tests
'
)
;
}
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinVarTests
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinVarTests
.
prototype
.
constructor
=
es3fShaderBuiltinVarTests
.
ShaderBuiltinVarTests
;
es3fShaderBuiltinVarTests
.
ShaderBuiltinVarTests
.
prototype
.
init
=
function
(
)
{
var
testGroup
=
tcuTestCase
.
runner
.
testCases
;
var
BuiltinConstant
=
function
(
caseName
varName
getValue
)
{
this
.
caseName
=
caseName
;
this
.
varName
=
varName
;
this
.
getValue
=
getValue
;
}
;
var
builtinConstants
=
[
new
BuiltinConstant
(
'
max_vertex_attribs
'
'
gl_MaxVertexAttribs
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_VERTEX_ATTRIBS
)
;
}
)
new
BuiltinConstant
(
'
max_vertex_uniform_vectors
'
'
gl_MaxVertexUniformVectors
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_VERTEX_UNIFORM_VECTORS
)
;
}
)
new
BuiltinConstant
(
'
max_fragment_uniform_vectors
'
'
gl_MaxFragmentUniformVectors
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_FRAGMENT_UNIFORM_VECTORS
)
;
}
)
new
BuiltinConstant
(
'
max_texture_image_units
'
'
gl_MaxTextureImageUnits
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_TEXTURE_IMAGE_UNITS
)
;
}
)
new
BuiltinConstant
(
'
max_vertex_texture_image_units
'
'
gl_MaxVertexTextureImageUnits
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_VERTEX_TEXTURE_IMAGE_UNITS
)
;
}
)
new
BuiltinConstant
(
'
max_combined_texture_image_units
'
'
gl_MaxCombinedTextureImageUnits
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_COMBINED_TEXTURE_IMAGE_UNITS
)
;
}
)
new
BuiltinConstant
(
'
max_draw_buffers
'
'
gl_MaxDrawBuffers
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_DRAW_BUFFERS
)
;
}
)
new
BuiltinConstant
(
'
max_vertex_output_vectors
'
'
gl_MaxVertexOutputVectors
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getVectorsFromComps
(
gl
.
MAX_VERTEX_OUTPUT_COMPONENTS
)
;
}
)
new
BuiltinConstant
(
'
max_fragment_input_vectors
'
'
gl_MaxFragmentInputVectors
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getVectorsFromComps
(
gl
.
MAX_FRAGMENT_INPUT_COMPONENTS
)
;
}
)
new
BuiltinConstant
(
'
min_program_texel_offset
'
'
gl_MinProgramTexelOffset
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MIN_PROGRAM_TEXEL_OFFSET
)
;
}
)
new
BuiltinConstant
(
'
max_program_texel_offset
'
'
gl_MaxProgramTexelOffset
'
function
(
)
{
return
es3fShaderBuiltinVarTests
.
getInteger
(
gl
.
MAX_PROGRAM_TEXEL_OFFSET
)
;
}
)
]
;
for
(
var
ndx
=
0
;
ndx
<
builtinConstants
.
length
;
ndx
+
+
)
{
var
caseName
=
builtinConstants
[
ndx
]
.
caseName
;
var
varName
=
builtinConstants
[
ndx
]
.
varName
;
var
getValue
=
builtinConstants
[
ndx
]
.
getValue
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
(
caseName
+
'
_vertex
'
varName
varName
getValue
gluShaderProgram
.
shaderType
.
VERTEX
)
)
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
ShaderBuiltinConstantCase
(
caseName
+
'
_fragment
'
varName
varName
getValue
gluShaderProgram
.
shaderType
.
FRAGMENT
)
)
;
}
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
(
'
depth_range_vertex
'
'
gl_DepthRange
'
true
)
)
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
ShaderDepthRangeTest
(
'
depth_range_fragment
'
'
gl_DepthRange
'
false
)
)
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
VertexIDCase
(
)
)
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
FragCoordXYZCase
(
)
)
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
FragCoordWCase
(
)
)
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
PointCoordCase
(
)
)
;
testGroup
.
addChild
(
new
es3fShaderBuiltinVarTests
.
FrontFacingCase
(
)
)
;
}
;
es3fShaderBuiltinVarTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
state
.
setRoot
(
new
es3fShaderBuiltinVarTests
.
ShaderBuiltinVarTests
(
)
)
;
setCurrentTestName
(
state
.
testCases
.
fullName
(
)
)
;
description
(
state
.
testCases
.
getDescription
(
)
)
;
try
{
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fShaderBuiltinVarTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
