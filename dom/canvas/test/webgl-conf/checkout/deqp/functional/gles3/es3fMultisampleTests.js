'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fMultisampleTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluStrUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuLogImage
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsTextureTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
gl
;
var
es3fMultisampleTests
=
functional
.
gles3
.
es3fMultisampleTests
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
gluStrUtil
=
framework
.
opengl
.
gluStrUtil
;
var
glsTextureTestUtil
=
modules
.
shared
.
glsTextureTestUtil
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
tcuLogImage
=
framework
.
common
.
tcuLogImage
;
es3fMultisampleTests
.
QuadCorners
=
function
(
p0_
p1_
p2_
p3_
)
{
this
.
p0
=
p0_
;
this
.
p1
=
p1_
;
this
.
p2
=
p2_
;
this
.
p3
=
p3_
;
}
;
es3fMultisampleTests
.
getIterationCount
=
function
(
defaultCount
)
{
return
defaultCount
;
}
;
es3fMultisampleTests
.
isInsideQuad
=
function
(
point
p0
p1
p2
p3
)
{
var
dot0
=
(
point
[
0
]
-
p0
[
0
]
)
*
(
p1
[
1
]
-
p0
[
1
]
)
+
(
point
[
1
]
-
p0
[
1
]
)
*
(
p0
[
0
]
-
p1
[
0
]
)
;
var
dot1
=
(
point
[
0
]
-
p1
[
0
]
)
*
(
p2
[
1
]
-
p1
[
1
]
)
+
(
point
[
1
]
-
p1
[
1
]
)
*
(
p1
[
0
]
-
p2
[
0
]
)
;
var
dot2
=
(
point
[
0
]
-
p2
[
0
]
)
*
(
p3
[
1
]
-
p2
[
1
]
)
+
(
point
[
1
]
-
p2
[
1
]
)
*
(
p2
[
0
]
-
p3
[
0
]
)
;
var
dot3
=
(
point
[
0
]
-
p3
[
0
]
)
*
(
p0
[
1
]
-
p3
[
1
]
)
+
(
point
[
1
]
-
p3
[
1
]
)
*
(
p3
[
0
]
-
p0
[
0
]
)
;
return
(
dot0
>
0
)
=
=
(
dot1
>
0
)
&
&
(
dot1
>
0
)
=
=
(
dot2
>
0
)
&
&
(
dot2
>
0
)
=
=
(
dot3
>
0
)
;
}
;
es3fMultisampleTests
.
isPixelRegionUnicolored
=
function
(
img
p0
p1
p2
p3
)
{
var
xMin
=
deMath
.
clamp
(
Math
.
min
(
p0
[
0
]
p1
[
0
]
p2
[
0
]
p3
[
0
]
)
0
img
.
getWidth
(
)
-
1
)
;
var
yMin
=
deMath
.
clamp
(
Math
.
min
(
p0
[
1
]
p1
[
1
]
p2
[
1
]
p3
[
1
]
)
0
img
.
getHeight
(
)
-
1
)
;
var
xMax
=
deMath
.
clamp
(
Math
.
max
(
p0
[
0
]
p1
[
0
]
p2
[
0
]
p3
[
0
]
)
0
img
.
getWidth
(
)
-
1
)
;
var
yMax
=
deMath
.
clamp
(
Math
.
max
(
p0
[
1
]
p1
[
1
]
p2
[
1
]
p3
[
1
]
)
0
img
.
getHeight
(
)
-
1
)
;
var
insideEncountered
=
false
;
var
insideColor
;
var
threshold
=
tcuRGBA
.
newRGBAComponents
(
3
3
3
3
)
;
for
(
var
y
=
yMin
;
y
<
=
yMax
;
y
+
+
)
for
(
var
x
=
xMin
;
x
<
=
xMax
;
x
+
+
)
if
(
es3fMultisampleTests
.
isInsideQuad
(
[
x
y
]
p0
p1
p2
p3
)
)
{
var
pixColor
=
new
tcuRGBA
.
RGBA
(
img
.
getPixel
(
x
y
)
)
;
if
(
insideEncountered
)
if
(
!
tcuRGBA
.
compareThreshold
(
pixColor
insideColor
threshold
)
)
return
false
;
else
{
insideEncountered
=
true
;
insideColor
=
pixColor
;
}
}
return
true
;
}
;
es3fMultisampleTests
.
drawUnicolorTestErrors
=
function
(
img
errorImg
p0
p1
p2
p3
)
{
var
xMin
=
deMath
.
clamp
(
Math
.
min
(
p0
[
0
]
p1
[
0
]
p2
[
0
]
p3
[
0
]
)
0
img
.
getWidth
(
)
-
1
)
;
var
yMin
=
deMath
.
clamp
(
Math
.
min
(
p0
[
1
]
p1
[
1
]
p2
[
1
]
p3
[
1
]
)
0
img
.
getHeight
(
)
-
1
)
;
var
xMax
=
deMath
.
clamp
(
Math
.
max
(
p0
[
0
]
p1
[
0
]
p2
[
0
]
p3
[
0
]
)
0
img
.
getWidth
(
)
-
1
)
;
var
yMax
=
deMath
.
clamp
(
Math
.
max
(
p0
[
1
]
p1
[
1
]
p2
[
1
]
p3
[
1
]
)
0
img
.
getHeight
(
)
-
1
)
;
var
refColor
=
new
tcuRGBA
.
RGBA
(
img
.
getPixel
(
Math
.
floor
(
(
xMin
+
xMax
)
/
2
)
Math
.
floor
(
(
yMin
+
yMax
)
/
2
)
)
)
;
var
threshold
=
tcuRGBA
.
newRGBAComponents
(
3
3
3
3
)
;
for
(
var
y
=
yMin
;
y
<
=
yMax
;
y
+
+
)
for
(
var
x
=
xMin
;
x
<
=
xMax
;
x
+
+
)
if
(
es3fMultisampleTests
.
isInsideQuad
(
[
x
y
]
p0
p1
p2
p3
)
)
{
if
(
!
tcuRGBA
.
compareThreshold
(
new
tcuRGBA
.
RGBA
(
img
.
getPixel
(
x
y
)
)
refColor
threshold
)
)
{
img
.
setPixel
(
x
y
tcuRGBA
.
RGBA
.
red
.
toVec
(
)
)
;
errorImg
.
setPixel
(
[
1
.
0
0
.
0
0
.
0
1
.
0
]
x
y
)
;
}
}
return
true
;
}
;
es3fMultisampleTests
.
FboParams
=
function
(
numSamples_
useDepth_
useStencil_
)
{
var
useFbo_
=
true
;
if
(
numSamples_
=
=
=
undefined
&
&
useDepth_
=
=
=
undefined
&
&
useStencil_
=
=
=
undefined
)
useFbo_
=
false
;
this
.
useFbo
=
useFbo_
;
this
.
numSamples
=
numSamples_
=
=
=
undefined
?
-
1
:
numSamples_
;
this
.
useDepth
=
useDepth_
=
=
=
undefined
?
false
:
useDepth_
;
this
.
useStencil
=
useStencil_
=
=
=
undefined
?
false
:
useStencil_
;
}
;
es3fMultisampleTests
.
MultisampleCase
=
function
(
name
desc
desiredViewportSize
fboParams
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
desc
)
;
this
.
m_numSamples
=
0
;
this
.
m_viewportSize
=
0
;
this
.
m_desiredViewportSize
=
desiredViewportSize
;
this
.
m_fboParams
=
fboParams
;
this
.
m_msColorRbo
=
null
;
this
.
m_msDepthStencilRbo
=
null
;
this
.
m_resolveColorRbo
=
null
;
this
.
m_msFbo
=
null
;
this
.
m_resolveFbo
=
null
;
this
.
m_program
=
null
;
this
.
m_attrPositionLoc
=
-
1
;
this
.
m_attrColorLoc
=
-
1
;
this
.
m_renderWidth
=
fboParams
.
useFbo
?
2
*
desiredViewportSize
:
gl
.
drawingBufferWidth
;
this
.
m_renderHeight
=
fboParams
.
useFbo
?
2
*
desiredViewportSize
:
gl
.
drawingBufferHeight
;
this
.
m_viewportX
=
0
;
this
.
m_viewportY
=
0
;
this
.
m_rnd
=
new
deRandom
.
Random
(
deString
.
deStringHash
(
this
.
name
)
)
;
if
(
this
.
m_fboParams
.
useFbo
)
assertMsgOptions
(
this
.
m_fboParams
.
numSamples
>
=
0
'
fboParams
.
numSamples
<
0
'
false
true
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
MultisampleCase
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
deinit
=
function
(
)
{
gl
.
colorMask
(
true
true
true
true
)
;
gl
.
depthMask
(
true
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
gl
.
clearDepth
(
1
.
0
)
;
gl
.
clearStencil
(
0
)
;
gl
.
disable
(
gl
.
STENCIL_TEST
)
;
gl
.
disable
(
gl
.
DEPTH_TEST
)
;
gl
.
disable
(
gl
.
BLEND
)
gl
.
disable
(
gl
.
SAMPLE_COVERAGE
)
;
gl
.
disable
(
gl
.
SAMPLE_ALPHA_TO_COVERAGE
)
;
if
(
this
.
m_program
)
{
gl
.
deleteProgram
(
this
.
m_program
.
getProgram
(
)
)
;
this
.
m_program
=
null
;
}
if
(
this
.
m_msColorRbo
)
{
gl
.
deleteRenderbuffer
(
this
.
m_msColorRbo
)
;
this
.
m_msColorRbo
=
null
;
}
if
(
this
.
m_msDepthStencilRbo
)
{
gl
.
deleteRenderbuffer
(
this
.
m_msDepthStencilRbo
)
;
this
.
m_msDepthStencilRbo
=
null
;
}
if
(
this
.
m_resolveColorRbo
)
{
gl
.
deleteRenderbuffer
(
this
.
m_resolveColorRbo
)
;
this
.
m_resolveColorRbo
=
null
;
}
if
(
this
.
m_msFbo
)
{
gl
.
deleteFramebuffer
(
this
.
m_msFbo
)
;
this
.
m_msFbo
=
null
;
}
if
(
this
.
m_resolveFbo
)
{
gl
.
deleteFramebuffer
(
this
.
m_resolveFbo
)
;
this
.
m_resolveFbo
=
null
;
}
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
null
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
}
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
renderTriangle_pAsVec3cAsVec4
=
function
(
p0
p1
p2
c0
c1
c2
)
{
var
vertexPositions
=
[
p0
[
0
]
p0
[
1
]
p0
[
2
]
1
.
0
p1
[
0
]
p1
[
1
]
p1
[
2
]
1
.
0
p2
[
0
]
p2
[
1
]
p2
[
2
]
1
.
0
]
;
var
vertexColors
=
[
c0
[
0
]
c0
[
1
]
c0
[
2
]
c0
[
3
]
c1
[
0
]
c1
[
1
]
c1
[
2
]
c1
[
3
]
c2
[
0
]
c2
[
1
]
c2
[
2
]
c2
[
3
]
]
;
var
posGLBuffer
=
gl
.
createBuffer
(
)
;
var
posBuffer
=
new
Float32Array
(
vertexPositions
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
posGLBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
posBuffer
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
this
.
m_attrPositionLoc
)
;
gl
.
vertexAttribPointer
(
this
.
m_attrPositionLoc
4
gl
.
FLOAT
false
0
0
)
;
var
colGLBuffer
=
gl
.
createBuffer
(
)
;
var
colBuffer
=
new
Float32Array
(
vertexColors
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
colGLBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
colBuffer
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
this
.
m_attrColorLoc
)
;
gl
.
vertexAttribPointer
(
this
.
m_attrColorLoc
4
gl
.
FLOAT
false
0
0
)
;
gl
.
useProgram
(
this
.
m_program
.
getProgram
(
)
)
;
gl
.
drawArrays
(
gl
.
TRIANGLES
0
3
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
null
)
;
gl
.
deleteBuffer
(
colGLBuffer
)
;
gl
.
deleteBuffer
(
posGLBuffer
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
renderTriangle_pAsVec3WithColor
=
function
(
p0
p1
p2
color
)
{
this
.
renderTriangle_pAsVec3cAsVec4
(
p0
p1
p2
color
color
color
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
renderTriangle_pAsVec2
=
function
(
p0
p1
p2
c0
c1
c2
)
{
this
.
renderTriangle_pAsVec3cAsVec4
(
[
p0
[
0
]
p0
[
1
]
0
.
0
]
[
p1
[
0
]
p1
[
1
]
0
.
0
]
[
p2
[
0
]
p2
[
1
]
0
.
0
]
c0
c1
c2
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
renderTriangle_pAsVec2WithColor
=
function
(
p0
p1
p2
color
)
{
this
.
renderTriangle_pAsVec2
(
p0
p1
p2
color
color
color
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
renderQuad
=
function
(
p0
p1
p2
p3
c0
c1
c2
c3
)
{
this
.
renderTriangle_pAsVec2
(
p0
p1
p2
c0
c1
c2
)
;
this
.
renderTriangle_pAsVec2
(
p2
p1
p3
c2
c1
c3
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
renderQuad_WithColor
=
function
(
p0
p1
p2
p3
color
)
{
this
.
renderQuad
(
p0
p1
p2
p3
color
color
color
color
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
renderLine
=
function
(
p0
p1
color
)
{
var
vertexPositions
=
[
p0
[
0
]
p0
[
1
]
0
.
0
1
.
0
p1
[
0
]
p1
[
1
]
0
.
0
1
.
0
]
;
var
vertexColors
=
[
color
[
0
]
color
[
1
]
color
[
2
]
color
[
3
]
color
[
0
]
color
[
1
]
color
[
2
]
color
[
3
]
]
;
var
posGLBuffer
=
gl
.
createBuffer
(
)
;
var
posBuffer
=
new
Float32Array
(
vertexPositions
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
posGLBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
posBuffer
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
this
.
m_attrPositionLoc
)
;
gl
.
vertexAttribPointer
(
this
.
m_attrPositionLoc
4
gl
.
FLOAT
false
0
0
)
;
var
colGLBuffer
=
gl
.
createBuffer
(
)
;
var
colBuffer
=
new
Float32Array
(
vertexColors
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
colGLBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
colBuffer
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
this
.
m_attrColorLoc
)
;
gl
.
vertexAttribPointer
(
this
.
m_attrColorLoc
4
gl
.
FLOAT
false
0
0
)
;
gl
.
useProgram
(
this
.
m_program
.
getProgram
(
)
)
;
gl
.
drawArrays
(
gl
.
LINES
0
2
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
null
)
;
gl
.
deleteBuffer
(
colGLBuffer
)
;
gl
.
deleteBuffer
(
posGLBuffer
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
randomizeViewport
=
function
(
)
{
this
.
m_viewportX
=
this
.
m_rnd
.
getInt
(
0
this
.
m_renderWidth
-
this
.
m_viewportSize
)
;
this
.
m_viewportY
=
this
.
m_rnd
.
getInt
(
0
this
.
m_renderHeight
-
this
.
m_viewportSize
)
;
gl
.
viewport
(
this
.
m_viewportX
this
.
m_viewportY
this
.
m_viewportSize
this
.
m_viewportSize
)
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
readImage
=
function
(
)
{
var
dst
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
var
pixelSize
=
dst
.
getAccess
(
)
.
getFormat
(
)
.
getPixelSize
(
)
;
var
param
=
deMath
.
deIsPowerOfTwo32
(
pixelSize
)
?
Math
.
min
(
pixelSize
8
)
:
1
;
var
format
=
gluTextureUtil
.
getTransferFormat
(
dst
.
getAccess
(
)
.
getFormat
(
)
)
;
var
width
=
dst
.
getAccess
(
)
.
getWidth
(
)
;
var
height
=
dst
.
getAccess
(
)
.
getHeight
(
)
;
if
(
this
.
m_fboParams
.
useFbo
)
{
gl
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
this
.
m_resolveFbo
)
;
gl
.
blitFramebuffer
(
0
0
this
.
m_renderWidth
this
.
m_renderHeight
0
0
this
.
m_renderWidth
this
.
m_renderHeight
gl
.
COLOR_BUFFER_BIT
gl
.
NEAREST
)
;
gl
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
this
.
m_resolveFbo
)
;
gl
.
pixelStorei
(
gl
.
PACK_ALIGNMENT
param
)
;
gl
.
readPixels
(
this
.
m_viewportX
this
.
m_viewportY
width
height
format
.
format
format
.
dataType
dst
.
getAccess
(
)
.
getDataPtr
(
)
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_msFbo
)
;
}
else
{
gl
.
pixelStorei
(
gl
.
PACK_ALIGNMENT
param
)
;
gl
.
readPixels
(
this
.
m_viewportX
this
.
m_viewportY
width
height
format
.
format
format
.
dataType
dst
.
getAccess
(
)
.
getDataPtr
(
)
)
;
}
return
dst
;
}
;
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
init
=
function
(
)
{
var
vertShaderSource
=
'
'
+
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
in
mediump
vec4
a_color
;
\
n
'
+
'
out
mediump
vec4
v_color
;
\
n
'
+
'
void
main
(
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
v_color
=
a_color
;
\
n
'
+
'
}
\
n
'
;
var
fragShaderSource
=
'
'
+
'
#
version
300
es
\
n
'
+
'
in
mediump
vec4
v_color
;
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
void
main
(
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
v_color
;
\
n
'
+
'
}
\
n
'
;
var
numSamples
=
(
gl
.
getParameter
(
gl
.
SAMPLES
)
)
;
if
(
!
this
.
m_fboParams
.
useFbo
&
&
numSamples
<
=
1
)
{
var
msg
=
'
No
multisample
buffers
'
;
testSkippedOptions
(
msg
true
)
;
return
false
;
}
if
(
this
.
m_fboParams
.
useFbo
)
{
if
(
this
.
m_fboParams
.
numSamples
>
0
)
this
.
m_numSamples
=
this
.
m_fboParams
.
numSamples
;
else
{
bufferedLogToConsole
(
'
Querying
maximum
number
of
samples
for
'
+
gluStrUtil
.
getPixelFormatName
(
gl
.
RGBA8
)
+
'
with
gl
.
getInternalformatParameter
(
)
'
)
;
this
.
m_numSamples
=
(
gl
.
getInternalformatParameter
(
gl
.
RENDERBUFFER
gl
.
RGBA8
gl
.
SAMPLES
)
.
length
)
;
}
bufferedLogToConsole
(
'
Using
FBO
of
size
(
'
+
this
.
m_renderWidth
+
'
'
+
this
.
m_renderHeight
+
'
)
with
'
+
this
.
m_numSamples
+
'
samples
'
)
;
}
else
{
this
.
m_numSamples
=
numSamples
;
bufferedLogToConsole
(
'
gl
.
SAMPLES
=
'
+
this
.
m_numSamples
)
;
}
assertMsgOptions
(
!
this
.
m_program
'
Program
loaded
when
it
should
not
be
.
'
false
true
)
;
this
.
m_program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vertShaderSource
fragShaderSource
)
)
;
if
(
!
this
.
m_program
.
isOk
(
)
)
throw
new
Error
(
'
Failed
to
compile
program
'
)
;
this
.
m_attrPositionLoc
=
gl
.
getAttribLocation
(
this
.
m_program
.
getProgram
(
)
'
a_position
'
)
;
this
.
m_attrColorLoc
=
gl
.
getAttribLocation
(
this
.
m_program
.
getProgram
(
)
'
a_color
'
)
;
if
(
this
.
m_attrPositionLoc
<
0
|
|
this
.
m_attrColorLoc
<
0
)
{
this
.
m_program
=
null
;
throw
new
Error
(
'
Invalid
attribute
locations
'
)
;
}
if
(
this
.
m_fboParams
.
useFbo
)
{
this
.
m_msColorRbo
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
this
.
m_msColorRbo
)
;
try
{
gl
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
this
.
m_numSamples
gl
.
RGBA8
this
.
m_renderWidth
this
.
m_renderHeight
)
;
}
catch
(
e
)
{
var
maxSampleCount
=
(
gl
.
getInternalformatParameter
(
gl
.
RENDERBUFFER
gl
.
RGBA8
gl
.
SAMPLES
)
)
;
if
(
maxSampleCount
.
length
<
this
.
m_numSamples
)
throw
new
Error
(
'
Maximum
sample
count
returned
by
gl
.
getInternalformatParameter
(
)
for
'
+
gluStrUtil
.
getPixelFormatName
(
gl
.
RGBA8
)
+
'
is
only
'
+
maxSampleCount
.
length
)
;
else
throw
new
Error
(
'
Unspecified
error
.
'
)
;
}
if
(
this
.
m_fboParams
.
useDepth
|
|
this
.
m_fboParams
.
useStencil
)
{
this
.
m_msDepthStencilRbo
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
this
.
m_msDepthStencilRbo
)
;
gl
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
this
.
m_numSamples
gl
.
DEPTH24_STENCIL8
this
.
m_renderWidth
this
.
m_renderHeight
)
;
}
this
.
m_msFbo
=
gl
.
createFramebuffer
(
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_msFbo
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
this
.
m_msColorRbo
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
DEPTH_STENCIL_ATTACHMENT
gl
.
RENDERBUFFER
this
.
m_msDepthStencilRbo
)
;
this
.
m_resolveColorRbo
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
this
.
m_resolveColorRbo
)
;
gl
.
renderbufferStorage
(
gl
.
RENDERBUFFER
gl
.
RGBA8
this
.
m_renderWidth
this
.
m_renderHeight
)
;
this
.
m_resolveFbo
=
gl
.
createFramebuffer
(
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_resolveFbo
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
this
.
m_resolveColorRbo
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_msFbo
)
;
}
this
.
m_viewportSize
=
Math
.
min
(
this
.
m_desiredViewportSize
this
.
m_renderWidth
this
.
m_renderHeight
)
;
this
.
randomizeViewport
(
)
;
}
;
es3fMultisampleTests
.
NumSamplesCase
=
function
(
name
desc
fboParams
)
{
es3fMultisampleTests
.
MultisampleCase
.
call
(
this
name
desc
256
fboParams
)
;
var
DEFAULT_MAX_NUM_ITERATIONS
=
16
;
this
.
m_currentIteration
=
0
;
this
.
m_maxNumIterations
=
es3fMultisampleTests
.
getIterationCount
(
DEFAULT_MAX_NUM_ITERATIONS
)
;
this
.
m_detectedColors
=
[
]
;
}
;
es3fMultisampleTests
.
NumSamplesCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
MultisampleCase
.
prototype
)
;
es3fMultisampleTests
.
NumSamplesCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
NumSamplesCase
;
es3fMultisampleTests
.
NumSamplesCase
.
prototype
.
iterate
=
function
(
)
{
var
renderedImg
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
this
.
randomizeViewport
(
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
this
.
renderPattern
(
)
;
renderedImg
=
this
.
readImage
(
)
;
tcuLogImage
.
logImage
(
'
RenderedImage
'
'
Rendered
image
'
renderedImg
.
getAccess
(
)
)
;
var
requiredNumDistinctColors
=
this
.
m_numSamples
+
1
;
for
(
var
y
=
0
;
y
<
renderedImg
.
getHeight
(
)
&
&
this
.
m_detectedColors
.
length
<
requiredNumDistinctColors
;
y
+
+
)
for
(
var
x
=
0
;
x
<
renderedImg
.
getWidth
(
)
&
&
this
.
m_detectedColors
.
length
<
requiredNumDistinctColors
;
x
+
+
)
{
var
color
=
new
tcuRGBA
.
RGBA
(
renderedImg
.
getPixel
(
x
y
)
)
;
var
i
;
for
(
i
=
0
;
i
<
this
.
m_detectedColors
.
length
;
i
+
+
)
{
if
(
tcuRGBA
.
compareThreshold
(
color
this
.
m_detectedColors
[
i
]
tcuRGBA
.
newRGBAComponents
(
3
3
3
3
)
)
)
break
;
}
if
(
i
=
=
=
this
.
m_detectedColors
.
length
)
this
.
m_detectedColors
.
push
(
color
)
;
}
bufferedLogToConsole
(
'
Number
of
distinct
colors
detected
so
far
:
'
+
(
this
.
m_detectedColors
.
length
>
=
requiredNumDistinctColors
?
'
at
least
'
:
'
'
)
+
this
.
m_detectedColors
.
length
)
;
if
(
this
.
m_detectedColors
.
length
<
requiredNumDistinctColors
)
{
this
.
m_currentIteration
+
+
;
if
(
this
.
m_currentIteration
>
=
this
.
m_maxNumIterations
)
{
testFailedOptions
(
'
Failure
:
Number
of
distinct
colors
detected
is
lower
than
sample
count
+
1
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
else
{
bufferedLogToConsole
(
'
The
number
of
distinct
colors
detected
is
lower
than
sample
count
+
1
-
trying
again
with
a
slightly
altered
pattern
'
)
;
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
}
}
else
{
testPassedOptions
(
'
Success
:
The
number
of
distinct
colors
detected
is
at
least
sample
count
+
1
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
}
;
es3fMultisampleTests
.
PolygonNumSamplesCase
=
function
(
name
desc
numFboSamples
)
{
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
false
false
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
NumSamplesCase
.
call
(
this
name
desc
params
)
;
}
;
es3fMultisampleTests
.
PolygonNumSamplesCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
NumSamplesCase
.
prototype
)
;
es3fMultisampleTests
.
PolygonNumSamplesCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
PolygonNumSamplesCase
;
es3fMultisampleTests
.
PolygonNumSamplesCase
.
prototype
.
renderPattern
=
function
(
)
{
var
numTriangles
=
25
;
for
(
var
i
=
0
;
i
<
numTriangles
;
i
+
+
)
{
var
angle0
=
2
.
0
*
Math
.
PI
*
i
/
numTriangles
+
0
.
001
*
this
.
m_currentIteration
;
var
angle1
=
2
.
0
*
Math
.
PI
*
(
i
+
0
.
5
)
/
numTriangles
+
0
.
001
*
this
.
m_currentIteration
;
this
.
renderTriangle_pAsVec2WithColor
(
[
0
.
0
0
.
0
]
[
Math
.
cos
(
angle0
)
*
0
.
95
Math
.
sin
(
angle0
)
*
0
.
95
]
[
Math
.
cos
(
angle1
)
*
0
.
95
Math
.
sin
(
angle1
)
*
0
.
95
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
}
}
;
es3fMultisampleTests
.
LineNumSamplesCase
=
function
(
name
desc
numFboSamples
)
{
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
false
false
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
NumSamplesCase
.
call
(
this
name
desc
params
)
;
}
;
es3fMultisampleTests
.
LineNumSamplesCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
NumSamplesCase
.
prototype
)
;
es3fMultisampleTests
.
LineNumSamplesCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
LineNumSamplesCase
;
es3fMultisampleTests
.
LineNumSamplesCase
.
prototype
.
renderPattern
=
function
(
)
{
var
numLines
=
Math
.
floor
(
100
.
0
*
Math
.
sqrt
(
this
.
m_viewportSize
/
256
.
0
)
)
;
for
(
var
i
=
0
;
i
<
numLines
;
i
+
+
)
{
var
angle
=
2
.
0
*
Math
.
PI
*
i
/
numLines
+
0
.
001
*
this
.
m_currentIteration
;
this
.
renderLine
(
[
0
.
0
0
.
0
]
[
Math
.
cos
(
angle
)
*
0
.
95
Math
.
sin
(
angle
)
*
0
.
95
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
}
}
;
es3fMultisampleTests
.
CommonEdgeCase
=
function
(
name
desc
caseType
numFboSamples
)
{
var
cases
=
caseType
=
=
=
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
SMALL_QUADS
?
128
:
32
;
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
false
false
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
MultisampleCase
.
call
(
this
name
desc
cases
params
)
;
var
DEFAULT_SMALL_QUADS_ITERATIONS
=
16
;
var
DEFAULT_BIGGER_THAN_VIEWPORT_QUAD_ITERATIONS
=
64
;
this
.
m_caseType
=
caseType
;
this
.
m_currentIteration
=
0
;
this
.
m_numIterations
=
caseType
=
=
=
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
SMALL_QUADS
?
es3fMultisampleTests
.
getIterationCount
(
DEFAULT_SMALL_QUADS_ITERATIONS
)
:
caseType
=
=
=
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
BIGGER_THAN_VIEWPORT_QUAD
?
es3fMultisampleTests
.
getIterationCount
(
DEFAULT_BIGGER_THAN_VIEWPORT_QUAD_ITERATIONS
)
:
8
;
}
;
es3fMultisampleTests
.
CommonEdgeCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
MultisampleCase
.
prototype
)
;
es3fMultisampleTests
.
CommonEdgeCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
CommonEdgeCase
;
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
=
{
SMALL_QUADS
:
0
BIGGER_THAN_VIEWPORT_QUAD
:
1
FIT_VIEWPORT_QUAD
:
2
}
;
es3fMultisampleTests
.
CommonEdgeCase
.
prototype
.
init
=
function
(
)
{
var
inited
=
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
init
.
call
(
this
)
;
if
(
!
inited
)
{
return
false
;
}
if
(
this
.
m_caseType
=
=
=
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
SMALL_QUADS
)
{
var
minViewportSize
=
32
;
if
(
this
.
m_viewportSize
<
minViewportSize
)
throw
new
Error
(
'
Render
target
width
or
height
too
low
(
is
'
+
this
.
m_viewportSize
+
'
should
be
at
least
'
+
minViewportSize
+
'
)
'
)
;
}
gl
.
enable
(
gl
.
BLEND
)
;
gl
.
blendEquation
(
gl
.
FUNC_ADD
)
;
gl
.
blendFunc
(
gl
.
ONE
gl
.
ONE
)
;
bufferedLogToConsole
(
'
Additive
blending
enabled
in
order
to
detect
(
erroneously
)
overlapping
samples
'
)
;
}
;
es3fMultisampleTests
.
CommonEdgeCase
.
prototype
.
iterate
=
function
(
)
{
var
renderedImg
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
var
errorImg
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
this
.
randomizeViewport
(
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
var
unicoloredRegions
=
[
]
;
var
corners
;
var
angleCos
;
var
angleSin
;
var
angle
;
var
quadDiagLen
;
var
unicolorRegionScale
;
var
quadBaseAngleNdx
var
quadSubAngleNdx
;
if
(
this
.
m_caseType
=
=
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
SMALL_QUADS
)
{
quadDiagLen
=
2
.
0
/
3
.
0
*
0
.
9
;
if
(
this
.
m_currentIteration
=
=
=
0
)
{
angleCos
=
1
.
0
;
angleSin
=
0
.
0
;
}
else
if
(
this
.
m_currentIteration
=
=
=
1
)
{
angleCos
=
Math
.
SQRT1_2
;
angleSin
=
Math
.
SQRT1_2
;
}
else
{
angle
=
0
.
5
*
Math
.
PI
*
(
this
.
m_currentIteration
-
1
)
/
(
this
.
m_numIterations
-
1
)
;
angleCos
=
Math
.
cos
(
angle
)
;
angleSin
=
Math
.
sin
(
angle
)
;
}
corners
=
[
deMath
.
scale
(
[
angleCos
angleSin
]
0
.
5
*
quadDiagLen
)
deMath
.
scale
(
[
-
angleSin
angleCos
]
0
.
5
*
quadDiagLen
)
deMath
.
scale
(
[
-
angleCos
-
angleSin
]
0
.
5
*
quadDiagLen
)
deMath
.
scale
(
[
angleSin
-
angleCos
]
0
.
5
*
quadDiagLen
)
]
;
for
(
var
quadNdx
=
0
;
quadNdx
<
8
;
quadNdx
+
+
)
{
var
center
=
deMath
.
addScalar
(
deMath
.
scale
(
[
quadNdx
%
3
quadNdx
/
3
]
(
2
.
0
-
quadDiagLen
)
/
2
.
0
)
(
-
0
.
5
*
(
2
.
0
-
quadDiagLen
)
)
)
;
this
.
renderTriangle_pAsVec2WithColor
(
deMath
.
add
(
corners
[
(
0
+
quadNdx
)
%
4
]
center
)
deMath
.
add
(
corners
[
(
1
+
quadNdx
)
%
4
]
center
)
deMath
.
add
(
corners
[
(
2
+
quadNdx
)
%
4
]
center
)
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
if
(
quadNdx
>
=
4
)
{
this
.
renderTriangle_pAsVec2WithColor
(
deMath
.
add
(
corners
[
(
3
+
quadNdx
)
%
4
]
center
)
deMath
.
add
(
corners
[
(
2
+
quadNdx
)
%
4
]
center
)
deMath
.
add
(
corners
[
(
0
+
quadNdx
)
%
4
]
center
)
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
}
else
{
this
.
renderTriangle_pAsVec2WithColor
(
deMath
.
add
(
corners
[
(
0
+
quadNdx
)
%
4
]
center
)
deMath
.
add
(
corners
[
(
2
+
quadNdx
)
%
4
]
center
)
deMath
.
add
(
corners
[
(
3
+
quadNdx
)
%
4
]
center
)
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
}
unicolorRegionScale
=
1
.
0
-
6
.
0
*
2
.
0
/
this
.
m_viewportSize
/
quadDiagLen
;
unicoloredRegions
.
push
(
new
es3fMultisampleTests
.
QuadCorners
(
deMath
.
add
(
center
deMath
.
scale
(
corners
[
0
]
unicolorRegionScale
)
)
deMath
.
add
(
center
deMath
.
scale
(
corners
[
1
]
unicolorRegionScale
)
)
deMath
.
add
(
center
deMath
.
scale
(
corners
[
2
]
unicolorRegionScale
)
)
deMath
.
add
(
center
deMath
.
scale
(
corners
[
3
]
unicolorRegionScale
)
)
)
)
;
}
}
else
if
(
this
.
m_caseType
=
=
=
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
BIGGER_THAN_VIEWPORT_QUAD
)
{
quadBaseAngleNdx
=
Math
.
floor
(
this
.
m_currentIteration
/
8
)
;
quadSubAngleNdx
=
this
.
m_currentIteration
%
8
;
if
(
quadBaseAngleNdx
=
=
=
0
)
{
angleCos
=
1
.
0
;
angleSin
=
0
.
0
;
}
else
if
(
quadBaseAngleNdx
=
=
=
1
)
{
angleCos
=
Math
.
SQRT1_2
;
angleSin
=
Math
.
SQRT1_2
;
}
else
{
angle
=
0
.
5
*
Math
.
PI
*
(
this
.
m_currentIteration
-
1
)
/
(
this
.
m_numIterations
-
1
)
;
angleCos
=
Math
.
cos
(
angle
)
;
angleSin
=
Math
.
sin
(
angle
)
;
}
quadDiagLen
=
2
.
5
/
Math
.
max
(
angleCos
angleSin
)
;
corners
=
[
deMath
.
scale
(
[
angleCos
angleSin
]
0
.
5
*
quadDiagLen
)
deMath
.
scale
(
[
-
angleSin
angleCos
]
0
.
5
*
quadDiagLen
)
deMath
.
scale
(
[
-
angleCos
-
angleSin
]
0
.
5
*
quadDiagLen
)
deMath
.
scale
(
[
angleSin
-
angleCos
]
0
.
5
*
quadDiagLen
)
]
;
this
.
renderTriangle_pAsVec2WithColor
(
corners
[
(
0
+
quadSubAngleNdx
)
%
4
]
corners
[
(
1
+
quadSubAngleNdx
)
%
4
]
corners
[
(
2
+
quadSubAngleNdx
)
%
4
]
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
if
(
quadSubAngleNdx
>
=
4
)
{
this
.
renderTriangle_pAsVec2WithColor
(
corners
[
(
3
+
quadSubAngleNdx
)
%
4
]
corners
[
(
2
+
quadSubAngleNdx
)
%
4
]
corners
[
(
0
+
quadSubAngleNdx
)
%
4
]
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
}
else
{
this
.
renderTriangle_pAsVec2WithColor
(
corners
[
(
0
+
quadSubAngleNdx
)
%
4
]
corners
[
(
2
+
quadSubAngleNdx
)
%
4
]
corners
[
(
3
+
quadSubAngleNdx
)
%
4
]
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
}
unicolorRegionScale
=
1
.
0
-
6
.
0
*
2
.
0
/
this
.
m_viewportSize
/
quadDiagLen
;
unicoloredRegions
.
push
(
new
es3fMultisampleTests
.
QuadCorners
(
deMath
.
scale
(
corners
[
0
]
unicolorRegionScale
)
deMath
.
scale
(
corners
[
1
]
unicolorRegionScale
)
deMath
.
scale
(
corners
[
2
]
unicolorRegionScale
)
deMath
.
scale
(
corners
[
3
]
unicolorRegionScale
)
)
)
;
}
else
if
(
this
.
m_caseType
=
=
=
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
FIT_VIEWPORT_QUAD
)
{
quadSubAngleNdx
=
this
.
m_currentIteration
%
8
;
corners
=
[
[
1
.
0
1
.
0
]
[
-
1
.
0
1
.
0
]
[
-
1
.
0
-
1
.
0
]
[
1
.
0
-
1
.
0
]
]
;
this
.
renderTriangle_pAsVec2WithColor
(
corners
[
(
0
+
quadSubAngleNdx
)
%
4
]
corners
[
(
1
+
quadSubAngleNdx
)
%
4
]
corners
[
(
2
+
quadSubAngleNdx
)
%
4
]
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
if
(
quadSubAngleNdx
>
=
4
)
{
this
.
renderTriangle_pAsVec2WithColor
(
corners
[
(
3
+
quadSubAngleNdx
)
%
4
]
corners
[
(
2
+
quadSubAngleNdx
)
%
4
]
corners
[
(
0
+
quadSubAngleNdx
)
%
4
]
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
}
else
{
this
.
renderTriangle_pAsVec2WithColor
(
corners
[
(
0
+
quadSubAngleNdx
)
%
4
]
corners
[
(
2
+
quadSubAngleNdx
)
%
4
]
corners
[
(
3
+
quadSubAngleNdx
)
%
4
]
[
0
.
5
0
.
5
0
.
5
1
.
0
]
)
;
}
unicoloredRegions
.
push
(
new
es3fMultisampleTests
.
QuadCorners
(
corners
[
0
]
corners
[
1
]
corners
[
2
]
corners
[
3
]
)
)
;
}
else
throw
new
Error
(
'
CaseType
not
supported
.
'
)
;
renderedImg
=
this
.
readImage
(
)
;
errorImg
.
getAccess
(
)
.
clear
(
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
tcuLogImage
.
logImage
(
'
RenderedImage
'
'
Rendered
image
'
renderedImg
.
getAccess
(
)
)
;
var
errorsDetected
=
false
;
for
(
var
i
=
0
;
i
<
unicoloredRegions
.
length
;
i
+
+
)
{
var
region
=
unicoloredRegions
[
i
]
;
var
p0Win
=
deMath
.
scale
(
deMath
.
addScalar
(
region
.
p0
1
.
0
)
0
.
5
*
(
this
.
m_viewportSize
-
1
)
+
0
.
5
)
;
var
p1Win
=
deMath
.
scale
(
deMath
.
addScalar
(
region
.
p1
1
.
0
)
0
.
5
*
(
this
.
m_viewportSize
-
1
)
+
0
.
5
)
;
var
p2Win
=
deMath
.
scale
(
deMath
.
addScalar
(
region
.
p2
1
.
0
)
0
.
5
*
(
this
.
m_viewportSize
-
1
)
+
0
.
5
)
;
var
p3Win
=
deMath
.
scale
(
deMath
.
addScalar
(
region
.
p3
1
.
0
)
0
.
5
*
(
this
.
m_viewportSize
-
1
)
+
0
.
5
)
;
var
errorsInCurrentRegion
=
!
es3fMultisampleTests
.
isPixelRegionUnicolored
(
renderedImg
p0Win
p1Win
p2Win
p3Win
)
;
if
(
errorsInCurrentRegion
)
es3fMultisampleTests
.
drawUnicolorTestErrors
(
renderedImg
errorImg
.
getAccess
(
)
p0Win
p1Win
p2Win
p3Win
)
;
errorsDetected
=
errorsDetected
|
|
errorsInCurrentRegion
;
}
this
.
m_currentIteration
+
+
;
if
(
errorsDetected
)
{
bufferedLogToConsole
(
'
Failure
:
Not
all
quad
interiors
seem
unicolored
-
common
-
edge
artifacts
?
'
)
;
bufferedLogToConsole
(
'
Erroneous
pixels
are
drawn
red
in
the
following
image
'
)
;
tcuLogImage
.
logImage
(
'
RenderedImageWithErrors
'
'
Rendered
image
with
errors
marked
'
renderedImg
.
getAccess
(
)
)
;
tcuLogImage
.
logImage
(
'
ErrorsOnly
'
'
Image
with
error
pixels
only
'
errorImg
.
getAccess
(
)
)
;
testFailedOptions
(
'
Failed
:
iteration
'
+
(
this
.
m_currentIteration
-
1
)
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
else
if
(
this
.
m_currentIteration
<
this
.
m_numIterations
)
{
bufferedLogToConsole
(
'
Quads
seem
OK
-
moving
on
to
next
pattern
'
)
;
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
}
else
{
bufferedLogToConsole
(
'
Success
:
All
quad
interiors
seem
unicolored
(
no
common
-
edge
artifacts
)
'
)
;
testPassedOptions
(
'
Passed
:
iteration
'
+
(
this
.
m_currentIteration
-
1
)
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
}
;
es3fMultisampleTests
.
SampleDepthCase
=
function
(
name
desc
numFboSamples
)
{
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
true
false
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
NumSamplesCase
.
call
(
this
name
desc
params
)
;
}
;
es3fMultisampleTests
.
SampleDepthCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
NumSamplesCase
.
prototype
)
;
es3fMultisampleTests
.
SampleDepthCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
SampleDepthCase
;
es3fMultisampleTests
.
SampleDepthCase
.
prototype
.
init
=
function
(
)
{
var
inited
=
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
init
.
call
(
this
)
;
if
(
!
inited
)
{
return
false
;
}
gl
.
enable
(
gl
.
DEPTH_TEST
)
;
gl
.
depthFunc
(
gl
.
LESS
)
;
bufferedLogToConsole
(
'
Depth
test
enabled
depth
func
is
gl
.
LESS
'
)
;
bufferedLogToConsole
(
'
Drawing
several
bigger
-
than
-
viewport
black
or
white
polygons
intersecting
each
other
'
)
;
}
;
es3fMultisampleTests
.
SampleDepthCase
.
prototype
.
renderPattern
=
function
(
)
{
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
gl
.
clearDepth
(
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
)
;
var
numPolygons
=
50
;
for
(
var
i
=
0
;
i
<
numPolygons
;
i
+
+
)
{
var
color
=
i
%
2
=
=
0
?
[
1
.
0
1
.
0
1
.
0
1
.
0
]
:
[
0
.
0
0
.
0
0
.
0
1
.
0
]
;
var
angle
=
2
.
0
*
Math
.
PI
*
i
/
numPolygons
+
0
.
001
*
this
.
m_currentIteration
;
var
pt0
=
[
3
.
0
*
Math
.
cos
(
angle
+
2
.
0
*
Math
.
PI
*
0
.
0
/
3
.
0
)
3
.
0
*
Math
.
sin
(
angle
+
2
.
0
*
Math
.
PI
*
0
.
0
/
3
.
0
)
1
.
0
]
;
var
pt1
=
[
3
.
0
*
Math
.
cos
(
angle
+
2
.
0
*
Math
.
PI
*
1
.
0
/
3
.
0
)
3
.
0
*
Math
.
sin
(
angle
+
2
.
0
*
Math
.
PI
*
1
.
0
/
3
.
0
)
0
.
0
]
;
var
pt2
=
[
3
.
0
*
Math
.
cos
(
angle
+
2
.
0
*
Math
.
PI
*
2
.
0
/
3
.
0
)
3
.
0
*
Math
.
sin
(
angle
+
2
.
0
*
Math
.
PI
*
2
.
0
/
3
.
0
)
0
.
0
]
;
this
.
renderTriangle_pAsVec3WithColor
(
pt0
pt1
pt2
color
)
;
}
}
;
es3fMultisampleTests
.
SampleStencilCase
=
function
(
name
desc
numFboSamples
)
{
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
false
true
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
MultisampleCase
.
call
(
this
name
desc
256
params
)
;
}
;
es3fMultisampleTests
.
SampleStencilCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
MultisampleCase
.
prototype
)
;
es3fMultisampleTests
.
SampleStencilCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
SampleStencilCase
;
es3fMultisampleTests
.
SampleStencilCase
.
prototype
.
iterate
=
function
(
)
{
var
renderedImgFirst
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
var
renderedImgSecond
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
this
.
randomizeViewport
(
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
gl
.
clearStencil
(
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
gl
.
enable
(
gl
.
STENCIL_TEST
)
;
gl
.
stencilFunc
(
gl
.
ALWAYS
1
1
)
;
gl
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
REPLACE
)
;
bufferedLogToConsole
(
'
Drawing
a
pattern
with
gl
.
stencilFunc
(
gl
.
ALWAYS
1
1
)
and
gl
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
REPLACE
)
'
)
;
var
numTriangles
=
25
;
for
(
var
i
=
0
;
i
<
numTriangles
;
i
+
+
)
{
var
angle0
=
2
.
0
*
Math
.
PI
*
i
/
numTriangles
;
var
angle1
=
2
.
0
*
Math
.
PI
*
(
i
+
0
.
5
)
/
numTriangles
;
this
.
renderTriangle_pAsVec2WithColor
(
[
0
.
0
0
.
0
]
[
Math
.
cos
(
angle0
)
*
0
.
95
Math
.
sin
(
angle0
)
*
0
.
95
]
[
Math
.
cos
(
angle1
)
*
0
.
95
Math
.
sin
(
angle1
)
*
0
.
95
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
}
renderedImgFirst
=
this
.
readImage
(
)
;
tcuLogImage
.
logImage
(
'
RenderedImgFirst
'
'
First
image
rendered
'
renderedImgFirst
.
getAccess
(
)
)
;
bufferedLogToConsole
(
'
Clearing
color
buffer
to
black
'
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
gl
.
stencilFunc
(
gl
.
EQUAL
1
1
)
;
gl
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
KEEP
)
;
bufferedLogToConsole
(
'
Checking
that
color
buffer
was
actually
cleared
to
black
'
)
;
var
clearedImg
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
clearedImg
=
this
.
readImage
(
)
;
for
(
var
y
=
0
;
y
<
clearedImg
.
getHeight
(
)
;
y
+
+
)
for
(
var
x
=
0
;
x
<
clearedImg
.
getWidth
(
)
;
x
+
+
)
{
var
clr
=
new
tcuRGBA
.
RGBA
(
clearedImg
.
getPixel
(
x
y
)
)
;
if
(
!
clr
.
equals
(
tcuRGBA
.
RGBA
.
black
)
)
{
bufferedLogToConsole
(
'
Failure
:
first
non
-
black
pixel
color
'
+
clr
.
toString
(
)
+
'
detected
at
coordinates
(
'
+
x
+
'
'
+
y
+
'
)
'
)
;
tcuLogImage
.
logImage
(
'
ClearedImg
'
'
Image
after
clearing
erroneously
non
-
black
'
clearedImg
.
getAccess
(
)
)
;
testFailedOptions
(
'
Failed
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
}
bufferedLogToConsole
(
'
Drawing
a
viewport
-
sized
quad
with
gl
.
stencilFunc
(
gl
.
EQUAL
1
1
)
and
gl
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
KEEP
)
-
should
result
in
same
image
as
the
first
'
)
;
this
.
renderQuad_WithColor
(
[
-
1
.
0
-
1
.
0
]
[
1
.
0
-
1
.
0
]
[
-
1
.
0
1
.
0
]
[
1
.
0
1
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
renderedImgSecond
=
this
.
readImage
(
)
;
tcuLogImage
.
logImage
(
'
RenderedImgSecond
'
'
Second
image
rendered
'
renderedImgSecond
.
getAccess
(
)
)
;
var
passed
=
tcuImageCompare
.
pixelThresholdCompare
(
'
ImageCompare
'
'
Image
comparison
'
renderedImgFirst
renderedImgSecond
[
0
0
0
0
]
)
;
if
(
passed
)
{
bufferedLogToConsole
(
'
Success
:
The
two
images
rendered
are
identical
'
)
;
testPassedOptions
(
'
Passed
'
true
)
;
}
else
testFailedOptions
(
'
Failed
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fMultisampleTests
.
MaskProportionalityCase
=
function
(
name
desc
type
numFboSamples
)
{
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
false
false
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
MultisampleCase
.
call
(
this
name
desc
32
params
)
;
this
.
m_type
=
type
;
this
.
m_numIterations
;
this
.
m_currentIteration
=
0
;
this
.
m_previousIterationColorSum
=
-
1
;
}
;
es3fMultisampleTests
.
MaskProportionalityCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
MultisampleCase
.
prototype
)
;
es3fMultisampleTests
.
MaskProportionalityCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
MaskProportionalityCase
;
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
=
{
ALPHA_TO_COVERAGE
:
0
SAMPLE_COVERAGE
:
1
SAMPLE_COVERAGE_INVERTED
:
2
}
;
es3fMultisampleTests
.
MaskProportionalityCase
.
prototype
.
init
=
function
(
)
{
var
inited
=
es3fMultisampleTests
.
MultisampleCase
.
prototype
.
init
.
call
(
this
)
;
if
(
!
inited
)
{
return
false
;
}
if
(
this
.
m_type
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
ALPHA_TO_COVERAGE
)
{
gl
.
enable
(
gl
.
SAMPLE_ALPHA_TO_COVERAGE
)
;
bufferedLogToConsole
(
'
gl
.
SAMPLE_ALPHA_TO_COVERAGE
is
enabled
'
)
;
}
else
{
assertMsgOptions
(
this
.
m_type
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE
|
|
this
.
m_type
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE_INVERTED
'
CaseType
should
be
SAMPLE_COVERAGE
or
SAMPLE_COVERAGE_INVERTED
'
false
true
)
;
gl
.
enable
(
gl
.
SAMPLE_COVERAGE
)
;
bufferedLogToConsole
(
'
gl
.
SAMPLE_COVERAGE
is
enabled
'
)
;
}
this
.
m_numIterations
=
Math
.
max
(
2
es3fMultisampleTests
.
getIterationCount
(
this
.
m_numSamples
*
5
)
)
;
this
.
randomizeViewport
(
)
;
}
;
es3fMultisampleTests
.
MaskProportionalityCase
.
prototype
.
iterate
=
function
(
)
{
var
renderedImg
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
var
numPixels
=
renderedImg
.
getWidth
(
)
*
renderedImg
.
getHeight
(
)
;
bufferedLogToConsole
(
'
Clearing
color
to
black
'
)
;
gl
.
colorMask
(
true
true
true
true
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
if
(
this
.
m_type
=
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
ALPHA_TO_COVERAGE
)
{
gl
.
colorMask
(
true
true
true
false
)
;
bufferedLogToConsole
(
'
Using
color
mask
TRUE
TRUE
TRUE
FALSE
'
)
;
}
var
pt0
=
[
-
1
.
0
-
1
.
0
]
;
var
pt1
=
[
1
.
0
-
1
.
0
]
;
var
pt2
=
[
-
1
.
0
1
.
0
]
;
var
pt3
=
[
1
.
0
1
.
0
]
;
var
quadColor
=
[
1
.
0
0
.
0
0
.
0
1
.
0
]
;
var
alphaOrCoverageValue
=
this
.
m_currentIteration
/
(
this
.
m_numIterations
-
1
)
;
if
(
this
.
m_type
=
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
ALPHA_TO_COVERAGE
)
{
bufferedLogToConsole
(
'
Drawing
a
red
quad
using
alpha
value
'
+
alphaOrCoverageValue
)
;
quadColor
[
3
]
=
alphaOrCoverageValue
;
}
else
{
assertMsgOptions
(
this
.
m_type
=
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE
|
|
this
.
m_type
=
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE_INVERTED
'
CaseType
should
be
SAMPLE_COVERAGE
or
SAMPLE_COVERAGE_INVERTED
'
false
true
)
;
var
isInverted
=
(
this
.
m_type
=
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE_INVERTED
)
;
var
coverageValue
=
isInverted
?
1
.
0
-
alphaOrCoverageValue
:
alphaOrCoverageValue
;
bufferedLogToConsole
(
'
Drawing
a
red
quad
using
sample
coverage
value
'
+
coverageValue
+
(
isInverted
?
'
(
inverted
)
'
:
'
'
)
)
;
gl
.
sampleCoverage
(
coverageValue
isInverted
?
true
:
false
)
;
}
this
.
renderQuad_WithColor
(
pt0
pt1
pt2
pt3
quadColor
)
;
renderedImg
=
this
.
readImage
(
)
;
tcuLogImage
.
logImage
(
'
RenderedImage
'
'
Rendered
image
'
renderedImg
.
getAccess
(
)
)
;
var
sumRed
=
0
;
for
(
var
y
=
0
;
y
<
renderedImg
.
getHeight
(
)
;
y
+
+
)
for
(
var
x
=
0
;
x
<
renderedImg
.
getWidth
(
)
;
x
+
+
)
sumRed
+
=
new
tcuRGBA
.
RGBA
(
renderedImg
.
getPixel
(
x
y
)
)
.
getRed
(
)
;
bufferedLogToConsole
(
'
Average
red
color
component
:
'
+
(
sumRed
/
255
.
0
/
numPixels
)
)
;
if
(
sumRed
<
this
.
m_previousIterationColorSum
)
{
bufferedLogToConsole
(
'
Failure
:
Current
average
red
color
component
is
lower
than
previous
'
)
;
testFailedOptions
(
'
Failed
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
if
(
this
.
m_currentIteration
=
=
0
&
&
sumRed
!
=
0
)
{
bufferedLogToConsole
(
'
Failure
:
Image
should
be
completely
black
'
)
;
testFailedOptions
(
'
Failed
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
if
(
this
.
m_currentIteration
=
=
this
.
m_numIterations
-
1
&
&
sumRed
!
=
0xff
*
numPixels
)
{
bufferedLogToConsole
(
'
Failure
:
Image
should
be
completely
red
'
)
;
testFailedOptions
(
'
Failed
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
this
.
m_previousIterationColorSum
=
sumRed
;
this
.
m_currentIteration
+
+
;
if
(
this
.
m_currentIteration
>
=
this
.
m_numIterations
)
{
bufferedLogToConsole
(
'
Success
:
Number
of
coverage
mask
bits
set
appears
to
be
on
average
proportional
to
'
+
(
this
.
m_type
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
ALPHA_TO_COVERAGE
?
'
alpha
'
:
this
.
m_type
=
=
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE
?
'
sample
coverage
value
'
:
'
inverted
sample
coverage
value
'
)
)
;
testPassedOptions
(
'
Passed
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
else
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
}
;
es3fMultisampleTests
.
MaskConstancyCase
=
function
(
name
desc
type
numFboSamples
)
{
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
false
false
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
MultisampleCase
.
call
(
this
name
desc
256
params
)
;
var
CaseType
=
es3fMultisampleTests
.
MaskConstancyCase
.
CaseType
;
this
.
m_isAlphaToCoverageCase
=
(
type
=
=
=
CaseType
.
ALPHA_TO_COVERAGE
|
|
type
=
=
=
CaseType
.
BOTH
|
|
type
=
=
=
CaseType
.
BOTH_INVERTED
)
;
this
.
m_isSampleCoverageCase
=
(
type
=
=
=
CaseType
.
SAMPLE_COVERAGE
|
|
type
=
=
=
CaseType
.
SAMPLE_COVERAGE_INVERTED
|
|
type
=
=
=
CaseType
.
BOTH
|
|
type
=
=
=
CaseType
.
BOTH_INVERTED
)
;
this
.
m_isInvertedSampleCoverageCase
=
(
type
=
=
=
CaseType
.
SAMPLE_COVERAGE_INVERTED
|
|
type
=
=
=
CaseType
.
BOTH_INVERTED
)
;
}
;
es3fMultisampleTests
.
MaskConstancyCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
MultisampleCase
.
prototype
)
;
es3fMultisampleTests
.
MaskConstancyCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
MaskConstancyCase
;
es3fMultisampleTests
.
MaskConstancyCase
.
CaseType
=
{
ALPHA_TO_COVERAGE
:
0
SAMPLE_COVERAGE
:
1
SAMPLE_COVERAGE_INVERTED
:
2
BOTH
:
3
BOTH_INVERTED
:
4
}
;
es3fMultisampleTests
.
MaskConstancyCase
.
prototype
.
iterate
=
function
(
)
{
var
renderedImg
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
this
.
randomizeViewport
(
)
;
bufferedLogToConsole
(
'
Clearing
color
to
black
'
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
if
(
this
.
m_isAlphaToCoverageCase
)
{
gl
.
enable
(
gl
.
SAMPLE_ALPHA_TO_COVERAGE
)
;
gl
.
colorMask
(
true
true
true
false
)
;
bufferedLogToConsole
(
'
gl
.
SAMPLE_ALPHA_TO_COVERAGE
is
enabled
'
)
;
bufferedLogToConsole
(
'
Color
mask
is
TRUE
TRUE
TRUE
FALSE
'
)
;
}
if
(
this
.
m_isSampleCoverageCase
)
{
gl
.
enable
(
gl
.
SAMPLE_COVERAGE
)
;
bufferedLogToConsole
(
'
gl
.
SAMPLE_COVERAGE
is
enabled
'
)
;
}
bufferedLogToConsole
(
'
Drawing
several
green
quads
each
fully
overlapped
by
a
red
quad
with
the
same
'
+
(
this
.
m_isAlphaToCoverageCase
?
'
alpha
'
:
'
'
)
+
(
this
.
m_isAlphaToCoverageCase
&
&
this
.
m_isSampleCoverageCase
?
'
and
'
:
'
'
)
+
(
this
.
m_isInvertedSampleCoverageCase
?
'
inverted
'
:
'
'
)
+
(
this
.
m_isSampleCoverageCase
?
'
sample
coverage
'
:
'
'
)
+
'
values
'
)
;
var
numQuadRowsCols
=
this
.
m_numSamples
*
4
;
for
(
var
row
=
0
;
row
<
numQuadRowsCols
;
row
+
+
)
{
for
(
var
col
=
0
;
col
<
numQuadRowsCols
;
col
+
+
)
{
var
x0
=
(
col
+
0
)
/
numQuadRowsCols
*
2
.
0
-
1
.
0
;
var
x1
=
(
col
+
1
)
/
numQuadRowsCols
*
2
.
0
-
1
.
0
;
var
y0
=
(
row
+
0
)
/
numQuadRowsCols
*
2
.
0
-
1
.
0
;
var
y1
=
(
row
+
1
)
/
numQuadRowsCols
*
2
.
0
-
1
.
0
;
var
baseGreen
=
[
0
.
0
1
.
0
0
.
0
0
.
0
]
;
var
baseRed
=
[
1
.
0
0
.
0
0
.
0
0
.
0
]
;
var
alpha0
=
[
0
.
0
0
.
0
0
.
0
this
.
m_isAlphaToCoverageCase
?
col
/
(
numQuadRowsCols
-
1
)
:
1
.
0
]
;
var
alpha1
=
[
0
.
0
0
.
0
0
.
0
this
.
m_isAlphaToCoverageCase
?
row
/
(
numQuadRowsCols
-
1
)
:
1
.
0
]
;
if
(
this
.
m_isSampleCoverageCase
)
{
var
value
=
(
row
*
numQuadRowsCols
+
col
)
/
(
numQuadRowsCols
*
numQuadRowsCols
-
1
)
;
gl
.
sampleCoverage
(
this
.
m_isInvertedSampleCoverageCase
?
1
.
0
-
value
:
value
this
.
m_isInvertedSampleCoverageCase
?
true
:
false
)
;
}
this
.
renderQuad
(
[
x0
y0
]
[
x1
y0
]
[
x0
y1
]
[
x1
y1
]
deMath
.
add
(
baseGreen
alpha0
)
deMath
.
add
(
baseGreen
alpha1
)
deMath
.
add
(
baseGreen
alpha0
)
deMath
.
add
(
baseGreen
alpha1
)
)
;
this
.
renderQuad
(
[
x0
y0
]
[
x1
y0
]
[
x0
y1
]
[
x1
y1
]
deMath
.
add
(
baseRed
alpha0
)
deMath
.
add
(
baseRed
alpha1
)
deMath
.
add
(
baseRed
alpha0
)
deMath
.
add
(
baseRed
alpha1
)
)
;
}
}
renderedImg
=
this
.
readImage
(
)
;
tcuLogImage
.
logImage
(
'
RenderedImage
'
'
Rendered
image
'
renderedImg
.
getAccess
(
)
)
;
for
(
var
y
=
0
;
y
<
renderedImg
.
getHeight
(
)
;
y
+
+
)
for
(
var
x
=
0
;
x
<
renderedImg
.
getWidth
(
)
;
x
+
+
)
{
if
(
new
tcuRGBA
.
RGBA
(
renderedImg
.
getPixel
(
x
y
)
)
.
getGreen
(
)
>
0
)
{
bufferedLogToConsole
(
'
Failure
:
Non
-
zero
green
color
component
detected
-
should
have
been
completely
overwritten
by
red
quad
'
)
;
testFailedOptions
(
'
Failed
'
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
}
bufferedLogToConsole
(
'
Success
:
Coverage
mask
appears
to
be
constant
at
a
given
pixel
coordinate
with
a
given
'
+
(
this
.
m_isAlphaToCoverageCase
?
'
alpha
'
:
'
'
)
+
(
this
.
m_isAlphaToCoverageCase
&
&
this
.
m_isSampleCoverageCase
?
'
and
'
:
'
'
)
+
(
this
.
m_isSampleCoverageCase
?
'
coverage
value
'
:
'
'
)
)
;
testPassedOptions
(
'
Passed
'
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
es3fMultisampleTests
.
CoverageMaskInvertCase
=
function
(
name
desc
numFboSamples
)
{
numFboSamples
=
numFboSamples
=
=
=
undefined
?
0
:
numFboSamples
;
var
params
=
numFboSamples
>
=
0
?
new
es3fMultisampleTests
.
FboParams
(
numFboSamples
false
false
)
:
new
es3fMultisampleTests
.
FboParams
(
)
;
es3fMultisampleTests
.
MultisampleCase
.
call
(
this
name
desc
256
params
)
;
}
;
es3fMultisampleTests
.
CoverageMaskInvertCase
.
prototype
=
Object
.
create
(
es3fMultisampleTests
.
MultisampleCase
.
prototype
)
;
es3fMultisampleTests
.
CoverageMaskInvertCase
.
prototype
.
constructor
=
es3fMultisampleTests
.
CoverageMaskInvertCase
;
es3fMultisampleTests
.
CoverageMaskInvertCase
.
prototype
.
drawPattern
=
function
(
invertSampleCoverage
)
{
var
numTriangles
=
25
;
for
(
var
i
=
0
;
i
<
numTriangles
;
i
+
+
)
{
gl
.
sampleCoverage
(
i
/
(
numTriangles
-
1
)
invertSampleCoverage
?
true
:
false
)
;
var
angle0
=
2
.
0
*
Math
.
PI
*
i
/
numTriangles
;
var
angle1
=
2
.
0
*
Math
.
PI
*
(
i
+
0
.
5
)
/
numTriangles
;
this
.
renderTriangle_pAsVec2WithColor
(
[
0
.
0
0
.
0
]
[
Math
.
cos
(
angle0
)
*
0
.
95
Math
.
sin
(
angle0
)
*
0
.
95
]
[
Math
.
cos
(
angle1
)
*
0
.
95
Math
.
sin
(
angle1
)
*
0
.
95
]
[
0
.
4
+
i
/
numTriangles
*
0
.
6
0
.
5
+
i
/
numTriangles
*
0
.
3
0
.
6
-
i
/
numTriangles
*
0
.
5
0
.
7
-
i
/
numTriangles
*
0
.
7
]
)
;
}
}
;
es3fMultisampleTests
.
CoverageMaskInvertCase
.
prototype
.
iterate
=
function
(
)
{
var
renderedImgNoSampleCoverage
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
var
renderedImgSampleCoverage
=
new
tcuSurface
.
Surface
(
this
.
m_viewportSize
this
.
m_viewportSize
)
;
this
.
randomizeViewport
(
)
;
gl
.
enable
(
gl
.
BLEND
)
;
gl
.
blendEquation
(
gl
.
FUNC_ADD
)
;
gl
.
blendFunc
(
gl
.
ONE
gl
.
ONE
)
;
bufferedLogToConsole
(
'
Additive
blending
enabled
in
order
to
detect
(
erroneously
)
overlapping
samples
'
)
;
bufferedLogToConsole
(
'
Clearing
color
to
all
-
zeros
'
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
bufferedLogToConsole
(
'
Drawing
the
pattern
with
gl
.
SAMPLE_COVERAGE
disabled
'
)
;
this
.
drawPattern
(
false
)
;
renderedImgNoSampleCoverage
=
this
.
readImage
(
)
;
tcuLogImage
.
logImage
(
'
RenderedImageNoSampleCoverage
'
'
Rendered
image
with
gl
.
SAMPLE_COVERAGE
disabled
'
renderedImgNoSampleCoverage
.
getAccess
(
)
)
;
bufferedLogToConsole
(
'
Clearing
color
to
all
-
zeros
'
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
gl
.
enable
(
gl
.
SAMPLE_COVERAGE
)
;
bufferedLogToConsole
(
'
Drawing
the
pattern
with
gl
.
SAMPLE_COVERAGE
enabled
using
non
-
inverted
masks
'
)
;
this
.
drawPattern
(
false
)
;
bufferedLogToConsole
(
'
Drawing
the
pattern
with
gl
.
SAMPLE_COVERAGE
enabled
using
same
sample
coverage
values
but
inverted
masks
'
)
;
this
.
drawPattern
(
true
)
;
renderedImgSampleCoverage
=
this
.
readImage
(
)
;
tcuLogImage
.
logImage
(
'
RenderedImageSampleCoverage
'
'
Rendered
image
with
gl
.
SAMPLE_COVERAGE
enabled
'
renderedImgSampleCoverage
.
getAccess
(
)
)
;
var
passed
=
tcuImageCompare
.
pixelThresholdCompare
(
'
CoverageVsNoCoverage
'
'
Comparison
of
same
pattern
with
gl
.
SAMPLE_COVERAGE
disabled
and
enabled
'
renderedImgNoSampleCoverage
renderedImgSampleCoverage
[
0
0
0
0
]
)
;
if
(
passed
)
{
bufferedLogToConsole
(
'
Success
:
The
two
images
rendered
are
identical
'
)
;
testPassedOptions
(
'
Passed
'
true
)
;
}
else
{
testFailedOptions
(
'
Failed
'
false
)
;
}
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fMultisampleTests
.
init
=
function
(
)
{
var
testGroup
=
tcuTestCase
.
runner
.
testCases
;
var
CaseType
=
{
DEFAULT_FRAMEBUFFER
:
0
FBO_4_SAMPLES
:
1
FBO_8_SAMPLES
:
2
FBO_MAX_SAMPLES
:
3
}
;
for
(
var
caseTypeI
in
CaseType
)
{
var
caseType
=
CaseType
[
caseTypeI
]
;
var
numFboSamples
=
caseType
=
=
=
CaseType
.
DEFAULT_FRAMEBUFFER
?
-
1
:
caseType
=
=
=
CaseType
.
FBO_4_SAMPLES
?
4
:
caseType
=
=
=
CaseType
.
FBO_8_SAMPLES
?
8
:
caseType
=
=
=
CaseType
.
FBO_MAX_SAMPLES
?
0
:
-
2
;
var
name
=
caseType
=
=
=
CaseType
.
DEFAULT_FRAMEBUFFER
?
'
default_framebuffer
'
:
caseType
=
=
=
CaseType
.
FBO_4_SAMPLES
?
'
fbo_4_samples
'
:
caseType
=
=
=
CaseType
.
FBO_8_SAMPLES
?
'
fbo_8_samples
'
:
caseType
=
=
=
CaseType
.
FBO_MAX_SAMPLES
?
'
fbo_max_samples
'
:
null
;
var
desc
=
caseType
=
=
=
CaseType
.
DEFAULT_FRAMEBUFFER
?
'
Render
into
default
framebuffer
'
:
caseType
=
=
=
CaseType
.
FBO_4_SAMPLES
?
'
Render
into
a
framebuffer
object
with
4
samples
'
:
caseType
=
=
=
CaseType
.
FBO_8_SAMPLES
?
'
Render
into
a
framebuffer
object
with
8
samples
'
:
caseType
=
=
=
CaseType
.
FBO_MAX_SAMPLES
?
'
Render
into
a
framebuffer
object
with
the
maximum
number
of
samples
'
:
null
;
var
group
=
tcuTestCase
.
newTest
(
name
desc
)
;
assertMsgOptions
(
group
.
name
!
=
null
'
Error
:
No
Test
Name
'
false
true
)
;
assertMsgOptions
(
group
.
description
!
=
null
'
Error
:
No
Test
Description
'
false
true
)
;
assertMsgOptions
(
numFboSamples
>
=
-
1
'
Assert
Failed
:
numFboSamples
>
=
-
1
'
false
true
)
;
testGroup
.
addChild
(
group
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
PolygonNumSamplesCase
(
'
num_samples_polygon
'
'
Test
sanity
of
the
sample
count
with
polygons
'
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
LineNumSamplesCase
(
'
num_samples_line
'
'
Test
sanity
of
the
sample
count
with
lines
'
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
CommonEdgeCase
(
'
common_edge_small_quads
'
'
Test
polygons
\
'
s
common
edges
with
small
quads
'
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
SMALL_QUADS
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
CommonEdgeCase
(
'
common_edge_big_quad
'
'
Test
polygon
\
'
s
common
edges
with
bigger
-
than
-
viewport
quads
'
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
BIGGER_THAN_VIEWPORT_QUAD
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
CommonEdgeCase
(
'
common_edge_viewport_quad
'
'
Test
polygons
\
'
common
edges
with
exactly
viewport
-
sized
quads
'
es3fMultisampleTests
.
CommonEdgeCase
.
CaseType
.
FIT_VIEWPORT_QUAD
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
SampleDepthCase
(
'
depth
'
'
Test
that
depth
values
are
per
-
sample
'
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
SampleStencilCase
(
'
stencil
'
'
Test
that
stencil
values
are
per
-
sample
'
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
CoverageMaskInvertCase
(
'
sample_coverage_invert
'
'
Test
that
non
-
inverted
and
inverted
sample
coverage
masks
are
each
other
\
'
s
negations
'
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskProportionalityCase
(
'
proportionality_alpha_to_coverage
'
'
Test
the
proportionality
property
of
GL_SAMPLE_ALPHA_TO_COVERAGE
'
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
ALPHA_TO_COVERAGE
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskProportionalityCase
(
'
proportionality_sample_coverage
'
'
Test
the
proportionality
property
of
GL_SAMPLE_COVERAGE
'
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskProportionalityCase
(
'
proportionality_sample_coverage_inverted
'
'
Test
the
proportionality
property
of
inverted
-
mask
GL_SAMPLE_COVERAGE
'
es3fMultisampleTests
.
MaskProportionalityCase
.
CaseType
.
SAMPLE_COVERAGE_INVERTED
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskConstancyCase
(
'
constancy_alpha_to_coverage
'
'
Test
that
coverage
mask
is
constant
at
given
coordinates
with
a
given
alpha
or
coverage
value
using
GL_SAMPLE_ALPHA_TO_COVERAGE
'
es3fMultisampleTests
.
MaskConstancyCase
.
CaseType
.
ALPHA_TO_COVERAGE
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskConstancyCase
(
'
constancy_sample_coverage
'
'
Test
that
coverage
mask
is
constant
at
given
coordinates
with
a
given
alpha
or
coverage
value
using
GL_SAMPLE_COVERAGE
'
es3fMultisampleTests
.
MaskConstancyCase
.
CaseType
.
SAMPLE_COVERAGE
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskConstancyCase
(
'
constancy_sample_coverage_inverted
'
'
Test
that
coverage
mask
is
constant
at
given
coordinates
with
a
given
alpha
or
coverage
value
using
inverted
-
mask
GL_SAMPLE_COVERAGE
'
es3fMultisampleTests
.
MaskConstancyCase
.
CaseType
.
SAMPLE_COVERAGE_INVERTED
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskConstancyCase
(
'
constancy_both
'
'
Test
that
coverage
mask
is
constant
at
given
coordinates
with
a
given
alpha
or
coverage
value
using
GL_SAMPLE_ALPHA_TO_COVERAGE
and
GL_SAMPLE_COVERAGE
'
es3fMultisampleTests
.
MaskConstancyCase
.
CaseType
.
BOTH
numFboSamples
)
)
;
group
.
addChild
(
new
es3fMultisampleTests
.
MaskConstancyCase
(
'
constancy_both_inverted
'
'
Test
that
coverage
mask
is
constant
at
given
coordinates
with
a
given
alpha
or
coverage
value
using
GL_SAMPLE_ALPHA_TO_COVERAGE
and
inverted
-
mask
GL_SAMPLE_COVERAGE
'
es3fMultisampleTests
.
MaskConstancyCase
.
CaseType
.
BOTH_INVERTED
numFboSamples
)
)
;
}
}
;
es3fMultisampleTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
testName
=
'
multisample
'
;
var
testDescription
=
'
Multisample
Tests
'
;
var
state
=
tcuTestCase
.
runner
;
state
.
testName
=
testName
;
state
.
setRoot
(
tcuTestCase
.
newTest
(
testName
testDescription
null
)
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
es3fMultisampleTests
.
init
(
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fMultisampleTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
