'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fPrimitiveRestartTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fPrimitiveRestartTests
=
functional
.
gles3
.
es3fPrimitiveRestartTests
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gl
;
es3fPrimitiveRestartTests
.
MAX_RENDER_WIDTH
=
256
;
es3fPrimitiveRestartTests
.
MAX_RENDER_HEIGHT
=
256
;
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_BYTE
=
255
;
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_SHORT
=
65535
;
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_INT
=
4294967295
;
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_BYTE
=
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_BYTE
;
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_SHORT
=
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_SHORT
;
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_INT
=
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_INT
;
var
DE_ASSERT
=
function
(
expression
)
{
if
(
!
expression
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
es3fPrimitiveRestartTests
.
PrimitiveType
=
{
PRIMITIVE_POINTS
:
0
PRIMITIVE_LINE_STRIP
:
1
PRIMITIVE_LINE_LOOP
:
2
PRIMITIVE_LINES
:
3
PRIMITIVE_TRIANGLE_STRIP
:
4
PRIMITIVE_TRIANGLE_FAN
:
5
PRIMITIVE_TRIANGLES
:
6
}
;
es3fPrimitiveRestartTests
.
IndexType
=
{
INDEX_UNSIGNED_BYTE
:
0
INDEX_UNSIGNED_SHORT
:
1
INDEX_UNSIGNED_INT
:
2
}
;
es3fPrimitiveRestartTests
.
DrawFunction
=
{
FUNCTION_DRAW_ELEMENTS
:
0
FUNCTION_DRAW_ELEMENTS_INSTANCED
:
1
FUNCTION_DRAW_RANGE_ELEMENTS
:
2
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
=
function
(
name
description
primType
indexType
_function
beginWithRestart
endWithRestart
duplicateRestarts
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_primType
=
primType
;
this
.
m_indexType
=
indexType
;
this
.
m_function
=
_function
;
this
.
m_beginWithRestart
=
beginWithRestart
;
this
.
m_endWithRestart
=
endWithRestart
;
this
.
m_duplicateRestarts
=
duplicateRestarts
;
this
.
m_program
=
null
;
this
.
m_indicesUB
=
[
]
;
this
.
m_indicesUS
=
[
]
;
this
.
m_indicesUI
=
[
]
;
this
.
m_positions
=
[
]
;
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
constructor
=
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
draw
=
function
(
startNdx
count
)
{
var
primTypeGL
;
switch
(
this
.
m_primType
)
{
case
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_POINTS
:
primTypeGL
=
gl
.
POINTS
;
break
;
case
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINE_STRIP
:
primTypeGL
=
gl
.
LINE_STRIP
;
break
;
case
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINE_LOOP
:
primTypeGL
=
gl
.
LINE_LOOP
;
break
;
case
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINES
:
primTypeGL
=
gl
.
LINES
;
break
;
case
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLE_STRIP
:
primTypeGL
=
gl
.
TRIANGLE_STRIP
;
break
;
case
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLE_FAN
:
primTypeGL
=
gl
.
TRIANGLE_FAN
;
break
;
case
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLES
:
primTypeGL
=
gl
.
TRIANGLES
;
break
;
default
:
DE_ASSERT
(
false
)
;
primTypeGL
=
0
;
}
var
indexTypeGL
;
switch
(
this
.
m_indexType
)
{
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
:
indexTypeGL
=
gl
.
UNSIGNED_BYTE
;
break
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
:
indexTypeGL
=
gl
.
UNSIGNED_SHORT
;
break
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
:
indexTypeGL
=
gl
.
UNSIGNED_INT
;
break
;
default
:
DE_ASSERT
(
false
)
;
indexTypeGL
=
0
;
}
var
restartIndex
=
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_BYTE
:
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_SHORT
:
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_INT
:
0
;
DE_ASSERT
(
restartIndex
!
=
0
)
;
var
indexGLBuffer
=
gl
.
createBuffer
(
)
;
var
bufferIndex
=
this
.
getIndexPtr
(
startNdx
)
;
gl
.
bindBuffer
(
gl
.
ELEMENT_ARRAY_BUFFER
indexGLBuffer
)
;
gl
.
bufferData
(
gl
.
ELEMENT_ARRAY_BUFFER
bufferIndex
gl
.
STATIC_DRAW
)
;
if
(
this
.
m_function
=
=
es3fPrimitiveRestartTests
.
DrawFunction
.
FUNCTION_DRAW_ELEMENTS
)
{
gl
.
drawElements
(
primTypeGL
count
indexTypeGL
0
)
;
}
else
if
(
this
.
m_function
=
=
es3fPrimitiveRestartTests
.
DrawFunction
.
FUNCTION_DRAW_ELEMENTS_INSTANCED
)
{
gl
.
drawElementsInstanced
(
primTypeGL
count
indexTypeGL
0
1
)
;
}
else
{
DE_ASSERT
(
this
.
m_function
=
=
es3fPrimitiveRestartTests
.
DrawFunction
.
FUNCTION_DRAW_RANGE_ELEMENTS
)
;
var
max
=
0
;
var
numIndices
=
this
.
getNumIndices
(
)
;
for
(
var
i
=
0
;
i
<
numIndices
;
i
+
+
)
{
var
index
=
this
.
getIndex
(
i
)
;
if
(
index
!
=
restartIndex
&
&
index
>
max
)
max
=
index
;
}
gl
.
drawRangeElements
(
primTypeGL
0
max
count
indexTypeGL
0
)
;
}
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
renderWithRestart
=
function
(
)
{
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
this
.
draw
(
0
this
.
getNumIndices
(
)
)
;
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
renderWithoutRestart
=
function
(
)
{
var
restartIndex
=
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_BYTE
:
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_SHORT
:
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_INT
:
0
;
DE_ASSERT
(
restartIndex
!
=
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
var
numIndices
=
this
.
getNumIndices
(
)
;
DE_ASSERT
(
numIndices
>
=
0
)
;
var
indexArrayStartNdx
=
0
;
for
(
var
indexArrayNdx
=
0
;
indexArrayNdx
<
=
numIndices
;
indexArrayNdx
+
+
)
{
if
(
indexArrayNdx
>
=
numIndices
|
|
this
.
getIndex
(
indexArrayNdx
)
=
=
restartIndex
)
{
if
(
indexArrayStartNdx
<
numIndices
)
{
this
.
draw
(
indexArrayStartNdx
indexArrayNdx
-
indexArrayStartNdx
)
;
}
indexArrayStartNdx
=
indexArrayNdx
+
1
;
}
}
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
addIndex
=
function
(
index
)
{
if
(
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
index
0
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_BYTE
)
)
;
this
.
m_indicesUB
.
push
(
index
)
;
}
else
if
(
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
index
0
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_SHORT
)
)
;
this
.
m_indicesUS
.
push
(
index
)
;
}
else
if
(
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
index
0
es3fPrimitiveRestartTests
.
MAX_UNSIGNED_INT
)
)
;
this
.
m_indicesUI
.
push
(
index
)
;
}
else
DE_ASSERT
(
false
)
;
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
getIndex
=
function
(
indexNdx
)
{
switch
(
this
.
m_indexType
)
{
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
:
return
this
.
m_indicesUB
[
indexNdx
]
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
:
return
this
.
m_indicesUS
[
indexNdx
]
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
:
return
this
.
m_indicesUI
[
indexNdx
]
;
default
:
DE_ASSERT
(
false
)
;
return
0
;
}
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
getNumIndices
=
function
(
)
{
switch
(
this
.
m_indexType
)
{
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
:
return
this
.
m_indicesUB
.
length
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
:
return
this
.
m_indicesUS
.
length
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
:
return
this
.
m_indicesUI
.
length
;
default
:
DE_ASSERT
(
false
)
;
return
0
;
}
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
getIndexPtr
=
function
(
indexNdx
)
{
switch
(
this
.
m_indexType
)
{
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
:
return
new
Uint8Array
(
this
.
m_indicesUB
)
.
subarray
(
indexNdx
)
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
:
return
new
Uint16Array
(
this
.
m_indicesUS
)
.
subarray
(
indexNdx
)
;
case
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
:
return
new
Uint32Array
(
this
.
m_indicesUI
)
.
subarray
(
indexNdx
)
;
default
:
DE_ASSERT
(
false
)
;
return
null
;
}
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
init
=
function
(
)
{
gl
.
getError
(
)
;
var
vertShaderSource
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
\
n
'
+
'
void
main
(
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
}
\
n
'
;
var
fragShaderSource
=
'
#
version
300
es
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
\
n
'
+
'
void
main
(
)
\
n
'
+
'
{
\
n
'
+
'
o_color
=
vec4
(
1
.
0f
)
;
\
n
'
+
'
}
\
n
'
;
DE_ASSERT
(
!
this
.
m_program
)
;
this
.
m_program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vertShaderSource
fragShaderSource
)
)
;
if
(
!
this
.
m_program
.
isOk
(
)
)
{
testFailedOptions
(
'
Failed
to
compile
shader
'
true
)
;
}
var
restartIndex
=
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_BYTE
:
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_SHORT
:
this
.
m_indexType
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
?
es3fPrimitiveRestartTests
.
RESTART_INDEX_UNSIGNED_INT
:
0
;
DE_ASSERT
(
restartIndex
!
=
0
)
;
DE_ASSERT
(
this
.
getNumIndices
(
)
=
=
0
)
;
if
(
this
.
m_beginWithRestart
)
{
this
.
addIndex
(
restartIndex
)
;
if
(
this
.
m_duplicateRestarts
)
this
.
addIndex
(
restartIndex
)
;
}
var
curIndex
;
var
numRows
;
var
numCols
;
var
fx
;
var
fy
;
var
centerY
;
var
centerX
;
var
numVertices
;
var
numArcVertices
;
var
numStrips
;
if
(
this
.
m_primType
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_POINTS
)
{
curIndex
=
0
;
numRows
=
20
;
for
(
var
row
=
0
;
row
<
numRows
;
row
+
+
)
{
for
(
var
col
=
0
;
col
<
row
+
1
;
col
+
+
)
{
fx
=
-
1
.
0
+
2
.
0
*
(
col
+
0
.
5
)
/
numRows
;
fy
=
-
1
.
0
+
2
.
0
*
(
row
+
0
.
5
)
/
numRows
;
this
.
m_positions
.
push
(
fx
)
;
this
.
m_positions
.
push
(
fy
)
;
this
.
addIndex
(
curIndex
+
+
)
;
}
if
(
row
<
numRows
-
1
)
{
this
.
addIndex
(
restartIndex
)
;
if
(
this
.
m_duplicateRestarts
)
this
.
addIndex
(
restartIndex
)
;
}
}
}
else
if
(
this
.
m_primType
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINE_STRIP
|
|
this
.
m_primType
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINE_LOOP
|
|
this
.
m_primType
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINES
)
{
curIndex
=
0
;
numRows
=
4
;
numCols
=
4
;
for
(
var
row
=
0
;
row
<
numRows
;
row
+
+
)
{
centerY
=
-
1
.
0
+
2
.
0
*
(
row
+
0
.
5
)
/
numRows
;
for
(
var
col
=
0
;
col
<
numCols
;
col
+
+
)
{
centerX
=
-
1
.
0
+
2
.
0
*
(
col
+
0
.
5
)
/
numCols
;
numVertices
=
row
*
numCols
+
col
+
1
;
for
(
var
i
=
0
;
i
<
numVertices
;
i
+
+
)
{
fx
=
centerX
+
0
.
9
*
Math
.
cos
(
i
*
2
.
0
*
Math
.
PI
/
numVertices
)
/
numCols
;
fy
=
centerY
+
0
.
9
*
Math
.
sin
(
i
*
2
.
0
*
Math
.
PI
/
numVertices
)
/
numRows
;
this
.
m_positions
.
push
(
fx
)
;
this
.
m_positions
.
push
(
fy
)
;
this
.
addIndex
(
curIndex
+
+
)
;
}
if
(
col
<
numCols
-
1
|
|
row
<
numRows
-
1
)
{
this
.
addIndex
(
restartIndex
)
;
if
(
this
.
m_duplicateRestarts
)
this
.
addIndex
(
restartIndex
)
;
}
}
}
}
else
if
(
this
.
m_primType
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLE_STRIP
)
{
curIndex
=
0
;
numStrips
=
20
;
for
(
var
stripNdx
=
0
;
stripNdx
<
numStrips
;
stripNdx
+
+
)
{
numVertices
=
stripNdx
+
1
;
for
(
var
i
=
0
;
i
<
numVertices
;
i
+
+
)
{
fx
=
-
0
.
9
+
1
.
8
*
(
i
/
2
*
2
)
/
numStrips
;
fy
=
-
0
.
9
+
1
.
8
*
(
stripNdx
+
(
i
%
2
=
=
0
?
0
.
0
:
0
.
8
)
)
/
numStrips
;
this
.
m_positions
.
push
(
fx
)
;
this
.
m_positions
.
push
(
fy
)
;
this
.
addIndex
(
curIndex
+
+
)
;
}
if
(
stripNdx
<
numStrips
-
1
)
{
this
.
addIndex
(
restartIndex
)
;
if
(
this
.
m_duplicateRestarts
)
this
.
addIndex
(
restartIndex
)
;
}
}
}
else
if
(
this
.
m_primType
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLE_FAN
)
{
curIndex
=
0
;
numRows
=
4
;
numCols
=
4
;
for
(
var
row
=
0
;
row
<
numRows
;
row
+
+
)
{
centerY
=
-
1
.
0
+
2
.
0
*
(
row
+
0
.
5
)
/
numRows
;
for
(
var
col
=
0
;
col
<
numCols
;
col
+
+
)
{
centerX
=
-
1
.
0
+
2
.
0
*
(
col
+
0
.
5
)
/
numCols
;
numArcVertices
=
row
*
numCols
+
col
;
this
.
m_positions
.
push
(
centerX
)
;
this
.
m_positions
.
push
(
centerY
)
;
this
.
addIndex
(
curIndex
+
+
)
;
for
(
var
i
=
0
;
i
<
numArcVertices
;
i
+
+
)
{
fx
=
centerX
+
0
.
9
*
Math
.
cos
(
i
*
2
.
0
*
Math
.
PI
/
numArcVertices
)
/
numCols
;
fy
=
centerY
+
0
.
9
*
Math
.
sin
(
i
*
2
.
0
*
Math
.
PI
/
numArcVertices
)
/
numRows
;
this
.
m_positions
.
push
(
fx
)
;
this
.
m_positions
.
push
(
fy
)
;
this
.
addIndex
(
curIndex
+
+
)
;
}
if
(
col
<
numCols
-
1
|
|
row
<
numRows
-
1
)
{
this
.
addIndex
(
restartIndex
)
;
if
(
this
.
m_duplicateRestarts
)
this
.
addIndex
(
restartIndex
)
;
}
}
}
}
else
if
(
this
.
m_primType
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLES
)
{
curIndex
=
0
;
numRows
=
3
*
7
;
for
(
var
rowNdx
=
0
;
rowNdx
<
numRows
;
rowNdx
+
+
)
{
numVertices
=
rowNdx
+
1
;
for
(
var
i
=
0
;
i
<
numVertices
;
i
+
+
)
{
fx
=
-
0
.
9
+
1
.
8
*
(
(
i
/
3
)
+
(
i
%
3
=
=
2
?
0
.
8
:
0
.
0
)
)
*
3
/
numRows
;
fy
=
-
0
.
9
+
1
.
8
*
(
rowNdx
+
(
i
%
3
=
=
0
?
0
.
0
:
0
.
8
)
)
/
numRows
;
this
.
m_positions
.
push
(
fx
)
;
this
.
m_positions
.
push
(
fy
)
;
this
.
addIndex
(
curIndex
+
+
)
;
}
if
(
rowNdx
<
numRows
-
1
)
{
this
.
addIndex
(
restartIndex
)
;
if
(
this
.
m_duplicateRestarts
)
this
.
addIndex
(
restartIndex
)
;
}
}
}
else
DE_ASSERT
(
false
)
;
if
(
this
.
m_endWithRestart
)
{
this
.
addIndex
(
restartIndex
)
;
if
(
this
.
m_duplicateRestarts
)
this
.
addIndex
(
restartIndex
)
;
}
var
numIndices
=
this
.
getNumIndices
(
)
;
DE_ASSERT
(
numIndices
>
0
)
;
DE_ASSERT
(
this
.
m_beginWithRestart
|
|
this
.
getIndex
(
0
)
!
=
restartIndex
)
;
DE_ASSERT
(
this
.
m_endWithRestart
|
|
this
.
getIndex
(
numIndices
-
1
)
!
=
restartIndex
)
;
if
(
!
this
.
m_duplicateRestarts
)
for
(
var
i
=
1
;
i
<
numIndices
;
i
+
+
)
DE_ASSERT
(
this
.
getIndex
(
i
)
!
=
restartIndex
|
|
this
.
getIndex
(
i
-
1
)
!
=
restartIndex
)
;
}
;
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
.
prototype
.
iterate
=
function
(
)
{
var
width
=
Math
.
min
(
gl
.
drawingBufferWidth
es3fPrimitiveRestartTests
.
MAX_RENDER_WIDTH
)
;
var
height
=
Math
.
min
(
gl
.
drawingBufferHeight
es3fPrimitiveRestartTests
.
MAX_RENDER_HEIGHT
)
;
var
xOffsetMax
=
gl
.
drawingBufferWidth
-
width
;
var
yOffsetMax
=
gl
.
drawingBufferHeight
-
height
;
var
rnd
=
new
deRandom
.
Random
(
deString
.
deStringHash
(
this
.
name
)
)
;
var
xOffset
=
rnd
.
getInt
(
0
xOffsetMax
)
;
var
yOffset
=
rnd
.
getInt
(
0
yOffsetMax
)
;
var
referenceImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
resultImg
=
new
tcuSurface
.
Surface
(
width
height
)
;
gl
.
viewport
(
xOffset
yOffset
width
height
)
;
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
var
program
=
this
.
m_program
.
getProgram
(
)
;
gl
.
useProgram
(
program
)
;
var
loc
=
gl
.
getAttribLocation
(
program
'
a_position
'
)
;
gl
.
enableVertexAttribArray
(
loc
)
;
var
locGlBuffer
=
gl
.
createBuffer
(
)
;
var
bufferLoc
=
new
Float32Array
(
this
.
m_positions
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
locGlBuffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
bufferLoc
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribPointer
(
loc
2
gl
.
FLOAT
false
0
0
)
;
this
.
renderWithRestart
(
)
;
var
resImg
=
resultImg
.
getAccess
(
)
;
var
resImgTransferFormat
=
gluTextureUtil
.
getTransferFormat
(
resImg
.
getFormat
(
)
)
;
gl
.
readPixels
(
xOffset
yOffset
resImg
.
m_width
resImg
.
m_height
resImgTransferFormat
.
format
resImgTransferFormat
.
dataType
resultImg
.
m_pixels
)
;
this
.
renderWithoutRestart
(
)
;
var
refImg
=
referenceImg
.
getAccess
(
)
;
var
refImgTransferFormat
=
gluTextureUtil
.
getTransferFormat
(
refImg
.
getFormat
(
)
)
;
gl
.
readPixels
(
xOffset
yOffset
refImg
.
m_width
refImg
.
m_height
refImgTransferFormat
.
format
refImgTransferFormat
.
dataType
referenceImg
.
m_pixels
)
;
var
testOk
=
tcuImageCompare
.
pixelThresholdCompare
(
'
ComparisonResult
'
'
Image
comparison
result
'
referenceImg
resultImg
[
0
0
0
0
]
)
;
assertMsgOptions
(
testOk
'
'
true
false
)
;
gl
.
useProgram
(
null
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fPrimitiveRestartTests
.
init
=
function
(
)
{
var
testGroup
=
tcuTestCase
.
runner
.
testCases
;
for
(
var
isRestartBeginCaseI
=
0
;
isRestartBeginCaseI
<
=
1
;
isRestartBeginCaseI
+
+
)
{
for
(
var
isRestartEndCaseI
=
0
;
isRestartEndCaseI
<
=
1
;
isRestartEndCaseI
+
+
)
{
for
(
var
isDuplicateRestartCaseI
=
0
;
isDuplicateRestartCaseI
<
=
1
;
isDuplicateRestartCaseI
+
+
)
{
var
isRestartBeginCase
=
isRestartBeginCaseI
!
=
0
;
var
isRestartEndCase
=
isRestartEndCaseI
!
=
0
;
var
isDuplicateRestartCase
=
isDuplicateRestartCaseI
!
=
0
;
var
specialCaseGroupName
=
'
'
;
if
(
isRestartBeginCase
)
specialCaseGroupName
=
'
begin_restart
'
;
if
(
isRestartEndCase
)
specialCaseGroupName
+
=
(
deString
.
deIsStringEmpty
(
specialCaseGroupName
)
?
'
'
:
'
_
'
)
+
'
end_restart
'
;
if
(
isDuplicateRestartCase
)
specialCaseGroupName
+
=
(
deString
.
deIsStringEmpty
(
specialCaseGroupName
)
?
'
'
:
'
_
'
)
+
'
duplicate_restarts
'
;
if
(
deString
.
deIsStringEmpty
(
specialCaseGroupName
)
)
specialCaseGroupName
=
'
basic
'
;
var
specialCaseGroup
=
tcuTestCase
.
newTest
(
specialCaseGroupName
'
'
)
;
testGroup
.
addChild
(
specialCaseGroup
)
;
for
(
var
primType
in
es3fPrimitiveRestartTests
.
PrimitiveType
)
{
var
primTypeName
=
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_POINTS
?
'
points
'
:
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINE_STRIP
?
'
line_strip
'
:
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINE_LOOP
?
'
line_loop
'
:
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_LINES
?
'
lines
'
:
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLE_STRIP
?
'
triangle_strip
'
:
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLE_FAN
?
'
triangle_fan
'
:
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
=
=
es3fPrimitiveRestartTests
.
PrimitiveType
.
PRIMITIVE_TRIANGLES
?
'
triangles
'
:
'
'
;
DE_ASSERT
(
primTypeName
!
=
null
)
;
var
primTypeGroup
=
tcuTestCase
.
newTest
(
primTypeName
'
'
)
;
specialCaseGroup
.
addChild
(
primTypeGroup
)
;
for
(
var
indexType
in
es3fPrimitiveRestartTests
.
IndexType
)
{
var
indexTypeName
=
es3fPrimitiveRestartTests
.
IndexType
[
indexType
]
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_BYTE
?
'
unsigned_byte
'
:
es3fPrimitiveRestartTests
.
IndexType
[
indexType
]
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_SHORT
?
'
unsigned_short
'
:
es3fPrimitiveRestartTests
.
IndexType
[
indexType
]
=
=
es3fPrimitiveRestartTests
.
IndexType
.
INDEX_UNSIGNED_INT
?
'
unsigned_int
'
:
'
'
;
DE_ASSERT
(
indexTypeName
!
=
null
)
;
var
indexTypeGroup
=
tcuTestCase
.
newTest
(
indexTypeName
'
'
)
;
primTypeGroup
.
addChild
(
indexTypeGroup
)
;
for
(
var
_function
in
es3fPrimitiveRestartTests
.
DrawFunction
)
{
var
functionName
=
es3fPrimitiveRestartTests
.
DrawFunction
[
_function
]
=
=
es3fPrimitiveRestartTests
.
DrawFunction
.
FUNCTION_DRAW_ELEMENTS
?
'
draw_elements
'
:
es3fPrimitiveRestartTests
.
DrawFunction
[
_function
]
=
=
es3fPrimitiveRestartTests
.
DrawFunction
.
FUNCTION_DRAW_ELEMENTS_INSTANCED
?
'
draw_elements_instanced
'
:
es3fPrimitiveRestartTests
.
DrawFunction
[
_function
]
=
=
es3fPrimitiveRestartTests
.
DrawFunction
.
FUNCTION_DRAW_RANGE_ELEMENTS
?
'
draw_range_elements
'
:
null
;
DE_ASSERT
(
functionName
!
=
null
)
;
indexTypeGroup
.
addChild
(
new
es3fPrimitiveRestartTests
.
PrimitiveRestartCase
(
functionName
'
'
es3fPrimitiveRestartTests
.
PrimitiveType
[
primType
]
es3fPrimitiveRestartTests
.
IndexType
[
indexType
]
es3fPrimitiveRestartTests
.
DrawFunction
[
_function
]
isRestartBeginCase
isRestartEndCase
isDuplicateRestartCase
)
)
;
}
}
}
}
}
}
}
;
es3fPrimitiveRestartTests
.
run
=
function
(
context
range
)
{
gl
=
context
;
var
testName
=
'
primitive_restart
'
;
var
testDescription
=
'
Primitive
Restart
Tests
'
;
var
state
=
tcuTestCase
.
runner
;
state
.
testName
=
testName
;
state
.
setRoot
(
tcuTestCase
.
newTest
(
testName
testDescription
null
)
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
es3fPrimitiveRestartTests
.
init
(
)
;
if
(
range
)
state
.
setRange
(
range
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fPrimitiveRestartTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
