'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fFboStencilbufferTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrUtil
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestCase
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fFboStencilbufferTests
=
functional
.
gles3
.
es3fFboStencilbufferTests
;
var
es3fFboTestCase
=
functional
.
gles3
.
es3fFboTestCase
;
var
es3fFboTestUtil
=
functional
.
gles3
.
es3fFboTestUtil
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
rrUtil
=
framework
.
referencerenderer
.
rrUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gl
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
es3fFboStencilbufferTests
.
BasicFboStencilCase
=
function
(
name
desc
format
size
useDepth
)
{
es3fFboTestCase
.
FboTestCase
.
call
(
this
name
desc
)
;
this
.
m_format
=
format
;
this
.
m_size
=
size
;
this
.
m_useDepth
=
useDepth
;
}
;
es3fFboStencilbufferTests
.
BasicFboStencilCase
.
prototype
=
Object
.
create
(
es3fFboTestCase
.
FboTestCase
.
prototype
)
;
es3fFboStencilbufferTests
.
BasicFboStencilCase
.
prototype
.
constructor
=
es3fFboStencilbufferTests
.
BasicFboStencilCase
;
es3fFboStencilbufferTests
.
BasicFboStencilCase
.
prototype
.
preCheck
=
function
(
)
{
this
.
checkFormatSupport
(
this
.
m_format
)
;
}
;
es3fFboStencilbufferTests
.
BasicFboStencilCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
colorFormat
=
gl
.
RGBA8
;
var
gradShader
=
new
es3fFboTestUtil
.
GradientShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShaderID
=
this
.
getCurrentContext
(
)
.
createProgram
(
flatShader
)
;
var
gradShaderID
=
this
.
getCurrentContext
(
)
.
createProgram
(
gradShader
)
;
var
fbo
=
0
;
var
colorRbo
=
0
;
var
depthStencilRbo
=
0
;
colorRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
colorRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
colorFormat
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
depthStencilRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
depthStencilRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
this
.
m_format
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
fbo
=
ctx
.
createFramebuffer
(
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
colorRbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
STENCIL_ATTACHMENT
gl
.
RENDERBUFFER
depthStencilRbo
)
;
if
(
this
.
m_useDepth
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
DEPTH_ATTACHMENT
gl
.
RENDERBUFFER
depthStencilRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
viewport
(
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
ctx
.
clearBufferfv
(
gl
.
COLOR
0
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
ctx
.
clearBufferfi
(
gl
.
DEPTH_STENCIL
0
1
.
0
0
)
;
ctx
.
enable
(
gl
.
DEPTH_TEST
)
;
ctx
.
enable
(
gl
.
STENCIL_TEST
)
;
ctx
.
stencilFunc
(
gl
.
ALWAYS
0
0xff
)
;
ctx
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
INCR
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
1
.
0
0
.
0
0
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
gradShader
.
setGradient
(
this
.
getCurrentContext
(
)
gradShaderID
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
gradShaderID
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
)
;
ctx
.
disable
(
gl
.
DEPTH_TEST
)
;
ctx
.
stencilFunc
(
gl
.
EQUAL
this
.
m_useDepth
?
2
:
1
0xff
)
;
ctx
.
stencilOp
(
gl
.
DECR
gl
.
KEEP
gl
.
KEEP
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
0
.
5
-
0
.
5
0
.
0
]
[
0
.
5
0
.
5
0
.
0
]
)
;
ctx
.
stencilFunc
(
gl
.
GREATER
this
.
m_useDepth
?
1
:
2
0xff
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
0
.
0
0
.
0
1
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
this
.
readPixelsUsingFormat
(
dst
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
gluTextureUtil
.
mapGLInternalFormat
(
colorFormat
)
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
;
es3fFboStencilbufferTests
.
DepthStencilAttachCase
=
function
(
name
desc
attachDepth
attachStencil
)
{
es3fFboTestCase
.
FboTestCase
.
call
(
this
name
desc
)
;
this
.
m_attachDepth
=
attachDepth
;
this
.
m_attachStencil
=
attachStencil
;
DE_ASSERT
(
this
.
m_attachDepth
=
=
gl
.
DEPTH_ATTACHMENT
|
|
this
.
m_attachDepth
=
=
gl
.
DEPTH_STENCIL_ATTACHMENT
|
|
this
.
m_attachDepth
=
=
gl
.
NONE
)
;
DE_ASSERT
(
this
.
m_attachStencil
=
=
gl
.
STENCIL_ATTACHMENT
|
|
this
.
m_attachStencil
=
=
gl
.
NONE
)
;
DE_ASSERT
(
this
.
m_attachDepth
!
=
gl
.
DEPTH_STENCIL
|
|
this
.
m_attachStencil
=
=
gl
.
NONE
)
;
}
;
es3fFboStencilbufferTests
.
DepthStencilAttachCase
.
prototype
=
Object
.
create
(
es3fFboTestCase
.
FboTestCase
.
prototype
)
;
es3fFboStencilbufferTests
.
DepthStencilAttachCase
.
prototype
.
constructor
=
es3fFboStencilbufferTests
.
DepthStencilAttachCase
;
es3fFboStencilbufferTests
.
DepthStencilAttachCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
colorFormat
=
gl
.
RGBA8
;
var
depthStencilFormat
=
gl
.
DEPTH24_STENCIL8
;
var
width
=
128
;
var
height
=
128
;
var
hasDepth
=
this
.
m_attachDepth
=
=
gl
.
DEPTH_STENCIL
|
|
this
.
m_attachDepth
=
=
gl
.
DEPTH_ATTACHMENT
;
var
gradShader
=
new
es3fFboTestUtil
.
GradientShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShaderID
=
this
.
getCurrentContext
(
)
.
createProgram
(
flatShader
)
;
var
gradShaderID
=
this
.
getCurrentContext
(
)
.
createProgram
(
gradShader
)
;
var
fbo
=
0
;
var
colorRbo
=
0
;
var
depthStencilRbo
=
0
;
colorRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
colorRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
colorFormat
width
height
)
;
depthStencilRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
depthStencilRbo
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
depthStencilFormat
width
height
)
;
fbo
=
ctx
.
createFramebuffer
(
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
colorRbo
)
;
if
(
this
.
m_attachDepth
!
=
gl
.
NONE
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
this
.
m_attachDepth
gl
.
RENDERBUFFER
depthStencilRbo
)
;
if
(
this
.
m_attachStencil
!
=
gl
.
NONE
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
this
.
m_attachStencil
gl
.
RENDERBUFFER
depthStencilRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
viewport
(
0
0
width
height
)
;
ctx
.
clearBufferfv
(
gl
.
COLOR
0
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
ctx
.
clearBufferfi
(
gl
.
DEPTH_STENCIL
0
1
.
0
0
)
;
ctx
.
enable
(
gl
.
DEPTH_TEST
)
;
ctx
.
enable
(
gl
.
STENCIL_TEST
)
;
ctx
.
stencilFunc
(
gl
.
ALWAYS
0
0xff
)
;
ctx
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
INCR
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
1
.
0
0
.
0
0
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
gradShader
.
setGradient
(
this
.
getCurrentContext
(
)
gradShaderID
[
0
.
0
0
.
0
0
.
0
0
.
0
]
[
1
.
0
1
.
0
1
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
gradShaderID
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
)
;
ctx
.
disable
(
gl
.
DEPTH_TEST
)
;
ctx
.
stencilFunc
(
gl
.
EQUAL
hasDepth
?
2
:
1
0xff
)
;
ctx
.
stencilOp
(
gl
.
DECR
gl
.
KEEP
gl
.
KEEP
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
0
.
5
-
0
.
5
0
.
0
]
[
0
.
5
0
.
5
0
.
0
]
)
;
ctx
.
stencilFunc
(
gl
.
GREATER
hasDepth
?
1
:
2
0xff
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
[
0
.
0
0
.
0
1
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
this
.
readPixelsUsingFormat
(
dst
0
0
width
height
gluTextureUtil
.
mapGLInternalFormat
(
colorFormat
)
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
;
es3fFboStencilbufferTests
.
FboStencilTests
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
stencil
'
'
FBO
Stencilbuffer
tests
'
)
;
}
;
es3fFboStencilbufferTests
.
FboStencilTests
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fFboStencilbufferTests
.
FboStencilTests
.
prototype
.
constructor
=
es3fFboStencilbufferTests
.
FboStencilTests
;
es3fFboStencilbufferTests
.
FboStencilTests
.
prototype
.
init
=
function
(
)
{
var
stencilFormats
=
[
gl
.
DEPTH32F_STENCIL8
gl
.
DEPTH24_STENCIL8
gl
.
STENCIL_INDEX8
]
;
var
basicGroup
=
tcuTestCase
.
newTest
(
'
basic
'
'
Basic
stencil
tests
'
)
;
this
.
addChild
(
basicGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
stencilFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
stencilFormats
[
fmtNdx
]
;
var
texFmt
=
gluTextureUtil
.
mapGLInternalFormat
(
format
)
;
basicGroup
.
addChild
(
new
es3fFboStencilbufferTests
.
BasicFboStencilCase
(
es3fFboTestUtil
.
getFormatName
(
format
)
'
'
format
[
111
132
]
false
)
)
;
if
(
texFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
DS
)
basicGroup
.
addChild
(
new
es3fFboStencilbufferTests
.
BasicFboStencilCase
(
es3fFboTestUtil
.
getFormatName
(
format
)
+
'
_depth
'
'
'
format
[
111
132
]
true
)
)
;
}
var
attachGroup
=
tcuTestCase
.
newTest
(
'
attach
'
'
Attaching
depth
stencil
'
)
;
this
.
addChild
(
attachGroup
)
;
attachGroup
.
addChild
(
new
es3fFboStencilbufferTests
.
DepthStencilAttachCase
(
'
depth_only
'
'
Only
depth
part
of
depth
-
stencil
RBO
attached
'
gl
.
DEPTH_ATTACHMENT
gl
.
NONE
)
)
;
attachGroup
.
addChild
(
new
es3fFboStencilbufferTests
.
DepthStencilAttachCase
(
'
stencil_only
'
'
Only
stencil
part
of
depth
-
stencil
RBO
attached
'
gl
.
NONE
gl
.
STENCIL_ATTACHMENT
)
)
;
attachGroup
.
addChild
(
new
es3fFboStencilbufferTests
.
DepthStencilAttachCase
(
'
depth_stencil_separate
'
'
Depth
and
stencil
attached
separately
'
gl
.
DEPTH_ATTACHMENT
gl
.
STENCIL_ATTACHMENT
)
)
;
attachGroup
.
addChild
(
new
es3fFboStencilbufferTests
.
DepthStencilAttachCase
(
'
depth_stencil_attachment
'
'
Depth
and
stencil
attached
with
DEPTH_STENCIL_ATTACHMENT
'
gl
.
DEPTH_STENCIL_ATTACHMENT
gl
.
NONE
)
)
;
}
;
es3fFboStencilbufferTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
var
test
=
new
es3fFboStencilbufferTests
.
FboStencilTests
(
)
;
var
testName
=
test
.
fullName
(
)
;
var
testDescription
=
test
.
getDescription
(
)
;
state
.
testName
=
testName
;
state
.
setRoot
(
test
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
test
.
init
(
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fFboStencilbufferTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
