'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fTextureFormatTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuCompressedTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluStrUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTexture
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsTextureTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fTextureFormatTests
=
functional
.
gles3
.
es3fTextureFormatTests
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
gluTexture
=
framework
.
opengl
.
gluTexture
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
glsTextureTestUtil
=
modules
.
shared
.
glsTextureTestUtil
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
gluStrUtil
=
framework
.
opengl
.
gluStrUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
tcuCompressedTexture
=
framework
.
common
.
tcuCompressedTexture
;
var
gl
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
es3fTextureFormatTests
.
version
=
'
300
es
'
;
es3fTextureFormatTests
.
testDescription
=
function
(
)
{
var
test
=
tcuTestCase
.
runner
.
currentTest
;
return
test
.
description
;
}
;
es3fTextureFormatTests
.
setParentClass
=
function
(
child
parent
)
{
child
.
prototype
=
Object
.
create
(
parent
.
prototype
)
;
child
.
prototype
.
constructor
=
child
;
}
;
es3fTextureFormatTests
.
Texture2DFormatCase
=
function
(
descriptor
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
descriptor
.
name
descriptor
.
description
)
;
this
.
m_format
=
descriptor
.
format
;
this
.
m_dataType
=
descriptor
.
dataType
;
this
.
m_width
=
descriptor
.
width
;
this
.
m_height
=
descriptor
.
height
;
this
.
m_renderer
=
new
glsTextureTestUtil
.
TextureRenderer
(
es3fTextureFormatTests
.
version
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
}
;
es3fTextureFormatTests
.
setParentClass
(
es3fTextureFormatTests
.
Texture2DFormatCase
tcuTestCase
.
DeqpTest
)
;
es3fTextureFormatTests
.
Texture2DFormatCase
.
prototype
.
init
=
function
(
)
{
var
fmt
=
this
.
m_dataType
?
gluTextureUtil
.
mapGLTransferFormat
(
this
.
m_format
this
.
m_dataType
)
:
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_format
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
fmt
)
;
this
.
m_texture
=
this
.
m_dataType
?
gluTexture
.
texture2DFromFormat
(
gl
this
.
m_format
this
.
m_dataType
this
.
m_width
this
.
m_height
)
:
gluTexture
.
texture2DFromInternalFormat
(
gl
this
.
m_format
this
.
m_width
this
.
m_height
)
;
this
.
m_texture
.
getRefTexture
(
)
.
allocLevel
(
0
)
;
tcuTextureUtil
.
fillWithComponentGradients
(
this
.
m_texture
.
getRefTexture
(
)
.
getLevel
(
0
)
spec
.
valueMin
spec
.
valueMax
)
;
}
;
es3fTextureFormatTests
.
Texture2DFormatCase
.
prototype
.
deinit
=
function
(
)
{
}
;
es3fTextureFormatTests
.
Texture2DFormatCase
.
prototype
.
iterate
=
function
(
)
{
var
viewport
=
new
glsTextureTestUtil
.
RandomViewport
(
document
.
getElementById
(
'
canvas
'
)
this
.
m_width
this
.
m_height
)
;
var
renderedFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
referenceFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
threshold
=
[
3
3
3
3
]
;
var
renderParams
=
new
glsTextureTestUtil
.
ReferenceParams
(
glsTextureTestUtil
.
textureType
.
TEXTURETYPE_2D
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
var
wrapS
=
gl
.
CLAMP_TO_EDGE
;
var
wrapT
=
gl
.
CLAMP_TO_EDGE
;
var
minFilter
=
gl
.
NEAREST
;
var
magFilter
=
gl
.
NEAREST
;
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
renderParams
.
samplerType
=
glsTextureTestUtil
.
getSamplerType
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
renderParams
.
sampler
=
new
tcuTexture
.
Sampler
(
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
FilterMode
.
NEAREST
tcuTexture
.
FilterMode
.
NEAREST
)
;
renderParams
.
colorScale
=
spec
.
lookupScale
;
renderParams
.
colorBias
=
spec
.
lookupBias
;
var
texCoord
=
glsTextureTestUtil
.
computeQuadTexCoord2D
(
[
0
0
]
[
1
1
]
)
;
gl
.
viewport
(
viewport
.
x
viewport
.
y
viewport
.
width
viewport
.
height
)
;
this
.
m_texture
.
upload
(
)
;
gl
.
activeTexture
(
gl
.
TEXTURE0
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
wrapS
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
wrapT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
minFilter
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
magFilter
)
;
this
.
m_renderer
.
renderQuad
(
0
texCoord
renderParams
)
;
renderedFrame
.
readViewport
(
gl
viewport
)
;
glsTextureTestUtil
.
sampleTexture2D
(
new
glsTextureTestUtil
.
SurfaceAccess
(
referenceFrame
undefined
)
this
.
m_texture
.
getRefTexture
(
)
texCoord
renderParams
)
;
var
isOk
=
glsTextureTestUtil
.
compareImages
(
referenceFrame
renderedFrame
threshold
)
;
assertMsgOptions
(
isOk
es3fTextureFormatTests
.
testDescription
(
)
true
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fTextureFormatTests
.
TextureCubeFormatCase
=
function
(
descriptor
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
descriptor
.
name
descriptor
.
description
)
;
this
.
m_format
=
descriptor
.
format
;
this
.
m_dataType
=
descriptor
.
dataType
;
this
.
m_width
=
descriptor
.
width
;
this
.
m_height
=
descriptor
.
height
;
this
.
m_renderer
=
new
glsTextureTestUtil
.
TextureRenderer
(
es3fTextureFormatTests
.
version
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
DE_ASSERT
(
this
.
m_width
=
=
this
.
m_height
)
;
}
;
es3fTextureFormatTests
.
setParentClass
(
es3fTextureFormatTests
.
TextureCubeFormatCase
tcuTestCase
.
DeqpTest
)
;
es3fTextureFormatTests
.
TextureCubeFormatCase
.
prototype
.
init
=
function
(
)
{
var
fmt
=
this
.
m_dataType
?
gluTextureUtil
.
mapGLTransferFormat
(
this
.
m_format
this
.
m_dataType
)
:
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_format
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
fmt
)
;
this
.
m_texture
=
this
.
m_dataType
?
gluTexture
.
cubeFromFormat
(
gl
this
.
m_format
this
.
m_dataType
this
.
m_width
)
:
gluTexture
.
cubeFromInternalFormat
(
gl
this
.
m_format
this
.
m_width
)
;
for
(
var
face
in
tcuTexture
.
CubeFace
)
{
var
gMin
=
null
;
var
gMax
=
null
;
switch
(
tcuTexture
.
CubeFace
[
face
]
)
{
case
0
:
gMin
=
deMath
.
swizzle
(
spec
.
valueMin
[
0
1
2
3
]
)
;
gMax
=
deMath
.
swizzle
(
spec
.
valueMax
[
0
1
2
3
]
)
;
break
;
case
1
:
gMin
=
deMath
.
swizzle
(
spec
.
valueMin
[
2
1
0
3
]
)
;
gMax
=
deMath
.
swizzle
(
spec
.
valueMax
[
2
1
0
3
]
)
;
break
;
case
2
:
gMin
=
deMath
.
swizzle
(
spec
.
valueMin
[
1
2
0
3
]
)
;
gMax
=
deMath
.
swizzle
(
spec
.
valueMax
[
1
2
0
3
]
)
;
break
;
case
3
:
gMin
=
deMath
.
swizzle
(
spec
.
valueMax
[
0
1
2
3
]
)
;
gMax
=
deMath
.
swizzle
(
spec
.
valueMin
[
0
1
2
3
]
)
;
break
;
case
4
:
gMin
=
deMath
.
swizzle
(
spec
.
valueMax
[
2
1
0
3
]
)
;
gMax
=
deMath
.
swizzle
(
spec
.
valueMin
[
2
1
0
3
]
)
;
break
;
case
5
:
gMin
=
deMath
.
swizzle
(
spec
.
valueMax
[
1
2
0
3
]
)
;
gMax
=
deMath
.
swizzle
(
spec
.
valueMin
[
1
2
0
3
]
)
;
break
;
default
:
DE_ASSERT
(
false
)
;
}
this
.
m_texture
.
getRefTexture
(
)
.
allocLevel
(
tcuTexture
.
CubeFace
[
face
]
0
)
;
tcuTextureUtil
.
fillWithComponentGradients
(
this
.
m_texture
.
getRefTexture
(
)
.
getLevelFace
(
0
tcuTexture
.
CubeFace
[
face
]
)
gMin
gMax
)
;
}
this
.
m_texture
.
upload
(
)
;
this
.
m_curFace
=
0
;
this
.
m_isOk
=
true
;
}
;
es3fTextureFormatTests
.
TextureCubeFormatCase
.
prototype
.
testFace
=
function
(
face
)
{
var
viewport
=
new
glsTextureTestUtil
.
RandomViewport
(
document
.
getElementById
(
'
canvas
'
)
this
.
m_width
this
.
m_height
)
;
var
renderedFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
referenceFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
threshold
=
[
3
3
3
3
]
;
var
renderParams
=
new
glsTextureTestUtil
.
ReferenceParams
(
glsTextureTestUtil
.
textureType
.
TEXTURETYPE_CUBE
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
var
wrapS
=
gl
.
CLAMP_TO_EDGE
;
var
wrapT
=
gl
.
CLAMP_TO_EDGE
;
var
minFilter
=
gl
.
NEAREST
;
var
magFilter
=
gl
.
NEAREST
;
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
renderParams
.
samplerType
=
glsTextureTestUtil
.
getSamplerType
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
renderParams
.
sampler
=
new
tcuTexture
.
Sampler
(
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
FilterMode
.
NEAREST
tcuTexture
.
FilterMode
.
NEAREST
)
;
renderParams
.
colorScale
=
spec
.
lookupScale
;
renderParams
.
colorBias
=
spec
.
lookupBias
;
if
(
face
=
=
=
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_X
)
{
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
}
var
texCoord
=
glsTextureTestUtil
.
computeQuadTexCoordCube
(
face
)
;
gl
.
viewport
(
viewport
.
x
viewport
.
y
viewport
.
width
viewport
.
height
)
;
gl
.
activeTexture
(
gl
.
TEXTURE0
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_CUBE_MAP
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_WRAP_S
wrapS
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_WRAP_T
wrapT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_MIN_FILTER
minFilter
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_MAG_FILTER
magFilter
)
;
this
.
m_renderer
.
renderQuad
(
0
texCoord
renderParams
)
;
renderedFrame
.
readViewport
(
gl
viewport
)
;
glsTextureTestUtil
.
sampleTextureCube
(
new
glsTextureTestUtil
.
SurfaceAccess
(
referenceFrame
undefined
)
this
.
m_texture
.
getRefTexture
(
)
texCoord
renderParams
)
;
var
skipPixels
=
null
;
if
(
renderParams
.
samplerType
=
=
glsTextureTestUtil
.
samplerType
.
SAMPLERTYPE_INT
|
|
renderParams
.
samplerType
=
=
glsTextureTestUtil
.
samplerType
.
SAMPLERTYPE_UINT
)
{
skipPixels
=
[
[
this
.
m_width
-
1
this
.
m_height
-
1
]
]
;
}
var
isOk
=
glsTextureTestUtil
.
compareImages
(
referenceFrame
renderedFrame
threshold
skipPixels
)
;
assertMsgOptions
(
isOk
'
Face
:
'
+
this
.
m_curFace
+
'
'
+
es3fTextureFormatTests
.
testDescription
(
)
true
false
)
;
return
isOk
;
}
;
es3fTextureFormatTests
.
TextureCubeFormatCase
.
prototype
.
iterate
=
function
(
)
{
debug
(
'
Testing
face
'
+
this
.
m_curFace
)
;
if
(
!
this
.
testFace
(
this
.
m_curFace
)
)
this
.
m_isOk
=
false
;
this
.
m_curFace
+
=
1
;
if
(
this
.
m_curFace
<
Object
.
keys
(
tcuTexture
.
CubeFace
)
.
length
)
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
else
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fTextureFormatTests
.
Texture2DArrayFormatCase
=
function
(
descriptor
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
descriptor
.
name
descriptor
.
description
)
;
this
.
m_format
=
descriptor
.
format
;
this
.
m_dataType
=
descriptor
.
dataType
;
this
.
m_width
=
descriptor
.
width
;
this
.
m_height
=
descriptor
.
height
;
this
.
m_numLayers
=
descriptor
.
numLayers
;
this
.
m_renderer
=
new
glsTextureTestUtil
.
TextureRenderer
(
es3fTextureFormatTests
.
version
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
}
;
es3fTextureFormatTests
.
setParentClass
(
es3fTextureFormatTests
.
Texture2DArrayFormatCase
tcuTestCase
.
DeqpTest
)
;
es3fTextureFormatTests
.
Texture2DArrayFormatCase
.
prototype
.
init
=
function
(
)
{
var
fmt
=
this
.
m_dataType
?
gluTextureUtil
.
mapGLTransferFormat
(
this
.
m_format
this
.
m_dataType
)
:
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_format
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
fmt
)
;
this
.
m_texture
=
this
.
m_dataType
?
gluTexture
.
texture2DArrayFromFormat
(
gl
this
.
m_format
this
.
m_dataType
this
.
m_width
this
.
m_height
this
.
m_numLayers
)
:
gluTexture
.
texture2DArrayFromInternalFormat
(
gl
this
.
m_format
this
.
m_width
this
.
m_height
this
.
m_numLayers
)
;
this
.
m_texture
.
getRefTexture
(
)
.
allocLevel
(
0
)
;
tcuTextureUtil
.
fillWithComponentGradients
(
this
.
m_texture
.
getRefTexture
(
)
.
getLevel
(
0
)
spec
.
valueMin
spec
.
valueMax
)
;
this
.
m_curLayer
=
0
;
this
.
m_isOk
=
true
;
}
;
es3fTextureFormatTests
.
Texture2DArrayFormatCase
.
prototype
.
testLayer
=
function
(
layerNdx
)
{
var
viewport
=
new
glsTextureTestUtil
.
RandomViewport
(
document
.
getElementById
(
'
canvas
'
)
this
.
m_width
this
.
m_height
)
;
var
renderedFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
referenceFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
threshold
=
[
3
3
3
3
]
;
var
renderParams
=
new
glsTextureTestUtil
.
ReferenceParams
(
glsTextureTestUtil
.
textureType
.
TEXTURETYPE_2D_ARRAY
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
var
wrapS
=
gl
.
CLAMP_TO_EDGE
;
var
wrapT
=
gl
.
CLAMP_TO_EDGE
;
var
minFilter
=
gl
.
NEAREST
;
var
magFilter
=
gl
.
NEAREST
;
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
renderParams
.
samplerType
=
glsTextureTestUtil
.
getSamplerType
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
renderParams
.
sampler
=
new
tcuTexture
.
Sampler
(
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
FilterMode
.
NEAREST
tcuTexture
.
FilterMode
.
NEAREST
)
;
renderParams
.
colorScale
=
spec
.
lookupScale
;
renderParams
.
colorBias
=
spec
.
lookupBias
;
var
texCoord
=
glsTextureTestUtil
.
computeQuadTexCoord2DArray
(
layerNdx
[
0
0
]
[
1
1
]
)
;
gl
.
viewport
(
viewport
.
x
viewport
.
y
viewport
.
width
viewport
.
height
)
;
this
.
m_texture
.
upload
(
)
;
gl
.
activeTexture
(
gl
.
TEXTURE0
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D_ARRAY
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D_ARRAY
gl
.
TEXTURE_WRAP_S
wrapS
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D_ARRAY
gl
.
TEXTURE_WRAP_T
wrapT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D_ARRAY
gl
.
TEXTURE_MIN_FILTER
minFilter
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D_ARRAY
gl
.
TEXTURE_MAG_FILTER
magFilter
)
;
this
.
m_renderer
.
renderQuad
(
0
texCoord
renderParams
)
;
renderedFrame
.
readViewport
(
gl
viewport
)
;
glsTextureTestUtil
.
sampleTexture2DArray
(
new
glsTextureTestUtil
.
SurfaceAccess
(
referenceFrame
undefined
)
this
.
m_texture
.
getRefTexture
(
)
.
getView
(
)
texCoord
renderParams
)
;
var
isOk
=
glsTextureTestUtil
.
compareImages
(
referenceFrame
renderedFrame
threshold
)
;
assertMsgOptions
(
isOk
'
Layer
:
'
+
this
.
m_curLayer
+
'
'
+
es3fTextureFormatTests
.
testDescription
(
)
true
false
)
;
return
isOk
;
}
;
es3fTextureFormatTests
.
Texture2DArrayFormatCase
.
prototype
.
iterate
=
function
(
)
{
debug
(
'
Testing
layer
'
+
this
.
m_curLayer
)
;
if
(
!
this
.
testLayer
(
this
.
m_curLayer
)
)
this
.
m_isOk
=
false
;
this
.
m_curLayer
+
=
1
;
if
(
this
.
m_curLayer
=
=
this
.
m_numLayers
)
return
tcuTestCase
.
IterateResult
.
STOP
;
else
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
}
;
es3fTextureFormatTests
.
Texture3DFormatCase
=
function
(
descriptor
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
descriptor
.
name
descriptor
.
description
)
;
this
.
m_format
=
descriptor
.
format
;
this
.
m_dataType
=
descriptor
.
dataType
;
this
.
m_width
=
descriptor
.
width
;
this
.
m_height
=
descriptor
.
height
;
this
.
m_depth
=
descriptor
.
depth
;
this
.
m_renderer
=
new
glsTextureTestUtil
.
TextureRenderer
(
es3fTextureFormatTests
.
version
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
}
;
es3fTextureFormatTests
.
setParentClass
(
es3fTextureFormatTests
.
Texture3DFormatCase
tcuTestCase
.
DeqpTest
)
;
es3fTextureFormatTests
.
Texture3DFormatCase
.
prototype
.
init
=
function
(
)
{
var
fmt
=
this
.
m_dataType
?
gluTextureUtil
.
mapGLTransferFormat
(
this
.
m_format
this
.
m_dataType
)
:
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_format
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
fmt
)
;
this
.
m_texture
=
this
.
m_dataType
?
gluTexture
.
texture3DFromFormat
(
gl
this
.
m_format
this
.
m_dataType
this
.
m_width
this
.
m_height
this
.
m_depth
)
:
gluTexture
.
texture3DFromInternalFormat
(
gl
this
.
m_format
this
.
m_width
this
.
m_height
this
.
m_depth
)
;
this
.
m_texture
.
getRefTexture
(
)
.
allocLevel
(
0
)
;
tcuTextureUtil
.
fillWithComponentGradients
(
this
.
m_texture
.
getRefTexture
(
)
.
getLevel
(
0
)
spec
.
valueMin
spec
.
valueMax
)
;
this
.
m_curSlice
=
0
;
this
.
m_isOk
=
true
;
}
;
es3fTextureFormatTests
.
Texture3DFormatCase
.
prototype
.
testSlice
=
function
(
sliceNdx
)
{
var
viewport
=
new
glsTextureTestUtil
.
RandomViewport
(
document
.
getElementById
(
'
canvas
'
)
this
.
m_width
this
.
m_height
)
;
var
renderedFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
referenceFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
threshold
=
[
3
3
3
3
]
;
var
renderParams
=
new
glsTextureTestUtil
.
ReferenceParams
(
glsTextureTestUtil
.
textureType
.
TEXTURETYPE_3D
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
var
r
=
(
sliceNdx
+
0
.
5
)
/
this
.
m_depth
;
var
wrapS
=
gl
.
CLAMP_TO_EDGE
;
var
wrapT
=
gl
.
CLAMP_TO_EDGE
;
var
minFilter
=
gl
.
NEAREST
;
var
magFilter
=
gl
.
NEAREST
;
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
renderParams
.
samplerType
=
glsTextureTestUtil
.
getSamplerType
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
renderParams
.
sampler
=
new
tcuTexture
.
Sampler
(
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
FilterMode
.
NEAREST
tcuTexture
.
FilterMode
.
NEAREST
)
;
renderParams
.
colorScale
=
spec
.
lookupScale
;
renderParams
.
colorBias
=
spec
.
lookupBias
;
var
texCoord
=
glsTextureTestUtil
.
computeQuadTexCoord3D
(
[
0
0
r
]
[
1
1
r
]
[
0
1
2
]
)
;
gl
.
viewport
(
viewport
.
x
viewport
.
y
viewport
.
width
viewport
.
height
)
;
this
.
m_texture
.
upload
(
)
;
gl
.
activeTexture
(
gl
.
TEXTURE0
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_3D
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_3D
gl
.
TEXTURE_WRAP_S
wrapS
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_3D
gl
.
TEXTURE_WRAP_T
wrapT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_3D
gl
.
TEXTURE_MIN_FILTER
minFilter
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_3D
gl
.
TEXTURE_MAG_FILTER
magFilter
)
;
this
.
m_renderer
.
renderQuad
(
0
texCoord
renderParams
)
;
renderedFrame
.
readViewport
(
gl
viewport
)
;
glsTextureTestUtil
.
sampleTexture3D
(
new
glsTextureTestUtil
.
SurfaceAccess
(
referenceFrame
undefined
)
this
.
m_texture
.
getRefTexture
(
)
texCoord
renderParams
)
;
var
isOk
=
glsTextureTestUtil
.
compareImages
(
referenceFrame
renderedFrame
threshold
)
;
assertMsgOptions
(
isOk
'
Slice
:
'
+
this
.
m_curSlice
+
'
'
+
es3fTextureFormatTests
.
testDescription
(
)
true
false
)
;
return
isOk
;
}
;
es3fTextureFormatTests
.
Texture3DFormatCase
.
prototype
.
iterate
=
function
(
)
{
debug
(
'
Testing
slice
'
+
this
.
m_curSlice
)
;
if
(
!
this
.
testSlice
(
this
.
m_curSlice
)
)
this
.
m_isOk
=
false
;
this
.
m_curSlice
+
=
1
;
if
(
this
.
m_curSlice
>
=
this
.
m_depth
)
return
tcuTestCase
.
IterateResult
.
STOP
;
else
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
}
;
es3fTextureFormatTests
.
Compressed2DFormatCase
=
function
(
descriptor
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
descriptor
.
name
descriptor
.
description
)
;
this
.
m_format
=
descriptor
.
format
;
this
.
m_dataType
=
descriptor
.
dataType
;
this
.
m_width
=
descriptor
.
width
;
this
.
m_height
=
descriptor
.
height
;
this
.
m_renderer
=
new
glsTextureTestUtil
.
TextureRenderer
(
es3fTextureFormatTests
.
version
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
}
;
es3fTextureFormatTests
.
setParentClass
(
es3fTextureFormatTests
.
Compressed2DFormatCase
tcuTestCase
.
DeqpTest
)
;
es3fTextureFormatTests
.
Compressed2DFormatCase
.
prototype
.
init
=
function
(
)
{
var
compressed
=
new
tcuCompressedTexture
.
CompressedTexture
(
this
.
m_format
this
.
m_width
this
.
m_height
)
;
var
rand
=
new
deRandom
.
Random
(
0
)
;
for
(
var
i
=
0
;
i
<
compressed
.
m_data
.
length
;
i
+
+
)
{
compressed
.
m_data
[
i
]
=
rand
.
getInt
(
0
255
)
;
}
this
.
m_texture
=
gluTexture
.
compressed2DFromInternalFormat
(
gl
this
.
m_format
this
.
m_width
this
.
m_height
compressed
)
;
}
;
es3fTextureFormatTests
.
Compressed2DFormatCase
.
prototype
.
deinit
=
function
(
)
{
}
;
es3fTextureFormatTests
.
Compressed2DFormatCase
.
prototype
.
iterate
=
function
(
)
{
var
viewport
=
new
glsTextureTestUtil
.
RandomViewport
(
document
.
getElementById
(
'
canvas
'
)
this
.
m_width
this
.
m_height
)
;
var
renderedFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
referenceFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
threshold
=
[
3
3
3
3
]
;
var
renderParams
=
new
glsTextureTestUtil
.
ReferenceParams
(
glsTextureTestUtil
.
textureType
.
TEXTURETYPE_2D
)
;
var
spec
=
tcuTextureUtil
.
getTextureFormatInfo
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
var
wrapS
=
gl
.
CLAMP_TO_EDGE
;
var
wrapT
=
gl
.
CLAMP_TO_EDGE
;
var
minFilter
=
gl
.
NEAREST
;
var
magFilter
=
gl
.
NEAREST
;
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
renderParams
.
samplerType
=
glsTextureTestUtil
.
getSamplerType
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
renderParams
.
sampler
=
new
tcuTexture
.
Sampler
(
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
FilterMode
.
NEAREST
tcuTexture
.
FilterMode
.
NEAREST
)
;
renderParams
.
colorScale
=
spec
.
lookupScale
;
renderParams
.
colorBias
=
spec
.
lookupBias
;
var
texCoord
=
glsTextureTestUtil
.
computeQuadTexCoord2D
(
[
0
0
]
[
1
1
]
)
;
gl
.
viewport
(
viewport
.
x
viewport
.
y
viewport
.
width
viewport
.
height
)
;
gl
.
activeTexture
(
gl
.
TEXTURE0
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
wrapS
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
wrapT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
minFilter
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
magFilter
)
;
this
.
m_renderer
.
renderQuad
(
0
texCoord
renderParams
)
;
renderedFrame
.
readViewport
(
gl
viewport
)
;
glsTextureTestUtil
.
sampleTexture2D
(
new
glsTextureTestUtil
.
SurfaceAccess
(
referenceFrame
undefined
)
this
.
m_texture
.
getRefTexture
(
)
texCoord
renderParams
)
;
var
isOk
=
glsTextureTestUtil
.
compareImages
(
referenceFrame
renderedFrame
threshold
)
;
assertMsgOptions
(
isOk
es3fTextureFormatTests
.
testDescription
(
)
true
false
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fTextureFormatTests
.
CompressedCubeFormatCase
=
function
(
descriptor
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
descriptor
.
name
descriptor
.
description
)
;
this
.
m_format
=
descriptor
.
format
;
this
.
m_dataType
=
descriptor
.
dataType
;
this
.
m_width
=
descriptor
.
width
;
this
.
m_height
=
descriptor
.
height
;
this
.
m_renderer
=
new
glsTextureTestUtil
.
TextureRenderer
(
es3fTextureFormatTests
.
version
gluShaderUtil
.
precision
.
PRECISION_HIGHP
)
;
this
.
m_curFace
=
0
;
this
.
m_isOk
=
true
;
DE_ASSERT
(
this
.
m_width
=
=
this
.
m_height
)
;
}
;
es3fTextureFormatTests
.
setParentClass
(
es3fTextureFormatTests
.
CompressedCubeFormatCase
tcuTestCase
.
DeqpTest
)
;
es3fTextureFormatTests
.
CompressedCubeFormatCase
.
prototype
.
init
=
function
(
)
{
var
compressed
=
new
tcuCompressedTexture
.
CompressedTexture
(
this
.
m_format
this
.
m_width
this
.
m_height
)
;
var
rand
=
new
deRandom
.
Random
(
0
)
;
for
(
var
i
=
0
;
i
<
compressed
.
m_data
.
length
;
i
+
+
)
{
compressed
.
m_data
[
i
]
=
rand
.
getInt
(
0
255
)
;
}
this
.
m_texture
=
gluTexture
.
compressedCubeFromInternalFormat
(
gl
this
.
m_format
this
.
m_width
compressed
)
;
}
;
es3fTextureFormatTests
.
CompressedCubeFormatCase
.
prototype
.
testFace
=
function
(
face
)
{
var
viewport
=
new
glsTextureTestUtil
.
RandomViewport
(
document
.
getElementById
(
'
canvas
'
)
this
.
m_width
this
.
m_height
)
;
var
renderedFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
referenceFrame
=
new
tcuSurface
.
Surface
(
viewport
.
width
viewport
.
height
)
;
var
threshold
=
[
6
6
6
6
]
;
var
renderParams
=
new
glsTextureTestUtil
.
ReferenceParams
(
glsTextureTestUtil
.
textureType
.
TEXTURETYPE_CUBE
)
;
var
wrapS
=
gl
.
CLAMP_TO_EDGE
;
var
wrapT
=
gl
.
CLAMP_TO_EDGE
;
var
minFilter
=
gl
.
NEAREST
;
var
magFilter
=
gl
.
NEAREST
;
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
renderParams
.
samplerType
=
glsTextureTestUtil
.
getSamplerType
(
this
.
m_texture
.
getRefTexture
(
)
.
getFormat
(
)
)
;
renderParams
.
sampler
=
new
tcuTexture
.
Sampler
(
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
tcuTexture
.
FilterMode
.
NEAREST
tcuTexture
.
FilterMode
.
NEAREST
)
;
if
(
face
=
=
=
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_X
)
{
renderParams
.
flags
.
log_programs
=
true
;
renderParams
.
flags
.
log_uniforms
=
true
;
}
var
texCoord
=
glsTextureTestUtil
.
computeQuadTexCoordCube
(
face
)
;
gl
.
viewport
(
viewport
.
x
viewport
.
y
viewport
.
width
viewport
.
height
)
;
gl
.
activeTexture
(
gl
.
TEXTURE0
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_CUBE_MAP
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_WRAP_S
wrapS
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_WRAP_T
wrapT
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_MIN_FILTER
minFilter
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_CUBE_MAP
gl
.
TEXTURE_MAG_FILTER
magFilter
)
;
this
.
m_renderer
.
renderQuad
(
0
texCoord
renderParams
)
;
renderedFrame
.
readViewport
(
gl
viewport
)
;
glsTextureTestUtil
.
sampleTextureCube
(
new
glsTextureTestUtil
.
SurfaceAccess
(
referenceFrame
undefined
)
this
.
m_texture
.
getRefTexture
(
)
texCoord
renderParams
)
;
var
isOk
=
glsTextureTestUtil
.
compareImages
(
referenceFrame
renderedFrame
threshold
)
;
assertMsgOptions
(
isOk
'
Face
:
'
+
this
.
m_curFace
+
'
'
+
es3fTextureFormatTests
.
testDescription
(
)
true
false
)
;
return
isOk
;
}
;
es3fTextureFormatTests
.
CompressedCubeFormatCase
.
prototype
.
iterate
=
function
(
)
{
debug
(
'
Testing
face
'
+
this
.
m_curFace
)
;
if
(
!
this
.
testFace
(
this
.
m_curFace
)
)
this
.
m_isOk
=
false
;
this
.
m_curFace
+
=
1
;
if
(
this
.
m_curFace
<
Object
.
keys
(
tcuTexture
.
CubeFace
)
.
length
)
return
tcuTestCase
.
IterateResult
.
CONTINUE
;
else
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fTextureFormatTests
.
genTestCases
=
function
(
)
{
var
state
=
tcuTestCase
.
runner
;
state
.
setRoot
(
tcuTestCase
.
newTest
(
'
texture_format
'
'
Top
level
'
)
)
;
var
texFormats
=
[
[
'
alpha
'
gl
.
ALPHA
gl
.
UNSIGNED_BYTE
]
[
'
luminance
'
gl
.
LUMINANCE
gl
.
UNSIGNED_BYTE
]
[
'
luminance_alpha
'
gl
.
LUMINANCE_ALPHA
gl
.
UNSIGNED_BYTE
]
[
'
rgb_unsigned_short_5_6_5
'
gl
.
RGB
gl
.
UNSIGNED_SHORT_5_6_5
]
[
'
rgb_unsigned_byte
'
gl
.
RGB
gl
.
UNSIGNED_BYTE
]
[
'
rgba_unsigned_short_4_4_4_4
'
gl
.
RGBA
gl
.
UNSIGNED_SHORT_4_4_4_4
]
[
'
rgba_unsigned_short_5_5_5_1
'
gl
.
RGBA
gl
.
UNSIGNED_SHORT_5_5_5_1
]
[
'
rgba_unsigned_byte
'
gl
.
RGBA
gl
.
UNSIGNED_BYTE
]
]
;
var
unsized2DGroup
=
tcuTestCase
.
newTest
(
'
unsized
'
'
Unsized
formats
(
2D
Cubemap
)
'
)
;
state
.
testCases
.
addChild
(
unsized2DGroup
)
;
var
unsized2DArrayGroup
=
tcuTestCase
.
newTest
(
'
unsized
'
'
Unsized
formats
(
2D
Array
)
'
)
;
state
.
testCases
.
addChild
(
unsized2DArrayGroup
)
;
var
unsized3DGroup
=
tcuTestCase
.
newTest
(
'
unsized
'
'
Unsized
formats
(
3D
)
'
)
;
state
.
testCases
.
addChild
(
unsized3DGroup
)
;
texFormats
.
forEach
(
function
(
elem
)
{
var
format
=
elem
[
1
]
;
var
dataType
=
elem
[
2
]
;
var
nameBase
=
elem
[
0
]
;
var
descriptionBase
=
gluStrUtil
.
getPixelFormatName
(
format
)
+
'
'
+
gluStrUtil
.
getTypeName
(
dataType
)
;
unsized2DGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DFormatCase
(
{
name
:
nameBase
+
'
_2d_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
format
dataType
:
dataType
width
:
128
height
:
128
}
)
)
;
unsized2DGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DFormatCase
(
{
name
:
nameBase
+
'
_2d_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
format
dataType
:
dataType
width
:
63
height
:
112
}
)
)
;
unsized2DGroup
.
addChild
(
new
es3fTextureFormatTests
.
TextureCubeFormatCase
(
{
name
:
nameBase
+
'
_cube_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
format
dataType
:
dataType
width
:
64
height
:
64
}
)
)
;
unsized2DGroup
.
addChild
(
new
es3fTextureFormatTests
.
TextureCubeFormatCase
(
{
name
:
nameBase
+
'
_cube_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
format
dataType
:
dataType
width
:
57
height
:
57
}
)
)
;
unsized2DArrayGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DArrayFormatCase
(
{
name
:
nameBase
+
'
_2d_array_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D_ARRAY
'
format
:
format
dataType
:
dataType
width
:
64
height
:
64
numLayers
:
8
}
)
)
;
unsized2DArrayGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DArrayFormatCase
(
{
name
:
nameBase
+
'
_2d_array_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D_ARRAY
'
format
:
format
dataType
:
dataType
width
:
63
height
:
57
numLayers
:
7
}
)
)
;
unsized3DGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture3DFormatCase
(
{
name
:
nameBase
+
'
_3d_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_3D
'
format
:
format
dataType
:
dataType
width
:
8
height
:
32
depth
:
16
}
)
)
;
unsized3DGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture3DFormatCase
(
{
name
:
nameBase
+
'
_3d_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_3D
'
format
:
format
dataType
:
dataType
width
:
11
height
:
31
depth
:
7
}
)
)
;
}
)
;
var
sizedColorFormats
=
[
[
'
rgba32f
'
gl
.
RGBA32F
]
[
'
rgba32i
'
gl
.
RGBA32I
]
[
'
rgba32ui
'
gl
.
RGBA32UI
]
[
'
rgba16f
'
gl
.
RGBA16F
]
[
'
rgba16i
'
gl
.
RGBA16I
]
[
'
rgba16ui
'
gl
.
RGBA16UI
]
[
'
rgba8
'
gl
.
RGBA8
]
[
'
rgba8i
'
gl
.
RGBA8I
]
[
'
rgba8ui
'
gl
.
RGBA8UI
]
[
'
srgb8_alpha8
'
gl
.
SRGB8_ALPHA8
]
[
'
rgb10_a2
'
gl
.
RGB10_A2
]
[
'
rgb10_a2ui
'
gl
.
RGB10_A2UI
]
[
'
rgba4
'
gl
.
RGBA4
]
[
'
rgb5_a1
'
gl
.
RGB5_A1
]
[
'
rgba8_snorm
'
gl
.
RGBA8_SNORM
]
[
'
rgb8
'
gl
.
RGB8
]
[
'
rgb565
'
gl
.
RGB565
]
[
'
r11f_g11f_b10f
'
gl
.
R11F_G11F_B10F
]
[
'
rgb32f
'
gl
.
RGB32F
]
[
'
rgb32i
'
gl
.
RGB32I
]
[
'
rgb32ui
'
gl
.
RGB32UI
]
[
'
rgb16f
'
gl
.
RGB16F
]
[
'
rgb16i
'
gl
.
RGB16I
]
[
'
rgb16ui
'
gl
.
RGB16UI
]
[
'
rgb8_snorm
'
gl
.
RGB8_SNORM
]
[
'
rgb8i
'
gl
.
RGB8I
]
[
'
rgb8ui
'
gl
.
RGB8UI
]
[
'
srgb8
'
gl
.
SRGB8
]
[
'
rgb9_e5
'
gl
.
RGB9_E5
]
[
'
rg32f
'
gl
.
RG32F
]
[
'
rg32i
'
gl
.
RG32I
]
[
'
rg32ui
'
gl
.
RG32UI
]
[
'
rg16f
'
gl
.
RG16F
]
[
'
rg16i
'
gl
.
RG16I
]
[
'
rg16ui
'
gl
.
RG16UI
]
[
'
rg8
'
gl
.
RG8
]
[
'
rg8i
'
gl
.
RG8I
]
[
'
rg8ui
'
gl
.
RG8UI
]
[
'
rg8_snorm
'
gl
.
RG8_SNORM
]
[
'
r32f
'
gl
.
R32F
]
[
'
r32i
'
gl
.
R32I
]
[
'
r32ui
'
gl
.
R32UI
]
[
'
r16f
'
gl
.
R16F
]
[
'
r16i
'
gl
.
R16I
]
[
'
r16ui
'
gl
.
R16UI
]
[
'
r8
'
gl
.
R8
]
[
'
r8i
'
gl
.
R8I
]
[
'
r8ui
'
gl
.
R8UI
]
[
'
r8_snorm
'
gl
.
R8_SNORM
]
]
;
var
splitSizedColorTests
=
4
;
var
sizedColor2DPOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColor2DPOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
2D
POT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColor2DPOTGroup
[
ii
]
)
;
}
var
sizedColor2DNPOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColor2DNPOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
2D
NPOT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColor2DNPOTGroup
[
ii
]
)
;
}
var
sizedColorCubePOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColorCubePOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
Cubemap
POT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColorCubePOTGroup
[
ii
]
)
;
}
var
sizedColorCubeNPOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColorCubeNPOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
Cubemap
NPOT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColorCubeNPOTGroup
[
ii
]
)
;
}
var
sizedColor2DArrayPOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColor2DArrayPOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
2D
Array
POT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColor2DArrayPOTGroup
[
ii
]
)
;
}
var
sizedColor2DArrayNPOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColor2DArrayNPOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
2D
Array
NPOT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColor2DArrayNPOTGroup
[
ii
]
)
;
}
var
sizedColor3DPOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColor3DPOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
3D
POT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColor3DPOTGroup
[
ii
]
)
;
}
var
sizedColor3DNPOTGroup
=
[
]
;
for
(
var
ii
=
0
;
ii
<
splitSizedColorTests
;
+
+
ii
)
{
sizedColor3DNPOTGroup
.
push
(
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
3D
NPOT
)
'
)
)
;
state
.
testCases
.
addChild
(
sizedColor3DNPOTGroup
[
ii
]
)
;
}
for
(
var
ii
=
0
;
ii
<
sizedColorFormats
.
length
;
+
+
ii
)
{
var
internalFormat
=
sizedColorFormats
[
ii
]
[
1
]
;
var
nameBase
=
sizedColorFormats
[
ii
]
[
0
]
;
var
descriptionBase
=
gluStrUtil
.
getPixelFormatName
(
internalFormat
)
;
sizedColor2DPOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DFormatCase
(
{
name
:
nameBase
+
'
_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
internalFormat
width
:
128
height
:
128
}
)
)
;
sizedColor2DNPOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DFormatCase
(
{
name
:
nameBase
+
'
_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
internalFormat
width
:
63
height
:
112
}
)
)
;
sizedColorCubePOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
TextureCubeFormatCase
(
{
name
:
nameBase
+
'
_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
internalFormat
width
:
64
height
:
64
}
)
)
;
sizedColorCubeNPOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
TextureCubeFormatCase
(
{
name
:
nameBase
+
'
_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
internalFormat
width
:
57
height
:
57
}
)
)
;
sizedColor2DArrayPOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DArrayFormatCase
(
{
name
:
nameBase
+
'
_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D_ARRAY
'
format
:
internalFormat
width
:
64
height
:
64
numLayers
:
8
}
)
)
;
sizedColor2DArrayNPOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DArrayFormatCase
(
{
name
:
nameBase
+
'
_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D_ARRAY
'
format
:
internalFormat
width
:
63
height
:
57
numLayers
:
7
}
)
)
;
sizedColor3DPOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
Texture3DFormatCase
(
{
name
:
nameBase
+
'
_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_3D
'
format
:
internalFormat
width
:
8
height
:
32
depth
:
16
}
)
)
;
sizedColor3DNPOTGroup
[
ii
%
splitSizedColorTests
]
.
addChild
(
new
es3fTextureFormatTests
.
Texture3DFormatCase
(
{
name
:
nameBase
+
'
_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_3D
'
format
:
internalFormat
width
:
11
height
:
31
depth
:
7
}
)
)
;
}
var
sizedDepthStencilFormats
=
[
[
'
depth_component32f
'
gl
.
DEPTH_COMPONENT32F
]
[
'
depth_component24
'
gl
.
DEPTH_COMPONENT24
]
[
'
depth_component16
'
gl
.
DEPTH_COMPONENT16
]
[
'
depth24_stencil8
'
gl
.
DEPTH24_STENCIL8
]
]
;
var
sizedDepthStencilGroup
=
tcuTestCase
.
newTest
(
'
sized
'
'
Sized
formats
(
Depth
Stencil
)
'
)
;
state
.
testCases
.
addChild
(
sizedDepthStencilGroup
)
;
sizedDepthStencilFormats
.
forEach
(
function
(
elem
)
{
var
internalFormat
=
elem
[
1
]
;
var
nameBase
=
elem
[
0
]
;
var
descriptionBase
=
gluStrUtil
.
getPixelFormatName
(
internalFormat
)
;
sizedDepthStencilGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DFormatCase
(
{
name
:
nameBase
+
'
_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
internalFormat
width
:
128
height
:
128
}
)
)
;
sizedDepthStencilGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DFormatCase
(
{
name
:
nameBase
+
'
_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
internalFormat
width
:
63
height
:
112
}
)
)
;
sizedDepthStencilGroup
.
addChild
(
new
es3fTextureFormatTests
.
TextureCubeFormatCase
(
{
name
:
nameBase
+
'
_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
internalFormat
width
:
64
height
:
64
}
)
)
;
sizedDepthStencilGroup
.
addChild
(
new
es3fTextureFormatTests
.
TextureCubeFormatCase
(
{
name
:
nameBase
+
'
_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
internalFormat
width
:
57
height
:
57
}
)
)
;
sizedDepthStencilGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DArrayFormatCase
(
{
name
:
nameBase
+
'
_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D_ARRAY
'
format
:
internalFormat
width
:
64
height
:
64
numLayers
:
8
}
)
)
;
sizedDepthStencilGroup
.
addChild
(
new
es3fTextureFormatTests
.
Texture2DArrayFormatCase
(
{
name
:
nameBase
+
'
_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D_ARRAY
'
format
:
internalFormat
width
:
63
height
:
57
numLayers
:
7
}
)
)
;
}
)
;
var
compressed2DGroup
=
tcuTestCase
.
newTest
(
'
compressed
'
'
Compressed
formats
(
2D
)
'
)
;
state
.
testCases
.
addChild
(
compressed2DGroup
)
;
var
compressedCubeGroup
=
tcuTestCase
.
newTest
(
'
compressed
'
'
Compressed
formats
(
Cubemap
)
'
)
;
state
.
testCases
.
addChild
(
compressedCubeGroup
)
;
var
etc2Formats
=
[
[
'
gl
.
COMPRESSED_R11_EAC
'
'
eac_r11
'
tcuCompressedTexture
.
Format
.
EAC_R11
]
[
'
gl
.
COMPRESSED_SIGNED_R11_EAC
'
'
eac_signed_r11
'
tcuCompressedTexture
.
Format
.
EAC_SIGNED_R11
]
[
'
gl
.
COMPRESSED_RG11_EAC
'
'
eac_rg11
'
tcuCompressedTexture
.
Format
.
EAC_RG11
]
[
'
gl
.
COMPRESSED_SIGNED_RG11_EAC
'
'
eac_signed_rg11
'
tcuCompressedTexture
.
Format
.
EAC_SIGNED_RG11
]
[
'
gl
.
COMPRESSED_RGB8_ETC2
'
'
etc2_rgb8
'
tcuCompressedTexture
.
Format
.
ETC2_RGB8
]
[
'
gl
.
COMPRESSED_SRGB8_ETC2
'
'
etc2_srgb8
'
tcuCompressedTexture
.
Format
.
ETC2_SRGB8
]
[
'
gl
.
COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2
'
'
etc2_rgb8_punchthrough_alpha1
'
tcuCompressedTexture
.
Format
.
ETC2_RGB8_PUNCHTHROUGH_ALPHA1
]
[
'
gl
.
COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2
'
'
etc2_srgb8_punchthrough_alpha1
'
tcuCompressedTexture
.
Format
.
ETC2_SRGB8_PUNCHTHROUGH_ALPHA1
]
[
'
gl
.
COMPRESSED_RGBA8_ETC2_EAC
'
'
etc2_eac_rgba8
'
tcuCompressedTexture
.
Format
.
ETC2_EAC_RGBA8
]
[
'
gl
.
COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
'
'
etc2_eac_srgb8_alpha8
'
tcuCompressedTexture
.
Format
.
ETC2_EAC_SRGB8_ALPHA8
]
]
;
if
(
!
gluTextureUtil
.
enableCompressedTextureETC
(
)
)
{
debug
(
'
Skipping
ETC2
/
EAC
texture
format
tests
:
no
support
for
WEBGL_compressed_texture_etc
'
)
;
etc2Formats
=
[
]
;
}
etc2Formats
.
forEach
(
function
(
elem
)
{
var
nameBase
=
elem
[
1
]
;
var
descriptionBase
=
elem
[
0
]
;
var
format
=
elem
[
2
]
;
compressed2DGroup
.
addChild
(
new
es3fTextureFormatTests
.
Compressed2DFormatCase
(
{
name
:
nameBase
+
'
_2d_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
format
width
:
128
height
:
64
}
)
)
;
compressedCubeGroup
.
addChild
(
new
es3fTextureFormatTests
.
CompressedCubeFormatCase
(
{
name
:
nameBase
+
'
_cube_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
format
width
:
64
height
:
64
}
)
)
;
compressed2DGroup
.
addChild
(
new
es3fTextureFormatTests
.
Compressed2DFormatCase
(
{
name
:
nameBase
+
'
_2d_pot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_2D
'
format
:
format
width
:
128
height
:
64
}
)
)
;
compressedCubeGroup
.
addChild
(
new
es3fTextureFormatTests
.
CompressedCubeFormatCase
(
{
name
:
nameBase
+
'
_cube_npot
'
description
:
descriptionBase
+
'
gl
.
TEXTURE_CUBE_MAP
'
format
:
format
width
:
51
height
:
51
}
)
)
;
}
)
;
}
;
es3fTextureFormatTests
.
run
=
function
(
context
range
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
try
{
es3fTextureFormatTests
.
genTestCases
(
)
;
if
(
range
)
state
.
setRange
(
range
)
;
state
.
runCallback
(
tcuTestCase
.
runTestCases
)
;
}
catch
(
err
)
{
bufferedLogToConsole
(
err
)
;
state
.
terminate
(
)
;
}
}
;
}
)
;
