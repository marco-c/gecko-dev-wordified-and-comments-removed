'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fDrawTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuLogImage
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluDrawUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTexture
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluVarType
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrGLContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrShaderProgram
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrFragmentOperations
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrGenericVector
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrShadingContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexAttrib
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexPacket
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsDrawTests
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fDrawTests
=
functional
.
gles3
.
es3fDrawTests
;
var
gluDrawUtil
=
framework
.
opengl
.
gluDrawUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
gluTexture
=
framework
.
opengl
.
gluTexture
;
var
gluVarType
=
framework
.
opengl
.
gluVarType
;
var
tcuLogImage
=
framework
.
common
.
tcuLogImage
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deUtil
=
framework
.
delibs
.
debase
.
deUtil
;
var
glsDrawTests
=
modules
.
shared
.
glsDrawTests
;
var
sglrShaderProgram
=
framework
.
opengl
.
simplereference
.
sglrShaderProgram
;
var
sglrGLContext
=
framework
.
opengl
.
simplereference
.
sglrGLContext
;
var
rrFragmentOperations
=
framework
.
referencerenderer
.
rrFragmentOperations
;
var
rrGenericVector
=
framework
.
referencerenderer
.
rrGenericVector
;
var
rrShadingContext
=
framework
.
referencerenderer
.
rrShadingContext
;
var
rrVertexAttrib
=
framework
.
referencerenderer
.
rrVertexAttrib
;
var
rrVertexPacket
=
framework
.
referencerenderer
.
rrVertexPacket
;
var
gl
;
es3fDrawTests
.
TestIterationType
=
{
DRAW_COUNT
:
0
INSTANCE_COUNT
:
1
INDEX_RANGE
:
2
}
;
es3fDrawTests
.
addTestIterations
=
function
(
test
baseSpec
type
)
{
var
spec
=
(
deUtil
.
clone
(
baseSpec
)
)
;
if
(
type
=
=
es3fDrawTests
.
TestIterationType
.
DRAW_COUNT
)
{
spec
.
primitiveCount
=
1
;
test
.
addIteration
(
spec
'
draw
count
=
'
+
spec
.
primitiveCount
)
;
spec
.
primitiveCount
=
5
;
test
.
addIteration
(
spec
'
draw
count
=
'
+
spec
.
primitiveCount
)
;
spec
.
primitiveCount
=
25
;
test
.
addIteration
(
spec
'
draw
count
=
'
+
spec
.
primitiveCount
)
;
}
else
if
(
type
=
=
es3fDrawTests
.
TestIterationType
.
INSTANCE_COUNT
)
{
spec
.
instanceCount
=
1
;
test
.
addIteration
(
spec
'
instance
count
=
'
+
spec
.
instanceCount
)
;
spec
.
instanceCount
=
4
;
test
.
addIteration
(
spec
'
instance
count
=
'
+
spec
.
instanceCount
)
;
spec
.
instanceCount
=
11
;
test
.
addIteration
(
spec
'
instance
count
=
'
+
spec
.
instanceCount
)
;
}
else
if
(
type
=
=
es3fDrawTests
.
TestIterationType
.
INDEX_RANGE
)
{
spec
.
indexMin
=
0
;
spec
.
indexMax
=
23
;
test
.
addIteration
(
spec
'
index
range
=
[
'
+
spec
.
indexMin
+
'
'
+
spec
.
indexMax
+
'
]
'
)
;
spec
.
indexMin
=
23
;
spec
.
indexMax
=
40
;
test
.
addIteration
(
spec
'
index
range
=
[
'
+
spec
.
indexMin
+
'
'
+
spec
.
indexMax
+
'
]
'
)
;
if
(
spec
.
primitive
=
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
)
{
spec
.
indexMin
=
5
;
spec
.
indexMax
=
5
;
test
.
addIteration
(
spec
'
index
range
=
[
'
+
spec
.
indexMin
+
'
'
+
spec
.
indexMax
+
'
]
'
)
;
}
}
else
throw
new
Error
(
'
Invalid
test
iteration
type
'
)
;
}
;
es3fDrawTests
.
genBasicSpec
=
function
(
spec
method
)
{
spec
.
primitive
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
;
spec
.
primitiveCount
=
6
;
spec
.
drawMethod
=
method
;
spec
.
indexType
=
null
;
spec
.
indexPointerOffset
=
0
;
spec
.
indexStorage
=
null
;
spec
.
first
=
0
;
spec
.
indexMin
=
0
;
spec
.
indexMax
=
0
;
spec
.
instanceCount
=
1
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
0
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
0
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
0
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
0
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
0
]
.
componentCount
=
4
;
spec
.
attribs
[
0
]
.
offset
=
0
;
spec
.
attribs
[
0
]
.
stride
=
0
;
spec
.
attribs
[
0
]
.
normalize
=
false
;
spec
.
attribs
[
0
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
0
]
.
useDefaultAttribute
=
false
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
1
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
1
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
1
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
1
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
1
]
.
componentCount
=
2
;
spec
.
attribs
[
1
]
.
offset
=
0
;
spec
.
attribs
[
1
]
.
stride
=
0
;
spec
.
attribs
[
1
]
.
normalize
=
false
;
spec
.
attribs
[
1
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
1
]
.
useDefaultAttribute
=
false
;
}
;
es3fDrawTests
.
AttributeGroup
=
function
(
name
descr
drawMethod
primitive
indexType
indexStorage
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
descr
)
;
this
.
m_method
=
drawMethod
;
this
.
m_primitive
=
primitive
;
this
.
m_indexType
=
indexType
;
this
.
m_indexStorage
=
indexStorage
;
this
.
makeExecutable
(
)
;
}
;
es3fDrawTests
.
AttributeGroup
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
AttributeGroup
.
prototype
.
constructor
=
es3fDrawTests
.
AttributeGroup
;
es3fDrawTests
.
AttributeGroup
.
prototype
.
init
=
function
(
)
{
var
instanced
=
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS_INSTANCED
|
|
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_INSTANCED
;
var
ranged
=
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
;
var
testType
=
instanced
?
es3fDrawTests
.
TestIterationType
.
INSTANCE_COUNT
:
(
ranged
?
es3fDrawTests
.
TestIterationType
.
INDEX_RANGE
:
es3fDrawTests
.
TestIterationType
.
DRAW_COUNT
)
;
var
test
=
new
glsDrawTests
.
DrawTest
(
null
'
single_attribute
'
'
Single
attribute
array
.
'
)
;
var
spec
=
new
glsDrawTests
.
DrawTestSpec
(
)
;
spec
.
primitive
=
this
.
m_primitive
;
spec
.
primitiveCount
=
5
;
spec
.
drawMethod
=
this
.
m_method
;
spec
.
indexType
=
this
.
m_indexType
;
spec
.
indexPointerOffset
=
0
;
spec
.
indexStorage
=
this
.
m_indexStorage
;
spec
.
first
=
0
;
spec
.
indexMin
=
0
;
spec
.
indexMax
=
0
;
spec
.
instanceCount
=
1
;
spec
.
attribs
.
length
=
0
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
0
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
0
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
0
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
0
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
0
]
.
componentCount
=
2
;
spec
.
attribs
[
0
]
.
offset
=
0
;
spec
.
attribs
[
0
]
.
stride
=
0
;
spec
.
attribs
[
0
]
.
normalize
=
false
;
spec
.
attribs
[
0
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
0
]
.
useDefaultAttribute
=
false
;
es3fDrawTests
.
addTestIterations
(
test
spec
testType
)
;
this
.
addChild
(
test
)
;
test
=
new
glsDrawTests
.
DrawTest
(
null
'
multiple_attributes
'
'
Multiple
attribute
arrays
.
'
)
;
spec
.
primitive
=
this
.
m_primitive
;
spec
.
primitiveCount
=
5
;
spec
.
drawMethod
=
this
.
m_method
;
spec
.
indexType
=
this
.
m_indexType
;
spec
.
indexPointerOffset
=
0
;
spec
.
indexStorage
=
this
.
m_indexStorage
;
spec
.
first
=
0
;
spec
.
indexMin
=
0
;
spec
.
indexMax
=
0
;
spec
.
instanceCount
=
1
;
spec
.
attribs
.
length
=
0
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
0
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
0
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
0
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
0
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
0
]
.
componentCount
=
4
;
spec
.
attribs
[
0
]
.
offset
=
0
;
spec
.
attribs
[
0
]
.
stride
=
0
;
spec
.
attribs
[
0
]
.
normalize
=
false
;
spec
.
attribs
[
0
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
0
]
.
useDefaultAttribute
=
false
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
1
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
1
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
1
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
1
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
1
]
.
componentCount
=
2
;
spec
.
attribs
[
1
]
.
offset
=
0
;
spec
.
attribs
[
1
]
.
stride
=
0
;
spec
.
attribs
[
1
]
.
normalize
=
false
;
spec
.
attribs
[
1
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
1
]
.
useDefaultAttribute
=
false
;
es3fDrawTests
.
addTestIterations
(
test
spec
testType
)
;
this
.
addChild
(
test
)
;
test
=
new
glsDrawTests
.
DrawTest
(
null
'
instanced_attributes
'
'
Instanced
attribute
array
.
'
)
;
spec
.
primitive
=
this
.
m_primitive
;
spec
.
primitiveCount
=
5
;
spec
.
drawMethod
=
this
.
m_method
;
spec
.
indexType
=
this
.
m_indexType
;
spec
.
indexPointerOffset
=
0
;
spec
.
indexStorage
=
this
.
m_indexStorage
;
spec
.
first
=
0
;
spec
.
indexMin
=
0
;
spec
.
indexMax
=
0
;
spec
.
instanceCount
=
1
;
spec
.
attribs
.
length
=
0
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
0
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
0
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
0
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
0
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
0
]
.
componentCount
=
4
;
spec
.
attribs
[
0
]
.
offset
=
0
;
spec
.
attribs
[
0
]
.
stride
=
0
;
spec
.
attribs
[
0
]
.
normalize
=
false
;
spec
.
attribs
[
0
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
0
]
.
useDefaultAttribute
=
false
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
1
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
1
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
1
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
1
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
1
]
.
componentCount
=
2
;
spec
.
attribs
[
1
]
.
offset
=
0
;
spec
.
attribs
[
1
]
.
stride
=
0
;
spec
.
attribs
[
1
]
.
normalize
=
false
;
spec
.
attribs
[
1
]
.
instanceDivisor
=
1
;
spec
.
attribs
[
1
]
.
useDefaultAttribute
=
false
;
spec
.
attribs
[
1
]
.
additionalPositionAttribute
=
true
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
2
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
2
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
2
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
2
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
2
]
.
componentCount
=
3
;
spec
.
attribs
[
2
]
.
offset
=
0
;
spec
.
attribs
[
2
]
.
stride
=
0
;
spec
.
attribs
[
2
]
.
normalize
=
false
;
spec
.
attribs
[
2
]
.
instanceDivisor
=
1
;
spec
.
attribs
[
2
]
.
useDefaultAttribute
=
false
;
es3fDrawTests
.
addTestIterations
(
test
spec
testType
)
;
this
.
addChild
(
test
)
;
test
=
new
glsDrawTests
.
DrawTest
(
null
'
default_attribute
'
'
Attribute
specified
with
glVertexAttrib
*
.
'
)
;
spec
.
primitive
=
this
.
m_primitive
;
spec
.
primitiveCount
=
5
;
spec
.
drawMethod
=
this
.
m_method
;
spec
.
indexType
=
this
.
m_indexType
;
spec
.
indexPointerOffset
=
0
;
spec
.
indexStorage
=
this
.
m_indexStorage
;
spec
.
first
=
0
;
spec
.
indexMin
=
0
;
spec
.
indexMax
=
17
;
spec
.
instanceCount
=
1
;
spec
.
attribs
.
length
=
0
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
spec
.
attribs
[
0
]
.
inputType
=
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
;
spec
.
attribs
[
0
]
.
outputType
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
;
spec
.
attribs
[
0
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
0
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
0
]
.
componentCount
=
2
;
spec
.
attribs
[
0
]
.
offset
=
0
;
spec
.
attribs
[
0
]
.
stride
=
0
;
spec
.
attribs
[
0
]
.
normalize
=
false
;
spec
.
attribs
[
0
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
0
]
.
useDefaultAttribute
=
false
;
var
iopairs
=
[
{
input
:
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
output
:
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
componentCount
:
4
}
{
input
:
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
output
:
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
componentCount
:
2
}
{
input
:
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
output
:
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
componentCount
:
4
}
{
input
:
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
output
:
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
componentCount
:
4
}
]
;
spec
.
attribs
.
push
(
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
)
;
for
(
var
ioNdx
=
0
;
ioNdx
<
iopairs
.
length
;
+
+
ioNdx
)
{
var
desc
=
glsDrawTests
.
DrawTestSpec
.
inputTypeToString
(
iopairs
[
ioNdx
]
.
input
)
+
iopairs
[
ioNdx
]
.
componentCount
+
'
to
'
+
glsDrawTests
.
DrawTestSpec
.
outputTypeToString
(
iopairs
[
ioNdx
]
.
output
)
;
spec
.
attribs
[
1
]
.
inputType
=
iopairs
[
ioNdx
]
.
input
;
spec
.
attribs
[
1
]
.
outputType
=
iopairs
[
ioNdx
]
.
output
;
spec
.
attribs
[
1
]
.
storage
=
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
;
spec
.
attribs
[
1
]
.
usage
=
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
;
spec
.
attribs
[
1
]
.
componentCount
=
iopairs
[
ioNdx
]
.
componentCount
;
spec
.
attribs
[
1
]
.
offset
=
0
;
spec
.
attribs
[
1
]
.
stride
=
0
;
spec
.
attribs
[
1
]
.
normalize
=
false
;
spec
.
attribs
[
1
]
.
instanceDivisor
=
0
;
spec
.
attribs
[
1
]
.
useDefaultAttribute
=
true
;
test
.
addIteration
(
spec
desc
)
;
}
this
.
addChild
(
test
)
;
}
;
es3fDrawTests
.
IndexGroup
=
function
(
name
descr
drawMethod
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
descr
)
;
this
.
m_method
=
drawMethod
;
this
.
makeExecutable
(
)
;
}
;
es3fDrawTests
.
IndexGroup
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
IndexGroup
.
prototype
.
constructor
=
es3fDrawTests
.
IndexGroup
;
es3fDrawTests
.
IndexGroup
.
prototype
.
init
=
function
(
)
{
var
tests
=
[
{
storage
:
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
type
:
glsDrawTests
.
DrawTestSpec
.
IndexType
.
BYTE
aligned
:
true
offsets
:
[
0
1
-
1
]
}
{
storage
:
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
type
:
glsDrawTests
.
DrawTestSpec
.
IndexType
.
SHORT
aligned
:
true
offsets
:
[
0
2
-
1
]
}
{
storage
:
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
type
:
glsDrawTests
.
DrawTestSpec
.
IndexType
.
INT
aligned
:
true
offsets
:
[
0
4
-
1
]
}
{
storage
:
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
type
:
glsDrawTests
.
DrawTestSpec
.
IndexType
.
SHORT
aligned
:
false
offsets
:
[
1
3
-
1
]
}
{
storage
:
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
type
:
glsDrawTests
.
DrawTestSpec
.
IndexType
.
INT
aligned
:
false
offsets
:
[
2
3
-
1
]
}
]
;
var
spec
=
new
glsDrawTests
.
DrawTestSpec
(
)
;
es3fDrawTests
.
genBasicSpec
(
spec
this
.
m_method
)
;
var
bufferGroup
=
new
tcuTestCase
.
DeqpTest
(
'
buffer
'
'
buffer
'
)
;
var
unalignedBufferGroup
=
new
tcuTestCase
.
DeqpTest
(
'
unaligned_buffer
'
'
unaligned
buffer
'
)
;
this
.
addChild
(
bufferGroup
)
;
this
.
addChild
(
unalignedBufferGroup
)
;
for
(
var
testNdx
=
0
;
testNdx
<
tests
.
length
;
+
+
testNdx
)
{
var
indexTest
=
tests
[
testNdx
]
;
var
group
=
indexTest
.
aligned
?
bufferGroup
:
unalignedBufferGroup
;
var
name
=
'
index_
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
indexTest
.
type
)
;
var
desc
=
'
index
'
+
glsDrawTests
.
DrawTestSpec
.
indexTypeToString
(
indexTest
.
type
)
+
'
in
'
+
glsDrawTests
.
DrawTestSpec
.
storageToString
(
indexTest
.
storage
)
;
var
test
=
new
glsDrawTests
.
DrawTest
(
null
name
desc
)
;
spec
.
indexType
=
indexTest
.
type
;
spec
.
indexStorage
=
indexTest
.
storage
;
for
(
var
iterationNdx
=
0
;
iterationNdx
<
indexTest
.
offsets
.
length
&
&
indexTest
.
offsets
[
iterationNdx
]
!
=
-
1
;
+
+
iterationNdx
)
{
var
iterationDesc
=
'
offset
'
+
indexTest
.
offsets
[
iterationNdx
]
;
spec
.
indexPointerOffset
=
indexTest
.
offsets
[
iterationNdx
]
;
test
.
addIteration
(
spec
iterationDesc
)
;
}
if
(
spec
.
isCompatibilityTest
(
)
!
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_OFFSET
&
&
spec
.
isCompatibilityTest
(
)
!
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_STRIDE
)
group
.
addChild
(
test
)
;
}
}
;
es3fDrawTests
.
FirstGroup
=
function
(
name
descr
drawMethod
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
descr
)
;
this
.
m_method
=
drawMethod
;
this
.
makeExecutable
(
)
;
}
;
es3fDrawTests
.
FirstGroup
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
FirstGroup
.
prototype
.
constructor
=
es3fDrawTests
.
FirstGroup
;
es3fDrawTests
.
FirstGroup
.
prototype
.
init
=
function
(
)
{
var
firsts
=
[
1
3
17
]
;
var
spec
=
new
glsDrawTests
.
DrawTestSpec
(
)
;
es3fDrawTests
.
genBasicSpec
(
spec
this
.
m_method
)
;
for
(
var
firstNdx
=
0
;
firstNdx
<
firsts
.
length
;
+
+
firstNdx
)
{
var
name
=
'
first_
'
+
firsts
[
firstNdx
]
;
var
desc
=
'
first
'
+
firsts
[
firstNdx
]
;
var
test
=
new
glsDrawTests
.
DrawTest
(
null
name
desc
)
;
spec
.
first
=
firsts
[
firstNdx
]
;
es3fDrawTests
.
addTestIterations
(
test
spec
es3fDrawTests
.
TestIterationType
.
DRAW_COUNT
)
;
this
.
addChild
(
test
)
;
}
}
;
es3fDrawTests
.
MethodGroup
=
function
(
name
descr
drawMethod
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
descr
)
;
this
.
m_method
=
drawMethod
;
this
.
makeExecutable
(
)
;
}
;
es3fDrawTests
.
MethodGroup
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
MethodGroup
.
prototype
.
constructor
=
es3fDrawTests
.
MethodGroup
;
es3fDrawTests
.
MethodGroup
.
prototype
.
init
=
function
(
)
{
var
indexed
=
(
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS
)
|
|
(
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_INSTANCED
)
|
|
(
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
)
;
var
hasFirst
=
(
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS
)
|
|
(
this
.
m_method
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS_INSTANCED
)
;
var
primitive
=
[
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINES
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_STRIP
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_LOOP
]
;
if
(
hasFirst
)
{
this
.
addChild
(
new
es3fDrawTests
.
FirstGroup
(
'
first
'
'
First
tests
'
this
.
m_method
)
)
;
}
if
(
indexed
)
{
if
(
this
.
m_method
!
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
)
this
.
addChild
(
new
es3fDrawTests
.
IndexGroup
(
'
indices
'
'
Index
tests
'
this
.
m_method
)
)
;
}
for
(
var
ndx
=
0
;
ndx
<
primitive
.
length
;
+
+
ndx
)
{
var
name
=
glsDrawTests
.
DrawTestSpec
.
primitiveToString
(
primitive
[
ndx
]
)
;
var
desc
=
glsDrawTests
.
DrawTestSpec
.
primitiveToString
(
primitive
[
ndx
]
)
;
this
.
addChild
(
new
es3fDrawTests
.
AttributeGroup
(
name
desc
this
.
m_method
primitive
[
ndx
]
glsDrawTests
.
DrawTestSpec
.
IndexType
.
SHORT
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
)
)
;
}
}
;
es3fDrawTests
.
GridProgram
=
function
(
)
{
var
decl
=
new
sglrShaderProgram
.
ShaderProgramDeclaration
(
)
;
decl
.
pushVertexAttribute
(
new
sglrShaderProgram
.
VertexAttribute
(
'
a_position
'
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushVertexAttribute
(
new
sglrShaderProgram
.
VertexAttribute
(
'
a_offset
'
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushVertexAttribute
(
new
sglrShaderProgram
.
VertexAttribute
(
'
a_color
'
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushVertexToFragmentVarying
(
new
sglrShaderProgram
.
VertexToFragmentVarying
(
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushFragmentOutput
(
new
sglrShaderProgram
.
FragmentOutput
(
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
decl
.
pushVertexSource
(
new
sglrShaderProgram
.
VertexSource
(
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
in
highp
vec4
a_offset
;
\
n
'
+
'
in
highp
vec4
a_color
;
\
n
'
+
'
out
mediump
vec4
v_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
+
a_offset
;
\
n
'
+
'
v_color
=
a_color
;
\
n
'
+
'
}
\
n
'
)
)
;
decl
.
pushFragmentSource
(
new
sglrShaderProgram
.
FragmentSource
(
'
#
version
300
es
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
dEQP_FragColor
;
\
n
'
+
'
in
mediump
vec4
v_color
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
dEQP_FragColor
=
v_color
;
\
n
'
+
'
}
\
n
'
)
)
;
sglrShaderProgram
.
ShaderProgram
.
call
(
this
decl
)
;
}
;
es3fDrawTests
.
GridProgram
.
prototype
=
Object
.
create
(
sglrShaderProgram
.
ShaderProgram
.
prototype
)
;
es3fDrawTests
.
GridProgram
.
prototype
.
constructor
=
es3fDrawTests
.
GridProgram
;
es3fDrawTests
.
GridProgram
.
prototype
.
shadeVertices
=
function
(
inputs
packets
numPackets
)
{
for
(
var
ndx
=
0
;
ndx
<
numPackets
;
+
+
ndx
)
{
packets
[
ndx
]
.
position
=
deMath
.
add
(
rrVertexAttrib
.
readVertexAttrib
(
inputs
[
0
]
packets
[
ndx
]
.
instanceNdx
packets
[
ndx
]
.
vertexNdx
rrGenericVector
.
GenericVecType
.
FLOAT
)
rrVertexAttrib
.
readVertexAttrib
(
inputs
[
1
]
packets
[
ndx
]
.
instanceNdx
packets
[
ndx
]
.
vertexNdx
rrGenericVector
.
GenericVecType
.
FLOAT
)
)
;
packets
[
ndx
]
.
outputs
[
0
]
=
rrVertexAttrib
.
readVertexAttrib
(
inputs
[
2
]
packets
[
ndx
]
.
instanceNdx
packets
[
ndx
]
.
vertexNdx
rrGenericVector
.
GenericVecType
.
FLOAT
)
;
}
}
;
es3fDrawTests
.
GridProgram
.
prototype
.
shadeFragments
=
function
(
packets
context
)
{
for
(
var
packetNdx
=
0
;
packetNdx
<
packets
.
length
;
+
+
packetNdx
)
for
(
var
fragNdx
=
0
;
fragNdx
<
4
;
+
+
fragNdx
)
packets
[
packetNdx
]
.
value
=
rrShadingContext
.
readTriangleVarying
(
packets
[
packetNdx
]
context
fragNdx
)
;
}
;
es3fDrawTests
.
InstancedGridRenderTest
=
function
(
name
desc
gridSide
useIndices
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
desc
)
;
this
.
m_gridSide
=
gridSide
;
this
.
m_useIndices
=
useIndices
;
}
;
es3fDrawTests
.
InstancedGridRenderTest
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
InstancedGridRenderTest
.
prototype
.
constructor
=
es3fDrawTests
.
InstancedGridRenderTest
;
es3fDrawTests
.
InstancedGridRenderTest
.
prototype
.
iterate
=
function
(
)
{
var
renderTargetWidth
=
Math
.
min
(
1024
gl
.
canvas
.
width
)
;
var
renderTargetHeight
=
Math
.
min
(
1024
gl
.
canvas
.
height
)
;
var
ctx
=
new
sglrGLContext
.
GLContext
(
gl
)
;
var
surface
=
new
tcuSurface
.
Surface
(
renderTargetWidth
renderTargetHeight
)
;
var
program
=
new
es3fDrawTests
.
GridProgram
(
)
;
this
.
renderTo
(
ctx
program
surface
)
;
if
(
this
.
verifyImage
(
surface
)
)
testPassed
(
'
'
)
;
else
testFailed
(
'
Incorrect
rendering
result
'
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fDrawTests
.
InstancedGridRenderTest
.
prototype
.
renderTo
=
function
(
ctx
program
dst
)
{
var
green
=
[
0
1
0
1
]
;
var
yellow
=
[
1
1
0
1
]
;
var
positionBuf
=
null
;
var
offsetBuf
=
null
;
var
colorBuf
=
null
;
var
indexBuf
=
null
;
var
programID
=
ctx
.
createProgram
(
program
)
;
var
posLocation
=
ctx
.
getAttribLocation
(
(
programID
)
'
a_position
'
)
;
var
offsetLocation
=
ctx
.
getAttribLocation
(
(
programID
)
'
a_offset
'
)
;
var
colorLocation
=
ctx
.
getAttribLocation
(
(
programID
)
'
a_color
'
)
;
var
cellW
=
2
.
0
/
this
.
m_gridSide
;
var
cellH
=
2
.
0
/
this
.
m_gridSide
;
var
vertexPositions
=
new
Float32Array
(
[
0
0
0
1
cellW
0
0
1
0
cellH
0
1
0
cellH
0
1
cellW
0
0
1
cellW
cellH
0
1
]
)
;
var
indices
=
new
Uint16Array
(
[
0
4
3
2
1
5
]
)
;
var
offsets
=
[
]
;
for
(
var
x
=
0
;
x
<
this
.
m_gridSide
;
+
+
x
)
for
(
var
y
=
0
;
y
<
this
.
m_gridSide
;
+
+
y
)
{
offsets
.
push
(
x
*
cellW
-
1
.
0
)
;
offsets
.
push
(
y
*
cellW
-
1
.
0
)
;
offsets
.
push
(
0
0
)
;
}
offsets
=
new
Float32Array
(
offsets
)
;
var
colors
=
[
]
;
for
(
var
x
=
0
;
x
<
this
.
m_gridSide
;
+
+
x
)
for
(
var
y
=
0
;
y
<
this
.
m_gridSide
;
+
+
y
)
{
var
colorToPush
=
(
(
x
+
y
)
%
2
=
=
0
)
?
(
green
)
:
(
yellow
)
;
colors
.
push
(
colorToPush
[
0
]
)
;
colors
.
push
(
colorToPush
[
1
]
)
;
colors
.
push
(
colorToPush
[
2
]
)
;
colors
.
push
(
colorToPush
[
3
]
)
;
}
colors
=
new
Float32Array
(
colors
)
;
positionBuf
=
ctx
.
createBuffer
(
)
;
ctx
.
bindBuffer
(
gl
.
ARRAY_BUFFER
positionBuf
)
;
ctx
.
bufferData
(
gl
.
ARRAY_BUFFER
vertexPositions
gl
.
STATIC_DRAW
)
;
ctx
.
vertexAttribPointer
(
posLocation
4
gl
.
FLOAT
false
0
0
)
;
ctx
.
vertexAttribDivisor
(
posLocation
0
)
;
ctx
.
enableVertexAttribArray
(
posLocation
)
;
offsetBuf
=
ctx
.
createBuffer
(
)
;
ctx
.
bindBuffer
(
gl
.
ARRAY_BUFFER
offsetBuf
)
;
ctx
.
bufferData
(
gl
.
ARRAY_BUFFER
offsets
gl
.
STATIC_DRAW
)
;
ctx
.
vertexAttribPointer
(
offsetLocation
4
gl
.
FLOAT
false
0
0
)
;
ctx
.
vertexAttribDivisor
(
offsetLocation
1
)
;
ctx
.
enableVertexAttribArray
(
offsetLocation
)
;
colorBuf
=
ctx
.
createBuffer
(
)
;
ctx
.
bindBuffer
(
gl
.
ARRAY_BUFFER
colorBuf
)
;
ctx
.
bufferData
(
gl
.
ARRAY_BUFFER
colors
gl
.
STATIC_DRAW
)
;
ctx
.
vertexAttribPointer
(
colorLocation
4
gl
.
FLOAT
false
0
0
)
;
ctx
.
vertexAttribDivisor
(
colorLocation
1
)
;
ctx
.
enableVertexAttribArray
(
colorLocation
)
;
if
(
this
.
m_useIndices
)
{
indexBuf
=
ctx
.
createBuffer
(
)
;
ctx
.
bindBuffer
(
gl
.
ELEMENT_ARRAY_BUFFER
indexBuf
)
;
ctx
.
bufferData
(
gl
.
ELEMENT_ARRAY_BUFFER
indices
gl
.
STATIC_DRAW
)
;
}
ctx
.
clearColor
(
0
0
0
1
)
;
ctx
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
ctx
.
viewport
(
0
0
dst
.
getWidth
(
)
dst
.
getHeight
(
)
)
;
ctx
.
useProgram
(
programID
)
;
if
(
this
.
m_useIndices
)
ctx
.
drawElementsInstanced
(
gl
.
TRIANGLES
6
gl
.
UNSIGNED_SHORT
0
this
.
m_gridSide
*
this
.
m_gridSide
)
;
else
ctx
.
drawArraysInstanced
(
gl
.
TRIANGLES
0
6
this
.
m_gridSide
*
this
.
m_gridSide
)
;
ctx
.
useProgram
(
null
)
;
if
(
this
.
m_useIndices
)
ctx
.
deleteBuffer
(
indexBuf
)
;
ctx
.
deleteBuffer
(
colorBuf
)
;
ctx
.
deleteBuffer
(
offsetBuf
)
;
ctx
.
deleteBuffer
(
positionBuf
)
;
ctx
.
deleteProgram
(
programID
)
;
ctx
.
finish
(
)
;
dst
.
readViewport
(
ctx
[
0
0
dst
.
getWidth
(
)
dst
.
getHeight
(
)
]
)
;
}
;
es3fDrawTests
.
InstancedGridRenderTest
.
prototype
.
verifyImage
=
function
(
image
)
{
var
green
=
[
0
255
0
255
]
;
var
yellow
=
[
255
255
0
255
]
;
var
colorThreshold
=
20
;
var
error
=
new
tcuSurface
.
Surface
(
image
.
getWidth
(
)
image
.
getHeight
(
)
)
;
var
isOk
=
true
;
for
(
var
y
=
1
;
y
<
image
.
getHeight
(
)
-
1
;
y
+
+
)
for
(
var
x
=
1
;
x
<
image
.
getWidth
(
)
-
1
;
x
+
+
)
{
var
pixel
=
new
tcuRGBA
.
RGBA
(
image
.
getPixel
(
x
y
)
)
;
var
pixelOk
=
true
;
if
(
Math
.
abs
(
pixel
.
getGreen
(
)
-
255
)
>
colorThreshold
)
pixelOk
=
false
;
if
(
Math
.
abs
(
pixel
.
getBlue
(
)
-
0
)
>
colorThreshold
)
pixelOk
=
false
;
error
.
setPixel
(
x
y
pixelOk
?
[
0
255
0
255
]
:
[
255
0
0
255
]
)
;
isOk
=
isOk
&
&
pixelOk
;
}
if
(
!
isOk
)
{
bufferedLogToConsole
(
'
Image
verification
failed
.
'
)
;
debug
(
'
Verfication
result
'
)
;
tcuLogImage
.
logImageWithInfo
(
image
.
getAccess
(
)
'
Result
'
)
;
tcuLogImage
.
logImageWithInfo
(
error
.
getAccess
(
)
'
Error
mask
'
)
;
}
else
{
debug
(
'
Verfication
result
'
)
;
}
return
isOk
;
}
;
es3fDrawTests
.
InstancingGroup
=
function
(
name
descr
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
descr
)
;
this
.
makeExecutable
(
)
;
}
;
es3fDrawTests
.
InstancingGroup
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
InstancingGroup
.
prototype
.
constructor
=
es3fDrawTests
.
InstancingGroup
;
es3fDrawTests
.
InstancingGroup
.
prototype
.
init
=
function
(
)
{
var
gridWidths
=
[
2
5
10
32
100
]
;
for
(
var
ndx
=
0
;
ndx
<
gridWidths
.
length
;
+
+
ndx
)
{
var
name
=
'
draw_arrays_instanced_grid_
'
+
gridWidths
[
ndx
]
+
'
x
'
+
gridWidths
[
ndx
]
;
var
desc
=
'
DrawArraysInstanced
Grid
size
'
+
gridWidths
[
ndx
]
+
'
x
'
+
gridWidths
[
ndx
]
;
this
.
addChild
(
new
es3fDrawTests
.
InstancedGridRenderTest
(
name
desc
gridWidths
[
ndx
]
false
)
)
;
}
for
(
var
ndx
=
0
;
ndx
<
gridWidths
.
length
;
+
+
ndx
)
{
var
name
=
'
draw_elements_instanced_grid_
'
+
gridWidths
[
ndx
]
+
'
x
'
+
gridWidths
[
ndx
]
;
var
desc
=
'
DrawElementsInstanced
Grid
size
'
+
gridWidths
[
ndx
]
+
'
x
'
+
gridWidths
[
ndx
]
;
this
.
addChild
(
new
es3fDrawTests
.
InstancedGridRenderTest
(
name
desc
gridWidths
[
ndx
]
true
)
)
;
}
}
;
es3fDrawTests
.
UniformWeightArray
=
function
(
size
)
{
this
.
weights
=
[
]
;
for
(
var
i
=
0
;
i
<
size
;
+
+
i
)
this
.
weights
[
i
]
=
1
.
0
;
}
;
es3fDrawTests
.
RandomGroup
=
function
(
name
descr
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
descr
)
;
this
.
makeExecutable
(
)
;
}
;
es3fDrawTests
.
RandomGroup
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
RandomGroup
.
prototype
.
constructor
=
es3fDrawTests
.
RandomGroup
;
es3fDrawTests
.
RandomGroup
.
prototype
.
init
=
function
(
)
{
var
numAttempts
=
300
;
var
attribCounts
=
[
1
2
5
]
;
var
attribWeights
=
[
30
10
1
]
;
var
primitiveCounts
=
[
2
6
64
]
;
var
primitiveCountWeights
=
[
20
10
1
]
;
var
indexOffsets
=
[
0
7
13
]
;
var
indexOffsetWeights
=
[
20
20
1
]
;
var
firsts
=
[
0
6
12
]
;
var
firstWeights
=
[
20
20
1
]
;
var
instanceCounts
=
[
1
2
16
17
]
;
var
instanceWeights
=
[
20
10
5
1
]
;
var
indexMins
=
[
0
1
3
9
]
;
var
indexMaxs
=
[
5
9
129
257
]
;
var
indexWeights
=
[
50
50
50
50
]
;
var
offsets
=
[
0
1
5
12
]
;
var
offsetWeights
=
[
50
10
10
10
]
;
var
strides
=
[
0
7
16
17
]
;
var
strideWeights
=
[
50
10
10
10
]
;
var
instanceDivisors
=
[
0
1
3
129
]
;
var
instanceDivisorWeights
=
[
70
30
10
10
]
;
var
primitives
=
[
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINES
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_STRIP
glsDrawTests
.
DrawTestSpec
.
Primitive
.
LINE_LOOP
]
;
var
primitiveWeights
=
new
es3fDrawTests
.
UniformWeightArray
(
primitives
.
length
)
;
var
drawMethods
=
[
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS_INSTANCED
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_INSTANCED
]
;
var
drawMethodWeights
=
new
es3fDrawTests
.
UniformWeightArray
(
drawMethods
.
length
)
;
var
indexTypes
=
[
glsDrawTests
.
DrawTestSpec
.
IndexType
.
BYTE
glsDrawTests
.
DrawTestSpec
.
IndexType
.
SHORT
glsDrawTests
.
DrawTestSpec
.
IndexType
.
INT
]
;
var
indexTypeWeights
=
new
es3fDrawTests
.
UniformWeightArray
(
indexTypes
.
length
)
;
var
storages
=
[
glsDrawTests
.
DrawTestSpec
.
Storage
.
BUFFER
]
;
var
storageWeights
=
new
es3fDrawTests
.
UniformWeightArray
(
storages
.
length
)
;
var
inputTypes
=
[
glsDrawTests
.
DrawTestSpec
.
InputType
.
FLOAT
glsDrawTests
.
DrawTestSpec
.
InputType
.
BYTE
glsDrawTests
.
DrawTestSpec
.
InputType
.
SHORT
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_BYTE
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_SHORT
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT
glsDrawTests
.
DrawTestSpec
.
InputType
.
HALF
glsDrawTests
.
DrawTestSpec
.
InputType
.
UNSIGNED_INT_2_10_10_10
glsDrawTests
.
DrawTestSpec
.
InputType
.
INT_2_10_10_10
]
;
var
inputTypeWeights
=
new
es3fDrawTests
.
UniformWeightArray
(
inputTypes
.
length
)
;
var
outputTypes
=
[
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC2
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC3
glsDrawTests
.
DrawTestSpec
.
OutputType
.
VEC4
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC2
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC3
glsDrawTests
.
DrawTestSpec
.
OutputType
.
IVEC4
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC2
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC3
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UVEC4
]
;
var
outputTypeWeights
=
new
es3fDrawTests
.
UniformWeightArray
(
outputTypes
.
length
)
;
var
usages
=
[
glsDrawTests
.
DrawTestSpec
.
Usage
.
DYNAMIC_DRAW
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_DRAW
glsDrawTests
.
DrawTestSpec
.
Usage
.
STREAM_DRAW
glsDrawTests
.
DrawTestSpec
.
Usage
.
STREAM_READ
glsDrawTests
.
DrawTestSpec
.
Usage
.
STREAM_COPY
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_READ
glsDrawTests
.
DrawTestSpec
.
Usage
.
STATIC_COPY
glsDrawTests
.
DrawTestSpec
.
Usage
.
DYNAMIC_READ
glsDrawTests
.
DrawTestSpec
.
Usage
.
DYNAMIC_COPY
]
;
var
usageWeights
=
new
es3fDrawTests
.
UniformWeightArray
(
usages
.
length
)
;
var
insertedHashes
=
[
]
;
var
insertedCount
=
0
;
for
(
var
ndx
=
0
;
ndx
<
numAttempts
;
+
+
ndx
)
{
var
random
=
new
deRandom
.
Random
(
0xc551393
+
ndx
)
;
var
attributeCount
=
random
.
chooseWeighted
(
attribCounts
attribWeights
)
;
var
spec
=
new
glsDrawTests
.
DrawTestSpec
(
)
;
spec
.
primitive
=
(
random
.
chooseWeighted
(
primitives
primitiveWeights
.
weights
)
)
;
spec
.
primitiveCount
=
random
.
chooseWeighted
(
primitiveCounts
primitiveCountWeights
)
;
spec
.
drawMethod
=
(
random
.
chooseWeighted
(
drawMethods
drawMethodWeights
.
weights
)
)
;
spec
.
indexType
=
(
random
.
chooseWeighted
(
indexTypes
indexTypeWeights
.
weights
)
)
;
spec
.
indexPointerOffset
=
random
.
chooseWeighted
(
indexOffsets
indexOffsetWeights
)
;
spec
.
indexStorage
=
(
random
.
chooseWeighted
(
storages
storageWeights
.
weights
)
)
;
spec
.
first
=
random
.
chooseWeighted
(
firsts
firstWeights
)
;
spec
.
indexMin
=
random
.
chooseWeighted
(
indexMins
indexWeights
)
;
spec
.
indexMax
=
random
.
chooseWeighted
(
indexMaxs
indexWeights
)
;
spec
.
instanceCount
=
random
.
chooseWeighted
(
instanceCounts
instanceWeights
)
;
if
(
!
spec
.
valid
(
)
)
continue
;
var
hasZeroDivisor
=
false
;
for
(
var
attrNdx
=
0
;
attrNdx
<
attributeCount
;
)
{
var
valid
;
var
attribSpec
=
new
glsDrawTests
.
DrawTestSpec
.
AttributeSpec
(
)
;
attribSpec
.
inputType
=
(
random
.
chooseWeighted
(
inputTypes
inputTypeWeights
.
weights
)
)
;
attribSpec
.
outputType
=
(
random
.
chooseWeighted
(
outputTypes
outputTypeWeights
.
weights
)
)
;
attribSpec
.
storage
=
(
random
.
chooseWeighted
(
storages
storageWeights
.
weights
)
)
;
attribSpec
.
usage
=
(
random
.
chooseWeighted
(
usages
usageWeights
.
weights
)
)
;
attribSpec
.
componentCount
=
random
.
getInt
(
1
4
)
;
attribSpec
.
offset
=
random
.
chooseWeighted
(
offsets
offsetWeights
)
;
attribSpec
.
stride
=
random
.
chooseWeighted
(
strides
strideWeights
)
;
attribSpec
.
normalize
=
random
.
getBool
(
)
;
attribSpec
.
instanceDivisor
=
random
.
chooseWeighted
(
instanceDivisors
instanceDivisorWeights
)
;
attribSpec
.
useDefaultAttribute
=
random
.
getBool
(
)
;
valid
=
attribSpec
.
valid
(
)
;
if
(
attribSpec
.
stride
&
&
attribSpec
.
componentCount
*
glsDrawTests
.
DrawTestSpec
.
inputTypeSize
(
attribSpec
.
inputType
)
>
attribSpec
.
stride
)
valid
=
false
;
if
(
valid
)
{
spec
.
attribs
.
push
(
attribSpec
)
;
+
+
attrNdx
;
if
(
attribSpec
.
instanceDivisor
=
=
0
)
hasZeroDivisor
=
true
;
}
}
if
(
spec
.
primitive
!
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
)
{
spec
.
attribs
[
0
]
.
instanceDivisor
=
0
;
hasZeroDivisor
=
true
;
}
if
(
hasZeroDivisor
=
=
false
)
continue
;
if
(
spec
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
&
&
spec
.
indexMin
=
=
spec
.
indexMax
&
&
spec
.
primitive
!
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
)
continue
;
if
(
spec
.
attribs
[
0
]
.
useDefaultAttribute
&
&
spec
.
primitive
!
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
POINTS
)
continue
;
if
(
spec
.
primitive
=
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLES
|
|
spec
.
primitive
=
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_FAN
|
|
spec
.
primitive
=
=
glsDrawTests
.
DrawTestSpec
.
Primitive
.
TRIANGLE_STRIP
)
{
if
(
spec
.
attribs
[
0
]
.
componentCount
=
=
1
)
continue
;
if
(
spec
.
attribs
[
0
]
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
FLOAT
|
|
spec
.
attribs
[
0
]
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
INT
|
|
spec
.
attribs
[
0
]
.
outputType
=
=
glsDrawTests
.
DrawTestSpec
.
OutputType
.
UINT
)
continue
;
if
(
spec
.
drawMethod
=
=
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
&
&
(
spec
.
indexMax
-
spec
.
indexMin
)
<
2
)
continue
;
}
var
hash
=
spec
.
hash
(
)
;
for
(
var
attrNdx
=
0
;
attrNdx
<
attributeCount
;
+
+
attrNdx
)
hash
=
deMath
.
binaryOp
(
deMath
.
shiftLeft
(
hash
2
)
spec
.
attribs
[
attrNdx
]
.
hash
(
)
deMath
.
BinaryOp
.
XOR
)
;
if
(
insertedHashes
.
indexOf
(
hash
)
=
=
-
1
)
{
if
(
spec
.
isCompatibilityTest
(
)
!
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_OFFSET
&
&
spec
.
isCompatibilityTest
(
)
!
=
glsDrawTests
.
DrawTestSpec
.
CompatibilityTestType
.
UNALIGNED_STRIDE
)
{
this
.
addChild
(
new
glsDrawTests
.
DrawTest
(
spec
insertedCount
+
'
'
spec
.
getDesc
(
)
)
)
;
}
deUtil
.
dePushUniqueToArray
(
insertedHashes
hash
)
;
+
+
insertedCount
;
}
}
}
;
es3fDrawTests
.
DrawTest
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
draw
'
'
Drawing
tests
'
)
;
this
.
makeExecutable
(
)
;
}
;
es3fDrawTests
.
DrawTest
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fDrawTests
.
DrawTest
.
prototype
.
constructor
=
es3fDrawTests
.
DrawTest
;
es3fDrawTests
.
DrawTest
.
prototype
.
init
=
function
(
)
{
var
basicMethods
=
[
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWARRAYS_INSTANCED
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_INSTANCED
glsDrawTests
.
DrawTestSpec
.
DrawMethod
.
DRAWELEMENTS_RANGED
]
;
for
(
var
ndx
=
0
;
ndx
<
basicMethods
.
length
;
+
+
ndx
)
{
var
name
=
glsDrawTests
.
DrawTestSpec
.
drawMethodToString
(
basicMethods
[
ndx
]
)
;
var
desc
=
glsDrawTests
.
DrawTestSpec
.
drawMethodToString
(
basicMethods
[
ndx
]
)
;
this
.
addChild
(
new
es3fDrawTests
.
MethodGroup
(
name
desc
basicMethods
[
ndx
]
)
)
;
}
this
.
addChild
(
new
es3fDrawTests
.
InstancingGroup
(
'
instancing
'
'
draw
tests
with
a
large
instance
count
.
'
)
)
;
this
.
addChild
(
new
es3fDrawTests
.
RandomGroup
(
'
random
'
'
random
draw
commands
.
'
)
)
;
}
;
es3fDrawTests
.
run
=
function
(
context
range
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
var
rootTest
=
new
es3fDrawTests
.
DrawTest
(
)
;
state
.
setRoot
(
rootTest
)
;
setCurrentTestName
(
rootTest
.
fullName
(
)
)
;
description
(
rootTest
.
getDescription
(
)
)
;
try
{
if
(
range
)
{
state
.
setRange
(
range
)
;
}
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
run
draw
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
