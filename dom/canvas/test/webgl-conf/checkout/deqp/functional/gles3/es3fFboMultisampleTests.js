'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fFboMultisampleTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrUtil
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestCase
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fFboMultisampleTests
=
functional
.
gles3
.
es3fFboMultisampleTests
;
var
es3fFboTestCase
=
functional
.
gles3
.
es3fFboTestCase
;
var
es3fFboTestUtil
=
functional
.
gles3
.
es3fFboTestUtil
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
rrUtil
=
framework
.
referencerenderer
.
rrUtil
;
var
gl
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
es3fFboMultisampleTests
.
BasicFboMultisampleCase
=
function
(
name
desc
colorFormat
depthStencilFormat
size
numSamples
)
{
es3fFboTestCase
.
FboTestCase
.
call
(
this
name
desc
)
;
this
.
m_colorFormat
=
colorFormat
;
this
.
m_depthStencilFormat
=
depthStencilFormat
;
this
.
m_size
=
size
;
this
.
m_numSamples
=
numSamples
;
}
;
es3fFboMultisampleTests
.
BasicFboMultisampleCase
.
prototype
=
Object
.
create
(
es3fFboTestCase
.
FboTestCase
.
prototype
)
;
es3fFboMultisampleTests
.
BasicFboMultisampleCase
.
prototype
.
constructor
=
es3fFboMultisampleTests
.
BasicFboMultisampleCase
;
es3fFboMultisampleTests
.
BasicFboMultisampleCase
.
prototype
.
preCheck
=
function
(
)
{
this
.
checkFormatSupport
(
this
.
m_colorFormat
)
;
if
(
!
this
.
checkSampleCount
(
this
.
m_colorFormat
this
.
m_numSamples
)
)
return
false
;
if
(
this
.
m_depthStencilFormat
!
=
gl
.
NONE
)
{
this
.
checkFormatSupport
(
this
.
m_depthStencilFormat
)
;
if
(
!
this
.
checkSampleCount
(
this
.
m_depthStencilFormat
this
.
m_numSamples
)
)
return
false
;
}
return
true
;
}
;
es3fFboMultisampleTests
.
BasicFboMultisampleCase
.
prototype
.
render
=
function
(
dst
)
{
var
ctx
=
this
.
getCurrentContext
(
)
;
var
colorFmt
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_colorFormat
)
;
var
depthStencilFmt
=
this
.
m_depthStencilFormat
!
=
gl
.
NONE
?
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_depthStencilFormat
)
:
new
tcuTexture
.
TextureFormat
(
null
null
)
;
var
colorFmtInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
colorFmt
)
;
var
depth
=
depthStencilFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
D
|
|
depthStencilFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
DS
;
var
stencil
=
depthStencilFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
S
|
|
depthStencilFmt
.
order
=
=
tcuTexture
.
ChannelOrder
.
DS
;
var
gradShader
=
new
es3fFboTestUtil
.
GradientShader
(
es3fFboTestUtil
.
getFragmentOutputType
(
colorFmt
)
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
es3fFboTestUtil
.
getFragmentOutputType
(
colorFmt
)
)
;
var
gradShaderID
=
this
.
getCurrentContext
(
)
.
createProgram
(
gradShader
)
;
var
flatShaderID
=
this
.
getCurrentContext
(
)
.
createProgram
(
flatShader
)
;
var
msaaFbo
=
null
;
var
resolveFbo
=
null
;
var
msaaColorRbo
=
null
;
var
resolveColorRbo
=
null
;
var
msaaDepthStencilRbo
=
null
;
var
resolveDepthStencilRbo
=
null
;
msaaColorRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
msaaColorRbo
)
;
ctx
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
this
.
m_numSamples
this
.
m_colorFormat
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
if
(
depth
|
|
stencil
)
{
msaaDepthStencilRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
msaaDepthStencilRbo
)
;
ctx
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
this
.
m_numSamples
this
.
m_depthStencilFormat
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
}
msaaFbo
=
ctx
.
createFramebuffer
(
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
msaaFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
msaaColorRbo
)
;
if
(
depth
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
DEPTH_ATTACHMENT
gl
.
RENDERBUFFER
msaaDepthStencilRbo
)
;
if
(
stencil
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
STENCIL_ATTACHMENT
gl
.
RENDERBUFFER
msaaDepthStencilRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
resolveColorRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
resolveColorRbo
)
;
ctx
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
0
this
.
m_colorFormat
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
if
(
depth
|
|
stencil
)
{
resolveDepthStencilRbo
=
ctx
.
createRenderbuffer
(
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
resolveDepthStencilRbo
)
;
ctx
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
0
this
.
m_depthStencilFormat
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
}
resolveFbo
=
ctx
.
createFramebuffer
(
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
resolveFbo
)
;
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
resolveColorRbo
)
;
if
(
depth
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
DEPTH_ATTACHMENT
gl
.
RENDERBUFFER
resolveDepthStencilRbo
)
;
if
(
stencil
)
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
STENCIL_ATTACHMENT
gl
.
RENDERBUFFER
resolveDepthStencilRbo
)
;
this
.
checkError
(
)
;
this
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
msaaFbo
)
;
ctx
.
viewport
(
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
)
;
ctx
.
clearBufferfi
(
gl
.
DEPTH_STENCIL
0
1
.
0
0
)
;
ctx
.
enable
(
gl
.
DEPTH_TEST
)
;
gradShader
.
setGradient
(
this
.
getCurrentContext
(
)
gradShaderID
colorFmtInfo
.
valueMin
colorFmtInfo
.
valueMax
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
gradShaderID
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
)
;
var
numQuads
=
8
;
var
rnd
=
new
deRandom
.
Random
(
7
)
;
ctx
.
depthFunc
(
gl
.
ALWAYS
)
;
ctx
.
enable
(
gl
.
STENCIL_TEST
)
;
ctx
.
stencilFunc
(
gl
.
ALWAYS
0
0xff
)
;
ctx
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
INCR
)
;
for
(
var
ndx
=
0
;
ndx
<
numQuads
;
ndx
+
+
)
{
var
r
=
rnd
.
getFloat
(
)
;
var
g
=
rnd
.
getFloat
(
)
;
var
b
=
rnd
.
getFloat
(
)
;
var
a
=
rnd
.
getFloat
(
)
;
var
x0
=
rnd
.
getFloat
(
-
1
.
0
1
.
0
)
;
var
y0
=
rnd
.
getFloat
(
-
1
.
0
1
.
0
)
;
var
z0
=
rnd
.
getFloat
(
-
1
.
0
1
.
0
)
;
var
x1
=
rnd
.
getFloat
(
-
1
.
0
1
.
0
)
;
var
y1
=
rnd
.
getFloat
(
-
1
.
0
1
.
0
)
;
var
z1
=
rnd
.
getFloat
(
-
1
.
0
1
.
0
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
deMath
.
add
(
deMath
.
multiply
(
[
r
g
b
a
]
deMath
.
subtract
(
colorFmtInfo
.
valueMax
colorFmtInfo
.
valueMin
)
)
colorFmtInfo
.
valueMin
)
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
x0
y0
z0
]
[
x1
y1
z1
]
)
;
}
ctx
.
disable
(
gl
.
DEPTH_TEST
)
;
ctx
.
disable
(
gl
.
STENCIL_TEST
)
;
this
.
checkError
(
)
;
ctx
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
resolveFbo
)
;
ctx
.
blitFramebuffer
(
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
gl
.
COLOR_BUFFER_BIT
|
(
depth
?
gl
.
DEPTH_BUFFER_BIT
:
0
)
|
(
stencil
?
gl
.
STENCIL_BUFFER_BIT
:
0
)
gl
.
NEAREST
)
;
ctx
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
resolveFbo
)
;
var
numSteps
;
var
step
;
var
d
;
var
c
;
var
s
;
if
(
depth
)
{
numSteps
=
8
;
step
=
2
.
0
/
numSteps
;
ctx
.
enable
(
gl
.
DEPTH_TEST
)
;
ctx
.
depthFunc
(
gl
.
LESS
)
;
ctx
.
depthMask
(
false
)
;
ctx
.
colorMask
(
false
false
true
false
)
;
for
(
var
ndx
=
0
;
ndx
<
numSteps
;
ndx
+
+
)
{
d
=
-
1
.
0
+
step
*
ndx
;
c
=
ndx
/
(
numSteps
-
1
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
deMath
.
add
(
deMath
.
multiply
(
[
0
.
0
0
.
0
c
1
.
0
]
deMath
.
subtract
(
colorFmtInfo
.
valueMax
colorFmtInfo
.
valueMin
)
)
colorFmtInfo
.
valueMin
)
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
1
.
0
-
1
.
0
d
]
[
1
.
0
1
.
0
d
]
)
;
}
ctx
.
disable
(
gl
.
DEPTH_TEST
)
;
}
if
(
stencil
)
{
numSteps
=
4
;
step
=
1
;
ctx
.
enable
(
gl
.
STENCIL_TEST
)
;
ctx
.
stencilOp
(
gl
.
KEEP
gl
.
KEEP
gl
.
KEEP
)
;
ctx
.
colorMask
(
false
true
false
false
)
;
for
(
var
ndx
=
0
;
ndx
<
numSteps
;
ndx
+
+
)
{
s
=
step
*
ndx
;
c
=
ndx
/
(
numSteps
-
1
)
;
ctx
.
stencilFunc
(
gl
.
EQUAL
s
0xff
)
;
flatShader
.
setColor
(
this
.
getCurrentContext
(
)
flatShaderID
deMath
.
add
(
deMath
.
multiply
(
[
0
.
0
c
0
.
0
1
.
0
]
deMath
.
subtract
(
colorFmtInfo
.
valueMax
colorFmtInfo
.
valueMin
)
)
colorFmtInfo
.
valueMin
)
)
;
rrUtil
.
drawQuad
(
this
.
getCurrentContext
(
)
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
}
ctx
.
disable
(
gl
.
STENCIL_TEST
)
;
}
this
.
readPixelsUsingFormat
(
dst
0
0
this
.
m_size
[
0
]
this
.
m_size
[
1
]
colorFmt
colorFmtInfo
.
lookupScale
colorFmtInfo
.
lookupBias
)
;
}
;
es3fFboMultisampleTests
.
BasicFboMultisampleCase
.
prototype
.
colorCompare
=
function
(
reference
result
)
{
var
threshold
=
tcuRGBA
.
max
(
es3fFboTestUtil
.
getFormatThreshold
(
this
.
m_colorFormat
)
tcuRGBA
.
newRGBAComponents
(
12
12
12
12
)
)
;
return
tcuImageCompare
.
bilinearCompare
(
'
Result
'
'
Image
comparison
result
'
reference
.
getAccess
(
)
result
.
getAccess
(
)
threshold
tcuImageCompare
.
CompareLogMode
.
RESULT
)
;
}
;
es3fFboMultisampleTests
.
BasicFboMultisampleCase
.
prototype
.
compare
=
function
(
reference
result
)
{
if
(
this
.
m_depthStencilFormat
!
=
gl
.
NONE
)
return
es3fFboTestCase
.
FboTestCase
.
prototype
.
compare
(
reference
result
)
;
else
return
this
.
colorCompare
(
reference
result
)
;
}
;
es3fFboMultisampleTests
.
FboMultisampleTests
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
msaa
'
'
Multisample
FBO
tests
'
)
;
}
;
es3fFboMultisampleTests
.
FboMultisampleTests
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fFboMultisampleTests
.
FboMultisampleTests
.
prototype
.
constructor
=
es3fFboMultisampleTests
.
FboMultisampleTests
;
es3fFboMultisampleTests
.
FboMultisampleTests
.
prototype
.
init
=
function
(
)
{
var
colorFormats
=
[
gl
.
RGBA8
gl
.
SRGB8_ALPHA8
gl
.
RGB10_A2
gl
.
RGBA4
gl
.
RGB5_A1
gl
.
RGB8
gl
.
RGB565
gl
.
RG8
gl
.
R8
gl
.
RGBA32F
gl
.
RGBA16F
gl
.
R11F_G11F_B10F
gl
.
RG32F
gl
.
RG16F
gl
.
R32F
gl
.
R16F
]
;
var
depthStencilFormats
=
[
gl
.
DEPTH_COMPONENT32F
gl
.
DEPTH_COMPONENT24
gl
.
DEPTH_COMPONENT16
gl
.
DEPTH32F_STENCIL8
gl
.
DEPTH24_STENCIL8
gl
.
STENCIL_INDEX8
]
;
var
sampleCounts
=
[
2
4
8
]
;
for
(
var
sampleCntNdx
in
sampleCounts
)
{
var
samples
=
sampleCounts
[
sampleCntNdx
]
;
var
sampleCountGroup
=
tcuTestCase
.
newTest
(
samples
+
'
_samples
'
'
'
)
;
this
.
addChild
(
sampleCountGroup
)
;
for
(
var
fmtNdx
in
colorFormats
)
sampleCountGroup
.
addChild
(
new
es3fFboMultisampleTests
.
BasicFboMultisampleCase
(
es3fFboTestUtil
.
getFormatName
(
colorFormats
[
fmtNdx
]
)
'
'
colorFormats
[
fmtNdx
]
gl
.
NONE
[
119
131
]
samples
)
)
;
for
(
var
fmtNdx
in
depthStencilFormats
)
sampleCountGroup
.
addChild
(
new
es3fFboMultisampleTests
.
BasicFboMultisampleCase
(
es3fFboTestUtil
.
getFormatName
(
depthStencilFormats
[
fmtNdx
]
)
'
'
gl
.
RGBA8
depthStencilFormats
[
fmtNdx
]
[
119
131
]
samples
)
)
;
}
}
;
es3fFboMultisampleTests
.
run
=
function
(
context
range
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
var
test
=
new
es3fFboMultisampleTests
.
FboMultisampleTests
(
)
;
var
testName
=
test
.
fullName
(
)
;
var
testDescription
=
test
.
getDescription
(
)
;
state
.
testName
=
testName
;
state
.
setRoot
(
test
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
test
.
init
(
)
;
if
(
range
)
state
.
setRange
(
range
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fFboMultisampleTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
