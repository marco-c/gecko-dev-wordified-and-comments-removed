'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fFboRenderTest
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuLogImage
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuPixelFormat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrGLContext
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrReferenceContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrUtil
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fFboRenderTest
=
functional
.
gles3
.
es3fFboRenderTest
;
var
es3fFboTestUtil
=
functional
.
gles3
.
es3fFboTestUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuLogImage
=
framework
.
common
.
tcuLogImage
;
var
tcuPixelFormat
=
framework
.
common
.
tcuPixelFormat
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
deUtil
=
framework
.
delibs
.
debase
.
deUtil
;
var
sglrGLContext
=
framework
.
opengl
.
simplereference
.
sglrGLContext
;
var
sglrReferenceContext
=
framework
.
opengl
.
simplereference
.
sglrReferenceContext
;
var
rrUtil
=
framework
.
referencerenderer
.
rrUtil
;
var
gl
;
es3fFboRenderTest
.
FboConfig
=
function
(
buffers_
colorType_
colorFormat_
depthStencilType_
depthStencilFormat_
width_
height_
samples_
)
{
this
.
buffers
=
buffers_
?
buffers_
:
0
;
this
.
colorType
=
colorType_
?
colorType_
:
gl
.
NONE
;
this
.
colorFormat
=
colorFormat_
?
colorFormat_
:
gl
.
NONE
;
this
.
depthStencilType
=
depthStencilType_
?
depthStencilType_
:
gl
.
NONE
;
this
.
depthStencilFormat
=
depthStencilFormat_
?
depthStencilFormat_
:
gl
.
NONE
;
this
.
width
=
width_
?
width_
:
0
;
this
.
height
=
height_
?
height_
:
0
;
this
.
samples
=
samples_
?
samples_
:
0
;
}
;
es3fFboRenderTest
.
getTypeName
=
function
(
type
)
{
switch
(
type
)
{
case
gl
.
TEXTURE_2D
:
return
'
tex2d
'
;
case
gl
.
RENDERBUFFER
:
return
'
rbo
'
;
default
:
testFailed
(
'
Unknown
type
'
)
;
}
return
'
Should
not
get
to
this
point
'
;
}
;
es3fFboRenderTest
.
FboConfig
.
prototype
.
getName
=
function
(
)
{
var
name
=
'
'
;
assertMsgOptions
(
(
this
.
buffers
&
gl
.
COLOR_BUFFER_BIT
)
!
=
0
'
Color
buffer
is
not
specified
'
false
true
)
;
name
+
=
es3fFboRenderTest
.
getTypeName
(
this
.
colorType
)
+
'
_
'
+
es3fFboTestUtil
.
getFormatName
(
this
.
colorFormat
)
;
if
(
this
.
buffers
&
gl
.
DEPTH_BUFFER_BIT
)
name
+
=
'
_depth
'
;
if
(
this
.
buffers
&
gl
.
STENCIL_BUFFER_BIT
)
name
+
=
'
_stencil
'
;
if
(
this
.
buffers
&
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
)
name
+
=
'
_
'
+
es3fFboRenderTest
.
getTypeName
(
this
.
depthStencilType
)
+
'
_
'
+
es3fFboTestUtil
.
getFormatName
(
this
.
depthStencilFormat
)
;
return
name
;
}
;
es3fFboRenderTest
.
getEnablingExtensions
=
function
(
format
)
{
var
out
=
[
]
;
switch
(
format
)
{
case
gl
.
RGB16F
:
out
.
push
(
'
EXT_color_buffer_half_float
'
)
;
break
;
case
gl
.
RGBA16F
:
case
gl
.
RG16F
:
case
gl
.
R16F
:
out
.
push
(
'
EXT_color_buffer_half_float
'
)
;
case
gl
.
RGBA32F
:
case
gl
.
RGB32F
:
case
gl
.
R11F_G11F_B10F
:
case
gl
.
RG32F
:
case
gl
.
R32F
:
out
.
push
(
'
WEBGL_color_buffer_float
'
)
;
default
:
break
;
}
return
out
;
}
;
es3fFboRenderTest
.
isExtensionSupported
=
function
(
context
name
)
{
return
context
.
getExtension
(
name
)
;
}
;
es3fFboRenderTest
.
isAnyExtensionSupported
=
function
(
context
requiredExts
)
{
if
(
!
requiredExts
|
|
requiredExts
.
length
=
=
0
)
return
true
;
for
(
var
extNdx
=
0
;
extNdx
<
requiredExts
.
length
;
extNdx
+
+
)
{
var
extension
=
requiredExts
[
extNdx
]
;
if
(
es3fFboRenderTest
.
isExtensionSupported
(
context
extension
)
)
return
true
;
}
return
false
;
}
;
es3fFboRenderTest
.
join
=
function
(
list
sep
)
{
var
out
=
'
'
;
for
(
var
elemNdx
=
0
;
elemNdx
<
list
.
length
;
elemNdx
+
+
)
{
if
(
elemNdx
!
=
0
)
out
+
=
sep
;
out
+
=
list
[
elemNdx
]
;
}
return
out
;
}
;
es3fFboRenderTest
.
checkColorFormatSupport
=
function
(
context
sizedFormat
)
{
var
requiredExts
=
es3fFboRenderTest
.
getEnablingExtensions
(
sizedFormat
)
;
if
(
!
es3fFboRenderTest
.
isAnyExtensionSupported
(
context
requiredExts
)
)
{
var
errMsg
=
'
Format
not
supported
requires
'
+
(
(
requiredExts
.
length
=
=
1
)
?
requiredExts
[
0
]
:
'
one
of
the
following
:
'
+
requiredExts
.
join
(
'
'
)
)
;
checkMessage
(
false
errMsg
)
;
throw
new
TestFailedException
(
errMsg
)
;
}
}
;
es3fFboRenderTest
.
Framebuffer
=
function
(
context
config
width
height
fbo
colorBufferName
depthStencilBufferName
)
{
this
.
m_config
=
config
;
this
.
m_context
=
context
;
this
.
m_framebuffer
=
fbo
?
fbo
:
null
;
this
.
m_colorBuffer
=
colorBufferName
?
colorBufferName
:
null
;
this
.
m_depthStencilBuffer
=
depthStencilBufferName
?
depthStencilBufferName
:
null
;
es3fFboRenderTest
.
checkColorFormatSupport
(
context
config
.
colorFormat
)
;
if
(
!
this
.
m_framebuffer
)
this
.
m_framebuffer
=
context
.
createFramebuffer
(
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_framebuffer
)
;
if
(
this
.
m_config
.
buffers
&
(
gl
.
COLOR_BUFFER_BIT
)
)
{
switch
(
this
.
m_config
.
colorType
)
{
case
gl
.
TEXTURE_2D
:
this
.
m_colorBuffer
=
this
.
createTex2D
(
(
colorBufferName
)
this
.
m_config
.
colorFormat
width
height
)
;
context
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
TEXTURE_2D
this
.
m_colorBuffer
0
)
;
break
;
case
gl
.
RENDERBUFFER
:
this
.
m_colorBuffer
=
this
.
createRbo
(
(
colorBufferName
)
this
.
m_config
.
colorFormat
width
height
)
;
context
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
this
.
m_colorBuffer
)
;
break
;
default
:
testFailed
(
'
Unsupported
type
'
)
;
}
}
if
(
this
.
m_config
.
buffers
&
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
)
{
switch
(
this
.
m_config
.
depthStencilType
)
{
case
gl
.
TEXTURE_2D
:
this
.
m_depthStencilBuffer
=
this
.
createTex2D
(
(
depthStencilBufferName
)
this
.
m_config
.
depthStencilFormat
width
height
)
;
break
;
case
gl
.
RENDERBUFFER
:
this
.
m_depthStencilBuffer
=
this
.
createRbo
(
(
depthStencilBufferName
)
this
.
m_config
.
depthStencilFormat
width
height
)
;
break
;
default
:
testFailed
(
'
Unsupported
type
'
)
;
}
}
for
(
var
ndx
=
0
;
ndx
<
2
;
ndx
+
+
)
{
var
bit
=
ndx
?
gl
.
STENCIL_BUFFER_BIT
:
gl
.
DEPTH_BUFFER_BIT
;
var
point
=
ndx
?
gl
.
STENCIL_ATTACHMENT
:
gl
.
DEPTH_ATTACHMENT
;
if
(
(
this
.
m_config
.
buffers
&
bit
)
=
=
0
)
continue
;
switch
(
this
.
m_config
.
depthStencilType
)
{
case
gl
.
TEXTURE_2D
:
context
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
point
gl
.
TEXTURE_2D
this
.
m_depthStencilBuffer
0
)
;
break
;
case
gl
.
RENDERBUFFER
:
context
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
point
gl
.
RENDERBUFFER
this
.
m_depthStencilBuffer
)
;
break
;
default
:
throw
new
Error
(
'
Invalid
depth
stencil
type
'
)
;
}
}
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
getConfig
=
function
(
)
{
return
this
.
m_config
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
getFramebuffer
=
function
(
)
{
return
this
.
m_framebuffer
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
getColorBuffer
=
function
(
)
{
return
this
.
m_colorBuffer
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
getDepthStencilBuffer
=
function
(
)
{
return
this
.
m_depthStencilBuffer
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
deinit
=
function
(
)
{
this
.
m_context
.
deleteFramebuffer
(
(
this
.
m_framebuffer
)
)
;
this
.
destroyBuffer
(
this
.
m_colorBuffer
this
.
m_config
.
colorType
)
;
this
.
destroyBuffer
(
this
.
m_depthStencilBuffer
this
.
m_config
.
depthStencilType
)
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
checkCompleteness
=
function
(
)
{
this
.
m_context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_framebuffer
)
;
var
status
=
this
.
m_context
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
this
.
m_context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
if
(
status
!
=
gl
.
FRAMEBUFFER_COMPLETE
)
throw
new
es3fFboTestUtil
.
FboIncompleteException
(
status
)
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
createTex2D
=
function
(
name
format
width
height
)
{
if
(
!
name
)
name
=
this
.
m_context
.
createTexture
(
)
;
this
.
m_context
.
bindTexture
(
gl
.
TEXTURE_2D
name
)
;
this
.
m_context
.
texImage2DDelegate
(
gl
.
TEXTURE_2D
0
format
width
height
)
;
if
(
!
deMath
.
deIsPowerOfTwo32
(
width
)
|
|
!
deMath
.
deIsPowerOfTwo32
(
height
)
)
{
this
.
m_context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
this
.
m_context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
}
this
.
m_context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
this
.
m_context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
return
name
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
createRbo
=
function
(
name
format
width
height
)
{
if
(
!
name
)
name
=
this
.
m_context
.
createRenderbuffer
(
)
;
this
.
m_context
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
name
)
;
this
.
m_context
.
renderbufferStorage
(
gl
.
RENDERBUFFER
format
width
height
)
;
return
name
;
}
;
es3fFboRenderTest
.
Framebuffer
.
prototype
.
destroyBuffer
=
function
(
name
type
)
{
if
(
type
=
=
gl
.
TEXTURE_2D
|
|
type
=
=
gl
.
TEXTURE_CUBE_MAP
)
this
.
m_context
.
deleteTexture
(
(
name
)
)
;
else
if
(
type
=
=
gl
.
RENDERBUFFER
)
this
.
m_context
.
deleteRenderbuffer
(
(
name
)
)
;
else
assertMsgOptions
(
type
=
=
gl
.
NONE
'
Invalid
buffer
type
'
false
true
)
;
}
;
es3fFboRenderTest
.
createMetaballsTex2D
=
function
(
context
name
format
dataType
width
height
)
{
var
texFormat
=
gluTextureUtil
.
mapGLTransferFormat
(
format
dataType
)
;
var
level
=
new
tcuTexture
.
TextureLevel
(
texFormat
width
height
)
;
tcuTextureUtil
.
fillWithMetaballs
(
level
.
getAccess
(
)
5
width
^
height
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
name
)
;
context
.
texImage2D
(
gl
.
TEXTURE_2D
0
format
width
height
0
format
dataType
level
.
getAccess
(
)
.
getDataPtr
(
)
)
;
context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
LINEAR
)
;
}
;
es3fFboRenderTest
.
createQuadsTex2D
=
function
(
context
name
format
dataType
width
height
)
{
var
texFormat
=
gluTextureUtil
.
mapGLTransferFormat
(
format
dataType
)
;
var
level
=
new
tcuTexture
.
TextureLevel
(
texFormat
width
height
)
;
tcuTextureUtil
.
fillWithRGBAQuads
(
level
.
getAccess
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
name
)
;
context
.
texImage2D
(
gl
.
TEXTURE_2D
0
format
width
height
0
format
dataType
level
.
getAccess
(
)
.
getDataPtr
(
)
)
;
context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
LINEAR
)
;
}
;
es3fFboRenderTest
.
FboRenderCase
=
function
(
name
description
config
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_config
=
config
;
}
;
es3fFboRenderTest
.
FboRenderCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fFboRenderTest
.
FboRenderCase
.
prototype
.
constructor
=
es3fFboRenderTest
.
FboRenderCase
;
es3fFboRenderTest
.
FboRenderCase
.
prototype
.
render
=
function
(
fboContext
dst
)
{
throw
new
Error
(
'
Must
override
'
)
;
}
;
es3fFboRenderTest
.
FboRenderCase
.
prototype
.
iterate
=
function
(
)
{
var
clearColor
=
[
0
.
125
0
.
25
0
.
5
1
.
0
]
;
var
failReason
=
"
"
;
var
rnd
=
new
deRandom
.
deRandom
(
)
;
deRandom
.
deRandom_init
(
rnd
deString
.
deStringHash
(
this
.
fullName
(
)
)
)
;
var
width
=
Math
.
min
(
gl
.
canvas
.
width
128
)
;
var
height
=
Math
.
min
(
gl
.
canvas
.
height
128
)
;
var
xMax
=
gl
.
canvas
.
width
-
width
+
1
;
var
yMax
=
gl
.
canvas
.
height
-
height
+
1
;
var
x
=
Math
.
abs
(
deRandom
.
deRandom_getInt
(
rnd
)
)
%
xMax
;
var
y
=
Math
.
abs
(
deRandom
.
deRandom_getInt
(
rnd
)
)
%
yMax
;
var
gles3Frame
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
refFrame
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
gles3Error
=
0
;
var
refError
=
0
;
var
context
;
try
{
context
=
new
sglrGLContext
.
GLContext
(
gl
[
x
y
width
height
]
)
;
context
.
clearColor
(
clearColor
[
0
]
clearColor
[
1
]
clearColor
[
2
]
clearColor
[
3
]
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
this
.
render
(
context
gles3Frame
)
;
gles3Error
=
context
.
getError
(
)
;
}
catch
(
e
)
{
if
(
e
instanceof
es3fFboTestUtil
.
FboIncompleteException
)
{
e
.
message
=
WebGLTestUtils
.
glEnumToString
(
gl
e
.
getReason
(
)
)
;
if
(
e
.
getReason
(
)
=
=
gl
.
FRAMEBUFFER_UNSUPPORTED
)
{
bufferedLogToConsole
(
e
+
'
:
'
+
e
.
message
)
;
testFailed
(
'
Not
supported
'
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
}
throw
e
;
}
var
buffers
=
new
sglrReferenceContext
.
ReferenceContextBuffers
(
new
tcuPixelFormat
.
PixelFormat
(
8
8
8
gl
.
getParameter
(
gl
.
ALPHA_BITS
)
?
8
:
0
)
(
gl
.
getParameter
(
gl
.
DEPTH_BITS
)
)
(
gl
.
getParameter
(
gl
.
STENCIL_BITS
)
)
width
height
)
;
context
=
new
sglrReferenceContext
.
ReferenceContext
(
new
sglrReferenceContext
.
ReferenceContextLimits
(
gl
)
buffers
.
getColorbuffer
(
)
buffers
.
getDepthbuffer
(
)
buffers
.
getStencilbuffer
(
)
)
;
context
.
clearColor
(
clearColor
[
0
]
clearColor
[
1
]
clearColor
[
2
]
clearColor
[
3
]
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
this
.
render
(
context
refFrame
)
;
refError
=
context
.
getError
(
)
;
var
errorCodesOk
=
(
gles3Error
=
=
refError
)
;
if
(
!
errorCodesOk
)
{
bufferedLogToConsole
(
'
Error
code
mismatch
:
got
'
+
WebGLTestUtils
.
glEnumToString
(
gl
gles3Error
)
+
'
expected
'
+
WebGLTestUtils
.
glEnumToString
(
gl
refError
)
)
;
failReason
=
'
Got
unexpected
error
'
;
}
var
imagesOk
=
this
.
compare
(
refFrame
gles3Frame
)
;
if
(
!
imagesOk
&
&
!
failReason
)
failReason
=
'
Image
comparison
failed
'
;
var
isOk
=
errorCodesOk
&
&
imagesOk
;
assertMsgOptions
(
isOk
failReason
true
true
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fFboRenderTest
.
FboRenderCase
.
prototype
.
compare
=
function
(
reference
result
)
{
var
threshold
=
new
tcuRGBA
.
RGBA
(
[
12
12
12
12
]
)
;
return
tcuImageCompare
.
bilinearCompare
(
'
ComparisonResult
'
'
Image
comparison
result
'
reference
.
getAccess
(
)
result
.
getAccess
(
)
threshold
tcuImageCompare
.
CompareLogMode
.
RESULT
)
;
}
;
es3fFboRenderTest
.
FboRenderCase
.
prototype
.
deinit
=
function
(
)
{
gl
.
clearColor
(
0
.
0
0
.
0
0
.
0
0
.
0
)
;
gl
.
clearDepth
(
1
.
0
)
;
gl
.
clearStencil
(
0
)
;
gl
.
disable
(
gl
.
STENCIL_TEST
)
;
gl
.
disable
(
gl
.
DEPTH_TEST
)
;
gl
.
disable
(
gl
.
BLEND
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
null
)
;
}
;
es3fFboRenderTest
.
StencilClearsTest
=
function
(
config
)
{
es3fFboRenderTest
.
FboRenderCase
.
call
(
this
config
.
getName
(
)
'
Stencil
clears
'
config
)
;
}
;
es3fFboRenderTest
.
StencilClearsTest
.
prototype
=
Object
.
create
(
es3fFboRenderTest
.
FboRenderCase
.
prototype
)
;
es3fFboRenderTest
.
StencilClearsTest
.
prototype
.
constructor
=
es3fFboRenderTest
.
StencilClearsTest
;
es3fFboRenderTest
.
StencilClearsTest
.
prototype
.
render
=
function
(
context
dst
)
{
var
colorFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_config
.
colorFormat
)
;
var
fboSamplerType
=
(
gluTextureUtil
.
getSampler2DType
(
colorFormat
)
)
;
var
fboOutputType
=
es3fFboTestUtil
.
getFragmentOutputType
(
colorFormat
)
;
var
fboRangeInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
colorFormat
)
;
var
fboOutScale
=
deMath
.
subtract
(
fboRangeInfo
.
valueMax
fboRangeInfo
.
valueMin
)
;
var
fboOutBias
=
fboRangeInfo
.
valueMin
;
var
texToFboShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
fboOutputType
)
;
var
texFromFboShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
fboSamplerType
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
texToFboShaderID
=
context
.
createProgram
(
texToFboShader
)
;
var
texFromFboShaderID
=
context
.
createProgram
(
texFromFboShader
)
;
var
metaballsTex
=
context
.
createTexture
(
)
;
var
quadsTex
=
context
.
createTexture
(
)
;
var
width
=
128
;
var
height
=
128
;
texToFboShader
.
setOutScaleBias
(
fboOutScale
fboOutBias
)
;
texFromFboShader
.
setTexScaleBias
(
0
fboRangeInfo
.
lookupScale
fboRangeInfo
.
lookupBias
)
;
es3fFboRenderTest
.
createQuadsTex2D
(
context
quadsTex
gl
.
RGBA
gl
.
UNSIGNED_BYTE
width
height
)
;
es3fFboRenderTest
.
createMetaballsTex2D
(
context
metaballsTex
gl
.
RGBA
gl
.
UNSIGNED_BYTE
width
height
)
;
var
fbo
=
new
es3fFboRenderTest
.
Framebuffer
(
context
this
.
m_config
width
height
)
;
fbo
.
checkCompleteness
(
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
.
getFramebuffer
(
)
)
;
context
.
viewport
(
0
0
width
height
)
;
context
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
enable
(
gl
.
SCISSOR_TEST
)
;
context
.
scissor
(
10
16
32
120
)
;
context
.
clearStencil
(
1
)
;
context
.
clear
(
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
scissor
(
16
32
100
64
)
;
context
.
clearStencil
(
2
)
;
context
.
clear
(
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
disable
(
gl
.
SCISSOR_TEST
)
;
context
.
enable
(
gl
.
STENCIL_TEST
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
quadsTex
)
;
context
.
stencilFunc
(
gl
.
EQUAL
1
0xff
)
;
texToFboShader
.
setUniforms
(
context
texToFboShaderID
)
;
rrUtil
.
drawQuad
(
context
texToFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
metaballsTex
)
;
context
.
stencilFunc
(
gl
.
EQUAL
2
0xff
)
;
texToFboShader
.
setUniforms
(
context
texToFboShaderID
)
;
rrUtil
.
drawQuad
(
context
texToFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
disable
(
gl
.
STENCIL_TEST
)
;
if
(
fbo
.
getConfig
(
)
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
fbo
.
getColorBuffer
(
)
)
;
context
.
viewport
(
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
)
;
texFromFboShader
.
setUniforms
(
context
texFromFboShaderID
)
;
rrUtil
.
drawQuad
(
context
texFromFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
dst
.
readViewport
(
context
[
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
]
)
;
}
else
es3fFboTestUtil
.
readPixels
(
context
dst
0
0
width
height
colorFormat
fboRangeInfo
.
lookupScale
fboRangeInfo
.
lookupBias
)
;
}
;
es3fFboRenderTest
.
SharedColorbufferTest
=
function
(
config
)
{
es3fFboRenderTest
.
FboRenderCase
.
call
(
this
config
.
getName
(
)
'
Shared
colorbuffer
'
config
)
;
}
;
es3fFboRenderTest
.
SharedColorbufferTest
.
prototype
=
Object
.
create
(
es3fFboRenderTest
.
FboRenderCase
.
prototype
)
;
es3fFboRenderTest
.
SharedColorbufferTest
.
prototype
.
constructor
=
es3fFboRenderTest
.
SharedColorbufferTest
;
es3fFboRenderTest
.
SharedColorbufferTest
.
prototype
.
render
=
function
(
context
dst
)
{
var
texShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
texShaderID
=
context
.
createProgram
(
texShader
)
;
var
flatShaderID
=
context
.
createProgram
(
flatShader
)
;
var
width
=
128
;
var
height
=
128
;
var
quadsTex
=
context
.
createTexture
(
)
;
var
metaballsTex
=
context
.
createTexture
(
)
;
var
stencil
=
(
this
.
m_config
.
buffers
&
gl
.
STENCIL_BUFFER_BIT
)
!
=
0
;
context
.
disable
(
gl
.
DITHER
)
;
es3fFboRenderTest
.
createQuadsTex2D
(
context
quadsTex
gl
.
RGB
gl
.
UNSIGNED_BYTE
64
64
)
;
es3fFboRenderTest
.
createMetaballsTex2D
(
context
metaballsTex
gl
.
RGBA
gl
.
UNSIGNED_BYTE
64
64
)
;
context
.
viewport
(
0
0
width
height
)
;
var
fboA
=
new
es3fFboRenderTest
.
Framebuffer
(
context
this
.
m_config
width
height
)
;
fboA
.
checkCompleteness
(
)
;
var
cfg
=
(
deUtil
.
clone
(
this
.
m_config
)
)
;
cfg
.
buffers
=
deMath
.
binaryOp
(
cfg
.
buffers
deMath
.
binaryNot
(
gl
.
COLOR_BUFFER_BIT
)
deMath
.
BinaryOp
.
AND
)
;
cfg
.
colorType
=
gl
.
NONE
;
cfg
.
colorFormat
=
gl
.
NONE
;
var
fboB
=
new
es3fFboRenderTest
.
Framebuffer
(
context
cfg
width
height
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fboB
.
getFramebuffer
(
)
)
;
switch
(
this
.
m_config
.
colorType
)
{
case
gl
.
TEXTURE_2D
:
context
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
TEXTURE_2D
fboA
.
getColorBuffer
(
)
0
)
;
break
;
case
gl
.
RENDERBUFFER
:
context
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
fboA
.
getColorBuffer
(
)
)
;
break
;
default
:
throw
new
Error
(
'
Invalid
color
type
'
)
;
}
context
.
clear
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fboA
.
getFramebuffer
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
quadsTex
)
;
context
.
clearColor
(
0
.
0
0
.
0
0
.
0
1
.
0
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
if
(
stencil
)
{
context
.
clearStencil
(
1
)
;
context
.
clear
(
gl
.
STENCIL_BUFFER_BIT
)
;
}
texShader
.
setUniforms
(
context
texShaderID
)
;
context
.
enable
(
gl
.
DEPTH_TEST
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
disable
(
gl
.
DEPTH_TEST
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fboB
.
getFramebuffer
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
metaballsTex
)
;
context
.
enable
(
gl
.
BLEND
)
;
context
.
blendFuncSeparate
(
gl
.
SRC_ALPHA
gl
.
ONE_MINUS_SRC_ALPHA
gl
.
ZERO
gl
.
ONE
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
quadsTex
)
;
context
.
enable
(
gl
.
DEPTH_TEST
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
0
.
5
0
.
5
0
.
5
]
[
1
.
0
1
.
0
0
.
5
]
)
;
context
.
disable
(
gl
.
DEPTH_TEST
)
;
if
(
stencil
)
{
flatShader
.
setColor
(
context
flatShaderID
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
context
.
enable
(
gl
.
SCISSOR_TEST
)
;
context
.
scissor
(
10
10
12
25
)
;
context
.
clearStencil
(
1
)
;
context
.
clear
(
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
disable
(
gl
.
SCISSOR_TEST
)
;
context
.
enable
(
gl
.
STENCIL_TEST
)
;
context
.
stencilFunc
(
gl
.
EQUAL
1
0xff
)
;
rrUtil
.
drawQuad
(
context
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
disable
(
gl
.
STENCIL_TEST
)
;
}
if
(
fboA
.
getConfig
(
)
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
texShader
.
setUniforms
(
context
texShaderID
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
fboA
.
getColorBuffer
(
)
)
;
context
.
viewport
(
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
dst
.
readViewport
(
context
[
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
]
)
;
}
else
es3fFboTestUtil
.
readPixels
(
context
dst
0
0
width
height
gluTextureUtil
.
mapGLInternalFormat
(
fboA
.
getConfig
(
)
.
colorFormat
)
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
;
es3fFboRenderTest
.
SharedColorbufferClearsTest
=
function
(
config
)
{
es3fFboRenderTest
.
FboRenderCase
.
call
(
this
config
.
getName
(
)
'
Shared
colorbuffer
clears
'
config
)
;
}
;
es3fFboRenderTest
.
SharedColorbufferClearsTest
.
prototype
=
Object
.
create
(
es3fFboRenderTest
.
FboRenderCase
.
prototype
)
;
es3fFboRenderTest
.
SharedColorbufferClearsTest
.
prototype
.
constructor
=
es3fFboRenderTest
.
SharedColorbufferClearsTest
;
es3fFboRenderTest
.
SharedColorbufferClearsTest
.
prototype
.
render
=
function
(
context
dst
)
{
var
colorFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_config
.
colorFormat
)
;
var
fboSamplerType
=
gluTextureUtil
.
getSampler2DType
(
colorFormat
)
;
var
width
=
128
;
var
height
=
128
;
var
colorbuffer
=
this
.
m_config
.
colorType
=
=
gl
.
TEXTURE_2D
?
context
.
createTexture
(
)
:
context
.
createRenderbuffer
(
)
;
es3fFboRenderTest
.
checkColorFormatSupport
(
context
this
.
m_config
.
colorFormat
)
;
if
(
this
.
m_config
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
context
.
bindTexture
(
gl
.
TEXTURE_2D
colorbuffer
)
;
context
.
texImage2DDelegate
(
gl
.
TEXTURE_2D
0
this
.
m_config
.
colorFormat
width
height
)
;
context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
context
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
}
else
{
assertMsgOptions
(
this
.
m_config
.
colorType
=
=
gl
.
RENDERBUFFER
'
Not
a
render
buffer
type
'
false
true
)
;
context
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
colorbuffer
)
;
context
.
renderbufferStorage
(
gl
.
RENDERBUFFER
this
.
m_config
.
colorFormat
width
height
)
;
}
var
fbo
=
[
context
.
createFramebuffer
(
)
context
.
createFramebuffer
(
)
context
.
createFramebuffer
(
)
]
;
for
(
var
fboi
=
0
;
fboi
<
fbo
.
length
;
fboi
+
+
)
{
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
[
fboi
]
)
;
if
(
this
.
m_config
.
colorType
=
=
gl
.
TEXTURE_2D
)
context
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
TEXTURE_2D
colorbuffer
0
)
;
else
context
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
colorbuffer
)
;
}
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
[
0
]
)
;
var
status
=
context
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
if
(
status
!
=
gl
.
FRAMEBUFFER_COMPLETE
)
throw
new
es3fFboTestUtil
.
FboIncompleteException
(
status
)
;
context
.
viewport
(
0
0
width
height
)
;
context
.
clearColor
(
0
.
0
0
.
0
1
.
0
1
.
0
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
context
.
enable
(
gl
.
SCISSOR_TEST
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
[
1
]
)
;
context
.
clearColor
(
0
.
6
0
.
0
0
.
0
1
.
0
)
;
context
.
scissor
(
10
10
64
64
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
context
.
clearColor
(
0
.
0
0
.
6
0
.
0
1
.
0
)
;
context
.
scissor
(
60
60
40
20
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
[
2
]
)
;
context
.
clearColor
(
0
.
0
0
.
0
0
.
6
1
.
0
)
;
context
.
scissor
(
20
20
100
10
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
[
0
]
)
;
context
.
clearColor
(
0
.
6
0
.
0
0
.
6
1
.
0
)
;
context
.
scissor
(
20
20
5
100
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
)
;
context
.
disable
(
gl
.
SCISSOR_TEST
)
;
if
(
this
.
m_config
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
var
shader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
fboSamplerType
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
shaderID
=
context
.
createProgram
(
shader
)
;
shader
.
setUniforms
(
context
shaderID
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
context
.
viewport
(
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
)
;
rrUtil
.
drawQuad
(
context
shaderID
[
-
0
.
9
-
0
.
9
0
.
0
]
[
0
.
9
0
.
9
0
.
0
]
)
;
dst
.
readViewport
(
context
[
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
]
)
;
}
else
es3fFboTestUtil
.
readPixels
(
context
dst
0
0
width
height
colorFormat
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
for
(
fboi
=
0
;
fboi
<
fbo
.
length
;
fboi
+
+
)
context
.
deleteFramebuffer
(
fbo
[
fboi
]
)
;
if
(
this
.
m_config
.
colorType
=
=
gl
.
TEXTURE_2D
)
context
.
deleteTexture
(
colorbuffer
)
;
else
context
.
deleteRenderbuffer
(
colorbuffer
)
;
}
;
es3fFboRenderTest
.
SharedDepthStencilTest
=
function
(
config
)
{
es3fFboRenderTest
.
FboRenderCase
.
call
(
this
config
.
getName
(
)
'
Shared
depth
/
stencilbuffer
'
config
)
;
}
;
es3fFboRenderTest
.
SharedDepthStencilTest
.
prototype
=
Object
.
create
(
es3fFboRenderTest
.
FboRenderCase
.
prototype
)
;
es3fFboRenderTest
.
SharedDepthStencilTest
.
prototype
.
constructor
=
es3fFboRenderTest
.
SharedDepthStencilTest
;
es3fFboRenderTest
.
SharedDepthStencilTest
.
prototype
.
isConfigSupported
=
function
(
config
)
{
return
deMath
.
binaryOp
(
config
.
buffers
deMath
.
binaryOp
(
gl
.
DEPTH_BUFFER_BIT
gl
.
STENCIL_BUFFER_BIT
deMath
.
BinaryOp
.
OR
)
deMath
.
BinaryOp
.
AND
)
!
=
0
;
}
;
es3fFboRenderTest
.
SharedDepthStencilTest
.
prototype
.
render
=
function
(
context
dst
)
{
var
texShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
texShaderID
=
context
.
createProgram
(
texShader
)
;
var
flatShaderID
=
context
.
createProgram
(
flatShader
)
;
var
width
=
128
;
var
height
=
128
;
var
stencil
=
(
this
.
m_config
.
buffers
&
gl
.
STENCIL_BUFFER_BIT
)
!
=
0
;
var
metaballsTex
=
context
.
createTexture
(
)
;
var
quadsTex
=
context
.
createTexture
(
)
;
es3fFboRenderTest
.
createMetaballsTex2D
(
context
metaballsTex
gl
.
RGB
gl
.
UNSIGNED_BYTE
64
64
)
;
es3fFboRenderTest
.
createQuadsTex2D
(
context
quadsTex
gl
.
RGB
gl
.
UNSIGNED_BYTE
64
64
)
;
context
.
viewport
(
0
0
width
height
)
;
var
fboA
=
new
es3fFboRenderTest
.
Framebuffer
(
context
this
.
m_config
width
height
)
;
fboA
.
checkCompleteness
(
)
;
var
cfg
=
(
deUtil
.
clone
(
this
.
m_config
)
)
;
cfg
.
buffers
=
deMath
.
binaryOp
(
cfg
.
buffers
deMath
.
binaryNot
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
deMath
.
BinaryOp
.
AND
)
;
cfg
.
depthStencilType
=
gl
.
NONE
;
cfg
.
depthStencilFormat
=
gl
.
NONE
;
var
fboB
=
new
es3fFboRenderTest
.
Framebuffer
(
context
cfg
width
height
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fboB
.
getFramebuffer
(
)
)
;
for
(
var
ndx
=
0
;
ndx
<
2
;
ndx
+
+
)
{
var
bit
=
ndx
?
gl
.
STENCIL_BUFFER_BIT
:
gl
.
DEPTH_BUFFER_BIT
;
var
point
=
ndx
?
gl
.
STENCIL_ATTACHMENT
:
gl
.
DEPTH_ATTACHMENT
;
if
(
deMath
.
binaryOp
(
this
.
m_config
.
buffers
bit
deMath
.
BinaryOp
.
AND
)
=
=
0
)
continue
;
switch
(
this
.
m_config
.
depthStencilType
)
{
case
gl
.
TEXTURE_2D
:
context
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
point
gl
.
TEXTURE_2D
fboA
.
getDepthStencilBuffer
(
)
0
)
;
break
;
case
gl
.
RENDERBUFFER
:
context
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
point
gl
.
RENDERBUFFER
fboA
.
getDepthStencilBuffer
(
)
)
;
break
;
default
:
testFailed
(
'
Not
implemented
'
)
;
}
}
texShader
.
setUniforms
(
context
texShaderID
)
;
context
.
clearColor
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
context
.
clearStencil
(
1
)
;
context
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
enable
(
gl
.
DEPTH_TEST
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fboA
.
getFramebuffer
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
quadsTex
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
if
(
stencil
)
{
context
.
enable
(
gl
.
SCISSOR_TEST
)
;
context
.
scissor
(
10
10
12
25
)
;
context
.
clearStencil
(
0
)
;
context
.
clear
(
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
disable
(
gl
.
SCISSOR_TEST
)
;
}
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fboB
.
getFramebuffer
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
metaballsTex
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
-
1
.
0
-
1
.
0
-
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
)
;
context
.
disable
(
gl
.
DEPTH_TEST
)
;
if
(
stencil
)
{
context
.
enable
(
gl
.
STENCIL_TEST
)
;
context
.
stencilFunc
(
gl
.
EQUAL
0
0xff
)
;
context
.
useProgram
(
flatShaderID
)
;
flatShader
.
setColor
(
context
flatShaderID
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
rrUtil
.
drawQuad
(
context
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
disable
(
gl
.
STENCIL_TEST
)
;
}
if
(
this
.
m_config
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
context
.
viewport
(
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
fboA
.
getColorBuffer
(
)
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
0
.
0
1
.
0
0
.
0
]
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
fboB
.
getColorBuffer
(
)
)
;
rrUtil
.
drawQuad
(
context
texShaderID
[
0
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
dst
.
readViewport
(
context
[
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
]
)
;
}
else
{
es3fFboTestUtil
.
readPixels
(
context
dst
0
0
width
height
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_config
.
colorFormat
)
[
1
.
0
1
.
0
1
.
0
1
.
0
]
[
0
.
0
0
.
0
0
.
0
0
.
0
]
)
;
}
}
;
es3fFboRenderTest
.
ResizeTest
=
function
(
config
)
{
es3fFboRenderTest
.
FboRenderCase
.
call
(
this
config
.
getName
(
)
'
Resize
framebuffer
'
config
)
;
}
;
es3fFboRenderTest
.
ResizeTest
.
prototype
=
Object
.
create
(
es3fFboRenderTest
.
FboRenderCase
.
prototype
)
;
es3fFboRenderTest
.
ResizeTest
.
prototype
.
constructor
=
es3fFboRenderTest
.
ResizeTest
;
es3fFboRenderTest
.
ResizeTest
.
prototype
.
render
=
function
(
context
dst
)
{
var
colorFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_config
.
colorFormat
)
;
var
fboSamplerType
=
gluTextureUtil
.
getSampler2DType
(
colorFormat
)
;
var
fboOutputType
=
es3fFboTestUtil
.
getFragmentOutputType
(
colorFormat
)
;
var
fboRangeInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
colorFormat
)
;
var
fboOutScale
=
deMath
.
subtract
(
fboRangeInfo
.
valueMax
fboRangeInfo
.
valueMin
)
;
var
fboOutBias
=
fboRangeInfo
.
valueMin
;
var
texToFboShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
fboOutputType
)
;
var
texFromFboShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
fboSamplerType
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
fboOutputType
)
;
var
texToFboShaderID
=
context
.
createProgram
(
texToFboShader
)
;
var
texFromFboShaderID
=
context
.
createProgram
(
texFromFboShader
)
;
var
flatShaderID
=
context
.
createProgram
(
flatShader
)
;
var
quadsTex
=
context
.
createTexture
(
)
;
var
metaballsTex
=
context
.
createTexture
(
)
;
var
depth
=
deMath
.
binaryOp
(
this
.
m_config
.
buffers
gl
.
DEPTH_BUFFER_BIT
deMath
.
BinaryOp
.
AND
)
!
=
0
;
var
stencil
=
deMath
.
binaryOp
(
this
.
m_config
.
buffers
gl
.
STENCIL_BUFFER_BIT
deMath
.
BinaryOp
.
AND
)
!
=
0
;
var
initialWidth
=
128
;
var
initialHeight
=
128
;
var
newWidth
=
64
;
var
newHeight
=
32
;
texToFboShader
.
setOutScaleBias
(
fboOutScale
fboOutBias
)
;
texFromFboShader
.
setTexScaleBias
(
0
fboRangeInfo
.
lookupScale
fboRangeInfo
.
lookupBias
)
;
es3fFboRenderTest
.
createQuadsTex2D
(
context
quadsTex
gl
.
RGB
gl
.
UNSIGNED_BYTE
64
64
)
;
es3fFboRenderTest
.
createMetaballsTex2D
(
context
metaballsTex
gl
.
RGB
gl
.
UNSIGNED_BYTE
32
32
)
;
var
fbo
=
new
es3fFboRenderTest
.
Framebuffer
(
context
this
.
m_config
initialWidth
initialHeight
)
;
fbo
.
checkCompleteness
(
)
;
texToFboShader
.
setUniforms
(
context
texToFboShaderID
)
;
texFromFboShader
.
setUniforms
(
context
texFromFboShaderID
)
;
flatShader
.
setColor
(
context
flatShaderID
deMath
.
add
(
deMath
.
multiply
(
[
0
.
0
1
.
0
0
.
0
1
.
0
]
fboOutScale
)
fboOutBias
)
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
.
getFramebuffer
(
)
)
;
context
.
viewport
(
0
0
initialWidth
initialHeight
)
;
es3fFboTestUtil
.
clearColorBuffer
(
context
colorFormat
[
0
.
0
0
.
0
0
.
0
1
.
0
]
)
;
context
.
clear
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
quadsTex
)
;
rrUtil
.
drawQuad
(
context
texToFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
if
(
fbo
.
getConfig
(
)
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
context
.
viewport
(
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
fbo
.
getColorBuffer
(
)
)
;
rrUtil
.
drawQuad
(
context
texFromFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
.
getFramebuffer
(
)
)
;
}
switch
(
fbo
.
getConfig
(
)
.
colorType
)
{
case
gl
.
TEXTURE_2D
:
context
.
bindTexture
(
gl
.
TEXTURE_2D
fbo
.
getColorBuffer
(
)
)
;
context
.
texImage2DDelegate
(
gl
.
TEXTURE_2D
0
fbo
.
getConfig
(
)
.
colorFormat
newWidth
newHeight
)
;
break
;
case
gl
.
RENDERBUFFER
:
context
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
fbo
.
getColorBuffer
(
)
)
;
context
.
renderbufferStorage
(
gl
.
RENDERBUFFER
fbo
.
getConfig
(
)
.
colorFormat
newWidth
newHeight
)
;
break
;
default
:
throw
new
Error
(
'
Color
type
unsupported
'
)
;
}
if
(
depth
|
|
stencil
)
{
switch
(
fbo
.
getConfig
(
)
.
depthStencilType
)
{
case
gl
.
TEXTURE_2D
:
context
.
bindTexture
(
gl
.
TEXTURE_2D
fbo
.
getDepthStencilBuffer
(
)
)
;
context
.
texImage2DDelegate
(
gl
.
TEXTURE_2D
0
fbo
.
getConfig
(
)
.
depthStencilFormat
newWidth
newHeight
)
;
break
;
case
gl
.
RENDERBUFFER
:
context
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
fbo
.
getDepthStencilBuffer
(
)
)
;
context
.
renderbufferStorage
(
gl
.
RENDERBUFFER
fbo
.
getConfig
(
)
.
depthStencilFormat
newWidth
newHeight
)
;
break
;
default
:
throw
new
Error
(
'
Depth
/
stencil
type
unsupported
'
)
;
}
}
context
.
viewport
(
0
0
newWidth
newHeight
)
;
es3fFboTestUtil
.
clearColorBuffer
(
context
colorFormat
[
1
.
0
0
.
0
0
.
0
1
.
0
]
)
;
context
.
clear
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
enable
(
gl
.
DEPTH_TEST
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
metaballsTex
)
;
rrUtil
.
drawQuad
(
context
texToFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
quadsTex
)
;
rrUtil
.
drawQuad
(
context
texToFboShaderID
[
0
.
0
0
.
0
-
1
.
0
]
[
1
.
0
1
.
0
1
.
0
]
)
;
context
.
disable
(
gl
.
DEPTH_TEST
)
;
if
(
stencil
)
{
context
.
enable
(
gl
.
SCISSOR_TEST
)
;
context
.
clearStencil
(
1
)
;
context
.
scissor
(
10
10
5
15
)
;
context
.
clear
(
gl
.
STENCIL_BUFFER_BIT
)
;
context
.
disable
(
gl
.
SCISSOR_TEST
)
;
context
.
enable
(
gl
.
STENCIL_TEST
)
;
context
.
stencilFunc
(
gl
.
EQUAL
1
0xff
)
;
rrUtil
.
drawQuad
(
context
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
context
.
disable
(
gl
.
STENCIL_TEST
)
;
}
if
(
this
.
m_config
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
context
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
context
.
viewport
(
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
)
;
context
.
bindTexture
(
gl
.
TEXTURE_2D
fbo
.
getColorBuffer
(
)
)
;
rrUtil
.
drawQuad
(
context
texFromFboShaderID
[
-
0
.
5
-
0
.
5
0
.
0
]
[
0
.
5
0
.
5
0
.
0
]
)
;
dst
.
readViewport
(
context
[
0
0
context
.
getWidth
(
)
context
.
getHeight
(
)
]
)
;
}
else
es3fFboTestUtil
.
readPixels
(
context
dst
0
0
newWidth
newHeight
colorFormat
fboRangeInfo
.
lookupScale
fboRangeInfo
.
lookupBias
)
;
}
;
es3fFboRenderTest
.
RecreateBuffersTest
=
function
(
config
buffers
rebind
)
{
es3fFboRenderTest
.
FboRenderCase
.
call
(
this
config
.
getName
(
)
+
(
rebind
?
'
'
:
'
_no_rebind
'
)
'
Recreate
buffers
'
config
)
;
this
.
m_buffers
=
buffers
;
this
.
m_rebind
=
rebind
;
}
;
es3fFboRenderTest
.
RecreateBuffersTest
.
prototype
=
Object
.
create
(
es3fFboRenderTest
.
FboRenderCase
.
prototype
)
;
es3fFboRenderTest
.
RecreateBuffersTest
.
prototype
.
construtor
=
es3fFboRenderTest
.
RecreateBuffersTest
;
es3fFboRenderTest
.
RecreateBuffersTest
.
prototype
.
render
=
function
(
ctx
dst
)
{
var
colorFormat
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_config
.
colorFormat
)
;
var
fboSamplerType
=
gluTextureUtil
.
getSampler2DType
(
colorFormat
)
;
var
fboOutputType
=
es3fFboTestUtil
.
getFragmentOutputType
(
colorFormat
)
;
var
fboRangeInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
colorFormat
)
;
var
fboOutScale
=
deMath
.
subtract
(
fboRangeInfo
.
valueMax
fboRangeInfo
.
valueMin
)
;
var
fboOutBias
=
fboRangeInfo
.
valueMin
;
var
texToFboShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
gluShaderUtil
.
DataType
.
SAMPLER_2D
]
fboOutputType
)
;
var
texFromFboShader
=
new
es3fFboTestUtil
.
Texture2DShader
(
[
fboSamplerType
]
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
var
flatShader
=
new
es3fFboTestUtil
.
FlatColorShader
(
fboOutputType
)
;
var
texToFboShaderID
=
ctx
.
createProgram
(
texToFboShader
)
;
var
texFromFboShaderID
=
ctx
.
createProgram
(
texFromFboShader
)
;
var
flatShaderID
=
ctx
.
createProgram
(
flatShader
)
;
var
width
=
128
;
var
height
=
128
;
var
metaballsTex
=
ctx
.
createTexture
(
)
;
var
quadsTex
=
ctx
.
createTexture
(
)
;
var
stencil
=
deMath
.
binaryOp
(
this
.
m_config
.
buffers
gl
.
STENCIL_BUFFER_BIT
deMath
.
BinaryOp
.
AND
)
!
=
0
;
es3fFboRenderTest
.
createQuadsTex2D
(
ctx
quadsTex
gl
.
RGB
gl
.
UNSIGNED_BYTE
64
64
)
;
es3fFboRenderTest
.
createMetaballsTex2D
(
ctx
metaballsTex
gl
.
RGB
gl
.
UNSIGNED_BYTE
64
64
)
;
var
fbo
=
new
es3fFboRenderTest
.
Framebuffer
(
ctx
this
.
m_config
width
height
)
;
fbo
.
checkCompleteness
(
)
;
texToFboShader
.
setOutScaleBias
(
fboOutScale
fboOutBias
)
;
texFromFboShader
.
setTexScaleBias
(
0
fboRangeInfo
.
lookupScale
fboRangeInfo
.
lookupBias
)
;
texToFboShader
.
setUniforms
(
ctx
texToFboShaderID
)
;
texFromFboShader
.
setUniforms
(
ctx
texFromFboShaderID
)
;
flatShader
.
setColor
(
ctx
flatShaderID
deMath
.
add
(
deMath
.
multiply
(
[
0
.
0
0
.
0
1
.
0
1
.
0
]
fboOutScale
)
fboOutBias
)
)
;
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
.
getFramebuffer
(
)
)
;
ctx
.
viewport
(
0
0
width
height
)
;
es3fFboTestUtil
.
clearColorBuffer
(
ctx
colorFormat
[
1
.
0
0
.
0
0
.
0
1
.
0
]
)
;
ctx
.
clear
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
ctx
.
enable
(
gl
.
DEPTH_TEST
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
quadsTex
)
;
rrUtil
.
drawQuad
(
ctx
texToFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
ctx
.
disable
(
gl
.
DEPTH_TEST
)
;
if
(
stencil
)
{
ctx
.
enable
(
gl
.
SCISSOR_TEST
)
;
ctx
.
scissor
(
Math
.
floor
(
width
/
4
)
Math
.
floor
(
height
/
4
)
Math
.
floor
(
width
/
2
)
Math
.
floor
(
height
/
2
)
)
;
ctx
.
clearStencil
(
1
)
;
ctx
.
clear
(
gl
.
STENCIL_BUFFER_BIT
)
;
ctx
.
disable
(
gl
.
SCISSOR_TEST
)
;
}
if
(
!
this
.
m_rebind
)
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
assertMsgOptions
(
deMath
.
binaryOp
(
this
.
m_buffers
deMath
.
binaryOp
(
gl
.
DEPTH_BUFFER_BIT
gl
.
STENCIL_BUFFER_BIT
deMath
.
BinaryOp
.
OR
)
deMath
.
BinaryOp
.
AND
)
=
=
0
|
|
deMath
.
binaryOp
(
this
.
m_buffers
deMath
.
binaryOp
(
gl
.
DEPTH_BUFFER_BIT
gl
.
STENCIL_BUFFER_BIT
deMath
.
BinaryOp
.
OR
)
deMath
.
BinaryOp
.
AND
)
=
=
deMath
.
binaryOp
(
this
.
m_config
.
buffers
deMath
.
binaryOp
(
gl
.
DEPTH_BUFFER_BIT
gl
.
STENCIL_BUFFER_BIT
deMath
.
BinaryOp
.
OR
)
deMath
.
BinaryOp
.
AND
)
'
Depth
/
stencil
buffers
are
not
disabled
or
not
'
+
'
equal
to
the
config
\
'
s
depth
/
stencil
buffer
state
'
false
true
)
;
for
(
var
ndx
=
0
;
ndx
<
2
;
ndx
+
+
)
{
var
bit
=
ndx
=
=
0
?
gl
.
COLOR_BUFFER_BIT
:
(
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
var
type
=
ndx
=
=
0
?
fbo
.
getConfig
(
)
.
colorType
:
fbo
.
getConfig
(
)
.
depthStencilType
;
var
format
=
ndx
=
=
0
?
fbo
.
getConfig
(
)
.
colorFormat
:
fbo
.
getConfig
(
)
.
depthStencilFormat
;
var
buf
=
ndx
=
=
0
?
fbo
.
getColorBuffer
(
)
:
fbo
.
getDepthStencilBuffer
(
)
;
if
(
deMath
.
binaryOp
(
this
.
m_buffers
bit
deMath
.
BinaryOp
.
AND
)
=
=
0
)
continue
;
switch
(
type
)
{
case
gl
.
TEXTURE_2D
:
ctx
.
deleteTexture
(
(
buf
)
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
buf
)
;
ctx
.
texImage2DDelegate
(
gl
.
TEXTURE_2D
0
format
width
height
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
ctx
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
break
;
case
gl
.
RENDERBUFFER
:
ctx
.
deleteRenderbuffer
(
(
buf
)
)
;
ctx
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
buf
)
;
ctx
.
renderbufferStorage
(
gl
.
RENDERBUFFER
format
width
height
)
;
break
;
default
:
throw
new
Error
(
'
Unsupported
buffer
type
'
)
;
}
}
if
(
this
.
m_rebind
)
{
for
(
var
ndx
=
0
;
ndx
<
3
;
ndx
+
+
)
{
var
bit
=
ndx
=
=
0
?
gl
.
COLOR_BUFFER_BIT
:
ndx
=
=
1
?
gl
.
DEPTH_BUFFER_BIT
:
ndx
=
=
2
?
gl
.
STENCIL_BUFFER_BIT
:
0
;
var
point
=
ndx
=
=
0
?
gl
.
COLOR_ATTACHMENT0
:
ndx
=
=
1
?
gl
.
DEPTH_ATTACHMENT
:
ndx
=
=
2
?
gl
.
STENCIL_ATTACHMENT
:
0
;
var
type
=
ndx
=
=
0
?
fbo
.
getConfig
(
)
.
colorType
:
fbo
.
getConfig
(
)
.
depthStencilType
;
var
buf
=
ndx
=
=
0
?
fbo
.
getColorBuffer
(
)
:
fbo
.
getDepthStencilBuffer
(
)
;
if
(
deMath
.
binaryOp
(
this
.
m_buffers
bit
deMath
.
BinaryOp
.
AND
)
=
=
0
)
continue
;
switch
(
type
)
{
case
gl
.
TEXTURE_2D
:
ctx
.
framebufferTexture2D
(
gl
.
FRAMEBUFFER
point
gl
.
TEXTURE_2D
buf
0
)
;
break
;
case
gl
.
RENDERBUFFER
:
ctx
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
point
gl
.
RENDERBUFFER
buf
)
;
break
;
default
:
throw
new
Error
(
'
Invalid
buffer
type
'
)
;
}
}
}
if
(
!
this
.
m_rebind
)
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
.
getFramebuffer
(
)
)
;
ctx
.
clearStencil
(
0
)
;
ctx
.
clear
(
deMath
.
binaryOp
(
this
.
m_buffers
deMath
.
binaryOp
(
gl
.
DEPTH_BUFFER_BIT
gl
.
STENCIL_BUFFER_BIT
deMath
.
BinaryOp
.
OR
)
deMath
.
BinaryOp
.
AND
)
)
;
if
(
deMath
.
binaryOp
(
this
.
m_buffers
gl
.
COLOR_BUFFER_BIT
deMath
.
BinaryOp
.
AND
)
)
{
rrUtil
.
drawQuad
(
ctx
flatShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
}
ctx
.
enable
(
gl
.
DEPTH_TEST
)
;
if
(
stencil
)
{
ctx
.
enable
(
gl
.
STENCIL_TEST
)
;
ctx
.
stencilFunc
(
gl
.
EQUAL
0
0xff
)
;
}
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
metaballsTex
)
;
rrUtil
.
drawQuad
(
ctx
texToFboShaderID
[
-
1
.
0
-
1
.
0
1
.
0
]
[
1
.
0
1
.
0
-
1
.
0
]
)
;
if
(
stencil
)
ctx
.
disable
(
gl
.
STENCIL_TEST
)
;
ctx
.
disable
(
gl
.
DEPTH_TEST
)
;
if
(
fbo
.
getConfig
(
)
.
colorType
=
=
gl
.
TEXTURE_2D
)
{
ctx
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
ctx
.
bindTexture
(
gl
.
TEXTURE_2D
fbo
.
getColorBuffer
(
)
)
;
ctx
.
viewport
(
0
0
ctx
.
getWidth
(
)
ctx
.
getHeight
(
)
)
;
rrUtil
.
drawQuad
(
ctx
texFromFboShaderID
[
-
1
.
0
-
1
.
0
0
.
0
]
[
1
.
0
1
.
0
0
.
0
]
)
;
dst
.
readViewport
(
ctx
[
0
0
ctx
.
getWidth
(
)
ctx
.
getHeight
(
)
]
)
;
}
else
{
es3fFboTestUtil
.
readPixels
(
ctx
dst
0
0
width
height
colorFormat
fboRangeInfo
.
lookupScale
fboRangeInfo
.
lookupBias
)
;
}
}
;
es3fFboRenderTest
.
FboRenderTestGroup
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
render
'
'
Rendering
Tests
'
)
;
}
;
es3fFboRenderTest
.
FboRenderTestGroup
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fFboRenderTest
.
FboRenderTestGroup
.
prototype
.
constructor
=
es3fFboRenderTest
.
FboRenderTestGroup
;
var
FormatType
=
{
FLOAT
:
0
INT
:
1
UINT
:
2
}
;
var
ColorFormatStruct
;
var
DepthStencilFormatStruct
;
es3fFboRenderTest
.
FboRenderTestGroup
.
prototype
.
init
=
function
(
)
{
var
objectTypes
=
[
gl
.
TEXTURE_2D
gl
.
RENDERBUFFER
]
;
var
colorFormats
=
[
{
format
:
gl
.
RGBA32F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
RGBA32I
type
:
FormatType
.
INT
}
{
format
:
gl
.
RGBA32UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
RGBA16F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
RGBA16I
type
:
FormatType
.
INT
}
{
format
:
gl
.
RGBA16UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
RGB16F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
RGBA8I
type
:
FormatType
.
INT
}
{
format
:
gl
.
RGBA8UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
RGB10_A2UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
R11F_G11F_B10F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
RG32F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
RG32I
type
:
FormatType
.
INT
}
{
format
:
gl
.
RG32UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
RG16F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
RG16I
type
:
FormatType
.
INT
}
{
format
:
gl
.
RG16UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
RG8
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
RG8I
type
:
FormatType
.
INT
}
{
format
:
gl
.
RG8UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
R32F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
R32I
type
:
FormatType
.
INT
}
{
format
:
gl
.
R32UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
R16F
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
R16I
type
:
FormatType
.
INT
}
{
format
:
gl
.
R16UI
type
:
FormatType
.
UINT
}
{
format
:
gl
.
R8
type
:
FormatType
.
FLOAT
}
{
format
:
gl
.
R8I
type
:
FormatType
.
INT
}
{
format
:
gl
.
R8UI
type
:
FormatType
.
UINT
}
]
;
var
depthStencilFormats
=
[
{
format
:
gl
.
DEPTH_COMPONENT32F
depth
:
true
stencil
:
false
}
{
format
:
gl
.
DEPTH_COMPONENT24
depth
:
true
stencil
:
false
}
{
format
:
gl
.
DEPTH_COMPONENT16
depth
:
true
stencil
:
false
}
{
format
:
gl
.
DEPTH32F_STENCIL8
depth
:
true
stencil
:
true
}
{
format
:
gl
.
DEPTH24_STENCIL8
depth
:
true
stencil
:
true
}
{
format
:
gl
.
STENCIL_INDEX8
depth
:
false
stencil
:
true
}
]
;
var
config
;
var
colorType
;
var
stencilType
;
var
colorFmt
;
var
depth
;
var
stencil
;
var
depthStencilType
;
var
depthStencilFormat
;
var
stencilClearGroup
=
new
tcuTestCase
.
DeqpTest
(
'
stencil_clear
'
'
Stencil
buffer
clears
'
)
;
this
.
addChild
(
stencilClearGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
depthStencilFormats
.
length
;
fmtNdx
+
+
)
{
colorType
=
gl
.
TEXTURE_2D
;
stencilType
=
gl
.
RENDERBUFFER
;
colorFmt
=
gl
.
RGBA8
;
if
(
!
depthStencilFormats
[
fmtNdx
]
.
stencil
)
continue
;
config
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
colorType
colorFmt
stencilType
depthStencilFormats
[
fmtNdx
]
.
format
)
;
stencilClearGroup
.
addChild
(
new
es3fFboRenderTest
.
StencilClearsTest
(
config
)
)
;
}
var
sharedColorbufferClearGroup
=
new
tcuTestCase
.
DeqpTest
(
'
shared_colorbuffer_clear
'
'
Shader
colorbuffer
clears
'
)
;
this
.
addChild
(
sharedColorbufferClearGroup
)
;
for
(
var
colorFmtNdx
=
0
;
colorFmtNdx
<
colorFormats
.
length
;
colorFmtNdx
+
+
)
{
if
(
colorFormats
[
colorFmtNdx
]
.
type
=
=
FormatType
.
INT
|
|
colorFormats
[
colorFmtNdx
]
.
type
=
=
FormatType
.
UINT
)
continue
;
for
(
var
typeNdx
=
0
;
typeNdx
<
objectTypes
.
length
;
typeNdx
+
+
)
{
config
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
objectTypes
[
typeNdx
]
colorFormats
[
colorFmtNdx
]
.
format
gl
.
NONE
gl
.
NONE
)
;
sharedColorbufferClearGroup
.
addChild
(
new
es3fFboRenderTest
.
SharedColorbufferClearsTest
(
config
)
)
;
}
}
var
sharedColorbufferGroup
=
new
tcuTestCase
.
DeqpTest
(
'
shared_colorbuffer
'
'
Shared
colorbuffer
tests
'
)
;
this
.
addChild
(
sharedColorbufferGroup
)
;
for
(
var
colorFmtNdx
=
0
;
colorFmtNdx
<
colorFormats
.
length
;
colorFmtNdx
+
+
)
{
depthStencilType
=
gl
.
RENDERBUFFER
;
depthStencilFormat
=
gl
.
DEPTH24_STENCIL8
;
if
(
colorFormats
[
colorFmtNdx
]
.
type
=
=
FormatType
.
INT
|
|
colorFormats
[
colorFmtNdx
]
.
type
=
=
FormatType
.
UINT
|
|
colorFormats
[
colorFmtNdx
]
.
format
=
=
gl
.
RGBA32F
|
|
colorFormats
[
colorFmtNdx
]
.
format
=
=
gl
.
RGB32F
|
|
colorFormats
[
colorFmtNdx
]
.
format
=
=
gl
.
RG32F
|
|
colorFormats
[
colorFmtNdx
]
.
format
=
=
gl
.
R32F
)
continue
;
for
(
var
typeNdx
=
0
;
typeNdx
<
objectTypes
.
length
;
typeNdx
+
+
)
{
var
colorOnlyConfig
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
objectTypes
[
typeNdx
]
colorFormats
[
colorFmtNdx
]
.
format
gl
.
NONE
gl
.
NONE
)
;
var
colorDepthConfig
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
objectTypes
[
typeNdx
]
colorFormats
[
colorFmtNdx
]
.
format
depthStencilType
depthStencilFormat
)
;
var
colorDepthStencilConfig
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
objectTypes
[
typeNdx
]
colorFormats
[
colorFmtNdx
]
.
format
depthStencilType
depthStencilFormat
)
;
sharedColorbufferGroup
.
addChild
(
new
es3fFboRenderTest
.
SharedColorbufferTest
(
colorOnlyConfig
)
)
;
sharedColorbufferGroup
.
addChild
(
new
es3fFboRenderTest
.
SharedColorbufferTest
(
colorDepthConfig
)
)
;
sharedColorbufferGroup
.
addChild
(
new
es3fFboRenderTest
.
SharedColorbufferTest
(
colorDepthStencilConfig
)
)
;
}
}
var
sharedDepthStencilGroup
=
new
tcuTestCase
.
DeqpTest
(
'
shared_depth_stencil
'
'
Shared
depth
and
stencil
buffers
'
)
;
this
.
addChild
(
sharedDepthStencilGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
depthStencilFormats
.
length
;
fmtNdx
+
+
)
{
colorType
=
gl
.
TEXTURE_2D
;
colorFmt
=
gl
.
RGBA8
;
depth
=
depthStencilFormats
[
fmtNdx
]
.
depth
;
stencil
=
depthStencilFormats
[
fmtNdx
]
.
stencil
;
if
(
!
depth
)
continue
;
for
(
var
typeNdx
=
0
;
typeNdx
<
objectTypes
.
length
;
typeNdx
+
+
)
{
config
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
|
(
depth
?
gl
.
DEPTH_BUFFER_BIT
:
0
)
|
(
stencil
?
gl
.
STENCIL_BUFFER_BIT
:
0
)
colorType
colorFmt
objectTypes
[
typeNdx
]
depthStencilFormats
[
fmtNdx
]
.
format
)
;
sharedDepthStencilGroup
.
addChild
(
new
es3fFboRenderTest
.
SharedDepthStencilTest
(
config
)
)
;
}
}
var
resizeGroup
=
new
tcuTestCase
.
DeqpTest
(
'
resize
'
'
FBO
resize
tests
'
)
;
this
.
addChild
(
resizeGroup
)
;
for
(
var
colorFmtNdx
=
0
;
colorFmtNdx
<
colorFormats
.
length
;
colorFmtNdx
+
+
)
{
var
colorFormat
=
colorFormats
[
colorFmtNdx
]
.
format
;
for
(
var
typeNdx
=
0
;
typeNdx
<
objectTypes
.
length
;
typeNdx
+
+
)
{
config
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
objectTypes
[
typeNdx
]
colorFormat
gl
.
NONE
gl
.
NONE
)
;
resizeGroup
.
addChild
(
new
es3fFboRenderTest
.
ResizeTest
(
config
)
)
;
}
if
(
colorFormat
=
=
gl
.
RGBA8
|
|
colorFormat
=
=
gl
.
RGBA16F
)
{
for
(
var
depthStencilFmtNdx
=
0
;
depthStencilFmtNdx
<
depthStencilFormats
.
length
;
depthStencilFmtNdx
+
+
)
{
colorType
=
gl
.
TEXTURE_2D
;
depth
=
depthStencilFormats
[
depthStencilFmtNdx
]
.
depth
;
stencil
=
depthStencilFormats
[
depthStencilFmtNdx
]
.
stencil
;
for
(
var
typeNdx
=
0
;
typeNdx
<
objectTypes
.
length
;
typeNdx
+
+
)
{
if
(
!
depth
&
&
objectTypes
[
typeNdx
]
!
=
gl
.
RENDERBUFFER
)
continue
;
config
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
|
(
depth
?
gl
.
DEPTH_BUFFER_BIT
:
0
)
|
(
stencil
?
gl
.
STENCIL_BUFFER_BIT
:
0
)
colorType
colorFormat
objectTypes
[
typeNdx
]
depthStencilFormats
[
depthStencilFmtNdx
]
.
format
)
;
resizeGroup
.
addChild
(
new
es3fFboRenderTest
.
ResizeTest
(
config
)
)
;
}
}
}
}
var
recreateColorGroup
=
new
tcuTestCase
.
DeqpTest
(
'
recreate_color
'
'
Recreate
colorbuffer
tests
'
)
;
this
.
addChild
(
recreateColorGroup
)
;
for
(
var
colorFmtNdx
=
0
;
colorFmtNdx
<
colorFormats
.
length
;
colorFmtNdx
+
+
)
{
colorFormat
=
colorFormats
[
colorFmtNdx
]
.
format
;
depthStencilFormat
=
gl
.
DEPTH24_STENCIL8
;
depthStencilType
=
gl
.
RENDERBUFFER
;
for
(
var
typeNdx
=
0
;
typeNdx
<
objectTypes
.
length
;
typeNdx
+
+
)
{
config
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
objectTypes
[
typeNdx
]
colorFormat
depthStencilType
depthStencilFormat
)
;
recreateColorGroup
.
addChild
(
new
es3fFboRenderTest
.
RecreateBuffersTest
(
config
gl
.
COLOR_BUFFER_BIT
true
)
)
;
}
}
var
recreateDepthStencilGroup
=
new
tcuTestCase
.
DeqpTest
(
'
recreate_depth_stencil
'
'
Recreate
depth
and
stencil
buffers
'
)
;
this
.
addChild
(
recreateDepthStencilGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
depthStencilFormats
.
length
;
fmtNdx
+
+
)
{
colorType
=
gl
.
TEXTURE_2D
;
colorFmt
=
gl
.
RGBA8
;
depth
=
depthStencilFormats
[
fmtNdx
]
.
depth
;
stencil
=
depthStencilFormats
[
fmtNdx
]
.
stencil
;
for
(
var
typeNdx
=
0
;
typeNdx
<
objectTypes
.
length
;
typeNdx
+
+
)
{
if
(
!
depth
&
&
objectTypes
[
typeNdx
]
!
=
gl
.
RENDERBUFFER
)
continue
;
config
=
new
es3fFboRenderTest
.
FboConfig
(
gl
.
COLOR_BUFFER_BIT
|
(
depth
?
gl
.
DEPTH_BUFFER_BIT
:
0
)
|
(
stencil
?
gl
.
STENCIL_BUFFER_BIT
:
0
)
colorType
colorFmt
objectTypes
[
typeNdx
]
depthStencilFormats
[
fmtNdx
]
.
format
)
;
recreateDepthStencilGroup
.
addChild
(
new
es3fFboRenderTest
.
RecreateBuffersTest
(
config
(
depth
?
gl
.
DEPTH_BUFFER_BIT
:
0
)
|
(
stencil
?
gl
.
STENCIL_BUFFER_BIT
:
0
)
true
)
)
;
}
}
}
;
es3fFboRenderTest
.
run
=
function
(
context
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
state
.
setRoot
(
new
es3fFboRenderTest
.
FboRenderTestGroup
(
)
)
;
setCurrentTestName
(
state
.
testCases
.
fullName
(
)
)
;
description
(
state
.
testCases
.
getDescription
(
)
)
;
try
{
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
