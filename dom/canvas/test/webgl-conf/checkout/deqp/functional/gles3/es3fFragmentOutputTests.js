'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fFragmentOutputTests
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
functional
.
gles3
.
es3fFboTestUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fFragmentOutputTests
=
functional
.
gles3
.
es3fFragmentOutputTests
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
es3fFboTestUtil
=
functional
.
gles3
.
es3fFboTestUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
gl
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
es3fFragmentOutputTests
.
BufferSpec
=
function
(
format_
width_
height_
samples_
)
{
this
.
format
=
format_
;
this
.
width
=
width_
;
this
.
height
=
height_
;
this
.
samples
=
samples_
;
}
;
es3fFragmentOutputTests
.
FragmentOutput
=
function
(
type_
precision_
location_
arrayLength_
)
{
this
.
type
=
type_
;
this
.
precision
=
precision_
;
this
.
location
=
location_
;
this
.
arrayLength
=
arrayLength_
|
|
0
;
}
;
es3fFragmentOutputTests
.
FragmentOutputCase
=
function
(
name
description
fboSpec
outputs
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_fboSpec
=
fboSpec
;
this
.
m_outputs
=
outputs
;
this
.
m_program
=
null
;
this
.
m_framebuffer
=
null
;
this
.
m_renderbuffer
=
null
;
}
;
es3fFragmentOutputTests
.
FragmentOutputCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fFragmentOutputTests
.
FragmentOutputCase
.
prototype
.
constructor
=
es3fFragmentOutputTests
.
FragmentOutputCase
;
es3fFragmentOutputTests
.
createProgram
=
function
(
outputs
)
{
var
vtx
=
'
'
;
var
frag
=
'
'
;
vtx
=
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
;
frag
=
'
#
version
300
es
\
n
'
;
var
output
=
null
;
var
isArray
=
false
;
for
(
var
outNdx
=
0
;
outNdx
<
outputs
.
length
;
outNdx
+
+
)
{
output
=
outputs
[
outNdx
]
;
isArray
=
output
.
arrayLength
>
0
;
var
typeName
=
gluShaderUtil
.
getDataTypeName
(
output
.
type
)
;
var
precName
=
gluShaderUtil
.
getPrecisionName
(
output
.
precision
)
;
var
isFloat
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
output
.
type
)
;
var
interp
=
isFloat
?
'
smooth
'
:
'
flat
'
;
if
(
isArray
)
{
for
(
var
elemNdx
=
0
;
elemNdx
<
output
.
arrayLength
;
elemNdx
+
+
)
{
vtx
+
=
'
in
'
+
precName
+
'
'
+
typeName
+
'
in
'
+
outNdx
+
'
_
'
+
elemNdx
+
'
;
\
n
'
+
interp
+
'
out
'
+
precName
+
'
'
+
typeName
+
'
var
'
+
outNdx
+
'
_
'
+
elemNdx
+
'
;
\
n
'
;
frag
+
=
interp
+
'
in
'
+
precName
+
'
'
+
typeName
+
'
var
'
+
outNdx
+
'
_
'
+
elemNdx
+
'
;
\
n
'
;
}
frag
+
=
'
layout
(
location
=
'
+
output
.
location
+
'
)
out
'
+
precName
+
'
'
+
typeName
+
'
out
'
+
outNdx
+
'
[
'
+
output
.
arrayLength
+
'
]
;
\
n
'
;
}
else
{
vtx
+
=
'
in
'
+
precName
+
'
'
+
typeName
+
'
in
'
+
outNdx
+
'
;
\
n
'
+
interp
+
'
out
'
+
precName
+
'
'
+
typeName
+
'
var
'
+
outNdx
+
'
;
\
n
'
;
frag
+
=
interp
+
'
in
'
+
precName
+
'
'
+
typeName
+
'
var
'
+
outNdx
+
'
;
\
n
'
+
'
layout
(
location
=
'
+
output
.
location
+
'
)
out
'
+
precName
+
'
'
+
typeName
+
'
out
'
+
outNdx
+
'
;
\
n
'
;
}
}
vtx
+
=
'
\
nvoid
main
(
)
\
n
{
\
n
'
;
frag
+
=
'
\
nvoid
main
(
)
\
n
{
\
n
'
;
vtx
+
=
'
gl_Position
=
a_position
;
\
n
'
;
for
(
var
outNdx
=
0
;
outNdx
<
outputs
.
length
;
outNdx
+
+
)
{
output
=
outputs
[
outNdx
]
;
isArray
=
output
.
arrayLength
>
0
;
if
(
isArray
)
{
for
(
var
elemNdx
=
0
;
elemNdx
<
output
.
arrayLength
;
elemNdx
+
+
)
{
vtx
+
=
'
\
tvar
'
+
outNdx
+
'
_
'
+
elemNdx
+
'
=
in
'
+
outNdx
+
'
_
'
+
elemNdx
+
'
;
\
n
'
;
frag
+
=
'
\
tout
'
+
outNdx
+
'
[
'
+
elemNdx
+
'
]
=
var
'
+
outNdx
+
'
_
'
+
elemNdx
+
'
;
\
n
'
;
}
}
else
{
vtx
+
=
'
\
tvar
'
+
outNdx
+
'
=
in
'
+
outNdx
+
'
;
\
n
'
;
frag
+
=
'
\
tout
'
+
outNdx
+
'
=
var
'
+
outNdx
+
'
;
\
n
'
;
}
}
vtx
+
=
'
}
\
n
'
;
frag
+
=
'
}
\
n
'
;
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
vtx
frag
)
)
;
return
program
;
}
;
es3fFragmentOutputTests
.
FragmentOutputCase
.
prototype
.
init
=
function
(
)
{
for
(
var
iter
=
0
;
iter
<
this
.
m_fboSpec
.
length
;
+
+
iter
)
{
if
(
!
gluTextureUtil
.
isSizedFormatColorRenderable
(
this
.
m_fboSpec
[
iter
]
.
format
)
)
throw
new
Error
(
'
Unsupported
attachment
format
'
)
;
}
DE_ASSERT
(
!
this
.
m_program
)
;
this
.
m_program
=
es3fFragmentOutputTests
.
createProgram
(
this
.
m_outputs
)
;
if
(
!
this
.
m_program
.
isOk
(
)
)
throw
new
Error
(
'
Compile
failed
.
Program
no
created
'
)
;
this
.
m_framebuffer
=
gl
.
createFramebuffer
(
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_framebuffer
)
;
for
(
var
bufNdx
=
0
;
bufNdx
<
this
.
m_fboSpec
.
length
;
bufNdx
+
+
)
{
this
.
m_renderbuffer
=
gl
.
createRenderbuffer
(
)
;
var
bufSpec
=
this
.
m_fboSpec
[
bufNdx
]
;
var
attachment
=
gl
.
COLOR_ATTACHMENT0
+
bufNdx
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
this
.
m_renderbuffer
)
;
gl
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
bufSpec
.
samples
bufSpec
.
format
bufSpec
.
width
bufSpec
.
height
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
attachment
gl
.
RENDERBUFFER
this
.
m_renderbuffer
)
;
}
var
fboStatus
=
gl
.
checkFramebufferStatus
(
gl
.
FRAMEBUFFER
)
;
if
(
fboStatus
=
=
gl
.
FRAMEBUFFER_UNSUPPORTED
)
throw
new
Error
(
'
Framebuffer
not
supported
'
)
;
else
if
(
fboStatus
!
=
gl
.
FRAMEBUFFER_COMPLETE
)
throw
new
Error
(
'
Incomplete
framebuffer
'
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
null
)
;
}
;
es3fFragmentOutputTests
.
FragmentOutputCase
.
prototype
.
deinit
=
function
(
)
{
}
;
es3fFragmentOutputTests
.
getMinSize
=
function
(
fboSpec
)
{
var
minSize
=
[
0x7fffffff
0x7fffffff
]
;
for
(
var
i
=
0
;
i
<
fboSpec
.
length
;
i
+
+
)
{
minSize
[
0
]
=
Math
.
min
(
minSize
[
0
]
fboSpec
[
i
]
.
width
)
;
minSize
[
1
]
=
Math
.
min
(
minSize
[
1
]
fboSpec
[
i
]
.
height
)
;
}
return
minSize
;
}
;
es3fFragmentOutputTests
.
getNumInputVectors
=
function
(
outputs
)
{
var
numVecs
=
0
;
for
(
var
i
=
0
;
i
<
outputs
.
length
;
i
+
+
)
numVecs
+
=
(
outputs
[
i
]
.
arrayLength
>
0
?
outputs
[
i
]
.
arrayLength
:
1
)
;
return
numVecs
;
}
;
es3fFragmentOutputTests
.
getFloatRange
=
function
(
precision
)
{
var
ranges
=
[
[
-
2
.
0
2
.
0
]
[
-
16000
.
0
16000
.
0
]
[
-
1e35
1e35
]
]
;
return
ranges
[
precision
]
;
}
;
es3fFragmentOutputTests
.
getIntRange
=
function
(
precision
)
{
var
ranges
=
[
[
-
(
1
<
<
7
)
(
1
<
<
7
)
-
1
]
[
-
(
1
<
<
15
)
(
1
<
<
15
)
-
1
]
[
-
0x80000000
0x7fffffff
]
]
;
return
ranges
[
precision
]
;
}
;
es3fFragmentOutputTests
.
getUintRange
=
function
(
precision
)
{
var
ranges
=
[
[
0
(
1
<
<
8
)
-
1
]
[
0
(
1
<
<
16
)
-
1
]
[
0
0xffffffff
]
]
;
return
ranges
[
precision
]
;
}
;
es3fFragmentOutputTests
.
readVec4
=
function
(
ptr
index
numComponents
)
{
DE_ASSERT
(
numComponents
>
=
1
)
;
return
[
ptr
[
index
+
0
]
numComponents
>
=
2
?
ptr
[
index
+
1
]
:
0
.
0
numComponents
>
=
3
?
ptr
[
index
+
2
]
:
0
.
0
numComponents
>
=
4
?
ptr
[
index
+
3
]
:
0
.
0
]
;
}
;
es3fFragmentOutputTests
.
readIVec4
=
function
(
ptr
index
numComponents
)
{
DE_ASSERT
(
numComponents
>
=
1
)
;
return
[
ptr
[
index
+
0
]
numComponents
>
=
2
?
ptr
[
index
+
1
]
:
0
numComponents
>
=
3
?
ptr
[
index
+
2
]
:
0
numComponents
>
=
4
?
ptr
[
index
+
3
]
:
0
]
;
}
;
es3fFragmentOutputTests
.
renderFloatReference
=
function
(
dst
gridWidth
gridHeight
numComponents
vertices
)
{
var
isSRGB
=
dst
.
getFormat
(
)
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGB
|
|
dst
.
getFormat
(
)
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGBA
;
var
cellW
=
dst
.
getWidth
(
)
/
(
gridWidth
-
1
)
;
var
cellH
=
dst
.
getHeight
(
)
/
(
gridHeight
-
1
)
;
for
(
var
y
=
0
;
y
<
dst
.
getHeight
(
)
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
dst
.
getWidth
(
)
;
x
+
+
)
{
var
cellX
=
deMath
.
clamp
(
Math
.
floor
(
x
/
cellW
)
0
gridWidth
-
2
)
;
var
cellY
=
deMath
.
clamp
(
Math
.
floor
(
y
/
cellH
)
0
gridHeight
-
2
)
;
var
xf
=
(
x
-
cellX
*
cellW
+
0
.
5
)
/
cellW
;
var
yf
=
(
y
-
cellY
*
cellH
+
0
.
5
)
/
cellH
;
var
v00
=
es3fFragmentOutputTests
.
readVec4
(
vertices
(
(
cellY
+
0
)
*
gridWidth
+
cellX
+
0
)
*
numComponents
numComponents
)
;
var
v01
=
es3fFragmentOutputTests
.
readVec4
(
vertices
(
(
cellY
+
1
)
*
gridWidth
+
cellX
+
0
)
*
numComponents
numComponents
)
;
var
v10
=
es3fFragmentOutputTests
.
readVec4
(
vertices
(
(
cellY
+
0
)
*
gridWidth
+
cellX
+
1
)
*
numComponents
numComponents
)
;
var
v11
=
es3fFragmentOutputTests
.
readVec4
(
vertices
(
(
cellY
+
1
)
*
gridWidth
+
cellX
+
1
)
*
numComponents
numComponents
)
;
var
tri
=
xf
+
yf
>
=
1
.
0
;
var
v0
=
tri
?
v11
:
v00
;
var
v1
=
tri
?
v01
:
v10
;
var
v2
=
tri
?
v10
:
v01
;
var
s
=
tri
?
1
.
0
-
xf
:
xf
;
var
t
=
tri
?
1
.
0
-
yf
:
yf
;
var
color
=
deMath
.
add
(
v0
deMath
.
add
(
deMath
.
multiply
(
(
deMath
.
subtract
(
v1
v0
)
)
[
s
s
s
s
]
)
deMath
.
multiply
(
(
deMath
.
subtract
(
v2
v0
)
)
[
t
t
t
t
]
)
)
)
;
dst
.
setPixel
(
isSRGB
?
tcuTextureUtil
.
linearToSRGB
(
color
)
:
color
x
y
)
;
}
}
}
;
es3fFragmentOutputTests
.
renderIntReference
=
function
(
dst
gridWidth
gridHeight
numComponents
vertices
)
{
var
cellW
=
dst
.
getWidth
(
)
/
(
gridWidth
-
1
)
;
var
cellH
=
dst
.
getHeight
(
)
/
(
gridHeight
-
1
)
;
for
(
var
y
=
0
;
y
<
dst
.
getHeight
(
)
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
dst
.
getWidth
(
)
;
x
+
+
)
{
var
cellX
=
deMath
.
clamp
(
Math
.
floor
(
x
/
cellW
)
0
gridWidth
-
2
)
;
var
cellY
=
deMath
.
clamp
(
Math
.
floor
(
y
/
cellH
)
0
gridHeight
-
2
)
;
var
c
=
es3fFragmentOutputTests
.
readIVec4
(
vertices
(
cellY
*
gridWidth
+
cellX
+
1
)
*
numComponents
numComponents
)
;
dst
.
setPixelInt
(
c
x
y
)
;
}
}
}
;
es3fFragmentOutputTests
.
s_swizzles
=
function
(
)
{
var
mat_swizzles
=
[
[
0
1
2
3
]
[
1
2
3
0
]
[
2
3
0
1
]
[
3
0
1
2
]
[
3
2
1
0
]
[
2
1
0
3
]
[
1
0
3
2
]
[
0
3
2
1
]
]
;
return
mat_swizzles
;
}
;
es3fFragmentOutputTests
.
swizzleVec
=
function
(
vec
swzNdx
)
{
var
swz
=
es3fFragmentOutputTests
.
s_swizzles
(
)
[
swzNdx
%
es3fFragmentOutputTests
.
s_swizzles
(
)
.
length
]
;
return
deMath
.
swizzle
(
vec
swz
)
;
}
;
es3fFragmentOutputTests
.
AttachmentData
=
function
(
)
{
return
{
format
:
null
referenceFormat
:
null
readFormat
:
null
numWrittenChannels
:
0
outPrecision
:
gluShaderUtil
.
precision
.
PRECISION_LOWP
renderedData
:
null
referenceData
:
null
}
;
}
;
es3fFragmentOutputTests
.
FragmentOutputCase
.
prototype
.
iterate
=
function
(
)
{
var
minCellSize
=
8
;
var
minBufSize
=
es3fFragmentOutputTests
.
getMinSize
(
this
.
m_fboSpec
)
;
var
gridWidth
=
deMath
.
clamp
(
Math
.
floor
(
minBufSize
[
0
]
/
minCellSize
)
1
255
)
+
1
;
var
gridHeight
=
deMath
.
clamp
(
Math
.
floor
(
minBufSize
[
1
]
/
minCellSize
)
1
255
)
+
1
;
var
numVertices
=
gridWidth
*
gridHeight
;
var
numQuads
=
(
gridWidth
-
1
)
*
(
gridHeight
-
1
)
;
var
numIndices
=
numQuads
*
6
;
var
numInputVecs
=
es3fFragmentOutputTests
.
getNumInputVectors
(
this
.
m_outputs
)
;
var
inputs
=
[
]
;
for
(
var
inputNdx
=
0
;
inputNdx
<
numInputVecs
;
inputNdx
+
+
)
inputs
[
inputNdx
]
=
[
]
;
var
positions
=
[
]
;
var
indices
=
[
]
;
var
readAlignment
=
4
;
var
viewportW
=
minBufSize
[
0
]
;
var
viewportH
=
minBufSize
[
1
]
;
var
numAttachments
=
this
.
m_fboSpec
.
length
;
var
drawBuffers
=
[
]
;
var
attachments
=
[
]
;
var
attachmentW
;
var
attachmentH
;
for
(
var
ndx
=
0
;
ndx
<
numAttachments
;
ndx
+
+
)
{
var
texFmt
=
gluTextureUtil
.
mapGLInternalFormat
(
this
.
m_fboSpec
[
ndx
]
.
format
)
;
var
chnClass
=
tcuTexture
.
getTextureChannelClass
(
texFmt
.
type
)
;
var
isFixedPoint
=
(
chnClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
|
|
chnClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
;
var
refFmt
=
isFixedPoint
?
new
tcuTexture
.
TextureFormat
(
texFmt
.
order
tcuTexture
.
ChannelType
.
FLOAT
)
:
texFmt
;
var
readFmt
=
es3fFboTestUtil
.
getFramebufferReadFormat
(
texFmt
)
;
attachmentW
=
this
.
m_fboSpec
[
ndx
]
.
width
;
attachmentH
=
this
.
m_fboSpec
[
ndx
]
.
height
;
drawBuffers
[
ndx
]
=
gl
.
COLOR_ATTACHMENT0
+
ndx
;
attachments
[
ndx
]
=
new
es3fFragmentOutputTests
.
AttachmentData
(
)
;
attachments
[
ndx
]
.
format
=
texFmt
;
attachments
[
ndx
]
.
readFormat
=
readFmt
;
attachments
[
ndx
]
.
referenceFormat
=
refFmt
;
attachments
[
ndx
]
.
renderedData
=
new
ArrayBuffer
(
readFmt
.
getPixelSize
(
)
*
attachmentW
*
attachmentH
)
;
attachments
[
ndx
]
.
referenceData
=
new
ArrayBuffer
(
refFmt
.
getPixelSize
(
)
*
attachmentW
*
attachmentH
)
;
}
for
(
var
quadNdx
=
0
;
quadNdx
<
numQuads
;
quadNdx
+
+
)
{
var
quadY
=
Math
.
floor
(
quadNdx
/
(
gridWidth
-
1
)
)
;
var
quadX
=
quadNdx
-
quadY
*
(
gridWidth
-
1
)
;
indices
[
quadNdx
*
6
+
0
]
=
quadX
+
quadY
*
gridWidth
;
indices
[
quadNdx
*
6
+
1
]
=
quadX
+
(
quadY
+
1
)
*
gridWidth
;
indices
[
quadNdx
*
6
+
2
]
=
quadX
+
quadY
*
gridWidth
+
1
;
indices
[
quadNdx
*
6
+
3
]
=
indices
[
quadNdx
*
6
+
1
]
;
indices
[
quadNdx
*
6
+
4
]
=
quadX
+
(
quadY
+
1
)
*
gridWidth
+
1
;
indices
[
quadNdx
*
6
+
5
]
=
indices
[
quadNdx
*
6
+
2
]
;
}
var
xf
=
0
;
var
yf
=
0
;
for
(
var
y
=
0
;
y
<
gridHeight
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
gridWidth
;
x
+
+
)
{
xf
=
x
/
(
gridWidth
-
1
)
;
yf
=
y
/
(
gridHeight
-
1
)
;
positions
[
(
y
*
gridWidth
+
x
)
*
4
+
0
]
=
2
.
0
*
xf
-
1
.
0
;
positions
[
(
y
*
gridWidth
+
x
)
*
4
+
1
]
=
2
.
0
*
yf
-
1
.
0
;
positions
[
(
y
*
gridWidth
+
x
)
*
4
+
2
]
=
0
.
0
;
positions
[
(
y
*
gridWidth
+
x
)
*
4
+
3
]
=
1
.
0
;
}
}
var
output
;
var
isArray
;
var
isFloat
;
var
isInt
;
var
isUint
;
var
numVecs
;
var
numScalars
;
var
curInVec
=
0
;
for
(
var
outputNdx
=
0
;
outputNdx
<
this
.
m_outputs
.
length
;
outputNdx
+
+
)
{
output
=
this
.
m_outputs
[
outputNdx
]
;
isFloat
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
output
.
type
)
;
isInt
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
output
.
type
)
;
isUint
=
gluShaderUtil
.
isDataTypeUintOrUVec
(
output
.
type
)
;
numVecs
=
output
.
arrayLength
>
0
?
output
.
arrayLength
:
1
;
numScalars
=
gluShaderUtil
.
getDataTypeScalarSize
(
output
.
type
)
;
for
(
var
vecNdx
=
0
;
vecNdx
<
numVecs
;
vecNdx
+
+
)
{
inputs
[
curInVec
]
.
length
=
numVertices
*
numScalars
;
DE_ASSERT
(
output
.
location
+
vecNdx
<
attachments
.
length
)
;
attachments
[
output
.
location
+
vecNdx
]
.
numWrittenChannels
=
numScalars
;
attachments
[
output
.
location
+
vecNdx
]
.
outPrecision
=
output
.
precision
;
var
range
=
null
;
var
minVal
=
null
;
var
maxVal
=
null
;
var
fmtBits
=
null
;
var
fmtMaxVal
=
[
]
;
var
rangeDiv
=
null
;
var
step
=
[
]
;
var
ix
=
0
;
var
iy
=
0
;
var
c
=
null
;
var
pos
=
0
;
if
(
isFloat
)
{
range
=
es3fFragmentOutputTests
.
getFloatRange
(
output
.
precision
)
;
minVal
=
[
range
[
0
]
range
[
0
]
range
[
0
]
range
[
0
]
]
;
maxVal
=
[
range
[
1
]
range
[
1
]
range
[
1
]
range
[
1
]
]
;
if
(
deMath
.
deInBounds32
(
output
.
location
+
vecNdx
0
attachments
.
length
)
)
{
var
fmtInfo
=
tcuTextureUtil
.
getTextureFormatInfo
(
attachments
[
output
.
location
+
vecNdx
]
.
format
)
;
minVal
=
deMath
.
max
(
minVal
fmtInfo
.
valueMin
)
;
maxVal
=
deMath
.
min
(
maxVal
fmtInfo
.
valueMax
)
;
}
console
.
log
(
'
out
'
+
curInVec
+
'
value
range
:
'
+
minVal
+
'
-
>
'
+
maxVal
)
;
for
(
var
y
=
0
;
y
<
gridHeight
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
gridWidth
;
x
+
+
)
{
xf
=
x
/
(
gridWidth
-
1
)
;
yf
=
y
/
(
gridHeight
-
1
)
;
var
f0
=
(
xf
+
yf
)
*
0
.
5
;
var
f1
=
0
.
5
+
(
xf
-
yf
)
*
0
.
5
;
var
f
=
es3fFragmentOutputTests
.
swizzleVec
(
[
f0
f1
1
.
0
-
f0
1
.
0
-
f1
]
curInVec
)
;
c
=
deMath
.
add
(
minVal
deMath
.
multiply
(
deMath
.
subtract
(
maxVal
minVal
)
f
)
)
;
pos
=
(
y
*
gridWidth
+
x
)
*
numScalars
;
for
(
var
ndx
=
0
;
ndx
<
numScalars
;
ndx
+
+
)
inputs
[
curInVec
]
[
pos
+
ndx
]
=
c
[
ndx
]
;
}
}
}
else
if
(
isInt
)
{
range
=
es3fFragmentOutputTests
.
getIntRange
(
output
.
precision
)
;
minVal
=
[
range
[
0
]
range
[
0
]
range
[
0
]
range
[
0
]
]
;
maxVal
=
[
range
[
1
]
range
[
1
]
range
[
1
]
range
[
1
]
]
;
if
(
deMath
.
deInBounds32
(
output
.
location
+
vecNdx
0
attachments
.
length
)
)
{
fmtBits
=
tcuTextureUtil
.
getTextureFormatBitDepth
(
attachments
[
output
.
location
+
vecNdx
]
.
format
)
;
var
isZero
=
deMath
.
lessThanEqual
(
fmtBits
[
0
0
0
0
]
)
;
var
fmtMinVal
=
[
]
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
fmtMinVal
[
i
]
=
-
1
*
Math
.
pow
(
2
fmtBits
[
i
]
-
1
)
;
fmtMaxVal
[
i
]
=
Math
.
pow
(
2
fmtBits
[
i
]
-
1
)
-
1
;
}
minVal
=
tcuTextureUtil
.
select
(
minVal
deMath
.
max
(
minVal
fmtMinVal
)
isZero
)
;
maxVal
=
tcuTextureUtil
.
select
(
maxVal
deMath
.
min
(
maxVal
fmtMaxVal
)
isZero
)
;
}
console
.
log
(
'
out
'
+
curInVec
+
'
value
range
:
'
+
minVal
+
'
-
>
'
+
maxVal
)
;
rangeDiv
=
es3fFragmentOutputTests
.
swizzleVec
(
[
gridWidth
-
1
gridHeight
-
1
gridWidth
-
1
gridHeight
-
1
]
curInVec
)
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
step
[
i
]
=
Math
.
floor
(
(
maxVal
[
i
]
-
minVal
[
i
]
)
/
rangeDiv
[
i
]
)
;
}
for
(
var
y
=
0
;
y
<
gridHeight
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
gridWidth
;
x
+
+
)
{
ix
=
gridWidth
-
x
-
1
;
iy
=
gridHeight
-
y
-
1
;
c
=
deMath
.
add
(
minVal
deMath
.
multiply
(
step
es3fFragmentOutputTests
.
swizzleVec
(
[
x
y
ix
iy
]
curInVec
)
)
)
;
pos
=
(
y
*
gridWidth
+
x
)
*
numScalars
;
for
(
var
ndx
=
0
;
ndx
<
numScalars
;
ndx
+
+
)
inputs
[
curInVec
]
[
pos
+
ndx
]
=
c
[
ndx
]
;
}
}
}
else
if
(
isUint
)
{
range
=
es3fFragmentOutputTests
.
getUintRange
(
output
.
precision
)
;
maxVal
=
[
range
[
1
]
range
[
1
]
range
[
1
]
range
[
1
]
]
;
if
(
deMath
.
deInBounds32
(
output
.
location
+
vecNdx
0
attachments
.
length
)
)
{
fmtBits
=
tcuTextureUtil
.
getTextureFormatBitDepth
(
attachments
[
output
.
location
+
vecNdx
]
.
format
)
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
{
fmtMaxVal
[
i
]
=
Math
.
pow
(
2
fmtBits
[
i
]
)
-
1
;
}
maxVal
=
deMath
.
min
(
maxVal
fmtMaxVal
)
;
}
console
.
log
(
'
out
'
+
curInVec
+
'
value
range
:
'
+
minVal
+
'
-
>
'
+
maxVal
)
;
rangeDiv
=
es3fFragmentOutputTests
.
swizzleVec
(
[
gridWidth
-
1
gridHeight
-
1
gridWidth
-
1
gridHeight
-
1
]
curInVec
)
;
for
(
var
stepPos
=
0
;
stepPos
<
maxVal
.
length
;
stepPos
+
+
)
{
step
[
stepPos
]
=
Math
.
floor
(
maxVal
[
stepPos
]
/
rangeDiv
[
stepPos
]
)
;
}
DE_ASSERT
(
range
[
0
]
=
=
0
)
;
for
(
var
y
=
0
;
y
<
gridHeight
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
gridWidth
;
x
+
+
)
{
ix
=
gridWidth
-
x
-
1
;
iy
=
gridHeight
-
y
-
1
;
c
=
deMath
.
multiply
(
step
es3fFragmentOutputTests
.
swizzleVec
(
[
x
y
ix
iy
]
curInVec
)
)
;
pos
=
(
y
*
gridWidth
+
x
)
*
numScalars
;
DE_ASSERT
(
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
c
maxVal
)
)
)
;
for
(
var
ndx
=
0
;
ndx
<
numScalars
;
ndx
+
+
)
inputs
[
curInVec
]
[
pos
+
ndx
]
=
c
[
ndx
]
;
}
}
}
else
DE_ASSERT
(
false
)
;
curInVec
+
=
1
;
}
}
gl
.
useProgram
(
this
.
m_program
.
getProgram
(
)
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
this
.
m_framebuffer
)
;
gl
.
viewport
(
0
0
viewportW
viewportH
)
;
gl
.
drawBuffers
(
drawBuffers
)
;
gl
.
disable
(
gl
.
DITHER
)
;
var
buffer
=
null
;
var
name
;
curInVec
=
0
;
for
(
var
outputNdx
=
0
;
outputNdx
<
this
.
m_outputs
.
length
;
outputNdx
+
+
)
{
output
=
this
.
m_outputs
[
outputNdx
]
;
isArray
=
output
.
arrayLength
>
0
;
isFloat
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
output
.
type
)
;
isInt
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
output
.
type
)
;
isUint
=
gluShaderUtil
.
isDataTypeUintOrUVec
(
output
.
type
)
;
var
scalarSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
output
.
type
)
;
var
glScalarType
=
isFloat
?
gl
.
FLOAT
:
isInt
?
gl
.
INT
:
isUint
?
gl
.
UNSIGNED_INT
:
gl
.
NONE
;
numVecs
=
isArray
?
output
.
arrayLength
:
1
;
for
(
var
vecNdx
=
0
;
vecNdx
<
numVecs
;
vecNdx
+
+
)
{
name
=
'
in
'
+
outputNdx
+
(
isArray
?
'
_
'
+
vecNdx
:
'
'
)
;
var
loc
=
gl
.
getAttribLocation
(
this
.
m_program
.
getProgram
(
)
name
)
;
if
(
loc
>
=
0
)
{
buffer
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
buffer
)
;
gl
.
enableVertexAttribArray
(
loc
)
;
if
(
isFloat
)
{
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Float32Array
(
inputs
[
curInVec
]
)
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribPointer
(
loc
scalarSize
glScalarType
false
0
0
)
;
}
else
{
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Int32Array
(
inputs
[
curInVec
]
)
gl
.
STATIC_DRAW
)
;
gl
.
vertexAttribIPointer
(
loc
scalarSize
glScalarType
0
0
)
;
}
}
else
bufferedLogToConsole
(
'
Warning
:
No
location
for
attribute
"
'
+
name
+
'
"
found
.
'
)
;
curInVec
+
=
1
;
}
}
var
posLoc
=
gl
.
getAttribLocation
(
this
.
m_program
.
getProgram
(
)
'
a_position
'
)
;
buffer
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ARRAY_BUFFER
buffer
)
;
gl
.
bufferData
(
gl
.
ARRAY_BUFFER
new
Float32Array
(
positions
)
gl
.
STATIC_DRAW
)
;
gl
.
enableVertexAttribArray
(
posLoc
)
;
gl
.
vertexAttribPointer
(
posLoc
4
gl
.
FLOAT
false
0
0
)
;
var
indexObject
=
gl
.
createBuffer
(
)
;
gl
.
bindBuffer
(
gl
.
ELEMENT_ARRAY_BUFFER
indexObject
)
;
gl
.
bufferData
(
gl
.
ELEMENT_ARRAY_BUFFER
new
Uint16Array
(
indices
)
gl
.
STATIC_DRAW
)
;
gl
.
drawElements
(
gl
.
TRIANGLES
numIndices
gl
.
UNSIGNED_SHORT
0
)
;
var
curInNdx
=
0
;
for
(
var
outputNdx
=
0
;
outputNdx
<
this
.
m_outputs
.
length
;
outputNdx
+
+
)
{
output
=
this
.
m_outputs
[
outputNdx
]
;
isArray
=
output
.
arrayLength
>
0
;
isFloat
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
output
.
type
)
;
isInt
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
output
.
type
)
;
isUint
=
gluShaderUtil
.
isDataTypeUintOrUVec
(
output
.
type
)
;
scalarSize
=
gluShaderUtil
.
getDataTypeScalarSize
(
output
.
type
)
;
numVecs
=
isArray
?
output
.
arrayLength
:
1
;
for
(
var
vecNdx
=
0
;
vecNdx
<
numVecs
;
vecNdx
+
+
)
{
var
location
=
output
.
location
+
vecNdx
;
var
inputData
=
inputs
[
curInNdx
]
;
DE_ASSERT
(
deMath
.
deInBounds32
(
location
0
this
.
m_fboSpec
.
length
)
)
;
var
bufW
=
this
.
m_fboSpec
[
location
]
.
width
;
var
bufH
=
this
.
m_fboSpec
[
location
]
.
height
;
var
descriptor
=
{
format
:
attachments
[
location
]
.
referenceFormat
width
:
bufW
height
:
bufH
depth
:
1
data
:
attachments
[
location
]
.
referenceData
}
;
var
buf
=
new
tcuTexture
.
PixelBufferAccess
(
descriptor
)
;
var
viewportBuf
=
tcuTextureUtil
.
getSubregion
(
buf
0
0
0
viewportW
viewportH
1
)
;
if
(
isInt
|
|
isUint
)
es3fFragmentOutputTests
.
renderIntReference
(
viewportBuf
gridWidth
gridHeight
scalarSize
inputData
)
;
else
if
(
isFloat
)
es3fFragmentOutputTests
.
renderFloatReference
(
viewportBuf
gridWidth
gridHeight
scalarSize
inputData
)
;
else
DE_ASSERT
(
false
)
;
curInNdx
+
=
1
;
}
}
var
allLevelsOk
=
true
;
for
(
var
attachNdx
=
0
;
attachNdx
<
numAttachments
;
attachNdx
+
+
)
{
attachmentW
=
this
.
m_fboSpec
[
attachNdx
]
.
width
;
attachmentH
=
this
.
m_fboSpec
[
attachNdx
]
.
height
;
var
numValidChannels
=
attachments
[
attachNdx
]
.
numWrittenChannels
;
var
cmpMask
=
[
numValidChannels
>
=
1
numValidChannels
>
=
2
numValidChannels
>
=
3
numValidChannels
>
=
4
]
;
var
outPrecision
=
attachments
[
attachNdx
]
.
outPrecision
;
var
format
=
attachments
[
attachNdx
]
.
format
;
var
renderedDescriptor
=
{
format
:
attachments
[
attachNdx
]
.
readFormat
width
:
attachmentW
height
:
attachmentH
depth
:
1
rowPitch
:
deMath
.
deAlign32
(
attachments
[
attachNdx
]
.
readFormat
.
getPixelSize
(
)
*
attachmentW
readAlignment
)
slicePitch
:
0
data
:
attachments
[
attachNdx
]
.
renderedData
}
;
var
rendered
=
new
tcuTexture
.
PixelBufferAccess
(
renderedDescriptor
)
;
var
transferFmt
=
gluTextureUtil
.
getTransferFormat
(
attachments
[
attachNdx
]
.
readFormat
)
;
gl
.
readBuffer
(
gl
.
COLOR_ATTACHMENT0
+
attachNdx
)
;
gl
.
readPixels
(
0
0
attachmentW
attachmentH
transferFmt
.
format
transferFmt
.
dataType
rendered
.
getDataPtr
(
)
)
;
var
referenceDescriptor
=
{
format
:
attachments
[
attachNdx
]
.
referenceFormat
width
:
attachmentW
height
:
attachmentH
depth
:
1
data
:
attachments
[
attachNdx
]
.
referenceData
}
;
var
reference
=
new
tcuTexture
.
ConstPixelBufferAccess
(
referenceDescriptor
)
;
var
texClass
=
tcuTexture
.
getTextureChannelClass
(
format
.
type
)
;
var
isOk
=
true
;
name
=
'
Attachment
'
+
attachNdx
;
var
desc
=
'
Color
attachment
'
+
attachNdx
;
var
threshold
;
bufferedLogToConsole
(
'
Attachment
'
+
attachNdx
+
'
:
'
+
numValidChannels
+
'
channels
have
defined
values
and
used
for
comparison
'
)
;
switch
(
texClass
)
{
case
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
:
{
var
formatThreshold
=
[
]
;
formatThreshold
.
length
=
4
;
var
precThreshold
=
0
;
var
finalThreshold
=
[
]
;
finalThreshold
.
length
=
4
;
switch
(
format
.
type
)
{
case
tcuTexture
.
ChannelType
.
FLOAT
:
formatThreshold
=
[
4
4
4
4
]
;
break
;
case
tcuTexture
.
ChannelType
.
HALF_FLOAT
:
formatThreshold
=
[
(
1
<
<
13
)
+
4
(
1
<
<
13
)
+
4
(
1
<
<
13
)
+
4
(
1
<
<
13
)
+
4
]
;
break
;
case
tcuTexture
.
ChannelType
.
UNSIGNED_INT_11F_11F_10F_REV
:
formatThreshold
=
[
(
1
<
<
17
)
+
4
(
1
<
<
17
)
+
4
(
1
<
<
18
)
+
4
4
]
;
break
;
default
:
DE_ASSERT
(
false
)
;
break
;
}
switch
(
outPrecision
)
{
case
gluShaderUtil
.
precision
.
PRECISION_LOWP
:
precThreshold
=
(
1
<
<
21
)
;
break
;
case
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
:
precThreshold
=
(
1
<
<
13
)
;
break
;
case
gluShaderUtil
.
precision
.
PRECISION_HIGHP
:
precThreshold
=
0
;
break
;
default
:
DE_ASSERT
(
false
)
;
}
finalThreshold
=
tcuTextureUtil
.
select
(
deMath
.
max
(
formatThreshold
[
precThreshold
precThreshold
precThreshold
precThreshold
]
)
[
0xffffffff
0xffffffff
0xffffffff
0xffffffff
]
cmpMask
)
;
isOk
=
tcuImageCompare
.
floatUlpThresholdCompare
(
name
desc
reference
rendered
finalThreshold
)
;
break
;
}
case
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
:
{
var
bits
=
deMath
.
min
(
[
8
8
8
8
]
tcuTextureUtil
.
getTextureFormatBitDepth
(
format
)
)
;
var
baseThreshold
=
[
]
;
baseThreshold
.
length
=
4
;
for
(
var
inc
=
0
;
inc
<
baseThreshold
.
length
;
inc
+
+
)
{
baseThreshold
[
inc
]
=
1
.
0
/
(
(
1
<
<
bits
[
inc
]
)
-
1
)
;
}
threshold
=
tcuTextureUtil
.
select
(
baseThreshold
[
2
.
0
2
.
0
2
.
0
2
.
0
]
cmpMask
)
;
isOk
=
tcuImageCompare
.
floatThresholdCompare
(
name
desc
reference
rendered
threshold
)
;
break
;
}
case
tcuTexture
.
TextureChannelClass
.
SIGNED_INTEGER
:
case
tcuTexture
.
TextureChannelClass
.
UNSIGNED_INTEGER
:
{
threshold
=
tcuTextureUtil
.
select
(
[
0
0
0
0
]
[
1
1
1
1
]
cmpMask
)
;
isOk
=
tcuImageCompare
.
intThresholdCompare
(
name
desc
reference
rendered
threshold
)
;
break
;
}
default
:
testFailedOptions
(
'
Unsupported
comparison
'
true
)
;
break
;
}
if
(
!
isOk
)
allLevelsOk
=
false
;
}
if
(
numAttachments
>
1
)
{
if
(
allLevelsOk
)
testPassed
(
'
Image
comparison
passed
for
'
+
numAttachments
+
'
attachments
'
)
;
else
testFailed
(
'
Image
comparison
failed
for
some
of
'
+
numAttachments
+
'
attachments
'
)
;
}
else
{
if
(
allLevelsOk
)
testPassed
(
'
Image
comparison
passed
'
)
;
else
testFailed
(
'
Image
comparison
failed
'
)
;
}
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fFragmentOutputTests
.
createRandomCase
=
function
(
minRenderTargets
maxRenderTargets
seed
colorBufferFloatSupported
)
{
var
outputTypes
=
[
gluShaderUtil
.
DataType
.
FLOAT
gluShaderUtil
.
DataType
.
FLOAT_VEC2
gluShaderUtil
.
DataType
.
FLOAT_VEC3
gluShaderUtil
.
DataType
.
FLOAT_VEC4
gluShaderUtil
.
DataType
.
INT
gluShaderUtil
.
DataType
.
INT_VEC2
gluShaderUtil
.
DataType
.
INT_VEC3
gluShaderUtil
.
DataType
.
INT_VEC4
gluShaderUtil
.
DataType
.
UINT
gluShaderUtil
.
DataType
.
UINT_VEC2
gluShaderUtil
.
DataType
.
UINT_VEC3
gluShaderUtil
.
DataType
.
UINT_VEC4
]
;
var
precisions
=
[
gluShaderUtil
.
precision
.
PRECISION_LOWP
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
gluShaderUtil
.
precision
.
PRECISION_HIGHP
]
;
var
floatFormats
=
[
gl
.
RGBA32F
gl
.
RGBA16F
gl
.
R11F_G11F_B10F
gl
.
RG32F
gl
.
RG16F
gl
.
R32F
gl
.
R16F
gl
.
RGBA8
gl
.
SRGB8_ALPHA8
gl
.
RGB10_A2
gl
.
RGBA4
gl
.
RGB5_A1
gl
.
RGB8
gl
.
RGB565
gl
.
RG8
gl
.
R8
]
;
var
colorBufferFloatFormats
=
[
gl
.
RGBA32F
gl
.
RGBA16F
gl
.
R11F_G11F_B10F
gl
.
RG32F
gl
.
RG16F
gl
.
R32F
gl
.
R16F
]
;
var
intFormats
=
[
gl
.
RGBA32I
gl
.
RGBA16I
gl
.
RGBA8I
gl
.
RG32I
gl
.
RG16I
gl
.
RG8I
gl
.
R32I
gl
.
R16I
gl
.
R8I
]
;
var
uintFormats
=
[
gl
.
RGBA32UI
gl
.
RGBA16UI
gl
.
RGBA8UI
gl
.
RGB10_A2UI
gl
.
RG32UI
gl
.
RG16UI
gl
.
RG8UI
gl
.
R32UI
gl
.
R16UI
gl
.
R8UI
]
;
var
rnd
=
new
deRandom
.
Random
(
seed
)
;
var
outputs
=
[
]
;
var
targets
=
[
]
;
var
outTypes
=
[
]
;
var
numTargets
=
rnd
.
getInt
(
minRenderTargets
maxRenderTargets
)
;
var
width
=
128
;
var
height
=
64
;
var
samples
=
0
;
var
curLoc
=
0
;
while
(
curLoc
<
numTargets
)
{
var
useArray
=
rnd
.
getFloat
(
)
<
0
.
3
;
var
maxArrayLen
=
numTargets
-
curLoc
;
var
arrayLen
=
useArray
?
rnd
.
getInt
(
1
maxArrayLen
)
:
0
;
var
basicTypeArray
=
rnd
.
choose
(
outputTypes
undefined
1
)
;
var
basicType
=
basicTypeArray
[
0
]
;
var
precisionArray
=
rnd
.
choose
(
precisions
undefined
1
)
;
var
precision
=
precisionArray
[
0
]
;
var
numLocations
=
useArray
?
arrayLen
:
1
;
outputs
.
push
(
new
es3fFragmentOutputTests
.
FragmentOutput
(
basicType
precision
curLoc
arrayLen
)
)
;
for
(
var
ndx
=
0
;
ndx
<
numLocations
;
ndx
+
+
)
outTypes
.
push
(
basicType
)
;
curLoc
+
=
numLocations
;
}
DE_ASSERT
(
curLoc
=
=
numTargets
)
;
DE_ASSERT
(
outTypes
.
length
=
=
numTargets
)
;
while
(
targets
.
length
<
numTargets
)
{
var
outType
=
outTypes
[
targets
.
length
]
;
var
isFloat
=
gluShaderUtil
.
isDataTypeFloatOrVec
(
outType
)
;
var
isInt
=
gluShaderUtil
.
isDataTypeIntOrIVec
(
outType
)
;
var
isUint
=
gluShaderUtil
.
isDataTypeUintOrUVec
(
outType
)
;
var
formatArray
=
[
]
;
var
format
=
0
;
if
(
isFloat
)
{
formatArray
=
rnd
.
choose
(
floatFormats
undefined
1
)
;
format
=
formatArray
[
0
]
;
if
(
colorBufferFloatFormats
.
indexOf
(
format
)
>
=
0
&
&
!
colorBufferFloatSupported
)
return
null
;
}
else
if
(
isInt
)
{
formatArray
=
rnd
.
choose
(
intFormats
undefined
1
)
;
format
=
formatArray
[
0
]
;
}
else
if
(
isUint
)
{
formatArray
=
rnd
.
choose
(
uintFormats
undefined
1
)
;
format
=
formatArray
[
0
]
;
}
else
DE_ASSERT
(
false
)
;
targets
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
}
return
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
seed
.
toString
(
)
'
'
targets
outputs
)
;
}
;
es3fFragmentOutputTests
.
init
=
function
(
gl
)
{
var
state
=
tcuTestCase
.
runner
;
state
.
testCases
=
tcuTestCase
.
newTest
(
'
fragment_outputs
'
'
Top
level
'
)
;
var
testGroup
=
state
.
testCases
;
var
requiredFloatFormats
=
[
gl
.
RGBA32F
gl
.
RGBA16F
gl
.
R11F_G11F_B10F
gl
.
RG32F
gl
.
RG16F
gl
.
R32F
gl
.
R16F
]
;
var
requiredFixedFormats
=
[
gl
.
RGBA8
gl
.
SRGB8_ALPHA8
gl
.
RGB10_A2
gl
.
RGBA4
gl
.
RGB5_A1
gl
.
RGB8
gl
.
RGB565
gl
.
RG8
gl
.
R8
]
;
var
requiredIntFormats
=
[
gl
.
RGBA32I
gl
.
RGBA16I
gl
.
RGBA8I
gl
.
RG32I
gl
.
RG16I
gl
.
RG8I
gl
.
R32I
gl
.
R16I
gl
.
R8I
]
;
var
requiredUintFormats
=
[
gl
.
RGBA32UI
gl
.
RGBA16UI
gl
.
RGBA8UI
gl
.
RGB10_A2UI
gl
.
RG32UI
gl
.
RG16UI
gl
.
RG8UI
gl
.
R32UI
gl
.
R16UI
gl
.
R8UI
]
;
var
precisions
=
[
gluShaderUtil
.
precision
.
PRECISION_LOWP
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
gluShaderUtil
.
precision
.
PRECISION_HIGHP
]
;
var
basicGroup
=
tcuTestCase
.
newTest
(
'
basic
'
'
Basic
fragment
output
tests
'
)
;
testGroup
.
addChild
(
basicGroup
)
;
var
width
=
64
;
var
height
=
64
;
var
samples
=
0
;
var
fboSpec
=
null
;
var
prec
;
var
precName
;
if
(
gl
.
getExtension
(
'
EXT_color_buffer_float
'
)
)
{
var
floatGroup
=
tcuTestCase
.
newTest
(
'
float
'
'
Floating
-
point
output
tests
'
)
;
basicGroup
.
addChild
(
floatGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredFloatFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredFloatFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
floatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_float
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT
prec
0
)
]
)
)
;
floatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC2
prec
0
)
]
)
)
;
floatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC3
prec
0
)
]
)
)
;
floatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
prec
0
)
]
)
)
;
}
}
}
var
fixedGroup
=
tcuTestCase
.
newTest
(
'
fixed
'
'
Fixed
-
point
output
tests
'
)
;
basicGroup
.
addChild
(
fixedGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredFixedFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredFixedFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
fixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_float
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT
prec
0
)
]
)
)
;
fixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC2
prec
0
)
]
)
)
;
fixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC3
prec
0
)
]
)
)
;
fixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
prec
0
)
]
)
)
;
}
}
var
intGroup
=
tcuTestCase
.
newTest
(
'
int
'
'
Integer
output
tests
'
)
;
basicGroup
.
addChild
(
intGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredIntFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredIntFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
intGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_int
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT
prec
0
)
]
)
)
;
intGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_ivec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT_VEC2
prec
0
)
]
)
)
;
intGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_ivec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT_VEC3
prec
0
)
]
)
)
;
intGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_ivec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT_VEC4
prec
0
)
]
)
)
;
}
}
var
uintGroup
=
tcuTestCase
.
newTest
(
'
uint
'
'
Usigned
integer
output
tests
'
)
;
basicGroup
.
addChild
(
uintGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredUintFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredUintFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
uintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uint
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT
prec
0
)
]
)
)
;
uintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uvec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT_VEC2
prec
0
)
]
)
)
;
uintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uvec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT_VEC3
prec
0
)
]
)
)
;
uintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uvec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT_VEC4
prec
0
)
]
)
)
;
}
}
var
arrayGroup
=
tcuTestCase
.
newTest
(
'
array
'
'
Array
outputs
'
)
;
testGroup
.
addChild
(
arrayGroup
)
;
var
numTargets
=
3
;
if
(
gl
.
getExtension
(
'
EXT_color_buffer_float
'
)
)
{
var
arrayFloatGroup
=
tcuTestCase
.
newTest
(
'
float
'
'
Floating
-
point
output
tests
'
)
;
arrayGroup
.
addChild
(
arrayFloatGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredFloatFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredFloatFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
for
(
var
ndx
=
0
;
ndx
<
numTargets
;
ndx
+
+
)
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
arrayFloatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_float
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT
prec
0
numTargets
)
]
)
)
;
arrayFloatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC2
prec
0
numTargets
)
]
)
)
;
arrayFloatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC3
prec
0
numTargets
)
]
)
)
;
arrayFloatGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
prec
0
numTargets
)
]
)
)
;
}
}
}
var
arrayFixedGroup
=
tcuTestCase
.
newTest
(
'
fixed
'
'
Fixed
-
point
output
tests
'
)
;
arrayGroup
.
addChild
(
arrayFixedGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredFixedFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredFixedFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
for
(
var
ndx
=
0
;
ndx
<
numTargets
;
ndx
+
+
)
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
arrayFixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_float
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT
prec
0
numTargets
)
]
)
)
;
arrayFixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC2
prec
0
numTargets
)
]
)
)
;
arrayFixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC3
prec
0
numTargets
)
]
)
)
;
arrayFixedGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_vec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
prec
0
numTargets
)
]
)
)
;
}
}
var
arrayIntGroup
=
tcuTestCase
.
newTest
(
'
int
'
'
Integer
output
tests
'
)
;
arrayGroup
.
addChild
(
arrayIntGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredIntFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredIntFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
for
(
var
ndx
=
0
;
ndx
<
numTargets
;
ndx
+
+
)
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
arrayIntGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_int
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT
prec
0
numTargets
)
]
)
)
;
arrayIntGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_ivec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT_VEC2
prec
0
numTargets
)
]
)
)
;
arrayIntGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_ivec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT_VEC3
prec
0
numTargets
)
]
)
)
;
arrayIntGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_ivec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
INT_VEC4
prec
0
numTargets
)
]
)
)
;
}
}
var
arrayUintGroup
=
tcuTestCase
.
newTest
(
'
uint
'
'
Usigned
integer
output
tests
'
)
;
arrayGroup
.
addChild
(
arrayUintGroup
)
;
for
(
var
fmtNdx
=
0
;
fmtNdx
<
requiredUintFormats
.
length
;
fmtNdx
+
+
)
{
var
format
=
requiredUintFormats
[
fmtNdx
]
;
var
fmtName
=
es3fFboTestUtil
.
getFormatName
(
format
)
;
fboSpec
=
[
]
;
for
(
var
ndx
=
0
;
ndx
<
numTargets
;
ndx
+
+
)
fboSpec
.
push
(
new
es3fFragmentOutputTests
.
BufferSpec
(
format
width
height
samples
)
)
;
for
(
var
precNdx
=
0
;
precNdx
<
precisions
.
length
;
precNdx
+
+
)
{
prec
=
precisions
[
precNdx
]
;
precName
=
gluShaderUtil
.
getPrecisionName
(
prec
)
;
arrayUintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uint
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT
prec
0
numTargets
)
]
)
)
;
arrayUintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uvec2
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT_VEC2
prec
0
numTargets
)
]
)
)
;
arrayUintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uvec3
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT_VEC3
prec
0
numTargets
)
]
)
)
;
arrayUintGroup
.
addChild
(
new
es3fFragmentOutputTests
.
FragmentOutputCase
(
fmtName
+
'
_
'
+
precName
+
'
_uvec4
'
'
'
fboSpec
[
new
es3fFragmentOutputTests
.
FragmentOutput
(
gluShaderUtil
.
DataType
.
UINT_VEC4
prec
0
numTargets
)
]
)
)
;
}
}
var
randomGroup
=
tcuTestCase
.
newTest
(
'
random
'
'
Random
fragment
output
cases
'
)
;
testGroup
.
addChild
(
randomGroup
)
;
var
colorBufferFloatSupported
=
(
gl
.
getExtension
(
'
EXT_color_buffer_float
'
)
!
=
null
)
;
for
(
var
seed
=
0
;
seed
<
100
;
seed
+
+
)
{
var
test
=
es3fFragmentOutputTests
.
createRandomCase
(
2
4
seed
colorBufferFloatSupported
)
;
if
(
test
!
=
=
null
)
{
randomGroup
.
addChild
(
test
)
;
}
}
}
;
es3fFragmentOutputTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
testName
=
'
fragment_output
'
;
var
testDescription
=
'
Fragment
Output
Tests
'
;
var
state
=
tcuTestCase
.
runner
;
state
.
testName
=
testName
;
state
.
testCases
=
tcuTestCase
.
newTest
(
testName
testDescription
null
)
;
setCurrentTestName
(
testName
)
;
description
(
testDescription
)
;
try
{
es3fFragmentOutputTests
.
init
(
gl
)
;
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fFragmentOutputTests
.
run
tests
'
false
)
;
console
.
log
(
err
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
