'
use
strict
'
;
goog
.
provide
(
'
functional
.
gles3
.
es3fShaderDerivateTests
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluDrawUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluPixelTransfer
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuInterval
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuFloat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuLogImage
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuMatrix
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuPixelFormat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuStringTemplate
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
modules
.
shared
.
glsShaderRenderCase
'
)
;
goog
.
scope
(
function
(
)
{
var
es3fShaderDerivateTests
=
functional
.
gles3
.
es3fShaderDerivateTests
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
gluDrawUtil
=
framework
.
opengl
.
gluDrawUtil
;
var
gluPixelTransfer
=
framework
.
opengl
.
gluPixelTransfer
;
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
gluTexture
=
framework
.
opengl
.
gluTexture
;
var
tcuInterval
=
framework
.
common
.
tcuInterval
;
var
tcuFloat
=
framework
.
common
.
tcuFloat
;
var
tcuLogImage
=
framework
.
common
.
tcuLogImage
;
var
tcuMatrix
=
framework
.
common
.
tcuMatrix
;
var
tcuPixelFormat
=
framework
.
common
.
tcuPixelFormat
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuStringTemplate
=
framework
.
common
.
tcuStringTemplate
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
glsShaderRenderCase
=
modules
.
shared
.
glsShaderRenderCase
;
es3fShaderDerivateTests
.
VIEWPORT_WIDTH
=
167
;
es3fShaderDerivateTests
.
VIEWPORT_HEIGHT
=
103
;
es3fShaderDerivateTests
.
FBO_WIDTH
=
99
;
es3fShaderDerivateTests
.
FBO_HEIGHT
=
133
;
es3fShaderDerivateTests
.
MAX_FAILED_MESSAGES
=
10
;
es3fShaderDerivateTests
.
INTERPOLATION_LOST_BITS
=
3
;
es3fShaderDerivateTests
.
DerivateFunc
=
{
DFDX
:
0
DFDY
:
1
FWIDTH
:
2
}
;
es3fShaderDerivateTests
.
SurfaceType
=
{
DEFAULT_FRAMEBUFFER
:
0
UNORM_FBO
:
1
FLOAT_FBO
:
2
}
;
es3fShaderDerivateTests
.
VerificationLogging
=
{
LOG_ALL
:
0
LOG_NOTHING
:
1
}
;
es3fShaderDerivateTests
.
getDerivateFuncName
=
function
(
func
)
{
switch
(
func
)
{
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
:
return
'
dFdx
'
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDY
:
return
'
dFdy
'
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
FWIDTH
:
return
'
fwidth
'
;
default
:
throw
new
Error
(
'
Derivate
Func
not
supported
.
'
)
;
}
}
;
es3fShaderDerivateTests
.
getDerivateFuncCaseName
=
function
(
func
)
{
switch
(
func
)
{
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
:
return
'
dfdx
'
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDY
:
return
'
dfdy
'
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
FWIDTH
:
return
'
fwidth
'
;
default
:
throw
new
Error
(
'
Derivate
Func
not
supported
.
'
)
;
}
}
;
es3fShaderDerivateTests
.
getDerivateMask
=
function
(
type
)
{
switch
(
type
)
{
case
gluShaderUtil
.
DataType
.
FLOAT
:
return
[
true
false
false
false
]
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC2
:
return
[
true
true
false
false
]
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC3
:
return
[
true
true
true
false
]
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC4
:
return
[
true
true
true
true
]
;
default
:
throw
new
Error
(
'
Data
Type
not
supported
.
'
)
;
}
}
;
es3fShaderDerivateTests
.
readDerivate
=
function
(
surface
derivScale
derivBias
x
y
)
{
return
deMath
.
divide
(
deMath
.
subtract
(
surface
.
getPixel
(
x
y
)
derivBias
)
derivScale
)
;
}
;
es3fShaderDerivateTests
.
getCompExpBits
=
function
(
v
)
{
return
[
tcuFloat
.
newFloat32
(
v
[
0
]
)
.
exponentBits
(
)
tcuFloat
.
newFloat32
(
v
[
1
]
)
.
exponentBits
(
)
tcuFloat
.
newFloat32
(
v
[
2
]
)
.
exponentBits
(
)
tcuFloat
.
newFloat32
(
v
[
3
]
)
.
exponentBits
(
)
]
;
}
;
es3fShaderDerivateTests
.
computeFloatingPointError
=
function
(
value
numAccurateBits
)
{
var
numGarbageBits
=
23
-
numAccurateBits
;
var
mask
=
(
1
<
<
numGarbageBits
)
-
1
;
var
exp
=
tcuFloat
.
newFloat32
(
value
)
.
exponent
(
)
;
return
(
new
tcuFloat
.
deFloat
(
)
)
.
construct
(
1
exp
(
1
<
<
23
)
|
mask
)
.
getValue
(
)
-
(
new
tcuFloat
.
deFloat
(
)
)
.
construct
(
1
exp
1
<
<
23
)
.
getValue
(
)
;
}
;
es3fShaderDerivateTests
.
getNumMantissaBits
=
function
(
precision
)
{
switch
(
precision
)
{
case
gluShaderUtil
.
precision
.
PRECISION_HIGHP
:
return
23
;
case
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
:
return
10
;
case
gluShaderUtil
.
precision
.
PRECISION_LOWP
:
return
6
;
default
:
throw
new
Error
(
'
Precision
not
supported
:
'
+
precision
)
;
}
}
;
es3fShaderDerivateTests
.
getMinExponent
=
function
(
precision
)
{
switch
(
precision
)
{
case
gluShaderUtil
.
precision
.
PRECISION_HIGHP
:
return
-
126
;
case
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
:
return
-
14
;
case
gluShaderUtil
.
precision
.
PRECISION_LOWP
:
return
-
8
;
default
:
throw
new
Error
(
'
Precision
not
supported
:
'
+
precision
)
;
}
}
;
es3fShaderDerivateTests
.
getSingleULPForExponent
=
function
(
exp
numMantissaBits
)
{
if
(
numMantissaBits
>
0
)
{
assertMsgOptions
(
numMantissaBits
<
=
23
'
numMantissaBits
must
be
less
or
equal
than
23
.
'
false
true
)
;
var
ulpBitNdx
=
23
-
numMantissaBits
;
return
(
new
tcuFloat
.
deFloat
(
)
)
.
construct
(
1
exp
(
1
<
<
23
)
|
(
1
<
<
ulpBitNdx
)
)
.
getValue
(
)
-
(
new
tcuFloat
.
deFloat
(
)
)
.
construct
(
1
exp
1
<
<
23
)
.
getValue
(
)
;
}
else
{
assertMsgOptions
(
numMantissaBits
=
=
=
0
'
numMantissaBits
must
equal
to
0
.
'
false
true
)
;
return
(
new
tcuFloat
.
deFloat
(
)
)
.
construct
(
1
exp
(
1
<
<
23
)
)
.
getValue
(
)
}
}
;
es3fShaderDerivateTests
.
getSingleULPForValue
=
function
(
value
numMantissaBits
)
{
var
exp
=
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
value
)
)
.
exponent
(
)
;
return
es3fShaderDerivateTests
.
getSingleULPForExponent
(
exp
numMantissaBits
)
;
}
;
es3fShaderDerivateTests
.
convertFloorFlushToZero
=
function
(
value
minExponent
numAccurateBits
)
{
if
(
value
=
=
=
0
.
0
)
{
return
0
.
0
;
}
else
{
var
inputFloat
=
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
value
)
;
var
numTruncatedBits
=
23
-
numAccurateBits
;
var
truncMask
=
(
1
<
<
numTruncatedBits
)
-
1
;
if
(
value
>
0
.
0
)
{
if
(
value
>
0
.
0
&
&
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
value
)
)
.
exponent
(
)
<
minExponent
)
{
return
0
.
0
;
}
else
{
return
(
new
tcuFloat
.
deFloat
(
)
)
.
construct
(
1
inputFloat
.
exponent
(
)
inputFloat
.
mantissa
(
)
&
~
truncMask
)
.
getValue
(
)
;
}
}
else
{
if
(
inputFloat
.
mantissa
(
)
&
truncMask
)
{
return
(
new
tcuFloat
.
deFloat
(
)
)
.
construct
(
-
1
inputFloat
.
exponent
(
)
inputFloat
.
mantissa
(
)
&
~
truncMask
)
.
getValue
(
)
-
es3fShaderDerivateTests
.
getSingleULPForExponent
(
inputFloat
.
exponent
(
)
numAccurateBits
)
;
}
else
{
return
value
;
}
}
}
}
;
es3fShaderDerivateTests
.
convertCeilFlushToZero
=
function
(
value
minExponent
numAccurateBits
)
{
return
-
es3fShaderDerivateTests
.
convertFloorFlushToZero
(
-
value
minExponent
numAccurateBits
)
;
}
;
es3fShaderDerivateTests
.
addErrorUlp
=
function
(
value
numUlps
numMantissaBits
)
{
return
value
+
numUlps
*
es3fShaderDerivateTests
.
getSingleULPForValue
(
value
numMantissaBits
)
;
}
;
es3fShaderDerivateTests
.
getDerivateThreshold
=
function
(
precision
valueMin
valueMax
expectedDerivate
)
{
var
baseBits
=
es3fShaderDerivateTests
.
getNumMantissaBits
(
precision
)
;
var
derivExp
=
es3fShaderDerivateTests
.
getCompExpBits
(
expectedDerivate
)
;
var
maxValueExp
=
deMath
.
max
(
es3fShaderDerivateTests
.
getCompExpBits
(
valueMin
)
es3fShaderDerivateTests
.
getCompExpBits
(
valueMax
)
)
;
var
numBitsLost
=
deMath
.
subtract
(
maxValueExp
deMath
.
min
(
maxValueExp
derivExp
)
)
;
var
numAccurateBits
=
deMath
.
max
(
deMath
.
addScalar
(
deMath
.
subtract
(
[
baseBits
baseBits
baseBits
baseBits
]
numBitsLost
)
-
es3fShaderDerivateTests
.
INTERPOLATION_LOST_BITS
)
[
0
0
0
0
]
)
;
return
[
es3fShaderDerivateTests
.
computeFloatingPointError
(
expectedDerivate
[
0
]
numAccurateBits
[
0
]
)
es3fShaderDerivateTests
.
computeFloatingPointError
(
expectedDerivate
[
1
]
numAccurateBits
[
1
]
)
es3fShaderDerivateTests
.
computeFloatingPointError
(
expectedDerivate
[
2
]
numAccurateBits
[
2
]
)
es3fShaderDerivateTests
.
computeFloatingPointError
(
expectedDerivate
[
3
]
numAccurateBits
[
3
]
)
]
;
}
;
es3fShaderDerivateTests
.
verifyConstantDerivate
=
function
(
result
errorMask
dataType
reference
threshold
scale
bias
logPolicy
)
{
logPolicy
=
logPolicy
=
=
=
undefined
?
es3fShaderDerivateTests
.
VerificationLogging
.
LOG_ALL
:
logPolicy
;
var
mask
=
deMath
.
logicalNotBool
(
es3fShaderDerivateTests
.
getDerivateMask
(
dataType
)
)
;
var
numFailedPixels
=
0
;
if
(
logPolicy
=
=
=
es3fShaderDerivateTests
.
VerificationLogging
.
LOG_ALL
)
bufferedLogToConsole
(
'
Expecting
'
+
reference
+
'
with
threshold
'
+
threshold
)
;
for
(
var
y
=
0
;
y
<
result
.
getHeight
(
)
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
result
.
getWidth
(
)
;
x
+
+
)
{
var
resDerivate
=
es3fShaderDerivateTests
.
readDerivate
(
result
scale
bias
x
y
)
;
var
isOk
=
deMath
.
boolAll
(
deMath
.
logicalOrBool
(
deMath
.
lessThanEqual
(
deMath
.
abs
(
deMath
.
subtract
(
reference
resDerivate
)
)
threshold
)
mask
)
)
;
if
(
!
isOk
)
{
if
(
numFailedPixels
<
es3fShaderDerivateTests
.
MAX_FAILED_MESSAGES
&
&
logPolicy
=
=
=
es3fShaderDerivateTests
.
VerificationLogging
.
LOG_ALL
)
bufferedLogToConsole
(
'
FAIL
:
got
'
+
resDerivate
+
'
diff
=
'
+
deMath
.
abs
(
deMath
.
subtract
(
reference
resDerivate
)
)
+
'
at
x
=
'
+
x
+
'
y
=
'
+
y
)
;
numFailedPixels
+
=
1
;
errorMask
.
setPixel
(
tcuRGBA
.
RGBA
.
red
.
toVec
(
)
x
y
)
;
}
}
}
if
(
numFailedPixels
>
=
es3fShaderDerivateTests
.
MAX_FAILED_MESSAGES
&
&
logPolicy
=
=
=
es3fShaderDerivateTests
.
VerificationLogging
.
LOG_ALL
)
bufferedLogToConsole
(
'
.
.
.
'
)
;
if
(
numFailedPixels
>
0
&
&
logPolicy
=
=
=
es3fShaderDerivateTests
.
VerificationLogging
.
LOG_ALL
)
bufferedLogToConsole
(
'
FAIL
:
found
'
+
numFailedPixels
+
'
failed
pixels
'
)
;
return
numFailedPixels
=
=
=
0
;
}
;
es3fShaderDerivateTests
.
Linear2DFunctionEvaluator
=
function
(
)
{
this
.
matrix
=
new
tcuMatrix
.
Matrix
(
4
3
)
;
}
;
es3fShaderDerivateTests
.
Linear2DFunctionEvaluator
.
prototype
.
evaluateAt
=
function
(
screenX
screenY
)
{
var
position
=
[
screenX
screenY
1
.
0
]
;
return
tcuMatrix
.
multiplyMatVec
(
this
.
matrix
position
)
;
}
;
es3fShaderDerivateTests
.
reverifyConstantDerivateWithFlushRelaxations
=
function
(
result
errorMask
dataType
precision
derivScale
derivBias
surfaceThreshold
derivateFunc
func
)
{
assertMsgOptions
(
result
.
getWidth
(
)
=
=
=
errorMask
.
getWidth
(
)
'
Dimensions
of
result
and
errorMask
inconsistent
.
'
false
true
)
;
assertMsgOptions
(
result
.
getHeight
(
)
=
=
=
errorMask
.
getHeight
(
)
'
Dimensions
of
result
and
errorMask
inconsistent
.
'
false
true
)
;
assertMsgOptions
(
derivateFunc
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
|
|
derivateFunc
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDY
'
Derivate
Function
should
be
DFDX
or
DFDY
.
'
false
true
)
;
var
red
=
[
255
0
0
255
]
;
var
green
=
[
0
255
0
255
]
;
var
divisionErrorUlps
=
2
.
5
;
var
numComponents
=
gluShaderUtil
.
getDataTypeScalarTypeAsDataType
(
dataType
)
;
var
numBits
=
es3fShaderDerivateTests
.
getNumMantissaBits
(
precision
)
;
var
minExponent
=
es3fShaderDerivateTests
.
getMinExponent
(
precision
)
;
var
numVaryingSampleBits
=
numBits
-
es3fShaderDerivateTests
.
INTERPOLATION_LOST_BITS
;
var
numFailedPixels
=
0
;
errorMask
.
clear
(
green
)
;
for
(
var
y
=
0
;
y
<
result
.
getHeight
(
)
;
+
+
y
)
for
(
var
x
=
0
;
x
<
result
.
getWidth
(
)
;
+
+
x
)
{
var
resultDerivative
=
es3fShaderDerivateTests
.
readDerivate
(
result
derivScale
derivBias
x
y
)
;
var
functionValueForward
=
(
derivateFunc
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
)
?
(
func
.
evaluateAt
(
x
+
2
.
0
y
+
0
.
5
)
)
:
(
func
.
evaluateAt
(
x
+
0
.
5
y
+
2
.
0
)
)
;
var
functionValueBackward
=
(
derivateFunc
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
)
?
(
func
.
evaluateAt
(
x
-
1
.
0
y
+
0
.
5
)
)
:
(
func
.
evaluateAt
(
x
+
0
.
5
y
-
1
.
0
)
)
;
var
anyComponentFailed
=
false
;
for
(
var
c
=
0
;
c
<
numComponents
;
+
+
c
)
{
var
forwardComponent
=
tcuInterval
.
withIntervals
(
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertFloorFlushToZero
(
functionValueForward
[
c
]
minExponent
numVaryingSampleBits
)
)
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertCeilFlushToZero
(
functionValueForward
[
c
]
minExponent
numVaryingSampleBits
)
)
)
;
var
backwardComponent
=
tcuInterval
.
withIntervals
(
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertFloorFlushToZero
(
functionValueBackward
[
c
]
minExponent
numVaryingSampleBits
)
)
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertCeilFlushToZero
(
functionValueBackward
[
c
]
minExponent
numVaryingSampleBits
)
)
)
;
var
maxValueExp
=
Math
.
max
(
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
forwardComponent
.
lo
(
)
)
)
.
exponent
(
)
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
forwardComponent
.
hi
(
)
)
)
.
exponent
(
)
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
backwardComponent
.
lo
(
)
)
)
.
exponent
(
)
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
backwardComponent
.
hi
(
)
)
)
.
exponent
(
)
)
;
var
nominator
=
tcuInterval
.
Interval
.
operatorSub
(
forwardComponent
backwardComponent
)
;
var
nominatorLoExp
=
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
nominator
.
lo
(
)
)
)
.
exponent
(
)
;
var
nominatorHiExp
=
(
new
tcuFloat
.
deFloat
(
)
.
deFloatNumber
(
nominator
.
hi
(
)
)
)
.
exponent
(
)
;
var
nominatorLoBitsLost
=
maxValueExp
-
nominatorLoExp
;
var
nominatorHiBitsLost
=
maxValueExp
-
nominatorHiExp
;
var
nominatorLoBits
=
Math
.
max
(
0
numBits
-
nominatorLoBitsLost
)
;
var
nominatorHiBits
=
Math
.
max
(
0
numBits
-
nominatorHiBitsLost
)
;
var
nominatorRange
=
tcuInterval
.
withIntervals
(
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertFloorFlushToZero
(
nominator
.
lo
(
)
minExponent
nominatorLoBits
)
)
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertCeilFlushToZero
(
nominator
.
hi
(
)
minExponent
nominatorHiBits
)
)
)
;
var
divisionRange
=
tcuInterval
.
Interval
.
operatorDiv
(
nominatorRange
new
tcuInterval
.
Interval
(
3
.
0
)
)
;
var
divisionResultRange
=
tcuInterval
.
withIntervals
(
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertFloorFlushToZero
(
es3fShaderDerivateTests
.
addErrorUlp
(
divisionRange
.
lo
(
)
-
divisionErrorUlps
numBits
)
minExponent
numBits
)
)
new
tcuInterval
.
Interval
(
es3fShaderDerivateTests
.
convertCeilFlushToZero
(
es3fShaderDerivateTests
.
addErrorUlp
(
divisionRange
.
hi
(
)
divisionErrorUlps
numBits
)
minExponent
numBits
)
)
)
;
var
finalResultRange
=
tcuInterval
.
withIntervals
(
new
tcuInterval
.
Interval
(
divisionResultRange
.
lo
(
)
-
surfaceThreshold
[
c
]
)
new
tcuInterval
.
Interval
(
divisionResultRange
.
hi
(
)
+
surfaceThreshold
[
c
]
)
)
;
if
(
resultDerivative
[
c
]
>
=
finalResultRange
.
lo
(
)
&
&
resultDerivative
[
c
]
<
=
finalResultRange
.
hi
(
)
)
{
}
else
{
if
(
numFailedPixels
<
es3fShaderDerivateTests
.
MAX_FAILED_MESSAGES
)
bufferedLogToConsole
(
'
Error
in
pixel
at
'
+
x
+
'
'
+
y
+
'
with
component
'
+
c
+
'
(
channel
'
+
(
'
rgba
'
[
c
]
)
+
'
)
\
n
'
+
'
\
tGot
pixel
value
'
+
result
.
getPixelInt
(
x
y
)
+
'
\
n
'
+
'
\
t
\
tdFd
'
+
(
(
derivateFunc
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
)
?
'
x
'
:
'
y
'
)
+
'
~
=
'
+
resultDerivative
[
c
]
+
'
\
n
'
+
'
\
t
\
tdifference
to
a
valid
range
:
'
+
(
(
resultDerivative
[
c
]
<
finalResultRange
.
lo
(
)
)
?
'
-
'
:
'
+
'
)
+
(
(
resultDerivative
[
c
]
<
finalResultRange
.
lo
(
)
)
?
(
finalResultRange
.
lo
(
)
-
resultDerivative
[
c
]
)
:
(
resultDerivative
[
c
]
-
finalResultRange
.
hi
(
)
)
)
+
'
\
n
'
+
'
\
tDerivative
value
range
:
\
n
'
+
'
\
t
\
tMin
:
'
+
finalResultRange
.
lo
(
)
+
'
\
n
'
+
'
\
t
\
tMax
:
'
+
finalResultRange
.
hi
(
)
+
'
\
n
'
)
;
+
+
numFailedPixels
;
anyComponentFailed
=
true
;
}
}
if
(
anyComponentFailed
)
errorMask
.
setPixel
(
red
x
y
)
;
}
if
(
numFailedPixels
>
=
es3fShaderDerivateTests
.
MAX_FAILED_MESSAGES
)
bufferedLogToConsole
(
'
.
.
.
'
)
;
if
(
numFailedPixels
>
0
)
bufferedLogToConsole
(
'
FAIL
:
found
'
+
numFailedPixels
+
'
failed
pixels
'
)
;
return
numFailedPixels
=
=
=
0
;
}
;
es3fShaderDerivateTests
.
TriangleDerivateCase
=
function
(
name
description
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
name
description
)
;
this
.
m_dataType
=
null
;
this
.
m_precision
=
null
;
this
.
m_coordDataType
=
null
;
this
.
m_coordPrecision
=
null
;
this
.
m_fragmentSrc
;
this
.
m_coordMin
=
[
]
;
this
.
m_coordMax
=
[
]
;
this
.
m_derivScale
=
[
]
;
this
.
m_derivBias
=
[
]
;
this
.
m_surfaceType
=
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
;
this
.
m_numSamples
=
0
;
this
.
m_hint
=
gl
.
DONT_CARE
;
assertMsgOptions
(
this
.
m_surfaceType
!
=
=
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
|
|
this
.
m_numSamples
=
=
=
0
'
Did
not
expect
surfaceType
=
DEFAULT_FRAMEBUFFER
or
numSamples
=
0
'
false
true
)
;
}
;
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
.
constructor
=
es3fShaderDerivateTests
.
TriangleDerivateCase
;
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
.
deinit
=
function
(
)
{
}
;
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
.
setupRenderState
=
function
(
program
)
{
}
;
es3fShaderDerivateTests
.
genVertexSource
=
function
(
coordType
precision
)
{
assertMsgOptions
(
gluShaderUtil
.
isDataTypeFloatOrVec
(
coordType
)
'
Coord
Type
not
supported
'
false
true
)
;
var
vertexTmpl
=
'
'
+
'
#
version
300
es
\
n
'
+
'
in
highp
vec4
a_position
;
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
a_coord
;
\
n
'
+
'
out
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
gl_Position
=
a_position
;
\
n
'
+
'
v_coord
=
a_coord
;
\
n
'
+
'
}
\
n
'
;
var
vertexParams
=
{
}
;
vertexParams
[
'
PRECISION
'
]
=
gluShaderUtil
.
getPrecisionName
(
precision
)
;
vertexParams
[
'
DATATYPE
'
]
=
gluShaderUtil
.
getDataTypeName
(
coordType
)
;
return
tcuStringTemplate
.
specialize
(
vertexTmpl
vertexParams
)
;
}
;
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
.
getViewportSize
=
function
(
)
{
if
(
this
.
m_surfaceType
=
=
=
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
)
{
var
width
=
Math
.
min
(
gl
.
drawingBufferWidth
es3fShaderDerivateTests
.
VIEWPORT_WIDTH
)
;
var
height
=
Math
.
min
(
gl
.
drawingBufferHeight
es3fShaderDerivateTests
.
VIEWPORT_HEIGHT
)
;
return
[
width
height
]
;
}
else
return
[
es3fShaderDerivateTests
.
FBO_WIDTH
es3fShaderDerivateTests
.
FBO_HEIGHT
]
;
}
;
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
.
iterate
=
function
(
)
{
var
program
=
new
gluShaderProgram
.
ShaderProgram
(
gl
gluShaderProgram
.
makeVtxFragSources
(
es3fShaderDerivateTests
.
genVertexSource
(
this
.
m_coordDataType
this
.
m_coordPrecision
)
this
.
m_fragmentSrc
)
)
;
var
rnd
=
new
deRandom
.
Random
(
deString
.
deStringHash
(
this
.
name
)
^
0xbbc24
)
;
var
useFbo
=
this
.
m_surfaceType
!
=
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
;
var
fboFormat
=
this
.
m_surfaceType
=
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
?
gl
.
RGBA32UI
:
gl
.
RGBA8
;
var
viewportSize
=
this
.
getViewportSize
(
)
;
var
viewportX
=
useFbo
?
0
:
rnd
.
getInt
(
0
gl
.
drawingBufferWidth
-
viewportSize
[
0
]
)
;
var
viewportY
=
useFbo
?
0
:
rnd
.
getInt
(
0
gl
.
drawingBufferHeight
-
viewportSize
[
1
]
)
;
var
fbo
=
null
;
var
rbo
=
null
;
var
result
=
null
;
bufferedLogToConsole
(
program
.
getProgramInfo
(
)
.
infoLog
)
;
if
(
!
program
.
isOk
(
)
)
assertMsgOptions
(
false
'
Compile
failed
'
false
true
)
;
if
(
useFbo
)
{
bufferedLogToConsole
(
'
Rendering
to
FBO
format
=
'
+
wtu
.
glEnumToString
(
gl
fboFormat
)
+
'
samples
=
'
+
this
.
m_numSamples
)
;
fbo
=
gl
.
createFramebuffer
(
)
;
rbo
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
rbo
)
;
gl
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
this
.
m_numSamples
fboFormat
viewportSize
[
0
]
viewportSize
[
1
]
)
;
gl
.
bindFramebuffer
(
gl
.
FRAMEBUFFER
fbo
)
;
gl
.
framebufferRenderbuffer
(
gl
.
FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
rbo
)
;
}
else
{
var
pixelFormat
=
tcuPixelFormat
.
PixelFormatFromContext
(
gl
)
;
bufferedLogToConsole
(
'
Rendering
to
default
framebuffer
\
n
'
+
'
\
tColor
depth
:
R
=
'
+
pixelFormat
.
redBits
+
'
G
=
'
+
pixelFormat
.
greenBits
+
'
B
=
'
+
pixelFormat
.
blueBits
+
'
A
=
'
+
pixelFormat
.
alphaBits
)
;
}
bufferedLogToConsole
(
'
in
:
'
+
this
.
m_coordMin
+
'
'
+
this
.
m_coordMax
+
'
\
n
'
+
'
v_coord
.
x
=
in
.
x
*
x
\
n
'
+
'
v_coord
.
y
=
in
.
y
*
y
\
n
'
+
'
v_coord
.
z
=
in
.
z
*
(
x
+
y
)
/
2
\
n
'
+
'
v_coord
.
w
=
in
.
w
*
(
1
-
(
x
+
y
)
/
2
)
\
n
'
+
'
\
n
'
+
'
u_scale
:
'
+
this
.
m_derivScale
+
'
u_bias
:
'
+
this
.
m_derivBias
+
'
(
displayed
values
have
scale
/
bias
removed
)
'
+
'
Viewport
:
'
+
viewportSize
[
0
]
+
'
x
'
+
viewportSize
[
1
]
+
'
gl
.
FRAGMENT_SHADER_DERIVATE_HINT
:
'
+
wtu
.
glEnumToString
(
gl
this
.
m_hint
)
)
;
var
positions
=
[
-
1
.
0
-
1
.
0
0
.
0
1
.
0
-
1
.
0
1
.
0
0
.
0
1
.
0
1
.
0
-
1
.
0
0
.
0
1
.
0
1
.
0
1
.
0
0
.
0
1
.
0
]
;
var
coords
=
[
this
.
m_coordMin
[
0
]
this
.
m_coordMin
[
1
]
this
.
m_coordMin
[
2
]
this
.
m_coordMax
[
3
]
this
.
m_coordMin
[
0
]
this
.
m_coordMax
[
1
]
(
this
.
m_coordMin
[
2
]
+
this
.
m_coordMax
[
2
]
)
*
0
.
5
(
this
.
m_coordMin
[
3
]
+
this
.
m_coordMax
[
3
]
)
*
0
.
5
this
.
m_coordMax
[
0
]
this
.
m_coordMin
[
1
]
(
this
.
m_coordMin
[
2
]
+
this
.
m_coordMax
[
2
]
)
*
0
.
5
(
this
.
m_coordMin
[
3
]
+
this
.
m_coordMax
[
3
]
)
*
0
.
5
this
.
m_coordMax
[
0
]
this
.
m_coordMax
[
1
]
this
.
m_coordMax
[
2
]
this
.
m_coordMin
[
3
]
]
;
var
vertexArrays
=
[
gluDrawUtil
.
newFloatVertexArrayBinding
(
'
a_position
'
4
4
0
positions
)
gluDrawUtil
.
newFloatVertexArrayBinding
(
'
a_coord
'
4
4
0
coords
)
]
;
var
indices
=
[
0
2
1
2
3
1
]
;
gl
.
clearColor
(
0
.
125
0
.
25
0
.
5
1
.
0
)
;
gl
.
clear
(
gl
.
COLOR_BUFFER_BIT
|
gl
.
DEPTH_BUFFER_BIT
|
gl
.
STENCIL_BUFFER_BIT
)
;
gl
.
disable
(
gl
.
DITHER
)
;
gl
.
useProgram
(
program
.
getProgram
(
)
)
;
var
scaleLoc
=
gl
.
getUniformLocation
(
program
.
getProgram
(
)
'
u_scale
'
)
;
var
biasLoc
=
gl
.
getUniformLocation
(
program
.
getProgram
(
)
'
u_bias
'
)
;
switch
(
this
.
m_dataType
)
{
case
gluShaderUtil
.
DataType
.
FLOAT
:
gl
.
uniform1f
(
scaleLoc
this
.
m_derivScale
[
0
]
)
;
gl
.
uniform1f
(
biasLoc
this
.
m_derivBias
[
0
]
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC2
:
gl
.
uniform2fv
(
scaleLoc
this
.
m_derivScale
.
slice
(
0
2
)
)
;
gl
.
uniform2fv
(
biasLoc
this
.
m_derivBias
.
slice
(
0
2
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC3
:
gl
.
uniform3fv
(
scaleLoc
this
.
m_derivScale
.
slice
(
0
3
)
)
;
gl
.
uniform3fv
(
biasLoc
this
.
m_derivBias
.
slice
(
0
3
)
)
;
break
;
case
gluShaderUtil
.
DataType
.
FLOAT_VEC4
:
gl
.
uniform4fv
(
scaleLoc
this
.
m_derivScale
)
;
gl
.
uniform4fv
(
biasLoc
this
.
m_derivBias
)
;
break
;
default
:
throw
new
Error
(
'
Data
Type
not
supported
:
'
+
this
.
m_dataType
)
;
}
glsShaderRenderCase
.
setupDefaultUniforms
(
program
.
getProgram
(
)
)
;
this
.
setupRenderState
(
program
.
getProgram
(
)
)
;
gl
.
hint
(
gl
.
FRAGMENT_SHADER_DERIVATIVE_HINT
this
.
m_hint
)
;
gl
.
viewport
(
viewportX
viewportY
viewportSize
[
0
]
viewportSize
[
1
]
)
;
gluDrawUtil
.
draw
(
gl
program
.
getProgram
(
)
vertexArrays
gluDrawUtil
.
triangles
(
indices
)
)
;
var
isMSAA
=
useFbo
&
&
this
.
m_numSamples
>
0
;
var
resFbo
=
null
;
var
resRbo
=
null
;
if
(
isMSAA
)
{
resFbo
=
gl
.
createFramebuffer
(
)
;
resRbo
=
gl
.
createRenderbuffer
(
)
;
gl
.
bindRenderbuffer
(
gl
.
RENDERBUFFER
resRbo
)
;
gl
.
renderbufferStorageMultisample
(
gl
.
RENDERBUFFER
0
fboFormat
viewportSize
[
0
]
viewportSize
[
1
]
)
;
gl
.
bindFramebuffer
(
gl
.
DRAW_FRAMEBUFFER
resFbo
)
;
gl
.
framebufferRenderbuffer
(
gl
.
DRAW_FRAMEBUFFER
gl
.
COLOR_ATTACHMENT0
gl
.
RENDERBUFFER
resRbo
)
;
gl
.
blitFramebuffer
(
0
0
viewportSize
[
0
]
viewportSize
[
1
]
0
0
viewportSize
[
0
]
viewportSize
[
1
]
gl
.
COLOR_BUFFER_BIT
gl
.
NEAREST
)
;
gl
.
bindFramebuffer
(
gl
.
READ_FRAMEBUFFER
resFbo
)
;
}
switch
(
this
.
m_surfaceType
)
{
case
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
:
case
es3fShaderDerivateTests
.
SurfaceType
.
UNORM_FBO
:
var
dataFormat
=
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
;
result
=
new
tcuTexture
.
TextureLevel
(
dataFormat
viewportSize
[
0
]
viewportSize
[
1
]
)
;
gluPixelTransfer
.
readPixels
(
gl
viewportX
viewportY
dataFormat
result
)
;
break
;
case
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
:
var
dataFormat
=
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
FLOAT
)
;
var
transferFormat
=
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNSIGNED_INT32
)
;
result
=
new
tcuTexture
.
TextureLevel
(
dataFormat
viewportSize
[
0
]
viewportSize
[
1
]
)
;
gluPixelTransfer
.
readPixels
(
gl
viewportX
viewportY
transferFormat
result
)
;
break
;
default
:
throw
new
Error
(
'
Surface
Type
not
supported
:
'
+
this
.
m_surfaceType
)
;
}
var
errorMask
=
new
tcuSurface
.
Surface
(
result
.
getWidth
(
)
result
.
getHeight
(
)
)
;
errorMask
.
getAccess
(
)
.
clear
(
tcuRGBA
.
RGBA
.
green
.
toVec
(
)
)
;
var
isOk
=
this
.
verify
(
result
.
getAccess
(
)
errorMask
.
getAccess
(
)
)
;
if
(
!
isOk
)
{
tcuLogImage
.
logImage
(
'
Rendered
'
'
Rendered
image
'
result
.
getAccess
(
)
)
;
tcuLogImage
.
logImage
(
'
ErrorMask
'
'
Error
mask
'
errorMask
.
getAccess
(
)
)
;
testFailedOptions
(
'
Fail
'
false
)
;
}
else
testPassedOptions
(
'
Pass
'
true
)
;
gl
.
deleteFramebuffer
(
fbo
)
;
gl
.
deleteRenderbuffer
(
rbo
)
;
gl
.
deleteFramebuffer
(
resFbo
)
;
gl
.
deleteRenderbuffer
(
resRbo
)
;
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
.
getSurfaceThreshold
=
function
(
)
{
switch
(
this
.
m_surfaceType
)
{
case
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
:
var
pixelFormat
=
tcuPixelFormat
.
PixelFormatFromContext
(
gl
)
;
var
channelBits
=
[
pixelFormat
.
redBits
pixelFormat
.
greenBits
pixelFormat
.
blueBits
pixelFormat
.
alphaBits
]
;
var
intThreshold
=
deMath
.
arrayShiftLeft
(
[
1
1
1
1
]
deMath
.
subtract
(
[
8
8
8
8
]
channelBits
)
)
;
var
normThreshold
=
deMath
.
scale
(
intThreshold
1
.
0
/
255
.
0
)
;
return
normThreshold
;
case
es3fShaderDerivateTests
.
SurfaceType
.
UNORM_FBO
:
return
deMath
.
scale
(
[
1
1
1
1
]
1
.
0
/
255
.
0
)
;
case
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
:
return
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
default
:
assertMsgOptions
(
false
'
Surface
Type
not
supported
.
Falling
back
to
default
retun
value
[
0
.
0
0
.
0
0
.
0
0
.
0
]
'
false
false
)
;
return
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
}
}
;
es3fShaderDerivateTests
.
ConstantDerivateCase
=
function
(
name
description
func
type
)
{
es3fShaderDerivateTests
.
TriangleDerivateCase
.
call
(
this
name
description
)
;
this
.
m_func
=
func
;
this
.
m_dataType
=
type
;
this
.
m_precision
=
gluShaderUtil
.
precision
.
PRECISION_HIGHP
;
this
.
m_coordDataType
=
this
.
m_dataType
;
this
.
m_coordPrecision
=
this
.
m_precision
;
}
;
es3fShaderDerivateTests
.
ConstantDerivateCase
.
prototype
=
Object
.
create
(
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
)
;
es3fShaderDerivateTests
.
ConstantDerivateCase
.
prototype
.
constructor
=
es3fShaderDerivateTests
.
ConstantDerivateCase
;
es3fShaderDerivateTests
.
ConstantDerivateCase
.
prototype
.
init
=
function
(
)
{
var
fragmentTmpl
=
'
'
+
'
#
version
300
es
\
n
'
+
'
layout
(
location
=
0
)
out
mediump
vec4
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
=
{
FUNC
}
(
{
VALUE
}
)
*
u_scale
+
u_bias
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
;
var
fragmentParams
=
{
}
;
fragmentParams
[
'
PRECISION
'
]
=
gluShaderUtil
.
getPrecisionName
(
this
.
m_precision
)
;
fragmentParams
[
'
DATATYPE
'
]
=
gluShaderUtil
.
getDataTypeName
(
this
.
m_dataType
)
;
fragmentParams
[
'
FUNC
'
]
=
es3fShaderDerivateTests
.
getDerivateFuncName
(
this
.
m_func
)
;
fragmentParams
[
'
VALUE
'
]
=
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC4
?
'
vec4
(
1
.
0
7
.
2
-
1e5
0
.
0
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC3
?
'
vec3
(
1e2
8
.
0
0
.
01
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
?
'
vec2
(
-
0
.
0
2
.
7
)
'
:
'
7
.
7
'
;
fragmentParams
[
'
CAST_TO_OUTPUT
'
]
=
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC4
?
'
res
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC3
?
'
vec4
(
res
1
.
0
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
?
'
vec4
(
res
0
.
0
1
.
0
)
'
:
'
vec4
(
res
0
.
0
0
.
0
1
.
0
)
'
;
this
.
m_fragmentSrc
=
tcuStringTemplate
.
specialize
(
fragmentTmpl
fragmentParams
)
;
this
.
m_derivScale
=
[
1e3
1e3
1e3
1e3
]
;
this
.
m_derivBias
=
[
0
.
5
0
.
5
0
.
5
0
.
5
]
;
}
;
es3fShaderDerivateTests
.
ConstantDerivateCase
.
prototype
.
verify
=
function
(
result
errorMask
)
{
var
reference
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
var
threshold
=
deMath
.
divide
(
this
.
getSurfaceThreshold
(
)
deMath
.
abs
(
this
.
m_derivScale
)
)
;
return
es3fShaderDerivateTests
.
verifyConstantDerivate
(
result
errorMask
this
.
m_dataType
reference
threshold
this
.
m_derivScale
this
.
m_derivBias
)
;
}
;
es3fShaderDerivateTests
.
LinearDerivateCase
=
function
(
name
description
func
type
precision
hint
surfaceType
numSamples
fragmentSrcTmpl
)
{
es3fShaderDerivateTests
.
TriangleDerivateCase
.
call
(
this
name
description
)
;
this
.
m_func
=
func
;
this
.
m_fragmentTmpl
=
fragmentSrcTmpl
;
this
.
m_dataType
=
type
;
this
.
m_precision
=
precision
;
this
.
m_coordDataType
=
this
.
m_dataType
;
this
.
m_coordPrecision
=
this
.
m_precision
;
this
.
m_hint
=
hint
;
this
.
m_surfaceType
=
surfaceType
;
this
.
m_numSamples
=
numSamples
;
}
;
es3fShaderDerivateTests
.
LinearDerivateCase
.
prototype
=
Object
.
create
(
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
)
;
es3fShaderDerivateTests
.
LinearDerivateCase
.
prototype
.
constructor
=
es3fShaderDerivateTests
.
LinearDerivateCase
;
es3fShaderDerivateTests
.
LinearDerivateCase
.
prototype
.
init
=
function
(
)
{
var
viewportSize
=
this
.
getViewportSize
(
)
;
var
w
=
viewportSize
[
0
]
;
var
h
=
viewportSize
[
1
]
;
var
packToInt
=
this
.
m_surfaceType
=
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
;
var
fragmentParams
=
{
}
;
fragmentParams
[
'
OUTPUT_TYPE
'
]
=
gluShaderUtil
.
getDataTypeName
(
packToInt
?
gluShaderUtil
.
DataType
.
UINT_VEC4
:
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
fragmentParams
[
'
OUTPUT_PREC
'
]
=
gluShaderUtil
.
getPrecisionName
(
packToInt
?
gluShaderUtil
.
precision
.
PRECISION_HIGHP
:
this
.
m_precision
)
;
fragmentParams
[
'
PRECISION
'
]
=
gluShaderUtil
.
getPrecisionName
(
this
.
m_precision
)
;
fragmentParams
[
'
DATATYPE
'
]
=
gluShaderUtil
.
getDataTypeName
(
this
.
m_dataType
)
;
fragmentParams
[
'
FUNC
'
]
=
es3fShaderDerivateTests
.
getDerivateFuncName
(
this
.
m_func
)
;
if
(
packToInt
)
{
fragmentParams
[
'
CAST_TO_OUTPUT
'
]
=
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC4
?
'
floatBitsToUint
(
res
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC3
?
'
floatBitsToUint
(
vec4
(
res
1
.
0
)
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
?
'
floatBitsToUint
(
vec4
(
res
0
.
0
1
.
0
)
)
'
:
'
floatBitsToUint
(
vec4
(
res
0
.
0
0
.
0
1
.
0
)
)
'
;
}
else
{
fragmentParams
[
'
CAST_TO_OUTPUT
'
]
=
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC4
?
'
res
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC3
?
'
vec4
(
res
1
.
0
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
?
'
vec4
(
res
0
.
0
1
.
0
)
'
:
'
vec4
(
res
0
.
0
0
.
0
1
.
0
)
'
;
}
this
.
m_fragmentSrc
=
tcuStringTemplate
.
specialize
(
this
.
m_fragmentTmpl
fragmentParams
)
;
switch
(
this
.
m_precision
)
{
case
gluShaderUtil
.
precision
.
PRECISION_HIGHP
:
this
.
m_coordMin
=
[
-
97
.
0
.
2
71
.
74
.
]
;
this
.
m_coordMax
=
[
-
13
.
2
-
77
.
44
.
76
.
]
;
break
;
case
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
:
this
.
m_coordMin
=
[
-
37
.
0
47
.
-
7
.
0
.
0
]
;
this
.
m_coordMax
=
[
-
1
.
0
12
.
7
.
19
.
]
;
break
;
case
gluShaderUtil
.
precision
.
PRECISION_LOWP
:
this
.
m_coordMin
=
[
0
.
0
-
1
.
0
0
.
0
1
.
0
]
;
this
.
m_coordMax
=
[
1
.
0
1
.
0
-
1
.
0
-
1
.
0
]
;
break
;
default
:
throw
new
Error
(
'
Precision
not
supported
:
'
+
this
.
m_precision
)
;
}
if
(
this
.
m_surfaceType
=
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
)
{
this
.
m_derivScale
=
[
1
.
0
1
.
0
1
.
0
1
.
0
]
;
this
.
m_derivBias
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
}
else
{
var
dx
=
deMath
.
divide
(
deMath
.
subtract
(
this
.
m_coordMax
this
.
m_coordMin
)
[
w
w
w
*
0
.
5
-
w
*
0
.
5
]
)
;
var
dy
=
deMath
.
divide
(
deMath
.
subtract
(
this
.
m_coordMax
this
.
m_coordMin
)
[
h
h
h
*
0
.
5
-
h
*
0
.
5
]
)
;
switch
(
this
.
m_func
)
{
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
:
this
.
m_derivScale
=
deMath
.
divide
(
[
0
.
5
0
.
5
0
.
5
0
.
5
]
dx
)
;
break
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDY
:
this
.
m_derivScale
=
deMath
.
divide
(
[
0
.
5
0
.
5
0
.
5
0
.
5
]
dy
)
;
break
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
FWIDTH
:
this
.
m_derivScale
=
deMath
.
divide
(
[
0
.
5
0
.
5
0
.
5
0
.
5
]
deMath
.
add
(
deMath
.
abs
(
dx
)
deMath
.
abs
(
dy
)
)
)
;
break
;
default
:
throw
new
Error
(
'
Derivate
Function
not
supported
:
'
+
this
.
m_func
)
;
}
this
.
m_derivBias
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
}
}
;
es3fShaderDerivateTests
.
LinearDerivateCase
.
prototype
.
verify
=
function
(
result
errorMask
)
{
var
xScale
=
[
1
.
0
0
.
0
0
.
5
-
0
.
5
]
;
var
yScale
=
[
0
.
0
1
.
0
0
.
5
-
0
.
5
]
;
var
surfaceThreshold
=
deMath
.
divide
(
this
.
getSurfaceThreshold
(
)
deMath
.
abs
(
this
.
m_derivScale
)
)
;
var
w
;
var
h
;
var
reference
;
var
threshold
;
if
(
this
.
m_func
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
|
|
this
.
m_func
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDY
)
{
var
isX
=
this
.
m_func
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
;
var
div
=
isX
?
result
.
getWidth
(
)
:
result
.
getHeight
(
)
;
var
scale
=
isX
?
xScale
:
yScale
;
reference
=
deMath
.
multiply
(
deMath
.
scale
(
deMath
.
subtract
(
this
.
m_coordMax
this
.
m_coordMin
)
1
/
div
)
scale
)
;
var
opThreshold
=
es3fShaderDerivateTests
.
getDerivateThreshold
(
this
.
m_precision
deMath
.
multiply
(
this
.
m_coordMin
scale
)
deMath
.
multiply
(
this
.
m_coordMax
scale
)
reference
)
;
threshold
=
deMath
.
max
(
surfaceThreshold
opThreshold
)
;
bufferedLogToConsole
(
'
Verifying
result
image
.
\
n
'
+
'
\
tValid
derivative
is
'
+
reference
+
'
with
threshold
'
+
threshold
)
;
if
(
es3fShaderDerivateTests
.
verifyConstantDerivate
(
result
errorMask
this
.
m_dataType
reference
threshold
this
.
m_derivScale
this
.
m_derivBias
es3fShaderDerivateTests
.
VerificationLogging
.
LOG_NOTHING
)
)
{
bufferedLogToConsole
(
'
No
incorrect
derivatives
found
result
valid
.
'
)
;
return
true
;
}
bufferedLogToConsole
(
'
Initial
verification
failed
verifying
image
by
calculating
accurate
error
bounds
for
each
result
pixel
.
\
n
'
+
'
\
tVerifying
each
result
derivative
is
within
its
range
of
legal
result
values
.
'
)
;
var
viewportSize
=
this
.
getViewportSize
(
)
;
var
valueRamp
=
deMath
.
subtract
(
this
.
m_coordMax
this
.
m_coordMin
)
;
var
function_
=
new
es3fShaderDerivateTests
.
Linear2DFunctionEvaluator
(
)
;
w
=
viewportSize
[
0
]
;
h
=
viewportSize
[
1
]
;
function_
.
matrix
.
setRow
(
0
[
valueRamp
[
0
]
/
w
0
.
0
this
.
m_coordMin
[
0
]
]
)
;
function_
.
matrix
.
setRow
(
1
[
0
.
0
valueRamp
[
1
]
/
h
this
.
m_coordMin
[
1
]
]
)
;
function_
.
matrix
.
setRow
(
2
deMath
.
scale
(
[
valueRamp
[
2
]
/
w
valueRamp
[
2
]
/
h
this
.
m_coordMin
[
2
]
+
this
.
m_coordMin
[
2
]
]
1
/
2
.
0
)
)
;
function_
.
matrix
.
setRow
(
3
deMath
.
scale
(
[
-
valueRamp
[
3
]
/
w
-
valueRamp
[
3
]
/
h
this
.
m_coordMax
[
3
]
+
this
.
m_coordMax
[
3
]
]
1
/
2
.
0
)
)
;
return
es3fShaderDerivateTests
.
reverifyConstantDerivateWithFlushRelaxations
(
result
errorMask
this
.
m_dataType
this
.
m_precision
this
.
m_derivScale
this
.
m_derivBias
surfaceThreshold
this
.
m_func
function_
)
;
}
else
{
assertMsgOptions
(
this
.
m_func
=
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
FWIDTH
'
Expected
DerivateFunc
.
FWIDTH
'
false
true
)
;
w
=
result
.
getWidth
(
)
;
h
=
result
.
getHeight
(
)
;
var
dx
=
deMath
.
multiply
(
deMath
.
scale
(
deMath
.
subtract
(
this
.
m_coordMax
this
.
m_coordMin
)
1
/
w
)
xScale
)
;
var
dy
=
deMath
.
multiply
(
deMath
.
scale
(
deMath
.
subtract
(
this
.
m_coordMax
this
.
m_coordMin
)
1
/
h
)
yScale
)
;
reference
=
deMath
.
add
(
deMath
.
abs
(
dx
)
deMath
.
abs
(
dy
)
)
;
var
dxThreshold
=
es3fShaderDerivateTests
.
getDerivateThreshold
(
this
.
m_precision
deMath
.
multiply
(
this
.
m_coordMin
xScale
)
deMath
.
multiply
(
this
.
m_coordMax
xScale
)
dx
)
;
var
dyThreshold
=
es3fShaderDerivateTests
.
getDerivateThreshold
(
this
.
m_precision
deMath
.
multiply
(
this
.
m_coordMin
yScale
)
deMath
.
multiply
(
this
.
m_coordMax
yScale
)
dy
)
;
threshold
=
deMath
.
max
(
surfaceThreshold
deMath
.
max
(
dxThreshold
dyThreshold
)
)
;
return
es3fShaderDerivateTests
.
verifyConstantDerivate
(
result
errorMask
this
.
m_dataType
reference
threshold
this
.
m_derivScale
this
.
m_derivBias
)
;
}
}
;
es3fShaderDerivateTests
.
TextureDerivateCase
=
function
(
name
description
func
type
precision
hint
surfaceType
numSamples
)
{
es3fShaderDerivateTests
.
TriangleDerivateCase
.
call
(
this
name
description
)
;
this
.
m_func
=
func
;
this
.
m_texture
=
null
;
this
.
m_texValueMin
=
[
]
;
this
.
m_texValueMax
=
[
]
;
this
.
m_dataType
=
type
;
this
.
m_precision
=
precision
;
this
.
m_coordDataType
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
;
this
.
m_coordPrecision
=
gluShaderUtil
.
precision
.
PRECISION_HIGHP
;
this
.
m_hint
=
hint
;
this
.
m_surfaceType
=
surfaceType
;
this
.
m_numSamples
=
numSamples
;
}
;
es3fShaderDerivateTests
.
TextureDerivateCase
.
prototype
=
Object
.
create
(
es3fShaderDerivateTests
.
TriangleDerivateCase
.
prototype
)
;
es3fShaderDerivateTests
.
TextureDerivateCase
.
prototype
.
constructor
=
es3fShaderDerivateTests
.
TextureDerivateCase
;
es3fShaderDerivateTests
.
TextureDerivateCase
.
prototype
.
deinit
=
function
(
)
{
this
.
m_texture
=
null
;
}
;
es3fShaderDerivateTests
.
TextureDerivateCase
.
prototype
.
init
=
function
(
)
{
var
fragmentTmpl
=
'
'
+
'
#
version
300
es
\
n
'
+
'
in
highp
vec2
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
sampler2D
u_sampler
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
vec4
tex
=
texture
(
u_sampler
v_coord
)
;
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
=
{
FUNC
}
(
tex
{
SWIZZLE
}
)
*
u_scale
+
u_bias
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
;
var
packToInt
=
this
.
m_surfaceType
=
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
;
var
fragmentParams
=
{
}
;
var
viewportSize
;
fragmentParams
[
'
OUTPUT_TYPE
'
]
=
gluShaderUtil
.
getDataTypeName
(
packToInt
?
gluShaderUtil
.
DataType
.
UINT_VEC4
:
gluShaderUtil
.
DataType
.
FLOAT_VEC4
)
;
fragmentParams
[
'
OUTPUT_PREC
'
]
=
gluShaderUtil
.
getPrecisionName
(
packToInt
?
gluShaderUtil
.
precision
.
PRECISION_HIGHP
:
this
.
m_precision
)
;
fragmentParams
[
'
PRECISION
'
]
=
gluShaderUtil
.
getPrecisionName
(
this
.
m_precision
)
;
fragmentParams
[
'
DATATYPE
'
]
=
gluShaderUtil
.
getDataTypeName
(
this
.
m_dataType
)
;
fragmentParams
[
'
FUNC
'
]
=
es3fShaderDerivateTests
.
getDerivateFuncName
(
this
.
m_func
)
;
fragmentParams
[
'
SWIZZLE
'
]
=
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC4
?
'
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC3
?
'
.
xyz
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
?
'
.
xy
'
:
'
.
x
'
;
if
(
packToInt
)
{
fragmentParams
[
'
CAST_TO_OUTPUT
'
]
=
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC4
?
'
floatBitsToUint
(
res
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC3
?
'
floatBitsToUint
(
vec4
(
res
1
.
0
)
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
?
'
floatBitsToUint
(
vec4
(
res
0
.
0
1
.
0
)
)
'
:
'
floatBitsToUint
(
vec4
(
res
0
.
0
0
.
0
1
.
0
)
)
'
;
}
else
{
fragmentParams
[
'
CAST_TO_OUTPUT
'
]
=
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC4
?
'
res
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC3
?
'
vec4
(
res
1
.
0
)
'
:
this
.
m_dataType
=
=
=
gluShaderUtil
.
DataType
.
FLOAT_VEC2
?
'
vec4
(
res
0
.
0
1
.
0
)
'
:
'
vec4
(
res
0
.
0
0
.
0
1
.
0
)
'
;
}
this
.
m_fragmentSrc
=
tcuStringTemplate
.
specialize
(
fragmentTmpl
fragmentParams
)
;
switch
(
this
.
m_precision
)
{
case
gluShaderUtil
.
precision
.
PRECISION_HIGHP
:
this
.
m_texValueMin
=
[
-
97
.
0
.
2
71
.
74
.
]
;
this
.
m_texValueMax
=
[
-
13
.
2
-
77
.
44
.
76
.
]
;
break
;
case
gluShaderUtil
.
precision
.
PRECISION_MEDIUMP
:
this
.
m_texValueMin
=
[
-
37
.
0
47
.
-
7
.
0
.
0
]
;
this
.
m_texValueMax
=
[
-
1
.
0
12
.
7
.
19
.
]
;
break
;
case
gluShaderUtil
.
precision
.
PRECISION_LOWP
:
this
.
m_texValueMin
=
[
0
.
0
-
1
.
0
0
.
0
1
.
0
]
;
this
.
m_texValueMax
=
[
1
.
0
1
.
0
-
1
.
0
-
1
.
0
]
;
break
;
default
:
throw
new
Error
(
false
'
Precision
not
supported
:
'
+
this
.
m_precision
)
;
}
viewportSize
=
this
.
getViewportSize
(
)
;
assertMsgOptions
(
!
this
.
m_texture
'
Texture
not
null
'
false
true
)
;
this
.
m_texture
=
gluTexture
.
texture2DFromInternalFormat
(
gl
this
.
m_precision
=
=
=
gluShaderUtil
.
precision
.
PRECISION_HIGHP
?
gl
.
RGBA32F
:
gl
.
RGBA16F
viewportSize
[
0
]
viewportSize
[
1
]
)
;
this
.
m_texture
.
getRefTexture
(
)
.
allocLevel
(
0
)
;
this
.
m_coordMin
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
this
.
m_coordMax
=
[
1
.
0
1
.
0
1
.
0
1
.
0
]
;
var
level0
=
this
.
m_texture
.
getRefTexture
(
)
.
getLevel
(
0
)
;
for
(
var
y
=
0
;
y
<
level0
.
getHeight
(
)
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
level0
.
getWidth
(
)
;
x
+
+
)
{
var
xf
=
(
x
+
0
.
5
)
/
level0
.
getWidth
(
)
;
var
yf
=
(
y
+
0
.
5
)
/
level0
.
getHeight
(
)
;
var
s
=
[
xf
yf
(
xf
+
yf
)
/
2
.
0
1
.
0
-
(
xf
+
yf
)
/
2
.
0
]
;
level0
.
setPixel
(
deMath
.
add
(
this
.
m_texValueMin
deMath
.
multiply
(
deMath
.
subtract
(
this
.
m_texValueMax
this
.
m_texValueMin
)
s
)
)
x
y
)
;
}
}
this
.
m_texture
.
upload
(
)
;
if
(
this
.
m_surfaceType
=
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
)
{
this
.
m_derivScale
=
[
1
.
0
1
.
0
1
.
0
1
.
0
]
;
this
.
m_derivBias
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
}
else
{
viewportSize
=
this
.
getViewportSize
(
)
;
var
w
=
viewportSize
[
0
]
;
var
h
=
viewportSize
[
1
]
;
var
dx
=
deMath
.
divide
(
deMath
.
subtract
(
this
.
m_texValueMax
this
.
m_texValueMin
)
[
w
w
w
*
0
.
5
-
w
*
0
.
5
]
)
;
var
dy
=
deMath
.
divide
(
deMath
.
subtract
(
this
.
m_texValueMax
this
.
m_texValueMin
)
[
h
h
h
*
0
.
5
-
h
*
0
.
5
]
)
;
switch
(
this
.
m_func
)
{
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
:
this
.
m_derivScale
=
deMath
.
divide
(
[
0
.
5
0
.
5
0
.
5
0
.
5
]
dx
)
;
break
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
DFDY
:
this
.
m_derivScale
=
deMath
.
divide
(
[
0
.
5
0
.
5
0
.
5
0
.
5
]
dy
)
;
break
;
case
es3fShaderDerivateTests
.
DerivateFunc
.
FWIDTH
:
this
.
m_derivScale
=
deMath
.
divide
(
[
0
.
5
0
.
5
0
.
5
0
.
5
]
deMath
.
add
(
deMath
.
abs
(
dx
)
deMath
.
abs
(
dy
)
)
)
;
break
;
default
:
throw
new
Error
(
'
Derivate
Function
not
supported
:
'
+
this
.
m_func
)
;
}
this
.
m_derivBias
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
}
}
;
es3fShaderDerivateTests
.
TextureDerivateCase
.
prototype
.
setupRenderState
=
function
(
program
)
{
var
texUnit
=
1
;
gl
.
activeTexture
(
gl
.
TEXTURE0
+
texUnit
)
;
gl
.
bindTexture
(
gl
.
TEXTURE_2D
this
.
m_texture
.
getGLTexture
(
)
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MIN_FILTER
gl
.
NEAREST
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_MAG_FILTER
gl
.
NEAREST
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_S
gl
.
CLAMP_TO_EDGE
)
;
gl
.
texParameteri
(
gl
.
TEXTURE_2D
gl
.
TEXTURE_WRAP_T
gl
.
CLAMP_TO_EDGE
)
;
gl
.
uniform1i
(
gl
.
getUniformLocation
(
program
'
u_sampler
'
)
texUnit
)
;
}
;
es3fShaderDerivateTests
.
TextureDerivateCase
.
prototype
.
verify
=
function
(
result
errorMask
)
{
if
(
result
.
getWidth
(
)
<
2
|
|
result
.
getHeight
(
)
<
2
)
throw
new
Error
(
'
Too
small
viewport
'
)
;
var
compareArea
=
tcuTextureUtil
.
getSubregion
(
result
1
1
0
result
.
getWidth
(
)
-
2
result
.
getHeight
(
)
-
2
1
)
;
var
maskArea
=
tcuTextureUtil
.
getSubregion
(
errorMask
1
1
0
errorMask
.
getWidth
(
)
-
2
errorMask
.
getHeight
(
)
-
2
1
)
;
var
xScale
=
[
1
.
0
0
.
0
0
.
5
-
0
.
5
]
;
var
yScale
=
[
0
.
0
1
.
0
0
.
5
-
0
.
5
]
;
var
w
=
result
.
getWidth
(
)
;
var
h
=
result
.
getHeight
(
)
;
var
surfaceThreshold
=
deMath
.
divide
(
this
.
getSurfaceThreshold
(
)
deMath
.
abs
(
this
.
m_derivScale
)
)
;
var
reference
;
var
threshold
;
if
(
this
.
m_func
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
|
|
this
.
m_func
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDY
)
{
var
isX
=
this
.
m_func
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
DFDX
;
var
div
=
isX
?
w
:
h
;
var
scale
=
isX
?
xScale
:
yScale
;
reference
=
deMath
.
multiply
(
deMath
.
scale
(
deMath
.
subtract
(
this
.
m_texValueMax
this
.
m_texValueMin
)
1
/
div
)
scale
)
;
var
opThreshold
=
es3fShaderDerivateTests
.
getDerivateThreshold
(
this
.
m_precision
deMath
.
multiply
(
this
.
m_texValueMin
scale
)
deMath
.
multiply
(
this
.
m_texValueMax
scale
)
reference
)
;
threshold
=
deMath
.
max
(
surfaceThreshold
opThreshold
)
;
bufferedLogToConsole
(
'
Verifying
result
image
.
\
n
'
+
'
\
tValid
derivative
is
'
+
reference
+
'
with
threshold
'
+
threshold
)
;
if
(
es3fShaderDerivateTests
.
verifyConstantDerivate
(
compareArea
maskArea
this
.
m_dataType
reference
threshold
this
.
m_derivScale
this
.
m_derivBias
es3fShaderDerivateTests
.
VerificationLogging
.
LOG_NOTHING
)
)
{
bufferedLogToConsole
(
'
No
incorrect
derivatives
found
result
valid
.
'
)
;
return
true
;
}
bufferedLogToConsole
(
'
Initial
verification
failed
verifying
image
by
calculating
accurate
error
bounds
for
each
result
pixel
.
\
n
'
+
'
\
tVerifying
each
result
derivative
is
within
its
range
of
legal
result
values
.
'
)
;
var
valueRamp
=
deMath
.
subtract
(
this
.
m_texValueMax
this
.
m_texValueMin
)
;
var
function_
=
new
es3fShaderDerivateTests
.
Linear2DFunctionEvaluator
(
)
;
function_
.
matrix
.
setRow
(
0
[
valueRamp
[
0
]
/
w
0
.
0
this
.
m_texValueMin
[
0
]
]
)
;
function_
.
matrix
.
setRow
(
1
[
0
.
0
valueRamp
[
1
]
/
h
this
.
m_texValueMin
[
1
]
]
)
;
function_
.
matrix
.
setRow
(
2
deMath
.
scale
(
[
valueRamp
[
2
]
/
w
valueRamp
[
2
]
/
h
this
.
m_texValueMin
[
2
]
+
this
.
m_texValueMin
[
2
]
]
1
/
2
.
0
)
)
;
function_
.
matrix
.
setRow
(
3
deMath
.
scale
(
[
-
valueRamp
[
3
]
/
w
-
valueRamp
[
3
]
/
h
this
.
m_texValueMax
[
3
]
+
this
.
m_texValueMax
[
3
]
]
1
/
2
.
0
)
)
;
return
es3fShaderDerivateTests
.
reverifyConstantDerivateWithFlushRelaxations
(
compareArea
maskArea
this
.
m_dataType
this
.
m_precision
this
.
m_derivScale
this
.
m_derivBias
surfaceThreshold
this
.
m_func
function_
)
;
}
else
{
assertMsgOptions
(
this
.
m_func
=
=
es3fShaderDerivateTests
.
DerivateFunc
.
FWIDTH
'
Expected
Derivate
Function
FWIDTH
'
false
true
)
;
var
dx
=
deMath
.
multiply
(
deMath
.
scale
(
deMath
.
subtract
(
this
.
m_texValueMax
this
.
m_texValueMin
)
1
/
w
)
xScale
)
;
var
dy
=
deMath
.
multiply
(
deMath
.
scale
(
deMath
.
subtract
(
this
.
m_texValueMax
this
.
m_texValueMin
)
1
/
h
)
yScale
)
;
reference
=
deMath
.
add
(
deMath
.
abs
(
dx
)
deMath
.
abs
(
dy
)
)
;
var
dxThreshold
=
es3fShaderDerivateTests
.
getDerivateThreshold
(
this
.
m_precision
deMath
.
multiply
(
this
.
m_texValueMin
xScale
)
deMath
.
multiply
(
this
.
m_texValueMax
xScale
)
dx
)
;
var
dyThreshold
=
es3fShaderDerivateTests
.
getDerivateThreshold
(
this
.
m_precision
deMath
.
multiply
(
this
.
m_texValueMin
yScale
)
deMath
.
multiply
(
this
.
m_texValueMax
yScale
)
dy
)
;
threshold
=
deMath
.
max
(
surfaceThreshold
deMath
.
max
(
dxThreshold
dyThreshold
)
)
;
return
es3fShaderDerivateTests
.
verifyConstantDerivate
(
compareArea
maskArea
this
.
m_dataType
reference
threshold
this
.
m_derivScale
this
.
m_derivBias
)
;
}
;
}
;
es3fShaderDerivateTests
.
ShaderDerivateTests
=
function
(
)
{
tcuTestCase
.
DeqpTest
.
call
(
this
'
derivate
'
'
Derivate
Function
Tests
'
)
;
}
;
es3fShaderDerivateTests
.
ShaderDerivateTests
.
prototype
=
Object
.
create
(
tcuTestCase
.
DeqpTest
.
prototype
)
;
es3fShaderDerivateTests
.
ShaderDerivateTests
.
prototype
.
constructor
=
es3fShaderDerivateTests
.
ShaderDerivateTests
es3fShaderDerivateTests
.
FunctionSpec
=
function
(
name
func
dataType_
precision_
)
{
this
.
name
=
name
;
this
.
function_
=
func
;
this
.
dataType
=
dataType_
;
this
.
precision
=
precision_
;
}
;
es3fShaderDerivateTests
.
ShaderDerivateTests
.
prototype
.
init
=
function
(
)
{
var
testGroup
=
tcuTestCase
.
runner
.
testCases
;
var
LinearDerivateCase
=
function
(
name
description
source
)
{
this
.
name
=
name
;
this
.
description
=
description
;
this
.
source
=
source
;
}
;
var
s_linearDerivateCases
=
[
new
LinearDerivateCase
(
'
linear
'
'
Basic
derivate
of
linearly
interpolated
argument
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
=
{
FUNC
}
(
v_coord
)
*
u_scale
+
u_bias
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
new
LinearDerivateCase
(
'
in_function
'
'
Derivate
of
linear
function
argument
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
computeRes
(
{
PRECISION
}
{
DATATYPE
}
value
)
\
n
'
+
'
{
\
n
'
+
'
return
{
FUNC
}
(
v_coord
)
*
u_scale
+
u_bias
;
\
n
'
+
'
}
\
n
'
+
'
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
=
computeRes
(
v_coord
)
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
new
LinearDerivateCase
(
'
static_if
'
'
Derivate
of
linearly
interpolated
value
in
static
if
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
;
\
n
'
+
'
if
(
false
)
\
n
'
+
'
res
=
{
FUNC
}
(
-
v_coord
)
*
u_scale
+
u_bias
;
\
n
'
+
'
else
\
n
'
+
'
res
=
{
FUNC
}
(
v_coord
)
*
u_scale
+
u_bias
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
new
LinearDerivateCase
(
'
static_loop
'
'
Derivate
of
linearly
interpolated
value
in
static
loop
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
=
{
DATATYPE
}
(
0
.
0
)
;
\
n
'
+
'
for
(
int
i
=
0
;
i
<
2
;
i
+
+
)
\
n
'
+
'
res
+
=
{
FUNC
}
(
v_coord
*
float
(
i
)
)
;
\
n
'
+
'
res
=
res
*
u_scale
+
u_bias
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
new
LinearDerivateCase
(
'
static_switch
'
'
Derivate
of
linearly
interpolated
value
in
static
switch
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
;
\
n
'
+
'
switch
(
1
)
\
n
'
+
'
{
\
n
'
+
'
case
0
:
res
=
{
FUNC
}
(
-
v_coord
)
*
u_scale
+
u_bias
;
break
;
\
n
'
+
'
case
1
:
res
=
{
FUNC
}
(
v_coord
)
*
u_scale
+
u_bias
;
break
;
\
n
'
+
'
}
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
new
LinearDerivateCase
(
'
uniform_if
'
'
Derivate
of
linearly
interpolated
value
in
uniform
if
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
uniform
bool
ub_true
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
;
\
n
'
+
'
if
(
ub_true
)
\
n
'
+
'
res
=
{
FUNC
}
(
v_coord
)
*
u_scale
+
u_bias
;
\
n
'
+
'
else
\
n
'
+
'
res
=
{
FUNC
}
(
-
v_coord
)
*
u_scale
+
u_bias
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
new
LinearDerivateCase
(
'
uniform_loop
'
'
Derivate
of
linearly
interpolated
value
in
uniform
loop
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
uniform
int
ui_two
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
=
{
DATATYPE
}
(
0
.
0
)
;
\
n
'
+
'
for
(
int
i
=
0
;
i
<
ui_two
;
i
+
+
)
\
n
'
+
'
res
+
=
{
FUNC
}
(
v_coord
*
float
(
i
)
)
;
\
n
'
+
'
res
=
res
*
u_scale
+
u_bias
;
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
new
LinearDerivateCase
(
'
uniform_switch
'
'
Derivate
of
linearly
interpolated
value
in
uniform
switch
'
'
#
version
300
es
\
n
'
+
'
in
{
PRECISION
}
{
DATATYPE
}
v_coord
;
\
n
'
+
'
layout
(
location
=
0
)
out
{
OUTPUT_PREC
}
{
OUTPUT_TYPE
}
o_color
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_scale
;
\
n
'
+
'
uniform
{
PRECISION
}
{
DATATYPE
}
u_bias
;
\
n
'
+
'
uniform
int
ui_one
;
\
n
'
+
'
void
main
(
void
)
\
n
'
+
'
{
\
n
'
+
'
{
PRECISION
}
{
DATATYPE
}
res
;
\
n
'
+
'
switch
(
ui_one
)
\
n
'
+
'
{
\
n
'
+
'
case
0
:
res
=
{
FUNC
}
(
-
v_coord
)
*
u_scale
+
u_bias
;
break
;
\
n
'
+
'
case
1
:
res
=
{
FUNC
}
(
v_coord
)
*
u_scale
+
u_bias
;
break
;
\
n
'
+
'
}
\
n
'
+
'
o_color
=
{
CAST_TO_OUTPUT
}
;
\
n
'
+
'
}
\
n
'
)
]
;
var
FboConfig
=
function
(
name
surfaceType
numSamples
)
{
this
.
name
=
name
;
this
.
surfaceType
=
surfaceType
;
this
.
numSamples
=
numSamples
;
}
;
var
s_fboConfigs
=
[
new
FboConfig
(
'
fbo
'
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
0
)
new
FboConfig
(
'
fbo_msaa2
'
es3fShaderDerivateTests
.
SurfaceType
.
UNORM_FBO
2
)
new
FboConfig
(
'
fbo_msaa4
'
es3fShaderDerivateTests
.
SurfaceType
.
UNORM_FBO
4
)
new
FboConfig
(
'
fbo_float
'
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
0
)
]
;
var
Hint
=
function
(
name
hint
)
{
this
.
name
=
name
;
this
.
hint
=
hint
;
}
;
var
s_hints
=
[
new
Hint
(
'
fastest
'
gl
.
FASTEST
)
new
Hint
(
'
nicest
'
gl
.
NICEST
)
]
;
var
HintFboConfig
=
function
(
name
surfaceType
numSamples
)
{
this
.
name
=
name
;
this
.
surfaceType
=
surfaceType
;
this
.
numSamples
=
numSamples
;
}
;
var
s_hintFboConfigs
=
[
new
HintFboConfig
(
'
default
'
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
0
)
new
HintFboConfig
(
'
fbo_msaa4
'
es3fShaderDerivateTests
.
SurfaceType
.
UNORM_FBO
4
)
new
HintFboConfig
(
'
fbo_float
'
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
0
)
]
;
var
TextureConfig
=
function
(
name
surfaceType
numSamples
hint
)
{
this
.
name
=
name
;
this
.
surfaceType
=
surfaceType
;
this
.
numSamples
=
numSamples
;
this
.
hint
=
hint
;
}
;
var
s_textureConfigs
=
[
new
TextureConfig
(
'
basic
'
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
0
gl
.
DONT_CARE
)
new
TextureConfig
(
'
msaa4
'
es3fShaderDerivateTests
.
SurfaceType
.
UNORM_FBO
4
gl
.
DONT_CARE
)
new
TextureConfig
(
'
float_fastest
'
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
0
gl
.
FASTEST
)
new
TextureConfig
(
'
float_nicest
'
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
0
gl
.
NICEST
)
]
;
var
dataType
;
var
source
;
var
precision
;
var
surfaceType
;
var
numSamples
;
var
hint
;
var
caseName
;
var
fboGroup
;
for
(
var
funcNdx
in
es3fShaderDerivateTests
.
DerivateFunc
)
{
var
function_
=
es3fShaderDerivateTests
.
DerivateFunc
[
funcNdx
]
;
var
functionGroup
=
tcuTestCase
.
newTest
(
es3fShaderDerivateTests
.
getDerivateFuncCaseName
(
function_
)
es3fShaderDerivateTests
.
getDerivateFuncName
(
function_
)
)
;
testGroup
.
addChild
(
functionGroup
)
;
var
constantGroup
=
tcuTestCase
.
newTest
(
'
constant
'
'
Derivate
of
constant
argument
'
)
;
functionGroup
.
addChild
(
constantGroup
)
;
for
(
var
vecSize
=
1
;
vecSize
<
=
4
;
vecSize
+
+
)
{
dataType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
:
gluShaderUtil
.
DataType
.
FLOAT
;
constantGroup
.
addChild
(
new
es3fShaderDerivateTests
.
ConstantDerivateCase
(
gluShaderUtil
.
getDataTypeName
(
dataType
)
'
'
function_
dataType
)
)
;
}
for
(
var
caseNdx
=
0
;
caseNdx
<
s_linearDerivateCases
.
length
;
caseNdx
+
+
)
{
var
linearCaseGroup
=
tcuTestCase
.
newTest
(
s_linearDerivateCases
[
caseNdx
]
.
name
s_linearDerivateCases
[
caseNdx
]
.
description
)
;
source
=
s_linearDerivateCases
[
caseNdx
]
.
source
;
functionGroup
.
addChild
(
linearCaseGroup
)
;
for
(
var
vecSize
=
1
;
vecSize
<
=
4
;
vecSize
+
+
)
for
(
var
precNdx
in
gluShaderUtil
.
precision
)
{
dataType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
:
gluShaderUtil
.
DataType
.
FLOAT
;
precision
=
gluShaderUtil
.
precision
[
precNdx
]
;
surfaceType
=
es3fShaderDerivateTests
.
SurfaceType
.
DEFAULT_FRAMEBUFFER
;
numSamples
=
0
;
hint
=
gl
.
DONT_CARE
;
if
(
caseNdx
!
=
=
0
&
&
precision
=
=
=
gluShaderUtil
.
precision
.
PRECISION_LOWP
)
continue
;
caseName
=
gluShaderUtil
.
getDataTypeName
(
dataType
)
+
'
_
'
+
gluShaderUtil
.
getPrecisionName
(
precision
)
;
linearCaseGroup
.
addChild
(
new
es3fShaderDerivateTests
.
LinearDerivateCase
(
caseName
'
'
function_
dataType
precision
hint
surfaceType
numSamples
source
)
)
;
}
}
for
(
var
caseNdx
=
0
;
caseNdx
<
s_fboConfigs
.
length
;
caseNdx
+
+
)
{
fboGroup
=
tcuTestCase
.
newTest
(
s_fboConfigs
[
caseNdx
]
.
name
'
Derivate
usage
when
rendering
into
FBO
'
)
;
source
=
s_linearDerivateCases
[
0
]
.
source
;
surfaceType
=
s_fboConfigs
[
caseNdx
]
.
surfaceType
;
numSamples
=
s_fboConfigs
[
caseNdx
]
.
numSamples
;
functionGroup
.
addChild
(
fboGroup
)
;
for
(
var
vecSize
=
1
;
vecSize
<
=
4
;
vecSize
+
+
)
for
(
var
precNdx
in
gluShaderUtil
.
precision
)
{
dataType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
:
gluShaderUtil
.
DataType
.
FLOAT
;
precision
=
gluShaderUtil
.
precision
[
precNdx
]
;
hint
=
gl
.
DONT_CARE
;
if
(
surfaceType
!
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
&
&
precision
=
=
=
gluShaderUtil
.
precision
.
PRECISION_LOWP
)
continue
;
caseName
=
gluShaderUtil
.
getDataTypeName
(
dataType
)
+
'
_
'
+
gluShaderUtil
.
getPrecisionName
(
precision
)
;
fboGroup
.
addChild
(
new
es3fShaderDerivateTests
.
LinearDerivateCase
(
caseName
'
'
function_
dataType
precision
hint
surfaceType
numSamples
source
)
)
;
}
}
for
(
var
hintCaseNdx
=
0
;
hintCaseNdx
<
s_hints
.
length
;
hintCaseNdx
+
+
)
{
var
hintGroup
=
tcuTestCase
.
newTest
(
s_hints
[
hintCaseNdx
]
.
name
'
Shader
derivate
hints
'
)
;
source
=
s_linearDerivateCases
[
0
]
.
source
;
hint
=
s_hints
[
hintCaseNdx
]
.
hint
;
functionGroup
.
addChild
(
hintGroup
)
;
for
(
var
fboCaseNdx
=
0
;
fboCaseNdx
<
s_hintFboConfigs
.
length
;
fboCaseNdx
+
+
)
{
fboGroup
=
tcuTestCase
.
newTest
(
s_hintFboConfigs
[
fboCaseNdx
]
.
name
'
'
)
;
surfaceType
=
s_hintFboConfigs
[
fboCaseNdx
]
.
surfaceType
;
numSamples
=
s_hintFboConfigs
[
fboCaseNdx
]
.
numSamples
;
hintGroup
.
addChild
(
fboGroup
)
;
for
(
var
vecSize
=
1
;
vecSize
<
=
4
;
vecSize
+
+
)
for
(
var
precNdx
in
gluShaderUtil
.
precision
)
{
dataType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
:
gluShaderUtil
.
DataType
.
FLOAT
;
precision
=
gluShaderUtil
.
precision
[
precNdx
]
;
if
(
surfaceType
!
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
&
&
precision
=
=
=
gluShaderUtil
.
precision
.
PRECISION_LOWP
)
continue
;
caseName
=
gluShaderUtil
.
getDataTypeName
(
dataType
)
+
'
_
'
+
gluShaderUtil
.
getPrecisionName
(
precision
)
;
fboGroup
.
addChild
(
new
es3fShaderDerivateTests
.
LinearDerivateCase
(
caseName
'
'
function_
dataType
precision
hint
surfaceType
numSamples
source
)
)
;
}
}
}
var
textureGroup
=
tcuTestCase
.
newTest
(
'
texture
'
'
Derivate
of
texture
lookup
result
'
)
;
functionGroup
.
addChild
(
textureGroup
)
;
for
(
var
texCaseNdx
=
0
;
texCaseNdx
<
s_textureConfigs
.
length
;
texCaseNdx
+
+
)
{
var
caseGroup
=
tcuTestCase
.
newTest
(
s_textureConfigs
[
texCaseNdx
]
.
name
'
'
)
;
surfaceType
=
s_textureConfigs
[
texCaseNdx
]
.
surfaceType
;
numSamples
=
s_textureConfigs
[
texCaseNdx
]
.
numSamples
;
hint
=
s_textureConfigs
[
texCaseNdx
]
.
hint
;
textureGroup
.
addChild
(
caseGroup
)
;
for
(
var
vecSize
=
1
;
vecSize
<
=
4
;
vecSize
+
+
)
for
(
var
precNdx
in
gluShaderUtil
.
precision
)
{
dataType
=
vecSize
>
1
?
gluShaderUtil
.
getDataTypeFloatVec
(
vecSize
)
:
gluShaderUtil
.
DataType
.
FLOAT
;
precision
=
gluShaderUtil
.
precision
[
precNdx
]
;
if
(
surfaceType
!
=
=
es3fShaderDerivateTests
.
SurfaceType
.
FLOAT_FBO
&
&
precision
=
=
=
gluShaderUtil
.
precision
.
PRECISION_LOWP
)
continue
;
caseName
=
gluShaderUtil
.
getDataTypeName
(
dataType
)
+
'
_
'
+
gluShaderUtil
.
getPrecisionName
(
precision
)
;
caseGroup
.
addChild
(
new
es3fShaderDerivateTests
.
TextureDerivateCase
(
caseName
'
'
function_
dataType
precision
hint
surfaceType
numSamples
)
)
;
}
}
}
}
;
es3fShaderDerivateTests
.
run
=
function
(
context
)
{
gl
=
context
;
var
state
=
tcuTestCase
.
runner
;
state
.
setRoot
(
new
es3fShaderDerivateTests
.
ShaderDerivateTests
(
)
)
;
setCurrentTestName
(
state
.
testCases
.
fullName
(
)
)
;
description
(
state
.
testCases
.
getDescription
(
)
)
;
try
{
tcuTestCase
.
runTestCases
(
)
;
}
catch
(
err
)
{
testFailedOptions
(
'
Failed
to
es3fShaderDerivateTests
.
run
tests
'
false
)
;
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
