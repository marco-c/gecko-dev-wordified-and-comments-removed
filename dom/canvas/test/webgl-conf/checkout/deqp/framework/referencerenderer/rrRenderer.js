'
use
strict
'
;
goog
.
provide
(
'
framework
.
referencerenderer
.
rrRenderer
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deString
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
simplereference
.
sglrShaderProgram
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrDefs
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrFragmentOperations
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrGenericVector
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrMultisamplePixelBufferAccess
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrRenderState
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrShadingContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexAttrib
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexPacket
'
)
;
goog
.
scope
(
function
(
)
{
var
rrRenderer
=
framework
.
referencerenderer
.
rrRenderer
;
var
rrVertexPacket
=
framework
.
referencerenderer
.
rrVertexPacket
;
var
rrDefs
=
framework
.
referencerenderer
.
rrDefs
;
var
rrFragmentOperations
=
framework
.
referencerenderer
.
rrFragmentOperations
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
rrRenderState
=
framework
.
referencerenderer
.
rrRenderState
;
var
rrMultisamplePixelBufferAccess
=
framework
.
referencerenderer
.
rrMultisamplePixelBufferAccess
;
var
rrShadingContext
=
framework
.
referencerenderer
.
rrShadingContext
;
var
rrGenericVector
=
framework
.
referencerenderer
.
rrGenericVector
;
var
sglrShaderProgram
=
framework
.
opengl
.
simplereference
.
sglrShaderProgram
;
var
rrVertexAttrib
=
framework
.
referencerenderer
.
rrVertexAttrib
;
var
deString
=
framework
.
delibs
.
debase
.
deString
;
var
deUtil
=
framework
.
delibs
.
debase
.
deUtil
;
rrRenderer
.
PrimitiveType
=
{
TRIANGLES
:
0
TRIANGLE_STRIP
:
1
TRIANGLE_FAN
:
2
LINES
:
3
LINE_STRIP
:
4
LINE_LOOP
:
5
POINTS
:
6
}
;
rrRenderer
.
DrawContext
=
function
(
id
)
{
this
.
primitiveID
=
id
|
|
0
;
}
;
rrRenderer
.
transformGLToWindowCoords
=
function
(
state
packet
)
{
var
transformed
=
[
packet
.
position
[
0
]
/
packet
.
position
[
3
]
packet
.
position
[
1
]
/
packet
.
position
[
3
]
packet
.
position
[
2
]
packet
.
position
[
3
]
]
;
var
viewport
=
state
.
viewport
.
rect
;
var
halfW
=
viewport
.
width
/
2
;
var
halfH
=
viewport
.
height
/
2
;
var
oX
=
viewport
.
left
+
halfW
;
var
oY
=
viewport
.
bottom
+
halfH
;
return
[
transformed
[
0
]
*
halfW
+
oX
transformed
[
1
]
*
halfH
+
oY
transformed
[
2
]
transformed
[
3
]
]
;
}
;
rrRenderer
.
RenderTarget
=
function
(
colorMultisampleBuffer
depthMultisampleBuffer
stencilMultisampleBuffer
)
{
this
.
MAX_COLOR_BUFFERS
=
4
;
this
.
colorBuffers
=
[
]
;
this
.
colorBuffers
[
0
]
=
colorMultisampleBuffer
;
this
.
depthBuffer
=
depthMultisampleBuffer
|
|
new
rrMultisamplePixelBufferAccess
.
MultisamplePixelBufferAccess
(
)
;
this
.
stencilBuffer
=
stencilMultisampleBuffer
|
|
new
rrMultisamplePixelBufferAccess
.
MultisamplePixelBufferAccess
(
)
;
this
.
numColorBuffers
=
1
;
}
;
rrRenderer
.
DrawIndices
=
function
(
data
type
offset
baseVertex_
)
{
this
.
data
=
data
;
this
.
baseVertex
=
baseVertex_
|
|
0
;
this
.
indexType
=
type
;
this
.
access
=
null
;
switch
(
type
)
{
case
rrDefs
.
IndexType
.
INDEXTYPE_UINT8
:
this
.
access
=
new
Uint8Array
(
data
)
.
subarray
(
offset
)
;
break
;
case
rrDefs
.
IndexType
.
INDEXTYPE_UINT16
:
this
.
access
=
new
Uint16Array
(
data
)
.
subarray
(
offset
/
2
)
;
break
;
case
rrDefs
.
IndexType
.
INDEXTYPE_UINT32
:
this
.
access
=
new
Uint32Array
(
data
)
.
subarray
(
offset
/
4
)
;
break
;
default
:
throw
new
Error
(
'
Invalid
type
:
'
+
type
)
;
}
}
;
rrRenderer
.
DrawIndices
.
prototype
.
readIndexArray
=
function
(
index
)
{
return
this
.
access
[
index
]
;
}
;
rrRenderer
.
PrimitiveList
=
function
(
primitiveType
numElements
indices
)
{
this
.
m_primitiveType
=
primitiveType
;
this
.
m_numElements
=
numElements
;
if
(
typeof
indices
=
=
'
number
'
)
{
this
.
m_indices
=
null
;
this
.
m_indexType
=
null
;
this
.
m_baseVertex
=
indices
;
}
else
{
this
.
m_indices
=
indices
;
this
.
m_indexType
=
indices
.
indexType
;
this
.
m_baseVertex
=
indices
.
baseVertex
;
}
this
.
m_iterator
=
0
;
}
;
rrRenderer
.
PrimitiveList
.
prototype
.
getIndex
=
function
(
elementNdx
)
{
if
(
this
.
m_indices
)
{
var
index
=
this
.
m_baseVertex
+
this
.
m_indices
.
readIndexArray
(
elementNdx
)
;
if
(
index
<
0
)
throw
new
Error
(
'
Index
must
not
be
negative
'
)
;
return
index
;
}
else
return
this
.
m_baseVertex
+
elementNdx
;
}
;
rrRenderer
.
PrimitiveList
.
prototype
.
isRestartIndex
=
function
(
elementNdx
restartIndex
)
{
if
(
this
.
m_indices
)
return
this
.
m_indices
.
readIndexArray
(
elementNdx
)
=
=
restartIndex
;
else
return
elementNdx
=
=
restartIndex
;
}
;
rrRenderer
.
PrimitiveList
.
prototype
.
getNumElements
=
function
(
)
{
return
this
.
m_numElements
;
}
;
rrRenderer
.
PrimitiveList
.
prototype
.
getPrimitiveType
=
function
(
)
{
return
this
.
m_primitiveType
;
}
;
rrRenderer
.
PrimitiveList
.
prototype
.
getIndexType
=
function
(
)
{
return
this
.
m_indexType
;
}
;
rrRenderer
.
PrimitiveList
.
prototype
.
getNextPrimitive
=
function
(
reset
)
{
if
(
reset
)
this
.
m_iterator
=
0
;
var
result
=
[
]
;
var
i
=
this
.
m_iterator
;
switch
(
this
.
m_primitiveType
)
{
case
rrRenderer
.
PrimitiveType
.
TRIANGLES
:
if
(
this
.
m_iterator
+
3
<
=
this
.
m_numElements
)
{
result
=
[
i
i
+
1
i
+
2
]
;
this
.
m_iterator
+
=
3
;
}
break
;
case
rrRenderer
.
PrimitiveType
.
TRIANGLE_STRIP
:
if
(
this
.
m_iterator
+
3
<
=
this
.
m_numElements
)
{
result
=
[
i
i
+
1
i
+
2
]
;
this
.
m_iterator
+
=
1
;
}
break
;
case
rrRenderer
.
PrimitiveType
.
TRIANGLE_FAN
:
if
(
this
.
m_iterator
+
3
<
=
this
.
m_numElements
)
{
result
=
[
0
i
+
1
i
+
2
]
;
this
.
m_iterator
+
=
1
;
}
break
;
case
rrRenderer
.
PrimitiveType
.
LINES
:
if
(
this
.
m_iterator
+
2
<
=
this
.
m_numElements
)
{
result
=
[
i
i
+
1
]
;
this
.
m_iterator
+
=
2
;
}
break
;
case
rrRenderer
.
PrimitiveType
.
LINE_STRIP
:
if
(
this
.
m_iterator
+
2
<
=
this
.
m_numElements
)
{
result
=
[
i
i
+
1
]
;
this
.
m_iterator
+
=
1
;
}
break
;
case
rrRenderer
.
PrimitiveType
.
LINE_LOOP
:
if
(
this
.
m_iterator
=
=
this
.
m_numElements
)
break
;
if
(
this
.
m_iterator
+
2
<
=
this
.
m_numElements
)
result
=
[
i
i
+
1
]
;
else
result
=
[
i
0
]
;
this
.
m_iterator
+
=
1
;
break
;
case
rrRenderer
.
PrimitiveType
.
POINTS
:
if
(
this
.
m_iterator
=
=
this
.
m_numElements
)
break
;
else
result
=
[
i
]
;
this
.
m_iterator
+
=
1
;
break
;
default
:
throw
new
Error
(
'
Unsupported
primitive
type
:
'
+
deString
.
enumToString
(
rrRenderer
.
PrimitiveType
this
.
m_primitiveType
)
)
;
}
return
result
;
}
;
rrRenderer
.
getBarycentricCoefficients
=
function
(
v
v1
v2
v3
)
{
var
b
=
[
]
;
var
x
=
v
[
0
]
;
var
y
=
v
[
1
]
;
var
x1
=
v1
[
0
]
;
var
x2
=
v2
[
0
]
;
var
x3
=
v3
[
0
]
;
var
y1
=
v1
[
1
]
;
var
y2
=
v2
[
1
]
;
var
y3
=
v3
[
1
]
;
var
det
=
(
y2
-
y3
)
*
(
x1
-
x3
)
+
(
x3
-
x2
)
*
(
y1
-
y3
)
;
b
[
0
]
=
(
(
y2
-
y3
)
*
(
x
-
x3
)
+
(
x3
-
x2
)
*
(
y
-
y3
)
)
/
det
;
b
[
1
]
=
(
(
y3
-
y1
)
*
(
x
-
x3
)
+
(
x1
-
x3
)
*
(
y
-
y3
)
)
/
det
;
b
[
2
]
=
1
-
b
[
0
]
-
b
[
1
]
;
return
b
;
}
;
rrRenderer
.
writeFragments
=
function
(
state
renderTarget
fragments
)
{
var
colorbuffer
=
renderTarget
.
colorBuffers
[
0
]
.
raw
(
)
;
for
(
var
i
=
0
;
i
<
fragments
.
length
;
i
+
+
)
{
var
fragment
=
fragments
[
i
]
;
colorbuffer
.
setPixel
(
fragment
.
value
0
fragment
.
pixelCoord
[
0
]
fragment
.
pixelCoord
[
1
]
)
;
}
}
;
rrRenderer
.
writeFragments2
=
function
(
renderState
renderTarget
fragments
)
{
var
fragmentFacing
=
rrDefs
.
FaceType
.
FACETYPE_FRONT
;
var
colorBuffer
=
renderTarget
.
colorBuffers
[
0
]
.
raw
(
)
;
var
depthBuffer
=
renderTarget
.
depthBuffer
.
raw
(
)
;
var
stencilBuffer
=
renderTarget
.
stencilBuffer
.
raw
(
)
;
var
state
=
renderState
.
fragOps
;
var
hasDepth
=
depthBuffer
.
getWidth
(
)
>
0
&
&
depthBuffer
.
getHeight
(
)
>
0
&
&
depthBuffer
.
getDepth
(
)
>
0
;
var
hasStencil
=
stencilBuffer
.
getWidth
(
)
>
0
&
&
stencilBuffer
.
getHeight
(
)
>
0
&
&
stencilBuffer
.
getDepth
(
)
>
0
;
var
doDepthTest
=
hasDepth
&
&
state
.
depthTestEnabled
;
var
doStencilTest
=
hasStencil
&
&
state
.
stencilTestEnabled
;
var
colorbufferClass
=
tcuTexture
.
getTextureChannelClass
(
colorBuffer
.
getFormat
(
)
.
type
)
;
var
fragmentDataType
=
rrGenericVector
.
GenericVecType
.
FLOAT
;
switch
(
colorbufferClass
)
{
case
tcuTexture
.
TextureChannelClass
.
SIGNED_INTEGER
:
fragmentDataType
=
rrGenericVector
.
GenericVecType
.
INT32
;
break
;
case
tcuTexture
.
TextureChannelClass
.
UNSIGNED_INTEGER
:
fragmentDataType
=
rrGenericVector
.
GenericVecType
.
UINT32
;
break
;
}
if
(
!
(
(
!
hasDepth
|
|
colorBuffer
.
getWidth
(
)
=
=
depthBuffer
.
getWidth
(
)
)
&
&
(
!
hasStencil
|
|
colorBuffer
.
getWidth
(
)
=
=
stencilBuffer
.
getWidth
(
)
)
)
)
throw
new
Error
(
'
Attachment
must
have
the
same
width
'
)
;
if
(
!
(
(
!
hasDepth
|
|
colorBuffer
.
getHeight
(
)
=
=
depthBuffer
.
getHeight
(
)
)
&
&
(
!
hasStencil
|
|
colorBuffer
.
getHeight
(
)
=
=
stencilBuffer
.
getHeight
(
)
)
)
)
throw
new
Error
(
'
Attachment
must
have
the
same
height
'
)
;
if
(
!
(
(
!
hasDepth
|
|
colorBuffer
.
getDepth
(
)
=
=
depthBuffer
.
getDepth
(
)
)
&
&
(
!
hasStencil
|
|
colorBuffer
.
getDepth
(
)
=
=
stencilBuffer
.
getDepth
(
)
)
)
)
throw
new
Error
(
'
Attachment
must
have
the
same
depth
'
)
;
var
stencilState
=
state
.
stencilStates
[
fragmentFacing
]
;
var
colorMaskFactor
=
[
state
.
colorMask
[
0
]
?
1
:
0
state
.
colorMask
[
1
]
?
1
:
0
state
.
colorMask
[
2
]
?
1
:
0
state
.
colorMask
[
3
]
?
1
:
0
]
;
var
colorMaskNegationFactor
=
[
state
.
colorMask
[
0
]
?
false
:
true
state
.
colorMask
[
1
]
?
false
:
true
state
.
colorMask
[
2
]
?
false
:
true
state
.
colorMask
[
3
]
?
false
:
true
]
;
var
sRGBTarget
=
false
;
if
(
state
.
scissorTestEnabled
)
rrFragmentOperations
.
executeScissorTest
(
fragments
state
.
scissorRectangle
)
;
if
(
doStencilTest
)
{
rrFragmentOperations
.
executeStencilCompare
(
fragments
stencilState
state
.
numStencilBits
stencilBuffer
)
;
rrFragmentOperations
.
executeStencilSFail
(
fragments
stencilState
state
.
numStencilBits
stencilBuffer
)
;
}
if
(
doDepthTest
)
{
rrFragmentOperations
.
executeDepthCompare
(
fragments
state
.
depthFunc
depthBuffer
)
;
if
(
state
.
depthMask
)
rrFragmentOperations
.
executeDepthWrite
(
fragments
depthBuffer
)
;
}
if
(
doStencilTest
)
rrFragmentOperations
.
executeStencilDpFailAndPass
(
fragments
stencilState
state
.
numStencilBits
stencilBuffer
)
;
if
(
doDepthTest
)
{
for
(
var
i
=
0
;
i
<
fragments
.
length
;
i
+
+
)
fragments
[
i
]
.
isAlive
=
fragments
[
i
]
.
isAlive
&
&
fragments
[
i
]
.
depthPassed
;
}
switch
(
fragmentDataType
)
{
case
rrGenericVector
.
GenericVecType
.
FLOAT
:
if
(
state
.
blendMode
=
=
rrRenderState
.
BlendMode
.
STANDARD
)
{
for
(
var
i
=
0
;
i
<
fragments
.
length
;
i
+
+
)
{
var
frag
=
fragments
[
i
]
;
if
(
frag
.
isAlive
)
{
var
dstColor
=
colorBuffer
.
getPixel
(
0
frag
.
pixelCoord
[
0
]
frag
.
pixelCoord
[
1
]
)
;
frag
.
clampedBlendSrcColor
=
deMath
.
clampVector
(
frag
.
value
0
1
)
;
frag
.
clampedBlendSrc1Color
=
deMath
.
clampVector
(
frag
.
value1
0
1
)
;
frag
.
clampedBlendDstColor
=
deMath
.
clampVector
(
sRGBTarget
?
tcuTexture
.
sRGBToLinear
(
dstColor
)
:
dstColor
0
1
)
;
}
}
rrFragmentOperations
.
executeBlendFactorComputeRGB
(
fragments
state
.
blendColor
state
.
blendRGBState
)
;
rrFragmentOperations
.
executeBlendFactorComputeA
(
fragments
state
.
blendColor
state
.
blendAState
)
;
rrFragmentOperations
.
executeBlend
(
fragments
state
.
blendRGBState
state
.
blendAState
)
;
}
else
{
for
(
var
i
=
0
;
i
<
fragments
.
length
;
i
+
+
)
{
var
frag
=
fragments
[
i
]
;
if
(
frag
.
isAlive
)
{
frag
.
blendedRGB
=
deMath
.
swizzle
(
frag
.
value
[
0
1
2
]
)
;
frag
.
blendedA
=
frag
.
value
[
3
]
;
}
}
}
if
(
state
.
colorMask
[
0
]
&
&
state
.
colorMask
[
1
]
&
&
state
.
colorMask
[
2
]
&
&
state
.
colorMask
[
3
]
)
{
rrFragmentOperations
.
executeColorWrite
(
fragments
sRGBTarget
colorBuffer
)
;
}
else
if
(
state
.
colorMask
[
0
]
|
|
state
.
colorMask
[
1
]
|
|
state
.
colorMask
[
2
]
|
|
state
.
colorMask
[
3
]
)
rrFragmentOperations
.
executeMaskedColorWrite
(
fragments
colorMaskFactor
colorMaskNegationFactor
sRGBTarget
colorBuffer
)
;
break
;
case
rrGenericVector
.
GenericVecType
.
INT32
:
for
(
var
i
=
0
;
i
<
fragments
.
length
;
i
+
+
)
{
var
frag
=
fragments
[
i
]
;
if
(
frag
.
isAlive
)
{
frag
.
signedValue
=
frag
.
value
;
}
}
if
(
state
.
colorMask
[
0
]
|
|
state
.
colorMask
[
1
]
|
|
state
.
colorMask
[
2
]
|
|
state
.
colorMask
[
3
]
)
rrFragmentOperations
.
executeSignedValueWrite
(
fragments
state
.
colorMask
colorBuffer
)
;
break
;
case
rrGenericVector
.
GenericVecType
.
UINT32
:
for
(
var
i
=
0
;
i
<
fragments
.
length
;
i
+
+
)
{
var
frag
=
fragments
[
i
]
;
if
(
frag
.
isAlive
)
{
frag
.
unsignedValue
=
frag
.
value
;
}
}
if
(
state
.
colorMask
[
0
]
|
|
state
.
colorMask
[
1
]
|
|
state
.
colorMask
[
2
]
|
|
state
.
colorMask
[
3
]
)
rrFragmentOperations
.
executeUnsignedValueWrite
(
fragments
state
.
colorMask
colorBuffer
)
;
break
;
default
:
throw
new
Error
(
'
Unrecognized
fragment
data
type
:
'
+
fragmentDataType
)
;
}
}
;
rrRenderer
.
getIndexOfCorner
=
function
(
isTop
isRight
vertexPackets
)
{
var
x
=
null
;
var
y
=
null
;
var
xcriteria
=
isRight
?
Math
.
max
:
Math
.
min
;
var
ycriteria
=
isTop
?
Math
.
max
:
Math
.
min
;
for
(
var
i
=
0
;
i
<
vertexPackets
.
length
;
i
+
+
)
{
x
=
x
!
=
null
?
xcriteria
(
vertexPackets
[
i
]
.
position
[
0
]
x
)
:
vertexPackets
[
i
]
.
position
[
0
]
;
y
=
y
!
=
null
?
ycriteria
(
vertexPackets
[
i
]
.
position
[
1
]
y
)
:
vertexPackets
[
i
]
.
position
[
1
]
;
}
for
(
var
v
=
0
;
v
<
vertexPackets
.
length
;
v
+
+
)
if
(
vertexPackets
[
v
]
.
position
[
0
]
=
=
x
&
&
vertexPackets
[
v
]
.
position
[
1
]
=
=
y
)
return
v
;
throw
new
Error
(
'
Corner
not
found
'
)
;
}
;
rrRenderer
.
clipTest
=
function
(
x
y
z
rect
)
{
x
=
Math
.
round
(
x
)
;
y
=
Math
.
round
(
y
)
;
if
(
!
deMath
.
deInBounds32
(
x
rect
.
left
rect
.
left
+
rect
.
width
)
)
return
false
;
if
(
!
deMath
.
deInBounds32
(
y
rect
.
bottom
rect
.
bottom
+
rect
.
height
)
)
return
false
;
if
(
z
<
0
|
|
z
>
1
)
return
false
;
return
true
;
}
;
rrRenderer
.
drawTriangles
=
function
(
state
renderTarget
program
vertexAttribs
primitive
first
count
instanceID
)
{
var
selectVertices
=
function
(
vertices
indices
)
{
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
indices
.
length
;
i
+
+
)
result
.
push
(
vertices
[
indices
[
i
]
]
)
;
return
result
;
}
;
var
primitives
=
new
rrRenderer
.
PrimitiveList
(
primitive
count
first
)
;
if
(
primitives
.
getNumElements
(
)
=
=
0
)
return
;
var
numVaryings
=
program
.
vertexShader
.
getOutputs
(
)
.
length
;
var
vpalloc
=
new
rrVertexPacket
.
VertexPacketAllocator
(
numVaryings
)
;
var
vertexPackets
=
vpalloc
.
allocArray
(
primitives
.
getNumElements
(
)
)
;
var
drawContext
=
new
rrRenderer
.
DrawContext
(
)
;
drawContext
.
primitiveID
=
0
;
var
numberOfVertices
=
primitives
.
getNumElements
(
)
;
var
numVertexPackets
=
0
;
for
(
var
elementNdx
=
0
;
elementNdx
<
numberOfVertices
;
+
+
elementNdx
)
{
vertexPackets
[
numVertexPackets
]
.
instanceNdx
=
instanceID
;
vertexPackets
[
numVertexPackets
]
.
vertexNdx
=
primitives
.
getIndex
(
elementNdx
)
;
vertexPackets
[
numVertexPackets
]
.
pointSize
=
state
.
point
.
pointSize
;
vertexPackets
[
numVertexPackets
]
.
position
=
[
0
0
0
0
]
;
+
+
numVertexPackets
;
}
program
.
shadeVertices
(
vertexAttribs
vertexPackets
numVertexPackets
)
;
var
zn
=
state
.
viewport
.
zn
;
var
zf
=
state
.
viewport
.
zf
;
var
depthScale
=
(
zf
-
zn
)
/
2
;
var
depthBias
=
(
zf
+
zn
)
/
2
;
for
(
var
prim
=
primitives
.
getNextPrimitive
(
true
)
;
prim
.
length
>
0
;
prim
=
primitives
.
getNextPrimitive
(
)
)
{
var
vertices
=
selectVertices
(
vertexPackets
prim
)
;
var
v0
=
rrRenderer
.
transformGLToWindowCoords
(
state
vertices
[
0
]
)
;
var
v1
=
rrRenderer
.
transformGLToWindowCoords
(
state
vertices
[
1
]
)
;
var
v2
=
rrRenderer
.
transformGLToWindowCoords
(
state
vertices
[
2
]
)
;
var
minX
=
Math
.
floor
(
Math
.
min
(
v0
[
0
]
v1
[
0
]
v2
[
0
]
)
)
;
var
maxX
=
Math
.
ceil
(
Math
.
max
(
v0
[
0
]
v1
[
0
]
v2
[
0
]
)
)
;
var
minY
=
Math
.
floor
(
Math
.
min
(
v0
[
1
]
v1
[
1
]
v2
[
1
]
)
)
;
var
maxY
=
Math
.
ceil
(
Math
.
max
(
v0
[
1
]
v1
[
1
]
v2
[
1
]
)
)
;
var
fragmentPackets
=
[
]
;
for
(
var
i
=
minX
;
i
<
=
maxX
;
i
+
+
)
{
for
(
var
j
=
minY
;
j
<
=
maxY
;
j
+
+
)
{
var
x
=
i
+
0
.
5
;
var
y
=
j
+
0
.
5
;
var
b
=
rrRenderer
.
getBarycentricCoefficients
(
[
x
y
]
v0
v1
v2
)
;
if
(
b
[
0
]
<
0
|
|
b
[
1
]
<
0
|
|
b
[
2
]
<
0
)
{
continue
;
}
var
depth
=
v0
[
2
]
*
b
[
0
]
+
v1
[
2
]
*
b
[
1
]
+
v2
[
2
]
*
b
[
2
]
;
depth
=
depth
*
depthScale
+
depthBias
;
if
(
!
rrRenderer
.
clipTest
(
i
j
depth
state
.
viewport
.
rect
)
)
continue
;
fragmentPackets
.
push
(
new
rrFragmentOperations
.
Fragment
(
b
[
i
j
]
depth
)
)
;
}
}
var
shadingContext
=
new
rrShadingContext
.
FragmentShadingContext
(
vertices
[
0
]
.
outputs
vertices
[
1
]
.
outputs
vertices
[
2
]
.
outputs
)
;
shadingContext
.
setSize
(
maxX
-
minX
maxY
-
minY
)
;
program
.
shadeFragments
(
fragmentPackets
shadingContext
)
;
rrRenderer
.
writeFragments2
(
state
renderTarget
fragmentPackets
)
;
}
}
;
rrRenderer
.
drawLines
=
function
(
state
renderTarget
program
vertexAttribs
primitive
first
count
instanceID
)
{
var
selectVertices
=
function
(
vertices
indices
)
{
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
indices
.
length
;
i
+
+
)
result
.
push
(
vertices
[
indices
[
i
]
]
)
;
return
result
;
}
;
var
lengthSquared
=
function
(
a
)
{
var
sqSum
=
0
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
sqSum
+
=
a
[
i
]
*
a
[
i
]
;
return
sqSum
;
}
;
var
dot
=
function
(
a
b
)
{
var
res
=
0
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
res
+
=
a
[
i
]
*
b
[
i
]
;
return
res
;
}
;
var
rasterizeLine
=
function
(
v0
v1
)
{
var
d
=
[
Math
.
abs
(
v1
[
0
]
-
v0
[
0
]
)
Math
.
abs
(
v1
[
1
]
-
v0
[
1
]
)
]
;
var
xstep
=
v0
[
0
]
<
v1
[
0
]
?
1
:
-
1
;
var
ystep
=
v0
[
1
]
<
v1
[
1
]
?
1
:
-
1
;
var
x
=
v0
[
0
]
;
var
y
=
v0
[
1
]
;
var
offset
=
d
[
0
]
-
d
[
1
]
;
var
lenV
=
[
v1
[
0
]
-
v0
[
0
]
v1
[
1
]
-
v0
[
1
]
]
;
var
lenSq
=
lengthSquared
(
lenV
)
;
var
packets
=
[
]
;
while
(
true
)
{
var
t
=
dot
(
[
x
-
v0
[
0
]
y
-
v0
[
1
]
]
lenV
)
/
lenSq
;
var
depth
=
(
1
-
t
)
*
v0
[
2
]
+
t
*
v1
[
2
]
;
var
b
=
[
0
0
0
]
;
b
[
0
]
=
1
-
t
;
b
[
1
]
=
t
;
if
(
x
=
=
v1
[
0
]
&
&
y
=
=
v1
[
1
]
)
break
;
depth
=
depth
*
depthScale
+
depthBias
;
packets
.
push
(
new
rrFragmentOperations
.
Fragment
(
b
[
x
y
]
depth
)
)
;
var
offset2
=
2
*
offset
;
if
(
offset2
>
-
1
*
d
[
1
]
)
{
x
+
=
xstep
;
offset
-
=
d
[
1
]
;
}
if
(
offset2
<
d
[
0
]
)
{
y
+
=
ystep
;
offset
+
=
d
[
0
]
;
}
}
return
packets
;
}
;
var
primitives
=
new
rrRenderer
.
PrimitiveList
(
primitive
count
first
)
;
if
(
primitives
.
getNumElements
(
)
=
=
0
)
return
;
var
numVaryings
=
program
.
vertexShader
.
getOutputs
(
)
.
length
;
var
vpalloc
=
new
rrVertexPacket
.
VertexPacketAllocator
(
numVaryings
)
;
var
vertexPackets
=
vpalloc
.
allocArray
(
primitives
.
getNumElements
(
)
)
;
var
drawContext
=
new
rrRenderer
.
DrawContext
(
)
;
drawContext
.
primitiveID
=
0
;
var
numberOfVertices
=
primitives
.
getNumElements
(
)
;
var
numVertexPackets
=
0
;
for
(
var
elementNdx
=
0
;
elementNdx
<
numberOfVertices
;
+
+
elementNdx
)
{
vertexPackets
[
numVertexPackets
]
.
instanceNdx
=
instanceID
;
vertexPackets
[
numVertexPackets
]
.
vertexNdx
=
primitives
.
getIndex
(
elementNdx
)
;
vertexPackets
[
numVertexPackets
]
.
pointSize
=
state
.
point
.
pointSize
;
vertexPackets
[
numVertexPackets
]
.
position
=
[
0
0
0
0
]
;
+
+
numVertexPackets
;
}
program
.
shadeVertices
(
vertexAttribs
vertexPackets
numVertexPackets
)
;
var
zn
=
state
.
viewport
.
zn
;
var
zf
=
state
.
viewport
.
zf
;
var
depthScale
=
(
zf
-
zn
)
/
2
;
var
depthBias
=
(
zf
+
zn
)
/
2
;
for
(
var
prim
=
primitives
.
getNextPrimitive
(
true
)
;
prim
.
length
>
0
;
prim
=
primitives
.
getNextPrimitive
(
)
)
{
var
linePackets
=
selectVertices
(
vertexPackets
prim
)
;
var
v0
=
rrRenderer
.
transformGLToWindowCoords
(
state
linePackets
[
0
]
)
;
var
v1
=
rrRenderer
.
transformGLToWindowCoords
(
state
linePackets
[
1
]
)
;
v0
[
2
]
=
linePackets
[
0
]
.
position
[
2
]
;
v1
[
2
]
=
linePackets
[
1
]
.
position
[
2
]
;
v0
[
0
]
=
Math
.
floor
(
v0
[
0
]
)
;
v0
[
1
]
=
Math
.
floor
(
v0
[
1
]
)
;
v1
[
0
]
=
Math
.
floor
(
v1
[
0
]
)
;
v1
[
1
]
=
Math
.
floor
(
v1
[
1
]
)
;
var
lineWidth
=
state
.
line
.
lineWidth
;
var
shadingContext
=
new
rrShadingContext
.
FragmentShadingContext
(
linePackets
[
0
]
.
outputs
linePackets
[
1
]
.
outputs
null
)
;
var
isXmajor
=
Math
.
abs
(
v1
[
0
]
-
v0
[
0
]
)
>
=
Math
.
abs
(
v1
[
1
]
-
v0
[
1
]
)
;
var
packets
=
[
]
;
if
(
isXmajor
)
packets
=
rasterizeLine
(
[
v0
[
0
]
v0
[
1
]
-
(
lineWidth
-
1
)
/
2
v0
[
2
]
]
[
v1
[
0
]
v1
[
1
]
-
(
lineWidth
-
1
)
/
2
v1
[
2
]
]
)
;
else
packets
=
rasterizeLine
(
[
v0
[
0
]
-
(
lineWidth
-
1
)
/
2
v0
[
1
]
v0
[
2
]
]
[
v1
[
0
]
-
(
lineWidth
-
1
)
/
2
v1
[
1
]
v1
[
2
]
]
)
;
var
numPackets
=
packets
.
length
;
if
(
lineWidth
>
1
)
for
(
var
i
=
0
;
i
<
numPackets
;
i
+
+
)
{
var
p
=
packets
[
i
]
;
for
(
var
j
=
1
;
j
<
lineWidth
;
j
+
+
)
{
var
p2
=
deUtil
.
clone
(
p
)
;
if
(
isXmajor
)
p2
.
pixelCoord
[
1
]
+
=
j
;
else
p2
.
pixelCoord
[
0
]
+
=
j
;
packets
.
push
(
p2
)
;
}
}
var
clipped
=
[
]
;
for
(
var
i
=
0
;
i
<
packets
.
length
;
i
+
+
)
{
var
p
=
packets
[
i
]
;
if
(
rrRenderer
.
clipTest
(
p
.
pixelCoord
[
0
]
p
.
pixelCoord
[
1
]
p
.
sampleDepths
[
0
]
state
.
viewport
.
rect
)
)
clipped
.
push
(
p
)
;
}
program
.
shadeFragments
(
clipped
shadingContext
)
;
rrRenderer
.
writeFragments2
(
state
renderTarget
clipped
)
;
}
}
;
rrRenderer
.
drawPoints
=
function
(
state
renderTarget
program
vertexAttribs
primitive
first
count
instanceID
)
{
var
selectVertices
=
function
(
vertices
indices
)
{
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
indices
.
length
;
i
+
+
)
result
.
push
(
vertices
[
indices
[
i
]
]
)
;
return
result
;
}
;
var
primitives
=
new
rrRenderer
.
PrimitiveList
(
primitive
count
first
)
;
if
(
primitives
.
getNumElements
(
)
=
=
0
)
return
;
var
numVaryings
=
program
.
vertexShader
.
getOutputs
(
)
.
length
;
var
vpalloc
=
new
rrVertexPacket
.
VertexPacketAllocator
(
numVaryings
)
;
var
vertexPackets
=
vpalloc
.
allocArray
(
primitives
.
getNumElements
(
)
)
;
var
drawContext
=
new
rrRenderer
.
DrawContext
(
)
;
drawContext
.
primitiveID
=
0
;
var
numberOfVertices
=
primitives
.
getNumElements
(
)
;
var
numVertexPackets
=
0
;
for
(
var
elementNdx
=
0
;
elementNdx
<
numberOfVertices
;
+
+
elementNdx
)
{
vertexPackets
[
numVertexPackets
]
.
instanceNdx
=
instanceID
;
vertexPackets
[
numVertexPackets
]
.
vertexNdx
=
primitives
.
getIndex
(
elementNdx
)
;
vertexPackets
[
numVertexPackets
]
.
pointSize
=
state
.
point
.
pointSize
;
vertexPackets
[
numVertexPackets
]
.
position
=
[
0
0
0
0
]
;
+
+
numVertexPackets
;
}
program
.
shadeVertices
(
vertexAttribs
vertexPackets
numVertexPackets
)
;
var
zn
=
state
.
viewport
.
zn
;
var
zf
=
state
.
viewport
.
zf
;
var
depthScale
=
(
zf
-
zn
)
/
2
;
var
depthBias
=
(
zf
+
zn
)
/
2
;
for
(
var
prim
=
primitives
.
getNextPrimitive
(
true
)
;
prim
.
length
>
0
;
prim
=
primitives
.
getNextPrimitive
(
)
)
{
var
pointPackets
=
selectVertices
(
vertexPackets
prim
)
;
var
v0
=
rrRenderer
.
transformGLToWindowCoords
(
state
pointPackets
[
0
]
)
;
v0
[
2
]
=
pointPackets
[
0
]
.
position
[
2
]
;
var
pointSize
=
pointPackets
[
0
]
.
pointSize
;
var
shadingContext
=
new
rrShadingContext
.
FragmentShadingContext
(
pointPackets
[
0
]
.
outputs
null
null
)
;
var
packets
=
[
]
;
var
x
=
v0
[
0
]
;
var
y
=
v0
[
1
]
;
var
depth
=
v0
[
2
]
;
var
b
=
[
1
0
0
]
;
depth
=
depth
*
depthScale
+
depthBias
;
for
(
var
i
=
Math
.
floor
(
x
-
pointSize
/
2
)
;
i
<
x
+
pointSize
/
2
;
i
+
+
)
{
for
(
var
j
=
Math
.
floor
(
y
-
pointSize
/
2
)
;
j
<
y
+
pointSize
/
2
;
j
+
+
)
{
var
centerX
=
i
+
0
.
5
;
var
centerY
=
j
+
0
.
5
;
if
(
Math
.
abs
(
centerX
-
x
)
<
=
pointSize
/
2
&
&
Math
.
abs
(
centerY
-
y
)
<
=
pointSize
/
2
&
&
rrRenderer
.
clipTest
(
i
j
depth
state
.
viewport
.
rect
)
)
packets
.
push
(
new
rrFragmentOperations
.
Fragment
(
b
[
i
j
]
depth
)
)
;
}
}
program
.
shadeFragments
(
packets
shadingContext
)
;
rrRenderer
.
writeFragments2
(
state
renderTarget
packets
)
;
}
}
;
}
)
;
