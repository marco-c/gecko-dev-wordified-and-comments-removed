'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuFloatFormat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuInterval
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuFloatFormat
=
framework
.
common
.
tcuFloatFormat
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
tcuInterval
=
framework
.
common
.
tcuInterval
;
tcuFloatFormat
.
chooseInterval
=
function
(
choice
no
yes
)
{
switch
(
choice
)
{
case
tcuFloatFormat
.
YesNoMaybe
.
NO
:
return
no
;
case
tcuFloatFormat
.
YesNoMaybe
.
YES
:
return
yes
;
case
tcuFloatFormat
.
YesNoMaybe
.
MAYBE
:
return
no
.
operatorOrBinary
(
yes
)
;
default
:
throw
new
Error
(
'
Impossible
case
'
)
;
}
}
;
tcuFloatFormat
.
computeMaxValue
=
function
(
maxExp
fractionBits
)
{
return
deMath
.
deLdExp
(
1
maxExp
)
+
deMath
.
deLdExp
(
Math
.
pow
(
2
fractionBits
)
-
1
maxExp
-
fractionBits
)
;
}
;
tcuFloatFormat
.
YesNoMaybe
=
{
NO
:
0
MAYBE
:
1
YES
:
2
}
;
tcuFloatFormat
.
FloatFormat
=
function
(
minExp
maxExp
fractionBits
exactPrecision
hasSubnormal
hasInf
hasNaN
)
{
this
.
m_minExp
=
minExp
;
this
.
m_maxExp
=
maxExp
;
this
.
m_fractionBits
=
fractionBits
;
this
.
m_hasSubnormal
=
hasSubnormal
=
=
=
undefined
?
tcuFloatFormat
.
YesNoMaybe
.
MAYBE
:
hasSubnormal
;
this
.
m_hasInf
=
hasInf
=
=
=
undefined
?
tcuFloatFormat
.
YesNoMaybe
.
MAYBE
:
hasInf
;
this
.
m_hasNaN
=
hasNaN
=
=
=
undefined
?
tcuFloatFormat
.
YesNoMaybe
.
MAYBE
:
hasNaN
;
this
.
m_exactPrecision
=
exactPrecision
;
this
.
m_maxValue
=
tcuFloatFormat
.
computeMaxValue
(
maxExp
fractionBits
)
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
getMinExp
=
function
(
)
{
return
this
.
m_minExp
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
getMaxExp
=
function
(
)
{
return
this
.
m_maxExp
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
getMaxValue
=
function
(
)
{
return
this
.
m_maxValue
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
getFractionBits
=
function
(
)
{
return
this
.
m_fractionBits
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
hasSubnormal
=
function
(
)
{
return
this
.
m_hasSubnormal
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
hasInf
=
function
(
)
{
return
this
.
m_hasInf
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
ulp
=
function
(
x
count
)
{
var
breakdown
=
deMath
.
deFractExp
(
Math
.
abs
(
x
)
)
;
var
exp
=
breakdown
.
exponent
;
var
frac
=
breakdown
.
significand
;
if
(
isNaN
(
frac
)
)
return
NaN
;
else
if
(
!
isFinite
(
frac
)
)
return
deMath
.
deLdExp
(
1
.
0
this
.
m_maxExp
-
this
.
m_fractionBits
)
;
else
if
(
frac
=
=
1
.
0
)
{
-
-
exp
;
}
else
if
(
frac
=
=
0
.
0
)
exp
=
this
.
m_minExp
;
exp
=
Math
.
max
(
exp
this
.
m_minExp
)
;
var
oneULP
=
deMath
.
deLdExp
(
1
.
0
exp
-
this
.
m_fractionBits
)
;
return
oneULP
*
count
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
exponentShift
=
function
(
exp
)
{
return
this
.
m_fractionBits
-
Math
.
max
(
this
.
m_minExp
-
exp
0
)
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
round
=
function
(
d
upward
)
{
var
breakdown
=
deMath
.
deFractExp
(
d
)
;
var
exp
=
breakdown
.
exponent
;
var
frac
=
breakdown
.
significand
;
var
shift
=
this
.
exponentShift
(
exp
)
;
var
shiftFrac
=
deMath
.
deLdExp
(
frac
shift
)
;
var
roundFrac
=
upward
?
Math
.
ceil
(
shiftFrac
)
:
Math
.
floor
(
shiftFrac
)
;
return
deMath
.
deLdExp
(
roundFrac
exp
-
shift
)
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
clampValue
=
function
(
d
)
{
var
rSign
=
deMath
.
deSign
(
d
)
;
var
rExp
=
0
;
var
breakdown
=
deMath
.
deFractExp
(
d
)
;
rExp
=
breakdown
.
exponent
;
if
(
rExp
<
this
.
m_minExp
)
return
tcuFloatFormat
.
chooseInterval
(
this
.
m_hasSubnormal
new
tcuInterval
.
Interval
(
rSign
*
0
.
0
)
new
tcuInterval
.
Interval
(
d
)
)
;
else
if
(
!
isFinite
(
d
)
|
|
rExp
>
this
.
m_maxExp
)
return
tcuFloatFormat
.
chooseInterval
(
this
.
m_hasInf
new
tcuInterval
.
Interval
(
rSign
*
this
.
getMaxValue
(
)
)
new
tcuInterval
.
Interval
(
rSign
*
Number
.
POSITIVE_INFINITY
)
)
;
return
new
tcuInterval
.
Interval
(
d
)
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
roundOutDir
=
function
(
d
upward
roundUnderOverflow
)
{
var
breakdown
=
deMath
.
deFractExp
(
d
)
;
var
exp
=
breakdown
.
exponent
;
if
(
roundUnderOverflow
&
&
exp
>
this
.
m_maxExp
&
&
(
upward
=
=
(
d
<
0
.
0
)
)
)
return
deMath
.
deSign
(
d
)
*
this
.
getMaxValue
(
)
;
else
return
this
.
round
(
d
upward
)
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
roundOut
=
function
(
x
roundUnderOverflow
)
{
var
ret
=
x
.
nan
(
)
;
if
(
!
x
.
empty
(
)
)
{
var
a
=
new
tcuInterval
.
Interval
(
this
.
roundOutDir
(
x
.
lo
(
)
false
roundUnderOverflow
)
)
;
var
b
=
new
tcuInterval
.
Interval
(
this
.
roundOutDir
(
x
.
hi
(
)
true
roundUnderOverflow
)
)
;
ret
.
operatorOrAssignBinary
(
tcuInterval
.
withIntervals
(
a
b
)
)
;
}
return
ret
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
convert
=
function
(
x
)
{
var
ret
=
new
tcuInterval
.
Interval
(
)
;
var
tmp
=
x
;
if
(
x
.
hasNaN
(
)
)
{
if
(
this
.
m_hasNaN
!
=
tcuFloatFormat
.
YesNoMaybe
.
NO
)
ret
.
operatorOrAssignBinary
(
new
tcuInterval
.
Interval
(
NaN
)
)
;
if
(
this
.
m_hasNaN
!
=
tcuFloatFormat
.
YesNoMaybe
.
YES
)
tmp
=
tcuInterval
.
unbounded
(
)
;
}
if
(
!
tmp
.
empty
(
)
)
ret
.
operatorOrAssignBinary
(
this
.
clampValue
(
this
.
round
(
tmp
.
lo
(
)
true
)
)
.
operatorOrBinary
(
this
.
clampValue
(
this
.
round
(
tmp
.
hi
(
)
false
)
)
)
)
;
if
(
!
this
.
m_exactPrecision
)
ret
.
operatorOrAssignBinary
(
x
)
;
return
ret
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
floatToHex
=
function
(
x
)
{
if
(
isNaN
(
x
)
)
return
'
NaN
'
;
else
if
(
!
isFinite
(
x
)
)
return
(
x
<
0
.
0
?
'
-
'
:
'
+
'
)
+
(
'
inf
'
)
;
else
if
(
x
=
=
0
.
0
)
return
'
0
.
0
'
;
return
x
.
toString
(
10
)
;
}
;
tcuFloatFormat
.
FloatFormat
.
prototype
.
intervalToHex
=
function
(
interval
)
{
if
(
interval
.
empty
(
)
)
return
interval
.
hasNaN
(
)
?
'
{
NaN
}
'
:
'
{
}
'
;
else
if
(
interval
.
lo
(
)
=
=
interval
.
hi
(
)
)
return
(
(
interval
.
hasNaN
(
)
?
'
{
NaN
'
:
'
{
'
)
+
this
.
floatToHex
(
interval
.
lo
(
)
)
+
'
}
'
)
;
else
if
(
interval
=
=
tcuInterval
.
unbounded
(
true
)
)
return
'
<
any
>
'
;
return
(
(
interval
.
hasNaN
(
)
?
'
{
NaN
}
|
'
:
'
'
)
+
'
[
'
+
this
.
floatToHex
(
interval
.
lo
(
)
)
+
'
'
+
this
.
floatToHex
(
interval
.
hi
(
)
)
+
'
]
'
)
;
}
;
tcuFloatFormat
.
nativeDouble
=
function
(
)
{
return
new
tcuFloatFormat
.
FloatFormat
(
-
1021
-
1
1024
-
1
53
-
1
true
tcuFloatFormat
.
YesNoMaybe
.
YES
tcuFloatFormat
.
YesNoMaybe
.
YES
tcuFloatFormat
.
YesNoMaybe
.
YES
)
;
}
;
}
)
;
