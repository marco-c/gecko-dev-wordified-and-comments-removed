'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuTexLookupVerifier
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexVerifierUtil
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuTexLookupVerifier
=
framework
.
common
.
tcuTexLookupVerifier
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
tcuTexVerifierUtil
=
framework
.
common
.
tcuTexVerifierUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
tcuTexLookupVerifier
.
PrecType
;
tcuTexLookupVerifier
.
LookupPrecision
=
function
(
coordBits
uvwBits
colorThreshold
colorMask
)
{
this
.
coordBits
=
coordBits
|
|
[
22
22
22
]
;
this
.
uvwBits
=
uvwBits
|
|
[
16
16
16
]
;
this
.
colorThreshold
=
colorThreshold
|
|
[
0
0
0
0
]
;
this
.
colorMask
=
colorMask
|
|
[
true
true
true
true
]
;
}
;
tcuTexLookupVerifier
.
LodPrecision
=
function
(
derivateBits
lodBits
)
{
this
.
derivateBits
=
derivateBits
=
=
=
undefined
?
22
:
derivateBits
;
this
.
lodBits
=
lodBits
=
=
=
undefined
?
16
:
lodBits
;
}
;
tcuTexLookupVerifier
.
TexLookupScaleMode
=
{
MINIFY
:
0
MAGNIFY
:
1
}
;
tcuTexLookupVerifier
.
isSamplerSupported
=
function
(
sampler
)
{
return
sampler
.
compare
=
=
tcuTexture
.
CompareMode
.
COMPAREMODE_NONE
&
&
tcuTexVerifierUtil
.
isWrapModeSupported
(
sampler
.
wrapS
)
&
&
tcuTexVerifierUtil
.
isWrapModeSupported
(
sampler
.
wrapT
)
&
&
tcuTexVerifierUtil
.
isWrapModeSupported
(
sampler
.
wrapR
)
;
}
;
tcuTexLookupVerifier
.
coordsInBounds
=
function
(
access
x
y
z
)
{
return
deMath
.
deInBounds32
(
x
0
access
.
getWidth
(
)
)
&
&
deMath
.
deInBounds32
(
y
0
access
.
getHeight
(
)
)
&
&
deMath
.
deInBounds32
(
z
0
access
.
getDepth
(
)
)
;
}
;
tcuTexLookupVerifier
.
isSRGB
=
function
(
format
)
{
return
format
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGB
|
|
format
.
order
=
=
tcuTexture
.
ChannelOrder
.
sRGBA
;
}
;
tcuTexLookupVerifier
.
lookupScalar
=
function
(
access
sampler
i
j
k
)
{
if
(
tcuTexLookupVerifier
.
coordsInBounds
(
access
i
j
k
)
)
return
access
.
getPixel
(
i
j
k
)
;
else
return
deMath
.
toIVec
(
sampler
.
borderColor
)
;
}
;
tcuTexLookupVerifier
.
lookupFloat
=
function
(
access
sampler
i
j
k
)
{
if
(
tcuTexLookupVerifier
.
coordsInBounds
(
access
i
j
k
)
)
{
var
p
=
access
.
getPixel
(
i
j
k
)
;
return
tcuTexLookupVerifier
.
isSRGB
(
access
.
getFormat
(
)
)
?
tcuTextureUtil
.
sRGBToLinear
(
p
)
:
p
;
}
else
return
sampler
.
borderColor
;
}
;
tcuTexLookupVerifier
.
isColorValid
=
function
(
prec
ref
result
)
{
return
deMath
.
boolAll
(
deMath
.
logicalOrBool
(
deMath
.
lessThanEqual
(
deMath
.
absDiff
(
ref
result
)
prec
.
colorThreshold
)
deMath
.
logicalNotBool
(
prec
.
colorMask
)
)
)
;
}
;
tcuTexLookupVerifier
.
ColorQuad
=
function
(
p00
p01
p10
p11
)
{
this
.
p00
=
p00
|
|
null
;
this
.
p01
=
p01
|
|
null
;
this
.
p10
=
p10
|
|
null
;
this
.
p11
=
p11
|
|
null
;
}
;
tcuTexLookupVerifier
.
lookupQuad
=
function
(
level
sampler
x0
x1
y0
y1
z
)
{
var
p00
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x0
y0
z
)
;
var
p10
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x1
y0
z
)
;
var
p01
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x0
y1
z
)
;
var
p11
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x1
y1
z
)
;
return
new
tcuTexLookupVerifier
.
ColorQuad
(
p00
p01
p10
p11
)
;
}
;
tcuTexLookupVerifier
.
ColorLine
=
function
(
p0
p1
)
{
this
.
p0
=
p0
|
|
null
;
this
.
p1
=
p1
|
|
null
;
}
;
tcuTexLookupVerifier
.
lookupLine
=
function
(
level
sampler
x0
x1
y
)
{
return
new
tcuTexLookupVerifier
.
ColorLine
(
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x0
y
0
)
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x1
y
0
)
)
;
}
;
tcuTexLookupVerifier
.
minComp
=
function
(
vec
)
{
var
minVal
=
vec
[
0
]
;
for
(
var
ndx
=
1
;
ndx
<
vec
.
length
;
ndx
+
+
)
minVal
=
Math
.
min
(
minVal
vec
[
ndx
]
)
;
return
minVal
;
}
;
tcuTexLookupVerifier
.
maxComp
=
function
(
vec
)
{
var
maxVal
=
vec
[
0
]
;
for
(
var
ndx
=
1
;
ndx
<
vec
.
length
;
ndx
+
+
)
maxVal
=
Math
.
max
(
maxVal
vec
[
ndx
]
)
;
return
maxVal
;
}
;
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatLine
=
function
(
prec
line
)
{
assertMsgOptions
(
deMath
.
boolAll
(
deMath
.
greaterThan
(
prec
.
colorThreshold
[
0
0
0
0
]
)
)
'
Threshold
not
greater
than
0
.
'
false
true
)
;
var
maxSteps
=
1
<
<
16
;
var
d
=
deMath
.
absDiff
(
line
.
p1
line
.
p0
)
;
var
stepCount
=
deMath
.
divide
(
[
d
d
d
d
]
prec
.
colorThreshold
)
;
var
minStep
=
deMath
.
divide
(
[
1
1
1
1
]
deMath
.
add
(
stepCount
[
1
1
1
1
]
)
)
;
var
step
=
Math
.
max
(
tcuTexLookupVerifier
.
minComp
(
minStep
)
1
/
maxSteps
)
;
return
step
;
}
;
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
=
function
(
prec
quad
)
{
assertMsgOptions
(
deMath
.
boolAll
(
deMath
.
greaterThan
(
prec
.
colorThreshold
[
0
0
0
0
]
)
)
'
Threshold
not
greater
than
0
.
'
false
true
)
;
var
maxSteps
=
1
<
<
16
;
var
d0
=
deMath
.
absDiff
(
quad
.
p10
quad
.
p00
)
;
var
d1
=
deMath
.
absDiff
(
quad
.
p01
quad
.
p00
)
;
var
d2
=
deMath
.
absDiff
(
quad
.
p11
quad
.
p10
)
;
var
d3
=
deMath
.
absDiff
(
quad
.
p11
quad
.
p01
)
;
var
maxD
=
deMath
.
max
(
d0
deMath
.
max
(
d1
deMath
.
max
(
d2
d3
)
)
)
;
var
stepCount
=
deMath
.
divide
(
maxD
prec
.
colorThreshold
)
;
var
minStep
=
deMath
.
divide
(
[
1
1
1
1
]
deMath
.
add
(
stepCount
[
1
1
1
1
]
)
)
;
var
step
=
Math
.
max
(
tcuTexLookupVerifier
.
minComp
(
minStep
)
1
/
maxSteps
)
;
return
step
;
}
;
tcuTexLookupVerifier
.
computeBilinearSearchStepForUnorm
=
function
(
prec
)
{
assertMsgOptions
(
deMath
.
boolAll
(
deMath
.
greaterThan
(
prec
.
colorThreshold
[
0
0
0
0
]
)
)
'
Threshold
not
greater
than
0
.
'
false
true
)
;
var
stepCount
=
deMath
.
divide
(
[
1
1
1
1
]
prec
.
colorThreshold
)
;
var
minStep
=
deMath
.
divide
(
[
1
1
1
1
]
(
deMath
.
add
(
stepCount
[
1
1
1
1
]
)
)
)
;
var
step
=
tcuTexLookupVerifier
.
minComp
(
minStep
)
;
return
step
;
}
;
tcuTexLookupVerifier
.
computeBilinearSearchStepForSnorm
=
function
(
prec
)
{
assertMsgOptions
(
deMath
.
boolAll
(
deMath
.
greaterThan
(
prec
.
colorThreshold
[
0
0
0
0
]
)
)
'
Threshold
not
greater
than
0
.
'
false
true
)
;
var
stepCount
=
deMath
.
divide
(
[
2
.
0
2
.
0
2
.
0
2
.
0
]
prec
.
colorThreshold
)
;
var
minStep
=
deMath
.
divide
(
[
1
1
1
1
]
deMath
.
add
(
stepCount
[
1
1
1
1
]
)
)
;
var
step
=
tcuTexLookupVerifier
.
minComp
(
minStep
)
;
return
step
;
}
;
tcuTexLookupVerifier
.
minLine
=
function
(
line
)
{
return
deMath
.
min
(
line
.
p0
line
.
p1
)
;
}
;
tcuTexLookupVerifier
.
maxLine
=
function
(
line
)
{
var
max
=
deMath
.
max
;
return
max
(
line
.
p0
line
.
p1
)
;
}
;
tcuTexLookupVerifier
.
minQuad
=
function
(
quad
)
{
var
min
=
deMath
.
min
;
return
min
(
quad
.
p00
min
(
quad
.
p10
min
(
quad
.
p01
quad
.
p11
)
)
)
;
}
;
tcuTexLookupVerifier
.
maxQuad
=
function
(
quad
)
{
var
max
=
deMath
.
max
;
return
max
(
quad
.
p00
max
(
quad
.
p10
max
(
quad
.
p01
quad
.
p11
)
)
)
;
}
;
tcuTexLookupVerifier
.
isInColorBounds_1Quad
=
function
(
prec
quad
result
)
{
var
quadMin
=
tcuTexLookupVerifier
.
minQuad
;
var
quadMax
=
tcuTexLookupVerifier
.
maxQuad
;
var
minVal
=
deMath
.
subtract
(
quadMin
(
quad
)
prec
.
colorThreshold
)
;
var
maxVal
=
deMath
.
add
(
quadMax
(
quad
)
prec
.
colorThreshold
)
;
return
deMath
.
boolAll
(
deMath
.
logicalOrBool
(
deMath
.
logicalAndBool
(
deMath
.
greaterThanEqual
(
result
minVal
)
deMath
.
lessThanEqual
(
result
maxVal
)
)
deMath
.
logicalNotBool
(
prec
.
colorMask
)
)
)
;
}
;
tcuTexLookupVerifier
.
isInColorBounds_2Quad
=
function
(
prec
quad0
quad1
result
)
{
var
min
=
deMath
.
min
;
var
max
=
deMath
.
max
;
var
quadMin
=
tcuTexLookupVerifier
.
minQuad
;
var
quadMax
=
tcuTexLookupVerifier
.
maxQuad
;
var
minVal
=
deMath
.
subtract
(
min
(
quadMin
(
quad0
)
quadMin
(
quad1
)
)
prec
.
colorThreshold
)
;
var
maxVal
=
deMath
.
add
(
max
(
quadMax
(
quad0
)
quadMax
(
quad1
)
)
prec
.
colorThreshold
)
;
return
deMath
.
boolAll
(
deMath
.
logicalOrBool
(
deMath
.
logicalAndBool
(
deMath
.
greaterThanEqual
(
result
minVal
)
deMath
.
lessThanEqual
(
result
maxVal
)
)
deMath
.
logicalNotBool
(
prec
.
colorMask
)
)
)
;
}
;
tcuTexLookupVerifier
.
isInColorBounds_2Line
=
function
(
prec
line0
line1
result
)
{
var
min
=
deMath
.
min
;
var
max
=
deMath
.
max
;
var
lineMin
=
tcuTexLookupVerifier
.
minLine
;
var
lineMax
=
tcuTexLookupVerifier
.
maxLine
;
var
minVal
=
deMath
.
subtract
(
min
(
lineMin
(
line0
)
lineMin
(
line1
)
)
prec
.
colorThreshold
)
;
var
maxVal
=
deMath
.
add
(
max
(
lineMax
(
line0
)
lineMax
(
line1
)
)
prec
.
colorThreshold
)
;
return
deMath
.
boolAll
(
deMath
.
logicalOrBool
(
deMath
.
logicalAndBool
(
deMath
.
greaterThanEqual
(
result
minVal
)
deMath
.
lessThanEqual
(
result
maxVal
)
)
deMath
.
logicalNotBool
(
prec
.
colorMask
)
)
)
;
}
;
tcuTexLookupVerifier
.
isInColorBounds_4Quad
=
function
(
prec
quad00
quad01
quad10
quad11
result
)
{
var
min
=
deMath
.
min
;
var
max
=
deMath
.
max
;
var
quadMin
=
tcuTexLookupVerifier
.
minQuad
;
var
quadMax
=
tcuTexLookupVerifier
.
maxQuad
;
var
minVal
=
deMath
.
subtract
(
min
(
quadMin
(
quad00
)
min
(
quadMin
(
quad01
)
min
(
quadMin
(
quad10
)
quadMin
(
quad11
)
)
)
)
prec
.
colorThreshold
)
;
var
maxVal
=
deMath
.
add
(
max
(
quadMax
(
quad00
)
max
(
quadMax
(
quad01
)
max
(
quadMax
(
quad10
)
quadMax
(
quad11
)
)
)
)
prec
.
colorThreshold
)
;
return
deMath
.
boolAll
(
deMath
.
logicalOrBool
(
deMath
.
logicalAndBool
(
deMath
.
greaterThanEqual
(
result
minVal
)
deMath
.
lessThanEqual
(
result
maxVal
)
)
deMath
.
logicalNotBool
(
prec
.
colorMask
)
)
)
;
}
;
tcuTexLookupVerifier
.
isLinearRangeValid
=
function
(
prec
c0
c1
fBounds
result
)
{
var
rMin
=
deMath
.
subtract
(
result
prec
.
colorThreshold
)
;
var
rMax
=
deMath
.
add
(
result
prec
.
colorThreshold
)
;
for
(
var
compNdx
=
0
;
compNdx
<
4
;
compNdx
+
+
)
{
if
(
!
prec
.
colorMask
[
compNdx
]
)
continue
;
var
i0
=
c0
[
compNdx
]
*
(
1
-
fBounds
[
0
]
)
+
c1
[
compNdx
]
*
fBounds
[
0
]
;
var
i1
=
c0
[
compNdx
]
*
(
1
-
fBounds
[
1
]
)
+
c1
[
compNdx
]
*
fBounds
[
1
]
;
if
(
(
i0
>
rMax
[
compNdx
]
&
&
i1
>
rMax
[
compNdx
]
)
|
|
(
i0
<
rMin
[
compNdx
]
&
&
i1
<
rMin
[
compNdx
]
)
)
{
return
false
;
}
}
return
true
;
}
;
tcuTexLookupVerifier
.
isBilinearRangeValid
=
function
(
prec
quad
xBounds
yBounds
searchStep
result
)
{
assertMsgOptions
(
xBounds
[
0
]
<
=
xBounds
[
1
]
'
Out
of
bounds
:
X
direction
.
'
false
true
)
;
assertMsgOptions
(
yBounds
[
0
]
<
=
yBounds
[
1
]
'
Out
of
bounds
:
Y
direction
.
'
false
true
)
;
if
(
!
tcuTexLookupVerifier
.
isInColorBounds_1Quad
(
prec
quad
result
)
)
return
false
;
for
(
var
x
=
xBounds
[
0
]
;
x
<
xBounds
[
1
]
+
searchStep
;
x
+
=
searchStep
)
{
var
a
=
Math
.
min
(
x
xBounds
[
1
]
)
;
var
c0
=
deMath
.
add
(
deMath
.
scale
(
quad
.
p00
(
1
-
a
)
)
deMath
.
scale
(
quad
.
p10
a
)
)
;
var
c1
=
deMath
.
add
(
deMath
.
scale
(
quad
.
p01
(
1
-
a
)
)
deMath
.
scale
(
quad
.
p11
a
)
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
c0
c1
yBounds
result
)
)
return
true
;
}
return
false
;
}
;
tcuTexLookupVerifier
.
isTrilinearRangeValid
=
function
(
prec
quad0
quad1
xBounds
yBounds
zBounds
searchStep
result
)
{
assertMsgOptions
(
xBounds
[
0
]
<
=
xBounds
[
1
]
'
Out
of
bounds
:
X
direction
.
'
false
true
)
;
assertMsgOptions
(
yBounds
[
0
]
<
=
yBounds
[
1
]
'
Out
of
bounds
:
Y
direction
.
'
false
true
)
;
assertMsgOptions
(
zBounds
[
0
]
<
=
zBounds
[
1
]
'
Out
of
bounds
:
Z
direction
.
'
false
true
)
;
if
(
!
tcuTexLookupVerifier
.
isInColorBounds_2Quad
(
prec
quad0
quad1
result
)
)
return
false
;
for
(
var
x
=
xBounds
[
0
]
;
x
<
xBounds
[
1
]
+
searchStep
;
x
+
=
searchStep
)
{
for
(
var
y
=
yBounds
[
0
]
;
y
<
yBounds
[
1
]
+
searchStep
;
y
+
=
searchStep
)
{
var
a
=
Math
.
min
(
x
xBounds
[
1
]
)
;
var
b
=
Math
.
min
(
y
yBounds
[
1
]
)
;
var
c0
=
deMath
.
add
(
deMath
.
add
(
deMath
.
add
(
deMath
.
scale
(
quad0
.
p00
(
1
-
a
)
*
(
1
-
b
)
)
deMath
.
scale
(
quad0
.
p10
a
*
(
1
-
b
)
)
)
deMath
.
scale
(
quad0
.
p01
(
1
-
a
)
*
b
)
)
deMath
.
scale
(
quad0
.
p11
a
*
b
)
)
;
var
c1
=
deMath
.
add
(
deMath
.
add
(
deMath
.
add
(
deMath
.
scale
(
quad1
.
p00
(
1
-
a
)
*
(
1
-
b
)
)
deMath
.
scale
(
quad1
.
p10
a
*
(
1
-
b
)
)
)
deMath
.
scale
(
quad1
.
p01
(
1
-
a
)
*
b
)
)
deMath
.
scale
(
quad1
.
p11
a
*
b
)
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
c0
c1
zBounds
result
)
)
return
true
;
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
is2DTrilinearFilterResultValid
=
function
(
prec
quad0
quad1
xBounds0
yBounds0
xBounds1
yBounds1
zBounds
searchStep
result
)
{
assertMsgOptions
(
xBounds0
[
0
]
<
=
xBounds0
[
1
]
'
Out
of
bounds
:
X
direction
.
'
false
true
)
;
assertMsgOptions
(
yBounds0
[
0
]
<
=
yBounds0
[
1
]
'
Out
of
bounds
:
Y
direction
.
'
false
true
)
;
assertMsgOptions
(
xBounds1
[
0
]
<
=
xBounds1
[
1
]
'
Out
of
bounds
:
X
direction
.
'
false
true
)
;
assertMsgOptions
(
yBounds1
[
0
]
<
=
yBounds1
[
1
]
'
Out
of
bounds
:
Y
direction
.
'
false
true
)
;
if
(
!
tcuTexLookupVerifier
.
isInColorBounds_2Quad
(
prec
quad0
quad1
result
)
)
return
false
;
for
(
var
x0
=
xBounds0
[
0
]
;
x0
<
xBounds0
[
1
]
+
searchStep
;
x0
+
=
searchStep
)
{
for
(
var
y0
=
yBounds0
[
0
]
;
y0
<
yBounds0
[
1
]
+
searchStep
;
y0
+
=
searchStep
)
{
var
a0
=
Math
.
min
(
x0
xBounds0
[
1
]
)
;
var
b0
=
Math
.
min
(
y0
yBounds0
[
1
]
)
;
var
c0
=
deMath
.
add
(
deMath
.
add
(
deMath
.
add
(
deMath
.
scale
(
quad0
.
p00
(
1
-
a0
)
*
(
1
-
b0
)
)
deMath
.
scale
(
quad0
.
p10
a0
*
(
1
-
b0
)
)
)
deMath
.
scale
(
quad0
.
p01
(
1
-
a0
)
*
b0
)
)
deMath
.
scale
(
quad0
.
p11
a0
*
b0
)
)
;
for
(
var
x1
=
xBounds1
[
0
]
;
x1
<
=
xBounds1
[
1
]
;
x1
+
=
searchStep
)
{
for
(
var
y1
=
yBounds1
[
0
]
;
y1
<
=
yBounds1
[
1
]
;
y1
+
=
searchStep
)
{
var
a1
=
Math
.
min
(
x1
xBounds1
[
1
]
)
;
var
b1
=
Math
.
min
(
y1
yBounds1
[
1
]
)
;
var
c1
=
deMath
.
add
(
deMath
.
add
(
deMath
.
add
(
deMath
.
scale
(
quad1
.
p00
(
1
-
a1
)
*
(
1
-
b1
)
)
deMath
.
scale
(
quad1
.
p10
a1
*
(
1
-
b1
)
)
)
deMath
.
scale
(
quad1
.
p01
(
1
-
a1
)
*
b1
)
)
deMath
.
scale
(
quad1
.
p11
a1
*
b1
)
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
c0
c1
zBounds
result
)
)
return
true
;
}
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
is3DTrilinearFilterResultValid
=
function
(
prec
quad00
quad01
quad10
quad11
xBounds0
yBounds0
zBounds0
xBounds1
yBounds1
zBounds1
wBounds
searchStep
result
)
{
assertMsgOptions
(
xBounds0
[
0
]
<
=
xBounds0
[
1
]
'
Out
of
bounds
:
X
direction
.
'
false
true
)
;
assertMsgOptions
(
yBounds0
[
0
]
<
=
yBounds0
[
1
]
'
Out
of
bounds
:
Y
direction
.
'
false
true
)
;
assertMsgOptions
(
zBounds0
[
0
]
<
=
zBounds0
[
1
]
'
Out
of
bounds
:
Z
direction
.
'
false
true
)
;
assertMsgOptions
(
xBounds1
[
0
]
<
=
xBounds1
[
1
]
'
Out
of
bounds
:
X
direction
.
'
false
true
)
;
assertMsgOptions
(
yBounds1
[
0
]
<
=
yBounds1
[
1
]
'
Out
of
bounds
:
Y
direction
.
'
false
true
)
;
assertMsgOptions
(
zBounds1
[
0
]
<
=
zBounds1
[
1
]
'
Out
of
bounds
:
Z
direction
.
'
false
true
)
;
if
(
!
tcuTexLookupVerifier
.
isInColorBounds_4Quad
(
prec
quad00
quad01
quad10
quad11
result
)
)
return
false
;
function
biInterp
(
result
p00
p01
p10
p11
s00
s01
s10
s11
)
{
for
(
var
ii
=
0
;
ii
<
4
;
+
+
ii
)
{
result
[
ii
]
=
p00
[
ii
]
*
s00
+
p10
[
ii
]
*
s10
+
p01
[
ii
]
*
s01
+
p11
[
ii
]
*
s11
;
}
}
function
interp
(
result
p0
p1
s
)
{
for
(
var
ii
=
0
;
ii
<
4
;
+
+
ii
)
{
result
[
ii
]
=
p0
[
ii
]
*
(
1
-
s
)
+
p1
[
ii
]
*
s
;
}
}
var
c00
=
[
0
0
0
0
]
;
var
c01
=
[
0
0
0
0
]
;
var
c10
=
[
0
0
0
0
]
;
var
c11
=
[
0
0
0
0
]
;
var
cz0
=
[
0
0
0
0
]
;
var
cz1
=
[
0
0
0
0
]
;
for
(
var
x0
=
xBounds0
[
0
]
;
x0
<
xBounds0
[
1
]
+
searchStep
;
x0
+
=
searchStep
)
{
for
(
var
y0
=
yBounds0
[
0
]
;
y0
<
yBounds0
[
1
]
+
searchStep
;
y0
+
=
searchStep
)
{
var
a0
=
Math
.
min
(
x0
xBounds0
[
1
]
)
;
var
b0
=
Math
.
min
(
y0
yBounds0
[
1
]
)
;
var
s00
=
(
1
-
a0
)
*
(
1
-
b0
)
;
var
s01
=
(
1
-
a0
)
*
b0
;
var
s10
=
a0
*
(
1
-
b0
)
;
var
s11
=
a0
*
b0
;
biInterp
(
c00
quad00
.
p00
quad00
.
p01
quad00
.
p10
quad00
.
p11
s00
s01
s10
s11
)
;
biInterp
(
c01
quad01
.
p00
quad01
.
p01
quad01
.
p10
quad01
.
p11
s00
s01
s10
s11
)
;
for
(
var
z0
=
zBounds0
[
0
]
;
z0
<
zBounds0
[
1
]
+
searchStep
;
z0
+
=
searchStep
)
{
var
c0
=
Math
.
min
(
z0
zBounds0
[
1
]
)
;
interp
(
cz0
c00
c01
c0
)
;
for
(
var
x1
=
xBounds1
[
0
]
;
x1
<
xBounds1
[
1
]
+
searchStep
;
x1
+
=
searchStep
)
{
for
(
var
y1
=
yBounds1
[
0
]
;
y1
<
yBounds1
[
1
]
+
searchStep
;
y1
+
=
searchStep
)
{
var
a1
=
Math
.
min
(
x1
xBounds1
[
1
]
)
;
var
b1
=
Math
.
min
(
y1
yBounds1
[
1
]
)
;
var
t00
=
(
1
-
a1
)
*
(
1
-
b1
)
;
var
t01
=
(
1
-
a1
)
*
b1
;
var
t10
=
a1
*
(
1
-
b1
)
;
var
t11
=
a1
*
b1
;
biInterp
(
c10
quad10
.
p00
quad10
.
p01
quad10
.
p10
quad10
.
p11
t00
t01
t10
t11
)
;
biInterp
(
c11
quad11
.
p00
quad11
.
p01
quad11
.
p10
quad11
.
p11
t00
t01
t10
t11
)
;
for
(
var
z1
=
zBounds1
[
0
]
;
z1
<
zBounds1
[
1
]
+
searchStep
;
z1
+
=
searchStep
)
{
var
c1
=
Math
.
min
(
z1
zBounds1
[
1
]
)
;
interp
(
cz1
c10
c11
c1
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
cz0
cz1
wBounds
result
)
)
return
true
;
}
}
}
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordXYAsNumber
=
function
(
level
sampler
prec
coordX
coordY
result
)
{
assertMsgOptions
(
level
.
getDepth
(
)
=
=
1
'
Depth
must
be
1
.
'
false
true
)
;
var
uBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getWidth
(
)
coordX
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
minI
=
Math
.
floor
(
uBounds
[
0
]
)
;
var
maxI
=
Math
.
floor
(
uBounds
[
1
]
)
;
for
(
var
i
=
minI
;
i
<
=
maxI
;
i
+
+
)
{
var
x
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
level
.
getWidth
(
)
)
;
var
color
;
if
(
tcuTexLookupVerifier
.
isSRGB
(
level
.
getFormat
(
)
)
)
{
color
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x
coordY
0
)
;
}
else
{
color
=
tcuTexLookupVerifier
.
lookupScalar
(
level
sampler
x
coordY
0
)
;
}
if
(
tcuTexLookupVerifier
.
isColorValid
(
prec
color
result
)
)
return
true
;
}
return
false
;
}
;
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordAsVec2AndInt
=
function
(
level
sampler
prec
coord
coordZ
result
)
{
var
uBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getWidth
(
)
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getHeight
(
)
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
minI
=
Math
.
floor
(
uBounds
[
0
]
)
;
var
maxI
=
Math
.
floor
(
uBounds
[
1
]
)
;
var
minJ
=
Math
.
floor
(
vBounds
[
0
]
)
;
var
maxJ
=
Math
.
floor
(
vBounds
[
1
]
)
;
for
(
var
j
=
minJ
;
j
<
=
maxJ
;
j
+
+
)
for
(
var
i
=
minI
;
i
<
=
maxI
;
i
+
+
)
{
var
x
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
level
.
getWidth
(
)
)
;
var
y
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j
level
.
getHeight
(
)
)
;
var
color
;
if
(
tcuTexLookupVerifier
.
isSRGB
(
level
.
getFormat
(
)
)
)
{
color
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x
y
coordZ
)
;
}
else
{
color
=
tcuTexLookupVerifier
.
lookupScalar
(
level
sampler
x
y
coordZ
)
;
}
if
(
tcuTexLookupVerifier
.
isColorValid
(
prec
color
result
)
)
return
true
;
}
return
false
;
}
;
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordAsVec3
=
function
(
level
sampler
prec
coord
result
)
{
var
uBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getWidth
(
)
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getHeight
(
)
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
wBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getDepth
(
)
coord
[
2
]
prec
.
coordBits
[
2
]
prec
.
uvwBits
[
2
]
)
;
var
minI
=
Math
.
floor
(
uBounds
[
0
]
)
;
var
maxI
=
Math
.
floor
(
uBounds
[
1
]
)
;
var
minJ
=
Math
.
floor
(
vBounds
[
0
]
)
;
var
maxJ
=
Math
.
floor
(
vBounds
[
1
]
)
;
var
minK
=
Math
.
floor
(
wBounds
[
0
]
)
;
var
maxK
=
Math
.
floor
(
wBounds
[
1
]
)
;
for
(
var
k
=
minK
;
k
<
=
maxK
;
k
+
+
)
{
for
(
var
j
=
minJ
;
j
<
=
maxJ
;
j
+
+
)
{
for
(
var
i
=
minI
;
i
<
=
maxI
;
i
+
+
)
{
var
x
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
level
.
getWidth
(
)
)
;
var
y
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j
level
.
getHeight
(
)
)
;
var
z
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k
level
.
getDepth
(
)
)
;
var
color
;
if
(
tcuTexLookupVerifier
.
isSRGB
(
level
.
getFormat
(
)
)
)
{
color
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x
y
z
)
;
}
else
{
color
=
tcuTexLookupVerifier
.
lookupScalar
(
level
sampler
x
y
z
)
;
}
if
(
tcuTexLookupVerifier
.
isColorValid
(
prec
color
result
)
)
return
true
;
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLinearSampleResultValid_CoordXYAsNumber
=
function
(
level
sampler
prec
coordX
coordY
result
)
{
var
uBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getWidth
(
)
coordX
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
minI
=
Math
.
floor
(
uBounds
[
0
]
-
0
.
5
)
;
var
maxI
=
Math
.
floor
(
uBounds
[
1
]
-
0
.
5
)
;
var
w
=
level
.
getWidth
(
)
;
for
(
var
i
=
minI
;
i
<
=
maxI
;
i
+
+
)
{
var
x0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
w
)
;
var
x1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
+
1
w
)
;
var
minA
=
deMath
.
clamp
(
(
uBounds
[
0
]
-
0
.
5
)
-
i
0
1
)
;
var
maxA
=
deMath
.
clamp
(
(
uBounds
[
1
]
-
0
.
5
)
-
i
0
1
)
;
var
colorA
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x0
coordY
0
)
;
var
colorB
=
tcuTexLookupVerifier
.
lookupFloat
(
level
sampler
x1
coordY
0
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
colorA
colorB
[
minA
maxA
]
result
)
)
return
true
;
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLinearSampleResultValid_CoordAsVec2AndInt
=
function
(
level
sampler
prec
coord
coordZ
result
)
{
var
uBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getWidth
(
)
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getHeight
(
)
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
minI
=
Math
.
floor
(
uBounds
[
0
]
-
0
.
5
)
;
var
maxI
=
Math
.
floor
(
uBounds
[
1
]
-
0
.
5
)
;
var
minJ
=
Math
.
floor
(
vBounds
[
0
]
-
0
.
5
)
;
var
maxJ
=
Math
.
floor
(
vBounds
[
1
]
-
0
.
5
)
;
var
w
=
level
.
getWidth
(
)
;
var
h
=
level
.
getHeight
(
)
;
var
texClass
=
tcuTexture
.
getTextureChannelClass
(
level
.
getFormat
(
)
.
type
)
;
var
searchStep
=
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForUnorm
(
prec
)
:
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForSnorm
(
prec
)
:
0
;
for
(
var
j
=
minJ
;
j
<
=
maxJ
;
j
+
+
)
for
(
var
i
=
minI
;
i
<
=
maxI
;
i
+
+
)
{
var
x0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
w
)
;
var
x1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
+
1
w
)
;
var
y0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j
h
)
;
var
y1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j
+
1
h
)
;
var
minA
=
deMath
.
clamp
(
(
uBounds
[
0
]
-
0
.
5
)
-
i
0
1
)
;
var
maxA
=
deMath
.
clamp
(
(
uBounds
[
1
]
-
0
.
5
)
-
i
0
1
)
;
var
minB
=
deMath
.
clamp
(
(
vBounds
[
0
]
-
0
.
5
)
-
j
0
1
)
;
var
maxB
=
deMath
.
clamp
(
(
vBounds
[
1
]
-
0
.
5
)
-
j
0
1
)
;
var
quad
=
tcuTexLookupVerifier
.
lookupQuad
(
level
sampler
x0
x1
y0
y1
coordZ
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep
=
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad
)
;
if
(
tcuTexLookupVerifier
.
isBilinearRangeValid
(
prec
quad
[
minA
maxA
]
[
minB
maxB
]
searchStep
result
)
)
return
true
;
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLinearSampleResultValid_CoordAsVec3
=
function
(
level
sampler
prec
coord
result
)
{
var
uBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getWidth
(
)
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getHeight
(
)
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
wBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
level
.
getDepth
(
)
coord
[
2
]
prec
.
coordBits
[
2
]
prec
.
uvwBits
[
2
]
)
;
var
minI
=
Math
.
floor
(
uBounds
[
0
]
-
0
.
5
)
;
var
maxI
=
Math
.
floor
(
uBounds
[
1
]
-
0
.
5
)
;
var
minJ
=
Math
.
floor
(
vBounds
[
0
]
-
0
.
5
)
;
var
maxJ
=
Math
.
floor
(
vBounds
[
1
]
-
0
.
5
)
;
var
minK
=
Math
.
floor
(
wBounds
[
0
]
-
0
.
5
)
;
var
maxK
=
Math
.
floor
(
wBounds
[
1
]
-
0
.
5
)
;
var
w
=
level
.
getWidth
(
)
;
var
h
=
level
.
getHeight
(
)
;
var
d
=
level
.
getDepth
(
)
;
var
texClass
=
tcuTexture
.
getTextureChannelClass
(
level
.
getFormat
(
)
.
type
)
;
var
searchStep
=
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForUnorm
(
prec
)
:
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForSnorm
(
prec
)
:
0
;
for
(
var
k
=
minK
;
k
<
=
maxK
;
k
+
+
)
{
for
(
var
j
=
minJ
;
j
<
=
maxJ
;
j
+
+
)
{
for
(
var
i
=
minI
;
i
<
=
maxI
;
i
+
+
)
{
var
x0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
w
)
;
var
x1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i
+
1
w
)
;
var
y0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j
h
)
;
var
y1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j
+
1
h
)
;
var
z0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k
d
)
;
var
z1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k
+
1
d
)
;
var
minA
=
deMath
.
clamp
(
(
uBounds
[
0
]
-
0
.
5
)
-
i
0
1
)
;
var
maxA
=
deMath
.
clamp
(
(
uBounds
[
1
]
-
0
.
5
)
-
i
0
1
)
;
var
minB
=
deMath
.
clamp
(
(
vBounds
[
0
]
-
0
.
5
)
-
j
0
1
)
;
var
maxB
=
deMath
.
clamp
(
(
vBounds
[
1
]
-
0
.
5
)
-
j
0
1
)
;
var
minC
=
deMath
.
clamp
(
(
wBounds
[
0
]
-
0
.
5
)
-
k
0
1
)
;
var
maxC
=
deMath
.
clamp
(
(
wBounds
[
1
]
-
0
.
5
)
-
k
0
1
)
;
var
quad0
=
tcuTexLookupVerifier
.
lookupQuad
(
level
sampler
x0
x1
y0
y1
z0
)
;
var
quad1
=
tcuTexLookupVerifier
.
lookupQuad
(
level
sampler
x0
x1
y0
y1
z1
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep
=
Math
.
min
(
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad0
)
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad1
)
)
;
if
(
tcuTexLookupVerifier
.
isTrilinearRangeValid
(
prec
quad0
quad1
[
minA
maxA
]
[
minB
maxB
]
[
minC
maxC
]
searchStep
result
)
)
return
true
;
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isNearestMipmapLinearSampleResultValid_CoordXYAsNumber
=
function
(
level0
level1
sampler
prec
coord
coordY
fBounds
result
)
{
var
w0
=
level0
.
getWidth
(
)
;
var
w1
=
level1
.
getWidth
(
)
;
var
uBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w0
coord
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
uBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w1
coord
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
minI0
=
Math
.
floor
(
uBounds0
[
0
]
)
;
var
maxI0
=
Math
.
floor
(
uBounds0
[
1
]
)
;
var
minI1
=
Math
.
floor
(
uBounds1
[
0
]
)
;
var
maxI1
=
Math
.
floor
(
uBounds1
[
1
]
)
;
for
(
var
i0
=
minI0
;
i0
<
=
maxI0
;
i0
+
+
)
{
for
(
var
i1
=
minI1
;
i1
<
=
maxI1
;
i1
+
+
)
{
var
c0
=
tcuTexLookupVerifier
.
lookupFloat
(
level0
sampler
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i0
w0
)
coordY
0
)
;
var
c1
=
tcuTexLookupVerifier
.
lookupFloat
(
level1
sampler
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i1
w1
)
coordY
0
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
c0
c1
fBounds
result
)
)
return
true
;
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isNearestMipmapLinearSampleResultValid_CoordAsVec2AndInt
=
function
(
level0
level1
sampler
prec
coord
coordZ
fBounds
result
)
{
var
w0
=
level0
.
getWidth
(
)
;
var
w1
=
level1
.
getWidth
(
)
;
var
h0
=
level0
.
getHeight
(
)
;
var
h1
=
level1
.
getHeight
(
)
;
var
uBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w0
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
uBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w1
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h0
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
vBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h1
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
minI0
=
Math
.
floor
(
uBounds0
[
0
]
)
;
var
maxI0
=
Math
.
floor
(
uBounds0
[
1
]
)
;
var
minI1
=
Math
.
floor
(
uBounds1
[
0
]
)
;
var
maxI1
=
Math
.
floor
(
uBounds1
[
1
]
)
;
var
minJ0
=
Math
.
floor
(
vBounds0
[
0
]
)
;
var
maxJ0
=
Math
.
floor
(
vBounds0
[
1
]
)
;
var
minJ1
=
Math
.
floor
(
vBounds1
[
0
]
)
;
var
maxJ1
=
Math
.
floor
(
vBounds1
[
1
]
)
;
for
(
var
j0
=
minJ0
;
j0
<
=
maxJ0
;
j0
+
+
)
{
for
(
var
i0
=
minI0
;
i0
<
=
maxI0
;
i0
+
+
)
{
for
(
var
j1
=
minJ1
;
j1
<
=
maxJ1
;
j1
+
+
)
{
for
(
var
i1
=
minI1
;
i1
<
=
maxI1
;
i1
+
+
)
{
var
c0
=
tcuTexLookupVerifier
.
lookupFloat
(
level0
sampler
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i0
w0
)
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j0
h0
)
coordZ
)
;
var
c1
=
tcuTexLookupVerifier
.
lookupFloat
(
level1
sampler
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i1
w1
)
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j1
h1
)
coordZ
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
c0
c1
fBounds
result
)
)
return
true
;
}
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isNearestMipmapLinearSampleResultValid_CoordAsVec3
=
function
(
level0
level1
sampler
prec
coord
fBounds
result
)
{
var
w0
=
level0
.
getWidth
(
)
;
var
w1
=
level1
.
getWidth
(
)
;
var
h0
=
level0
.
getHeight
(
)
;
var
h1
=
level1
.
getHeight
(
)
;
var
d0
=
level0
.
getDepth
(
)
;
var
d1
=
level1
.
getDepth
(
)
;
var
uBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w0
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
uBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w1
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h0
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
vBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h1
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
wBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
d0
coord
[
2
]
prec
.
coordBits
[
2
]
prec
.
uvwBits
[
2
]
)
;
var
wBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
d1
coord
[
2
]
prec
.
coordBits
[
2
]
prec
.
uvwBits
[
2
]
)
;
var
minI0
=
Math
.
floor
(
uBounds0
[
0
]
)
;
var
maxI0
=
Math
.
floor
(
uBounds0
[
1
]
)
;
var
minI1
=
Math
.
floor
(
uBounds1
[
0
]
)
;
var
maxI1
=
Math
.
floor
(
uBounds1
[
1
]
)
;
var
minJ0
=
Math
.
floor
(
vBounds0
[
0
]
)
;
var
maxJ0
=
Math
.
floor
(
vBounds0
[
1
]
)
;
var
minJ1
=
Math
.
floor
(
vBounds1
[
0
]
)
;
var
maxJ1
=
Math
.
floor
(
vBounds1
[
1
]
)
;
var
minK0
=
Math
.
floor
(
wBounds0
[
0
]
)
;
var
maxK0
=
Math
.
floor
(
wBounds0
[
1
]
)
;
var
minK1
=
Math
.
floor
(
wBounds1
[
0
]
)
;
var
maxK1
=
Math
.
floor
(
wBounds1
[
1
]
)
;
for
(
var
k0
=
minK0
;
k0
<
=
maxK0
;
k0
+
+
)
{
for
(
var
j0
=
minJ0
;
j0
<
=
maxJ0
;
j0
+
+
)
{
for
(
var
i0
=
minI0
;
i0
<
=
maxI0
;
i0
+
+
)
{
for
(
var
k1
=
minK1
;
k1
<
=
maxK1
;
k1
+
+
)
{
for
(
var
j1
=
minJ1
;
j1
<
=
maxJ1
;
j1
+
+
)
{
for
(
var
i1
=
minI1
;
i1
<
=
maxI1
;
i1
+
+
)
{
var
c0
=
tcuTexLookupVerifier
.
lookupFloat
(
level0
sampler
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i0
w0
)
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j0
h0
)
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k0
d0
)
)
;
var
c1
=
tcuTexLookupVerifier
.
lookupFloat
(
level1
sampler
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i1
w1
)
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j1
h1
)
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k1
d1
)
)
;
if
(
tcuTexLookupVerifier
.
isLinearRangeValid
(
prec
c0
c1
fBounds
result
)
)
return
true
;
}
}
}
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLinearMipmapLinearSampleResultValid_CoordAsVec2AndInt
=
function
(
level0
level1
sampler
prec
coord
coordZ
fBounds
result
)
{
var
w0
=
level0
.
getWidth
(
)
;
var
w1
=
level1
.
getWidth
(
)
;
var
h0
=
level0
.
getHeight
(
)
;
var
h1
=
level1
.
getHeight
(
)
;
var
uBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w0
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
uBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w1
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h0
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
vBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h1
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
minI0
=
Math
.
floor
(
uBounds0
[
0
]
-
0
.
5
)
;
var
maxI0
=
Math
.
floor
(
uBounds0
[
1
]
-
0
.
5
)
;
var
minI1
=
Math
.
floor
(
uBounds1
[
0
]
-
0
.
5
)
;
var
maxI1
=
Math
.
floor
(
uBounds1
[
1
]
-
0
.
5
)
;
var
minJ0
=
Math
.
floor
(
vBounds0
[
0
]
-
0
.
5
)
;
var
maxJ0
=
Math
.
floor
(
vBounds0
[
1
]
-
0
.
5
)
;
var
minJ1
=
Math
.
floor
(
vBounds1
[
0
]
-
0
.
5
)
;
var
maxJ1
=
Math
.
floor
(
vBounds1
[
1
]
-
0
.
5
)
;
var
texClass
=
tcuTexture
.
getTextureChannelClass
(
level0
.
getFormat
(
)
.
type
)
;
var
cSearchStep
=
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForUnorm
(
prec
)
:
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForSnorm
(
prec
)
:
0
;
var
x0
;
var
x1
;
var
y0
;
var
y1
;
for
(
var
j0
=
minJ0
;
j0
<
=
maxJ0
;
j0
+
+
)
{
for
(
var
i0
=
minI0
;
i0
<
=
maxI0
;
i0
+
+
)
{
var
searchStep0
;
x0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i0
w0
)
;
x1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i0
+
1
w0
)
;
y0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j0
h0
)
;
y1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j0
+
1
h0
)
;
var
quad0
=
tcuTexLookupVerifier
.
lookupQuad
(
level0
sampler
x0
x1
y0
y1
coordZ
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep0
=
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad0
)
;
else
searchStep0
=
cSearchStep
;
var
minA0
=
deMath
.
clamp
(
(
uBounds0
[
0
]
-
0
.
5
)
-
i0
0
1
)
;
var
maxA0
=
deMath
.
clamp
(
(
uBounds0
[
1
]
-
0
.
5
)
-
i0
0
1
)
;
var
minB0
=
deMath
.
clamp
(
(
vBounds0
[
0
]
-
0
.
5
)
-
j0
0
1
)
;
var
maxB0
=
deMath
.
clamp
(
(
vBounds0
[
1
]
-
0
.
5
)
-
j0
0
1
)
;
for
(
var
j1
=
minJ1
;
j1
<
=
maxJ1
;
j1
+
+
)
{
for
(
var
i1
=
minI1
;
i1
<
=
maxI1
;
i1
+
+
)
{
var
searchStep1
;
x0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i1
w1
)
;
x1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i1
+
1
w1
)
;
y0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j1
h1
)
;
y1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j1
+
1
h1
)
;
var
quad1
=
tcuTexLookupVerifier
.
lookupQuad
(
level1
sampler
x0
x1
y0
y1
coordZ
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep1
=
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad1
)
;
else
searchStep1
=
cSearchStep
;
var
minA1
=
deMath
.
clamp
(
(
uBounds1
[
0
]
-
0
.
5
)
-
i1
0
1
)
;
var
maxA1
=
deMath
.
clamp
(
(
uBounds1
[
1
]
-
0
.
5
)
-
i1
0
1
)
;
var
minB1
=
deMath
.
clamp
(
(
vBounds1
[
0
]
-
0
.
5
)
-
j1
0
1
)
;
var
maxB1
=
deMath
.
clamp
(
(
vBounds1
[
1
]
-
0
.
5
)
-
j1
0
1
)
;
if
(
tcuTexLookupVerifier
.
is2DTrilinearFilterResultValid
(
prec
quad0
quad1
[
minA0
maxA0
]
[
minB0
maxB0
]
[
minA1
maxA1
]
[
minB1
maxB1
]
fBounds
Math
.
min
(
searchStep0
searchStep1
)
result
)
)
return
true
;
}
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLinearMipmapLinearSampleResultValid_CoordAsVec3
=
function
(
level0
level1
sampler
prec
coord
fBounds
result
)
{
var
w0
=
level0
.
getWidth
(
)
;
var
w1
=
level1
.
getWidth
(
)
;
var
h0
=
level0
.
getHeight
(
)
;
var
h1
=
level1
.
getHeight
(
)
;
var
d0
=
level0
.
getDepth
(
)
;
var
d1
=
level1
.
getDepth
(
)
;
var
uBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w0
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
uBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
w1
coord
[
0
]
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h0
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
vBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
h1
coord
[
1
]
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
wBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
d0
coord
[
2
]
prec
.
coordBits
[
2
]
prec
.
uvwBits
[
2
]
)
;
var
wBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
d1
coord
[
2
]
prec
.
coordBits
[
2
]
prec
.
uvwBits
[
2
]
)
;
var
minI0
=
Math
.
floor
(
uBounds0
[
0
]
-
0
.
5
)
;
var
maxI0
=
Math
.
floor
(
uBounds0
[
1
]
-
0
.
5
)
;
var
minI1
=
Math
.
floor
(
uBounds1
[
0
]
-
0
.
5
)
;
var
maxI1
=
Math
.
floor
(
uBounds1
[
1
]
-
0
.
5
)
;
var
minJ0
=
Math
.
floor
(
vBounds0
[
0
]
-
0
.
5
)
;
var
maxJ0
=
Math
.
floor
(
vBounds0
[
1
]
-
0
.
5
)
;
var
minJ1
=
Math
.
floor
(
vBounds1
[
0
]
-
0
.
5
)
;
var
maxJ1
=
Math
.
floor
(
vBounds1
[
1
]
-
0
.
5
)
;
var
minK0
=
Math
.
floor
(
wBounds0
[
0
]
-
0
.
5
)
;
var
maxK0
=
Math
.
floor
(
wBounds0
[
1
]
-
0
.
5
)
;
var
minK1
=
Math
.
floor
(
wBounds1
[
0
]
-
0
.
5
)
;
var
maxK1
=
Math
.
floor
(
wBounds1
[
1
]
-
0
.
5
)
;
var
texClass
=
tcuTexture
.
getTextureChannelClass
(
level0
.
getFormat
(
)
.
type
)
;
var
cSearchStep
=
texClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForUnorm
(
prec
)
:
texClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForSnorm
(
prec
)
:
0
;
var
x0
;
var
x1
;
var
y0
;
var
y1
;
var
z0
;
var
z1
;
for
(
var
k0
=
minK0
;
k0
<
=
maxK0
;
k0
+
+
)
{
for
(
var
j0
=
minJ0
;
j0
<
=
maxJ0
;
j0
+
+
)
{
for
(
var
i0
=
minI0
;
i0
<
=
maxI0
;
i0
+
+
)
{
var
searchStep0
;
x0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i0
w0
)
;
x1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i0
+
1
w0
)
;
y0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j0
h0
)
;
y1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j0
+
1
h0
)
;
z0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k0
d0
)
;
z1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k0
+
1
d0
)
;
var
quad00
=
tcuTexLookupVerifier
.
lookupQuad
(
level0
sampler
x0
x1
y0
y1
z0
)
;
var
quad01
=
tcuTexLookupVerifier
.
lookupQuad
(
level0
sampler
x0
x1
y0
y1
z1
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep0
=
Math
.
min
(
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad00
)
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad01
)
)
;
else
searchStep0
=
cSearchStep
;
var
minA0
=
deMath
.
clamp
(
(
uBounds0
[
0
]
-
0
.
5
)
-
i0
0
1
)
;
var
maxA0
=
deMath
.
clamp
(
(
uBounds0
[
1
]
-
0
.
5
)
-
i0
0
1
)
;
var
minB0
=
deMath
.
clamp
(
(
vBounds0
[
0
]
-
0
.
5
)
-
j0
0
1
)
;
var
maxB0
=
deMath
.
clamp
(
(
vBounds0
[
1
]
-
0
.
5
)
-
j0
0
1
)
;
var
minC0
=
deMath
.
clamp
(
(
wBounds0
[
0
]
-
0
.
5
)
-
k0
0
1
)
;
var
maxC0
=
deMath
.
clamp
(
(
wBounds0
[
1
]
-
0
.
5
)
-
k0
0
1
)
;
for
(
var
k1
=
minK1
;
k1
<
=
maxK1
;
k1
+
+
)
{
for
(
var
j1
=
minJ1
;
j1
<
=
maxJ1
;
j1
+
+
)
{
for
(
var
i1
=
minI1
;
i1
<
=
maxI1
;
i1
+
+
)
{
var
searchStep1
;
x0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i1
w1
)
;
x1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapS
i1
+
1
w1
)
;
y0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j1
h1
)
;
y1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapT
j1
+
1
h1
)
;
z0
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k1
d1
)
;
z1
=
tcuTexVerifierUtil
.
wrap
(
sampler
.
wrapR
k1
+
1
d1
)
;
var
quad10
=
tcuTexLookupVerifier
.
lookupQuad
(
level1
sampler
x0
x1
y0
y1
z0
)
;
var
quad11
=
tcuTexLookupVerifier
.
lookupQuad
(
level1
sampler
x0
x1
y0
y1
z1
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep1
=
Math
.
min
(
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad10
)
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad11
)
)
;
else
searchStep1
=
cSearchStep
;
var
minA1
=
deMath
.
clamp
(
(
uBounds1
[
0
]
-
0
.
5
)
-
i1
0
1
)
;
var
maxA1
=
deMath
.
clamp
(
(
uBounds1
[
1
]
-
0
.
5
)
-
i1
0
1
)
;
var
minB1
=
deMath
.
clamp
(
(
vBounds1
[
0
]
-
0
.
5
)
-
j1
0
1
)
;
var
maxB1
=
deMath
.
clamp
(
(
vBounds1
[
1
]
-
0
.
5
)
-
j1
0
1
)
;
var
minC1
=
deMath
.
clamp
(
(
wBounds1
[
0
]
-
0
.
5
)
-
k1
0
1
)
;
var
maxC1
=
deMath
.
clamp
(
(
wBounds1
[
1
]
-
0
.
5
)
-
k1
0
1
)
;
if
(
tcuTexLookupVerifier
.
is3DTrilinearFilterResultValid
(
prec
quad00
quad01
quad10
quad11
[
minA0
maxA0
]
[
minB0
maxB0
]
[
minC0
maxC0
]
[
minA1
maxA1
]
[
minB1
maxB1
]
[
minC1
maxC1
]
fBounds
Math
.
min
(
searchStep0
searchStep1
)
result
)
)
return
true
;
}
}
}
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordXYAsNumber
=
function
(
level
sampler
filterMode
prec
coordX
coordY
result
)
{
if
(
filterMode
=
=
tcuTexture
.
FilterMode
.
LINEAR
)
return
tcuTexLookupVerifier
.
isLinearSampleResultValid_CoordXYAsNumber
(
level
sampler
prec
coordX
coordY
result
)
;
else
return
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordXYAsNumber
(
level
sampler
prec
coordX
coordY
result
)
;
}
;
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
=
function
(
level
sampler
filterMode
prec
coord
coordZ
result
)
{
if
(
filterMode
=
=
tcuTexture
.
FilterMode
.
LINEAR
)
return
tcuTexLookupVerifier
.
isLinearSampleResultValid_CoordAsVec2AndInt
(
level
sampler
prec
coord
coordZ
result
)
;
else
return
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordAsVec2AndInt
(
level
sampler
prec
coord
coordZ
result
)
;
}
;
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec3
=
function
(
level
sampler
filterMode
prec
coord
result
)
{
if
(
filterMode
=
=
tcuTexture
.
FilterMode
.
LINEAR
)
return
tcuTexLookupVerifier
.
isLinearSampleResultValid_CoordAsVec3
(
level
sampler
prec
coord
result
)
;
else
return
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordAsVec3
(
level
sampler
prec
coord
result
)
;
}
;
tcuTexLookupVerifier
.
isMipmapLinearSampleResultValid_CoordAsVec2AndInt
=
function
(
level0
level1
sampler
levelFilter
prec
coord
coordZ
fBounds
result
)
{
if
(
levelFilter
=
=
tcuTexture
.
FilterMode
.
LINEAR
)
return
tcuTexLookupVerifier
.
isLinearMipmapLinearSampleResultValid_CoordAsVec2AndInt
(
level0
level1
sampler
prec
coord
coordZ
fBounds
result
)
;
else
return
tcuTexLookupVerifier
.
isNearestMipmapLinearSampleResultValid_CoordAsVec2AndInt
(
level0
level1
sampler
prec
coord
coordZ
fBounds
result
)
;
}
;
tcuTexLookupVerifier
.
isMipmapLinearSampleResultValid_CoordAsVec3
=
function
(
level0
level1
sampler
levelFilter
prec
coord
fBounds
result
)
{
if
(
levelFilter
=
=
tcuTexture
.
FilterMode
.
LINEAR
)
return
tcuTexLookupVerifier
.
isLinearMipmapLinearSampleResultValid_CoordAsVec3
(
level0
level1
sampler
prec
coord
fBounds
result
)
;
else
return
tcuTexLookupVerifier
.
isNearestMipmapLinearSampleResultValid_CoordAsVec3
(
level0
level1
sampler
prec
coord
fBounds
result
)
;
}
;
tcuTexLookupVerifier
.
isLookupResultValid_Texture2DView
=
function
(
texture
sampler
prec
coord
lodBounds
result
)
{
var
minLod
=
lodBounds
[
0
]
;
var
maxLod
=
lodBounds
[
1
]
;
var
canBeMagnified
=
minLod
<
=
sampler
.
lodThreshold
;
var
canBeMinified
=
maxLod
>
sampler
.
lodThreshold
;
assertMsgOptions
(
tcuTexLookupVerifier
.
isSamplerSupported
(
sampler
)
'
Sampler
not
supported
.
'
false
true
)
;
var
minLevel
;
var
maxLevel
;
if
(
canBeMagnified
)
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
0
)
sampler
sampler
.
magFilter
prec
coord
0
result
)
)
return
true
;
if
(
canBeMinified
)
{
var
isNearestMipmap
=
tcuTexVerifierUtil
.
isNearestMipmapFilter
(
sampler
.
minFilter
)
;
var
isLinearMipmap
=
tcuTexVerifierUtil
.
isLinearMipmapFilter
(
sampler
.
minFilter
)
;
var
minTexLevel
=
0
;
var
maxTexLevel
=
texture
.
getNumLevels
(
)
-
1
;
assertMsgOptions
(
minTexLevel
<
=
maxTexLevel
'
minTexLevel
>
maxTexLevel
'
false
true
)
;
if
(
isLinearMipmap
&
&
minTexLevel
<
maxTexLevel
)
{
minLevel
=
deMath
.
clamp
(
Math
.
floor
(
minLod
)
minTexLevel
maxTexLevel
-
1
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
)
minTexLevel
maxTexLevel
-
1
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
level
=
minLevel
;
level
<
=
maxLevel
;
level
+
+
)
{
var
minF
=
deMath
.
clamp
(
minLod
-
level
0
1
)
;
var
maxF
=
deMath
.
clamp
(
maxLod
-
level
0
1
)
;
if
(
tcuTexLookupVerifier
.
isMipmapLinearSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
level
)
texture
.
getLevel
(
level
+
1
)
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
coord
0
[
minF
maxF
]
result
)
)
return
true
;
}
}
else
if
(
isNearestMipmap
)
{
minLevel
=
deMath
.
clamp
(
Math
.
ceil
(
minLod
+
0
.
5
)
-
1
minTexLevel
maxTexLevel
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
+
0
.
5
)
minTexLevel
maxTexLevel
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
level
=
minLevel
;
level
<
=
maxLevel
;
level
+
+
)
{
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
level
)
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
coord
0
result
)
)
return
true
;
}
}
else
{
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
0
)
sampler
sampler
.
minFilter
prec
coord
0
result
)
)
return
true
;
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLookupResultValid_TextureCubeView
=
function
(
texture
sampler
prec
coord
lodBounds
result
)
{
var
numPossibleFaces
=
0
;
assertMsgOptions
(
tcuTexLookupVerifier
.
isSamplerSupported
(
sampler
)
'
Sampler
not
supported
.
'
false
true
)
;
var
possibleFaces
=
tcuTexVerifierUtil
.
getPossibleCubeFaces
(
coord
prec
.
coordBits
)
;
var
minLevel
;
var
maxLevel
;
if
(
!
possibleFaces
)
return
true
;
for
(
var
tryFaceNdx
=
0
;
tryFaceNdx
<
possibleFaces
.
length
;
tryFaceNdx
+
+
)
{
var
faceCoords
=
new
tcuTexture
.
CubeFaceCoords
(
possibleFaces
[
tryFaceNdx
]
tcuTexture
.
projectToFace
(
possibleFaces
[
tryFaceNdx
]
coord
)
)
;
var
minLod
=
lodBounds
[
0
]
;
var
maxLod
=
lodBounds
[
1
]
;
var
canBeMagnified
=
minLod
<
=
sampler
.
lodThreshold
;
var
canBeMinified
=
maxLod
>
sampler
.
lodThreshold
;
var
faces
=
[
]
;
if
(
canBeMagnified
)
{
tcuTexLookupVerifier
.
getCubeLevelFaces
(
texture
0
faces
)
;
if
(
tcuTexLookupVerifier
.
isCubeLevelSampleResultValid
(
faces
sampler
sampler
.
magFilter
prec
faceCoords
result
)
)
return
true
;
}
if
(
canBeMinified
)
{
var
isNearestMipmap
=
tcuTexVerifierUtil
.
isNearestMipmapFilter
(
sampler
.
minFilter
)
;
var
isLinearMipmap
=
tcuTexVerifierUtil
.
isLinearMipmapFilter
(
sampler
.
minFilter
)
;
var
minTexLevel
=
0
;
var
maxTexLevel
=
texture
.
getNumLevels
(
)
-
1
;
assertMsgOptions
(
minTexLevel
<
=
maxTexLevel
'
minTexLevel
>
maxTexLevel
'
false
true
)
;
if
(
isLinearMipmap
&
&
minTexLevel
<
maxTexLevel
)
{
minLevel
=
deMath
.
clamp
(
Math
.
floor
(
minLod
)
minTexLevel
maxTexLevel
-
1
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
)
minTexLevel
maxTexLevel
-
1
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
levelNdx
=
minLevel
;
levelNdx
<
=
maxLevel
;
levelNdx
+
+
)
{
var
minF
=
deMath
.
clamp
(
minLod
-
levelNdx
0
1
)
;
var
maxF
=
deMath
.
clamp
(
maxLod
-
levelNdx
0
1
)
;
var
faces0
=
[
]
;
var
faces1
=
[
]
;
tcuTexLookupVerifier
.
getCubeLevelFaces
(
texture
levelNdx
faces0
)
;
tcuTexLookupVerifier
.
getCubeLevelFaces
(
texture
levelNdx
+
1
faces1
)
;
if
(
tcuTexLookupVerifier
.
isCubeMipmapLinearSampleResultValid
(
faces0
faces1
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
faceCoords
[
minF
maxF
]
result
)
)
return
true
;
}
}
else
if
(
isNearestMipmap
)
{
minLevel
=
deMath
.
clamp
(
Math
.
ceil
(
minLod
+
0
.
5
)
-
1
minTexLevel
maxTexLevel
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
+
0
.
5
)
minTexLevel
maxTexLevel
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
levelNdx
=
minLevel
;
levelNdx
<
=
maxLevel
;
levelNdx
+
+
)
{
tcuTexLookupVerifier
.
getCubeLevelFaces
(
texture
levelNdx
faces
)
;
if
(
tcuTexLookupVerifier
.
isCubeLevelSampleResultValid
(
faces
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
faceCoords
result
)
)
return
true
;
}
}
else
{
tcuTexLookupVerifier
.
getCubeLevelFaces
(
texture
0
faces
)
;
if
(
tcuTexLookupVerifier
.
isCubeLevelSampleResultValid
(
faces
sampler
sampler
.
minFilter
prec
faceCoords
result
)
)
return
true
;
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLookupResultValid_Texture2DArrayView
=
function
(
texture
sampler
prec
coord
lodBounds
result
)
{
var
layerRange
=
tcuTexLookupVerifier
.
computeLayerRange
(
texture
.
getNumLayers
(
)
prec
.
coordBits
[
2
]
coord
[
2
]
)
;
var
coordXY
=
deMath
.
swizzle
(
coord
[
0
1
]
)
;
var
minLod
=
lodBounds
[
0
]
;
var
maxLod
=
lodBounds
[
1
]
;
var
canBeMagnified
=
minLod
<
=
sampler
.
lodThreshold
;
var
canBeMinified
=
maxLod
>
sampler
.
lodThreshold
;
assertMsgOptions
(
tcuTexLookupVerifier
.
isSamplerSupported
(
sampler
)
'
Sampler
not
supported
.
'
false
true
)
;
var
minLevel
;
var
maxLevel
;
for
(
var
layer
=
layerRange
[
0
]
;
layer
<
=
layerRange
[
1
]
;
layer
+
+
)
{
if
(
canBeMagnified
)
{
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
0
)
sampler
sampler
.
magFilter
prec
coordXY
layer
result
)
)
return
true
;
}
if
(
canBeMinified
)
{
var
isNearestMipmap
=
tcuTexVerifierUtil
.
isNearestMipmapFilter
(
sampler
.
minFilter
)
;
var
isLinearMipmap
=
tcuTexVerifierUtil
.
isLinearMipmapFilter
(
sampler
.
minFilter
)
;
var
minTexLevel
=
0
;
var
maxTexLevel
=
texture
.
getNumLevels
(
)
-
1
;
assertMsgOptions
(
minTexLevel
<
=
maxTexLevel
'
minTexLevel
>
maxTexLevel
'
false
true
)
;
if
(
isLinearMipmap
&
&
minTexLevel
<
maxTexLevel
)
{
minLevel
=
deMath
.
clamp
(
Math
.
floor
(
minLod
)
minTexLevel
maxTexLevel
-
1
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
)
minTexLevel
maxTexLevel
-
1
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
level
=
minLevel
;
level
<
=
maxLevel
;
level
+
+
)
{
var
minF
=
deMath
.
clamp
(
minLod
-
level
0
1
)
;
var
maxF
=
deMath
.
clamp
(
maxLod
-
level
0
1
)
;
if
(
tcuTexLookupVerifier
.
isMipmapLinearSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
level
)
texture
.
getLevel
(
level
+
1
)
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
coordXY
layer
[
minF
maxF
]
result
)
)
return
true
;
}
}
else
if
(
isNearestMipmap
)
{
minLevel
=
deMath
.
clamp
(
Math
.
ceil
(
minLod
+
0
.
5
)
-
1
minTexLevel
maxTexLevel
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
+
0
.
5
)
minTexLevel
maxTexLevel
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
level
=
minLevel
;
level
<
=
maxLevel
;
level
+
+
)
{
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
level
)
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
coordXY
layer
result
)
)
return
true
;
}
}
else
{
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
(
texture
.
getLevel
(
0
)
sampler
sampler
.
minFilter
prec
coordXY
layer
result
)
)
return
true
;
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isLookupResultValid
=
function
(
texture
sampler
prec
coord
lodBounds
result
)
{
var
minLod
=
lodBounds
[
0
]
;
var
maxLod
=
lodBounds
[
1
]
;
var
canBeMagnified
=
minLod
<
=
sampler
.
lodThreshold
;
var
canBeMinified
=
maxLod
>
sampler
.
lodThreshold
;
assertMsgOptions
(
tcuTexLookupVerifier
.
isSamplerSupported
(
sampler
)
'
Sampler
not
supported
.
'
false
true
)
;
var
minLevel
;
var
maxLevel
;
if
(
canBeMagnified
)
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec3
(
texture
.
getLevel
(
0
)
sampler
sampler
.
magFilter
prec
coord
result
)
)
return
true
;
if
(
canBeMinified
)
{
var
isNearestMipmap
=
tcuTexVerifierUtil
.
isNearestMipmapFilter
(
sampler
.
minFilter
)
;
var
isLinearMipmap
=
tcuTexVerifierUtil
.
isLinearMipmapFilter
(
sampler
.
minFilter
)
;
var
minTexLevel
=
0
;
var
maxTexLevel
=
texture
.
getNumLevels
(
)
-
1
;
assertMsgOptions
(
minTexLevel
<
=
maxTexLevel
'
minTexLevel
>
maxTexLevel
'
false
true
)
;
if
(
isLinearMipmap
&
&
minTexLevel
<
maxTexLevel
)
{
minLevel
=
deMath
.
clamp
(
Math
.
floor
(
minLod
)
minTexLevel
maxTexLevel
-
1
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
)
minTexLevel
maxTexLevel
-
1
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
level
=
minLevel
;
level
<
=
maxLevel
;
level
+
+
)
{
var
minF
=
deMath
.
clamp
(
minLod
-
level
0
1
)
;
var
maxF
=
deMath
.
clamp
(
maxLod
-
level
0
1
)
;
if
(
tcuTexLookupVerifier
.
isMipmapLinearSampleResultValid_CoordAsVec3
(
texture
.
getLevel
(
level
)
texture
.
getLevel
(
level
+
1
)
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
coord
[
minF
maxF
]
result
)
)
return
true
;
}
}
else
if
(
isNearestMipmap
)
{
minLevel
=
deMath
.
clamp
(
Math
.
ceil
(
minLod
+
0
.
5
)
-
1
minTexLevel
maxTexLevel
)
;
maxLevel
=
deMath
.
clamp
(
Math
.
floor
(
maxLod
+
0
.
5
)
minTexLevel
maxTexLevel
)
;
assertMsgOptions
(
minLevel
<
=
maxLevel
'
minLevel
>
maxLevel
'
false
true
)
;
for
(
var
level
=
minLevel
;
level
<
=
maxLevel
;
level
+
+
)
{
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec3
(
texture
.
getLevel
(
level
)
sampler
tcuTexVerifierUtil
.
getLevelFilter
(
sampler
.
minFilter
)
prec
coord
result
)
)
return
true
;
}
}
else
{
if
(
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec3
(
texture
.
getLevel
(
0
)
sampler
sampler
.
minFilter
prec
coord
result
)
)
return
true
;
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isSeamlessLinearSampleResultValid
=
function
(
faces
sampler
prec
coords
result
)
{
var
size
=
faces
[
coords
.
face
]
.
getWidth
(
)
;
var
uBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
size
coords
.
s
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
size
coords
.
t
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
minI
=
Math
.
floor
(
uBounds
[
0
]
-
0
.
5
)
;
var
maxI
=
Math
.
floor
(
uBounds
[
1
]
-
0
.
5
)
;
var
minJ
=
Math
.
floor
(
vBounds
[
0
]
-
0
.
5
)
;
var
maxJ
=
Math
.
floor
(
vBounds
[
1
]
-
0
.
5
)
;
var
texClass
=
tcuTexture
.
getTextureChannelClass
(
faces
[
coords
.
face
]
.
getFormat
(
)
.
type
)
;
var
searchStep
=
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForUnorm
(
prec
)
:
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForSnorm
(
prec
)
:
0
;
for
(
var
j
=
minJ
;
j
<
=
maxJ
;
j
+
+
)
{
for
(
var
i
=
minI
;
i
<
=
maxI
;
i
+
+
)
{
var
c00
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i
+
0
j
+
0
]
)
size
)
;
var
c10
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i
+
1
j
+
0
]
)
size
)
;
var
c01
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i
+
0
j
+
1
]
)
size
)
;
var
c11
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i
+
1
j
+
1
]
)
size
)
;
if
(
c00
=
=
null
|
|
c01
=
=
null
|
|
c10
=
=
null
|
|
c11
=
=
null
|
|
c00
.
face
=
=
null
|
|
c01
.
face
=
=
null
|
|
c10
.
face
=
=
null
|
|
c11
.
face
=
=
null
)
return
true
;
var
minA
=
deMath
.
clamp
(
(
uBounds
[
0
]
-
0
.
5
)
-
i
0
1
)
;
var
maxA
=
deMath
.
clamp
(
(
uBounds
[
1
]
-
0
.
5
)
-
i
0
1
)
;
var
minB
=
deMath
.
clamp
(
(
vBounds
[
0
]
-
0
.
5
)
-
j
0
1
)
;
var
maxB
=
deMath
.
clamp
(
(
vBounds
[
1
]
-
0
.
5
)
-
j
0
1
)
;
var
quad
=
new
tcuTexLookupVerifier
.
ColorQuad
(
[
]
[
]
[
]
[
]
)
;
quad
.
p00
=
tcuTexLookupVerifier
.
lookupFloat
(
faces
[
c00
.
face
]
sampler
c00
.
s
c00
.
t
0
)
;
quad
.
p10
=
tcuTexLookupVerifier
.
lookupFloat
(
faces
[
c10
.
face
]
sampler
c10
.
s
c10
.
t
0
)
;
quad
.
p01
=
tcuTexLookupVerifier
.
lookupFloat
(
faces
[
c01
.
face
]
sampler
c01
.
s
c01
.
t
0
)
;
quad
.
p11
=
tcuTexLookupVerifier
.
lookupFloat
(
faces
[
c11
.
face
]
sampler
c11
.
s
c11
.
t
0
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep
=
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad
)
;
if
(
tcuTexLookupVerifier
.
isBilinearRangeValid
(
prec
quad
[
minA
maxA
]
[
minB
maxB
]
searchStep
result
)
)
return
true
;
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isSeamplessLinearMipmapLinearSampleResultValid
=
function
(
faces0
faces1
sampler
prec
coords
fBounds
result
)
{
var
size0
=
faces0
[
coords
.
face
]
.
getWidth
(
)
;
var
size1
=
faces1
[
coords
.
face
]
.
getWidth
(
)
;
var
uBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
size0
coords
.
s
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
uBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
size1
coords
.
s
prec
.
coordBits
[
0
]
prec
.
uvwBits
[
0
]
)
;
var
vBounds0
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
size0
coords
.
t
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
vBounds1
=
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
(
sampler
.
normalizedCoords
size1
coords
.
t
prec
.
coordBits
[
1
]
prec
.
uvwBits
[
1
]
)
;
var
minI0
=
Math
.
floor
(
uBounds0
[
0
]
-
0
.
5
)
;
var
maxI0
=
Math
.
floor
(
uBounds0
[
1
]
-
0
.
5
)
;
var
minI1
=
Math
.
floor
(
uBounds1
[
0
]
-
0
.
5
)
;
var
maxI1
=
Math
.
floor
(
uBounds1
[
1
]
-
0
.
5
)
;
var
minJ0
=
Math
.
floor
(
vBounds0
[
0
]
-
0
.
5
)
;
var
maxJ0
=
Math
.
floor
(
vBounds0
[
1
]
-
0
.
5
)
;
var
minJ1
=
Math
.
floor
(
vBounds1
[
0
]
-
0
.
5
)
;
var
maxJ1
=
Math
.
floor
(
vBounds1
[
1
]
-
0
.
5
)
;
var
texClass
=
tcuTexture
.
getTextureChannelClass
(
faces0
[
coords
.
face
]
.
getFormat
(
)
.
type
)
;
var
cSearchStep
=
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
UNSIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForUnorm
(
prec
)
:
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
SIGNED_FIXED_POINT
)
?
tcuTexLookupVerifier
.
computeBilinearSearchStepForSnorm
(
prec
)
:
0
;
var
c00
;
var
c10
;
var
c01
;
var
c11
;
for
(
var
j0
=
minJ0
;
j0
<
=
maxJ0
;
j0
+
+
)
{
for
(
var
i0
=
minI0
;
i0
<
=
maxI0
;
i0
+
+
)
{
var
quad0
=
new
tcuTexLookupVerifier
.
ColorQuad
(
[
]
[
]
[
]
[
]
)
;
var
searchStep0
;
c00
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i0
+
0
j0
+
0
]
)
size0
)
;
c10
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i0
+
1
j0
+
0
]
)
size0
)
;
c01
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i0
+
0
j0
+
1
]
)
size0
)
;
c11
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i0
+
1
j0
+
1
]
)
size0
)
;
if
(
c00
=
=
null
|
|
c01
=
=
null
|
|
c10
=
=
null
|
|
c11
=
=
null
|
|
c00
.
face
=
=
null
|
|
c01
.
face
=
=
null
|
|
c10
.
face
=
=
null
|
|
c11
.
face
=
=
null
)
return
true
;
quad0
.
p00
=
tcuTexLookupVerifier
.
lookupFloat
(
faces0
[
c00
.
face
]
sampler
c00
.
s
c00
.
t
0
)
;
quad0
.
p10
=
tcuTexLookupVerifier
.
lookupFloat
(
faces0
[
c10
.
face
]
sampler
c10
.
s
c10
.
t
0
)
;
quad0
.
p01
=
tcuTexLookupVerifier
.
lookupFloat
(
faces0
[
c01
.
face
]
sampler
c01
.
s
c01
.
t
0
)
;
quad0
.
p11
=
tcuTexLookupVerifier
.
lookupFloat
(
faces0
[
c11
.
face
]
sampler
c11
.
s
c11
.
t
0
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep0
=
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad0
)
;
else
searchStep0
=
cSearchStep
;
var
minA0
=
deMath
.
clamp
(
(
uBounds0
[
0
]
-
0
.
5
)
-
i0
0
1
)
;
var
maxA0
=
deMath
.
clamp
(
(
uBounds0
[
1
]
-
0
.
5
)
-
i0
0
1
)
;
var
minB0
=
deMath
.
clamp
(
(
vBounds0
[
0
]
-
0
.
5
)
-
j0
0
1
)
;
var
maxB0
=
deMath
.
clamp
(
(
vBounds0
[
1
]
-
0
.
5
)
-
j0
0
1
)
;
for
(
var
j1
=
minJ1
;
j1
<
=
maxJ1
;
j1
+
+
)
{
for
(
var
i1
=
minI1
;
i1
<
=
maxI1
;
i1
+
+
)
{
var
quad1
=
new
tcuTexLookupVerifier
.
ColorQuad
(
[
]
[
]
[
]
[
]
)
;
var
searchStep1
;
c00
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i1
+
0
j1
+
0
]
)
size1
)
;
c10
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i1
+
1
j1
+
0
]
)
size1
)
;
c01
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i1
+
0
j1
+
1
]
)
size1
)
;
c11
=
tcuTexture
.
remapCubeEdgeCoords
(
new
tcuTexture
.
CubeFaceCoords
(
coords
.
face
[
i1
+
1
j1
+
1
]
)
size1
)
;
if
(
c00
=
=
null
|
|
c01
=
=
null
|
|
c10
=
=
null
|
|
c11
=
=
null
|
|
c00
.
face
=
=
null
|
|
c01
.
face
=
=
null
|
|
c10
.
face
=
=
null
|
|
c11
.
face
=
=
null
)
return
true
;
quad1
.
p00
=
tcuTexLookupVerifier
.
lookupFloat
(
faces1
[
c00
.
face
]
sampler
c00
.
s
c00
.
t
0
)
;
quad1
.
p10
=
tcuTexLookupVerifier
.
lookupFloat
(
faces1
[
c10
.
face
]
sampler
c10
.
s
c10
.
t
0
)
;
quad1
.
p01
=
tcuTexLookupVerifier
.
lookupFloat
(
faces1
[
c01
.
face
]
sampler
c01
.
s
c01
.
t
0
)
;
quad1
.
p11
=
tcuTexLookupVerifier
.
lookupFloat
(
faces1
[
c11
.
face
]
sampler
c11
.
s
c11
.
t
0
)
;
if
(
texClass
=
=
tcuTexture
.
TextureChannelClass
.
FLOATING_POINT
)
searchStep1
=
tcuTexLookupVerifier
.
computeBilinearSearchStepFromFloatQuad
(
prec
quad1
)
;
else
searchStep1
=
cSearchStep
;
var
minA1
=
deMath
.
clamp
(
(
uBounds1
[
0
]
-
0
.
5
)
-
i1
0
1
)
;
var
maxA1
=
deMath
.
clamp
(
(
uBounds1
[
1
]
-
0
.
5
)
-
i1
0
1
)
;
var
minB1
=
deMath
.
clamp
(
(
vBounds1
[
0
]
-
0
.
5
)
-
j1
0
1
)
;
var
maxB1
=
deMath
.
clamp
(
(
vBounds1
[
1
]
-
0
.
5
)
-
j1
0
1
)
;
if
(
tcuTexLookupVerifier
.
is2DTrilinearFilterResultValid
(
prec
quad0
quad1
[
minA0
maxA0
]
[
minB0
maxB0
]
[
minA1
maxA1
]
[
minB1
maxB1
]
fBounds
Math
.
min
(
searchStep0
searchStep1
)
result
)
)
return
true
;
}
}
}
}
return
false
;
}
;
tcuTexLookupVerifier
.
isCubeLevelSampleResultValid
=
function
(
level
sampler
filterMode
prec
coords
result
)
{
if
(
filterMode
=
=
tcuTexture
.
FilterMode
.
LINEAR
)
{
if
(
sampler
.
seamlessCubeMap
)
return
tcuTexLookupVerifier
.
isSeamlessLinearSampleResultValid
(
level
sampler
prec
coords
result
)
;
else
return
tcuTexLookupVerifier
.
isLinearSampleResultValid_CoordAsVec2AndInt
(
level
[
coords
.
face
]
sampler
prec
[
coords
.
s
coords
.
t
]
0
result
)
;
}
else
return
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordAsVec2AndInt
(
level
[
coords
.
face
]
sampler
prec
[
coords
.
s
coords
.
t
]
0
result
)
;
}
;
tcuTexLookupVerifier
.
isCubeMipmapLinearSampleResultValid
=
function
(
faces0
faces1
sampler
levelFilter
prec
coords
fBounds
result
)
{
if
(
levelFilter
=
=
tcuTexture
.
FilterMode
.
LINEAR
)
{
if
(
sampler
.
seamlessCubeMap
)
return
tcuTexLookupVerifier
.
isSeamplessLinearMipmapLinearSampleResultValid
(
faces0
faces1
sampler
prec
coords
fBounds
result
)
;
else
return
tcuTexLookupVerifier
.
isLinearMipmapLinearSampleResultValid_CoordAsVec2AndInt
(
faces0
[
coords
.
face
]
faces1
[
coords
.
face
]
sampler
prec
[
coords
.
s
coords
.
t
]
0
fBounds
result
)
;
}
else
return
tcuTexLookupVerifier
.
isNearestMipmapLinearSampleResultValid_CoordAsVec2AndInt
(
faces0
[
coords
.
face
]
faces1
[
coords
.
face
]
sampler
prec
[
coords
.
s
coords
.
t
]
0
fBounds
result
)
;
}
;
tcuTexLookupVerifier
.
getCubeLevelFaces
=
function
(
texture
levelNdx
out
)
{
for
(
var
faceNdx
=
0
;
faceNdx
<
6
;
faceNdx
+
+
)
out
[
faceNdx
]
=
texture
.
getLevelFace
(
levelNdx
(
faceNdx
)
)
;
}
;
tcuTexLookupVerifier
.
computeLayerRange
=
function
(
numLayers
numCoordBits
layerCoord
)
{
var
err
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
layerCoord
numCoordBits
)
;
var
minL
=
Math
.
floor
(
layerCoord
-
err
+
0
.
5
)
;
var
maxL
=
Math
.
ceil
(
layerCoord
+
err
+
0
.
5
)
-
1
;
assertMsgOptions
(
minL
<
=
maxL
'
minL
>
maxL
'
false
true
)
;
return
[
deMath
.
clamp
(
minL
0
numLayers
-
1
)
deMath
.
clamp
(
maxL
0
numLayers
-
1
)
]
;
}
;
tcuTexLookupVerifier
.
computeFixedPointThreshold
=
function
(
bits
)
{
return
tcuTexVerifierUtil
.
computeFixedPointError_Vector
(
bits
)
;
}
;
tcuTexLookupVerifier
.
computeFloatingPointThreshold
=
function
(
bits
value
)
{
return
tcuTexVerifierUtil
.
computeFloatingPointError_Vector
(
value
bits
)
;
}
;
tcuTexLookupVerifier
.
computeLodBoundsFromDerivates
=
function
(
dudx
dvdx
dwdx
dudy
dvdy
dwdy
prec
)
{
var
mu
=
Math
.
max
(
Math
.
abs
(
dudx
)
Math
.
abs
(
dudy
)
)
;
var
mv
=
Math
.
max
(
Math
.
abs
(
dvdx
)
Math
.
abs
(
dvdy
)
)
;
var
mw
=
Math
.
max
(
Math
.
abs
(
dwdx
)
Math
.
abs
(
dwdy
)
)
;
var
minDBound
=
Math
.
max
(
Math
.
max
(
mu
mv
)
mw
)
;
var
maxDBound
=
mu
+
mv
+
mw
;
var
minDErr
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
minDBound
prec
.
derivateBits
)
;
var
maxDErr
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
maxDBound
prec
.
derivateBits
)
;
var
minLod
=
Math
.
log2
(
minDBound
-
minDErr
)
;
var
maxLod
=
Math
.
log2
(
maxDBound
+
maxDErr
)
;
var
lodErr
=
tcuTexVerifierUtil
.
computeFixedPointError
(
prec
.
lodBits
)
;
assertMsgOptions
(
minLod
<
=
maxLod
'
Error
:
minLod
>
maxLod
'
false
true
)
;
return
[
minLod
-
lodErr
maxLod
+
lodErr
]
;
}
;
tcuTexLookupVerifier
.
computeLodBoundsFromDerivatesUV
=
function
(
dudx
dvdx
dudy
dvdy
prec
)
{
return
tcuTexLookupVerifier
.
computeLodBoundsFromDerivates
(
dudx
dvdx
0
dudy
dvdy
0
prec
)
;
}
;
tcuTexLookupVerifier
.
computeLodBoundsFromDerivatesU
=
function
(
dudx
dudy
prec
)
{
return
tcuTexLookupVerifier
.
computeLodBoundsFromDerivates
(
dudx
0
0
dudy
0
0
prec
)
;
}
;
tcuTexLookupVerifier
.
computeCubeLodBoundsFromDerivates
=
function
(
coord
coordDx
coordDy
faceSize
prec
)
{
var
allowBrokenEdgeDerivate
=
false
;
var
face
=
tcuTexture
.
selectCubeFace
(
coord
)
;
var
maNdx
=
0
;
var
sNdx
=
0
;
var
tNdx
=
0
;
switch
(
face
)
{
case
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_X
:
case
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_X
:
maNdx
=
0
;
sNdx
=
2
;
tNdx
=
1
;
break
;
case
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_Y
:
case
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_Y
:
maNdx
=
1
;
sNdx
=
0
;
tNdx
=
2
;
break
;
case
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_Z
:
case
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_Z
:
maNdx
=
2
;
sNdx
=
0
;
tNdx
=
1
;
break
;
default
:
throw
new
Error
(
'
Invalid
CubeFace
.
'
)
;
}
var
sc
=
coord
[
sNdx
]
;
var
tc
=
coord
[
tNdx
]
;
var
ma
=
Math
.
abs
(
coord
[
maNdx
]
)
;
var
scdx
=
coordDx
[
sNdx
]
;
var
tcdx
=
coordDx
[
tNdx
]
;
var
madx
=
Math
.
abs
(
coordDx
[
maNdx
]
)
;
var
scdy
=
coordDy
[
sNdx
]
;
var
tcdy
=
coordDy
[
tNdx
]
;
var
mady
=
Math
.
abs
(
coordDy
[
maNdx
]
)
;
var
dudx
=
faceSize
*
0
.
5
*
(
scdx
*
ma
-
sc
*
madx
)
/
(
ma
*
ma
)
;
var
dvdx
=
faceSize
*
0
.
5
*
(
tcdx
*
ma
-
tc
*
madx
)
/
(
ma
*
ma
)
;
var
dudy
=
faceSize
*
0
.
5
*
(
scdy
*
ma
-
sc
*
mady
)
/
(
ma
*
ma
)
;
var
dvdy
=
faceSize
*
0
.
5
*
(
tcdy
*
ma
-
tc
*
mady
)
/
(
ma
*
ma
)
;
var
bounds
=
tcuTexLookupVerifier
.
computeLodBoundsFromDerivatesUV
(
dudx
dvdx
dudy
dvdy
prec
)
;
if
(
allowBrokenEdgeDerivate
)
{
var
dxErr
=
tcuTexVerifierUtil
.
computeFloatingPointError_Vector
(
coordDx
[
prec
.
derivateBits
prec
.
derivateBits
prec
.
derivateBits
]
)
;
var
dyErr
=
tcuTexVerifierUtil
.
computeFloatingPointError_Vector
(
coordDy
[
prec
.
derivateBits
prec
.
derivateBits
prec
.
derivateBits
]
)
;
var
xoffs
=
deMath
.
add
(
deMath
.
abs
(
coordDx
)
dxErr
)
;
var
yoffs
=
deMath
.
add
(
deMath
.
abs
(
coordDy
)
dyErr
)
;
if
(
tcuTexture
.
selectCubeFace
(
deMath
.
add
(
coord
xoffs
)
)
!
=
face
|
|
tcuTexture
.
selectCubeFace
(
deMath
.
subtract
(
coord
xoffs
)
)
!
=
face
|
|
tcuTexture
.
selectCubeFace
(
deMath
.
add
(
coord
yoffs
)
)
!
=
face
|
|
tcuTexture
.
selectCubeFace
(
deMath
.
subtract
(
coord
yoffs
)
)
!
=
face
)
{
return
[
bounds
[
0
]
1000
]
;
}
}
return
bounds
;
}
;
tcuTexLookupVerifier
.
clampLodBounds
=
function
(
lodBounds
lodMinMax
prec
)
{
var
lodErr
=
tcuTexVerifierUtil
.
computeFixedPointError
(
prec
.
lodBits
)
;
var
a
=
lodMinMax
[
0
]
;
var
b
=
lodMinMax
[
1
]
;
return
[
deMath
.
clamp
(
lodBounds
[
0
]
a
-
lodErr
b
-
lodErr
)
deMath
.
clamp
(
lodBounds
[
1
]
a
+
lodErr
b
+
lodErr
)
]
;
}
;
tcuTexLookupVerifier
.
isLevel2DLookupResultValid
=
function
(
access
sampler
scaleMode
prec
coord
coordZ
result
)
{
var
filterMode
=
(
scaleMode
=
=
tcuTexLookupVerifier
.
TexLookupScaleMode
.
MAGNIFY
)
?
sampler
.
magFilter
:
sampler
.
minFilter
;
return
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec2AndInt
(
access
sampler
filterMode
prec
coord
coordZ
result
)
;
}
;
tcuTexLookupVerifier
.
isLevel2DLookupResultValid_Int
=
function
(
access
sampler
scaleMode
prec
coord
coordZ
result
)
{
assertMsgOptions
(
sampler
.
minFilter
=
=
tcuTexture
.
FilterMode
.
NEAREST
&
&
sampler
.
magFilter
=
=
tcuTexture
.
FilterMode
.
NEAREST
'
minFilter
and
magFilter
must
be
NEAREST
'
false
true
)
;
return
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordAsVec2AndInt
(
access
sampler
prec
coord
coordZ
result
)
;
}
;
tcuTexLookupVerifier
.
isLevel3DLookupResultValid
=
function
(
access
sampler
scaleMode
prec
coord
result
)
{
var
filterMode
=
(
scaleMode
=
=
tcuTexLookupVerifier
.
TexLookupScaleMode
.
MAGNIFY
)
?
sampler
.
magFilter
:
sampler
.
minFilter
;
return
tcuTexLookupVerifier
.
isLevelSampleResultValid_CoordAsVec3
(
access
sampler
filterMode
prec
coord
result
)
;
}
;
tcuTexLookupVerifier
.
isLevel3DLookupResultValid_Int
=
function
(
access
sampler
scaleMode
prec
coord
result
)
{
assertMsgOptions
(
sampler
.
minFilter
=
=
tcuTexture
.
FilterMode
.
NEAREST
&
&
sampler
.
magFilter
=
=
tcuTexture
.
FilterMode
.
NEAREST
'
minFilter
and
magFilter
must
be
NEAREST
'
false
true
)
;
return
tcuTexLookupVerifier
.
isNearestSampleResultValid_CoordAsVec3
(
access
sampler
prec
coord
result
)
;
}
;
}
)
;
