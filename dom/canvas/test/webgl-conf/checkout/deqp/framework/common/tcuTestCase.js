'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuTestCase
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSkipList
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuTestCase
=
framework
.
common
.
tcuTestCase
;
var
tcuSkipList
=
framework
.
common
.
tcuSkipList
;
tcuTestCase
.
getQueryVal
=
function
(
key
)
{
const
queryVars
=
window
.
location
.
search
.
substring
(
1
)
.
split
(
'
&
'
)
;
for
(
let
kv
of
queryVars
)
{
kv
=
kv
.
split
(
'
=
'
)
;
if
(
decodeURIComponent
(
kv
[
0
]
)
=
=
=
key
)
return
decodeURIComponent
(
kv
[
1
]
)
;
}
return
null
;
}
;
tcuTestCase
.
isQuickMode
=
(
)
=
>
tcuTestCase
.
getQueryVal
(
'
quick
'
)
=
=
=
'
1
'
;
tcuTestCase
.
isQuietMode
=
(
)
=
>
tcuTestCase
.
getQueryVal
(
'
quiet
'
)
=
=
=
'
1
'
;
tcuTestCase
.
getFilter
=
(
)
=
>
tcuTestCase
.
getQueryVal
(
'
filter
'
)
;
tcuTestCase
.
IterateResult
=
{
STOP
:
0
CONTINUE
:
1
}
;
tcuTestCase
.
Runner
=
function
(
)
{
this
.
currentTest
=
null
;
this
.
nextTest
=
null
;
this
.
testCases
=
null
;
this
.
filter
=
tcuTestCase
.
getFilter
(
)
;
}
;
tcuTestCase
.
Runner
.
prototype
.
setRoot
=
function
(
root
)
{
this
.
currentTest
=
null
;
this
.
testCases
=
root
;
}
;
tcuTestCase
.
Runner
.
prototype
.
setRange
=
function
(
range
)
{
this
.
range
=
range
;
}
;
tcuTestCase
.
Runner
.
prototype
.
next
=
function
(
)
{
if
(
!
this
.
currentTest
)
{
this
.
currentTest
=
this
.
testCases
;
if
(
this
.
currentTest
.
isExecutable
(
)
)
return
this
.
currentTest
;
}
if
(
tcuTestCase
.
lastResult
=
=
tcuTestCase
.
IterateResult
.
STOP
)
{
do
{
if
(
this
.
range
)
this
.
currentTest
=
this
.
currentTest
.
nextInRange
(
this
.
filter
this
.
range
)
;
else
this
.
currentTest
=
this
.
currentTest
.
next
(
this
.
filter
)
;
}
while
(
this
.
currentTest
&
&
!
this
.
currentTest
.
isExecutable
(
)
)
;
}
return
this
.
currentTest
;
}
;
tcuTestCase
.
Runner
.
prototype
.
runCallback
=
function
(
callback
)
{
setTimeout
(
function
(
)
{
callback
(
)
;
}
.
bind
(
this
)
0
)
;
}
;
tcuTestCase
.
Runner
.
prototype
.
terminate
=
function
(
)
{
finishTest
(
)
;
if
(
!
tcuTestCase
.
isQuietMode
(
)
)
{
console
.
log
(
'
finishTest
(
)
after
(
in
ms
)
:
'
performance
.
now
(
)
)
;
}
}
;
tcuTestCase
.
runner
=
new
tcuTestCase
.
Runner
(
)
;
tcuTestCase
.
lastResult
=
tcuTestCase
.
IterateResult
.
STOP
;
tcuTestCase
.
DeqpTest
=
function
(
name
description
spec
)
{
this
.
name
=
name
|
|
'
'
;
this
.
description
=
description
|
|
'
'
;
this
.
spec
=
spec
;
this
.
currentTestNdx
=
0
;
this
.
parentTest
=
null
;
this
.
childrenTests
=
[
]
;
this
.
executeAlways
=
false
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
init
=
function
(
)
{
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
deinit
=
function
(
)
{
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
iterate
=
function
(
)
{
return
tcuTestCase
.
IterateResult
.
STOP
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
isExecutable
=
function
(
)
{
return
this
.
childrenTests
.
length
=
=
0
|
|
this
.
executeAlways
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
isLeaf
=
function
(
)
{
return
this
.
childrenTests
.
length
=
=
0
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
makeExecutable
=
function
(
)
{
this
.
executeAlways
=
true
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
addChild
=
function
(
test
)
{
test
.
parentTest
=
this
;
this
.
childrenTests
.
push
(
test
)
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
setChildren
=
function
(
tests
)
{
for
(
var
test
in
tests
)
tests
[
test
]
.
parentTest
=
this
;
this
.
childrenTests
=
tests
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
next
=
function
(
pattern
)
{
return
this
.
_nextHonoringSkipList
(
pattern
)
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
_nextHonoringSkipList
=
function
(
pattern
)
{
var
tryAgain
=
false
;
var
test
=
null
;
do
{
tryAgain
=
false
;
test
=
this
.
_nextIgnoringSkipList
(
pattern
)
;
if
(
test
!
=
null
)
{
var
fullTestName
=
test
.
fullName
(
)
;
var
skipDisposition
=
tcuSkipList
.
getSkipStatus
(
fullTestName
)
;
if
(
skipDisposition
.
skip
)
{
tryAgain
=
true
;
setCurrentTestName
(
fullTestName
)
;
checkMessage
(
false
'
Skipping
test
due
to
tcuSkipList
:
'
+
fullTestName
)
;
}
}
}
while
(
tryAgain
)
;
return
test
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
_nextIgnoringSkipList
=
function
(
pattern
)
{
if
(
pattern
)
return
this
.
_findIgnoringSkipList
(
pattern
)
;
var
test
=
null
;
if
(
this
.
currentTestNdx
<
this
.
childrenTests
.
length
)
{
test
=
this
.
childrenTests
[
this
.
currentTestNdx
]
;
this
.
currentTestNdx
+
+
;
}
if
(
test
=
=
null
&
&
this
.
parentTest
!
=
null
)
{
test
=
this
.
parentTest
.
_nextIgnoringSkipList
(
null
)
;
}
return
test
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
nextInRange
=
function
(
pattern
range
)
{
while
(
true
)
{
var
test
=
this
.
_nextHonoringSkipList
(
pattern
)
;
if
(
!
test
)
return
null
;
var
topLevelId
=
tcuTestCase
.
runner
.
testCases
.
currentTestNdx
-
1
;
if
(
topLevelId
>
=
range
[
0
]
&
&
topLevelId
<
range
[
1
]
)
return
test
;
}
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
fullName
=
function
(
)
{
if
(
this
.
parentTest
)
{
var
parentName
=
this
.
parentTest
.
fullName
(
)
;
if
(
parentName
)
return
parentName
+
'
.
'
+
this
.
name
;
}
return
this
.
name
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
getDescription
=
function
(
)
{
return
this
.
description
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
find
=
function
(
pattern
)
{
return
this
.
_findHonoringSkipList
(
pattern
)
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
_findHonoringSkipList
=
function
(
pattern
)
{
var
tryAgain
=
false
;
var
test
=
null
;
do
{
tryAgain
=
false
;
test
=
this
.
_findIgnoringSkipList
(
pattern
)
;
if
(
test
!
=
null
)
{
var
fullTestName
=
test
.
fullName
(
)
;
var
skipDisposition
=
tcuSkipList
.
getSkipStatus
(
fullTestName
)
;
if
(
skipDisposition
.
skip
)
{
tryAgain
=
true
;
checkMessage
(
false
'
Skipping
test
due
to
tcuSkipList
:
'
+
fullTestName
)
;
}
}
}
while
(
tryAgain
)
;
return
test
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
_findIgnoringSkipList
=
function
(
pattern
)
{
var
test
=
this
;
while
(
true
)
{
test
=
test
.
_nextIgnoringSkipList
(
null
)
;
if
(
!
test
)
break
;
if
(
test
.
fullName
(
)
.
match
(
pattern
)
|
|
test
.
executeAlways
)
break
;
}
return
test
;
}
;
tcuTestCase
.
DeqpTest
.
prototype
.
reset
=
function
(
)
{
this
.
currentTestNdx
=
0
;
for
(
var
i
=
0
;
i
<
this
.
childrenTests
.
length
;
i
+
+
)
this
.
childrenTests
[
i
]
.
reset
(
)
;
}
;
tcuTestCase
.
newTest
=
function
(
name
description
spec
)
{
var
test
=
new
tcuTestCase
.
DeqpTest
(
name
description
spec
)
;
return
test
;
}
;
tcuTestCase
.
newExecutableTest
=
function
(
name
description
spec
)
{
var
test
=
tcuTestCase
.
newTest
(
name
description
spec
)
;
test
.
makeExecutable
(
)
;
return
test
;
}
;
tcuTestCase
.
runTestCases
=
function
(
)
{
var
state
=
tcuTestCase
.
runner
;
if
(
state
.
next
(
)
)
{
try
{
var
fullTestName
=
state
.
currentTest
.
fullName
(
)
;
var
inited
=
true
;
if
(
tcuTestCase
.
lastResult
=
=
tcuTestCase
.
IterateResult
.
STOP
)
{
setCurrentTestName
(
fullTestName
)
;
bufferedLogToConsole
(
'
Init
testcase
:
'
+
fullTestName
)
;
inited
=
state
.
currentTest
.
init
(
)
;
inited
=
inited
=
=
=
undefined
?
true
:
inited
;
if
(
state
.
currentTest
.
isLeaf
(
)
&
&
inited
)
debug
(
'
<
hr
/
>
<
br
/
>
Start
testcase
:
'
+
fullTestName
)
;
}
if
(
inited
)
{
const
debug
=
tcuTestCase
.
_debug
=
tcuTestCase
.
_debug
|
|
(
(
)
=
>
{
function
LapStopwatch
(
)
{
this
.
lap
=
function
(
)
{
const
now
=
performance
.
now
(
)
;
const
ret
=
now
-
this
.
last
;
this
.
last
=
now
;
return
ret
;
}
;
this
.
lap
(
)
;
}
return
{
stopwatch
:
new
LapStopwatch
(
)
testDoneCount
:
0
}
;
}
)
(
)
;
const
overheadDur
=
debug
.
stopwatch
.
lap
(
)
;
tcuTestCase
.
lastResult
=
state
.
currentTest
.
iterate
(
)
;
const
testDur
=
debug
.
stopwatch
.
lap
(
)
;
debug
.
testDoneCount
+
=
1
;
console
.
log
(
[
test
{
debug
.
testDoneCount
}
]
Ran
in
{
testDur
}
ms
(
+
{
overheadDur
}
ms
overhead
)
)
;
}
else
{
tcuTestCase
.
lastResult
=
tcuTestCase
.
IterateResult
.
STOP
;
}
if
(
tcuTestCase
.
lastResult
=
=
tcuTestCase
.
IterateResult
.
STOP
)
state
.
currentTest
.
deinit
(
)
;
}
catch
(
err
)
{
if
(
!
(
err
instanceof
TestFailedException
)
)
{
tcuTestCase
.
lastResult
=
tcuTestCase
.
IterateResult
.
STOP
;
try
{
if
(
tcuTestCase
.
lastResult
=
=
tcuTestCase
.
IterateResult
.
STOP
)
state
.
currentTest
.
deinit
(
)
;
}
catch
(
cerr
)
{
bufferedLogToConsole
(
'
Error
while
cleaning
up
test
:
'
+
cerr
)
;
}
var
msg
=
err
;
if
(
err
.
message
)
msg
=
err
.
message
;
testFailedOptions
(
msg
false
)
;
}
bufferedLogToConsole
(
err
)
;
}
tcuTestCase
.
runner
.
runCallback
(
tcuTestCase
.
runTestCases
)
;
}
else
{
tcuTestCase
.
runner
.
terminate
(
)
;
}
}
;
}
)
;
