'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
tcuSurface
.
Surface
=
function
(
width
height
)
{
width
=
width
|
|
0
;
height
=
height
|
|
0
;
this
.
setSize
(
width
height
)
;
}
;
tcuSurface
.
Surface
.
prototype
.
setSize
=
function
(
width
height
)
{
this
.
m_width
=
width
;
this
.
m_height
=
height
;
if
(
width
*
height
>
0
)
{
this
.
m_data
=
new
ArrayBuffer
(
4
*
width
*
height
)
;
this
.
m_pixels
=
new
Uint8Array
(
this
.
m_data
)
;
}
else
{
this
.
m_data
=
null
;
this
.
m_pixels
=
null
;
}
}
;
tcuSurface
.
Surface
.
prototype
.
getWidth
=
function
(
)
{
return
this
.
m_width
;
}
;
tcuSurface
.
Surface
.
prototype
.
getHeight
=
function
(
)
{
return
this
.
m_height
;
}
;
tcuSurface
.
Surface
.
prototype
.
setPixel
=
function
(
x
y
color
)
{
DE_ASSERT
(
deMath
.
deInBounds32
(
x
0
this
.
m_width
)
)
;
DE_ASSERT
(
deMath
.
deInBounds32
(
y
0
this
.
m_height
)
)
;
var
offset
=
4
*
(
x
+
y
*
this
.
m_width
)
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
this
.
m_pixels
[
offset
+
i
]
=
color
[
i
]
;
}
;
tcuSurface
.
Surface
.
prototype
.
getPixel
=
function
(
x
y
)
{
DE_ASSERT
(
deMath
.
deInBounds32
(
x
0
this
.
m_width
)
)
;
DE_ASSERT
(
deMath
.
deInBounds32
(
y
0
this
.
m_height
)
)
;
var
color
=
[
]
;
color
.
length
=
4
;
var
offset
=
4
*
(
x
+
y
*
this
.
m_width
)
;
for
(
var
i
=
0
;
i
<
4
;
i
+
+
)
color
[
i
]
=
this
.
m_pixels
[
offset
+
i
]
;
return
color
;
}
;
tcuSurface
.
Surface
.
prototype
.
getPixelUintRGB8
=
function
(
x
y
)
{
DE_ASSERT
(
deMath
.
deInBounds32
(
x
0
this
.
m_width
)
)
;
DE_ASSERT
(
deMath
.
deInBounds32
(
y
0
this
.
m_height
)
)
;
var
offset
=
4
*
(
x
+
y
*
this
.
m_width
)
;
return
(
this
.
m_pixels
[
offset
]
<
<
16
)
+
(
this
.
m_pixels
[
offset
+
1
]
<
<
8
)
+
this
.
m_pixels
[
offset
+
2
]
;
}
;
tcuSurface
.
Surface
.
prototype
.
readViewport
=
function
(
ctx
view
)
{
ctx
=
ctx
|
|
gl
;
var
v
=
view
|
|
(
ctx
.
getParameter
(
gl
.
VIEWPORT
)
)
;
var
x
;
var
y
;
var
width
;
var
height
;
if
(
v
instanceof
Array
|
|
ArrayBuffer
.
isView
(
v
)
)
{
x
=
v
[
0
]
;
y
=
v
[
1
]
;
width
=
v
[
2
]
;
height
=
v
[
3
]
;
}
else
{
x
=
v
.
x
;
y
=
v
.
y
;
width
=
v
.
width
;
height
=
v
.
height
;
}
if
(
width
!
=
this
.
m_width
|
|
height
!
=
this
.
m_height
)
this
.
setSize
(
width
height
)
;
ctx
.
readPixels
(
x
y
width
height
gl
.
RGBA
gl
.
UNSIGNED_BYTE
this
.
m_pixels
)
;
}
;
tcuSurface
.
Surface
.
prototype
.
getPixels
=
function
(
)
{
return
this
.
m_pixels
|
|
null
;
}
;
tcuSurface
.
Surface
.
prototype
.
getAccess
=
function
(
)
{
return
new
tcuTexture
.
PixelBufferAccess
(
{
format
:
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
width
:
this
.
m_width
height
:
this
.
m_height
data
:
this
.
m_data
}
)
;
}
;
tcuSurface
.
Surface
.
prototype
.
getSubAccess
=
function
(
x
y
width
height
)
{
throw
new
Error
(
'
Unimplemented
'
)
;
}
;
}
)
;
