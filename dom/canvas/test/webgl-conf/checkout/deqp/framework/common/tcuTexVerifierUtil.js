'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuTexVerifierUtil
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuFloat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuTexVerifierUtil
=
framework
.
common
.
tcuTexVerifierUtil
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deUtil
=
framework
.
delibs
.
debase
.
deUtil
;
var
tcuFloat
=
framework
.
common
.
tcuFloat
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
tcuTexVerifierUtil
.
computeFloatingPointError
=
function
(
value
numAccurateBits
)
{
var
numGarbageBits
=
23
-
numAccurateBits
;
var
mask
=
(
1
<
<
numGarbageBits
)
-
1
;
var
exp
=
tcuFloat
.
newFloat32
(
value
)
.
exponent
(
)
;
var
v1
=
new
tcuFloat
.
deFloat
(
)
;
var
v2
=
new
tcuFloat
.
deFloat
(
)
;
return
v1
.
construct
(
1
exp
1
<
<
23
|
mask
)
.
getValue
(
)
-
v2
.
construct
(
1
exp
1
<
<
23
)
.
getValue
(
)
;
}
;
tcuTexVerifierUtil
.
computeFixedPointError
=
function
(
numAccurateBits
)
{
return
tcuTexVerifierUtil
.
computeFloatingPointError
(
1
.
0
numAccurateBits
)
;
}
;
tcuTexVerifierUtil
.
computeFixedPointError_Vector
=
function
(
numAccurateBits
)
{
var
res
=
[
]
;
for
(
var
ndx
=
0
;
ndx
<
numAccurateBits
.
length
;
ndx
+
+
)
res
[
ndx
]
=
tcuTexVerifierUtil
.
computeFixedPointError
(
numAccurateBits
[
ndx
]
)
;
return
res
;
}
;
tcuTexVerifierUtil
.
computeFloatingPointError_Vector
=
function
(
value
numAccurateBits
)
{
assertMsgOptions
(
value
.
length
=
=
=
numAccurateBits
.
length
'
'
false
true
)
;
var
res
=
[
]
;
for
(
var
ndx
=
0
;
ndx
<
value
.
length
;
ndx
+
+
)
res
[
ndx
]
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
value
[
ndx
]
numAccurateBits
[
ndx
]
)
;
return
res
;
}
;
tcuTexVerifierUtil
.
isNearestMipmapFilter
=
function
(
mode
)
{
return
mode
=
=
tcuTexture
.
FilterMode
.
NEAREST_MIPMAP_NEAREST
|
|
mode
=
=
tcuTexture
.
FilterMode
.
LINEAR_MIPMAP_NEAREST
;
}
;
tcuTexVerifierUtil
.
isLinearMipmapFilter
=
function
(
mode
)
{
return
mode
=
=
tcuTexture
.
FilterMode
.
NEAREST_MIPMAP_LINEAR
|
|
mode
=
=
tcuTexture
.
FilterMode
.
LINEAR_MIPMAP_LINEAR
;
}
;
tcuTexVerifierUtil
.
isMipmapFilter
=
function
(
mode
)
{
return
tcuTexVerifierUtil
.
isNearestMipmapFilter
(
mode
)
|
|
tcuTexVerifierUtil
.
isLinearMipmapFilter
(
mode
)
;
}
;
tcuTexVerifierUtil
.
isLinearFilter
=
function
(
mode
)
{
return
mode
=
=
tcuTexture
.
FilterMode
.
LINEAR
|
|
mode
=
=
tcuTexture
.
FilterMode
.
LINEAR_MIPMAP_NEAREST
|
|
mode
=
=
tcuTexture
.
FilterMode
.
LINEAR_MIPMAP_LINEAR
;
}
;
tcuTexVerifierUtil
.
isNearestFilter
=
function
(
mode
)
{
return
!
tcuTexVerifierUtil
.
isLinearFilter
(
mode
)
;
}
;
tcuTexVerifierUtil
.
getLevelFilter
=
function
(
mode
)
{
return
tcuTexVerifierUtil
.
isLinearFilter
(
mode
)
?
tcuTexture
.
FilterMode
.
LINEAR
:
tcuTexture
.
FilterMode
.
NEAREST
;
}
;
tcuTexVerifierUtil
.
isWrapModeSupported
=
function
(
mode
)
{
return
mode
!
=
tcuTexture
.
WrapMode
.
MIRRORED_REPEAT_CL
&
&
mode
!
=
tcuTexture
.
WrapMode
.
REPEAT_CL
;
}
;
tcuTexVerifierUtil
.
computeNonNormalizedCoordBounds
=
function
(
normalizedCoords
dim
coord
coordBits
uvBits
)
{
var
coordErr
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
coord
coordBits
)
;
var
minN
=
coord
-
coordErr
;
var
maxN
=
coord
+
coordErr
;
var
minA
=
normalizedCoords
?
minN
*
dim
:
minN
;
var
maxA
=
normalizedCoords
?
maxN
*
dim
:
maxN
;
var
minC
=
minA
-
tcuTexVerifierUtil
.
computeFixedPointError
(
uvBits
)
;
var
maxC
=
maxA
+
tcuTexVerifierUtil
.
computeFixedPointError
(
uvBits
)
;
assertMsgOptions
(
minC
<
=
maxC
'
'
false
true
)
;
return
[
minC
maxC
]
;
}
;
tcuTexVerifierUtil
.
getPossibleCubeFaces
=
function
(
coord
bits
)
{
var
faces
=
[
]
;
var
x
=
coord
[
0
]
;
var
y
=
coord
[
1
]
;
var
z
=
coord
[
2
]
;
var
ax
=
Math
.
abs
(
x
)
;
var
ay
=
Math
.
abs
(
y
)
;
var
az
=
Math
.
abs
(
z
)
;
var
ex
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
x
bits
[
0
]
)
;
var
ey
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
y
bits
[
1
]
)
;
var
ez
=
tcuTexVerifierUtil
.
computeFloatingPointError
(
z
bits
[
2
]
)
;
var
numFaces
=
0
;
if
(
ay
+
ey
<
ax
-
ex
&
&
az
+
ez
<
ax
-
ex
)
{
if
(
x
>
=
ex
)
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_X
)
;
if
(
x
<
=
ex
)
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_X
)
;
}
else
if
(
ax
+
ex
<
ay
-
ey
&
&
az
+
ez
<
ay
-
ey
)
{
if
(
y
>
=
ey
)
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_Y
)
;
if
(
y
<
=
ey
)
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_Y
)
;
}
else
if
(
ax
+
ex
<
az
-
ez
&
&
ay
+
ey
<
az
-
ez
)
{
if
(
z
>
=
ez
)
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_Z
)
;
if
(
z
<
=
ez
)
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_Z
)
;
}
else
{
if
(
ax
>
ex
)
{
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_X
)
;
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_X
)
;
}
if
(
ay
>
ey
)
{
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_Y
)
;
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_Y
)
;
}
if
(
az
>
ez
)
{
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_NEGATIVE_Z
)
;
faces
.
push
(
tcuTexture
.
CubeFace
.
CUBEFACE_POSITIVE_Z
)
;
}
}
return
faces
.
length
=
=
0
?
null
:
faces
;
}
;
tcuTexVerifierUtil
.
getUnnormalizedCoordSampler
=
function
(
sampler
)
{
var
copy
=
(
deUtil
.
clone
(
sampler
)
)
;
copy
.
normalizedCoords
=
false
;
return
copy
;
}
;
tcuTexVerifierUtil
.
imod
=
function
(
a
b
)
{
return
deMath
.
imod
(
a
b
)
;
}
;
tcuTexVerifierUtil
.
mirror
=
function
(
a
)
{
return
deMath
.
mirror
(
a
)
;
}
;
tcuTexVerifierUtil
.
wrap
=
function
(
mode
c
size
)
{
switch
(
mode
)
{
case
tcuTexture
.
WrapMode
.
CLAMP_TO_EDGE
:
return
deMath
.
clamp
(
c
0
size
-
1
)
;
case
tcuTexture
.
WrapMode
.
REPEAT_GL
:
case
tcuTexture
.
WrapMode
.
REPEAT_CL
:
return
deMath
.
imod
(
c
size
)
;
case
tcuTexture
.
WrapMode
.
MIRRORED_REPEAT_GL
:
case
tcuTexture
.
WrapMode
.
MIRRORED_REPEAT_CL
:
return
(
size
-
1
)
-
deMath
.
mirror
(
deMath
.
imod
(
c
2
*
size
)
-
size
)
;
default
:
throw
new
Error
(
'
Wrap
mode
not
supported
.
'
)
;
}
}
;
}
)
;
