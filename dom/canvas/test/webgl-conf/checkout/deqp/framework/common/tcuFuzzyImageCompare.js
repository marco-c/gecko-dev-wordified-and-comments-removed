'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuFuzzyImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuFuzzyImageCompare
=
framework
.
common
.
tcuFuzzyImageCompare
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
tcuFuzzyImageCompare
.
FuzzyCompareParams
=
function
(
maxSampleSkip_
minErrThreshold_
errExp_
)
{
this
.
maxSampleSkip
=
maxSampleSkip_
=
=
=
undefined
?
8
:
maxSampleSkip_
;
this
.
minErrThreshold
=
minErrThreshold_
=
=
=
undefined
?
4
:
minErrThreshold_
;
this
.
errExp
=
errExp_
=
=
=
undefined
?
4
.
0
:
errExp_
;
}
;
tcuFuzzyImageCompare
.
roundArray4ToUint8Sat
=
function
(
v
)
{
return
[
deMath
.
clamp
(
Math
.
trunc
(
v
[
0
]
+
0
.
5
)
0
255
)
deMath
.
clamp
(
Math
.
trunc
(
v
[
1
]
+
0
.
5
)
0
255
)
deMath
.
clamp
(
Math
.
trunc
(
v
[
2
]
+
0
.
5
)
0
255
)
deMath
.
clamp
(
Math
.
trunc
(
v
[
3
]
+
0
.
5
)
0
255
)
]
;
}
;
tcuFuzzyImageCompare
.
compareColors
=
function
(
pa
pb
minErrThreshold
)
{
var
r
=
Math
.
max
(
Math
.
abs
(
pa
[
0
]
-
pb
[
0
]
)
-
minErrThreshold
0
)
;
var
g
=
Math
.
max
(
Math
.
abs
(
pa
[
1
]
-
pb
[
1
]
)
-
minErrThreshold
0
)
;
var
b
=
Math
.
max
(
Math
.
abs
(
pa
[
2
]
-
pb
[
2
]
)
-
minErrThreshold
0
)
;
var
a
=
Math
.
max
(
Math
.
abs
(
pa
[
3
]
-
pb
[
3
]
)
-
minErrThreshold
0
)
;
var
scale
=
1
.
0
/
(
255
-
minErrThreshold
)
;
var
sqSum
=
(
r
*
r
+
g
*
g
+
b
*
b
+
a
*
a
)
*
(
scale
*
scale
)
;
return
Math
.
sqrt
(
sqSum
)
;
}
;
tcuFuzzyImageCompare
.
bilinearSample
=
function
(
src
u
v
NumChannels
)
{
var
w
=
src
.
width
;
var
h
=
src
.
height
;
var
x0
=
Math
.
floor
(
u
-
0
.
5
)
;
var
x1
=
x0
+
1
;
var
y0
=
Math
.
floor
(
v
-
0
.
5
)
;
var
y1
=
y0
+
1
;
var
i0
=
deMath
.
clamp
(
x0
0
w
-
1
)
;
var
i1
=
deMath
.
clamp
(
x1
0
w
-
1
)
;
var
j0
=
deMath
.
clamp
(
y0
0
h
-
1
)
;
var
j1
=
deMath
.
clamp
(
y1
0
h
-
1
)
;
var
a
=
(
u
-
0
.
5
)
-
Math
.
floor
(
u
-
0
.
5
)
;
var
b
=
(
u
-
0
.
5
)
-
Math
.
floor
(
u
-
0
.
5
)
;
var
p00
=
src
.
read
(
i0
j0
NumChannels
)
;
var
p10
=
src
.
read
(
i1
j0
NumChannels
)
;
var
p01
=
src
.
read
(
i0
j1
NumChannels
)
;
var
p11
=
src
.
read
(
i1
j1
NumChannels
)
;
var
dst
=
0
;
var
f
=
[
]
;
for
(
var
c
=
0
;
c
<
NumChannels
;
c
+
+
)
{
f
[
c
]
=
p00
[
c
]
*
(
1
.
0
-
a
)
*
(
1
.
0
-
b
)
+
(
p10
[
c
]
*
a
*
(
1
.
0
-
b
)
)
+
(
p01
[
c
]
*
(
1
.
0
-
a
)
*
b
)
+
(
p11
[
c
]
*
a
*
b
)
;
}
return
tcuFuzzyImageCompare
.
roundArray4ToUint8Sat
(
f
)
;
}
;
tcuFuzzyImageCompare
.
separableConvolve
=
function
(
dst
src
shiftX
shiftY
kernelX
kernelY
DstChannels
SrcChannels
)
{
DE_ASSERT
(
dst
.
width
=
=
src
.
width
&
&
dst
.
height
=
=
src
.
height
)
;
var
tmp
=
new
tcuTexture
.
TextureLevel
(
dst
.
getFormat
(
)
dst
.
height
dst
.
width
)
;
var
tmpView
=
new
tcuTexture
.
RGBA8View
(
tmp
.
getAccess
(
)
)
;
var
kw
=
kernelX
.
length
;
var
kh
=
kernelY
.
length
;
var
sum
=
[
]
;
var
f
;
var
p
;
for
(
var
j
=
0
;
j
<
src
.
height
;
j
+
+
)
{
for
(
var
i
=
0
;
i
<
src
.
width
;
i
+
+
)
{
sum
[
0
]
=
sum
[
1
]
=
sum
[
2
]
=
sum
[
3
]
=
0
;
for
(
var
kx
=
0
;
kx
<
kw
;
kx
+
+
)
{
f
=
kernelX
[
kw
-
kx
-
1
]
;
p
=
src
.
read
(
deMath
.
clamp
(
i
+
kx
-
shiftX
0
src
.
width
-
1
)
j
SrcChannels
)
;
sum
=
deMath
.
add
(
sum
deMath
.
scale
(
p
f
)
)
;
}
sum
=
tcuFuzzyImageCompare
.
roundArray4ToUint8Sat
(
sum
)
;
tmpView
.
write
(
j
i
sum
DstChannels
)
;
}
}
for
(
var
j
=
0
;
j
<
src
.
height
;
j
+
+
)
{
for
(
var
i
=
0
;
i
<
src
.
width
;
i
+
+
)
{
sum
[
0
]
=
sum
[
1
]
=
sum
[
2
]
=
sum
[
3
]
=
0
;
for
(
var
ky
=
0
;
ky
<
kh
;
ky
+
+
)
{
f
=
kernelY
[
kh
-
ky
-
1
]
;
p
=
tmpView
.
read
(
deMath
.
clamp
(
j
+
ky
-
shiftY
0
tmpView
.
width
-
1
)
i
DstChannels
)
;
sum
=
deMath
.
add
(
sum
deMath
.
scale
(
p
f
)
)
;
}
sum
=
tcuFuzzyImageCompare
.
roundArray4ToUint8Sat
(
sum
)
;
dst
.
write
(
i
j
sum
DstChannels
)
;
}
}
}
;
tcuFuzzyImageCompare
.
compareToNeighbor
=
function
(
params
rnd
pixel
surface
x
y
NumChannels
)
{
var
minErr
=
100
;
minErr
=
Math
.
min
(
minErr
tcuFuzzyImageCompare
.
compareColors
(
pixel
surface
.
read
(
x
y
NumChannels
)
params
.
minErrThreshold
)
)
;
if
(
minErr
=
=
0
.
0
)
return
minErr
;
var
s_coords
=
[
[
-
1
-
1
]
[
0
-
1
]
[
1
-
1
]
[
-
1
0
]
[
1
0
]
[
-
1
1
]
[
0
1
]
[
1
1
]
]
;
var
dx
;
var
dy
;
for
(
var
d
=
0
;
d
<
s_coords
.
length
;
d
+
+
)
{
dx
=
x
+
s_coords
[
d
]
[
0
]
;
dy
=
y
+
s_coords
[
d
]
[
1
]
;
if
(
!
deMath
.
deInBounds32
(
dx
0
surface
.
width
)
|
|
!
deMath
.
deInBounds32
(
dy
0
surface
.
height
)
)
continue
;
minErr
=
Math
.
min
(
minErr
tcuFuzzyImageCompare
.
compareColors
(
pixel
surface
.
read
(
dx
dy
NumChannels
)
params
.
minErrThreshold
)
)
;
if
(
minErr
=
=
0
.
0
)
return
minErr
;
}
for
(
var
s
=
0
;
s
<
32
;
s
+
+
)
{
dx
=
x
+
rnd
.
getFloat
(
)
*
2
.
0
-
0
.
5
;
dy
=
y
+
rnd
.
getFloat
(
)
*
2
.
0
-
0
.
5
;
var
sample
=
tcuFuzzyImageCompare
.
bilinearSample
(
surface
dx
dy
NumChannels
)
;
minErr
=
Math
.
min
(
minErr
tcuFuzzyImageCompare
.
compareColors
(
pixel
sample
params
.
minErrThreshold
)
)
;
if
(
minErr
=
=
0
.
0
)
return
minErr
;
}
return
minErr
;
}
;
tcuFuzzyImageCompare
.
toGrayscale
=
function
(
c
)
{
return
0
.
2126
*
c
[
0
]
+
0
.
7152
*
c
[
1
]
+
0
.
0722
*
c
[
2
]
;
}
;
tcuFuzzyImageCompare
.
isFormatSupported
=
function
(
format
)
{
return
format
.
type
=
=
tcuTexture
.
ChannelType
.
UNORM_INT8
&
&
(
format
.
order
=
=
tcuTexture
.
ChannelOrder
.
RGB
|
|
format
.
order
=
=
tcuTexture
.
ChannelOrder
.
RGBA
)
;
}
;
tcuFuzzyImageCompare
.
fuzzyCompare
=
function
(
params
ref
cmp
errorMask
)
{
assertMsgOptions
(
ref
.
getWidth
(
)
=
=
cmp
.
getWidth
(
)
&
&
ref
.
getHeight
(
)
=
=
cmp
.
getHeight
(
)
'
Reference
and
result
images
have
different
dimensions
'
false
true
)
;
assertMsgOptions
(
ref
.
getWidth
(
)
=
=
errorMask
.
getWidth
(
)
&
&
ref
.
getHeight
(
)
=
=
errorMask
.
getHeight
(
)
'
Reference
and
error
mask
images
have
different
dimensions
'
false
true
)
;
if
(
!
tcuFuzzyImageCompare
.
isFormatSupported
(
ref
.
getFormat
(
)
)
|
|
!
tcuFuzzyImageCompare
.
isFormatSupported
(
cmp
.
getFormat
(
)
)
)
throw
new
Error
(
'
Unsupported
format
in
fuzzy
comparison
'
)
;
var
width
=
ref
.
getWidth
(
)
;
var
height
=
ref
.
getHeight
(
)
;
var
rnd
=
new
deRandom
.
Random
(
667
)
;
var
refFiltered
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
width
height
)
;
var
cmpFiltered
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
width
height
)
;
var
refView
=
new
tcuTexture
.
RGBA8View
(
ref
)
;
var
cmpView
=
new
tcuTexture
.
RGBA8View
(
cmp
)
;
var
refFilteredView
=
new
tcuTexture
.
RGBA8View
(
tcuTexture
.
PixelBufferAccess
.
newFromTextureLevel
(
refFiltered
)
)
;
var
cmpFilteredView
=
new
tcuTexture
.
RGBA8View
(
tcuTexture
.
PixelBufferAccess
.
newFromTextureLevel
(
cmpFiltered
)
)
;
var
kernel
=
[
0
.
1
0
.
8
0
.
1
]
;
var
shift
=
Math
.
floor
(
(
kernel
.
length
-
1
)
/
2
)
;
switch
(
ref
.
getFormat
(
)
.
order
)
{
case
tcuTexture
.
ChannelOrder
.
RGBA
:
tcuFuzzyImageCompare
.
separableConvolve
(
refFilteredView
refView
shift
shift
kernel
kernel
4
4
)
;
break
;
case
tcuTexture
.
ChannelOrder
.
RGB
:
tcuFuzzyImageCompare
.
separableConvolve
(
refFilteredView
refView
shift
shift
kernel
kernel
4
3
)
;
break
;
default
:
throw
new
Error
(
'
tcuFuzzyImageCompare
.
fuzzyCompare
-
Invalid
ChannelOrder
'
)
;
}
switch
(
cmp
.
getFormat
(
)
.
order
)
{
case
tcuTexture
.
ChannelOrder
.
RGBA
:
tcuFuzzyImageCompare
.
separableConvolve
(
cmpFilteredView
cmpView
shift
shift
kernel
kernel
4
4
)
;
break
;
case
tcuTexture
.
ChannelOrder
.
RGB
:
tcuFuzzyImageCompare
.
separableConvolve
(
cmpFilteredView
cmpView
shift
shift
kernel
kernel
4
3
)
;
break
;
default
:
throw
new
Error
(
'
tcuFuzzyImageCompare
.
fuzzyCompare
-
Invalid
ChannelOrder
'
)
;
}
var
numSamples
=
0
;
var
errSum
=
0
.
0
;
errorMask
.
clear
(
[
0
.
0
1
.
0
0
.
0
1
.
0
]
)
;
for
(
var
y
=
1
;
y
<
height
-
1
;
y
+
+
)
{
for
(
var
x
=
1
;
x
<
width
-
1
;
x
+
=
params
.
maxSampleSkip
>
0
?
rnd
.
getInt
(
0
params
.
maxSampleSkip
)
:
1
)
{
var
err
=
Math
.
min
(
tcuFuzzyImageCompare
.
compareToNeighbor
(
params
rnd
refFilteredView
.
read
(
x
y
4
)
cmpFilteredView
x
y
4
)
tcuFuzzyImageCompare
.
compareToNeighbor
(
params
rnd
cmpFilteredView
.
read
(
x
y
4
)
refFilteredView
x
y
4
)
)
;
err
=
Math
.
pow
(
err
params
.
errExp
)
;
errSum
+
=
err
;
numSamples
+
=
1
;
var
red
=
err
*
500
.
0
;
var
luma
=
tcuFuzzyImageCompare
.
toGrayscale
(
cmp
.
getPixel
(
x
y
)
)
;
var
rF
=
0
.
7
+
0
.
3
*
luma
;
errorMask
.
setPixel
(
[
red
*
rF
(
1
.
0
-
red
)
*
rF
0
.
0
1
.
0
]
x
y
)
;
}
}
errSum
*
=
(
(
width
-
2
)
*
(
height
-
2
)
)
/
numSamples
;
return
errSum
;
}
;
}
)
;
