'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuBilinearImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuFloat
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuFuzzyImageCompare
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuLogImage
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuSurface
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuImageCompare
=
framework
.
common
.
tcuImageCompare
;
var
tcuSurface
=
framework
.
common
.
tcuSurface
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
tcuFloat
=
framework
.
common
.
tcuFloat
;
var
tcuFuzzyImageCompare
=
framework
.
common
.
tcuFuzzyImageCompare
;
var
tcuBilinearImageCompare
=
framework
.
common
.
tcuBilinearImageCompare
;
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
tcuLogImage
=
framework
.
common
.
tcuLogImage
;
tcuImageCompare
.
CompareLogMode
=
{
EVERYTHING
:
0
RESULT
:
1
ON_ERROR
:
2
}
;
tcuImageCompare
.
displayImages
=
function
(
result
reference
diff
)
{
var
limits
=
tcuImageCompare
.
computeScaleAndBias
(
reference
result
)
;
tcuLogImage
.
logImage
(
'
Result
'
'
'
result
limits
.
scale
limits
.
bias
)
;
tcuLogImage
.
logImage
(
'
Reference
'
'
'
reference
limits
.
scale
limits
.
bias
)
;
if
(
diff
)
tcuLogImage
.
logImage
(
'
Error
'
'
error
mask
'
diff
)
;
}
;
tcuImageCompare
.
computeScaleAndBias
=
function
(
reference
result
)
{
var
minVal
=
[
]
;
var
maxVal
=
[
]
;
var
scale
=
[
]
;
var
bias
=
[
]
;
var
eps
=
0
.
0001
;
var
referenceRange
=
tcuTextureUtil
.
estimatePixelValueRange
(
reference
)
;
var
resultRange
=
tcuTextureUtil
.
estimatePixelValueRange
(
result
)
;
minVal
[
0
]
=
Math
.
min
(
referenceRange
[
0
]
[
0
]
resultRange
[
0
]
[
0
]
)
;
minVal
[
1
]
=
Math
.
min
(
referenceRange
[
0
]
[
1
]
resultRange
[
0
]
[
1
]
)
;
minVal
[
2
]
=
Math
.
min
(
referenceRange
[
0
]
[
2
]
resultRange
[
0
]
[
2
]
)
;
minVal
[
3
]
=
Math
.
min
(
referenceRange
[
0
]
[
3
]
resultRange
[
0
]
[
3
]
)
;
maxVal
[
0
]
=
Math
.
max
(
referenceRange
[
1
]
[
0
]
resultRange
[
1
]
[
0
]
)
;
maxVal
[
1
]
=
Math
.
max
(
referenceRange
[
1
]
[
1
]
resultRange
[
1
]
[
1
]
)
;
maxVal
[
2
]
=
Math
.
max
(
referenceRange
[
1
]
[
2
]
resultRange
[
1
]
[
2
]
)
;
maxVal
[
3
]
=
Math
.
max
(
referenceRange
[
1
]
[
3
]
resultRange
[
1
]
[
3
]
)
;
for
(
var
c
=
0
;
c
<
4
;
c
+
+
)
{
if
(
maxVal
[
c
]
-
minVal
[
c
]
<
eps
)
{
scale
[
c
]
=
(
maxVal
[
c
]
<
eps
)
?
1
:
(
1
/
maxVal
[
c
]
)
;
bias
[
c
]
=
(
c
=
=
3
)
?
(
1
-
maxVal
[
c
]
*
scale
[
c
]
)
:
(
0
-
minVal
[
c
]
*
scale
[
c
]
)
;
}
else
{
scale
[
c
]
=
1
/
(
maxVal
[
c
]
-
minVal
[
c
]
)
;
bias
[
c
]
=
0
-
minVal
[
c
]
*
scale
[
c
]
;
}
}
return
{
scale
:
scale
bias
:
bias
}
;
}
;
tcuImageCompare
.
intThresholdCompare
=
function
(
imageSetName
imageSetDesc
reference
result
threshold
logMode
)
{
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
depth
=
reference
.
getDepth
(
)
;
var
errorMask
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
maxDiff
=
[
0
0
0
0
]
;
assertMsgOptions
(
result
.
getWidth
(
)
=
=
width
&
&
result
.
getHeight
(
)
=
=
height
&
&
result
.
getDepth
(
)
=
=
depth
'
Reference
and
result
images
have
different
dimensions
'
false
true
)
;
for
(
var
z
=
0
;
z
<
depth
;
z
+
+
)
{
for
(
var
y
=
0
;
y
<
height
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
width
;
x
+
+
)
{
var
refPix
=
reference
.
getPixelInt
(
x
y
z
)
;
var
cmpPix
=
result
.
getPixelInt
(
x
y
z
)
;
var
diff
=
deMath
.
absDiff
(
refPix
cmpPix
)
;
var
isOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
diff
threshold
)
)
;
maxDiff
=
deMath
.
max
(
maxDiff
diff
)
;
var
color
=
[
0
255
0
255
]
;
if
(
!
isOk
)
color
=
[
255
0
0
255
]
;
errorMask
.
setPixel
(
x
y
color
)
;
}
}
}
var
compareOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
maxDiff
threshold
)
)
;
if
(
!
compareOk
)
{
debug
(
'
Image
comparison
failed
:
max
difference
=
'
+
maxDiff
+
'
threshold
=
'
+
threshold
)
;
tcuImageCompare
.
displayImages
(
result
reference
errorMask
.
getAccess
(
)
)
;
}
return
compareOk
;
}
;
tcuImageCompare
.
intThresholdPositionDeviationErrorThresholdCompare
=
function
(
imageSetName
imageSetDesc
reference
result
threshold
maxPositionDeviation
acceptOutOfBoundsAsAnyValue
maxAllowedFailingPixels
)
{
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
depth
=
reference
.
getDepth
(
)
;
var
errorMask
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
numFailingPixels
=
tcuImageCompare
.
findNumPositionDeviationFailingPixels
(
errorMask
.
getAccess
(
)
reference
result
threshold
maxPositionDeviation
acceptOutOfBoundsAsAnyValue
)
;
var
compareOk
=
numFailingPixels
<
=
maxAllowedFailingPixels
;
var
pixelBias
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
var
pixelScale
=
[
1
.
0
1
.
0
1
.
0
1
.
0
]
;
if
(
!
compareOk
)
{
debug
(
'
Position
deviation
error
threshold
image
comparison
failed
:
failed
pixels
=
'
+
numFailingPixels
+
'
threshold
=
'
+
threshold
)
;
tcuImageCompare
.
displayImages
(
result
reference
errorMask
.
getAccess
(
)
)
;
}
else
tcuLogImage
.
logImage
(
'
Result
'
'
'
result
)
;
return
compareOk
;
}
;
tcuImageCompare
.
floatUlpThresholdCompare
=
function
(
imageSetName
imageSetDesc
reference
result
threshold
)
{
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
depth
=
reference
.
getDepth
(
)
;
var
errorMask
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
maxDiff
=
[
0
0
0
0
]
;
assertMsgOptions
(
result
.
getWidth
(
)
=
=
width
&
&
result
.
getHeight
(
)
=
=
height
&
&
result
.
getDepth
(
)
=
=
depth
'
Reference
and
result
images
have
different
dimensions
'
false
true
)
;
for
(
var
z
=
0
;
z
<
depth
;
z
+
+
)
{
for
(
var
y
=
0
;
y
<
height
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
width
;
x
+
+
)
{
var
arrayBufferRef
=
new
ArrayBuffer
(
4
*
4
)
;
var
arrayBufferCmp
=
new
ArrayBuffer
(
4
*
4
)
;
var
refPix
=
reference
.
getPixel
(
x
y
z
)
;
var
cmpPix
=
result
.
getPixel
(
x
y
z
)
;
var
refBits
=
new
Uint32Array
(
arrayBufferRef
)
;
var
cmpBits
=
new
Uint32Array
(
arrayBufferCmp
)
;
for
(
var
i
=
0
;
i
<
refPix
.
length
;
i
+
+
)
{
refBits
[
i
]
=
tcuFloat
.
convertFloat32Inline
(
refPix
[
i
]
tcuFloat
.
description32
)
;
cmpBits
[
i
]
=
tcuFloat
.
convertFloat32Inline
(
cmpPix
[
i
]
tcuFloat
.
description32
)
;
}
var
diff
=
deMath
.
absDiff
(
refBits
cmpBits
)
;
var
isOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
diff
threshold
)
)
;
maxDiff
=
deMath
.
max
(
maxDiff
diff
)
;
errorMask
.
setPixel
(
x
y
isOk
?
[
0
255
0
255
]
:
[
255
0
0
255
]
)
;
}
}
}
var
compareOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
maxDiff
threshold
)
)
;
if
(
!
compareOk
)
{
debug
(
'
Image
comparison
failed
:
max
difference
=
'
+
maxDiff
+
'
threshold
=
'
+
threshold
)
;
tcuImageCompare
.
displayImages
(
result
reference
errorMask
.
getAccess
(
)
)
;
}
return
compareOk
;
}
;
tcuImageCompare
.
floatThresholdCompare
=
function
(
imageSetName
imageSetDesc
reference
result
threshold
)
{
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
depth
=
reference
.
getDepth
(
)
;
var
errorMask
=
new
tcuSurface
.
Surface
(
width
height
)
;
var
maxDiff
=
[
0
0
0
0
]
;
assertMsgOptions
(
result
.
getWidth
(
)
=
=
width
&
&
result
.
getHeight
(
)
=
=
height
&
&
result
.
getDepth
(
)
=
=
depth
'
Reference
and
result
images
have
different
dimensions
'
false
true
)
;
for
(
var
z
=
0
;
z
<
depth
;
z
+
+
)
{
for
(
var
y
=
0
;
y
<
height
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
width
;
x
+
+
)
{
var
refPix
=
reference
.
getPixel
(
x
y
z
)
;
var
cmpPix
=
result
.
getPixel
(
x
y
z
)
;
var
diff
=
deMath
.
absDiff
(
refPix
cmpPix
)
;
var
isOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
diff
threshold
)
)
;
maxDiff
=
deMath
.
max
(
maxDiff
diff
)
;
errorMask
.
setPixel
(
x
y
isOk
?
[
0
255
0
255
]
:
[
255
0
0
255
]
)
;
}
}
}
var
compareOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
maxDiff
threshold
)
)
;
if
(
!
compareOk
)
{
debug
(
'
Image
comparison
failed
:
max
difference
=
'
+
maxDiff
+
'
threshold
=
'
+
threshold
)
;
tcuImageCompare
.
displayImages
(
result
reference
errorMask
.
getAccess
(
)
)
;
}
return
compareOk
;
}
;
tcuImageCompare
.
pixelThresholdCompare
=
function
(
imageSetName
imageSetDesc
reference
result
threshold
logMode
)
{
return
tcuImageCompare
.
intThresholdCompare
(
imageSetName
imageSetDesc
reference
.
getAccess
(
)
result
.
getAccess
(
)
threshold
logMode
)
;
}
;
tcuImageCompare
.
findNumPositionDeviationFailingPixels
=
function
(
errorMask
reference
result
threshold
maxPositionDeviation
acceptOutOfBoundsAsAnyValue
)
{
var
width
=
reference
.
getWidth
(
)
;
var
height
=
reference
.
getHeight
(
)
;
var
depth
=
reference
.
getDepth
(
)
;
var
numFailingPixels
=
0
;
checkMessage
(
result
.
getWidth
(
)
=
=
width
&
&
result
.
getHeight
(
)
=
=
height
&
&
result
.
getDepth
(
)
=
=
depth
'
Surfaces
have
different
dimensions
'
)
;
for
(
var
z
=
0
;
z
<
depth
;
z
+
+
)
{
for
(
var
y
=
0
;
y
<
height
;
y
+
+
)
{
for
(
var
x
=
0
;
x
<
width
;
x
+
+
)
{
var
refPix
=
reference
.
getPixelInt
(
x
y
z
)
;
var
cmpPix
=
result
.
getPixelInt
(
x
y
z
)
;
var
diff
=
deMath
.
absDiff
(
refPix
cmpPix
)
;
var
isOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
diff
threshold
)
)
;
if
(
isOk
)
{
errorMask
.
setPixel
(
[
0
0xff
0
0xff
]
x
y
z
)
;
continue
;
}
if
(
acceptOutOfBoundsAsAnyValue
&
&
(
x
<
maxPositionDeviation
[
0
]
|
|
x
+
maxPositionDeviation
[
0
]
>
=
width
|
|
y
<
maxPositionDeviation
[
1
]
|
|
y
+
maxPositionDeviation
[
1
]
>
=
height
|
|
z
<
maxPositionDeviation
[
2
]
|
|
z
+
maxPositionDeviation
[
2
]
>
=
depth
)
)
{
errorMask
.
setPixel
(
[
0
0xff
0
0xff
]
x
y
z
)
;
continue
;
}
var
pixelFoundForReference
=
false
;
var
pixelFoundForResult
=
false
;
for
(
var
sz
=
Math
.
max
(
0
z
-
maxPositionDeviation
[
2
]
)
;
sz
<
=
Math
.
min
(
depth
-
1
z
+
maxPositionDeviation
[
2
]
)
&
&
!
pixelFoundForReference
;
+
+
sz
)
for
(
var
sy
=
Math
.
max
(
0
y
-
maxPositionDeviation
[
1
]
)
;
sy
<
=
Math
.
min
(
height
-
1
y
+
maxPositionDeviation
[
1
]
)
&
&
!
pixelFoundForReference
;
+
+
sy
)
for
(
var
sx
=
Math
.
max
(
0
x
-
maxPositionDeviation
[
0
]
)
;
sx
<
=
Math
.
min
(
width
-
1
x
+
maxPositionDeviation
[
0
]
)
&
&
!
pixelFoundForReference
;
+
+
sx
)
{
var
deviatedCmpPix
=
result
.
getPixelInt
(
sx
sy
sz
)
;
diff
=
deMath
.
absDiff
(
refPix
deviatedCmpPix
)
;
isOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
diff
threshold
)
)
;
pixelFoundForReference
|
=
isOk
;
}
for
(
var
sz
=
Math
.
max
(
0
z
-
maxPositionDeviation
[
2
]
)
;
sz
<
=
Math
.
min
(
depth
-
1
z
+
maxPositionDeviation
[
2
]
)
&
&
!
pixelFoundForResult
;
+
+
sz
)
for
(
var
sy
=
Math
.
max
(
0
y
-
maxPositionDeviation
[
1
]
)
;
sy
<
=
Math
.
min
(
height
-
1
y
+
maxPositionDeviation
[
1
]
)
&
&
!
pixelFoundForResult
;
+
+
sy
)
for
(
var
sx
=
Math
.
max
(
0
x
-
maxPositionDeviation
[
0
]
)
;
sx
<
=
Math
.
min
(
width
-
1
x
+
maxPositionDeviation
[
0
]
)
&
&
!
pixelFoundForResult
;
+
+
sx
)
{
var
deviatedRefPix
=
reference
.
getPixelInt
(
sx
sy
sz
)
;
diff
=
deMath
.
absDiff
(
cmpPix
deviatedRefPix
)
;
isOk
=
deMath
.
boolAll
(
deMath
.
lessThanEqual
(
diff
threshold
)
)
;
pixelFoundForResult
|
=
isOk
;
}
if
(
pixelFoundForReference
&
&
pixelFoundForResult
)
errorMask
.
setPixel
(
[
0
0xff
0
0xff
]
x
y
z
)
;
else
{
errorMask
.
setPixel
(
[
0xff
0
0
0xff
]
x
y
z
)
;
+
+
numFailingPixels
;
}
}
}
}
return
numFailingPixels
;
}
;
tcuImageCompare
.
fuzzyCompare
=
function
(
imageSetName
imageSetDesc
reference
result
threshold
logMode
)
{
var
params
=
new
tcuFuzzyImageCompare
.
FuzzyCompareParams
(
)
;
var
errorMask
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGB
tcuTexture
.
ChannelType
.
UNORM_INT8
)
reference
.
getWidth
(
)
reference
.
getHeight
(
)
)
;
var
difference
=
tcuFuzzyImageCompare
.
fuzzyCompare
(
params
reference
result
tcuTexture
.
PixelBufferAccess
.
newFromTextureLevel
(
errorMask
)
)
;
var
isOk
=
difference
<
=
threshold
;
var
pixelBias
=
[
0
.
0
0
.
0
0
.
0
0
.
0
]
;
var
pixelScale
=
[
1
.
0
1
.
0
1
.
0
1
.
0
]
;
if
(
!
isOk
)
{
debug
(
'
Fuzzy
image
comparison
failed
:
difference
=
'
+
difference
+
'
threshold
=
'
+
threshold
)
;
tcuImageCompare
.
displayImages
(
result
reference
errorMask
.
getAccess
(
)
)
;
}
return
isOk
;
}
;
tcuImageCompare
.
unitTest
=
function
(
)
{
var
width
=
128
;
var
height
=
128
;
var
weirdLevel
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RG
tcuTexture
.
ChannelType
.
SNORM_INT32
)
width
height
)
;
var
access
=
weirdLevel
.
getAccess
(
)
;
access
.
clear
(
[
0
.
1
0
.
5
0
0
]
)
;
access
.
clear
(
[
0
.
11
0
.
52
0
0
]
[
0
width
]
[
0
height
/
2
]
)
;
access
.
clear
(
[
0
.
12
0
.
52
0
0
]
[
0
width
]
[
height
/
2
height
/
2
+
height
/
8
]
)
;
var
limits
=
tcuTextureUtil
.
computePixelScaleBias
(
access
)
;
debug
(
'
Scale
:
'
+
limits
.
scale
)
;
debug
(
'
Bias
:
'
+
limits
.
bias
)
;
tcuLogImage
.
logImage
(
'
Weird
'
'
weird
format
without
scaling
'
access
)
;
tcuLogImage
.
logImage
(
'
Weird
'
'
weird
format
'
access
limits
.
scale
limits
.
bias
)
;
var
srcLevel
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
width
height
)
;
var
dstLevel
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
width
height
)
;
var
src
=
srcLevel
.
getAccess
(
)
;
var
dst
=
dstLevel
.
getAccess
(
)
;
src
.
clear
(
)
;
dst
.
clear
(
)
;
for
(
var
i
=
0
;
i
<
width
-
1
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
height
-
1
;
j
+
+
)
{
src
.
setPixelInt
(
[
i
j
90
255
]
i
j
)
;
dst
.
setPixelInt
(
[
i
j
90
255
]
i
+
1
j
+
1
)
;
}
}
debug
(
'
Src
format
:
'
+
src
.
getFormat
(
)
)
;
debug
(
'
Destination
:
'
+
dst
)
;
debug
(
src
)
;
tcuLogImage
.
logImage
(
'
Source
'
'
Source
image
'
src
)
;
if
(
!
tcuImageCompare
.
fuzzyCompare
(
'
compare
'
'
compare
similar
images
'
src
dst
0
.
05
)
)
throw
new
Error
(
'
Compare
should
return
true
'
)
;
src
.
clear
(
)
;
dst
.
clear
(
)
;
for
(
var
i
=
0
;
i
<
width
-
2
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
height
-
2
;
j
+
+
)
{
src
.
setPixelInt
(
[
i
j
90
255
]
i
j
)
;
dst
.
setPixelInt
(
[
i
j
90
255
]
i
+
2
j
+
2
)
;
}
}
if
(
tcuImageCompare
.
fuzzyCompare
(
'
compare
'
'
compare
different
images
'
src
dst
0
.
05
)
)
throw
new
Error
(
'
Compare
should
return
false
'
)
;
debug
(
'
Passed
'
)
;
}
;
tcuImageCompare
.
unitTest2
=
function
(
)
{
var
width
=
128
;
var
height
=
128
;
var
srcLevel
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
width
height
)
;
var
dstLevel
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGBA
tcuTexture
.
ChannelType
.
UNORM_INT8
)
width
height
)
;
var
src
=
srcLevel
.
getAccess
(
)
;
var
dst
=
dstLevel
.
getAccess
(
)
;
var
threshold
=
tcuRGBA
.
newRGBAComponents
(
1
1
1
1
)
;
debug
(
'
Threshold
:
'
+
threshold
)
;
src
.
clear
(
)
;
dst
.
clear
(
)
;
for
(
var
i
=
0
;
i
<
width
-
1
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
height
-
1
;
j
+
+
)
{
src
.
setPixelInt
(
[
i
j
90
255
]
i
j
)
;
dst
.
setPixelInt
(
[
i
j
90
255
]
i
j
)
;
}
}
if
(
!
tcuImageCompare
.
bilinearCompare
(
'
compare
'
'
compare
similar
images
'
src
dst
threshold
)
)
throw
new
Error
(
'
Compare
should
return
true
'
)
;
debug
(
'
bilinear
compare
the
same
images
passed
'
)
;
src
.
clear
(
)
;
dst
.
clear
(
)
;
for
(
var
i
=
0
;
i
<
width
-
1
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
height
-
1
;
j
+
+
)
{
src
.
setPixelInt
(
[
i
j
90
255
]
i
j
)
;
dst
.
setPixelInt
(
[
i
j
+
1
90
255
]
i
j
+
1
)
;
}
}
if
(
!
tcuImageCompare
.
bilinearCompare
(
'
compare
'
'
compare
similar
images
'
src
dst
threshold
)
)
throw
new
Error
(
'
Compare
should
return
true
'
)
;
debug
(
'
bilinear
compare
very
similar
images
passed
'
)
;
src
.
clear
(
)
;
dst
.
clear
(
)
;
for
(
var
i
=
0
;
i
<
width
-
2
;
i
+
+
)
{
for
(
var
j
=
0
;
j
<
height
-
2
;
j
+
+
)
{
src
.
setPixelInt
(
[
i
j
90
255
]
i
j
)
;
}
}
if
(
tcuImageCompare
.
bilinearCompare
(
'
compare
'
'
compare
different
images
'
src
dst
threshold
)
)
throw
new
Error
(
'
Compare
should
return
false
'
)
;
debug
(
'
bilinear
compare
very
different
images
passed
'
)
;
}
;
tcuImageCompare
.
bilinearCompare
=
function
(
imageSetName
imageSetDesc
reference
result
threshold
logMode
)
{
var
errorMask
=
new
tcuTexture
.
TextureLevel
(
new
tcuTexture
.
TextureFormat
(
tcuTexture
.
ChannelOrder
.
RGB
tcuTexture
.
ChannelType
.
UNORM_INT8
)
reference
.
getWidth
(
)
reference
.
getHeight
(
)
)
;
var
isOk
=
tcuBilinearImageCompare
.
bilinearCompare
(
reference
result
tcuTexture
.
PixelBufferAccess
.
newFromTextureLevel
(
errorMask
)
threshold
)
;
if
(
!
isOk
)
{
debug
(
'
Image
comparison
failed
:
threshold
=
'
+
threshold
)
;
tcuImageCompare
.
displayImages
(
result
reference
errorMask
.
getAccess
(
)
)
;
}
return
isOk
;
}
;
}
)
;
