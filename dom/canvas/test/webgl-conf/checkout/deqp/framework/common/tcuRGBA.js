'
use
strict
'
;
goog
.
provide
(
'
framework
.
common
.
tcuRGBA
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
scope
(
function
(
)
{
var
tcuRGBA
=
framework
.
common
.
tcuRGBA
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
tcuRGBA
.
RGBA
=
function
(
value
)
{
this
.
m_value
=
value
|
|
null
;
}
;
tcuRGBA
.
RGBA
.
Shift
=
{
RED
:
0
GREEN
:
1
BLUE
:
2
ALPHA
:
3
}
;
tcuRGBA
.
RGBA
.
Mask
=
function
(
)
{
return
{
RED
:
false
GREEN
:
false
BLUE
:
false
ALPHA
:
false
}
;
}
;
tcuRGBA
.
newRGBAComponents
=
function
(
r
g
b
a
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
r
0
255
)
)
;
DE_ASSERT
(
deMath
.
deInRange32
(
g
0
255
)
)
;
DE_ASSERT
(
deMath
.
deInRange32
(
b
0
255
)
)
;
DE_ASSERT
(
deMath
.
deInRange32
(
a
0
255
)
)
;
return
new
tcuRGBA
.
RGBA
(
[
r
g
b
a
]
)
;
}
;
tcuRGBA
.
newRGBAFromArray
=
function
(
v
)
{
return
new
tcuRGBA
.
RGBA
(
v
.
slice
(
0
4
)
)
;
}
;
tcuRGBA
.
newRGBAFromValue
=
function
(
value
)
{
var
rgba
=
new
tcuRGBA
.
RGBA
(
)
;
var
array32
=
new
Uint32Array
(
[
value
]
)
;
rgba
.
m_value
=
(
new
Uint8Array
(
array32
.
buffer
)
)
;
return
rgba
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
setRed
=
function
(
v
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
v
0
255
)
)
;
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
RED
]
=
v
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
setGreen
=
function
(
v
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
v
0
255
)
)
;
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
GREEN
]
=
v
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
setBlue
=
function
(
v
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
v
0
255
)
)
;
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
BLUE
]
=
v
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
setAlpha
=
function
(
v
)
{
DE_ASSERT
(
deMath
.
deInRange32
(
v
0
255
)
)
;
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
ALPHA
]
=
v
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
getRed
=
function
(
)
{
return
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
RED
]
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
getGreen
=
function
(
)
{
return
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
GREEN
]
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
getBlue
=
function
(
)
{
return
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
BLUE
]
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
getAlpha
=
function
(
)
{
return
this
.
m_value
[
tcuRGBA
.
RGBA
.
Shift
.
ALPHA
]
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
isBelowThreshold
=
function
(
thr
)
{
return
(
this
.
getRed
(
)
<
=
thr
.
getRed
(
)
)
&
&
(
this
.
getGreen
(
)
<
=
thr
.
getGreen
(
)
)
&
&
(
this
.
getBlue
(
)
<
=
thr
.
getBlue
(
)
)
&
&
(
this
.
getAlpha
(
)
<
=
thr
.
getAlpha
(
)
)
;
}
;
tcuRGBA
.
RGBA
.
fromBytes
=
function
(
bytes
)
{
return
tcuRGBA
.
newRGBAFromArray
(
bytes
)
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
toBytes
=
function
(
bytes
)
{
var
result
=
new
Uint8Array
(
this
.
m_value
)
;
bytes
[
0
]
=
result
[
0
]
;
bytes
[
1
]
=
result
[
1
]
;
bytes
[
2
]
=
result
[
2
]
;
bytes
[
3
]
=
result
[
3
]
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
toVec
=
function
(
)
{
return
[
this
.
getRed
(
)
/
255
.
0
this
.
getGreen
(
)
/
255
.
0
this
.
getBlue
(
)
/
255
.
0
this
.
getAlpha
(
)
/
255
.
0
]
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
toIVec
=
function
(
)
{
return
[
this
.
getRed
(
)
this
.
getGreen
(
)
this
.
getBlue
(
)
this
.
getAlpha
(
)
]
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
equals
=
function
(
v
)
{
return
(
this
.
m_value
[
0
]
=
=
v
.
m_value
[
0
]
&
&
this
.
m_value
[
1
]
=
=
v
.
m_value
[
1
]
&
&
this
.
m_value
[
2
]
=
=
v
.
m_value
[
2
]
&
&
this
.
m_value
[
3
]
=
=
v
.
m_value
[
3
]
)
;
}
;
tcuRGBA
.
compareThreshold
=
function
(
a
b
threshold
)
{
if
(
a
.
equals
(
b
)
)
return
true
;
return
tcuRGBA
.
computeAbsDiff
(
a
b
)
.
isBelowThreshold
(
threshold
)
;
}
;
tcuRGBA
.
computeAbsDiff
=
function
(
a
b
)
{
return
tcuRGBA
.
newRGBAComponents
(
Math
.
abs
(
a
.
getRed
(
)
-
b
.
getRed
(
)
)
Math
.
abs
(
a
.
getGreen
(
)
-
b
.
getGreen
(
)
)
Math
.
abs
(
a
.
getBlue
(
)
-
b
.
getBlue
(
)
)
Math
.
abs
(
a
.
getAlpha
(
)
-
b
.
getAlpha
(
)
)
)
;
}
;
tcuRGBA
.
multiply
=
function
(
a
b
)
{
return
tcuRGBA
.
newRGBAComponents
(
deMath
.
clamp
(
a
.
getRed
(
)
*
b
0
255
)
deMath
.
clamp
(
a
.
getGreen
(
)
*
b
0
255
)
deMath
.
clamp
(
a
.
getBlue
(
)
*
b
0
255
)
deMath
.
clamp
(
a
.
getAlpha
(
)
*
b
0
255
)
)
;
}
;
tcuRGBA
.
max
=
function
(
a
b
)
{
return
tcuRGBA
.
newRGBAComponents
(
Math
.
max
(
a
.
getRed
(
)
b
.
getRed
(
)
)
Math
.
max
(
a
.
getGreen
(
)
b
.
getGreen
(
)
)
Math
.
max
(
a
.
getBlue
(
)
b
.
getBlue
(
)
)
Math
.
max
(
a
.
getAlpha
(
)
b
.
getAlpha
(
)
)
)
;
}
;
tcuRGBA
.
RGBA
.
prototype
.
toString
=
function
(
)
{
return
'
[
'
+
this
.
m_value
[
0
]
+
'
'
+
this
.
m_value
[
1
]
+
'
'
+
this
.
m_value
[
2
]
+
'
'
+
this
.
m_value
[
3
]
+
'
]
'
;
}
;
tcuRGBA
.
RGBA
.
red
=
tcuRGBA
.
newRGBAComponents
(
0xFF
0
0
0xFF
)
;
tcuRGBA
.
RGBA
.
green
=
tcuRGBA
.
newRGBAComponents
(
0
0xFF
0
0xFF
)
;
tcuRGBA
.
RGBA
.
blue
=
tcuRGBA
.
newRGBAComponents
(
0
0
0xFF
0xFF
)
;
tcuRGBA
.
RGBA
.
gray
=
tcuRGBA
.
newRGBAComponents
(
0x80
0x80
0x80
0xFF
)
;
tcuRGBA
.
RGBA
.
white
=
tcuRGBA
.
newRGBAComponents
(
0xFF
0xFF
0xFF
0xFF
)
;
tcuRGBA
.
RGBA
.
black
=
tcuRGBA
.
newRGBAComponents
(
0
0
0
0xFF
)
;
}
)
;
