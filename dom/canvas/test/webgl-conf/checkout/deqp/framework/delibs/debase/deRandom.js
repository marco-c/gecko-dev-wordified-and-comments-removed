'
use
strict
'
;
goog
.
provide
(
'
framework
.
delibs
.
debase
.
deRandom
'
)
;
goog
.
scope
(
function
(
)
{
var
deRandom
=
framework
.
delibs
.
debase
.
deRandom
;
deRandom
.
deRandom
=
function
(
)
{
this
.
x
=
0
;
this
.
y
=
0
;
this
.
z
=
0
;
this
.
w
=
0
;
}
;
deRandom
.
deRandom_init
=
function
(
rnd
seed
)
{
rnd
.
x
=
(
-
seed
^
123456789
)
;
rnd
.
y
=
(
362436069
*
seed
)
;
rnd
.
z
=
(
521288629
^
(
seed
>
>
7
)
)
;
rnd
.
w
=
(
88675123
^
(
seed
<
<
3
)
)
;
}
;
deRandom
.
deRandom_getInt
=
function
(
rnd
opts
)
{
if
(
opts
!
=
undefined
&
&
opts
[
0
]
!
=
undefined
&
&
opts
[
1
]
!
=
undefined
)
{
if
(
opts
[
0
]
=
=
0x80000000
&
&
opts
[
1
]
=
=
0x7fffffff
)
{
return
deRandom
.
deRandom_getInt
(
rnd
)
;
}
else
{
return
opts
[
0
]
+
(
deRandom
.
deRandom_getInt
(
rnd
)
%
(
opts
[
1
]
-
opts
[
0
]
+
1
)
)
;
}
}
var
w
=
rnd
.
w
;
var
t
;
t
=
rnd
.
x
^
(
rnd
.
x
<
<
11
)
;
rnd
.
x
=
rnd
.
y
;
rnd
.
y
=
rnd
.
z
;
rnd
.
z
=
w
;
rnd
.
w
=
w
=
(
w
^
(
w
>
>
19
)
)
^
(
t
^
(
t
>
>
8
)
)
;
return
w
;
}
;
deRandom
.
deRandom_getFloat
=
function
(
rnd
opts
)
{
if
(
opts
!
=
undefined
&
&
opts
[
0
]
!
=
undefined
&
&
opts
[
1
]
!
=
undefined
)
{
if
(
opts
[
0
]
<
=
opts
[
1
]
)
{
return
opts
[
0
]
+
(
opts
[
1
]
-
opts
[
0
]
)
*
deRandom
.
deRandom_getFloat
(
rnd
)
;
}
}
else
{
return
(
deRandom
.
deRandom_getInt
(
rnd
)
&
0xFFFFFFF
)
/
(
0xFFFFFFF
+
1
)
;
}
throw
new
Error
(
'
Invalid
arguments
'
)
;
}
;
deRandom
.
deRandom_getBool
=
function
(
rnd
)
{
var
val
;
val
=
deRandom
.
deRandom_getInt
(
rnd
)
;
return
(
(
val
&
0xFFFFFF
)
<
0x800000
)
;
}
;
deRandom
.
getBaseSeed
=
function
(
)
{
return
42
;
}
;
deRandom
.
choose
=
function
(
rnd
elements
resultOut
num
)
{
var
items
=
num
|
|
1
;
var
temp
=
elements
.
slice
(
)
;
if
(
!
resultOut
)
resultOut
=
[
]
;
while
(
items
-
-
>
0
)
{
var
index
=
deRandom
.
deRandom_getInt
(
rnd
[
0
temp
.
length
-
1
]
)
;
resultOut
.
push
(
temp
[
index
]
)
;
temp
.
splice
(
index
1
)
;
}
return
resultOut
;
}
;
deRandom
.
chooseWeighted
=
function
(
rnd
array
weights
)
{
var
weightSum
=
0
.
0
;
var
ndx
;
for
(
ndx
=
0
;
ndx
<
array
.
length
;
ndx
+
+
)
weightSum
+
=
weights
[
ndx
]
;
var
p
=
deRandom
.
deRandom_getFloat
(
rnd
[
0
.
0
weightSum
]
)
;
var
lastNonZero
=
array
.
length
;
var
curWeight
=
0
.
0
;
for
(
ndx
=
0
;
ndx
!
=
array
.
length
;
ndx
+
+
)
{
var
w
=
weights
[
ndx
]
;
curWeight
+
=
w
;
if
(
p
<
curWeight
)
return
array
[
ndx
]
;
else
if
(
w
>
0
.
0
)
lastNonZero
=
ndx
;
}
assertMsgOptions
(
lastNonZero
!
=
array
.
length
'
Index
went
out
of
bounds
'
false
true
)
;
return
array
[
lastNonZero
]
;
}
;
deRandom
.
shuffle
=
function
(
rnd
elements
)
{
var
index
=
elements
.
length
;
while
(
index
>
0
)
{
var
random
=
deRandom
.
deRandom_getInt
(
rnd
[
0
index
-
1
]
)
;
index
-
=
1
;
var
elem
=
elements
[
index
]
;
elements
[
index
]
=
elements
[
random
]
;
elements
[
random
]
=
elem
;
}
return
elements
;
}
;
deRandom
.
Random
=
function
(
seed
)
{
this
.
m_rnd
=
new
deRandom
.
deRandom
(
)
;
deRandom
.
deRandom_init
(
this
.
m_rnd
seed
)
;
}
;
deRandom
.
Random
.
prototype
.
getBool
=
function
(
)
{
return
deRandom
.
deRandom_getBool
(
this
.
m_rnd
)
=
=
true
;
}
;
deRandom
.
Random
.
prototype
.
getFloat
=
function
(
min
max
)
{
return
deRandom
.
deRandom_getFloat
(
this
.
m_rnd
[
min
max
]
)
}
;
deRandom
.
Random
.
prototype
.
getInt
=
function
(
min
max
)
{
return
deRandom
.
deRandom_getInt
(
this
.
m_rnd
[
min
max
]
)
}
;
deRandom
.
Random
.
prototype
.
choose
=
function
(
elements
resultOut
num
)
{
return
deRandom
.
choose
(
this
.
m_rnd
elements
resultOut
num
)
}
;
deRandom
.
Random
.
prototype
.
chooseWeighted
=
function
(
array
weights
)
{
return
deRandom
.
chooseWeighted
(
this
.
m_rnd
array
weights
)
}
;
deRandom
.
Random
.
prototype
.
shuffle
=
function
(
elements
)
{
return
deRandom
.
shuffle
(
this
.
m_rnd
elements
)
}
;
deRandom
.
Random
.
prototype
.
getBaseSeed
=
function
(
)
{
return
deRandom
.
getBaseSeed
(
)
;
}
;
}
)
;
