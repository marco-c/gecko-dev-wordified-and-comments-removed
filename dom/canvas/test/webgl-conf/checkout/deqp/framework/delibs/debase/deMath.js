'
use
strict
'
;
goog
.
provide
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
TypedArray
;
goog
.
NumberArray
;
goog
.
scope
(
function
(
)
{
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
deMath
.
INT32_SIZE
=
4
;
deMath
.
deInRange32
=
function
(
a
mn
mx
)
{
return
(
a
>
=
mn
)
&
&
(
a
<
=
mx
)
;
}
;
deMath
.
deInBounds32
=
function
(
a
mn
mx
)
{
return
(
a
>
=
mn
)
&
&
(
a
<
mx
)
;
}
;
deMath
.
deFloatFrac
=
function
(
a
)
{
return
a
-
Math
.
floor
(
a
)
;
}
;
deMath
.
toFloat32
=
(
function
(
)
{
var
FLOAT32ARRAY1
=
new
Float32Array
(
1
)
;
return
function
(
a
)
{
FLOAT32ARRAY1
[
0
]
=
a
;
return
FLOAT32ARRAY1
[
0
]
;
}
;
}
)
(
)
;
deMath
.
INV_LOG_2_FLOAT32
=
deMath
.
toFloat32
(
1
.
44269504089
)
;
deMath
.
deIsPowerOfTwo32
=
function
(
a
)
{
return
(
(
a
&
(
a
-
1
)
)
=
=
0
)
;
}
;
deMath
.
deAlign32
=
function
(
val
align
)
{
if
(
!
deMath
.
deIsPowerOfTwo32
(
align
)
)
throw
new
Error
(
'
Not
a
power
of
2
:
'
+
align
)
;
return
(
(
val
+
align
-
1
)
&
~
(
align
-
1
)
)
&
0xFFFFFFFF
;
}
;
deMath
.
dePop32
=
function
(
a
)
{
var
mask0
=
0x55555555
;
var
mask1
=
0x33333333
;
var
mask2
=
0x0f0f0f0f
;
var
mask3
=
0x00ff00ff
;
var
mask4
=
0x0000ffff
;
var
t
=
a
&
0xFFFFFFFF
;
t
=
(
t
&
mask0
)
+
(
(
t
>
>
1
)
&
mask0
)
;
t
=
(
t
&
mask1
)
+
(
(
t
>
>
2
)
&
mask1
)
;
t
=
(
t
&
mask2
)
+
(
(
t
>
>
4
)
&
mask2
)
;
t
=
(
t
&
mask3
)
+
(
(
t
>
>
8
)
&
mask3
)
;
t
=
(
t
&
mask4
)
+
(
t
>
>
16
)
;
return
t
;
}
;
deMath
.
clamp
=
function
(
val
minParm
maxParm
)
{
return
Math
.
min
(
Math
.
max
(
val
minParm
)
maxParm
)
;
}
;
deMath
.
clampVector
=
function
(
values
minParm
maxParm
)
{
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
values
.
length
;
i
+
+
)
result
.
push
(
deMath
.
clamp
(
values
[
i
]
minParm
maxParm
)
)
;
return
result
;
}
;
deMath
.
imod
=
function
(
a
b
)
{
var
m
=
a
%
b
;
return
m
<
0
?
m
+
b
:
m
;
}
;
deMath
.
mirror
=
function
(
a
)
{
return
a
>
=
0
?
a
:
-
(
1
+
a
)
;
}
;
deMath
.
swizzle
=
function
(
a
indices
)
{
if
(
!
indices
.
length
)
throw
new
Error
(
'
Argument
must
be
an
array
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
indices
.
length
;
i
+
+
)
dst
.
push
(
a
[
indices
[
i
]
]
)
;
return
dst
;
}
;
deMath
.
arrayShiftLeft
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
<
<
b
[
i
]
)
;
return
dst
;
}
;
deMath
.
multiply
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
*
b
[
i
]
)
;
return
dst
;
}
;
deMath
.
divide
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
if
(
b
[
i
]
=
=
=
0
)
throw
new
Error
(
'
Division
by
0
'
)
;
dst
.
push
(
a
[
i
]
/
b
[
i
]
)
;
}
return
dst
;
}
;
deMath
.
divideScale
=
function
(
a
b
)
{
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
/
b
)
;
return
dst
;
}
;
deMath
.
mod
=
function
(
a
b
)
{
return
a
-
b
*
Math
.
floor
(
a
/
b
)
;
}
;
deMath
.
modScale
=
function
(
a
b
)
{
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
deMath
.
mod
(
a
[
i
]
b
)
)
;
return
dst
;
}
;
deMath
.
scale
=
function
(
a
b
)
{
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
*
b
)
;
return
dst
;
}
;
deMath
.
addScalar
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
First
argument
must
be
an
array
.
'
)
;
if
(
typeof
b
!
=
=
'
number
'
)
throw
new
Error
(
'
Second
argument
must
be
a
number
.
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
+
b
)
;
return
dst
;
}
;
deMath
.
add
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
+
b
[
i
]
)
;
return
dst
;
}
;
deMath
.
subtract
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
-
b
[
i
]
)
;
return
dst
;
}
;
deMath
.
subScalar
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
First
argument
must
be
an
array
.
'
)
;
if
(
typeof
b
!
=
=
'
number
'
)
throw
new
Error
(
'
Second
argument
must
be
a
number
.
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
-
b
)
;
return
dst
;
}
;
deMath
.
absDiff
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
Math
.
abs
(
a
[
i
]
-
b
[
i
]
)
)
;
return
dst
;
}
;
deMath
.
abs
=
function
(
a
)
{
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
Math
.
abs
(
a
[
i
]
)
)
;
return
dst
;
}
;
deMath
.
lessThanEqual
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
<
=
b
[
i
]
)
;
return
dst
;
}
;
deMath
.
equal
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
if
(
a
[
i
]
!
=
=
b
[
i
]
)
return
false
;
}
return
true
;
}
;
deMath
.
boolAll
=
function
(
a
)
{
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
if
(
a
[
i
]
=
=
false
)
return
false
;
return
true
;
}
;
deMath
.
assign
=
function
(
a
)
{
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
a
[
i
]
)
;
return
dst
;
}
;
deMath
.
max
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
Math
.
max
(
a
[
i
]
b
[
i
]
)
)
;
return
dst
;
}
;
deMath
.
min
=
function
(
a
b
)
{
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
Arrays
must
have
the
same
size
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
Math
.
min
(
a
[
i
]
b
[
i
]
)
)
;
return
dst
;
}
;
deMath
.
rint
=
function
(
a
)
{
var
floorVal
=
Math
.
floor
(
a
)
;
var
fracVal
=
a
-
floorVal
;
if
(
fracVal
!
=
0
.
5
)
return
Math
.
round
(
a
)
;
var
roundUp
=
(
floorVal
%
2
)
!
=
0
;
return
floorVal
+
(
roundUp
?
1
:
0
)
;
}
;
deMath
.
wrap
=
function
(
v
minValue
maxValue
)
{
var
range
=
maxValue
-
minValue
+
1
;
if
(
v
<
minValue
)
{
v
+
=
range
*
(
Math
.
floor
(
(
minValue
-
v
)
/
range
)
+
1
)
;
}
return
minValue
+
Math
.
floor
(
(
v
-
minValue
)
%
range
)
;
}
;
deMath
.
intCast
=
function
(
a
)
{
var
v
;
if
(
a
>
=
0
)
v
=
Math
.
floor
(
a
)
;
else
v
=
Math
.
ceil
(
a
)
;
return
deMath
.
wrap
(
v
-
0x80000000
0x7FFFFFFF
)
;
}
;
deMath
.
uintCast
=
function
(
a
)
{
var
v
;
if
(
a
>
=
0
)
v
=
Math
.
floor
(
a
)
;
else
v
=
Math
.
ceil
(
a
)
;
return
deMath
.
wrap
(
v
0
0xFFFFFFFF
)
;
}
;
deMath
.
logToFloor
=
function
(
a
)
{
assertMsgOptions
(
a
>
0
'
Value
is
less
or
equal
than
zero
'
false
true
)
;
return
31
-
deMath
.
clz32
(
a
)
;
}
;
deMath
.
intersect
=
function
(
a
b
)
{
if
(
a
.
length
!
=
4
)
throw
new
Error
(
'
Array
"
a
"
must
have
length
4
but
has
length
:
'
+
a
.
length
)
;
if
(
b
.
length
!
=
4
)
throw
new
Error
(
'
Array
"
b
"
must
have
length
4
but
has
length
:
'
+
b
.
length
)
;
var
x0
=
Math
.
max
(
a
[
0
]
b
[
0
]
)
;
var
y0
=
Math
.
max
(
a
[
1
]
b
[
1
]
)
;
var
x1
=
Math
.
min
(
a
[
0
]
+
a
[
2
]
b
[
0
]
+
b
[
2
]
)
;
var
y1
=
Math
.
min
(
a
[
1
]
+
a
[
3
]
b
[
1
]
+
b
[
3
]
)
;
var
w
=
Math
.
max
(
0
x1
-
x0
)
;
var
h
=
Math
.
max
(
0
y1
-
y0
)
;
return
[
x0
y0
w
h
]
;
}
;
deMath
.
deMathHash
=
function
(
a
)
{
var
key
=
a
;
key
=
(
key
^
61
)
^
(
key
>
>
16
)
;
key
=
key
+
(
key
<
<
3
)
;
key
=
key
^
(
key
>
>
4
)
;
key
=
key
*
0x27d4eb2d
;
key
=
key
^
(
key
>
>
15
)
;
return
key
;
}
;
deMath
.
arrayToNumber
=
function
(
array
)
{
DE_ASSERT
(
array
.
length
<
=
6
|
|
(
array
.
length
=
=
6
&
&
array
[
5
]
<
=
127
)
)
;
var
result
=
0
;
for
(
var
ndx
=
0
;
ndx
<
array
.
length
;
ndx
+
+
)
{
result
+
=
array
[
ndx
]
*
Math
.
pow
(
256
ndx
)
;
}
return
result
;
}
;
deMath
.
numberToArray
=
function
(
array
number
)
{
DE_ASSERT
(
Number
.
isInteger
(
number
)
)
;
for
(
var
byteNdx
=
0
;
byteNdx
<
array
.
length
;
byteNdx
+
+
)
{
var
acumzndx
=
!
byteNdx
?
number
:
Math
.
floor
(
number
/
Math
.
pow
(
256
byteNdx
)
)
;
array
[
byteNdx
]
=
acumzndx
&
0xFF
;
}
}
;
deMath
.
getBitRange
=
function
(
x
firstNdx
lastNdx
)
{
DE_ASSERT
(
lastNdx
-
firstNdx
<
=
52
)
;
var
shifted
=
deMath
.
shiftRight
(
x
firstNdx
)
;
var
bitSize
=
lastNdx
-
firstNdx
;
var
mask
;
if
(
bitSize
<
32
)
mask
=
(
1
<
<
bitSize
)
-
1
;
else
mask
=
Math
.
pow
(
2
bitSize
)
-
1
;
var
masked
=
deMath
.
binaryAnd
(
shifted
mask
)
;
return
masked
;
}
;
deMath
.
getArray32BitRange
=
function
(
array
firstNdx
lastNdx
)
{
DE_ASSERT
(
0
<
=
firstNdx
&
&
firstNdx
<
(
array
.
length
*
32
)
)
;
DE_ASSERT
(
0
<
lastNdx
&
&
lastNdx
<
=
(
array
.
length
*
32
)
)
;
DE_ASSERT
(
(
lastNdx
-
firstNdx
)
<
=
52
)
;
var
blockIndexA
=
Math
.
floor
(
firstNdx
/
32
)
;
var
bitsToBeginningOfBlock
=
firstNdx
%
32
;
var
blockIndexB
=
Math
.
floor
(
(
lastNdx
-
1
)
/
32
)
;
var
bitsFromEndOfBlock
=
31
-
(
(
lastNdx
-
1
)
%
32
)
;
var
blockB
=
array
[
blockIndexB
]
;
var
blockBTruncated
=
(
blockB
<
<
bitsFromEndOfBlock
)
>
>
>
bitsFromEndOfBlock
;
if
(
blockIndexA
=
=
blockIndexB
)
{
return
blockBTruncated
>
>
>
bitsToBeginningOfBlock
;
}
else
{
var
blockA
=
array
[
blockIndexA
]
;
var
blockATruncated
=
blockA
>
>
>
bitsToBeginningOfBlock
;
var
blockATruncatedLength
=
32
-
bitsToBeginningOfBlock
;
return
blockATruncated
+
(
blockBTruncated
*
Math
.
pow
(
2
blockATruncatedLength
)
)
;
}
}
;
deMath
.
split32
=
function
(
x
)
{
var
ret
=
[
]
;
ret
[
1
]
=
Math
.
floor
(
x
/
0x100000000
)
;
ret
[
0
]
=
x
-
ret
[
1
]
*
0x100000000
;
return
ret
;
}
;
deMath
.
split16
=
function
(
x
)
{
var
ret
=
[
]
;
x
=
x
&
0xffffffff
;
ret
[
1
]
=
Math
.
floor
(
x
/
0x10000
)
;
ret
[
0
]
=
x
-
ret
[
1
]
*
0x10000
;
return
ret
;
}
;
deMath
.
join32
=
function
(
x
)
{
var
v0
=
x
[
0
]
>
=
0
?
x
[
0
]
:
0x100000000
+
x
[
0
]
;
var
v1
=
x
[
1
]
;
var
val
=
v1
*
0x100000000
+
v0
;
return
val
;
}
;
deMath
.
BinaryOp
=
{
AND
:
0
OR
:
1
XOR
:
2
}
;
deMath
.
doNativeBinaryOp
=
function
(
valueA
valueB
operation
)
{
switch
(
operation
)
{
case
deMath
.
BinaryOp
.
AND
:
return
valueA
&
valueB
;
case
deMath
.
BinaryOp
.
OR
:
return
valueA
|
valueB
;
case
deMath
.
BinaryOp
.
XOR
:
return
valueA
^
valueB
;
default
:
throw
new
Error
(
'
Unknown
operation
:
'
+
operation
)
;
}
}
;
deMath
.
binaryOp
=
function
(
valueA
valueB
binaryOpParm
)
{
if
(
deMath
.
deInRange32
(
valueA
-
0x80000000
0x7FFFFFFF
)
&
&
deMath
.
deInRange32
(
valueB
-
0x80000000
0x7FFFFFFF
)
)
return
deMath
.
doNativeBinaryOp
(
valueA
valueB
binaryOpParm
)
;
var
x
=
deMath
.
split32
(
valueA
)
;
var
y
=
deMath
.
split32
(
valueB
)
;
var
z
=
[
]
;
for
(
var
i
=
0
;
i
<
2
;
i
+
+
)
z
[
i
]
=
deMath
.
doNativeBinaryOp
(
x
[
i
]
y
[
i
]
binaryOpParm
)
;
var
ret
=
deMath
.
join32
(
z
)
;
return
ret
;
}
;
deMath
.
binaryAnd
=
function
(
a
b
)
{
return
deMath
.
binaryOp
(
a
b
deMath
.
BinaryOp
.
AND
)
;
}
;
deMath
.
binaryAndVecScalar
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
First
argument
must
be
an
array
.
'
)
;
if
(
typeof
b
!
=
=
'
number
'
)
throw
new
Error
(
'
Second
argument
must
be
a
number
.
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
deMath
.
binaryOp
(
a
[
i
]
b
deMath
.
BinaryOp
.
AND
)
)
;
return
dst
;
}
;
deMath
.
binaryOr
=
function
(
a
b
)
{
return
deMath
.
binaryOp
(
a
b
deMath
.
BinaryOp
.
OR
)
;
}
;
deMath
.
binaryOrVecScalar
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
First
argument
must
be
an
array
.
'
)
;
if
(
typeof
b
!
=
=
'
number
'
)
throw
new
Error
(
'
Second
argument
must
be
a
number
.
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
deMath
.
binaryOp
(
a
[
i
]
b
deMath
.
BinaryOp
.
OR
)
)
;
return
dst
;
}
;
deMath
.
binaryXor
=
function
(
a
b
)
{
return
deMath
.
binaryOp
(
a
b
deMath
.
BinaryOp
.
XOR
)
;
}
;
deMath
.
binaryXorVecScalar
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
First
argument
must
be
an
array
.
'
)
;
if
(
typeof
b
!
=
=
'
number
'
)
throw
new
Error
(
'
Second
argument
must
be
a
number
.
'
)
;
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
deMath
.
binaryOp
(
a
[
i
]
b
deMath
.
BinaryOp
.
XOR
)
)
;
return
dst
;
}
;
deMath
.
binaryNot
=
function
(
value
)
{
if
(
deMath
.
deInRange32
(
value
-
0x80000000
0x7FFFFFFF
)
)
return
~
value
;
var
x
=
deMath
.
split32
(
value
)
;
x
[
0
]
=
~
x
[
0
]
;
x
[
1
]
=
~
x
[
1
]
;
var
ret
=
deMath
.
join32
(
x
)
;
return
ret
;
}
;
deMath
.
shiftLeft
=
function
(
value
steps
)
{
if
(
steps
<
31
)
{
var
v
=
value
*
(
1
<
<
steps
)
;
if
(
deMath
.
deInRange32
(
v
-
0x80000000
0x7FFFFFFF
)
)
return
v
;
}
if
(
steps
=
=
0
)
return
value
;
else
if
(
steps
<
32
)
{
var
mask
=
(
1
<
<
32
-
steps
)
-
1
;
var
x
=
deMath
.
split32
(
value
)
;
var
highBits
=
x
[
0
]
&
(
~
mask
)
;
var
y
=
highBits
>
>
(
32
-
steps
)
;
if
(
highBits
<
0
)
{
var
m
=
(
1
<
<
steps
)
-
1
;
y
&
=
m
;
}
var
result
=
[
]
;
result
[
0
]
=
x
[
0
]
<
<
steps
;
result
[
1
]
=
x
[
1
]
<
<
steps
;
result
[
1
]
|
=
y
;
return
deMath
.
join32
(
result
)
;
}
else
{
var
x
=
deMath
.
split32
(
value
)
;
var
result
=
[
]
;
result
[
0
]
=
0
;
result
[
1
]
=
x
[
0
]
<
<
steps
-
32
;
return
deMath
.
join32
(
result
)
;
}
}
;
deMath
.
shiftLeftVecScalar
=
function
(
a
b
)
{
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
deMath
.
shiftLeft
(
a
[
i
]
b
)
)
;
return
dst
;
}
;
deMath
.
shiftRight
=
function
(
value
steps
)
{
if
(
deMath
.
deInRange32
(
value
-
0x80000000
0x7FFFFFFF
)
&
&
steps
<
32
)
return
value
>
>
steps
;
if
(
steps
=
=
0
)
return
value
;
else
if
(
steps
<
32
)
{
if
(
steps
=
=
0
)
return
value
;
var
mask
=
(
1
<
<
steps
)
-
1
;
var
x
=
deMath
.
split32
(
value
)
;
var
lowBits
=
x
[
1
]
&
mask
;
var
result
=
[
]
;
var
m
=
(
1
<
<
32
-
steps
)
-
1
;
result
[
0
]
=
(
x
[
0
]
>
>
steps
)
&
m
;
result
[
1
]
=
x
[
1
]
>
>
steps
;
result
[
0
]
|
=
lowBits
<
<
32
-
steps
;
return
deMath
.
join32
(
result
)
;
}
else
{
var
x
=
deMath
.
split32
(
value
)
;
var
result
=
[
]
;
result
[
0
]
=
x
[
1
]
>
>
steps
-
32
;
result
[
1
]
=
value
<
0
?
-
1
:
0
;
return
deMath
.
join32
(
result
)
;
}
}
;
deMath
.
shiftRightVecScalar
=
function
(
a
b
)
{
var
dst
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
dst
.
push
(
deMath
.
shiftRight
(
a
[
i
]
b
)
)
;
return
dst
;
}
;
deMath
.
logicalAndBool
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
The
first
parameter
is
not
an
array
:
(
'
+
typeof
(
a
)
+
'
)
'
+
a
)
;
if
(
!
Array
.
isArray
(
b
)
)
throw
new
Error
(
'
The
second
parameter
is
not
an
array
:
(
'
+
typeof
(
b
)
+
'
)
'
+
b
)
;
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
The
lengths
of
the
passed
arrays
are
not
equivalent
.
(
'
+
a
.
length
+
'
!
=
'
+
b
.
length
+
'
)
'
)
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
if
(
a
[
i
]
&
b
[
i
]
)
result
.
push
(
true
)
;
else
result
.
push
(
false
)
;
}
return
result
;
}
;
deMath
.
logicalOrBool
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
The
first
parameter
is
not
an
array
:
(
'
+
typeof
(
a
)
+
'
)
'
+
a
)
;
if
(
!
Array
.
isArray
(
b
)
)
throw
new
Error
(
'
The
second
parameter
is
not
an
array
:
(
'
+
typeof
(
b
)
+
'
)
'
+
b
)
;
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
The
lengths
of
the
passed
arrays
are
not
equivalent
.
(
'
+
a
.
length
+
'
!
=
'
+
b
.
length
+
'
)
'
)
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
{
if
(
a
[
i
]
|
b
[
i
]
)
result
.
push
(
true
)
;
else
result
.
push
(
false
)
;
}
return
result
;
}
;
deMath
.
logicalNotBool
=
function
(
a
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
The
passed
value
is
not
an
array
:
(
'
+
typeof
(
a
)
+
'
)
'
+
a
)
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
result
.
push
(
!
a
[
i
]
)
;
return
result
;
}
;
deMath
.
greaterThan
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
The
first
parameter
is
not
an
array
:
(
'
+
typeof
(
a
)
+
'
)
'
+
a
)
;
if
(
!
Array
.
isArray
(
b
)
)
throw
new
Error
(
'
The
second
parameter
is
not
an
array
:
(
'
+
typeof
(
b
)
+
'
)
'
+
b
)
;
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
The
lengths
of
the
passed
arrays
are
not
equivalent
.
(
'
+
a
.
length
+
'
!
=
'
+
b
.
length
+
'
)
'
)
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
result
.
push
(
a
[
i
]
>
b
[
i
]
)
;
return
result
;
}
;
deMath
.
greaterThanEqual
=
function
(
a
b
)
{
if
(
!
Array
.
isArray
(
a
)
)
throw
new
Error
(
'
The
first
parameter
is
not
an
array
:
(
'
+
typeof
(
a
)
+
'
)
'
+
a
)
;
if
(
!
Array
.
isArray
(
b
)
)
throw
new
Error
(
'
The
second
parameter
is
not
an
array
:
(
'
+
typeof
(
b
)
+
'
)
'
+
b
)
;
if
(
a
.
length
!
=
b
.
length
)
throw
new
Error
(
'
The
lengths
of
the
passed
arrays
are
not
equivalent
.
(
'
+
a
.
length
+
'
!
=
'
+
b
.
length
+
'
)
'
)
;
var
result
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
result
.
push
(
a
[
i
]
>
=
b
[
i
]
)
;
return
result
;
}
;
deMath
.
toIVec
=
function
(
a
)
{
var
res
=
[
]
;
for
(
var
i
=
0
;
i
<
a
.
length
;
i
+
+
)
res
.
push
(
deMath
.
clamp
(
Math
.
floor
(
a
[
i
]
*
255
)
0
255
)
)
;
return
res
;
}
;
deMath
.
clz32
=
function
(
a
)
{
var
maxValue
=
2147483648
;
var
leadingZeros
=
0
;
while
(
a
<
maxValue
)
{
maxValue
=
maxValue
>
>
>
1
;
leadingZeros
+
+
;
}
return
leadingZeros
;
}
;
deMath
.
deLdExp
=
function
(
a
exponent
)
{
return
deMath
.
ldexp
(
a
exponent
)
;
}
;
deMath
.
deFloatLdExp
=
function
(
a
exponent
)
{
return
deMath
.
ldexp
(
a
exponent
)
;
}
;
deMath
.
frexp
=
(
function
(
)
{
var
data
=
new
DataView
(
new
ArrayBuffer
(
8
)
)
;
return
function
(
value
)
{
if
(
value
=
=
=
0
)
return
[
value
0
]
;
data
.
setFloat64
(
0
value
)
;
var
bits
=
(
data
.
getUint32
(
0
)
>
>
>
20
)
&
0x7FF
;
if
(
bits
=
=
=
0
)
{
data
.
setFloat64
(
0
value
*
Math
.
pow
(
2
64
)
)
;
bits
=
(
(
data
.
getUint32
(
0
)
>
>
>
20
)
&
0x7FF
)
-
64
;
}
var
exponent
=
bits
-
1022
mantissa
=
deMath
.
ldexp
(
value
-
exponent
)
;
return
[
mantissa
exponent
]
;
}
}
)
(
)
;
deMath
.
ldexp
=
function
(
mantissa
exponent
)
{
return
exponent
>
1023
?
mantissa
*
Math
.
pow
(
2
1023
)
*
Math
.
pow
(
2
exponent
-
1023
)
:
exponent
<
-
1074
?
mantissa
*
Math
.
pow
(
2
-
1074
)
*
Math
.
pow
(
2
exponent
+
1074
)
:
mantissa
*
Math
.
pow
(
2
exponent
)
;
}
;
deMath
.
deCbrt
=
function
(
a
)
{
return
deMath
.
deSign
(
a
)
*
Math
.
pow
(
Math
.
abs
(
a
)
1
.
0
/
3
.
0
)
;
}
;
deMath
.
deSign
=
function
(
x
)
{
return
isNaN
(
x
)
?
x
:
(
(
x
>
0
.
0
)
-
(
x
<
0
.
0
)
)
;
}
;
deMath
.
deFractExp
=
function
(
x
)
{
var
result
=
{
significand
:
x
exponent
:
0
}
;
if
(
isFinite
(
x
)
)
{
var
r
=
deMath
.
frexp
(
x
)
;
result
.
exponent
=
r
[
1
]
-
1
;
result
.
significand
=
r
[
0
]
*
2
;
}
return
result
;
}
;
}
)
;
