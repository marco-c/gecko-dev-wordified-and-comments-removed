'
use
strict
'
;
goog
.
provide
(
'
framework
.
opengl
.
simplereference
.
sglrShaderProgram
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTexture
'
)
;
goog
.
require
(
'
framework
.
common
.
tcuTextureUtil
'
)
;
goog
.
require
(
'
framework
.
delibs
.
debase
.
deMath
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluTextureUtil
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrDefs
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrFragmentOperations
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrGenericVector
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrShaders
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrShadingContext
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexAttrib
'
)
;
goog
.
require
(
'
framework
.
referencerenderer
.
rrVertexPacket
'
)
;
goog
.
scope
(
function
(
)
{
var
sglrShaderProgram
=
framework
.
opengl
.
simplereference
.
sglrShaderProgram
;
var
rrShaders
=
framework
.
referencerenderer
.
rrShaders
;
var
rrGenericVector
=
framework
.
referencerenderer
.
rrGenericVector
;
var
tcuTexture
=
framework
.
common
.
tcuTexture
;
var
deMath
=
framework
.
delibs
.
debase
.
deMath
;
var
gluTextureUtil
=
framework
.
opengl
.
gluTextureUtil
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
var
tcuTextureUtil
=
framework
.
common
.
tcuTextureUtil
;
var
rrDefs
=
framework
.
referencerenderer
.
rrDefs
;
var
rrFragmentOperations
=
framework
.
referencerenderer
.
rrFragmentOperations
;
var
rrVertexAttrib
=
framework
.
referencerenderer
.
rrVertexAttrib
;
var
rrVertexPacket
=
framework
.
referencerenderer
.
rrVertexPacket
;
var
rrShadingContext
=
framework
.
referencerenderer
.
rrShadingContext
;
var
DE_ASSERT
=
function
(
x
)
{
if
(
!
x
)
throw
new
Error
(
'
Assert
failed
'
)
;
}
;
sglrShaderProgram
.
VaryingFlags
=
function
(
)
{
this
.
NONE
=
true
;
this
.
FLATSHADE
=
false
;
}
;
sglrShaderProgram
.
VertexAttribute
=
function
(
name_
type_
)
{
this
.
name
=
name_
;
this
.
type
=
type_
;
}
;
sglrShaderProgram
.
VertexToFragmentVarying
=
function
(
type_
flags
)
{
this
.
type
=
type_
;
this
.
flatshade
=
flags
=
=
=
undefined
?
new
sglrShaderProgram
.
VaryingFlags
(
)
.
FLATSHADE
:
flags
.
FLATSHADE
;
}
;
sglrShaderProgram
.
FragmentOutput
=
function
(
type_
)
{
this
.
type
=
type_
;
}
;
sglrShaderProgram
.
Uniform
=
function
(
name_
type_
)
{
this
.
name
=
name_
;
this
.
type
=
type_
;
this
.
value
;
this
.
sampler
=
null
;
}
;
sglrShaderProgram
.
VertexSource
=
function
(
str
)
{
this
.
source
=
str
;
}
;
sglrShaderProgram
.
FragmentSource
=
function
(
str
)
{
this
.
source
=
str
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
=
function
(
)
{
this
.
m_vertexAttributes
=
[
]
;
this
.
m_vertexToFragmentVaryings
=
[
]
;
this
.
m_fragmentOutputs
=
[
]
;
this
.
m_uniforms
=
[
]
;
this
.
m_vertexSource
;
this
.
m_fragmentSource
;
this
.
m_vertexShaderSet
=
false
;
this
.
m_fragmentShaderSet
=
false
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
pushVertexAttribute
=
function
(
v
)
{
this
.
m_vertexAttributes
.
push
(
v
)
;
return
this
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
pushVertexToFragmentVarying
=
function
(
v
)
{
this
.
m_vertexToFragmentVaryings
.
push
(
v
)
;
return
this
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
pushFragmentOutput
=
function
(
v
)
{
this
.
m_fragmentOutputs
.
push
(
v
)
;
return
this
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
pushUniform
=
function
(
v
)
{
this
.
m_uniforms
.
push
(
v
)
;
return
this
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
pushVertexSource
=
function
(
c
)
{
DE_ASSERT
(
!
this
.
m_vertexShaderSet
)
;
this
.
m_vertexSource
=
c
.
source
;
this
.
m_vertexShaderSet
=
true
;
return
this
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
pushFragmentSource
=
function
(
c
)
{
DE_ASSERT
(
!
this
.
m_fragmentSource
)
;
this
.
m_fragmentSource
=
c
.
source
;
this
.
m_fragmentShaderSet
=
true
;
return
this
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
valid
=
function
(
)
{
if
(
!
this
.
m_vertexShaderSet
|
|
!
this
.
m_fragmentShaderSet
)
return
false
;
if
(
this
.
m_fragmentOutputs
.
length
=
=
0
)
return
false
;
return
true
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
getVertexInputCount
=
function
(
)
{
return
this
.
m_vertexAttributes
.
length
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
getVertexOutputCount
=
function
(
)
{
return
this
.
m_vertexToFragmentVaryings
.
length
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
getFragmentInputCount
=
function
(
)
{
return
this
.
m_vertexToFragmentVaryings
.
length
;
}
;
sglrShaderProgram
.
ShaderProgramDeclaration
.
prototype
.
getFragmentOutputCount
=
function
(
)
{
return
this
.
m_fragmentOutputs
.
length
;
}
;
sglrShaderProgram
.
ShaderProgram
=
function
(
decl
)
{
this
.
vertexShader
=
new
rrShaders
.
VertexShader
(
decl
.
getVertexInputCount
(
)
decl
.
getVertexOutputCount
(
)
)
;
this
.
fragmentShader
=
new
rrShaders
.
FragmentShader
(
decl
.
getFragmentInputCount
(
)
decl
.
getFragmentOutputCount
(
)
)
;
this
.
m_attributeNames
=
[
]
;
this
.
m_uniforms
=
[
]
;
this
.
m_vertSrc
=
decl
.
m_vertexSource
;
this
.
m_fragSrc
=
decl
.
m_fragmentSource
;
DE_ASSERT
(
decl
.
valid
(
)
)
;
for
(
var
ndx
=
0
;
ndx
<
decl
.
m_vertexAttributes
.
length
;
+
+
ndx
)
{
this
.
vertexShader
.
m_inputs
[
ndx
]
.
type
=
decl
.
m_vertexAttributes
[
ndx
]
.
type
;
this
.
m_attributeNames
[
ndx
]
=
decl
.
m_vertexAttributes
[
ndx
]
.
name
;
}
for
(
var
ndx
=
0
;
ndx
<
decl
.
m_vertexToFragmentVaryings
.
length
;
+
+
ndx
)
{
this
.
vertexShader
.
m_outputs
[
ndx
]
.
type
=
decl
.
m_vertexToFragmentVaryings
[
ndx
]
.
type
;
this
.
vertexShader
.
m_outputs
[
ndx
]
.
flatshade
=
decl
.
m_vertexToFragmentVaryings
[
ndx
]
.
flatshade
;
this
.
fragmentShader
.
m_inputs
[
ndx
]
=
this
.
vertexShader
.
m_outputs
[
ndx
]
;
}
for
(
var
ndx
=
0
;
ndx
<
decl
.
m_fragmentOutputs
.
length
;
+
+
ndx
)
this
.
fragmentShader
.
m_outputs
[
ndx
]
.
type
=
decl
.
m_fragmentOutputs
[
ndx
]
.
type
;
for
(
var
ndx
=
0
;
ndx
<
decl
.
m_uniforms
.
length
;
+
+
ndx
)
this
.
m_uniforms
[
ndx
]
=
new
sglrShaderProgram
.
Uniform
(
decl
.
m_uniforms
[
ndx
]
.
name
decl
.
m_uniforms
[
ndx
]
.
type
)
;
}
;
sglrShaderProgram
.
ShaderProgram
.
prototype
.
getVertexShader
=
function
(
)
{
return
this
.
vertexShader
;
}
;
sglrShaderProgram
.
ShaderProgram
.
prototype
.
getFragmentShader
=
function
(
)
{
return
this
.
fragmentShader
;
}
;
sglrShaderProgram
.
ShaderProgram
.
prototype
.
getUniformByName
=
function
(
name
)
{
DE_ASSERT
(
name
)
;
for
(
var
ndx
=
0
;
ndx
<
this
.
m_uniforms
.
length
;
+
+
ndx
)
if
(
this
.
m_uniforms
[
ndx
]
.
name
=
=
name
)
return
this
.
m_uniforms
[
ndx
]
;
throw
new
Error
(
'
Invalid
uniform
name
uniform
not
found
.
'
)
;
}
;
sglrShaderProgram
.
ShaderProgram
.
prototype
.
shadeFragments
=
function
(
packets
context
)
{
throw
new
Error
(
'
This
function
needs
to
be
overwritten
in
a
child
class
.
'
)
;
}
;
sglrShaderProgram
.
ShaderProgram
.
prototype
.
shadeVertices
=
function
(
inputs
packets
numPackets
)
{
throw
new
Error
(
'
This
function
needs
to
be
overwritten
in
a
child
class
.
'
)
;
}
;
}
)
;
