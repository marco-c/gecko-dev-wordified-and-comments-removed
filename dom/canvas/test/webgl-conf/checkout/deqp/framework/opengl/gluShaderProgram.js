'
use
strict
'
;
goog
.
provide
(
'
framework
.
opengl
.
gluShaderProgram
'
)
;
goog
.
scope
(
function
(
)
{
var
gluShaderProgram
=
framework
.
opengl
.
gluShaderProgram
;
gluShaderProgram
.
shaderType
=
{
VERTEX
:
0
FRAGMENT
:
1
}
;
gluShaderProgram
.
getShaderTypeName
=
function
(
shaderType
)
{
var
s_names
=
[
'
vertex
'
'
fragment
'
]
;
return
s_names
[
shaderType
]
;
}
;
gluShaderProgram
.
getGLShaderType
=
function
(
gl
type
)
{
var
_glShaderType
;
switch
(
type
)
{
case
gluShaderProgram
.
shaderType
.
VERTEX
:
_glShaderType
=
gl
.
VERTEX_SHADER
;
break
;
case
gluShaderProgram
.
shaderType
.
FRAGMENT
:
_glShaderType
=
gl
.
FRAGMENT_SHADER
;
break
;
default
:
throw
new
Error
(
'
Unknown
shader
type
'
+
type
)
;
}
return
_glShaderType
;
}
;
gluShaderProgram
.
ShaderInfo
=
function
(
type
source
)
{
this
.
type
=
type
;
this
.
source
=
source
;
this
.
infoLog
;
this
.
compileOk
=
false
;
this
.
compileTimeUs
=
0
;
}
;
gluShaderProgram
.
genVertexSource
=
function
(
source
)
{
var
shader
=
new
gluShaderProgram
.
ShaderInfo
(
gluShaderProgram
.
shaderType
.
VERTEX
source
)
;
return
shader
;
}
;
gluShaderProgram
.
genFragmentSource
=
function
(
source
)
{
var
shader
=
new
gluShaderProgram
.
ShaderInfo
(
gluShaderProgram
.
shaderType
.
FRAGMENT
source
)
;
return
shader
;
}
;
gluShaderProgram
.
Shader
=
function
(
gl
type
)
{
this
.
gl
=
gl
;
this
.
info
=
new
gluShaderProgram
.
ShaderInfo
(
type
)
;
this
.
shader
=
gl
.
createShader
(
gluShaderProgram
.
getGLShaderType
(
gl
type
)
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
gl
.
NO_ERROR
'
gl
.
createShader
(
)
'
false
true
)
;
this
.
setSources
=
function
(
source
)
{
this
.
gl
.
shaderSource
(
this
.
shader
source
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
glshaderSource
(
)
'
false
true
)
;
this
.
info
.
source
=
source
;
}
;
this
.
getCompileStatus
=
function
(
)
{
return
this
.
info
.
compileOk
;
}
;
this
.
compile
=
function
(
)
{
this
.
info
.
compileOk
=
false
;
this
.
info
.
compileTimeUs
=
0
;
this
.
info
.
infoLog
=
'
'
;
var
compileStart
=
new
Date
(
)
;
this
.
gl
.
compileShader
(
this
.
shader
)
;
var
compileEnd
=
new
Date
(
)
;
this
.
info
.
compileTimeUs
=
1000
*
(
compileEnd
.
getTime
(
)
-
compileStart
.
getTime
(
)
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
gl
.
compileShader
(
)
'
false
true
)
;
var
compileStatus
=
this
.
gl
.
getShaderParameter
(
this
.
shader
this
.
gl
.
COMPILE_STATUS
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
glGetShaderParameter
(
)
'
false
true
)
;
this
.
info
.
compileOk
=
compileStatus
;
this
.
info
.
infoLog
=
this
.
gl
.
getShaderInfoLog
(
this
.
shader
)
;
}
;
this
.
getShader
=
function
(
)
{
return
this
.
shader
;
}
;
this
.
destroy
=
function
(
)
{
this
.
gl
.
deleteShader
(
this
.
shader
)
;
}
;
}
;
gluShaderProgram
.
ProgramInfo
=
function
(
)
{
this
.
infoLog
=
'
'
;
this
.
linkOk
=
false
;
this
.
linkTimeUs
=
0
;
}
;
gluShaderProgram
.
Program
=
function
(
gl
programID
)
{
this
.
gl
=
gl
;
this
.
program
=
programID
|
|
null
;
this
.
info
=
new
gluShaderProgram
.
ProgramInfo
(
)
;
if
(
!
programID
)
{
this
.
program
=
gl
.
createProgram
(
)
;
assertMsgOptions
(
gl
.
getError
(
)
=
=
gl
.
NO_ERROR
'
gl
.
createProgram
(
)
'
false
true
)
;
}
}
;
gluShaderProgram
.
Program
.
prototype
.
getProgram
=
function
(
)
{
return
this
.
program
;
}
;
gluShaderProgram
.
Program
.
prototype
.
getInfo
=
function
(
)
{
return
this
.
info
;
}
;
gluShaderProgram
.
Program
.
prototype
.
attachShader
=
function
(
shader
)
{
this
.
gl
.
attachShader
(
this
.
program
shader
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
gl
.
attachShader
(
)
'
false
true
)
;
}
;
gluShaderProgram
.
Program
.
prototype
.
detachShader
=
function
(
shader
)
{
this
.
gl
.
detachShader
(
this
.
program
shader
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
gl
.
detachShader
(
)
'
false
true
)
;
}
;
gluShaderProgram
.
Program
.
prototype
.
bindAttribLocation
=
function
(
location
name
)
{
this
.
gl
.
bindAttribLocation
(
this
.
program
location
name
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
gl
.
bindAttribLocation
(
)
'
false
true
)
;
}
;
gluShaderProgram
.
Program
.
prototype
.
link
=
function
(
)
{
this
.
info
.
linkOk
=
false
;
this
.
info
.
linkTimeUs
=
0
;
this
.
info
.
infoLog
=
'
'
;
var
linkStart
=
new
Date
(
)
;
this
.
gl
.
linkProgram
(
this
.
program
)
;
var
linkEnd
=
new
Date
(
)
;
this
.
info
.
linkTimeUs
=
1000
*
(
linkEnd
.
getTime
(
)
-
linkStart
.
getTime
(
)
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
gl
.
linkProgram
(
)
'
false
true
)
;
var
linkStatus
=
this
.
gl
.
getProgramParameter
(
this
.
program
this
.
gl
.
LINK_STATUS
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
gl
.
getProgramParameter
(
)
'
false
true
)
;
this
.
info
.
linkOk
=
linkStatus
;
this
.
info
.
infoLog
=
this
.
gl
.
getProgramInfoLog
(
this
.
program
)
;
}
;
gluShaderProgram
.
Program
.
prototype
.
getLinkStatus
=
function
(
)
{
return
this
.
info
.
linkOk
;
}
;
gluShaderProgram
.
Program
.
prototype
.
transformFeedbackVaryings
=
function
(
varyings
bufferMode
)
{
this
.
gl
.
transformFeedbackVaryings
(
this
.
program
varyings
bufferMode
)
;
assertMsgOptions
(
this
.
gl
.
getError
(
)
=
=
this
.
gl
.
NO_ERROR
'
gl
.
transformFeedbackVaryings
(
)
'
false
true
)
;
}
;
gluShaderProgram
.
ShaderProgram
=
function
(
gl
programSources
)
{
this
.
gl
=
gl
;
this
.
programSources
=
programSources
;
this
.
shaders
=
[
]
;
this
.
program
=
new
gluShaderProgram
.
Program
(
gl
)
;
this
.
shadersOK
=
true
;
for
(
var
i
=
0
;
i
<
programSources
.
sources
.
length
;
i
+
+
)
{
var
shader
=
new
gluShaderProgram
.
Shader
(
gl
programSources
.
sources
[
i
]
.
type
)
;
shader
.
setSources
(
programSources
.
sources
[
i
]
.
source
)
;
shader
.
compile
(
)
;
this
.
shaders
.
push
(
shader
)
;
this
.
shadersOK
=
this
.
shadersOK
&
&
shader
.
getCompileStatus
(
)
;
if
(
!
shader
.
getCompileStatus
(
)
)
{
console
.
log
(
'
gluShaderProgram
.
Shader
:
\
n
'
+
programSources
.
sources
[
i
]
.
source
)
;
console
.
log
(
'
Compile
status
:
'
+
shader
.
getCompileStatus
(
)
)
;
console
.
log
(
'
Shader
infoLog
:
'
+
shader
.
info
.
infoLog
)
;
}
}
if
(
this
.
shadersOK
)
{
for
(
var
i
=
0
;
i
<
this
.
shaders
.
length
;
i
+
+
)
this
.
program
.
attachShader
(
this
.
shaders
[
i
]
.
getShader
(
)
)
;
for
(
var
attrib
in
programSources
.
attribLocationBindings
)
this
.
program
.
bindAttribLocation
(
programSources
.
attribLocationBindings
[
attrib
]
attrib
)
;
if
(
programSources
.
transformFeedbackBufferMode
)
if
(
programSources
.
transformFeedbackBufferMode
=
=
=
gl
.
NONE
)
assertMsgOptions
(
programSources
.
transformFeedbackVaryings
.
length
=
=
=
0
'
Transform
feedback
sanity
check
'
false
true
)
;
else
this
.
program
.
transformFeedbackVaryings
(
programSources
.
transformFeedbackVaryings
programSources
.
transformFeedbackBufferMode
)
;
this
.
program
.
link
(
)
;
}
}
;
gluShaderProgram
.
ShaderProgram
.
prototype
.
getProgram
=
function
(
)
{
return
this
.
program
.
program
;
}
;
gluShaderProgram
.
ShaderProgram
.
prototype
.
getProgramInfo
=
function
(
)
{
return
this
.
program
.
info
;
}
;
gluShaderProgram
.
ShaderProgram
.
prototype
.
isOk
=
function
(
)
{
return
this
.
shadersOK
&
&
this
.
program
.
getLinkStatus
(
)
;
}
;
gluShaderProgram
.
containerTypes
=
{
ATTRIB_LOCATION_BINDING
:
0
TRANSFORM_FEEDBACK_MODE
:
1
TRANSFORM_FEEDBACK_VARYING
:
2
TRANSFORM_FEEDBACK_VARYINGS
:
3
SHADER_SOURCE
:
4
PROGRAM_SEPARABLE
:
5
PROGRAM_SOURCES
:
6
CONTAINER_TYPE_LAST
:
7
ATTACHABLE_BEGIN
:
0
ATTACHABLE_END
:
5
+
1
}
;
gluShaderProgram
.
AttribLocationBinding
=
function
(
name
location
)
{
this
.
name
=
name
;
this
.
location
=
location
;
this
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
ATTRIB_LOCATION_BINDING
;
}
;
}
;
gluShaderProgram
.
TransformFeedbackMode
=
function
(
mode
)
{
this
.
mode
=
mode
;
this
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
TRANSFORM_FEEDBACK_MODE
;
}
;
}
;
gluShaderProgram
.
TransformFeedbackVarying
=
function
(
name
)
{
this
.
name
=
name
;
this
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
TRANSFORM_FEEDBACK_VARYING
;
}
;
}
;
gluShaderProgram
.
TransformFeedbackVaryings
=
function
(
array
)
{
this
.
array
=
array
;
this
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
TRANSFORM_FEEDBACK_VARYINGS
;
}
;
}
;
gluShaderProgram
.
ProgramSeparable
=
function
(
separable
)
{
this
.
separable
=
separable
;
this
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
PROGRAM_SEPARABLE
;
}
;
}
;
gluShaderProgram
.
VertexSource
=
function
(
str
)
{
this
.
shaderType
=
gluShaderProgram
.
shaderType
.
VERTEX
;
this
.
source
=
str
;
this
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
SHADER_SOURCE
;
}
;
}
;
gluShaderProgram
.
FragmentSource
=
function
(
str
)
{
this
.
shaderType
=
gluShaderProgram
.
shaderType
.
FRAGMENT
;
this
.
source
=
str
;
this
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
SHADER_SOURCE
;
}
;
}
;
gluShaderProgram
.
ProgramSources
=
function
(
)
{
this
.
sources
=
[
]
;
this
.
attribLocationBindings
=
[
]
;
this
.
transformFeedbackVaryings
=
[
]
;
this
.
transformFeedbackBufferMode
=
0
;
this
.
separable
=
false
;
}
;
gluShaderProgram
.
ProgramSources
.
prototype
.
getContainerType
=
function
(
)
{
return
gluShaderProgram
.
containerTypes
.
PROGRAM_SOURCES
;
}
;
gluShaderProgram
.
ProgramSources
.
prototype
.
add
=
function
(
item
)
{
var
type
=
undefined
;
if
(
typeof
(
item
.
getContainerType
)
=
=
'
function
'
)
{
type
=
item
.
getContainerType
(
)
;
if
(
typeof
(
type
)
!
=
'
number
'
|
|
type
<
gluShaderProgram
.
containerTypes
.
ATTACHABLE_BEGIN
|
|
type
>
=
gluShaderProgram
.
containerTypes
.
ATTACHABLE_END
)
{
type
=
undefined
;
}
}
switch
(
type
)
{
case
gluShaderProgram
.
containerTypes
.
ATTRIB_LOCATION_BINDING
:
this
.
attribLocationBindings
.
push
(
item
)
;
break
;
case
gluShaderProgram
.
containerTypes
.
TRANSFORM_FEEDBACK_MODE
:
this
.
transformFeedbackBufferMode
=
item
.
mode
;
break
;
case
gluShaderProgram
.
containerTypes
.
TRANSFORM_FEEDBACK_VARYING
:
this
.
transformFeedbackVaryings
.
push
(
item
.
name
)
;
break
;
case
gluShaderProgram
.
containerTypes
.
TRANSFORM_FEEDBACK_VARYINGS
:
this
.
transformFeedbackVaryings
=
this
.
transformFeedbackVaryings
.
concat
(
item
.
array
)
;
break
;
case
gluShaderProgram
.
containerTypes
.
SHADER_SOURCE
:
this
.
sources
.
push
(
new
gluShaderProgram
.
ShaderInfo
(
item
.
shaderType
item
.
source
)
)
;
break
;
case
gluShaderProgram
.
containerTypes
.
PROGRAM_SEPARABLE
:
this
.
separable
=
item
.
separable
;
break
;
default
:
throw
new
Error
(
'
Type
\
"
'
+
type
+
'
\
"
cannot
be
added
to
gluShaderProgram
.
ProgramSources
.
'
)
;
break
;
}
return
this
;
}
;
gluShaderProgram
.
makeVtxFragSources
=
function
(
vertexSrc
fragmentSrc
)
{
var
sources
=
new
gluShaderProgram
.
ProgramSources
(
)
;
sources
.
sources
.
push
(
gluShaderProgram
.
genVertexSource
(
vertexSrc
)
)
;
sources
.
sources
.
push
(
gluShaderProgram
.
genFragmentSource
(
fragmentSrc
)
)
;
return
sources
;
}
;
}
)
;
