'
use
strict
'
;
goog
.
provide
(
'
framework
.
opengl
.
gluVarType
'
)
;
goog
.
require
(
'
framework
.
opengl
.
gluShaderUtil
'
)
;
goog
.
scope
(
function
(
)
{
var
gluVarType
=
framework
.
opengl
.
gluVarType
;
var
gluShaderUtil
=
framework
.
opengl
.
gluShaderUtil
;
gluVarType
.
Type
=
{
TYPE_BASIC
:
0
TYPE_ARRAY
:
1
TYPE_STRUCT
:
2
}
;
gluVarType
.
TypeArray
=
function
(
elementType
arraySize
)
{
this
.
elementType
=
gluVarType
.
newClone
(
elementType
)
;
this
.
size
=
arraySize
;
}
;
gluVarType
.
VarType
=
function
(
)
{
this
.
m_flags
;
this
.
m_type
=
-
1
;
this
.
m_data
=
null
;
}
;
gluVarType
.
VarType
.
UNSIZED_ARRAY
=
-
1
;
gluVarType
.
VarType
.
prototype
.
VarTypeBasic
=
function
(
basicType
flags
)
{
this
.
m_type
=
gluVarType
.
Type
.
TYPE_BASIC
;
this
.
m_flags
=
flags
;
this
.
m_data
=
basicType
;
return
this
;
}
;
gluVarType
.
VarType
.
prototype
.
VarTypeBoolean
=
function
(
basicType
)
{
this
.
m_type
=
gluVarType
.
Type
.
TYPE_BASIC
;
this
.
m_data
=
basicType
;
return
this
;
}
;
gluVarType
.
VarType
.
prototype
.
VarTypeArray
=
function
(
elementType
arraySize
)
{
this
.
m_type
=
gluVarType
.
Type
.
TYPE_ARRAY
;
if
(
!
(
arraySize
>
=
0
|
|
arraySize
=
=
gluVarType
.
VarType
.
UNSIZED_ARRAY
)
)
throw
new
Error
(
'
Illegal
array
size
:
'
+
arraySize
)
;
this
.
m_data
=
new
gluVarType
.
TypeArray
(
elementType
arraySize
)
;
return
this
;
}
;
gluVarType
.
VarType
.
prototype
.
VarTypeStruct
=
function
(
structPtr
)
{
this
.
m_type
=
gluVarType
.
Type
.
TYPE_STRUCT
;
this
.
m_data
=
structPtr
;
return
this
;
}
;
gluVarType
.
VarType
.
prototype
.
VarTypeClone
=
function
(
object
)
{
this
.
m_type
=
object
.
m_type
;
switch
(
this
.
m_type
)
{
case
gluVarType
.
Type
.
TYPE_BASIC
:
this
.
m_flags
=
object
.
m_flags
;
this
.
m_data
=
object
.
m_data
;
break
;
case
gluVarType
.
Type
.
TYPE_BASIC
:
this
.
m_data
=
new
gluVarType
.
TypeArray
(
object
.
m_data
.
elementType
object
.
m_data
.
size
)
;
break
;
case
gluVarType
.
Type
.
TYPE_STRUCT
:
this
.
m_data
=
object
.
m_data
;
break
;
default
:
throw
new
Error
(
'
unknown
type
:
'
+
this
.
m_type
)
;
}
return
this
;
}
;
gluVarType
.
VarType
.
prototype
.
isBasicType
=
function
(
)
{
return
this
.
m_type
=
=
gluVarType
.
Type
.
TYPE_BASIC
;
}
;
gluVarType
.
VarType
.
prototype
.
isArrayType
=
function
(
)
{
return
this
.
m_type
=
=
gluVarType
.
Type
.
TYPE_ARRAY
;
}
;
gluVarType
.
VarType
.
prototype
.
isStructType
=
function
(
)
{
return
this
.
m_type
=
=
gluVarType
.
Type
.
TYPE_STRUCT
;
}
;
gluVarType
.
VarType
.
prototype
.
getFlags
=
function
(
)
{
return
this
.
m_flags
;
}
;
gluVarType
.
VarType
.
prototype
.
getBasicType
=
function
(
)
{
if
(
!
this
.
isBasicType
(
)
)
throw
new
Error
(
'
VarType
is
not
a
basic
type
.
'
)
;
return
(
this
.
m_data
)
;
}
;
gluVarType
.
VarType
.
prototype
.
getPrecision
=
function
(
)
{
if
(
!
this
.
isBasicType
(
)
)
throw
new
Error
(
'
VarType
is
not
a
basic
type
.
'
)
;
return
this
.
m_flags
;
}
;
gluVarType
.
VarType
.
prototype
.
getElementType
=
function
(
)
{
if
(
!
this
.
isArrayType
(
)
)
throw
new
Error
(
'
VarType
is
not
an
array
type
.
'
)
;
return
this
.
m_data
.
elementType
;
}
;
gluVarType
.
VarType
.
prototype
.
getArraySize
=
function
(
)
{
if
(
!
this
.
isArrayType
(
)
)
throw
new
Error
(
'
VarType
is
not
an
array
type
.
'
)
;
return
this
.
m_data
.
size
;
}
;
gluVarType
.
VarType
.
prototype
.
getStruct
=
function
(
)
{
if
(
!
this
.
isStructType
(
)
)
throw
new
Error
(
'
VarType
is
not
a
struct
type
.
'
)
;
return
(
this
.
m_data
)
;
}
;
gluVarType
.
VarType
.
prototype
.
getScalarSize
=
function
(
)
{
switch
(
this
.
m_type
)
{
case
gluVarType
.
Type
.
TYPE_BASIC
:
{
return
gluShaderUtil
.
getDataTypeScalarSize
(
(
this
.
getBasicType
(
)
)
)
;
}
case
gluVarType
.
Type
.
TYPE_ARRAY
:
{
var
m_data
=
(
this
.
m_data
)
;
return
m_data
.
elementType
.
getScalarSize
(
)
*
m_data
.
size
;
}
case
gluVarType
.
Type
.
TYPE_STRUCT
:
{
var
size
=
0
;
var
struct
=
(
this
.
m_data
)
;
for
(
var
iter
=
0
;
struct
.
m_members
[
iter
]
<
struct
.
getSize
(
)
;
iter
+
+
)
size
+
=
struct
.
getMember
(
iter
)
.
m_type
.
getScalarSize
(
)
;
return
size
;
}
default
:
return
0
;
}
}
;
gluVarType
.
VarType
.
prototype
.
is
=
function
(
other
)
{
if
(
this
.
m_type
!
=
other
.
m_type
)
return
false
;
switch
(
this
.
m_type
)
{
case
gluVarType
.
Type
.
TYPE_BASIC
:
return
this
.
m_data
=
=
other
.
m_data
&
&
this
.
m_flags
=
=
other
.
m_flags
;
case
gluVarType
.
Type
.
TYPE_ARRAY
:
return
this
.
m_data
.
elementType
=
=
other
.
m_data
.
elementType
&
&
this
.
m_data
.
size
=
=
other
.
m_data
.
size
;
case
gluVarType
.
Type
.
TYPE_STRUCT
:
return
this
.
m_data
=
=
=
other
.
m_data
;
default
:
return
false
;
}
}
;
gluVarType
.
VarType
.
prototype
.
isnt
=
function
(
other
)
{
return
!
(
this
.
is
(
other
)
)
;
}
;
gluVarType
.
newTypeBasic
=
function
(
basicType
flags
)
{
if
(
!
gluShaderUtil
.
isDataTypeBoolOrBVec
(
basicType
)
)
return
new
gluVarType
.
VarType
(
)
.
VarTypeBasic
(
basicType
(
flags
)
)
;
else
return
new
gluVarType
.
VarType
(
)
.
VarTypeBoolean
(
basicType
)
;
}
;
gluVarType
.
newTypeArray
=
function
(
elementType
arraySize
)
{
return
new
gluVarType
.
VarType
(
)
.
VarTypeArray
(
elementType
arraySize
)
;
}
;
gluVarType
.
newTypeStruct
=
function
(
structPtr
)
{
return
new
gluVarType
.
VarType
(
)
.
VarTypeStruct
(
structPtr
)
;
}
;
gluVarType
.
newClone
=
function
(
object
)
{
return
new
gluVarType
.
VarType
(
)
.
VarTypeClone
(
object
)
;
}
;
gluVarType
.
StructMember
=
function
(
)
{
this
.
m_name
;
this
.
m_type
;
}
;
gluVarType
.
StructMember
.
prototype
.
Constructor
=
function
(
name
type
)
{
this
.
m_type
=
type
;
this
.
m_name
=
name
;
return
this
;
}
;
gluVarType
.
StructMember
.
prototype
.
getName
=
function
(
)
{
return
this
.
m_name
;
}
;
gluVarType
.
StructMember
.
prototype
.
getType
=
function
(
)
{
return
this
.
m_type
;
}
;
gluVarType
.
newStructMember
=
function
(
name
type
)
{
return
new
gluVarType
.
StructMember
(
)
.
Constructor
(
name
type
)
;
}
;
gluVarType
.
StructType
=
function
(
)
{
this
.
m_typeName
=
'
'
;
this
.
m_members
=
[
]
;
}
;
gluVarType
.
StructType
.
prototype
.
Constructor
=
function
(
name
)
{
this
.
m_typeName
=
this
.
setTypeName
(
name
)
;
return
this
;
}
;
gluVarType
.
StructType
.
prototype
.
hasTypeName
=
function
(
)
{
return
(
this
.
m_typeName
!
=
=
'
undefined
'
)
;
}
;
gluVarType
.
StructType
.
prototype
.
setTypeName
=
function
(
name
)
{
return
this
.
m_typeName
=
name
;
}
;
gluVarType
.
StructType
.
prototype
.
getTypeName
=
function
(
)
{
return
this
.
m_typeName
;
}
;
gluVarType
.
StructType
.
prototype
.
getNumMembers
=
function
(
)
{
return
this
.
m_members
.
length
;
}
;
gluVarType
.
StructType
.
prototype
.
getMember
=
function
(
memberNdx
)
{
if
(
memberNdx
>
=
0
&
&
memberNdx
<
this
.
m_members
.
length
)
return
this
.
m_members
[
memberNdx
]
;
else
{
throw
new
Error
(
'
Invalid
member
index
for
StructTypes
members
'
)
;
}
}
;
gluVarType
.
StructType
.
prototype
.
getSize
=
function
(
)
{
return
this
.
m_members
.
length
;
}
;
gluVarType
.
StructType
.
prototype
.
addMember
=
function
(
name
type
)
{
var
member
=
gluVarType
.
newStructMember
(
name
type
)
;
this
.
m_members
.
push
(
member
)
;
}
;
gluVarType
.
newStructType
=
function
(
name
)
{
return
new
gluVarType
.
StructType
(
)
.
Constructor
(
name
)
;
}
;
gluVarType
.
indent
=
function
(
level
)
{
var
str
=
'
'
;
for
(
var
i
=
0
;
i
<
level
;
i
+
+
)
str
+
=
'
\
t
'
;
return
str
;
}
;
gluVarType
.
declareVariable
=
function
(
varType
name
level
)
{
var
str
=
'
'
;
var
type
=
varType
;
var
curType
=
type
;
var
arraySizes
=
[
]
;
while
(
curType
.
isArrayType
(
)
)
{
arraySizes
.
push
(
curType
.
getArraySize
(
)
)
;
curType
=
curType
.
getElementType
(
)
;
}
if
(
curType
.
isBasicType
(
)
)
{
if
(
curType
.
getPrecision
(
)
!
=
=
undefined
)
str
+
=
gluShaderUtil
.
getPrecisionName
(
curType
.
getPrecision
(
)
)
+
'
'
;
str
+
=
gluShaderUtil
.
getDataTypeName
(
(
curType
.
getBasicType
(
)
)
)
;
}
else
if
(
curType
.
isStructType
(
)
)
{
var
structPtr
=
curType
.
getStruct
(
)
;
if
(
structPtr
.
hasTypeName
(
)
)
str
+
=
structPtr
.
getTypeName
(
)
;
else
str
+
=
gluVarType
.
declareStructType
(
structPtr
level
)
;
}
else
throw
new
Error
(
'
Unexpected
Array
typed
VarType
.
'
)
;
str
+
=
'
'
+
name
;
for
(
var
size
=
0
;
size
<
arraySizes
.
length
;
size
+
+
)
{
var
arrSize
=
arraySizes
[
size
]
;
if
(
arrSize
=
=
gluVarType
.
VarType
.
UNSIZED_ARRAY
)
str
+
=
'
[
]
'
;
else
str
+
=
'
[
'
+
arrSize
+
'
]
'
;
}
return
str
;
}
;
gluVarType
.
declareStructType
=
function
(
structType
level
)
{
var
str
=
'
struct
'
;
level
=
level
|
|
0
;
if
(
structType
.
hasTypeName
(
)
)
str
+
=
'
'
+
structType
.
getTypeName
(
)
;
str
+
=
'
\
n
'
+
gluVarType
.
indent
(
level
)
+
'
{
\
n
'
;
for
(
var
memberNdx
=
0
;
memberNdx
<
structType
.
getSize
(
)
;
memberNdx
+
+
)
{
var
memberIter
=
structType
.
getMember
(
memberNdx
)
;
str
+
=
gluVarType
.
indent
(
level
+
1
)
;
str
+
=
gluVarType
.
declareVariable
(
memberIter
.
getType
(
)
memberIter
.
getName
(
)
level
+
1
)
+
'
;
\
n
'
;
}
str
+
=
gluVarType
.
indent
(
level
)
+
'
}
'
;
return
str
;
}
;
gluVarType
.
getVarTypeOf
=
function
(
T
size
precision
)
{
size
=
size
|
|
1
;
precision
=
precision
|
|
gluShaderUtil
.
precision
.
PRECISION_LOWP
;
switch
(
size
)
{
case
4
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
precision
)
;
case
3
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_VEC3
precision
)
;
case
2
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_VEC2
precision
)
;
}
switch
(
T
)
{
case
'
float
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT
precision
)
;
case
'
vec4
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_VEC4
precision
)
;
case
'
vec3
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_VEC3
precision
)
;
case
'
vec2
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_VEC2
precision
)
;
case
'
mat2
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT2
precision
)
;
case
'
mat2x3
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT2X3
precision
)
;
case
'
mat2x4
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT2X4
precision
)
;
case
'
mat3x2
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT3X2
precision
)
;
case
'
mat3
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT3
precision
)
;
case
'
mat3x4
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT3X4
precision
)
;
case
'
mat4x2
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT4X2
precision
)
;
case
'
mat4x3
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT4X3
precision
)
;
case
'
mat4
'
:
return
gluVarType
.
newTypeBasic
(
gluShaderUtil
.
DataType
.
FLOAT_MAT4
precision
)
;
}
throw
new
Error
(
'
Invalid
input
type
'
+
T
+
'
or
size
'
+
size
)
;
}
;
gluVarType
.
Storage
=
{
STORAGE_IN
:
0
STORAGE_OUT
:
1
STORAGE_CONST
:
2
STORAGE_UNIFORM
:
3
STORAGE_BUFFER
:
4
}
;
gluVarType
.
getStorageName
=
function
(
storage
)
{
switch
(
storage
)
{
case
gluVarType
.
Storage
.
STORAGE_IN
:
return
'
in
'
;
case
gluVarType
.
Storage
.
STORAGE_OUT
:
return
'
out
'
;
case
gluVarType
.
Storage
.
STORAGE_CONST
:
return
'
const
'
;
case
gluVarType
.
Storage
.
STORAGE_UNIFORM
:
return
'
uniform
'
;
case
gluVarType
.
Storage
.
STORAGE_BUFFER
:
return
'
buffer
'
;
default
:
throw
new
Error
(
'
Unknown
storage
:
'
+
storage
)
;
}
}
;
gluVarType
.
Interpolation
=
{
INTERPOLATION_SMOOTH
:
0
INTERPOLATION_FLAT
:
1
INTERPOLATION_CENTROID
:
2
}
;
gluVarType
.
getInterpolationName
=
function
(
interpolation
)
{
switch
(
interpolation
)
{
case
gluVarType
.
Interpolation
.
INTERPOLATION_SMOOTH
:
return
'
smooth
'
;
case
gluVarType
.
Interpolation
.
INTERPOLATION_FLAT
:
return
'
flat
'
;
case
gluVarType
.
Interpolation
.
INTERPOLATION_CENTROID
:
return
'
centrod
'
;
default
:
throw
new
Error
(
'
Unknown
interpolation
:
'
+
interpolation
)
;
}
}
;
gluVarType
.
FormatLayout
=
{
FORMATLAYOUT_RGBA32F
:
0
FORMATLAYOUT_RGBA16F
:
1
FORMATLAYOUT_R32F
:
2
FORMATLAYOUT_RGBA8
:
3
FORMATLAYOUT_RGBA8_SNORM
:
4
FORMATLAYOUT_RGBA32I
:
5
FORMATLAYOUT_RGBA16I
:
6
FORMATLAYOUT_RGBA8I
:
7
FORMATLAYOUT_R32I
:
8
FORMATLAYOUT_RGBA32UI
:
9
FORMATLAYOUT_RGBA16UI
:
10
FORMATLAYOUT_RGBA8UI
:
11
FORMATLAYOUT_R32UI
:
12
}
;
gluVarType
.
getFormatLayoutName
=
function
(
layout
)
{
switch
(
layout
)
{
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA32F
:
return
'
rgba32f
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA16F
:
return
'
rgba16f
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_R32F
:
return
'
r32f
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA8
:
return
'
rgba8
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA8_SNORM
:
return
'
rgba8_snorm
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA32I
:
return
'
rgba32i
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA16I
:
return
'
rgba16i
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA8I
:
return
'
rgba8i
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_R32I
:
return
'
r32i
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA32UI
:
return
'
rgba32ui
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA16UI
:
return
'
rgba16ui
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_RGBA8UI
:
return
'
rgba8ui
'
;
case
gluVarType
.
FormatLayout
.
FORMATLAYOUT_R32UI
:
return
'
r32ui
'
;
default
:
throw
new
Error
(
'
Unknown
layout
:
'
+
layout
)
;
}
}
;
gluVarType
.
MatrixOrder
=
{
MATRIXORDER_COLUMN_MAJOR
:
0
MATRIXORDER_ROW_MAJOR
:
1
}
;
gluVarType
.
getMatrixOrderName
=
function
(
qualifier
)
{
switch
(
qualifier
)
{
case
gluVarType
.
MatrixOrder
.
MATRIXORDER_COLUMN_MAJOR
:
return
'
column_major
'
;
case
gluVarType
.
MatrixOrder
.
MATRIXORDER_ROW_MAJOR
:
return
'
row_major
'
;
default
:
throw
new
Error
(
'
Unknown
qualifier
:
'
+
qualifier
)
;
}
}
;
gluVarType
.
MemoryAccessQualifier
=
{
MEMORYACCESSQUALIFIER_COHERENT_BIT
:
0x01
MEMORYACCESSQUALIFIER_VOLATILE_BIT
:
0x02
MEMORYACCESSQUALIFIER_RESTRICT_BIT
:
0x04
MEMORYACCESSQUALIFIER_READONLY_BIT
:
0x08
MEMORYACCESSQUALIFIER_WRITEONLY_BIT
:
0x10
}
;
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_MASK
=
(
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_WRITEONLY_BIT
<
<
1
)
-
1
;
gluVarType
.
getMemoryAccessQualifierName
=
function
(
qualifier
)
{
switch
(
qualifier
)
{
case
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_COHERENT_BIT
:
return
'
coherent
'
;
case
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_VOLATILE_BIT
:
return
'
volatile
'
;
case
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_RESTRICT_BIT
:
return
'
restrict
'
;
case
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_READONLY_BIT
:
return
'
readonly
'
;
case
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_WRITEONLY_BIT
:
return
'
writeonly
'
;
default
:
throw
new
Error
(
'
Unknown
qualifier
:
'
+
qualifier
)
;
}
}
;
gluVarType
.
Layout
=
function
(
location
binding
offset
format
matrixOrder
)
{
this
.
location
=
location
;
this
.
binding
=
binding
;
this
.
offset
=
offset
;
this
.
format
=
format
;
this
.
matrixOrder
=
matrixOrder
;
}
;
gluVarType
.
Layout
.
prototype
.
toString
=
function
(
)
{
var
strings
=
[
]
;
var
str
=
'
'
;
if
(
typeof
this
.
location
!
=
=
'
undefined
'
)
strings
.
push
(
'
location
=
'
+
this
.
location
)
;
if
(
typeof
this
.
binding
!
=
=
'
undefined
'
)
strings
.
push
(
'
binding
=
'
+
this
.
binding
)
;
if
(
typeof
this
.
offset
!
=
=
'
undefined
'
)
strings
.
push
(
'
offset
=
'
+
this
.
offset
)
;
if
(
typeof
this
.
format
!
=
=
'
undefined
'
)
strings
.
push
(
gluVarType
.
getFormatLayoutName
(
this
.
format
)
)
;
if
(
typeof
this
.
matrixOrder
!
=
=
'
undefined
'
)
strings
.
push
(
gluVarType
.
getMatrixOrderName
(
this
.
matrixOrder
)
)
;
if
(
strings
.
length
>
0
)
{
str
+
=
'
layout
(
'
+
strings
[
0
]
;
for
(
var
i
=
1
;
i
<
strings
.
length
;
i
+
+
)
str
+
=
'
'
+
strings
[
i
]
;
str
+
=
'
)
'
;
}
return
str
;
}
;
gluVarType
.
VariableDeclaration
=
function
(
varType
name
storage
interpolation
layout
memoryAccessQualifierBits
)
{
this
.
varType
=
varType
;
this
.
name
=
name
;
this
.
storage
=
storage
;
this
.
interpolation
=
interpolation
;
this
.
layout
=
layout
;
this
.
memoryAccessQualifierBits
=
memoryAccessQualifierBits
|
|
0
;
}
;
gluVarType
.
VariableDeclaration
.
prototype
.
toString
=
function
(
)
{
var
str
=
'
'
;
if
(
typeof
this
.
layout
!
=
=
'
undefined
'
)
str
+
=
this
.
layout
.
toString
(
)
+
'
'
;
for
(
var
bitNdx
=
0
;
(
1
<
<
bitNdx
)
&
gluVarType
.
MemoryAccessQualifier
.
MEMORYACCESSQUALIFIER_MASK
;
+
+
bitNdx
)
if
(
this
.
memoryAccessQualifierBits
&
(
1
<
<
bitNdx
)
)
str
+
=
gluVarType
.
getMemoryAccessQualifierName
(
(
1
<
<
bitNdx
)
)
+
'
'
;
if
(
typeof
this
.
interpolation
!
=
=
'
undefined
'
)
str
+
=
gluVarType
.
getInterpolationName
(
this
.
interpolation
)
+
'
'
;
if
(
typeof
this
.
storage
!
=
=
'
undefined
'
)
str
+
=
gluVarType
.
getStorageName
(
this
.
storage
)
+
'
'
;
str
+
=
gluVarType
.
declareVariable
(
this
.
varType
this
.
name
)
;
return
str
;
}
;
}
)
;
