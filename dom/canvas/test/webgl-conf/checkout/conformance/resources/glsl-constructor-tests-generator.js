var
GLSLConstructorTestsGenerator
=
(
function
(
)
{
var
wtu
=
WebGLTestUtils
;
var
constructorVertexTemplate
=
[
"
attribute
vec4
vPosition
;
"
"
precision
mediump
int
;
"
"
precision
mediump
float
;
"
"
const
vec4
green
=
vec4
(
0
.
0
1
.
0
0
.
0
1
.
0
)
;
"
"
const
vec4
red
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
"
"
(
errorBound
)
"
"
varying
vec4
vColor
;
"
"
void
main
(
)
{
"
"
(
argsList
)
"
"
(
type
)
v
=
(
type
)
(
(
argsConstr
)
)
;
"
"
if
(
(
checkCompVals
)
)
"
"
vColor
=
green
;
"
"
else
"
"
vColor
=
red
;
"
"
gl_Position
=
vPosition
;
"
"
}
"
]
.
join
(
"
\
n
"
)
;
var
passThroughColorFragmentShader
=
[
"
precision
mediump
float
;
"
"
varying
vec4
vColor
;
"
"
void
main
(
)
{
"
"
gl_FragColor
=
vColor
;
"
"
}
"
]
.
join
(
'
\
n
'
)
;
var
constructorFragmentTemplate
=
[
"
precision
mediump
int
;
"
"
precision
mediump
float
;
"
"
const
vec4
green
=
vec4
(
0
.
0
1
.
0
0
.
0
1
.
0
)
;
"
"
const
vec4
red
=
vec4
(
1
.
0
0
.
0
0
.
0
1
.
0
)
;
"
"
(
errorBound
)
"
"
void
main
(
)
{
"
"
(
argsList
)
"
"
(
type
)
v
=
(
type
)
(
(
argsConstr
)
)
;
"
"
if
(
(
checkCompVals
)
)
"
"
gl_FragColor
=
green
;
"
"
else
"
"
gl_FragColor
=
red
;
"
"
}
"
]
.
join
(
"
\
n
"
)
;
function
getTypeCodeDimensions
(
typeCode
)
{
switch
(
typeCode
)
{
case
"
s
"
:
return
[
1
1
]
;
case
"
v2
"
:
return
[
1
2
]
;
case
"
v3
"
:
return
[
1
3
]
;
case
"
v4
"
:
return
[
1
4
]
;
case
"
m2
"
:
return
[
2
2
]
;
case
"
m3
"
:
return
[
3
3
]
;
case
"
m4
"
:
return
[
4
4
]
;
default
:
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
getTypeCodeDimensions
(
)
unknown
type
code
"
)
;
debugger
;
}
}
;
function
getTypeCodeComponentCount
(
typeCode
)
{
var
dim
=
getTypeCodeDimensions
(
typeCode
)
;
return
dim
[
0
]
*
dim
[
1
]
;
}
function
getGLSLBaseTypeName
(
typeCode
)
{
switch
(
typeCode
)
{
case
"
s
"
:
return
"
"
;
case
"
v2
"
:
return
"
vec2
"
;
case
"
v3
"
:
return
"
vec3
"
;
case
"
v4
"
:
return
"
vec4
"
;
case
"
m2
"
:
return
"
mat2
"
;
case
"
m3
"
:
return
"
mat3
"
;
case
"
m4
"
:
return
"
mat4
"
;
default
:
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
getGLSLBaseTypeName
(
)
unknown
type
code
"
)
;
debugger
;
}
}
function
getGLSLScalarType
(
targetType
)
{
switch
(
targetType
[
0
]
)
{
case
'
i
'
:
return
"
int
"
;
case
'
b
'
:
return
"
bool
"
;
case
'
v
'
:
case
'
m
'
:
return
"
float
"
;
default
:
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
getGLSLScalarType
(
)
unknown
target
type
"
)
;
debugger
;
}
}
function
getGLSLScalarPrefix
(
targetType
)
{
switch
(
targetType
[
0
]
)
{
case
'
i
'
:
case
'
b
'
:
return
targetType
[
0
]
;
case
'
v
'
:
case
'
m
'
:
return
'
'
;
default
:
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
getGLSLScalarPrefix
(
)
unknown
target
type
"
)
;
debugger
;
}
}
function
getGLSLArgumentType
(
typeCode
targetType
)
{
var
baseType
=
getGLSLBaseTypeName
(
typeCode
)
;
if
(
baseType
!
=
=
"
"
)
{
if
(
typeCode
[
0
]
=
=
=
"
v
"
)
{
return
getGLSLScalarPrefix
(
targetType
)
+
baseType
;
}
else
return
baseType
;
}
else
return
getGLSLScalarType
(
targetType
)
;
}
function
getGLSLArgumentComponentType
(
argTypeCode
targetType
)
{
var
scalarType
;
if
(
argTypeCode
[
0
]
=
=
=
"
m
"
)
{
scalarType
=
"
float
"
;
}
else
scalarType
=
getGLSLScalarType
(
targetType
)
;
return
scalarType
;
}
function
getGLSLColumnSize
(
targetType
)
{
colSize
=
parseInt
(
targetType
.
slice
(
-
1
)
)
;
if
(
!
isNaN
(
colSize
)
)
return
colSize
;
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
getGLSLColumnSize
(
)
invalid
target
type
"
)
;
debugger
;
}
function
getScalarTypeValStr
(
val
scalarType
)
{
if
(
val
=
=
null
)
debugger
;
switch
(
scalarType
)
{
case
"
float
"
:
return
val
.
toFixed
(
1
)
;
case
"
int
"
:
return
val
;
case
"
bool
"
:
return
(
val
=
=
=
0
)
?
"
false
"
:
"
true
"
;
default
:
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
getScalarTypeValStr
(
)
unknown
scalar
type
"
)
;
debugger
;
}
}
function
isGLSLTypeMatrix
(
type
)
{
return
(
type
.
indexOf
(
"
mat
"
)
!
=
=
-
1
)
;
}
function
isGLSLTypeVector
(
type
)
{
return
(
type
.
indexOf
(
"
vec
"
)
!
=
=
-
1
)
;
}
function
getGLSLTypeComponentCount
(
type
)
{
var
colSize
=
getGLSLColumnSize
(
type
)
;
if
(
isGLSLTypeMatrix
(
type
)
)
return
colSize
*
colSize
;
else
return
colSize
;
}
function
getComponentSequenceConstructorExpression
(
typeCode
firstCompValue
targetType
)
{
var
scalarType
=
getGLSLArgumentComponentType
(
typeCode
targetType
)
;
if
(
typeCode
=
=
=
"
s
"
)
{
return
getScalarTypeValStr
(
firstCompValue
scalarType
)
+
"
;
"
;
}
else
{
compCount
=
getTypeCodeComponentCount
(
typeCode
)
;
var
constrExpParts
=
new
Array
(
compCount
)
;
for
(
var
aa
=
0
;
aa
<
compCount
;
+
+
aa
)
constrExpParts
[
aa
]
=
getScalarTypeValStr
(
firstCompValue
+
aa
scalarType
)
;
return
getGLSLArgumentType
(
typeCode
targetType
)
+
"
(
"
+
constrExpParts
.
join
(
"
"
)
+
"
)
;
"
;
}
}
function
getComponentSelectorExpStr
(
targetType
compIx
)
{
if
(
isGLSLTypeMatrix
(
targetType
)
)
{
var
colRowIx
=
getColRowIndexFromLinearIndex
(
compIx
getGLSLColumnSize
(
targetType
)
)
;
return
"
v
[
"
+
colRowIx
.
colIx
+
"
]
[
"
+
colRowIx
.
rowIx
+
"
]
"
;
}
else
return
"
v
[
"
+
compIx
+
"
]
"
;
}
function
getComponentValidationExpression
(
refCompVals
targetType
)
{
if
(
refCompVals
.
length
=
=
=
0
)
return
"
false
"
;
var
scalarType
=
getGLSLScalarType
(
targetType
)
;
var
checkComponentValueParts
=
new
Array
(
refCompVals
.
length
)
;
for
(
var
cc
=
0
;
cc
<
refCompVals
.
length
;
+
+
cc
)
{
var
val_str
=
getScalarTypeValStr
(
refCompVals
[
cc
]
scalarType
)
;
var
comp_sel_exp
=
getComponentSelectorExpStr
(
targetType
cc
)
;
if
(
scalarType
=
=
=
"
float
"
)
{
checkComponentValueParts
[
cc
]
=
"
abs
(
"
+
comp_sel_exp
+
"
-
"
+
val_str
+
"
)
<
=
errorBound
"
;
}
else
{
checkComponentValueParts
[
cc
]
=
comp_sel_exp
+
"
=
=
"
+
val_str
;
}
}
return
checkComponentValueParts
.
join
(
"
&
&
"
)
;
}
function
getTestShaderParts
(
targetType
argExp
firstCompValue
)
{
var
argsListParts
=
new
Array
(
argExp
.
length
)
;
var
argsConstrParts
=
new
Array
(
argExp
.
length
)
;
var
typeExpParts
=
new
Array
(
argExp
.
length
)
;
for
(
var
aa
=
0
;
aa
<
argExp
.
length
;
+
+
aa
)
{
var
typeCode
=
argExp
[
aa
]
;
var
argCompCount
=
getTypeCodeComponentCount
(
typeCode
)
;
var
argName
=
"
a
"
+
aa
;
var
argType
=
getGLSLArgumentType
(
typeCode
targetType
)
;
var
argConstrExp
=
argType
+
"
"
+
argName
+
"
=
"
+
getComponentSequenceConstructorExpression
(
typeCode
firstCompValue
targetType
)
;
argsListParts
[
aa
]
=
(
(
aa
>
0
)
?
"
"
:
"
"
)
+
argConstrExp
;
argsConstrParts
[
aa
]
=
argName
;
typeExpParts
[
aa
]
=
argType
;
firstCompValue
+
=
argCompCount
;
}
return
{
argsList
:
argsListParts
.
join
(
"
\
n
"
)
+
"
\
n
"
argsConstr
:
argsConstrParts
.
join
(
"
"
)
typeExp
:
targetType
+
"
(
"
+
typeExpParts
.
join
(
"
"
)
+
"
)
"
}
;
}
function
getArrayWithIdenticalValues
(
size
val
)
{
var
matArray
=
new
Array
(
size
)
;
for
(
var
aa
=
0
;
aa
<
size
;
+
+
aa
)
matArray
[
aa
]
=
val
;
return
matArray
;
}
function
getArrayWithIncreasingValues
(
size
start
)
{
var
matArray
=
new
Array
(
size
)
;
for
(
var
aa
=
0
;
aa
<
size
;
+
+
aa
)
matArray
[
aa
]
=
start
+
aa
;
return
matArray
;
}
function
matCompArraySetDiagonal
(
matArray
diagVal
)
{
var
colSize
=
Math
.
round
(
Math
.
sqrt
(
matArray
.
length
)
)
;
var
dIx
=
0
;
do
{
matArray
[
dIx
]
=
diagVal
;
dIx
+
=
(
colSize
+
1
)
;
}
while
(
dIx
<
colSize
*
colSize
)
;
return
matArray
;
}
function
matCompArrayCreateDiagonalMatrix
(
colSize
diagVal
)
{
var
size
=
colSize
*
colSize
;
var
matArray
=
new
Array
(
size
)
;
for
(
var
aa
=
0
;
aa
<
size
;
+
+
aa
)
matArray
[
aa
]
=
0
;
return
matCompArraySetDiagonal
(
matArray
diagVal
)
;
}
function
getColRowIndexFromLinearIndex
(
linIx
colSize
)
{
return
{
colIx
:
Math
.
floor
(
linIx
/
colSize
)
rowIx
:
linIx
%
colSize
}
;
}
function
getLinearIndexFromColRowIndex
(
rowColIx
colSize
)
{
return
rowColIx
.
colIx
*
colSize
+
rowColIx
.
rowIx
;
}
function
matCompArraySetMatrixFromMatrix
(
dstColSize
srcMatArray
)
{
var
dstMatArray
=
matCompArrayCreateDiagonalMatrix
(
dstColSize
1
)
;
var
srcColSize
=
Math
.
round
(
Math
.
sqrt
(
srcMatArray
.
length
)
)
;
for
(
var
c_ix
=
0
;
c_ix
<
srcMatArray
.
length
;
+
+
c_ix
)
{
var
srcMatIx
=
getColRowIndexFromLinearIndex
(
c_ix
srcColSize
)
;
if
(
srcMatIx
.
colIx
<
dstColSize
&
&
srcMatIx
.
rowIx
<
dstColSize
)
{
dstMatArray
[
getLinearIndexFromColRowIndex
(
srcMatIx
dstColSize
)
]
=
srcMatArray
[
c_ix
]
;
}
}
return
dstMatArray
;
}
function
getConstructorExpressionInfo
(
targetType
argExp
firstCompValue
)
{
var
argCompCountsSum
=
0
;
var
argCompCounts
=
new
Array
(
argExp
.
length
)
;
for
(
var
aa
=
0
;
aa
<
argExp
.
length
;
+
+
aa
)
{
argCompCounts
[
aa
]
=
getTypeCodeComponentCount
(
argExp
[
aa
]
)
;
argCompCountsSum
+
=
argCompCounts
[
aa
]
;
}
var
targetCompCount
=
getGLSLTypeComponentCount
(
targetType
)
;
var
refCompVals
;
var
testMsg
;
var
valid
;
if
(
argCompCountsSum
=
=
=
0
)
{
refCompVals
=
[
]
;
testMsg
=
"
invalid
(
no
arguments
)
"
;
valid
=
false
;
}
else
{
if
(
isGLSLTypeVector
(
targetType
)
)
{
if
(
argCompCountsSum
=
=
=
1
)
{
refCompVals
=
getArrayWithIdenticalValues
(
targetCompCount
firstCompValue
)
;
testMsg
=
"
valid
(
all
components
set
to
the
same
value
)
"
;
valid
=
true
;
}
else
{
if
(
argCompCountsSum
<
targetCompCount
)
{
refCompVals
=
[
]
;
testMsg
=
"
invalid
(
not
enough
arguments
)
"
;
valid
=
false
;
}
else
{
var
lastArgFirstCompIx
=
argCompCountsSum
-
argCompCounts
[
argCompCounts
.
length
-
1
]
;
if
(
lastArgFirstCompIx
<
targetCompCount
)
{
refCompVals
=
getArrayWithIncreasingValues
(
targetCompCount
firstCompValue
)
;
testMsg
=
"
valid
"
;
valid
=
true
;
}
else
{
refCompVals
=
[
]
;
testMsg
=
"
invalid
(
unused
argument
)
"
;
valid
=
false
;
}
}
}
}
else
{
if
(
argCompCountsSum
=
=
=
1
)
{
refCompVals
=
matCompArrayCreateDiagonalMatrix
(
Math
.
round
(
Math
.
sqrt
(
targetCompCount
)
)
firstCompValue
)
;
testMsg
=
"
valid
(
diagonal
components
set
to
the
same
value
off
-
diagonal
components
set
to
zero
)
"
;
valid
=
true
;
}
else
{
if
(
argExp
.
length
=
=
=
1
&
&
argExp
[
0
]
[
0
]
=
=
=
"
m
"
)
{
var
dstColSize
=
getGLSLColumnSize
(
targetType
)
;
refCompVals
=
matCompArraySetMatrixFromMatrix
(
dstColSize
getArrayWithIncreasingValues
(
getTypeCodeComponentCount
(
argExp
[
0
]
)
firstCompValue
)
)
;
testMsg
=
"
valid
components
at
corresponding
col
row
indices
are
set
from
argument
other
components
are
set
from
identity
matrix
"
;
valid
=
true
;
}
else
{
var
matFound
=
false
;
for
(
var
aa
=
0
;
aa
<
argExp
.
length
;
+
+
aa
)
if
(
argExp
[
aa
]
[
0
]
=
=
=
"
m
"
)
matFound
=
true
;
if
(
matFound
)
{
refCompVals
=
[
]
;
testMsg
=
"
invalid
argument
list
greater
than
one
contains
matrix
type
"
;
valid
=
false
;
}
else
{
if
(
argCompCountsSum
<
targetCompCount
)
{
refCompVals
=
[
]
;
testMsg
=
"
invalid
(
not
enough
arguments
)
"
;
valid
=
false
;
}
else
{
var
lastArgFirstCompIx
=
argCompCountsSum
-
argCompCounts
[
argCompCounts
.
length
-
1
]
;
if
(
lastArgFirstCompIx
<
targetCompCount
)
{
refCompVals
=
getArrayWithIncreasingValues
(
targetCompCount
firstCompValue
)
;
testMsg
=
"
valid
"
;
valid
=
true
;
}
else
{
refCompVals
=
[
]
;
testMsg
=
"
invalid
(
unused
argument
)
"
;
valid
=
false
;
}
}
}
}
}
}
}
if
(
testMsg
=
=
null
|
|
valid
=
=
null
)
{
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
getConstructorExpressionInfo
(
)
info
not
set
"
)
;
debugger
;
}
return
{
refCompVals
:
refCompVals
testMsg
:
testMsg
valid
:
valid
}
;
}
function
getVertexAndFragmentShaderTestCase
(
targetType
argExp
)
{
var
firstCompValue
=
0
;
if
(
isGLSLTypeMatrix
(
targetType
)
)
{
firstCompValue
=
2
;
}
var
argCode
=
getTestShaderParts
(
targetType
argExp
firstCompValue
)
;
var
expInfo
=
getConstructorExpressionInfo
(
targetType
argExp
firstCompValue
)
;
var
substitutions
=
{
type
:
targetType
errorBound
:
(
getGLSLScalarType
(
targetType
)
=
=
=
"
float
"
)
?
"
const
float
errorBound
=
1
.
0E
-
5
;
"
:
"
"
argsList
:
argCode
.
argsList
argsConstr
:
argCode
.
argsConstr
checkCompVals
:
getComponentValidationExpression
(
expInfo
.
refCompVals
targetType
)
}
;
return
[
{
vShaderSource
:
wtu
.
replaceParams
(
constructorVertexTemplate
substitutions
)
vShaderSuccess
:
expInfo
.
valid
fShaderSource
:
passThroughColorFragmentShader
fShaderSuccess
:
true
linkSuccess
:
expInfo
.
valid
passMsg
:
"
Vertex
shader
:
"
+
argCode
.
typeExp
+
"
"
+
expInfo
.
testMsg
render
:
expInfo
.
valid
}
{
vShaderSource
:
GLSLConformanceTester
.
defaultVertexShader
vShaderSuccess
:
true
fShaderSource
:
wtu
.
replaceParams
(
constructorFragmentTemplate
substitutions
)
fShaderSuccess
:
expInfo
.
valid
linkSuccess
:
expInfo
.
valid
passMsg
:
"
Fragment
shader
:
"
+
argCode
.
typeExp
+
"
"
+
expInfo
.
testMsg
render
:
expInfo
.
valid
}
]
;
}
var
typeCodeIncrementer
=
{
s
:
{
typeCode
:
"
v2
"
order
:
0
}
v2
:
{
typeCode
:
"
v3
"
order
:
1
}
v3
:
{
typeCode
:
"
v4
"
order
:
2
}
v4
:
{
typeCode
:
"
m2
"
order
:
3
}
m2
:
{
typeCode
:
"
m3
"
order
:
4
}
m3
:
{
typeCode
:
"
m4
"
order
:
5
}
m4
:
{
typeCode
:
"
s
"
order
:
6
}
first
:
"
s
"
}
function
getNextArgumentSequence
(
inSeq
)
{
var
nextSeq
;
if
(
inSeq
.
length
=
=
=
0
)
{
nextSeq
=
[
typeCodeIncrementer
.
first
]
;
}
else
{
nextSeq
=
new
Array
(
inSeq
.
length
)
;
var
overflow
=
true
;
for
(
var
aa
=
0
;
aa
<
inSeq
.
length
;
+
+
aa
)
{
var
currArg
=
inSeq
[
aa
]
;
if
(
overflow
)
{
var
nextArg
=
typeCodeIncrementer
[
currArg
]
.
typeCode
;
nextSeq
[
aa
]
=
nextArg
;
overflow
=
(
nextArg
=
=
=
typeCodeIncrementer
.
first
)
;
}
else
{
nextSeq
[
aa
]
=
currArg
;
}
}
if
(
overflow
)
{
nextSeq
.
push
(
typeCodeIncrementer
.
first
)
;
}
}
return
nextSeq
;
}
function
areArgExpEqual
(
expA
expB
)
{
if
(
expA
.
length
!
=
=
expB
.
length
)
return
false
;
for
(
var
aa
=
0
;
aa
<
expA
.
length
;
+
+
aa
)
if
(
expA
[
aa
]
!
=
=
expB
[
aa
]
)
return
false
;
return
true
;
}
function
isArgExpSmallerOrEqual
(
argExpA
argExpB
)
{
var
aLen
=
argExpA
.
length
;
var
bLen
=
argExpB
.
length
;
if
(
aLen
!
=
=
bLen
)
return
(
aLen
<
bLen
)
;
for
(
var
aa
=
aLen
-
1
;
aa
>
=
0
;
-
-
aa
)
{
var
argA
=
argExpA
[
aa
]
;
var
argB
=
argExpB
[
aa
]
;
if
(
argA
!
=
=
argB
)
{
var
aOrder
=
typeCodeIncrementer
[
argA
]
.
order
;
var
bOrder
=
typeCodeIncrementer
[
argB
]
.
order
;
if
(
aOrder
!
=
=
bOrder
)
return
(
aOrder
<
bOrder
)
;
}
}
return
true
;
}
function
getNextArgumentExpression
(
testExp
testSet
)
{
var
testInterval
=
testSet
[
testExp
.
ix
]
;
if
(
areArgExpEqual
(
testExp
.
argExp
testInterval
[
1
]
)
)
{
if
(
testExp
.
ix
=
=
=
testSet
.
length
-
1
)
{
return
null
;
}
else
{
var
nextIx
=
testExp
.
ix
+
1
;
return
{
ix
:
nextIx
argExp
:
testSet
[
nextIx
]
[
0
]
}
;
}
}
else
{
return
{
ix
:
testExp
.
ix
argExp
:
getNextArgumentSequence
(
testExp
.
argExp
)
}
;
}
}
function
convertCsvToArray
(
str
)
{
function
checkInput
(
el
ix
arr
)
{
var
typeCode
=
el
.
trim
(
)
;
if
(
!
(
typeCode
in
typeCodeIncrementer
)
&
&
typeCode
!
=
=
"
first
"
)
{
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
convertCsvToArray
(
)
unknown
type
code
"
+
typeCode
)
;
debugger
;
}
arr
[
ix
]
=
typeCode
;
}
var
spArr
=
str
.
split
(
"
"
)
;
if
(
spArr
.
length
=
=
=
1
&
&
spArr
[
0
]
.
trim
(
)
=
=
=
"
"
)
spArr
=
[
]
;
spArr
.
forEach
(
checkInput
)
;
return
spArr
;
}
function
processInputs
(
testSequences
)
{
var
testSet
=
new
Array
(
testSequences
.
length
)
;
for
(
var
tt
=
0
;
tt
<
testSequences
.
length
;
+
+
tt
)
{
var
interval
=
testSequences
[
tt
]
;
var
bounds
=
interval
.
split
(
"
-
"
)
;
var
begin
=
convertCsvToArray
(
bounds
[
0
]
)
;
var
end
=
convertCsvToArray
(
bounds
[
bounds
.
length
-
1
]
)
;
if
(
!
isArgExpSmallerOrEqual
(
begin
end
)
)
{
wtu
.
error
(
"
GLSLConstructorTestsGenerator
.
processInputs
(
)
interval
not
valid
"
)
;
debugger
;
}
testSet
[
tt
]
=
[
begin
end
]
;
}
return
testSet
;
}
function
getConstructorTests
(
targetType
testSequences
)
{
var
testInfos
=
[
]
;
var
testSet
=
processInputs
(
testSequences
)
;
var
testExp
=
{
ix
:
0
argExp
:
testSet
[
0
]
[
0
]
}
;
do
{
testInfos
=
testInfos
.
concat
(
getVertexAndFragmentShaderTestCase
(
targetType
testExp
.
argExp
)
)
;
testExp
=
getNextArgumentExpression
(
testExp
testSet
)
;
}
while
(
testExp
!
=
null
)
;
return
testInfos
;
}
function
getDefaultTestSet
(
targetType
)
{
switch
(
targetType
)
{
case
"
vec2
"
:
case
"
ivec2
"
:
case
"
bvec2
"
:
return
[
"
-
m4
"
"
s
s
-
m4
s
"
"
s
v2
"
"
s
v3
"
"
s
v4
"
"
s
m2
"
"
s
m3
"
"
s
m4
"
"
s
s
s
"
]
;
case
"
vec3
"
:
case
"
ivec3
"
:
case
"
bvec3
"
:
return
[
"
-
m4
"
"
s
s
-
m4
s
"
"
s
v2
"
"
s
v3
"
"
s
v4
"
"
s
m2
"
"
s
m3
"
"
s
m4
"
"
s
s
s
-
m4
s
s
"
"
s
s
v2
"
"
s
s
v3
"
"
s
s
v4
"
"
s
s
m2
"
"
s
s
m3
"
"
s
s
m4
"
"
s
s
s
s
"
]
;
case
"
vec4
"
:
case
"
ivec4
"
:
case
"
bvec4
"
:
case
"
mat2
"
:
return
[
"
-
m4
"
"
s
s
-
m4
s
"
"
s
v2
"
"
s
v3
"
"
s
v4
"
"
s
m2
"
"
s
m3
"
"
s
m4
"
"
s
s
s
-
m4
s
s
"
"
s
s
v2
"
"
s
s
v3
"
"
s
s
v4
"
"
s
s
m2
"
"
s
s
m3
"
"
s
s
m4
"
"
s
s
s
s
-
m4
s
s
s
"
"
s
s
s
v2
"
"
s
s
s
v3
"
"
s
s
s
v4
"
"
s
s
s
m2
"
"
s
s
s
m3
"
"
s
s
s
m4
"
"
s
s
s
s
s
"
]
;
case
"
mat3
"
:
case
"
mat4
"
:
return
[
"
-
m4
"
"
s
s
-
m4
s
"
"
s
v2
"
"
s
v3
"
"
s
v4
"
"
s
m2
"
"
s
m3
"
"
s
m4
"
"
v4
s
v4
"
"
v4
s
v3
v2
"
"
v4
v4
v3
v2
"
"
v4
v4
v4
v4
"
"
v2
v2
v2
v2
v2
"
"
v2
v2
v2
v2
v2
v2
v2
v2
"
"
v3
v3
v3
"
"
v3
v3
v3
s
"
"
v3
v3
v3
v3
v3
s
"
"
v3
v3
v3
v3
v3
s
s
"
]
;
}
}
return
{
getConstructorTests
:
getConstructorTests
getDefaultTestSet
:
getDefaultTestSet
}
;
}
(
)
)
;
