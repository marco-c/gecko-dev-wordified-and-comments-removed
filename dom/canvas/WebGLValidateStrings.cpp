#
include
"
WebGLValidateStrings
.
h
"
#
include
<
regex
>
#
include
"
WebGLTypes
.
h
"
namespace
mozilla
{
std
:
:
string
CommentsToSpaces
(
const
std
:
:
string
&
src
)
{
constexpr
auto
flags
=
std
:
:
regex
:
:
ECMAScript
|
std
:
:
regex
:
:
nosubs
|
std
:
:
regex
:
:
optimize
;
static
const
auto
RE_COMMENT_BEGIN
=
std
:
:
regex
(
"
/
[
*
/
]
"
flags
)
;
static
const
auto
RE_LINE_COMMENT_END
=
std
:
:
regex
(
R
"
(
[
^
\
\
]
\
n
)
"
flags
)
;
static
const
auto
RE_BLOCK_COMMENT_END
=
std
:
:
regex
(
R
"
(
\
*
/
)
"
flags
)
;
std
:
:
string
ret
;
ret
.
reserve
(
src
.
size
(
)
)
;
auto
itr
=
src
.
begin
(
)
;
const
auto
end
=
src
.
end
(
)
;
std
:
:
smatch
match
;
while
(
std
:
:
regex_search
(
itr
end
match
RE_COMMENT_BEGIN
)
)
{
MOZ_ASSERT
(
match
.
length
(
)
=
=
2
)
;
const
auto
commentBegin
=
itr
+
match
.
position
(
)
;
ret
.
append
(
itr
commentBegin
)
;
itr
=
commentBegin
+
match
.
length
(
)
;
const
bool
isBlockComment
=
(
*
(
commentBegin
+
1
)
=
=
'
*
'
)
;
const
auto
*
endRegex
=
&
RE_LINE_COMMENT_END
;
if
(
isBlockComment
)
{
endRegex
=
&
RE_BLOCK_COMMENT_END
;
}
if
(
isBlockComment
)
{
ret
+
=
"
/
*
"
;
}
const
bool
isTerminated
=
std
:
:
regex_search
(
itr
end
match
*
endRegex
)
;
if
(
!
isTerminated
)
return
ret
;
const
auto
commentEnd
=
itr
+
match
.
position
(
)
+
match
.
length
(
)
;
for
(
;
itr
!
=
commentEnd
;
+
+
itr
)
{
const
auto
cur
=
*
itr
;
if
(
cur
=
=
'
\
n
'
)
{
ret
+
=
cur
;
}
}
if
(
isBlockComment
)
{
ret
+
=
"
*
/
"
;
}
}
ret
.
append
(
itr
end
)
;
return
ret
;
}
static
bool
IsValidGLSLChar
(
const
char
c
)
{
if
(
(
'
a
'
<
=
c
&
&
c
<
=
'
z
'
)
|
|
(
'
A
'
<
=
c
&
&
c
<
=
'
Z
'
)
|
|
(
'
0
'
<
=
c
&
&
c
<
=
'
9
'
)
)
{
return
true
;
}
switch
(
c
)
{
case
'
'
:
case
'
\
t
'
:
case
'
\
v
'
:
case
'
\
f
'
:
case
'
\
r
'
:
case
'
\
n
'
:
case
'
_
'
:
case
'
.
'
:
case
'
+
'
:
case
'
-
'
:
case
'
/
'
:
case
'
*
'
:
case
'
%
'
:
case
'
<
'
:
case
'
>
'
:
case
'
[
'
:
case
'
]
'
:
case
'
(
'
:
case
'
)
'
:
case
'
{
'
:
case
'
}
'
:
case
'
^
'
:
case
'
|
'
:
case
'
&
'
:
case
'
~
'
:
case
'
=
'
:
case
'
!
'
:
case
'
:
'
:
case
'
;
'
:
case
'
'
:
case
'
?
'
:
return
true
;
default
:
return
false
;
}
}
Maybe
<
char
>
CheckGLSLPreprocString
(
const
bool
webgl2
const
std
:
:
string
&
string
)
{
for
(
const
auto
c
:
string
)
{
if
(
IsValidGLSLChar
(
c
)
)
continue
;
if
(
c
=
=
'
#
'
)
continue
;
if
(
c
=
=
'
\
\
'
&
&
webgl2
)
continue
;
return
Some
(
c
)
;
}
return
{
}
;
}
Maybe
<
webgl
:
:
ErrorInfo
>
CheckGLSLVariableName
(
const
bool
webgl2
const
std
:
:
string
&
name
)
{
if
(
name
.
empty
(
)
)
return
{
}
;
const
uint32_t
maxSize
=
webgl2
?
1024
:
256
;
if
(
name
.
size
(
)
>
maxSize
)
{
const
auto
info
=
nsPrintfCString
(
"
Identifier
is
%
zu
characters
long
exceeds
the
"
"
maximum
allowed
length
of
%
u
characters
.
"
name
.
size
(
)
maxSize
)
;
return
Some
(
webgl
:
:
ErrorInfo
{
LOCAL_GL_INVALID_VALUE
info
.
BeginReading
(
)
}
)
;
}
for
(
const
auto
cur
:
name
)
{
if
(
!
IsValidGLSLChar
(
cur
)
)
{
const
auto
info
=
nsPrintfCString
(
"
String
contains
the
illegal
character
0x
%
x
'
.
"
cur
)
;
return
Some
(
webgl
:
:
ErrorInfo
{
LOCAL_GL_INVALID_VALUE
info
.
BeginReading
(
)
}
)
;
}
}
if
(
name
.
find
(
"
webgl_
"
)
=
=
0
|
|
name
.
find
(
"
_webgl_
"
)
=
=
0
)
{
return
Some
(
webgl
:
:
ErrorInfo
{
LOCAL_GL_INVALID_OPERATION
"
String
matches
reserved
GLSL
prefix
pattern
/
_
?
webgl_
/
.
"
}
)
;
}
return
{
}
;
}
}
