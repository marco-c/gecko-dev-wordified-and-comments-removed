#
include
"
GLContext
.
h
"
#
include
"
WebGL2Context
.
h
"
#
include
"
WebGLQuery
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
RefPtr
<
WebGLQuery
>
*
WebGLContext
:
:
ValidateQuerySlotByTarget
(
GLenum
target
)
{
if
(
IsWebGL2
(
)
)
{
switch
(
target
)
{
case
LOCAL_GL_ANY_SAMPLES_PASSED
:
case
LOCAL_GL_ANY_SAMPLES_PASSED_CONSERVATIVE
:
return
&
mQuerySlot_SamplesPassed
;
case
LOCAL_GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN
:
return
&
mQuerySlot_TFPrimsWritten
;
default
:
break
;
}
}
if
(
IsExtensionEnabled
(
WebGLExtensionID
:
:
EXT_disjoint_timer_query
)
)
{
switch
(
target
)
{
case
LOCAL_GL_TIME_ELAPSED_EXT
:
return
&
mQuerySlot_TimeElapsed
;
default
:
break
;
}
}
ErrorInvalidEnumInfo
(
"
target
"
target
)
;
return
nullptr
;
}
RefPtr
<
WebGLQuery
>
WebGLContext
:
:
CreateQuery
(
)
{
const
FuncScope
funcScope
(
*
this
"
createQuery
"
)
;
if
(
IsContextLost
(
)
)
return
nullptr
;
return
new
WebGLQuery
(
this
)
;
}
void
WebGLContext
:
:
BeginQuery
(
GLenum
target
WebGLQuery
&
query
)
{
FuncScope
funcScope
(
*
this
"
beginQuery
"
)
;
if
(
IsContextLost
(
)
)
return
;
funcScope
.
mBindFailureGuard
=
true
;
const
auto
&
slot
=
ValidateQuerySlotByTarget
(
target
)
;
if
(
!
slot
)
return
;
if
(
*
slot
)
return
ErrorInvalidOperation
(
"
Query
target
already
active
.
"
)
;
const
auto
&
curTarget
=
query
.
Target
(
)
;
if
(
curTarget
&
&
target
!
=
curTarget
)
{
ErrorInvalidOperation
(
"
Queries
cannot
change
targets
.
"
)
;
return
;
}
query
.
BeginQuery
(
target
*
slot
)
;
funcScope
.
mBindFailureGuard
=
false
;
}
void
WebGLContext
:
:
EndQuery
(
GLenum
target
)
{
FuncScope
funcScope
(
*
this
"
endQuery
"
)
;
if
(
IsContextLost
(
)
)
return
;
funcScope
.
mBindFailureGuard
=
true
;
const
auto
&
slot
=
ValidateQuerySlotByTarget
(
target
)
;
if
(
!
slot
)
return
;
const
auto
query
=
*
slot
;
if
(
!
query
)
return
ErrorInvalidOperation
(
"
Query
target
not
active
.
"
)
;
query
-
>
EndQuery
(
)
;
funcScope
.
mBindFailureGuard
=
false
;
}
Maybe
<
double
>
WebGLContext
:
:
GetQueryParameter
(
const
WebGLQuery
&
query
GLenum
pname
)
const
{
const
FuncScope
funcScope
(
*
this
"
getQueryParameter
"
)
;
if
(
IsContextLost
(
)
)
return
Nothing
(
)
;
return
query
.
GetQueryParameter
(
pname
)
;
}
void
WebGLContext
:
:
QueryCounter
(
WebGLQuery
&
query
)
const
{
const
WebGLContext
:
:
FuncScope
funcScope
(
*
this
"
queryCounterEXT
"
)
;
if
(
IsContextLost
(
)
)
return
;
query
.
QueryCounter
(
)
;
}
}
