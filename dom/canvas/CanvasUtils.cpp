#
include
<
stdlib
.
h
>
#
include
<
stdarg
.
h
>
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsICanvasRenderingContextInternal
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsGfxCIID
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
CanvasUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
WebGL2Context
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
jsapi
.
h
"
#
define
TOPIC_CANVAS_PERMISSIONS_PROMPT
"
canvas
-
permissions
-
prompt
"
#
define
TOPIC_CANVAS_PERMISSIONS_PROMPT_HIDE_DOORHANGER
\
"
canvas
-
permissions
-
prompt
-
hide
-
doorhanger
"
#
define
PERMISSION_CANVAS_EXTRACT_DATA
NS_LITERAL_CSTRING
(
"
canvas
"
)
using
namespace
mozilla
:
:
gfx
;
namespace
mozilla
{
namespace
CanvasUtils
{
bool
IsImageExtractionAllowed
(
Document
*
aDocument
JSContext
*
aCx
nsIPrincipal
&
aPrincipal
)
{
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
aDocument
)
)
{
return
true
;
}
if
(
!
aDocument
|
|
!
aCx
)
{
return
false
;
}
if
(
nsContentUtils
:
:
IsSystemPrincipal
(
&
aPrincipal
)
)
{
return
true
;
}
auto
principal
=
BasePrincipal
:
:
Cast
(
&
aPrincipal
)
;
if
(
principal
-
>
AddonPolicy
(
)
|
|
principal
-
>
ContentScriptAddonPolicy
(
)
)
{
return
true
;
}
nsIURI
*
docURI
=
aDocument
-
>
GetDocumentURI
(
)
;
nsCString
docURISpec
;
docURI
-
>
GetSpec
(
docURISpec
)
;
bool
isFileURL
;
if
(
NS_SUCCEEDED
(
docURI
-
>
SchemeIs
(
"
file
"
&
isFileURL
)
)
&
&
isFileURL
)
{
return
true
;
}
JS
:
:
AutoFilename
scriptFile
;
if
(
JS
:
:
DescribeScriptedCaller
(
aCx
&
scriptFile
)
&
&
scriptFile
.
get
(
)
&
&
strcmp
(
scriptFile
.
get
(
)
"
resource
:
/
/
pdf
.
js
/
build
/
pdf
.
js
"
)
=
=
0
)
{
return
true
;
}
Document
*
topLevelDocument
=
aDocument
-
>
GetTopLevelContentDocument
(
)
;
nsIURI
*
topLevelDocURI
=
topLevelDocument
?
topLevelDocument
-
>
GetDocumentURI
(
)
:
nullptr
;
nsCString
topLevelDocURISpec
;
if
(
topLevelDocURI
)
{
topLevelDocURI
-
>
GetSpec
(
topLevelDocURISpec
)
;
}
nsresult
rv
;
nsCOMPtr
<
mozIThirdPartyUtil
>
thirdPartyUtil
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
bool
isThirdParty
=
true
;
rv
=
thirdPartyUtil
-
>
IsThirdPartyURI
(
topLevelDocURI
docURI
&
isThirdParty
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
isThirdParty
)
{
nsAutoString
message
;
message
.
AppendPrintf
(
"
Blocked
third
party
%
s
from
extracting
canvas
data
.
"
docURISpec
.
get
(
)
)
;
nsContentUtils
:
:
ReportToConsoleNonLocalized
(
message
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Security
"
)
aDocument
)
;
return
false
;
}
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
do_GetService
(
NS_PERMISSIONMANAGER_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
uint32_t
permission
;
rv
=
permissionManager
-
>
TestPermissionFromPrincipal
(
principal
PERMISSION_CANVAS_EXTRACT_DATA
&
permission
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
switch
(
permission
)
{
case
nsIPermissionManager
:
:
ALLOW_ACTION
:
return
true
;
case
nsIPermissionManager
:
:
DENY_ACTION
:
return
false
;
default
:
break
;
}
bool
isAutoBlockCanvas
=
StaticPrefs
:
:
privacy_resistFingerprinting_autoDeclineNoUserInputCanvasPrompts
(
)
&
&
!
EventStateManager
:
:
IsHandlingUserInput
(
)
;
if
(
isAutoBlockCanvas
)
{
nsAutoString
message
;
message
.
AppendPrintf
(
"
Blocked
%
s
from
extracting
canvas
data
because
no
user
input
was
"
"
detected
.
"
docURISpec
.
get
(
)
)
;
nsContentUtils
:
:
ReportToConsoleNonLocalized
(
message
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Security
"
)
aDocument
)
;
}
else
{
nsAutoString
message
;
message
.
AppendPrintf
(
"
Blocked
%
s
from
extracting
canvas
data
but
prompting
the
user
.
"
docURISpec
.
get
(
)
)
;
nsContentUtils
:
:
ReportToConsoleNonLocalized
(
message
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Security
"
)
aDocument
)
;
}
nsPIDOMWindowOuter
*
win
=
aDocument
-
>
GetWindow
(
)
;
nsAutoCString
origin
;
rv
=
principal
-
>
GetOrigin
(
origin
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
XRE_IsContentProcess
(
)
)
{
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
win
)
;
if
(
browserChild
)
{
browserChild
-
>
SendShowCanvasPermissionPrompt
(
origin
isAutoBlockCanvas
)
;
}
}
else
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
win
isAutoBlockCanvas
?
TOPIC_CANVAS_PERMISSIONS_PROMPT_HIDE_DOORHANGER
:
TOPIC_CANVAS_PERMISSIONS_PROMPT
NS_ConvertUTF8toUTF16
(
origin
)
.
get
(
)
)
;
}
}
return
false
;
}
bool
GetCanvasContextType
(
const
nsAString
&
str
dom
:
:
CanvasContextType
*
const
out_type
)
{
if
(
str
.
EqualsLiteral
(
"
2d
"
)
)
{
*
out_type
=
dom
:
:
CanvasContextType
:
:
Canvas2D
;
return
true
;
}
if
(
str
.
EqualsLiteral
(
"
webgl
"
)
|
|
str
.
EqualsLiteral
(
"
experimental
-
webgl
"
)
)
{
*
out_type
=
dom
:
:
CanvasContextType
:
:
WebGL1
;
return
true
;
}
if
(
WebGL2Context
:
:
IsSupported
(
)
)
{
if
(
str
.
EqualsLiteral
(
"
webgl2
"
)
)
{
*
out_type
=
dom
:
:
CanvasContextType
:
:
WebGL2
;
return
true
;
}
}
if
(
str
.
EqualsLiteral
(
"
bitmaprenderer
"
)
)
{
*
out_type
=
dom
:
:
CanvasContextType
:
:
ImageBitmap
;
return
true
;
}
return
false
;
}
void
DoDrawImageSecurityCheck
(
dom
:
:
HTMLCanvasElement
*
aCanvasElement
nsIPrincipal
*
aPrincipal
bool
forceWriteOnly
bool
CORSUsed
)
{
if
(
!
aCanvasElement
)
{
NS_WARNING
(
"
DoDrawImageSecurityCheck
called
without
canvas
element
!
"
)
;
return
;
}
if
(
aCanvasElement
-
>
IsWriteOnly
(
)
&
&
!
aCanvasElement
-
>
mExpandedReader
)
{
return
;
}
if
(
forceWriteOnly
)
{
aCanvasElement
-
>
SetWriteOnly
(
)
;
return
;
}
if
(
CORSUsed
)
return
;
MOZ_ASSERT
(
aPrincipal
"
Must
have
a
principal
here
"
)
;
if
(
aCanvasElement
-
>
NodePrincipal
(
)
-
>
Subsumes
(
aPrincipal
)
)
{
return
;
}
if
(
BasePrincipal
:
:
Cast
(
aPrincipal
)
-
>
AddonPolicy
(
)
)
{
if
(
aCanvasElement
-
>
mExpandedReader
&
&
aCanvasElement
-
>
mExpandedReader
-
>
Subsumes
(
aPrincipal
)
)
{
return
;
}
if
(
!
aCanvasElement
-
>
mExpandedReader
)
{
aCanvasElement
-
>
SetWriteOnly
(
aPrincipal
)
;
return
;
}
}
aCanvasElement
-
>
SetWriteOnly
(
)
;
}
bool
CoerceDouble
(
const
JS
:
:
Value
&
v
double
*
d
)
{
if
(
v
.
isDouble
(
)
)
{
*
d
=
v
.
toDouble
(
)
;
}
else
if
(
v
.
isInt32
(
)
)
{
*
d
=
double
(
v
.
toInt32
(
)
)
;
}
else
if
(
v
.
isUndefined
(
)
)
{
*
d
=
0
.
0
;
}
else
{
return
false
;
}
return
true
;
}
bool
HasDrawWindowPrivilege
(
JSContext
*
aCx
JSObject
*
)
{
return
nsContentUtils
:
:
CallerHasPermission
(
aCx
nsGkAtoms
:
:
all_urlsPermission
)
;
}
bool
CheckWriteOnlySecurity
(
bool
aCORSUsed
nsIPrincipal
*
aPrincipal
bool
aHadCrossOriginRedirects
)
{
if
(
!
aPrincipal
)
{
return
true
;
}
if
(
!
aCORSUsed
)
{
if
(
aHadCrossOriginRedirects
)
{
return
true
;
}
nsIGlobalObject
*
incumbentSettingsObject
=
dom
:
:
GetIncumbentGlobal
(
)
;
if
(
!
incumbentSettingsObject
)
{
return
true
;
}
nsIPrincipal
*
principal
=
incumbentSettingsObject
-
>
PrincipalOrNull
(
)
;
if
(
NS_WARN_IF
(
!
principal
)
|
|
!
(
principal
-
>
Subsumes
(
aPrincipal
)
)
)
{
return
true
;
}
}
return
false
;
}
}
}
