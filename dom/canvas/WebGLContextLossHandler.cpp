#
include
"
WebGLContextLossHandler
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
WebGLContext
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
namespace
mozilla
{
class
ContextLossWorkerEventTarget
final
:
public
nsIEventTarget
{
public
:
explicit
ContextLossWorkerEventTarget
(
nsIEventTarget
*
aEventTarget
)
:
mEventTarget
(
aEventTarget
)
{
MOZ_ASSERT
(
aEventTarget
)
;
}
NS_DECL_NSIEVENTTARGET
NS_DECL_THREADSAFE_ISUPPORTS
protected
:
~
ContextLossWorkerEventTarget
(
)
{
}
private
:
nsCOMPtr
<
nsIEventTarget
>
mEventTarget
;
}
;
class
ContextLossWorkerRunnable
final
:
public
nsICancelableRunnable
{
public
:
explicit
ContextLossWorkerRunnable
(
nsIRunnable
*
aRunnable
)
:
mRunnable
(
aRunnable
)
{
}
NS_DECL_NSICANCELABLERUNNABLE
NS_DECL_THREADSAFE_ISUPPORTS
NS_FORWARD_NSIRUNNABLE
(
mRunnable
-
>
)
protected
:
~
ContextLossWorkerRunnable
(
)
{
}
private
:
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
}
;
NS_IMPL_ISUPPORTS
(
ContextLossWorkerEventTarget
nsIEventTarget
nsISupports
)
NS_IMETHODIMP
ContextLossWorkerEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aEvent
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
event
(
aEvent
)
;
return
Dispatch
(
event
.
forget
(
)
aFlags
)
;
}
NS_IMETHODIMP
ContextLossWorkerEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aEvent
uint32_t
aFlags
)
{
nsCOMPtr
<
nsIRunnable
>
eventRef
(
aEvent
)
;
nsRefPtr
<
ContextLossWorkerRunnable
>
wrappedEvent
=
new
ContextLossWorkerRunnable
(
eventRef
)
;
return
mEventTarget
-
>
Dispatch
(
wrappedEvent
aFlags
)
;
}
NS_IMETHODIMP
ContextLossWorkerEventTarget
:
:
IsOnCurrentThread
(
bool
*
aResult
)
{
return
mEventTarget
-
>
IsOnCurrentThread
(
aResult
)
;
}
NS_IMPL_ISUPPORTS
(
ContextLossWorkerRunnable
nsICancelableRunnable
nsIRunnable
)
NS_IMETHODIMP
ContextLossWorkerRunnable
:
:
Cancel
(
)
{
mRunnable
=
nullptr
;
return
NS_OK
;
}
WebGLContextLossHandler
:
:
WebGLContextLossHandler
(
WebGLContext
*
webgl
)
:
mWeakWebGL
(
webgl
)
mTimer
(
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
)
mIsTimerRunning
(
false
)
mShouldRunTimerAgain
(
false
)
mIsDisabled
(
false
)
mFeatureAdded
(
false
)
#
ifdef
DEBUG
mThread
(
NS_GetCurrentThread
(
)
)
#
endif
{
}
WebGLContextLossHandler
:
:
~
WebGLContextLossHandler
(
)
{
MOZ_ASSERT
(
!
mIsTimerRunning
)
;
}
void
WebGLContextLossHandler
:
:
StartTimer
(
unsigned
long
delayMS
)
{
this
-
>
AddRef
(
)
;
mTimer
-
>
InitWithFuncCallback
(
StaticTimerCallback
static_cast
<
void
*
>
(
this
)
delayMS
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
void
WebGLContextLossHandler
:
:
StaticTimerCallback
(
nsITimer
*
void
*
voidHandler
)
{
typedef
WebGLContextLossHandler
T
;
T
*
handler
=
static_cast
<
T
*
>
(
voidHandler
)
;
handler
-
>
TimerCallback
(
)
;
handler
-
>
Release
(
)
;
}
void
WebGLContextLossHandler
:
:
TimerCallback
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mThread
)
;
MOZ_ASSERT
(
mIsTimerRunning
)
;
mIsTimerRunning
=
false
;
if
(
mIsDisabled
)
return
;
if
(
mShouldRunTimerAgain
)
{
RunTimer
(
)
;
MOZ_ASSERT
(
mIsTimerRunning
)
;
}
if
(
mWeakWebGL
)
{
mWeakWebGL
-
>
UpdateContextLossStatus
(
)
;
}
}
void
WebGLContextLossHandler
:
:
RunTimer
(
)
{
MOZ_ASSERT
(
!
mIsDisabled
)
;
if
(
mIsTimerRunning
)
{
mShouldRunTimerAgain
=
true
;
return
;
}
if
(
!
NS_IsMainThread
(
)
)
{
dom
:
:
workers
:
:
WorkerPrivate
*
workerPrivate
=
dom
:
:
workers
:
:
GetCurrentThreadWorkerPrivate
(
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
workerPrivate
-
>
GetEventTarget
(
)
;
mTimer
-
>
SetTarget
(
new
ContextLossWorkerEventTarget
(
target
)
)
;
if
(
!
mFeatureAdded
)
{
workerPrivate
-
>
AddFeature
(
workerPrivate
-
>
GetJSContext
(
)
this
)
;
mFeatureAdded
=
true
;
}
}
StartTimer
(
1000
)
;
mIsTimerRunning
=
true
;
mShouldRunTimerAgain
=
false
;
}
void
WebGLContextLossHandler
:
:
DisableTimer
(
)
{
if
(
mIsDisabled
)
return
;
mIsDisabled
=
true
;
if
(
mFeatureAdded
)
{
dom
:
:
workers
:
:
WorkerPrivate
*
workerPrivate
=
dom
:
:
workers
:
:
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_RELEASE_ASSERT
(
workerPrivate
)
;
workerPrivate
-
>
RemoveFeature
(
workerPrivate
-
>
GetJSContext
(
)
this
)
;
mFeatureAdded
=
false
;
}
if
(
!
mIsTimerRunning
)
return
;
mTimer
-
>
SetDelay
(
0
)
;
}
bool
WebGLContextLossHandler
:
:
Notify
(
JSContext
*
aCx
dom
:
:
workers
:
:
Status
aStatus
)
{
bool
isWorkerRunning
=
aStatus
<
dom
:
:
workers
:
:
Closing
;
if
(
!
isWorkerRunning
&
&
mIsTimerRunning
)
{
mIsTimerRunning
=
false
;
this
-
>
Release
(
)
;
}
return
true
;
}
}
