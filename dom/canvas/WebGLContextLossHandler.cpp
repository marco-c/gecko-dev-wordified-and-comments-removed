#
include
"
WebGLContextLossHandler
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
WebGLContext
.
h
"
namespace
mozilla
{
class
WatchdogTimerEvent
final
:
public
nsITimerCallback
{
const
WeakPtr
<
WebGLContextLossHandler
>
mHandler
;
public
:
NS_DECL_ISUPPORTS
explicit
WatchdogTimerEvent
(
WebGLContextLossHandler
*
handler
)
:
mHandler
(
handler
)
{
}
private
:
virtual
~
WatchdogTimerEvent
(
)
{
}
NS_IMETHOD
Notify
(
nsITimer
*
)
override
{
if
(
mHandler
)
{
mHandler
-
>
TimerCallback
(
)
;
}
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
WatchdogTimerEvent
nsITimerCallback
nsISupports
)
WebGLContextLossHandler
:
:
WebGLContextLossHandler
(
WebGLContext
*
webgl
)
:
mWebGL
(
webgl
)
mTimer
(
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
)
mTimerPending
(
false
)
mShouldRunTimerAgain
(
false
)
#
ifdef
DEBUG
mThread
(
NS_GetCurrentThread
(
)
)
#
endif
{
MOZ_ASSERT
(
mThread
)
;
}
WebGLContextLossHandler
:
:
~
WebGLContextLossHandler
(
)
{
const
DebugOnly
<
nsIThread
*
>
callingThread
=
NS_GetCurrentThread
(
)
;
MOZ_ASSERT
(
callingThread
=
=
mThread
|
|
!
callingThread
)
;
}
void
WebGLContextLossHandler
:
:
RunTimer
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mThread
)
;
if
(
mTimerPending
)
{
mShouldRunTimerAgain
=
true
;
return
;
}
const
RefPtr
<
WatchdogTimerEvent
>
event
=
new
WatchdogTimerEvent
(
this
)
;
const
uint32_t
kDelayMS
=
1000
;
mTimer
-
>
InitWithCallback
(
event
kDelayMS
nsITimer
:
:
TYPE_ONE_SHOT
)
;
mTimerPending
=
true
;
}
void
WebGLContextLossHandler
:
:
TimerCallback
(
)
{
MOZ_ASSERT
(
NS_GetCurrentThread
(
)
=
=
mThread
)
;
mTimerPending
=
false
;
const
bool
runOnceMore
=
mShouldRunTimerAgain
;
mShouldRunTimerAgain
=
false
;
mWebGL
-
>
UpdateContextLossStatus
(
)
;
if
(
runOnceMore
&
&
!
mTimerPending
)
{
RunTimer
(
)
;
}
}
}
