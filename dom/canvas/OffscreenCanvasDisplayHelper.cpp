#
include
"
OffscreenCanvasDisplayHelper
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
CanvasManagerChild
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
mozilla
/
layers
/
ImageBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
TextureClientSharedSurface
.
h
"
#
include
"
mozilla
/
layers
/
TextureWrapperImage
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
nsICanvasRenderingContextInternal
.
h
"
namespace
mozilla
:
:
dom
{
OffscreenCanvasDisplayHelper
:
:
OffscreenCanvasDisplayHelper
(
HTMLCanvasElement
*
aCanvasElement
uint32_t
aWidth
uint32_t
aHeight
)
:
mMutex
(
"
mozilla
:
:
dom
:
:
OffscreenCanvasDisplayHelper
"
)
mCanvasElement
(
aCanvasElement
)
mImageProducerID
(
layers
:
:
ImageContainer
:
:
AllocateProducerID
(
)
)
{
mData
.
mSize
.
width
=
aWidth
;
mData
.
mSize
.
height
=
aHeight
;
}
OffscreenCanvasDisplayHelper
:
:
~
OffscreenCanvasDisplayHelper
(
)
=
default
;
void
OffscreenCanvasDisplayHelper
:
:
Destroy
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mCanvasElement
=
nullptr
;
}
CanvasContextType
OffscreenCanvasDisplayHelper
:
:
GetContextType
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mType
;
}
RefPtr
<
layers
:
:
ImageContainer
>
OffscreenCanvasDisplayHelper
:
:
GetImageContainer
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mImageContainer
;
}
layers
:
:
CompositableHandle
OffscreenCanvasDisplayHelper
:
:
GetCompositableHandle
(
)
const
{
MutexAutoLock
lock
(
mMutex
)
;
return
mData
.
mHandle
;
}
void
OffscreenCanvasDisplayHelper
:
:
UpdateContext
(
CanvasContextType
aType
const
Maybe
<
int32_t
>
&
aChildId
)
{
RefPtr
<
layers
:
:
ImageContainer
>
imageContainer
;
if
(
aType
!
=
CanvasContextType
:
:
WebGPU
)
{
imageContainer
=
MakeRefPtr
<
layers
:
:
ImageContainer
>
(
layers
:
:
ImageContainer
:
:
ASYNCHRONOUS
)
;
}
MutexAutoLock
lock
(
mMutex
)
;
mType
=
aType
;
mContextChildId
=
aChildId
;
mImageContainer
=
std
:
:
move
(
imageContainer
)
;
if
(
aChildId
)
{
mContextManagerId
=
Some
(
gfx
:
:
CanvasManagerChild
:
:
Get
(
)
-
>
Id
(
)
)
;
}
else
{
mContextManagerId
.
reset
(
)
;
}
MaybeQueueInvalidateElement
(
)
;
}
bool
OffscreenCanvasDisplayHelper
:
:
CommitFrameToCompositor
(
nsICanvasRenderingContextInternal
*
aContext
layers
:
:
TextureType
aTextureType
const
Maybe
<
OffscreenCanvasDisplayData
>
&
aData
)
{
MutexAutoLock
lock
(
mMutex
)
;
gfx
:
:
SurfaceFormat
format
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8A8
;
layers
:
:
TextureFlags
flags
=
layers
:
:
TextureFlags
:
:
IMMUTABLE
;
if
(
!
mCanvasElement
)
{
return
false
;
}
if
(
aData
)
{
mData
=
aData
.
ref
(
)
;
MaybeQueueInvalidateElement
(
)
;
}
if
(
mData
.
mHandle
)
{
return
true
;
}
if
(
!
mImageContainer
)
{
return
false
;
}
if
(
mData
.
mIsOpaque
)
{
flags
|
=
layers
:
:
TextureFlags
:
:
IS_OPAQUE
;
format
=
gfx
:
:
SurfaceFormat
:
:
B8G8R8X8
;
}
else
if
(
!
mData
.
mIsAlphaPremult
)
{
flags
|
=
layers
:
:
TextureFlags
:
:
NON_PREMULTIPLIED
;
}
switch
(
mData
.
mOriginPos
)
{
case
gl
:
:
OriginPos
:
:
BottomLeft
:
flags
|
=
layers
:
:
TextureFlags
:
:
ORIGIN_BOTTOM_LEFT
;
break
;
case
gl
:
:
OriginPos
:
:
TopLeft
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
origin
position
!
"
)
;
break
;
}
auto
imageBridge
=
layers
:
:
ImageBridgeChild
:
:
GetSingleton
(
)
;
if
(
!
imageBridge
)
{
return
false
;
}
bool
paintCallbacks
=
mData
.
mDoPaintCallbacks
;
RefPtr
<
layers
:
:
Image
>
image
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
;
Maybe
<
layers
:
:
SurfaceDescriptor
>
desc
;
{
MutexAutoUnlock
unlock
(
mMutex
)
;
if
(
paintCallbacks
)
{
aContext
-
>
OnBeforePaintTransaction
(
)
;
}
desc
=
aContext
-
>
PresentFrontBuffer
(
nullptr
aTextureType
)
;
if
(
!
desc
)
{
surface
=
aContext
-
>
GetFrontBufferSnapshot
(
false
)
;
if
(
surface
&
&
surface
-
>
GetType
(
)
=
=
gfx
:
:
SurfaceType
:
:
WEBGL
)
{
gfx
:
:
DataSourceSurface
:
:
ScopedMap
map
(
static_cast
<
gfx
:
:
DataSourceSurface
*
>
(
surface
.
get
(
)
)
gfx
:
:
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
surface
=
nullptr
;
}
}
}
if
(
paintCallbacks
)
{
aContext
-
>
OnDidPaintTransaction
(
)
;
}
}
if
(
desc
)
{
if
(
desc
-
>
type
(
)
=
=
layers
:
:
SurfaceDescriptor
:
:
TSurfaceDescriptorRemoteTexture
)
{
const
auto
&
textureDesc
=
desc
-
>
get_SurfaceDescriptorRemoteTexture
(
)
;
imageBridge
-
>
UpdateCompositable
(
mImageContainer
textureDesc
.
textureId
(
)
textureDesc
.
ownerId
(
)
mData
.
mSize
flags
)
;
}
else
{
RefPtr
<
layers
:
:
TextureClient
>
texture
=
layers
:
:
SharedSurfaceTextureData
:
:
CreateTextureClient
(
*
desc
format
mData
.
mSize
flags
imageBridge
)
;
if
(
texture
)
{
image
=
new
layers
:
:
TextureWrapperImage
(
texture
gfx
:
:
IntRect
(
gfx
:
:
IntPoint
(
0
0
)
mData
.
mSize
)
)
;
}
}
}
else
if
(
surface
)
{
auto
surfaceImage
=
MakeRefPtr
<
layers
:
:
SourceSurfaceImage
>
(
surface
)
;
surfaceImage
-
>
SetTextureFlags
(
flags
)
;
image
=
surfaceImage
;
}
if
(
image
)
{
AutoTArray
<
layers
:
:
ImageContainer
:
:
NonOwningImage
1
>
imageList
;
imageList
.
AppendElement
(
layers
:
:
ImageContainer
:
:
NonOwningImage
(
image
TimeStamp
(
)
mLastFrameID
+
+
mImageProducerID
)
)
;
mImageContainer
-
>
SetCurrentImages
(
imageList
)
;
}
else
if
(
!
desc
|
|
desc
-
>
type
(
)
!
=
layers
:
:
SurfaceDescriptor
:
:
TSurfaceDescriptorRemoteTexture
)
{
mImageContainer
-
>
ClearAllImages
(
)
;
}
mFrontBufferSurface
=
surface
;
return
true
;
}
void
OffscreenCanvasDisplayHelper
:
:
MaybeQueueInvalidateElement
(
)
{
mMutex
.
AssertCurrentThreadOwns
(
)
;
if
(
!
mPendingInvalidate
)
{
mPendingInvalidate
=
true
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
OffscreenCanvasDisplayHelper
:
:
InvalidateElement
"
[
self
=
RefPtr
{
this
}
]
{
self
-
>
InvalidateElement
(
)
;
}
)
)
;
}
}
void
OffscreenCanvasDisplayHelper
:
:
InvalidateElement
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
HTMLCanvasElement
*
canvasElement
;
gfx
:
:
IntSize
size
;
{
MutexAutoLock
lock
(
mMutex
)
;
MOZ_ASSERT
(
mPendingInvalidate
)
;
mPendingInvalidate
=
false
;
canvasElement
=
mCanvasElement
;
size
=
mData
.
mSize
;
}
if
(
canvasElement
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
canvasElement
)
;
canvasElement
-
>
InvalidateCanvasPlaceholder
(
size
.
width
size
.
height
)
;
canvasElement
-
>
InvalidateCanvasContent
(
nullptr
)
;
}
}
bool
OffscreenCanvasDisplayHelper
:
:
TransformSurface
(
const
gfx
:
:
DataSourceSurface
:
:
ScopedMap
&
aSrcMap
const
gfx
:
:
DataSourceSurface
:
:
ScopedMap
&
aDstMap
gfx
:
:
SurfaceFormat
aFormat
const
gfx
:
:
IntSize
&
aSize
bool
aNeedsPremult
gl
:
:
OriginPos
aOriginPos
)
const
{
if
(
!
aSrcMap
.
IsMapped
(
)
|
|
!
aDstMap
.
IsMapped
(
)
)
{
return
false
;
}
switch
(
aOriginPos
)
{
case
gl
:
:
OriginPos
:
:
BottomLeft
:
if
(
aNeedsPremult
)
{
return
gfx
:
:
PremultiplyYFlipData
(
aSrcMap
.
GetData
(
)
aSrcMap
.
GetStride
(
)
aFormat
aDstMap
.
GetData
(
)
aDstMap
.
GetStride
(
)
aFormat
aSize
)
;
}
return
gfx
:
:
SwizzleYFlipData
(
aSrcMap
.
GetData
(
)
aSrcMap
.
GetStride
(
)
aFormat
aDstMap
.
GetData
(
)
aDstMap
.
GetStride
(
)
aFormat
aSize
)
;
case
gl
:
:
OriginPos
:
:
TopLeft
:
if
(
aNeedsPremult
)
{
return
gfx
:
:
PremultiplyData
(
aSrcMap
.
GetData
(
)
aSrcMap
.
GetStride
(
)
aFormat
aDstMap
.
GetData
(
)
aDstMap
.
GetStride
(
)
aFormat
aSize
)
;
}
return
gfx
:
:
SwizzleData
(
aSrcMap
.
GetData
(
)
aSrcMap
.
GetStride
(
)
aFormat
aDstMap
.
GetData
(
)
aDstMap
.
GetStride
(
)
aFormat
aSize
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
origin
position
!
"
)
;
break
;
}
return
false
;
}
already_AddRefed
<
gfx
:
:
SourceSurface
>
OffscreenCanvasDisplayHelper
:
:
GetSurfaceSnapshot
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
layers
:
:
SurfaceDescriptor
>
desc
;
bool
hasAlpha
;
bool
isAlphaPremult
;
gl
:
:
OriginPos
originPos
;
Maybe
<
uint32_t
>
managerId
;
Maybe
<
int32_t
>
childId
;
HTMLCanvasElement
*
canvasElement
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
;
layers
:
:
CompositableHandle
handle
;
{
MutexAutoLock
lock
(
mMutex
)
;
hasAlpha
=
!
mData
.
mIsOpaque
;
isAlphaPremult
=
mData
.
mIsAlphaPremult
;
originPos
=
mData
.
mOriginPos
;
handle
=
mData
.
mHandle
;
managerId
=
mContextManagerId
;
childId
=
mContextChildId
;
canvasElement
=
mCanvasElement
;
surface
=
mFrontBufferSurface
;
}
if
(
surface
)
{
if
(
originPos
=
=
gl
:
:
OriginPos
:
:
TopLeft
&
&
(
!
hasAlpha
|
|
isAlphaPremult
)
)
{
return
surface
.
forget
(
)
;
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
srcSurface
=
surface
-
>
GetDataSurface
(
)
;
if
(
!
srcSurface
)
{
return
nullptr
;
}
const
auto
size
=
srcSurface
-
>
GetSize
(
)
;
const
auto
format
=
srcSurface
-
>
GetFormat
(
)
;
RefPtr
<
gfx
:
:
DataSourceSurface
>
dstSurface
=
gfx
:
:
Factory
:
:
CreateDataSourceSurface
(
size
format
false
)
;
if
(
!
dstSurface
)
{
return
nullptr
;
}
gfx
:
:
DataSourceSurface
:
:
ScopedMap
srcMap
(
srcSurface
gfx
:
:
DataSourceSurface
:
:
READ
)
;
gfx
:
:
DataSourceSurface
:
:
ScopedMap
dstMap
(
dstSurface
gfx
:
:
DataSourceSurface
:
:
WRITE
)
;
if
(
!
TransformSurface
(
srcMap
dstMap
format
size
hasAlpha
&
&
!
isAlphaPremult
originPos
)
)
{
return
nullptr
;
}
return
dstSurface
.
forget
(
)
;
}
#
ifdef
MOZ_WIDGET_ANDROID
if
(
canvasElement
)
{
return
nullptr
;
}
#
endif
if
(
managerId
&
&
childId
)
{
return
gfx
:
:
CanvasManagerChild
:
:
Get
(
)
-
>
GetSnapshot
(
managerId
.
value
(
)
childId
.
value
(
)
handle
hasAlpha
?
gfx
:
:
SurfaceFormat
:
:
R8G8B8A8
:
gfx
:
:
SurfaceFormat
:
:
R8G8B8X8
hasAlpha
&
&
!
isAlphaPremult
originPos
=
=
gl
:
:
OriginPos
:
:
BottomLeft
)
;
}
if
(
!
canvasElement
)
{
return
nullptr
;
}
const
auto
*
offscreenCanvas
=
canvasElement
-
>
GetOffscreenCanvas
(
)
;
nsICanvasRenderingContextInternal
*
context
=
offscreenCanvas
-
>
GetContext
(
)
;
if
(
!
context
)
{
return
nullptr
;
}
surface
=
context
-
>
GetFrontBufferSnapshot
(
false
)
;
if
(
!
surface
)
{
return
nullptr
;
}
if
(
originPos
=
=
gl
:
:
OriginPos
:
:
TopLeft
&
&
(
!
hasAlpha
|
|
isAlphaPremult
)
)
{
return
surface
.
forget
(
)
;
}
RefPtr
<
gfx
:
:
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
if
(
!
dataSurface
)
{
return
nullptr
;
}
gfx
:
:
DataSourceSurface
:
:
ScopedMap
map
(
dataSurface
gfx
:
:
DataSourceSurface
:
:
READ_WRITE
)
;
if
(
!
TransformSurface
(
map
map
dataSurface
-
>
GetFormat
(
)
dataSurface
-
>
GetSize
(
)
hasAlpha
&
&
!
isAlphaPremult
originPos
)
)
{
return
nullptr
;
}
return
surface
.
forget
(
)
;
}
already_AddRefed
<
layers
:
:
Image
>
OffscreenCanvasDisplayHelper
:
:
GetAsImage
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
GetSurfaceSnapshot
(
)
;
if
(
!
surface
)
{
return
nullptr
;
}
return
MakeAndAddRef
<
layers
:
:
SourceSurfaceImage
>
(
surface
)
;
}
}
