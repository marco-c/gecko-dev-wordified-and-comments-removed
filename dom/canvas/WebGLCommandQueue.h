#
ifndef
WEBGLCOMMANDQUEUE_H_
#
define
WEBGLCOMMANDQUEUE_H_
#
include
"
mozilla
/
dom
/
ProducerConsumerQueue
.
h
"
#
include
"
mozilla
/
ipc
/
IPDLParamTraits
.
h
"
#
if
defined
(
_M_IX86
)
#
define
SINK_FCN_CC
__thiscall
#
else
#
define
SINK_FCN_CC
#
endif
namespace
mozilla
{
using
mozilla
:
:
ipc
:
:
IPDLParamTraits
;
using
mozilla
:
:
webgl
:
:
Consumer
;
using
mozilla
:
:
webgl
:
:
PcqStatus
;
using
mozilla
:
:
webgl
:
:
Producer
;
using
mozilla
:
:
webgl
:
:
ProducerConsumerQueue
;
template
<
typename
Derived
typename
SinkType
>
struct
FunctionDispatcher
;
template
<
typename
Derived
typename
SinkType
>
struct
MethodDispatcher
;
enum
CommandResult
{
Success
TimeExpired
QueueEmpty
Error
}
;
enum
CommandSyncType
{
ASYNC
SYNC
}
;
class
BasicSource
{
public
:
explicit
BasicSource
(
UniquePtr
<
Producer
>
&
&
aProducer
)
:
mProducer
(
std
:
:
move
(
aProducer
)
)
{
MOZ_ASSERT
(
mProducer
)
;
}
virtual
~
BasicSource
(
)
{
}
BasicSource
(
)
{
}
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
BasicSource
>
;
protected
:
UniquePtr
<
Producer
>
mProducer
;
}
;
class
BasicSink
{
public
:
explicit
BasicSink
(
UniquePtr
<
Consumer
>
&
&
aConsumer
)
:
mConsumer
(
std
:
:
move
(
aConsumer
)
)
{
MOZ_ASSERT
(
mConsumer
)
;
}
virtual
~
BasicSink
(
)
{
}
BasicSink
(
)
{
}
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
BasicSink
>
;
protected
:
UniquePtr
<
Consumer
>
mConsumer
;
}
;
template
<
typename
Command
>
class
CommandSource
:
public
BasicSource
{
public
:
explicit
CommandSource
(
UniquePtr
<
Producer
>
&
&
aProducer
)
:
BasicSource
(
std
:
:
move
(
aProducer
)
)
{
}
template
<
typename
.
.
.
Args
>
PcqStatus
InsertCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
return
this
-
>
mProducer
-
>
TryWaitInsert
(
Nothing
(
)
aCommand
aArgs
.
.
.
)
;
}
template
<
>
PcqStatus
InsertCommand
<
>
(
Command
aCommand
)
{
return
this
-
>
mProducer
-
>
TryWaitInsert
(
Nothing
(
)
aCommand
)
;
}
template
<
typename
.
.
.
Args
>
PcqStatus
RunCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
return
InsertCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
CommandSource
(
)
{
}
}
;
template
<
typename
Command
>
class
CommandSink
:
public
BasicSink
{
public
:
explicit
CommandSink
(
UniquePtr
<
Consumer
>
&
&
aConsumer
)
:
BasicSink
(
std
:
:
move
(
aConsumer
)
)
{
}
CommandResult
ProcessOne
(
const
Maybe
<
TimeDuration
>
&
aTimeout
)
{
Command
command
;
PcqStatus
status
=
(
aTimeout
.
isNothing
(
)
|
|
aTimeout
.
value
(
)
)
?
this
-
>
mConsumer
-
>
TryWaitRemove
(
aTimeout
command
)
:
this
-
>
mConsumer
-
>
TryRemove
(
command
)
;
if
(
status
=
=
PcqStatus
:
:
Success
)
{
if
(
DispatchCommand
(
command
)
)
{
return
CommandResult
:
:
Success
;
}
return
CommandResult
:
:
Error
;
}
if
(
status
=
=
PcqStatus
:
:
PcqNotReady
)
{
return
CommandResult
:
:
QueueEmpty
;
}
if
(
status
=
=
PcqStatus
:
:
PcqOOMError
)
{
ReportOOM
(
)
;
}
return
CommandResult
:
:
Error
;
}
CommandResult
ProcessOneNow
(
)
{
return
ProcessOne
(
Some
(
TimeDuration
(
0
)
)
)
;
}
CommandResult
ProcessAll
(
)
{
CommandResult
result
;
do
{
result
=
ProcessOneNow
(
)
;
}
while
(
result
=
=
CommandResult
:
:
Success
)
;
return
result
;
}
CommandResult
ProcessUpToDuration
(
TimeDuration
aDuration
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
now
=
start
;
CommandResult
result
;
do
{
result
=
ProcessOne
(
Some
(
aDuration
-
(
now
-
start
)
)
)
;
now
=
TimeStamp
:
:
Now
(
)
;
}
while
(
(
result
=
=
CommandResult
:
:
Success
)
&
&
(
(
now
-
start
)
<
aDuration
)
)
;
return
result
;
}
CommandSink
(
)
{
}
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
T
&
aObj
ReturnType
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
const
T
&
aObj
ReturnType
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchAsyncFunction
(
ReturnType
(
*
aFunc
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallFunction
(
aFunc
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
T
*
aObj
void
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
const
T
*
aObj
void
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
.
.
.
Args
>
bool
DispatchAsyncFunction
(
void
(
*
aFunc
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallVoidFunction
(
aFunc
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
protected
:
virtual
bool
DispatchCommand
(
Command
command
)
=
0
;
virtual
void
ReportOOM
(
)
{
}
template
<
typename
.
.
.
Args
size_t
.
.
.
Indices
>
PcqStatus
CallTryRemove
(
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
PcqStatus
status
=
mConsumer
-
>
TryRemove
(
std
:
:
get
<
Indices
>
(
aArgs
)
.
.
.
)
;
MOZ_ASSERT
(
status
!
=
PcqStatus
:
:
PcqNotReady
)
;
return
status
;
}
template
<
>
PcqStatus
CallTryRemove
(
std
:
:
tuple
<
>
&
aArgs
std
:
:
make_integer_sequence
<
size_t
0
>
)
{
return
PcqStatus
:
:
Success
;
}
template
<
typename
T
typename
MethodType
typename
.
.
.
Args
size_t
.
.
.
Indices
typename
ReturnType
=
typename
mozilla
:
:
FunctionTypeTraits
<
MethodType
>
:
:
ReturnType
>
ReturnType
CallMethod
(
T
&
aObj
MethodType
aMethod
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
return
(
aObj
.
*
aMethod
)
(
std
:
:
forward
<
Args
>
(
std
:
:
get
<
Indices
>
(
aArgs
)
)
.
.
.
)
;
}
template
<
typename
FunctionType
typename
.
.
.
Args
size_t
.
.
.
Indices
typename
ReturnType
=
typename
mozilla
:
:
FunctionTypeTraits
<
FunctionType
>
:
:
ReturnType
>
ReturnType
CallFunction
(
FunctionType
aFunc
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
return
(
*
aFunc
)
(
std
:
:
forward
<
Args
>
(
std
:
:
get
<
Indices
>
(
aArgs
)
)
.
.
.
)
;
}
template
<
typename
T
typename
MethodType
typename
.
.
.
Args
size_t
.
.
.
Indices
>
void
CallVoidMethod
(
T
&
aObj
MethodType
aMethod
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
(
aObj
.
*
aMethod
)
(
std
:
:
forward
<
Args
>
(
std
:
:
get
<
Indices
>
(
aArgs
)
)
.
.
.
)
;
}
template
<
typename
FunctionType
typename
.
.
.
Args
size_t
.
.
.
Indices
>
void
CallVoidFunction
(
FunctionType
aFunc
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
(
*
aFunc
)
(
std
:
:
forward
<
Args
>
(
std
:
:
get
<
Indices
>
(
aArgs
)
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
bool
ReadArgs
(
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
)
{
PcqStatus
status
=
CallTryRemove
(
aArgs
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
IsSuccess
(
status
)
;
}
}
;
enum
SyncResponse
:
uint8_t
{
RESPONSE_NAK
RESPONSE_ACK
}
;
template
<
typename
Command
>
class
SyncCommandSource
:
public
CommandSource
<
Command
>
{
public
:
using
BaseType
=
CommandSource
<
Command
>
;
SyncCommandSource
(
UniquePtr
<
Producer
>
&
&
aProducer
UniquePtr
<
Consumer
>
&
&
aResponseConsumer
)
:
CommandSource
<
Command
>
(
std
:
:
move
(
aProducer
)
)
mConsumer
(
std
:
:
move
(
aResponseConsumer
)
)
{
}
template
<
typename
.
.
.
Args
>
PcqStatus
RunAsyncCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
return
this
-
>
RunCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
PcqStatus
RunVoidSyncCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
PcqStatus
status
=
RunAsyncCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
IsSuccess
(
status
)
?
this
-
>
ReadSyncResponse
(
)
:
status
;
}
template
<
typename
ResultType
typename
.
.
.
Args
>
PcqStatus
RunSyncCommand
(
Command
aCommand
ResultType
&
aReturn
Args
&
&
.
.
.
aArgs
)
{
PcqStatus
status
=
RunVoidSyncCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
IsSuccess
(
status
)
?
this
-
>
ReadResult
(
aReturn
)
:
status
;
}
SyncCommandSource
(
)
{
}
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
SyncCommandSource
<
Command
>
>
;
protected
:
PcqStatus
ReadSyncResponse
(
)
{
SyncResponse
response
;
PcqStatus
status
=
mConsumer
-
>
TryWaitRemove
(
Nothing
(
)
response
)
;
MOZ_ASSERT
(
status
!
=
PcqStatus
:
:
PcqNotReady
)
;
if
(
IsSuccess
(
status
)
&
&
response
!
=
RESPONSE_ACK
)
{
return
PcqStatus
:
:
PcqFatalError
;
}
return
status
;
}
template
<
typename
T
>
PcqStatus
ReadResult
(
T
&
aResult
)
{
PcqStatus
status
=
mConsumer
-
>
TryRemove
(
aResult
)
;
MOZ_ASSERT
(
status
!
=
PcqStatus
:
:
PcqNotReady
)
;
return
status
;
}
UniquePtr
<
Consumer
>
mConsumer
;
}
;
template
<
typename
Command
>
class
SyncCommandSink
:
public
CommandSink
<
Command
>
{
using
BaseType
=
CommandSink
<
Command
>
;
public
:
SyncCommandSink
(
UniquePtr
<
Consumer
>
&
&
aConsumer
UniquePtr
<
Producer
>
&
&
aResponseProducer
)
:
CommandSink
<
Command
>
(
std
:
:
move
(
aConsumer
)
)
mProducer
(
std
:
:
move
(
aResponseProducer
)
)
{
}
SyncCommandSink
(
)
{
}
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
SyncCommandSink
<
Command
>
>
;
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
ReturnType
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
ReturnType
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
#
if
defined
(
_M_IX86
)
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
ReturnType
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
ReturnType
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
#
endif
template
<
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncFunction
(
ReturnType
(
*
aFunc
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallFunction
(
aFunc
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
void
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
void
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
#
if
defined
(
_M_IX86
)
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
void
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
void
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
#
endif
template
<
typename
.
.
.
Args
>
bool
DispatchSyncFunction
(
void
(
*
aFunc
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
typename
RemoveCV
<
typename
RemoveReference
<
Args
>
:
:
Type
>
:
:
Type
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidFunction
(
aFunc
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
protected
:
template
<
typename
.
.
.
Args
>
bool
WriteArgs
(
const
Args
&
.
.
.
aArgs
)
{
return
IsSuccess
(
mProducer
-
>
TryInsert
(
aArgs
.
.
.
)
)
;
}
template
<
typename
.
.
.
Args
>
bool
WriteACK
(
const
Args
&
.
.
.
aArgs
)
{
SyncResponse
ack
=
RESPONSE_ACK
;
return
WriteArgs
(
ack
aArgs
.
.
.
)
;
}
bool
WriteNAK
(
)
{
SyncResponse
nak
=
RESPONSE_NAK
;
return
WriteArgs
(
nak
)
;
}
UniquePtr
<
Producer
>
mProducer
;
}
;
template
<
typename
Derived
>
struct
CommandDispatchDriver
{
template
<
size_t
commandId
typename
.
.
.
Args
>
static
MOZ_ALWAYS_INLINE
bool
DispatchCommandHelper
(
size_t
aId
Args
&
.
.
.
aArgs
)
{
if
(
commandId
=
=
aId
)
{
return
Derived
:
:
template
Dispatch
<
commandId
>
(
aArgs
.
.
.
)
;
}
return
Derived
:
:
template
DispatchCommand
<
commandId
+
1
>
(
aId
aArgs
.
.
.
)
;
}
}
;
template
<
typename
Derived
typename
_SinkType
>
struct
FunctionDispatcher
{
using
SinkType
=
_SinkType
;
template
<
CommandSyncType
syncType
>
struct
DispatchFunction
;
template
<
>
struct
DispatchFunction
<
CommandSyncType
:
:
ASYNC
>
{
template
<
typename
FunctionType
>
static
MOZ_ALWAYS_INLINE
bool
Run
(
SinkType
&
aSink
FunctionType
function
)
{
return
aSink
.
DispatchAsyncFunction
(
function
)
;
}
}
;
template
<
>
struct
DispatchFunction
<
CommandSyncType
:
:
SYNC
>
{
template
<
typename
FunctionType
>
static
MOZ_ALWAYS_INLINE
bool
Run
(
SinkType
&
aSink
FunctionType
function
)
{
return
aSink
.
DispatchSyncFunction
(
function
)
;
}
}
;
}
;
template
<
typename
Derived
typename
_SinkType
>
struct
MethodDispatcher
{
using
SinkType
=
_SinkType
;
template
<
CommandSyncType
syncType
>
struct
DispatchMethod
;
template
<
>
struct
DispatchMethod
<
CommandSyncType
:
:
ASYNC
>
{
template
<
typename
MethodType
typename
ObjectType
>
static
MOZ_ALWAYS_INLINE
bool
Run
(
SinkType
&
aSink
MethodType
mMethod
ObjectType
&
aObj
)
{
return
aSink
.
DispatchAsyncMethod
(
aObj
mMethod
)
;
}
}
;
template
<
>
struct
DispatchMethod
<
CommandSyncType
:
:
SYNC
>
{
template
<
typename
MethodType
typename
ObjectType
>
static
MOZ_ALWAYS_INLINE
bool
Run
(
SinkType
&
aSink
MethodType
aMethod
ObjectType
&
aObj
)
{
return
aSink
.
DispatchSyncMethod
(
aObj
aMethod
)
;
}
}
;
}
;
#
define
DECLARE_FUNCTION_DISPATCHER
(
_DISPATCHER
_SINKTYPE
)
\
struct
_DISPATCHER
:
public
FunctionDispatcher
<
_DISPATCHER
_SINKTYPE
>
{
\
template
<
size_t
commandId
=
0
>
\
static
MOZ_ALWAYS_INLINE
bool
DispatchCommand
(
size_t
aId
)
{
\
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
command
ID
"
)
;
\
return
false
;
\
}
\
template
<
size_t
commandId
>
\
static
MOZ_ALWAYS_INLINE
bool
Dispatch
(
SinkType
&
aSink
)
;
\
template
<
size_t
commandId
>
\
struct
FuncInfo
;
\
template
<
size_t
commandId
>
\
static
constexpr
CommandSyncType
SyncType
(
)
;
\
template
<
typename
FuncType
FuncType
func
>
\
static
constexpr
size_t
Id
(
)
;
\
}
;
#
define
DECLARE_METHOD_DISPATCHER
(
_DISPATCHER
_SINKTYPE
_OBJECTTYPE
)
\
struct
_DISPATCHER
:
public
MethodDispatcher
<
_DISPATCHER
_SINKTYPE
>
{
\
using
ObjectType
=
_OBJECTTYPE
;
\
template
<
size_t
commandId
=
0
>
\
static
MOZ_ALWAYS_INLINE
bool
DispatchCommand
(
size_t
aId
SinkType
&
aSink
\
ObjectType
&
aObj
)
{
\
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
command
ID
"
)
;
\
return
false
;
\
}
\
template
<
size_t
commandId
>
\
static
MOZ_ALWAYS_INLINE
bool
Dispatch
(
SinkType
&
aSink
ObjectType
&
aObj
)
;
\
template
<
size_t
commandId
>
\
struct
MethodInfo
;
\
template
<
size_t
commandId
>
\
static
constexpr
CommandSyncType
SyncType
(
)
;
\
template
<
typename
MethodType
MethodType
method
>
\
static
constexpr
size_t
Id
(
)
;
\
}
;
#
define
DEFINE_FUNCTION_DISPATCHER
(
_DISPATCHER
_ID
_FUNC
_SYNC
)
\
template
<
>
\
bool
_DISPATCHER
:
:
DispatchCommand
<
_ID
>
(
size_t
aId
SinkType
&
aSink
)
{
\
return
CommandDispatchDriver
<
_DISPATCHER
>
:
:
DispatchCommandHelper
(
aId
\
aSink
)
;
\
}
\
template
<
>
\
bool
_DISPATCHER
:
:
Dispatch
<
_ID
>
(
SinkType
&
aSink
)
{
\
return
DispatchFunction
<
_SYNC
>
:
:
Run
(
aSink
&
_FUNC
)
;
\
}
\
template
<
>
\
struct
_DISPATCHER
:
:
FuncInfo
<
_ID
>
{
\
using
FuncType
=
decltype
(
&
_FUNC
)
;
\
}
;
\
template
<
>
\
constexpr
CommandSyncType
_DISPATCHER
:
:
SyncType
<
_ID
>
(
)
{
\
return
_SYNC
;
\
}
\
template
<
>
\
constexpr
size_t
_DISPATCHER
:
:
Id
<
decltype
(
&
_FUNC
)
&
_FUNC
>
(
)
{
\
return
_ID
;
\
}
#
define
DEFINE_METHOD_DISPATCHER
(
_DISPATCHER
_ID
_METHOD
_SYNC
)
\
template
<
>
\
struct
_DISPATCHER
:
:
MethodInfo
<
_ID
>
{
\
using
MethodType
=
decltype
(
&
_METHOD
)
;
\
}
;
\
template
<
>
\
constexpr
CommandSyncType
_DISPATCHER
:
:
SyncType
<
_ID
>
(
)
{
\
return
_SYNC
;
\
}
\
template
<
>
\
constexpr
size_t
_DISPATCHER
:
:
Id
<
decltype
(
&
_METHOD
)
&
_METHOD
>
(
)
{
\
return
_ID
;
\
}
namespace
ipc
{
template
<
typename
T
>
struct
IPDLParamTraits
;
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
BasicSource
>
{
public
:
typedef
mozilla
:
:
BasicSource
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
aParam
.
mProducer
)
;
WriteIPDLParam
(
aMsg
aActor
*
aParam
.
mProducer
.
get
(
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
Producer
*
producer
=
new
Producer
;
bool
ret
=
ReadIPDLParam
(
aMsg
aIter
aActor
producer
)
;
aResult
-
>
mProducer
.
reset
(
producer
)
;
return
ret
;
}
}
;
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
BasicSink
>
{
public
:
typedef
mozilla
:
:
BasicSink
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
aParam
.
mConsumer
)
;
WriteIPDLParam
(
aMsg
aActor
*
aParam
.
mConsumer
.
get
(
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
Consumer
*
consumer
=
new
Consumer
;
bool
ret
=
ReadIPDLParam
(
aMsg
aIter
aActor
consumer
)
;
aResult
-
>
mConsumer
.
reset
(
consumer
)
;
return
ret
;
}
}
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
CommandSource
<
Command
>
>
:
public
IPDLParamTraits
<
mozilla
:
:
BasicSource
>
{
public
:
typedef
mozilla
:
:
CommandSource
<
Command
>
paramType
;
}
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
CommandSink
<
Command
>
>
:
public
IPDLParamTraits
<
mozilla
:
:
BasicSink
>
{
public
:
typedef
mozilla
:
:
CommandSink
<
Command
>
paramType
;
}
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
SyncCommandSource
<
Command
>
>
:
public
IPDLParamTraits
<
mozilla
:
:
CommandSource
<
Command
>
>
{
public
:
typedef
mozilla
:
:
SyncCommandSource
<
Command
>
paramType
;
typedef
typename
paramType
:
:
BaseType
paramBaseType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
static_cast
<
const
paramBaseType
&
>
(
aParam
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mConsumer
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aParam
)
{
bool
result
=
ReadIPDLParam
(
aMsg
aIter
aActor
static_cast
<
paramBaseType
*
>
(
aParam
)
)
;
return
result
&
&
ReadIPDLParam
(
aMsg
aIter
aActor
&
aParam
-
>
mConsumer
)
;
}
}
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
SyncCommandSink
<
Command
>
>
:
public
IPDLParamTraits
<
mozilla
:
:
CommandSink
<
Command
>
>
{
public
:
typedef
mozilla
:
:
SyncCommandSink
<
Command
>
paramType
;
typedef
typename
paramType
:
:
BaseType
paramBaseType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
static_cast
<
const
paramBaseType
&
>
(
aParam
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mProducer
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aParam
)
{
bool
result
=
ReadIPDLParam
(
aMsg
aIter
aActor
static_cast
<
paramBaseType
*
>
(
aParam
)
)
;
return
result
&
&
ReadIPDLParam
(
aMsg
aIter
aActor
&
aParam
-
>
mProducer
)
;
}
}
;
}
}
#
endif
