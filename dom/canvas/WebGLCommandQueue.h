#
ifndef
WEBGLCOMMANDQUEUE_H_
#
define
WEBGLCOMMANDQUEUE_H_
#
include
"
mozilla
/
FunctionTypeTraits
.
h
"
#
include
"
mozilla
/
dom
/
ProducerConsumerQueue
.
h
"
#
include
"
mozilla
/
ipc
/
IPDLParamTraits
.
h
"
#
include
<
type_traits
>
#
if
defined
(
_M_IX86
)
#
define
SINK_FCN_CC
__thiscall
#
else
#
define
SINK_FCN_CC
#
endif
namespace
mozilla
{
using
mozilla
:
:
ipc
:
:
IPDLParamTraits
;
using
mozilla
:
:
webgl
:
:
Consumer
;
using
mozilla
:
:
webgl
:
:
Producer
;
using
mozilla
:
:
webgl
:
:
ProducerConsumerQueue
;
using
mozilla
:
:
webgl
:
:
QueueStatus
;
enum
CommandResult
{
kSuccess
kTimeExpired
kQueueEmpty
kError
}
;
enum
CommandSyncType
{
ASYNC
SYNC
}
;
template
<
typename
Command
>
class
CommandSource
{
public
:
explicit
CommandSource
(
UniquePtr
<
Producer
>
&
&
aSource
)
:
mSource
(
std
:
:
move
(
aSource
)
)
{
MOZ_ASSERT
(
mSource
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
InsertCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
return
this
-
>
mSource
-
>
TryWaitInsert
(
Nothing
(
)
aCommand
aArgs
.
.
.
)
;
}
QueueStatus
InsertCommand
(
Command
aCommand
)
{
return
this
-
>
mSource
-
>
TryWaitInsert
(
Nothing
(
)
aCommand
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
RunCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
return
InsertCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
CommandSource
(
)
=
default
;
protected
:
friend
struct
IPDLParamTraits
<
mozilla
:
:
CommandSource
<
Command
>
>
;
UniquePtr
<
Producer
>
mSource
;
}
;
template
<
typename
Command
>
class
CommandSink
{
public
:
explicit
CommandSink
(
UniquePtr
<
Consumer
>
&
&
aSink
)
:
mSink
(
std
:
:
move
(
aSink
)
)
{
MOZ_ASSERT
(
mSink
)
;
}
CommandResult
ProcessOne
(
const
Maybe
<
TimeDuration
>
&
aTimeout
)
{
Command
command
;
QueueStatus
status
=
(
aTimeout
.
isNothing
(
)
|
|
aTimeout
.
value
(
)
)
?
this
-
>
mSink
-
>
TryWaitRemove
(
aTimeout
command
)
:
this
-
>
mSink
-
>
TryRemove
(
command
)
;
if
(
status
=
=
QueueStatus
:
:
kSuccess
)
{
if
(
DispatchCommand
(
command
)
)
{
return
CommandResult
:
:
kSuccess
;
}
return
CommandResult
:
:
kError
;
}
if
(
status
=
=
QueueStatus
:
:
kNotReady
)
{
return
CommandResult
:
:
kQueueEmpty
;
}
if
(
status
=
=
QueueStatus
:
:
kOOMError
)
{
ReportOOM
(
)
;
}
return
CommandResult
:
:
kError
;
}
CommandResult
ProcessOneNow
(
)
{
return
ProcessOne
(
Some
(
TimeDuration
(
0
)
)
)
;
}
CommandResult
ProcessAll
(
)
{
CommandResult
result
;
do
{
result
=
ProcessOneNow
(
)
;
}
while
(
result
=
=
CommandResult
:
:
kSuccess
)
;
return
result
;
}
CommandResult
ProcessUpToDuration
(
TimeDuration
aDuration
)
{
TimeStamp
start
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
now
=
start
;
CommandResult
result
;
do
{
result
=
ProcessOne
(
Some
(
aDuration
-
(
now
-
start
)
)
)
;
now
=
TimeStamp
:
:
Now
(
)
;
}
while
(
(
result
=
=
CommandResult
:
:
kSuccess
)
&
&
(
(
now
-
start
)
<
aDuration
)
)
;
return
result
;
}
CommandSink
(
)
=
default
;
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
T
&
aObj
ReturnType
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
const
T
&
aObj
ReturnType
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
T
*
aObj
void
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchAsyncMethod
(
const
T
*
aObj
void
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
ReadArgs
(
args
)
)
{
return
false
;
}
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
true
;
}
protected
:
friend
struct
IPDLParamTraits
<
mozilla
:
:
CommandSink
<
Command
>
>
;
virtual
bool
DispatchCommand
(
Command
command
)
=
0
;
virtual
void
ReportOOM
(
)
{
}
template
<
typename
.
.
.
Args
size_t
.
.
.
Indices
>
QueueStatus
CallTryRemove
(
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
QueueStatus
status
=
mSink
-
>
TryRemove
(
std
:
:
get
<
Indices
>
(
aArgs
)
.
.
.
)
;
MOZ_ASSERT
(
status
!
=
QueueStatus
:
:
kNotReady
)
;
return
status
;
}
QueueStatus
CallTryRemove
(
std
:
:
tuple
<
>
&
aArgs
std
:
:
make_integer_sequence
<
size_t
0
>
)
{
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
T
typename
MethodType
typename
.
.
.
Args
size_t
.
.
.
Indices
typename
ReturnType
=
typename
mozilla
:
:
FunctionTypeTraits
<
MethodType
>
:
:
ReturnType
>
ReturnType
CallMethod
(
T
&
aObj
MethodType
aMethod
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
return
(
aObj
.
*
aMethod
)
(
std
:
:
forward
<
Args
>
(
std
:
:
get
<
Indices
>
(
aArgs
)
)
.
.
.
)
;
}
template
<
typename
T
typename
MethodType
typename
.
.
.
Args
size_t
.
.
.
Indices
>
void
CallVoidMethod
(
T
&
aObj
MethodType
aMethod
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
std
:
:
index_sequence
<
Indices
.
.
.
>
)
{
(
aObj
.
*
aMethod
)
(
std
:
:
forward
<
Args
>
(
std
:
:
get
<
Indices
>
(
aArgs
)
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
bool
ReadArgs
(
std
:
:
tuple
<
Args
.
.
.
>
&
aArgs
)
{
QueueStatus
status
=
CallTryRemove
(
aArgs
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
IsSuccess
(
status
)
;
}
UniquePtr
<
Consumer
>
mSink
;
}
;
enum
SyncResponse
:
uint8_t
{
RESPONSE_NAK
RESPONSE_ACK
}
;
template
<
typename
Command
>
class
SyncCommandSource
:
public
CommandSource
<
Command
>
{
public
:
using
BaseType
=
CommandSource
<
Command
>
;
SyncCommandSource
(
UniquePtr
<
Producer
>
&
&
aProducer
UniquePtr
<
Consumer
>
&
&
aResponseConsumer
)
:
CommandSource
<
Command
>
(
std
:
:
move
(
aProducer
)
)
mResponseSink
(
std
:
:
move
(
aResponseConsumer
)
)
{
}
template
<
typename
.
.
.
Args
>
QueueStatus
RunAsyncCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
return
this
-
>
RunCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
RunVoidSyncCommand
(
Command
aCommand
Args
&
&
.
.
.
aArgs
)
{
QueueStatus
status
=
RunAsyncCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
IsSuccess
(
status
)
?
this
-
>
ReadSyncResponse
(
)
:
status
;
}
template
<
typename
ResultType
typename
.
.
.
Args
>
QueueStatus
RunSyncCommand
(
Command
aCommand
ResultType
&
aReturn
Args
&
&
.
.
.
aArgs
)
{
QueueStatus
status
=
RunVoidSyncCommand
(
aCommand
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
return
IsSuccess
(
status
)
?
this
-
>
ReadResult
(
aReturn
)
:
status
;
}
SyncCommandSource
(
)
=
default
;
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
SyncCommandSource
<
Command
>
>
;
protected
:
QueueStatus
ReadSyncResponse
(
)
{
SyncResponse
response
;
QueueStatus
status
=
mResponseSink
-
>
TryWaitRemove
(
Nothing
(
)
response
)
;
MOZ_ASSERT
(
status
!
=
QueueStatus
:
:
kNotReady
)
;
if
(
IsSuccess
(
status
)
&
&
response
!
=
RESPONSE_ACK
)
{
return
QueueStatus
:
:
kFatalError
;
}
return
status
;
}
template
<
typename
T
>
QueueStatus
ReadResult
(
T
&
aResult
)
{
QueueStatus
status
=
mResponseSink
-
>
TryRemove
(
aResult
)
;
MOZ_ASSERT
(
status
!
=
QueueStatus
:
:
kNotReady
)
;
return
status
;
}
UniquePtr
<
Consumer
>
mResponseSink
;
}
;
template
<
typename
Command
>
class
SyncCommandSink
:
public
CommandSink
<
Command
>
{
using
BaseType
=
CommandSink
<
Command
>
;
public
:
SyncCommandSink
(
UniquePtr
<
Consumer
>
&
&
aConsumer
UniquePtr
<
Producer
>
&
&
aResponseSource
)
:
CommandSink
<
Command
>
(
std
:
:
move
(
aConsumer
)
)
mResponseSource
(
std
:
:
move
(
aResponseSource
)
)
{
}
SyncCommandSink
(
)
=
default
;
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
SyncCommandSink
<
Command
>
>
;
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
ReturnType
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
ReturnType
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
#
if
defined
(
_M_IX86
)
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
ReturnType
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
template
<
typename
T
typename
ReturnType
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
ReturnType
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
ReturnType
response
=
BaseType
:
:
CallMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
response
)
;
}
#
endif
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
void
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
void
SINK_FCN_CC
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
#
if
defined
(
_M_IX86
)
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
T
&
aObj
void
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
bool
DispatchSyncMethod
(
const
T
&
aObj
void
__stdcall
(
T
:
:
*
aMethod
)
(
Args
.
.
.
)
const
)
{
std
:
:
tuple
<
std
:
:
remove_cv_t
<
std
:
:
remove_reference_t
<
Args
>
>
.
.
.
>
args
;
if
(
!
BaseType
:
:
ReadArgs
(
args
)
)
{
WriteNAK
(
)
;
return
false
;
}
BaseType
:
:
CallVoidMethod
(
aObj
aMethod
args
std
:
:
index_sequence_for
<
Args
.
.
.
>
{
}
)
;
return
WriteACK
(
)
;
}
#
endif
protected
:
template
<
typename
.
.
.
Args
>
bool
WriteArgs
(
const
Args
&
.
.
.
aArgs
)
{
return
IsSuccess
(
mResponseSource
-
>
TryInsert
(
aArgs
.
.
.
)
)
;
}
template
<
typename
.
.
.
Args
>
bool
WriteACK
(
const
Args
&
.
.
.
aArgs
)
{
SyncResponse
ack
=
RESPONSE_ACK
;
return
WriteArgs
(
ack
aArgs
.
.
.
)
;
}
bool
WriteNAK
(
)
{
SyncResponse
nak
=
RESPONSE_NAK
;
return
WriteArgs
(
nak
)
;
}
UniquePtr
<
Producer
>
mResponseSource
;
}
;
template
<
typename
Derived
>
struct
MethodDispatcher
{
template
<
CommandSyncType
syncType
>
struct
DispatchMethod
;
template
<
>
struct
DispatchMethod
<
CommandSyncType
:
:
ASYNC
>
{
template
<
typename
MethodType
typename
ObjectType
typename
SinkType
>
static
MOZ_ALWAYS_INLINE
bool
Run
(
SinkType
&
aSink
MethodType
mMethod
ObjectType
&
aObj
)
{
return
aSink
.
DispatchAsyncMethod
(
aObj
mMethod
)
;
}
}
;
template
<
>
struct
DispatchMethod
<
CommandSyncType
:
:
SYNC
>
{
template
<
typename
MethodType
typename
ObjectType
typename
SinkType
>
static
MOZ_ALWAYS_INLINE
bool
Run
(
SinkType
&
aSink
MethodType
aMethod
ObjectType
&
aObj
)
{
return
aSink
.
DispatchSyncMethod
(
aObj
aMethod
)
;
}
}
;
}
;
#
define
DECLARE_METHOD_DISPATCHER
(
_DISPATCHER
_OBJECTTYPE
)
\
struct
_DISPATCHER
:
public
MethodDispatcher
<
_DISPATCHER
>
{
\
using
ObjectType
=
_OBJECTTYPE
;
\
template
<
size_t
commandId
>
\
struct
IdDispatcher
{
\
template
<
typename
SinkType
>
\
static
MOZ_ALWAYS_INLINE
bool
DispatchCommand
(
size_t
aId
\
SinkType
&
aSink
\
ObjectType
&
aObj
)
{
\
MOZ_CRASH
(
"
Impossible
-
-
Unhandled
command
ID
"
)
;
\
return
false
;
\
}
\
}
;
\
template
<
typename
SinkType
size_t
commandId
=
0
>
\
static
MOZ_ALWAYS_INLINE
bool
DispatchCommand
(
size_t
aId
SinkType
&
aSink
\
ObjectType
&
aObj
)
{
\
return
IdDispatcher
<
commandId
>
:
:
DispatchCommand
(
aId
aSink
aObj
)
;
\
}
\
template
<
size_t
commandId
>
\
struct
MethodInfo
;
\
template
<
size_t
commandId
>
\
static
constexpr
CommandSyncType
SyncType
(
)
;
\
template
<
typename
MethodType
MethodType
method
>
\
static
constexpr
size_t
Id
(
)
;
\
}
;
#
define
DEFINE_METHOD_DISPATCHER
(
_DISPATCHER
_ID
_METHOD
_SYNC
)
\
template
<
>
\
struct
_DISPATCHER
:
:
MethodInfo
<
_ID
>
{
\
using
MethodType
=
decltype
(
&
_METHOD
)
;
\
}
;
\
template
<
>
\
constexpr
CommandSyncType
_DISPATCHER
:
:
SyncType
<
_ID
>
(
)
{
\
return
_SYNC
;
\
}
\
template
<
>
\
constexpr
size_t
_DISPATCHER
:
:
Id
<
decltype
(
&
_METHOD
)
&
_METHOD
>
(
)
{
\
return
_ID
;
\
}
\
template
<
>
\
struct
_DISPATCHER
:
:
IdDispatcher
<
_ID
>
{
\
template
<
typename
SinkType
>
\
static
bool
MOZ_ALWAYS_INLINE
DispatchCommand
(
size_t
aId
SinkType
&
aSink
\
ObjectType
&
aObj
)
{
\
return
(
_ID
=
=
aId
)
?
DispatchMethod
<
_SYNC
>
:
:
Run
(
aSink
&
_METHOD
aObj
)
\
:
_DISPATCHER
:
:
DispatchCommand
<
SinkType
_ID
+
1
>
(
\
aId
aSink
aObj
)
;
\
}
\
}
;
namespace
ipc
{
template
<
typename
T
>
struct
IPDLParamTraits
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
CommandSource
<
Command
>
>
{
public
:
typedef
mozilla
:
:
CommandSource
<
Command
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
aParam
.
mSource
)
;
WriteIPDLParam
(
aMsg
aActor
*
aParam
.
mSource
.
get
(
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
Producer
*
producer
=
new
Producer
;
bool
ret
=
ReadIPDLParam
(
aMsg
aIter
aActor
producer
)
;
aResult
-
>
mSource
.
reset
(
producer
)
;
return
ret
;
}
}
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
CommandSink
<
Command
>
>
{
public
:
typedef
mozilla
:
:
CommandSink
<
Command
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
aParam
.
mSink
)
;
WriteIPDLParam
(
aMsg
aActor
*
aParam
.
mSink
.
get
(
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
Consumer
*
consumer
=
new
Consumer
;
bool
ret
=
ReadIPDLParam
(
aMsg
aIter
aActor
consumer
)
;
aResult
-
>
mSink
.
reset
(
consumer
)
;
return
ret
;
}
}
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
SyncCommandSource
<
Command
>
>
:
public
IPDLParamTraits
<
mozilla
:
:
CommandSource
<
Command
>
>
{
public
:
typedef
mozilla
:
:
SyncCommandSource
<
Command
>
paramType
;
typedef
typename
paramType
:
:
BaseType
paramBaseType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
static_cast
<
const
paramBaseType
&
>
(
aParam
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mResponseSink
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aParam
)
{
bool
result
=
ReadIPDLParam
(
aMsg
aIter
aActor
static_cast
<
paramBaseType
*
>
(
aParam
)
)
;
return
result
&
&
ReadIPDLParam
(
aMsg
aIter
aActor
&
aParam
-
>
mResponseSink
)
;
}
}
;
template
<
typename
Command
>
struct
IPDLParamTraits
<
mozilla
:
:
SyncCommandSink
<
Command
>
>
:
public
IPDLParamTraits
<
mozilla
:
:
CommandSink
<
Command
>
>
{
public
:
typedef
mozilla
:
:
SyncCommandSink
<
Command
>
paramType
;
typedef
typename
paramType
:
:
BaseType
paramBaseType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
static_cast
<
const
paramBaseType
&
>
(
aParam
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mResponseSource
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aParam
)
{
bool
result
=
ReadIPDLParam
(
aMsg
aIter
aActor
static_cast
<
paramBaseType
*
>
(
aParam
)
)
;
return
result
&
&
ReadIPDLParam
(
aMsg
aIter
aActor
&
aParam
-
>
mResponseSource
)
;
}
}
;
}
}
#
endif
