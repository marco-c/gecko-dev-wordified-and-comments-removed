#
include
"
CanvasRenderingContextHelper
.
h
"
#
include
"
ImageEncoder
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
WebGL1Context
.
h
"
#
include
"
WebGL2Context
.
h
"
namespace
mozilla
{
namespace
dom
{
void
CanvasRenderingContextHelper
:
:
ToBlob
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
FileCallback
&
aCallback
const
nsAString
&
aType
JS
:
:
Handle
<
JS
:
:
Value
>
aParams
ErrorResult
&
aRv
)
{
nsAutoString
type
;
nsContentUtils
:
:
ASCIIToLower
(
aType
type
)
;
nsAutoString
params
;
bool
usingCustomParseOptions
;
aRv
=
ParseParams
(
aCx
type
aParams
params
&
usingCustomParseOptions
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
#
ifdef
DEBUG
if
(
mCurrentContext
)
{
nsIntSize
elementSize
=
GetWidthHeight
(
)
;
MOZ_ASSERT
(
elementSize
.
width
=
=
mCurrentContext
-
>
GetWidth
(
)
|
|
(
elementSize
.
width
=
=
0
&
&
mCurrentContext
-
>
GetWidth
(
)
=
=
1
)
)
;
MOZ_ASSERT
(
elementSize
.
height
=
=
mCurrentContext
-
>
GetHeight
(
)
|
|
(
elementSize
.
height
=
=
0
&
&
mCurrentContext
-
>
GetHeight
(
)
=
=
1
)
)
;
}
#
endif
uint8_t
*
imageBuffer
=
nullptr
;
int32_t
format
=
0
;
if
(
mCurrentContext
)
{
mCurrentContext
-
>
GetImageBuffer
(
&
imageBuffer
&
format
)
;
}
class
EncodeCallback
:
public
EncodeCompleteCallback
{
public
:
EncodeCallback
(
nsIGlobalObject
*
aGlobal
FileCallback
*
aCallback
)
:
mGlobal
(
aGlobal
)
mFileCallback
(
aCallback
)
{
}
nsresult
ReceiveBlob
(
already_AddRefed
<
Blob
>
aBlob
)
{
nsRefPtr
<
Blob
>
blob
=
aBlob
;
ErrorResult
rv
;
uint64_t
size
=
blob
-
>
GetSize
(
rv
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
}
else
{
AutoJSAPI
jsapi
;
if
(
jsapi
.
Init
(
mGlobal
)
)
{
JS_updateMallocCounter
(
jsapi
.
cx
(
)
size
)
;
}
}
nsRefPtr
<
Blob
>
newBlob
=
Blob
:
:
Create
(
mGlobal
blob
-
>
Impl
(
)
)
;
mFileCallback
-
>
Call
(
*
newBlob
rv
)
;
mGlobal
=
nullptr
;
mFileCallback
=
nullptr
;
return
rv
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
nsRefPtr
<
FileCallback
>
mFileCallback
;
}
;
nsRefPtr
<
EncodeCompleteCallback
>
callback
=
new
EncodeCallback
(
aGlobal
&
aCallback
)
;
aRv
=
ImageEncoder
:
:
ExtractDataAsync
(
type
params
usingCustomParseOptions
imageBuffer
format
GetWidthHeight
(
)
callback
)
;
}
already_AddRefed
<
nsICanvasRenderingContextInternal
>
CanvasRenderingContextHelper
:
:
CreateContext
(
CanvasContextType
aContextType
)
{
MOZ_ASSERT
(
aContextType
!
=
CanvasContextType
:
:
NoContext
)
;
nsRefPtr
<
nsICanvasRenderingContextInternal
>
ret
;
switch
(
aContextType
)
{
case
CanvasContextType
:
:
NoContext
:
break
;
case
CanvasContextType
:
:
Canvas2D
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CANVAS_2D_USED
1
)
;
ret
=
new
CanvasRenderingContext2D
(
)
;
break
;
case
CanvasContextType
:
:
WebGL1
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CANVAS_WEBGL_USED
1
)
;
ret
=
WebGL1Context
:
:
Create
(
)
;
if
(
!
ret
)
return
nullptr
;
break
;
case
CanvasContextType
:
:
WebGL2
:
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CANVAS_WEBGL_USED
1
)
;
ret
=
WebGL2Context
:
:
Create
(
)
;
if
(
!
ret
)
return
nullptr
;
break
;
}
MOZ_ASSERT
(
ret
)
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
nsISupports
>
CanvasRenderingContextHelper
:
:
GetContext
(
JSContext
*
aCx
const
nsAString
&
aContextId
JS
:
:
Handle
<
JS
:
:
Value
>
aContextOptions
ErrorResult
&
aRv
)
{
CanvasContextType
contextType
;
if
(
!
CanvasUtils
:
:
GetCanvasContextType
(
aContextId
&
contextType
)
)
return
nullptr
;
if
(
!
mCurrentContext
)
{
nsRefPtr
<
nsICanvasRenderingContextInternal
>
context
;
context
=
CreateContext
(
contextType
)
;
if
(
!
context
)
{
return
nullptr
;
}
nsXPCOMCycleCollectionParticipant
*
cp
=
nullptr
;
CallQueryInterface
(
context
&
cp
)
;
if
(
!
cp
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
mCurrentContext
=
context
.
forget
(
)
;
mCurrentContextType
=
contextType
;
aRv
=
UpdateContext
(
aCx
aContextOptions
)
;
if
(
aRv
.
Failed
(
)
)
{
aRv
=
NS_OK
;
return
nullptr
;
}
}
else
{
if
(
contextType
!
=
mCurrentContextType
)
return
nullptr
;
}
nsCOMPtr
<
nsICanvasRenderingContextInternal
>
context
=
mCurrentContext
;
return
context
.
forget
(
)
;
}
nsresult
CanvasRenderingContextHelper
:
:
UpdateContext
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aNewContextOptions
)
{
if
(
!
mCurrentContext
)
return
NS_OK
;
nsIntSize
sz
=
GetWidthHeight
(
)
;
nsCOMPtr
<
nsICanvasRenderingContextInternal
>
currentContext
=
mCurrentContext
;
nsresult
rv
=
currentContext
-
>
SetIsOpaque
(
GetOpaqueAttr
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCurrentContext
=
nullptr
;
return
rv
;
}
rv
=
currentContext
-
>
SetContextOptions
(
aCx
aNewContextOptions
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCurrentContext
=
nullptr
;
return
rv
;
}
rv
=
currentContext
-
>
SetDimensions
(
sz
.
width
sz
.
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCurrentContext
=
nullptr
;
}
return
rv
;
}
nsresult
CanvasRenderingContextHelper
:
:
ParseParams
(
JSContext
*
aCx
const
nsAString
&
aType
const
JS
:
:
Value
&
aEncoderOptions
nsAString
&
outParams
bool
*
const
outUsingCustomParseOptions
)
{
if
(
aType
.
EqualsLiteral
(
"
image
/
jpeg
"
)
)
{
if
(
aEncoderOptions
.
isNumber
(
)
)
{
double
quality
=
aEncoderOptions
.
toNumber
(
)
;
if
(
quality
>
=
0
.
0
&
&
quality
<
=
1
.
0
)
{
outParams
.
AppendLiteral
(
"
quality
=
"
)
;
outParams
.
AppendInt
(
NS_lround
(
quality
*
100
.
0
)
)
;
}
}
}
*
outUsingCustomParseOptions
=
false
;
if
(
outParams
.
Length
(
)
=
=
0
&
&
aEncoderOptions
.
isString
(
)
)
{
NS_NAMED_LITERAL_STRING
(
mozParseOptions
"
-
moz
-
parse
-
options
:
"
)
;
nsAutoJSString
paramString
;
if
(
!
paramString
.
init
(
aCx
aEncoderOptions
.
toString
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
StringBeginsWith
(
paramString
mozParseOptions
)
)
{
nsDependentSubstring
parseOptions
=
Substring
(
paramString
mozParseOptions
.
Length
(
)
paramString
.
Length
(
)
-
mozParseOptions
.
Length
(
)
)
;
outParams
.
Append
(
parseOptions
)
;
*
outUsingCustomParseOptions
=
true
;
}
}
return
NS_OK
;
}
}
}
