#
include
"
CanvasRenderingContextHelper
.
h
"
#
include
"
ClientWebGLContext
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
ImageBitmapRenderingContext
.
h
"
#
include
"
ImageEncoder
.
h
"
#
include
"
MozFramebuffer
.
h
"
#
include
"
mozilla
/
GfxMessageUtils
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
BlobImpl
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
dom
/
OffscreenCanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
glean
/
DomCanvasMetrics
.
h
"
#
include
"
mozilla
/
webgpu
/
CanvasContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsJSUtils
.
h
"
namespace
mozilla
:
:
dom
{
CanvasRenderingContextHelper
:
:
CanvasRenderingContextHelper
(
)
:
mCurrentContextType
(
CanvasContextType
:
:
NoContext
)
{
}
void
CanvasRenderingContextHelper
:
:
ToBlob
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
BlobCallback
&
aCallback
const
nsAString
&
aType
JS
:
:
Handle
<
JS
:
:
Value
>
aParams
bool
aUsePlaceholder
ErrorResult
&
aRv
)
{
class
EncodeCallback
:
public
EncodeCompleteCallback
{
public
:
EncodeCallback
(
nsIGlobalObject
*
aGlobal
BlobCallback
*
aCallback
)
:
mGlobal
(
aGlobal
)
mBlobCallback
(
aCallback
)
{
}
MOZ_CAN_RUN_SCRIPT
nsresult
ReceiveBlobImpl
(
already_AddRefed
<
BlobImpl
>
aBlobImpl
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
BlobImpl
>
blobImpl
=
aBlobImpl
;
RefPtr
<
Blob
>
blob
;
if
(
blobImpl
)
{
blob
=
Blob
:
:
Create
(
mGlobal
blobImpl
)
;
}
RefPtr
<
BlobCallback
>
callback
(
std
:
:
move
(
mBlobCallback
)
)
;
ErrorResult
rv
;
callback
-
>
Call
(
blob
rv
)
;
mGlobal
=
nullptr
;
MOZ_ASSERT
(
!
mBlobCallback
)
;
return
rv
.
StealNSResult
(
)
;
}
bool
CanBeDeletedOnAnyThread
(
)
override
{
return
false
;
}
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
RefPtr
<
BlobCallback
>
mBlobCallback
;
}
;
RefPtr
<
EncodeCompleteCallback
>
callback
=
new
EncodeCallback
(
aGlobal
&
aCallback
)
;
ToBlob
(
aCx
callback
aType
aParams
aUsePlaceholder
aRv
)
;
}
void
CanvasRenderingContextHelper
:
:
ToBlob
(
JSContext
*
aCx
EncodeCompleteCallback
*
aCallback
const
nsAString
&
aType
JS
:
:
Handle
<
JS
:
:
Value
>
aParams
bool
aUsePlaceholder
ErrorResult
&
aRv
)
{
nsAutoString
type
;
nsContentUtils
:
:
ASCIIToLower
(
aType
type
)
;
nsAutoString
params
;
bool
usingCustomParseOptions
;
aRv
=
ParseParams
(
aCx
type
aParams
params
&
usingCustomParseOptions
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
ToBlob
(
aCallback
type
params
usingCustomParseOptions
aUsePlaceholder
aRv
)
;
}
void
CanvasRenderingContextHelper
:
:
ToBlob
(
EncodeCompleteCallback
*
aCallback
nsAString
&
aType
const
nsAString
&
aEncodeOptions
bool
aUsingCustomOptions
bool
aUsePlaceholder
ErrorResult
&
aRv
)
{
const
CSSIntSize
elementSize
=
GetWidthHeight
(
)
;
if
(
mCurrentContext
)
{
if
(
(
elementSize
.
width
!
=
mCurrentContext
-
>
GetWidth
(
)
&
&
(
elementSize
.
width
!
=
0
|
|
mCurrentContext
-
>
GetWidth
(
)
!
=
1
)
)
|
|
(
elementSize
.
height
!
=
mCurrentContext
-
>
GetHeight
(
)
&
&
(
elementSize
.
height
!
=
0
|
|
mCurrentContext
-
>
GetHeight
(
)
!
=
1
)
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
}
int32_t
format
=
0
;
auto
imageSize
=
gfx
:
:
IntSize
{
elementSize
.
width
elementSize
.
height
}
;
UniquePtr
<
uint8_t
[
]
>
imageBuffer
=
GetImageBuffer
(
&
format
&
imageSize
)
;
RefPtr
<
EncodeCompleteCallback
>
callback
=
aCallback
;
aRv
=
ImageEncoder
:
:
ExtractDataAsync
(
aType
aEncodeOptions
aUsingCustomOptions
std
:
:
move
(
imageBuffer
)
format
CSSIntSize
:
:
FromUnknownSize
(
imageSize
)
aUsePlaceholder
callback
)
;
}
UniquePtr
<
uint8_t
[
]
>
CanvasRenderingContextHelper
:
:
GetImageBuffer
(
int32_t
*
aOutFormat
gfx
:
:
IntSize
*
aOutImageSize
)
{
if
(
mCurrentContext
)
{
return
mCurrentContext
-
>
GetImageBuffer
(
aOutFormat
aOutImageSize
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsICanvasRenderingContextInternal
>
CanvasRenderingContextHelper
:
:
CreateContext
(
CanvasContextType
aContextType
)
{
return
CreateContextHelper
(
aContextType
layers
:
:
LayersBackend
:
:
LAYERS_NONE
)
;
}
already_AddRefed
<
nsICanvasRenderingContextInternal
>
CanvasRenderingContextHelper
:
:
CreateContextHelper
(
CanvasContextType
aContextType
layers
:
:
LayersBackend
aCompositorBackend
)
{
MOZ_ASSERT
(
aContextType
!
=
CanvasContextType
:
:
NoContext
)
;
RefPtr
<
nsICanvasRenderingContextInternal
>
ret
;
switch
(
aContextType
)
{
case
CanvasContextType
:
:
NoContext
:
break
;
case
CanvasContextType
:
:
Canvas2D
:
glean
:
:
canvas
:
:
used_2d
.
EnumGet
(
glean
:
:
canvas
:
:
Used2dLabel
:
:
eTrue
)
.
Add
(
)
;
ret
=
new
CanvasRenderingContext2D
(
aCompositorBackend
)
;
break
;
case
CanvasContextType
:
:
OffscreenCanvas2D
:
glean
:
:
canvas
:
:
used_2d
.
EnumGet
(
glean
:
:
canvas
:
:
Used2dLabel
:
:
eTrue
)
.
Add
(
)
;
ret
=
new
OffscreenCanvasRenderingContext2D
(
aCompositorBackend
)
;
break
;
case
CanvasContextType
:
:
WebGL1
:
glean
:
:
canvas
:
:
webgl_used
.
EnumGet
(
glean
:
:
canvas
:
:
WebglUsedLabel
:
:
eTrue
)
.
Add
(
)
;
ret
=
new
ClientWebGLContext
(
false
)
;
break
;
case
CanvasContextType
:
:
WebGL2
:
glean
:
:
canvas
:
:
webgl_used
.
EnumGet
(
glean
:
:
canvas
:
:
WebglUsedLabel
:
:
eTrue
)
.
Add
(
)
;
ret
=
new
ClientWebGLContext
(
true
)
;
break
;
case
CanvasContextType
:
:
WebGPU
:
ret
=
new
webgpu
:
:
CanvasContext
(
)
;
break
;
case
CanvasContextType
:
:
ImageBitmap
:
ret
=
new
ImageBitmapRenderingContext
(
)
;
break
;
}
MOZ_ASSERT
(
ret
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
ret
-
>
Initialize
(
)
)
)
)
{
return
nullptr
;
}
return
ret
.
forget
(
)
;
}
already_AddRefed
<
nsISupports
>
CanvasRenderingContextHelper
:
:
GetOrCreateContext
(
JSContext
*
aCx
const
nsAString
&
aContextId
JS
:
:
Handle
<
JS
:
:
Value
>
aContextOptions
ErrorResult
&
aRv
)
{
CanvasContextType
contextType
;
if
(
!
CanvasUtils
:
:
GetCanvasContextType
(
aContextId
&
contextType
)
)
return
nullptr
;
return
GetOrCreateContext
(
aCx
contextType
aContextOptions
aRv
)
;
}
already_AddRefed
<
nsISupports
>
CanvasRenderingContextHelper
:
:
GetOrCreateContext
(
JSContext
*
aCx
CanvasContextType
aContextType
JS
:
:
Handle
<
JS
:
:
Value
>
aContextOptions
ErrorResult
&
aRv
)
{
if
(
!
mCurrentContext
)
{
RefPtr
<
nsICanvasRenderingContextInternal
>
context
;
context
=
CreateContext
(
aContextType
)
;
if
(
!
context
)
{
aRv
.
ThrowUnknownError
(
"
Failed
to
create
context
"
)
;
return
nullptr
;
}
nsXPCOMCycleCollectionParticipant
*
cp
=
nullptr
;
CallQueryInterface
(
context
&
cp
)
;
if
(
!
cp
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
mCurrentContext
=
std
:
:
move
(
context
)
;
mCurrentContextType
=
aContextType
;
JS
:
:
Rooted
<
JS
:
:
Value
>
options
(
RootingCx
(
)
aContextOptions
)
;
if
(
!
options
.
isObject
(
)
)
{
options
.
setNull
(
)
;
}
nsresult
rv
=
UpdateContext
(
aCx
options
aRv
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
aContextType
=
=
CanvasContextType
:
:
WebGL1
)
{
glean
:
:
canvas
:
:
webgl_success
.
EnumGet
(
glean
:
:
canvas
:
:
WebglSuccessLabel
:
:
eFalse
)
.
Add
(
)
;
}
else
if
(
aContextType
=
=
CanvasContextType
:
:
WebGL2
)
{
glean
:
:
canvas
:
:
webgl2_success
.
EnumGet
(
glean
:
:
canvas
:
:
Webgl2SuccessLabel
:
:
eFalse
)
.
Add
(
)
;
}
else
if
(
aContextType
=
=
CanvasContextType
:
:
WebGPU
)
{
}
return
nullptr
;
}
if
(
aContextType
=
=
CanvasContextType
:
:
WebGL1
)
{
glean
:
:
canvas
:
:
webgl_success
.
EnumGet
(
glean
:
:
canvas
:
:
WebglSuccessLabel
:
:
eTrue
)
.
Add
(
)
;
}
else
if
(
aContextType
=
=
CanvasContextType
:
:
WebGL2
)
{
glean
:
:
canvas
:
:
webgl2_success
.
EnumGet
(
glean
:
:
canvas
:
:
Webgl2SuccessLabel
:
:
eTrue
)
.
Add
(
)
;
}
else
if
(
aContextType
=
=
CanvasContextType
:
:
WebGPU
)
{
}
}
else
{
if
(
aContextType
!
=
mCurrentContextType
)
return
nullptr
;
}
nsCOMPtr
<
nsICanvasRenderingContextInternal
>
context
=
mCurrentContext
;
return
context
.
forget
(
)
;
}
nsresult
CanvasRenderingContextHelper
:
:
UpdateContext
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aNewContextOptions
ErrorResult
&
aRvForDictionaryInit
)
{
if
(
!
mCurrentContext
)
return
NS_OK
;
CSSIntSize
sz
=
GetWidthHeight
(
)
;
nsCOMPtr
<
nsICanvasRenderingContextInternal
>
currentContext
=
mCurrentContext
;
currentContext
-
>
SetOpaqueValueFromOpaqueAttr
(
GetOpaqueAttr
(
)
)
;
nsresult
rv
=
currentContext
-
>
SetContextOptions
(
aCx
aNewContextOptions
aRvForDictionaryInit
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCurrentContext
=
nullptr
;
return
rv
;
}
rv
=
currentContext
-
>
SetDimensions
(
sz
.
width
sz
.
height
)
;
if
(
NS_FAILED
(
rv
)
)
{
mCurrentContext
=
nullptr
;
}
return
rv
;
}
nsresult
CanvasRenderingContextHelper
:
:
ParseParams
(
JSContext
*
aCx
const
nsAString
&
aType
const
JS
:
:
Value
&
aEncoderOptions
nsAString
&
outParams
bool
*
const
outUsingCustomParseOptions
)
{
if
(
aType
.
EqualsLiteral
(
"
image
/
jpeg
"
)
|
|
aType
.
EqualsLiteral
(
"
image
/
webp
"
)
)
{
if
(
aEncoderOptions
.
isNumber
(
)
)
{
double
quality
=
aEncoderOptions
.
toNumber
(
)
;
if
(
quality
>
=
0
.
0
&
&
quality
<
=
1
.
0
)
{
outParams
.
AppendLiteral
(
"
quality
=
"
)
;
outParams
.
AppendInt
(
NS_lround
(
quality
*
100
.
0
)
)
;
}
}
}
*
outUsingCustomParseOptions
=
false
;
if
(
outParams
.
Length
(
)
=
=
0
&
&
aEncoderOptions
.
isString
(
)
)
{
constexpr
auto
mozParseOptions
=
u
"
-
moz
-
parse
-
options
:
"
_ns
;
nsAutoJSString
paramString
;
if
(
!
paramString
.
init
(
aCx
aEncoderOptions
.
toString
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
StringBeginsWith
(
paramString
mozParseOptions
)
)
{
nsDependentSubstring
parseOptions
=
Substring
(
paramString
mozParseOptions
.
Length
(
)
paramString
.
Length
(
)
-
mozParseOptions
.
Length
(
)
)
;
outParams
.
Append
(
parseOptions
)
;
*
outUsingCustomParseOptions
=
true
;
}
}
return
NS_OK
;
}
}
