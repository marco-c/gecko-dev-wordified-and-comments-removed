#
ifndef
TEX_UNPACK_BLOB_H_
#
define
TEX_UNPACK_BLOB_H_
#
include
"
GLContextTypes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
WebGLStrongTypes
.
h
"
#
include
"
WebGLTypes
.
h
"
namespace
mozilla
{
class
UniqueBuffer
;
class
WebGLContext
;
class
WebGLTexture
;
namespace
dom
{
class
Element
;
class
HTMLCanvasElement
;
class
HTMLVideoElement
;
}
namespace
gfx
{
class
DataSourceSurface
;
}
namespace
layers
{
class
Image
;
class
ImageContainer
;
}
namespace
webgl
{
struct
PackingInfo
;
struct
DriverUnpackInfo
;
class
TexUnpackBlob
{
public
:
const
uint32_t
mAlignment
;
const
uint32_t
mRowLength
;
const
uint32_t
mImageHeight
;
const
uint32_t
mSkipPixels
;
const
uint32_t
mSkipRows
;
const
uint32_t
mSkipImages
;
const
uint32_t
mWidth
;
const
uint32_t
mHeight
;
const
uint32_t
mDepth
;
const
bool
mSrcIsPremult
;
bool
mNeedsExactUpload
;
protected
:
TexUnpackBlob
(
const
WebGLContext
*
webgl
TexImageTarget
target
uint32_t
rowLength
uint32_t
width
uint32_t
height
uint32_t
depth
bool
isSrcPremult
)
;
public
:
virtual
~
TexUnpackBlob
(
)
{
}
protected
:
bool
ConvertIfNeeded
(
WebGLContext
*
webgl
const
char
*
funcName
const
uint32_t
rowLength
const
uint32_t
rowCount
WebGLTexelFormat
srcFormat
const
uint8_t
*
const
srcBegin
const
ptrdiff_t
srcStride
WebGLTexelFormat
dstFormat
const
ptrdiff_t
dstStride
const
uint8_t
*
*
const
out_begin
UniqueBuffer
*
const
out_anchoredBuffer
)
const
;
public
:
virtual
bool
HasData
(
)
const
{
return
true
;
}
virtual
bool
Validate
(
WebGLContext
*
webgl
const
char
*
funcName
const
webgl
:
:
PackingInfo
&
pi
)
=
0
;
virtual
bool
TexOrSubImage
(
bool
isSubImage
bool
needsRespec
const
char
*
funcName
WebGLTexture
*
tex
TexImageTarget
target
GLint
level
const
webgl
:
:
DriverUnpackInfo
*
dui
GLint
xOffset
GLint
yOffset
GLint
zOffset
GLenum
*
const
out_error
)
const
=
0
;
}
;
class
TexUnpackBytes
final
:
public
TexUnpackBlob
{
public
:
const
bool
mIsClientData
;
const
uint8_t
*
const
mPtr
;
const
size_t
mAvailBytes
;
TexUnpackBytes
(
const
WebGLContext
*
webgl
TexImageTarget
target
uint32_t
width
uint32_t
height
uint32_t
depth
bool
isClientData
const
uint8_t
*
ptr
size_t
availBytes
)
;
virtual
bool
HasData
(
)
const
override
{
return
!
mIsClientData
|
|
bool
(
mPtr
)
;
}
virtual
bool
Validate
(
WebGLContext
*
webgl
const
char
*
funcName
const
webgl
:
:
PackingInfo
&
pi
)
override
;
virtual
bool
TexOrSubImage
(
bool
isSubImage
bool
needsRespec
const
char
*
funcName
WebGLTexture
*
tex
TexImageTarget
target
GLint
level
const
webgl
:
:
DriverUnpackInfo
*
dui
GLint
xOffset
GLint
yOffset
GLint
zOffset
GLenum
*
const
out_error
)
const
override
;
}
;
class
TexUnpackImage
final
:
public
TexUnpackBlob
{
public
:
const
RefPtr
<
layers
:
:
Image
>
mImage
;
TexUnpackImage
(
const
WebGLContext
*
webgl
TexImageTarget
target
uint32_t
width
uint32_t
height
uint32_t
depth
layers
:
:
Image
*
image
bool
isAlphaPremult
)
;
~
TexUnpackImage
(
)
;
virtual
bool
Validate
(
WebGLContext
*
webgl
const
char
*
funcName
const
webgl
:
:
PackingInfo
&
pi
)
override
;
virtual
bool
TexOrSubImage
(
bool
isSubImage
bool
needsRespec
const
char
*
funcName
WebGLTexture
*
tex
TexImageTarget
target
GLint
level
const
webgl
:
:
DriverUnpackInfo
*
dui
GLint
xOffset
GLint
yOffset
GLint
zOffset
GLenum
*
const
out_error
)
const
override
;
}
;
class
TexUnpackSurface
final
:
public
TexUnpackBlob
{
public
:
const
RefPtr
<
gfx
:
:
DataSourceSurface
>
mSurf
;
TexUnpackSurface
(
const
WebGLContext
*
webgl
TexImageTarget
target
uint32_t
width
uint32_t
height
uint32_t
depth
gfx
:
:
DataSourceSurface
*
surf
bool
isAlphaPremult
)
;
virtual
bool
Validate
(
WebGLContext
*
webgl
const
char
*
funcName
const
webgl
:
:
PackingInfo
&
pi
)
override
;
virtual
bool
TexOrSubImage
(
bool
isSubImage
bool
needsRespec
const
char
*
funcName
WebGLTexture
*
tex
TexImageTarget
target
GLint
level
const
webgl
:
:
DriverUnpackInfo
*
dui
GLint
xOffset
GLint
yOffset
GLint
zOffset
GLenum
*
const
out_error
)
const
override
;
}
;
}
}
#
endif
