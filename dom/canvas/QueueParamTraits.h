#
ifndef
_QUEUEPARAMTRAITS_H_
#
define
_QUEUEPARAMTRAITS_H_
1
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsString
.
h
"
namespace
IPC
{
typedef
uint32_t
PcqTypeInfoID
;
template
<
typename
T
>
struct
PcqTypeInfo
;
}
namespace
mozilla
{
namespace
webgl
{
using
IPC
:
:
PcqTypeInfo
;
using
IPC
:
:
PcqTypeInfoID
;
struct
QueueStatus
{
enum
EStatus
{
kSuccess
kNotReady
kTypeError
kTooSmall
kFatalError
kOOMError
}
mValue
;
MOZ_IMPLICIT
QueueStatus
(
const
EStatus
status
=
kSuccess
)
:
mValue
(
status
)
{
}
explicit
operator
bool
(
)
const
{
return
mValue
=
=
kSuccess
;
}
explicit
operator
int
(
)
const
{
return
static_cast
<
int
>
(
mValue
)
;
}
bool
operator
=
=
(
const
EStatus
&
o
)
const
{
return
mValue
=
=
o
;
}
bool
operator
!
=
(
const
EStatus
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
}
;
inline
bool
IsSuccess
(
QueueStatus
status
)
{
return
status
=
=
QueueStatus
:
:
kSuccess
;
}
template
<
typename
T
>
struct
RemoveCVR
{
typedef
typename
std
:
:
remove_reference
<
typename
std
:
:
remove_cv
<
T
>
:
:
type
>
:
:
type
Type
;
}
;
inline
size_t
UsedBytes
(
size_t
aQueueBufferSize
size_t
aRead
size_t
aWrite
)
{
return
(
aRead
<
=
aWrite
)
?
aWrite
-
aRead
:
(
aQueueBufferSize
-
aRead
)
+
aWrite
;
}
inline
size_t
FreeBytes
(
size_t
aQueueBufferSize
size_t
aRead
size_t
aWrite
)
{
return
(
aQueueBufferSize
-
1
)
-
UsedBytes
(
aQueueBufferSize
aRead
aWrite
)
;
}
template
<
typename
T
>
struct
IsTriviallySerializable
:
public
std
:
:
integral_constant
<
bool
std
:
:
is_enum
<
T
>
:
:
value
|
|
std
:
:
is_arithmetic
<
T
>
:
:
value
>
{
}
;
class
ProducerConsumerQueue
;
class
PcqProducer
;
class
PcqConsumer
;
template
<
typename
Arg
>
struct
QueueParamTraits
;
template
<
typename
Arg
>
struct
PcqTypedArg
{
explicit
PcqTypedArg
(
const
Arg
&
aArg
)
:
mWrite
(
&
aArg
)
mRead
(
nullptr
)
{
}
explicit
PcqTypedArg
(
Arg
*
aArg
)
:
mWrite
(
nullptr
)
mRead
(
aArg
)
{
}
private
:
friend
struct
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
;
const
Arg
*
mWrite
;
Arg
*
mRead
;
}
;
class
Marshaller
{
public
:
static
QueueStatus
WriteObject
(
uint8_t
*
aQueue
size_t
aQueueBufferSize
size_t
aRead
size_t
*
aWrite
const
void
*
aArg
size_t
aArgLength
)
{
const
uint8_t
*
buf
=
reinterpret_cast
<
const
uint8_t
*
>
(
aArg
)
;
if
(
FreeBytes
(
aQueueBufferSize
aRead
*
aWrite
)
<
aArgLength
)
{
return
QueueStatus
:
:
kNotReady
;
}
if
(
*
aWrite
+
aArgLength
<
=
aQueueBufferSize
)
{
memcpy
(
aQueue
+
*
aWrite
buf
aArgLength
)
;
}
else
{
size_t
firstLen
=
aQueueBufferSize
-
*
aWrite
;
memcpy
(
aQueue
+
*
aWrite
buf
firstLen
)
;
memcpy
(
aQueue
&
buf
[
firstLen
]
aArgLength
-
firstLen
)
;
}
*
aWrite
=
(
*
aWrite
+
aArgLength
)
%
aQueueBufferSize
;
return
QueueStatus
:
:
kSuccess
;
}
static
QueueStatus
ReadObject
(
const
uint8_t
*
aQueue
size_t
aQueueBufferSize
size_t
*
aRead
size_t
aWrite
void
*
aArg
size_t
aArgLength
)
{
if
(
UsedBytes
(
aQueueBufferSize
*
aRead
aWrite
)
<
aArgLength
)
{
return
QueueStatus
:
:
kNotReady
;
}
if
(
aArg
)
{
uint8_t
*
buf
=
reinterpret_cast
<
uint8_t
*
>
(
aArg
)
;
if
(
*
aRead
+
aArgLength
<
=
aQueueBufferSize
)
{
memcpy
(
buf
aQueue
+
*
aRead
aArgLength
)
;
}
else
{
size_t
firstLen
=
aQueueBufferSize
-
*
aRead
;
memcpy
(
buf
aQueue
+
*
aRead
firstLen
)
;
memcpy
(
&
buf
[
firstLen
]
aQueue
aArgLength
-
firstLen
)
;
}
}
*
aRead
=
(
*
aRead
+
aArgLength
)
%
aQueueBufferSize
;
return
QueueStatus
:
:
kSuccess
;
}
}
;
template
<
typename
_Producer
>
class
ProducerView
{
public
:
using
Producer
=
_Producer
;
ProducerView
(
Producer
*
aProducer
size_t
aRead
size_t
*
aWrite
)
:
mProducer
(
aProducer
)
mRead
(
aRead
)
mWrite
(
aWrite
)
mStatus
(
QueueStatus
:
:
kSuccess
)
{
}
inline
QueueStatus
Write
(
const
void
*
aBuffer
size_t
aBufferSize
)
;
template
<
typename
T
>
inline
QueueStatus
Write
(
const
T
*
src
size_t
count
)
{
return
Write
(
reinterpret_cast
<
const
void
*
>
(
src
)
count
*
sizeof
(
T
)
)
;
}
template
<
typename
Arg
>
QueueStatus
WriteParam
(
const
Arg
&
aArg
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Write
(
*
this
aArg
)
;
}
template
<
typename
Arg
>
QueueStatus
WriteTypedParam
(
const
Arg
&
aArg
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
:
:
Write
(
*
this
PcqTypedArg
<
Arg
>
(
aArg
)
)
;
}
template
<
typename
Arg
>
size_t
MinSizeParam
(
const
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
MinSize
(
*
this
aArg
)
;
}
inline
size_t
MinSizeBytes
(
size_t
aNBytes
)
;
QueueStatus
GetStatus
(
)
{
return
mStatus
;
}
private
:
Producer
*
mProducer
;
size_t
mRead
;
size_t
*
mWrite
;
QueueStatus
mStatus
;
}
;
template
<
typename
_Consumer
>
class
ConsumerView
{
public
:
using
Consumer
=
_Consumer
;
ConsumerView
(
Consumer
*
aConsumer
size_t
*
aRead
size_t
aWrite
)
:
mConsumer
(
aConsumer
)
mRead
(
aRead
)
mWrite
(
aWrite
)
mStatus
(
QueueStatus
:
:
kSuccess
)
{
}
using
PcqReadBytesVariant
=
Variant
<
QueueStatus
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
void
*
>
;
inline
QueueStatus
Read
(
void
*
aBuffer
size_t
aBufferSize
)
;
template
<
typename
T
>
inline
QueueStatus
Read
(
T
*
dest
size_t
count
)
{
return
Read
(
reinterpret_cast
<
void
*
>
(
dest
)
count
*
sizeof
(
T
)
)
;
}
template
<
typename
Matcher
>
inline
QueueStatus
ReadVariant
(
size_t
aBufferSize
Matcher
&
&
aMatcher
)
;
template
<
typename
Arg
>
QueueStatus
ReadParam
(
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Read
(
*
this
aArg
)
;
}
template
<
typename
Arg
>
QueueStatus
ReadTypedParam
(
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
:
:
Read
(
*
this
PcqTypedArg
(
aArg
)
)
;
}
template
<
typename
Arg
>
size_t
MinSizeParam
(
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
MinSize
(
*
this
aArg
)
;
}
inline
size_t
MinSizeBytes
(
size_t
aNBytes
)
;
QueueStatus
GetStatus
(
)
{
return
mStatus
;
}
private
:
Consumer
*
mConsumer
;
size_t
*
mRead
;
size_t
mWrite
;
QueueStatus
mStatus
;
}
;
template
<
typename
T
>
QueueStatus
ProducerView
<
T
>
:
:
Write
(
const
void
*
aBuffer
size_t
aBufferSize
)
{
MOZ_ASSERT
(
aBuffer
&
&
(
aBufferSize
>
0
)
)
;
if
(
!
mStatus
)
{
return
mStatus
;
}
if
(
NeedsSharedMemory
(
aBufferSize
mProducer
-
>
Size
(
)
)
)
{
auto
smem
=
MakeRefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
(
)
;
if
(
!
smem
-
>
Create
(
aBufferSize
)
|
|
!
smem
-
>
Map
(
aBufferSize
)
)
{
return
QueueStatus
:
:
kFatalError
;
}
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
handle
;
if
(
!
smem
-
>
ShareToProcess
(
mProducer
-
>
mOtherPid
&
handle
)
)
{
return
QueueStatus
:
:
kFatalError
;
}
memcpy
(
smem
-
>
memory
(
)
aBuffer
aBufferSize
)
;
smem
-
>
CloseHandle
(
)
;
return
WriteParam
(
handle
)
;
}
return
mProducer
-
>
WriteObject
(
mRead
mWrite
aBuffer
aBufferSize
)
;
}
template
<
typename
T
>
size_t
ProducerView
<
T
>
:
:
MinSizeBytes
(
size_t
aNBytes
)
{
return
NeedsSharedMemory
(
aNBytes
mProducer
-
>
Size
(
)
)
?
MinSizeParam
(
(
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
)
nullptr
)
:
aNBytes
;
}
template
<
typename
T
>
QueueStatus
ConsumerView
<
T
>
:
:
Read
(
void
*
aBuffer
size_t
aBufferSize
)
{
struct
PcqReadBytesMatcher
{
QueueStatus
operator
(
)
(
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
&
smem
)
{
MOZ_ASSERT
(
smem
)
;
QueueStatus
ret
;
if
(
smem
-
>
memory
(
)
)
{
if
(
mBuffer
)
{
memcpy
(
mBuffer
smem
-
>
memory
(
)
mBufferSize
)
;
}
ret
=
QueueStatus
:
:
kSuccess
;
}
else
{
ret
=
QueueStatus
:
:
kFatalError
;
}
smem
-
>
CloseHandle
(
)
;
return
ret
;
}
QueueStatus
operator
(
)
(
)
{
return
mConsumer
.
ReadObject
(
mRead
mWrite
mBuffer
mBufferSize
)
;
}
Consumer
&
mConsumer
;
size_t
*
mRead
;
size_t
mWrite
;
void
*
mBuffer
;
size_t
mBufferSize
;
}
;
MOZ_ASSERT
(
aBufferSize
>
0
)
;
if
(
!
mStatus
)
{
return
mStatus
;
}
return
ReadVariant
(
aBufferSize
PcqReadBytesMatcher
{
*
(
this
-
>
mConsumer
)
mRead
mWrite
aBuffer
aBufferSize
}
)
;
}
template
<
typename
T
>
template
<
typename
Matcher
>
QueueStatus
ConsumerView
<
T
>
:
:
ReadVariant
(
size_t
aBufferSize
Matcher
&
&
aMatcher
)
{
if
(
!
mStatus
)
{
return
mStatus
;
}
if
(
NeedsSharedMemory
(
aBufferSize
mConsumer
-
>
Size
(
)
)
)
{
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
handle
;
if
(
!
ReadParam
(
&
handle
)
)
{
return
GetStatus
(
)
;
}
auto
sharedMem
=
MakeRefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
(
)
;
if
(
!
sharedMem
-
>
IsHandleValid
(
handle
)
|
|
!
sharedMem
-
>
SetHandle
(
handle
mozilla
:
:
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
|
|
!
sharedMem
-
>
Map
(
aBufferSize
)
)
{
return
QueueStatus
:
:
kFatalError
;
}
return
aMatcher
(
sharedMem
)
;
}
return
aMatcher
(
)
;
}
template
<
typename
T
>
size_t
ConsumerView
<
T
>
:
:
MinSizeBytes
(
size_t
aNBytes
)
{
return
NeedsSharedMemory
(
aNBytes
mConsumer
-
>
Size
(
)
)
?
MinSizeParam
(
(
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
)
nullptr
)
:
aNBytes
;
}
template
<
typename
Arg
>
struct
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
{
using
ParamType
=
PcqTypedArg
<
Arg
>
;
template
<
typename
U
PcqTypeInfoID
ArgTypeId
=
PcqTypeInfo
<
Arg
>
:
:
ID
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
MOZ_ASSERT
(
aArg
.
mWrite
)
;
aProducerView
.
WriteParam
(
ArgTypeId
)
;
return
aProducerView
.
WriteParam
(
*
aArg
.
mWrite
)
;
}
template
<
typename
U
PcqTypeInfoID
ArgTypeId
=
PcqTypeInfo
<
Arg
>
:
:
ID
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
MOZ_ASSERT
(
aArg
-
>
mRead
)
;
PcqTypeInfoID
typeId
;
if
(
!
aConsumerView
.
ReadParam
(
&
typeId
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
return
(
typeId
=
=
ArgTypeId
)
?
aConsumerView
.
ReadParam
(
aArg
)
:
QueueStatus
:
:
kTypeError
;
}
template
<
typename
View
>
static
constexpr
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
sizeof
(
PcqTypeInfoID
)
+
aView
.
MinSize
(
aArg
-
>
mWrite
?
aArg
-
>
mWrite
:
aArg
-
>
mRead
)
;
}
}
;
template
<
typename
Arg
>
struct
QueueParamTraits
{
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
Arg
&
aArg
)
{
static_assert
(
mozilla
:
:
webgl
:
:
template
IsTriviallySerializable
<
Arg
>
:
:
value
"
No
QueueParamTraits
specialization
was
found
for
this
type
"
"
and
it
does
not
satisfy
IsTriviallySerializable
.
"
)
;
return
aProducerView
.
Write
(
&
aArg
sizeof
(
Arg
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
Arg
*
aArg
)
{
static_assert
(
mozilla
:
:
webgl
:
:
template
IsTriviallySerializable
<
Arg
>
:
:
value
"
No
QueueParamTraits
specialization
was
found
for
this
type
"
"
and
it
does
not
satisfy
IsTriviallySerializable
.
"
)
;
return
aConsumerView
.
Read
(
aArg
sizeof
(
Arg
)
)
;
}
template
<
typename
View
>
static
constexpr
size_t
MinSize
(
View
&
aView
const
Arg
*
aArg
)
{
static_assert
(
mozilla
:
:
webgl
:
:
template
IsTriviallySerializable
<
Arg
>
:
:
value
"
No
QueueParamTraits
specialization
was
found
for
this
type
"
"
and
it
does
not
satisfy
IsTriviallySerializable
.
"
)
;
return
sizeof
(
Arg
)
;
}
}
;
template
<
>
struct
IsTriviallySerializable
<
QueueStatus
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
QueueParamTraits
<
nsACString
>
{
using
ParamType
=
nsACString
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
if
(
(
!
aProducerView
.
WriteParam
(
aArg
.
IsVoid
(
)
)
)
|
|
aArg
.
IsVoid
(
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
uint32_t
len
=
aArg
.
Length
(
)
;
if
(
(
!
aProducerView
.
WriteParam
(
len
)
)
|
|
(
len
=
=
0
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
return
aProducerView
.
Write
(
aArg
.
BeginReading
(
)
len
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isVoid
=
false
;
if
(
!
aConsumerView
.
ReadParam
(
&
isVoid
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
SetIsVoid
(
isVoid
)
;
}
if
(
isVoid
)
{
return
QueueStatus
:
:
kSuccess
;
}
uint32_t
len
=
0
;
if
(
!
aConsumerView
.
ReadParam
(
&
len
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
len
=
=
0
)
{
if
(
aArg
)
{
*
aArg
=
"
"
;
}
return
QueueStatus
:
:
kSuccess
;
}
char
*
buf
=
aArg
?
new
char
[
len
+
1
]
:
nullptr
;
if
(
aArg
&
&
(
!
buf
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
if
(
!
aConsumerView
.
Read
(
buf
len
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
buf
[
len
]
=
'
\
0
'
;
if
(
aArg
)
{
aArg
-
>
Adopt
(
buf
len
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
minSize
=
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
;
if
(
(
!
aArg
)
|
|
aArg
-
>
IsVoid
(
)
)
{
return
minSize
;
}
minSize
+
=
aView
.
template
MinSizeParam
<
uint32_t
>
(
nullptr
)
+
aView
.
MinSizeBytes
(
aArg
-
>
Length
(
)
)
;
return
minSize
;
}
}
;
template
<
>
struct
QueueParamTraits
<
nsAString
>
{
using
ParamType
=
nsAString
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
if
(
(
!
aProducerView
.
WriteParam
(
aArg
.
IsVoid
(
)
)
)
|
|
(
aArg
.
IsVoid
(
)
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
uint32_t
len
=
aArg
.
Length
(
)
;
if
(
(
!
aProducerView
.
WriteParam
(
len
)
)
|
|
(
len
=
=
0
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
constexpr
const
uint32_t
sizeofchar
=
sizeof
(
typename
ParamType
:
:
char_type
)
;
return
aProducerView
.
Write
(
aArg
.
BeginReading
(
)
len
*
sizeofchar
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isVoid
=
false
;
if
(
!
aConsumerView
.
ReadParam
(
&
isVoid
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
SetIsVoid
(
isVoid
)
;
}
if
(
isVoid
)
{
return
QueueStatus
:
:
kSuccess
;
}
uint32_t
len
=
0
;
if
(
!
aConsumerView
.
ReadParam
(
&
len
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
len
=
=
0
)
{
if
(
aArg
)
{
*
aArg
=
nsString
(
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
uint32_t
sizeofchar
=
sizeof
(
typename
ParamType
:
:
char_type
)
;
typename
ParamType
:
:
char_type
*
buf
=
nullptr
;
if
(
aArg
)
{
buf
=
static_cast
<
typename
ParamType
:
:
char_type
*
>
(
malloc
(
(
len
+
1
)
*
sizeofchar
)
)
;
if
(
!
buf
)
{
return
QueueStatus
:
:
kOOMError
;
}
}
if
(
!
aConsumerView
.
Read
(
buf
len
*
sizeofchar
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
buf
[
len
]
=
L
'
\
0
'
;
if
(
aArg
)
{
aArg
-
>
Adopt
(
buf
len
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
minSize
=
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
;
if
(
(
!
aArg
)
|
|
aArg
-
>
IsVoid
(
)
)
{
return
minSize
;
}
uint32_t
sizeofchar
=
sizeof
(
typename
ParamType
:
:
char_type
)
;
minSize
+
=
aView
.
template
MinSizeParam
<
uint32_t
>
(
nullptr
)
+
aView
.
MinSizeBytes
(
aArg
-
>
Length
(
)
*
sizeofchar
)
;
return
minSize
;
}
}
;
template
<
>
struct
QueueParamTraits
<
nsCString
>
:
public
QueueParamTraits
<
nsACString
>
{
using
ParamType
=
nsCString
;
}
;
template
<
>
struct
QueueParamTraits
<
nsString
>
:
public
QueueParamTraits
<
nsAString
>
{
using
ParamType
=
nsString
;
}
;
template
<
typename
NSTArrayType
bool
=
IsTriviallySerializable
<
typename
NSTArrayType
:
:
elem_type
>
:
:
value
>
struct
NSArrayQueueParamTraits
;
template
<
typename
_ElementType
>
struct
NSArrayQueueParamTraits
<
nsTArray
<
_ElementType
>
false
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
nsTArray
<
ElementType
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
aArg
.
Length
(
)
)
;
for
(
auto
&
elt
:
aArg
)
{
aProducerView
.
WriteParam
(
elt
)
;
}
return
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
size_t
arrayLen
;
if
(
!
aConsumerView
.
ReadParam
(
&
arrayLen
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
&
&
!
aArg
-
>
AppendElements
(
arrayLen
fallible
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
for
(
auto
i
:
IntegerRange
(
arrayLen
)
)
{
ElementType
*
elt
=
aArg
?
(
&
aArg
-
>
ElementAt
(
i
)
)
:
nullptr
;
aConsumerView
.
ReadParam
(
elt
)
;
}
return
aConsumerView
.
GetStatus
(
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
ret
=
aView
.
template
MinSizeParam
<
size_t
>
(
nullptr
)
;
if
(
!
aArg
)
{
return
ret
;
}
for
(
auto
&
elt
:
aArg
)
{
ret
+
=
aView
.
MinSizeParam
(
&
elt
)
;
}
return
ret
;
}
}
;
template
<
typename
_ElementType
>
struct
NSArrayQueueParamTraits
<
nsTArray
<
_ElementType
>
true
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
nsTArray
<
ElementType
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
size_t
arrayLen
=
aArg
.
Length
(
)
;
aProducerView
.
WriteParam
(
arrayLen
)
;
return
aProducerView
.
Write
(
&
aArg
[
0
]
aArg
.
Length
(
)
*
sizeof
(
ElementType
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
size_t
arrayLen
;
if
(
!
aConsumerView
.
ReadParam
(
&
arrayLen
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
&
&
!
aArg
-
>
AppendElements
(
arrayLen
fallible
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
return
aConsumerView
.
Read
(
aArg
-
>
Elements
(
)
arrayLen
*
sizeof
(
ElementType
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
ret
=
aView
.
template
MinSizeParam
<
size_t
>
(
nullptr
)
;
if
(
!
aArg
)
{
return
ret
;
}
ret
+
=
aView
.
MinSizeBytes
(
aArg
-
>
Length
(
)
*
sizeof
(
ElementType
)
)
;
return
ret
;
}
}
;
template
<
typename
ElementType
>
struct
QueueParamTraits
<
nsTArray
<
ElementType
>
>
:
public
NSArrayQueueParamTraits
<
nsTArray
<
ElementType
>
>
{
using
ParamType
=
nsTArray
<
ElementType
>
;
}
;
template
<
typename
ArrayType
bool
=
IsTriviallySerializable
<
typename
ArrayType
:
:
ElementType
>
:
:
value
>
struct
ArrayQueueParamTraits
;
template
<
typename
_ElementType
size_t
Length
>
struct
ArrayQueueParamTraits
<
Array
<
_ElementType
Length
>
false
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
Array
<
ElementType
Length
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
for
(
size_t
i
=
0
;
i
<
Length
;
+
+
i
)
{
aProducerView
.
WriteParam
(
aArg
[
i
]
)
;
}
return
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
for
(
size_t
i
=
0
;
i
<
Length
;
+
+
i
)
{
ElementType
*
elt
=
aArg
?
(
&
(
(
*
aArg
)
[
i
]
)
)
:
nullptr
;
aConsumerView
.
ReadParam
(
elt
)
;
}
return
aConsumerView
.
GetStatus
(
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
ret
=
0
;
for
(
size_t
i
=
0
;
i
<
Length
;
+
+
i
)
{
ret
+
=
aView
.
MinSizeParam
(
&
(
(
*
aArg
)
[
i
]
)
)
;
}
return
ret
;
}
}
;
template
<
typename
_ElementType
size_t
Length
>
struct
ArrayQueueParamTraits
<
Array
<
_ElementType
Length
>
true
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
Array
<
ElementType
Length
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
return
aProducerView
.
Write
(
aArg
.
begin
(
)
sizeof
(
ElementType
[
Length
]
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
return
aConsumerView
.
Read
(
aArg
-
>
begin
(
)
sizeof
(
ElementType
[
Length
]
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
MinSizeBytes
(
sizeof
(
ElementType
[
Length
]
)
)
;
}
}
;
template
<
typename
ElementType
size_t
Length
>
struct
QueueParamTraits
<
Array
<
ElementType
Length
>
>
:
public
ArrayQueueParamTraits
<
Array
<
ElementType
Length
>
>
{
using
ParamType
=
Array
<
ElementType
Length
>
;
}
;
template
<
typename
ElementType
>
struct
QueueParamTraits
<
Maybe
<
ElementType
>
>
{
using
ParamType
=
Maybe
<
ElementType
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
static_cast
<
bool
>
(
aArg
)
)
;
return
aArg
?
aProducerView
.
WriteParam
(
aArg
.
ref
(
)
)
:
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isSome
;
if
(
!
aConsumerView
.
ReadParam
(
&
isSome
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
!
isSome
)
{
if
(
aArg
)
{
aArg
-
>
reset
(
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
if
(
!
aArg
)
{
return
aConsumerView
.
template
ReadParam
<
ElementType
>
(
nullptr
)
;
}
aArg
-
>
emplace
(
)
;
return
aConsumerView
.
ReadParam
(
aArg
-
>
ptr
(
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
+
(
(
aArg
&
&
aArg
-
>
isSome
(
)
)
?
aView
.
MinSizeParam
(
&
aArg
-
>
ref
(
)
)
:
0
)
;
}
}
;
template
<
typename
T
typename
.
.
.
Ts
>
struct
QueueParamTraits
<
Maybe
<
Variant
<
T
Ts
.
.
.
>
>
>
{
using
ParamType
=
Maybe
<
Variant
<
T
Ts
.
.
.
>
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
aArg
.
mIsSome
)
;
return
(
aArg
.
mIsSome
)
?
aProducerView
.
WriteParam
(
aArg
.
ref
(
)
)
:
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isSome
;
if
(
!
aConsumerView
.
ReadParam
(
&
isSome
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
!
isSome
)
{
if
(
aArg
)
{
aArg
-
>
reset
(
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
if
(
!
aArg
)
{
return
aConsumerView
.
template
ReadParam
<
Variant
<
T
Ts
.
.
.
>
>
(
nullptr
)
;
}
aArg
-
>
emplace
(
VariantType
<
T
>
(
)
)
;
return
aConsumerView
.
ReadParam
(
aArg
-
>
ptr
(
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
+
(
(
aArg
&
&
aArg
-
>
isSome
(
)
)
?
aView
.
MinSizeParam
(
&
aArg
-
>
ref
(
)
)
:
0
)
;
}
}
;
template
<
typename
TypeA
typename
TypeB
>
struct
QueueParamTraits
<
std
:
:
pair
<
TypeA
TypeB
>
>
{
using
ParamType
=
std
:
:
pair
<
TypeA
TypeB
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
aArg
.
first
(
)
)
;
return
aProducerView
.
WriteParam
(
aArg
.
second
(
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
aConsumerView
.
ReadParam
(
aArg
?
(
&
aArg
-
>
first
(
)
)
:
nullptr
)
;
return
aConsumerView
.
ReadParam
(
aArg
?
(
&
aArg
-
>
second
(
)
)
:
nullptr
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
MinSizeParam
(
aArg
?
aArg
-
>
first
(
)
:
nullptr
)
+
aView
.
MinSizeParam
(
aArg
?
aArg
-
>
second
(
)
:
nullptr
)
;
}
}
;
template
<
typename
T
>
struct
QueueParamTraits
<
UniquePtr
<
T
>
>
{
using
ParamType
=
UniquePtr
<
T
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
!
static_cast
<
bool
>
(
aArg
)
)
;
if
(
aArg
&
&
aProducerView
.
WriteParam
(
*
aArg
.
get
(
)
)
)
{
const_cast
<
ParamType
&
>
(
aArg
)
.
reset
(
)
;
}
return
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isNull
;
if
(
!
aConsumerView
.
ReadParam
(
&
isNull
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
isNull
)
{
if
(
aArg
)
{
aArg
-
>
reset
(
nullptr
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
T
*
obj
=
nullptr
;
if
(
aArg
)
{
obj
=
new
T
(
)
;
if
(
!
obj
)
{
return
QueueStatus
:
:
kOOMError
;
}
aArg
-
>
reset
(
obj
)
;
}
return
aConsumerView
.
ReadParam
(
obj
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
if
(
(
!
aArg
)
|
|
(
!
aArg
-
>
get
(
)
)
)
{
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
;
}
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
+
aView
.
MinSizeParam
(
aArg
-
>
get
(
)
)
;
}
}
;
#
if
defined
(
OS_WIN
)
template
<
>
struct
IsTriviallySerializable
<
base
:
:
SharedMemoryHandle
>
:
std
:
:
true_type
{
}
;
#
elif
defined
(
OS_POSIX
)
template
<
>
struct
QueueParamTraits
<
base
:
:
FileDescriptor
>
{
using
ParamType
=
base
:
:
FileDescriptor
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
return
aProducerView
.
WriteParam
(
aArg
.
fd
>
0
?
aArg
.
fd
:
-
1
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
int
fd
;
if
(
!
aConsumerView
.
ReadParam
(
aArg
?
&
fd
:
nullptr
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
fd
=
fd
;
aArg
-
>
auto_close
=
false
;
}
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
MinSizeParam
(
aArg
?
&
aArg
-
>
fd
:
nullptr
)
;
}
}
;
#
endif
template
<
typename
U
>
struct
PcqVariantWriter
{
ProducerView
<
U
>
&
mView
;
template
<
typename
T
>
QueueStatus
match
(
const
T
&
x
)
{
return
mView
.
WriteParam
(
x
)
;
}
}
;
template
<
typename
.
.
.
Types
>
struct
QueueParamTraits
<
Variant
<
Types
.
.
.
>
>
{
using
ParamType
=
Variant
<
Types
.
.
.
>
;
using
Tag
=
typename
mozilla
:
:
detail
:
:
VariantTag
<
Types
.
.
.
>
:
:
Type
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
aArg
.
tag
)
;
return
aArg
.
match
(
PcqVariantWriter
{
aProducerView
}
)
;
}
template
<
size_t
N
typename
dummy
=
void
>
struct
VariantReader
{
using
Next
=
VariantReader
<
N
-
1
>
;
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aView
Tag
aTag
ParamType
*
aArg
)
{
if
(
aTag
=
=
N
-
1
)
{
using
EntryType
=
typename
mozilla
:
:
detail
:
:
Nth
<
N
-
1
Types
.
.
.
>
:
:
Type
;
if
(
aArg
)
{
return
aView
.
ReadParam
(
static_cast
<
EntryType
*
>
(
aArg
-
>
ptr
(
)
)
)
;
}
return
aView
.
template
ReadParam
<
EntryType
>
(
)
;
}
return
Next
:
:
Read
(
aView
aTag
aArg
)
;
}
}
;
template
<
typename
dummy
>
struct
VariantReader
<
0
dummy
>
{
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aView
Tag
aTag
ParamType
*
aArg
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Tag
wasn
'
t
for
an
entry
in
this
Variant
"
)
;
return
QueueStatus
:
:
kFatalError
;
}
}
;
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
Tag
tag
;
if
(
!
aConsumerView
.
ReadParam
(
&
tag
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
tag
=
tag
;
}
return
VariantReader
<
sizeof
.
.
.
(
Types
)
>
:
:
Read
(
aConsumerView
tag
aArg
)
;
}
template
<
size_t
N
typename
View
>
struct
MinSizeVariant
{
using
Next
=
MinSizeVariant
<
N
-
1
View
>
;
static
size_t
MinSize
(
View
&
aView
const
Tag
*
aTag
const
ParamType
*
aArg
)
{
using
EntryType
=
typename
mozilla
:
:
detail
:
:
Nth
<
N
-
1
Types
.
.
.
>
:
:
Type
;
if
(
!
aArg
)
{
return
std
:
:
min
(
aView
.
template
MinSizeParam
<
EntryType
>
(
)
Next
:
:
MinSize
(
aView
aTag
aArg
)
)
;
}
MOZ_ASSERT
(
aTag
)
;
if
(
*
aTag
=
=
N
-
1
)
{
return
aView
.
MinSizeParam
(
&
aArg
-
>
template
as
<
EntryType
>
(
)
)
;
}
return
Next
:
:
MinSize
(
aView
aTag
aArg
)
;
}
}
;
template
<
typename
View
>
struct
MinSizeVariant
<
0
View
>
{
static
size_t
MinSize
(
View
&
aView
const
Tag
*
aTag
const
ParamType
*
aArg
)
{
if
(
!
aArg
)
{
return
0
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Tag
wasn
'
t
for
an
entry
in
this
Variant
"
)
;
return
0
;
}
}
;
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
const
Tag
*
tag
=
aArg
?
&
aArg
-
>
tag
:
nullptr
;
return
aView
.
MinSizeParam
(
tag
)
+
MinSizeVariant
<
sizeof
.
.
.
(
Types
)
View
>
:
:
MinSize
(
aView
tag
aArg
)
;
}
}
;
}
}
#
endif
