#
include
"
mozilla
/
dom
/
ImageBitmap
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
dom
/
BlobImpl
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
dom
/
CanvasUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLVideoElement
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
mozilla
/
dom
/
OffscreenCanvas
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneTags
.
h
"
#
include
"
mozilla
/
dom
/
SVGImageElement
.
h
"
#
include
"
mozilla
/
dom
/
WorkerPrivate
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRef
.
h
"
#
include
"
mozilla
/
dom
/
WorkerRunnable
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
Scale
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsIAsyncInputStream
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
imgTools
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
mozilla
:
:
dom
:
:
HTMLMediaElement_Binding
:
:
HAVE_METADATA
;
using
mozilla
:
:
dom
:
:
HTMLMediaElement_Binding
:
:
NETWORK_EMPTY
;
namespace
mozilla
:
:
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ImageBitmap
mParent
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ImageBitmap
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ImageBitmap
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ImageBitmap
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
class
ImageBitmapShutdownObserver
final
:
public
nsIObserver
{
public
:
explicit
ImageBitmapShutdownObserver
(
ImageBitmap
*
aImageBitmap
)
:
mImageBitmap
(
nullptr
)
{
if
(
NS_IsMainThread
(
)
)
{
mImageBitmap
=
aImageBitmap
;
}
else
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
mMainThreadEventTarget
=
workerPrivate
-
>
MainThreadEventTarget
(
)
;
mSendToWorkerTask
=
new
SendShutdownToWorkerThread
(
aImageBitmap
)
;
}
}
void
RegisterObserver
(
)
{
if
(
NS_IsMainThread
(
)
)
{
nsContentUtils
:
:
RegisterShutdownObserver
(
this
)
;
return
;
}
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
RefPtr
<
ImageBitmapShutdownObserver
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
ImageBitmapShutdownObserver
:
:
RegisterObserver
"
[
self
]
(
)
{
self
-
>
RegisterObserver
(
)
;
}
)
;
mMainThreadEventTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
UnregisterObserver
(
)
{
if
(
NS_IsMainThread
(
)
)
{
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
return
;
}
MOZ_ASSERT
(
mMainThreadEventTarget
)
;
RefPtr
<
ImageBitmapShutdownObserver
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
ImageBitmapShutdownObserver
:
:
RegisterObserver
"
[
self
]
(
)
{
self
-
>
UnregisterObserver
(
)
;
}
)
;
mMainThreadEventTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
void
Clear
(
)
{
mImageBitmap
=
nullptr
;
if
(
mSendToWorkerTask
)
{
mSendToWorkerTask
-
>
mImageBitmap
=
nullptr
;
}
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
private
:
~
ImageBitmapShutdownObserver
(
)
=
default
;
class
SendShutdownToWorkerThread
:
public
MainThreadWorkerControlRunnable
{
public
:
explicit
SendShutdownToWorkerThread
(
ImageBitmap
*
aImageBitmap
)
:
MainThreadWorkerControlRunnable
(
GetCurrentThreadWorkerPrivate
(
)
)
mImageBitmap
(
aImageBitmap
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
if
(
mImageBitmap
)
{
mImageBitmap
-
>
OnShutdown
(
)
;
mImageBitmap
=
nullptr
;
}
return
true
;
}
ImageBitmap
*
mImageBitmap
;
}
;
ImageBitmap
*
mImageBitmap
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
RefPtr
<
SendShutdownToWorkerThread
>
mSendToWorkerTask
;
}
;
NS_IMPL_ISUPPORTS
(
ImageBitmapShutdownObserver
nsIObserver
)
NS_IMETHODIMP
ImageBitmapShutdownObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
strcmp
(
aTopic
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
=
=
0
)
{
if
(
mSendToWorkerTask
)
{
mSendToWorkerTask
-
>
Dispatch
(
)
;
}
else
{
if
(
mImageBitmap
)
{
mImageBitmap
-
>
OnShutdown
(
)
;
mImageBitmap
=
nullptr
;
}
}
nsContentUtils
:
:
UnregisterShutdownObserver
(
this
)
;
}
return
NS_OK
;
}
static
IntRect
FixUpNegativeDimension
(
const
IntRect
&
aRect
ErrorResult
&
aRv
)
{
gfx
:
:
IntRect
rect
=
aRect
;
if
(
rect
.
width
<
0
)
{
CheckedInt32
checkedX
=
CheckedInt32
(
rect
.
x
)
+
rect
.
width
;
if
(
!
checkedX
.
isValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
rect
;
}
rect
.
x
=
checkedX
.
value
(
)
;
rect
.
width
=
-
(
rect
.
width
)
;
}
if
(
rect
.
height
<
0
)
{
CheckedInt32
checkedY
=
CheckedInt32
(
rect
.
y
)
+
rect
.
height
;
if
(
!
checkedY
.
isValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
rect
;
}
rect
.
y
=
checkedY
.
value
(
)
;
rect
.
height
=
-
(
rect
.
height
)
;
}
return
rect
;
}
static
already_AddRefed
<
DataSourceSurface
>
CropAndCopyDataSourceSurface
(
DataSourceSurface
*
aSurface
const
IntRect
&
aCropRect
)
{
MOZ_ASSERT
(
aSurface
)
;
ErrorResult
error
;
const
IntRect
positiveCropRect
=
FixUpNegativeDimension
(
aCropRect
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
nullptr
;
}
const
SurfaceFormat
format
=
SurfaceFormat
:
:
B8G8R8A8
;
const
int
bytesPerPixel
=
BytesPerPixel
(
format
)
;
const
IntSize
dstSize
=
IntSize
(
positiveCropRect
.
width
positiveCropRect
.
height
)
;
const
uint32_t
dstStride
=
dstSize
.
width
*
bytesPerPixel
;
RefPtr
<
DataSourceSurface
>
dstDataSurface
=
Factory
:
:
CreateDataSourceSurfaceWithStride
(
dstSize
format
dstStride
true
)
;
if
(
NS_WARN_IF
(
!
dstDataSurface
)
)
{
return
nullptr
;
}
const
IntRect
surfRect
(
IntPoint
(
0
0
)
aSurface
-
>
GetSize
(
)
)
;
if
(
surfRect
.
Intersects
(
positiveCropRect
)
)
{
const
IntRect
surfPortion
=
surfRect
.
Intersect
(
positiveCropRect
)
;
const
IntPoint
dest
(
std
:
:
max
(
0
surfPortion
.
X
(
)
-
positiveCropRect
.
X
(
)
)
std
:
:
max
(
0
surfPortion
.
Y
(
)
-
positiveCropRect
.
Y
(
)
)
)
;
DataSourceSurface
:
:
ScopedMap
srcMap
(
aSurface
DataSourceSurface
:
:
READ
)
;
DataSourceSurface
:
:
ScopedMap
dstMap
(
dstDataSurface
DataSourceSurface
:
:
WRITE
)
;
if
(
NS_WARN_IF
(
!
srcMap
.
IsMapped
(
)
)
|
|
NS_WARN_IF
(
!
dstMap
.
IsMapped
(
)
)
)
{
return
nullptr
;
}
uint8_t
*
srcBufferPtr
=
srcMap
.
GetData
(
)
+
surfPortion
.
y
*
srcMap
.
GetStride
(
)
+
surfPortion
.
x
*
bytesPerPixel
;
uint8_t
*
dstBufferPtr
=
dstMap
.
GetData
(
)
+
dest
.
y
*
dstMap
.
GetStride
(
)
+
dest
.
x
*
bytesPerPixel
;
CheckedInt
<
uint32_t
>
copiedBytesPerRaw
=
CheckedInt
<
uint32_t
>
(
surfPortion
.
width
)
*
bytesPerPixel
;
if
(
!
copiedBytesPerRaw
.
isValid
(
)
)
{
return
nullptr
;
}
for
(
int
i
=
0
;
i
<
surfPortion
.
height
;
+
+
i
)
{
memcpy
(
dstBufferPtr
srcBufferPtr
copiedBytesPerRaw
.
value
(
)
)
;
srcBufferPtr
+
=
srcMap
.
GetStride
(
)
;
dstBufferPtr
+
=
dstMap
.
GetStride
(
)
;
}
}
return
dstDataSurface
.
forget
(
)
;
}
static
already_AddRefed
<
DataSourceSurface
>
ScaleDataSourceSurface
(
DataSourceSurface
*
aSurface
const
ImageBitmapOptions
&
aOptions
)
{
MOZ_ASSERT
(
aSurface
)
;
const
SurfaceFormat
format
=
aSurface
-
>
GetFormat
(
)
;
const
int
bytesPerPixel
=
BytesPerPixel
(
format
)
;
const
IntSize
srcSize
=
aSurface
-
>
GetSize
(
)
;
int32_t
tmp
;
CheckedInt
<
int32_t
>
checked
;
CheckedInt
<
int32_t
>
dstWidth
(
aOptions
.
mResizeWidth
.
WasPassed
(
)
?
aOptions
.
mResizeWidth
.
Value
(
)
:
0
)
;
CheckedInt
<
int32_t
>
dstHeight
(
aOptions
.
mResizeHeight
.
WasPassed
(
)
?
aOptions
.
mResizeHeight
.
Value
(
)
:
0
)
;
if
(
!
dstWidth
.
isValid
(
)
|
|
!
dstHeight
.
isValid
(
)
)
{
return
nullptr
;
}
if
(
!
dstWidth
.
value
(
)
)
{
checked
=
srcSize
.
width
*
dstHeight
;
if
(
!
checked
.
isValid
(
)
)
{
return
nullptr
;
}
tmp
=
ceil
(
checked
.
value
(
)
/
double
(
srcSize
.
height
)
)
;
dstWidth
=
tmp
;
}
else
if
(
!
dstHeight
.
value
(
)
)
{
checked
=
srcSize
.
height
*
dstWidth
;
if
(
!
checked
.
isValid
(
)
)
{
return
nullptr
;
}
tmp
=
ceil
(
checked
.
value
(
)
/
double
(
srcSize
.
width
)
)
;
dstHeight
=
tmp
;
}
const
IntSize
dstSize
(
dstWidth
.
value
(
)
dstHeight
.
value
(
)
)
;
const
int32_t
dstStride
=
dstSize
.
width
*
bytesPerPixel
;
RefPtr
<
DataSourceSurface
>
dstDataSurface
=
Factory
:
:
CreateDataSourceSurfaceWithStride
(
dstSize
format
dstStride
true
)
;
if
(
NS_WARN_IF
(
!
dstDataSurface
)
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
srcMap
(
aSurface
DataSourceSurface
:
:
READ
)
;
DataSourceSurface
:
:
ScopedMap
dstMap
(
dstDataSurface
DataSourceSurface
:
:
WRITE
)
;
if
(
NS_WARN_IF
(
!
srcMap
.
IsMapped
(
)
)
|
|
NS_WARN_IF
(
!
dstMap
.
IsMapped
(
)
)
)
{
return
nullptr
;
}
uint8_t
*
srcBufferPtr
=
srcMap
.
GetData
(
)
;
uint8_t
*
dstBufferPtr
=
dstMap
.
GetData
(
)
;
bool
res
=
Scale
(
srcBufferPtr
srcSize
.
width
srcSize
.
height
srcMap
.
GetStride
(
)
dstBufferPtr
dstSize
.
width
dstSize
.
height
dstMap
.
GetStride
(
)
aSurface
-
>
GetFormat
(
)
)
;
if
(
!
res
)
{
return
nullptr
;
}
return
dstDataSurface
.
forget
(
)
;
}
static
DataSourceSurface
*
FlipYDataSourceSurface
(
DataSourceSurface
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
)
;
DataSourceSurface
:
:
ScopedMap
srcMap
(
aSurface
DataSourceSurface
:
:
READ_WRITE
)
;
if
(
NS_WARN_IF
(
!
srcMap
.
IsMapped
(
)
)
)
{
return
nullptr
;
}
const
IntSize
srcSize
=
aSurface
-
>
GetSize
(
)
;
uint8_t
*
srcBufferPtr
=
srcMap
.
GetData
(
)
;
const
uint32_t
stride
=
srcMap
.
GetStride
(
)
;
CheckedInt
<
uint32_t
>
copiedBytesPerRaw
=
CheckedInt
<
uint32_t
>
(
stride
)
;
if
(
!
copiedBytesPerRaw
.
isValid
(
)
)
{
return
nullptr
;
}
for
(
int
i
=
0
;
i
<
srcSize
.
height
/
2
;
+
+
i
)
{
std
:
:
swap_ranges
(
srcBufferPtr
+
stride
*
i
srcBufferPtr
+
stride
*
(
i
+
1
)
srcBufferPtr
+
stride
*
(
srcSize
.
height
-
1
-
i
)
)
;
}
return
aSurface
;
}
static
DataSourceSurface
*
AlphaPremultiplyDataSourceSurface
(
DataSourceSurface
*
aSurface
const
bool
forward
=
true
)
{
MOZ_ASSERT
(
aSurface
)
;
DataSourceSurface
:
:
MappedSurface
surfaceMap
;
if
(
aSurface
-
>
Map
(
DataSourceSurface
:
:
MapType
:
:
READ_WRITE
&
surfaceMap
)
)
{
if
(
forward
)
{
PremultiplyData
(
surfaceMap
.
mData
surfaceMap
.
mStride
aSurface
-
>
GetFormat
(
)
surfaceMap
.
mData
surfaceMap
.
mStride
aSurface
-
>
GetFormat
(
)
aSurface
-
>
GetSize
(
)
)
;
}
else
{
UnpremultiplyData
(
surfaceMap
.
mData
surfaceMap
.
mStride
aSurface
-
>
GetFormat
(
)
surfaceMap
.
mData
surfaceMap
.
mStride
aSurface
-
>
GetFormat
(
)
aSurface
-
>
GetSize
(
)
)
;
}
aSurface
-
>
Unmap
(
)
;
}
else
{
return
nullptr
;
}
return
aSurface
;
}
static
already_AddRefed
<
layers
:
:
Image
>
CreateImageFromSurface
(
SourceSurface
*
aSurface
)
{
MOZ_ASSERT
(
aSurface
)
;
RefPtr
<
layers
:
:
SourceSurfaceImage
>
image
=
new
layers
:
:
SourceSurfaceImage
(
aSurface
-
>
GetSize
(
)
aSurface
)
;
return
image
.
forget
(
)
;
}
static
already_AddRefed
<
SourceSurface
>
CreateSurfaceFromRawData
(
const
gfx
:
:
IntSize
&
aSize
uint32_t
aStride
gfx
:
:
SurfaceFormat
aFormat
uint8_t
*
aBuffer
uint32_t
aBufferLength
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
)
{
MOZ_ASSERT
(
!
aSize
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aBuffer
)
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
Factory
:
:
CreateWrappingDataSourceSurface
(
aBuffer
aStride
aSize
aFormat
)
;
if
(
NS_WARN_IF
(
!
dataSurface
)
)
{
return
nullptr
;
}
const
IntRect
cropRect
=
aCropRect
.
valueOr
(
IntRect
(
0
0
aSize
.
width
aSize
.
height
)
)
;
RefPtr
<
DataSourceSurface
>
result
=
CropAndCopyDataSourceSurface
(
dataSurface
cropRect
)
;
if
(
NS_WARN_IF
(
!
result
)
)
{
return
nullptr
;
}
if
(
aOptions
.
mImageOrientation
=
=
ImageOrientation
:
:
FlipY
)
{
result
=
FlipYDataSourceSurface
(
result
)
;
if
(
NS_WARN_IF
(
!
result
)
)
{
return
nullptr
;
}
}
if
(
aOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
Premultiply
)
{
result
=
AlphaPremultiplyDataSourceSurface
(
result
)
;
if
(
NS_WARN_IF
(
!
result
)
)
{
return
nullptr
;
}
}
if
(
aOptions
.
mResizeWidth
.
WasPassed
(
)
|
|
aOptions
.
mResizeHeight
.
WasPassed
(
)
)
{
dataSurface
=
result
-
>
GetDataSurface
(
)
;
result
=
ScaleDataSourceSurface
(
dataSurface
aOptions
)
;
if
(
NS_WARN_IF
(
!
result
)
)
{
return
nullptr
;
}
}
return
result
.
forget
(
)
;
}
static
already_AddRefed
<
layers
:
:
Image
>
CreateImageFromRawData
(
const
gfx
:
:
IntSize
&
aSize
uint32_t
aStride
gfx
:
:
SurfaceFormat
aFormat
uint8_t
*
aBuffer
uint32_t
aBufferLength
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
SourceSurface
>
rgbaSurface
=
CreateSurfaceFromRawData
(
aSize
aStride
aFormat
aBuffer
aBufferLength
aCropRect
aOptions
)
;
if
(
NS_WARN_IF
(
!
rgbaSurface
)
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
rgbaDataSurface
=
rgbaSurface
-
>
GetDataSurface
(
)
;
DataSourceSurface
:
:
ScopedMap
rgbaMap
(
rgbaDataSurface
DataSourceSurface
:
:
READ
)
;
if
(
NS_WARN_IF
(
!
rgbaMap
.
IsMapped
(
)
)
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
bgraDataSurface
=
Factory
:
:
CreateDataSourceSurfaceWithStride
(
rgbaDataSurface
-
>
GetSize
(
)
SurfaceFormat
:
:
B8G8R8A8
rgbaMap
.
GetStride
(
)
)
;
if
(
NS_WARN_IF
(
!
bgraDataSurface
)
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
bgraMap
(
bgraDataSurface
DataSourceSurface
:
:
WRITE
)
;
if
(
NS_WARN_IF
(
!
bgraMap
.
IsMapped
(
)
)
)
{
return
nullptr
;
}
SwizzleData
(
rgbaMap
.
GetData
(
)
rgbaMap
.
GetStride
(
)
SurfaceFormat
:
:
R8G8B8A8
bgraMap
.
GetData
(
)
bgraMap
.
GetStride
(
)
SurfaceFormat
:
:
B8G8R8A8
bgraDataSurface
-
>
GetSize
(
)
)
;
return
CreateImageFromSurface
(
bgraDataSurface
)
;
}
class
CreateImageFromRawDataInMainThreadSyncTask
final
:
public
WorkerMainThreadRunnable
{
public
:
CreateImageFromRawDataInMainThreadSyncTask
(
uint8_t
*
aBuffer
uint32_t
aBufferLength
uint32_t
aStride
gfx
:
:
SurfaceFormat
aFormat
const
gfx
:
:
IntSize
&
aSize
const
Maybe
<
IntRect
>
&
aCropRect
layers
:
:
Image
*
*
aImage
const
ImageBitmapOptions
&
aOptions
)
:
WorkerMainThreadRunnable
(
GetCurrentThreadWorkerPrivate
(
)
"
ImageBitmap
:
:
Create
Image
from
Raw
Data
"
_ns
)
mImage
(
aImage
)
mBuffer
(
aBuffer
)
mBufferLength
(
aBufferLength
)
mStride
(
aStride
)
mFormat
(
aFormat
)
mSize
(
aSize
)
mCropRect
(
aCropRect
)
mOptions
(
aOptions
)
{
MOZ_ASSERT
(
!
(
*
aImage
)
"
Don
'
t
pass
an
existing
Image
into
"
"
CreateImageFromRawDataInMainThreadSyncTask
.
"
)
;
}
bool
MainThreadRun
(
)
override
{
RefPtr
<
layers
:
:
Image
>
image
=
CreateImageFromRawData
(
mSize
mStride
mFormat
mBuffer
mBufferLength
mCropRect
mOptions
)
;
if
(
NS_WARN_IF
(
!
image
)
)
{
return
false
;
}
image
.
forget
(
mImage
)
;
return
true
;
}
private
:
layers
:
:
Image
*
*
mImage
;
uint8_t
*
mBuffer
;
uint32_t
mBufferLength
;
uint32_t
mStride
;
gfx
:
:
SurfaceFormat
mFormat
;
gfx
:
:
IntSize
mSize
;
const
Maybe
<
IntRect
>
&
mCropRect
;
const
ImageBitmapOptions
mOptions
;
}
;
template
<
class
ElementType
>
static
already_AddRefed
<
SourceSurface
>
GetSurfaceFromElement
(
nsIGlobalObject
*
aGlobal
ElementType
&
aElement
bool
*
aWriteOnly
const
ImageBitmapOptions
&
aOptions
gfxAlphaType
*
aAlphaType
ErrorResult
&
aRv
)
{
uint32_t
flags
=
nsLayoutUtils
:
:
SFE_WANT_FIRST_FRAME_IF_IMAGE
;
if
(
aOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
None
)
{
flags
|
=
nsLayoutUtils
:
:
SFE_ALLOW_NON_PREMULT
;
}
if
(
aOptions
.
mColorSpaceConversion
=
=
ColorSpaceConversion
:
:
None
&
&
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
flags
|
=
nsLayoutUtils
:
:
SFE_NO_COLORSPACE_CONVERSION
;
}
SurfaceFromElementResult
res
=
nsLayoutUtils
:
:
SurfaceFromElement
(
&
aElement
flags
)
;
RefPtr
<
SourceSurface
>
surface
=
res
.
GetSourceSurface
(
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
*
aWriteOnly
=
res
.
mIsWriteOnly
;
*
aAlphaType
=
res
.
mAlphaType
;
return
surface
.
forget
(
)
;
}
ImageBitmap
:
:
ImageBitmap
(
nsIGlobalObject
*
aGlobal
layers
:
:
Image
*
aData
bool
aWriteOnly
gfxAlphaType
aAlphaType
)
:
mParent
(
aGlobal
)
mData
(
aData
)
mSurface
(
nullptr
)
mPictureRect
(
aData
-
>
GetPictureRect
(
)
)
mAlphaType
(
aAlphaType
)
mAllocatedImageData
(
false
)
mWriteOnly
(
aWriteOnly
)
{
MOZ_ASSERT
(
aData
"
aData
is
null
in
ImageBitmap
constructor
.
"
)
;
mShutdownObserver
=
new
ImageBitmapShutdownObserver
(
this
)
;
mShutdownObserver
-
>
RegisterObserver
(
)
;
}
ImageBitmap
:
:
~
ImageBitmap
(
)
{
if
(
mShutdownObserver
)
{
mShutdownObserver
-
>
Clear
(
)
;
mShutdownObserver
-
>
UnregisterObserver
(
)
;
mShutdownObserver
=
nullptr
;
}
}
JSObject
*
ImageBitmap
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ImageBitmap_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
void
ImageBitmap
:
:
Close
(
)
{
mData
=
nullptr
;
mSurface
=
nullptr
;
mPictureRect
.
SetEmpty
(
)
;
}
void
ImageBitmap
:
:
OnShutdown
(
)
{
mShutdownObserver
=
nullptr
;
Close
(
)
;
}
void
ImageBitmap
:
:
SetPictureRect
(
const
IntRect
&
aRect
ErrorResult
&
aRv
)
{
mPictureRect
=
FixUpNegativeDimension
(
aRect
aRv
)
;
}
already_AddRefed
<
SourceSurface
>
ImageBitmap
:
:
PrepareForDrawTarget
(
gfx
:
:
DrawTarget
*
aTarget
)
{
MOZ_ASSERT
(
aTarget
)
;
if
(
!
mData
)
{
return
nullptr
;
}
if
(
!
mSurface
)
{
mSurface
=
mData
-
>
GetAsSourceSurface
(
)
;
if
(
!
mSurface
)
{
return
nullptr
;
}
}
IntRect
surfRect
(
0
0
mSurface
-
>
GetSize
(
)
.
width
mSurface
-
>
GetSize
(
)
.
height
)
;
if
(
!
mPictureRect
.
IsEqualEdges
(
surfRect
)
)
{
IntRect
surfPortion
=
surfRect
.
Intersect
(
mPictureRect
)
;
if
(
surfPortion
.
IsEmpty
(
)
)
{
mSurface
=
nullptr
;
return
nullptr
;
}
IntPoint
dest
(
std
:
:
max
(
0
surfPortion
.
X
(
)
-
mPictureRect
.
X
(
)
)
std
:
:
max
(
0
surfPortion
.
Y
(
)
-
mPictureRect
.
Y
(
)
)
)
;
SurfaceFormat
format
=
mSurface
-
>
GetFormat
(
)
;
if
(
!
surfPortion
.
IsEqualEdges
(
mPictureRect
)
&
&
IsOpaque
(
format
)
)
{
format
=
SurfaceFormat
:
:
B8G8R8A8
;
}
RefPtr
<
DrawTarget
>
cropped
=
aTarget
-
>
CreateSimilarDrawTarget
(
mPictureRect
.
Size
(
)
format
)
;
if
(
!
cropped
)
{
mSurface
=
nullptr
;
return
nullptr
;
}
cropped
-
>
CopySurface
(
mSurface
surfPortion
dest
)
;
mSurface
=
cropped
-
>
Snapshot
(
)
;
if
(
!
mSurface
)
{
return
nullptr
;
}
mPictureRect
.
MoveTo
(
0
0
)
;
}
if
(
mAlphaType
=
=
gfxAlphaType
:
:
NonPremult
&
&
!
IsOpaque
(
mSurface
-
>
GetFormat
(
)
)
)
{
MOZ_ASSERT
(
mSurface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
R8G8B8A8
|
|
mSurface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
mSurface
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
A8R8G8B8
)
;
RefPtr
<
DataSourceSurface
>
srcSurface
=
mSurface
-
>
GetDataSurface
(
)
;
if
(
NS_WARN_IF
(
!
srcSurface
)
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
dstSurface
=
Factory
:
:
CreateDataSourceSurface
(
srcSurface
-
>
GetSize
(
)
srcSurface
-
>
GetFormat
(
)
)
;
if
(
NS_WARN_IF
(
!
dstSurface
)
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
srcMap
(
srcSurface
DataSourceSurface
:
:
READ
)
;
if
(
!
srcMap
.
IsMapped
(
)
)
{
gfxCriticalError
(
)
<
<
"
Failed
to
map
source
surface
for
premultiplying
alpha
.
"
;
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
dstMap
(
dstSurface
DataSourceSurface
:
:
WRITE
)
;
if
(
!
dstMap
.
IsMapped
(
)
)
{
gfxCriticalError
(
)
<
<
"
Failed
to
map
destination
surface
for
premultiplying
alpha
.
"
;
return
nullptr
;
}
PremultiplyData
(
srcMap
.
GetData
(
)
srcMap
.
GetStride
(
)
mSurface
-
>
GetFormat
(
)
dstMap
.
GetData
(
)
dstMap
.
GetStride
(
)
mSurface
-
>
GetFormat
(
)
dstSurface
-
>
GetSize
(
)
)
;
mAlphaType
=
gfxAlphaType
:
:
Premult
;
mSurface
=
dstSurface
;
}
mSurface
=
aTarget
-
>
OptimizeSourceSurface
(
mSurface
)
;
return
do_AddRef
(
mSurface
)
;
}
already_AddRefed
<
layers
:
:
Image
>
ImageBitmap
:
:
TransferAsImage
(
)
{
RefPtr
<
layers
:
:
Image
>
image
=
mData
;
Close
(
)
;
return
image
.
forget
(
)
;
}
UniquePtr
<
ImageBitmapCloneData
>
ImageBitmap
:
:
ToCloneData
(
)
const
{
if
(
!
mData
)
{
return
nullptr
;
}
UniquePtr
<
ImageBitmapCloneData
>
result
(
new
ImageBitmapCloneData
(
)
)
;
result
-
>
mPictureRect
=
mPictureRect
;
result
-
>
mAlphaType
=
mAlphaType
;
RefPtr
<
SourceSurface
>
surface
=
mData
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
)
{
return
nullptr
;
}
result
-
>
mSurface
=
surface
-
>
GetDataSurface
(
)
;
MOZ_ASSERT
(
result
-
>
mSurface
)
;
result
-
>
mWriteOnly
=
mWriteOnly
;
return
result
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateFromSourceSurface
(
nsIGlobalObject
*
aGlobal
gfx
:
:
SourceSurface
*
aSource
ErrorResult
&
aRv
)
{
RefPtr
<
layers
:
:
Image
>
data
=
CreateImageFromSurface
(
aSource
)
;
RefPtr
<
ImageBitmap
>
ret
=
new
ImageBitmap
(
aGlobal
data
false
)
;
ret
-
>
mAllocatedImageData
=
true
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateFromCloneData
(
nsIGlobalObject
*
aGlobal
ImageBitmapCloneData
*
aData
)
{
RefPtr
<
layers
:
:
Image
>
data
=
CreateImageFromSurface
(
aData
-
>
mSurface
)
;
RefPtr
<
ImageBitmap
>
ret
=
new
ImageBitmap
(
aGlobal
data
aData
-
>
mWriteOnly
aData
-
>
mAlphaType
)
;
ret
-
>
mAllocatedImageData
=
true
;
ErrorResult
rv
;
ret
-
>
SetPictureRect
(
aData
-
>
mPictureRect
rv
)
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateFromOffscreenCanvas
(
nsIGlobalObject
*
aGlobal
OffscreenCanvas
&
aOffscreenCanvas
ErrorResult
&
aRv
)
{
bool
writeOnly
=
aOffscreenCanvas
.
IsWriteOnly
(
)
;
SurfaceFromElementResult
res
=
nsLayoutUtils
:
:
SurfaceFromOffscreenCanvas
(
&
aOffscreenCanvas
nsLayoutUtils
:
:
SFE_WANT_FIRST_FRAME_IF_IMAGE
)
;
RefPtr
<
SourceSurface
>
surface
=
res
.
GetSourceSurface
(
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
layers
:
:
Image
>
data
=
CreateImageFromSurface
(
surface
)
;
RefPtr
<
ImageBitmap
>
ret
=
new
ImageBitmap
(
aGlobal
data
writeOnly
)
;
ret
-
>
mAllocatedImageData
=
true
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateImageBitmapInternal
(
nsIGlobalObject
*
aGlobal
gfx
:
:
SourceSurface
*
aSurface
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
const
bool
aWriteOnly
const
bool
aAllocatedImageData
const
bool
aMustCopy
const
gfxAlphaType
aAlphaType
ErrorResult
&
aRv
)
{
bool
needToReportMemoryAllocation
=
aAllocatedImageData
;
const
IntSize
srcSize
=
aSurface
-
>
GetSize
(
)
;
IntRect
cropRect
=
aCropRect
.
valueOr
(
IntRect
(
0
0
srcSize
.
width
srcSize
.
height
)
)
;
RefPtr
<
SourceSurface
>
surface
=
aSurface
;
RefPtr
<
DataSourceSurface
>
dataSurface
;
gfxAlphaType
alphaType
=
aAlphaType
;
bool
mustCopy
=
aMustCopy
;
bool
requiresPremultiply
=
false
;
bool
requiresUnpremultiply
=
false
;
if
(
!
IsOpaque
(
surface
-
>
GetFormat
(
)
)
)
{
if
(
aAlphaType
=
=
gfxAlphaType
:
:
Premult
&
&
aOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
None
)
{
requiresUnpremultiply
=
true
;
alphaType
=
gfxAlphaType
:
:
NonPremult
;
if
(
!
aAllocatedImageData
)
{
mustCopy
=
true
;
}
}
else
if
(
aAlphaType
=
=
gfxAlphaType
:
:
NonPremult
&
&
aOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
Premultiply
)
{
requiresPremultiply
=
true
;
alphaType
=
gfxAlphaType
:
:
Premult
;
if
(
!
aAllocatedImageData
)
{
mustCopy
=
true
;
}
}
}
if
(
(
aOptions
.
mImageOrientation
=
=
ImageOrientation
:
:
FlipY
&
&
(
!
aAllocatedImageData
|
|
aCropRect
.
isSome
(
)
)
)
|
|
mustCopy
)
{
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
dataSurface
=
CropAndCopyDataSourceSurface
(
dataSurface
cropRect
)
;
if
(
NS_WARN_IF
(
!
dataSurface
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
surface
=
dataSurface
;
cropRect
.
SetRect
(
0
0
dataSurface
-
>
GetSize
(
)
.
width
dataSurface
-
>
GetSize
(
)
.
height
)
;
needToReportMemoryAllocation
=
true
;
}
if
(
aOptions
.
mImageOrientation
=
=
ImageOrientation
:
:
FlipY
)
{
if
(
!
dataSurface
)
{
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
}
surface
=
FlipYDataSourceSurface
(
dataSurface
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
return
nullptr
;
}
}
if
(
requiresPremultiply
)
{
if
(
!
dataSurface
)
{
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
}
surface
=
AlphaPremultiplyDataSourceSurface
(
dataSurface
true
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
return
nullptr
;
}
}
if
(
aOptions
.
mResizeWidth
.
WasPassed
(
)
|
|
aOptions
.
mResizeHeight
.
WasPassed
(
)
)
{
if
(
!
dataSurface
)
{
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
}
;
surface
=
ScaleDataSourceSurface
(
dataSurface
aOptions
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Failed
to
create
resized
image
"
)
;
return
nullptr
;
}
needToReportMemoryAllocation
=
true
;
cropRect
.
SetRect
(
0
0
surface
-
>
GetSize
(
)
.
width
surface
-
>
GetSize
(
)
.
height
)
;
}
if
(
requiresUnpremultiply
)
{
if
(
!
dataSurface
)
{
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
}
surface
=
AlphaPremultiplyDataSourceSurface
(
dataSurface
false
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
return
nullptr
;
}
}
RefPtr
<
layers
:
:
Image
>
data
=
CreateImageFromSurface
(
surface
)
;
RefPtr
<
ImageBitmap
>
ret
=
new
ImageBitmap
(
aGlobal
data
aWriteOnly
alphaType
)
;
if
(
needToReportMemoryAllocation
)
{
ret
-
>
mAllocatedImageData
=
true
;
}
ret
-
>
SetPictureRect
(
cropRect
aRv
)
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
HTMLImageElement
&
aImageEl
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
!
aImageEl
.
Complete
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
bool
writeOnly
=
true
;
gfxAlphaType
alphaType
=
gfxAlphaType
:
:
NonPremult
;
RefPtr
<
SourceSurface
>
surface
=
GetSurfaceFromElement
(
aGlobal
aImageEl
&
writeOnly
aOptions
&
alphaType
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
bool
needToReportMemoryAllocation
=
false
;
return
CreateImageBitmapInternal
(
aGlobal
surface
aCropRect
aOptions
writeOnly
needToReportMemoryAllocation
false
alphaType
aRv
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
SVGImageElement
&
aImageEl
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
bool
writeOnly
=
true
;
gfxAlphaType
alphaType
=
gfxAlphaType
:
:
NonPremult
;
RefPtr
<
SourceSurface
>
surface
=
GetSurfaceFromElement
(
aGlobal
aImageEl
&
writeOnly
aOptions
&
alphaType
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
bool
needToReportMemoryAllocation
=
false
;
return
CreateImageBitmapInternal
(
aGlobal
surface
aCropRect
aOptions
writeOnly
needToReportMemoryAllocation
false
alphaType
aRv
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
HTMLVideoElement
&
aVideoEl
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
aVideoEl
.
MarkAsContentSource
(
mozilla
:
:
dom
:
:
HTMLVideoElement
:
:
CallerAPI
:
:
CREATE_IMAGEBITMAP
)
;
if
(
aVideoEl
.
NetworkState
(
)
=
=
NETWORK_EMPTY
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
aVideoEl
.
ReadyState
(
)
<
=
HAVE_METADATA
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aVideoEl
.
GetCurrentVideoPrincipal
(
)
;
bool
hadCrossOriginRedirects
=
aVideoEl
.
HadCrossOriginRedirects
(
)
;
bool
CORSUsed
=
aVideoEl
.
GetCORSMode
(
)
!
=
CORS_NONE
;
bool
writeOnly
=
CanvasUtils
:
:
CheckWriteOnlySecurity
(
CORSUsed
principal
hadCrossOriginRedirects
)
;
RefPtr
<
layers
:
:
Image
>
data
=
aVideoEl
.
GetCurrentImage
(
)
;
if
(
!
data
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
SourceSurface
>
surface
=
data
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
)
{
RefPtr
<
ImageBitmap
>
ret
=
new
ImageBitmap
(
aGlobal
data
writeOnly
)
;
return
ret
.
forget
(
)
;
}
bool
needToReportMemoryAllocation
=
false
;
return
CreateImageBitmapInternal
(
aGlobal
surface
aCropRect
aOptions
writeOnly
needToReportMemoryAllocation
false
gfxAlphaType
:
:
Premult
aRv
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
HTMLCanvasElement
&
aCanvasEl
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
aCanvasEl
.
Width
(
)
=
=
0
|
|
aCanvasEl
.
Height
(
)
=
=
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
bool
writeOnly
=
true
;
gfxAlphaType
alphaType
=
gfxAlphaType
:
:
NonPremult
;
RefPtr
<
SourceSurface
>
surface
=
GetSurfaceFromElement
(
aGlobal
aCanvasEl
&
writeOnly
aOptions
&
alphaType
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
!
writeOnly
)
{
writeOnly
=
aCanvasEl
.
IsWriteOnly
(
)
;
}
bool
needToReportMemoryAllocation
=
false
;
bool
mustCopy
=
false
;
if
(
(
aCanvasEl
.
GetCurrentContextType
(
)
=
=
CanvasContextType
:
:
WebGL1
|
|
aCanvasEl
.
GetCurrentContextType
(
)
=
=
CanvasContextType
:
:
WebGL2
|
|
aCanvasEl
.
GetCurrentContextType
(
)
=
=
CanvasContextType
:
:
WebGPU
)
&
&
aCropRect
.
isSome
(
)
)
{
mustCopy
=
true
;
}
return
CreateImageBitmapInternal
(
aGlobal
surface
aCropRect
aOptions
writeOnly
needToReportMemoryAllocation
mustCopy
alphaType
aRv
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
OffscreenCanvas
&
aOffscreenCanvas
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
aOffscreenCanvas
.
Width
(
)
=
=
0
)
{
aRv
.
ThrowInvalidStateError
(
"
Passed
-
in
canvas
has
width
0
"
)
;
return
nullptr
;
}
if
(
aOffscreenCanvas
.
Height
(
)
=
=
0
)
{
aRv
.
ThrowInvalidStateError
(
"
Passed
-
in
canvas
has
height
0
"
)
;
return
nullptr
;
}
uint32_t
flags
=
nsLayoutUtils
:
:
SFE_WANT_FIRST_FRAME_IF_IMAGE
;
if
(
aOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
None
)
{
flags
|
=
nsLayoutUtils
:
:
SFE_ALLOW_NON_PREMULT
;
}
SurfaceFromElementResult
res
=
nsLayoutUtils
:
:
SurfaceFromOffscreenCanvas
(
&
aOffscreenCanvas
flags
)
;
RefPtr
<
SourceSurface
>
surface
=
res
.
GetSourceSurface
(
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Passed
-
in
canvas
failed
to
create
snapshot
"
)
;
return
nullptr
;
}
gfxAlphaType
alphaType
=
res
.
mAlphaType
;
bool
writeOnly
=
res
.
mIsWriteOnly
;
bool
needToReportMemoryAllocation
=
false
;
bool
mustCopy
=
aCropRect
.
isSome
(
)
&
&
(
aOffscreenCanvas
.
GetContextType
(
)
=
=
CanvasContextType
:
:
WebGL1
|
|
aOffscreenCanvas
.
GetContextType
(
)
=
=
CanvasContextType
:
:
WebGL2
|
|
aOffscreenCanvas
.
GetContextType
(
)
=
=
CanvasContextType
:
:
WebGPU
)
;
return
CreateImageBitmapInternal
(
aGlobal
surface
aCropRect
aOptions
writeOnly
needToReportMemoryAllocation
mustCopy
alphaType
aRv
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
ImageData
&
aImageData
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
RootedSpiderMonkeyInterface
<
Uint8ClampedArray
>
array
(
RootingCx
(
)
)
;
if
(
!
array
.
Init
(
aImageData
.
GetDataObject
(
)
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Failed
to
extract
Uint8ClampedArray
from
ImageData
(
security
check
"
"
failed
?
)
"
)
;
return
nullptr
;
}
array
.
ComputeState
(
)
;
const
SurfaceFormat
FORMAT
=
SurfaceFormat
:
:
R8G8B8A8
;
auto
alphaType
=
(
aOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
Premultiply
)
?
gfxAlphaType
:
:
Premult
:
gfxAlphaType
:
:
NonPremult
;
const
uint32_t
BYTES_PER_PIXEL
=
BytesPerPixel
(
FORMAT
)
;
const
uint32_t
imageWidth
=
aImageData
.
Width
(
)
;
const
uint32_t
imageHeight
=
aImageData
.
Height
(
)
;
const
uint32_t
imageStride
=
imageWidth
*
BYTES_PER_PIXEL
;
const
uint32_t
dataLength
=
array
.
Length
(
)
;
const
gfx
:
:
IntSize
imageSize
(
imageWidth
imageHeight
)
;
if
(
imageWidth
=
=
0
|
|
imageHeight
=
=
0
)
{
aRv
.
ThrowInvalidStateError
(
"
Passed
-
in
image
is
empty
"
)
;
return
nullptr
;
}
if
(
(
imageWidth
*
imageHeight
*
BYTES_PER_PIXEL
)
!
=
dataLength
)
{
aRv
.
ThrowInvalidStateError
(
"
Data
size
/
image
format
mismatch
"
)
;
return
nullptr
;
}
RefPtr
<
layers
:
:
Image
>
data
;
size_t
maxInline
=
JS_MaxMovableTypedArraySize
(
)
;
uint8_t
inlineDataBuffer
[
maxInline
]
;
uint8_t
*
fixedData
=
array
.
FixedData
(
inlineDataBuffer
maxInline
)
;
array
.
Reset
(
)
;
if
(
NS_IsMainThread
(
)
)
{
data
=
CreateImageFromRawData
(
imageSize
imageStride
FORMAT
fixedData
dataLength
aCropRect
aOptions
)
;
}
else
{
RefPtr
<
CreateImageFromRawDataInMainThreadSyncTask
>
task
=
new
CreateImageFromRawDataInMainThreadSyncTask
(
fixedData
dataLength
imageStride
FORMAT
imageSize
aCropRect
getter_AddRefs
(
data
)
aOptions
)
;
task
-
>
Dispatch
(
Canceling
aRv
)
;
}
if
(
NS_WARN_IF
(
!
data
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Failed
to
create
internal
image
"
)
;
return
nullptr
;
}
RefPtr
<
ImageBitmap
>
ret
=
new
ImageBitmap
(
aGlobal
data
false
alphaType
)
;
ret
-
>
mAllocatedImageData
=
true
;
return
ret
.
forget
(
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
CanvasRenderingContext2D
&
aCanvasCtx
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aGlobal
)
;
nsGlobalWindowInner
*
window
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
if
(
NS_WARN_IF
(
!
window
)
|
|
!
window
-
>
GetExtantDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
window
-
>
GetExtantDoc
(
)
-
>
WarnOnceAbout
(
DeprecatedOperations
:
:
eCreateImageBitmapCanvasRenderingContext2D
)
;
bool
writeOnly
=
aCanvasCtx
.
GetCanvas
(
)
-
>
IsWriteOnly
(
)
|
|
aCanvasCtx
.
IsWriteOnly
(
)
;
RefPtr
<
SourceSurface
>
surface
=
aCanvasCtx
.
GetSurfaceSnapshot
(
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
const
IntSize
surfaceSize
=
surface
-
>
GetSize
(
)
;
if
(
surfaceSize
.
width
=
=
0
|
|
surfaceSize
.
height
=
=
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
bool
needToReportMemoryAllocation
=
true
;
return
CreateImageBitmapInternal
(
aGlobal
surface
aCropRect
aOptions
writeOnly
needToReportMemoryAllocation
false
gfxAlphaType
:
:
Premult
aRv
)
;
}
already_AddRefed
<
ImageBitmap
>
ImageBitmap
:
:
CreateInternal
(
nsIGlobalObject
*
aGlobal
ImageBitmap
&
aImageBitmap
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
!
aImageBitmap
.
mData
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
IntRect
cropRect
=
aImageBitmap
.
mPictureRect
;
RefPtr
<
SourceSurface
>
surface
;
bool
needToReportMemoryAllocation
=
false
;
if
(
aImageBitmap
.
mSurface
)
{
surface
=
aImageBitmap
.
mSurface
;
cropRect
=
aCropRect
.
valueOr
(
cropRect
)
;
}
else
{
RefPtr
<
layers
:
:
Image
>
data
=
aImageBitmap
.
mData
;
surface
=
data
-
>
GetAsSourceSurface
(
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
if
(
aCropRect
.
isSome
(
)
)
{
IntRect
newCropRect
=
aCropRect
.
ref
(
)
;
newCropRect
=
FixUpNegativeDimension
(
newCropRect
aRv
)
;
newCropRect
.
MoveBy
(
cropRect
.
X
(
)
cropRect
.
Y
(
)
)
;
if
(
cropRect
.
Contains
(
newCropRect
)
)
{
cropRect
=
newCropRect
;
}
else
{
RefPtr
<
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
surface
=
CropAndCopyDataSourceSurface
(
dataSurface
cropRect
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
needToReportMemoryAllocation
=
true
;
cropRect
=
aCropRect
.
ref
(
)
;
}
}
}
return
CreateImageBitmapInternal
(
aGlobal
surface
Some
(
cropRect
)
aOptions
aImageBitmap
.
mWriteOnly
needToReportMemoryAllocation
false
aImageBitmap
.
mAlphaType
aRv
)
;
}
class
FulfillImageBitmapPromise
{
protected
:
FulfillImageBitmapPromise
(
Promise
*
aPromise
ImageBitmap
*
aImageBitmap
)
:
mPromise
(
aPromise
)
mImageBitmap
(
aImageBitmap
)
{
MOZ_ASSERT
(
aPromise
)
;
}
void
DoFulfillImageBitmapPromise
(
)
{
mPromise
-
>
MaybeResolve
(
mImageBitmap
)
;
}
private
:
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
ImageBitmap
>
mImageBitmap
;
}
;
class
FulfillImageBitmapPromiseTask
final
:
public
Runnable
public
FulfillImageBitmapPromise
{
public
:
FulfillImageBitmapPromiseTask
(
Promise
*
aPromise
ImageBitmap
*
aImageBitmap
)
:
Runnable
(
"
dom
:
:
FulfillImageBitmapPromiseTask
"
)
FulfillImageBitmapPromise
(
aPromise
aImageBitmap
)
{
}
NS_IMETHOD
Run
(
)
override
{
DoFulfillImageBitmapPromise
(
)
;
return
NS_OK
;
}
}
;
class
FulfillImageBitmapPromiseWorkerTask
final
:
public
WorkerSameThreadRunnable
public
FulfillImageBitmapPromise
{
public
:
FulfillImageBitmapPromiseWorkerTask
(
Promise
*
aPromise
ImageBitmap
*
aImageBitmap
)
:
WorkerSameThreadRunnable
(
GetCurrentThreadWorkerPrivate
(
)
)
FulfillImageBitmapPromise
(
aPromise
aImageBitmap
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
DoFulfillImageBitmapPromise
(
)
;
return
true
;
}
}
;
static
void
AsyncFulfillImageBitmapPromise
(
Promise
*
aPromise
ImageBitmap
*
aImageBitmap
)
{
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
task
=
new
FulfillImageBitmapPromiseTask
(
aPromise
aImageBitmap
)
;
NS_DispatchToCurrentThread
(
task
)
;
}
else
{
RefPtr
<
FulfillImageBitmapPromiseWorkerTask
>
task
=
new
FulfillImageBitmapPromiseWorkerTask
(
aPromise
aImageBitmap
)
;
task
-
>
Dispatch
(
)
;
}
}
class
CreateImageBitmapFromBlobRunnable
;
class
CreateImageBitmapFromBlob
final
:
public
DiscardableRunnable
public
imgIContainerCallback
public
nsIInputStreamCallback
{
friend
class
CreateImageBitmapFromBlobRunnable
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_IMGICONTAINERCALLBACK
NS_DECL_NSIINPUTSTREAMCALLBACK
static
already_AddRefed
<
CreateImageBitmapFromBlob
>
Create
(
Promise
*
aPromise
nsIGlobalObject
*
aGlobal
Blob
&
aBlob
const
Maybe
<
IntRect
>
&
aCropRect
nsIEventTarget
*
aMainThreadEventTarget
const
ImageBitmapOptions
&
aOptions
)
;
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
IsCurrentThread
(
)
)
;
nsresult
rv
=
StartMimeTypeAndDecodeAndCropBlob
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
rv
)
;
}
return
NS_OK
;
}
void
WorkerShuttingDown
(
)
;
private
:
CreateImageBitmapFromBlob
(
Promise
*
aPromise
nsIGlobalObject
*
aGlobal
already_AddRefed
<
nsIInputStream
>
aInputStream
const
Maybe
<
IntRect
>
&
aCropRect
nsIEventTarget
*
aMainThreadEventTarget
const
ImageBitmapOptions
&
aOptions
)
:
DiscardableRunnable
(
"
dom
:
:
CreateImageBitmapFromBlob
"
)
mMutex
(
"
dom
:
:
CreateImageBitmapFromBlob
:
:
mMutex
"
)
mPromise
(
aPromise
)
mGlobalObject
(
aGlobal
)
mInputStream
(
std
:
:
move
(
aInputStream
)
)
mCropRect
(
aCropRect
)
mMainThreadEventTarget
(
aMainThreadEventTarget
)
mOptions
(
aOptions
)
mThread
(
PR_GetCurrentThread
(
)
)
{
}
virtual
~
CreateImageBitmapFromBlob
(
)
=
default
;
bool
IsCurrentThread
(
)
const
{
return
mThread
=
=
PR_GetCurrentThread
(
)
;
}
nsresult
StartMimeTypeAndDecodeAndCropBlob
(
)
;
void
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
layers
:
:
Image
*
aImage
nsresult
aStatus
)
;
void
MimeTypeAndDecodeAndCropBlobCompletedOwningThread
(
layers
:
:
Image
*
aImage
nsresult
aStatus
)
;
nsresult
MimeTypeAndDecodeAndCropBlob
(
)
;
nsresult
DecodeAndCropBlob
(
const
nsACString
&
aMimeType
)
;
nsresult
GetMimeTypeSync
(
nsACString
&
aMimeType
)
;
nsresult
GetMimeTypeAsync
(
)
;
Mutex
mMutex
MOZ_UNANNOTATED
;
RefPtr
<
ThreadSafeWorkerRef
>
mWorkerRef
;
RefPtr
<
Promise
>
mPromise
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobalObject
;
nsCOMPtr
<
nsIInputStream
>
mInputStream
;
Maybe
<
IntRect
>
mCropRect
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
const
ImageBitmapOptions
mOptions
;
void
*
mThread
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
CreateImageBitmapFromBlob
DiscardableRunnable
imgIContainerCallback
nsIInputStreamCallback
)
class
CreateImageBitmapFromBlobRunnable
:
public
WorkerRunnable
{
public
:
explicit
CreateImageBitmapFromBlobRunnable
(
WorkerPrivate
*
aWorkerPrivate
CreateImageBitmapFromBlob
*
aTask
layers
:
:
Image
*
aImage
nsresult
aStatus
)
:
WorkerRunnable
(
aWorkerPrivate
)
mTask
(
aTask
)
mImage
(
aImage
)
mStatus
(
aStatus
)
{
}
bool
WorkerRun
(
JSContext
*
aCx
WorkerPrivate
*
aWorkerPrivate
)
override
{
mTask
-
>
MimeTypeAndDecodeAndCropBlobCompletedOwningThread
(
mImage
mStatus
)
;
return
true
;
}
private
:
RefPtr
<
CreateImageBitmapFromBlob
>
mTask
;
RefPtr
<
layers
:
:
Image
>
mImage
;
nsresult
mStatus
;
}
;
static
void
AsyncCreateImageBitmapFromBlob
(
Promise
*
aPromise
nsIGlobalObject
*
aGlobal
Blob
&
aBlob
const
Maybe
<
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
)
{
nsCOMPtr
<
nsIEventTarget
>
mainThreadEventTarget
;
if
(
NS_IsMainThread
(
)
)
{
mainThreadEventTarget
=
aGlobal
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
else
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
mainThreadEventTarget
=
workerPrivate
-
>
MainThreadEventTarget
(
)
;
}
RefPtr
<
CreateImageBitmapFromBlob
>
task
=
CreateImageBitmapFromBlob
:
:
Create
(
aPromise
aGlobal
aBlob
aCropRect
mainThreadEventTarget
aOptions
)
;
if
(
NS_WARN_IF
(
!
task
)
)
{
aPromise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
NS_DispatchToCurrentThread
(
task
)
;
}
already_AddRefed
<
Promise
>
ImageBitmap
:
:
Create
(
nsIGlobalObject
*
aGlobal
const
ImageBitmapSource
&
aSrc
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
const
ImageBitmapOptions
&
aOptions
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aGlobal
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
aGlobal
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
aCropRect
.
isSome
(
)
)
{
if
(
aCropRect
-
>
Width
(
)
=
=
0
)
{
aRv
.
ThrowRangeError
(
"
The
crop
rect
width
passed
to
createImageBitmap
must
be
nonzero
"
)
;
return
promise
.
forget
(
)
;
}
if
(
aCropRect
-
>
Height
(
)
=
=
0
)
{
aRv
.
ThrowRangeError
(
"
The
crop
rect
height
passed
to
createImageBitmap
must
be
nonzero
"
)
;
return
promise
.
forget
(
)
;
}
}
if
(
aOptions
.
mResizeWidth
.
WasPassed
(
)
&
&
aOptions
.
mResizeWidth
.
Value
(
)
=
=
0
)
{
aRv
.
ThrowInvalidStateError
(
"
The
resizeWidth
passed
to
createImageBitmap
must
be
nonzero
"
)
;
return
promise
.
forget
(
)
;
}
if
(
aOptions
.
mResizeHeight
.
WasPassed
(
)
&
&
aOptions
.
mResizeHeight
.
Value
(
)
=
=
0
)
{
aRv
.
ThrowInvalidStateError
(
"
The
resizeHeight
passed
to
createImageBitmap
must
be
nonzero
"
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
ImageBitmap
>
imageBitmap
;
if
(
aSrc
.
IsHTMLImageElement
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Creating
ImageBitmap
from
HTMLImageElement
off
the
main
thread
.
"
)
;
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsHTMLImageElement
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsSVGImageElement
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Creating
ImageBitmap
from
SVGImageElement
off
the
main
thread
.
"
)
;
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsSVGImageElement
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsHTMLVideoElement
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Creating
ImageBitmap
from
HTMLVideoElement
off
the
main
thread
.
"
)
;
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsHTMLVideoElement
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsHTMLCanvasElement
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Creating
ImageBitmap
from
HTMLCanvasElement
off
the
main
thread
.
"
)
;
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsHTMLCanvasElement
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsOffscreenCanvas
(
)
)
{
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsOffscreenCanvas
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsImageData
(
)
)
{
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsImageData
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsCanvasRenderingContext2D
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Creating
ImageBitmap
from
CanvasRenderingContext2D
off
the
"
"
main
thread
.
"
)
;
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsCanvasRenderingContext2D
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsImageBitmap
(
)
)
{
imageBitmap
=
CreateInternal
(
aGlobal
aSrc
.
GetAsImageBitmap
(
)
aCropRect
aOptions
aRv
)
;
}
else
if
(
aSrc
.
IsBlob
(
)
)
{
AsyncCreateImageBitmapFromBlob
(
promise
aGlobal
aSrc
.
GetAsBlob
(
)
aCropRect
aOptions
)
;
return
promise
.
forget
(
)
;
}
else
{
MOZ_CRASH
(
"
Unsupported
type
!
"
)
;
return
nullptr
;
}
if
(
!
aRv
.
Failed
(
)
)
{
AsyncFulfillImageBitmapPromise
(
promise
imageBitmap
)
;
}
return
promise
.
forget
(
)
;
}
JSObject
*
ImageBitmap
:
:
ReadStructuredClone
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
nsIGlobalObject
*
aParent
const
nsTArray
<
RefPtr
<
DataSourceSurface
>
>
&
aClonedSurfaces
uint32_t
aIndex
)
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aReader
)
;
uint32_t
picRectX_
;
uint32_t
picRectY_
;
uint32_t
picRectWidth_
;
uint32_t
picRectHeight_
;
uint32_t
alphaType_
;
uint32_t
writeOnly
;
if
(
!
JS_ReadUint32Pair
(
aReader
&
picRectX_
&
picRectY_
)
|
|
!
JS_ReadUint32Pair
(
aReader
&
picRectWidth_
&
picRectHeight_
)
|
|
!
JS_ReadUint32Pair
(
aReader
&
alphaType_
&
writeOnly
)
)
{
return
nullptr
;
}
int32_t
picRectX
=
BitwiseCast
<
int32_t
>
(
picRectX_
)
;
int32_t
picRectY
=
BitwiseCast
<
int32_t
>
(
picRectY_
)
;
int32_t
picRectWidth
=
BitwiseCast
<
int32_t
>
(
picRectWidth_
)
;
int32_t
picRectHeight
=
BitwiseCast
<
int32_t
>
(
picRectHeight_
)
;
const
auto
alphaType
=
BitwiseCast
<
gfxAlphaType
>
(
alphaType_
)
;
MOZ_ASSERT
(
!
aClonedSurfaces
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aIndex
<
aClonedSurfaces
.
Length
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
{
#
ifdef
FUZZING
if
(
aIndex
>
=
aClonedSurfaces
.
Length
(
)
)
{
return
nullptr
;
}
#
endif
RefPtr
<
layers
:
:
Image
>
img
=
CreateImageFromSurface
(
aClonedSurfaces
[
aIndex
]
)
;
RefPtr
<
ImageBitmap
>
imageBitmap
=
new
ImageBitmap
(
aParent
img
!
!
writeOnly
alphaType
)
;
ErrorResult
error
;
imageBitmap
-
>
SetPictureRect
(
IntRect
(
picRectX
picRectY
picRectWidth
picRectHeight
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
error
.
SuppressException
(
)
;
return
nullptr
;
}
if
(
!
GetOrCreateDOMReflector
(
aCx
imageBitmap
&
value
)
)
{
return
nullptr
;
}
imageBitmap
-
>
mAllocatedImageData
=
true
;
}
return
&
(
value
.
toObject
(
)
)
;
}
bool
ImageBitmap
:
:
WriteStructuredClone
(
JSStructuredCloneWriter
*
aWriter
nsTArray
<
RefPtr
<
DataSourceSurface
>
>
&
aClonedSurfaces
ImageBitmap
*
aImageBitmap
)
{
MOZ_ASSERT
(
aWriter
)
;
MOZ_ASSERT
(
aImageBitmap
)
;
if
(
!
aImageBitmap
-
>
mData
)
{
return
false
;
}
const
uint32_t
picRectX
=
BitwiseCast
<
uint32_t
>
(
aImageBitmap
-
>
mPictureRect
.
x
)
;
const
uint32_t
picRectY
=
BitwiseCast
<
uint32_t
>
(
aImageBitmap
-
>
mPictureRect
.
y
)
;
const
uint32_t
picRectWidth
=
BitwiseCast
<
uint32_t
>
(
aImageBitmap
-
>
mPictureRect
.
width
)
;
const
uint32_t
picRectHeight
=
BitwiseCast
<
uint32_t
>
(
aImageBitmap
-
>
mPictureRect
.
height
)
;
const
uint32_t
alphaType
=
BitwiseCast
<
uint32_t
>
(
aImageBitmap
-
>
mAlphaType
)
;
uint32_t
index
=
aClonedSurfaces
.
Length
(
)
;
if
(
NS_WARN_IF
(
!
JS_WriteUint32Pair
(
aWriter
SCTAG_DOM_IMAGEBITMAP
index
)
)
|
|
NS_WARN_IF
(
!
JS_WriteUint32Pair
(
aWriter
picRectX
picRectY
)
)
|
|
NS_WARN_IF
(
!
JS_WriteUint32Pair
(
aWriter
picRectWidth
picRectHeight
)
)
|
|
NS_WARN_IF
(
!
JS_WriteUint32Pair
(
aWriter
alphaType
aImageBitmap
-
>
mWriteOnly
)
)
)
{
return
false
;
}
RefPtr
<
SourceSurface
>
surface
=
aImageBitmap
-
>
mData
-
>
GetAsSourceSurface
(
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
return
false
;
}
RefPtr
<
DataSourceSurface
>
snapshot
=
surface
-
>
GetDataSurface
(
)
;
if
(
NS_WARN_IF
(
!
snapshot
)
)
{
return
false
;
}
RefPtr
<
DataSourceSurface
>
dstDataSurface
;
{
DataSourceSurface
:
:
ScopedMap
map
(
snapshot
DataSourceSurface
:
:
READ
)
;
if
(
NS_WARN_IF
(
!
map
.
IsMapped
(
)
)
)
{
return
false
;
}
dstDataSurface
=
Factory
:
:
CreateDataSourceSurfaceWithStride
(
snapshot
-
>
GetSize
(
)
snapshot
-
>
GetFormat
(
)
map
.
GetStride
(
)
true
)
;
}
if
(
NS_WARN_IF
(
!
dstDataSurface
)
)
{
return
false
;
}
Factory
:
:
CopyDataSourceSurface
(
snapshot
dstDataSurface
)
;
aClonedSurfaces
.
AppendElement
(
dstDataSurface
)
;
return
true
;
}
size_t
ImageBitmap
:
:
GetAllocatedSize
(
)
const
{
if
(
!
mAllocatedImageData
)
{
return
0
;
}
if
(
mData
-
>
GetFormat
(
)
=
=
mozilla
:
:
ImageFormat
:
:
PLANAR_YCBCR
)
{
return
mData
-
>
AsPlanarYCbCrImage
(
)
-
>
GetDataSize
(
)
;
}
if
(
mData
-
>
GetFormat
(
)
=
=
mozilla
:
:
ImageFormat
:
:
NV_IMAGE
)
{
return
mData
-
>
AsNVImage
(
)
-
>
GetBufferSize
(
)
;
}
RefPtr
<
SourceSurface
>
surface
=
mData
-
>
GetAsSourceSurface
(
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
return
0
;
}
const
int
bytesPerPixel
=
BytesPerPixel
(
surface
-
>
GetFormat
(
)
)
;
return
surface
-
>
GetSize
(
)
.
height
*
surface
-
>
GetSize
(
)
.
width
*
bytesPerPixel
;
}
size_t
BindingJSObjectMallocBytes
(
ImageBitmap
*
aBitmap
)
{
return
aBitmap
-
>
GetAllocatedSize
(
)
;
}
already_AddRefed
<
CreateImageBitmapFromBlob
>
CreateImageBitmapFromBlob
:
:
Create
(
Promise
*
aPromise
nsIGlobalObject
*
aGlobal
Blob
&
aBlob
const
Maybe
<
IntRect
>
&
aCropRect
nsIEventTarget
*
aMainThreadEventTarget
const
ImageBitmapOptions
&
aOptions
)
{
nsCOMPtr
<
nsIInputStream
>
stream
;
ErrorResult
error
;
aBlob
.
Impl
(
)
-
>
CreateInputStream
(
getter_AddRefs
(
stream
)
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
nullptr
;
}
if
(
!
NS_InputStreamIsBuffered
(
stream
)
)
{
nsCOMPtr
<
nsIInputStream
>
bufferedStream
;
nsresult
rv
=
NS_NewBufferedInputStream
(
getter_AddRefs
(
bufferedStream
)
stream
.
forget
(
)
4096
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
stream
=
bufferedStream
;
}
RefPtr
<
CreateImageBitmapFromBlob
>
task
=
new
CreateImageBitmapFromBlob
(
aPromise
aGlobal
stream
.
forget
(
)
aCropRect
aMainThreadEventTarget
aOptions
)
;
if
(
NS_IsMainThread
(
)
)
{
return
task
.
forget
(
)
;
}
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
RefPtr
<
StrongWorkerRef
>
workerRef
=
StrongWorkerRef
:
:
Create
(
workerPrivate
"
CreateImageBitmapFromBlob
"
[
task
]
(
)
{
task
-
>
WorkerShuttingDown
(
)
;
}
)
;
if
(
NS_WARN_IF
(
!
workerRef
)
)
{
return
nullptr
;
}
task
-
>
mWorkerRef
=
new
ThreadSafeWorkerRef
(
workerRef
)
;
return
task
.
forget
(
)
;
}
nsresult
CreateImageBitmapFromBlob
:
:
StartMimeTypeAndDecodeAndCropBlob
(
)
{
MOZ_ASSERT
(
IsCurrentThread
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
RefPtr
<
CreateImageBitmapFromBlob
>
self
=
this
;
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableFunction
(
"
CreateImageBitmapFromBlob
:
:
MimeTypeAndDecodeAndCropBlob
"
[
self
]
(
)
{
nsresult
rv
=
self
-
>
MimeTypeAndDecodeAndCropBlob
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
self
-
>
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
rv
)
;
}
}
)
;
return
mMainThreadEventTarget
-
>
Dispatch
(
r
.
forget
(
)
)
;
}
return
MimeTypeAndDecodeAndCropBlob
(
)
;
}
nsresult
CreateImageBitmapFromBlob
:
:
MimeTypeAndDecodeAndCropBlob
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsAutoCString
mimeType
;
nsresult
rv
=
GetMimeTypeSync
(
mimeType
)
;
if
(
rv
=
=
NS_BASE_STREAM_WOULD_BLOCK
)
{
return
GetMimeTypeAsync
(
)
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
DecodeAndCropBlob
(
mimeType
)
;
}
nsresult
CreateImageBitmapFromBlob
:
:
DecodeAndCropBlob
(
const
nsACString
&
aMimeType
)
{
nsCOMPtr
<
imgITools
>
imgtool
=
do_GetService
(
NS_IMGTOOLS_CID
)
;
if
(
NS_WARN_IF
(
!
imgtool
)
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
imgtool
-
>
DecodeImageAsync
(
mInputStream
aMimeType
this
mMainThreadEventTarget
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
static
nsresult
sniff_cb
(
nsIInputStream
*
aInputStream
void
*
aClosure
const
char
*
aFromRawSegment
uint32_t
aToOffset
uint32_t
aCount
uint32_t
*
aWriteCount
)
{
nsACString
*
mimeType
=
static_cast
<
nsACString
*
>
(
aClosure
)
;
MOZ_ASSERT
(
mimeType
)
;
if
(
aCount
>
0
)
{
imgLoader
:
:
GetMimeTypeFromContent
(
aFromRawSegment
aCount
*
mimeType
)
;
}
*
aWriteCount
=
0
;
return
NS_ERROR_FAILURE
;
}
nsresult
CreateImageBitmapFromBlob
:
:
GetMimeTypeSync
(
nsACString
&
aMimeType
)
{
uint32_t
dummy
;
return
mInputStream
-
>
ReadSegments
(
sniff_cb
&
aMimeType
128
&
dummy
)
;
}
nsresult
CreateImageBitmapFromBlob
:
:
GetMimeTypeAsync
(
)
{
nsCOMPtr
<
nsIAsyncInputStream
>
asyncInputStream
=
do_QueryInterface
(
mInputStream
)
;
if
(
NS_WARN_IF
(
!
asyncInputStream
)
)
{
return
NS_ERROR_FAILURE
;
}
return
asyncInputStream
-
>
AsyncWait
(
this
0
128
mMainThreadEventTarget
)
;
}
NS_IMETHODIMP
CreateImageBitmapFromBlob
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
{
nsresult
rv
=
MimeTypeAndDecodeAndCropBlob
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CreateImageBitmapFromBlob
:
:
OnImageReady
(
imgIContainer
*
aImgContainer
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
NS_FAILED
(
aStatus
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
aStatus
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
aImgContainer
)
;
uint32_t
frameFlags
=
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
uint32_t
whichFrame
=
imgIContainer
:
:
FRAME_FIRST
;
if
(
mOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
None
)
{
frameFlags
|
=
imgIContainer
:
:
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
;
}
if
(
mOptions
.
mColorSpaceConversion
=
=
ColorSpaceConversion
:
:
None
)
{
frameFlags
|
=
imgIContainer
:
:
FLAG_DECODE_NO_COLORSPACE_CONVERSION
;
}
RefPtr
<
SourceSurface
>
surface
=
aImgContainer
-
>
GetFrame
(
whichFrame
frameFlags
)
;
if
(
NS_WARN_IF
(
!
surface
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
NS_OK
;
}
RefPtr
<
SourceSurface
>
croppedSurface
=
surface
;
RefPtr
<
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
bool
copyRequired
=
mCropRect
.
isSome
(
)
|
|
mOptions
.
mImageOrientation
=
=
ImageOrientation
:
:
FlipY
;
if
(
copyRequired
)
{
IntRect
cropRect
=
mCropRect
.
isSome
(
)
?
mCropRect
.
ref
(
)
:
dataSurface
-
>
GetRect
(
)
;
croppedSurface
=
CropAndCopyDataSourceSurface
(
dataSurface
cropRect
)
;
if
(
NS_WARN_IF
(
!
croppedSurface
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
NS_OK
;
}
dataSurface
=
croppedSurface
-
>
GetDataSurface
(
)
;
if
(
mCropRect
.
isSome
(
)
)
{
mCropRect
-
>
SetRect
(
0
0
dataSurface
-
>
GetSize
(
)
.
width
dataSurface
-
>
GetSize
(
)
.
height
)
;
}
}
if
(
mOptions
.
mImageOrientation
=
=
ImageOrientation
:
:
FlipY
)
{
croppedSurface
=
FlipYDataSourceSurface
(
dataSurface
)
;
}
if
(
mOptions
.
mResizeWidth
.
WasPassed
(
)
|
|
mOptions
.
mResizeHeight
.
WasPassed
(
)
)
{
dataSurface
=
croppedSurface
-
>
GetDataSurface
(
)
;
croppedSurface
=
ScaleDataSourceSurface
(
dataSurface
mOptions
)
;
if
(
NS_WARN_IF
(
!
croppedSurface
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
NS_OK
;
}
if
(
mCropRect
.
isSome
(
)
)
{
mCropRect
-
>
SetRect
(
0
0
croppedSurface
-
>
GetSize
(
)
.
width
croppedSurface
-
>
GetSize
(
)
.
height
)
;
}
}
if
(
NS_WARN_IF
(
!
croppedSurface
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
NS_OK
;
}
RefPtr
<
layers
:
:
Image
>
image
=
CreateImageFromSurface
(
croppedSurface
)
;
if
(
NS_WARN_IF
(
!
image
)
)
{
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
nullptr
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
NS_OK
;
}
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
image
NS_OK
)
;
return
NS_OK
;
}
void
CreateImageBitmapFromBlob
:
:
MimeTypeAndDecodeAndCropBlobCompletedMainThread
(
layers
:
:
Image
*
aImage
nsresult
aStatus
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
IsCurrentThread
(
)
)
{
MutexAutoLock
lock
(
mMutex
)
;
if
(
!
mWorkerRef
)
{
return
;
}
RefPtr
<
CreateImageBitmapFromBlobRunnable
>
r
=
new
CreateImageBitmapFromBlobRunnable
(
mWorkerRef
-
>
Private
(
)
this
aImage
aStatus
)
;
r
-
>
Dispatch
(
)
;
return
;
}
MimeTypeAndDecodeAndCropBlobCompletedOwningThread
(
aImage
aStatus
)
;
}
void
CreateImageBitmapFromBlob
:
:
MimeTypeAndDecodeAndCropBlobCompletedOwningThread
(
layers
:
:
Image
*
aImage
nsresult
aStatus
)
{
MOZ_ASSERT
(
IsCurrentThread
(
)
)
;
if
(
!
mPromise
)
{
return
;
}
auto
raii
=
MakeScopeExit
(
[
&
]
{
mWorkerRef
=
nullptr
;
mPromise
=
nullptr
;
mGlobalObject
=
nullptr
;
}
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
aStatus
)
)
)
{
mPromise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
gfxAlphaType
alphaType
=
gfxAlphaType
:
:
Premult
;
if
(
mOptions
.
mPremultiplyAlpha
=
=
PremultiplyAlpha
:
:
None
)
{
alphaType
=
gfxAlphaType
:
:
NonPremult
;
}
RefPtr
<
ImageBitmap
>
imageBitmap
=
new
ImageBitmap
(
mGlobalObject
aImage
false
alphaType
)
;
if
(
mCropRect
.
isSome
(
)
)
{
ErrorResult
rv
;
imageBitmap
-
>
SetPictureRect
(
mCropRect
.
ref
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
mPromise
-
>
MaybeReject
(
std
:
:
move
(
rv
)
)
;
return
;
}
}
imageBitmap
-
>
mAllocatedImageData
=
true
;
mPromise
-
>
MaybeResolve
(
imageBitmap
)
;
}
void
CreateImageBitmapFromBlob
:
:
WorkerShuttingDown
(
)
{
MOZ_ASSERT
(
IsCurrentThread
(
)
)
;
MutexAutoLock
lock
(
mMutex
)
;
mWorkerRef
=
nullptr
;
mPromise
=
nullptr
;
mGlobalObject
=
nullptr
;
}
}
