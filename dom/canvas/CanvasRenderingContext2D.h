#
ifndef
CanvasRenderingContext2D_h
#
define
CanvasRenderingContext2D_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
<
vector
>
#
include
"
nsICanvasRenderingContextInternal
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLVideoElement
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BasicRenderingContext2D
.
h
"
#
include
"
mozilla
/
dom
/
CanvasGradient
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2DBinding
.
h
"
#
include
"
mozilla
/
dom
/
CanvasPattern
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
imgIEncoder
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
FilterSupport
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsBidi
.
h
"
class
gfxFontGroup
;
class
nsGlobalWindowInner
;
class
nsXULElement
;
namespace
mozilla
{
namespace
gl
{
class
SourceSurface
;
}
namespace
dom
{
class
HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap
;
typedef
HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap
CanvasImageSource
;
class
ImageBitmap
;
class
ImageData
;
class
StringOrCanvasGradientOrCanvasPattern
;
class
OwningStringOrCanvasGradientOrCanvasPattern
;
class
TextMetrics
;
class
CanvasPath
;
extern
const
mozilla
:
:
gfx
:
:
Float
SIGMA_MAX
;
template
<
typename
T
>
class
Optional
;
struct
CanvasBidiProcessor
;
class
CanvasRenderingContext2DUserData
;
class
CanvasDrawObserver
;
class
CanvasShutdownObserver
;
class
DOMMatrix
;
class
DOMMatrixReadOnly
;
struct
DOMMatrix2DInit
;
class
CanvasRenderingContext2D
final
:
public
nsICanvasRenderingContextInternal
public
nsWrapperCache
public
BasicRenderingContext2D
{
virtual
~
CanvasRenderingContext2D
(
)
;
public
:
explicit
CanvasRenderingContext2D
(
layers
:
:
LayersBackend
aCompositorBackend
)
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
HTMLCanvasElement
*
GetCanvas
(
)
const
{
if
(
!
mCanvasElement
|
|
mCanvasElement
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
return
mCanvasElement
-
>
GetOriginalCanvas
(
)
;
}
void
Save
(
)
override
;
void
Restore
(
)
override
;
void
Scale
(
double
aX
double
aY
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
Rotate
(
double
aAngle
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
Translate
(
double
aX
double
aY
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
Transform
(
double
aM11
double
aM12
double
aM21
double
aM22
double
aDx
double
aDy
mozilla
:
:
ErrorResult
&
aError
)
override
;
already_AddRefed
<
DOMMatrix
>
GetTransform
(
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
SetTransform
(
double
aM11
double
aM12
double
aM21
double
aM22
double
aDx
double
aDy
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
SetTransform
(
const
DOMMatrix2DInit
&
aInit
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
ResetTransform
(
mozilla
:
:
ErrorResult
&
aError
)
override
;
double
GlobalAlpha
(
)
override
{
return
CurrentState
(
)
.
globalAlpha
;
}
static
mozilla
:
:
gfx
:
:
Float
ToFloat
(
double
aValue
)
{
return
mozilla
:
:
gfx
:
:
Float
(
aValue
)
;
}
void
SetGlobalAlpha
(
double
aGlobalAlpha
)
override
{
if
(
aGlobalAlpha
>
=
0
.
0
&
&
aGlobalAlpha
<
=
1
.
0
)
{
CurrentState
(
)
.
globalAlpha
=
ToFloat
(
aGlobalAlpha
)
;
}
}
void
GetGlobalCompositeOperation
(
nsAString
&
aOp
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
SetGlobalCompositeOperation
(
const
nsAString
&
aOp
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
GetStrokeStyle
(
OwningStringOrCanvasGradientOrCanvasPattern
&
aValue
)
override
{
GetStyleAsUnion
(
aValue
Style
:
:
STROKE
)
;
}
void
SetStrokeStyle
(
const
StringOrCanvasGradientOrCanvasPattern
&
aValue
)
override
{
SetStyleFromUnion
(
aValue
Style
:
:
STROKE
)
;
}
void
GetFillStyle
(
OwningStringOrCanvasGradientOrCanvasPattern
&
aValue
)
override
{
GetStyleAsUnion
(
aValue
Style
:
:
FILL
)
;
}
void
SetFillStyle
(
const
StringOrCanvasGradientOrCanvasPattern
&
aValue
)
override
{
SetStyleFromUnion
(
aValue
Style
:
:
FILL
)
;
}
already_AddRefed
<
CanvasGradient
>
CreateLinearGradient
(
double
aX0
double
aY0
double
aX1
double
aY1
)
override
;
already_AddRefed
<
CanvasGradient
>
CreateRadialGradient
(
double
aX0
double
aY0
double
aR0
double
aX1
double
aY1
double
aR1
ErrorResult
&
aError
)
override
;
already_AddRefed
<
CanvasPattern
>
CreatePattern
(
const
CanvasImageSource
&
aElement
const
nsAString
&
aRepeat
ErrorResult
&
aError
)
override
;
double
ShadowOffsetX
(
)
override
{
return
CurrentState
(
)
.
shadowOffset
.
x
;
}
void
SetShadowOffsetX
(
double
aShadowOffsetX
)
override
{
CurrentState
(
)
.
shadowOffset
.
x
=
ToFloat
(
aShadowOffsetX
)
;
}
double
ShadowOffsetY
(
)
override
{
return
CurrentState
(
)
.
shadowOffset
.
y
;
}
void
SetShadowOffsetY
(
double
aShadowOffsetY
)
override
{
CurrentState
(
)
.
shadowOffset
.
y
=
ToFloat
(
aShadowOffsetY
)
;
}
double
ShadowBlur
(
)
override
{
return
CurrentState
(
)
.
shadowBlur
;
}
void
SetShadowBlur
(
double
aShadowBlur
)
override
{
if
(
aShadowBlur
>
=
0
.
0
)
{
CurrentState
(
)
.
shadowBlur
=
ToFloat
(
aShadowBlur
)
;
}
}
void
GetShadowColor
(
nsAString
&
aShadowColor
)
override
{
StyleColorToString
(
CurrentState
(
)
.
shadowColor
aShadowColor
)
;
}
void
GetFilter
(
nsAString
&
aFilter
)
{
aFilter
=
CurrentState
(
)
.
filterString
;
}
void
SetShadowColor
(
const
nsAString
&
aShadowColor
)
override
;
void
SetFilter
(
const
nsAString
&
aFilter
mozilla
:
:
ErrorResult
&
aError
)
;
void
ClearRect
(
double
aX
double
aY
double
aW
double
aH
)
override
;
void
FillRect
(
double
aX
double
aY
double
aW
double
aH
)
override
;
void
StrokeRect
(
double
aX
double
aY
double
aW
double
aH
)
override
;
void
BeginPath
(
)
;
void
Fill
(
const
CanvasWindingRule
&
aWinding
)
;
void
Fill
(
const
CanvasPath
&
aPath
const
CanvasWindingRule
&
aWinding
)
;
void
Stroke
(
)
;
void
Stroke
(
const
CanvasPath
&
aPath
)
;
void
DrawFocusIfNeeded
(
mozilla
:
:
dom
:
:
Element
&
aElement
ErrorResult
&
aRv
)
;
bool
DrawCustomFocusRing
(
mozilla
:
:
dom
:
:
Element
&
aElement
)
;
void
Clip
(
const
CanvasWindingRule
&
aWinding
)
;
void
Clip
(
const
CanvasPath
&
aPath
const
CanvasWindingRule
&
aWinding
)
;
bool
IsPointInPath
(
JSContext
*
aCx
double
aX
double
aY
const
CanvasWindingRule
&
aWinding
nsIPrincipal
&
aSubjectPrincipal
)
;
bool
IsPointInPath
(
JSContext
*
aCx
const
CanvasPath
&
aPath
double
aX
double
aY
const
CanvasWindingRule
&
aWinding
nsIPrincipal
&
)
;
bool
IsPointInStroke
(
JSContext
*
aCx
double
aX
double
aY
nsIPrincipal
&
aSubjectPrincipal
)
;
bool
IsPointInStroke
(
JSContext
*
aCx
const
CanvasPath
&
aPath
double
aX
double
aY
nsIPrincipal
&
)
;
void
FillText
(
const
nsAString
&
aText
double
aX
double
aY
const
Optional
<
double
>
&
aMaxWidth
mozilla
:
:
ErrorResult
&
aError
)
;
void
StrokeText
(
const
nsAString
&
aText
double
aX
double
aY
const
Optional
<
double
>
&
aMaxWidth
mozilla
:
:
ErrorResult
&
aError
)
;
TextMetrics
*
MeasureText
(
const
nsAString
&
aRawText
mozilla
:
:
ErrorResult
&
aError
)
;
void
AddHitRegion
(
const
HitRegionOptions
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
void
RemoveHitRegion
(
const
nsAString
&
aId
)
;
void
ClearHitRegions
(
)
;
void
DrawImage
(
const
CanvasImageSource
&
aImage
double
aDx
double
aDy
mozilla
:
:
ErrorResult
&
aError
)
override
{
DrawImage
(
aImage
0
.
0
0
.
0
0
.
0
0
.
0
aDx
aDy
0
.
0
0
.
0
0
aError
)
;
}
void
DrawImage
(
const
CanvasImageSource
&
aImage
double
aDx
double
aDy
double
aDw
double
aDh
mozilla
:
:
ErrorResult
&
aError
)
override
{
DrawImage
(
aImage
0
.
0
0
.
0
0
.
0
0
.
0
aDx
aDy
aDw
aDh
2
aError
)
;
}
void
DrawImage
(
const
CanvasImageSource
&
aImage
double
aSx
double
aSy
double
aSw
double
aSh
double
aDx
double
aDy
double
aDw
double
aDh
mozilla
:
:
ErrorResult
&
aError
)
override
{
DrawImage
(
aImage
aSx
aSy
aSw
aSh
aDx
aDy
aDw
aDh
6
aError
)
;
}
already_AddRefed
<
ImageData
>
CreateImageData
(
JSContext
*
aCx
double
aSw
double
aSh
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
ImageData
>
CreateImageData
(
JSContext
*
aCx
ImageData
&
aImagedata
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
ImageData
>
GetImageData
(
JSContext
*
aCx
double
aSx
double
aSy
double
aSw
double
aSh
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
PutImageData
(
ImageData
&
aImageData
double
aDx
double
aDy
mozilla
:
:
ErrorResult
&
aError
)
;
void
PutImageData
(
ImageData
&
aImageData
double
aDx
double
aDy
double
aDirtyX
double
aDirtyY
double
aDirtyWidth
double
aDirtyHeight
mozilla
:
:
ErrorResult
&
aError
)
;
double
LineWidth
(
)
override
{
return
CurrentState
(
)
.
lineWidth
;
}
void
SetLineWidth
(
double
aWidth
)
override
{
if
(
aWidth
>
0
.
0
)
{
CurrentState
(
)
.
lineWidth
=
ToFloat
(
aWidth
)
;
}
}
void
GetLineCap
(
nsAString
&
aLinecapStyle
)
override
;
void
SetLineCap
(
const
nsAString
&
aLinecapStyle
)
override
;
void
GetLineJoin
(
nsAString
&
aLinejoinStyle
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
SetLineJoin
(
const
nsAString
&
aLinejoinStyle
)
override
;
double
MiterLimit
(
)
override
{
return
CurrentState
(
)
.
miterLimit
;
}
void
SetMiterLimit
(
double
aMiter
)
override
{
if
(
aMiter
>
0
.
0
)
{
CurrentState
(
)
.
miterLimit
=
ToFloat
(
aMiter
)
;
}
}
void
GetFont
(
nsAString
&
aFont
)
{
aFont
=
GetFont
(
)
;
}
void
SetFont
(
const
nsAString
&
aFont
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetTextAlign
(
nsAString
&
aTextAlign
)
;
void
SetTextAlign
(
const
nsAString
&
aTextAlign
)
;
void
GetTextBaseline
(
nsAString
&
aTextBaseline
)
;
void
SetTextBaseline
(
const
nsAString
&
aTextBaseline
)
;
void
ClosePath
(
)
override
{
EnsureWritablePath
(
)
;
if
(
mPathBuilder
)
{
mPathBuilder
-
>
Close
(
)
;
}
else
{
mDSPathBuilder
-
>
Close
(
)
;
}
}
void
MoveTo
(
double
aX
double
aY
)
override
{
EnsureWritablePath
(
)
;
if
(
mPathBuilder
)
{
mPathBuilder
-
>
MoveTo
(
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
else
{
mDSPathBuilder
-
>
MoveTo
(
mTarget
-
>
GetTransform
(
)
.
TransformPoint
(
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
)
;
}
}
void
LineTo
(
double
aX
double
aY
)
override
{
EnsureWritablePath
(
)
;
LineTo
(
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
void
QuadraticCurveTo
(
double
aCpx
double
aCpy
double
aX
double
aY
)
override
{
EnsureWritablePath
(
)
;
if
(
mPathBuilder
)
{
mPathBuilder
-
>
QuadraticBezierTo
(
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aCpx
)
ToFloat
(
aCpy
)
)
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
else
{
mozilla
:
:
gfx
:
:
Matrix
transform
=
mTarget
-
>
GetTransform
(
)
;
mDSPathBuilder
-
>
QuadraticBezierTo
(
transform
.
TransformPoint
(
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aCpx
)
ToFloat
(
aCpy
)
)
)
transform
.
TransformPoint
(
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
)
;
}
}
void
BezierCurveTo
(
double
aCp1x
double
aCp1y
double
aCp2x
double
aCp2y
double
aX
double
aY
)
override
{
EnsureWritablePath
(
)
;
BezierTo
(
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aCp1x
)
ToFloat
(
aCp1y
)
)
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aCp2x
)
ToFloat
(
aCp2y
)
)
mozilla
:
:
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
void
ArcTo
(
double
aX1
double
aY1
double
aX2
double
aY2
double
aRadius
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
Rect
(
double
aX
double
aY
double
aW
double
aH
)
override
;
void
Arc
(
double
aX
double
aY
double
aRadius
double
aStartAngle
double
aEndAngle
bool
aAnticlockwise
mozilla
:
:
ErrorResult
&
aError
)
override
;
void
Ellipse
(
double
aX
double
aY
double
aRadiusX
double
aRadiusY
double
aRotation
double
aStartAngle
double
aEndAngle
bool
aAnticlockwise
ErrorResult
&
aError
)
override
;
void
GetMozCurrentTransform
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetMozCurrentTransform
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCurrentTransform
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetMozCurrentTransformInverse
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetMozCurrentTransformInverse
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCurrentTransform
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetFillRule
(
nsAString
&
aFillRule
)
;
void
SetFillRule
(
const
nsAString
&
aFillRule
)
;
void
SetLineDash
(
const
Sequence
<
double
>
&
aSegments
mozilla
:
:
ErrorResult
&
aRv
)
override
;
void
GetLineDash
(
nsTArray
<
double
>
&
aSegments
)
const
override
;
void
SetLineDashOffset
(
double
aOffset
)
override
;
double
LineDashOffset
(
)
const
override
;
void
GetMozTextStyle
(
nsAString
&
aMozTextStyle
)
{
GetFont
(
aMozTextStyle
)
;
}
void
SetMozTextStyle
(
const
nsAString
&
aMozTextStyle
mozilla
:
:
ErrorResult
&
aError
)
{
SetFont
(
aMozTextStyle
aError
)
;
}
bool
ImageSmoothingEnabled
(
)
override
{
return
CurrentState
(
)
.
imageSmoothingEnabled
;
}
void
SetImageSmoothingEnabled
(
bool
aImageSmoothingEnabled
)
override
{
if
(
aImageSmoothingEnabled
!
=
CurrentState
(
)
.
imageSmoothingEnabled
)
{
CurrentState
(
)
.
imageSmoothingEnabled
=
aImageSmoothingEnabled
;
}
}
void
DrawWindow
(
nsGlobalWindowInner
&
aWindow
double
aX
double
aY
double
aW
double
aH
const
nsAString
&
aBgColor
uint32_t
aFlags
mozilla
:
:
ErrorResult
&
aError
)
;
void
Demote
(
)
;
nsresult
Redraw
(
)
;
gfx
:
:
IntSize
GetSize
(
)
const
{
return
gfx
:
:
IntSize
(
mWidth
mHeight
)
;
}
virtual
int32_t
GetWidth
(
)
override
{
return
GetSize
(
)
.
width
;
}
virtual
int32_t
GetHeight
(
)
override
{
return
GetSize
(
)
.
height
;
}
PresShell
*
GetPresShell
(
)
final
{
if
(
mCanvasElement
)
{
return
mCanvasElement
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
}
if
(
mDocShell
)
{
return
mDocShell
-
>
GetPresShell
(
)
;
}
return
nullptr
;
}
NS_IMETHOD
SetDimensions
(
int32_t
aWidth
int32_t
aHeight
)
override
;
NS_IMETHOD
InitializeWithDrawTarget
(
nsIDocShell
*
aShell
NotNull
<
gfx
:
:
DrawTarget
*
>
aTarget
)
override
;
NS_IMETHOD
GetInputStream
(
const
char
*
aMimeType
const
nsAString
&
aEncoderOptions
nsIInputStream
*
*
aStream
)
override
;
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
GetSurfaceSnapshot
(
gfxAlphaType
*
aOutAlphaType
=
nullptr
)
override
;
virtual
void
SetOpaqueValueFromOpaqueAttr
(
bool
aOpaqueAttrValue
)
override
;
bool
GetIsOpaque
(
)
override
{
return
mOpaque
;
}
NS_IMETHOD
Reset
(
)
override
;
already_AddRefed
<
Layer
>
GetCanvasLayer
(
nsDisplayListBuilder
*
aBuilder
Layer
*
aOldLayer
LayerManager
*
aManager
)
override
;
bool
UpdateWebRenderCanvasData
(
nsDisplayListBuilder
*
aBuilder
WebRenderCanvasData
*
aCanvasData
)
override
;
bool
InitializeCanvasRenderer
(
nsDisplayListBuilder
*
aBuilder
CanvasRenderer
*
aRenderer
)
override
;
virtual
bool
ShouldForceInactiveLayer
(
LayerManager
*
aManager
)
override
;
void
MarkContextClean
(
)
override
;
void
MarkContextCleanForFrameCapture
(
)
override
;
bool
IsContextCleanForFrameCapture
(
)
override
;
NS_IMETHOD
SetIsIPC
(
bool
aIsIPC
)
override
;
void
Redraw
(
const
mozilla
:
:
gfx
:
:
Rect
&
aR
)
;
NS_IMETHOD
Redraw
(
const
gfxRect
&
aR
)
override
{
Redraw
(
ToRect
(
aR
)
)
;
return
NS_OK
;
}
NS_IMETHOD
SetContextOptions
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aOptions
ErrorResult
&
aRvForDictionaryInit
)
override
;
virtual
void
DidRefresh
(
)
override
;
void
RedrawUser
(
const
gfxRect
&
aR
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS
(
CanvasRenderingContext2D
)
enum
class
CanvasMultiGetterType
:
uint8_t
{
STRING
=
0
PATTERN
=
1
GRADIENT
=
2
}
;
enum
class
Style
:
uint8_t
{
STROKE
=
0
FILL
MAX
}
;
nsINode
*
GetParentObject
(
)
{
return
mCanvasElement
;
}
void
LineTo
(
const
mozilla
:
:
gfx
:
:
Point
&
aPoint
)
{
if
(
mPathBuilder
)
{
mPathBuilder
-
>
LineTo
(
aPoint
)
;
}
else
{
mDSPathBuilder
-
>
LineTo
(
mTarget
-
>
GetTransform
(
)
.
TransformPoint
(
aPoint
)
)
;
}
}
void
BezierTo
(
const
mozilla
:
:
gfx
:
:
Point
&
aCP1
const
mozilla
:
:
gfx
:
:
Point
&
aCP2
const
mozilla
:
:
gfx
:
:
Point
&
aCP3
)
{
if
(
mPathBuilder
)
{
mPathBuilder
-
>
BezierTo
(
aCP1
aCP2
aCP3
)
;
}
else
{
mozilla
:
:
gfx
:
:
Matrix
transform
=
mTarget
-
>
GetTransform
(
)
;
mDSPathBuilder
-
>
BezierTo
(
transform
.
TransformPoint
(
aCP1
)
transform
.
TransformPoint
(
aCP2
)
transform
.
TransformPoint
(
aCP3
)
)
;
}
}
friend
class
CanvasRenderingContext2DUserData
;
virtual
UniquePtr
<
uint8_t
[
]
>
GetImageBuffer
(
int32_t
*
aFormat
)
override
;
nsString
GetHitRegion
(
const
mozilla
:
:
gfx
:
:
Point
&
aPoint
)
override
;
bool
GetHitRegionRect
(
Element
*
aElement
nsRect
&
aRect
)
override
;
void
OnShutdown
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
UpdateFilter
(
)
;
protected
:
nsresult
GetImageDataArray
(
JSContext
*
aCx
int32_t
aX
int32_t
aY
uint32_t
aWidth
uint32_t
aHeight
nsIPrincipal
&
aSubjectPrincipal
JSObject
*
*
aRetval
)
;
nsresult
PutImageData_explicit
(
int32_t
aX
int32_t
aY
uint32_t
aW
uint32_t
aH
dom
:
:
Uint8ClampedArray
*
aArray
bool
aHasDirtyRect
int32_t
aDirtyX
int32_t
aDirtyY
int32_t
aDirtyWidth
int32_t
aDirtyHeight
)
;
bool
CopyBufferProvider
(
layers
:
:
PersistentBufferProvider
&
aOld
gfx
:
:
DrawTarget
&
aTarget
gfx
:
:
IntRect
aCopyRect
)
;
nsresult
Initialize
(
int32_t
aWidth
int32_t
aHeight
)
;
nsresult
InitializeWithTarget
(
mozilla
:
:
gfx
:
:
DrawTarget
*
aSurface
int32_t
aWidth
int32_t
aHeight
)
;
static
uintptr_t
sNumLivingContexts
;
static
mozilla
:
:
gfx
:
:
DrawTarget
*
sErrorTarget
;
void
SetTransformInternal
(
const
mozilla
:
:
gfx
:
:
Matrix
&
aTransform
)
;
void
SetStyleFromUnion
(
const
StringOrCanvasGradientOrCanvasPattern
&
aValue
Style
aWhichStyle
)
;
void
SetStyleFromString
(
const
nsAString
&
aStr
Style
aWhichStyle
)
;
void
SetStyleFromGradient
(
CanvasGradient
&
aGradient
Style
aWhichStyle
)
{
CurrentState
(
)
.
SetGradientStyle
(
aWhichStyle
&
aGradient
)
;
}
void
SetStyleFromPattern
(
CanvasPattern
&
aPattern
Style
aWhichStyle
)
{
CurrentState
(
)
.
SetPatternStyle
(
aWhichStyle
&
aPattern
)
;
}
void
GetStyleAsUnion
(
OwningStringOrCanvasGradientOrCanvasPattern
&
aValue
Style
aWhichStyle
)
;
bool
ParseColor
(
const
nsAString
&
aString
nscolor
*
aColor
)
;
static
void
StyleColorToString
(
const
nscolor
&
aColor
nsAString
&
aStr
)
;
bool
ParseFilter
(
const
nsAString
&
aString
StyleOwnedSlice
<
StyleFilter
>
&
aFilterChain
ErrorResult
&
aError
)
;
bool
SetFontInternal
(
const
nsAString
&
aFont
mozilla
:
:
ErrorResult
&
aError
)
;
void
UpdateIsOpaque
(
)
;
static
void
EnsureErrorTarget
(
)
;
void
EnsureWritablePath
(
)
;
void
EnsureUserSpacePath
(
const
CanvasWindingRule
&
aWinding
=
CanvasWindingRule
:
:
Nonzero
)
;
void
TransformWillUpdate
(
)
;
void
FillRuleChanged
(
)
;
bool
EnsureTarget
(
const
gfx
:
:
Rect
*
aCoveredRect
=
nullptr
bool
aWillClear
=
false
)
;
void
RestoreClipsAndTransformToTarget
(
)
;
bool
TrySharedTarget
(
RefPtr
<
gfx
:
:
DrawTarget
>
&
aOutDT
RefPtr
<
layers
:
:
PersistentBufferProvider
>
&
aOutProvider
)
;
bool
TryBasicTarget
(
RefPtr
<
gfx
:
:
DrawTarget
>
&
aOutDT
RefPtr
<
layers
:
:
PersistentBufferProvider
>
&
aOutProvider
)
;
void
RegisterAllocation
(
)
;
void
SetInitialState
(
)
;
void
SetErrorState
(
)
;
void
OnStableState
(
)
;
void
ScheduleStableStateCallback
(
)
;
void
ClearTarget
(
int32_t
aWidth
=
-
1
int32_t
aHeight
=
-
1
)
;
void
ReturnTarget
(
bool
aForceReset
=
false
)
;
bool
IsTargetValid
(
)
const
{
return
!
!
mTarget
&
&
mTarget
!
=
sErrorTarget
;
}
mozilla
:
:
gfx
:
:
SurfaceFormat
GetSurfaceFormat
(
)
const
;
bool
PatternIsOpaque
(
Style
aStyle
bool
*
aIsColor
=
nullptr
)
const
;
nsLayoutUtils
:
:
SurfaceFromElementResult
CachedSurfaceFromElement
(
Element
*
aElement
)
;
void
DrawImage
(
const
CanvasImageSource
&
aImgElt
double
aSx
double
aSy
double
aSw
double
aSh
double
aDx
double
aDy
double
aDw
double
aDh
uint8_t
aOptional_argc
mozilla
:
:
ErrorResult
&
aError
)
;
void
DrawDirectlyToCanvas
(
const
nsLayoutUtils
:
:
DirectDrawInfo
&
aImage
mozilla
:
:
gfx
:
:
Rect
*
aBounds
mozilla
:
:
gfx
:
:
Rect
aDest
mozilla
:
:
gfx
:
:
Rect
aSrc
gfx
:
:
IntSize
aImgSize
)
;
nsString
&
GetFont
(
)
{
GetCurrentFontStyle
(
)
;
return
CurrentState
(
)
.
font
;
}
int32_t
mWidth
mHeight
;
bool
mZero
;
bool
mOpaqueAttrValue
;
bool
mContextAttributesHasAlpha
;
bool
mOpaque
;
bool
mResetLayer
;
bool
mIPC
;
bool
mHasPendingStableStateCallback
;
nsTArray
<
CanvasRenderingContext2DUserData
*
>
mUserDatas
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
mozilla
:
:
gfx
:
:
DrawTarget
>
mTarget
;
RefPtr
<
mozilla
:
:
layers
:
:
PersistentBufferProvider
>
mBufferProvider
;
RefPtr
<
CanvasShutdownObserver
>
mShutdownObserver
;
void
RemoveShutdownObserver
(
)
;
bool
AlreadyShutDown
(
)
const
{
return
!
mShutdownObserver
;
}
bool
mIsEntireFrameInvalid
;
bool
mPredictManyRedrawCalls
;
bool
mIsCapturedFrameInvalid
;
RefPtr
<
mozilla
:
:
gfx
:
:
Path
>
mPath
;
RefPtr
<
mozilla
:
:
gfx
:
:
PathBuilder
>
mDSPathBuilder
;
RefPtr
<
mozilla
:
:
gfx
:
:
PathBuilder
>
mPathBuilder
;
bool
mPathTransformWillUpdate
;
mozilla
:
:
gfx
:
:
Matrix
mPathToDS
;
uint32_t
mInvalidateCount
;
static
const
uint32_t
kCanvasMaxInvalidateCount
=
100
;
struct
RegionInfo
{
nsString
mId
;
RefPtr
<
Element
>
mElement
;
RefPtr
<
gfx
:
:
Path
>
mPath
;
}
;
nsTArray
<
RegionInfo
>
mHitRegionsOptions
;
nsBidi
mBidiEngine
;
bool
NeedToDrawShadow
(
)
{
const
ContextState
&
state
=
CurrentState
(
)
;
return
NS_GET_A
(
state
.
shadowColor
)
!
=
0
&
&
(
state
.
shadowBlur
!
=
0
.
f
|
|
state
.
shadowOffset
.
x
!
=
0
.
f
|
|
state
.
shadowOffset
.
y
!
=
0
.
f
)
;
}
bool
NeedToApplyFilter
(
)
{
return
EnsureUpdatedFilter
(
)
.
mPrimitives
.
Length
(
)
>
0
;
}
const
gfx
:
:
FilterDescription
&
EnsureUpdatedFilter
(
)
{
bool
isWriteOnly
=
mCanvasElement
&
&
mCanvasElement
-
>
IsWriteOnly
(
)
;
if
(
CurrentState
(
)
.
filterSourceGraphicTainted
!
=
isWriteOnly
)
{
UpdateFilter
(
)
;
EnsureTarget
(
)
;
}
MOZ_ASSERT
(
CurrentState
(
)
.
filterSourceGraphicTainted
=
=
isWriteOnly
)
;
return
CurrentState
(
)
.
filter
;
}
bool
NeedToCalculateBounds
(
)
{
return
NeedToDrawShadow
(
)
|
|
NeedToApplyFilter
(
)
;
}
mozilla
:
:
gfx
:
:
CompositionOp
UsedOperation
(
)
{
if
(
NeedToDrawShadow
(
)
|
|
NeedToApplyFilter
(
)
)
{
return
mozilla
:
:
gfx
:
:
CompositionOp
:
:
OP_OVER
;
}
return
CurrentState
(
)
.
op
;
}
protected
:
enum
class
TextAlign
:
uint8_t
{
START
END
LEFT
RIGHT
CENTER
}
;
enum
class
TextBaseline
:
uint8_t
{
TOP
HANGING
MIDDLE
ALPHABETIC
IDEOGRAPHIC
BOTTOM
}
;
enum
class
TextDrawOperation
:
uint8_t
{
FILL
STROKE
MEASURE
}
;
protected
:
gfxFontGroup
*
GetCurrentFontStyle
(
)
;
nsresult
DrawOrMeasureText
(
const
nsAString
&
aText
float
aX
float
aY
const
Optional
<
double
>
&
aMaxWidth
TextDrawOperation
aOp
float
*
aWidth
)
;
struct
ClipState
{
explicit
ClipState
(
mozilla
:
:
gfx
:
:
Path
*
aClip
)
:
clip
(
aClip
)
{
}
explicit
ClipState
(
const
mozilla
:
:
gfx
:
:
Matrix
&
aTransform
)
:
transform
(
aTransform
)
{
}
bool
IsClip
(
)
const
{
return
!
!
clip
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
Path
>
clip
;
mozilla
:
:
gfx
:
:
Matrix
transform
;
}
;
class
ContextState
{
public
:
ContextState
(
)
;
ContextState
(
const
ContextState
&
aOther
)
;
~
ContextState
(
)
;
void
SetColorStyle
(
Style
aWhichStyle
nscolor
aColor
)
{
colorStyles
[
aWhichStyle
]
=
aColor
;
gradientStyles
[
aWhichStyle
]
=
nullptr
;
patternStyles
[
aWhichStyle
]
=
nullptr
;
}
void
SetPatternStyle
(
Style
aWhichStyle
CanvasPattern
*
aPat
)
{
gradientStyles
[
aWhichStyle
]
=
nullptr
;
patternStyles
[
aWhichStyle
]
=
aPat
;
}
void
SetGradientStyle
(
Style
aWhichStyle
CanvasGradient
*
aGrad
)
{
gradientStyles
[
aWhichStyle
]
=
aGrad
;
patternStyles
[
aWhichStyle
]
=
nullptr
;
}
bool
StyleIsColor
(
Style
aWhichStyle
)
const
{
return
!
(
patternStyles
[
aWhichStyle
]
|
|
gradientStyles
[
aWhichStyle
]
)
;
}
int32_t
ShadowBlurRadius
(
)
const
{
static
const
gfxFloat
GAUSSIAN_SCALE_FACTOR
=
(
3
*
sqrt
(
2
*
M_PI
)
/
4
)
*
1
.
5
;
return
(
int32_t
)
floor
(
ShadowBlurSigma
(
)
*
GAUSSIAN_SCALE_FACTOR
+
0
.
5
)
;
}
mozilla
:
:
gfx
:
:
Float
ShadowBlurSigma
(
)
const
{
return
std
:
:
min
(
SIGMA_MAX
shadowBlur
/
2
.
0f
)
;
}
nsTArray
<
ClipState
>
clipsAndTransforms
;
RefPtr
<
gfxFontGroup
>
fontGroup
;
RefPtr
<
nsAtom
>
fontLanguage
;
nsFont
fontFont
;
EnumeratedArray
<
Style
Style
:
:
MAX
RefPtr
<
CanvasGradient
>
>
gradientStyles
;
EnumeratedArray
<
Style
Style
:
:
MAX
RefPtr
<
CanvasPattern
>
>
patternStyles
;
EnumeratedArray
<
Style
Style
:
:
MAX
nscolor
>
colorStyles
;
nsString
font
;
TextAlign
textAlign
=
TextAlign
:
:
START
;
TextBaseline
textBaseline
=
TextBaseline
:
:
ALPHABETIC
;
nscolor
shadowColor
=
0
;
mozilla
:
:
gfx
:
:
Matrix
transform
;
mozilla
:
:
gfx
:
:
Point
shadowOffset
;
mozilla
:
:
gfx
:
:
Float
lineWidth
=
1
.
0f
;
mozilla
:
:
gfx
:
:
Float
miterLimit
=
10
.
0f
;
mozilla
:
:
gfx
:
:
Float
globalAlpha
=
1
.
0f
;
mozilla
:
:
gfx
:
:
Float
shadowBlur
=
0
.
0f
;
nsTArray
<
mozilla
:
:
gfx
:
:
Float
>
dash
;
mozilla
:
:
gfx
:
:
Float
dashOffset
=
0
.
0f
;
mozilla
:
:
gfx
:
:
CompositionOp
op
=
mozilla
:
:
gfx
:
:
CompositionOp
:
:
OP_OVER
;
mozilla
:
:
gfx
:
:
FillRule
fillRule
=
mozilla
:
:
gfx
:
:
FillRule
:
:
FILL_WINDING
;
mozilla
:
:
gfx
:
:
CapStyle
lineCap
=
mozilla
:
:
gfx
:
:
CapStyle
:
:
BUTT
;
mozilla
:
:
gfx
:
:
JoinStyle
lineJoin
=
mozilla
:
:
gfx
:
:
JoinStyle
:
:
MITER_OR_BEVEL
;
nsString
filterString
=
nsString
(
u
"
none
"
)
;
StyleOwnedSlice
<
StyleFilter
>
filterChain
;
nsCOMPtr
<
nsISupports
>
autoSVGFiltersObserver
;
mozilla
:
:
gfx
:
:
FilterDescription
filter
;
nsTArray
<
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
>
filterAdditionalImages
;
bool
filterSourceGraphicTainted
=
false
;
bool
imageSmoothingEnabled
=
true
;
bool
fontExplicitLanguage
=
false
;
}
;
AutoTArray
<
ContextState
3
>
mStyleStack
;
inline
ContextState
&
CurrentState
(
)
{
return
mStyleStack
[
mStyleStack
.
Length
(
)
-
1
]
;
}
inline
const
ContextState
&
CurrentState
(
)
const
{
return
mStyleStack
[
mStyleStack
.
Length
(
)
-
1
]
;
}
friend
class
CanvasGeneralPattern
;
friend
class
AdjustedTarget
;
friend
class
AdjustedTargetForShadow
;
friend
class
AdjustedTargetForFilter
;
void
GetAppUnitsValues
(
int32_t
*
aPerDevPixel
int32_t
*
aPerCSSPixel
)
{
if
(
aPerDevPixel
)
{
*
aPerDevPixel
=
60
;
}
if
(
aPerCSSPixel
)
{
*
aPerCSSPixel
=
60
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
if
(
aPerDevPixel
)
{
*
aPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
}
if
(
aPerCSSPixel
)
{
*
aPerCSSPixel
=
AppUnitsPerCSSPixel
(
)
;
}
}
friend
struct
CanvasBidiProcessor
;
friend
class
CanvasDrawObserver
;
friend
class
ImageBitmap
;
void
SetWriteOnly
(
)
;
bool
IsWriteOnly
(
)
const
{
return
mWriteOnly
;
}
bool
mWriteOnly
;
}
;
size_t
BindingJSObjectMallocBytes
(
CanvasRenderingContext2D
*
aContext
)
;
}
}
#
endif
