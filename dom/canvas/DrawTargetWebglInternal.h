#
ifndef
_MOZILLA_GFX_DRAWTARGETWEBGL_INTERNAL_H
#
define
_MOZILLA_GFX_DRAWTARGETWEBGL_INTERNAL_H
#
include
"
DrawTargetWebgl
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
namespace
mozilla
:
:
gfx
{
class
TexturePacker
{
public
:
explicit
TexturePacker
(
const
IntRect
&
aBounds
bool
aAvailable
=
true
)
:
mBounds
(
aBounds
)
mAvailable
(
aAvailable
?
std
:
:
min
(
aBounds
.
width
aBounds
.
height
)
:
0
)
{
}
Maybe
<
IntPoint
>
Insert
(
const
IntSize
&
aSize
)
;
bool
Remove
(
const
IntRect
&
aBounds
)
;
const
IntRect
&
GetBounds
(
)
const
{
return
mBounds
;
}
private
:
bool
IsLeaf
(
)
const
{
return
!
mChildren
[
0
]
;
}
bool
IsFullyAvailable
(
)
const
{
return
IsLeaf
(
)
&
&
mAvailable
>
0
;
}
void
DiscardChildren
(
)
{
mChildren
[
0
]
=
nullptr
;
mChildren
[
1
]
=
nullptr
;
}
UniquePtr
<
TexturePacker
>
mChildren
[
2
]
;
IntRect
mBounds
;
int
mAvailable
=
0
;
}
;
class
GlyphCacheEntry
;
class
TextureHandle
:
public
RefCounted
<
TextureHandle
>
public
LinkedListElement
<
RefPtr
<
TextureHandle
>
>
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
TextureHandle
)
enum
Type
{
SHARED
STANDALONE
}
;
virtual
Type
GetType
(
)
const
=
0
;
virtual
const
RefPtr
<
WebGLTextureJS
>
&
GetWebGLTexture
(
)
const
=
0
;
virtual
IntRect
GetBounds
(
)
const
=
0
;
IntSize
GetSize
(
)
const
{
return
GetBounds
(
)
.
Size
(
)
;
}
virtual
IntSize
GetBackingSize
(
)
const
=
0
;
virtual
SurfaceFormat
GetFormat
(
)
const
=
0
;
virtual
size_t
UsedBytes
(
)
const
=
0
;
static
inline
size_t
UsedBytes
(
SurfaceFormat
aFormat
const
IntSize
&
aSize
)
{
return
size_t
(
BytesPerPixel
(
aFormat
)
)
*
size_t
(
aSize
.
width
)
*
size_t
(
aSize
.
height
)
;
}
virtual
void
UpdateSize
(
const
IntSize
&
aSize
)
{
}
virtual
void
Cleanup
(
DrawTargetWebgl
&
aDT
)
{
}
virtual
~
TextureHandle
(
)
{
}
bool
IsValid
(
)
const
{
return
mValid
;
}
void
Invalidate
(
)
{
mValid
=
false
;
}
void
SetSurface
(
SourceSurface
*
aSurface
)
{
mSurface
=
aSurface
;
}
SourceSurface
*
GetSurface
(
)
const
{
return
mSurface
;
}
float
GetSigma
(
)
const
{
return
mSigma
;
}
void
SetSigma
(
float
aSigma
)
{
mSigma
=
aSigma
;
}
bool
IsShadow
(
)
const
{
return
mSigma
>
=
0
.
0f
;
}
void
SetSamplingOffset
(
const
IntPoint
&
aSamplingOffset
)
{
mSamplingOffset
=
aSamplingOffset
;
}
const
IntPoint
&
GetSamplingOffset
(
)
const
{
return
mSamplingOffset
;
}
IntRect
GetSamplingRect
(
)
const
{
return
IntRect
(
GetSamplingOffset
(
)
GetSize
(
)
)
;
}
const
RefPtr
<
GlyphCacheEntry
>
&
GetGlyphCacheEntry
(
)
const
{
return
mGlyphCacheEntry
;
}
void
SetGlyphCacheEntry
(
const
RefPtr
<
GlyphCacheEntry
>
&
aEntry
)
{
mGlyphCacheEntry
=
aEntry
;
}
bool
IsUsed
(
)
const
{
return
mSurface
|
|
mGlyphCacheEntry
;
}
private
:
bool
mValid
=
true
;
SourceSurface
*
mSurface
=
nullptr
;
float
mSigma
=
-
1
.
0f
;
IntPoint
mSamplingOffset
;
RefPtr
<
GlyphCacheEntry
>
mGlyphCacheEntry
;
}
;
class
SharedTextureHandle
;
class
SharedTexture
:
public
RefCounted
<
SharedTexture
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
SharedTexture
)
SharedTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTextureJS
>
&
aTexture
)
;
already_AddRefed
<
SharedTextureHandle
>
Allocate
(
const
IntSize
&
aSize
)
;
bool
Free
(
const
SharedTextureHandle
&
aHandle
)
;
SurfaceFormat
GetFormat
(
)
const
{
return
mFormat
;
}
IntSize
GetSize
(
)
const
{
return
mPacker
.
GetBounds
(
)
.
Size
(
)
;
}
size_t
UsedBytes
(
)
const
{
return
TextureHandle
:
:
UsedBytes
(
GetFormat
(
)
GetSize
(
)
)
;
}
bool
HasAllocatedHandles
(
)
const
{
return
mAllocatedHandles
>
0
;
}
const
RefPtr
<
WebGLTextureJS
>
&
GetWebGLTexture
(
)
const
{
return
mTexture
;
}
private
:
TexturePacker
mPacker
;
SurfaceFormat
mFormat
;
RefPtr
<
WebGLTextureJS
>
mTexture
;
size_t
mAllocatedHandles
=
0
;
}
;
class
SharedTextureHandle
:
public
TextureHandle
{
friend
class
SharedTexture
;
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
SharedTextureHandle
override
)
SharedTextureHandle
(
const
IntRect
&
aBounds
SharedTexture
*
aTexture
)
;
Type
GetType
(
)
const
override
{
return
Type
:
:
SHARED
;
}
const
RefPtr
<
WebGLTextureJS
>
&
GetWebGLTexture
(
)
const
override
{
return
mTexture
-
>
GetWebGLTexture
(
)
;
}
IntRect
GetBounds
(
)
const
override
{
return
mBounds
;
}
IntSize
GetBackingSize
(
)
const
override
{
return
mTexture
-
>
GetSize
(
)
;
}
SurfaceFormat
GetFormat
(
)
const
override
{
return
mTexture
-
>
GetFormat
(
)
;
}
size_t
UsedBytes
(
)
const
override
{
return
TextureHandle
:
:
UsedBytes
(
GetFormat
(
)
mBounds
.
Size
(
)
)
;
}
void
Cleanup
(
DrawTargetWebgl
&
aDT
)
override
;
const
RefPtr
<
SharedTexture
>
&
GetOwner
(
)
const
{
return
mTexture
;
}
private
:
IntRect
mBounds
;
RefPtr
<
SharedTexture
>
mTexture
;
}
;
class
StandaloneTexture
:
public
TextureHandle
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
StandaloneTexture
override
)
StandaloneTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTextureJS
>
&
aTexture
)
;
Type
GetType
(
)
const
override
{
return
Type
:
:
STANDALONE
;
}
SurfaceFormat
GetFormat
(
)
const
override
{
return
mFormat
;
}
const
RefPtr
<
WebGLTextureJS
>
&
GetWebGLTexture
(
)
const
override
{
return
mTexture
;
}
IntRect
GetBounds
(
)
const
override
{
return
IntRect
(
IntPoint
(
0
0
)
mSize
)
;
}
IntSize
GetBackingSize
(
)
const
override
{
return
mSize
;
}
size_t
UsedBytes
(
)
const
override
{
return
TextureHandle
:
:
UsedBytes
(
mFormat
mSize
)
;
}
void
UpdateSize
(
const
IntSize
&
aSize
)
override
{
mSize
=
aSize
;
}
void
Cleanup
(
DrawTargetWebgl
&
aDT
)
override
;
private
:
IntSize
mSize
;
SurfaceFormat
mFormat
;
RefPtr
<
WebGLTextureJS
>
mTexture
;
}
;
class
GlyphCacheEntry
:
public
RefCounted
<
GlyphCacheEntry
>
public
LinkedListElement
<
RefPtr
<
GlyphCacheEntry
>
>
{
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
GlyphCacheEntry
)
GlyphCacheEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntRect
&
aBounds
HashNumber
aHash
=
0
)
;
bool
MatchesGlyphs
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntRect
&
aBounds
HashNumber
aHash
)
;
static
HashNumber
HashGlyphs
(
const
GlyphBuffer
&
aBuffer
const
Matrix
&
aTransform
)
;
void
Link
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
;
void
Unlink
(
)
;
const
RefPtr
<
TextureHandle
>
&
GetHandle
(
)
const
{
return
mHandle
;
}
private
:
RefPtr
<
TextureHandle
>
mHandle
;
GlyphBuffer
mBuffer
=
{
nullptr
0
}
;
DeviceColor
mColor
;
Matrix
mTransform
;
IntRect
mBounds
;
HashNumber
mHash
;
}
;
class
GlyphCache
:
public
LinkedListElement
<
GlyphCache
>
{
public
:
explicit
GlyphCache
(
ScaledFont
*
aFont
)
;
~
GlyphCache
(
)
;
ScaledFont
*
GetFont
(
)
const
{
return
mFont
;
}
already_AddRefed
<
GlyphCacheEntry
>
FindOrInsertEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntRect
&
aBounds
HashNumber
aHash
=
0
)
;
private
:
ScaledFont
*
mFont
;
LinkedList
<
RefPtr
<
GlyphCacheEntry
>
>
mEntries
;
}
;
}
#
endif
