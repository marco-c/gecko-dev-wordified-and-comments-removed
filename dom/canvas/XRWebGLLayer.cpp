#
include
"
mozilla
/
dom
/
XRSession
.
h
"
#
include
"
mozilla
/
dom
/
XRView
.
h
"
#
include
"
mozilla
/
dom
/
XRViewport
.
h
"
#
include
"
mozilla
/
dom
/
XRWebGLLayer
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_webgl
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
#
include
"
MozFramebuffer
.
h
"
#
include
"
VRDisplayClient
.
h
"
#
include
"
ClientWebGLContext
.
h
"
#
include
"
nsICanvasRenderingContextInternal
.
h
"
using
namespace
mozilla
:
:
gl
;
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
XRWebGLLayer
mParent
mSession
mContext
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
XRWebGLLayer
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
XRWebGLLayer
Release
)
XRWebGLLayer
:
:
XRWebGLLayer
(
nsISupports
*
aParent
XRSession
&
aSession
bool
aAntialias
const
XRWebGLLayerInit
&
aXRWebGLLayerInitDict
const
WebGLRenderingContextOrWebGL2RenderingContext
&
aXRWebGLContext
)
:
mSession
(
&
aSession
)
mParent
(
aParent
)
mCompositionDisabled
(
!
aSession
.
IsImmersive
(
)
)
mIgnoreDepthValues
(
aXRWebGLLayerInitDict
.
mIgnoreDepthValues
)
mAntialias
(
aAntialias
)
{
gfx
:
:
VRDisplayClient
*
display
=
aSession
.
GetDisplayClient
(
)
;
if
(
aXRWebGLContext
.
IsWebGLRenderingContext
(
)
)
{
mContext
=
&
aXRWebGLContext
.
GetAsWebGLRenderingContext
(
)
;
}
else
{
mContext
=
&
aXRWebGLContext
.
GetAsWebGL2RenderingContext
(
)
;
}
mIgnoreDepthValues
=
true
;
if
(
!
aXRWebGLLayerInitDict
.
mIgnoreDepthValues
&
&
display
!
=
nullptr
)
{
const
gfx
:
:
VRDisplayInfo
&
displayInfo
=
display
-
>
GetDisplayInfo
(
)
;
if
(
displayInfo
.
mDisplayState
.
capabilityFlags
&
gfx
:
:
VRDisplayCapabilityFlags
:
:
Cap_UseDepthValues
)
{
mIgnoreDepthValues
=
false
;
}
}
}
already_AddRefed
<
XRWebGLLayer
>
XRWebGLLayer
:
:
Constructor
(
const
GlobalObject
&
aGlobal
XRSession
&
aSession
const
WebGLRenderingContextOrWebGL2RenderingContext
&
aXRWebGLContext
const
XRWebGLLayerInit
&
aXRWebGLLayerInitDict
ErrorResult
&
aRv
)
{
if
(
aSession
.
IsEnded
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Can
not
create
an
XRWebGLLayer
with
an
XRSession
that
has
ended
.
"
)
;
return
nullptr
;
}
ClientWebGLContext
*
gl
=
nullptr
;
if
(
aXRWebGLContext
.
IsWebGLRenderingContext
(
)
)
{
gl
=
&
aXRWebGLContext
.
GetAsWebGLRenderingContext
(
)
;
}
else
{
gl
=
&
aXRWebGLContext
.
GetAsWebGL2RenderingContext
(
)
;
}
if
(
gl
-
>
IsContextLost
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Could
not
create
an
XRWebGLLayer
as
the
WebGL
context
was
lost
.
"
)
;
return
nullptr
;
}
if
(
!
gl
-
>
IsXRCompatible
(
)
&
&
aSession
.
IsImmersive
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
Can
not
create
an
XRWebGLLayer
without
first
calling
makeXRCompatible
"
"
on
the
WebGLRenderingContext
or
WebGL2RenderingContext
.
"
)
;
return
nullptr
;
}
bool
antialias
=
false
;
if
(
aSession
.
IsImmersive
(
)
)
{
antialias
=
aXRWebGLLayerInitDict
.
mAntialias
;
}
else
{
const
WebGLContextOptions
&
options
=
gl
-
>
ActualContextParameters
(
)
;
antialias
=
options
.
antialias
;
}
RefPtr
<
XRWebGLLayer
>
obj
=
new
XRWebGLLayer
(
aGlobal
.
GetAsSupports
(
)
aSession
antialias
aXRWebGLLayerInitDict
aXRWebGLContext
)
;
return
obj
.
forget
(
)
;
}
JSObject
*
XRWebGLLayer
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
XRWebGLLayer_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
nsISupports
*
XRWebGLLayer
:
:
GetParentObject
(
)
const
{
return
mParent
;
}
bool
XRWebGLLayer
:
:
Antialias
(
)
{
return
mAntialias
;
}
bool
XRWebGLLayer
:
:
IgnoreDepthValues
(
)
{
return
mIgnoreDepthValues
;
}
WebGLFramebufferJS
*
XRWebGLLayer
:
:
GetFramebuffer
(
)
{
return
nullptr
;
}
uint32_t
XRWebGLLayer
:
:
FramebufferWidth
(
)
{
return
mContext
-
>
GetWidth
(
)
;
}
uint32_t
XRWebGLLayer
:
:
FramebufferHeight
(
)
{
return
mContext
-
>
GetHeight
(
)
;
}
already_AddRefed
<
XRViewport
>
XRWebGLLayer
:
:
GetViewport
(
const
XRView
&
aView
)
{
gfx
:
:
IntRect
viewportRect
(
0
0
mContext
-
>
GetWidth
(
)
/
2
mContext
-
>
GetHeight
(
)
)
;
if
(
aView
.
Eye
(
)
=
=
XREye
:
:
Right
)
{
viewportRect
.
x
=
viewportRect
.
width
;
}
RefPtr
<
XRViewport
>
viewport
=
new
XRViewport
(
mParent
viewportRect
)
;
return
viewport
.
forget
(
)
;
}
double
XRWebGLLayer
:
:
GetNativeFramebufferScaleFactor
(
const
GlobalObject
&
aGlobal
const
XRSession
&
aSession
)
{
if
(
aSession
.
IsEnded
(
)
)
{
return
0
.
0f
;
}
return
1
.
0f
;
}
}
}
