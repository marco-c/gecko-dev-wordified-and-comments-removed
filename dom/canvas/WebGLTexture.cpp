#
include
"
WebGLTexture
.
h
"
#
include
<
algorithm
>
#
include
"
GLContext
.
h
"
#
include
"
ScopedGLHelpers
.
h
"
#
include
"
WebGLContext
.
h
"
#
include
"
WebGLContextUtils
.
h
"
#
include
"
WebGLFormats
.
h
"
#
include
"
WebGLFramebuffer
.
h
"
#
include
"
WebGLSampler
.
h
"
#
include
"
WebGLTexelConversions
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
WebGLRenderingContextBinding
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
namespace
mozilla
{
namespace
webgl
{
MOZ_CONSTINIT
const
ImageInfo
ImageInfo
:
:
kUndefined
;
size_t
ImageInfo
:
:
MemoryUsage
(
)
const
{
if
(
!
IsDefined
(
)
)
return
0
;
size_t
samples
=
mSamples
;
if
(
!
samples
)
{
samples
=
1
;
}
const
size_t
bytesPerTexel
=
mFormat
-
>
format
-
>
estimatedBytesPerPixel
;
return
size_t
(
mWidth
)
*
size_t
(
mHeight
)
*
size_t
(
mDepth
)
*
samples
*
bytesPerTexel
;
}
Maybe
<
ImageInfo
>
ImageInfo
:
:
NextMip
(
const
GLenum
target
)
const
{
MOZ_ASSERT
(
IsDefined
(
)
)
;
auto
next
=
*
this
;
if
(
target
=
=
LOCAL_GL_TEXTURE_3D
)
{
if
(
mWidth
<
=
1
&
&
mHeight
<
=
1
&
&
mDepth
<
=
1
)
{
return
{
}
;
}
next
.
mDepth
=
std
:
:
max
(
uint32_t
(
1
)
next
.
mDepth
/
2
)
;
}
else
{
if
(
mWidth
<
=
1
&
&
mHeight
<
=
1
)
{
return
{
}
;
}
}
if
(
next
.
mUninitializedSlices
)
{
next
.
mUninitializedSlices
.
emplace
(
next
.
mDepth
true
)
;
}
next
.
mWidth
=
std
:
:
max
(
uint32_t
(
1
)
next
.
mWidth
/
2
)
;
next
.
mHeight
=
std
:
:
max
(
uint32_t
(
1
)
next
.
mHeight
/
2
)
;
return
Some
(
next
)
;
}
}
WebGLTexture
:
:
WebGLTexture
(
WebGLContext
*
webgl
GLuint
tex
)
:
WebGLContextBoundObject
(
webgl
)
mGLName
(
tex
)
mTarget
(
LOCAL_GL_NONE
)
mFaceCount
(
0
)
mImmutable
(
false
)
mImmutableLevelCount
(
0
)
mBaseMipmapLevel
(
0
)
mMaxMipmapLevel
(
1000
)
{
}
WebGLTexture
:
:
~
WebGLTexture
(
)
{
for
(
auto
&
cur
:
mImageInfoArr
)
{
cur
=
webgl
:
:
ImageInfo
(
)
;
}
InvalidateCaches
(
)
;
if
(
!
mContext
)
return
;
mContext
-
>
gl
-
>
fDeleteTextures
(
1
&
mGLName
)
;
}
size_t
WebGLTexture
:
:
MemoryUsage
(
)
const
{
size_t
accum
=
0
;
for
(
const
auto
&
cur
:
mImageInfoArr
)
{
accum
+
=
cur
.
MemoryUsage
(
)
;
}
return
accum
;
}
void
WebGLTexture
:
:
PopulateMipChain
(
const
uint32_t
maxLevel
)
{
auto
ref
=
BaseImageInfo
(
)
;
MOZ_ASSERT
(
ref
.
mWidth
&
&
ref
.
mHeight
&
&
ref
.
mDepth
)
;
for
(
auto
level
=
mBaseMipmapLevel
;
level
<
=
maxLevel
;
+
+
level
)
{
for
(
uint8_t
face
=
0
;
face
<
mFaceCount
;
face
+
+
)
{
auto
&
cur
=
ImageInfoAtFace
(
face
level
)
;
cur
=
ref
;
}
const
auto
next
=
ref
.
NextMip
(
mTarget
.
get
(
)
)
;
if
(
!
next
)
break
;
ref
=
next
.
ref
(
)
;
}
InvalidateCaches
(
)
;
}
static
bool
ZeroTextureData
(
const
WebGLContext
*
webgl
GLuint
tex
TexImageTarget
target
uint32_t
level
const
webgl
:
:
ImageInfo
&
info
)
;
bool
WebGLTexture
:
:
IsMipAndCubeComplete
(
const
uint32_t
maxLevel
const
bool
ensureInit
bool
*
const
out_initFailed
)
const
{
*
out_initFailed
=
false
;
auto
ref
=
BaseImageInfo
(
)
;
MOZ_ASSERT
(
ref
.
mWidth
&
&
ref
.
mHeight
&
&
ref
.
mDepth
)
;
for
(
auto
level
=
mBaseMipmapLevel
;
level
<
=
maxLevel
;
+
+
level
)
{
for
(
uint8_t
face
=
0
;
face
<
mFaceCount
;
face
+
+
)
{
auto
&
cur
=
ImageInfoAtFace
(
face
level
)
;
if
(
cur
.
mWidth
!
=
ref
.
mWidth
|
|
cur
.
mHeight
!
=
ref
.
mHeight
|
|
cur
.
mDepth
!
=
ref
.
mDepth
|
|
cur
.
mFormat
!
=
ref
.
mFormat
)
{
return
false
;
}
if
(
MOZ_UNLIKELY
(
ensureInit
&
&
cur
.
mUninitializedSlices
)
)
{
auto
imageTarget
=
mTarget
.
get
(
)
;
if
(
imageTarget
=
=
LOCAL_GL_TEXTURE_CUBE_MAP
)
{
imageTarget
=
LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X
+
face
;
}
if
(
!
ZeroTextureData
(
mContext
mGLName
imageTarget
level
cur
)
)
{
mContext
-
>
ErrorOutOfMemory
(
"
Failed
to
zero
tex
image
data
.
"
)
;
*
out_initFailed
=
true
;
return
false
;
}
cur
.
mUninitializedSlices
.
reset
(
)
;
}
}
const
auto
next
=
ref
.
NextMip
(
mTarget
.
get
(
)
)
;
if
(
!
next
)
break
;
ref
=
next
.
ref
(
)
;
}
return
true
;
}
Maybe
<
const
WebGLTexture
:
:
CompletenessInfo
>
WebGLTexture
:
:
CalcCompletenessInfo
(
const
bool
ensureInit
const
bool
skipMips
)
const
{
Maybe
<
CompletenessInfo
>
ret
=
Some
(
CompletenessInfo
(
)
)
;
const
auto
level_base
=
Es3_level_base
(
)
;
if
(
level_base
>
kMaxLevelCount
-
1
)
{
ret
-
>
incompleteReason
=
"
level_base
too
high
.
"
;
return
ret
;
}
const
auto
&
baseImageInfo
=
ImageInfoAtFace
(
0
level_base
)
;
if
(
!
baseImageInfo
.
IsDefined
(
)
)
{
ret
-
>
incompleteReason
=
nullptr
;
return
ret
;
}
if
(
!
baseImageInfo
.
mWidth
|
|
!
baseImageInfo
.
mHeight
|
|
!
baseImageInfo
.
mDepth
)
{
ret
-
>
incompleteReason
=
"
The
dimensions
of
level_base
are
not
all
positive
.
"
;
return
ret
;
}
bool
initFailed
=
false
;
if
(
!
IsMipAndCubeComplete
(
level_base
ensureInit
&
initFailed
)
)
{
if
(
initFailed
)
return
{
}
;
ret
-
>
incompleteReason
=
"
Cubemaps
must
be
\
"
cube
complete
\
"
.
"
;
return
ret
;
}
ret
-
>
levels
=
1
;
ret
-
>
usage
=
baseImageInfo
.
mFormat
;
RefreshSwizzle
(
)
;
ret
-
>
powerOfTwo
=
mozilla
:
:
IsPowerOfTwo
(
baseImageInfo
.
mWidth
)
&
&
mozilla
:
:
IsPowerOfTwo
(
baseImageInfo
.
mHeight
)
;
if
(
mTarget
=
=
LOCAL_GL_TEXTURE_3D
)
{
ret
-
>
powerOfTwo
&
=
mozilla
:
:
IsPowerOfTwo
(
baseImageInfo
.
mDepth
)
;
}
if
(
!
mContext
-
>
IsWebGL2
(
)
&
&
!
ret
-
>
powerOfTwo
)
{
ret
-
>
incompleteReason
=
"
Mipmapping
requires
power
-
of
-
two
sizes
.
"
;
return
ret
;
}
const
auto
level_max
=
Es3_level_max
(
)
;
const
auto
maxLevel_aka_q
=
Es3_q
(
)
;
if
(
level_base
>
level_max
)
{
ret
-
>
incompleteReason
=
"
level_base
>
level_max
.
"
;
return
ret
;
}
if
(
skipMips
)
return
ret
;
if
(
!
IsMipAndCubeComplete
(
maxLevel_aka_q
ensureInit
&
initFailed
)
)
{
if
(
initFailed
)
return
{
}
;
ret
-
>
incompleteReason
=
"
Bad
mipmap
dimension
or
format
.
"
;
return
ret
;
}
ret
-
>
levels
=
AutoAssertCast
(
maxLevel_aka_q
-
level_base
+
1
)
;
ret
-
>
mipmapComplete
=
true
;
return
ret
;
}
Maybe
<
const
webgl
:
:
SampleableInfo
>
WebGLTexture
:
:
CalcSampleableInfo
(
const
WebGLSampler
*
const
sampler
)
const
{
Maybe
<
webgl
:
:
SampleableInfo
>
ret
=
Some
(
webgl
:
:
SampleableInfo
(
)
)
;
const
bool
ensureInit
=
true
;
const
auto
completeness
=
CalcCompletenessInfo
(
ensureInit
)
;
if
(
!
completeness
)
return
{
}
;
ret
-
>
incompleteReason
=
completeness
-
>
incompleteReason
;
if
(
!
completeness
-
>
levels
)
return
ret
;
const
auto
*
sampling
=
&
mSamplingState
;
if
(
sampler
)
{
sampling
=
&
sampler
-
>
State
(
)
;
}
const
auto
isDepthTex
=
bool
(
completeness
-
>
usage
-
>
format
-
>
d
)
;
ret
-
>
isDepthTexCompare
=
isDepthTex
&
bool
(
sampling
-
>
compareMode
.
get
(
)
)
;
const
auto
&
minFilter
=
sampling
-
>
minFilter
;
const
auto
&
magFilter
=
sampling
-
>
magFilter
;
const
bool
needsMips
=
(
minFilter
=
=
LOCAL_GL_NEAREST_MIPMAP_NEAREST
|
|
minFilter
=
=
LOCAL_GL_NEAREST_MIPMAP_LINEAR
|
|
minFilter
=
=
LOCAL_GL_LINEAR_MIPMAP_NEAREST
|
|
minFilter
=
=
LOCAL_GL_LINEAR_MIPMAP_LINEAR
)
;
if
(
needsMips
&
!
completeness
-
>
mipmapComplete
)
return
ret
;
const
bool
isMinFilteringNearest
=
(
minFilter
=
=
LOCAL_GL_NEAREST
|
|
minFilter
=
=
LOCAL_GL_NEAREST_MIPMAP_NEAREST
)
;
const
bool
isMagFilteringNearest
=
(
magFilter
=
=
LOCAL_GL_NEAREST
)
;
const
bool
isFilteringNearestOnly
=
(
isMinFilteringNearest
&
&
isMagFilteringNearest
)
;
if
(
!
isFilteringNearestOnly
)
{
bool
isFilterable
=
completeness
-
>
usage
-
>
isFilterable
;
if
(
ret
-
>
isDepthTexCompare
)
{
isFilterable
=
true
;
if
(
mContext
-
>
mWarnOnce_DepthTexCompareFilterable
)
{
mContext
-
>
mWarnOnce_DepthTexCompareFilterable
=
false
;
mContext
-
>
GenerateWarning
(
"
Depth
texture
comparison
requests
(
e
.
g
.
LINEAR
)
Filtering
but
"
"
behavior
is
implementation
-
defined
and
so
on
some
systems
will
"
"
sometimes
behave
as
NEAREST
.
(
warns
once
)
"
)
;
}
}
if
(
!
isFilterable
)
{
ret
-
>
incompleteReason
=
"
Minification
or
magnification
filtering
is
not
"
"
NEAREST
or
NEAREST_MIPMAP_NEAREST
and
the
"
"
texture
'
s
format
is
not
\
"
texture
-
filterable
\
"
.
"
;
return
ret
;
}
}
if
(
!
mContext
-
>
IsWebGL2
(
)
&
&
!
completeness
-
>
powerOfTwo
)
{
if
(
sampling
-
>
wrapS
!
=
LOCAL_GL_CLAMP_TO_EDGE
|
|
sampling
-
>
wrapT
!
=
LOCAL_GL_CLAMP_TO_EDGE
)
{
ret
-
>
incompleteReason
=
"
Non
-
power
-
of
-
two
textures
must
have
a
wrap
mode
of
"
"
CLAMP_TO_EDGE
.
"
;
return
ret
;
}
}
ret
-
>
incompleteReason
=
nullptr
;
ret
-
>
levels
=
completeness
-
>
levels
;
if
(
!
needsMips
&
&
ret
-
>
levels
)
{
ret
-
>
levels
=
1
;
}
ret
-
>
usage
=
completeness
-
>
usage
;
return
ret
;
}
const
webgl
:
:
SampleableInfo
*
WebGLTexture
:
:
GetSampleableInfo
(
const
WebGLSampler
*
const
sampler
)
const
{
auto
itr
=
mSamplingCache
.
Find
(
sampler
)
;
if
(
!
itr
)
{
const
auto
info
=
CalcSampleableInfo
(
sampler
)
;
if
(
!
info
)
return
nullptr
;
auto
entry
=
mSamplingCache
.
MakeEntry
(
sampler
info
.
value
(
)
)
;
entry
-
>
AddInvalidator
(
*
this
)
;
if
(
sampler
)
{
entry
-
>
AddInvalidator
(
*
sampler
)
;
}
itr
=
mSamplingCache
.
Insert
(
std
:
:
move
(
entry
)
)
;
}
return
itr
;
}
uint32_t
WebGLTexture
:
:
Es3_q
(
)
const
{
const
auto
&
imageInfo
=
BaseImageInfo
(
)
;
if
(
!
imageInfo
.
IsDefined
(
)
)
return
mBaseMipmapLevel
;
uint32_t
largestDim
=
std
:
:
max
(
imageInfo
.
mWidth
imageInfo
.
mHeight
)
;
if
(
mTarget
=
=
LOCAL_GL_TEXTURE_3D
)
{
largestDim
=
std
:
:
max
(
largestDim
imageInfo
.
mDepth
)
;
}
if
(
!
largestDim
)
return
mBaseMipmapLevel
;
const
auto
numLevels
=
FloorLog2Size
(
largestDim
)
+
1
;
const
auto
maxLevelBySize
=
mBaseMipmapLevel
+
numLevels
-
1
;
return
std
:
:
min
<
uint32_t
>
(
maxLevelBySize
mMaxMipmapLevel
)
;
}
static
void
SetSwizzle
(
gl
:
:
GLContext
*
gl
TexTarget
target
const
GLint
*
swizzle
)
{
static
const
GLint
kNoSwizzle
[
4
]
=
{
LOCAL_GL_RED
LOCAL_GL_GREEN
LOCAL_GL_BLUE
LOCAL_GL_ALPHA
}
;
if
(
!
swizzle
)
{
swizzle
=
kNoSwizzle
;
}
else
if
(
!
gl
-
>
IsSupported
(
gl
:
:
GLFeature
:
:
texture_swizzle
)
)
{
MOZ_CRASH
(
"
GFX
:
Needs
swizzle
feature
to
swizzle
!
"
)
;
}
gl
-
>
fTexParameteri
(
target
.
get
(
)
LOCAL_GL_TEXTURE_SWIZZLE_R
swizzle
[
0
]
)
;
gl
-
>
fTexParameteri
(
target
.
get
(
)
LOCAL_GL_TEXTURE_SWIZZLE_G
swizzle
[
1
]
)
;
gl
-
>
fTexParameteri
(
target
.
get
(
)
LOCAL_GL_TEXTURE_SWIZZLE_B
swizzle
[
2
]
)
;
gl
-
>
fTexParameteri
(
target
.
get
(
)
LOCAL_GL_TEXTURE_SWIZZLE_A
swizzle
[
3
]
)
;
}
void
WebGLTexture
:
:
RefreshSwizzle
(
)
const
{
const
auto
&
imageInfo
=
BaseImageInfo
(
)
;
const
auto
&
swizzle
=
imageInfo
.
mFormat
-
>
textureSwizzleRGBA
;
if
(
swizzle
!
=
mCurSwizzle
)
{
const
gl
:
:
ScopedBindTexture
scopeBindTexture
(
mContext
-
>
gl
mGLName
mTarget
.
get
(
)
)
;
SetSwizzle
(
mContext
-
>
gl
mTarget
swizzle
)
;
mCurSwizzle
=
swizzle
;
}
}
bool
WebGLTexture
:
:
EnsureImageDataInitialized
(
const
TexImageTarget
target
const
uint32_t
level
)
{
auto
&
imageInfo
=
ImageInfoAt
(
target
level
)
;
if
(
!
imageInfo
.
IsDefined
(
)
)
return
true
;
if
(
!
imageInfo
.
mUninitializedSlices
)
return
true
;
if
(
!
ZeroTextureData
(
mContext
mGLName
target
level
imageInfo
)
)
{
return
false
;
}
imageInfo
.
mUninitializedSlices
.
reset
(
)
;
return
true
;
}
static
bool
ClearDepthTexture
(
const
WebGLContext
&
webgl
const
GLuint
tex
const
TexImageTarget
imageTarget
const
uint32_t
level
const
webgl
:
:
ImageInfo
&
info
)
{
const
auto
&
gl
=
webgl
.
gl
;
const
auto
&
usage
=
info
.
mFormat
;
const
auto
&
format
=
usage
-
>
format
;
MOZ_ASSERT
(
usage
-
>
IsRenderable
(
)
)
;
MOZ_ASSERT
(
info
.
mUninitializedSlices
)
;
GLenum
attachPoint
=
LOCAL_GL_DEPTH_ATTACHMENT
;
GLbitfield
clearBits
=
LOCAL_GL_DEPTH_BUFFER_BIT
;
if
(
format
-
>
s
)
{
attachPoint
=
LOCAL_GL_DEPTH_STENCIL_ATTACHMENT
;
clearBits
|
=
LOCAL_GL_STENCIL_BUFFER_BIT
;
}
gl
:
:
ScopedFramebuffer
scopedFB
(
gl
)
;
const
gl
:
:
ScopedBindFramebuffer
scopedBindFB
(
gl
scopedFB
.
FB
(
)
)
;
const
webgl
:
:
ScopedPrepForResourceClear
scopedPrep
(
webgl
)
;
const
auto
fnAttach
=
[
&
]
(
const
uint32_t
z
)
{
switch
(
imageTarget
.
get
(
)
)
{
case
LOCAL_GL_TEXTURE_3D
:
case
LOCAL_GL_TEXTURE_2D_ARRAY
:
gl
-
>
fFramebufferTextureLayer
(
LOCAL_GL_FRAMEBUFFER
attachPoint
tex
level
z
)
;
break
;
default
:
if
(
attachPoint
=
=
LOCAL_GL_DEPTH_STENCIL_ATTACHMENT
)
{
gl
-
>
fFramebufferTexture2D
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_DEPTH_ATTACHMENT
imageTarget
.
get
(
)
tex
level
)
;
gl
-
>
fFramebufferTexture2D
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_STENCIL_ATTACHMENT
imageTarget
.
get
(
)
tex
level
)
;
}
else
{
gl
-
>
fFramebufferTexture2D
(
LOCAL_GL_FRAMEBUFFER
attachPoint
imageTarget
.
get
(
)
tex
level
)
;
}
break
;
}
}
;
for
(
const
auto
z
:
IntegerRange
(
info
.
mDepth
)
)
{
if
(
(
*
info
.
mUninitializedSlices
)
[
z
]
)
{
fnAttach
(
z
)
;
gl
-
>
fClear
(
clearBits
)
;
}
}
const
auto
&
status
=
gl
-
>
fCheckFramebufferStatus
(
LOCAL_GL_FRAMEBUFFER
)
;
const
bool
isComplete
=
(
status
=
=
LOCAL_GL_FRAMEBUFFER_COMPLETE
)
;
MOZ_ASSERT
(
isComplete
)
;
return
isComplete
;
}
static
bool
ZeroTextureData
(
const
WebGLContext
*
webgl
GLuint
tex
TexImageTarget
target
uint32_t
level
const
webgl
:
:
ImageInfo
&
info
)
{
MOZ_ASSERT
(
info
.
mUninitializedSlices
)
;
const
auto
targetStr
=
EnumString
(
target
.
get
(
)
)
;
webgl
-
>
GenerateWarning
(
"
Tex
image
%
s
level
%
u
is
incurring
lazy
initialization
.
"
targetStr
.
c_str
(
)
level
)
;
gl
:
:
GLContext
*
gl
=
webgl
-
>
GL
(
)
;
const
auto
&
width
=
info
.
mWidth
;
const
auto
&
height
=
info
.
mHeight
;
const
auto
&
depth
=
info
.
mDepth
;
const
auto
&
usage
=
info
.
mFormat
;
GLenum
scopeBindTarget
;
switch
(
target
.
get
(
)
)
{
case
LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_X
:
case
LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_X
:
case
LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Y
:
case
LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
:
case
LOCAL_GL_TEXTURE_CUBE_MAP_POSITIVE_Z
:
case
LOCAL_GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
:
scopeBindTarget
=
LOCAL_GL_TEXTURE_CUBE_MAP
;
break
;
default
:
scopeBindTarget
=
target
.
get
(
)
;
break
;
}
const
gl
:
:
ScopedBindTexture
scopeBindTexture
(
gl
tex
scopeBindTarget
)
;
const
auto
&
compression
=
usage
-
>
format
-
>
compression
;
if
(
compression
)
{
auto
sizedFormat
=
usage
-
>
format
-
>
sizedFormat
;
MOZ_RELEASE_ASSERT
(
sizedFormat
"
GFX
:
texture
sized
format
not
set
"
)
;
const
auto
fnSizeInBlocks
=
[
]
(
CheckedUint32
pixels
uint8_t
pixelsPerBlock
)
{
return
RoundUpToMultipleOf
(
pixels
pixelsPerBlock
)
/
pixelsPerBlock
;
}
;
const
auto
widthBlocks
=
fnSizeInBlocks
(
width
compression
-
>
blockWidth
)
;
const
auto
heightBlocks
=
fnSizeInBlocks
(
height
compression
-
>
blockHeight
)
;
CheckedUint32
checkedByteCount
=
compression
-
>
bytesPerBlock
;
checkedByteCount
*
=
widthBlocks
;
checkedByteCount
*
=
heightBlocks
;
if
(
!
checkedByteCount
.
isValid
(
)
)
return
false
;
const
size_t
sliceByteCount
=
checkedByteCount
.
value
(
)
;
const
auto
zeros
=
UniqueBuffer
:
:
Take
(
calloc
(
1u
sliceByteCount
)
)
;
if
(
!
zeros
)
return
false
;
webgl
:
:
PixelPackingState
{
}
.
AssertCurrentUnpack
(
*
gl
webgl
-
>
IsWebGL2
(
)
)
;
gl
-
>
fPixelStorei
(
LOCAL_GL_UNPACK_ALIGNMENT
1
)
;
const
auto
revert
=
MakeScopeExit
(
[
&
]
(
)
{
gl
-
>
fPixelStorei
(
LOCAL_GL_UNPACK_ALIGNMENT
4
)
;
}
)
;
GLenum
error
=
0
;
for
(
const
auto
z
:
IntegerRange
(
depth
)
)
{
if
(
(
*
info
.
mUninitializedSlices
)
[
z
]
)
{
error
=
DoCompressedTexSubImage
(
gl
target
.
get
(
)
level
0
0
z
width
height
1
sizedFormat
sliceByteCount
zeros
.
get
(
)
)
;
if
(
error
)
break
;
}
}
return
!
error
;
}
const
auto
driverUnpackInfo
=
usage
-
>
idealUnpack
;
MOZ_RELEASE_ASSERT
(
driverUnpackInfo
"
GFX
:
ideal
unpack
info
not
set
.
"
)
;
if
(
usage
-
>
format
-
>
d
)
{
return
ClearDepthTexture
(
*
webgl
tex
target
level
info
)
;
}
const
webgl
:
:
PackingInfo
packing
=
driverUnpackInfo
-
>
ToPacking
(
)
;
const
auto
bytesPerPixel
=
webgl
:
:
BytesPerPixel
(
packing
)
;
CheckedUint32
checkedByteCount
=
bytesPerPixel
;
checkedByteCount
*
=
width
;
checkedByteCount
*
=
height
;
if
(
!
checkedByteCount
.
isValid
(
)
)
return
false
;
const
size_t
sliceByteCount
=
checkedByteCount
.
value
(
)
;
const
auto
zeros
=
UniqueBuffer
:
:
Take
(
calloc
(
1u
sliceByteCount
)
)
;
if
(
!
zeros
)
return
false
;
webgl
:
:
PixelPackingState
{
}
.
AssertCurrentUnpack
(
*
gl
webgl
-
>
IsWebGL2
(
)
)
;
gl
-
>
fPixelStorei
(
LOCAL_GL_UNPACK_ALIGNMENT
1
)
;
const
auto
revert
=
MakeScopeExit
(
[
&
]
(
)
{
gl
-
>
fPixelStorei
(
LOCAL_GL_UNPACK_ALIGNMENT
4
)
;
}
)
;
GLenum
error
=
0
;
for
(
const
auto
z
:
IntegerRange
(
depth
)
)
{
if
(
(
*
info
.
mUninitializedSlices
)
[
z
]
)
{
error
=
DoTexSubImage
(
gl
target
level
0
0
z
width
height
1
packing
zeros
.
get
(
)
)
;
if
(
error
)
break
;
}
}
return
!
error
;
}
void
WebGLTexture
:
:
ClampLevelBaseAndMax
(
)
{
if
(
!
mImmutable
)
return
;
MOZ_ASSERT
(
mImmutableLevelCount
>
0
)
;
const
auto
oldBase
=
mBaseMipmapLevel
;
const
auto
oldMax
=
mMaxMipmapLevel
;
mBaseMipmapLevel
=
std
:
:
clamp
(
mBaseMipmapLevel
0u
mImmutableLevelCount
-
1u
)
;
mMaxMipmapLevel
=
std
:
:
clamp
(
mMaxMipmapLevel
mBaseMipmapLevel
mImmutableLevelCount
-
1u
)
;
if
(
oldBase
!
=
mBaseMipmapLevel
&
&
mBaseMipmapLevelState
!
=
MIPMAP_LEVEL_DEFAULT
)
{
mBaseMipmapLevelState
=
MIPMAP_LEVEL_DIRTY
;
}
if
(
oldMax
!
=
mMaxMipmapLevel
&
&
mMaxMipmapLevelState
!
=
MIPMAP_LEVEL_DEFAULT
)
{
mMaxMipmapLevelState
=
MIPMAP_LEVEL_DIRTY
;
}
}
bool
WebGLTexture
:
:
BindTexture
(
TexTarget
texTarget
)
{
const
bool
isFirstBinding
=
!
mTarget
;
if
(
!
isFirstBinding
&
&
mTarget
!
=
texTarget
)
{
mContext
-
>
ErrorInvalidOperation
(
"
bindTexture
:
This
texture
has
already
been
bound
"
"
to
a
different
target
.
"
)
;
return
false
;
}
mTarget
=
texTarget
;
mContext
-
>
gl
-
>
fBindTexture
(
mTarget
.
get
(
)
mGLName
)
;
if
(
isFirstBinding
)
{
mFaceCount
=
IsCubeMap
(
)
?
6
:
1
;
gl
:
:
GLContext
*
gl
=
mContext
-
>
gl
;
const
bool
hasWrapR
=
gl
-
>
IsSupported
(
gl
:
:
GLFeature
:
:
texture_3D
)
;
if
(
IsCubeMap
(
)
&
&
hasWrapR
&
&
!
mContext
-
>
IsWebGL2
(
)
)
{
gl
-
>
fTexParameteri
(
texTarget
.
get
(
)
LOCAL_GL_TEXTURE_WRAP_R
LOCAL_GL_CLAMP_TO_EDGE
)
;
}
}
return
true
;
}
static
constexpr
GLint
ClampMipmapLevelForDriver
(
uint32_t
level
)
{
return
static_cast
<
GLint
>
(
std
:
:
clamp
(
level
0u
(
uint32_t
)
WebGLTexture
:
:
kMaxLevelCount
)
)
;
}
void
WebGLTexture
:
:
GenerateMipmap
(
)
{
const
bool
ensureInit
=
true
;
const
bool
skipMips
=
true
;
const
auto
completeness
=
CalcCompletenessInfo
(
ensureInit
skipMips
)
;
if
(
!
completeness
|
|
!
completeness
-
>
levels
)
{
mContext
-
>
ErrorInvalidOperation
(
"
The
texture
'
s
base
level
must
be
complete
.
"
)
;
return
;
}
const
auto
&
usage
=
completeness
-
>
usage
;
const
auto
&
format
=
usage
-
>
format
;
if
(
!
mContext
-
>
IsWebGL2
(
)
)
{
if
(
!
completeness
-
>
powerOfTwo
)
{
mContext
-
>
ErrorInvalidOperation
(
"
The
base
level
of
the
texture
does
not
"
"
have
power
-
of
-
two
dimensions
.
"
)
;
return
;
}
if
(
format
-
>
isSRGB
)
{
mContext
-
>
ErrorInvalidOperation
(
"
EXT_sRGB
forbids
GenerateMipmap
with
"
"
sRGB
.
"
)
;
return
;
}
}
if
(
format
-
>
compression
)
{
mContext
-
>
ErrorInvalidOperation
(
"
Texture
data
at
base
level
is
compressed
.
"
)
;
return
;
}
if
(
format
-
>
d
)
{
mContext
-
>
ErrorInvalidOperation
(
"
Depth
textures
are
not
supported
.
"
)
;
return
;
}
bool
canGenerateMipmap
=
(
usage
-
>
IsRenderable
(
)
&
&
usage
-
>
isFilterable
)
;
switch
(
usage
-
>
format
-
>
effectiveFormat
)
{
case
webgl
:
:
EffectiveFormat
:
:
Luminance8
:
case
webgl
:
:
EffectiveFormat
:
:
Alpha8
:
case
webgl
:
:
EffectiveFormat
:
:
Luminance8Alpha8
:
canGenerateMipmap
=
true
;
break
;
default
:
break
;
}
if
(
!
canGenerateMipmap
)
{
mContext
-
>
ErrorInvalidOperation
(
"
Texture
at
base
level
is
not
unsized
"
"
internal
format
or
is
not
"
"
color
-
renderable
or
texture
-
filterable
.
"
)
;
return
;
}
if
(
usage
-
>
IsRenderable
(
)
&
&
!
usage
-
>
IsExplicitlyRenderable
(
)
)
{
mContext
-
>
WarnIfImplicit
(
usage
-
>
GetExtensionID
(
)
)
;
}
gl
:
:
GLContext
*
gl
=
mContext
-
>
gl
;
if
(
gl
-
>
WorkAroundDriverBugs
(
)
)
{
if
(
mBaseMipmapLevelState
=
=
MIPMAP_LEVEL_DIRTY
)
{
gl
-
>
fTexParameteri
(
mTarget
.
get
(
)
LOCAL_GL_TEXTURE_BASE_LEVEL
ClampMipmapLevelForDriver
(
mBaseMipmapLevel
)
)
;
mBaseMipmapLevelState
=
MIPMAP_LEVEL_CLEAN
;
}
if
(
mMaxMipmapLevelState
=
=
MIPMAP_LEVEL_DIRTY
)
{
gl
-
>
fTexParameteri
(
mTarget
.
get
(
)
LOCAL_GL_TEXTURE_MAX_LEVEL
ClampMipmapLevelForDriver
(
mMaxMipmapLevel
)
)
;
mMaxMipmapLevelState
=
MIPMAP_LEVEL_CLEAN
;
}
gl
-
>
fTexParameteri
(
mTarget
.
get
(
)
LOCAL_GL_TEXTURE_MIN_FILTER
LOCAL_GL_NEAREST_MIPMAP_NEAREST
)
;
gl
-
>
fGenerateMipmap
(
mTarget
.
get
(
)
)
;
gl
-
>
fTexParameteri
(
mTarget
.
get
(
)
LOCAL_GL_TEXTURE_MIN_FILTER
mSamplingState
.
minFilter
.
get
(
)
)
;
}
else
{
gl
-
>
fGenerateMipmap
(
mTarget
.
get
(
)
)
;
}
const
auto
maxLevel
=
Es3_q
(
)
;
PopulateMipChain
(
maxLevel
)
;
}
Maybe
<
double
>
WebGLTexture
:
:
GetTexParameter
(
GLenum
pname
)
const
{
GLint
i
=
0
;
GLfloat
f
=
0
.
0f
;
switch
(
pname
)
{
case
LOCAL_GL_TEXTURE_BASE_LEVEL
:
return
Some
(
mBaseMipmapLevel
)
;
case
LOCAL_GL_TEXTURE_MAX_LEVEL
:
return
Some
(
mMaxMipmapLevel
)
;
case
LOCAL_GL_TEXTURE_IMMUTABLE_FORMAT
:
return
Some
(
mImmutable
)
;
case
LOCAL_GL_TEXTURE_IMMUTABLE_LEVELS
:
return
Some
(
uint32_t
(
mImmutableLevelCount
)
)
;
case
LOCAL_GL_TEXTURE_MIN_FILTER
:
case
LOCAL_GL_TEXTURE_MAG_FILTER
:
case
LOCAL_GL_TEXTURE_WRAP_S
:
case
LOCAL_GL_TEXTURE_WRAP_T
:
case
LOCAL_GL_TEXTURE_WRAP_R
:
case
LOCAL_GL_TEXTURE_COMPARE_MODE
:
case
LOCAL_GL_TEXTURE_COMPARE_FUNC
:
{
MOZ_ASSERT
(
mTarget
)
;
const
gl
:
:
ScopedBindTexture
autoTex
(
mContext
-
>
gl
mGLName
mTarget
.
get
(
)
)
;
mContext
-
>
gl
-
>
fGetTexParameteriv
(
mTarget
.
get
(
)
pname
&
i
)
;
return
Some
(
i
)
;
}
case
LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT
:
case
LOCAL_GL_TEXTURE_MAX_LOD
:
case
LOCAL_GL_TEXTURE_MIN_LOD
:
{
MOZ_ASSERT
(
mTarget
)
;
const
gl
:
:
ScopedBindTexture
autoTex
(
mContext
-
>
gl
mGLName
mTarget
.
get
(
)
)
;
mContext
-
>
gl
-
>
fGetTexParameterfv
(
mTarget
.
get
(
)
pname
&
f
)
;
return
Some
(
f
)
;
}
default
:
MOZ_CRASH
(
"
GFX
:
Unhandled
pname
.
"
)
;
}
}
void
WebGLTexture
:
:
TexParameter
(
TexTarget
texTarget
GLenum
pname
const
FloatOrInt
&
param
)
{
bool
isPNameValid
=
false
;
switch
(
pname
)
{
case
LOCAL_GL_TEXTURE_WRAP_S
:
case
LOCAL_GL_TEXTURE_WRAP_T
:
case
LOCAL_GL_TEXTURE_MIN_FILTER
:
case
LOCAL_GL_TEXTURE_MAG_FILTER
:
isPNameValid
=
true
;
break
;
case
LOCAL_GL_TEXTURE_BASE_LEVEL
:
case
LOCAL_GL_TEXTURE_COMPARE_MODE
:
case
LOCAL_GL_TEXTURE_COMPARE_FUNC
:
case
LOCAL_GL_TEXTURE_MAX_LEVEL
:
case
LOCAL_GL_TEXTURE_MAX_LOD
:
case
LOCAL_GL_TEXTURE_MIN_LOD
:
case
LOCAL_GL_TEXTURE_WRAP_R
:
if
(
mContext
-
>
IsWebGL2
(
)
)
isPNameValid
=
true
;
break
;
case
LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT
:
if
(
mContext
-
>
IsExtensionEnabled
(
WebGLExtensionID
:
:
EXT_texture_filter_anisotropic
)
)
isPNameValid
=
true
;
break
;
}
if
(
!
isPNameValid
)
{
mContext
-
>
ErrorInvalidEnumInfo
(
"
texParameter
:
pname
"
pname
)
;
return
;
}
bool
paramBadEnum
=
false
;
bool
paramBadValue
=
false
;
switch
(
pname
)
{
case
LOCAL_GL_TEXTURE_BASE_LEVEL
:
case
LOCAL_GL_TEXTURE_MAX_LEVEL
:
paramBadValue
=
(
param
.
i
<
0
)
;
break
;
case
LOCAL_GL_TEXTURE_COMPARE_MODE
:
paramBadValue
=
(
param
.
i
!
=
LOCAL_GL_NONE
&
&
param
.
i
!
=
LOCAL_GL_COMPARE_REF_TO_TEXTURE
)
;
break
;
case
LOCAL_GL_TEXTURE_COMPARE_FUNC
:
switch
(
param
.
i
)
{
case
LOCAL_GL_LEQUAL
:
case
LOCAL_GL_GEQUAL
:
case
LOCAL_GL_LESS
:
case
LOCAL_GL_GREATER
:
case
LOCAL_GL_EQUAL
:
case
LOCAL_GL_NOTEQUAL
:
case
LOCAL_GL_ALWAYS
:
case
LOCAL_GL_NEVER
:
break
;
default
:
paramBadValue
=
true
;
break
;
}
break
;
case
LOCAL_GL_TEXTURE_MIN_FILTER
:
switch
(
param
.
i
)
{
case
LOCAL_GL_NEAREST
:
case
LOCAL_GL_LINEAR
:
case
LOCAL_GL_NEAREST_MIPMAP_NEAREST
:
case
LOCAL_GL_LINEAR_MIPMAP_NEAREST
:
case
LOCAL_GL_NEAREST_MIPMAP_LINEAR
:
case
LOCAL_GL_LINEAR_MIPMAP_LINEAR
:
break
;
default
:
paramBadEnum
=
true
;
break
;
}
break
;
case
LOCAL_GL_TEXTURE_MAG_FILTER
:
switch
(
param
.
i
)
{
case
LOCAL_GL_NEAREST
:
case
LOCAL_GL_LINEAR
:
break
;
default
:
paramBadEnum
=
true
;
break
;
}
break
;
case
LOCAL_GL_TEXTURE_WRAP_S
:
case
LOCAL_GL_TEXTURE_WRAP_T
:
case
LOCAL_GL_TEXTURE_WRAP_R
:
switch
(
param
.
i
)
{
case
LOCAL_GL_CLAMP_TO_EDGE
:
case
LOCAL_GL_MIRRORED_REPEAT
:
case
LOCAL_GL_REPEAT
:
break
;
default
:
paramBadEnum
=
true
;
break
;
}
break
;
case
LOCAL_GL_TEXTURE_MAX_ANISOTROPY_EXT
:
if
(
param
.
f
<
1
.
0f
)
paramBadValue
=
true
;
break
;
}
if
(
paramBadEnum
)
{
if
(
!
param
.
isFloat
)
{
mContext
-
>
ErrorInvalidEnum
(
"
pname
0x
%
04x
:
Invalid
param
"
"
0x
%
04x
.
"
pname
param
.
i
)
;
}
else
{
mContext
-
>
ErrorInvalidEnum
(
"
pname
0x
%
04x
:
Invalid
param
%
g
.
"
pname
param
.
f
)
;
}
return
;
}
if
(
paramBadValue
)
{
if
(
!
param
.
isFloat
)
{
mContext
-
>
ErrorInvalidValue
(
"
pname
0x
%
04x
:
Invalid
param
%
i
"
"
(
0x
%
x
)
.
"
pname
param
.
i
param
.
i
)
;
}
else
{
mContext
-
>
ErrorInvalidValue
(
"
pname
0x
%
04x
:
Invalid
param
%
g
.
"
pname
param
.
f
)
;
}
return
;
}
FloatOrInt
clamped
=
param
;
bool
invalidate
=
true
;
switch
(
pname
)
{
case
LOCAL_GL_TEXTURE_BASE_LEVEL
:
{
mBaseMipmapLevel
=
clamped
.
i
;
mBaseMipmapLevelState
=
MIPMAP_LEVEL_CLEAN
;
ClampLevelBaseAndMax
(
)
;
clamped
=
FloatOrInt
(
ClampMipmapLevelForDriver
(
mBaseMipmapLevel
)
)
;
break
;
}
case
LOCAL_GL_TEXTURE_MAX_LEVEL
:
{
mMaxMipmapLevel
=
clamped
.
i
;
mMaxMipmapLevelState
=
MIPMAP_LEVEL_CLEAN
;
ClampLevelBaseAndMax
(
)
;
clamped
=
FloatOrInt
(
ClampMipmapLevelForDriver
(
mMaxMipmapLevel
)
)
;
break
;
}
case
LOCAL_GL_TEXTURE_MIN_FILTER
:
mSamplingState
.
minFilter
=
clamped
.
i
;
break
;
case
LOCAL_GL_TEXTURE_MAG_FILTER
:
mSamplingState
.
magFilter
=
clamped
.
i
;
break
;
case
LOCAL_GL_TEXTURE_WRAP_S
:
mSamplingState
.
wrapS
=
clamped
.
i
;
break
;
case
LOCAL_GL_TEXTURE_WRAP_T
:
mSamplingState
.
wrapT
=
clamped
.
i
;
break
;
case
LOCAL_GL_TEXTURE_COMPARE_MODE
:
mSamplingState
.
compareMode
=
clamped
.
i
;
break
;
default
:
invalidate
=
false
;
break
;
}
if
(
invalidate
)
{
InvalidateCaches
(
)
;
}
if
(
!
clamped
.
isFloat
)
{
mContext
-
>
gl
-
>
fTexParameteri
(
texTarget
.
get
(
)
pname
clamped
.
i
)
;
}
else
{
mContext
-
>
gl
-
>
fTexParameterf
(
texTarget
.
get
(
)
pname
clamped
.
f
)
;
}
}
void
WebGLTexture
:
:
Truncate
(
)
{
for
(
auto
&
cur
:
mImageInfoArr
)
{
cur
=
{
}
;
}
InvalidateCaches
(
)
;
}
}
