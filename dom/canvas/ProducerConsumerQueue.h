#
ifndef
mozilla_ipc_ProducerConsumerQueue_h
#
define
mozilla_ipc_ProducerConsumerQueue_h
1
#
include
<
atomic
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsString
.
h
"
#
include
"
CrossProcessSemaphore
.
h
"
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
typedef
uint32_t
PcqTypeInfoID
;
template
<
typename
T
>
struct
PcqTypeInfo
;
#
define
MAKE_PCQTYPEINFO
(
__TYPENAME
__TYPEID
)
\
template
<
>
\
struct
PcqTypeInfo
<
__TYPENAME
>
{
\
static
const
PcqTypeInfoID
ID
=
__TYPEID
;
\
}
;
MAKE_PCQTYPEINFO
(
bool
1
)
MAKE_PCQTYPEINFO
(
int8_t
2
)
MAKE_PCQTYPEINFO
(
uint8_t
3
)
MAKE_PCQTYPEINFO
(
int16_t
4
)
MAKE_PCQTYPEINFO
(
uint16_t
5
)
MAKE_PCQTYPEINFO
(
int32_t
6
)
MAKE_PCQTYPEINFO
(
uint32_t
7
)
MAKE_PCQTYPEINFO
(
int64_t
8
)
MAKE_PCQTYPEINFO
(
uint64_t
9
)
MAKE_PCQTYPEINFO
(
float
10
)
MAKE_PCQTYPEINFO
(
double
11
)
MAKE_PCQTYPEINFO
(
nsresult
20
)
MAKE_PCQTYPEINFO
(
nsString
21
)
MAKE_PCQTYPEINFO
(
nsCString
22
)
static
const
PcqTypeInfoID
PcqTypeInfo_UserStart
=
10000
;
}
namespace
mozilla
{
namespace
webgl
{
using
IPC
:
:
PcqTypeInfo
;
using
IPC
:
:
PcqTypeInfoID
;
extern
LazyLogModule
gPCQLog
;
#
define
PCQ_LOG_
(
lvl
.
.
.
)
MOZ_LOG
(
mozilla
:
:
webgl
:
:
gPCQLog
lvl
(
__VA_ARGS__
)
)
#
define
PCQ_LOGD
(
.
.
.
)
PCQ_LOG_
(
LogLevel
:
:
Debug
__VA_ARGS__
)
#
define
PCQ_LOGE
(
.
.
.
)
PCQ_LOG_
(
LogLevel
:
:
Error
__VA_ARGS__
)
struct
QueueStatus
{
enum
EStatus
{
kSuccess
kNotReady
kTypeError
kTooSmall
kFatalError
kOOMError
}
mValue
;
MOZ_IMPLICIT
QueueStatus
(
const
EStatus
status
=
kSuccess
)
:
mValue
(
status
)
{
}
explicit
operator
bool
(
)
const
{
return
mValue
=
=
kSuccess
;
}
explicit
operator
int
(
)
const
{
return
static_cast
<
int
>
(
mValue
)
;
}
bool
operator
=
=
(
const
EStatus
&
o
)
const
{
return
mValue
=
=
o
;
}
bool
operator
!
=
(
const
EStatus
&
o
)
const
{
return
!
(
*
this
=
=
o
)
;
}
}
;
inline
bool
IsSuccess
(
QueueStatus
status
)
{
return
status
=
=
QueueStatus
:
:
kSuccess
;
}
template
<
typename
T
>
struct
RemoveCVR
{
using
Type
=
std
:
:
remove_reference_t
<
std
:
:
remove_cv_t
<
T
>
>
;
}
;
template
<
typename
T
>
struct
IsTriviallySerializable
:
public
std
:
:
integral_constant
<
bool
std
:
:
is_enum
<
T
>
:
:
value
|
|
std
:
:
is_arithmetic
<
T
>
:
:
value
>
{
}
;
class
ProducerConsumerQueue
;
class
PcqProducer
;
class
PcqConsumer
;
template
<
typename
Arg
>
struct
QueueParamTraits
;
template
<
typename
Arg
>
struct
PcqTypedArg
{
explicit
PcqTypedArg
(
const
Arg
&
aArg
)
:
mWrite
(
&
aArg
)
mRead
(
nullptr
)
{
}
explicit
PcqTypedArg
(
Arg
*
aArg
)
:
mWrite
(
nullptr
)
mRead
(
aArg
)
{
}
private
:
friend
struct
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
;
const
Arg
*
mWrite
;
Arg
*
mRead
;
}
;
template
<
typename
_Producer
>
class
ProducerView
{
public
:
using
Producer
=
_Producer
;
ProducerView
(
Producer
*
aProducer
size_t
aRead
size_t
*
aWrite
)
:
mProducer
(
aProducer
)
mRead
(
aRead
)
mWrite
(
aWrite
)
mStatus
(
QueueStatus
:
:
kSuccess
)
{
}
inline
QueueStatus
Write
(
const
void
*
aBuffer
size_t
aBufferSize
)
;
template
<
typename
T
>
inline
QueueStatus
Write
(
const
T
*
src
size_t
count
)
{
return
Write
(
reinterpret_cast
<
const
void
*
>
(
src
)
count
*
sizeof
(
T
)
)
;
}
template
<
typename
Arg
>
QueueStatus
WriteParam
(
const
Arg
&
aArg
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Write
(
*
this
aArg
)
;
}
template
<
typename
Arg
>
QueueStatus
WriteTypedParam
(
const
Arg
&
aArg
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
:
:
Write
(
*
this
PcqTypedArg
<
Arg
>
(
aArg
)
)
;
}
template
<
typename
Arg
>
size_t
MinSizeParam
(
const
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
MinSize
(
*
this
aArg
)
;
}
inline
size_t
MinSizeBytes
(
size_t
aNBytes
)
;
QueueStatus
GetStatus
(
)
{
return
mStatus
;
}
private
:
Producer
*
mProducer
;
size_t
mRead
;
size_t
*
mWrite
;
QueueStatus
mStatus
;
}
;
template
<
typename
_Consumer
>
class
ConsumerView
{
public
:
using
Consumer
=
_Consumer
;
ConsumerView
(
Consumer
*
aConsumer
size_t
*
aRead
size_t
aWrite
)
:
mConsumer
(
aConsumer
)
mRead
(
aRead
)
mWrite
(
aWrite
)
mStatus
(
QueueStatus
:
:
kSuccess
)
{
}
using
PcqReadBytesVariant
=
Variant
<
QueueStatus
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
void
*
>
;
inline
QueueStatus
Read
(
void
*
aBuffer
size_t
aBufferSize
)
;
template
<
typename
T
>
inline
QueueStatus
Read
(
T
*
dest
size_t
count
)
{
return
Read
(
reinterpret_cast
<
void
*
>
(
dest
)
count
*
sizeof
(
T
)
)
;
}
template
<
typename
Matcher
>
inline
QueueStatus
ReadVariant
(
size_t
aBufferSize
Matcher
&
&
aMatcher
)
;
template
<
typename
Arg
>
QueueStatus
ReadParam
(
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Read
(
*
this
aArg
)
;
}
template
<
typename
Arg
>
QueueStatus
ReadTypedParam
(
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
:
:
Read
(
*
this
PcqTypedArg
(
aArg
)
)
;
}
template
<
typename
Arg
>
size_t
MinSizeParam
(
Arg
*
aArg
=
nullptr
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
MinSize
(
*
this
aArg
)
;
}
inline
size_t
MinSizeBytes
(
size_t
aNBytes
)
;
QueueStatus
GetStatus
(
)
{
return
mStatus
;
}
private
:
Consumer
*
mConsumer
;
size_t
*
mRead
;
size_t
mWrite
;
QueueStatus
mStatus
;
}
;
}
namespace
detail
{
using
IPC
:
:
PcqTypeInfo
;
using
IPC
:
:
PcqTypeInfoID
;
using
mozilla
:
:
ipc
:
:
Shmem
;
using
mozilla
:
:
webgl
:
:
IsSuccess
;
using
mozilla
:
:
webgl
:
:
ProducerConsumerQueue
;
using
mozilla
:
:
webgl
:
:
QueueStatus
;
constexpr
size_t
GetCacheLineSize
(
)
{
return
64
;
}
constexpr
size_t
GetMaxHeaderSize
(
)
{
constexpr
size_t
alignment
=
std
:
:
max
(
std
:
:
alignment_of
<
size_t
>
:
:
value
GetCacheLineSize
(
)
)
;
static_assert
(
alignment
>
=
sizeof
(
size_t
)
"
alignment
expected
to
be
large
enough
to
hold
a
size_t
"
)
;
constexpr
size_t
maxAlign1
=
alignment
-
1
;
constexpr
size_t
readAndAlign2
=
alignment
;
constexpr
size_t
writeAndAlign3
=
alignment
;
return
maxAlign1
+
readAndAlign2
+
writeAndAlign3
;
}
inline
size_t
UsedBytes
(
size_t
aQueueBufferSize
size_t
aRead
size_t
aWrite
)
{
return
(
aRead
<
=
aWrite
)
?
aWrite
-
aRead
:
(
aQueueBufferSize
-
aRead
)
+
aWrite
;
}
inline
size_t
FreeBytes
(
size_t
aQueueBufferSize
size_t
aRead
size_t
aWrite
)
{
return
(
aQueueBufferSize
-
1
)
-
UsedBytes
(
aQueueBufferSize
aRead
aWrite
)
;
}
template
<
typename
View
typename
Arg
typename
.
.
.
Args
>
size_t
MinSizeofArgs
(
View
&
aView
const
Arg
*
aArg
const
Args
*
.
.
.
aArgs
)
{
return
aView
.
MinSizeParam
(
aArg
)
+
MinSizeofArgs
(
aView
aArgs
.
.
.
)
;
}
template
<
typename
View
>
size_t
MinSizeofArgs
(
View
&
)
{
return
0
;
}
template
<
typename
View
typename
Arg1
typename
Arg2
typename
.
.
.
Args
>
size_t
MinSizeofArgs
(
View
&
aView
)
{
return
aView
.
template
MinSizeParam
<
Arg1
>
(
nullptr
)
+
MinSizeofArgs
<
Arg2
Args
.
.
.
>
(
aView
)
;
}
template
<
typename
View
typename
Arg
>
size_t
MinSizeofArgs
(
View
&
aView
)
{
return
aView
.
MinSizeParam
(
nullptr
)
;
}
inline
bool
NeedsSharedMemory
(
size_t
aRequested
size_t
aTotal
)
{
return
(
aTotal
/
16
)
<
aRequested
;
}
class
Marshaller
{
public
:
static
QueueStatus
WriteObject
(
uint8_t
*
aQueue
size_t
aQueueBufferSize
size_t
aRead
size_t
*
aWrite
const
void
*
aArg
size_t
aArgLength
)
{
const
uint8_t
*
buf
=
reinterpret_cast
<
const
uint8_t
*
>
(
aArg
)
;
if
(
FreeBytes
(
aQueueBufferSize
aRead
*
aWrite
)
<
aArgLength
)
{
return
QueueStatus
:
:
kNotReady
;
}
if
(
*
aWrite
+
aArgLength
<
=
aQueueBufferSize
)
{
memcpy
(
aQueue
+
*
aWrite
buf
aArgLength
)
;
}
else
{
size_t
firstLen
=
aQueueBufferSize
-
*
aWrite
;
memcpy
(
aQueue
+
*
aWrite
buf
firstLen
)
;
memcpy
(
aQueue
&
buf
[
firstLen
]
aArgLength
-
firstLen
)
;
}
*
aWrite
=
(
*
aWrite
+
aArgLength
)
%
aQueueBufferSize
;
return
QueueStatus
:
:
kSuccess
;
}
static
QueueStatus
ReadObject
(
const
uint8_t
*
aQueue
size_t
aQueueBufferSize
size_t
*
aRead
size_t
aWrite
void
*
aArg
size_t
aArgLength
)
{
if
(
UsedBytes
(
aQueueBufferSize
*
aRead
aWrite
)
<
aArgLength
)
{
return
QueueStatus
:
:
kNotReady
;
}
if
(
aArg
)
{
uint8_t
*
buf
=
reinterpret_cast
<
uint8_t
*
>
(
aArg
)
;
if
(
*
aRead
+
aArgLength
<
=
aQueueBufferSize
)
{
memcpy
(
buf
aQueue
+
*
aRead
aArgLength
)
;
}
else
{
size_t
firstLen
=
aQueueBufferSize
-
*
aRead
;
memcpy
(
buf
aQueue
+
*
aRead
firstLen
)
;
memcpy
(
&
buf
[
firstLen
]
aQueue
aArgLength
-
firstLen
)
;
}
}
*
aRead
=
(
*
aRead
+
aArgLength
)
%
aQueueBufferSize
;
return
QueueStatus
:
:
kSuccess
;
}
}
;
class
PcqRCSemaphore
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PcqRCSemaphore
)
explicit
PcqRCSemaphore
(
CrossProcessSemaphore
*
aSem
)
:
mSem
(
aSem
)
{
MOZ_ASSERT
(
mSem
)
;
}
bool
Wait
(
const
Maybe
<
TimeDuration
>
&
aTime
)
{
return
mSem
-
>
Wait
(
aTime
)
;
}
void
Signal
(
)
{
mSem
-
>
Signal
(
)
;
}
bool
IsAvailable
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unimplemented
"
)
;
return
false
;
}
CrossProcessSemaphoreHandle
ShareToProcess
(
base
:
:
ProcessId
aTargetPid
)
{
return
mSem
-
>
ShareToProcess
(
aTargetPid
)
;
}
void
CloseHandle
(
)
{
mSem
-
>
CloseHandle
(
)
;
}
private
:
~
PcqRCSemaphore
(
)
{
delete
mSem
;
}
CrossProcessSemaphore
*
mSem
;
}
;
class
PcqBase
{
public
:
size_t
UsedBytes
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
detail
:
:
UsedBytes
(
QueueBufferSize
(
)
aRead
aWrite
)
;
}
size_t
FreeBytes
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
detail
:
:
FreeBytes
(
QueueBufferSize
(
)
aRead
aWrite
)
;
}
bool
ValidState
(
size_t
aRead
size_t
aWrite
)
{
return
(
aRead
<
QueueBufferSize
(
)
)
&
&
(
aWrite
<
QueueBufferSize
(
)
)
;
}
bool
IsEmpty
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
UsedBytes
(
aRead
aWrite
)
=
=
0
;
}
bool
IsFull
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
FreeBytes
(
aRead
aWrite
)
=
=
0
;
}
size_t
UsedBytes
(
)
{
size_t
write
=
mWrite
-
>
load
(
std
:
:
memory_order_relaxed
)
;
size_t
read
=
mRead
-
>
load
(
std
:
:
memory_order_relaxed
)
;
return
UsedBytes
(
read
write
)
;
}
size_t
FreeBytes
(
)
{
return
QueueSize
(
)
-
UsedBytes
(
)
;
}
bool
IsEmpty
(
)
{
return
IsEmpty
(
GetReadRelaxed
(
)
GetWriteRelaxed
(
)
)
;
}
bool
IsFull
(
)
{
return
IsFull
(
GetReadRelaxed
(
)
GetWriteRelaxed
(
)
)
;
}
protected
:
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
PcqBase
>
;
friend
ProducerConsumerQueue
;
PcqBase
(
)
:
mOtherPid
(
0
)
mQueue
(
nullptr
)
mQueueBufferSize
(
0
)
mUserReservedMemory
(
nullptr
)
mUserReservedSize
(
0
)
mRead
(
nullptr
)
mWrite
(
nullptr
)
{
}
PcqBase
(
Shmem
&
aShmem
base
:
:
ProcessId
aOtherPid
size_t
aQueueSize
RefPtr
<
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
PcqRCSemaphore
>
aMaybeNotFullSem
)
{
Set
(
aShmem
aOtherPid
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
;
}
PcqBase
(
const
PcqBase
&
)
=
delete
;
PcqBase
(
PcqBase
&
&
)
=
default
;
PcqBase
&
operator
=
(
const
PcqBase
&
)
=
delete
;
PcqBase
&
operator
=
(
PcqBase
&
&
)
=
default
;
void
Set
(
Shmem
&
aShmem
base
:
:
ProcessId
aOtherPid
size_t
aQueueSize
RefPtr
<
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
PcqRCSemaphore
>
aMaybeNotFullSem
)
{
mOtherPid
=
aOtherPid
;
mShmem
=
aShmem
;
mQueue
=
aShmem
.
get
<
uint8_t
>
(
)
;
mQueueBufferSize
=
aQueueSize
+
1
;
size_t
shmemSize
=
aShmem
.
Size
<
uint8_t
>
(
)
;
uint8_t
*
header
=
mQueue
+
mQueueBufferSize
;
constexpr
size_t
alignment
=
std
:
:
max
(
std
:
:
alignment_of
<
size_t
>
:
:
value
GetCacheLineSize
(
)
)
;
static_assert
(
alignment
>
=
sizeof
(
size_t
)
"
alignment
expected
to
be
large
enough
to
hold
a
size_t
"
)
;
static_assert
(
(
alignment
&
(
alignment
-
1
)
)
=
=
0
"
alignment
must
be
a
power
of
2
"
)
;
constexpr
size_t
maxAlign1
=
alignment
-
1
;
uintptr_t
alignValue
=
reinterpret_cast
<
uintptr_t
>
(
header
+
maxAlign1
)
;
alignValue
&
=
~
(
alignment
-
1
)
;
uint8_t
*
metadata
=
reinterpret_cast
<
uint8_t
*
>
(
alignValue
)
;
mRead
=
new
(
metadata
)
std
:
:
atomic_size_t
;
mWrite
=
new
(
metadata
+
alignment
)
std
:
:
atomic_size_t
;
size_t
align1
=
metadata
-
header
;
MOZ_ASSERT
(
align1
<
=
maxAlign1
)
;
size_t
headerSize
=
align1
+
2
*
alignment
;
size_t
userSize
=
shmemSize
-
mQueueBufferSize
-
headerSize
;
if
(
userSize
>
0
)
{
mUserReservedMemory
=
mQueue
+
mQueueBufferSize
+
headerSize
;
mUserReservedSize
=
userSize
;
}
else
{
mUserReservedMemory
=
nullptr
;
mUserReservedSize
=
0
;
}
MOZ_ASSERT
(
aMaybeNotEmptySem
&
&
aMaybeNotFullSem
)
;
mMaybeNotEmptySem
=
aMaybeNotEmptySem
;
mMaybeNotFullSem
=
aMaybeNotFullSem
;
PCQ_LOGD
(
"
Created
queue
(
%
p
)
with
size
:
%
zu
alignment
:
%
zu
align1
:
%
zu
"
this
aQueueSize
alignment
align1
)
;
}
~
PcqBase
(
)
{
PCQ_LOGD
(
"
Destroying
queue
(
%
p
)
.
"
this
)
;
}
size_t
GetReadRelaxed
(
)
{
return
mRead
-
>
load
(
std
:
:
memory_order_relaxed
)
;
}
size_t
GetWriteRelaxed
(
)
{
return
mWrite
-
>
load
(
std
:
:
memory_order_relaxed
)
;
}
size_t
QueueSize
(
)
{
return
QueueBufferSize
(
)
-
1
;
}
size_t
QueueBufferSize
(
)
{
return
mQueueBufferSize
;
}
base
:
:
ProcessId
mOtherPid
;
uint8_t
*
mQueue
;
size_t
mQueueBufferSize
;
uint8_t
*
mUserReservedMemory
;
size_t
mUserReservedSize
;
std
:
:
atomic_size_t
*
mRead
;
std
:
:
atomic_size_t
*
mWrite
;
Shmem
mShmem
;
RefPtr
<
PcqRCSemaphore
>
mMaybeNotEmptySem
;
RefPtr
<
PcqRCSemaphore
>
mMaybeNotFullSem
;
}
;
}
namespace
webgl
{
using
mozilla
:
:
ipc
:
:
Shmem
;
class
PcqProducer
:
public
detail
:
:
PcqBase
{
public
:
PcqProducer
(
PcqProducer
&
&
aOther
)
=
default
;
PcqProducer
&
operator
=
(
PcqProducer
&
&
)
=
default
;
PcqProducer
(
)
=
default
;
size_t
Size
(
)
{
return
QueueSize
(
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryInsert
(
Args
&
&
.
.
.
aArgs
)
{
size_t
write
=
mWrite
-
>
load
(
std
:
:
memory_order_relaxed
)
;
const
size_t
initWrite
=
write
;
size_t
read
=
mRead
-
>
load
(
std
:
:
memory_order_acquire
)
;
if
(
!
ValidState
(
read
write
)
)
{
PCQ_LOGE
(
"
Queue
was
found
in
an
invalid
state
.
Queue
Size
:
%
zu
.
"
"
Read
:
%
zu
.
Write
:
%
zu
"
Size
(
)
read
write
)
;
return
QueueStatus
:
:
kFatalError
;
}
ProducerView
view
(
this
read
&
write
)
;
size_t
bytesNeeded
=
detail
:
:
MinSizeofArgs
(
view
&
aArgs
.
.
.
)
;
if
(
Size
(
)
<
bytesNeeded
)
{
PCQ_LOGE
(
"
Queue
is
too
small
for
objects
.
Queue
Size
:
%
zu
.
"
"
Needed
:
%
zu
"
Size
(
)
bytesNeeded
)
;
return
QueueStatus
:
:
kTooSmall
;
}
if
(
FreeBytes
(
read
write
)
<
bytesNeeded
)
{
PCQ_LOGD
(
"
Not
enough
room
to
insert
.
Has
:
%
zu
(
%
zu
%
zu
)
.
"
"
Needed
:
%
zu
"
FreeBytes
(
read
write
)
read
write
bytesNeeded
)
;
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
TryInsertHelper
(
view
aArgs
.
.
.
)
;
if
(
!
status
)
{
PCQ_LOGD
(
"
Failed
to
insert
with
error
(
%
d
)
.
Has
:
%
zu
(
%
zu
%
zu
)
.
"
"
Estimate
of
bytes
needed
:
%
zu
"
(
int
)
status
FreeBytes
(
read
write
)
read
write
bytesNeeded
)
;
return
status
;
}
MOZ_ASSERT
(
ValidState
(
read
write
)
)
;
bool
enoughBytes
=
UsedBytes
(
read
write
)
>
=
UsedBytes
(
read
(
initWrite
+
bytesNeeded
)
%
QueueBufferSize
(
)
)
;
MOZ_ASSERT
(
enoughBytes
)
;
if
(
!
enoughBytes
)
{
return
QueueStatus
:
:
kFatalError
;
}
PCQ_LOGD
(
"
Successfully
inserted
.
PcqProducer
used
%
zu
bytes
total
.
"
"
Write
index
:
%
zu
-
>
%
zu
"
bytesNeeded
initWrite
write
)
;
mWrite
-
>
store
(
write
std
:
:
memory_order_release
)
;
if
(
!
mMaybeNotEmptySem
-
>
IsAvailable
(
)
)
{
mMaybeNotEmptySem
-
>
Signal
(
)
;
}
return
status
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitInsert
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
&
.
.
.
aArgs
)
{
return
TryWaitInsertImpl
(
false
aDuration
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryTypedInsert
(
Args
&
&
.
.
.
aArgs
)
{
return
TryInsert
(
PcqTypedArg
<
Args
>
(
aArgs
)
.
.
.
)
;
}
protected
:
friend
ProducerConsumerQueue
;
friend
ProducerView
<
PcqProducer
>
;
template
<
typename
Arg
typename
.
.
.
Args
>
QueueStatus
TryInsertHelper
(
ProducerView
<
PcqProducer
>
&
aView
const
Arg
&
aArg
const
Args
&
.
.
.
aArgs
)
{
QueueStatus
status
=
TryInsertItem
(
aView
aArg
)
;
return
IsSuccess
(
status
)
?
TryInsertHelper
(
aView
aArgs
.
.
.
)
:
status
;
}
QueueStatus
TryInsertHelper
(
ProducerView
<
PcqProducer
>
&
)
{
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
Arg
>
QueueStatus
TryInsertItem
(
ProducerView
<
PcqProducer
>
&
aView
const
Arg
&
aArg
)
{
return
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Write
(
aView
aArg
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitInsertImpl
(
bool
aRecursed
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
&
.
.
.
aArgs
)
{
TimeStamp
start
(
TimeStamp
:
:
Now
(
)
)
;
if
(
aRecursed
&
&
(
!
mMaybeNotFullSem
-
>
Wait
(
aDuration
)
)
)
{
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
TryInsert
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
TimeStamp
now
;
if
(
aRecursed
&
&
IsSuccess
(
status
)
)
{
if
(
(
!
IsFull
(
)
)
&
&
(
!
mMaybeNotFullSem
-
>
IsAvailable
(
)
)
)
{
mMaybeNotFullSem
-
>
Signal
(
)
;
}
}
else
if
(
(
status
=
=
QueueStatus
:
:
kNotReady
)
&
&
(
aDuration
.
isNothing
(
)
|
|
(
(
now
=
TimeStamp
:
:
Now
(
)
)
-
start
)
<
aDuration
.
value
(
)
)
)
{
status
=
aDuration
.
isNothing
(
)
?
TryWaitInsertImpl
(
true
aDuration
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
:
TryWaitInsertImpl
(
true
Some
(
aDuration
.
value
(
)
-
(
now
-
start
)
)
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
return
status
;
}
template
<
typename
Arg
>
QueueStatus
WriteObject
(
size_t
aRead
size_t
*
aWrite
const
Arg
&
arg
size_t
aArgSize
)
{
return
mozilla
:
:
detail
:
:
Marshaller
:
:
WriteObject
(
mQueue
QueueBufferSize
(
)
aRead
aWrite
arg
aArgSize
)
;
}
PcqProducer
(
Shmem
&
aShmem
base
:
:
ProcessId
aOtherPid
size_t
aQueueSize
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotFullSem
)
:
PcqBase
(
aShmem
aOtherPid
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
{
*
mRead
=
0
;
*
mWrite
=
0
;
}
PcqProducer
(
const
PcqProducer
&
)
=
delete
;
PcqProducer
&
operator
=
(
const
PcqProducer
&
)
=
delete
;
}
;
class
PcqConsumer
:
public
detail
:
:
PcqBase
{
public
:
PcqConsumer
(
PcqConsumer
&
&
aOther
)
=
default
;
PcqConsumer
&
operator
=
(
PcqConsumer
&
&
)
=
default
;
PcqConsumer
(
)
=
default
;
size_t
Size
(
)
{
return
QueueSize
(
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryPeek
(
Args
&
.
.
.
aArgs
)
{
return
TryPeekOrRemove
<
false
Args
.
.
.
>
(
[
&
]
(
ConsumerView
<
PcqConsumer
>
&
aView
)
-
>
QueueStatus
{
return
TryPeekRemoveHelper
(
aView
&
aArgs
.
.
.
)
;
}
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryTypedPeek
(
Args
&
.
.
.
aArgs
)
{
return
TryPeek
(
PcqTypedArg
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryRemove
(
Args
&
.
.
.
aArgs
)
{
return
TryPeekOrRemove
<
true
Args
.
.
.
>
(
[
&
]
(
ConsumerView
<
PcqConsumer
>
&
aView
)
-
>
QueueStatus
{
return
TryPeekRemoveHelper
(
aView
&
aArgs
.
.
.
)
;
}
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryTypedRemove
(
Args
&
.
.
.
aArgs
)
{
return
TryRemove
(
PcqTypedArg
<
Args
>
(
&
aArgs
)
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryRemove
(
)
{
using
seq
=
std
:
:
index_sequence_for
<
Args
.
.
.
>
;
return
TryRemove
<
Args
.
.
.
>
(
seq
{
}
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryTypedRemove
(
)
{
return
TryRemove
<
PcqTypedArg
<
Args
>
.
.
.
>
(
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitPeek
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
.
.
.
aArgs
)
{
return
TryWaitPeekOrRemove
<
false
>
(
aDuration
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitRemove
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
.
.
.
aArgs
)
{
return
TryWaitPeekOrRemove
<
true
>
(
aDuration
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitRemove
(
const
Maybe
<
TimeDuration
>
&
aDuration
)
{
TimeStamp
start
(
TimeStamp
:
:
Now
(
)
)
;
if
(
!
mMaybeNotEmptySem
-
>
Wait
(
aDuration
)
)
{
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
TryRemove
<
Args
.
.
.
>
(
)
;
TimeStamp
now
;
if
(
IsSuccess
(
status
)
)
{
if
(
(
!
IsEmpty
(
)
)
&
&
(
!
mMaybeNotEmptySem
-
>
IsAvailable
(
)
)
)
{
mMaybeNotEmptySem
-
>
Signal
(
)
;
}
}
else
if
(
(
status
=
=
QueueStatus
:
:
kNotReady
)
&
&
(
aDuration
.
isNothing
(
)
|
|
(
(
now
=
TimeStamp
:
:
Now
(
)
)
-
start
)
<
aDuration
.
value
(
)
)
)
{
status
=
aDuration
.
isNothing
(
)
?
TryWaitRemove
<
Args
.
.
.
>
(
aDuration
)
:
TryWaitRemove
<
Args
.
.
.
>
(
Some
(
aDuration
.
value
(
)
-
(
now
-
start
)
)
)
;
}
return
status
;
}
protected
:
friend
ProducerConsumerQueue
;
friend
ConsumerView
<
PcqConsumer
>
;
using
PeekOrRemoveOperation
=
std
:
:
function
<
QueueStatus
(
ConsumerView
<
PcqConsumer
>
&
)
>
;
template
<
bool
isRemove
typename
.
.
.
Args
>
QueueStatus
TryPeekOrRemove
(
const
PeekOrRemoveOperation
&
aOperation
)
{
size_t
write
=
mWrite
-
>
load
(
std
:
:
memory_order_acquire
)
;
size_t
read
=
mRead
-
>
load
(
std
:
:
memory_order_relaxed
)
;
const
size_t
initRead
=
read
;
if
(
!
ValidState
(
read
write
)
)
{
PCQ_LOGE
(
"
Queue
was
found
in
an
invalid
state
.
Queue
Size
:
%
zu
.
"
"
Read
:
%
zu
.
Write
:
%
zu
"
Size
(
)
read
write
)
;
return
QueueStatus
:
:
kFatalError
;
}
ConsumerView
<
PcqConsumer
>
view
(
this
&
read
write
)
;
size_t
bytesNeeded
=
detail
:
:
MinSizeofArgs
(
view
)
;
if
(
Size
(
)
<
bytesNeeded
)
{
PCQ_LOGE
(
"
Queue
is
too
small
for
objects
.
Queue
Size
:
%
zu
.
"
"
Bytes
needed
:
%
zu
.
"
Size
(
)
bytesNeeded
)
;
return
QueueStatus
:
:
kTooSmall
;
}
if
(
UsedBytes
(
read
write
)
<
bytesNeeded
)
{
PCQ_LOGD
(
"
Not
enough
data
in
queue
.
Has
:
%
zu
(
%
zu
%
zu
)
.
"
"
Bytes
needed
:
%
zu
"
UsedBytes
(
read
write
)
read
write
bytesNeeded
)
;
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
aOperation
(
view
)
;
if
(
!
status
)
{
return
status
;
}
bool
enoughBytes
=
FreeBytes
(
read
write
)
>
=
FreeBytes
(
(
initRead
+
bytesNeeded
)
%
QueueBufferSize
(
)
write
)
;
MOZ_ASSERT
(
enoughBytes
)
;
if
(
!
enoughBytes
)
{
return
QueueStatus
:
:
kFatalError
;
}
MOZ_ASSERT
(
ValidState
(
read
write
)
)
;
PCQ_LOGD
(
"
Successfully
%
s
.
PcqConsumer
used
%
zu
bytes
total
.
"
"
Read
index
:
%
zu
-
>
%
zu
"
isRemove
?
"
removed
"
:
"
peeked
"
bytesNeeded
initRead
read
)
;
if
(
isRemove
)
{
mRead
-
>
store
(
read
std
:
:
memory_order_release
)
;
if
(
!
mMaybeNotFullSem
-
>
IsAvailable
(
)
)
{
mMaybeNotFullSem
-
>
Signal
(
)
;
}
}
return
status
;
}
template
<
typename
.
.
.
Args
size_t
.
.
.
Is
>
QueueStatus
TryRemove
(
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
std
:
:
tuple
<
Args
*
.
.
.
>
nullArgs
;
return
TryPeekOrRemove
<
true
Args
.
.
.
>
(
[
&
]
(
ConsumerView
<
PcqConsumer
>
&
aView
)
{
return
TryPeekRemoveHelper
(
aView
std
:
:
get
<
Is
>
(
nullArgs
)
.
.
.
)
;
}
)
;
}
template
<
bool
isRemove
typename
.
.
.
Args
>
QueueStatus
TryWaitPeekOrRemove
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
&
.
.
.
aArgs
)
{
return
TryWaitPeekOrRemoveImpl
<
isRemove
>
(
false
aDuration
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
bool
isRemove
typename
.
.
.
Args
>
QueueStatus
TryWaitPeekOrRemoveImpl
(
bool
aRecursed
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
.
.
.
aArgs
)
{
TimeStamp
start
(
TimeStamp
:
:
Now
(
)
)
;
if
(
aRecursed
&
&
(
!
mMaybeNotEmptySem
-
>
Wait
(
aDuration
)
)
)
{
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
isRemove
?
TryRemove
(
aArgs
.
.
.
)
:
TryPeek
(
aArgs
.
.
.
)
;
TimeStamp
now
;
if
(
aRecursed
&
&
IsSuccess
(
status
)
)
{
if
(
(
!
IsEmpty
(
)
)
&
&
(
!
mMaybeNotEmptySem
-
>
IsAvailable
(
)
)
)
{
mMaybeNotEmptySem
-
>
Signal
(
)
;
}
}
else
if
(
(
status
=
=
QueueStatus
:
:
kNotReady
)
&
&
(
aDuration
.
isNothing
(
)
|
|
(
(
now
=
TimeStamp
:
:
Now
(
)
)
-
start
)
<
aDuration
.
value
(
)
)
)
{
status
=
aDuration
.
isNothing
(
)
?
TryWaitPeekOrRemoveImpl
<
isRemove
>
(
true
aDuration
aArgs
.
.
.
)
:
TryWaitPeekOrRemoveImpl
<
isRemove
>
(
true
Some
(
aDuration
.
value
(
)
-
(
now
-
start
)
)
aArgs
.
.
.
)
;
}
return
status
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryPeekRemoveHelper
(
ConsumerView
<
PcqConsumer
>
&
aView
Args
*
.
.
.
aArgs
)
;
template
<
typename
Arg
typename
.
.
.
Args
>
QueueStatus
TryPeekRemoveHelper
(
ConsumerView
<
PcqConsumer
>
&
aView
Arg
*
aArg
Args
*
.
.
.
aArgs
)
{
QueueStatus
status
=
TryCopyOrSkipItem
<
Arg
>
(
aView
aArg
)
;
return
IsSuccess
(
status
)
?
TryPeekRemoveHelper
<
Args
.
.
.
>
(
aView
aArgs
.
.
.
)
:
status
;
}
template
<
>
QueueStatus
TryPeekRemoveHelper
(
ConsumerView
<
PcqConsumer
>
&
)
{
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
Arg
>
QueueStatus
TryCopyOrSkipItem
(
ConsumerView
<
PcqConsumer
>
&
aView
Arg
*
aArg
)
{
return
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Read
(
aView
const_cast
<
std
:
:
remove_cv_t
<
Arg
>
*
>
(
aArg
)
)
;
}
template
<
typename
Arg
>
QueueStatus
ReadObject
(
size_t
*
aRead
size_t
aWrite
Arg
*
arg
size_t
aArgSize
)
{
return
mozilla
:
:
detail
:
:
Marshaller
:
:
ReadObject
(
mQueue
QueueBufferSize
(
)
aRead
aWrite
arg
aArgSize
)
;
}
PcqConsumer
(
Shmem
&
aShmem
base
:
:
ProcessId
aOtherPid
size_t
aQueueSize
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotFullSem
)
:
PcqBase
(
aShmem
aOtherPid
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
{
}
PcqConsumer
(
const
PcqConsumer
&
)
=
delete
;
PcqConsumer
&
operator
=
(
const
PcqConsumer
&
)
=
delete
;
}
;
template
<
typename
T
>
QueueStatus
ProducerView
<
T
>
:
:
Write
(
const
void
*
aBuffer
size_t
aBufferSize
)
{
MOZ_ASSERT
(
aBuffer
&
&
(
aBufferSize
>
0
)
)
;
if
(
!
mStatus
)
{
return
mStatus
;
}
if
(
detail
:
:
NeedsSharedMemory
(
aBufferSize
mProducer
-
>
Size
(
)
)
)
{
auto
smem
=
MakeRefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
(
)
;
if
(
!
smem
-
>
Create
(
aBufferSize
)
|
|
!
smem
-
>
Map
(
aBufferSize
)
)
{
return
QueueStatus
:
:
kFatalError
;
}
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
handle
;
if
(
!
smem
-
>
ShareToProcess
(
mProducer
-
>
mOtherPid
&
handle
)
)
{
return
QueueStatus
:
:
kFatalError
;
}
memcpy
(
smem
-
>
memory
(
)
aBuffer
aBufferSize
)
;
smem
-
>
CloseHandle
(
)
;
return
WriteParam
(
handle
)
;
}
return
mProducer
-
>
WriteObject
(
mRead
mWrite
aBuffer
aBufferSize
)
;
}
template
<
typename
T
>
size_t
ProducerView
<
T
>
:
:
MinSizeBytes
(
size_t
aNBytes
)
{
return
detail
:
:
NeedsSharedMemory
(
aNBytes
mProducer
-
>
Size
(
)
)
?
MinSizeParam
(
(
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
)
nullptr
)
:
aNBytes
;
}
template
<
typename
T
>
QueueStatus
ConsumerView
<
T
>
:
:
Read
(
void
*
aBuffer
size_t
aBufferSize
)
{
struct
PcqReadBytesMatcher
{
QueueStatus
operator
(
)
(
RefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
&
smem
)
{
MOZ_ASSERT
(
smem
)
;
QueueStatus
ret
;
if
(
smem
-
>
memory
(
)
)
{
if
(
mBuffer
)
{
memcpy
(
mBuffer
smem
-
>
memory
(
)
mBufferSize
)
;
}
ret
=
QueueStatus
:
:
kSuccess
;
}
else
{
ret
=
QueueStatus
:
:
kFatalError
;
}
smem
-
>
CloseHandle
(
)
;
return
ret
;
}
QueueStatus
operator
(
)
(
)
{
return
mConsumer
.
ReadObject
(
mRead
mWrite
mBuffer
mBufferSize
)
;
}
Consumer
&
mConsumer
;
size_t
*
mRead
;
size_t
mWrite
;
void
*
mBuffer
;
size_t
mBufferSize
;
}
;
MOZ_ASSERT
(
aBufferSize
>
0
)
;
if
(
!
mStatus
)
{
return
mStatus
;
}
return
ReadVariant
(
aBufferSize
PcqReadBytesMatcher
{
*
(
this
-
>
mConsumer
)
mRead
mWrite
aBuffer
aBufferSize
}
)
;
}
template
<
typename
T
>
template
<
typename
Matcher
>
QueueStatus
ConsumerView
<
T
>
:
:
ReadVariant
(
size_t
aBufferSize
Matcher
&
&
aMatcher
)
{
if
(
!
mStatus
)
{
return
mStatus
;
}
if
(
detail
:
:
NeedsSharedMemory
(
aBufferSize
mConsumer
-
>
Size
(
)
)
)
{
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
handle
;
if
(
!
ReadParam
(
&
handle
)
)
{
return
GetStatus
(
)
;
}
auto
sharedMem
=
MakeRefPtr
<
mozilla
:
:
ipc
:
:
SharedMemoryBasic
>
(
)
;
if
(
!
sharedMem
-
>
IsHandleValid
(
handle
)
|
|
!
sharedMem
-
>
SetHandle
(
handle
mozilla
:
:
ipc
:
:
SharedMemory
:
:
RightsReadWrite
)
|
|
!
sharedMem
-
>
Map
(
aBufferSize
)
)
{
return
QueueStatus
:
:
kFatalError
;
}
return
aMatcher
(
sharedMem
)
;
}
return
aMatcher
(
)
;
}
template
<
typename
T
>
size_t
ConsumerView
<
T
>
:
:
MinSizeBytes
(
size_t
aNBytes
)
{
return
detail
:
:
NeedsSharedMemory
(
aNBytes
mConsumer
-
>
Size
(
)
)
?
MinSizeParam
(
(
mozilla
:
:
ipc
:
:
SharedMemoryBasic
:
:
Handle
*
)
nullptr
)
:
aNBytes
;
}
using
mozilla
:
:
detail
:
:
GetCacheLineSize
;
using
mozilla
:
:
detail
:
:
GetMaxHeaderSize
;
class
ProducerConsumerQueue
{
public
:
static
UniquePtr
<
ProducerConsumerQueue
>
Create
(
mozilla
:
:
ipc
:
:
IProtocol
*
aProtocol
size_t
aQueueSize
size_t
aAdditionalBytes
=
0
)
{
MOZ_ASSERT
(
aProtocol
)
;
Shmem
shmem
;
uint32_t
totalShmemSize
=
aQueueSize
+
1
+
GetMaxHeaderSize
(
)
+
aAdditionalBytes
;
if
(
!
aProtocol
-
>
AllocUnsafeShmem
(
totalShmemSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
TYPE_BASIC
&
shmem
)
)
{
return
nullptr
;
}
UniquePtr
<
ProducerConsumerQueue
>
ret
=
Create
(
shmem
aProtocol
-
>
OtherPid
(
)
aQueueSize
)
;
if
(
!
ret
)
{
return
ret
;
}
MOZ_ASSERT
(
ret
-
>
mProducer
-
>
mUserReservedSize
>
=
aAdditionalBytes
)
;
ret
-
>
mProducer
-
>
mUserReservedSize
=
aAdditionalBytes
;
ret
-
>
mConsumer
-
>
mUserReservedSize
=
aAdditionalBytes
;
if
(
aAdditionalBytes
=
=
0
)
{
ret
-
>
mProducer
-
>
mUserReservedMemory
=
nullptr
;
ret
-
>
mConsumer
-
>
mUserReservedMemory
=
nullptr
;
}
return
ret
;
}
static
UniquePtr
<
ProducerConsumerQueue
>
Create
(
Shmem
&
aShmem
base
:
:
ProcessId
aOtherPid
size_t
aQueueSize
)
{
uint32_t
totalShmemSize
=
aShmem
.
Size
<
uint8_t
>
(
)
;
if
(
(
!
aShmem
.
IsWritable
(
)
)
|
|
(
!
aShmem
.
IsReadable
(
)
)
|
|
(
(
GetMaxHeaderSize
(
)
+
aQueueSize
+
1
)
>
totalShmemSize
)
)
{
return
nullptr
;
}
auto
notempty
=
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
"
webgl
-
notempty
"
0
)
)
;
auto
notfull
=
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
"
webgl
-
notfull
"
1
)
)
;
return
WrapUnique
(
new
ProducerConsumerQueue
(
aShmem
aOtherPid
aQueueSize
notempty
notfull
)
)
;
}
static
constexpr
size_t
GetMaxHeaderSize
(
)
{
return
mozilla
:
:
detail
:
:
GetMaxHeaderSize
(
)
;
}
static
constexpr
size_t
GetCacheLineSize
(
)
{
return
mozilla
:
:
detail
:
:
GetCacheLineSize
(
)
;
}
using
Producer
=
PcqProducer
;
using
Consumer
=
PcqConsumer
;
UniquePtr
<
Producer
>
TakeProducer
(
)
{
return
std
:
:
move
(
mProducer
)
;
}
UniquePtr
<
Consumer
>
TakeConsumer
(
)
{
return
std
:
:
move
(
mConsumer
)
;
}
private
:
ProducerConsumerQueue
(
Shmem
&
aShmem
base
:
:
ProcessId
aOtherPid
size_t
aQueueSize
RefPtr
<
detail
:
:
PcqRCSemaphore
>
&
aMaybeNotEmptySem
RefPtr
<
detail
:
:
PcqRCSemaphore
>
&
aMaybeNotFullSem
)
:
mProducer
(
WrapUnique
(
new
Producer
(
aShmem
aOtherPid
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
)
)
mConsumer
(
WrapUnique
(
new
Consumer
(
aShmem
aOtherPid
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
)
)
{
PCQ_LOGD
(
"
Constructed
PCQ
(
%
p
)
.
Shmem
Size
=
%
zu
.
Queue
Size
=
%
zu
.
"
"
Other
process
ID
:
%
08x
.
"
this
aShmem
.
Size
<
uint8_t
>
(
)
aQueueSize
(
uint32_t
)
aOtherPid
)
;
}
UniquePtr
<
Producer
>
mProducer
;
UniquePtr
<
Consumer
>
mConsumer
;
}
;
}
namespace
ipc
{
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
detail
:
:
PcqBase
>
{
typedef
mozilla
:
:
detail
:
:
PcqBase
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
paramType
&
aParam
)
{
WriteIPDLParam
(
aMsg
aActor
aParam
.
QueueSize
(
)
)
;
WriteIPDLParam
(
aMsg
aActor
std
:
:
move
(
aParam
.
mShmem
)
)
;
MOZ_ASSERT
(
aActor
-
>
OtherPid
(
)
=
=
aParam
.
mOtherPid
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mMaybeNotEmptySem
-
>
ShareToProcess
(
aActor
-
>
OtherPid
(
)
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mMaybeNotFullSem
-
>
ShareToProcess
(
aActor
-
>
OtherPid
(
)
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
size_t
queueSize
;
Shmem
shmem
;
CrossProcessSemaphoreHandle
notEmptyHandle
;
CrossProcessSemaphoreHandle
notFullHandle
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
queueSize
)
|
|
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
shmem
)
|
|
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
notEmptyHandle
)
|
|
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
notFullHandle
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsHandleValid
(
notEmptyHandle
)
&
&
IsHandleValid
(
notFullHandle
)
)
;
aResult
-
>
Set
(
shmem
aActor
-
>
OtherPid
(
)
queueSize
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
notEmptyHandle
)
)
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
notFullHandle
)
)
)
;
return
true
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
IPDLParamTraits
<
Shmem
>
:
:
Log
(
aParam
.
mShmem
aLog
)
;
}
}
;
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
webgl
:
:
PcqProducer
>
:
public
IPDLParamTraits
<
mozilla
:
:
detail
:
:
PcqBase
>
{
typedef
mozilla
:
:
webgl
:
:
PcqProducer
paramType
;
}
;
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
webgl
:
:
PcqConsumer
>
:
public
IPDLParamTraits
<
mozilla
:
:
detail
:
:
PcqBase
>
{
typedef
mozilla
:
:
webgl
:
:
PcqConsumer
paramType
;
}
;
}
namespace
webgl
{
template
<
typename
Arg
>
struct
QueueParamTraits
<
PcqTypedArg
<
Arg
>
>
{
using
ParamType
=
PcqTypedArg
<
Arg
>
;
template
<
typename
U
PcqTypeInfoID
ArgTypeId
=
PcqTypeInfo
<
Arg
>
:
:
ID
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
MOZ_ASSERT
(
aArg
.
mWrite
)
;
aProducerView
.
WriteParam
(
ArgTypeId
)
;
return
aProducerView
.
WriteParam
(
*
aArg
.
mWrite
)
;
}
template
<
typename
U
PcqTypeInfoID
ArgTypeId
=
PcqTypeInfo
<
Arg
>
:
:
ID
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
MOZ_ASSERT
(
aArg
-
>
mRead
)
;
PcqTypeInfoID
typeId
;
if
(
!
aConsumerView
.
ReadParam
(
&
typeId
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
return
(
typeId
=
=
ArgTypeId
)
?
aConsumerView
.
ReadParam
(
aArg
)
:
QueueStatus
:
:
kTypeError
;
}
template
<
typename
View
>
static
constexpr
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
sizeof
(
PcqTypeInfoID
)
+
aView
.
MinSize
(
aArg
-
>
mWrite
?
aArg
-
>
mWrite
:
aArg
-
>
mRead
)
;
}
}
;
template
<
typename
Arg
>
struct
QueueParamTraits
{
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
Arg
&
aArg
)
{
static_assert
(
mozilla
:
:
webgl
:
:
template
IsTriviallySerializable
<
Arg
>
:
:
value
"
No
QueueParamTraits
specialization
was
found
for
this
type
"
"
and
it
does
not
satisfy
IsTriviallySerializable
.
"
)
;
return
aProducerView
.
Write
(
&
aArg
sizeof
(
Arg
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
Arg
*
aArg
)
{
static_assert
(
mozilla
:
:
webgl
:
:
template
IsTriviallySerializable
<
Arg
>
:
:
value
"
No
QueueParamTraits
specialization
was
found
for
this
type
"
"
and
it
does
not
satisfy
IsTriviallySerializable
.
"
)
;
return
aConsumerView
.
Read
(
aArg
sizeof
(
Arg
)
)
;
}
template
<
typename
View
>
static
constexpr
size_t
MinSize
(
View
&
aView
const
Arg
*
aArg
)
{
static_assert
(
mozilla
:
:
webgl
:
:
template
IsTriviallySerializable
<
Arg
>
:
:
value
"
No
QueueParamTraits
specialization
was
found
for
this
type
"
"
and
it
does
not
satisfy
IsTriviallySerializable
.
"
)
;
return
sizeof
(
Arg
)
;
}
}
;
template
<
>
struct
IsTriviallySerializable
<
QueueStatus
>
:
TrueType
{
}
;
template
<
>
struct
QueueParamTraits
<
nsACString
>
{
using
ParamType
=
nsACString
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
if
(
(
!
aProducerView
.
WriteParam
(
aArg
.
IsVoid
(
)
)
)
|
|
aArg
.
IsVoid
(
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
uint32_t
len
=
aArg
.
Length
(
)
;
if
(
(
!
aProducerView
.
WriteParam
(
len
)
)
|
|
(
len
=
=
0
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
return
aProducerView
.
Write
(
aArg
.
BeginReading
(
)
len
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isVoid
=
false
;
if
(
!
aConsumerView
.
ReadParam
(
&
isVoid
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
SetIsVoid
(
isVoid
)
;
}
if
(
isVoid
)
{
return
QueueStatus
:
:
kSuccess
;
}
uint32_t
len
=
0
;
if
(
!
aConsumerView
.
ReadParam
(
&
len
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
len
=
=
0
)
{
if
(
aArg
)
{
*
aArg
=
"
"
;
}
return
QueueStatus
:
:
kSuccess
;
}
char
*
buf
=
aArg
?
new
char
[
len
+
1
]
:
nullptr
;
if
(
aArg
&
&
(
!
buf
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
if
(
!
aConsumerView
.
Read
(
buf
len
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
buf
[
len
]
=
'
\
0
'
;
if
(
aArg
)
{
aArg
-
>
Adopt
(
buf
len
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
minSize
=
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
;
if
(
(
!
aArg
)
|
|
aArg
-
>
IsVoid
(
)
)
{
return
minSize
;
}
minSize
+
=
aView
.
template
MinSizeParam
<
uint32_t
>
(
nullptr
)
+
aView
.
MinSizeBytes
(
aArg
-
>
Length
(
)
)
;
return
minSize
;
}
}
;
template
<
>
struct
QueueParamTraits
<
nsAString
>
{
using
ParamType
=
nsAString
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
if
(
(
!
aProducerView
.
WriteParam
(
aArg
.
IsVoid
(
)
)
)
|
|
(
aArg
.
IsVoid
(
)
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
uint32_t
len
=
aArg
.
Length
(
)
;
if
(
(
!
aProducerView
.
WriteParam
(
len
)
)
|
|
(
len
=
=
0
)
)
{
return
aProducerView
.
GetStatus
(
)
;
}
constexpr
const
uint32_t
sizeofchar
=
sizeof
(
typename
ParamType
:
:
char_type
)
;
return
aProducerView
.
Write
(
aArg
.
BeginReading
(
)
len
*
sizeofchar
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isVoid
=
false
;
if
(
!
aConsumerView
.
ReadParam
(
&
isVoid
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
SetIsVoid
(
isVoid
)
;
}
if
(
isVoid
)
{
return
QueueStatus
:
:
kSuccess
;
}
uint32_t
len
=
0
;
if
(
!
aConsumerView
.
ReadParam
(
&
len
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
len
=
=
0
)
{
if
(
aArg
)
{
*
aArg
=
nsString
(
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
uint32_t
sizeofchar
=
sizeof
(
typename
ParamType
:
:
char_type
)
;
typename
ParamType
:
:
char_type
*
buf
=
nullptr
;
if
(
aArg
)
{
buf
=
static_cast
<
typename
ParamType
:
:
char_type
*
>
(
malloc
(
(
len
+
1
)
*
sizeofchar
)
)
;
if
(
!
buf
)
{
return
QueueStatus
:
:
kOOMError
;
}
}
if
(
!
aConsumerView
.
Read
(
buf
len
*
sizeofchar
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
buf
[
len
]
=
L
'
\
0
'
;
if
(
aArg
)
{
aArg
-
>
Adopt
(
buf
len
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
minSize
=
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
;
if
(
(
!
aArg
)
|
|
aArg
-
>
IsVoid
(
)
)
{
return
minSize
;
}
uint32_t
sizeofchar
=
sizeof
(
typename
ParamType
:
:
char_type
)
;
minSize
+
=
aView
.
template
MinSizeParam
<
uint32_t
>
(
nullptr
)
+
aView
.
MinSizeBytes
(
aArg
-
>
Length
(
)
*
sizeofchar
)
;
return
minSize
;
}
}
;
template
<
>
struct
QueueParamTraits
<
nsCString
>
:
public
QueueParamTraits
<
nsACString
>
{
using
ParamType
=
nsCString
;
}
;
template
<
>
struct
QueueParamTraits
<
nsString
>
:
public
QueueParamTraits
<
nsAString
>
{
using
ParamType
=
nsString
;
}
;
template
<
typename
NSTArrayType
bool
=
IsTriviallySerializable
<
typename
NSTArrayType
:
:
elem_type
>
:
:
value
>
struct
NSArrayQueueParamTraits
;
template
<
typename
_ElementType
>
struct
NSArrayQueueParamTraits
<
nsTArray
<
_ElementType
>
false
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
nsTArray
<
ElementType
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
size_t
arrayLen
=
aArg
.
Length
(
)
;
aProducerView
.
WriteParam
(
arrayLen
)
;
for
(
size_t
i
=
0
;
i
<
aArg
.
Length
(
)
;
+
+
i
)
{
aProducerView
.
WriteParam
(
aArg
[
i
]
)
;
}
return
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
size_t
arrayLen
;
if
(
!
aConsumerView
.
ReadParam
(
&
arrayLen
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
&
&
!
aArg
-
>
AppendElements
(
arrayLen
fallible
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
for
(
size_t
i
=
0
;
i
<
arrayLen
;
+
+
i
)
{
ElementType
*
elt
=
aArg
?
(
&
aArg
-
>
ElementAt
(
i
)
)
:
nullptr
;
aConsumerView
.
ReadParam
(
elt
)
;
}
return
aConsumerView
.
GetStatus
(
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
ret
=
aView
.
template
MinSizeParam
<
size_t
>
(
nullptr
)
;
if
(
!
aArg
)
{
return
ret
;
}
size_t
arrayLen
=
aArg
-
>
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
arrayLen
;
+
+
i
)
{
ret
+
=
aView
.
MinSizeParam
(
&
aArg
[
i
]
)
;
}
return
ret
;
}
}
;
template
<
typename
_ElementType
>
struct
NSArrayQueueParamTraits
<
nsTArray
<
_ElementType
>
true
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
nsTArray
<
ElementType
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
size_t
arrayLen
=
aArg
.
Length
(
)
;
aProducerView
.
WriteParam
(
arrayLen
)
;
return
aProducerView
.
Write
(
&
aArg
[
0
]
aArg
.
Length
(
)
*
sizeof
(
ElementType
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
size_t
arrayLen
;
if
(
!
aConsumerView
.
ReadParam
(
&
arrayLen
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
&
&
!
aArg
-
>
AppendElements
(
arrayLen
fallible
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
return
aConsumerView
.
Read
(
aArg
-
>
Elements
(
)
arrayLen
*
sizeof
(
ElementType
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
ret
=
aView
.
template
MinSizeParam
<
size_t
>
(
nullptr
)
;
if
(
!
aArg
)
{
return
ret
;
}
ret
+
=
aView
.
MinSizeBytes
(
aArg
-
>
Length
(
)
*
sizeof
(
ElementType
)
)
;
return
ret
;
}
}
;
template
<
typename
ElementType
>
struct
QueueParamTraits
<
nsTArray
<
ElementType
>
>
:
public
NSArrayQueueParamTraits
<
nsTArray
<
ElementType
>
>
{
using
ParamType
=
nsTArray
<
ElementType
>
;
}
;
template
<
typename
ArrayType
bool
=
IsTriviallySerializable
<
typename
ArrayType
:
:
ElementType
>
:
:
value
>
struct
ArrayQueueParamTraits
;
template
<
typename
_ElementType
size_t
Length
>
struct
ArrayQueueParamTraits
<
Array
<
_ElementType
Length
>
false
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
Array
<
ElementType
Length
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
for
(
size_t
i
=
0
;
i
<
Length
;
+
+
i
)
{
aProducerView
.
WriteParam
(
aArg
[
i
]
)
;
}
return
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
for
(
size_t
i
=
0
;
i
<
Length
;
+
+
i
)
{
ElementType
*
elt
=
aArg
?
(
&
(
(
*
aArg
)
[
i
]
)
)
:
nullptr
;
aConsumerView
.
ReadParam
(
elt
)
;
}
return
aConsumerView
.
GetStatus
(
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
size_t
ret
=
0
;
for
(
size_t
i
=
0
;
i
<
Length
;
+
+
i
)
{
ret
+
=
aView
.
MinSizeParam
(
&
(
(
*
aArg
)
[
i
]
)
)
;
}
return
ret
;
}
}
;
template
<
typename
_ElementType
size_t
Length
>
struct
ArrayQueueParamTraits
<
Array
<
_ElementType
Length
>
true
>
{
using
ElementType
=
_ElementType
;
using
ParamType
=
Array
<
ElementType
Length
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
return
aProducerView
.
Write
(
aArg
.
begin
(
)
sizeof
(
ElementType
[
Length
]
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
return
aConsumerView
.
Read
(
aArg
-
>
begin
(
)
sizeof
(
ElementType
[
Length
]
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
MinSizeBytes
(
sizeof
(
ElementType
[
Length
]
)
)
;
}
}
;
template
<
typename
ElementType
size_t
Length
>
struct
QueueParamTraits
<
Array
<
ElementType
Length
>
>
:
public
ArrayQueueParamTraits
<
Array
<
ElementType
Length
>
>
{
using
ParamType
=
Array
<
ElementType
Length
>
;
}
;
template
<
typename
ElementType
>
struct
QueueParamTraits
<
Maybe
<
ElementType
>
>
{
using
ParamType
=
Maybe
<
ElementType
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
static_cast
<
bool
>
(
aArg
)
)
;
return
aArg
?
aProducerView
.
WriteParam
(
aArg
.
ref
(
)
)
:
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isSome
;
if
(
!
aConsumerView
.
ReadParam
(
&
isSome
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
!
isSome
)
{
if
(
aArg
)
{
aArg
-
>
reset
(
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
if
(
!
aArg
)
{
return
aConsumerView
.
template
ReadParam
<
ElementType
>
(
nullptr
)
;
}
aArg
-
>
emplace
(
)
;
return
aConsumerView
.
ReadParam
(
aArg
-
>
ptr
(
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
+
(
(
aArg
&
&
aArg
-
>
isSome
(
)
)
?
aView
.
MinSizeParam
(
&
aArg
-
>
ref
(
)
)
:
0
)
;
}
}
;
template
<
typename
T
typename
.
.
.
Ts
>
struct
QueueParamTraits
<
Maybe
<
Variant
<
T
Ts
.
.
.
>
>
>
{
using
ParamType
=
Maybe
<
Variant
<
T
Ts
.
.
.
>
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
aArg
.
mIsSome
)
;
return
(
aArg
.
mIsSome
)
?
aProducerView
.
WriteParam
(
aArg
.
ref
(
)
)
:
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isSome
;
if
(
!
aConsumerView
.
ReadParam
(
&
isSome
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
!
isSome
)
{
if
(
aArg
)
{
aArg
-
>
reset
(
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
if
(
!
aArg
)
{
return
aConsumerView
.
template
ReadParam
<
Variant
<
T
Ts
.
.
.
>
>
(
nullptr
)
;
}
aArg
-
>
emplace
(
VariantType
<
T
>
(
)
)
;
return
aConsumerView
.
ReadParam
(
aArg
-
>
ptr
(
)
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
+
(
(
aArg
&
&
aArg
-
>
isSome
(
)
)
?
aView
.
MinSizeParam
(
&
aArg
-
>
ref
(
)
)
:
0
)
;
}
}
;
template
<
typename
TypeA
typename
TypeB
>
struct
QueueParamTraits
<
std
:
:
pair
<
TypeA
TypeB
>
>
{
using
ParamType
=
std
:
:
pair
<
TypeA
TypeB
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
aArg
.
first
(
)
)
;
return
aProducerView
.
WriteParam
(
aArg
.
second
(
)
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
aConsumerView
.
ReadParam
(
aArg
?
(
&
aArg
-
>
first
(
)
)
:
nullptr
)
;
return
aConsumerView
.
ReadParam
(
aArg
?
(
&
aArg
-
>
second
(
)
)
:
nullptr
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
MinSizeParam
(
aArg
?
aArg
-
>
first
:
nullptr
)
+
aView
.
MinSizeParam
(
aArg
?
aArg
-
>
second
:
nullptr
)
;
}
}
;
template
<
typename
T
>
struct
QueueParamTraits
<
UniquePtr
<
T
>
>
{
using
ParamType
=
UniquePtr
<
T
>
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
!
static_cast
<
bool
>
(
aArg
)
)
;
if
(
aArg
&
&
aProducerView
.
WriteParam
(
*
aArg
.
get
(
)
)
)
{
const_cast
<
ParamType
&
>
(
aArg
)
.
reset
(
)
;
}
return
aProducerView
.
GetStatus
(
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
bool
isNull
;
if
(
!
aConsumerView
.
ReadParam
(
&
isNull
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
isNull
)
{
if
(
aArg
)
{
aArg
-
>
reset
(
nullptr
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
T
*
obj
=
nullptr
;
if
(
aArg
)
{
obj
=
new
T
(
)
;
if
(
!
obj
)
{
return
QueueStatus
:
:
kOOMError
;
}
aArg
-
>
reset
(
obj
)
;
}
return
aConsumerView
.
ReadParam
(
obj
)
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
if
(
(
!
aArg
)
|
|
(
!
aArg
-
>
get
(
)
)
)
{
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
;
}
return
aView
.
template
MinSizeParam
<
bool
>
(
nullptr
)
+
aView
.
MinSizeParam
(
aArg
-
>
get
(
)
)
;
}
}
;
#
if
defined
(
OS_WIN
)
template
<
>
struct
IsTriviallySerializable
<
base
:
:
SharedMemoryHandle
>
:
std
:
:
true_type
{
}
;
#
elif
defined
(
OS_POSIX
)
template
<
>
struct
QueueParamTraits
<
base
:
:
FileDescriptor
>
{
using
ParamType
=
base
:
:
FileDescriptor
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
return
aProducerView
.
WriteParam
(
aArg
.
fd
>
0
?
aArg
.
fd
:
-
1
)
;
}
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
int
fd
;
if
(
!
aConsumerView
.
ReadParam
(
aArg
?
&
fd
:
nullptr
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
fd
=
fd
;
aArg
-
>
auto_close
=
false
;
}
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
return
aView
.
MinSizeParam
(
aArg
?
&
aArg
-
>
fd
:
nullptr
)
;
}
}
;
#
endif
template
<
typename
U
>
struct
PcqVariantWriter
{
ProducerView
<
U
>
&
mView
;
template
<
typename
T
>
QueueStatus
match
(
const
T
&
x
)
{
return
mView
.
WriteParam
(
x
)
;
}
}
;
template
<
typename
.
.
.
Types
>
struct
QueueParamTraits
<
Variant
<
Types
.
.
.
>
>
{
using
ParamType
=
Variant
<
Types
.
.
.
>
;
using
Tag
=
typename
mozilla
:
:
detail
:
:
VariantTag
<
Types
.
.
.
>
:
:
Type
;
template
<
typename
U
>
static
QueueStatus
Write
(
ProducerView
<
U
>
&
aProducerView
const
ParamType
&
aArg
)
{
aProducerView
.
WriteParam
(
aArg
.
tag
)
;
return
aArg
.
match
(
PcqVariantWriter
{
aProducerView
}
)
;
}
template
<
size_t
N
typename
dummy
=
void
>
struct
VariantReader
{
using
Next
=
VariantReader
<
N
-
1
>
;
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aView
Tag
aTag
ParamType
*
aArg
)
{
if
(
aTag
=
=
N
-
1
)
{
using
EntryType
=
typename
mozilla
:
:
detail
:
:
Nth
<
N
-
1
Types
.
.
.
>
:
:
Type
;
if
(
aArg
)
{
return
aView
.
ReadParam
(
static_cast
<
EntryType
*
>
(
aArg
-
>
ptr
(
)
)
)
;
}
return
aView
.
template
ReadParam
<
EntryType
>
(
)
;
}
return
Next
:
:
Read
(
aView
aTag
aArg
)
;
}
}
;
template
<
typename
dummy
>
struct
VariantReader
<
0
dummy
>
{
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aView
Tag
aTag
ParamType
*
aArg
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Tag
wasn
'
t
for
an
entry
in
this
Variant
"
)
;
return
QueueStatus
:
:
kFatalError
;
}
}
;
template
<
typename
U
>
static
QueueStatus
Read
(
ConsumerView
<
U
>
&
aConsumerView
ParamType
*
aArg
)
{
Tag
tag
;
if
(
!
aConsumerView
.
ReadParam
(
&
tag
)
)
{
return
aConsumerView
.
GetStatus
(
)
;
}
if
(
aArg
)
{
aArg
-
>
tag
=
tag
;
}
return
VariantReader
<
sizeof
.
.
.
(
Types
)
>
:
:
Read
(
aConsumerView
tag
aArg
)
;
}
template
<
size_t
N
typename
View
>
struct
MinSizeVariant
{
using
Next
=
MinSizeVariant
<
N
-
1
View
>
;
static
size_t
MinSize
(
View
&
aView
const
Tag
*
aTag
const
ParamType
*
aArg
)
{
using
EntryType
=
typename
mozilla
:
:
detail
:
:
Nth
<
N
-
1
Types
.
.
.
>
:
:
Type
;
if
(
!
aArg
)
{
return
std
:
:
min
(
aView
.
template
MinSizeParam
<
EntryType
>
(
)
Next
:
:
MinSize
(
aView
aTag
aArg
)
)
;
}
MOZ_ASSERT
(
aTag
)
;
if
(
*
aTag
=
=
N
-
1
)
{
return
aView
.
MinSizeParam
(
&
aArg
-
>
template
as
<
EntryType
>
(
)
)
;
}
return
Next
:
:
MinSize
(
aView
aTag
aArg
)
;
}
}
;
template
<
typename
View
>
struct
MinSizeVariant
<
0
View
>
{
static
size_t
MinSize
(
View
&
aView
const
Tag
*
aTag
const
ParamType
*
aArg
)
{
if
(
!
aArg
)
{
return
0
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Tag
wasn
'
t
for
an
entry
in
this
Variant
"
)
;
return
0
;
}
}
;
template
<
typename
View
>
static
size_t
MinSize
(
View
&
aView
const
ParamType
*
aArg
)
{
const
Tag
*
tag
=
aArg
?
&
aArg
-
>
tag
:
nullptr
;
return
aView
.
MinSizeParam
(
tag
)
+
MinSizeVariant
<
sizeof
.
.
.
(
Types
)
View
>
:
:
MinSize
(
aView
tag
aArg
)
;
}
}
;
}
}
#
endif
