#
ifndef
mozilla_ipc_ProducerConsumerQueue_h
#
define
mozilla_ipc_ProducerConsumerQueue_h
1
#
include
<
atomic
>
#
include
<
tuple
>
#
include
<
type_traits
>
#
include
<
utility
>
#
include
<
vector
>
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
dom
/
QueueParamTraits
.
h
"
#
include
"
CrossProcessSemaphore
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
webgl
{
using
mozilla
:
:
ipc
:
:
IProtocol
;
using
mozilla
:
:
ipc
:
:
Shmem
;
extern
LazyLogModule
gPCQLog
;
#
define
PCQ_LOG_
(
lvl
.
.
.
)
MOZ_LOG
(
mozilla
:
:
webgl
:
:
gPCQLog
lvl
(
__VA_ARGS__
)
)
#
define
PCQ_LOGD
(
.
.
.
)
PCQ_LOG_
(
LogLevel
:
:
Debug
__VA_ARGS__
)
#
define
PCQ_LOGE
(
.
.
.
)
PCQ_LOG_
(
LogLevel
:
:
Error
__VA_ARGS__
)
class
ProducerConsumerQueue
;
class
PcqProducer
;
class
PcqConsumer
;
class
PcqActor
:
public
SupportsWeakPtr
<
PcqActor
>
{
IProtocol
*
mProtocol
;
inline
static
std
:
:
unordered_map
<
IProtocol
*
PcqActor
*
>
sMap
;
static
bool
IsActorThread
(
)
{
static
nsIThread
*
sActorThread
=
[
]
{
return
NS_GetCurrentThread
(
)
;
}
(
)
;
return
sActorThread
=
=
NS_GetCurrentThread
(
)
;
}
protected
:
explicit
PcqActor
(
IProtocol
*
aProtocol
)
:
mProtocol
(
aProtocol
)
{
MOZ_ASSERT
(
IsActorThread
(
)
)
;
sMap
.
insert
(
{
mProtocol
this
}
)
;
}
~
PcqActor
(
)
{
MOZ_ASSERT
(
IsActorThread
(
)
)
;
sMap
.
erase
(
mProtocol
)
;
}
public
:
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
PcqActor
)
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
int32_t
aId
)
{
return
mProtocol
-
>
LookupSharedMemory
(
aId
)
;
}
int32_t
Id
(
)
const
{
return
mProtocol
-
>
Id
(
)
;
}
base
:
:
ProcessId
OtherPid
(
)
const
{
return
mProtocol
-
>
OtherPid
(
)
;
}
bool
AllocShmem
(
size_t
aSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
aShmType
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
)
{
return
mProtocol
-
>
AllocShmem
(
aSize
aShmType
aShmem
)
;
}
static
PcqActor
*
LookupProtocol
(
IProtocol
*
aProtocol
)
{
MOZ_ASSERT
(
IsActorThread
(
)
)
;
auto
it
=
sMap
.
find
(
aProtocol
)
;
return
(
it
!
=
sMap
.
end
(
)
)
?
it
-
>
second
:
nullptr
;
}
}
;
}
namespace
detail
{
using
mozilla
:
:
ipc
:
:
IProtocol
;
using
mozilla
:
:
ipc
:
:
Shmem
;
using
mozilla
:
:
webgl
:
:
IsSuccess
;
using
mozilla
:
:
webgl
:
:
PcqActor
;
using
mozilla
:
:
webgl
:
:
ProducerConsumerQueue
;
using
mozilla
:
:
webgl
:
:
QueueStatus
;
constexpr
size_t
GetCacheLineSize
(
)
{
return
64
;
}
constexpr
size_t
GetMaxHeaderSize
(
)
{
constexpr
size_t
alignment
=
std
:
:
max
(
std
:
:
alignment_of
<
size_t
>
:
:
value
GetCacheLineSize
(
)
)
;
static_assert
(
alignment
>
=
sizeof
(
size_t
)
"
alignment
expected
to
be
large
enough
to
hold
a
size_t
"
)
;
constexpr
size_t
maxAlign1
=
alignment
-
1
;
constexpr
size_t
readAndAlign2
=
alignment
;
constexpr
size_t
writeAndAlign3
=
alignment
;
return
maxAlign1
+
readAndAlign2
+
writeAndAlign3
;
}
template
<
typename
View
typename
Arg
typename
.
.
.
Args
>
size_t
MinSizeofArgs
(
View
&
aView
const
Arg
*
aArg
const
Args
*
.
.
.
aArgs
)
{
return
aView
.
MinSizeParam
(
aArg
)
+
MinSizeofArgs
(
aView
aArgs
.
.
.
)
;
}
template
<
typename
View
>
size_t
MinSizeofArgs
(
View
&
)
{
return
0
;
}
template
<
typename
View
typename
Arg1
typename
Arg2
typename
.
.
.
Args
>
size_t
MinSizeofArgs
(
View
&
aView
)
{
return
aView
.
template
MinSizeParam
<
Arg1
>
(
nullptr
)
+
MinSizeofArgs
<
Arg2
Args
.
.
.
>
(
aView
)
;
}
template
<
typename
View
typename
Arg
>
size_t
MinSizeofArgs
(
View
&
aView
)
{
return
aView
.
MinSizeParam
(
nullptr
)
;
}
class
PcqRCSemaphore
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
PcqRCSemaphore
)
explicit
PcqRCSemaphore
(
CrossProcessSemaphore
*
aSem
)
:
mSem
(
aSem
)
{
MOZ_ASSERT
(
mSem
)
;
}
bool
Wait
(
const
Maybe
<
TimeDuration
>
&
aTime
)
{
return
mSem
-
>
Wait
(
aTime
)
;
}
void
Signal
(
)
{
mSem
-
>
Signal
(
)
;
}
bool
IsAvailable
(
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unimplemented
"
)
;
return
false
;
}
CrossProcessSemaphoreHandle
ShareToProcess
(
base
:
:
ProcessId
aTargetPid
)
{
return
mSem
-
>
ShareToProcess
(
aTargetPid
)
;
}
void
CloseHandle
(
)
{
mSem
-
>
CloseHandle
(
)
;
}
private
:
~
PcqRCSemaphore
(
)
{
delete
mSem
;
}
CrossProcessSemaphore
*
mSem
;
}
;
class
PcqBase
{
public
:
size_t
UsedBytes
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
mozilla
:
:
webgl
:
:
UsedBytes
(
QueueBufferSize
(
)
aRead
aWrite
)
;
}
size_t
FreeBytes
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
mozilla
:
:
webgl
:
:
FreeBytes
(
QueueBufferSize
(
)
aRead
aWrite
)
;
}
bool
ValidState
(
size_t
aRead
size_t
aWrite
)
{
return
(
aRead
<
QueueBufferSize
(
)
)
&
&
(
aWrite
<
QueueBufferSize
(
)
)
;
}
bool
IsEmpty
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
UsedBytes
(
aRead
aWrite
)
=
=
0
;
}
bool
IsFull
(
size_t
aRead
size_t
aWrite
)
{
MOZ_ASSERT
(
ValidState
(
aRead
aWrite
)
)
;
return
FreeBytes
(
aRead
aWrite
)
=
=
0
;
}
size_t
UsedBytes
(
)
{
size_t
write
=
mWrite
-
>
load
(
std
:
:
memory_order_relaxed
)
;
size_t
read
=
mRead
-
>
load
(
std
:
:
memory_order_relaxed
)
;
return
UsedBytes
(
read
write
)
;
}
size_t
FreeBytes
(
)
{
return
QueueSize
(
)
-
UsedBytes
(
)
;
}
bool
IsEmpty
(
)
{
return
IsEmpty
(
GetReadRelaxed
(
)
GetWriteRelaxed
(
)
)
;
}
bool
IsFull
(
)
{
return
IsFull
(
GetReadRelaxed
(
)
GetWriteRelaxed
(
)
)
;
}
protected
:
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
PcqBase
>
;
friend
ProducerConsumerQueue
;
PcqBase
(
)
=
default
;
PcqBase
(
Shmem
&
aShmem
IProtocol
*
aProtocol
size_t
aQueueSize
RefPtr
<
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
PcqRCSemaphore
>
aMaybeNotFullSem
)
{
Set
(
aShmem
aProtocol
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
;
}
PcqBase
(
const
PcqBase
&
)
=
delete
;
PcqBase
(
PcqBase
&
&
)
=
default
;
PcqBase
&
operator
=
(
const
PcqBase
&
)
=
delete
;
PcqBase
&
operator
=
(
PcqBase
&
&
)
=
default
;
void
Set
(
Shmem
&
aShmem
IProtocol
*
aProtocol
size_t
aQueueSize
RefPtr
<
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
PcqRCSemaphore
>
aMaybeNotFullSem
)
{
mActor
=
PcqActor
:
:
LookupProtocol
(
aProtocol
)
;
MOZ_RELEASE_ASSERT
(
mActor
)
;
mOtherPid
=
mActor
-
>
OtherPid
(
)
;
mShmem
=
aShmem
;
mQueue
=
aShmem
.
get
<
uint8_t
>
(
)
;
mQueueBufferSize
=
aQueueSize
+
1
;
size_t
shmemSize
=
aShmem
.
Size
<
uint8_t
>
(
)
;
uint8_t
*
header
=
mQueue
+
mQueueBufferSize
;
constexpr
size_t
alignment
=
std
:
:
max
(
std
:
:
alignment_of
<
size_t
>
:
:
value
GetCacheLineSize
(
)
)
;
static_assert
(
alignment
>
=
sizeof
(
size_t
)
"
alignment
expected
to
be
large
enough
to
hold
a
size_t
"
)
;
static_assert
(
(
alignment
&
(
alignment
-
1
)
)
=
=
0
"
alignment
must
be
a
power
of
2
"
)
;
constexpr
size_t
maxAlign1
=
alignment
-
1
;
uintptr_t
alignValue
=
reinterpret_cast
<
uintptr_t
>
(
header
+
maxAlign1
)
;
alignValue
&
=
~
(
alignment
-
1
)
;
uint8_t
*
metadata
=
reinterpret_cast
<
uint8_t
*
>
(
alignValue
)
;
mRead
=
new
(
metadata
)
std
:
:
atomic_size_t
;
mWrite
=
new
(
metadata
+
alignment
)
std
:
:
atomic_size_t
;
size_t
align1
=
metadata
-
header
;
MOZ_ASSERT
(
align1
<
=
maxAlign1
)
;
size_t
headerSize
=
align1
+
2
*
alignment
;
size_t
userSize
=
shmemSize
-
mQueueBufferSize
-
headerSize
;
if
(
userSize
>
0
)
{
mUserReservedMemory
=
mQueue
+
mQueueBufferSize
+
headerSize
;
mUserReservedSize
=
userSize
;
}
else
{
mUserReservedMemory
=
nullptr
;
mUserReservedSize
=
0
;
}
MOZ_ASSERT
(
aMaybeNotEmptySem
&
&
aMaybeNotFullSem
)
;
mMaybeNotEmptySem
=
aMaybeNotEmptySem
;
mMaybeNotFullSem
=
aMaybeNotFullSem
;
PCQ_LOGD
(
"
Created
queue
(
%
p
)
with
size
:
%
zu
alignment
:
%
zu
align1
:
%
zu
"
this
aQueueSize
alignment
align1
)
;
}
~
PcqBase
(
)
{
PCQ_LOGD
(
"
Destroying
queue
(
%
p
)
.
"
this
)
;
}
size_t
GetReadRelaxed
(
)
{
return
mRead
-
>
load
(
std
:
:
memory_order_relaxed
)
;
}
size_t
GetWriteRelaxed
(
)
{
return
mWrite
-
>
load
(
std
:
:
memory_order_relaxed
)
;
}
size_t
QueueSize
(
)
{
return
QueueBufferSize
(
)
-
1
;
}
size_t
QueueBufferSize
(
)
{
return
mQueueBufferSize
;
}
WeakPtr
<
PcqActor
>
mActor
;
base
:
:
ProcessId
mOtherPid
=
0
;
uint8_t
*
mQueue
=
nullptr
;
size_t
mQueueBufferSize
=
0
;
uint8_t
*
mUserReservedMemory
=
nullptr
;
size_t
mUserReservedSize
=
0
;
std
:
:
atomic_size_t
*
mRead
=
nullptr
;
std
:
:
atomic_size_t
*
mWrite
=
nullptr
;
Shmem
mShmem
;
RefPtr
<
PcqRCSemaphore
>
mMaybeNotEmptySem
;
RefPtr
<
PcqRCSemaphore
>
mMaybeNotFullSem
;
}
;
}
namespace
webgl
{
using
mozilla
:
:
ipc
:
:
Shmem
;
class
PcqProducer
:
public
detail
:
:
PcqBase
{
public
:
PcqProducer
(
PcqProducer
&
&
aOther
)
=
default
;
PcqProducer
&
operator
=
(
PcqProducer
&
&
)
=
default
;
PcqProducer
(
)
=
default
;
size_t
Size
(
)
{
return
QueueSize
(
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryInsert
(
Args
&
&
.
.
.
aArgs
)
{
size_t
write
=
mWrite
-
>
load
(
std
:
:
memory_order_relaxed
)
;
const
size_t
initWrite
=
write
;
size_t
read
=
mRead
-
>
load
(
std
:
:
memory_order_acquire
)
;
if
(
!
ValidState
(
read
write
)
)
{
PCQ_LOGE
(
"
Queue
was
found
in
an
invalid
state
.
Queue
Size
:
%
zu
.
"
"
Read
:
%
zu
.
Write
:
%
zu
"
Size
(
)
read
write
)
;
return
QueueStatus
:
:
kFatalError
;
}
ProducerView
view
(
this
read
&
write
)
;
size_t
bytesNeeded
=
detail
:
:
MinSizeofArgs
(
view
&
aArgs
.
.
.
)
;
if
(
Size
(
)
<
bytesNeeded
)
{
PCQ_LOGE
(
"
Queue
is
too
small
for
objects
.
Queue
Size
:
%
zu
.
"
"
Needed
:
%
zu
"
Size
(
)
bytesNeeded
)
;
return
QueueStatus
:
:
kTooSmall
;
}
if
(
FreeBytes
(
read
write
)
<
bytesNeeded
)
{
PCQ_LOGD
(
"
Not
enough
room
to
insert
.
Has
:
%
zu
(
%
zu
%
zu
)
.
"
"
Needed
:
%
zu
"
FreeBytes
(
read
write
)
read
write
bytesNeeded
)
;
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
TryInsertHelper
(
view
aArgs
.
.
.
)
;
if
(
!
status
)
{
PCQ_LOGD
(
"
Failed
to
insert
with
error
(
%
d
)
.
Has
:
%
zu
(
%
zu
%
zu
)
.
"
"
Estimate
of
bytes
needed
:
%
zu
"
(
int
)
status
FreeBytes
(
read
write
)
read
write
bytesNeeded
)
;
return
status
;
}
MOZ_ASSERT
(
ValidState
(
read
write
)
)
;
bool
enoughBytes
=
UsedBytes
(
read
write
)
>
=
UsedBytes
(
read
(
initWrite
+
bytesNeeded
)
%
QueueBufferSize
(
)
)
;
MOZ_ASSERT
(
enoughBytes
)
;
if
(
!
enoughBytes
)
{
return
QueueStatus
:
:
kFatalError
;
}
PCQ_LOGD
(
"
Successfully
inserted
.
PcqProducer
used
%
zu
bytes
total
.
"
"
Write
index
:
%
zu
-
>
%
zu
"
bytesNeeded
initWrite
write
)
;
mWrite
-
>
store
(
write
std
:
:
memory_order_release
)
;
if
(
!
mMaybeNotEmptySem
-
>
IsAvailable
(
)
)
{
mMaybeNotEmptySem
-
>
Signal
(
)
;
}
return
status
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitInsert
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
&
.
.
.
aArgs
)
{
return
TryWaitInsertImpl
(
false
aDuration
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
QueueStatus
AllocShmem
(
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
size_t
aBufferSize
const
void
*
aBuffer
=
nullptr
)
{
if
(
!
mActor
)
{
return
QueueStatus
:
:
kFatalError
;
}
if
(
!
mActor
-
>
AllocShmem
(
aBufferSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
:
:
TYPE_BASIC
aShmem
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
if
(
aBuffer
)
{
memcpy
(
aShmem
-
>
get
<
uint8_t
>
(
)
aBuffer
aBufferSize
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
protected
:
friend
ProducerConsumerQueue
;
friend
ProducerView
<
PcqProducer
>
;
template
<
typename
Arg
typename
.
.
.
Args
>
QueueStatus
TryInsertHelper
(
ProducerView
<
PcqProducer
>
&
aView
Arg
&
&
aArg
Args
&
&
.
.
.
aArgs
)
{
QueueStatus
status
=
TryInsertItem
(
aView
std
:
:
forward
<
Arg
>
(
aArg
)
)
;
return
IsSuccess
(
status
)
?
TryInsertHelper
(
aView
aArgs
.
.
.
)
:
status
;
}
QueueStatus
TryInsertHelper
(
ProducerView
<
PcqProducer
>
&
)
{
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
Arg
>
QueueStatus
TryInsertItem
(
ProducerView
<
PcqProducer
>
&
aView
Arg
&
&
aArg
)
{
return
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Write
(
aView
std
:
:
forward
<
Arg
>
(
aArg
)
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitInsertImpl
(
bool
aRecursed
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
&
.
.
.
aArgs
)
{
TimeStamp
start
(
TimeStamp
:
:
Now
(
)
)
;
if
(
aRecursed
&
&
(
!
mMaybeNotFullSem
-
>
Wait
(
aDuration
)
)
)
{
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
TryInsert
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
TimeStamp
now
;
if
(
aRecursed
&
&
IsSuccess
(
status
)
)
{
if
(
(
!
IsFull
(
)
)
&
&
(
!
mMaybeNotFullSem
-
>
IsAvailable
(
)
)
)
{
mMaybeNotFullSem
-
>
Signal
(
)
;
}
}
else
if
(
(
status
=
=
QueueStatus
:
:
kNotReady
)
&
&
(
aDuration
.
isNothing
(
)
|
|
(
(
now
=
TimeStamp
:
:
Now
(
)
)
-
start
)
<
aDuration
.
value
(
)
)
)
{
status
=
aDuration
.
isNothing
(
)
?
TryWaitInsertImpl
(
true
aDuration
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
:
TryWaitInsertImpl
(
true
Some
(
aDuration
.
value
(
)
-
(
now
-
start
)
)
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
return
status
;
}
template
<
typename
Arg
>
QueueStatus
WriteObject
(
size_t
aRead
size_t
*
aWrite
const
Arg
&
arg
size_t
aArgSize
)
{
return
Marshaller
:
:
WriteObject
(
mQueue
QueueBufferSize
(
)
aRead
aWrite
arg
aArgSize
)
;
}
bool
NeedsSharedMemory
(
size_t
aRequested
)
{
return
(
Size
(
)
/
16
)
<
aRequested
;
}
PcqProducer
(
Shmem
&
aShmem
IProtocol
*
aProtocol
size_t
aQueueSize
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotFullSem
)
:
PcqBase
(
aShmem
aProtocol
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
{
*
mRead
=
0
;
*
mWrite
=
0
;
}
PcqProducer
(
const
PcqProducer
&
)
=
delete
;
PcqProducer
&
operator
=
(
const
PcqProducer
&
)
=
delete
;
}
;
class
PcqConsumer
:
public
detail
:
:
PcqBase
{
public
:
PcqConsumer
(
PcqConsumer
&
&
aOther
)
=
default
;
PcqConsumer
&
operator
=
(
PcqConsumer
&
&
)
=
default
;
PcqConsumer
(
)
=
default
;
size_t
Size
(
)
{
return
QueueSize
(
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryPeek
(
Args
&
.
.
.
aArgs
)
{
return
TryPeekOrRemove
<
false
Args
.
.
.
>
(
[
&
]
(
ConsumerView
<
PcqConsumer
>
&
aView
)
-
>
QueueStatus
{
return
TryPeekRemoveHelper
(
aView
&
aArgs
.
.
.
)
;
}
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryRemove
(
Args
&
.
.
.
aArgs
)
{
return
TryPeekOrRemove
<
true
Args
.
.
.
>
(
[
&
]
(
ConsumerView
<
PcqConsumer
>
&
aView
)
-
>
QueueStatus
{
return
TryPeekRemoveHelper
(
aView
&
aArgs
.
.
.
)
;
}
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryRemove
(
)
{
using
seq
=
std
:
:
index_sequence_for
<
Args
.
.
.
>
;
return
TryRemove
<
Args
.
.
.
>
(
seq
{
}
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitPeek
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
.
.
.
aArgs
)
{
return
TryWaitPeekOrRemove
<
false
>
(
aDuration
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitRemove
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
.
.
.
aArgs
)
{
return
TryWaitPeekOrRemove
<
true
>
(
aDuration
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitRemove
(
const
Maybe
<
TimeDuration
>
&
aDuration
)
{
TimeStamp
start
(
TimeStamp
:
:
Now
(
)
)
;
if
(
!
mMaybeNotEmptySem
-
>
Wait
(
aDuration
)
)
{
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
TryRemove
<
Args
.
.
.
>
(
)
;
TimeStamp
now
;
if
(
IsSuccess
(
status
)
)
{
if
(
(
!
IsEmpty
(
)
)
&
&
(
!
mMaybeNotEmptySem
-
>
IsAvailable
(
)
)
)
{
mMaybeNotEmptySem
-
>
Signal
(
)
;
}
}
else
if
(
(
status
=
=
QueueStatus
:
:
kNotReady
)
&
&
(
aDuration
.
isNothing
(
)
|
|
(
(
now
=
TimeStamp
:
:
Now
(
)
)
-
start
)
<
aDuration
.
value
(
)
)
)
{
status
=
aDuration
.
isNothing
(
)
?
TryWaitRemove
<
Args
.
.
.
>
(
aDuration
)
:
TryWaitRemove
<
Args
.
.
.
>
(
Some
(
aDuration
.
value
(
)
-
(
now
-
start
)
)
)
;
}
return
status
;
}
mozilla
:
:
ipc
:
:
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
uint32_t
aId
)
{
if
(
!
mActor
)
{
return
nullptr
;
}
return
mActor
-
>
LookupSharedMemory
(
aId
)
;
}
protected
:
friend
ProducerConsumerQueue
;
friend
ConsumerView
<
PcqConsumer
>
;
using
PeekOrRemoveOperation
=
std
:
:
function
<
QueueStatus
(
ConsumerView
<
PcqConsumer
>
&
)
>
;
template
<
bool
isRemove
typename
.
.
.
Args
>
QueueStatus
TryPeekOrRemove
(
const
PeekOrRemoveOperation
&
aOperation
)
{
size_t
write
=
mWrite
-
>
load
(
std
:
:
memory_order_acquire
)
;
size_t
read
=
mRead
-
>
load
(
std
:
:
memory_order_relaxed
)
;
const
size_t
initRead
=
read
;
if
(
!
ValidState
(
read
write
)
)
{
PCQ_LOGE
(
"
Queue
was
found
in
an
invalid
state
.
Queue
Size
:
%
zu
.
"
"
Read
:
%
zu
.
Write
:
%
zu
"
Size
(
)
read
write
)
;
return
QueueStatus
:
:
kFatalError
;
}
ConsumerView
<
PcqConsumer
>
view
(
this
&
read
write
)
;
size_t
bytesNeeded
=
detail
:
:
MinSizeofArgs
(
view
)
;
if
(
Size
(
)
<
bytesNeeded
)
{
PCQ_LOGE
(
"
Queue
is
too
small
for
objects
.
Queue
Size
:
%
zu
.
"
"
Bytes
needed
:
%
zu
.
"
Size
(
)
bytesNeeded
)
;
return
QueueStatus
:
:
kTooSmall
;
}
if
(
UsedBytes
(
read
write
)
<
bytesNeeded
)
{
PCQ_LOGD
(
"
Not
enough
data
in
queue
.
Has
:
%
zu
(
%
zu
%
zu
)
.
"
"
Bytes
needed
:
%
zu
"
UsedBytes
(
read
write
)
read
write
bytesNeeded
)
;
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
aOperation
(
view
)
;
if
(
!
status
)
{
return
status
;
}
bool
enoughBytes
=
FreeBytes
(
read
write
)
>
=
FreeBytes
(
(
initRead
+
bytesNeeded
)
%
QueueBufferSize
(
)
write
)
;
MOZ_ASSERT
(
enoughBytes
)
;
if
(
!
enoughBytes
)
{
return
QueueStatus
:
:
kFatalError
;
}
MOZ_ASSERT
(
ValidState
(
read
write
)
)
;
PCQ_LOGD
(
"
Successfully
%
s
.
PcqConsumer
used
%
zu
bytes
total
.
"
"
Read
index
:
%
zu
-
>
%
zu
"
isRemove
?
"
removed
"
:
"
peeked
"
bytesNeeded
initRead
read
)
;
if
(
isRemove
)
{
mRead
-
>
store
(
read
std
:
:
memory_order_release
)
;
if
(
!
mMaybeNotFullSem
-
>
IsAvailable
(
)
)
{
mMaybeNotFullSem
-
>
Signal
(
)
;
}
}
return
status
;
}
template
<
typename
.
.
.
Args
size_t
.
.
.
Is
>
QueueStatus
TryRemove
(
std
:
:
index_sequence
<
Is
.
.
.
>
)
{
std
:
:
tuple
<
Args
*
.
.
.
>
nullArgs
;
return
TryPeekOrRemove
<
true
Args
.
.
.
>
(
[
&
]
(
ConsumerView
<
PcqConsumer
>
&
aView
)
{
return
TryPeekRemoveHelper
(
aView
std
:
:
get
<
Is
>
(
nullArgs
)
.
.
.
)
;
}
)
;
}
template
<
bool
isRemove
typename
.
.
.
Args
>
QueueStatus
TryWaitPeekOrRemove
(
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
&
.
.
.
aArgs
)
{
return
TryWaitPeekOrRemoveImpl
<
isRemove
>
(
false
aDuration
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
template
<
bool
isRemove
typename
.
.
.
Args
>
QueueStatus
TryWaitPeekOrRemoveImpl
(
bool
aRecursed
const
Maybe
<
TimeDuration
>
&
aDuration
Args
&
.
.
.
aArgs
)
{
TimeStamp
start
(
TimeStamp
:
:
Now
(
)
)
;
if
(
aRecursed
&
&
(
!
mMaybeNotEmptySem
-
>
Wait
(
aDuration
)
)
)
{
return
QueueStatus
:
:
kNotReady
;
}
QueueStatus
status
=
isRemove
?
TryRemove
(
aArgs
.
.
.
)
:
TryPeek
(
aArgs
.
.
.
)
;
TimeStamp
now
;
if
(
aRecursed
&
&
IsSuccess
(
status
)
)
{
if
(
(
!
IsEmpty
(
)
)
&
&
(
!
mMaybeNotEmptySem
-
>
IsAvailable
(
)
)
)
{
mMaybeNotEmptySem
-
>
Signal
(
)
;
}
}
else
if
(
(
status
=
=
QueueStatus
:
:
kNotReady
)
&
&
(
aDuration
.
isNothing
(
)
|
|
(
(
now
=
TimeStamp
:
:
Now
(
)
)
-
start
)
<
aDuration
.
value
(
)
)
)
{
status
=
aDuration
.
isNothing
(
)
?
TryWaitPeekOrRemoveImpl
<
isRemove
>
(
true
aDuration
aArgs
.
.
.
)
:
TryWaitPeekOrRemoveImpl
<
isRemove
>
(
true
Some
(
aDuration
.
value
(
)
-
(
now
-
start
)
)
aArgs
.
.
.
)
;
}
return
status
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryPeekRemoveHelper
(
ConsumerView
<
PcqConsumer
>
&
aView
Args
*
.
.
.
aArgs
)
;
template
<
typename
Arg
typename
.
.
.
Args
>
QueueStatus
TryPeekRemoveHelper
(
ConsumerView
<
PcqConsumer
>
&
aView
Arg
*
aArg
Args
*
.
.
.
aArgs
)
{
QueueStatus
status
=
TryCopyOrSkipItem
<
Arg
>
(
aView
aArg
)
;
return
IsSuccess
(
status
)
?
TryPeekRemoveHelper
<
Args
.
.
.
>
(
aView
aArgs
.
.
.
)
:
status
;
}
QueueStatus
TryPeekRemoveHelper
(
ConsumerView
<
PcqConsumer
>
&
)
{
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
Arg
>
QueueStatus
TryCopyOrSkipItem
(
ConsumerView
<
PcqConsumer
>
&
aView
Arg
*
aArg
)
{
return
QueueParamTraits
<
typename
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Read
(
aView
const_cast
<
std
:
:
remove_cv_t
<
Arg
>
*
>
(
aArg
)
)
;
}
template
<
typename
Arg
>
QueueStatus
ReadObject
(
size_t
*
aRead
size_t
aWrite
Arg
*
arg
size_t
aArgSize
)
{
return
Marshaller
:
:
ReadObject
(
mQueue
QueueBufferSize
(
)
aRead
aWrite
arg
aArgSize
)
;
}
bool
NeedsSharedMemory
(
size_t
aRequested
)
{
return
(
Size
(
)
/
16
)
<
aRequested
;
}
PcqConsumer
(
Shmem
&
aShmem
IProtocol
*
aProtocol
size_t
aQueueSize
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotEmptySem
RefPtr
<
detail
:
:
PcqRCSemaphore
>
aMaybeNotFullSem
)
:
PcqBase
(
aShmem
aProtocol
aQueueSize
aMaybeNotEmptySem
aMaybeNotFullSem
)
{
}
PcqConsumer
(
const
PcqConsumer
&
)
=
delete
;
PcqConsumer
&
operator
=
(
const
PcqConsumer
&
)
=
delete
;
}
;
using
mozilla
:
:
detail
:
:
GetCacheLineSize
;
using
mozilla
:
:
detail
:
:
GetMaxHeaderSize
;
class
ProducerConsumerQueue
{
public
:
static
UniquePtr
<
ProducerConsumerQueue
>
Create
(
IProtocol
*
aProtocol
size_t
aQueueSize
size_t
aAdditionalBytes
=
0
)
{
MOZ_ASSERT
(
aProtocol
)
;
MOZ_ASSERT
(
PcqActor
:
:
LookupProtocol
(
aProtocol
)
)
;
Shmem
shmem
;
uint32_t
totalShmemSize
=
aQueueSize
+
1
+
GetMaxHeaderSize
(
)
+
aAdditionalBytes
;
if
(
!
aProtocol
-
>
AllocUnsafeShmem
(
totalShmemSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
TYPE_BASIC
&
shmem
)
)
{
return
nullptr
;
}
if
(
(
!
shmem
.
IsWritable
(
)
)
|
|
(
!
shmem
.
IsReadable
(
)
)
|
|
(
(
GetMaxHeaderSize
(
)
+
aQueueSize
+
1
)
>
totalShmemSize
)
)
{
return
nullptr
;
}
return
WrapUnique
(
new
ProducerConsumerQueue
(
shmem
aProtocol
aQueueSize
aAdditionalBytes
)
)
;
}
static
constexpr
size_t
GetMaxHeaderSize
(
)
{
return
mozilla
:
:
detail
:
:
GetMaxHeaderSize
(
)
;
}
static
constexpr
size_t
GetCacheLineSize
(
)
{
return
mozilla
:
:
detail
:
:
GetCacheLineSize
(
)
;
}
using
Producer
=
PcqProducer
;
using
Consumer
=
PcqConsumer
;
UniquePtr
<
Producer
>
TakeProducer
(
)
{
return
std
:
:
move
(
mProducer
)
;
}
UniquePtr
<
Consumer
>
TakeConsumer
(
)
{
return
std
:
:
move
(
mConsumer
)
;
}
private
:
ProducerConsumerQueue
(
Shmem
&
aShmem
IProtocol
*
aProtocol
size_t
aQueueSize
size_t
aAdditionalBytes
)
{
auto
notempty
=
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
"
webgl
-
notempty
"
0
)
)
;
auto
notfull
=
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
"
webgl
-
notfull
"
1
)
)
;
mProducer
=
WrapUnique
(
new
Producer
(
aShmem
aProtocol
aQueueSize
notempty
notfull
)
)
;
mConsumer
=
WrapUnique
(
new
Consumer
(
aShmem
aProtocol
aQueueSize
notempty
notfull
)
)
;
MOZ_ASSERT
(
mProducer
-
>
mUserReservedSize
>
=
aAdditionalBytes
)
;
mProducer
-
>
mUserReservedSize
=
aAdditionalBytes
;
mConsumer
-
>
mUserReservedSize
=
aAdditionalBytes
;
if
(
aAdditionalBytes
=
=
0
)
{
mProducer
-
>
mUserReservedMemory
=
nullptr
;
mConsumer
-
>
mUserReservedMemory
=
nullptr
;
}
PCQ_LOGD
(
"
Constructed
PCQ
(
%
p
)
.
Shmem
Size
=
%
zu
.
Queue
Size
=
%
zu
.
"
"
Other
process
ID
:
%
08x
.
"
this
aShmem
.
Size
<
uint8_t
>
(
)
aQueueSize
(
uint32_t
)
aProtocol
-
>
OtherPid
(
)
)
;
}
UniquePtr
<
Producer
>
mProducer
;
UniquePtr
<
Consumer
>
mConsumer
;
}
;
}
namespace
ipc
{
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
detail
:
:
PcqBase
>
{
typedef
mozilla
:
:
detail
:
:
PcqBase
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
paramType
&
aParam
)
{
MOZ_RELEASE_ASSERT
(
aParam
.
mActor
&
&
aActor
-
>
Id
(
)
=
=
aParam
.
mActor
-
>
Id
(
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mActor
-
>
Id
(
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
QueueSize
(
)
)
;
WriteIPDLParam
(
aMsg
aActor
std
:
:
move
(
aParam
.
mShmem
)
)
;
MOZ_ASSERT
(
aActor
-
>
OtherPid
(
)
=
=
aParam
.
mOtherPid
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mMaybeNotEmptySem
-
>
ShareToProcess
(
aActor
-
>
OtherPid
(
)
)
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mMaybeNotFullSem
-
>
ShareToProcess
(
aActor
-
>
OtherPid
(
)
)
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
int32_t
iProtocolId
;
size_t
queueSize
;
Shmem
shmem
;
CrossProcessSemaphoreHandle
notEmptyHandle
;
CrossProcessSemaphoreHandle
notFullHandle
;
if
(
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
iProtocolId
)
|
|
(
iProtocolId
!
=
aActor
-
>
Id
(
)
)
|
|
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
queueSize
)
|
|
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
shmem
)
|
|
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
notEmptyHandle
)
|
|
!
ReadIPDLParam
(
aMsg
aIter
aActor
&
notFullHandle
)
)
{
return
false
;
}
MOZ_ASSERT
(
IsHandleValid
(
notEmptyHandle
)
&
&
IsHandleValid
(
notFullHandle
)
)
;
aResult
-
>
Set
(
shmem
aActor
queueSize
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
notEmptyHandle
)
)
MakeRefPtr
<
detail
:
:
PcqRCSemaphore
>
(
CrossProcessSemaphore
:
:
Create
(
notFullHandle
)
)
)
;
return
true
;
}
static
void
Log
(
const
paramType
&
aParam
std
:
:
wstring
*
aLog
)
{
IPDLParamTraits
<
Shmem
>
:
:
Log
(
aParam
.
mShmem
aLog
)
;
}
}
;
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
webgl
:
:
PcqProducer
>
:
public
IPDLParamTraits
<
mozilla
:
:
detail
:
:
PcqBase
>
{
typedef
mozilla
:
:
webgl
:
:
PcqProducer
paramType
;
}
;
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
webgl
:
:
PcqConsumer
>
:
public
IPDLParamTraits
<
mozilla
:
:
detail
:
:
PcqBase
>
{
typedef
mozilla
:
:
webgl
:
:
PcqConsumer
paramType
;
}
;
}
}
#
endif
