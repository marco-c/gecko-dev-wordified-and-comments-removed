#
include
"
WebGLShaderValidator
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
MurmurHash3
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
<
string
>
#
include
<
vector
>
#
include
"
WebGLContext
.
h
"
namespace
mozilla
{
namespace
webgl
{
uint64_t
IdentifierHashFunc
(
const
char
*
name
size_t
len
)
{
uint64_t
hash
[
2
]
;
MurmurHash3_x86_128
(
name
len
0
hash
)
;
return
hash
[
0
]
;
}
static
ShCompileOptions
ChooseValidatorCompileOptions
(
const
ShBuiltInResources
&
resources
const
mozilla
:
:
gl
:
:
GLContext
*
gl
)
{
ShCompileOptions
options
=
SH_VARIABLES
|
SH_ENFORCE_PACKING_RESTRICTIONS
|
SH_OBJECT_CODE
|
SH_INIT_GL_POSITION
|
SH_INITIALIZE_UNINITIALIZED_LOCALS
|
SH_INIT_OUTPUT_VARIABLES
;
#
ifndef
XP_MACOSX
options
|
=
SH_CLAMP_INDIRECT_ARRAY_BOUNDS
;
#
endif
if
(
gl
-
>
WorkAroundDriverBugs
(
)
)
{
#
ifdef
XP_MACOSX
options
|
=
SH_UNFOLD_SHORT_CIRCUIT
;
options
|
=
SH_REGENERATE_STRUCT_NAMES
;
options
|
=
SH_INIT_OUTPUT_VARIABLES
;
if
(
gl
-
>
Vendor
(
)
=
=
gl
:
:
GLVendor
:
:
Intel
)
{
options
|
=
SH_ADD_AND_TRUE_TO_LOOP_CONDITION
;
}
#
endif
if
(
!
gl
-
>
IsANGLE
(
)
&
&
gl
-
>
Vendor
(
)
=
=
gl
:
:
GLVendor
:
:
Intel
)
{
options
|
=
SH_SCALARIZE_VEC_AND_MAT_CONSTRUCTOR_ARGS
;
}
}
if
(
gfxPrefs
:
:
WebGLAllANGLEOptions
(
)
)
{
options
=
-
1
;
options
^
=
SH_INTERMEDIATE_TREE
;
options
^
=
SH_LINE_DIRECTIVES
;
options
^
=
SH_SOURCE_PATH
;
options
^
=
SH_LIMIT_EXPRESSION_COMPLEXITY
;
options
^
=
SH_LIMIT_CALL_STACK_DEPTH
;
options
^
=
SH_EXPAND_SELECT_HLSL_INTEGER_POW_EXPRESSIONS
;
options
^
=
SH_HLSL_GET_DIMENSIONS_IGNORES_BASE_LEVEL
;
options
^
=
SH_DONT_REMOVE_INVARIANT_FOR_FRAGMENT_INPUT
;
options
^
=
SH_REMOVE_INVARIANT_AND_CENTROID_FOR_ESSL3
;
}
if
(
resources
.
MaxExpressionComplexity
>
0
)
{
options
|
=
SH_LIMIT_EXPRESSION_COMPLEXITY
;
}
if
(
resources
.
MaxCallStackDepth
>
0
)
{
options
|
=
SH_LIMIT_CALL_STACK_DEPTH
;
}
return
options
;
}
}
static
ShShaderOutput
ShaderOutput
(
gl
:
:
GLContext
*
gl
)
{
if
(
gl
-
>
IsGLES
(
)
)
{
return
SH_ESSL_OUTPUT
;
}
else
{
uint32_t
version
=
gl
-
>
ShadingLanguageVersion
(
)
;
switch
(
version
)
{
case
100
:
return
SH_GLSL_COMPATIBILITY_OUTPUT
;
case
120
:
return
SH_GLSL_COMPATIBILITY_OUTPUT
;
case
130
:
return
SH_GLSL_130_OUTPUT
;
case
140
:
return
SH_GLSL_140_OUTPUT
;
case
150
:
return
SH_GLSL_150_CORE_OUTPUT
;
case
330
:
return
SH_GLSL_330_CORE_OUTPUT
;
case
400
:
return
SH_GLSL_400_CORE_OUTPUT
;
case
410
:
return
SH_GLSL_410_CORE_OUTPUT
;
case
420
:
return
SH_GLSL_420_CORE_OUTPUT
;
case
430
:
return
SH_GLSL_430_CORE_OUTPUT
;
case
440
:
return
SH_GLSL_440_CORE_OUTPUT
;
default
:
if
(
version
>
=
450
)
{
return
SH_GLSL_450_CORE_OUTPUT
;
}
gfxCriticalNote
<
<
"
Unexpected
GLSL
version
:
"
<
<
version
;
}
}
return
SH_GLSL_COMPATIBILITY_OUTPUT
;
}
webgl
:
:
ShaderValidator
*
WebGLContext
:
:
CreateShaderValidator
(
GLenum
shaderType
)
const
{
if
(
mBypassShaderValidation
)
return
nullptr
;
const
auto
spec
=
(
IsWebGL2
(
)
?
SH_WEBGL2_SPEC
:
SH_WEBGL_SPEC
)
;
const
auto
outputLanguage
=
ShaderOutput
(
gl
)
;
ShBuiltInResources
resources
;
memset
(
&
resources
0
sizeof
(
resources
)
)
;
sh
:
:
InitBuiltInResources
(
&
resources
)
;
resources
.
HashFunction
=
webgl
:
:
IdentifierHashFunc
;
resources
.
MaxVertexAttribs
=
mGLMaxVertexAttribs
;
resources
.
MaxVertexUniformVectors
=
mGLMaxVertexUniformVectors
;
resources
.
MaxVaryingVectors
=
mGLMaxVaryingVectors
;
resources
.
MaxVertexTextureImageUnits
=
mGLMaxVertexTextureImageUnits
;
resources
.
MaxCombinedTextureImageUnits
=
mGLMaxCombinedTextureImageUnits
;
resources
.
MaxTextureImageUnits
=
mGLMaxFragmentTextureImageUnits
;
resources
.
MaxFragmentUniformVectors
=
mGLMaxFragmentUniformVectors
;
const
bool
hasMRTs
=
(
IsWebGL2
(
)
|
|
IsExtensionEnabled
(
WebGLExtensionID
:
:
WEBGL_draw_buffers
)
)
;
resources
.
MaxDrawBuffers
=
(
hasMRTs
?
mGLMaxDrawBuffers
:
1
)
;
if
(
IsExtensionEnabled
(
WebGLExtensionID
:
:
EXT_frag_depth
)
)
resources
.
EXT_frag_depth
=
1
;
if
(
IsExtensionEnabled
(
WebGLExtensionID
:
:
OES_standard_derivatives
)
)
resources
.
OES_standard_derivatives
=
1
;
if
(
IsExtensionEnabled
(
WebGLExtensionID
:
:
WEBGL_draw_buffers
)
)
resources
.
EXT_draw_buffers
=
1
;
if
(
IsExtensionEnabled
(
WebGLExtensionID
:
:
EXT_shader_texture_lod
)
)
resources
.
EXT_shader_texture_lod
=
1
;
resources
.
FragmentPrecisionHigh
=
mDisableFragHighP
?
0
:
1
;
if
(
gl
-
>
WorkAroundDriverBugs
(
)
)
{
#
ifdef
XP_MACOSX
if
(
gl
-
>
Vendor
(
)
=
=
gl
:
:
GLVendor
:
:
NVIDIA
)
{
resources
.
MaxExpressionComplexity
=
1000
;
}
#
endif
}
const
auto
compileOptions
=
webgl
:
:
ChooseValidatorCompileOptions
(
resources
gl
)
;
return
webgl
:
:
ShaderValidator
:
:
Create
(
shaderType
spec
outputLanguage
resources
compileOptions
)
;
}
namespace
webgl
{
ShaderValidator
*
ShaderValidator
:
:
Create
(
GLenum
shaderType
ShShaderSpec
spec
ShShaderOutput
outputLanguage
const
ShBuiltInResources
&
resources
ShCompileOptions
compileOptions
)
{
ShHandle
handle
=
sh
:
:
ConstructCompiler
(
shaderType
spec
outputLanguage
&
resources
)
;
if
(
!
handle
)
return
nullptr
;
return
new
ShaderValidator
(
handle
compileOptions
resources
.
MaxVaryingVectors
)
;
}
ShaderValidator
:
:
~
ShaderValidator
(
)
{
sh
:
:
Destruct
(
mHandle
)
;
}
bool
ShaderValidator
:
:
ValidateAndTranslate
(
const
char
*
source
)
{
MOZ_ASSERT
(
!
mHasRun
)
;
mHasRun
=
true
;
const
char
*
const
parts
[
]
=
{
source
}
;
return
sh
:
:
Compile
(
mHandle
parts
ArrayLength
(
parts
)
mCompileOptions
)
;
}
void
ShaderValidator
:
:
GetInfoLog
(
nsACString
*
out
)
const
{
MOZ_ASSERT
(
mHasRun
)
;
const
std
:
:
string
&
log
=
sh
:
:
GetInfoLog
(
mHandle
)
;
out
-
>
Assign
(
log
.
data
(
)
log
.
length
(
)
)
;
}
void
ShaderValidator
:
:
GetOutput
(
nsACString
*
out
)
const
{
MOZ_ASSERT
(
mHasRun
)
;
const
std
:
:
string
&
output
=
sh
:
:
GetObjectCode
(
mHandle
)
;
out
-
>
Assign
(
output
.
data
(
)
output
.
length
(
)
)
;
}
template
<
size_t
N
>
static
bool
StartsWith
(
const
std
:
:
string
&
haystack
const
char
(
&
needle
)
[
N
]
)
{
return
haystack
.
compare
(
0
N
-
1
needle
)
=
=
0
;
}
bool
ShaderValidator
:
:
CanLinkTo
(
const
ShaderValidator
*
prev
nsCString
*
const
out_log
)
const
{
if
(
!
prev
)
{
nsPrintfCString
error
(
"
Passed
in
NULL
prev
ShaderValidator
.
"
)
;
*
out_log
=
error
;
return
false
;
}
const
auto
shaderVersion
=
sh
:
:
GetShaderVersion
(
mHandle
)
;
if
(
sh
:
:
GetShaderVersion
(
prev
-
>
mHandle
)
!
=
shaderVersion
)
{
nsPrintfCString
error
(
"
Vertex
shader
version
%
d
does
not
match
"
"
fragment
shader
version
%
d
.
"
sh
:
:
GetShaderVersion
(
prev
-
>
mHandle
)
sh
:
:
GetShaderVersion
(
mHandle
)
)
;
*
out_log
=
error
;
return
false
;
}
{
const
std
:
:
vector
<
sh
:
:
Uniform
>
*
vertPtr
=
sh
:
:
GetUniforms
(
prev
-
>
mHandle
)
;
const
std
:
:
vector
<
sh
:
:
Uniform
>
*
fragPtr
=
sh
:
:
GetUniforms
(
mHandle
)
;
if
(
!
vertPtr
|
|
!
fragPtr
)
{
nsPrintfCString
error
(
"
Could
not
create
uniform
list
.
"
)
;
*
out_log
=
error
;
return
false
;
}
for
(
auto
itrFrag
=
fragPtr
-
>
begin
(
)
;
itrFrag
!
=
fragPtr
-
>
end
(
)
;
+
+
itrFrag
)
{
for
(
auto
itrVert
=
vertPtr
-
>
begin
(
)
;
itrVert
!
=
vertPtr
-
>
end
(
)
;
+
+
itrVert
)
{
if
(
itrVert
-
>
name
!
=
itrFrag
-
>
name
)
continue
;
if
(
!
itrVert
-
>
isSameUniformAtLinkTime
(
*
itrFrag
)
)
{
nsPrintfCString
error
(
"
Uniform
%
s
is
not
linkable
between
"
"
attached
shaders
.
"
itrFrag
-
>
name
.
c_str
(
)
)
;
*
out_log
=
error
;
return
false
;
}
break
;
}
}
}
{
const
auto
vertVars
=
sh
:
:
GetInterfaceBlocks
(
prev
-
>
mHandle
)
;
const
auto
fragVars
=
sh
:
:
GetInterfaceBlocks
(
mHandle
)
;
if
(
!
vertVars
|
|
!
fragVars
)
{
nsPrintfCString
error
(
"
Could
not
create
uniform
block
list
.
"
)
;
*
out_log
=
error
;
return
false
;
}
for
(
const
auto
&
fragVar
:
*
fragVars
)
{
for
(
const
auto
&
vertVar
:
*
vertVars
)
{
if
(
vertVar
.
name
!
=
fragVar
.
name
)
continue
;
if
(
!
vertVar
.
isSameInterfaceBlockAtLinkTime
(
fragVar
)
)
{
nsPrintfCString
error
(
"
Interface
block
%
s
is
not
linkable
between
"
"
attached
shaders
.
"
fragVar
.
name
.
c_str
(
)
)
;
*
out_log
=
error
;
return
false
;
}
break
;
}
}
}
const
auto
&
vertVaryings
=
sh
:
:
GetVaryings
(
prev
-
>
mHandle
)
;
const
auto
&
fragVaryings
=
sh
:
:
GetVaryings
(
mHandle
)
;
if
(
!
vertVaryings
|
|
!
fragVaryings
)
{
nsPrintfCString
error
(
"
Could
not
create
varying
list
.
"
)
;
*
out_log
=
error
;
return
false
;
}
{
std
:
:
vector
<
sh
:
:
ShaderVariable
>
staticUseVaryingList
;
for
(
const
auto
&
fragVarying
:
*
fragVaryings
)
{
static
const
char
prefix
[
]
=
"
gl_
"
;
if
(
StartsWith
(
fragVarying
.
name
prefix
)
)
{
if
(
fragVarying
.
staticUse
)
{
staticUseVaryingList
.
push_back
(
fragVarying
)
;
}
continue
;
}
bool
definedInVertShader
=
false
;
bool
staticVertUse
=
false
;
for
(
const
auto
&
vertVarying
:
*
vertVaryings
)
{
if
(
vertVarying
.
name
!
=
fragVarying
.
name
)
continue
;
if
(
!
vertVarying
.
isSameVaryingAtLinkTime
(
fragVarying
shaderVersion
)
)
{
nsPrintfCString
error
(
"
Varying
%
s
is
not
linkable
between
"
"
attached
shaders
.
"
fragVarying
.
name
.
c_str
(
)
)
;
*
out_log
=
error
;
return
false
;
}
definedInVertShader
=
true
;
staticVertUse
=
vertVarying
.
staticUse
;
break
;
}
if
(
!
definedInVertShader
&
&
fragVarying
.
staticUse
)
{
nsPrintfCString
error
(
"
Varying
%
s
has
static
-
use
in
the
frag
"
"
shader
but
is
undeclared
in
the
vert
"
"
shader
.
"
fragVarying
.
name
.
c_str
(
)
)
;
*
out_log
=
error
;
return
false
;
}
if
(
staticVertUse
&
&
fragVarying
.
staticUse
)
{
staticUseVaryingList
.
push_back
(
fragVarying
)
;
}
}
if
(
!
sh
:
:
CheckVariablesWithinPackingLimits
(
mMaxVaryingVectors
staticUseVaryingList
)
)
{
*
out_log
=
"
Statically
used
varyings
do
not
fit
within
packing
limits
.
(
see
"
"
GLSL
ES
Specification
1
.
0
.
17
p111
)
"
;
return
false
;
}
}
if
(
shaderVersion
=
=
100
)
{
bool
isInvariant_Position
=
false
;
bool
isInvariant_PointSize
=
false
;
bool
isInvariant_FragCoord
=
false
;
bool
isInvariant_PointCoord
=
false
;
for
(
const
auto
&
varying
:
*
vertVaryings
)
{
if
(
varying
.
name
=
=
"
gl_Position
"
)
{
isInvariant_Position
=
varying
.
isInvariant
;
}
else
if
(
varying
.
name
=
=
"
gl_PointSize
"
)
{
isInvariant_PointSize
=
varying
.
isInvariant
;
}
}
for
(
const
auto
&
varying
:
*
fragVaryings
)
{
if
(
varying
.
name
=
=
"
gl_FragCoord
"
)
{
isInvariant_FragCoord
=
varying
.
isInvariant
;
}
else
if
(
varying
.
name
=
=
"
gl_PointCoord
"
)
{
isInvariant_PointCoord
=
varying
.
isInvariant
;
}
}
const
auto
fnCanBuiltInsLink
=
[
]
(
bool
vertIsInvariant
bool
fragIsInvariant
)
{
if
(
vertIsInvariant
)
return
true
;
return
!
fragIsInvariant
;
}
;
if
(
!
fnCanBuiltInsLink
(
isInvariant_Position
isInvariant_FragCoord
)
)
{
*
out_log
=
"
gl_Position
must
be
invariant
if
gl_FragCoord
is
.
(
see
GLSL
ES
"
"
Specification
1
.
0
.
17
p39
)
"
;
return
false
;
}
if
(
!
fnCanBuiltInsLink
(
isInvariant_PointSize
isInvariant_PointCoord
)
)
{
*
out_log
=
"
gl_PointSize
must
be
invariant
if
gl_PointCoord
is
.
(
see
GLSL
ES
"
"
Specification
1
.
0
.
17
p39
)
"
;
return
false
;
}
}
return
true
;
}
size_t
ShaderValidator
:
:
CalcNumSamplerUniforms
(
)
const
{
size_t
accum
=
0
;
const
std
:
:
vector
<
sh
:
:
Uniform
>
&
uniforms
=
*
sh
:
:
GetUniforms
(
mHandle
)
;
for
(
auto
itr
=
uniforms
.
begin
(
)
;
itr
!
=
uniforms
.
end
(
)
;
+
+
itr
)
{
GLenum
type
=
itr
-
>
type
;
if
(
type
=
=
LOCAL_GL_SAMPLER_2D
|
|
type
=
=
LOCAL_GL_SAMPLER_CUBE
)
{
accum
+
=
itr
-
>
getArraySizeProduct
(
)
;
}
}
return
accum
;
}
size_t
ShaderValidator
:
:
NumAttributes
(
)
const
{
return
sh
:
:
GetAttributes
(
mHandle
)
-
>
size
(
)
;
}
bool
ShaderValidator
:
:
FindAttribUserNameByMappedName
(
const
std
:
:
string
&
mappedName
const
std
:
:
string
*
*
const
out_userName
)
const
{
const
std
:
:
vector
<
sh
:
:
Attribute
>
&
attribs
=
*
sh
:
:
GetAttributes
(
mHandle
)
;
for
(
auto
itr
=
attribs
.
begin
(
)
;
itr
!
=
attribs
.
end
(
)
;
+
+
itr
)
{
if
(
itr
-
>
mappedName
=
=
mappedName
)
{
*
out_userName
=
&
(
itr
-
>
name
)
;
return
true
;
}
}
return
false
;
}
bool
ShaderValidator
:
:
FindAttribMappedNameByUserName
(
const
std
:
:
string
&
userName
const
std
:
:
string
*
*
const
out_mappedName
)
const
{
const
std
:
:
vector
<
sh
:
:
Attribute
>
&
attribs
=
*
sh
:
:
GetAttributes
(
mHandle
)
;
for
(
auto
itr
=
attribs
.
begin
(
)
;
itr
!
=
attribs
.
end
(
)
;
+
+
itr
)
{
if
(
itr
-
>
name
=
=
userName
)
{
*
out_mappedName
=
&
(
itr
-
>
mappedName
)
;
return
true
;
}
}
return
false
;
}
bool
ShaderValidator
:
:
FindVaryingByMappedName
(
const
std
:
:
string
&
mappedName
std
:
:
string
*
const
out_userName
bool
*
const
out_isArray
)
const
{
const
std
:
:
vector
<
sh
:
:
Varying
>
&
varyings
=
*
sh
:
:
GetVaryings
(
mHandle
)
;
for
(
auto
itr
=
varyings
.
begin
(
)
;
itr
!
=
varyings
.
end
(
)
;
+
+
itr
)
{
const
sh
:
:
ShaderVariable
*
found
;
if
(
!
itr
-
>
findInfoByMappedName
(
mappedName
&
found
out_userName
)
)
continue
;
*
out_isArray
=
found
-
>
isArray
(
)
;
return
true
;
}
return
false
;
}
bool
ShaderValidator
:
:
FindVaryingMappedNameByUserName
(
const
std
:
:
string
&
userName
const
std
:
:
string
*
*
const
out_mappedName
)
const
{
const
std
:
:
vector
<
sh
:
:
Varying
>
&
attribs
=
*
sh
:
:
GetVaryings
(
mHandle
)
;
for
(
auto
itr
=
attribs
.
begin
(
)
;
itr
!
=
attribs
.
end
(
)
;
+
+
itr
)
{
if
(
itr
-
>
name
=
=
userName
)
{
*
out_mappedName
=
&
(
itr
-
>
mappedName
)
;
return
true
;
}
}
return
false
;
}
bool
ShaderValidator
:
:
FindUniformByMappedName
(
const
std
:
:
string
&
mappedName
std
:
:
string
*
const
out_userName
bool
*
const
out_isArray
)
const
{
const
std
:
:
vector
<
sh
:
:
Uniform
>
&
uniforms
=
*
sh
:
:
GetUniforms
(
mHandle
)
;
for
(
auto
itr
=
uniforms
.
begin
(
)
;
itr
!
=
uniforms
.
end
(
)
;
+
+
itr
)
{
const
sh
:
:
ShaderVariable
*
found
;
if
(
!
itr
-
>
findInfoByMappedName
(
mappedName
&
found
out_userName
)
)
continue
;
*
out_isArray
=
found
-
>
isArray
(
)
;
return
true
;
}
const
size_t
dotPos
=
mappedName
.
find
(
"
.
"
)
;
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaces
=
*
sh
:
:
GetInterfaceBlocks
(
mHandle
)
;
for
(
const
auto
&
interface
:
interfaces
)
{
std
:
:
string
mappedFieldName
;
const
bool
hasInstanceName
=
!
interface
.
instanceName
.
empty
(
)
;
if
(
hasInstanceName
)
{
if
(
std
:
:
string
:
:
npos
=
=
dotPos
)
continue
;
const
std
:
:
string
mappedInterfaceBlockName
=
mappedName
.
substr
(
0
dotPos
)
;
if
(
interface
.
mappedName
!
=
mappedInterfaceBlockName
)
continue
;
mappedFieldName
=
mappedName
.
substr
(
dotPos
+
1
)
;
}
else
{
mappedFieldName
=
mappedName
;
}
for
(
const
auto
&
field
:
interface
.
fields
)
{
const
sh
:
:
ShaderVariable
*
found
;
if
(
!
field
.
findInfoByMappedName
(
mappedFieldName
&
found
out_userName
)
)
continue
;
if
(
hasInstanceName
)
{
*
out_userName
=
interface
.
name
+
"
.
"
+
*
out_userName
;
}
*
out_isArray
=
found
-
>
isArray
(
)
;
return
true
;
}
}
return
false
;
}
bool
ShaderValidator
:
:
UnmapUniformBlockName
(
const
nsACString
&
baseMappedName
nsCString
*
const
out_baseUserName
)
const
{
const
std
:
:
vector
<
sh
:
:
InterfaceBlock
>
&
interfaces
=
*
sh
:
:
GetInterfaceBlocks
(
mHandle
)
;
for
(
const
auto
&
interface
:
interfaces
)
{
const
nsDependentCString
interfaceMappedName
(
interface
.
mappedName
.
data
(
)
interface
.
mappedName
.
size
(
)
)
;
if
(
baseMappedName
=
=
interfaceMappedName
)
{
*
out_baseUserName
=
interface
.
name
.
data
(
)
;
return
true
;
}
}
return
false
;
}
void
ShaderValidator
:
:
EnumerateFragOutputs
(
std
:
:
map
<
nsCString
const
nsCString
>
&
out_FragOutputs
)
const
{
const
auto
*
fragOutputs
=
sh
:
:
GetOutputVariables
(
mHandle
)
;
if
(
fragOutputs
)
{
for
(
const
auto
&
fragOutput
:
*
fragOutputs
)
{
out_FragOutputs
.
insert
(
{
nsCString
(
fragOutput
.
name
.
c_str
(
)
)
nsCString
(
fragOutput
.
mappedName
.
c_str
(
)
)
}
)
;
}
}
}
}
}
