#
ifndef
IPDLQUEUE_H_
#
define
IPDLQUEUE_H_
1
#
include
<
atomic
>
#
include
<
tuple
>
#
include
<
vector
>
#
include
<
unordered_map
>
#
include
"
ipc
/
IPCMessageUtilsSpecializations
.
h
"
#
include
"
mozilla
/
dom
/
QueueParamTraits
.
h
"
#
include
"
mozilla
/
ipc
/
SharedMemoryBasic
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
ipc
/
Shmem
.
h
"
#
include
"
mozilla
/
ipc
/
ProtocolUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
namespace
dom
{
using
mozilla
:
:
webgl
:
:
QueueStatus
;
extern
LazyLogModule
gIpdlQueueLog
;
#
define
IPDLQUEUE_LOG_
(
lvl
.
.
.
)
\
MOZ_LOG
(
mozilla
:
:
dom
:
:
gIpdlQueueLog
lvl
(
__VA_ARGS__
)
)
#
define
IPDLQUEUE_LOGD
(
.
.
.
)
IPDLQUEUE_LOG_
(
LogLevel
:
:
Debug
__VA_ARGS__
)
#
define
IPDLQUEUE_LOGE
(
.
.
.
)
IPDLQUEUE_LOG_
(
LogLevel
:
:
Error
__VA_ARGS__
)
template
<
typename
ActorP
typename
ActorC
>
class
IpdlQueue
;
template
<
typename
Derived
>
class
SyncConsumerActor
;
enum
IpdlQueueProtocol
{
kAsync
kBufferedAsync
kSync
}
;
constexpr
uint64_t
kIllegalQueueId
=
0
;
inline
uint64_t
NewIpdlQueueId
(
)
{
static
std
:
:
atomic
<
uint64_t
>
sNextIpdlQueueId
=
1
;
return
sNextIpdlQueueId
+
+
;
}
struct
IpdlQueueBuffer
{
uint64_t
id
=
kIllegalQueueId
;
nsTArray
<
uint8_t
>
data
;
IpdlQueueBuffer
(
)
=
default
;
IpdlQueueBuffer
(
const
IpdlQueueBuffer
&
)
=
delete
;
IpdlQueueBuffer
(
IpdlQueueBuffer
&
&
)
=
default
;
IpdlQueueBuffer
(
uint64_t
aId
nsTArray
<
uint8_t
>
&
&
aData
)
:
id
(
aId
)
data
(
std
:
:
move
(
aData
)
)
{
}
}
;
using
IpdlQueueBuffers
=
nsTArray
<
IpdlQueueBuffer
>
;
static
constexpr
uint32_t
kAsyncFlushWaitMs
=
4
;
template
<
typename
Derived
>
class
AsyncProducerActor
{
public
:
virtual
bool
TransmitIpdlQueueData
(
IpdlQueueProtocol
aProtocol
IpdlQueueBuffer
&
&
aData
)
{
MOZ_ASSERT
(
(
aProtocol
=
=
IpdlQueueProtocol
:
:
kAsync
)
|
|
(
aProtocol
=
=
IpdlQueueProtocol
:
:
kBufferedAsync
)
)
;
if
(
mResponseBuffers
|
|
(
aProtocol
=
=
IpdlQueueProtocol
:
:
kBufferedAsync
)
)
{
auto
&
buffers
=
mResponseBuffers
?
*
mResponseBuffers
:
mAsyncBuffers
;
const
uint64_t
id
=
aData
.
id
;
for
(
auto
&
elt
:
buffers
)
{
if
(
elt
.
id
=
=
id
)
{
elt
.
data
.
AppendElements
(
aData
.
data
)
;
return
true
;
}
}
buffers
.
AppendElement
(
std
:
:
move
(
aData
)
)
;
if
(
!
mResponseBuffers
)
{
PostFlushAsyncCache
(
kAsyncFlushWaitMs
)
;
}
return
true
;
}
FlushAsyncCache
(
)
;
Derived
*
self
=
static_cast
<
Derived
*
>
(
this
)
;
return
self
-
>
SendTransmitIpdlQueueData
(
std
:
:
move
(
aData
)
)
;
}
bool
FlushAsyncCache
(
)
{
Derived
*
self
=
static_cast
<
Derived
*
>
(
this
)
;
for
(
auto
&
elt
:
mAsyncBuffers
)
{
if
(
!
elt
.
data
.
IsEmpty
(
)
)
{
if
(
!
self
-
>
SendTransmitIpdlQueueData
(
std
:
:
move
(
elt
)
)
)
{
return
false
;
}
}
}
mAsyncBuffers
.
Clear
(
)
;
return
true
;
}
bool
PostFlushAsyncCache
(
uint32_t
aEstWaitTimeMs
)
{
if
(
mPostedFlushRunnable
)
{
return
true
;
}
MOZ_ASSERT
(
GetCurrentSerialEventTarget
(
)
"
No
message
loop
for
IpdlQueue
flush
task
"
)
;
Derived
*
self
=
static_cast
<
Derived
*
>
(
this
)
;
auto
weak
=
WeakPtr
<
Derived
>
(
self
)
;
already_AddRefed
<
mozilla
:
:
Runnable
>
flushRunnable
=
NS_NewRunnableFunction
(
"
FlushAsyncCache
"
[
weak
]
{
auto
strong
=
RefPtr
<
Derived
>
(
weak
)
;
if
(
!
strong
)
{
return
;
}
strong
-
>
FlushAsyncCache
(
)
;
strong
-
>
ClearFlushRunnable
(
)
;
}
)
;
NS_ENSURE_SUCCESS
(
GetCurrentSerialEventTarget
(
)
-
>
DelayedDispatch
(
std
:
:
move
(
flushRunnable
)
aEstWaitTimeMs
)
false
)
;
mPostedFlushRunnable
=
true
;
return
true
;
}
void
ClearFlushRunnable
(
)
{
mPostedFlushRunnable
=
false
;
}
template
<
typename
.
.
.
Args
>
IpdlQueueProtocol
GetIpdlQueueProtocol
(
const
Args
&
.
.
.
)
{
return
IpdlQueueProtocol
:
:
kAsync
;
}
protected
:
friend
SyncConsumerActor
<
Derived
>
;
void
SetResponseBuffers
(
IpdlQueueBuffers
*
aResponse
)
{
MOZ_ASSERT
(
!
mResponseBuffers
)
;
mResponseBuffers
=
aResponse
;
*
mResponseBuffers
=
std
:
:
move
(
mAsyncBuffers
)
;
}
void
ClearResponseBuffers
(
)
{
MOZ_ASSERT
(
mResponseBuffers
)
;
mResponseBuffers
=
nullptr
;
}
IpdlQueueBuffers
*
mResponseBuffers
=
nullptr
;
IpdlQueueBuffers
mAsyncBuffers
;
bool
mPostedFlushRunnable
=
false
;
}
;
template
<
typename
Derived
>
class
SyncProducerActor
:
public
AsyncProducerActor
<
Derived
>
{
public
:
bool
TransmitIpdlQueueData
(
IpdlQueueProtocol
aProtocol
IpdlQueueBuffer
&
&
aData
)
override
{
Derived
*
self
=
static_cast
<
Derived
*
>
(
this
)
;
if
(
mResponseBuffers
|
|
(
aProtocol
!
=
IpdlQueueProtocol
:
:
kSync
)
)
{
return
AsyncProducerActor
<
Derived
>
:
:
TransmitIpdlQueueData
(
aProtocol
std
:
:
forward
<
IpdlQueueBuffer
>
(
aData
)
)
;
}
IpdlQueueBuffers
responses
;
if
(
!
self
-
>
SendExchangeIpdlQueueData
(
std
:
:
forward
<
IpdlQueueBuffer
>
(
aData
)
&
responses
)
)
{
return
false
;
}
for
(
auto
&
buf
:
responses
)
{
if
(
!
self
-
>
StoreIpdlQueueData
(
std
:
:
move
(
buf
)
)
)
{
return
false
;
}
}
return
true
;
}
protected
:
using
AsyncProducerActor
<
Derived
>
:
:
mResponseBuffers
;
}
;
template
<
typename
Derived
>
class
AsyncConsumerActor
{
public
:
nsTArray
<
uint8_t
>
TakeIpdlQueueData
(
uint64_t
aId
)
{
auto
it
=
mIpdlQueueBuffers
.
find
(
aId
)
;
if
(
it
!
=
mIpdlQueueBuffers
.
end
(
)
)
{
return
std
:
:
move
(
it
-
>
second
.
data
)
;
}
return
nsTArray
<
uint8_t
>
(
)
;
}
protected
:
friend
SyncProducerActor
<
Derived
>
;
bool
StoreIpdlQueueData
(
IpdlQueueBuffer
&
&
aBuffer
)
{
auto
it
=
mIpdlQueueBuffers
.
find
(
aBuffer
.
id
)
;
if
(
it
=
=
mIpdlQueueBuffers
.
end
(
)
)
{
return
mIpdlQueueBuffers
.
insert
(
{
aBuffer
.
id
std
:
:
move
(
aBuffer
)
}
)
.
second
;
}
return
it
-
>
second
.
data
.
AppendElements
(
aBuffer
.
data
fallible
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
RecvTransmitIpdlQueueData
(
IpdlQueueBuffer
&
&
aBuffer
)
{
if
(
StoreIpdlQueueData
(
std
:
:
forward
<
IpdlQueueBuffer
>
(
aBuffer
)
)
)
{
return
IPC_OK
(
)
;
}
return
IPC_FAIL_NO_REASON
(
static_cast
<
Derived
*
>
(
this
)
)
;
}
std
:
:
unordered_map
<
uint64_t
IpdlQueueBuffer
>
mIpdlQueueBuffers
;
}
;
template
<
typename
Derived
>
class
SyncConsumerActor
:
public
AsyncConsumerActor
<
Derived
>
{
protected
:
using
AsyncConsumerActor
<
Derived
>
:
:
StoreIpdlQueueData
;
mozilla
:
:
ipc
:
:
IPCResult
RecvExchangeIpdlQueueData
(
IpdlQueueBuffer
&
&
aBuffer
IpdlQueueBuffers
*
aResponse
)
{
uint64_t
id
=
aBuffer
.
id
;
if
(
!
StoreIpdlQueueData
(
std
:
:
forward
<
IpdlQueueBuffer
>
(
aBuffer
)
)
)
{
return
IPC_FAIL_NO_REASON
(
static_cast
<
Derived
*
>
(
this
)
)
;
}
Derived
*
actor
=
static_cast
<
Derived
*
>
(
this
)
;
actor
-
>
SetResponseBuffers
(
aResponse
)
;
auto
clearResponseBuffer
=
MakeScopeExit
(
[
&
]
{
actor
-
>
ClearResponseBuffers
(
)
;
}
)
;
#
if
defined
(
DEBUG
)
DebugOnly
<
bool
>
responseBufferIsEmpty
=
[
&
]
{
for
(
auto
&
elt
:
*
aResponse
)
{
if
(
elt
.
id
=
=
id
)
{
return
elt
.
data
.
IsEmpty
(
)
;
}
}
return
true
;
}
(
)
;
MOZ_ASSERT
(
responseBufferIsEmpty
)
;
#
endif
return
actor
-
>
RunQueue
(
id
)
?
IPC_OK
(
)
:
IPC_FAIL_NO_REASON
(
actor
)
;
}
}
;
template
<
typename
_Actor
>
class
IpdlProducer
final
:
public
SupportsWeakPtr
{
nsTArray
<
uint8_t
>
mSerializedData
;
WeakPtr
<
_Actor
>
mActor
;
uint64_t
mId
;
public
:
using
Actor
=
_Actor
;
using
SelfType
=
IpdlProducer
<
Actor
>
;
IpdlProducer
(
)
:
mId
(
kIllegalQueueId
)
{
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryInsert
(
Args
&
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
mId
!
=
kIllegalQueueId
)
;
if
(
!
mActor
)
{
NS_WARNING
(
"
TryInsert
with
actor
that
was
already
freed
.
"
)
;
return
QueueStatus
:
:
kFatalError
;
}
MOZ_ASSERT
(
mSerializedData
.
IsEmpty
(
)
)
;
auto
self
=
*
this
;
auto
clearData
=
MakeScopeExit
(
[
&
]
{
self
.
mSerializedData
.
Clear
(
)
;
}
)
;
const
IpdlQueueProtocol
protocol
=
mActor
-
>
GetIpdlQueueProtocol
(
aArgs
.
.
.
)
;
QueueStatus
status
=
SerializeAllArgs
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
if
(
status
!
=
QueueStatus
:
:
kSuccess
)
{
return
status
;
}
return
mActor
-
>
TransmitIpdlQueueData
(
protocol
IpdlQueueBuffer
(
mId
std
:
:
move
(
mSerializedData
)
)
)
?
QueueStatus
:
:
kSuccess
:
QueueStatus
:
:
kFatalError
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitInsert
(
const
Maybe
<
TimeDuration
>
&
Args
&
&
.
.
.
aArgs
)
{
return
TryInsert
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
QueueStatus
AllocShmem
(
mozilla
:
:
ipc
:
:
Shmem
*
aShmem
size_t
aBufferSize
const
void
*
aBuffer
=
nullptr
)
{
if
(
!
mActor
)
{
return
QueueStatus
:
:
kFatalError
;
}
if
(
!
mActor
-
>
AllocShmem
(
aBufferSize
mozilla
:
:
ipc
:
:
SharedMemory
:
:
SharedMemoryType
:
:
TYPE_BASIC
aShmem
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
if
(
aBuffer
)
{
memcpy
(
aShmem
-
>
get
<
uint8_t
>
(
)
aBuffer
aBufferSize
)
;
}
return
QueueStatus
:
:
kSuccess
;
}
protected
:
template
<
typename
T1
typename
T2
>
friend
class
IpdlQueue
;
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
SelfType
>
;
explicit
IpdlProducer
(
uint64_t
aId
Actor
*
aActor
=
nullptr
)
:
mActor
(
aActor
)
mId
(
aId
)
{
}
template
<
typename
.
.
.
Args
>
QueueStatus
SerializeAllArgs
(
Args
&
&
.
.
.
aArgs
)
{
size_t
read
=
0
;
size_t
write
=
0
;
mozilla
:
:
webgl
:
:
ProducerView
<
SelfType
>
view
(
this
read
&
write
)
;
size_t
bytesNeeded
=
MinSizeofArgs
(
view
aArgs
.
.
.
)
;
if
(
!
mSerializedData
.
SetLength
(
bytesNeeded
fallible
)
)
{
return
QueueStatus
:
:
kOOMError
;
}
return
SerializeArgs
(
view
aArgs
.
.
.
)
;
}
QueueStatus
SerializeArgs
(
mozilla
:
:
webgl
:
:
ProducerView
<
SelfType
>
&
aView
)
{
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
Arg
typename
.
.
.
Args
>
QueueStatus
SerializeArgs
(
mozilla
:
:
webgl
:
:
ProducerView
<
SelfType
>
&
aView
const
Arg
&
aArg
const
Args
&
.
.
.
aArgs
)
{
QueueStatus
status
=
SerializeArg
(
aView
aArg
)
;
if
(
!
IsSuccess
(
status
)
)
{
return
status
;
}
return
SerializeArgs
(
aView
aArgs
.
.
.
)
;
}
template
<
typename
Arg
>
QueueStatus
SerializeArg
(
mozilla
:
:
webgl
:
:
ProducerView
<
SelfType
>
&
aView
const
Arg
&
aArg
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
std
:
:
remove_volatile
<
Arg
>
:
:
type
>
:
:
Write
(
aView
aArg
)
;
}
public
:
template
<
typename
Arg
>
QueueStatus
WriteObject
(
size_t
aRead
size_t
*
aWrite
const
Arg
&
arg
size_t
aArgSize
)
{
if
(
mSerializedData
.
Length
(
)
<
(
*
aWrite
)
+
aArgSize
)
{
mSerializedData
.
SetLength
(
*
aWrite
+
aArgSize
)
;
}
return
mozilla
:
:
webgl
:
:
Marshaller
:
:
WriteObject
(
mSerializedData
.
Elements
(
)
mSerializedData
.
Length
(
)
+
1
aRead
aWrite
arg
aArgSize
)
;
}
base
:
:
ProcessId
OtherPid
(
)
{
return
mActor
?
mActor
-
>
OtherPid
(
)
:
0
;
}
protected
:
size_t
MinSizeofArgs
(
mozilla
:
:
webgl
:
:
ProducerView
<
SelfType
>
&
aView
)
{
return
0
;
}
template
<
typename
Arg
typename
.
.
.
Args
>
size_t
MinSizeofArgs
(
mozilla
:
:
webgl
:
:
ProducerView
<
SelfType
>
&
aView
const
Arg
&
aArg
const
Args
&
.
.
.
aArgs
)
{
return
aView
.
MinSizeParam
(
aArg
)
+
MinSizeofArgs
(
aView
aArgs
.
.
.
)
;
}
}
;
template
<
typename
_Actor
>
class
IpdlConsumer
final
:
public
SupportsWeakPtr
{
public
:
using
Actor
=
_Actor
;
using
SelfType
=
IpdlConsumer
<
Actor
>
;
IpdlConsumer
(
)
:
mId
(
kIllegalQueueId
)
{
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryRemove
(
Args
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
mId
!
=
kIllegalQueueId
)
;
if
(
!
mActor
)
{
NS_WARNING
(
"
TryRemove
with
actor
that
was
already
freed
.
"
)
;
return
QueueStatus
:
:
kFatalError
;
}
mBuf
.
AppendElements
(
mActor
-
>
TakeIpdlQueueData
(
mId
)
)
;
return
DeserializeAllArgs
(
aArgs
.
.
.
)
;
}
template
<
typename
.
.
.
Args
>
QueueStatus
TryWaitRemove
(
const
Maybe
<
TimeDuration
>
&
Args
&
.
.
.
aArgs
)
{
return
TryRemove
(
aArgs
.
.
.
)
;
}
mozilla
:
:
ipc
:
:
Shmem
:
:
SharedMemory
*
LookupSharedMemory
(
uint32_t
aId
)
{
return
mActor
?
mActor
-
>
LookupSharedMemory
(
aId
)
:
nullptr
;
}
protected
:
template
<
typename
T1
typename
T2
>
friend
class
IpdlQueue
;
friend
struct
mozilla
:
:
ipc
:
:
IPDLParamTraits
<
SelfType
>
;
explicit
IpdlConsumer
(
uint64_t
aId
Actor
*
aActor
=
nullptr
)
:
mActor
(
aActor
)
mId
(
aId
)
{
}
template
<
typename
.
.
.
Args
>
QueueStatus
DeserializeAllArgs
(
Args
&
.
.
.
aArgs
)
{
size_t
read
=
0
;
size_t
write
=
mBuf
.
Length
(
)
;
mozilla
:
:
webgl
:
:
ConsumerView
<
SelfType
>
view
(
this
&
read
write
)
;
QueueStatus
status
=
DeserializeArgs
(
view
aArgs
.
.
.
)
;
if
(
IsSuccess
(
status
)
&
&
(
read
>
0
)
)
{
mBuf
.
RemoveElementsAt
(
0
read
)
;
}
return
status
;
}
QueueStatus
DeserializeArgs
(
mozilla
:
:
webgl
:
:
ConsumerView
<
SelfType
>
&
aView
)
{
return
QueueStatus
:
:
kSuccess
;
}
template
<
typename
Arg
typename
.
.
.
Args
>
QueueStatus
DeserializeArgs
(
mozilla
:
:
webgl
:
:
ConsumerView
<
SelfType
>
&
aView
Arg
&
aArg
Args
&
.
.
.
aArgs
)
{
QueueStatus
status
=
DeserializeArg
(
aView
aArg
)
;
if
(
!
IsSuccess
(
status
)
)
{
return
status
;
}
return
DeserializeArgs
(
aView
aArgs
.
.
.
)
;
}
template
<
typename
Arg
>
QueueStatus
DeserializeArg
(
mozilla
:
:
webgl
:
:
ConsumerView
<
SelfType
>
&
aView
Arg
&
aArg
)
{
return
mozilla
:
:
webgl
:
:
QueueParamTraits
<
typename
mozilla
:
:
webgl
:
:
RemoveCVR
<
Arg
>
:
:
Type
>
:
:
Read
(
aView
const_cast
<
std
:
:
remove_cv_t
<
Arg
>
*
>
(
&
aArg
)
)
;
}
public
:
template
<
typename
Arg
>
QueueStatus
ReadObject
(
size_t
*
aRead
size_t
aWrite
Arg
*
arg
size_t
aArgSize
)
{
return
mozilla
:
:
webgl
:
:
Marshaller
:
:
ReadObject
(
mBuf
.
Elements
(
)
mBuf
.
Length
(
)
+
1
aRead
aWrite
arg
aArgSize
)
;
}
base
:
:
ProcessId
OtherPid
(
)
{
return
mActor
?
mActor
-
>
OtherPid
(
)
:
0
;
}
protected
:
WeakPtr
<
Actor
>
mActor
;
uint64_t
mId
;
nsTArray
<
uint8_t
>
mBuf
;
}
;
template
<
typename
_ActorP
typename
_ActorC
>
class
IpdlQueue
final
{
public
:
using
ActorP
=
_ActorP
;
using
ActorC
=
_ActorC
;
using
Producer
=
IpdlProducer
<
ActorP
>
;
using
Consumer
=
IpdlConsumer
<
ActorC
>
;
UniquePtr
<
Producer
>
TakeProducer
(
)
{
return
std
:
:
move
(
mProducer
)
;
}
UniquePtr
<
Consumer
>
TakeConsumer
(
)
{
return
std
:
:
move
(
mConsumer
)
;
}
static
UniquePtr
<
IpdlQueue
<
ActorP
ActorC
>
>
Create
(
ActorP
*
aProducerActor
)
{
static_assert
(
std
:
:
is_same
<
typename
ActorP
:
:
OtherSideActor
ActorC
>
:
:
value
"
ActorP
'
s
reciprocal
must
be
ActorC
"
)
;
static_assert
(
std
:
:
is_same
<
typename
ActorC
:
:
OtherSideActor
ActorP
>
:
:
value
"
ActorC
'
s
reciprocal
must
be
ActorP
"
)
;
auto
id
=
NewIpdlQueueId
(
)
;
return
WrapUnique
(
new
IpdlQueue
<
ActorP
ActorC
>
(
std
:
:
move
(
WrapUnique
(
new
Producer
(
id
aProducerActor
)
)
)
std
:
:
move
(
WrapUnique
(
new
Consumer
(
id
)
)
)
)
)
;
}
static
UniquePtr
<
IpdlQueue
<
ActorP
ActorC
>
>
Create
(
ActorC
*
aConsumerActor
)
{
static_assert
(
std
:
:
is_same
<
typename
ActorP
:
:
OtherSideActor
ActorC
>
:
:
value
"
ActorP
'
s
reciprocal
must
be
ActorC
"
)
;
static_assert
(
std
:
:
is_same
<
typename
ActorC
:
:
OtherSideActor
ActorP
>
:
:
value
"
ActorC
'
s
reciprocal
must
be
ActorP
"
)
;
auto
id
=
NewIpdlQueueId
(
)
;
return
WrapUnique
(
new
IpdlQueue
<
ActorP
ActorC
>
(
std
:
:
move
(
WrapUnique
(
new
Producer
(
id
)
)
)
std
:
:
move
(
WrapUnique
(
new
Consumer
(
id
aConsumerActor
)
)
)
)
)
;
}
private
:
IpdlQueue
(
UniquePtr
<
Producer
>
&
&
aProducer
UniquePtr
<
Consumer
>
&
&
aConsumer
)
:
mProducer
(
std
:
:
move
(
aProducer
)
)
mConsumer
(
std
:
:
move
(
aConsumer
)
)
{
}
UniquePtr
<
Producer
>
mProducer
;
UniquePtr
<
Consumer
>
mConsumer
;
}
;
}
namespace
ipc
{
template
<
typename
Actor
>
struct
IPDLParamTraits
<
mozilla
:
:
dom
:
:
IpdlProducer
<
Actor
>
>
{
typedef
mozilla
:
:
dom
:
:
IpdlProducer
<
Actor
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
aParam
.
mActor
=
=
nullptr
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mId
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
aResult
-
>
mActor
=
static_cast
<
Actor
*
>
(
aActor
)
;
return
ReadIPDLParam
(
aMsg
aIter
aActor
&
aResult
-
>
mId
)
;
}
}
;
template
<
typename
Actor
>
struct
IPDLParamTraits
<
mozilla
:
:
dom
:
:
IpdlConsumer
<
Actor
>
>
{
typedef
mozilla
:
:
dom
:
:
IpdlConsumer
<
Actor
>
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
MOZ_ASSERT
(
aParam
.
mActor
=
=
nullptr
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mId
)
;
WriteIPDLParam
(
aMsg
aActor
aParam
.
mBuf
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
aResult
-
>
mActor
=
static_cast
<
Actor
*
>
(
aActor
)
;
return
ReadIPDLParam
(
aMsg
aIter
aActor
&
aResult
-
>
mId
)
&
&
ReadIPDLParam
(
aMsg
aIter
aActor
&
aResult
-
>
mBuf
)
;
}
}
;
template
<
>
struct
IPDLParamTraits
<
mozilla
:
:
dom
:
:
IpdlQueueBuffer
>
{
typedef
mozilla
:
:
dom
:
:
IpdlQueueBuffer
paramType
;
static
void
Write
(
IPC
:
:
Message
*
aMsg
IProtocol
*
aActor
const
paramType
&
aParam
)
{
WriteParam
(
aMsg
aParam
.
id
)
;
WriteParam
(
aMsg
aParam
.
data
)
;
}
static
bool
Read
(
const
IPC
:
:
Message
*
aMsg
PickleIterator
*
aIter
IProtocol
*
aActor
paramType
*
aResult
)
{
return
ReadParam
(
aMsg
aIter
&
aResult
-
>
id
)
&
&
ReadParam
(
aMsg
aIter
&
aResult
-
>
data
)
;
}
}
;
}
}
#
endif
