#
include
"
DrawTargetWebglInternal
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
gfx
/
Blur
.
h
"
#
include
"
mozilla
/
gfx
/
DrawTargetSkia
.
h
"
#
include
"
mozilla
/
gfx
/
HelpersSkia
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
PathSkia
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
ClientWebGLContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
namespace
mozilla
:
:
gfx
{
Maybe
<
IntPoint
>
TexturePacker
:
:
Insert
(
const
IntSize
&
aSize
)
{
if
(
mAvailable
<
std
:
:
min
(
aSize
.
width
aSize
.
height
)
|
|
mBounds
.
width
<
aSize
.
width
|
|
mBounds
.
height
<
aSize
.
height
)
{
return
Nothing
(
)
;
}
if
(
mChildren
[
0
]
)
{
Maybe
<
IntPoint
>
inserted
=
mChildren
[
0
]
-
>
Insert
(
aSize
)
;
if
(
!
inserted
)
{
inserted
=
mChildren
[
1
]
-
>
Insert
(
aSize
)
;
}
if
(
inserted
)
{
mAvailable
=
std
:
:
max
(
mChildren
[
0
]
-
>
mAvailable
mChildren
[
1
]
-
>
mAvailable
)
;
if
(
!
mAvailable
)
{
DiscardChildren
(
)
;
}
}
return
inserted
;
}
if
(
mBounds
.
Size
(
)
=
=
aSize
)
{
mAvailable
=
0
;
return
Some
(
mBounds
.
TopLeft
(
)
)
;
}
if
(
mBounds
.
width
-
aSize
.
width
>
mBounds
.
height
-
aSize
.
height
)
{
mChildren
[
0
]
.
reset
(
new
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
aSize
.
width
mBounds
.
height
)
)
)
;
mChildren
[
1
]
.
reset
(
new
TexturePacker
(
IntRect
(
mBounds
.
x
+
aSize
.
width
mBounds
.
y
mBounds
.
width
-
aSize
.
width
mBounds
.
height
)
)
)
;
}
else
{
mChildren
[
0
]
.
reset
(
new
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
mBounds
.
width
aSize
.
height
)
)
)
;
mChildren
[
1
]
.
reset
(
new
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
+
aSize
.
height
mBounds
.
width
mBounds
.
height
-
aSize
.
height
)
)
)
;
}
Maybe
<
IntPoint
>
inserted
=
mChildren
[
0
]
-
>
Insert
(
aSize
)
;
mAvailable
=
std
:
:
max
(
mChildren
[
0
]
-
>
mAvailable
mChildren
[
1
]
-
>
mAvailable
)
;
return
inserted
;
}
bool
TexturePacker
:
:
Remove
(
const
IntRect
&
aBounds
)
{
if
(
!
mChildren
[
0
]
)
{
if
(
mAvailable
>
0
|
|
!
mBounds
.
Contains
(
aBounds
)
)
{
return
false
;
}
if
(
mBounds
=
=
aBounds
)
{
mAvailable
=
std
:
:
min
(
mBounds
.
width
mBounds
.
height
)
;
return
true
;
}
if
(
mBounds
.
width
-
aBounds
.
width
>
mBounds
.
height
-
aBounds
.
height
)
{
int
split
=
aBounds
.
x
-
mBounds
.
x
>
mBounds
.
XMost
(
)
-
aBounds
.
XMost
(
)
?
aBounds
.
x
:
aBounds
.
XMost
(
)
;
mChildren
[
0
]
.
reset
(
new
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
split
-
mBounds
.
x
mBounds
.
height
)
false
)
)
;
mChildren
[
1
]
.
reset
(
new
TexturePacker
(
IntRect
(
split
mBounds
.
y
mBounds
.
XMost
(
)
-
split
mBounds
.
height
)
false
)
)
;
}
else
{
int
split
=
aBounds
.
y
-
mBounds
.
y
>
mBounds
.
YMost
(
)
-
aBounds
.
YMost
(
)
?
aBounds
.
y
:
aBounds
.
YMost
(
)
;
mChildren
[
0
]
.
reset
(
new
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
mBounds
.
width
split
-
mBounds
.
y
)
false
)
)
;
mChildren
[
1
]
.
reset
(
new
TexturePacker
(
IntRect
(
mBounds
.
x
split
mBounds
.
width
mBounds
.
YMost
(
)
-
split
)
false
)
)
;
}
}
bool
next
=
mChildren
[
0
]
-
>
mBounds
.
x
<
mChildren
[
1
]
-
>
mBounds
.
x
?
aBounds
.
x
>
=
mChildren
[
1
]
-
>
mBounds
.
x
:
aBounds
.
y
>
=
mChildren
[
1
]
-
>
mBounds
.
y
;
bool
removed
=
mChildren
[
next
?
1
:
0
]
-
>
Remove
(
aBounds
)
;
if
(
removed
)
{
if
(
mChildren
[
0
]
-
>
IsFullyAvailable
(
)
&
&
mChildren
[
1
]
-
>
IsFullyAvailable
(
)
)
{
DiscardChildren
(
)
;
mAvailable
=
std
:
:
min
(
mBounds
.
width
mBounds
.
height
)
;
}
else
{
mAvailable
=
std
:
:
max
(
mChildren
[
0
]
-
>
mAvailable
mChildren
[
1
]
-
>
mAvailable
)
;
}
}
return
removed
;
}
SharedTexture
:
:
SharedTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTextureJS
>
&
aTexture
)
:
mPacker
(
IntRect
(
IntPoint
(
0
0
)
aSize
)
)
mFormat
(
aFormat
)
mTexture
(
aTexture
)
{
}
SharedTextureHandle
:
:
SharedTextureHandle
(
const
IntRect
&
aBounds
SharedTexture
*
aTexture
)
:
mBounds
(
aBounds
)
mTexture
(
aTexture
)
{
}
already_AddRefed
<
SharedTextureHandle
>
SharedTexture
:
:
Allocate
(
const
IntSize
&
aSize
)
{
RefPtr
<
SharedTextureHandle
>
handle
;
if
(
Maybe
<
IntPoint
>
origin
=
mPacker
.
Insert
(
aSize
)
)
{
handle
=
new
SharedTextureHandle
(
IntRect
(
*
origin
aSize
)
this
)
;
+
+
mAllocatedHandles
;
}
return
handle
.
forget
(
)
;
}
bool
SharedTexture
:
:
Free
(
const
SharedTextureHandle
&
aHandle
)
{
if
(
aHandle
.
mTexture
!
=
this
)
{
return
false
;
}
if
(
!
mPacker
.
Remove
(
aHandle
.
mBounds
)
)
{
return
false
;
}
-
-
mAllocatedHandles
;
return
true
;
}
StandaloneTexture
:
:
StandaloneTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTextureJS
>
&
aTexture
)
:
mSize
(
aSize
)
mFormat
(
aFormat
)
mTexture
(
aTexture
)
{
}
DrawTargetWebgl
:
:
DrawTargetWebgl
(
)
=
default
;
DrawTargetWebgl
:
:
~
DrawTargetWebgl
(
)
{
while
(
!
mTextureHandles
.
isEmpty
(
)
)
{
PruneTextureHandle
(
mTextureHandles
.
popLast
(
)
)
;
-
-
mNumTextureHandles
;
}
UnlinkSurfaceTextures
(
)
;
UnlinkGlyphCaches
(
)
;
}
inline
void
DrawTargetWebgl
:
:
UnlinkSurfaceTexture
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
if
(
SourceSurface
*
surface
=
aHandle
-
>
GetSurface
(
)
)
{
surface
-
>
RemoveUserData
(
aHandle
-
>
IsShadow
(
)
?
&
mShadowTextureKey
:
&
mTextureHandleKey
)
;
}
}
void
DrawTargetWebgl
:
:
UnlinkSurfaceTextures
(
)
{
for
(
RefPtr
<
TextureHandle
>
handle
=
mTextureHandles
.
getFirst
(
)
;
handle
;
handle
=
handle
-
>
getNext
(
)
)
{
UnlinkSurfaceTexture
(
handle
)
;
}
}
void
DrawTargetWebgl
:
:
UnlinkGlyphCaches
(
)
{
GlyphCache
*
cache
=
mGlyphCaches
.
getFirst
(
)
;
while
(
cache
)
{
ScaledFont
*
font
=
cache
-
>
GetFont
(
)
;
cache
=
cache
-
>
getNext
(
)
;
font
-
>
RemoveUserData
(
&
mGlyphCacheKey
)
;
}
}
bool
DrawTargetWebgl
:
:
Init
(
const
IntSize
&
size
const
SurfaceFormat
format
)
{
WebGLContextOptions
options
=
{
}
;
options
.
alpha
=
!
IsOpaque
(
format
)
;
options
.
depth
=
false
;
options
.
stencil
=
false
;
options
.
antialias
=
true
;
options
.
preserveDrawingBuffer
=
true
;
options
.
failIfMajorPerformanceCaveat
=
true
;
mWebgl
=
new
ClientWebGLContext
(
true
)
;
mWebgl
-
>
SetContextOptions
(
options
)
;
if
(
mWebgl
-
>
SetDimensions
(
size
.
width
size
.
height
)
!
=
NS_OK
)
{
mWebgl
=
nullptr
;
return
false
;
}
mMaxTextureSize
=
mWebgl
-
>
Limits
(
)
.
maxTex2dSize
;
if
(
size_t
(
std
:
:
max
(
size
.
width
size
.
height
)
)
>
mMaxTextureSize
)
{
mWebgl
=
nullptr
;
return
false
;
}
if
(
!
CreateShaders
(
)
)
{
mWebgl
=
nullptr
;
return
false
;
}
mSkia
=
new
DrawTargetSkia
;
if
(
!
mSkia
-
>
Init
(
size
SurfaceFormat
:
:
B8G8R8A8
)
)
{
return
false
;
}
mSize
=
size
;
mFormat
=
format
;
return
true
;
}
bool
DrawTargetWebgl
:
:
IsValid
(
)
const
{
return
mWebgl
&
&
!
mWebgl
-
>
IsContextLost
(
)
;
}
already_AddRefed
<
DrawTargetWebgl
>
DrawTargetWebgl
:
:
Create
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
!
StaticPrefs
:
:
gfx_canvas_accelerated
(
)
)
{
return
nullptr
;
}
static
const
int32_t
kMinDimension
=
16
;
if
(
std
:
:
min
(
aSize
.
width
aSize
.
height
)
<
kMinDimension
)
{
return
nullptr
;
}
int32_t
minSize
=
StaticPrefs
:
:
gfx_canvas_accelerated_min_size
(
)
;
if
(
aSize
.
width
*
aSize
.
height
<
minSize
*
minSize
)
{
return
nullptr
;
}
int32_t
maxSize
=
StaticPrefs
:
:
gfx_canvas_accelerated_max_size
(
)
;
if
(
maxSize
>
0
)
{
if
(
std
:
:
max
(
aSize
.
width
aSize
.
height
)
>
maxSize
)
{
return
nullptr
;
}
}
else
if
(
maxSize
<
0
)
{
static
const
int32_t
kScreenPixels
=
980
*
480
;
IntSize
screenSize
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetScreenSize
(
)
;
if
(
aSize
.
width
*
aSize
.
height
>
std
:
:
max
(
screenSize
.
width
*
screenSize
.
height
kScreenPixels
)
)
{
return
nullptr
;
}
}
RefPtr
<
DrawTargetWebgl
>
dt
=
new
DrawTargetWebgl
;
if
(
!
dt
-
>
Init
(
aSize
aFormat
)
|
|
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
return
dt
.
forget
(
)
;
}
void
*
DrawTargetWebgl
:
:
GetNativeSurface
(
NativeSurfaceType
aType
)
{
switch
(
aType
)
{
case
NativeSurfaceType
:
:
WEBGL_CONTEXT
:
if
(
mWebgl
-
>
IsContextLost
(
)
)
{
return
nullptr
;
}
if
(
!
mWebglValid
)
{
FlushFromSkia
(
)
;
}
return
mWebgl
.
get
(
)
;
default
:
return
nullptr
;
}
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
Snapshot
(
)
{
if
(
mSkiaValid
)
{
if
(
mSkiaLayer
)
{
FlattenSkia
(
)
;
}
return
mSkia
-
>
Snapshot
(
)
;
}
RefPtr
<
SourceSurface
>
snapshot
=
mSnapshot
;
if
(
snapshot
)
{
return
snapshot
.
forget
(
)
;
}
if
(
mWebgl
-
>
IsContextLost
(
)
)
{
return
nullptr
;
}
mSnapshot
=
Factory
:
:
CreateDataSourceSurface
(
mSize
mFormat
)
;
if
(
!
mSnapshot
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
dstMap
(
mSnapshot
DataSourceSurface
:
:
WRITE
)
;
if
(
!
dstMap
.
IsMapped
(
)
|
|
!
ReadInto
(
dstMap
.
GetData
(
)
dstMap
.
GetStride
(
)
)
)
{
mSnapshot
=
nullptr
;
return
nullptr
;
}
snapshot
=
mSnapshot
;
return
snapshot
.
forget
(
)
;
}
bool
DrawTargetWebgl
:
:
ReadInto
(
uint8_t
*
aDstData
int32_t
aDstStride
)
{
RefPtr
<
DataSourceSurface
>
temp
=
Factory
:
:
CreateDataSourceSurface
(
mSize
mFormat
)
;
if
(
!
temp
)
{
return
false
;
}
DataSourceSurface
:
:
ScopedMap
srcMap
(
temp
DataSourceSurface
:
:
READ_WRITE
)
;
if
(
!
srcMap
.
IsMapped
(
)
)
{
return
false
;
}
int32_t
srcStride
=
srcMap
.
GetStride
(
)
;
webgl
:
:
ReadPixelsDesc
desc
;
desc
.
srcOffset
=
{
0
0
}
;
desc
.
size
=
*
uvec2
:
:
FromSize
(
mSize
)
;
desc
.
packState
.
rowLength
=
srcStride
/
4
;
Range
<
uint8_t
>
range
=
{
srcMap
.
GetData
(
)
size_t
(
srcStride
)
*
mSize
.
height
}
;
mWebgl
-
>
DoReadPixels
(
desc
range
)
;
const
uint8_t
*
srcRow
=
srcMap
.
GetData
(
)
;
uint8_t
*
dstRow
=
aDstData
+
size_t
(
aDstStride
)
*
mSize
.
height
;
for
(
int
y
=
0
;
y
<
mSize
.
height
;
y
+
+
)
{
dstRow
-
=
aDstStride
;
SwizzleData
(
srcRow
srcMap
.
GetStride
(
)
SurfaceFormat
:
:
B8G8R8A8
dstRow
aDstStride
SurfaceFormat
:
:
R8G8B8A8
IntSize
(
mSize
.
width
1
)
)
;
srcRow
+
=
srcStride
;
}
return
true
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
GetBackingSurface
(
)
{
return
Snapshot
(
)
;
}
void
DrawTargetWebgl
:
:
MarkChanged
(
)
{
mSkiaValid
=
false
;
mSnapshot
=
nullptr
;
}
bool
DrawTargetWebgl
:
:
LockBits
(
uint8_t
*
*
aData
IntSize
*
aSize
int32_t
*
aStride
SurfaceFormat
*
aFormat
IntPoint
*
aOrigin
)
{
if
(
mSkiaValid
&
&
!
mSkiaLayer
)
{
return
mSkia
-
>
LockBits
(
aData
aSize
aStride
aFormat
aOrigin
)
;
}
return
false
;
}
void
DrawTargetWebgl
:
:
ReleaseBits
(
uint8_t
*
aData
)
{
if
(
mSkiaValid
&
&
!
mSkiaLayer
)
{
mSkia
-
>
ReleaseBits
(
aData
)
;
}
}
bool
DrawTargetWebgl
:
:
CreateShaders
(
)
{
if
(
!
mVertexArray
)
{
mVertexArray
=
mWebgl
-
>
CreateVertexArray
(
)
;
}
if
(
!
mVertexBuffer
)
{
mVertexBuffer
=
mWebgl
-
>
CreateBuffer
(
)
;
static
const
float
rectData
[
8
]
=
{
0
.
0f
0
.
0f
1
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
}
;
mWebgl
-
>
BindVertexArray
(
mVertexArray
.
get
(
)
)
;
mWebgl
-
>
BindBuffer
(
LOCAL_GL_ARRAY_BUFFER
mVertexBuffer
.
get
(
)
)
;
mWebgl
-
>
RawBufferData
(
LOCAL_GL_ARRAY_BUFFER
{
(
const
uint8_t
*
)
rectData
sizeof
(
rectData
)
}
LOCAL_GL_STATIC_DRAW
)
;
mWebgl
-
>
EnableVertexAttribArray
(
0
)
;
mWebgl
-
>
VertexAttribPointer
(
0
2
LOCAL_GL_FLOAT
LOCAL_GL_FALSE
0
0
)
;
}
if
(
!
mSolidProgram
)
{
auto
vsSource
=
u
"
attribute
vec2
a_vertex
;
\
n
"
"
uniform
vec2
u_transform
[
3
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
vertex
=
u_transform
[
0
]
*
a_vertex
.
x
+
\
n
"
"
u_transform
[
1
]
*
a_vertex
.
y
+
\
n
"
"
u_transform
[
2
]
;
\
n
"
"
gl_Position
=
vec4
(
vertex
0
.
0
1
.
0
)
;
\
n
"
"
}
\
n
"
_ns
;
auto
fsSource
=
u
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u_color
;
\
n
"
"
void
main
(
)
{
\
n
"
"
gl_FragColor
=
u_color
;
\
n
"
"
}
\
n
"
_ns
;
RefPtr
<
WebGLShaderJS
>
vsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_VERTEX_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
vsId
vsSource
)
;
mWebgl
-
>
CompileShader
(
*
vsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
vsId
)
.
success
)
{
return
false
;
}
RefPtr
<
WebGLShaderJS
>
fsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_FRAGMENT_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
fsId
fsSource
)
;
mWebgl
-
>
CompileShader
(
*
fsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
fsId
)
.
success
)
{
return
false
;
}
mSolidProgram
=
mWebgl
-
>
CreateProgram
(
)
;
mWebgl
-
>
AttachShader
(
*
mSolidProgram
*
vsId
)
;
mWebgl
-
>
AttachShader
(
*
mSolidProgram
*
fsId
)
;
mWebgl
-
>
BindAttribLocation
(
*
mSolidProgram
0
u
"
a_vertex
"
_ns
)
;
mWebgl
-
>
LinkProgram
(
*
mSolidProgram
)
;
if
(
!
mWebgl
-
>
GetLinkResult
(
*
mSolidProgram
)
.
success
)
{
return
false
;
}
mSolidProgramTransform
=
mWebgl
-
>
GetUniformLocation
(
*
mSolidProgram
u
"
u_transform
"
_ns
)
;
mSolidProgramColor
=
mWebgl
-
>
GetUniformLocation
(
*
mSolidProgram
u
"
u_color
"
_ns
)
;
if
(
!
mSolidProgramTransform
|
|
!
mSolidProgramColor
)
{
return
false
;
}
}
if
(
!
mImageProgram
)
{
auto
vsSource
=
u
"
attribute
vec2
a_vertex
;
\
n
"
"
varying
vec2
v_texcoord
;
\
n
"
"
uniform
vec2
u_transform
[
3
]
;
\
n
"
"
uniform
vec2
u_texmatrix
[
3
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
vertex
=
u_transform
[
0
]
*
a_vertex
.
x
+
\
n
"
"
u_transform
[
1
]
*
a_vertex
.
y
+
\
n
"
"
u_transform
[
2
]
;
\
n
"
"
gl_Position
=
vec4
(
vertex
0
.
0
1
.
0
)
;
\
n
"
"
v_texcoord
=
u_texmatrix
[
0
]
*
a_vertex
.
x
+
\
n
"
"
u_texmatrix
[
1
]
*
a_vertex
.
y
+
\
n
"
"
u_texmatrix
[
2
]
;
\
n
"
"
}
\
n
"
_ns
;
auto
fsSource
=
u
"
precision
mediump
float
;
\
n
"
"
varying
vec2
v_texcoord
;
\
n
"
"
uniform
vec4
u_texbounds
;
\
n
"
"
uniform
vec4
u_color
;
\
n
"
"
uniform
float
u_swizzle
;
\
n
"
"
uniform
sampler2D
u_sampler
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
tc
=
clamp
(
v_texcoord
u_texbounds
.
xy
u_texbounds
.
zw
)
;
\
n
"
"
vec4
image
=
texture2D
(
u_sampler
tc
)
;
\
n
"
"
gl_FragColor
=
u_color
*
mix
(
image
.
bgra
image
.
rrrr
u_swizzle
)
;
\
n
"
"
}
\
n
"
_ns
;
RefPtr
<
WebGLShaderJS
>
vsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_VERTEX_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
vsId
vsSource
)
;
mWebgl
-
>
CompileShader
(
*
vsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
vsId
)
.
success
)
{
return
false
;
}
RefPtr
<
WebGLShaderJS
>
fsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_FRAGMENT_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
fsId
fsSource
)
;
mWebgl
-
>
CompileShader
(
*
fsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
fsId
)
.
success
)
{
return
false
;
}
mImageProgram
=
mWebgl
-
>
CreateProgram
(
)
;
mWebgl
-
>
AttachShader
(
*
mImageProgram
*
vsId
)
;
mWebgl
-
>
AttachShader
(
*
mImageProgram
*
fsId
)
;
mWebgl
-
>
BindAttribLocation
(
*
mImageProgram
0
u
"
a_vertex
"
_ns
)
;
mWebgl
-
>
LinkProgram
(
*
mImageProgram
)
;
if
(
!
mWebgl
-
>
GetLinkResult
(
*
mImageProgram
)
.
success
)
{
return
false
;
}
mImageProgramTransform
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_transform
"
_ns
)
;
mImageProgramTexMatrix
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_texmatrix
"
_ns
)
;
mImageProgramTexBounds
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_texbounds
"
_ns
)
;
mImageProgramSwizzle
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_swizzle
"
_ns
)
;
mImageProgramColor
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_color
"
_ns
)
;
mImageProgramSampler
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_sampler
"
_ns
)
;
if
(
!
mImageProgramTransform
|
|
!
mImageProgramTexMatrix
|
|
!
mImageProgramTexBounds
|
|
!
mImageProgramSwizzle
|
|
!
mImageProgramColor
|
|
!
mImageProgramSampler
)
{
return
false
;
}
}
return
true
;
}
void
DrawTargetWebgl
:
:
ClearRect
(
const
Rect
&
aRect
)
{
ColorPattern
pattern
(
DeviceColor
(
0
.
0f
0
.
0f
0
.
0f
IsOpaque
(
mFormat
)
?
1
.
0f
:
0
.
0f
)
)
;
DrawRect
(
aRect
pattern
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
}
void
DrawTargetWebgl
:
:
CopySurface
(
SourceSurface
*
aSurface
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
{
if
(
mSkiaValid
)
{
if
(
mSkiaLayer
)
{
if
(
IntRect
(
aDestination
aSourceRect
.
Size
(
)
)
.
Contains
(
GetRect
(
)
)
)
{
mSkiaLayer
=
false
;
}
else
if
(
!
IsOpaque
(
aSurface
-
>
GetFormat
(
)
)
)
{
FlattenSkia
(
)
;
}
}
else
{
MarkSkiaChanged
(
)
;
}
mSkia
-
>
CopySurface
(
aSurface
aSourceRect
aDestination
)
;
return
;
}
Matrix
matrix
=
Matrix
:
:
Translation
(
aDestination
-
aSourceRect
.
TopLeft
(
)
)
;
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
matrix
)
;
DrawRect
(
Rect
(
IntRect
(
aDestination
aSourceRect
.
Size
(
)
)
)
pattern
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
Nothing
(
)
nullptr
false
false
)
;
}
void
DrawTargetWebgl
:
:
PushClip
(
const
Path
*
aPath
)
{
mSkia
-
>
PushClip
(
aPath
)
;
}
void
DrawTargetWebgl
:
:
PushClipRect
(
const
Rect
&
aRect
)
{
mSkia
-
>
PushClipRect
(
aRect
)
;
}
void
DrawTargetWebgl
:
:
PushDeviceSpaceClipRects
(
const
IntRect
*
aRects
uint32_t
aCount
)
{
mSkia
-
>
PushDeviceSpaceClipRects
(
aRects
aCount
)
;
}
void
DrawTargetWebgl
:
:
PopClip
(
)
{
mSkia
-
>
PopClip
(
)
;
}
static
inline
bool
SupportsDrawOptions
(
const
DrawOptions
&
aOptions
)
{
switch
(
aOptions
.
mCompositionOp
)
{
case
CompositionOp
:
:
OP_OVER
:
case
CompositionOp
:
:
OP_ADD
:
case
CompositionOp
:
:
OP_ATOP
:
case
CompositionOp
:
:
OP_SOURCE
:
return
true
;
default
:
return
false
;
}
}
bool
DrawTargetWebgl
:
:
SupportsPattern
(
const
Pattern
&
aPattern
)
{
switch
(
aPattern
.
GetType
(
)
)
{
case
PatternType
:
:
COLOR
:
return
true
;
case
PatternType
:
:
SURFACE
:
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
if
(
surfacePattern
.
mSurface
)
{
IntSize
size
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
int32_t
maxSize
=
int32_t
(
std
:
:
min
(
StaticPrefs
:
:
gfx_canvas_accelerated_max_surface_size
(
)
mMaxTextureSize
)
)
;
if
(
std
:
:
max
(
size
.
width
size
.
height
)
>
maxSize
&
&
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
|
|
std
:
:
max
(
surfacePattern
.
mSamplingRect
.
width
surfacePattern
.
mSamplingRect
.
height
)
>
maxSize
)
)
{
return
false
;
}
}
return
true
;
}
default
:
return
false
;
}
}
static
void
ReleaseTextureHandle
(
void
*
aPtr
)
{
static_cast
<
TextureHandle
*
>
(
aPtr
)
-
>
SetSurface
(
nullptr
)
;
}
bool
DrawTargetWebgl
:
:
DrawRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
Maybe
<
DeviceColor
>
aMaskColor
RefPtr
<
TextureHandle
>
*
aHandle
bool
aTransformed
bool
aClipped
bool
aAccelOnly
bool
aForceUpdate
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
true
;
}
Maybe
<
IntRect
>
intClip
;
if
(
!
aClipped
)
{
intClip
=
Some
(
IntRect
(
IntPoint
(
)
mSize
)
)
;
}
else
if
(
Maybe
<
Rect
>
clip
=
mSkia
-
>
GetDeviceClipRect
(
)
)
{
if
(
clip
-
>
IsEmpty
(
)
)
{
return
true
;
}
IntRect
intRect
=
RoundedToInt
(
*
clip
)
;
if
(
clip
-
>
WithinEpsilonOf
(
Rect
(
intRect
)
1
.
0e
-
3f
)
)
{
intClip
=
Some
(
intRect
)
;
}
}
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
!
SupportsPattern
(
aPattern
)
|
|
!
intClip
|
|
mWebgl
-
>
IsContextLost
(
)
)
{
if
(
aAccelOnly
)
{
return
false
;
}
MarkSkiaChanged
(
aOptions
)
;
if
(
aTransformed
)
{
if
(
aMaskColor
)
{
mSkia
-
>
Mask
(
ColorPattern
(
*
aMaskColor
)
aPattern
aOptions
)
;
}
else
if
(
aStrokeOptions
)
{
mSkia
-
>
StrokeRect
(
aRect
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
}
else
if
(
aClipped
)
{
mSkia
-
>
SetTransform
(
Matrix
(
)
)
;
if
(
aMaskColor
)
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
if
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
)
{
mSkia
-
>
MaskSurface
(
ColorPattern
(
*
aMaskColor
)
surfacePattern
.
mSurface
aRect
.
TopLeft
(
)
aOptions
)
;
}
else
{
mSkia
-
>
Mask
(
ColorPattern
(
*
aMaskColor
)
aPattern
aOptions
)
;
}
}
else
if
(
aStrokeOptions
)
{
mSkia
-
>
StrokeRect
(
aRect
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
mSkia
-
>
SetTransform
(
mTransform
)
;
}
else
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
SURFACE
)
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
mSkia
-
>
CopySurface
(
surfacePattern
.
mSurface
surfacePattern
.
mSurface
-
>
GetRect
(
)
IntPoint
:
:
Round
(
aRect
.
TopLeft
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
}
return
false
;
}
if
(
!
mWebglValid
)
{
FlushFromSkia
(
)
;
}
MarkChanged
(
)
;
if
(
aOptions
.
mCompositionOp
!
=
mLastCompositionOp
)
{
mLastCompositionOp
=
aOptions
.
mCompositionOp
;
mWebgl
-
>
Enable
(
LOCAL_GL_BLEND
)
;
switch
(
aOptions
.
mCompositionOp
)
{
case
CompositionOp
:
:
OP_OVER
:
mWebgl
-
>
BlendFuncSeparate
(
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
break
;
case
CompositionOp
:
:
OP_ADD
:
mWebgl
-
>
BlendFuncSeparate
(
LOCAL_GL_ONE
LOCAL_GL_ONE
LOCAL_GL_ONE
LOCAL_GL_ONE
)
;
break
;
case
CompositionOp
:
:
OP_ATOP
:
mWebgl
-
>
BlendFuncSeparate
(
LOCAL_GL_DST_ALPHA
LOCAL_GL_ONE_MINUS_SRC_ALPHA
LOCAL_GL_DST_ALPHA
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
break
;
case
CompositionOp
:
:
OP_SOURCE
:
default
:
mWebgl
-
>
Disable
(
LOCAL_GL_BLEND
)
;
break
;
}
}
if
(
intClip
-
>
Contains
(
IntRect
(
IntPoint
(
)
mSize
)
)
)
{
intClip
=
Nothing
(
)
;
}
else
{
mWebgl
-
>
Enable
(
LOCAL_GL_SCISSOR_TEST
)
;
mWebgl
-
>
Scissor
(
intClip
-
>
x
mSize
.
height
-
(
intClip
-
>
y
+
intClip
-
>
height
)
intClip
-
>
width
intClip
-
>
height
)
;
}
switch
(
aPattern
.
GetType
(
)
)
{
case
PatternType
:
:
COLOR
:
{
auto
color
=
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
;
if
(
(
(
color
.
a
*
aOptions
.
mAlpha
=
=
1
.
0f
&
&
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_OVER
)
|
|
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
)
&
&
mTransform
.
HasOnlyIntegerTranslation
(
)
)
{
auto
intRect
=
RoundedToInt
(
aRect
)
;
if
(
aRect
.
WithinEpsilonOf
(
Rect
(
intRect
)
1
.
0e
-
3f
)
)
{
intRect
+
=
RoundedToInt
(
mTransform
.
GetTranslation
(
)
)
;
IntRect
bounds
=
intClip
.
refOr
(
IntRect
(
IntPoint
(
)
mSize
)
)
;
bool
scissor
=
!
intRect
.
Contains
(
bounds
)
;
if
(
scissor
)
{
mWebgl
-
>
Enable
(
LOCAL_GL_SCISSOR_TEST
)
;
intRect
=
intRect
.
Intersect
(
intClip
.
refOr
(
IntRect
(
IntPoint
(
)
mSize
)
)
)
;
mWebgl
-
>
Scissor
(
intRect
.
x
mSize
.
height
-
(
intRect
.
y
+
intRect
.
height
)
intRect
.
width
intRect
.
height
)
;
}
float
a
=
color
.
a
*
aOptions
.
mAlpha
;
mWebgl
-
>
ClearColor
(
color
.
r
*
a
color
.
g
*
a
color
.
b
*
a
a
)
;
mWebgl
-
>
Clear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
if
(
scissor
)
{
mWebgl
-
>
Disable
(
LOCAL_GL_SCISSOR_TEST
)
;
}
break
;
}
}
mWebgl
-
>
UseProgram
(
mSolidProgram
.
get
(
)
)
;
float
a
=
color
.
a
*
aOptions
.
mAlpha
;
float
colorData
[
4
]
=
{
color
.
r
*
a
color
.
g
*
a
color
.
b
*
a
a
}
;
Matrix
xform
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
if
(
aTransformed
)
{
xform
*
=
mTransform
;
}
xform
*
=
Matrix
(
2
.
0f
/
float
(
mSize
.
width
)
0
.
0f
0
.
0f
-
2
.
0f
/
float
(
mSize
.
height
)
-
1
1
)
;
float
xformData
[
6
]
=
{
xform
.
_11
xform
.
_12
xform
.
_21
xform
.
_22
xform
.
_31
xform
.
_32
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mSolidProgramTransform
false
{
(
const
uint8_t
*
)
xformData
sizeof
(
xformData
)
}
)
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC4
mSolidProgramColor
false
{
(
const
uint8_t
*
)
colorData
sizeof
(
colorData
)
}
)
;
mWebgl
-
>
DrawArrays
(
aStrokeOptions
?
LOCAL_GL_LINE_LOOP
:
LOCAL_GL_TRIANGLE_FAN
0
4
)
;
break
;
}
case
PatternType
:
:
SURFACE
:
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
RefPtr
<
TextureHandle
>
handle
=
aHandle
?
aHandle
-
>
get
(
)
:
(
surfacePattern
.
mSurface
?
static_cast
<
TextureHandle
*
>
(
surfacePattern
.
mSurface
-
>
GetUserData
(
&
mTextureHandleKey
)
)
:
nullptr
)
;
IntSize
texSize
;
IntPoint
offset
;
SurfaceFormat
format
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
&
&
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
|
|
handle
-
>
GetSamplingRect
(
)
.
IsEqualEdges
(
surfacePattern
.
mSamplingRect
)
)
)
{
texSize
=
handle
-
>
GetSize
(
)
;
format
=
handle
-
>
GetFormat
(
)
;
offset
=
handle
-
>
GetSamplingOffset
(
)
;
}
else
{
handle
=
nullptr
;
if
(
!
surfacePattern
.
mSurface
)
{
break
;
}
texSize
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
format
=
surfacePattern
.
mSurface
-
>
GetFormat
(
)
;
if
(
!
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
)
{
texSize
=
surfacePattern
.
mSamplingRect
.
Size
(
)
;
offset
=
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
;
}
}
mWebgl
-
>
UseProgram
(
mImageProgram
.
get
(
)
)
;
DeviceColor
color
=
aMaskColor
.
valueOr
(
DeviceColor
(
1
1
1
1
)
)
;
float
a
=
color
.
a
*
aOptions
.
mAlpha
;
float
colorData
[
4
]
=
{
color
.
r
*
a
color
.
g
*
a
color
.
b
*
a
a
}
;
float
swizzleData
=
aMaskColor
?
1
.
0f
:
0
.
0f
;
Matrix
xform
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
if
(
aTransformed
)
{
xform
*
=
mTransform
;
}
xform
*
=
Matrix
(
2
.
0f
/
float
(
mSize
.
width
)
0
.
0f
0
.
0f
-
2
.
0f
/
float
(
mSize
.
height
)
-
1
1
)
;
float
xformData
[
6
]
=
{
xform
.
_11
xform
.
_12
xform
.
_21
xform
.
_22
xform
.
_31
xform
.
_32
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramTransform
false
{
(
const
uint8_t
*
)
xformData
sizeof
(
xformData
)
}
)
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC4
mImageProgramColor
false
{
(
const
uint8_t
*
)
colorData
sizeof
(
colorData
)
}
)
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT
mImageProgramSwizzle
false
{
(
const
uint8_t
*
)
&
swizzleData
sizeof
(
swizzleData
)
}
)
;
int32_t
samplerData
=
0
;
mWebgl
-
>
UniformData
(
LOCAL_GL_INT
mImageProgramSampler
false
{
(
const
uint8_t
*
)
&
samplerData
sizeof
(
samplerData
)
}
)
;
RefPtr
<
WebGLTextureJS
>
tex
;
IntRect
bounds
;
IntSize
backingSize
;
bool
update
=
aForceUpdate
;
bool
init
=
false
;
if
(
handle
)
{
handle
-
>
remove
(
)
;
mTextureHandles
.
insertFront
(
handle
)
;
if
(
update
)
{
mUsedTextureMemory
-
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
UpdateSize
(
texSize
)
;
mUsedTextureMemory
+
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
SetSamplingOffset
(
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
)
;
}
}
else
{
size_t
usedBytes
=
TextureHandle
:
:
UsedBytes
(
format
texSize
)
;
PruneTextureMemory
(
usedBytes
false
)
;
int32_t
pageSize
=
int32_t
(
std
:
:
min
(
StaticPrefs
:
:
gfx_canvas_accelerated_shared_page_size
(
)
mMaxTextureSize
)
)
;
if
(
!
aForceUpdate
&
&
std
:
:
max
(
texSize
.
width
texSize
.
height
)
<
=
pageSize
/
2
)
{
for
(
auto
&
shared
:
mSharedTextures
)
{
if
(
shared
-
>
GetFormat
(
)
=
=
format
)
{
handle
=
shared
-
>
Allocate
(
texSize
)
;
if
(
handle
)
{
break
;
}
}
}
if
(
!
handle
)
{
tex
=
mWebgl
-
>
CreateTexture
(
)
;
if
(
!
tex
)
{
MOZ_ASSERT
(
false
)
;
break
;
}
RefPtr
<
SharedTexture
>
shared
=
new
SharedTexture
(
IntSize
(
pageSize
pageSize
)
format
tex
)
;
mSharedTextures
.
push_back
(
shared
)
;
mTotalTextureMemory
+
=
shared
-
>
UsedBytes
(
)
;
handle
=
shared
-
>
Allocate
(
texSize
)
;
if
(
!
handle
)
{
MOZ_ASSERT
(
false
)
;
break
;
}
init
=
true
;
}
update
=
true
;
}
else
{
tex
=
mWebgl
-
>
CreateTexture
(
)
;
if
(
!
tex
)
{
MOZ_ASSERT
(
false
)
;
break
;
}
RefPtr
<
StandaloneTexture
>
standalone
=
new
StandaloneTexture
(
texSize
format
tex
)
;
mStandaloneTextures
.
push_back
(
standalone
)
;
mTotalTextureMemory
+
=
standalone
-
>
UsedBytes
(
)
;
handle
=
standalone
;
update
=
true
;
init
=
true
;
}
mTextureHandles
.
insertFront
(
handle
)
;
+
+
mNumTextureHandles
;
mUsedTextureMemory
+
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
SetSamplingOffset
(
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
)
;
if
(
aHandle
)
{
*
aHandle
=
handle
;
}
else
{
handle
-
>
SetSurface
(
surfacePattern
.
mSurface
)
;
surfacePattern
.
mSurface
-
>
AddUserData
(
&
mTextureHandleKey
handle
.
get
(
)
ReleaseTextureHandle
)
;
}
}
if
(
!
tex
)
{
tex
=
handle
-
>
GetWebGLTexture
(
)
;
}
bounds
=
handle
-
>
GetBounds
(
)
;
backingSize
=
handle
-
>
GetBackingSize
(
)
;
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
tex
.
get
(
)
)
;
if
(
init
)
{
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_S
LOCAL_GL_CLAMP_TO_EDGE
)
;
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_T
LOCAL_GL_CLAMP_TO_EDGE
)
;
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MAG_FILTER
LOCAL_GL_LINEAR
)
;
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MIN_FILTER
LOCAL_GL_LINEAR
)
;
if
(
texSize
!
=
backingSize
)
{
GLenum
intFormat
=
format
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_R8
:
LOCAL_GL_RGBA8
;
GLenum
extFormat
=
format
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_RED
:
LOCAL_GL_RGBA
;
webgl
:
:
PackingInfo
texPI
=
{
extFormat
LOCAL_GL_UNSIGNED_BYTE
}
;
webgl
:
:
TexUnpackBlobDesc
texDesc
=
{
LOCAL_GL_TEXTURE_2D
{
uint32_t
(
backingSize
.
width
)
uint32_t
(
backingSize
.
height
)
1
}
}
;
mWebgl
-
>
RawTexImage
(
0
intFormat
{
0
0
0
}
texPI
texDesc
)
;
}
}
if
(
update
)
{
RefPtr
<
DataSourceSurface
>
data
=
surfacePattern
.
mSurface
-
>
GetDataSurface
(
)
;
DataSourceSurface
:
:
ScopedMap
map
(
data
DataSourceSurface
:
:
READ
)
;
int32_t
stride
=
map
.
GetStride
(
)
;
int32_t
bpp
=
BytesPerPixel
(
format
)
;
Range
<
const
uint8_t
>
range
(
map
.
GetData
(
)
+
offset
.
y
*
size_t
(
stride
)
+
offset
.
x
*
bpp
texSize
.
height
*
size_t
(
stride
)
)
;
webgl
:
:
TexUnpackBlobDesc
texDesc
=
{
LOCAL_GL_TEXTURE_2D
{
uint32_t
(
texSize
.
width
)
uint32_t
(
texSize
.
height
)
1
}
gfxAlphaType
:
:
NonPremult
Some
(
RawBuffer
(
range
)
)
}
;
texDesc
.
unpacking
.
mUnpackAlignment
=
stride
%
4
?
1
:
4
;
texDesc
.
unpacking
.
mUnpackRowLength
=
stride
/
bpp
;
texDesc
.
unpacking
.
mUnpackImageHeight
=
texSize
.
height
;
GLenum
intFormat
=
format
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_R8
:
LOCAL_GL_RGBA8
;
GLenum
extFormat
=
format
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_RED
:
LOCAL_GL_RGBA
;
webgl
:
:
PackingInfo
texPI
=
{
extFormat
LOCAL_GL_UNSIGNED_BYTE
}
;
mWebgl
-
>
RawTexImage
(
0
texSize
=
=
backingSize
?
intFormat
:
0
{
uint32_t
(
bounds
.
x
)
uint32_t
(
bounds
.
y
)
0
}
texPI
texDesc
)
;
}
Size
backingSizeF
(
backingSize
)
;
Matrix
uvMatrix
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
uvMatrix
*
=
surfacePattern
.
mMatrix
.
Inverse
(
)
;
uvMatrix
*
=
Matrix
(
1
.
0f
/
backingSizeF
.
width
0
0
1
.
0f
/
backingSizeF
.
height
float
(
bounds
.
x
-
offset
.
x
)
/
backingSizeF
.
width
float
(
bounds
.
y
-
offset
.
y
)
/
backingSizeF
.
height
)
;
float
uvData
[
6
]
=
{
uvMatrix
.
_11
uvMatrix
.
_12
uvMatrix
.
_21
uvMatrix
.
_22
uvMatrix
.
_31
uvMatrix
.
_32
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramTexMatrix
false
{
(
const
uint8_t
*
)
uvData
sizeof
(
uvData
)
}
)
;
float
texBounds
[
4
]
=
{
(
bounds
.
x
+
0
.
5f
)
/
backingSizeF
.
width
(
bounds
.
y
+
0
.
5f
)
/
backingSizeF
.
height
(
bounds
.
XMost
(
)
-
0
.
5f
)
/
backingSizeF
.
width
(
bounds
.
YMost
(
)
-
0
.
5f
)
/
backingSizeF
.
height
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC4
mImageProgramTexBounds
false
{
(
const
uint8_t
*
)
texBounds
sizeof
(
texBounds
)
}
)
;
mWebgl
-
>
DrawArrays
(
aStrokeOptions
?
LOCAL_GL_LINE_LOOP
:
LOCAL_GL_TRIANGLE_FAN
0
4
)
;
break
;
}
default
:
gfxWarning
(
)
<
<
"
Unknown
DrawTargetWebgl
:
:
DrawRect
pattern
type
:
"
<
<
(
int
)
aPattern
.
GetType
(
)
;
break
;
}
if
(
intClip
)
{
mWebgl
-
>
Disable
(
LOCAL_GL_SCISSOR_TEST
)
;
}
return
true
;
}
bool
DrawTargetWebgl
:
:
RemoveSharedTexture
(
const
RefPtr
<
SharedTexture
>
&
aTexture
)
{
auto
pos
=
std
:
:
find
(
mSharedTextures
.
begin
(
)
mSharedTextures
.
end
(
)
aTexture
)
;
if
(
pos
=
=
mSharedTextures
.
end
(
)
)
{
return
false
;
}
mTotalTextureMemory
-
=
aTexture
-
>
UsedBytes
(
)
;
mSharedTextures
.
erase
(
pos
)
;
return
true
;
}
void
SharedTextureHandle
:
:
Cleanup
(
DrawTargetWebgl
&
aDT
)
{
mTexture
-
>
Free
(
*
this
)
;
if
(
!
mTexture
-
>
HasAllocatedHandles
(
)
)
{
aDT
.
RemoveSharedTexture
(
mTexture
)
;
}
}
bool
DrawTargetWebgl
:
:
RemoveStandaloneTexture
(
const
RefPtr
<
StandaloneTexture
>
&
aTexture
)
{
auto
pos
=
std
:
:
find
(
mStandaloneTextures
.
begin
(
)
mStandaloneTextures
.
end
(
)
aTexture
)
;
if
(
pos
=
=
mStandaloneTextures
.
end
(
)
)
{
return
false
;
}
mTotalTextureMemory
-
=
aTexture
-
>
UsedBytes
(
)
;
mStandaloneTextures
.
erase
(
pos
)
;
return
true
;
}
void
StandaloneTexture
:
:
Cleanup
(
DrawTargetWebgl
&
aDT
)
{
aDT
.
RemoveStandaloneTexture
(
this
)
;
}
void
DrawTargetWebgl
:
:
PruneTextureHandle
(
RefPtr
<
TextureHandle
>
aHandle
)
{
aHandle
-
>
Invalidate
(
)
;
UnlinkSurfaceTexture
(
aHandle
)
;
if
(
RefPtr
<
CacheEntry
>
entry
=
aHandle
-
>
GetCacheEntry
(
)
)
{
entry
-
>
Unlink
(
)
;
}
mUsedTextureMemory
-
=
aHandle
-
>
UsedBytes
(
)
;
aHandle
-
>
Cleanup
(
*
this
)
;
}
bool
DrawTargetWebgl
:
:
PruneTextureMemory
(
size_t
aMargin
bool
aPruneUnused
)
{
size_t
maxBytes
=
StaticPrefs
:
:
gfx_canvas_accelerated_cache_size
(
)
<
<
20
;
maxBytes
-
=
std
:
:
min
(
maxBytes
aMargin
)
;
size_t
maxItems
=
StaticPrefs
:
:
gfx_canvas_accelerated_cache_items
(
)
;
size_t
oldItems
=
mNumTextureHandles
;
while
(
!
mTextureHandles
.
isEmpty
(
)
&
&
(
mUsedTextureMemory
>
maxBytes
|
|
mNumTextureHandles
>
maxItems
|
|
(
aPruneUnused
&
&
!
mTextureHandles
.
getLast
(
)
-
>
IsUsed
(
)
)
)
)
{
PruneTextureHandle
(
mTextureHandles
.
popLast
(
)
)
;
-
-
mNumTextureHandles
;
}
return
mNumTextureHandles
<
oldItems
;
}
void
DrawTargetWebgl
:
:
FillRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
SupportsPattern
(
aPattern
)
)
{
DrawRect
(
aRect
aPattern
aOptions
)
;
}
else
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
else
{
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
aRect
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
DrawPath
(
path
aPattern
aOptions
)
;
}
}
void
CacheEntry
:
:
Link
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
mHandle
=
aHandle
;
mHandle
-
>
SetCacheEntry
(
this
)
;
}
void
CacheEntry
:
:
Unlink
(
)
{
RemoveFromList
(
)
;
if
(
mHandle
)
{
mHandle
-
>
SetCacheEntry
(
nullptr
)
;
mHandle
=
nullptr
;
}
}
HashNumber
PathCacheEntry
:
:
HashPath
(
const
SkPath
&
aPath
const
Pattern
*
aPattern
const
Matrix
&
aTransform
const
IntRect
&
aBounds
)
{
HashNumber
hash
=
0
;
hash
=
AddToHash
(
hash
aPath
.
countVerbs
(
)
)
;
hash
=
AddToHash
(
hash
aPath
.
countPoints
(
)
)
;
hash
=
AddToHash
(
hash
aBounds
.
width
)
;
hash
=
AddToHash
(
hash
aBounds
.
height
)
;
if
(
aPattern
)
{
hash
=
AddToHash
(
hash
(
int
)
aPattern
-
>
GetType
(
)
)
;
}
return
hash
;
}
static
inline
bool
HasMatchingScale
(
const
Matrix
&
aTransform1
const
Matrix
&
aTransform2
)
{
return
FuzzyEqual
(
aTransform1
.
_11
aTransform2
.
_11
)
&
&
FuzzyEqual
(
aTransform1
.
_12
aTransform2
.
_12
)
&
&
FuzzyEqual
(
aTransform1
.
_21
aTransform2
.
_21
)
&
&
FuzzyEqual
(
aTransform1
.
_22
aTransform2
.
_22
)
;
}
bool
PathCacheEntry
:
:
MatchesPath
(
const
SkPath
&
aPath
const
Pattern
*
aPattern
const
StrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
HashNumber
aHash
)
{
return
aHash
=
=
mHash
&
&
HasMatchingScale
(
aTransform
mTransform
)
&
&
aBounds
.
Size
(
)
=
=
mBounds
.
Size
(
)
&
&
aPath
=
=
mPath
&
&
(
!
aPattern
?
!
mPattern
:
mPattern
&
&
*
aPattern
=
=
*
mPattern
)
&
&
(
!
aStrokeOptions
?
!
mStrokeOptions
:
mStrokeOptions
&
&
*
aStrokeOptions
=
=
*
mStrokeOptions
)
;
}
PathCacheEntry
:
:
PathCacheEntry
(
const
SkPath
&
aPath
Pattern
*
aPattern
StoredStrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
HashNumber
aHash
)
:
CacheEntryImpl
<
PathCacheEntry
>
(
aTransform
aBounds
aHash
)
mPath
(
aPath
)
mOrigin
(
aOrigin
)
mPattern
(
aPattern
)
mStrokeOptions
(
aStrokeOptions
)
{
}
already_AddRefed
<
PathCacheEntry
>
PathCache
:
:
FindOrInsertEntry
(
const
SkPath
&
aPath
const
Pattern
*
aPattern
const
StrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
)
{
HashNumber
hash
=
PathCacheEntry
:
:
HashPath
(
aPath
aPattern
aTransform
aBounds
)
;
for
(
const
RefPtr
<
PathCacheEntry
>
&
entry
:
mEntries
)
{
if
(
entry
-
>
MatchesPath
(
aPath
aPattern
aStrokeOptions
aTransform
aBounds
hash
)
)
{
return
do_AddRef
(
entry
)
;
}
}
Pattern
*
pattern
=
nullptr
;
if
(
aPattern
)
{
pattern
=
aPattern
-
>
Clone
(
)
;
if
(
!
pattern
)
{
return
nullptr
;
}
}
StoredStrokeOptions
*
strokeOptions
=
nullptr
;
if
(
aStrokeOptions
)
{
strokeOptions
=
aStrokeOptions
-
>
Clone
(
)
;
if
(
!
strokeOptions
)
{
return
nullptr
;
}
}
RefPtr
<
PathCacheEntry
>
entry
=
new
PathCacheEntry
(
aPath
pattern
strokeOptions
aTransform
aBounds
aOrigin
hash
)
;
mEntries
.
insertFront
(
entry
)
;
return
entry
.
forget
(
)
;
}
void
DrawTargetWebgl
:
:
Fill
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
!
aPath
|
|
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
SkPath
&
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
-
>
GetPath
(
)
;
SkRect
rect
;
if
(
skiaPath
.
isRect
(
&
rect
)
&
&
SupportsPattern
(
aPattern
)
)
{
DrawRect
(
SkRectToRect
(
rect
)
aPattern
aOptions
)
;
}
else
{
DrawPath
(
aPath
aPattern
aOptions
)
;
}
}
void
DrawTargetWebgl
:
:
DrawPath
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
)
{
const
PathSkia
*
pathSkia
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
;
Rect
bounds
=
pathSkia
-
>
GetFastBounds
(
mTransform
aStrokeOptions
)
.
Intersect
(
Rect
(
mSkia
-
>
GetRect
(
)
)
)
;
if
(
bounds
.
IsEmpty
(
)
)
{
return
;
}
IntRect
intBounds
=
RoundedOut
(
bounds
)
;
Maybe
<
DeviceColor
>
color
=
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
?
Some
(
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
)
:
Nothing
(
)
;
if
(
!
mPathCache
)
{
mPathCache
=
MakeUnique
<
PathCache
>
(
)
;
}
RefPtr
<
PathCacheEntry
>
entry
=
mPathCache
-
>
FindOrInsertEntry
(
pathSkia
-
>
GetPath
(
)
color
?
nullptr
:
&
aPattern
aStrokeOptions
mTransform
intBounds
bounds
.
TopLeft
(
)
)
;
if
(
entry
)
{
RefPtr
<
TextureHandle
>
handle
=
entry
-
>
GetHandle
(
)
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
)
{
Point
oldOffset
=
entry
-
>
GetOrigin
(
)
-
entry
-
>
GetBounds
(
)
.
TopLeft
(
)
;
Point
newOffset
=
bounds
.
TopLeft
(
)
-
intBounds
.
TopLeft
(
)
;
Rect
offsetRect
=
Rect
(
intBounds
)
+
(
newOffset
-
oldOffset
)
;
SurfacePattern
pathPattern
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
offsetRect
.
TopLeft
(
)
)
)
;
if
(
DrawRect
(
offsetRect
pathPattern
aOptions
color
&
handle
false
true
true
)
)
{
return
;
}
}
else
{
handle
=
nullptr
;
RefPtr
<
DrawTargetSkia
>
pathDT
=
new
DrawTargetSkia
;
if
(
pathDT
-
>
Init
(
intBounds
.
Size
(
)
color
?
SurfaceFormat
:
:
A8
:
SurfaceFormat
:
:
B8G8R8A8
)
)
{
pathDT
-
>
SetTransform
(
mTransform
*
Matrix
:
:
Translation
(
-
intBounds
.
TopLeft
(
)
)
)
;
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aOptions
.
mAntialiasMode
)
;
static
const
ColorPattern
maskPattern
(
DeviceColor
(
1
.
0f
1
.
0f
1
.
0f
1
.
0f
)
)
;
const
Pattern
&
cachePattern
=
color
?
maskPattern
:
aPattern
;
if
(
aStrokeOptions
)
{
pathDT
-
>
Stroke
(
aPath
cachePattern
*
aStrokeOptions
drawOptions
)
;
}
else
{
pathDT
-
>
Fill
(
aPath
cachePattern
drawOptions
)
;
}
RefPtr
<
SourceSurface
>
pathSurface
=
pathDT
-
>
Snapshot
(
)
;
if
(
pathSurface
)
{
SurfacePattern
pathPattern
(
pathSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
)
;
if
(
DrawRect
(
Rect
(
intBounds
)
pathPattern
aOptions
color
&
handle
false
true
)
&
&
handle
)
{
entry
-
>
Link
(
handle
)
;
}
else
{
entry
-
>
Unlink
(
)
;
}
return
;
}
}
}
}
}
MarkSkiaChanged
(
aOptions
)
;
if
(
aStrokeOptions
)
{
mSkia
-
>
Stroke
(
aPath
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
Fill
(
aPath
aPattern
aOptions
)
;
}
}
void
DrawTargetWebgl
:
:
DrawSurface
(
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSource
const
DrawSurfaceOptions
&
aSurfOptions
const
DrawOptions
&
aOptions
)
{
Matrix
matrix
=
Matrix
:
:
Scaling
(
aDest
.
width
/
aSource
.
width
aDest
.
height
/
aSource
.
height
)
;
matrix
.
PreTranslate
(
-
aSource
.
x
-
aSource
.
y
)
;
matrix
.
PostTranslate
(
aDest
.
x
aDest
.
y
)
;
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
matrix
)
;
DrawRect
(
aDest
pattern
aOptions
)
;
}
void
DrawTargetWebgl
:
:
Mask
(
const
Pattern
&
aSource
const
Pattern
&
aMask
const
DrawOptions
&
aOptions
)
{
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
aMask
.
GetType
(
)
!
=
PatternType
:
:
SURFACE
|
|
aSource
.
GetType
(
)
!
=
PatternType
:
:
COLOR
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
Mask
(
aSource
aMask
aOptions
)
;
return
;
}
auto
sourceColor
=
static_cast
<
const
ColorPattern
&
>
(
aSource
)
.
mColor
;
auto
maskPattern
=
static_cast
<
const
SurfacePattern
&
>
(
aMask
)
;
DrawRect
(
Rect
(
IntRect
(
IntPoint
(
)
maskPattern
.
mSurface
-
>
GetSize
(
)
)
)
maskPattern
aOptions
Some
(
sourceColor
)
)
;
}
void
DrawTargetWebgl
:
:
MaskSurface
(
const
Pattern
&
aSource
SourceSurface
*
aMask
Point
aOffset
const
DrawOptions
&
aOptions
)
{
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
aSource
.
GetType
(
)
!
=
PatternType
:
:
COLOR
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
MaskSurface
(
aSource
aMask
aOffset
aOptions
)
;
}
else
{
auto
sourceColor
=
static_cast
<
const
ColorPattern
&
>
(
aSource
)
.
mColor
;
SurfacePattern
pattern
(
aMask
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
aOffset
)
)
;
DrawRect
(
Rect
(
aOffset
Size
(
aMask
-
>
GetSize
(
)
)
)
pattern
aOptions
Some
(
sourceColor
)
)
;
}
}
static
already_AddRefed
<
DataSourceSurface
>
ExtractAlpha
(
SourceSurface
*
aSurface
)
{
RefPtr
<
DataSourceSurface
>
surfaceData
=
aSurface
-
>
GetDataSurface
(
)
;
if
(
!
surfaceData
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
srcMap
(
surfaceData
DataSourceSurface
:
:
READ
)
;
if
(
!
srcMap
.
IsMapped
(
)
)
{
return
nullptr
;
}
IntSize
size
=
surfaceData
-
>
GetSize
(
)
;
RefPtr
<
DataSourceSurface
>
alpha
=
Factory
:
:
CreateDataSourceSurface
(
size
SurfaceFormat
:
:
A8
false
)
;
if
(
!
alpha
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
dstMap
(
alpha
DataSourceSurface
:
:
WRITE
)
;
if
(
!
dstMap
.
IsMapped
(
)
)
{
return
nullptr
;
}
SwizzleData
(
srcMap
.
GetData
(
)
srcMap
.
GetStride
(
)
surfaceData
-
>
GetFormat
(
)
dstMap
.
GetData
(
)
dstMap
.
GetStride
(
)
SurfaceFormat
:
:
A8
size
)
;
return
alpha
.
forget
(
)
;
}
void
DrawTargetWebgl
:
:
DrawSurfaceWithShadow
(
SourceSurface
*
aSurface
const
Point
&
aDest
const
DeviceColor
&
aColor
const
Point
&
aOffset
Float
aSigma
CompositionOp
aOperator
)
{
IntSize
size
=
aSurface
-
>
GetSize
(
)
;
RefPtr
<
TextureHandle
>
handle
=
static_cast
<
TextureHandle
*
>
(
aSurface
-
>
GetUserData
(
&
mShadowTextureKey
)
)
;
if
(
!
handle
|
|
!
handle
-
>
IsValid
(
)
|
|
handle
-
>
GetSigma
(
)
!
=
aSigma
)
{
RefPtr
<
DataSourceSurface
>
alpha
;
if
(
RefPtr
<
DataSourceSurface
>
alphaData
=
ExtractAlpha
(
aSurface
)
)
{
DataSourceSurface
:
:
ScopedMap
dstMap
(
alphaData
DataSourceSurface
:
:
READ_WRITE
)
;
if
(
dstMap
.
IsMapped
(
)
)
{
AlphaBoxBlur
blur
(
Rect
(
0
0
size
.
width
size
.
height
)
dstMap
.
GetStride
(
)
aSigma
aSigma
)
;
blur
.
Blur
(
dstMap
.
GetData
(
)
)
;
alpha
=
alphaData
;
}
}
if
(
alpha
)
{
IntPoint
shadowOffset
=
IntPoint
:
:
Round
(
aDest
+
aOffset
)
;
SurfacePattern
shadowMask
(
alpha
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
Point
(
shadowOffset
)
)
)
;
handle
=
nullptr
;
if
(
DrawRect
(
Rect
(
IntRect
(
shadowOffset
size
)
)
shadowMask
DrawOptions
(
1
.
0f
aOperator
)
Some
(
aColor
)
&
handle
false
true
)
&
&
handle
)
{
handle
-
>
SetSurface
(
aSurface
)
;
handle
-
>
SetSigma
(
aSigma
)
;
aSurface
-
>
AddUserData
(
&
mShadowTextureKey
handle
.
get
(
)
ReleaseTextureHandle
)
;
}
IntPoint
surfaceOffset
=
IntPoint
:
:
Round
(
aDest
)
;
SurfacePattern
surfacePattern
(
aSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
Point
(
surfaceOffset
)
)
)
;
DrawRect
(
Rect
(
IntRect
(
surfaceOffset
size
)
)
surfacePattern
DrawOptions
(
1
.
0f
aOperator
)
Nothing
(
)
nullptr
false
true
)
;
return
;
}
}
else
{
IntPoint
shadowOffset
=
IntPoint
:
:
Round
(
aDest
+
aOffset
)
;
SurfacePattern
shadowMask
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
Point
(
shadowOffset
)
)
)
;
if
(
DrawRect
(
Rect
(
IntRect
(
shadowOffset
size
)
)
shadowMask
DrawOptions
(
1
.
0f
aOperator
)
Some
(
aColor
)
&
handle
false
true
true
)
)
{
IntPoint
surfaceOffset
=
IntPoint
:
:
Round
(
aDest
)
;
SurfacePattern
surfacePattern
(
aSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
Point
(
surfaceOffset
)
)
)
;
DrawRect
(
Rect
(
IntRect
(
surfaceOffset
size
)
)
surfacePattern
DrawOptions
(
1
.
0f
aOperator
)
Nothing
(
)
nullptr
false
true
)
;
return
;
}
}
MarkSkiaChanged
(
)
;
mSkia
-
>
DrawSurfaceWithShadow
(
aSurface
aDest
aColor
aOffset
aSigma
aOperator
)
;
}
already_AddRefed
<
PathBuilder
>
DrawTargetWebgl
:
:
CreatePathBuilder
(
FillRule
aFillRule
)
const
{
return
mSkia
-
>
CreatePathBuilder
(
aFillRule
)
;
}
void
DrawTargetWebgl
:
:
SetTransform
(
const
Matrix
&
aTransform
)
{
DrawTarget
:
:
SetTransform
(
aTransform
)
;
mSkia
-
>
SetTransform
(
aTransform
)
;
}
void
DrawTargetWebgl
:
:
StrokeRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
aStrokeOptions
=
=
StrokeOptions
(
)
&
&
mTransform
.
PreservesDistance
(
)
)
{
DrawRect
(
aRect
aPattern
aOptions
Nothing
(
)
nullptr
true
true
false
false
&
aStrokeOptions
)
;
}
else
if
(
!
mWebglValid
|
|
!
SupportsPattern
(
aPattern
)
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
StrokeRect
(
aRect
aPattern
aStrokeOptions
aOptions
)
;
}
else
{
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
aRect
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
DrawPath
(
path
aPattern
aOptions
&
aStrokeOptions
)
;
}
}
void
DrawTargetWebgl
:
:
StrokeLine
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
StrokeLine
(
aStart
aEnd
aPattern
aStrokeOptions
aOptions
)
;
}
void
DrawTargetWebgl
:
:
Stroke
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
!
aPath
|
|
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
auto
&
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
-
>
GetPath
(
)
;
SkRect
rect
;
SkPoint
line
[
2
]
;
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
Stroke
(
aPath
aPattern
aStrokeOptions
aOptions
)
;
}
else
if
(
skiaPath
.
isRect
(
&
rect
)
)
{
StrokeRect
(
SkRectToRect
(
rect
)
aPattern
aStrokeOptions
aOptions
)
;
}
else
if
(
skiaPath
.
isLine
(
line
)
)
{
StrokeLine
(
SkPointToPoint
(
line
[
0
]
)
SkPointToPoint
(
line
[
1
]
)
aPattern
aStrokeOptions
aOptions
)
;
}
else
{
DrawPath
(
aPath
aPattern
aOptions
&
aStrokeOptions
)
;
}
}
void
DrawTargetWebgl
:
:
StrokeGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
StrokeGlyphs
(
aFont
aBuffer
aPattern
aStrokeOptions
aOptions
)
;
}
static
inline
IntPoint
QuantizePosition
(
const
Matrix
&
aTransform
const
IntPoint
&
aOffset
const
Point
&
aPosition
)
{
IntPoint
pos
=
RoundedToInt
(
aTransform
.
TransformPoint
(
aPosition
)
*
4
.
0f
)
-
aOffset
*
4
;
return
IntPoint
(
pos
.
x
&
3
pos
.
y
&
3
)
;
}
HashNumber
GlyphCacheEntry
:
:
HashGlyphs
(
const
GlyphBuffer
&
aBuffer
const
Matrix
&
aTransform
)
{
HashNumber
hash
=
0
;
IntPoint
offset
=
TruncatedToInt
(
aTransform
.
TransformPoint
(
aBuffer
.
mGlyphs
[
0
]
.
mPosition
)
)
;
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
const
Glyph
&
glyph
=
aBuffer
.
mGlyphs
[
i
]
;
hash
=
AddToHash
(
hash
glyph
.
mIndex
)
;
IntPoint
pos
=
QuantizePosition
(
aTransform
offset
glyph
.
mPosition
)
;
hash
=
AddToHash
(
hash
pos
.
x
)
;
hash
=
AddToHash
(
hash
pos
.
y
)
;
}
return
hash
;
}
bool
GlyphCacheEntry
:
:
MatchesGlyphs
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntRect
&
aBounds
HashNumber
aHash
)
{
if
(
aHash
!
=
mHash
|
|
aBuffer
.
mNumGlyphs
!
=
mBuffer
.
mNumGlyphs
|
|
aColor
!
=
mColor
|
|
!
HasMatchingScale
(
aTransform
mTransform
)
|
|
aBounds
.
Size
(
)
!
=
mBounds
.
Size
(
)
)
{
return
false
;
}
IntPoint
offset
=
TruncatedToInt
(
aTransform
.
TransformPoint
(
aBuffer
.
mGlyphs
[
0
]
.
mPosition
)
)
;
if
(
aBounds
.
TopLeft
(
)
-
offset
!
=
mBounds
.
TopLeft
(
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
const
Glyph
&
dst
=
mBuffer
.
mGlyphs
[
i
]
;
const
Glyph
&
src
=
aBuffer
.
mGlyphs
[
i
]
;
if
(
dst
.
mIndex
!
=
src
.
mIndex
|
|
dst
.
mPosition
!
=
Point
(
QuantizePosition
(
aTransform
offset
src
.
mPosition
)
)
)
{
return
false
;
}
}
return
true
;
}
GlyphCacheEntry
:
:
GlyphCacheEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntRect
&
aBounds
HashNumber
aHash
)
:
CacheEntryImpl
<
GlyphCacheEntry
>
(
aTransform
aBounds
aHash
)
mColor
(
aColor
)
{
Glyph
*
glyphs
=
new
Glyph
[
aBuffer
.
mNumGlyphs
]
;
IntPoint
offset
=
TruncatedToInt
(
aTransform
.
TransformPoint
(
aBuffer
.
mGlyphs
[
0
]
.
mPosition
)
)
;
mBounds
-
=
offset
;
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
Glyph
&
dst
=
glyphs
[
i
]
;
const
Glyph
&
src
=
aBuffer
.
mGlyphs
[
i
]
;
dst
.
mIndex
=
src
.
mIndex
;
dst
.
mPosition
=
Point
(
QuantizePosition
(
aTransform
offset
src
.
mPosition
)
)
;
}
mBuffer
.
mGlyphs
=
glyphs
;
mBuffer
.
mNumGlyphs
=
aBuffer
.
mNumGlyphs
;
}
already_AddRefed
<
GlyphCacheEntry
>
GlyphCache
:
:
FindOrInsertEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntRect
&
aBounds
)
{
HashNumber
hash
=
GlyphCacheEntry
:
:
HashGlyphs
(
aBuffer
aTransform
)
;
for
(
const
RefPtr
<
GlyphCacheEntry
>
&
entry
:
mEntries
)
{
if
(
entry
-
>
MatchesGlyphs
(
aBuffer
aColor
aTransform
aBounds
hash
)
)
{
return
do_AddRef
(
entry
)
;
}
}
RefPtr
<
GlyphCacheEntry
>
entry
=
new
GlyphCacheEntry
(
aBuffer
aColor
aTransform
aBounds
hash
)
;
mEntries
.
insertFront
(
entry
)
;
return
entry
.
forget
(
)
;
}
GlyphCache
:
:
GlyphCache
(
ScaledFont
*
aFont
)
:
mFont
(
aFont
)
{
}
static
void
ReleaseGlyphCache
(
void
*
aPtr
)
{
delete
static_cast
<
GlyphCache
*
>
(
aPtr
)
;
}
void
DrawTargetWebgl
:
:
SetPermitSubpixelAA
(
bool
aPermitSubpixelAA
)
{
DrawTarget
:
:
SetPermitSubpixelAA
(
aPermitSubpixelAA
)
;
mSkia
-
>
SetPermitSubpixelAA
(
aPermitSubpixelAA
)
;
}
static
bool
CheckForColorGlyphs
(
const
RefPtr
<
SourceSurface
>
&
aSurface
)
{
if
(
aSurface
-
>
GetFormat
(
)
!
=
SurfaceFormat
:
:
B8G8R8A8
)
{
return
false
;
}
RefPtr
<
DataSourceSurface
>
dataSurf
=
aSurface
-
>
GetDataSurface
(
)
;
if
(
!
dataSurf
)
{
return
true
;
}
DataSourceSurface
:
:
ScopedMap
map
(
dataSurf
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
true
;
}
IntSize
size
=
dataSurf
-
>
GetSize
(
)
;
const
uint8_t
*
data
=
map
.
GetData
(
)
;
int32_t
stride
=
map
.
GetStride
(
)
;
for
(
int
y
=
0
;
y
<
size
.
height
;
y
+
+
)
{
const
uint32_t
*
x
=
(
const
uint32_t
*
)
data
;
const
uint32_t
*
end
=
x
+
size
.
width
;
for
(
;
x
<
end
;
x
+
+
)
{
uint32_t
color
=
*
x
;
uint32_t
gray
=
color
&
0xFF
;
gray
|
=
gray
<
<
8
;
gray
|
=
gray
<
<
16
;
if
(
color
!
=
gray
)
return
true
;
}
data
+
=
stride
;
}
return
false
;
}
void
DrawTargetWebgl
:
:
FillGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
!
aFont
|
|
!
aBuffer
.
mNumGlyphs
)
{
return
;
}
if
(
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
&
&
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
)
{
Maybe
<
Rect
>
bounds
=
mSkia
-
>
GetGlyphLocalBounds
(
aFont
aBuffer
aPattern
nullptr
aOptions
)
;
if
(
bounds
)
{
Rect
xformBounds
=
mTransform
.
TransformBounds
(
*
bounds
)
.
Intersect
(
Rect
(
mSkia
-
>
GetRect
(
)
)
)
;
if
(
xformBounds
.
IsEmpty
(
)
)
{
return
;
}
IntRect
intBounds
=
RoundedOut
(
xformBounds
)
;
AntialiasMode
aaMode
=
aFont
-
>
GetDefaultAAMode
(
)
;
if
(
aOptions
.
mAntialiasMode
!
=
AntialiasMode
:
:
DEFAULT
)
{
aaMode
=
aOptions
.
mAntialiasMode
;
}
bool
useSubpixelAA
=
GetPermitSubpixelAA
(
)
&
&
(
aaMode
=
=
AntialiasMode
:
:
DEFAULT
|
|
aaMode
=
=
AntialiasMode
:
:
SUBPIXEL
)
;
bool
useColor
=
useSubpixelAA
;
GlyphCache
*
cache
=
static_cast
<
GlyphCache
*
>
(
aFont
-
>
GetUserData
(
&
mGlyphCacheKey
)
)
;
if
(
!
cache
)
{
cache
=
new
GlyphCache
(
aFont
)
;
aFont
-
>
AddUserData
(
&
mGlyphCacheKey
cache
ReleaseGlyphCache
)
;
mGlyphCaches
.
insertFront
(
cache
)
;
}
DeviceColor
color
=
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
;
DeviceColor
aaColor
=
useColor
?
color
:
DeviceColor
(
1
.
0f
1
.
0f
1
.
0f
1
.
0f
)
;
RefPtr
<
GlyphCacheEntry
>
entry
=
cache
-
>
FindOrInsertEntry
(
aBuffer
aaColor
mTransform
intBounds
)
;
if
(
entry
)
{
RefPtr
<
TextureHandle
>
handle
=
entry
-
>
GetHandle
(
)
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
)
{
SurfacePattern
pattern
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
)
;
if
(
DrawRect
(
Rect
(
intBounds
)
pattern
aOptions
handle
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
A8
?
Some
(
color
)
:
Nothing
(
)
&
handle
false
true
true
)
)
{
return
;
}
}
else
{
handle
=
nullptr
;
RefPtr
<
DrawTargetSkia
>
textDT
=
new
DrawTargetSkia
;
if
(
textDT
-
>
Init
(
intBounds
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
)
{
textDT
-
>
SetTransform
(
mTransform
*
Matrix
:
:
Translation
(
-
intBounds
.
TopLeft
(
)
)
)
;
textDT
-
>
SetPermitSubpixelAA
(
useSubpixelAA
)
;
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aOptions
.
mAntialiasMode
)
;
textDT
-
>
FillGlyphs
(
aFont
aBuffer
ColorPattern
(
aaColor
)
drawOptions
)
;
RefPtr
<
SourceSurface
>
textSurface
=
textDT
-
>
Snapshot
(
)
;
if
(
textSurface
)
{
if
(
!
useColor
)
{
if
(
CheckForColorGlyphs
(
textSurface
)
)
{
useColor
=
true
;
}
else
{
textSurface
=
ExtractAlpha
(
textSurface
)
;
if
(
!
textSurface
)
{
return
;
}
}
}
SurfacePattern
pattern
(
textSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
)
;
if
(
DrawRect
(
Rect
(
intBounds
)
pattern
aOptions
useColor
?
Nothing
(
)
:
Some
(
color
)
&
handle
false
true
)
&
&
handle
)
{
entry
-
>
Link
(
handle
)
;
}
else
{
entry
-
>
Unlink
(
)
;
}
return
;
}
}
}
}
}
}
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
FillGlyphs
(
aFont
aBuffer
aPattern
aOptions
)
;
}
void
DrawTargetWebgl
:
:
MarkSkiaChanged
(
const
DrawOptions
&
aOptions
)
{
if
(
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_OVER
)
{
if
(
!
mSkiaValid
)
{
mSkia
-
>
Clear
(
)
;
mSkiaValid
=
true
;
mSkiaLayer
=
true
;
}
mWebglValid
=
false
;
}
else
{
MarkSkiaChanged
(
)
;
}
}
void
DrawTargetWebgl
:
:
ReadIntoSkia
(
)
{
if
(
mSkiaValid
)
{
return
;
}
if
(
mWebglValid
&
&
!
mWebgl
-
>
IsContextLost
(
)
)
{
uint8_t
*
data
=
nullptr
;
IntSize
size
;
int32_t
stride
;
SurfaceFormat
format
;
if
(
!
mSnapshot
&
&
mSkia
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
)
{
(
void
)
ReadInto
(
data
stride
)
;
mSkia
-
>
ReleaseBits
(
data
)
;
}
else
if
(
RefPtr
<
SourceSurface
>
snapshot
=
Snapshot
(
)
)
{
mSkia
-
>
CopySurface
(
snapshot
GetRect
(
)
IntPoint
(
0
0
)
)
;
}
}
mSkiaValid
=
true
;
mSkiaLayer
=
false
;
}
void
DrawTargetWebgl
:
:
FlattenSkia
(
)
{
if
(
!
mSkiaValid
|
|
!
mSkiaLayer
)
{
return
;
}
if
(
!
mWebgl
-
>
IsContextLost
(
)
)
{
RefPtr
<
DataSourceSurface
>
base
=
Factory
:
:
CreateDataSourceSurface
(
mSize
mFormat
)
;
if
(
base
)
{
DataSourceSurface
:
:
ScopedMap
baseMap
(
base
DataSourceSurface
:
:
WRITE
)
;
if
(
baseMap
.
IsMapped
(
)
&
&
ReadInto
(
baseMap
.
GetData
(
)
baseMap
.
GetStride
(
)
)
)
{
mSkia
-
>
BlendSurface
(
base
GetRect
(
)
IntPoint
(
)
CompositionOp
:
:
OP_DEST_OVER
)
;
}
}
}
mSkiaLayer
=
false
;
}
bool
DrawTargetWebgl
:
:
FlushFromSkia
(
)
{
if
(
mWebgl
-
>
IsContextLost
(
)
)
{
mWebglValid
=
false
;
return
false
;
}
if
(
mWebglValid
)
{
return
true
;
}
mWebglValid
=
true
;
if
(
mSkiaValid
)
{
RefPtr
<
SourceSurface
>
skiaSnapshot
=
mSkia
-
>
Snapshot
(
)
;
if
(
skiaSnapshot
)
{
SurfacePattern
pattern
(
skiaSnapshot
ExtendMode
:
:
CLAMP
)
;
DrawRect
(
Rect
(
GetRect
(
)
)
pattern
DrawOptions
(
1
.
0f
mSkiaLayer
?
CompositionOp
:
:
OP_OVER
:
CompositionOp
:
:
OP_SOURCE
)
Nothing
(
)
&
mSnapshotTexture
false
false
false
true
)
;
}
}
return
true
;
}
void
DrawTargetWebgl
:
:
Flush
(
)
{
if
(
!
mWebglValid
)
{
FlushFromSkia
(
)
;
}
mWebgl
-
>
OnBeforePaintTransaction
(
)
;
PruneTextureMemory
(
)
;
}
already_AddRefed
<
DrawTarget
>
DrawTargetWebgl
:
:
CreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
bool
DrawTargetWebgl
:
:
CanCreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CanCreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
RefPtr
<
DrawTarget
>
DrawTargetWebgl
:
:
CreateClippedDrawTarget
(
const
Rect
&
aBounds
SurfaceFormat
aFormat
)
{
return
mSkia
-
>
CreateClippedDrawTarget
(
aBounds
aFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
CreateSourceSurfaceFromData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CreateSourceSurfaceFromData
(
aData
aSize
aStride
aFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
CreateSourceSurfaceFromNativeSurface
(
const
NativeSurface
&
aSurface
)
const
{
return
mSkia
-
>
CreateSourceSurfaceFromNativeSurface
(
aSurface
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
OptimizeSourceSurface
(
SourceSurface
*
aSurface
)
const
{
return
mSkia
-
>
OptimizeSourceSurface
(
aSurface
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
OptimizeSourceSurfaceForUnknownAlpha
(
SourceSurface
*
aSurface
)
const
{
return
mSkia
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
aSurface
)
;
}
already_AddRefed
<
GradientStops
>
DrawTargetWebgl
:
:
CreateGradientStops
(
GradientStop
*
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
)
const
{
return
mSkia
-
>
CreateGradientStops
(
aStops
aNumStops
aExtendMode
)
;
}
already_AddRefed
<
FilterNode
>
DrawTargetWebgl
:
:
CreateFilter
(
FilterType
aType
)
{
return
mSkia
-
>
CreateFilter
(
aType
)
;
}
void
DrawTargetWebgl
:
:
DrawFilter
(
FilterNode
*
aNode
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
const
DrawOptions
&
aOptions
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
DrawFilter
(
aNode
aSourceRect
aDestPoint
aOptions
)
;
}
bool
DrawTargetWebgl
:
:
Draw3DTransformedSurface
(
SourceSurface
*
aSurface
const
Matrix4x4
&
aMatrix
)
{
MarkSkiaChanged
(
)
;
return
mSkia
-
>
Draw3DTransformedSurface
(
aSurface
aMatrix
)
;
}
}
