#
include
"
DrawTargetWebglInternal
.
h
"
#
include
"
SourceSurfaceWebgl
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
gfx
/
AAStroke
.
h
"
#
include
"
mozilla
/
gfx
/
Blur
.
h
"
#
include
"
mozilla
/
gfx
/
DrawTargetSkia
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
HelpersSkia
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
PathSkia
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
RemoteTextureMap
.
h
"
#
include
"
mozilla
/
widget
/
ScreenManager
.
h
"
#
include
"
skia
/
include
/
core
/
SkPixmap
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
WebGLContext
.
h
"
#
include
"
WebGLChild
.
h
"
#
include
"
WebGLBuffer
.
h
"
#
include
"
WebGLFramebuffer
.
h
"
#
include
"
WebGLProgram
.
h
"
#
include
"
WebGLShader
.
h
"
#
include
"
WebGLTexture
.
h
"
#
include
"
WebGLVertexArray
.
h
"
#
include
"
gfxPlatform
.
h
"
#
ifdef
XP_MACOSX
#
include
"
mozilla
/
gfx
/
ScaledFontMac
.
h
"
#
endif
namespace
mozilla
:
:
gfx
{
BackingTexture
:
:
BackingTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTexture
>
&
aTexture
)
:
mSize
(
aSize
)
mFormat
(
aFormat
)
mTexture
(
aTexture
)
{
}
SharedTexture
:
:
SharedTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTexture
>
&
aTexture
)
:
BackingTexture
(
aSize
aFormat
aTexture
)
mAtlasAllocator
(
Etagere
:
:
etagere_atlas_allocator_new
(
aSize
.
width
aSize
.
height
)
)
{
}
SharedTexture
:
:
~
SharedTexture
(
)
{
if
(
mAtlasAllocator
)
{
Etagere
:
:
etagere_atlas_allocator_delete
(
mAtlasAllocator
)
;
mAtlasAllocator
=
nullptr
;
}
}
SharedTextureHandle
:
:
SharedTextureHandle
(
Etagere
:
:
AllocationId
aId
const
IntRect
&
aBounds
SharedTexture
*
aTexture
)
:
mAllocationId
(
aId
)
mBounds
(
aBounds
)
mTexture
(
aTexture
)
{
}
already_AddRefed
<
SharedTextureHandle
>
SharedTexture
:
:
Allocate
(
const
IntSize
&
aSize
)
{
Etagere
:
:
Allocation
alloc
=
{
{
0
0
0
0
}
Etagere
:
:
INVALID_ALLOCATION_ID
}
;
if
(
!
mAtlasAllocator
|
|
!
Etagere
:
:
etagere_atlas_allocator_allocate
(
mAtlasAllocator
aSize
.
width
aSize
.
height
&
alloc
)
|
|
alloc
.
id
=
=
Etagere
:
:
INVALID_ALLOCATION_ID
)
{
return
nullptr
;
}
RefPtr
<
SharedTextureHandle
>
handle
=
new
SharedTextureHandle
(
alloc
.
id
IntRect
(
IntPoint
(
alloc
.
rectangle
.
min_x
alloc
.
rectangle
.
min_y
)
aSize
)
this
)
;
return
handle
.
forget
(
)
;
}
bool
SharedTexture
:
:
Free
(
SharedTextureHandle
&
aHandle
)
{
if
(
aHandle
.
mTexture
!
=
this
)
{
return
false
;
}
if
(
aHandle
.
mAllocationId
!
=
Etagere
:
:
INVALID_ALLOCATION_ID
)
{
if
(
mAtlasAllocator
)
{
Etagere
:
:
etagere_atlas_allocator_deallocate
(
mAtlasAllocator
aHandle
.
mAllocationId
)
;
}
aHandle
.
mAllocationId
=
Etagere
:
:
INVALID_ALLOCATION_ID
;
}
return
true
;
}
StandaloneTexture
:
:
StandaloneTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTexture
>
&
aTexture
)
:
BackingTexture
(
aSize
aFormat
aTexture
)
{
}
DrawTargetWebgl
:
:
DrawTargetWebgl
(
)
=
default
;
inline
void
SharedContextWebgl
:
:
ClearLastTexture
(
bool
aFullClear
)
{
mLastTexture
=
nullptr
;
if
(
aFullClear
)
{
mLastClipMask
=
nullptr
;
}
}
void
DrawTargetWebgl
:
:
ClearSnapshot
(
bool
aCopyOnWrite
bool
aNeedHandle
)
{
if
(
!
mSnapshot
)
{
return
;
}
mSharedContext
-
>
ClearLastTexture
(
)
;
RefPtr
<
SourceSurfaceWebgl
>
snapshot
=
mSnapshot
.
forget
(
)
;
if
(
snapshot
-
>
hasOneRef
(
)
)
{
return
;
}
if
(
aCopyOnWrite
)
{
snapshot
-
>
DrawTargetWillChange
(
aNeedHandle
)
;
}
else
{
snapshot
-
>
GiveTexture
(
mSharedContext
-
>
WrapSnapshot
(
GetSize
(
)
GetFormat
(
)
mTex
.
forget
(
)
)
)
;
}
}
DrawTargetWebgl
:
:
~
DrawTargetWebgl
(
)
{
ClearSnapshot
(
false
)
;
if
(
mSharedContext
)
{
if
(
mSkia
)
{
mSkia
-
>
DetachAllSnapshots
(
)
;
}
mSharedContext
-
>
ClearLastTexture
(
true
)
;
mClipMask
=
nullptr
;
mFramebuffer
=
nullptr
;
mTex
=
nullptr
;
mSharedContext
-
>
mDrawTargetCount
-
-
;
}
}
SharedContextWebgl
:
:
SharedContextWebgl
(
)
=
default
;
SharedContextWebgl
:
:
~
SharedContextWebgl
(
)
{
if
(
mWebgl
)
{
ExitTlsScope
(
)
;
mWebgl
-
>
ActiveTexture
(
0
)
;
}
if
(
mWGRPathBuilder
)
{
WGR
:
:
wgr_builder_release
(
mWGRPathBuilder
)
;
mWGRPathBuilder
=
nullptr
;
}
ClearAllTextures
(
)
;
UnlinkSurfaceTextures
(
)
;
UnlinkGlyphCaches
(
)
;
}
gl
:
:
GLContext
*
SharedContextWebgl
:
:
GetGLContext
(
)
{
return
mWebgl
?
mWebgl
-
>
GL
(
)
:
nullptr
;
}
void
SharedContextWebgl
:
:
EnterTlsScope
(
)
{
if
(
mTlsScope
.
isSome
(
)
)
{
return
;
}
if
(
gl
:
:
GLContext
*
gl
=
GetGLContext
(
)
)
{
mTlsScope
=
Some
(
gl
-
>
mUseTLSIsCurrent
)
;
gl
:
:
GLContext
:
:
InvalidateCurrentContext
(
)
;
gl
-
>
mUseTLSIsCurrent
=
true
;
}
}
void
SharedContextWebgl
:
:
ExitTlsScope
(
)
{
if
(
mTlsScope
.
isNothing
(
)
)
{
return
;
}
if
(
gl
:
:
GLContext
*
gl
=
GetGLContext
(
)
)
{
gl
-
>
mUseTLSIsCurrent
=
mTlsScope
.
value
(
)
;
}
mTlsScope
=
Nothing
(
)
;
}
inline
void
SharedContextWebgl
:
:
UnlinkSurfaceTexture
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
if
(
RefPtr
<
SourceSurface
>
surface
=
aHandle
-
>
GetSurface
(
)
)
{
if
(
surface
-
>
GetType
(
)
=
=
SurfaceType
:
:
WEBGL
)
{
static_cast
<
SourceSurfaceWebgl
*
>
(
surface
.
get
(
)
)
-
>
OnUnlinkTexture
(
this
)
;
}
surface
-
>
RemoveUserData
(
aHandle
-
>
IsShadow
(
)
?
&
mShadowTextureKey
:
&
mTextureHandleKey
)
;
}
}
void
SharedContextWebgl
:
:
UnlinkSurfaceTextures
(
)
{
for
(
RefPtr
<
TextureHandle
>
handle
=
mTextureHandles
.
getFirst
(
)
;
handle
;
handle
=
handle
-
>
getNext
(
)
)
{
UnlinkSurfaceTexture
(
handle
)
;
}
}
void
SharedContextWebgl
:
:
UnlinkGlyphCaches
(
)
{
GlyphCache
*
cache
=
mGlyphCaches
.
getFirst
(
)
;
while
(
cache
)
{
ScaledFont
*
font
=
cache
-
>
GetFont
(
)
;
cache
=
cache
-
>
getNext
(
)
;
font
-
>
RemoveUserData
(
&
mGlyphCacheKey
)
;
}
}
void
SharedContextWebgl
:
:
OnMemoryPressure
(
)
{
mShouldClearCaches
=
true
;
}
void
SharedContextWebgl
:
:
ClearCaches
(
)
{
OnMemoryPressure
(
)
;
ClearCachesIfNecessary
(
)
;
}
void
SharedContextWebgl
:
:
ClearAllTextures
(
)
{
while
(
!
mTextureHandles
.
isEmpty
(
)
)
{
PruneTextureHandle
(
mTextureHandles
.
popLast
(
)
)
;
-
-
mNumTextureHandles
;
}
}
void
SharedContextWebgl
:
:
ClearEmptyTextureMemory
(
)
{
for
(
auto
pos
=
mSharedTextures
.
begin
(
)
;
pos
!
=
mSharedTextures
.
end
(
)
;
)
{
if
(
!
(
*
pos
)
-
>
HasAllocatedHandles
(
)
)
{
RefPtr
<
SharedTexture
>
shared
=
*
pos
;
size_t
usedBytes
=
shared
-
>
UsedBytes
(
)
;
mEmptyTextureMemory
-
=
usedBytes
;
mTotalTextureMemory
-
=
usedBytes
;
pos
=
mSharedTextures
.
erase
(
pos
)
;
}
else
{
+
+
pos
;
}
}
}
void
SharedContextWebgl
:
:
ClearCachesIfNecessary
(
)
{
if
(
!
mShouldClearCaches
.
exchange
(
false
)
)
{
return
;
}
mZeroBuffer
=
nullptr
;
ClearAllTextures
(
)
;
if
(
mEmptyTextureMemory
)
{
ClearEmptyTextureMemory
(
)
;
}
ClearLastTexture
(
)
;
}
bool
DrawTargetWebgl
:
:
Init
(
const
IntSize
&
size
const
SurfaceFormat
format
const
RefPtr
<
SharedContextWebgl
>
&
aSharedContext
)
{
MOZ_ASSERT
(
format
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
format
=
=
SurfaceFormat
:
:
B8G8R8X8
)
;
mSize
=
size
;
mFormat
=
format
;
if
(
!
aSharedContext
|
|
aSharedContext
-
>
IsContextLost
(
)
|
|
aSharedContext
-
>
mDrawTargetCount
>
=
StaticPrefs
:
:
gfx_canvas_accelerated_max_draw_target_count
(
)
)
{
return
false
;
}
mSharedContext
=
aSharedContext
;
mSharedContext
-
>
mDrawTargetCount
+
+
;
if
(
size_t
(
std
:
:
max
(
size
.
width
size
.
height
)
)
>
mSharedContext
-
>
mMaxTextureSize
)
{
return
false
;
}
if
(
!
CreateFramebuffer
(
)
)
{
return
false
;
}
size_t
byteSize
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBBufferSize
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
byteSize
=
=
0
)
{
return
false
;
}
size_t
shmemSize
=
mozilla
:
:
ipc
:
:
SharedMemory
:
:
PageAlignedSize
(
byteSize
)
;
if
(
NS_WARN_IF
(
shmemSize
>
UINT32_MAX
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Buffer
too
big
?
"
)
;
return
false
;
}
auto
shmem
=
MakeRefPtr
<
mozilla
:
:
ipc
:
:
SharedMemory
>
(
)
;
if
(
NS_WARN_IF
(
!
shmem
-
>
Create
(
shmemSize
)
)
|
|
NS_WARN_IF
(
!
shmem
-
>
Map
(
shmemSize
)
)
)
{
return
false
;
}
mShmem
=
std
:
:
move
(
shmem
)
;
mShmemSize
=
shmemSize
;
mSkia
=
new
DrawTargetSkia
;
auto
stride
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBStride
(
SurfaceFormat
:
:
B8G8R8A8
size
.
width
)
;
if
(
!
mSkia
-
>
Init
(
reinterpret_cast
<
uint8_t
*
>
(
mShmem
-
>
Memory
(
)
)
size
stride
SurfaceFormat
:
:
B8G8R8A8
true
)
)
{
return
false
;
}
uint8_t
*
dtData
=
nullptr
;
IntSize
dtSize
;
int32_t
dtStride
=
0
;
SurfaceFormat
dtFormat
=
SurfaceFormat
:
:
UNKNOWN
;
if
(
!
mSkia
-
>
LockBits
(
&
dtData
&
dtSize
&
dtStride
&
dtFormat
)
)
{
return
false
;
}
mSkiaNoClip
=
new
DrawTargetSkia
;
if
(
!
mSkiaNoClip
-
>
Init
(
dtData
dtSize
dtStride
dtFormat
true
)
)
{
mSkia
-
>
ReleaseBits
(
dtData
)
;
return
false
;
}
mSkia
-
>
ReleaseBits
(
dtData
)
;
SetPermitSubpixelAA
(
IsOpaque
(
format
)
)
;
return
true
;
}
static
Atomic
<
bool
>
sContextInitError
(
false
)
;
already_AddRefed
<
SharedContextWebgl
>
SharedContextWebgl
:
:
Create
(
)
{
if
(
sContextInitError
)
{
return
nullptr
;
}
RefPtr
<
SharedContextWebgl
>
sharedContext
=
new
SharedContextWebgl
;
if
(
!
sharedContext
-
>
Initialize
(
)
)
{
return
nullptr
;
}
return
sharedContext
.
forget
(
)
;
}
bool
SharedContextWebgl
:
:
Initialize
(
)
{
WebGLContextOptions
options
=
{
}
;
options
.
alpha
=
true
;
options
.
depth
=
false
;
options
.
stencil
=
false
;
options
.
antialias
=
false
;
options
.
preserveDrawingBuffer
=
true
;
options
.
failIfMajorPerformanceCaveat
=
false
;
const
bool
resistFingerprinting
=
nsContentUtils
:
:
ShouldResistFingerprinting
(
"
Fallback
"
RFPTarget
:
:
WebGLRenderCapability
)
;
const
auto
initDesc
=
webgl
:
:
InitContextDesc
{
.
isWebgl2
=
true
.
resistFingerprinting
=
resistFingerprinting
.
principalKey
=
0
.
size
=
{
1
1
}
.
options
=
options
}
;
webgl
:
:
InitContextResult
initResult
;
mWebgl
=
WebGLContext
:
:
Create
(
nullptr
initDesc
&
initResult
)
;
if
(
!
mWebgl
)
{
sContextInitError
=
true
;
mWebgl
=
nullptr
;
return
false
;
}
if
(
mWebgl
-
>
IsContextLost
(
)
)
{
mWebgl
=
nullptr
;
return
false
;
}
mMaxTextureSize
=
initResult
.
limits
.
maxTex2dSize
;
if
(
kIsMacOS
)
{
mRasterizationTruncates
=
initResult
.
vendor
=
=
gl
:
:
GLVendor
:
:
ATI
;
}
CachePrefs
(
)
;
if
(
!
CreateShaders
(
)
)
{
sContextInitError
=
true
;
mWebgl
=
nullptr
;
return
false
;
}
mWGRPathBuilder
=
WGR
:
:
wgr_new_builder
(
)
;
return
true
;
}
inline
void
SharedContextWebgl
:
:
BlendFunc
(
GLenum
aSrcFactor
GLenum
aDstFactor
)
{
mWebgl
-
>
BlendFuncSeparate
(
{
}
aSrcFactor
aDstFactor
aSrcFactor
aDstFactor
)
;
}
void
SharedContextWebgl
:
:
SetBlendState
(
CompositionOp
aOp
const
Maybe
<
DeviceColor
>
&
aColor
)
{
if
(
aOp
=
=
mLastCompositionOp
&
&
mLastBlendColor
=
=
aColor
)
{
return
;
}
mLastCompositionOp
=
aOp
;
mLastBlendColor
=
aColor
;
bool
enabled
=
true
;
switch
(
aOp
)
{
case
CompositionOp
:
:
OP_OVER
:
if
(
aColor
)
{
mWebgl
-
>
BlendColor
(
aColor
-
>
b
aColor
-
>
g
aColor
-
>
r
1
.
0f
)
;
BlendFunc
(
LOCAL_GL_CONSTANT_COLOR
LOCAL_GL_ONE_MINUS_SRC_COLOR
)
;
}
else
{
BlendFunc
(
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
}
break
;
case
CompositionOp
:
:
OP_ADD
:
BlendFunc
(
LOCAL_GL_ONE
LOCAL_GL_ONE
)
;
break
;
case
CompositionOp
:
:
OP_ATOP
:
BlendFunc
(
LOCAL_GL_DST_ALPHA
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
break
;
case
CompositionOp
:
:
OP_SOURCE
:
if
(
aColor
)
{
mWebgl
-
>
BlendColor
(
aColor
-
>
b
aColor
-
>
g
aColor
-
>
r
aColor
-
>
a
)
;
BlendFunc
(
LOCAL_GL_CONSTANT_COLOR
LOCAL_GL_ONE_MINUS_SRC_COLOR
)
;
}
else
{
enabled
=
false
;
}
break
;
case
CompositionOp
:
:
OP_CLEAR
:
mWebgl
-
>
BlendFuncSeparate
(
{
}
LOCAL_GL_ZERO
LOCAL_GL_ONE_MINUS_SRC_ALPHA
IsOpaque
(
mCurrentTarget
-
>
GetFormat
(
)
)
?
LOCAL_GL_ONE
:
LOCAL_GL_ZERO
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
break
;
default
:
enabled
=
false
;
break
;
}
mWebgl
-
>
SetEnabled
(
LOCAL_GL_BLEND
{
}
enabled
)
;
}
bool
SharedContextWebgl
:
:
SetTarget
(
DrawTargetWebgl
*
aDT
)
{
if
(
!
mWebgl
|
|
mWebgl
-
>
IsContextLost
(
)
)
{
return
false
;
}
if
(
aDT
!
=
mCurrentTarget
)
{
mCurrentTarget
=
aDT
;
if
(
aDT
)
{
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
aDT
-
>
mFramebuffer
)
;
mViewportSize
=
aDT
-
>
GetSize
(
)
;
mWebgl
-
>
Viewport
(
0
0
mViewportSize
.
width
mViewportSize
.
height
)
;
}
}
return
true
;
}
void
SharedContextWebgl
:
:
SetClipRect
(
const
Rect
&
aClipRect
)
{
if
(
!
mClipAARect
.
IsEqualEdges
(
aClipRect
)
)
{
mClipAARect
=
aClipRect
;
mClipRect
=
RoundedOut
(
aClipRect
)
;
}
}
bool
SharedContextWebgl
:
:
SetClipMask
(
const
RefPtr
<
WebGLTexture
>
&
aTex
)
{
if
(
mLastClipMask
!
=
aTex
)
{
if
(
!
mWebgl
)
{
return
false
;
}
mWebgl
-
>
ActiveTexture
(
1
)
;
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
aTex
)
;
mWebgl
-
>
ActiveTexture
(
0
)
;
mLastClipMask
=
aTex
;
}
return
true
;
}
bool
SharedContextWebgl
:
:
SetNoClipMask
(
)
{
if
(
mNoClipMask
)
{
return
SetClipMask
(
mNoClipMask
)
;
}
if
(
!
mWebgl
)
{
return
false
;
}
mNoClipMask
=
mWebgl
-
>
CreateTexture
(
)
;
if
(
!
mNoClipMask
)
{
return
false
;
}
mWebgl
-
>
ActiveTexture
(
1
)
;
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
mNoClipMask
)
;
static
const
auto
solidMask
=
std
:
:
array
<
const
uint8_t
4
>
{
0xFF
0xFF
0xFF
0xFF
}
;
mWebgl
-
>
TexImage
(
0
LOCAL_GL_RGBA8
{
0
0
0
}
{
LOCAL_GL_RGBA
LOCAL_GL_UNSIGNED_BYTE
}
{
LOCAL_GL_TEXTURE_2D
{
1
1
1
}
gfxAlphaType
:
:
NonPremult
Some
(
Span
{
solidMask
}
)
}
)
;
InitTexParameters
(
mNoClipMask
false
)
;
mWebgl
-
>
ActiveTexture
(
0
)
;
mLastClipMask
=
mNoClipMask
;
return
true
;
}
inline
bool
DrawTargetWebgl
:
:
ClipStack
:
:
operator
=
=
(
const
DrawTargetWebgl
:
:
ClipStack
&
aOther
)
const
{
if
(
!
mTransform
.
FuzzyEquals
(
aOther
.
mTransform
)
|
|
!
mRect
.
IsEqualInterior
(
aOther
.
mRect
)
)
{
return
false
;
}
if
(
!
mPath
)
{
return
!
aOther
.
mPath
;
}
if
(
!
aOther
.
mPath
|
|
mPath
-
>
GetBackendType
(
)
!
=
aOther
.
mPath
-
>
GetBackendType
(
)
)
{
return
false
;
}
if
(
mPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
mPath
=
=
aOther
.
mPath
;
}
return
static_cast
<
const
PathSkia
*
>
(
mPath
.
get
(
)
)
-
>
GetPath
(
)
=
=
static_cast
<
const
PathSkia
*
>
(
aOther
.
mPath
.
get
(
)
)
-
>
GetPath
(
)
;
}
bool
DrawTargetWebgl
:
:
GenerateComplexClipMask
(
)
{
if
(
!
mClipChanged
|
|
(
mClipMask
&
&
mCachedClipStack
=
=
mClipStack
)
)
{
mClipChanged
=
false
;
mSharedContext
-
>
SetClipMask
(
mClipMask
)
;
mSharedContext
-
>
SetClipRect
(
mClipBounds
)
;
return
true
;
}
if
(
!
mWebglValid
)
{
return
false
;
}
RefPtr
<
WebGLContext
>
webgl
=
mSharedContext
-
>
mWebgl
;
if
(
!
webgl
)
{
return
false
;
}
bool
init
=
false
;
if
(
!
mClipMask
)
{
mClipMask
=
webgl
-
>
CreateTexture
(
)
;
if
(
!
mClipMask
)
{
return
false
;
}
init
=
true
;
}
if
(
Maybe
<
IntRect
>
clip
=
mSkia
-
>
GetDeviceClipRect
(
true
)
)
{
mClipBounds
=
*
clip
;
}
else
{
mClipBounds
=
GetRect
(
)
;
}
mClipAARect
=
Rect
(
mClipBounds
)
;
RefPtr
<
DrawTargetSkia
>
dt
=
new
DrawTargetSkia
;
if
(
!
dt
-
>
Init
(
mClipBounds
.
Size
(
)
SurfaceFormat
:
:
A8
)
)
{
return
false
;
}
mCachedClipStack
.
clear
(
)
;
for
(
auto
&
clipStack
:
mClipStack
)
{
mCachedClipStack
.
push_back
(
clipStack
)
;
dt
-
>
SetTransform
(
Matrix
(
clipStack
.
mTransform
)
.
PostTranslate
(
-
mClipBounds
.
TopLeft
(
)
)
)
;
if
(
clipStack
.
mPath
)
{
dt
-
>
PushClip
(
clipStack
.
mPath
)
;
}
else
{
dt
-
>
PushClipRect
(
clipStack
.
mRect
)
;
}
}
dt
-
>
SetTransform
(
Matrix
:
:
Translation
(
-
mClipBounds
.
TopLeft
(
)
)
)
;
dt
-
>
FillRect
(
Rect
(
mClipBounds
)
ColorPattern
(
DeviceColor
(
1
1
1
1
)
)
)
;
webgl
-
>
ActiveTexture
(
1
)
;
webgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
mClipMask
)
;
if
(
init
)
{
mSharedContext
-
>
InitTexParameters
(
mClipMask
false
)
;
}
RefPtr
<
DataSourceSurface
>
data
;
if
(
RefPtr
<
SourceSurface
>
snapshot
=
dt
-
>
Snapshot
(
)
)
{
data
=
snapshot
-
>
GetDataSurface
(
)
;
}
if
(
init
&
&
mClipBounds
.
Size
(
)
!
=
mSize
)
{
mSharedContext
-
>
UploadSurface
(
nullptr
SurfaceFormat
:
:
A8
GetRect
(
)
IntPoint
(
)
true
true
)
;
init
=
false
;
}
mSharedContext
-
>
UploadSurface
(
data
SurfaceFormat
:
:
A8
IntRect
(
IntPoint
(
)
mClipBounds
.
Size
(
)
)
mClipBounds
.
TopLeft
(
)
init
)
;
webgl
-
>
ActiveTexture
(
0
)
;
mSharedContext
-
>
mLastClipMask
=
mClipMask
;
mSharedContext
-
>
SetClipRect
(
mClipBounds
)
;
mProfile
.
OnCacheMiss
(
)
;
return
!
!
data
;
}
bool
DrawTargetWebgl
:
:
SetSimpleClipRect
(
)
{
if
(
Maybe
<
IntRect
>
clip
=
mSkia
-
>
GetDeviceClipRect
(
false
)
)
{
if
(
!
clip
-
>
IsEmpty
(
)
&
&
clip
-
>
Contains
(
GetRect
(
)
)
)
{
clip
=
Some
(
GetRect
(
)
)
;
}
mSharedContext
-
>
SetClipRect
(
*
clip
)
;
mSharedContext
-
>
SetNoClipMask
(
)
;
return
true
;
}
Rect
rect
(
GetRect
(
)
)
;
for
(
auto
&
clipStack
:
mClipStack
)
{
if
(
clipStack
.
mPath
|
|
!
clipStack
.
mTransform
.
PreservesAxisAlignedRectangles
(
)
)
{
return
false
;
}
rect
=
clipStack
.
mTransform
.
TransformBounds
(
clipStack
.
mRect
)
.
Intersect
(
rect
)
;
}
mSharedContext
-
>
SetClipRect
(
rect
)
;
mSharedContext
-
>
SetNoClipMask
(
)
;
return
true
;
}
bool
DrawTargetWebgl
:
:
PrepareContext
(
bool
aClipped
)
{
if
(
!
aClipped
)
{
mSharedContext
-
>
SetClipRect
(
GetRect
(
)
)
;
mSharedContext
-
>
SetNoClipMask
(
)
;
mRefreshClipState
=
true
;
}
else
if
(
mRefreshClipState
|
|
!
mSharedContext
-
>
IsCurrentTarget
(
this
)
)
{
if
(
!
SetSimpleClipRect
(
)
&
&
!
GenerateComplexClipMask
(
)
)
{
return
false
;
}
mClipChanged
=
false
;
mRefreshClipState
=
false
;
}
return
mSharedContext
-
>
SetTarget
(
this
)
;
}
bool
SharedContextWebgl
:
:
IsContextLost
(
)
const
{
return
!
mWebgl
|
|
mWebgl
-
>
IsContextLost
(
)
;
}
bool
DrawTargetWebgl
:
:
IsValid
(
)
const
{
return
mSharedContext
&
&
!
mSharedContext
-
>
IsContextLost
(
)
;
}
bool
DrawTargetWebgl
:
:
CanCreate
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
!
gfxVars
:
:
UseAcceleratedCanvas2D
(
)
)
{
return
false
;
}
if
(
!
Factory
:
:
AllowedSurfaceSize
(
aSize
)
)
{
return
false
;
}
static
const
int32_t
kMinDimension
=
16
;
if
(
std
:
:
min
(
aSize
.
width
aSize
.
height
)
<
kMinDimension
)
{
return
false
;
}
int32_t
minSize
=
StaticPrefs
:
:
gfx_canvas_accelerated_min_size
(
)
;
if
(
aSize
.
width
*
aSize
.
height
<
minSize
*
minSize
)
{
return
false
;
}
int32_t
maxSize
=
StaticPrefs
:
:
gfx_canvas_accelerated_max_size
(
)
;
if
(
maxSize
>
0
)
{
if
(
std
:
:
max
(
aSize
.
width
aSize
.
height
)
>
maxSize
)
{
return
false
;
}
}
else
if
(
maxSize
<
0
)
{
static
const
int32_t
kScreenPixels
=
980
*
480
;
if
(
RefPtr
<
widget
:
:
Screen
>
screen
=
widget
:
:
ScreenManager
:
:
GetSingleton
(
)
.
GetPrimaryScreen
(
)
)
{
LayoutDeviceIntSize
screenSize
=
screen
-
>
GetRect
(
)
.
Size
(
)
;
if
(
aSize
.
width
*
aSize
.
height
>
std
:
:
max
(
screenSize
.
width
*
screenSize
.
height
kScreenPixels
)
)
{
return
false
;
}
}
}
return
true
;
}
already_AddRefed
<
DrawTargetWebgl
>
DrawTargetWebgl
:
:
Create
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
SharedContextWebgl
>
&
aSharedContext
)
{
if
(
!
CanCreate
(
aSize
aFormat
)
)
{
return
nullptr
;
}
RefPtr
<
DrawTargetWebgl
>
dt
=
new
DrawTargetWebgl
;
if
(
!
dt
-
>
Init
(
aSize
aFormat
aSharedContext
)
|
|
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
return
dt
.
forget
(
)
;
}
void
*
DrawTargetWebgl
:
:
GetNativeSurface
(
NativeSurfaceType
aType
)
{
switch
(
aType
)
{
case
NativeSurfaceType
:
:
WEBGL_CONTEXT
:
if
(
mSharedContext
-
>
IsContextLost
(
)
)
{
return
nullptr
;
}
if
(
!
mWebglValid
)
{
FlushFromSkia
(
)
;
}
return
mSharedContext
-
>
mWebgl
.
get
(
)
;
default
:
return
nullptr
;
}
}
already_AddRefed
<
TextureHandle
>
SharedContextWebgl
:
:
WrapSnapshot
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
RefPtr
<
WebGLTexture
>
aTex
)
{
size_t
usedBytes
=
BackingTexture
:
:
UsedBytes
(
aFormat
aSize
)
;
PruneTextureMemory
(
usedBytes
false
)
;
RefPtr
<
StandaloneTexture
>
handle
=
new
StandaloneTexture
(
aSize
aFormat
aTex
.
forget
(
)
)
;
mStandaloneTextures
.
push_back
(
handle
)
;
mTextureHandles
.
insertFront
(
handle
)
;
mTotalTextureMemory
+
=
usedBytes
;
mUsedTextureMemory
+
=
usedBytes
;
+
+
mNumTextureHandles
;
return
handle
.
forget
(
)
;
}
void
SharedContextWebgl
:
:
SetTexFilter
(
WebGLTexture
*
aTex
bool
aFilter
)
{
mWebgl
-
>
TexParameter_base
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MAG_FILTER
FloatOrInt
(
aFilter
?
LOCAL_GL_LINEAR
:
LOCAL_GL_NEAREST
)
)
;
mWebgl
-
>
TexParameter_base
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MIN_FILTER
FloatOrInt
(
aFilter
?
LOCAL_GL_LINEAR
:
LOCAL_GL_NEAREST
)
)
;
}
void
SharedContextWebgl
:
:
InitTexParameters
(
WebGLTexture
*
aTex
bool
aFilter
)
{
mWebgl
-
>
TexParameter_base
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_S
FloatOrInt
(
LOCAL_GL_CLAMP_TO_EDGE
)
)
;
mWebgl
-
>
TexParameter_base
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_T
FloatOrInt
(
LOCAL_GL_CLAMP_TO_EDGE
)
)
;
SetTexFilter
(
aTex
aFilter
)
;
}
already_AddRefed
<
TextureHandle
>
SharedContextWebgl
:
:
CopySnapshot
(
const
IntRect
&
aRect
TextureHandle
*
aHandle
)
{
if
(
!
mWebgl
|
|
mWebgl
-
>
IsContextLost
(
)
)
{
return
nullptr
;
}
RefPtr
<
WebGLTexture
>
tex
=
mWebgl
-
>
CreateTexture
(
)
;
if
(
!
tex
)
{
return
nullptr
;
}
if
(
aHandle
)
{
if
(
!
mScratchFramebuffer
)
{
mScratchFramebuffer
=
mWebgl
-
>
CreateFramebuffer
(
)
;
}
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mScratchFramebuffer
)
;
webgl
:
:
FbAttachInfo
attachInfo
;
attachInfo
.
tex
=
aHandle
-
>
GetBackingTexture
(
)
-
>
GetWebGLTexture
(
)
;
mWebgl
-
>
FramebufferAttach
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_COLOR_ATTACHMENT0
LOCAL_GL_TEXTURE_2D
attachInfo
)
;
}
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
tex
)
;
mWebgl
-
>
TexStorage
(
LOCAL_GL_TEXTURE_2D
1
LOCAL_GL_RGBA8
{
uint32_t
(
aRect
.
width
)
uint32_t
(
aRect
.
height
)
1
}
)
;
InitTexParameters
(
tex
)
;
mWebgl
-
>
CopyTexImage
(
LOCAL_GL_TEXTURE_2D
0
0
{
0
0
0
}
{
aRect
.
x
aRect
.
y
}
{
uint32_t
(
aRect
.
width
)
uint32_t
(
aRect
.
height
)
}
)
;
ClearLastTexture
(
)
;
SurfaceFormat
format
=
aHandle
?
aHandle
-
>
GetFormat
(
)
:
mCurrentTarget
-
>
GetFormat
(
)
;
already_AddRefed
<
TextureHandle
>
result
=
WrapSnapshot
(
aRect
.
Size
(
)
format
tex
.
forget
(
)
)
;
if
(
aHandle
&
&
mCurrentTarget
)
{
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mCurrentTarget
-
>
mFramebuffer
)
;
}
return
result
;
}
inline
DrawTargetWebgl
:
:
AutoRestoreContext
:
:
AutoRestoreContext
(
DrawTargetWebgl
*
aTarget
)
:
mTarget
(
aTarget
)
mClipAARect
(
aTarget
-
>
mSharedContext
-
>
mClipAARect
)
mLastClipMask
(
aTarget
-
>
mSharedContext
-
>
mLastClipMask
)
{
}
inline
DrawTargetWebgl
:
:
AutoRestoreContext
:
:
~
AutoRestoreContext
(
)
{
mTarget
-
>
mSharedContext
-
>
SetClipRect
(
mClipAARect
)
;
if
(
mLastClipMask
)
{
mTarget
-
>
mSharedContext
-
>
SetClipMask
(
mLastClipMask
)
;
}
mTarget
-
>
mRefreshClipState
=
true
;
}
already_AddRefed
<
TextureHandle
>
DrawTargetWebgl
:
:
CopySnapshot
(
const
IntRect
&
aRect
)
{
AutoRestoreContext
restore
(
this
)
;
if
(
!
PrepareContext
(
false
)
)
{
return
nullptr
;
}
return
mSharedContext
-
>
CopySnapshot
(
aRect
)
;
}
bool
DrawTargetWebgl
:
:
HasDataSnapshot
(
)
const
{
return
(
mSkiaValid
&
&
!
mSkiaLayer
)
|
|
(
mSnapshot
&
&
mSnapshot
-
>
HasReadData
(
)
)
;
}
bool
DrawTargetWebgl
:
:
PrepareSkia
(
)
{
if
(
!
mSkiaValid
)
{
ReadIntoSkia
(
)
;
}
else
if
(
mSkiaLayer
)
{
FlattenSkia
(
)
;
}
return
mSkiaValid
;
}
bool
DrawTargetWebgl
:
:
EnsureDataSnapshot
(
)
{
return
HasDataSnapshot
(
)
|
|
PrepareSkia
(
)
;
}
void
DrawTargetWebgl
:
:
PrepareShmem
(
)
{
PrepareSkia
(
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
GetDataSnapshot
(
)
{
PrepareSkia
(
)
;
return
mSkia
-
>
Snapshot
(
mFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
Snapshot
(
)
{
if
(
mSkiaValid
)
{
return
GetDataSnapshot
(
)
;
}
if
(
!
mSnapshot
)
{
mSnapshot
=
new
SourceSurfaceWebgl
(
this
)
;
}
return
do_AddRef
(
mSnapshot
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
GetOptimizedSnapshot
(
DrawTarget
*
aTarget
)
{
if
(
aTarget
&
&
aTarget
-
>
GetBackendType
(
)
=
=
BackendType
:
:
WEBGL
&
&
static_cast
<
DrawTargetWebgl
*
>
(
aTarget
)
-
>
mSharedContext
=
=
mSharedContext
)
{
return
Snapshot
(
)
;
}
return
GetDataSnapshot
(
)
;
}
bool
SharedContextWebgl
:
:
ReadInto
(
uint8_t
*
aDstData
int32_t
aDstStride
SurfaceFormat
aFormat
const
IntRect
&
aBounds
TextureHandle
*
aHandle
)
{
MOZ_ASSERT
(
aFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
aFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
)
;
if
(
aHandle
)
{
if
(
!
mScratchFramebuffer
)
{
mScratchFramebuffer
=
mWebgl
-
>
CreateFramebuffer
(
)
;
}
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mScratchFramebuffer
)
;
webgl
:
:
FbAttachInfo
attachInfo
;
attachInfo
.
tex
=
aHandle
-
>
GetBackingTexture
(
)
-
>
GetWebGLTexture
(
)
;
mWebgl
-
>
FramebufferAttach
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_COLOR_ATTACHMENT0
LOCAL_GL_TEXTURE_2D
attachInfo
)
;
}
else
if
(
mCurrentTarget
&
&
mCurrentTarget
-
>
mIsClear
)
{
SkPixmap
(
MakeSkiaImageInfo
(
aBounds
.
Size
(
)
aFormat
)
aDstData
aDstStride
)
.
erase
(
IsOpaque
(
aFormat
)
?
SK_ColorBLACK
:
SK_ColorTRANSPARENT
)
;
return
true
;
}
webgl
:
:
ReadPixelsDesc
desc
;
desc
.
srcOffset
=
*
ivec2
:
:
From
(
aBounds
)
;
desc
.
size
=
*
uvec2
:
:
FromSize
(
aBounds
)
;
desc
.
packState
.
rowLength
=
aDstStride
/
4
;
Range
<
uint8_t
>
range
=
{
aDstData
size_t
(
aDstStride
)
*
aBounds
.
height
}
;
mWebgl
-
>
ReadPixelsInto
(
desc
range
)
;
if
(
aHandle
&
&
mCurrentTarget
)
{
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mCurrentTarget
-
>
mFramebuffer
)
;
}
return
true
;
}
already_AddRefed
<
DataSourceSurface
>
SharedContextWebgl
:
:
ReadSnapshot
(
TextureHandle
*
aHandle
)
{
SurfaceFormat
format
=
SurfaceFormat
:
:
UNKNOWN
;
IntRect
bounds
;
if
(
aHandle
)
{
format
=
aHandle
-
>
GetFormat
(
)
;
bounds
=
aHandle
-
>
GetBounds
(
)
;
}
else
{
format
=
mCurrentTarget
-
>
GetFormat
(
)
;
bounds
=
mCurrentTarget
-
>
GetRect
(
)
;
}
RefPtr
<
DataSourceSurface
>
surface
=
Factory
:
:
CreateDataSourceSurface
(
bounds
.
Size
(
)
format
)
;
if
(
!
surface
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
dstMap
(
surface
DataSourceSurface
:
:
WRITE
)
;
if
(
!
dstMap
.
IsMapped
(
)
|
|
!
ReadInto
(
dstMap
.
GetData
(
)
dstMap
.
GetStride
(
)
format
bounds
aHandle
)
)
{
return
nullptr
;
}
return
surface
.
forget
(
)
;
}
bool
DrawTargetWebgl
:
:
ReadInto
(
uint8_t
*
aDstData
int32_t
aDstStride
)
{
if
(
!
PrepareContext
(
false
)
)
{
return
false
;
}
return
mSharedContext
-
>
ReadInto
(
aDstData
aDstStride
GetFormat
(
)
GetRect
(
)
)
;
}
already_AddRefed
<
DataSourceSurface
>
DrawTargetWebgl
:
:
ReadSnapshot
(
)
{
AutoRestoreContext
restore
(
this
)
;
if
(
!
PrepareContext
(
false
)
)
{
return
nullptr
;
}
mProfile
.
OnReadback
(
)
;
return
mSharedContext
-
>
ReadSnapshot
(
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
GetBackingSurface
(
)
{
return
Snapshot
(
)
;
}
void
DrawTargetWebgl
:
:
DetachAllSnapshots
(
)
{
mSkia
-
>
DetachAllSnapshots
(
)
;
ClearSnapshot
(
)
;
}
bool
DrawTargetWebgl
:
:
MarkChanged
(
)
{
if
(
mSnapshot
)
{
ClearSnapshot
(
true
true
)
;
}
if
(
!
mWebglValid
&
&
!
FlushFromSkia
(
)
)
{
return
false
;
}
mSkiaValid
=
false
;
mIsClear
=
false
;
return
true
;
}
void
DrawTargetWebgl
:
:
MarkSkiaChanged
(
bool
aOverwrite
)
{
if
(
aOverwrite
)
{
mSkiaValid
=
true
;
mSkiaLayer
=
false
;
}
else
if
(
!
mSkiaValid
)
{
if
(
ReadIntoSkia
(
)
)
{
mProfile
.
OnFallback
(
)
;
}
}
else
if
(
mSkiaLayer
)
{
FlattenSkia
(
)
;
}
mWebglValid
=
false
;
mIsClear
=
false
;
}
static
inline
bool
SupportsLayering
(
const
DrawOptions
&
aOptions
)
{
switch
(
aOptions
.
mCompositionOp
)
{
case
CompositionOp
:
:
OP_OVER
:
return
true
;
default
:
return
false
;
}
}
void
DrawTargetWebgl
:
:
MarkSkiaChanged
(
const
DrawOptions
&
aOptions
)
{
if
(
SupportsLayering
(
aOptions
)
)
{
if
(
!
mSkiaValid
)
{
mSkiaValid
=
true
;
if
(
mWebglValid
)
{
mProfile
.
OnLayer
(
)
;
mSkiaLayer
=
true
;
mSkiaLayerClear
=
mIsClear
;
mSkia
-
>
DetachAllSnapshots
(
)
;
if
(
mSkiaLayerClear
)
{
mSkiaNoClip
-
>
FillRect
(
Rect
(
mSkiaNoClip
-
>
GetRect
(
)
)
GetClearPattern
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
}
else
{
mSkiaNoClip
-
>
ClearRect
(
Rect
(
mSkiaNoClip
-
>
GetRect
(
)
)
)
;
}
}
}
mWebglValid
=
false
;
mIsClear
=
false
;
}
else
{
MarkSkiaChanged
(
)
;
}
}
bool
DrawTargetWebgl
:
:
LockBits
(
uint8_t
*
*
aData
IntSize
*
aSize
int32_t
*
aStride
SurfaceFormat
*
aFormat
IntPoint
*
aOrigin
)
{
if
(
mSkiaValid
&
&
!
mSkiaLayer
)
{
MarkSkiaChanged
(
)
;
return
mSkia
-
>
LockBits
(
aData
aSize
aStride
aFormat
aOrigin
)
;
}
return
false
;
}
void
DrawTargetWebgl
:
:
ReleaseBits
(
uint8_t
*
aData
)
{
if
(
mSkiaValid
&
&
!
mSkiaLayer
)
{
mSkia
-
>
ReleaseBits
(
aData
)
;
}
}
static
const
float
kRectVertexData
[
12
]
=
{
0
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
1
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
1
.
0f
}
;
void
SharedContextWebgl
:
:
ResetPathVertexBuffer
(
bool
aChanged
)
{
mWebgl
-
>
BindBuffer
(
LOCAL_GL_ARRAY_BUFFER
mPathVertexBuffer
.
get
(
)
)
;
mWebgl
-
>
UninitializedBufferData_SizeOnly
(
LOCAL_GL_ARRAY_BUFFER
std
:
:
max
(
size_t
(
mPathVertexCapacity
)
sizeof
(
kRectVertexData
)
)
LOCAL_GL_DYNAMIC_DRAW
)
;
mWebgl
-
>
BufferSubData
(
LOCAL_GL_ARRAY_BUFFER
0
sizeof
(
kRectVertexData
)
(
const
uint8_t
*
)
kRectVertexData
)
;
mPathVertexOffset
=
sizeof
(
kRectVertexData
)
;
if
(
aChanged
)
{
mWGROutputBuffer
.
reset
(
mPathVertexCapacity
>
0
?
new
(
fallible
)
WGR
:
:
OutputVertex
[
mPathVertexCapacity
/
sizeof
(
WGR
:
:
OutputVertex
)
]
:
nullptr
)
;
}
}
bool
SharedContextWebgl
:
:
CreateShaders
(
)
{
if
(
!
mPathVertexArray
)
{
mPathVertexArray
=
mWebgl
-
>
CreateVertexArray
(
)
;
}
if
(
!
mPathVertexBuffer
)
{
mPathVertexBuffer
=
mWebgl
-
>
CreateBuffer
(
)
;
mWebgl
-
>
BindVertexArray
(
mPathVertexArray
.
get
(
)
)
;
ResetPathVertexBuffer
(
)
;
mWebgl
-
>
EnableVertexAttribArray
(
0
)
;
webgl
:
:
VertAttribPointerDesc
attribDesc
;
attribDesc
.
channels
=
3
;
attribDesc
.
type
=
LOCAL_GL_FLOAT
;
attribDesc
.
normalized
=
false
;
mWebgl
-
>
VertexAttribPointer
(
0
attribDesc
)
;
}
if
(
!
mSolidProgram
)
{
auto
vsSource
=
"
attribute
vec3
a_vertex
;
\
n
"
"
uniform
vec2
u_transform
[
3
]
;
\
n
"
"
uniform
vec2
u_viewport
;
\
n
"
"
uniform
vec4
u_clipbounds
;
\
n
"
"
uniform
float
u_aa
;
\
n
"
"
varying
vec2
v_cliptc
;
\
n
"
"
varying
vec4
v_clipdist
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
varying
float
v_alpha
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
scale
=
vec2
(
dot
(
u_transform
[
0
]
u_transform
[
0
]
)
\
n
"
"
dot
(
u_transform
[
1
]
u_transform
[
1
]
)
)
;
\
n
"
"
vec2
invScale
=
u_aa
*
inversesqrt
(
scale
+
1
.
0e
-
6
)
;
\
n
"
"
scale
*
=
invScale
;
\
n
"
"
vec2
extrude
=
a_vertex
.
xy
+
\
n
"
"
invScale
*
(
2
.
0
*
a_vertex
.
xy
-
1
.
0
)
;
\
n
"
"
vec2
vertex
=
u_transform
[
0
]
*
extrude
.
x
+
\
n
"
"
u_transform
[
1
]
*
extrude
.
y
+
\
n
"
"
u_transform
[
2
]
;
\
n
"
"
gl_Position
=
vec4
(
vertex
*
2
.
0
/
u_viewport
-
1
.
0
0
.
0
1
.
0
)
;
\
n
"
"
v_cliptc
=
vertex
/
u_viewport
;
\
n
"
"
v_clipdist
=
vec4
(
vertex
-
u_clipbounds
.
xy
\
n
"
"
u_clipbounds
.
zw
-
vertex
)
;
\
n
"
"
float
noAA
=
1
.
0
-
u_aa
;
\
n
"
"
v_dist
=
vec4
(
extrude
1
.
0
-
extrude
)
*
scale
.
xyxy
+
0
.
5
+
noAA
;
\
n
"
"
v_alpha
=
min
(
a_vertex
.
z
\
n
"
"
min
(
scale
.
x
1
.
0
)
*
min
(
scale
.
y
1
.
0
)
+
noAA
)
;
\
n
"
"
}
\
n
"
;
auto
fsSource
=
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u_color
;
\
n
"
"
uniform
sampler2D
u_clipmask
;
\
n
"
"
varying
highp
vec2
v_cliptc
;
\
n
"
"
varying
vec4
v_clipdist
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
varying
float
v_alpha
;
\
n
"
"
void
main
(
)
{
\
n
"
"
float
clip
=
texture2D
(
u_clipmask
v_cliptc
)
.
r
;
\
n
"
"
vec4
dist
=
min
(
v_dist
v_clipdist
)
;
\
n
"
"
dist
.
xy
=
min
(
dist
.
xy
dist
.
zw
)
;
\
n
"
"
float
aa
=
clamp
(
min
(
dist
.
x
dist
.
y
)
0
.
0
v_alpha
)
;
\
n
"
"
gl_FragColor
=
clip
*
aa
*
u_color
;
\
n
"
"
}
\
n
"
;
RefPtr
<
WebGLShader
>
vsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_VERTEX_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
vsId
vsSource
)
;
mWebgl
-
>
CompileShader
(
*
vsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
vsId
)
.
success
)
{
return
false
;
}
RefPtr
<
WebGLShader
>
fsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_FRAGMENT_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
fsId
fsSource
)
;
mWebgl
-
>
CompileShader
(
*
fsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
fsId
)
.
success
)
{
return
false
;
}
mSolidProgram
=
mWebgl
-
>
CreateProgram
(
)
;
mWebgl
-
>
AttachShader
(
*
mSolidProgram
*
vsId
)
;
mWebgl
-
>
AttachShader
(
*
mSolidProgram
*
fsId
)
;
mWebgl
-
>
BindAttribLocation
(
*
mSolidProgram
0
"
a_vertex
"
)
;
mWebgl
-
>
LinkProgram
(
*
mSolidProgram
)
;
if
(
!
mWebgl
-
>
GetLinkResult
(
*
mSolidProgram
)
.
success
)
{
return
false
;
}
mSolidProgramViewport
=
GetUniformLocation
(
mSolidProgram
"
u_viewport
"
)
;
mSolidProgramAA
=
GetUniformLocation
(
mSolidProgram
"
u_aa
"
)
;
mSolidProgramTransform
=
GetUniformLocation
(
mSolidProgram
"
u_transform
"
)
;
mSolidProgramColor
=
GetUniformLocation
(
mSolidProgram
"
u_color
"
)
;
mSolidProgramClipMask
=
GetUniformLocation
(
mSolidProgram
"
u_clipmask
"
)
;
mSolidProgramClipBounds
=
GetUniformLocation
(
mSolidProgram
"
u_clipbounds
"
)
;
if
(
!
mSolidProgramViewport
|
|
!
mSolidProgramAA
|
|
!
mSolidProgramTransform
|
|
!
mSolidProgramColor
|
|
!
mSolidProgramClipMask
|
|
!
mSolidProgramClipBounds
)
{
return
false
;
}
mWebgl
-
>
UseProgram
(
mSolidProgram
)
;
UniformData
(
LOCAL_GL_INT
mSolidProgramClipMask
Array
<
int32_t
1
>
{
1
}
)
;
}
if
(
!
mImageProgram
)
{
auto
vsSource
=
"
attribute
vec3
a_vertex
;
\
n
"
"
uniform
vec2
u_viewport
;
\
n
"
"
uniform
vec4
u_clipbounds
;
\
n
"
"
uniform
float
u_aa
;
\
n
"
"
uniform
vec2
u_transform
[
3
]
;
\
n
"
"
uniform
vec2
u_texmatrix
[
3
]
;
\
n
"
"
varying
vec2
v_cliptc
;
\
n
"
"
varying
vec2
v_texcoord
;
\
n
"
"
varying
vec4
v_clipdist
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
varying
float
v_alpha
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
scale
=
vec2
(
dot
(
u_transform
[
0
]
u_transform
[
0
]
)
\
n
"
"
dot
(
u_transform
[
1
]
u_transform
[
1
]
)
)
;
\
n
"
"
vec2
invScale
=
u_aa
*
inversesqrt
(
scale
+
1
.
0e
-
6
)
;
\
n
"
"
scale
*
=
invScale
;
\
n
"
"
vec2
extrude
=
a_vertex
.
xy
+
\
n
"
"
invScale
*
(
2
.
0
*
a_vertex
.
xy
-
1
.
0
)
;
\
n
"
"
vec2
vertex
=
u_transform
[
0
]
*
extrude
.
x
+
\
n
"
"
u_transform
[
1
]
*
extrude
.
y
+
\
n
"
"
u_transform
[
2
]
;
\
n
"
"
gl_Position
=
vec4
(
vertex
*
2
.
0
/
u_viewport
-
1
.
0
0
.
0
1
.
0
)
;
\
n
"
"
v_cliptc
=
vertex
/
u_viewport
;
\
n
"
"
v_clipdist
=
vec4
(
vertex
-
u_clipbounds
.
xy
\
n
"
"
u_clipbounds
.
zw
-
vertex
)
;
\
n
"
"
v_texcoord
=
u_texmatrix
[
0
]
*
extrude
.
x
+
\
n
"
"
u_texmatrix
[
1
]
*
extrude
.
y
+
\
n
"
"
u_texmatrix
[
2
]
;
\
n
"
"
float
noAA
=
1
.
0
-
u_aa
;
\
n
"
"
v_dist
=
vec4
(
extrude
1
.
0
-
extrude
)
*
scale
.
xyxy
+
0
.
5
+
noAA
;
\
n
"
"
v_alpha
=
min
(
a_vertex
.
z
\
n
"
"
min
(
scale
.
x
1
.
0
)
*
min
(
scale
.
y
1
.
0
)
+
noAA
)
;
\
n
"
"
}
\
n
"
;
auto
fsSource
=
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u_texbounds
;
\
n
"
"
uniform
vec4
u_color
;
\
n
"
"
uniform
float
u_swizzle
;
\
n
"
"
uniform
sampler2D
u_sampler
;
\
n
"
"
uniform
sampler2D
u_clipmask
;
\
n
"
"
varying
highp
vec2
v_cliptc
;
\
n
"
"
varying
highp
vec2
v_texcoord
;
\
n
"
"
varying
vec4
v_clipdist
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
varying
float
v_alpha
;
\
n
"
"
void
main
(
)
{
\
n
"
"
highp
vec2
tc
=
clamp
(
v_texcoord
u_texbounds
.
xy
\
n
"
"
u_texbounds
.
zw
)
;
\
n
"
"
vec4
image
=
texture2D
(
u_sampler
tc
)
;
\
n
"
"
float
clip
=
texture2D
(
u_clipmask
v_cliptc
)
.
r
;
\
n
"
"
vec4
dist
=
min
(
v_dist
v_clipdist
)
;
\
n
"
"
dist
.
xy
=
min
(
dist
.
xy
dist
.
zw
)
;
\
n
"
"
float
aa
=
clamp
(
min
(
dist
.
x
dist
.
y
)
0
.
0
v_alpha
)
;
\
n
"
"
gl_FragColor
=
clip
*
aa
*
u_color
*
\
n
"
"
mix
(
image
image
.
rrrr
u_swizzle
)
;
\
n
"
"
}
\
n
"
;
RefPtr
<
WebGLShader
>
vsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_VERTEX_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
vsId
vsSource
)
;
mWebgl
-
>
CompileShader
(
*
vsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
vsId
)
.
success
)
{
return
false
;
}
RefPtr
<
WebGLShader
>
fsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_FRAGMENT_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
fsId
fsSource
)
;
mWebgl
-
>
CompileShader
(
*
fsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
fsId
)
.
success
)
{
return
false
;
}
mImageProgram
=
mWebgl
-
>
CreateProgram
(
)
;
mWebgl
-
>
AttachShader
(
*
mImageProgram
*
vsId
)
;
mWebgl
-
>
AttachShader
(
*
mImageProgram
*
fsId
)
;
mWebgl
-
>
BindAttribLocation
(
*
mImageProgram
0
"
a_vertex
"
)
;
mWebgl
-
>
LinkProgram
(
*
mImageProgram
)
;
if
(
!
mWebgl
-
>
GetLinkResult
(
*
mImageProgram
)
.
success
)
{
return
false
;
}
mImageProgramViewport
=
GetUniformLocation
(
mImageProgram
"
u_viewport
"
)
;
mImageProgramAA
=
GetUniformLocation
(
mImageProgram
"
u_aa
"
)
;
mImageProgramTransform
=
GetUniformLocation
(
mImageProgram
"
u_transform
"
)
;
mImageProgramTexMatrix
=
GetUniformLocation
(
mImageProgram
"
u_texmatrix
"
)
;
mImageProgramTexBounds
=
GetUniformLocation
(
mImageProgram
"
u_texbounds
"
)
;
mImageProgramSwizzle
=
GetUniformLocation
(
mImageProgram
"
u_swizzle
"
)
;
mImageProgramColor
=
GetUniformLocation
(
mImageProgram
"
u_color
"
)
;
mImageProgramSampler
=
GetUniformLocation
(
mImageProgram
"
u_sampler
"
)
;
mImageProgramClipMask
=
GetUniformLocation
(
mImageProgram
"
u_clipmask
"
)
;
mImageProgramClipBounds
=
GetUniformLocation
(
mImageProgram
"
u_clipbounds
"
)
;
if
(
!
mImageProgramViewport
|
|
!
mImageProgramAA
|
|
!
mImageProgramTransform
|
|
!
mImageProgramTexMatrix
|
|
!
mImageProgramTexBounds
|
|
!
mImageProgramSwizzle
|
|
!
mImageProgramColor
|
|
!
mImageProgramSampler
|
|
!
mImageProgramClipMask
|
|
!
mImageProgramClipBounds
)
{
return
false
;
}
mWebgl
-
>
UseProgram
(
mImageProgram
)
;
UniformData
(
LOCAL_GL_INT
mImageProgramSampler
Array
<
int32_t
1
>
{
0
}
)
;
UniformData
(
LOCAL_GL_INT
mImageProgramClipMask
Array
<
int32_t
1
>
{
1
}
)
;
}
return
true
;
}
void
SharedContextWebgl
:
:
EnableScissor
(
const
IntRect
&
aRect
)
{
if
(
!
mLastScissor
.
IsEqualEdges
(
aRect
)
)
{
mLastScissor
=
aRect
;
mWebgl
-
>
Scissor
(
aRect
.
x
aRect
.
y
aRect
.
width
aRect
.
height
)
;
}
if
(
!
mScissorEnabled
)
{
mScissorEnabled
=
true
;
mWebgl
-
>
SetEnabled
(
LOCAL_GL_SCISSOR_TEST
{
}
true
)
;
}
}
void
SharedContextWebgl
:
:
DisableScissor
(
)
{
if
(
mScissorEnabled
)
{
mScissorEnabled
=
false
;
mWebgl
-
>
SetEnabled
(
LOCAL_GL_SCISSOR_TEST
{
}
false
)
;
}
}
inline
ColorPattern
DrawTargetWebgl
:
:
GetClearPattern
(
)
const
{
return
ColorPattern
(
DeviceColor
(
0
.
0f
0
.
0f
0
.
0f
IsOpaque
(
mFormat
)
?
1
.
0f
:
0
.
0f
)
)
;
}
template
<
typename
R
>
inline
RectDouble
DrawTargetWebgl
:
:
TransformDouble
(
const
R
&
aRect
)
const
{
return
MatrixDouble
(
mTransform
)
.
TransformBounds
(
WidenToDouble
(
aRect
)
)
;
}
inline
Maybe
<
Rect
>
DrawTargetWebgl
:
:
RectClippedToViewport
(
const
RectDouble
&
aRect
)
const
{
if
(
!
mTransform
.
PreservesAxisAlignedRectangles
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
NarrowToFloat
(
aRect
.
SafeIntersect
(
RectDouble
(
GetRect
(
)
)
)
)
)
;
}
static
inline
bool
RectInsidePrecisionLimits
(
const
RectDouble
&
aRect
)
{
return
RectDouble
(
-
(
1
<
<
20
)
-
(
1
<
<
20
)
2
<
<
20
2
<
<
20
)
.
Contains
(
aRect
)
;
}
void
DrawTargetWebgl
:
:
ClearRect
(
const
Rect
&
aRect
)
{
if
(
mIsClear
)
{
return
;
}
RectDouble
xformRect
=
TransformDouble
(
aRect
)
;
bool
containsViewport
=
false
;
if
(
Maybe
<
Rect
>
clipped
=
RectClippedToViewport
(
xformRect
)
)
{
containsViewport
=
clipped
-
>
Size
(
)
=
=
Size
(
GetSize
(
)
)
;
DrawRect
(
*
clipped
GetClearPattern
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_CLEAR
)
Nothing
(
)
nullptr
false
)
;
}
else
if
(
RectInsidePrecisionLimits
(
xformRect
)
)
{
DrawRect
(
aRect
GetClearPattern
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_CLEAR
)
)
;
}
else
{
MarkSkiaChanged
(
)
;
mSkia
-
>
ClearRect
(
aRect
)
;
}
if
(
containsViewport
&
&
mSharedContext
-
>
IsCurrentTarget
(
this
)
&
&
!
mSharedContext
-
>
HasClipMask
(
)
&
&
mSharedContext
-
>
mClipAARect
.
Contains
(
Rect
(
GetRect
(
)
)
)
)
{
mIsClear
=
true
;
}
}
static
inline
DeviceColor
PremultiplyColor
(
const
DeviceColor
&
aColor
float
aAlpha
=
1
.
0f
)
{
float
a
=
aColor
.
a
*
aAlpha
;
return
DeviceColor
(
aColor
.
r
*
a
aColor
.
g
*
a
aColor
.
b
*
a
a
)
;
}
bool
DrawTargetWebgl
:
:
CreateFramebuffer
(
)
{
RefPtr
<
WebGLContext
>
webgl
=
mSharedContext
-
>
mWebgl
;
if
(
!
mFramebuffer
)
{
mFramebuffer
=
webgl
-
>
CreateFramebuffer
(
)
;
}
if
(
!
mTex
)
{
mTex
=
webgl
-
>
CreateTexture
(
)
;
webgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
mTex
)
;
webgl
-
>
TexStorage
(
LOCAL_GL_TEXTURE_2D
1
LOCAL_GL_RGBA8
{
uint32_t
(
mSize
.
width
)
uint32_t
(
mSize
.
height
)
1
}
)
;
mSharedContext
-
>
InitTexParameters
(
mTex
)
;
webgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mFramebuffer
)
;
webgl
:
:
FbAttachInfo
attachInfo
;
attachInfo
.
tex
=
mTex
;
webgl
-
>
FramebufferAttach
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_COLOR_ATTACHMENT0
LOCAL_GL_TEXTURE_2D
attachInfo
)
;
webgl
-
>
Viewport
(
0
0
mSize
.
width
mSize
.
height
)
;
mSharedContext
-
>
DisableScissor
(
)
;
DeviceColor
color
=
PremultiplyColor
(
GetClearPattern
(
)
.
mColor
)
;
webgl
-
>
ClearColor
(
color
.
b
color
.
g
color
.
r
color
.
a
)
;
webgl
-
>
Clear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
mSharedContext
-
>
ClearTarget
(
)
;
mSharedContext
-
>
ClearLastTexture
(
)
;
}
return
true
;
}
void
DrawTargetWebgl
:
:
CopySurface
(
SourceSurface
*
aSurface
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
{
IntRect
destRect
=
IntRect
(
aDestination
aSourceRect
.
Size
(
)
)
.
SafeIntersect
(
GetRect
(
)
)
;
IntRect
srcRect
=
destRect
-
aDestination
+
aSourceRect
.
TopLeft
(
)
;
if
(
srcRect
.
IsEmpty
(
)
)
{
return
;
}
if
(
mSkiaValid
)
{
if
(
mSkiaLayer
)
{
if
(
destRect
.
Contains
(
GetRect
(
)
)
)
{
mSkiaLayer
=
false
;
}
else
if
(
!
IsOpaque
(
aSurface
-
>
GetFormat
(
)
)
)
{
FlattenSkia
(
)
;
}
}
else
{
MarkSkiaChanged
(
)
;
}
mSkia
-
>
CopySurface
(
aSurface
srcRect
destRect
.
TopLeft
(
)
)
;
return
;
}
IntRect
samplingRect
;
if
(
!
mSharedContext
-
>
IsCompatibleSurface
(
aSurface
)
)
{
if
(
destRect
.
Contains
(
GetRect
(
)
)
)
{
MarkSkiaChanged
(
true
)
;
mSkia
-
>
DetachAllSnapshots
(
)
;
mSkiaNoClip
-
>
CopySurface
(
aSurface
srcRect
destRect
.
TopLeft
(
)
)
;
return
;
}
IntRect
surfaceRect
=
aSurface
-
>
GetRect
(
)
;
if
(
!
srcRect
.
IsEqualEdges
(
surfaceRect
)
)
{
samplingRect
=
srcRect
.
SafeIntersect
(
surfaceRect
)
;
}
}
Matrix
matrix
=
Matrix
:
:
Translation
(
destRect
.
TopLeft
(
)
-
srcRect
.
TopLeft
(
)
)
;
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
matrix
SamplingFilter
:
:
POINT
samplingRect
)
;
DrawRect
(
Rect
(
destRect
)
pattern
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
Nothing
(
)
nullptr
false
false
)
;
}
void
DrawTargetWebgl
:
:
PushClip
(
const
Path
*
aPath
)
{
if
(
aPath
&
&
aPath
-
>
GetBackendType
(
)
=
=
BackendType
:
:
SKIA
)
{
if
(
Maybe
<
Rect
>
rect
=
aPath
-
>
AsRect
(
)
)
{
PushClipRect
(
*
rect
)
;
return
;
}
}
mClipChanged
=
true
;
mRefreshClipState
=
true
;
mSkia
-
>
PushClip
(
aPath
)
;
mClipStack
.
push_back
(
{
GetTransform
(
)
Rect
(
)
aPath
}
)
;
}
void
DrawTargetWebgl
:
:
PushClipRect
(
const
Rect
&
aRect
)
{
mClipChanged
=
true
;
mRefreshClipState
=
true
;
mSkia
-
>
PushClipRect
(
aRect
)
;
mClipStack
.
push_back
(
{
GetTransform
(
)
aRect
nullptr
}
)
;
}
void
DrawTargetWebgl
:
:
PushDeviceSpaceClipRects
(
const
IntRect
*
aRects
uint32_t
aCount
)
{
mClipChanged
=
true
;
mRefreshClipState
=
true
;
mSkia
-
>
PushDeviceSpaceClipRects
(
aRects
aCount
)
;
for
(
uint32_t
i
=
0
;
i
<
aCount
;
i
+
+
)
{
mClipStack
.
push_back
(
{
Matrix
(
)
Rect
(
aRects
[
i
]
)
nullptr
}
)
;
}
}
void
DrawTargetWebgl
:
:
PopClip
(
)
{
mClipChanged
=
true
;
mRefreshClipState
=
true
;
mSkia
-
>
PopClip
(
)
;
mClipStack
.
pop_back
(
)
;
}
bool
DrawTargetWebgl
:
:
RemoveAllClips
(
)
{
if
(
mClipStack
.
empty
(
)
)
{
return
true
;
}
if
(
!
mSkia
-
>
RemoveAllClips
(
)
)
{
return
false
;
}
mClipChanged
=
true
;
mRefreshClipState
=
true
;
mClipStack
.
clear
(
)
;
return
true
;
}
void
DrawTargetWebgl
:
:
CopyToFallback
(
DrawTarget
*
aDT
)
{
if
(
RefPtr
<
SourceSurface
>
snapshot
=
Snapshot
(
)
)
{
aDT
-
>
CopySurface
(
snapshot
snapshot
-
>
GetRect
(
)
gfx
:
:
IntPoint
(
0
0
)
)
;
}
aDT
-
>
RemoveAllClips
(
)
;
for
(
auto
&
clipStack
:
mClipStack
)
{
aDT
-
>
SetTransform
(
clipStack
.
mTransform
)
;
if
(
clipStack
.
mPath
)
{
aDT
-
>
PushClip
(
clipStack
.
mPath
)
;
}
else
{
aDT
-
>
PushClipRect
(
clipStack
.
mRect
)
;
}
}
aDT
-
>
SetTransform
(
GetTransform
(
)
)
;
}
static
inline
bool
SupportsDrawOptions
(
const
DrawOptions
&
aOptions
)
{
switch
(
aOptions
.
mCompositionOp
)
{
case
CompositionOp
:
:
OP_OVER
:
case
CompositionOp
:
:
OP_ADD
:
case
CompositionOp
:
:
OP_ATOP
:
case
CompositionOp
:
:
OP_SOURCE
:
case
CompositionOp
:
:
OP_CLEAR
:
return
true
;
default
:
return
false
;
}
}
bool
SharedContextWebgl
:
:
SupportsPattern
(
const
Pattern
&
aPattern
)
{
switch
(
aPattern
.
GetType
(
)
)
{
case
PatternType
:
:
COLOR
:
return
true
;
case
PatternType
:
:
SURFACE
:
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
if
(
surfacePattern
.
mExtendMode
!
=
ExtendMode
:
:
CLAMP
)
{
return
false
;
}
if
(
surfacePattern
.
mSurface
)
{
if
(
IsCompatibleSurface
(
surfacePattern
.
mSurface
)
)
{
return
true
;
}
IntSize
size
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
int32_t
maxSize
=
int32_t
(
std
:
:
min
(
StaticPrefs
:
:
gfx_canvas_accelerated_max_surface_size
(
)
mMaxTextureSize
)
)
;
if
(
std
:
:
max
(
size
.
width
size
.
height
)
>
maxSize
&
&
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
|
|
std
:
:
max
(
surfacePattern
.
mSamplingRect
.
width
surfacePattern
.
mSamplingRect
.
height
)
>
maxSize
)
)
{
return
false
;
}
}
return
true
;
}
default
:
return
false
;
}
}
bool
DrawTargetWebgl
:
:
DrawRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
Maybe
<
DeviceColor
>
aMaskColor
RefPtr
<
TextureHandle
>
*
aHandle
bool
aTransformed
bool
aClipped
bool
aAccelOnly
bool
aForceUpdate
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
mWebglValid
|
|
(
mSkiaLayer
&
&
!
mLayerDepth
&
&
(
aAccelOnly
|
|
!
SupportsLayering
(
aOptions
)
)
)
)
{
if
(
PrepareContext
(
aClipped
)
)
{
return
mSharedContext
-
>
DrawRectAccel
(
aRect
aPattern
aOptions
aMaskColor
aHandle
aTransformed
aClipped
aAccelOnly
aForceUpdate
aStrokeOptions
)
;
}
}
if
(
!
aAccelOnly
)
{
DrawRectFallback
(
aRect
aPattern
aOptions
aMaskColor
aTransformed
aClipped
aStrokeOptions
)
;
}
return
false
;
}
void
DrawTargetWebgl
:
:
DrawRectFallback
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
Maybe
<
DeviceColor
>
aMaskColor
bool
aTransformed
bool
aClipped
const
StrokeOptions
*
aStrokeOptions
)
{
MarkSkiaChanged
(
aOptions
)
;
if
(
aTransformed
)
{
if
(
aMaskColor
)
{
mSkia
-
>
Mask
(
ColorPattern
(
*
aMaskColor
)
aPattern
aOptions
)
;
}
else
if
(
aStrokeOptions
)
{
mSkia
-
>
StrokeRect
(
aRect
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
}
else
if
(
aClipped
)
{
mSkia
-
>
SetTransform
(
Matrix
(
)
)
;
if
(
aMaskColor
)
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
if
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
)
{
mSkia
-
>
MaskSurface
(
ColorPattern
(
*
aMaskColor
)
surfacePattern
.
mSurface
aRect
.
TopLeft
(
)
aOptions
)
;
}
else
{
mSkia
-
>
Mask
(
ColorPattern
(
*
aMaskColor
)
aPattern
aOptions
)
;
}
}
else
if
(
aStrokeOptions
)
{
mSkia
-
>
StrokeRect
(
aRect
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
mSkia
-
>
SetTransform
(
mTransform
)
;
}
else
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
SURFACE
)
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
mSkia
-
>
CopySurface
(
surfacePattern
.
mSurface
surfacePattern
.
mSurface
-
>
GetRect
(
)
IntPoint
:
:
Round
(
aRect
.
TopLeft
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
}
}
inline
already_AddRefed
<
WebGLTexture
>
SharedContextWebgl
:
:
GetCompatibleSnapshot
(
SourceSurface
*
aSurface
)
const
{
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
WEBGL
)
{
RefPtr
<
SourceSurfaceWebgl
>
webglSurf
=
static_cast
<
SourceSurfaceWebgl
*
>
(
aSurface
)
;
if
(
this
=
=
webglSurf
-
>
mSharedContext
)
{
if
(
webglSurf
-
>
mHandle
)
{
return
do_AddRef
(
webglSurf
-
>
mHandle
-
>
GetBackingTexture
(
)
-
>
GetWebGLTexture
(
)
)
;
}
if
(
RefPtr
<
DrawTargetWebgl
>
webglDT
=
webglSurf
-
>
GetTarget
(
)
)
{
if
(
!
IsCurrentTarget
(
webglDT
)
)
{
return
do_AddRef
(
webglDT
-
>
mTex
)
;
}
}
}
}
return
nullptr
;
}
inline
bool
SharedContextWebgl
:
:
IsCompatibleSurface
(
SourceSurface
*
aSurface
)
const
{
return
bool
(
RefPtr
<
WebGLTexture
>
(
GetCompatibleSnapshot
(
aSurface
)
)
)
;
}
bool
SharedContextWebgl
:
:
UploadSurface
(
DataSourceSurface
*
aData
SurfaceFormat
aFormat
const
IntRect
&
aSrcRect
const
IntPoint
&
aDstOffset
bool
aInit
bool
aZero
const
RefPtr
<
WebGLTexture
>
&
aTex
)
{
webgl
:
:
TexUnpackBlobDesc
texDesc
=
{
LOCAL_GL_TEXTURE_2D
{
uint32_t
(
aSrcRect
.
width
)
uint32_t
(
aSrcRect
.
height
)
1
}
}
;
if
(
aData
)
{
DataSourceSurface
:
:
ScopedMap
map
(
aData
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
false
;
}
int32_t
stride
=
map
.
GetStride
(
)
;
int32_t
bpp
=
BytesPerPixel
(
aFormat
)
;
Span
<
const
uint8_t
>
range
(
map
.
GetData
(
)
+
aSrcRect
.
y
*
size_t
(
stride
)
+
aSrcRect
.
x
*
bpp
std
:
:
max
(
aSrcRect
.
height
-
1
0
)
*
size_t
(
stride
)
+
aSrcRect
.
width
*
bpp
)
;
texDesc
.
cpuData
=
Some
(
range
)
;
texDesc
.
unpacking
.
alignmentInTypeElems
=
stride
%
4
?
1
:
4
;
texDesc
.
unpacking
.
rowLength
=
stride
/
bpp
;
}
else
if
(
aZero
)
{
MOZ_ASSERT
(
aSrcRect
.
TopLeft
(
)
=
=
IntPoint
(
0
0
)
)
;
size_t
size
=
size_t
(
GetAlignedStride
<
4
>
(
aSrcRect
.
width
BytesPerPixel
(
aFormat
)
)
)
*
aSrcRect
.
height
;
if
(
!
mZeroBuffer
|
|
size
>
mZeroSize
)
{
mZeroBuffer
=
mWebgl
-
>
CreateBuffer
(
)
;
mZeroSize
=
size
;
mWebgl
-
>
BindBuffer
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
mZeroBuffer
)
;
mWebgl
-
>
BufferData
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
size
nullptr
LOCAL_GL_STATIC_DRAW
)
;
}
else
{
mWebgl
-
>
BindBuffer
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
mZeroBuffer
)
;
}
texDesc
.
pboOffset
=
Some
(
0
)
;
}
GLenum
intFormat
=
aFormat
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_R8
:
LOCAL_GL_RGBA8
;
GLenum
extFormat
=
aFormat
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_RED
:
LOCAL_GL_RGBA
;
webgl
:
:
PackingInfo
texPI
=
{
extFormat
LOCAL_GL_UNSIGNED_BYTE
}
;
if
(
aTex
)
{
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
aTex
)
;
}
mWebgl
-
>
TexImage
(
0
aInit
?
intFormat
:
0
{
uint32_t
(
aDstOffset
.
x
)
uint32_t
(
aDstOffset
.
y
)
0
}
texPI
texDesc
)
;
if
(
aTex
)
{
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
mLastTexture
)
;
}
if
(
!
aData
&
&
aZero
)
{
mWebgl
-
>
BindBuffer
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
0
)
;
}
return
true
;
}
already_AddRefed
<
TextureHandle
>
SharedContextWebgl
:
:
AllocateTextureHandle
(
SurfaceFormat
aFormat
const
IntSize
&
aSize
bool
aAllowShared
bool
aRenderable
)
{
RefPtr
<
TextureHandle
>
handle
;
size_t
usedBytes
=
BackingTexture
:
:
UsedBytes
(
aFormat
aSize
)
;
PruneTextureMemory
(
usedBytes
false
)
;
int32_t
pageSize
=
int32_t
(
std
:
:
min
(
StaticPrefs
:
:
gfx_canvas_accelerated_shared_page_size
(
)
mMaxTextureSize
)
)
;
if
(
aAllowShared
&
&
std
:
:
max
(
aSize
.
width
aSize
.
height
)
<
=
pageSize
/
2
)
{
for
(
auto
&
shared
:
mSharedTextures
)
{
if
(
shared
-
>
GetFormat
(
)
=
=
aFormat
&
&
shared
-
>
IsRenderable
(
)
=
=
aRenderable
)
{
bool
wasEmpty
=
!
shared
-
>
HasAllocatedHandles
(
)
;
handle
=
shared
-
>
Allocate
(
aSize
)
;
if
(
handle
)
{
if
(
wasEmpty
)
{
mEmptyTextureMemory
-
=
shared
-
>
UsedBytes
(
)
;
}
break
;
}
}
}
if
(
!
handle
)
{
if
(
RefPtr
<
WebGLTexture
>
tex
=
mWebgl
-
>
CreateTexture
(
)
)
{
RefPtr
<
SharedTexture
>
shared
=
new
SharedTexture
(
IntSize
(
pageSize
pageSize
)
aFormat
tex
)
;
if
(
aRenderable
)
{
shared
-
>
MarkRenderable
(
)
;
}
mSharedTextures
.
push_back
(
shared
)
;
mTotalTextureMemory
+
=
shared
-
>
UsedBytes
(
)
;
handle
=
shared
-
>
Allocate
(
aSize
)
;
}
}
}
else
{
if
(
RefPtr
<
WebGLTexture
>
tex
=
mWebgl
-
>
CreateTexture
(
)
)
{
RefPtr
<
StandaloneTexture
>
standalone
=
new
StandaloneTexture
(
aSize
aFormat
tex
)
;
if
(
aRenderable
)
{
standalone
-
>
MarkRenderable
(
)
;
}
mStandaloneTextures
.
push_back
(
standalone
)
;
mTotalTextureMemory
+
=
standalone
-
>
UsedBytes
(
)
;
handle
=
standalone
;
}
}
if
(
!
handle
)
{
return
nullptr
;
}
mTextureHandles
.
insertFront
(
handle
)
;
+
+
mNumTextureHandles
;
mUsedTextureMemory
+
=
handle
-
>
UsedBytes
(
)
;
return
handle
.
forget
(
)
;
}
static
inline
SamplingFilter
GetSamplingFilter
(
const
Pattern
&
aPattern
)
{
return
aPattern
.
GetType
(
)
=
=
PatternType
:
:
SURFACE
?
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
.
mSamplingFilter
:
SamplingFilter
:
:
GOOD
;
}
static
inline
bool
UseNearestFilter
(
const
Pattern
&
aPattern
)
{
return
GetSamplingFilter
(
aPattern
)
=
=
SamplingFilter
:
:
POINT
;
}
static
inline
Maybe
<
IntRect
>
IsAlignedRect
(
bool
aTransformed
const
Matrix
&
aCurrentTransform
const
Rect
&
aRect
)
{
if
(
!
aTransformed
|
|
aCurrentTransform
.
HasOnlyIntegerTranslation
(
)
)
{
auto
intRect
=
RoundedToInt
(
aRect
)
;
if
(
aRect
.
WithinEpsilonOf
(
Rect
(
intRect
)
1
.
0e
-
3f
)
)
{
if
(
aTransformed
)
{
intRect
+
=
RoundedToInt
(
aCurrentTransform
.
GetTranslation
(
)
)
;
}
return
Some
(
intRect
)
;
}
}
return
Nothing
(
)
;
}
Maybe
<
uint32_t
>
SharedContextWebgl
:
:
GetUniformLocation
(
const
RefPtr
<
WebGLProgram
>
&
aProg
const
std
:
:
string
&
aName
)
const
{
if
(
!
aProg
|
|
!
aProg
-
>
LinkInfo
(
)
)
{
return
Nothing
(
)
;
}
for
(
const
auto
&
activeUniform
:
aProg
-
>
LinkInfo
(
)
-
>
active
.
activeUniforms
)
{
if
(
activeUniform
.
block_index
!
=
-
1
)
continue
;
auto
locName
=
activeUniform
.
name
;
const
auto
indexed
=
webgl
:
:
ParseIndexed
(
locName
)
;
if
(
indexed
)
{
locName
=
indexed
-
>
name
;
}
const
auto
baseLength
=
locName
.
size
(
)
;
for
(
const
auto
&
pair
:
activeUniform
.
locByIndex
)
{
if
(
indexed
)
{
locName
.
erase
(
baseLength
)
;
locName
+
=
'
[
'
;
locName
+
=
std
:
:
to_string
(
pair
.
first
)
;
locName
+
=
'
]
'
;
}
if
(
locName
=
=
aName
|
|
locName
=
=
aName
+
"
[
0
]
"
)
{
return
Some
(
pair
.
second
)
;
}
}
}
return
Nothing
(
)
;
}
template
<
class
T
>
struct
IsUniformDataValT
:
std
:
:
false_type
{
}
;
template
<
>
struct
IsUniformDataValT
<
webgl
:
:
UniformDataVal
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsUniformDataValT
<
float
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsUniformDataValT
<
int32_t
>
:
std
:
:
true_type
{
}
;
template
<
>
struct
IsUniformDataValT
<
uint32_t
>
:
std
:
:
true_type
{
}
;
template
<
typename
T
typename
=
std
:
:
enable_if_t
<
IsUniformDataValT
<
T
>
:
:
value
>
>
inline
Range
<
const
webgl
:
:
UniformDataVal
>
AsUniformDataVal
(
const
Range
<
const
T
>
&
data
)
{
return
{
data
.
begin
(
)
.
template
ReinterpretCast
<
const
webgl
:
:
UniformDataVal
>
(
)
data
.
end
(
)
.
template
ReinterpretCast
<
const
webgl
:
:
UniformDataVal
>
(
)
}
;
}
template
<
class
T
size_t
N
>
inline
void
SharedContextWebgl
:
:
UniformData
(
GLenum
aFuncElemType
const
Maybe
<
uint32_t
>
&
aLoc
const
Array
<
T
N
>
&
aData
)
{
mWebgl
-
>
UniformData
(
*
aLoc
false
AsUniformDataVal
(
Range
<
const
T
>
(
Span
<
const
T
>
(
aData
)
)
)
)
;
}
template
<
class
T
size_t
N
>
void
SharedContextWebgl
:
:
MaybeUniformData
(
GLenum
aFuncElemType
const
Maybe
<
uint32_t
>
&
aLoc
const
Array
<
T
N
>
&
aData
Maybe
<
Array
<
T
N
>
>
&
aCached
)
{
if
(
aCached
.
isNothing
(
)
|
|
!
(
*
aCached
=
=
aData
)
)
{
aCached
=
Some
(
aData
)
;
UniformData
(
aFuncElemType
aLoc
aData
)
;
}
}
inline
void
SharedContextWebgl
:
:
DrawQuad
(
)
{
mWebgl
-
>
DrawArraysInstanced
(
LOCAL_GL_TRIANGLE_FAN
0
4
1
)
;
}
void
SharedContextWebgl
:
:
DrawTriangles
(
const
PathVertexRange
&
aRange
)
{
mWebgl
-
>
DrawArraysInstanced
(
LOCAL_GL_TRIANGLES
GLint
(
aRange
.
mOffset
)
GLsizei
(
aRange
.
mLength
)
1
)
;
}
bool
SharedContextWebgl
:
:
DrawRectAccel
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
Maybe
<
DeviceColor
>
aMaskColor
RefPtr
<
TextureHandle
>
*
aHandle
bool
aTransformed
bool
aClipped
bool
aAccelOnly
bool
aForceUpdate
const
StrokeOptions
*
aStrokeOptions
const
PathVertexRange
*
aVertexRange
const
Matrix
*
aRectXform
)
{
if
(
aRect
.
IsEmpty
(
)
|
|
mClipRect
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
(
!
aForceUpdate
&
&
!
SupportsPattern
(
aPattern
)
)
|
|
aStrokeOptions
|
|
!
mCurrentTarget
-
>
MarkChanged
(
)
)
{
if
(
!
aAccelOnly
)
{
MOZ_ASSERT
(
!
aVertexRange
)
;
mCurrentTarget
-
>
DrawRectFallback
(
aRect
aPattern
aOptions
aMaskColor
aTransformed
aClipped
aStrokeOptions
)
;
}
return
false
;
}
const
Matrix
&
currentTransform
=
mCurrentTarget
-
>
GetTransform
(
)
;
Matrix
rectXform
=
currentTransform
;
if
(
aRectXform
)
{
rectXform
.
PreMultiply
(
*
aRectXform
)
;
}
if
(
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
&
&
aTransformed
&
&
aClipped
&
&
(
HasClipMask
(
)
|
|
!
rectXform
.
PreservesAxisAlignedRectangles
(
)
|
|
!
rectXform
.
TransformBounds
(
aRect
)
.
Contains
(
Rect
(
mClipAARect
)
)
|
|
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
SURFACE
&
&
!
IsAlignedRect
(
aTransformed
rectXform
aRect
)
)
)
)
{
return
DrawRectAccel
(
Rect
(
mClipRect
)
ColorPattern
(
DeviceColor
(
0
0
0
0
)
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
aOptions
.
mAntialiasMode
)
Nothing
(
)
nullptr
false
aClipped
aAccelOnly
)
&
&
DrawRectAccel
(
aRect
aPattern
DrawOptions
(
aOptions
.
mAlpha
CompositionOp
:
:
OP_ADD
aOptions
.
mAntialiasMode
)
aMaskColor
aHandle
aTransformed
aClipped
aAccelOnly
aForceUpdate
aStrokeOptions
aVertexRange
aRectXform
)
;
}
if
(
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_CLEAR
&
&
aPattern
.
GetType
(
)
=
=
PatternType
:
:
SURFACE
&
&
!
aMaskColor
)
{
return
DrawRectAccel
(
aRect
ColorPattern
(
DeviceColor
(
1
1
1
1
)
)
aOptions
Nothing
(
)
aHandle
aTransformed
aClipped
aAccelOnly
aForceUpdate
aStrokeOptions
aVertexRange
aRectXform
)
;
}
if
(
!
mClipRect
.
Contains
(
IntRect
(
IntPoint
(
)
mViewportSize
)
)
)
{
EnableScissor
(
mClipRect
)
;
}
else
{
DisableScissor
(
)
;
}
bool
success
=
false
;
switch
(
aPattern
.
GetType
(
)
)
{
case
PatternType
:
:
COLOR
:
{
if
(
!
aVertexRange
)
{
mCurrentTarget
-
>
mProfile
.
OnUncachedDraw
(
)
;
}
DeviceColor
color
=
PremultiplyColor
(
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
aOptions
.
mAlpha
)
;
if
(
(
(
color
.
a
=
=
1
.
0f
&
&
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_OVER
)
|
|
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
|
|
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_CLEAR
)
&
&
!
aStrokeOptions
&
&
!
aVertexRange
&
&
!
HasClipMask
(
)
&
&
mClipAARect
.
IsEqualEdges
(
Rect
(
mClipRect
)
)
)
{
if
(
Maybe
<
IntRect
>
intRect
=
IsAlignedRect
(
aTransformed
rectXform
aRect
)
)
{
if
(
intRect
-
>
Area
(
)
>
=
(
mViewportSize
.
width
/
2
)
*
(
mViewportSize
.
height
/
2
)
)
{
if
(
!
intRect
-
>
Contains
(
mClipRect
)
)
{
EnableScissor
(
intRect
-
>
Intersect
(
mClipRect
)
)
;
}
if
(
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_CLEAR
)
{
color
=
PremultiplyColor
(
mCurrentTarget
-
>
GetClearPattern
(
)
.
mColor
)
;
}
mWebgl
-
>
ClearColor
(
color
.
b
color
.
g
color
.
r
color
.
a
)
;
mWebgl
-
>
Clear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
success
=
true
;
break
;
}
}
}
Maybe
<
DeviceColor
>
blendColor
;
if
(
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
|
|
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_CLEAR
)
{
blendColor
=
Some
(
color
)
;
color
=
DeviceColor
(
1
1
1
1
)
;
}
SetBlendState
(
aOptions
.
mCompositionOp
blendColor
)
;
if
(
mLastProgram
!
=
mSolidProgram
)
{
mWebgl
-
>
UseProgram
(
mSolidProgram
)
;
mLastProgram
=
mSolidProgram
;
}
Array
<
float
2
>
viewportData
=
{
float
(
mViewportSize
.
width
)
float
(
mViewportSize
.
height
)
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC2
mSolidProgramViewport
viewportData
mSolidProgramUniformState
.
mViewport
)
;
Array
<
float
1
>
aaData
=
{
aVertexRange
?
0
.
0f
:
1
.
0f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT
mSolidProgramAA
aaData
mSolidProgramUniformState
.
mAA
)
;
Array
<
float
4
>
clipData
=
{
mClipAARect
.
x
-
0
.
5f
mClipAARect
.
y
-
0
.
5f
mClipAARect
.
XMost
(
)
+
0
.
5f
mClipAARect
.
YMost
(
)
+
0
.
5f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC4
mSolidProgramClipBounds
clipData
mSolidProgramUniformState
.
mClipBounds
)
;
Array
<
float
4
>
colorData
=
{
color
.
b
color
.
g
color
.
r
color
.
a
}
;
Matrix
xform
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
if
(
aTransformed
)
{
xform
*
=
rectXform
;
}
Array
<
float
6
>
xformData
=
{
xform
.
_11
xform
.
_12
xform
.
_21
xform
.
_22
xform
.
_31
xform
.
_32
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC2
mSolidProgramTransform
xformData
mSolidProgramUniformState
.
mTransform
)
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC4
mSolidProgramColor
colorData
mSolidProgramUniformState
.
mColor
)
;
if
(
aVertexRange
)
{
DrawTriangles
(
*
aVertexRange
)
;
}
else
{
DrawQuad
(
)
;
}
success
=
true
;
break
;
}
case
PatternType
:
:
SURFACE
:
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
RefPtr
<
TextureHandle
>
handle
=
aHandle
?
aHandle
-
>
get
(
)
:
(
surfacePattern
.
mSurface
?
static_cast
<
TextureHandle
*
>
(
surfacePattern
.
mSurface
-
>
GetUserData
(
&
mTextureHandleKey
)
)
:
nullptr
)
;
IntSize
texSize
;
IntPoint
offset
;
SurfaceFormat
format
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
&
&
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
|
|
handle
-
>
GetSamplingRect
(
)
.
IsEqualEdges
(
surfacePattern
.
mSamplingRect
)
)
)
{
texSize
=
handle
-
>
GetSize
(
)
;
format
=
handle
-
>
GetFormat
(
)
;
offset
=
handle
-
>
GetSamplingOffset
(
)
;
}
else
{
handle
=
nullptr
;
if
(
!
surfacePattern
.
mSurface
)
{
break
;
}
texSize
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
format
=
surfacePattern
.
mSurface
-
>
GetFormat
(
)
;
if
(
!
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
)
{
texSize
=
surfacePattern
.
mSamplingRect
.
Size
(
)
;
offset
=
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
;
}
}
Matrix
invMatrix
=
surfacePattern
.
mMatrix
;
if
(
aVertexRange
&
&
!
aTransformed
)
{
invMatrix
*
=
currentTransform
;
}
if
(
!
invMatrix
.
Invert
(
)
)
{
break
;
}
if
(
aRectXform
)
{
invMatrix
.
PreMultiply
(
*
aRectXform
)
;
}
RefPtr
<
WebGLTexture
>
tex
;
IntRect
bounds
;
IntSize
backingSize
;
RefPtr
<
DataSourceSurface
>
data
;
if
(
handle
)
{
if
(
aForceUpdate
)
{
data
=
surfacePattern
.
mSurface
-
>
GetDataSurface
(
)
;
if
(
!
data
)
{
break
;
}
mUsedTextureMemory
-
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
UpdateSize
(
texSize
)
;
mUsedTextureMemory
+
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
SetSamplingOffset
(
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
)
;
}
handle
-
>
remove
(
)
;
mTextureHandles
.
insertFront
(
handle
)
;
}
else
if
(
(
tex
=
GetCompatibleSnapshot
(
surfacePattern
.
mSurface
)
)
)
{
backingSize
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
bounds
=
IntRect
(
offset
texSize
)
;
mCurrentTarget
-
>
mProfile
.
OnCacheHit
(
)
;
}
else
{
data
=
surfacePattern
.
mSurface
-
>
GetDataSurface
(
)
;
if
(
!
data
)
{
break
;
}
handle
=
AllocateTextureHandle
(
format
texSize
!
aForceUpdate
)
;
if
(
!
handle
)
{
MOZ_ASSERT
(
false
)
;
break
;
}
handle
-
>
SetSamplingOffset
(
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
)
;
if
(
aHandle
)
{
*
aHandle
=
handle
;
}
else
{
handle
-
>
SetSurface
(
surfacePattern
.
mSurface
)
;
surfacePattern
.
mSurface
-
>
AddUserData
(
&
mTextureHandleKey
handle
.
get
(
)
nullptr
)
;
}
}
SetBlendState
(
aOptions
.
mCompositionOp
format
!
=
SurfaceFormat
:
:
A8
?
aMaskColor
:
Nothing
(
)
)
;
if
(
mLastProgram
!
=
mImageProgram
)
{
mWebgl
-
>
UseProgram
(
mImageProgram
)
;
mLastProgram
=
mImageProgram
;
}
Array
<
float
2
>
viewportData
=
{
float
(
mViewportSize
.
width
)
float
(
mViewportSize
.
height
)
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramViewport
viewportData
mImageProgramUniformState
.
mViewport
)
;
Array
<
float
1
>
aaData
=
{
mLastCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
|
|
aVertexRange
?
0
.
0f
:
1
.
0f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT
mImageProgramAA
aaData
mImageProgramUniformState
.
mAA
)
;
Array
<
float
4
>
clipData
=
{
mClipAARect
.
x
-
0
.
5f
mClipAARect
.
y
-
0
.
5f
mClipAARect
.
XMost
(
)
+
0
.
5f
mClipAARect
.
YMost
(
)
+
0
.
5f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC4
mImageProgramClipBounds
clipData
mImageProgramUniformState
.
mClipBounds
)
;
DeviceColor
color
=
mLastCompositionOp
=
=
CompositionOp
:
:
OP_CLEAR
?
DeviceColor
(
1
1
1
1
)
:
PremultiplyColor
(
aMaskColor
&
&
format
!
=
SurfaceFormat
:
:
A8
?
DeviceColor
:
:
Mask
(
1
.
0f
aMaskColor
-
>
a
)
:
aMaskColor
.
valueOr
(
DeviceColor
(
1
1
1
1
)
)
aOptions
.
mAlpha
)
;
Array
<
float
4
>
colorData
=
{
color
.
b
color
.
g
color
.
r
color
.
a
}
;
Array
<
float
1
>
swizzleData
=
{
format
=
=
SurfaceFormat
:
:
A8
?
1
.
0f
:
0
.
0f
}
;
Matrix
xform
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
if
(
aTransformed
)
{
xform
*
=
rectXform
;
}
Array
<
float
6
>
xformData
=
{
xform
.
_11
xform
.
_12
xform
.
_21
xform
.
_22
xform
.
_31
xform
.
_32
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramTransform
xformData
mImageProgramUniformState
.
mTransform
)
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC4
mImageProgramColor
colorData
mImageProgramUniformState
.
mColor
)
;
MaybeUniformData
(
LOCAL_GL_FLOAT
mImageProgramSwizzle
swizzleData
mImageProgramUniformState
.
mSwizzle
)
;
BackingTexture
*
backing
=
nullptr
;
if
(
handle
)
{
backing
=
handle
-
>
GetBackingTexture
(
)
;
if
(
!
tex
)
{
tex
=
backing
-
>
GetWebGLTexture
(
)
;
}
bounds
=
handle
-
>
GetBounds
(
)
;
backingSize
=
backing
-
>
GetSize
(
)
;
}
if
(
mLastTexture
!
=
tex
)
{
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
tex
)
;
mLastTexture
=
tex
;
}
if
(
backing
&
&
!
backing
-
>
IsInitialized
(
)
)
{
backing
-
>
MarkInitialized
(
)
;
InitTexParameters
(
tex
)
;
if
(
texSize
!
=
backingSize
)
{
UploadSurface
(
nullptr
format
IntRect
(
IntPoint
(
)
backingSize
)
IntPoint
(
)
true
true
)
;
}
}
if
(
data
)
{
UploadSurface
(
data
format
IntRect
(
offset
texSize
)
bounds
.
TopLeft
(
)
texSize
=
=
backingSize
)
;
mCurrentTarget
-
>
mProfile
.
OnCacheMiss
(
)
;
}
else
{
mCurrentTarget
-
>
mProfile
.
OnCacheHit
(
)
;
}
Size
backingSizeF
(
backingSize
)
;
Matrix
uvMatrix
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
uvMatrix
*
=
invMatrix
;
uvMatrix
*
=
Matrix
(
1
.
0f
/
backingSizeF
.
width
0
.
0f
0
.
0f
1
.
0f
/
backingSizeF
.
height
float
(
bounds
.
x
-
offset
.
x
)
/
backingSizeF
.
width
float
(
bounds
.
y
-
offset
.
y
)
/
backingSizeF
.
height
)
;
Array
<
float
6
>
uvData
=
{
uvMatrix
.
_11
uvMatrix
.
_12
uvMatrix
.
_21
uvMatrix
.
_22
uvMatrix
.
_31
uvMatrix
.
_32
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramTexMatrix
uvData
mImageProgramUniformState
.
mTexMatrix
)
;
Array
<
float
4
>
texBounds
=
{
(
bounds
.
x
+
0
.
5f
)
/
backingSizeF
.
width
(
bounds
.
y
+
0
.
5f
)
/
backingSizeF
.
height
(
bounds
.
XMost
(
)
-
0
.
5f
)
/
backingSizeF
.
width
(
bounds
.
YMost
(
)
-
0
.
5f
)
/
backingSizeF
.
height
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC4
mImageProgramTexBounds
texBounds
mImageProgramUniformState
.
mTexBounds
)
;
if
(
UseNearestFilter
(
surfacePattern
)
)
{
SetTexFilter
(
tex
false
)
;
}
if
(
aVertexRange
)
{
DrawTriangles
(
*
aVertexRange
)
;
}
else
{
DrawQuad
(
)
;
}
if
(
UseNearestFilter
(
surfacePattern
)
)
{
SetTexFilter
(
tex
true
)
;
}
success
=
true
;
break
;
}
default
:
gfxWarning
(
)
<
<
"
Unknown
DrawTargetWebgl
:
:
DrawRect
pattern
type
:
"
<
<
(
int
)
aPattern
.
GetType
(
)
;
break
;
}
return
success
;
}
bool
SharedContextWebgl
:
:
RemoveSharedTexture
(
const
RefPtr
<
SharedTexture
>
&
aTexture
)
{
auto
pos
=
std
:
:
find
(
mSharedTextures
.
begin
(
)
mSharedTextures
.
end
(
)
aTexture
)
;
if
(
pos
=
=
mSharedTextures
.
end
(
)
)
{
return
false
;
}
size_t
maxBytes
=
StaticPrefs
:
:
gfx_canvas_accelerated_reserve_empty_cache
(
)
<
<
20
;
size_t
usedBytes
=
aTexture
-
>
UsedBytes
(
)
;
if
(
mEmptyTextureMemory
+
usedBytes
<
=
maxBytes
)
{
mEmptyTextureMemory
+
=
usedBytes
;
}
else
{
mTotalTextureMemory
-
=
usedBytes
;
mSharedTextures
.
erase
(
pos
)
;
ClearLastTexture
(
)
;
}
return
true
;
}
void
SharedTextureHandle
:
:
Cleanup
(
SharedContextWebgl
&
aContext
)
{
mTexture
-
>
Free
(
*
this
)
;
if
(
!
mTexture
-
>
HasAllocatedHandles
(
)
)
{
aContext
.
RemoveSharedTexture
(
mTexture
)
;
}
}
bool
SharedContextWebgl
:
:
RemoveStandaloneTexture
(
const
RefPtr
<
StandaloneTexture
>
&
aTexture
)
{
auto
pos
=
std
:
:
find
(
mStandaloneTextures
.
begin
(
)
mStandaloneTextures
.
end
(
)
aTexture
)
;
if
(
pos
=
=
mStandaloneTextures
.
end
(
)
)
{
return
false
;
}
mTotalTextureMemory
-
=
aTexture
-
>
UsedBytes
(
)
;
mStandaloneTextures
.
erase
(
pos
)
;
ClearLastTexture
(
)
;
return
true
;
}
void
StandaloneTexture
:
:
Cleanup
(
SharedContextWebgl
&
aContext
)
{
aContext
.
RemoveStandaloneTexture
(
this
)
;
}
void
SharedContextWebgl
:
:
PruneTextureHandle
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
aHandle
-
>
Invalidate
(
)
;
UnlinkSurfaceTexture
(
aHandle
)
;
if
(
RefPtr
<
CacheEntry
>
entry
=
aHandle
-
>
GetCacheEntry
(
)
)
{
entry
-
>
Unlink
(
)
;
}
mUsedTextureMemory
-
=
aHandle
-
>
UsedBytes
(
)
;
aHandle
-
>
Cleanup
(
*
this
)
;
}
bool
SharedContextWebgl
:
:
PruneTextureMemory
(
size_t
aMargin
bool
aPruneUnused
)
{
size_t
maxBytes
=
StaticPrefs
:
:
gfx_canvas_accelerated_cache_size
(
)
<
<
20
;
maxBytes
-
=
std
:
:
min
(
maxBytes
aMargin
)
;
size_t
maxItems
=
StaticPrefs
:
:
gfx_canvas_accelerated_cache_items
(
)
;
size_t
oldItems
=
mNumTextureHandles
;
while
(
!
mTextureHandles
.
isEmpty
(
)
&
&
(
mUsedTextureMemory
>
maxBytes
|
|
mNumTextureHandles
>
maxItems
|
|
(
aPruneUnused
&
&
!
mTextureHandles
.
getLast
(
)
-
>
IsUsed
(
)
)
)
)
{
PruneTextureHandle
(
mTextureHandles
.
popLast
(
)
)
;
-
-
mNumTextureHandles
;
}
return
mNumTextureHandles
<
oldItems
;
}
Maybe
<
SurfacePattern
>
DrawTargetWebgl
:
:
LinearGradientToSurface
(
const
RectDouble
&
aBounds
const
Pattern
&
aPattern
)
{
MOZ_ASSERT
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
LINEAR_GRADIENT
)
;
const
auto
&
gradient
=
static_cast
<
const
LinearGradientPattern
&
>
(
aPattern
)
;
Point
gradBegin
=
gradient
.
mMatrix
.
TransformPoint
(
gradient
.
mBegin
)
;
Point
gradEnd
=
gradient
.
mMatrix
.
TransformPoint
(
gradient
.
mEnd
)
;
Point
begin
=
mTransform
.
TransformPoint
(
gradBegin
)
;
Point
end
=
mTransform
.
TransformPoint
(
gradEnd
)
;
Point
dir
=
end
-
begin
;
float
len
=
dir
.
Length
(
)
;
dir
=
dir
/
len
;
Rect
visBounds
=
NarrowToFloat
(
aBounds
.
SafeIntersect
(
RectDouble
(
GetRect
(
)
)
)
)
;
float
dist0
=
(
visBounds
.
TopLeft
(
)
-
begin
)
.
DotProduct
(
dir
)
;
float
distX
=
visBounds
.
width
*
dir
.
x
;
float
distY
=
visBounds
.
height
*
dir
.
y
;
float
minDist
=
floorf
(
std
:
:
max
(
dist0
+
std
:
:
min
(
distX
0
.
0f
)
+
std
:
:
min
(
distY
0
.
0f
)
0
.
0f
)
)
;
float
maxDist
=
ceilf
(
std
:
:
min
(
dist0
+
std
:
:
max
(
distX
0
.
0f
)
+
std
:
:
max
(
distY
0
.
0f
)
len
)
)
;
float
subLen
=
maxDist
-
minDist
;
if
(
subLen
>
0
&
&
subLen
<
0
.
5f
*
visBounds
.
Area
(
)
)
{
RefPtr
<
DrawTargetSkia
>
dt
=
new
DrawTargetSkia
;
if
(
dt
-
>
Init
(
IntSize
(
int32_t
(
subLen
+
2
)
1
)
SurfaceFormat
:
:
B8G8R8A8
)
)
{
dt
-
>
FillRect
(
Rect
(
dt
-
>
GetRect
(
)
)
LinearGradientPattern
(
Point
(
1
-
minDist
0
.
0f
)
Point
(
len
+
1
-
minDist
0
.
0f
)
gradient
.
mStops
)
)
;
if
(
RefPtr
<
SourceSurface
>
snapshot
=
dt
-
>
Snapshot
(
)
)
{
Point
gradDir
=
(
gradEnd
-
gradBegin
)
/
len
;
Point
tangent
=
Point
(
-
gradDir
.
y
gradDir
.
x
)
/
gradDir
.
Length
(
)
;
SurfacePattern
surfacePattern
(
snapshot
ExtendMode
:
:
CLAMP
Matrix
(
gradDir
.
x
gradDir
.
y
tangent
.
x
tangent
.
y
gradBegin
.
x
gradBegin
.
y
)
.
PreTranslate
(
minDist
-
1
0
)
)
;
if
(
SupportsPattern
(
surfacePattern
)
)
{
return
Some
(
surfacePattern
)
;
}
}
}
}
return
Nothing
(
)
;
}
void
DrawTargetWebgl
:
:
FillRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
RectDouble
xformRect
=
TransformDouble
(
aRect
)
;
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
)
{
if
(
Maybe
<
Rect
>
clipped
=
RectClippedToViewport
(
xformRect
)
)
{
DrawRect
(
*
clipped
aPattern
aOptions
Nothing
(
)
nullptr
false
)
;
return
;
}
}
if
(
RectInsidePrecisionLimits
(
xformRect
)
)
{
if
(
SupportsPattern
(
aPattern
)
)
{
DrawRect
(
aRect
aPattern
aOptions
)
;
return
;
}
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
LINEAR_GRADIENT
)
{
if
(
Maybe
<
SurfacePattern
>
surface
=
LinearGradientToSurface
(
xformRect
aPattern
)
)
{
if
(
DrawRect
(
aRect
*
surface
aOptions
Nothing
(
)
nullptr
true
true
true
)
)
{
return
;
}
}
}
}
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
else
{
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
aRect
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
DrawPath
(
path
aPattern
aOptions
)
;
}
}
void
CacheEntry
:
:
Link
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
mHandle
=
aHandle
;
mHandle
-
>
SetCacheEntry
(
this
)
;
}
void
CacheEntry
:
:
Unlink
(
)
{
if
(
mHandle
)
{
mHandle
-
>
SetCacheEntry
(
nullptr
)
;
mHandle
=
nullptr
;
}
RemoveFromList
(
)
;
}
HashNumber
PathCacheEntry
:
:
HashPath
(
const
QuantizedPath
&
aPath
const
Pattern
*
aPattern
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
)
{
HashNumber
hash
=
0
;
hash
=
AddToHash
(
hash
aPath
.
mPath
.
num_types
)
;
hash
=
AddToHash
(
hash
aPath
.
mPath
.
num_points
)
;
if
(
aPath
.
mPath
.
num_points
>
0
)
{
hash
=
AddToHash
(
hash
aPath
.
mPath
.
points
[
0
]
.
x
)
;
hash
=
AddToHash
(
hash
aPath
.
mPath
.
points
[
0
]
.
y
)
;
if
(
aPath
.
mPath
.
num_points
>
1
)
{
hash
=
AddToHash
(
hash
aPath
.
mPath
.
points
[
1
]
.
x
)
;
hash
=
AddToHash
(
hash
aPath
.
mPath
.
points
[
1
]
.
y
)
;
}
}
IntPoint
offset
=
RoundedToInt
(
(
aOrigin
-
Point
(
aBounds
.
TopLeft
(
)
)
)
*
16
.
0f
)
;
hash
=
AddToHash
(
hash
offset
.
x
)
;
hash
=
AddToHash
(
hash
offset
.
y
)
;
hash
=
AddToHash
(
hash
aBounds
.
width
)
;
hash
=
AddToHash
(
hash
aBounds
.
height
)
;
if
(
aPattern
)
{
hash
=
AddToHash
(
hash
(
int
)
aPattern
-
>
GetType
(
)
)
;
}
return
hash
;
}
static
inline
bool
HasMatchingScale
(
const
Matrix
&
aTransform1
const
Matrix
&
aTransform2
)
{
return
FuzzyEqual
(
aTransform1
.
_11
aTransform2
.
_11
)
&
&
FuzzyEqual
(
aTransform1
.
_12
aTransform2
.
_12
)
&
&
FuzzyEqual
(
aTransform1
.
_21
aTransform2
.
_21
)
&
&
FuzzyEqual
(
aTransform1
.
_22
aTransform2
.
_22
)
;
}
inline
bool
PathCacheEntry
:
:
MatchesPath
(
const
QuantizedPath
&
aPath
const
Pattern
*
aPattern
const
StrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
HashNumber
aHash
float
aSigma
)
{
return
aHash
=
=
mHash
&
&
HasMatchingScale
(
aTransform
mTransform
)
&
&
aBounds
.
x
-
aOrigin
.
x
>
=
mBounds
.
x
-
mOrigin
.
x
&
&
(
aBounds
.
x
-
aOrigin
.
x
)
+
aBounds
.
width
<
=
(
mBounds
.
x
-
mOrigin
.
x
)
+
mBounds
.
width
&
&
aBounds
.
y
-
aOrigin
.
y
>
=
mBounds
.
y
-
mOrigin
.
y
&
&
(
aBounds
.
y
-
aOrigin
.
y
)
+
aBounds
.
height
<
=
(
mBounds
.
y
-
mOrigin
.
y
)
+
mBounds
.
height
&
&
aPath
=
=
mPath
&
&
(
!
aPattern
?
!
mPattern
:
mPattern
&
&
*
aPattern
=
=
*
mPattern
)
&
&
(
!
aStrokeOptions
?
!
mStrokeOptions
:
mStrokeOptions
&
&
*
aStrokeOptions
=
=
*
mStrokeOptions
)
&
&
aSigma
=
=
mSigma
;
}
PathCacheEntry
:
:
PathCacheEntry
(
QuantizedPath
&
&
aPath
Pattern
*
aPattern
StoredStrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
HashNumber
aHash
float
aSigma
)
:
CacheEntryImpl
<
PathCacheEntry
>
(
aTransform
aBounds
aHash
)
mPath
(
std
:
:
move
(
aPath
)
)
mOrigin
(
aOrigin
)
mPattern
(
aPattern
)
mStrokeOptions
(
aStrokeOptions
)
mSigma
(
aSigma
)
{
}
already_AddRefed
<
PathCacheEntry
>
PathCache
:
:
FindOrInsertEntry
(
QuantizedPath
aPath
const
Pattern
*
aPattern
const
StrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
float
aSigma
)
{
HashNumber
hash
=
PathCacheEntry
:
:
HashPath
(
aPath
aPattern
aTransform
aBounds
aOrigin
)
;
for
(
const
RefPtr
<
PathCacheEntry
>
&
entry
:
GetChain
(
hash
)
)
{
if
(
entry
-
>
MatchesPath
(
aPath
aPattern
aStrokeOptions
aTransform
aBounds
aOrigin
hash
aSigma
)
)
{
return
do_AddRef
(
entry
)
;
}
}
Pattern
*
pattern
=
nullptr
;
if
(
aPattern
)
{
pattern
=
aPattern
-
>
CloneWeak
(
)
;
if
(
!
pattern
)
{
return
nullptr
;
}
}
StoredStrokeOptions
*
strokeOptions
=
nullptr
;
if
(
aStrokeOptions
)
{
strokeOptions
=
aStrokeOptions
-
>
Clone
(
)
;
if
(
!
strokeOptions
)
{
return
nullptr
;
}
}
RefPtr
<
PathCacheEntry
>
entry
=
new
PathCacheEntry
(
std
:
:
move
(
aPath
)
pattern
strokeOptions
aTransform
aBounds
aOrigin
hash
aSigma
)
;
Insert
(
entry
)
;
return
entry
.
forget
(
)
;
}
void
DrawTargetWebgl
:
:
Fill
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
!
aPath
|
|
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
SkPath
&
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
-
>
GetPath
(
)
;
SkRect
skiaRect
=
SkRect
:
:
MakeEmpty
(
)
;
if
(
skiaPath
.
isRect
(
&
skiaRect
)
)
{
RectDouble
rect
=
SkRectToRectDouble
(
skiaRect
)
;
RectDouble
xformRect
=
TransformDouble
(
rect
)
;
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
)
{
if
(
Maybe
<
Rect
>
clipped
=
RectClippedToViewport
(
xformRect
)
)
{
DrawRect
(
*
clipped
aPattern
aOptions
Nothing
(
)
nullptr
false
)
;
return
;
}
}
if
(
RectInsidePrecisionLimits
(
xformRect
)
)
{
if
(
SupportsPattern
(
aPattern
)
)
{
DrawRect
(
NarrowToFloat
(
rect
)
aPattern
aOptions
)
;
return
;
}
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
LINEAR_GRADIENT
)
{
if
(
Maybe
<
SurfacePattern
>
surface
=
LinearGradientToSurface
(
xformRect
aPattern
)
)
{
if
(
DrawRect
(
NarrowToFloat
(
rect
)
*
surface
aOptions
Nothing
(
)
nullptr
true
true
true
)
)
{
return
;
}
}
}
}
}
DrawPath
(
aPath
aPattern
aOptions
)
;
}
void
DrawTargetWebgl
:
:
FillCircle
(
const
Point
&
aOrigin
float
aRadius
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
DrawCircle
(
aOrigin
aRadius
aPattern
aOptions
)
;
}
QuantizedPath
:
:
QuantizedPath
(
const
WGR
:
:
Path
&
aPath
)
:
mPath
(
aPath
)
{
}
QuantizedPath
:
:
QuantizedPath
(
QuantizedPath
&
&
aPath
)
noexcept
:
mPath
(
aPath
.
mPath
)
{
aPath
.
mPath
.
points
=
nullptr
;
aPath
.
mPath
.
num_points
=
0
;
aPath
.
mPath
.
types
=
nullptr
;
aPath
.
mPath
.
num_types
=
0
;
}
QuantizedPath
:
:
~
QuantizedPath
(
)
{
if
(
mPath
.
points
|
|
mPath
.
types
)
{
WGR
:
:
wgr_path_release
(
mPath
)
;
}
}
bool
QuantizedPath
:
:
operator
=
=
(
const
QuantizedPath
&
aOther
)
const
{
return
mPath
.
num_types
=
=
aOther
.
mPath
.
num_types
&
&
mPath
.
num_points
=
=
aOther
.
mPath
.
num_points
&
&
mPath
.
fill_mode
=
=
aOther
.
mPath
.
fill_mode
&
&
!
memcmp
(
mPath
.
types
aOther
.
mPath
.
types
mPath
.
num_types
*
sizeof
(
uint8_t
)
)
&
&
!
memcmp
(
mPath
.
points
aOther
.
mPath
.
points
mPath
.
num_points
*
sizeof
(
WGR
:
:
Point
)
)
;
}
static
Maybe
<
QuantizedPath
>
GenerateQuantizedPath
(
WGR
:
:
PathBuilder
*
aPathBuilder
const
SkPath
&
aPath
const
Rect
&
aBounds
const
Matrix
&
aTransform
)
{
if
(
!
aPathBuilder
)
{
return
Nothing
(
)
;
}
WGR
:
:
wgr_builder_reset
(
aPathBuilder
)
;
WGR
:
:
wgr_builder_set_fill_mode
(
aPathBuilder
aPath
.
getFillType
(
)
=
=
SkPathFillType
:
:
kWinding
?
WGR
:
:
FillMode
:
:
Winding
:
WGR
:
:
FillMode
:
:
EvenOdd
)
;
SkPath
:
:
RawIter
iter
(
aPath
)
;
SkPoint
params
[
4
]
;
SkPath
:
:
Verb
currentVerb
;
Matrix
transform
=
aTransform
;
transform
.
PostTranslate
(
-
aBounds
.
TopLeft
(
)
)
;
while
(
(
currentVerb
=
iter
.
next
(
params
)
)
!
=
SkPath
:
:
kDone_Verb
)
{
switch
(
currentVerb
)
{
case
SkPath
:
:
kMove_Verb
:
{
Point
p0
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
0
]
)
)
;
WGR
:
:
wgr_builder_move_to
(
aPathBuilder
p0
.
x
p0
.
y
)
;
break
;
}
case
SkPath
:
:
kLine_Verb
:
{
Point
p1
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
1
]
)
)
;
WGR
:
:
wgr_builder_line_to
(
aPathBuilder
p1
.
x
p1
.
y
)
;
break
;
}
case
SkPath
:
:
kCubic_Verb
:
{
Point
p1
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
1
]
)
)
;
Point
p2
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
2
]
)
)
;
Point
p3
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
3
]
)
)
;
WGR
:
:
wgr_builder_curve_to
(
aPathBuilder
p1
.
x
p1
.
y
p2
.
x
p2
.
y
p3
.
x
p3
.
y
)
;
break
;
}
case
SkPath
:
:
kQuad_Verb
:
{
Point
p1
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
1
]
)
)
;
Point
p2
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
2
]
)
)
;
WGR
:
:
wgr_builder_quad_to
(
aPathBuilder
p1
.
x
p1
.
y
p2
.
x
p2
.
y
)
;
break
;
}
case
SkPath
:
:
kConic_Verb
:
{
Point
p0
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
0
]
)
)
;
Point
p1
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
1
]
)
)
;
Point
p2
=
transform
.
TransformPoint
(
SkPointToPoint
(
params
[
2
]
)
)
;
float
w
=
iter
.
conicWeight
(
)
;
std
:
:
vector
<
Point
>
quads
;
int
numQuads
=
ConvertConicToQuads
(
p0
p1
p2
w
quads
)
;
for
(
int
i
=
0
;
i
<
numQuads
;
i
+
+
)
{
Point
q1
=
quads
[
2
*
i
+
1
]
;
Point
q2
=
quads
[
2
*
i
+
2
]
;
WGR
:
:
wgr_builder_quad_to
(
aPathBuilder
q1
.
x
q1
.
y
q2
.
x
q2
.
y
)
;
}
break
;
}
case
SkPath
:
:
kClose_Verb
:
WGR
:
:
wgr_builder_close
(
aPathBuilder
)
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
return
Nothing
(
)
;
}
}
WGR
:
:
Path
p
=
WGR
:
:
wgr_builder_get_path
(
aPathBuilder
)
;
if
(
!
p
.
num_points
|
|
!
p
.
num_types
)
{
WGR
:
:
wgr_path_release
(
p
)
;
return
Nothing
(
)
;
}
return
Some
(
QuantizedPath
(
p
)
)
;
}
static
Maybe
<
WGR
:
:
VertexBuffer
>
GeneratePathVertexBuffer
(
const
QuantizedPath
&
aPath
const
IntRect
&
aClipRect
bool
aRasterizationTruncates
WGR
:
:
OutputVertex
*
aBuffer
size_t
aBufferCapacity
)
{
WGR
:
:
VertexBuffer
vb
=
WGR
:
:
wgr_path_rasterize_to_tri_list
(
&
aPath
.
mPath
aClipRect
.
x
aClipRect
.
y
aClipRect
.
width
aClipRect
.
height
true
false
aRasterizationTruncates
aBuffer
aBufferCapacity
)
;
if
(
!
vb
.
len
|
|
(
aBuffer
&
&
vb
.
len
>
aBufferCapacity
)
)
{
WGR
:
:
wgr_vertex_buffer_release
(
vb
)
;
return
Nothing
(
)
;
}
return
Some
(
vb
)
;
}
static
inline
AAStroke
:
:
LineJoin
ToAAStrokeLineJoin
(
JoinStyle
aJoin
)
{
switch
(
aJoin
)
{
case
JoinStyle
:
:
BEVEL
:
return
AAStroke
:
:
LineJoin
:
:
Bevel
;
case
JoinStyle
:
:
ROUND
:
return
AAStroke
:
:
LineJoin
:
:
Round
;
case
JoinStyle
:
:
MITER
:
case
JoinStyle
:
:
MITER_OR_BEVEL
:
return
AAStroke
:
:
LineJoin
:
:
Miter
;
}
return
AAStroke
:
:
LineJoin
:
:
Miter
;
}
static
inline
AAStroke
:
:
LineCap
ToAAStrokeLineCap
(
CapStyle
aCap
)
{
switch
(
aCap
)
{
case
CapStyle
:
:
BUTT
:
return
AAStroke
:
:
LineCap
:
:
Butt
;
case
CapStyle
:
:
ROUND
:
return
AAStroke
:
:
LineCap
:
:
Round
;
case
CapStyle
:
:
SQUARE
:
return
AAStroke
:
:
LineCap
:
:
Square
;
}
return
AAStroke
:
:
LineCap
:
:
Butt
;
}
static
inline
Point
WGRPointToPoint
(
const
WGR
:
:
Point
&
aPoint
)
{
return
Point
(
IntPoint
(
aPoint
.
x
aPoint
.
y
)
)
*
(
1
.
0f
/
16
.
0f
)
;
}
static
Maybe
<
AAStroke
:
:
VertexBuffer
>
GenerateStrokeVertexBuffer
(
const
QuantizedPath
&
aPath
const
StrokeOptions
*
aStrokeOptions
float
aScale
WGR
:
:
OutputVertex
*
aBuffer
size_t
aBufferCapacity
)
{
AAStroke
:
:
StrokeStyle
style
=
{
aStrokeOptions
-
>
mLineWidth
*
aScale
ToAAStrokeLineCap
(
aStrokeOptions
-
>
mLineCap
)
ToAAStrokeLineJoin
(
aStrokeOptions
-
>
mLineJoin
)
aStrokeOptions
-
>
mMiterLimit
}
;
if
(
style
.
width
<
=
0
.
0f
|
|
!
std
:
:
isfinite
(
style
.
width
)
|
|
style
.
miter_limit
<
=
0
.
0f
|
|
!
std
:
:
isfinite
(
style
.
miter_limit
)
)
{
return
Nothing
(
)
;
}
AAStroke
:
:
Stroker
*
s
=
AAStroke
:
:
aa_stroke_new
(
&
style
(
AAStroke
:
:
OutputVertex
*
)
aBuffer
aBufferCapacity
)
;
bool
valid
=
true
;
size_t
curPoint
=
0
;
for
(
size_t
curType
=
0
;
valid
&
&
curType
<
aPath
.
mPath
.
num_types
;
)
{
if
(
(
aPath
.
mPath
.
types
[
curType
]
&
WGR
:
:
PathPointTypePathTypeMask
)
!
=
WGR
:
:
PathPointTypeStart
)
{
valid
=
false
;
break
;
}
size_t
endType
=
curType
+
1
;
for
(
;
endType
<
aPath
.
mPath
.
num_types
;
endType
+
+
)
{
if
(
(
aPath
.
mPath
.
types
[
endType
]
&
WGR
:
:
PathPointTypePathTypeMask
)
=
=
WGR
:
:
PathPointTypeStart
)
{
break
;
}
}
bool
closed
=
(
aPath
.
mPath
.
types
[
endType
-
1
]
&
WGR
:
:
PathPointTypeCloseSubpath
)
!
=
0
;
for
(
;
curType
<
endType
;
curType
+
+
)
{
bool
end
=
curType
+
1
=
=
endType
&
&
!
closed
;
switch
(
aPath
.
mPath
.
types
[
curType
]
&
WGR
:
:
PathPointTypePathTypeMask
)
{
case
WGR
:
:
PathPointTypeStart
:
{
if
(
curPoint
+
1
>
aPath
.
mPath
.
num_points
)
{
valid
=
false
;
break
;
}
Point
p1
=
WGRPointToPoint
(
aPath
.
mPath
.
points
[
curPoint
]
)
;
AAStroke
:
:
aa_stroke_move_to
(
s
p1
.
x
p1
.
y
closed
)
;
if
(
end
)
{
AAStroke
:
:
aa_stroke_line_to
(
s
p1
.
x
p1
.
y
true
)
;
}
curPoint
+
+
;
break
;
}
case
WGR
:
:
PathPointTypeLine
:
{
if
(
curPoint
+
1
>
aPath
.
mPath
.
num_points
)
{
valid
=
false
;
break
;
}
Point
p1
=
WGRPointToPoint
(
aPath
.
mPath
.
points
[
curPoint
]
)
;
AAStroke
:
:
aa_stroke_line_to
(
s
p1
.
x
p1
.
y
end
)
;
curPoint
+
+
;
break
;
}
case
WGR
:
:
PathPointTypeBezier
:
{
if
(
curPoint
+
3
>
aPath
.
mPath
.
num_points
)
{
valid
=
false
;
break
;
}
Point
p1
=
WGRPointToPoint
(
aPath
.
mPath
.
points
[
curPoint
]
)
;
Point
p2
=
WGRPointToPoint
(
aPath
.
mPath
.
points
[
curPoint
+
1
]
)
;
Point
p3
=
WGRPointToPoint
(
aPath
.
mPath
.
points
[
curPoint
+
2
]
)
;
AAStroke
:
:
aa_stroke_curve_to
(
s
p1
.
x
p1
.
y
p2
.
x
p2
.
y
p3
.
x
p3
.
y
end
)
;
curPoint
+
=
3
;
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
WGR
path
point
type
"
)
;
valid
=
false
;
break
;
}
}
if
(
valid
&
&
closed
)
{
AAStroke
:
:
aa_stroke_close
(
s
)
;
}
}
Maybe
<
AAStroke
:
:
VertexBuffer
>
result
;
if
(
valid
)
{
AAStroke
:
:
VertexBuffer
vb
=
AAStroke
:
:
aa_stroke_finish
(
s
)
;
if
(
!
vb
.
len
|
|
(
aBuffer
&
&
vb
.
len
>
aBufferCapacity
)
)
{
AAStroke
:
:
aa_stroke_vertex_buffer_release
(
vb
)
;
}
else
{
result
=
Some
(
vb
)
;
}
}
AAStroke
:
:
aa_stroke_release
(
s
)
;
return
result
;
}
void
PathCache
:
:
ClearVertexRanges
(
)
{
for
(
auto
&
chain
:
mChains
)
{
PathCacheEntry
*
entry
=
chain
.
getFirst
(
)
;
while
(
entry
)
{
PathCacheEntry
*
next
=
entry
-
>
getNext
(
)
;
if
(
entry
-
>
GetVertexRange
(
)
.
IsValid
(
)
)
{
entry
-
>
Unlink
(
)
;
}
entry
=
next
;
}
}
}
inline
bool
DrawTargetWebgl
:
:
ShouldAccelPath
(
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
)
{
return
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
&
&
PrepareContext
(
)
;
}
enum
class
AAStrokeMode
{
Unsupported
Geometry
Mask
}
;
static
inline
AAStrokeMode
SupportsAAStroke
(
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
&
aStrokeOptions
bool
aAllowStrokeAlpha
)
{
if
(
aStrokeOptions
.
mDashPattern
)
{
return
AAStrokeMode
:
:
Unsupported
;
}
switch
(
aOptions
.
mCompositionOp
)
{
case
CompositionOp
:
:
OP_SOURCE
:
return
AAStrokeMode
:
:
Geometry
;
case
CompositionOp
:
:
OP_OVER
:
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
)
{
return
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
.
a
*
aOptions
.
mAlpha
<
1
.
0f
&
&
!
aAllowStrokeAlpha
?
AAStrokeMode
:
:
Mask
:
AAStrokeMode
:
:
Geometry
;
}
return
AAStrokeMode
:
:
Unsupported
;
default
:
return
AAStrokeMode
:
:
Unsupported
;
}
}
already_AddRefed
<
TextureHandle
>
SharedContextWebgl
:
:
DrawStrokeMask
(
const
PathVertexRange
&
aVertexRange
const
IntSize
&
aSize
)
{
RefPtr
<
TextureHandle
>
handle
=
AllocateTextureHandle
(
SurfaceFormat
:
:
A8
aSize
true
true
)
;
if
(
!
handle
)
{
return
nullptr
;
}
IntRect
texBounds
=
handle
-
>
GetBounds
(
)
;
BackingTexture
*
backing
=
handle
-
>
GetBackingTexture
(
)
;
if
(
!
backing
-
>
IsInitialized
(
)
)
{
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
backing
-
>
GetWebGLTexture
(
)
)
;
mWebgl
-
>
TexStorage
(
LOCAL_GL_TEXTURE_2D
1
LOCAL_GL_R8
{
uint32_t
(
backing
-
>
GetSize
(
)
.
width
)
uint32_t
(
backing
-
>
GetSize
(
)
.
height
)
1
}
)
;
InitTexParameters
(
backing
-
>
GetWebGLTexture
(
)
)
;
ClearLastTexture
(
)
;
}
if
(
!
mScratchFramebuffer
)
{
mScratchFramebuffer
=
mWebgl
-
>
CreateFramebuffer
(
)
;
}
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mScratchFramebuffer
)
;
webgl
:
:
FbAttachInfo
attachInfo
;
attachInfo
.
tex
=
backing
-
>
GetWebGLTexture
(
)
;
mWebgl
-
>
FramebufferAttach
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_COLOR_ATTACHMENT0
LOCAL_GL_TEXTURE_2D
attachInfo
)
;
mWebgl
-
>
Viewport
(
texBounds
.
x
texBounds
.
y
texBounds
.
width
texBounds
.
height
)
;
EnableScissor
(
texBounds
)
;
if
(
!
backing
-
>
IsInitialized
(
)
)
{
backing
-
>
MarkInitialized
(
)
;
}
else
{
mWebgl
-
>
ClearColor
(
0
.
0f
0
.
0f
0
.
0f
0
.
0f
)
;
mWebgl
-
>
Clear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
}
SetBlendState
(
CompositionOp
:
:
OP_OVER
)
;
if
(
mLastProgram
!
=
mSolidProgram
)
{
mWebgl
-
>
UseProgram
(
mSolidProgram
)
;
mLastProgram
=
mSolidProgram
;
}
Array
<
float
2
>
viewportData
=
{
float
(
texBounds
.
width
)
float
(
texBounds
.
height
)
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC2
mSolidProgramViewport
viewportData
mSolidProgramUniformState
.
mViewport
)
;
Array
<
float
1
>
aaData
=
{
0
.
0f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT
mSolidProgramAA
aaData
mSolidProgramUniformState
.
mAA
)
;
Array
<
float
4
>
clipData
=
{
-
0
.
5f
-
0
.
5f
float
(
texBounds
.
width
)
+
0
.
5f
float
(
texBounds
.
height
)
+
0
.
5f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC4
mSolidProgramClipBounds
clipData
mSolidProgramUniformState
.
mClipBounds
)
;
Array
<
float
4
>
colorData
=
{
1
.
0f
1
.
0f
1
.
0f
1
.
0f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC4
mSolidProgramColor
colorData
mSolidProgramUniformState
.
mColor
)
;
Array
<
float
6
>
xformData
=
{
1
.
0f
0
.
0f
0
.
0f
1
.
0f
0
.
0f
0
.
0f
}
;
MaybeUniformData
(
LOCAL_GL_FLOAT_VEC2
mSolidProgramTransform
xformData
mSolidProgramUniformState
.
mTransform
)
;
RefPtr
<
WebGLTexture
>
prevClipMask
=
mLastClipMask
;
SetNoClipMask
(
)
;
DrawTriangles
(
aVertexRange
)
;
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mCurrentTarget
-
>
mFramebuffer
)
;
mWebgl
-
>
Viewport
(
0
0
mViewportSize
.
width
mViewportSize
.
height
)
;
if
(
prevClipMask
)
{
SetClipMask
(
prevClipMask
)
;
}
return
handle
.
forget
(
)
;
}
bool
SharedContextWebgl
:
:
DrawPathAccel
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
bool
aAllowStrokeAlpha
const
ShadowOptions
*
aShadow
bool
aCacheable
const
Matrix
*
aPathXform
)
{
const
PathSkia
*
pathSkia
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
;
const
Matrix
&
currentTransform
=
mCurrentTarget
-
>
GetTransform
(
)
;
Matrix
pathXform
=
currentTransform
;
if
(
aPathXform
)
{
pathXform
.
PreMultiply
(
*
aPathXform
)
;
}
Rect
bounds
=
pathSkia
-
>
GetFastBounds
(
pathXform
aStrokeOptions
)
;
if
(
bounds
.
IsEmpty
(
)
)
{
return
true
;
}
IntRect
viewport
(
IntPoint
(
)
mViewportSize
)
;
if
(
aShadow
)
{
bounds
+
=
aShadow
-
>
mOffset
;
int32_t
blurRadius
=
aShadow
-
>
BlurRadius
(
)
;
bounds
.
Inflate
(
blurRadius
)
;
viewport
.
Inflate
(
blurRadius
)
;
}
Point
realOrigin
=
bounds
.
TopLeft
(
)
;
if
(
aCacheable
)
{
bounds
.
Scale
(
4
.
0f
)
;
bounds
.
Round
(
)
;
bounds
.
Scale
(
0
.
25f
)
;
}
Point
quantizedOrigin
=
bounds
.
TopLeft
(
)
;
IntRect
intBounds
=
RoundedOut
(
bounds
)
.
Intersect
(
viewport
)
;
if
(
intBounds
.
IsEmpty
(
)
)
{
return
true
;
}
Rect
quantBounds
=
Rect
(
intBounds
)
+
(
realOrigin
-
quantizedOrigin
)
;
Maybe
<
DeviceColor
>
color
=
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_CLEAR
?
Some
(
DeviceColor
(
1
1
1
1
)
)
:
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
?
Some
(
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
)
:
Nothing
(
)
)
;
RefPtr
<
PathCacheEntry
>
entry
;
RefPtr
<
TextureHandle
>
handle
;
if
(
aCacheable
)
{
if
(
!
mPathCache
)
{
mPathCache
=
MakeUnique
<
PathCache
>
(
)
;
}
Maybe
<
QuantizedPath
>
qp
=
GenerateQuantizedPath
(
mWGRPathBuilder
pathSkia
-
>
GetPath
(
)
quantBounds
pathXform
)
;
if
(
!
qp
)
{
return
false
;
}
entry
=
mPathCache
-
>
FindOrInsertEntry
(
std
:
:
move
(
*
qp
)
color
?
nullptr
:
&
aPattern
aStrokeOptions
currentTransform
intBounds
quantizedOrigin
aShadow
?
aShadow
-
>
mSigma
:
-
1
.
0f
)
;
if
(
!
entry
)
{
return
false
;
}
handle
=
entry
-
>
GetHandle
(
)
;
}
Maybe
<
DeviceColor
>
shadowColor
=
color
;
if
(
aShadow
&
&
aOptions
.
mCompositionOp
!
=
CompositionOp
:
:
OP_CLEAR
)
{
shadowColor
=
Some
(
aShadow
-
>
mColor
)
;
if
(
color
)
{
shadowColor
-
>
a
*
=
color
-
>
a
;
}
}
SamplingFilter
filter
=
aShadow
?
SamplingFilter
:
:
GOOD
:
GetSamplingFilter
(
aPattern
)
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
)
{
Point
offset
=
(
realOrigin
-
entry
-
>
GetOrigin
(
)
)
+
entry
-
>
GetBounds
(
)
.
TopLeft
(
)
;
SurfacePattern
pathPattern
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
offset
)
filter
)
;
return
DrawRectAccel
(
quantBounds
pathPattern
aOptions
shadowColor
&
handle
false
true
true
)
;
}
if
(
mPathVertexCapacity
>
0
&
&
!
handle
&
&
entry
&
&
!
aShadow
&
&
aOptions
.
mAntialiasMode
!
=
AntialiasMode
:
:
NONE
&
&
SupportsPattern
(
aPattern
)
&
&
entry
-
>
GetPath
(
)
.
mPath
.
num_types
<
=
mPathMaxComplexity
)
{
if
(
entry
-
>
GetVertexRange
(
)
.
IsValid
(
)
)
{
mCurrentTarget
-
>
mProfile
.
OnCacheHit
(
)
;
return
DrawRectAccel
(
Rect
(
intBounds
.
TopLeft
(
)
Size
(
1
1
)
)
aPattern
aOptions
Nothing
(
)
nullptr
false
true
true
false
nullptr
&
entry
-
>
GetVertexRange
(
)
)
;
}
WGR
:
:
OutputVertex
*
outputBuffer
=
nullptr
;
size_t
outputBufferCapacity
=
0
;
if
(
mWGROutputBuffer
)
{
outputBuffer
=
mWGROutputBuffer
.
get
(
)
;
outputBufferCapacity
=
mPathVertexCapacity
/
sizeof
(
WGR
:
:
OutputVertex
)
;
}
Maybe
<
WGR
:
:
VertexBuffer
>
wgrVB
;
Maybe
<
AAStroke
:
:
VertexBuffer
>
strokeVB
;
if
(
!
aStrokeOptions
)
{
if
(
aPath
=
=
mUnitCirclePath
)
{
auto
scaleFactors
=
pathXform
.
ScaleFactors
(
)
;
if
(
scaleFactors
.
AreScalesSame
(
)
)
{
Point
center
=
pathXform
.
GetTranslation
(
)
-
quantBounds
.
TopLeft
(
)
;
float
radius
=
scaleFactors
.
xScale
;
AAStroke
:
:
VertexBuffer
vb
=
AAStroke
:
:
aa_stroke_filled_circle
(
center
.
x
center
.
y
radius
(
AAStroke
:
:
OutputVertex
*
)
outputBuffer
outputBufferCapacity
)
;
if
(
!
vb
.
len
|
|
(
outputBuffer
&
&
vb
.
len
>
outputBufferCapacity
)
)
{
AAStroke
:
:
aa_stroke_vertex_buffer_release
(
vb
)
;
}
else
{
strokeVB
=
Some
(
vb
)
;
}
}
}
if
(
!
strokeVB
)
{
wgrVB
=
GeneratePathVertexBuffer
(
entry
-
>
GetPath
(
)
IntRect
(
-
intBounds
.
TopLeft
(
)
mViewportSize
)
mRasterizationTruncates
outputBuffer
outputBufferCapacity
)
;
}
}
else
{
if
(
mPathAAStroke
&
&
SupportsAAStroke
(
aPattern
aOptions
*
aStrokeOptions
aAllowStrokeAlpha
)
!
=
AAStrokeMode
:
:
Unsupported
)
{
auto
scaleFactors
=
currentTransform
.
ScaleFactors
(
)
;
if
(
scaleFactors
.
AreScalesSame
(
)
)
{
strokeVB
=
GenerateStrokeVertexBuffer
(
entry
-
>
GetPath
(
)
aStrokeOptions
scaleFactors
.
xScale
outputBuffer
outputBufferCapacity
)
;
}
}
if
(
!
strokeVB
&
&
mPathWGRStroke
)
{
Maybe
<
Rect
>
cullRect
;
Matrix
invTransform
=
currentTransform
;
if
(
invTransform
.
Invert
(
)
)
{
Rect
invRect
=
invTransform
.
TransformBounds
(
Rect
(
mClipRect
)
)
;
invRect
.
RoundOut
(
)
;
cullRect
=
Some
(
invRect
)
;
}
SkPath
fillPath
;
if
(
pathSkia
-
>
GetFillPath
(
*
aStrokeOptions
pathXform
fillPath
cullRect
)
)
{
if
(
Maybe
<
QuantizedPath
>
qp
=
GenerateQuantizedPath
(
mWGRPathBuilder
fillPath
quantBounds
pathXform
)
)
{
wgrVB
=
GeneratePathVertexBuffer
(
*
qp
IntRect
(
-
intBounds
.
TopLeft
(
)
mViewportSize
)
mRasterizationTruncates
outputBuffer
outputBufferCapacity
)
;
}
}
}
}
if
(
wgrVB
|
|
strokeVB
)
{
const
uint8_t
*
vbData
=
wgrVB
?
(
const
uint8_t
*
)
wgrVB
-
>
data
:
(
const
uint8_t
*
)
strokeVB
-
>
data
;
if
(
outputBuffer
&
&
!
vbData
)
{
vbData
=
(
const
uint8_t
*
)
outputBuffer
;
}
size_t
vbLen
=
wgrVB
?
wgrVB
-
>
len
:
strokeVB
-
>
len
;
uint32_t
vertexBytes
=
uint32_t
(
std
:
:
min
(
vbLen
*
sizeof
(
WGR
:
:
OutputVertex
)
size_t
(
UINT32_MAX
)
)
)
;
if
(
vertexBytes
>
mPathVertexCapacity
-
mPathVertexOffset
&
&
vertexBytes
<
=
mPathVertexCapacity
-
sizeof
(
kRectVertexData
)
)
{
if
(
mPathCache
)
{
mPathCache
-
>
ClearVertexRanges
(
)
;
}
ResetPathVertexBuffer
(
false
)
;
}
if
(
vertexBytes
<
=
mPathVertexCapacity
-
mPathVertexOffset
)
{
PathVertexRange
vertexRange
(
uint32_t
(
mPathVertexOffset
/
sizeof
(
WGR
:
:
OutputVertex
)
)
uint32_t
(
vbLen
)
)
;
mWebgl
-
>
BufferSubData
(
LOCAL_GL_ARRAY_BUFFER
mPathVertexOffset
vertexBytes
vbData
true
)
;
mPathVertexOffset
+
=
vertexBytes
;
if
(
wgrVB
)
{
WGR
:
:
wgr_vertex_buffer_release
(
wgrVB
.
ref
(
)
)
;
}
else
{
AAStroke
:
:
aa_stroke_vertex_buffer_release
(
strokeVB
.
ref
(
)
)
;
}
if
(
strokeVB
&
&
aStrokeOptions
&
&
SupportsAAStroke
(
aPattern
aOptions
*
aStrokeOptions
aAllowStrokeAlpha
)
=
=
AAStrokeMode
:
:
Mask
)
{
if
(
RefPtr
<
TextureHandle
>
handle
=
DrawStrokeMask
(
vertexRange
intBounds
.
Size
(
)
)
)
{
if
(
entry
)
{
entry
-
>
Link
(
handle
)
;
}
mCurrentTarget
-
>
mProfile
.
OnCacheMiss
(
)
;
SurfacePattern
maskPattern
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
quantBounds
.
TopLeft
(
)
)
SamplingFilter
:
:
GOOD
)
;
return
DrawRectAccel
(
quantBounds
maskPattern
aOptions
color
&
handle
false
true
true
)
;
}
}
else
{
if
(
entry
)
{
entry
-
>
SetVertexRange
(
vertexRange
)
;
}
mCurrentTarget
-
>
mProfile
.
OnCacheMiss
(
)
;
return
DrawRectAccel
(
Rect
(
intBounds
.
TopLeft
(
)
Size
(
1
1
)
)
aPattern
aOptions
Nothing
(
)
nullptr
false
true
true
false
nullptr
&
vertexRange
)
;
}
}
else
{
if
(
wgrVB
)
{
WGR
:
:
wgr_vertex_buffer_release
(
wgrVB
.
ref
(
)
)
;
}
else
{
AAStroke
:
:
aa_stroke_vertex_buffer_release
(
strokeVB
.
ref
(
)
)
;
}
}
}
}
if
(
aStrokeOptions
&
&
intBounds
.
width
*
intBounds
.
height
>
(
mViewportSize
.
width
/
2
)
*
(
mViewportSize
.
height
/
2
)
)
{
return
false
;
}
handle
=
nullptr
;
RefPtr
<
DrawTargetSkia
>
pathDT
=
new
DrawTargetSkia
;
if
(
pathDT
-
>
Init
(
intBounds
.
Size
(
)
color
|
|
aShadow
?
SurfaceFormat
:
:
A8
:
SurfaceFormat
:
:
B8G8R8A8
)
)
{
Point
offset
=
-
quantBounds
.
TopLeft
(
)
;
if
(
aShadow
)
{
offset
+
=
aShadow
-
>
mOffset
;
}
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aOptions
.
mAntialiasMode
)
;
static
const
ColorPattern
maskPattern
(
DeviceColor
(
1
.
0f
1
.
0f
1
.
0f
1
.
0f
)
)
;
const
Pattern
&
cachePattern
=
color
?
maskPattern
:
aPattern
;
DrawTargetWebgl
*
oldTarget
=
mCurrentTarget
;
{
RefPtr
<
const
Path
>
path
;
if
(
color
|
|
!
aPathXform
)
{
path
=
aPath
;
pathDT
-
>
SetTransform
(
pathXform
*
Matrix
:
:
Translation
(
offset
)
)
;
}
else
{
RefPtr
<
PathBuilder
>
builder
=
aPath
-
>
TransformedCopyToBuilder
(
*
aPathXform
)
;
path
=
builder
-
>
Finish
(
)
;
pathDT
-
>
SetTransform
(
currentTransform
*
Matrix
:
:
Translation
(
offset
)
)
;
}
if
(
aStrokeOptions
)
{
pathDT
-
>
Stroke
(
path
cachePattern
*
aStrokeOptions
drawOptions
)
;
}
else
{
pathDT
-
>
Fill
(
path
cachePattern
drawOptions
)
;
}
}
if
(
aShadow
&
&
aShadow
-
>
mSigma
>
0
.
0f
)
{
uint8_t
*
data
=
nullptr
;
IntSize
size
;
int32_t
stride
=
0
;
SurfaceFormat
format
=
SurfaceFormat
:
:
UNKNOWN
;
if
(
pathDT
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
)
{
AlphaBoxBlur
blur
(
Rect
(
pathDT
-
>
GetRect
(
)
)
stride
aShadow
-
>
mSigma
aShadow
-
>
mSigma
)
;
blur
.
Blur
(
data
)
;
pathDT
-
>
ReleaseBits
(
data
)
;
}
}
RefPtr
<
SourceSurface
>
pathSurface
=
pathDT
-
>
Snapshot
(
)
;
if
(
pathSurface
)
{
if
(
mCurrentTarget
!
=
oldTarget
&
&
!
oldTarget
-
>
PrepareContext
(
)
)
{
return
false
;
}
SurfacePattern
pathPattern
(
pathSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
quantBounds
.
TopLeft
(
)
)
filter
)
;
if
(
DrawRectAccel
(
quantBounds
pathPattern
aOptions
shadowColor
&
handle
false
true
)
&
&
handle
)
{
if
(
entry
)
{
entry
-
>
Link
(
handle
)
;
}
}
else
if
(
entry
)
{
entry
-
>
Unlink
(
)
;
}
return
true
;
}
}
return
false
;
}
void
DrawTargetWebgl
:
:
DrawPath
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
bool
aAllowStrokeAlpha
)
{
if
(
ShouldAccelPath
(
aOptions
aStrokeOptions
)
&
&
mSharedContext
-
>
DrawPathAccel
(
aPath
aPattern
aOptions
aStrokeOptions
aAllowStrokeAlpha
)
)
{
return
;
}
MarkSkiaChanged
(
aOptions
)
;
if
(
aStrokeOptions
)
{
mSkia
-
>
Stroke
(
aPath
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
Fill
(
aPath
aPattern
aOptions
)
;
}
}
bool
SharedContextWebgl
:
:
DrawCircleAccel
(
const
Point
&
aCenter
float
aRadius
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
!
mUnitCirclePath
)
{
mUnitCirclePath
=
MakePathForCircle
(
*
mCurrentTarget
Point
(
0
0
)
1
)
;
}
Matrix
circleXform
(
aRadius
0
0
aRadius
aCenter
.
x
aCenter
.
y
)
;
return
DrawPathAccel
(
mUnitCirclePath
aPattern
aOptions
aStrokeOptions
true
nullptr
true
&
circleXform
)
;
}
void
DrawTargetWebgl
:
:
DrawCircle
(
const
Point
&
aOrigin
float
aRadius
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
ShouldAccelPath
(
aOptions
aStrokeOptions
)
&
&
mSharedContext
-
>
DrawCircleAccel
(
aOrigin
aRadius
aPattern
aOptions
aStrokeOptions
)
)
{
return
;
}
MarkSkiaChanged
(
aOptions
)
;
if
(
aStrokeOptions
)
{
mSkia
-
>
StrokeCircle
(
aOrigin
aRadius
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
FillCircle
(
aOrigin
aRadius
aPattern
aOptions
)
;
}
}
void
DrawTargetWebgl
:
:
DrawSurface
(
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSource
const
DrawSurfaceOptions
&
aSurfOptions
const
DrawOptions
&
aOptions
)
{
Matrix
matrix
=
Matrix
:
:
Scaling
(
aDest
.
width
/
aSource
.
width
aDest
.
height
/
aSource
.
height
)
;
matrix
.
PreTranslate
(
-
aSource
.
x
-
aSource
.
y
)
;
matrix
.
PostTranslate
(
aDest
.
x
aDest
.
y
)
;
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
matrix
aSurfOptions
.
mSamplingFilter
)
;
DrawRect
(
aDest
pattern
aOptions
)
;
}
void
DrawTargetWebgl
:
:
Mask
(
const
Pattern
&
aSource
const
Pattern
&
aMask
const
DrawOptions
&
aOptions
)
{
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
aMask
.
GetType
(
)
!
=
PatternType
:
:
SURFACE
|
|
aSource
.
GetType
(
)
!
=
PatternType
:
:
COLOR
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
Mask
(
aSource
aMask
aOptions
)
;
return
;
}
auto
sourceColor
=
static_cast
<
const
ColorPattern
&
>
(
aSource
)
.
mColor
;
auto
maskPattern
=
static_cast
<
const
SurfacePattern
&
>
(
aMask
)
;
DrawRect
(
Rect
(
IntRect
(
IntPoint
(
)
maskPattern
.
mSurface
-
>
GetSize
(
)
)
)
maskPattern
aOptions
Some
(
sourceColor
)
)
;
}
void
DrawTargetWebgl
:
:
MaskSurface
(
const
Pattern
&
aSource
SourceSurface
*
aMask
Point
aOffset
const
DrawOptions
&
aOptions
)
{
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
aSource
.
GetType
(
)
!
=
PatternType
:
:
COLOR
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
MaskSurface
(
aSource
aMask
aOffset
aOptions
)
;
}
else
{
auto
sourceColor
=
static_cast
<
const
ColorPattern
&
>
(
aSource
)
.
mColor
;
SurfacePattern
pattern
(
aMask
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
aOffset
)
)
;
DrawRect
(
Rect
(
aOffset
Size
(
aMask
-
>
GetSize
(
)
)
)
pattern
aOptions
Some
(
sourceColor
)
)
;
}
}
static
already_AddRefed
<
DataSourceSurface
>
ExtractAlpha
(
SourceSurface
*
aSurface
bool
aAllowSubpixelAA
)
{
RefPtr
<
DataSourceSurface
>
surfaceData
=
aSurface
-
>
GetDataSurface
(
)
;
if
(
!
surfaceData
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
srcMap
(
surfaceData
DataSourceSurface
:
:
READ
)
;
if
(
!
srcMap
.
IsMapped
(
)
)
{
return
nullptr
;
}
IntSize
size
=
surfaceData
-
>
GetSize
(
)
;
RefPtr
<
DataSourceSurface
>
alpha
=
Factory
:
:
CreateDataSourceSurface
(
size
SurfaceFormat
:
:
A8
false
)
;
if
(
!
alpha
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
dstMap
(
alpha
DataSourceSurface
:
:
WRITE
)
;
if
(
!
dstMap
.
IsMapped
(
)
)
{
return
nullptr
;
}
SwizzleData
(
srcMap
.
GetData
(
)
srcMap
.
GetStride
(
)
aAllowSubpixelAA
?
SurfaceFormat
:
:
A8R8G8B8
:
surfaceData
-
>
GetFormat
(
)
dstMap
.
GetData
(
)
dstMap
.
GetStride
(
)
SurfaceFormat
:
:
A8
size
)
;
return
alpha
.
forget
(
)
;
}
void
DrawTargetWebgl
:
:
DrawShadow
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
ShadowOptions
&
aShadow
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
!
aPath
|
|
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
if
(
ShouldAccelPath
(
aOptions
aStrokeOptions
)
&
&
mSharedContext
-
>
DrawPathAccel
(
aPath
aPattern
aOptions
aStrokeOptions
false
&
aShadow
)
)
{
return
;
}
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
DrawShadow
(
aPath
aPattern
aShadow
aOptions
aStrokeOptions
)
;
}
void
DrawTargetWebgl
:
:
DrawSurfaceWithShadow
(
SourceSurface
*
aSurface
const
Point
&
aDest
const
ShadowOptions
&
aShadow
CompositionOp
aOperator
)
{
DrawOptions
options
(
1
.
0f
aOperator
)
;
if
(
ShouldAccelPath
(
options
nullptr
)
)
{
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
aDest
)
)
;
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
Rect
(
aSurface
-
>
GetRect
(
)
)
+
aDest
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
AutoRestoreTransform
restore
(
this
)
;
SetTransform
(
Matrix
(
)
)
;
if
(
mSharedContext
-
>
DrawPathAccel
(
path
pattern
options
nullptr
false
&
aShadow
false
)
)
{
DrawRect
(
Rect
(
aSurface
-
>
GetRect
(
)
)
+
aDest
pattern
options
)
;
return
;
}
}
MarkSkiaChanged
(
options
)
;
mSkia
-
>
DrawSurfaceWithShadow
(
aSurface
aDest
aShadow
aOperator
)
;
}
already_AddRefed
<
PathBuilder
>
DrawTargetWebgl
:
:
CreatePathBuilder
(
FillRule
aFillRule
)
const
{
return
mSkia
-
>
CreatePathBuilder
(
aFillRule
)
;
}
void
DrawTargetWebgl
:
:
SetTransform
(
const
Matrix
&
aTransform
)
{
DrawTarget
:
:
SetTransform
(
aTransform
)
;
mSkia
-
>
SetTransform
(
aTransform
)
;
}
void
DrawTargetWebgl
:
:
StrokeRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
StrokeRect
(
aRect
aPattern
aStrokeOptions
aOptions
)
;
}
else
{
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
aRect
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
DrawPath
(
path
aPattern
aOptions
&
aStrokeOptions
true
)
;
}
}
static
inline
bool
IsThinLine
(
const
Matrix
&
aTransform
const
StrokeOptions
&
aStrokeOptions
)
{
auto
scale
=
aTransform
.
ScaleFactors
(
)
;
return
std
:
:
max
(
scale
.
xScale
scale
.
yScale
)
*
aStrokeOptions
.
mLineWidth
<
=
1
;
}
bool
DrawTargetWebgl
:
:
StrokeLineAccel
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
bool
aClosed
)
{
CapStyle
capStyle
=
aClosed
?
(
aStrokeOptions
.
mLineJoin
=
=
JoinStyle
:
:
ROUND
?
CapStyle
:
:
ROUND
:
CapStyle
:
:
BUTT
)
:
aStrokeOptions
.
mLineCap
;
if
(
mWebglValid
&
&
SupportsPattern
(
aPattern
)
&
&
(
capStyle
!
=
CapStyle
:
:
ROUND
|
|
IsThinLine
(
GetTransform
(
)
aStrokeOptions
)
)
&
&
aStrokeOptions
.
mDashPattern
=
=
nullptr
&
&
aStrokeOptions
.
mLineWidth
>
0
)
{
Point
start
=
aStart
;
Point
dirX
=
aEnd
-
aStart
;
Point
dirY
;
float
dirLen
=
dirX
.
Length
(
)
;
float
scale
=
aStrokeOptions
.
mLineWidth
;
if
(
dirLen
=
=
0
.
0f
)
{
switch
(
capStyle
)
{
case
CapStyle
:
:
BUTT
:
return
true
;
case
CapStyle
:
:
ROUND
:
case
CapStyle
:
:
SQUARE
:
dirX
=
Point
(
scale
0
.
0f
)
;
dirY
=
Point
(
0
.
0f
scale
)
;
start
.
x
-
=
0
.
5f
*
scale
;
break
;
}
}
else
{
scale
/
=
dirLen
;
dirY
=
Point
(
-
dirX
.
y
dirX
.
x
)
*
scale
;
if
(
capStyle
=
=
CapStyle
:
:
SQUARE
)
{
start
-
=
(
dirX
*
scale
)
*
0
.
5f
;
dirX
+
=
dirX
*
scale
;
}
}
Matrix
lineXform
(
dirX
.
x
dirX
.
y
dirY
.
x
dirY
.
y
start
.
x
-
0
.
5f
*
dirY
.
x
start
.
y
-
0
.
5f
*
dirY
.
y
)
;
if
(
PrepareContext
(
)
&
&
mSharedContext
-
>
DrawRectAccel
(
Rect
(
0
0
1
1
)
aPattern
aOptions
Nothing
(
)
nullptr
true
true
true
false
nullptr
nullptr
&
lineXform
)
)
{
return
true
;
}
}
return
false
;
}
void
DrawTargetWebgl
:
:
StrokeLine
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
StrokeLine
(
aStart
aEnd
aPattern
aStrokeOptions
aOptions
)
;
}
else
if
(
!
StrokeLineAccel
(
aStart
aEnd
aPattern
aStrokeOptions
aOptions
)
)
{
SkPath
skiaPath
;
skiaPath
.
moveTo
(
PointToSkPoint
(
aStart
)
)
;
skiaPath
.
lineTo
(
PointToSkPoint
(
aEnd
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
DrawPath
(
path
aPattern
aOptions
&
aStrokeOptions
true
)
;
}
}
void
DrawTargetWebgl
:
:
Stroke
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
!
aPath
|
|
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
auto
&
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
-
>
GetPath
(
)
;
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
Stroke
(
aPath
aPattern
aStrokeOptions
aOptions
)
;
return
;
}
int
numVerbs
=
skiaPath
.
countVerbs
(
)
;
bool
allowStrokeAlpha
=
false
;
if
(
numVerbs
>
=
2
&
&
numVerbs
<
=
3
)
{
uint8_t
verbs
[
3
]
;
skiaPath
.
getVerbs
(
verbs
numVerbs
)
;
if
(
verbs
[
0
]
=
=
SkPath
:
:
kMove_Verb
&
&
verbs
[
1
]
=
=
SkPath
:
:
kLine_Verb
&
&
(
numVerbs
<
3
|
|
verbs
[
2
]
=
=
SkPath
:
:
kClose_Verb
)
)
{
bool
closed
=
numVerbs
>
=
3
;
Point
start
=
SkPointToPoint
(
skiaPath
.
getPoint
(
0
)
)
;
Point
end
=
SkPointToPoint
(
skiaPath
.
getPoint
(
1
)
)
;
if
(
StrokeLineAccel
(
start
end
aPattern
aStrokeOptions
aOptions
closed
)
)
{
if
(
closed
)
{
StrokeLineAccel
(
end
start
aPattern
aStrokeOptions
aOptions
true
)
;
}
return
;
}
allowStrokeAlpha
=
true
;
}
}
DrawPath
(
aPath
aPattern
aOptions
&
aStrokeOptions
allowStrokeAlpha
)
;
}
void
DrawTargetWebgl
:
:
StrokeCircle
(
const
Point
&
aOrigin
float
aRadius
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
DrawCircle
(
aOrigin
aRadius
aPattern
aOptions
&
aStrokeOptions
)
;
}
bool
DrawTargetWebgl
:
:
ShouldUseSubpixelAA
(
ScaledFont
*
aFont
const
DrawOptions
&
aOptions
)
{
AntialiasMode
aaMode
=
aFont
-
>
GetDefaultAAMode
(
)
;
if
(
aOptions
.
mAntialiasMode
!
=
AntialiasMode
:
:
DEFAULT
)
{
aaMode
=
aOptions
.
mAntialiasMode
;
}
return
GetPermitSubpixelAA
(
)
&
&
(
aaMode
=
=
AntialiasMode
:
:
DEFAULT
|
|
aaMode
=
=
AntialiasMode
:
:
SUBPIXEL
)
&
&
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_OVER
;
}
void
DrawTargetWebgl
:
:
StrokeGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
!
aFont
|
|
!
aBuffer
.
mNumGlyphs
)
{
return
;
}
bool
useSubpixelAA
=
ShouldUseSubpixelAA
(
aFont
aOptions
)
;
if
(
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
&
&
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
&
&
PrepareContext
(
)
&
&
mSharedContext
-
>
DrawGlyphsAccel
(
aFont
aBuffer
aPattern
aOptions
&
aStrokeOptions
useSubpixelAA
)
)
{
return
;
}
if
(
useSubpixelAA
)
{
MarkSkiaChanged
(
)
;
}
else
{
MarkSkiaChanged
(
aOptions
)
;
}
mSkia
-
>
StrokeGlyphs
(
aFont
aBuffer
aPattern
aStrokeOptions
aOptions
)
;
}
static
inline
IntPoint
QuantizeScale
(
ScaledFont
*
aFont
const
Matrix
&
aTransform
)
{
if
(
!
aFont
-
>
UseSubpixelPosition
(
)
)
{
return
{
1
1
}
;
}
if
(
aTransform
.
_12
=
=
0
)
{
return
{
4
1
}
;
}
if
(
aTransform
.
_11
=
=
0
)
{
return
{
1
4
}
;
}
return
{
4
4
}
;
}
static
inline
IntPoint
QuantizePosition
(
const
Matrix
&
aTransform
const
IntPoint
&
aOffset
const
Point
&
aPosition
)
{
return
RoundedToInt
(
aTransform
.
TransformPoint
(
aPosition
)
)
-
aOffset
;
}
static
inline
IntPoint
QuantizeOffset
(
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
GlyphBuffer
&
aBuffer
)
{
IntPoint
offset
=
RoundedToInt
(
aTransform
.
TransformPoint
(
aBuffer
.
mGlyphs
[
0
]
.
mPosition
)
)
;
offset
.
x
.
value
&
=
~
(
aQuantizeScale
.
x
.
value
-
1
)
;
offset
.
y
.
value
&
=
~
(
aQuantizeScale
.
y
.
value
-
1
)
;
return
offset
;
}
HashNumber
GlyphCacheEntry
:
:
HashGlyphs
(
const
GlyphBuffer
&
aBuffer
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
)
{
HashNumber
hash
=
0
;
IntPoint
offset
=
QuantizeOffset
(
aTransform
aQuantizeScale
aBuffer
)
;
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
const
Glyph
&
glyph
=
aBuffer
.
mGlyphs
[
i
]
;
hash
=
AddToHash
(
hash
glyph
.
mIndex
)
;
IntPoint
pos
=
QuantizePosition
(
aTransform
offset
glyph
.
mPosition
)
;
hash
=
AddToHash
(
hash
pos
.
x
)
;
hash
=
AddToHash
(
hash
pos
.
y
)
;
}
return
hash
;
}
inline
bool
GlyphCacheEntry
:
:
MatchesGlyphs
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeOffset
const
IntPoint
&
aBoundsOffset
const
IntRect
&
aClipRect
HashNumber
aHash
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
aHash
!
=
mHash
|
|
aBuffer
.
mNumGlyphs
!
=
mBuffer
.
mNumGlyphs
|
|
aColor
!
=
mColor
|
|
!
HasMatchingScale
(
aTransform
mTransform
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
const
Glyph
&
dst
=
mBuffer
.
mGlyphs
[
i
]
;
const
Glyph
&
src
=
aBuffer
.
mGlyphs
[
i
]
;
if
(
dst
.
mIndex
!
=
src
.
mIndex
|
|
dst
.
mPosition
!
=
Point
(
QuantizePosition
(
aTransform
aQuantizeOffset
src
.
mPosition
)
)
)
{
return
false
;
}
}
if
(
aStrokeOptions
)
{
if
(
!
(
mStrokeOptions
&
&
*
aStrokeOptions
=
=
*
mStrokeOptions
)
)
{
return
false
;
}
}
else
if
(
mStrokeOptions
)
{
return
false
;
}
return
(
mFullBounds
+
aBoundsOffset
)
.
Intersect
(
aClipRect
)
.
IsEqualEdges
(
GetBounds
(
)
+
aBoundsOffset
)
;
}
GlyphCacheEntry
:
:
GlyphCacheEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
IntRect
&
aBounds
const
IntRect
&
aFullBounds
HashNumber
aHash
StoredStrokeOptions
*
aStrokeOptions
)
:
CacheEntryImpl
<
GlyphCacheEntry
>
(
aTransform
aBounds
aHash
)
mColor
(
aColor
)
mFullBounds
(
aFullBounds
)
mStrokeOptions
(
aStrokeOptions
)
{
Glyph
*
glyphs
=
new
Glyph
[
aBuffer
.
mNumGlyphs
]
;
IntPoint
offset
=
QuantizeOffset
(
aTransform
aQuantizeScale
aBuffer
)
;
IntPoint
boundsOffset
(
offset
.
x
/
aQuantizeScale
.
x
offset
.
y
/
aQuantizeScale
.
y
)
;
mBounds
-
=
boundsOffset
;
mFullBounds
-
=
boundsOffset
;
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
Glyph
&
dst
=
glyphs
[
i
]
;
const
Glyph
&
src
=
aBuffer
.
mGlyphs
[
i
]
;
dst
.
mIndex
=
src
.
mIndex
;
dst
.
mPosition
=
Point
(
QuantizePosition
(
aTransform
offset
src
.
mPosition
)
)
;
}
mBuffer
.
mGlyphs
=
glyphs
;
mBuffer
.
mNumGlyphs
=
aBuffer
.
mNumGlyphs
;
}
GlyphCacheEntry
:
:
~
GlyphCacheEntry
(
)
{
delete
[
]
mBuffer
.
mGlyphs
;
}
already_AddRefed
<
GlyphCacheEntry
>
GlyphCache
:
:
FindEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
IntRect
&
aClipRect
HashNumber
aHash
const
StrokeOptions
*
aStrokeOptions
)
{
IntPoint
offset
=
QuantizeOffset
(
aTransform
aQuantizeScale
aBuffer
)
;
IntPoint
boundsOffset
(
offset
.
x
/
aQuantizeScale
.
x
offset
.
y
/
aQuantizeScale
.
y
)
;
for
(
const
RefPtr
<
GlyphCacheEntry
>
&
entry
:
GetChain
(
aHash
)
)
{
if
(
entry
-
>
MatchesGlyphs
(
aBuffer
aColor
aTransform
offset
boundsOffset
aClipRect
aHash
aStrokeOptions
)
)
{
return
do_AddRef
(
entry
)
;
}
}
return
nullptr
;
}
already_AddRefed
<
GlyphCacheEntry
>
GlyphCache
:
:
InsertEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
IntRect
&
aBounds
const
IntRect
&
aFullBounds
HashNumber
aHash
const
StrokeOptions
*
aStrokeOptions
)
{
StoredStrokeOptions
*
strokeOptions
=
nullptr
;
if
(
aStrokeOptions
)
{
strokeOptions
=
aStrokeOptions
-
>
Clone
(
)
;
if
(
!
strokeOptions
)
{
return
nullptr
;
}
}
RefPtr
<
GlyphCacheEntry
>
entry
=
new
GlyphCacheEntry
(
aBuffer
aColor
aTransform
aQuantizeScale
aBounds
aFullBounds
aHash
strokeOptions
)
;
Insert
(
entry
)
;
return
entry
.
forget
(
)
;
}
GlyphCache
:
:
GlyphCache
(
ScaledFont
*
aFont
)
:
mFont
(
aFont
)
{
}
static
void
ReleaseGlyphCache
(
void
*
aPtr
)
{
delete
static_cast
<
GlyphCache
*
>
(
aPtr
)
;
}
void
DrawTargetWebgl
:
:
SetPermitSubpixelAA
(
bool
aPermitSubpixelAA
)
{
DrawTarget
:
:
SetPermitSubpixelAA
(
aPermitSubpixelAA
)
;
mSkia
-
>
SetPermitSubpixelAA
(
aPermitSubpixelAA
)
;
}
static
bool
CheckForColorGlyphs
(
const
RefPtr
<
SourceSurface
>
&
aSurface
)
{
if
(
aSurface
-
>
GetFormat
(
)
!
=
SurfaceFormat
:
:
B8G8R8A8
)
{
return
false
;
}
RefPtr
<
DataSourceSurface
>
dataSurf
=
aSurface
-
>
GetDataSurface
(
)
;
if
(
!
dataSurf
)
{
return
true
;
}
DataSourceSurface
:
:
ScopedMap
map
(
dataSurf
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
true
;
}
IntSize
size
=
dataSurf
-
>
GetSize
(
)
;
const
uint8_t
*
data
=
map
.
GetData
(
)
;
int32_t
stride
=
map
.
GetStride
(
)
;
for
(
int
y
=
0
;
y
<
size
.
height
;
y
+
+
)
{
const
uint32_t
*
x
=
(
const
uint32_t
*
)
data
;
const
uint32_t
*
end
=
x
+
size
.
width
;
for
(
;
x
<
end
;
x
+
+
)
{
uint32_t
color
=
*
x
;
uint32_t
gray
=
color
&
0xFF
;
gray
|
=
gray
<
<
8
;
gray
|
=
gray
<
<
16
;
if
(
color
!
=
gray
)
return
true
;
}
data
+
=
stride
;
}
return
false
;
}
static
DeviceColor
QuantizePreblendColor
(
const
DeviceColor
&
aColor
bool
aUseSubpixelAA
)
{
int32_t
r
=
int32_t
(
aColor
.
r
*
255
.
0f
+
0
.
5f
)
;
int32_t
g
=
int32_t
(
aColor
.
g
*
255
.
0f
+
0
.
5f
)
;
int32_t
b
=
int32_t
(
aColor
.
b
*
255
.
0f
+
0
.
5f
)
;
bool
lightOnDark
=
r
>
=
85
&
&
g
>
=
85
&
&
b
>
=
85
&
&
r
+
g
+
b
>
=
2
*
255
;
constexpr
int32_t
lumBits
=
3
;
constexpr
int32_t
ceilMask
=
(
1
<
<
(
8
-
lumBits
)
)
-
1
;
constexpr
int32_t
floorMask
=
(
(
1
<
<
lumBits
)
-
1
)
<
<
(
8
-
lumBits
)
;
if
(
!
aUseSubpixelAA
)
{
g
=
(
r
*
54
+
g
*
183
+
b
*
19
)
>
>
8
;
g
|
=
ceilMask
;
r
=
b
=
lightOnDark
?
255
:
0
;
}
else
if
(
lightOnDark
)
{
r
|
=
ceilMask
;
g
|
=
ceilMask
;
b
|
=
ceilMask
;
}
else
{
r
&
=
floorMask
;
g
&
=
floorMask
;
b
&
=
floorMask
;
}
return
DeviceColor
{
r
/
255
.
0f
g
/
255
.
0f
b
/
255
.
0f
1
.
0f
}
;
}
bool
SharedContextWebgl
:
:
DrawGlyphsAccel
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
bool
aUseSubpixelAA
)
{
bool
useBitmaps
=
!
aStrokeOptions
&
&
aFont
-
>
MayUseBitmaps
(
)
&
&
aOptions
.
mCompositionOp
!
=
CompositionOp
:
:
OP_CLEAR
;
GlyphCache
*
cache
=
static_cast
<
GlyphCache
*
>
(
aFont
-
>
GetUserData
(
&
mGlyphCacheKey
)
)
;
if
(
!
cache
)
{
cache
=
new
GlyphCache
(
aFont
)
;
aFont
-
>
AddUserData
(
&
mGlyphCacheKey
cache
ReleaseGlyphCache
)
;
mGlyphCaches
.
insertFront
(
cache
)
;
}
DeviceColor
color
=
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_CLEAR
?
DeviceColor
(
1
1
1
1
)
:
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
;
#
if
defined
(
XP_MACOSX
)
bool
usePreblend
=
aUseSubpixelAA
|
|
(
aFont
-
>
GetType
(
)
=
=
FontType
:
:
MAC
&
&
static_cast
<
ScaledFontMac
*
>
(
aFont
)
-
>
UseFontSmoothing
(
)
)
;
#
elif
defined
(
XP_WIN
)
bool
usePreblend
=
aUseSubpixelAA
|
|
aOptions
.
mAntialiasMode
!
=
AntialiasMode
:
:
NONE
;
#
else
bool
usePreblend
=
false
;
#
endif
const
Matrix
&
currentTransform
=
mCurrentTarget
-
>
GetTransform
(
)
;
IntPoint
quantizeScale
=
QuantizeScale
(
aFont
currentTransform
)
;
Matrix
quantizeTransform
=
currentTransform
;
quantizeTransform
.
PostScale
(
quantizeScale
.
x
quantizeScale
.
y
)
;
HashNumber
hash
=
GlyphCacheEntry
:
:
HashGlyphs
(
aBuffer
quantizeTransform
quantizeScale
)
;
DeviceColor
colorOrMask
=
useBitmaps
?
color
:
(
usePreblend
?
QuantizePreblendColor
(
color
aUseSubpixelAA
)
:
DeviceColor
:
:
Mask
(
aUseSubpixelAA
?
1
:
0
1
)
)
;
IntRect
clipRect
(
IntPoint
(
)
mViewportSize
)
;
RefPtr
<
GlyphCacheEntry
>
entry
=
cache
-
>
FindEntry
(
aBuffer
colorOrMask
quantizeTransform
quantizeScale
clipRect
hash
aStrokeOptions
)
;
if
(
!
entry
)
{
Maybe
<
Rect
>
bounds
=
mCurrentTarget
-
>
mSkia
-
>
GetGlyphLocalBounds
(
aFont
aBuffer
aPattern
aStrokeOptions
aOptions
)
;
if
(
!
bounds
)
{
return
true
;
}
Rect
xformBounds
=
currentTransform
.
TransformBounds
(
*
bounds
)
;
if
(
xformBounds
.
IsEmpty
(
)
)
{
return
true
;
}
IntRect
fullBounds
=
RoundedOut
(
xformBounds
)
;
IntRect
clipBounds
=
fullBounds
.
Intersect
(
clipRect
)
;
if
(
clipBounds
.
IsEmpty
(
)
)
{
return
true
;
}
entry
=
cache
-
>
InsertEntry
(
aBuffer
colorOrMask
quantizeTransform
quantizeScale
clipBounds
fullBounds
hash
aStrokeOptions
)
;
if
(
!
entry
)
{
return
false
;
}
}
IntRect
intBounds
=
entry
-
>
GetBounds
(
)
;
IntPoint
newOffset
=
QuantizeOffset
(
quantizeTransform
quantizeScale
aBuffer
)
;
intBounds
+
=
IntPoint
(
newOffset
.
x
/
quantizeScale
.
x
newOffset
.
y
/
quantizeScale
.
y
)
;
intBounds
.
Inflate
(
2
)
;
RefPtr
<
TextureHandle
>
handle
=
entry
-
>
GetHandle
(
)
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
)
{
SurfacePattern
pattern
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
)
;
if
(
DrawRectAccel
(
Rect
(
intBounds
)
pattern
aOptions
useBitmaps
?
Nothing
(
)
:
Some
(
color
)
&
handle
false
true
true
)
)
{
return
true
;
}
}
else
{
handle
=
nullptr
;
RefPtr
<
DrawTargetSkia
>
textDT
=
new
DrawTargetSkia
;
if
(
textDT
-
>
Init
(
intBounds
.
Size
(
)
useBitmaps
|
|
usePreblend
|
|
aUseSubpixelAA
?
SurfaceFormat
:
:
B8G8R8A8
:
SurfaceFormat
:
:
A8
)
)
{
textDT
-
>
SetTransform
(
currentTransform
*
Matrix
:
:
Translation
(
-
intBounds
.
TopLeft
(
)
)
)
;
textDT
-
>
SetPermitSubpixelAA
(
aUseSubpixelAA
)
;
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aOptions
.
mAntialiasMode
)
;
if
(
!
useBitmaps
&
&
usePreblend
)
{
textDT
-
>
DrawGlyphMask
(
aFont
aBuffer
color
aStrokeOptions
drawOptions
)
;
}
else
{
ColorPattern
colorPattern
(
useBitmaps
?
color
:
DeviceColor
(
1
1
1
1
)
)
;
if
(
aStrokeOptions
)
{
textDT
-
>
StrokeGlyphs
(
aFont
aBuffer
colorPattern
*
aStrokeOptions
drawOptions
)
;
}
else
{
textDT
-
>
FillGlyphs
(
aFont
aBuffer
colorPattern
drawOptions
)
;
}
}
RefPtr
<
SourceSurface
>
textSurface
=
textDT
-
>
Snapshot
(
)
;
if
(
textSurface
)
{
if
(
textSurface
-
>
GetFormat
(
)
!
=
SurfaceFormat
:
:
A8
&
&
!
CheckForColorGlyphs
(
textSurface
)
)
{
textSurface
=
ExtractAlpha
(
textSurface
!
useBitmaps
)
;
if
(
!
textSurface
)
{
return
false
;
}
}
SurfacePattern
pattern
(
textSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
)
;
if
(
DrawRectAccel
(
Rect
(
intBounds
)
pattern
aOptions
useBitmaps
?
Nothing
(
)
:
Some
(
color
)
&
handle
false
true
)
&
&
handle
)
{
entry
-
>
Link
(
handle
)
;
}
else
{
entry
-
>
Unlink
(
)
;
}
return
true
;
}
}
}
return
false
;
}
void
DrawTargetWebgl
:
:
FillGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
!
aFont
|
|
!
aBuffer
.
mNumGlyphs
)
{
return
;
}
bool
useSubpixelAA
=
ShouldUseSubpixelAA
(
aFont
aOptions
)
;
if
(
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
&
&
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
&
&
PrepareContext
(
)
&
&
mSharedContext
-
>
DrawGlyphsAccel
(
aFont
aBuffer
aPattern
aOptions
nullptr
useSubpixelAA
)
)
{
return
;
}
if
(
useSubpixelAA
)
{
MarkSkiaChanged
(
)
;
}
else
{
MarkSkiaChanged
(
aOptions
)
;
}
mSkia
-
>
FillGlyphs
(
aFont
aBuffer
aPattern
aOptions
)
;
}
bool
DrawTargetWebgl
:
:
ReadIntoSkia
(
)
{
if
(
mSkiaValid
)
{
return
false
;
}
bool
didReadback
=
false
;
if
(
mWebglValid
)
{
uint8_t
*
data
=
nullptr
;
IntSize
size
;
int32_t
stride
;
SurfaceFormat
format
;
if
(
mIsClear
)
{
mSkia
-
>
DetachAllSnapshots
(
)
;
mSkiaNoClip
-
>
FillRect
(
Rect
(
mSkiaNoClip
-
>
GetRect
(
)
)
GetClearPattern
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
}
else
{
if
(
!
mSnapshot
&
&
mSkia
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
)
{
(
void
)
ReadInto
(
data
stride
)
;
mSkia
-
>
ReleaseBits
(
data
)
;
}
else
if
(
RefPtr
<
SourceSurface
>
snapshot
=
Snapshot
(
)
)
{
mSkia
-
>
CopySurface
(
snapshot
GetRect
(
)
IntPoint
(
0
0
)
)
;
}
didReadback
=
true
;
}
}
mSkiaValid
=
true
;
mSkiaLayer
=
false
;
return
didReadback
;
}
void
DrawTargetWebgl
:
:
FlattenSkia
(
)
{
if
(
!
mSkiaValid
|
|
!
mSkiaLayer
)
{
return
;
}
mSkiaLayer
=
false
;
if
(
mSkiaLayerClear
)
{
return
;
}
if
(
RefPtr
<
DataSourceSurface
>
base
=
ReadSnapshot
(
)
)
{
mSkia
-
>
DetachAllSnapshots
(
)
;
mSkiaNoClip
-
>
DrawSurface
(
base
Rect
(
GetRect
(
)
)
Rect
(
GetRect
(
)
)
DrawSurfaceOptions
(
SamplingFilter
:
:
POINT
)
DrawOptions
(
1
.
f
CompositionOp
:
:
OP_DEST_OVER
)
)
;
}
}
bool
DrawTargetWebgl
:
:
FlushFromSkia
(
)
{
if
(
mSharedContext
-
>
IsContextLost
(
)
)
{
mWebglValid
=
false
;
return
false
;
}
if
(
mWebglValid
)
{
return
true
;
}
mWebglValid
=
true
;
if
(
mSkiaValid
)
{
AutoRestoreContext
restore
(
this
)
;
if
(
mIsClear
)
{
if
(
!
DrawRect
(
Rect
(
GetRect
(
)
)
GetClearPattern
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
Nothing
(
)
nullptr
false
false
true
)
)
{
mWebglValid
=
false
;
return
false
;
}
return
true
;
}
RefPtr
<
SourceSurface
>
skiaSnapshot
=
mSkia
-
>
Snapshot
(
)
;
if
(
!
skiaSnapshot
)
{
mWebglValid
=
false
;
return
false
;
}
if
(
!
mSkiaLayer
)
{
if
(
PrepareContext
(
false
)
&
&
MarkChanged
(
)
)
{
if
(
RefPtr
<
DataSourceSurface
>
data
=
skiaSnapshot
-
>
GetDataSurface
(
)
)
{
mSharedContext
-
>
UploadSurface
(
data
mFormat
GetRect
(
)
IntPoint
(
)
false
false
mTex
)
;
return
true
;
}
}
mWebglValid
=
false
;
return
false
;
}
SurfacePattern
pattern
(
skiaSnapshot
ExtendMode
:
:
CLAMP
)
;
if
(
!
DrawRect
(
Rect
(
GetRect
(
)
)
pattern
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
)
Nothing
(
)
&
mSnapshotTexture
false
false
true
true
)
)
{
mWebglValid
=
false
;
return
false
;
}
}
return
true
;
}
void
DrawTargetWebgl
:
:
UsageProfile
:
:
BeginFrame
(
)
{
mFallbacks
=
0
;
mLayers
=
0
;
mCacheMisses
=
0
;
mCacheHits
=
0
;
mUncachedDraws
=
0
;
mReadbacks
=
0
;
}
void
DrawTargetWebgl
:
:
UsageProfile
:
:
EndFrame
(
)
{
bool
failed
=
false
;
float
cacheRatio
=
StaticPrefs
:
:
gfx_canvas_accelerated_profile_cache_miss_ratio
(
)
;
if
(
mFallbacks
>
0
|
|
float
(
mCacheMisses
+
mReadbacks
+
mLayers
)
>
cacheRatio
*
float
(
mCacheMisses
+
mCacheHits
+
mUncachedDraws
+
mReadbacks
+
mLayers
)
)
{
failed
=
true
;
}
if
(
failed
)
{
+
+
mFailedFrames
;
}
+
+
mFrameCount
;
}
bool
DrawTargetWebgl
:
:
UsageProfile
:
:
RequiresRefresh
(
)
const
{
uint32_t
profileFrames
=
StaticPrefs
:
:
gfx_canvas_accelerated_profile_frames
(
)
;
if
(
!
profileFrames
|
|
mFrameCount
<
profileFrames
)
{
return
false
;
}
float
failRatio
=
StaticPrefs
:
:
gfx_canvas_accelerated_profile_fallback_ratio
(
)
;
return
mFailedFrames
>
failRatio
*
mFrameCount
;
}
void
SharedContextWebgl
:
:
CachePrefs
(
)
{
uint32_t
capacity
=
StaticPrefs
:
:
gfx_canvas_accelerated_gpu_path_size
(
)
<
<
20
;
if
(
capacity
!
=
mPathVertexCapacity
)
{
mPathVertexCapacity
=
capacity
;
if
(
mPathCache
)
{
mPathCache
-
>
ClearVertexRanges
(
)
;
}
if
(
mPathVertexBuffer
)
{
ResetPathVertexBuffer
(
)
;
}
}
mPathMaxComplexity
=
StaticPrefs
:
:
gfx_canvas_accelerated_gpu_path_complexity
(
)
;
mPathAAStroke
=
StaticPrefs
:
:
gfx_canvas_accelerated_aa_stroke_enabled
(
)
;
mPathWGRStroke
=
StaticPrefs
:
:
gfx_canvas_accelerated_stroke_to_fill_path
(
)
;
}
void
DrawTargetWebgl
:
:
BeginFrame
(
bool
aInvalidContents
)
{
if
(
!
mWebglValid
)
{
if
(
aInvalidContents
)
{
mWebglValid
=
true
;
mIsClear
=
false
;
}
else
{
FlushFromSkia
(
)
;
}
}
mSharedContext
-
>
ClearCachesIfNecessary
(
)
;
mSharedContext
-
>
CachePrefs
(
)
;
mProfile
.
BeginFrame
(
)
;
}
void
DrawTargetWebgl
:
:
EndFrame
(
)
{
if
(
StaticPrefs
:
:
gfx_canvas_accelerated_debug
(
)
)
{
IntRect
corner
=
IntRect
(
mSize
.
width
-
16
0
16
16
)
.
Intersect
(
GetRect
(
)
)
;
DrawRect
(
Rect
(
corner
)
ColorPattern
(
DeviceColor
(
0
.
0f
1
.
0f
0
.
0f
1
.
0f
)
)
DrawOptions
(
)
Nothing
(
)
nullptr
false
false
)
;
}
mProfile
.
EndFrame
(
)
;
mSharedContext
-
>
PruneTextureMemory
(
)
;
mSharedContext
-
>
mWebgl
-
>
EndOfFrame
(
)
;
mSharedContext
-
>
ClearCachesIfNecessary
(
)
;
}
bool
DrawTargetWebgl
:
:
CopyToSwapChain
(
layers
:
:
TextureType
aTextureType
layers
:
:
RemoteTextureId
aId
layers
:
:
RemoteTextureOwnerId
aOwnerId
layers
:
:
RemoteTextureOwnerClient
*
aOwnerClient
)
{
if
(
!
mWebglValid
&
&
!
FlushFromSkia
(
)
)
{
return
false
;
}
webgl
:
:
SwapChainOptions
options
;
options
.
bgra
=
true
;
options
.
forceAsyncPresent
=
StaticPrefs
:
:
gfx_canvas_accelerated_async_present
(
)
;
options
.
remoteTextureId
=
aId
;
options
.
remoteTextureOwnerId
=
aOwnerId
;
return
mSharedContext
-
>
mWebgl
-
>
CopyToSwapChain
(
mFramebuffer
aTextureType
options
aOwnerClient
)
;
}
already_AddRefed
<
DrawTarget
>
DrawTargetWebgl
:
:
CreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
bool
DrawTargetWebgl
:
:
CanCreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CanCreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
RefPtr
<
DrawTarget
>
DrawTargetWebgl
:
:
CreateClippedDrawTarget
(
const
Rect
&
aBounds
SurfaceFormat
aFormat
)
{
return
mSkia
-
>
CreateClippedDrawTarget
(
aBounds
aFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
CreateSourceSurfaceFromData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CreateSourceSurfaceFromData
(
aData
aSize
aStride
aFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
CreateSourceSurfaceFromNativeSurface
(
const
NativeSurface
&
aSurface
)
const
{
return
mSkia
-
>
CreateSourceSurfaceFromNativeSurface
(
aSurface
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
OptimizeSourceSurface
(
SourceSurface
*
aSurface
)
const
{
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
WEBGL
)
{
return
do_AddRef
(
aSurface
)
;
}
return
mSkia
-
>
OptimizeSourceSurface
(
aSurface
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
OptimizeSourceSurfaceForUnknownAlpha
(
SourceSurface
*
aSurface
)
const
{
return
mSkia
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
aSurface
)
;
}
already_AddRefed
<
GradientStops
>
DrawTargetWebgl
:
:
CreateGradientStops
(
GradientStop
*
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
)
const
{
return
mSkia
-
>
CreateGradientStops
(
aStops
aNumStops
aExtendMode
)
;
}
already_AddRefed
<
FilterNode
>
DrawTargetWebgl
:
:
CreateFilter
(
FilterType
aType
)
{
return
mSkia
-
>
CreateFilter
(
aType
)
;
}
void
DrawTargetWebgl
:
:
DrawFilter
(
FilterNode
*
aNode
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
const
DrawOptions
&
aOptions
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
DrawFilter
(
aNode
aSourceRect
aDestPoint
aOptions
)
;
}
bool
DrawTargetWebgl
:
:
Draw3DTransformedSurface
(
SourceSurface
*
aSurface
const
Matrix4x4
&
aMatrix
)
{
MarkSkiaChanged
(
)
;
return
mSkia
-
>
Draw3DTransformedSurface
(
aSurface
aMatrix
)
;
}
void
DrawTargetWebgl
:
:
PushLayer
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
bool
aCopyBackground
)
{
PushLayerWithBlend
(
aOpaque
aOpacity
aMask
aMaskTransform
aBounds
aCopyBackground
CompositionOp
:
:
OP_OVER
)
;
}
void
DrawTargetWebgl
:
:
PushLayerWithBlend
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
bool
aCopyBackground
CompositionOp
aCompositionOp
)
{
MarkSkiaChanged
(
DrawOptions
(
aOpacity
aCompositionOp
)
)
;
mSkia
-
>
PushLayerWithBlend
(
aOpaque
aOpacity
aMask
aMaskTransform
aBounds
aCopyBackground
aCompositionOp
)
;
+
+
mLayerDepth
;
SetPermitSubpixelAA
(
mSkia
-
>
GetPermitSubpixelAA
(
)
)
;
}
void
DrawTargetWebgl
:
:
PopLayer
(
)
{
MOZ_ASSERT
(
mSkiaValid
)
;
MOZ_ASSERT
(
mLayerDepth
>
0
)
;
-
-
mLayerDepth
;
mSkia
-
>
PopLayer
(
)
;
SetPermitSubpixelAA
(
mSkia
-
>
GetPermitSubpixelAA
(
)
)
;
}
}
