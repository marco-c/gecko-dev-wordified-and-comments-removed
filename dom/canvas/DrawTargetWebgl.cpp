#
include
"
DrawTargetWebglInternal
.
h
"
#
include
"
SourceSurfaceWebgl
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
gfx
/
Blur
.
h
"
#
include
"
mozilla
/
gfx
/
DrawTargetSkia
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
HelpersSkia
.
h
"
#
include
"
mozilla
/
gfx
/
Logging
.
h
"
#
include
"
mozilla
/
gfx
/
PathSkia
.
h
"
#
include
"
mozilla
/
gfx
/
Swizzle
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
ClientWebGLContext
.
h
"
#
include
"
WebGLChild
.
h
"
#
include
"
gfxPlatform
.
h
"
namespace
mozilla
:
:
gfx
{
Maybe
<
IntPoint
>
TexturePacker
:
:
Insert
(
const
IntSize
&
aSize
)
{
if
(
mAvailable
<
std
:
:
min
(
aSize
.
width
aSize
.
height
)
|
|
mBounds
.
width
<
aSize
.
width
|
|
mBounds
.
height
<
aSize
.
height
)
{
return
Nothing
(
)
;
}
if
(
mChildren
)
{
Maybe
<
IntPoint
>
inserted
=
mChildren
[
0
]
.
Insert
(
aSize
)
;
if
(
!
inserted
)
{
inserted
=
mChildren
[
1
]
.
Insert
(
aSize
)
;
}
if
(
inserted
)
{
mAvailable
=
std
:
:
max
(
mChildren
[
0
]
.
mAvailable
mChildren
[
1
]
.
mAvailable
)
;
if
(
!
mAvailable
)
{
DiscardChildren
(
)
;
}
}
return
inserted
;
}
if
(
mBounds
.
Size
(
)
=
=
aSize
)
{
mAvailable
=
0
;
return
Some
(
mBounds
.
TopLeft
(
)
)
;
}
if
(
mBounds
.
width
-
aSize
.
width
>
mBounds
.
height
-
aSize
.
height
)
{
mChildren
.
reset
(
new
TexturePacker
[
2
]
{
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
aSize
.
width
mBounds
.
height
)
)
TexturePacker
(
IntRect
(
mBounds
.
x
+
aSize
.
width
mBounds
.
y
mBounds
.
width
-
aSize
.
width
mBounds
.
height
)
)
}
)
;
}
else
{
mChildren
.
reset
(
new
TexturePacker
[
2
]
{
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
mBounds
.
width
aSize
.
height
)
)
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
+
aSize
.
height
mBounds
.
width
mBounds
.
height
-
aSize
.
height
)
)
}
)
;
}
Maybe
<
IntPoint
>
inserted
=
mChildren
[
0
]
.
Insert
(
aSize
)
;
mAvailable
=
std
:
:
max
(
mChildren
[
0
]
.
mAvailable
mChildren
[
1
]
.
mAvailable
)
;
return
inserted
;
}
bool
TexturePacker
:
:
Remove
(
const
IntRect
&
aBounds
)
{
if
(
!
mChildren
)
{
if
(
mAvailable
>
0
|
|
!
mBounds
.
Contains
(
aBounds
)
)
{
return
false
;
}
if
(
mBounds
=
=
aBounds
)
{
mAvailable
=
std
:
:
min
(
mBounds
.
width
mBounds
.
height
)
;
return
true
;
}
if
(
mBounds
.
width
-
aBounds
.
width
>
mBounds
.
height
-
aBounds
.
height
)
{
int
split
=
aBounds
.
x
-
mBounds
.
x
>
mBounds
.
XMost
(
)
-
aBounds
.
XMost
(
)
?
aBounds
.
x
:
aBounds
.
XMost
(
)
;
mChildren
.
reset
(
new
TexturePacker
[
2
]
{
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
split
-
mBounds
.
x
mBounds
.
height
)
false
)
TexturePacker
(
IntRect
(
split
mBounds
.
y
mBounds
.
XMost
(
)
-
split
mBounds
.
height
)
false
)
}
)
;
}
else
{
int
split
=
aBounds
.
y
-
mBounds
.
y
>
mBounds
.
YMost
(
)
-
aBounds
.
YMost
(
)
?
aBounds
.
y
:
aBounds
.
YMost
(
)
;
mChildren
.
reset
(
new
TexturePacker
[
2
]
{
TexturePacker
(
IntRect
(
mBounds
.
x
mBounds
.
y
mBounds
.
width
split
-
mBounds
.
y
)
false
)
TexturePacker
(
IntRect
(
mBounds
.
x
split
mBounds
.
width
mBounds
.
YMost
(
)
-
split
)
false
)
}
)
;
}
}
bool
next
=
mChildren
[
0
]
.
mBounds
.
x
<
mChildren
[
1
]
.
mBounds
.
x
?
aBounds
.
x
>
=
mChildren
[
1
]
.
mBounds
.
x
:
aBounds
.
y
>
=
mChildren
[
1
]
.
mBounds
.
y
;
bool
removed
=
mChildren
[
next
?
1
:
0
]
.
Remove
(
aBounds
)
;
if
(
removed
)
{
if
(
mChildren
[
0
]
.
IsFullyAvailable
(
)
&
&
mChildren
[
1
]
.
IsFullyAvailable
(
)
)
{
DiscardChildren
(
)
;
mAvailable
=
std
:
:
min
(
mBounds
.
width
mBounds
.
height
)
;
}
else
{
mAvailable
=
std
:
:
max
(
mChildren
[
0
]
.
mAvailable
mChildren
[
1
]
.
mAvailable
)
;
}
}
return
removed
;
}
SharedTexture
:
:
SharedTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTextureJS
>
&
aTexture
)
:
mPacker
(
IntRect
(
IntPoint
(
0
0
)
aSize
)
)
mFormat
(
aFormat
)
mTexture
(
aTexture
)
{
}
SharedTextureHandle
:
:
SharedTextureHandle
(
const
IntRect
&
aBounds
SharedTexture
*
aTexture
)
:
mBounds
(
aBounds
)
mTexture
(
aTexture
)
{
}
already_AddRefed
<
SharedTextureHandle
>
SharedTexture
:
:
Allocate
(
const
IntSize
&
aSize
)
{
RefPtr
<
SharedTextureHandle
>
handle
;
if
(
Maybe
<
IntPoint
>
origin
=
mPacker
.
Insert
(
aSize
)
)
{
handle
=
new
SharedTextureHandle
(
IntRect
(
*
origin
aSize
)
this
)
;
+
+
mAllocatedHandles
;
}
return
handle
.
forget
(
)
;
}
bool
SharedTexture
:
:
Free
(
const
SharedTextureHandle
&
aHandle
)
{
if
(
aHandle
.
mTexture
!
=
this
)
{
return
false
;
}
if
(
!
mPacker
.
Remove
(
aHandle
.
mBounds
)
)
{
return
false
;
}
-
-
mAllocatedHandles
;
return
true
;
}
StandaloneTexture
:
:
StandaloneTexture
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
const
RefPtr
<
WebGLTextureJS
>
&
aTexture
)
:
mSize
(
aSize
)
mFormat
(
aFormat
)
mTexture
(
aTexture
)
{
}
DrawTargetWebgl
:
:
DrawTargetWebgl
(
)
=
default
;
inline
void
DrawTargetWebgl
:
:
SharedContext
:
:
ClearLastTexture
(
)
{
mLastTexture
=
nullptr
;
}
void
DrawTargetWebgl
:
:
ClearSnapshot
(
bool
aCopyOnWrite
bool
aNeedHandle
)
{
if
(
!
mSnapshot
)
{
return
;
}
mSharedContext
-
>
ClearLastTexture
(
)
;
if
(
mSnapshot
-
>
hasOneRef
(
)
|
|
mSnapshot
-
>
GetType
(
)
!
=
SurfaceType
:
:
WEBGL
)
{
mSnapshot
=
nullptr
;
return
;
}
RefPtr
<
SourceSurfaceWebgl
>
snapshot
=
mSnapshot
.
forget
(
)
.
downcast
<
SourceSurfaceWebgl
>
(
)
;
if
(
aCopyOnWrite
)
{
snapshot
-
>
DrawTargetWillChange
(
aNeedHandle
)
;
}
else
{
snapshot
-
>
GiveTexture
(
mSharedContext
-
>
WrapSnapshot
(
GetSize
(
)
GetFormat
(
)
mTex
.
forget
(
)
)
)
;
}
}
DrawTargetWebgl
:
:
~
DrawTargetWebgl
(
)
{
ClearSnapshot
(
false
)
;
if
(
mSharedContext
)
{
if
(
mShmem
.
IsWritable
(
)
)
{
mSkia
-
>
DetachAllSnapshots
(
)
;
mSharedContext
-
>
WaitForShmem
(
)
;
auto
*
child
=
mSharedContext
-
>
mWebgl
-
>
GetChild
(
)
;
if
(
child
&
&
child
-
>
CanSend
(
)
)
{
child
-
>
DeallocShmem
(
mShmem
)
;
}
}
if
(
mFramebuffer
)
{
mSharedContext
-
>
mWebgl
-
>
DeleteFramebuffer
(
mFramebuffer
)
;
}
if
(
mTex
)
{
mSharedContext
-
>
mWebgl
-
>
DeleteTexture
(
mTex
)
;
}
}
}
DrawTargetWebgl
:
:
SharedContext
:
:
SharedContext
(
)
=
default
;
DrawTargetWebgl
:
:
SharedContext
:
:
~
SharedContext
(
)
{
if
(
sSharedContext
.
init
(
)
&
&
sSharedContext
.
get
(
)
=
=
this
)
{
sSharedContext
.
set
(
nullptr
)
;
}
ClearAllTextures
(
)
;
UnlinkSurfaceTextures
(
)
;
UnlinkGlyphCaches
(
)
;
}
inline
void
DrawTargetWebgl
:
:
SharedContext
:
:
UnlinkSurfaceTexture
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
if
(
SourceSurface
*
surface
=
aHandle
-
>
GetSurface
(
)
)
{
if
(
surface
-
>
GetType
(
)
=
=
SurfaceType
:
:
WEBGL
)
{
static_cast
<
SourceSurfaceWebgl
*
>
(
surface
)
-
>
OnUnlinkTexture
(
this
)
;
}
surface
-
>
RemoveUserData
(
aHandle
-
>
IsShadow
(
)
?
&
mShadowTextureKey
:
&
mTextureHandleKey
)
;
}
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
UnlinkSurfaceTextures
(
)
{
for
(
RefPtr
<
TextureHandle
>
handle
=
mTextureHandles
.
getFirst
(
)
;
handle
;
handle
=
handle
-
>
getNext
(
)
)
{
UnlinkSurfaceTexture
(
handle
)
;
}
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
UnlinkGlyphCaches
(
)
{
GlyphCache
*
cache
=
mGlyphCaches
.
getFirst
(
)
;
while
(
cache
)
{
ScaledFont
*
font
=
cache
-
>
GetFont
(
)
;
cache
=
cache
-
>
getNext
(
)
;
font
-
>
RemoveUserData
(
&
mGlyphCacheKey
)
;
}
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
OnMemoryPressure
(
)
{
mShouldClearCaches
=
true
;
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
ClearAllTextures
(
)
{
while
(
!
mTextureHandles
.
isEmpty
(
)
)
{
PruneTextureHandle
(
mTextureHandles
.
popLast
(
)
)
;
-
-
mNumTextureHandles
;
}
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
ClearEmptyTextureMemory
(
)
{
for
(
auto
pos
=
mSharedTextures
.
begin
(
)
;
pos
!
=
mSharedTextures
.
end
(
)
;
)
{
if
(
!
(
*
pos
)
-
>
HasAllocatedHandles
(
)
)
{
RefPtr
<
SharedTexture
>
shared
=
*
pos
;
size_t
usedBytes
=
shared
-
>
UsedBytes
(
)
;
mEmptyTextureMemory
-
=
usedBytes
;
mTotalTextureMemory
-
=
usedBytes
;
pos
=
mSharedTextures
.
erase
(
pos
)
;
mWebgl
-
>
DeleteTexture
(
shared
-
>
GetWebGLTexture
(
)
)
;
}
else
{
+
+
pos
;
}
}
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
ClearCachesIfNecessary
(
)
{
if
(
!
mShouldClearCaches
.
exchange
(
false
)
)
{
return
;
}
mZeroBuffer
=
nullptr
;
ClearAllTextures
(
)
;
if
(
mEmptyTextureMemory
)
{
ClearEmptyTextureMemory
(
)
;
}
ClearLastTexture
(
)
;
}
MOZ_THREAD_LOCAL
(
DrawTargetWebgl
:
:
SharedContext
*
)
DrawTargetWebgl
:
:
sSharedContext
;
bool
DrawTargetWebgl
:
:
Init
(
const
IntSize
&
size
const
SurfaceFormat
format
)
{
MOZ_ASSERT
(
format
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
format
=
=
SurfaceFormat
:
:
B8G8R8X8
)
;
mSize
=
size
;
mFormat
=
format
;
if
(
!
sSharedContext
.
init
(
)
)
{
return
false
;
}
DrawTargetWebgl
:
:
SharedContext
*
sharedContext
=
sSharedContext
.
get
(
)
;
if
(
!
sharedContext
|
|
sharedContext
-
>
IsContextLost
(
)
)
{
mSharedContext
=
new
DrawTargetWebgl
:
:
SharedContext
;
if
(
!
mSharedContext
-
>
Initialize
(
)
)
{
mSharedContext
=
nullptr
;
return
false
;
}
sSharedContext
.
set
(
mSharedContext
.
get
(
)
)
;
}
else
{
mSharedContext
=
sharedContext
;
}
if
(
size_t
(
std
:
:
max
(
size
.
width
size
.
height
)
)
>
mSharedContext
-
>
mMaxTextureSize
)
{
return
false
;
}
if
(
!
CreateFramebuffer
(
)
)
{
return
false
;
}
auto
*
child
=
mSharedContext
-
>
mWebgl
-
>
GetChild
(
)
;
if
(
child
&
&
child
-
>
CanSend
(
)
)
{
size_t
byteSize
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBBufferSize
(
mSize
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
byteSize
)
{
(
void
)
child
-
>
AllocUnsafeShmem
(
byteSize
&
mShmem
)
;
}
}
mSkia
=
new
DrawTargetSkia
;
if
(
mShmem
.
IsWritable
(
)
)
{
auto
stride
=
layers
:
:
ImageDataSerializer
:
:
ComputeRGBStride
(
SurfaceFormat
:
:
B8G8R8A8
size
.
width
)
;
if
(
!
mSkia
-
>
Init
(
mShmem
.
get
<
uint8_t
>
(
)
size
stride
SurfaceFormat
:
:
B8G8R8A8
true
)
)
{
return
false
;
}
}
else
if
(
!
mSkia
-
>
Init
(
size
SurfaceFormat
:
:
B8G8R8A8
)
)
{
return
false
;
}
SetPermitSubpixelAA
(
IsOpaque
(
format
)
)
;
return
true
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
Initialize
(
)
{
WebGLContextOptions
options
=
{
}
;
options
.
alpha
=
true
;
options
.
depth
=
false
;
options
.
stencil
=
false
;
options
.
antialias
=
false
;
options
.
preserveDrawingBuffer
=
true
;
options
.
failIfMajorPerformanceCaveat
=
true
;
mWebgl
=
new
ClientWebGLContext
(
true
)
;
mWebgl
-
>
SetContextOptions
(
options
)
;
if
(
mWebgl
-
>
SetDimensions
(
1
1
)
!
=
NS_OK
)
{
mWebgl
=
nullptr
;
return
false
;
}
mMaxTextureSize
=
mWebgl
-
>
Limits
(
)
.
maxTex2dSize
;
if
(
!
CreateShaders
(
)
)
{
mWebgl
=
nullptr
;
return
false
;
}
return
true
;
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
SetBlendState
(
CompositionOp
aOp
const
Maybe
<
DeviceColor
>
&
aColor
)
{
if
(
aOp
=
=
mLastCompositionOp
&
&
mLastBlendColor
=
=
aColor
)
{
return
;
}
mLastCompositionOp
=
aOp
;
mLastBlendColor
=
aColor
;
mDirtyAA
=
true
;
mWebgl
-
>
Enable
(
LOCAL_GL_BLEND
)
;
switch
(
aOp
)
{
case
CompositionOp
:
:
OP_OVER
:
if
(
aColor
)
{
mWebgl
-
>
BlendColor
(
aColor
-
>
b
aColor
-
>
g
aColor
-
>
r
1
.
0f
)
;
mWebgl
-
>
BlendFunc
(
LOCAL_GL_CONSTANT_COLOR
LOCAL_GL_ONE_MINUS_SRC_COLOR
)
;
}
else
{
mWebgl
-
>
BlendFunc
(
LOCAL_GL_ONE
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
}
break
;
case
CompositionOp
:
:
OP_ADD
:
mWebgl
-
>
BlendFunc
(
LOCAL_GL_ONE
LOCAL_GL_ONE
)
;
break
;
case
CompositionOp
:
:
OP_ATOP
:
mWebgl
-
>
BlendFunc
(
LOCAL_GL_DST_ALPHA
LOCAL_GL_ONE_MINUS_SRC_ALPHA
)
;
break
;
case
CompositionOp
:
:
OP_SOURCE
:
default
:
mWebgl
-
>
Disable
(
LOCAL_GL_BLEND
)
;
break
;
}
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
SetTarget
(
DrawTargetWebgl
*
aDT
)
{
if
(
!
mWebgl
|
|
mWebgl
-
>
IsContextLost
(
)
)
{
return
false
;
}
if
(
aDT
!
=
mCurrentTarget
)
{
mCurrentTarget
=
aDT
;
if
(
aDT
)
{
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
aDT
-
>
mFramebuffer
)
;
mViewportSize
=
aDT
-
>
GetSize
(
)
;
mWebgl
-
>
Viewport
(
0
0
mViewportSize
.
width
mViewportSize
.
height
)
;
mDirtyViewport
=
true
;
}
}
return
true
;
}
bool
DrawTargetWebgl
:
:
PrepareContext
(
bool
aClipped
)
{
if
(
!
aClipped
)
{
mSharedContext
-
>
SetClipRect
(
IntRect
(
IntPoint
(
)
mSize
)
)
;
mClipDirty
=
true
;
}
else
if
(
mClipDirty
|
|
!
mSharedContext
-
>
IsCurrentTarget
(
this
)
)
{
Maybe
<
Rect
>
clip
=
mSkia
-
>
GetDeviceClipRect
(
)
;
if
(
!
clip
)
{
return
false
;
}
IntRect
intClip
;
if
(
!
clip
-
>
IsEmpty
(
)
)
{
intClip
=
RoundedToInt
(
*
clip
)
;
if
(
!
clip
-
>
WithinEpsilonOf
(
Rect
(
intClip
)
1
.
0e
-
3f
)
)
{
return
false
;
}
if
(
intClip
.
Contains
(
IntRect
(
IntPoint
(
)
mSize
)
)
)
{
intClip
=
IntRect
(
IntPoint
(
)
mSize
)
;
}
}
mSharedContext
-
>
SetClipRect
(
intClip
)
;
mClipDirty
=
false
;
}
return
mSharedContext
-
>
SetTarget
(
this
)
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
IsContextLost
(
)
const
{
return
!
mWebgl
|
|
mWebgl
-
>
IsContextLost
(
)
;
}
bool
DrawTargetWebgl
:
:
IsValid
(
)
const
{
return
mSharedContext
&
&
!
mSharedContext
-
>
IsContextLost
(
)
;
}
already_AddRefed
<
DrawTargetWebgl
>
DrawTargetWebgl
:
:
Create
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
{
if
(
!
StaticPrefs
:
:
gfx_canvas_accelerated
(
)
)
{
return
nullptr
;
}
static
const
int32_t
kMinDimension
=
16
;
if
(
std
:
:
min
(
aSize
.
width
aSize
.
height
)
<
kMinDimension
)
{
return
nullptr
;
}
int32_t
minSize
=
StaticPrefs
:
:
gfx_canvas_accelerated_min_size
(
)
;
if
(
aSize
.
width
*
aSize
.
height
<
minSize
*
minSize
)
{
return
nullptr
;
}
int32_t
maxSize
=
StaticPrefs
:
:
gfx_canvas_accelerated_max_size
(
)
;
if
(
maxSize
>
0
)
{
if
(
std
:
:
max
(
aSize
.
width
aSize
.
height
)
>
maxSize
)
{
return
nullptr
;
}
}
else
if
(
maxSize
<
0
)
{
static
const
int32_t
kScreenPixels
=
980
*
480
;
IntSize
screenSize
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetScreenSize
(
)
;
if
(
aSize
.
width
*
aSize
.
height
>
std
:
:
max
(
screenSize
.
width
*
screenSize
.
height
kScreenPixels
)
)
{
return
nullptr
;
}
}
RefPtr
<
DrawTargetWebgl
>
dt
=
new
DrawTargetWebgl
;
if
(
!
dt
-
>
Init
(
aSize
aFormat
)
|
|
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
return
dt
.
forget
(
)
;
}
void
*
DrawTargetWebgl
:
:
GetNativeSurface
(
NativeSurfaceType
aType
)
{
switch
(
aType
)
{
case
NativeSurfaceType
:
:
WEBGL_CONTEXT
:
if
(
mSharedContext
-
>
IsContextLost
(
)
)
{
return
nullptr
;
}
if
(
!
mWebglValid
)
{
FlushFromSkia
(
)
;
}
return
mSharedContext
-
>
mWebgl
.
get
(
)
;
default
:
return
nullptr
;
}
}
already_AddRefed
<
TextureHandle
>
DrawTargetWebgl
:
:
SharedContext
:
:
WrapSnapshot
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
RefPtr
<
WebGLTextureJS
>
aTex
)
{
size_t
usedBytes
=
TextureHandle
:
:
UsedBytes
(
aFormat
aSize
)
;
PruneTextureMemory
(
usedBytes
false
)
;
RefPtr
<
StandaloneTexture
>
handle
=
new
StandaloneTexture
(
aSize
aFormat
aTex
.
forget
(
)
)
;
mStandaloneTextures
.
push_back
(
handle
)
;
mTextureHandles
.
insertFront
(
handle
)
;
mTotalTextureMemory
+
=
usedBytes
;
mUsedTextureMemory
+
=
usedBytes
;
+
+
mNumTextureHandles
;
return
handle
.
forget
(
)
;
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
SetTexFilter
(
WebGLTextureJS
*
aTex
bool
aFilter
)
{
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MAG_FILTER
aFilter
?
LOCAL_GL_LINEAR
:
LOCAL_GL_NEAREST
)
;
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MIN_FILTER
aFilter
?
LOCAL_GL_LINEAR
:
LOCAL_GL_NEAREST
)
;
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
InitTexParameters
(
WebGLTextureJS
*
aTex
)
{
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_S
LOCAL_GL_CLAMP_TO_EDGE
)
;
mWebgl
-
>
TexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_T
LOCAL_GL_CLAMP_TO_EDGE
)
;
SetTexFilter
(
aTex
true
)
;
}
already_AddRefed
<
TextureHandle
>
DrawTargetWebgl
:
:
SharedContext
:
:
CopySnapshot
(
)
{
RefPtr
<
WebGLTextureJS
>
tex
=
mWebgl
-
>
CreateTexture
(
)
;
if
(
!
tex
)
{
return
nullptr
;
}
SurfaceFormat
format
=
mCurrentTarget
-
>
GetFormat
(
)
;
IntSize
size
=
mCurrentTarget
-
>
GetSize
(
)
;
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
tex
)
;
mWebgl
-
>
TexStorage2D
(
LOCAL_GL_TEXTURE_2D
1
LOCAL_GL_RGBA8
size
.
width
size
.
height
)
;
InitTexParameters
(
tex
)
;
mWebgl
-
>
CopyTexSubImage2D
(
LOCAL_GL_TEXTURE_2D
0
0
0
0
0
size
.
width
size
.
height
)
;
ClearLastTexture
(
)
;
return
WrapSnapshot
(
size
format
tex
.
forget
(
)
)
;
}
already_AddRefed
<
TextureHandle
>
DrawTargetWebgl
:
:
CopySnapshot
(
)
{
AutoRestoreContext
restore
(
this
)
;
if
(
!
PrepareContext
(
false
)
)
{
return
nullptr
;
}
return
mSharedContext
-
>
CopySnapshot
(
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
GetDataSnapshot
(
)
{
if
(
!
mSkiaValid
)
{
ReadIntoSkia
(
)
;
}
else
if
(
mSkiaLayer
)
{
FlattenSkia
(
)
;
}
return
mSkia
-
>
Snapshot
(
mFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
Snapshot
(
)
{
if
(
mSkiaValid
)
{
return
GetDataSnapshot
(
)
;
}
if
(
!
mSnapshot
)
{
mSnapshot
=
new
SourceSurfaceWebgl
(
this
)
;
}
return
do_AddRef
(
mSnapshot
)
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
ReadInto
(
uint8_t
*
aDstData
int32_t
aDstStride
SurfaceFormat
aFormat
const
IntRect
&
aBounds
TextureHandle
*
aHandle
)
{
MOZ_ASSERT
(
aFormat
=
=
SurfaceFormat
:
:
B8G8R8A8
|
|
aFormat
=
=
SurfaceFormat
:
:
B8G8R8X8
)
;
if
(
aHandle
)
{
if
(
!
mScratchFramebuffer
)
{
mScratchFramebuffer
=
mWebgl
-
>
CreateFramebuffer
(
)
;
}
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mScratchFramebuffer
)
;
mWebgl
-
>
FramebufferTexture2D
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_COLOR_ATTACHMENT0
LOCAL_GL_TEXTURE_2D
aHandle
-
>
GetWebGLTexture
(
)
0
)
;
}
webgl
:
:
ReadPixelsDesc
desc
;
desc
.
srcOffset
=
*
ivec2
:
:
From
(
aBounds
)
;
desc
.
size
=
*
uvec2
:
:
FromSize
(
aBounds
)
;
desc
.
packState
.
rowLength
=
aDstStride
/
4
;
bool
success
=
false
;
if
(
mCurrentTarget
&
&
mCurrentTarget
-
>
mShmem
.
IsWritable
(
)
&
&
aDstData
=
=
mCurrentTarget
-
>
mShmem
.
get
<
uint8_t
>
(
)
)
{
success
=
mWebgl
-
>
DoReadPixels
(
desc
mCurrentTarget
-
>
mShmem
)
;
}
else
{
Range
<
uint8_t
>
range
=
{
aDstData
size_t
(
aDstStride
)
*
aBounds
.
height
}
;
success
=
mWebgl
-
>
DoReadPixels
(
desc
range
)
;
}
if
(
aHandle
&
&
mCurrentTarget
)
{
mWebgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mCurrentTarget
-
>
mFramebuffer
)
;
}
return
success
;
}
already_AddRefed
<
DataSourceSurface
>
DrawTargetWebgl
:
:
SharedContext
:
:
ReadSnapshot
(
TextureHandle
*
aHandle
)
{
SurfaceFormat
format
=
SurfaceFormat
:
:
UNKNOWN
;
IntRect
bounds
;
if
(
aHandle
)
{
format
=
aHandle
-
>
GetFormat
(
)
;
bounds
=
aHandle
-
>
GetBounds
(
)
;
}
else
{
format
=
mCurrentTarget
-
>
GetFormat
(
)
;
bounds
=
mCurrentTarget
-
>
GetRect
(
)
;
}
RefPtr
<
DataSourceSurface
>
surface
=
Factory
:
:
CreateDataSourceSurface
(
bounds
.
Size
(
)
format
)
;
if
(
!
surface
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
dstMap
(
surface
DataSourceSurface
:
:
WRITE
)
;
if
(
!
dstMap
.
IsMapped
(
)
|
|
!
ReadInto
(
dstMap
.
GetData
(
)
dstMap
.
GetStride
(
)
format
bounds
aHandle
)
)
{
return
nullptr
;
}
return
surface
.
forget
(
)
;
}
bool
DrawTargetWebgl
:
:
ReadInto
(
uint8_t
*
aDstData
int32_t
aDstStride
)
{
if
(
!
PrepareContext
(
false
)
)
{
return
false
;
}
return
mSharedContext
-
>
ReadInto
(
aDstData
aDstStride
GetFormat
(
)
GetRect
(
)
)
;
}
already_AddRefed
<
DataSourceSurface
>
DrawTargetWebgl
:
:
ReadSnapshot
(
)
{
AutoRestoreContext
restore
(
this
)
;
if
(
!
PrepareContext
(
false
)
)
{
return
nullptr
;
}
mProfile
.
OnReadback
(
)
;
return
mSharedContext
-
>
ReadSnapshot
(
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
GetBackingSurface
(
)
{
return
Snapshot
(
)
;
}
void
DrawTargetWebgl
:
:
DetachAllSnapshots
(
)
{
mSkia
-
>
DetachAllSnapshots
(
)
;
ClearSnapshot
(
)
;
}
bool
DrawTargetWebgl
:
:
MarkChanged
(
)
{
if
(
mSnapshot
)
{
ClearSnapshot
(
true
true
)
;
}
if
(
!
mWebglValid
&
&
!
FlushFromSkia
(
)
)
{
return
false
;
}
mSkiaValid
=
false
;
return
true
;
}
bool
DrawTargetWebgl
:
:
LockBits
(
uint8_t
*
*
aData
IntSize
*
aSize
int32_t
*
aStride
SurfaceFormat
*
aFormat
IntPoint
*
aOrigin
)
{
if
(
mSkiaValid
&
&
!
mSkiaLayer
)
{
MarkSkiaChanged
(
)
;
return
mSkia
-
>
LockBits
(
aData
aSize
aStride
aFormat
aOrigin
)
;
}
return
false
;
}
void
DrawTargetWebgl
:
:
ReleaseBits
(
uint8_t
*
aData
)
{
if
(
mSkiaValid
&
&
!
mSkiaLayer
)
{
mSkia
-
>
ReleaseBits
(
aData
)
;
}
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
CreateShaders
(
)
{
if
(
!
mVertexArray
)
{
mVertexArray
=
mWebgl
-
>
CreateVertexArray
(
)
;
}
if
(
!
mVertexBuffer
)
{
mVertexBuffer
=
mWebgl
-
>
CreateBuffer
(
)
;
static
const
float
rectData
[
8
]
=
{
0
.
0f
0
.
0f
1
.
0f
0
.
0f
1
.
0f
1
.
0f
0
.
0f
1
.
0f
}
;
mWebgl
-
>
BindVertexArray
(
mVertexArray
.
get
(
)
)
;
mWebgl
-
>
BindBuffer
(
LOCAL_GL_ARRAY_BUFFER
mVertexBuffer
.
get
(
)
)
;
mWebgl
-
>
RawBufferData
(
LOCAL_GL_ARRAY_BUFFER
(
const
uint8_t
*
)
rectData
sizeof
(
rectData
)
LOCAL_GL_STATIC_DRAW
)
;
mWebgl
-
>
EnableVertexAttribArray
(
0
)
;
mWebgl
-
>
VertexAttribPointer
(
0
2
LOCAL_GL_FLOAT
LOCAL_GL_FALSE
0
0
)
;
}
if
(
!
mSolidProgram
)
{
auto
vsSource
=
u
"
attribute
vec2
a_vertex
;
\
n
"
"
uniform
vec2
u_transform
[
3
]
;
\
n
"
"
uniform
vec2
u_viewport
;
\
n
"
"
uniform
float
u_aa
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
scale
=
vec2
(
dot
(
u_transform
[
0
]
u_transform
[
0
]
)
\
n
"
"
dot
(
u_transform
[
1
]
u_transform
[
1
]
)
)
;
\
n
"
"
vec2
invScale
=
u_aa
*
inversesqrt
(
scale
+
1
.
0e
-
6
)
;
\
n
"
"
scale
*
=
invScale
;
\
n
"
"
vec2
extrude
=
a_vertex
+
invScale
*
(
2
.
0
*
a_vertex
-
1
.
0
)
;
\
n
"
"
vec2
vertex
=
u_transform
[
0
]
*
extrude
.
x
+
\
n
"
"
u_transform
[
1
]
*
extrude
.
y
+
\
n
"
"
u_transform
[
2
]
;
\
n
"
"
gl_Position
=
vec4
(
vertex
*
2
.
0
/
u_viewport
-
1
.
0
0
.
0
1
.
0
)
;
\
n
"
"
v_dist
=
vec4
(
extrude
1
.
0
-
extrude
)
*
scale
.
xyxy
+
1
.
5
-
u_aa
;
\
n
"
"
}
\
n
"
_ns
;
auto
fsSource
=
u
"
precision
mediump
float
;
\
n
"
"
uniform
vec4
u_color
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
dist
=
min
(
v_dist
.
xy
v_dist
.
zw
)
;
\
n
"
"
float
aa
=
clamp
(
min
(
dist
.
x
dist
.
y
)
0
.
0
1
.
0
)
;
\
n
"
"
gl_FragColor
=
aa
*
u_color
;
\
n
"
"
}
\
n
"
_ns
;
RefPtr
<
WebGLShaderJS
>
vsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_VERTEX_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
vsId
vsSource
)
;
mWebgl
-
>
CompileShader
(
*
vsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
vsId
)
.
success
)
{
return
false
;
}
RefPtr
<
WebGLShaderJS
>
fsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_FRAGMENT_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
fsId
fsSource
)
;
mWebgl
-
>
CompileShader
(
*
fsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
fsId
)
.
success
)
{
return
false
;
}
mSolidProgram
=
mWebgl
-
>
CreateProgram
(
)
;
mWebgl
-
>
AttachShader
(
*
mSolidProgram
*
vsId
)
;
mWebgl
-
>
AttachShader
(
*
mSolidProgram
*
fsId
)
;
mWebgl
-
>
BindAttribLocation
(
*
mSolidProgram
0
u
"
a_vertex
"
_ns
)
;
mWebgl
-
>
LinkProgram
(
*
mSolidProgram
)
;
if
(
!
mWebgl
-
>
GetLinkResult
(
*
mSolidProgram
)
.
success
)
{
return
false
;
}
mSolidProgramViewport
=
mWebgl
-
>
GetUniformLocation
(
*
mSolidProgram
u
"
u_viewport
"
_ns
)
;
mSolidProgramAA
=
mWebgl
-
>
GetUniformLocation
(
*
mSolidProgram
u
"
u_aa
"
_ns
)
;
mSolidProgramTransform
=
mWebgl
-
>
GetUniformLocation
(
*
mSolidProgram
u
"
u_transform
"
_ns
)
;
mSolidProgramColor
=
mWebgl
-
>
GetUniformLocation
(
*
mSolidProgram
u
"
u_color
"
_ns
)
;
if
(
!
mSolidProgramViewport
|
|
!
mSolidProgramAA
|
|
!
mSolidProgramTransform
|
|
!
mSolidProgramColor
)
{
return
false
;
}
}
if
(
!
mImageProgram
)
{
auto
vsSource
=
u
"
attribute
vec2
a_vertex
;
\
n
"
"
varying
vec2
v_texcoord
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
uniform
vec2
u_viewport
;
\
n
"
"
uniform
float
u_aa
;
\
n
"
"
uniform
vec2
u_transform
[
3
]
;
\
n
"
"
uniform
vec2
u_texmatrix
[
3
]
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
scale
=
vec2
(
dot
(
u_transform
[
0
]
u_transform
[
0
]
)
\
n
"
"
dot
(
u_transform
[
1
]
u_transform
[
1
]
)
)
;
\
n
"
"
vec2
invScale
=
u_aa
*
inversesqrt
(
scale
+
1
.
0e
-
6
)
;
\
n
"
"
scale
*
=
invScale
;
\
n
"
"
vec2
extrude
=
a_vertex
+
invScale
*
(
2
.
0
*
a_vertex
-
1
.
0
)
;
\
n
"
"
vec2
vertex
=
u_transform
[
0
]
*
extrude
.
x
+
\
n
"
"
u_transform
[
1
]
*
extrude
.
y
+
\
n
"
"
u_transform
[
2
]
;
\
n
"
"
gl_Position
=
vec4
(
vertex
*
2
.
0
/
u_viewport
-
1
.
0
0
.
0
1
.
0
)
;
\
n
"
"
v_texcoord
=
u_texmatrix
[
0
]
*
extrude
.
x
+
\
n
"
"
u_texmatrix
[
1
]
*
extrude
.
y
+
\
n
"
"
u_texmatrix
[
2
]
;
\
n
"
"
v_dist
=
vec4
(
extrude
1
.
0
-
extrude
)
*
scale
.
xyxy
+
1
.
5
-
u_aa
;
\
n
"
"
}
\
n
"
_ns
;
auto
fsSource
=
u
"
precision
mediump
float
;
\
n
"
"
varying
vec2
v_texcoord
;
\
n
"
"
varying
vec4
v_dist
;
\
n
"
"
uniform
vec4
u_texbounds
;
\
n
"
"
uniform
vec4
u_color
;
\
n
"
"
uniform
float
u_swizzle
;
\
n
"
"
uniform
sampler2D
u_sampler
;
\
n
"
"
void
main
(
)
{
\
n
"
"
vec2
tc
=
clamp
(
v_texcoord
u_texbounds
.
xy
u_texbounds
.
zw
)
;
\
n
"
"
vec4
image
=
texture2D
(
u_sampler
tc
)
;
\
n
"
"
vec2
dist
=
min
(
v_dist
.
xy
v_dist
.
zw
)
;
\
n
"
"
float
aa
=
clamp
(
min
(
dist
.
x
dist
.
y
)
0
.
0
1
.
0
)
;
\
n
"
"
gl_FragColor
=
aa
*
u_color
*
mix
(
image
image
.
rrrr
u_swizzle
)
;
\
n
"
"
}
\
n
"
_ns
;
RefPtr
<
WebGLShaderJS
>
vsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_VERTEX_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
vsId
vsSource
)
;
mWebgl
-
>
CompileShader
(
*
vsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
vsId
)
.
success
)
{
return
false
;
}
RefPtr
<
WebGLShaderJS
>
fsId
=
mWebgl
-
>
CreateShader
(
LOCAL_GL_FRAGMENT_SHADER
)
;
mWebgl
-
>
ShaderSource
(
*
fsId
fsSource
)
;
mWebgl
-
>
CompileShader
(
*
fsId
)
;
if
(
!
mWebgl
-
>
GetCompileResult
(
*
fsId
)
.
success
)
{
return
false
;
}
mImageProgram
=
mWebgl
-
>
CreateProgram
(
)
;
mWebgl
-
>
AttachShader
(
*
mImageProgram
*
vsId
)
;
mWebgl
-
>
AttachShader
(
*
mImageProgram
*
fsId
)
;
mWebgl
-
>
BindAttribLocation
(
*
mImageProgram
0
u
"
a_vertex
"
_ns
)
;
mWebgl
-
>
LinkProgram
(
*
mImageProgram
)
;
if
(
!
mWebgl
-
>
GetLinkResult
(
*
mImageProgram
)
.
success
)
{
return
false
;
}
mImageProgramViewport
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_viewport
"
_ns
)
;
mImageProgramAA
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_aa
"
_ns
)
;
mImageProgramTransform
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_transform
"
_ns
)
;
mImageProgramTexMatrix
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_texmatrix
"
_ns
)
;
mImageProgramTexBounds
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_texbounds
"
_ns
)
;
mImageProgramSwizzle
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_swizzle
"
_ns
)
;
mImageProgramColor
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_color
"
_ns
)
;
mImageProgramSampler
=
mWebgl
-
>
GetUniformLocation
(
*
mImageProgram
u
"
u_sampler
"
_ns
)
;
if
(
!
mImageProgramViewport
|
|
!
mImageProgramAA
|
|
!
mImageProgramTransform
|
|
!
mImageProgramTexMatrix
|
|
!
mImageProgramTexBounds
|
|
!
mImageProgramSwizzle
|
|
!
mImageProgramColor
|
|
!
mImageProgramSampler
)
{
return
false
;
}
mWebgl
-
>
UseProgram
(
mImageProgram
)
;
int32_t
samplerData
=
0
;
mWebgl
-
>
UniformData
(
LOCAL_GL_INT
mImageProgramSampler
false
{
(
const
uint8_t
*
)
&
samplerData
sizeof
(
samplerData
)
}
)
;
}
return
true
;
}
void
DrawTargetWebgl
:
:
ClearRect
(
const
Rect
&
aRect
)
{
PushClipRect
(
aRect
)
;
ColorPattern
pattern
(
DeviceColor
(
0
.
0f
0
.
0f
0
.
0f
IsOpaque
(
mFormat
)
?
1
.
0f
:
0
.
0f
)
)
;
DrawRect
(
aRect
pattern
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
PopClip
(
)
;
}
bool
DrawTargetWebgl
:
:
CreateFramebuffer
(
)
{
RefPtr
<
ClientWebGLContext
>
webgl
=
mSharedContext
-
>
mWebgl
;
if
(
!
mFramebuffer
)
{
mFramebuffer
=
webgl
-
>
CreateFramebuffer
(
)
;
}
if
(
!
mTex
)
{
mTex
=
webgl
-
>
CreateTexture
(
)
;
webgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
mTex
)
;
webgl
-
>
TexStorage2D
(
LOCAL_GL_TEXTURE_2D
1
LOCAL_GL_RGBA8
mSize
.
width
mSize
.
height
)
;
mSharedContext
-
>
InitTexParameters
(
mTex
)
;
webgl
-
>
BindFramebuffer
(
LOCAL_GL_FRAMEBUFFER
mFramebuffer
)
;
webgl
-
>
FramebufferTexture2D
(
LOCAL_GL_FRAMEBUFFER
LOCAL_GL_COLOR_ATTACHMENT0
LOCAL_GL_TEXTURE_2D
mTex
0
)
;
webgl
-
>
Viewport
(
0
0
mSize
.
width
mSize
.
height
)
;
webgl
-
>
ClearColor
(
0
.
0f
0
.
0f
0
.
0f
IsOpaque
(
mFormat
)
?
1
.
0f
:
0
.
0f
)
;
webgl
-
>
Clear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
mSharedContext
-
>
ClearTarget
(
)
;
mSharedContext
-
>
ClearLastTexture
(
)
;
}
return
true
;
}
void
DrawTargetWebgl
:
:
CopySurface
(
SourceSurface
*
aSurface
const
IntRect
&
aSourceRect
const
IntPoint
&
aDestination
)
{
if
(
mSkiaValid
)
{
if
(
mSkiaLayer
)
{
if
(
IntRect
(
aDestination
aSourceRect
.
Size
(
)
)
.
Contains
(
GetRect
(
)
)
)
{
mSkiaLayer
=
false
;
}
else
if
(
!
IsOpaque
(
aSurface
-
>
GetFormat
(
)
)
)
{
FlattenSkia
(
)
;
}
}
else
{
MarkSkiaChanged
(
)
;
}
mSkia
-
>
CopySurface
(
aSurface
aSourceRect
aDestination
)
;
return
;
}
Matrix
matrix
=
Matrix
:
:
Translation
(
aDestination
-
aSourceRect
.
TopLeft
(
)
)
;
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
matrix
)
;
DrawRect
(
Rect
(
IntRect
(
aDestination
aSourceRect
.
Size
(
)
)
)
pattern
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
Nothing
(
)
nullptr
false
false
)
;
}
void
DrawTargetWebgl
:
:
PushClip
(
const
Path
*
aPath
)
{
mClipDirty
=
true
;
mSkia
-
>
PushClip
(
aPath
)
;
}
void
DrawTargetWebgl
:
:
PushClipRect
(
const
Rect
&
aRect
)
{
mClipDirty
=
true
;
mSkia
-
>
PushClipRect
(
aRect
)
;
}
void
DrawTargetWebgl
:
:
PushDeviceSpaceClipRects
(
const
IntRect
*
aRects
uint32_t
aCount
)
{
mClipDirty
=
true
;
mSkia
-
>
PushDeviceSpaceClipRects
(
aRects
aCount
)
;
}
void
DrawTargetWebgl
:
:
PopClip
(
)
{
mClipDirty
=
true
;
mSkia
-
>
PopClip
(
)
;
}
static
inline
bool
SupportsDrawOptions
(
const
DrawOptions
&
aOptions
)
{
switch
(
aOptions
.
mCompositionOp
)
{
case
CompositionOp
:
:
OP_OVER
:
case
CompositionOp
:
:
OP_ADD
:
case
CompositionOp
:
:
OP_ATOP
:
case
CompositionOp
:
:
OP_SOURCE
:
return
true
;
default
:
return
false
;
}
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
SupportsPattern
(
const
Pattern
&
aPattern
)
{
switch
(
aPattern
.
GetType
(
)
)
{
case
PatternType
:
:
COLOR
:
return
true
;
case
PatternType
:
:
SURFACE
:
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
if
(
surfacePattern
.
mExtendMode
!
=
ExtendMode
:
:
CLAMP
)
{
return
false
;
}
if
(
surfacePattern
.
mSurface
)
{
IntSize
size
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
int32_t
maxSize
=
int32_t
(
std
:
:
min
(
StaticPrefs
:
:
gfx_canvas_accelerated_max_surface_size
(
)
mMaxTextureSize
)
)
;
if
(
std
:
:
max
(
size
.
width
size
.
height
)
>
maxSize
&
&
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
|
|
std
:
:
max
(
surfacePattern
.
mSamplingRect
.
width
surfacePattern
.
mSamplingRect
.
height
)
>
maxSize
)
)
{
return
false
;
}
}
return
true
;
}
default
:
return
false
;
}
}
static
inline
bool
SupportsLayering
(
const
DrawOptions
&
aOptions
)
{
switch
(
aOptions
.
mCompositionOp
)
{
case
CompositionOp
:
:
OP_OVER
:
return
true
;
default
:
return
false
;
}
}
static
void
ReleaseTextureHandle
(
void
*
aPtr
)
{
static_cast
<
TextureHandle
*
>
(
aPtr
)
-
>
SetSurface
(
nullptr
)
;
}
bool
DrawTargetWebgl
:
:
DrawRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
Maybe
<
DeviceColor
>
aMaskColor
RefPtr
<
TextureHandle
>
*
aHandle
bool
aTransformed
bool
aClipped
bool
aAccelOnly
bool
aForceUpdate
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
mWebglValid
|
|
(
mSkiaLayer
&
&
!
mLayerDepth
&
&
(
aAccelOnly
|
|
!
SupportsLayering
(
aOptions
)
)
)
)
{
if
(
PrepareContext
(
aClipped
)
)
{
return
mSharedContext
-
>
DrawRectAccel
(
aRect
aPattern
aOptions
aMaskColor
aHandle
aTransformed
aClipped
aAccelOnly
aForceUpdate
aStrokeOptions
)
;
}
}
if
(
!
aAccelOnly
)
{
DrawRectFallback
(
aRect
aPattern
aOptions
aMaskColor
aTransformed
aClipped
aStrokeOptions
)
;
}
return
false
;
}
void
DrawTargetWebgl
:
:
DrawRectFallback
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
Maybe
<
DeviceColor
>
aMaskColor
bool
aTransformed
bool
aClipped
const
StrokeOptions
*
aStrokeOptions
)
{
MarkSkiaChanged
(
aOptions
)
;
if
(
aTransformed
)
{
if
(
aMaskColor
)
{
mSkia
-
>
Mask
(
ColorPattern
(
*
aMaskColor
)
aPattern
aOptions
)
;
}
else
if
(
aStrokeOptions
)
{
mSkia
-
>
StrokeRect
(
aRect
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
}
else
if
(
aClipped
)
{
mSkia
-
>
SetTransform
(
Matrix
(
)
)
;
if
(
aMaskColor
)
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
if
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
)
{
mSkia
-
>
MaskSurface
(
ColorPattern
(
*
aMaskColor
)
surfacePattern
.
mSurface
aRect
.
TopLeft
(
)
aOptions
)
;
}
else
{
mSkia
-
>
Mask
(
ColorPattern
(
*
aMaskColor
)
aPattern
aOptions
)
;
}
}
else
if
(
aStrokeOptions
)
{
mSkia
-
>
StrokeRect
(
aRect
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
mSkia
-
>
SetTransform
(
mTransform
)
;
}
else
if
(
aPattern
.
GetType
(
)
=
=
PatternType
:
:
SURFACE
)
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
mSkia
-
>
CopySurface
(
surfacePattern
.
mSurface
surfacePattern
.
mSurface
-
>
GetRect
(
)
IntPoint
:
:
Round
(
aRect
.
TopLeft
(
)
)
)
;
}
else
{
MOZ_ASSERT
(
false
)
;
}
}
inline
already_AddRefed
<
WebGLTextureJS
>
DrawTargetWebgl
:
:
SharedContext
:
:
GetCompatibleSnapshot
(
SourceSurface
*
aSurface
)
{
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
WEBGL
)
{
RefPtr
<
SourceSurfaceWebgl
>
webglSurf
=
static_cast
<
SourceSurfaceWebgl
*
>
(
aSurface
)
;
if
(
this
=
=
webglSurf
-
>
mSharedContext
)
{
if
(
webglSurf
-
>
mHandle
)
{
return
do_AddRef
(
webglSurf
-
>
mHandle
-
>
GetWebGLTexture
(
)
)
;
}
if
(
RefPtr
<
DrawTargetWebgl
>
webglDT
=
webglSurf
-
>
GetTarget
(
)
)
{
if
(
!
IsCurrentTarget
(
webglDT
)
)
{
return
do_AddRef
(
webglDT
-
>
mTex
)
;
}
}
}
}
return
nullptr
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
UploadSurface
(
DataSourceSurface
*
aData
SurfaceFormat
aFormat
const
IntRect
&
aSrcRect
const
IntPoint
&
aDstOffset
bool
aInit
bool
aZero
)
{
webgl
:
:
TexUnpackBlobDesc
texDesc
=
{
LOCAL_GL_TEXTURE_2D
{
uint32_t
(
aSrcRect
.
width
)
uint32_t
(
aSrcRect
.
height
)
1
}
}
;
if
(
aData
)
{
DataSourceSurface
:
:
ScopedMap
map
(
aData
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
false
;
}
int32_t
stride
=
map
.
GetStride
(
)
;
int32_t
bpp
=
BytesPerPixel
(
aFormat
)
;
if
(
mCurrentTarget
&
&
mCurrentTarget
-
>
mShmem
.
IsWritable
(
)
&
&
map
.
GetData
(
)
=
=
mCurrentTarget
-
>
mShmem
.
get
<
uint8_t
>
(
)
)
{
texDesc
.
sd
=
Some
(
layers
:
:
SurfaceDescriptorBuffer
(
layers
:
:
RGBDescriptor
(
mCurrentTarget
-
>
mSize
SurfaceFormat
:
:
R8G8B8A8
)
mCurrentTarget
-
>
mShmem
)
)
;
texDesc
.
structuredSrcSize
=
uvec2
:
:
From
(
stride
/
bpp
mCurrentTarget
-
>
mSize
.
height
)
;
texDesc
.
unpacking
.
skipPixels
=
aSrcRect
.
x
;
texDesc
.
unpacking
.
skipRows
=
aSrcRect
.
y
;
mWaitForShmem
=
true
;
}
else
{
Range
<
const
uint8_t
>
range
(
map
.
GetData
(
)
+
aSrcRect
.
y
*
size_t
(
stride
)
+
aSrcRect
.
x
*
bpp
std
:
:
max
(
aSrcRect
.
height
-
1
0
)
*
size_t
(
stride
)
+
aSrcRect
.
width
*
bpp
)
;
texDesc
.
cpuData
=
Some
(
RawBuffer
(
range
)
)
;
}
texDesc
.
unpacking
.
alignmentInTypeElems
=
stride
%
4
?
1
:
4
;
texDesc
.
unpacking
.
rowLength
=
stride
/
bpp
;
}
else
if
(
aZero
)
{
MOZ_ASSERT
(
aSrcRect
.
TopLeft
(
)
=
=
IntPoint
(
0
0
)
)
;
if
(
!
mZeroBuffer
|
|
mZeroSize
.
width
<
aSrcRect
.
width
|
|
mZeroSize
.
height
<
aSrcRect
.
height
)
{
mZeroBuffer
=
mWebgl
-
>
CreateBuffer
(
)
;
mZeroSize
=
aSrcRect
.
Size
(
)
;
mWebgl
-
>
BindBuffer
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
mZeroBuffer
)
;
size_t
size
=
4
*
mZeroSize
.
width
*
mZeroSize
.
height
;
mWebgl
-
>
RawBufferData
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
nullptr
size
LOCAL_GL_STATIC_DRAW
)
;
}
else
{
mWebgl
-
>
BindBuffer
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
mZeroBuffer
)
;
}
texDesc
.
pboOffset
=
Some
(
0
)
;
}
GLenum
intFormat
=
aFormat
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_R8
:
LOCAL_GL_RGBA8
;
GLenum
extFormat
=
aFormat
=
=
SurfaceFormat
:
:
A8
?
LOCAL_GL_RED
:
LOCAL_GL_RGBA
;
webgl
:
:
PackingInfo
texPI
=
{
extFormat
LOCAL_GL_UNSIGNED_BYTE
}
;
mWebgl
-
>
RawTexImage
(
0
aInit
?
intFormat
:
0
{
uint32_t
(
aDstOffset
.
x
)
uint32_t
(
aDstOffset
.
y
)
0
}
texPI
std
:
:
move
(
texDesc
)
)
;
if
(
!
aData
&
&
aZero
)
{
mWebgl
-
>
BindBuffer
(
LOCAL_GL_PIXEL_UNPACK_BUFFER
0
)
;
}
return
true
;
}
static
inline
SamplingFilter
GetSamplingFilter
(
const
Pattern
&
aPattern
)
{
return
aPattern
.
GetType
(
)
=
=
PatternType
:
:
SURFACE
?
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
.
mSamplingFilter
:
SamplingFilter
:
:
GOOD
;
}
static
inline
bool
UseNearestFilter
(
const
Pattern
&
aPattern
)
{
return
GetSamplingFilter
(
aPattern
)
=
=
SamplingFilter
:
:
POINT
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
DrawRectAccel
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
Maybe
<
DeviceColor
>
aMaskColor
RefPtr
<
TextureHandle
>
*
aHandle
bool
aTransformed
bool
aClipped
bool
aAccelOnly
bool
aForceUpdate
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
aRect
.
IsEmpty
(
)
|
|
mClipRect
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
!
SupportsPattern
(
aPattern
)
|
|
!
mCurrentTarget
-
>
MarkChanged
(
)
)
{
if
(
!
aAccelOnly
)
{
mCurrentTarget
-
>
DrawRectFallback
(
aRect
aPattern
aOptions
aMaskColor
aTransformed
aClipped
aStrokeOptions
)
;
}
return
false
;
}
bool
scissor
=
false
;
if
(
!
mClipRect
.
Contains
(
IntRect
(
IntPoint
(
)
mViewportSize
)
)
)
{
scissor
=
true
;
mWebgl
-
>
Enable
(
LOCAL_GL_SCISSOR_TEST
)
;
mWebgl
-
>
Scissor
(
mClipRect
.
x
mClipRect
.
y
mClipRect
.
width
mClipRect
.
height
)
;
}
const
Matrix
&
currentTransform
=
GetTransform
(
)
;
bool
success
=
false
;
switch
(
aPattern
.
GetType
(
)
)
{
case
PatternType
:
:
COLOR
:
{
mCurrentTarget
-
>
mProfile
.
OnUncachedDraw
(
)
;
auto
color
=
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
;
if
(
(
(
color
.
a
*
aOptions
.
mAlpha
=
=
1
.
0f
&
&
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_OVER
)
|
|
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
)
&
&
(
!
aTransformed
|
|
currentTransform
.
HasOnlyIntegerTranslation
(
)
)
&
&
!
aStrokeOptions
)
{
auto
intRect
=
RoundedToInt
(
aRect
)
;
if
(
aRect
.
WithinEpsilonOf
(
Rect
(
intRect
)
1
.
0e
-
3f
)
)
{
if
(
aTransformed
)
{
intRect
+
=
RoundedToInt
(
currentTransform
.
GetTranslation
(
)
)
;
}
if
(
!
intRect
.
Contains
(
mClipRect
)
)
{
scissor
=
true
;
mWebgl
-
>
Enable
(
LOCAL_GL_SCISSOR_TEST
)
;
intRect
=
intRect
.
Intersect
(
mClipRect
)
;
mWebgl
-
>
Scissor
(
intRect
.
x
intRect
.
y
intRect
.
width
intRect
.
height
)
;
}
float
a
=
color
.
a
*
aOptions
.
mAlpha
;
mWebgl
-
>
ClearColor
(
color
.
b
*
a
color
.
g
*
a
color
.
r
*
a
a
)
;
mWebgl
-
>
Clear
(
LOCAL_GL_COLOR_BUFFER_BIT
)
;
success
=
true
;
break
;
}
}
SetBlendState
(
aOptions
.
mCompositionOp
)
;
if
(
mLastProgram
!
=
mSolidProgram
)
{
mWebgl
-
>
UseProgram
(
mSolidProgram
)
;
mLastProgram
=
mSolidProgram
;
mDirtyViewport
=
true
;
mDirtyAA
=
true
;
}
if
(
mDirtyViewport
)
{
float
viewportData
[
2
]
=
{
float
(
mViewportSize
.
width
)
float
(
mViewportSize
.
height
)
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mSolidProgramViewport
false
{
(
const
uint8_t
*
)
viewportData
sizeof
(
viewportData
)
}
)
;
mDirtyViewport
=
false
;
}
if
(
mDirtyAA
|
|
aStrokeOptions
)
{
float
aaData
=
mLastCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
|
|
aStrokeOptions
?
0
.
0f
:
1
.
0f
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT
mSolidProgramAA
false
{
(
const
uint8_t
*
)
&
aaData
sizeof
(
aaData
)
}
)
;
mDirtyAA
=
!
!
aStrokeOptions
;
}
float
a
=
color
.
a
*
aOptions
.
mAlpha
;
float
colorData
[
4
]
=
{
color
.
b
*
a
color
.
g
*
a
color
.
r
*
a
a
}
;
Matrix
xform
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
if
(
aTransformed
)
{
xform
*
=
currentTransform
;
}
float
xformData
[
6
]
=
{
xform
.
_11
xform
.
_12
xform
.
_21
xform
.
_22
xform
.
_31
xform
.
_32
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mSolidProgramTransform
false
{
(
const
uint8_t
*
)
xformData
sizeof
(
xformData
)
}
)
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC4
mSolidProgramColor
false
{
(
const
uint8_t
*
)
colorData
sizeof
(
colorData
)
}
)
;
mWebgl
-
>
DrawArrays
(
aStrokeOptions
?
LOCAL_GL_LINE_LOOP
:
LOCAL_GL_TRIANGLE_FAN
0
4
)
;
success
=
true
;
break
;
}
case
PatternType
:
:
SURFACE
:
{
auto
surfacePattern
=
static_cast
<
const
SurfacePattern
&
>
(
aPattern
)
;
RefPtr
<
TextureHandle
>
handle
=
aHandle
?
aHandle
-
>
get
(
)
:
(
surfacePattern
.
mSurface
?
static_cast
<
TextureHandle
*
>
(
surfacePattern
.
mSurface
-
>
GetUserData
(
&
mTextureHandleKey
)
)
:
nullptr
)
;
IntSize
texSize
;
IntPoint
offset
;
SurfaceFormat
format
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
&
&
(
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
|
|
handle
-
>
GetSamplingRect
(
)
.
IsEqualEdges
(
surfacePattern
.
mSamplingRect
)
)
)
{
texSize
=
handle
-
>
GetSize
(
)
;
format
=
handle
-
>
GetFormat
(
)
;
offset
=
handle
-
>
GetSamplingOffset
(
)
;
}
else
{
handle
=
nullptr
;
if
(
!
surfacePattern
.
mSurface
)
{
break
;
}
texSize
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
format
=
surfacePattern
.
mSurface
-
>
GetFormat
(
)
;
if
(
!
surfacePattern
.
mSamplingRect
.
IsEmpty
(
)
)
{
texSize
=
surfacePattern
.
mSamplingRect
.
Size
(
)
;
offset
=
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
;
}
}
RefPtr
<
WebGLTextureJS
>
tex
;
IntRect
bounds
;
IntSize
backingSize
;
RefPtr
<
DataSourceSurface
>
data
;
bool
init
=
false
;
if
(
handle
)
{
if
(
aForceUpdate
)
{
data
=
surfacePattern
.
mSurface
-
>
GetDataSurface
(
)
;
if
(
!
data
)
{
break
;
}
mUsedTextureMemory
-
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
UpdateSize
(
texSize
)
;
mUsedTextureMemory
+
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
SetSamplingOffset
(
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
)
;
}
handle
-
>
remove
(
)
;
mTextureHandles
.
insertFront
(
handle
)
;
}
else
if
(
(
tex
=
GetCompatibleSnapshot
(
surfacePattern
.
mSurface
)
)
)
{
backingSize
=
surfacePattern
.
mSurface
-
>
GetSize
(
)
;
bounds
=
IntRect
(
offset
texSize
)
;
mCurrentTarget
-
>
mProfile
.
OnCacheHit
(
)
;
}
else
{
data
=
surfacePattern
.
mSurface
-
>
GetDataSurface
(
)
;
if
(
!
data
)
{
break
;
}
size_t
usedBytes
=
TextureHandle
:
:
UsedBytes
(
format
texSize
)
;
PruneTextureMemory
(
usedBytes
false
)
;
int32_t
pageSize
=
int32_t
(
std
:
:
min
(
StaticPrefs
:
:
gfx_canvas_accelerated_shared_page_size
(
)
mMaxTextureSize
)
)
;
if
(
!
aForceUpdate
&
&
std
:
:
max
(
texSize
.
width
texSize
.
height
)
<
=
pageSize
/
2
)
{
for
(
auto
&
shared
:
mSharedTextures
)
{
if
(
shared
-
>
GetFormat
(
)
=
=
format
)
{
bool
wasEmpty
=
!
shared
-
>
HasAllocatedHandles
(
)
;
handle
=
shared
-
>
Allocate
(
texSize
)
;
if
(
handle
)
{
if
(
wasEmpty
)
{
mEmptyTextureMemory
-
=
shared
-
>
UsedBytes
(
)
;
}
break
;
}
}
}
if
(
!
handle
)
{
tex
=
mWebgl
-
>
CreateTexture
(
)
;
if
(
!
tex
)
{
MOZ_ASSERT
(
false
)
;
break
;
}
RefPtr
<
SharedTexture
>
shared
=
new
SharedTexture
(
IntSize
(
pageSize
pageSize
)
format
tex
)
;
mSharedTextures
.
push_back
(
shared
)
;
mTotalTextureMemory
+
=
shared
-
>
UsedBytes
(
)
;
handle
=
shared
-
>
Allocate
(
texSize
)
;
if
(
!
handle
)
{
MOZ_ASSERT
(
false
)
;
break
;
}
init
=
true
;
}
}
else
{
tex
=
mWebgl
-
>
CreateTexture
(
)
;
if
(
!
tex
)
{
MOZ_ASSERT
(
false
)
;
break
;
}
RefPtr
<
StandaloneTexture
>
standalone
=
new
StandaloneTexture
(
texSize
format
tex
)
;
mStandaloneTextures
.
push_back
(
standalone
)
;
mTotalTextureMemory
+
=
standalone
-
>
UsedBytes
(
)
;
handle
=
standalone
;
init
=
true
;
}
mTextureHandles
.
insertFront
(
handle
)
;
+
+
mNumTextureHandles
;
mUsedTextureMemory
+
=
handle
-
>
UsedBytes
(
)
;
handle
-
>
SetSamplingOffset
(
surfacePattern
.
mSamplingRect
.
TopLeft
(
)
)
;
if
(
aHandle
)
{
*
aHandle
=
handle
;
}
else
{
handle
-
>
SetSurface
(
surfacePattern
.
mSurface
)
;
surfacePattern
.
mSurface
-
>
AddUserData
(
&
mTextureHandleKey
handle
.
get
(
)
ReleaseTextureHandle
)
;
}
}
SetBlendState
(
aOptions
.
mCompositionOp
format
!
=
SurfaceFormat
:
:
A8
?
aMaskColor
:
Nothing
(
)
)
;
if
(
mLastProgram
!
=
mImageProgram
)
{
mWebgl
-
>
UseProgram
(
mImageProgram
)
;
mLastProgram
=
mImageProgram
;
mDirtyViewport
=
true
;
mDirtyAA
=
true
;
}
if
(
mDirtyViewport
)
{
float
viewportData
[
2
]
=
{
float
(
mViewportSize
.
width
)
float
(
mViewportSize
.
height
)
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramViewport
false
{
(
const
uint8_t
*
)
viewportData
sizeof
(
viewportData
)
}
)
;
mDirtyViewport
=
false
;
}
if
(
mDirtyAA
|
|
aStrokeOptions
)
{
float
aaData
=
mLastCompositionOp
=
=
CompositionOp
:
:
OP_SOURCE
|
|
aStrokeOptions
?
0
.
0f
:
1
.
0f
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT
mImageProgramAA
false
{
(
const
uint8_t
*
)
&
aaData
sizeof
(
aaData
)
}
)
;
mDirtyAA
=
!
!
aStrokeOptions
;
}
DeviceColor
color
=
aMaskColor
&
&
format
!
=
SurfaceFormat
:
:
A8
?
DeviceColor
:
:
Mask
(
1
.
0f
aMaskColor
-
>
a
)
:
aMaskColor
.
valueOr
(
DeviceColor
(
1
1
1
1
)
)
;
float
a
=
color
.
a
*
aOptions
.
mAlpha
;
float
colorData
[
4
]
=
{
color
.
b
*
a
color
.
g
*
a
color
.
r
*
a
a
}
;
float
swizzleData
=
aMaskColor
&
&
format
=
=
SurfaceFormat
:
:
A8
?
1
.
0f
:
0
.
0f
;
Matrix
xform
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
if
(
aTransformed
)
{
xform
*
=
currentTransform
;
}
float
xformData
[
6
]
=
{
xform
.
_11
xform
.
_12
xform
.
_21
xform
.
_22
xform
.
_31
xform
.
_32
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramTransform
false
{
(
const
uint8_t
*
)
xformData
sizeof
(
xformData
)
}
)
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC4
mImageProgramColor
false
{
(
const
uint8_t
*
)
colorData
sizeof
(
colorData
)
}
)
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT
mImageProgramSwizzle
false
{
(
const
uint8_t
*
)
&
swizzleData
sizeof
(
swizzleData
)
}
)
;
if
(
handle
)
{
if
(
!
tex
)
{
tex
=
handle
-
>
GetWebGLTexture
(
)
;
}
bounds
=
handle
-
>
GetBounds
(
)
;
backingSize
=
handle
-
>
GetBackingSize
(
)
;
}
if
(
mLastTexture
!
=
tex
)
{
mWebgl
-
>
BindTexture
(
LOCAL_GL_TEXTURE_2D
tex
)
;
mLastTexture
=
tex
;
}
if
(
init
)
{
InitTexParameters
(
tex
)
;
if
(
texSize
!
=
backingSize
)
{
UploadSurface
(
nullptr
format
IntRect
(
IntPoint
(
)
backingSize
)
IntPoint
(
)
true
true
)
;
}
}
if
(
data
)
{
UploadSurface
(
data
format
IntRect
(
offset
texSize
)
bounds
.
TopLeft
(
)
texSize
=
=
backingSize
)
;
mCurrentTarget
-
>
mProfile
.
OnCacheMiss
(
)
;
}
else
{
mCurrentTarget
-
>
mProfile
.
OnCacheHit
(
)
;
}
Size
backingSizeF
(
backingSize
)
;
Matrix
uvMatrix
(
aRect
.
width
0
.
0f
0
.
0f
aRect
.
height
aRect
.
x
aRect
.
y
)
;
uvMatrix
*
=
surfacePattern
.
mMatrix
.
Inverse
(
)
;
uvMatrix
*
=
Matrix
(
1
.
0f
/
backingSizeF
.
width
0
.
0f
0
.
0f
1
.
0f
/
backingSizeF
.
height
float
(
bounds
.
x
-
offset
.
x
)
/
backingSizeF
.
width
float
(
bounds
.
y
-
offset
.
y
)
/
backingSizeF
.
height
)
;
float
uvData
[
6
]
=
{
uvMatrix
.
_11
uvMatrix
.
_12
uvMatrix
.
_21
uvMatrix
.
_22
uvMatrix
.
_31
uvMatrix
.
_32
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC2
mImageProgramTexMatrix
false
{
(
const
uint8_t
*
)
uvData
sizeof
(
uvData
)
}
)
;
float
texBounds
[
4
]
=
{
(
bounds
.
x
+
0
.
5f
)
/
backingSizeF
.
width
(
bounds
.
y
+
0
.
5f
)
/
backingSizeF
.
height
(
bounds
.
XMost
(
)
-
0
.
5f
)
/
backingSizeF
.
width
(
bounds
.
YMost
(
)
-
0
.
5f
)
/
backingSizeF
.
height
}
;
mWebgl
-
>
UniformData
(
LOCAL_GL_FLOAT_VEC4
mImageProgramTexBounds
false
{
(
const
uint8_t
*
)
texBounds
sizeof
(
texBounds
)
}
)
;
if
(
UseNearestFilter
(
surfacePattern
)
)
{
SetTexFilter
(
tex
false
)
;
}
mWebgl
-
>
DrawArrays
(
aStrokeOptions
?
LOCAL_GL_LINE_LOOP
:
LOCAL_GL_TRIANGLE_FAN
0
4
)
;
if
(
UseNearestFilter
(
surfacePattern
)
)
{
SetTexFilter
(
tex
true
)
;
}
success
=
true
;
break
;
}
default
:
gfxWarning
(
)
<
<
"
Unknown
DrawTargetWebgl
:
:
DrawRect
pattern
type
:
"
<
<
(
int
)
aPattern
.
GetType
(
)
;
break
;
}
if
(
scissor
)
{
mWebgl
-
>
Disable
(
LOCAL_GL_SCISSOR_TEST
)
;
}
return
success
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
RemoveSharedTexture
(
const
RefPtr
<
SharedTexture
>
&
aTexture
)
{
auto
pos
=
std
:
:
find
(
mSharedTextures
.
begin
(
)
mSharedTextures
.
end
(
)
aTexture
)
;
if
(
pos
=
=
mSharedTextures
.
end
(
)
)
{
return
false
;
}
size_t
maxBytes
=
StaticPrefs
:
:
gfx_canvas_accelerated_reserve_empty_cache
(
)
<
<
20
;
size_t
usedBytes
=
aTexture
-
>
UsedBytes
(
)
;
if
(
mEmptyTextureMemory
+
usedBytes
<
=
maxBytes
)
{
mEmptyTextureMemory
+
=
usedBytes
;
}
else
{
mTotalTextureMemory
-
=
usedBytes
;
mSharedTextures
.
erase
(
pos
)
;
ClearLastTexture
(
)
;
mWebgl
-
>
DeleteTexture
(
aTexture
-
>
GetWebGLTexture
(
)
)
;
}
return
true
;
}
void
SharedTextureHandle
:
:
Cleanup
(
DrawTargetWebgl
:
:
SharedContext
&
aContext
)
{
mTexture
-
>
Free
(
*
this
)
;
if
(
!
mTexture
-
>
HasAllocatedHandles
(
)
)
{
aContext
.
RemoveSharedTexture
(
mTexture
)
;
}
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
RemoveStandaloneTexture
(
const
RefPtr
<
StandaloneTexture
>
&
aTexture
)
{
auto
pos
=
std
:
:
find
(
mStandaloneTextures
.
begin
(
)
mStandaloneTextures
.
end
(
)
aTexture
)
;
if
(
pos
=
=
mStandaloneTextures
.
end
(
)
)
{
return
false
;
}
mTotalTextureMemory
-
=
aTexture
-
>
UsedBytes
(
)
;
mStandaloneTextures
.
erase
(
pos
)
;
ClearLastTexture
(
)
;
mWebgl
-
>
DeleteTexture
(
aTexture
-
>
GetWebGLTexture
(
)
)
;
return
true
;
}
void
StandaloneTexture
:
:
Cleanup
(
DrawTargetWebgl
:
:
SharedContext
&
aContext
)
{
aContext
.
RemoveStandaloneTexture
(
this
)
;
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
PruneTextureHandle
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
aHandle
-
>
Invalidate
(
)
;
UnlinkSurfaceTexture
(
aHandle
)
;
if
(
RefPtr
<
CacheEntry
>
entry
=
aHandle
-
>
GetCacheEntry
(
)
)
{
entry
-
>
Unlink
(
)
;
}
mUsedTextureMemory
-
=
aHandle
-
>
UsedBytes
(
)
;
aHandle
-
>
Cleanup
(
*
this
)
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
PruneTextureMemory
(
size_t
aMargin
bool
aPruneUnused
)
{
size_t
maxBytes
=
StaticPrefs
:
:
gfx_canvas_accelerated_cache_size
(
)
<
<
20
;
maxBytes
-
=
std
:
:
min
(
maxBytes
aMargin
)
;
size_t
maxItems
=
StaticPrefs
:
:
gfx_canvas_accelerated_cache_items
(
)
;
size_t
oldItems
=
mNumTextureHandles
;
while
(
!
mTextureHandles
.
isEmpty
(
)
&
&
(
mUsedTextureMemory
>
maxBytes
|
|
mNumTextureHandles
>
maxItems
|
|
(
aPruneUnused
&
&
!
mTextureHandles
.
getLast
(
)
-
>
IsUsed
(
)
)
)
)
{
PruneTextureHandle
(
mTextureHandles
.
popLast
(
)
)
;
-
-
mNumTextureHandles
;
}
return
mNumTextureHandles
<
oldItems
;
}
void
DrawTargetWebgl
:
:
FillRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
SupportsPattern
(
aPattern
)
)
{
DrawRect
(
aRect
aPattern
aOptions
)
;
}
else
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
FillRect
(
aRect
aPattern
aOptions
)
;
}
else
{
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
aRect
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
DrawPath
(
path
aPattern
aOptions
)
;
}
}
void
CacheEntry
:
:
Link
(
const
RefPtr
<
TextureHandle
>
&
aHandle
)
{
mHandle
=
aHandle
;
mHandle
-
>
SetCacheEntry
(
this
)
;
}
void
CacheEntry
:
:
Unlink
(
)
{
RemoveFromList
(
)
;
if
(
mHandle
)
{
mHandle
-
>
SetCacheEntry
(
nullptr
)
;
mHandle
=
nullptr
;
}
}
HashNumber
PathCacheEntry
:
:
HashPath
(
const
SkPath
&
aPath
const
Pattern
*
aPattern
const
Matrix
&
aTransform
const
IntRect
&
aBounds
)
{
HashNumber
hash
=
0
;
hash
=
AddToHash
(
hash
aPath
.
countVerbs
(
)
)
;
hash
=
AddToHash
(
hash
aPath
.
countPoints
(
)
)
;
hash
=
AddToHash
(
hash
aBounds
.
width
)
;
hash
=
AddToHash
(
hash
aBounds
.
height
)
;
if
(
aPattern
)
{
hash
=
AddToHash
(
hash
(
int
)
aPattern
-
>
GetType
(
)
)
;
}
return
hash
;
}
static
inline
bool
HasMatchingScale
(
const
Matrix
&
aTransform1
const
Matrix
&
aTransform2
)
{
return
FuzzyEqual
(
aTransform1
.
_11
aTransform2
.
_11
)
&
&
FuzzyEqual
(
aTransform1
.
_12
aTransform2
.
_12
)
&
&
FuzzyEqual
(
aTransform1
.
_21
aTransform2
.
_21
)
&
&
FuzzyEqual
(
aTransform1
.
_22
aTransform2
.
_22
)
;
}
inline
bool
PathCacheEntry
:
:
MatchesPath
(
const
SkPath
&
aPath
const
Pattern
*
aPattern
const
StrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
HashNumber
aHash
float
aSigma
)
{
return
aHash
=
=
mHash
&
&
HasMatchingScale
(
aTransform
mTransform
)
&
&
aBounds
.
x
-
aOrigin
.
x
>
=
mBounds
.
x
-
mOrigin
.
x
&
&
(
aBounds
.
x
-
aOrigin
.
x
)
+
aBounds
.
width
<
=
(
mBounds
.
x
-
mOrigin
.
x
)
+
mBounds
.
width
&
&
aBounds
.
y
-
aOrigin
.
y
>
=
mBounds
.
y
-
mOrigin
.
y
&
&
(
aBounds
.
y
-
aOrigin
.
y
)
+
aBounds
.
height
<
=
(
mBounds
.
y
-
mOrigin
.
y
)
+
mBounds
.
height
&
&
aPath
=
=
mPath
&
&
(
!
aPattern
?
!
mPattern
:
mPattern
&
&
*
aPattern
=
=
*
mPattern
)
&
&
(
!
aStrokeOptions
?
!
mStrokeOptions
:
mStrokeOptions
&
&
*
aStrokeOptions
=
=
*
mStrokeOptions
)
&
&
aSigma
=
=
mSigma
;
}
PathCacheEntry
:
:
PathCacheEntry
(
const
SkPath
&
aPath
Pattern
*
aPattern
StoredStrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
HashNumber
aHash
float
aSigma
)
:
CacheEntryImpl
<
PathCacheEntry
>
(
aTransform
aBounds
aHash
)
mPath
(
aPath
)
mOrigin
(
aOrigin
)
mPattern
(
aPattern
)
mStrokeOptions
(
aStrokeOptions
)
mSigma
(
aSigma
)
{
}
already_AddRefed
<
PathCacheEntry
>
PathCache
:
:
FindOrInsertEntry
(
const
SkPath
&
aPath
const
Pattern
*
aPattern
const
StrokeOptions
*
aStrokeOptions
const
Matrix
&
aTransform
const
IntRect
&
aBounds
const
Point
&
aOrigin
float
aSigma
)
{
HashNumber
hash
=
PathCacheEntry
:
:
HashPath
(
aPath
aPattern
aTransform
aBounds
)
;
for
(
const
RefPtr
<
PathCacheEntry
>
&
entry
:
GetChain
(
hash
)
)
{
if
(
entry
-
>
MatchesPath
(
aPath
aPattern
aStrokeOptions
aTransform
aBounds
aOrigin
hash
aSigma
)
)
{
return
do_AddRef
(
entry
)
;
}
}
Pattern
*
pattern
=
nullptr
;
if
(
aPattern
)
{
pattern
=
aPattern
-
>
CloneWeak
(
)
;
if
(
!
pattern
)
{
return
nullptr
;
}
}
StoredStrokeOptions
*
strokeOptions
=
nullptr
;
if
(
aStrokeOptions
)
{
strokeOptions
=
aStrokeOptions
-
>
Clone
(
)
;
if
(
!
strokeOptions
)
{
return
nullptr
;
}
}
RefPtr
<
PathCacheEntry
>
entry
=
new
PathCacheEntry
(
aPath
pattern
strokeOptions
aTransform
aBounds
aOrigin
hash
aSigma
)
;
Insert
(
entry
)
;
return
entry
.
forget
(
)
;
}
void
DrawTargetWebgl
:
:
Fill
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
!
aPath
|
|
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
SkPath
&
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
-
>
GetPath
(
)
;
SkRect
rect
;
if
(
skiaPath
.
isRect
(
&
rect
)
&
&
SupportsPattern
(
aPattern
)
)
{
DrawRect
(
SkRectToRect
(
rect
)
aPattern
aOptions
)
;
}
else
{
DrawPath
(
aPath
aPattern
aOptions
)
;
}
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
DrawPathAccel
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
const
ShadowOptions
*
aShadow
bool
aCacheable
)
{
const
PathSkia
*
pathSkia
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
;
const
Matrix
&
currentTransform
=
GetTransform
(
)
;
Rect
bounds
=
pathSkia
-
>
GetFastBounds
(
currentTransform
aStrokeOptions
)
;
if
(
bounds
.
IsEmpty
(
)
)
{
return
true
;
}
IntRect
viewport
(
IntPoint
(
)
mViewportSize
)
;
if
(
aShadow
)
{
bounds
+
=
aShadow
-
>
mOffset
;
int32_t
blurRadius
=
aShadow
-
>
BlurRadius
(
)
;
bounds
.
Inflate
(
blurRadius
)
;
viewport
.
Inflate
(
blurRadius
)
;
}
IntRect
intBounds
=
RoundedOut
(
bounds
)
.
Intersect
(
viewport
)
;
if
(
intBounds
.
IsEmpty
(
)
)
{
return
true
;
}
Maybe
<
DeviceColor
>
color
=
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
?
Some
(
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
)
:
Nothing
(
)
;
RefPtr
<
PathCacheEntry
>
entry
;
RefPtr
<
TextureHandle
>
handle
;
if
(
aCacheable
)
{
if
(
!
mPathCache
)
{
mPathCache
=
MakeUnique
<
PathCache
>
(
)
;
}
entry
=
mPathCache
-
>
FindOrInsertEntry
(
pathSkia
-
>
GetPath
(
)
color
?
nullptr
:
&
aPattern
aStrokeOptions
currentTransform
intBounds
bounds
.
TopLeft
(
)
aShadow
?
aShadow
-
>
mSigma
:
-
1
.
0f
)
;
if
(
!
entry
)
{
return
false
;
}
handle
=
entry
-
>
GetHandle
(
)
;
}
Maybe
<
DeviceColor
>
shadowColor
=
color
;
if
(
aShadow
)
{
shadowColor
=
Some
(
aShadow
-
>
mColor
)
;
if
(
color
)
{
shadowColor
-
>
a
*
=
color
-
>
a
;
}
}
SamplingFilter
filter
=
aShadow
?
SamplingFilter
:
:
GOOD
:
GetSamplingFilter
(
aPattern
)
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
)
{
Point
offset
=
(
bounds
.
TopLeft
(
)
-
entry
-
>
GetOrigin
(
)
)
+
entry
-
>
GetBounds
(
)
.
TopLeft
(
)
;
SurfacePattern
pathPattern
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
offset
)
filter
)
;
if
(
DrawRectAccel
(
Rect
(
intBounds
)
pathPattern
aOptions
shadowColor
&
handle
false
true
true
)
)
{
return
true
;
}
}
else
{
handle
=
nullptr
;
RefPtr
<
DrawTargetSkia
>
pathDT
=
new
DrawTargetSkia
;
if
(
pathDT
-
>
Init
(
intBounds
.
Size
(
)
color
|
|
aShadow
?
SurfaceFormat
:
:
A8
:
SurfaceFormat
:
:
B8G8R8A8
)
)
{
Point
offset
=
-
intBounds
.
TopLeft
(
)
;
if
(
aShadow
)
{
offset
+
=
aShadow
-
>
mOffset
;
}
pathDT
-
>
SetTransform
(
currentTransform
*
Matrix
:
:
Translation
(
offset
)
)
;
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aOptions
.
mAntialiasMode
)
;
static
const
ColorPattern
maskPattern
(
DeviceColor
(
1
.
0f
1
.
0f
1
.
0f
1
.
0f
)
)
;
const
Pattern
&
cachePattern
=
color
?
maskPattern
:
aPattern
;
DrawTargetWebgl
*
oldTarget
=
mCurrentTarget
;
if
(
aStrokeOptions
)
{
pathDT
-
>
Stroke
(
aPath
cachePattern
*
aStrokeOptions
drawOptions
)
;
}
else
{
pathDT
-
>
Fill
(
aPath
cachePattern
drawOptions
)
;
}
if
(
aShadow
&
&
aShadow
-
>
mSigma
>
0
.
0f
)
{
uint8_t
*
data
=
nullptr
;
IntSize
size
;
int32_t
stride
=
0
;
SurfaceFormat
format
=
SurfaceFormat
:
:
UNKNOWN
;
if
(
pathDT
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
)
{
AlphaBoxBlur
blur
(
Rect
(
pathDT
-
>
GetRect
(
)
)
stride
aShadow
-
>
mSigma
aShadow
-
>
mSigma
)
;
blur
.
Blur
(
data
)
;
pathDT
-
>
ReleaseBits
(
data
)
;
}
}
RefPtr
<
SourceSurface
>
pathSurface
=
pathDT
-
>
Snapshot
(
)
;
if
(
pathSurface
)
{
if
(
mCurrentTarget
!
=
oldTarget
&
&
!
oldTarget
-
>
PrepareContext
(
)
)
{
return
false
;
}
SurfacePattern
pathPattern
(
pathSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
filter
)
;
if
(
DrawRectAccel
(
Rect
(
intBounds
)
pathPattern
aOptions
shadowColor
&
handle
false
true
)
&
&
handle
)
{
if
(
entry
)
{
entry
-
>
Link
(
handle
)
;
}
}
else
if
(
entry
)
{
entry
-
>
Unlink
(
)
;
}
return
true
;
}
}
}
return
false
;
}
void
DrawTargetWebgl
:
:
DrawPath
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
&
&
PrepareContext
(
)
&
&
mSharedContext
-
>
DrawPathAccel
(
aPath
aPattern
aOptions
aStrokeOptions
)
)
{
return
;
}
MarkSkiaChanged
(
aOptions
)
;
if
(
aStrokeOptions
)
{
mSkia
-
>
Stroke
(
aPath
aPattern
*
aStrokeOptions
aOptions
)
;
}
else
{
mSkia
-
>
Fill
(
aPath
aPattern
aOptions
)
;
}
}
void
DrawTargetWebgl
:
:
DrawSurface
(
SourceSurface
*
aSurface
const
Rect
&
aDest
const
Rect
&
aSource
const
DrawSurfaceOptions
&
aSurfOptions
const
DrawOptions
&
aOptions
)
{
Matrix
matrix
=
Matrix
:
:
Scaling
(
aDest
.
width
/
aSource
.
width
aDest
.
height
/
aSource
.
height
)
;
matrix
.
PreTranslate
(
-
aSource
.
x
-
aSource
.
y
)
;
matrix
.
PostTranslate
(
aDest
.
x
aDest
.
y
)
;
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
matrix
aSurfOptions
.
mSamplingFilter
)
;
DrawRect
(
aDest
pattern
aOptions
)
;
}
void
DrawTargetWebgl
:
:
Mask
(
const
Pattern
&
aSource
const
Pattern
&
aMask
const
DrawOptions
&
aOptions
)
{
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
aMask
.
GetType
(
)
!
=
PatternType
:
:
SURFACE
|
|
aSource
.
GetType
(
)
!
=
PatternType
:
:
COLOR
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
Mask
(
aSource
aMask
aOptions
)
;
return
;
}
auto
sourceColor
=
static_cast
<
const
ColorPattern
&
>
(
aSource
)
.
mColor
;
auto
maskPattern
=
static_cast
<
const
SurfacePattern
&
>
(
aMask
)
;
DrawRect
(
Rect
(
IntRect
(
IntPoint
(
)
maskPattern
.
mSurface
-
>
GetSize
(
)
)
)
maskPattern
aOptions
Some
(
sourceColor
)
)
;
}
void
DrawTargetWebgl
:
:
MaskSurface
(
const
Pattern
&
aSource
SourceSurface
*
aMask
Point
aOffset
const
DrawOptions
&
aOptions
)
{
if
(
!
SupportsDrawOptions
(
aOptions
)
|
|
aSource
.
GetType
(
)
!
=
PatternType
:
:
COLOR
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
MaskSurface
(
aSource
aMask
aOffset
aOptions
)
;
}
else
{
auto
sourceColor
=
static_cast
<
const
ColorPattern
&
>
(
aSource
)
.
mColor
;
SurfacePattern
pattern
(
aMask
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
aOffset
)
)
;
DrawRect
(
Rect
(
aOffset
Size
(
aMask
-
>
GetSize
(
)
)
)
pattern
aOptions
Some
(
sourceColor
)
)
;
}
}
static
already_AddRefed
<
DataSourceSurface
>
ExtractAlpha
(
SourceSurface
*
aSurface
bool
aAllowSubpixelAA
)
{
RefPtr
<
DataSourceSurface
>
surfaceData
=
aSurface
-
>
GetDataSurface
(
)
;
if
(
!
surfaceData
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
srcMap
(
surfaceData
DataSourceSurface
:
:
READ
)
;
if
(
!
srcMap
.
IsMapped
(
)
)
{
return
nullptr
;
}
IntSize
size
=
surfaceData
-
>
GetSize
(
)
;
RefPtr
<
DataSourceSurface
>
alpha
=
Factory
:
:
CreateDataSourceSurface
(
size
SurfaceFormat
:
:
A8
false
)
;
if
(
!
alpha
)
{
return
nullptr
;
}
DataSourceSurface
:
:
ScopedMap
dstMap
(
alpha
DataSourceSurface
:
:
WRITE
)
;
if
(
!
dstMap
.
IsMapped
(
)
)
{
return
nullptr
;
}
SwizzleData
(
srcMap
.
GetData
(
)
srcMap
.
GetStride
(
)
aAllowSubpixelAA
?
SurfaceFormat
:
:
A8R8G8B8
:
surfaceData
-
>
GetFormat
(
)
dstMap
.
GetData
(
)
dstMap
.
GetStride
(
)
SurfaceFormat
:
:
A8
size
)
;
return
alpha
.
forget
(
)
;
}
void
DrawTargetWebgl
:
:
DrawShadow
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
ShadowOptions
&
aShadow
const
DrawOptions
&
aOptions
const
StrokeOptions
*
aStrokeOptions
)
{
if
(
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
&
&
PrepareContext
(
)
&
&
mSharedContext
-
>
DrawPathAccel
(
aPath
aPattern
aOptions
aStrokeOptions
&
aShadow
)
)
{
return
;
}
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
DrawShadow
(
aPath
aPattern
aShadow
aOptions
aStrokeOptions
)
;
}
void
DrawTargetWebgl
:
:
DrawSurfaceWithShadow
(
SourceSurface
*
aSurface
const
Point
&
aDest
const
ShadowOptions
&
aShadow
CompositionOp
aOperator
)
{
DrawOptions
options
(
1
.
0f
aOperator
)
;
if
(
mWebglValid
&
&
SupportsDrawOptions
(
options
)
&
&
PrepareContext
(
)
)
{
SurfacePattern
pattern
(
aSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
aDest
)
)
;
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
Rect
(
aSurface
-
>
GetRect
(
)
)
+
aDest
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
AutoRestoreTransform
restore
(
this
)
;
SetTransform
(
Matrix
(
)
)
;
if
(
mSharedContext
-
>
DrawPathAccel
(
path
pattern
options
nullptr
&
aShadow
false
)
)
{
DrawRect
(
Rect
(
aSurface
-
>
GetRect
(
)
)
+
aDest
pattern
options
)
;
return
;
}
}
MarkSkiaChanged
(
options
)
;
mSkia
-
>
DrawSurfaceWithShadow
(
aSurface
aDest
aShadow
aOperator
)
;
}
already_AddRefed
<
PathBuilder
>
DrawTargetWebgl
:
:
CreatePathBuilder
(
FillRule
aFillRule
)
const
{
return
mSkia
-
>
CreatePathBuilder
(
aFillRule
)
;
}
void
DrawTargetWebgl
:
:
SetTransform
(
const
Matrix
&
aTransform
)
{
DrawTarget
:
:
SetTransform
(
aTransform
)
;
mSkia
-
>
SetTransform
(
aTransform
)
;
}
void
DrawTargetWebgl
:
:
StrokeRect
(
const
Rect
&
aRect
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
aStrokeOptions
=
=
StrokeOptions
(
)
&
&
mTransform
.
PreservesDistance
(
)
)
{
DrawRect
(
aRect
aPattern
aOptions
Nothing
(
)
nullptr
true
true
false
false
&
aStrokeOptions
)
;
}
else
if
(
!
mWebglValid
|
|
!
SupportsPattern
(
aPattern
)
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
StrokeRect
(
aRect
aPattern
aStrokeOptions
aOptions
)
;
}
else
{
SkPath
skiaPath
;
skiaPath
.
addRect
(
RectToSkRect
(
aRect
)
)
;
RefPtr
<
PathSkia
>
path
=
new
PathSkia
(
skiaPath
FillRule
:
:
FILL_WINDING
)
;
DrawPath
(
path
aPattern
aOptions
&
aStrokeOptions
)
;
}
}
void
DrawTargetWebgl
:
:
StrokeLine
(
const
Point
&
aStart
const
Point
&
aEnd
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
mWebglValid
&
&
SupportsPattern
(
aPattern
)
&
&
(
aStrokeOptions
.
mLineCap
=
=
CapStyle
:
:
BUTT
|
|
aStrokeOptions
.
mLineCap
=
=
CapStyle
:
:
SQUARE
)
&
&
aStrokeOptions
.
mDashPattern
=
=
nullptr
&
&
aStrokeOptions
.
mLineWidth
>
0
)
{
Point
start
=
aStart
;
Point
dirX
=
aEnd
-
aStart
;
float
scale
=
aStrokeOptions
.
mLineWidth
/
dirX
.
Length
(
)
;
Point
dirY
=
Point
(
-
dirX
.
y
dirX
.
x
)
*
scale
;
if
(
aStrokeOptions
.
mLineCap
=
=
CapStyle
:
:
SQUARE
)
{
start
-
=
(
dirX
*
scale
)
*
0
.
5f
;
dirX
+
=
dirX
*
scale
;
}
Matrix
lineXform
(
dirX
.
x
dirX
.
y
dirY
.
x
dirY
.
y
start
.
x
-
0
.
5f
*
dirY
.
x
start
.
y
-
0
.
5f
*
dirY
.
y
)
;
AutoRestoreTransform
restore
(
this
)
;
ConcatTransform
(
lineXform
)
;
if
(
DrawRect
(
Rect
(
0
0
1
1
)
aPattern
aOptions
Nothing
(
)
nullptr
true
true
true
)
)
{
return
;
}
}
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
StrokeLine
(
aStart
aEnd
aPattern
aStrokeOptions
aOptions
)
;
}
void
DrawTargetWebgl
:
:
Stroke
(
const
Path
*
aPath
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
!
aPath
|
|
aPath
-
>
GetBackendType
(
)
!
=
BackendType
:
:
SKIA
)
{
return
;
}
const
auto
&
skiaPath
=
static_cast
<
const
PathSkia
*
>
(
aPath
)
-
>
GetPath
(
)
;
SkRect
rect
;
if
(
!
mWebglValid
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
Stroke
(
aPath
aPattern
aStrokeOptions
aOptions
)
;
}
else
if
(
skiaPath
.
isRect
(
&
rect
)
)
{
StrokeRect
(
SkRectToRect
(
rect
)
aPattern
aStrokeOptions
aOptions
)
;
}
else
{
int
numVerbs
=
skiaPath
.
countVerbs
(
)
;
if
(
numVerbs
>
=
2
&
&
numVerbs
<
=
3
)
{
uint8_t
verbs
[
3
]
;
skiaPath
.
getVerbs
(
verbs
numVerbs
)
;
if
(
verbs
[
0
]
=
=
SkPath
:
:
kMove_Verb
&
&
verbs
[
1
]
=
=
SkPath
:
:
kLine_Verb
&
&
(
numVerbs
<
3
|
|
verbs
[
2
]
=
=
SkPath
:
:
kClose_Verb
)
)
{
Point
start
=
SkPointToPoint
(
skiaPath
.
getPoint
(
0
)
)
;
Point
end
=
SkPointToPoint
(
skiaPath
.
getPoint
(
1
)
)
;
StrokeLine
(
start
end
aPattern
aStrokeOptions
aOptions
)
;
if
(
numVerbs
>
=
3
)
{
StrokeLine
(
end
start
aPattern
aStrokeOptions
aOptions
)
;
}
return
;
}
}
DrawPath
(
aPath
aPattern
aOptions
&
aStrokeOptions
)
;
}
}
bool
DrawTargetWebgl
:
:
ShouldUseSubpixelAA
(
ScaledFont
*
aFont
const
DrawOptions
&
aOptions
)
{
AntialiasMode
aaMode
=
aFont
-
>
GetDefaultAAMode
(
)
;
if
(
aOptions
.
mAntialiasMode
!
=
AntialiasMode
:
:
DEFAULT
)
{
aaMode
=
aOptions
.
mAntialiasMode
;
}
return
GetPermitSubpixelAA
(
)
&
&
(
aaMode
=
=
AntialiasMode
:
:
DEFAULT
|
|
aaMode
=
=
AntialiasMode
:
:
SUBPIXEL
)
&
&
aOptions
.
mCompositionOp
=
=
CompositionOp
:
:
OP_OVER
;
}
void
DrawTargetWebgl
:
:
StrokeGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aOptions
)
{
if
(
!
aFont
|
|
!
aBuffer
.
mNumGlyphs
)
{
return
;
}
bool
useSubpixelAA
=
ShouldUseSubpixelAA
(
aFont
aOptions
)
;
if
(
useSubpixelAA
)
{
MarkSkiaChanged
(
)
;
}
else
{
MarkSkiaChanged
(
aOptions
)
;
}
mSkia
-
>
StrokeGlyphs
(
aFont
aBuffer
aPattern
aStrokeOptions
aOptions
)
;
}
static
inline
IntPoint
QuantizeScale
(
ScaledFont
*
aFont
const
Matrix
&
aTransform
)
{
if
(
!
aFont
-
>
UseSubpixelPosition
(
)
)
{
return
{
1
1
}
;
}
if
(
aTransform
.
_12
=
=
0
)
{
return
{
4
1
}
;
}
if
(
aTransform
.
_11
=
=
0
)
{
return
{
1
4
}
;
}
return
{
4
4
}
;
}
static
inline
IntPoint
QuantizePosition
(
const
Matrix
&
aTransform
const
IntPoint
&
aOffset
const
Point
&
aPosition
)
{
return
RoundedToInt
(
aTransform
.
TransformPoint
(
aPosition
)
)
-
aOffset
;
}
static
inline
IntPoint
QuantizeOffset
(
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
GlyphBuffer
&
aBuffer
)
{
IntPoint
offset
=
RoundedToInt
(
aTransform
.
TransformPoint
(
aBuffer
.
mGlyphs
[
0
]
.
mPosition
)
)
;
offset
.
x
&
=
~
(
aQuantizeScale
.
x
-
1
)
;
offset
.
y
&
=
~
(
aQuantizeScale
.
y
-
1
)
;
return
offset
;
}
HashNumber
GlyphCacheEntry
:
:
HashGlyphs
(
const
GlyphBuffer
&
aBuffer
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
)
{
HashNumber
hash
=
0
;
IntPoint
offset
=
QuantizeOffset
(
aTransform
aQuantizeScale
aBuffer
)
;
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
const
Glyph
&
glyph
=
aBuffer
.
mGlyphs
[
i
]
;
hash
=
AddToHash
(
hash
glyph
.
mIndex
)
;
IntPoint
pos
=
QuantizePosition
(
aTransform
offset
glyph
.
mPosition
)
;
hash
=
AddToHash
(
hash
pos
.
x
)
;
hash
=
AddToHash
(
hash
pos
.
y
)
;
}
return
hash
;
}
inline
bool
GlyphCacheEntry
:
:
MatchesGlyphs
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeOffset
const
IntPoint
&
aBoundsOffset
const
IntRect
&
aClipRect
HashNumber
aHash
)
{
if
(
aHash
!
=
mHash
|
|
aBuffer
.
mNumGlyphs
!
=
mBuffer
.
mNumGlyphs
|
|
aColor
!
=
mColor
|
|
!
HasMatchingScale
(
aTransform
mTransform
)
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
const
Glyph
&
dst
=
mBuffer
.
mGlyphs
[
i
]
;
const
Glyph
&
src
=
aBuffer
.
mGlyphs
[
i
]
;
if
(
dst
.
mIndex
!
=
src
.
mIndex
|
|
dst
.
mPosition
!
=
Point
(
QuantizePosition
(
aTransform
aQuantizeOffset
src
.
mPosition
)
)
)
{
return
false
;
}
}
return
(
mFullBounds
+
aBoundsOffset
)
.
Intersect
(
aClipRect
)
.
IsEqualEdges
(
GetBounds
(
)
+
aBoundsOffset
)
;
}
GlyphCacheEntry
:
:
GlyphCacheEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
IntRect
&
aBounds
const
IntRect
&
aFullBounds
HashNumber
aHash
)
:
CacheEntryImpl
<
GlyphCacheEntry
>
(
aTransform
aBounds
aHash
)
mColor
(
aColor
)
mFullBounds
(
aFullBounds
)
{
Glyph
*
glyphs
=
new
Glyph
[
aBuffer
.
mNumGlyphs
]
;
IntPoint
offset
=
QuantizeOffset
(
aTransform
aQuantizeScale
aBuffer
)
;
IntPoint
boundsOffset
(
offset
.
x
/
aQuantizeScale
.
x
offset
.
y
/
aQuantizeScale
.
y
)
;
mBounds
-
=
boundsOffset
;
mFullBounds
-
=
boundsOffset
;
for
(
size_t
i
=
0
;
i
<
aBuffer
.
mNumGlyphs
;
i
+
+
)
{
Glyph
&
dst
=
glyphs
[
i
]
;
const
Glyph
&
src
=
aBuffer
.
mGlyphs
[
i
]
;
dst
.
mIndex
=
src
.
mIndex
;
dst
.
mPosition
=
Point
(
QuantizePosition
(
aTransform
offset
src
.
mPosition
)
)
;
}
mBuffer
.
mGlyphs
=
glyphs
;
mBuffer
.
mNumGlyphs
=
aBuffer
.
mNumGlyphs
;
}
GlyphCacheEntry
:
:
~
GlyphCacheEntry
(
)
{
delete
[
]
mBuffer
.
mGlyphs
;
}
already_AddRefed
<
GlyphCacheEntry
>
GlyphCache
:
:
FindEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
IntRect
&
aClipRect
HashNumber
aHash
)
{
IntPoint
offset
=
QuantizeOffset
(
aTransform
aQuantizeScale
aBuffer
)
;
IntPoint
boundsOffset
(
offset
.
x
/
aQuantizeScale
.
x
offset
.
y
/
aQuantizeScale
.
y
)
;
for
(
const
RefPtr
<
GlyphCacheEntry
>
&
entry
:
GetChain
(
aHash
)
)
{
if
(
entry
-
>
MatchesGlyphs
(
aBuffer
aColor
aTransform
offset
boundsOffset
aClipRect
aHash
)
)
{
return
do_AddRef
(
entry
)
;
}
}
return
nullptr
;
}
already_AddRefed
<
GlyphCacheEntry
>
GlyphCache
:
:
InsertEntry
(
const
GlyphBuffer
&
aBuffer
const
DeviceColor
&
aColor
const
Matrix
&
aTransform
const
IntPoint
&
aQuantizeScale
const
IntRect
&
aBounds
const
IntRect
&
aFullBounds
HashNumber
aHash
)
{
RefPtr
<
GlyphCacheEntry
>
entry
=
new
GlyphCacheEntry
(
aBuffer
aColor
aTransform
aQuantizeScale
aBounds
aFullBounds
aHash
)
;
Insert
(
entry
)
;
return
entry
.
forget
(
)
;
}
GlyphCache
:
:
GlyphCache
(
ScaledFont
*
aFont
)
:
mFont
(
aFont
)
{
}
static
void
ReleaseGlyphCache
(
void
*
aPtr
)
{
delete
static_cast
<
GlyphCache
*
>
(
aPtr
)
;
}
void
DrawTargetWebgl
:
:
SetPermitSubpixelAA
(
bool
aPermitSubpixelAA
)
{
DrawTarget
:
:
SetPermitSubpixelAA
(
aPermitSubpixelAA
)
;
mSkia
-
>
SetPermitSubpixelAA
(
aPermitSubpixelAA
)
;
}
static
bool
CheckForColorGlyphs
(
const
RefPtr
<
SourceSurface
>
&
aSurface
)
{
if
(
aSurface
-
>
GetFormat
(
)
!
=
SurfaceFormat
:
:
B8G8R8A8
)
{
return
false
;
}
RefPtr
<
DataSourceSurface
>
dataSurf
=
aSurface
-
>
GetDataSurface
(
)
;
if
(
!
dataSurf
)
{
return
true
;
}
DataSourceSurface
:
:
ScopedMap
map
(
dataSurf
DataSourceSurface
:
:
READ
)
;
if
(
!
map
.
IsMapped
(
)
)
{
return
true
;
}
IntSize
size
=
dataSurf
-
>
GetSize
(
)
;
const
uint8_t
*
data
=
map
.
GetData
(
)
;
int32_t
stride
=
map
.
GetStride
(
)
;
for
(
int
y
=
0
;
y
<
size
.
height
;
y
+
+
)
{
const
uint32_t
*
x
=
(
const
uint32_t
*
)
data
;
const
uint32_t
*
end
=
x
+
size
.
width
;
for
(
;
x
<
end
;
x
+
+
)
{
uint32_t
color
=
*
x
;
uint32_t
gray
=
color
&
0xFF
;
gray
|
=
gray
<
<
8
;
gray
|
=
gray
<
<
16
;
if
(
color
!
=
gray
)
return
true
;
}
data
+
=
stride
;
}
return
false
;
}
bool
DrawTargetWebgl
:
:
SharedContext
:
:
FillGlyphsAccel
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
bool
aUseSubpixelAA
)
{
bool
useBitmaps
=
aFont
-
>
MayUseBitmaps
(
)
;
GlyphCache
*
cache
=
static_cast
<
GlyphCache
*
>
(
aFont
-
>
GetUserData
(
&
mGlyphCacheKey
)
)
;
if
(
!
cache
)
{
cache
=
new
GlyphCache
(
aFont
)
;
aFont
-
>
AddUserData
(
&
mGlyphCacheKey
cache
ReleaseGlyphCache
)
;
mGlyphCaches
.
insertFront
(
cache
)
;
}
DeviceColor
color
=
static_cast
<
const
ColorPattern
&
>
(
aPattern
)
.
mColor
;
#
ifdef
XP_MACOSX
bool
lightOnDark
=
useBitmaps
|
|
(
color
.
r
>
=
0
.
33f
&
&
color
.
g
>
=
0
.
33f
&
&
color
.
b
>
=
0
.
33f
&
&
color
.
r
+
color
.
g
+
color
.
b
>
=
2
.
0f
)
;
#
else
const
bool
lightOnDark
=
true
;
#
endif
const
Matrix
&
currentTransform
=
GetTransform
(
)
;
IntPoint
quantizeScale
=
QuantizeScale
(
aFont
currentTransform
)
;
Matrix
quantizeTransform
=
currentTransform
;
quantizeTransform
.
PostScale
(
quantizeScale
.
x
quantizeScale
.
y
)
;
HashNumber
hash
=
GlyphCacheEntry
:
:
HashGlyphs
(
aBuffer
quantizeTransform
quantizeScale
)
;
DeviceColor
colorOrMask
=
useBitmaps
?
color
:
DeviceColor
:
:
Mask
(
aUseSubpixelAA
?
1
:
0
lightOnDark
?
1
:
0
)
;
IntRect
clipRect
(
IntPoint
(
)
mViewportSize
)
;
RefPtr
<
GlyphCacheEntry
>
entry
=
cache
-
>
FindEntry
(
aBuffer
colorOrMask
quantizeTransform
quantizeScale
clipRect
hash
)
;
if
(
!
entry
)
{
Maybe
<
Rect
>
bounds
=
mCurrentTarget
-
>
mSkia
-
>
GetGlyphLocalBounds
(
aFont
aBuffer
aPattern
nullptr
aOptions
)
;
if
(
!
bounds
)
{
return
true
;
}
Rect
xformBounds
=
currentTransform
.
TransformBounds
(
*
bounds
)
;
if
(
xformBounds
.
IsEmpty
(
)
)
{
return
true
;
}
IntRect
fullBounds
=
RoundedOut
(
currentTransform
.
TransformBounds
(
*
bounds
)
)
;
IntRect
clipBounds
=
fullBounds
.
Intersect
(
clipRect
)
;
if
(
clipBounds
.
IsEmpty
(
)
)
{
return
true
;
}
entry
=
cache
-
>
InsertEntry
(
aBuffer
colorOrMask
quantizeTransform
quantizeScale
clipBounds
fullBounds
hash
)
;
if
(
!
entry
)
{
return
false
;
}
}
IntRect
intBounds
=
entry
-
>
GetBounds
(
)
;
IntPoint
newOffset
=
QuantizeOffset
(
quantizeTransform
quantizeScale
aBuffer
)
;
intBounds
+
=
IntPoint
(
newOffset
.
x
/
quantizeScale
.
x
newOffset
.
y
/
quantizeScale
.
y
)
;
intBounds
.
Inflate
(
2
)
;
RefPtr
<
TextureHandle
>
handle
=
entry
-
>
GetHandle
(
)
;
if
(
handle
&
&
handle
-
>
IsValid
(
)
)
{
SurfacePattern
pattern
(
nullptr
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
)
;
if
(
DrawRectAccel
(
Rect
(
intBounds
)
pattern
aOptions
useBitmaps
?
Nothing
(
)
:
Some
(
color
)
&
handle
false
true
true
)
)
{
return
true
;
}
}
else
{
handle
=
nullptr
;
RefPtr
<
DrawTargetSkia
>
textDT
=
new
DrawTargetSkia
;
if
(
textDT
-
>
Init
(
intBounds
.
Size
(
)
lightOnDark
&
&
!
useBitmaps
&
&
!
aUseSubpixelAA
?
SurfaceFormat
:
:
A8
:
SurfaceFormat
:
:
B8G8R8A8
)
)
{
if
(
!
lightOnDark
)
{
textDT
-
>
FillRect
(
Rect
(
IntRect
(
IntPoint
(
)
intBounds
.
Size
(
)
)
)
ColorPattern
(
DeviceColor
(
1
1
1
1
)
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
)
)
;
}
textDT
-
>
SetTransform
(
currentTransform
*
Matrix
:
:
Translation
(
-
intBounds
.
TopLeft
(
)
)
)
;
textDT
-
>
SetPermitSubpixelAA
(
aUseSubpixelAA
)
;
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aOptions
.
mAntialiasMode
)
;
textDT
-
>
FillGlyphs
(
aFont
aBuffer
ColorPattern
(
useBitmaps
?
color
:
DeviceColor
:
:
Mask
(
lightOnDark
?
1
:
0
1
)
)
drawOptions
)
;
if
(
!
lightOnDark
)
{
uint8_t
*
data
=
nullptr
;
IntSize
size
;
int32_t
stride
=
0
;
SurfaceFormat
format
=
SurfaceFormat
:
:
UNKNOWN
;
if
(
!
textDT
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
)
{
return
false
;
}
uint8_t
*
row
=
data
;
for
(
int
y
=
0
;
y
<
size
.
height
;
+
+
y
)
{
uint8_t
*
px
=
row
;
for
(
int
x
=
0
;
x
<
size
.
width
;
+
+
x
)
{
px
[
0
]
=
255
-
px
[
0
]
;
px
[
1
]
=
255
-
px
[
1
]
;
px
[
2
]
=
255
-
px
[
2
]
;
px
[
3
]
=
std
:
:
max
(
px
[
0
]
std
:
:
max
(
px
[
1
]
px
[
2
]
)
)
;
px
+
=
4
;
}
row
+
=
stride
;
}
textDT
-
>
ReleaseBits
(
data
)
;
}
RefPtr
<
SourceSurface
>
textSurface
=
textDT
-
>
Snapshot
(
)
;
if
(
textSurface
)
{
if
(
textSurface
-
>
GetFormat
(
)
!
=
SurfaceFormat
:
:
A8
&
&
!
CheckForColorGlyphs
(
textSurface
)
)
{
textSurface
=
ExtractAlpha
(
textSurface
!
useBitmaps
)
;
if
(
!
textSurface
)
{
return
false
;
}
}
SurfacePattern
pattern
(
textSurface
ExtendMode
:
:
CLAMP
Matrix
:
:
Translation
(
intBounds
.
TopLeft
(
)
)
)
;
if
(
DrawRectAccel
(
Rect
(
intBounds
)
pattern
aOptions
useBitmaps
?
Nothing
(
)
:
Some
(
color
)
&
handle
false
true
)
&
&
handle
)
{
entry
-
>
Link
(
handle
)
;
}
else
{
entry
-
>
Unlink
(
)
;
}
return
true
;
}
}
}
return
false
;
}
void
DrawTargetWebgl
:
:
FillGlyphs
(
ScaledFont
*
aFont
const
GlyphBuffer
&
aBuffer
const
Pattern
&
aPattern
const
DrawOptions
&
aOptions
)
{
if
(
!
aFont
|
|
!
aBuffer
.
mNumGlyphs
)
{
return
;
}
bool
useSubpixelAA
=
ShouldUseSubpixelAA
(
aFont
aOptions
)
;
if
(
mWebglValid
&
&
SupportsDrawOptions
(
aOptions
)
&
&
aPattern
.
GetType
(
)
=
=
PatternType
:
:
COLOR
&
&
PrepareContext
(
)
&
&
mSharedContext
-
>
FillGlyphsAccel
(
aFont
aBuffer
aPattern
aOptions
useSubpixelAA
)
)
{
return
;
}
if
(
useSubpixelAA
)
{
MarkSkiaChanged
(
)
;
}
else
{
MarkSkiaChanged
(
aOptions
)
;
}
mSkia
-
>
FillGlyphs
(
aFont
aBuffer
aPattern
aOptions
)
;
}
void
DrawTargetWebgl
:
:
SharedContext
:
:
WaitForShmem
(
)
{
if
(
mWaitForShmem
)
{
(
void
)
mWebgl
-
>
GetError
(
)
;
mWaitForShmem
=
false
;
}
}
void
DrawTargetWebgl
:
:
MarkSkiaChanged
(
const
DrawOptions
&
aOptions
)
{
if
(
SupportsLayering
(
aOptions
)
)
{
WaitForShmem
(
)
;
if
(
!
mSkiaValid
)
{
mSkiaValid
=
true
;
if
(
mWebglValid
)
{
mSkiaLayer
=
true
;
mSkia
-
>
Clear
(
)
;
}
}
mWebglValid
=
false
;
}
else
{
MarkSkiaChanged
(
)
;
}
}
void
DrawTargetWebgl
:
:
ReadIntoSkia
(
)
{
if
(
mSkiaValid
)
{
return
;
}
if
(
mWebglValid
)
{
uint8_t
*
data
=
nullptr
;
IntSize
size
;
int32_t
stride
;
SurfaceFormat
format
;
if
(
!
mSnapshot
&
&
mSkia
-
>
LockBits
(
&
data
&
size
&
stride
&
format
)
)
{
(
void
)
ReadInto
(
data
stride
)
;
mSkia
-
>
ReleaseBits
(
data
)
;
}
else
if
(
RefPtr
<
SourceSurface
>
snapshot
=
Snapshot
(
)
)
{
mSkia
-
>
CopySurface
(
snapshot
GetRect
(
)
IntPoint
(
0
0
)
)
;
}
mProfile
.
OnFallback
(
)
;
}
mSkiaValid
=
true
;
mSkiaLayer
=
false
;
}
void
DrawTargetWebgl
:
:
FlattenSkia
(
)
{
if
(
!
mSkiaValid
|
|
!
mSkiaLayer
)
{
return
;
}
if
(
RefPtr
<
DataSourceSurface
>
base
=
ReadSnapshot
(
)
)
{
mSkia
-
>
BlendSurface
(
base
GetRect
(
)
IntPoint
(
)
CompositionOp
:
:
OP_DEST_OVER
)
;
}
mSkiaLayer
=
false
;
}
bool
DrawTargetWebgl
:
:
FlushFromSkia
(
)
{
if
(
mSharedContext
-
>
IsContextLost
(
)
)
{
mWebglValid
=
false
;
return
false
;
}
if
(
mWebglValid
)
{
return
true
;
}
mWebglValid
=
true
;
if
(
mSkiaValid
)
{
RefPtr
<
SourceSurface
>
skiaSnapshot
=
mSkia
-
>
Snapshot
(
)
;
if
(
!
skiaSnapshot
)
{
mWebglValid
=
false
;
return
false
;
}
AutoRestoreContext
restore
(
this
)
;
SurfacePattern
pattern
(
skiaSnapshot
ExtendMode
:
:
CLAMP
)
;
if
(
!
DrawRect
(
Rect
(
GetRect
(
)
)
pattern
DrawOptions
(
1
.
0f
mSkiaLayer
?
CompositionOp
:
:
OP_OVER
:
CompositionOp
:
:
OP_SOURCE
)
Nothing
(
)
mSkiaLayer
?
&
mSnapshotTexture
:
nullptr
false
false
true
true
)
)
{
mWebglValid
=
false
;
return
false
;
}
}
return
true
;
}
void
DrawTargetWebgl
:
:
UsageProfile
:
:
BeginFrame
(
)
{
mFallbacks
=
0
;
mLayers
=
0
;
mCacheMisses
=
0
;
mCacheHits
=
0
;
mUncachedDraws
=
0
;
mReadbacks
=
0
;
}
void
DrawTargetWebgl
:
:
UsageProfile
:
:
EndFrame
(
)
{
bool
failed
=
false
;
float
cacheRatio
=
StaticPrefs
:
:
gfx_canvas_accelerated_profile_cache_miss_ratio
(
)
;
if
(
mFallbacks
>
0
|
|
mCacheMisses
+
mReadbacks
>
cacheRatio
*
(
mCacheMisses
+
mCacheHits
+
mUncachedDraws
+
mReadbacks
)
)
{
failed
=
true
;
}
if
(
failed
)
{
+
+
mFailedFrames
;
}
+
+
mFrameCount
;
}
bool
DrawTargetWebgl
:
:
UsageProfile
:
:
RequiresRefresh
(
)
const
{
uint32_t
profileFrames
=
StaticPrefs
:
:
gfx_canvas_accelerated_profile_frames
(
)
;
if
(
!
profileFrames
|
|
mFrameCount
<
profileFrames
)
{
return
false
;
}
float
failRatio
=
StaticPrefs
:
:
gfx_canvas_accelerated_profile_fallback_ratio
(
)
;
return
mFailedFrames
>
failRatio
*
mFrameCount
;
}
void
DrawTargetWebgl
:
:
BeginFrame
(
const
IntRect
&
aPersistedRect
)
{
if
(
mNeedsPresent
)
{
mNeedsPresent
=
false
;
if
(
!
mWebglValid
)
{
if
(
aPersistedRect
.
IsEmpty
(
)
)
{
mWebglValid
=
true
;
}
else
{
FlushFromSkia
(
)
;
}
}
}
mSharedContext
-
>
ClearCachesIfNecessary
(
)
;
mProfile
.
BeginFrame
(
)
;
}
void
DrawTargetWebgl
:
:
EndFrame
(
)
{
mProfile
.
EndFrame
(
)
;
mSharedContext
-
>
PruneTextureMemory
(
)
;
mSharedContext
-
>
mWebgl
-
>
EndOfFrame
(
)
;
mSharedContext
-
>
ClearCachesIfNecessary
(
)
;
mNeedsPresent
=
true
;
}
Maybe
<
layers
:
:
SurfaceDescriptor
>
DrawTargetWebgl
:
:
GetFrontBuffer
(
)
{
if
(
mNeedsPresent
)
{
mNeedsPresent
=
false
;
if
(
mWebglValid
|
|
FlushFromSkia
(
)
)
{
webgl
:
:
SwapChainOptions
options
;
options
.
bgra
=
true
;
options
.
forceAsyncPresent
=
StaticPrefs
:
:
gfx_canvas_accelerated_async_present
(
)
;
mSharedContext
-
>
mWebgl
-
>
CopyToSwapChain
(
mFramebuffer
options
)
;
}
}
if
(
mWebglValid
)
{
return
mSharedContext
-
>
mWebgl
-
>
GetFrontBuffer
(
mFramebuffer
)
;
}
return
Nothing
(
)
;
}
already_AddRefed
<
DrawTarget
>
DrawTargetWebgl
:
:
CreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
bool
DrawTargetWebgl
:
:
CanCreateSimilarDrawTarget
(
const
IntSize
&
aSize
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CanCreateSimilarDrawTarget
(
aSize
aFormat
)
;
}
RefPtr
<
DrawTarget
>
DrawTargetWebgl
:
:
CreateClippedDrawTarget
(
const
Rect
&
aBounds
SurfaceFormat
aFormat
)
{
return
mSkia
-
>
CreateClippedDrawTarget
(
aBounds
aFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
CreateSourceSurfaceFromData
(
unsigned
char
*
aData
const
IntSize
&
aSize
int32_t
aStride
SurfaceFormat
aFormat
)
const
{
return
mSkia
-
>
CreateSourceSurfaceFromData
(
aData
aSize
aStride
aFormat
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
CreateSourceSurfaceFromNativeSurface
(
const
NativeSurface
&
aSurface
)
const
{
return
mSkia
-
>
CreateSourceSurfaceFromNativeSurface
(
aSurface
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
OptimizeSourceSurface
(
SourceSurface
*
aSurface
)
const
{
if
(
aSurface
-
>
GetType
(
)
=
=
SurfaceType
:
:
WEBGL
)
{
return
do_AddRef
(
aSurface
)
;
}
return
mSkia
-
>
OptimizeSourceSurface
(
aSurface
)
;
}
already_AddRefed
<
SourceSurface
>
DrawTargetWebgl
:
:
OptimizeSourceSurfaceForUnknownAlpha
(
SourceSurface
*
aSurface
)
const
{
return
mSkia
-
>
OptimizeSourceSurfaceForUnknownAlpha
(
aSurface
)
;
}
already_AddRefed
<
GradientStops
>
DrawTargetWebgl
:
:
CreateGradientStops
(
GradientStop
*
aStops
uint32_t
aNumStops
ExtendMode
aExtendMode
)
const
{
return
mSkia
-
>
CreateGradientStops
(
aStops
aNumStops
aExtendMode
)
;
}
already_AddRefed
<
FilterNode
>
DrawTargetWebgl
:
:
CreateFilter
(
FilterType
aType
)
{
return
mSkia
-
>
CreateFilter
(
aType
)
;
}
void
DrawTargetWebgl
:
:
DrawFilter
(
FilterNode
*
aNode
const
Rect
&
aSourceRect
const
Point
&
aDestPoint
const
DrawOptions
&
aOptions
)
{
MarkSkiaChanged
(
aOptions
)
;
mSkia
-
>
DrawFilter
(
aNode
aSourceRect
aDestPoint
aOptions
)
;
}
bool
DrawTargetWebgl
:
:
Draw3DTransformedSurface
(
SourceSurface
*
aSurface
const
Matrix4x4
&
aMatrix
)
{
MarkSkiaChanged
(
)
;
return
mSkia
-
>
Draw3DTransformedSurface
(
aSurface
aMatrix
)
;
}
void
DrawTargetWebgl
:
:
PushLayer
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
bool
aCopyBackground
)
{
PushLayerWithBlend
(
aOpaque
aOpacity
aMask
aMaskTransform
aBounds
aCopyBackground
CompositionOp
:
:
OP_OVER
)
;
}
void
DrawTargetWebgl
:
:
PushLayerWithBlend
(
bool
aOpaque
Float
aOpacity
SourceSurface
*
aMask
const
Matrix
&
aMaskTransform
const
IntRect
&
aBounds
bool
aCopyBackground
CompositionOp
aCompositionOp
)
{
MarkSkiaChanged
(
DrawOptions
(
aOpacity
aCompositionOp
)
)
;
mSkia
-
>
PushLayerWithBlend
(
aOpaque
aOpacity
aMask
aMaskTransform
aBounds
aCopyBackground
aCompositionOp
)
;
+
+
mLayerDepth
;
}
void
DrawTargetWebgl
:
:
PopLayer
(
)
{
MOZ_ASSERT
(
mSkiaValid
)
;
MOZ_ASSERT
(
mLayerDepth
>
0
)
;
-
-
mLayerDepth
;
mSkia
-
>
PopLayer
(
)
;
}
}
