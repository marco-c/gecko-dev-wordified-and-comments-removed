#
ifndef
nsICanvasRenderingContextInternal_h___
#
define
nsICanvasRenderingContextInternal_h___
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
OffscreenCanvas
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
define
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
\
{
0xb84f2fed
0x9d4b
0x430b
\
{
0xbd
0xfb
0x85
0x57
0x8a
0xc2
0xb4
0x4b
}
}
class
gfxASurface
;
class
nsDisplayListBuilder
;
namespace
mozilla
{
namespace
layers
{
class
CanvasLayer
;
class
LayerManager
;
}
namespace
gfx
{
class
SourceSurface
;
}
}
class
nsICanvasRenderingContextInternal
:
public
nsISupports
public
nsAPostRefreshObserver
{
public
:
typedef
mozilla
:
:
layers
:
:
CanvasLayer
CanvasLayer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
)
void
SetCanvasElement
(
mozilla
:
:
dom
:
:
HTMLCanvasElement
*
parentCanvas
)
{
RemovePostRefreshObserver
(
)
;
mCanvasElement
=
parentCanvas
;
AddPostRefreshObserverIfNecessary
(
)
;
}
virtual
nsIPresShell
*
GetPresShell
(
)
{
if
(
mCanvasElement
)
{
return
mCanvasElement
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
}
return
nullptr
;
}
void
RemovePostRefreshObserver
(
)
{
if
(
mRefreshDriver
)
{
mRefreshDriver
-
>
RemovePostRefreshObserver
(
this
)
;
mRefreshDriver
=
nullptr
;
}
}
void
AddPostRefreshObserverIfNecessary
(
)
{
if
(
!
GetPresShell
(
)
|
|
!
GetPresShell
(
)
-
>
GetPresContext
(
)
|
|
!
GetPresShell
(
)
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
)
{
return
;
}
mRefreshDriver
=
GetPresShell
(
)
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
mRefreshDriver
-
>
AddPostRefreshObserver
(
this
)
;
}
mozilla
:
:
dom
:
:
HTMLCanvasElement
*
GetParentObject
(
)
const
{
return
mCanvasElement
;
}
void
SetOffscreenCanvas
(
mozilla
:
:
dom
:
:
OffscreenCanvas
*
aOffscreenCanvas
)
{
mOffscreenCanvas
=
aOffscreenCanvas
;
}
virtual
int32_t
GetWidth
(
)
const
=
0
;
virtual
int32_t
GetHeight
(
)
const
=
0
;
NS_IMETHOD
SetDimensions
(
int32_t
width
int32_t
height
)
=
0
;
NS_IMETHOD
InitializeWithSurface
(
nsIDocShell
*
docShell
gfxASurface
*
surface
int32_t
width
int32_t
height
)
=
0
;
virtual
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
GetImageBuffer
(
int32_t
*
format
)
=
0
;
NS_IMETHOD
GetInputStream
(
const
char
*
mimeType
const
char16_t
*
encoderOptions
nsIInputStream
*
*
stream
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
GetSurfaceSnapshot
(
bool
*
premultAlpha
=
nullptr
)
=
0
;
NS_IMETHOD
SetIsOpaque
(
bool
isOpaque
)
=
0
;
virtual
bool
GetIsOpaque
(
)
=
0
;
NS_IMETHOD
Reset
(
)
=
0
;
virtual
already_AddRefed
<
CanvasLayer
>
GetCanvasLayer
(
nsDisplayListBuilder
*
builder
CanvasLayer
*
oldLayer
LayerManager
*
manager
)
=
0
;
virtual
bool
ShouldForceInactiveLayer
(
LayerManager
*
manager
)
{
return
false
;
}
virtual
void
MarkContextClean
(
)
=
0
;
virtual
void
MarkContextCleanForFrameCapture
(
)
=
0
;
virtual
bool
IsContextCleanForFrameCapture
(
)
=
0
;
NS_IMETHOD
Redraw
(
const
gfxRect
&
dirty
)
=
0
;
NS_IMETHOD
SetContextOptions
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
options
mozilla
:
:
ErrorResult
&
aRvForDictionaryInit
)
{
return
NS_OK
;
}
virtual
bool
GetHitRegionRect
(
mozilla
:
:
dom
:
:
Element
*
element
nsRect
&
rect
)
{
return
false
;
}
virtual
nsString
GetHitRegion
(
const
mozilla
:
:
gfx
:
:
Point
&
point
)
{
return
nsString
(
)
;
}
virtual
void
OnVisibilityChange
(
)
{
}
virtual
void
OnMemoryPressure
(
)
{
}
NS_IMETHOD
SetIsIPC
(
bool
isIPC
)
=
0
;
protected
:
RefPtr
<
mozilla
:
:
dom
:
:
HTMLCanvasElement
>
mCanvasElement
;
RefPtr
<
mozilla
:
:
dom
:
:
OffscreenCanvas
>
mOffscreenCanvas
;
RefPtr
<
nsRefreshDriver
>
mRefreshDriver
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsICanvasRenderingContextInternal
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
)
#
endif
