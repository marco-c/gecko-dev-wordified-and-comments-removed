#
ifndef
nsICanvasRenderingContextInternal_h___
#
define
nsICanvasRenderingContextInternal_h___
#
include
<
memory
>
#
include
"
gfxRect
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsRefreshObservers
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
OffscreenCanvas
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
define
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
\
{
\
0xb84f2fed
0x9d4b
0x430b
{
\
0xbd
0xfb
0x85
0x57
0x8a
0xc2
0xb4
0x4b
\
}
\
}
class
nsIDocShell
;
class
nsRefreshDriver
;
namespace
mozilla
{
class
nsDisplayListBuilder
;
class
ClientWebGLContext
;
class
PresShell
;
namespace
layers
{
class
CanvasLayer
;
class
CanvasRenderer
;
class
CompositableHandle
;
class
Layer
;
class
Image
;
class
LayerManager
;
class
LayerTransactionChild
;
class
PersistentBufferProvider
;
class
WebRenderCanvasData
;
}
namespace
gfx
{
class
SourceSurface
;
}
}
class
nsICanvasRenderingContextInternal
:
public
nsISupports
public
nsAPostRefreshObserver
{
public
:
using
CanvasLayer
=
mozilla
:
:
layers
:
:
CanvasLayer
;
using
CanvasRenderer
=
mozilla
:
:
layers
:
:
CanvasRenderer
;
using
Layer
=
mozilla
:
:
layers
:
:
Layer
;
using
LayerManager
=
mozilla
:
:
layers
:
:
LayerManager
;
using
WebRenderCanvasData
=
mozilla
:
:
layers
:
:
WebRenderCanvasData
;
using
CompositableHandle
=
mozilla
:
:
layers
:
:
CompositableHandle
;
using
LayerTransactionChild
=
mozilla
:
:
layers
:
:
LayerTransactionChild
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
)
nsICanvasRenderingContextInternal
(
)
;
~
nsICanvasRenderingContextInternal
(
)
;
void
SetCanvasElement
(
mozilla
:
:
dom
:
:
HTMLCanvasElement
*
parentCanvas
)
{
RemovePostRefreshObserver
(
)
;
mCanvasElement
=
parentCanvas
;
AddPostRefreshObserverIfNecessary
(
)
;
}
virtual
mozilla
:
:
PresShell
*
GetPresShell
(
)
;
void
RemovePostRefreshObserver
(
)
;
void
AddPostRefreshObserverIfNecessary
(
)
;
mozilla
:
:
dom
:
:
HTMLCanvasElement
*
GetParentObject
(
)
const
{
return
mCanvasElement
;
}
void
SetOffscreenCanvas
(
mozilla
:
:
dom
:
:
OffscreenCanvas
*
aOffscreenCanvas
)
{
mOffscreenCanvas
=
aOffscreenCanvas
;
}
virtual
int32_t
GetWidth
(
)
=
0
;
virtual
int32_t
GetHeight
(
)
=
0
;
NS_IMETHOD
SetDimensions
(
int32_t
width
int32_t
height
)
=
0
;
NS_IMETHOD
InitializeWithDrawTarget
(
nsIDocShell
*
aDocShell
mozilla
:
:
NotNull
<
mozilla
:
:
gfx
:
:
DrawTarget
*
>
aTarget
)
=
0
;
virtual
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
GetImageBuffer
(
int32_t
*
format
)
=
0
;
NS_IMETHOD
GetInputStream
(
const
char
*
mimeType
const
nsAString
&
encoderOptions
nsIInputStream
*
*
stream
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
GetSurfaceSnapshot
(
gfxAlphaType
*
out_alphaType
=
nullptr
)
=
0
;
virtual
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
GetFrontBufferSnapshot
(
bool
)
{
return
GetSurfaceSnapshot
(
)
;
}
virtual
void
SetOpaqueValueFromOpaqueAttr
(
bool
aOpaqueAttrValue
)
=
0
;
virtual
bool
GetIsOpaque
(
)
=
0
;
NS_IMETHOD
Reset
(
)
=
0
;
virtual
already_AddRefed
<
Layer
>
GetCanvasLayer
(
mozilla
:
:
nsDisplayListBuilder
*
builder
Layer
*
oldLayer
LayerManager
*
manager
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
layers
:
:
Image
>
GetAsImage
(
)
{
return
nullptr
;
}
virtual
bool
UpdateWebRenderCanvasData
(
mozilla
:
:
nsDisplayListBuilder
*
aBuilder
WebRenderCanvasData
*
aCanvasData
)
{
return
false
;
}
virtual
bool
InitializeCanvasRenderer
(
mozilla
:
:
nsDisplayListBuilder
*
aBuilder
CanvasRenderer
*
aRenderer
)
{
return
false
;
}
virtual
bool
ShouldForceInactiveLayer
(
LayerManager
*
manager
)
{
return
false
;
}
virtual
void
MarkContextClean
(
)
=
0
;
virtual
void
MarkContextCleanForFrameCapture
(
)
=
0
;
virtual
bool
IsContextCleanForFrameCapture
(
)
=
0
;
NS_IMETHOD
Redraw
(
const
gfxRect
&
dirty
)
=
0
;
NS_IMETHOD
SetContextOptions
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
options
mozilla
:
:
ErrorResult
&
aRvForDictionaryInit
)
{
return
NS_OK
;
}
virtual
bool
GetHitRegionRect
(
mozilla
:
:
dom
:
:
Element
*
element
nsRect
&
rect
)
{
return
false
;
}
virtual
nsString
GetHitRegion
(
const
mozilla
:
:
gfx
:
:
Point
&
point
)
{
return
nsString
(
)
;
}
virtual
void
OnVisibilityChange
(
)
{
}
virtual
void
OnMemoryPressure
(
)
{
}
virtual
void
OnBeforePaintTransaction
(
)
{
}
virtual
void
OnDidPaintTransaction
(
)
{
}
virtual
mozilla
:
:
layers
:
:
PersistentBufferProvider
*
GetBufferProvider
(
)
{
return
nullptr
;
}
virtual
mozilla
:
:
ClientWebGLContext
*
AsWebgl
(
)
{
return
nullptr
;
}
NS_IMETHOD
SetIsIPC
(
bool
isIPC
)
=
0
;
protected
:
RefPtr
<
mozilla
:
:
dom
:
:
HTMLCanvasElement
>
mCanvasElement
;
RefPtr
<
mozilla
:
:
dom
:
:
OffscreenCanvas
>
mOffscreenCanvas
;
RefPtr
<
nsRefreshDriver
>
mRefreshDriver
;
public
:
const
std
:
:
shared_ptr
<
nsICanvasRenderingContextInternal
*
const
>
mSharedPtrPtr
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsICanvasRenderingContextInternal
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
)
#
endif
