#
ifndef
nsICanvasRenderingContextInternal_h___
#
define
nsICanvasRenderingContextInternal_h___
#
include
"
gfxRect
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsRefreshObservers
.
h
"
#
include
"
nsRFPService
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
OffscreenCanvas
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StateWatching
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
layers
/
LayersSurfaces
.
h
"
#
define
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
\
{
\
0xb84f2fed
0x9d4b
0x430b
{
\
0xbd
0xfb
0x85
0x57
0x8a
0xc2
0xb4
0x4b
\
}
\
}
class
nsIDocShell
;
class
nsIPrincipal
;
class
nsRefreshDriver
;
namespace
mozilla
{
class
nsDisplayListBuilder
;
class
ClientWebGLContext
;
class
PresShell
;
class
WebGLFramebufferJS
;
namespace
layers
{
class
CanvasRenderer
;
class
Layer
;
class
Image
;
class
LayerManager
;
class
LayerTransactionChild
;
class
PersistentBufferProvider
;
class
WebRenderCanvasData
;
}
namespace
gfx
{
class
DrawTarget
;
class
SourceSurface
;
}
}
enum
class
FrameCaptureState
:
uint8_t
{
CLEAN
DIRTY
}
;
class
nsICanvasRenderingContextInternal
:
public
nsISupports
public
mozilla
:
:
SupportsWeakPtr
public
nsAPostRefreshObserver
{
public
:
using
CanvasRenderer
=
mozilla
:
:
layers
:
:
CanvasRenderer
;
using
WebRenderCanvasData
=
mozilla
:
:
layers
:
:
WebRenderCanvasData
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
)
nsICanvasRenderingContextInternal
(
)
;
~
nsICanvasRenderingContextInternal
(
)
;
void
SetCanvasElement
(
mozilla
:
:
dom
:
:
HTMLCanvasElement
*
parentCanvas
)
{
RemovePostRefreshObserver
(
)
;
mCanvasElement
=
parentCanvas
;
AddPostRefreshObserverIfNecessary
(
)
;
}
virtual
mozilla
:
:
PresShell
*
GetPresShell
(
)
;
void
RemovePostRefreshObserver
(
)
;
void
AddPostRefreshObserverIfNecessary
(
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
;
nsIPrincipal
*
PrincipalOrNull
(
)
const
;
void
SetOffscreenCanvas
(
mozilla
:
:
dom
:
:
OffscreenCanvas
*
aOffscreenCanvas
)
{
mOffscreenCanvas
=
aOffscreenCanvas
;
}
virtual
int32_t
GetWidth
(
)
=
0
;
virtual
int32_t
GetHeight
(
)
=
0
;
NS_IMETHOD
SetDimensions
(
int32_t
width
int32_t
height
)
=
0
;
virtual
void
Initialize
(
)
{
}
NS_IMETHOD
InitializeWithDrawTarget
(
nsIDocShell
*
aDocShell
mozilla
:
:
NotNull
<
mozilla
:
:
gfx
:
:
DrawTarget
*
>
aTarget
)
=
0
;
virtual
mozilla
:
:
UniquePtr
<
uint8_t
[
]
>
GetImageBuffer
(
int32_t
*
out_format
mozilla
:
:
gfx
:
:
IntSize
*
out_imageSize
)
=
0
;
NS_IMETHOD
GetInputStream
(
const
char
*
mimeType
const
nsAString
&
encoderOptions
nsIInputStream
*
*
stream
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
GetSurfaceSnapshot
(
gfxAlphaType
*
out_alphaType
=
nullptr
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
GetOptimizedSnapshot
(
mozilla
:
:
gfx
:
:
DrawTarget
*
aTarget
gfxAlphaType
*
out_alphaType
=
nullptr
)
{
return
GetSurfaceSnapshot
(
out_alphaType
)
;
}
virtual
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
GetFrontBufferSnapshot
(
bool
)
{
return
GetSurfaceSnapshot
(
)
;
}
virtual
void
SetOpaqueValueFromOpaqueAttr
(
bool
aOpaqueAttrValue
)
=
0
;
virtual
bool
GetIsOpaque
(
)
=
0
;
virtual
void
ResetBitmap
(
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
layers
:
:
Image
>
GetAsImage
(
)
{
return
nullptr
;
}
virtual
bool
UpdateWebRenderCanvasData
(
mozilla
:
:
nsDisplayListBuilder
*
aBuilder
WebRenderCanvasData
*
aCanvasData
)
{
return
false
;
}
virtual
bool
InitializeCanvasRenderer
(
mozilla
:
:
nsDisplayListBuilder
*
aBuilder
CanvasRenderer
*
aRenderer
)
{
return
false
;
}
virtual
void
MarkContextClean
(
)
=
0
;
virtual
void
MarkContextCleanForFrameCapture
(
)
=
0
;
virtual
mozilla
:
:
Watchable
<
FrameCaptureState
>
*
GetFrameCaptureState
(
)
=
0
;
NS_IMETHOD
Redraw
(
const
gfxRect
&
dirty
)
=
0
;
NS_IMETHOD
SetContextOptions
(
JSContext
*
cx
JS
:
:
Handle
<
JS
:
:
Value
>
options
mozilla
:
:
ErrorResult
&
aRvForDictionaryInit
)
{
return
NS_OK
;
}
virtual
void
OnMemoryPressure
(
)
{
}
virtual
void
OnBeforePaintTransaction
(
)
{
}
virtual
void
OnDidPaintTransaction
(
)
{
}
virtual
mozilla
:
:
layers
:
:
PersistentBufferProvider
*
GetBufferProvider
(
)
{
return
nullptr
;
}
virtual
mozilla
:
:
Maybe
<
mozilla
:
:
layers
:
:
SurfaceDescriptor
>
GetFrontBuffer
(
mozilla
:
:
WebGLFramebufferJS
*
const
bool
webvr
=
false
)
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
mozilla
:
:
Maybe
<
mozilla
:
:
layers
:
:
SurfaceDescriptor
>
PresentFrontBuffer
(
mozilla
:
:
WebGLFramebufferJS
*
fb
mozilla
:
:
layers
:
:
TextureType
const
bool
webvr
=
false
)
{
return
GetFrontBuffer
(
fb
webvr
)
;
}
void
DoSecurityCheck
(
nsIPrincipal
*
aPrincipal
bool
forceWriteOnly
bool
CORSUsed
)
;
bool
ShouldResistFingerprinting
(
mozilla
:
:
RFPTarget
aTarget
=
mozilla
:
:
RFPTarget
:
:
Unknown
)
const
;
protected
:
RefPtr
<
mozilla
:
:
dom
:
:
HTMLCanvasElement
>
mCanvasElement
;
RefPtr
<
mozilla
:
:
dom
:
:
OffscreenCanvas
>
mOffscreenCanvas
;
RefPtr
<
nsRefreshDriver
>
mRefreshDriver
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsICanvasRenderingContextInternal
NS_ICANVASRENDERINGCONTEXTINTERNAL_IID
)
#
endif
