#
include
"
CanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
SVGImageContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
mozilla
/
css
/
StyleRule
.
h
"
#
include
"
mozilla
/
css
/
Declaration
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsGfxCIID
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
ImageEncoder
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxASurface
.
h
"
#
include
"
gfxImageSurface
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxFont
.
h
"
#
include
"
gfxBlur
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsBidi
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
CanvasUtils
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
CanvasImageCache
.
h
"
#
include
<
algorithm
>
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
Conversions
.
h
"
#
include
"
mozilla
/
Alignment
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmap
.
h
"
#
include
"
mozilla
/
dom
/
ImageData
.
h
"
#
include
"
mozilla
/
dom
/
PBrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
Endian
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
PatternHelpers
.
h
"
#
include
"
mozilla
/
ipc
/
DocumentRendererParent
.
h
"
#
include
"
mozilla
/
ipc
/
PDocumentRendererParent
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2DBinding
.
h
"
#
include
"
mozilla
/
dom
/
CanvasPath
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLVideoElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGMatrix
.
h
"
#
include
"
mozilla
/
dom
/
TextMetrics
.
h
"
#
include
"
mozilla
/
dom
/
SVGMatrix
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
GLContext
.
h
"
#
include
"
GLContextProvider
.
h
"
#
include
"
SVGContentUtils
.
h
"
#
include
"
SVGImageContext
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsFilterInstance
.
h
"
#
include
"
nsSVGLength2
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
Units
.
h
"
#
include
"
CanvasUtils
.
h
"
#
undef
free
/
/
apparently
defined
by
some
windows
header
clashing
with
a
free
(
)
#
include
"
SkiaGLGlue
.
h
"
#
ifdef
USE_SKIA
#
include
"
SurfaceTypes
.
h
"
#
include
"
GLBlitHelper
.
h
"
#
endif
using
mozilla
:
:
gl
:
:
GLContext
;
using
mozilla
:
:
gl
:
:
SkiaGLGlue
;
using
mozilla
:
:
gl
:
:
GLContextProvider
;
#
ifdef
XP_WIN
#
include
"
gfxWindowsPlatform
.
h
"
#
endif
#
ifdef
MOZ_WIDGET_GONK
#
include
"
mozilla
/
layers
/
ShadowLayers
.
h
"
#
endif
#
undef
DrawText
using
namespace
mozilla
;
using
namespace
mozilla
:
:
CanvasUtils
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
layers
;
namespace
mozilla
{
namespace
dom
{
const
Float
SIGMA_MAX
=
100
;
static
int64_t
gCanvasAzureMemoryUsed
=
0
;
class
Canvas2dPixelsReporter
final
:
public
nsIMemoryReporter
{
~
Canvas2dPixelsReporter
(
)
{
}
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
return
MOZ_COLLECT_REPORT
(
"
canvas
-
2d
-
pixels
"
KIND_OTHER
UNITS_BYTES
gCanvasAzureMemoryUsed
"
Memory
used
by
2D
canvases
.
Each
canvas
requires
"
"
(
width
*
height
*
4
)
bytes
.
"
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
Canvas2dPixelsReporter
nsIMemoryReporter
)
class
CanvasRadialGradient
:
public
CanvasGradient
{
public
:
CanvasRadialGradient
(
CanvasRenderingContext2D
*
aContext
const
Point
&
aBeginOrigin
Float
aBeginRadius
const
Point
&
aEndOrigin
Float
aEndRadius
)
:
CanvasGradient
(
aContext
Type
:
:
RADIAL
)
mCenter1
(
aBeginOrigin
)
mCenter2
(
aEndOrigin
)
mRadius1
(
aBeginRadius
)
mRadius2
(
aEndRadius
)
{
}
Point
mCenter1
;
Point
mCenter2
;
Float
mRadius1
;
Float
mRadius2
;
}
;
class
CanvasLinearGradient
:
public
CanvasGradient
{
public
:
CanvasLinearGradient
(
CanvasRenderingContext2D
*
aContext
const
Point
&
aBegin
const
Point
&
aEnd
)
:
CanvasGradient
(
aContext
Type
:
:
LINEAR
)
mBegin
(
aBegin
)
mEnd
(
aEnd
)
{
}
protected
:
friend
class
CanvasGeneralPattern
;
Point
mBegin
;
Point
mEnd
;
}
;
class
CanvasGeneralPattern
{
public
:
typedef
CanvasRenderingContext2D
:
:
Style
Style
;
typedef
CanvasRenderingContext2D
:
:
ContextState
ContextState
;
Pattern
&
ForStyle
(
CanvasRenderingContext2D
*
aCtx
Style
aStyle
DrawTarget
*
aRT
)
{
NS_ASSERTION
(
!
mPattern
.
GetPattern
(
)
"
ForStyle
(
)
should
only
be
called
once
on
CanvasGeneralPattern
!
"
)
;
const
ContextState
&
state
=
aCtx
-
>
CurrentState
(
)
;
if
(
state
.
StyleIsColor
(
aStyle
)
)
{
mPattern
.
InitColorPattern
(
ToDeviceColor
(
state
.
colorStyles
[
aStyle
]
)
)
;
}
else
if
(
state
.
gradientStyles
[
aStyle
]
&
&
state
.
gradientStyles
[
aStyle
]
-
>
GetType
(
)
=
=
CanvasGradient
:
:
Type
:
:
LINEAR
)
{
CanvasLinearGradient
*
gradient
=
static_cast
<
CanvasLinearGradient
*
>
(
state
.
gradientStyles
[
aStyle
]
.
get
(
)
)
;
mPattern
.
InitLinearGradientPattern
(
gradient
-
>
mBegin
gradient
-
>
mEnd
gradient
-
>
GetGradientStopsForTarget
(
aRT
)
)
;
}
else
if
(
state
.
gradientStyles
[
aStyle
]
&
&
state
.
gradientStyles
[
aStyle
]
-
>
GetType
(
)
=
=
CanvasGradient
:
:
Type
:
:
RADIAL
)
{
CanvasRadialGradient
*
gradient
=
static_cast
<
CanvasRadialGradient
*
>
(
state
.
gradientStyles
[
aStyle
]
.
get
(
)
)
;
mPattern
.
InitRadialGradientPattern
(
gradient
-
>
mCenter1
gradient
-
>
mCenter2
gradient
-
>
mRadius1
gradient
-
>
mRadius2
gradient
-
>
GetGradientStopsForTarget
(
aRT
)
)
;
}
else
if
(
state
.
patternStyles
[
aStyle
]
)
{
if
(
aCtx
-
>
mCanvasElement
)
{
CanvasUtils
:
:
DoDrawImageSecurityCheck
(
aCtx
-
>
mCanvasElement
state
.
patternStyles
[
aStyle
]
-
>
mPrincipal
state
.
patternStyles
[
aStyle
]
-
>
mForceWriteOnly
state
.
patternStyles
[
aStyle
]
-
>
mCORSUsed
)
;
}
ExtendMode
mode
;
if
(
state
.
patternStyles
[
aStyle
]
-
>
mRepeat
=
=
CanvasPattern
:
:
RepeatMode
:
:
NOREPEAT
)
{
mode
=
ExtendMode
:
:
CLAMP
;
}
else
{
mode
=
ExtendMode
:
:
REPEAT
;
}
Filter
filter
;
if
(
state
.
imageSmoothingEnabled
)
{
filter
=
Filter
:
:
GOOD
;
}
else
{
filter
=
Filter
:
:
POINT
;
}
mPattern
.
InitSurfacePattern
(
state
.
patternStyles
[
aStyle
]
-
>
mSurface
mode
state
.
patternStyles
[
aStyle
]
-
>
mTransform
filter
)
;
}
return
*
mPattern
.
GetPattern
(
)
;
}
GeneralPattern
mPattern
;
}
;
class
AdjustedTargetForFilter
{
public
:
typedef
CanvasRenderingContext2D
:
:
ContextState
ContextState
;
AdjustedTargetForFilter
(
CanvasRenderingContext2D
*
aCtx
DrawTarget
*
aFinalTarget
const
gfx
:
:
IntPoint
&
aFilterSpaceToTargetOffset
const
gfx
:
:
IntRect
&
aPreFilterBounds
const
gfx
:
:
IntRect
&
aPostFilterBounds
gfx
:
:
CompositionOp
aCompositionOp
)
:
mCtx
(
nullptr
)
mCompositionOp
(
aCompositionOp
)
{
mCtx
=
aCtx
;
mFinalTarget
=
aFinalTarget
;
mPostFilterBounds
=
aPostFilterBounds
;
mOffset
=
aFilterSpaceToTargetOffset
;
nsIntRegion
sourceGraphicNeededRegion
;
nsIntRegion
fillPaintNeededRegion
;
nsIntRegion
strokePaintNeededRegion
;
FilterSupport
:
:
ComputeSourceNeededRegions
(
aCtx
-
>
CurrentState
(
)
.
filter
mPostFilterBounds
sourceGraphicNeededRegion
fillPaintNeededRegion
strokePaintNeededRegion
)
;
mSourceGraphicRect
=
sourceGraphicNeededRegion
.
GetBounds
(
)
;
mFillPaintRect
=
fillPaintNeededRegion
.
GetBounds
(
)
;
mStrokePaintRect
=
strokePaintNeededRegion
.
GetBounds
(
)
;
mSourceGraphicRect
=
mSourceGraphicRect
.
Intersect
(
aPreFilterBounds
)
;
if
(
mSourceGraphicRect
.
IsEmpty
(
)
)
{
mSourceGraphicRect
.
SizeTo
(
1
1
)
;
}
mTarget
=
mFinalTarget
-
>
CreateSimilarDrawTarget
(
mSourceGraphicRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
mTarget
)
{
mTarget
=
mFinalTarget
;
mCtx
=
nullptr
;
mFinalTarget
=
nullptr
;
return
;
}
mTarget
-
>
SetTransform
(
mFinalTarget
-
>
GetTransform
(
)
.
PostTranslate
(
-
mSourceGraphicRect
.
TopLeft
(
)
+
mOffset
)
)
;
}
already_AddRefed
<
SourceSurface
>
DoSourcePaint
(
gfx
:
:
IntRect
&
aRect
CanvasRenderingContext2D
:
:
Style
aStyle
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
nullptr
;
}
RefPtr
<
DrawTarget
>
dt
=
mFinalTarget
-
>
CreateSimilarDrawTarget
(
aRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
)
{
aRect
.
SetEmpty
(
)
;
return
nullptr
;
}
Matrix
transform
=
mFinalTarget
-
>
GetTransform
(
)
.
PostTranslate
(
-
aRect
.
TopLeft
(
)
+
mOffset
)
;
dt
-
>
SetTransform
(
transform
)
;
if
(
transform
.
Invert
(
)
)
{
gfx
:
:
Rect
dtBounds
(
0
0
aRect
.
width
aRect
.
height
)
;
gfx
:
:
Rect
fillRect
=
transform
.
TransformBounds
(
dtBounds
)
;
dt
-
>
FillRect
(
fillRect
CanvasGeneralPattern
(
)
.
ForStyle
(
mCtx
aStyle
dt
)
)
;
}
return
dt
-
>
Snapshot
(
)
;
}
~
AdjustedTargetForFilter
(
)
{
if
(
!
mCtx
)
{
return
;
}
RefPtr
<
SourceSurface
>
snapshot
=
mTarget
-
>
Snapshot
(
)
;
RefPtr
<
SourceSurface
>
fillPaint
=
DoSourcePaint
(
mFillPaintRect
CanvasRenderingContext2D
:
:
Style
:
:
FILL
)
;
RefPtr
<
SourceSurface
>
strokePaint
=
DoSourcePaint
(
mStrokePaintRect
CanvasRenderingContext2D
:
:
Style
:
:
STROKE
)
;
AutoRestoreTransform
autoRestoreTransform
(
mFinalTarget
)
;
mFinalTarget
-
>
SetTransform
(
Matrix
(
)
)
;
gfx
:
:
FilterSupport
:
:
RenderFilterDescription
(
mFinalTarget
mCtx
-
>
CurrentState
(
)
.
filter
gfx
:
:
Rect
(
mPostFilterBounds
)
snapshot
mSourceGraphicRect
fillPaint
mFillPaintRect
strokePaint
mStrokePaintRect
mCtx
-
>
CurrentState
(
)
.
filterAdditionalImages
mPostFilterBounds
.
TopLeft
(
)
-
mOffset
DrawOptions
(
1
.
0f
mCompositionOp
)
)
;
}
DrawTarget
*
DT
(
)
{
return
mTarget
;
}
private
:
RefPtr
<
DrawTarget
>
mTarget
;
RefPtr
<
DrawTarget
>
mFinalTarget
;
CanvasRenderingContext2D
*
mCtx
;
gfx
:
:
IntRect
mSourceGraphicRect
;
gfx
:
:
IntRect
mFillPaintRect
;
gfx
:
:
IntRect
mStrokePaintRect
;
gfx
:
:
IntRect
mPostFilterBounds
;
gfx
:
:
IntPoint
mOffset
;
gfx
:
:
CompositionOp
mCompositionOp
;
}
;
class
AdjustedTargetForShadow
{
public
:
typedef
CanvasRenderingContext2D
:
:
ContextState
ContextState
;
AdjustedTargetForShadow
(
CanvasRenderingContext2D
*
aCtx
DrawTarget
*
aFinalTarget
const
gfx
:
:
Rect
&
aBounds
gfx
:
:
CompositionOp
aCompositionOp
)
:
mCtx
(
nullptr
)
mCompositionOp
(
aCompositionOp
)
{
mCtx
=
aCtx
;
mFinalTarget
=
aFinalTarget
;
const
ContextState
&
state
=
mCtx
-
>
CurrentState
(
)
;
mSigma
=
state
.
ShadowBlurSigma
(
)
;
gfx
:
:
Rect
bounds
=
aBounds
;
int32_t
blurRadius
=
state
.
ShadowBlurRadius
(
)
;
bounds
.
Inflate
(
blurRadius
)
;
bounds
.
RoundOut
(
)
;
bounds
.
ToIntRect
(
&
mTempRect
)
;
mTarget
=
mFinalTarget
-
>
CreateShadowDrawTarget
(
mTempRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
mSigma
)
;
if
(
!
mTarget
)
{
mTarget
=
mFinalTarget
;
mCtx
=
nullptr
;
mFinalTarget
=
nullptr
;
}
else
{
mTarget
-
>
SetTransform
(
mFinalTarget
-
>
GetTransform
(
)
.
PostTranslate
(
-
mTempRect
.
TopLeft
(
)
)
)
;
}
}
~
AdjustedTargetForShadow
(
)
{
if
(
!
mCtx
)
{
return
;
}
RefPtr
<
SourceSurface
>
snapshot
=
mTarget
-
>
Snapshot
(
)
;
mFinalTarget
-
>
DrawSurfaceWithShadow
(
snapshot
mTempRect
.
TopLeft
(
)
Color
:
:
FromABGR
(
mCtx
-
>
CurrentState
(
)
.
shadowColor
)
mCtx
-
>
CurrentState
(
)
.
shadowOffset
mSigma
mCompositionOp
)
;
}
DrawTarget
*
DT
(
)
{
return
mTarget
;
}
gfx
:
:
IntPoint
OffsetToFinalDT
(
)
{
return
mTempRect
.
TopLeft
(
)
;
}
private
:
RefPtr
<
DrawTarget
>
mTarget
;
RefPtr
<
DrawTarget
>
mFinalTarget
;
CanvasRenderingContext2D
*
mCtx
;
Float
mSigma
;
gfx
:
:
IntRect
mTempRect
;
gfx
:
:
CompositionOp
mCompositionOp
;
}
;
class
AdjustedTarget
{
public
:
typedef
CanvasRenderingContext2D
:
:
ContextState
ContextState
;
explicit
AdjustedTarget
(
CanvasRenderingContext2D
*
aCtx
const
gfx
:
:
Rect
*
aBounds
=
nullptr
)
{
mTarget
=
aCtx
-
>
mTarget
;
gfx
:
:
Rect
r
(
0
0
aCtx
-
>
mWidth
aCtx
-
>
mHeight
)
;
gfx
:
:
Rect
maxSourceNeededBoundsForShadow
=
MaxSourceNeededBoundsForShadow
(
r
aCtx
)
;
gfx
:
:
Rect
maxSourceNeededBoundsForFilter
=
MaxSourceNeededBoundsForFilter
(
maxSourceNeededBoundsForShadow
aCtx
)
;
gfx
:
:
Rect
bounds
=
maxSourceNeededBoundsForFilter
;
if
(
aBounds
)
{
bounds
=
bounds
.
Intersect
(
*
aBounds
)
;
}
gfx
:
:
Rect
boundsAfterFilter
=
BoundsAfterFilter
(
bounds
aCtx
)
;
mozilla
:
:
gfx
:
:
CompositionOp
op
=
aCtx
-
>
CurrentState
(
)
.
op
;
gfx
:
:
IntPoint
offsetToFinalDT
;
if
(
aCtx
-
>
NeedToDrawShadow
(
)
)
{
mShadowTarget
=
MakeUnique
<
AdjustedTargetForShadow
>
(
aCtx
mTarget
boundsAfterFilter
op
)
;
mTarget
=
mShadowTarget
-
>
DT
(
)
;
offsetToFinalDT
=
mShadowTarget
-
>
OffsetToFinalDT
(
)
;
op
=
gfx
:
:
CompositionOp
:
:
OP_OVER
;
}
if
(
aCtx
-
>
NeedToApplyFilter
(
)
)
{
bounds
.
RoundOut
(
)
;
gfx
:
:
IntRect
intBounds
;
if
(
!
bounds
.
ToIntRect
(
&
intBounds
)
)
{
return
;
}
mFilterTarget
=
MakeUnique
<
AdjustedTargetForFilter
>
(
aCtx
mTarget
offsetToFinalDT
intBounds
gfx
:
:
RoundedToInt
(
boundsAfterFilter
)
op
)
;
mTarget
=
mFilterTarget
-
>
DT
(
)
;
}
}
~
AdjustedTarget
(
)
{
mFilterTarget
.
reset
(
)
;
mShadowTarget
.
reset
(
)
;
}
operator
DrawTarget
*
(
)
{
return
mTarget
;
}
DrawTarget
*
operator
-
>
(
)
MOZ_NO_ADDREF_RELEASE_ON_RETURN
{
return
mTarget
;
}
private
:
gfx
:
:
Rect
MaxSourceNeededBoundsForFilter
(
const
gfx
:
:
Rect
&
aDestBounds
CanvasRenderingContext2D
*
aCtx
)
{
if
(
!
aCtx
-
>
NeedToApplyFilter
(
)
)
{
return
aDestBounds
;
}
nsIntRegion
sourceGraphicNeededRegion
;
nsIntRegion
fillPaintNeededRegion
;
nsIntRegion
strokePaintNeededRegion
;
FilterSupport
:
:
ComputeSourceNeededRegions
(
aCtx
-
>
CurrentState
(
)
.
filter
gfx
:
:
RoundedToInt
(
aDestBounds
)
sourceGraphicNeededRegion
fillPaintNeededRegion
strokePaintNeededRegion
)
;
return
gfx
:
:
Rect
(
sourceGraphicNeededRegion
.
GetBounds
(
)
)
;
}
gfx
:
:
Rect
MaxSourceNeededBoundsForShadow
(
const
gfx
:
:
Rect
&
aDestBounds
CanvasRenderingContext2D
*
aCtx
)
{
if
(
!
aCtx
-
>
NeedToDrawShadow
(
)
)
{
return
aDestBounds
;
}
const
ContextState
&
state
=
aCtx
-
>
CurrentState
(
)
;
gfx
:
:
Rect
sourceBounds
=
aDestBounds
-
state
.
shadowOffset
;
sourceBounds
.
Inflate
(
state
.
ShadowBlurRadius
(
)
)
;
return
sourceBounds
.
Union
(
aDestBounds
)
;
}
gfx
:
:
Rect
BoundsAfterFilter
(
const
gfx
:
:
Rect
&
aBounds
CanvasRenderingContext2D
*
aCtx
)
{
if
(
!
aCtx
-
>
NeedToApplyFilter
(
)
)
{
return
aBounds
;
}
gfx
:
:
Rect
bounds
(
aBounds
)
;
bounds
.
RoundOut
(
)
;
gfx
:
:
IntRect
intBounds
;
if
(
!
bounds
.
ToIntRect
(
&
intBounds
)
)
{
return
gfx
:
:
Rect
(
)
;
}
nsIntRegion
extents
=
gfx
:
:
FilterSupport
:
:
ComputePostFilterExtents
(
aCtx
-
>
CurrentState
(
)
.
filter
intBounds
)
;
return
gfx
:
:
Rect
(
extents
.
GetBounds
(
)
)
;
}
RefPtr
<
DrawTarget
>
mTarget
;
UniquePtr
<
AdjustedTargetForShadow
>
mShadowTarget
;
UniquePtr
<
AdjustedTargetForFilter
>
mFilterTarget
;
}
;
void
CanvasPattern
:
:
SetTransform
(
SVGMatrix
&
aMatrix
)
{
mTransform
=
ToMatrix
(
aMatrix
.
GetMatrix
(
)
)
;
}
void
CanvasGradient
:
:
AddColorStop
(
float
aOffset
const
nsAString
&
aColorstr
ErrorResult
&
aRv
)
{
if
(
aOffset
<
0
.
0
|
|
aOffset
>
1
.
0
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
nsCSSValue
value
;
nsCSSParser
parser
;
if
(
!
parser
.
ParseColorString
(
aColorstr
nullptr
0
value
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
nscolor
color
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mContext
?
mContext
-
>
GetPresShell
(
)
:
nullptr
;
if
(
!
nsRuleNode
:
:
ComputeColor
(
value
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
nullptr
color
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
mStops
=
nullptr
;
GradientStop
newStop
;
newStop
.
offset
=
aOffset
;
newStop
.
color
=
Color
:
:
FromABGR
(
color
)
;
mRawStops
.
AppendElement
(
newStop
)
;
}
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
CanvasGradient
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
CanvasGradient
Release
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
CanvasGradient
mContext
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
CanvasPattern
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
CanvasPattern
Release
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
CanvasPattern
mContext
)
class
CanvasDrawObserver
{
public
:
explicit
CanvasDrawObserver
(
CanvasRenderingContext2D
*
aCanvasContext
)
;
enum
DrawCallType
{
PutImageData
GetImageData
DrawImage
}
;
void
DidDrawCall
(
DrawCallType
aType
)
;
bool
FrameEnd
(
)
;
private
:
int32_t
mMinFramesBeforeDecision
;
float
mMinSecondsBeforeDecision
;
int32_t
mMinCallsBeforeDecision
;
CanvasRenderingContext2D
*
mCanvasContext
;
int32_t
mSoftwarePreferredCalls
;
int32_t
mGPUPreferredCalls
;
int32_t
mFramesRendered
;
TimeStamp
mCreationTime
;
}
;
CanvasDrawObserver
:
:
CanvasDrawObserver
(
CanvasRenderingContext2D
*
aCanvasContext
)
:
mMinFramesBeforeDecision
(
gfxPrefs
:
:
CanvasAutoAccelerateMinFrames
(
)
)
mMinSecondsBeforeDecision
(
gfxPrefs
:
:
CanvasAutoAccelerateMinSeconds
(
)
)
mMinCallsBeforeDecision
(
gfxPrefs
:
:
CanvasAutoAccelerateMinCalls
(
)
)
mCanvasContext
(
aCanvasContext
)
mSoftwarePreferredCalls
(
0
)
mGPUPreferredCalls
(
0
)
mFramesRendered
(
0
)
mCreationTime
(
TimeStamp
:
:
NowLoRes
(
)
)
{
}
void
CanvasDrawObserver
:
:
DidDrawCall
(
DrawCallType
aType
)
{
switch
(
aType
)
{
case
PutImageData
:
case
GetImageData
:
if
(
mGPUPreferredCalls
=
=
0
&
&
mSoftwarePreferredCalls
=
=
0
)
{
mCreationTime
=
TimeStamp
:
:
NowLoRes
(
)
;
}
mSoftwarePreferredCalls
+
+
;
break
;
case
DrawImage
:
if
(
mGPUPreferredCalls
=
=
0
&
&
mSoftwarePreferredCalls
=
=
0
)
{
mCreationTime
=
TimeStamp
:
:
NowLoRes
(
)
;
}
mGPUPreferredCalls
+
+
;
break
;
}
}
bool
CanvasDrawObserver
:
:
FrameEnd
(
)
{
mFramesRendered
+
+
;
if
(
(
mFramesRendered
>
=
mMinFramesBeforeDecision
)
|
|
(
(
TimeStamp
:
:
NowLoRes
(
)
-
mCreationTime
)
.
ToSeconds
(
)
)
>
mMinSecondsBeforeDecision
)
{
if
(
mGPUPreferredCalls
>
mMinCallsBeforeDecision
|
|
mSoftwarePreferredCalls
>
mMinCallsBeforeDecision
)
{
if
(
mGPUPreferredCalls
>
=
mSoftwarePreferredCalls
)
{
mCanvasContext
-
>
SwitchRenderingMode
(
CanvasRenderingContext2D
:
:
RenderingMode
:
:
OpenGLBackendMode
)
;
}
else
{
mCanvasContext
-
>
SwitchRenderingMode
(
CanvasRenderingContext2D
:
:
RenderingMode
:
:
SoftwareBackendMode
)
;
}
}
return
true
;
}
return
false
;
}
class
CanvasRenderingContext2DUserData
:
public
LayerUserData
{
public
:
explicit
CanvasRenderingContext2DUserData
(
CanvasRenderingContext2D
*
aContext
)
:
mContext
(
aContext
)
{
aContext
-
>
mUserDatas
.
AppendElement
(
this
)
;
}
~
CanvasRenderingContext2DUserData
(
)
{
if
(
mContext
)
{
mContext
-
>
mUserDatas
.
RemoveElement
(
this
)
;
}
}
static
void
PreTransactionCallback
(
void
*
aData
)
{
CanvasRenderingContext2DUserData
*
self
=
static_cast
<
CanvasRenderingContext2DUserData
*
>
(
aData
)
;
CanvasRenderingContext2D
*
context
=
self
-
>
mContext
;
if
(
!
context
|
|
!
context
-
>
mTarget
)
return
;
context
-
>
mTarget
-
>
Flush
(
)
;
context
-
>
ReturnTarget
(
)
;
}
static
void
DidTransactionCallback
(
void
*
aData
)
{
CanvasRenderingContext2DUserData
*
self
=
static_cast
<
CanvasRenderingContext2DUserData
*
>
(
aData
)
;
if
(
self
-
>
mContext
)
{
self
-
>
mContext
-
>
MarkContextClean
(
)
;
if
(
self
-
>
mContext
-
>
mDrawObserver
)
{
if
(
self
-
>
mContext
-
>
mDrawObserver
-
>
FrameEnd
(
)
)
{
self
-
>
mContext
-
>
RemoveDrawObserver
(
)
;
}
}
}
}
bool
IsForContext
(
CanvasRenderingContext2D
*
aContext
)
{
return
mContext
=
=
aContext
;
}
void
Forget
(
)
{
mContext
=
nullptr
;
}
private
:
CanvasRenderingContext2D
*
mContext
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
CanvasRenderingContext2D
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
CanvasRenderingContext2D
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
CanvasRenderingContext2D
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
CanvasRenderingContext2D
)
CanvasRenderingContext2D
:
:
RemoveDemotableContext
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCanvasElement
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mStyleStack
.
Length
(
)
;
i
+
+
)
{
ImplCycleCollectionUnlink
(
tmp
-
>
mStyleStack
[
i
]
.
patternStyles
[
Style
:
:
STROKE
]
)
;
ImplCycleCollectionUnlink
(
tmp
-
>
mStyleStack
[
i
]
.
patternStyles
[
Style
:
:
FILL
]
)
;
ImplCycleCollectionUnlink
(
tmp
-
>
mStyleStack
[
i
]
.
gradientStyles
[
Style
:
:
STROKE
]
)
;
ImplCycleCollectionUnlink
(
tmp
-
>
mStyleStack
[
i
]
.
gradientStyles
[
Style
:
:
FILL
]
)
;
}
for
(
size_t
x
=
0
;
x
<
tmp
-
>
mHitRegionsOptions
.
Length
(
)
;
x
+
+
)
{
RegionInfo
&
info
=
tmp
-
>
mHitRegionsOptions
[
x
]
;
if
(
info
.
mElement
)
{
ImplCycleCollectionUnlink
(
info
.
mElement
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
CanvasRenderingContext2D
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCanvasElement
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mStyleStack
.
Length
(
)
;
i
+
+
)
{
ImplCycleCollectionTraverse
(
cb
tmp
-
>
mStyleStack
[
i
]
.
patternStyles
[
Style
:
:
STROKE
]
"
Stroke
CanvasPattern
"
)
;
ImplCycleCollectionTraverse
(
cb
tmp
-
>
mStyleStack
[
i
]
.
patternStyles
[
Style
:
:
FILL
]
"
Fill
CanvasPattern
"
)
;
ImplCycleCollectionTraverse
(
cb
tmp
-
>
mStyleStack
[
i
]
.
gradientStyles
[
Style
:
:
STROKE
]
"
Stroke
CanvasGradient
"
)
;
ImplCycleCollectionTraverse
(
cb
tmp
-
>
mStyleStack
[
i
]
.
gradientStyles
[
Style
:
:
FILL
]
"
Fill
CanvasGradient
"
)
;
}
for
(
size_t
x
=
0
;
x
<
tmp
-
>
mHitRegionsOptions
.
Length
(
)
;
x
+
+
)
{
RegionInfo
&
info
=
tmp
-
>
mHitRegionsOptions
[
x
]
;
if
(
info
.
mElement
)
{
ImplCycleCollectionTraverse
(
cb
info
.
mElement
"
Hit
region
fallback
element
"
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
CanvasRenderingContext2D
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
CanvasRenderingContext2D
)
if
(
nsCCUncollectableMarker
:
:
sGeneration
&
&
tmp
-
>
IsBlack
(
)
)
{
dom
:
:
Element
*
canvasElement
=
tmp
-
>
mCanvasElement
;
if
(
canvasElement
)
{
if
(
canvasElement
-
>
IsPurple
(
)
)
{
canvasElement
-
>
RemovePurple
(
)
;
}
dom
:
:
Element
:
:
MarkNodeChildren
(
canvasElement
)
;
}
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
CanvasRenderingContext2D
)
return
nsCCUncollectableMarker
:
:
sGeneration
&
&
tmp
-
>
IsBlack
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
CanvasRenderingContext2D
)
return
nsCCUncollectableMarker
:
:
sGeneration
&
&
tmp
-
>
IsBlack
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
CanvasRenderingContext2D
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsICanvasRenderingContextInternal
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
uint32_t
CanvasRenderingContext2D
:
:
sNumLivingContexts
=
0
;
DrawTarget
*
CanvasRenderingContext2D
:
:
sErrorTarget
=
nullptr
;
CanvasRenderingContext2D
:
:
CanvasRenderingContext2D
(
)
:
mRenderingMode
(
RenderingMode
:
:
OpenGLBackendMode
)
#
ifdef
USE_SKIA_GPU
mVideoTexture
(
0
)
#
endif
mWidth
(
0
)
mHeight
(
0
)
mZero
(
false
)
mOpaque
(
false
)
mResetLayer
(
true
)
mIPC
(
false
)
mIsSkiaGL
(
false
)
mDrawObserver
(
nullptr
)
mIsEntireFrameInvalid
(
false
)
mPredictManyRedrawCalls
(
false
)
mIsCapturedFrameInvalid
(
false
)
mPathTransformWillUpdate
(
false
)
mInvalidateCount
(
0
)
{
sNumLivingContexts
+
+
;
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseAcceleratedSkiaCanvas
(
)
)
{
mRenderingMode
=
RenderingMode
:
:
SoftwareBackendMode
;
}
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
HaveChoiceOfHWAndSWCanvas
(
)
)
{
mDrawObserver
=
new
CanvasDrawObserver
(
this
)
;
}
}
CanvasRenderingContext2D
:
:
~
CanvasRenderingContext2D
(
)
{
RemoveDrawObserver
(
)
;
RemovePostRefreshObserver
(
)
;
Reset
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mUserDatas
.
Length
(
)
;
+
+
i
)
{
mUserDatas
[
i
]
-
>
Forget
(
)
;
}
sNumLivingContexts
-
-
;
if
(
!
sNumLivingContexts
)
{
NS_IF_RELEASE
(
sErrorTarget
)
;
}
#
ifdef
USE_SKIA_GPU
if
(
mVideoTexture
)
{
MOZ_ASSERT
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
"
null
SkiaGLGlue
"
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
-
>
GetGLContext
(
)
-
>
MakeCurrent
(
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
-
>
GetGLContext
(
)
-
>
fDeleteTextures
(
1
&
mVideoTexture
)
;
}
#
endif
RemoveDemotableContext
(
this
)
;
}
JSObject
*
CanvasRenderingContext2D
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
CanvasRenderingContext2DBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
bool
CanvasRenderingContext2D
:
:
ParseColor
(
const
nsAString
&
aString
nscolor
*
aColor
)
{
nsIDocument
*
document
=
mCanvasElement
?
mCanvasElement
-
>
OwnerDoc
(
)
:
nullptr
;
nsCSSParser
parser
(
document
?
document
-
>
CSSLoader
(
)
:
nullptr
)
;
nsCSSValue
value
;
if
(
!
parser
.
ParseColorString
(
aString
nullptr
0
value
)
)
{
return
false
;
}
if
(
value
.
IsNumericColorUnit
(
)
)
{
*
aColor
=
value
.
GetColorValue
(
)
;
}
else
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
RefPtr
<
nsStyleContext
>
parentContext
;
if
(
mCanvasElement
&
&
mCanvasElement
-
>
IsInDoc
(
)
)
{
parentContext
=
nsComputedDOMStyle
:
:
GetStyleContextForElement
(
mCanvasElement
nullptr
presShell
)
;
}
Unused
<
<
nsRuleNode
:
:
ComputeColor
(
value
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
parentContext
*
aColor
)
;
}
return
true
;
}
nsresult
CanvasRenderingContext2D
:
:
Reset
(
)
{
if
(
mCanvasElement
)
{
mCanvasElement
-
>
InvalidateCanvas
(
)
;
}
if
(
mTarget
&
&
IsTargetValid
(
)
&
&
!
mDocShell
)
{
gCanvasAzureMemoryUsed
-
=
mWidth
*
mHeight
*
4
;
}
ReturnTarget
(
)
;
mTarget
=
nullptr
;
mBufferProvider
=
nullptr
;
mHitRegionsOptions
.
ClearAndRetainStorage
(
)
;
mIsEntireFrameInvalid
=
false
;
mPredictManyRedrawCalls
=
false
;
mIsCapturedFrameInvalid
=
false
;
return
NS_OK
;
}
void
CanvasRenderingContext2D
:
:
SetStyleFromString
(
const
nsAString
&
aStr
Style
aWhichStyle
)
{
MOZ_ASSERT
(
!
aStr
.
IsVoid
(
)
)
;
nscolor
color
;
if
(
!
ParseColor
(
aStr
&
color
)
)
{
return
;
}
CurrentState
(
)
.
SetColorStyle
(
aWhichStyle
color
)
;
}
void
CanvasRenderingContext2D
:
:
GetStyleAsUnion
(
OwningStringOrCanvasGradientOrCanvasPattern
&
aValue
Style
aWhichStyle
)
{
const
ContextState
&
state
=
CurrentState
(
)
;
if
(
state
.
patternStyles
[
aWhichStyle
]
)
{
aValue
.
SetAsCanvasPattern
(
)
=
state
.
patternStyles
[
aWhichStyle
]
;
}
else
if
(
state
.
gradientStyles
[
aWhichStyle
]
)
{
aValue
.
SetAsCanvasGradient
(
)
=
state
.
gradientStyles
[
aWhichStyle
]
;
}
else
{
StyleColorToString
(
state
.
colorStyles
[
aWhichStyle
]
aValue
.
SetAsString
(
)
)
;
}
}
void
CanvasRenderingContext2D
:
:
StyleColorToString
(
const
nscolor
&
aColor
nsAString
&
aStr
)
{
if
(
NS_GET_A
(
aColor
)
=
=
255
)
{
CopyUTF8toUTF16
(
nsPrintfCString
(
"
#
%
02x
%
02x
%
02x
"
NS_GET_R
(
aColor
)
NS_GET_G
(
aColor
)
NS_GET_B
(
aColor
)
)
aStr
)
;
}
else
{
CopyUTF8toUTF16
(
nsPrintfCString
(
"
rgba
(
%
d
%
d
%
d
"
NS_GET_R
(
aColor
)
NS_GET_G
(
aColor
)
NS_GET_B
(
aColor
)
)
aStr
)
;
aStr
.
AppendFloat
(
nsStyleUtil
:
:
ColorComponentToFloat
(
NS_GET_A
(
aColor
)
)
)
;
aStr
.
Append
(
'
)
'
)
;
}
}
nsresult
CanvasRenderingContext2D
:
:
Redraw
(
)
{
mIsCapturedFrameInvalid
=
true
;
if
(
mIsEntireFrameInvalid
)
{
return
NS_OK
;
}
mIsEntireFrameInvalid
=
true
;
if
(
!
mCanvasElement
)
{
NS_ASSERTION
(
mDocShell
"
Redraw
with
no
canvas
element
or
docshell
!
"
)
;
return
NS_OK
;
}
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
mCanvasElement
)
;
mCanvasElement
-
>
InvalidateCanvasContent
(
nullptr
)
;
return
NS_OK
;
}
void
CanvasRenderingContext2D
:
:
Redraw
(
const
gfx
:
:
Rect
&
aR
)
{
mIsCapturedFrameInvalid
=
true
;
+
+
mInvalidateCount
;
if
(
mIsEntireFrameInvalid
)
{
return
;
}
if
(
mPredictManyRedrawCalls
|
|
mInvalidateCount
>
kCanvasMaxInvalidateCount
)
{
Redraw
(
)
;
return
;
}
if
(
!
mCanvasElement
)
{
NS_ASSERTION
(
mDocShell
"
Redraw
with
no
canvas
element
or
docshell
!
"
)
;
return
;
}
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
mCanvasElement
)
;
mCanvasElement
-
>
InvalidateCanvasContent
(
&
aR
)
;
}
void
CanvasRenderingContext2D
:
:
DidRefresh
(
)
{
if
(
IsTargetValid
(
)
&
&
SkiaGLTex
(
)
)
{
SkiaGLGlue
*
glue
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
;
MOZ_ASSERT
(
glue
)
;
auto
gl
=
glue
-
>
GetGLContext
(
)
;
gl
-
>
FlushIfHeavyGLCallsSinceLastFlush
(
)
;
}
}
void
CanvasRenderingContext2D
:
:
RedrawUser
(
const
gfxRect
&
aR
)
{
mIsCapturedFrameInvalid
=
true
;
if
(
mIsEntireFrameInvalid
)
{
+
+
mInvalidateCount
;
return
;
}
gfx
:
:
Rect
newr
=
mTarget
-
>
GetTransform
(
)
.
TransformBounds
(
ToRect
(
aR
)
)
;
Redraw
(
newr
)
;
}
bool
CanvasRenderingContext2D
:
:
SwitchRenderingMode
(
RenderingMode
aRenderingMode
)
{
if
(
!
IsTargetValid
(
)
|
|
mRenderingMode
=
=
aRenderingMode
)
{
return
false
;
}
#
ifdef
USE_SKIA_GPU
if
(
(
aRenderingMode
=
=
RenderingMode
:
:
OpenGLBackendMode
)
&
&
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
HaveChoiceOfHWAndSWCanvas
(
)
|
|
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseAcceleratedSkiaCanvas
(
)
)
)
{
return
false
;
}
if
(
mRenderingMode
=
=
RenderingMode
:
:
OpenGLBackendMode
)
{
if
(
mVideoTexture
)
{
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
-
>
GetGLContext
(
)
-
>
MakeCurrent
(
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
-
>
GetGLContext
(
)
-
>
fDeleteTextures
(
1
&
mVideoTexture
)
;
}
mCurrentVideoSize
.
width
=
0
;
mCurrentVideoSize
.
height
=
0
;
}
#
endif
RefPtr
<
SourceSurface
>
snapshot
;
Matrix
transform
;
if
(
mTarget
)
{
snapshot
=
mTarget
-
>
Snapshot
(
)
;
transform
=
mTarget
-
>
GetTransform
(
)
;
}
else
{
MOZ_ASSERT
(
mBufferProvider
)
;
transform
=
CurrentState
(
)
.
transform
;
snapshot
=
mBufferProvider
-
>
GetSnapshot
(
)
;
}
mTarget
=
nullptr
;
mBufferProvider
=
nullptr
;
mResetLayer
=
true
;
RenderingMode
attemptedMode
=
EnsureTarget
(
aRenderingMode
)
;
if
(
!
IsTargetValid
(
)
)
return
false
;
mRenderingMode
=
attemptedMode
;
gfx
:
:
Rect
r
(
0
0
mWidth
mHeight
)
;
mTarget
-
>
DrawSurface
(
snapshot
r
r
)
;
for
(
uint32_t
i
=
0
;
i
<
CurrentState
(
)
.
clipsPushed
.
Length
(
)
;
i
+
+
)
{
mTarget
-
>
PushClip
(
CurrentState
(
)
.
clipsPushed
[
i
]
)
;
}
mTarget
-
>
SetTransform
(
transform
)
;
return
true
;
}
void
CanvasRenderingContext2D
:
:
Demote
(
)
{
if
(
SwitchRenderingMode
(
RenderingMode
:
:
SoftwareBackendMode
)
)
{
RemoveDemotableContext
(
this
)
;
}
}
std
:
:
vector
<
CanvasRenderingContext2D
*
>
&
CanvasRenderingContext2D
:
:
DemotableContexts
(
)
{
static
std
:
:
vector
<
CanvasRenderingContext2D
*
>
contexts
;
return
contexts
;
}
void
CanvasRenderingContext2D
:
:
DemoteOldestContextIfNecessary
(
)
{
const
size_t
kMaxContexts
=
64
;
std
:
:
vector
<
CanvasRenderingContext2D
*
>
&
contexts
=
DemotableContexts
(
)
;
if
(
contexts
.
size
(
)
<
kMaxContexts
)
return
;
CanvasRenderingContext2D
*
oldest
=
contexts
.
front
(
)
;
if
(
oldest
-
>
SwitchRenderingMode
(
RenderingMode
:
:
SoftwareBackendMode
)
)
{
RemoveDemotableContext
(
oldest
)
;
}
}
void
CanvasRenderingContext2D
:
:
AddDemotableContext
(
CanvasRenderingContext2D
*
aContext
)
{
std
:
:
vector
<
CanvasRenderingContext2D
*
>
:
:
iterator
iter
=
std
:
:
find
(
DemotableContexts
(
)
.
begin
(
)
DemotableContexts
(
)
.
end
(
)
aContext
)
;
if
(
iter
!
=
DemotableContexts
(
)
.
end
(
)
)
return
;
DemotableContexts
(
)
.
push_back
(
aContext
)
;
}
void
CanvasRenderingContext2D
:
:
RemoveDemotableContext
(
CanvasRenderingContext2D
*
aContext
)
{
std
:
:
vector
<
CanvasRenderingContext2D
*
>
:
:
iterator
iter
=
std
:
:
find
(
DemotableContexts
(
)
.
begin
(
)
DemotableContexts
(
)
.
end
(
)
aContext
)
;
if
(
iter
!
=
DemotableContexts
(
)
.
end
(
)
)
DemotableContexts
(
)
.
erase
(
iter
)
;
}
bool
CanvasRenderingContext2D
:
:
CheckSizeForSkiaGL
(
IntSize
aSize
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
int
minsize
=
Preferences
:
:
GetInt
(
"
gfx
.
canvas
.
min
-
size
-
for
-
skia
-
gl
"
128
)
;
if
(
aSize
.
width
<
minsize
|
|
aSize
.
height
<
minsize
)
{
return
false
;
}
int
maxsize
=
Preferences
:
:
GetInt
(
"
gfx
.
canvas
.
max
-
size
-
for
-
skia
-
gl
"
0
)
;
if
(
!
maxsize
)
{
return
true
;
}
if
(
maxsize
>
0
)
{
return
aSize
.
width
<
=
maxsize
&
&
aSize
.
height
<
=
maxsize
;
}
static
int32_t
gScreenPixels
=
-
1
;
if
(
gScreenPixels
<
0
)
{
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
HasEnoughTotalSystemMemoryForSkiaGL
(
)
)
{
gScreenPixels
=
980
*
480
;
}
nsCOMPtr
<
nsIScreenManager
>
screenManager
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
if
(
screenManager
)
{
nsCOMPtr
<
nsIScreen
>
primaryScreen
;
screenManager
-
>
GetPrimaryScreen
(
getter_AddRefs
(
primaryScreen
)
)
;
if
(
primaryScreen
)
{
int32_t
x
y
width
height
;
primaryScreen
-
>
GetRect
(
&
x
&
y
&
width
&
height
)
;
gScreenPixels
=
std
:
:
max
(
gScreenPixels
width
*
height
)
;
}
}
}
static
double
gDefaultScale
=
1
.
0
;
double
scale
=
gDefaultScale
>
0
?
gDefaultScale
:
1
.
0
;
int32_t
threshold
=
ceil
(
scale
*
scale
*
gScreenPixels
)
;
return
threshold
<
0
|
|
(
aSize
.
width
*
aSize
.
height
)
<
=
threshold
;
}
CanvasRenderingContext2D
:
:
RenderingMode
CanvasRenderingContext2D
:
:
EnsureTarget
(
RenderingMode
aRenderingMode
)
{
MOZ_ASSERT
(
mRenderingMode
!
=
RenderingMode
:
:
DefaultBackendMode
)
;
RenderingMode
mode
=
(
aRenderingMode
=
=
RenderingMode
:
:
DefaultBackendMode
)
?
mRenderingMode
:
aRenderingMode
;
if
(
mTarget
&
&
mode
=
=
mRenderingMode
)
{
return
mRenderingMode
;
}
if
(
mBufferProvider
&
&
mode
=
=
mRenderingMode
)
{
mTarget
=
mBufferProvider
-
>
GetDT
(
IntRect
(
IntPoint
(
)
IntSize
(
mWidth
mHeight
)
)
)
;
if
(
mTarget
)
{
return
mRenderingMode
;
}
else
{
mBufferProvider
=
nullptr
;
}
}
mIsSkiaGL
=
false
;
IntSize
size
(
mWidth
mHeight
)
;
if
(
size
.
width
<
=
gfxPrefs
:
:
MaxCanvasSize
(
)
&
&
size
.
height
<
=
gfxPrefs
:
:
MaxCanvasSize
(
)
&
&
size
.
width
>
=
0
&
&
size
.
height
>
=
0
)
{
SurfaceFormat
format
=
GetSurfaceFormat
(
)
;
nsIDocument
*
ownerDoc
=
nullptr
;
if
(
mCanvasElement
)
{
ownerDoc
=
mCanvasElement
-
>
OwnerDoc
(
)
;
}
RefPtr
<
LayerManager
>
layerManager
=
nullptr
;
if
(
ownerDoc
)
{
layerManager
=
nsContentUtils
:
:
PersistentLayerManagerForDocument
(
ownerDoc
)
;
}
if
(
layerManager
)
{
if
(
mode
=
=
RenderingMode
:
:
OpenGLBackendMode
&
&
gfxPlatform
:
:
GetPlatform
(
)
-
>
UseAcceleratedSkiaCanvas
(
)
&
&
CheckSizeForSkiaGL
(
size
)
)
{
DemoteOldestContextIfNecessary
(
)
;
mBufferProvider
=
nullptr
;
#
if
USE_SKIA_GPU
SkiaGLGlue
*
glue
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
;
if
(
glue
&
&
glue
-
>
GetGrContext
(
)
&
&
glue
-
>
GetGLContext
(
)
)
{
mTarget
=
Factory
:
:
CreateDrawTargetSkiaWithGrContext
(
glue
-
>
GetGrContext
(
)
size
format
)
;
if
(
mTarget
)
{
AddDemotableContext
(
this
)
;
mBufferProvider
=
new
PersistentBufferProviderBasic
(
mTarget
)
;
mIsSkiaGL
=
true
;
}
else
{
gfxCriticalNote
<
<
"
Failed
to
create
a
SkiaGL
DrawTarget
falling
back
to
software
\
n
"
;
mode
=
RenderingMode
:
:
SoftwareBackendMode
;
}
}
#
endif
}
if
(
!
mBufferProvider
)
{
mBufferProvider
=
layerManager
-
>
CreatePersistentBufferProvider
(
size
format
)
;
}
}
if
(
mBufferProvider
)
{
mTarget
=
mBufferProvider
-
>
GetDT
(
IntRect
(
IntPoint
(
)
IntSize
(
mWidth
mHeight
)
)
)
;
}
else
if
(
!
mTarget
)
{
mTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenCanvasDrawTarget
(
size
format
)
;
mode
=
RenderingMode
:
:
SoftwareBackendMode
;
}
}
if
(
mTarget
)
{
static
bool
registered
=
false
;
if
(
!
registered
)
{
registered
=
true
;
RegisterStrongMemoryReporter
(
new
Canvas2dPixelsReporter
(
)
)
;
}
gCanvasAzureMemoryUsed
+
=
mWidth
*
mHeight
*
4
;
JSContext
*
context
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
if
(
context
)
{
JS_updateMallocCounter
(
context
mWidth
*
mHeight
*
4
)
;
}
mTarget
-
>
ClearRect
(
gfx
:
:
Rect
(
Point
(
0
0
)
Size
(
mWidth
mHeight
)
)
)
;
if
(
mTarget
-
>
GetBackendType
(
)
=
=
gfx
:
:
BackendType
:
:
CAIRO
)
{
mTarget
-
>
PushClipRect
(
gfx
:
:
Rect
(
Point
(
0
0
)
Size
(
mWidth
mHeight
)
)
)
;
}
if
(
mCanvasElement
)
{
mCanvasElement
-
>
InvalidateCanvas
(
)
;
}
Redraw
(
)
;
}
else
{
EnsureErrorTarget
(
)
;
mTarget
=
sErrorTarget
;
}
if
(
mIsSkiaGL
&
&
mTarget
&
&
mTarget
-
>
GetType
(
)
=
=
DrawTargetType
:
:
HARDWARE_RASTER
)
{
gfxWarningOnce
(
)
<
<
"
Using
SkiaGL
canvas
.
"
;
}
return
mode
;
}
int32_t
CanvasRenderingContext2D
:
:
GetWidth
(
)
const
{
return
mWidth
;
}
int32_t
CanvasRenderingContext2D
:
:
GetHeight
(
)
const
{
return
mHeight
;
}
NS_IMETHODIMP
CanvasRenderingContext2D
:
:
SetDimensions
(
int32_t
aWidth
int32_t
aHeight
)
{
ClearTarget
(
)
;
mZero
=
false
;
if
(
aHeight
=
=
0
)
{
aHeight
=
1
;
mZero
=
true
;
}
if
(
aWidth
=
=
0
)
{
aWidth
=
1
;
mZero
=
true
;
}
mWidth
=
aWidth
;
mHeight
=
aHeight
;
return
NS_OK
;
}
void
CanvasRenderingContext2D
:
:
ClearTarget
(
)
{
Reset
(
)
;
mResetLayer
=
true
;
mStyleStack
.
Clear
(
)
;
mPathBuilder
=
nullptr
;
mPath
=
nullptr
;
mDSPathBuilder
=
nullptr
;
ContextState
*
state
=
mStyleStack
.
AppendElement
(
)
;
state
-
>
globalAlpha
=
1
.
0
;
state
-
>
colorStyles
[
Style
:
:
FILL
]
=
NS_RGB
(
0
0
0
)
;
state
-
>
colorStyles
[
Style
:
:
STROKE
]
=
NS_RGB
(
0
0
0
)
;
state
-
>
shadowColor
=
NS_RGBA
(
0
0
0
0
)
;
RefPtr
<
nsStyleContext
>
canvasStyle
;
if
(
mCanvasElement
&
&
mCanvasElement
-
>
IsInDoc
(
)
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
canvasStyle
=
nsComputedDOMStyle
:
:
GetStyleContextForElement
(
mCanvasElement
nullptr
presShell
)
;
if
(
canvasStyle
)
{
WritingMode
wm
(
canvasStyle
)
;
if
(
wm
.
IsVertical
(
)
&
&
!
wm
.
IsSideways
(
)
)
{
state
-
>
textBaseline
=
TextBaseline
:
:
MIDDLE
;
}
}
}
}
}
void
CanvasRenderingContext2D
:
:
ReturnTarget
(
)
{
if
(
mTarget
&
&
mBufferProvider
)
{
CurrentState
(
)
.
transform
=
mTarget
-
>
GetTransform
(
)
;
DrawTarget
*
oldDT
=
mTarget
;
mTarget
=
nullptr
;
mBufferProvider
-
>
ReturnAndUseDT
(
oldDT
)
;
}
}
NS_IMETHODIMP
CanvasRenderingContext2D
:
:
InitializeWithSurface
(
nsIDocShell
*
aShell
gfxASurface
*
aSurface
int32_t
aWidth
int32_t
aHeight
)
{
RemovePostRefreshObserver
(
)
;
mDocShell
=
aShell
;
AddPostRefreshObserverIfNecessary
(
)
;
SetDimensions
(
aWidth
aHeight
)
;
mTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForSurface
(
aSurface
IntSize
(
aWidth
aHeight
)
)
;
if
(
!
mTarget
)
{
EnsureErrorTarget
(
)
;
mTarget
=
sErrorTarget
;
}
if
(
mTarget
-
>
GetBackendType
(
)
=
=
gfx
:
:
BackendType
:
:
CAIRO
)
{
mTarget
-
>
PushClipRect
(
gfx
:
:
Rect
(
Point
(
0
0
)
Size
(
mWidth
mHeight
)
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CanvasRenderingContext2D
:
:
SetIsOpaque
(
bool
aIsOpaque
)
{
if
(
aIsOpaque
!
=
mOpaque
)
{
mOpaque
=
aIsOpaque
;
ClearTarget
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CanvasRenderingContext2D
:
:
SetIsIPC
(
bool
aIsIPC
)
{
if
(
aIsIPC
!
=
mIPC
)
{
mIPC
=
aIsIPC
;
ClearTarget
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
CanvasRenderingContext2D
:
:
SetContextOptions
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aOptions
ErrorResult
&
aRvForDictionaryInit
)
{
if
(
aOptions
.
isNullOrUndefined
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
mTarget
)
;
ContextAttributes2D
attributes
;
if
(
!
attributes
.
Init
(
aCx
aOptions
)
)
{
aRvForDictionaryInit
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
Preferences
:
:
GetBool
(
"
gfx
.
canvas
.
willReadFrequently
.
enable
"
false
)
)
{
if
(
attributes
.
mWillReadFrequently
)
{
RemoveDrawObserver
(
)
;
mRenderingMode
=
RenderingMode
:
:
SoftwareBackendMode
;
}
}
if
(
!
attributes
.
mAlpha
)
{
SetIsOpaque
(
true
)
;
}
return
NS_OK
;
}
UniquePtr
<
uint8_t
[
]
>
CanvasRenderingContext2D
:
:
GetImageBuffer
(
int32_t
*
aFormat
)
{
*
aFormat
=
0
;
EnsureTarget
(
)
;
RefPtr
<
SourceSurface
>
snapshot
=
mTarget
-
>
Snapshot
(
)
;
if
(
!
snapshot
)
{
return
nullptr
;
}
RefPtr
<
DataSourceSurface
>
data
=
snapshot
-
>
GetDataSurface
(
)
;
if
(
!
data
|
|
data
-
>
GetSize
(
)
!
=
IntSize
(
mWidth
mHeight
)
)
{
return
nullptr
;
}
*
aFormat
=
imgIEncoder
:
:
INPUT_FORMAT_HOSTARGB
;
return
SurfaceToPackedBGRA
(
data
)
;
}
nsString
CanvasRenderingContext2D
:
:
GetHitRegion
(
const
mozilla
:
:
gfx
:
:
Point
&
aPoint
)
{
for
(
size_t
x
=
0
;
x
<
mHitRegionsOptions
.
Length
(
)
;
x
+
+
)
{
RegionInfo
&
info
=
mHitRegionsOptions
[
x
]
;
if
(
info
.
mPath
-
>
ContainsPoint
(
aPoint
Matrix
(
)
)
)
{
return
info
.
mId
;
}
}
return
nsString
(
)
;
}
NS_IMETHODIMP
CanvasRenderingContext2D
:
:
GetInputStream
(
const
char
*
aMimeType
const
char16_t
*
aEncoderOptions
nsIInputStream
*
*
aStream
)
{
nsCString
enccid
(
"
mozilla
.
org
/
image
/
encoder
;
2
?
type
=
"
)
;
enccid
+
=
aMimeType
;
nsCOMPtr
<
imgIEncoder
>
encoder
=
do_CreateInstance
(
enccid
.
get
(
)
)
;
if
(
!
encoder
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
format
=
0
;
UniquePtr
<
uint8_t
[
]
>
imageBuffer
=
GetImageBuffer
(
&
format
)
;
if
(
!
imageBuffer
)
{
return
NS_ERROR_FAILURE
;
}
return
ImageEncoder
:
:
GetInputStream
(
mWidth
mHeight
imageBuffer
.
get
(
)
format
encoder
aEncoderOptions
aStream
)
;
}
SurfaceFormat
CanvasRenderingContext2D
:
:
GetSurfaceFormat
(
)
const
{
return
mOpaque
?
SurfaceFormat
:
:
B8G8R8X8
:
SurfaceFormat
:
:
B8G8R8A8
;
}
void
CanvasRenderingContext2D
:
:
Save
(
)
{
EnsureTarget
(
)
;
mStyleStack
[
mStyleStack
.
Length
(
)
-
1
]
.
transform
=
mTarget
-
>
GetTransform
(
)
;
mStyleStack
.
SetCapacity
(
mStyleStack
.
Length
(
)
+
1
)
;
mStyleStack
.
AppendElement
(
CurrentState
(
)
)
;
}
void
CanvasRenderingContext2D
:
:
Restore
(
)
{
if
(
mStyleStack
.
Length
(
)
-
1
=
=
0
)
return
;
TransformWillUpdate
(
)
;
for
(
uint32_t
i
=
0
;
i
<
CurrentState
(
)
.
clipsPushed
.
Length
(
)
;
i
+
+
)
{
mTarget
-
>
PopClip
(
)
;
}
mStyleStack
.
RemoveElementAt
(
mStyleStack
.
Length
(
)
-
1
)
;
mTarget
-
>
SetTransform
(
CurrentState
(
)
.
transform
)
;
}
void
CanvasRenderingContext2D
:
:
Scale
(
double
aX
double
aY
ErrorResult
&
aError
)
{
TransformWillUpdate
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Matrix
newMatrix
=
mTarget
-
>
GetTransform
(
)
;
newMatrix
.
PreScale
(
aX
aY
)
;
if
(
!
newMatrix
.
IsFinite
(
)
)
{
return
;
}
mTarget
-
>
SetTransform
(
newMatrix
)
;
}
void
CanvasRenderingContext2D
:
:
Rotate
(
double
aAngle
ErrorResult
&
aError
)
{
TransformWillUpdate
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Matrix
newMatrix
=
Matrix
:
:
Rotation
(
aAngle
)
*
mTarget
-
>
GetTransform
(
)
;
if
(
!
newMatrix
.
IsFinite
(
)
)
{
return
;
}
mTarget
-
>
SetTransform
(
newMatrix
)
;
}
void
CanvasRenderingContext2D
:
:
Translate
(
double
aX
double
aY
ErrorResult
&
aError
)
{
TransformWillUpdate
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Matrix
newMatrix
=
mTarget
-
>
GetTransform
(
)
;
newMatrix
.
PreTranslate
(
aX
aY
)
;
if
(
!
newMatrix
.
IsFinite
(
)
)
{
return
;
}
mTarget
-
>
SetTransform
(
newMatrix
)
;
}
void
CanvasRenderingContext2D
:
:
Transform
(
double
aM11
double
aM12
double
aM21
double
aM22
double
aDx
double
aDy
ErrorResult
&
aError
)
{
TransformWillUpdate
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Matrix
newMatrix
(
aM11
aM12
aM21
aM22
aDx
aDy
)
;
newMatrix
*
=
mTarget
-
>
GetTransform
(
)
;
if
(
!
newMatrix
.
IsFinite
(
)
)
{
return
;
}
mTarget
-
>
SetTransform
(
newMatrix
)
;
}
void
CanvasRenderingContext2D
:
:
SetTransform
(
double
aM11
double
aM12
double
aM21
double
aM22
double
aDx
double
aDy
ErrorResult
&
aError
)
{
TransformWillUpdate
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Matrix
matrix
(
aM11
aM12
aM21
aM22
aDx
aDy
)
;
if
(
!
matrix
.
IsFinite
(
)
)
{
return
;
}
mTarget
-
>
SetTransform
(
matrix
)
;
}
void
CanvasRenderingContext2D
:
:
ResetTransform
(
ErrorResult
&
aError
)
{
SetTransform
(
1
.
0
0
.
0
0
.
0
1
.
0
0
.
0
0
.
0
aError
)
;
}
static
void
MatrixToJSObject
(
JSContext
*
aCx
const
Matrix
&
aMatrix
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aError
)
{
double
elts
[
6
]
=
{
aMatrix
.
_11
aMatrix
.
_12
aMatrix
.
_21
aMatrix
.
_22
aMatrix
.
_31
aMatrix
.
_32
}
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
elts
&
val
)
)
{
aError
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
}
else
{
aResult
.
set
(
&
val
.
toObject
(
)
)
;
}
}
static
bool
ObjectToMatrix
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
Matrix
&
aMatrix
ErrorResult
&
aError
)
{
uint32_t
length
;
if
(
!
JS_GetArrayLength
(
aCx
aObj
&
length
)
|
|
length
!
=
6
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
false
;
}
Float
*
elts
[
]
=
{
&
aMatrix
.
_11
&
aMatrix
.
_12
&
aMatrix
.
_21
&
aMatrix
.
_22
&
aMatrix
.
_31
&
aMatrix
.
_32
}
;
for
(
uint32_t
i
=
0
;
i
<
6
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
elt
(
aCx
)
;
double
d
;
if
(
!
JS_GetElement
(
aCx
aObj
i
&
elt
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
if
(
!
CoerceDouble
(
elt
&
d
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
false
;
}
if
(
!
FloatValidate
(
d
)
)
{
return
false
;
}
*
elts
[
i
]
=
Float
(
d
)
;
}
return
true
;
}
void
CanvasRenderingContext2D
:
:
SetMozCurrentTransform
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCurrentTransform
ErrorResult
&
aError
)
{
EnsureTarget
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Matrix
newCTM
;
if
(
ObjectToMatrix
(
aCx
aCurrentTransform
newCTM
aError
)
&
&
newCTM
.
IsFinite
(
)
)
{
mTarget
-
>
SetTransform
(
newCTM
)
;
}
}
void
CanvasRenderingContext2D
:
:
GetMozCurrentTransform
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aError
)
const
{
MatrixToJSObject
(
aCx
mTarget
?
mTarget
-
>
GetTransform
(
)
:
Matrix
(
)
aResult
aError
)
;
}
void
CanvasRenderingContext2D
:
:
SetMozCurrentTransformInverse
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aCurrentTransform
ErrorResult
&
aError
)
{
EnsureTarget
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
Matrix
newCTMInverse
;
if
(
ObjectToMatrix
(
aCx
aCurrentTransform
newCTMInverse
aError
)
)
{
if
(
newCTMInverse
.
Invert
(
)
&
&
newCTMInverse
.
IsFinite
(
)
)
{
mTarget
-
>
SetTransform
(
newCTMInverse
)
;
}
}
}
void
CanvasRenderingContext2D
:
:
GetMozCurrentTransformInverse
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aResult
ErrorResult
&
aError
)
const
{
if
(
!
mTarget
)
{
MatrixToJSObject
(
aCx
Matrix
(
)
aResult
aError
)
;
return
;
}
Matrix
ctm
=
mTarget
-
>
GetTransform
(
)
;
if
(
!
ctm
.
Invert
(
)
)
{
double
NaN
=
JS_GetNaNValue
(
aCx
)
.
toDouble
(
)
;
ctm
=
Matrix
(
NaN
NaN
NaN
NaN
NaN
NaN
)
;
}
MatrixToJSObject
(
aCx
ctm
aResult
aError
)
;
}
void
CanvasRenderingContext2D
:
:
SetStyleFromUnion
(
const
StringOrCanvasGradientOrCanvasPattern
&
aValue
Style
aWhichStyle
)
{
if
(
aValue
.
IsString
(
)
)
{
SetStyleFromString
(
aValue
.
GetAsString
(
)
aWhichStyle
)
;
return
;
}
if
(
aValue
.
IsCanvasGradient
(
)
)
{
SetStyleFromGradient
(
aValue
.
GetAsCanvasGradient
(
)
aWhichStyle
)
;
return
;
}
if
(
aValue
.
IsCanvasPattern
(
)
)
{
SetStyleFromPattern
(
aValue
.
GetAsCanvasPattern
(
)
aWhichStyle
)
;
return
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
union
value
"
)
;
}
void
CanvasRenderingContext2D
:
:
SetFillRule
(
const
nsAString
&
aString
)
{
FillRule
rule
;
if
(
aString
.
EqualsLiteral
(
"
evenodd
"
)
)
rule
=
FillRule
:
:
FILL_EVEN_ODD
;
else
if
(
aString
.
EqualsLiteral
(
"
nonzero
"
)
)
rule
=
FillRule
:
:
FILL_WINDING
;
else
return
;
CurrentState
(
)
.
fillRule
=
rule
;
}
void
CanvasRenderingContext2D
:
:
GetFillRule
(
nsAString
&
aString
)
{
switch
(
CurrentState
(
)
.
fillRule
)
{
case
FillRule
:
:
FILL_WINDING
:
aString
.
AssignLiteral
(
"
nonzero
"
)
;
break
;
case
FillRule
:
:
FILL_EVEN_ODD
:
aString
.
AssignLiteral
(
"
evenodd
"
)
;
break
;
}
}
already_AddRefed
<
CanvasGradient
>
CanvasRenderingContext2D
:
:
CreateLinearGradient
(
double
aX0
double
aY0
double
aX1
double
aY1
)
{
RefPtr
<
CanvasGradient
>
grad
=
new
CanvasLinearGradient
(
this
Point
(
aX0
aY0
)
Point
(
aX1
aY1
)
)
;
return
grad
.
forget
(
)
;
}
already_AddRefed
<
CanvasGradient
>
CanvasRenderingContext2D
:
:
CreateRadialGradient
(
double
aX0
double
aY0
double
aR0
double
aX1
double
aY1
double
aR1
ErrorResult
&
aError
)
{
if
(
aR0
<
0
.
0
|
|
aR1
<
0
.
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
RefPtr
<
CanvasGradient
>
grad
=
new
CanvasRadialGradient
(
this
Point
(
aX0
aY0
)
aR0
Point
(
aX1
aY1
)
aR1
)
;
return
grad
.
forget
(
)
;
}
already_AddRefed
<
CanvasPattern
>
CanvasRenderingContext2D
:
:
CreatePattern
(
const
CanvasImageSource
&
aSource
const
nsAString
&
aRepeat
ErrorResult
&
aError
)
{
CanvasPattern
:
:
RepeatMode
repeatMode
=
CanvasPattern
:
:
RepeatMode
:
:
NOREPEAT
;
if
(
aRepeat
.
IsEmpty
(
)
|
|
aRepeat
.
EqualsLiteral
(
"
repeat
"
)
)
{
repeatMode
=
CanvasPattern
:
:
RepeatMode
:
:
REPEAT
;
}
else
if
(
aRepeat
.
EqualsLiteral
(
"
repeat
-
x
"
)
)
{
repeatMode
=
CanvasPattern
:
:
RepeatMode
:
:
REPEATX
;
}
else
if
(
aRepeat
.
EqualsLiteral
(
"
repeat
-
y
"
)
)
{
repeatMode
=
CanvasPattern
:
:
RepeatMode
:
:
REPEATY
;
}
else
if
(
aRepeat
.
EqualsLiteral
(
"
no
-
repeat
"
)
)
{
repeatMode
=
CanvasPattern
:
:
RepeatMode
:
:
NOREPEAT
;
}
else
{
aError
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
nullptr
;
}
Element
*
htmlElement
;
if
(
aSource
.
IsHTMLCanvasElement
(
)
)
{
HTMLCanvasElement
*
canvas
=
&
aSource
.
GetAsHTMLCanvasElement
(
)
;
htmlElement
=
canvas
;
nsIntSize
size
=
canvas
-
>
GetSize
(
)
;
if
(
size
.
width
=
=
0
|
|
size
.
height
=
=
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
nsICanvasRenderingContextInternal
*
srcCanvas
=
canvas
-
>
GetContextAtIndex
(
0
)
;
if
(
srcCanvas
)
{
RefPtr
<
SourceSurface
>
srcSurf
=
srcCanvas
-
>
GetSurfaceSnapshot
(
)
;
RefPtr
<
CanvasPattern
>
pat
=
new
CanvasPattern
(
this
srcSurf
repeatMode
htmlElement
-
>
NodePrincipal
(
)
canvas
-
>
IsWriteOnly
(
)
false
)
;
return
pat
.
forget
(
)
;
}
}
else
if
(
aSource
.
IsHTMLImageElement
(
)
)
{
HTMLImageElement
*
img
=
&
aSource
.
GetAsHTMLImageElement
(
)
;
if
(
img
-
>
IntrinsicState
(
)
.
HasState
(
NS_EVENT_STATE_BROKEN
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
htmlElement
=
img
;
}
else
if
(
aSource
.
IsHTMLVideoElement
(
)
)
{
htmlElement
=
&
aSource
.
GetAsHTMLVideoElement
(
)
;
}
else
{
ImageBitmap
&
imgBitmap
=
aSource
.
GetAsImageBitmap
(
)
;
EnsureTarget
(
)
;
RefPtr
<
SourceSurface
>
srcSurf
=
imgBitmap
.
PrepareForDrawTarget
(
mTarget
)
;
RefPtr
<
CanvasPattern
>
pat
=
new
CanvasPattern
(
this
srcSurf
repeatMode
nullptr
false
true
)
;
return
pat
.
forget
(
)
;
}
EnsureTarget
(
)
;
nsLayoutUtils
:
:
SurfaceFromElementResult
res
=
nsLayoutUtils
:
:
SurfaceFromElement
(
htmlElement
nsLayoutUtils
:
:
SFE_WANT_FIRST_FRAME
mTarget
)
;
if
(
!
res
.
GetSourceSurface
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
CanvasPattern
>
pat
=
new
CanvasPattern
(
this
res
.
GetSourceSurface
(
)
repeatMode
res
.
mPrincipal
res
.
mIsWriteOnly
res
.
mCORSUsed
)
;
return
pat
.
forget
(
)
;
}
void
CanvasRenderingContext2D
:
:
SetShadowColor
(
const
nsAString
&
aShadowColor
)
{
nscolor
color
;
if
(
!
ParseColor
(
aShadowColor
&
color
)
)
{
return
;
}
CurrentState
(
)
.
shadowColor
=
color
;
}
static
already_AddRefed
<
Declaration
>
CreateDeclaration
(
nsINode
*
aNode
const
nsCSSProperty
aProp1
const
nsAString
&
aValue1
bool
*
aChanged1
const
nsCSSProperty
aProp2
const
nsAString
&
aValue2
bool
*
aChanged2
)
{
nsIPrincipal
*
principal
=
aNode
-
>
NodePrincipal
(
)
;
nsIDocument
*
document
=
aNode
-
>
OwnerDoc
(
)
;
nsIURI
*
docURL
=
document
-
>
GetDocumentURI
(
)
;
nsIURI
*
baseURL
=
document
-
>
GetDocBaseURI
(
)
;
nsCSSParser
parser
(
document
-
>
CSSLoader
(
)
)
;
RefPtr
<
Declaration
>
declaration
=
parser
.
ParseStyleAttribute
(
EmptyString
(
)
docURL
baseURL
principal
)
;
if
(
aProp1
!
=
eCSSProperty_UNKNOWN
)
{
parser
.
ParseProperty
(
aProp1
aValue1
docURL
baseURL
principal
declaration
aChanged1
false
)
;
}
if
(
aProp2
!
=
eCSSProperty_UNKNOWN
)
{
parser
.
ParseProperty
(
aProp2
aValue2
docURL
baseURL
principal
declaration
aChanged2
false
)
;
}
declaration
-
>
SetImmutable
(
)
;
return
declaration
.
forget
(
)
;
}
static
already_AddRefed
<
Declaration
>
CreateFontDeclaration
(
const
nsAString
&
aFont
nsINode
*
aNode
bool
*
aOutFontChanged
)
{
bool
lineHeightChanged
;
return
CreateDeclaration
(
aNode
eCSSProperty_font
aFont
aOutFontChanged
eCSSProperty_line_height
NS_LITERAL_STRING
(
"
normal
"
)
&
lineHeightChanged
)
;
}
static
already_AddRefed
<
nsStyleContext
>
GetFontParentStyleContext
(
Element
*
aElement
nsIPresShell
*
aPresShell
ErrorResult
&
aError
)
{
if
(
aElement
&
&
aElement
-
>
IsInDoc
(
)
)
{
RefPtr
<
nsStyleContext
>
result
=
nsComputedDOMStyle
:
:
GetStyleContextForElement
(
aElement
nullptr
aPresShell
)
;
if
(
!
result
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
result
.
forget
(
)
;
}
bool
changed
;
RefPtr
<
css
:
:
Declaration
>
parentRule
=
CreateFontDeclaration
(
NS_LITERAL_STRING
(
"
10px
sans
-
serif
"
)
aPresShell
-
>
GetDocument
(
)
&
changed
)
;
nsTArray
<
nsCOMPtr
<
nsIStyleRule
>
>
parentRules
;
parentRules
.
AppendElement
(
parentRule
)
;
RefPtr
<
nsStyleContext
>
result
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForRules
(
nullptr
parentRules
)
;
if
(
!
result
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
result
.
forget
(
)
;
}
static
bool
PropertyIsInheritOrInitial
(
Declaration
*
aDeclaration
const
nsCSSProperty
aProperty
)
{
const
nsCSSValue
*
filterVal
=
aDeclaration
-
>
GetNormalBlock
(
)
-
>
ValueFor
(
aProperty
)
;
return
(
!
filterVal
|
|
(
filterVal
-
>
GetUnit
(
)
=
=
eCSSUnit_Unset
|
|
filterVal
-
>
GetUnit
(
)
=
=
eCSSUnit_Inherit
|
|
filterVal
-
>
GetUnit
(
)
=
=
eCSSUnit_Initial
)
)
;
}
static
already_AddRefed
<
nsStyleContext
>
GetFontStyleContext
(
Element
*
aElement
const
nsAString
&
aFont
nsIPresShell
*
aPresShell
nsAString
&
aOutUsedFont
ErrorResult
&
aError
)
{
bool
fontParsedSuccessfully
=
false
;
RefPtr
<
css
:
:
Declaration
>
decl
=
CreateFontDeclaration
(
aFont
aPresShell
-
>
GetDocument
(
)
&
fontParsedSuccessfully
)
;
if
(
!
fontParsedSuccessfully
)
{
return
nullptr
;
}
if
(
PropertyIsInheritOrInitial
(
decl
eCSSProperty_font_size_adjust
)
)
{
return
nullptr
;
}
RefPtr
<
nsStyleContext
>
parentContext
=
GetFontParentStyleContext
(
aElement
aPresShell
aError
)
;
if
(
aError
.
Failed
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
MOZ_RELEASE_ASSERT
(
parentContext
"
GetFontParentStyleContext
should
have
returned
an
error
if
it
couldn
'
t
get
a
parent
context
.
"
)
;
MOZ_ASSERT
(
!
aPresShell
-
>
IsDestroying
(
)
"
GetFontParentStyleContext
should
have
returned
an
error
if
the
presshell
is
being
destroyed
.
"
)
;
nsTArray
<
nsCOMPtr
<
nsIStyleRule
>
>
rules
;
rules
.
AppendElement
(
decl
)
;
rules
.
AppendElement
(
new
nsDisableTextZoomStyleRule
)
;
nsStyleSet
*
styleSet
=
aPresShell
-
>
StyleSet
(
)
;
RefPtr
<
nsStyleContext
>
sc
=
styleSet
-
>
ResolveStyleForRules
(
parentContext
rules
)
;
decl
-
>
GetValue
(
eCSSProperty_font
aOutUsedFont
)
;
return
sc
.
forget
(
)
;
}
static
already_AddRefed
<
Declaration
>
CreateFilterDeclaration
(
const
nsAString
&
aFilter
nsINode
*
aNode
bool
*
aOutFilterChanged
)
{
bool
dummy
;
return
CreateDeclaration
(
aNode
eCSSProperty_filter
aFilter
aOutFilterChanged
eCSSProperty_UNKNOWN
EmptyString
(
)
&
dummy
)
;
}
static
already_AddRefed
<
nsStyleContext
>
ResolveStyleForFilter
(
const
nsAString
&
aFilterString
nsIPresShell
*
aPresShell
nsStyleContext
*
aParentContext
ErrorResult
&
aError
)
{
nsIDocument
*
document
=
aPresShell
-
>
GetDocument
(
)
;
bool
filterChanged
=
false
;
RefPtr
<
css
:
:
Declaration
>
decl
=
CreateFilterDeclaration
(
aFilterString
document
&
filterChanged
)
;
if
(
!
filterChanged
)
{
return
nullptr
;
}
if
(
PropertyIsInheritOrInitial
(
decl
eCSSProperty_filter
)
)
{
return
nullptr
;
}
nsTArray
<
nsCOMPtr
<
nsIStyleRule
>
>
rules
;
rules
.
AppendElement
(
decl
)
;
RefPtr
<
nsStyleContext
>
sc
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForRules
(
aParentContext
rules
)
;
return
sc
.
forget
(
)
;
}
bool
CanvasRenderingContext2D
:
:
ParseFilter
(
const
nsAString
&
aString
nsTArray
<
nsStyleFilter
>
&
aFilterChain
ErrorResult
&
aError
)
{
if
(
!
mCanvasElement
&
&
!
mDocShell
)
{
NS_WARNING
(
"
Canvas
element
must
be
non
-
null
or
a
docshell
must
be
provided
"
)
;
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsString
usedFont
;
RefPtr
<
nsStyleContext
>
parentContext
=
GetFontStyleContext
(
mCanvasElement
GetFont
(
)
presShell
usedFont
aError
)
;
if
(
!
parentContext
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
RefPtr
<
nsStyleContext
>
sc
=
ResolveStyleForFilter
(
aString
presShell
parentContext
aError
)
;
if
(
!
sc
)
{
return
false
;
}
aFilterChain
=
sc
-
>
StyleSVGReset
(
)
-
>
mFilters
;
return
true
;
}
class
CanvasFilterChainObserver
:
public
nsSVGFilterChainObserver
{
public
:
CanvasFilterChainObserver
(
nsTArray
<
nsStyleFilter
>
&
aFilters
Element
*
aCanvasElement
CanvasRenderingContext2D
*
aContext
)
:
nsSVGFilterChainObserver
(
aFilters
aCanvasElement
)
mContext
(
aContext
)
{
}
virtual
void
DoUpdate
(
)
override
{
mContext
-
>
UpdateFilter
(
)
;
}
private
:
CanvasRenderingContext2D
*
mContext
;
}
;
void
CanvasRenderingContext2D
:
:
SetFilter
(
const
nsAString
&
aFilter
ErrorResult
&
aError
)
{
nsTArray
<
nsStyleFilter
>
filterChain
;
if
(
ParseFilter
(
aFilter
filterChain
aError
)
)
{
CurrentState
(
)
.
filterString
=
aFilter
;
filterChain
.
SwapElements
(
CurrentState
(
)
.
filterChain
)
;
if
(
mCanvasElement
)
{
CurrentState
(
)
.
filterChainObserver
=
new
CanvasFilterChainObserver
(
CurrentState
(
)
.
filterChain
mCanvasElement
this
)
;
UpdateFilter
(
)
;
}
}
}
class
CanvasUserSpaceMetrics
:
public
UserSpaceMetricsWithSize
{
public
:
CanvasUserSpaceMetrics
(
const
gfx
:
:
IntSize
&
aSize
const
nsFont
&
aFont
nsIAtom
*
aFontLanguage
bool
aExplicitLanguage
nsPresContext
*
aPresContext
)
:
mSize
(
aSize
)
mFont
(
aFont
)
mFontLanguage
(
aFontLanguage
)
mExplicitLanguage
(
aExplicitLanguage
)
mPresContext
(
aPresContext
)
{
}
virtual
float
GetEmLength
(
)
const
override
{
return
NSAppUnitsToFloatPixels
(
mFont
.
size
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
;
}
virtual
float
GetExLength
(
)
const
override
{
gfxTextPerfMetrics
*
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
;
RefPtr
<
nsFontMetrics
>
fontMetrics
;
nsDeviceContext
*
dc
=
mPresContext
-
>
DeviceContext
(
)
;
dc
-
>
GetMetricsFor
(
mFont
mFontLanguage
mExplicitLanguage
gfxFont
:
:
eHorizontal
nullptr
tp
*
getter_AddRefs
(
fontMetrics
)
)
;
return
NSAppUnitsToFloatPixels
(
fontMetrics
-
>
XHeight
(
)
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
;
}
virtual
gfx
:
:
Size
GetSize
(
)
const
override
{
return
Size
(
mSize
)
;
}
private
:
gfx
:
:
IntSize
mSize
;
const
nsFont
&
mFont
;
nsIAtom
*
mFontLanguage
;
bool
mExplicitLanguage
;
nsPresContext
*
mPresContext
;
}
;
void
CanvasRenderingContext2D
:
:
UpdateFilter
(
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
|
|
presShell
-
>
IsDestroying
(
)
)
{
return
;
}
presShell
-
>
FlushPendingNotifications
(
Flush_Frames
)
;
CurrentState
(
)
.
filter
=
nsFilterInstance
:
:
GetFilterDescription
(
mCanvasElement
CurrentState
(
)
.
filterChain
CanvasUserSpaceMetrics
(
IntSize
(
mWidth
mHeight
)
CurrentState
(
)
.
fontFont
CurrentState
(
)
.
fontLanguage
CurrentState
(
)
.
fontExplicitLanguage
presShell
-
>
GetPresContext
(
)
)
gfxRect
(
0
0
mWidth
mHeight
)
CurrentState
(
)
.
filterAdditionalImages
)
;
}
static
bool
ValidateRect
(
double
&
aX
double
&
aY
double
&
aWidth
double
&
aHeight
bool
aIsZeroSizeValid
)
{
if
(
!
aIsZeroSizeValid
&
&
(
aWidth
=
=
0
.
0
|
|
aHeight
=
=
0
.
0
)
)
{
return
false
;
}
if
(
!
std
:
:
isfinite
(
(
float
)
aX
)
|
!
std
:
:
isfinite
(
(
float
)
aY
)
|
!
std
:
:
isfinite
(
(
float
)
aWidth
)
|
!
std
:
:
isfinite
(
(
float
)
aHeight
)
)
{
return
false
;
}
if
(
aWidth
<
0
)
{
aWidth
=
-
aWidth
;
aX
-
=
aWidth
;
}
if
(
aHeight
<
0
)
{
aHeight
=
-
aHeight
;
aY
-
=
aHeight
;
}
return
true
;
}
void
CanvasRenderingContext2D
:
:
ClearRect
(
double
aX
double
aY
double
aW
double
aH
)
{
if
(
!
ValidateRect
(
aX
aY
aW
aH
false
)
)
{
return
;
}
EnsureTarget
(
)
;
mTarget
-
>
ClearRect
(
gfx
:
:
Rect
(
aX
aY
aW
aH
)
)
;
RedrawUser
(
gfxRect
(
aX
aY
aW
aH
)
)
;
}
void
CanvasRenderingContext2D
:
:
FillRect
(
double
aX
double
aY
double
aW
double
aH
)
{
const
ContextState
&
state
=
CurrentState
(
)
;
if
(
!
ValidateRect
(
aX
aY
aW
aH
true
)
)
{
return
;
}
if
(
state
.
patternStyles
[
Style
:
:
FILL
]
)
{
CanvasPattern
:
:
RepeatMode
repeat
=
state
.
patternStyles
[
Style
:
:
FILL
]
-
>
mRepeat
;
bool
limitx
=
repeat
=
=
CanvasPattern
:
:
RepeatMode
:
:
NOREPEAT
|
|
repeat
=
=
CanvasPattern
:
:
RepeatMode
:
:
REPEATY
;
bool
limity
=
repeat
=
=
CanvasPattern
:
:
RepeatMode
:
:
NOREPEAT
|
|
repeat
=
=
CanvasPattern
:
:
RepeatMode
:
:
REPEATX
;
IntSize
patternSize
=
state
.
patternStyles
[
Style
:
:
FILL
]
-
>
mSurface
-
>
GetSize
(
)
;
if
(
limitx
)
{
if
(
aX
<
0
)
{
aW
+
=
aX
;
if
(
aW
<
0
)
{
aW
=
0
;
}
aX
=
0
;
}
if
(
aX
+
aW
>
patternSize
.
width
)
{
aW
=
patternSize
.
width
-
aX
;
if
(
aW
<
0
)
{
aW
=
0
;
}
}
}
if
(
limity
)
{
if
(
aY
<
0
)
{
aH
+
=
aY
;
if
(
aH
<
0
)
{
aH
=
0
;
}
aY
=
0
;
}
if
(
aY
+
aH
>
patternSize
.
height
)
{
aH
=
patternSize
.
height
-
aY
;
if
(
aH
<
0
)
{
aH
=
0
;
}
}
}
}
gfx
:
:
Rect
bounds
;
EnsureTarget
(
)
;
if
(
NeedToCalculateBounds
(
)
)
{
bounds
=
gfx
:
:
Rect
(
aX
aY
aW
aH
)
;
bounds
=
mTarget
-
>
GetTransform
(
)
.
TransformBounds
(
bounds
)
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
FillRect
(
gfx
:
:
Rect
(
aX
aY
aW
aH
)
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
FILL
mTarget
)
DrawOptions
(
state
.
globalAlpha
UsedOperation
(
)
)
)
;
RedrawUser
(
gfxRect
(
aX
aY
aW
aH
)
)
;
}
void
CanvasRenderingContext2D
:
:
StrokeRect
(
double
aX
double
aY
double
aW
double
aH
)
{
const
ContextState
&
state
=
CurrentState
(
)
;
gfx
:
:
Rect
bounds
;
if
(
!
aW
&
&
!
aH
)
{
return
;
}
if
(
!
ValidateRect
(
aX
aY
aW
aH
true
)
)
{
return
;
}
EnsureTarget
(
)
;
if
(
!
IsTargetValid
(
)
)
{
return
;
}
if
(
NeedToCalculateBounds
(
)
)
{
bounds
=
gfx
:
:
Rect
(
aX
-
state
.
lineWidth
/
2
.
0f
aY
-
state
.
lineWidth
/
2
.
0f
aW
+
state
.
lineWidth
aH
+
state
.
lineWidth
)
;
bounds
=
mTarget
-
>
GetTransform
(
)
.
TransformBounds
(
bounds
)
;
}
if
(
!
aH
)
{
CapStyle
cap
=
CapStyle
:
:
BUTT
;
if
(
state
.
lineJoin
=
=
JoinStyle
:
:
ROUND
)
{
cap
=
CapStyle
:
:
ROUND
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
StrokeLine
(
Point
(
aX
aY
)
Point
(
aX
+
aW
aY
)
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
STROKE
mTarget
)
StrokeOptions
(
state
.
lineWidth
state
.
lineJoin
cap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
DrawOptions
(
state
.
globalAlpha
UsedOperation
(
)
)
)
;
return
;
}
if
(
!
aW
)
{
CapStyle
cap
=
CapStyle
:
:
BUTT
;
if
(
state
.
lineJoin
=
=
JoinStyle
:
:
ROUND
)
{
cap
=
CapStyle
:
:
ROUND
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
StrokeLine
(
Point
(
aX
aY
)
Point
(
aX
aY
+
aH
)
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
STROKE
mTarget
)
StrokeOptions
(
state
.
lineWidth
state
.
lineJoin
cap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
DrawOptions
(
state
.
globalAlpha
UsedOperation
(
)
)
)
;
return
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
StrokeRect
(
gfx
:
:
Rect
(
aX
aY
aW
aH
)
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
STROKE
mTarget
)
StrokeOptions
(
state
.
lineWidth
state
.
lineJoin
state
.
lineCap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
DrawOptions
(
state
.
globalAlpha
UsedOperation
(
)
)
)
;
Redraw
(
)
;
}
void
CanvasRenderingContext2D
:
:
BeginPath
(
)
{
mPath
=
nullptr
;
mPathBuilder
=
nullptr
;
mDSPathBuilder
=
nullptr
;
mPathTransformWillUpdate
=
false
;
}
void
CanvasRenderingContext2D
:
:
Fill
(
const
CanvasWindingRule
&
aWinding
)
{
EnsureUserSpacePath
(
aWinding
)
;
if
(
!
mPath
)
{
return
;
}
gfx
:
:
Rect
bounds
;
if
(
NeedToCalculateBounds
(
)
)
{
bounds
=
mPath
-
>
GetBounds
(
mTarget
-
>
GetTransform
(
)
)
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
Fill
(
mPath
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
FILL
mTarget
)
DrawOptions
(
CurrentState
(
)
.
globalAlpha
UsedOperation
(
)
)
)
;
Redraw
(
)
;
}
void
CanvasRenderingContext2D
:
:
Fill
(
const
CanvasPath
&
aPath
const
CanvasWindingRule
&
aWinding
)
{
EnsureTarget
(
)
;
RefPtr
<
gfx
:
:
Path
>
gfxpath
=
aPath
.
GetPath
(
aWinding
mTarget
)
;
if
(
!
gfxpath
)
{
return
;
}
gfx
:
:
Rect
bounds
;
if
(
NeedToCalculateBounds
(
)
)
{
bounds
=
gfxpath
-
>
GetBounds
(
mTarget
-
>
GetTransform
(
)
)
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
Fill
(
gfxpath
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
FILL
mTarget
)
DrawOptions
(
CurrentState
(
)
.
globalAlpha
UsedOperation
(
)
)
)
;
Redraw
(
)
;
}
void
CanvasRenderingContext2D
:
:
Stroke
(
)
{
EnsureUserSpacePath
(
)
;
if
(
!
mPath
)
{
return
;
}
const
ContextState
&
state
=
CurrentState
(
)
;
StrokeOptions
strokeOptions
(
state
.
lineWidth
state
.
lineJoin
state
.
lineCap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
;
gfx
:
:
Rect
bounds
;
if
(
NeedToCalculateBounds
(
)
)
{
bounds
=
mPath
-
>
GetStrokedBounds
(
strokeOptions
mTarget
-
>
GetTransform
(
)
)
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
Stroke
(
mPath
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
STROKE
mTarget
)
strokeOptions
DrawOptions
(
state
.
globalAlpha
UsedOperation
(
)
)
)
;
Redraw
(
)
;
}
void
CanvasRenderingContext2D
:
:
Stroke
(
const
CanvasPath
&
aPath
)
{
EnsureTarget
(
)
;
RefPtr
<
gfx
:
:
Path
>
gfxpath
=
aPath
.
GetPath
(
CanvasWindingRule
:
:
Nonzero
mTarget
)
;
if
(
!
gfxpath
)
{
return
;
}
const
ContextState
&
state
=
CurrentState
(
)
;
StrokeOptions
strokeOptions
(
state
.
lineWidth
state
.
lineJoin
state
.
lineCap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
;
gfx
:
:
Rect
bounds
;
if
(
NeedToCalculateBounds
(
)
)
{
bounds
=
gfxpath
-
>
GetStrokedBounds
(
strokeOptions
mTarget
-
>
GetTransform
(
)
)
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
Stroke
(
gfxpath
CanvasGeneralPattern
(
)
.
ForStyle
(
this
Style
:
:
STROKE
mTarget
)
strokeOptions
DrawOptions
(
state
.
globalAlpha
UsedOperation
(
)
)
)
;
Redraw
(
)
;
}
void
CanvasRenderingContext2D
:
:
DrawFocusIfNeeded
(
mozilla
:
:
dom
:
:
Element
&
aElement
ErrorResult
&
aRv
)
{
EnsureUserSpacePath
(
)
;
if
(
!
mPath
)
{
return
;
}
if
(
DrawCustomFocusRing
(
aElement
)
)
{
Save
(
)
;
ContextState
&
state
=
CurrentState
(
)
;
state
.
globalAlpha
=
1
.
0
;
state
.
shadowBlur
=
0
;
state
.
shadowOffset
.
x
=
0
;
state
.
shadowOffset
.
y
=
0
;
state
.
op
=
mozilla
:
:
gfx
:
:
CompositionOp
:
:
OP_OVER
;
state
.
lineCap
=
CapStyle
:
:
BUTT
;
state
.
lineJoin
=
mozilla
:
:
gfx
:
:
JoinStyle
:
:
MITER_OR_BEVEL
;
state
.
lineWidth
=
1
;
CurrentState
(
)
.
dash
.
Clear
(
)
;
CurrentState
(
)
.
SetColorStyle
(
Style
:
:
STROKE
NS_RGBA
(
255
255
255
255
)
)
;
Stroke
(
)
;
nsTArray
<
mozilla
:
:
gfx
:
:
Float
>
&
dash
=
CurrentState
(
)
.
dash
;
for
(
uint32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
if
(
!
dash
.
AppendElement
(
1
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
}
CurrentState
(
)
.
SetColorStyle
(
Style
:
:
STROKE
NS_RGBA
(
0
0
0
255
)
)
;
Stroke
(
)
;
Restore
(
)
;
}
}
bool
CanvasRenderingContext2D
:
:
DrawCustomFocusRing
(
mozilla
:
:
dom
:
:
Element
&
aElement
)
{
EnsureUserSpacePath
(
)
;
HTMLCanvasElement
*
canvas
=
GetCanvas
(
)
;
if
(
!
canvas
|
|
!
nsContentUtils
:
:
ContentIsDescendantOf
(
&
aElement
canvas
)
)
{
return
false
;
}
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsCOMPtr
<
nsIDOMElement
>
focusedElement
;
fm
-
>
GetFocusedElement
(
getter_AddRefs
(
focusedElement
)
)
;
if
(
SameCOMIdentity
(
aElement
.
AsDOMNode
(
)
focusedElement
)
)
{
if
(
nsPIDOMWindowOuter
*
window
=
aElement
.
OwnerDoc
(
)
-
>
GetWindow
(
)
)
{
return
window
-
>
ShouldShowFocusRing
(
)
;
}
}
}
return
false
;
}
void
CanvasRenderingContext2D
:
:
Clip
(
const
CanvasWindingRule
&
aWinding
)
{
EnsureUserSpacePath
(
aWinding
)
;
if
(
!
mPath
)
{
return
;
}
mTarget
-
>
PushClip
(
mPath
)
;
CurrentState
(
)
.
clipsPushed
.
AppendElement
(
mPath
)
;
}
void
CanvasRenderingContext2D
:
:
Clip
(
const
CanvasPath
&
aPath
const
CanvasWindingRule
&
aWinding
)
{
EnsureTarget
(
)
;
RefPtr
<
gfx
:
:
Path
>
gfxpath
=
aPath
.
GetPath
(
aWinding
mTarget
)
;
if
(
!
gfxpath
)
{
return
;
}
mTarget
-
>
PushClip
(
gfxpath
)
;
CurrentState
(
)
.
clipsPushed
.
AppendElement
(
gfxpath
)
;
}
void
CanvasRenderingContext2D
:
:
ArcTo
(
double
aX1
double
aY1
double
aX2
double
aY2
double
aRadius
ErrorResult
&
aError
)
{
if
(
aRadius
<
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
EnsureWritablePath
(
)
;
Point
p0
;
if
(
mPathBuilder
)
{
p0
=
mPathBuilder
-
>
CurrentPoint
(
)
;
}
else
{
Matrix
invTransform
=
mTarget
-
>
GetTransform
(
)
;
if
(
!
invTransform
.
Invert
(
)
)
{
return
;
}
p0
=
invTransform
*
mDSPathBuilder
-
>
CurrentPoint
(
)
;
}
Point
p1
(
aX1
aY1
)
;
Point
p2
(
aX2
aY2
)
;
double
dir
a2
b2
c2
cosx
sinx
d
anx
any
bnx
bny
x3
y3
x4
y4
cx
cy
angle0
angle1
;
bool
anticlockwise
;
if
(
p0
=
=
p1
|
|
p1
=
=
p2
|
|
aRadius
=
=
0
)
{
LineTo
(
p1
.
x
p1
.
y
)
;
return
;
}
dir
=
(
p2
.
x
-
p1
.
x
)
*
(
p0
.
y
-
p1
.
y
)
+
(
p2
.
y
-
p1
.
y
)
*
(
p1
.
x
-
p0
.
x
)
;
if
(
dir
=
=
0
)
{
LineTo
(
p1
.
x
p1
.
y
)
;
return
;
}
a2
=
(
p0
.
x
-
aX1
)
*
(
p0
.
x
-
aX1
)
+
(
p0
.
y
-
aY1
)
*
(
p0
.
y
-
aY1
)
;
b2
=
(
aX1
-
aX2
)
*
(
aX1
-
aX2
)
+
(
aY1
-
aY2
)
*
(
aY1
-
aY2
)
;
c2
=
(
p0
.
x
-
aX2
)
*
(
p0
.
x
-
aX2
)
+
(
p0
.
y
-
aY2
)
*
(
p0
.
y
-
aY2
)
;
cosx
=
(
a2
+
b2
-
c2
)
/
(
2
*
sqrt
(
a2
*
b2
)
)
;
sinx
=
sqrt
(
1
-
cosx
*
cosx
)
;
d
=
aRadius
/
(
(
1
-
cosx
)
/
sinx
)
;
anx
=
(
aX1
-
p0
.
x
)
/
sqrt
(
a2
)
;
any
=
(
aY1
-
p0
.
y
)
/
sqrt
(
a2
)
;
bnx
=
(
aX1
-
aX2
)
/
sqrt
(
b2
)
;
bny
=
(
aY1
-
aY2
)
/
sqrt
(
b2
)
;
x3
=
aX1
-
anx
*
d
;
y3
=
aY1
-
any
*
d
;
x4
=
aX1
-
bnx
*
d
;
y4
=
aY1
-
bny
*
d
;
anticlockwise
=
(
dir
<
0
)
;
cx
=
x3
+
any
*
aRadius
*
(
anticlockwise
?
1
:
-
1
)
;
cy
=
y3
-
anx
*
aRadius
*
(
anticlockwise
?
1
:
-
1
)
;
angle0
=
atan2
(
(
y3
-
cy
)
(
x3
-
cx
)
)
;
angle1
=
atan2
(
(
y4
-
cy
)
(
x4
-
cx
)
)
;
LineTo
(
x3
y3
)
;
Arc
(
cx
cy
aRadius
angle0
angle1
anticlockwise
aError
)
;
}
void
CanvasRenderingContext2D
:
:
Arc
(
double
aX
double
aY
double
aR
double
aStartAngle
double
aEndAngle
bool
aAnticlockwise
ErrorResult
&
aError
)
{
if
(
aR
<
0
.
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
EnsureWritablePath
(
)
;
ArcToBezier
(
this
Point
(
aX
aY
)
Size
(
aR
aR
)
aStartAngle
aEndAngle
aAnticlockwise
)
;
}
void
CanvasRenderingContext2D
:
:
Rect
(
double
aX
double
aY
double
aW
double
aH
)
{
EnsureWritablePath
(
)
;
if
(
mPathBuilder
)
{
mPathBuilder
-
>
MoveTo
(
Point
(
aX
aY
)
)
;
mPathBuilder
-
>
LineTo
(
Point
(
aX
+
aW
aY
)
)
;
mPathBuilder
-
>
LineTo
(
Point
(
aX
+
aW
aY
+
aH
)
)
;
mPathBuilder
-
>
LineTo
(
Point
(
aX
aY
+
aH
)
)
;
mPathBuilder
-
>
Close
(
)
;
}
else
{
mDSPathBuilder
-
>
MoveTo
(
mTarget
-
>
GetTransform
(
)
*
Point
(
aX
aY
)
)
;
mDSPathBuilder
-
>
LineTo
(
mTarget
-
>
GetTransform
(
)
*
Point
(
aX
+
aW
aY
)
)
;
mDSPathBuilder
-
>
LineTo
(
mTarget
-
>
GetTransform
(
)
*
Point
(
aX
+
aW
aY
+
aH
)
)
;
mDSPathBuilder
-
>
LineTo
(
mTarget
-
>
GetTransform
(
)
*
Point
(
aX
aY
+
aH
)
)
;
mDSPathBuilder
-
>
Close
(
)
;
}
}
void
CanvasRenderingContext2D
:
:
EnsureWritablePath
(
)
{
EnsureTarget
(
)
;
if
(
mDSPathBuilder
)
{
return
;
}
FillRule
fillRule
=
CurrentState
(
)
.
fillRule
;
if
(
mPathBuilder
)
{
if
(
mPathTransformWillUpdate
)
{
mPath
=
mPathBuilder
-
>
Finish
(
)
;
mDSPathBuilder
=
mPath
-
>
TransformedCopyToBuilder
(
mPathToDS
fillRule
)
;
mPath
=
nullptr
;
mPathBuilder
=
nullptr
;
mPathTransformWillUpdate
=
false
;
}
return
;
}
if
(
!
mPath
)
{
NS_ASSERTION
(
!
mPathTransformWillUpdate
"
mPathTransformWillUpdate
should
be
false
if
all
paths
are
null
"
)
;
mPathBuilder
=
mTarget
-
>
CreatePathBuilder
(
fillRule
)
;
}
else
if
(
!
mPathTransformWillUpdate
)
{
mPathBuilder
=
mPath
-
>
CopyToBuilder
(
fillRule
)
;
}
else
{
mDSPathBuilder
=
mPath
-
>
TransformedCopyToBuilder
(
mPathToDS
fillRule
)
;
mPathTransformWillUpdate
=
false
;
mPath
=
nullptr
;
}
}
void
CanvasRenderingContext2D
:
:
EnsureUserSpacePath
(
const
CanvasWindingRule
&
aWinding
)
{
FillRule
fillRule
=
CurrentState
(
)
.
fillRule
;
if
(
aWinding
=
=
CanvasWindingRule
:
:
Evenodd
)
fillRule
=
FillRule
:
:
FILL_EVEN_ODD
;
EnsureTarget
(
)
;
if
(
!
mPath
&
&
!
mPathBuilder
&
&
!
mDSPathBuilder
)
{
mPathBuilder
=
mTarget
-
>
CreatePathBuilder
(
fillRule
)
;
}
if
(
mPathBuilder
)
{
mPath
=
mPathBuilder
-
>
Finish
(
)
;
mPathBuilder
=
nullptr
;
}
if
(
mPath
&
&
mPathTransformWillUpdate
)
{
mDSPathBuilder
=
mPath
-
>
TransformedCopyToBuilder
(
mPathToDS
fillRule
)
;
mPath
=
nullptr
;
mPathTransformWillUpdate
=
false
;
}
if
(
mDSPathBuilder
)
{
RefPtr
<
Path
>
dsPath
;
dsPath
=
mDSPathBuilder
-
>
Finish
(
)
;
mDSPathBuilder
=
nullptr
;
Matrix
inverse
=
mTarget
-
>
GetTransform
(
)
;
if
(
!
inverse
.
Invert
(
)
)
{
NS_WARNING
(
"
Could
not
invert
transform
"
)
;
return
;
}
mPathBuilder
=
dsPath
-
>
TransformedCopyToBuilder
(
inverse
fillRule
)
;
mPath
=
mPathBuilder
-
>
Finish
(
)
;
mPathBuilder
=
nullptr
;
}
if
(
mPath
&
&
mPath
-
>
GetFillRule
(
)
!
=
fillRule
)
{
mPathBuilder
=
mPath
-
>
CopyToBuilder
(
fillRule
)
;
mPath
=
mPathBuilder
-
>
Finish
(
)
;
mPathBuilder
=
nullptr
;
}
NS_ASSERTION
(
mPath
"
mPath
should
exist
"
)
;
}
void
CanvasRenderingContext2D
:
:
TransformWillUpdate
(
)
{
EnsureTarget
(
)
;
if
(
mPath
|
|
mPathBuilder
)
{
if
(
!
mPathTransformWillUpdate
)
{
mPathToDS
=
mTarget
-
>
GetTransform
(
)
;
}
mPathTransformWillUpdate
=
true
;
}
}
void
CanvasRenderingContext2D
:
:
SetFont
(
const
nsAString
&
aFont
ErrorResult
&
aError
)
{
SetFontInternal
(
aFont
aError
)
;
}
bool
CanvasRenderingContext2D
:
:
SetFontInternal
(
const
nsAString
&
aFont
ErrorResult
&
aError
)
{
if
(
!
mCanvasElement
&
&
!
mDocShell
)
{
NS_WARNING
(
"
Canvas
element
must
be
non
-
null
or
a
docshell
must
be
provided
"
)
;
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
nsString
usedFont
;
RefPtr
<
nsStyleContext
>
sc
=
GetFontStyleContext
(
mCanvasElement
aFont
presShell
usedFont
aError
)
;
if
(
!
sc
)
{
return
false
;
}
const
nsStyleFont
*
fontStyle
=
sc
-
>
StyleFont
(
)
;
nsPresContext
*
c
=
presShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
!
fontStyle
-
>
mAllowZoom
"
expected
text
zoom
to
be
disabled
on
this
nsStyleFont
"
)
;
nsFont
resizedFont
(
fontStyle
-
>
mFont
)
;
resizedFont
.
size
=
(
fontStyle
-
>
mSize
*
c
-
>
AppUnitsPerDevPixel
(
)
)
/
c
-
>
AppUnitsPerCSSPixel
(
)
;
RefPtr
<
nsFontMetrics
>
metrics
;
c
-
>
DeviceContext
(
)
-
>
GetMetricsFor
(
resizedFont
fontStyle
-
>
mLanguage
fontStyle
-
>
mExplicitLanguage
gfxFont
:
:
eHorizontal
c
-
>
GetUserFontSet
(
)
c
-
>
GetTextPerfMetrics
(
)
*
getter_AddRefs
(
metrics
)
)
;
gfxFontGroup
*
newFontGroup
=
metrics
-
>
GetThebesFontGroup
(
)
;
CurrentState
(
)
.
fontGroup
=
newFontGroup
;
NS_ASSERTION
(
CurrentState
(
)
.
fontGroup
"
Could
not
get
font
group
"
)
;
CurrentState
(
)
.
font
=
usedFont
;
CurrentState
(
)
.
fontFont
=
fontStyle
-
>
mFont
;
CurrentState
(
)
.
fontFont
.
size
=
fontStyle
-
>
mSize
;
CurrentState
(
)
.
fontLanguage
=
fontStyle
-
>
mLanguage
;
CurrentState
(
)
.
fontExplicitLanguage
=
fontStyle
-
>
mExplicitLanguage
;
return
true
;
}
void
CanvasRenderingContext2D
:
:
SetTextAlign
(
const
nsAString
&
aTextAlign
)
{
if
(
aTextAlign
.
EqualsLiteral
(
"
start
"
)
)
CurrentState
(
)
.
textAlign
=
TextAlign
:
:
START
;
else
if
(
aTextAlign
.
EqualsLiteral
(
"
end
"
)
)
CurrentState
(
)
.
textAlign
=
TextAlign
:
:
END
;
else
if
(
aTextAlign
.
EqualsLiteral
(
"
left
"
)
)
CurrentState
(
)
.
textAlign
=
TextAlign
:
:
LEFT
;
else
if
(
aTextAlign
.
EqualsLiteral
(
"
right
"
)
)
CurrentState
(
)
.
textAlign
=
TextAlign
:
:
RIGHT
;
else
if
(
aTextAlign
.
EqualsLiteral
(
"
center
"
)
)
CurrentState
(
)
.
textAlign
=
TextAlign
:
:
CENTER
;
}
void
CanvasRenderingContext2D
:
:
GetTextAlign
(
nsAString
&
aTextAlign
)
{
switch
(
CurrentState
(
)
.
textAlign
)
{
case
TextAlign
:
:
START
:
aTextAlign
.
AssignLiteral
(
"
start
"
)
;
break
;
case
TextAlign
:
:
END
:
aTextAlign
.
AssignLiteral
(
"
end
"
)
;
break
;
case
TextAlign
:
:
LEFT
:
aTextAlign
.
AssignLiteral
(
"
left
"
)
;
break
;
case
TextAlign
:
:
RIGHT
:
aTextAlign
.
AssignLiteral
(
"
right
"
)
;
break
;
case
TextAlign
:
:
CENTER
:
aTextAlign
.
AssignLiteral
(
"
center
"
)
;
break
;
}
}
void
CanvasRenderingContext2D
:
:
SetTextBaseline
(
const
nsAString
&
aTextBaseline
)
{
if
(
aTextBaseline
.
EqualsLiteral
(
"
top
"
)
)
CurrentState
(
)
.
textBaseline
=
TextBaseline
:
:
TOP
;
else
if
(
aTextBaseline
.
EqualsLiteral
(
"
hanging
"
)
)
CurrentState
(
)
.
textBaseline
=
TextBaseline
:
:
HANGING
;
else
if
(
aTextBaseline
.
EqualsLiteral
(
"
middle
"
)
)
CurrentState
(
)
.
textBaseline
=
TextBaseline
:
:
MIDDLE
;
else
if
(
aTextBaseline
.
EqualsLiteral
(
"
alphabetic
"
)
)
CurrentState
(
)
.
textBaseline
=
TextBaseline
:
:
ALPHABETIC
;
else
if
(
aTextBaseline
.
EqualsLiteral
(
"
ideographic
"
)
)
CurrentState
(
)
.
textBaseline
=
TextBaseline
:
:
IDEOGRAPHIC
;
else
if
(
aTextBaseline
.
EqualsLiteral
(
"
bottom
"
)
)
CurrentState
(
)
.
textBaseline
=
TextBaseline
:
:
BOTTOM
;
}
void
CanvasRenderingContext2D
:
:
GetTextBaseline
(
nsAString
&
aTextBaseline
)
{
switch
(
CurrentState
(
)
.
textBaseline
)
{
case
TextBaseline
:
:
TOP
:
aTextBaseline
.
AssignLiteral
(
"
top
"
)
;
break
;
case
TextBaseline
:
:
HANGING
:
aTextBaseline
.
AssignLiteral
(
"
hanging
"
)
;
break
;
case
TextBaseline
:
:
MIDDLE
:
aTextBaseline
.
AssignLiteral
(
"
middle
"
)
;
break
;
case
TextBaseline
:
:
ALPHABETIC
:
aTextBaseline
.
AssignLiteral
(
"
alphabetic
"
)
;
break
;
case
TextBaseline
:
:
IDEOGRAPHIC
:
aTextBaseline
.
AssignLiteral
(
"
ideographic
"
)
;
break
;
case
TextBaseline
:
:
BOTTOM
:
aTextBaseline
.
AssignLiteral
(
"
bottom
"
)
;
break
;
}
}
static
inline
void
TextReplaceWhitespaceCharacters
(
nsAutoString
&
aStr
)
{
aStr
.
ReplaceChar
(
"
\
x09
\
x0A
\
x0B
\
x0C
\
x0D
"
char16_t
(
'
'
)
)
;
}
void
CanvasRenderingContext2D
:
:
FillText
(
const
nsAString
&
aText
double
aX
double
aY
const
Optional
<
double
>
&
aMaxWidth
ErrorResult
&
aError
)
{
aError
=
DrawOrMeasureText
(
aText
aX
aY
aMaxWidth
TextDrawOperation
:
:
FILL
nullptr
)
;
}
void
CanvasRenderingContext2D
:
:
StrokeText
(
const
nsAString
&
aText
double
aX
double
aY
const
Optional
<
double
>
&
aMaxWidth
ErrorResult
&
aError
)
{
aError
=
DrawOrMeasureText
(
aText
aX
aY
aMaxWidth
TextDrawOperation
:
:
STROKE
nullptr
)
;
}
TextMetrics
*
CanvasRenderingContext2D
:
:
MeasureText
(
const
nsAString
&
aRawText
ErrorResult
&
aError
)
{
float
width
;
Optional
<
double
>
maxWidth
;
aError
=
DrawOrMeasureText
(
aRawText
0
0
maxWidth
TextDrawOperation
:
:
MEASURE
&
width
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
return
new
TextMetrics
(
width
)
;
}
void
CanvasRenderingContext2D
:
:
AddHitRegion
(
const
HitRegionOptions
&
aOptions
ErrorResult
&
aError
)
{
RefPtr
<
gfx
:
:
Path
>
path
;
if
(
aOptions
.
mPath
)
{
EnsureTarget
(
)
;
path
=
aOptions
.
mPath
-
>
GetPath
(
CanvasWindingRule
:
:
Nonzero
mTarget
)
;
}
if
(
!
path
)
{
EnsureUserSpacePath
(
CanvasWindingRule
:
:
Nonzero
)
;
path
=
mPath
;
}
if
(
!
path
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
gfx
:
:
Rect
bounds
(
path
-
>
GetBounds
(
mTarget
-
>
GetTransform
(
)
)
)
;
if
(
(
bounds
.
width
=
=
0
)
|
|
(
bounds
.
height
=
=
0
)
|
|
!
bounds
.
IsFinite
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
RemoveHitRegion
(
aOptions
.
mId
)
;
if
(
aOptions
.
mControl
)
{
for
(
size_t
x
=
0
;
x
<
mHitRegionsOptions
.
Length
(
)
;
x
+
+
)
{
RegionInfo
&
info
=
mHitRegionsOptions
[
x
]
;
if
(
info
.
mElement
=
=
aOptions
.
mControl
)
{
mHitRegionsOptions
.
RemoveElementAt
(
x
)
;
break
;
}
}
#
ifdef
ACCESSIBILITY
aOptions
.
mControl
-
>
SetProperty
(
nsGkAtoms
:
:
hitregion
new
bool
(
true
)
nsINode
:
:
DeleteProperty
<
bool
>
)
;
#
endif
}
RegionInfo
info
;
info
.
mId
=
aOptions
.
mId
;
info
.
mElement
=
aOptions
.
mControl
;
RefPtr
<
PathBuilder
>
pathBuilder
=
path
-
>
TransformedCopyToBuilder
(
mTarget
-
>
GetTransform
(
)
)
;
info
.
mPath
=
pathBuilder
-
>
Finish
(
)
;
mHitRegionsOptions
.
InsertElementAt
(
0
info
)
;
}
void
CanvasRenderingContext2D
:
:
RemoveHitRegion
(
const
nsAString
&
aId
)
{
if
(
aId
.
Length
(
)
=
=
0
)
{
return
;
}
for
(
size_t
x
=
0
;
x
<
mHitRegionsOptions
.
Length
(
)
;
x
+
+
)
{
RegionInfo
&
info
=
mHitRegionsOptions
[
x
]
;
if
(
info
.
mId
=
=
aId
)
{
mHitRegionsOptions
.
RemoveElementAt
(
x
)
;
return
;
}
}
}
void
CanvasRenderingContext2D
:
:
ClearHitRegions
(
)
{
mHitRegionsOptions
.
Clear
(
)
;
}
bool
CanvasRenderingContext2D
:
:
GetHitRegionRect
(
Element
*
aElement
nsRect
&
aRect
)
{
for
(
unsigned
int
x
=
0
;
x
<
mHitRegionsOptions
.
Length
(
)
;
x
+
+
)
{
RegionInfo
&
info
=
mHitRegionsOptions
[
x
]
;
if
(
info
.
mElement
=
=
aElement
)
{
gfx
:
:
Rect
bounds
(
info
.
mPath
-
>
GetBounds
(
)
)
;
gfxRect
rect
(
bounds
.
x
bounds
.
y
bounds
.
width
bounds
.
height
)
;
aRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
rect
AppUnitsPerCSSPixel
(
)
)
;
return
true
;
}
}
return
false
;
}
struct
MOZ_STACK_CLASS
CanvasBidiProcessor
:
public
nsBidiPresUtils
:
:
BidiProcessor
{
CanvasBidiProcessor
(
)
:
nsBidiPresUtils
:
:
BidiProcessor
(
)
{
if
(
Preferences
:
:
GetBool
(
GFX_MISSING_FONTS_NOTIFY_PREF
)
)
{
mMissingFonts
=
new
gfxMissingFontRecorder
(
)
;
}
}
~
CanvasBidiProcessor
(
)
{
if
(
mMissingFonts
)
{
mMissingFonts
-
>
Flush
(
)
;
}
}
typedef
CanvasRenderingContext2D
:
:
ContextState
ContextState
;
virtual
void
SetText
(
const
char16_t
*
aText
int32_t
aLength
nsBidiDirection
aDirection
)
{
mFontgrp
-
>
UpdateUserFonts
(
)
;
uint32_t
flags
=
mTextRunFlags
;
if
(
aDirection
=
=
NSBIDI_RTL
)
{
flags
|
=
gfxTextRunFactory
:
:
TEXT_IS_RTL
;
}
else
{
flags
&
=
~
gfxTextRunFactory
:
:
TEXT_IS_RTL
;
}
mTextRun
=
mFontgrp
-
>
MakeTextRun
(
aText
aLength
mDrawTarget
mAppUnitsPerDevPixel
flags
mMissingFonts
)
;
}
virtual
nscoord
GetWidth
(
)
{
gfxTextRun
:
:
Metrics
textRunMetrics
=
mTextRun
-
>
MeasureText
(
0
mTextRun
-
>
GetLength
(
)
mDoMeasureBoundingBox
?
gfxFont
:
:
TIGHT_INK_EXTENTS
:
gfxFont
:
:
LOOSE_INK_EXTENTS
mDrawTarget
nullptr
)
;
if
(
mDoMeasureBoundingBox
)
{
textRunMetrics
.
mBoundingBox
.
Scale
(
1
.
0
/
mAppUnitsPerDevPixel
)
;
mBoundingBox
=
mBoundingBox
.
Union
(
textRunMetrics
.
mBoundingBox
)
;
}
return
NSToCoordRound
(
textRunMetrics
.
mAdvanceWidth
)
;
}
virtual
void
DrawText
(
nscoord
aXOffset
nscoord
aWidth
)
{
gfxPoint
point
=
mPt
;
bool
rtl
=
mTextRun
-
>
IsRightToLeft
(
)
;
bool
verticalRun
=
mTextRun
-
>
IsVertical
(
)
;
bool
centerBaseline
=
mTextRun
-
>
UseCenterBaseline
(
)
;
gfxFloat
&
inlineCoord
=
verticalRun
?
point
.
y
:
point
.
x
;
inlineCoord
+
=
aXOffset
;
if
(
rtl
)
{
gfxTextRun
:
:
Metrics
textRunMetrics
=
mTextRun
-
>
MeasureText
(
0
mTextRun
-
>
GetLength
(
)
mDoMeasureBoundingBox
?
gfxFont
:
:
TIGHT_INK_EXTENTS
:
gfxFont
:
:
LOOSE_INK_EXTENTS
mDrawTarget
nullptr
)
;
inlineCoord
+
=
textRunMetrics
.
mAdvanceWidth
;
}
uint32_t
numRuns
;
const
gfxTextRun
:
:
GlyphRun
*
runs
=
mTextRun
-
>
GetGlyphRuns
(
&
numRuns
)
;
const
int32_t
appUnitsPerDevUnit
=
mAppUnitsPerDevPixel
;
const
double
devUnitsPerAppUnit
=
1
.
0
/
double
(
appUnitsPerDevUnit
)
;
Point
baselineOrigin
=
Point
(
point
.
x
*
devUnitsPerAppUnit
point
.
y
*
devUnitsPerAppUnit
)
;
float
advanceSum
=
0
;
mCtx
-
>
EnsureTarget
(
)
;
for
(
uint32_t
c
=
0
;
c
<
numRuns
;
c
+
+
)
{
gfxFont
*
font
=
runs
[
c
]
.
mFont
;
bool
verticalFont
=
runs
[
c
]
.
mOrientation
=
=
gfxTextRunFactory
:
:
TEXT_ORIENT_VERTICAL_UPRIGHT
;
const
float
&
baselineOriginInline
=
verticalFont
?
baselineOrigin
.
y
:
baselineOrigin
.
x
;
const
float
&
baselineOriginBlock
=
verticalFont
?
baselineOrigin
.
x
:
baselineOrigin
.
y
;
uint32_t
endRun
=
0
;
if
(
c
+
1
<
numRuns
)
{
endRun
=
runs
[
c
+
1
]
.
mCharacterOffset
;
}
else
{
endRun
=
mTextRun
-
>
GetLength
(
)
;
}
const
gfxTextRun
:
:
CompressedGlyph
*
glyphs
=
mTextRun
-
>
GetCharacterGlyphs
(
)
;
RefPtr
<
ScaledFont
>
scaledFont
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetScaledFontForFont
(
mCtx
-
>
mTarget
font
)
;
if
(
!
scaledFont
)
{
return
;
}
AutoRestoreTransform
sidewaysRestore
;
if
(
runs
[
c
]
.
mOrientation
=
=
gfxTextRunFactory
:
:
TEXT_ORIENT_VERTICAL_SIDEWAYS_RIGHT
)
{
sidewaysRestore
.
Init
(
mCtx
-
>
mTarget
)
;
const
gfxFont
:
:
Metrics
&
metrics
=
mTextRun
-
>
GetFontGroup
(
)
-
>
GetFirstValidFont
(
)
-
>
GetMetrics
(
gfxFont
:
:
eHorizontal
)
;
gfx
:
:
Matrix
mat
=
mCtx
-
>
mTarget
-
>
GetTransform
(
)
.
Copy
(
)
.
PreTranslate
(
baselineOrigin
)
.
PreRotate
(
gfx
:
:
Float
(
M_PI
/
2
.
0
)
)
.
PreTranslate
(
-
baselineOrigin
)
;
if
(
centerBaseline
)
{
float
offset
=
(
metrics
.
emAscent
-
metrics
.
emDescent
)
/
2
;
mat
=
mat
.
PreTranslate
(
Point
(
0
offset
)
)
;
}
mCtx
-
>
mTarget
-
>
SetTransform
(
mat
)
;
}
RefPtr
<
GlyphRenderingOptions
>
renderingOptions
=
font
-
>
GetGlyphRenderingOptions
(
)
;
GlyphBuffer
buffer
;
std
:
:
vector
<
Glyph
>
glyphBuf
;
for
(
uint32_t
i
=
runs
[
c
]
.
mCharacterOffset
;
i
<
endRun
;
i
+
+
)
{
Glyph
newGlyph
;
float
&
inlinePos
=
verticalFont
?
newGlyph
.
mPosition
.
y
:
newGlyph
.
mPosition
.
x
;
float
&
blockPos
=
verticalFont
?
newGlyph
.
mPosition
.
x
:
newGlyph
.
mPosition
.
y
;
if
(
glyphs
[
i
]
.
IsSimpleGlyph
(
)
)
{
newGlyph
.
mIndex
=
glyphs
[
i
]
.
GetSimpleGlyph
(
)
;
if
(
rtl
)
{
inlinePos
=
baselineOriginInline
-
advanceSum
-
glyphs
[
i
]
.
GetSimpleAdvance
(
)
*
devUnitsPerAppUnit
;
}
else
{
inlinePos
=
baselineOriginInline
+
advanceSum
;
}
blockPos
=
baselineOriginBlock
;
advanceSum
+
=
glyphs
[
i
]
.
GetSimpleAdvance
(
)
*
devUnitsPerAppUnit
;
glyphBuf
.
push_back
(
newGlyph
)
;
continue
;
}
if
(
!
glyphs
[
i
]
.
GetGlyphCount
(
)
)
{
continue
;
}
const
gfxTextRun
:
:
DetailedGlyph
*
d
=
mTextRun
-
>
GetDetailedGlyphs
(
i
)
;
if
(
glyphs
[
i
]
.
IsMissing
(
)
)
{
if
(
d
-
>
mAdvance
>
0
)
{
newGlyph
.
mIndex
=
0
;
if
(
rtl
)
{
inlinePos
=
baselineOriginInline
-
advanceSum
-
d
-
>
mAdvance
*
devUnitsPerAppUnit
;
}
else
{
inlinePos
=
baselineOriginInline
+
advanceSum
;
}
blockPos
=
baselineOriginBlock
;
advanceSum
+
=
d
-
>
mAdvance
*
devUnitsPerAppUnit
;
glyphBuf
.
push_back
(
newGlyph
)
;
}
continue
;
}
for
(
uint32_t
c
=
0
;
c
<
glyphs
[
i
]
.
GetGlyphCount
(
)
;
c
+
+
d
+
+
)
{
newGlyph
.
mIndex
=
d
-
>
mGlyphID
;
if
(
rtl
)
{
inlinePos
=
baselineOriginInline
-
advanceSum
-
d
-
>
mAdvance
*
devUnitsPerAppUnit
;
}
else
{
inlinePos
=
baselineOriginInline
+
advanceSum
;
}
inlinePos
+
=
d
-
>
mXOffset
*
devUnitsPerAppUnit
;
blockPos
=
baselineOriginBlock
+
d
-
>
mYOffset
*
devUnitsPerAppUnit
;
glyphBuf
.
push_back
(
newGlyph
)
;
advanceSum
+
=
d
-
>
mAdvance
*
devUnitsPerAppUnit
;
}
}
if
(
!
glyphBuf
.
size
(
)
)
{
continue
;
}
buffer
.
mGlyphs
=
&
glyphBuf
.
front
(
)
;
buffer
.
mNumGlyphs
=
glyphBuf
.
size
(
)
;
Rect
bounds
=
mCtx
-
>
mTarget
-
>
GetTransform
(
)
.
TransformBounds
(
Rect
(
mBoundingBox
.
x
mBoundingBox
.
y
mBoundingBox
.
width
mBoundingBox
.
height
)
)
;
if
(
mOp
=
=
CanvasRenderingContext2D
:
:
TextDrawOperation
:
:
FILL
)
{
AdjustedTarget
(
mCtx
&
bounds
)
-
>
FillGlyphs
(
scaledFont
buffer
CanvasGeneralPattern
(
)
.
ForStyle
(
mCtx
CanvasRenderingContext2D
:
:
Style
:
:
FILL
mCtx
-
>
mTarget
)
DrawOptions
(
mState
-
>
globalAlpha
mCtx
-
>
UsedOperation
(
)
)
renderingOptions
)
;
}
else
if
(
mOp
=
=
CanvasRenderingContext2D
:
:
TextDrawOperation
:
:
STROKE
)
{
buffer
.
mGlyphs
=
&
glyphBuf
.
front
(
)
;
buffer
.
mNumGlyphs
=
1
;
const
ContextState
&
state
=
*
mState
;
const
StrokeOptions
strokeOpts
(
state
.
lineWidth
state
.
lineJoin
state
.
lineCap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
;
bounds
.
Inflate
(
MaxStrokeExtents
(
strokeOpts
mCtx
-
>
mTarget
-
>
GetTransform
(
)
)
)
;
AdjustedTarget
target
(
mCtx
&
bounds
)
;
CanvasGeneralPattern
cgp
;
const
Pattern
&
patForStyle
(
cgp
.
ForStyle
(
mCtx
CanvasRenderingContext2D
:
:
Style
:
:
STROKE
mCtx
-
>
mTarget
)
)
;
const
DrawOptions
drawOpts
(
state
.
globalAlpha
mCtx
-
>
UsedOperation
(
)
)
;
for
(
unsigned
i
=
glyphBuf
.
size
(
)
;
i
>
0
;
-
-
i
)
{
RefPtr
<
Path
>
path
=
scaledFont
-
>
GetPathForGlyphs
(
buffer
mCtx
-
>
mTarget
)
;
target
-
>
Stroke
(
path
patForStyle
strokeOpts
drawOpts
)
;
buffer
.
mGlyphs
+
+
;
}
}
}
}
nsAutoPtr
<
gfxTextRun
>
mTextRun
;
RefPtr
<
DrawTarget
>
mDrawTarget
;
CanvasRenderingContext2D
*
mCtx
;
gfxPoint
mPt
;
gfxFontGroup
*
mFontgrp
;
nsAutoPtr
<
gfxMissingFontRecorder
>
mMissingFonts
;
int32_t
mAppUnitsPerDevPixel
;
CanvasRenderingContext2D
:
:
TextDrawOperation
mOp
;
ContextState
*
mState
;
gfxRect
mBoundingBox
;
uint32_t
mTextRunFlags
;
bool
mDoMeasureBoundingBox
;
}
;
nsresult
CanvasRenderingContext2D
:
:
DrawOrMeasureText
(
const
nsAString
&
aRawText
float
aX
float
aY
const
Optional
<
double
>
&
aMaxWidth
TextDrawOperation
aOp
float
*
aWidth
)
{
nsresult
rv
;
if
(
aMaxWidth
.
WasPassed
(
)
&
&
aMaxWidth
.
Value
(
)
<
0
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mCanvasElement
&
&
!
mDocShell
)
{
NS_WARNING
(
"
Canvas
element
must
be
non
-
null
or
a
docshell
must
be
provided
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
return
NS_ERROR_FAILURE
;
nsIDocument
*
document
=
presShell
-
>
GetDocument
(
)
;
nsAutoString
textToDraw
(
aRawText
)
;
TextReplaceWhitespaceCharacters
(
textToDraw
)
;
bool
isRTL
=
false
;
RefPtr
<
nsStyleContext
>
canvasStyle
;
if
(
mCanvasElement
&
&
mCanvasElement
-
>
IsInDoc
(
)
)
{
canvasStyle
=
nsComputedDOMStyle
:
:
GetStyleContextForElement
(
mCanvasElement
nullptr
presShell
)
;
if
(
!
canvasStyle
)
{
return
NS_ERROR_FAILURE
;
}
isRTL
=
canvasStyle
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_RTL
;
}
else
{
isRTL
=
GET_BIDI_OPTION_DIRECTION
(
document
-
>
GetBidiOptions
(
)
)
=
=
IBMBIDI_TEXTDIRECTION_RTL
;
}
gfxFontGroup
*
currentFontStyle
=
GetCurrentFontStyle
(
)
;
if
(
!
currentFontStyle
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
!
presShell
-
>
IsDestroying
(
)
"
GetCurrentFontStyle
(
)
should
have
returned
null
if
the
presshell
is
being
destroyed
"
)
;
currentFontStyle
-
>
SetUserFontSet
(
presShell
-
>
GetPresContext
(
)
-
>
GetUserFontSet
(
)
)
;
if
(
currentFontStyle
-
>
GetStyle
(
)
-
>
size
=
=
0
.
0F
)
{
if
(
aWidth
)
{
*
aWidth
=
0
;
}
return
NS_OK
;
}
if
(
!
IsFinite
(
aX
)
|
|
!
IsFinite
(
aY
)
)
{
return
NS_OK
;
}
const
ContextState
&
state
=
CurrentState
(
)
;
bool
doCalculateBounds
=
NeedToCalculateBounds
(
)
;
CanvasBidiProcessor
processor
;
processor
.
mTextRunFlags
=
canvasStyle
?
nsLayoutUtils
:
:
GetTextRunFlagsForStyle
(
canvasStyle
canvasStyle
-
>
StyleFont
(
)
canvasStyle
-
>
StyleText
(
)
0
)
:
0
;
GetAppUnitsValues
(
&
processor
.
mAppUnitsPerDevPixel
nullptr
)
;
processor
.
mPt
=
gfxPoint
(
aX
aY
)
;
processor
.
mDrawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
if
(
mTarget
)
{
processor
.
mDrawTarget
-
>
SetTransform
(
mTarget
-
>
GetTransform
(
)
)
;
}
processor
.
mCtx
=
this
;
processor
.
mOp
=
aOp
;
processor
.
mBoundingBox
=
gfxRect
(
0
0
0
0
)
;
processor
.
mDoMeasureBoundingBox
=
doCalculateBounds
|
|
!
mIsEntireFrameInvalid
;
processor
.
mState
=
&
CurrentState
(
)
;
processor
.
mFontgrp
=
currentFontStyle
;
nscoord
totalWidthCoord
;
nsBidi
bidiEngine
;
rv
=
nsBidiPresUtils
:
:
ProcessText
(
textToDraw
.
get
(
)
textToDraw
.
Length
(
)
isRTL
?
NSBIDI_RTL
:
NSBIDI_LTR
presShell
-
>
GetPresContext
(
)
processor
nsBidiPresUtils
:
:
MODE_MEASURE
nullptr
0
&
totalWidthCoord
&
bidiEngine
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
float
totalWidth
=
float
(
totalWidthCoord
)
/
processor
.
mAppUnitsPerDevPixel
;
if
(
aWidth
)
{
*
aWidth
=
totalWidth
;
}
if
(
aOp
=
=
TextDrawOperation
:
:
MEASURE
)
{
return
NS_OK
;
}
gfxFloat
anchorX
;
if
(
state
.
textAlign
=
=
TextAlign
:
:
CENTER
)
{
anchorX
=
.
5
;
}
else
if
(
state
.
textAlign
=
=
TextAlign
:
:
LEFT
|
|
(
!
isRTL
&
&
state
.
textAlign
=
=
TextAlign
:
:
START
)
|
|
(
isRTL
&
&
state
.
textAlign
=
=
TextAlign
:
:
END
)
)
{
anchorX
=
0
;
}
else
{
anchorX
=
1
;
}
processor
.
mPt
.
x
-
=
anchorX
*
totalWidth
;
processor
.
mFontgrp
-
>
UpdateUserFonts
(
)
;
const
gfxFont
:
:
Metrics
&
fontMetrics
=
processor
.
mFontgrp
-
>
GetFirstValidFont
(
)
-
>
GetMetrics
(
gfxFont
:
:
eHorizontal
)
;
gfxFloat
baselineAnchor
;
switch
(
state
.
textBaseline
)
{
case
TextBaseline
:
:
HANGING
:
case
TextBaseline
:
:
TOP
:
baselineAnchor
=
fontMetrics
.
emAscent
;
break
;
case
TextBaseline
:
:
MIDDLE
:
baselineAnchor
=
(
fontMetrics
.
emAscent
-
fontMetrics
.
emDescent
)
*
.
5f
;
break
;
case
TextBaseline
:
:
IDEOGRAPHIC
:
case
TextBaseline
:
:
ALPHABETIC
:
baselineAnchor
=
0
;
break
;
case
TextBaseline
:
:
BOTTOM
:
baselineAnchor
=
-
fontMetrics
.
emDescent
;
break
;
default
:
MOZ_CRASH
(
"
unexpected
TextBaseline
"
)
;
}
uint16_t
runOrientation
=
(
processor
.
mTextRunFlags
&
gfxTextRunFactory
:
:
TEXT_ORIENT_MASK
)
;
if
(
runOrientation
!
=
gfxTextRunFactory
:
:
TEXT_ORIENT_HORIZONTAL
)
{
if
(
runOrientation
=
=
gfxTextRunFactory
:
:
TEXT_ORIENT_VERTICAL_MIXED
|
|
runOrientation
=
=
gfxTextRunFactory
:
:
TEXT_ORIENT_VERTICAL_UPRIGHT
)
{
baselineAnchor
-
=
(
fontMetrics
.
emAscent
-
fontMetrics
.
emDescent
)
*
.
5f
;
}
processor
.
mPt
.
x
-
=
baselineAnchor
;
}
else
{
processor
.
mPt
.
y
+
=
baselineAnchor
;
}
processor
.
mBoundingBox
.
width
=
totalWidth
;
processor
.
mBoundingBox
.
MoveBy
(
processor
.
mPt
)
;
processor
.
mPt
.
x
*
=
processor
.
mAppUnitsPerDevPixel
;
processor
.
mPt
.
y
*
=
processor
.
mAppUnitsPerDevPixel
;
EnsureTarget
(
)
;
Matrix
oldTransform
=
mTarget
-
>
GetTransform
(
)
;
if
(
aMaxWidth
.
WasPassed
(
)
&
&
aMaxWidth
.
Value
(
)
>
0
&
&
totalWidth
>
aMaxWidth
.
Value
(
)
)
{
Matrix
newTransform
=
oldTransform
;
newTransform
.
PreTranslate
(
aX
0
)
;
newTransform
.
PreScale
(
aMaxWidth
.
Value
(
)
/
totalWidth
1
)
;
newTransform
.
PreTranslate
(
-
aX
0
)
;
Matrix
androidCompilerBug
=
newTransform
;
mTarget
-
>
SetTransform
(
androidCompilerBug
)
;
}
gfxRect
boundingBox
=
processor
.
mBoundingBox
;
processor
.
mDoMeasureBoundingBox
=
false
;
rv
=
nsBidiPresUtils
:
:
ProcessText
(
textToDraw
.
get
(
)
textToDraw
.
Length
(
)
isRTL
?
NSBIDI_RTL
:
NSBIDI_LTR
presShell
-
>
GetPresContext
(
)
processor
nsBidiPresUtils
:
:
MODE_DRAW
nullptr
0
nullptr
&
bidiEngine
)
;
mTarget
-
>
SetTransform
(
oldTransform
)
;
if
(
aOp
=
=
CanvasRenderingContext2D
:
:
TextDrawOperation
:
:
FILL
&
&
!
doCalculateBounds
)
{
RedrawUser
(
boundingBox
)
;
return
NS_OK
;
}
Redraw
(
)
;
return
NS_OK
;
}
gfxFontGroup
*
CanvasRenderingContext2D
:
:
GetCurrentFontStyle
(
)
{
if
(
!
CurrentState
(
)
.
fontGroup
)
{
ErrorResult
err
;
NS_NAMED_LITERAL_STRING
(
kDefaultFontStyle
"
10px
sans
-
serif
"
)
;
static
float
kDefaultFontSize
=
10
.
0
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
bool
fontUpdated
=
SetFontInternal
(
kDefaultFontStyle
err
)
;
if
(
err
.
Failed
(
)
|
|
!
fontUpdated
)
{
err
.
SuppressException
(
)
;
gfxFontStyle
style
;
style
.
size
=
kDefaultFontSize
;
gfxTextPerfMetrics
*
tp
=
nullptr
;
if
(
presShell
&
&
!
presShell
-
>
IsDestroying
(
)
)
{
tp
=
presShell
-
>
GetPresContext
(
)
-
>
GetTextPerfMetrics
(
)
;
}
int32_t
perDevPixel
perCSSPixel
;
GetAppUnitsValues
(
&
perDevPixel
&
perCSSPixel
)
;
gfxFloat
devToCssSize
=
gfxFloat
(
perDevPixel
)
/
gfxFloat
(
perCSSPixel
)
;
CurrentState
(
)
.
fontGroup
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateFontGroup
(
FontFamilyList
(
eFamily_sans_serif
)
&
style
tp
nullptr
devToCssSize
)
;
if
(
CurrentState
(
)
.
fontGroup
)
{
CurrentState
(
)
.
font
=
kDefaultFontStyle
;
}
else
{
NS_ERROR
(
"
Default
canvas
font
is
invalid
"
)
;
}
}
}
return
CurrentState
(
)
.
fontGroup
;
}
void
CanvasRenderingContext2D
:
:
SetLineCap
(
const
nsAString
&
aLinecapStyle
)
{
CapStyle
cap
;
if
(
aLinecapStyle
.
EqualsLiteral
(
"
butt
"
)
)
{
cap
=
CapStyle
:
:
BUTT
;
}
else
if
(
aLinecapStyle
.
EqualsLiteral
(
"
round
"
)
)
{
cap
=
CapStyle
:
:
ROUND
;
}
else
if
(
aLinecapStyle
.
EqualsLiteral
(
"
square
"
)
)
{
cap
=
CapStyle
:
:
SQUARE
;
}
else
{
return
;
}
CurrentState
(
)
.
lineCap
=
cap
;
}
void
CanvasRenderingContext2D
:
:
GetLineCap
(
nsAString
&
aLinecapStyle
)
{
switch
(
CurrentState
(
)
.
lineCap
)
{
case
CapStyle
:
:
BUTT
:
aLinecapStyle
.
AssignLiteral
(
"
butt
"
)
;
break
;
case
CapStyle
:
:
ROUND
:
aLinecapStyle
.
AssignLiteral
(
"
round
"
)
;
break
;
case
CapStyle
:
:
SQUARE
:
aLinecapStyle
.
AssignLiteral
(
"
square
"
)
;
break
;
}
}
void
CanvasRenderingContext2D
:
:
SetLineJoin
(
const
nsAString
&
aLinejoinStyle
)
{
JoinStyle
j
;
if
(
aLinejoinStyle
.
EqualsLiteral
(
"
round
"
)
)
{
j
=
JoinStyle
:
:
ROUND
;
}
else
if
(
aLinejoinStyle
.
EqualsLiteral
(
"
bevel
"
)
)
{
j
=
JoinStyle
:
:
BEVEL
;
}
else
if
(
aLinejoinStyle
.
EqualsLiteral
(
"
miter
"
)
)
{
j
=
JoinStyle
:
:
MITER_OR_BEVEL
;
}
else
{
return
;
}
CurrentState
(
)
.
lineJoin
=
j
;
}
void
CanvasRenderingContext2D
:
:
GetLineJoin
(
nsAString
&
aLinejoinStyle
ErrorResult
&
aError
)
{
switch
(
CurrentState
(
)
.
lineJoin
)
{
case
JoinStyle
:
:
ROUND
:
aLinejoinStyle
.
AssignLiteral
(
"
round
"
)
;
break
;
case
JoinStyle
:
:
BEVEL
:
aLinejoinStyle
.
AssignLiteral
(
"
bevel
"
)
;
break
;
case
JoinStyle
:
:
MITER_OR_BEVEL
:
aLinejoinStyle
.
AssignLiteral
(
"
miter
"
)
;
break
;
default
:
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
void
CanvasRenderingContext2D
:
:
SetMozDash
(
JSContext
*
aCx
const
JS
:
:
Value
&
aMozDash
ErrorResult
&
aError
)
{
nsTArray
<
Float
>
dash
;
aError
=
JSValToDashArray
(
aCx
aMozDash
dash
)
;
if
(
!
aError
.
Failed
(
)
)
{
ContextState
&
state
=
CurrentState
(
)
;
state
.
dash
=
Move
(
dash
)
;
if
(
state
.
dash
.
IsEmpty
(
)
)
{
state
.
dashOffset
=
0
;
}
}
}
void
CanvasRenderingContext2D
:
:
GetMozDash
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
DashArrayToJSVal
(
CurrentState
(
)
.
dash
aCx
aRetval
aError
)
;
}
void
CanvasRenderingContext2D
:
:
SetMozDashOffset
(
double
aMozDashOffset
)
{
ContextState
&
state
=
CurrentState
(
)
;
if
(
!
state
.
dash
.
IsEmpty
(
)
)
{
state
.
dashOffset
=
aMozDashOffset
;
}
}
void
CanvasRenderingContext2D
:
:
SetLineDash
(
const
Sequence
<
double
>
&
aSegments
ErrorResult
&
aRv
)
{
nsTArray
<
mozilla
:
:
gfx
:
:
Float
>
dash
;
for
(
uint32_t
x
=
0
;
x
<
aSegments
.
Length
(
)
;
x
+
+
)
{
if
(
aSegments
[
x
]
<
0
.
0
)
{
return
;
}
if
(
!
dash
.
AppendElement
(
aSegments
[
x
]
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
}
if
(
aSegments
.
Length
(
)
%
2
)
{
for
(
uint32_t
x
=
0
;
x
<
aSegments
.
Length
(
)
;
x
+
+
)
{
if
(
!
dash
.
AppendElement
(
aSegments
[
x
]
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
}
}
CurrentState
(
)
.
dash
=
Move
(
dash
)
;
}
void
CanvasRenderingContext2D
:
:
GetLineDash
(
nsTArray
<
double
>
&
aSegments
)
const
{
const
nsTArray
<
mozilla
:
:
gfx
:
:
Float
>
&
dash
=
CurrentState
(
)
.
dash
;
aSegments
.
Clear
(
)
;
for
(
uint32_t
x
=
0
;
x
<
dash
.
Length
(
)
;
x
+
+
)
{
aSegments
.
AppendElement
(
dash
[
x
]
)
;
}
}
void
CanvasRenderingContext2D
:
:
SetLineDashOffset
(
double
aOffset
)
{
CurrentState
(
)
.
dashOffset
=
aOffset
;
}
double
CanvasRenderingContext2D
:
:
LineDashOffset
(
)
const
{
return
CurrentState
(
)
.
dashOffset
;
}
bool
CanvasRenderingContext2D
:
:
IsPointInPath
(
double
aX
double
aY
const
CanvasWindingRule
&
aWinding
)
{
if
(
!
FloatValidate
(
aX
aY
)
)
{
return
false
;
}
EnsureUserSpacePath
(
aWinding
)
;
if
(
!
mPath
)
{
return
false
;
}
if
(
mPathTransformWillUpdate
)
{
return
mPath
-
>
ContainsPoint
(
Point
(
aX
aY
)
mPathToDS
)
;
}
return
mPath
-
>
ContainsPoint
(
Point
(
aX
aY
)
mTarget
-
>
GetTransform
(
)
)
;
}
bool
CanvasRenderingContext2D
:
:
IsPointInPath
(
const
CanvasPath
&
aPath
double
aX
double
aY
const
CanvasWindingRule
&
aWinding
)
{
if
(
!
FloatValidate
(
aX
aY
)
)
{
return
false
;
}
EnsureTarget
(
)
;
RefPtr
<
gfx
:
:
Path
>
tempPath
=
aPath
.
GetPath
(
aWinding
mTarget
)
;
return
tempPath
-
>
ContainsPoint
(
Point
(
aX
aY
)
mTarget
-
>
GetTransform
(
)
)
;
}
bool
CanvasRenderingContext2D
:
:
IsPointInStroke
(
double
aX
double
aY
)
{
if
(
!
FloatValidate
(
aX
aY
)
)
{
return
false
;
}
EnsureUserSpacePath
(
)
;
if
(
!
mPath
)
{
return
false
;
}
const
ContextState
&
state
=
CurrentState
(
)
;
StrokeOptions
strokeOptions
(
state
.
lineWidth
state
.
lineJoin
state
.
lineCap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
;
if
(
mPathTransformWillUpdate
)
{
return
mPath
-
>
StrokeContainsPoint
(
strokeOptions
Point
(
aX
aY
)
mPathToDS
)
;
}
return
mPath
-
>
StrokeContainsPoint
(
strokeOptions
Point
(
aX
aY
)
mTarget
-
>
GetTransform
(
)
)
;
}
bool
CanvasRenderingContext2D
:
:
IsPointInStroke
(
const
CanvasPath
&
aPath
double
aX
double
aY
)
{
if
(
!
FloatValidate
(
aX
aY
)
)
{
return
false
;
}
EnsureTarget
(
)
;
RefPtr
<
gfx
:
:
Path
>
tempPath
=
aPath
.
GetPath
(
CanvasWindingRule
:
:
Nonzero
mTarget
)
;
const
ContextState
&
state
=
CurrentState
(
)
;
StrokeOptions
strokeOptions
(
state
.
lineWidth
state
.
lineJoin
state
.
lineCap
state
.
miterLimit
state
.
dash
.
Length
(
)
state
.
dash
.
Elements
(
)
state
.
dashOffset
)
;
return
tempPath
-
>
StrokeContainsPoint
(
strokeOptions
Point
(
aX
aY
)
mTarget
-
>
GetTransform
(
)
)
;
}
static
already_AddRefed
<
SourceSurface
>
ExtractSubrect
(
SourceSurface
*
aSurface
gfx
:
:
Rect
*
aSourceRect
DrawTarget
*
aTargetDT
)
{
gfx
:
:
Rect
roundedOutSourceRect
=
*
aSourceRect
;
roundedOutSourceRect
.
RoundOut
(
)
;
gfx
:
:
IntRect
roundedOutSourceRectInt
;
if
(
!
roundedOutSourceRect
.
ToIntRect
(
&
roundedOutSourceRectInt
)
)
{
RefPtr
<
SourceSurface
>
surface
(
aSurface
)
;
return
surface
.
forget
(
)
;
}
RefPtr
<
DrawTarget
>
subrectDT
=
aTargetDT
-
>
CreateSimilarDrawTarget
(
roundedOutSourceRectInt
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
subrectDT
)
{
RefPtr
<
SourceSurface
>
surface
(
aSurface
)
;
return
surface
.
forget
(
)
;
}
*
aSourceRect
-
=
roundedOutSourceRect
.
TopLeft
(
)
;
subrectDT
-
>
CopySurface
(
aSurface
roundedOutSourceRectInt
IntPoint
(
)
)
;
return
subrectDT
-
>
Snapshot
(
)
;
}
nsLayoutUtils
:
:
SurfaceFromElementResult
CanvasRenderingContext2D
:
:
CachedSurfaceFromElement
(
Element
*
aElement
)
{
nsLayoutUtils
:
:
SurfaceFromElementResult
res
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
aElement
)
;
if
(
!
imageLoader
)
{
return
res
;
}
nsCOMPtr
<
imgIRequest
>
imgRequest
;
imageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgRequest
)
)
;
if
(
!
imgRequest
)
{
return
res
;
}
uint32_t
status
;
if
(
NS_FAILED
(
imgRequest
-
>
GetImageStatus
(
&
status
)
)
|
|
!
(
status
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
)
{
return
res
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
if
(
NS_FAILED
(
imgRequest
-
>
GetImagePrincipal
(
getter_AddRefs
(
principal
)
)
)
|
|
!
principal
)
{
return
res
;
}
res
.
mSourceSurface
=
CanvasImageCache
:
:
SimpleLookup
(
aElement
mIsSkiaGL
)
;
if
(
!
res
.
mSourceSurface
)
{
return
res
;
}
int32_t
corsmode
=
imgIRequest
:
:
CORS_NONE
;
if
(
NS_SUCCEEDED
(
imgRequest
-
>
GetCORSMode
(
&
corsmode
)
)
)
{
res
.
mCORSUsed
=
corsmode
!
=
imgIRequest
:
:
CORS_NONE
;
}
res
.
mSize
=
res
.
mSourceSurface
-
>
GetSize
(
)
;
res
.
mPrincipal
=
principal
.
forget
(
)
;
res
.
mIsWriteOnly
=
false
;
res
.
mImageRequest
=
imgRequest
.
forget
(
)
;
return
res
;
}
static
void
ClipImageDimension
(
double
&
aSourceCoord
double
&
aSourceSize
int32_t
aImageSize
double
&
aDestCoord
double
&
aDestSize
)
{
double
scale
=
aDestSize
/
aSourceSize
;
if
(
aSourceCoord
<
0
.
0
)
{
double
destEnd
=
aDestCoord
+
aDestSize
;
aDestCoord
-
=
aSourceCoord
*
scale
;
aDestSize
=
destEnd
-
aDestCoord
;
aSourceSize
+
=
aSourceCoord
;
aSourceCoord
=
0
.
0
;
}
double
delta
=
aImageSize
-
(
aSourceCoord
+
aSourceSize
)
;
if
(
delta
<
0
.
0
)
{
aDestSize
+
=
delta
*
scale
;
aSourceSize
=
aImageSize
-
aSourceCoord
;
}
}
void
CanvasRenderingContext2D
:
:
DrawImage
(
const
CanvasImageSource
&
aImage
double
aSx
double
aSy
double
aSw
double
aSh
double
aDx
double
aDy
double
aDw
double
aDh
uint8_t
aOptional_argc
ErrorResult
&
aError
)
{
if
(
mDrawObserver
)
{
mDrawObserver
-
>
DidDrawCall
(
CanvasDrawObserver
:
:
DrawCallType
:
:
DrawImage
)
;
}
MOZ_ASSERT
(
aOptional_argc
=
=
0
|
|
aOptional_argc
=
=
2
|
|
aOptional_argc
=
=
6
)
;
if
(
!
ValidateRect
(
aDx
aDy
aDw
aDh
true
)
)
{
return
;
}
if
(
aOptional_argc
=
=
6
)
{
if
(
!
ValidateRect
(
aSx
aSy
aSw
aSh
true
)
)
{
return
;
}
}
RefPtr
<
SourceSurface
>
srcSurf
;
gfx
:
:
IntSize
imgSize
;
Element
*
element
=
nullptr
;
EnsureTarget
(
)
;
if
(
aImage
.
IsHTMLCanvasElement
(
)
)
{
HTMLCanvasElement
*
canvas
=
&
aImage
.
GetAsHTMLCanvasElement
(
)
;
element
=
canvas
;
nsIntSize
size
=
canvas
-
>
GetSize
(
)
;
if
(
size
.
width
=
=
0
|
|
size
.
height
=
=
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
}
else
if
(
aImage
.
IsImageBitmap
(
)
)
{
ImageBitmap
&
imageBitmap
=
aImage
.
GetAsImageBitmap
(
)
;
srcSurf
=
imageBitmap
.
PrepareForDrawTarget
(
mTarget
)
;
if
(
!
srcSurf
)
{
return
;
}
imgSize
=
gfx
:
:
IntSize
(
imageBitmap
.
Width
(
)
imageBitmap
.
Height
(
)
)
;
}
else
{
if
(
aImage
.
IsHTMLImageElement
(
)
)
{
HTMLImageElement
*
img
=
&
aImage
.
GetAsHTMLImageElement
(
)
;
element
=
img
;
}
else
{
HTMLVideoElement
*
video
=
&
aImage
.
GetAsHTMLVideoElement
(
)
;
element
=
video
;
}
srcSurf
=
CanvasImageCache
:
:
Lookup
(
element
mCanvasElement
&
imgSize
mIsSkiaGL
)
;
}
nsLayoutUtils
:
:
DirectDrawInfo
drawInfo
;
#
ifdef
USE_SKIA_GPU
if
(
mRenderingMode
=
=
RenderingMode
:
:
OpenGLBackendMode
&
&
mIsSkiaGL
&
&
!
srcSurf
&
&
aImage
.
IsHTMLVideoElement
(
)
&
&
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
)
{
mozilla
:
:
gl
:
:
GLContext
*
gl
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
-
>
GetGLContext
(
)
;
HTMLVideoElement
*
video
=
&
aImage
.
GetAsHTMLVideoElement
(
)
;
if
(
!
video
)
{
return
;
}
#
ifdef
MOZ_EME
if
(
video
-
>
ContainsRestrictedContent
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
#
endif
uint16_t
readyState
;
if
(
NS_SUCCEEDED
(
video
-
>
GetReadyState
(
&
readyState
)
)
&
&
readyState
<
nsIDOMHTMLMediaElement
:
:
HAVE_CURRENT_DATA
)
{
return
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
video
-
>
GetCurrentPrincipal
(
)
;
if
(
!
principal
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
mozilla
:
:
layers
:
:
ImageContainer
*
container
=
video
-
>
GetImageContainer
(
)
;
if
(
!
container
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
AutoLockImage
lockImage
(
container
)
;
layers
:
:
Image
*
srcImage
=
lockImage
.
GetImage
(
)
;
if
(
!
srcImage
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
gl
-
>
MakeCurrent
(
)
;
if
(
!
mVideoTexture
)
{
gl
-
>
fGenTextures
(
1
&
mVideoTexture
)
;
}
gl
-
>
fActiveTexture
(
LOCAL_GL_TEXTURE0
)
;
gl
-
>
fBindTexture
(
LOCAL_GL_TEXTURE_2D
mVideoTexture
)
;
bool
dimensionsMatch
=
mCurrentVideoSize
.
width
=
=
srcImage
-
>
GetSize
(
)
.
width
&
&
mCurrentVideoSize
.
height
=
=
srcImage
-
>
GetSize
(
)
.
height
;
if
(
!
dimensionsMatch
)
{
mCurrentVideoSize
.
width
=
srcImage
-
>
GetSize
(
)
.
width
;
mCurrentVideoSize
.
height
=
srcImage
-
>
GetSize
(
)
.
height
;
gl
-
>
fTexImage2D
(
LOCAL_GL_TEXTURE_2D
0
LOCAL_GL_RGB
srcImage
-
>
GetSize
(
)
.
width
srcImage
-
>
GetSize
(
)
.
height
0
LOCAL_GL_RGB
LOCAL_GL_UNSIGNED_SHORT_5_6_5
nullptr
)
;
gl
-
>
fTexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_S
LOCAL_GL_CLAMP_TO_EDGE
)
;
gl
-
>
fTexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_WRAP_T
LOCAL_GL_CLAMP_TO_EDGE
)
;
gl
-
>
fTexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MAG_FILTER
LOCAL_GL_LINEAR
)
;
gl
-
>
fTexParameteri
(
LOCAL_GL_TEXTURE_2D
LOCAL_GL_TEXTURE_MIN_FILTER
LOCAL_GL_LINEAR
)
;
}
const
gl
:
:
OriginPos
destOrigin
=
gl
:
:
OriginPos
:
:
TopLeft
;
bool
ok
=
gl
-
>
BlitHelper
(
)
-
>
BlitImageToTexture
(
srcImage
srcImage
-
>
GetSize
(
)
mVideoTexture
LOCAL_GL_TEXTURE_2D
destOrigin
)
;
if
(
ok
)
{
NativeSurface
texSurf
;
texSurf
.
mType
=
NativeSurfaceType
:
:
OPENGL_TEXTURE
;
texSurf
.
mFormat
=
SurfaceFormat
:
:
R5G6B5_UINT16
;
texSurf
.
mSize
.
width
=
mCurrentVideoSize
.
width
;
texSurf
.
mSize
.
height
=
mCurrentVideoSize
.
height
;
texSurf
.
mSurface
=
(
void
*
)
(
(
uintptr_t
)
mVideoTexture
)
;
srcSurf
=
mTarget
-
>
CreateSourceSurfaceFromNativeSurface
(
texSurf
)
;
imgSize
.
width
=
mCurrentVideoSize
.
width
;
imgSize
.
height
=
mCurrentVideoSize
.
height
;
int32_t
displayWidth
=
video
-
>
VideoWidth
(
)
;
int32_t
displayHeight
=
video
-
>
VideoHeight
(
)
;
aSw
*
=
(
double
)
imgSize
.
width
/
(
double
)
displayWidth
;
aSh
*
=
(
double
)
imgSize
.
height
/
(
double
)
displayHeight
;
}
srcImage
=
nullptr
;
if
(
mCanvasElement
)
{
CanvasUtils
:
:
DoDrawImageSecurityCheck
(
mCanvasElement
principal
false
video
-
>
GetCORSMode
(
)
!
=
CORS_NONE
)
;
}
}
#
endif
if
(
!
srcSurf
)
{
uint32_t
sfeFlags
=
nsLayoutUtils
:
:
SFE_WANT_FIRST_FRAME
|
nsLayoutUtils
:
:
SFE_NO_RASTERIZING_VECTORS
;
nsLayoutUtils
:
:
SurfaceFromElementResult
res
=
CachedSurfaceFromElement
(
element
)
;
if
(
!
res
.
mSourceSurface
)
res
=
nsLayoutUtils
:
:
SurfaceFromElement
(
element
sfeFlags
mTarget
)
;
if
(
!
res
.
mSourceSurface
&
&
!
res
.
mDrawInfo
.
mImgContainer
)
{
if
(
!
res
.
mIsStillLoading
&
&
!
res
.
mHasSize
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
}
return
;
}
imgSize
=
res
.
mSize
;
if
(
aImage
.
IsHTMLVideoElement
(
)
)
{
HTMLVideoElement
*
video
=
&
aImage
.
GetAsHTMLVideoElement
(
)
;
int32_t
displayWidth
=
video
-
>
VideoWidth
(
)
;
int32_t
displayHeight
=
video
-
>
VideoHeight
(
)
;
aSw
*
=
(
double
)
imgSize
.
width
/
(
double
)
displayWidth
;
aSh
*
=
(
double
)
imgSize
.
height
/
(
double
)
displayHeight
;
}
if
(
mCanvasElement
)
{
CanvasUtils
:
:
DoDrawImageSecurityCheck
(
mCanvasElement
res
.
mPrincipal
res
.
mIsWriteOnly
res
.
mCORSUsed
)
;
}
if
(
res
.
mSourceSurface
)
{
if
(
res
.
mImageRequest
)
{
CanvasImageCache
:
:
NotifyDrawImage
(
element
mCanvasElement
res
.
mImageRequest
res
.
mSourceSurface
imgSize
mIsSkiaGL
)
;
}
srcSurf
=
res
.
mSourceSurface
;
}
else
{
drawInfo
=
res
.
mDrawInfo
;
}
}
if
(
aOptional_argc
=
=
0
)
{
aSx
=
aSy
=
0
.
0
;
aDw
=
aSw
=
(
double
)
imgSize
.
width
;
aDh
=
aSh
=
(
double
)
imgSize
.
height
;
}
else
if
(
aOptional_argc
=
=
2
)
{
aSx
=
aSy
=
0
.
0
;
aSw
=
(
double
)
imgSize
.
width
;
aSh
=
(
double
)
imgSize
.
height
;
}
if
(
aSw
=
=
0
.
0
|
|
aSh
=
=
0
.
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
ClipImageDimension
(
aSx
aSw
imgSize
.
width
aDx
aDw
)
;
ClipImageDimension
(
aSy
aSh
imgSize
.
height
aDy
aDh
)
;
if
(
aSw
<
=
0
.
0
|
|
aSh
<
=
0
.
0
|
|
aDw
<
=
0
.
0
|
|
aDh
<
=
0
.
0
)
{
return
;
}
Filter
filter
;
if
(
CurrentState
(
)
.
imageSmoothingEnabled
)
filter
=
gfx
:
:
Filter
:
:
LINEAR
;
else
filter
=
gfx
:
:
Filter
:
:
POINT
;
gfx
:
:
Rect
bounds
;
if
(
NeedToCalculateBounds
(
)
)
{
bounds
=
gfx
:
:
Rect
(
aDx
aDy
aDw
aDh
)
;
bounds
=
mTarget
-
>
GetTransform
(
)
.
TransformBounds
(
bounds
)
;
}
if
(
srcSurf
)
{
gfx
:
:
Rect
sourceRect
(
aSx
aSy
aSw
aSh
)
;
if
(
element
=
=
mCanvasElement
)
{
srcSurf
=
ExtractSubrect
(
srcSurf
&
sourceRect
mTarget
)
;
}
AdjustedTarget
(
this
bounds
.
IsEmpty
(
)
?
nullptr
:
&
bounds
)
-
>
DrawSurface
(
srcSurf
gfx
:
:
Rect
(
aDx
aDy
aDw
aDh
)
sourceRect
DrawSurfaceOptions
(
filter
)
DrawOptions
(
CurrentState
(
)
.
globalAlpha
UsedOperation
(
)
)
)
;
}
else
{
DrawDirectlyToCanvas
(
drawInfo
&
bounds
gfx
:
:
Rect
(
aDx
aDy
aDw
aDh
)
gfx
:
:
Rect
(
aSx
aSy
aSw
aSh
)
imgSize
)
;
}
RedrawUser
(
gfxRect
(
aDx
aDy
aDw
aDh
)
)
;
}
void
CanvasRenderingContext2D
:
:
DrawDirectlyToCanvas
(
const
nsLayoutUtils
:
:
DirectDrawInfo
&
aImage
gfx
:
:
Rect
*
aBounds
gfx
:
:
Rect
aDest
gfx
:
:
Rect
aSrc
gfx
:
:
IntSize
aImgSize
)
{
MOZ_ASSERT
(
aSrc
.
width
>
0
&
&
aSrc
.
height
>
0
"
Need
positive
source
width
and
height
"
)
;
gfxMatrix
contextMatrix
;
AdjustedTarget
tempTarget
(
this
aBounds
-
>
IsEmpty
(
)
?
nullptr
:
aBounds
)
;
if
(
tempTarget
)
{
Matrix
matrix
=
tempTarget
-
>
GetTransform
(
)
;
contextMatrix
=
gfxMatrix
(
matrix
.
_11
matrix
.
_12
matrix
.
_21
matrix
.
_22
matrix
.
_31
matrix
.
_32
)
;
}
gfxSize
contextScale
(
contextMatrix
.
ScaleFactors
(
true
)
)
;
aDest
.
Scale
(
contextScale
.
width
contextScale
.
height
)
;
gfxSize
scale
(
aDest
.
width
/
aSrc
.
width
aDest
.
height
/
aSrc
.
height
)
;
nsIntSize
scaledImageSize
(
std
:
:
ceil
(
aImgSize
.
width
*
scale
.
width
)
std
:
:
ceil
(
aImgSize
.
height
*
scale
.
height
)
)
;
aSrc
.
Scale
(
scale
.
width
scale
.
height
)
;
AutoRestoreTransform
autoRestoreTransform
(
mTarget
)
;
RefPtr
<
gfxContext
>
context
=
new
gfxContext
(
tempTarget
)
;
context
-
>
SetMatrix
(
contextMatrix
.
Scale
(
1
.
0
/
contextScale
.
width
1
.
0
/
contextScale
.
height
)
.
Translate
(
aDest
.
x
-
aSrc
.
x
aDest
.
y
-
aSrc
.
y
)
)
;
uint32_t
modifiedFlags
=
aImage
.
mDrawingFlags
|
imgIContainer
:
:
FLAG_CLAMP
;
CSSIntSize
sz
(
scaledImageSize
.
width
scaledImageSize
.
height
)
;
SVGImageContext
svgContext
(
sz
Nothing
(
)
CurrentState
(
)
.
globalAlpha
)
;
auto
result
=
aImage
.
mImgContainer
-
>
Draw
(
context
scaledImageSize
ImageRegion
:
:
Create
(
gfxRect
(
aSrc
.
x
aSrc
.
y
aSrc
.
width
aSrc
.
height
)
)
aImage
.
mWhichFrame
Filter
:
:
GOOD
Some
(
svgContext
)
modifiedFlags
)
;
if
(
result
!
=
DrawResult
:
:
SUCCESS
)
{
NS_WARNING
(
"
imgIContainer
:
:
Draw
failed
"
)
;
}
}
void
CanvasRenderingContext2D
:
:
SetGlobalCompositeOperation
(
const
nsAString
&
aOp
ErrorResult
&
aError
)
{
CompositionOp
comp_op
;
#
define
CANVAS_OP_TO_GFX_OP
(
cvsop
op2d
)
\
if
(
aOp
.
EqualsLiteral
(
cvsop
)
)
\
comp_op
=
CompositionOp
:
:
OP_
#
#
op2d
;
CANVAS_OP_TO_GFX_OP
(
"
copy
"
SOURCE
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
atop
"
ATOP
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
in
"
IN
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
out
"
OUT
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
over
"
OVER
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
in
"
DEST_IN
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
out
"
DEST_OUT
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
over
"
DEST_OVER
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
atop
"
DEST_ATOP
)
else
CANVAS_OP_TO_GFX_OP
(
"
lighter
"
ADD
)
else
CANVAS_OP_TO_GFX_OP
(
"
xor
"
XOR
)
else
CANVAS_OP_TO_GFX_OP
(
"
multiply
"
MULTIPLY
)
else
CANVAS_OP_TO_GFX_OP
(
"
screen
"
SCREEN
)
else
CANVAS_OP_TO_GFX_OP
(
"
overlay
"
OVERLAY
)
else
CANVAS_OP_TO_GFX_OP
(
"
darken
"
DARKEN
)
else
CANVAS_OP_TO_GFX_OP
(
"
lighten
"
LIGHTEN
)
else
CANVAS_OP_TO_GFX_OP
(
"
color
-
dodge
"
COLOR_DODGE
)
else
CANVAS_OP_TO_GFX_OP
(
"
color
-
burn
"
COLOR_BURN
)
else
CANVAS_OP_TO_GFX_OP
(
"
hard
-
light
"
HARD_LIGHT
)
else
CANVAS_OP_TO_GFX_OP
(
"
soft
-
light
"
SOFT_LIGHT
)
else
CANVAS_OP_TO_GFX_OP
(
"
difference
"
DIFFERENCE
)
else
CANVAS_OP_TO_GFX_OP
(
"
exclusion
"
EXCLUSION
)
else
CANVAS_OP_TO_GFX_OP
(
"
hue
"
HUE
)
else
CANVAS_OP_TO_GFX_OP
(
"
saturation
"
SATURATION
)
else
CANVAS_OP_TO_GFX_OP
(
"
color
"
COLOR
)
else
CANVAS_OP_TO_GFX_OP
(
"
luminosity
"
LUMINOSITY
)
else
return
;
#
undef
CANVAS_OP_TO_GFX_OP
CurrentState
(
)
.
op
=
comp_op
;
}
void
CanvasRenderingContext2D
:
:
GetGlobalCompositeOperation
(
nsAString
&
aOp
ErrorResult
&
aError
)
{
CompositionOp
comp_op
=
CurrentState
(
)
.
op
;
#
define
CANVAS_OP_TO_GFX_OP
(
cvsop
op2d
)
\
if
(
comp_op
=
=
CompositionOp
:
:
OP_
#
#
op2d
)
\
aOp
.
AssignLiteral
(
cvsop
)
;
CANVAS_OP_TO_GFX_OP
(
"
copy
"
SOURCE
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
atop
"
DEST_ATOP
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
in
"
DEST_IN
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
out
"
DEST_OUT
)
else
CANVAS_OP_TO_GFX_OP
(
"
destination
-
over
"
DEST_OVER
)
else
CANVAS_OP_TO_GFX_OP
(
"
lighter
"
ADD
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
atop
"
ATOP
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
in
"
IN
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
out
"
OUT
)
else
CANVAS_OP_TO_GFX_OP
(
"
source
-
over
"
OVER
)
else
CANVAS_OP_TO_GFX_OP
(
"
xor
"
XOR
)
else
CANVAS_OP_TO_GFX_OP
(
"
multiply
"
MULTIPLY
)
else
CANVAS_OP_TO_GFX_OP
(
"
screen
"
SCREEN
)
else
CANVAS_OP_TO_GFX_OP
(
"
overlay
"
OVERLAY
)
else
CANVAS_OP_TO_GFX_OP
(
"
darken
"
DARKEN
)
else
CANVAS_OP_TO_GFX_OP
(
"
lighten
"
LIGHTEN
)
else
CANVAS_OP_TO_GFX_OP
(
"
color
-
dodge
"
COLOR_DODGE
)
else
CANVAS_OP_TO_GFX_OP
(
"
color
-
burn
"
COLOR_BURN
)
else
CANVAS_OP_TO_GFX_OP
(
"
hard
-
light
"
HARD_LIGHT
)
else
CANVAS_OP_TO_GFX_OP
(
"
soft
-
light
"
SOFT_LIGHT
)
else
CANVAS_OP_TO_GFX_OP
(
"
difference
"
DIFFERENCE
)
else
CANVAS_OP_TO_GFX_OP
(
"
exclusion
"
EXCLUSION
)
else
CANVAS_OP_TO_GFX_OP
(
"
hue
"
HUE
)
else
CANVAS_OP_TO_GFX_OP
(
"
saturation
"
SATURATION
)
else
CANVAS_OP_TO_GFX_OP
(
"
color
"
COLOR
)
else
CANVAS_OP_TO_GFX_OP
(
"
luminosity
"
LUMINOSITY
)
else
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
}
#
undef
CANVAS_OP_TO_GFX_OP
}
void
CanvasRenderingContext2D
:
:
DrawWindow
(
nsGlobalWindow
&
aWindow
double
aX
double
aY
double
aW
double
aH
const
nsAString
&
aBgColor
uint32_t
aFlags
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
aWindow
.
IsInnerWindow
(
)
)
;
if
(
!
gfxASurface
:
:
CheckSurfaceSize
(
gfx
:
:
IntSize
(
int32_t
(
aW
)
int32_t
(
aH
)
)
0xffff
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
EnsureTarget
(
)
;
if
(
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
!
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_DO_NOT_FLUSH
)
)
{
nsContentUtils
:
:
FlushLayoutForTree
(
aWindow
.
AsInner
(
)
-
>
GetOuterWindow
(
)
)
;
}
RefPtr
<
nsPresContext
>
presContext
;
nsIDocShell
*
docshell
=
aWindow
.
GetDocShell
(
)
;
if
(
docshell
)
{
docshell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
}
if
(
!
presContext
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nscolor
backgroundColor
;
if
(
!
ParseColor
(
aBgColor
&
backgroundColor
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsRect
r
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
aX
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
aY
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
aW
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
float
)
aH
)
)
;
uint32_t
renderDocFlags
=
(
nsIPresShell
:
:
RENDER_IGNORE_VIEWPORT_SCROLLING
|
nsIPresShell
:
:
RENDER_DOCUMENT_RELATIVE
)
;
if
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_DRAW_CARET
)
{
renderDocFlags
|
=
nsIPresShell
:
:
RENDER_CARET
;
}
if
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_DRAW_VIEW
)
{
renderDocFlags
&
=
~
(
nsIPresShell
:
:
RENDER_IGNORE_VIEWPORT_SCROLLING
|
nsIPresShell
:
:
RENDER_DOCUMENT_RELATIVE
)
;
}
if
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_USE_WIDGET_LAYERS
)
{
renderDocFlags
|
=
nsIPresShell
:
:
RENDER_USE_WIDGET_LAYERS
;
}
if
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_ASYNC_DECODE_IMAGES
)
{
renderDocFlags
|
=
nsIPresShell
:
:
RENDER_ASYNC_DECODE_IMAGES
;
}
if
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_DO_NOT_FLUSH
)
{
renderDocFlags
|
=
nsIPresShell
:
:
RENDER_DRAWWINDOW_NOT_FLUSHING
;
}
Matrix
matrix
=
mTarget
-
>
GetTransform
(
)
;
double
sw
=
matrix
.
_11
*
aW
;
double
sh
=
matrix
.
_22
*
aH
;
if
(
!
sw
|
|
!
sh
)
{
return
;
}
RefPtr
<
gfxContext
>
thebes
;
RefPtr
<
DrawTarget
>
drawDT
;
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
SupportsAzureContentForDrawTarget
(
mTarget
)
&
&
GlobalAlpha
(
)
=
=
1
.
0f
&
&
UsedOperation
(
)
=
=
CompositionOp
:
:
OP_OVER
)
{
thebes
=
new
gfxContext
(
mTarget
)
;
thebes
-
>
SetMatrix
(
gfxMatrix
(
matrix
.
_11
matrix
.
_12
matrix
.
_21
matrix
.
_22
matrix
.
_31
matrix
.
_32
)
)
;
}
else
{
drawDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
ceil
(
sw
)
ceil
(
sh
)
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
drawDT
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
thebes
=
new
gfxContext
(
drawDT
)
;
thebes
-
>
SetMatrix
(
gfxMatrix
:
:
Scaling
(
matrix
.
_11
matrix
.
_22
)
)
;
}
nsCOMPtr
<
nsIPresShell
>
shell
=
presContext
-
>
PresShell
(
)
;
Unused
<
<
shell
-
>
RenderDocument
(
r
renderDocFlags
backgroundColor
thebes
)
;
if
(
drawDT
)
{
RefPtr
<
SourceSurface
>
snapshot
=
drawDT
-
>
Snapshot
(
)
;
RefPtr
<
DataSourceSurface
>
data
=
snapshot
-
>
GetDataSurface
(
)
;
DataSourceSurface
:
:
MappedSurface
rawData
;
if
(
NS_WARN_IF
(
!
data
-
>
Map
(
DataSourceSurface
:
:
READ
&
rawData
)
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
SourceSurface
>
source
=
mTarget
-
>
CreateSourceSurfaceFromData
(
rawData
.
mData
data
-
>
GetSize
(
)
rawData
.
mStride
data
-
>
GetFormat
(
)
)
;
data
-
>
Unmap
(
)
;
if
(
!
source
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
gfx
:
:
Rect
destRect
(
0
0
aW
aH
)
;
gfx
:
:
Rect
sourceRect
(
0
0
sw
sh
)
;
mTarget
-
>
DrawSurface
(
source
destRect
sourceRect
DrawSurfaceOptions
(
gfx
:
:
Filter
:
:
POINT
)
DrawOptions
(
GlobalAlpha
(
)
UsedOperation
(
)
AntialiasMode
:
:
NONE
)
)
;
mTarget
-
>
Flush
(
)
;
}
else
{
mTarget
-
>
SetTransform
(
matrix
)
;
}
RedrawUser
(
gfxRect
(
0
0
aW
aH
)
)
;
}
void
CanvasRenderingContext2D
:
:
AsyncDrawXULElement
(
nsXULElement
&
aElem
double
aX
double
aY
double
aW
double
aH
const
nsAString
&
aBgColor
uint32_t
aFlags
ErrorResult
&
aError
)
{
if
(
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
#
if
0
nsCOMPtr
<
nsIFrameLoaderOwner
>
loaderOwner
=
do_QueryInterface
(
&
elem
)
;
if
(
!
loaderOwner
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
nsFrameLoader
>
frameloader
=
loaderOwner
-
>
GetFrameLoader
(
)
;
if
(
!
frameloader
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
PBrowserParent
*
child
=
frameloader
-
>
GetRemoteBrowser
(
)
;
if
(
!
child
)
{
nsIDocShell
*
docShell
=
frameLoader
-
>
GetExistingDocShell
(
)
;
if
(
!
docShell
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
docShell
-
>
GetWindow
(
)
;
if
(
!
window
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
return
DrawWindow
(
window
-
>
GetCurrentInnerWindow
(
)
aX
aY
aW
aH
aBgColor
aFlags
)
;
}
if
(
!
gfxASurface
:
:
CheckSurfaceSize
(
gfx
:
:
IntSize
(
aW
aH
)
0xffff
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
bool
flush
=
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_DO_NOT_FLUSH
)
=
=
0
;
uint32_t
renderDocFlags
=
nsIPresShell
:
:
RENDER_IGNORE_VIEWPORT_SCROLLING
;
if
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_DRAW_CARET
)
{
renderDocFlags
|
=
nsIPresShell
:
:
RENDER_CARET
;
}
if
(
aFlags
&
nsIDOMCanvasRenderingContext2D
:
:
DRAWWINDOW_DRAW_VIEW
)
{
renderDocFlags
&
=
~
nsIPresShell
:
:
RENDER_IGNORE_VIEWPORT_SCROLLING
;
}
nsRect
rect
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aX
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aY
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aW
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aH
)
)
;
if
(
mIPC
)
{
PDocumentRendererParent
*
pdocrender
=
child
-
>
SendPDocumentRendererConstructor
(
rect
mThebes
-
>
CurrentMatrix
(
)
nsString
(
aBGColor
)
renderDocFlags
flush
nsIntSize
(
mWidth
mHeight
)
)
;
if
(
!
pdocrender
)
return
NS_ERROR_FAILURE
;
DocumentRendererParent
*
docrender
=
static_cast
<
DocumentRendererParent
*
>
(
pdocrender
)
;
docrender
-
>
SetCanvasContext
(
this
mThebes
)
;
}
#
endif
}
void
CanvasRenderingContext2D
:
:
DrawWidgetAsOnScreen
(
nsGlobalWindow
&
aWindow
mozilla
:
:
ErrorResult
&
aError
)
{
EnsureTarget
(
)
;
if
(
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
RefPtr
<
nsPresContext
>
presContext
;
nsIDocShell
*
docshell
=
aWindow
.
GetDocShell
(
)
;
if
(
docshell
)
{
docshell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
}
if
(
!
presContext
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIWidget
*
widget
=
presContext
-
>
GetRootWidget
(
)
;
if
(
!
widget
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
RefPtr
<
SourceSurface
>
snapshot
=
widget
-
>
SnapshotWidgetOnScreen
(
)
;
if
(
!
snapshot
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
gfx
:
:
Rect
sourceRect
(
gfx
:
:
Point
(
0
0
)
gfx
:
:
Size
(
snapshot
-
>
GetSize
(
)
)
)
;
mTarget
-
>
DrawSurface
(
snapshot
sourceRect
sourceRect
DrawSurfaceOptions
(
gfx
:
:
Filter
:
:
POINT
)
DrawOptions
(
GlobalAlpha
(
)
CompositionOp
:
:
OP_OVER
AntialiasMode
:
:
NONE
)
)
;
mTarget
-
>
Flush
(
)
;
RedrawUser
(
gfxRect
(
0
0
std
:
:
min
(
mWidth
snapshot
-
>
GetSize
(
)
.
width
)
std
:
:
min
(
mHeight
snapshot
-
>
GetSize
(
)
.
height
)
)
)
;
}
already_AddRefed
<
ImageData
>
CanvasRenderingContext2D
:
:
GetImageData
(
JSContext
*
aCx
double
aSx
double
aSy
double
aSw
double
aSh
ErrorResult
&
aError
)
{
if
(
mDrawObserver
)
{
mDrawObserver
-
>
DidDrawCall
(
CanvasDrawObserver
:
:
DrawCallType
:
:
GetImageData
)
;
}
EnsureTarget
(
)
;
if
(
!
IsTargetValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
mCanvasElement
&
&
!
mDocShell
)
{
NS_ERROR
(
"
No
canvas
element
and
no
docshell
in
GetImageData
!
!
!
"
)
;
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
if
(
mCanvasElement
&
&
mCanvasElement
-
>
IsWriteOnly
(
)
&
&
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
if
(
!
IsFinite
(
aSx
)
|
|
!
IsFinite
(
aSy
)
|
|
!
IsFinite
(
aSw
)
|
|
!
IsFinite
(
aSh
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
!
aSw
|
|
!
aSh
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
int32_t
x
=
JS
:
:
ToInt32
(
aSx
)
;
int32_t
y
=
JS
:
:
ToInt32
(
aSy
)
;
int32_t
wi
=
JS
:
:
ToInt32
(
aSw
)
;
int32_t
hi
=
JS
:
:
ToInt32
(
aSh
)
;
uint32_t
w
h
;
if
(
aSw
<
0
)
{
w
=
-
wi
;
x
-
=
w
;
}
else
{
w
=
wi
;
}
if
(
aSh
<
0
)
{
h
=
-
hi
;
y
-
=
h
;
}
else
{
h
=
hi
;
}
if
(
w
=
=
0
)
{
w
=
1
;
}
if
(
h
=
=
0
)
{
h
=
1
;
}
JS
:
:
Rooted
<
JSObject
*
>
array
(
aCx
)
;
aError
=
GetImageDataArray
(
aCx
x
y
w
h
array
.
address
(
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
array
)
;
RefPtr
<
ImageData
>
imageData
=
new
ImageData
(
w
h
*
array
)
;
return
imageData
.
forget
(
)
;
}
nsresult
CanvasRenderingContext2D
:
:
GetImageDataArray
(
JSContext
*
aCx
int32_t
aX
int32_t
aY
uint32_t
aWidth
uint32_t
aHeight
JSObject
*
*
aRetval
)
{
if
(
mDrawObserver
)
{
mDrawObserver
-
>
DidDrawCall
(
CanvasDrawObserver
:
:
DrawCallType
:
:
GetImageData
)
;
}
MOZ_ASSERT
(
aWidth
&
&
aHeight
)
;
CheckedInt
<
uint32_t
>
len
=
CheckedInt
<
uint32_t
>
(
aWidth
)
*
aHeight
*
4
;
if
(
!
len
.
isValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
CheckedInt
<
int32_t
>
rightMost
=
CheckedInt
<
int32_t
>
(
aX
)
+
aWidth
;
CheckedInt
<
int32_t
>
bottomMost
=
CheckedInt
<
int32_t
>
(
aY
)
+
aHeight
;
if
(
!
rightMost
.
isValid
(
)
|
|
!
bottomMost
.
isValid
(
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
JS
:
:
Rooted
<
JSObject
*
>
darray
(
aCx
JS_NewUint8ClampedArray
(
aCx
len
.
value
(
)
)
)
;
if
(
!
darray
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mZero
)
{
*
aRetval
=
darray
;
return
NS_OK
;
}
IntRect
srcRect
(
0
0
mWidth
mHeight
)
;
IntRect
destRect
(
aX
aY
aWidth
aHeight
)
;
IntRect
srcReadRect
=
srcRect
.
Intersect
(
destRect
)
;
RefPtr
<
DataSourceSurface
>
readback
;
DataSourceSurface
:
:
MappedSurface
rawData
;
if
(
!
srcReadRect
.
IsEmpty
(
)
)
{
RefPtr
<
SourceSurface
>
snapshot
=
mTarget
-
>
Snapshot
(
)
;
if
(
snapshot
)
{
readback
=
snapshot
-
>
GetDataSurface
(
)
;
}
if
(
!
readback
|
|
!
readback
-
>
Map
(
DataSourceSurface
:
:
READ
&
rawData
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
IntRect
dstWriteRect
=
srcReadRect
;
dstWriteRect
.
MoveBy
(
-
aX
-
aY
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
bool
isShared
;
uint8_t
*
data
=
JS_GetUint8ClampedArrayData
(
darray
&
isShared
nogc
)
;
MOZ_ASSERT
(
!
isShared
)
;
uint8_t
*
src
;
uint32_t
srcStride
;
if
(
readback
)
{
srcStride
=
rawData
.
mStride
;
src
=
rawData
.
mData
+
srcReadRect
.
y
*
srcStride
+
srcReadRect
.
x
*
4
;
}
else
{
src
=
data
;
srcStride
=
aWidth
*
4
;
}
uint8_t
*
dst
=
data
+
dstWriteRect
.
y
*
(
aWidth
*
4
)
+
dstWriteRect
.
x
*
4
;
if
(
mOpaque
)
{
for
(
int32_t
j
=
0
;
j
<
dstWriteRect
.
height
;
+
+
j
)
{
for
(
int32_t
i
=
0
;
i
<
dstWriteRect
.
width
;
+
+
i
)
{
#
if
MOZ_LITTLE_ENDIAN
uint8_t
b
=
*
src
+
+
;
uint8_t
g
=
*
src
+
+
;
uint8_t
r
=
*
src
+
+
;
src
+
+
;
#
else
src
+
+
;
uint8_t
r
=
*
src
+
+
;
uint8_t
g
=
*
src
+
+
;
uint8_t
b
=
*
src
+
+
;
#
endif
*
dst
+
+
=
r
;
*
dst
+
+
=
g
;
*
dst
+
+
=
b
;
*
dst
+
+
=
255
;
}
src
+
=
srcStride
-
(
dstWriteRect
.
width
*
4
)
;
dst
+
=
(
aWidth
*
4
)
-
(
dstWriteRect
.
width
*
4
)
;
}
}
else
for
(
int32_t
j
=
0
;
j
<
dstWriteRect
.
height
;
+
+
j
)
{
for
(
int32_t
i
=
0
;
i
<
dstWriteRect
.
width
;
+
+
i
)
{
#
if
MOZ_LITTLE_ENDIAN
uint8_t
b
=
*
src
+
+
;
uint8_t
g
=
*
src
+
+
;
uint8_t
r
=
*
src
+
+
;
uint8_t
a
=
*
src
+
+
;
#
else
uint8_t
a
=
*
src
+
+
;
uint8_t
r
=
*
src
+
+
;
uint8_t
g
=
*
src
+
+
;
uint8_t
b
=
*
src
+
+
;
#
endif
*
dst
+
+
=
gfxUtils
:
:
sUnpremultiplyTable
[
a
*
256
+
r
]
;
*
dst
+
+
=
gfxUtils
:
:
sUnpremultiplyTable
[
a
*
256
+
g
]
;
*
dst
+
+
=
gfxUtils
:
:
sUnpremultiplyTable
[
a
*
256
+
b
]
;
*
dst
+
+
=
a
;
}
src
+
=
srcStride
-
(
dstWriteRect
.
width
*
4
)
;
dst
+
=
(
aWidth
*
4
)
-
(
dstWriteRect
.
width
*
4
)
;
}
if
(
readback
)
{
readback
-
>
Unmap
(
)
;
}
*
aRetval
=
darray
;
return
NS_OK
;
}
void
CanvasRenderingContext2D
:
:
EnsureErrorTarget
(
)
{
if
(
sErrorTarget
)
{
return
;
}
RefPtr
<
DrawTarget
>
errorTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenCanvasDrawTarget
(
IntSize
(
1
1
)
SurfaceFormat
:
:
B8G8R8A8
)
;
MOZ_ASSERT
(
errorTarget
"
Failed
to
allocate
the
error
target
!
"
)
;
sErrorTarget
=
errorTarget
;
NS_ADDREF
(
sErrorTarget
)
;
}
void
CanvasRenderingContext2D
:
:
FillRuleChanged
(
)
{
if
(
mPath
)
{
mPathBuilder
=
mPath
-
>
CopyToBuilder
(
CurrentState
(
)
.
fillRule
)
;
mPath
=
nullptr
;
}
}
void
CanvasRenderingContext2D
:
:
PutImageData
(
ImageData
&
aImageData
double
aDx
double
aDy
ErrorResult
&
aError
)
{
dom
:
:
Uint8ClampedArray
arr
;
DebugOnly
<
bool
>
inited
=
arr
.
Init
(
aImageData
.
GetDataObject
(
)
)
;
MOZ_ASSERT
(
inited
)
;
aError
=
PutImageData_explicit
(
JS
:
:
ToInt32
(
aDx
)
JS
:
:
ToInt32
(
aDy
)
aImageData
.
Width
(
)
aImageData
.
Height
(
)
&
arr
false
0
0
0
0
)
;
}
void
CanvasRenderingContext2D
:
:
PutImageData
(
ImageData
&
aImageData
double
aDx
double
aDy
double
aDirtyX
double
aDirtyY
double
aDirtyWidth
double
aDirtyHeight
ErrorResult
&
aError
)
{
dom
:
:
Uint8ClampedArray
arr
;
DebugOnly
<
bool
>
inited
=
arr
.
Init
(
aImageData
.
GetDataObject
(
)
)
;
MOZ_ASSERT
(
inited
)
;
aError
=
PutImageData_explicit
(
JS
:
:
ToInt32
(
aDx
)
JS
:
:
ToInt32
(
aDy
)
aImageData
.
Width
(
)
aImageData
.
Height
(
)
&
arr
true
JS
:
:
ToInt32
(
aDirtyX
)
JS
:
:
ToInt32
(
aDirtyY
)
JS
:
:
ToInt32
(
aDirtyWidth
)
JS
:
:
ToInt32
(
aDirtyHeight
)
)
;
}
nsresult
CanvasRenderingContext2D
:
:
PutImageData_explicit
(
int32_t
aX
int32_t
aY
uint32_t
aW
uint32_t
aH
dom
:
:
Uint8ClampedArray
*
aArray
bool
aHasDirtyRect
int32_t
aDirtyX
int32_t
aDirtyY
int32_t
aDirtyWidth
int32_t
aDirtyHeight
)
{
EnsureTarget
(
)
;
if
(
mDrawObserver
)
{
mDrawObserver
-
>
DidDrawCall
(
CanvasDrawObserver
:
:
DrawCallType
:
:
PutImageData
)
;
}
if
(
aW
=
=
0
|
|
aH
=
=
0
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
IntRect
dirtyRect
;
IntRect
imageDataRect
(
0
0
aW
aH
)
;
if
(
aHasDirtyRect
)
{
if
(
aDirtyWidth
<
0
)
{
NS_ENSURE_TRUE
(
aDirtyWidth
!
=
INT_MIN
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
CheckedInt32
checkedDirtyX
=
CheckedInt32
(
aDirtyX
)
+
aDirtyWidth
;
if
(
!
checkedDirtyX
.
isValid
(
)
)
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
aDirtyX
=
checkedDirtyX
.
value
(
)
;
aDirtyWidth
=
-
aDirtyWidth
;
}
if
(
aDirtyHeight
<
0
)
{
NS_ENSURE_TRUE
(
aDirtyHeight
!
=
INT_MIN
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
CheckedInt32
checkedDirtyY
=
CheckedInt32
(
aDirtyY
)
+
aDirtyHeight
;
if
(
!
checkedDirtyY
.
isValid
(
)
)
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
aDirtyY
=
checkedDirtyY
.
value
(
)
;
aDirtyHeight
=
-
aDirtyHeight
;
}
dirtyRect
=
imageDataRect
.
Intersect
(
IntRect
(
aDirtyX
aDirtyY
aDirtyWidth
aDirtyHeight
)
)
;
if
(
dirtyRect
.
Width
(
)
<
=
0
|
|
dirtyRect
.
Height
(
)
<
=
0
)
return
NS_OK
;
}
else
{
dirtyRect
=
imageDataRect
;
}
dirtyRect
.
MoveBy
(
IntPoint
(
aX
aY
)
)
;
dirtyRect
=
IntRect
(
0
0
mWidth
mHeight
)
.
Intersect
(
dirtyRect
)
;
if
(
dirtyRect
.
Width
(
)
<
=
0
|
|
dirtyRect
.
Height
(
)
<
=
0
)
{
return
NS_OK
;
}
aArray
-
>
ComputeLengthAndData
(
)
;
uint32_t
dataLen
=
aArray
-
>
Length
(
)
;
uint32_t
len
=
aW
*
aH
*
4
;
if
(
dataLen
!
=
len
)
{
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
uint32_t
copyWidth
=
dirtyRect
.
Width
(
)
;
uint32_t
copyHeight
=
dirtyRect
.
Height
(
)
;
RefPtr
<
gfxImageSurface
>
imgsurf
=
new
gfxImageSurface
(
gfx
:
:
IntSize
(
copyWidth
copyHeight
)
SurfaceFormat
:
:
A8R8G8B8_UINT32
false
)
;
if
(
!
imgsurf
|
|
imgsurf
-
>
CairoStatus
(
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
copyX
=
dirtyRect
.
x
-
aX
;
uint32_t
copyY
=
dirtyRect
.
y
-
aY
;
uint8_t
*
dst
=
imgsurf
-
>
Data
(
)
;
uint8_t
*
srcLine
=
aArray
-
>
Data
(
)
+
copyY
*
(
aW
*
4
)
+
copyX
*
4
;
#
if
0
printf
(
"
PutImageData_explicit
:
dirty
x
=
%
d
y
=
%
d
w
=
%
d
h
=
%
d
copy
x
=
%
d
y
=
%
d
w
=
%
d
h
=
%
d
ext
x
=
%
d
y
=
%
d
w
=
%
d
h
=
%
d
\
n
"
dirtyRect
.
x
dirtyRect
.
y
copyWidth
copyHeight
copyX
copyY
copyWidth
copyHeight
x
y
w
h
)
;
#
endif
for
(
uint32_t
j
=
0
;
j
<
copyHeight
;
j
+
+
)
{
uint8_t
*
src
=
srcLine
;
for
(
uint32_t
i
=
0
;
i
<
copyWidth
;
i
+
+
)
{
uint8_t
r
=
*
src
+
+
;
uint8_t
g
=
*
src
+
+
;
uint8_t
b
=
*
src
+
+
;
uint8_t
a
=
*
src
+
+
;
#
if
MOZ_LITTLE_ENDIAN
*
dst
+
+
=
gfxUtils
:
:
sPremultiplyTable
[
a
*
256
+
b
]
;
*
dst
+
+
=
gfxUtils
:
:
sPremultiplyTable
[
a
*
256
+
g
]
;
*
dst
+
+
=
gfxUtils
:
:
sPremultiplyTable
[
a
*
256
+
r
]
;
*
dst
+
+
=
a
;
#
else
*
dst
+
+
=
a
;
*
dst
+
+
=
gfxUtils
:
:
sPremultiplyTable
[
a
*
256
+
r
]
;
*
dst
+
+
=
gfxUtils
:
:
sPremultiplyTable
[
a
*
256
+
g
]
;
*
dst
+
+
=
gfxUtils
:
:
sPremultiplyTable
[
a
*
256
+
b
]
;
#
endif
}
srcLine
+
=
aW
*
4
;
}
EnsureTarget
(
)
;
if
(
!
IsTargetValid
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
SourceSurface
>
sourceSurface
=
mTarget
-
>
CreateSourceSurfaceFromData
(
imgsurf
-
>
Data
(
)
IntSize
(
copyWidth
copyHeight
)
imgsurf
-
>
Stride
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
sourceSurface
)
{
return
NS_ERROR_FAILURE
;
}
mTarget
-
>
CopySurface
(
sourceSurface
IntRect
(
0
0
dirtyRect
.
width
dirtyRect
.
height
)
IntPoint
(
dirtyRect
.
x
dirtyRect
.
y
)
)
;
Redraw
(
gfx
:
:
Rect
(
dirtyRect
.
x
dirtyRect
.
y
dirtyRect
.
width
dirtyRect
.
height
)
)
;
return
NS_OK
;
}
static
already_AddRefed
<
ImageData
>
CreateImageData
(
JSContext
*
aCx
CanvasRenderingContext2D
*
aContext
uint32_t
aW
uint32_t
aH
ErrorResult
&
aError
)
{
if
(
aW
=
=
0
)
aW
=
1
;
if
(
aH
=
=
0
)
aH
=
1
;
CheckedInt
<
uint32_t
>
len
=
CheckedInt
<
uint32_t
>
(
aW
)
*
aH
*
4
;
if
(
!
len
.
isValid
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
JSObject
*
darray
=
Uint8ClampedArray
:
:
Create
(
aCx
aContext
len
.
value
(
)
)
;
if
(
!
darray
)
{
aError
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
dom
:
:
ImageData
>
imageData
=
new
mozilla
:
:
dom
:
:
ImageData
(
aW
aH
*
darray
)
;
return
imageData
.
forget
(
)
;
}
already_AddRefed
<
ImageData
>
CanvasRenderingContext2D
:
:
CreateImageData
(
JSContext
*
aCx
double
aSw
double
aSh
ErrorResult
&
aError
)
{
if
(
!
aSw
|
|
!
aSh
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
int32_t
wi
=
JS
:
:
ToInt32
(
aSw
)
;
int32_t
hi
=
JS
:
:
ToInt32
(
aSh
)
;
uint32_t
w
=
Abs
(
wi
)
;
uint32_t
h
=
Abs
(
hi
)
;
return
mozilla
:
:
dom
:
:
CreateImageData
(
aCx
this
w
h
aError
)
;
}
already_AddRefed
<
ImageData
>
CanvasRenderingContext2D
:
:
CreateImageData
(
JSContext
*
aCx
ImageData
&
aImagedata
ErrorResult
&
aError
)
{
return
mozilla
:
:
dom
:
:
CreateImageData
(
aCx
this
aImagedata
.
Width
(
)
aImagedata
.
Height
(
)
aError
)
;
}
static
uint8_t
g2DContextLayerUserData
;
uint32_t
CanvasRenderingContext2D
:
:
SkiaGLTex
(
)
const
{
if
(
!
mTarget
)
{
return
0
;
}
MOZ_ASSERT
(
IsTargetValid
(
)
)
;
return
(
uint32_t
)
(
uintptr_t
)
mTarget
-
>
GetNativeSurface
(
NativeSurfaceType
:
:
OPENGL_TEXTURE
)
;
}
void
CanvasRenderingContext2D
:
:
RemoveDrawObserver
(
)
{
if
(
mDrawObserver
)
{
delete
mDrawObserver
;
mDrawObserver
=
nullptr
;
}
}
PersistentBufferProvider
*
CanvasRenderingContext2D
:
:
GetBufferProvider
(
LayerManager
*
aManager
)
{
if
(
mBufferProvider
)
{
return
mBufferProvider
;
}
if
(
!
mTarget
)
{
return
nullptr
;
}
mBufferProvider
=
new
PersistentBufferProviderBasic
(
mTarget
)
;
return
mBufferProvider
;
}
already_AddRefed
<
Layer
>
CanvasRenderingContext2D
:
:
GetCanvasLayer
(
nsDisplayListBuilder
*
aBuilder
Layer
*
aOldLayer
LayerManager
*
aManager
)
{
if
(
mOpaque
|
|
mIsSkiaGL
)
{
EnsureTarget
(
)
;
}
if
(
(
!
mBufferProvider
&
&
!
mTarget
)
|
|
!
IsTargetValid
(
)
)
{
MarkContextClean
(
)
;
return
nullptr
;
}
if
(
!
mResetLayer
&
&
aOldLayer
)
{
CanvasRenderingContext2DUserData
*
userData
=
static_cast
<
CanvasRenderingContext2DUserData
*
>
(
aOldLayer
-
>
GetUserData
(
&
g2DContextLayerUserData
)
)
;
CanvasLayer
:
:
Data
data
;
GLuint
skiaGLTex
=
SkiaGLTex
(
)
;
if
(
skiaGLTex
)
{
SkiaGLGlue
*
glue
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
;
MOZ_ASSERT
(
glue
)
;
data
.
mGLContext
=
glue
-
>
GetGLContext
(
)
;
data
.
mFrontbufferGLTex
=
skiaGLTex
;
PersistentBufferProvider
*
provider
=
GetBufferProvider
(
aManager
)
;
data
.
mBufferProvider
=
provider
;
}
else
{
PersistentBufferProvider
*
provider
=
GetBufferProvider
(
aManager
)
;
data
.
mBufferProvider
=
provider
;
}
if
(
userData
&
&
userData
-
>
IsForContext
(
this
)
&
&
static_cast
<
CanvasLayer
*
>
(
aOldLayer
)
-
>
IsDataValid
(
data
)
)
{
RefPtr
<
Layer
>
ret
=
aOldLayer
;
return
ret
.
forget
(
)
;
}
}
RefPtr
<
CanvasLayer
>
canvasLayer
=
aManager
-
>
CreateCanvasLayer
(
)
;
if
(
!
canvasLayer
)
{
NS_WARNING
(
"
CreateCanvasLayer
returned
null
!
"
)
;
MarkContextClean
(
)
;
return
nullptr
;
}
CanvasRenderingContext2DUserData
*
userData
=
nullptr
;
userData
=
new
CanvasRenderingContext2DUserData
(
this
)
;
canvasLayer
-
>
SetDidTransactionCallback
(
CanvasRenderingContext2DUserData
:
:
DidTransactionCallback
userData
)
;
canvasLayer
-
>
SetUserData
(
&
g2DContextLayerUserData
userData
)
;
CanvasLayer
:
:
Data
data
;
data
.
mSize
=
nsIntSize
(
mWidth
mHeight
)
;
data
.
mHasAlpha
=
!
mOpaque
;
canvasLayer
-
>
SetPreTransactionCallback
(
CanvasRenderingContext2DUserData
:
:
PreTransactionCallback
userData
)
;
GLuint
skiaGLTex
=
SkiaGLTex
(
)
;
if
(
skiaGLTex
)
{
SkiaGLGlue
*
glue
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetSkiaGLGlue
(
)
;
MOZ_ASSERT
(
glue
)
;
data
.
mGLContext
=
glue
-
>
GetGLContext
(
)
;
data
.
mFrontbufferGLTex
=
skiaGLTex
;
PersistentBufferProvider
*
provider
=
GetBufferProvider
(
aManager
)
;
data
.
mBufferProvider
=
provider
;
}
else
{
PersistentBufferProvider
*
provider
=
GetBufferProvider
(
aManager
)
;
data
.
mBufferProvider
=
provider
;
}
canvasLayer
-
>
Initialize
(
data
)
;
uint32_t
flags
=
mOpaque
?
Layer
:
:
CONTENT_OPAQUE
:
0
;
canvasLayer
-
>
SetContentFlags
(
flags
)
;
canvasLayer
-
>
Updated
(
)
;
mResetLayer
=
false
;
return
canvasLayer
.
forget
(
)
;
}
void
CanvasRenderingContext2D
:
:
MarkContextClean
(
)
{
if
(
mInvalidateCount
>
0
)
{
mPredictManyRedrawCalls
=
mInvalidateCount
>
kCanvasMaxInvalidateCount
;
}
mIsEntireFrameInvalid
=
false
;
mInvalidateCount
=
0
;
}
void
CanvasRenderingContext2D
:
:
MarkContextCleanForFrameCapture
(
)
{
mIsCapturedFrameInvalid
=
false
;
}
bool
CanvasRenderingContext2D
:
:
IsContextCleanForFrameCapture
(
)
{
return
!
mIsCapturedFrameInvalid
;
}
bool
CanvasRenderingContext2D
:
:
ShouldForceInactiveLayer
(
LayerManager
*
aManager
)
{
return
!
aManager
-
>
CanUseCanvasLayerForSize
(
IntSize
(
mWidth
mHeight
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
CanvasPath
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
CanvasPath
Release
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
CanvasPath
mParent
)
CanvasPath
:
:
CanvasPath
(
nsISupports
*
aParent
)
:
mParent
(
aParent
)
{
mPathBuilder
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
-
>
CreatePathBuilder
(
)
;
}
CanvasPath
:
:
CanvasPath
(
nsISupports
*
aParent
already_AddRefed
<
PathBuilder
>
aPathBuilder
)
:
mParent
(
aParent
)
mPathBuilder
(
aPathBuilder
)
{
if
(
!
mPathBuilder
)
{
mPathBuilder
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
-
>
CreatePathBuilder
(
)
;
}
}
JSObject
*
CanvasPath
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Path2DBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
already_AddRefed
<
CanvasPath
>
CanvasPath
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
{
RefPtr
<
CanvasPath
>
path
=
new
CanvasPath
(
aGlobal
.
GetAsSupports
(
)
)
;
return
path
.
forget
(
)
;
}
already_AddRefed
<
CanvasPath
>
CanvasPath
:
:
Constructor
(
const
GlobalObject
&
aGlobal
CanvasPath
&
aCanvasPath
ErrorResult
&
aRv
)
{
RefPtr
<
gfx
:
:
Path
>
tempPath
=
aCanvasPath
.
GetPath
(
CanvasWindingRule
:
:
Nonzero
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
)
;
RefPtr
<
CanvasPath
>
path
=
new
CanvasPath
(
aGlobal
.
GetAsSupports
(
)
tempPath
-
>
CopyToBuilder
(
)
)
;
return
path
.
forget
(
)
;
}
already_AddRefed
<
CanvasPath
>
CanvasPath
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aPathString
ErrorResult
&
aRv
)
{
RefPtr
<
gfx
:
:
Path
>
tempPath
=
SVGContentUtils
:
:
GetPath
(
aPathString
)
;
if
(
!
tempPath
)
{
return
Constructor
(
aGlobal
aRv
)
;
}
RefPtr
<
CanvasPath
>
path
=
new
CanvasPath
(
aGlobal
.
GetAsSupports
(
)
tempPath
-
>
CopyToBuilder
(
)
)
;
return
path
.
forget
(
)
;
}
void
CanvasPath
:
:
ClosePath
(
)
{
EnsurePathBuilder
(
)
;
mPathBuilder
-
>
Close
(
)
;
}
void
CanvasPath
:
:
MoveTo
(
double
aX
double
aY
)
{
EnsurePathBuilder
(
)
;
mPathBuilder
-
>
MoveTo
(
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
void
CanvasPath
:
:
LineTo
(
double
aX
double
aY
)
{
EnsurePathBuilder
(
)
;
mPathBuilder
-
>
LineTo
(
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
void
CanvasPath
:
:
QuadraticCurveTo
(
double
aCpx
double
aCpy
double
aX
double
aY
)
{
EnsurePathBuilder
(
)
;
mPathBuilder
-
>
QuadraticBezierTo
(
gfx
:
:
Point
(
ToFloat
(
aCpx
)
ToFloat
(
aCpy
)
)
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
void
CanvasPath
:
:
BezierCurveTo
(
double
aCp1x
double
aCp1y
double
aCp2x
double
aCp2y
double
aX
double
aY
)
{
BezierTo
(
gfx
:
:
Point
(
ToFloat
(
aCp1x
)
ToFloat
(
aCp1y
)
)
gfx
:
:
Point
(
ToFloat
(
aCp2x
)
ToFloat
(
aCp2y
)
)
gfx
:
:
Point
(
ToFloat
(
aX
)
ToFloat
(
aY
)
)
)
;
}
void
CanvasPath
:
:
ArcTo
(
double
aX1
double
aY1
double
aX2
double
aY2
double
aRadius
ErrorResult
&
aError
)
{
if
(
aRadius
<
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
EnsurePathBuilder
(
)
;
Point
p0
=
mPathBuilder
-
>
CurrentPoint
(
)
;
Point
p1
(
aX1
aY1
)
;
Point
p2
(
aX2
aY2
)
;
double
dir
a2
b2
c2
cosx
sinx
d
anx
any
bnx
bny
x3
y3
x4
y4
cx
cy
angle0
angle1
;
bool
anticlockwise
;
if
(
p0
=
=
p1
|
|
p1
=
=
p2
|
|
aRadius
=
=
0
)
{
LineTo
(
p1
.
x
p1
.
y
)
;
return
;
}
dir
=
(
p2
.
x
-
p1
.
x
)
*
(
p0
.
y
-
p1
.
y
)
+
(
p2
.
y
-
p1
.
y
)
*
(
p1
.
x
-
p0
.
x
)
;
if
(
dir
=
=
0
)
{
LineTo
(
p1
.
x
p1
.
y
)
;
return
;
}
a2
=
(
p0
.
x
-
aX1
)
*
(
p0
.
x
-
aX1
)
+
(
p0
.
y
-
aY1
)
*
(
p0
.
y
-
aY1
)
;
b2
=
(
aX1
-
aX2
)
*
(
aX1
-
aX2
)
+
(
aY1
-
aY2
)
*
(
aY1
-
aY2
)
;
c2
=
(
p0
.
x
-
aX2
)
*
(
p0
.
x
-
aX2
)
+
(
p0
.
y
-
aY2
)
*
(
p0
.
y
-
aY2
)
;
cosx
=
(
a2
+
b2
-
c2
)
/
(
2
*
sqrt
(
a2
*
b2
)
)
;
sinx
=
sqrt
(
1
-
cosx
*
cosx
)
;
d
=
aRadius
/
(
(
1
-
cosx
)
/
sinx
)
;
anx
=
(
aX1
-
p0
.
x
)
/
sqrt
(
a2
)
;
any
=
(
aY1
-
p0
.
y
)
/
sqrt
(
a2
)
;
bnx
=
(
aX1
-
aX2
)
/
sqrt
(
b2
)
;
bny
=
(
aY1
-
aY2
)
/
sqrt
(
b2
)
;
x3
=
aX1
-
anx
*
d
;
y3
=
aY1
-
any
*
d
;
x4
=
aX1
-
bnx
*
d
;
y4
=
aY1
-
bny
*
d
;
anticlockwise
=
(
dir
<
0
)
;
cx
=
x3
+
any
*
aRadius
*
(
anticlockwise
?
1
:
-
1
)
;
cy
=
y3
-
anx
*
aRadius
*
(
anticlockwise
?
1
:
-
1
)
;
angle0
=
atan2
(
(
y3
-
cy
)
(
x3
-
cx
)
)
;
angle1
=
atan2
(
(
y4
-
cy
)
(
x4
-
cx
)
)
;
LineTo
(
x3
y3
)
;
Arc
(
cx
cy
aRadius
angle0
angle1
anticlockwise
aError
)
;
}
void
CanvasPath
:
:
Rect
(
double
aX
double
aY
double
aW
double
aH
)
{
MoveTo
(
aX
aY
)
;
LineTo
(
aX
+
aW
aY
)
;
LineTo
(
aX
+
aW
aY
+
aH
)
;
LineTo
(
aX
aY
+
aH
)
;
ClosePath
(
)
;
}
void
CanvasPath
:
:
Arc
(
double
aX
double
aY
double
aRadius
double
aStartAngle
double
aEndAngle
bool
aAnticlockwise
ErrorResult
&
aError
)
{
if
(
aRadius
<
0
.
0
)
{
aError
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
EnsurePathBuilder
(
)
;
ArcToBezier
(
this
Point
(
aX
aY
)
Size
(
aRadius
aRadius
)
aStartAngle
aEndAngle
aAnticlockwise
)
;
}
void
CanvasPath
:
:
LineTo
(
const
gfx
:
:
Point
&
aPoint
)
{
EnsurePathBuilder
(
)
;
mPathBuilder
-
>
LineTo
(
aPoint
)
;
}
void
CanvasPath
:
:
BezierTo
(
const
gfx
:
:
Point
&
aCP1
const
gfx
:
:
Point
&
aCP2
const
gfx
:
:
Point
&
aCP3
)
{
EnsurePathBuilder
(
)
;
mPathBuilder
-
>
BezierTo
(
aCP1
aCP2
aCP3
)
;
}
void
CanvasPath
:
:
AddPath
(
CanvasPath
&
aCanvasPath
const
Optional
<
NonNull
<
SVGMatrix
>
>
&
aMatrix
)
{
RefPtr
<
gfx
:
:
Path
>
tempPath
=
aCanvasPath
.
GetPath
(
CanvasWindingRule
:
:
Nonzero
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
)
;
if
(
aMatrix
.
WasPassed
(
)
)
{
const
SVGMatrix
&
m
=
aMatrix
.
Value
(
)
;
Matrix
transform
(
m
.
A
(
)
m
.
B
(
)
m
.
C
(
)
m
.
D
(
)
m
.
E
(
)
m
.
F
(
)
)
;
if
(
!
transform
.
IsIdentity
(
)
)
{
RefPtr
<
PathBuilder
>
tempBuilder
=
tempPath
-
>
TransformedCopyToBuilder
(
transform
FillRule
:
:
FILL_WINDING
)
;
tempPath
=
tempBuilder
-
>
Finish
(
)
;
}
}
EnsurePathBuilder
(
)
;
tempPath
-
>
StreamToSink
(
mPathBuilder
)
;
}
already_AddRefed
<
gfx
:
:
Path
>
CanvasPath
:
:
GetPath
(
const
CanvasWindingRule
&
aWinding
const
DrawTarget
*
aTarget
)
const
{
FillRule
fillRule
=
FillRule
:
:
FILL_WINDING
;
if
(
aWinding
=
=
CanvasWindingRule
:
:
Evenodd
)
{
fillRule
=
FillRule
:
:
FILL_EVEN_ODD
;
}
if
(
mPath
&
&
(
mPath
-
>
GetBackendType
(
)
=
=
aTarget
-
>
GetBackendType
(
)
)
&
&
(
mPath
-
>
GetFillRule
(
)
=
=
fillRule
)
)
{
RefPtr
<
gfx
:
:
Path
>
path
(
mPath
)
;
return
path
.
forget
(
)
;
}
if
(
!
mPath
)
{
MOZ_ASSERT
(
mPathBuilder
)
;
mPath
=
mPathBuilder
-
>
Finish
(
)
;
if
(
!
mPath
)
{
RefPtr
<
gfx
:
:
Path
>
path
(
mPath
)
;
return
path
.
forget
(
)
;
}
mPathBuilder
=
nullptr
;
}
if
(
mPath
-
>
GetBackendType
(
)
!
=
aTarget
-
>
GetBackendType
(
)
)
{
RefPtr
<
PathBuilder
>
tmpPathBuilder
=
aTarget
-
>
CreatePathBuilder
(
fillRule
)
;
mPath
-
>
StreamToSink
(
tmpPathBuilder
)
;
mPath
=
tmpPathBuilder
-
>
Finish
(
)
;
}
else
if
(
mPath
-
>
GetFillRule
(
)
!
=
fillRule
)
{
RefPtr
<
PathBuilder
>
tmpPathBuilder
=
mPath
-
>
CopyToBuilder
(
fillRule
)
;
mPath
=
tmpPathBuilder
-
>
Finish
(
)
;
}
RefPtr
<
gfx
:
:
Path
>
path
(
mPath
)
;
return
path
.
forget
(
)
;
}
void
CanvasPath
:
:
EnsurePathBuilder
(
)
const
{
if
(
mPathBuilder
)
{
return
;
}
MOZ_ASSERT
(
mPath
)
;
mPathBuilder
=
mPath
-
>
CopyToBuilder
(
)
;
mPath
=
nullptr
;
}
}
}
