#
ifndef
mozilla_dom_ImageBitmap_h
#
define
mozilla_dom_ImageBitmap_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapSource
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
struct
JSContext
;
struct
JSStructuredCloneReader
;
struct
JSStructuredCloneWriter
;
class
nsIGlobalObject
;
namespace
mozilla
{
class
ErrorResult
;
namespace
gfx
{
class
DataSourceSurface
;
class
DrawTarget
;
class
SourceSurface
;
}
namespace
layers
{
class
Image
;
}
namespace
dom
{
class
OffscreenCanvas
;
class
ArrayBufferViewOrArrayBuffer
;
class
CanvasRenderingContext2D
;
struct
ChannelPixelLayout
;
class
CreateImageBitmapFromBlob
;
class
CreateImageBitmapFromBlobTask
;
class
CreateImageBitmapFromBlobWorkerTask
;
class
File
;
class
HTMLCanvasElement
;
class
HTMLImageElement
;
class
HTMLVideoElement
;
enum
class
ImageBitmapFormat
:
uint8_t
;
class
ImageData
;
class
ImageUtils
;
template
<
typename
T
>
class
MapDataIntoBufferSource
;
class
Promise
;
class
PostMessageEvent
;
class
ImageBitmapShutdownObserver
;
struct
ImageBitmapCloneData
final
{
RefPtr
<
gfx
:
:
DataSourceSurface
>
mSurface
;
gfx
:
:
IntRect
mPictureRect
;
gfxAlphaType
mAlphaType
;
bool
mIsCroppingAreaOutSideOfSourceImage
;
}
;
class
ImageBitmap
final
:
public
nsISupports
public
nsWrapperCache
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ImageBitmap
)
nsCOMPtr
<
nsIGlobalObject
>
GetParentObject
(
)
const
{
return
mParent
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
uint32_t
Width
(
)
const
{
return
mPictureRect
.
Width
(
)
;
}
uint32_t
Height
(
)
const
{
return
mPictureRect
.
Height
(
)
;
}
void
Close
(
)
;
already_AddRefed
<
gfx
:
:
SourceSurface
>
PrepareForDrawTarget
(
gfx
:
:
DrawTarget
*
aTarget
)
;
already_AddRefed
<
layers
:
:
Image
>
TransferAsImage
(
)
;
UniquePtr
<
ImageBitmapCloneData
>
ToCloneData
(
)
const
;
static
already_AddRefed
<
ImageBitmap
>
CreateFromCloneData
(
nsIGlobalObject
*
aGlobal
ImageBitmapCloneData
*
aData
)
;
static
already_AddRefed
<
ImageBitmap
>
CreateFromOffscreenCanvas
(
nsIGlobalObject
*
aGlobal
OffscreenCanvas
&
aOffscreenCanvas
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
Create
(
nsIGlobalObject
*
aGlobal
const
ImageBitmapSource
&
aSrc
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
Promise
>
Create
(
nsIGlobalObject
*
aGlobal
const
ImageBitmapSource
&
aBuffer
int32_t
aOffset
int32_t
aLength
mozilla
:
:
dom
:
:
ImageBitmapFormat
aFormat
const
Sequence
<
mozilla
:
:
dom
:
:
ChannelPixelLayout
>
&
aLayout
ErrorResult
&
aRv
)
;
static
JSObject
*
ReadStructuredClone
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
nsIGlobalObject
*
aParent
const
nsTArray
<
RefPtr
<
gfx
:
:
DataSourceSurface
>
>
&
aClonedSurfaces
uint32_t
aIndex
)
;
static
bool
WriteStructuredClone
(
JSStructuredCloneWriter
*
aWriter
nsTArray
<
RefPtr
<
gfx
:
:
DataSourceSurface
>
>
&
aClonedSurfaces
ImageBitmap
*
aImageBitmap
)
;
friend
CreateImageBitmapFromBlob
;
friend
CreateImageBitmapFromBlobTask
;
friend
CreateImageBitmapFromBlobWorkerTask
;
template
<
typename
T
>
friend
class
MapDataIntoBufferSource
;
ImageBitmapFormat
FindOptimalFormat
(
const
Optional
<
Sequence
<
ImageBitmapFormat
>
>
&
aPossibleFormats
ErrorResult
&
aRv
)
;
int32_t
MappedDataLength
(
ImageBitmapFormat
aFormat
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
MapDataInto
(
JSContext
*
aCx
ImageBitmapFormat
aFormat
const
ArrayBufferViewOrArrayBuffer
&
aBuffer
int32_t
aOffset
ErrorResult
&
aRv
)
;
size_t
GetAllocatedSize
(
)
const
;
void
OnShutdown
(
)
;
protected
:
ImageBitmap
(
nsIGlobalObject
*
aGlobal
layers
:
:
Image
*
aData
gfxAlphaType
aAlphaType
=
gfxAlphaType
:
:
Premult
)
;
virtual
~
ImageBitmap
(
)
;
void
SetPictureRect
(
const
gfx
:
:
IntRect
&
aRect
ErrorResult
&
aRv
)
;
void
SetIsCroppingAreaOutSideOfSourceImage
(
const
gfx
:
:
IntSize
&
aSourceSize
const
Maybe
<
gfx
:
:
IntRect
>
&
aCroppingRect
)
;
static
already_AddRefed
<
ImageBitmap
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
HTMLImageElement
&
aImageEl
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
ImageBitmap
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
HTMLVideoElement
&
aVideoEl
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
ImageBitmap
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
HTMLCanvasElement
&
aCanvasEl
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
ImageBitmap
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
ImageData
&
aImageData
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
ImageBitmap
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
CanvasRenderingContext2D
&
aCanvasCtx
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
ImageBitmap
>
CreateInternal
(
nsIGlobalObject
*
aGlobal
ImageBitmap
&
aImageBitmap
const
Maybe
<
gfx
:
:
IntRect
>
&
aCropRect
ErrorResult
&
aRv
)
;
nsCOMPtr
<
nsIGlobalObject
>
mParent
;
RefPtr
<
layers
:
:
Image
>
mData
;
RefPtr
<
gfx
:
:
SourceSurface
>
mSurface
;
UniquePtr
<
ImageUtils
>
mDataWrapper
;
gfx
:
:
IntRect
mPictureRect
;
const
gfxAlphaType
mAlphaType
;
RefPtr
<
ImageBitmapShutdownObserver
>
mShutdownObserver
;
bool
mIsCroppingAreaOutSideOfSourceImage
;
bool
mAllocatedImageData
;
}
;
}
}
#
endif
