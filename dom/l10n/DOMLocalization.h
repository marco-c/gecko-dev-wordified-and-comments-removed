#
ifndef
mozilla_dom_l10n_DOMLocalization_h
#
define
mozilla_dom_l10n_DOMLocalization_h
#
include
"
nsXULPrototypeDocument
.
h
"
#
include
"
mozilla
/
intl
/
Localization
.
h
"
#
include
"
mozilla
/
dom
/
DOMLocalizationBinding
.
h
"
#
include
"
mozilla
/
dom
/
L10nMutations
.
h
"
#
include
"
mozilla
/
dom
/
L10nOverlaysBinding
.
h
"
#
include
"
mozilla
/
dom
/
LocalizationBinding
.
h
"
#
include
"
nsINode
.
h
"
namespace
mozilla
{
namespace
dom
{
class
Element
;
class
L10nMutations
;
class
DOMLocalization
:
public
intl
:
:
Localization
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
DOMLocalization
Localization
)
static
already_AddRefed
<
DOMLocalization
>
Create
(
nsIGlobalObject
*
aGlobal
const
bool
aSync
const
BundleGenerator
&
aBundleGenerator
)
;
void
Destroy
(
)
;
static
already_AddRefed
<
DOMLocalization
>
Constructor
(
const
GlobalObject
&
aGlobal
const
Sequence
<
nsString
>
&
aResourceIds
const
bool
aSync
const
BundleGenerator
&
aBundleGenerator
ErrorResult
&
aRv
)
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
ConnectRoot
(
nsINode
&
aNode
ErrorResult
&
aRv
)
;
void
DisconnectRoot
(
nsINode
&
aNode
ErrorResult
&
aRv
)
;
void
PauseObserving
(
ErrorResult
&
aRv
)
;
void
ResumeObserving
(
ErrorResult
&
aRv
)
;
void
SetAttributes
(
JSContext
*
aCx
Element
&
aElement
const
nsAString
&
aId
const
Optional
<
JS
:
:
Handle
<
JSObject
*
>
>
&
aArgs
ErrorResult
&
aRv
)
;
void
GetAttributes
(
Element
&
aElement
L10nIdArgs
&
aResult
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
TranslateFragment
(
nsINode
&
aNode
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
TranslateElements
(
const
Sequence
<
OwningNonNull
<
Element
>
>
&
aElements
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
TranslateElements
(
const
Sequence
<
OwningNonNull
<
Element
>
>
&
aElements
nsXULPrototypeDocument
*
aProto
ErrorResult
&
aRv
)
;
already_AddRefed
<
Promise
>
TranslateRoots
(
ErrorResult
&
aRv
)
;
static
void
GetTranslatables
(
nsINode
&
aNode
Sequence
<
OwningNonNull
<
Element
>
>
&
aElements
ErrorResult
&
aRv
)
;
static
void
SetRootInfo
(
Element
*
aElement
)
;
bool
ApplyTranslations
(
nsTArray
<
nsCOMPtr
<
Element
>
>
&
aElements
nsTArray
<
Nullable
<
L10nMessage
>
>
&
aTranslations
nsXULPrototypeDocument
*
aProto
ErrorResult
&
aRv
)
;
bool
SubtreeRootInRoots
(
nsINode
*
aSubtreeRoot
)
{
for
(
auto
iter
=
mRoots
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsINode
*
subtreeRoot
=
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
SubtreeRoot
(
)
;
if
(
subtreeRoot
=
=
aSubtreeRoot
)
{
return
true
;
}
}
return
false
;
}
protected
:
explicit
DOMLocalization
(
nsIGlobalObject
*
aGlobal
const
bool
aSync
const
BundleGenerator
&
aBundleGenerator
)
;
virtual
~
DOMLocalization
(
)
;
void
OnChange
(
)
override
;
void
DisconnectMutations
(
)
;
void
DisconnectRoots
(
)
;
void
ReportL10nOverlaysErrors
(
nsTArray
<
L10nOverlaysError
>
&
aErrors
)
;
void
ConvertStringToL10nArgs
(
const
nsString
&
aInput
intl
:
:
L10nArgs
&
aRetVal
ErrorResult
&
aRv
)
;
RefPtr
<
L10nMutations
>
mMutations
;
nsTHashtable
<
nsRefPtrHashKey
<
nsINode
>
>
mRoots
;
}
;
}
}
#
endif
