#
include
"
CryptoBuffer
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
dom
/
BufferSourceBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
secitem
.
h
"
namespace
mozilla
:
:
dom
{
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
CryptoBuffer
&
aData
)
{
return
ReplaceElementsAt
(
0
Length
(
)
aData
.
Elements
(
)
aData
.
Length
(
)
fallible
)
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
uint8_t
*
aData
uint32_t
aLength
)
{
return
ReplaceElementsAt
(
0
Length
(
)
aData
aLength
fallible
)
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
nsACString
&
aString
)
{
return
Assign
(
reinterpret_cast
<
uint8_t
const
*
>
(
aString
.
BeginReading
(
)
)
aString
.
Length
(
)
)
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
SECItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
)
;
return
Assign
(
aItem
-
>
data
aItem
-
>
len
)
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
nsTArray
<
uint8_t
>
&
aData
)
{
return
ReplaceElementsAt
(
0
Length
(
)
aData
.
Elements
(
)
aData
.
Length
(
)
fallible
)
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
ArrayBuffer
&
aData
)
{
Clear
(
)
;
return
aData
.
AppendDataTo
(
*
this
)
?
Elements
(
)
:
nullptr
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
ArrayBufferView
&
aData
)
{
Clear
(
)
;
return
aData
.
AppendDataTo
(
*
this
)
?
Elements
(
)
:
nullptr
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
BufferSource
&
aData
)
{
Clear
(
)
;
return
AppendTypedArrayDataTo
(
aData
*
this
)
?
Elements
(
)
:
nullptr
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
OwningBufferSource
&
aData
)
{
Clear
(
)
;
return
AppendTypedArrayDataTo
(
aData
*
this
)
?
Elements
(
)
:
nullptr
;
}
uint8_t
*
CryptoBuffer
:
:
Assign
(
const
Uint8Array
&
aArray
)
{
Clear
(
)
;
return
aArray
.
AppendDataTo
(
*
this
)
?
Elements
(
)
:
nullptr
;
}
uint8_t
*
CryptoBuffer
:
:
AppendSECItem
(
const
SECItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
)
;
return
AppendElements
(
aItem
-
>
data
aItem
-
>
len
fallible
)
;
}
uint8_t
*
CryptoBuffer
:
:
AppendSECItem
(
const
SECItem
&
aItem
)
{
return
AppendElements
(
aItem
.
data
aItem
.
len
fallible
)
;
}
nsresult
CryptoBuffer
:
:
FromJwkBase64
(
const
nsString
&
aBase64
)
{
NS_ConvertUTF16toUTF8
temp
(
aBase64
)
;
temp
.
StripWhitespace
(
)
;
nsresult
rv
=
Base64URLDecode
(
temp
Base64URLDecodePaddingPolicy
:
:
Reject
*
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
CryptoBuffer
:
:
ToJwkBase64
(
nsString
&
aBase64
)
const
{
if
(
Length
(
)
=
=
0
)
{
aBase64
.
Truncate
(
)
;
return
NS_OK
;
}
nsAutoCString
base64
;
nsresult
rv
=
Base64URLEncode
(
Length
(
)
Elements
(
)
Base64URLEncodePaddingPolicy
:
:
Omit
base64
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyASCIItoUTF16
(
base64
aBase64
)
;
return
NS_OK
;
}
bool
CryptoBuffer
:
:
ToSECItem
(
PLArenaPool
*
aArena
SECItem
*
aItem
)
const
{
aItem
-
>
type
=
siBuffer
;
aItem
-
>
data
=
nullptr
;
if
(
!
:
:
SECITEM_AllocItem
(
aArena
aItem
Length
(
)
)
)
{
return
false
;
}
if
(
!
aItem
-
>
data
)
{
MOZ_ASSERT
(
Length
(
)
=
=
0
)
;
return
true
;
}
memcpy
(
aItem
-
>
data
Elements
(
)
Length
(
)
)
;
return
true
;
}
JSObject
*
CryptoBuffer
:
:
ToUint8Array
(
JSContext
*
aCx
ErrorResult
&
aError
)
const
{
return
Uint8Array
:
:
Create
(
aCx
*
this
aError
)
;
}
JSObject
*
CryptoBuffer
:
:
ToArrayBuffer
(
JSContext
*
aCx
ErrorResult
&
aError
)
const
{
return
ArrayBuffer
:
:
Create
(
aCx
*
this
aError
)
;
}
bool
CryptoBuffer
:
:
GetBigIntValue
(
unsigned
long
&
aRetVal
)
{
if
(
Length
(
)
>
sizeof
(
aRetVal
)
)
{
return
false
;
}
aRetVal
=
0
;
for
(
size_t
i
=
0
;
i
<
Length
(
)
;
+
+
i
)
{
aRetVal
=
(
aRetVal
<
<
8
)
+
ElementAt
(
i
)
;
}
return
true
;
}
}
