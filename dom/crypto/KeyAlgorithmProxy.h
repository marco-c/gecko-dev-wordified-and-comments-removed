#
ifndef
mozilla_dom_KeyAlgorithmProxy_h
#
define
mozilla_dom_KeyAlgorithmProxy_h
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
dom
/
CryptoBuffer
.
h
"
#
include
"
mozilla
/
dom
/
KeyAlgorithmBinding
.
h
"
#
include
"
mozilla
/
dom
/
TypedArray
.
h
"
#
include
"
mozilla
/
dom
/
WebCryptoCommon
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
pkcs11t
.
h
"
class
JSObject
;
struct
JSContext
;
struct
JSStructuredCloneReader
;
struct
JSStructuredCloneWriter
;
#
define
KEY_ALGORITHM_SC_VERSION
0x00000001
namespace
mozilla
{
namespace
dom
{
struct
RsaHashedKeyAlgorithmStorage
{
nsString
mName
;
KeyAlgorithm
mHash
;
uint16_t
mModulusLength
;
CryptoBuffer
mPublicExponent
;
bool
ToKeyAlgorithm
(
JSContext
*
aCx
RsaHashedKeyAlgorithm
&
aRsa
)
const
{
JS
:
:
Rooted
<
JSObject
*
>
exponent
(
aCx
mPublicExponent
.
ToUint8Array
(
aCx
)
)
;
if
(
!
exponent
)
{
return
false
;
}
aRsa
.
mName
=
mName
;
aRsa
.
mModulusLength
=
mModulusLength
;
aRsa
.
mHash
.
mName
=
mHash
.
mName
;
aRsa
.
mPublicExponent
.
Init
(
exponent
)
;
aRsa
.
mPublicExponent
.
ComputeState
(
)
;
return
true
;
}
}
;
struct
KeyAlgorithmProxy
{
enum
KeyAlgorithmType
{
AES
HMAC
RSA
EC
}
;
KeyAlgorithmType
mType
;
nsString
mName
;
AesKeyAlgorithm
mAes
;
HmacKeyAlgorithm
mHmac
;
RsaHashedKeyAlgorithmStorage
mRsa
;
EcKeyAlgorithm
mEc
;
bool
WriteStructuredClone
(
JSStructuredCloneWriter
*
aWriter
)
const
;
bool
ReadStructuredClone
(
JSStructuredCloneReader
*
aReader
)
;
CK_MECHANISM_TYPE
Mechanism
(
)
const
;
nsString
JwkAlg
(
)
const
;
static
CK_MECHANISM_TYPE
GetMechanism
(
const
KeyAlgorithm
&
aAlgorithm
)
;
static
CK_MECHANISM_TYPE
GetMechanism
(
const
HmacKeyAlgorithm
&
aAlgorithm
)
;
static
nsString
GetJwkAlg
(
const
KeyAlgorithm
&
aAlgorithm
)
;
void
MakeAes
(
const
nsString
&
aName
uint32_t
aLength
)
{
mType
=
AES
;
mName
=
aName
;
mAes
.
mName
=
aName
;
mAes
.
mLength
=
aLength
;
}
void
MakeHmac
(
uint32_t
aLength
const
nsString
&
aHashName
)
{
mType
=
HMAC
;
mName
=
NS_LITERAL_STRING_FROM_CSTRING
(
WEBCRYPTO_ALG_HMAC
)
;
mHmac
.
mName
=
NS_LITERAL_STRING_FROM_CSTRING
(
WEBCRYPTO_ALG_HMAC
)
;
mHmac
.
mLength
=
aLength
;
mHmac
.
mHash
.
mName
=
aHashName
;
}
bool
MakeRsa
(
const
nsString
&
aName
uint32_t
aModulusLength
const
CryptoBuffer
&
aPublicExponent
const
nsString
&
aHashName
)
{
mType
=
RSA
;
mName
=
aName
;
mRsa
.
mName
=
aName
;
mRsa
.
mModulusLength
=
aModulusLength
;
mRsa
.
mHash
.
mName
=
aHashName
;
if
(
!
mRsa
.
mPublicExponent
.
Assign
(
aPublicExponent
)
)
{
return
false
;
}
return
true
;
}
void
MakeEc
(
const
nsString
&
aName
const
nsString
&
aNamedCurve
)
{
mType
=
EC
;
mName
=
aName
;
mEc
.
mName
=
aName
;
mEc
.
mNamedCurve
=
aNamedCurve
;
}
}
;
}
}
#
endif
