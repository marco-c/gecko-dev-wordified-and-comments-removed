#
include
"
BroadcastChannelParent
.
h
"
#
include
"
BroadcastChannelParentMessage
.
h
"
#
include
"
BroadcastChannelService
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
BlobParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
namespace
mozilla
{
using
namespace
ipc
;
namespace
dom
{
BroadcastChannelParent
:
:
BroadcastChannelParent
(
const
nsAString
&
aOriginChannelKey
)
:
mService
(
BroadcastChannelService
:
:
GetOrCreate
(
)
)
mOriginChannelKey
(
aOriginChannelKey
)
mStatus
(
eInitializing
)
{
AssertIsOnBackgroundThread
(
)
;
mService
-
>
RegisterActor
(
this
mOriginChannelKey
)
;
}
BroadcastChannelParent
:
:
~
BroadcastChannelParent
(
)
{
AssertIsOnBackgroundThread
(
)
;
}
void
BroadcastChannelParent
:
:
Start
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitializing
|
|
mStatus
=
=
eClosing
)
;
for
(
uint32_t
i
=
0
;
i
<
mPendingMessages
.
Length
(
)
;
+
+
i
)
{
mService
-
>
PostMessage
(
this
mPendingMessages
[
i
]
mOriginChannelKey
)
;
}
mPendingMessages
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mDeliveringMessages
.
Length
(
)
;
+
+
i
)
{
DeliverInternal
(
mDeliveringMessages
[
i
]
)
;
}
mDeliveringMessages
.
Clear
(
)
;
if
(
mStatus
=
=
eClosing
)
{
Shutdown
(
)
;
return
;
}
mStatus
=
eInitialized
;
}
void
BroadcastChannelParent
:
:
Shutdown
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mService
)
{
mService
-
>
UnregisterActor
(
this
mOriginChannelKey
)
;
mService
=
nullptr
;
}
Unused
<
<
Send__delete__
(
this
)
;
mStatus
=
eDestroyed
;
}
mozilla
:
:
ipc
:
:
IPCResult
BroadcastChannelParent
:
:
RecvPostMessage
(
const
ClonedMessageData
&
aData
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
!
mService
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
mStatus
=
=
eDestroyed
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
RefPtr
<
BroadcastChannelParentMessage
>
msg
=
new
BroadcastChannelParentMessage
(
aData
)
;
if
(
mStatus
=
=
eInitializing
)
{
mPendingMessages
.
AppendElement
(
msg
)
;
return
IPC_OK
(
)
;
}
if
(
mStatus
=
=
eClosing
)
{
return
IPC_OK
(
)
;
}
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
if
(
NS_WARN_IF
(
!
mPendingMessages
.
IsEmpty
(
)
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
mService
-
>
PostMessage
(
this
msg
mOriginChannelKey
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
BroadcastChannelParent
:
:
RecvClose
(
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
NS_WARN_IF
(
!
mService
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
mStatus
=
=
eDestroyed
|
|
mStatus
=
=
eClosing
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
if
(
mStatus
=
=
eInitializing
)
{
mStatus
=
eClosing
;
return
IPC_OK
(
)
;
}
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
if
(
NS_WARN_IF
(
!
mPendingMessages
.
IsEmpty
(
)
)
|
|
NS_WARN_IF
(
!
mDeliveringMessages
.
IsEmpty
(
)
)
)
{
return
IPC_FAIL_NO_REASON
(
this
)
;
}
Shutdown
(
)
;
return
IPC_OK
(
)
;
}
void
BroadcastChannelParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mService
)
{
mService
-
>
UnregisterActor
(
this
mOriginChannelKey
)
;
}
mStatus
=
eDestroyed
;
}
void
BroadcastChannelParent
:
:
Deliver
(
BroadcastChannelParentMessage
*
aMsg
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aMsg
)
;
if
(
mStatus
=
=
eInitializing
)
{
RefPtr
<
BroadcastChannelParentMessage
>
msg
=
new
BroadcastChannelParentMessage
(
aMsg
-
>
Data
(
)
)
;
mDeliveringMessages
.
AppendElement
(
msg
)
;
return
;
}
if
(
mStatus
=
=
eInitialized
)
{
DeliverInternal
(
aMsg
)
;
return
;
}
}
void
BroadcastChannelParent
:
:
DeliverInternal
(
BroadcastChannelParentMessage
*
aMsg
)
{
ClonedMessageData
newData
(
aMsg
-
>
Data
(
)
)
;
for
(
uint32_t
i
=
0
len
=
newData
.
blobsParent
(
)
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
RefPtr
<
BlobImpl
>
impl
=
static_cast
<
BlobParent
*
>
(
newData
.
blobsParent
(
)
[
i
]
)
-
>
GetBlobImpl
(
)
;
PBlobParent
*
blobParent
=
BackgroundParent
:
:
GetOrCreateActorForBlobImpl
(
Manager
(
)
impl
)
;
if
(
!
blobParent
)
{
return
;
}
newData
.
blobsParent
(
)
[
i
]
=
blobParent
;
}
Unused
<
<
SendNotify
(
newData
)
;
}
}
}
