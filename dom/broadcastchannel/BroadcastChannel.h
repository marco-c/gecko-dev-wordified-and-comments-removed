#
ifndef
mozilla_dom_BroadcastChannel_h
#
define
mozilla_dom_BroadcastChannel_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
nsIIPCBackgroundChildCreateCallback
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
class
nsPIDOMWindowInner
;
namespace
mozilla
{
namespace
ipc
{
class
PrincipalInfo
;
}
namespace
dom
{
namespace
workers
{
class
WorkerFeature
;
}
class
BroadcastChannelChild
;
class
BroadcastChannelMessage
;
class
BroadcastChannel
final
:
public
DOMEventTargetHelper
public
nsIIPCBackgroundChildCreateCallback
public
nsIObserver
{
friend
class
BroadcastChannelChild
;
NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
NS_DECL_NSIOBSERVER
typedef
mozilla
:
:
ipc
:
:
PrincipalInfo
PrincipalInfo
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
BroadcastChannel
DOMEventTargetHelper
)
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
already_AddRefed
<
BroadcastChannel
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aChannel
ErrorResult
&
aRv
)
;
void
GetName
(
nsAString
&
aName
)
const
{
aName
=
mChannel
;
}
void
PostMessage
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
ErrorResult
&
aRv
)
;
void
Close
(
)
;
EventHandlerNonNull
*
GetOnmessage
(
)
;
void
SetOnmessage
(
EventHandlerNonNull
*
aCallback
)
;
using
nsIDOMEventTarget
:
:
AddEventListener
;
using
nsIDOMEventTarget
:
:
RemoveEventListener
;
virtual
void
AddEventListener
(
const
nsAString
&
aType
EventListener
*
aCallback
bool
aCapture
const
Nullable
<
bool
>
&
aWantsUntrusted
ErrorResult
&
aRv
)
override
;
virtual
void
RemoveEventListener
(
const
nsAString
&
aType
EventListener
*
aCallback
bool
aCapture
ErrorResult
&
aRv
)
override
;
void
Shutdown
(
)
;
private
:
BroadcastChannel
(
nsPIDOMWindowInner
*
aWindow
const
PrincipalInfo
&
aPrincipalInfo
const
nsACString
&
aOrigin
const
nsAString
&
aChannel
bool
aPrivateBrowsing
)
;
~
BroadcastChannel
(
)
;
void
PostMessageData
(
BroadcastChannelMessage
*
aData
)
;
void
PostMessageInternal
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
ErrorResult
&
aRv
)
;
void
UpdateMustKeepAlive
(
)
;
bool
IsCertainlyAliveForCC
(
)
const
override
{
return
mIsKeptAlive
;
}
bool
IsClosed
(
)
const
{
return
mState
!
=
StateActive
;
}
void
RemoveDocFromBFCache
(
)
;
RefPtr
<
BroadcastChannelChild
>
mActor
;
nsTArray
<
RefPtr
<
BroadcastChannelMessage
>
>
mPendingMessages
;
nsAutoPtr
<
workers
:
:
WorkerFeature
>
mWorkerFeature
;
nsAutoPtr
<
PrincipalInfo
>
mPrincipalInfo
;
nsCString
mOrigin
;
nsString
mChannel
;
bool
mPrivateBrowsing
;
bool
mIsKeptAlive
;
uint64_t
mInnerID
;
enum
{
StateActive
StateClosing
StateClosed
}
mState
;
}
;
}
}
#
endif
