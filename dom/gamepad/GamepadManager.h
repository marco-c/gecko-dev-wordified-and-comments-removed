#
ifndef
mozilla_dom_GamepadManager_h_
#
define
mozilla_dom_GamepadManager_h_
#
include
"
nsIObserver
.
h
"
#
include
"
mozilla
/
dom
/
GamepadBinding
.
h
"
#
include
"
mozilla
/
dom
/
GamepadServiceType
.
h
"
class
nsGlobalWindowInner
;
namespace
mozilla
{
namespace
gfx
{
class
VRManagerChild
;
}
namespace
dom
{
class
EventTarget
;
class
Gamepad
;
class
GamepadChangeEvent
;
class
GamepadEventChannelChild
;
class
GamepadManager
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
static
bool
IsServiceRunning
(
)
;
static
already_AddRefed
<
GamepadManager
>
GetService
(
)
;
static
bool
IsAPIEnabled
(
)
;
void
BeginShutdown
(
)
;
void
StopMonitoring
(
)
;
void
AddListener
(
nsGlobalWindowInner
*
aWindow
)
;
void
RemoveListener
(
nsGlobalWindowInner
*
aWindow
)
;
void
AddGamepad
(
uint32_t
aIndex
const
nsAString
&
aID
GamepadMappingType
aMapping
GamepadHand
aHand
GamepadServiceType
aServiceType
uint32_t
aDisplayID
uint32_t
aNumButtons
uint32_t
aNumAxes
uint32_t
aNumHaptics
uint32_t
aNumLightIndicator
uint32_t
aNumTouchEvents
)
;
void
RemoveGamepad
(
uint32_t
aIndex
GamepadServiceType
aServiceType
)
;
void
SyncGamepadState
(
uint32_t
aIndex
nsGlobalWindowInner
*
aWindow
Gamepad
*
aGamepad
)
;
already_AddRefed
<
Gamepad
>
GetGamepad
(
uint32_t
aIndex
)
const
;
already_AddRefed
<
Gamepad
>
GetGamepad
(
uint32_t
aGamepadId
GamepadServiceType
aServiceType
)
const
;
void
Update
(
const
GamepadChangeEvent
&
aGamepadEvent
)
;
already_AddRefed
<
Promise
>
VibrateHaptic
(
uint32_t
aControllerIdx
uint32_t
aHapticIndex
double
aIntensity
double
aDuration
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
;
void
StopHaptics
(
)
;
already_AddRefed
<
Promise
>
SetLightIndicatorColor
(
uint32_t
aControllerIdx
uint32_t
aLightColorIndex
uint8_t
aRed
uint8_t
aGreen
uint8_t
aBlue
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
;
protected
:
GamepadManager
(
)
;
~
GamepadManager
(
)
{
}
;
void
NewConnectionEvent
(
uint32_t
aIndex
bool
aConnected
)
;
void
FireAxisMoveEvent
(
EventTarget
*
aTarget
Gamepad
*
aGamepad
uint32_t
axis
double
value
)
;
void
FireButtonEvent
(
EventTarget
*
aTarget
Gamepad
*
aGamepad
uint32_t
aButton
double
aValue
)
;
void
FireConnectionEvent
(
EventTarget
*
aTarget
Gamepad
*
aGamepad
bool
aConnected
)
;
bool
mEnabled
;
bool
mNonstandardEventsEnabled
;
bool
mShuttingDown
;
nsTArray
<
GamepadEventChannelChild
*
>
mChannelChildren
;
private
:
nsresult
Init
(
)
;
void
MaybeConvertToNonstandardGamepadEvent
(
const
GamepadChangeEvent
&
aEvent
nsGlobalWindowInner
*
aWindow
)
;
bool
SetGamepadByEvent
(
const
GamepadChangeEvent
&
aEvent
nsGlobalWindowInner
*
aWindow
=
nullptr
)
;
bool
MaybeWindowHasSeenGamepad
(
nsGlobalWindowInner
*
aWindow
uint32_t
aIndex
)
;
bool
WindowHasSeenGamepad
(
nsGlobalWindowInner
*
aWindow
uint32_t
aIndex
)
const
;
void
SetWindowHasSeenGamepad
(
nsGlobalWindowInner
*
aWindow
uint32_t
aIndex
bool
aHasSeen
=
true
)
;
uint32_t
GetGamepadIndexWithServiceType
(
uint32_t
aIndex
GamepadServiceType
aServiceType
)
const
;
nsRefPtrHashtable
<
nsUint32HashKey
Gamepad
>
mGamepads
;
nsTArray
<
RefPtr
<
nsGlobalWindowInner
>
>
mListeners
;
uint32_t
mPromiseID
;
}
;
}
}
#
endif
