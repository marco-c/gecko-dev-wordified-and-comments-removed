#
include
"
mozilla
/
dom
/
GamepadPlatformService
.
h
"
#
include
"
mozilla
/
dom
/
GamepadEventChannelParent
.
h
"
#
include
"
mozilla
/
dom
/
GamepadMonitoring
.
h
"
#
include
"
mozilla
/
dom
/
GamepadStateBroadcastReceiverInfo
.
h
"
#
include
"
mozilla
/
dom
/
GamepadTestChannelParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
:
:
dom
{
namespace
{
StaticRefPtr
<
GamepadPlatformService
>
gGamepadPlatformServiceSingleton
;
}
GamepadMonitoringState
&
GamepadMonitoringState
:
:
GetSingleton
(
)
{
static
GamepadMonitoringState
sInstance
{
}
;
return
sInstance
;
}
void
GamepadMonitoringState
:
:
AddObserver
(
GamepadTestChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ALWAYS_TRUE
(
mObservers
.
append
(
aParent
)
)
;
}
void
GamepadMonitoringState
:
:
RemoveObserver
(
GamepadTestChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
WeakPtr
<
GamepadTestChannelParent
>
*
observer
=
nullptr
;
for
(
auto
&
item
:
mObservers
)
{
if
(
item
=
=
aParent
)
{
observer
=
&
item
;
}
}
MOZ_ASSERT
(
observer
"
Attempted
to
remove
a
GamepadTestChannelParent
that
was
never
added
"
)
;
std
:
:
swap
(
*
observer
mObservers
.
back
(
)
)
;
mObservers
.
popBack
(
)
;
}
bool
GamepadMonitoringState
:
:
IsMonitoring
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mIsMonitoring
;
}
void
GamepadMonitoringState
:
:
Set
(
bool
aIsMonitoring
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mIsMonitoring
!
=
aIsMonitoring
)
{
mIsMonitoring
=
aIsMonitoring
;
for
(
auto
&
observer
:
mObservers
)
{
MOZ_RELEASE_ASSERT
(
observer
)
;
observer
-
>
OnMonitoringStateChanged
(
aIsMonitoring
)
;
}
}
}
GamepadPlatformService
:
:
GamepadPlatformService
(
)
:
mNextGamepadHandleValue
(
1
)
mMutex
(
"
mozilla
:
:
dom
:
:
GamepadPlatformService
"
)
mMaybeGamepadStateBroadcaster
(
GamepadStateBroadcaster
:
:
Create
(
)
)
{
}
GamepadPlatformService
:
:
~
GamepadPlatformService
(
)
{
Cleanup
(
)
;
}
already_AddRefed
<
GamepadPlatformService
>
GamepadPlatformService
:
:
GetParentService
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
gGamepadPlatformServiceSingleton
)
{
if
(
IsOnBackgroundThread
(
)
)
{
gGamepadPlatformServiceSingleton
=
new
GamepadPlatformService
(
)
;
}
else
{
return
nullptr
;
}
}
RefPtr
<
GamepadPlatformService
>
service
(
gGamepadPlatformServiceSingleton
)
;
return
service
.
forget
(
)
;
}
template
<
class
T
>
void
GamepadPlatformService
:
:
NotifyGamepadChange
(
GamepadHandle
aHandle
const
T
&
aInfo
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mMaybeGamepadStateBroadcaster
)
;
GamepadChangeEventBody
body
(
aInfo
)
;
GamepadChangeEvent
e
(
aHandle
body
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
+
+
i
)
{
mChannelParents
[
i
]
-
>
DispatchUpdateEvent
(
e
)
;
}
}
GamepadHandle
GamepadPlatformService
:
:
AddGamepad
(
const
char
*
aID
GamepadMappingType
aMapping
GamepadHand
aHand
uint32_t
aNumButtons
uint32_t
aNumAxes
uint32_t
aHaptics
uint32_t
aNumLightIndicator
uint32_t
aNumTouchEvents
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadHandle
gamepadHandle
{
mNextGamepadHandleValue
+
+
GamepadHandleKind
:
:
GamepadPlatformManager
}
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
AddGamepad
(
gamepadHandle
aID
aMapping
aHand
aNumButtons
aNumAxes
aHaptics
aNumLightIndicator
aNumTouchEvents
)
;
}
else
{
GamepadAdded
a
(
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
aID
)
)
aMapping
aHand
0
aNumButtons
aNumAxes
aHaptics
aNumLightIndicator
aNumTouchEvents
)
;
mGamepadAdded
.
emplace
(
gamepadHandle
a
)
;
NotifyGamepadChange
<
GamepadAdded
>
(
gamepadHandle
a
)
;
}
return
gamepadHandle
;
}
void
GamepadPlatformService
:
:
RemoveGamepad
(
GamepadHandle
aHandle
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
RemoveGamepad
(
aHandle
)
;
}
else
{
GamepadRemoved
a
;
NotifyGamepadChange
<
GamepadRemoved
>
(
aHandle
a
)
;
mGamepadAdded
.
erase
(
aHandle
)
;
}
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
bool
aTouched
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
NewButtonEvent
(
aHandle
aButton
aPressed
aTouched
aValue
)
;
}
else
{
GamepadButtonInformation
a
(
aButton
aValue
aPressed
aTouched
)
;
NotifyGamepadChange
<
GamepadButtonInformation
>
(
aHandle
a
)
;
}
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aHandle
aButton
aPressed
aPressed
aValue
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
bool
aTouched
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aHandle
aButton
aPressed
aTouched
aPressed
?
1
.
0L
:
0
.
0L
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aHandle
aButton
aPressed
aPressed
aPressed
?
1
.
0L
:
0
.
0L
)
;
}
void
GamepadPlatformService
:
:
NewAxisMoveEvent
(
GamepadHandle
aHandle
uint32_t
aAxis
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
NewAxisMoveEvent
(
aHandle
aAxis
aValue
)
;
}
else
{
GamepadAxisInformation
a
(
aAxis
aValue
)
;
NotifyGamepadChange
<
GamepadAxisInformation
>
(
aHandle
a
)
;
}
}
void
GamepadPlatformService
:
:
NewLightIndicatorTypeEvent
(
GamepadHandle
aHandle
uint32_t
aLight
GamepadLightIndicatorType
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
NewLightIndicatorTypeEvent
(
aHandle
aLight
aType
)
;
}
else
{
GamepadLightIndicatorTypeInformation
a
(
aLight
aType
)
;
NotifyGamepadChange
<
GamepadLightIndicatorTypeInformation
>
(
aHandle
a
)
;
}
}
void
GamepadPlatformService
:
:
NewPoseEvent
(
GamepadHandle
aHandle
const
GamepadPoseState
&
aState
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
NewPoseEvent
(
aHandle
aState
)
;
}
else
{
GamepadPoseInformation
a
(
aState
)
;
NotifyGamepadChange
<
GamepadPoseInformation
>
(
aHandle
a
)
;
}
}
void
GamepadPlatformService
:
:
NewMultiTouchEvent
(
GamepadHandle
aHandle
uint32_t
aTouchArrayIndex
const
GamepadTouchState
&
aState
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
NewMultiTouchEvent
(
aHandle
aTouchArrayIndex
aState
)
;
}
else
{
GamepadTouchInformation
a
(
aTouchArrayIndex
aState
)
;
NotifyGamepadChange
<
GamepadTouchInformation
>
(
aHandle
a
)
;
}
}
void
GamepadPlatformService
:
:
ResetGamepadIndexes
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mNextGamepadHandleValue
=
1
;
}
void
GamepadPlatformService
:
:
AddChannelParent
(
GamepadEventChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
!
mChannelParents
.
Contains
(
aParent
)
)
;
GamepadStateBroadcastReceiverInfo
receiverInfo
{
}
;
if
(
mMaybeGamepadStateBroadcaster
&
&
mMaybeGamepadStateBroadcaster
-
>
AddReceiverAndGenerateRemoteInfo
(
aParent
&
receiverInfo
)
)
{
Unused
<
<
aParent
-
>
SendSetupSharedMemory
(
receiverInfo
)
;
}
{
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
AppendElement
(
aParent
)
;
if
(
!
mMaybeGamepadStateBroadcaster
)
{
if
(
mChannelParents
.
Length
(
)
>
1
)
{
for
(
const
auto
&
evt
:
mGamepadAdded
)
{
GamepadChangeEventBody
body
(
evt
.
second
)
;
GamepadChangeEvent
e
(
evt
.
first
body
)
;
aParent
-
>
DispatchUpdateEvent
(
e
)
;
}
}
}
}
StartGamepadMonitoring
(
)
;
GamepadMonitoringState
:
:
GetSingleton
(
)
.
Set
(
true
)
;
}
void
GamepadPlatformService
:
:
RemoveChannelParent
(
GamepadEventChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
mChannelParents
.
Contains
(
aParent
)
)
;
{
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
RemoveElement
(
aParent
)
;
if
(
!
mChannelParents
.
IsEmpty
(
)
)
{
return
;
}
}
GamepadMonitoringState
:
:
GetSingleton
(
)
.
Set
(
false
)
;
StopGamepadMonitoring
(
)
;
if
(
mMaybeGamepadStateBroadcaster
)
{
mMaybeGamepadStateBroadcaster
-
>
RemoveReceiver
(
aParent
)
;
}
ResetGamepadIndexes
(
)
;
MaybeShutdown
(
)
;
}
void
GamepadPlatformService
:
:
MaybeShutdown
(
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
GamepadPlatformService
>
kungFuDeathGrip
;
bool
isChannelParentEmpty
;
{
MutexAutoLock
autoLock
(
mMutex
)
;
isChannelParentEmpty
=
mChannelParents
.
IsEmpty
(
)
;
if
(
isChannelParentEmpty
)
{
kungFuDeathGrip
=
gGamepadPlatformServiceSingleton
;
gGamepadPlatformServiceSingleton
=
nullptr
;
mGamepadAdded
.
clear
(
)
;
}
}
}
void
GamepadPlatformService
:
:
Cleanup
(
)
{
AssertIsOnBackgroundThread
(
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
Clear
(
)
;
}
}
