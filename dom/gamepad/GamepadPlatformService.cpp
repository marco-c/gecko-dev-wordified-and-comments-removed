#
include
"
mozilla
/
dom
/
GamepadPlatformService
.
h
"
#
include
"
mozilla
/
dom
/
GamepadEventChannelParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIThread
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
dom
{
namespace
{
StaticRefPtr
<
GamepadPlatformService
>
gGamepadPlatformServiceSingleton
;
}
GamepadPlatformService
:
:
GamepadPlatformService
(
)
:
mGamepadIndex
(
0
)
mMutex
(
"
mozilla
:
:
dom
:
:
GamepadPlatformService
"
)
{
}
GamepadPlatformService
:
:
~
GamepadPlatformService
(
)
{
Cleanup
(
)
;
}
already_AddRefed
<
GamepadPlatformService
>
GamepadPlatformService
:
:
GetParentService
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
gGamepadPlatformServiceSingleton
)
{
if
(
IsOnBackgroundThread
(
)
)
{
gGamepadPlatformServiceSingleton
=
new
GamepadPlatformService
(
)
;
}
else
{
return
nullptr
;
}
}
RefPtr
<
GamepadPlatformService
>
service
(
gGamepadPlatformServiceSingleton
)
;
return
service
.
forget
(
)
;
}
template
<
class
T
>
void
GamepadPlatformService
:
:
NotifyGamepadChange
(
const
T
&
aInfo
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadChangeEvent
e
(
aInfo
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
if
(
mChannelParents
.
IsEmpty
(
)
)
{
mPendingEvents
.
AppendElement
(
e
)
;
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
+
+
i
)
{
mChannelParents
[
i
]
-
>
DispatchUpdateEvent
(
e
)
;
}
}
uint32_t
GamepadPlatformService
:
:
AddGamepad
(
const
char
*
aID
GamepadMappingType
aMapping
uint32_t
aNumButtons
uint32_t
aNumAxes
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
uint32_t
index
=
+
+
mGamepadIndex
;
GamepadAdded
a
(
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
aID
)
)
index
static_cast
<
uint32_t
>
(
aMapping
)
static_cast
<
uint32_t
>
(
GamepadHand
:
:
_empty
)
GamepadServiceType
:
:
Standard
aNumButtons
aNumAxes
)
;
NotifyGamepadChange
<
GamepadAdded
>
(
a
)
;
return
index
;
}
void
GamepadPlatformService
:
:
RemoveGamepad
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadRemoved
a
(
aIndex
GamepadServiceType
:
:
Standard
)
;
NotifyGamepadChange
<
GamepadRemoved
>
(
a
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadButtonInformation
a
(
aIndex
GamepadServiceType
:
:
Standard
aButton
aPressed
aValue
)
;
NotifyGamepadChange
<
GamepadButtonInformation
>
(
a
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aIndex
aButton
aPressed
aPressed
?
1
.
0L
:
0
.
0L
)
;
}
void
GamepadPlatformService
:
:
NewAxisMoveEvent
(
uint32_t
aIndex
uint32_t
aAxis
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadAxisInformation
a
(
aIndex
GamepadServiceType
:
:
Standard
aAxis
aValue
)
;
NotifyGamepadChange
<
GamepadAxisInformation
>
(
a
)
;
}
void
GamepadPlatformService
:
:
ResetGamepadIndexes
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mGamepadIndex
=
0
;
}
void
GamepadPlatformService
:
:
AddChannelParent
(
GamepadEventChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
!
mChannelParents
.
Contains
(
aParent
)
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
AppendElement
(
aParent
)
;
FlushPendingEvents
(
)
;
}
void
GamepadPlatformService
:
:
FlushPendingEvents
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mChannelParents
.
IsEmpty
(
)
)
;
if
(
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
+
+
i
)
{
for
(
uint32_t
j
=
0
;
j
<
mPendingEvents
.
Length
(
)
;
+
+
j
)
{
mChannelParents
[
i
]
-
>
DispatchUpdateEvent
(
mPendingEvents
[
j
]
)
;
}
}
mPendingEvents
.
Clear
(
)
;
}
void
GamepadPlatformService
:
:
RemoveChannelParent
(
GamepadEventChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
mChannelParents
.
Contains
(
aParent
)
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
RemoveElement
(
aParent
)
;
}
bool
GamepadPlatformService
:
:
HasGamepadListeners
(
)
{
AssertIsOnBackgroundThread
(
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
i
+
+
)
{
if
(
mChannelParents
[
i
]
-
>
HasGamepadListener
(
)
)
{
return
true
;
}
}
return
false
;
}
void
GamepadPlatformService
:
:
MaybeShutdown
(
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
GamepadPlatformService
>
kungFuDeathGrip
;
bool
isChannelParentEmpty
;
{
MutexAutoLock
autoLock
(
mMutex
)
;
isChannelParentEmpty
=
mChannelParents
.
IsEmpty
(
)
;
if
(
isChannelParentEmpty
)
{
kungFuDeathGrip
=
gGamepadPlatformServiceSingleton
;
gGamepadPlatformServiceSingleton
=
nullptr
;
}
}
}
void
GamepadPlatformService
:
:
Cleanup
(
)
{
AssertIsOnBackgroundThread
(
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
Clear
(
)
;
}
}
}
