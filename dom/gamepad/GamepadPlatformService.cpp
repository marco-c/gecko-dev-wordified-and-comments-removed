#
include
"
mozilla
/
dom
/
GamepadPlatformService
.
h
"
#
include
"
mozilla
/
dom
/
GamepadEventChannelParent
.
h
"
#
include
"
mozilla
/
dom
/
GamepadMonitoring
.
h
"
#
include
"
mozilla
/
dom
/
GamepadTestChannelParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
:
:
dom
{
namespace
{
static
StaticRefPtr
<
GamepadPlatformService
>
gGamepadPlatformServiceSingleton
;
}
GamepadMonitoringState
&
GamepadMonitoringState
:
:
GetSingleton
(
)
{
static
GamepadMonitoringState
sInstance
{
}
;
return
sInstance
;
}
void
GamepadMonitoringState
:
:
AddObserver
(
GamepadTestChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ALWAYS_TRUE
(
mObservers
.
append
(
aParent
)
)
;
}
void
GamepadMonitoringState
:
:
RemoveObserver
(
GamepadTestChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
WeakPtr
<
GamepadTestChannelParent
>
*
observer
=
nullptr
;
for
(
auto
&
item
:
mObservers
)
{
if
(
item
=
=
aParent
)
{
observer
=
&
item
;
}
}
MOZ_ASSERT
(
observer
"
Attempted
to
remove
a
GamepadTestChannelParent
that
was
never
added
"
)
;
std
:
:
swap
(
*
observer
mObservers
.
back
(
)
)
;
mObservers
.
popBack
(
)
;
}
bool
GamepadMonitoringState
:
:
IsMonitoring
(
)
const
{
AssertIsOnBackgroundThread
(
)
;
return
mIsMonitoring
;
}
void
GamepadMonitoringState
:
:
Set
(
bool
aIsMonitoring
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mIsMonitoring
!
=
aIsMonitoring
)
{
mIsMonitoring
=
aIsMonitoring
;
for
(
auto
&
observer
:
mObservers
)
{
MOZ_RELEASE_ASSERT
(
observer
)
;
observer
-
>
OnMonitoringStateChanged
(
aIsMonitoring
)
;
}
}
}
GamepadPlatformService
:
:
GamepadPlatformService
(
RefPtr
<
GamepadEventChannelParent
>
aParent
)
:
mNextGamepadHandleValue
(
1
)
mMutex
(
"
mozilla
:
:
dom
:
:
GamepadPlatformService
"
)
{
AssertIsOnBackgroundThread
(
)
;
mChannelParents
.
AppendElement
(
std
:
:
move
(
aParent
)
)
;
MOZ_ASSERT
(
mChannelParents
.
Length
(
)
=
=
1
)
;
}
GamepadPlatformService
:
:
~
GamepadPlatformService
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mChannelParents
.
Length
(
)
=
=
1
)
;
}
already_AddRefed
<
GamepadPlatformService
>
GamepadPlatformService
:
:
GetParentService
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
gGamepadPlatformServiceSingleton
"
Impossible
for
monitor
thread
to
be
running
with
no
platform
service
"
)
;
return
RefPtr
<
GamepadPlatformService
>
(
gGamepadPlatformServiceSingleton
)
.
forget
(
)
;
}
template
<
class
T
>
void
GamepadPlatformService
:
:
NotifyGamepadChange
(
GamepadHandle
aHandle
const
T
&
aInfo
const
MutexAutoLock
&
aProofOfLock
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
aProofOfLock
.
AssertOwns
(
mMutex
)
;
GamepadChangeEventBody
body
(
aInfo
)
;
GamepadChangeEvent
e
(
aHandle
body
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
+
+
i
)
{
mChannelParents
[
i
]
-
>
DispatchUpdateEvent
(
e
)
;
}
}
GamepadHandle
GamepadPlatformService
:
:
AddGamepad
(
const
char
*
aID
GamepadMappingType
aMapping
GamepadHand
aHand
uint32_t
aNumButtons
uint32_t
aNumAxes
uint32_t
aNumHaptics
uint32_t
aNumLightIndicator
uint32_t
aNumTouchEvents
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadHandle
gamepadHandle
{
mNextGamepadHandleValue
+
+
GamepadHandleKind
:
:
GamepadPlatformManager
}
;
GamepadAdded
a
(
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
aID
)
)
aMapping
aHand
0
aNumButtons
aNumAxes
aNumHaptics
aNumLightIndicator
aNumTouchEvents
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mGamepadAdded
.
emplace
(
gamepadHandle
a
)
;
NotifyGamepadChange
<
GamepadAdded
>
(
gamepadHandle
a
autoLock
)
;
return
gamepadHandle
;
}
void
GamepadPlatformService
:
:
RemoveGamepad
(
GamepadHandle
aHandle
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadRemoved
a
;
MutexAutoLock
autoLock
(
mMutex
)
;
NotifyGamepadChange
<
GamepadRemoved
>
(
aHandle
a
autoLock
)
;
mGamepadAdded
.
erase
(
aHandle
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
bool
aTouched
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadButtonInformation
a
(
aButton
aValue
aPressed
aTouched
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
NotifyGamepadChange
<
GamepadButtonInformation
>
(
aHandle
a
autoLock
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aHandle
aButton
aPressed
aPressed
aValue
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
bool
aTouched
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aHandle
aButton
aPressed
aTouched
aPressed
?
1
.
0L
:
0
.
0L
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
GamepadHandle
aHandle
uint32_t
aButton
bool
aPressed
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aHandle
aButton
aPressed
aPressed
aPressed
?
1
.
0L
:
0
.
0L
)
;
}
void
GamepadPlatformService
:
:
NewAxisMoveEvent
(
GamepadHandle
aHandle
uint32_t
aAxis
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadAxisInformation
a
(
aAxis
aValue
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
NotifyGamepadChange
<
GamepadAxisInformation
>
(
aHandle
a
autoLock
)
;
}
void
GamepadPlatformService
:
:
NewLightIndicatorTypeEvent
(
GamepadHandle
aHandle
uint32_t
aLight
GamepadLightIndicatorType
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadLightIndicatorTypeInformation
a
(
aLight
aType
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
NotifyGamepadChange
<
GamepadLightIndicatorTypeInformation
>
(
aHandle
a
autoLock
)
;
}
void
GamepadPlatformService
:
:
NewPoseEvent
(
GamepadHandle
aHandle
const
GamepadPoseState
&
aState
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadPoseInformation
a
(
aState
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
NotifyGamepadChange
<
GamepadPoseInformation
>
(
aHandle
a
autoLock
)
;
}
void
GamepadPlatformService
:
:
NewMultiTouchEvent
(
GamepadHandle
aHandle
uint32_t
aTouchArrayIndex
const
GamepadTouchState
&
aState
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadTouchInformation
a
(
aTouchArrayIndex
aState
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
NotifyGamepadChange
<
GamepadTouchInformation
>
(
aHandle
a
autoLock
)
;
}
void
GamepadPlatformService
:
:
AddChannelParentInternal
(
const
RefPtr
<
GamepadEventChannelParent
>
&
aParent
)
{
MutexAutoLock
autoLock
(
mMutex
)
;
MOZ_ASSERT
(
!
mChannelParents
.
Contains
(
aParent
)
)
;
mChannelParents
.
AppendElement
(
aParent
)
;
for
(
const
auto
&
evt
:
mGamepadAdded
)
{
GamepadChangeEventBody
body
(
evt
.
second
)
;
GamepadChangeEvent
e
(
evt
.
first
body
)
;
aParent
-
>
DispatchUpdateEvent
(
e
)
;
}
}
bool
GamepadPlatformService
:
:
RemoveChannelParentInternal
(
GamepadEventChannelParent
*
aParent
)
{
MutexAutoLock
autoLock
(
mMutex
)
;
MOZ_ASSERT
(
mChannelParents
.
Contains
(
aParent
)
)
;
if
(
mChannelParents
.
Length
(
)
=
=
1
)
{
return
false
;
}
mChannelParents
.
RemoveElement
(
aParent
)
;
return
true
;
}
void
GamepadPlatformService
:
:
AddChannelParent
(
const
RefPtr
<
GamepadEventChannelParent
>
&
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
if
(
gGamepadPlatformServiceSingleton
)
{
gGamepadPlatformServiceSingleton
-
>
AddChannelParentInternal
(
aParent
)
;
return
;
}
gGamepadPlatformServiceSingleton
=
RefPtr
<
GamepadPlatformService
>
(
new
GamepadPlatformService
{
aParent
}
)
;
StartGamepadMonitoring
(
)
;
GamepadMonitoringState
:
:
GetSingleton
(
)
.
Set
(
true
)
;
}
void
GamepadPlatformService
:
:
RemoveChannelParent
(
GamepadEventChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
gGamepadPlatformServiceSingleton
)
;
if
(
gGamepadPlatformServiceSingleton
-
>
RemoveChannelParentInternal
(
aParent
)
)
{
return
;
}
GamepadMonitoringState
:
:
GetSingleton
(
)
.
Set
(
false
)
;
StopGamepadMonitoring
(
)
;
MOZ_RELEASE_ASSERT
(
gGamepadPlatformServiceSingleton
-
>
mRefCnt
.
get
(
)
=
=
1
)
;
gGamepadPlatformServiceSingleton
=
nullptr
;
}
}
