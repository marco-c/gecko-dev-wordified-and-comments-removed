#
include
"
mozilla
/
dom
/
GamepadPlatformService
.
h
"
#
include
"
mozilla
/
dom
/
GamepadEventChannelParent
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundParent
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIThread
.
h
"
using
namespace
mozilla
:
:
ipc
;
namespace
mozilla
{
namespace
dom
{
namespace
{
StaticRefPtr
<
GamepadPlatformService
>
gGamepadPlatformServiceSingleton
;
}
GamepadPlatformService
:
:
GamepadPlatformService
(
)
:
mGamepadIndex
(
0
)
mMutex
(
"
mozilla
:
:
dom
:
:
GamepadPlatformService
"
)
{
}
GamepadPlatformService
:
:
~
GamepadPlatformService
(
)
{
Cleanup
(
)
;
}
already_AddRefed
<
GamepadPlatformService
>
GamepadPlatformService
:
:
GetParentService
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
gGamepadPlatformServiceSingleton
)
{
if
(
IsOnBackgroundThread
(
)
)
{
gGamepadPlatformServiceSingleton
=
new
GamepadPlatformService
(
)
;
}
else
{
return
nullptr
;
}
}
RefPtr
<
GamepadPlatformService
>
service
(
gGamepadPlatformServiceSingleton
)
;
return
service
.
forget
(
)
;
}
template
<
class
T
>
void
GamepadPlatformService
:
:
NotifyGamepadChange
(
uint32_t
aIndex
const
T
&
aInfo
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadChangeEventBody
body
(
aInfo
)
;
GamepadChangeEvent
e
(
aIndex
GamepadServiceType
:
:
Standard
body
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
if
(
mChannelParents
.
IsEmpty
(
)
)
{
mPendingEvents
.
AppendElement
(
e
)
;
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
+
+
i
)
{
mChannelParents
[
i
]
-
>
DispatchUpdateEvent
(
e
)
;
}
}
uint32_t
GamepadPlatformService
:
:
AddGamepad
(
const
char
*
aID
GamepadMappingType
aMapping
GamepadHand
aHand
uint32_t
aNumButtons
uint32_t
aNumAxes
uint32_t
aHaptics
uint32_t
aNumLightIndicator
uint32_t
aNumTouchEvents
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
uint32_t
index
=
+
+
mGamepadIndex
;
GamepadAdded
a
(
NS_ConvertUTF8toUTF16
(
nsDependentCString
(
aID
)
)
aMapping
aHand
0
aNumButtons
aNumAxes
aHaptics
aNumLightIndicator
aNumTouchEvents
)
;
NotifyGamepadChange
<
GamepadAdded
>
(
index
a
)
;
return
index
;
}
void
GamepadPlatformService
:
:
RemoveGamepad
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadRemoved
a
;
NotifyGamepadChange
<
GamepadRemoved
>
(
aIndex
a
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
bool
aTouched
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadButtonInformation
a
(
aButton
aValue
aPressed
aTouched
)
;
NotifyGamepadChange
<
GamepadButtonInformation
>
(
aIndex
a
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aIndex
aButton
aPressed
aPressed
aValue
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
bool
aTouched
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aIndex
aButton
aPressed
aTouched
aPressed
?
1
.
0L
:
0
.
0L
)
;
}
void
GamepadPlatformService
:
:
NewButtonEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
NewButtonEvent
(
aIndex
aButton
aPressed
aPressed
aPressed
?
1
.
0L
:
0
.
0L
)
;
}
void
GamepadPlatformService
:
:
NewAxisMoveEvent
(
uint32_t
aIndex
uint32_t
aAxis
double
aValue
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadAxisInformation
a
(
aAxis
aValue
)
;
NotifyGamepadChange
<
GamepadAxisInformation
>
(
aIndex
a
)
;
}
void
GamepadPlatformService
:
:
NewLightIndicatorTypeEvent
(
uint32_t
aIndex
uint32_t
aLight
GamepadLightIndicatorType
aType
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadLightIndicatorTypeInformation
a
(
aLight
aType
)
;
NotifyGamepadChange
<
GamepadLightIndicatorTypeInformation
>
(
aIndex
a
)
;
}
void
GamepadPlatformService
:
:
NewPoseEvent
(
uint32_t
aIndex
const
GamepadPoseState
&
aState
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadPoseInformation
a
(
aState
)
;
NotifyGamepadChange
<
GamepadPoseInformation
>
(
aIndex
a
)
;
}
void
GamepadPlatformService
:
:
NewMultiTouchEvent
(
uint32_t
aIndex
uint32_t
aTouchArrayIndex
const
GamepadTouchState
&
aState
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
GamepadTouchInformation
a
(
aTouchArrayIndex
aState
)
;
NotifyGamepadChange
<
GamepadTouchInformation
>
(
aIndex
a
)
;
}
void
GamepadPlatformService
:
:
ResetGamepadIndexes
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
!
NS_IsMainThread
(
)
)
;
mGamepadIndex
=
0
;
}
void
GamepadPlatformService
:
:
AddChannelParent
(
GamepadEventChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
!
mChannelParents
.
Contains
(
aParent
)
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
AppendElement
(
aParent
)
;
FlushPendingEvents
(
)
;
}
void
GamepadPlatformService
:
:
FlushPendingEvents
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mChannelParents
.
IsEmpty
(
)
)
;
if
(
mPendingEvents
.
IsEmpty
(
)
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
+
+
i
)
{
for
(
uint32_t
j
=
0
;
j
<
mPendingEvents
.
Length
(
)
;
+
+
j
)
{
mChannelParents
[
i
]
-
>
DispatchUpdateEvent
(
mPendingEvents
[
j
]
)
;
}
}
mPendingEvents
.
Clear
(
)
;
}
void
GamepadPlatformService
:
:
RemoveChannelParent
(
GamepadEventChannelParent
*
aParent
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
mChannelParents
.
Contains
(
aParent
)
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
RemoveElement
(
aParent
)
;
}
bool
GamepadPlatformService
:
:
HasGamepadListeners
(
)
{
AssertIsOnBackgroundThread
(
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
for
(
uint32_t
i
=
0
;
i
<
mChannelParents
.
Length
(
)
;
i
+
+
)
{
if
(
mChannelParents
[
i
]
-
>
HasGamepadListener
(
)
)
{
return
true
;
}
}
return
false
;
}
void
GamepadPlatformService
:
:
MaybeShutdown
(
)
{
AssertIsOnBackgroundThread
(
)
;
RefPtr
<
GamepadPlatformService
>
kungFuDeathGrip
;
bool
isChannelParentEmpty
;
{
MutexAutoLock
autoLock
(
mMutex
)
;
isChannelParentEmpty
=
mChannelParents
.
IsEmpty
(
)
;
if
(
isChannelParentEmpty
)
{
kungFuDeathGrip
=
gGamepadPlatformServiceSingleton
;
gGamepadPlatformServiceSingleton
=
nullptr
;
}
}
}
void
GamepadPlatformService
:
:
Cleanup
(
)
{
AssertIsOnBackgroundThread
(
)
;
MutexAutoLock
autoLock
(
mMutex
)
;
mChannelParents
.
Clear
(
)
;
}
}
}
