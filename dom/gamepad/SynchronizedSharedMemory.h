#
ifndef
DOM_GAMEPAD_SYNCHRONIZEDSHAREDMEMORY_H_
#
define
DOM_GAMEPAD_SYNCHRONIZEDSHAREDMEMORY_H_
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
cinttypes
>
#
include
<
type_traits
>
namespace
mozilla
:
:
ipc
{
class
IProtocol
;
}
namespace
mozilla
:
:
dom
{
class
SynchronizedSharedMemoryRemoteInfo
;
class
SynchronizedSharedMemoryDetail
{
public
:
static
Maybe
<
SynchronizedSharedMemoryDetail
>
CreateNew
(
uint32_t
aSize
)
;
~
SynchronizedSharedMemoryDetail
(
)
;
void
LockMutex
(
)
;
void
UnlockMutex
(
)
;
void
*
GetPtr
(
)
const
;
static
Maybe
<
SynchronizedSharedMemoryDetail
>
CreateFromRemoteInfo
(
const
SynchronizedSharedMemoryRemoteInfo
&
aIPCInfo
)
;
bool
GenerateRemoteInfo
(
const
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
SynchronizedSharedMemoryRemoteInfo
*
aOut
)
;
SynchronizedSharedMemoryDetail
(
SynchronizedSharedMemoryDetail
&
&
)
;
SynchronizedSharedMemoryDetail
&
operator
=
(
SynchronizedSharedMemoryDetail
&
&
)
;
SynchronizedSharedMemoryDetail
(
const
SynchronizedSharedMemoryDetail
&
)
=
delete
;
SynchronizedSharedMemoryDetail
&
operator
=
(
const
SynchronizedSharedMemoryDetail
&
)
=
delete
;
private
:
class
Impl
;
SynchronizedSharedMemoryDetail
(
)
;
explicit
SynchronizedSharedMemoryDetail
(
UniquePtr
<
Impl
>
aImpl
)
;
UniquePtr
<
Impl
>
mImpl
;
template
<
typename
T
>
friend
class
SynchronizedSharedMemory
;
bool
GenerateTestRemoteInfo
(
SynchronizedSharedMemoryRemoteInfo
*
aOut
)
;
}
;
template
<
typename
T
>
class
SynchronizedSharedMemory
{
static_assert
(
std
:
:
is_trivially_copyable
<
T
>
:
:
value
"
SynchronizedSharedMemory
can
only
be
used
with
types
that
are
"
"
trivially
copyable
"
)
;
static_assert
(
std
:
:
is_standard_layout
<
T
>
:
:
value
"
SynchronizedSharedMemory
can
only
be
used
with
types
that
are
"
"
standard
layout
"
)
;
public
:
template
<
typename
.
.
.
Args
>
static
Maybe
<
SynchronizedSharedMemory
>
CreateNew
(
Args
&
&
.
.
.
args
)
{
auto
maybeDetail
=
SynchronizedSharedMemoryDetail
:
:
CreateNew
(
sizeof
(
T
)
)
;
if
(
!
maybeDetail
)
{
return
Nothing
{
}
;
}
new
(
(
*
maybeDetail
)
.
GetPtr
(
)
)
T
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
return
Some
(
SynchronizedSharedMemory
(
std
:
:
move
(
*
maybeDetail
)
)
)
;
}
template
<
typename
Fn
typename
.
.
.
Args
>
void
RunWithLock
(
Fn
&
&
aFn
Args
&
&
.
.
.
args
)
{
mDetail
.
LockMutex
(
)
;
T
localCopy
;
volatile_memcpy
(
&
localCopy
mDetail
.
GetPtr
(
)
sizeof
(
T
)
)
;
(
std
:
:
forward
<
Fn
>
(
aFn
)
)
(
&
localCopy
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
;
volatile_memcpy
(
mDetail
.
GetPtr
(
)
&
localCopy
sizeof
(
T
)
)
;
mDetail
.
UnlockMutex
(
)
;
}
static
Maybe
<
SynchronizedSharedMemory
>
CreateFromRemoteInfo
(
const
SynchronizedSharedMemoryRemoteInfo
&
aIPCInfo
)
{
auto
maybeDetail
=
SynchronizedSharedMemoryDetail
:
:
CreateFromRemoteInfo
(
aIPCInfo
)
;
if
(
!
maybeDetail
)
{
return
Nothing
{
}
;
}
return
Some
(
SynchronizedSharedMemory
(
std
:
:
move
(
*
maybeDetail
)
)
)
;
}
bool
GenerateRemoteInfo
(
const
mozilla
:
:
ipc
:
:
IProtocol
*
aActor
SynchronizedSharedMemoryRemoteInfo
*
aOut
)
{
return
mDetail
.
GenerateRemoteInfo
(
aActor
aOut
)
;
}
SynchronizedSharedMemory
(
SynchronizedSharedMemory
&
&
)
=
default
;
SynchronizedSharedMemory
&
operator
=
(
SynchronizedSharedMemory
&
&
)
=
default
;
SynchronizedSharedMemory
(
const
SynchronizedSharedMemory
&
)
=
delete
;
SynchronizedSharedMemory
&
operator
=
(
const
SynchronizedSharedMemory
&
)
=
delete
;
~
SynchronizedSharedMemory
(
)
=
default
;
private
:
SynchronizedSharedMemory
(
)
=
default
;
explicit
SynchronizedSharedMemory
(
SynchronizedSharedMemoryDetail
aDetail
)
:
mDetail
(
std
:
:
move
(
aDetail
)
)
{
}
void
volatile_memcpy
(
void
*
aDst
const
void
*
aSrc
size_t
aSize
)
{
const
volatile
unsigned
char
*
src
=
static_cast
<
const
volatile
unsigned
char
*
>
(
aSrc
)
;
volatile
unsigned
char
*
dst
=
static_cast
<
volatile
unsigned
char
*
>
(
aDst
)
;
size_t
remaining
=
aSize
;
while
(
remaining
)
{
*
dst
=
*
src
;
+
+
src
;
+
+
dst
;
-
-
remaining
;
}
}
SynchronizedSharedMemoryDetail
mDetail
;
friend
class
SynchronizedSharedMemoryTestFriend
;
bool
GenerateTestRemoteInfo
(
SynchronizedSharedMemoryRemoteInfo
*
aOut
)
{
return
mDetail
.
GenerateTestRemoteInfo
(
aOut
)
;
}
}
;
}
#
endif
