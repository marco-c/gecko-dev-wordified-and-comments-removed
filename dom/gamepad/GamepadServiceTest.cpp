#
include
"
GamepadServiceTest
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
GamepadManager
.
h
"
#
include
"
mozilla
/
dom
/
GamepadPlatformService
.
h
"
#
include
"
mozilla
/
dom
/
GamepadServiceTestBinding
.
h
"
#
include
"
mozilla
/
dom
/
GamepadTestChannelChild
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
GamepadServiceTest
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
GamepadServiceTest
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
GamepadServiceTest
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
GamepadServiceTest
)
NS_INTERFACE_MAP_ENTRY
(
nsIIPCBackgroundChildCreateCallback
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
GamepadServiceTest
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
GamepadServiceTest
DOMEventTargetHelper
)
already_AddRefed
<
GamepadServiceTest
>
GamepadServiceTest
:
:
CreateTestService
(
nsPIDOMWindowInner
*
aWindow
)
{
MOZ_ASSERT
(
aWindow
)
;
RefPtr
<
GamepadServiceTest
>
service
=
new
GamepadServiceTest
(
aWindow
)
;
service
-
>
InitPBackgroundActor
(
)
;
return
service
.
forget
(
)
;
}
void
GamepadServiceTest
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
!
mShuttingDown
)
;
mShuttingDown
=
true
;
DestroyPBackgroundActor
(
)
;
mWindow
=
nullptr
;
}
GamepadServiceTest
:
:
GamepadServiceTest
(
nsPIDOMWindowInner
*
aWindow
)
:
mService
(
GamepadManager
:
:
GetService
(
)
)
mWindow
(
aWindow
)
mEventNumber
(
0
)
mShuttingDown
(
false
)
mChild
(
nullptr
)
{
}
GamepadServiceTest
:
:
~
GamepadServiceTest
(
)
{
}
void
GamepadServiceTest
:
:
InitPBackgroundActor
(
)
{
MOZ_ASSERT
(
!
mChild
)
;
PBackgroundChild
*
actor
=
BackgroundChild
:
:
GetForCurrentThread
(
)
;
if
(
actor
)
{
ActorCreated
(
actor
)
;
}
else
{
Unused
<
<
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
this
)
;
}
}
void
GamepadServiceTest
:
:
DestroyPBackgroundActor
(
)
{
if
(
mChild
)
{
MOZ_ASSERT
(
mPendingOperations
.
IsEmpty
(
)
)
;
mChild
-
>
SendShutdownChannel
(
)
;
mChild
=
nullptr
;
}
else
{
mPendingOperations
.
Clear
(
)
;
}
}
already_AddRefed
<
Promise
>
GamepadServiceTest
:
:
AddGamepad
(
const
nsAString
&
aID
GamepadMappingType
aMapping
uint32_t
aNumButtons
uint32_t
aNumAxes
ErrorResult
&
aRv
)
{
if
(
mShuttingDown
)
{
return
nullptr
;
}
GamepadAdded
a
(
nsString
(
aID
)
0
aMapping
GamepadHand
:
:
_empty
GamepadServiceType
:
:
Standard
aNumButtons
aNumAxes
)
;
GamepadChangeEvent
e
(
a
)
;
nsCOMPtr
<
nsIGlobalObject
>
go
=
do_QueryInterface
(
mWindow
)
;
RefPtr
<
Promise
>
p
=
Promise
:
:
Create
(
go
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
uint32_t
id
=
+
+
mEventNumber
;
if
(
mChild
)
{
mChild
-
>
AddPromise
(
id
p
)
;
mChild
-
>
SendGamepadTestEvent
(
id
e
)
;
}
else
{
PendingOperation
op
(
id
e
p
)
;
mPendingOperations
.
AppendElement
(
op
)
;
}
return
p
.
forget
(
)
;
}
void
GamepadServiceTest
:
:
RemoveGamepad
(
uint32_t
aIndex
)
{
if
(
mShuttingDown
)
{
return
;
}
GamepadRemoved
a
(
aIndex
GamepadServiceType
:
:
Standard
)
;
GamepadChangeEvent
e
(
a
)
;
uint32_t
id
=
+
+
mEventNumber
;
if
(
mChild
)
{
mChild
-
>
SendGamepadTestEvent
(
id
e
)
;
}
else
{
PendingOperation
op
(
id
e
)
;
mPendingOperations
.
AppendElement
(
op
)
;
}
}
void
GamepadServiceTest
:
:
NewButtonEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
)
{
if
(
mShuttingDown
)
{
return
;
}
GamepadButtonInformation
a
(
aIndex
GamepadServiceType
:
:
Standard
aButton
aPressed
aPressed
?
1
.
0
:
0
)
;
GamepadChangeEvent
e
(
a
)
;
uint32_t
id
=
+
+
mEventNumber
;
if
(
mChild
)
{
mChild
-
>
SendGamepadTestEvent
(
id
e
)
;
}
else
{
PendingOperation
op
(
id
e
)
;
mPendingOperations
.
AppendElement
(
op
)
;
}
}
void
GamepadServiceTest
:
:
NewButtonValueEvent
(
uint32_t
aIndex
uint32_t
aButton
bool
aPressed
double
aValue
)
{
if
(
mShuttingDown
)
{
return
;
}
GamepadButtonInformation
a
(
aIndex
GamepadServiceType
:
:
Standard
aButton
aPressed
aValue
)
;
GamepadChangeEvent
e
(
a
)
;
uint32_t
id
=
+
+
mEventNumber
;
if
(
mChild
)
{
mChild
-
>
SendGamepadTestEvent
(
id
e
)
;
}
else
{
PendingOperation
op
(
id
e
)
;
mPendingOperations
.
AppendElement
(
op
)
;
}
}
void
GamepadServiceTest
:
:
NewAxisMoveEvent
(
uint32_t
aIndex
uint32_t
aAxis
double
aValue
)
{
if
(
mShuttingDown
)
{
return
;
}
GamepadAxisInformation
a
(
aIndex
GamepadServiceType
:
:
Standard
aAxis
aValue
)
;
GamepadChangeEvent
e
(
a
)
;
uint32_t
id
=
+
+
mEventNumber
;
if
(
mChild
)
{
mChild
-
>
SendGamepadTestEvent
(
id
e
)
;
}
else
{
PendingOperation
op
(
id
e
)
;
mPendingOperations
.
AppendElement
(
op
)
;
}
}
void
GamepadServiceTest
:
:
FlushPendingOperations
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mPendingOperations
.
Length
(
)
;
+
+
i
)
{
PendingOperation
op
=
mPendingOperations
[
i
]
;
if
(
op
.
mPromise
)
{
mChild
-
>
AddPromise
(
op
.
mID
op
.
mPromise
)
;
}
mChild
-
>
SendGamepadTestEvent
(
op
.
mID
op
.
mEvent
)
;
}
mPendingOperations
.
Clear
(
)
;
}
void
GamepadServiceTest
:
:
ActorCreated
(
PBackgroundChild
*
aActor
)
{
MOZ_ASSERT
(
aActor
)
;
if
(
mShuttingDown
)
{
MOZ_ASSERT
(
mPendingOperations
.
IsEmpty
(
)
)
;
return
;
}
mChild
=
new
GamepadTestChannelChild
(
)
;
PGamepadTestChannelChild
*
initedChild
=
aActor
-
>
SendPGamepadTestChannelConstructor
(
mChild
)
;
if
(
NS_WARN_IF
(
!
initedChild
)
)
{
ActorFailed
(
)
;
return
;
}
FlushPendingOperations
(
)
;
}
void
GamepadServiceTest
:
:
ActorFailed
(
)
{
MOZ_CRASH
(
"
Failed
to
create
background
child
actor
!
"
)
;
}
JSObject
*
GamepadServiceTest
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
HandleObject
aGivenProto
)
{
return
GamepadServiceTestBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
}
}
