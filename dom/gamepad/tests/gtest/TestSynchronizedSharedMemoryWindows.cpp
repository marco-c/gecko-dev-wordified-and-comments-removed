#
include
"
mozilla
/
dom
/
SynchronizedSharedMemory
.
h
"
#
include
"
mozilla
/
dom
/
SynchronizedSharedMemoryRemoteInfo
.
h
"
#
include
<
array
>
#
include
<
atomic
>
#
include
<
chrono
>
#
include
<
thread
>
#
include
<
windows
.
h
>
#
include
"
gtest
/
gtest
.
h
"
namespace
mozilla
:
:
dom
{
class
SynchronizedSharedMemoryTestFriend
{
public
:
template
<
typename
T
>
static
bool
GenerateRemoteInfo
(
SynchronizedSharedMemory
<
T
>
&
aSharedMemory
SynchronizedSharedMemoryRemoteInfo
*
aOut
)
{
return
aSharedMemory
.
GenerateTestRemoteInfo
(
aOut
)
;
}
}
;
TEST
(
SynchronizedSharedMemoryTest
Basic
)
{
auto
maybeLocalObject
=
SynchronizedSharedMemory
<
int
>
:
:
CreateNew
(
0
)
;
ASSERT_TRUE
(
maybeLocalObject
)
;
SynchronizedSharedMemoryRemoteInfo
remoteInfo
;
ASSERT_TRUE
(
SynchronizedSharedMemoryTestFriend
:
:
GenerateRemoteInfo
(
*
maybeLocalObject
&
remoteInfo
)
)
;
auto
maybeRemoteObject
=
SynchronizedSharedMemory
<
int
>
:
:
CreateFromRemoteInfo
(
remoteInfo
)
;
ASSERT_TRUE
(
maybeRemoteObject
)
;
(
*
maybeLocalObject
)
.
RunWithLock
(
[
]
(
int
*
ptr
int
value
)
{
*
ptr
=
value
;
}
5
)
;
int
value
=
0
;
(
*
maybeRemoteObject
)
.
RunWithLock
(
[
&
value
]
(
int
*
ptr
)
{
value
=
*
ptr
;
}
)
;
ASSERT_EQ
(
value
5
)
;
}
TEST
(
SynchronizedSharedMemoryTest
Multithreaded
)
{
struct
TestStruct
{
std
:
:
array
<
uint64_t
16
>
data
;
void
WriteValueToAll
(
uint64_t
value
)
{
for
(
auto
&
x
:
data
)
{
x
=
value
;
}
}
void
AddValueToAll
(
uint64_t
value
)
{
for
(
auto
&
x
:
data
)
{
x
+
=
value
;
}
}
void
AssertAllEqual
(
uint64_t
value
)
const
{
for
(
size_t
i
=
0
;
i
<
(
data
.
size
(
)
-
1
)
;
+
+
i
)
{
ASSERT_EQ
(
data
[
i
]
data
[
i
+
1
]
)
;
}
}
void
AssertEq
(
const
TestStruct
&
other
)
const
{
for
(
size_t
i
=
0
;
i
<
data
.
size
(
)
;
+
+
i
)
{
ASSERT_EQ
(
data
[
i
]
other
.
data
[
i
]
)
;
}
}
}
;
using
SharedType
=
SynchronizedSharedMemory
<
TestStruct
>
;
constexpr
size_t
kNumThreads
=
4
;
constexpr
uint64_t
kTestStartValue
=
0x1234
;
constexpr
uint64_t
kTestIncrementAmount
=
0x5678
;
constexpr
uint32_t
kMinimumChangesToWitness
=
10000
;
constexpr
TestStruct
kInitialStruct
=
{
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
}
;
auto
maybeLocalObject
=
SharedType
:
:
CreateNew
(
kInitialStruct
)
;
ASSERT_TRUE
(
maybeLocalObject
)
;
maybeLocalObject
-
>
RunWithLock
(
[
&
]
(
TestStruct
*
shared
)
{
shared
-
>
AssertEq
(
kInitialStruct
)
;
shared
-
>
WriteValueToAll
(
kTestStartValue
)
;
shared
-
>
AssertAllEqual
(
kTestStartValue
)
;
}
)
;
std
:
:
atomic_bool
done
{
false
}
;
std
:
:
array
<
std
:
:
thread
kNumThreads
>
workerThreads
;
for
(
auto
&
t
:
workerThreads
)
{
SynchronizedSharedMemoryRemoteInfo
remoteInfo
;
ASSERT_TRUE
(
SynchronizedSharedMemoryTestFriend
:
:
GenerateRemoteInfo
(
*
maybeLocalObject
&
remoteInfo
)
)
;
t
=
std
:
:
thread
(
[
remoteInfo
&
done
]
{
auto
maybeRemoteObject
=
SharedType
:
:
CreateFromRemoteInfo
(
remoteInfo
)
;
ASSERT_TRUE
(
maybeRemoteObject
)
;
while
(
!
done
.
load
(
std
:
:
memory_order_relaxed
)
)
{
maybeRemoteObject
-
>
RunWithLock
(
[
&
]
(
TestStruct
*
shared
)
{
shared
-
>
AssertAllEqual
(
shared
-
>
data
[
0
]
)
;
shared
-
>
AddValueToAll
(
kTestIncrementAmount
)
;
shared
-
>
AssertAllEqual
(
shared
-
>
data
[
0
]
)
;
}
)
;
}
}
)
;
}
uint64_t
numChangesWitnessed
=
0
;
uint64_t
lastValueWitnessed
=
kTestStartValue
;
while
(
numChangesWitnessed
<
kMinimumChangesToWitness
)
{
uint64_t
valueWitnessed
=
0
;
maybeLocalObject
-
>
RunWithLock
(
[
&
]
(
TestStruct
*
shared
)
{
valueWitnessed
=
shared
-
>
data
[
0
]
;
shared
-
>
AssertAllEqual
(
valueWitnessed
)
;
}
)
;
if
(
lastValueWitnessed
!
=
valueWitnessed
)
{
+
+
numChangesWitnessed
;
lastValueWitnessed
=
valueWitnessed
;
}
}
done
.
store
(
true
std
:
:
memory_order_relaxed
)
;
for
(
auto
&
t
:
workerThreads
)
{
t
.
join
(
)
;
}
}
}
