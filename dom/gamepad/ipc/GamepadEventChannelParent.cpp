#
include
"
GamepadEventChannelParent
.
h
"
#
include
"
GamepadPlatformService
.
h
"
#
include
"
mozilla
/
dom
/
GamepadMonitoring
.
h
"
#
include
"
nsThreadUtils
.
h
"
namespace
mozilla
{
namespace
dom
{
using
namespace
mozilla
:
:
ipc
;
namespace
{
class
SendGamepadUpdateRunnable
final
:
public
Runnable
{
private
:
~
SendGamepadUpdateRunnable
(
)
{
}
RefPtr
<
GamepadEventChannelParent
>
mParent
;
GamepadChangeEvent
mEvent
;
public
:
SendGamepadUpdateRunnable
(
GamepadEventChannelParent
*
aParent
GamepadChangeEvent
aEvent
)
:
Runnable
(
"
dom
:
:
SendGamepadUpdateRunnable
"
)
mEvent
(
aEvent
)
{
MOZ_ASSERT
(
aParent
)
;
mParent
=
aParent
;
}
NS_IMETHOD
Run
(
)
override
{
AssertIsOnBackgroundThread
(
)
;
if
(
mParent
-
>
HasGamepadListener
(
)
)
{
Unused
<
<
mParent
-
>
SendGamepadUpdate
(
mEvent
)
;
}
return
NS_OK
;
}
}
;
}
GamepadEventChannelParent
:
:
GamepadEventChannelParent
(
)
:
mHasGamepadListener
(
false
)
{
RefPtr
<
GamepadPlatformService
>
service
=
GamepadPlatformService
:
:
GetParentService
(
)
;
MOZ_ASSERT
(
service
)
;
mBackgroundEventTarget
=
GetCurrentThreadEventTarget
(
)
;
service
-
>
AddChannelParent
(
this
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GamepadEventChannelParent
:
:
RecvGamepadListenerAdded
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
!
mHasGamepadListener
)
;
mHasGamepadListener
=
true
;
StartGamepadMonitoring
(
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GamepadEventChannelParent
:
:
RecvGamepadListenerRemoved
(
)
{
AssertIsOnBackgroundThread
(
)
;
MOZ_ASSERT
(
mHasGamepadListener
)
;
mHasGamepadListener
=
false
;
RefPtr
<
GamepadPlatformService
>
service
=
GamepadPlatformService
:
:
GetParentService
(
)
;
MOZ_ASSERT
(
service
)
;
service
-
>
RemoveChannelParent
(
this
)
;
Unused
<
<
Send__delete__
(
this
)
;
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GamepadEventChannelParent
:
:
RecvVibrateHaptic
(
const
uint32_t
&
aControllerIdx
const
uint32_t
&
aHapticIndex
const
double
&
aIntensity
const
double
&
aDuration
const
uint32_t
&
aPromiseID
)
{
if
(
SendReplyGamepadPromise
(
aPromiseID
)
)
{
return
IPC_OK
(
)
;
}
return
IPC_FAIL
(
this
"
SendReplyGamepadPromise
fail
.
"
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GamepadEventChannelParent
:
:
RecvStopVibrateHaptic
(
const
uint32_t
&
aControllerIdx
)
{
return
IPC_OK
(
)
;
}
mozilla
:
:
ipc
:
:
IPCResult
GamepadEventChannelParent
:
:
RecvLightIndicatorColor
(
const
uint32_t
&
aControllerIdx
const
uint32_t
&
aLightColorIndex
const
uint8_t
&
aRed
const
uint8_t
&
aGreen
const
uint8_t
&
aBlue
const
uint32_t
&
aPromiseID
)
{
if
(
mHasGamepadListener
)
{
SetGamepadLightIndicatorColor
(
aControllerIdx
aLightColorIndex
aRed
aGreen
aBlue
)
;
}
if
(
SendReplyGamepadPromise
(
aPromiseID
)
)
{
return
IPC_OK
(
)
;
}
return
IPC_FAIL
(
this
"
SendReplyGamepadPromise
fail
.
"
)
;
}
void
GamepadEventChannelParent
:
:
ActorDestroy
(
ActorDestroyReason
aWhy
)
{
AssertIsOnBackgroundThread
(
)
;
if
(
mHasGamepadListener
)
{
mHasGamepadListener
=
false
;
RefPtr
<
GamepadPlatformService
>
service
=
GamepadPlatformService
:
:
GetParentService
(
)
;
MOZ_ASSERT
(
service
)
;
service
-
>
RemoveChannelParent
(
this
)
;
}
MaybeStopGamepadMonitoring
(
)
;
}
void
GamepadEventChannelParent
:
:
DispatchUpdateEvent
(
const
GamepadChangeEvent
&
aEvent
)
{
mBackgroundEventTarget
-
>
Dispatch
(
new
SendGamepadUpdateRunnable
(
this
aEvent
)
NS_DISPATCH_NORMAL
)
;
}
}
}
