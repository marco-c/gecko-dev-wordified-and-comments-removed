#
ifndef
mozilla_dom_InternalResponse_h
#
define
mozilla_dom_InternalResponse_h
#
include
"
nsIInputStream
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
mozilla
/
dom
/
InternalHeaders
.
h
"
#
include
"
mozilla
/
dom
/
ResponseBinding
.
h
"
#
include
"
mozilla
/
dom
/
ChannelInfo
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
namespace
ipc
{
class
PrincipalInfo
;
class
AutoIPCStream
;
}
namespace
dom
{
class
InternalHeaders
;
class
IPCInternalResponse
;
class
InternalResponse
final
{
friend
class
FetchDriver
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
InternalResponse
)
InternalResponse
(
uint16_t
aStatus
const
nsACString
&
aStatusText
)
;
static
already_AddRefed
<
InternalResponse
>
FromIPC
(
const
IPCInternalResponse
&
aIPCResponse
)
;
template
<
typename
M
>
void
ToIPC
(
IPCInternalResponse
*
aIPCResponse
M
*
aManager
UniquePtr
<
mozilla
:
:
ipc
:
:
AutoIPCStream
>
&
aAutoStream
)
;
enum
CloneType
{
eCloneInputStream
eDontCloneInputStream
}
;
already_AddRefed
<
InternalResponse
>
Clone
(
CloneType
eCloneType
)
;
static
already_AddRefed
<
InternalResponse
>
NetworkError
(
nsresult
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
NS_FAILED
(
aRv
)
)
;
RefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
0
EmptyCString
(
)
)
;
ErrorResult
result
;
response
-
>
Headers
(
)
-
>
SetGuard
(
HeadersGuardEnum
:
:
Immutable
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
response
-
>
mType
=
ResponseType
:
:
Error
;
response
-
>
mErrorCode
=
aRv
;
return
response
.
forget
(
)
;
}
already_AddRefed
<
InternalResponse
>
OpaqueResponse
(
)
;
already_AddRefed
<
InternalResponse
>
OpaqueRedirectResponse
(
)
;
already_AddRefed
<
InternalResponse
>
BasicResponse
(
)
;
already_AddRefed
<
InternalResponse
>
CORSResponse
(
)
;
ResponseType
Type
(
)
const
{
MOZ_ASSERT_IF
(
mType
=
=
ResponseType
:
:
Error
!
mWrappedResponse
)
;
MOZ_ASSERT_IF
(
mType
=
=
ResponseType
:
:
Default
!
mWrappedResponse
)
;
MOZ_ASSERT_IF
(
mType
=
=
ResponseType
:
:
Basic
mWrappedResponse
)
;
MOZ_ASSERT_IF
(
mType
=
=
ResponseType
:
:
Cors
mWrappedResponse
)
;
MOZ_ASSERT_IF
(
mType
=
=
ResponseType
:
:
Opaque
mWrappedResponse
)
;
MOZ_ASSERT_IF
(
mType
=
=
ResponseType
:
:
Opaqueredirect
mWrappedResponse
)
;
return
mType
;
}
bool
IsError
(
)
const
{
return
Type
(
)
=
=
ResponseType
:
:
Error
;
}
const
nsCString
&
GetURL
(
)
const
{
if
(
mURLList
.
IsEmpty
(
)
)
{
return
EmptyCString
(
)
;
}
return
mURLList
.
LastElement
(
)
;
}
void
GetURLList
(
nsTArray
<
nsCString
>
&
aURLList
)
const
{
aURLList
.
Assign
(
mURLList
)
;
}
const
nsCString
&
GetUnfilteredURL
(
)
const
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
GetURL
(
)
;
}
return
GetURL
(
)
;
}
void
GetUnfilteredURLList
(
nsTArray
<
nsCString
>
&
aURLList
)
const
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
GetURLList
(
aURLList
)
;
}
return
GetURLList
(
aURLList
)
;
}
void
SetURLList
(
const
nsTArray
<
nsCString
>
&
aURLList
)
{
mURLList
.
Assign
(
aURLList
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
mURLList
.
Length
(
)
;
+
+
i
)
{
MOZ_ASSERT
(
mURLList
[
i
]
.
Find
(
NS_LITERAL_CSTRING
(
"
#
"
)
)
=
=
kNotFound
)
;
}
#
endif
}
uint16_t
GetStatus
(
)
const
{
return
mStatus
;
}
uint16_t
GetUnfilteredStatus
(
)
const
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
GetStatus
(
)
;
}
return
GetStatus
(
)
;
}
const
nsCString
&
GetStatusText
(
)
const
{
return
mStatusText
;
}
const
nsCString
&
GetUnfilteredStatusText
(
)
const
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
GetStatusText
(
)
;
}
return
GetStatusText
(
)
;
}
InternalHeaders
*
Headers
(
)
{
return
mHeaders
;
}
InternalHeaders
*
UnfilteredHeaders
(
)
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
Headers
(
)
;
}
;
return
Headers
(
)
;
}
void
GetUnfilteredBody
(
nsIInputStream
*
*
aStream
int64_t
*
aBodySize
=
nullptr
)
{
if
(
mWrappedResponse
)
{
MOZ_ASSERT
(
!
mBody
)
;
return
mWrappedResponse
-
>
GetBody
(
aStream
aBodySize
)
;
}
nsCOMPtr
<
nsIInputStream
>
stream
=
mBody
;
stream
.
forget
(
aStream
)
;
if
(
aBodySize
)
{
*
aBodySize
=
mBodySize
;
}
}
void
GetBody
(
nsIInputStream
*
*
aStream
int64_t
*
aBodySize
=
nullptr
)
{
if
(
Type
(
)
=
=
ResponseType
:
:
Opaque
|
|
Type
(
)
=
=
ResponseType
:
:
Opaqueredirect
)
{
*
aStream
=
nullptr
;
if
(
aBodySize
)
{
*
aBodySize
=
UNKNOWN_BODY_SIZE
;
}
return
;
}
GetUnfilteredBody
(
aStream
aBodySize
)
;
}
void
SetBody
(
nsIInputStream
*
aBody
int64_t
aBodySize
)
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
SetBody
(
aBody
aBodySize
)
;
}
MOZ_ASSERT
(
!
mBody
)
;
MOZ_ASSERT
(
mBodySize
=
=
UNKNOWN_BODY_SIZE
)
;
MOZ_ASSERT
(
aBodySize
=
=
UNKNOWN_BODY_SIZE
|
|
aBodySize
>
=
0
)
;
MOZ_ASSERT_IF
(
!
aBody
aBodySize
=
=
UNKNOWN_BODY_SIZE
)
;
mBody
=
aBody
;
mBodySize
=
aBodySize
;
}
uint32_t
GetPaddingInfo
(
)
;
nsresult
GeneratePaddingInfo
(
)
;
int64_t
GetPaddingSize
(
)
;
void
SetPaddingSize
(
int64_t
aPaddingSize
)
;
void
SetAlternativeBody
(
nsIInputStream
*
aAlternativeBody
)
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
SetAlternativeBody
(
aAlternativeBody
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mAlternativeBody
)
;
mAlternativeBody
=
aAlternativeBody
;
}
already_AddRefed
<
nsIInputStream
>
TakeAlternativeBody
(
)
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
TakeAlternativeBody
(
)
;
}
if
(
!
mAlternativeBody
)
{
return
nullptr
;
}
mBody
=
nullptr
;
mBodySize
=
UNKNOWN_BODY_SIZE
;
return
mAlternativeBody
.
forget
(
)
;
}
void
SetCacheInfoChannel
(
nsICacheInfoChannel
*
aCacheInfoChannel
)
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
SetCacheInfoChannel
(
aCacheInfoChannel
)
;
}
mCacheInfoChannel
=
aCacheInfoChannel
;
}
already_AddRefed
<
nsICacheInfoChannel
>
TakeCacheInfoChannel
(
)
{
if
(
mWrappedResponse
)
{
return
mWrappedResponse
-
>
TakeCacheInfoChannel
(
)
;
}
return
mCacheInfoChannel
.
forget
(
)
;
}
void
InitChannelInfo
(
nsIChannel
*
aChannel
)
{
mChannelInfo
.
InitFromChannel
(
aChannel
)
;
}
void
InitChannelInfo
(
const
mozilla
:
:
ipc
:
:
IPCChannelInfo
&
aChannelInfo
)
{
mChannelInfo
.
InitFromIPCChannelInfo
(
aChannelInfo
)
;
}
void
InitChannelInfo
(
const
ChannelInfo
&
aChannelInfo
)
{
mChannelInfo
=
aChannelInfo
;
}
const
ChannelInfo
&
GetChannelInfo
(
)
const
{
return
mChannelInfo
;
}
const
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
&
GetPrincipalInfo
(
)
const
{
return
mPrincipalInfo
;
}
bool
IsRedirected
(
)
const
{
return
mURLList
.
Length
(
)
>
1
;
}
nsresult
GetErrorCode
(
)
const
{
return
mErrorCode
;
}
void
SetPrincipalInfo
(
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
aPrincipalInfo
)
;
LoadTainting
GetTainting
(
)
const
;
already_AddRefed
<
InternalResponse
>
Unfiltered
(
)
;
private
:
~
InternalResponse
(
)
;
explicit
InternalResponse
(
const
InternalResponse
&
aOther
)
=
delete
;
InternalResponse
&
operator
=
(
const
InternalResponse
&
)
=
delete
;
already_AddRefed
<
InternalResponse
>
CreateIncompleteCopy
(
)
;
ResponseType
mType
;
nsCString
mTerminationReason
;
nsTArray
<
nsCString
>
mURLList
;
const
uint16_t
mStatus
;
const
nsCString
mStatusText
;
RefPtr
<
InternalHeaders
>
mHeaders
;
nsCOMPtr
<
nsIInputStream
>
mBody
;
int64_t
mBodySize
;
Maybe
<
uint32_t
>
mPaddingInfo
;
int64_t
mPaddingSize
;
nsresult
mErrorCode
;
nsCOMPtr
<
nsIInputStream
>
mAlternativeBody
;
nsCOMPtr
<
nsICacheInfoChannel
>
mCacheInfoChannel
;
public
:
static
const
int64_t
UNKNOWN_BODY_SIZE
=
-
1
;
static
const
int64_t
UNKNOWN_PADDING_SIZE
=
-
1
;
private
:
ChannelInfo
mChannelInfo
;
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
mPrincipalInfo
;
RefPtr
<
InternalResponse
>
mWrappedResponse
;
}
;
}
}
#
endif
