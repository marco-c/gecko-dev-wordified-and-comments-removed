#
ifndef
mozilla_dom_FetchDriver_h
#
define
mozilla_dom_FetchDriver_h
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsICacheInfoChannel
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
SerializedStackHolder
.
h
"
#
include
"
mozilla
/
dom
/
SRIMetadata
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
class
nsIConsoleReportCollector
;
class
nsICookieSettings
;
class
nsICSPEventListener
;
class
nsIEventTarget
;
class
nsIOutputStream
;
class
nsILoadGroup
;
class
nsIPrincipal
;
namespace
mozilla
{
namespace
dom
{
class
Document
;
class
InternalRequest
;
class
InternalResponse
;
class
PerformanceStorage
;
class
FetchDriverObserver
{
public
:
FetchDriverObserver
(
)
:
mReporter
(
new
ConsoleReportCollector
(
)
)
mGotResponseAvailable
(
false
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FetchDriverObserver
)
;
void
OnResponseAvailable
(
InternalResponse
*
aResponse
)
{
MOZ_ASSERT
(
!
mGotResponseAvailable
)
;
mGotResponseAvailable
=
true
;
OnResponseAvailableInternal
(
aResponse
)
;
}
enum
EndReason
{
eAborted
eByNetworking
}
;
virtual
void
OnResponseEnd
(
EndReason
aReason
)
{
}
;
nsIConsoleReportCollector
*
GetReporter
(
)
const
{
return
mReporter
;
}
virtual
void
FlushConsoleReport
(
)
=
0
;
virtual
bool
NeedOnDataAvailable
(
)
=
0
;
virtual
void
OnDataAvailable
(
)
=
0
;
protected
:
virtual
~
FetchDriverObserver
(
)
{
}
;
virtual
void
OnResponseAvailableInternal
(
InternalResponse
*
aResponse
)
=
0
;
nsCOMPtr
<
nsIConsoleReportCollector
>
mReporter
;
private
:
bool
mGotResponseAvailable
;
}
;
class
AlternativeDataStreamListener
;
class
FetchDriver
final
:
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIInterfaceRequestor
public
nsIThreadRetargetableStreamListener
public
AbortFollower
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
FetchDriver
(
InternalRequest
*
aRequest
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
nsIEventTarget
*
aMainThreadEventTarget
nsICookieSettings
*
aCookieSettings
PerformanceStorage
*
aPerformanceStorage
bool
aIsTrackingFetch
)
;
nsresult
Fetch
(
AbortSignalImpl
*
aSignalImpl
FetchDriverObserver
*
aObserver
)
;
void
SetDocument
(
Document
*
aDocument
)
;
void
SetCSPEventListener
(
nsICSPEventListener
*
aCSPEventListener
)
;
void
SetClientInfo
(
const
ClientInfo
&
aClientInfo
)
;
void
SetController
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
)
;
void
SetWorkerScript
(
const
nsACString
&
aWorkerScript
)
{
MOZ_ASSERT
(
!
aWorkerScript
.
IsEmpty
(
)
)
;
mWorkerScript
=
aWorkerScript
;
}
void
SetOriginStack
(
UniquePtr
<
SerializedStackHolder
>
&
&
aOriginStack
)
{
mOriginStack
=
std
:
:
move
(
aOriginStack
)
;
}
void
Abort
(
)
override
;
private
:
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
RefPtr
<
InternalRequest
>
mRequest
;
RefPtr
<
InternalResponse
>
mResponse
;
nsCOMPtr
<
nsIOutputStream
>
mPipeOutputStream
;
RefPtr
<
FetchDriverObserver
>
mObserver
;
RefPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsICSPEventListener
>
mCSPEventListener
;
Maybe
<
ClientInfo
>
mClientInfo
;
Maybe
<
ServiceWorkerDescriptor
>
mController
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
nsAutoPtr
<
SRICheckDataVerifier
>
mSRIDataVerifier
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
nsCOMPtr
<
nsICookieSettings
>
mCookieSettings
;
RefPtr
<
PerformanceStorage
>
mPerformanceStorage
;
SRIMetadata
mSRIMetadata
;
nsCString
mWorkerScript
;
UniquePtr
<
SerializedStackHolder
>
mOriginStack
;
bool
mNeedToObserveOnDataAvailable
;
bool
mIsTrackingFetch
;
RefPtr
<
AlternativeDataStreamListener
>
mAltDataListener
;
bool
mOnStopRequestCalled
;
#
ifdef
DEBUG
bool
mResponseAvailableCalled
;
bool
mFetchCalled
;
#
endif
friend
class
AlternativeDataStreamListener
;
FetchDriver
(
)
=
delete
;
FetchDriver
(
const
FetchDriver
&
)
=
delete
;
FetchDriver
&
operator
=
(
const
FetchDriver
&
)
=
delete
;
~
FetchDriver
(
)
;
nsresult
HttpFetch
(
const
nsACString
&
aPreferredAlternativeDataType
=
EmptyCString
(
)
)
;
already_AddRefed
<
InternalResponse
>
BeginAndGetFilteredResponse
(
InternalResponse
*
aResponse
bool
aFoundOpaqueRedirect
)
;
void
FailWithNetworkError
(
nsresult
rv
)
;
void
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
)
const
;
void
FinishOnStopRequest
(
AlternativeDataStreamListener
*
aAltDataListener
)
;
}
;
}
}
#
endif
