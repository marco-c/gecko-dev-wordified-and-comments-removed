#
ifndef
mozilla_dom_FetchDriver_h
#
define
mozilla_dom_FetchDriver_h
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsINetworkInterceptController
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
SafeRefPtr
.
h
"
#
include
"
mozilla
/
dom
/
SerializedStackHolder
.
h
"
#
include
"
mozilla
/
dom
/
SRIMetadata
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Mutex
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
class
nsIConsoleReportCollector
;
class
nsICookieJarSettings
;
class
nsICSPEventListener
;
class
nsIEventTarget
;
class
nsIOutputStream
;
class
nsILoadGroup
;
class
nsIPrincipal
;
namespace
mozilla
{
class
PreloaderBase
;
namespace
dom
{
class
Document
;
class
InternalRequest
;
class
InternalResponse
;
class
PerformanceStorage
;
class
PerformanceTimingData
;
class
FetchDriverObserver
{
public
:
FetchDriverObserver
(
)
:
mReporter
(
new
ConsoleReportCollector
(
)
)
mGotResponseAvailable
(
false
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FetchDriverObserver
)
;
void
OnResponseAvailable
(
SafeRefPtr
<
InternalResponse
>
aResponse
)
;
enum
EndReason
{
eAborted
eByNetworking
}
;
virtual
void
OnResponseEnd
(
EndReason
aReason
JS
:
:
Handle
<
JS
:
:
Value
>
aReasonDetails
)
{
}
;
nsIConsoleReportCollector
*
GetReporter
(
)
const
{
return
mReporter
;
}
virtual
void
FlushConsoleReport
(
)
=
0
;
virtual
bool
NeedOnDataAvailable
(
)
=
0
;
virtual
void
OnDataAvailable
(
)
=
0
;
virtual
void
OnReportPerformanceTiming
(
)
{
}
virtual
void
OnNotifyNetworkMonitorAlternateStack
(
uint64_t
aChannelID
)
{
}
protected
:
virtual
~
FetchDriverObserver
(
)
=
default
;
virtual
void
OnResponseAvailableInternal
(
SafeRefPtr
<
InternalResponse
>
aResponse
)
=
0
;
nsCOMPtr
<
nsIConsoleReportCollector
>
mReporter
;
private
:
bool
mGotResponseAvailable
;
}
;
class
AlternativeDataStreamListener
;
class
FetchDriver
final
:
public
nsIChannelEventSink
public
nsIInterfaceRequestor
public
nsINetworkInterceptController
public
nsIThreadRetargetableStreamListener
public
AbortFollower
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSINETWORKINTERCEPTCONTROLLER
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
FetchDriver
(
SafeRefPtr
<
InternalRequest
>
aRequest
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
nsIEventTarget
*
aMainThreadEventTarget
nsICookieJarSettings
*
aCookieJarSettings
PerformanceStorage
*
aPerformanceStorage
net
:
:
ClassificationFlags
aTrackingFlags
)
;
nsresult
Fetch
(
AbortSignalImpl
*
aSignalImpl
FetchDriverObserver
*
aObserver
)
;
void
SetDocument
(
Document
*
aDocument
)
;
void
SetCSPEventListener
(
nsICSPEventListener
*
aCSPEventListener
)
;
void
SetClientInfo
(
const
ClientInfo
&
aClientInfo
)
;
void
SetController
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
)
;
void
SetWorkerScript
(
const
nsACString
&
aWorkerScript
)
{
MOZ_ASSERT
(
!
aWorkerScript
.
IsEmpty
(
)
)
;
mWorkerScript
=
aWorkerScript
;
}
void
SetOriginStack
(
UniquePtr
<
SerializedStackHolder
>
&
&
aOriginStack
)
{
mOriginStack
=
std
:
:
move
(
aOriginStack
)
;
}
PerformanceTimingData
*
GetPerformanceTimingData
(
nsAString
&
aInitiatorType
nsAString
&
aEntryName
)
;
void
RunAbortAlgorithm
(
)
override
;
void
FetchDriverAbortActions
(
AbortSignalImpl
*
aSignalImpl
)
;
void
EnableNetworkInterceptControl
(
)
;
void
SetAssociatedBrowsingContextID
(
uint64_t
aID
)
{
mAssociatedBrowsingContextID
=
aID
;
}
void
SetIsThirdPartyContext
(
const
Maybe
<
bool
>
aIsThirdPartyWorker
)
{
mIsThirdPartyContext
=
aIsThirdPartyWorker
;
}
void
SetIsOn3PCBExceptionList
(
bool
aIsOn3PCBExceptionList
)
{
mIsOn3PCBExceptionList
=
aIsOn3PCBExceptionList
;
}
private
:
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
SafeRefPtr
<
InternalRequest
>
mRequest
;
SafeRefPtr
<
InternalResponse
>
mResponse
;
nsCOMPtr
<
nsIOutputStream
>
mPipeOutputStream
;
Mutex
mODAMutex
;
RefPtr
<
FetchDriverObserver
>
mObserver
;
RefPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsICSPEventListener
>
mCSPEventListener
;
Maybe
<
ClientInfo
>
mClientInfo
;
Maybe
<
ServiceWorkerDescriptor
>
mController
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
UniquePtr
<
SRICheckDataVerifier
>
mSRIDataVerifier
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
nsCOMPtr
<
nsICookieJarSettings
>
mCookieJarSettings
;
RefPtr
<
PerformanceStorage
>
mPerformanceStorage
;
SRIMetadata
mSRIMetadata
;
nsCString
mWorkerScript
;
UniquePtr
<
SerializedStackHolder
>
mOriginStack
;
bool
mNeedToObserveOnDataAvailable
;
bool
mIsTrackingFetch
;
net
:
:
ClassificationFlags
mTrackingFlags
;
Maybe
<
bool
>
mIsThirdPartyContext
;
bool
mIsOn3PCBExceptionList
;
RefPtr
<
AlternativeDataStreamListener
>
mAltDataListener
;
bool
mOnStopRequestCalled
;
bool
mFromPreload
=
false
;
bool
mAborted
=
false
;
#
ifdef
DEBUG
bool
mResponseAvailableCalled
;
bool
mFetchCalled
;
#
endif
nsCOMPtr
<
nsINetworkInterceptController
>
mInterceptController
;
uint64_t
mAssociatedBrowsingContextID
{
0
}
;
friend
class
AlternativeDataStreamListener
;
FetchDriver
(
)
=
delete
;
FetchDriver
(
const
FetchDriver
&
)
=
delete
;
FetchDriver
&
operator
=
(
const
FetchDriver
&
)
=
delete
;
~
FetchDriver
(
)
;
already_AddRefed
<
PreloaderBase
>
FindPreload
(
nsIURI
*
aURI
)
;
void
UpdateReferrerInfoFromNewChannel
(
nsIChannel
*
aChannel
)
;
nsresult
HttpFetch
(
const
nsACString
&
aPreferredAlternativeDataType
=
"
"
_ns
)
;
SafeRefPtr
<
InternalResponse
>
BeginAndGetFilteredResponse
(
SafeRefPtr
<
InternalResponse
>
aResponse
bool
aFoundOpaqueRedirect
)
;
void
FailWithNetworkError
(
nsresult
rv
)
;
void
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
bool
aStripRequestBodyHeader
bool
aStripAuthHeader
)
const
;
void
FinishOnStopRequest
(
AlternativeDataStreamListener
*
aAltDataListener
)
;
}
;
}
}
#
endif
