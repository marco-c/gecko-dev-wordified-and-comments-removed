#
ifndef
mozilla_dom_FetchDriver_h
#
define
mozilla_dom_FetchDriver_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIStreamListener
.
h
"
#
include
"
nsIThreadRetargetableStreamListener
.
h
"
#
include
"
mozilla
/
nsRefPtr
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
class
nsIDocument
;
class
nsIOutputStream
;
class
nsILoadGroup
;
class
nsIPrincipal
;
namespace
mozilla
{
namespace
dom
{
class
InternalRequest
;
class
InternalResponse
;
class
FetchDriverObserver
{
public
:
FetchDriverObserver
(
)
:
mGotResponseAvailable
(
false
)
{
}
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FetchDriverObserver
)
;
void
OnResponseAvailable
(
InternalResponse
*
aResponse
)
{
MOZ_ASSERT
(
!
mGotResponseAvailable
)
;
mGotResponseAvailable
=
true
;
OnResponseAvailableInternal
(
aResponse
)
;
}
virtual
void
OnResponseEnd
(
)
{
}
;
protected
:
virtual
~
FetchDriverObserver
(
)
{
}
;
virtual
void
OnResponseAvailableInternal
(
InternalResponse
*
aResponse
)
=
0
;
private
:
bool
mGotResponseAvailable
;
}
;
class
FetchDriver
final
:
public
nsIStreamListener
public
nsIChannelEventSink
public
nsIInterfaceRequestor
public
nsIAsyncVerifyRedirectCallback
public
nsIThreadRetargetableStreamListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSIASYNCVERIFYREDIRECTCALLBACK
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
explicit
FetchDriver
(
InternalRequest
*
aRequest
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
;
NS_IMETHOD
Fetch
(
FetchDriverObserver
*
aObserver
)
;
void
SetDocument
(
nsIDocument
*
aDocument
)
;
private
:
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
nsRefPtr
<
InternalRequest
>
mRequest
;
nsRefPtr
<
InternalResponse
>
mResponse
;
nsCOMPtr
<
nsIOutputStream
>
mPipeOutputStream
;
nsRefPtr
<
FetchDriverObserver
>
mObserver
;
nsCOMPtr
<
nsIInterfaceRequestor
>
mNotificationCallbacks
;
nsCOMPtr
<
nsIAsyncVerifyRedirectCallback
>
mRedirectCallback
;
nsCOMPtr
<
nsIChannel
>
mOldRedirectChannel
;
nsCOMPtr
<
nsIChannel
>
mNewRedirectChannel
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
uint32_t
mFetchRecursionCount
;
bool
mCORSFlagEverSet
;
DebugOnly
<
bool
>
mResponseAvailableCalled
;
FetchDriver
(
)
=
delete
;
FetchDriver
(
const
FetchDriver
&
)
=
delete
;
FetchDriver
&
operator
=
(
const
FetchDriver
&
)
=
delete
;
~
FetchDriver
(
)
;
enum
MainFetchOpType
{
NETWORK_ERROR
BASIC_FETCH
HTTP_FETCH
NUM_MAIN_FETCH_OPS
}
;
struct
MainFetchOp
{
explicit
MainFetchOp
(
MainFetchOpType
aType
bool
aCORSFlag
=
false
bool
aCORSPreflightFlag
=
false
)
:
mType
(
aType
)
mCORSFlag
(
aCORSFlag
)
mCORSPreflightFlag
(
aCORSPreflightFlag
)
{
}
MainFetchOpType
mType
;
bool
mCORSFlag
;
bool
mCORSPreflightFlag
;
}
;
nsresult
Fetch
(
bool
aCORSFlag
)
;
MainFetchOp
SetTaintingAndGetNextOp
(
bool
aCORSFlag
)
;
nsresult
ContinueFetch
(
bool
aCORSFlag
)
;
nsresult
BasicFetch
(
)
;
nsresult
HttpFetch
(
bool
aCORSFlag
=
false
bool
aCORSPreflightFlag
=
false
bool
aAuthenticationFlag
=
false
)
;
nsresult
ContinueHttpFetchAfterNetworkFetch
(
)
;
already_AddRefed
<
InternalResponse
>
BeginAndGetFilteredResponse
(
InternalResponse
*
aResponse
nsIURI
*
aFinalURI
)
;
void
BeginResponse
(
InternalResponse
*
aResponse
)
;
nsresult
FailWithNetworkError
(
)
;
nsresult
SucceedWithResponse
(
)
;
nsresult
DoesNotRequirePreflight
(
nsIChannel
*
aChannel
)
;
}
;
}
}
#
endif
