#
include
"
FetchUtil
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIUnicodeDecoder
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
mozilla
/
dom
/
EncodingUtils
.
h
"
#
include
"
mozilla
/
dom
/
InternalRequest
.
h
"
namespace
mozilla
{
namespace
dom
{
nsresult
FetchUtil
:
:
GetValidRequestMethod
(
const
nsACString
&
aMethod
nsCString
&
outMethod
)
{
nsAutoCString
upperCaseMethod
(
aMethod
)
;
ToUpperCase
(
upperCaseMethod
)
;
if
(
!
NS_IsValidHTTPToken
(
aMethod
)
)
{
outMethod
.
SetIsVoid
(
true
)
;
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
if
(
upperCaseMethod
.
EqualsLiteral
(
"
CONNECT
"
)
|
|
upperCaseMethod
.
EqualsLiteral
(
"
TRACE
"
)
|
|
upperCaseMethod
.
EqualsLiteral
(
"
TRACK
"
)
)
{
outMethod
.
SetIsVoid
(
true
)
;
return
NS_ERROR_DOM_SECURITY_ERR
;
}
if
(
upperCaseMethod
.
EqualsLiteral
(
"
DELETE
"
)
|
|
upperCaseMethod
.
EqualsLiteral
(
"
GET
"
)
|
|
upperCaseMethod
.
EqualsLiteral
(
"
HEAD
"
)
|
|
upperCaseMethod
.
EqualsLiteral
(
"
OPTIONS
"
)
|
|
upperCaseMethod
.
EqualsLiteral
(
"
POST
"
)
|
|
upperCaseMethod
.
EqualsLiteral
(
"
PUT
"
)
)
{
outMethod
=
upperCaseMethod
;
}
else
{
outMethod
=
aMethod
;
}
return
NS_OK
;
}
static
bool
FindCRLF
(
nsACString
:
:
const_iterator
&
aStart
nsACString
:
:
const_iterator
&
aEnd
)
{
nsACString
:
:
const_iterator
end
(
aEnd
)
;
return
FindInReadable
(
NS_LITERAL_CSTRING
(
"
\
r
\
n
"
)
aStart
end
)
;
}
static
bool
PushOverLine
(
nsACString
:
:
const_iterator
&
aStart
const
nsACString
:
:
const_iterator
&
aEnd
)
{
if
(
*
aStart
=
=
nsCRT
:
:
CR
&
&
(
aEnd
-
aStart
>
1
)
&
&
*
(
+
+
aStart
)
=
=
nsCRT
:
:
LF
)
{
+
+
aStart
;
return
true
;
}
return
false
;
}
bool
FetchUtil
:
:
ExtractHeader
(
nsACString
:
:
const_iterator
&
aStart
nsACString
:
:
const_iterator
&
aEnd
nsCString
&
aHeaderName
nsCString
&
aHeaderValue
bool
*
aWasEmptyHeader
)
{
MOZ_ASSERT
(
aWasEmptyHeader
)
;
*
aWasEmptyHeader
=
false
;
const
char
*
beginning
=
aStart
.
get
(
)
;
nsACString
:
:
const_iterator
end
(
aEnd
)
;
if
(
!
FindCRLF
(
aStart
end
)
)
{
return
false
;
}
if
(
aStart
.
get
(
)
=
=
beginning
)
{
*
aWasEmptyHeader
=
true
;
return
true
;
}
nsAutoCString
header
(
beginning
aStart
.
get
(
)
-
beginning
)
;
nsACString
:
:
const_iterator
headerStart
iter
headerEnd
;
header
.
BeginReading
(
headerStart
)
;
header
.
EndReading
(
headerEnd
)
;
iter
=
headerStart
;
if
(
!
FindCharInReadable
(
'
:
'
iter
headerEnd
)
)
{
return
false
;
}
aHeaderName
.
Assign
(
StringHead
(
header
iter
-
headerStart
)
)
;
aHeaderName
.
CompressWhitespace
(
)
;
if
(
!
NS_IsValidHTTPToken
(
aHeaderName
)
)
{
return
false
;
}
aHeaderValue
.
Assign
(
Substring
(
+
+
iter
headerEnd
)
)
;
if
(
!
NS_IsReasonableHTTPHeaderValue
(
aHeaderValue
)
)
{
return
false
;
}
aHeaderValue
.
CompressWhitespace
(
)
;
return
PushOverLine
(
aStart
aEnd
)
;
}
nsresult
FetchUtil
:
:
SetRequestReferrer
(
nsIPrincipal
*
aPrincipal
nsIDocument
*
aDoc
nsIHttpChannel
*
aChannel
InternalRequest
*
aRequest
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsAutoString
referrer
;
aRequest
-
>
GetReferrer
(
referrer
)
;
net
:
:
ReferrerPolicy
policy
=
aRequest
-
>
GetReferrerPolicy
(
)
;
nsresult
rv
=
NS_OK
;
if
(
referrer
.
IsEmpty
(
)
)
{
rv
=
aChannel
-
>
SetReferrerWithPolicy
(
nullptr
net
:
:
RP_No_Referrer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
referrer
.
EqualsLiteral
(
kFETCH_CLIENT_REFERRER_STR
)
)
{
rv
=
nsContentUtils
:
:
SetFetchReferrerURIWithPolicy
(
aPrincipal
aDoc
aChannel
policy
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
nsCOMPtr
<
nsIURI
>
referrerURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
referrerURI
)
referrer
nullptr
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aChannel
-
>
SetReferrerWithPolicy
(
referrerURI
policy
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIURI
>
referrerURI
;
Unused
<
<
aChannel
-
>
GetReferrer
(
getter_AddRefs
(
referrerURI
)
)
;
if
(
referrerURI
)
{
nsAutoCString
spec
;
rv
=
referrerURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aRequest
-
>
SetReferrer
(
NS_ConvertUTF8toUTF16
(
spec
)
)
;
}
else
{
aRequest
-
>
SetReferrer
(
EmptyString
(
)
)
;
}
return
NS_OK
;
}
}
}
