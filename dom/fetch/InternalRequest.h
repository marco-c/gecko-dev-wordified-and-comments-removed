#
ifndef
mozilla_dom_InternalRequest_h
#
define
mozilla_dom_InternalRequest_h
#
include
"
mozilla
/
dom
/
HeadersBinding
.
h
"
#
include
"
mozilla
/
dom
/
InternalHeaders
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
mozilla
/
LoadTainting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
ifdef
DEBUG
#
include
"
nsIURLParser
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
endif
namespace
mozilla
{
namespace
ipc
{
class
PrincipalInfo
;
class
AutoIPCStream
;
}
namespace
dom
{
class
IPCInternalRequest
;
class
Request
;
#
define
kFETCH_CLIENT_REFERRER_STR
"
about
:
client
"
class
InternalRequest
final
{
friend
class
Request
;
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
InternalRequest
)
InternalRequest
(
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
;
InternalRequest
(
const
nsACString
&
aURL
const
nsACString
&
aFragment
const
nsACString
&
aMethod
already_AddRefed
<
InternalHeaders
>
aHeaders
RequestCache
aCacheMode
RequestMode
aMode
RequestRedirect
aRequestRedirect
RequestCredentials
aRequestCredentials
const
nsAString
&
aReferrer
ReferrerPolicy
aReferrerPolicy
nsContentPolicyType
aContentPolicyType
const
nsAString
&
aIntegrity
)
;
explicit
InternalRequest
(
const
IPCInternalRequest
&
aIPCRequest
)
;
template
<
typename
M
>
void
ToIPC
(
IPCInternalRequest
*
aIPCRequest
M
*
aManager
UniquePtr
<
mozilla
:
:
ipc
:
:
AutoIPCStream
>
&
aAutoStream
)
;
already_AddRefed
<
InternalRequest
>
Clone
(
)
;
void
GetMethod
(
nsCString
&
aMethod
)
const
{
aMethod
.
Assign
(
mMethod
)
;
}
void
SetMethod
(
const
nsACString
&
aMethod
)
{
mMethod
.
Assign
(
aMethod
)
;
}
bool
HasSimpleMethod
(
)
const
{
return
mMethod
.
LowerCaseEqualsASCII
(
"
get
"
)
|
|
mMethod
.
LowerCaseEqualsASCII
(
"
post
"
)
|
|
mMethod
.
LowerCaseEqualsASCII
(
"
head
"
)
;
}
void
GetURL
(
nsACString
&
aURL
)
const
{
aURL
.
Assign
(
GetURLWithoutFragment
(
)
)
;
if
(
GetFragment
(
)
.
IsEmpty
(
)
)
{
return
;
}
aURL
.
AppendLiteral
(
"
#
"
)
;
aURL
.
Append
(
GetFragment
(
)
)
;
}
const
nsCString
&
GetURLWithoutFragment
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
mURLList
.
IsEmpty
(
)
"
Internal
Request
'
s
urlList
should
not
be
empty
.
"
)
;
return
mURLList
.
LastElement
(
)
;
}
void
SetURLForInternalRedirect
(
const
uint32_t
aFlag
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
{
MOZ_ASSERT
(
aFlag
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
return
SetURL
(
aURL
aFragment
)
;
}
void
AddURL
(
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
{
MOZ_ASSERT
(
!
aURL
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aURL
.
Contains
(
'
#
'
)
)
;
mURLList
.
AppendElement
(
aURL
)
;
mFragment
.
Assign
(
aFragment
)
;
}
void
GetURLListWithoutFragment
(
nsTArray
<
nsCString
>
&
aURLList
)
{
aURLList
.
Assign
(
mURLList
)
;
}
void
GetReferrer
(
nsAString
&
aReferrer
)
const
{
aReferrer
.
Assign
(
mReferrer
)
;
}
void
SetReferrer
(
const
nsAString
&
aReferrer
)
{
#
ifdef
DEBUG
bool
validReferrer
=
false
;
if
(
aReferrer
.
IsEmpty
(
)
|
|
aReferrer
.
EqualsLiteral
(
kFETCH_CLIENT_REFERRER_STR
)
)
{
validReferrer
=
true
;
}
else
{
nsCOMPtr
<
nsIURLParser
>
parser
=
do_GetService
(
NS_STDURLPARSER_CONTRACTID
)
;
if
(
!
parser
)
{
NS_WARNING
(
"
Could
not
get
parser
to
validate
URL
!
"
)
;
}
else
{
uint32_t
schemePos
;
int32_t
schemeLen
;
uint32_t
authorityPos
;
int32_t
authorityLen
;
uint32_t
pathPos
;
int32_t
pathLen
;
NS_ConvertUTF16toUTF8
ref
(
aReferrer
)
;
nsresult
rv
=
parser
-
>
ParseURL
(
ref
.
get
(
)
ref
.
Length
(
)
&
schemePos
&
schemeLen
&
authorityPos
&
authorityLen
&
pathPos
&
pathLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Invalid
referrer
URL
!
"
)
;
}
else
if
(
schemeLen
<
0
|
|
authorityLen
<
0
)
{
NS_WARNING
(
"
Invalid
referrer
URL
!
"
)
;
}
else
{
validReferrer
=
true
;
}
}
}
MOZ_ASSERT
(
validReferrer
)
;
#
endif
mReferrer
.
Assign
(
aReferrer
)
;
}
ReferrerPolicy
ReferrerPolicy_
(
)
const
{
return
mReferrerPolicy
;
}
void
SetReferrerPolicy
(
ReferrerPolicy
aReferrerPolicy
)
{
mReferrerPolicy
=
aReferrerPolicy
;
}
ReferrerPolicy
GetEnvironmentReferrerPolicy
(
)
const
{
return
mEnvironmentReferrerPolicy
;
}
void
SetEnvironmentReferrerPolicy
(
ReferrerPolicy
aReferrerPolicy
)
{
mEnvironmentReferrerPolicy
=
aReferrerPolicy
;
}
bool
SkipServiceWorker
(
)
const
{
return
mSkipServiceWorker
;
}
void
SetSkipServiceWorker
(
)
{
mSkipServiceWorker
=
true
;
}
bool
IsSynchronous
(
)
const
{
return
mSynchronous
;
}
RequestMode
Mode
(
)
const
{
return
mMode
;
}
void
SetMode
(
RequestMode
aMode
)
{
mMode
=
aMode
;
}
RequestCredentials
GetCredentialsMode
(
)
const
{
return
mCredentialsMode
;
}
void
SetCredentialsMode
(
RequestCredentials
aCredentialsMode
)
{
mCredentialsMode
=
aCredentialsMode
;
}
LoadTainting
GetResponseTainting
(
)
const
{
return
mResponseTainting
;
}
void
MaybeIncreaseResponseTainting
(
LoadTainting
aTainting
)
{
if
(
aTainting
>
mResponseTainting
)
{
mResponseTainting
=
aTainting
;
}
}
RequestCache
GetCacheMode
(
)
const
{
return
mCacheMode
;
}
void
SetCacheMode
(
RequestCache
aCacheMode
)
{
mCacheMode
=
aCacheMode
;
}
RequestRedirect
GetRedirectMode
(
)
const
{
return
mRedirectMode
;
}
void
SetRedirectMode
(
RequestRedirect
aRedirectMode
)
{
mRedirectMode
=
aRedirectMode
;
}
const
nsString
&
GetIntegrity
(
)
const
{
return
mIntegrity
;
}
void
SetIntegrity
(
const
nsAString
&
aIntegrity
)
{
MOZ_ASSERT
(
mIntegrity
.
IsEmpty
(
)
)
;
mIntegrity
.
Assign
(
aIntegrity
)
;
}
bool
MozErrors
(
)
const
{
return
mMozErrors
;
}
void
SetMozErrors
(
)
{
mMozErrors
=
true
;
}
const
nsCString
&
GetFragment
(
)
const
{
return
mFragment
;
}
nsContentPolicyType
ContentPolicyType
(
)
const
{
return
mContentPolicyType
;
}
void
SetContentPolicyType
(
nsContentPolicyType
aContentPolicyType
)
;
void
OverrideContentPolicyType
(
nsContentPolicyType
aContentPolicyType
)
;
RequestDestination
Destination
(
)
const
{
return
MapContentPolicyTypeToRequestDestination
(
mContentPolicyType
)
;
}
bool
UnsafeRequest
(
)
const
{
return
mUnsafeRequest
;
}
void
SetUnsafeRequest
(
)
{
mUnsafeRequest
=
true
;
}
InternalHeaders
*
Headers
(
)
{
return
mHeaders
;
}
void
SetHeaders
(
InternalHeaders
*
aHeaders
)
{
MOZ_ASSERT
(
aHeaders
)
;
mHeaders
=
aHeaders
;
}
bool
SameOriginDataURL
(
)
const
{
return
mSameOriginDataURL
;
}
void
UnsetSameOriginDataURL
(
)
{
mSameOriginDataURL
=
false
;
}
void
SetBody
(
nsIInputStream
*
aStream
int64_t
aBodyLength
)
{
MOZ_ASSERT_IF
(
aStream
!
mBodyStream
)
;
mBodyStream
=
aStream
;
mBodyLength
=
aBodyLength
;
}
void
GetBody
(
nsIInputStream
*
*
aStream
int64_t
*
aBodyLength
=
nullptr
)
{
nsCOMPtr
<
nsIInputStream
>
s
=
mBodyStream
;
s
.
forget
(
aStream
)
;
if
(
aBodyLength
)
{
*
aBodyLength
=
mBodyLength
;
}
}
void
SetBodyBlobURISpec
(
nsACString
&
aBlobURISpec
)
{
mBodyBlobURISpec
=
aBlobURISpec
;
}
const
nsACString
&
BodyBlobURISpec
(
)
const
{
return
mBodyBlobURISpec
;
}
void
SetBodyLocalPath
(
nsAString
&
aLocalPath
)
{
mBodyLocalPath
=
aLocalPath
;
}
const
nsAString
&
BodyLocalPath
(
)
const
{
return
mBodyLocalPath
;
}
already_AddRefed
<
InternalRequest
>
GetRequestConstructorCopy
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
const
;
bool
IsNavigationRequest
(
)
const
;
bool
IsWorkerRequest
(
)
const
;
bool
IsClientRequest
(
)
const
;
void
MaybeSkipCacheIfPerformingRevalidation
(
)
;
bool
IsContentPolicyTypeOverridden
(
)
const
{
return
mContentPolicyTypeOverridden
;
}
static
RequestMode
MapChannelToRequestMode
(
nsIChannel
*
aChannel
)
;
static
RequestCredentials
MapChannelToRequestCredentials
(
nsIChannel
*
aChannel
)
;
void
SetPrincipalInfo
(
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
aPrincipalInfo
)
;
const
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
&
GetPrincipalInfo
(
)
const
{
return
mPrincipalInfo
;
}
const
nsCString
&
GetPreferredAlternativeDataType
(
)
const
{
return
mPreferredAlternativeDataType
;
}
void
SetPreferredAlternativeDataType
(
const
nsACString
&
aDataType
)
{
mPreferredAlternativeDataType
=
aDataType
;
}
private
:
explicit
InternalRequest
(
const
InternalRequest
&
aOther
)
;
~
InternalRequest
(
)
;
static
RequestDestination
MapContentPolicyTypeToRequestDestination
(
nsContentPolicyType
aContentPolicyType
)
;
static
bool
IsNavigationContentPolicy
(
nsContentPolicyType
aContentPolicyType
)
;
static
bool
IsWorkerContentPolicy
(
nsContentPolicyType
aContentPolicyType
)
;
void
SetURL
(
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
{
MOZ_ASSERT
(
!
aURL
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aURL
.
Contains
(
'
#
'
)
)
;
MOZ_ASSERT
(
mURLList
.
Length
(
)
>
0
)
;
mURLList
.
LastElement
(
)
=
aURL
;
mFragment
.
Assign
(
aFragment
)
;
}
nsCString
mMethod
;
nsTArray
<
nsCString
>
mURLList
;
RefPtr
<
InternalHeaders
>
mHeaders
;
nsCString
mBodyBlobURISpec
;
nsString
mBodyLocalPath
;
nsCOMPtr
<
nsIInputStream
>
mBodyStream
;
int64_t
mBodyLength
;
nsCString
mPreferredAlternativeDataType
;
nsContentPolicyType
mContentPolicyType
;
nsString
mReferrer
;
ReferrerPolicy
mReferrerPolicy
;
ReferrerPolicy
mEnvironmentReferrerPolicy
;
RequestMode
mMode
;
RequestCredentials
mCredentialsMode
;
MOZ_INIT_OUTSIDE_CTOR
LoadTainting
mResponseTainting
;
RequestCache
mCacheMode
;
RequestRedirect
mRedirectMode
;
nsString
mIntegrity
;
bool
mMozErrors
=
false
;
nsCString
mFragment
;
MOZ_INIT_OUTSIDE_CTOR
bool
mAuthenticationFlag
;
MOZ_INIT_OUTSIDE_CTOR
bool
mPreserveContentCodings
;
MOZ_INIT_OUTSIDE_CTOR
bool
mSameOriginDataURL
;
MOZ_INIT_OUTSIDE_CTOR
bool
mSkipServiceWorker
;
MOZ_INIT_OUTSIDE_CTOR
bool
mSynchronous
;
MOZ_INIT_OUTSIDE_CTOR
bool
mUnsafeRequest
;
MOZ_INIT_OUTSIDE_CTOR
bool
mUseURLCredentials
;
bool
mContentPolicyTypeOverridden
=
false
;
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
mPrincipalInfo
;
}
;
}
}
#
endif
