#
ifndef
mozilla_dom_InternalRequest_h
#
define
mozilla_dom_InternalRequest_h
#
include
"
mozilla
/
LoadTainting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
HeadersBinding
.
h
"
#
include
"
mozilla
/
dom
/
InternalHeaders
.
h
"
#
include
"
mozilla
/
dom
/
InternalResponse
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
#
include
"
mozilla
/
dom
/
SafeRefPtr
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
ifdef
DEBUG
#
include
"
nsIURLParser
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
endif
using
mozilla
:
:
net
:
:
RedirectHistoryEntryInfo
;
namespace
mozilla
{
namespace
ipc
{
class
PBackgroundChild
;
class
PrincipalInfo
;
}
namespace
dom
{
class
IPCInternalRequest
;
class
Request
;
#
define
kFETCH_CLIENT_REFERRER_STR
"
about
:
client
"
class
InternalRequest
final
:
public
AtomicSafeRefCounted
<
InternalRequest
>
{
friend
class
Request
;
public
:
MOZ_DECLARE_REFCOUNTED_TYPENAME
(
InternalRequest
)
InternalRequest
(
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
;
explicit
InternalRequest
(
const
IPCInternalRequest
&
aIPCRequest
)
;
void
ToIPCInternalRequest
(
IPCInternalRequest
*
aIPCRequest
mozilla
:
:
ipc
:
:
PBackgroundChild
*
aManager
)
;
SafeRefPtr
<
InternalRequest
>
Clone
(
)
;
void
GetMethod
(
nsCString
&
aMethod
)
const
{
aMethod
.
Assign
(
mMethod
)
;
}
void
SetMethod
(
const
nsACString
&
aMethod
)
{
mMethod
.
Assign
(
aMethod
)
;
}
bool
HasSimpleMethod
(
)
const
{
return
mMethod
.
LowerCaseEqualsASCII
(
"
get
"
)
|
|
mMethod
.
LowerCaseEqualsASCII
(
"
post
"
)
|
|
mMethod
.
LowerCaseEqualsASCII
(
"
head
"
)
;
}
void
GetURL
(
nsACString
&
aURL
)
const
{
aURL
.
Assign
(
GetURLWithoutFragment
(
)
)
;
if
(
GetFragment
(
)
.
IsEmpty
(
)
)
{
return
;
}
aURL
.
AppendLiteral
(
"
#
"
)
;
aURL
.
Append
(
GetFragment
(
)
)
;
}
const
nsCString
&
GetURLWithoutFragment
(
)
const
{
MOZ_RELEASE_ASSERT
(
!
mURLList
.
IsEmpty
(
)
"
Internal
Request
'
s
urlList
should
not
be
empty
.
"
)
;
return
mURLList
.
LastElement
(
)
;
}
void
SetURLForInternalRedirect
(
const
uint32_t
aFlag
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
{
MOZ_ASSERT
(
aFlag
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
;
return
SetURL
(
aURL
aFragment
)
;
}
void
AddURL
(
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
{
MOZ_ASSERT
(
!
aURL
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aURL
.
Contains
(
'
#
'
)
)
;
mURLList
.
AppendElement
(
aURL
)
;
mFragment
.
Assign
(
aFragment
)
;
}
void
GetURLListWithoutFragment
(
nsTArray
<
nsCString
>
&
aURLList
)
{
aURLList
.
Assign
(
mURLList
)
;
}
void
GetReferrer
(
nsACString
&
aReferrer
)
const
{
aReferrer
.
Assign
(
mReferrer
)
;
}
void
SetReferrer
(
const
nsACString
&
aReferrer
)
{
#
ifdef
DEBUG
bool
validReferrer
=
false
;
if
(
aReferrer
.
IsEmpty
(
)
|
|
aReferrer
.
EqualsLiteral
(
kFETCH_CLIENT_REFERRER_STR
)
)
{
validReferrer
=
true
;
}
else
{
nsCOMPtr
<
nsIURLParser
>
parser
=
do_GetService
(
NS_STDURLPARSER_CONTRACTID
)
;
if
(
!
parser
)
{
NS_WARNING
(
"
Could
not
get
parser
to
validate
URL
!
"
)
;
}
else
{
uint32_t
schemePos
;
int32_t
schemeLen
;
uint32_t
authorityPos
;
int32_t
authorityLen
;
uint32_t
pathPos
;
int32_t
pathLen
;
nsresult
rv
=
parser
-
>
ParseURL
(
aReferrer
.
BeginReading
(
)
aReferrer
.
Length
(
)
&
schemePos
&
schemeLen
&
authorityPos
&
authorityLen
&
pathPos
&
pathLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Invalid
referrer
URL
!
"
)
;
}
else
if
(
schemeLen
<
0
|
|
authorityLen
<
0
)
{
NS_WARNING
(
"
Invalid
referrer
URL
!
"
)
;
}
else
{
validReferrer
=
true
;
}
}
}
MOZ_ASSERT
(
validReferrer
)
;
#
endif
mReferrer
.
Assign
(
aReferrer
)
;
}
ReferrerPolicy
ReferrerPolicy_
(
)
const
{
return
mReferrerPolicy
;
}
void
SetReferrerPolicy
(
ReferrerPolicy
aReferrerPolicy
)
{
mReferrerPolicy
=
aReferrerPolicy
;
}
ReferrerPolicy
GetEnvironmentReferrerPolicy
(
)
const
{
return
mEnvironmentReferrerPolicy
;
}
void
SetEnvironmentReferrerPolicy
(
ReferrerPolicy
aReferrerPolicy
)
{
mEnvironmentReferrerPolicy
=
aReferrerPolicy
;
}
bool
SkipServiceWorker
(
)
const
{
return
mSkipServiceWorker
;
}
void
SetSkipServiceWorker
(
)
{
mSkipServiceWorker
=
true
;
}
bool
SkipWasmCaching
(
)
const
{
return
mSkipWasmCaching
;
}
void
SetSkipWasmCaching
(
)
{
mSkipWasmCaching
=
true
;
}
bool
IsSynchronous
(
)
const
{
return
mSynchronous
;
}
RequestMode
Mode
(
)
const
{
return
mMode
;
}
void
SetMode
(
RequestMode
aMode
)
{
mMode
=
aMode
;
}
RequestCredentials
GetCredentialsMode
(
)
const
{
return
mCredentialsMode
;
}
void
SetCredentialsMode
(
RequestCredentials
aCredentialsMode
)
{
mCredentialsMode
=
aCredentialsMode
;
}
LoadTainting
GetResponseTainting
(
)
const
{
return
mResponseTainting
;
}
void
MaybeIncreaseResponseTainting
(
LoadTainting
aTainting
)
{
if
(
aTainting
>
mResponseTainting
&
&
!
mNeverTaint
)
{
mResponseTainting
=
aTainting
;
}
}
RequestCache
GetCacheMode
(
)
const
{
return
mCacheMode
;
}
void
SetCacheMode
(
RequestCache
aCacheMode
)
{
mCacheMode
=
aCacheMode
;
}
RequestRedirect
GetRedirectMode
(
)
const
{
return
mRedirectMode
;
}
void
SetRedirectMode
(
RequestRedirect
aRedirectMode
)
{
mRedirectMode
=
aRedirectMode
;
}
RequestPriority
GetPriorityMode
(
)
const
{
return
mPriorityMode
;
}
void
SetPriorityMode
(
RequestPriority
aPriorityMode
)
{
mPriorityMode
=
aPriorityMode
;
}
const
nsString
&
GetIntegrity
(
)
const
{
return
mIntegrity
;
}
void
SetIntegrity
(
const
nsAString
&
aIntegrity
)
{
mIntegrity
.
Assign
(
aIntegrity
)
;
}
bool
GetKeepalive
(
)
const
{
return
mKeepalive
;
}
void
SetKeepalive
(
const
bool
aKeepalive
)
{
mKeepalive
=
aKeepalive
;
}
bool
MozErrors
(
)
const
{
return
mMozErrors
;
}
void
SetMozErrors
(
)
{
mMozErrors
=
true
;
}
void
SetTriggeringPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
mTriggeringPrincipalOverride
=
aPrincipal
;
}
nsIPrincipal
*
GetTriggeringPrincipalOverride
(
)
{
return
mTriggeringPrincipalOverride
;
}
void
SetNeverTaint
(
bool
aNeverTaint
)
{
mNeverTaint
=
aNeverTaint
;
}
bool
GetNeverTaint
(
)
{
return
mNeverTaint
;
}
const
nsCString
&
GetFragment
(
)
const
{
return
mFragment
;
}
nsContentPolicyType
ContentPolicyType
(
)
const
{
return
mContentPolicyType
;
}
void
SetContentPolicyType
(
nsContentPolicyType
aContentPolicyType
)
;
void
OverrideContentPolicyType
(
nsContentPolicyType
aContentPolicyType
)
;
RequestDestination
Destination
(
)
const
{
return
MapContentPolicyTypeToRequestDestination
(
mContentPolicyType
)
;
}
int32_t
InternalPriority
(
)
const
{
return
mInternalPriority
;
}
void
SetInternalPriority
(
int32_t
aInternalPriority
)
{
mInternalPriority
=
aInternalPriority
;
}
bool
UnsafeRequest
(
)
const
{
return
mUnsafeRequest
;
}
void
SetUnsafeRequest
(
)
{
mUnsafeRequest
=
true
;
}
InternalHeaders
*
Headers
(
)
const
{
return
mHeaders
;
}
void
SetHeaders
(
InternalHeaders
*
aHeaders
)
{
MOZ_ASSERT
(
aHeaders
)
;
mHeaders
=
aHeaders
;
}
void
SetBody
(
nsIInputStream
*
aStream
int64_t
aBodyLength
)
{
MOZ_ASSERT_IF
(
aStream
!
mBodyStream
)
;
mBodyStream
=
aStream
;
mBodyLength
=
aBodyLength
;
}
void
GetBody
(
nsIInputStream
*
*
aStream
int64_t
*
aBodyLength
=
nullptr
)
const
{
nsCOMPtr
<
nsIInputStream
>
s
=
mBodyStream
;
s
.
forget
(
aStream
)
;
if
(
aBodyLength
)
{
*
aBodyLength
=
mBodyLength
;
}
}
int64_t
BodyLength
(
)
const
{
return
mBodyLength
;
}
void
SetBodyBlobURISpec
(
nsACString
&
aBlobURISpec
)
{
mBodyBlobURISpec
=
aBlobURISpec
;
}
const
nsACString
&
BodyBlobURISpec
(
)
const
{
return
mBodyBlobURISpec
;
}
void
SetBodyLocalPath
(
nsAString
&
aLocalPath
)
{
mBodyLocalPath
=
aLocalPath
;
}
const
nsAString
&
BodyLocalPath
(
)
const
{
return
mBodyLocalPath
;
}
SafeRefPtr
<
InternalRequest
>
GetRequestConstructorCopy
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
const
;
bool
IsNavigationRequest
(
)
const
;
bool
IsWorkerRequest
(
)
const
;
bool
IsClientRequest
(
)
const
;
void
MaybeSkipCacheIfPerformingRevalidation
(
)
;
bool
IsContentPolicyTypeOverridden
(
)
const
{
return
mContentPolicyTypeOverridden
;
}
static
RequestMode
MapChannelToRequestMode
(
nsIChannel
*
aChannel
)
;
static
RequestCredentials
MapChannelToRequestCredentials
(
nsIChannel
*
aChannel
)
;
void
SetPrincipalInfo
(
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
aPrincipalInfo
)
;
const
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
&
GetPrincipalInfo
(
)
const
{
return
mPrincipalInfo
;
}
const
nsCString
&
GetPreferredAlternativeDataType
(
)
const
{
return
mPreferredAlternativeDataType
;
}
void
SetPreferredAlternativeDataType
(
const
nsACString
&
aDataType
)
{
mPreferredAlternativeDataType
=
aDataType
;
}
~
InternalRequest
(
)
;
InternalRequest
(
const
InternalRequest
&
aOther
)
=
delete
;
void
SetEmbedderPolicy
(
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
aPolicy
)
{
mEmbedderPolicy
=
aPolicy
;
}
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
GetEmbedderPolicy
(
)
const
{
return
mEmbedderPolicy
;
}
void
SetInterceptionTriggeringPrincipalInfo
(
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
aPrincipalInfo
)
;
const
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
&
GetInterceptionTriggeringPrincipalInfo
(
)
const
{
return
mInterceptionTriggeringPrincipalInfo
;
}
nsContentPolicyType
InterceptionContentPolicyType
(
)
const
{
return
mInterceptionContentPolicyType
;
}
RequestDestination
InterceptionDestination
(
)
const
{
return
MapContentPolicyTypeToRequestDestination
(
mInterceptionContentPolicyType
)
;
}
void
SetInterceptionContentPolicyType
(
nsContentPolicyType
aContentPolicyType
)
;
const
nsTArray
<
RedirectHistoryEntryInfo
>
&
InterceptionRedirectChain
(
)
const
{
return
mInterceptionRedirectChain
;
}
void
SetInterceptionRedirectChain
(
const
nsTArray
<
RedirectHistoryEntryInfo
>
&
aRedirectChain
)
{
mInterceptionRedirectChain
=
aRedirectChain
;
}
const
bool
&
InterceptionFromThirdParty
(
)
const
{
return
mInterceptionFromThirdParty
;
}
void
SetInterceptionFromThirdParty
(
bool
aFromThirdParty
)
{
mInterceptionFromThirdParty
=
aFromThirdParty
;
}
private
:
struct
ConstructorGuard
{
}
;
public
:
InternalRequest
(
const
InternalRequest
&
aOther
ConstructorGuard
)
;
static
RequestDestination
MapContentPolicyTypeToRequestDestination
(
nsContentPolicyType
aContentPolicyType
)
;
private
:
static
bool
IsNavigationContentPolicy
(
nsContentPolicyType
aContentPolicyType
)
;
static
bool
IsWorkerContentPolicy
(
nsContentPolicyType
aContentPolicyType
)
;
void
SetURL
(
const
nsACString
&
aURL
const
nsACString
&
aFragment
)
{
MOZ_ASSERT
(
!
aURL
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
aURL
.
Contains
(
'
#
'
)
)
;
MOZ_ASSERT
(
mURLList
.
Length
(
)
>
0
)
;
mURLList
.
LastElement
(
)
=
aURL
;
mFragment
.
Assign
(
aFragment
)
;
}
nsCString
mMethod
;
nsTArray
<
nsCString
>
mURLList
;
RefPtr
<
InternalHeaders
>
mHeaders
;
nsCString
mBodyBlobURISpec
;
nsString
mBodyLocalPath
;
nsCOMPtr
<
nsIInputStream
>
mBodyStream
;
nsCOMPtr
<
nsIPrincipal
>
mTriggeringPrincipalOverride
;
bool
mNeverTaint
=
false
;
int64_t
mBodyLength
{
InternalResponse
:
:
UNKNOWN_BODY_SIZE
}
;
nsCString
mPreferredAlternativeDataType
;
nsContentPolicyType
mContentPolicyType
;
int32_t
mInternalPriority
=
nsISupportsPriority
:
:
PRIORITY_NORMAL
;
nsCString
mReferrer
;
ReferrerPolicy
mReferrerPolicy
;
ReferrerPolicy
mEnvironmentReferrerPolicy
;
RequestMode
mMode
;
RequestCredentials
mCredentialsMode
;
LoadTainting
mResponseTainting
=
LoadTainting
:
:
Basic
;
RequestCache
mCacheMode
;
RequestRedirect
mRedirectMode
;
RequestPriority
mPriorityMode
=
RequestPriority
:
:
Auto
;
nsString
mIntegrity
;
bool
mKeepalive
=
false
;
bool
mMozErrors
=
false
;
nsCString
mFragment
;
bool
mSkipServiceWorker
=
false
;
bool
mSkipWasmCaching
=
false
;
bool
mSynchronous
=
false
;
bool
mUnsafeRequest
=
false
;
bool
mUseURLCredentials
=
false
;
bool
mContentPolicyTypeOverridden
=
false
;
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
mEmbedderPolicy
=
nsILoadInfo
:
:
EMBEDDER_POLICY_NULL
;
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
mPrincipalInfo
;
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
mInterceptionTriggeringPrincipalInfo
;
nsContentPolicyType
mInterceptionContentPolicyType
{
nsIContentPolicy
:
:
TYPE_INVALID
}
;
CopyableTArray
<
RedirectHistoryEntryInfo
>
mInterceptionRedirectChain
;
bool
mInterceptionFromThirdParty
{
false
}
;
}
;
}
}
#
endif
