#
ifndef
mozilla_dom_FetchConsumer_h
#
define
mozilla_dom_FetchConsumer_h
#
include
"
Fetch
.
h
"
#
include
"
mozilla
/
dom
/
AbortSignal
.
h
"
#
include
"
mozilla
/
dom
/
MutableBlobStorage
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsWeakReference
.
h
"
class
nsIThread
;
namespace
mozilla
{
namespace
dom
{
class
Promise
;
class
ThreadSafeWorkerRef
;
template
<
class
Derived
>
class
FetchBody
;
template
<
class
Derived
>
class
FetchBodyConsumer
final
:
public
nsIObserver
public
nsSupportsWeakReference
public
AbortFollower
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
static
already_AddRefed
<
Promise
>
Create
(
nsIGlobalObject
*
aGlobal
nsIEventTarget
*
aMainThreadEventTarget
FetchBody
<
Derived
>
*
aBody
AbortSignalImpl
*
aSignalImpl
FetchConsumeType
aType
ErrorResult
&
aRv
)
;
void
ReleaseObject
(
)
;
void
BeginConsumeBodyMainThread
(
ThreadSafeWorkerRef
*
aWorkerRef
)
;
void
ContinueConsumeBody
(
nsresult
aStatus
uint32_t
aLength
uint8_t
*
aResult
bool
aShuttingDown
=
false
)
;
void
ContinueConsumeBlobBody
(
BlobImpl
*
aBlobImpl
bool
aShuttingDown
=
false
)
;
void
ShutDownMainThreadConsuming
(
)
;
void
NullifyConsumeBodyPump
(
)
{
mShuttingDown
=
true
;
mConsumeBodyPump
=
nullptr
;
}
void
Abort
(
)
override
;
private
:
FetchBodyConsumer
(
nsIEventTarget
*
aMainThreadEventTarget
nsIGlobalObject
*
aGlobalObject
FetchBody
<
Derived
>
*
aBody
nsIInputStream
*
aBodyStream
Promise
*
aPromise
FetchConsumeType
aType
)
;
~
FetchBodyConsumer
(
)
;
void
AssertIsOnTargetThread
(
)
const
;
nsCOMPtr
<
nsIThread
>
mTargetThread
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
#
ifdef
DEBUG
RefPtr
<
FetchBody
<
Derived
>
>
mBody
;
#
endif
nsCOMPtr
<
nsIInputStream
>
mBodyStream
;
MutableBlobStorage
:
:
MutableBlobStorageType
mBlobStorageType
;
nsCString
mBodyMimeType
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
nsCOMPtr
<
nsIInputStreamPump
>
mConsumeBodyPump
;
FetchConsumeType
mConsumeType
;
RefPtr
<
Promise
>
mConsumePromise
;
bool
mBodyConsumed
;
bool
mShuttingDown
;
}
;
}
}
#
endif
