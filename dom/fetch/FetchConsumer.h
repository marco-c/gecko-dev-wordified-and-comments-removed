#
ifndef
mozilla_dom_FetchConsumer_h
#
define
mozilla_dom_FetchConsumer_h
#
include
"
Fetch
.
h
"
class
nsIThread
;
namespace
mozilla
{
namespace
dom
{
class
Promise
;
namespace
workers
{
class
WorkerPrivate
;
class
WorkerHolder
;
}
template
<
class
Derived
>
class
FetchBody
;
template
<
class
Derived
>
class
FetchBodyConsumer
final
{
public
:
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FetchBodyConsumer
<
Derived
>
)
static
already_AddRefed
<
Promise
>
Create
(
nsIGlobalObject
*
aGlobal
nsIEventTarget
*
aMainThreadEventTarget
FetchBody
<
Derived
>
*
aBody
FetchConsumeType
aType
ErrorResult
&
aRv
)
;
void
ReleaseObject
(
)
;
FetchBody
<
Derived
>
*
Body
(
)
const
{
return
mBody
;
}
void
BeginConsumeBodyMainThread
(
)
;
void
ContinueConsumeBody
(
nsresult
aStatus
uint32_t
aLength
uint8_t
*
aResult
)
;
void
ContinueConsumeBlobBody
(
BlobImpl
*
aBlobImpl
)
;
void
CancelPump
(
)
;
workers
:
:
WorkerPrivate
*
GetWorkerPrivate
(
)
const
{
return
mWorkerPrivate
;
}
private
:
FetchBodyConsumer
(
nsIEventTarget
*
aMainThreadEventTarget
workers
:
:
WorkerPrivate
*
aWorkerPrivate
FetchBody
<
Derived
>
*
aBody
Promise
*
aPromise
FetchConsumeType
aType
)
;
~
FetchBodyConsumer
(
)
;
void
AssertIsOnTargetThread
(
)
const
;
bool
RegisterWorkerHolder
(
workers
:
:
WorkerPrivate
*
aWorkerPrivate
)
;
nsCOMPtr
<
nsIThread
>
mTargetThread
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
RefPtr
<
FetchBody
<
Derived
>
>
mBody
;
UniquePtr
<
workers
:
:
WorkerHolder
>
mWorkerHolder
;
workers
:
:
WorkerPrivate
*
mWorkerPrivate
;
nsMainThreadPtrHandle
<
nsIInputStreamPump
>
mConsumeBodyPump
;
FetchConsumeType
mConsumeType
;
RefPtr
<
Promise
>
mConsumePromise
;
#
ifdef
DEBUG
bool
mReadDone
;
#
endif
}
;
}
}
#
endif
