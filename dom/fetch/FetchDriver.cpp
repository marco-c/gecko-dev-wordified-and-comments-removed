#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
FetchDriver
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsIJARChannel
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIPipe
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
nsDataHandler
.
h
"
#
include
"
nsHostObjectProtocolHandler
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
workers
/
Workers
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
Fetch
.
h
"
#
include
"
InternalRequest
.
h
"
#
include
"
InternalResponse
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_ISUPPORTS
(
FetchDriver
nsIStreamListener
nsIChannelEventSink
nsIInterfaceRequestor
nsIAsyncVerifyRedirectCallback
nsIThreadRetargetableStreamListener
)
FetchDriver
:
:
FetchDriver
(
InternalRequest
*
aRequest
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
)
:
mPrincipal
(
aPrincipal
)
mLoadGroup
(
aLoadGroup
)
mRequest
(
aRequest
)
mFetchRecursionCount
(
0
)
mCORSFlagEverSet
(
false
)
mResponseAvailableCalled
(
false
)
{
}
FetchDriver
:
:
~
FetchDriver
(
)
{
MOZ_ASSERT
(
mResponseAvailableCalled
)
;
}
nsresult
FetchDriver
:
:
Fetch
(
FetchDriverObserver
*
aObserver
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
mObserver
=
aObserver
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SERVICE_WORKER_REQUEST_PASSTHROUGH
mRequest
-
>
WasCreatedByFetchEvent
(
)
)
;
return
Fetch
(
false
)
;
}
nsresult
FetchDriver
:
:
Fetch
(
bool
aCORSFlag
)
{
MOZ_ASSERT
(
mFetchRecursionCount
=
=
0
)
;
mFetchRecursionCount
+
+
;
if
(
!
mRequest
-
>
IsSynchronous
(
)
&
&
mFetchRecursionCount
<
=
1
)
{
nsCOMPtr
<
nsIRunnable
>
r
=
NS_NewRunnableMethodWithArg
<
bool
>
(
this
&
FetchDriver
:
:
ContinueFetch
aCORSFlag
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
r
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
}
return
rv
;
}
MOZ_CRASH
(
"
Synchronous
fetch
not
supported
"
)
;
}
FetchDriver
:
:
MainFetchOp
FetchDriver
:
:
SetTaintingAndGetNextOp
(
bool
aCORSFlag
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
nsAutoCString
url
;
mRequest
-
>
GetURL
(
url
)
;
nsCOMPtr
<
nsIURI
>
requestURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
requestURI
)
url
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
MainFetchOp
(
NETWORK_ERROR
)
;
}
int16_t
shouldLoad
;
rv
=
NS_CheckContentLoadPolicy
(
mRequest
-
>
ContentPolicyType
(
)
requestURI
mPrincipal
mDocument
EmptyCString
(
)
nullptr
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
nsContentUtils
:
:
GetSecurityManager
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
)
{
return
MainFetchOp
(
NETWORK_ERROR
)
;
}
nsAutoCString
scheme
;
rv
=
requestURI
-
>
GetScheme
(
scheme
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
MainFetchOp
(
NETWORK_ERROR
)
;
}
rv
=
mPrincipal
-
>
CheckMayLoad
(
requestURI
false
false
)
;
if
(
(
!
aCORSFlag
&
&
NS_SUCCEEDED
(
rv
)
)
|
|
(
scheme
.
EqualsLiteral
(
"
data
"
)
&
&
mRequest
-
>
SameOriginDataURL
(
)
)
|
|
scheme
.
EqualsLiteral
(
"
about
"
)
)
{
return
MainFetchOp
(
BASIC_FETCH
)
;
}
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Same_origin
)
{
return
MainFetchOp
(
NETWORK_ERROR
)
;
}
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
No_cors
)
{
mRequest
-
>
SetResponseTainting
(
InternalRequest
:
:
RESPONSETAINT_OPAQUE
)
;
return
MainFetchOp
(
BASIC_FETCH
)
;
}
if
(
!
scheme
.
EqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
)
{
return
MainFetchOp
(
NETWORK_ERROR
)
;
}
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Cors_with_forced_preflight
|
|
(
mRequest
-
>
UnsafeRequest
(
)
&
&
(
!
mRequest
-
>
HasSimpleMethod
(
)
|
|
!
mRequest
-
>
Headers
(
)
-
>
HasOnlySimpleHeaders
(
)
)
)
)
{
mRequest
-
>
SetResponseTainting
(
InternalRequest
:
:
RESPONSETAINT_CORS
)
;
mRequest
-
>
SetRedirectMode
(
RequestRedirect
:
:
Error
)
;
return
MainFetchOp
(
HTTP_FETCH
true
true
)
;
}
mRequest
-
>
SetResponseTainting
(
InternalRequest
:
:
RESPONSETAINT_CORS
)
;
return
MainFetchOp
(
HTTP_FETCH
true
false
)
;
}
nsresult
FetchDriver
:
:
ContinueFetch
(
bool
aCORSFlag
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
MainFetchOp
nextOp
=
SetTaintingAndGetNextOp
(
aCORSFlag
)
;
if
(
nextOp
.
mType
=
=
NETWORK_ERROR
)
{
return
FailWithNetworkError
(
)
;
}
if
(
nextOp
.
mType
=
=
BASIC_FETCH
)
{
return
BasicFetch
(
)
;
}
if
(
nextOp
.
mType
=
=
HTTP_FETCH
)
{
return
HttpFetch
(
nextOp
.
mCORSFlag
nextOp
.
mCORSPreflightFlag
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
main
fetch
operation
!
"
)
;
return
FailWithNetworkError
(
)
;
}
nsresult
FetchDriver
:
:
BasicFetch
(
)
{
nsAutoCString
url
;
mRequest
-
>
GetURL
(
url
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
url
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
about
"
)
)
{
if
(
url
.
EqualsLiteral
(
"
about
:
blank
"
)
)
{
nsRefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
200
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
ErrorResult
result
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
NS_LITERAL_CSTRING
(
"
text
/
html
;
charset
=
utf
-
8
"
)
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
nsCOMPtr
<
nsIInputStream
>
body
;
rv
=
NS_NewCStringInputStream
(
getter_AddRefs
(
body
)
EmptyCString
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
response
-
>
SetBody
(
body
)
;
BeginResponse
(
response
)
;
return
SucceedWithResponse
(
)
;
}
return
FailWithNetworkError
(
)
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
blob
"
)
)
{
nsRefPtr
<
BlobImpl
>
blobImpl
;
rv
=
NS_GetBlobForBlobURI
(
uri
getter_AddRefs
(
blobImpl
)
)
;
BlobImpl
*
blob
=
static_cast
<
BlobImpl
*
>
(
blobImpl
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsRefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
200
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
ErrorResult
result
;
uint64_t
size
=
blob
-
>
GetSize
(
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
StealNSResult
(
)
;
}
nsAutoString
sizeStr
;
sizeStr
.
AppendInt
(
size
)
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Length
"
)
NS_ConvertUTF16toUTF8
(
sizeStr
)
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
StealNSResult
(
)
;
}
nsAutoString
type
;
blob
-
>
GetType
(
type
)
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
NS_ConvertUTF16toUTF8
(
type
)
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
blob
-
>
GetInternalStream
(
getter_AddRefs
(
stream
)
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
StealNSResult
(
)
;
}
response
-
>
SetBody
(
stream
)
;
BeginResponse
(
response
)
;
return
SucceedWithResponse
(
)
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
data
"
)
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
if
(
method
.
LowerCaseEqualsASCII
(
"
get
"
)
)
{
nsresult
rv
;
nsCOMPtr
<
nsIProtocolHandler
>
dataHandler
=
do_GetService
(
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
"
data
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
dataHandler
-
>
NewChannel
(
uri
getter_AddRefs
(
channel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
channel
-
>
Open
(
getter_AddRefs
(
stream
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
nsAutoCString
contentType
;
if
(
NS_SUCCEEDED
(
channel
-
>
GetContentType
(
contentType
)
)
)
{
nsAutoCString
charset
;
if
(
NS_SUCCEEDED
(
channel
-
>
GetContentCharset
(
charset
)
)
&
&
!
charset
.
IsEmpty
(
)
)
{
contentType
.
AppendLiteral
(
"
;
charset
=
"
)
;
contentType
.
Append
(
charset
)
;
}
}
else
{
NS_WARNING
(
"
Could
not
get
content
type
from
data
channel
"
)
;
}
nsRefPtr
<
InternalResponse
>
response
=
new
InternalResponse
(
200
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
ErrorResult
result
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
contentType
result
)
;
if
(
NS_WARN_IF
(
result
.
Failed
(
)
)
)
{
FailWithNetworkError
(
)
;
return
result
.
StealNSResult
(
)
;
}
response
-
>
SetBody
(
stream
)
;
BeginResponse
(
response
)
;
return
SucceedWithResponse
(
)
;
}
return
FailWithNetworkError
(
)
;
}
if
(
scheme
.
LowerCaseEqualsLiteral
(
"
http
"
)
|
|
scheme
.
LowerCaseEqualsLiteral
(
"
https
"
)
|
|
scheme
.
LowerCaseEqualsLiteral
(
"
app
"
)
)
{
return
HttpFetch
(
)
;
}
return
FailWithNetworkError
(
)
;
}
nsresult
FetchDriver
:
:
HttpFetch
(
bool
aCORSFlag
bool
aCORSPreflightFlag
bool
aAuthenticationFlag
)
{
mResponse
=
nullptr
;
nsresult
rv
;
mCORSFlagEverSet
=
mCORSFlagEverSet
|
|
aCORSFlag
;
nsCOMPtr
<
nsIIOService
>
ios
=
do_GetIOService
(
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsAutoCString
url
;
mRequest
-
>
GetURL
(
url
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
url
nullptr
nullptr
ios
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
bool
useCredentials
=
false
;
if
(
mRequest
-
>
GetCredentialsMode
(
)
=
=
RequestCredentials
:
:
Include
|
|
(
mRequest
-
>
GetCredentialsMode
(
)
=
=
RequestCredentials
:
:
Same_origin
&
&
!
aCORSFlag
)
)
{
useCredentials
=
true
;
}
const
nsLoadFlags
credentialsFlag
=
useCredentials
?
0
:
nsIRequest
:
:
LOAD_ANONYMOUS
;
MOZ_ASSERT
(
mLoadGroup
)
;
nsCOMPtr
<
nsIChannel
>
chan
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
uri
mPrincipal
nsILoadInfo
:
:
SEC_NORMAL
mRequest
-
>
ContentPolicyType
(
)
mLoadGroup
nullptr
nsIRequest
:
:
LOAD_NORMAL
|
credentialsFlag
ios
)
;
mLoadGroup
=
nullptr
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
chan
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
mNotificationCallbacks
)
)
;
chan
-
>
SetNotificationCallbacks
(
this
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChan
=
do_QueryInterface
(
chan
)
;
if
(
httpChan
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
rv
=
httpChan
-
>
SetRequestMethod
(
method
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
nsAutoTArray
<
InternalHeaders
:
:
Entry
5
>
headers
;
mRequest
-
>
Headers
(
)
-
>
GetEntries
(
headers
)
;
for
(
uint32_t
i
=
0
;
i
<
headers
.
Length
(
)
;
+
+
i
)
{
if
(
headers
[
i
]
.
mValue
.
IsEmpty
(
)
)
{
httpChan
-
>
SetEmptyRequestHeader
(
headers
[
i
]
.
mName
)
;
}
else
{
httpChan
-
>
SetRequestHeader
(
headers
[
i
]
.
mName
headers
[
i
]
.
mValue
false
)
;
}
}
nsAutoString
referrer
;
mRequest
-
>
GetReferrer
(
referrer
)
;
if
(
referrer
.
EqualsLiteral
(
kFETCH_CLIENT_REFERRER_STR
)
)
{
rv
=
nsContentUtils
:
:
SetFetchReferrerURIWithPolicy
(
mPrincipal
mDocument
httpChan
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
}
else
if
(
referrer
.
IsEmpty
(
)
)
{
rv
=
httpChan
-
>
SetReferrerWithPolicy
(
nullptr
net
:
:
RP_No_Referrer
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
}
else
{
nsCOMPtr
<
nsIURI
>
referrerURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
referrerURI
)
referrer
nullptr
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
rv
=
httpChan
-
>
SetReferrerWithPolicy
(
referrerURI
mDocument
?
mDocument
-
>
GetReferrerPolicy
(
)
:
net
:
:
RP_Default
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
}
if
(
mRequest
-
>
ForceOriginHeader
(
)
)
{
nsAutoString
origin
;
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
mPrincipal
origin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
httpChan
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
origin
"
)
NS_ConvertUTF16toUTF8
(
origin
)
false
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChan
=
do_QueryInterface
(
httpChan
)
;
internalChan
-
>
SetCorsMode
(
static_cast
<
uint32_t
>
(
mRequest
-
>
Mode
(
)
)
)
;
internalChan
-
>
SetRedirectMode
(
static_cast
<
uint32_t
>
(
mRequest
-
>
GetRedirectMode
(
)
)
)
;
}
nsCOMPtr
<
nsIUploadChannel2
>
uploadChan
=
do_QueryInterface
(
chan
)
;
if
(
uploadChan
)
{
nsAutoCString
contentType
;
ErrorResult
result
;
mRequest
-
>
Headers
(
)
-
>
Get
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
contentType
result
)
;
if
(
result
.
Failed
(
)
)
{
return
FailWithNetworkError
(
)
;
}
nsCOMPtr
<
nsIInputStream
>
bodyStream
;
mRequest
-
>
GetBody
(
getter_AddRefs
(
bodyStream
)
)
;
if
(
bodyStream
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
rv
=
uploadChan
-
>
ExplicitSetUploadStream
(
bodyStream
contentType
-
1
method
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
}
}
if
(
mRequest
-
>
SkipServiceWorker
(
)
)
{
if
(
httpChan
)
{
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChan
=
do_QueryInterface
(
httpChan
)
;
internalChan
-
>
ForceNoIntercept
(
)
;
}
else
{
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
chan
)
;
MOZ_ASSERT
(
jarChannel
)
;
jarChannel
-
>
ForceNoIntercept
(
)
;
}
}
nsCOMPtr
<
nsIStreamListener
>
listener
=
this
;
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Cors
)
{
nsRefPtr
<
nsCORSListenerProxy
>
corsListener
=
new
nsCORSListenerProxy
(
this
mPrincipal
useCredentials
)
;
rv
=
corsListener
-
>
Init
(
chan
DataURIHandling
:
:
Allow
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
listener
=
corsListener
.
forget
(
)
;
}
if
(
aCORSPreflightFlag
)
{
MOZ_ASSERT
(
mRequest
-
>
Mode
(
)
!
=
RequestMode
:
:
No_cors
"
FetchDriver
:
:
ContinueFetch
(
)
should
ensure
that
the
request
is
not
no
-
cors
"
)
;
MOZ_ASSERT
(
httpChan
"
CORS
preflight
can
only
be
used
with
HTTP
channels
"
)
;
nsAutoTArray
<
nsCString
5
>
unsafeHeaders
;
mRequest
-
>
Headers
(
)
-
>
GetUnsafeHeaders
(
unsafeHeaders
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChan
=
do_QueryInterface
(
httpChan
)
;
rv
=
internalChan
-
>
SetCorsPreflightParameters
(
unsafeHeaders
useCredentials
mPrincipal
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
}
rv
=
chan
-
>
AsyncOpen
(
listener
nullptr
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
FailWithNetworkError
(
)
;
}
return
NS_OK
;
}
nsresult
FetchDriver
:
:
ContinueHttpFetchAfterNetworkFetch
(
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mResponse
)
;
MOZ_ASSERT
(
!
mResponse
-
>
IsError
(
)
)
;
return
SucceedWithResponse
(
)
;
}
already_AddRefed
<
InternalResponse
>
FetchDriver
:
:
BeginAndGetFilteredResponse
(
InternalResponse
*
aResponse
nsIURI
*
aFinalURI
)
{
MOZ_ASSERT
(
aResponse
)
;
nsAutoCString
reqURL
;
if
(
aFinalURI
)
{
aFinalURI
-
>
GetSpec
(
reqURL
)
;
}
else
{
mRequest
-
>
GetURL
(
reqURL
)
;
}
DebugOnly
<
nsresult
>
rv
=
aResponse
-
>
StripFragmentAndSetUrl
(
reqURL
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsRefPtr
<
InternalResponse
>
filteredResponse
;
switch
(
mRequest
-
>
GetResponseTainting
(
)
)
{
case
InternalRequest
:
:
RESPONSETAINT_BASIC
:
filteredResponse
=
aResponse
-
>
BasicResponse
(
)
;
break
;
case
InternalRequest
:
:
RESPONSETAINT_CORS
:
filteredResponse
=
aResponse
-
>
CORSResponse
(
)
;
break
;
case
InternalRequest
:
:
RESPONSETAINT_OPAQUE
:
filteredResponse
=
aResponse
-
>
OpaqueResponse
(
)
;
break
;
case
InternalRequest
:
:
RESPONSETAINT_OPAQUEREDIRECT
:
filteredResponse
=
aResponse
-
>
OpaqueRedirectResponse
(
)
;
break
;
default
:
MOZ_CRASH
(
"
Unexpected
case
"
)
;
}
MOZ_ASSERT
(
filteredResponse
)
;
MOZ_ASSERT
(
mObserver
)
;
mObserver
-
>
OnResponseAvailable
(
filteredResponse
)
;
mResponseAvailableCalled
=
true
;
return
filteredResponse
.
forget
(
)
;
}
void
FetchDriver
:
:
BeginResponse
(
InternalResponse
*
aResponse
)
{
nsRefPtr
<
InternalResponse
>
r
=
BeginAndGetFilteredResponse
(
aResponse
nullptr
)
;
}
nsresult
FetchDriver
:
:
SucceedWithResponse
(
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
if
(
mObserver
)
{
mObserver
-
>
OnResponseEnd
(
)
;
mObserver
=
nullptr
;
}
return
NS_OK
;
}
nsresult
FetchDriver
:
:
FailWithNetworkError
(
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
nsRefPtr
<
InternalResponse
>
error
=
InternalResponse
:
:
NetworkError
(
)
;
if
(
mObserver
)
{
mObserver
-
>
OnResponseAvailable
(
error
)
;
mResponseAvailableCalled
=
true
;
mObserver
-
>
OnResponseEnd
(
)
;
mObserver
=
nullptr
;
}
return
NS_OK
;
}
namespace
{
class
FillResponseHeaders
final
:
public
nsIHttpHeaderVisitor
{
InternalResponse
*
mResponse
;
~
FillResponseHeaders
(
)
{
}
public
:
NS_DECL_ISUPPORTS
explicit
FillResponseHeaders
(
InternalResponse
*
aResponse
)
:
mResponse
(
aResponse
)
{
}
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
ErrorResult
result
;
mResponse
-
>
Headers
(
)
-
>
Append
(
aHeader
aValue
result
)
;
if
(
result
.
Failed
(
)
)
{
NS_WARNING
(
nsPrintfCString
(
"
Fetch
ignoring
illegal
header
-
'
%
s
'
:
'
%
s
'
"
PromiseFlatCString
(
aHeader
)
.
get
(
)
PromiseFlatCString
(
aValue
)
.
get
(
)
)
.
get
(
)
)
;
result
.
SuppressException
(
)
;
}
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
FillResponseHeaders
nsIHttpHeaderVisitor
)
}
NS_IMETHODIMP
FetchDriver
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
nsresult
rv
;
aRequest
-
>
GetStatus
(
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
MOZ_ASSERT
(
!
mPipeOutputStream
)
;
MOZ_ASSERT
(
mObserver
)
;
nsRefPtr
<
InternalResponse
>
response
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
httpChannel
)
{
uint32_t
responseStatus
;
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
nsAutoCString
statusText
;
httpChannel
-
>
GetResponseStatusText
(
statusText
)
;
response
=
new
InternalResponse
(
responseStatus
statusText
)
;
nsRefPtr
<
FillResponseHeaders
>
visitor
=
new
FillResponseHeaders
(
response
)
;
rv
=
httpChannel
-
>
VisitResponseHeaders
(
visitor
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
NS_WARNING
(
"
Failed
to
visit
all
headers
.
"
)
;
}
}
else
{
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
aRequest
)
;
MOZ_ASSERT
(
jarChannel
)
;
uint32_t
responseStatus
=
200
;
nsAutoCString
statusText
;
response
=
new
InternalResponse
(
responseStatus
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
ErrorResult
result
;
nsAutoCString
contentType
;
jarChannel
-
>
GetContentType
(
contentType
)
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
contentType
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
}
nsCOMPtr
<
nsIInputStream
>
pipeInputStream
;
rv
=
NS_NewPipe
(
getter_AddRefs
(
pipeInputStream
)
getter_AddRefs
(
mPipeOutputStream
)
0
UINT32_MAX
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
response
-
>
SetBody
(
pipeInputStream
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
response
-
>
InitChannelInfo
(
channel
)
;
nsCOMPtr
<
nsIURI
>
channelURI
;
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
channelURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
mResponse
=
BeginAndGetFilteredResponse
(
response
channelURI
)
;
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
)
;
return
rv
;
}
if
(
nsCOMPtr
<
nsIThreadRetargetableRequest
>
rr
=
do_QueryInterface
(
aRequest
)
)
{
NS_WARN_IF
(
NS_FAILED
(
rr
-
>
RetargetDeliveryTo
(
sts
)
)
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
uint32_t
aRead
;
MOZ_ASSERT
(
mResponse
)
;
MOZ_ASSERT
(
mPipeOutputStream
)
;
nsresult
rv
=
aInputStream
-
>
ReadSegments
(
NS_CopySegmentToStream
mPipeOutputStream
aCount
&
aRead
)
;
return
rv
;
}
NS_IMETHODIMP
FetchDriver
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
workers
:
:
AssertIsOnMainThread
(
)
;
if
(
mPipeOutputStream
)
{
mPipeOutputStream
-
>
Close
(
)
;
}
if
(
NS_FAILED
(
aStatusCode
)
)
{
FailWithNetworkError
(
)
;
return
aStatusCode
;
}
ContinueHttpFetchAfterNetworkFetch
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
{
NS_PRECONDITION
(
aNewChannel
"
Redirect
without
a
channel
?
"
)
;
nsresult
rv
;
if
(
NS_WARN_IF
(
mRequest
-
>
GetRedirectMode
(
)
=
=
RequestRedirect
:
:
Error
)
)
{
aOldChannel
-
>
Cancel
(
NS_BINDING_FAILED
)
;
return
NS_BINDING_FAILED
;
}
mRequest
-
>
UnsetSameOriginDataURL
(
)
;
if
(
mRequest
-
>
GetRedirectMode
(
)
=
=
RequestRedirect
:
:
Manual
)
{
mRequest
-
>
SetResponseTainting
(
InternalRequest
:
:
RESPONSETAINT_OPAQUEREDIRECT
)
;
unused
<
<
OnStartRequest
(
aOldChannel
nullptr
)
;
unused
<
<
OnStopRequest
(
aOldChannel
nullptr
NS_OK
)
;
aOldChannel
-
>
Cancel
(
NS_BINDING_FAILED
)
;
return
NS_BINDING_FAILED
;
}
MOZ_ASSERT
(
mRequest
-
>
GetRedirectMode
(
)
=
=
RequestRedirect
:
:
Follow
)
;
mRedirectCallback
=
aCallback
;
mOldRedirectChannel
=
aOldChannel
;
mNewRedirectChannel
=
aNewChannel
;
nsCOMPtr
<
nsIChannelEventSink
>
outer
=
do_GetInterface
(
mNotificationCallbacks
)
;
if
(
outer
)
{
rv
=
outer
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
aOldChannel
-
>
Cancel
(
rv
)
;
mRedirectCallback
=
nullptr
;
mOldRedirectChannel
=
nullptr
;
mNewRedirectChannel
=
nullptr
;
}
return
rv
;
}
(
void
)
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
CheckListenerChain
(
)
{
return
NS_OK
;
}
nsresult
FetchDriver
:
:
DoesNotRequirePreflight
(
nsIChannel
*
aChannel
)
{
if
(
nsContentUtils
:
:
CheckMayLoad
(
mPrincipal
aChannel
true
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
NS_ENSURE_TRUE
(
httpChannel
NS_ERROR_DOM_BAD_URI
)
;
nsAutoCString
method
;
httpChannel
-
>
GetRequestMethod
(
method
)
;
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Cors_with_forced_preflight
|
|
!
mRequest
-
>
Headers
(
)
-
>
HasOnlySimpleHeaders
(
)
|
|
(
!
method
.
LowerCaseEqualsLiteral
(
"
get
"
)
&
&
!
method
.
LowerCaseEqualsLiteral
(
"
post
"
)
&
&
!
method
.
LowerCaseEqualsLiteral
(
"
head
"
)
)
)
{
return
NS_ERROR_DOM_BAD_URI
;
}
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
*
aResult
=
static_cast
<
nsIChannelEventSink
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
nsresult
rv
;
if
(
mNotificationCallbacks
)
{
rv
=
mNotificationCallbacks
-
>
GetInterface
(
aIID
aResult
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NS_ASSERTION
(
*
aResult
"
Lying
nsIInterfaceRequestor
implementation
!
"
)
;
return
rv
;
}
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIStreamListener
)
)
)
{
*
aResult
=
static_cast
<
nsIStreamListener
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIRequestObserver
)
)
)
{
*
aResult
=
static_cast
<
nsIRequestObserver
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
return
QueryInterface
(
aIID
aResult
)
;
}
NS_IMETHODIMP
FetchDriver
:
:
OnRedirectVerifyCallback
(
nsresult
aResult
)
{
if
(
NS_SUCCEEDED
(
aResult
)
)
{
nsCOMPtr
<
nsIURI
>
newURI
;
nsresult
rv
=
NS_GetFinalChannelURI
(
mNewRedirectChannel
getter_AddRefs
(
newURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aResult
=
rv
;
}
else
{
nsAutoCString
newUrl
;
newURI
-
>
GetSpec
(
newUrl
)
;
mRequest
-
>
SetURL
(
newUrl
)
;
}
}
if
(
NS_FAILED
(
aResult
)
)
{
mOldRedirectChannel
-
>
Cancel
(
aResult
)
;
}
MainFetchOp
nextOp
=
SetTaintingAndGetNextOp
(
mCORSFlagEverSet
)
;
if
(
nextOp
.
mType
=
=
NETWORK_ERROR
)
{
aResult
=
NS_ERROR_DOM_BAD_URI
;
mOldRedirectChannel
-
>
Cancel
(
aResult
)
;
}
else
{
MOZ_ASSERT
(
nextOp
.
mType
=
=
BASIC_FETCH
|
|
nextOp
.
mType
=
=
HTTP_FETCH
)
;
MOZ_ASSERT_IF
(
mCORSFlagEverSet
nextOp
.
mType
=
=
HTTP_FETCH
)
;
MOZ_ASSERT_IF
(
mCORSFlagEverSet
nextOp
.
mCORSFlag
)
;
}
mOldRedirectChannel
=
nullptr
;
mNewRedirectChannel
=
nullptr
;
mRedirectCallback
-
>
OnRedirectVerifyCallback
(
aResult
)
;
mRedirectCallback
=
nullptr
;
return
NS_OK
;
}
void
FetchDriver
:
:
SetDocument
(
nsIDocument
*
aDocument
)
{
MOZ_ASSERT
(
mFetchRecursionCount
=
=
0
)
;
mDocument
=
aDocument
;
}
}
}
