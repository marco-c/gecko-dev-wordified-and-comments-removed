#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
FetchDriver
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIInputStream
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsIThreadRetargetableRequest
.
h
"
#
include
"
nsIUploadChannel2
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIPipe
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsDataHandler
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsStringStream
.
h
"
#
include
"
nsHttpChannel
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceStorage
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundSharedTypes
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
Fetch
.
h
"
#
include
"
FetchUtil
.
h
"
#
include
"
InternalRequest
.
h
"
#
include
"
InternalResponse
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
void
GetBlobURISpecFromChannel
(
nsIRequest
*
aRequest
nsCString
&
aBlobURISpec
)
{
MOZ_ASSERT
(
aRequest
)
;
aBlobURISpec
.
SetIsVoid
(
true
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
channel
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
!
dom
:
:
IsBlobURI
(
uri
)
)
{
return
;
}
uri
-
>
GetSpec
(
aBlobURISpec
)
;
}
bool
ShouldCheckSRI
(
const
InternalRequest
*
const
aRequest
const
InternalResponse
*
const
aResponse
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aRequest
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aResponse
)
;
return
!
aRequest
-
>
GetIntegrity
(
)
.
IsEmpty
(
)
&
&
aResponse
-
>
Type
(
)
!
=
ResponseType
:
:
Error
;
}
}
class
AlternativeDataStreamListener
final
:
public
nsIStreamListener
public
nsIThreadRetargetableStreamListener
{
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIREQUESTOBSERVER
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSITHREADRETARGETABLESTREAMLISTENER
enum
eStatus
{
LOADING
=
0
COMPLETED
CANCELED
FALLBACK
}
;
AlternativeDataStreamListener
(
FetchDriver
*
aFetchDriver
nsIChannel
*
aChannel
const
nsACString
&
aAlternativeDataType
)
;
eStatus
Status
(
)
;
void
Cancel
(
)
;
uint64_t
GetAlternativeDataCacheEntryId
(
)
;
const
nsACString
&
GetAlternativeDataType
(
)
const
;
already_AddRefed
<
nsICacheInfoChannel
>
GetCacheInfoChannel
(
)
;
already_AddRefed
<
nsIInputStream
>
GetAlternativeInputStream
(
)
;
private
:
~
AlternativeDataStreamListener
(
)
=
default
;
RefPtr
<
FetchDriver
>
mFetchDriver
;
nsCString
mAlternativeDataType
;
nsCOMPtr
<
nsIInputStream
>
mPipeAlternativeInputStream
;
nsCOMPtr
<
nsIOutputStream
>
mPipeAlternativeOutputStream
;
uint64_t
mAlternativeDataCacheEntryId
;
nsCOMPtr
<
nsICacheInfoChannel
>
mCacheInfoChannel
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
Atomic
<
eStatus
>
mStatus
;
}
;
NS_IMPL_ISUPPORTS
(
AlternativeDataStreamListener
nsIStreamListener
nsIThreadRetargetableStreamListener
)
AlternativeDataStreamListener
:
:
AlternativeDataStreamListener
(
FetchDriver
*
aFetchDriver
nsIChannel
*
aChannel
const
nsACString
&
aAlternativeDataType
)
:
mFetchDriver
(
aFetchDriver
)
mAlternativeDataType
(
aAlternativeDataType
)
mAlternativeDataCacheEntryId
(
0
)
mChannel
(
aChannel
)
mStatus
(
AlternativeDataStreamListener
:
:
LOADING
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mFetchDriver
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mChannel
)
;
}
AlternativeDataStreamListener
:
:
eStatus
AlternativeDataStreamListener
:
:
Status
(
)
{
return
mStatus
;
}
void
AlternativeDataStreamListener
:
:
Cancel
(
)
{
mAlternativeDataCacheEntryId
=
0
;
mCacheInfoChannel
=
nullptr
;
mPipeAlternativeOutputStream
=
nullptr
;
mPipeAlternativeInputStream
=
nullptr
;
if
(
mChannel
&
&
mStatus
!
=
AlternativeDataStreamListener
:
:
FALLBACK
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mChannel
=
nullptr
;
}
mStatus
=
AlternativeDataStreamListener
:
:
CANCELED
;
}
uint64_t
AlternativeDataStreamListener
:
:
GetAlternativeDataCacheEntryId
(
)
{
return
mAlternativeDataCacheEntryId
;
}
const
nsACString
&
AlternativeDataStreamListener
:
:
GetAlternativeDataType
(
)
const
{
return
mAlternativeDataType
;
}
already_AddRefed
<
nsIInputStream
>
AlternativeDataStreamListener
:
:
GetAlternativeInputStream
(
)
{
nsCOMPtr
<
nsIInputStream
>
inputStream
=
mPipeAlternativeInputStream
;
return
inputStream
.
forget
(
)
;
}
already_AddRefed
<
nsICacheInfoChannel
>
AlternativeDataStreamListener
:
:
GetCacheInfoChannel
(
)
{
nsCOMPtr
<
nsICacheInfoChannel
>
channel
=
mCacheInfoChannel
;
return
channel
.
forget
(
)
;
}
NS_IMETHODIMP
AlternativeDataStreamListener
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
mAlternativeDataType
.
IsEmpty
(
)
)
;
nsAutoCString
alternativeDataType
;
nsCOMPtr
<
nsICacheInfoChannel
>
cic
=
do_QueryInterface
(
aRequest
)
;
mStatus
=
AlternativeDataStreamListener
:
:
LOADING
;
if
(
cic
&
&
NS_SUCCEEDED
(
cic
-
>
GetAlternativeDataType
(
alternativeDataType
)
)
&
&
mAlternativeDataType
.
Equals
(
alternativeDataType
)
&
&
NS_SUCCEEDED
(
cic
-
>
GetCacheEntryId
(
&
mAlternativeDataCacheEntryId
)
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mPipeAlternativeInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mPipeAlternativeOutputStream
)
;
nsresult
rv
=
NS_NewPipe
(
getter_AddRefs
(
mPipeAlternativeInputStream
)
getter_AddRefs
(
mPipeAlternativeOutputStream
)
0
UINT32_MAX
true
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
mFetchDriver
-
>
FailWithNetworkError
(
rv
)
;
return
rv
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mCacheInfoChannel
)
;
mCacheInfoChannel
=
cic
;
MOZ_ASSERT
(
mFetchDriver
)
;
return
mFetchDriver
-
>
HttpFetch
(
)
;
}
else
{
MOZ_ASSERT
(
alternativeDataType
.
IsEmpty
(
)
)
;
mStatus
=
AlternativeDataStreamListener
:
:
FALLBACK
;
mAlternativeDataCacheEntryId
=
0
;
MOZ_ASSERT
(
mFetchDriver
)
;
return
mFetchDriver
-
>
OnStartRequest
(
aRequest
aContext
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AlternativeDataStreamListener
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
mStatus
=
=
AlternativeDataStreamListener
:
:
LOADING
)
{
MOZ_ASSERT
(
mPipeAlternativeOutputStream
)
;
uint32_t
read
;
return
aInputStream
-
>
ReadSegments
(
NS_CopySegmentToStream
mPipeAlternativeOutputStream
aCount
&
read
)
;
}
if
(
mStatus
=
=
AlternativeDataStreamListener
:
:
FALLBACK
)
{
MOZ_ASSERT
(
mFetchDriver
)
;
return
mFetchDriver
-
>
OnDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
AlternativeDataStreamListener
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
FetchDriver
>
fetchDriver
=
mFetchDriver
.
forget
(
)
;
if
(
mStatus
=
=
AlternativeDataStreamListener
:
:
CANCELED
)
{
return
NS_OK
;
}
if
(
mStatus
=
=
AlternativeDataStreamListener
:
:
FALLBACK
)
{
MOZ_ASSERT
(
fetchDriver
)
;
return
fetchDriver
-
>
OnStopRequest
(
aRequest
aContext
aStatusCode
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mStatus
=
=
AlternativeDataStreamListener
:
:
LOADING
)
;
MOZ_ASSERT
(
!
mAlternativeDataType
.
IsEmpty
(
)
&
&
mPipeAlternativeOutputStream
&
&
mPipeAlternativeInputStream
)
;
mPipeAlternativeOutputStream
-
>
Close
(
)
;
mPipeAlternativeOutputStream
=
nullptr
;
if
(
NS_FAILED
(
aStatusCode
)
)
{
mAlternativeDataCacheEntryId
=
0
;
mCacheInfoChannel
=
nullptr
;
mPipeAlternativeInputStream
=
nullptr
;
}
mStatus
=
AlternativeDataStreamListener
:
:
COMPLETED
;
MOZ_ASSERT
(
fetchDriver
)
;
return
fetchDriver
-
>
FinishOnStopRequest
(
this
)
;
}
NS_IMETHODIMP
AlternativeDataStreamListener
:
:
CheckListenerChain
(
)
{
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
FetchDriver
nsIStreamListener
nsIChannelEventSink
nsIInterfaceRequestor
nsIThreadRetargetableStreamListener
)
FetchDriver
:
:
FetchDriver
(
InternalRequest
*
aRequest
nsIPrincipal
*
aPrincipal
nsILoadGroup
*
aLoadGroup
nsIEventTarget
*
aMainThreadEventTarget
PerformanceStorage
*
aPerformanceStorage
bool
aIsTrackingFetch
)
:
mPrincipal
(
aPrincipal
)
mLoadGroup
(
aLoadGroup
)
mRequest
(
aRequest
)
mMainThreadEventTarget
(
aMainThreadEventTarget
)
mPerformanceStorage
(
aPerformanceStorage
)
mNeedToObserveOnDataAvailable
(
false
)
mIsTrackingFetch
(
aIsTrackingFetch
)
mOnStopRequestCalled
(
false
)
#
ifdef
DEBUG
mResponseAvailableCalled
(
false
)
mFetchCalled
(
false
)
#
endif
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aRequest
)
;
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aMainThreadEventTarget
)
;
}
FetchDriver
:
:
~
FetchDriver
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mResponseAvailableCalled
)
;
}
nsresult
FetchDriver
:
:
Fetch
(
AbortSignalImpl
*
aSignalImpl
FetchDriverObserver
*
aObserver
)
{
AssertIsOnMainThread
(
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mFetchCalled
)
;
mFetchCalled
=
true
;
#
endif
mObserver
=
aObserver
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SERVICE_WORKER_REQUEST_PASSTHROUGH
mRequest
-
>
WasCreatedByFetchEvent
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mRequest
-
>
IsSynchronous
(
)
"
Synchronous
fetch
not
supported
"
)
;
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
principalInfo
(
new
mozilla
:
:
ipc
:
:
PrincipalInfo
(
)
)
;
nsresult
rv
=
PrincipalToPrincipalInfo
(
mPrincipal
principalInfo
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
mRequest
-
>
SetPrincipalInfo
(
std
:
:
move
(
principalInfo
)
)
;
if
(
aSignalImpl
)
{
if
(
aSignalImpl
-
>
Aborted
(
)
)
{
Abort
(
)
;
return
NS_OK
;
}
Follow
(
aSignalImpl
)
;
}
rv
=
HttpFetch
(
mRequest
-
>
GetPreferredAlternativeDataType
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
FailWithNetworkError
(
rv
)
;
}
return
NS_OK
;
}
nsresult
FetchDriver
:
:
HttpFetch
(
const
nsACString
&
aPreferredAlternativeDataType
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mResponse
=
nullptr
;
mOnStopRequestCalled
=
false
;
nsresult
rv
;
nsCOMPtr
<
nsIIOService
>
ios
=
do_GetIOService
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
url
;
mRequest
-
>
GetURL
(
url
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
url
nullptr
nullptr
ios
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
No_cors
&
&
mRequest
-
>
UnsafeRequest
(
)
&
&
(
!
mRequest
-
>
HasSimpleMethod
(
)
|
|
!
mRequest
-
>
Headers
(
)
-
>
HasOnlySimpleHeaders
(
)
)
)
{
MOZ_ASSERT
(
false
"
The
API
should
have
caught
this
"
)
;
return
NS_ERROR_DOM_BAD_URI
;
}
if
(
IsBlobURI
(
uri
)
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
if
(
!
method
.
EqualsLiteral
(
"
GET
"
)
)
{
return
NS_ERROR_DOM_NETWORK_ERR
;
}
}
const
nsLoadFlags
bypassFlag
=
mRequest
-
>
SkipServiceWorker
(
)
?
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
:
0
;
nsSecurityFlags
secFlags
=
0
;
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Cors
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
}
else
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Same_origin
|
|
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Navigate
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
;
}
else
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
No_cors
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
request
mode
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
if
(
mRequest
-
>
GetRedirectMode
(
)
!
=
RequestRedirect
:
:
Follow
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_DONT_FOLLOW_REDIRECTS
;
}
if
(
mRequest
-
>
GetCredentialsMode
(
)
=
=
RequestCredentials
:
:
Include
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
else
if
(
mRequest
-
>
GetCredentialsMode
(
)
=
=
RequestCredentials
:
:
Omit
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_OMIT
;
}
else
if
(
mRequest
-
>
GetCredentialsMode
(
)
=
=
RequestCredentials
:
:
Same_origin
)
{
secFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
credentials
mode
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
MOZ_ASSERT
(
mLoadGroup
)
;
nsCOMPtr
<
nsIChannel
>
chan
;
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_BACKGROUND
|
bypassFlag
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
;
if
(
mDocument
)
{
MOZ_ASSERT
(
mDocument
-
>
NodePrincipal
(
)
=
=
mPrincipal
)
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
uri
mDocument
secFlags
mRequest
-
>
ContentPolicyType
(
)
nullptr
mLoadGroup
nullptr
loadFlags
ios
)
;
}
else
if
(
mClientInfo
.
isSome
(
)
)
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
uri
mPrincipal
mClientInfo
.
ref
(
)
mController
secFlags
mRequest
-
>
ContentPolicyType
(
)
mPerformanceStorage
mLoadGroup
nullptr
loadFlags
ios
)
;
}
else
{
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
uri
mPrincipal
secFlags
mRequest
-
>
ContentPolicyType
(
)
mPerformanceStorage
mLoadGroup
nullptr
loadFlags
ios
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mCSPEventListener
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
-
>
GetLoadInfo
(
)
;
if
(
NS_WARN_IF
(
!
loadInfo
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
rv
=
loadInfo
-
>
SetCspEventListener
(
mCSPEventListener
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIInterfaceRequestor
>
notificationCallbacks
;
chan
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
notificationCallbacks
)
)
;
MOZ_ASSERT
(
!
notificationCallbacks
)
;
}
#
endif
chan
-
>
SetNotificationCallbacks
(
this
)
;
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
chan
)
)
;
if
(
cos
&
&
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
UrgentStart
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChan
=
do_QueryInterface
(
chan
)
;
if
(
httpChan
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
rv
=
httpChan
-
>
SetRequestMethod
(
method
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
SetRequestHeaders
(
httpChan
)
;
net
:
:
ReferrerPolicy
net_referrerPolicy
=
mRequest
-
>
GetEnvironmentReferrerPolicy
(
)
;
if
(
mRequest
-
>
ReferrerPolicy_
(
)
=
=
ReferrerPolicy
:
:
_empty
)
{
mRequest
-
>
SetReferrerPolicy
(
net_referrerPolicy
)
;
}
if
(
mRequest
-
>
ReferrerPolicy_
(
)
=
=
ReferrerPolicy
:
:
_empty
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
httpChan
-
>
GetLoadInfo
(
)
;
bool
isPrivate
=
loadInfo
-
>
GetOriginAttributes
(
)
.
mPrivateBrowsingId
>
0
;
net
:
:
ReferrerPolicy
referrerPolicy
=
static_cast
<
net
:
:
ReferrerPolicy
>
(
NS_GetDefaultReferrerPolicy
(
isPrivate
)
)
;
mRequest
-
>
SetReferrerPolicy
(
referrerPolicy
)
;
}
rv
=
FetchUtil
:
:
SetRequestReferrer
(
mPrincipal
mDocument
httpChan
mRequest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChan
=
do_QueryInterface
(
httpChan
)
;
rv
=
internalChan
-
>
SetCorsMode
(
static_cast
<
uint32_t
>
(
mRequest
-
>
Mode
(
)
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
internalChan
-
>
SetRedirectMode
(
static_cast
<
uint32_t
>
(
mRequest
-
>
GetRedirectMode
(
)
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
mRequest
-
>
MaybeSkipCacheIfPerformingRevalidation
(
)
;
rv
=
internalChan
-
>
SetFetchCacheMode
(
static_cast
<
uint32_t
>
(
mRequest
-
>
GetCacheMode
(
)
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
rv
=
internalChan
-
>
SetIntegrityMetadata
(
mRequest
-
>
GetIntegrity
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChan
)
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
fetch
"
)
)
;
}
}
nsCOMPtr
<
nsIUploadChannel2
>
uploadChan
=
do_QueryInterface
(
chan
)
;
if
(
uploadChan
)
{
nsAutoCString
contentType
;
ErrorResult
result
;
mRequest
-
>
Headers
(
)
-
>
GetFirst
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
contentType
result
)
;
if
(
result
.
Failed
(
)
)
{
return
result
.
StealNSResult
(
)
;
}
#
ifdef
DEBUG
bool
hasContentTypeHeader
=
mRequest
-
>
Headers
(
)
-
>
Has
(
NS_LITERAL_CSTRING
(
"
content
-
type
"
)
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
MOZ_ASSERT_IF
(
!
hasContentTypeHeader
contentType
.
IsVoid
(
)
)
;
#
endif
int64_t
bodyLength
;
nsCOMPtr
<
nsIInputStream
>
bodyStream
;
mRequest
-
>
GetBody
(
getter_AddRefs
(
bodyStream
)
&
bodyLength
)
;
if
(
bodyStream
)
{
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
rv
=
uploadChan
-
>
ExplicitSetUploadStream
(
bodyStream
contentType
bodyLength
method
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
if
(
mRequest
-
>
Mode
(
)
=
=
RequestMode
:
:
Cors
)
{
AutoTArray
<
nsCString
5
>
unsafeHeaders
;
mRequest
-
>
Headers
(
)
-
>
GetUnsafeHeaders
(
unsafeHeaders
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
chan
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
)
{
loadInfo
-
>
SetCorsPreflightInfo
(
unsafeHeaders
false
)
;
}
}
if
(
mIsTrackingFetch
&
&
nsContentUtils
:
:
IsTailingEnabled
(
)
&
&
cos
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Throttleable
|
nsIClassOfService
:
:
Tail
)
;
}
if
(
mIsTrackingFetch
&
&
StaticPrefs
:
:
privacy_trackingprotection_lower_network_priority
(
)
)
{
nsCOMPtr
<
nsISupportsPriority
>
p
=
do_QueryInterface
(
chan
)
;
if
(
p
)
{
p
-
>
SetPriority
(
nsISupportsPriority
:
:
PRIORITY_LOWEST
)
;
}
}
if
(
!
aPreferredAlternativeDataType
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsICacheInfoChannel
>
cic
=
do_QueryInterface
(
chan
)
;
if
(
cic
)
{
cic
-
>
PreferAlternativeDataType
(
aPreferredAlternativeDataType
EmptyCString
(
)
)
;
MOZ_ASSERT
(
!
mAltDataListener
)
;
mAltDataListener
=
new
AlternativeDataStreamListener
(
this
chan
aPreferredAlternativeDataType
)
;
rv
=
chan
-
>
AsyncOpen
(
mAltDataListener
)
;
}
else
{
rv
=
chan
-
>
AsyncOpen
(
this
)
;
}
}
else
{
rv
=
chan
-
>
AsyncOpen
(
this
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
mChannel
=
chan
;
return
NS_OK
;
}
already_AddRefed
<
InternalResponse
>
FetchDriver
:
:
BeginAndGetFilteredResponse
(
InternalResponse
*
aResponse
bool
aFoundOpaqueRedirect
)
{
MOZ_ASSERT
(
aResponse
)
;
AutoTArray
<
nsCString
4
>
reqURLList
;
mRequest
-
>
GetURLListWithoutFragment
(
reqURLList
)
;
MOZ_ASSERT
(
!
reqURLList
.
IsEmpty
(
)
)
;
aResponse
-
>
SetURLList
(
reqURLList
)
;
RefPtr
<
InternalResponse
>
filteredResponse
;
if
(
aFoundOpaqueRedirect
)
{
filteredResponse
=
aResponse
-
>
OpaqueRedirectResponse
(
)
;
}
else
{
switch
(
mRequest
-
>
GetResponseTainting
(
)
)
{
case
LoadTainting
:
:
Basic
:
filteredResponse
=
aResponse
-
>
BasicResponse
(
)
;
break
;
case
LoadTainting
:
:
CORS
:
filteredResponse
=
aResponse
-
>
CORSResponse
(
)
;
break
;
case
LoadTainting
:
:
Opaque
:
{
filteredResponse
=
aResponse
-
>
OpaqueResponse
(
)
;
nsresult
rv
=
filteredResponse
-
>
GeneratePaddingInfo
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
break
;
}
default
:
MOZ_CRASH
(
"
Unexpected
case
"
)
;
}
}
MOZ_ASSERT
(
filteredResponse
)
;
MOZ_ASSERT
(
mObserver
)
;
if
(
!
ShouldCheckSRI
(
mRequest
filteredResponse
)
)
{
mObserver
-
>
OnResponseAvailable
(
filteredResponse
)
;
#
ifdef
DEBUG
mResponseAvailableCalled
=
true
;
#
endif
}
return
filteredResponse
.
forget
(
)
;
}
void
FetchDriver
:
:
FailWithNetworkError
(
nsresult
rv
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
InternalResponse
>
error
=
InternalResponse
:
:
NetworkError
(
rv
)
;
if
(
mObserver
)
{
mObserver
-
>
OnResponseAvailable
(
error
)
;
#
ifdef
DEBUG
mResponseAvailableCalled
=
true
;
#
endif
mObserver
-
>
OnResponseEnd
(
FetchDriverObserver
:
:
eByNetworking
)
;
mObserver
=
nullptr
;
}
mChannel
=
nullptr
;
}
NS_IMETHODIMP
FetchDriver
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mChannel
)
{
MOZ_ASSERT
(
!
mObserver
)
;
return
NS_BINDING_ABORTED
;
}
nsresult
rv
;
aRequest
-
>
GetStatus
(
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
FailWithNetworkError
(
rv
)
;
return
rv
;
}
MOZ_ASSERT
(
!
mPipeOutputStream
)
;
MOZ_ASSERT
(
mObserver
)
;
mNeedToObserveOnDataAvailable
=
mObserver
-
>
NeedOnDataAvailable
(
)
;
RefPtr
<
InternalResponse
>
response
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aRequest
)
;
bool
foundOpaqueRedirect
=
false
;
int64_t
contentLength
=
InternalResponse
:
:
UNKNOWN_BODY_SIZE
;
rv
=
channel
-
>
GetContentLength
(
&
contentLength
)
;
MOZ_ASSERT_IF
(
NS_FAILED
(
rv
)
contentLength
=
=
InternalResponse
:
:
UNKNOWN_BODY_SIZE
)
;
if
(
httpChannel
)
{
uint32_t
responseStatus
;
rv
=
httpChannel
-
>
GetResponseStatus
(
&
responseStatus
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
mozilla
:
:
net
:
:
nsHttpChannel
:
:
IsRedirectStatus
(
responseStatus
)
)
{
if
(
mRequest
-
>
GetRedirectMode
(
)
=
=
RequestRedirect
:
:
Error
)
{
FailWithNetworkError
(
NS_BINDING_ABORTED
)
;
return
NS_BINDING_FAILED
;
}
if
(
mRequest
-
>
GetRedirectMode
(
)
=
=
RequestRedirect
:
:
Manual
)
{
foundOpaqueRedirect
=
true
;
}
}
nsAutoCString
statusText
;
rv
=
httpChannel
-
>
GetResponseStatusText
(
statusText
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
response
=
new
InternalResponse
(
responseStatus
statusText
)
;
UniquePtr
<
mozilla
:
:
ipc
:
:
PrincipalInfo
>
principalInfo
(
new
mozilla
:
:
ipc
:
:
PrincipalInfo
(
)
)
;
nsresult
rv
=
PrincipalToPrincipalInfo
(
mPrincipal
principalInfo
.
get
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
response
-
>
SetPrincipalInfo
(
std
:
:
move
(
principalInfo
)
)
;
response
-
>
Headers
(
)
-
>
FillResponseHeaders
(
httpChannel
)
;
ErrorResult
result
;
if
(
response
-
>
Headers
(
)
-
>
Has
(
NS_LITERAL_CSTRING
(
"
content
-
encoding
"
)
result
)
|
|
response
-
>
Headers
(
)
-
>
Has
(
NS_LITERAL_CSTRING
(
"
transfer
-
encoding
"
)
result
)
)
{
contentLength
=
InternalResponse
:
:
UNKNOWN_BODY_SIZE
;
}
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
}
else
{
response
=
new
InternalResponse
(
200
NS_LITERAL_CSTRING
(
"
OK
"
)
)
;
ErrorResult
result
;
nsAutoCString
contentType
;
rv
=
channel
-
>
GetContentType
(
contentType
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
contentType
.
IsEmpty
(
)
)
{
nsAutoCString
contentCharset
;
channel
-
>
GetContentCharset
(
contentCharset
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
contentCharset
.
IsEmpty
(
)
)
{
contentType
+
=
NS_LITERAL_CSTRING
(
"
;
charset
=
"
)
+
contentCharset
;
}
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Type
"
)
contentType
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
}
if
(
contentLength
>
0
)
{
nsAutoCString
contentLenStr
;
contentLenStr
.
AppendInt
(
contentLength
)
;
response
-
>
Headers
(
)
-
>
Append
(
NS_LITERAL_CSTRING
(
"
Content
-
Length
"
)
contentLenStr
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
}
}
nsCOMPtr
<
nsICacheInfoChannel
>
cic
=
do_QueryInterface
(
aRequest
)
;
if
(
cic
&
&
mAltDataListener
)
{
if
(
mAltDataListener
-
>
Status
(
)
!
=
AlternativeDataStreamListener
:
:
FALLBACK
)
{
uint64_t
cacheEntryId
=
0
;
if
(
NS_SUCCEEDED
(
cic
-
>
GetCacheEntryId
(
&
cacheEntryId
)
)
&
&
cacheEntryId
!
=
mAltDataListener
-
>
GetAlternativeDataCacheEntryId
(
)
)
{
mAltDataListener
-
>
Cancel
(
)
;
}
else
{
nsCOMPtr
<
nsICacheInfoChannel
>
cacheInfo
=
mAltDataListener
-
>
GetCacheInfoChannel
(
)
;
nsCOMPtr
<
nsIInputStream
>
altInputStream
=
mAltDataListener
-
>
GetAlternativeInputStream
(
)
;
MOZ_ASSERT
(
altInputStream
&
&
cacheInfo
)
;
response
-
>
SetAlternativeBody
(
altInputStream
)
;
nsMainThreadPtrHandle
<
nsICacheInfoChannel
>
handle
(
new
nsMainThreadPtrHolder
<
nsICacheInfoChannel
>
(
"
nsICacheInfoChannel
"
cacheInfo
false
)
)
;
response
-
>
SetCacheInfoChannel
(
handle
)
;
}
}
else
if
(
!
mAltDataListener
-
>
GetAlternativeDataType
(
)
.
IsEmpty
(
)
)
{
nsMainThreadPtrHandle
<
nsICacheInfoChannel
>
handle
(
new
nsMainThreadPtrHolder
<
nsICacheInfoChannel
>
(
"
nsICacheInfoChannel
"
cic
false
)
)
;
response
-
>
SetCacheInfoChannel
(
handle
)
;
}
}
nsCOMPtr
<
nsIInputStream
>
pipeInputStream
;
rv
=
NS_NewPipe
(
getter_AddRefs
(
pipeInputStream
)
getter_AddRefs
(
mPipeOutputStream
)
0
UINT32_MAX
true
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
rv
)
;
return
rv
;
}
response
-
>
SetBody
(
pipeInputStream
contentLength
)
;
nsCOMPtr
<
nsIFileChannel
>
fc
=
do_QueryInterface
(
aRequest
)
;
if
(
fc
)
{
nsCOMPtr
<
nsIFile
>
file
;
rv
=
fc
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
nsAutoString
path
;
file
-
>
GetPath
(
path
)
;
response
-
>
SetBodyLocalPath
(
path
)
;
}
}
else
{
nsCString
blobURISpec
;
GetBlobURISpecFromChannel
(
aRequest
blobURISpec
)
;
if
(
!
blobURISpec
.
IsVoid
(
)
)
{
response
-
>
SetBodyBlobURISpec
(
blobURISpec
)
;
}
}
response
-
>
InitChannelInfo
(
channel
)
;
nsCOMPtr
<
nsIURI
>
channelURI
;
rv
=
channel
-
>
GetURI
(
getter_AddRefs
(
channelURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
rv
)
;
return
rv
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
rv
=
channel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
rv
)
;
return
rv
;
}
mRequest
-
>
MaybeIncreaseResponseTainting
(
loadInfo
-
>
GetTainting
(
)
)
;
mResponse
=
BeginAndGetFilteredResponse
(
response
foundOpaqueRedirect
)
;
if
(
NS_WARN_IF
(
!
mResponse
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mResponse
-
>
Type
(
)
=
=
ResponseType
:
:
Opaque
)
;
FailWithNetworkError
(
NS_ERROR_UNEXPECTED
)
;
return
rv
;
}
if
(
ShouldCheckSRI
(
mRequest
mResponse
)
&
&
mSRIMetadata
.
IsEmpty
(
)
)
{
nsIConsoleReportCollector
*
reporter
=
nullptr
;
if
(
mObserver
)
{
reporter
=
mObserver
-
>
GetReporter
(
)
;
}
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
else
if
(
!
mWorkerScript
.
IsEmpty
(
)
)
{
sourceUri
.
Assign
(
mWorkerScript
)
;
}
SRICheck
:
:
IntegrityMetadata
(
mRequest
-
>
GetIntegrity
(
)
sourceUri
reporter
&
mSRIMetadata
)
;
mSRIDataVerifier
=
new
SRICheckDataVerifier
(
mSRIMetadata
sourceUri
reporter
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIEventTarget
>
sts
=
do_GetService
(
NS_STREAMTRANSPORTSERVICE_CONTRACTID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
FailWithNetworkError
(
rv
)
;
return
rv
;
}
if
(
nsCOMPtr
<
nsIThreadRetargetableRequest
>
rr
=
do_QueryInterface
(
aRequest
)
)
{
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rr
-
>
RetargetDeliveryTo
(
sts
)
)
)
;
}
return
NS_OK
;
}
namespace
{
class
DataAvailableRunnable
final
:
public
Runnable
{
RefPtr
<
FetchDriverObserver
>
mObserver
;
public
:
explicit
DataAvailableRunnable
(
FetchDriverObserver
*
aObserver
)
:
Runnable
(
"
dom
:
:
DataAvailableRunnable
"
)
mObserver
(
aObserver
)
{
MOZ_ASSERT
(
aObserver
)
;
}
NS_IMETHOD
Run
(
)
override
{
mObserver
-
>
OnDataAvailable
(
)
;
mObserver
=
nullptr
;
return
NS_OK
;
}
}
;
struct
SRIVerifierAndOutputHolder
{
SRIVerifierAndOutputHolder
(
SRICheckDataVerifier
*
aVerifier
nsIOutputStream
*
aOutputStream
)
:
mVerifier
(
aVerifier
)
mOutputStream
(
aOutputStream
)
{
}
SRICheckDataVerifier
*
mVerifier
;
nsIOutputStream
*
mOutputStream
;
private
:
SRIVerifierAndOutputHolder
(
)
=
delete
;
}
;
nsresult
CopySegmentToStreamAndSRI
(
nsIInputStream
*
aInStr
void
*
aClosure
const
char
*
aBuffer
uint32_t
aOffset
uint32_t
aCount
uint32_t
*
aCountWritten
)
{
auto
holder
=
static_cast
<
SRIVerifierAndOutputHolder
*
>
(
aClosure
)
;
MOZ_DIAGNOSTIC_ASSERT
(
holder
&
&
holder
-
>
mVerifier
&
&
holder
-
>
mOutputStream
"
Bogus
holder
"
)
;
nsresult
rv
=
holder
-
>
mVerifier
-
>
Update
(
aCount
reinterpret_cast
<
const
uint8_t
*
>
(
aBuffer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aCountWritten
=
0
;
while
(
aCount
)
{
uint32_t
n
=
0
;
rv
=
holder
-
>
mOutputStream
-
>
Write
(
aBuffer
aCount
&
n
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
aBuffer
+
=
n
;
aCount
-
=
n
;
*
aCountWritten
+
=
n
;
}
return
NS_OK
;
}
}
NS_IMETHODIMP
FetchDriver
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
mNeedToObserveOnDataAvailable
)
{
mNeedToObserveOnDataAvailable
=
false
;
if
(
mObserver
)
{
if
(
NS_IsMainThread
(
)
)
{
mObserver
-
>
OnDataAvailable
(
)
;
}
else
{
RefPtr
<
Runnable
>
runnable
=
new
DataAvailableRunnable
(
mObserver
)
;
nsresult
rv
=
mMainThreadEventTarget
-
>
Dispatch
(
runnable
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
}
}
}
uint32_t
aRead
=
0
;
MOZ_ASSERT
(
mResponse
)
;
MOZ_ASSERT
(
mPipeOutputStream
)
;
nsresult
rv
;
if
(
mResponse
-
>
Type
(
)
!
=
ResponseType
:
:
Opaque
&
&
ShouldCheckSRI
(
mRequest
mResponse
)
)
{
MOZ_ASSERT
(
mSRIDataVerifier
)
;
SRIVerifierAndOutputHolder
holder
(
mSRIDataVerifier
mPipeOutputStream
)
;
rv
=
aInputStream
-
>
ReadSegments
(
CopySegmentToStreamAndSRI
&
holder
aCount
&
aRead
)
;
}
else
{
rv
=
aInputStream
-
>
ReadSegments
(
NS_CopySegmentToStream
mPipeOutputStream
aCount
&
aRead
)
;
}
if
(
aRead
=
=
0
&
&
aCount
!
=
0
)
{
return
NS_BASE_STREAM_CLOSED
;
}
return
rv
;
}
NS_IMETHODIMP
FetchDriver
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
AssertIsOnMainThread
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mOnStopRequestCalled
)
;
mOnStopRequestCalled
=
true
;
RefPtr
<
AlternativeDataStreamListener
>
altDataListener
=
mAltDataListener
.
forget
(
)
;
if
(
NS_FAILED
(
aStatusCode
)
|
|
!
mObserver
)
{
nsCOMPtr
<
nsIAsyncOutputStream
>
outputStream
=
do_QueryInterface
(
mPipeOutputStream
)
;
if
(
outputStream
)
{
outputStream
-
>
CloseWithStatus
(
NS_FAILED
(
aStatusCode
)
?
aStatusCode
:
NS_BINDING_FAILED
)
;
}
if
(
altDataListener
)
{
altDataListener
-
>
Cancel
(
)
;
}
}
else
{
MOZ_ASSERT
(
mResponse
)
;
MOZ_ASSERT
(
!
mResponse
-
>
IsError
(
)
)
;
if
(
ShouldCheckSRI
(
mRequest
mResponse
)
)
{
MOZ_ASSERT
(
mSRIDataVerifier
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aRequest
)
;
nsIConsoleReportCollector
*
reporter
=
nullptr
;
if
(
mObserver
)
{
reporter
=
mObserver
-
>
GetReporter
(
)
;
}
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
else
if
(
!
mWorkerScript
.
IsEmpty
(
)
)
{
sourceUri
.
Assign
(
mWorkerScript
)
;
}
nsresult
rv
=
mSRIDataVerifier
-
>
Verify
(
mSRIMetadata
channel
sourceUri
reporter
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
altDataListener
)
{
altDataListener
-
>
Cancel
(
)
;
}
FailWithNetworkError
(
rv
)
;
return
rv
;
}
}
if
(
mPipeOutputStream
)
{
mPipeOutputStream
-
>
Close
(
)
;
}
}
return
FinishOnStopRequest
(
altDataListener
)
;
}
nsresult
FetchDriver
:
:
FinishOnStopRequest
(
AlternativeDataStreamListener
*
aAltDataListener
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mOnStopRequestCalled
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mAltDataListener
)
;
if
(
aAltDataListener
&
&
aAltDataListener
-
>
Status
(
)
=
=
AlternativeDataStreamListener
:
:
LOADING
)
{
return
NS_OK
;
}
if
(
mObserver
)
{
if
(
ShouldCheckSRI
(
mRequest
mResponse
)
)
{
MOZ_ASSERT
(
mResponse
)
;
mObserver
-
>
OnResponseAvailable
(
mResponse
)
;
#
ifdef
DEBUG
mResponseAvailableCalled
=
true
;
#
endif
}
mObserver
-
>
OnResponseEnd
(
FetchDriverObserver
:
:
eByNetworking
)
;
mObserver
=
nullptr
;
}
mChannel
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
aCallback
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aNewChannel
)
;
if
(
httpChannel
)
{
SetRequestHeaders
(
httpChannel
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
oldHttpChannel
=
do_QueryInterface
(
aOldChannel
)
;
nsAutoCString
tRPHeaderCValue
;
if
(
oldHttpChannel
)
{
Unused
<
<
oldHttpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
referrer
-
policy
"
)
tRPHeaderCValue
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
MOZ_ALWAYS_SUCCEEDS
(
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
)
;
nsCOMPtr
<
nsIURI
>
uriClone
;
nsresult
rv
=
NS_GetURIWithoutRef
(
uri
getter_AddRefs
(
uriClone
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
spec
;
rv
=
uriClone
-
>
GetSpec
(
spec
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCString
fragment
;
rv
=
uri
-
>
GetRef
(
fragment
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
(
aFlags
&
nsIChannelEventSink
:
:
REDIRECT_INTERNAL
)
)
{
mRequest
-
>
AddURL
(
spec
fragment
)
;
}
else
{
mRequest
-
>
SetURLForInternalRedirect
(
aFlags
spec
fragment
)
;
}
NS_ConvertUTF8toUTF16
tRPHeaderValue
(
tRPHeaderCValue
)
;
if
(
!
tRPHeaderValue
.
IsEmpty
(
)
)
{
net
:
:
ReferrerPolicy
net_referrerPolicy
=
nsContentUtils
:
:
GetReferrerPolicyFromHeader
(
tRPHeaderValue
)
;
if
(
net_referrerPolicy
!
=
net
:
:
RP_Unset
)
{
mRequest
-
>
SetReferrerPolicy
(
net_referrerPolicy
)
;
if
(
httpChannel
)
{
nsresult
rv
=
FetchUtil
:
:
SetRequestReferrer
(
mPrincipal
mDocument
httpChannel
mRequest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
aCallback
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
CheckListenerChain
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
FetchDriver
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
*
aResult
=
static_cast
<
nsIChannelEventSink
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIStreamListener
)
)
)
{
*
aResult
=
static_cast
<
nsIStreamListener
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIRequestObserver
)
)
)
{
*
aResult
=
static_cast
<
nsIRequestObserver
*
>
(
this
)
;
NS_ADDREF_THIS
(
)
;
return
NS_OK
;
}
return
QueryInterface
(
aIID
aResult
)
;
}
void
FetchDriver
:
:
SetDocument
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
!
mFetchCalled
)
;
mDocument
=
aDocument
;
}
void
FetchDriver
:
:
SetCSPEventListener
(
nsICSPEventListener
*
aCSPEventListener
)
{
MOZ_ASSERT
(
!
mFetchCalled
)
;
mCSPEventListener
=
aCSPEventListener
;
}
void
FetchDriver
:
:
SetClientInfo
(
const
ClientInfo
&
aClientInfo
)
{
MOZ_ASSERT
(
!
mFetchCalled
)
;
mClientInfo
.
emplace
(
aClientInfo
)
;
}
void
FetchDriver
:
:
SetController
(
const
Maybe
<
ServiceWorkerDescriptor
>
&
aController
)
{
MOZ_ASSERT
(
!
mFetchCalled
)
;
mController
=
aController
;
}
void
FetchDriver
:
:
SetRequestHeaders
(
nsIHttpChannel
*
aChannel
)
const
{
MOZ_ASSERT
(
aChannel
)
;
nsTArray
<
nsCString
>
headersSet
;
AutoTArray
<
InternalHeaders
:
:
Entry
5
>
headers
;
mRequest
-
>
Headers
(
)
-
>
GetEntries
(
headers
)
;
for
(
uint32_t
i
=
0
;
i
<
headers
.
Length
(
)
;
+
+
i
)
{
bool
alreadySet
=
headersSet
.
Contains
(
headers
[
i
]
.
mName
)
;
if
(
!
alreadySet
)
{
headersSet
.
AppendElement
(
headers
[
i
]
.
mName
)
;
}
if
(
headers
[
i
]
.
mValue
.
IsEmpty
(
)
)
{
DebugOnly
<
nsresult
>
rv
=
aChannel
-
>
SetEmptyRequestHeader
(
headers
[
i
]
.
mName
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
else
{
DebugOnly
<
nsresult
>
rv
=
aChannel
-
>
SetRequestHeader
(
headers
[
i
]
.
mName
headers
[
i
]
.
mValue
alreadySet
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
nsAutoCString
method
;
mRequest
-
>
GetMethod
(
method
)
;
if
(
!
method
.
EqualsLiteral
(
"
GET
"
)
&
&
!
method
.
EqualsLiteral
(
"
HEAD
"
)
)
{
nsAutoString
origin
;
if
(
NS_SUCCEEDED
(
nsContentUtils
:
:
GetUTFOrigin
(
mPrincipal
origin
)
)
)
{
DebugOnly
<
nsresult
>
rv
=
aChannel
-
>
SetRequestHeader
(
nsDependentCString
(
net
:
:
nsHttp
:
:
Origin
)
NS_ConvertUTF16toUTF8
(
origin
)
false
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
}
}
}
void
FetchDriver
:
:
Abort
(
)
{
if
(
mObserver
)
{
#
ifdef
DEBUG
mResponseAvailableCalled
=
true
;
#
endif
mObserver
-
>
OnResponseEnd
(
FetchDriverObserver
:
:
eAborted
)
;
mObserver
=
nullptr
;
}
if
(
mChannel
)
{
mChannel
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
mChannel
=
nullptr
;
}
}
}
}
