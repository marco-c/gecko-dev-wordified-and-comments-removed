#
ifndef
mozilla_dom_FetchStreamReader_h
#
define
mozilla_dom_FetchStreamReader_h
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
dom
/
FetchBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
namespace
mozilla
{
namespace
dom
{
class
WorkerHolder
;
class
FetchStreamReader
final
:
public
nsIOutputStreamCallback
public
PromiseNativeHandler
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
FetchStreamReader
nsIOutputStreamCallback
)
NS_DECL_NSIOUTPUTSTREAMCALLBACK
static
nsresult
Create
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
FetchStreamReader
*
*
aStreamReader
nsIInputStream
*
*
aInputStream
)
;
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
;
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
;
void
CloseAndRelease
(
JSContext
*
aCx
nsresult
aStatus
)
;
void
StartConsuming
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
JS
:
:
MutableHandle
<
JSObject
*
>
aReader
ErrorResult
&
aRv
)
;
private
:
explicit
FetchStreamReader
(
nsIGlobalObject
*
aGlobal
)
;
~
FetchStreamReader
(
)
;
nsresult
WriteBuffer
(
)
;
void
ReportErrorToConsole
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
nsCOMPtr
<
nsIEventTarget
>
mOwningEventTarget
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mPipeOut
;
UniquePtr
<
WorkerHolder
>
mWorkerHolder
;
JS
:
:
Heap
<
JSObject
*
>
mReader
;
UniquePtr
<
FetchReadableStreamReadDataArray
>
mBuffer
;
uint32_t
mBufferRemaining
;
uint32_t
mBufferOffset
;
bool
mStreamClosed
;
}
;
}
}
#
endif
