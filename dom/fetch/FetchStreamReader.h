#
ifndef
mozilla_dom_FetchStreamReader_h
#
define
mozilla_dom_FetchStreamReader_h
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
FetchBinding
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
nsIAsyncOutputStream
.
h
"
#
include
"
nsIGlobalObject
.
h
"
namespace
mozilla
:
:
dom
{
class
ReadableStream
;
class
ReadableStreamDefaultReader
;
class
StrongWorkerRef
;
class
FetchStreamReader
final
:
public
nsIOutputStreamCallback
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
FetchStreamReader
)
NS_DECL_NSIOUTPUTSTREAMCALLBACK
static
nsresult
Create
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
FetchStreamReader
*
*
aStreamReader
nsIInputStream
*
*
aInputStream
)
;
MOZ_CAN_RUN_SCRIPT
void
ChunkSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aChunk
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
CloseSteps
(
JSContext
*
aCx
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ErrorSteps
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aError
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
CloseAndRelease
(
JSContext
*
aCx
nsresult
aStatus
)
;
void
StartConsuming
(
JSContext
*
aCx
ReadableStream
*
aStream
ErrorResult
&
aRv
)
;
private
:
explicit
FetchStreamReader
(
nsIGlobalObject
*
aGlobal
)
;
~
FetchStreamReader
(
)
;
nsresult
MaybeGrabStrongWorkerRef
(
JSContext
*
aCx
)
;
nsresult
WriteBuffer
(
)
;
MOZ_CAN_RUN_SCRIPT
bool
Process
(
JSContext
*
aCx
)
;
void
ReportErrorToConsole
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobal
;
nsCOMPtr
<
nsIEventTarget
>
mOwningEventTarget
;
nsCOMPtr
<
nsIAsyncOutputStream
>
mPipeOut
;
RefPtr
<
StrongWorkerRef
>
mWorkerRef
;
RefPtr
<
StrongWorkerRef
>
mAsyncWaitWorkerRef
;
RefPtr
<
ReadableStreamDefaultReader
>
mReader
;
nsTArray
<
uint8_t
>
mBuffer
;
uint32_t
mBufferRemaining
=
0
;
uint32_t
mBufferOffset
=
0
;
bool
mHasOutstandingReadRequest
=
false
;
bool
mStreamClosed
=
false
;
}
;
}
#
endif
