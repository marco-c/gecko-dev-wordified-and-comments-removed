#
ifndef
_mozilla_dom_FetchService_h
#
define
_mozilla_dom_FetchService_h
#
include
"
nsIChannel
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsTHashMap
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
MozPromise
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
FetchDriver
.
h
"
#
include
"
mozilla
/
dom
/
FetchTypes
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceTimingTypes
.
h
"
#
include
"
mozilla
/
dom
/
SafeRefPtr
.
h
"
class
nsILoadGroup
;
class
nsIPrincipal
;
class
nsICookieJarSettings
;
class
PerformanceStorage
;
namespace
mozilla
:
:
dom
{
class
InternalRequest
;
class
InternalResponse
;
using
FetchServiceResponse
=
SafeRefPtr
<
InternalResponse
>
;
using
FetchServiceResponseAvailablePromise
=
MozPromise
<
FetchServiceResponse
CopyableErrorResult
true
>
;
using
FetchServiceResponseEndPromise
=
MozPromise
<
ResponseEndArgs
CopyableErrorResult
true
>
;
class
FetchServicePromises
final
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
FetchServicePromises
)
;
public
:
FetchServicePromises
(
)
;
RefPtr
<
FetchServiceResponseAvailablePromise
>
GetResponseAvailablePromise
(
)
;
RefPtr
<
FetchServiceResponseEndPromise
>
GetResponseEndPromise
(
)
;
void
ResolveResponseAvailablePromise
(
FetchServiceResponse
&
&
aResponse
const
char
*
aMethodName
)
;
void
RejectResponseAvailablePromise
(
const
CopyableErrorResult
&
&
aError
const
char
*
aMethodName
)
;
void
ResolveResponseEndPromise
(
ResponseEndArgs
&
&
aArgs
const
char
*
aMethodName
)
;
void
RejectResponseEndPromise
(
const
CopyableErrorResult
&
&
aError
const
char
*
aMethodName
)
;
private
:
~
FetchServicePromises
(
)
=
default
;
RefPtr
<
FetchServiceResponseAvailablePromise
:
:
Private
>
mAvailablePromise
;
RefPtr
<
FetchServiceResponseEndPromise
:
:
Private
>
mEndPromise
;
}
;
class
FetchService
final
:
public
nsIObserver
{
public
:
NS_DECL_ISUPPORTS
;
NS_DECL_NSIOBSERVER
;
static
already_AddRefed
<
FetchService
>
GetInstance
(
)
;
static
RefPtr
<
FetchServicePromises
>
NetworkErrorResponse
(
nsresult
aRv
)
;
FetchService
(
)
;
RefPtr
<
FetchServicePromises
>
Fetch
(
SafeRefPtr
<
InternalRequest
>
aRequest
nsIChannel
*
aChannel
=
nullptr
)
;
void
CancelFetch
(
RefPtr
<
FetchServicePromises
>
&
&
aPromises
)
;
private
:
class
FetchInstance
final
:
public
FetchDriverObserver
{
public
:
explicit
FetchInstance
(
SafeRefPtr
<
InternalRequest
>
aRequest
)
;
nsresult
Initialize
(
nsIChannel
*
aChannel
=
nullptr
)
;
RefPtr
<
FetchServicePromises
>
Fetch
(
)
;
void
Cancel
(
)
;
void
OnResponseEnd
(
FetchDriverObserver
:
:
EndReason
aReason
JS
:
:
Handle
<
JS
:
:
Value
>
aReasonDetails
)
override
;
void
OnResponseAvailableInternal
(
SafeRefPtr
<
InternalResponse
>
aResponse
)
override
;
bool
NeedOnDataAvailable
(
)
override
;
void
OnDataAvailable
(
)
override
;
void
FlushConsoleReport
(
)
override
;
private
:
~
FetchInstance
(
)
;
SafeRefPtr
<
InternalRequest
>
mRequest
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
nsCOMPtr
<
nsICookieJarSettings
>
mCookieJarSettings
;
RefPtr
<
PerformanceStorage
>
mPerformanceStorage
;
RefPtr
<
FetchDriver
>
mFetchDriver
;
SafeRefPtr
<
InternalResponse
>
mResponse
;
RefPtr
<
FetchServicePromises
>
mPromises
;
}
;
~
FetchService
(
)
;
nsresult
RegisterNetworkObserver
(
)
;
nsresult
UnregisterNetworkObserver
(
)
;
nsTHashMap
<
nsRefPtrHashKey
<
FetchServicePromises
>
RefPtr
<
FetchInstance
>
>
mFetchInstanceTable
;
bool
mObservingNetwork
{
false
}
;
bool
mOffline
{
false
}
;
}
;
}
#
endif
