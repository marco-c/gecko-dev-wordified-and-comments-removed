#
ifndef
mozilla_dom_Fetch_h
#
define
mozilla_dom_Fetch_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIInputStreamPump
.
h
"
#
include
"
nsIStreamLoader
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
class
nsIGlobalObject
;
class
nsIEventTarget
;
namespace
mozilla
{
namespace
dom
{
class
BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
;
class
BlobImpl
;
class
InternalRequest
;
class
OwningBlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
;
class
RequestOrUSVString
;
enum
class
CallerType
:
uint32_t
;
namespace
workers
{
class
WorkerPrivate
;
}
already_AddRefed
<
Promise
>
FetchRequest
(
nsIGlobalObject
*
aGlobal
const
RequestOrUSVString
&
aInput
const
RequestInit
&
aInit
CallerType
aCallerType
ErrorResult
&
aRv
)
;
nsresult
UpdateRequestReferrer
(
nsIGlobalObject
*
aGlobal
InternalRequest
*
aRequest
)
;
namespace
fetch
{
typedef
BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
BodyInit
;
typedef
OwningBlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
OwningBodyInit
;
}
;
nsresult
ExtractByteStreamFromBody
(
const
fetch
:
:
OwningBodyInit
&
aBodyInit
nsIInputStream
*
*
aStream
nsCString
&
aContentType
uint64_t
&
aContentLength
)
;
nsresult
ExtractByteStreamFromBody
(
const
fetch
:
:
BodyInit
&
aBodyInit
nsIInputStream
*
*
aStream
nsCString
&
aContentType
uint64_t
&
aContentLength
)
;
template
<
class
Derived
>
class
FetchBodyWrapper
;
template
<
class
Derived
>
class
FetchBody
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
bool
BodyUsed
(
)
const
{
return
mBodyUsed
;
}
already_AddRefed
<
Promise
>
ArrayBuffer
(
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
CONSUME_ARRAYBUFFER
aRv
)
;
}
already_AddRefed
<
Promise
>
Blob
(
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
CONSUME_BLOB
aRv
)
;
}
already_AddRefed
<
Promise
>
FormData
(
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
CONSUME_FORMDATA
aRv
)
;
}
already_AddRefed
<
Promise
>
Json
(
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
CONSUME_JSON
aRv
)
;
}
already_AddRefed
<
Promise
>
Text
(
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
CONSUME_TEXT
aRv
)
;
}
void
BeginConsumeBodyMainThread
(
FetchBodyWrapper
<
Derived
>
*
aWrapper
)
;
void
ContinueConsumeBody
(
FetchBodyWrapper
<
Derived
>
*
aWrapper
nsresult
aStatus
uint32_t
aLength
uint8_t
*
aResult
)
;
void
ContinueConsumeBlobBody
(
FetchBodyWrapper
<
Derived
>
*
aWrapper
BlobImpl
*
aBlobImpl
)
;
void
CancelPump
(
)
;
void
SetBodyUsed
(
)
{
mBodyUsed
=
true
;
}
workers
:
:
WorkerPrivate
*
mWorkerPrivate
;
protected
:
nsCOMPtr
<
nsIGlobalObject
>
mOwner
;
explicit
FetchBody
(
nsIGlobalObject
*
aOwner
)
;
virtual
~
FetchBody
(
)
;
void
SetMimeType
(
)
;
private
:
enum
ConsumeType
{
CONSUME_ARRAYBUFFER
CONSUME_BLOB
CONSUME_FORMDATA
CONSUME_JSON
CONSUME_TEXT
}
;
Derived
*
DerivedClass
(
)
const
{
return
static_cast
<
Derived
*
>
(
const_cast
<
FetchBody
*
>
(
this
)
)
;
}
nsresult
BeginConsumeBody
(
)
;
already_AddRefed
<
Promise
>
ConsumeBody
(
ConsumeType
aType
ErrorResult
&
aRv
)
;
bool
IsOnTargetThread
(
)
{
return
NS_IsMainThread
(
)
=
=
!
mWorkerPrivate
;
}
void
AssertIsOnTargetThread
(
)
{
MOZ_ASSERT
(
IsOnTargetThread
(
)
)
;
}
bool
mBodyUsed
;
nsCString
mMimeType
;
ConsumeType
mConsumeType
;
RefPtr
<
Promise
>
mConsumePromise
;
#
ifdef
DEBUG
bool
mReadDone
;
#
endif
nsMainThreadPtrHandle
<
nsIInputStreamPump
>
mConsumeBodyPump
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
}
;
}
}
#
endif
