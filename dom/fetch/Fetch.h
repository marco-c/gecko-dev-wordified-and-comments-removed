#
ifndef
mozilla_dom_Fetch_h
#
define
mozilla_dom_Fetch_h
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIStreamLoader
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
FetchStreamReader
.
h
"
#
include
"
mozilla
/
dom
/
RequestBinding
.
h
"
class
nsIGlobalObject
;
class
nsIEventTarget
;
namespace
mozilla
{
namespace
dom
{
class
BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
;
class
BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrReadableStreamOrUSVString
;
class
BlobImpl
;
class
InternalRequest
;
class
OwningBlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
;
struct
ReadableStream
;
class
RequestOrUSVString
;
enum
class
CallerType
:
uint32_t
;
namespace
workers
{
class
WorkerPrivate
;
}
already_AddRefed
<
Promise
>
FetchRequest
(
nsIGlobalObject
*
aGlobal
const
RequestOrUSVString
&
aInput
const
RequestInit
&
aInit
CallerType
aCallerType
ErrorResult
&
aRv
)
;
nsresult
UpdateRequestReferrer
(
nsIGlobalObject
*
aGlobal
InternalRequest
*
aRequest
)
;
namespace
fetch
{
typedef
BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
BodyInit
;
typedef
BlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrReadableStreamOrUSVString
ResponseBodyInit
;
typedef
OwningBlobOrArrayBufferViewOrArrayBufferOrFormDataOrURLSearchParamsOrUSVString
OwningBodyInit
;
}
;
nsresult
ExtractByteStreamFromBody
(
const
fetch
:
:
OwningBodyInit
&
aBodyInit
nsIInputStream
*
*
aStream
nsCString
&
aContentType
uint64_t
&
aContentLength
)
;
nsresult
ExtractByteStreamFromBody
(
const
fetch
:
:
BodyInit
&
aBodyInit
nsIInputStream
*
*
aStream
nsCString
&
aContentType
uint64_t
&
aContentLength
)
;
nsresult
ExtractByteStreamFromBody
(
const
fetch
:
:
ResponseBodyInit
&
aBodyInit
nsIInputStream
*
*
aStream
nsCString
&
aContentType
uint64_t
&
aContentLength
)
;
template
<
class
Derived
>
class
FetchBodyConsumer
;
enum
FetchConsumeType
{
CONSUME_ARRAYBUFFER
CONSUME_BLOB
CONSUME_FORMDATA
CONSUME_JSON
CONSUME_TEXT
}
;
class
FetchStreamHolder
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
void
NullifyStream
(
)
=
0
;
}
;
template
<
class
Derived
>
class
FetchBody
:
public
FetchStreamHolder
{
public
:
friend
class
FetchBodyConsumer
<
Derived
>
;
bool
BodyUsed
(
)
const
;
already_AddRefed
<
Promise
>
ArrayBuffer
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
aCx
CONSUME_ARRAYBUFFER
aRv
)
;
}
already_AddRefed
<
Promise
>
Blob
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
aCx
CONSUME_BLOB
aRv
)
;
}
already_AddRefed
<
Promise
>
FormData
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
aCx
CONSUME_FORMDATA
aRv
)
;
}
already_AddRefed
<
Promise
>
Json
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
aCx
CONSUME_JSON
aRv
)
;
}
already_AddRefed
<
Promise
>
Text
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
return
ConsumeBody
(
aCx
CONSUME_TEXT
aRv
)
;
}
void
GetBody
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aBodyOut
ErrorResult
&
aRv
)
;
void
MaybeTeeReadableStreamBody
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aBodyOut
FetchStreamReader
*
*
aStreamReader
nsIInputStream
*
*
aInputStream
ErrorResult
&
aRv
)
;
void
SetBodyUsed
(
)
{
mBodyUsed
=
true
;
}
const
nsCString
&
MimeType
(
)
const
{
return
mMimeType
;
}
void
NullifyStream
(
)
override
{
mReadableStreamBody
=
nullptr
;
mReadableStreamReader
=
nullptr
;
mFetchStreamReader
=
nullptr
;
}
protected
:
nsCOMPtr
<
nsIGlobalObject
>
mOwner
;
workers
:
:
WorkerPrivate
*
mWorkerPrivate
;
JS
:
:
Heap
<
JSObject
*
>
mReadableStreamBody
;
JS
:
:
Heap
<
JSObject
*
>
mReadableStreamReader
;
RefPtr
<
FetchStreamReader
>
mFetchStreamReader
;
explicit
FetchBody
(
nsIGlobalObject
*
aOwner
)
;
virtual
~
FetchBody
(
)
;
void
SetMimeType
(
)
;
void
SetReadableStreamBody
(
JSObject
*
aBody
)
;
private
:
Derived
*
DerivedClass
(
)
const
{
return
static_cast
<
Derived
*
>
(
const_cast
<
FetchBody
*
>
(
this
)
)
;
}
already_AddRefed
<
Promise
>
ConsumeBody
(
JSContext
*
aCx
FetchConsumeType
aType
ErrorResult
&
aRv
)
;
void
LockStream
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
ErrorResult
&
aRv
)
;
bool
IsOnTargetThread
(
)
{
return
NS_IsMainThread
(
)
=
=
!
mWorkerPrivate
;
}
void
AssertIsOnTargetThread
(
)
{
MOZ_ASSERT
(
IsOnTargetThread
(
)
)
;
}
bool
mBodyUsed
;
nsCString
mMimeType
;
nsCOMPtr
<
nsIEventTarget
>
mMainThreadEventTarget
;
}
;
}
}
#
endif
