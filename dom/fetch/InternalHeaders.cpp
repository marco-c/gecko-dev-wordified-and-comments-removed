#
include
"
mozilla
/
dom
/
InternalHeaders
.
h
"
#
include
"
FetchUtil
.
h
"
#
include
"
mozilla
/
dom
/
FetchTypes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpHeaderVisitor
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsReadableUtils
.
h
"
namespace
mozilla
:
:
dom
{
InternalHeaders
:
:
InternalHeaders
(
nsTArray
<
Entry
>
&
&
aHeaders
HeadersGuardEnum
aGuard
)
:
mGuard
(
aGuard
)
mList
(
std
:
:
move
(
aHeaders
)
)
mListDirty
(
true
)
{
}
InternalHeaders
:
:
InternalHeaders
(
const
nsTArray
<
HeadersEntry
>
&
aHeadersEntryList
HeadersGuardEnum
aGuard
)
:
mGuard
(
aGuard
)
mListDirty
(
true
)
{
for
(
const
HeadersEntry
&
headersEntry
:
aHeadersEntryList
)
{
mList
.
AppendElement
(
Entry
(
headersEntry
.
name
(
)
headersEntry
.
value
(
)
)
)
;
}
}
void
InternalHeaders
:
:
ToIPC
(
nsTArray
<
HeadersEntry
>
&
aIPCHeaders
HeadersGuardEnum
&
aGuard
)
{
aGuard
=
mGuard
;
aIPCHeaders
.
Clear
(
)
;
for
(
Entry
&
entry
:
mList
)
{
aIPCHeaders
.
AppendElement
(
HeadersEntry
(
entry
.
mName
entry
.
mValue
)
)
;
}
}
bool
InternalHeaders
:
:
IsValidHeaderValue
(
const
nsCString
&
aLowerName
const
nsCString
&
aNormalizedValue
ErrorResult
&
aRv
)
{
if
(
IsInvalidName
(
aLowerName
aRv
)
|
|
IsInvalidValue
(
aNormalizedValue
aRv
)
)
{
return
false
;
}
if
(
IsImmutable
(
aRv
)
)
{
return
false
;
}
if
(
mGuard
=
=
HeadersGuardEnum
:
:
Request
)
{
if
(
IsForbiddenRequestHeader
(
aLowerName
aNormalizedValue
)
)
{
return
false
;
}
}
if
(
mGuard
=
=
HeadersGuardEnum
:
:
Request_no_cors
)
{
nsAutoCString
tempValue
;
Get
(
aLowerName
tempValue
aRv
)
;
if
(
tempValue
.
IsVoid
(
)
)
{
tempValue
=
aNormalizedValue
;
}
else
{
tempValue
.
Append
(
"
"
)
;
tempValue
.
Append
(
aNormalizedValue
)
;
}
if
(
!
nsContentUtils
:
:
IsCORSSafelistedRequestHeader
(
aLowerName
tempValue
)
)
{
return
false
;
}
}
else
if
(
IsForbiddenResponseHeader
(
aLowerName
)
)
{
return
false
;
}
return
true
;
}
void
InternalHeaders
:
:
Append
(
const
nsACString
&
aName
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
nsAutoCString
trimValue
;
NS_TrimHTTPWhitespace
(
aValue
trimValue
)
;
nsAutoCString
lowerName
;
ToLowerCase
(
aName
lowerName
)
;
if
(
!
IsValidHeaderValue
(
lowerName
trimValue
aRv
)
)
{
return
;
}
nsAutoCString
name
(
aName
)
;
ReuseExistingNameIfExists
(
name
)
;
SetListDirty
(
)
;
mList
.
AppendElement
(
Entry
(
name
trimValue
)
)
;
if
(
mGuard
=
=
HeadersGuardEnum
:
:
Request_no_cors
)
{
RemovePrivilegedNoCorsRequestHeaders
(
)
;
}
}
void
InternalHeaders
:
:
RemovePrivilegedNoCorsRequestHeaders
(
)
{
bool
dirty
=
false
;
for
(
int32_t
i
=
mList
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
IsPrivilegedNoCorsRequestHeaderName
(
mList
[
i
]
.
mName
)
)
{
mList
.
RemoveElementAt
(
i
)
;
dirty
=
true
;
}
}
if
(
dirty
)
{
SetListDirty
(
)
;
}
}
bool
InternalHeaders
:
:
DeleteInternal
(
const
nsCString
&
aLowerName
ErrorResult
&
aRv
)
{
bool
dirty
=
false
;
for
(
int32_t
i
=
mList
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mList
[
i
]
.
mName
.
EqualsIgnoreCase
(
aLowerName
.
get
(
)
)
)
{
mList
.
RemoveElementAt
(
i
)
;
dirty
=
true
;
}
}
if
(
dirty
)
{
SetListDirty
(
)
;
}
return
dirty
;
}
void
InternalHeaders
:
:
Delete
(
const
nsACString
&
aName
ErrorResult
&
aRv
)
{
nsAutoCString
lowerName
;
ToLowerCase
(
aName
lowerName
)
;
if
(
IsInvalidName
(
lowerName
aRv
)
)
{
return
;
}
if
(
IsImmutable
(
aRv
)
)
{
return
;
}
nsAutoCString
value
;
GetInternal
(
lowerName
value
aRv
)
;
if
(
IsForbiddenRequestHeader
(
lowerName
value
)
)
{
return
;
}
if
(
mGuard
=
=
HeadersGuardEnum
:
:
Request_no_cors
&
&
!
IsNoCorsSafelistedRequestHeaderName
(
lowerName
)
&
&
!
IsPrivilegedNoCorsRequestHeaderName
(
lowerName
)
)
{
return
;
}
if
(
IsForbiddenResponseHeader
(
lowerName
)
)
{
return
;
}
if
(
!
DeleteInternal
(
lowerName
aRv
)
)
{
return
;
}
if
(
mGuard
=
=
HeadersGuardEnum
:
:
Request_no_cors
)
{
RemovePrivilegedNoCorsRequestHeaders
(
)
;
}
}
void
InternalHeaders
:
:
Get
(
const
nsACString
&
aName
nsACString
&
aValue
ErrorResult
&
aRv
)
const
{
nsAutoCString
lowerName
;
ToLowerCase
(
aName
lowerName
)
;
if
(
IsInvalidName
(
lowerName
aRv
)
)
{
return
;
}
GetInternal
(
lowerName
aValue
aRv
)
;
}
void
InternalHeaders
:
:
GetInternal
(
const
nsCString
&
aLowerName
nsACString
&
aValue
ErrorResult
&
aRv
)
const
{
const
char
*
delimiter
=
"
"
;
bool
firstValueFound
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mList
.
Length
(
)
;
+
+
i
)
{
if
(
mList
[
i
]
.
mName
.
EqualsIgnoreCase
(
aLowerName
.
get
(
)
)
)
{
if
(
firstValueFound
)
{
aValue
+
=
delimiter
;
}
aValue
+
=
mList
[
i
]
.
mValue
;
firstValueFound
=
true
;
}
}
if
(
!
firstValueFound
)
{
aValue
.
SetIsVoid
(
true
)
;
}
}
void
InternalHeaders
:
:
GetFirst
(
const
nsACString
&
aName
nsACString
&
aValue
ErrorResult
&
aRv
)
const
{
nsAutoCString
lowerName
;
ToLowerCase
(
aName
lowerName
)
;
if
(
IsInvalidName
(
lowerName
aRv
)
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
mList
.
Length
(
)
;
+
+
i
)
{
if
(
mList
[
i
]
.
mName
.
EqualsIgnoreCase
(
lowerName
.
get
(
)
)
)
{
aValue
=
mList
[
i
]
.
mValue
;
return
;
}
}
aValue
.
SetIsVoid
(
true
)
;
}
bool
InternalHeaders
:
:
Has
(
const
nsACString
&
aName
ErrorResult
&
aRv
)
const
{
nsAutoCString
lowerName
;
ToLowerCase
(
aName
lowerName
)
;
if
(
IsInvalidName
(
lowerName
aRv
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
mList
.
Length
(
)
;
+
+
i
)
{
if
(
mList
[
i
]
.
mName
.
EqualsIgnoreCase
(
lowerName
.
get
(
)
)
)
{
return
true
;
}
}
return
false
;
}
void
InternalHeaders
:
:
Set
(
const
nsACString
&
aName
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
nsAutoCString
trimValue
;
NS_TrimHTTPWhitespace
(
aValue
trimValue
)
;
nsAutoCString
lowerName
;
ToLowerCase
(
aName
lowerName
)
;
if
(
!
IsValidHeaderValue
(
lowerName
trimValue
aRv
)
)
{
return
;
}
SetListDirty
(
)
;
int32_t
firstIndex
=
INT32_MAX
;
for
(
int32_t
i
=
mList
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
if
(
mList
[
i
]
.
mName
.
EqualsIgnoreCase
(
lowerName
.
get
(
)
)
)
{
firstIndex
=
std
:
:
min
(
firstIndex
i
)
;
mList
.
RemoveElementAt
(
i
)
;
}
}
if
(
firstIndex
<
INT32_MAX
)
{
Entry
*
entry
=
mList
.
InsertElementAt
(
firstIndex
)
;
entry
-
>
mName
=
aName
;
entry
-
>
mValue
=
trimValue
;
}
else
{
mList
.
AppendElement
(
Entry
(
aName
trimValue
)
)
;
}
if
(
mGuard
=
=
HeadersGuardEnum
:
:
Request_no_cors
)
{
RemovePrivilegedNoCorsRequestHeaders
(
)
;
}
}
void
InternalHeaders
:
:
Clear
(
)
{
SetListDirty
(
)
;
mList
.
Clear
(
)
;
}
void
InternalHeaders
:
:
SetGuard
(
HeadersGuardEnum
aGuard
ErrorResult
&
aRv
)
{
mGuard
=
aGuard
;
}
InternalHeaders
:
:
~
InternalHeaders
(
)
=
default
;
bool
InternalHeaders
:
:
IsNoCorsSafelistedRequestHeaderName
(
const
nsCString
&
aName
)
{
return
aName
.
EqualsIgnoreCase
(
"
accept
"
)
|
|
aName
.
EqualsIgnoreCase
(
"
accept
-
language
"
)
|
|
aName
.
EqualsIgnoreCase
(
"
content
-
language
"
)
|
|
aName
.
EqualsIgnoreCase
(
"
content
-
type
"
)
;
}
bool
InternalHeaders
:
:
IsPrivilegedNoCorsRequestHeaderName
(
const
nsCString
&
aName
)
{
return
aName
.
EqualsIgnoreCase
(
"
range
"
)
;
}
bool
InternalHeaders
:
:
IsSimpleHeader
(
const
nsCString
&
aName
const
nsACString
&
aValue
)
{
if
(
aValue
.
Length
(
)
>
128
)
{
return
false
;
}
return
(
aName
.
EqualsIgnoreCase
(
"
accept
"
)
&
&
nsContentUtils
:
:
IsAllowedNonCorsAccept
(
aValue
)
)
|
|
(
aName
.
EqualsIgnoreCase
(
"
accept
-
language
"
)
&
&
nsContentUtils
:
:
IsAllowedNonCorsLanguage
(
aValue
)
)
|
|
(
aName
.
EqualsIgnoreCase
(
"
content
-
language
"
)
&
&
nsContentUtils
:
:
IsAllowedNonCorsLanguage
(
aValue
)
)
|
|
(
aName
.
EqualsIgnoreCase
(
"
content
-
type
"
)
&
&
nsContentUtils
:
:
IsAllowedNonCorsContentType
(
aValue
)
)
;
}
bool
InternalHeaders
:
:
IsRevalidationHeader
(
const
nsCString
&
aName
)
{
return
aName
.
EqualsIgnoreCase
(
"
if
-
modified
-
since
"
)
|
|
aName
.
EqualsIgnoreCase
(
"
if
-
none
-
match
"
)
|
|
aName
.
EqualsIgnoreCase
(
"
if
-
unmodified
-
since
"
)
|
|
aName
.
EqualsIgnoreCase
(
"
if
-
match
"
)
|
|
aName
.
EqualsIgnoreCase
(
"
if
-
range
"
)
;
}
bool
InternalHeaders
:
:
IsInvalidName
(
const
nsACString
&
aName
ErrorResult
&
aRv
)
{
if
(
!
NS_IsValidHTTPToken
(
aName
)
)
{
aRv
.
ThrowTypeError
<
MSG_INVALID_HEADER_NAME
>
(
aName
)
;
return
true
;
}
return
false
;
}
bool
InternalHeaders
:
:
IsInvalidValue
(
const
nsACString
&
aValue
ErrorResult
&
aRv
)
{
if
(
!
NS_IsReasonableHTTPHeaderValue
(
aValue
)
)
{
aRv
.
ThrowTypeError
<
MSG_INVALID_HEADER_VALUE
>
(
aValue
)
;
return
true
;
}
return
false
;
}
bool
InternalHeaders
:
:
IsImmutable
(
ErrorResult
&
aRv
)
const
{
if
(
mGuard
=
=
HeadersGuardEnum
:
:
Immutable
)
{
aRv
.
ThrowTypeError
(
"
Headers
are
immutable
and
cannot
be
modified
.
"
)
;
return
true
;
}
return
false
;
}
bool
InternalHeaders
:
:
IsForbiddenRequestHeader
(
const
nsCString
&
aName
const
nsACString
&
aValue
)
const
{
return
mGuard
=
=
HeadersGuardEnum
:
:
Request
&
&
nsContentUtils
:
:
IsForbiddenRequestHeader
(
aName
aValue
)
;
}
bool
InternalHeaders
:
:
IsForbiddenRequestNoCorsHeader
(
const
nsCString
&
aName
)
const
{
return
mGuard
=
=
HeadersGuardEnum
:
:
Request_no_cors
&
&
!
IsSimpleHeader
(
aName
"
"
_ns
)
;
}
bool
InternalHeaders
:
:
IsForbiddenRequestNoCorsHeader
(
const
nsCString
&
aName
const
nsACString
&
aValue
)
const
{
return
mGuard
=
=
HeadersGuardEnum
:
:
Request_no_cors
&
&
!
IsSimpleHeader
(
aName
aValue
)
;
}
bool
InternalHeaders
:
:
IsForbiddenResponseHeader
(
const
nsCString
&
aName
)
const
{
return
mGuard
=
=
HeadersGuardEnum
:
:
Response
&
&
nsContentUtils
:
:
IsForbiddenResponseHeader
(
aName
)
;
}
void
InternalHeaders
:
:
Fill
(
const
InternalHeaders
&
aInit
ErrorResult
&
aRv
)
{
const
nsTArray
<
Entry
>
&
list
=
aInit
.
mList
;
for
(
uint32_t
i
=
0
;
i
<
list
.
Length
(
)
&
&
!
aRv
.
Failed
(
)
;
+
+
i
)
{
const
Entry
&
entry
=
list
[
i
]
;
Append
(
entry
.
mName
entry
.
mValue
aRv
)
;
}
}
void
InternalHeaders
:
:
Fill
(
const
Sequence
<
Sequence
<
nsCString
>
>
&
aInit
ErrorResult
&
aRv
)
{
for
(
uint32_t
i
=
0
;
i
<
aInit
.
Length
(
)
&
&
!
aRv
.
Failed
(
)
;
+
+
i
)
{
const
Sequence
<
nsCString
>
&
tuple
=
aInit
[
i
]
;
if
(
tuple
.
Length
(
)
!
=
2
)
{
aRv
.
ThrowTypeError
(
"
Headers
require
name
/
value
tuples
when
being
initialized
by
a
"
"
sequence
.
"
)
;
return
;
}
Append
(
tuple
[
0
]
tuple
[
1
]
aRv
)
;
}
}
void
InternalHeaders
:
:
Fill
(
const
Record
<
nsCString
nsCString
>
&
aInit
ErrorResult
&
aRv
)
{
for
(
auto
&
entry
:
aInit
.
Entries
(
)
)
{
Append
(
entry
.
mKey
entry
.
mValue
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
}
namespace
{
class
FillOriginalResponseHeaders
final
:
public
nsIHttpHeaderVisitor
{
RefPtr
<
InternalHeaders
>
mInternalHeaders
;
~
FillOriginalResponseHeaders
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
FillOriginalResponseHeaders
(
InternalHeaders
*
aInternalHeaders
)
:
mInternalHeaders
(
aInternalHeaders
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mInternalHeaders
)
;
}
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
mInternalHeaders
-
>
Append
(
aHeader
aValue
IgnoreErrors
(
)
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
FillOriginalResponseHeaders
nsIHttpHeaderVisitor
)
class
FillMissingResponseHeaders
final
:
public
nsIHttpHeaderVisitor
{
RefPtr
<
InternalHeaders
>
mInternalHeaders
;
~
FillMissingResponseHeaders
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
explicit
FillMissingResponseHeaders
(
InternalHeaders
*
aInternalHeaders
)
:
mInternalHeaders
(
aInternalHeaders
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mInternalHeaders
)
;
}
NS_IMETHOD
VisitHeader
(
const
nsACString
&
aHeader
const
nsACString
&
aValue
)
override
{
ErrorResult
rv
;
if
(
!
mInternalHeaders
-
>
Has
(
aHeader
rv
)
)
{
MOZ_ASSERT
(
!
rv
.
Failed
(
)
)
;
mInternalHeaders
-
>
Append
(
aHeader
aValue
IgnoreErrors
(
)
)
;
}
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
FillMissingResponseHeaders
nsIHttpHeaderVisitor
)
}
void
InternalHeaders
:
:
FillResponseHeaders
(
nsIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aRequest
)
;
if
(
!
httpChannel
)
{
return
;
}
RefPtr
<
FillOriginalResponseHeaders
>
visitor
=
new
FillOriginalResponseHeaders
(
this
)
;
nsresult
rv
=
httpChannel
-
>
VisitOriginalResponseHeaders
(
visitor
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
fill
headers
"
)
;
}
RefPtr
<
FillMissingResponseHeaders
>
visitMissingHeaders
=
new
FillMissingResponseHeaders
(
this
)
;
rv
=
httpChannel
-
>
VisitResponseHeaders
(
visitMissingHeaders
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
fill
headers
"
)
;
}
}
bool
InternalHeaders
:
:
HasOnlySimpleHeaders
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mList
.
Length
(
)
;
+
+
i
)
{
if
(
!
IsSimpleHeader
(
mList
[
i
]
.
mName
mList
[
i
]
.
mValue
)
)
{
return
false
;
}
}
return
true
;
}
bool
InternalHeaders
:
:
HasRevalidationHeaders
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mList
.
Length
(
)
;
+
+
i
)
{
if
(
IsRevalidationHeader
(
mList
[
i
]
.
mName
)
)
{
return
true
;
}
}
return
false
;
}
already_AddRefed
<
InternalHeaders
>
InternalHeaders
:
:
BasicHeaders
(
InternalHeaders
*
aHeaders
)
{
RefPtr
<
InternalHeaders
>
basic
=
new
InternalHeaders
(
*
aHeaders
)
;
ErrorResult
result
;
basic
-
>
Delete
(
"
Set
-
Cookie
"
_ns
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
basic
-
>
Delete
(
"
Set
-
Cookie2
"
_ns
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
return
basic
.
forget
(
)
;
}
already_AddRefed
<
InternalHeaders
>
InternalHeaders
:
:
CORSHeaders
(
InternalHeaders
*
aHeaders
RequestCredentials
aCredentialsMode
)
{
RefPtr
<
InternalHeaders
>
cors
=
new
InternalHeaders
(
aHeaders
-
>
mGuard
)
;
ErrorResult
result
;
nsAutoCString
acExposedNames
;
aHeaders
-
>
Get
(
"
Access
-
Control
-
Expose
-
Headers
"
_ns
acExposedNames
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
bool
allowAllHeaders
=
false
;
AutoTArray
<
nsCString
5
>
exposeNamesArray
;
for
(
const
nsACString
&
token
:
nsCCharSeparatedTokenizer
(
acExposedNames
'
'
)
.
ToRange
(
)
)
{
if
(
token
.
IsEmpty
(
)
)
{
continue
;
}
if
(
!
NS_IsValidHTTPToken
(
token
)
)
{
NS_WARNING
(
"
Got
invalid
HTTP
token
in
Access
-
Control
-
Expose
-
Headers
.
Header
"
"
value
is
:
"
)
;
NS_WARNING
(
acExposedNames
.
get
(
)
)
;
exposeNamesArray
.
Clear
(
)
;
break
;
}
if
(
token
.
EqualsLiteral
(
"
*
"
)
&
&
aCredentialsMode
!
=
RequestCredentials
:
:
Include
)
{
allowAllHeaders
=
true
;
}
exposeNamesArray
.
AppendElement
(
token
)
;
}
nsCaseInsensitiveCStringArrayComparator
comp
;
for
(
uint32_t
i
=
0
;
i
<
aHeaders
-
>
mList
.
Length
(
)
;
+
+
i
)
{
const
Entry
&
entry
=
aHeaders
-
>
mList
[
i
]
;
if
(
allowAllHeaders
)
{
cors
-
>
Append
(
entry
.
mName
entry
.
mValue
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
}
else
if
(
entry
.
mName
.
EqualsIgnoreCase
(
"
cache
-
control
"
)
|
|
entry
.
mName
.
EqualsIgnoreCase
(
"
content
-
language
"
)
|
|
entry
.
mName
.
EqualsIgnoreCase
(
"
content
-
type
"
)
|
|
entry
.
mName
.
EqualsIgnoreCase
(
"
content
-
length
"
)
|
|
entry
.
mName
.
EqualsIgnoreCase
(
"
expires
"
)
|
|
entry
.
mName
.
EqualsIgnoreCase
(
"
last
-
modified
"
)
|
|
entry
.
mName
.
EqualsIgnoreCase
(
"
pragma
"
)
|
|
exposeNamesArray
.
Contains
(
entry
.
mName
comp
)
)
{
cors
-
>
Append
(
entry
.
mName
entry
.
mValue
result
)
;
MOZ_ASSERT
(
!
result
.
Failed
(
)
)
;
}
}
return
cors
.
forget
(
)
;
}
void
InternalHeaders
:
:
GetEntries
(
nsTArray
<
InternalHeaders
:
:
Entry
>
&
aEntries
)
const
{
MOZ_ASSERT
(
aEntries
.
IsEmpty
(
)
)
;
aEntries
.
AppendElements
(
mList
)
;
}
void
InternalHeaders
:
:
GetUnsafeHeaders
(
nsTArray
<
nsCString
>
&
aNames
)
const
{
MOZ_ASSERT
(
aNames
.
IsEmpty
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mList
.
Length
(
)
;
+
+
i
)
{
const
Entry
&
header
=
mList
[
i
]
;
if
(
!
InternalHeaders
:
:
IsSimpleHeader
(
header
.
mName
header
.
mValue
)
)
{
aNames
.
AppendElement
(
header
.
mName
)
;
}
}
}
void
InternalHeaders
:
:
MaybeSortList
(
)
{
class
Comparator
{
public
:
bool
Equals
(
const
Entry
&
aA
const
Entry
&
aB
)
const
{
return
aA
.
mName
=
=
aB
.
mName
;
}
bool
LessThan
(
const
Entry
&
aA
const
Entry
&
aB
)
const
{
return
aA
.
mName
<
aB
.
mName
;
}
}
;
if
(
!
mListDirty
)
{
return
;
}
mListDirty
=
false
;
Comparator
comparator
;
mSortedList
.
Clear
(
)
;
for
(
const
Entry
&
entry
:
mList
)
{
bool
found
=
false
;
for
(
Entry
&
sortedEntry
:
mSortedList
)
{
if
(
sortedEntry
.
mName
.
EqualsIgnoreCase
(
entry
.
mName
.
get
(
)
)
)
{
sortedEntry
.
mValue
+
=
"
"
;
sortedEntry
.
mValue
+
=
entry
.
mValue
;
found
=
true
;
break
;
}
}
if
(
!
found
)
{
Entry
newEntry
=
entry
;
ToLowerCase
(
newEntry
.
mName
)
;
mSortedList
.
InsertElementSorted
(
newEntry
comparator
)
;
}
}
}
void
InternalHeaders
:
:
SetListDirty
(
)
{
mSortedList
.
Clear
(
)
;
mListDirty
=
true
;
}
void
InternalHeaders
:
:
ReuseExistingNameIfExists
(
nsCString
&
aName
)
const
{
for
(
const
Entry
&
entry
:
mList
)
{
if
(
entry
.
mName
.
EqualsIgnoreCase
(
aName
.
get
(
)
)
)
{
aName
=
entry
.
mName
;
break
;
}
}
}
}
