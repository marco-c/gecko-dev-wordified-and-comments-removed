#
include
"
FetchObserver
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION_CLASS
(
FetchObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
FetchObserver
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
FetchObserver
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
FetchObserver
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
FetchObserver
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
FetchObserver
DOMEventTargetHelper
)
bool
FetchObserver
:
:
IsEnabled
(
JSContext
*
aCx
JSObject
*
aGlobal
)
{
if
(
NS_IsMainThread
(
)
)
{
return
Preferences
:
:
GetBool
(
"
dom
.
fetchObserver
.
enabled
"
false
)
;
}
using
namespace
workers
;
WorkerPrivate
*
workerPrivate
=
GetWorkerPrivateFromContext
(
aCx
)
;
if
(
!
workerPrivate
)
{
return
false
;
}
return
workerPrivate
-
>
FetchObserverEnabled
(
)
;
}
FetchObserver
:
:
FetchObserver
(
nsIGlobalObject
*
aGlobal
FetchSignal
*
aSignal
)
:
DOMEventTargetHelper
(
aGlobal
)
mState
(
FetchState
:
:
Requesting
)
{
if
(
aSignal
)
{
Follow
(
aSignal
)
;
}
}
JSObject
*
FetchObserver
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
FetchObserverBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
FetchState
FetchObserver
:
:
State
(
)
const
{
return
mState
;
}
void
FetchObserver
:
:
Aborted
(
)
{
SetState
(
FetchState
:
:
Aborted
)
;
}
void
FetchObserver
:
:
SetState
(
FetchState
aState
)
{
MOZ_ASSERT
(
mState
<
aState
)
;
if
(
mState
=
=
FetchState
:
:
Aborted
|
|
mState
=
=
FetchState
:
:
Errored
|
|
mState
=
=
FetchState
:
:
Complete
)
{
return
;
}
if
(
mState
=
=
FetchState
:
:
Requesting
&
&
aState
=
=
FetchState
:
:
Complete
)
{
SetState
(
FetchState
:
:
Responding
)
;
}
mState
=
aState
;
if
(
mState
=
=
FetchState
:
:
Aborted
|
|
mState
=
=
FetchState
:
:
Errored
|
|
mState
=
=
FetchState
:
:
Complete
)
{
Unfollow
(
)
;
}
EventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
RefPtr
<
Event
>
event
=
Event
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
statechange
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
dummy
;
DispatchEvent
(
event
&
dummy
)
;
}
}
}
