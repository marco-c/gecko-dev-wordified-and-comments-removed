#
include
"
FetchStream
.
h
"
#
include
"
nsITransport
.
h
"
#
include
"
nsIStreamTransportService
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
define
FETCH_STREAM_FLAG
0
static
NS_DEFINE_CID
(
kStreamTransportServiceCID
NS_STREAMTRANSPORTSERVICE_CID
)
;
namespace
mozilla
{
namespace
dom
{
NS_IMPL_ISUPPORTS
(
FetchStream
nsIInputStreamCallback
)
JSObject
*
FetchStream
:
:
Create
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
nsIInputStream
*
aInputStream
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aCx
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
RefPtr
<
FetchStream
>
stream
=
new
FetchStream
(
aGlobal
aInputStream
)
;
if
(
!
JS
:
:
HasReadableStreamCallbacks
(
aCx
)
)
{
JS
:
:
SetReadableStreamCallbacks
(
aCx
&
FetchStream
:
:
RequestDataCallback
&
FetchStream
:
:
WriteIntoReadRequestCallback
&
FetchStream
:
:
CancelCallback
&
FetchStream
:
:
ClosedCallback
&
FetchStream
:
:
ErroredCallback
&
FetchStream
:
:
FinalizeCallback
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
body
(
aCx
JS
:
:
NewReadableExternalSourceStreamObject
(
aCx
stream
FETCH_STREAM_FLAG
)
)
;
if
(
!
body
)
{
aRv
.
StealExceptionFromJSContext
(
aCx
)
;
return
nullptr
;
}
stream
-
>
mReadableStream
=
body
;
NS_ADDREF
(
stream
.
get
(
)
)
;
return
body
;
}
void
FetchStream
:
:
RequestDataCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
void
*
aUnderlyingSource
uint8_t
aFlags
size_t
aDesiredSize
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFlags
=
=
FETCH_STREAM_FLAG
)
;
MOZ_DIAGNOSTIC_ASSERT
(
JS
:
:
ReadableStreamIsDisturbed
(
aStream
)
)
;
RefPtr
<
FetchStream
>
stream
=
static_cast
<
FetchStream
*
>
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
mState
=
=
eWaiting
|
|
stream
-
>
mState
=
=
eChecking
)
;
if
(
stream
-
>
mState
=
=
eChecking
)
{
MOZ_ASSERT
(
stream
-
>
mInputStream
)
;
stream
-
>
mState
=
eReading
;
return
;
}
stream
-
>
mState
=
eReading
;
if
(
!
stream
-
>
mInputStream
)
{
MOZ_ASSERT
(
stream
-
>
mOriginalInputStream
)
;
bool
nonBlocking
=
false
;
nsresult
rv
=
stream
-
>
mOriginalInputStream
-
>
IsNonBlocking
(
&
nonBlocking
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
stream
-
>
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
nsCOMPtr
<
nsIAsyncInputStream
>
asyncStream
=
do_QueryInterface
(
stream
-
>
mOriginalInputStream
)
;
if
(
!
nonBlocking
|
|
!
asyncStream
)
{
nsCOMPtr
<
nsIStreamTransportService
>
sts
=
do_GetService
(
kStreamTransportServiceCID
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
stream
-
>
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
nsCOMPtr
<
nsITransport
>
transport
;
rv
=
sts
-
>
CreateInputTransport
(
stream
-
>
mOriginalInputStream
0
-
1
true
getter_AddRefs
(
transport
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
stream
-
>
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
nsCOMPtr
<
nsIInputStream
>
wrapper
;
rv
=
transport
-
>
OpenInputStream
(
0
0
0
getter_AddRefs
(
wrapper
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
stream
-
>
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
asyncStream
=
do_QueryInterface
(
wrapper
)
;
}
stream
-
>
mInputStream
=
asyncStream
;
stream
-
>
mOriginalInputStream
=
nullptr
;
}
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
stream
-
>
mOriginalInputStream
)
;
nsresult
rv
=
stream
-
>
mInputStream
-
>
AsyncWait
(
stream
0
0
stream
-
>
mGlobal
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
stream
-
>
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
}
void
FetchStream
:
:
WriteIntoReadRequestCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
void
*
aUnderlyingSource
uint8_t
aFlags
void
*
aBuffer
size_t
aLength
size_t
*
aByteWritten
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFlags
=
=
FETCH_STREAM_FLAG
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aBuffer
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aByteWritten
)
;
RefPtr
<
FetchStream
>
stream
=
static_cast
<
FetchStream
*
>
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
stream
-
>
mState
=
=
eWriting
)
;
stream
-
>
mState
=
eChecking
;
uint32_t
written
;
nsresult
rv
=
stream
-
>
mInputStream
-
>
Read
(
static_cast
<
char
*
>
(
aBuffer
)
aLength
&
written
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
stream
-
>
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
*
aByteWritten
=
written
;
if
(
written
=
=
0
)
{
stream
-
>
mState
=
eClosed
;
JS
:
:
ReadableStreamClose
(
aCx
aStream
)
;
return
;
}
rv
=
stream
-
>
mInputStream
-
>
AsyncWait
(
stream
0
0
stream
-
>
mGlobal
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
stream
-
>
ErrorPropagation
(
aCx
aStream
rv
)
;
return
;
}
}
JS
:
:
Value
FetchStream
:
:
CancelCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
void
*
aUnderlyingSource
uint8_t
aFlags
JS
:
:
HandleValue
aReason
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFlags
=
=
FETCH_STREAM_FLAG
)
;
RefPtr
<
FetchStream
>
stream
=
static_cast
<
FetchStream
*
>
(
aUnderlyingSource
)
;
if
(
stream
-
>
mInputStream
)
{
stream
-
>
mInputStream
-
>
CloseWithStatus
(
NS_BASE_STREAM_CLOSED
)
;
}
stream
-
>
mState
=
eClosed
;
return
JS
:
:
UndefinedValue
(
)
;
}
void
FetchStream
:
:
ClosedCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
void
*
aUnderlyingSource
uint8_t
aFlags
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFlags
=
=
FETCH_STREAM_FLAG
)
;
}
void
FetchStream
:
:
ErroredCallback
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
void
*
aUnderlyingSource
uint8_t
aFlags
JS
:
:
HandleValue
aReason
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFlags
=
=
FETCH_STREAM_FLAG
)
;
}
void
FetchStream
:
:
FinalizeCallback
(
void
*
aUnderlyingSource
uint8_t
aFlags
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aUnderlyingSource
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aFlags
=
=
FETCH_STREAM_FLAG
)
;
RefPtr
<
FetchStream
>
stream
=
dont_AddRef
(
static_cast
<
FetchStream
*
>
(
aUnderlyingSource
)
)
;
stream
-
>
mState
=
eClosed
;
stream
-
>
mReadableStream
=
nullptr
;
}
FetchStream
:
:
FetchStream
(
nsIGlobalObject
*
aGlobal
nsIInputStream
*
aInputStream
)
:
mState
(
eWaiting
)
mGlobal
(
aGlobal
)
mOriginalInputStream
(
aInputStream
)
mOwningEventTarget
(
mGlobal
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
mReadableStream
(
nullptr
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aInputStream
)
;
}
FetchStream
:
:
~
FetchStream
(
)
{
NS_ProxyRelease
(
"
FetchStream
:
:
mGlobal
"
mOwningEventTarget
mGlobal
.
forget
(
)
)
;
}
void
FetchStream
:
:
ErrorPropagation
(
JSContext
*
aCx
JS
:
:
HandleObject
aStream
nsresult
aError
)
{
if
(
mState
=
=
eClosed
)
{
return
;
}
mState
=
eClosed
;
if
(
aError
=
=
NS_BASE_STREAM_CLOSED
)
{
JS
:
:
ReadableStreamClose
(
aCx
aStream
)
;
return
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mGlobal
)
;
RefPtr
<
DOMError
>
error
=
new
DOMError
(
window
NS_ERROR_DOM_TYPE_ERR
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
errorValue
(
aCx
)
;
if
(
ToJSValue
(
aCx
error
&
errorValue
)
)
{
JS
:
:
ReadableStreamError
(
aCx
aStream
errorValue
)
;
}
}
NS_IMETHODIMP
FetchStream
:
:
OnInputStreamReady
(
nsIAsyncInputStream
*
aStream
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aStream
)
;
if
(
mState
=
=
eClosed
)
{
return
NS_OK
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mInputStream
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eReading
|
|
mState
=
=
eChecking
)
;
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
mGlobal
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
stream
(
cx
mReadableStream
)
;
uint64_t
size
=
0
;
nsresult
rv
=
mInputStream
-
>
Available
(
&
size
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
size
=
=
0
)
{
rv
=
NS_BASE_STREAM_CLOSED
;
}
if
(
rv
=
=
NS_BASE_STREAM_CLOSED
|
|
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
ErrorPropagation
(
cx
stream
rv
)
;
return
NS_OK
;
}
if
(
mState
=
=
eChecking
)
{
mState
=
eWaiting
;
return
NS_OK
;
}
mState
=
eWriting
;
JS
:
:
ReadableStreamUpdateDataAvailableFromSource
(
cx
stream
size
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mState
=
=
eChecking
)
;
return
NS_OK
;
}
}
}
