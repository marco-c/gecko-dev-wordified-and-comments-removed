#
include
"
InternalRequest
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
workers
/
Workers
.
h
"
#
include
"
WorkerPrivate
.
h
"
namespace
mozilla
{
namespace
dom
{
already_AddRefed
<
InternalRequest
>
InternalRequest
:
:
GetRequestConstructorCopy
(
nsIGlobalObject
*
aGlobal
ErrorResult
&
aRv
)
const
{
nsRefPtr
<
InternalRequest
>
copy
=
new
InternalRequest
(
)
;
copy
-
>
mURL
.
Assign
(
mURL
)
;
copy
-
>
SetMethod
(
mMethod
)
;
copy
-
>
mHeaders
=
new
InternalHeaders
(
*
mHeaders
)
;
copy
-
>
SetUnsafeRequest
(
)
;
copy
-
>
mBodyStream
=
mBodyStream
;
copy
-
>
mForceOriginHeader
=
true
;
copy
-
>
mSameOriginDataURL
=
true
;
copy
-
>
mPreserveContentCodings
=
true
;
copy
-
>
mContentPolicyType
=
nsIContentPolicy
:
:
TYPE_FETCH
;
copy
-
>
mMode
=
mMode
;
copy
-
>
mCredentialsMode
=
mCredentialsMode
;
copy
-
>
mCacheMode
=
mCacheMode
;
copy
-
>
mRedirectMode
=
mRedirectMode
;
copy
-
>
mCreatedByFetchEvent
=
mCreatedByFetchEvent
;
return
copy
.
forget
(
)
;
}
already_AddRefed
<
InternalRequest
>
InternalRequest
:
:
Clone
(
)
{
nsRefPtr
<
InternalRequest
>
clone
=
new
InternalRequest
(
*
this
)
;
if
(
!
mBodyStream
)
{
return
clone
.
forget
(
)
;
}
nsCOMPtr
<
nsIInputStream
>
clonedBody
;
nsCOMPtr
<
nsIInputStream
>
replacementBody
;
nsresult
rv
=
NS_CloneInputStream
(
mBodyStream
getter_AddRefs
(
clonedBody
)
getter_AddRefs
(
replacementBody
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
clone
-
>
mBodyStream
.
swap
(
clonedBody
)
;
if
(
replacementBody
)
{
mBodyStream
.
swap
(
replacementBody
)
;
}
return
clone
.
forget
(
)
;
}
InternalRequest
:
:
InternalRequest
(
const
InternalRequest
&
aOther
)
:
mMethod
(
aOther
.
mMethod
)
mURL
(
aOther
.
mURL
)
mHeaders
(
new
InternalHeaders
(
*
aOther
.
mHeaders
)
)
mContentPolicyType
(
aOther
.
mContentPolicyType
)
mReferrer
(
aOther
.
mReferrer
)
mMode
(
aOther
.
mMode
)
mCredentialsMode
(
aOther
.
mCredentialsMode
)
mResponseTainting
(
aOther
.
mResponseTainting
)
mCacheMode
(
aOther
.
mCacheMode
)
mRedirectMode
(
aOther
.
mRedirectMode
)
mAuthenticationFlag
(
aOther
.
mAuthenticationFlag
)
mForceOriginHeader
(
aOther
.
mForceOriginHeader
)
mPreserveContentCodings
(
aOther
.
mPreserveContentCodings
)
mSameOriginDataURL
(
aOther
.
mSameOriginDataURL
)
mSandboxedStorageAreaURLs
(
aOther
.
mSandboxedStorageAreaURLs
)
mSkipServiceWorker
(
aOther
.
mSkipServiceWorker
)
mSynchronous
(
aOther
.
mSynchronous
)
mUnsafeRequest
(
aOther
.
mUnsafeRequest
)
mUseURLCredentials
(
aOther
.
mUseURLCredentials
)
mCreatedByFetchEvent
(
aOther
.
mCreatedByFetchEvent
)
{
}
InternalRequest
:
:
~
InternalRequest
(
)
{
}
void
InternalRequest
:
:
SetContentPolicyType
(
nsContentPolicyType
aContentPolicyType
)
{
mContentPolicyType
=
aContentPolicyType
;
}
RequestContext
InternalRequest
:
:
MapContentPolicyTypeToRequestContext
(
nsContentPolicyType
aContentPolicyType
)
{
RequestContext
context
=
RequestContext
:
:
Internal
;
switch
(
aContentPolicyType
)
{
case
nsIContentPolicy
:
:
TYPE_OTHER
:
context
=
RequestContext
:
:
Internal
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
:
context
=
RequestContext
:
:
Script
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
:
context
=
RequestContext
:
:
Worker
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
:
context
=
RequestContext
:
:
Sharedworker
;
break
;
case
nsIContentPolicy
:
:
TYPE_IMAGE
:
context
=
RequestContext
:
:
Image
;
break
;
case
nsIContentPolicy
:
:
TYPE_STYLESHEET
:
context
=
RequestContext
:
:
Style
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_OBJECT
:
context
=
RequestContext
:
:
Object
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EMBED
:
context
=
RequestContext
:
:
Embed
;
break
;
case
nsIContentPolicy
:
:
TYPE_DOCUMENT
:
context
=
RequestContext
:
:
Internal
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
:
context
=
RequestContext
:
:
Iframe
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
:
context
=
RequestContext
:
:
Frame
;
break
;
case
nsIContentPolicy
:
:
TYPE_REFRESH
:
context
=
RequestContext
:
:
Internal
;
break
;
case
nsIContentPolicy
:
:
TYPE_XBL
:
context
=
RequestContext
:
:
Internal
;
break
;
case
nsIContentPolicy
:
:
TYPE_PING
:
context
=
RequestContext
:
:
Ping
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_XMLHTTPREQUEST
:
context
=
RequestContext
:
:
Xmlhttprequest
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_EVENTSOURCE
:
context
=
RequestContext
:
:
Eventsource
;
break
;
case
nsIContentPolicy
:
:
TYPE_OBJECT_SUBREQUEST
:
context
=
RequestContext
:
:
Plugin
;
break
;
case
nsIContentPolicy
:
:
TYPE_DTD
:
context
=
RequestContext
:
:
Internal
;
break
;
case
nsIContentPolicy
:
:
TYPE_FONT
:
context
=
RequestContext
:
:
Font
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_AUDIO
:
context
=
RequestContext
:
:
Audio
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_VIDEO
:
context
=
RequestContext
:
:
Video
;
break
;
case
nsIContentPolicy
:
:
TYPE_INTERNAL_TRACK
:
context
=
RequestContext
:
:
Track
;
break
;
case
nsIContentPolicy
:
:
TYPE_WEBSOCKET
:
context
=
RequestContext
:
:
Internal
;
break
;
case
nsIContentPolicy
:
:
TYPE_CSP_REPORT
:
context
=
RequestContext
:
:
Cspreport
;
break
;
case
nsIContentPolicy
:
:
TYPE_XSLT
:
context
=
RequestContext
:
:
Xslt
;
break
;
case
nsIContentPolicy
:
:
TYPE_BEACON
:
context
=
RequestContext
:
:
Beacon
;
break
;
case
nsIContentPolicy
:
:
TYPE_FETCH
:
context
=
RequestContext
:
:
Fetch
;
break
;
case
nsIContentPolicy
:
:
TYPE_IMAGESET
:
context
=
RequestContext
:
:
Imageset
;
break
;
case
nsIContentPolicy
:
:
TYPE_WEB_MANIFEST
:
context
=
RequestContext
:
:
Manifest
;
break
;
default
:
MOZ_ASSERT
(
false
"
Unhandled
nsContentPolicyType
value
"
)
;
break
;
}
return
context
;
}
bool
InternalRequest
:
:
IsNavigationContentPolicy
(
nsContentPolicyType
aContentPolicyType
)
{
return
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
|
|
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
|
|
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
|
|
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
|
|
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_REFRESH
;
}
bool
InternalRequest
:
:
IsWorkerContentPolicy
(
nsContentPolicyType
aContentPolicyType
)
{
return
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
|
|
aContentPolicyType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
;
}
bool
InternalRequest
:
:
IsNavigationRequest
(
)
const
{
return
IsNavigationContentPolicy
(
mContentPolicyType
)
;
}
bool
InternalRequest
:
:
IsWorkerRequest
(
)
const
{
return
IsWorkerContentPolicy
(
mContentPolicyType
)
;
}
bool
InternalRequest
:
:
IsClientRequest
(
)
const
{
return
IsNavigationRequest
(
)
|
|
IsWorkerRequest
(
)
;
}
RequestMode
InternalRequest
:
:
MapChannelToRequestMode
(
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
aChannel
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
aChannel
-
>
GetLoadInfo
(
getter_AddRefs
(
loadInfo
)
)
)
)
;
nsContentPolicyType
contentPolicy
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
if
(
IsNavigationContentPolicy
(
contentPolicy
)
|
|
IsWorkerContentPolicy
(
contentPolicy
)
)
{
return
RequestMode
:
:
Same_origin
;
}
uint32_t
securityMode
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
loadInfo
-
>
GetSecurityMode
(
&
securityMode
)
)
)
;
switch
(
securityMode
)
{
case
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_INHERITS
:
case
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_DATA_IS_BLOCKED
:
return
RequestMode
:
:
Same_origin
;
case
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_INHERITS
:
case
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
:
return
RequestMode
:
:
No_cors
;
case
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
:
return
RequestMode
:
:
Cors
;
default
:
MOZ_ASSERT
(
securityMode
=
=
nsILoadInfo
:
:
SEC_NORMAL
)
;
break
;
}
#
ifndef
RELEASE_BUILD
nsCOMPtr
<
nsIJARChannel
>
jarChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
jarChannel
)
{
return
RequestMode
:
:
No_cors
;
}
#
endif
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
uint32_t
corsMode
;
MOZ_ALWAYS_TRUE
(
NS_SUCCEEDED
(
httpChannel
-
>
GetCorsMode
(
&
corsMode
)
)
)
;
return
static_cast
<
RequestMode
>
(
corsMode
)
;
}
}
}
