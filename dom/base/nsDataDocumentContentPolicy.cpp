#
include
"
nsContentUtils
.
h
"
#
include
"
nsDataDocumentContentPolicy
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIProtocolHandler
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsIURI
.
h
"
NS_IMPL_ISUPPORTS
(
nsDataDocumentContentPolicy
nsIContentPolicy
)
static
bool
HasFlags
(
nsIURI
*
aURI
uint32_t
aURIFlags
)
{
bool
hasFlags
;
nsresult
rv
=
NS_URIChainHasFlags
(
aURI
aURIFlags
&
hasFlags
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
hasFlags
;
}
NS_IMETHODIMP
nsDataDocumentContentPolicy
:
:
ShouldLoad
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
uint32_t
contentType
=
aLoadInfo
-
>
GetExternalContentPolicyType
(
)
;
nsCOMPtr
<
nsISupports
>
requestingContext
=
aLoadInfo
-
>
GetLoadingContext
(
)
;
MOZ_ASSERT
(
contentType
=
=
nsContentUtils
:
:
InternalContentPolicyTypeToExternal
(
contentType
)
"
We
should
only
see
external
content
policy
types
here
.
"
)
;
*
aDecision
=
nsIContentPolicy
:
:
ACCEPT
;
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
requestingContext
)
;
if
(
node
)
{
doc
=
node
-
>
OwnerDoc
(
)
;
}
else
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
do_QueryInterface
(
requestingContext
)
)
{
doc
=
window
-
>
GetDoc
(
)
;
}
}
if
(
!
doc
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_DTD
)
{
return
NS_OK
;
}
if
(
doc
-
>
IsLoadedAsData
(
)
)
{
if
(
!
doc
-
>
IsStaticDocument
(
)
|
|
contentType
!
=
nsIContentPolicy
:
:
TYPE_FONT
)
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_TYPE
;
return
NS_OK
;
}
}
nsIDocument
*
docToCheckForImage
=
doc
-
>
GetDisplayDocument
(
)
;
if
(
!
docToCheckForImage
)
{
docToCheckForImage
=
doc
;
}
if
(
docToCheckForImage
-
>
IsBeingUsedAsImage
(
)
)
{
if
(
!
(
HasFlags
(
aContentLocation
nsIProtocolHandler
:
:
URI_IS_LOCAL_RESOURCE
)
&
&
(
HasFlags
(
aContentLocation
nsIProtocolHandler
:
:
URI_INHERITS_SECURITY_CONTEXT
)
|
|
HasFlags
(
aContentLocation
nsIProtocolHandler
:
:
URI_LOADABLE_BY_SUBSUMERS
)
)
)
)
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_TYPE
;
if
(
node
)
{
nsIPrincipal
*
requestingPrincipal
=
node
-
>
NodePrincipal
(
)
;
RefPtr
<
nsIURI
>
principalURI
;
nsresult
rv
=
requestingPrincipal
-
>
GetURI
(
getter_AddRefs
(
principalURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
principalURI
)
{
nsScriptSecurityManager
:
:
ReportError
(
"
ExternalDataError
"
principalURI
aContentLocation
requestingPrincipal
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
>
0
)
;
}
}
}
else
if
(
(
contentType
=
=
nsIContentPolicy
:
:
TYPE_IMAGE
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_IMAGESET
)
&
&
doc
-
>
GetDocumentURI
(
)
)
{
bool
isRecursiveLoad
;
nsresult
rv
=
aContentLocation
-
>
EqualsExceptRef
(
doc
-
>
GetDocumentURI
(
)
&
isRecursiveLoad
)
;
if
(
NS_FAILED
(
rv
)
|
|
isRecursiveLoad
)
{
NS_WARNING
(
"
Refusing
to
recursively
load
image
"
)
;
*
aDecision
=
nsIContentPolicy
:
:
REJECT_TYPE
;
}
}
return
NS_OK
;
}
if
(
!
doc
-
>
IsResourceDoc
(
)
)
{
return
NS_OK
;
}
if
(
contentType
=
=
nsIContentPolicy
:
:
TYPE_OBJECT
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_SUBDOCUMENT
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_SCRIPT
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_XSLT
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_FETCH
|
|
contentType
=
=
nsIContentPolicy
:
:
TYPE_WEB_MANIFEST
)
{
*
aDecision
=
nsIContentPolicy
:
:
REJECT_TYPE
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDataDocumentContentPolicy
:
:
ShouldProcess
(
nsIURI
*
aContentLocation
nsILoadInfo
*
aLoadInfo
const
nsACString
&
aMimeGuess
int16_t
*
aDecision
)
{
return
ShouldLoad
(
aContentLocation
aLoadInfo
aMimeGuess
aDecision
)
;
}
