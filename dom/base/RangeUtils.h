#
ifndef
mozilla_RangeUtils_h
#
define
mozilla_RangeUtils_h
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsINode
.
h
"
namespace
mozilla
{
namespace
dom
{
class
AbstractRange
;
struct
ShadowDOMSelectionHelpers
{
ShadowDOMSelectionHelpers
(
)
=
delete
;
static
nsINode
*
GetStartContainer
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
;
static
uint32_t
StartOffset
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
;
static
nsINode
*
GetEndContainer
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
;
static
uint32_t
EndOffset
(
const
AbstractRange
*
aRange
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
;
static
nsINode
*
GetParentNodeInSameSelection
(
const
nsINode
&
aNode
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
;
static
ShadowRoot
*
GetShadowRoot
(
const
nsINode
*
aNode
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
)
;
}
;
}
class
RangeUtils
final
{
using
AbstractRange
=
dom
:
:
AbstractRange
;
public
:
static
const
RawRangeBoundary
GetRawRangeBoundaryAfter
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
NS_WARN_IF
(
!
aNode
-
>
IsContent
(
)
)
)
{
return
RawRangeBoundary
(
)
;
}
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
RawRangeBoundary
(
)
;
}
RawRangeBoundary
afterNode
(
parentNode
aNode
-
>
AsContent
(
)
)
;
if
(
NS_WARN_IF
(
!
afterNode
.
Offset
(
RawRangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
)
)
{
return
RawRangeBoundary
(
)
;
}
return
afterNode
;
}
static
const
RawRangeBoundary
GetRawRangeBoundaryBefore
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
)
;
if
(
NS_WARN_IF
(
!
aNode
-
>
IsContent
(
)
)
)
{
return
RawRangeBoundary
(
)
;
}
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
RawRangeBoundary
(
)
;
}
const
Maybe
<
uint32_t
>
indexInParent
=
parentNode
-
>
ComputeIndexOf
(
aNode
)
;
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
indexInParent
.
isNothing
(
)
)
)
)
{
return
RawRangeBoundary
(
)
;
}
return
RawRangeBoundary
(
parentNode
*
indexInParent
)
;
}
static
nsINode
*
ComputeRootNode
(
nsINode
*
aNode
)
;
static
bool
IsValidOffset
(
uint32_t
aOffset
)
{
return
aOffset
<
=
INT32_MAX
;
}
static
bool
IsValidPoints
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
return
IsValidPoints
(
RawRangeBoundary
(
aStartContainer
aStartOffset
)
RawRangeBoundary
(
aEndContainer
aEndOffset
)
)
;
}
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
>
static
bool
IsValidPoints
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
)
;
template
<
TreeKind
aKind
=
TreeKind
:
:
ShadowIncludingDOM
typename
=
std
:
:
enable_if_t
<
aKind
=
=
TreeKind
:
:
ShadowIncludingDOM
|
|
aKind
=
=
TreeKind
:
:
Flat
>
>
static
Maybe
<
bool
>
IsNodeContainedInRange
(
nsINode
&
aNode
AbstractRange
*
aAbstractRange
)
;
template
<
TreeKind
aKind
=
TreeKind
:
:
ShadowIncludingDOM
typename
=
std
:
:
enable_if_t
<
aKind
=
=
TreeKind
:
:
ShadowIncludingDOM
|
|
aKind
=
=
TreeKind
:
:
Flat
>
>
static
nsresult
CompareNodeToRange
(
nsINode
*
aNode
AbstractRange
*
aAbstractRange
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
template
<
TreeKind
aKind
typename
SPT
typename
SRT
typename
EPT
typename
ERT
typename
=
std
:
:
enable_if_t
<
aKind
=
=
TreeKind
:
:
ShadowIncludingDOM
|
|
aKind
=
=
TreeKind
:
:
Flat
>
>
static
nsresult
CompareNodeToRangeBoundaries
(
nsINode
*
aNode
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
bool
*
aNodeIsBeforeRange
bool
*
aNodeIsAfterRange
)
;
}
;
}
#
endif
