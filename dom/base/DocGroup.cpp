#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
PerformanceUtils
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
mozilla
/
dom
/
DOMTypes
.
h
"
#
include
"
mozilla
/
dom
/
JSExecutionManager
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsIDirectTaskDispatcher
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsThread
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
processthreadsapi
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
namespace
{
#
define
NS_LABELLINGEVENTTARGET_IID
\
{
\
0x6087fa50
0xe387
0x45c8
{
\
0xab
0x72
0xd2
0x1f
0x69
0xee
0xd3
0x15
\
}
\
}
class
LabellingEventTarget
final
:
public
nsISerialEventTarget
public
nsIDirectTaskDispatcher
{
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_LABELLINGEVENTTARGET_IID
)
explicit
LabellingEventTarget
(
mozilla
:
:
dom
:
:
DocGroup
*
aDocGroup
)
:
mDocGroup
(
aDocGroup
)
mMainThread
(
static_cast
<
nsThread
*
>
(
GetMainThreadSerialEventTarget
(
)
)
)
{
}
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIEVENTTARGET_FULL
NS_DECL_NSIDIRECTTASKDISPATCHER
private
:
~
LabellingEventTarget
(
)
=
default
;
const
RefPtr
<
nsThread
>
mMainThread
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
LabellingEventTarget
NS_LABELLINGEVENTTARGET_IID
)
}
NS_IMETHODIMP
LabellingEventTarget
:
:
DispatchFromScript
(
nsIRunnable
*
aRunnable
uint32_t
aFlags
)
{
return
Dispatch
(
do_AddRef
(
aRunnable
)
aFlags
)
;
}
NS_IMETHODIMP
LabellingEventTarget
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
aRunnable
uint32_t
aFlags
)
{
if
(
NS_WARN_IF
(
aFlags
!
=
NS_DISPATCH_NORMAL
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
return
mozilla
:
:
SchedulerGroup
:
:
DispatchWithDocGroup
(
mozilla
:
:
TaskCategory
:
:
Other
std
:
:
move
(
aRunnable
)
mDocGroup
)
;
}
NS_IMETHODIMP
LabellingEventTarget
:
:
DelayedDispatch
(
already_AddRefed
<
nsIRunnable
>
uint32_t
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
LabellingEventTarget
:
:
IsOnCurrentThread
(
bool
*
aIsOnCurrentThread
)
{
*
aIsOnCurrentThread
=
NS_IsMainThread
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
bool
)
LabellingEventTarget
:
:
IsOnCurrentThreadInfallible
(
)
{
return
NS_IsMainThread
(
)
;
}
NS_IMETHODIMP
LabellingEventTarget
:
:
DispatchDirectTask
(
already_AddRefed
<
nsIRunnable
>
aEvent
)
{
return
mMainThread
-
>
DispatchDirectTask
(
std
:
:
move
(
aEvent
)
)
;
}
NS_IMETHODIMP
LabellingEventTarget
:
:
DrainDirectTasks
(
)
{
return
mMainThread
-
>
DrainDirectTasks
(
)
;
}
NS_IMETHODIMP
LabellingEventTarget
:
:
HaveDirectTasks
(
bool
*
aValue
)
{
return
mMainThread
-
>
HaveDirectTasks
(
aValue
)
;
}
NS_IMPL_ISUPPORTS
(
LabellingEventTarget
nsIEventTarget
nsISerialEventTarget
nsIDirectTaskDispatcher
)
namespace
mozilla
{
namespace
dom
{
AutoTArray
<
RefPtr
<
DocGroup
>
2
>
*
DocGroup
:
:
sPendingDocGroups
=
nullptr
;
already_AddRefed
<
DocGroup
>
DocGroup
:
:
Create
(
BrowsingContextGroup
*
aBrowsingContextGroup
const
nsACString
&
aKey
)
{
RefPtr
<
DocGroup
>
docGroup
=
new
DocGroup
(
aBrowsingContextGroup
aKey
)
;
docGroup
-
>
mEventTarget
=
new
LabellingEventTarget
(
docGroup
)
;
return
docGroup
.
forget
(
)
;
}
nsresult
DocGroup
:
:
GetKey
(
nsIPrincipal
*
aPrincipal
bool
aCrossOriginIsolated
nsACString
&
aKey
)
{
nsresult
rv
=
aCrossOriginIsolated
?
aPrincipal
-
>
GetOrigin
(
aKey
)
:
aPrincipal
-
>
GetSiteOrigin
(
aKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
aKey
.
Truncate
(
)
;
}
return
rv
;
}
void
DocGroup
:
:
SetExecutionManager
(
JSExecutionManager
*
aManager
)
{
mExecutionManager
=
aManager
;
}
void
DocGroup
:
:
AddDocument
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mDocuments
.
Contains
(
aDocument
)
)
;
MOZ_ASSERT
(
mBrowsingContextGroup
)
;
mDocuments
.
AppendElement
(
aDocument
)
;
}
void
DocGroup
:
:
RemoveDocument
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mDocuments
.
Contains
(
aDocument
)
)
;
mDocuments
.
RemoveElement
(
aDocument
)
;
if
(
mDocuments
.
IsEmpty
(
)
)
{
mBrowsingContextGroup
=
nullptr
;
mEventTarget
=
nullptr
;
}
}
DocGroup
:
:
DocGroup
(
BrowsingContextGroup
*
aBrowsingContextGroup
const
nsACString
&
aKey
)
:
mKey
(
aKey
)
mBrowsingContextGroup
(
aBrowsingContextGroup
)
mAgentClusterId
(
nsContentUtils
:
:
GenerateUUID
(
)
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
StaticPrefs
:
:
dom_arena_allocator_enabled_AtStartup
(
)
)
{
mArena
=
new
mozilla
:
:
dom
:
:
DOMArena
(
)
;
}
mPerformanceCounter
=
new
mozilla
:
:
PerformanceCounter
(
"
DocGroup
:
"
_ns
+
aKey
)
;
}
DocGroup
:
:
~
DocGroup
(
)
{
MOZ_RELEASE_ASSERT
(
mDocuments
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
!
mBrowsingContextGroup
)
;
if
(
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThread
(
"
DocGroup
:
:
mReactionsStack
"
mReactionsStack
.
forget
(
)
)
;
NS_ReleaseOnMainThread
(
"
DocGroup
:
:
mArena
"
mArena
.
forget
(
)
)
;
}
if
(
mIframePostMessageQueue
)
{
FlushIframePostMessageQueue
(
)
;
}
}
RefPtr
<
PerformanceInfoPromise
>
DocGroup
:
:
ReportPerformanceInfo
(
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
mPerformanceCounter
)
;
#
if
defined
(
XP_WIN
)
uint32_t
pid
=
GetCurrentProcessId
(
)
;
#
else
uint32_t
pid
=
getpid
(
)
;
#
endif
uint64_t
windowID
=
0
;
uint16_t
count
=
0
;
uint64_t
duration
=
0
;
bool
isTopLevel
=
false
;
nsCString
host
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
;
RefPtr
<
AbstractThread
>
mainThread
;
for
(
const
auto
&
document
:
*
this
)
{
nsCOMPtr
<
Document
>
doc
=
document
;
MOZ_ASSERT
(
doc
)
;
nsCOMPtr
<
nsIURI
>
docURI
=
doc
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
)
{
continue
;
}
docURI
-
>
GetHost
(
host
)
;
if
(
host
.
IsEmpty
(
)
)
{
host
=
docURI
-
>
GetSpecOrDefault
(
)
;
}
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
continue
;
}
top
=
win
-
>
GetInProcessTop
(
)
;
if
(
!
top
)
{
continue
;
}
windowID
=
top
-
>
WindowID
(
)
;
isTopLevel
=
win
-
>
GetBrowsingContext
(
)
-
>
IsTop
(
)
;
mainThread
=
AbstractMainThreadFor
(
TaskCategory
:
:
Performance
)
;
break
;
}
MOZ_ASSERT
(
!
host
.
IsEmpty
(
)
)
;
duration
=
mPerformanceCounter
-
>
GetExecutionDuration
(
)
;
FallibleTArray
<
CategoryDispatch
>
items
;
for
(
uint32_t
index
=
0
;
index
<
(
uint32_t
)
TaskCategory
:
:
Count
;
index
+
+
)
{
TaskCategory
category
=
static_cast
<
TaskCategory
>
(
index
)
;
count
=
mPerformanceCounter
-
>
GetDispatchCount
(
DispatchCategory
(
category
)
)
;
CategoryDispatch
item
=
CategoryDispatch
(
index
count
)
;
if
(
!
items
.
AppendElement
(
item
fallible
)
)
{
NS_ERROR
(
"
Could
not
complete
the
operation
"
)
;
break
;
}
}
if
(
!
isTopLevel
)
{
return
PerformanceInfoPromise
:
:
CreateAndResolve
(
PerformanceInfo
(
host
pid
windowID
duration
mPerformanceCounter
-
>
GetID
(
)
false
isTopLevel
PerformanceMemoryInfo
(
)
items
)
__func__
)
;
}
MOZ_ASSERT
(
mainThread
)
;
RefPtr
<
DocGroup
>
self
=
this
;
return
CollectMemoryInfo
(
top
mainThread
)
-
>
Then
(
mainThread
__func__
[
self
host
pid
windowID
duration
isTopLevel
items
=
std
:
:
move
(
items
)
]
(
const
PerformanceMemoryInfo
&
aMemoryInfo
)
{
PerformanceInfo
info
=
PerformanceInfo
(
host
pid
windowID
duration
self
-
>
mPerformanceCounter
-
>
GetID
(
)
false
isTopLevel
aMemoryInfo
items
)
;
return
PerformanceInfoPromise
:
:
CreateAndResolve
(
std
:
:
move
(
info
)
__func__
)
;
}
[
self
]
(
const
nsresult
rv
)
{
return
PerformanceInfoPromise
:
:
CreateAndReject
(
rv
__func__
)
;
}
)
;
}
nsresult
DocGroup
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
if
(
mPerformanceCounter
)
{
mPerformanceCounter
-
>
IncrementDispatchCounter
(
DispatchCategory
(
aCategory
)
)
;
}
return
SchedulerGroup
:
:
DispatchWithDocGroup
(
aCategory
std
:
:
move
(
aRunnable
)
this
)
;
}
nsISerialEventTarget
*
DocGroup
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
MOZ_ASSERT
(
!
mDocuments
.
IsEmpty
(
)
)
;
if
(
mEventTarget
)
{
return
mEventTarget
;
}
return
GetMainThreadSerialEventTarget
(
)
;
}
AbstractThread
*
DocGroup
:
:
AbstractMainThreadFor
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
mDocuments
.
IsEmpty
(
)
)
;
return
AbstractThread
:
:
MainThread
(
)
;
}
void
DocGroup
:
:
SignalSlotChange
(
HTMLSlotElement
&
aSlot
)
{
MOZ_ASSERT
(
!
mSignalSlotList
.
Contains
(
&
aSlot
)
)
;
mSignalSlotList
.
AppendElement
(
&
aSlot
)
;
if
(
!
sPendingDocGroups
)
{
nsDOMMutationObserver
:
:
QueueMutationObserverMicroTask
(
)
;
sPendingDocGroups
=
new
AutoTArray
<
RefPtr
<
DocGroup
>
2
>
;
}
sPendingDocGroups
-
>
AppendElement
(
this
)
;
}
bool
DocGroup
:
:
TryToLoadIframesInBackground
(
)
{
return
StaticPrefs
:
:
dom_separate_event_queue_for_post_message_enabled
(
)
&
&
StaticPrefs
:
:
dom_cross_origin_iframes_loaded_in_background
(
)
;
}
nsresult
DocGroup
:
:
QueueIframePostMessages
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
uint64_t
aWindowId
)
{
if
(
DocGroup
:
:
TryToLoadIframesInBackground
(
)
)
{
if
(
!
mIframePostMessageQueue
)
{
nsCOMPtr
<
nsISerialEventTarget
>
target
=
GetMainThreadSerialEventTarget
(
)
;
mIframePostMessageQueue
=
ThrottledEventQueue
:
:
Create
(
target
"
Background
Loading
Iframe
PostMessage
Queue
"
nsIRunnablePriority
:
:
PRIORITY_DEFERRED_TIMERS
)
;
nsresult
rv
=
mIframePostMessageQueue
-
>
SetIsPaused
(
true
)
;
MOZ_ALWAYS_SUCCEEDS
(
rv
)
;
}
MOZ_ASSERT
(
mIframePostMessageQueue
)
;
MOZ_ASSERT
(
mIframePostMessageQueue
-
>
IsPaused
(
)
)
;
mIframesUsedPostMessageQueue
.
PutEntry
(
aWindowId
)
;
mIframePostMessageQueue
-
>
Dispatch
(
std
:
:
move
(
aRunnable
)
NS_DISPATCH_NORMAL
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
void
DocGroup
:
:
TryFlushIframePostMessages
(
uint64_t
aWindowId
)
{
if
(
DocGroup
:
:
TryToLoadIframesInBackground
(
)
)
{
mIframesUsedPostMessageQueue
.
RemoveEntry
(
aWindowId
)
;
if
(
mIframePostMessageQueue
&
&
mIframesUsedPostMessageQueue
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
mIframePostMessageQueue
-
>
IsPaused
(
)
)
;
nsresult
rv
=
mIframePostMessageQueue
-
>
SetIsPaused
(
true
)
;
MOZ_ALWAYS_SUCCEEDS
(
rv
)
;
FlushIframePostMessageQueue
(
)
;
}
}
}
void
DocGroup
:
:
FlushIframePostMessageQueue
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
;
while
(
(
event
=
mIframePostMessageQueue
-
>
GetEvent
(
)
)
)
{
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
}
nsTArray
<
RefPtr
<
HTMLSlotElement
>
>
DocGroup
:
:
MoveSignalSlotList
(
)
{
for
(
const
RefPtr
<
HTMLSlotElement
>
&
slot
:
mSignalSlotList
)
{
slot
-
>
RemovedFromSignalSlotList
(
)
;
}
return
std
:
:
move
(
mSignalSlotList
)
;
}
bool
DocGroup
:
:
IsActive
(
)
const
{
for
(
Document
*
doc
:
mDocuments
)
{
if
(
doc
-
>
IsCurrentActiveDocument
(
)
)
{
return
true
;
}
}
return
false
;
}
}
}
