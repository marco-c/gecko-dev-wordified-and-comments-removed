#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
DOMTypes
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
if
defined
(
XP_WIN
)
#
include
<
processthreadsapi
.
h
>
#
else
#
include
<
unistd
.
h
>
#
endif
namespace
mozilla
{
namespace
dom
{
AutoTArray
<
RefPtr
<
DocGroup
>
2
>
*
DocGroup
:
:
sPendingDocGroups
=
nullptr
;
nsresult
DocGroup
:
:
GetKey
(
nsIPrincipal
*
aPrincipal
nsACString
&
aKey
)
{
nsresult
rv
=
aPrincipal
-
>
GetBaseDomain
(
aKey
)
;
if
(
NS_FAILED
(
rv
)
)
{
aKey
.
Truncate
(
)
;
}
return
rv
;
}
void
DocGroup
:
:
RemoveDocument
(
nsIDocument
*
aDocument
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mDocuments
.
Contains
(
aDocument
)
)
;
mDocuments
.
RemoveElement
(
aDocument
)
;
}
DocGroup
:
:
DocGroup
(
TabGroup
*
aTabGroup
const
nsACString
&
aKey
)
:
mKey
(
aKey
)
mTabGroup
(
aTabGroup
)
{
#
ifndef
RELEASE_OR_BETA
mPerformanceCounter
=
new
mozilla
:
:
PerformanceCounter
(
aKey
)
;
#
endif
}
DocGroup
:
:
~
DocGroup
(
)
{
MOZ_ASSERT
(
mDocuments
.
IsEmpty
(
)
)
;
if
(
!
NS_IsMainThread
(
)
)
{
nsIEventTarget
*
target
=
EventTargetFor
(
TaskCategory
:
:
Other
)
;
NS_ProxyRelease
(
"
DocGroup
:
:
mReactionsStack
"
target
mReactionsStack
.
forget
(
)
)
;
}
mTabGroup
-
>
mDocGroups
.
RemoveEntry
(
mKey
)
;
}
#
ifndef
RELEASE_OR_BETA
PerformanceInfo
DocGroup
:
:
ReportPerformanceInfo
(
)
{
AssertIsOnMainThread
(
)
;
#
if
defined
(
XP_WIN
)
uint32_t
pid
=
GetCurrentProcessId
(
)
;
#
else
uint32_t
pid
=
getpid
(
)
;
#
endif
uint64_t
wid
=
0
;
uint64_t
pwid
=
0
;
uint16_t
count
=
0
;
uint64_t
duration
=
0
;
nsCString
host
=
NS_LITERAL_CSTRING
(
"
None
"
)
;
for
(
const
auto
&
document
:
*
this
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
document
)
;
MOZ_ASSERT
(
doc
)
;
nsCOMPtr
<
nsIURI
>
docURI
=
doc
-
>
GetDocumentURI
(
)
;
if
(
!
docURI
)
{
continue
;
}
docURI
-
>
GetHost
(
host
)
;
wid
=
doc
-
>
OuterWindowID
(
)
;
pwid
=
wid
;
nsPIDOMWindowInner
*
win
=
doc
-
>
GetInnerWindow
(
)
;
if
(
win
)
{
nsPIDOMWindowOuter
*
outer
=
win
-
>
GetOuterWindow
(
)
;
if
(
outer
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
outer
-
>
GetTop
(
)
;
if
(
top
)
{
pwid
=
top
-
>
WindowID
(
)
;
}
}
}
}
duration
=
mPerformanceCounter
-
>
GetExecutionDuration
(
)
;
FallibleTArray
<
CategoryDispatch
>
items
;
for
(
uint32_t
index
=
0
;
index
<
(
uint32_t
)
TaskCategory
:
:
Count
;
index
+
+
)
{
TaskCategory
category
=
static_cast
<
TaskCategory
>
(
index
)
;
count
=
mPerformanceCounter
-
>
GetDispatchCount
(
DispatchCategory
(
category
)
)
;
CategoryDispatch
item
=
CategoryDispatch
(
index
count
)
;
if
(
!
items
.
AppendElement
(
item
fallible
)
)
{
NS_ERROR
(
"
Could
not
complete
the
operation
"
)
;
return
PerformanceInfo
(
host
pid
wid
pwid
duration
false
items
)
;
}
}
mPerformanceCounter
-
>
ResetPerformanceCounters
(
)
;
return
PerformanceInfo
(
host
pid
wid
pwid
duration
false
items
)
;
}
#
endif
nsresult
DocGroup
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
#
ifndef
RELEASE_OR_BETA
mPerformanceCounter
-
>
IncrementDispatchCounter
(
DispatchCategory
(
aCategory
)
)
;
#
endif
return
mTabGroup
-
>
DispatchWithDocGroup
(
aCategory
Move
(
aRunnable
)
this
)
;
}
nsISerialEventTarget
*
DocGroup
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
return
mTabGroup
-
>
EventTargetFor
(
aCategory
)
;
}
AbstractThread
*
DocGroup
:
:
AbstractMainThreadFor
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mTabGroup
-
>
AbstractMainThreadFor
(
aCategory
)
;
}
bool
*
DocGroup
:
:
GetValidAccessPtr
(
)
{
return
mTabGroup
-
>
GetValidAccessPtr
(
)
;
}
void
DocGroup
:
:
SignalSlotChange
(
const
HTMLSlotElement
*
aSlot
)
{
if
(
mSignalSlotList
.
Contains
(
aSlot
)
)
{
return
;
}
mSignalSlotList
.
AppendElement
(
const_cast
<
HTMLSlotElement
*
>
(
aSlot
)
)
;
if
(
!
sPendingDocGroups
)
{
nsDOMMutationObserver
:
:
QueueMutationObserverMicroTask
(
)
;
sPendingDocGroups
=
new
AutoTArray
<
RefPtr
<
DocGroup
>
2
>
;
}
sPendingDocGroups
-
>
AppendElement
(
this
)
;
}
}
}
