#
ifndef
nsContentList_h___
#
define
nsContentList_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsContentListDeclarations
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsINodeList
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
mozilla
/
HashFunctions
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
nsIContent
.
h
"
namespace
mozilla
:
:
dom
{
class
Element
;
}
class
nsBaseContentList
:
public
nsINodeList
{
protected
:
using
Element
=
mozilla
:
:
dom
:
:
Element
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
int32_t
IndexOf
(
nsIContent
*
aContent
)
override
;
nsIContent
*
Item
(
uint32_t
aIndex
)
override
;
uint32_t
Length
(
)
override
{
return
mElements
.
Length
(
)
;
}
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_WRAPPERCACHE_CLASS
(
nsBaseContentList
)
void
AppendElement
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
mElements
.
AppendElement
(
aContent
)
;
}
void
MaybeAppendElement
(
nsIContent
*
aContent
)
{
if
(
aContent
)
{
AppendElement
(
aContent
)
;
}
}
void
InsertElementAt
(
nsIContent
*
aContent
int32_t
aIndex
)
{
NS_ASSERTION
(
aContent
"
Element
to
insert
must
not
be
null
"
)
;
mElements
.
InsertElementAt
(
aIndex
aContent
)
;
}
void
RemoveElement
(
nsIContent
*
aContent
)
{
mElements
.
RemoveElement
(
aContent
)
;
}
void
Reset
(
)
{
mElements
.
Clear
(
)
;
}
virtual
int32_t
IndexOf
(
nsIContent
*
aContent
bool
aDoFlush
)
;
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
=
0
;
void
SetCapacity
(
uint32_t
aCapacity
)
{
mElements
.
SetCapacity
(
aCapacity
)
;
}
virtual
void
LastRelease
(
)
{
}
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
virtual
~
nsBaseContentList
(
)
;
virtual
void
RemoveFromCaches
(
)
{
}
AutoTArray
<
nsCOMPtr
<
nsIContent
>
10
>
mElements
;
}
;
class
nsSimpleContentList
:
public
nsBaseContentList
{
public
:
explicit
nsSimpleContentList
(
nsINode
*
aRoot
)
:
nsBaseContentList
(
)
mRoot
(
aRoot
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsSimpleContentList
nsBaseContentList
)
nsINode
*
GetParentObject
(
)
override
{
return
mRoot
;
}
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
protected
:
virtual
~
nsSimpleContentList
(
)
=
default
;
private
:
nsCOMPtr
<
nsINode
>
mRoot
;
}
;
class
nsEmptyContentList
final
:
public
nsBaseContentList
public
nsIHTMLCollection
{
public
:
explicit
nsEmptyContentList
(
nsINode
*
aRoot
)
:
nsBaseContentList
(
)
mRoot
(
aRoot
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsEmptyContentList
nsBaseContentList
)
nsINode
*
GetParentObject
(
)
override
{
return
mRoot
;
}
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
JSObject
*
GetWrapperPreserveColorInternal
(
)
override
{
return
nsWrapperCache
:
:
GetWrapperPreserveColor
(
)
;
}
void
PreserveWrapperInternal
(
nsISupports
*
aScriptObjectHolder
)
override
{
nsWrapperCache
:
:
PreserveWrapper
(
aScriptObjectHolder
)
;
}
uint32_t
Length
(
)
final
{
return
0
;
}
nsIContent
*
Item
(
uint32_t
aIndex
)
override
;
Element
*
GetElementAt
(
uint32_t
index
)
override
;
Element
*
GetFirstNamedElement
(
const
nsAString
&
aName
bool
&
aFound
)
override
;
void
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
override
;
protected
:
virtual
~
nsEmptyContentList
(
)
=
default
;
private
:
nsCOMPtr
<
nsINode
>
mRoot
;
}
;
struct
nsContentListKey
{
nsContentListKey
(
nsINode
*
aRootNode
int32_t
aMatchNameSpaceId
const
nsAString
&
aTagname
bool
aIsHTMLDocument
)
:
mRootNode
(
aRootNode
)
mMatchNameSpaceId
(
aMatchNameSpaceId
)
mTagname
(
aTagname
)
mIsHTMLDocument
(
aIsHTMLDocument
)
mHash
(
mozilla
:
:
AddToHash
(
mozilla
:
:
HashString
(
aTagname
)
mRootNode
mMatchNameSpaceId
mIsHTMLDocument
)
)
{
}
nsContentListKey
(
const
nsContentListKey
&
aContentListKey
)
=
default
;
inline
uint32_t
GetHash
(
void
)
const
{
return
mHash
;
}
nsINode
*
const
mRootNode
;
const
int32_t
mMatchNameSpaceId
;
const
nsAString
&
mTagname
;
bool
mIsHTMLDocument
;
const
uint32_t
mHash
;
}
;
class
nsContentList
:
public
nsBaseContentList
public
nsIHTMLCollection
public
nsStubMutationObserver
{
protected
:
enum
class
State
:
uint8_t
{
UpToDate
=
0
Dirty
Lazy
}
;
public
:
NS_DECL_ISUPPORTS_INHERITED
nsContentList
(
nsINode
*
aRootNode
int32_t
aMatchNameSpaceId
nsAtom
*
aHTMLMatchAtom
nsAtom
*
aXMLMatchAtom
bool
aDeep
=
true
bool
aLiveList
=
true
)
;
nsContentList
(
nsINode
*
aRootNode
nsContentListMatchFunc
aFunc
nsContentListDestroyFunc
aDestroyFunc
void
*
aData
bool
aDeep
=
true
nsAtom
*
aMatchAtom
=
nullptr
int32_t
aMatchNameSpaceId
=
kNameSpaceID_None
bool
aFuncMayDependOnAttr
=
true
bool
aLiveList
=
true
)
;
using
nsWrapperCache
:
:
GetWrapperPreserveColor
;
using
nsWrapperCache
:
:
PreserveWrapper
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
protected
:
virtual
~
nsContentList
(
)
;
JSObject
*
GetWrapperPreserveColorInternal
(
)
override
{
return
nsWrapperCache
:
:
GetWrapperPreserveColor
(
)
;
}
void
PreserveWrapperInternal
(
nsISupports
*
aScriptObjectHolder
)
override
{
nsWrapperCache
:
:
PreserveWrapper
(
aScriptObjectHolder
)
;
}
public
:
int32_t
IndexOf
(
nsIContent
*
aContent
bool
aDoFlush
)
override
;
int32_t
IndexOf
(
nsIContent
*
aContent
)
override
;
nsINode
*
GetParentObject
(
)
override
{
return
mRootNode
;
}
uint32_t
Length
(
)
final
{
return
Length
(
true
)
;
}
nsIContent
*
Item
(
uint32_t
aIndex
)
final
;
Element
*
GetElementAt
(
uint32_t
index
)
override
;
Element
*
GetFirstNamedElement
(
const
nsAString
&
aName
bool
&
aFound
)
override
{
Element
*
item
=
NamedItem
(
aName
true
)
;
aFound
=
!
!
item
;
return
item
;
}
void
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
override
;
uint32_t
Length
(
bool
aDoFlush
)
;
nsIContent
*
Item
(
uint32_t
aIndex
bool
aDoFlush
)
;
Element
*
NamedItem
(
const
nsAString
&
aName
bool
aDoFlush
)
;
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
static
nsContentList
*
FromSupports
(
nsISupports
*
aSupports
)
{
nsINodeList
*
list
=
static_cast
<
nsINodeList
*
>
(
aSupports
)
;
#
ifdef
DEBUG
{
nsCOMPtr
<
nsINodeList
>
list_qi
=
do_QueryInterface
(
aSupports
)
;
NS_ASSERTION
(
list_qi
=
=
list
"
Uh
fix
QI
!
"
)
;
}
#
endif
return
static_cast
<
nsContentList
*
>
(
list
)
;
}
bool
MatchesKey
(
const
nsContentListKey
&
aKey
)
const
{
MOZ_ASSERT
(
mXMLMatchAtom
"
How
did
we
get
here
with
a
null
match
atom
on
our
list
?
"
)
;
return
mXMLMatchAtom
-
>
Equals
(
aKey
.
mTagname
)
&
&
mRootNode
=
=
aKey
.
mRootNode
&
&
mMatchNameSpaceId
=
=
aKey
.
mMatchNameSpaceId
&
&
mIsHTMLDocument
=
=
aKey
.
mIsHTMLDocument
;
}
void
SetDirty
(
)
{
mState
=
State
:
:
Dirty
;
InvalidateNamedItemsCache
(
)
;
Reset
(
)
;
}
void
LastRelease
(
)
override
;
protected
:
using
NamedItemsCache
=
nsTHashMap
<
RefPtr
<
nsAtom
>
Element
*
>
;
void
InvalidateNamedItemsCache
(
)
{
mNamedItemsCache
=
nullptr
;
mNamedItemsCacheValid
=
false
;
}
inline
void
InsertElementInNamedItemsCache
(
nsIContent
&
)
;
inline
void
InvalidateNamedItemsCacheForAttributeChange
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
;
inline
void
InvalidateNamedItemsCacheForInsertion
(
Element
&
)
;
inline
void
InvalidateNamedItemsCacheForDeletion
(
Element
&
)
;
void
EnsureNamedItemsCacheValid
(
bool
aDoFlush
)
;
bool
Match
(
Element
*
aElement
)
;
bool
MatchSelf
(
nsIContent
*
aContent
)
;
virtual
void
PopulateSelf
(
uint32_t
aNeededLength
uint32_t
aExpectedElementsIfDirty
=
0
)
;
bool
MayContainRelevantNodes
(
nsINode
*
aContainer
)
{
return
mDeep
|
|
aContainer
=
=
mRootNode
;
}
void
RemoveFromHashtable
(
)
;
inline
void
BringSelfUpToDate
(
bool
aDoFlush
)
;
void
RemoveFromCaches
(
)
override
{
RemoveFromHashtable
(
)
;
}
nsINode
*
mRootNode
;
int32_t
mMatchNameSpaceId
;
RefPtr
<
nsAtom
>
mHTMLMatchAtom
;
RefPtr
<
nsAtom
>
mXMLMatchAtom
;
nsContentListMatchFunc
mFunc
=
nullptr
;
nsContentListDestroyFunc
mDestroyFunc
=
nullptr
;
void
*
mData
=
nullptr
;
mozilla
:
:
UniquePtr
<
NamedItemsCache
>
mNamedItemsCache
;
State
mState
;
bool
mMatchAll
:
1
;
bool
mDeep
:
1
;
bool
mFuncMayDependOnAttr
:
1
;
bool
mFlushesNeeded
:
1
;
bool
mIsHTMLDocument
:
1
;
bool
mNamedItemsCacheValid
:
1
;
const
bool
mIsLiveList
:
1
;
#
ifdef
DEBUG_CONTENT_LIST
void
AssertInSync
(
)
;
#
endif
}
;
class
nsCacheableFuncStringContentList
;
class
MOZ_STACK_CLASS
nsFuncStringCacheKey
{
public
:
nsFuncStringCacheKey
(
nsINode
*
aRootNode
nsContentListMatchFunc
aFunc
const
nsAString
&
aString
)
:
mRootNode
(
aRootNode
)
mFunc
(
aFunc
)
mString
(
aString
)
{
}
uint32_t
GetHash
(
void
)
const
{
uint32_t
hash
=
mozilla
:
:
HashString
(
mString
)
;
return
mozilla
:
:
AddToHash
(
hash
mRootNode
mFunc
)
;
}
private
:
friend
class
nsCacheableFuncStringContentList
;
nsINode
*
const
mRootNode
;
const
nsContentListMatchFunc
mFunc
;
const
nsAString
&
mString
;
}
;
class
nsCacheableFuncStringContentList
:
public
nsContentList
{
public
:
virtual
~
nsCacheableFuncStringContentList
(
)
;
bool
Equals
(
const
nsFuncStringCacheKey
*
aKey
)
{
return
mRootNode
=
=
aKey
-
>
mRootNode
&
&
mFunc
=
=
aKey
-
>
mFunc
&
&
mString
=
=
aKey
-
>
mString
;
}
enum
ContentListType
{
eNodeList
eHTMLCollection
}
;
#
ifdef
DEBUG
ContentListType
mType
;
#
endif
protected
:
nsCacheableFuncStringContentList
(
nsINode
*
aRootNode
nsContentListMatchFunc
aFunc
nsContentListDestroyFunc
aDestroyFunc
nsFuncStringContentListDataAllocator
aDataAllocator
const
nsAString
&
aString
mozilla
:
:
DebugOnly
<
ContentListType
>
aType
)
:
nsContentList
(
aRootNode
aFunc
aDestroyFunc
nullptr
)
#
ifdef
DEBUG
mType
(
aType
)
#
endif
mString
(
aString
)
{
mData
=
(
*
aDataAllocator
)
(
aRootNode
&
mString
)
;
MOZ_ASSERT
(
mData
)
;
}
void
RemoveFromCaches
(
)
override
{
RemoveFromFuncStringHashtable
(
)
;
}
void
RemoveFromFuncStringHashtable
(
)
;
nsString
mString
;
}
;
class
nsCachableElementsByNameNodeList
:
public
nsCacheableFuncStringContentList
{
public
:
nsCachableElementsByNameNodeList
(
nsINode
*
aRootNode
nsContentListMatchFunc
aFunc
nsContentListDestroyFunc
aDestroyFunc
nsFuncStringContentListDataAllocator
aDataAllocator
const
nsAString
&
aString
)
:
nsCacheableFuncStringContentList
(
aRootNode
aFunc
aDestroyFunc
aDataAllocator
aString
eNodeList
)
{
}
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
#
ifdef
DEBUG
static
const
ContentListType
sType
;
#
endif
}
;
class
nsCacheableFuncStringHTMLCollection
:
public
nsCacheableFuncStringContentList
{
public
:
nsCacheableFuncStringHTMLCollection
(
nsINode
*
aRootNode
nsContentListMatchFunc
aFunc
nsContentListDestroyFunc
aDestroyFunc
nsFuncStringContentListDataAllocator
aDataAllocator
const
nsAString
&
aString
)
:
nsCacheableFuncStringContentList
(
aRootNode
aFunc
aDestroyFunc
aDataAllocator
aString
eHTMLCollection
)
{
}
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
#
ifdef
DEBUG
static
const
ContentListType
sType
;
#
endif
}
;
class
nsLabelsNodeList
final
:
public
nsContentList
{
public
:
nsLabelsNodeList
(
nsINode
*
aRootNode
nsContentListMatchFunc
aFunc
nsContentListDestroyFunc
aDestroyFunc
void
*
aData
)
:
nsContentList
(
aRootNode
aFunc
aDestroyFunc
aData
)
{
}
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
MaybeResetRoot
(
nsINode
*
aRootNode
)
;
private
:
void
PopulateSelf
(
uint32_t
aNeededLength
uint32_t
aExpectedElementsIfDirty
=
0
)
override
;
}
;
#
endif
