#
ifndef
mozilla_dom_EventSource_h
#
define
mozilla_dom_EventSource_h
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
class
nsIGlobalObject
;
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
struct
EventSourceInit
;
class
EventSourceImpl
;
class
EventSource
final
:
public
DOMEventTargetHelper
{
friend
class
EventSourceImpl
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
EventSource
DOMEventTargetHelper
)
virtual
bool
IsCertainlyAliveForCC
(
)
const
override
;
void
DisconnectFromOwner
(
)
override
{
DOMEventTargetHelper
:
:
DisconnectFromOwner
(
)
;
Close
(
)
;
}
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
already_AddRefed
<
EventSource
>
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aURL
const
EventSourceInit
&
aEventSourceInitDict
ErrorResult
&
aRv
)
;
void
GetUrl
(
nsAString
&
aURL
)
const
{
AssertIsOnTargetThread
(
)
;
aURL
=
mOriginalURL
;
}
bool
WithCredentials
(
)
const
{
AssertIsOnTargetThread
(
)
;
return
mWithCredentials
;
}
uint16_t
ReadyState
(
)
const
{
AssertIsOnTargetThread
(
)
;
return
mReadyState
;
}
IMPL_EVENT_HANDLER
(
open
)
IMPL_EVENT_HANDLER
(
message
)
IMPL_EVENT_HANDLER
(
error
)
void
Close
(
)
;
private
:
EventSource
(
nsIGlobalObject
*
aGlobal
nsICookieJarSettings
*
aCookieJarSettings
bool
aWithCredentials
)
;
virtual
~
EventSource
(
)
;
EventSource
(
const
EventSource
&
x
)
=
delete
;
EventSource
&
operator
=
(
const
EventSource
&
x
)
=
delete
;
void
AssertIsOnTargetThread
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
=
=
mIsMainThread
)
;
}
nsresult
CreateAndDispatchSimpleEvent
(
const
nsAString
&
aName
)
;
RefPtr
<
EventSourceImpl
>
mESImpl
;
nsString
mOriginalURL
;
Atomic
<
uint32_t
>
mReadyState
;
const
bool
mWithCredentials
;
const
bool
mIsMainThread
;
}
;
}
}
#
endif
