#
ifndef
mozilla_RangeBoundary_h
#
define
mozilla_RangeBoundary_h
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
class
nsRange
;
namespace
mozilla
{
namespace
dom
{
class
CrossShadowBoundaryRange
;
}
template
<
typename
T
typename
U
>
class
EditorDOMPointBase
;
template
<
typename
ParentType
typename
RefType
>
class
RangeBoundaryBase
;
using
RangeBoundary
=
RangeBoundaryBase
<
nsCOMPtr
<
nsINode
>
nsCOMPtr
<
nsIContent
>
>
;
using
RawRangeBoundary
=
RangeBoundaryBase
<
nsINode
*
nsIContent
*
>
;
using
ConstRawRangeBoundary
=
RangeBoundaryBase
<
const
nsINode
*
const
nsIContent
*
>
;
enum
class
RangeBoundaryIsMutationObserved
{
No
=
0
Yes
=
1
}
;
template
<
typename
ParentType
typename
RefType
>
class
RangeBoundaryBase
{
template
<
typename
T
typename
U
>
friend
class
RangeBoundaryBase
;
template
<
typename
T
typename
U
>
friend
class
EditorDOMPointBase
;
friend
nsRange
;
friend
class
mozilla
:
:
dom
:
:
CrossShadowBoundaryRange
;
friend
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
RangeBoundary
&
const
char
*
uint32_t
)
;
friend
void
ImplCycleCollectionUnlink
(
RangeBoundary
&
)
;
static
const
uint32_t
kFallbackOffset
=
0
;
template
<
typename
T
typename
Enable
=
void
>
struct
GetNodeType
;
template
<
typename
T
>
struct
GetNodeType
<
T
std
:
:
enable_if_t
<
std
:
:
is_pointer_v
<
T
>
>
>
{
using
type
=
std
:
:
remove_pointer_t
<
T
>
;
}
;
template
<
typename
T
>
struct
GetNodeType
<
T
std
:
:
enable_if_t
<
!
std
:
:
is_pointer_v
<
T
>
>
>
{
using
type
=
typename
T
:
:
element_type
;
}
;
public
:
using
RawParentType
=
typename
GetNodeType
<
ParentType
>
:
:
type
;
static_assert
(
std
:
:
is_same_v
<
RawParentType
nsINode
>
|
|
std
:
:
is_same_v
<
RawParentType
const
nsINode
>
)
;
using
RawRefType
=
typename
GetNodeType
<
RefType
>
:
:
type
;
static_assert
(
std
:
:
is_same_v
<
RawRefType
nsIContent
>
|
|
std
:
:
is_same_v
<
RawRefType
const
nsIContent
>
)
;
RangeBoundaryBase
(
RawParentType
*
aContainer
RawRefType
*
aRef
)
:
mParent
(
aContainer
)
mRef
(
aRef
)
mIsMutationObserved
(
true
)
{
if
(
mRef
)
{
NS_WARNING_ASSERTION
(
mRef
-
>
GetParentNode
(
)
=
=
mParent
"
Initializing
RangeBoundary
with
invalid
value
"
)
;
}
else
{
mOffset
.
emplace
(
0
)
;
}
}
RangeBoundaryBase
(
RawParentType
*
aContainer
uint32_t
aOffset
RangeBoundaryIsMutationObserved
aRangeIsMutationObserver
=
RangeBoundaryIsMutationObserved
:
:
Yes
)
:
mParent
(
aContainer
)
mRef
(
nullptr
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
mIsMutationObserved
(
bool
(
aRangeIsMutationObserver
)
)
{
if
(
mIsMutationObserved
&
&
mParent
&
&
mParent
-
>
IsContainerNode
(
)
)
{
if
(
aOffset
=
=
mParent
-
>
GetChildCount
(
)
)
{
mRef
=
mParent
-
>
GetLastChild
(
)
;
}
else
if
(
aOffset
>
0
)
{
mRef
=
mParent
-
>
GetChildAt_Deprecated
(
aOffset
-
1
)
;
}
NS_WARNING_ASSERTION
(
mRef
|
|
aOffset
=
=
0
"
Constructing
RangeBoundary
with
invalid
value
"
)
;
}
NS_WARNING_ASSERTION
(
!
mRef
|
|
mRef
-
>
GetParentNode
(
)
=
=
mParent
"
Constructing
RangeBoundary
with
invalid
value
"
)
;
}
RangeBoundaryBase
(
RawParentType
*
aContainer
RawRefType
*
aRef
uint32_t
aOffset
RangeBoundaryIsMutationObserved
aRangeIsMutationObserver
=
RangeBoundaryIsMutationObserved
:
:
Yes
)
:
mParent
(
const_cast
<
nsINode
*
>
(
aContainer
)
)
mRef
(
const_cast
<
nsIContent
*
>
(
aRef
)
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
mIsMutationObserved
(
bool
(
aRangeIsMutationObserver
)
)
{
MOZ_ASSERT
(
IsSetAndValid
(
)
)
;
}
RangeBoundaryBase
(
)
:
mParent
(
nullptr
)
mRef
(
nullptr
)
mIsMutationObserved
(
true
)
{
}
template
<
typename
PT
typename
RT
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_const_v
<
RawParentType
>
|
|
std
:
:
is_const_v
<
PT
>
>
>
RangeBoundaryBase
(
const
RangeBoundaryBase
<
PT
RT
>
&
aOther
RangeBoundaryIsMutationObserved
aIsMutationObserved
)
:
mParent
(
aOther
.
mParent
)
mRef
(
aOther
.
mRef
)
mOffset
(
aOther
.
mOffset
)
mIsMutationObserved
(
bool
(
aIsMutationObserved
)
)
{
}
RawRefType
*
Ref
(
)
const
{
if
(
mIsMutationObserved
)
{
return
mRef
;
}
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mOffset
)
;
if
(
*
mOffset
>
Container
(
)
-
>
Length
(
)
)
{
mRef
=
nullptr
;
}
else
if
(
*
mOffset
=
=
Container
(
)
-
>
Length
(
)
)
{
mRef
=
mParent
-
>
GetLastChild
(
)
;
}
else
if
(
*
mOffset
)
{
auto
indexOfRefObject
=
mParent
-
>
ComputeIndexOf
(
mRef
)
;
if
(
indexOfRefObject
.
isNothing
(
)
|
|
*
mOffset
!
=
*
indexOfRefObject
+
1
)
{
mRef
=
mParent
-
>
GetChildAt_Deprecated
(
*
mOffset
-
1
)
;
}
}
else
{
mRef
=
nullptr
;
}
return
mRef
;
}
RawParentType
*
Container
(
)
const
{
return
mParent
;
}
dom
:
:
Document
*
GetComposedDoc
(
)
const
{
return
mParent
?
mParent
-
>
GetComposedDoc
(
)
:
nullptr
;
}
RawRefType
*
GetChildAtOffset
(
)
const
{
if
(
!
mParent
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
return
nullptr
;
}
RawRefType
*
const
ref
=
Ref
(
)
;
if
(
!
ref
)
{
if
(
!
mIsMutationObserved
&
&
*
mOffset
!
=
0
)
{
return
nullptr
;
}
MOZ_ASSERT
(
*
Offset
(
OffsetFilter
:
:
kValidOrInvalidOffsets
)
=
=
0
"
invalid
RangeBoundary
"
)
;
return
mParent
-
>
GetFirstChild
(
)
;
}
MOZ_ASSERT
(
mParent
-
>
GetChildAt_Deprecated
(
*
Offset
(
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
=
=
ref
-
>
GetNextSibling
(
)
)
;
return
ref
-
>
GetNextSibling
(
)
;
}
RawRefType
*
GetNextSiblingOfChildAtOffset
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
RawRefType
*
const
ref
=
Ref
(
)
;
if
(
!
ref
)
{
if
(
!
mIsMutationObserved
&
&
*
mOffset
!
=
0
)
{
return
nullptr
;
}
MOZ_ASSERT
(
*
Offset
(
OffsetFilter
:
:
kValidOffsets
)
=
=
0
"
invalid
RangeBoundary
"
)
;
nsIContent
*
firstChild
=
mParent
-
>
GetFirstChild
(
)
;
if
(
NS_WARN_IF
(
!
firstChild
)
)
{
return
nullptr
;
}
return
firstChild
-
>
GetNextSibling
(
)
;
}
if
(
NS_WARN_IF
(
!
ref
-
>
GetNextSibling
(
)
)
)
{
return
nullptr
;
}
return
ref
-
>
GetNextSibling
(
)
-
>
GetNextSibling
(
)
;
}
RawRefType
*
GetPreviousSiblingOfChildAtOffset
(
)
const
{
if
(
NS_WARN_IF
(
!
mParent
)
|
|
NS_WARN_IF
(
!
mParent
-
>
IsContainerNode
(
)
)
)
{
return
nullptr
;
}
RawRefType
*
const
ref
=
Ref
(
)
;
if
(
NS_WARN_IF
(
!
ref
)
)
{
return
nullptr
;
}
return
ref
;
}
[
[
nodiscard
]
]
bool
HasOffset
(
)
const
{
return
mOffset
.
isSome
(
)
;
}
enum
class
OffsetFilter
{
kValidOffsets
kValidOrInvalidOffsets
}
;
Maybe
<
uint32_t
>
Offset
(
const
OffsetFilter
aOffsetFilter
)
const
{
switch
(
aOffsetFilter
)
{
case
OffsetFilter
:
:
kValidOffsets
:
{
if
(
IsSetAndValid
(
)
)
{
MOZ_ASSERT_IF
(
!
mIsMutationObserved
mOffset
)
;
if
(
!
mOffset
&
&
mIsMutationObserved
)
{
DetermineOffsetFromReference
(
)
;
}
}
return
!
mIsMutationObserved
&
&
*
mOffset
>
Container
(
)
-
>
Length
(
)
?
Nothing
{
}
:
mOffset
;
}
case
OffsetFilter
:
:
kValidOrInvalidOffsets
:
{
MOZ_ASSERT_IF
(
!
mIsMutationObserved
mOffset
.
isSome
(
)
)
;
if
(
mOffset
.
isSome
(
)
)
{
return
mOffset
;
}
if
(
mParent
&
&
mIsMutationObserved
)
{
DetermineOffsetFromReference
(
)
;
if
(
mOffset
.
isSome
(
)
)
{
return
mOffset
;
}
}
return
Some
(
kFallbackOffset
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
)
;
return
Some
(
kFallbackOffset
)
;
}
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
RangeBoundaryBase
<
ParentType
RefType
>
&
aRangeBoundary
)
{
aStream
<
<
"
{
mParent
=
"
<
<
aRangeBoundary
.
Container
(
)
;
if
(
aRangeBoundary
.
Container
(
)
)
{
aStream
<
<
"
(
"
<
<
*
aRangeBoundary
.
Container
(
)
<
<
"
Length
(
)
=
"
<
<
aRangeBoundary
.
Container
(
)
-
>
Length
(
)
<
<
"
)
"
;
}
if
(
aRangeBoundary
.
mIsMutationObserved
)
{
aStream
<
<
"
mRef
=
"
<
<
aRangeBoundary
.
mRef
;
if
(
aRangeBoundary
.
mRef
)
{
aStream
<
<
"
(
"
<
<
*
aRangeBoundary
.
mRef
<
<
"
)
"
;
}
}
aStream
<
<
"
mOffset
=
"
<
<
aRangeBoundary
.
mOffset
;
aStream
<
<
"
mIsMutationObserved
=
"
<
<
(
aRangeBoundary
.
mIsMutationObserved
?
"
true
"
:
"
false
"
)
<
<
"
}
"
;
return
aStream
;
}
private
:
void
DetermineOffsetFromReference
(
)
const
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mRef
)
;
MOZ_ASSERT
(
mRef
-
>
GetParentNode
(
)
=
=
mParent
)
;
MOZ_ASSERT
(
mIsMutationObserved
)
;
MOZ_ASSERT
(
mOffset
.
isNothing
(
)
)
;
if
(
mRef
-
>
IsBeingRemoved
(
)
)
{
return
;
}
const
Maybe
<
uint32_t
>
index
=
mParent
-
>
ComputeIndexOf
(
mRef
)
;
MOZ_ASSERT
(
*
index
!
=
UINT32_MAX
)
;
mOffset
.
emplace
(
MOZ_LIKELY
(
index
.
isSome
(
)
)
?
*
index
+
1u
:
0u
)
;
}
void
InvalidateOffset
(
)
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mParent
-
>
IsContainerNode
(
)
"
Range
is
positioned
on
a
text
node
!
"
)
;
if
(
!
mIsMutationObserved
)
{
return
;
}
if
(
!
mRef
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
=
=
0
"
Invalidating
offset
of
invalid
RangeBoundary
?
"
)
;
return
;
}
mOffset
.
reset
(
)
;
}
public
:
void
NotifyParentBecomesShadowHost
(
)
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mParent
-
>
IsContainerNode
(
)
"
Range
is
positioned
on
a
text
node
!
"
)
;
if
(
!
StaticPrefs
:
:
dom_shadowdom_selection_across_boundary_enabled
(
)
)
{
return
;
}
if
(
!
mIsMutationObserved
)
{
return
;
}
if
(
!
mRef
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
=
=
0
"
Invalidating
offset
of
invalid
RangeBoundary
?
"
)
;
return
;
}
if
(
dom
:
:
ShadowRoot
*
shadowRoot
=
mParent
-
>
GetShadowRootForSelection
(
)
)
{
mParent
=
shadowRoot
;
}
mOffset
=
Some
(
0
)
;
}
bool
IsSet
(
)
const
{
return
mParent
&
&
(
mRef
|
|
mOffset
.
isSome
(
)
)
;
}
[
[
nodiscard
]
]
bool
IsSetAndInComposedDoc
(
)
const
{
return
IsSet
(
)
&
&
mParent
-
>
IsInComposedDoc
(
)
;
}
bool
IsSetAndValid
(
)
const
{
if
(
!
IsSet
(
)
)
{
return
false
;
}
if
(
mIsMutationObserved
&
&
Ref
(
)
)
{
return
Ref
(
)
-
>
GetParentNode
(
)
=
=
Container
(
)
&
&
!
Ref
(
)
-
>
IsBeingRemoved
(
)
;
}
MOZ_ASSERT
(
mOffset
.
isSome
(
)
)
;
return
*
mOffset
<
=
Container
(
)
-
>
Length
(
)
;
}
bool
IsStartOfContainer
(
)
const
{
return
mIsMutationObserved
?
!
Ref
(
)
&
&
mOffset
.
value
(
)
=
=
0
:
mOffset
.
value
(
)
=
=
0
;
}
bool
IsEndOfContainer
(
)
const
{
return
mIsMutationObserved
&
&
Ref
(
)
?
!
Ref
(
)
-
>
GetNextSibling
(
)
:
mOffset
.
value
(
)
=
=
Container
(
)
-
>
Length
(
)
;
}
template
<
typename
PT
=
RawParentType
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_const_v
<
PT
>
>
>
RawRangeBoundary
AsRaw
(
)
const
{
return
RawRangeBoundary
(
*
this
RangeBoundaryIsMutationObserved
(
mIsMutationObserved
)
)
;
}
ConstRawRangeBoundary
AsConstRaw
(
)
const
{
return
ConstRawRangeBoundary
(
*
this
RangeBoundaryIsMutationObserved
(
mIsMutationObserved
)
)
;
}
template
<
typename
A
typename
B
>
RangeBoundaryBase
&
operator
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
=
delete
;
template
<
typename
PT
typename
RT
typename
RPT
=
RawParentType
typename
=
std
:
:
enable_if_t
<
!
std
:
:
is_const_v
<
PT
>
|
|
std
:
:
is_const_v
<
RPT
>
>
>
RangeBoundaryBase
&
CopyFrom
(
const
RangeBoundaryBase
<
PT
RT
>
&
aOther
RangeBoundaryIsMutationObserved
aIsMutationObserved
)
{
if
(
mParent
!
=
aOther
.
mParent
)
{
mParent
=
aOther
.
mParent
;
}
if
(
mRef
!
=
aOther
.
mRef
)
{
mRef
=
aOther
.
mRef
;
}
mIsMutationObserved
=
bool
(
aIsMutationObserved
)
;
if
(
!
mIsMutationObserved
&
&
aOther
.
mOffset
.
isNothing
(
)
)
{
mOffset
=
aOther
.
Offset
(
RangeBoundaryBase
<
PT
RT
>
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mOffset
.
isSome
(
)
)
;
}
else
{
mOffset
=
aOther
.
mOffset
;
}
return
*
this
;
}
bool
Equals
(
const
RawParentType
*
aNode
uint32_t
aOffset
)
const
{
if
(
mParent
!
=
aNode
)
{
return
false
;
}
const
Maybe
<
uint32_t
>
offset
=
Offset
(
OffsetFilter
:
:
kValidOffsets
)
;
return
offset
&
&
(
*
offset
=
=
aOffset
)
;
}
template
<
typename
A
typename
B
>
bool
operator
=
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
const
{
return
mParent
=
=
aOther
.
mParent
&
&
(
mIsMutationObserved
&
&
aOther
.
mIsMutationObserved
&
&
mRef
?
mRef
=
=
aOther
.
mRef
:
Offset
(
OffsetFilter
:
:
kValidOrInvalidOffsets
)
=
=
aOther
.
Offset
(
RangeBoundaryBase
<
A
B
>
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
;
}
template
<
typename
A
typename
B
>
bool
operator
!
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
ParentType
mParent
;
mutable
RefType
mRef
;
mutable
mozilla
:
:
Maybe
<
uint32_t
>
mOffset
;
bool
mIsMutationObserved
;
}
;
template
<
typename
ParentType
typename
RefType
>
const
uint32_t
RangeBoundaryBase
<
ParentType
RefType
>
:
:
kFallbackOffset
;
inline
void
ImplCycleCollectionUnlink
(
RangeBoundary
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mParent
)
;
ImplCycleCollectionUnlink
(
aField
.
mRef
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
RangeBoundary
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mParent
"
mParent
"
0
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mRef
"
mRef
"
0
)
;
}
}
#
endif
