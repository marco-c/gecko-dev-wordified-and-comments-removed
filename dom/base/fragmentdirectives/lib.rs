use
nsstring
:
:
{
nsCString
nsString
}
;
use
thin_vec
:
:
ThinVec
;
pub
mod
fragment_directive_impl
;
mod
test
;
#
[
repr
(
C
)
]
pub
struct
TextDirective
{
prefix
:
nsString
start
:
nsString
end
:
nsString
suffix
:
nsString
}
impl
TextDirective
{
fn
from_rust_type
(
element
:
&
fragment_directive_impl
:
:
TextDirective
)
-
>
Self
{
Self
{
prefix
:
element
.
prefix
(
)
.
as_ref
(
)
.
map_or_else
(
nsString
:
:
new
|
token
|
nsString
:
:
from
(
token
.
value
(
)
)
)
start
:
element
.
start
(
)
.
as_ref
(
)
.
map_or_else
(
nsString
:
:
new
|
token
|
nsString
:
:
from
(
token
.
value
(
)
)
)
end
:
element
.
end
(
)
.
as_ref
(
)
.
map_or_else
(
nsString
:
:
new
|
token
|
nsString
:
:
from
(
token
.
value
(
)
)
)
suffix
:
element
.
suffix
(
)
.
as_ref
(
)
.
map_or_else
(
nsString
:
:
new
|
token
|
nsString
:
:
from
(
token
.
value
(
)
)
)
}
}
fn
to_rust_type
(
&
self
)
-
>
Option
<
fragment_directive_impl
:
:
TextDirective
>
{
fragment_directive_impl
:
:
TextDirective
:
:
from_parts
(
self
.
prefix
.
to_string
(
)
self
.
start
.
to_string
(
)
self
.
end
.
to_string
(
)
self
.
suffix
.
to_string
(
)
)
}
}
#
[
repr
(
C
)
]
pub
struct
ParsedFragmentDirectiveResult
{
hash_without_fragment_directive
:
nsCString
fragment_directive
:
nsCString
text_directives
:
ThinVec
<
TextDirective
>
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
parse_fragment_directive
(
hash
:
&
nsCString
result
:
&
mut
ParsedFragmentDirectiveResult
)
-
>
bool
{
result
.
hash_without_fragment_directive
=
nsCString
:
:
new
(
)
;
result
.
fragment_directive
=
nsCString
:
:
new
(
)
;
result
.
text_directives
.
clear
(
)
;
let
url_as_rust_string
=
hash
.
to_utf8
(
)
;
if
let
Some
(
(
stripped_hash
fragment_directive
text_directives
)
)
=
fragment_directive_impl
:
:
parse_fragment_directive_and_remove_it_from_hash
(
&
url_as_rust_string
)
{
result
.
hash_without_fragment_directive
.
assign
(
&
stripped_hash
)
;
result
.
fragment_directive
.
assign
(
&
fragment_directive
)
;
result
.
text_directives
.
extend
(
text_directives
.
iter
(
)
.
map
(
|
text_directive
|
TextDirective
:
:
from_rust_type
(
text_directive
)
)
)
;
return
true
;
}
false
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
create_fragment_directive
(
text_directives
:
&
ThinVec
<
TextDirective
>
fragment_directive
:
&
mut
nsCString
)
-
>
bool
{
let
directives_rust
=
Vec
:
:
from_iter
(
text_directives
.
iter
(
)
.
filter_map
(
|
fragment
|
fragment
.
to_rust_type
(
)
)
)
;
if
let
Some
(
fragment_directive_rust
)
=
fragment_directive_impl
:
:
create_fragment_directive_string
(
&
directives_rust
)
{
fragment_directive
.
assign
(
&
fragment_directive_rust
)
;
return
true
;
}
false
}
#
[
no_mangle
]
pub
extern
"
C
"
fn
create_text_directive
(
text_directive
:
&
TextDirective
directive_string
:
&
mut
nsCString
)
-
>
bool
{
if
let
Some
(
text_directive_rust
)
=
text_directive
.
to_rust_type
(
)
{
if
let
Some
(
text_directive_string_rust
)
=
fragment_directive_impl
:
:
create_text_directive_string
(
&
text_directive_rust
)
{
directive_string
.
assign
(
&
text_directive_string_rust
)
;
return
true
;
}
}
false
}
#
[
repr
(
C
)
]
pub
struct
TextDirectiveCandidateContents
<
'
a
>
{
full_prefix_content
:
&
'
a
nsString
full_start_content
:
&
'
a
nsString
full_end_content
:
&
'
a
nsString
full_suffix_content
:
&
'
a
nsString
prefix_content
:
&
'
a
nsString
start_content
:
&
'
a
nsString
end_content
:
&
'
a
nsString
suffix_content
:
&
'
a
nsString
use_exact_matching
:
bool
}
