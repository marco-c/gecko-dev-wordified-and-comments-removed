#
ifndef
ChildIterator_h
#
define
ChildIterator_h
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
<
stdint
.
h
>
class
nsIContent
;
namespace
mozilla
:
:
dom
{
class
FlattenedChildIterator
{
public
:
explicit
FlattenedChildIterator
(
const
nsIContent
*
aParent
bool
aStartAtBeginning
=
true
)
;
nsIContent
*
GetNextChild
(
)
;
bool
Seek
(
const
nsIContent
*
aChildToFind
)
;
nsIContent
*
Get
(
)
const
{
return
mChild
;
}
const
nsIContent
*
Parent
(
)
const
{
return
mOriginalParent
;
}
nsIContent
*
GetPreviousChild
(
)
;
bool
ShadowDOMInvolved
(
)
const
{
return
mShadowDOMInvolved
;
}
protected
:
const
nsIContent
*
mParent
;
const
HTMLSlotElement
*
mParentAsSlot
=
nullptr
;
const
nsIContent
*
mOriginalParent
=
nullptr
;
nsIContent
*
mChild
=
nullptr
;
bool
mIsFirst
=
false
;
uint32_t
mIndexInInserted
=
0u
;
bool
mShadowDOMInvolved
=
false
;
}
;
class
AllChildrenIterator
:
private
FlattenedChildIterator
{
public
:
AllChildrenIterator
(
const
nsIContent
*
aNode
uint32_t
aFlags
bool
aStartAtBeginning
=
true
)
:
FlattenedChildIterator
(
aNode
aStartAtBeginning
)
mAnonKidsIdx
(
aStartAtBeginning
?
UINT32_MAX
:
0
)
mFlags
(
aFlags
)
mPhase
(
aStartAtBeginning
?
eAtBegin
:
eAtEnd
)
{
}
#
ifdef
DEBUG
AllChildrenIterator
(
AllChildrenIterator
&
&
)
=
default
;
AllChildrenIterator
&
operator
=
(
AllChildrenIterator
&
&
aOther
)
{
this
-
>
~
AllChildrenIterator
(
)
;
new
(
this
)
AllChildrenIterator
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
~
AllChildrenIterator
(
)
{
MOZ_ASSERT
(
!
mMutationGuard
.
Mutated
(
0
)
)
;
}
#
endif
nsIContent
*
Get
(
)
const
;
bool
Seek
(
const
nsIContent
*
aChildToFind
)
;
nsIContent
*
GetNextChild
(
)
;
nsIContent
*
GetPreviousChild
(
)
;
enum
IteratorPhase
{
eAtBegin
eAtMarkerKid
eAtBeforeKid
eAtFlatTreeKids
eAtAnonKids
eAtAfterKid
eAtEnd
}
;
IteratorPhase
Phase
(
)
const
{
return
mPhase
;
}
private
:
void
AppendNativeAnonymousChildren
(
)
;
nsTArray
<
nsIContent
*
>
mAnonKids
;
uint32_t
mAnonKidsIdx
;
uint32_t
mFlags
;
IteratorPhase
mPhase
;
#
ifdef
DEBUG
nsMutationGuard
mMutationGuard
;
#
endif
}
;
class
MOZ_NEEDS_MEMMOVABLE_MEMBERS
StyleChildrenIterator
:
private
AllChildrenIterator
{
public
:
static
nsIContent
*
GetParent
(
const
nsIContent
&
aContent
)
{
nsINode
*
node
=
aContent
.
GetFlattenedTreeParentNodeForStyle
(
)
;
return
node
&
&
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
}
explicit
StyleChildrenIterator
(
const
nsIContent
*
aContent
bool
aStartAtBeginning
=
true
)
:
AllChildrenIterator
(
aContent
nsIContent
:
:
eAllChildren
|
nsIContent
:
:
eSkipDocumentLevelNativeAnonymousContent
aStartAtBeginning
)
{
MOZ_COUNT_CTOR
(
StyleChildrenIterator
)
;
}
StyleChildrenIterator
(
StyleChildrenIterator
&
&
aOther
)
:
AllChildrenIterator
(
std
:
:
move
(
aOther
)
)
{
MOZ_COUNT_CTOR
(
StyleChildrenIterator
)
;
}
StyleChildrenIterator
&
operator
=
(
StyleChildrenIterator
&
&
aOther
)
=
default
;
MOZ_COUNTED_DTOR
(
StyleChildrenIterator
)
using
AllChildrenIterator
:
:
GetNextChild
;
using
AllChildrenIterator
:
:
GetPreviousChild
;
using
AllChildrenIterator
:
:
Seek
;
}
;
}
#
endif
