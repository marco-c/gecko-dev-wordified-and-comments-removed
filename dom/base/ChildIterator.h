#
ifndef
ChildIterator_h
#
define
ChildIterator_h
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
<
stdint
.
h
>
class
nsIContent
;
namespace
mozilla
{
namespace
dom
{
class
ExplicitChildIterator
{
public
:
explicit
ExplicitChildIterator
(
const
nsIContent
*
aParent
bool
aStartAtBeginning
=
true
)
;
nsIContent
*
GetNextChild
(
)
;
bool
Seek
(
const
nsIContent
*
aChildToFind
)
;
bool
Seek
(
const
nsIContent
*
aChildToFind
nsIContent
*
aBound
)
{
nsIContent
*
child
;
do
{
child
=
GetNextChild
(
)
;
}
while
(
child
&
&
child
!
=
aChildToFind
&
&
child
!
=
aBound
)
;
return
child
=
=
aChildToFind
;
}
nsIContent
*
Get
(
)
const
;
nsIContent
*
GetPreviousChild
(
)
;
protected
:
const
nsIContent
*
mParent
;
const
HTMLSlotElement
*
mParentAsSlot
;
nsIContent
*
mChild
;
nsIContent
*
mDefaultChild
;
bool
mIsFirst
;
uint32_t
mIndexInInserted
;
}
;
class
FlattenedChildIterator
:
public
ExplicitChildIterator
{
public
:
explicit
FlattenedChildIterator
(
const
nsIContent
*
aParent
bool
aStartAtBeginning
=
true
)
:
ExplicitChildIterator
(
aParent
aStartAtBeginning
)
mOriginalContent
(
aParent
)
{
Init
(
)
;
}
bool
ShadowDOMInvolved
(
)
{
return
mShadowDOMInvolved
;
}
const
nsIContent
*
Parent
(
)
const
{
return
mOriginalContent
;
}
protected
:
const
nsIContent
*
mOriginalContent
;
private
:
void
Init
(
)
;
bool
mShadowDOMInvolved
=
false
;
}
;
class
AllChildrenIterator
:
private
FlattenedChildIterator
{
public
:
AllChildrenIterator
(
const
nsIContent
*
aNode
uint32_t
aFlags
bool
aStartAtBeginning
=
true
)
:
FlattenedChildIterator
(
aNode
aStartAtBeginning
)
mAnonKidsIdx
(
aStartAtBeginning
?
UINT32_MAX
:
0
)
mFlags
(
aFlags
)
mPhase
(
aStartAtBeginning
?
eAtBegin
:
eAtEnd
)
{
}
#
ifdef
DEBUG
AllChildrenIterator
(
AllChildrenIterator
&
&
)
=
default
;
AllChildrenIterator
&
operator
=
(
AllChildrenIterator
&
&
aOther
)
{
this
-
>
~
AllChildrenIterator
(
)
;
new
(
this
)
AllChildrenIterator
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
~
AllChildrenIterator
(
)
{
MOZ_ASSERT
(
!
mMutationGuard
.
Mutated
(
0
)
)
;
}
#
endif
nsIContent
*
Get
(
)
const
;
bool
Seek
(
const
nsIContent
*
aChildToFind
)
;
nsIContent
*
GetNextChild
(
)
;
nsIContent
*
GetPreviousChild
(
)
;
enum
IteratorPhase
{
eAtBegin
eAtMarkerKid
eAtBeforeKid
eAtExplicitKids
eAtAnonKids
eAtAfterKid
eAtEnd
}
;
IteratorPhase
Phase
(
)
const
{
return
mPhase
;
}
private
:
void
AppendNativeAnonymousChildren
(
)
;
nsTArray
<
nsIContent
*
>
mAnonKids
;
uint32_t
mAnonKidsIdx
;
uint32_t
mFlags
;
IteratorPhase
mPhase
;
#
ifdef
DEBUG
nsMutationGuard
mMutationGuard
;
#
endif
}
;
class
MOZ_NEEDS_MEMMOVABLE_MEMBERS
StyleChildrenIterator
:
private
AllChildrenIterator
{
public
:
static
nsIContent
*
GetParent
(
const
nsIContent
&
aContent
)
{
nsINode
*
node
=
aContent
.
GetFlattenedTreeParentNodeForStyle
(
)
;
return
node
&
&
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
}
explicit
StyleChildrenIterator
(
const
nsIContent
*
aContent
bool
aStartAtBeginning
=
true
)
:
AllChildrenIterator
(
aContent
nsIContent
:
:
eAllChildren
|
nsIContent
:
:
eSkipDocumentLevelNativeAnonymousContent
aStartAtBeginning
)
{
MOZ_COUNT_CTOR
(
StyleChildrenIterator
)
;
}
StyleChildrenIterator
(
StyleChildrenIterator
&
&
aOther
)
:
AllChildrenIterator
(
std
:
:
move
(
aOther
)
)
{
MOZ_COUNT_CTOR
(
StyleChildrenIterator
)
;
}
StyleChildrenIterator
&
operator
=
(
StyleChildrenIterator
&
&
aOther
)
=
default
;
MOZ_COUNTED_DTOR
(
StyleChildrenIterator
)
using
AllChildrenIterator
:
:
GetNextChild
;
using
AllChildrenIterator
:
:
GetPreviousChild
;
using
AllChildrenIterator
:
:
Seek
;
}
;
}
}
#
endif
