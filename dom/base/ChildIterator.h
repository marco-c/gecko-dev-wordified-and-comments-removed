#
ifndef
ChildIterator_h
#
define
ChildIterator_h
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
<
stdint
.
h
>
class
nsIContent
;
namespace
mozilla
{
namespace
dom
{
class
ExplicitChildIterator
{
public
:
explicit
ExplicitChildIterator
(
const
nsIContent
*
aParent
bool
aStartAtBeginning
=
true
)
;
ExplicitChildIterator
(
const
ExplicitChildIterator
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mParentAsSlot
(
aOther
.
mParentAsSlot
)
mChild
(
aOther
.
mChild
)
mDefaultChild
(
aOther
.
mDefaultChild
)
mIsFirst
(
aOther
.
mIsFirst
)
mIndexInInserted
(
aOther
.
mIndexInInserted
)
{
}
ExplicitChildIterator
(
ExplicitChildIterator
&
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mParentAsSlot
(
aOther
.
mParentAsSlot
)
mChild
(
aOther
.
mChild
)
mDefaultChild
(
aOther
.
mDefaultChild
)
mIsFirst
(
aOther
.
mIsFirst
)
mIndexInInserted
(
aOther
.
mIndexInInserted
)
{
}
nsIContent
*
GetNextChild
(
)
;
bool
Seek
(
const
nsIContent
*
aChildToFind
)
;
bool
Seek
(
const
nsIContent
*
aChildToFind
nsIContent
*
aBound
)
{
nsIContent
*
child
;
do
{
child
=
GetNextChild
(
)
;
}
while
(
child
&
&
child
!
=
aChildToFind
&
&
child
!
=
aBound
)
;
return
child
=
=
aChildToFind
;
}
nsIContent
*
Get
(
)
const
;
nsIContent
*
GetPreviousChild
(
)
;
protected
:
const
nsIContent
*
mParent
;
const
HTMLSlotElement
*
mParentAsSlot
;
nsIContent
*
mChild
;
nsIContent
*
mDefaultChild
;
bool
mIsFirst
;
uint32_t
mIndexInInserted
;
}
;
class
FlattenedChildIterator
:
public
ExplicitChildIterator
{
public
:
explicit
FlattenedChildIterator
(
const
nsIContent
*
aParent
bool
aStartAtBeginning
=
true
)
:
ExplicitChildIterator
(
aParent
aStartAtBeginning
)
mOriginalContent
(
aParent
)
{
Init
(
false
)
;
}
FlattenedChildIterator
(
FlattenedChildIterator
&
&
aOther
)
:
ExplicitChildIterator
(
std
:
:
move
(
aOther
)
)
mOriginalContent
(
aOther
.
mOriginalContent
)
mXBLInvolved
(
aOther
.
mXBLInvolved
)
{
}
FlattenedChildIterator
(
const
FlattenedChildIterator
&
aOther
)
:
ExplicitChildIterator
(
aOther
)
mOriginalContent
(
aOther
.
mOriginalContent
)
mXBLInvolved
(
aOther
.
mXBLInvolved
)
{
}
bool
XBLInvolved
(
)
{
if
(
mXBLInvolved
.
isNothing
(
)
)
{
mXBLInvolved
=
Some
(
ComputeWhetherXBLIsInvolved
(
)
)
;
}
return
*
mXBLInvolved
;
}
const
nsIContent
*
Parent
(
)
const
{
return
mOriginalContent
;
}
private
:
bool
ComputeWhetherXBLIsInvolved
(
)
const
;
void
Init
(
bool
aIgnoreXBL
)
;
protected
:
FlattenedChildIterator
(
const
nsIContent
*
aParent
uint32_t
aFlags
bool
aStartAtBeginning
=
true
)
:
ExplicitChildIterator
(
aParent
aStartAtBeginning
)
mOriginalContent
(
aParent
)
{
bool
ignoreXBL
=
aFlags
&
nsIContent
:
:
eAllButXBL
;
Init
(
ignoreXBL
)
;
}
const
nsIContent
*
mOriginalContent
;
private
:
Maybe
<
bool
>
mXBLInvolved
;
}
;
class
AllChildrenIterator
:
private
FlattenedChildIterator
{
public
:
AllChildrenIterator
(
const
nsIContent
*
aNode
uint32_t
aFlags
bool
aStartAtBeginning
=
true
)
:
FlattenedChildIterator
(
aNode
aFlags
aStartAtBeginning
)
mAnonKidsIdx
(
aStartAtBeginning
?
UINT32_MAX
:
0
)
mFlags
(
aFlags
)
mPhase
(
aStartAtBeginning
?
eAtBegin
:
eAtEnd
)
{
}
AllChildrenIterator
(
AllChildrenIterator
&
&
aOther
)
:
FlattenedChildIterator
(
std
:
:
move
(
aOther
)
)
mAnonKids
(
std
:
:
move
(
aOther
.
mAnonKids
)
)
mAnonKidsIdx
(
aOther
.
mAnonKidsIdx
)
mFlags
(
aOther
.
mFlags
)
mPhase
(
aOther
.
mPhase
)
#
ifdef
DEBUG
mMutationGuard
(
aOther
.
mMutationGuard
)
#
endif
{
}
AllChildrenIterator
&
operator
=
(
AllChildrenIterator
&
&
aOther
)
{
this
-
>
~
AllChildrenIterator
(
)
;
new
(
this
)
AllChildrenIterator
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
#
ifdef
DEBUG
~
AllChildrenIterator
(
)
{
MOZ_ASSERT
(
!
mMutationGuard
.
Mutated
(
0
)
)
;
}
#
endif
nsIContent
*
Get
(
)
const
;
bool
Seek
(
const
nsIContent
*
aChildToFind
)
;
nsIContent
*
GetNextChild
(
)
;
nsIContent
*
GetPreviousChild
(
)
;
enum
IteratorPhase
{
eAtBegin
eAtBeforeKid
eAtExplicitKids
eAtAnonKids
eAtAfterKid
eAtEnd
}
;
IteratorPhase
Phase
(
)
const
{
return
mPhase
;
}
private
:
void
AppendNativeAnonymousChildren
(
)
;
nsTArray
<
nsIContent
*
>
mAnonKids
;
uint32_t
mAnonKidsIdx
;
uint32_t
mFlags
;
IteratorPhase
mPhase
;
#
ifdef
DEBUG
nsMutationGuard
mMutationGuard
;
#
endif
}
;
class
MOZ_NEEDS_MEMMOVABLE_MEMBERS
StyleChildrenIterator
:
private
AllChildrenIterator
{
public
:
static
nsIContent
*
GetParent
(
const
nsIContent
&
aContent
)
{
nsINode
*
node
=
aContent
.
GetFlattenedTreeParentNodeForStyle
(
)
;
return
node
&
&
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
}
StyleChildrenIterator
(
const
nsIContent
*
aContent
bool
aStartAtBeginning
=
true
)
:
AllChildrenIterator
(
aContent
nsIContent
:
:
eAllChildren
|
nsIContent
:
:
eSkipDocumentLevelNativeAnonymousContent
aStartAtBeginning
)
{
MOZ_COUNT_CTOR
(
StyleChildrenIterator
)
;
}
StyleChildrenIterator
(
StyleChildrenIterator
&
&
aOther
)
:
AllChildrenIterator
(
std
:
:
move
(
aOther
)
)
{
MOZ_COUNT_CTOR
(
StyleChildrenIterator
)
;
}
StyleChildrenIterator
&
operator
=
(
StyleChildrenIterator
&
&
aOther
)
{
AllChildrenIterator
:
:
operator
=
(
std
:
:
move
(
aOther
)
)
;
return
*
this
;
}
~
StyleChildrenIterator
(
)
{
MOZ_COUNT_DTOR
(
StyleChildrenIterator
)
;
}
using
AllChildrenIterator
:
:
GetNextChild
;
using
AllChildrenIterator
:
:
GetPreviousChild
;
using
AllChildrenIterator
:
:
Seek
;
}
;
}
}
#
endif
