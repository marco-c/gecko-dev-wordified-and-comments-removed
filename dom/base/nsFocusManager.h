#
ifndef
nsFocusManager_h___
#
define
nsFocusManager_h___
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIFocusManager
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
define
FOCUSMETHOD_MASK
0xF000
#
define
FOCUSMETHODANDRING_MASK
0xF0F000
#
define
FOCUSMANAGER_CONTRACTID
"
mozilla
.
org
/
focus
-
manager
;
1
"
class
nsIContent
;
class
nsIDocShellTreeItem
;
class
nsPIDOMWindowOuter
;
namespace
mozilla
{
namespace
dom
{
class
Element
;
class
TabParent
;
}
}
struct
nsDelayedBlurOrFocusEvent
;
class
nsFocusManager
final
:
public
nsIFocusManager
public
nsIObserver
public
nsSupportsWeakReference
{
typedef
mozilla
:
:
widget
:
:
InputContextAction
InputContextAction
;
public
:
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
nsFocusManager
nsIFocusManager
)
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIFOCUSMANAGER
static
nsresult
Init
(
)
;
static
void
Shutdown
(
)
;
static
nsFocusManager
*
GetFocusManager
(
)
{
return
sInstance
;
}
mozilla
:
:
dom
:
:
Element
*
GetFocusedElement
(
)
{
return
mFocusedElement
;
}
bool
IsFocused
(
nsIContent
*
aContent
)
;
nsPIDOMWindowOuter
*
GetFocusedWindow
(
)
const
{
return
mFocusedWindow
;
}
nsPIDOMWindowOuter
*
GetActiveWindow
(
)
const
{
return
mActiveWindow
;
}
nsresult
ContentRemoved
(
nsIDocument
*
aDocument
nsIContent
*
aContent
)
;
already_AddRefed
<
nsIDocument
>
SetMouseButtonHandlingDocument
(
nsIDocument
*
aDocument
)
{
nsCOMPtr
<
nsIDocument
>
handlingDocument
=
mMouseButtonEventHandlingDocument
;
mMouseButtonEventHandlingDocument
=
aDocument
;
return
handlingDocument
.
forget
(
)
;
}
void
NeedsFlushBeforeEventHandling
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
if
(
mFocusedElement
=
=
aElement
)
{
mEventHandlingNeedsFlush
=
true
;
}
}
bool
CanSkipFocus
(
nsIContent
*
aContent
)
;
void
FlushBeforeEventHandlingIfNeeded
(
nsIContent
*
aContent
)
{
if
(
mEventHandlingNeedsFlush
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
mEventHandlingNeedsFlush
=
false
;
doc
-
>
FlushPendingNotifications
(
mozilla
:
:
FlushType
:
:
Layout
)
;
}
}
}
void
UpdateCaretForCaretBrowsingMode
(
)
;
enum
SearchRange
{
eOnlyCurrentWindow
eIncludeAllDescendants
eIncludeVisibleDescendants
}
;
static
mozilla
:
:
dom
:
:
Element
*
GetFocusedDescendant
(
nsPIDOMWindowOuter
*
aWindow
SearchRange
aSearchRange
nsPIDOMWindowOuter
*
*
aFocusedWindow
)
;
static
mozilla
:
:
dom
:
:
Element
*
GetRedirectedFocus
(
nsIContent
*
aContent
)
;
static
InputContextAction
:
:
Cause
GetFocusMoveActionCause
(
uint32_t
aFlags
)
;
static
bool
sMouseFocusesFormControl
;
static
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
;
protected
:
nsFocusManager
(
)
;
~
nsFocusManager
(
)
;
void
EnsureCurrentWidgetFocused
(
)
;
void
ActivateOrDeactivate
(
nsPIDOMWindowOuter
*
aWindow
bool
aActive
)
;
void
SetFocusInner
(
mozilla
:
:
dom
:
:
Element
*
aNewContent
int32_t
aFlags
bool
aFocusChanged
bool
aAdjustWidget
)
;
bool
IsSameOrAncestor
(
nsPIDOMWindowOuter
*
aPossibleAncestor
nsPIDOMWindowOuter
*
aWindow
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetCommonAncestor
(
nsPIDOMWindowOuter
*
aWindow1
nsPIDOMWindowOuter
*
aWindow2
)
;
void
AdjustWindowFocus
(
nsPIDOMWindowOuter
*
aNewWindow
bool
aCheckPermission
)
;
bool
IsWindowVisible
(
nsPIDOMWindowOuter
*
aWindow
)
;
bool
IsNonFocusableRoot
(
nsIContent
*
aContent
)
;
mozilla
:
:
dom
:
:
Element
*
CheckIfFocusable
(
mozilla
:
:
dom
:
:
Element
*
aContent
uint32_t
aFlags
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
Blur
(
nsPIDOMWindowOuter
*
aWindowToClear
nsPIDOMWindowOuter
*
aAncestorWindowToFocus
bool
aIsLeavingDocument
bool
aAdjustWidget
nsIContent
*
aContentToFocus
=
nullptr
)
;
void
Focus
(
nsPIDOMWindowOuter
*
aWindow
mozilla
:
:
dom
:
:
Element
*
aContent
uint32_t
aFlags
bool
aIsNewDocument
bool
aFocusChanged
bool
aWindowRaised
bool
aAdjustWidget
nsIContent
*
aContentLostFocus
=
nullptr
)
;
void
SendFocusOrBlurEvent
(
mozilla
:
:
EventMessage
aEventMessage
nsIPresShell
*
aPresShell
nsIDocument
*
aDocument
nsISupports
*
aTarget
uint32_t
aFocusMethod
bool
aWindowRaised
bool
aIsRefocus
=
false
mozilla
:
:
dom
:
:
EventTarget
*
aRelatedTarget
=
nullptr
)
;
void
FireFocusOrBlurEvent
(
mozilla
:
:
EventMessage
aEventMessage
nsIPresShell
*
aPresShell
nsISupports
*
aTarget
bool
aWindowRaised
bool
aIsRefocus
=
false
mozilla
:
:
dom
:
:
EventTarget
*
aRelatedTarget
=
nullptr
)
;
void
FireFocusInOrOutEvent
(
mozilla
:
:
EventMessage
aEventMessage
nsIPresShell
*
aPresShell
nsISupports
*
aTarget
nsPIDOMWindowOuter
*
aCurrentFocusedWindow
nsIContent
*
aCurrentFocusedContent
mozilla
:
:
dom
:
:
EventTarget
*
aRelatedTarget
=
nullptr
)
;
void
ScrollIntoView
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
uint32_t
aFlags
)
;
void
RaiseWindow
(
nsPIDOMWindowOuter
*
aWindow
)
;
void
UpdateCaret
(
bool
aMoveCaretToFocus
bool
aUpdateVisibility
nsIContent
*
aContent
)
;
void
MoveCaretToFocus
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
)
;
nsresult
SetCaretVisible
(
nsIPresShell
*
aPresShell
bool
aVisible
nsIContent
*
aContent
)
;
nsresult
GetSelectionLocation
(
nsIDocument
*
aDocument
nsIPresShell
*
aPresShell
nsIContent
*
*
aStartContent
nsIContent
*
*
aEndContent
)
;
nsresult
DetermineElementToMoveFocus
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aStart
int32_t
aType
bool
aNoParentTraversal
nsIContent
*
*
aNextContent
)
;
nsIContent
*
FindOwner
(
nsIContent
*
aContent
)
;
bool
IsHostOrSlot
(
nsIContent
*
aContent
)
;
int32_t
HostOrSlotTabIndexValue
(
nsIContent
*
aContent
)
;
nsIContent
*
GetNextTabbableContentInScope
(
nsIContent
*
aOwner
nsIContent
*
aStartContent
nsIContent
*
aOriginalStartContent
bool
aForward
int32_t
aCurrentTabIndex
bool
aIgnoreTabIndex
bool
aForDocumentNavigation
bool
aSkipOwner
)
;
nsIContent
*
GetNextTabbableContentInAncestorScopes
(
nsIContent
*
*
aStartContent
nsIContent
*
aOriginalStartContent
bool
aForward
int32_t
*
aCurrentTabIndex
bool
aIgnoreTabIndex
bool
aForDocumentNavigation
)
;
nsresult
GetNextTabbableContent
(
nsIPresShell
*
aPresShell
nsIContent
*
aRootContent
nsIContent
*
aOriginalStartContent
nsIContent
*
aStartContent
bool
aForward
int32_t
aCurrentTabIndex
bool
aIgnoreTabIndex
bool
aForDocumentNavigation
nsIContent
*
*
aResultContent
)
;
nsIContent
*
GetNextTabbableMapArea
(
bool
aForward
int32_t
aCurrentTabIndex
mozilla
:
:
dom
:
:
Element
*
aImageContent
nsIContent
*
aStartContent
)
;
int32_t
GetNextTabIndex
(
nsIContent
*
aParent
int32_t
aCurrentTabIndex
bool
aForward
)
;
nsresult
FocusFirst
(
mozilla
:
:
dom
:
:
Element
*
aRootContent
nsIContent
*
*
aNextContent
)
;
mozilla
:
:
dom
:
:
Element
*
GetRootForFocus
(
nsPIDOMWindowOuter
*
aWindow
nsIDocument
*
aDocument
bool
aForDocumentNavigation
bool
aCheckVisibility
)
;
mozilla
:
:
dom
:
:
Element
*
GetRootForChildDocument
(
nsIContent
*
aContent
)
;
void
GetFocusInSelection
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aStartSelection
nsIContent
*
aEndSelection
nsIContent
*
*
aFocusedContent
)
;
private
:
static
void
NotifyFocusStateChange
(
nsIContent
*
aContent
nsIContent
*
aContentToFocus
bool
aWindowShouldShowFocusRing
bool
aGettingFocus
)
;
void
SetFocusedWindowInternal
(
nsPIDOMWindowOuter
*
aWindow
)
;
bool
TryDocumentNavigation
(
nsIContent
*
aCurrentContent
bool
*
aCheckSubDocument
nsIContent
*
*
aResultContent
)
;
bool
TryToMoveFocusToSubDocument
(
nsIContent
*
aCurrentContent
nsIContent
*
aOriginalStartContent
bool
aForward
bool
aForDocumentNavigation
nsIContent
*
*
aResultContent
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mActiveWindow
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mFocusedWindow
;
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
mFocusedElement
;
nsCOMPtr
<
nsIContent
>
mFirstBlurEvent
;
nsCOMPtr
<
nsIContent
>
mFirstFocusEvent
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mWindowBeingLowered
;
nsTArray
<
nsDelayedBlurOrFocusEvent
>
mDelayedBlurFocusEvents
;
nsCOMPtr
<
nsIDocument
>
mMouseButtonEventHandlingDocument
;
bool
mEventHandlingNeedsFlush
;
static
bool
sTestMode
;
static
nsFocusManager
*
sInstance
;
}
;
nsresult
NS_NewFocusManager
(
nsIFocusManager
*
*
aResult
)
;
#
endif
