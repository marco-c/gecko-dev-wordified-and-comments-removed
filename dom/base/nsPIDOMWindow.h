#
ifndef
nsPIDOMWindow_h__
#
define
nsPIDOMWindow_h__
#
include
"
nsIDOMWindow
.
h
"
#
include
"
mozIDOMWindow
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
TaskCategory
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
define
DOM_WINDOW_DESTROYED_TOPIC
"
dom
-
window
-
destroyed
"
#
define
DOM_WINDOW_FROZEN_TOPIC
"
dom
-
window
-
frozen
"
#
define
DOM_WINDOW_THAWED_TOPIC
"
dom
-
window
-
thawed
"
class
nsDOMOfflineResourceList
;
class
nsDOMWindowList
;
class
nsGlobalWindowInner
;
class
nsGlobalWindowOuter
;
class
nsIArray
;
class
nsIChannel
;
class
nsIContent
;
class
nsICSSDeclaration
;
class
nsIDocShell
;
class
nsDocShellLoadInfo
;
class
nsIDocument
;
class
nsIPrincipal
;
class
nsIScriptTimeoutHandler
;
class
nsISerialEventTarget
;
class
nsIURI
;
class
nsPIDOMWindowInner
;
class
nsPIDOMWindowOuter
;
class
nsPIWindowRoot
;
class
nsXBLPrototypeHandler
;
typedef
uint32_t
SuspendTypes
;
namespace
mozilla
{
class
ThrottledEventQueue
;
class
AutoplayPermissionManager
;
namespace
dom
{
class
AudioContext
;
class
ClientInfo
;
class
ClientState
;
class
ContentFrameMessageManager
;
class
DocGroup
;
class
TabGroup
;
class
Element
;
class
MozIdleObserver
;
class
Navigator
;
class
Performance
;
class
Selection
;
class
ServiceWorker
;
class
ServiceWorkerDescriptor
;
class
Timeout
;
class
TimeoutManager
;
class
CustomElementRegistry
;
enum
class
CallerType
:
uint32_t
;
}
}
enum
PopupControlState
{
openAllowed
=
0
openControlled
openBlocked
openAbused
openOverridden
}
;
enum
UIStateChangeType
{
UIStateChangeType_NoChange
UIStateChangeType_Set
UIStateChangeType_Clear
UIStateChangeType_Invalid
}
;
enum
class
FullscreenReason
{
ForFullscreenMode
ForFullscreenAPI
ForForceExitFullscreen
}
;
namespace
mozilla
{
namespace
dom
{
class
Location
;
enum
class
LargeAllocStatus
:
uint8_t
{
NONE
SUCCESS
NON_GET
NON_E10S
NOT_ONLY_TOPLEVEL_IN_TABGROUP
NON_WIN32
}
;
}
}
#
define
NS_PIDOMWINDOWINNER_IID
\
{
0x775dabc9
0x8f43
0x4277
\
{
0x9a
0xdb
0xf1
0x99
0x0d
0x77
0xcf
0xfb
}
}
#
define
NS_PIDOMWINDOWOUTER_IID
\
{
0x769693d4
0xb009
0x4fe2
\
{
0xaf
0x18
0x7d
0xc8
0xdf
0x74
0x96
0xdf
}
}
class
nsPIDOMWindowInner
:
public
mozIDOMWindow
{
protected
:
friend
nsGlobalWindowInner
;
friend
nsGlobalWindowOuter
;
explicit
nsPIDOMWindowInner
(
nsPIDOMWindowOuter
*
aOuterWindow
)
;
~
nsPIDOMWindowInner
(
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PIDOMWINDOWINNER_IID
)
nsPIDOMWindowInner
*
AsInner
(
)
{
return
this
;
}
const
nsPIDOMWindowInner
*
AsInner
(
)
const
{
return
this
;
}
nsIGlobalObject
*
AsGlobal
(
)
;
const
nsIGlobalObject
*
AsGlobal
(
)
const
;
nsPIDOMWindowOuter
*
GetOuterWindow
(
)
const
{
return
mOuterWindow
;
}
static
nsPIDOMWindowInner
*
From
(
mozIDOMWindow
*
aFrom
)
{
return
static_cast
<
nsPIDOMWindowInner
*
>
(
aFrom
)
;
}
inline
bool
IsCurrentInnerWindow
(
)
const
;
inline
bool
HasActiveDocument
(
)
;
inline
bool
IsTopInnerWindow
(
)
const
;
inline
bool
IsLoading
(
)
const
;
inline
bool
IsHandlingResizeEvent
(
)
const
;
bool
AddAudioContext
(
mozilla
:
:
dom
:
:
AudioContext
*
aAudioContext
)
;
void
RemoveAudioContext
(
mozilla
:
:
dom
:
:
AudioContext
*
aAudioContext
)
;
void
MuteAudioContexts
(
)
;
void
UnmuteAudioContexts
(
)
;
bool
GetAudioCaptured
(
)
const
;
nsresult
SetAudioCapture
(
bool
aCapture
)
;
mozilla
:
:
dom
:
:
Performance
*
GetPerformance
(
)
;
bool
HasMutationListeners
(
uint32_t
aMutationEventType
)
const
{
if
(
!
mOuterWindow
)
{
NS_ERROR
(
"
HasMutationListeners
(
)
called
on
orphan
inner
window
!
"
)
;
return
false
;
}
return
(
mMutationBits
&
aMutationEventType
)
!
=
0
;
}
void
SetMutationListeners
(
uint32_t
aType
)
{
if
(
!
mOuterWindow
)
{
NS_ERROR
(
"
HasMutationListeners
(
)
called
on
orphan
inner
window
!
"
)
;
return
;
}
mMutationBits
|
=
aType
;
}
bool
HasMouseEnterLeaveEventListeners
(
)
{
return
mMayHaveMouseEnterLeaveEventListener
;
}
void
SetHasMouseEnterLeaveEventListeners
(
)
{
mMayHaveMouseEnterLeaveEventListener
=
true
;
}
bool
HasPointerEnterLeaveEventListeners
(
)
{
return
mMayHavePointerEnterLeaveEventListener
;
}
void
SetHasPointerEnterLeaveEventListeners
(
)
{
mMayHavePointerEnterLeaveEventListener
=
true
;
}
mozilla
:
:
dom
:
:
Event
*
SetEvent
(
mozilla
:
:
dom
:
:
Event
*
aEvent
)
{
mozilla
:
:
dom
:
:
Event
*
old
=
mEvent
;
mEvent
=
aEvent
;
return
old
;
}
bool
IsSecureContext
(
)
const
;
bool
IsSecureContextIfOpenerIgnored
(
)
const
;
void
Suspend
(
)
;
void
Resume
(
)
;
void
SyncStateFromParentWindow
(
)
;
void
AddPeerConnection
(
)
;
void
RemovePeerConnection
(
)
;
bool
HasActivePeerConnections
(
)
;
bool
IsPlayingAudio
(
)
;
bool
IsDocumentLoaded
(
)
const
;
mozilla
:
:
dom
:
:
TimeoutManager
&
TimeoutManager
(
)
;
bool
IsRunningTimeout
(
)
;
void
TryToCacheTopInnerWindow
(
)
;
void
UpdateActiveIndexedDBTransactionCount
(
int32_t
aDelta
)
;
void
UpdateActiveIndexedDBDatabaseCount
(
int32_t
aDelta
)
;
bool
HasActiveIndexedDBDatabases
(
)
;
void
UpdateWebSocketCount
(
int32_t
aDelta
)
;
bool
HasOpenWebSockets
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
GetClientInfo
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientState
>
GetClientState
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
GetController
(
)
const
;
void
NoteCalledRegisterForServiceWorkerScope
(
const
nsACString
&
aScope
)
;
void
NoteDOMContentLoaded
(
)
;
mozilla
:
:
dom
:
:
TabGroup
*
TabGroup
(
)
;
virtual
nsPIDOMWindowOuter
*
GetPrivateRoot
(
)
=
0
;
virtual
mozilla
:
:
dom
:
:
CustomElementRegistry
*
CustomElements
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableTop
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableParent
(
)
=
0
;
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetChromeEventHandler
(
)
const
{
return
mChromeEventHandler
;
}
virtual
nsresult
RegisterIdleObserver
(
mozilla
:
:
dom
:
:
MozIdleObserver
&
aIdleObserver
)
=
0
;
virtual
nsresult
UnregisterIdleObserver
(
mozilla
:
:
dom
:
:
MozIdleObserver
&
aIdleObserver
)
=
0
;
virtual
bool
IsTopLevelWindowActive
(
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetParentTarget
(
)
{
if
(
!
mParentTarget
)
{
UpdateParentTarget
(
)
;
}
return
mParentTarget
;
}
virtual
void
MaybeUpdateTouchState
(
)
{
}
nsIDocument
*
GetExtantDoc
(
)
const
{
return
mDoc
;
}
nsIURI
*
GetDocumentURI
(
)
const
;
nsIURI
*
GetDocBaseURI
(
)
const
;
nsIDocument
*
GetDoc
(
)
{
if
(
!
mDoc
)
{
MaybeCreateDoc
(
)
;
}
return
mDoc
;
}
virtual
PopupControlState
GetPopupControlState
(
)
const
=
0
;
virtual
bool
IsSuspended
(
)
const
=
0
;
virtual
bool
IsFrozen
(
)
const
=
0
;
virtual
nsresult
FireDelayedDOMEvents
(
)
=
0
;
inline
nsIDocShell
*
GetDocShell
(
)
const
;
virtual
nsresult
SetNewDocument
(
nsIDocument
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
)
=
0
;
virtual
void
SetOpenerWindow
(
nsPIDOMWindowOuter
*
aOpener
bool
aOriginalOpener
)
=
0
;
void
SetHasPaintEventListeners
(
)
{
mMayHavePaintEventListener
=
true
;
}
bool
HasPaintEventListeners
(
)
{
return
mMayHavePaintEventListener
;
}
void
SetHasTouchEventListeners
(
)
{
if
(
!
mMayHaveTouchEventListener
)
{
mMayHaveTouchEventListener
=
true
;
MaybeUpdateTouchState
(
)
;
}
}
void
SetHasSelectionChangeEventListeners
(
)
{
mMayHaveSelectionChangeEventListener
=
true
;
}
bool
HasSelectionChangeEventListeners
(
)
{
return
mMayHaveSelectionChangeEventListener
;
}
virtual
JSObject
*
GetCachedXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
)
=
0
;
virtual
void
CacheXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
JS
:
:
Handle
<
JSObject
*
>
aHandler
)
=
0
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFocusedElement
(
)
const
;
virtual
void
SetFocusedElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
=
0
;
virtual
uint32_t
GetFocusMethod
(
)
=
0
;
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
=
0
;
virtual
void
SetReadyForFocus
(
)
=
0
;
virtual
bool
ShouldShowFocusRing
(
)
=
0
;
virtual
void
PageHidden
(
)
=
0
;
virtual
nsresult
DispatchAsyncHashchange
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
)
=
0
;
virtual
nsresult
DispatchSyncPopState
(
)
=
0
;
virtual
void
EnableDeviceSensor
(
uint32_t
aType
)
=
0
;
virtual
void
DisableDeviceSensor
(
uint32_t
aType
)
=
0
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
virtual
void
EnableOrientationChangeListener
(
)
=
0
;
virtual
void
DisableOrientationChangeListener
(
)
=
0
;
#
endif
virtual
void
SetHasGamepadEventListener
(
bool
aHasGamepad
=
true
)
=
0
;
virtual
uint32_t
GetSerial
(
)
=
0
;
uint64_t
WindowID
(
)
const
{
return
mWindowID
;
}
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
mozilla
:
:
dom
:
:
Navigator
*
Navigator
(
)
;
virtual
mozilla
:
:
dom
:
:
Location
*
GetLocation
(
)
=
0
;
virtual
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
=
0
;
virtual
nsDOMWindowList
*
GetFrames
(
)
=
0
;
virtual
nsresult
GetInnerWidth
(
int32_t
*
aWidth
)
=
0
;
virtual
nsresult
GetInnerHeight
(
int32_t
*
aHeight
)
=
0
;
virtual
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyle
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
mozilla
:
:
ErrorResult
&
aError
)
=
0
;
virtual
mozilla
:
:
dom
:
:
Element
*
GetFrameElement
(
)
=
0
;
virtual
nsDOMOfflineResourceList
*
GetApplicationCache
(
)
=
0
;
virtual
bool
GetFullScreen
(
)
=
0
;
virtual
nsresult
Focus
(
)
=
0
;
virtual
nsresult
Close
(
)
=
0
;
mozilla
:
:
dom
:
:
DocGroup
*
GetDocGroup
(
)
const
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
=
0
;
already_AddRefed
<
mozilla
:
:
AutoplayPermissionManager
>
GetAutoplayPermissionManager
(
)
;
protected
:
void
CreatePerformanceObjectIfNeeded
(
)
;
void
MaybeCreateDoc
(
)
;
void
SetChromeEventHandlerInternal
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
{
mChromeEventHandler
=
aChromeEventHandler
;
mParentTarget
=
nullptr
;
}
virtual
void
UpdateParentTarget
(
)
=
0
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mChromeEventHandler
;
nsCOMPtr
<
nsIDocument
>
mDoc
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIURI
>
mDocBaseURI
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mParentTarget
;
RefPtr
<
mozilla
:
:
dom
:
:
Performance
>
mPerformance
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
dom
:
:
TimeoutManager
>
mTimeoutManager
;
RefPtr
<
mozilla
:
:
dom
:
:
Navigator
>
mNavigator
;
uint32_t
mMutationBits
;
uint32_t
mActivePeerConnections
;
bool
mIsDocumentLoaded
;
bool
mIsHandlingResizeEvent
;
bool
mMayHavePaintEventListener
;
bool
mMayHaveTouchEventListener
;
bool
mMayHaveSelectionChangeEventListener
;
bool
mMayHaveMouseEnterLeaveEventListener
;
bool
mMayHavePointerEnterLeaveEventListener
;
bool
mAudioCaptured
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mOuterWindow
;
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
mFocusedElement
;
nsTArray
<
mozilla
:
:
dom
:
:
AudioContext
*
>
mAudioContexts
;
RefPtr
<
mozilla
:
:
dom
:
:
TabGroup
>
mTabGroup
;
uint64_t
mWindowID
;
bool
mHasNotifiedGlobalCreated
;
uint32_t
mMarkedCCGeneration
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mTopInnerWindow
;
bool
mHasTriedToCacheTopInnerWindow
;
uint32_t
mNumOfIndexedDBDatabases
;
uint32_t
mNumOfOpenWebSockets
;
RefPtr
<
mozilla
:
:
AutoplayPermissionManager
>
mAutoplayPermissionManager
;
mozilla
:
:
dom
:
:
Event
*
mEvent
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsPIDOMWindowInner
NS_PIDOMWINDOWINNER_IID
)
class
nsPIDOMWindowOuter
:
public
mozIDOMWindowProxy
{
protected
:
explicit
nsPIDOMWindowOuter
(
)
;
~
nsPIDOMWindowOuter
(
)
;
void
RefreshMediaElementsVolume
(
)
;
void
RefreshMediaElementsSuspend
(
SuspendTypes
aSuspend
)
;
bool
IsDisposableSuspend
(
SuspendTypes
aSuspend
)
const
;
void
MaybeNotifyMediaResumedFromBlock
(
SuspendTypes
aSuspend
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PIDOMWINDOWOUTER_IID
)
nsPIDOMWindowOuter
*
AsOuter
(
)
{
return
this
;
}
const
nsPIDOMWindowOuter
*
AsOuter
(
)
const
{
return
this
;
}
nsPIDOMWindowOuter
*
GetOuterWindow
(
)
const
{
return
const_cast
<
nsPIDOMWindowOuter
*
>
(
this
)
;
}
static
nsPIDOMWindowOuter
*
From
(
mozIDOMWindowProxy
*
aFrom
)
{
return
static_cast
<
nsPIDOMWindowOuter
*
>
(
aFrom
)
;
}
static
nsPIDOMWindowOuter
*
GetFromCurrentInner
(
nsPIDOMWindowInner
*
aInner
)
;
inline
bool
IsLoading
(
)
const
;
inline
bool
IsHandlingResizeEvent
(
)
const
;
nsPIDOMWindowInner
*
GetCurrentInnerWindow
(
)
const
{
return
mInnerWindow
;
}
nsPIDOMWindowInner
*
EnsureInnerWindow
(
)
{
GetDoc
(
)
;
return
GetCurrentInnerWindow
(
)
;
}
bool
IsRootOuterWindow
(
)
{
return
mIsRootOuterWindow
;
}
void
SetInitialKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
;
mozilla
:
:
dom
:
:
Element
*
GetFrameElementInternal
(
)
const
;
void
SetFrameElementInternal
(
mozilla
:
:
dom
:
:
Element
*
aFrameElement
)
;
bool
IsActive
(
)
{
return
mIsActive
;
}
void
SetDesktopModeViewport
(
bool
aDesktopModeViewport
)
{
mDesktopModeViewport
=
aDesktopModeViewport
;
}
bool
IsDesktopModeViewport
(
)
const
{
return
mDesktopModeViewport
;
}
bool
IsBackground
(
)
{
return
mIsBackground
;
}
SuspendTypes
GetMediaSuspend
(
)
const
;
void
SetMediaSuspend
(
SuspendTypes
aSuspend
)
;
bool
GetAudioMuted
(
)
const
;
void
SetAudioMuted
(
bool
aMuted
)
;
float
GetAudioVolume
(
)
const
;
nsresult
SetAudioVolume
(
float
aVolume
)
;
void
MaybeActiveMediaComponents
(
)
;
void
SetServiceWorkersTestingEnabled
(
bool
aEnabled
)
;
bool
GetServiceWorkersTestingEnabled
(
)
;
float
GetDevicePixelRatio
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
SetLargeAllocStatus
(
mozilla
:
:
dom
:
:
LargeAllocStatus
aStatus
)
;
bool
IsTopLevelWindow
(
)
;
bool
HadOriginalOpener
(
)
const
;
mozilla
:
:
dom
:
:
TabGroup
*
TabGroup
(
)
;
virtual
nsPIDOMWindowOuter
*
GetPrivateRoot
(
)
=
0
;
virtual
void
ActivateOrDeactivate
(
bool
aActivate
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTop
(
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetParent
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableTop
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableParent
(
)
=
0
;
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableParentOrNull
(
)
=
0
;
virtual
bool
IsTopLevelWindowActive
(
)
=
0
;
virtual
void
SetActive
(
bool
aActive
)
{
mIsActive
=
aActive
;
}
virtual
void
SetIsBackground
(
bool
aIsBackground
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetChromeEventHandler
(
)
const
{
return
mChromeEventHandler
;
}
virtual
void
SetChromeEventHandler
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetParentTarget
(
)
{
if
(
!
mParentTarget
)
{
UpdateParentTarget
(
)
;
}
return
mParentTarget
;
}
mozilla
:
:
dom
:
:
ContentFrameMessageManager
*
GetMessageManager
(
)
{
if
(
!
mParentTarget
)
{
UpdateParentTarget
(
)
;
}
return
mMessageManager
;
}
nsIDocument
*
GetExtantDoc
(
)
const
{
return
mDoc
;
}
nsIURI
*
GetDocumentURI
(
)
const
;
nsIDocument
*
GetDoc
(
)
{
if
(
!
mDoc
)
{
MaybeCreateDoc
(
)
;
}
return
mDoc
;
}
virtual
void
SetInitialPrincipalToSubject
(
)
=
0
;
virtual
PopupControlState
PushPopupControlState
(
PopupControlState
aState
bool
aForce
)
const
=
0
;
virtual
void
PopPopupControlState
(
PopupControlState
state
)
const
=
0
;
virtual
PopupControlState
GetPopupControlState
(
)
const
=
0
;
virtual
already_AddRefed
<
nsISupports
>
SaveWindowState
(
)
=
0
;
virtual
nsresult
RestoreWindowState
(
nsISupports
*
aState
)
=
0
;
virtual
bool
IsSuspended
(
)
const
=
0
;
virtual
bool
IsFrozen
(
)
const
=
0
;
virtual
nsresult
FireDelayedDOMEvents
(
)
=
0
;
inline
nsIDocShell
*
GetDocShell
(
)
const
;
virtual
nsresult
SetNewDocument
(
nsIDocument
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
)
=
0
;
virtual
void
SetOpenerWindow
(
nsPIDOMWindowOuter
*
aOpener
bool
aOriginalOpener
)
=
0
;
virtual
void
EnsureSizeAndPositionUpToDate
(
)
=
0
;
virtual
void
EnterModalState
(
)
=
0
;
virtual
void
LeaveModalState
(
)
=
0
;
virtual
bool
CanClose
(
)
=
0
;
virtual
void
ForceClose
(
)
=
0
;
virtual
nsresult
SetFullscreenInternal
(
FullscreenReason
aReason
bool
aIsFullscreen
)
=
0
;
virtual
void
FullscreenWillChange
(
bool
aIsFullscreen
)
=
0
;
virtual
void
FinishFullscreenChange
(
bool
aIsFullscreen
)
=
0
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFocusedElement
(
)
const
;
virtual
void
SetFocusedElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
=
0
;
virtual
uint32_t
GetFocusMethod
(
)
=
0
;
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
=
0
;
virtual
void
SetReadyForFocus
(
)
=
0
;
virtual
bool
ShouldShowFocusRing
(
)
=
0
;
virtual
void
SetKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
=
0
;
virtual
void
PageHidden
(
)
=
0
;
virtual
nsresult
SetArguments
(
nsIArray
*
aArguments
)
=
0
;
virtual
uint32_t
GetSerial
(
)
=
0
;
uint64_t
WindowID
(
)
const
{
return
mWindowID
;
}
virtual
bool
DispatchCustomEvent
(
const
nsAString
&
aEventName
)
=
0
;
virtual
nsresult
OpenNoNavigate
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
void
FirePopupBlockedEvent
(
nsIDocument
*
aDoc
nsIURI
*
aPopupURI
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
=
0
;
virtual
void
NotifyContentBlockingState
(
unsigned
aState
nsIChannel
*
aChannel
)
=
0
;
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
virtual
mozilla
:
:
dom
:
:
Navigator
*
GetNavigator
(
)
=
0
;
virtual
mozilla
:
:
dom
:
:
Location
*
GetLocation
(
)
=
0
;
virtual
nsresult
GetPrompter
(
nsIPrompt
*
*
aPrompt
)
=
0
;
virtual
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
dom
:
:
Selection
>
GetSelection
(
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetOpener
(
)
=
0
;
virtual
nsDOMWindowList
*
GetFrames
(
)
=
0
;
virtual
nsresult
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsDocShellLoadInfo
*
aLoadInfo
bool
aForceNoOpener
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
nsresult
OpenDialog
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsISupports
*
aExtraArgument
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
nsresult
GetInnerWidth
(
int32_t
*
aWidth
)
=
0
;
virtual
nsresult
GetInnerHeight
(
int32_t
*
aHeight
)
=
0
;
virtual
mozilla
:
:
dom
:
:
Element
*
GetFrameElement
(
)
=
0
;
virtual
bool
Closed
(
)
=
0
;
virtual
bool
GetFullScreen
(
)
=
0
;
virtual
nsresult
SetFullScreen
(
bool
aFullScreen
)
=
0
;
virtual
nsresult
Focus
(
)
=
0
;
virtual
nsresult
Close
(
)
=
0
;
virtual
nsresult
MoveBy
(
int32_t
aXDif
int32_t
aYDif
)
=
0
;
virtual
void
UpdateCommands
(
const
nsAString
&
anAction
mozilla
:
:
dom
:
:
Selection
*
aSel
int16_t
aReason
)
=
0
;
mozilla
:
:
dom
:
:
DocGroup
*
GetDocGroup
(
)
const
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
=
0
;
void
SetOpenerForInitialContentBrowser
(
nsPIDOMWindowOuter
*
aOpener
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
TakeOpenerForInitialContentBrowser
(
)
;
protected
:
void
MaybeCreateDoc
(
)
;
void
SetChromeEventHandlerInternal
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
;
virtual
void
UpdateParentTarget
(
)
=
0
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mChromeEventHandler
;
nsCOMPtr
<
nsIDocument
>
mDoc
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mParentTarget
;
RefPtr
<
mozilla
:
:
dom
:
:
ContentFrameMessageManager
>
mMessageManager
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mFrameElement
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
uint32_t
mModalStateDepth
;
bool
mIsActive
;
bool
mIsBackground
;
SuspendTypes
mMediaSuspend
;
bool
mAudioMuted
;
float
mAudioVolume
;
bool
mDesktopModeViewport
;
bool
mIsRootOuterWindow
;
nsPIDOMWindowInner
*
MOZ_NON_OWNING_REF
mInnerWindow
;
RefPtr
<
mozilla
:
:
dom
:
:
TabGroup
>
mTabGroup
;
uint64_t
mWindowID
;
uint32_t
mMarkedCCGeneration
;
bool
mServiceWorkersTestingEnabled
;
mozilla
:
:
dom
:
:
LargeAllocStatus
mLargeAllocStatus
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mOpenerForInitialContentBrowser
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsPIDOMWindowOuter
NS_PIDOMWINDOWOUTER_IID
)
#
include
"
nsPIDOMWindowInlines
.
h
"
#
ifdef
MOZILLA_INTERNAL_API
#
define
NS_AUTO_POPUP_STATE_PUSHER
nsAutoPopupStatePusherInternal
#
else
#
define
NS_AUTO_POPUP_STATE_PUSHER
nsAutoPopupStatePusherExternal
#
endif
class
NS_AUTO_POPUP_STATE_PUSHER
{
public
:
#
ifdef
MOZILLA_INTERNAL_API
explicit
NS_AUTO_POPUP_STATE_PUSHER
(
PopupControlState
aState
bool
aForce
=
false
)
;
~
NS_AUTO_POPUP_STATE_PUSHER
(
)
;
#
else
NS_AUTO_POPUP_STATE_PUSHER
(
nsPIDOMWindowOuter
*
aWindow
PopupControlState
aState
)
:
mWindow
(
aWindow
)
mOldState
(
openAbused
)
{
if
(
aWindow
)
{
mOldState
=
aWindow
-
>
PushPopupControlState
(
aState
false
)
;
}
}
~
NS_AUTO_POPUP_STATE_PUSHER
(
)
{
if
(
mWindow
)
{
mWindow
-
>
PopPopupControlState
(
mOldState
)
;
}
}
#
endif
protected
:
#
ifndef
MOZILLA_INTERNAL_API
nsCOMPtr
<
nsPIDOMWindowOuter
>
mWindow
;
#
endif
PopupControlState
mOldState
;
private
:
static
void
*
operator
new
(
size_t
)
CPP_THROW_NEW
{
return
nullptr
;
}
static
void
operator
delete
(
void
*
)
{
}
}
;
#
define
nsAutoPopupStatePusher
NS_AUTO_POPUP_STATE_PUSHER
#
endif
