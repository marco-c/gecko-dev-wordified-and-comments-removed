#
ifndef
nsPIDOMWindow_h__
#
define
nsPIDOMWindow_h__
#
include
"
nsIDOMWindow
.
h
"
#
include
"
mozIDOMWindow
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
AntiTrackingCommon
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TaskCategory
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
define
DOM_WINDOW_DESTROYED_TOPIC
"
dom
-
window
-
destroyed
"
#
define
DOM_WINDOW_FROZEN_TOPIC
"
dom
-
window
-
frozen
"
#
define
DOM_WINDOW_THAWED_TOPIC
"
dom
-
window
-
thawed
"
class
nsDOMOfflineResourceList
;
class
nsDOMWindowList
;
class
nsGlobalWindowInner
;
class
nsGlobalWindowOuter
;
class
nsIArray
;
class
nsIChannel
;
class
nsIContent
;
class
nsIContentSecurityPolicy
;
class
nsICSSDeclaration
;
class
nsIDocShell
;
class
nsDocShellLoadState
;
class
nsIPrincipal
;
class
nsIRunnable
;
class
nsIScriptTimeoutHandler
;
class
nsISerialEventTarget
;
class
nsIURI
;
class
nsPIDOMWindowInner
;
class
nsPIDOMWindowOuter
;
class
nsPIWindowRoot
;
class
nsXBLPrototypeHandler
;
typedef
uint32_t
SuspendTypes
;
namespace
mozilla
{
namespace
dom
{
class
AudioContext
;
class
BrowsingContext
;
class
ClientInfo
;
class
ClientState
;
class
ContentFrameMessageManager
;
class
DocGroup
;
class
Document
;
class
TabGroup
;
class
Element
;
class
Navigator
;
class
Performance
;
class
Report
;
class
ReportBody
;
class
ReportingObserver
;
class
Selection
;
class
ServiceWorker
;
class
ServiceWorkerDescriptor
;
class
Timeout
;
class
TimeoutManager
;
class
WindowGlobalChild
;
class
CustomElementRegistry
;
enum
class
CallerType
:
uint32_t
;
}
}
enum
UIStateChangeType
{
UIStateChangeType_NoChange
UIStateChangeType_Set
UIStateChangeType_Clear
UIStateChangeType_Invalid
}
;
enum
class
FullscreenReason
{
ForFullscreenMode
ForFullscreenAPI
ForForceExitFullscreen
}
;
namespace
mozilla
{
namespace
dom
{
class
Location
;
enum
class
LargeAllocStatus
:
uint8_t
{
NONE
SUCCESS
NON_GET
NON_E10S
NOT_ONLY_TOPLEVEL_IN_TABGROUP
NON_WIN32
}
;
}
}
#
define
NS_PIDOMWINDOWINNER_IID
\
{
\
0x775dabc9
0x8f43
0x4277
{
\
0x9a
0xdb
0xf1
0x99
0x0d
0x77
0xcf
0xfb
\
}
\
}
#
define
NS_PIDOMWINDOWOUTER_IID
\
{
\
0x769693d4
0xb009
0x4fe2
{
\
0xaf
0x18
0x7d
0xc8
0xdf
0x74
0x96
0xdf
\
}
\
}
class
nsPIDOMWindowInner
:
public
mozIDOMWindow
{
protected
:
typedef
mozilla
:
:
dom
:
:
Document
Document
;
friend
nsGlobalWindowInner
;
friend
nsGlobalWindowOuter
;
explicit
nsPIDOMWindowInner
(
nsPIDOMWindowOuter
*
aOuterWindow
)
;
~
nsPIDOMWindowInner
(
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PIDOMWINDOWINNER_IID
)
nsIGlobalObject
*
AsGlobal
(
)
;
const
nsIGlobalObject
*
AsGlobal
(
)
const
;
nsPIDOMWindowOuter
*
GetOuterWindow
(
)
const
{
return
mOuterWindow
;
}
static
nsPIDOMWindowInner
*
From
(
mozIDOMWindow
*
aFrom
)
{
return
static_cast
<
nsPIDOMWindowInner
*
>
(
aFrom
)
;
}
inline
bool
IsCurrentInnerWindow
(
)
const
;
inline
bool
HasActiveDocument
(
)
;
inline
bool
IsTopInnerWindow
(
)
const
;
inline
bool
IsLoading
(
)
const
;
inline
bool
IsHandlingResizeEvent
(
)
const
;
void
SetActiveLoadingState
(
bool
aIsActiveLoading
)
;
void
AddAfterLoadRunner
(
nsIRunnable
*
aRunner
)
;
bool
AddAudioContext
(
mozilla
:
:
dom
:
:
AudioContext
*
aAudioContext
)
;
void
RemoveAudioContext
(
mozilla
:
:
dom
:
:
AudioContext
*
aAudioContext
)
;
void
MuteAudioContexts
(
)
;
void
UnmuteAudioContexts
(
)
;
void
SetAudioCapture
(
bool
aCapture
)
;
mozilla
:
:
dom
:
:
Performance
*
GetPerformance
(
)
;
void
QueuePerformanceNavigationTiming
(
)
;
bool
HasMutationListeners
(
uint32_t
aMutationEventType
)
const
{
if
(
!
mOuterWindow
)
{
NS_ERROR
(
"
HasMutationListeners
(
)
called
on
orphan
inner
window
!
"
)
;
return
false
;
}
return
(
mMutationBits
&
aMutationEventType
)
!
=
0
;
}
void
SetMutationListeners
(
uint32_t
aType
)
{
if
(
!
mOuterWindow
)
{
NS_ERROR
(
"
HasMutationListeners
(
)
called
on
orphan
inner
window
!
"
)
;
return
;
}
mMutationBits
|
=
aType
;
}
bool
HasMouseEnterLeaveEventListeners
(
)
{
return
mMayHaveMouseEnterLeaveEventListener
;
}
void
SetHasMouseEnterLeaveEventListeners
(
)
{
mMayHaveMouseEnterLeaveEventListener
=
true
;
}
bool
HasPointerEnterLeaveEventListeners
(
)
{
return
mMayHavePointerEnterLeaveEventListener
;
}
void
SetHasPointerEnterLeaveEventListeners
(
)
{
mMayHavePointerEnterLeaveEventListener
=
true
;
}
void
SetHasTextEventListenerInDefaultGroup
(
)
{
mMayHaveTextEventListenerInDefaultGroup
=
true
;
}
mozilla
:
:
dom
:
:
Event
*
SetEvent
(
mozilla
:
:
dom
:
:
Event
*
aEvent
)
{
mozilla
:
:
dom
:
:
Event
*
old
=
mEvent
;
mEvent
=
aEvent
;
return
old
;
}
bool
IsSecureContext
(
)
const
;
bool
IsSecureContextIfOpenerIgnored
(
)
const
;
void
Suspend
(
)
;
void
Resume
(
)
;
void
SyncStateFromParentWindow
(
)
;
void
AddPeerConnection
(
)
;
void
RemovePeerConnection
(
)
;
bool
HasActivePeerConnections
(
)
;
bool
IsPlayingAudio
(
)
;
bool
IsDocumentLoaded
(
)
const
;
mozilla
:
:
dom
:
:
TimeoutManager
&
TimeoutManager
(
)
;
bool
IsRunningTimeout
(
)
;
void
TryToCacheTopInnerWindow
(
)
;
void
UpdateActiveIndexedDBTransactionCount
(
int32_t
aDelta
)
;
void
UpdateActiveIndexedDBDatabaseCount
(
int32_t
aDelta
)
;
bool
HasActiveIndexedDBDatabases
(
)
;
void
UpdateWebSocketCount
(
int32_t
aDelta
)
;
bool
HasOpenWebSockets
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
GetClientInfo
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientState
>
GetClientState
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
GetController
(
)
const
;
void
SetCsp
(
nsIContentSecurityPolicy
*
aCsp
)
;
void
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCsp
)
;
nsIContentSecurityPolicy
*
GetCsp
(
)
;
void
NoteCalledRegisterForServiceWorkerScope
(
const
nsACString
&
aScope
)
;
void
NoteDOMContentLoaded
(
)
;
mozilla
:
:
dom
:
:
TabGroup
*
TabGroup
(
)
;
virtual
mozilla
:
:
dom
:
:
CustomElementRegistry
*
CustomElements
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableTop
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableParent
(
)
=
0
;
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetChromeEventHandler
(
)
const
{
return
mChromeEventHandler
;
}
mozilla
:
:
dom
:
:
EventTarget
*
GetParentTarget
(
)
{
if
(
!
mParentTarget
)
{
UpdateParentTarget
(
)
;
}
return
mParentTarget
;
}
virtual
void
MaybeUpdateTouchState
(
)
{
}
Document
*
GetExtantDoc
(
)
const
{
return
mDoc
;
}
nsIURI
*
GetDocumentURI
(
)
const
;
nsIURI
*
GetDocBaseURI
(
)
const
;
Document
*
GetDoc
(
)
{
if
(
!
mDoc
)
{
MaybeCreateDoc
(
)
;
}
return
mDoc
;
}
mozilla
:
:
dom
:
:
WindowGlobalChild
*
GetWindowGlobalChild
(
)
{
return
mWindowGlobalChild
;
}
virtual
bool
IsSuspended
(
)
const
=
0
;
virtual
bool
IsFrozen
(
)
const
=
0
;
virtual
nsresult
FireDelayedDOMEvents
(
)
=
0
;
inline
nsIDocShell
*
GetDocShell
(
)
const
;
void
SetHasPaintEventListeners
(
)
{
mMayHavePaintEventListener
=
true
;
}
bool
HasPaintEventListeners
(
)
{
return
mMayHavePaintEventListener
;
}
void
SetHasTouchEventListeners
(
)
{
if
(
!
mMayHaveTouchEventListener
)
{
mMayHaveTouchEventListener
=
true
;
MaybeUpdateTouchState
(
)
;
}
}
void
SetHasSelectionChangeEventListeners
(
)
{
mMayHaveSelectionChangeEventListener
=
true
;
}
bool
HasSelectionChangeEventListeners
(
)
{
return
mMayHaveSelectionChangeEventListener
;
}
virtual
JSObject
*
GetCachedXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
)
=
0
;
virtual
void
CacheXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
JS
:
:
Handle
<
JSObject
*
>
aHandler
)
=
0
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFocusedElement
(
)
const
;
virtual
void
SetFocusedElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
=
0
;
virtual
uint32_t
GetFocusMethod
(
)
=
0
;
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
=
0
;
virtual
void
SetReadyForFocus
(
)
=
0
;
virtual
bool
ShouldShowFocusRing
(
)
=
0
;
virtual
void
PageHidden
(
)
=
0
;
virtual
nsresult
DispatchAsyncHashchange
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
)
=
0
;
virtual
nsresult
DispatchSyncPopState
(
)
=
0
;
virtual
void
EnableDeviceSensor
(
uint32_t
aType
)
=
0
;
virtual
void
DisableDeviceSensor
(
uint32_t
aType
)
=
0
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
virtual
void
EnableOrientationChangeListener
(
)
=
0
;
virtual
void
DisableOrientationChangeListener
(
)
=
0
;
#
endif
virtual
void
SetHasGamepadEventListener
(
bool
aHasGamepad
=
true
)
=
0
;
uint64_t
WindowID
(
)
const
{
return
mWindowID
;
}
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
mozilla
:
:
dom
:
:
Navigator
*
Navigator
(
)
;
virtual
mozilla
:
:
dom
:
:
Location
*
Location
(
)
=
0
;
virtual
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
=
0
;
virtual
nsDOMWindowList
*
GetFrames
(
)
=
0
;
virtual
nsresult
GetInnerWidth
(
int32_t
*
aWidth
)
=
0
;
virtual
nsresult
GetInnerHeight
(
int32_t
*
aHeight
)
=
0
;
virtual
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyle
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
mozilla
:
:
ErrorResult
&
aError
)
=
0
;
virtual
mozilla
:
:
dom
:
:
Element
*
GetFrameElement
(
)
=
0
;
virtual
nsDOMOfflineResourceList
*
GetApplicationCache
(
)
=
0
;
virtual
bool
GetFullScreen
(
)
=
0
;
virtual
nsresult
Focus
(
)
=
0
;
virtual
nsresult
Close
(
)
=
0
;
mozilla
:
:
dom
:
:
DocGroup
*
GetDocGroup
(
)
const
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
=
0
;
void
RegisterReportingObserver
(
mozilla
:
:
dom
:
:
ReportingObserver
*
aObserver
bool
aBuffered
)
;
void
UnregisterReportingObserver
(
mozilla
:
:
dom
:
:
ReportingObserver
*
aObserver
)
;
void
BroadcastReport
(
mozilla
:
:
dom
:
:
Report
*
aReport
)
;
MOZ_CAN_RUN_SCRIPT
void
NotifyReportingObservers
(
)
;
void
SaveStorageAccessGranted
(
const
nsACString
&
aPermissionKey
)
;
bool
HasStorageAccessGranted
(
const
nsACString
&
aPermissionKey
)
;
protected
:
void
CreatePerformanceObjectIfNeeded
(
)
;
void
MaybeCreateDoc
(
)
;
void
SetChromeEventHandlerInternal
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
{
mChromeEventHandler
=
aChromeEventHandler
;
mParentTarget
=
nullptr
;
}
virtual
void
UpdateParentTarget
(
)
=
0
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mChromeEventHandler
;
RefPtr
<
Document
>
mDoc
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIURI
>
mDocBaseURI
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mParentTarget
;
RefPtr
<
mozilla
:
:
dom
:
:
Performance
>
mPerformance
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
dom
:
:
TimeoutManager
>
mTimeoutManager
;
RefPtr
<
mozilla
:
:
dom
:
:
Navigator
>
mNavigator
;
uint32_t
mMutationBits
;
uint32_t
mActivePeerConnections
;
bool
mIsDocumentLoaded
;
bool
mIsHandlingResizeEvent
;
bool
mMayHavePaintEventListener
;
bool
mMayHaveTouchEventListener
;
bool
mMayHaveSelectionChangeEventListener
;
bool
mMayHaveMouseEnterLeaveEventListener
;
bool
mMayHavePointerEnterLeaveEventListener
;
bool
mMayHaveTextEventListenerInDefaultGroup
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mOuterWindow
;
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
mFocusedElement
;
nsTArray
<
mozilla
:
:
dom
:
:
AudioContext
*
>
mAudioContexts
;
RefPtr
<
mozilla
:
:
dom
:
:
TabGroup
>
mTabGroup
;
uint64_t
mWindowID
;
bool
mHasNotifiedGlobalCreated
;
uint32_t
mMarkedCCGeneration
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mTopInnerWindow
;
bool
mHasTriedToCacheTopInnerWindow
;
uint32_t
mNumOfIndexedDBDatabases
;
uint32_t
mNumOfOpenWebSockets
;
mozilla
:
:
dom
:
:
Event
*
mEvent
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
ReportingObserver
>
>
mReportingObservers
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Report
>
>
mReportRecords
;
nsTArray
<
nsCString
>
mStorageAccessGranted
;
RefPtr
<
mozilla
:
:
dom
:
:
WindowGlobalChild
>
mWindowGlobalChild
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mAfterLoadRunners
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsPIDOMWindowInner
NS_PIDOMWINDOWINNER_IID
)
class
nsPIDOMWindowOuter
:
public
mozIDOMWindowProxy
{
protected
:
typedef
mozilla
:
:
dom
:
:
Document
Document
;
explicit
nsPIDOMWindowOuter
(
uint64_t
aWindowID
)
;
~
nsPIDOMWindowOuter
(
)
;
void
RefreshMediaElementsVolume
(
)
;
void
RefreshMediaElementsSuspend
(
SuspendTypes
aSuspend
)
;
bool
IsDisposableSuspend
(
SuspendTypes
aSuspend
)
const
;
void
MaybeNotifyMediaResumedFromBlock
(
SuspendTypes
aSuspend
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PIDOMWINDOWOUTER_IID
)
static
nsPIDOMWindowOuter
*
From
(
mozIDOMWindowProxy
*
aFrom
)
{
return
static_cast
<
nsPIDOMWindowOuter
*
>
(
aFrom
)
;
}
static
nsPIDOMWindowOuter
*
GetFromCurrentInner
(
nsPIDOMWindowInner
*
aInner
)
;
inline
bool
IsLoading
(
)
const
;
inline
bool
IsHandlingResizeEvent
(
)
const
;
nsPIDOMWindowInner
*
GetCurrentInnerWindow
(
)
const
{
return
mInnerWindow
;
}
nsPIDOMWindowInner
*
EnsureInnerWindow
(
)
{
GetDoc
(
)
;
return
GetCurrentInnerWindow
(
)
;
}
bool
IsRootOuterWindow
(
)
{
return
mIsRootOuterWindow
;
}
void
SetInitialKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
;
mozilla
:
:
dom
:
:
Element
*
GetFrameElementInternal
(
)
const
;
void
SetFrameElementInternal
(
mozilla
:
:
dom
:
:
Element
*
aFrameElement
)
;
bool
IsActive
(
)
{
return
mIsActive
;
}
void
SetDesktopModeViewport
(
bool
aDesktopModeViewport
)
{
mDesktopModeViewport
=
aDesktopModeViewport
;
}
bool
IsDesktopModeViewport
(
)
const
{
return
mDesktopModeViewport
;
}
bool
IsBackground
(
)
{
return
mIsBackground
;
}
SuspendTypes
GetMediaSuspend
(
)
const
;
void
SetMediaSuspend
(
SuspendTypes
aSuspend
)
;
bool
GetAudioMuted
(
)
const
;
void
SetAudioMuted
(
bool
aMuted
)
;
float
GetAudioVolume
(
)
const
;
nsresult
SetAudioVolume
(
float
aVolume
)
;
void
MaybeActiveMediaComponents
(
)
;
void
SetServiceWorkersTestingEnabled
(
bool
aEnabled
)
;
bool
GetServiceWorkersTestingEnabled
(
)
;
float
GetDevicePixelRatio
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
SetLargeAllocStatus
(
mozilla
:
:
dom
:
:
LargeAllocStatus
aStatus
)
;
bool
IsTopLevelWindow
(
)
;
bool
HadOriginalOpener
(
)
const
;
mozilla
:
:
dom
:
:
TabGroup
*
TabGroup
(
)
;
virtual
nsPIDOMWindowOuter
*
GetPrivateRoot
(
)
=
0
;
virtual
void
ActivateOrDeactivate
(
bool
aActivate
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTop
(
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetParent
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableTop
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableParent
(
)
=
0
;
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableParentOrNull
(
)
=
0
;
virtual
bool
IsTopLevelWindowActive
(
)
=
0
;
virtual
void
SetActive
(
bool
aActive
)
{
mIsActive
=
aActive
;
}
virtual
void
SetIsBackground
(
bool
aIsBackground
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetChromeEventHandler
(
)
const
{
return
mChromeEventHandler
;
}
virtual
void
SetChromeEventHandler
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetParentTarget
(
)
{
if
(
!
mParentTarget
)
{
UpdateParentTarget
(
)
;
}
return
mParentTarget
;
}
mozilla
:
:
dom
:
:
ContentFrameMessageManager
*
GetMessageManager
(
)
{
if
(
!
mParentTarget
)
{
UpdateParentTarget
(
)
;
}
return
mMessageManager
;
}
Document
*
GetExtantDoc
(
)
const
{
return
mDoc
;
}
nsIURI
*
GetDocumentURI
(
)
const
;
Document
*
GetDoc
(
)
{
if
(
!
mDoc
)
{
MaybeCreateDoc
(
)
;
}
return
mDoc
;
}
virtual
void
SetInitialPrincipalToSubject
(
nsIContentSecurityPolicy
*
aCSP
)
=
0
;
virtual
already_AddRefed
<
nsISupports
>
SaveWindowState
(
)
=
0
;
virtual
nsresult
RestoreWindowState
(
nsISupports
*
aState
)
=
0
;
virtual
bool
IsSuspended
(
)
const
=
0
;
virtual
bool
IsFrozen
(
)
const
=
0
;
virtual
nsresult
FireDelayedDOMEvents
(
)
=
0
;
inline
nsIDocShell
*
GetDocShell
(
)
const
;
inline
mozilla
:
:
dom
:
:
BrowsingContext
*
GetBrowsingContext
(
)
const
;
virtual
nsresult
SetNewDocument
(
Document
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
)
=
0
;
virtual
void
SetOpenerWindow
(
nsPIDOMWindowOuter
*
aOpener
bool
aOriginalOpener
)
=
0
;
virtual
void
EnsureSizeAndPositionUpToDate
(
)
=
0
;
virtual
void
EnterModalState
(
)
=
0
;
virtual
void
LeaveModalState
(
)
=
0
;
virtual
bool
CanClose
(
)
=
0
;
virtual
void
ForceClose
(
)
=
0
;
virtual
nsresult
SetFullscreenInternal
(
FullscreenReason
aReason
bool
aIsFullscreen
)
=
0
;
virtual
void
FullscreenWillChange
(
bool
aIsFullscreen
)
=
0
;
virtual
void
FinishFullscreenChange
(
bool
aIsFullscreen
)
=
0
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFocusedElement
(
)
const
;
virtual
void
SetFocusedElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
=
0
;
virtual
uint32_t
GetFocusMethod
(
)
=
0
;
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
=
0
;
virtual
void
SetReadyForFocus
(
)
=
0
;
virtual
bool
ShouldShowFocusRing
(
)
=
0
;
virtual
void
SetKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
=
0
;
virtual
void
PageHidden
(
)
=
0
;
virtual
nsresult
SetArguments
(
nsIArray
*
aArguments
)
=
0
;
uint64_t
WindowID
(
)
const
{
return
mWindowID
;
}
virtual
bool
DispatchCustomEvent
(
const
nsAString
&
aEventName
)
=
0
;
virtual
nsresult
OpenNoNavigate
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
void
FirePopupBlockedEvent
(
Document
*
aDoc
nsIURI
*
aPopupURI
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
=
0
;
virtual
void
NotifyContentBlockingEvent
(
unsigned
aEvent
nsIChannel
*
aChannel
bool
aBlocked
nsIURI
*
aURIHint
nsIChannel
*
aTrackingChannel
const
mozilla
:
:
Maybe
<
mozilla
:
:
AntiTrackingCommon
:
:
StorageAccessGrantedReason
>
&
aReason
=
mozilla
:
:
Nothing
(
)
)
=
0
;
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
virtual
mozilla
:
:
dom
:
:
Navigator
*
GetNavigator
(
)
=
0
;
virtual
mozilla
:
:
dom
:
:
Location
*
GetLocation
(
)
=
0
;
virtual
nsresult
GetPrompter
(
nsIPrompt
*
*
aPrompt
)
=
0
;
virtual
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
dom
:
:
Selection
>
GetSelection
(
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetOpener
(
)
=
0
;
virtual
nsDOMWindowList
*
GetFrames
(
)
=
0
;
virtual
nsresult
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsDocShellLoadState
*
aLoadState
bool
aForceNoOpener
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
nsresult
OpenDialog
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsISupports
*
aExtraArgument
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
nsresult
GetInnerWidth
(
int32_t
*
aWidth
)
=
0
;
virtual
nsresult
GetInnerHeight
(
int32_t
*
aHeight
)
=
0
;
virtual
mozilla
:
:
dom
:
:
Element
*
GetFrameElement
(
)
=
0
;
virtual
bool
Closed
(
)
=
0
;
virtual
bool
GetFullScreen
(
)
=
0
;
virtual
nsresult
SetFullScreen
(
bool
aFullscreen
)
=
0
;
virtual
nsresult
Focus
(
)
=
0
;
virtual
nsresult
Close
(
)
=
0
;
virtual
nsresult
MoveBy
(
int32_t
aXDif
int32_t
aYDif
)
=
0
;
virtual
void
UpdateCommands
(
const
nsAString
&
anAction
mozilla
:
:
dom
:
:
Selection
*
aSel
int16_t
aReason
)
=
0
;
mozilla
:
:
dom
:
:
DocGroup
*
GetDocGroup
(
)
const
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
=
0
;
void
SetOpenerForInitialContentBrowser
(
mozilla
:
:
dom
:
:
BrowsingContext
*
aOpener
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
BrowsingContext
>
TakeOpenerForInitialContentBrowser
(
)
;
protected
:
void
MaybeCreateDoc
(
)
;
void
SetChromeEventHandlerInternal
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
;
virtual
void
UpdateParentTarget
(
)
=
0
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mChromeEventHandler
;
RefPtr
<
Document
>
mDoc
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mParentTarget
;
RefPtr
<
mozilla
:
:
dom
:
:
ContentFrameMessageManager
>
mMessageManager
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mFrameElement
;
nsCOMPtr
<
nsIDocShell
>
mDocShell
;
RefPtr
<
mozilla
:
:
dom
:
:
BrowsingContext
>
mBrowsingContext
;
uint32_t
mModalStateDepth
;
bool
mIsActive
;
bool
mIsBackground
;
SuspendTypes
mMediaSuspend
;
bool
mAudioMuted
;
float
mAudioVolume
;
bool
mDesktopModeViewport
;
bool
mIsRootOuterWindow
;
nsPIDOMWindowInner
*
MOZ_NON_OWNING_REF
mInnerWindow
;
RefPtr
<
mozilla
:
:
dom
:
:
TabGroup
>
mTabGroup
;
uint64_t
mWindowID
;
uint32_t
mMarkedCCGeneration
;
bool
mServiceWorkersTestingEnabled
;
mozilla
:
:
dom
:
:
LargeAllocStatus
mLargeAllocStatus
;
RefPtr
<
mozilla
:
:
dom
:
:
BrowsingContext
>
mOpenerForInitialContentBrowser
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsPIDOMWindowOuter
NS_PIDOMWINDOWOUTER_IID
)
#
include
"
nsPIDOMWindowInlines
.
h
"
#
endif
