#
ifndef
nsPIDOMWindow_h__
#
define
nsPIDOMWindow_h__
#
include
"
nsIDOMWindow
.
h
"
#
include
"
mozIDOMWindow
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
define
DOM_WINDOW_DESTROYED_TOPIC
"
dom
-
window
-
destroyed
"
#
define
DOM_WINDOW_FROZEN_TOPIC
"
dom
-
window
-
frozen
"
#
define
DOM_WINDOW_THAWED_TOPIC
"
dom
-
window
-
thawed
"
class
nsGlobalWindow
;
class
nsIArray
;
class
nsIContent
;
class
nsICSSDeclaration
;
class
nsIDocShell
;
class
nsIDocument
;
class
nsIIdleObserver
;
class
nsIScriptTimeoutHandler
;
class
nsIURI
;
class
nsPerformance
;
class
nsPIDOMWindowInner
;
class
nsPIDOMWindowOuter
;
class
nsPIWindowRoot
;
class
nsXBLPrototypeHandler
;
struct
nsTimeout
;
namespace
mozilla
{
namespace
dom
{
class
AudioContext
;
class
Element
;
class
ServiceWorkerRegistrationMainThread
;
}
namespace
gfx
{
class
VRDeviceProxy
;
}
}
enum
PopupControlState
{
openAllowed
=
0
openControlled
openAbused
openOverridden
}
;
enum
UIStateChangeType
{
UIStateChangeType_NoChange
UIStateChangeType_Set
UIStateChangeType_Clear
}
;
enum
class
FullscreenReason
{
ForFullscreenMode
ForFullscreenAPI
ForForceExitFullscreen
}
;
template
<
class
T
>
class
nsPIDOMWindow
:
public
T
{
public
:
nsPIDOMWindowInner
*
AsInner
(
)
;
const
nsPIDOMWindowInner
*
AsInner
(
)
const
;
nsPIDOMWindowOuter
*
AsOuter
(
)
;
const
nsPIDOMWindowOuter
*
AsOuter
(
)
const
;
virtual
nsPIDOMWindowOuter
*
GetPrivateRoot
(
)
=
0
;
virtual
void
ActivateOrDeactivate
(
bool
aActivate
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTop
(
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetParent
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableTop
(
)
=
0
;
virtual
nsPIDOMWindowOuter
*
GetScriptableParent
(
)
=
0
;
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
=
0
;
virtual
nsresult
RegisterIdleObserver
(
nsIIdleObserver
*
aIdleObserver
)
=
0
;
virtual
nsresult
UnregisterIdleObserver
(
nsIIdleObserver
*
aIdleObserver
)
=
0
;
virtual
void
SetActive
(
bool
aActive
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
mIsActive
=
aActive
;
}
virtual
void
SetIsBackground
(
bool
aIsBackground
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
mIsBackground
=
aIsBackground
;
}
mozilla
:
:
dom
:
:
EventTarget
*
GetChromeEventHandler
(
)
const
{
return
mChromeEventHandler
;
}
virtual
void
SetChromeEventHandler
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
=
0
;
mozilla
:
:
dom
:
:
EventTarget
*
GetParentTarget
(
)
{
if
(
!
mParentTarget
)
{
UpdateParentTarget
(
)
;
}
return
mParentTarget
;
}
bool
HasMutationListeners
(
uint32_t
aMutationEventType
)
const
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mOuterWindow
)
{
NS_ERROR
(
"
HasMutationListeners
(
)
called
on
orphan
inner
window
!
"
)
;
return
false
;
}
return
(
mMutationBits
&
aMutationEventType
)
!
=
0
;
}
void
SetMutationListeners
(
uint32_t
aType
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mOuterWindow
)
{
NS_ERROR
(
"
HasMutationListeners
(
)
called
on
orphan
inner
window
!
"
)
;
return
;
}
mMutationBits
|
=
aType
;
}
virtual
void
MaybeUpdateTouchState
(
)
{
}
nsIDocument
*
GetExtantDoc
(
)
const
{
return
mDoc
;
}
nsIURI
*
GetDocumentURI
(
)
const
;
nsIURI
*
GetDocBaseURI
(
)
const
;
nsIDocument
*
GetDoc
(
)
{
if
(
!
mDoc
)
{
MaybeCreateDoc
(
)
;
}
return
mDoc
;
}
virtual
bool
IsRunningTimeout
(
)
=
0
;
protected
:
void
MaybeCreateDoc
(
)
;
public
:
inline
bool
IsLoadingOrRunningTimeout
(
)
const
;
inline
bool
IsLoading
(
)
const
;
inline
bool
IsHandlingResizeEvent
(
)
const
;
virtual
void
SetInitialPrincipalToSubject
(
)
=
0
;
virtual
PopupControlState
PushPopupControlState
(
PopupControlState
aState
bool
aForce
)
const
=
0
;
virtual
void
PopPopupControlState
(
PopupControlState
state
)
const
=
0
;
virtual
PopupControlState
GetPopupControlState
(
)
const
=
0
;
virtual
already_AddRefed
<
nsISupports
>
SaveWindowState
(
)
=
0
;
virtual
nsresult
RestoreWindowState
(
nsISupports
*
aState
)
=
0
;
virtual
void
SuspendTimeouts
(
uint32_t
aIncrease
=
1
bool
aFreezeChildren
=
true
bool
aFreezeWorkers
=
true
)
=
0
;
virtual
nsresult
ResumeTimeouts
(
bool
aThawChildren
=
true
bool
aThawWorkers
=
true
)
=
0
;
virtual
uint32_t
TimeoutSuspendCount
(
)
=
0
;
virtual
nsresult
FireDelayedDOMEvents
(
)
=
0
;
virtual
bool
IsFrozen
(
)
const
=
0
;
virtual
nsresult
SetTimeoutOrInterval
(
nsIScriptTimeoutHandler
*
aHandler
int32_t
interval
bool
aIsInterval
int32_t
*
aReturn
)
=
0
;
virtual
nsresult
ClearTimeoutOrInterval
(
int32_t
aTimerID
)
=
0
;
nsPIDOMWindowOuter
*
GetOuterWindow
(
)
{
return
mIsInnerWindow
?
mOuterWindow
.
get
(
)
:
AsOuter
(
)
;
}
bool
IsInnerWindow
(
)
const
{
return
mIsInnerWindow
;
}
bool
IsOuterWindow
(
)
const
{
return
!
IsInnerWindow
(
)
;
}
virtual
bool
WouldReuseInnerWindow
(
nsIDocument
*
aNewDocument
)
=
0
;
nsIDocShell
*
GetDocShell
(
)
const
;
virtual
void
SetDocShell
(
nsIDocShell
*
aDocShell
)
=
0
;
virtual
void
DetachFromDocShell
(
)
=
0
;
virtual
nsresult
SetNewDocument
(
nsIDocument
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
)
=
0
;
virtual
void
SetOpenerWindow
(
nsPIDOMWindowOuter
*
aOpener
bool
aOriginalOpener
)
=
0
;
virtual
void
EnsureSizeUpToDate
(
)
=
0
;
virtual
void
EnterModalState
(
)
=
0
;
virtual
void
LeaveModalState
(
)
=
0
;
virtual
bool
CanClose
(
)
=
0
;
virtual
void
ForceClose
(
)
=
0
;
bool
IsModalContentWindow
(
)
const
{
return
mIsModalContentWindow
;
}
void
SetHasPaintEventListeners
(
)
{
mMayHavePaintEventListener
=
true
;
}
bool
HasPaintEventListeners
(
)
{
return
mMayHavePaintEventListener
;
}
void
SetHasTouchEventListeners
(
)
{
if
(
!
mMayHaveTouchEventListener
)
{
mMayHaveTouchEventListener
=
true
;
MaybeUpdateTouchState
(
)
;
}
}
virtual
nsresult
SetFullscreenInternal
(
FullscreenReason
aReason
bool
aIsFullscreen
mozilla
:
:
gfx
:
:
VRDeviceProxy
*
aHMD
=
nullptr
)
=
0
;
virtual
void
FinishFullscreenChange
(
bool
aIsFullscreen
)
=
0
;
bool
HasMouseEnterLeaveEventListeners
(
)
{
return
mMayHaveMouseEnterLeaveEventListener
;
}
void
SetHasMouseEnterLeaveEventListeners
(
)
{
mMayHaveMouseEnterLeaveEventListener
=
true
;
}
bool
HasPointerEnterLeaveEventListeners
(
)
{
return
mMayHavePointerEnterLeaveEventListener
;
}
void
SetHasPointerEnterLeaveEventListeners
(
)
{
mMayHavePointerEnterLeaveEventListener
=
true
;
}
virtual
JSObject
*
GetCachedXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
)
=
0
;
virtual
void
CacheXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
JS
:
:
Handle
<
JSObject
*
>
aHandler
)
=
0
;
nsIContent
*
GetFocusedNode
(
)
const
;
virtual
void
SetFocusedNode
(
nsIContent
*
aNode
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
=
0
;
virtual
uint32_t
GetFocusMethod
(
)
=
0
;
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
=
0
;
virtual
void
SetReadyForFocus
(
)
=
0
;
virtual
bool
ShouldShowFocusRing
(
)
=
0
;
virtual
void
SetKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
=
0
;
virtual
void
GetKeyboardIndicators
(
bool
*
aShowAccelerators
bool
*
aShowFocusRings
)
=
0
;
virtual
void
PageHidden
(
)
=
0
;
virtual
nsresult
DispatchAsyncHashchange
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
)
=
0
;
virtual
nsresult
DispatchSyncPopState
(
)
=
0
;
virtual
void
EnableDeviceSensor
(
uint32_t
aType
)
=
0
;
virtual
void
DisableDeviceSensor
(
uint32_t
aType
)
=
0
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
virtual
void
EnableOrientationChangeListener
(
)
=
0
;
virtual
void
DisableOrientationChangeListener
(
)
=
0
;
#
endif
virtual
void
EnableTimeChangeNotifications
(
)
=
0
;
virtual
void
DisableTimeChangeNotifications
(
)
=
0
;
#
ifdef
MOZ_B2G
virtual
void
EnableNetworkEvent
(
mozilla
:
:
EventMessage
aEventMessage
)
=
0
;
virtual
void
DisableNetworkEvent
(
mozilla
:
:
EventMessage
aEventMessage
)
=
0
;
#
endif
virtual
void
SetHasGamepadEventListener
(
bool
aHasGamepad
=
true
)
=
0
;
virtual
nsresult
SetArguments
(
nsIArray
*
aArguments
)
=
0
;
virtual
uint32_t
GetSerial
(
)
=
0
;
uint64_t
WindowID
(
)
const
{
return
mWindowID
;
}
virtual
bool
DispatchCustomEvent
(
const
nsAString
&
aEventName
)
=
0
;
virtual
void
RefreshCompartmentPrincipal
(
)
=
0
;
virtual
nsresult
OpenNoNavigate
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
void
FirePopupBlockedEvent
(
nsIDocument
*
aDoc
nsIURI
*
aPopupURI
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
=
0
;
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
virtual
nsIDOMScreen
*
GetScreen
(
)
=
0
;
virtual
nsIDOMNavigator
*
GetNavigator
(
)
=
0
;
virtual
nsIDOMLocation
*
GetLocation
(
)
=
0
;
virtual
nsresult
GetPrompter
(
nsIPrompt
*
*
aPrompt
)
=
0
;
virtual
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
=
0
;
virtual
already_AddRefed
<
nsISelection
>
GetSelection
(
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetOpener
(
)
=
0
;
virtual
already_AddRefed
<
nsIDOMWindowCollection
>
GetFrames
(
)
=
0
;
virtual
nsresult
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
nsresult
OpenDialog
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsISupports
*
aExtraArgument
nsPIDOMWindowOuter
*
*
_retval
)
=
0
;
virtual
nsresult
GetDevicePixelRatio
(
float
*
aRatio
)
=
0
;
virtual
nsresult
GetInnerWidth
(
int32_t
*
aWidth
)
=
0
;
virtual
nsresult
GetInnerHeight
(
int32_t
*
aHeight
)
=
0
;
virtual
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyle
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
mozilla
:
:
ErrorResult
&
aError
)
=
0
;
virtual
already_AddRefed
<
nsIDOMElement
>
GetFrameElement
(
)
=
0
;
virtual
already_AddRefed
<
nsIDOMOfflineResourceList
>
GetApplicationCache
(
)
=
0
;
virtual
bool
Closed
(
)
=
0
;
virtual
bool
GetFullScreen
(
)
=
0
;
virtual
nsresult
SetFullScreen
(
bool
aFullScreen
)
=
0
;
virtual
nsresult
Focus
(
)
=
0
;
virtual
nsresult
Close
(
)
=
0
;
virtual
nsresult
MoveBy
(
int32_t
aXDif
int32_t
aYDif
)
=
0
;
virtual
nsresult
UpdateCommands
(
const
nsAString
&
anAction
nsISelection
*
aSel
int16_t
aReason
)
=
0
;
protected
:
explicit
nsPIDOMWindow
<
T
>
(
nsPIDOMWindowOuter
*
aOuterWindow
)
;
~
nsPIDOMWindow
<
T
>
(
)
;
void
SetChromeEventHandlerInternal
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
{
mChromeEventHandler
=
aChromeEventHandler
;
mParentTarget
=
nullptr
;
}
virtual
void
UpdateParentTarget
(
)
=
0
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mChromeEventHandler
;
nsCOMPtr
<
nsIDocument
>
mDoc
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIURI
>
mDocBaseURI
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mParentTarget
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mFrameElement
;
nsIDocShell
*
MOZ_NON_OWNING_REF
mDocShell
;
RefPtr
<
nsPerformance
>
mPerformance
;
typedef
nsRefPtrHashtable
<
nsStringHashKey
mozilla
:
:
dom
:
:
ServiceWorkerRegistrationMainThread
>
ServiceWorkerRegistrationTable
;
ServiceWorkerRegistrationTable
mServiceWorkerRegistrationTable
;
uint32_t
mModalStateDepth
;
nsTimeout
*
mRunningTimeout
;
uint32_t
mMutationBits
;
bool
mIsDocumentLoaded
;
bool
mIsHandlingResizeEvent
;
bool
mIsInnerWindow
;
bool
mMayHavePaintEventListener
;
bool
mMayHaveTouchEventListener
;
bool
mMayHaveMouseEnterLeaveEventListener
;
bool
mMayHavePointerEnterLeaveEventListener
;
bool
mIsModalContentWindow
;
bool
mIsActive
;
bool
mIsBackground
;
bool
mAudioMuted
;
float
mAudioVolume
;
bool
mAudioCaptured
;
bool
mDesktopModeViewport
;
nsPIDOMWindowInner
*
MOZ_NON_OWNING_REF
mInnerWindow
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mOuterWindow
;
nsCOMPtr
<
nsIContent
>
mFocusedNode
;
nsTArray
<
mozilla
:
:
dom
:
:
AudioContext
*
>
mAudioContexts
;
uint64_t
mWindowID
;
bool
mHasNotifiedGlobalCreated
;
uint32_t
mMarkedCCGeneration
;
bool
mServiceWorkersTestingEnabled
;
}
;
#
define
NS_PIDOMWINDOWINNER_IID
\
{
0x775dabc9
0x8f43
0x4277
\
{
0x9a
0xdb
0xf1
0x99
0x0d
0x77
0xcf
0xfb
}
}
#
define
NS_PIDOMWINDOWOUTER_IID
\
{
0x769693d4
0xb009
0x4fe2
\
{
0xaf
0x18
0x7d
0xc8
0xdf
0x74
0x96
0xdf
}
}
class
nsPIDOMWindowInner
:
public
nsPIDOMWindow
<
mozIDOMWindow
>
{
friend
nsGlobalWindow
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PIDOMWINDOWINNER_IID
)
static
nsPIDOMWindowInner
*
From
(
mozIDOMWindow
*
aFrom
)
{
return
static_cast
<
nsPIDOMWindowInner
*
>
(
aFrom
)
;
}
inline
bool
IsCurrentInnerWindow
(
)
const
;
inline
bool
HasActiveDocument
(
)
;
bool
AddAudioContext
(
mozilla
:
:
dom
:
:
AudioContext
*
aAudioContext
)
;
void
RemoveAudioContext
(
mozilla
:
:
dom
:
:
AudioContext
*
aAudioContext
)
;
void
MuteAudioContexts
(
)
;
void
UnmuteAudioContexts
(
)
;
bool
GetAudioCaptured
(
)
const
;
nsresult
SetAudioCapture
(
bool
aCapture
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
ServiceWorkerRegistrationMainThread
>
GetServiceWorkerRegistration
(
const
nsAString
&
aScope
)
;
void
InvalidateServiceWorkerRegistration
(
const
nsAString
&
aScope
)
;
nsPerformance
*
GetPerformance
(
)
;
protected
:
void
CreatePerformanceObjectIfNeeded
(
)
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsPIDOMWindowInner
NS_PIDOMWINDOWINNER_IID
)
class
nsPIDOMWindowOuter
:
public
nsPIDOMWindow
<
mozIDOMWindowProxy
>
{
protected
:
void
RefreshMediaElements
(
)
;
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_PIDOMWINDOWOUTER_IID
)
static
nsPIDOMWindowOuter
*
From
(
mozIDOMWindowProxy
*
aFrom
)
{
return
static_cast
<
nsPIDOMWindowOuter
*
>
(
aFrom
)
;
}
static
nsPIDOMWindowOuter
*
GetFromCurrentInner
(
nsPIDOMWindowInner
*
aInner
)
;
nsPIDOMWindowInner
*
GetCurrentInnerWindow
(
)
const
{
return
mInnerWindow
;
}
nsPIDOMWindowInner
*
EnsureInnerWindow
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
GetDoc
(
)
;
return
GetCurrentInnerWindow
(
)
;
}
mozilla
:
:
dom
:
:
Element
*
GetFrameElementInternal
(
)
const
;
void
SetFrameElementInternal
(
mozilla
:
:
dom
:
:
Element
*
aFrameElement
)
;
bool
IsActive
(
)
{
return
mIsActive
;
}
void
SetDesktopModeViewport
(
bool
aDesktopModeViewport
)
{
mDesktopModeViewport
=
aDesktopModeViewport
;
}
bool
IsDesktopModeViewport
(
)
const
{
return
mDesktopModeViewport
;
}
bool
IsBackground
(
)
{
return
mIsBackground
;
}
bool
GetAudioMuted
(
)
const
;
void
SetAudioMuted
(
bool
aMuted
)
;
float
GetAudioVolume
(
)
const
;
nsresult
SetAudioVolume
(
float
aVolume
)
;
void
SetServiceWorkersTestingEnabled
(
bool
aEnabled
)
{
mServiceWorkersTestingEnabled
=
aEnabled
;
}
bool
GetServiceWorkersTestingEnabled
(
)
{
return
mServiceWorkersTestingEnabled
;
}
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsPIDOMWindowOuter
NS_PIDOMWINDOWOUTER_IID
)
#
include
"
nsPIDOMWindowInlines
.
h
"
#
ifdef
MOZILLA_INTERNAL_API
PopupControlState
PushPopupControlState
(
PopupControlState
aState
bool
aForce
)
;
void
PopPopupControlState
(
PopupControlState
aState
)
;
#
define
NS_AUTO_POPUP_STATE_PUSHER
nsAutoPopupStatePusherInternal
#
else
#
define
NS_AUTO_POPUP_STATE_PUSHER
nsAutoPopupStatePusherExternal
#
endif
class
NS_AUTO_POPUP_STATE_PUSHER
{
public
:
#
ifdef
MOZILLA_INTERNAL_API
explicit
NS_AUTO_POPUP_STATE_PUSHER
(
PopupControlState
aState
bool
aForce
=
false
)
:
mOldState
(
:
:
PushPopupControlState
(
aState
aForce
)
)
{
}
~
NS_AUTO_POPUP_STATE_PUSHER
(
)
{
PopPopupControlState
(
mOldState
)
;
}
#
else
NS_AUTO_POPUP_STATE_PUSHER
(
nsPIDOMWindowOuter
*
aWindow
PopupControlState
aState
)
:
mWindow
(
aWindow
)
mOldState
(
openAbused
)
{
if
(
aWindow
)
{
mOldState
=
aWindow
-
>
PushPopupControlState
(
aState
false
)
;
}
}
~
NS_AUTO_POPUP_STATE_PUSHER
(
)
{
if
(
mWindow
)
{
mWindow
-
>
PopPopupControlState
(
mOldState
)
;
}
}
#
endif
protected
:
#
ifndef
MOZILLA_INTERNAL_API
nsCOMPtr
<
nsPIDOMWindowOuter
>
mWindow
;
#
endif
PopupControlState
mOldState
;
private
:
static
void
*
operator
new
(
size_t
)
CPP_THROW_NEW
{
return
nullptr
;
}
static
void
operator
delete
(
void
*
)
{
}
}
;
#
define
nsAutoPopupStatePusher
NS_AUTO_POPUP_STATE_PUSHER
#
endif
