#
ifndef
nsGlobalWindowOuter_h___
#
define
nsGlobalWindowOuter_h___
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsJSThingHashtable
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
prclist
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
ChromeMessageBroadcaster
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
StorageEvent
.
h
"
#
include
"
mozilla
/
dom
/
StorageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsCheapSets
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapSource
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
class
nsDocShell
;
class
nsIArray
;
class
nsIBaseWindow
;
class
nsIContent
;
class
nsICSSDeclaration
;
class
nsIDocShellTreeOwner
;
class
nsIDOMWindowUtils
;
class
nsIScrollableFrame
;
class
nsIControllers
;
class
nsIScriptContext
;
class
nsIScriptTimeoutHandler
;
class
nsIBrowserChild
;
class
nsITimeoutHandler
;
class
nsIWebBrowserChrome
;
class
mozIDOMWindowProxy
;
class
nsDocShellLoadState
;
class
nsScreen
;
class
nsHistory
;
class
nsGlobalWindowObserver
;
class
nsGlobalWindowInner
;
class
nsDOMWindowUtils
;
struct
nsRect
;
class
nsWindowSizes
;
namespace
mozilla
{
class
AbstractThread
;
class
DOMEventTargetHelper
;
class
ThrottledEventQueue
;
namespace
dom
{
class
BarProp
;
struct
ChannelPixelLayout
;
class
Console
;
class
Crypto
;
class
CustomElementRegistry
;
class
DocGroup
;
class
External
;
class
Function
;
class
Gamepad
;
enum
class
ImageBitmapFormat
:
uint8_t
;
class
IncrementalRunnable
;
class
IntlUtils
;
class
Location
;
class
MediaQueryList
;
class
Navigator
;
class
OwningExternalOrWindowProxy
;
class
Promise
;
class
PostMessageData
;
class
PostMessageEvent
;
struct
RequestInit
;
class
RequestOrUSVString
;
class
Selection
;
class
SpeechSynthesis
;
class
TabGroup
;
class
Timeout
;
class
U2F
;
class
VRDisplay
;
enum
class
VRDisplayEventReason
:
uint8_t
;
class
VREventObserver
;
class
WakeLock
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
class
WindowOrientationObserver
;
#
endif
class
Worklet
;
namespace
cache
{
class
CacheStorage
;
}
class
IDBFactory
;
}
}
extern
already_AddRefed
<
nsIScriptTimeoutHandler
>
NS_CreateJSTimeoutHandler
(
JSContext
*
aCx
nsGlobalWindowInner
*
aWindow
mozilla
:
:
dom
:
:
Function
&
aFunction
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
mozilla
:
:
ErrorResult
&
aError
)
;
extern
already_AddRefed
<
nsIScriptTimeoutHandler
>
NS_CreateJSTimeoutHandler
(
JSContext
*
aCx
nsGlobalWindowInner
*
aWindow
const
nsAString
&
aExpression
mozilla
:
:
ErrorResult
&
aError
)
;
extern
const
JSClass
OuterWindowProxyClass
;
class
nsGlobalWindowOuter
final
:
public
mozilla
:
:
dom
:
:
EventTarget
public
nsPIDOMWindowOuter
private
nsIDOMWindow
private
nsIDOMChromeWindow
public
nsIScriptGlobalObject
public
nsIScriptObjectPrincipal
public
nsSupportsWeakReference
public
nsIInterfaceRequestor
public
PRCListStr
public
nsIObserver
{
public
:
typedef
nsDataHashtable
<
nsUint64HashKey
nsGlobalWindowOuter
*
>
OuterWindowByIdTable
;
static
void
AssertIsOnMainThread
(
)
#
ifdef
DEBUG
;
#
else
{
}
#
endif
static
nsGlobalWindowOuter
*
Cast
(
nsPIDOMWindowOuter
*
aPIWin
)
{
return
static_cast
<
nsGlobalWindowOuter
*
>
(
aPIWin
)
;
}
static
const
nsGlobalWindowOuter
*
Cast
(
const
nsPIDOMWindowOuter
*
aPIWin
)
{
return
static_cast
<
const
nsGlobalWindowOuter
*
>
(
aPIWin
)
;
}
static
nsGlobalWindowOuter
*
Cast
(
mozIDOMWindowProxy
*
aWin
)
{
return
Cast
(
nsPIDOMWindowOuter
:
:
From
(
aWin
)
)
;
}
static
nsGlobalWindowOuter
*
GetOuterWindowWithId
(
uint64_t
aWindowID
)
{
AssertIsOnMainThread
(
)
;
if
(
!
sOuterWindowsById
)
{
return
nullptr
;
}
nsGlobalWindowOuter
*
outerWindow
=
sOuterWindowsById
-
>
Get
(
aWindowID
)
;
return
outerWindow
;
}
static
OuterWindowByIdTable
*
GetWindowsTable
(
)
{
AssertIsOnMainThread
(
)
;
return
sOuterWindowsById
;
}
static
nsGlobalWindowOuter
*
FromSupports
(
nsISupports
*
supports
)
{
return
(
nsGlobalWindowOuter
*
)
(
mozilla
:
:
dom
:
:
EventTarget
*
)
supports
;
}
static
already_AddRefed
<
nsGlobalWindowOuter
>
Create
(
nsDocShell
*
aDocShell
bool
aIsChrome
)
;
nsPIDOMWindowOuter
*
GetPrivateParent
(
)
;
void
ReallyCloseWindow
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
virtual
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
EnsureInnerWindow
(
)
?
GetWrapper
(
)
:
nullptr
;
}
JSObject
*
GetGlobalJSObject
(
)
final
{
return
GetWrapper
(
)
;
}
JSObject
*
GetGlobalJSObjectPreserveColor
(
)
const
final
{
return
GetWrapperPreserveColor
(
)
;
}
virtual
nsresult
EnsureScriptEnvironment
(
)
override
;
virtual
nsIScriptContext
*
GetScriptContext
(
)
override
;
void
PoisonOuterWindowProxy
(
JSObject
*
aObject
)
;
virtual
bool
IsBlackForCC
(
bool
aTracingNeeded
=
true
)
override
;
virtual
nsIPrincipal
*
GetPrincipal
(
)
override
;
virtual
nsIPrincipal
*
GetEffectiveStoragePrincipal
(
)
override
;
NS_DECL_NSIDOMWINDOW
NS_DECL_NSIDOMCHROMEWINDOW
mozilla
:
:
dom
:
:
ChromeMessageBroadcaster
*
GetMessageManager
(
)
;
mozilla
:
:
dom
:
:
ChromeMessageBroadcaster
*
GetGroupMessageManager
(
const
nsAString
&
aGroup
)
;
nsresult
OpenJS
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
mozilla
:
:
dom
:
:
BrowsingContext
*
*
_retval
)
;
virtual
mozilla
:
:
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
bool
ComputeDefaultWantsUntrusted
(
mozilla
:
:
ErrorResult
&
aRv
)
final
;
virtual
nsPIDOMWindowOuter
*
GetOwnerGlobalForBindingsInternal
(
)
override
;
virtual
nsIGlobalObject
*
GetOwnerGlobal
(
)
const
override
;
EventTarget
*
GetTargetForEventTargetChain
(
)
override
;
using
mozilla
:
:
dom
:
:
EventTarget
:
:
DispatchEvent
;
bool
DispatchEvent
(
mozilla
:
:
dom
:
:
Event
&
aEvent
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
override
;
void
GetEventTargetParent
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
override
;
nsresult
PostHandleEvent
(
mozilla
:
:
EventChainPostVisitor
&
aVisitor
)
override
;
virtual
nsPIDOMWindowOuter
*
GetPrivateRoot
(
)
override
;
virtual
void
ActivateOrDeactivate
(
bool
aActivate
)
override
;
virtual
void
SetActive
(
bool
aActive
)
override
;
virtual
bool
IsTopLevelWindowActive
(
)
override
;
virtual
void
SetIsBackground
(
bool
aIsBackground
)
override
;
virtual
void
SetChromeEventHandler
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
override
;
virtual
void
SetInitialPrincipalToSubject
(
nsIContentSecurityPolicy
*
aCSP
)
override
;
virtual
already_AddRefed
<
nsISupports
>
SaveWindowState
(
)
override
;
virtual
nsresult
RestoreWindowState
(
nsISupports
*
aState
)
override
;
virtual
bool
IsSuspended
(
)
const
override
;
virtual
bool
IsFrozen
(
)
const
override
;
virtual
nsresult
FireDelayedDOMEvents
(
)
override
;
bool
WouldReuseInnerWindow
(
Document
*
aNewDocument
)
;
void
DetachFromDocShell
(
)
;
virtual
nsresult
SetNewDocument
(
Document
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
mozilla
:
:
dom
:
:
WindowGlobalChild
*
aActor
=
nullptr
)
override
;
static
void
PrepareForProcessChange
(
JSObject
*
aProxy
)
;
void
DispatchDOMWindowCreated
(
)
;
virtual
void
EnsureSizeAndPositionUpToDate
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
virtual
void
EnterModalState
(
)
override
;
virtual
void
LeaveModalState
(
)
override
;
virtual
bool
CanClose
(
)
override
;
virtual
void
ForceClose
(
)
override
;
virtual
bool
DispatchCustomEvent
(
const
nsAString
&
aEventName
)
override
;
bool
DispatchResizeEvent
(
const
mozilla
:
:
CSSIntSize
&
aSize
)
;
friend
class
FullscreenTransitionTask
;
nsresult
SetFullscreenInternal
(
FullscreenReason
aReason
bool
aIsFullscreen
)
final
;
void
FullscreenWillChange
(
bool
aIsFullscreen
)
final
;
void
FinishFullscreenChange
(
bool
aIsFullscreen
)
final
;
void
ForceFullScreenInWidget
(
)
final
;
bool
SetWidgetFullscreen
(
FullscreenReason
aReason
bool
aIsFullscreen
nsIWidget
*
aWidget
nsIScreen
*
aScreen
)
;
bool
Fullscreen
(
)
const
;
NS_DECL_NSIINTERFACEREQUESTOR
NS_DECL_NSIOBSERVER
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
IndexedGetterOuter
(
uint32_t
aIndex
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetInProcessTop
(
)
override
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTopExcludingExtensionAccessibleContentFrames
(
nsIURI
*
aURIBeingLoaded
)
;
nsPIDOMWindowOuter
*
GetInProcessScriptableTop
(
)
override
;
inline
nsGlobalWindowOuter
*
GetInProcessTopInternal
(
)
;
inline
nsGlobalWindowOuter
*
GetInProcessScriptableTopInternal
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
BrowsingContext
>
GetChildWindow
(
const
nsAString
&
aName
)
;
bool
ShouldPromptToBlockDialogs
(
)
;
void
EnableDialogs
(
)
;
void
DisableDialogs
(
)
;
bool
AreDialogsEnabled
(
)
;
class
MOZ_RAII
TemporarilyDisableDialogs
{
public
:
explicit
TemporarilyDisableDialogs
(
nsGlobalWindowOuter
*
aWindow
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
TemporarilyDisableDialogs
(
)
;
private
:
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
RefPtr
<
nsGlobalWindowInner
>
mTopWindow
;
bool
mSavedDialogsEnabled
;
}
;
friend
class
TemporarilyDisableDialogs
;
nsIScriptContext
*
GetContextInternal
(
)
;
nsGlobalWindowInner
*
GetCurrentInnerWindowInternal
(
)
const
;
nsGlobalWindowInner
*
EnsureInnerWindowInternal
(
)
;
bool
IsCreatingInnerWindow
(
)
const
{
return
mCreatingInnerWindow
;
}
bool
IsChromeWindow
(
)
const
{
return
mIsChrome
;
}
nsIScrollableFrame
*
GetScrollFrame
(
)
;
void
UnblockScriptedClosing
(
)
;
static
void
Init
(
)
;
static
void
ShutDown
(
)
;
static
bool
IsCallerChrome
(
)
;
friend
class
WindowStateHolder
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsGlobalWindowOuter
mozilla
:
:
dom
:
:
EventTarget
)
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
override
;
virtual
void
SetReadyForFocus
(
)
override
;
virtual
void
PageHidden
(
)
override
;
nsresult
SetArguments
(
nsIArray
*
aArguments
)
;
bool
IsClosedOrClosing
(
)
{
return
(
mIsClosed
|
|
mInClose
|
|
mHavePendingClose
|
|
mCleanedUp
)
;
}
bool
IsCleanedUp
(
)
const
{
return
mCleanedUp
;
}
bool
HadOriginalOpener
(
)
const
{
return
GetBrowsingContext
(
)
-
>
HadOriginalOpener
(
)
;
}
bool
IsTopLevelWindow
(
)
;
virtual
void
FirePopupBlockedEvent
(
Document
*
aDoc
nsIURI
*
aPopupURI
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
override
;
virtual
void
NotifyContentBlockingEvent
(
unsigned
aEvent
nsIChannel
*
aChannel
bool
aBlocked
nsIURI
*
aURIHint
nsIChannel
*
aTrackingChannel
const
mozilla
:
:
Maybe
<
mozilla
:
:
AntiTrackingCommon
:
:
StorageAccessGrantedReason
>
&
aReason
)
override
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
void
AllowScriptsToClose
(
)
{
mAllowScriptsToClose
=
true
;
}
uint32_t
GetAutoActivateVRDisplayID
(
)
;
void
SetAutoActivateVRDisplayID
(
uint32_t
aAutoActivateVRDisplayID
)
;
#
define
EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOn
#
#
name_
(
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
handler
)
;
\
}
\
}
#
define
ERROR_EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
OnErrorEventHandlerNonNull
*
GetOn
#
#
name_
(
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetOnErrorEventHandler
(
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
OnErrorEventHandlerNonNull
*
handler
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
handler
)
;
\
}
\
}
#
define
BEFOREUNLOAD_EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
GetOn
#
#
name_
(
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetOnBeforeUnloadEventHandler
(
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
\
mozilla
:
:
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
handler
)
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
handler
)
;
\
}
\
}
#
define
WINDOW_ONLY_EVENT
EVENT
#
define
TOUCH_EVENT
EVENT
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
TOUCH_EVENT
#
undef
WINDOW_ONLY_EVENT
#
undef
BEFOREUNLOAD_EVENT
#
undef
ERROR_EVENT
#
undef
EVENT
nsISupports
*
GetParentObject
(
)
{
return
nullptr
;
}
Document
*
GetDocument
(
)
{
return
GetDoc
(
)
;
}
void
GetNameOuter
(
nsAString
&
aName
)
;
void
SetNameOuter
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Location
*
GetLocation
(
)
override
;
void
GetStatusOuter
(
nsAString
&
aStatus
)
;
void
SetStatusOuter
(
const
nsAString
&
aStatus
)
;
void
CloseOuter
(
bool
aTrustedCaller
)
;
nsresult
Close
(
)
override
;
bool
GetClosedOuter
(
)
;
bool
Closed
(
)
override
;
void
StopOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
FocusOuter
(
)
;
nsresult
Focus
(
)
override
;
void
BlurOuter
(
)
;
mozilla
:
:
dom
:
:
WindowProxyHolder
GetFramesOuter
(
)
;
uint32_t
Length
(
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
GetTopOuter
(
)
;
nsresult
GetPrompter
(
nsIPrompt
*
*
aPrompt
)
override
;
RefPtr
<
mozilla
:
:
ThrottledEventQueue
>
mPostMessageEventQueue
;
protected
:
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
GetOpenerWindowOuter
(
)
;
void
InitWasOffline
(
)
;
public
:
nsPIDOMWindowOuter
*
GetSameProcessOpener
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
BrowsingContext
>
GetOpenerBrowsingContext
(
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
GetOpener
(
)
override
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
GetParentOuter
(
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetInProcessParent
(
)
override
;
nsPIDOMWindowOuter
*
GetInProcessScriptableParent
(
)
override
;
nsPIDOMWindowOuter
*
GetInProcessScriptableParentOrNull
(
)
override
;
mozilla
:
:
dom
:
:
Element
*
GetFrameElementOuter
(
nsIPrincipal
&
aSubjectPrincipal
)
;
mozilla
:
:
dom
:
:
Element
*
GetFrameElement
(
)
override
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
OpenOuter
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsDocShellLoadState
*
aLoadState
bool
aForceNoOpener
mozilla
:
:
dom
:
:
BrowsingContext
*
*
_retval
)
override
;
mozilla
:
:
dom
:
:
Navigator
*
GetNavigator
(
)
override
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
int16_t
Orientation
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
const
;
#
endif
protected
:
bool
AlertOrConfirm
(
bool
aAlert
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
public
:
void
AlertOuter
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
bool
ConfirmOuter
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
PromptOuter
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
PrintOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Selection
*
GetSelectionOuter
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Selection
>
GetSelection
(
)
override
;
already_AddRefed
<
mozilla
:
:
dom
:
:
MediaQueryList
>
MatchMediaOuter
(
const
nsAString
&
aQuery
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
nsScreen
*
GetScreen
(
)
;
void
MoveToOuter
(
int32_t
aXPos
int32_t
aYPos
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
MoveByOuter
(
int32_t
aXDif
int32_t
aYDif
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
MoveBy
(
int32_t
aXDif
int32_t
aYDif
)
override
;
void
ResizeToOuter
(
int32_t
aWidth
int32_t
aHeight
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
ResizeByOuter
(
int32_t
aWidthDif
int32_t
aHeightDif
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
double
GetScrollXOuter
(
)
;
double
GetScrollYOuter
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
SizeToContentOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
nsIControllers
*
GetControllersOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
override
;
mozilla
:
:
dom
:
:
Element
*
GetRealFrameElementOuter
(
)
;
float
GetMozInnerScreenXOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
float
GetMozInnerScreenYOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
double
GetDevicePixelRatioOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
bool
GetFullscreenOuter
(
)
;
bool
GetFullScreen
(
)
override
;
void
SetFullscreenOuter
(
bool
aFullscreen
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
SetFullScreen
(
bool
aFullscreen
)
override
;
bool
FindOuter
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
mozilla
:
:
ErrorResult
&
aError
)
;
uint64_t
GetMozPaintCountOuter
(
)
;
bool
ShouldResistFingerprinting
(
)
;
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
OpenDialogOuter
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
OpenDialog
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsISupports
*
aExtraArgument
mozilla
:
:
dom
:
:
BrowsingContext
*
*
_retval
)
override
;
void
UpdateCommands
(
const
nsAString
&
anAction
mozilla
:
:
dom
:
:
Selection
*
aSel
int16_t
aReason
)
override
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetContentInternal
(
mozilla
:
:
ErrorResult
&
aError
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
GetContentOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetContent
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetContentInternal
(
mozilla
:
:
IgnoreErrors
(
)
mozilla
:
:
dom
:
:
CallerType
:
:
System
)
;
return
win
.
forget
(
)
;
}
nsIBrowserDOMWindow
*
GetBrowserDOMWindowOuter
(
)
;
void
SetBrowserDOMWindowOuter
(
nsIBrowserDOMWindow
*
aBrowserWindow
)
;
void
SetCursorOuter
(
const
nsAString
&
aCursor
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetReturnValueOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetReturnValue
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetReturnValueOuter
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetReturnValue
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReturnValue
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsWindowRoot
>
GetWindowRootOuter
(
)
;
nsIDOMWindowUtils
*
WindowUtils
(
)
;
bool
HasOpenerForInitialContentBrowser
(
)
{
return
!
!
mOpenerForInitialContentBrowser
;
}
virtual
bool
IsInSyncOperation
(
)
override
{
return
GetExtantDoc
(
)
&
&
GetExtantDoc
(
)
-
>
IsInSyncOperation
(
)
;
}
void
ParentWindowChanged
(
)
{
mHasStorageAccess
=
false
;
}
public
:
int32_t
GetInnerWidthOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
protected
:
nsresult
GetInnerWidth
(
int32_t
*
aWidth
)
override
;
void
SetInnerWidthOuter
(
int32_t
aInnerWidth
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
public
:
int32_t
GetInnerHeightOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
protected
:
nsresult
GetInnerHeight
(
int32_t
*
aHeight
)
override
;
void
SetInnerHeightOuter
(
int32_t
aInnerHeight
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenXOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetScreenXOuter
(
int32_t
aScreenX
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenYOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetScreenYOuter
(
int32_t
aScreenY
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterWidthOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterWidthOuter
(
int32_t
aOuterWidth
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterHeightOuter
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterHeightOuter
(
int32_t
aOuterHeight
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
RefPtr
<
mozilla
:
:
dom
:
:
WakeLock
>
mWakeLock
;
friend
class
HashchangeCallback
;
friend
class
mozilla
:
:
dom
:
:
BarProp
;
virtual
~
nsGlobalWindowOuter
(
)
;
void
DropOuterWindowDocs
(
)
;
void
CleanUp
(
)
;
void
ClearControllers
(
)
;
void
FinalClose
(
)
;
inline
void
MaybeClearInnerWindow
(
nsGlobalWindowInner
*
aExpectedInner
)
;
nsPIDOMWindowOuter
*
GetInProcessParentInternal
(
)
;
protected
:
virtual
nsresult
OpenNoNavigate
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
mozilla
:
:
dom
:
:
BrowsingContext
*
*
_retval
)
override
;
private
:
explicit
nsGlobalWindowOuter
(
uint64_t
aWindowID
)
;
nsresult
OpenInternal
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
bool
aDialog
bool
aContentModal
bool
aCalledNoScript
bool
aDoJSFixups
bool
aNavigate
nsIArray
*
argv
nsISupports
*
aExtraArgument
nsDocShellLoadState
*
aLoadState
bool
aForceNoOpener
mozilla
:
:
dom
:
:
BrowsingContext
*
*
aReturn
)
;
static
bool
SameLoadingURI
(
Document
*
aDoc
nsIChannel
*
aChannel
)
;
public
:
already_AddRefed
<
nsIDocShellTreeOwner
>
GetTreeOwner
(
)
;
already_AddRefed
<
nsIBaseWindow
>
GetTreeOwnerWindow
(
)
;
already_AddRefed
<
nsIWebBrowserChrome
>
GetWebBrowserChrome
(
)
;
nsresult
SecurityCheckURL
(
const
char
*
aURL
nsIURI
*
*
aURI
)
;
bool
PopupWhitelisted
(
)
;
mozilla
:
:
dom
:
:
PopupBlocker
:
:
PopupControlState
RevisePopupAbuseLevel
(
mozilla
:
:
dom
:
:
PopupBlocker
:
:
PopupControlState
aState
)
;
void
FireAbuseEvents
(
const
nsAString
&
aPopupURL
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
;
private
:
void
ReportLargeAllocStatus
(
)
;
public
:
void
FlushPendingNotifications
(
mozilla
:
:
FlushType
aType
)
;
void
EnsureReflowFlushAndPaint
(
)
;
void
CheckSecurityWidthAndHeight
(
int32_t
*
width
int32_t
*
height
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
CheckSecurityLeftAndTop
(
int32_t
*
left
int32_t
*
top
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
void
SetCSSViewportWidthAndHeight
(
nscoord
width
nscoord
height
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SetDocShellWidthAndHeight
(
int32_t
width
int32_t
height
)
;
static
bool
CanSetProperty
(
const
char
*
aPrefName
)
;
static
void
MakeScriptDialogTitle
(
nsAString
&
aOutTitle
nsIPrincipal
*
aSubjectPrincipal
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
CanMoveResizeWindows
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
mozilla
:
:
CSSPoint
GetScrollXY
(
bool
aDoFlush
)
;
int32_t
GetScrollBoundaryOuter
(
mozilla
:
:
Side
aSide
)
;
nsresult
GetInnerSize
(
mozilla
:
:
CSSIntSize
&
aSize
)
;
nsIntSize
GetOuterSize
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterSize
(
int32_t
aLengthCSSPixels
bool
aIsWidth
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
nsRect
GetInnerScreenRect
(
)
;
static
Maybe
<
mozilla
:
:
CSSIntSize
>
GetRDMDeviceSize
(
const
Document
&
aDocument
)
;
bool
IsFrame
(
)
;
bool
WindowExists
(
const
nsAString
&
aName
bool
aForceNoOpener
bool
aLookForCallerOnJSStack
)
;
already_AddRefed
<
nsIWidget
>
GetMainWidget
(
)
;
nsIWidget
*
GetNearestWidget
(
)
const
;
bool
IsInModalState
(
)
;
bool
HasStorageAccess
(
)
const
{
return
mHasStorageAccess
;
}
void
SetHasStorageAccess
(
bool
aHasStorageAccess
)
{
mHasStorageAccess
=
aHasStorageAccess
;
}
int32_t
DevToCSSIntPixels
(
int32_t
px
)
;
int32_t
CSSToDevIntPixels
(
int32_t
px
)
;
nsIntSize
DevToCSSIntPixels
(
nsIntSize
px
)
;
nsIntSize
CSSToDevIntPixels
(
nsIntSize
px
)
;
virtual
void
SetFocusedElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
override
;
virtual
uint32_t
GetFocusMethod
(
)
override
;
virtual
bool
ShouldShowFocusRing
(
)
override
;
virtual
void
SetKeyboardIndicators
(
UIStateChangeType
aShowFocusRings
)
override
;
public
:
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
override
;
protected
:
void
NotifyWindowIDDestroyed
(
const
char
*
aTopic
)
;
void
ClearStatus
(
)
;
virtual
void
UpdateParentTarget
(
)
override
;
void
InitializeShowFocusRings
(
)
;
protected
:
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyleHelperOuter
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
)
;
void
PreloadLocalStorage
(
)
;
mozilla
:
:
CSSIntPoint
GetScreenXY
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aError
)
;
void
PostMessageMozOuter
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
;
public
:
bool
GetPrincipalForPostMessage
(
const
nsAString
&
aTargetOrigin
nsIURI
*
aTargetOriginURI
nsIPrincipal
*
aCallerPrincipal
nsIPrincipal
&
aSubjectPrincipal
nsIPrincipal
*
*
aProvidedPrincipal
)
;
private
:
static
bool
GatherPostMessageData
(
JSContext
*
aCx
const
nsAString
&
aTargetOrigin
mozilla
:
:
dom
:
:
BrowsingContext
*
*
aSource
nsAString
&
aOrigin
nsIURI
*
*
aTargetOriginURI
nsIPrincipal
*
*
aCallerPrincipal
nsGlobalWindowInner
*
*
aCallerInnerWindow
nsIURI
*
*
aCallerDocumentURI
Maybe
<
nsID
>
*
aCallerAgentClusterId
mozilla
:
:
ErrorResult
&
aError
)
;
bool
ConfirmDialogIfNeeded
(
)
;
void
CheckForDPIChange
(
)
;
private
:
enum
class
SecureContextFlags
{
eDefault
eIgnoreOpener
}
;
bool
ComputeIsSecureContext
(
Document
*
aDocument
SecureContextFlags
aFlags
=
SecureContextFlags
:
:
eDefault
)
;
void
SetDocShell
(
nsDocShell
*
aDocShell
)
;
friend
class
nsPIDOMWindowInner
;
friend
class
nsPIDOMWindowOuter
;
mozilla
:
:
dom
:
:
TabGroup
*
TabGroupOuter
(
)
;
void
SetIsBackgroundInternal
(
bool
aIsBackground
)
;
nsresult
GetInterfaceInternal
(
const
nsIID
&
aIID
void
*
*
aSink
)
;
void
MaybeAllowStorageForOpenedWindow
(
nsIURI
*
aURI
)
;
public
:
virtual
nsresult
Dispatch
(
mozilla
:
:
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
override
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
override
;
virtual
mozilla
:
:
AbstractThread
*
AbstractMainThreadFor
(
mozilla
:
:
TaskCategory
aCategory
)
override
;
protected
:
bool
mFullscreen
:
1
;
bool
mFullscreenMode
:
1
;
bool
mForceFullScreenInWidget
:
1
;
bool
mIsClosed
:
1
;
bool
mInClose
:
1
;
bool
mHavePendingClose
:
1
;
bool
mIsPopupSpam
:
1
;
bool
mBlockScriptedClosingFlag
:
1
;
bool
mWasOffline
:
1
;
bool
mCreatingInnerWindow
:
1
;
bool
mIsChrome
:
1
;
bool
mAllowScriptsToClose
:
1
;
bool
mTopLevelOuterContentWindow
:
1
;
bool
mHasStorageAccess
:
1
;
nsCOMPtr
<
nsIScriptContext
>
mContext
;
nsCOMPtr
<
nsIControllers
>
mControllers
;
nsCOMPtr
<
nsIArray
>
mArguments
;
RefPtr
<
nsDOMWindowUtils
>
mWindowUtils
;
nsString
mStatus
;
RefPtr
<
mozilla
:
:
dom
:
:
Storage
>
mLocalStorage
;
nsCOMPtr
<
nsIPrincipal
>
mDocumentPrincipal
;
nsCOMPtr
<
nsIPrincipal
>
mDocumentStoragePrincipal
;
#
ifdef
DEBUG
uint32_t
mSerial
;
bool
mSetOpenerWindowCalled
;
nsCOMPtr
<
nsIURI
>
mLastOpenedURI
;
#
endif
bool
mCleanedUp
;
RefPtr
<
Document
>
mSuspendedDoc
;
#
ifdef
DEBUG
bool
mIsValidatingTabGroup
;
#
endif
uint32_t
mCanSkipCCGeneration
;
uint32_t
mAutoActivateVRDisplayID
;
static
OuterWindowByIdTable
*
sOuterWindowsById
;
struct
ChromeFields
{
nsCOMPtr
<
nsIBrowserDOMWindow
>
mBrowserDOMWindow
;
nsWeakPtr
mFullscreenPresShell
;
}
mChromeFields
;
friend
class
nsDOMScriptableHelper
;
friend
class
nsDOMWindowUtils
;
friend
class
mozilla
:
:
dom
:
:
BrowsingContext
;
friend
class
mozilla
:
:
dom
:
:
PostMessageEvent
;
friend
class
DesktopNotification
;
friend
class
mozilla
:
:
dom
:
:
TimeoutManager
;
friend
class
nsGlobalWindowInner
;
}
;
#
include
"
nsGlobalWindowInner
.
h
"
inline
nsISupports
*
ToSupports
(
nsGlobalWindowOuter
*
p
)
{
return
static_cast
<
mozilla
:
:
dom
:
:
EventTarget
*
>
(
p
)
;
}
inline
nsISupports
*
ToCanonicalSupports
(
nsGlobalWindowOuter
*
p
)
{
return
static_cast
<
mozilla
:
:
dom
:
:
EventTarget
*
>
(
p
)
;
}
inline
nsIGlobalObject
*
nsGlobalWindowOuter
:
:
GetOwnerGlobal
(
)
const
{
return
GetCurrentInnerWindowInternal
(
)
;
}
inline
nsGlobalWindowOuter
*
nsGlobalWindowOuter
:
:
GetInProcessTopInternal
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
GetInProcessTop
(
)
;
if
(
top
)
{
return
nsGlobalWindowOuter
:
:
Cast
(
top
)
;
}
return
nullptr
;
}
inline
nsGlobalWindowOuter
*
nsGlobalWindowOuter
:
:
GetInProcessScriptableTopInternal
(
)
{
nsPIDOMWindowOuter
*
top
=
GetInProcessScriptableTop
(
)
;
return
nsGlobalWindowOuter
:
:
Cast
(
top
)
;
}
inline
nsIScriptContext
*
nsGlobalWindowOuter
:
:
GetContextInternal
(
)
{
return
mContext
;
}
inline
nsGlobalWindowInner
*
nsGlobalWindowOuter
:
:
GetCurrentInnerWindowInternal
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
mInnerWindow
)
;
}
inline
nsGlobalWindowInner
*
nsGlobalWindowOuter
:
:
EnsureInnerWindowInternal
(
)
{
return
nsGlobalWindowInner
:
:
Cast
(
EnsureInnerWindow
(
)
)
;
}
inline
bool
nsGlobalWindowOuter
:
:
IsTopLevelWindow
(
)
{
nsPIDOMWindowOuter
*
parentWindow
=
GetInProcessScriptableTop
(
)
;
return
parentWindow
=
=
this
;
}
inline
bool
nsGlobalWindowOuter
:
:
IsFrame
(
)
{
return
GetInProcessParentInternal
(
)
!
=
nullptr
;
}
inline
void
nsGlobalWindowOuter
:
:
MaybeClearInnerWindow
(
nsGlobalWindowInner
*
aExpectedInner
)
{
if
(
mInnerWindow
=
=
aExpectedInner
)
{
mInnerWindow
=
nullptr
;
}
}
#
endif
