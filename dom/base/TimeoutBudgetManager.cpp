#
include
"
TimeoutBudgetManager
.
h
"
namespace
mozilla
{
namespace
dom
{
const
uint32_t
kTelemetryPeriodMS
=
1000
;
static
TimeoutBudgetManager
gTimeoutBudgetManager
;
TimeoutBudgetManager
&
TimeoutBudgetManager
:
:
Get
(
)
{
return
gTimeoutBudgetManager
;
}
void
TimeoutBudgetManager
:
:
StartRecording
(
const
TimeStamp
&
aNow
)
{
mStart
=
aNow
;
}
void
TimeoutBudgetManager
:
:
StopRecording
(
)
{
mStart
=
TimeStamp
(
)
;
}
TimeDuration
TimeoutBudgetManager
:
:
RecordExecution
(
const
TimeStamp
&
aNow
bool
aIsTracking
bool
aIsBackground
)
{
if
(
!
mStart
)
{
return
TimeDuration
(
)
;
}
TimeDuration
duration
=
aNow
-
mStart
;
if
(
aIsBackground
)
{
if
(
aIsTracking
)
{
mTelemetryData
.
mBackgroundTracking
+
=
duration
;
}
else
{
mTelemetryData
.
mBackgroundNonTracking
+
=
duration
;
}
}
else
{
if
(
aIsTracking
)
{
mTelemetryData
.
mForegroundTracking
+
=
duration
;
}
else
{
mTelemetryData
.
mForegroundNonTracking
+
=
duration
;
}
}
return
duration
;
}
void
TimeoutBudgetManager
:
:
Accumulate
(
Telemetry
:
:
HistogramID
aId
const
TimeDuration
&
aSample
)
{
uint32_t
sample
=
std
:
:
round
(
aSample
.
ToMilliseconds
(
)
)
;
if
(
sample
)
{
Telemetry
:
:
Accumulate
(
aId
sample
)
;
}
}
void
TimeoutBudgetManager
:
:
MaybeCollectTelemetry
(
const
TimeStamp
&
aNow
)
{
if
(
(
aNow
-
mLastCollection
)
.
ToMilliseconds
(
)
<
kTelemetryPeriodMS
)
{
return
;
}
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_FG_TRACKING_MS
mTelemetryData
.
mForegroundTracking
)
;
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_FG_MS
mTelemetryData
.
mForegroundNonTracking
)
;
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_BG_TRACKING_MS
mTelemetryData
.
mBackgroundTracking
)
;
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_BG_MS
mTelemetryData
.
mBackgroundNonTracking
)
;
mTelemetryData
=
TelemetryData
(
)
;
mLastCollection
=
aNow
;
}
}
}
