#
include
"
mozilla
/
dom
/
Console
.
h
"
#
include
"
mozilla
/
dom
/
ConsoleBinding
.
h
"
#
include
"
mozilla
/
dom
/
BlobBinding
.
h
"
#
include
"
mozilla
/
dom
/
Exceptions
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneHolder
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsDocument
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPerformance
.
h
"
#
include
"
ScriptSettings
.
h
"
#
include
"
WorkerPrivate
.
h
"
#
include
"
WorkerRunnable
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
mozilla
/
ConsoleTimelineMarker
.
h
"
#
include
"
mozilla
/
TimestampTimelineMarker
.
h
"
#
include
"
nsIConsoleAPIStorage
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIProgrammingLanguage
.
h
"
#
include
"
nsISensitiveInfoHiddenURI
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
define
MAX_PAGE_TIMERS
10000
#
define
MAX_PAGE_COUNTERS
10000
#
define
DEFAULT_MAX_STACKTRACE_DEPTH
200
#
define
CONSOLE_TAG_BLOB
JS_SCTAG_USER_MIN
#
define
STORAGE_MAX_EVENTS
200
using
namespace
mozilla
:
:
dom
:
:
exceptions
;
using
namespace
mozilla
:
:
dom
:
:
workers
;
namespace
mozilla
{
namespace
dom
{
struct
ConsoleStructuredCloneData
{
nsCOMPtr
<
nsISupports
>
mParent
;
nsTArray
<
RefPtr
<
BlobImpl
>
>
mBlobs
;
}
;
class
ConsoleCallData
final
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
ConsoleCallData
)
ConsoleCallData
(
)
:
mMethodName
(
Console
:
:
MethodLog
)
mPrivate
(
false
)
mTimeStamp
(
JS_Now
(
)
/
PR_USEC_PER_MSEC
)
mStartTimerValue
(
0
)
mStartTimerStatus
(
false
)
mStopTimerDuration
(
0
)
mStopTimerStatus
(
false
)
mCountValue
(
MAX_PAGE_COUNTERS
)
mIDType
(
eUnknown
)
mOuterIDNumber
(
0
)
mInnerIDNumber
(
0
)
#
ifdef
DEBUG
mOwningThread
(
PR_GetCurrentThread
(
)
)
#
endif
{
}
bool
Initialize
(
JSContext
*
aCx
Console
:
:
MethodName
aName
const
nsAString
&
aString
const
Sequence
<
JS
:
:
Value
>
&
aArguments
Console
*
aConsole
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aConsole
)
;
aConsole
-
>
StoreCallData
(
this
)
;
mMethodName
=
aName
;
mMethodString
=
aString
;
for
(
uint32_t
i
=
0
;
i
<
aArguments
.
Length
(
)
;
+
+
i
)
{
if
(
NS_WARN_IF
(
!
mCopiedArguments
.
AppendElement
(
aArguments
[
i
]
)
)
)
{
aConsole
-
>
UnstoreCallData
(
this
)
;
return
false
;
}
}
return
true
;
}
void
SetIDs
(
uint64_t
aOuterID
uint64_t
aInnerID
)
{
MOZ_ASSERT
(
mIDType
=
=
eUnknown
)
;
mOuterIDNumber
=
aOuterID
;
mInnerIDNumber
=
aInnerID
;
mIDType
=
eNumber
;
}
void
SetIDs
(
const
nsAString
&
aOuterID
const
nsAString
&
aInnerID
)
{
MOZ_ASSERT
(
mIDType
=
=
eUnknown
)
;
mOuterIDString
=
aOuterID
;
mInnerIDString
=
aInnerID
;
mIDType
=
eString
;
}
void
Trace
(
const
TraceCallbacks
&
aCallbacks
void
*
aClosure
)
{
AssertIsOnOwningThread
(
)
;
ConsoleCallData
*
tmp
=
this
;
for
(
uint32_t
i
=
0
;
i
<
mCopiedArguments
.
Length
(
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mCopiedArguments
[
i
]
)
}
}
void
AssertIsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
mOwningThread
)
;
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
mOwningThread
)
;
}
nsTArray
<
JS
:
:
Heap
<
JS
:
:
Value
>
>
mCopiedArguments
;
Console
:
:
MethodName
mMethodName
;
bool
mPrivate
;
int64_t
mTimeStamp
;
DOMHighResTimeStamp
mStartTimerValue
;
nsString
mStartTimerLabel
;
bool
mStartTimerStatus
;
double
mStopTimerDuration
;
nsString
mStopTimerLabel
;
bool
mStopTimerStatus
;
nsString
mCountLabel
;
uint32_t
mCountValue
;
enum
{
eString
eNumber
eUnknown
}
mIDType
;
uint64_t
mOuterIDNumber
;
nsString
mOuterIDString
;
uint64_t
mInnerIDNumber
;
nsString
mInnerIDString
;
nsString
mMethodString
;
Maybe
<
ConsoleStackEntry
>
mTopStackFrame
;
Maybe
<
nsTArray
<
ConsoleStackEntry
>
>
mReifiedStack
;
nsCOMPtr
<
nsIStackFrame
>
mStack
;
enum
{
eUnused
eInUse
eToBeDeleted
}
mStatus
;
#
ifdef
DEBUG
PRThread
*
mOwningThread
;
#
endif
private
:
~
ConsoleCallData
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
!
=
eInUse
)
;
}
}
;
class
ClearException
{
public
:
explicit
ClearException
(
JSContext
*
aCx
)
:
mCx
(
aCx
)
{
}
~
ClearException
(
)
{
JS_ClearPendingException
(
mCx
)
;
}
private
:
JSContext
*
mCx
;
}
;
class
ConsoleRunnable
:
public
nsRunnable
public
WorkerFeature
public
StructuredCloneHolderBase
{
public
:
explicit
ConsoleRunnable
(
Console
*
aConsole
)
:
mWorkerPrivate
(
GetCurrentThreadWorkerPrivate
(
)
)
mConsole
(
aConsole
)
{
MOZ_ASSERT
(
mWorkerPrivate
)
;
}
virtual
~
ConsoleRunnable
(
)
{
Clear
(
)
;
}
bool
Dispatch
(
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
{
if
(
!
DispatchInternal
(
aGlobal
)
)
{
ReleaseData
(
)
;
return
false
;
}
return
true
;
}
virtual
bool
Notify
(
JSContext
*
aCx
workers
:
:
Status
aStatus
)
override
{
return
true
;
}
private
:
NS_IMETHOD
Run
(
)
override
{
AssertIsOnMainThread
(
)
;
WorkerPrivate
*
wp
=
mWorkerPrivate
;
while
(
wp
-
>
GetParent
(
)
)
{
wp
=
wp
-
>
GetParent
(
)
;
}
nsPIDOMWindowInner
*
window
=
wp
-
>
GetWindow
(
)
;
if
(
!
window
)
{
RunWindowless
(
)
;
}
else
{
RunWithWindow
(
window
)
;
}
PostDispatch
(
)
;
return
NS_OK
;
}
bool
DispatchInternal
(
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
JSContext
*
cx
=
mWorkerPrivate
-
>
GetJSContext
(
)
;
if
(
NS_WARN_IF
(
!
PreDispatch
(
cx
aGlobal
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
mWorkerPrivate
-
>
AddFeature
(
this
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
NS_FAILED
(
NS_DispatchToMainThread
(
this
)
)
)
)
{
return
false
;
}
return
true
;
}
void
PostDispatch
(
)
{
class
ConsoleReleaseRunnable
final
:
public
MainThreadWorkerControlRunnable
{
RefPtr
<
ConsoleRunnable
>
mRunnable
;
public
:
ConsoleReleaseRunnable
(
WorkerPrivate
*
aWorkerPrivate
ConsoleRunnable
*
aRunnable
)
:
MainThreadWorkerControlRunnable
(
aWorkerPrivate
)
mRunnable
(
aRunnable
)
{
MOZ_ASSERT
(
aRunnable
)
;
}
virtual
bool
WorkerRun
(
JSContext
*
aCx
workers
:
:
WorkerPrivate
*
aWorkerPrivate
)
override
{
MOZ_ASSERT
(
aWorkerPrivate
)
;
aWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mRunnable
-
>
ReleaseData
(
)
;
mRunnable
-
>
mConsole
=
nullptr
;
aWorkerPrivate
-
>
RemoveFeature
(
mRunnable
)
;
return
true
;
}
private
:
~
ConsoleReleaseRunnable
(
)
{
}
}
;
RefPtr
<
WorkerControlRunnable
>
runnable
=
new
ConsoleReleaseRunnable
(
mWorkerPrivate
this
)
;
NS_WARN_IF
(
!
runnable
-
>
Dispatch
(
)
)
;
}
void
RunWithWindow
(
nsPIDOMWindowInner
*
aWindow
)
{
AssertIsOnMainThread
(
)
;
AutoJSAPI
jsapi
;
MOZ_ASSERT
(
aWindow
)
;
RefPtr
<
nsGlobalWindow
>
win
=
nsGlobalWindow
:
:
Cast
(
aWindow
)
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
win
)
)
)
{
return
;
}
MOZ_ASSERT
(
aWindow
-
>
IsInnerWindow
(
)
)
;
nsPIDOMWindowOuter
*
outerWindow
=
aWindow
-
>
GetOuterWindow
(
)
;
if
(
NS_WARN_IF
(
!
outerWindow
)
)
{
return
;
}
RunConsole
(
jsapi
.
cx
(
)
outerWindow
aWindow
)
;
}
void
RunWindowless
(
)
{
AssertIsOnMainThread
(
)
;
WorkerPrivate
*
wp
=
mWorkerPrivate
;
while
(
wp
-
>
GetParent
(
)
)
{
wp
=
wp
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
!
wp
-
>
GetWindow
(
)
)
;
AutoSafeJSContext
cx
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
mConsole
-
>
GetOrCreateSandbox
(
cx
wp
-
>
GetPrincipal
(
)
)
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
;
}
global
=
js
:
:
UncheckedUnwrap
(
global
)
;
JSAutoCompartment
ac
(
cx
global
)
;
RunConsole
(
cx
nullptr
nullptr
)
;
}
protected
:
virtual
bool
PreDispatch
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
=
0
;
virtual
void
RunConsole
(
JSContext
*
aCx
nsPIDOMWindowOuter
*
aOuterWindow
nsPIDOMWindowInner
*
aInnerWindow
)
=
0
;
virtual
void
ReleaseData
(
)
=
0
;
virtual
JSObject
*
CustomReadHandler
(
JSContext
*
aCx
JSStructuredCloneReader
*
aReader
uint32_t
aTag
uint32_t
aIndex
)
override
{
AssertIsOnMainThread
(
)
;
if
(
aTag
=
=
CONSOLE_TAG_BLOB
)
{
MOZ_ASSERT
(
mClonedData
.
mBlobs
.
Length
(
)
>
aIndex
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCx
)
;
{
RefPtr
<
Blob
>
blob
=
Blob
:
:
Create
(
mClonedData
.
mParent
mClonedData
.
mBlobs
.
ElementAt
(
aIndex
)
)
;
if
(
!
ToJSValue
(
aCx
blob
&
val
)
)
{
return
nullptr
;
}
}
return
&
val
.
toObject
(
)
;
}
MOZ_CRASH
(
"
No
other
tags
are
supported
.
"
)
;
return
nullptr
;
}
virtual
bool
CustomWriteHandler
(
JSContext
*
aCx
JSStructuredCloneWriter
*
aWriter
JS
:
:
Handle
<
JSObject
*
>
aObj
)
override
{
RefPtr
<
Blob
>
blob
;
if
(
NS_SUCCEEDED
(
UNWRAP_OBJECT
(
Blob
aObj
blob
)
)
&
&
blob
-
>
Impl
(
)
-
>
MayBeClonedToOtherThreads
(
)
)
{
if
(
NS_WARN_IF
(
!
JS_WriteUint32Pair
(
aWriter
CONSOLE_TAG_BLOB
mClonedData
.
mBlobs
.
Length
(
)
)
)
)
{
return
false
;
}
mClonedData
.
mBlobs
.
AppendElement
(
blob
-
>
Impl
(
)
)
;
return
true
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
JS
:
:
ObjectOrNullValue
(
aObj
)
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
value
)
)
;
if
(
NS_WARN_IF
(
!
jsString
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
JS_WriteString
(
aWriter
jsString
)
)
)
{
return
false
;
}
return
true
;
}
WorkerPrivate
*
mWorkerPrivate
;
RefPtr
<
Console
>
mConsole
;
ConsoleStructuredCloneData
mClonedData
;
}
;
class
ConsoleCallDataRunnable
final
:
public
ConsoleRunnable
{
public
:
ConsoleCallDataRunnable
(
Console
*
aConsole
ConsoleCallData
*
aCallData
)
:
ConsoleRunnable
(
aConsole
)
mCallData
(
aCallData
)
{
MOZ_ASSERT
(
aCallData
)
;
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mCallData
-
>
AssertIsOnOwningThread
(
)
;
}
private
:
~
ConsoleCallDataRunnable
(
)
{
MOZ_ASSERT
(
!
mCallData
)
;
}
bool
PreDispatch
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
override
{
mWorkerPrivate
-
>
AssertIsOnWorkerThread
(
)
;
mCallData
-
>
AssertIsOnOwningThread
(
)
;
ClearException
ce
(
aCx
)
;
JSAutoCompartment
ac
(
aCx
aGlobal
)
;
JS
:
:
Rooted
<
JSObject
*
>
arguments
(
aCx
JS_NewArrayObject
(
aCx
mCallData
-
>
mCopiedArguments
.
Length
(
)
)
)
;
if
(
NS_WARN_IF
(
!
arguments
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
arg
(
aCx
)
;
for
(
uint32_t
i
=
0
;
i
<
mCallData
-
>
mCopiedArguments
.
Length
(
)
;
+
+
i
)
{
arg
=
mCallData
-
>
mCopiedArguments
[
i
]
;
if
(
NS_WARN_IF
(
!
JS_DefineElement
(
aCx
arguments
i
arg
JSPROP_ENUMERATE
)
)
)
{
return
false
;
}
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
JS
:
:
ObjectValue
(
*
arguments
)
)
;
if
(
NS_WARN_IF
(
!
Write
(
aCx
value
)
)
)
{
return
false
;
}
mCallData
-
>
mStatus
=
ConsoleCallData
:
:
eInUse
;
return
true
;
}
void
RunConsole
(
JSContext
*
aCx
nsPIDOMWindowOuter
*
aOuterWindow
nsPIDOMWindowInner
*
aInnerWindow
)
override
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
!
!
aOuterWindow
=
=
!
!
aInnerWindow
)
;
if
(
aOuterWindow
)
{
mCallData
-
>
SetIDs
(
aOuterWindow
-
>
WindowID
(
)
aInnerWindow
-
>
WindowID
(
)
)
;
}
else
{
ConsoleStackEntry
frame
;
if
(
mCallData
-
>
mTopStackFrame
)
{
frame
=
*
mCallData
-
>
mTopStackFrame
;
}
nsString
id
=
frame
.
mFilename
;
nsString
innerID
;
if
(
mWorkerPrivate
-
>
IsSharedWorker
(
)
)
{
innerID
=
NS_LITERAL_STRING
(
"
SharedWorker
"
)
;
}
else
if
(
mWorkerPrivate
-
>
IsServiceWorker
(
)
)
{
innerID
=
NS_LITERAL_STRING
(
"
ServiceWorker
"
)
;
id
.
AssignWithConversion
(
mWorkerPrivate
-
>
WorkerName
(
)
)
;
}
else
{
innerID
=
NS_LITERAL_STRING
(
"
Worker
"
)
;
}
mCallData
-
>
SetIDs
(
id
innerID
)
;
}
mClonedData
.
mParent
=
aInnerWindow
;
ProcessCallData
(
aCx
)
;
mClonedData
.
mParent
=
nullptr
;
}
virtual
void
ReleaseData
(
)
override
{
mConsole
-
>
AssertIsOnOwningThread
(
)
;
if
(
mCallData
-
>
mStatus
=
=
ConsoleCallData
:
:
eToBeDeleted
)
{
mConsole
-
>
ReleaseCallData
(
mCallData
)
;
}
else
{
MOZ_ASSERT
(
mCallData
-
>
mStatus
=
=
ConsoleCallData
:
:
eInUse
)
;
mCallData
-
>
mStatus
=
ConsoleCallData
:
:
eUnused
;
}
mCallData
=
nullptr
;
}
void
ProcessCallData
(
JSContext
*
aCx
)
{
AssertIsOnMainThread
(
)
;
ClearException
ce
(
aCx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
argumentsValue
(
aCx
)
;
if
(
!
Read
(
aCx
&
argumentsValue
)
)
{
return
;
}
MOZ_ASSERT
(
argumentsValue
.
isObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
argumentsObj
(
aCx
&
argumentsValue
.
toObject
(
)
)
;
uint32_t
length
;
if
(
!
JS_GetArrayLength
(
aCx
argumentsObj
&
length
)
)
{
return
;
}
Sequence
<
JS
:
:
Value
>
values
;
SequenceRooter
<
JS
:
:
Value
>
arguments
(
aCx
&
values
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
JS_GetElement
(
aCx
argumentsObj
i
&
value
)
)
{
return
;
}
if
(
!
values
.
AppendElement
(
value
fallible
)
)
{
return
;
}
}
MOZ_ASSERT
(
values
.
Length
(
)
=
=
length
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
mConsole
-
>
ProcessCallData
(
mCallData
global
values
)
;
}
RefPtr
<
ConsoleCallData
>
mCallData
;
}
;
class
ConsoleProfileRunnable
final
:
public
ConsoleRunnable
{
public
:
ConsoleProfileRunnable
(
Console
*
aConsole
const
nsAString
&
aAction
const
Sequence
<
JS
:
:
Value
>
&
aArguments
)
:
ConsoleRunnable
(
aConsole
)
mAction
(
aAction
)
mArguments
(
aArguments
)
{
MOZ_ASSERT
(
aConsole
)
;
}
private
:
bool
PreDispatch
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
)
override
{
ClearException
ce
(
aCx
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
aGlobal
)
;
if
(
NS_WARN_IF
(
!
global
)
)
{
return
false
;
}
JSAutoCompartment
ac
(
aCx
global
)
;
JS
:
:
Rooted
<
JSObject
*
>
arguments
(
aCx
JS_NewArrayObject
(
aCx
mArguments
.
Length
(
)
)
)
;
if
(
NS_WARN_IF
(
!
arguments
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
arg
(
aCx
)
;
for
(
uint32_t
i
=
0
;
i
<
mArguments
.
Length
(
)
;
+
+
i
)
{
arg
=
mArguments
[
i
]
;
if
(
NS_WARN_IF
(
!
JS_DefineElement
(
aCx
arguments
i
arg
JSPROP_ENUMERATE
)
)
)
{
return
false
;
}
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
JS
:
:
ObjectValue
(
*
arguments
)
)
;
if
(
NS_WARN_IF
(
!
Write
(
aCx
value
)
)
)
{
return
false
;
}
return
true
;
}
void
RunConsole
(
JSContext
*
aCx
nsPIDOMWindowOuter
*
aOuterWindow
nsPIDOMWindowInner
*
aInnerWindow
)
override
{
AssertIsOnMainThread
(
)
;
ClearException
ce
(
aCx
)
;
mClonedData
.
mParent
=
aInnerWindow
;
JS
:
:
Rooted
<
JS
:
:
Value
>
argumentsValue
(
aCx
)
;
bool
ok
=
Read
(
aCx
&
argumentsValue
)
;
mClonedData
.
mParent
=
nullptr
;
if
(
!
ok
)
{
return
;
}
MOZ_ASSERT
(
argumentsValue
.
isObject
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
argumentsObj
(
aCx
&
argumentsValue
.
toObject
(
)
)
;
uint32_t
length
;
if
(
!
JS_GetArrayLength
(
aCx
argumentsObj
&
length
)
)
{
return
;
}
Sequence
<
JS
:
:
Value
>
arguments
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
JS_GetElement
(
aCx
argumentsObj
i
&
value
)
)
{
return
;
}
if
(
!
arguments
.
AppendElement
(
value
fallible
)
)
{
return
;
}
}
mConsole
-
>
ProfileMethod
(
aCx
mAction
arguments
)
;
}
virtual
void
ReleaseData
(
)
override
{
}
nsString
mAction
;
const
Sequence
<
JS
:
:
Value
>
&
mArguments
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Console
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Console
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
)
tmp
-
>
Shutdown
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Console
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
Console
)
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mCallDataStorage
.
Length
(
)
;
+
+
i
)
{
tmp
-
>
mCallDataStorage
[
i
]
-
>
Trace
(
aCallbacks
aClosure
)
;
}
for
(
uint32_t
i
=
0
;
i
<
tmp
-
>
mCallDataStoragePending
.
Length
(
)
;
+
+
i
)
{
tmp
-
>
mCallDataStoragePending
[
i
]
-
>
Trace
(
aCallbacks
aClosure
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Console
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
Console
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
Console
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIObserver
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END
already_AddRefed
<
Console
>
Console
:
:
Create
(
nsPIDOMWindowInner
*
aWindow
ErrorResult
&
aRv
)
{
RefPtr
<
Console
>
console
=
new
Console
(
aWindow
)
;
console
-
>
Initialize
(
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
return
console
.
forget
(
)
;
}
Console
:
:
Console
(
nsPIDOMWindowInner
*
aWindow
)
:
mWindow
(
aWindow
)
#
ifdef
DEBUG
mOwningThread
(
PR_GetCurrentThread
(
)
)
#
endif
mOuterID
(
0
)
mInnerID
(
0
)
mStatus
(
eUnknown
)
{
if
(
mWindow
)
{
MOZ_ASSERT
(
mWindow
-
>
IsInnerWindow
(
)
)
;
mInnerID
=
mWindow
-
>
WindowID
(
)
;
nsPIDOMWindowOuter
*
outerWindow
=
mWindow
-
>
GetOuterWindow
(
)
;
if
(
outerWindow
)
{
mOuterID
=
outerWindow
-
>
WindowID
(
)
;
}
}
mozilla
:
:
HoldJSObjects
(
this
)
;
}
Console
:
:
~
Console
(
)
{
AssertIsOnOwningThread
(
)
;
Shutdown
(
)
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
void
Console
:
:
Initialize
(
ErrorResult
&
aRv
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eUnknown
)
;
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
NS_WARN_IF
(
!
obs
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aRv
=
obs
-
>
AddObserver
(
this
"
inner
-
window
-
destroyed
"
true
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
}
mStatus
=
eInitialized
;
}
void
Console
:
:
Shutdown
(
)
{
AssertIsOnOwningThread
(
)
;
if
(
mStatus
=
=
eUnknown
|
|
mStatus
=
=
eShuttingDown
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
inner
-
window
-
destroyed
"
)
;
}
}
NS_ReleaseOnMainThread
(
mStorage
.
forget
(
)
)
;
NS_ReleaseOnMainThread
(
mSandbox
.
forget
(
)
)
;
mTimerRegistry
.
Clear
(
)
;
mCounterRegistry
.
Clear
(
)
;
mCallDataStorage
.
Clear
(
)
;
mCallDataStoragePending
.
Clear
(
)
;
mStatus
=
eShuttingDown
;
}
NS_IMETHODIMP
Console
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
AssertIsOnMainThread
(
)
;
if
(
strcmp
(
aTopic
"
inner
-
window
-
destroyed
"
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISupportsPRUint64
>
wrapper
=
do_QueryInterface
(
aSubject
)
;
NS_ENSURE_TRUE
(
wrapper
NS_ERROR_FAILURE
)
;
uint64_t
innerID
;
nsresult
rv
=
wrapper
-
>
GetData
(
&
innerID
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
innerID
=
=
mInnerID
)
{
Shutdown
(
)
;
}
return
NS_OK
;
}
JSObject
*
Console
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
ConsoleBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
#
define
METHOD
(
name
string
)
\
void
\
Console
:
:
name
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
)
\
{
\
Method
(
aCx
Method
#
#
name
NS_LITERAL_STRING
(
string
)
aData
)
;
\
}
METHOD
(
Log
"
log
"
)
METHOD
(
Info
"
info
"
)
METHOD
(
Warn
"
warn
"
)
METHOD
(
Error
"
error
"
)
METHOD
(
Exception
"
exception
"
)
METHOD
(
Debug
"
debug
"
)
METHOD
(
Table
"
table
"
)
void
Console
:
:
Trace
(
JSContext
*
aCx
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
const
Sequence
<
JS
:
:
Value
>
data
;
Method
(
aCx
MethodTrace
NS_LITERAL_STRING
(
"
trace
"
)
data
)
;
}
METHOD
(
Dir
"
dir
"
)
;
METHOD
(
Dirxml
"
dirxml
"
)
;
METHOD
(
Group
"
group
"
)
METHOD
(
GroupCollapsed
"
groupCollapsed
"
)
METHOD
(
GroupEnd
"
groupEnd
"
)
void
Console
:
:
Time
(
JSContext
*
aCx
const
JS
:
:
Handle
<
JS
:
:
Value
>
aTime
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
Sequence
<
JS
:
:
Value
>
data
;
SequenceRooter
<
JS
:
:
Value
>
rooter
(
aCx
&
data
)
;
if
(
!
aTime
.
isUndefined
(
)
&
&
!
data
.
AppendElement
(
aTime
fallible
)
)
{
return
;
}
Method
(
aCx
MethodTime
NS_LITERAL_STRING
(
"
time
"
)
data
)
;
}
void
Console
:
:
TimeEnd
(
JSContext
*
aCx
const
JS
:
:
Handle
<
JS
:
:
Value
>
aTime
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
Sequence
<
JS
:
:
Value
>
data
;
SequenceRooter
<
JS
:
:
Value
>
rooter
(
aCx
&
data
)
;
if
(
!
aTime
.
isUndefined
(
)
&
&
!
data
.
AppendElement
(
aTime
fallible
)
)
{
return
;
}
Method
(
aCx
MethodTimeEnd
NS_LITERAL_STRING
(
"
timeEnd
"
)
data
)
;
}
void
Console
:
:
TimeStamp
(
JSContext
*
aCx
const
JS
:
:
Handle
<
JS
:
:
Value
>
aData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
Sequence
<
JS
:
:
Value
>
data
;
SequenceRooter
<
JS
:
:
Value
>
rooter
(
aCx
&
data
)
;
if
(
aData
.
isString
(
)
&
&
!
data
.
AppendElement
(
aData
fallible
)
)
{
return
;
}
Method
(
aCx
MethodTimeStamp
NS_LITERAL_STRING
(
"
timeStamp
"
)
data
)
;
}
void
Console
:
:
Profile
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
ProfileMethod
(
aCx
NS_LITERAL_STRING
(
"
profile
"
)
aData
)
;
}
void
Console
:
:
ProfileEnd
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
ProfileMethod
(
aCx
NS_LITERAL_STRING
(
"
profileEnd
"
)
aData
)
;
}
void
Console
:
:
ProfileMethod
(
JSContext
*
aCx
const
nsAString
&
aAction
const
Sequence
<
JS
:
:
Value
>
&
aData
)
{
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
if
(
!
NS_IsMainThread
(
)
)
{
RefPtr
<
ConsoleProfileRunnable
>
runnable
=
new
ConsoleProfileRunnable
(
this
aAction
aData
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
runnable
-
>
Dispatch
(
global
)
;
return
;
}
ClearException
ce
(
aCx
)
;
RootedDictionary
<
ConsoleProfileEvent
>
event
(
aCx
)
;
event
.
mAction
=
aAction
;
event
.
mArguments
.
Construct
(
)
;
Sequence
<
JS
:
:
Value
>
&
sequence
=
event
.
mArguments
.
Value
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aData
.
Length
(
)
;
+
+
i
)
{
if
(
!
sequence
.
AppendElement
(
aData
[
i
]
fallible
)
)
{
return
;
}
}
JS
:
:
Rooted
<
JS
:
:
Value
>
eventValue
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
event
&
eventValue
)
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
eventObj
(
aCx
&
eventValue
.
toObject
(
)
)
;
MOZ_ASSERT
(
eventObj
)
;
if
(
!
JS_DefineProperty
(
aCx
eventObj
"
wrappedJSObject
"
eventValue
JSPROP_ENUMERATE
)
)
{
return
;
}
nsXPConnect
*
xpc
=
nsXPConnect
:
:
XPConnect
(
)
;
nsCOMPtr
<
nsISupports
>
wrapper
;
const
nsIID
&
iid
=
NS_GET_IID
(
nsISupports
)
;
if
(
NS_FAILED
(
xpc
-
>
WrapJS
(
aCx
eventObj
iid
getter_AddRefs
(
wrapper
)
)
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
wrapper
"
console
-
api
-
profiler
"
nullptr
)
;
}
}
void
Console
:
:
Assert
(
JSContext
*
aCx
bool
aCondition
const
Sequence
<
JS
:
:
Value
>
&
aData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
if
(
!
aCondition
)
{
Method
(
aCx
MethodAssert
NS_LITERAL_STRING
(
"
assert
"
)
aData
)
;
}
}
METHOD
(
Count
"
count
"
)
void
Console
:
:
NoopMethod
(
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
}
static
nsresult
StackFrameToStackEntry
(
JSContext
*
aCx
nsIStackFrame
*
aStackFrame
ConsoleStackEntry
&
aStackEntry
)
{
MOZ_ASSERT
(
aStackFrame
)
;
nsresult
rv
=
aStackFrame
-
>
GetFilename
(
aCx
aStackEntry
.
mFilename
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
lineNumber
;
rv
=
aStackFrame
-
>
GetLineNumber
(
aCx
&
lineNumber
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aStackEntry
.
mLineNumber
=
lineNumber
;
int32_t
columnNumber
;
rv
=
aStackFrame
-
>
GetColumnNumber
(
aCx
&
columnNumber
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aStackEntry
.
mColumnNumber
=
columnNumber
;
rv
=
aStackFrame
-
>
GetName
(
aCx
aStackEntry
.
mFunctionName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsString
cause
;
rv
=
aStackFrame
-
>
GetAsyncCause
(
aCx
cause
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
cause
.
IsEmpty
(
)
)
{
aStackEntry
.
mAsyncCause
.
Construct
(
cause
)
;
}
aStackEntry
.
mLanguage
=
nsIProgrammingLanguage
:
:
JAVASCRIPT
;
return
NS_OK
;
}
static
nsresult
ReifyStack
(
JSContext
*
aCx
nsIStackFrame
*
aStack
nsTArray
<
ConsoleStackEntry
>
&
aRefiedStack
)
{
nsCOMPtr
<
nsIStackFrame
>
stack
(
aStack
)
;
while
(
stack
)
{
ConsoleStackEntry
&
data
=
*
aRefiedStack
.
AppendElement
(
)
;
nsresult
rv
=
StackFrameToStackEntry
(
aCx
stack
data
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIStackFrame
>
caller
;
rv
=
stack
-
>
GetCaller
(
aCx
getter_AddRefs
(
caller
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
caller
)
{
rv
=
stack
-
>
GetAsyncCaller
(
aCx
getter_AddRefs
(
caller
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
stack
.
swap
(
caller
)
;
}
return
NS_OK
;
}
void
Console
:
:
Method
(
JSContext
*
aCx
MethodName
aMethodName
const
nsAString
&
aMethodString
const
Sequence
<
JS
:
:
Value
>
&
aData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
mStatus
=
=
eInitialized
)
;
RefPtr
<
ConsoleCallData
>
callData
(
new
ConsoleCallData
(
)
)
;
ClearException
ce
(
aCx
)
;
if
(
NS_WARN_IF
(
!
callData
-
>
Initialize
(
aCx
aMethodName
aMethodString
aData
this
)
)
)
{
return
;
}
if
(
mWindow
)
{
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_GetInterface
(
mWindow
)
;
if
(
!
webNav
)
{
return
;
}
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_QueryInterface
(
webNav
)
;
MOZ_ASSERT
(
loadContext
)
;
loadContext
-
>
GetUsePrivateBrowsing
(
&
callData
-
>
mPrivate
)
;
}
uint32_t
maxDepth
=
ShouldIncludeStackTrace
(
aMethodName
)
?
DEFAULT_MAX_STACKTRACE_DEPTH
:
1
;
nsCOMPtr
<
nsIStackFrame
>
stack
=
CreateStack
(
aCx
maxDepth
)
;
if
(
stack
)
{
callData
-
>
mTopStackFrame
.
emplace
(
)
;
nsresult
rv
=
StackFrameToStackEntry
(
aCx
stack
*
callData
-
>
mTopStackFrame
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
if
(
NS_IsMainThread
(
)
)
{
callData
-
>
mStack
=
stack
;
}
else
{
callData
-
>
mReifiedStack
.
emplace
(
)
;
nsresult
rv
=
ReifyStack
(
aCx
stack
*
callData
-
>
mReifiedStack
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
}
DOMHighResTimeStamp
monotonicTimer
;
if
(
aMethodName
=
=
MethodTime
|
|
aMethodName
=
=
MethodTimeEnd
|
|
aMethodName
=
=
MethodTimeStamp
)
{
if
(
mWindow
)
{
nsGlobalWindow
*
win
=
nsGlobalWindow
:
:
Cast
(
mWindow
)
;
MOZ_ASSERT
(
win
)
;
RefPtr
<
nsPerformance
>
performance
=
win
-
>
GetPerformance
(
)
;
if
(
!
performance
)
{
return
;
}
monotonicTimer
=
performance
-
>
Now
(
)
;
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
mWindow
-
>
GetDocShell
(
)
)
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
isTimelineRecording
=
timelines
&
&
timelines
-
>
HasConsumer
(
docShell
)
;
if
(
isTimelineRecording
&
&
aMethodName
=
=
MethodTimeStamp
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
aData
.
Length
(
)
=
=
0
?
JS_GetEmptyStringValue
(
aCx
)
:
aData
[
0
]
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
value
)
)
;
nsAutoJSString
key
;
if
(
jsString
)
{
key
.
init
(
aCx
jsString
)
;
}
timelines
-
>
AddMarkerForDocShell
(
docShell
Move
(
MakeUnique
<
TimestampTimelineMarker
>
(
key
)
)
)
;
}
else
if
(
isTimelineRecording
&
&
aData
.
Length
(
)
=
=
1
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
aData
[
0
]
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
value
)
)
;
if
(
jsString
)
{
nsAutoJSString
key
;
if
(
key
.
init
(
aCx
jsString
)
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
Move
(
MakeUnique
<
ConsoleTimelineMarker
>
(
key
aMethodName
=
=
MethodTime
?
MarkerTracingType
:
:
START
:
MarkerTracingType
:
:
END
)
)
)
;
}
}
}
}
else
{
WorkerPrivate
*
workerPrivate
=
GetCurrentThreadWorkerPrivate
(
)
;
MOZ_ASSERT
(
workerPrivate
)
;
TimeDuration
duration
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
-
workerPrivate
-
>
NowBaseTimeStamp
(
)
;
monotonicTimer
=
duration
.
ToMilliseconds
(
)
;
}
}
if
(
aMethodName
=
=
MethodTime
&
&
!
aData
.
IsEmpty
(
)
)
{
callData
-
>
mStartTimerStatus
=
StartTimer
(
aCx
aData
[
0
]
monotonicTimer
callData
-
>
mStartTimerLabel
&
callData
-
>
mStartTimerValue
)
;
}
else
if
(
aMethodName
=
=
MethodTimeEnd
&
&
!
aData
.
IsEmpty
(
)
)
{
callData
-
>
mStopTimerStatus
=
StopTimer
(
aCx
aData
[
0
]
monotonicTimer
callData
-
>
mStopTimerLabel
&
callData
-
>
mStopTimerDuration
)
;
}
else
if
(
aMethodName
=
=
MethodCount
)
{
ConsoleStackEntry
frame
;
if
(
callData
-
>
mTopStackFrame
)
{
frame
=
*
callData
-
>
mTopStackFrame
;
}
callData
-
>
mCountValue
=
IncreaseCounter
(
aCx
frame
aData
callData
-
>
mCountLabel
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
if
(
NS_IsMainThread
(
)
)
{
callData
-
>
SetIDs
(
mOuterID
mInnerID
)
;
ProcessCallData
(
callData
global
aData
)
;
UnstoreCallData
(
callData
)
;
return
;
}
RefPtr
<
ConsoleCallDataRunnable
>
runnable
=
new
ConsoleCallDataRunnable
(
this
callData
)
;
NS_WARN_IF
(
!
runnable
-
>
Dispatch
(
global
)
)
;
}
enum
{
SLOT_STACKOBJ
SLOT_RAW_STACK
}
;
bool
LazyStackGetter
(
JSContext
*
aCx
unsigned
aArgc
JS
:
:
Value
*
aVp
)
{
JS
:
:
CallArgs
args
=
CallArgsFromVp
(
aArgc
aVp
)
;
JS
:
:
Rooted
<
JSObject
*
>
callee
(
aCx
&
args
.
callee
(
)
)
;
JS
:
:
Value
v
=
js
:
:
GetFunctionNativeReserved
(
&
args
.
callee
(
)
SLOT_RAW_STACK
)
;
if
(
v
.
isUndefined
(
)
)
{
args
.
rval
(
)
.
set
(
js
:
:
GetFunctionNativeReserved
(
callee
SLOT_STACKOBJ
)
)
;
return
true
;
}
nsIStackFrame
*
stack
=
reinterpret_cast
<
nsIStackFrame
*
>
(
v
.
toPrivate
(
)
)
;
nsTArray
<
ConsoleStackEntry
>
reifiedStack
;
nsresult
rv
=
ReifyStack
(
aCx
stack
reifiedStack
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
Throw
(
aCx
rv
)
;
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
stackVal
(
aCx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
aCx
reifiedStack
&
stackVal
)
)
)
{
return
false
;
}
MOZ_ASSERT
(
stackVal
.
isObject
(
)
)
;
js
:
:
SetFunctionNativeReserved
(
callee
SLOT_STACKOBJ
stackVal
)
;
js
:
:
SetFunctionNativeReserved
(
callee
SLOT_RAW_STACK
JS
:
:
UndefinedValue
(
)
)
;
args
.
rval
(
)
.
set
(
stackVal
)
;
return
true
;
}
void
Console
:
:
ProcessCallData
(
ConsoleCallData
*
aData
JS
:
:
Handle
<
JSObject
*
>
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aArguments
)
{
AssertIsOnMainThread
(
)
;
MOZ_ASSERT
(
aData
)
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
aGlobal
)
)
{
return
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
eventValue
(
cx
)
;
if
(
NS_WARN_IF
(
!
PopulateEvent
(
cx
aGlobal
aArguments
&
eventValue
aData
)
)
)
{
return
;
}
if
(
!
mStorage
)
{
mStorage
=
do_GetService
(
"
mozilla
.
org
/
consoleAPI
-
storage
;
1
"
)
;
}
if
(
!
mStorage
)
{
NS_WARNING
(
"
Failed
to
get
the
ConsoleAPIStorage
service
.
"
)
;
return
;
}
nsAutoString
innerID
outerID
;
MOZ_ASSERT
(
aData
-
>
mIDType
!
=
ConsoleCallData
:
:
eUnknown
)
;
if
(
aData
-
>
mIDType
=
=
ConsoleCallData
:
:
eString
)
{
outerID
=
aData
-
>
mOuterIDString
;
innerID
=
aData
-
>
mInnerIDString
;
}
else
{
MOZ_ASSERT
(
aData
-
>
mIDType
=
=
ConsoleCallData
:
:
eNumber
)
;
outerID
.
AppendInt
(
aData
-
>
mOuterIDNumber
)
;
innerID
.
AppendInt
(
aData
-
>
mInnerIDNumber
)
;
}
if
(
NS_FAILED
(
mStorage
-
>
RecordEvent
(
innerID
outerID
eventValue
)
)
)
{
NS_WARNING
(
"
Failed
to
record
a
console
event
.
"
)
;
}
}
bool
Console
:
:
PopulateEvent
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
const
Sequence
<
JS
:
:
Value
>
&
aArguments
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aEventValue
ConsoleCallData
*
aData
)
const
{
MOZ_ASSERT
(
aCx
)
;
MOZ_ASSERT
(
aData
)
;
ConsoleStackEntry
frame
;
if
(
aData
-
>
mTopStackFrame
)
{
frame
=
*
aData
-
>
mTopStackFrame
;
}
ClearException
ce
(
aCx
)
;
RootedDictionary
<
ConsoleEvent
>
event
(
aCx
)
;
JSAutoCompartment
ac
(
aCx
aGlobal
)
;
event
.
mID
.
Construct
(
)
;
event
.
mInnerID
.
Construct
(
)
;
if
(
aData
-
>
mIDType
=
=
ConsoleCallData
:
:
eString
)
{
event
.
mID
.
Value
(
)
.
SetAsString
(
)
=
aData
-
>
mOuterIDString
;
event
.
mInnerID
.
Value
(
)
.
SetAsString
(
)
=
aData
-
>
mInnerIDString
;
}
else
if
(
aData
-
>
mIDType
=
=
ConsoleCallData
:
:
eNumber
)
{
event
.
mID
.
Value
(
)
.
SetAsUnsignedLongLong
(
)
=
aData
-
>
mOuterIDNumber
;
event
.
mInnerID
.
Value
(
)
.
SetAsUnsignedLongLong
(
)
=
aData
-
>
mInnerIDNumber
;
}
else
{
event
.
mID
.
Value
(
)
.
SetAsUnsignedLongLong
(
)
=
0
;
event
.
mInnerID
.
Value
(
)
.
SetAsUnsignedLongLong
(
)
=
0
;
}
event
.
mLevel
=
aData
-
>
mMethodString
;
event
.
mFilename
=
frame
.
mFilename
;
nsCOMPtr
<
nsIURI
>
filenameURI
;
nsAutoCString
pass
;
if
(
NS_IsMainThread
(
)
&
&
NS_SUCCEEDED
(
NS_NewURI
(
getter_AddRefs
(
filenameURI
)
frame
.
mFilename
)
)
&
&
NS_SUCCEEDED
(
filenameURI
-
>
GetPassword
(
pass
)
)
&
&
!
pass
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsISensitiveInfoHiddenURI
>
safeURI
=
do_QueryInterface
(
filenameURI
)
;
nsAutoCString
spec
;
if
(
safeURI
&
&
NS_SUCCEEDED
(
safeURI
-
>
GetSensitiveInfoHiddenSpec
(
spec
)
)
)
{
CopyUTF8toUTF16
(
spec
event
.
mFilename
)
;
}
}
event
.
mLineNumber
=
frame
.
mLineNumber
;
event
.
mColumnNumber
=
frame
.
mColumnNumber
;
event
.
mFunctionName
=
frame
.
mFunctionName
;
event
.
mTimeStamp
=
aData
-
>
mTimeStamp
;
event
.
mPrivate
=
aData
-
>
mPrivate
;
switch
(
aData
-
>
mMethodName
)
{
case
MethodLog
:
case
MethodInfo
:
case
MethodWarn
:
case
MethodError
:
case
MethodException
:
case
MethodDebug
:
case
MethodAssert
:
event
.
mArguments
.
Construct
(
)
;
event
.
mStyles
.
Construct
(
)
;
if
(
NS_WARN_IF
(
!
ProcessArguments
(
aCx
aArguments
event
.
mArguments
.
Value
(
)
event
.
mStyles
.
Value
(
)
)
)
)
{
return
false
;
}
break
;
default
:
event
.
mArguments
.
Construct
(
)
;
if
(
NS_WARN_IF
(
!
ArgumentsToValueList
(
aArguments
event
.
mArguments
.
Value
(
)
)
)
)
{
return
false
;
}
}
if
(
aData
-
>
mMethodName
=
=
MethodGroup
|
|
aData
-
>
mMethodName
=
=
MethodGroupCollapsed
|
|
aData
-
>
mMethodName
=
=
MethodGroupEnd
)
{
ComposeGroupName
(
aCx
aArguments
event
.
mGroupName
)
;
}
else
if
(
aData
-
>
mMethodName
=
=
MethodTime
&
&
!
aArguments
.
IsEmpty
(
)
)
{
event
.
mTimer
=
CreateStartTimerValue
(
aCx
aData
-
>
mStartTimerLabel
aData
-
>
mStartTimerValue
aData
-
>
mStartTimerStatus
)
;
}
else
if
(
aData
-
>
mMethodName
=
=
MethodTimeEnd
&
&
!
aArguments
.
IsEmpty
(
)
)
{
event
.
mTimer
=
CreateStopTimerValue
(
aCx
aData
-
>
mStopTimerLabel
aData
-
>
mStopTimerDuration
aData
-
>
mStopTimerStatus
)
;
}
else
if
(
aData
-
>
mMethodName
=
=
MethodCount
)
{
event
.
mCounter
=
CreateCounterValue
(
aCx
aData
-
>
mCountLabel
aData
-
>
mCountValue
)
;
}
JSAutoCompartment
ac2
(
aCx
xpc
:
:
PrivilegedJunkScope
(
)
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
aCx
event
aEventValue
)
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
eventObj
(
aCx
&
aEventValue
.
toObject
(
)
)
;
if
(
NS_WARN_IF
(
!
JS_DefineProperty
(
aCx
eventObj
"
wrappedJSObject
"
eventObj
JSPROP_ENUMERATE
)
)
)
{
return
false
;
}
if
(
ShouldIncludeStackTrace
(
aData
-
>
mMethodName
)
)
{
if
(
aData
-
>
mReifiedStack
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
stacktrace
(
aCx
)
;
if
(
NS_WARN_IF
(
!
ToJSValue
(
aCx
*
aData
-
>
mReifiedStack
&
stacktrace
)
)
|
|
NS_WARN_IF
(
!
JS_DefineProperty
(
aCx
eventObj
"
stacktrace
"
stacktrace
JSPROP_ENUMERATE
)
)
)
{
return
false
;
}
}
else
{
JSFunction
*
fun
=
js
:
:
NewFunctionWithReserved
(
aCx
LazyStackGetter
0
0
"
stacktrace
"
)
;
if
(
NS_WARN_IF
(
!
fun
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
funObj
(
aCx
JS_GetFunctionObject
(
fun
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
stackVal
(
aCx
)
;
nsresult
rv
=
nsContentUtils
:
:
WrapNative
(
aCx
aData
-
>
mStack
&
stackVal
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
js
:
:
SetFunctionNativeReserved
(
funObj
SLOT_STACKOBJ
stackVal
)
;
js
:
:
SetFunctionNativeReserved
(
funObj
SLOT_RAW_STACK
JS
:
:
PrivateValue
(
aData
-
>
mStack
.
get
(
)
)
)
;
if
(
NS_WARN_IF
(
!
JS_DefineProperty
(
aCx
eventObj
"
stacktrace
"
JS
:
:
UndefinedHandleValue
JSPROP_ENUMERATE
|
JSPROP_SHARED
|
JSPROP_GETTER
|
JSPROP_SETTER
JS_DATA_TO_FUNC_PTR
(
JSNative
funObj
.
get
(
)
)
nullptr
)
)
)
{
return
false
;
}
}
}
return
true
;
}
namespace
{
bool
FlushOutput
(
JSContext
*
aCx
Sequence
<
JS
:
:
Value
>
&
aSequence
nsString
&
aOutput
)
{
if
(
!
aOutput
.
IsEmpty
(
)
)
{
JS
:
:
Rooted
<
JSString
*
>
str
(
aCx
JS_NewUCStringCopyN
(
aCx
aOutput
.
get
(
)
aOutput
.
Length
(
)
)
)
;
if
(
NS_WARN_IF
(
!
str
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
aSequence
.
AppendElement
(
JS
:
:
StringValue
(
str
)
fallible
)
)
)
{
return
false
;
}
aOutput
.
Truncate
(
)
;
}
return
true
;
}
}
bool
Console
:
:
ProcessArguments
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
Sequence
<
JS
:
:
Value
>
&
aSequence
Sequence
<
nsString
>
&
aStyles
)
const
{
if
(
aData
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
aData
.
Length
(
)
=
=
1
|
|
!
aData
[
0
]
.
isString
(
)
)
{
return
ArgumentsToValueList
(
aData
aSequence
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
format
(
aCx
aData
[
0
]
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
format
)
)
;
if
(
NS_WARN_IF
(
!
jsString
)
)
{
return
false
;
}
nsAutoJSString
string
;
if
(
NS_WARN_IF
(
!
string
.
init
(
aCx
jsString
)
)
)
{
return
false
;
}
nsString
:
:
const_iterator
start
end
;
string
.
BeginReading
(
start
)
;
string
.
EndReading
(
end
)
;
nsString
output
;
uint32_t
index
=
1
;
while
(
start
!
=
end
)
{
if
(
*
start
!
=
'
%
'
)
{
output
.
Append
(
*
start
)
;
+
+
start
;
continue
;
}
+
+
start
;
if
(
start
=
=
end
)
{
output
.
Append
(
'
%
'
)
;
break
;
}
if
(
*
start
=
=
'
%
'
)
{
output
.
Append
(
*
start
)
;
+
+
start
;
continue
;
}
nsAutoString
tmp
;
tmp
.
Append
(
'
%
'
)
;
int32_t
integer
=
-
1
;
int32_t
mantissa
=
-
1
;
if
(
*
start
>
=
'
0
'
&
&
*
start
<
=
'
9
'
)
{
integer
=
0
;
do
{
integer
=
integer
*
10
+
*
start
-
'
0
'
;
tmp
.
Append
(
*
start
)
;
+
+
start
;
}
while
(
*
start
>
=
'
0
'
&
&
*
start
<
=
'
9
'
&
&
start
!
=
end
)
;
}
if
(
start
=
=
end
)
{
output
.
Append
(
tmp
)
;
break
;
}
if
(
*
start
=
=
'
.
'
)
{
tmp
.
Append
(
*
start
)
;
+
+
start
;
if
(
start
=
=
end
)
{
output
.
Append
(
tmp
)
;
break
;
}
if
(
*
start
<
'
0
'
|
|
*
start
>
'
9
'
)
{
output
.
Append
(
tmp
)
;
continue
;
}
mantissa
=
0
;
do
{
mantissa
=
mantissa
*
10
+
*
start
-
'
0
'
;
tmp
.
Append
(
*
start
)
;
+
+
start
;
}
while
(
*
start
>
=
'
0
'
&
&
*
start
<
=
'
9
'
&
&
start
!
=
end
)
;
if
(
start
=
=
end
)
{
output
.
Append
(
tmp
)
;
break
;
}
}
char
ch
=
*
start
;
tmp
.
Append
(
ch
)
;
+
+
start
;
switch
(
ch
)
{
case
'
o
'
:
case
'
O
'
:
{
if
(
NS_WARN_IF
(
!
FlushOutput
(
aCx
aSequence
output
)
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aCx
)
;
if
(
index
<
aData
.
Length
(
)
)
{
v
=
aData
[
index
+
+
]
;
}
if
(
NS_WARN_IF
(
!
aSequence
.
AppendElement
(
v
fallible
)
)
)
{
return
false
;
}
break
;
}
case
'
c
'
:
{
if
(
output
.
IsEmpty
(
)
&
&
!
aStyles
.
IsEmpty
(
)
)
{
aStyles
.
TruncateLength
(
aStyles
.
Length
(
)
-
1
)
;
}
if
(
NS_WARN_IF
(
!
FlushOutput
(
aCx
aSequence
output
)
)
)
{
return
false
;
}
if
(
index
<
aData
.
Length
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aCx
aData
[
index
+
+
]
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
v
)
)
;
if
(
NS_WARN_IF
(
!
jsString
)
)
{
return
false
;
}
int32_t
diff
=
aSequence
.
Length
(
)
-
aStyles
.
Length
(
)
;
if
(
diff
>
0
)
{
for
(
int32_t
i
=
0
;
i
<
diff
;
i
+
+
)
{
if
(
NS_WARN_IF
(
!
aStyles
.
AppendElement
(
NullString
(
)
fallible
)
)
)
{
return
false
;
}
}
}
nsAutoJSString
string
;
if
(
NS_WARN_IF
(
!
string
.
init
(
aCx
jsString
)
)
)
{
return
false
;
}
if
(
NS_WARN_IF
(
!
aStyles
.
AppendElement
(
string
fallible
)
)
)
{
return
false
;
}
}
break
;
}
case
'
s
'
:
if
(
index
<
aData
.
Length
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
aData
[
index
+
+
]
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
value
)
)
;
if
(
NS_WARN_IF
(
!
jsString
)
)
{
return
false
;
}
nsAutoJSString
v
;
if
(
NS_WARN_IF
(
!
v
.
init
(
aCx
jsString
)
)
)
{
return
false
;
}
output
.
Append
(
v
)
;
}
break
;
case
'
d
'
:
case
'
i
'
:
if
(
index
<
aData
.
Length
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
aData
[
index
+
+
]
)
;
int32_t
v
;
if
(
NS_WARN_IF
(
!
JS
:
:
ToInt32
(
aCx
value
&
v
)
)
)
{
return
false
;
}
nsCString
format
;
MakeFormatString
(
format
integer
mantissa
'
d
'
)
;
output
.
AppendPrintf
(
format
.
get
(
)
v
)
;
}
break
;
case
'
f
'
:
if
(
index
<
aData
.
Length
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
aData
[
index
+
+
]
)
;
double
v
;
if
(
NS_WARN_IF
(
!
JS
:
:
ToNumber
(
aCx
value
&
v
)
)
)
{
return
false
;
}
if
(
std
:
:
isnan
(
v
)
)
{
output
.
AppendFloat
(
v
)
;
}
else
{
nsCString
format
;
MakeFormatString
(
format
integer
mantissa
'
f
'
)
;
output
.
AppendPrintf
(
format
.
get
(
)
v
)
;
}
}
break
;
default
:
output
.
Append
(
tmp
)
;
break
;
}
}
if
(
NS_WARN_IF
(
!
FlushOutput
(
aCx
aSequence
output
)
)
)
{
return
false
;
}
if
(
aStyles
.
Length
(
)
>
aSequence
.
Length
(
)
)
{
aStyles
.
TruncateLength
(
aSequence
.
Length
(
)
)
;
}
for
(
;
index
<
aData
.
Length
(
)
;
+
+
index
)
{
if
(
NS_WARN_IF
(
!
aSequence
.
AppendElement
(
aData
[
index
]
fallible
)
)
)
{
return
false
;
}
}
return
true
;
}
void
Console
:
:
MakeFormatString
(
nsCString
&
aFormat
int32_t
aInteger
int32_t
aMantissa
char
aCh
)
const
{
aFormat
.
Append
(
'
%
'
)
;
if
(
aInteger
>
=
0
)
{
aFormat
.
AppendInt
(
aInteger
)
;
}
if
(
aMantissa
>
=
0
)
{
aFormat
.
Append
(
'
.
'
)
;
aFormat
.
AppendInt
(
aMantissa
)
;
}
aFormat
.
Append
(
aCh
)
;
}
void
Console
:
:
ComposeGroupName
(
JSContext
*
aCx
const
Sequence
<
JS
:
:
Value
>
&
aData
nsAString
&
aName
)
const
{
for
(
uint32_t
i
=
0
;
i
<
aData
.
Length
(
)
;
+
+
i
)
{
if
(
i
!
=
0
)
{
aName
.
AppendASCII
(
"
"
)
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
aData
[
i
]
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
value
)
)
;
if
(
!
jsString
)
{
return
;
}
nsAutoJSString
string
;
if
(
!
string
.
init
(
aCx
jsString
)
)
{
return
;
}
aName
.
Append
(
string
)
;
}
}
bool
Console
:
:
StartTimer
(
JSContext
*
aCx
const
JS
:
:
Value
&
aName
DOMHighResTimeStamp
aTimestamp
nsAString
&
aTimerLabel
DOMHighResTimeStamp
*
aTimerValue
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aTimerValue
)
;
*
aTimerValue
=
0
;
if
(
NS_WARN_IF
(
mTimerRegistry
.
Count
(
)
>
=
MAX_PAGE_TIMERS
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
name
(
aCx
aName
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
name
)
)
;
if
(
NS_WARN_IF
(
!
jsString
)
)
{
return
false
;
}
nsAutoJSString
label
;
if
(
NS_WARN_IF
(
!
label
.
init
(
aCx
jsString
)
)
)
{
return
false
;
}
DOMHighResTimeStamp
entry
;
if
(
!
mTimerRegistry
.
Get
(
label
&
entry
)
)
{
mTimerRegistry
.
Put
(
label
aTimestamp
)
;
}
else
{
aTimestamp
=
entry
;
}
aTimerLabel
=
label
;
*
aTimerValue
=
aTimestamp
;
return
true
;
}
JS
:
:
Value
Console
:
:
CreateStartTimerValue
(
JSContext
*
aCx
const
nsAString
&
aTimerLabel
DOMHighResTimeStamp
aTimerValue
bool
aTimerStatus
)
const
{
if
(
!
aTimerStatus
)
{
RootedDictionary
<
ConsoleTimerError
>
error
(
aCx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
error
&
value
)
)
{
return
JS
:
:
UndefinedValue
(
)
;
}
return
value
;
}
RootedDictionary
<
ConsoleTimerStart
>
timer
(
aCx
)
;
timer
.
mName
=
aTimerLabel
;
timer
.
mStarted
=
aTimerValue
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
timer
&
value
)
)
{
return
JS
:
:
UndefinedValue
(
)
;
}
return
value
;
}
bool
Console
:
:
StopTimer
(
JSContext
*
aCx
const
JS
:
:
Value
&
aName
DOMHighResTimeStamp
aTimestamp
nsAString
&
aTimerLabel
double
*
aTimerDuration
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aTimerDuration
)
;
*
aTimerDuration
=
0
;
JS
:
:
Rooted
<
JS
:
:
Value
>
name
(
aCx
aName
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
name
)
)
;
if
(
NS_WARN_IF
(
!
jsString
)
)
{
return
false
;
}
nsAutoJSString
key
;
if
(
NS_WARN_IF
(
!
key
.
init
(
aCx
jsString
)
)
)
{
return
false
;
}
DOMHighResTimeStamp
entry
;
if
(
NS_WARN_IF
(
!
mTimerRegistry
.
Get
(
key
&
entry
)
)
)
{
return
false
;
}
mTimerRegistry
.
Remove
(
key
)
;
aTimerLabel
=
key
;
*
aTimerDuration
=
aTimestamp
-
entry
;
return
true
;
}
JS
:
:
Value
Console
:
:
CreateStopTimerValue
(
JSContext
*
aCx
const
nsAString
&
aLabel
double
aDuration
bool
aStatus
)
const
{
if
(
!
aStatus
)
{
return
JS
:
:
UndefinedValue
(
)
;
}
RootedDictionary
<
ConsoleTimerEnd
>
timer
(
aCx
)
;
timer
.
mName
=
aLabel
;
timer
.
mDuration
=
aDuration
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
timer
&
value
)
)
{
return
JS
:
:
UndefinedValue
(
)
;
}
return
value
;
}
bool
Console
:
:
ArgumentsToValueList
(
const
Sequence
<
JS
:
:
Value
>
&
aData
Sequence
<
JS
:
:
Value
>
&
aSequence
)
const
{
for
(
uint32_t
i
=
0
;
i
<
aData
.
Length
(
)
;
+
+
i
)
{
if
(
NS_WARN_IF
(
!
aSequence
.
AppendElement
(
aData
[
i
]
fallible
)
)
)
{
return
false
;
}
}
return
true
;
}
uint32_t
Console
:
:
IncreaseCounter
(
JSContext
*
aCx
const
ConsoleStackEntry
&
aFrame
const
Sequence
<
JS
:
:
Value
>
&
aArguments
nsAString
&
aCountLabel
)
{
AssertIsOnOwningThread
(
)
;
ClearException
ce
(
aCx
)
;
nsAutoString
key
;
nsAutoString
label
;
if
(
!
aArguments
.
IsEmpty
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
labelValue
(
aCx
aArguments
[
0
]
)
;
JS
:
:
Rooted
<
JSString
*
>
jsString
(
aCx
JS
:
:
ToString
(
aCx
labelValue
)
)
;
nsAutoJSString
string
;
if
(
jsString
&
&
string
.
init
(
aCx
jsString
)
)
{
label
=
string
;
key
=
string
;
}
}
if
(
key
.
IsEmpty
(
)
)
{
key
.
Append
(
aFrame
.
mFilename
)
;
key
.
Append
(
'
:
'
)
;
key
.
AppendInt
(
aFrame
.
mLineNumber
)
;
}
uint32_t
count
=
0
;
if
(
!
mCounterRegistry
.
Get
(
key
&
count
)
&
&
mCounterRegistry
.
Count
(
)
>
=
MAX_PAGE_COUNTERS
)
{
return
MAX_PAGE_COUNTERS
;
}
+
+
count
;
mCounterRegistry
.
Put
(
key
count
)
;
aCountLabel
=
label
;
return
count
;
}
JS
:
:
Value
Console
:
:
CreateCounterValue
(
JSContext
*
aCx
const
nsAString
&
aCountLabel
uint32_t
aCountValue
)
const
{
ClearException
ce
(
aCx
)
;
if
(
aCountValue
=
=
MAX_PAGE_COUNTERS
)
{
RootedDictionary
<
ConsoleCounterError
>
error
(
aCx
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
error
&
value
)
)
{
return
JS
:
:
UndefinedValue
(
)
;
}
return
value
;
}
RootedDictionary
<
ConsoleCounter
>
data
(
aCx
)
;
data
.
mLabel
=
aCountLabel
;
data
.
mCount
=
aCountValue
;
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
data
&
value
)
)
{
return
JS
:
:
UndefinedValue
(
)
;
}
return
value
;
}
bool
Console
:
:
ShouldIncludeStackTrace
(
MethodName
aMethodName
)
const
{
switch
(
aMethodName
)
{
case
MethodError
:
case
MethodException
:
case
MethodAssert
:
case
MethodTrace
:
return
true
;
default
:
return
false
;
}
}
JSObject
*
Console
:
:
GetOrCreateSandbox
(
JSContext
*
aCx
nsIPrincipal
*
aPrincipal
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mSandbox
)
{
nsIXPConnect
*
xpc
=
nsContentUtils
:
:
XPConnect
(
)
;
MOZ_ASSERT
(
xpc
"
This
should
never
be
null
!
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
sandbox
(
aCx
)
;
nsresult
rv
=
xpc
-
>
CreateSandbox
(
aCx
aPrincipal
sandbox
.
address
(
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
mSandbox
=
new
JSObjectHolder
(
aCx
sandbox
)
;
}
return
mSandbox
-
>
GetJSObject
(
)
;
}
void
Console
:
:
StoreCallData
(
ConsoleCallData
*
aCallData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aCallData
)
;
MOZ_ASSERT
(
!
mCallDataStorage
.
Contains
(
aCallData
)
)
;
MOZ_ASSERT
(
!
mCallDataStoragePending
.
Contains
(
aCallData
)
)
;
mCallDataStorage
.
AppendElement
(
aCallData
)
;
if
(
mCallDataStorage
.
Length
(
)
>
STORAGE_MAX_EVENTS
)
{
RefPtr
<
ConsoleCallData
>
callData
=
mCallDataStorage
[
0
]
;
mCallDataStorage
.
RemoveElementAt
(
0
)
;
MOZ_ASSERT
(
callData
-
>
mStatus
!
=
ConsoleCallData
:
:
eToBeDeleted
)
;
if
(
callData
-
>
mStatus
=
=
ConsoleCallData
:
:
eInUse
)
{
callData
-
>
mStatus
=
ConsoleCallData
:
:
eToBeDeleted
;
mCallDataStoragePending
.
AppendElement
(
callData
)
;
}
}
}
void
Console
:
:
UnstoreCallData
(
ConsoleCallData
*
aCallData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aCallData
)
;
MOZ_ASSERT
(
mCallDataStorage
.
Contains
(
aCallData
)
)
;
MOZ_ASSERT
(
!
mCallDataStoragePending
.
Contains
(
aCallData
)
)
;
mCallDataStorage
.
RemoveElement
(
aCallData
)
;
}
void
Console
:
:
ReleaseCallData
(
ConsoleCallData
*
aCallData
)
{
AssertIsOnOwningThread
(
)
;
MOZ_ASSERT
(
aCallData
)
;
MOZ_ASSERT
(
aCallData
-
>
mStatus
=
=
ConsoleCallData
:
:
eToBeDeleted
)
;
MOZ_ASSERT
(
mCallDataStoragePending
.
Contains
(
aCallData
)
)
;
mCallDataStoragePending
.
RemoveElement
(
aCallData
)
;
}
void
Console
:
:
AssertIsOnOwningThread
(
)
const
{
MOZ_ASSERT
(
mOwningThread
)
;
MOZ_ASSERT
(
PR_GetCurrentThread
(
)
=
=
mOwningThread
)
;
}
}
}
