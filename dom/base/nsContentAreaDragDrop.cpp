#
include
"
nsReadableUtils
.
h
"
#
include
"
nsContentAreaDragDrop
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIWebBrowserPersist
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
nsIMIMEInfo
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
BrowserParent
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsQueryObject
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
IgnoreErrors
;
class
MOZ_STACK_CLASS
DragDataProducer
{
public
:
DragDataProducer
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aTarget
nsIContent
*
aSelectionTargetNode
bool
aIsAltKeyPressed
)
;
nsresult
Produce
(
DataTransfer
*
aDataTransfer
bool
*
aCanDrag
Selection
*
*
aSelection
nsIContent
*
*
aDragNode
nsIContentSecurityPolicy
*
*
aCsp
nsICookieJarSettings
*
*
aCookieJarSettings
)
;
private
:
void
AddString
(
DataTransfer
*
aDataTransfer
const
nsAString
&
aFlavor
const
nsAString
&
aData
nsIPrincipal
*
aPrincipal
bool
aHidden
=
false
)
;
nsresult
AddStringsToDataTransfer
(
nsIContent
*
aDragNode
DataTransfer
*
aDataTransfer
)
;
nsresult
GetImageData
(
imgIContainer
*
aImage
imgIRequest
*
aRequest
)
;
static
nsresult
GetDraggableSelectionData
(
Selection
*
inSelection
nsIContent
*
inRealTargetNode
nsIContent
*
*
outImageOrLinkNode
bool
*
outDragSelectedText
)
;
[
[
nodiscard
]
]
static
nsresult
GetAnchorURL
(
nsIContent
*
inNode
nsAString
&
outURL
)
;
static
void
CreateLinkText
(
const
nsAString
&
inURL
const
nsAString
&
inText
nsAString
&
outLinkText
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mWindow
;
nsCOMPtr
<
nsIContent
>
mTarget
;
nsCOMPtr
<
nsIContent
>
mSelectionTargetNode
;
bool
mIsAltKeyPressed
;
nsString
mUrlString
;
nsString
mImageSourceString
;
nsString
mImageDestFileName
;
#
if
defined
(
XP_MACOSX
)
nsString
mImageRequestMime
;
#
endif
nsString
mTitleString
;
nsString
mHtmlString
;
nsString
mContextString
;
nsString
mInfoString
;
bool
mIsAnchor
;
nsCOMPtr
<
imgIContainer
>
mImage
;
}
;
nsresult
nsContentAreaDragDrop
:
:
GetDragData
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aTarget
nsIContent
*
aSelectionTargetNode
bool
aIsAltKeyPressed
DataTransfer
*
aDataTransfer
bool
*
aCanDrag
Selection
*
*
aSelection
nsIContent
*
*
aDragNode
nsIContentSecurityPolicy
*
*
aCsp
nsICookieJarSettings
*
*
aCookieJarSettings
)
{
NS_ENSURE_TRUE
(
aSelectionTargetNode
NS_ERROR_INVALID_ARG
)
;
*
aCanDrag
=
true
;
DragDataProducer
provider
(
aWindow
aTarget
aSelectionTargetNode
aIsAltKeyPressed
)
;
return
provider
.
Produce
(
aDataTransfer
aCanDrag
aSelection
aDragNode
aCsp
aCookieJarSettings
)
;
}
NS_IMPL_ISUPPORTS
(
nsContentAreaDragDropDataProvider
nsIFlavorDataProvider
)
nsresult
nsContentAreaDragDropDataProvider
:
:
SaveURIToFile
(
nsIURI
*
inSourceURI
nsIPrincipal
*
inTriggeringPrincipal
nsICookieJarSettings
*
inCookieJarSettings
nsIFile
*
inDestFile
nsContentPolicyType
inContentPolicyType
bool
isPrivate
)
{
nsCOMPtr
<
nsIURL
>
sourceURL
=
do_QueryInterface
(
inSourceURI
)
;
if
(
!
sourceURL
)
{
return
NS_ERROR_NO_INTERFACE
;
}
nsresult
rv
=
inDestFile
-
>
CreateUnique
(
nsIFile
:
:
NORMAL_FILE_TYPE
0600
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIWebBrowserPersist
>
persist
=
do_CreateInstance
(
"
mozilla
.
org
/
embedding
/
browser
/
nsWebBrowserPersist
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
persist
-
>
SetPersistFlags
(
nsIWebBrowserPersist
:
:
PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION
)
;
return
persist
-
>
SaveURI
(
inSourceURI
inTriggeringPrincipal
0
nullptr
inCookieJarSettings
nullptr
nullptr
inDestFile
inContentPolicyType
isPrivate
)
;
}
nsresult
CheckAndGetExtensionForMime
(
const
nsCString
&
aExtension
const
nsCString
&
aMimeType
bool
*
aIsValidExtension
nsACString
*
aPrimaryExtension
)
{
nsresult
rv
;
nsCOMPtr
<
nsIMIMEService
>
mimeService
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mimeService
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIMIMEInfo
>
mimeInfo
;
rv
=
mimeService
-
>
GetFromTypeAndExtension
(
aMimeType
"
"
_ns
getter_AddRefs
(
mimeInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mimeInfo
-
>
GetPrimaryExtension
(
*
aPrimaryExtension
)
;
if
(
aExtension
.
IsEmpty
(
)
)
{
*
aIsValidExtension
=
false
;
return
NS_OK
;
}
rv
=
mimeInfo
-
>
ExtensionExists
(
aExtension
aIsValidExtension
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsContentAreaDragDropDataProvider
:
:
GetFlavorData
(
nsITransferable
*
aTransferable
const
char
*
aFlavor
nsISupports
*
*
aData
)
{
NS_ENSURE_ARG_POINTER
(
aData
)
;
*
aData
=
nullptr
;
nsresult
rv
=
NS_ERROR_NOT_IMPLEMENTED
;
if
(
strcmp
(
aFlavor
kFilePromiseMime
)
=
=
0
)
{
NS_ENSURE_ARG
(
aTransferable
)
;
nsCOMPtr
<
nsISupports
>
tmp
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseURLMime
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISupportsString
>
supportsString
=
do_QueryInterface
(
tmp
)
;
if
(
!
supportsString
)
return
NS_ERROR_FAILURE
;
nsAutoString
sourceURLString
;
supportsString
-
>
GetData
(
sourceURLString
)
;
if
(
sourceURLString
.
IsEmpty
(
)
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIURI
>
sourceURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
sourceURI
)
sourceURLString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseDestFilename
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
supportsString
=
do_QueryInterface
(
tmp
)
;
if
(
!
supportsString
)
return
NS_ERROR_FAILURE
;
nsAutoString
targetFilename
;
supportsString
-
>
GetData
(
targetFilename
)
;
if
(
targetFilename
.
IsEmpty
(
)
)
return
NS_ERROR_FAILURE
;
#
if
defined
(
XP_MACOSX
)
if
(
XRE_IsParentProcess
(
)
)
{
rv
=
aTransferable
-
>
GetTransferData
(
kImageRequestMime
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
supportsString
=
do_QueryInterface
(
tmp
)
;
if
(
!
supportsString
)
return
NS_ERROR_FAILURE
;
nsAutoString
contentType
;
supportsString
-
>
GetData
(
contentType
)
;
nsCOMPtr
<
nsIMIMEService
>
mimeService
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mimeService
)
)
{
return
NS_ERROR_FAILURE
;
}
mimeService
-
>
ValidateFileNameForSaving
(
targetFilename
NS_ConvertUTF16toUTF8
(
contentType
)
nsIMIMEService
:
:
VALIDATE_DEFAULT
targetFilename
)
;
}
else
{
targetFilename
.
ReplaceChar
(
u
"
"
FILE_PATH_SEPARATOR
FILE_ILLEGAL_CHARACTERS
u
'
-
'
)
;
}
#
endif
nsCOMPtr
<
nsISupports
>
dirPrimitive
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseDirectoryMime
getter_AddRefs
(
dirPrimitive
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
destDirectory
=
do_QueryInterface
(
dirPrimitive
)
;
if
(
!
destDirectory
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
destDirectory
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
file
-
>
Append
(
targetFilename
)
;
bool
isPrivate
=
aTransferable
-
>
GetIsPrivateData
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
aTransferable
-
>
GetDataPrincipal
(
)
;
nsContentPolicyType
contentPolicyType
=
aTransferable
-
>
GetContentPolicyType
(
)
;
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
aTransferable
-
>
GetCookieJarSettings
(
)
;
rv
=
SaveURIToFile
(
sourceURI
principal
cookieJarSettings
file
contentPolicyType
isPrivate
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CallQueryInterface
(
file
aData
)
;
}
}
return
rv
;
}
DragDataProducer
:
:
DragDataProducer
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aTarget
nsIContent
*
aSelectionTargetNode
bool
aIsAltKeyPressed
)
:
mWindow
(
aWindow
)
mTarget
(
aTarget
)
mSelectionTargetNode
(
aSelectionTargetNode
)
mIsAltKeyPressed
(
aIsAltKeyPressed
)
mIsAnchor
(
false
)
{
}
static
nsIContent
*
FindDragTarget
(
nsIContent
*
aContent
)
{
for
(
nsIContent
*
content
=
aContent
;
content
;
content
=
content
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
nsContentUtils
:
:
ContentIsDraggable
(
content
)
)
{
return
content
;
}
}
return
nullptr
;
}
nsresult
DragDataProducer
:
:
GetAnchorURL
(
nsIContent
*
aContent
nsAString
&
aURL
)
{
aURL
.
Truncate
(
)
;
auto
*
element
=
Element
:
:
FromNodeOrNull
(
aContent
)
;
if
(
!
element
|
|
!
element
-
>
IsLink
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIURI
>
linkURI
=
element
-
>
GetHrefURI
(
)
;
if
(
!
linkURI
)
{
return
NS_OK
;
}
nsAutoCString
spec
;
nsresult
rv
=
linkURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
rv
=
secMan
-
>
CheckLoadURIStrWithPrincipal
(
aContent
-
>
NodePrincipal
(
)
spec
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
spec
aURL
)
;
return
NS_OK
;
}
void
DragDataProducer
:
:
CreateLinkText
(
const
nsAString
&
inURL
const
nsAString
&
inText
nsAString
&
outLinkText
)
{
nsAutoString
linkText
(
u
"
<
a
href
=
\
"
"
_ns
+
inURL
+
u
"
\
"
>
"
_ns
+
inText
+
u
"
<
/
a
>
"
_ns
)
;
outLinkText
=
linkText
;
}
nsresult
DragDataProducer
:
:
GetImageData
(
imgIContainer
*
aImage
imgIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIURI
>
imgUri
=
aRequest
-
>
GetURI
(
)
;
nsCOMPtr
<
nsIURL
>
imgUrl
(
do_QueryInterface
(
imgUri
)
)
;
if
(
imgUrl
)
{
nsAutoCString
spec
;
nsresult
rv
=
imgUrl
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
spec
mImageSourceString
)
;
nsCString
mimeType
;
aRequest
-
>
GetMimeType
(
getter_Copies
(
mimeType
)
)
;
nsAutoCString
fileName
;
aRequest
-
>
GetFileName
(
fileName
)
;
#
if
defined
(
XP_MACOSX
)
CopyUTF8toUTF16
(
mimeType
mImageRequestMime
)
;
CopyUTF8toUTF16
(
fileName
mImageDestFileName
)
;
#
else
nsCOMPtr
<
nsIMIMEService
>
mimeService
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mimeService
)
)
{
return
NS_ERROR_FAILURE
;
}
CopyUTF8toUTF16
(
fileName
mImageDestFileName
)
;
mimeService
-
>
ValidateFileNameForSaving
(
mImageDestFileName
mimeType
nsIMIMEService
:
:
VALIDATE_DEFAULT
mImageDestFileName
)
;
#
endif
mImage
=
aImage
;
}
return
NS_OK
;
}
nsresult
DragDataProducer
:
:
Produce
(
DataTransfer
*
aDataTransfer
bool
*
aCanDrag
Selection
*
*
aSelection
nsIContent
*
*
aDragNode
nsIContentSecurityPolicy
*
*
aCsp
nsICookieJarSettings
*
*
aCookieJarSettings
)
{
MOZ_ASSERT
(
aCanDrag
&
&
aSelection
&
&
aDataTransfer
&
&
aDragNode
"
null
pointer
passed
to
Produce
"
)
;
NS_ASSERTION
(
mWindow
"
window
not
set
"
)
;
NS_ASSERTION
(
mSelectionTargetNode
"
selection
target
node
should
have
been
set
"
)
;
*
aDragNode
=
nullptr
;
nsresult
rv
;
nsIContent
*
dragNode
=
nullptr
;
*
aSelection
=
nullptr
;
RefPtr
<
Selection
>
selection
;
nsIContent
*
editingElement
=
mSelectionTargetNode
-
>
IsEditable
(
)
?
mSelectionTargetNode
-
>
GetEditingHost
(
)
:
nullptr
;
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
GetTextControlElementFromEditingHost
(
editingElement
)
;
if
(
textControlElement
)
{
nsISelectionController
*
selcon
=
textControlElement
-
>
GetSelectionController
(
)
;
if
(
selcon
)
{
selection
=
selcon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
}
if
(
!
selection
)
return
NS_OK
;
}
else
{
selection
=
mWindow
-
>
GetSelection
(
)
;
if
(
!
selection
)
return
NS_OK
;
nsCOMPtr
<
nsIContent
>
findFormNode
=
mSelectionTargetNode
;
nsIContent
*
findFormParent
=
findFormNode
-
>
GetParent
(
)
;
while
(
findFormParent
)
{
const
auto
*
form
=
nsIFormControl
:
:
FromNode
(
findFormParent
)
;
if
(
form
&
&
!
form
-
>
AllowDraggableChildren
(
)
)
{
return
NS_OK
;
}
findFormParent
=
findFormParent
-
>
GetParent
(
)
;
}
}
nsCOMPtr
<
nsIContent
>
nodeToSerialize
;
BrowsingContext
*
bc
=
mWindow
-
>
GetBrowsingContext
(
)
;
const
bool
isChromeShell
=
bc
&
&
bc
-
>
IsChrome
(
)
;
if
(
isChromeShell
&
&
!
editingElement
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Shouldn
'
t
be
generating
drag
data
for
chrome
"
)
;
return
NS_OK
;
}
if
(
isChromeShell
&
&
textControlElement
)
{
if
(
!
selection
-
>
ContainsNode
(
*
mSelectionTargetNode
false
IgnoreErrors
(
)
)
)
return
NS_OK
;
selection
.
swap
(
*
aSelection
)
;
}
else
{
bool
haveSelectedContent
=
false
;
if
(
!
mIsAltKeyPressed
)
{
const
auto
*
form
=
nsIFormControl
:
:
FromNodeOrNull
(
mTarget
)
;
if
(
form
&
&
form
-
>
ControlType
(
)
!
=
FormControlType
:
:
Object
)
{
*
aCanDrag
=
false
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIContent
>
parentLink
;
nsCOMPtr
<
nsIContent
>
draggedNode
=
FindDragTarget
(
mTarget
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
image
;
nsCOMPtr
<
nsIContent
>
selectedImageOrLinkNode
;
GetDraggableSelectionData
(
selection
mSelectionTargetNode
getter_AddRefs
(
selectedImageOrLinkNode
)
&
haveSelectedContent
)
;
if
(
haveSelectedContent
)
{
selection
.
swap
(
*
aSelection
)
;
}
else
if
(
selectedImageOrLinkNode
)
{
image
=
do_QueryInterface
(
selectedImageOrLinkNode
)
;
}
else
{
parentLink
=
nsContentUtils
:
:
GetClosestLinkInFlatTree
(
draggedNode
)
;
if
(
parentLink
&
&
mIsAltKeyPressed
)
{
*
aCanDrag
=
false
;
return
NS_OK
;
}
image
=
do_QueryInterface
(
draggedNode
)
;
}
{
nsCOMPtr
<
nsIContent
>
linkNode
;
if
(
const
auto
*
areaElem
=
HTMLAreaElement
:
:
FromNodeOrNull
(
draggedNode
)
)
{
areaElem
-
>
GetAttr
(
nsGkAtoms
:
:
alt
mTitleString
)
;
if
(
mTitleString
.
IsEmpty
(
)
)
{
areaElem
-
>
GetAttr
(
nsGkAtoms
:
:
href
mTitleString
)
;
}
nsresult
rv
=
GetAnchorURL
(
draggedNode
mUrlString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIsAnchor
=
true
;
mHtmlString
.
AssignLiteral
(
"
<
a
href
=
\
"
"
)
;
mHtmlString
.
Append
(
mUrlString
)
;
mHtmlString
.
AppendLiteral
(
"
\
"
>
"
)
;
mHtmlString
.
Append
(
mTitleString
)
;
mHtmlString
.
AppendLiteral
(
"
<
/
a
>
"
)
;
dragNode
=
draggedNode
;
}
else
if
(
image
)
{
nsCOMPtr
<
nsIURI
>
imageURI
;
image
-
>
GetCurrentURI
(
getter_AddRefs
(
imageURI
)
)
;
nsCOMPtr
<
Element
>
imageElement
(
do_QueryInterface
(
image
)
)
;
if
(
imageURI
)
{
nsAutoCString
spec
;
rv
=
imageURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
rv
=
secMan
-
>
CheckLoadURIStrWithPrincipal
(
imageElement
-
>
NodePrincipal
(
)
spec
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIsAnchor
=
true
;
CopyUTF8toUTF16
(
spec
mUrlString
)
;
}
if
(
imageElement
)
{
imageElement
-
>
GetAttr
(
nsGkAtoms
:
:
alt
mTitleString
)
;
}
if
(
mTitleString
.
IsEmpty
(
)
)
{
mTitleString
=
mUrlString
;
}
nsCOMPtr
<
imgIRequest
>
imgRequest
;
nsCOMPtr
<
imgIContainer
>
img
=
nsContentUtils
:
:
GetImageFromContent
(
image
getter_AddRefs
(
imgRequest
)
)
;
if
(
imgRequest
)
{
rv
=
GetImageData
(
img
imgRequest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
parentLink
)
{
linkNode
=
parentLink
;
nodeToSerialize
=
linkNode
;
}
else
{
nodeToSerialize
=
draggedNode
;
}
dragNode
=
nodeToSerialize
;
}
else
if
(
parentLink
)
{
linkNode
=
parentLink
;
nodeToSerialize
=
linkNode
;
}
else
if
(
!
haveSelectedContent
)
{
return
NS_OK
;
}
if
(
linkNode
)
{
rv
=
GetAnchorURL
(
linkNode
mUrlString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIsAnchor
=
true
;
dragNode
=
linkNode
;
}
}
}
if
(
nodeToSerialize
|
|
*
aSelection
)
{
mHtmlString
.
Truncate
(
)
;
mContextString
.
Truncate
(
)
;
mInfoString
.
Truncate
(
)
;
mTitleString
.
Truncate
(
)
;
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
doc
-
>
GetCsp
(
)
;
if
(
csp
)
{
NS_IF_ADDREF
(
*
aCsp
=
csp
)
;
}
nsCOMPtr
<
nsICookieJarSettings
>
cookieJarSettings
=
doc
-
>
CookieJarSettings
(
)
;
if
(
cookieJarSettings
)
{
NS_IF_ADDREF
(
*
aCookieJarSettings
=
cookieJarSettings
)
;
}
nsCOMPtr
<
nsITransferable
>
transferable
;
if
(
*
aSelection
)
{
rv
=
nsCopySupport
:
:
GetTransferableForSelection
(
*
aSelection
doc
getter_AddRefs
(
transferable
)
)
;
}
else
{
rv
=
nsCopySupport
:
:
GetTransferableForNode
(
nodeToSerialize
doc
getter_AddRefs
(
transferable
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISupports
>
supports
;
nsCOMPtr
<
nsISupportsString
>
data
;
rv
=
transferable
-
>
GetTransferData
(
kHTMLMime
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
data
-
>
GetData
(
mHtmlString
)
;
}
rv
=
transferable
-
>
GetTransferData
(
kHTMLContext
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
data
-
>
GetData
(
mContextString
)
;
}
rv
=
transferable
-
>
GetTransferData
(
kHTMLInfo
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
data
-
>
GetData
(
mInfoString
)
;
}
rv
=
transferable
-
>
GetTransferData
(
kTextMime
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
data
-
>
GetData
(
mTitleString
)
;
}
if
(
mTitleString
.
IsEmpty
(
)
)
{
mTitleString
=
mUrlString
;
}
if
(
mHtmlString
.
IsEmpty
(
)
&
&
!
mUrlString
.
IsEmpty
(
)
)
CreateLinkText
(
mUrlString
mTitleString
mHtmlString
)
;
rv
=
AddStringsToDataTransfer
(
dragNode
?
dragNode
:
mSelectionTargetNode
.
get
(
)
aDataTransfer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_IF_ADDREF
(
*
aDragNode
=
dragNode
)
;
return
NS_OK
;
}
void
DragDataProducer
:
:
AddString
(
DataTransfer
*
aDataTransfer
const
nsAString
&
aFlavor
const
nsAString
&
aData
nsIPrincipal
*
aPrincipal
bool
aHidden
)
{
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsAString
(
aData
)
;
aDataTransfer
-
>
SetDataWithPrincipal
(
aFlavor
variant
0
aPrincipal
aHidden
)
;
}
nsresult
DragDataProducer
:
:
AddStringsToDataTransfer
(
nsIContent
*
aDragNode
DataTransfer
*
aDataTransfer
)
{
NS_ASSERTION
(
aDragNode
"
adding
strings
for
null
node
"
)
;
nsIPrincipal
*
principal
=
aDragNode
-
>
NodePrincipal
(
)
;
if
(
!
mUrlString
.
IsEmpty
(
)
&
&
mIsAnchor
)
{
nsAutoString
dragData
(
mUrlString
)
;
dragData
.
Append
(
'
\
n
'
)
;
nsAutoString
title
(
mTitleString
)
;
title
.
Trim
(
"
\
r
\
n
"
)
;
title
.
ReplaceChar
(
u
"
\
r
\
n
"
'
'
)
;
dragData
+
=
title
;
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kURLMime
)
dragData
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kURLDataMime
)
mUrlString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kURLDescriptionMime
)
mTitleString
principal
)
;
AddString
(
aDataTransfer
u
"
text
/
uri
-
list
"
_ns
mUrlString
principal
)
;
}
if
(
!
mContextString
.
IsEmpty
(
)
)
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kHTMLContext
)
mContextString
principal
)
;
if
(
!
mInfoString
.
IsEmpty
(
)
)
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kHTMLInfo
)
mInfoString
principal
)
;
if
(
!
mHtmlString
.
IsEmpty
(
)
)
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kHTMLMime
)
mHtmlString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kTextMime
)
mIsAnchor
?
mUrlString
:
mTitleString
principal
)
;
if
(
mImage
)
{
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsISupports
(
mImage
)
;
aDataTransfer
-
>
SetDataWithPrincipal
(
NS_LITERAL_STRING_FROM_CSTRING
(
kNativeImageMime
)
variant
0
principal
)
;
nsCOMPtr
<
nsIFlavorDataProvider
>
dataProvider
=
new
nsContentAreaDragDropDataProvider
(
)
;
if
(
dataProvider
)
{
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsISupports
(
dataProvider
)
;
aDataTransfer
-
>
SetDataWithPrincipal
(
NS_LITERAL_STRING_FROM_CSTRING
(
kFilePromiseMime
)
variant
0
principal
)
;
}
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kFilePromiseURLMime
)
mImageSourceString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kFilePromiseDestFilename
)
mImageDestFileName
principal
)
;
#
if
defined
(
XP_MACOSX
)
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kImageRequestMime
)
mImageRequestMime
principal
true
)
;
#
endif
if
(
!
mIsAnchor
)
{
AddString
(
aDataTransfer
NS_LITERAL_STRING_FROM_CSTRING
(
kURLDataMime
)
mUrlString
principal
)
;
AddString
(
aDataTransfer
u
"
text
/
uri
-
list
"
_ns
mUrlString
principal
)
;
}
}
return
NS_OK
;
}
nsresult
DragDataProducer
:
:
GetDraggableSelectionData
(
Selection
*
inSelection
nsIContent
*
inRealTargetNode
nsIContent
*
*
outImageOrLinkNode
bool
*
outDragSelectedText
)
{
NS_ENSURE_ARG
(
inSelection
)
;
NS_ENSURE_ARG
(
inRealTargetNode
)
;
NS_ENSURE_ARG_POINTER
(
outImageOrLinkNode
)
;
*
outImageOrLinkNode
=
nullptr
;
*
outDragSelectedText
=
false
;
if
(
!
inSelection
-
>
IsCollapsed
(
)
)
{
if
(
inSelection
-
>
ContainsNode
(
*
inRealTargetNode
false
IgnoreErrors
(
)
)
)
{
nsINode
*
selectionStart
=
inSelection
-
>
GetAnchorNode
(
)
;
nsINode
*
selectionEnd
=
inSelection
-
>
GetFocusNode
(
)
;
if
(
selectionStart
=
=
selectionEnd
)
{
nsCOMPtr
<
nsIContent
>
selStartContent
=
nsIContent
:
:
FromNodeOrNull
(
selectionStart
)
;
if
(
selStartContent
&
&
selStartContent
-
>
HasChildNodes
(
)
)
{
uint32_t
anchorOffset
=
inSelection
-
>
AnchorOffset
(
)
;
uint32_t
focusOffset
=
inSelection
-
>
FocusOffset
(
)
;
if
(
anchorOffset
=
=
focusOffset
+
1
|
|
focusOffset
=
=
anchorOffset
+
1
)
{
uint32_t
childOffset
=
std
:
:
min
(
anchorOffset
focusOffset
)
;
nsIContent
*
childContent
=
selStartContent
-
>
GetChildAt_Deprecated
(
childOffset
)
;
if
(
nsContentUtils
:
:
IsDraggableImage
(
childContent
)
)
{
NS_ADDREF
(
*
outImageOrLinkNode
=
childContent
)
;
return
NS_OK
;
}
}
}
}
*
outDragSelectedText
=
true
;
}
}
return
NS_OK
;
}
