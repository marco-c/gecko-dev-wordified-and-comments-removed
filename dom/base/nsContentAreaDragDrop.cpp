#
include
"
nsReadableUtils
.
h
"
#
include
"
nsContentAreaDragDrop
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsITextControlElement
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIWebBrowserPersist
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
nsIMIMEInfo
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
TabParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsQueryObject
.
h
"
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
IgnoreErrors
;
class
MOZ_STACK_CLASS
DragDataProducer
{
public
:
DragDataProducer
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aTarget
nsIContent
*
aSelectionTargetNode
bool
aIsAltKeyPressed
)
;
nsresult
Produce
(
DataTransfer
*
aDataTransfer
bool
*
aCanDrag
Selection
*
*
aSelection
nsIContent
*
*
aDragNode
nsIPrincipal
*
*
aPrincipal
)
;
private
:
void
AddString
(
DataTransfer
*
aDataTransfer
const
nsAString
&
aFlavor
const
nsAString
&
aData
nsIPrincipal
*
aPrincipal
bool
aHidden
=
false
)
;
nsresult
AddStringsToDataTransfer
(
nsIContent
*
aDragNode
DataTransfer
*
aDataTransfer
)
;
nsresult
GetImageData
(
imgIContainer
*
aImage
imgIRequest
*
aRequest
)
;
static
nsresult
GetDraggableSelectionData
(
Selection
*
inSelection
nsIContent
*
inRealTargetNode
nsIContent
*
*
outImageOrLinkNode
bool
*
outDragSelectedText
)
;
static
already_AddRefed
<
nsIContent
>
FindParentLinkNode
(
nsIContent
*
inNode
)
;
static
MOZ_MUST_USE
nsresult
GetAnchorURL
(
nsIContent
*
inNode
nsAString
&
outURL
)
;
static
void
GetNodeString
(
nsIContent
*
inNode
nsAString
&
outNodeString
)
;
static
void
CreateLinkText
(
const
nsAString
&
inURL
const
nsAString
&
inText
nsAString
&
outLinkText
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
mWindow
;
nsCOMPtr
<
nsIContent
>
mTarget
;
nsCOMPtr
<
nsIContent
>
mSelectionTargetNode
;
bool
mIsAltKeyPressed
;
nsString
mUrlString
;
nsString
mImageSourceString
;
nsString
mImageDestFileName
;
#
if
defined
(
XP_MACOSX
)
nsString
mImageRequestMime
;
#
endif
nsString
mTitleString
;
nsString
mHtmlString
;
nsString
mContextString
;
nsString
mInfoString
;
bool
mIsAnchor
;
nsCOMPtr
<
imgIContainer
>
mImage
;
}
;
nsresult
nsContentAreaDragDrop
:
:
GetDragData
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aTarget
nsIContent
*
aSelectionTargetNode
bool
aIsAltKeyPressed
DataTransfer
*
aDataTransfer
bool
*
aCanDrag
Selection
*
*
aSelection
nsIContent
*
*
aDragNode
nsIPrincipal
*
*
aPrincipal
)
{
NS_ENSURE_TRUE
(
aSelectionTargetNode
NS_ERROR_INVALID_ARG
)
;
*
aCanDrag
=
true
;
DragDataProducer
provider
(
aWindow
aTarget
aSelectionTargetNode
aIsAltKeyPressed
)
;
return
provider
.
Produce
(
aDataTransfer
aCanDrag
aSelection
aDragNode
aPrincipal
)
;
}
NS_IMPL_ISUPPORTS
(
nsContentAreaDragDropDataProvider
nsIFlavorDataProvider
)
nsresult
nsContentAreaDragDropDataProvider
:
:
SaveURIToFile
(
nsIURI
*
inSourceURI
nsIPrincipal
*
inTriggeringPrincipal
nsIFile
*
inDestFile
bool
isPrivate
)
{
nsCOMPtr
<
nsIURL
>
sourceURL
=
do_QueryInterface
(
inSourceURI
)
;
if
(
!
sourceURL
)
{
return
NS_ERROR_NO_INTERFACE
;
}
nsresult
rv
=
inDestFile
-
>
CreateUnique
(
nsIFile
:
:
NORMAL_FILE_TYPE
0600
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIWebBrowserPersist
>
persist
=
do_CreateInstance
(
"
mozilla
.
org
/
embedding
/
browser
/
nsWebBrowserPersist
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
persist
-
>
SetPersistFlags
(
nsIWebBrowserPersist
:
:
PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION
)
;
return
persist
-
>
SavePrivacyAwareURI
(
inSourceURI
inTriggeringPrincipal
0
nullptr
mozilla
:
:
net
:
:
RP_Unset
nullptr
nullptr
inDestFile
isPrivate
)
;
}
nsresult
CheckAndGetExtensionForMime
(
const
nsCString
&
aExtension
const
nsCString
&
aMimeType
bool
*
aIsValidExtension
nsACString
*
aPrimaryExtension
)
{
nsresult
rv
;
nsCOMPtr
<
nsIMIMEService
>
mimeService
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mimeService
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIMIMEInfo
>
mimeInfo
;
rv
=
mimeService
-
>
GetFromTypeAndExtension
(
aMimeType
EmptyCString
(
)
getter_AddRefs
(
mimeInfo
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mimeInfo
-
>
GetPrimaryExtension
(
*
aPrimaryExtension
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aExtension
.
IsEmpty
(
)
)
{
*
aIsValidExtension
=
false
;
return
NS_OK
;
}
rv
=
mimeInfo
-
>
ExtensionExists
(
aExtension
aIsValidExtension
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsContentAreaDragDropDataProvider
:
:
GetFlavorData
(
nsITransferable
*
aTransferable
const
char
*
aFlavor
nsISupports
*
*
aData
)
{
NS_ENSURE_ARG_POINTER
(
aData
)
;
*
aData
=
nullptr
;
nsresult
rv
=
NS_ERROR_NOT_IMPLEMENTED
;
if
(
strcmp
(
aFlavor
kFilePromiseMime
)
=
=
0
)
{
NS_ENSURE_ARG
(
aTransferable
)
;
nsCOMPtr
<
nsISupports
>
tmp
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseURLMime
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISupportsString
>
supportsString
=
do_QueryInterface
(
tmp
)
;
if
(
!
supportsString
)
return
NS_ERROR_FAILURE
;
nsAutoString
sourceURLString
;
supportsString
-
>
GetData
(
sourceURLString
)
;
if
(
sourceURLString
.
IsEmpty
(
)
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIURI
>
sourceURI
;
rv
=
NS_NewURI
(
getter_AddRefs
(
sourceURI
)
sourceURLString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseDestFilename
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
supportsString
=
do_QueryInterface
(
tmp
)
;
if
(
!
supportsString
)
return
NS_ERROR_FAILURE
;
nsAutoString
targetFilename
;
supportsString
-
>
GetData
(
targetFilename
)
;
if
(
targetFilename
.
IsEmpty
(
)
)
return
NS_ERROR_FAILURE
;
#
if
defined
(
XP_MACOSX
)
if
(
XRE_IsParentProcess
(
)
)
{
rv
=
aTransferable
-
>
GetTransferData
(
kImageRequestMime
getter_AddRefs
(
tmp
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
supportsString
=
do_QueryInterface
(
tmp
)
;
if
(
!
supportsString
)
return
NS_ERROR_FAILURE
;
nsAutoString
imageRequestMime
;
supportsString
-
>
GetData
(
imageRequestMime
)
;
if
(
!
imageRequestMime
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIURL
>
imageURL
=
do_QueryInterface
(
sourceURI
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoCString
extension
;
rv
=
imageURL
-
>
GetFileExtension
(
extension
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF16toUTF8
mimeCString
(
imageRequestMime
)
;
bool
isValidExtension
;
nsAutoCString
primaryExtension
;
rv
=
CheckAndGetExtensionForMime
(
extension
mimeCString
&
isValidExtension
&
primaryExtension
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isValidExtension
)
{
nsAutoCString
newFileName
;
rv
=
imageURL
-
>
GetFileBaseName
(
newFileName
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
newFileName
.
Append
(
"
.
"
)
;
newFileName
.
Append
(
primaryExtension
)
;
targetFilename
=
NS_ConvertUTF8toUTF16
(
newFileName
)
;
}
}
}
targetFilename
.
ReplaceChar
(
FILE_PATH_SEPARATOR
FILE_ILLEGAL_CHARACTERS
'
-
'
)
;
#
endif
nsCOMPtr
<
nsISupports
>
dirPrimitive
;
rv
=
aTransferable
-
>
GetTransferData
(
kFilePromiseDirectoryMime
getter_AddRefs
(
dirPrimitive
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIFile
>
destDirectory
=
do_QueryInterface
(
dirPrimitive
)
;
if
(
!
destDirectory
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIFile
>
file
;
rv
=
destDirectory
-
>
Clone
(
getter_AddRefs
(
file
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
file
-
>
Append
(
targetFilename
)
;
bool
isPrivate
=
aTransferable
-
>
GetIsPrivateData
(
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
aTransferable
-
>
GetRequestingPrincipal
(
)
;
rv
=
SaveURIToFile
(
sourceURI
principal
file
isPrivate
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CallQueryInterface
(
file
aData
)
;
}
}
return
rv
;
}
DragDataProducer
:
:
DragDataProducer
(
nsPIDOMWindowOuter
*
aWindow
nsIContent
*
aTarget
nsIContent
*
aSelectionTargetNode
bool
aIsAltKeyPressed
)
:
mWindow
(
aWindow
)
mTarget
(
aTarget
)
mSelectionTargetNode
(
aSelectionTargetNode
)
mIsAltKeyPressed
(
aIsAltKeyPressed
)
mIsAnchor
(
false
)
{
}
already_AddRefed
<
nsIContent
>
DragDataProducer
:
:
FindParentLinkNode
(
nsIContent
*
inNode
)
{
nsIContent
*
content
=
inNode
;
if
(
!
content
)
{
return
nullptr
;
}
for
(
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
nsContentUtils
:
:
IsDraggableLink
(
content
)
)
{
nsCOMPtr
<
nsIContent
>
ret
=
content
;
return
ret
.
forget
(
)
;
}
}
return
nullptr
;
}
nsresult
DragDataProducer
:
:
GetAnchorURL
(
nsIContent
*
inNode
nsAString
&
outURL
)
{
nsCOMPtr
<
nsIURI
>
linkURI
;
if
(
!
inNode
|
|
!
inNode
-
>
IsLink
(
getter_AddRefs
(
linkURI
)
)
)
{
outURL
.
Truncate
(
)
;
return
NS_OK
;
}
nsAutoCString
spec
;
nsresult
rv
=
linkURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
spec
outURL
)
;
return
NS_OK
;
}
void
DragDataProducer
:
:
CreateLinkText
(
const
nsAString
&
inURL
const
nsAString
&
inText
nsAString
&
outLinkText
)
{
nsAutoString
linkText
(
NS_LITERAL_STRING
(
"
<
a
href
=
\
"
"
)
+
inURL
+
NS_LITERAL_STRING
(
"
\
"
>
"
)
+
inText
+
NS_LITERAL_STRING
(
"
<
/
a
>
"
)
)
;
outLinkText
=
linkText
;
}
void
DragDataProducer
:
:
GetNodeString
(
nsIContent
*
inNode
nsAString
&
outNodeString
)
{
nsCOMPtr
<
nsINode
>
node
=
inNode
;
outNodeString
.
Truncate
(
)
;
nsCOMPtr
<
Document
>
doc
=
node
-
>
OwnerDoc
(
)
;
RefPtr
<
nsRange
>
range
=
doc
-
>
CreateRange
(
IgnoreErrors
(
)
)
;
if
(
range
)
{
range
-
>
SelectNode
(
*
node
IgnoreErrors
(
)
)
;
range
-
>
ToString
(
outNodeString
IgnoreErrors
(
)
)
;
}
}
nsresult
DragDataProducer
:
:
GetImageData
(
imgIContainer
*
aImage
imgIRequest
*
aRequest
)
{
nsCOMPtr
<
nsIURI
>
imgUri
;
aRequest
-
>
GetURI
(
getter_AddRefs
(
imgUri
)
)
;
nsCOMPtr
<
nsIURL
>
imgUrl
(
do_QueryInterface
(
imgUri
)
)
;
if
(
imgUrl
)
{
nsAutoCString
spec
;
nsresult
rv
=
imgUrl
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
spec
mImageSourceString
)
;
nsCString
mimeType
;
aRequest
-
>
GetMimeType
(
getter_Copies
(
mimeType
)
)
;
#
if
defined
(
XP_MACOSX
)
CopyUTF8toUTF16
(
mimeType
mImageRequestMime
)
;
#
else
nsCOMPtr
<
nsIMIMEService
>
mimeService
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
NS_WARN_IF
(
!
mimeService
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIMIMEInfo
>
mimeInfo
;
mimeService
-
>
GetFromTypeAndExtension
(
mimeType
EmptyCString
(
)
getter_AddRefs
(
mimeInfo
)
)
;
if
(
mimeInfo
)
{
nsAutoCString
extension
;
imgUrl
-
>
GetFileExtension
(
extension
)
;
bool
validExtension
;
if
(
extension
.
IsEmpty
(
)
|
|
NS_FAILED
(
mimeInfo
-
>
ExtensionExists
(
extension
&
validExtension
)
)
|
|
!
validExtension
)
{
nsAutoCString
primaryExtension
;
mimeInfo
-
>
GetPrimaryExtension
(
primaryExtension
)
;
rv
=
NS_MutateURI
(
imgUrl
)
.
Apply
(
NS_MutatorMethod
(
&
nsIURLMutator
:
:
SetFileExtension
primaryExtension
nullptr
)
)
.
Finalize
(
imgUrl
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
#
endif
nsAutoCString
fileName
;
imgUrl
-
>
GetFileName
(
fileName
)
;
NS_UnescapeURL
(
fileName
)
;
#
if
!
defined
(
XP_MACOSX
)
fileName
.
ReplaceChar
(
FILE_PATH_SEPARATOR
FILE_ILLEGAL_CHARACTERS
'
-
'
)
;
#
endif
CopyUTF8toUTF16
(
fileName
mImageDestFileName
)
;
mImage
=
aImage
;
}
return
NS_OK
;
}
nsresult
DragDataProducer
:
:
Produce
(
DataTransfer
*
aDataTransfer
bool
*
aCanDrag
Selection
*
*
aSelection
nsIContent
*
*
aDragNode
nsIPrincipal
*
*
aPrincipal
)
{
MOZ_ASSERT
(
aCanDrag
&
&
aSelection
&
&
aDataTransfer
&
&
aDragNode
"
null
pointer
passed
to
Produce
"
)
;
NS_ASSERTION
(
mWindow
"
window
not
set
"
)
;
NS_ASSERTION
(
mSelectionTargetNode
"
selection
target
node
should
have
been
set
"
)
;
*
aDragNode
=
nullptr
;
nsresult
rv
;
nsIContent
*
dragNode
=
nullptr
;
*
aSelection
=
nullptr
;
RefPtr
<
Selection
>
selection
;
nsIContent
*
editingElement
=
mSelectionTargetNode
-
>
IsEditable
(
)
?
mSelectionTargetNode
-
>
GetEditingHost
(
)
:
nullptr
;
nsCOMPtr
<
nsITextControlElement
>
textControl
=
nsITextControlElement
:
:
GetTextControlElementFromEditingHost
(
editingElement
)
;
if
(
textControl
)
{
nsISelectionController
*
selcon
=
textControl
-
>
GetSelectionController
(
)
;
if
(
selcon
)
{
selection
=
selcon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
}
if
(
!
selection
)
return
NS_OK
;
}
else
{
selection
=
mWindow
-
>
GetSelection
(
)
;
if
(
!
selection
)
return
NS_OK
;
nsCOMPtr
<
nsIContent
>
findFormNode
=
mSelectionTargetNode
;
nsIContent
*
findFormParent
=
findFormNode
-
>
GetParent
(
)
;
while
(
findFormParent
)
{
nsCOMPtr
<
nsIFormControl
>
form
(
do_QueryInterface
(
findFormParent
)
)
;
if
(
form
&
&
!
form
-
>
AllowDraggableChildren
(
)
)
{
return
NS_OK
;
}
findFormParent
=
findFormParent
-
>
GetParent
(
)
;
}
}
nsCOMPtr
<
nsIContent
>
nodeToSerialize
;
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
mWindow
-
>
GetDocShell
(
)
;
const
bool
isChromeShell
=
dsti
&
&
dsti
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
;
if
(
isChromeShell
&
&
!
editingElement
)
{
RefPtr
<
nsFrameLoaderOwner
>
flo
=
do_QueryObject
(
mTarget
)
;
if
(
flo
)
{
RefPtr
<
nsFrameLoader
>
fl
=
flo
-
>
GetFrameLoader
(
)
;
if
(
fl
)
{
TabParent
*
tp
=
static_cast
<
TabParent
*
>
(
fl
-
>
GetRemoteBrowser
(
)
)
;
if
(
tp
)
{
tp
-
>
AddInitialDnDDataTo
(
aDataTransfer
aPrincipal
)
;
}
}
}
return
NS_OK
;
}
if
(
isChromeShell
&
&
textControl
)
{
if
(
!
selection
-
>
ContainsNode
(
*
mSelectionTargetNode
false
IgnoreErrors
(
)
)
)
return
NS_OK
;
selection
.
swap
(
*
aSelection
)
;
}
else
{
bool
haveSelectedContent
=
false
;
nsCOMPtr
<
nsIContent
>
parentLink
;
nsCOMPtr
<
nsIContent
>
draggedNode
;
{
nsCOMPtr
<
nsIFormControl
>
form
(
do_QueryInterface
(
mTarget
)
)
;
if
(
form
&
&
!
mIsAltKeyPressed
&
&
form
-
>
ControlType
(
)
!
=
NS_FORM_OBJECT
)
{
*
aCanDrag
=
false
;
return
NS_OK
;
}
draggedNode
=
mTarget
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
image
;
nsCOMPtr
<
nsIContent
>
selectedImageOrLinkNode
;
GetDraggableSelectionData
(
selection
mSelectionTargetNode
getter_AddRefs
(
selectedImageOrLinkNode
)
&
haveSelectedContent
)
;
if
(
haveSelectedContent
)
{
selection
.
swap
(
*
aSelection
)
;
}
else
if
(
selectedImageOrLinkNode
)
{
image
=
do_QueryInterface
(
selectedImageOrLinkNode
)
;
}
else
{
parentLink
=
FindParentLinkNode
(
draggedNode
)
;
if
(
parentLink
&
&
mIsAltKeyPressed
)
{
*
aCanDrag
=
false
;
return
NS_OK
;
}
image
=
do_QueryInterface
(
draggedNode
)
;
}
{
nsCOMPtr
<
nsIContent
>
linkNode
;
RefPtr
<
HTMLAreaElement
>
areaElem
=
HTMLAreaElement
:
:
FromNodeOrNull
(
draggedNode
)
;
if
(
areaElem
)
{
areaElem
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
alt
"
)
mTitleString
)
;
if
(
mTitleString
.
IsEmpty
(
)
)
{
areaElem
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
href
"
)
mTitleString
)
;
}
mIsAnchor
=
true
;
nsresult
rv
=
GetAnchorURL
(
draggedNode
mUrlString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mHtmlString
.
AssignLiteral
(
"
<
a
href
=
\
"
"
)
;
mHtmlString
.
Append
(
mUrlString
)
;
mHtmlString
.
AppendLiteral
(
"
\
"
>
"
)
;
mHtmlString
.
Append
(
mTitleString
)
;
mHtmlString
.
AppendLiteral
(
"
<
/
a
>
"
)
;
dragNode
=
draggedNode
;
}
else
if
(
image
)
{
mIsAnchor
=
true
;
nsCOMPtr
<
nsIURI
>
imageURI
;
image
-
>
GetCurrentURI
(
getter_AddRefs
(
imageURI
)
)
;
if
(
imageURI
)
{
nsAutoCString
spec
;
rv
=
imageURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
spec
mUrlString
)
;
}
nsCOMPtr
<
Element
>
imageElement
(
do_QueryInterface
(
image
)
)
;
if
(
imageElement
)
{
imageElement
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
alt
"
)
mTitleString
)
;
}
if
(
mTitleString
.
IsEmpty
(
)
)
{
mTitleString
=
mUrlString
;
}
nsCOMPtr
<
imgIRequest
>
imgRequest
;
nsCOMPtr
<
imgIContainer
>
img
=
nsContentUtils
:
:
GetImageFromContent
(
image
getter_AddRefs
(
imgRequest
)
)
;
if
(
imgRequest
)
{
rv
=
GetImageData
(
img
imgRequest
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
parentLink
)
{
linkNode
=
parentLink
;
nodeToSerialize
=
linkNode
;
}
else
{
nodeToSerialize
=
draggedNode
;
}
dragNode
=
nodeToSerialize
;
}
else
if
(
draggedNode
&
&
draggedNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
linkNode
=
draggedNode
;
GetNodeString
(
draggedNode
mTitleString
)
;
}
else
if
(
parentLink
)
{
linkNode
=
parentLink
;
nodeToSerialize
=
linkNode
;
}
else
if
(
!
haveSelectedContent
)
{
return
NS_OK
;
}
if
(
linkNode
)
{
mIsAnchor
=
true
;
rv
=
GetAnchorURL
(
linkNode
mUrlString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
dragNode
=
linkNode
;
}
}
}
if
(
nodeToSerialize
|
|
*
aSelection
)
{
mHtmlString
.
Truncate
(
)
;
mContextString
.
Truncate
(
)
;
mInfoString
.
Truncate
(
)
;
mTitleString
.
Truncate
(
)
;
nsCOMPtr
<
Document
>
doc
=
mWindow
-
>
GetDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsITransferable
>
transferable
;
if
(
*
aSelection
)
{
rv
=
nsCopySupport
:
:
GetTransferableForSelection
(
*
aSelection
doc
getter_AddRefs
(
transferable
)
)
;
}
else
{
rv
=
nsCopySupport
:
:
GetTransferableForNode
(
nodeToSerialize
doc
getter_AddRefs
(
transferable
)
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsISupports
>
supports
;
nsCOMPtr
<
nsISupportsString
>
data
;
rv
=
transferable
-
>
GetTransferData
(
kHTMLMime
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
data
-
>
GetData
(
mHtmlString
)
;
}
rv
=
transferable
-
>
GetTransferData
(
kHTMLContext
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
data
-
>
GetData
(
mContextString
)
;
}
rv
=
transferable
-
>
GetTransferData
(
kHTMLInfo
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
data
-
>
GetData
(
mInfoString
)
;
}
rv
=
transferable
-
>
GetTransferData
(
kUnicodeMime
getter_AddRefs
(
supports
)
)
;
data
=
do_QueryInterface
(
supports
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
data
-
>
GetData
(
mTitleString
)
;
}
if
(
mTitleString
.
IsEmpty
(
)
)
{
mTitleString
=
mUrlString
;
}
if
(
mHtmlString
.
IsEmpty
(
)
&
&
!
mUrlString
.
IsEmpty
(
)
)
CreateLinkText
(
mUrlString
mTitleString
mHtmlString
)
;
rv
=
AddStringsToDataTransfer
(
dragNode
?
dragNode
:
mSelectionTargetNode
.
get
(
)
aDataTransfer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_IF_ADDREF
(
*
aDragNode
=
dragNode
)
;
return
NS_OK
;
}
void
DragDataProducer
:
:
AddString
(
DataTransfer
*
aDataTransfer
const
nsAString
&
aFlavor
const
nsAString
&
aData
nsIPrincipal
*
aPrincipal
bool
aHidden
)
{
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsAString
(
aData
)
;
aDataTransfer
-
>
SetDataWithPrincipal
(
aFlavor
variant
0
aPrincipal
aHidden
)
;
}
nsresult
DragDataProducer
:
:
AddStringsToDataTransfer
(
nsIContent
*
aDragNode
DataTransfer
*
aDataTransfer
)
{
NS_ASSERTION
(
aDragNode
"
adding
strings
for
null
node
"
)
;
nsIPrincipal
*
principal
=
aDragNode
-
>
NodePrincipal
(
)
;
if
(
!
mUrlString
.
IsEmpty
(
)
&
&
mIsAnchor
)
{
nsAutoString
dragData
(
mUrlString
)
;
dragData
.
Append
(
'
\
n
'
)
;
nsAutoString
title
(
mTitleString
)
;
title
.
Trim
(
"
\
r
\
n
"
)
;
title
.
ReplaceChar
(
"
\
r
\
n
"
'
'
)
;
dragData
+
=
title
;
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kURLMime
)
dragData
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kURLDataMime
)
mUrlString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kURLDescriptionMime
)
mTitleString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
"
text
/
uri
-
list
"
)
mUrlString
principal
)
;
}
if
(
!
mContextString
.
IsEmpty
(
)
)
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLContext
)
mContextString
principal
)
;
if
(
!
mInfoString
.
IsEmpty
(
)
)
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLInfo
)
mInfoString
principal
)
;
if
(
!
mHtmlString
.
IsEmpty
(
)
)
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kHTMLMime
)
mHtmlString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kTextMime
)
mIsAnchor
?
mUrlString
:
mTitleString
principal
)
;
if
(
mImage
)
{
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsISupports
(
mImage
)
;
aDataTransfer
-
>
SetDataWithPrincipal
(
NS_LITERAL_STRING
(
kNativeImageMime
)
variant
0
principal
)
;
nsCOMPtr
<
nsIFlavorDataProvider
>
dataProvider
=
new
nsContentAreaDragDropDataProvider
(
)
;
if
(
dataProvider
)
{
RefPtr
<
nsVariantCC
>
variant
=
new
nsVariantCC
(
)
;
variant
-
>
SetAsISupports
(
dataProvider
)
;
aDataTransfer
-
>
SetDataWithPrincipal
(
NS_LITERAL_STRING
(
kFilePromiseMime
)
variant
0
principal
)
;
}
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kFilePromiseURLMime
)
mImageSourceString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kFilePromiseDestFilename
)
mImageDestFileName
principal
)
;
#
if
defined
(
XP_MACOSX
)
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kImageRequestMime
)
mImageRequestMime
principal
true
)
;
#
endif
if
(
!
mIsAnchor
)
{
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
kURLDataMime
)
mUrlString
principal
)
;
AddString
(
aDataTransfer
NS_LITERAL_STRING
(
"
text
/
uri
-
list
"
)
mUrlString
principal
)
;
}
}
return
NS_OK
;
}
nsresult
DragDataProducer
:
:
GetDraggableSelectionData
(
Selection
*
inSelection
nsIContent
*
inRealTargetNode
nsIContent
*
*
outImageOrLinkNode
bool
*
outDragSelectedText
)
{
NS_ENSURE_ARG
(
inSelection
)
;
NS_ENSURE_ARG
(
inRealTargetNode
)
;
NS_ENSURE_ARG_POINTER
(
outImageOrLinkNode
)
;
*
outImageOrLinkNode
=
nullptr
;
*
outDragSelectedText
=
false
;
if
(
!
inSelection
-
>
IsCollapsed
(
)
)
{
if
(
inSelection
-
>
ContainsNode
(
*
inRealTargetNode
false
IgnoreErrors
(
)
)
)
{
nsINode
*
selectionStart
=
inSelection
-
>
GetAnchorNode
(
)
;
nsINode
*
selectionEnd
=
inSelection
-
>
GetFocusNode
(
)
;
if
(
selectionStart
=
=
selectionEnd
)
{
nsCOMPtr
<
nsIContent
>
selStartContent
=
nsIContent
:
:
FromNodeOrNull
(
selectionStart
)
;
if
(
selStartContent
&
&
selStartContent
-
>
HasChildNodes
(
)
)
{
uint32_t
anchorOffset
=
inSelection
-
>
AnchorOffset
(
)
;
uint32_t
focusOffset
=
inSelection
-
>
FocusOffset
(
)
;
if
(
anchorOffset
=
=
focusOffset
+
1
|
|
focusOffset
=
=
anchorOffset
+
1
)
{
uint32_t
childOffset
=
std
:
:
min
(
anchorOffset
focusOffset
)
;
nsIContent
*
childContent
=
selStartContent
-
>
GetChildAt_Deprecated
(
childOffset
)
;
if
(
nsContentUtils
:
:
IsDraggableImage
(
childContent
)
)
{
NS_ADDREF
(
*
outImageOrLinkNode
=
childContent
)
;
return
NS_OK
;
}
}
}
}
*
outDragSelectedText
=
true
;
}
}
return
NS_OK
;
}
