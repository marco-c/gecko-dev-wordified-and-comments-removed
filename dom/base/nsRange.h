#
ifndef
nsRange_h___
#
define
nsRange_h___
#
include
"
nsIDOMRange
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
prmon
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
struct
ClientRectsAndTexts
;
class
DocumentFragment
;
class
DOMRect
;
class
DOMRectList
;
class
Selection
;
}
}
class
nsRange
final
:
public
nsIDOMRange
public
nsStubMutationObserver
public
nsWrapperCache
{
typedef
mozilla
:
:
ErrorResult
ErrorResult
;
typedef
mozilla
:
:
dom
:
:
DOMRect
DOMRect
;
typedef
mozilla
:
:
dom
:
:
DOMRectList
DOMRectList
;
virtual
~
nsRange
(
)
;
public
:
explicit
nsRange
(
nsINode
*
aNode
)
;
static
nsresult
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndContainer
uint32_t
aEndOffset
nsRange
*
*
aRange
)
;
static
nsresult
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndContainer
uint32_t
aEndOffset
nsIDOMRange
*
*
aRange
)
;
static
nsresult
CreateRange
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
nsRange
*
*
aRange
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsRange
nsIDOMRange
)
nsrefcnt
GetRefCount
(
)
const
{
return
mRefCnt
;
}
NS_DECL_NSIDOMRANGE
nsINode
*
GetRoot
(
)
const
{
return
mRoot
;
}
nsINode
*
GetStartContainer
(
)
const
{
return
mStartContainer
;
}
nsINode
*
GetEndContainer
(
)
const
{
return
mEndContainer
;
}
uint32_t
StartOffset
(
)
const
{
return
mStartOffset
;
}
uint32_t
EndOffset
(
)
const
{
return
mEndOffset
;
}
bool
IsPositioned
(
)
const
{
return
mIsPositioned
;
}
void
SetMaySpanAnonymousSubtrees
(
bool
aMaySpanAnonymousSubtrees
)
{
mMaySpanAnonymousSubtrees
=
aMaySpanAnonymousSubtrees
;
}
bool
IsInSelection
(
)
const
{
return
!
!
mSelection
;
}
void
SetSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
)
;
bool
IsGenerated
(
)
const
{
return
mIsGenerated
;
}
void
SetIsGenerated
(
bool
aIsGenerated
)
{
mIsGenerated
=
aIsGenerated
;
}
nsINode
*
GetCommonAncestor
(
)
const
;
void
Reset
(
)
;
nsresult
SetStart
(
nsINode
*
aContainer
uint32_t
aOffset
)
;
nsresult
SetEnd
(
nsINode
*
aContainer
uint32_t
aOffset
)
;
already_AddRefed
<
nsRange
>
CloneRange
(
)
const
;
nsresult
SetStartAndEnd
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
;
nsresult
CollapseTo
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
return
SetStartAndEnd
(
aContainer
aOffset
aContainer
aOffset
)
;
}
static
nsINode
*
GetContainerAndOffsetAfter
(
nsINode
*
aNode
uint32_t
*
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOffset
)
;
*
aOffset
=
0
;
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
nullptr
;
}
int32_t
indexInParent
=
parentNode
-
>
IndexOf
(
aNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
nullptr
;
}
*
aOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
+
1
;
return
parentNode
;
}
static
nsINode
*
GetContainerAndOffsetBefore
(
nsINode
*
aNode
uint32_t
*
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOffset
)
;
*
aOffset
=
0
;
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
nullptr
;
}
int32_t
indexInParent
=
parentNode
-
>
IndexOf
(
aNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
nullptr
;
}
*
aOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
;
return
parentNode
;
}
NS_IMETHOD
GetUsedFontFaces
(
nsIDOMFontFaceList
*
*
aResult
)
;
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
static
already_AddRefed
<
nsRange
>
Constructor
(
const
mozilla
:
:
dom
:
:
GlobalObject
&
global
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
Collapsed
(
)
const
{
return
mIsPositioned
&
&
mStartContainer
=
=
mEndContainer
&
&
mStartOffset
=
=
mEndOffset
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CreateContextualFragment
(
const
nsAString
&
aString
ErrorResult
&
aError
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CloneContents
(
ErrorResult
&
aErr
)
;
int16_t
CompareBoundaryPoints
(
uint16_t
aHow
nsRange
&
aOther
ErrorResult
&
aErr
)
;
int16_t
ComparePoint
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
DeleteContents
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
ExtractContents
(
ErrorResult
&
aErr
)
;
nsINode
*
GetCommonAncestorContainer
(
ErrorResult
&
aRv
)
const
;
nsINode
*
GetStartContainer
(
ErrorResult
&
aRv
)
const
;
uint32_t
GetStartOffset
(
ErrorResult
&
aRv
)
const
;
nsINode
*
GetEndContainer
(
ErrorResult
&
aRv
)
const
;
uint32_t
GetEndOffset
(
ErrorResult
&
aRv
)
const
;
void
InsertNode
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
bool
IntersectsNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
;
bool
IsPointInRange
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
CollapseJS
(
bool
aToStart
)
;
void
SelectNodeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SelectNodeContentsJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetEndAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetStartAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SurroundContents
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
already_AddRefed
<
DOMRect
>
GetBoundingClientRect
(
bool
aClampToEdge
=
true
bool
aFlushLayout
=
true
)
;
already_AddRefed
<
DOMRectList
>
GetClientRects
(
bool
aClampToEdge
=
true
bool
aFlushLayout
=
true
)
;
void
GetClientRectsAndTexts
(
mozilla
:
:
dom
:
:
ClientRectsAndTexts
&
aResult
ErrorResult
&
aErr
)
;
void
SelectNode
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SelectNodeContents
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEnd
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetEndAfter
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndBefore
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStart
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetStartAfter
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartBefore
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
static
void
GetInnerTextNoFlush
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
mozilla
:
:
ErrorResult
&
aError
nsIContent
*
aStartContainer
uint32_t
aStartOffset
nsIContent
*
aEndContainer
uint32_t
aEndOffset
)
;
nsINode
*
GetParentObject
(
)
const
{
return
mOwner
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
final
;
private
:
nsRange
(
const
nsRange
&
)
;
nsRange
&
operator
=
(
const
nsRange
&
)
;
nsresult
CutContents
(
mozilla
:
:
dom
:
:
DocumentFragment
*
*
frag
)
;
static
nsresult
CloneParentsBetween
(
nsINode
*
aAncestor
nsINode
*
aNode
nsINode
*
*
aClosestAncestor
nsINode
*
*
aFarthestAncestor
)
;
public
:
static
nsINode
*
ComputeRootNode
(
nsINode
*
aNode
)
{
return
ComputeRootNode
(
aNode
false
)
;
}
static
bool
IsValidPoints
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
;
static
nsresult
CompareNodeToRange
(
nsINode
*
aNode
nsRange
*
aRange
bool
*
outNodeBefore
bool
*
outNodeAfter
)
;
static
bool
IsNodeSelected
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
static
void
CollectClientRectsAndText
(
nsLayoutUtils
:
:
RectCallback
*
aCollector
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
*
aTextList
nsRange
*
aRange
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
bool
aClampToEdge
bool
aFlushLayout
)
;
void
ExcludeNonSelectableNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
*
aOutRanges
)
;
typedef
nsTHashtable
<
nsPtrHashKey
<
nsRange
>
>
RangeHashTable
;
protected
:
void
RegisterCommonAncestor
(
nsINode
*
aNode
)
;
void
UnregisterCommonAncestor
(
nsINode
*
aNode
)
;
nsINode
*
IsValidBoundary
(
nsINode
*
aNode
)
const
{
return
ComputeRootNode
(
aNode
mMaySpanAnonymousSubtrees
)
;
}
static
bool
IsValidOffset
(
uint32_t
aOffset
)
{
return
aOffset
<
=
INT32_MAX
;
}
static
bool
IsValidOffset
(
nsINode
*
aNode
uint32_t
aOffset
)
;
static
nsINode
*
ComputeRootNode
(
nsINode
*
aNode
bool
aMaySpanAnonymousSubtrees
)
;
void
DoSetRange
(
nsINode
*
aStartN
uint32_t
aStartOffset
nsINode
*
aEndN
uint32_t
aEndOffset
nsINode
*
aRoot
bool
aNotInsertedYet
=
false
)
;
nsINode
*
GetRegisteredCommonAncestor
(
)
;
static
bool
IsNodeInSortedRanges
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
const
nsTArray
<
const
nsRange
*
>
&
aRanges
size_t
aRangeStart
size_t
aRangeEnd
)
;
class
MOZ_RAII
AutoCalledByJSRestore
final
{
private
:
nsRange
&
mRange
;
bool
mOldValue
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoCalledByJSRestore
(
nsRange
&
aRange
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mRange
(
aRange
)
mOldValue
(
aRange
.
mCalledByJS
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoCalledByJSRestore
(
)
{
mRange
.
mCalledByJS
=
mOldValue
;
}
bool
SavedValue
(
)
const
{
return
mOldValue
;
}
}
;
struct
MOZ_STACK_CLASS
AutoInvalidateSelection
{
explicit
AutoInvalidateSelection
(
nsRange
*
aRange
)
:
mRange
(
aRange
)
{
#
ifdef
DEBUG
mWasInSelection
=
mRange
-
>
IsInSelection
(
)
;
#
endif
if
(
!
mRange
-
>
IsInSelection
(
)
|
|
mIsNested
)
{
return
;
}
mIsNested
=
true
;
mCommonAncestor
=
mRange
-
>
GetRegisteredCommonAncestor
(
)
;
}
~
AutoInvalidateSelection
(
)
;
nsRange
*
mRange
;
RefPtr
<
nsINode
>
mCommonAncestor
;
#
ifdef
DEBUG
bool
mWasInSelection
;
#
endif
static
bool
mIsNested
;
}
;
nsCOMPtr
<
nsIDocument
>
mOwner
;
nsCOMPtr
<
nsINode
>
mRoot
;
nsCOMPtr
<
nsINode
>
mStartContainer
;
nsCOMPtr
<
nsINode
>
mEndContainer
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
mSelection
;
uint32_t
mStartOffset
;
uint32_t
mEndOffset
;
bool
mIsPositioned
:
1
;
bool
mMaySpanAnonymousSubtrees
:
1
;
bool
mIsGenerated
:
1
;
bool
mStartOffsetWasIncremented
:
1
;
bool
mEndOffsetWasIncremented
:
1
;
bool
mCalledByJS
:
1
;
#
ifdef
DEBUG
int32_t
mAssertNextInsertOrAppendIndex
;
nsINode
*
mAssertNextInsertOrAppendNode
;
#
endif
}
;
inline
nsISupports
*
ToCanonicalSupports
(
nsRange
*
aRange
)
{
return
static_cast
<
nsIDOMRange
*
>
(
aRange
)
;
}
inline
nsISupports
*
ToSupports
(
nsRange
*
aRange
)
{
return
static_cast
<
nsIDOMRange
*
>
(
aRange
)
;
}
#
endif
