#
ifndef
nsRange_h___
#
define
nsRange_h___
#
include
"
nsIDOMRange
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
prmon
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
struct
ClientRectsAndTexts
;
class
DocumentFragment
;
class
DOMRect
;
class
DOMRectList
;
class
Selection
;
}
}
class
nsRange
final
:
public
nsIDOMRange
public
nsStubMutationObserver
public
nsWrapperCache
{
typedef
mozilla
:
:
ErrorResult
ErrorResult
;
typedef
mozilla
:
:
dom
:
:
DOMRect
DOMRect
;
typedef
mozilla
:
:
dom
:
:
DOMRectList
DOMRectList
;
virtual
~
nsRange
(
)
;
public
:
explicit
nsRange
(
nsINode
*
aNode
)
;
static
nsresult
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndContainer
uint32_t
aEndOffset
nsRange
*
*
aRange
)
;
static
nsresult
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndContainer
uint32_t
aEndOffset
nsIDOMRange
*
*
aRange
)
;
static
nsresult
CreateRange
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
nsRange
*
*
aRange
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsRange
nsIDOMRange
)
nsrefcnt
GetRefCount
(
)
const
{
return
mRefCnt
;
}
NS_DECL_NSIDOMRANGE
nsINode
*
GetRoot
(
)
const
{
return
mRoot
;
}
nsINode
*
GetStartContainer
(
)
const
{
return
mStart
.
Container
(
)
;
}
nsINode
*
GetEndContainer
(
)
const
{
return
mEnd
.
Container
(
)
;
}
uint32_t
StartOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
mStart
.
Offset
(
)
)
;
}
uint32_t
EndOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
mEnd
.
Offset
(
)
)
;
}
bool
IsPositioned
(
)
const
{
return
mIsPositioned
;
}
void
SetMaySpanAnonymousSubtrees
(
bool
aMaySpanAnonymousSubtrees
)
{
mMaySpanAnonymousSubtrees
=
aMaySpanAnonymousSubtrees
;
}
bool
IsInSelection
(
)
const
{
return
!
!
mSelection
;
}
void
SetSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
)
;
bool
IsGenerated
(
)
const
{
return
mIsGenerated
;
}
void
SetIsGenerated
(
bool
aIsGenerated
)
{
mIsGenerated
=
aIsGenerated
;
}
nsINode
*
GetCommonAncestor
(
)
const
;
void
Reset
(
)
;
nsresult
SetStart
(
nsINode
*
aContainer
uint32_t
aOffset
)
;
nsresult
SetEnd
(
nsINode
*
aContainer
uint32_t
aOffset
)
;
already_AddRefed
<
nsRange
>
CloneRange
(
)
const
;
nsresult
SetStartAndEnd
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
;
nsresult
CollapseTo
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
return
SetStartAndEnd
(
aContainer
aOffset
aContainer
aOffset
)
;
}
static
nsINode
*
GetContainerAndOffsetAfter
(
nsINode
*
aNode
uint32_t
*
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOffset
)
;
*
aOffset
=
0
;
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
nullptr
;
}
int32_t
indexInParent
=
parentNode
-
>
IndexOf
(
aNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
nullptr
;
}
*
aOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
+
1
;
return
parentNode
;
}
static
nsINode
*
GetContainerAndOffsetBefore
(
nsINode
*
aNode
uint32_t
*
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOffset
)
;
*
aOffset
=
0
;
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
nullptr
;
}
int32_t
indexInParent
=
parentNode
-
>
IndexOf
(
aNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
nullptr
;
}
*
aOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
;
return
parentNode
;
}
NS_IMETHOD
GetUsedFontFaces
(
nsIDOMFontFaceList
*
*
aResult
)
;
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
static
already_AddRefed
<
nsRange
>
Constructor
(
const
mozilla
:
:
dom
:
:
GlobalObject
&
global
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
Collapsed
(
)
const
{
return
mIsPositioned
&
&
mStart
.
Container
(
)
=
=
mEnd
.
Container
(
)
&
&
mStart
.
Offset
(
)
=
=
mEnd
.
Offset
(
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CreateContextualFragment
(
const
nsAString
&
aString
ErrorResult
&
aError
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CloneContents
(
ErrorResult
&
aErr
)
;
int16_t
CompareBoundaryPoints
(
uint16_t
aHow
nsRange
&
aOther
ErrorResult
&
aErr
)
;
int16_t
ComparePoint
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
DeleteContents
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
ExtractContents
(
ErrorResult
&
aErr
)
;
nsINode
*
GetCommonAncestorContainer
(
ErrorResult
&
aRv
)
const
;
nsINode
*
GetStartContainer
(
ErrorResult
&
aRv
)
const
;
uint32_t
GetStartOffset
(
ErrorResult
&
aRv
)
const
;
nsINode
*
GetEndContainer
(
ErrorResult
&
aRv
)
const
;
uint32_t
GetEndOffset
(
ErrorResult
&
aRv
)
const
;
void
InsertNode
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
bool
IntersectsNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
;
bool
IsPointInRange
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
CollapseJS
(
bool
aToStart
)
;
void
SelectNodeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SelectNodeContentsJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetEndAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetStartAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SurroundContents
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
already_AddRefed
<
DOMRect
>
GetBoundingClientRect
(
bool
aClampToEdge
=
true
bool
aFlushLayout
=
true
)
;
already_AddRefed
<
DOMRectList
>
GetClientRects
(
bool
aClampToEdge
=
true
bool
aFlushLayout
=
true
)
;
void
GetClientRectsAndTexts
(
mozilla
:
:
dom
:
:
ClientRectsAndTexts
&
aResult
ErrorResult
&
aErr
)
;
void
SelectNode
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SelectNodeContents
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEnd
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetEndAfter
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndBefore
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStart
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetStartAfter
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartBefore
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
static
void
GetInnerTextNoFlush
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
mozilla
:
:
ErrorResult
&
aError
nsIContent
*
aStartContainer
uint32_t
aStartOffset
nsIContent
*
aEndContainer
uint32_t
aEndOffset
)
;
nsINode
*
GetParentObject
(
)
const
{
return
mOwner
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
final
;
private
:
nsRange
(
const
nsRange
&
)
;
nsRange
&
operator
=
(
const
nsRange
&
)
;
nsresult
CutContents
(
mozilla
:
:
dom
:
:
DocumentFragment
*
*
frag
)
;
static
nsresult
CloneParentsBetween
(
nsINode
*
aAncestor
nsINode
*
aNode
nsINode
*
*
aClosestAncestor
nsINode
*
*
aFarthestAncestor
)
;
public
:
static
nsINode
*
ComputeRootNode
(
nsINode
*
aNode
)
{
return
ComputeRootNode
(
aNode
false
)
;
}
static
bool
IsValidPoints
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
;
static
nsresult
CompareNodeToRange
(
nsINode
*
aNode
nsRange
*
aRange
bool
*
outNodeBefore
bool
*
outNodeAfter
)
;
static
bool
IsNodeSelected
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
static
void
CollectClientRectsAndText
(
nsLayoutUtils
:
:
RectCallback
*
aCollector
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
*
aTextList
nsRange
*
aRange
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
bool
aClampToEdge
bool
aFlushLayout
)
;
void
ExcludeNonSelectableNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
*
aOutRanges
)
;
typedef
nsTHashtable
<
nsPtrHashKey
<
nsRange
>
>
RangeHashTable
;
protected
:
template
<
typename
ParentType
typename
RefType
>
class
RangeBoundaryBase
{
friend
class
nsRange
;
public
:
RangeBoundaryBase
(
nsINode
*
aContainer
nsIContent
*
aRef
)
:
mParent
(
aContainer
)
mRef
(
aRef
)
{
if
(
!
mRef
)
{
mOffset
=
mozilla
:
:
Some
(
0
)
;
}
else
{
mOffset
.
reset
(
)
;
}
}
RangeBoundaryBase
(
nsINode
*
aContainer
int32_t
aOffset
)
:
mParent
(
aContainer
)
mRef
(
nullptr
)
mOffset
(
mozilla
:
:
Some
(
aOffset
)
)
{
if
(
mParent
&
&
mParent
-
>
IsContainerNode
(
)
)
{
if
(
aOffset
=
=
static_cast
<
int32_t
>
(
aContainer
-
>
GetChildCount
(
)
)
)
{
mRef
=
aContainer
-
>
GetLastChild
(
)
;
}
else
if
(
aOffset
!
=
0
)
{
mRef
=
mParent
-
>
GetChildAt
(
aOffset
-
1
)
;
MOZ_ASSERT
(
mRef
)
;
}
MOZ_ASSERT_IF
(
!
mRef
aOffset
=
=
0
)
;
}
MOZ_ASSERT_IF
(
mRef
mRef
-
>
GetParentNode
(
)
=
=
mParent
)
;
}
RangeBoundaryBase
(
)
:
mParent
(
nullptr
)
mRef
(
nullptr
)
{
}
explicit
RangeBoundaryBase
(
const
RangeBoundaryBase
<
nsCOMPtr
<
nsINode
>
nsCOMPtr
<
nsIContent
>
>
&
aOther
)
:
mParent
(
aOther
.
mParent
)
mRef
(
aOther
.
mRef
)
mOffset
(
aOther
.
mOffset
)
{
}
nsIContent
*
Ref
(
)
const
{
return
mRef
;
}
nsINode
*
Container
(
)
const
{
return
mParent
;
}
nsIContent
*
GetChildAtOffset
(
)
const
{
if
(
!
mParent
|
|
!
mParent
-
>
IsContainerNode
(
)
)
{
return
nullptr
;
}
if
(
!
mRef
)
{
MOZ_ASSERT
(
Offset
(
)
=
=
0
)
;
return
mParent
-
>
GetFirstChild
(
)
;
}
MOZ_ASSERT
(
mParent
-
>
GetChildAt
(
Offset
(
)
)
=
=
mRef
-
>
GetNextSibling
(
)
)
;
return
mRef
-
>
GetNextSibling
(
)
;
}
uint32_t
Offset
(
)
const
{
if
(
mOffset
.
isSome
(
)
)
{
return
mOffset
.
value
(
)
;
}
if
(
!
mParent
)
{
return
0
;
}
MOZ_ASSERT
(
mRef
)
;
MOZ_ASSERT
(
mRef
-
>
GetParentNode
(
)
=
=
mParent
)
;
mOffset
=
mozilla
:
:
Some
(
mParent
-
>
IndexOf
(
mRef
)
+
1
)
;
return
mOffset
.
value
(
)
;
}
void
InvalidateOffset
(
)
{
MOZ_ASSERT
(
mParent
)
;
MOZ_ASSERT
(
mParent
-
>
IsContainerNode
(
)
"
Range
is
positioned
on
a
text
node
!
"
)
;
if
(
!
mRef
)
{
MOZ_ASSERT
(
mOffset
.
isSome
(
)
&
&
mOffset
.
value
(
)
=
=
0
)
;
return
;
}
mOffset
.
reset
(
)
;
}
void
AdjustOffset
(
int32_t
aDelta
)
{
MOZ_ASSERT
(
mRef
)
;
mOffset
=
mozilla
:
:
Some
(
Offset
(
)
+
aDelta
)
;
}
void
Set
(
nsINode
*
aContainer
int32_t
aOffset
)
{
mParent
=
aContainer
;
if
(
mParent
&
&
mParent
-
>
IsContainerNode
(
)
)
{
if
(
aOffset
=
=
static_cast
<
int32_t
>
(
aContainer
-
>
GetChildCount
(
)
)
)
{
mRef
=
aContainer
-
>
GetLastChild
(
)
;
}
else
if
(
aOffset
=
=
0
)
{
mRef
=
nullptr
;
}
else
{
mRef
=
mParent
-
>
GetChildAt
(
aOffset
-
1
)
;
MOZ_ASSERT
(
mRef
)
;
}
MOZ_ASSERT_IF
(
!
mRef
aOffset
=
=
0
)
;
}
else
{
mRef
=
nullptr
;
}
mOffset
=
mozilla
:
:
Some
(
aOffset
)
;
MOZ_ASSERT_IF
(
mRef
mRef
-
>
GetParentNode
(
)
=
=
mParent
)
;
}
void
SetAfterRef
(
nsINode
*
aParent
nsIContent
*
aRef
)
{
mParent
=
aParent
;
mRef
=
aRef
;
if
(
!
mRef
)
{
mOffset
=
mozilla
:
:
Some
(
0
)
;
}
else
{
mOffset
.
reset
(
)
;
}
}
bool
IsSet
(
)
const
{
return
mParent
&
&
(
mRef
|
|
mOffset
.
isSome
(
)
)
;
}
RangeBoundaryBase
<
nsINode
*
nsIContent
*
>
AsRaw
(
)
const
{
return
RangeBoundaryBase
<
nsINode
*
nsIContent
*
>
(
*
this
)
;
}
template
<
typename
A
typename
B
>
RangeBoundaryBase
&
operator
=
(
const
RangeBoundaryBase
<
A
B
>
&
aOther
)
{
mParent
=
aOther
.
mParent
;
mRef
=
aOther
.
mRef
;
mOffset
=
aOther
.
mOffset
;
return
*
this
;
}
private
:
ParentType
mParent
;
RefType
mRef
;
mutable
mozilla
:
:
Maybe
<
uint32_t
>
mOffset
;
}
;
typedef
RangeBoundaryBase
<
nsCOMPtr
<
nsINode
>
nsCOMPtr
<
nsIContent
>
>
RangeBoundary
;
typedef
RangeBoundaryBase
<
nsINode
*
nsIContent
*
>
RawRangeBoundary
;
void
RegisterCommonAncestor
(
nsINode
*
aNode
)
;
void
UnregisterCommonAncestor
(
nsINode
*
aNode
)
;
nsINode
*
IsValidBoundary
(
nsINode
*
aNode
)
const
{
return
ComputeRootNode
(
aNode
mMaySpanAnonymousSubtrees
)
;
}
static
bool
IsValidOffset
(
uint32_t
aOffset
)
{
return
aOffset
<
=
INT32_MAX
;
}
static
bool
IsValidOffset
(
nsINode
*
aNode
uint32_t
aOffset
)
;
static
nsINode
*
ComputeRootNode
(
nsINode
*
aNode
bool
aMaySpanAnonymousSubtrees
)
;
void
DoSetRange
(
const
RawRangeBoundary
&
lowerBound
const
RawRangeBoundary
&
upperBound
nsINode
*
aRoot
bool
aNotInsertedYet
=
false
)
;
void
DoSetRange
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
nsINode
*
aRoot
bool
aNotInsertedYet
=
false
)
{
RawRangeBoundary
start
(
aStartContainer
aStartOffset
)
;
RawRangeBoundary
end
(
aEndContainer
aEndOffset
)
;
DoSetRange
(
start
end
aRoot
aNotInsertedYet
)
;
}
nsINode
*
GetRegisteredCommonAncestor
(
)
;
static
bool
IsNodeInSortedRanges
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
const
nsTArray
<
const
nsRange
*
>
&
aRanges
size_t
aRangeStart
size_t
aRangeEnd
)
;
class
MOZ_RAII
AutoCalledByJSRestore
final
{
private
:
nsRange
&
mRange
;
bool
mOldValue
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoCalledByJSRestore
(
nsRange
&
aRange
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mRange
(
aRange
)
mOldValue
(
aRange
.
mCalledByJS
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoCalledByJSRestore
(
)
{
mRange
.
mCalledByJS
=
mOldValue
;
}
bool
SavedValue
(
)
const
{
return
mOldValue
;
}
}
;
struct
MOZ_STACK_CLASS
AutoInvalidateSelection
{
explicit
AutoInvalidateSelection
(
nsRange
*
aRange
)
:
mRange
(
aRange
)
{
if
(
!
mRange
-
>
IsInSelection
(
)
|
|
sIsNested
)
{
return
;
}
sIsNested
=
true
;
mCommonAncestor
=
mRange
-
>
GetRegisteredCommonAncestor
(
)
;
}
~
AutoInvalidateSelection
(
)
;
nsRange
*
mRange
;
RefPtr
<
nsINode
>
mCommonAncestor
;
static
bool
sIsNested
;
}
;
nsCOMPtr
<
nsIDocument
>
mOwner
;
nsCOMPtr
<
nsINode
>
mRoot
;
nsINode
*
MOZ_NON_OWNING_REF
mRegisteredCommonAncestor
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
mSelection
;
nsIContent
*
MOZ_NON_OWNING_REF
mNextStartRef
;
nsIContent
*
MOZ_NON_OWNING_REF
mNextEndRef
;
RangeBoundary
mStart
;
RangeBoundary
mEnd
;
bool
mIsPositioned
:
1
;
bool
mMaySpanAnonymousSubtrees
:
1
;
bool
mIsGenerated
:
1
;
bool
mCalledByJS
:
1
;
}
;
inline
nsISupports
*
ToCanonicalSupports
(
nsRange
*
aRange
)
{
return
static_cast
<
nsIDOMRange
*
>
(
aRange
)
;
}
inline
nsISupports
*
ToSupports
(
nsRange
*
aRange
)
{
return
static_cast
<
nsIDOMRange
*
>
(
aRange
)
;
}
#
endif
