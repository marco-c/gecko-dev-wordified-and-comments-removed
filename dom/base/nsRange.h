#
ifndef
nsRange_h___
#
define
nsRange_h___
#
include
"
nsIDOMRange
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
prmon
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
GuardObjects
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
namespace
mozilla
{
class
ErrorResult
;
namespace
dom
{
struct
ClientRectsAndTexts
;
class
DocGroup
;
class
DocumentFragment
;
class
DOMRect
;
class
DOMRectList
;
class
InspectorFontFace
;
class
Selection
;
}
}
class
nsRange
final
:
public
nsIDOMRange
public
nsStubMutationObserver
public
nsWrapperCache
public
mozilla
:
:
LinkedListElement
<
nsRange
>
{
typedef
mozilla
:
:
ErrorResult
ErrorResult
;
typedef
mozilla
:
:
dom
:
:
DocGroup
DocGroup
;
typedef
mozilla
:
:
dom
:
:
DOMRect
DOMRect
;
typedef
mozilla
:
:
dom
:
:
DOMRectList
DOMRectList
;
typedef
mozilla
:
:
RangeBoundary
RangeBoundary
;
typedef
mozilla
:
:
RawRangeBoundary
RawRangeBoundary
;
virtual
~
nsRange
(
)
;
public
:
explicit
nsRange
(
nsINode
*
aNode
)
;
static
nsresult
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndContainer
uint32_t
aEndOffset
nsRange
*
*
aRange
)
;
static
nsresult
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndContainer
uint32_t
aEndOffset
nsIDOMRange
*
*
aRange
)
;
static
nsresult
CreateRange
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
nsRange
*
*
aRange
)
;
static
nsresult
CreateRange
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
nsRange
*
*
aRange
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsRange
nsIDOMRange
)
nsrefcnt
GetRefCount
(
)
const
{
return
mRefCnt
;
}
NS_DECL_NSIDOMRANGE
nsINode
*
GetRoot
(
)
const
{
return
mRoot
;
}
const
RangeBoundary
&
StartRef
(
)
const
{
return
mStart
;
}
nsINode
*
GetStartContainer
(
)
const
{
return
mStart
.
Container
(
)
;
}
const
RangeBoundary
&
EndRef
(
)
const
{
return
mEnd
;
}
nsINode
*
GetEndContainer
(
)
const
{
return
mEnd
.
Container
(
)
;
}
uint32_t
StartOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
mStart
.
Offset
(
)
)
;
}
uint32_t
EndOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
mEnd
.
Offset
(
)
)
;
}
nsIContent
*
GetChildAtStartOffset
(
)
const
{
return
mStart
.
GetChildAtOffset
(
)
;
}
nsIContent
*
GetChildAtEndOffset
(
)
const
{
return
mEnd
.
GetChildAtOffset
(
)
;
}
bool
IsPositioned
(
)
const
{
return
mIsPositioned
;
}
void
SetMaySpanAnonymousSubtrees
(
bool
aMaySpanAnonymousSubtrees
)
{
mMaySpanAnonymousSubtrees
=
aMaySpanAnonymousSubtrees
;
}
bool
IsInSelection
(
)
const
{
return
!
!
mSelection
;
}
void
SetSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
)
;
bool
IsGenerated
(
)
const
{
return
mIsGenerated
;
}
void
SetIsGenerated
(
bool
aIsGenerated
)
{
mIsGenerated
=
aIsGenerated
;
}
nsINode
*
GetCommonAncestor
(
)
const
;
void
Reset
(
)
;
nsresult
SetStart
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
ErrorResult
error
;
SetStart
(
RawRangeBoundary
(
aContainer
aOffset
)
error
)
;
return
error
.
StealNSResult
(
)
;
}
nsresult
SetEnd
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
ErrorResult
error
;
SetEnd
(
RawRangeBoundary
(
aContainer
aOffset
)
error
)
;
return
error
.
StealNSResult
(
)
;
}
already_AddRefed
<
nsRange
>
CloneRange
(
)
const
;
nsresult
SetStartAndEnd
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
return
SetStartAndEnd
(
RawRangeBoundary
(
aStartContainer
aStartOffset
)
RawRangeBoundary
(
aEndContainer
aEndOffset
)
)
;
}
nsresult
SetStartAndEnd
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
;
void
SelectNodesInContainer
(
nsINode
*
aContainer
nsIContent
*
aStartContent
nsIContent
*
aEndContent
)
;
nsresult
CollapseTo
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
return
CollapseTo
(
RawRangeBoundary
(
aContainer
aOffset
)
)
;
}
nsresult
CollapseTo
(
const
RawRangeBoundary
&
aPoint
)
{
return
SetStartAndEnd
(
aPoint
aPoint
)
;
}
static
nsINode
*
GetContainerAndOffsetAfter
(
nsINode
*
aNode
uint32_t
*
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOffset
)
;
*
aOffset
=
0
;
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
nullptr
;
}
int32_t
indexInParent
=
parentNode
-
>
ComputeIndexOf
(
aNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
nullptr
;
}
*
aOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
+
1
;
return
parentNode
;
}
static
nsINode
*
GetContainerAndOffsetBefore
(
nsINode
*
aNode
uint32_t
*
aOffset
)
{
MOZ_ASSERT
(
aNode
)
;
MOZ_ASSERT
(
aOffset
)
;
*
aOffset
=
0
;
nsINode
*
parentNode
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parentNode
)
{
return
nullptr
;
}
int32_t
indexInParent
=
parentNode
-
>
ComputeIndexOf
(
aNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
return
nullptr
;
}
*
aOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
;
return
parentNode
;
}
nsresult
GetUsedFontFaces
(
nsTArray
<
nsAutoPtr
<
mozilla
:
:
dom
:
:
InspectorFontFace
>
>
&
aResult
uint32_t
aMaxRanges
)
;
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_PARENTCHAINCHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
static
already_AddRefed
<
nsRange
>
Constructor
(
const
mozilla
:
:
dom
:
:
GlobalObject
&
global
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
Collapsed
(
)
const
{
return
mIsPositioned
&
&
mStart
.
Container
(
)
=
=
mEnd
.
Container
(
)
&
&
mStart
.
Offset
(
)
=
=
mEnd
.
Offset
(
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CreateContextualFragment
(
const
nsAString
&
aString
ErrorResult
&
aError
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CloneContents
(
ErrorResult
&
aErr
)
;
int16_t
CompareBoundaryPoints
(
uint16_t
aHow
nsRange
&
aOther
ErrorResult
&
aErr
)
;
int16_t
ComparePoint
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aErr
)
{
return
ComparePoint
(
RawRangeBoundary
(
&
aContainer
aOffset
)
aErr
)
;
}
int16_t
ComparePoint
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aErr
)
;
void
DeleteContents
(
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
ExtractContents
(
ErrorResult
&
aErr
)
;
nsINode
*
GetCommonAncestorContainer
(
ErrorResult
&
aRv
)
const
;
nsINode
*
GetStartContainer
(
ErrorResult
&
aRv
)
const
;
uint32_t
GetStartOffset
(
ErrorResult
&
aRv
)
const
;
nsINode
*
GetEndContainer
(
ErrorResult
&
aRv
)
const
;
uint32_t
GetEndOffset
(
ErrorResult
&
aRv
)
const
;
void
InsertNode
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
bool
IntersectsNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
;
bool
IsPointInRange
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aErr
)
{
return
IsPointInRange
(
RawRangeBoundary
(
&
aContainer
aOffset
)
aErr
)
;
}
bool
IsPointInRange
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aErr
)
;
void
CollapseJS
(
bool
aToStart
)
;
void
SelectNodeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SelectNodeContentsJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetEndAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetStartAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SurroundContents
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
already_AddRefed
<
DOMRect
>
GetBoundingClientRect
(
bool
aClampToEdge
=
true
bool
aFlushLayout
=
true
)
;
already_AddRefed
<
DOMRectList
>
GetClientRects
(
bool
aClampToEdge
=
true
bool
aFlushLayout
=
true
)
;
void
GetClientRectsAndTexts
(
mozilla
:
:
dom
:
:
ClientRectsAndTexts
&
aResult
ErrorResult
&
aErr
)
;
void
SelectNode
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SelectNodeContents
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEnd
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetEnd
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aErr
)
;
void
SetEndAfter
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetEndBefore
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStart
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
;
void
SetStart
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aErr
)
;
void
SetStartAfter
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
void
SetStartBefore
(
nsINode
&
aNode
ErrorResult
&
aErr
)
;
static
void
GetInnerTextNoFlush
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
mozilla
:
:
ErrorResult
&
aError
nsIContent
*
aContainer
)
;
nsINode
*
GetParentObject
(
)
const
{
return
mOwner
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
final
;
DocGroup
*
GetDocGroup
(
)
const
;
private
:
nsRange
(
const
nsRange
&
)
;
nsRange
&
operator
=
(
const
nsRange
&
)
;
nsresult
CutContents
(
mozilla
:
:
dom
:
:
DocumentFragment
*
*
frag
)
;
static
nsresult
CloneParentsBetween
(
nsINode
*
aAncestor
nsINode
*
aNode
nsINode
*
*
aClosestAncestor
nsINode
*
*
aFarthestAncestor
)
;
public
:
static
nsINode
*
ComputeRootNode
(
nsINode
*
aNode
)
{
return
ComputeRootNode
(
aNode
false
)
;
}
static
bool
IsValidPoints
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
;
static
nsresult
CompareNodeToRange
(
nsINode
*
aNode
nsRange
*
aRange
bool
*
outNodeBefore
bool
*
outNodeAfter
)
;
static
bool
IsNodeSelected
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
;
static
void
CollectClientRectsAndText
(
nsLayoutUtils
:
:
RectCallback
*
aCollector
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
*
aTextList
nsRange
*
aRange
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
bool
aClampToEdge
bool
aFlushLayout
)
;
void
ExcludeNonSelectableNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
*
aOutRanges
)
;
void
NotifySelectionListenersAfterRangeSet
(
)
;
typedef
nsTHashtable
<
nsPtrHashKey
<
nsRange
>
>
RangeHashTable
;
protected
:
void
RegisterCommonAncestor
(
nsINode
*
aNode
)
;
void
UnregisterCommonAncestor
(
nsINode
*
aNode
bool
aIsUnlinking
)
;
nsINode
*
IsValidBoundary
(
nsINode
*
aNode
)
const
{
return
ComputeRootNode
(
aNode
mMaySpanAnonymousSubtrees
)
;
}
static
bool
IsValidOffset
(
uint32_t
aOffset
)
{
return
aOffset
<
=
INT32_MAX
;
}
static
bool
IsValidOffset
(
nsINode
*
aNode
uint32_t
aOffset
)
;
static
nsINode
*
ComputeRootNode
(
nsINode
*
aNode
bool
aMaySpanAnonymousSubtrees
)
;
void
DoSetRange
(
const
RawRangeBoundary
&
lowerBound
const
RawRangeBoundary
&
upperBound
nsINode
*
aRoot
bool
aNotInsertedYet
=
false
)
;
nsINode
*
GetRegisteredCommonAncestor
(
)
;
static
bool
IsNodeInSortedRanges
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
const
nsTArray
<
const
nsRange
*
>
&
aRanges
size_t
aRangeStart
size_t
aRangeEnd
)
;
class
MOZ_RAII
AutoCalledByJSRestore
final
{
private
:
nsRange
&
mRange
;
bool
mOldValue
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoCalledByJSRestore
(
nsRange
&
aRange
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mRange
(
aRange
)
mOldValue
(
aRange
.
mCalledByJS
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoCalledByJSRestore
(
)
{
mRange
.
mCalledByJS
=
mOldValue
;
}
bool
SavedValue
(
)
const
{
return
mOldValue
;
}
}
;
struct
MOZ_STACK_CLASS
AutoInvalidateSelection
{
explicit
AutoInvalidateSelection
(
nsRange
*
aRange
)
:
mRange
(
aRange
)
{
if
(
!
mRange
-
>
IsInSelection
(
)
|
|
sIsNested
)
{
return
;
}
sIsNested
=
true
;
mCommonAncestor
=
mRange
-
>
GetRegisteredCommonAncestor
(
)
;
}
~
AutoInvalidateSelection
(
)
;
nsRange
*
mRange
;
RefPtr
<
nsINode
>
mCommonAncestor
;
static
bool
sIsNested
;
}
;
nsCOMPtr
<
nsIDocument
>
mOwner
;
nsCOMPtr
<
nsINode
>
mRoot
;
nsINode
*
MOZ_NON_OWNING_REF
mRegisteredCommonAncestor
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
mSelection
;
nsIContent
*
MOZ_NON_OWNING_REF
mNextStartRef
;
nsIContent
*
MOZ_NON_OWNING_REF
mNextEndRef
;
RangeBoundary
mStart
;
RangeBoundary
mEnd
;
bool
mIsPositioned
:
1
;
bool
mMaySpanAnonymousSubtrees
:
1
;
bool
mIsGenerated
:
1
;
bool
mCalledByJS
:
1
;
}
;
inline
nsISupports
*
ToCanonicalSupports
(
nsRange
*
aRange
)
{
return
static_cast
<
nsIDOMRange
*
>
(
aRange
)
;
}
inline
nsISupports
*
ToSupports
(
nsRange
*
aRange
)
{
return
static_cast
<
nsIDOMRange
*
>
(
aRange
)
;
}
#
endif
