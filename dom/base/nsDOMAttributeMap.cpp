#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
NamedNodeMapBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfoInlines
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsDOMAttributeMap
:
:
nsDOMAttributeMap
(
Element
*
aContent
)
:
mContent
(
aContent
)
{
}
PLDHashOperator
RemoveMapRef
(
nsAttrHashKey
:
:
KeyType
aKey
RefPtr
<
Attr
>
&
aData
void
*
aUserArg
)
{
aData
-
>
SetMap
(
nullptr
)
;
return
PL_DHASH_REMOVE
;
}
nsDOMAttributeMap
:
:
~
nsDOMAttributeMap
(
)
{
mAttributeCache
.
Enumerate
(
RemoveMapRef
nullptr
)
;
}
void
nsDOMAttributeMap
:
:
DropReference
(
)
{
mAttributeCache
.
Enumerate
(
RemoveMapRef
nullptr
)
;
mContent
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsDOMAttributeMap
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsDOMAttributeMap
)
tmp
-
>
DropReference
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mContent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
PLDHashOperator
TraverseMapEntry
(
nsAttrHashKey
:
:
KeyType
aKey
RefPtr
<
Attr
>
&
aData
void
*
aUserArg
)
{
nsCycleCollectionTraversalCallback
*
cb
=
static_cast
<
nsCycleCollectionTraversalCallback
*
>
(
aUserArg
)
;
cb
-
>
NoteXPCOMChild
(
static_cast
<
nsINode
*
>
(
aData
.
get
(
)
)
)
;
return
PL_DHASH_NEXT
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsDOMAttributeMap
)
tmp
-
>
mAttributeCache
.
Enumerate
(
TraverseMapEntry
&
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
nsDOMAttributeMap
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsDOMAttributeMap
)
if
(
tmp
-
>
IsBlack
(
)
)
{
if
(
tmp
-
>
mContent
)
{
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
MarkNodeChildren
(
tmp
-
>
mContent
)
;
}
return
true
;
}
if
(
tmp
-
>
mContent
&
&
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkip
(
tmp
-
>
mContent
true
)
)
{
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsDOMAttributeMap
)
return
tmp
-
>
IsBlackAndDoesNotNeedTracing
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsDOMAttributeMap
)
return
tmp
-
>
IsBlack
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_TABLE_HEAD
(
nsDOMAttributeMap
)
NS_INTERFACE_TABLE
(
nsDOMAttributeMap
nsIDOMMozNamedAttrMap
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE
NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
nsDOMAttributeMap
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsDOMAttributeMap
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsDOMAttributeMap
)
nsresult
nsDOMAttributeMap
:
:
SetOwnerDocument
(
nsIDocument
*
aDocument
)
{
for
(
auto
iter
=
mAttributeCache
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsresult
rv
=
iter
.
Data
(
)
-
>
SetOwnerDocument
(
aDocument
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
void
nsDOMAttributeMap
:
:
DropAttribute
(
int32_t
aNamespaceID
nsIAtom
*
aLocalName
)
{
nsAttrKey
attr
(
aNamespaceID
aLocalName
)
;
Attr
*
node
=
mAttributeCache
.
GetWeak
(
attr
)
;
if
(
node
)
{
node
-
>
SetMap
(
nullptr
)
;
mAttributeCache
.
Remove
(
attr
)
;
}
}
Attr
*
nsDOMAttributeMap
:
:
GetAttribute
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
)
{
NS_ASSERTION
(
aNodeInfo
"
GetAttribute
(
)
called
with
aNodeInfo
=
=
nullptr
!
"
)
;
nsAttrKey
attr
(
aNodeInfo
-
>
NamespaceID
(
)
aNodeInfo
-
>
NameAtom
(
)
)
;
Attr
*
node
=
mAttributeCache
.
GetWeak
(
attr
)
;
if
(
!
node
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
aNodeInfo
;
RefPtr
<
Attr
>
newAttr
=
new
Attr
(
this
ni
.
forget
(
)
EmptyString
(
)
)
;
mAttributeCache
.
Put
(
attr
newAttr
)
;
node
=
newAttr
;
}
return
node
;
}
Attr
*
nsDOMAttributeMap
:
:
NamedGetter
(
const
nsAString
&
aAttrName
bool
&
aFound
)
{
aFound
=
false
;
NS_ENSURE_TRUE
(
mContent
nullptr
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
mContent
-
>
GetExistingAttrNameFromQName
(
aAttrName
)
;
if
(
!
ni
)
{
return
nullptr
;
}
aFound
=
true
;
return
GetAttribute
(
ni
)
;
}
bool
nsDOMAttributeMap
:
:
NameIsEnumerable
(
const
nsAString
&
aName
)
{
return
false
;
}
void
nsDOMAttributeMap
:
:
GetSupportedNames
(
unsigned
aFlags
nsTArray
<
nsString
>
&
aNames
)
{
if
(
!
(
aFlags
&
JSITER_HIDDEN
)
)
{
return
;
}
const
uint32_t
count
=
mContent
-
>
GetAttrCount
(
)
;
bool
seenNonAtomName
=
false
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
i
)
;
seenNonAtomName
=
seenNonAtomName
|
|
!
name
-
>
IsAtom
(
)
;
nsString
qualifiedName
;
name
-
>
GetQualifiedName
(
qualifiedName
)
;
if
(
seenNonAtomName
&
&
aNames
.
Contains
(
qualifiedName
)
)
{
continue
;
}
aNames
.
AppendElement
(
qualifiedName
)
;
}
}
Attr
*
nsDOMAttributeMap
:
:
GetNamedItem
(
const
nsAString
&
aAttrName
)
{
bool
dummy
;
return
NamedGetter
(
aAttrName
dummy
)
;
}
NS_IMETHODIMP
nsDOMAttributeMap
:
:
GetNamedItem
(
const
nsAString
&
aAttrName
nsIDOMAttr
*
*
aAttribute
)
{
NS_ENSURE_ARG_POINTER
(
aAttribute
)
;
NS_IF_ADDREF
(
*
aAttribute
=
GetNamedItem
(
aAttrName
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMAttributeMap
:
:
SetNamedItem
(
nsIDOMAttr
*
aAttr
nsIDOMAttr
*
*
aReturn
)
{
Attr
*
attribute
=
static_cast
<
Attr
*
>
(
aAttr
)
;
NS_ENSURE_ARG
(
attribute
)
;
ErrorResult
rv
;
*
aReturn
=
SetNamedItemNS
(
*
attribute
rv
)
.
take
(
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDOMAttributeMap
:
:
SetNamedItemNS
(
nsIDOMAttr
*
aAttr
nsIDOMAttr
*
*
aReturn
)
{
Attr
*
attribute
=
static_cast
<
Attr
*
>
(
aAttr
)
;
NS_ENSURE_ARG
(
attribute
)
;
ErrorResult
rv
;
*
aReturn
=
SetNamedItemNS
(
*
attribute
rv
)
.
take
(
)
;
return
rv
.
StealNSResult
(
)
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
SetNamedItemNS
(
Attr
&
aAttr
ErrorResult
&
aError
)
{
NS_ENSURE_TRUE
(
mContent
nullptr
)
;
nsDOMAttributeMap
*
owner
=
aAttr
.
GetMap
(
)
;
if
(
owner
)
{
if
(
owner
!
=
this
)
{
aError
.
Throw
(
NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR
)
;
return
nullptr
;
}
RefPtr
<
Attr
>
attribute
=
&
aAttr
;
return
attribute
.
forget
(
)
;
}
nsresult
rv
;
if
(
mContent
-
>
OwnerDoc
(
)
!
=
aAttr
.
OwnerDoc
(
)
)
{
nsCOMPtr
<
nsINode
>
adoptedNode
=
mContent
-
>
OwnerDoc
(
)
-
>
AdoptNode
(
aAttr
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
NS_ASSERTION
(
adoptedNode
=
=
&
aAttr
"
Uh
adopt
node
changed
nodes
?
"
)
;
}
RefPtr
<
NodeInfo
>
oldNi
;
uint32_t
i
count
=
mContent
-
>
GetAttrCount
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
i
)
;
int32_t
attrNS
=
name
-
>
NamespaceID
(
)
;
nsIAtom
*
nameAtom
=
name
-
>
LocalName
(
)
;
if
(
aAttr
.
NodeInfo
(
)
-
>
Equals
(
nameAtom
attrNS
)
)
{
oldNi
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nameAtom
name
-
>
GetPrefix
(
)
aAttr
.
NodeInfo
(
)
-
>
NamespaceID
(
)
nsIDOMNode
:
:
ATTRIBUTE_NODE
)
;
break
;
}
}
RefPtr
<
Attr
>
oldAttr
;
if
(
oldNi
)
{
oldAttr
=
GetAttribute
(
oldNi
)
;
if
(
oldAttr
=
=
&
aAttr
)
{
return
oldAttr
.
forget
(
)
;
}
if
(
oldAttr
)
{
DropAttribute
(
oldNi
-
>
NamespaceID
(
)
oldNi
-
>
NameAtom
(
)
)
;
}
}
nsAutoString
value
;
aAttr
.
GetValue
(
value
)
;
RefPtr
<
NodeInfo
>
ni
=
aAttr
.
NodeInfo
(
)
;
nsAttrKey
attrkey
(
ni
-
>
NamespaceID
(
)
ni
-
>
NameAtom
(
)
)
;
mAttributeCache
.
Put
(
attrkey
&
aAttr
)
;
aAttr
.
SetMap
(
this
)
;
rv
=
mContent
-
>
SetAttr
(
ni
-
>
NamespaceID
(
)
ni
-
>
NameAtom
(
)
ni
-
>
GetPrefixAtom
(
)
value
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
DropAttribute
(
ni
-
>
NamespaceID
(
)
ni
-
>
NameAtom
(
)
)
;
}
return
oldAttr
.
forget
(
)
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
RemoveNamedItem
(
NodeInfo
*
aNodeInfo
ErrorResult
&
aError
)
{
RefPtr
<
Attr
>
attribute
=
GetAttribute
(
aNodeInfo
)
;
aError
=
mContent
-
>
UnsetAttr
(
aNodeInfo
-
>
NamespaceID
(
)
aNodeInfo
-
>
NameAtom
(
)
true
)
;
return
attribute
.
forget
(
)
;
}
NS_IMETHODIMP
nsDOMAttributeMap
:
:
RemoveNamedItem
(
const
nsAString
&
aName
nsIDOMAttr
*
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
ErrorResult
rv
;
*
aReturn
=
RemoveNamedItem
(
aName
rv
)
.
take
(
)
;
return
rv
.
StealNSResult
(
)
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
RemoveNamedItem
(
const
nsAString
&
aName
ErrorResult
&
aError
)
{
if
(
!
mContent
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
mContent
-
>
GetExistingAttrNameFromQName
(
aName
)
;
if
(
!
ni
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
return
RemoveNamedItem
(
ni
aError
)
;
}
Attr
*
nsDOMAttributeMap
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
{
aFound
=
false
;
NS_ENSURE_TRUE
(
mContent
nullptr
)
;
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
aIndex
)
;
NS_ENSURE_TRUE
(
name
nullptr
)
;
aFound
=
true
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
name
-
>
LocalName
(
)
name
-
>
GetPrefix
(
)
name
-
>
NamespaceID
(
)
nsIDOMNode
:
:
ATTRIBUTE_NODE
)
;
return
GetAttribute
(
ni
)
;
}
Attr
*
nsDOMAttributeMap
:
:
Item
(
uint32_t
aIndex
)
{
bool
dummy
;
return
IndexedGetter
(
aIndex
dummy
)
;
}
NS_IMETHODIMP
nsDOMAttributeMap
:
:
Item
(
uint32_t
aIndex
nsIDOMAttr
*
*
aReturn
)
{
NS_IF_ADDREF
(
*
aReturn
=
Item
(
aIndex
)
)
;
return
NS_OK
;
}
uint32_t
nsDOMAttributeMap
:
:
Length
(
)
const
{
NS_ENSURE_TRUE
(
mContent
0
)
;
return
mContent
-
>
GetAttrCount
(
)
;
}
nsresult
nsDOMAttributeMap
:
:
GetLength
(
uint32_t
*
aLength
)
{
NS_ENSURE_ARG_POINTER
(
aLength
)
;
*
aLength
=
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMAttributeMap
:
:
GetNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
nsIDOMAttr
*
*
aReturn
)
{
NS_IF_ADDREF
(
*
aReturn
=
GetNamedItemNS
(
aNamespaceURI
aLocalName
)
)
;
return
NS_OK
;
}
Attr
*
nsDOMAttributeMap
:
:
GetNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
GetAttrNodeInfo
(
aNamespaceURI
aLocalName
)
;
if
(
!
ni
)
{
return
nullptr
;
}
return
GetAttribute
(
ni
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
nsDOMAttributeMap
:
:
GetAttrNodeInfo
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
if
(
!
mContent
)
{
return
nullptr
;
}
int32_t
nameSpaceID
=
kNameSpaceID_None
;
if
(
!
aNamespaceURI
.
IsEmpty
(
)
)
{
nameSpaceID
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceID
(
aNamespaceURI
)
;
if
(
nameSpaceID
=
=
kNameSpaceID_Unknown
)
{
return
nullptr
;
}
}
uint32_t
i
count
=
mContent
-
>
GetAttrCount
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
i
)
;
int32_t
attrNS
=
name
-
>
NamespaceID
(
)
;
nsIAtom
*
nameAtom
=
name
-
>
LocalName
(
)
;
if
(
nameSpaceID
=
=
attrNS
&
&
nameAtom
-
>
Equals
(
aLocalName
)
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
;
ni
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nameAtom
name
-
>
GetPrefix
(
)
nameSpaceID
nsIDOMNode
:
:
ATTRIBUTE_NODE
)
;
return
ni
.
forget
(
)
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
nsDOMAttributeMap
:
:
RemoveNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
nsIDOMAttr
*
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
ErrorResult
rv
;
*
aReturn
=
RemoveNamedItemNS
(
aNamespaceURI
aLocalName
rv
)
.
take
(
)
;
return
rv
.
StealNSResult
(
)
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
RemoveNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
GetAttrNodeInfo
(
aNamespaceURI
aLocalName
)
;
if
(
!
ni
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
return
RemoveNamedItem
(
ni
aError
)
;
}
uint32_t
nsDOMAttributeMap
:
:
Count
(
)
const
{
return
mAttributeCache
.
Count
(
)
;
}
size_t
nsDOMAttributeMap
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mAttributeCache
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
auto
iter
=
mAttributeCache
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
n
+
=
aMallocSizeOf
(
iter
.
Data
(
)
.
get
(
)
)
;
}
return
n
;
}
JSObject
*
nsDOMAttributeMap
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
NamedNodeMapBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
