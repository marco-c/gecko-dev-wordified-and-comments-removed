#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
NamedNodeMapBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfoInlines
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsDOMAttributeMap
:
:
nsDOMAttributeMap
(
Element
*
aContent
)
:
mContent
(
aContent
)
{
}
nsDOMAttributeMap
:
:
~
nsDOMAttributeMap
(
)
{
DropReference
(
)
;
}
void
nsDOMAttributeMap
:
:
DropReference
(
)
{
for
(
auto
iter
=
mAttributeCache
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
-
>
SetMap
(
nullptr
)
;
iter
.
Remove
(
)
;
}
mContent
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsDOMAttributeMap
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsDOMAttributeMap
)
tmp
-
>
DropReference
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mContent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsDOMAttributeMap
)
for
(
const
auto
&
entry
:
tmp
-
>
mAttributeCache
)
{
cb
.
NoteXPCOMChild
(
static_cast
<
nsINode
*
>
(
entry
.
GetWeak
(
)
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
nsDOMAttributeMap
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsDOMAttributeMap
)
if
(
tmp
-
>
HasKnownLiveWrapper
(
)
)
{
if
(
tmp
-
>
mContent
)
{
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
MarkNodeChildren
(
tmp
-
>
mContent
)
;
}
return
true
;
}
if
(
tmp
-
>
mContent
&
&
mozilla
:
:
dom
:
:
FragmentOrElement
:
:
CanSkip
(
tmp
-
>
mContent
true
)
)
{
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsDOMAttributeMap
)
return
tmp
-
>
HasKnownLiveWrapperAndDoesNotNeedTracing
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsDOMAttributeMap
)
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_MAP_BEGIN
(
nsDOMAttributeMap
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
nsDOMAttributeMap
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsDOMAttributeMap
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsDOMAttributeMap
)
nsresult
nsDOMAttributeMap
:
:
SetOwnerDocument
(
Document
*
aDocument
)
{
for
(
const
auto
&
entry
:
mAttributeCache
)
{
nsresult
rv
=
entry
.
GetData
(
)
-
>
SetOwnerDocument
(
aDocument
)
;
NS_ENSURE_SUCCESS
(
rv
NS_ERROR_FAILURE
)
;
}
return
NS_OK
;
}
void
nsDOMAttributeMap
:
:
DropAttribute
(
int32_t
aNamespaceID
nsAtom
*
aLocalName
)
{
nsAttrKey
attr
(
aNamespaceID
aLocalName
)
;
if
(
auto
entry
=
mAttributeCache
.
Lookup
(
attr
)
)
{
entry
.
Data
(
)
-
>
SetMap
(
nullptr
)
;
entry
.
Remove
(
)
;
}
}
Attr
*
nsDOMAttributeMap
:
:
GetAttribute
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
)
{
NS_ASSERTION
(
aNodeInfo
"
GetAttribute
(
)
called
with
aNodeInfo
=
=
nullptr
!
"
)
;
nsAttrKey
attr
(
aNodeInfo
-
>
NamespaceID
(
)
aNodeInfo
-
>
NameAtom
(
)
)
;
return
mAttributeCache
.
LookupOrInsertWith
(
attr
[
&
]
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
aNodeInfo
;
auto
*
nim
=
ni
-
>
NodeInfoManager
(
)
;
return
new
(
nim
)
Attr
(
this
ni
.
forget
(
)
u
"
"
_ns
)
;
}
)
;
}
Attr
*
nsDOMAttributeMap
:
:
NamedGetter
(
const
nsAString
&
aAttrName
bool
&
aFound
)
{
aFound
=
false
;
NS_ENSURE_TRUE
(
mContent
nullptr
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
mContent
-
>
GetExistingAttrNameFromQName
(
aAttrName
)
;
if
(
!
ni
)
{
return
nullptr
;
}
aFound
=
true
;
return
GetAttribute
(
ni
)
;
}
void
nsDOMAttributeMap
:
:
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
{
bool
lowercaseNamesOnly
=
mContent
-
>
IsHTMLElement
(
)
&
&
mContent
-
>
IsInHTMLDocument
(
)
;
const
uint32_t
count
=
mContent
-
>
GetAttrCount
(
)
;
bool
seenNonAtomName
=
false
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
i
)
;
seenNonAtomName
=
seenNonAtomName
|
|
!
name
-
>
IsAtom
(
)
;
nsString
qualifiedName
;
name
-
>
GetQualifiedName
(
qualifiedName
)
;
if
(
lowercaseNamesOnly
&
&
nsContentUtils
:
:
StringContainsASCIIUpper
(
qualifiedName
)
)
{
continue
;
}
if
(
seenNonAtomName
&
&
aNames
.
Contains
(
qualifiedName
)
)
{
continue
;
}
aNames
.
AppendElement
(
qualifiedName
)
;
}
}
Attr
*
nsDOMAttributeMap
:
:
GetNamedItem
(
const
nsAString
&
aAttrName
)
{
bool
dummy
;
return
NamedGetter
(
aAttrName
dummy
)
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
SetNamedItemNS
(
Attr
&
aAttr
ErrorResult
&
aError
)
{
NS_ENSURE_TRUE
(
mContent
nullptr
)
;
nsDOMAttributeMap
*
owner
=
aAttr
.
GetMap
(
)
;
if
(
owner
)
{
if
(
owner
!
=
this
)
{
aError
.
Throw
(
NS_ERROR_DOM_INUSE_ATTRIBUTE_ERR
)
;
return
nullptr
;
}
RefPtr
<
Attr
>
attribute
=
&
aAttr
;
return
attribute
.
forget
(
)
;
}
nsresult
rv
;
if
(
mContent
-
>
OwnerDoc
(
)
!
=
aAttr
.
OwnerDoc
(
)
)
{
DebugOnly
<
void
*
>
adoptedNode
=
mContent
-
>
OwnerDoc
(
)
-
>
AdoptNode
(
aAttr
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
NS_ASSERTION
(
adoptedNode
=
=
&
aAttr
"
Uh
adopt
node
changed
nodes
?
"
)
;
}
RefPtr
<
NodeInfo
>
oldNi
;
uint32_t
i
count
=
mContent
-
>
GetAttrCount
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
i
)
;
int32_t
attrNS
=
name
-
>
NamespaceID
(
)
;
nsAtom
*
nameAtom
=
name
-
>
LocalName
(
)
;
if
(
aAttr
.
NodeInfo
(
)
-
>
Equals
(
nameAtom
attrNS
)
)
{
oldNi
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nameAtom
name
-
>
GetPrefix
(
)
aAttr
.
NodeInfo
(
)
-
>
NamespaceID
(
)
nsINode
:
:
ATTRIBUTE_NODE
)
;
break
;
}
}
RefPtr
<
Attr
>
oldAttr
;
if
(
oldNi
)
{
oldAttr
=
GetAttribute
(
oldNi
)
;
if
(
oldAttr
=
=
&
aAttr
)
{
return
oldAttr
.
forget
(
)
;
}
if
(
oldAttr
)
{
DropAttribute
(
oldNi
-
>
NamespaceID
(
)
oldNi
-
>
NameAtom
(
)
)
;
}
}
nsAutoString
value
;
aAttr
.
GetValue
(
value
)
;
RefPtr
<
NodeInfo
>
ni
=
aAttr
.
NodeInfo
(
)
;
nsAttrKey
attrkey
(
ni
-
>
NamespaceID
(
)
ni
-
>
NameAtom
(
)
)
;
mAttributeCache
.
InsertOrUpdate
(
attrkey
RefPtr
{
&
aAttr
}
)
;
aAttr
.
SetMap
(
this
)
;
rv
=
mContent
-
>
SetAttr
(
ni
-
>
NamespaceID
(
)
ni
-
>
NameAtom
(
)
ni
-
>
GetPrefixAtom
(
)
value
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
DropAttribute
(
ni
-
>
NamespaceID
(
)
ni
-
>
NameAtom
(
)
)
;
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
return
oldAttr
.
forget
(
)
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
RemoveNamedItem
(
NodeInfo
*
aNodeInfo
ErrorResult
&
aError
)
{
RefPtr
<
Attr
>
attribute
=
GetAttribute
(
aNodeInfo
)
;
aError
=
mContent
-
>
UnsetAttr
(
aNodeInfo
-
>
NamespaceID
(
)
aNodeInfo
-
>
NameAtom
(
)
true
)
;
return
attribute
.
forget
(
)
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
RemoveNamedItem
(
const
nsAString
&
aName
ErrorResult
&
aError
)
{
if
(
!
mContent
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
mContent
-
>
GetExistingAttrNameFromQName
(
aName
)
;
if
(
!
ni
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
return
RemoveNamedItem
(
ni
aError
)
;
}
Attr
*
nsDOMAttributeMap
:
:
IndexedGetter
(
uint32_t
aIndex
bool
&
aFound
)
{
aFound
=
false
;
NS_ENSURE_TRUE
(
mContent
nullptr
)
;
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
aIndex
)
;
NS_ENSURE_TRUE
(
name
nullptr
)
;
aFound
=
true
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
name
-
>
LocalName
(
)
name
-
>
GetPrefix
(
)
name
-
>
NamespaceID
(
)
nsINode
:
:
ATTRIBUTE_NODE
)
;
return
GetAttribute
(
ni
)
;
}
Attr
*
nsDOMAttributeMap
:
:
Item
(
uint32_t
aIndex
)
{
bool
dummy
;
return
IndexedGetter
(
aIndex
dummy
)
;
}
uint32_t
nsDOMAttributeMap
:
:
Length
(
)
const
{
NS_ENSURE_TRUE
(
mContent
0
)
;
return
mContent
-
>
GetAttrCount
(
)
;
}
Attr
*
nsDOMAttributeMap
:
:
GetNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
GetAttrNodeInfo
(
aNamespaceURI
aLocalName
)
;
if
(
!
ni
)
{
return
nullptr
;
}
return
GetAttribute
(
ni
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
nsDOMAttributeMap
:
:
GetAttrNodeInfo
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
)
{
if
(
!
mContent
)
{
return
nullptr
;
}
int32_t
nameSpaceID
=
kNameSpaceID_None
;
if
(
!
aNamespaceURI
.
IsEmpty
(
)
)
{
nameSpaceID
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
GetNameSpaceID
(
aNamespaceURI
nsContentUtils
:
:
IsChromeDoc
(
mContent
-
>
OwnerDoc
(
)
)
)
;
if
(
nameSpaceID
=
=
kNameSpaceID_Unknown
)
{
return
nullptr
;
}
}
uint32_t
i
count
=
mContent
-
>
GetAttrCount
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
mContent
-
>
GetAttrNameAt
(
i
)
;
int32_t
attrNS
=
name
-
>
NamespaceID
(
)
;
nsAtom
*
nameAtom
=
name
-
>
LocalName
(
)
;
if
(
nameSpaceID
=
=
attrNS
&
&
nameAtom
-
>
Equals
(
aLocalName
)
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
;
ni
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nameAtom
name
-
>
GetPrefix
(
)
nameSpaceID
nsINode
:
:
ATTRIBUTE_NODE
)
;
return
ni
.
forget
(
)
;
}
}
return
nullptr
;
}
already_AddRefed
<
Attr
>
nsDOMAttributeMap
:
:
RemoveNamedItemNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aLocalName
ErrorResult
&
aError
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
ni
=
GetAttrNodeInfo
(
aNamespaceURI
aLocalName
)
;
if
(
!
ni
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
return
RemoveNamedItem
(
ni
aError
)
;
}
uint32_t
nsDOMAttributeMap
:
:
Count
(
)
const
{
return
mAttributeCache
.
Count
(
)
;
}
size_t
nsDOMAttributeMap
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mAttributeCache
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
entry
:
mAttributeCache
)
{
n
+
=
aMallocSizeOf
(
entry
.
GetWeak
(
)
)
;
}
return
n
;
}
JSObject
*
nsDOMAttributeMap
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
NamedNodeMap_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
DocGroup
*
nsDOMAttributeMap
:
:
GetDocGroup
(
)
const
{
return
mContent
?
mContent
-
>
OwnerDoc
(
)
-
>
GetDocGroup
(
)
:
nullptr
;
}
