#
include
"
TimeoutManager
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsITimeoutHandler
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
OrderedTimeoutIterator
.
h
"
#
include
"
TimeoutExecutor
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
LazyLogModule
gLog
(
"
Timeout
"
)
;
const
uint32_t
kTelemetryPeriodMS
=
1000
;
class
TimeoutTelemetry
{
public
:
static
TimeoutTelemetry
&
Get
(
)
;
TimeoutTelemetry
(
)
:
mLastCollection
(
TimeStamp
:
:
Now
(
)
)
{
}
void
StartRecording
(
TimeStamp
aNow
)
;
void
StopRecording
(
)
;
void
RecordExecution
(
TimeStamp
aNow
Timeout
*
aTimeout
bool
aIsBackground
)
;
void
MaybeCollectTelemetry
(
TimeStamp
aNow
)
;
private
:
struct
TelemetryData
{
TimeDuration
mForegroundTracking
;
TimeDuration
mForegroundNonTracking
;
TimeDuration
mBackgroundTracking
;
TimeDuration
mBackgroundNonTracking
;
}
;
void
Accumulate
(
Telemetry
:
:
HistogramID
aId
TimeDuration
aSample
)
;
TelemetryData
mTelemetryData
;
TimeStamp
mStart
;
TimeStamp
mLastCollection
;
}
;
static
TimeoutTelemetry
gTimeoutTelemetry
;
TimeoutTelemetry
&
TimeoutTelemetry
:
:
Get
(
)
{
return
gTimeoutTelemetry
;
}
void
TimeoutTelemetry
:
:
StartRecording
(
TimeStamp
aNow
)
{
mStart
=
aNow
;
}
void
TimeoutTelemetry
:
:
StopRecording
(
)
{
mStart
=
TimeStamp
(
)
;
}
void
TimeoutTelemetry
:
:
RecordExecution
(
TimeStamp
aNow
Timeout
*
aTimeout
bool
aIsBackground
)
{
if
(
!
mStart
)
{
return
;
}
TimeDuration
duration
=
aNow
-
mStart
;
if
(
aIsBackground
)
{
if
(
aTimeout
-
>
mIsTracking
)
{
mTelemetryData
.
mBackgroundTracking
+
=
duration
;
}
else
{
mTelemetryData
.
mBackgroundNonTracking
+
=
duration
;
}
}
else
{
if
(
aTimeout
-
>
mIsTracking
)
{
mTelemetryData
.
mForegroundTracking
+
=
duration
;
}
else
{
mTelemetryData
.
mForegroundNonTracking
+
=
duration
;
}
}
}
void
TimeoutTelemetry
:
:
Accumulate
(
Telemetry
:
:
HistogramID
aId
TimeDuration
aSample
)
{
uint32_t
sample
=
std
:
:
round
(
aSample
.
ToMilliseconds
(
)
)
;
if
(
sample
)
{
Telemetry
:
:
Accumulate
(
aId
sample
)
;
}
}
void
TimeoutTelemetry
:
:
MaybeCollectTelemetry
(
TimeStamp
aNow
)
{
if
(
(
aNow
-
mLastCollection
)
.
ToMilliseconds
(
)
<
kTelemetryPeriodMS
)
{
return
;
}
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_FG_TRACKING_MS
mTelemetryData
.
mForegroundTracking
)
;
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_FG_MS
mTelemetryData
.
mForegroundNonTracking
)
;
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_BG_TRACKING_MS
mTelemetryData
.
mBackgroundTracking
)
;
Accumulate
(
Telemetry
:
:
TIMEOUT_EXECUTION_BG_MS
mTelemetryData
.
mBackgroundNonTracking
)
;
mTelemetryData
=
TelemetryData
(
)
;
mLastCollection
=
aNow
;
}
static
int32_t
gRunningTimeoutDepth
=
0
;
#
define
DEFAULT_MIN_TIMEOUT_VALUE
4
/
/
4ms
#
define
DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE
1000
/
/
1000ms
#
define
DEFAULT_MIN_TRACKING_TIMEOUT_VALUE
4
/
/
4ms
#
define
DEFAULT_MIN_TRACKING_BACKGROUND_TIMEOUT_VALUE
1000
/
/
1000ms
static
int32_t
gMinTimeoutValue
=
0
;
static
int32_t
gMinBackgroundTimeoutValue
=
0
;
static
int32_t
gMinTrackingTimeoutValue
=
0
;
static
int32_t
gMinTrackingBackgroundTimeoutValue
=
0
;
static
int32_t
gTrackingTimeoutThrottlingDelay
=
0
;
static
bool
gAnnotateTrackingChannels
=
false
;
const
uint32_t
TimeoutManager
:
:
InvalidFiringId
=
0
;
bool
TimeoutManager
:
:
IsBackground
(
)
const
{
return
!
mWindow
.
AsInner
(
)
-
>
IsPlayingAudio
(
)
&
&
mWindow
.
IsBackgroundInternal
(
)
;
}
uint32_t
TimeoutManager
:
:
CreateFiringId
(
)
{
uint32_t
id
=
mNextFiringId
;
mNextFiringId
+
=
1
;
if
(
mNextFiringId
=
=
InvalidFiringId
)
{
mNextFiringId
+
=
1
;
}
mFiringIdStack
.
AppendElement
(
id
)
;
return
id
;
}
void
TimeoutManager
:
:
DestroyFiringId
(
uint32_t
aFiringId
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mFiringIdStack
.
IsEmpty
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mFiringIdStack
.
LastElement
(
)
=
=
aFiringId
)
;
mFiringIdStack
.
RemoveElementAt
(
mFiringIdStack
.
Length
(
)
-
1
)
;
}
bool
TimeoutManager
:
:
IsValidFiringId
(
uint32_t
aFiringId
)
const
{
return
!
IsInvalidFiringId
(
aFiringId
)
;
}
bool
TimeoutManager
:
:
IsInvalidFiringId
(
uint32_t
aFiringId
)
const
{
if
(
aFiringId
=
=
InvalidFiringId
|
|
mFiringIdStack
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
mFiringIdStack
.
Length
(
)
=
=
1
)
{
return
mFiringIdStack
[
0
]
!
=
aFiringId
;
}
uint32_t
low
=
mFiringIdStack
[
0
]
;
uint32_t
high
=
mFiringIdStack
.
LastElement
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
low
!
=
high
)
;
if
(
low
>
high
)
{
Swap
(
low
high
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
low
<
high
)
;
if
(
aFiringId
<
low
|
|
aFiringId
>
high
)
{
return
true
;
}
return
!
mFiringIdStack
.
Contains
(
aFiringId
)
;
}
int32_t
TimeoutManager
:
:
DOMMinTimeoutValue
(
bool
aIsTracking
)
const
{
bool
isBackground
=
IsBackground
(
)
;
bool
throttleTracking
=
aIsTracking
&
&
mThrottleTrackingTimeouts
;
auto
minValue
=
throttleTracking
?
(
isBackground
?
gMinTrackingBackgroundTimeoutValue
:
gMinTrackingTimeoutValue
)
:
(
isBackground
?
gMinBackgroundTimeoutValue
:
gMinTimeoutValue
)
;
return
minValue
;
}
#
define
TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY
0
/
/
Consider
all
timeouts
coming
from
tracking
scripts
as
tracking
#
define
ALL_NORMAL_TIMEOUT_BUCKETING_STRATEGY
1
/
/
Consider
all
timeouts
as
normal
#
define
ALTERNATE_TIMEOUT_BUCKETING_STRATEGY
2
/
/
Put
every
other
timeout
in
the
list
of
tracking
timeouts
#
define
RANDOM_TIMEOUT_BUCKETING_STRATEGY
3
/
/
Put
timeouts
into
either
the
normal
or
tracking
timeouts
list
randomly
static
int32_t
gTimeoutBucketingStrategy
=
0
;
#
define
DEFAULT_TRACKING_TIMEOUT_THROTTLING_DELAY
-
1
/
/
Only
positive
integers
cause
us
to
introduce
a
delay
for
tracking
#
define
DOM_CLAMP_TIMEOUT_NESTING_LEVEL
5
#
define
DOM_MAX_TIMEOUT_VALUE
DELAY_INTERVAL_LIMIT
uint32_t
TimeoutManager
:
:
sNestingLevel
=
0
;
namespace
{
#
define
DEFAULT_MAX_CONSECUTIVE_CALLBACKS_MILLISECONDS
4
uint32_t
gMaxConsecutiveCallbacksMilliseconds
;
}
TimeoutManager
:
:
TimeoutManager
(
nsGlobalWindow
&
aWindow
)
:
mWindow
(
aWindow
)
mExecutor
(
new
TimeoutExecutor
(
this
)
)
mNormalTimeouts
(
*
this
)
mTrackingTimeouts
(
*
this
)
mTimeoutIdCounter
(
1
)
mNextFiringId
(
InvalidFiringId
+
1
)
mRunningTimeout
(
nullptr
)
mIdleCallbackTimeoutCounter
(
1
)
mThrottleTrackingTimeouts
(
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aWindow
.
IsInnerWindow
(
)
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
TimeoutManager
%
p
created
tracking
bucketing
%
s
\
n
"
this
gAnnotateTrackingChannels
?
"
enabled
"
:
"
disabled
"
)
)
;
}
TimeoutManager
:
:
~
TimeoutManager
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
.
AsInner
(
)
-
>
InnerObjectsFreed
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mThrottleTrackingTimeoutsTimer
)
;
mExecutor
-
>
Shutdown
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
TimeoutManager
%
p
destroyed
\
n
"
this
)
)
;
}
void
TimeoutManager
:
:
Initialize
(
)
{
Preferences
:
:
AddIntVarCache
(
&
gMinTimeoutValue
"
dom
.
min_timeout_value
"
DEFAULT_MIN_TIMEOUT_VALUE
)
;
Preferences
:
:
AddIntVarCache
(
&
gMinBackgroundTimeoutValue
"
dom
.
min_background_timeout_value
"
DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE
)
;
Preferences
:
:
AddIntVarCache
(
&
gMinTrackingTimeoutValue
"
dom
.
min_tracking_timeout_value
"
DEFAULT_MIN_TRACKING_TIMEOUT_VALUE
)
;
Preferences
:
:
AddIntVarCache
(
&
gMinTrackingBackgroundTimeoutValue
"
dom
.
min_tracking_background_timeout_value
"
DEFAULT_MIN_TRACKING_BACKGROUND_TIMEOUT_VALUE
)
;
Preferences
:
:
AddIntVarCache
(
&
gTimeoutBucketingStrategy
"
dom
.
timeout_bucketing_strategy
"
TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY
)
;
Preferences
:
:
AddIntVarCache
(
&
gTrackingTimeoutThrottlingDelay
"
dom
.
timeout
.
tracking_throttling_delay
"
DEFAULT_TRACKING_TIMEOUT_THROTTLING_DELAY
)
;
Preferences
:
:
AddBoolVarCache
(
&
gAnnotateTrackingChannels
"
privacy
.
trackingprotection
.
annotate_channels
"
false
)
;
Preferences
:
:
AddUintVarCache
(
&
gMaxConsecutiveCallbacksMilliseconds
"
dom
.
timeout
.
max_consecutive_callbacks_ms
"
DEFAULT_MAX_CONSECUTIVE_CALLBACKS_MILLISECONDS
)
;
}
uint32_t
TimeoutManager
:
:
GetTimeoutId
(
Timeout
:
:
Reason
aReason
)
{
switch
(
aReason
)
{
case
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
:
return
+
+
mIdleCallbackTimeoutCounter
;
case
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
:
default
:
return
+
+
mTimeoutIdCounter
;
}
}
bool
TimeoutManager
:
:
IsRunningTimeout
(
)
const
{
return
mRunningTimeout
;
}
nsresult
TimeoutManager
:
:
SetTimeout
(
nsITimeoutHandler
*
aHandler
int32_t
interval
bool
aIsInterval
Timeout
:
:
Reason
aReason
int32_t
*
aReturn
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
mWindow
.
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
NS_OK
;
}
interval
=
std
:
:
max
(
aIsInterval
?
1
:
0
interval
)
;
uint32_t
maxTimeoutMs
=
PR_IntervalToMilliseconds
(
DOM_MAX_TIMEOUT_VALUE
)
;
if
(
static_cast
<
uint32_t
>
(
interval
)
>
maxTimeoutMs
)
{
interval
=
maxTimeoutMs
;
}
RefPtr
<
Timeout
>
timeout
=
new
Timeout
(
)
;
timeout
-
>
mIsInterval
=
aIsInterval
;
timeout
-
>
mInterval
=
interval
;
timeout
-
>
mScriptHandler
=
aHandler
;
timeout
-
>
mReason
=
aReason
;
switch
(
gTimeoutBucketingStrategy
)
{
default
:
case
TRACKING_SEPARATE_TIMEOUT_BUCKETING_STRATEGY
:
{
const
char
*
filename
=
nullptr
;
uint32_t
dummyLine
=
0
dummyColumn
=
0
;
aHandler
-
>
GetLocation
(
&
filename
&
dummyLine
&
dummyColumn
)
;
timeout
-
>
mIsTracking
=
doc
-
>
IsScriptTracking
(
nsDependentCString
(
filename
)
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Classified
timeout
%
p
set
from
%
s
as
%
stracking
\
n
"
timeout
.
get
(
)
filename
timeout
-
>
mIsTracking
?
"
"
:
"
non
-
"
)
)
;
break
;
}
case
ALL_NORMAL_TIMEOUT_BUCKETING_STRATEGY
:
MOZ_DIAGNOSTIC_ASSERT
(
!
timeout
-
>
mIsTracking
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Classified
timeout
%
p
unconditionally
as
normal
\
n
"
timeout
.
get
(
)
)
)
;
break
;
case
ALTERNATE_TIMEOUT_BUCKETING_STRATEGY
:
timeout
-
>
mIsTracking
=
(
mTimeoutIdCounter
%
2
)
=
=
0
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Classified
timeout
%
p
as
%
stracking
(
alternating
mode
)
\
n
"
timeout
.
get
(
)
timeout
-
>
mIsTracking
?
"
"
:
"
non
-
"
)
)
;
break
;
case
RANDOM_TIMEOUT_BUCKETING_STRATEGY
:
timeout
-
>
mIsTracking
=
(
rand
(
)
%
2
)
=
=
0
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Classified
timeout
%
p
as
%
stracking
(
random
mode
)
\
n
"
timeout
.
get
(
)
timeout
-
>
mIsTracking
?
"
"
:
"
non
-
"
)
)
;
break
;
}
uint32_t
nestingLevel
=
sNestingLevel
+
1
;
uint32_t
realInterval
=
interval
;
if
(
aIsInterval
|
|
nestingLevel
>
=
DOM_CLAMP_TIMEOUT_NESTING_LEVEL
|
|
mWindow
.
IsBackgroundInternal
(
)
|
|
timeout
-
>
mIsTracking
)
{
realInterval
=
std
:
:
max
(
realInterval
uint32_t
(
DOMMinTimeoutValue
(
timeout
-
>
mIsTracking
)
)
)
;
}
timeout
-
>
mWindow
=
&
mWindow
;
TimeDuration
delta
=
TimeDuration
:
:
FromMilliseconds
(
realInterval
)
;
timeout
-
>
SetWhenOrTimeRemaining
(
TimeStamp
:
:
Now
(
)
delta
)
;
if
(
!
mWindow
.
IsSuspended
(
)
)
{
MOZ_ASSERT
(
!
timeout
-
>
When
(
)
.
IsNull
(
)
)
;
nsresult
rv
=
mExecutor
-
>
MaybeSchedule
(
timeout
-
>
When
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
if
(
!
aIsInterval
)
{
timeout
-
>
mNestingLevel
=
nestingLevel
;
}
timeout
-
>
mPopupState
=
openAbused
;
if
(
gRunningTimeoutDepth
=
=
0
&
&
mWindow
.
GetPopupControlState
(
)
<
openAbused
)
{
int32_t
delay
=
Preferences
:
:
GetInt
(
"
dom
.
disable_open_click_delay
"
)
;
if
(
interval
<
=
delay
)
{
timeout
-
>
mPopupState
=
mWindow
.
GetPopupControlState
(
)
;
}
}
Timeouts
:
:
SortBy
sort
(
mWindow
.
IsFrozen
(
)
?
Timeouts
:
:
SortBy
:
:
TimeRemaining
:
Timeouts
:
:
SortBy
:
:
TimeWhen
)
;
if
(
timeout
-
>
mIsTracking
)
{
mTrackingTimeouts
.
Insert
(
timeout
sort
)
;
}
else
{
mNormalTimeouts
.
Insert
(
timeout
sort
)
;
}
timeout
-
>
mTimeoutId
=
GetTimeoutId
(
aReason
)
;
*
aReturn
=
timeout
-
>
mTimeoutId
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Set
%
s
(
TimeoutManager
=
%
p
timeout
=
%
p
delay
=
%
i
"
"
minimum
=
%
i
throttling
=
%
s
background
=
%
d
realInterval
=
%
i
)
"
"
returned
%
stracking
timeout
ID
%
u
\
n
"
aIsInterval
?
"
Interval
"
:
"
Timeout
"
this
timeout
.
get
(
)
interval
DOMMinTimeoutValue
(
timeout
-
>
mIsTracking
)
mThrottleTrackingTimeouts
?
"
yes
"
:
(
mThrottleTrackingTimeoutsTimer
?
"
pending
"
:
"
no
"
)
int
(
mWindow
.
IsBackgroundInternal
(
)
)
realInterval
timeout
-
>
mIsTracking
?
"
"
:
"
non
-
"
timeout
-
>
mTimeoutId
)
)
;
return
NS_OK
;
}
void
TimeoutManager
:
:
ClearTimeout
(
int32_t
aTimerId
Timeout
:
:
Reason
aReason
)
{
uint32_t
timerId
=
(
uint32_t
)
aTimerId
;
bool
firstTimeout
=
true
;
ForEachUnorderedTimeoutAbortable
(
[
&
]
(
Timeout
*
aTimeout
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Clear
%
s
(
TimeoutManager
=
%
p
timeout
=
%
p
aTimerId
=
%
u
ID
=
%
u
tracking
=
%
d
)
\
n
"
aTimeout
-
>
mIsInterval
?
"
Interval
"
:
"
Timeout
"
this
aTimeout
timerId
aTimeout
-
>
mTimeoutId
int
(
aTimeout
-
>
mIsTracking
)
)
)
;
if
(
aTimeout
-
>
mTimeoutId
=
=
timerId
&
&
aTimeout
-
>
mReason
=
=
aReason
)
{
if
(
aTimeout
-
>
mRunning
)
{
aTimeout
-
>
mIsInterval
=
false
;
}
else
{
aTimeout
-
>
remove
(
)
;
}
return
true
;
}
firstTimeout
=
false
;
return
false
;
}
)
;
if
(
!
firstTimeout
)
{
return
;
}
mExecutor
-
>
Cancel
(
)
;
OrderedTimeoutIterator
iter
(
mNormalTimeouts
mTrackingTimeouts
nullptr
nullptr
)
;
Timeout
*
nextTimeout
=
iter
.
Next
(
)
;
if
(
nextTimeout
)
{
MOZ_ALWAYS_SUCCEEDS
(
mExecutor
-
>
MaybeSchedule
(
nextTimeout
-
>
When
(
)
)
)
;
}
}
void
TimeoutManager
:
:
RunTimeout
(
const
TimeStamp
&
aNow
const
TimeStamp
&
aTargetDeadline
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aNow
.
IsNull
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aTargetDeadline
.
IsNull
(
)
)
;
if
(
mWindow
.
IsSuspended
(
)
)
{
return
;
}
NS_ASSERTION
(
!
mWindow
.
IsFrozen
(
)
"
Timeout
running
on
a
window
in
the
bfcache
!
"
)
;
uint32_t
totalTimeLimitMS
=
std
:
:
max
(
1u
gMaxConsecutiveCallbacksMilliseconds
)
;
const
TimeDuration
totalTimeLimit
=
TimeDuration
:
:
FromMilliseconds
(
totalTimeLimitMS
)
;
const
TimeDuration
initalTimeLimit
=
TimeDuration
:
:
FromMilliseconds
(
totalTimeLimit
.
ToMilliseconds
(
)
/
4
)
;
const
uint32_t
kNumTimersPerInitialElapsedCheck
=
100
;
TimeStamp
now
(
aNow
)
;
TimeStamp
start
=
now
;
Timeout
*
last_expired_normal_timeout
=
nullptr
;
Timeout
*
last_expired_tracking_timeout
=
nullptr
;
bool
last_expired_timeout_is_normal
=
false
;
Timeout
*
last_normal_insertion_point
=
nullptr
;
Timeout
*
last_tracking_insertion_point
=
nullptr
;
uint32_t
firingId
=
CreateFiringId
(
)
;
auto
guard
=
MakeScopeExit
(
[
&
]
{
DestroyFiringId
(
firingId
)
;
}
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
windowKungFuDeathGrip
(
&
mWindow
)
;
Unused
<
<
windowKungFuDeathGrip
;
TimeStamp
deadline
;
if
(
aTargetDeadline
>
now
)
{
deadline
=
aTargetDeadline
;
}
else
{
deadline
=
now
;
}
TimeStamp
nextDeadline
;
{
OrderedTimeoutIterator
expiredIter
(
mNormalTimeouts
mTrackingTimeouts
nullptr
nullptr
)
;
uint32_t
numTimersToRun
=
0
;
while
(
true
)
{
Timeout
*
timeout
=
expiredIter
.
Next
(
)
;
if
(
!
timeout
|
|
timeout
-
>
When
(
)
>
deadline
)
{
if
(
timeout
)
{
nextDeadline
=
timeout
-
>
When
(
)
;
}
break
;
}
if
(
IsInvalidFiringId
(
timeout
-
>
mFiringId
)
)
{
timeout
-
>
mFiringId
=
firingId
;
last_expired_timeout_is_normal
=
expiredIter
.
PickedNormalIter
(
)
;
if
(
last_expired_timeout_is_normal
)
{
last_expired_normal_timeout
=
timeout
;
}
else
{
last_expired_tracking_timeout
=
timeout
;
}
numTimersToRun
+
=
1
;
if
(
numTimersToRun
%
kNumTimersPerInitialElapsedCheck
=
=
0
)
{
now
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
elapsed
(
now
-
start
)
;
if
(
elapsed
>
=
initalTimeLimit
)
{
nextDeadline
=
timeout
-
>
When
(
)
;
break
;
}
}
}
expiredIter
.
UpdateIterator
(
)
;
}
}
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
nextDeadline
.
IsNull
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mExecutor
-
>
MaybeSchedule
(
nextDeadline
)
)
;
}
if
(
!
last_expired_normal_timeout
&
&
!
last_expired_tracking_timeout
)
{
return
;
}
RefPtr
<
Timeout
>
dummy_normal_timeout
=
new
Timeout
(
)
;
dummy_normal_timeout
-
>
mFiringId
=
firingId
;
dummy_normal_timeout
-
>
SetDummyWhen
(
now
)
;
if
(
last_expired_timeout_is_normal
)
{
last_expired_normal_timeout
-
>
setNext
(
dummy_normal_timeout
)
;
}
RefPtr
<
Timeout
>
dummy_tracking_timeout
=
new
Timeout
(
)
;
dummy_tracking_timeout
-
>
mFiringId
=
firingId
;
dummy_tracking_timeout
-
>
SetDummyWhen
(
now
)
;
if
(
!
last_expired_timeout_is_normal
)
{
last_expired_tracking_timeout
-
>
setNext
(
dummy_tracking_timeout
)
;
}
last_normal_insertion_point
=
mNormalTimeouts
.
InsertionPoint
(
)
;
if
(
last_expired_timeout_is_normal
)
{
mNormalTimeouts
.
SetInsertionPoint
(
dummy_normal_timeout
)
;
}
last_tracking_insertion_point
=
mTrackingTimeouts
.
InsertionPoint
(
)
;
if
(
!
last_expired_timeout_is_normal
)
{
mTrackingTimeouts
.
SetInsertionPoint
(
dummy_tracking_timeout
)
;
}
{
OrderedTimeoutIterator
runIter
(
mNormalTimeouts
mTrackingTimeouts
last_expired_normal_timeout
?
last_expired_normal_timeout
-
>
getNext
(
)
:
nullptr
last_expired_tracking_timeout
?
last_expired_tracking_timeout
-
>
getNext
(
)
:
nullptr
)
;
while
(
true
)
{
RefPtr
<
Timeout
>
timeout
=
runIter
.
Next
(
)
;
MOZ_ASSERT
(
timeout
!
=
dummy_normal_timeout
&
&
timeout
!
=
dummy_tracking_timeout
"
We
should
have
stopped
iterating
before
getting
to
the
dummy
timeout
"
)
;
if
(
!
timeout
)
{
break
;
}
runIter
.
UpdateIterator
(
)
;
if
(
timeout
-
>
mFiringId
!
=
firingId
)
{
continue
;
}
MOZ_ASSERT_IF
(
mWindow
.
IsFrozen
(
)
mWindow
.
IsSuspended
(
)
)
;
if
(
mWindow
.
IsSuspended
(
)
)
{
break
;
}
nsCOMPtr
<
nsIScriptContext
>
scx
=
mWindow
.
GetContextInternal
(
)
;
if
(
!
scx
)
{
timeout
-
>
remove
(
)
;
continue
;
}
bool
timeout_was_cleared
=
mWindow
.
RunTimeoutHandler
(
timeout
scx
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Run
%
s
(
TimeoutManager
=
%
p
timeout
=
%
p
tracking
=
%
d
)
returned
%
d
\
n
"
timeout
-
>
mIsInterval
?
"
Interval
"
:
"
Timeout
"
this
timeout
.
get
(
)
int
(
timeout
-
>
mIsTracking
)
!
!
timeout_was_cleared
)
)
;
if
(
timeout_was_cleared
)
{
runIter
.
Clear
(
)
;
mNormalTimeouts
.
SetInsertionPoint
(
last_normal_insertion_point
)
;
mTrackingTimeouts
.
SetInsertionPoint
(
last_tracking_insertion_point
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
HasTimeouts
(
)
)
;
return
;
}
now
=
TimeStamp
:
:
Now
(
)
;
bool
needsReinsertion
=
RescheduleTimeout
(
timeout
now
)
;
runIter
.
UpdateIterator
(
)
;
timeout
-
>
remove
(
)
;
if
(
needsReinsertion
)
{
if
(
runIter
.
PickedTrackingIter
(
)
)
{
mTrackingTimeouts
.
Insert
(
timeout
mWindow
.
IsFrozen
(
)
?
Timeouts
:
:
SortBy
:
:
TimeRemaining
:
Timeouts
:
:
SortBy
:
:
TimeWhen
)
;
}
else
{
mNormalTimeouts
.
Insert
(
timeout
mWindow
.
IsFrozen
(
)
?
Timeouts
:
:
SortBy
:
:
TimeRemaining
:
Timeouts
:
:
SortBy
:
:
TimeWhen
)
;
}
}
TimeDuration
elapsed
=
now
-
start
;
if
(
elapsed
>
=
totalTimeLimit
)
{
RefPtr
<
Timeout
>
timeout
=
runIter
.
Next
(
)
;
if
(
timeout
)
{
MOZ_ALWAYS_SUCCEEDS
(
mExecutor
-
>
MaybeSchedule
(
timeout
-
>
When
(
)
)
)
;
}
break
;
}
}
}
if
(
dummy_normal_timeout
-
>
isInList
(
)
)
{
dummy_normal_timeout
-
>
remove
(
)
;
}
if
(
dummy_tracking_timeout
-
>
isInList
(
)
)
{
dummy_tracking_timeout
-
>
remove
(
)
;
}
mNormalTimeouts
.
SetInsertionPoint
(
last_normal_insertion_point
)
;
mTrackingTimeouts
.
SetInsertionPoint
(
last_tracking_insertion_point
)
;
}
bool
TimeoutManager
:
:
RescheduleTimeout
(
Timeout
*
aTimeout
const
TimeStamp
&
now
)
{
if
(
!
aTimeout
-
>
mIsInterval
)
{
return
false
;
}
TimeDuration
nextInterval
=
TimeDuration
:
:
FromMilliseconds
(
std
:
:
max
(
aTimeout
-
>
mInterval
uint32_t
(
DOMMinTimeoutValue
(
aTimeout
-
>
mIsTracking
)
)
)
)
;
TimeStamp
firingTime
=
now
+
nextInterval
;
TimeStamp
currentNow
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
delay
=
firingTime
-
currentNow
;
if
(
delay
<
TimeDuration
(
0
)
)
{
delay
=
TimeDuration
(
0
)
;
}
aTimeout
-
>
SetWhenOrTimeRemaining
(
currentNow
delay
)
;
if
(
mWindow
.
IsSuspended
(
)
)
{
return
true
;
}
nsresult
rv
=
mExecutor
-
>
MaybeSchedule
(
aTimeout
-
>
When
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
true
;
}
nsresult
TimeoutManager
:
:
ResetTimersForThrottleReduction
(
)
{
return
ResetTimersForThrottleReduction
(
gMinBackgroundTimeoutValue
)
;
}
nsresult
TimeoutManager
:
:
ResetTimersForThrottleReduction
(
int32_t
aPreviousThrottleDelayMS
)
{
MOZ_ASSERT
(
aPreviousThrottleDelayMS
>
0
)
;
if
(
mWindow
.
IsFrozen
(
)
|
|
mWindow
.
IsSuspended
(
)
)
{
return
NS_OK
;
}
Timeouts
:
:
SortBy
sortBy
=
mWindow
.
IsFrozen
(
)
?
Timeouts
:
:
SortBy
:
:
TimeRemaining
:
Timeouts
:
:
SortBy
:
:
TimeWhen
;
nsresult
rv
=
mNormalTimeouts
.
ResetTimersForThrottleReduction
(
aPreviousThrottleDelayMS
*
this
sortBy
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mTrackingTimeouts
.
ResetTimersForThrottleReduction
(
aPreviousThrottleDelayMS
*
this
sortBy
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OrderedTimeoutIterator
iter
(
mNormalTimeouts
mTrackingTimeouts
nullptr
nullptr
)
;
Timeout
*
firstTimeout
=
iter
.
Next
(
)
;
if
(
firstTimeout
)
{
rv
=
mExecutor
-
>
MaybeSchedule
(
firstTimeout
-
>
When
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
TimeoutManager
:
:
Timeouts
:
:
ResetTimersForThrottleReduction
(
int32_t
aPreviousThrottleDelayMS
const
TimeoutManager
&
aTimeoutManager
SortBy
aSortBy
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
for
(
RefPtr
<
Timeout
>
timeout
=
GetFirst
(
)
;
timeout
;
)
{
if
(
mManager
.
IsValidFiringId
(
timeout
-
>
mFiringId
)
|
|
timeout
-
>
When
(
)
<
=
now
)
{
timeout
=
timeout
-
>
getNext
(
)
;
continue
;
}
if
(
timeout
-
>
When
(
)
-
now
>
TimeDuration
:
:
FromMilliseconds
(
aPreviousThrottleDelayMS
)
)
{
break
;
}
TimeDuration
interval
=
TimeDuration
:
:
FromMilliseconds
(
std
:
:
max
(
timeout
-
>
mInterval
uint32_t
(
aTimeoutManager
.
DOMMinTimeoutValue
(
timeout
-
>
mIsTracking
)
)
)
)
;
const
TimeDuration
&
oldInterval
=
timeout
-
>
ScheduledDelay
(
)
;
if
(
oldInterval
>
interval
)
{
TimeStamp
firingTime
=
std
:
:
max
(
timeout
-
>
When
(
)
-
oldInterval
+
interval
now
)
;
NS_ASSERTION
(
firingTime
<
timeout
-
>
When
(
)
"
Our
firing
time
should
strictly
decrease
!
"
)
;
TimeDuration
delay
=
firingTime
-
now
;
timeout
-
>
SetWhenOrTimeRemaining
(
now
delay
)
;
MOZ_DIAGNOSTIC_ASSERT
(
timeout
-
>
When
(
)
=
=
firingTime
)
;
Timeout
*
nextTimeout
=
timeout
-
>
getNext
(
)
;
Timeout
*
prevTimeout
=
timeout
-
>
getPrevious
(
)
;
if
(
prevTimeout
&
&
prevTimeout
-
>
When
(
)
>
timeout
-
>
When
(
)
)
{
NS_ASSERTION
(
!
nextTimeout
|
|
timeout
-
>
When
(
)
<
nextTimeout
-
>
When
(
)
"
How
did
that
happen
?
"
)
;
timeout
-
>
remove
(
)
;
uint32_t
firingId
=
timeout
-
>
mFiringId
;
Insert
(
timeout
aSortBy
)
;
timeout
-
>
mFiringId
=
firingId
;
}
timeout
=
nextTimeout
;
}
else
{
timeout
=
timeout
-
>
getNext
(
)
;
}
}
return
NS_OK
;
}
void
TimeoutManager
:
:
ClearAllTimeouts
(
)
{
bool
seenRunningTimeout
=
false
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
ClearAllTimeouts
(
TimeoutManager
=
%
p
)
\
n
"
this
)
)
;
if
(
mThrottleTrackingTimeoutsTimer
)
{
mThrottleTrackingTimeoutsTimer
-
>
Cancel
(
)
;
mThrottleTrackingTimeoutsTimer
=
nullptr
;
}
mExecutor
-
>
Cancel
(
)
;
ForEachUnorderedTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
mRunningTimeout
=
=
aTimeout
)
{
seenRunningTimeout
=
true
;
}
aTimeout
-
>
mCleared
=
true
;
}
)
;
if
(
seenRunningTimeout
)
{
mNormalTimeouts
.
SetInsertionPoint
(
nullptr
)
;
mTrackingTimeouts
.
SetInsertionPoint
(
nullptr
)
;
}
mNormalTimeouts
.
Clear
(
)
;
mTrackingTimeouts
.
Clear
(
)
;
}
void
TimeoutManager
:
:
Timeouts
:
:
Insert
(
Timeout
*
aTimeout
SortBy
aSortBy
)
{
Timeout
*
prevSibling
;
for
(
prevSibling
=
GetLast
(
)
;
prevSibling
&
&
(
aSortBy
=
=
SortBy
:
:
TimeRemaining
?
prevSibling
-
>
TimeRemaining
(
)
>
aTimeout
-
>
TimeRemaining
(
)
:
prevSibling
-
>
When
(
)
>
aTimeout
-
>
When
(
)
)
&
&
mManager
.
IsInvalidFiringId
(
prevSibling
-
>
mFiringId
)
;
prevSibling
=
prevSibling
-
>
getPrevious
(
)
)
{
}
if
(
prevSibling
)
{
prevSibling
-
>
setNext
(
aTimeout
)
;
}
else
{
InsertFront
(
aTimeout
)
;
}
aTimeout
-
>
mFiringId
=
InvalidFiringId
;
}
Timeout
*
TimeoutManager
:
:
BeginRunningTimeout
(
Timeout
*
aTimeout
)
{
Timeout
*
currentTimeout
=
mRunningTimeout
;
mRunningTimeout
=
aTimeout
;
+
+
gRunningTimeoutDepth
;
if
(
!
mWindow
.
IsChromeWindow
(
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
currentTimeout
)
{
TimeoutTelemetry
:
:
Get
(
)
.
RecordExecution
(
now
currentTimeout
IsBackground
(
)
)
;
}
TimeoutTelemetry
:
:
Get
(
)
.
MaybeCollectTelemetry
(
now
)
;
TimeoutTelemetry
:
:
Get
(
)
.
StartRecording
(
now
)
;
}
return
currentTimeout
;
}
void
TimeoutManager
:
:
EndRunningTimeout
(
Timeout
*
aTimeout
)
{
-
-
gRunningTimeoutDepth
;
if
(
!
mWindow
.
IsChromeWindow
(
)
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeoutTelemetry
:
:
Get
(
)
.
RecordExecution
(
now
mRunningTimeout
IsBackground
(
)
)
;
if
(
aTimeout
)
{
TimeoutTelemetry
:
:
Get
(
)
.
StartRecording
(
now
)
;
}
}
mRunningTimeout
=
aTimeout
;
}
void
TimeoutManager
:
:
UnmarkGrayTimers
(
)
{
ForEachUnorderedTimeout
(
[
]
(
Timeout
*
aTimeout
)
{
if
(
aTimeout
-
>
mScriptHandler
)
{
aTimeout
-
>
mScriptHandler
-
>
MarkForCC
(
)
;
}
}
)
;
}
void
TimeoutManager
:
:
Suspend
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Suspend
(
TimeoutManager
=
%
p
)
\
n
"
this
)
)
;
if
(
mThrottleTrackingTimeoutsTimer
)
{
mThrottleTrackingTimeoutsTimer
-
>
Cancel
(
)
;
mThrottleTrackingTimeoutsTimer
=
nullptr
;
}
mExecutor
-
>
Cancel
(
)
;
}
void
TimeoutManager
:
:
Resume
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Resume
(
TimeoutManager
=
%
p
)
\
n
"
this
)
)
;
if
(
mWindow
.
AsInner
(
)
-
>
IsDocumentLoaded
(
)
&
&
!
mThrottleTrackingTimeouts
)
{
MaybeStartThrottleTrackingTimout
(
)
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DebugOnly
<
bool
>
_seenDummyTimeout
=
false
;
TimeStamp
nextWakeUp
;
ForEachUnorderedTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
!
aTimeout
-
>
mWindow
)
{
NS_ASSERTION
(
!
_seenDummyTimeout
"
More
than
one
dummy
timeout
?
!
"
)
;
_seenDummyTimeout
=
true
;
return
;
}
int32_t
remaining
=
0
;
if
(
aTimeout
-
>
When
(
)
>
now
)
{
remaining
=
static_cast
<
int32_t
>
(
(
aTimeout
-
>
When
(
)
-
now
)
.
ToMilliseconds
(
)
)
;
}
uint32_t
delay
=
std
:
:
max
(
remaining
DOMMinTimeoutValue
(
aTimeout
-
>
mIsTracking
)
)
;
aTimeout
-
>
SetWhenOrTimeRemaining
(
now
TimeDuration
:
:
FromMilliseconds
(
delay
)
)
;
if
(
nextWakeUp
.
IsNull
(
)
|
|
aTimeout
-
>
When
(
)
<
nextWakeUp
)
{
nextWakeUp
=
aTimeout
-
>
When
(
)
;
}
}
)
;
if
(
!
nextWakeUp
.
IsNull
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mExecutor
-
>
MaybeSchedule
(
nextWakeUp
)
)
;
}
}
void
TimeoutManager
:
:
Freeze
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Freeze
(
TimeoutManager
=
%
p
)
\
n
"
this
)
)
;
DebugOnly
<
bool
>
_seenDummyTimeout
=
false
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
ForEachUnorderedTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
!
aTimeout
-
>
mWindow
)
{
NS_ASSERTION
(
!
_seenDummyTimeout
"
More
than
one
dummy
timeout
?
!
"
)
;
_seenDummyTimeout
=
true
;
return
;
}
TimeDuration
delta
(
0
)
;
if
(
aTimeout
-
>
When
(
)
>
now
)
{
delta
=
aTimeout
-
>
When
(
)
-
now
;
}
aTimeout
-
>
SetWhenOrTimeRemaining
(
now
delta
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aTimeout
-
>
TimeRemaining
(
)
=
=
delta
)
;
}
)
;
}
void
TimeoutManager
:
:
Thaw
(
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
Thaw
(
TimeoutManager
=
%
p
)
\
n
"
this
)
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DebugOnly
<
bool
>
_seenDummyTimeout
=
false
;
ForEachUnorderedTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
!
aTimeout
-
>
mWindow
)
{
NS_ASSERTION
(
!
_seenDummyTimeout
"
More
than
one
dummy
timeout
?
!
"
)
;
_seenDummyTimeout
=
true
;
return
;
}
aTimeout
-
>
SetWhenOrTimeRemaining
(
now
aTimeout
-
>
TimeRemaining
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aTimeout
-
>
When
(
)
.
IsNull
(
)
)
;
}
)
;
}
bool
TimeoutManager
:
:
IsTimeoutTracking
(
uint32_t
aTimeoutId
)
{
return
mTrackingTimeouts
.
ForEachAbortable
(
[
&
]
(
Timeout
*
aTimeout
)
{
return
aTimeout
-
>
mTimeoutId
=
=
aTimeoutId
;
}
)
;
}
namespace
{
class
ThrottleTrackingTimeoutsCallback
final
:
public
nsITimerCallback
{
public
:
explicit
ThrottleTrackingTimeoutsCallback
(
nsGlobalWindow
*
aWindow
)
:
mWindow
(
aWindow
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aWindow
-
>
IsInnerWindow
(
)
)
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSITIMERCALLBACK
private
:
~
ThrottleTrackingTimeoutsCallback
(
)
{
}
private
:
RefPtr
<
nsGlobalWindow
>
mWindow
;
}
;
NS_IMPL_ISUPPORTS
(
ThrottleTrackingTimeoutsCallback
nsITimerCallback
)
NS_IMETHODIMP
ThrottleTrackingTimeoutsCallback
:
:
Notify
(
nsITimer
*
aTimer
)
{
mWindow
-
>
AsInner
(
)
-
>
TimeoutManager
(
)
.
StartThrottlingTrackingTimeouts
(
)
;
mWindow
=
nullptr
;
return
NS_OK
;
}
}
void
TimeoutManager
:
:
StartThrottlingTrackingTimeouts
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mThrottleTrackingTimeoutsTimer
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
TimeoutManager
%
p
started
to
throttle
tracking
timeouts
\
n
"
this
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mThrottleTrackingTimeouts
)
;
mThrottleTrackingTimeouts
=
true
;
mThrottleTrackingTimeoutsTimer
=
nullptr
;
}
void
TimeoutManager
:
:
OnDocumentLoaded
(
)
{
if
(
!
mThrottleTrackingTimeouts
)
{
MaybeStartThrottleTrackingTimout
(
)
;
}
}
void
TimeoutManager
:
:
MaybeStartThrottleTrackingTimout
(
)
{
if
(
gTrackingTimeoutThrottlingDelay
<
=
0
|
|
mWindow
.
AsInner
(
)
-
>
InnerObjectsFreed
(
)
|
|
mWindow
.
IsSuspended
(
)
)
{
return
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mThrottleTrackingTimeouts
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
TimeoutManager
%
p
delaying
tracking
timeout
throttling
by
%
dms
\
n
"
this
gTrackingTimeoutThrottlingDelay
)
)
;
mThrottleTrackingTimeoutsTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
)
;
if
(
!
mThrottleTrackingTimeoutsTimer
)
{
return
;
}
nsCOMPtr
<
nsITimerCallback
>
callback
=
new
ThrottleTrackingTimeoutsCallback
(
&
mWindow
)
;
mThrottleTrackingTimeoutsTimer
-
>
InitWithCallback
(
callback
gTrackingTimeoutThrottlingDelay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
void
TimeoutManager
:
:
BeginSyncOperation
(
)
{
if
(
!
mWindow
.
IsChromeWindow
(
)
)
{
if
(
mRunningTimeout
)
{
TimeoutTelemetry
:
:
Get
(
)
.
RecordExecution
(
TimeStamp
:
:
Now
(
)
mRunningTimeout
IsBackground
(
)
)
;
}
TimeoutTelemetry
:
:
Get
(
)
.
StopRecording
(
)
;
}
}
void
TimeoutManager
:
:
EndSyncOperation
(
)
{
if
(
!
mWindow
.
IsChromeWindow
(
)
&
&
mRunningTimeout
)
{
TimeoutTelemetry
:
:
Get
(
)
.
StartRecording
(
TimeStamp
:
:
Now
(
)
)
;
}
}
nsIEventTarget
*
TimeoutManager
:
:
EventTarget
(
)
{
return
mWindow
.
EventTargetFor
(
TaskCategory
:
:
Timer
)
;
}
