#
include
"
TimeoutManager
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsITimeoutHandler
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
int32_t
gRunningTimeoutDepth
=
0
;
#
define
DEFAULT_MIN_TIMEOUT_VALUE
4
/
/
4ms
#
define
DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE
1000
/
/
1000ms
static
int32_t
gMinTimeoutValue
;
static
int32_t
gMinBackgroundTimeoutValue
;
int32_t
TimeoutManager
:
:
DOMMinTimeoutValue
(
)
const
{
int32_t
value
=
std
:
:
max
(
mBackPressureDelayMS
0
)
;
bool
isBackground
=
!
mWindow
.
AsInner
(
)
-
>
HasAudioContexts
(
)
&
&
mWindow
.
IsBackgroundInternal
(
)
;
return
std
:
:
max
(
isBackground
?
gMinBackgroundTimeoutValue
:
gMinTimeoutValue
value
)
;
}
#
define
DOM_CLAMP_TIMEOUT_NESTING_LEVEL
5
#
define
DOM_MAX_TIMEOUT_VALUE
DELAY_INTERVAL_LIMIT
uint32_t
TimeoutManager
:
:
sNestingLevel
=
0
;
namespace
{
const
uint32_t
kThrottledEventQueueBackPressure
=
5000
;
const
double
kBackPressureDelayMS
=
500
;
const
double
kBackPressureDelayReductionThresholdMS
=
400
;
const
double
kBackPressureDelayMinimumMS
=
100
;
int32_t
CalculateNewBackPressureDelayMS
(
uint32_t
aBacklogDepth
)
{
double
multiplier
=
static_cast
<
double
>
(
aBacklogDepth
)
/
static_cast
<
double
>
(
kThrottledEventQueueBackPressure
)
;
double
value
=
kBackPressureDelayMS
*
multiplier
;
if
(
value
>
INT32_MAX
)
{
value
=
INT32_MAX
;
}
else
if
(
value
<
kBackPressureDelayMinimumMS
)
{
value
=
0
;
}
return
static_cast
<
int32_t
>
(
value
)
;
}
}
TimeoutManager
:
:
TimeoutManager
(
nsGlobalWindow
&
aWindow
)
:
mWindow
(
aWindow
)
mTimeoutIdCounter
(
1
)
mTimeoutFiringDepth
(
0
)
mRunningTimeout
(
nullptr
)
mIdleCallbackTimeoutCounter
(
1
)
mBackPressureDelayMS
(
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aWindow
.
IsInnerWindow
(
)
)
;
}
void
TimeoutManager
:
:
Initialize
(
)
{
Preferences
:
:
AddIntVarCache
(
&
gMinTimeoutValue
"
dom
.
min_timeout_value
"
DEFAULT_MIN_TIMEOUT_VALUE
)
;
Preferences
:
:
AddIntVarCache
(
&
gMinBackgroundTimeoutValue
"
dom
.
min_background_timeout_value
"
DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE
)
;
}
uint32_t
TimeoutManager
:
:
GetTimeoutId
(
Timeout
:
:
Reason
aReason
)
{
switch
(
aReason
)
{
case
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
:
return
+
+
mIdleCallbackTimeoutCounter
;
case
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
:
default
:
return
+
+
mTimeoutIdCounter
;
}
}
nsresult
TimeoutManager
:
:
SetTimeout
(
nsITimeoutHandler
*
aHandler
int32_t
interval
bool
aIsInterval
Timeout
:
:
Reason
aReason
int32_t
*
aReturn
)
{
if
(
!
mWindow
.
GetExtantDoc
(
)
)
{
return
NS_OK
;
}
interval
=
std
:
:
max
(
aIsInterval
?
1
:
0
interval
)
;
uint32_t
maxTimeoutMs
=
PR_IntervalToMilliseconds
(
DOM_MAX_TIMEOUT_VALUE
)
;
if
(
static_cast
<
uint32_t
>
(
interval
)
>
maxTimeoutMs
)
{
interval
=
maxTimeoutMs
;
}
RefPtr
<
Timeout
>
timeout
=
new
Timeout
(
)
;
timeout
-
>
mIsInterval
=
aIsInterval
;
timeout
-
>
mInterval
=
interval
;
timeout
-
>
mScriptHandler
=
aHandler
;
timeout
-
>
mReason
=
aReason
;
uint32_t
nestingLevel
=
sNestingLevel
+
1
;
uint32_t
realInterval
=
interval
;
if
(
aIsInterval
|
|
nestingLevel
>
=
DOM_CLAMP_TIMEOUT_NESTING_LEVEL
|
|
mBackPressureDelayMS
>
0
|
|
mWindow
.
IsBackgroundInternal
(
)
)
{
realInterval
=
std
:
:
max
(
realInterval
uint32_t
(
DOMMinTimeoutValue
(
)
)
)
;
}
TimeDuration
delta
=
TimeDuration
:
:
FromMilliseconds
(
realInterval
)
;
if
(
mWindow
.
IsFrozen
(
)
)
{
timeout
-
>
mTimeRemaining
=
delta
;
}
else
{
timeout
-
>
mWhen
=
TimeStamp
:
:
Now
(
)
+
delta
;
}
if
(
!
mWindow
.
IsSuspended
(
)
)
{
MOZ_ASSERT
(
!
timeout
-
>
mWhen
.
IsNull
(
)
)
;
nsresult
rv
;
timeout
-
>
mTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
RefPtr
<
Timeout
>
copy
=
timeout
;
rv
=
timeout
-
>
InitTimer
(
mWindow
.
GetThrottledEventQueue
(
)
realInterval
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
Unused
<
<
copy
.
forget
(
)
;
}
timeout
-
>
mWindow
=
&
mWindow
;
if
(
!
aIsInterval
)
{
timeout
-
>
mNestingLevel
=
nestingLevel
;
}
timeout
-
>
mPopupState
=
openAbused
;
if
(
gRunningTimeoutDepth
=
=
0
&
&
mWindow
.
GetPopupControlState
(
)
<
openAbused
)
{
int32_t
delay
=
Preferences
:
:
GetInt
(
"
dom
.
disable_open_click_delay
"
)
;
if
(
interval
<
=
delay
)
{
timeout
-
>
mPopupState
=
mWindow
.
GetPopupControlState
(
)
;
}
}
mTimeouts
.
Insert
(
timeout
mWindow
.
IsFrozen
(
)
?
Timeouts
:
:
SortBy
:
:
TimeRemaining
:
Timeouts
:
:
SortBy
:
:
TimeWhen
)
;
timeout
-
>
mTimeoutId
=
GetTimeoutId
(
aReason
)
;
*
aReturn
=
timeout
-
>
mTimeoutId
;
return
NS_OK
;
}
void
TimeoutManager
:
:
ClearTimeout
(
int32_t
aTimerId
Timeout
:
:
Reason
aReason
)
{
uint32_t
timerId
=
(
uint32_t
)
aTimerId
;
ForEachTimeoutAbortable
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
aTimeout
-
>
mTimeoutId
=
=
timerId
&
&
aTimeout
-
>
mReason
=
=
aReason
)
{
if
(
aTimeout
-
>
mRunning
)
{
aTimeout
-
>
mIsInterval
=
false
;
}
else
{
aTimeout
-
>
remove
(
)
;
if
(
aTimeout
-
>
mTimer
)
{
aTimeout
-
>
mTimer
-
>
Cancel
(
)
;
aTimeout
-
>
mTimer
=
nullptr
;
aTimeout
-
>
Release
(
)
;
}
aTimeout
-
>
Release
(
)
;
}
return
true
;
}
return
false
;
}
)
;
}
void
TimeoutManager
:
:
RunTimeout
(
Timeout
*
aTimeout
)
{
if
(
mWindow
.
IsSuspended
(
)
)
{
return
;
}
NS_ASSERTION
(
!
mWindow
.
IsFrozen
(
)
"
Timeout
running
on
a
window
in
the
bfcache
!
"
)
;
Timeout
*
nextTimeout
;
Timeout
*
last_expired_timeout
;
Timeout
*
last_insertion_point
;
uint32_t
firingDepth
=
mTimeoutFiringDepth
+
1
;
nsCOMPtr
<
nsIScriptGlobalObject
>
windowKungFuDeathGrip
(
&
mWindow
)
;
Unused
<
<
windowKungFuDeathGrip
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
deadline
;
if
(
aTimeout
&
&
aTimeout
-
>
mWhen
>
now
)
{
deadline
=
aTimeout
-
>
mWhen
;
}
else
{
deadline
=
now
;
}
last_expired_timeout
=
nullptr
;
for
(
Timeout
*
timeout
=
mTimeouts
.
GetFirst
(
)
;
timeout
&
&
timeout
-
>
mWhen
<
=
deadline
;
timeout
=
timeout
-
>
getNext
(
)
)
{
if
(
timeout
-
>
mFiringDepth
=
=
0
)
{
timeout
-
>
mFiringDepth
=
firingDepth
;
last_expired_timeout
=
timeout
;
if
(
timeout
=
=
aTimeout
&
&
!
mWindow
.
IsChromeWindow
(
)
)
{
break
;
}
}
}
if
(
!
last_expired_timeout
)
{
return
;
}
RefPtr
<
Timeout
>
dummy_timeout
=
new
Timeout
(
)
;
dummy_timeout
-
>
mFiringDepth
=
firingDepth
;
dummy_timeout
-
>
mWhen
=
now
;
last_expired_timeout
-
>
setNext
(
dummy_timeout
)
;
RefPtr
<
Timeout
>
timeoutExtraRef
(
dummy_timeout
)
;
last_insertion_point
=
mTimeouts
.
InsertionPoint
(
)
;
mTimeouts
.
SetInsertionPoint
(
dummy_timeout
)
;
for
(
Timeout
*
timeout
=
mTimeouts
.
GetFirst
(
)
;
timeout
!
=
dummy_timeout
&
&
!
mWindow
.
IsFrozen
(
)
;
timeout
=
nextTimeout
)
{
nextTimeout
=
timeout
-
>
getNext
(
)
;
if
(
timeout
-
>
mFiringDepth
!
=
firingDepth
)
{
continue
;
}
if
(
mWindow
.
IsSuspended
(
)
)
{
timeout
-
>
mFiringDepth
=
0
;
continue
;
}
nsCOMPtr
<
nsIScriptContext
>
scx
=
mWindow
.
GetContextInternal
(
)
;
if
(
!
scx
)
{
continue
;
}
bool
timeout_was_cleared
=
mWindow
.
RunTimeoutHandler
(
timeout
scx
)
;
if
(
timeout_was_cleared
)
{
MOZ_ASSERT
(
dummy_timeout
-
>
HasRefCntOne
(
)
"
dummy_timeout
may
leak
"
)
;
Unused
<
<
timeoutExtraRef
.
forget
(
)
.
take
(
)
;
mTimeouts
.
SetInsertionPoint
(
last_insertion_point
)
;
return
;
}
bool
needsReinsertion
=
RescheduleTimeout
(
timeout
now
!
aTimeout
)
;
nextTimeout
=
timeout
-
>
getNext
(
)
;
timeout
-
>
remove
(
)
;
if
(
needsReinsertion
)
{
mTimeouts
.
Insert
(
timeout
mWindow
.
IsFrozen
(
)
?
Timeouts
:
:
SortBy
:
:
TimeRemaining
:
Timeouts
:
:
SortBy
:
:
TimeWhen
)
;
}
timeout
-
>
Release
(
)
;
}
dummy_timeout
-
>
remove
(
)
;
timeoutExtraRef
=
nullptr
;
MOZ_ASSERT
(
dummy_timeout
-
>
HasRefCntOne
(
)
"
dummy_timeout
may
leak
"
)
;
mTimeouts
.
SetInsertionPoint
(
last_insertion_point
)
;
MaybeApplyBackPressure
(
)
;
}
void
TimeoutManager
:
:
MaybeApplyBackPressure
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mBackPressureDelayMS
>
0
|
|
mWindow
.
IsSuspended
(
)
)
{
return
;
}
RefPtr
<
ThrottledEventQueue
>
queue
=
mWindow
.
TabGroup
(
)
-
>
GetThrottledEventQueue
(
)
;
if
(
!
queue
)
{
return
;
}
if
(
queue
-
>
Length
(
)
<
kThrottledEventQueueBackPressure
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
NewNonOwningRunnableMethod
<
StorensRefPtrPassByPtr
<
nsGlobalWindow
>
>
(
this
&
TimeoutManager
:
:
CancelOrUpdateBackPressure
&
mWindow
)
;
nsresult
rv
=
queue
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mBackPressureDelayMS
=
CalculateNewBackPressureDelayMS
(
queue
-
>
Length
(
)
)
;
}
void
TimeoutManager
:
:
CancelOrUpdateBackPressure
(
nsGlobalWindow
*
aWindow
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aWindow
=
=
&
mWindow
)
;
MOZ_ASSERT
(
mBackPressureDelayMS
>
0
)
;
RefPtr
<
ThrottledEventQueue
>
queue
=
mWindow
.
TabGroup
(
)
-
>
GetThrottledEventQueue
(
)
;
int32_t
newBackPressureDelayMS
=
CalculateNewBackPressureDelayMS
(
queue
?
queue
-
>
Length
(
)
:
0
)
;
if
(
newBackPressureDelayMS
>
mBackPressureDelayMS
)
{
mBackPressureDelayMS
=
newBackPressureDelayMS
;
}
else
if
(
newBackPressureDelayMS
=
=
0
|
|
(
newBackPressureDelayMS
<
=
(
mBackPressureDelayMS
-
kBackPressureDelayReductionThresholdMS
)
)
)
{
int32_t
oldBackPressureDelayMS
=
mBackPressureDelayMS
;
mBackPressureDelayMS
=
newBackPressureDelayMS
;
ResetTimersForThrottleReduction
(
oldBackPressureDelayMS
)
;
}
if
(
!
mBackPressureDelayMS
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
r
=
NewNonOwningRunnableMethod
<
StorensRefPtrPassByPtr
<
nsGlobalWindow
>
>
(
this
&
TimeoutManager
:
:
CancelOrUpdateBackPressure
&
mWindow
)
;
MOZ_ALWAYS_SUCCEEDS
(
queue
-
>
Dispatch
(
r
.
forget
(
)
NS_DISPATCH_NORMAL
)
)
;
}
bool
TimeoutManager
:
:
RescheduleTimeout
(
Timeout
*
aTimeout
const
TimeStamp
&
now
bool
aRunningPendingTimeouts
)
{
if
(
!
aTimeout
-
>
mIsInterval
)
{
if
(
aTimeout
-
>
mTimer
)
{
aTimeout
-
>
mTimer
-
>
Cancel
(
)
;
aTimeout
-
>
mTimer
=
nullptr
;
aTimeout
-
>
Release
(
)
;
}
return
false
;
}
TimeDuration
nextInterval
=
TimeDuration
:
:
FromMilliseconds
(
std
:
:
max
(
aTimeout
-
>
mInterval
uint32_t
(
DOMMinTimeoutValue
(
)
)
)
)
;
TimeStamp
firingTime
;
if
(
aRunningPendingTimeouts
)
{
firingTime
=
now
+
nextInterval
;
}
else
{
firingTime
=
aTimeout
-
>
mWhen
+
nextInterval
;
}
TimeStamp
currentNow
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
delay
=
firingTime
-
currentNow
;
if
(
delay
<
TimeDuration
(
0
)
)
{
delay
=
TimeDuration
(
0
)
;
}
if
(
!
aTimeout
-
>
mTimer
)
{
NS_ASSERTION
(
mWindow
.
IsFrozen
(
)
|
|
mWindow
.
IsSuspended
(
)
"
How
'
d
our
timer
end
up
null
if
we
'
re
not
frozen
or
"
"
suspended
?
"
)
;
aTimeout
-
>
mTimeRemaining
=
delay
;
return
true
;
}
aTimeout
-
>
mWhen
=
currentNow
+
delay
;
nsresult
rv
=
aTimeout
-
>
InitTimer
(
mWindow
.
GetThrottledEventQueue
(
)
delay
.
ToMilliseconds
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Error
initializing
timer
for
DOM
timeout
!
"
)
;
aTimeout
-
>
mTimer
-
>
Cancel
(
)
;
aTimeout
-
>
mTimer
=
nullptr
;
aTimeout
-
>
Release
(
)
;
return
false
;
}
return
true
;
}
nsresult
TimeoutManager
:
:
ResetTimersForThrottleReduction
(
)
{
return
ResetTimersForThrottleReduction
(
gMinBackgroundTimeoutValue
)
;
}
nsresult
TimeoutManager
:
:
ResetTimersForThrottleReduction
(
int32_t
aPreviousThrottleDelayMS
)
{
MOZ_ASSERT
(
aPreviousThrottleDelayMS
>
0
)
;
if
(
mWindow
.
IsFrozen
(
)
|
|
mWindow
.
IsSuspended
(
)
)
{
return
NS_OK
;
}
Timeouts
:
:
SortBy
sortBy
=
mWindow
.
IsFrozen
(
)
?
Timeouts
:
:
SortBy
:
:
TimeRemaining
:
Timeouts
:
:
SortBy
:
:
TimeWhen
;
return
mTimeouts
.
ResetTimersForThrottleReduction
(
aPreviousThrottleDelayMS
DOMMinTimeoutValue
(
)
sortBy
mWindow
.
GetThrottledEventQueue
(
)
)
;
}
nsresult
TimeoutManager
:
:
Timeouts
:
:
ResetTimersForThrottleReduction
(
int32_t
aPreviousThrottleDelayMS
int32_t
aMinTimeoutValueMS
SortBy
aSortBy
ThrottledEventQueue
*
aQueue
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
for
(
Timeout
*
timeout
=
InsertionPoint
(
)
?
InsertionPoint
(
)
-
>
getNext
(
)
:
GetFirst
(
)
;
timeout
;
)
{
if
(
timeout
-
>
mWhen
<
=
now
)
{
timeout
=
timeout
-
>
getNext
(
)
;
continue
;
}
if
(
timeout
-
>
mWhen
-
now
>
TimeDuration
:
:
FromMilliseconds
(
aPreviousThrottleDelayMS
)
)
{
break
;
}
TimeDuration
interval
=
TimeDuration
:
:
FromMilliseconds
(
std
:
:
max
(
timeout
-
>
mInterval
uint32_t
(
aMinTimeoutValueMS
)
)
)
;
uint32_t
oldIntervalMillisecs
=
0
;
timeout
-
>
mTimer
-
>
GetDelay
(
&
oldIntervalMillisecs
)
;
TimeDuration
oldInterval
=
TimeDuration
:
:
FromMilliseconds
(
oldIntervalMillisecs
)
;
if
(
oldInterval
>
interval
)
{
TimeStamp
firingTime
=
std
:
:
max
(
timeout
-
>
mWhen
-
oldInterval
+
interval
now
)
;
NS_ASSERTION
(
firingTime
<
timeout
-
>
mWhen
"
Our
firing
time
should
strictly
decrease
!
"
)
;
TimeDuration
delay
=
firingTime
-
now
;
timeout
-
>
mWhen
=
firingTime
;
Timeout
*
nextTimeout
=
timeout
-
>
getNext
(
)
;
NS_ASSERTION
(
!
nextTimeout
|
|
timeout
-
>
mWhen
<
nextTimeout
-
>
mWhen
"
How
did
that
happen
?
"
)
;
timeout
-
>
remove
(
)
;
uint32_t
firingDepth
=
timeout
-
>
mFiringDepth
;
Insert
(
timeout
aSortBy
)
;
timeout
-
>
mFiringDepth
=
firingDepth
;
timeout
-
>
Release
(
)
;
nsresult
rv
=
timeout
-
>
InitTimer
(
aQueue
delay
.
ToMilliseconds
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Error
resetting
non
background
timer
for
DOM
timeout
!
"
)
;
return
rv
;
}
timeout
=
nextTimeout
;
}
else
{
timeout
=
timeout
-
>
getNext
(
)
;
}
}
return
NS_OK
;
}
void
TimeoutManager
:
:
ClearAllTimeouts
(
)
{
bool
seenRunningTimeout
=
false
;
ForEachTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
mRunningTimeout
=
=
aTimeout
)
{
seenRunningTimeout
=
true
;
}
if
(
aTimeout
-
>
mTimer
)
{
aTimeout
-
>
mTimer
-
>
Cancel
(
)
;
aTimeout
-
>
mTimer
=
nullptr
;
aTimeout
-
>
Release
(
)
;
}
aTimeout
-
>
mCleared
=
true
;
aTimeout
-
>
Release
(
)
;
}
)
;
if
(
seenRunningTimeout
)
{
mTimeouts
.
SetInsertionPoint
(
nullptr
)
;
}
mTimeouts
.
Clear
(
)
;
}
void
TimeoutManager
:
:
Timeouts
:
:
Insert
(
Timeout
*
aTimeout
SortBy
aSortBy
)
{
Timeout
*
prevSibling
;
for
(
prevSibling
=
GetLast
(
)
;
prevSibling
&
&
prevSibling
!
=
InsertionPoint
(
)
&
&
(
aSortBy
=
=
SortBy
:
:
TimeRemaining
?
prevSibling
-
>
mTimeRemaining
>
aTimeout
-
>
mTimeRemaining
:
prevSibling
-
>
mWhen
>
aTimeout
-
>
mWhen
)
;
prevSibling
=
prevSibling
-
>
getPrevious
(
)
)
{
}
if
(
prevSibling
)
{
prevSibling
-
>
setNext
(
aTimeout
)
;
}
else
{
InsertFront
(
aTimeout
)
;
}
aTimeout
-
>
mFiringDepth
=
0
;
aTimeout
-
>
AddRef
(
)
;
}
Timeout
*
TimeoutManager
:
:
BeginRunningTimeout
(
Timeout
*
aTimeout
)
{
Timeout
*
currentTimeout
=
mRunningTimeout
;
mRunningTimeout
=
aTimeout
;
+
+
gRunningTimeoutDepth
;
+
+
mTimeoutFiringDepth
;
return
currentTimeout
;
}
void
TimeoutManager
:
:
EndRunningTimeout
(
Timeout
*
aTimeout
)
{
-
-
mTimeoutFiringDepth
;
-
-
gRunningTimeoutDepth
;
mRunningTimeout
=
aTimeout
;
}
void
TimeoutManager
:
:
UnmarkGrayTimers
(
)
{
ForEachTimeout
(
[
]
(
Timeout
*
aTimeout
)
{
if
(
aTimeout
-
>
mScriptHandler
)
{
aTimeout
-
>
mScriptHandler
-
>
MarkForCC
(
)
;
}
}
)
;
}
void
TimeoutManager
:
:
Suspend
(
)
{
ForEachTimeout
(
[
]
(
Timeout
*
aTimeout
)
{
if
(
aTimeout
-
>
mTimer
)
{
aTimeout
-
>
mTimer
-
>
Cancel
(
)
;
aTimeout
-
>
mTimer
=
nullptr
;
aTimeout
-
>
Release
(
)
;
}
}
)
;
}
void
TimeoutManager
:
:
Resume
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DebugOnly
<
bool
>
_seenDummyTimeout
=
false
;
ForEachTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
!
aTimeout
-
>
mWindow
)
{
NS_ASSERTION
(
!
_seenDummyTimeout
"
More
than
one
dummy
timeout
?
!
"
)
;
_seenDummyTimeout
=
true
;
return
;
}
MOZ_ASSERT
(
!
aTimeout
-
>
mTimer
)
;
int32_t
remaining
=
0
;
if
(
aTimeout
-
>
mWhen
>
now
)
{
remaining
=
static_cast
<
int32_t
>
(
(
aTimeout
-
>
mWhen
-
now
)
.
ToMilliseconds
(
)
)
;
}
uint32_t
delay
=
std
:
:
max
(
remaining
DOMMinTimeoutValue
(
)
)
;
aTimeout
-
>
mTimer
=
do_CreateInstance
(
"
mozilla
.
org
/
timer
;
1
"
)
;
if
(
!
aTimeout
-
>
mTimer
)
{
aTimeout
-
>
remove
(
)
;
return
;
}
nsresult
rv
=
aTimeout
-
>
InitTimer
(
mWindow
.
GetThrottledEventQueue
(
)
delay
)
;
if
(
NS_FAILED
(
rv
)
)
{
aTimeout
-
>
mTimer
=
nullptr
;
aTimeout
-
>
remove
(
)
;
return
;
}
aTimeout
-
>
AddRef
(
)
;
}
)
;
}
void
TimeoutManager
:
:
Freeze
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
ForEachTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
aTimeout
-
>
mWhen
>
now
)
{
aTimeout
-
>
mTimeRemaining
=
aTimeout
-
>
mWhen
-
now
;
}
else
{
aTimeout
-
>
mTimeRemaining
=
TimeDuration
(
0
)
;
}
MOZ_ASSERT
(
!
aTimeout
-
>
mTimer
)
;
}
)
;
}
void
TimeoutManager
:
:
Thaw
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
DebugOnly
<
bool
>
_seenDummyTimeout
=
false
;
ForEachTimeout
(
[
&
]
(
Timeout
*
aTimeout
)
{
if
(
!
aTimeout
-
>
mWindow
)
{
NS_ASSERTION
(
!
_seenDummyTimeout
"
More
than
one
dummy
timeout
?
!
"
)
;
_seenDummyTimeout
=
true
;
return
;
}
aTimeout
-
>
mWhen
=
now
+
aTimeout
-
>
mTimeRemaining
;
MOZ_ASSERT
(
!
aTimeout
-
>
mTimer
)
;
}
)
;
}
