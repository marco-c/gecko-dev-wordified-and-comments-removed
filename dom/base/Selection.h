#
ifndef
mozilla_Selection_h__
#
define
mozilla_Selection_h__
#
include
"
nsIWeakReference
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsISelectionPrivate
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsWrapperCache
.
h
"
struct
CachedOffsetForFrame
;
class
nsAutoScrollTimer
;
class
nsIContentIterator
;
class
nsIDocument
;
class
nsIFrame
;
class
nsFrameSelection
;
class
nsPIDOMWindowOuter
;
struct
SelectionDetails
;
struct
SelectionCustomColors
;
class
nsCopySupport
;
class
nsHTMLCopyEncoder
;
namespace
mozilla
{
class
ErrorResult
;
class
HTMLEditor
;
struct
AutoPrepareFocusRange
;
}
struct
RangeData
{
explicit
RangeData
(
nsRange
*
aRange
)
:
mRange
(
aRange
)
{
}
RefPtr
<
nsRange
>
mRange
;
mozilla
:
:
TextRangeStyle
mTextRangeStyle
;
}
;
namespace
mozilla
{
namespace
dom
{
class
Selection
final
:
public
nsISelectionPrivate
public
nsWrapperCache
public
nsSupportsWeakReference
{
protected
:
virtual
~
Selection
(
)
;
public
:
Selection
(
)
;
explicit
Selection
(
nsFrameSelection
*
aList
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
Selection
nsISelectionPrivate
)
NS_DECL_NSISELECTION
NS_DECL_NSISELECTIONPRIVATE
nsresult
EndBatchChangesInternal
(
int16_t
aReason
=
nsISelectionListener
:
:
NO_REASON
)
;
nsIDocument
*
GetParentObject
(
)
const
;
nsPresContext
*
GetPresContext
(
)
const
;
nsIPresShell
*
GetPresShell
(
)
const
;
nsFrameSelection
*
GetFrameSelection
(
)
const
{
return
mFrameSelection
;
}
nsIFrame
*
GetSelectionAnchorGeometry
(
SelectionRegion
aRegion
nsRect
*
aRect
)
;
nsIFrame
*
GetSelectionEndPointGeometry
(
SelectionRegion
aRegion
nsRect
*
aRect
)
;
nsresult
PostScrollSelectionIntoViewEvent
(
SelectionRegion
aRegion
int32_t
aFlags
nsIPresShell
:
:
ScrollAxis
aVertical
nsIPresShell
:
:
ScrollAxis
aHorizontal
)
;
enum
{
SCROLL_SYNCHRONOUS
=
1
<
<
1
SCROLL_FIRST_ANCESTOR_ONLY
=
1
<
<
2
SCROLL_DO_FLUSH
=
1
<
<
3
SCROLL_OVERFLOW_HIDDEN
=
1
<
<
5
SCROLL_FOR_CARET_MOVE
=
1
<
<
6
}
;
nsresult
ScrollIntoView
(
SelectionRegion
aRegion
nsIPresShell
:
:
ScrollAxis
aVertical
=
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
aHorizontal
=
nsIPresShell
:
:
ScrollAxis
(
)
int32_t
aFlags
=
0
)
;
nsresult
SubtractRange
(
RangeData
*
aRange
nsRange
*
aSubtract
nsTArray
<
RangeData
>
*
aOutput
)
;
nsresult
AddItem
(
nsRange
*
aRange
int32_t
*
aOutIndex
bool
aNoStartSelect
=
false
)
;
nsresult
RemoveItem
(
nsRange
*
aRange
)
;
nsresult
RemoveCollapsedRanges
(
)
;
nsresult
Clear
(
nsPresContext
*
aPresContext
)
;
nsresult
Collapse
(
nsINode
*
aContainer
int32_t
aOffset
)
;
nsresult
Extend
(
nsINode
*
aContainer
int32_t
aOffset
)
;
nsRange
*
GetRangeAt
(
int32_t
aIndex
)
const
;
const
nsRange
*
GetAnchorFocusRange
(
)
const
{
return
mAnchorFocusRange
;
}
nsDirection
GetDirection
(
)
{
return
mDirection
;
}
void
SetDirection
(
nsDirection
aDir
)
{
mDirection
=
aDir
;
}
nsresult
SetAnchorFocusToRange
(
nsRange
*
aRange
)
;
void
ReplaceAnchorFocusRange
(
nsRange
*
aRange
)
;
void
AdjustAnchorFocusForMultiRange
(
nsDirection
aDirection
)
;
nsresult
GetPrimaryFrameForAnchorNode
(
nsIFrame
*
*
aReturnFrame
)
;
nsresult
GetPrimaryFrameForFocusNode
(
nsIFrame
*
*
aReturnFrame
int32_t
*
aOffset
bool
aVisual
)
;
UniquePtr
<
SelectionDetails
>
LookUpSelection
(
nsIContent
*
aContent
int32_t
aContentOffset
int32_t
aContentLength
UniquePtr
<
SelectionDetails
>
aDetailsHead
SelectionType
aSelectionType
bool
aSlowCheck
)
;
NS_IMETHOD
Repaint
(
nsPresContext
*
aPresContext
)
;
nsresult
StartAutoScrollTimer
(
nsIFrame
*
aFrame
nsPoint
&
aPoint
uint32_t
aDelay
)
;
nsresult
StopAutoScrollTimer
(
)
;
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
nsINode
*
GetAnchorNode
(
)
;
uint32_t
AnchorOffset
(
)
;
nsINode
*
GetFocusNode
(
)
;
uint32_t
FocusOffset
(
)
;
bool
IsCollapsed
(
)
const
{
uint32_t
cnt
=
mRanges
.
Length
(
)
;
if
(
cnt
=
=
0
)
{
return
true
;
}
if
(
cnt
!
=
1
)
{
return
false
;
}
return
mRanges
[
0
]
.
mRange
-
>
Collapsed
(
)
;
}
void
CollapseJS
(
nsINode
*
aContainer
uint32_t
aOffset
mozilla
:
:
ErrorResult
&
aRv
)
;
void
CollapseToStartJS
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
CollapseToEndJS
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
ExtendJS
(
nsINode
&
aContainer
uint32_t
aOffset
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SelectAllChildrenJS
(
nsINode
&
aNode
mozilla
:
:
ErrorResult
&
aRv
)
;
void
DeleteFromDocument
(
mozilla
:
:
ErrorResult
&
aRv
)
;
uint32_t
RangeCount
(
)
const
{
return
mRanges
.
Length
(
)
;
}
void
GetType
(
nsAString
&
aOutType
)
const
;
nsRange
*
GetRangeAt
(
uint32_t
aIndex
mozilla
:
:
ErrorResult
&
aRv
)
;
void
AddRangeJS
(
nsRange
&
aRange
mozilla
:
:
ErrorResult
&
aRv
)
;
void
RemoveRange
(
nsRange
&
aRange
mozilla
:
:
ErrorResult
&
aRv
)
;
void
RemoveAllRanges
(
mozilla
:
:
ErrorResult
&
aRv
)
;
nsresult
RemoveAllRangesTemporarily
(
)
;
void
Stringify
(
nsAString
&
aResult
)
;
bool
ContainsNode
(
nsINode
&
aNode
bool
aPartlyContained
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
ContainsPoint
(
const
nsPoint
&
aPoint
)
;
void
Modify
(
const
nsAString
&
aAlter
const
nsAString
&
aDirection
const
nsAString
&
aGranularity
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetBaseAndExtentJS
(
nsINode
&
aAnchorNode
uint32_t
aAnchorOffset
nsINode
&
aFocusNode
uint32_t
aFocusOffset
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
GetInterlinePosition
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetInterlinePosition
(
bool
aValue
mozilla
:
:
ErrorResult
&
aRv
)
;
Nullable
<
int16_t
>
GetCaretBidiLevel
(
mozilla
:
:
ErrorResult
&
aRv
)
const
;
void
SetCaretBidiLevel
(
const
Nullable
<
int16_t
>
&
aCaretBidiLevel
mozilla
:
:
ErrorResult
&
aRv
)
;
void
ToStringWithFormat
(
const
nsAString
&
aFormatType
uint32_t
aFlags
int32_t
aWrapColumn
nsAString
&
aReturn
mozilla
:
:
ErrorResult
&
aRv
)
;
void
AddSelectionListener
(
nsISelectionListener
*
aListener
mozilla
:
:
ErrorResult
&
aRv
)
;
void
RemoveSelectionListener
(
nsISelectionListener
*
aListener
mozilla
:
:
ErrorResult
&
aRv
)
;
RawSelectionType
RawType
(
)
const
{
return
ToRawSelectionType
(
mSelectionType
)
;
}
SelectionType
Type
(
)
const
{
return
mSelectionType
;
}
void
GetRangesForInterval
(
nsINode
&
aBeginNode
int32_t
aBeginOffset
nsINode
&
aEndNode
int32_t
aEndOffset
bool
aAllowAdjacent
nsTArray
<
RefPtr
<
nsRange
>
>
&
aReturn
mozilla
:
:
ErrorResult
&
aRv
)
;
void
ScrollIntoView
(
int16_t
aRegion
bool
aIsSynchronous
int16_t
aVPercent
int16_t
aHPercent
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetColors
(
const
nsAString
&
aForeColor
const
nsAString
&
aBackColor
const
nsAString
&
aAltForeColor
const
nsAString
&
aAltBackColor
mozilla
:
:
ErrorResult
&
aRv
)
;
void
ResetColors
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
Collapse
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
;
void
CollapseToStart
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
CollapseToEnd
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
Extend
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
;
void
AddRange
(
nsRange
&
aRange
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SelectAllChildren
(
nsINode
&
aNode
mozilla
:
:
ErrorResult
&
aRv
)
;
void
SetBaseAndExtent
(
nsINode
&
aAnchorNode
uint32_t
aAnchorOffset
nsINode
&
aFocusNode
uint32_t
aFocusOffset
mozilla
:
:
ErrorResult
&
aRv
)
;
void
AddSelectionChangeBlocker
(
)
;
void
RemoveSelectionChangeBlocker
(
)
;
bool
IsBlockingSelectionChangeEvents
(
)
const
;
nsresult
SetTextRangeStyle
(
nsRange
*
aRange
const
TextRangeStyle
&
aTextRangeStyle
)
;
private
:
friend
class
:
:
nsAutoScrollTimer
;
nsresult
DoAutoScroll
(
nsIFrame
*
aFrame
nsPoint
&
aPoint
)
;
bool
HasSameRoot
(
nsINode
&
aNode
)
;
friend
class
:
:
nsCopySupport
;
friend
class
:
:
nsHTMLCopyEncoder
;
void
AddRangeInternal
(
nsRange
&
aRange
nsIDocument
*
aDocument
ErrorResult
&
)
;
nsresult
GetPrimaryOrCaretFrameForNodeOffset
(
nsIContent
*
aContent
uint32_t
aOffset
nsIFrame
*
*
aReturnFrame
int32_t
*
aOffsetUsed
bool
aVisual
)
const
;
public
:
SelectionType
GetType
(
)
const
{
return
mSelectionType
;
}
void
SetType
(
SelectionType
aSelectionType
)
{
mSelectionType
=
aSelectionType
;
}
SelectionCustomColors
*
GetCustomColors
(
)
const
{
return
mCustomColors
.
get
(
)
;
}
nsresult
NotifySelectionListeners
(
bool
aCalledByJS
)
;
nsresult
NotifySelectionListeners
(
)
;
friend
struct
AutoUserInitiated
;
struct
MOZ_RAII
AutoUserInitiated
{
explicit
AutoUserInitiated
(
Selection
*
aSelection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mSavedValue
(
aSelection
-
>
mUserInitiated
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
aSelection
-
>
mUserInitiated
=
true
;
}
AutoRestore
<
bool
>
mSavedValue
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
private
:
friend
struct
mozilla
:
:
AutoPrepareFocusRange
;
class
ScrollSelectionIntoViewEvent
;
friend
class
ScrollSelectionIntoViewEvent
;
class
ScrollSelectionIntoViewEvent
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
ScrollSelectionIntoViewEvent
(
Selection
*
aSelection
SelectionRegion
aRegion
nsIPresShell
:
:
ScrollAxis
aVertical
nsIPresShell
:
:
ScrollAxis
aHorizontal
int32_t
aFlags
)
:
Runnable
(
"
dom
:
:
Selection
:
:
ScrollSelectionIntoViewEvent
"
)
mSelection
(
aSelection
)
mRegion
(
aRegion
)
mVerticalScroll
(
aVertical
)
mHorizontalScroll
(
aHorizontal
)
mFlags
(
aFlags
)
{
NS_ASSERTION
(
aSelection
"
null
parameter
"
)
;
}
void
Revoke
(
)
{
mSelection
=
nullptr
;
}
private
:
Selection
*
mSelection
;
SelectionRegion
mRegion
;
nsIPresShell
:
:
ScrollAxis
mVerticalScroll
;
nsIPresShell
:
:
ScrollAxis
mHorizontalScroll
;
int32_t
mFlags
;
}
;
void
SetAnchorFocusRange
(
int32_t
aIndex
)
;
void
SelectFramesForContent
(
nsIContent
*
aContent
bool
aSelected
)
;
nsresult
SelectAllFramesForContent
(
nsIContentIterator
*
aInnerIter
nsIContent
*
aContent
bool
aSelected
)
;
nsresult
SelectFrames
(
nsPresContext
*
aPresContext
nsRange
*
aRange
bool
aSelect
)
;
nsresult
GetTableCellLocationFromRange
(
nsRange
*
aRange
int32_t
*
aSelectionType
int32_t
*
aRow
int32_t
*
aCol
)
;
nsresult
AddTableCellRange
(
nsRange
*
aRange
bool
*
aDidAddRange
int32_t
*
aOutIndex
)
;
nsresult
FindInsertionPoint
(
nsTArray
<
RangeData
>
*
aElementArray
nsINode
*
aPointNode
int32_t
aPointOffset
nsresult
(
*
aComparator
)
(
nsINode
*
int32_t
nsRange
*
int32_t
*
)
int32_t
*
aPoint
)
;
bool
EqualsRangeAtPoint
(
nsINode
*
aBeginNode
int32_t
aBeginOffset
nsINode
*
aEndNode
int32_t
aEndOffset
int32_t
aRangeIndex
)
;
nsresult
GetIndicesForInterval
(
nsINode
*
aBeginNode
int32_t
aBeginOffset
nsINode
*
aEndNode
int32_t
aEndOffset
bool
aAllowAdjacent
int32_t
*
aStartIndex
int32_t
*
aEndIndex
)
;
RangeData
*
FindRangeData
(
nsIDOMRange
*
aRange
)
;
void
UserSelectRangesToAdd
(
nsRange
*
aItem
nsTArray
<
RefPtr
<
nsRange
>
>
&
rangesToAdd
)
;
nsresult
AddItemInternal
(
nsRange
*
aRange
int32_t
*
aOutIndex
)
;
nsIDocument
*
GetDocument
(
)
const
;
nsPIDOMWindowOuter
*
GetWindow
(
)
const
;
HTMLEditor
*
GetHTMLEditor
(
)
const
;
Element
*
GetCommonEditingHostForAllRanges
(
)
;
AutoTArray
<
RangeData
1
>
mRanges
;
RefPtr
<
nsRange
>
mAnchorFocusRange
;
RefPtr
<
nsRange
>
mCachedRange
;
RefPtr
<
nsFrameSelection
>
mFrameSelection
;
RefPtr
<
nsAutoScrollTimer
>
mAutoScrollTimer
;
FallibleTArray
<
nsCOMPtr
<
nsISelectionListener
>
>
mSelectionListeners
;
nsRevocableEventPtr
<
ScrollSelectionIntoViewEvent
>
mScrollEvent
;
CachedOffsetForFrame
*
mCachedOffsetForFrame
;
nsDirection
mDirection
;
SelectionType
mSelectionType
;
UniquePtr
<
SelectionCustomColors
>
mCustomColors
;
bool
mUserInitiated
;
bool
mCalledByJS
;
uint32_t
mSelectionChangeBlockerCount
;
}
;
class
MOZ_STACK_CLASS
SelectionBatcher
final
{
private
:
RefPtr
<
Selection
>
mSelection
;
public
:
explicit
SelectionBatcher
(
Selection
*
aSelection
)
{
mSelection
=
aSelection
;
if
(
mSelection
)
{
mSelection
-
>
StartBatchChanges
(
)
;
}
}
~
SelectionBatcher
(
)
{
if
(
mSelection
)
{
mSelection
-
>
EndBatchChangesInternal
(
)
;
}
}
}
;
class
MOZ_RAII
AutoHideSelectionChanges
final
{
private
:
RefPtr
<
Selection
>
mSelection
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
public
:
explicit
AutoHideSelectionChanges
(
const
nsFrameSelection
*
aFrame
)
;
explicit
AutoHideSelectionChanges
(
Selection
*
aSelection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mSelection
(
aSelection
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mSelection
=
aSelection
;
if
(
mSelection
)
{
mSelection
-
>
AddSelectionChangeBlocker
(
)
;
}
}
~
AutoHideSelectionChanges
(
)
{
if
(
mSelection
)
{
mSelection
-
>
RemoveSelectionChangeBlocker
(
)
;
}
}
}
;
}
inline
bool
IsValidRawSelectionType
(
RawSelectionType
aRawSelectionType
)
{
return
aRawSelectionType
>
=
nsISelectionController
:
:
SELECTION_NONE
&
&
aRawSelectionType
<
=
nsISelectionController
:
:
SELECTION_URLSTRIKEOUT
;
}
inline
SelectionType
ToSelectionType
(
RawSelectionType
aRawSelectionType
)
{
if
(
!
IsValidRawSelectionType
(
aRawSelectionType
)
)
{
return
SelectionType
:
:
eInvalid
;
}
return
static_cast
<
SelectionType
>
(
aRawSelectionType
)
;
}
inline
RawSelectionType
ToRawSelectionType
(
SelectionType
aSelectionType
)
{
MOZ_ASSERT
(
aSelectionType
!
=
SelectionType
:
:
eInvalid
)
;
return
static_cast
<
RawSelectionType
>
(
aSelectionType
)
;
}
inline
RawSelectionType
ToRawSelectionType
(
TextRangeType
aTextRangeType
)
{
return
ToRawSelectionType
(
ToSelectionType
(
aTextRangeType
)
)
;
}
inline
SelectionTypeMask
ToSelectionTypeMask
(
SelectionType
aSelectionType
)
{
MOZ_ASSERT
(
aSelectionType
!
=
SelectionType
:
:
eInvalid
)
;
return
aSelectionType
=
=
SelectionType
:
:
eNone
?
0
:
(
1
<
<
(
static_cast
<
uint8_t
>
(
aSelectionType
)
-
1
)
)
;
}
}
inline
mozilla
:
:
dom
:
:
Selection
*
nsISelection
:
:
AsSelection
(
)
{
return
static_cast
<
mozilla
:
:
dom
:
:
Selection
*
>
(
this
)
;
}
#
endif
