#
include
"
TextDirectiveCreator
.
h
"
#
include
"
TextDirectiveUtil
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
dom
/
fragmentdirectives_ffi_generated
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
Document
.
h
"
namespace
mozilla
:
:
dom
{
Result
<
std
:
:
tuple
<
const
nsString
&
const
nsString
&
>
ErrorResult
>
RangeContentCache
:
:
Get
(
nsRange
*
aRange1
nsRange
*
aRange2
)
{
auto
cachedContent1
=
mCache
.
Lookup
(
aRange1
)
;
auto
cachedContent2
=
mCache
.
Lookup
(
aRange2
)
;
const
bool
needsToInsert1
=
!
cachedContent1
;
const
bool
needsToInsert2
=
!
cachedContent2
;
if
(
!
needsToInsert1
&
&
!
needsToInsert2
)
{
return
std
:
:
tuple
<
const
nsString
&
const
nsString
&
>
{
*
cachedContent1
*
cachedContent2
}
;
}
if
(
needsToInsert1
)
{
Result
<
nsString
ErrorResult
>
content1
=
TextDirectiveUtil
:
:
RangeContentAsFoldCase
(
aRange1
)
;
if
(
MOZ_UNLIKELY
(
content1
.
isErr
(
)
)
)
{
return
content1
.
propagateErr
(
)
;
}
mCache
.
InsertOrUpdate
(
aRange1
content1
.
unwrap
(
)
)
;
}
if
(
needsToInsert2
)
{
Result
<
nsString
ErrorResult
>
content2
=
TextDirectiveUtil
:
:
RangeContentAsFoldCase
(
aRange2
)
;
if
(
MOZ_UNLIKELY
(
content2
.
isErr
(
)
)
)
{
return
content2
.
propagateErr
(
)
;
}
mCache
.
InsertOrUpdate
(
aRange2
content2
.
unwrap
(
)
)
;
}
return
std
:
:
tuple
<
const
nsString
&
const
nsString
&
>
{
*
mCache
.
Lookup
(
aRange1
)
*
mCache
.
Lookup
(
aRange2
)
}
;
}
TextDirectiveCandidate
:
:
TextDirectiveCandidate
(
nsRange
*
aStartRange
nsRange
*
aFullStartRange
nsRange
*
aEndRange
nsRange
*
aFullEndRange
nsRange
*
aPrefixRange
nsRange
*
aFullPrefixRange
nsRange
*
aSuffixRange
nsRange
*
aFullSuffixRange
)
:
mStartRange
(
aStartRange
)
mFullStartRange
(
aFullStartRange
)
mEndRange
(
aEndRange
)
mFullEndRange
(
aFullEndRange
)
mPrefixRange
(
aPrefixRange
)
mFullPrefixRange
(
aFullPrefixRange
)
mSuffixRange
(
aSuffixRange
)
mFullSuffixRange
(
aFullSuffixRange
)
{
}
Result
<
TextDirectiveCandidate
ErrorResult
>
TextDirectiveCandidate
:
:
CreateFromInputRange
(
const
nsRange
*
aInputRange
)
{
MOZ_ASSERT
(
aInputRange
)
;
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullStartRange
=
MaybeCreateStartToBlockBoundaryRange
(
*
aInputRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullStartRange
.
isErr
(
)
)
)
{
return
maybeFullStartRange
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullStartRange
=
maybeFullStartRange
.
unwrap
(
)
;
RefPtr
<
nsRange
>
fullEndRange
;
const
bool
useExactMatching
=
!
fullStartRange
;
RefPtr
<
nsRange
>
startRange
;
RefPtr
<
nsRange
>
endRange
;
if
(
useExactMatching
)
{
startRange
=
aInputRange
-
>
CloneRange
(
)
;
}
else
{
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullEndRange
=
MaybeCreateEndToBlockBoundaryRange
(
*
aInputRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullEndRange
.
isErr
(
)
)
)
{
return
maybeFullEndRange
.
propagateErr
(
)
;
}
fullEndRange
=
maybeFullEndRange
.
unwrap
(
)
;
MOZ_ASSERT
(
fullEndRange
"
Searching
from
start
found
a
range
boundary
in
the
range
so
"
"
searching
from
the
end
must
find
one
as
well
"
)
;
startRange
=
nsRange
:
:
Create
(
aInputRange
-
>
StartRef
(
)
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
aInputRange
-
>
StartRef
(
)
TextScanDirection
:
:
Right
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
endRange
=
nsRange
:
:
Create
(
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
aInputRange
-
>
EndRef
(
)
TextScanDirection
:
:
Left
)
aInputRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
}
auto
prefixRanges
=
CreatePrefixRanges
(
startRange
-
>
StartRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
prefixRanges
.
isErr
(
)
)
)
{
return
prefixRanges
.
propagateErr
(
)
;
}
auto
[
prefixRange
fullPrefixRange
]
=
prefixRanges
.
unwrap
(
)
;
auto
suffixRanges
=
CreateSuffixRanges
(
endRange
?
endRange
-
>
EndRef
(
)
:
startRange
-
>
EndRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
suffixRanges
.
isErr
(
)
)
)
{
return
suffixRanges
.
propagateErr
(
)
;
}
auto
[
suffixRange
fullSuffixRange
]
=
suffixRanges
.
unwrap
(
)
;
auto
instance
=
TextDirectiveCandidate
{
startRange
fullStartRange
endRange
fullEndRange
prefixRange
fullPrefixRange
suffixRange
fullSuffixRange
}
;
MOZ_TRY
(
instance
.
CreateTextDirectiveString
(
)
)
;
return
instance
;
}
Result
<
TextDirectiveCandidate
ErrorResult
>
TextDirectiveCandidate
:
:
CreateFromStartAndEndRange
(
const
nsRange
*
aStartRange
const
nsRange
*
aEndRange
)
{
MOZ_ASSERT
(
aStartRange
)
;
MOZ_ASSERT
(
aEndRange
)
;
ErrorResult
rv
;
RefPtr
<
nsRange
>
startRange
=
aStartRange
-
>
CloneRange
(
)
;
RefPtr
<
nsRange
>
endRange
=
aEndRange
-
>
CloneRange
(
)
;
RefPtr
<
nsRange
>
fullRange
=
nsRange
:
:
Create
(
startRange
-
>
StartRef
(
)
endRange
-
>
EndRef
(
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullStartRange
=
MaybeCreateStartToBlockBoundaryRange
(
*
fullRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullStartRange
.
isErr
(
)
)
)
{
return
maybeFullStartRange
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullStartRange
=
maybeFullStartRange
.
unwrap
(
)
;
if
(
!
fullStartRange
)
{
fullStartRange
=
fullRange
-
>
CloneRange
(
)
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullEndRange
=
MaybeCreateEndToBlockBoundaryRange
(
*
fullRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullEndRange
.
isErr
(
)
)
)
{
return
maybeFullStartRange
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullEndRange
=
maybeFullStartRange
.
unwrap
(
)
;
if
(
!
fullEndRange
)
{
fullEndRange
=
fullRange
-
>
CloneRange
(
)
;
}
auto
prefixRanges
=
CreatePrefixRanges
(
startRange
-
>
StartRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
prefixRanges
.
isErr
(
)
)
)
{
return
prefixRanges
.
propagateErr
(
)
;
}
auto
[
prefixRange
fullPrefixRange
]
=
prefixRanges
.
unwrap
(
)
;
auto
suffixRanges
=
CreateSuffixRanges
(
endRange
-
>
EndRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
suffixRanges
.
isErr
(
)
)
)
{
return
suffixRanges
.
propagateErr
(
)
;
}
auto
[
suffixRange
fullSuffixRange
]
=
suffixRanges
.
unwrap
(
)
;
auto
instance
=
TextDirectiveCandidate
{
startRange
fullStartRange
endRange
fullEndRange
prefixRange
fullPrefixRange
suffixRange
fullSuffixRange
}
;
MOZ_TRY
(
instance
.
CreateTextDirectiveString
(
)
)
;
return
instance
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
TextDirectiveCandidate
:
:
MaybeCreateStartToBlockBoundaryRange
(
const
nsRange
&
aRange
)
{
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
fullRange
=
TextDirectiveUtil
:
:
FindBlockBoundaryInRange
(
aRange
TextScanDirection
:
:
Right
)
.
andThen
(
[
&
aRange
&
rv
]
(
auto
boundary
)
-
>
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
{
RefPtr
range
=
boundary
?
nsRange
:
:
Create
(
aRange
.
StartRef
(
)
*
boundary
rv
)
:
nullptr
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
range
;
}
)
;
return
fullRange
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
TextDirectiveCandidate
:
:
MaybeCreateEndToBlockBoundaryRange
(
const
nsRange
&
aRange
)
{
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
fullRange
=
TextDirectiveUtil
:
:
FindBlockBoundaryInRange
(
aRange
TextScanDirection
:
:
Left
)
.
andThen
(
[
&
aRange
&
rv
]
(
auto
boundary
)
-
>
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
{
RefPtr
range
=
boundary
?
nsRange
:
:
Create
(
*
boundary
aRange
.
EndRef
(
)
rv
)
:
nullptr
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
range
;
}
)
;
return
fullRange
;
}
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreatePrefixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
ErrorResult
rv
;
RangeBoundary
previousNonWhitespacePoint
=
TextDirectiveUtil
:
:
MoveBoundaryToPreviousNonWhitespacePosition
(
aRangeBoundary
)
;
RefPtr
<
nsRange
>
prefixRange
=
nsRange
:
:
Create
(
previousNonWhitespacePoint
previousNonWhitespacePoint
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RangeBoundary
ErrorResult
>
fullPrefixStartBoundary
=
TextDirectiveUtil
:
:
FindNextBlockBoundary
(
prefixRange
-
>
EndRef
(
)
TextScanDirection
:
:
Left
)
;
if
(
MOZ_UNLIKELY
(
fullPrefixStartBoundary
.
isErr
(
)
)
)
{
return
fullPrefixStartBoundary
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullPrefixRange
=
nsRange
:
:
Create
(
fullPrefixStartBoundary
.
unwrap
(
)
prefixRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
std
:
:
tuple
{
prefixRange
fullPrefixRange
}
;
}
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreateSuffixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
RangeBoundary
nextNonWhitespacePoint
=
TextDirectiveUtil
:
:
MoveBoundaryToNextNonWhitespacePosition
(
aRangeBoundary
)
;
ErrorResult
rv
;
RefPtr
<
nsRange
>
suffixRange
=
nsRange
:
:
Create
(
nextNonWhitespacePoint
nextNonWhitespacePoint
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RangeBoundary
ErrorResult
>
fullSuffixEndBoundary
=
TextDirectiveUtil
:
:
FindNextBlockBoundary
(
suffixRange
-
>
EndRef
(
)
TextScanDirection
:
:
Right
)
;
if
(
MOZ_UNLIKELY
(
fullSuffixEndBoundary
.
isErr
(
)
)
)
{
return
fullSuffixEndBoundary
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullSuffixRange
=
nsRange
:
:
Create
(
suffixRange
-
>
StartRef
(
)
fullSuffixEndBoundary
.
unwrap
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
std
:
:
tuple
{
suffixRange
fullSuffixRange
}
;
}
const
nsCString
&
TextDirectiveCandidate
:
:
TextDirectiveString
(
)
const
{
return
mTextDirectiveString
;
}
Result
<
Ok
ErrorResult
>
TextDirectiveCandidate
:
:
CreateTextDirectiveString
(
)
{
Result
<
TextDirective
ErrorResult
>
maybeTextDirective
=
TextDirectiveUtil
:
:
CreateTextDirectiveFromRanges
(
mPrefixRange
mStartRange
mEndRange
mSuffixRange
)
;
if
(
MOZ_UNLIKELY
(
maybeTextDirective
.
isErr
(
)
)
)
{
return
maybeTextDirective
.
propagateErr
(
)
;
}
TextDirective
textDirective
=
maybeTextDirective
.
unwrap
(
)
;
create_text_directive
(
&
textDirective
&
mTextDirectiveString
)
;
return
Ok
(
)
;
}
void
TextDirectiveCandidate
:
:
LogCurrentState
(
const
char
*
aCallerFunc
)
const
{
if
(
!
TextDirectiveUtil
:
:
ShouldLog
(
)
)
{
return
;
}
auto
getRangeContent
=
[
]
(
nsRange
*
range
)
{
auto
content
=
TextDirectiveUtil
:
:
RangeContentAsString
(
range
)
.
unwrapOr
(
u
"
<
nsRange
:
:
ToString
(
)
failed
>
"
_ns
)
;
return
NS_ConvertUTF16toUTF8
(
content
.
IsEmpty
(
)
?
u
"
<
empty
range
>
"
_ns
:
content
)
;
}
;
auto
fullTextDirectiveString
=
TextDirectiveUtil
:
:
CreateTextDirectiveFromRanges
(
mFullPrefixRange
mFullStartRange
?
mFullStartRange
:
mStartRange
mFullEndRange
mFullSuffixRange
)
.
map
(
[
]
(
auto
textDirective
)
{
nsCString
value
;
create_text_directive
(
&
textDirective
&
value
)
;
return
value
;
}
)
.
unwrapOr
(
"
<
creating
text
directive
failed
>
"
_ns
)
;
TEXT_FRAGMENT_LOG_FN
(
"
State
of
text
directive
candidate
%
p
:
\
nPercent
-
encoded
string
:
"
"
%
s
\
n
\
nCurrent
context
terms
:
\
nPrefix
:
%
s
\
nStart
:
%
s
\
nEnd
:
%
s
\
nSuffix
:
"
"
%
s
\
n
\
nMaximum
expanded
context
terms
:
\
nPercent
-
encoded
string
:
"
"
%
s
\
nPrefix
:
\
n
%
s
\
nStart
:
\
n
%
s
\
nEnd
:
\
n
%
s
\
nSuffix
:
\
n
%
s
"
aCallerFunc
this
mTextDirectiveString
.
Data
(
)
getRangeContent
(
mPrefixRange
)
.
Data
(
)
getRangeContent
(
mStartRange
)
.
Data
(
)
getRangeContent
(
mEndRange
)
.
Data
(
)
getRangeContent
(
mSuffixRange
)
.
Data
(
)
fullTextDirectiveString
.
Data
(
)
getRangeContent
(
mFullPrefixRange
)
.
Data
(
)
getRangeContent
(
mFullStartRange
)
.
Data
(
)
getRangeContent
(
mFullEndRange
)
.
Data
(
)
getRangeContent
(
mFullSuffixRange
)
.
Data
(
)
)
;
}
TextDirectiveCreator
:
:
TextDirectiveCreator
(
Document
&
aDocument
nsRange
*
aInputRange
TextDirectiveCandidate
&
&
aTextDirective
)
:
mDocument
(
aDocument
)
mInputRange
(
aInputRange
)
mTextDirective
(
std
:
:
move
(
aTextDirective
)
)
{
}
mozilla
:
:
Result
<
nsCString
ErrorResult
>
TextDirectiveCreator
:
:
CreateTextDirectiveFromRange
(
Document
&
aDocument
nsRange
*
aInputRange
)
{
MOZ_ASSERT
(
aInputRange
)
;
MOZ_ASSERT
(
!
aInputRange
-
>
Collapsed
(
)
)
;
RefPtr
<
nsRange
>
inputRangeExtendedToWordBoundaries
=
aInputRange
-
>
CloneRange
(
)
;
MOZ_TRY
(
TextDirectiveUtil
:
:
ExtendRangeToWordBoundaries
(
*
inputRangeExtendedToWordBoundaries
)
)
;
if
(
inputRangeExtendedToWordBoundaries
-
>
Collapsed
(
)
)
{
return
nsCString
{
}
;
}
Result
<
nsString
ErrorResult
>
rangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
inputRangeExtendedToWordBoundaries
)
;
if
(
MOZ_UNLIKELY
(
rangeContent
.
isErr
(
)
)
)
{
return
rangeContent
.
propagateErr
(
)
;
}
if
(
rangeContent
.
unwrap
(
)
.
IsEmpty
(
)
)
{
return
nsCString
{
}
;
}
Result
<
TextDirectiveCandidate
ErrorResult
>
maybeTextDirectiveCandidate
=
TextDirectiveCandidate
:
:
CreateFromInputRange
(
inputRangeExtendedToWordBoundaries
)
;
if
(
MOZ_UNLIKELY
(
maybeTextDirectiveCandidate
.
isErr
(
)
)
)
{
return
maybeTextDirectiveCandidate
.
propagateErr
(
)
;
}
auto
textDirectiveCandidate
=
maybeTextDirectiveCandidate
.
unwrap
(
)
;
TextDirectiveCreator
creator
(
aDocument
inputRangeExtendedToWordBoundaries
std
:
:
move
(
textDirectiveCandidate
)
)
;
return
creator
.
FindAllMatchingCandidates
(
)
.
andThen
(
[
&
creator
]
(
nsTArray
<
TextDirectiveCandidate
>
&
&
previousMatches
)
-
>
Result
<
nsCString
ErrorResult
>
{
return
creator
.
CreateTextDirectiveFromMatches
(
previousMatches
)
;
}
)
;
}
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
TextDirectiveCreator
:
:
FindAllMatchingCandidates
(
)
{
ErrorResult
rv
;
if
(
mTextDirective
.
UseExactMatch
(
)
)
{
Result
<
nsString
ErrorResult
>
rangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
mInputRange
)
;
if
(
MOZ_UNLIKELY
(
rangeContent
.
isErr
(
)
)
)
{
return
rangeContent
.
propagateErr
(
)
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
maybeRangeMatches
=
FindAllMatchingRanges
(
rangeContent
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
maybeRangeMatches
.
isErr
(
)
)
)
{
return
maybeRangeMatches
.
propagateErr
(
)
;
}
auto
rangeMatches
=
maybeRangeMatches
.
unwrap
(
)
;
nsTArray
<
TextDirectiveCandidate
>
textDirectiveMatches
(
rangeMatches
.
Length
(
)
)
;
for
(
const
auto
&
rangeMatch
:
rangeMatches
)
{
auto
candidate
=
TextDirectiveCandidate
:
:
CreateFromInputRange
(
rangeMatch
)
;
if
(
MOZ_UNLIKELY
(
candidate
.
isErr
(
)
)
)
{
return
candidate
.
propagateErr
(
)
;
}
textDirectiveMatches
.
AppendElement
(
candidate
.
unwrap
(
)
)
;
}
return
textDirectiveMatches
;
}
Result
<
nsString
ErrorResult
>
startRangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
mTextDirective
.
StartRange
(
)
)
;
if
(
MOZ_UNLIKELY
(
startRangeContent
.
isErr
(
)
)
)
{
return
startRangeContent
.
propagateErr
(
)
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
maybeStartRangeMatches
=
FindAllMatchingRanges
(
startRangeContent
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
maybeStartRangeMatches
.
isErr
(
)
)
)
{
return
maybeStartRangeMatches
.
propagateErr
(
)
;
}
auto
startRangeMatches
=
maybeStartRangeMatches
.
unwrap
(
)
;
Result
<
nsString
ErrorResult
>
endRangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
mTextDirective
.
EndRange
(
)
)
;
if
(
MOZ_UNLIKELY
(
endRangeContent
.
isErr
(
)
)
)
{
return
endRangeContent
.
propagateErr
(
)
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
maybeEndRangeMatches
=
FindAllMatchingRanges
(
endRangeContent
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
maybeEndRangeMatches
.
isErr
(
)
)
)
{
return
maybeEndRangeMatches
.
propagateErr
(
)
;
}
nsDeque
<
nsRange
>
endRangeMatches
;
for
(
auto
&
element
:
maybeEndRangeMatches
.
unwrap
(
)
)
{
endRangeMatches
.
Push
(
element
.
get
(
)
)
;
}
nsTArray
<
TextDirectiveCandidate
>
textDirectiveCandidates
(
startRangeMatches
.
Length
(
)
)
;
for
(
const
auto
&
matchStartRange
:
startRangeMatches
)
{
for
(
auto
*
matchEndRange
:
endRangeMatches
)
{
Maybe
<
int32_t
>
compare
=
nsContentUtils
:
:
ComparePoints
(
matchStartRange
-
>
EndRef
(
)
matchEndRange
-
>
StartRef
(
)
)
;
if
(
!
compare
|
|
*
compare
=
=
-
1
)
{
endRangeMatches
.
PopFront
(
)
;
continue
;
}
auto
candidate
=
TextDirectiveCandidate
:
:
CreateFromStartAndEndRange
(
matchStartRange
matchEndRange
)
;
if
(
MOZ_UNLIKELY
(
candidate
.
isErr
(
)
)
)
{
return
candidate
.
propagateErr
(
)
;
}
textDirectiveCandidates
.
AppendElement
(
candidate
.
unwrap
(
)
)
;
}
}
return
textDirectiveCandidates
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCreator
:
:
FindAllMatchingRanges
(
const
nsString
&
aSearchQuery
)
{
MOZ_ASSERT
(
!
aSearchQuery
.
IsEmpty
(
)
)
;
ErrorResult
rv
;
RangeBoundary
documentStart
{
&
mDocument
0u
}
;
RefPtr
<
nsRange
>
searchRange
=
nsRange
:
:
Create
(
documentStart
mInputRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
nsTArray
<
RefPtr
<
nsRange
>
>
matchingRanges
;
while
(
!
searchRange
-
>
Collapsed
(
)
)
{
RefPtr
<
nsRange
>
searchResult
=
TextDirectiveUtil
:
:
FindStringInRange
(
searchRange
aSearchQuery
true
true
)
;
if
(
!
searchResult
)
{
break
;
}
if
(
TextDirectiveUtil
:
:
NormalizedRangeBoundariesAreEqual
(
searchResult
-
>
EndRef
(
)
mInputRange
-
>
EndRef
(
)
)
)
{
break
;
}
matchingRanges
.
AppendElement
(
searchResult
)
;
RangeBoundary
newStartBoundary
=
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
searchResult
-
>
StartRef
(
)
TextScanDirection
:
:
Right
)
;
searchRange
-
>
SetStart
(
newStartBoundary
.
AsRaw
(
)
rv
)
;
}
TEXT_FRAGMENT_LOG
(
"
Found
%
zu
matches
for
the
input
'
%
s
'
in
the
document
until
the
end
of
"
"
the
input
range
.
"
matchingRanges
.
Length
(
)
NS_ConvertUTF16toUTF8
(
aSearchQuery
)
.
Data
(
)
)
;
return
matchingRanges
;
}
Result
<
nsCString
ErrorResult
>
TextDirectiveCreator
:
:
CreateTextDirectiveFromMatches
(
const
nsTArray
<
TextDirectiveCandidate
>
&
aTextDirectiveMatches
)
{
TextDirectiveCandidate
currentCandidate
=
std
:
:
move
(
mTextDirective
)
;
if
(
aTextDirectiveMatches
.
IsEmpty
(
)
)
{
TEXT_FRAGMENT_LOG
(
"
There
are
no
conflicting
matches
.
Returning
text
directive
'
%
s
'
.
"
currentCandidate
.
TextDirectiveString
(
)
.
Data
(
)
)
;
return
currentCandidate
.
TextDirectiveString
(
)
;
}
return
nsCString
{
}
;
}
}
