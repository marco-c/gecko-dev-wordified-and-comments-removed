#
include
"
TextDirectiveCreator
.
h
"
#
include
"
TextDirectiveUtil
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
dom
/
fragmentdirectives_ffi_generated
.
h
"
#
include
"
nsRange
.
h
"
namespace
mozilla
:
:
dom
{
TextDirectiveCandidate
:
:
TextDirectiveCandidate
(
nsRange
*
aStartRange
nsRange
*
aFullStartRange
nsRange
*
aEndRange
nsRange
*
aFullEndRange
nsRange
*
aPrefixRange
nsRange
*
aFullPrefixRange
nsRange
*
aSuffixRange
nsRange
*
aFullSuffixRange
)
:
mStartRange
(
aStartRange
)
mFullStartRange
(
aFullStartRange
)
mEndRange
(
aEndRange
)
mFullEndRange
(
aFullEndRange
)
mPrefixRange
(
aPrefixRange
)
mFullPrefixRange
(
aFullPrefixRange
)
mSuffixRange
(
aSuffixRange
)
mFullSuffixRange
(
aFullSuffixRange
)
{
}
Result
<
TextDirectiveCandidate
ErrorResult
>
TextDirectiveCandidate
:
:
CreateFromInputRange
(
const
nsRange
*
aInputRange
)
{
MOZ_ASSERT
(
aInputRange
)
;
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullStartRange
=
MaybeCreateStartToBlockBoundaryRange
(
*
aInputRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullStartRange
.
isErr
(
)
)
)
{
return
maybeFullStartRange
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullStartRange
=
maybeFullStartRange
.
unwrap
(
)
;
RefPtr
<
nsRange
>
fullEndRange
;
const
bool
useExactMatching
=
!
fullStartRange
;
RefPtr
<
nsRange
>
startRange
;
RefPtr
<
nsRange
>
endRange
;
if
(
useExactMatching
)
{
startRange
=
aInputRange
-
>
CloneRange
(
)
;
}
else
{
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullEndRange
=
MaybeCreateEndToBlockBoundaryRange
(
*
aInputRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullEndRange
.
isErr
(
)
)
)
{
return
maybeFullEndRange
.
propagateErr
(
)
;
}
fullEndRange
=
maybeFullEndRange
.
unwrap
(
)
;
MOZ_ASSERT
(
fullEndRange
"
Searching
from
start
found
a
range
boundary
in
the
range
so
"
"
searching
from
the
end
must
find
one
as
well
"
)
;
startRange
=
nsRange
:
:
Create
(
aInputRange
-
>
StartRef
(
)
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
aInputRange
-
>
StartRef
(
)
TextScanDirection
:
:
Right
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
endRange
=
nsRange
:
:
Create
(
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
aInputRange
-
>
EndRef
(
)
TextScanDirection
:
:
Left
)
aInputRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
}
auto
prefixRanges
=
CreatePrefixRanges
(
startRange
-
>
StartRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
prefixRanges
.
isErr
(
)
)
)
{
return
prefixRanges
.
propagateErr
(
)
;
}
auto
[
prefixRange
fullPrefixRange
]
=
prefixRanges
.
unwrap
(
)
;
auto
suffixRanges
=
CreateSuffixRanges
(
endRange
?
endRange
-
>
EndRef
(
)
:
startRange
-
>
EndRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
suffixRanges
.
isErr
(
)
)
)
{
return
suffixRanges
.
propagateErr
(
)
;
}
auto
[
suffixRange
fullSuffixRange
]
=
suffixRanges
.
unwrap
(
)
;
auto
instance
=
TextDirectiveCandidate
{
startRange
fullStartRange
endRange
fullEndRange
prefixRange
fullPrefixRange
suffixRange
fullSuffixRange
}
;
MOZ_TRY
(
instance
.
CreateTextDirectiveString
(
)
)
;
return
instance
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
TextDirectiveCandidate
:
:
MaybeCreateStartToBlockBoundaryRange
(
const
nsRange
&
aRange
)
{
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
fullRange
=
TextDirectiveUtil
:
:
FindBlockBoundaryInRange
(
aRange
TextScanDirection
:
:
Right
)
.
andThen
(
[
&
aRange
&
rv
]
(
auto
boundary
)
-
>
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
{
RefPtr
range
=
boundary
?
nsRange
:
:
Create
(
aRange
.
StartRef
(
)
*
boundary
rv
)
:
nullptr
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
range
;
}
)
;
return
fullRange
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
TextDirectiveCandidate
:
:
MaybeCreateEndToBlockBoundaryRange
(
const
nsRange
&
aRange
)
{
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
fullRange
=
TextDirectiveUtil
:
:
FindBlockBoundaryInRange
(
aRange
TextScanDirection
:
:
Left
)
.
andThen
(
[
&
aRange
&
rv
]
(
auto
boundary
)
-
>
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
{
RefPtr
range
=
boundary
?
nsRange
:
:
Create
(
*
boundary
aRange
.
EndRef
(
)
rv
)
:
nullptr
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
range
;
}
)
;
return
fullRange
;
}
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreatePrefixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
ErrorResult
rv
;
RangeBoundary
previousNonWhitespacePoint
=
TextDirectiveUtil
:
:
MoveBoundaryToPreviousNonWhitespacePosition
(
aRangeBoundary
)
;
RefPtr
<
nsRange
>
prefixRange
=
nsRange
:
:
Create
(
previousNonWhitespacePoint
previousNonWhitespacePoint
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RangeBoundary
ErrorResult
>
fullPrefixStartBoundary
=
TextDirectiveUtil
:
:
FindNextBlockBoundary
(
prefixRange
-
>
EndRef
(
)
TextScanDirection
:
:
Left
)
;
if
(
MOZ_UNLIKELY
(
fullPrefixStartBoundary
.
isErr
(
)
)
)
{
return
fullPrefixStartBoundary
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullPrefixRange
=
nsRange
:
:
Create
(
fullPrefixStartBoundary
.
unwrap
(
)
prefixRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
std
:
:
tuple
{
prefixRange
fullPrefixRange
}
;
}
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreateSuffixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
RangeBoundary
nextNonWhitespacePoint
=
TextDirectiveUtil
:
:
MoveBoundaryToNextNonWhitespacePosition
(
aRangeBoundary
)
;
ErrorResult
rv
;
RefPtr
<
nsRange
>
suffixRange
=
nsRange
:
:
Create
(
nextNonWhitespacePoint
nextNonWhitespacePoint
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RangeBoundary
ErrorResult
>
fullSuffixEndBoundary
=
TextDirectiveUtil
:
:
FindNextBlockBoundary
(
suffixRange
-
>
EndRef
(
)
TextScanDirection
:
:
Right
)
;
if
(
MOZ_UNLIKELY
(
fullSuffixEndBoundary
.
isErr
(
)
)
)
{
return
fullSuffixEndBoundary
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullSuffixRange
=
nsRange
:
:
Create
(
suffixRange
-
>
StartRef
(
)
fullSuffixEndBoundary
.
unwrap
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
std
:
:
tuple
{
suffixRange
fullSuffixRange
}
;
}
const
nsCString
&
TextDirectiveCandidate
:
:
TextDirectiveString
(
)
const
{
return
mTextDirectiveString
;
}
Result
<
Ok
ErrorResult
>
TextDirectiveCandidate
:
:
CreateTextDirectiveString
(
)
{
Result
<
TextDirective
ErrorResult
>
maybeTextDirective
=
TextDirectiveUtil
:
:
CreateTextDirectiveFromRanges
(
mPrefixRange
mStartRange
mEndRange
mSuffixRange
)
;
if
(
MOZ_UNLIKELY
(
maybeTextDirective
.
isErr
(
)
)
)
{
return
maybeTextDirective
.
propagateErr
(
)
;
}
TextDirective
textDirective
=
maybeTextDirective
.
unwrap
(
)
;
create_text_directive
(
&
textDirective
&
mTextDirectiveString
)
;
return
Ok
(
)
;
}
mozilla
:
:
Result
<
nsCString
ErrorResult
>
TextDirectiveCreator
:
:
CreateTextDirectiveFromRange
(
Document
&
aDocument
nsRange
*
aInputRange
)
{
MOZ_ASSERT
(
aInputRange
)
;
MOZ_ASSERT
(
!
aInputRange
-
>
Collapsed
(
)
)
;
RefPtr
<
nsRange
>
inputRangeExtendedToWordBoundaries
=
aInputRange
-
>
CloneRange
(
)
;
MOZ_TRY
(
TextDirectiveUtil
:
:
ExtendRangeToWordBoundaries
(
*
inputRangeExtendedToWordBoundaries
)
)
;
if
(
inputRangeExtendedToWordBoundaries
-
>
Collapsed
(
)
)
{
return
nsCString
{
}
;
}
Result
<
nsString
ErrorResult
>
rangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
inputRangeExtendedToWordBoundaries
)
;
if
(
MOZ_UNLIKELY
(
rangeContent
.
isErr
(
)
)
)
{
return
rangeContent
.
propagateErr
(
)
;
}
if
(
rangeContent
.
unwrap
(
)
.
IsEmpty
(
)
)
{
return
nsCString
{
}
;
}
Result
<
TextDirectiveCandidate
ErrorResult
>
maybeTextDirectiveCandidate
=
TextDirectiveCandidate
:
:
CreateFromInputRange
(
inputRangeExtendedToWordBoundaries
)
;
if
(
MOZ_UNLIKELY
(
maybeTextDirectiveCandidate
.
isErr
(
)
)
)
{
return
maybeTextDirectiveCandidate
.
propagateErr
(
)
;
}
auto
textDirectiveCandidate
=
maybeTextDirectiveCandidate
.
unwrap
(
)
;
Result
<
nsCString
ErrorResult
>
maybeTextDirectiveString
=
textDirectiveCandidate
.
TextDirectiveString
(
)
;
if
(
MOZ_UNLIKELY
(
maybeTextDirectiveString
.
isErr
(
)
)
)
{
return
maybeTextDirectiveString
.
propagateErr
(
)
;
}
nsCString
textDirectiveString
=
maybeTextDirectiveString
.
unwrap
(
)
;
TEXT_FRAGMENT_LOG
(
"
Returning
text
directive
'
%
s
'
.
"
textDirectiveString
.
Data
(
)
)
;
return
textDirectiveString
;
}
}
