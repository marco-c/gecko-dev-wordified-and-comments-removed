#
include
"
TextDirectiveCreator
.
h
"
#
include
"
TextDirectiveUtil
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
dom
/
fragmentdirectives_ffi_generated
.
h
"
#
include
"
nsDeque
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
Document
.
h
"
namespace
mozilla
:
:
dom
{
Result
<
const
nsString
*
ErrorResult
>
RangeContentCache
:
:
GetOrCreate
(
nsRange
*
aRange
)
{
if
(
!
aRange
)
{
return
nullptr
;
}
if
(
const
auto
rangeContent
=
mCache
.
Lookup
(
aRange
)
)
{
return
rangeContent
-
>
get
(
)
;
}
return
TextDirectiveUtil
:
:
RangeContentAsFoldCase
(
aRange
)
.
andThen
(
[
cache
=
&
mCache
range
=
RefPtr
(
aRange
)
]
(
nsString
&
&
content
)
-
>
Result
<
const
nsString
*
ErrorResult
>
{
return
cache
-
>
InsertOrUpdate
(
range
MakeUnique
<
nsString
>
(
std
:
:
move
(
content
)
)
)
.
get
(
)
;
}
)
;
}
TextDirectiveCandidate
:
:
TextDirectiveCandidate
(
nsRange
*
aStartRange
nsRange
*
aFullStartRange
nsRange
*
aEndRange
nsRange
*
aFullEndRange
nsRange
*
aPrefixRange
nsRange
*
aFullPrefixRange
nsRange
*
aSuffixRange
nsRange
*
aFullSuffixRange
)
:
mStartRange
(
aStartRange
)
mFullStartRange
(
aFullStartRange
)
mEndRange
(
aEndRange
)
mFullEndRange
(
aFullEndRange
)
mPrefixRange
(
aPrefixRange
)
mFullPrefixRange
(
aFullPrefixRange
)
mSuffixRange
(
aSuffixRange
)
mFullSuffixRange
(
aFullSuffixRange
)
{
}
Result
<
TextDirectiveCandidate
ErrorResult
>
TextDirectiveCandidate
:
:
CreateFromInputRange
(
const
nsRange
*
aInputRange
RangeContentCache
&
aRangeContentCache
)
{
MOZ_ASSERT
(
aInputRange
)
;
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullStartRange
=
MaybeCreateStartToBlockBoundaryRange
(
*
aInputRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullStartRange
.
isErr
(
)
)
)
{
return
maybeFullStartRange
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullStartRange
=
maybeFullStartRange
.
unwrap
(
)
;
RefPtr
<
nsRange
>
fullEndRange
;
const
bool
useExactMatching
=
!
fullStartRange
;
RefPtr
<
nsRange
>
startRange
;
RefPtr
<
nsRange
>
endRange
;
if
(
useExactMatching
)
{
startRange
=
aInputRange
-
>
CloneRange
(
)
;
}
else
{
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullEndRange
=
MaybeCreateEndToBlockBoundaryRange
(
*
aInputRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullEndRange
.
isErr
(
)
)
)
{
return
maybeFullEndRange
.
propagateErr
(
)
;
}
fullEndRange
=
maybeFullEndRange
.
unwrap
(
)
;
MOZ_ASSERT
(
fullEndRange
"
Searching
from
start
found
a
range
boundary
in
the
range
so
"
"
searching
from
the
end
must
find
one
as
well
"
)
;
startRange
=
nsRange
:
:
Create
(
aInputRange
-
>
StartRef
(
)
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
aInputRange
-
>
StartRef
(
)
TextScanDirection
:
:
Right
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
endRange
=
nsRange
:
:
Create
(
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
aInputRange
-
>
EndRef
(
)
TextScanDirection
:
:
Left
)
aInputRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
}
auto
prefixRanges
=
CreatePrefixRanges
(
startRange
-
>
StartRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
prefixRanges
.
isErr
(
)
)
)
{
return
prefixRanges
.
propagateErr
(
)
;
}
auto
[
prefixRange
fullPrefixRange
]
=
prefixRanges
.
unwrap
(
)
;
auto
suffixRanges
=
CreateSuffixRanges
(
endRange
?
endRange
-
>
EndRef
(
)
:
startRange
-
>
EndRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
suffixRanges
.
isErr
(
)
)
)
{
return
suffixRanges
.
propagateErr
(
)
;
}
auto
[
suffixRange
fullSuffixRange
]
=
suffixRanges
.
unwrap
(
)
;
auto
instance
=
TextDirectiveCandidate
{
startRange
fullStartRange
endRange
fullEndRange
prefixRange
fullPrefixRange
suffixRange
fullSuffixRange
}
;
MOZ_TRY
(
instance
.
CreateFoldCaseContents
(
aRangeContentCache
)
)
;
MOZ_TRY
(
instance
.
CreateTextDirectiveString
(
)
)
;
return
instance
;
}
Result
<
TextDirectiveCandidate
ErrorResult
>
TextDirectiveCandidate
:
:
CreateFromStartAndEndRange
(
const
nsRange
*
aStartRange
const
nsRange
*
aEndRange
RangeContentCache
&
aRangeContentCache
)
{
MOZ_ASSERT
(
aStartRange
)
;
MOZ_ASSERT
(
aEndRange
)
;
ErrorResult
rv
;
RefPtr
<
nsRange
>
startRange
=
aStartRange
-
>
CloneRange
(
)
;
RefPtr
<
nsRange
>
endRange
=
aEndRange
-
>
CloneRange
(
)
;
RefPtr
<
nsRange
>
fullRange
=
nsRange
:
:
Create
(
startRange
-
>
StartRef
(
)
endRange
-
>
EndRef
(
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullStartRange
=
MaybeCreateStartToBlockBoundaryRange
(
*
fullRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullStartRange
.
isErr
(
)
)
)
{
return
maybeFullStartRange
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullStartRange
=
maybeFullStartRange
.
unwrap
(
)
;
if
(
!
fullStartRange
)
{
fullStartRange
=
fullRange
-
>
CloneRange
(
)
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
maybeFullEndRange
=
MaybeCreateEndToBlockBoundaryRange
(
*
fullRange
)
;
if
(
MOZ_UNLIKELY
(
maybeFullEndRange
.
isErr
(
)
)
)
{
return
maybeFullStartRange
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullEndRange
=
maybeFullStartRange
.
unwrap
(
)
;
if
(
!
fullEndRange
)
{
fullEndRange
=
fullRange
-
>
CloneRange
(
)
;
}
auto
prefixRanges
=
CreatePrefixRanges
(
startRange
-
>
StartRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
prefixRanges
.
isErr
(
)
)
)
{
return
prefixRanges
.
propagateErr
(
)
;
}
auto
[
prefixRange
fullPrefixRange
]
=
prefixRanges
.
unwrap
(
)
;
auto
suffixRanges
=
CreateSuffixRanges
(
endRange
-
>
EndRef
(
)
)
;
if
(
MOZ_UNLIKELY
(
suffixRanges
.
isErr
(
)
)
)
{
return
suffixRanges
.
propagateErr
(
)
;
}
auto
[
suffixRange
fullSuffixRange
]
=
suffixRanges
.
unwrap
(
)
;
auto
instance
=
TextDirectiveCandidate
{
startRange
fullStartRange
endRange
fullEndRange
prefixRange
fullPrefixRange
suffixRange
fullSuffixRange
}
;
MOZ_TRY
(
instance
.
CreateFoldCaseContents
(
aRangeContentCache
)
)
;
MOZ_TRY
(
instance
.
CreateTextDirectiveString
(
)
)
;
return
instance
;
}
Result
<
TextDirectiveCandidate
ErrorResult
>
TextDirectiveCandidate
:
:
CloneWith
(
RefPtr
<
nsRange
>
&
&
aNewPrefixRange
RefPtr
<
nsRange
>
&
&
aNewStartRange
RefPtr
<
nsRange
>
&
&
aNewEndRange
RefPtr
<
nsRange
>
&
&
aNewSuffixRange
RangeContentCache
&
aRangeContentCache
)
const
{
MOZ_ASSERT
(
mFullPrefixRange
&
&
mFullSuffixRange
"
TextDirectiveCandidate
:
:
CloneWith
(
)
:
Source
object
is
in
invalid
state
"
)
;
TextDirectiveCandidate
clone
(
*
this
)
;
if
(
aNewPrefixRange
)
{
clone
.
mPrefixRange
=
std
:
:
move
(
aNewPrefixRange
)
;
Result
<
const
nsString
*
ErrorResult
>
maybeContent
=
aRangeContentCache
.
GetOrCreate
(
clone
.
mPrefixRange
)
;
if
(
MOZ_UNLIKELY
(
maybeContent
.
isErr
(
)
)
)
{
return
maybeContent
.
propagateErr
(
)
;
}
clone
.
mPrefixContentFoldCase
=
maybeContent
.
unwrap
(
)
;
}
if
(
aNewStartRange
)
{
clone
.
mStartRange
=
std
:
:
move
(
aNewStartRange
)
;
Result
<
const
nsString
*
ErrorResult
>
maybeContent
=
aRangeContentCache
.
GetOrCreate
(
clone
.
mStartRange
)
;
if
(
MOZ_UNLIKELY
(
maybeContent
.
isErr
(
)
)
)
{
return
maybeContent
.
propagateErr
(
)
;
}
clone
.
mStartContentFoldCase
=
maybeContent
.
unwrap
(
)
;
}
MOZ_ASSERT_IF
(
aNewEndRange
mEndRange
)
;
if
(
aNewEndRange
)
{
clone
.
mEndRange
=
std
:
:
move
(
aNewEndRange
)
;
Result
<
const
nsString
*
ErrorResult
>
maybeContent
=
aRangeContentCache
.
GetOrCreate
(
clone
.
mEndRange
)
;
if
(
MOZ_UNLIKELY
(
maybeContent
.
isErr
(
)
)
)
{
return
maybeContent
.
propagateErr
(
)
;
}
clone
.
mEndContentFoldCase
=
maybeContent
.
unwrap
(
)
;
}
if
(
aNewSuffixRange
)
{
clone
.
mSuffixRange
=
std
:
:
move
(
aNewSuffixRange
)
;
Result
<
const
nsString
*
ErrorResult
>
maybeContent
=
aRangeContentCache
.
GetOrCreate
(
clone
.
mSuffixRange
)
;
if
(
MOZ_UNLIKELY
(
maybeContent
.
isErr
(
)
)
)
{
return
maybeContent
.
propagateErr
(
)
;
}
clone
.
mSuffixContentFoldCase
=
maybeContent
.
unwrap
(
)
;
}
MOZ_TRY
(
clone
.
CreateTextDirectiveString
(
)
)
;
return
clone
;
}
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreateNewCandidatesForMatches
(
const
nsTArray
<
const
TextDirectiveCandidate
*
>
&
aMatches
RangeContentCache
&
aRangeContentCache
)
{
TEXT_FRAGMENT_LOG
(
"
Creating
new
candidates
for
candidate
{
}
"
mTextDirectiveString
)
;
nsTArray
<
TextDirectiveCandidate
>
newCandidates
;
for
(
const
auto
*
match
:
aMatches
)
{
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
maybeNewCandidatesForThisMatch
=
CreateNewCandidatesForGivenMatch
(
*
match
aRangeContentCache
)
;
if
(
MOZ_UNLIKELY
(
maybeNewCandidatesForThisMatch
.
isErr
(
)
)
)
{
return
maybeNewCandidatesForThisMatch
.
propagateErr
(
)
;
}
auto
newCandidatesForThisMatch
=
maybeNewCandidatesForThisMatch
.
unwrap
(
)
;
if
(
newCandidatesForThisMatch
.
IsEmpty
(
)
)
{
return
nsTArray
<
TextDirectiveCandidate
>
{
}
;
}
newCandidates
.
AppendElements
(
std
:
:
move
(
newCandidatesForThisMatch
)
)
;
}
return
newCandidates
;
}
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreateNewCandidatesForGivenMatch
(
const
TextDirectiveCandidate
&
aOther
RangeContentCache
&
aRangeContentCache
)
const
{
AutoTArray
<
TextDirectiveCandidate
4
>
newCandidates
;
auto
createRangeExtendedUntilMismatch
=
[
]
(
nsRange
*
thisFullRange
const
nsString
&
thisFullRangeFoldCase
nsRange
*
otherFullRange
const
nsString
&
otherFullRangeFoldCase
TextScanDirection
expandDirection
Maybe
<
RangeBoundary
>
expandLimit
=
Nothing
{
}
)
-
>
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
{
ErrorResult
rv
;
auto
equalSubstringLength
=
expandDirection
=
=
TextScanDirection
:
:
Right
?
TextDirectiveUtil
:
:
FindCommonPrefix
(
thisFullRangeFoldCase
otherFullRangeFoldCase
)
:
TextDirectiveUtil
:
:
FindCommonSuffix
(
thisFullRangeFoldCase
otherFullRangeFoldCase
)
;
if
(
equalSubstringLength
=
=
thisFullRangeFoldCase
.
Length
(
)
)
{
return
RefPtr
<
nsRange
>
(
nullptr
)
;
}
size_t
indexFromStartOfFullRange
=
expandDirection
=
=
TextScanDirection
:
:
Right
?
equalSubstringLength
:
thisFullRangeFoldCase
.
Length
(
)
-
equalSubstringLength
;
Result
<
RangeBoundary
ErrorResult
>
maybeNewRangeBoundary
=
TextDirectiveUtil
:
:
CreateRangeBoundaryByMovingOffsetFromRangeStart
(
thisFullRange
indexFromStartOfFullRange
)
;
if
(
MOZ_UNLIKELY
(
maybeNewRangeBoundary
.
isErr
(
)
)
)
{
return
maybeNewRangeBoundary
.
propagateErr
(
)
;
}
RangeBoundary
newRangeBoundary
=
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
maybeNewRangeBoundary
.
unwrap
(
)
expandDirection
)
;
if
(
expandLimit
.
isSome
(
)
)
{
if
(
auto
compareResult
=
nsContentUtils
:
:
ComparePoints
(
newRangeBoundary
*
expandLimit
)
)
{
if
(
(
expandDirection
=
=
TextScanDirection
:
:
Right
&
&
*
compareResult
!
=
1
)
|
|
(
expandDirection
=
=
TextScanDirection
:
:
Left
&
&
*
compareResult
!
=
-
1
)
)
{
newRangeBoundary
=
*
expandLimit
;
}
}
}
RefPtr
<
nsRange
>
newRange
=
thisFullRange
-
>
CloneRange
(
)
;
if
(
expandDirection
=
=
TextScanDirection
:
:
Right
)
{
newRange
-
>
SetEnd
(
newRangeBoundary
.
AsRaw
(
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
}
else
{
newRange
-
>
SetStart
(
newRangeBoundary
.
AsRaw
(
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
}
return
newRange
;
}
;
auto
createAndAddCandidate
=
[
candidate
=
this
&
newCandidates
&
aRangeContentCache
func
=
__FUNCTION__
]
(
const
char
*
contextTermName
RefPtr
<
nsRange
>
&
&
extendedPrefix
RefPtr
<
nsRange
>
&
&
extendedStart
RefPtr
<
nsRange
>
&
&
extendedEnd
RefPtr
<
nsRange
>
&
&
extendedSuffix
)
-
>
Result
<
Ok
ErrorResult
>
{
if
(
!
extendedPrefix
&
&
!
extendedStart
&
&
!
extendedEnd
&
&
!
extendedSuffix
)
{
TEXT_FRAGMENT_LOG_FN
(
"
Could
not
extend
the
{
}
because
it
is
ambiguous
.
"
func
contextTermName
)
;
return
Ok
(
)
;
}
Result
<
TextDirectiveCandidate
ErrorResult
>
extendedCandidate
=
candidate
-
>
CloneWith
(
std
:
:
move
(
extendedPrefix
)
std
:
:
move
(
extendedStart
)
std
:
:
move
(
extendedEnd
)
std
:
:
move
(
extendedSuffix
)
aRangeContentCache
)
;
if
(
MOZ_UNLIKELY
(
extendedCandidate
.
isErr
(
)
)
)
{
return
extendedCandidate
.
propagateErr
(
)
;
}
newCandidates
.
AppendElement
(
extendedCandidate
.
unwrap
(
)
)
;
TEXT_FRAGMENT_LOG_FN
(
"
Created
candidate
by
extending
the
{
}
:
{
}
"
func
contextTermName
newCandidates
.
LastElement
(
)
.
TextDirectiveString
(
)
)
;
return
Ok
(
)
;
}
;
MOZ_ASSERT
(
mFullPrefixContentFoldCase
&
&
aOther
.
mFullPrefixContentFoldCase
)
;
MOZ_TRY
(
createRangeExtendedUntilMismatch
(
mFullPrefixRange
*
mFullPrefixContentFoldCase
aOther
.
mFullPrefixRange
*
aOther
.
mFullPrefixContentFoldCase
TextScanDirection
:
:
Left
)
.
andThen
(
[
&
createAndAddCandidate
]
(
RefPtr
<
nsRange
>
&
&
extendedRange
)
{
return
createAndAddCandidate
(
"
prefix
"
std
:
:
move
(
extendedRange
)
nullptr
nullptr
nullptr
)
;
}
)
)
;
MOZ_ASSERT
(
mFullSuffixContentFoldCase
&
&
aOther
.
mFullSuffixContentFoldCase
)
;
MOZ_TRY
(
createRangeExtendedUntilMismatch
(
mFullSuffixRange
*
mFullSuffixContentFoldCase
aOther
.
mFullSuffixRange
*
aOther
.
mFullSuffixContentFoldCase
TextScanDirection
:
:
Right
)
.
andThen
(
[
&
createAndAddCandidate
]
(
RefPtr
<
nsRange
>
&
&
extendedRange
)
{
return
createAndAddCandidate
(
"
suffix
"
nullptr
nullptr
nullptr
std
:
:
move
(
extendedRange
)
)
;
}
)
)
;
MOZ_ASSERT
(
UseExactMatch
(
)
=
=
aOther
.
UseExactMatch
(
)
)
;
if
(
UseExactMatch
(
)
)
{
return
std
:
:
move
(
newCandidates
)
;
}
MOZ_ASSERT
(
mFullStartContentFoldCase
&
&
aOther
.
mFullStartContentFoldCase
)
;
MOZ_TRY
(
createRangeExtendedUntilMismatch
(
mFullStartRange
*
mFullStartContentFoldCase
aOther
.
mFullStartRange
*
aOther
.
mFullStartContentFoldCase
TextScanDirection
:
:
Right
Some
(
mEndRange
-
>
StartRef
(
)
)
)
.
andThen
(
[
&
createAndAddCandidate
]
(
RefPtr
<
nsRange
>
&
&
extendedRange
)
{
return
createAndAddCandidate
(
"
start
"
nullptr
std
:
:
move
(
extendedRange
)
nullptr
nullptr
)
;
}
)
)
;
MOZ_ASSERT
(
mFullEndContentFoldCase
&
&
aOther
.
mFullEndContentFoldCase
)
;
MOZ_TRY
(
createRangeExtendedUntilMismatch
(
mFullEndRange
*
mFullEndContentFoldCase
aOther
.
mFullEndRange
*
aOther
.
mFullEndContentFoldCase
TextScanDirection
:
:
Left
)
.
andThen
(
[
&
createAndAddCandidate
]
(
RefPtr
<
nsRange
>
&
&
extendedRange
)
{
return
createAndAddCandidate
(
"
end
"
nullptr
nullptr
std
:
:
move
(
extendedRange
)
nullptr
)
;
}
)
)
;
return
std
:
:
move
(
newCandidates
)
;
}
nsTArray
<
const
TextDirectiveCandidate
*
>
TextDirectiveCandidate
:
:
FilterNonMatchingCandidates
(
const
nsTArray
<
const
TextDirectiveCandidate
*
>
&
aMatches
)
{
AutoTArray
<
const
TextDirectiveCandidate
*
8
>
stillMatching
;
for
(
const
auto
*
match
:
aMatches
)
{
if
(
ThisCandidateMatchesOther
(
*
match
)
)
{
stillMatching
.
AppendElement
(
match
)
;
}
}
return
std
:
:
move
(
stillMatching
)
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
TextDirectiveCandidate
:
:
MaybeCreateStartToBlockBoundaryRange
(
const
nsRange
&
aRange
)
{
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
fullRange
=
TextDirectiveUtil
:
:
FindBlockBoundaryInRange
(
aRange
TextScanDirection
:
:
Right
)
.
andThen
(
[
&
aRange
&
rv
]
(
auto
boundary
)
-
>
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
{
RefPtr
range
=
boundary
?
nsRange
:
:
Create
(
aRange
.
StartRef
(
)
*
boundary
rv
)
:
nullptr
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
range
;
}
)
;
return
fullRange
;
}
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
TextDirectiveCandidate
:
:
MaybeCreateEndToBlockBoundaryRange
(
const
nsRange
&
aRange
)
{
ErrorResult
rv
;
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
fullRange
=
TextDirectiveUtil
:
:
FindBlockBoundaryInRange
(
aRange
TextScanDirection
:
:
Left
)
.
andThen
(
[
&
aRange
&
rv
]
(
auto
boundary
)
-
>
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
{
RefPtr
range
=
boundary
?
nsRange
:
:
Create
(
*
boundary
aRange
.
EndRef
(
)
rv
)
:
nullptr
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
range
;
}
)
;
return
fullRange
;
}
bool
TextDirectiveCandidate
:
:
ThisCandidateMatchesOther
(
const
TextDirectiveCandidate
&
aOther
)
const
{
if
(
TextDirectiveUtil
:
:
FindCommonSuffix
(
*
mPrefixContentFoldCase
*
aOther
.
mFullPrefixContentFoldCase
)
!
=
mPrefixContentFoldCase
-
>
Length
(
)
)
{
return
false
;
}
if
(
TextDirectiveUtil
:
:
FindCommonPrefix
(
*
mSuffixContentFoldCase
*
aOther
.
mFullSuffixContentFoldCase
)
!
=
mSuffixContentFoldCase
-
>
Length
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
UseExactMatch
(
)
=
=
aOther
.
UseExactMatch
(
)
)
;
if
(
UseExactMatch
(
)
)
{
return
true
;
}
if
(
TextDirectiveUtil
:
:
FindCommonPrefix
(
*
mStartContentFoldCase
*
aOther
.
mFullStartContentFoldCase
)
!
=
mStartContentFoldCase
-
>
Length
(
)
)
{
return
false
;
}
return
TextDirectiveUtil
:
:
FindCommonSuffix
(
*
mEndContentFoldCase
*
aOther
.
mFullEndContentFoldCase
)
=
=
mEndContentFoldCase
-
>
Length
(
)
;
}
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreatePrefixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
ErrorResult
rv
;
RangeBoundary
previousNonWhitespacePoint
=
TextDirectiveUtil
:
:
MoveBoundaryToPreviousNonWhitespacePosition
(
aRangeBoundary
)
;
RefPtr
<
nsRange
>
prefixRange
=
nsRange
:
:
Create
(
previousNonWhitespacePoint
previousNonWhitespacePoint
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RangeBoundary
ErrorResult
>
fullPrefixStartBoundary
=
TextDirectiveUtil
:
:
FindNextBlockBoundary
(
prefixRange
-
>
EndRef
(
)
TextScanDirection
:
:
Left
)
;
if
(
MOZ_UNLIKELY
(
fullPrefixStartBoundary
.
isErr
(
)
)
)
{
return
fullPrefixStartBoundary
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullPrefixRange
=
nsRange
:
:
Create
(
fullPrefixStartBoundary
.
unwrap
(
)
prefixRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
std
:
:
tuple
{
prefixRange
fullPrefixRange
}
;
}
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCandidate
:
:
CreateSuffixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
RangeBoundary
nextNonWhitespacePoint
=
TextDirectiveUtil
:
:
MoveBoundaryToNextNonWhitespacePosition
(
aRangeBoundary
)
;
ErrorResult
rv
;
RefPtr
<
nsRange
>
suffixRange
=
nsRange
:
:
Create
(
nextNonWhitespacePoint
nextNonWhitespacePoint
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
Result
<
RangeBoundary
ErrorResult
>
fullSuffixEndBoundary
=
TextDirectiveUtil
:
:
FindNextBlockBoundary
(
suffixRange
-
>
EndRef
(
)
TextScanDirection
:
:
Right
)
;
if
(
MOZ_UNLIKELY
(
fullSuffixEndBoundary
.
isErr
(
)
)
)
{
return
fullSuffixEndBoundary
.
propagateErr
(
)
;
}
RefPtr
<
nsRange
>
fullSuffixRange
=
nsRange
:
:
Create
(
suffixRange
-
>
StartRef
(
)
fullSuffixEndBoundary
.
unwrap
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
std
:
:
tuple
{
suffixRange
fullSuffixRange
}
;
}
const
nsCString
&
TextDirectiveCandidate
:
:
TextDirectiveString
(
)
const
{
return
mTextDirectiveString
;
}
Result
<
Ok
ErrorResult
>
TextDirectiveCandidate
:
:
CreateTextDirectiveString
(
)
{
Result
<
TextDirective
ErrorResult
>
maybeTextDirective
=
TextDirectiveUtil
:
:
CreateTextDirectiveFromRanges
(
mPrefixRange
mStartRange
mEndRange
mSuffixRange
)
;
if
(
MOZ_UNLIKELY
(
maybeTextDirective
.
isErr
(
)
)
)
{
return
maybeTextDirective
.
propagateErr
(
)
;
}
TextDirective
textDirective
=
maybeTextDirective
.
unwrap
(
)
;
create_text_directive
(
&
textDirective
&
mTextDirectiveString
)
;
return
Ok
(
)
;
}
Result
<
Ok
ErrorResult
>
TextDirectiveCandidate
:
:
CreateFoldCaseContents
(
RangeContentCache
&
aRangeContentCache
)
{
auto
getFoldCase
=
[
&
aRangeContentCache
]
(
nsRange
*
range
const
nsString
*
&
content
)
-
>
Result
<
Ok
ErrorResult
>
{
return
aRangeContentCache
.
GetOrCreate
(
range
)
.
andThen
(
[
&
content
]
(
const
nsString
*
&
&
value
)
-
>
Result
<
Ok
ErrorResult
>
{
content
=
value
;
return
Ok
(
)
;
}
)
;
}
;
MOZ_ASSERT
(
mFullPrefixRange
)
;
MOZ_ASSERT
(
mFullSuffixRange
)
;
MOZ_ASSERT
(
mStartRange
)
;
MOZ_TRY
(
getFoldCase
(
mFullPrefixRange
mFullPrefixContentFoldCase
)
)
;
MOZ_TRY
(
getFoldCase
(
mFullStartRange
mFullStartContentFoldCase
)
)
;
MOZ_TRY
(
getFoldCase
(
mFullEndRange
mFullEndContentFoldCase
)
)
;
MOZ_TRY
(
getFoldCase
(
mFullSuffixRange
mFullSuffixContentFoldCase
)
)
;
MOZ_TRY
(
getFoldCase
(
mPrefixRange
mPrefixContentFoldCase
)
)
;
MOZ_TRY
(
getFoldCase
(
mStartRange
mStartContentFoldCase
)
)
;
MOZ_TRY
(
getFoldCase
(
mEndRange
mEndContentFoldCase
)
)
;
MOZ_TRY
(
getFoldCase
(
mSuffixRange
mSuffixContentFoldCase
)
)
;
return
Ok
(
)
;
}
void
TextDirectiveCandidate
:
:
LogCurrentState
(
const
char
*
aCallerFunc
)
const
{
if
(
!
TextDirectiveUtil
:
:
ShouldLog
(
)
)
{
return
;
}
auto
getRangeContent
=
[
]
(
nsRange
*
range
)
{
auto
content
=
TextDirectiveUtil
:
:
RangeContentAsString
(
range
)
.
unwrapOr
(
u
"
<
nsRange
:
:
ToString
(
)
failed
>
"
_ns
)
;
return
NS_ConvertUTF16toUTF8
(
content
.
IsEmpty
(
)
?
u
"
<
empty
range
>
"
_ns
:
content
)
;
}
;
auto
fullTextDirectiveString
=
TextDirectiveUtil
:
:
CreateTextDirectiveFromRanges
(
mFullPrefixRange
mFullStartRange
?
mFullStartRange
:
mStartRange
mFullEndRange
mFullSuffixRange
)
.
map
(
[
]
(
const
auto
&
textDirective
)
{
nsCString
value
;
create_text_directive
(
&
textDirective
&
value
)
;
return
value
;
}
)
.
unwrapOr
(
"
<
creating
text
directive
failed
>
"
_ns
)
;
TEXT_FRAGMENT_LOG_FN
(
"
State
of
text
directive
candidate
{
:
p
}
:
\
nPercent
-
encoded
string
:
"
"
{
}
\
n
\
nCurrent
context
terms
:
\
nPrefix
:
{
}
\
nStart
:
{
}
\
nEnd
:
{
}
\
nSuffix
:
"
"
{
}
\
n
\
nMaximum
expanded
context
terms
:
\
nPercent
-
encoded
string
:
"
"
{
}
\
nPrefix
:
\
n
{
}
\
nStart
:
\
n
{
}
\
nEnd
:
\
n
{
}
\
nSuffix
:
\
n
{
}
"
aCallerFunc
static_cast
<
const
void
*
>
(
this
)
mTextDirectiveString
getRangeContent
(
mPrefixRange
)
getRangeContent
(
mStartRange
)
getRangeContent
(
mEndRange
)
getRangeContent
(
mSuffixRange
)
fullTextDirectiveString
getRangeContent
(
mFullPrefixRange
)
getRangeContent
(
mFullStartRange
)
getRangeContent
(
mFullEndRange
)
getRangeContent
(
mFullSuffixRange
)
)
;
}
TextDirectiveCreator
:
:
TextDirectiveCreator
(
Document
&
aDocument
nsRange
*
aInputRange
TextDirectiveCandidate
&
&
aTextDirective
RangeContentCache
&
&
aRangeContentCache
)
:
mDocument
(
aDocument
)
mInputRange
(
aInputRange
)
mTextDirective
(
std
:
:
move
(
aTextDirective
)
)
mRangeContentCache
(
std
:
:
move
(
aRangeContentCache
)
)
{
}
mozilla
:
:
Result
<
nsCString
ErrorResult
>
TextDirectiveCreator
:
:
CreateTextDirectiveFromRange
(
Document
&
aDocument
nsRange
*
aInputRange
)
{
MOZ_ASSERT
(
aInputRange
)
;
MOZ_ASSERT
(
!
aInputRange
-
>
Collapsed
(
)
)
;
RefPtr
<
nsRange
>
inputRangeExtendedToWordBoundaries
=
aInputRange
-
>
CloneRange
(
)
;
MOZ_TRY
(
TextDirectiveUtil
:
:
ExtendRangeToWordBoundaries
(
*
inputRangeExtendedToWordBoundaries
)
)
;
if
(
inputRangeExtendedToWordBoundaries
-
>
Collapsed
(
)
)
{
return
nsCString
{
}
;
}
Result
<
nsString
ErrorResult
>
rangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
inputRangeExtendedToWordBoundaries
)
;
if
(
MOZ_UNLIKELY
(
rangeContent
.
isErr
(
)
)
)
{
return
rangeContent
.
propagateErr
(
)
;
}
if
(
rangeContent
.
unwrap
(
)
.
IsEmpty
(
)
)
{
return
nsCString
{
}
;
}
RangeContentCache
rangeContentCache
;
Result
<
TextDirectiveCandidate
ErrorResult
>
maybeTextDirectiveCandidate
=
TextDirectiveCandidate
:
:
CreateFromInputRange
(
inputRangeExtendedToWordBoundaries
rangeContentCache
)
;
if
(
MOZ_UNLIKELY
(
maybeTextDirectiveCandidate
.
isErr
(
)
)
)
{
return
maybeTextDirectiveCandidate
.
propagateErr
(
)
;
}
auto
textDirectiveCandidate
=
maybeTextDirectiveCandidate
.
unwrap
(
)
;
TextDirectiveCreator
creator
(
aDocument
inputRangeExtendedToWordBoundaries
std
:
:
move
(
textDirectiveCandidate
)
std
:
:
move
(
rangeContentCache
)
)
;
return
creator
.
FindAllMatchingCandidates
(
)
.
andThen
(
[
&
creator
]
(
nsTArray
<
TextDirectiveCandidate
>
&
&
previousMatches
)
-
>
Result
<
nsCString
ErrorResult
>
{
return
creator
.
CreateTextDirectiveFromMatches
(
previousMatches
)
;
}
)
;
}
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
TextDirectiveCreator
:
:
FindAllMatchingCandidates
(
)
{
ErrorResult
rv
;
nsTArray
<
TextDirectiveCandidate
>
textDirectiveMatches
;
if
(
mTextDirective
.
UseExactMatch
(
)
)
{
Result
<
nsString
ErrorResult
>
rangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
mInputRange
)
;
if
(
MOZ_UNLIKELY
(
rangeContent
.
isErr
(
)
)
)
{
return
rangeContent
.
propagateErr
(
)
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
maybeRangeMatches
=
FindAllMatchingRanges
(
rangeContent
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
maybeRangeMatches
.
isErr
(
)
)
)
{
return
maybeRangeMatches
.
propagateErr
(
)
;
}
if
(
mWatchdog
.
IsDone
(
)
)
{
return
textDirectiveMatches
;
}
auto
rangeMatches
=
maybeRangeMatches
.
unwrap
(
)
;
textDirectiveMatches
.
SetCapacity
(
rangeMatches
.
Length
(
)
)
;
for
(
const
auto
&
rangeMatch
:
rangeMatches
)
{
auto
candidate
=
TextDirectiveCandidate
:
:
CreateFromInputRange
(
rangeMatch
mRangeContentCache
)
;
if
(
MOZ_UNLIKELY
(
candidate
.
isErr
(
)
)
)
{
return
candidate
.
propagateErr
(
)
;
}
textDirectiveMatches
.
AppendElement
(
candidate
.
unwrap
(
)
)
;
}
return
textDirectiveMatches
;
}
Result
<
nsString
ErrorResult
>
startRangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
mTextDirective
.
StartRange
(
)
)
;
if
(
MOZ_UNLIKELY
(
startRangeContent
.
isErr
(
)
)
)
{
return
startRangeContent
.
propagateErr
(
)
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
maybeStartRangeMatches
=
FindAllMatchingRanges
(
startRangeContent
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
maybeStartRangeMatches
.
isErr
(
)
)
)
{
return
maybeStartRangeMatches
.
propagateErr
(
)
;
}
auto
startRangeMatches
=
maybeStartRangeMatches
.
unwrap
(
)
;
if
(
mWatchdog
.
IsDone
(
)
)
{
return
textDirectiveMatches
;
}
Result
<
nsString
ErrorResult
>
endRangeContent
=
TextDirectiveUtil
:
:
RangeContentAsString
(
mTextDirective
.
EndRange
(
)
)
;
if
(
MOZ_UNLIKELY
(
endRangeContent
.
isErr
(
)
)
)
{
return
endRangeContent
.
propagateErr
(
)
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
maybeEndRangeMatches
=
FindAllMatchingRanges
(
endRangeContent
.
unwrap
(
)
)
;
if
(
MOZ_UNLIKELY
(
maybeEndRangeMatches
.
isErr
(
)
)
)
{
return
maybeEndRangeMatches
.
propagateErr
(
)
;
}
auto
endRangeMatchesArray
=
maybeEndRangeMatches
.
unwrap
(
)
;
if
(
mWatchdog
.
IsDone
(
)
)
{
return
textDirectiveMatches
;
}
nsDeque
<
nsRange
>
endRangeMatches
;
for
(
auto
&
element
:
endRangeMatchesArray
)
{
endRangeMatches
.
Push
(
element
.
get
(
)
)
;
}
size_t
counter
=
0
;
for
(
const
auto
&
matchStartRange
:
startRangeMatches
)
{
if
(
+
+
counter
%
100
=
=
0
&
&
mWatchdog
.
IsDone
(
)
)
{
return
textDirectiveMatches
;
}
for
(
auto
*
matchEndRange
:
endRangeMatches
)
{
Maybe
<
int32_t
>
compare
=
nsContentUtils
:
:
ComparePoints
(
matchStartRange
-
>
EndRef
(
)
matchEndRange
-
>
StartRef
(
)
)
;
if
(
!
compare
|
|
*
compare
!
=
-
1
)
{
endRangeMatches
.
PopFront
(
)
;
continue
;
}
auto
candidate
=
TextDirectiveCandidate
:
:
CreateFromStartAndEndRange
(
matchStartRange
matchEndRange
mRangeContentCache
)
;
if
(
MOZ_UNLIKELY
(
candidate
.
isErr
(
)
)
)
{
return
candidate
.
propagateErr
(
)
;
}
textDirectiveMatches
.
AppendElement
(
candidate
.
unwrap
(
)
)
;
}
}
return
textDirectiveMatches
;
}
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
TextDirectiveCreator
:
:
FindAllMatchingRanges
(
const
nsString
&
aSearchQuery
)
{
MOZ_ASSERT
(
!
aSearchQuery
.
IsEmpty
(
)
)
;
ErrorResult
rv
;
nsContentUtils
:
:
NodeIndexCache
nodeIndexCache
;
RangeBoundary
documentStart
{
&
mDocument
0u
}
;
RefPtr
<
nsRange
>
searchRange
=
nsRange
:
:
Create
(
documentStart
mInputRange
-
>
EndRef
(
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
nsTArray
<
RefPtr
<
nsRange
>
>
matchingRanges
;
size_t
counter
=
0
;
RangeBoundary
searchStart
=
searchRange
-
>
StartRef
(
)
;
const
RangeBoundary
searchEnd
=
searchRange
-
>
EndRef
(
)
;
while
(
!
searchRange
-
>
Collapsed
(
)
)
{
if
(
+
+
counter
%
100
=
=
0
&
&
mWatchdog
.
IsDone
(
)
)
{
return
matchingRanges
;
}
RefPtr
<
nsRange
>
searchResult
=
TextDirectiveUtil
:
:
FindStringInRange
(
searchStart
searchEnd
aSearchQuery
true
true
&
nodeIndexCache
)
;
if
(
!
searchResult
)
{
break
;
}
if
(
TextDirectiveUtil
:
:
NormalizedRangeBoundariesAreEqual
(
searchResult
-
>
EndRef
(
)
searchEnd
&
nodeIndexCache
)
)
{
break
;
}
matchingRanges
.
AppendElement
(
searchResult
)
;
searchStart
=
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
searchResult
-
>
StartRef
(
)
TextScanDirection
:
:
Right
)
;
}
TEXT_FRAGMENT_LOG
(
"
Found
{
}
matches
for
the
input
'
{
}
'
in
the
document
until
the
end
of
"
"
the
input
range
.
"
matchingRanges
.
Length
(
)
NS_ConvertUTF16toUTF8
(
aSearchQuery
)
)
;
return
matchingRanges
;
}
Result
<
nsCString
ErrorResult
>
TextDirectiveCreator
:
:
CreateTextDirectiveFromMatches
(
const
nsTArray
<
TextDirectiveCandidate
>
&
aTextDirectiveMatches
)
{
if
(
mWatchdog
.
IsDone
(
)
)
{
TEXT_FRAGMENT_LOG
(
"
Hitting
{
}
s
timeout
.
"
StaticPrefs
:
:
dom_text_fragments_create_text_fragment_timeout_seconds
(
)
)
;
return
nsCString
{
}
;
}
TextDirectiveCandidate
currentCandidate
=
std
:
:
move
(
mTextDirective
)
;
if
(
aTextDirectiveMatches
.
IsEmpty
(
)
)
{
TEXT_FRAGMENT_LOG
(
"
There
are
no
conflicting
matches
.
Returning
text
directive
'
{
}
'
.
"
currentCandidate
.
TextDirectiveString
(
)
)
;
return
currentCandidate
.
TextDirectiveString
(
)
;
}
TEXT_FRAGMENT_LOG
(
"
Found
{
}
text
directive
matches
to
eliminate
"
aTextDirectiveMatches
.
Length
(
)
)
;
nsTArray
<
const
TextDirectiveCandidate
*
>
matches
(
aTextDirectiveMatches
.
Length
(
)
)
;
for
(
const
auto
&
match
:
aTextDirectiveMatches
)
{
matches
.
AppendElement
(
&
match
)
;
}
size_t
loopCounter
=
0
;
while
(
!
matches
.
IsEmpty
(
)
)
{
+
+
loopCounter
;
if
(
mWatchdog
.
IsDone
(
)
)
{
TEXT_FRAGMENT_LOG
(
"
Hitting
{
}
s
timeout
.
"
StaticPrefs
:
:
dom_text_fragments_create_text_fragment_timeout_seconds
(
)
)
;
return
nsCString
{
}
;
}
TEXT_FRAGMENT_LOG
(
"
Entering
loop
{
}
.
{
}
matches
left
.
Current
candidate
state
:
\
n
"
loopCounter
matches
.
Length
(
)
)
;
currentCandidate
.
LogCurrentState
(
__FUNCTION__
)
;
if
(
TextDirectiveUtil
:
:
ShouldLog
(
)
)
{
TEXT_FRAGMENT_LOG
(
"
State
of
remaining
matches
:
"
)
;
for
(
const
auto
*
match
:
matches
)
{
match
-
>
LogCurrentState
(
__FUNCTION__
)
;
}
}
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
maybeNewCandidates
=
currentCandidate
.
CreateNewCandidatesForMatches
(
matches
mRangeContentCache
)
;
if
(
MOZ_UNLIKELY
(
maybeNewCandidates
.
isErr
(
)
)
)
{
return
maybeNewCandidates
.
propagateErr
(
)
;
}
nsTArray
<
TextDirectiveCandidate
>
newCandidates
=
maybeNewCandidates
.
unwrap
(
)
;
if
(
newCandidates
.
IsEmpty
(
)
)
{
TEXT_FRAGMENT_LOG
(
"
It
is
not
possible
to
create
a
text
directive
that
matches
the
"
"
input
string
.
"
)
;
return
nsCString
{
}
;
}
nsTArray
<
std
:
:
pair
<
TextDirectiveCandidate
nsTArray
<
const
TextDirectiveCandidate
*
>
>
>
candidatesAndMatchesForNextIteration
(
newCandidates
.
Length
(
)
)
;
for
(
auto
&
newCandidate
:
newCandidates
)
{
candidatesAndMatchesForNextIteration
.
AppendElement
(
std
:
:
pair
{
std
:
:
move
(
newCandidate
)
newCandidate
.
FilterNonMatchingCandidates
(
matches
)
}
)
;
}
candidatesAndMatchesForNextIteration
.
Sort
(
[
]
(
const
auto
&
a
const
auto
&
b
)
-
>
int
{
const
int
difference
=
a
.
second
.
Length
(
)
-
b
.
second
.
Length
(
)
;
if
(
difference
!
=
0
)
{
return
difference
;
}
return
a
.
first
.
TextDirectiveString
(
)
.
Length
(
)
-
b
.
first
.
TextDirectiveString
(
)
.
Length
(
)
;
}
)
;
auto
&
[
bestCandidate
matchesForCandidate
]
=
candidatesAndMatchesForNextIteration
.
ElementAt
(
0
)
;
currentCandidate
=
std
:
:
move
(
bestCandidate
)
;
matches
=
std
:
:
move
(
matchesForCandidate
)
;
}
return
currentCandidate
.
TextDirectiveString
(
)
;
}
}
