#
include
"
DOMIntersectionObserver
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
namespace
mozilla
{
namespace
dom
{
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DOMIntersectionObserverEntry
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
DOMIntersectionObserverEntry
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
DOMIntersectionObserverEntry
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
DOMIntersectionObserverEntry
mOwner
mRootBounds
mBoundingClientRect
mIntersectionRect
mTarget
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
DOMIntersectionObserver
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_ENTRY
(
DOMIntersectionObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
DOMIntersectionObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
DOMIntersectionObserver
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
DOMIntersectionObserver
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
DOMIntersectionObserver
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
DOMIntersectionObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
tmp
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOwner
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCallback
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mRoot
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mQueuedEntries
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
DOMIntersectionObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOwner
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCallback
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRoot
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mQueuedEntries
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
already_AddRefed
<
DOMIntersectionObserver
>
DOMIntersectionObserver
:
:
Constructor
(
const
GlobalObject
&
aGlobal
dom
:
:
IntersectionCallback
&
aCb
ErrorResult
&
aRv
)
{
return
Constructor
(
aGlobal
aCb
IntersectionObserverInit
(
)
aRv
)
;
}
already_AddRefed
<
DOMIntersectionObserver
>
DOMIntersectionObserver
:
:
Constructor
(
const
GlobalObject
&
aGlobal
dom
:
:
IntersectionCallback
&
aCb
const
IntersectionObserverInit
&
aOptions
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
DOMIntersectionObserver
>
observer
=
new
DOMIntersectionObserver
(
window
.
forget
(
)
aCb
)
;
observer
-
>
mRoot
=
aOptions
.
mRoot
;
if
(
!
observer
-
>
SetRootMargin
(
aOptions
.
mRootMargin
)
)
{
aRv
.
ThrowSyntaxError
(
"
rootMargin
must
be
specified
in
pixels
or
percent
.
"
)
;
return
nullptr
;
}
if
(
aOptions
.
mThreshold
.
IsDoubleSequence
(
)
)
{
const
Sequence
<
double
>
&
thresholds
=
aOptions
.
mThreshold
.
GetAsDoubleSequence
(
)
;
observer
-
>
mThresholds
.
SetCapacity
(
thresholds
.
Length
(
)
)
;
for
(
const
auto
&
thresh
:
thresholds
)
{
if
(
thresh
<
0
.
0
|
|
thresh
>
1
.
0
)
{
aRv
.
ThrowTypeError
<
dom
:
:
MSG_THRESHOLD_RANGE_ERROR
>
(
)
;
return
nullptr
;
}
observer
-
>
mThresholds
.
AppendElement
(
thresh
)
;
}
observer
-
>
mThresholds
.
Sort
(
)
;
}
else
{
double
thresh
=
aOptions
.
mThreshold
.
GetAsDouble
(
)
;
if
(
thresh
<
0
.
0
|
|
thresh
>
1
.
0
)
{
aRv
.
ThrowTypeError
<
dom
:
:
MSG_THRESHOLD_RANGE_ERROR
>
(
)
;
return
nullptr
;
}
observer
-
>
mThresholds
.
AppendElement
(
thresh
)
;
}
return
observer
.
forget
(
)
;
}
bool
DOMIntersectionObserver
:
:
SetRootMargin
(
const
nsAString
&
aString
)
{
return
Servo_IntersectionObserverRootMargin_Parse
(
&
aString
&
mRootMargin
)
;
}
void
DOMIntersectionObserver
:
:
GetRootMargin
(
DOMString
&
aRetVal
)
{
nsString
&
retVal
=
aRetVal
;
Servo_IntersectionObserverRootMargin_ToString
(
&
mRootMargin
&
retVal
)
;
}
void
DOMIntersectionObserver
:
:
GetThresholds
(
nsTArray
<
double
>
&
aRetVal
)
{
aRetVal
=
mThresholds
;
}
void
DOMIntersectionObserver
:
:
Observe
(
Element
&
aTarget
)
{
if
(
mObservationTargets
.
Contains
(
&
aTarget
)
)
{
return
;
}
aTarget
.
RegisterIntersectionObserver
(
this
)
;
mObservationTargets
.
AppendElement
(
&
aTarget
)
;
Connect
(
)
;
if
(
mDocument
)
{
if
(
nsPresContext
*
pc
=
mDocument
-
>
GetPresContext
(
)
)
{
pc
-
>
RefreshDriver
(
)
-
>
IntersectionObservationAdded
(
)
;
}
}
}
void
DOMIntersectionObserver
:
:
Unobserve
(
Element
&
aTarget
)
{
if
(
!
mObservationTargets
.
Contains
(
&
aTarget
)
)
{
return
;
}
if
(
mObservationTargets
.
Length
(
)
=
=
1
)
{
Disconnect
(
)
;
return
;
}
mObservationTargets
.
RemoveElement
(
&
aTarget
)
;
aTarget
.
UnregisterIntersectionObserver
(
this
)
;
}
void
DOMIntersectionObserver
:
:
UnlinkTarget
(
Element
&
aTarget
)
{
mObservationTargets
.
RemoveElement
(
&
aTarget
)
;
if
(
mObservationTargets
.
Length
(
)
=
=
0
)
{
Disconnect
(
)
;
}
}
void
DOMIntersectionObserver
:
:
Connect
(
)
{
if
(
mConnected
)
{
return
;
}
mConnected
=
true
;
if
(
mDocument
)
{
mDocument
-
>
AddIntersectionObserver
(
this
)
;
}
}
void
DOMIntersectionObserver
:
:
Disconnect
(
)
{
if
(
!
mConnected
)
{
return
;
}
mConnected
=
false
;
for
(
size_t
i
=
0
;
i
<
mObservationTargets
.
Length
(
)
;
+
+
i
)
{
Element
*
target
=
mObservationTargets
.
ElementAt
(
i
)
;
target
-
>
UnregisterIntersectionObserver
(
this
)
;
}
mObservationTargets
.
Clear
(
)
;
if
(
mDocument
)
{
mDocument
-
>
RemoveIntersectionObserver
(
this
)
;
}
}
void
DOMIntersectionObserver
:
:
TakeRecords
(
nsTArray
<
RefPtr
<
DOMIntersectionObserverEntry
>
>
&
aRetVal
)
{
aRetVal
.
SwapElements
(
mQueuedEntries
)
;
mQueuedEntries
.
Clear
(
)
;
}
static
Maybe
<
nsRect
>
EdgeInclusiveIntersection
(
const
nsRect
&
aRect
const
nsRect
&
aOtherRect
)
{
nscoord
left
=
std
:
:
max
(
aRect
.
x
aOtherRect
.
x
)
;
nscoord
top
=
std
:
:
max
(
aRect
.
y
aOtherRect
.
y
)
;
nscoord
right
=
std
:
:
min
(
aRect
.
XMost
(
)
aOtherRect
.
XMost
(
)
)
;
nscoord
bottom
=
std
:
:
min
(
aRect
.
YMost
(
)
aOtherRect
.
YMost
(
)
)
;
if
(
left
>
right
|
|
top
>
bottom
)
{
return
Nothing
(
)
;
}
return
Some
(
nsRect
(
left
top
right
-
left
bottom
-
top
)
)
;
}
enum
class
BrowsingContextOrigin
{
Similar
Different
Unknown
}
;
static
BrowsingContextOrigin
SimilarOrigin
(
const
Element
&
aTarget
const
Element
*
aRoot
)
{
if
(
!
aRoot
)
{
return
BrowsingContextOrigin
:
:
Unknown
;
}
nsIPrincipal
*
principal1
=
aTarget
.
NodePrincipal
(
)
;
nsIPrincipal
*
principal2
=
aRoot
-
>
NodePrincipal
(
)
;
if
(
principal1
=
=
principal2
)
{
return
BrowsingContextOrigin
:
:
Similar
;
}
nsAutoCString
baseDomain1
;
nsAutoCString
baseDomain2
;
if
(
NS_FAILED
(
principal1
-
>
GetBaseDomain
(
baseDomain1
)
)
|
|
NS_FAILED
(
principal2
-
>
GetBaseDomain
(
baseDomain2
)
)
)
{
return
BrowsingContextOrigin
:
:
Different
;
}
return
baseDomain1
=
=
baseDomain2
?
BrowsingContextOrigin
:
:
Similar
:
BrowsingContextOrigin
:
:
Different
;
}
static
Document
*
GetTopLevelDocument
(
const
Document
&
aDocument
)
{
BrowsingContext
*
browsingContext
=
aDocument
.
GetBrowsingContext
(
)
;
if
(
!
browsingContext
)
{
return
nullptr
;
}
nsPIDOMWindowOuter
*
topWindow
=
browsingContext
-
>
Top
(
)
-
>
GetDOMWindow
(
)
;
if
(
!
topWindow
)
{
return
nullptr
;
}
return
topWindow
-
>
GetExtantDoc
(
)
;
}
static
Maybe
<
nsRect
>
ComputeTheIntersection
(
nsIFrame
*
aTarget
nsIFrame
*
aRoot
const
nsRect
&
aRootBounds
)
{
nsIFrame
*
target
=
aTarget
;
Maybe
<
nsRect
>
intersectionRect
=
Some
(
target
-
>
GetRectRelativeToSelf
(
)
)
;
nsIFrame
*
containerFrame
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
target
)
;
while
(
containerFrame
&
&
containerFrame
!
=
aRoot
)
{
if
(
containerFrame
-
>
IsScrollFrame
(
)
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
containerFrame
)
;
nsRect
subFrameRect
=
scrollFrame
-
>
GetScrollPortRect
(
)
;
nsRect
intersectionRectRelativeToContainer
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
target
intersectionRect
.
value
(
)
containerFrame
)
;
intersectionRect
=
EdgeInclusiveIntersection
(
intersectionRectRelativeToContainer
subFrameRect
)
;
if
(
!
intersectionRect
)
{
return
Nothing
(
)
;
}
target
=
containerFrame
;
}
containerFrame
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
containerFrame
)
;
}
MOZ_ASSERT
(
intersectionRect
)
;
nsRect
intersectionRectRelativeToRoot
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
target
intersectionRect
.
value
(
)
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
aRoot
)
)
;
intersectionRect
=
EdgeInclusiveIntersection
(
intersectionRectRelativeToRoot
aRootBounds
)
;
if
(
intersectionRect
.
isNothing
(
)
)
{
return
Nothing
(
)
;
}
nsRect
rect
=
intersectionRect
.
value
(
)
;
if
(
aTarget
-
>
PresContext
(
)
!
=
aRoot
-
>
PresContext
(
)
)
{
if
(
nsIFrame
*
rootScrollFrame
=
aTarget
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
)
{
nsLayoutUtils
:
:
TransformRect
(
aRoot
rootScrollFrame
rect
)
;
}
}
return
Some
(
rect
)
;
}
void
DOMIntersectionObserver
:
:
Update
(
Document
*
aDocument
DOMHighResTimeStamp
time
)
{
nsRect
rootRect
;
nsIFrame
*
rootFrame
=
nullptr
;
Element
*
root
=
mRoot
;
if
(
mRoot
)
{
if
(
(
rootFrame
=
mRoot
-
>
GetPrimaryFrame
(
)
)
)
{
nsRect
rootRectRelativeToRootFrame
;
if
(
rootFrame
-
>
IsScrollFrame
(
)
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
rootFrame
)
;
rootRectRelativeToRootFrame
=
scrollFrame
-
>
GetScrollPortRect
(
)
;
}
else
{
rootRectRelativeToRootFrame
=
rootFrame
-
>
GetRectRelativeToSelf
(
)
;
}
nsIFrame
*
containingBlock
=
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
rootFrame
)
;
rootRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
rootFrame
rootRectRelativeToRootFrame
containingBlock
)
;
}
}
else
if
(
Document
*
topLevelDocument
=
GetTopLevelDocument
(
*
aDocument
)
)
{
if
(
PresShell
*
presShell
=
topLevelDocument
-
>
GetPresShell
(
)
)
{
rootFrame
=
presShell
-
>
GetRootScrollFrame
(
)
;
if
(
rootFrame
)
{
root
=
rootFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
rootFrame
)
;
rootRect
=
scrollFrame
-
>
GetScrollPortRect
(
)
;
}
}
}
nsMargin
rootMargin
;
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
nscoord
basis
=
side
=
=
eSideTop
|
|
side
=
=
eSideBottom
?
rootRect
.
Height
(
)
:
rootRect
.
Width
(
)
;
rootMargin
.
Side
(
side
)
=
mRootMargin
.
Get
(
side
)
.
Resolve
(
basis
NSToCoordRoundWithClamp
)
;
}
for
(
Element
*
target
:
mObservationTargets
)
{
nsIFrame
*
targetFrame
=
target
-
>
GetPrimaryFrame
(
)
;
if
(
mRoot
&
&
mRoot
-
>
OwnerDoc
(
)
!
=
target
-
>
OwnerDoc
(
)
)
{
continue
;
}
nsRect
rootBounds
;
if
(
rootFrame
&
&
targetFrame
)
{
rootBounds
=
rootRect
;
}
BrowsingContextOrigin
origin
=
SimilarOrigin
(
*
target
root
)
;
if
(
origin
=
=
BrowsingContextOrigin
:
:
Similar
)
{
rootBounds
.
Inflate
(
rootMargin
)
;
}
Maybe
<
nsRect
>
intersectionRect
;
nsRect
targetRect
;
if
(
targetFrame
&
&
rootFrame
)
{
if
(
mRoot
&
&
!
nsLayoutUtils
:
:
IsProperAncestorFrameCrossDoc
(
rootFrame
targetFrame
)
)
{
continue
;
}
targetRect
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
targetFrame
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
targetFrame
)
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
;
intersectionRect
=
ComputeTheIntersection
(
targetFrame
rootFrame
rootBounds
)
;
}
int64_t
targetArea
=
(
int64_t
)
targetRect
.
Width
(
)
*
(
int64_t
)
targetRect
.
Height
(
)
;
int64_t
intersectionArea
=
!
intersectionRect
?
0
:
(
int64_t
)
intersectionRect
-
>
Width
(
)
*
(
int64_t
)
intersectionRect
-
>
Height
(
)
;
const
bool
isIntersecting
=
intersectionRect
.
isSome
(
)
;
double
intersectionRatio
;
if
(
targetArea
>
0
.
0
)
{
intersectionRatio
=
std
:
:
min
(
(
double
)
intersectionArea
/
(
double
)
targetArea
1
.
0
)
;
}
else
{
intersectionRatio
=
isIntersecting
?
1
.
0
:
0
.
0
;
}
int32_t
thresholdIndex
=
-
1
;
if
(
isIntersecting
)
{
thresholdIndex
=
mThresholds
.
IndexOfFirstElementGt
(
intersectionRatio
)
;
if
(
thresholdIndex
=
=
0
)
{
thresholdIndex
=
-
1
;
}
}
if
(
target
-
>
UpdateIntersectionObservation
(
this
thresholdIndex
)
)
{
QueueIntersectionObserverEntry
(
target
time
origin
=
=
BrowsingContextOrigin
:
:
Similar
?
Some
(
rootBounds
)
:
Nothing
(
)
targetRect
intersectionRect
intersectionRatio
)
;
}
}
}
void
DOMIntersectionObserver
:
:
QueueIntersectionObserverEntry
(
Element
*
aTarget
DOMHighResTimeStamp
time
const
Maybe
<
nsRect
>
&
aRootRect
const
nsRect
&
aTargetRect
const
Maybe
<
nsRect
>
&
aIntersectionRect
double
aIntersectionRatio
)
{
RefPtr
<
DOMRect
>
rootBounds
;
if
(
aRootRect
.
isSome
(
)
)
{
rootBounds
=
new
DOMRect
(
this
)
;
rootBounds
-
>
SetLayoutRect
(
aRootRect
.
value
(
)
)
;
}
RefPtr
<
DOMRect
>
boundingClientRect
=
new
DOMRect
(
this
)
;
boundingClientRect
-
>
SetLayoutRect
(
aTargetRect
)
;
RefPtr
<
DOMRect
>
intersectionRect
=
new
DOMRect
(
this
)
;
if
(
aIntersectionRect
.
isSome
(
)
)
{
intersectionRect
-
>
SetLayoutRect
(
aIntersectionRect
.
value
(
)
)
;
}
RefPtr
<
DOMIntersectionObserverEntry
>
entry
=
new
DOMIntersectionObserverEntry
(
this
time
rootBounds
.
forget
(
)
boundingClientRect
.
forget
(
)
intersectionRect
.
forget
(
)
aIntersectionRect
.
isSome
(
)
aTarget
aIntersectionRatio
)
;
mQueuedEntries
.
AppendElement
(
entry
.
forget
(
)
)
;
}
void
DOMIntersectionObserver
:
:
Notify
(
)
{
if
(
!
mQueuedEntries
.
Length
(
)
)
{
return
;
}
Sequence
<
OwningNonNull
<
DOMIntersectionObserverEntry
>
>
entries
;
if
(
entries
.
SetCapacity
(
mQueuedEntries
.
Length
(
)
mozilla
:
:
fallible
)
)
{
for
(
size_t
i
=
0
;
i
<
mQueuedEntries
.
Length
(
)
;
+
+
i
)
{
RefPtr
<
DOMIntersectionObserverEntry
>
next
=
mQueuedEntries
[
i
]
;
*
entries
.
AppendElement
(
mozilla
:
:
fallible
)
=
next
;
}
}
mQueuedEntries
.
Clear
(
)
;
RefPtr
<
dom
:
:
IntersectionCallback
>
callback
(
mCallback
)
;
callback
-
>
Call
(
this
entries
*
this
)
;
}
}
}
