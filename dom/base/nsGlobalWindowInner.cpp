nsGlobalWindowInner
:
:
InnerWindowByIdTable
*
nsGlobalWindowInner
:
:
sInnerWindowsById
=
nullptr
;
class
nsGlobalWindowObserver
final
:
public
nsIObserver
public
nsIInterfaceRequestor
public
StorageNotificationObserver
{
public
:
explicit
nsGlobalWindowObserver
(
nsGlobalWindowInner
*
aWindow
)
:
mWindow
(
aWindow
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
if
(
!
mWindow
)
return
NS_OK
;
return
mWindow
-
>
Observe
(
aSubject
aTopic
aData
)
;
}
void
Forget
(
)
{
mWindow
=
nullptr
;
}
NS_IMETHOD
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
override
{
if
(
mWindow
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMWindow
)
)
&
&
mWindow
)
{
return
mWindow
-
>
QueryInterface
(
aIID
aResult
)
;
}
return
NS_NOINTERFACE
;
}
void
ObserveStorageNotification
(
StorageEvent
*
aEvent
const
char16_t
*
aStorageType
bool
aPrivateBrowsing
)
override
{
if
(
mWindow
)
{
mWindow
-
>
ObserveStorageNotification
(
aEvent
aStorageType
aPrivateBrowsing
)
;
}
}
nsIPrincipal
*
GetPrincipal
(
)
const
override
{
return
mWindow
?
mWindow
-
>
GetPrincipal
(
)
:
nullptr
;
}
bool
IsPrivateBrowsing
(
)
const
override
{
return
mWindow
?
mWindow
-
>
IsPrivateBrowsing
(
)
:
false
;
}
nsIEventTarget
*
GetEventTarget
(
)
const
override
{
return
mWindow
?
mWindow
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
:
nullptr
;
}
private
:
~
nsGlobalWindowObserver
(
)
=
default
;
nsGlobalWindowInner
*
MOZ_NON_OWNING_REF
mWindow
;
}
;
NS_IMPL_ISUPPORTS
(
nsGlobalWindowObserver
nsIObserver
nsIInterfaceRequestor
)
class
IdleRequestExecutor
;
class
IdleRequestExecutorTimeoutHandler
final
:
public
TimeoutHandler
{
public
:
explicit
IdleRequestExecutorTimeoutHandler
(
IdleRequestExecutor
*
aExecutor
)
:
mExecutor
(
aExecutor
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
IdleRequestExecutorTimeoutHandler
TimeoutHandler
)
nsresult
Call
(
)
override
;
private
:
~
IdleRequestExecutorTimeoutHandler
(
)
override
{
}
RefPtr
<
IdleRequestExecutor
>
mExecutor
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
IdleRequestExecutorTimeoutHandler
TimeoutHandler
mExecutor
)
NS_IMPL_ADDREF_INHERITED
(
IdleRequestExecutorTimeoutHandler
TimeoutHandler
)
NS_IMPL_RELEASE_INHERITED
(
IdleRequestExecutorTimeoutHandler
TimeoutHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IdleRequestExecutorTimeoutHandler
)
NS_INTERFACE_MAP_END_INHERITING
(
TimeoutHandler
)
class
IdleRequestExecutor
final
:
public
nsIRunnable
public
nsICancelableRunnable
public
nsINamed
public
nsIIdleRunnable
{
public
:
explicit
IdleRequestExecutor
(
nsGlobalWindowInner
*
aWindow
)
:
mDispatched
(
false
)
mDeadline
(
TimeStamp
:
:
Now
(
)
)
mWindow
(
aWindow
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
-
>
IsInnerWindow
(
)
)
;
mIdlePeriodLimit
=
{
mDeadline
mWindow
-
>
LastIdleRequestHandle
(
)
}
;
mDelayedExecutorDispatcher
=
new
IdleRequestExecutorTimeoutHandler
(
this
)
;
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
IdleRequestExecutor
nsIRunnable
)
NS_DECL_NSIRUNNABLE
NS_DECL_NSINAMED
nsresult
Cancel
(
)
override
;
void
SetDeadline
(
TimeStamp
aDeadline
)
override
;
bool
IsCancelled
(
)
const
{
return
!
mWindow
|
|
mWindow
-
>
AsInner
(
)
-
>
InnerObjectsFreed
(
)
;
}
bool
IneligibleForCurrentIdlePeriod
(
IdleRequest
*
aRequest
)
const
{
return
aRequest
-
>
Handle
(
)
>
=
mIdlePeriodLimit
.
mLastRequestIdInIdlePeriod
&
&
TimeStamp
:
:
Now
(
)
<
=
mIdlePeriodLimit
.
mEndOfIdlePeriod
;
}
void
MaybeUpdateIdlePeriodLimit
(
)
;
void
MaybeDispatch
(
TimeStamp
aDelayUntil
=
TimeStamp
(
)
)
;
void
ScheduleDispatch
(
)
;
private
:
struct
IdlePeriodLimit
{
TimeStamp
mEndOfIdlePeriod
;
uint32_t
mLastRequestIdInIdlePeriod
;
}
;
void
DelayedDispatch
(
uint32_t
aDelay
)
;
~
IdleRequestExecutor
(
)
override
{
}
bool
mDispatched
;
TimeStamp
mDeadline
;
IdlePeriodLimit
mIdlePeriodLimit
;
RefPtr
<
nsGlobalWindowInner
>
mWindow
;
nsCOMPtr
<
nsITimeoutHandler
>
mDelayedExecutorDispatcher
;
Maybe
<
int32_t
>
mDelayedExecutorHandle
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDelayedExecutorDispatcher
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDelayedExecutorDispatcher
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IdleRequestExecutor
)
NS_INTERFACE_MAP_ENTRY
(
nsIRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsICancelableRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY
(
nsIIdleRunnable
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIRunnable
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP
IdleRequestExecutor
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignASCII
(
"
IdleRequestExecutor
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
IdleRequestExecutor
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDispatched
=
false
;
if
(
mWindow
)
{
return
mWindow
-
>
ExecuteIdleRequest
(
mDeadline
)
;
}
return
NS_OK
;
}
nsresult
IdleRequestExecutor
:
:
Cancel
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mDelayedExecutorHandle
&
&
mWindow
)
{
mWindow
-
>
AsInner
(
)
-
>
TimeoutManager
(
)
.
ClearTimeout
(
mDelayedExecutorHandle
.
value
(
)
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
)
;
}
mWindow
=
nullptr
;
return
NS_OK
;
}
void
IdleRequestExecutor
:
:
SetDeadline
(
TimeStamp
aDeadline
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mWindow
)
{
return
;
}
mDeadline
=
aDeadline
;
}
void
IdleRequestExecutor
:
:
MaybeUpdateIdlePeriodLimit
(
)
{
if
(
TimeStamp
:
:
Now
(
)
>
mIdlePeriodLimit
.
mEndOfIdlePeriod
)
{
mIdlePeriodLimit
=
{
mDeadline
mWindow
-
>
LastIdleRequestHandle
(
)
}
;
}
}
void
IdleRequestExecutor
:
:
MaybeDispatch
(
TimeStamp
aDelayUntil
)
{
if
(
mDispatched
|
|
IsCancelled
(
)
)
{
return
;
}
mDispatched
=
true
;
nsPIDOMWindowOuter
*
outer
=
mWindow
-
>
GetOuterWindow
(
)
;
if
(
outer
&
&
outer
-
>
AsOuter
(
)
-
>
IsBackground
(
)
)
{
DelayedDispatch
(
0
)
;
return
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
aDelayUntil
|
|
aDelayUntil
<
now
)
{
ScheduleDispatch
(
)
;
return
;
}
TimeDuration
delay
=
aDelayUntil
-
now
;
DelayedDispatch
(
static_cast
<
uint32_t
>
(
delay
.
ToMilliseconds
(
)
)
)
;
}
void
IdleRequestExecutor
:
:
ScheduleDispatch
(
)
{
MOZ_ASSERT
(
mWindow
)
;
mDelayedExecutorHandle
=
Nothing
(
)
;
RefPtr
<
IdleRequestExecutor
>
request
=
this
;
NS_IdleDispatchToCurrentThread
(
request
.
forget
(
)
)
;
}
void
IdleRequestExecutor
:
:
DelayedDispatch
(
uint32_t
aDelay
)
{
MOZ_ASSERT
(
mWindow
)
;
MOZ_ASSERT
(
mDelayedExecutorHandle
.
isNothing
(
)
)
;
int32_t
handle
;
mWindow
-
>
AsInner
(
)
-
>
TimeoutManager
(
)
.
SetTimeout
(
mDelayedExecutorDispatcher
aDelay
false
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
&
handle
)
;
mDelayedExecutorHandle
=
Some
(
handle
)
;
}
nsresult
IdleRequestExecutorTimeoutHandler
:
:
Call
(
)
{
if
(
!
mExecutor
-
>
IsCancelled
(
)
)
{
mExecutor
-
>
ScheduleDispatch
(
)
;
}
return
NS_OK
;
}
void
nsGlobalWindowInner
:
:
ScheduleIdleRequestDispatch
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mIdleRequestExecutor
)
{
mIdleRequestExecutor
=
new
IdleRequestExecutor
(
AssertInner
(
)
)
;
}
mIdleRequestExecutor
-
>
MaybeDispatch
(
)
;
}
void
nsGlobalWindowInner
:
:
SuspendIdleRequests
(
)
{
if
(
mIdleRequestExecutor
)
{
mIdleRequestExecutor
-
>
Cancel
(
)
;
mIdleRequestExecutor
=
nullptr
;
}
}
void
nsGlobalWindowInner
:
:
ResumeIdleRequests
(
)
{
MOZ_ASSERT
(
!
mIdleRequestExecutor
)
;
ScheduleIdleRequestDispatch
(
)
;
}
void
nsGlobalWindowInner
:
:
InsertIdleCallback
(
IdleRequest
*
aRequest
)
{
AssertIsOnMainThread
(
)
;
mIdleRequestCallbacks
.
insertBack
(
aRequest
)
;
aRequest
-
>
AddRef
(
)
;
}
void
nsGlobalWindowInner
:
:
RemoveIdleCallback
(
mozilla
:
:
dom
:
:
IdleRequest
*
aRequest
)
{
AssertIsOnMainThread
(
)
;
if
(
aRequest
-
>
HasTimeout
(
)
)
{
mTimeoutManager
-
>
ClearTimeout
(
aRequest
-
>
GetTimeoutHandle
(
)
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
)
;
}
aRequest
-
>
removeFrom
(
mIdleRequestCallbacks
)
;
aRequest
-
>
Release
(
)
;
}
nsresult
nsGlobalWindowInner
:
:
RunIdleRequest
(
IdleRequest
*
aRequest
DOMHighResTimeStamp
aDeadline
bool
aDidTimeout
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
IdleRequest
>
request
(
aRequest
)
;
RemoveIdleCallback
(
request
)
;
return
request
-
>
IdleRun
(
AsInner
(
)
aDeadline
aDidTimeout
)
;
}
nsresult
nsGlobalWindowInner
:
:
ExecuteIdleRequest
(
TimeStamp
aDeadline
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
IdleRequest
>
request
=
mIdleRequestCallbacks
.
getFirst
(
)
;
if
(
!
request
)
{
return
NS_OK
;
}
if
(
mIdleRequestExecutor
-
>
IneligibleForCurrentIdlePeriod
(
request
)
)
{
mIdleRequestExecutor
-
>
MaybeDispatch
(
aDeadline
)
;
return
NS_OK
;
}
DOMHighResTimeStamp
deadline
=
0
.
0
;
if
(
Performance
*
perf
=
GetPerformance
(
)
)
{
deadline
=
perf
-
>
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
aDeadline
)
;
}
mIdleRequestExecutor
-
>
MaybeUpdateIdlePeriodLimit
(
)
;
nsresult
result
=
RunIdleRequest
(
request
deadline
false
)
;
if
(
mIdleRequestExecutor
)
{
mIdleRequestExecutor
-
>
MaybeDispatch
(
)
;
}
return
result
;
}
class
IdleRequestTimeoutHandler
final
:
public
TimeoutHandler
{
public
:
IdleRequestTimeoutHandler
(
JSContext
*
aCx
IdleRequest
*
aIdleRequest
nsPIDOMWindowInner
*
aWindow
)
:
TimeoutHandler
(
aCx
)
mIdleRequest
(
aIdleRequest
)
mWindow
(
aWindow
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
IdleRequestTimeoutHandler
TimeoutHandler
)
nsresult
Call
(
)
override
{
return
nsGlobalWindowInner
:
:
Cast
(
mWindow
)
-
>
RunIdleRequest
(
mIdleRequest
0
.
0
true
)
;
}
private
:
~
IdleRequestTimeoutHandler
(
)
override
{
}
RefPtr
<
IdleRequest
>
mIdleRequest
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
IdleRequestTimeoutHandler
TimeoutHandler
mIdleRequest
mWindow
)
NS_IMPL_ADDREF_INHERITED
(
IdleRequestTimeoutHandler
TimeoutHandler
)
NS_IMPL_RELEASE_INHERITED
(
IdleRequestTimeoutHandler
TimeoutHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IdleRequestTimeoutHandler
)
NS_INTERFACE_MAP_END_INHERITING
(
TimeoutHandler
)
uint32_t
nsGlobalWindowInner
:
:
RequestIdleCallback
(
JSContext
*
aCx
IdleRequestCallback
&
aCallback
const
IdleRequestOptions
&
aOptions
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
AssertIsOnMainThread
(
)
;
uint32_t
handle
=
mIdleRequestCallbackCounter
+
+
;
RefPtr
<
IdleRequest
>
request
=
new
IdleRequest
(
&
aCallback
handle
)
;
if
(
aOptions
.
mTimeout
.
WasPassed
(
)
)
{
int32_t
timeoutHandle
;
nsCOMPtr
<
nsITimeoutHandler
>
handler
(
new
IdleRequestTimeoutHandler
(
aCx
request
AsInner
(
)
)
)
;
nsresult
rv
=
mTimeoutManager
-
>
SetTimeout
(
handler
aOptions
.
mTimeout
.
Value
(
)
false
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
&
timeoutHandle
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
0
;
}
request
-
>
SetTimeoutHandle
(
timeoutHandle
)
;
}
InsertIdleCallback
(
request
)
;
if
(
!
IsSuspended
(
)
)
{
ScheduleIdleRequestDispatch
(
)
;
}
return
handle
;
}
void
nsGlobalWindowInner
:
:
CancelIdleCallback
(
uint32_t
aHandle
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
for
(
IdleRequest
*
r
:
mIdleRequestCallbacks
)
{
if
(
r
-
>
Handle
(
)
=
=
aHandle
)
{
RemoveIdleCallback
(
r
)
;
break
;
}
}
}
void
nsGlobalWindowInner
:
:
DisableIdleCallbackRequests
(
)
{
if
(
mIdleRequestExecutor
)
{
mIdleRequestExecutor
-
>
Cancel
(
)
;
mIdleRequestExecutor
=
nullptr
;
}
while
(
!
mIdleRequestCallbacks
.
isEmpty
(
)
)
{
RefPtr
<
IdleRequest
>
request
=
mIdleRequestCallbacks
.
getFirst
(
)
;
RemoveIdleCallback
(
request
)
;
}
}
bool
nsGlobalWindowInner
:
:
IsBackgroundInternal
(
)
const
{
return
!
mOuterWindow
|
|
mOuterWindow
-
>
IsBackground
(
)
;
}
nsGlobalWindowInner
:
:
nsGlobalWindowInner
(
nsGlobalWindowOuter
*
aOuterWindow
)
:
nsPIDOMWindow
<
nsISupports
>
(
aOuterWindow
-
>
AsOuter
(
)
)
mIdleFuzzFactor
(
0
)
mIdleCallbackIndex
(
-
1
)
mCurrentlyIdle
(
false
)
mAddActiveEventFuzzTime
(
true
)
mFullScreen
(
false
)
mFullscreenMode
(
false
)
mIsClosed
(
false
)
mInClose
(
false
)
mHavePendingClose
(
false
)
mHadOriginalOpener
(
false
)
mOriginalOpenerWasSecureContext
(
false
)
mIsPopupSpam
(
false
)
mBlockScriptedClosingFlag
(
false
)
mWasOffline
(
false
)
mHasHadSlowScript
(
false
)
mNotifyIdleObserversIdleOnThaw
(
false
)
mNotifyIdleObserversActiveOnThaw
(
false
)
mCreatingInnerWindow
(
false
)
mIsChrome
(
false
)
mCleanMessageManager
(
false
)
mNeedsFocus
(
true
)
mHasFocus
(
false
)
mShowFocusRingForContent
(
false
)
mFocusByKeyOccurred
(
false
)
mHasGamepad
(
false
)
mHasVREvents
(
false
)
mHasVRDisplayActivateEvents
(
false
)
mHasSeenGamepadInput
(
false
)
mNotifiedIDDestroyed
(
false
)
mAllowScriptsToClose
(
false
)
mTopLevelOuterContentWindow
(
false
)
mSuspendDepth
(
0
)
mFreezeDepth
(
0
)
mFocusMethod
(
0
)
mSerial
(
0
)
mIdleRequestCallbackCounter
(
1
)
mIdleRequestExecutor
(
nullptr
)
#
ifdef
DEBUG
mSetOpenerWindowCalled
(
false
)
#
endif
mCleanedUp
(
false
)
mDialogAbuseCount
(
0
)
mAreDialogsEnabled
(
true
)
#
ifdef
DEBUG
mIsValidatingTabGroup
(
false
)
#
endif
mCanSkipCCGeneration
(
0
)
mAutoActivateVRDisplayID
(
0
)
mBeforeUnloadListenerCount
(
0
)
{
AssertIsOnMainThread
(
)
;
nsLayoutStatics
:
:
AddRef
(
)
;
PR_INIT_CLIST
(
this
)
;
if
(
aOuterWindow
)
{
PR_INSERT_AFTER
(
this
aOuterWindow
)
;
mObserver
=
new
nsGlobalWindowObserver
(
AssertInner
(
)
)
;
if
(
mObserver
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
mObserver
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
false
)
;
os
-
>
AddObserver
(
mObserver
MEMORY_PRESSURE_OBSERVER_TOPIC
false
)
;
}
Preferences
:
:
AddStrongObserver
(
mObserver
"
intl
.
accept_languages
"
)
;
RefPtr
<
StorageNotifierService
>
sns
=
StorageNotifierService
:
:
GetOrCreate
(
)
;
if
(
sns
)
{
sns
-
>
Register
(
mObserver
)
;
}
}
}
else
{
MOZ_ASSERT
(
IsFrozen
(
)
)
;
}
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
mTabChild
=
docShell
-
>
GetTabChild
(
)
;
}
}
gRefCnt
+
+
;
EnsurePrefCaches
(
)
;
if
(
gDumpFile
=
=
nullptr
)
{
nsAutoCString
fname
;
Preferences
:
:
GetCString
(
"
browser
.
dom
.
window
.
dump
.
file
"
fname
)
;
if
(
!
fname
.
IsEmpty
(
)
)
{
gDumpFile
=
fopen
(
fname
.
get
(
)
"
wb
+
"
)
;
}
else
{
gDumpFile
=
stdout
;
}
}
mSerial
=
+
+
gSerialCounter
;
#
ifdef
DEBUG
if
(
!
PR_GetEnv
(
"
MOZ_QUIET
"
)
)
{
printf_stderr
(
"
+
+
DOMWINDOW
=
=
%
d
(
%
p
)
[
pid
=
%
d
]
[
serial
=
%
d
]
[
outer
=
%
p
]
\
n
"
gRefCnt
static_cast
<
void
*
>
(
ToCanonicalSupports
(
this
)
)
getpid
(
)
gSerialCounter
static_cast
<
void
*
>
(
ToCanonicalSupports
(
aOuterWindow
)
)
)
;
}
#
endif
MOZ_LOG
(
gDOMLeakPRLog
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
created
outer
=
%
p
"
this
aOuterWindow
)
)
;
MOZ_ASSERT
(
sInnerWindowsById
"
Inner
Windows
hash
table
must
be
created
!
"
)
;
MOZ_ASSERT
(
!
sInnerWindowsById
-
>
Get
(
mWindowID
)
"
This
window
shouldn
'
t
be
in
the
hash
table
yet
!
"
)
;
if
(
sInnerWindowsById
)
{
sInnerWindowsById
-
>
Put
(
mWindowID
AssertInner
(
)
)
;
}
}
#
ifdef
DEBUG
void
nsGlobalWindowInner
:
:
AssertIsOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
#
endif
void
nsGlobalWindowInner
:
:
Init
(
)
{
AssertIsOnMainThread
(
)
;
NS_ASSERTION
(
gDOMLeakPRLog
"
gDOMLeakPRLog
should
have
been
initialized
!
"
)
;
sInnerWindowsById
=
new
InnerWindowByIdTable
(
)
;
}
nsGlobalWindowInner
:
:
~
nsGlobalWindowInner
(
)
{
AssertIsOnMainThread
(
)
;
if
(
IsChromeWindow
(
)
)
{
MOZ_ASSERT
(
mCleanMessageManager
"
chrome
windows
may
always
disconnect
the
msg
manager
"
)
;
DisconnectAndClearGroupMessageManagers
(
)
;
if
(
mChromeFields
.
mMessageManager
)
{
static_cast
<
nsFrameMessageManager
*
>
(
mChromeFields
.
mMessageManager
.
get
(
)
)
-
>
Disconnect
(
)
;
}
mCleanMessageManager
=
false
;
}
DisconnectEventTargetObjects
(
)
;
if
(
IsOuterWindow
(
)
)
{
if
(
nsGlobalWindowOuter
:
:
sOuterWindowsById
)
{
MOZ_ASSERT
(
nsGlobalWindowOuter
:
:
sOuterWindowsById
-
>
Get
(
mWindowID
)
"
This
window
should
be
in
the
hash
table
"
)
;
nsGlobalWindowOuter
:
:
sOuterWindowsById
-
>
Remove
(
mWindowID
)
;
}
}
else
{
if
(
nsGlobalWindowInner
:
:
sInnerWindowsById
)
{
MOZ_ASSERT
(
nsGlobalWindowInner
:
:
sInnerWindowsById
-
>
Get
(
mWindowID
)
"
This
window
should
be
in
the
hash
table
"
)
;
nsGlobalWindowInner
:
:
sInnerWindowsById
-
>
Remove
(
mWindowID
)
;
}
}
-
-
gRefCnt
;
#
ifdef
DEBUG
if
(
!
PR_GetEnv
(
"
MOZ_QUIET
"
)
)
{
nsAutoCString
url
;
if
(
mLastOpenedURI
)
{
url
=
mLastOpenedURI
-
>
GetSpecOrDefault
(
)
;
const
uint32_t
maxURLLength
=
1000
;
if
(
url
.
Length
(
)
>
maxURLLength
)
{
url
.
Truncate
(
maxURLLength
)
;
}
}
nsGlobalWindowOuter
*
outer
=
nsGlobalWindowOuter
:
:
Cast
(
mOuterWindow
)
;
printf_stderr
(
"
-
-
DOMWINDOW
=
=
%
d
(
%
p
)
[
pid
=
%
d
]
[
serial
=
%
d
]
[
outer
=
%
p
]
[
url
=
%
s
]
\
n
"
gRefCnt
static_cast
<
void
*
>
(
ToCanonicalSupports
(
this
)
)
getpid
(
)
mSerial
static_cast
<
void
*
>
(
ToCanonicalSupports
(
outer
)
)
url
.
get
(
)
)
;
}
#
endif
MOZ_LOG
(
gDOMLeakPRLog
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
destroyed
"
this
)
)
;
if
(
IsOuterWindow
(
)
)
{
JSObject
*
proxy
=
GetWrapperMaybeDead
(
)
;
if
(
proxy
)
{
js
:
:
SetProxyReservedSlot
(
proxy
0
js
:
:
PrivateValue
(
nullptr
)
)
;
}
PRCList
*
w
;
while
(
(
w
=
PR_LIST_HEAD
(
this
)
)
!
=
this
)
{
PR_REMOVE_AND_INIT_LINK
(
w
)
;
}
DropOuterWindowDocs
(
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INNERWINDOWS_WITH_MUTATION_LISTENERS
mMutationBits
?
1
:
0
)
;
if
(
mListenerManager
)
{
mListenerManager
-
>
Disconnect
(
)
;
mListenerManager
=
nullptr
;
}
PR_REMOVE_LINK
(
this
)
;
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
outer
)
{
outer
-
>
MaybeClearInnerWindow
(
AssertInner
(
)
)
;
}
}
if
(
mTabGroup
&
&
IsOuterWindow
(
)
)
{
mTabGroup
-
>
Leave
(
AsOuter
(
)
)
;
}
if
(
IsInnerWindow
(
)
)
{
CleanUp
(
)
;
}
else
{
MOZ_ASSERT
(
mCleanedUp
)
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
ac
-
>
RemoveWindowAsListener
(
this
)
;
nsLayoutStatics
:
:
Release
(
)
;
}
void
nsGlobalWindowInner
:
:
AddEventTargetObject
(
DOMEventTargetHelper
*
aObject
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mEventTargetObjects
.
PutEntry
(
aObject
)
;
}
void
nsGlobalWindowInner
:
:
RemoveEventTargetObject
(
DOMEventTargetHelper
*
aObject
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mEventTargetObjects
.
RemoveEntry
(
aObject
)
;
}
void
nsGlobalWindowInner
:
:
DisconnectEventTargetObjects
(
)
{
for
(
auto
iter
=
mEventTargetObjects
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
RefPtr
<
DOMEventTargetHelper
>
target
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
target
-
>
DisconnectFromOwner
(
)
;
}
mEventTargetObjects
.
Clear
(
)
;
}
void
nsGlobalWindowInner
:
:
ShutDown
(
)
{
AssertIsOnMainThread
(
)
;
delete
sInnerWindowsById
;
sInnerWindowsById
=
nullptr
;
}
void
nsGlobalWindowInner
:
:
CleanupCachedXBLHandlers
(
)
{
if
(
mCachedXBLPrototypeHandlers
&
&
mCachedXBLPrototypeHandlers
-
>
Count
(
)
>
0
)
{
mCachedXBLPrototypeHandlers
-
>
Clear
(
)
;
}
}
void
nsGlobalWindowInner
:
:
MaybeForgiveSpamCount
(
)
{
if
(
IsOuterWindow
(
)
&
&
IsPopupSpamWindow
(
)
)
{
SetIsPopupSpamWindow
(
false
)
;
}
}
void
nsGlobalWindowInner
:
:
SetIsPopupSpamWindow
(
bool
aIsPopupSpam
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
mIsPopupSpam
=
aIsPopupSpam
;
if
(
aIsPopupSpam
)
{
+
+
gOpenPopupSpamCount
;
}
else
{
-
-
gOpenPopupSpamCount
;
NS_ASSERTION
(
gOpenPopupSpamCount
>
=
0
"
Unbalanced
decrement
of
gOpenPopupSpamCount
"
)
;
}
}
void
nsGlobalWindowInner
:
:
DropOuterWindowDocs
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
MOZ_ASSERT_IF
(
mDoc
!
mDoc
-
>
EventHandlingSuppressed
(
)
)
;
mDoc
=
nullptr
;
mSuspendedDoc
=
nullptr
;
}
void
nsGlobalWindowInner
:
:
CleanUp
(
)
{
if
(
mCleanedUp
)
return
;
mCleanedUp
=
true
;
StartDying
(
)
;
DisconnectEventTargetObjects
(
)
;
if
(
mObserver
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
mObserver
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
)
;
os
-
>
RemoveObserver
(
mObserver
MEMORY_PRESSURE_OBSERVER_TOPIC
)
;
}
RefPtr
<
StorageNotifierService
>
sns
=
StorageNotifierService
:
:
GetOrCreate
(
)
;
if
(
sns
)
{
sns
-
>
Unregister
(
mObserver
)
;
}
if
(
mIdleService
)
{
mIdleService
-
>
RemoveIdleObserver
(
mObserver
MIN_IDLE_NOTIFICATION_TIME_S
)
;
}
Preferences
:
:
RemoveObserver
(
mObserver
"
intl
.
accept_languages
"
)
;
mObserver
-
>
Forget
(
)
;
}
if
(
mNavigator
)
{
mNavigator
-
>
Invalidate
(
)
;
mNavigator
=
nullptr
;
}
mScreen
=
nullptr
;
mMenubar
=
nullptr
;
mToolbar
=
nullptr
;
mLocationbar
=
nullptr
;
mPersonalbar
=
nullptr
;
mStatusbar
=
nullptr
;
mScrollbars
=
nullptr
;
mHistory
=
nullptr
;
mCustomElements
=
nullptr
;
mFrames
=
nullptr
;
mWindowUtils
=
nullptr
;
mApplicationCache
=
nullptr
;
mIndexedDB
=
nullptr
;
mConsole
=
nullptr
;
mAudioWorklet
=
nullptr
;
mPaintWorklet
=
nullptr
;
mExternal
=
nullptr
;
mMozSelfSupport
=
nullptr
;
mPerformance
=
nullptr
;
#
ifdef
MOZ_WEBSPEECH
mSpeechSynthesis
=
nullptr
;
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
mOrientationChangeObserver
=
nullptr
;
#
endif
ClearControllers
(
)
;
mOpener
=
nullptr
;
if
(
mContext
)
{
mContext
=
nullptr
;
}
mChromeEventHandler
=
nullptr
;
mParentTarget
=
nullptr
;
if
(
IsOuterWindow
(
)
)
{
nsGlobalWindowInner
*
inner
=
GetCurrentInnerWindowInternal
(
)
;
if
(
inner
)
{
inner
-
>
CleanUp
(
)
;
}
}
if
(
IsInnerWindow
(
)
)
{
DisableGamepadUpdates
(
)
;
mHasGamepad
=
false
;
DisableVRUpdates
(
)
;
mHasVREvents
=
false
;
mHasVRDisplayActivateEvents
=
false
;
DisableIdleCallbackRequests
(
)
;
}
else
{
MOZ_ASSERT
(
!
mHasGamepad
)
;
MOZ_ASSERT
(
!
mHasVREvents
)
;
MOZ_ASSERT
(
!
mHasVRDisplayActivateEvents
)
;
}
if
(
mCleanMessageManager
)
{
MOZ_ASSERT
(
mIsChrome
"
only
chrome
should
have
msg
manager
cleaned
"
)
;
if
(
mChromeFields
.
mMessageManager
)
{
static_cast
<
nsFrameMessageManager
*
>
(
mChromeFields
.
mMessageManager
.
get
(
)
)
-
>
Disconnect
(
)
;
}
}
mArguments
=
nullptr
;
CleanupCachedXBLHandlers
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
mAudioContexts
[
i
]
-
>
Shutdown
(
)
;
}
mAudioContexts
.
Clear
(
)
;
if
(
mIdleTimer
)
{
mIdleTimer
-
>
Cancel
(
)
;
mIdleTimer
=
nullptr
;
}
mServiceWorkerRegistrationTable
.
Clear
(
)
;
mIntlUtils
=
nullptr
;
}
void
nsGlobalWindowInner
:
:
ClearControllers
(
)
{
if
(
mControllers
)
{
uint32_t
count
;
mControllers
-
>
GetControllerCount
(
&
count
)
;
while
(
count
-
-
)
{
nsCOMPtr
<
nsIController
>
controller
;
mControllers
-
>
GetControllerAt
(
count
getter_AddRefs
(
controller
)
)
;
nsCOMPtr
<
nsIControllerContext
>
context
=
do_QueryInterface
(
controller
)
;
if
(
context
)
context
-
>
SetCommandContext
(
nullptr
)
;
}
mControllers
=
nullptr
;
}
}
void
nsGlobalWindowInner
:
:
FreeInnerObjects
(
)
{
NS_ASSERTION
(
IsInnerWindow
(
)
"
Don
'
t
free
inner
objects
on
an
outer
window
"
)
;
NotifyDOMWindowDestroyed
(
AssertInner
(
)
)
;
if
(
auto
*
reporter
=
nsWindowMemoryReporter
:
:
Get
(
)
)
{
reporter
-
>
ObserveDOMWindowDetached
(
AssertInner
(
)
)
;
}
mInnerObjectsFreed
=
true
;
mozilla
:
:
dom
:
:
workers
:
:
CancelWorkersForWindow
(
AsInner
(
)
)
;
if
(
mTimeoutManager
)
{
mTimeoutManager
-
>
ClearAllTimeouts
(
)
;
}
if
(
mIdleTimer
)
{
mIdleTimer
-
>
Cancel
(
)
;
mIdleTimer
=
nullptr
;
}
mIdleObservers
.
Clear
(
)
;
DisableIdleCallbackRequests
(
)
;
mChromeEventHandler
=
nullptr
;
if
(
mListenerManager
)
{
mListenerManager
-
>
Disconnect
(
)
;
mListenerManager
=
nullptr
;
}
mHistory
=
nullptr
;
mCustomElements
=
nullptr
;
if
(
mNavigator
)
{
mNavigator
-
>
OnNavigation
(
)
;
mNavigator
-
>
Invalidate
(
)
;
mNavigator
=
nullptr
;
}
if
(
mScreen
)
{
mScreen
=
nullptr
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
mOrientationChangeObserver
=
nullptr
;
#
endif
if
(
mDoc
)
{
mDocumentPrincipal
=
mDoc
-
>
NodePrincipal
(
)
;
mDocumentURI
=
mDoc
-
>
GetDocumentURI
(
)
;
mDocBaseURI
=
mDoc
-
>
GetDocBaseURI
(
)
;
while
(
mDoc
-
>
EventHandlingSuppressed
(
)
)
{
mDoc
-
>
UnsuppressEventHandlingAndFireEvents
(
false
)
;
}
}
mFocusedNode
=
nullptr
;
if
(
mApplicationCache
)
{
static_cast
<
nsDOMOfflineResourceList
*
>
(
mApplicationCache
.
get
(
)
)
-
>
Disconnect
(
)
;
mApplicationCache
=
nullptr
;
}
mIndexedDB
=
nullptr
;
UnlinkHostObjectURIs
(
)
;
NotifyWindowIDDestroyed
(
"
inner
-
window
-
destroyed
"
)
;
CleanupCachedXBLHandlers
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
mAudioContexts
[
i
]
-
>
Shutdown
(
)
;
}
mAudioContexts
.
Clear
(
)
;
DisableGamepadUpdates
(
)
;
mHasGamepad
=
false
;
mGamepads
.
Clear
(
)
;
DisableVRUpdates
(
)
;
mHasVREvents
=
false
;
mHasVRDisplayActivateEvents
=
false
;
mVRDisplays
.
Clear
(
)
;
if
(
mTabChild
)
{
while
(
mBeforeUnloadListenerCount
-
-
>
0
)
{
mTabChild
-
>
BeforeUnloadRemoved
(
)
;
}
}
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsGlobalWindowInner
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMEventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIGlobalObject
)
NS_INTERFACE_MAP_ENTRY
(
nsIScriptGlobalObject
)
NS_INTERFACE_MAP_ENTRY
(
nsIScriptObjectPrincipal
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventTarget
)
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
dom
:
:
EventTarget
)
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsPIDOMWindowInner
)
)
)
{
foundInterface
=
AsInner
(
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
mozIDOMWindow
)
)
&
&
IsInnerWindow
(
)
)
{
foundInterface
=
AsInner
(
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsPIDOMWindowOuter
)
)
)
{
foundInterface
=
AsOuter
(
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
mozIDOMWindowProxy
)
)
&
&
IsOuterWindow
(
)
)
{
foundInterface
=
AsOuter
(
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMChromeWindow
)
)
&
&
IsChromeWindow
(
)
)
{
foundInterface
=
static_cast
<
nsIDOMChromeWindow
*
>
(
this
)
;
}
else
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsGlobalWindowInner
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsGlobalWindowInner
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsGlobalWindowInner
)
if
(
tmp
-
>
IsBlackForCC
(
false
)
)
{
if
(
nsCCUncollectableMarker
:
:
InGeneration
(
tmp
-
>
mCanSkipCCGeneration
)
)
{
return
true
;
}
tmp
-
>
mCanSkipCCGeneration
=
nsCCUncollectableMarker
:
:
sGeneration
;
if
(
tmp
-
>
mCachedXBLPrototypeHandlers
)
{
for
(
auto
iter
=
tmp
-
>
mCachedXBLPrototypeHandlers
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Data
(
)
.
exposeToActiveJS
(
)
;
}
}
if
(
EventListenerManager
*
elm
=
tmp
-
>
GetExistingListenerManager
(
)
)
{
elm
-
>
MarkForCC
(
)
;
}
if
(
tmp
-
>
mTimeoutManager
)
{
tmp
-
>
mTimeoutManager
-
>
UnmarkGrayTimers
(
)
;
}
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsGlobalWindowInner
)
return
tmp
-
>
IsBlackForCC
(
true
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsGlobalWindowInner
)
return
tmp
-
>
IsBlackForCC
(
false
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsGlobalWindowInner
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL
(
nsGlobalWindowInner
)
if
(
MOZ_UNLIKELY
(
cb
.
WantDebugInfo
(
)
)
)
{
char
name
[
512
]
;
nsAutoCString
uri
;
if
(
tmp
-
>
mDoc
&
&
tmp
-
>
mDoc
-
>
GetDocumentURI
(
)
)
{
uri
=
tmp
-
>
mDoc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
}
SprintfLiteral
(
name
"
nsGlobalWindowInner
#
%
"
PRIu64
"
%
s
%
s
"
tmp
-
>
mWindowID
tmp
-
>
IsInnerWindow
(
)
?
"
inner
"
:
"
outer
"
uri
.
get
(
)
)
;
cb
.
DescribeRefCountedNode
(
tmp
-
>
mRefCnt
.
get
(
)
name
)
;
}
else
{
NS_IMPL_CYCLE_COLLECTION_DESCRIBE
(
nsGlobalWindowInner
tmp
-
>
mRefCnt
.
get
(
)
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mControllers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mArguments
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReturnValue
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNavigator
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPerformance
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mServiceWorkerRegistrationTable
)
#
ifdef
MOZ_WEBSPEECH
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSpeechSynthesis
)
#
endif
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOuterWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopInnerWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mListenerManager
)
if
(
tmp
-
>
mTimeoutManager
)
{
tmp
-
>
mTimeoutManager
-
>
ForEachUnorderedTimeout
(
[
&
cb
]
(
Timeout
*
timeout
)
{
cb
.
NoteNativeChild
(
timeout
NS_CYCLE_COLLECTION_PARTICIPANT
(
Timeout
)
)
;
}
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocation
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mHistory
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCustomElements
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocalStorage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSessionStorage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mApplicationCache
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSuspendedDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIndexedDB
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentPrincipal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTabChild
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIdleService
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWakeLock
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIdleRequestExecutor
)
for
(
IdleRequest
*
request
:
tmp
-
>
mIdleRequestCallbacks
)
{
cb
.
NoteNativeChild
(
request
NS_CYCLE_COLLECTION_PARTICIPANT
(
IdleRequest
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIdleObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGamepads
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCacheStorage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mVRDisplays
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeEventHandler
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParentTarget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFrameElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFocusedNode
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMenubar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mToolbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocationbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPersonalbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStatusbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScrollbars
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCrypto
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mU2F
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mConsole
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAudioWorklet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPaintWorklet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mExternal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMozSelfSupport
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIntlUtils
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocShell
)
tmp
-
>
TraverseHostObjectURIs
(
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeFields
.
mBrowserDOMWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeFields
.
mMessageManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeFields
.
mGroupMessageManagers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeFields
.
mOpenerForInitialContentBrowser
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsGlobalWindowInner
)
tmp
-
>
CleanupCachedXBLHandlers
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mContext
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mControllers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mArguments
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReturnValue
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNavigator
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPerformance
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mServiceWorkerRegistrationTable
)
#
ifdef
MOZ_WEBSPEECH
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSpeechSynthesis
)
#
endif
if
(
tmp
-
>
mOuterWindow
)
{
nsGlobalWindowOuter
:
:
Cast
(
tmp
-
>
mOuterWindow
)
-
>
MaybeClearInnerWindow
(
tmp
-
>
AssertInner
(
)
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOuterWindow
)
}
if
(
tmp
-
>
mListenerManager
)
{
tmp
-
>
mListenerManager
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mListenerManager
)
}
tmp
-
>
UpdateTopInnerWindow
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTopInnerWindow
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocation
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mHistory
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCustomElements
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocalStorage
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSessionStorage
)
if
(
tmp
-
>
mApplicationCache
)
{
static_cast
<
nsDOMOfflineResourceList
*
>
(
tmp
-
>
mApplicationCache
.
get
(
)
)
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mApplicationCache
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSuspendedDoc
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIndexedDB
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentPrincipal
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTabChild
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDoc
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIdleService
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWakeLock
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIdleObservers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGamepads
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCacheStorage
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mVRDisplays
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeEventHandler
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParentTarget
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFrameElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFocusedNode
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMenubar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mToolbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocationbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPersonalbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStatusbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mScrollbars
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCrypto
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mU2F
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mConsole
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAudioWorklet
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPaintWorklet
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mExternal
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMozSelfSupport
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIntlUtils
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocShell
)
tmp
-
>
UnlinkHostObjectURIs
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIdleRequestExecutor
)
tmp
-
>
DisableIdleCallbackRequests
(
)
;
if
(
tmp
-
>
IsChromeWindow
(
)
)
{
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeFields
.
mBrowserDOMWindow
)
if
(
tmp
-
>
mChromeFields
.
mMessageManager
)
{
static_cast
<
nsFrameMessageManager
*
>
(
tmp
-
>
mChromeFields
.
mMessageManager
.
get
(
)
)
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeFields
.
mMessageManager
)
}
tmp
-
>
DisconnectAndClearGroupMessageManagers
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeFields
.
mGroupMessageManagers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeFields
.
mOpenerForInitialContentBrowser
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
#
ifdef
DEBUG
void
nsGlobalWindowInner
:
:
RiskyUnlink
(
)
{
NS_CYCLE_COLLECTION_INNERNAME
.
Unlink
(
this
)
;
}
#
endif
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsGlobalWindowInner
)
if
(
tmp
-
>
mCachedXBLPrototypeHandlers
)
{
for
(
auto
iter
=
tmp
-
>
mCachedXBLPrototypeHandlers
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aCallbacks
.
Trace
(
&
iter
.
Data
(
)
"
Cached
XBL
prototype
handler
"
aClosure
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
bool
nsGlobalWindowInner
:
:
IsBlackForCC
(
bool
aTracingNeeded
)
{
if
(
!
nsCCUncollectableMarker
:
:
sGeneration
)
{
return
false
;
}
return
(
nsCCUncollectableMarker
:
:
InGeneration
(
GetMarkedCCGeneration
(
)
)
|
|
HasKnownLiveWrapper
(
)
)
&
&
(
!
aTracingNeeded
|
|
HasNothingToTrace
(
static_cast
<
nsIDOMEventTarget
*
>
(
this
)
)
)
;
}
nsresult
nsGlobalWindowInner
:
:
EnsureScriptEnvironment
(
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
NS_WARNING
(
"
No
outer
window
available
!
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
outer
-
>
GetWrapperPreserveColor
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
!
outer
-
>
GetCurrentInnerWindowInternal
(
)
"
No
cached
wrapper
but
we
have
an
inner
window
?
"
)
;
nsCOMPtr
<
nsIScriptContext
>
context
=
new
nsJSContext
(
!
IsFrame
(
)
outer
)
;
NS_ASSERTION
(
!
outer
-
>
mContext
"
Will
overwrite
mContext
!
"
)
;
context
-
>
WillInitializeContext
(
)
;
nsresult
rv
=
context
-
>
InitContext
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
outer
-
>
mContext
=
context
;
return
NS_OK
;
}
nsIScriptContext
*
nsGlobalWindowInner
:
:
GetScriptContext
(
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
return
nullptr
;
}
return
outer
-
>
mContext
;
}
JSObject
*
nsGlobalWindowInner
:
:
GetGlobalJSObject
(
)
{
return
FastGetGlobalJSObject
(
)
;
}
void
nsGlobalWindowInner
:
:
TraceGlobalJSObject
(
JSTracer
*
aTrc
)
{
TraceWrapper
(
aTrc
"
active
window
global
"
)
;
}
bool
nsGlobalWindowInner
:
:
WouldReuseInnerWindow
(
nsIDocument
*
aNewDocument
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDoc
|
|
!
aNewDocument
)
{
return
false
;
}
if
(
!
mDoc
-
>
IsInitialDocument
(
)
)
{
return
false
;
}
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIURI
>
uri
;
mDoc
-
>
GetDocumentURI
(
)
-
>
CloneIgnoringRef
(
getter_AddRefs
(
uri
)
)
;
NS_ASSERTION
(
NS_IsAboutBlank
(
uri
)
"
How
'
d
this
happen
?
"
)
;
}
#
endif
if
(
mDoc
=
=
aNewDocument
)
{
return
true
;
}
bool
equal
;
if
(
NS_SUCCEEDED
(
mDoc
-
>
NodePrincipal
(
)
-
>
Equals
(
aNewDocument
-
>
NodePrincipal
(
)
&
equal
)
)
&
&
equal
)
{
return
true
;
}
return
false
;
}
void
nsGlobalWindowInner
:
:
SetInitialPrincipalToSubject
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIPrincipal
>
newWindowPrincipal
=
nsContentUtils
:
:
SubjectPrincipalOrSystemIfNativeCaller
(
)
;
if
(
nsContentUtils
:
:
IsExpandedPrincipal
(
newWindowPrincipal
)
|
|
(
nsContentUtils
:
:
IsSystemPrincipal
(
newWindowPrincipal
)
&
&
GetDocShell
(
)
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
)
{
newWindowPrincipal
=
nullptr
;
}
if
(
mDoc
)
{
if
(
!
mDoc
-
>
IsInitialDocument
(
)
)
return
;
if
(
mDoc
-
>
NodePrincipal
(
)
=
=
newWindowPrincipal
)
return
;
#
ifdef
DEBUG
bool
isNullPrincipal
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
mDoc
-
>
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
&
isNullPrincipal
)
)
&
&
isNullPrincipal
)
;
#
endif
}
GetDocShell
(
)
-
>
CreateAboutBlankContentViewer
(
newWindowPrincipal
)
;
if
(
mDoc
)
{
mDoc
-
>
SetIsInitialDocument
(
true
)
;
}
nsCOMPtr
<
nsIPresShell
>
shell
=
GetDocShell
(
)
-
>
GetPresShell
(
)
;
if
(
shell
&
&
!
shell
-
>
DidInitialize
(
)
)
{
nsRect
r
=
shell
-
>
GetPresContext
(
)
-
>
GetVisibleArea
(
)
;
shell
-
>
Initialize
(
r
.
Width
(
)
r
.
Height
(
)
)
;
}
}
PopupControlState
nsGlobalWindowInner
:
:
PushPopupControlState
(
PopupControlState
aState
bool
aForce
)
const
{
return
:
:
PushPopupControlState
(
aState
aForce
)
;
}
void
nsGlobalWindowInner
:
:
PopPopupControlState
(
PopupControlState
aState
)
const
{
:
:
PopPopupControlState
(
aState
)
;
}
PopupControlState
nsGlobalWindowInner
:
:
GetPopupControlState
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
gPopupControlState
;
}
bool
nsGlobalWindowInner
:
:
ComputeIsSecureContext
(
nsIDocument
*
aDocument
SecureContextFlags
aFlags
)
{
MOZ_CRASH
(
"
Outer
Window
Only
-
notbuilding
"
)
;
}
nsresult
nsGlobalWindowInner
:
:
SetNewDocument
(
nsIDocument
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
)
{
NS_PRECONDITION
(
mDocumentPrincipal
=
=
nullptr
"
mDocumentPrincipal
prematurely
set
!
"
)
;
MOZ_ASSERT
(
aDocument
)
;
if
(
!
mOuterWindow
)
{
return
NS_ERROR_NOT_INITIALIZED
;
}
if
(
mOuterWindow
-
>
GetCurrentInnerWindow
(
)
!
=
AsInner
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
return
GetOuterWindowInternal
(
)
-
>
SetNewDocument
(
aDocument
aState
aForceReuseInnerWindow
)
;
}
void
nsGlobalWindowInner
:
:
PreloadLocalStorage
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
Preferences
:
:
GetBool
(
kStorageEnabled
)
)
{
return
;
}
if
(
IsChromeWindow
(
)
)
{
return
;
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
return
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_GetService
(
"
mozilla
.
org
/
dom
/
localStorage
-
manager
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
principal
-
>
GetPrivateBrowsingId
(
)
=
=
0
)
{
nsCOMPtr
<
nsIDOMStorage
>
storage
;
rv
=
storageManager
-
>
PrecacheStorage
(
principal
getter_AddRefs
(
storage
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mLocalStorage
=
static_cast
<
Storage
*
>
(
storage
.
get
(
)
)
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchDOMWindowCreated
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDoc
)
{
return
;
}
nsContentUtils
:
:
DispatchChromeEvent
(
mDoc
mDoc
NS_LITERAL_STRING
(
"
DOMWindowCreated
"
)
true
false
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
&
&
mDoc
)
{
nsAutoString
origin
;
nsIPrincipal
*
principal
=
mDoc
-
>
NodePrincipal
(
)
;
nsContentUtils
:
:
GetUTFOrigin
(
principal
origin
)
;
observerService
-
>
NotifyObservers
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
?
"
chrome
-
document
-
global
-
created
"
:
"
content
-
document
-
global
-
created
"
origin
.
get
(
)
)
;
}
}
void
nsGlobalWindowInner
:
:
ClearStatus
(
)
{
SetStatusOuter
(
EmptyString
(
)
)
;
}
void
nsGlobalWindowInner
:
:
InnerSetNewDocument
(
JSContext
*
aCx
nsIDocument
*
aDocument
)
{
NS_PRECONDITION
(
IsInnerWindow
(
)
"
Must
only
be
called
on
inner
windows
"
)
;
MOZ_ASSERT
(
aDocument
)
;
if
(
MOZ_LOG_TEST
(
gDOMLeakPRLog
LogLevel
:
:
Debug
)
)
{
nsIURI
*
uri
=
aDocument
-
>
GetDocumentURI
(
)
;
MOZ_LOG
(
gDOMLeakPRLog
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
SetNewDocument
%
s
"
this
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
}
mDoc
=
aDocument
;
ClearDocumentDependentSlots
(
aCx
)
;
mFocusedNode
=
nullptr
;
mLocalStorage
=
nullptr
;
mSessionStorage
=
nullptr
;
#
ifdef
DEBUG
mLastOpenedURI
=
aDocument
-
>
GetDocumentURI
(
)
;
#
endif
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INNERWINDOWS_WITH_MUTATION_LISTENERS
mMutationBits
?
1
:
0
)
;
mMutationBits
=
0
;
}
void
nsGlobalWindowInner
:
:
SetDocShell
(
nsIDocShell
*
aDocShell
)
{
MOZ_CRASH
(
"
Outer
Window
Only
"
)
;
}
void
nsGlobalWindowInner
:
:
DetachFromDocShell
(
)
{
NS_ASSERTION
(
IsOuterWindow
(
)
"
Uh
DetachFromDocShell
(
)
called
on
inner
window
!
"
)
;
RefPtr
<
nsGlobalWindowInner
>
inner
;
for
(
PRCList
*
node
=
PR_LIST_HEAD
(
this
)
;
node
!
=
this
;
node
=
PR_NEXT_LINK
(
inner
)
)
{
inner
=
static_cast
<
nsGlobalWindowInner
*
>
(
node
)
;
MOZ_ASSERT
(
inner
-
>
IsInnerWindow
(
)
)
;
MOZ_ASSERT
(
!
inner
-
>
mOuterWindow
|
|
inner
-
>
mOuterWindow
=
=
AsOuter
(
)
)
;
inner
-
>
FreeInnerObjects
(
)
;
}
NotifyWindowIDDestroyed
(
"
outer
-
window
-
destroyed
"
)
;
nsGlobalWindowInner
*
currentInner
=
GetCurrentInnerWindowInternal
(
)
;
if
(
currentInner
)
{
NS_ASSERTION
(
mDoc
"
Must
have
doc
!
"
)
;
mDocumentPrincipal
=
mDoc
-
>
NodePrincipal
(
)
;
mDocumentURI
=
mDoc
-
>
GetDocumentURI
(
)
;
mDocBaseURI
=
mDoc
-
>
GetDocBaseURI
(
)
;
DropOuterWindowDocs
(
)
;
mFocusedNode
=
nullptr
;
}
ClearControllers
(
)
;
mChromeEventHandler
=
nullptr
;
if
(
mContext
)
{
nsJSContext
:
:
PokeGC
(
JS
:
:
gcreason
:
:
SET_DOC_SHELL
(
mTopLevelOuterContentWindow
|
|
mIsChrome
)
?
nullptr
:
GetWrapperPreserveColor
(
)
)
;
mContext
=
nullptr
;
}
mDocShell
=
nullptr
;
NS_ASSERTION
(
!
mNavigator
"
Non
-
null
mNavigator
in
outer
window
!
"
)
;
if
(
mFrames
)
{
mFrames
-
>
SetDocShell
(
nullptr
)
;
}
MaybeForgiveSpamCount
(
)
;
CleanUp
(
)
;
}
void
nsGlobalWindowInner
:
:
SetOpenerWindow
(
nsPIDOMWindowOuter
*
aOpener
bool
aOriginalOpener
)
{
FORWARD_TO_OUTER_VOID
(
SetOpenerWindow
(
aOpener
aOriginalOpener
)
)
;
nsWeakPtr
opener
=
do_GetWeakReference
(
aOpener
)
;
if
(
opener
=
=
mOpener
)
{
return
;
}
NS_ASSERTION
(
!
aOriginalOpener
|
|
!
mSetOpenerWindowCalled
"
aOriginalOpener
is
true
but
not
first
call
to
"
"
SetOpenerWindow
!
"
)
;
NS_ASSERTION
(
aOpener
|
|
!
aOriginalOpener
"
Shouldn
'
t
set
mHadOriginalOpener
if
aOpener
is
null
"
)
;
mOpener
=
opener
.
forget
(
)
;
NS_ASSERTION
(
mOpener
|
|
!
aOpener
"
Opener
must
support
weak
references
!
"
)
;
nsPIDOMWindowOuter
*
contentOpener
=
GetSanitizedOpener
(
aOpener
)
;
mozilla
:
:
Unused
<
<
contentOpener
;
MOZ_DIAGNOSTIC_ASSERT
(
!
contentOpener
|
|
!
mTabGroup
|
|
mTabGroup
=
=
nsGlobalWindowOuter
:
:
Cast
(
contentOpener
)
-
>
mTabGroup
)
;
if
(
aOriginalOpener
)
{
MOZ_ASSERT
(
!
mHadOriginalOpener
"
Probably
too
late
to
call
ComputeIsSecureContext
again
"
)
;
mHadOriginalOpener
=
true
;
mOriginalOpenerWasSecureContext
=
aOpener
-
>
GetCurrentInnerWindow
(
)
-
>
IsSecureContext
(
)
;
}
#
ifdef
DEBUG
mSetOpenerWindowCalled
=
true
;
#
endif
}
void
nsGlobalWindowInner
:
:
UpdateParentTarget
(
)
{
nsCOMPtr
<
Element
>
frameElement
=
GetOuterWindow
(
)
-
>
GetFrameElementInternal
(
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
TryGetTabChildGlobalAsEventTarget
(
frameElement
)
;
if
(
!
eventTarget
)
{
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
topWin
)
{
frameElement
=
topWin
-
>
AsOuter
(
)
-
>
GetFrameElementInternal
(
)
;
eventTarget
=
TryGetTabChildGlobalAsEventTarget
(
frameElement
)
;
}
}
if
(
!
eventTarget
)
{
eventTarget
=
TryGetTabChildGlobalAsEventTarget
(
mChromeEventHandler
)
;
}
if
(
!
eventTarget
)
{
eventTarget
=
mChromeEventHandler
;
}
mParentTarget
=
eventTarget
;
}
EventTarget
*
nsGlobalWindowInner
:
:
GetTargetForDOMEvent
(
)
{
return
GetOuterWindowInternal
(
)
;
}
EventTarget
*
nsGlobalWindowInner
:
:
GetTargetForEventTargetChain
(
)
{
return
IsInnerWindow
(
)
?
this
:
GetCurrentInnerWindowInternal
(
)
;
}
nsresult
nsGlobalWindowInner
:
:
WillHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
NS_PRECONDITION
(
IsInnerWindow
(
)
"
GetEventTargetParent
is
used
on
outer
window
!
?
"
)
;
EventMessage
msg
=
aVisitor
.
mEvent
-
>
mMessage
;
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
mForceContentDispatch
=
true
;
if
(
msg
=
=
eResize
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
if
(
window
)
{
mIsHandlingResizeEvent
=
true
;
}
}
else
if
(
msg
=
=
eMouseDown
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
gMouseDown
=
true
;
}
else
if
(
(
msg
=
=
eMouseUp
|
|
msg
=
=
eDragEnd
)
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
gMouseDown
=
false
;
if
(
gDragServiceDisabled
)
{
nsCOMPtr
<
nsIDragService
>
ds
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
ds
)
{
gDragServiceDisabled
=
false
;
ds
-
>
Unsuppress
(
)
;
}
}
}
aVisitor
.
mParentTarget
=
GetParentTarget
(
)
;
if
(
!
mIdleObservers
.
IsEmpty
(
)
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
&
&
(
aVisitor
.
mEvent
-
>
HasMouseEventMessage
(
)
|
|
aVisitor
.
mEvent
-
>
HasDragEventMessage
(
)
)
)
{
mAddActiveEventFuzzTime
=
false
;
}
return
NS_OK
;
}
bool
nsGlobalWindowInner
:
:
ShouldPromptToBlockDialogs
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ASSERTION
(
!
mDocShell
"
ShouldPromptToBlockDialogs
(
)
called
without
a
top
window
?
"
)
;
return
true
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
!
topWindow
)
{
return
true
;
}
return
topWindow
-
>
DialogsAreBeingAbused
(
)
;
}
bool
nsGlobalWindowInner
:
:
AreDialogsEnabled
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
AreDialogsEnabled
(
)
called
without
a
top
window
?
"
)
;
return
false
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
!
topWindow
)
{
return
false
;
}
if
(
mDocShell
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
bool
isHidden
;
cv
-
>
GetIsHidden
(
&
isHidden
)
;
if
(
isHidden
)
{
return
false
;
}
}
if
(
!
mDoc
|
|
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
)
{
return
false
;
}
return
topWindow
-
>
mAreDialogsEnabled
;
}
bool
nsGlobalWindowInner
:
:
DialogsAreBeingAbused
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
NS_ASSERTION
(
GetScriptableTopInternal
(
)
&
&
GetScriptableTopInternal
(
)
-
>
GetCurrentInnerWindowInternal
(
)
=
=
this
"
DialogsAreBeingAbused
called
with
invalid
window
"
)
;
if
(
mLastDialogQuitTime
.
IsNull
(
)
|
|
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
return
false
;
}
TimeDuration
dialogInterval
(
TimeStamp
:
:
Now
(
)
-
mLastDialogQuitTime
)
;
if
(
dialogInterval
.
ToSeconds
(
)
<
Preferences
:
:
GetInt
(
"
dom
.
successive_dialog_time_limit
"
DEFAULT_SUCCESSIVE_DIALOG_TIME_LIMIT
)
)
{
mDialogAbuseCount
+
+
;
return
GetPopupControlState
(
)
>
openAllowed
|
|
mDialogAbuseCount
>
MAX_SUCCESSIVE_DIALOG_COUNT
;
}
mDialogAbuseCount
=
0
;
return
false
;
}
bool
nsGlobalWindowInner
:
:
ConfirmDialogIfNeeded
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
NS_ENSURE_TRUE
(
mDocShell
false
)
;
nsCOMPtr
<
nsIPromptService
>
promptSvc
=
do_GetService
(
"
mozilla
.
org
/
embedcomp
/
prompt
-
service
;
1
"
)
;
if
(
!
promptSvc
)
{
return
true
;
}
nsAutoPopupStatePusher
popupStatePusher
(
openAbused
true
)
;
bool
disableDialog
=
false
;
nsAutoString
label
title
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogLabel
"
label
)
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogPreventTitle
"
title
)
;
promptSvc
-
>
Confirm
(
AsOuter
(
)
title
.
get
(
)
label
.
get
(
)
&
disableDialog
)
;
if
(
disableDialog
)
{
DisableDialogs
(
)
;
return
false
;
}
return
true
;
}
void
nsGlobalWindowInner
:
:
DisableDialogs
(
)
{
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
DisableDialogs
(
)
called
without
a
top
window
?
"
)
;
return
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWindow
)
{
topWindow
-
>
mAreDialogsEnabled
=
false
;
}
}
void
nsGlobalWindowInner
:
:
EnableDialogs
(
)
{
nsGlobalWindowOuter
*
topWindowOuter
=
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
EnableDialogs
(
)
called
without
a
top
window
?
"
)
;
return
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWindow
)
{
topWindow
-
>
mAreDialogsEnabled
=
true
;
}
}
nsresult
nsGlobalWindowInner
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
NS_PRECONDITION
(
IsInnerWindow
(
)
"
PostHandleEvent
is
used
on
outer
window
!
?
"
)
;
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eResize
:
case
eUnload
:
case
eLoad
:
break
;
default
:
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMEventTarget
>
kungFuDeathGrip1
(
mChromeEventHandler
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip1
;
nsCOMPtr
<
nsIScriptContext
>
kungFuDeathGrip2
(
GetContextInternal
(
)
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip2
;
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eResize
)
{
mIsHandlingResizeEvent
=
false
;
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eUnload
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
IsPresenting
(
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
outer
)
{
outer
-
>
SetAutoActivateVRDisplayID
(
display
-
>
DisplayId
(
)
)
;
}
break
;
}
}
if
(
mDoc
)
{
mDoc
-
>
BindingManager
(
)
-
>
ExecuteDetachedHandlers
(
)
;
}
mIsDocumentLoaded
=
false
;
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eLoad
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
mIsDocumentLoaded
=
true
;
mTimeoutManager
-
>
OnDocumentLoaded
(
)
;
nsCOMPtr
<
Element
>
element
=
GetOuterWindow
(
)
-
>
GetFrameElementInternal
(
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
element
&
&
GetParentInternal
(
)
&
&
docShell
&
&
docShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
aVisitor
.
mEvent
-
>
IsTrusted
(
)
eLoad
)
;
event
.
mFlags
.
mBubbles
=
false
;
event
.
mFlags
.
mCancelable
=
false
;
EventDispatcher
:
:
Dispatch
(
element
nullptr
&
event
nullptr
&
status
)
;
}
uint32_t
autoActivateVRDisplayID
=
0
;
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
outer
)
{
autoActivateVRDisplayID
=
outer
-
>
GetAutoActivateVRDisplayID
(
)
;
}
if
(
autoActivateVRDisplayID
)
{
DispatchVRDisplayActivate
(
autoActivateVRDisplayID
VRDisplayEventReason
:
:
Navigation
)
;
}
}
return
NS_OK
;
}
void
nsGlobalWindowInner
:
:
PoisonOuterWindowProxy
(
JSObject
*
aObject
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
aObject
=
=
GetWrapperMaybeDead
(
)
)
{
PoisonWrapper
(
)
;
}
}
nsresult
nsGlobalWindowInner
:
:
SetArguments
(
nsIArray
*
aArguments
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsresult
rv
;
nsGlobalWindowInner
*
currentInner
=
GetCurrentInnerWindowInternal
(
)
;
mArguments
=
aArguments
;
rv
=
currentInner
-
>
DefineArgumentsProperty
(
aArguments
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
DefineArgumentsProperty
(
nsIArray
*
aArguments
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsIScriptContext
*
ctx
=
GetOuterWindowInternal
(
)
-
>
mContext
;
NS_ENSURE_TRUE
(
aArguments
&
&
ctx
NS_ERROR_NOT_INITIALIZED
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
RootingCx
(
)
GetWrapperPreserveColor
(
)
)
;
return
ctx
-
>
SetProperty
(
obj
"
arguments
"
aArguments
)
;
}
nsIPrincipal
*
nsGlobalWindowInner
:
:
GetPrincipal
(
)
{
if
(
mDoc
)
{
return
mDoc
-
>
NodePrincipal
(
)
;
}
if
(
mDocumentPrincipal
)
{
return
mDocumentPrincipal
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
objPrincipal
=
do_QueryInterface
(
GetParentInternal
(
)
)
;
if
(
objPrincipal
)
{
return
objPrincipal
-
>
GetPrincipal
(
)
;
}
return
nullptr
;
}
bool
nsPIDOMWindowInner
:
:
AddAudioContext
(
AudioContext
*
aAudioContext
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mAudioContexts
.
AppendElement
(
aAudioContext
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
return
docShell
&
&
!
docShell
-
>
GetAllowMedia
(
)
&
&
!
aAudioContext
-
>
IsOffline
(
)
;
}
void
nsPIDOMWindowInner
:
:
RemoveAudioContext
(
AudioContext
*
aAudioContext
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mAudioContexts
.
RemoveElement
(
aAudioContext
)
;
}
void
nsPIDOMWindowInner
:
:
MuteAudioContexts
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
if
(
!
mAudioContexts
[
i
]
-
>
IsOffline
(
)
)
{
mAudioContexts
[
i
]
-
>
Mute
(
)
;
}
}
}
void
nsPIDOMWindowInner
:
:
UnmuteAudioContexts
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
if
(
!
mAudioContexts
[
i
]
-
>
IsOffline
(
)
)
{
mAudioContexts
[
i
]
-
>
Unmute
(
)
;
}
}
}
nsGlobalWindowInner
*
nsGlobalWindowInner
:
:
Window
(
)
{
return
AssertInner
(
)
;
}
nsGlobalWindowInner
*
nsGlobalWindowInner
:
:
Self
(
)
{
return
AssertInner
(
)
;
}
Navigator
*
nsGlobalWindowInner
:
:
Navigator
(
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mNavigator
)
{
mNavigator
=
new
mozilla
:
:
dom
:
:
Navigator
(
AsInner
(
)
)
;
}
return
mNavigator
;
}
nsIDOMNavigator
*
nsGlobalWindowInner
:
:
GetNavigator
(
)
{
FORWARD_TO_INNER
(
GetNavigator
(
)
nullptr
)
;
return
Navigator
(
)
;
}
nsScreen
*
nsGlobalWindowInner
:
:
GetScreen
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mScreen
)
{
mScreen
=
nsScreen
:
:
Create
(
AsInner
(
)
)
;
if
(
!
mScreen
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
}
return
mScreen
;
}
nsIDOMScreen
*
nsGlobalWindowInner
:
:
GetScreen
(
)
{
FORWARD_TO_INNER
(
GetScreen
(
)
nullptr
)
;
ErrorResult
dummy
;
nsIDOMScreen
*
screen
=
GetScreen
(
dummy
)
;
dummy
.
SuppressException
(
)
;
return
screen
;
}
nsHistory
*
nsGlobalWindowInner
:
:
GetHistory
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mHistory
)
{
mHistory
=
new
nsHistory
(
AsInner
(
)
)
;
}
return
mHistory
;
}
CustomElementRegistry
*
nsGlobalWindowInner
:
:
CustomElements
(
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mCustomElements
)
{
mCustomElements
=
new
CustomElementRegistry
(
AsInner
(
)
)
;
}
return
mCustomElements
;
}
Performance
*
nsPIDOMWindowInner
:
:
GetPerformance
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
CreatePerformanceObjectIfNeeded
(
)
;
return
mPerformance
;
}
Performance
*
nsGlobalWindowInner
:
:
GetPerformance
(
)
{
return
AsInner
(
)
-
>
GetPerformance
(
)
;
}
void
nsPIDOMWindowInner
:
:
CreatePerformanceObjectIfNeeded
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mPerformance
|
|
!
mDoc
)
{
return
;
}
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDoc
-
>
GetNavigationTiming
(
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
mDoc
-
>
GetChannel
(
)
)
)
;
bool
timingEnabled
=
false
;
if
(
!
timedChannel
|
|
!
NS_SUCCEEDED
(
timedChannel
-
>
GetTimingEnabled
(
&
timingEnabled
)
)
|
|
!
timingEnabled
)
{
timedChannel
=
nullptr
;
}
if
(
timing
)
{
mPerformance
=
Performance
:
:
CreateForMainThread
(
this
timing
timedChannel
)
;
}
}
bool
nsPIDOMWindowInner
:
:
IsSecureContext
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
IsSecureContext
(
)
;
}
bool
nsPIDOMWindowInner
:
:
IsSecureContextIfOpenerIgnored
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
IsSecureContextIfOpenerIgnored
(
)
;
}
void
nsPIDOMWindowInner
:
:
Suspend
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
Suspend
(
)
;
}
void
nsPIDOMWindowInner
:
:
Resume
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
Resume
(
)
;
}
void
nsPIDOMWindowInner
:
:
Freeze
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
Freeze
(
)
;
}
void
nsPIDOMWindowInner
:
:
Thaw
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
Thaw
(
)
;
}
void
nsPIDOMWindowInner
:
:
SyncStateFromParentWindow
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
SyncStateFromParentWindow
(
)
;
}
void
nsGlobalWindowInner
:
:
UpdateTopInnerWindow
(
)
{
if
(
!
IsInnerWindow
(
)
|
|
AsInner
(
)
-
>
IsTopInnerWindow
(
)
|
|
!
mTopInnerWindow
)
{
return
;
}
mTopInnerWindow
-
>
UpdateWebSocketCount
(
-
(
int32_t
)
mNumOfOpenWebSockets
)
;
}
void
nsPIDOMWindowInner
:
:
AddPeerConnection
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
+
+
:
mActivePeerConnections
+
+
;
}
void
nsPIDOMWindowInner
:
:
RemovePeerConnection
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
MOZ_ASSERT
(
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
:
mActivePeerConnections
)
;
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
-
-
:
mActivePeerConnections
-
-
;
}
bool
nsPIDOMWindowInner
:
:
HasActivePeerConnections
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
:
mActivePeerConnections
;
}
bool
nsPIDOMWindowInner
:
:
IsPlayingAudio
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
i
+
+
)
{
if
(
mAudioContexts
[
i
]
-
>
IsRunning
(
)
)
{
return
true
;
}
}
RefPtr
<
AudioChannelService
>
acs
=
AudioChannelService
:
:
Get
(
)
;
if
(
!
acs
)
{
return
false
;
}
auto
outer
=
GetOuterWindow
(
)
;
if
(
!
outer
)
{
return
false
;
}
return
acs
-
>
IsWindowActive
(
outer
)
;
}
bool
nsPIDOMWindowInner
:
:
IsDocumentLoaded
(
)
const
{
return
mIsDocumentLoaded
;
}
mozilla
:
:
dom
:
:
TimeoutManager
&
nsPIDOMWindowInner
:
:
TimeoutManager
(
)
{
return
*
mTimeoutManager
;
}
bool
nsPIDOMWindowInner
:
:
IsRunningTimeout
(
)
{
return
TimeoutManager
(
)
.
IsRunningTimeout
(
)
;
}
void
nsPIDOMWindowInner
:
:
TryToCacheTopInnerWindow
(
)
{
if
(
mHasTriedToCacheTopInnerWindow
)
{
return
;
}
MOZ_ASSERT
(
!
mInnerObjectsFreed
)
;
mHasTriedToCacheTopInnerWindow
=
true
;
nsGlobalWindowInner
*
window
=
nsGlobalWindowInner
:
:
Cast
(
AsInner
(
)
)
;
MOZ_ASSERT
(
window
)
;
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
topOutter
=
window
-
>
GetScriptableTop
(
)
)
{
mTopInnerWindow
=
topOutter
-
>
GetCurrentInnerWindow
(
)
;
}
}
void
nsPIDOMWindowInner
:
:
UpdateActiveIndexedDBTransactionCount
(
int32_t
aDelta
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aDelta
=
=
0
)
{
return
;
}
TabGroup
(
)
-
>
IndexedDBTransactionCounter
(
)
+
=
aDelta
;
}
void
nsPIDOMWindowInner
:
:
UpdateActiveIndexedDBDatabaseCount
(
int32_t
aDelta
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aDelta
=
=
0
)
{
return
;
}
uint32_t
&
counter
=
mTopInnerWindow
?
mTopInnerWindow
-
>
mNumOfIndexedDBDatabases
:
mNumOfIndexedDBDatabases
;
counter
+
=
aDelta
;
TabGroup
(
)
-
>
IndexedDBDatabaseCounter
(
)
+
=
aDelta
;
}
bool
nsPIDOMWindowInner
:
:
HasActiveIndexedDBDatabases
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mTopInnerWindow
?
mTopInnerWindow
-
>
mNumOfIndexedDBDatabases
>
0
:
mNumOfIndexedDBDatabases
>
0
;
}
void
nsPIDOMWindowInner
:
:
UpdateWebSocketCount
(
int32_t
aDelta
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aDelta
=
=
0
)
{
return
;
}
if
(
mTopInnerWindow
&
&
!
IsTopInnerWindow
(
)
)
{
mTopInnerWindow
-
>
UpdateWebSocketCount
(
aDelta
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aDelta
>
0
|
|
(
(
aDelta
+
mNumOfOpenWebSockets
)
<
mNumOfOpenWebSockets
)
)
;
mNumOfOpenWebSockets
+
=
aDelta
;
}
bool
nsPIDOMWindowInner
:
:
HasOpenWebSockets
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mNumOfOpenWebSockets
|
|
(
mTopInnerWindow
&
&
mTopInnerWindow
-
>
mNumOfOpenWebSockets
)
;
}
bool
nsPIDOMWindowInner
:
:
GetAudioCaptured
(
)
const
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
mAudioCaptured
;
}
nsresult
nsPIDOMWindowInner
:
:
SetAudioCapture
(
bool
aCapture
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mAudioCaptured
=
aCapture
;
RefPtr
<
AudioChannelService
>
service
=
AudioChannelService
:
:
GetOrCreate
(
)
;
if
(
service
)
{
service
-
>
SetWindowAudioCaptured
(
GetOuterWindow
(
)
mWindowID
aCapture
)
;
}
return
NS_OK
;
}
#
ifdef
MOZ_WEBSPEECH
SpeechSynthesis
*
nsGlobalWindowInner
:
:
GetSpeechSynthesis
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mSpeechSynthesis
)
{
mSpeechSynthesis
=
new
SpeechSynthesis
(
AsInner
(
)
)
;
}
return
mSpeechSynthesis
;
}
bool
nsGlobalWindowInner
:
:
HasActiveSpeechSynthesis
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mSpeechSynthesis
)
{
return
!
mSpeechSynthesis
-
>
HasEmptyQueue
(
)
;
}
return
false
;
}
#
endif
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetParentOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
;
if
(
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
parent
=
AsOuter
(
)
;
}
else
{
parent
=
GetParent
(
)
;
}
return
parent
.
forget
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetParent
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetParentOuter
(
)
aError
nullptr
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetScriptableParent
(
)
{
FORWARD_TO_OUTER
(
GetScriptableParent
(
)
nullptr
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
GetParentOuter
(
)
;
return
parent
.
get
(
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetScriptableParentOrNull
(
)
{
FORWARD_TO_OUTER
(
GetScriptableParentOrNull
(
)
nullptr
)
;
MOZ_CRASH
(
"
Should
be
in
outer
by
now
"
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetParent
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
parent
;
mDocShell
-
>
GetSameTypeParentIgnoreBrowserBoundaries
(
getter_AddRefs
(
parent
)
)
;
if
(
parent
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
parent
-
>
GetWindow
(
)
;
return
win
.
forget
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
(
AsOuter
(
)
)
;
return
win
.
forget
(
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetScriptableTop
(
)
{
FORWARD_TO_OUTER
(
GetScriptableTop
(
)
nullptr
)
;
MOZ_CRASH
(
"
Outer
window
expected
!
"
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetTop
(
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
void
nsGlobalWindowInner
:
:
GetContentOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
content
=
GetContentInternal
(
aError
aCallerType
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
if
(
content
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
aCx
)
;
aError
=
nsContentUtils
:
:
WrapNative
(
aCx
content
&
val
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
aRetval
.
set
(
&
val
.
toObject
(
)
)
;
return
;
}
aRetval
.
set
(
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
GetContent
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetContentOuter
(
aCx
aRetval
aCallerType
aError
)
aError
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetContentInternal
(
ErrorResult
&
aError
CallerType
aCallerType
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
GetChildWindow
(
NS_LITERAL_STRING
(
"
content
"
)
)
;
if
(
domWindow
)
{
return
domWindow
.
forget
(
)
;
}
if
(
mDocShell
&
&
mDocShell
-
>
GetIsInMozBrowser
(
)
)
{
return
GetTopOuter
(
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
primaryContent
;
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
mDoc
)
{
mDoc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eWindowContentUntrusted
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
baseWin
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
baseWin
)
{
bool
visible
=
false
;
baseWin
-
>
GetVisibility
(
&
visible
)
;
if
(
!
visible
)
{
mDocShell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
primaryContent
)
)
;
}
}
}
if
(
!
primaryContent
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
if
(
!
treeOwner
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
treeOwner
-
>
GetPrimaryContentShell
(
getter_AddRefs
(
primaryContent
)
)
;
}
if
(
!
primaryContent
)
{
return
nullptr
;
}
domWindow
=
primaryContent
-
>
GetWindow
(
)
;
return
domWindow
.
forget
(
)
;
}
MozSelfSupport
*
nsGlobalWindowInner
:
:
GetMozSelfSupport
(
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mMozSelfSupport
)
{
return
mMozSelfSupport
;
}
AutoJSContext
cx
;
GlobalObject
global
(
cx
FastGetGlobalJSObject
(
)
)
;
mMozSelfSupport
=
MozSelfSupport
:
:
Constructor
(
global
cx
aError
)
;
return
mMozSelfSupport
;
}
nsresult
nsGlobalWindowInner
:
:
GetPrompter
(
nsIPrompt
*
*
aPrompt
)
{
if
(
IsInnerWindow
(
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
NS_WARNING
(
"
No
outer
window
available
!
"
)
;
return
NS_ERROR_NOT_INITIALIZED
;
}
return
outer
-
>
GetPrompter
(
aPrompt
)
;
}
if
(
!
mDocShell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIPrompt
>
prompter
(
do_GetInterface
(
mDocShell
)
)
;
NS_ENSURE_TRUE
(
prompter
NS_ERROR_NO_INTERFACE
)
;
prompter
.
forget
(
aPrompt
)
;
return
NS_OK
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetMenubar
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mMenubar
)
{
mMenubar
=
new
MenubarProp
(
AssertInner
(
)
)
;
}
return
mMenubar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetToolbar
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mToolbar
)
{
mToolbar
=
new
ToolbarProp
(
AssertInner
(
)
)
;
}
return
mToolbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetLocationbar
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mLocationbar
)
{
mLocationbar
=
new
LocationbarProp
(
AssertInner
(
)
)
;
}
return
mLocationbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetPersonalbar
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mPersonalbar
)
{
mPersonalbar
=
new
PersonalbarProp
(
AssertInner
(
)
)
;
}
return
mPersonalbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetStatusbar
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mStatusbar
)
{
mStatusbar
=
new
StatusbarProp
(
AssertInner
(
)
)
;
}
return
mStatusbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetScrollbars
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mScrollbars
)
{
mScrollbars
=
new
ScrollbarsProp
(
AssertInner
(
)
)
;
}
return
mScrollbars
;
}
bool
nsGlobalWindowInner
:
:
GetClosedOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
mIsClosed
|
|
!
mDocShell
;
}
bool
nsGlobalWindowInner
:
:
GetClosed
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetClosedOuter
(
)
aError
false
)
;
}
bool
nsGlobalWindowInner
:
:
Closed
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
return
GetClosedOuter
(
)
;
}
nsDOMWindowList
*
nsGlobalWindowInner
:
:
GetWindowList
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mFrames
&
&
mDocShell
)
{
mFrames
=
new
nsDOMWindowList
(
mDocShell
)
;
}
return
mFrames
;
}
already_AddRefed
<
nsIDOMWindowCollection
>
nsGlobalWindowInner
:
:
GetFrames
(
)
{
FORWARD_TO_OUTER
(
GetFrames
(
)
nullptr
)
;
nsCOMPtr
<
nsIDOMWindowCollection
>
frames
=
GetWindowList
(
)
;
return
frames
.
forget
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
IndexedGetterOuter
(
uint32_t
aIndex
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsDOMWindowList
*
windows
=
GetWindowList
(
)
;
NS_ENSURE_TRUE
(
windows
nullptr
)
;
return
windows
-
>
IndexedGetter
(
aIndex
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
IndexedGetter
(
uint32_t
aIndex
)
{
FORWARD_TO_OUTER
(
IndexedGetterOuter
(
aIndex
)
nullptr
)
;
MOZ_CRASH
(
)
;
}
bool
nsGlobalWindowInner
:
:
DoResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
aDesc
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
JSID_IS_STRING
(
aId
)
)
{
return
true
;
}
bool
found
;
if
(
!
WebIDLGlobalNameHash
:
:
DefineIfEnabled
(
aCx
aObj
aId
aDesc
&
found
)
)
{
return
false
;
}
if
(
found
)
{
return
true
;
}
nsresult
rv
=
nsWindowSH
:
:
GlobalResolve
(
AssertInner
(
)
aCx
aObj
aId
aDesc
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Throw
(
aCx
rv
)
;
}
return
true
;
}
bool
nsGlobalWindowInner
:
:
MayResolve
(
jsid
aId
)
{
if
(
!
JSID_IS_STRING
(
aId
)
)
{
return
false
;
}
if
(
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_COMPONENTS
)
)
{
return
true
;
}
if
(
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS
)
|
|
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS_CLASS
)
)
{
return
true
;
}
if
(
WebIDLGlobalNameHash
:
:
MayResolve
(
aId
)
)
{
return
true
;
}
nsScriptNameSpaceManager
*
nameSpaceManager
=
PeekNameSpaceManager
(
)
;
if
(
!
nameSpaceManager
)
{
return
true
;
}
nsAutoString
name
;
AssignJSFlatString
(
name
JSID_TO_FLAT_STRING
(
aId
)
)
;
return
nameSpaceManager
-
>
LookupName
(
name
)
;
}
void
nsGlobalWindowInner
:
:
GetOwnPropertyNames
(
JSContext
*
aCx
JS
:
:
AutoIdVector
&
aNames
bool
aEnumerableOnly
ErrorResult
&
aRv
)
{
if
(
aEnumerableOnly
)
{
return
;
}
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsScriptNameSpaceManager
*
nameSpaceManager
=
GetNameSpaceManager
(
)
;
if
(
nameSpaceManager
)
{
JS
:
:
Rooted
<
JSObject
*
>
wrapper
(
aCx
GetWrapper
(
)
)
;
WebIDLGlobalNameHash
:
:
NameType
nameType
=
js
:
:
IsObjectInContextCompartment
(
wrapper
aCx
)
?
WebIDLGlobalNameHash
:
:
UnresolvedNamesOnly
:
WebIDLGlobalNameHash
:
:
AllNames
;
if
(
!
WebIDLGlobalNameHash
:
:
GetNames
(
aCx
wrapper
nameType
aNames
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
}
for
(
auto
i
=
nameSpaceManager
-
>
GlobalNameIter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
const
GlobalNameMapEntry
*
entry
=
i
.
Get
(
)
;
if
(
nsWindowSH
:
:
NameStructEnabled
(
aCx
AssertInner
(
)
entry
-
>
mKey
entry
-
>
mGlobalName
)
)
{
JSString
*
str
=
JS_AtomizeUCStringN
(
aCx
entry
-
>
mKey
.
BeginReading
(
)
entry
-
>
mKey
.
Length
(
)
)
;
if
(
!
str
|
|
!
aNames
.
append
(
NON_INTEGER_ATOM_TO_JSID
(
str
)
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
return
;
}
}
}
}
}
bool
nsGlobalWindowInner
:
:
IsPrivilegedChromeWindow
(
JSContext
*
aCx
JSObject
*
aObj
)
{
return
xpc
:
:
WindowOrNull
(
aObj
)
-
>
IsChromeWindow
(
)
&
&
nsContentUtils
:
:
ObjectPrincipal
(
aObj
)
=
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
}
bool
nsGlobalWindowInner
:
:
IsRequestIdleCallbackEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
{
return
nsContentUtils
:
:
RequestIdleCallbackEnabled
(
)
|
|
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
;
}
nsIDOMOfflineResourceList
*
nsGlobalWindowInner
:
:
GetApplicationCache
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mApplicationCache
)
{
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
GetDocShell
(
)
)
)
;
if
(
!
webNav
|
|
!
mDoc
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
;
aError
=
webNav
-
>
GetCurrentURI
(
getter_AddRefs
(
uri
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
manifestURI
;
nsContentUtils
:
:
GetOfflineAppManifest
(
mDoc
getter_AddRefs
(
manifestURI
)
)
;
RefPtr
<
nsDOMOfflineResourceList
>
applicationCache
=
new
nsDOMOfflineResourceList
(
manifestURI
uri
mDoc
-
>
NodePrincipal
(
)
AsInner
(
)
)
;
applicationCache
-
>
Init
(
)
;
mApplicationCache
=
applicationCache
;
}
return
mApplicationCache
;
}
already_AddRefed
<
nsIDOMOfflineResourceList
>
nsGlobalWindowInner
:
:
GetApplicationCache
(
)
{
FORWARD_TO_INNER
(
GetApplicationCache
(
)
nullptr
)
;
ErrorResult
dummy
;
nsCOMPtr
<
nsIDOMOfflineResourceList
>
applicationCache
=
GetApplicationCache
(
dummy
)
;
dummy
.
SuppressException
(
)
;
return
applicationCache
.
forget
(
)
;
}
Crypto
*
nsGlobalWindowInner
:
:
GetCrypto
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mCrypto
)
{
mCrypto
=
new
Crypto
(
)
;
mCrypto
-
>
Init
(
this
)
;
}
return
mCrypto
;
}
mozilla
:
:
dom
:
:
U2F
*
nsGlobalWindowInner
:
:
GetU2f
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mU2F
)
{
RefPtr
<
U2F
>
u2f
=
new
U2F
(
AsInner
(
)
)
;
u2f
-
>
Init
(
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
mU2F
=
u2f
;
}
return
mU2F
;
}
nsIControllers
*
nsGlobalWindowInner
:
:
GetControllersOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mControllers
)
{
nsresult
rv
;
mControllers
=
do_CreateInstance
(
kXULControllersCID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIController
>
controller
=
do_CreateInstance
(
NS_WINDOWCONTROLLER_CONTRACTID
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
mControllers
-
>
InsertControllerAt
(
0
controller
)
;
nsCOMPtr
<
nsIControllerContext
>
controllerContext
=
do_QueryInterface
(
controller
)
;
if
(
!
controllerContext
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
controllerContext
-
>
SetCommandContext
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
)
;
}
return
mControllers
;
}
nsIControllers
*
nsGlobalWindowInner
:
:
GetControllers
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetControllersOuter
(
aError
)
aError
nullptr
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetControllers
(
nsIControllers
*
*
aResult
)
{
FORWARD_TO_INNER
(
GetControllers
(
aResult
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
nsCOMPtr
<
nsIControllers
>
controllers
=
GetControllers
(
rv
)
;
controllers
.
forget
(
aResult
)
;
return
rv
.
StealNSResult
(
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetSanitizedOpener
(
nsPIDOMWindowOuter
*
aOpener
)
{
if
(
!
aOpener
)
{
return
nullptr
;
}
nsGlobalWindowOuter
*
win
=
nsGlobalWindowOuter
:
:
Cast
(
aOpener
)
;
if
(
win
-
>
IsChromeWindow
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
openerDocShell
=
aOpener
-
>
GetDocShell
(
)
;
if
(
openerDocShell
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
openerRootItem
;
openerDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
openerRootItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
openerRootDocShell
(
do_QueryInterface
(
openerRootItem
)
)
;
if
(
openerRootDocShell
)
{
uint32_t
appType
;
nsresult
rv
=
openerRootDocShell
-
>
GetAppType
(
&
appType
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
appType
!
=
nsIDocShell
:
:
APP_TYPE_MAIL
)
{
return
aOpener
;
}
}
}
return
nullptr
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetOpenerWindowOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
opener
=
do_QueryReferent
(
mOpener
)
;
if
(
!
opener
)
{
return
nullptr
;
}
if
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
if
(
GetPrincipal
(
)
=
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
&
&
nsGlobalWindowOuter
:
:
Cast
(
opener
)
-
>
GetPrincipal
(
)
!
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
)
{
return
nullptr
;
}
return
opener
;
}
return
GetSanitizedOpener
(
opener
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetOpenerWindow
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetOpenerWindowOuter
(
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
opener
=
GetOpenerWindow
(
aError
)
;
if
(
aError
.
Failed
(
)
|
|
!
opener
)
{
aRetval
.
setNull
(
)
;
return
;
}
aError
=
nsContentUtils
:
:
WrapNative
(
aCx
opener
aRetval
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetOpener
(
)
{
FORWARD_TO_OUTER
(
GetOpener
(
)
nullptr
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
opener
=
GetOpenerWindowOuter
(
)
;
return
opener
.
forget
(
)
;
}
void
nsGlobalWindowInner
:
:
SetOpener
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aOpener
ErrorResult
&
aError
)
{
if
(
!
aOpener
.
isNull
(
)
&
&
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
RedefineProperty
(
aCx
"
opener
"
aOpener
aError
)
;
return
;
}
if
(
!
aOpener
.
isObjectOrNull
(
)
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
nsPIDOMWindowInner
*
win
=
nullptr
;
if
(
aOpener
.
isObject
(
)
)
{
JSObject
*
unwrapped
=
js
:
:
CheckedUnwrap
(
&
aOpener
.
toObject
(
)
false
)
;
if
(
!
unwrapped
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
auto
*
globalWindow
=
xpc
:
:
WindowOrNull
(
unwrapped
)
;
if
(
!
globalWindow
)
{
aError
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
win
=
globalWindow
-
>
AsInner
(
)
;
}
nsPIDOMWindowOuter
*
outer
=
nullptr
;
if
(
win
)
{
if
(
!
win
-
>
IsCurrentInnerWindow
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
outer
=
win
-
>
GetOuterWindow
(
)
;
}
SetOpenerWindow
(
outer
false
)
;
}
void
nsGlobalWindowInner
:
:
GetStatusOuter
(
nsAString
&
aStatus
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
aStatus
=
mStatus
;
}
void
nsGlobalWindowInner
:
:
GetStatus
(
nsAString
&
aStatus
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetStatusOuter
(
aStatus
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetStatusOuter
(
const
nsAString
&
aStatus
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
mStatus
=
aStatus
;
if
(
!
CanSetProperty
(
"
dom
.
disable_window_status_change
"
)
)
{
return
;
}
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
=
GetWebBrowserChrome
(
)
;
if
(
browserChrome
)
{
browserChrome
-
>
SetStatus
(
nsIWebBrowserChrome
:
:
STATUS_SCRIPT
PromiseFlatString
(
aStatus
)
.
get
(
)
)
;
}
}
void
nsGlobalWindowInner
:
:
SetStatus
(
const
nsAString
&
aStatus
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetStatusOuter
(
aStatus
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
GetNameOuter
(
nsAString
&
aName
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
mDocShell
)
{
mDocShell
-
>
GetName
(
aName
)
;
}
}
void
nsGlobalWindowInner
:
:
GetName
(
nsAString
&
aName
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetNameOuter
(
aName
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetNameOuter
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
mDocShell
)
{
aError
=
mDocShell
-
>
SetName
(
aName
)
;
}
}
void
nsGlobalWindowInner
:
:
SetName
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetNameOuter
(
aName
aError
)
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
DevToCSSIntPixels
(
int32_t
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
!
presContext
)
return
px
;
return
presContext
-
>
DevPixelsToIntCSSPixels
(
px
)
;
}
int32_t
nsGlobalWindowInner
:
:
CSSToDevIntPixels
(
int32_t
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
!
presContext
)
return
px
;
return
presContext
-
>
CSSPixelsToDevPixels
(
px
)
;
}
nsIntSize
nsGlobalWindowInner
:
:
DevToCSSIntPixels
(
nsIntSize
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
!
presContext
)
return
px
;
return
nsIntSize
(
presContext
-
>
DevPixelsToIntCSSPixels
(
px
.
width
)
presContext
-
>
DevPixelsToIntCSSPixels
(
px
.
height
)
)
;
}
nsIntSize
nsGlobalWindowInner
:
:
CSSToDevIntPixels
(
nsIntSize
px
)
{
if
(
!
mDocShell
)
return
px
;
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
!
presContext
)
return
px
;
return
nsIntSize
(
presContext
-
>
CSSPixelsToDevPixels
(
px
.
width
)
presContext
-
>
CSSPixelsToDevPixels
(
px
.
height
)
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetInnerSize
(
CSSIntSize
&
aSize
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
EnsureSizeAndPositionUpToDate
(
)
;
NS_ENSURE_STATE
(
mDocShell
)
;
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
RefPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presContext
|
|
!
presShell
)
{
aSize
=
CSSIntSize
(
0
0
)
;
return
NS_OK
;
}
if
(
presShell
-
>
IsScrollPositionClampingScrollPortSizeSet
(
)
)
{
aSize
=
CSSIntRect
:
:
FromAppUnitsRounded
(
presShell
-
>
GetScrollPositionClampingScrollPortSize
(
)
)
;
}
else
{
RefPtr
<
nsViewManager
>
viewManager
=
presShell
-
>
GetViewManager
(
)
;
if
(
viewManager
)
{
viewManager
-
>
FlushDelayedResize
(
false
)
;
}
aSize
=
CSSIntRect
:
:
FromAppUnitsRounded
(
presContext
-
>
GetVisibleArea
(
)
.
Size
(
)
)
;
}
return
NS_OK
;
}
int32_t
nsGlobalWindowInner
:
:
GetInnerWidthOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
CSSIntSize
size
;
aError
=
GetInnerSize
(
size
)
;
return
size
.
width
;
}
int32_t
nsGlobalWindowInner
:
:
GetInnerWidth
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetInnerWidthOuter
(
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetInnerWidth
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetInnerWidth
aValue
aCallerType
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetInnerWidth
(
int32_t
*
aInnerWidth
)
{
FORWARD_TO_INNER
(
GetInnerWidth
(
aInnerWidth
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
*
aInnerWidth
=
GetInnerWidth
(
CallerType
:
:
NonSystem
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerWidthOuter
(
int32_t
aInnerWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
CheckSecurityWidthAndHeight
(
&
aInnerWidth
nullptr
aCallerType
)
;
RefPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
GetIsViewportOverridden
(
)
)
{
nscoord
height
=
0
;
RefPtr
<
nsPresContext
>
presContext
;
presContext
=
presShell
-
>
GetPresContext
(
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
height
=
shellArea
.
Height
(
)
;
SetCSSViewportWidthAndHeight
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aInnerWidth
)
height
)
;
return
;
}
int32_t
height
=
0
;
int32_t
unused
=
0
;
nsCOMPtr
<
nsIBaseWindow
>
docShellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
docShellAsWin
-
>
GetSize
(
&
unused
&
height
)
;
aError
=
SetDocShellWidthAndHeight
(
CSSToDevIntPixels
(
aInnerWidth
)
height
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerWidth
(
int32_t
aInnerWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetInnerWidthOuter
(
aInnerWidth
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerWidth
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetInnerWidth
aValue
"
innerWidth
"
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetInnerHeightOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
CSSIntSize
size
;
aError
=
GetInnerSize
(
size
)
;
return
size
.
height
;
}
int32_t
nsGlobalWindowInner
:
:
GetInnerHeight
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetInnerHeightOuter
(
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetInnerHeight
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetInnerHeight
aValue
aCallerType
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetInnerHeight
(
int32_t
*
aInnerHeight
)
{
FORWARD_TO_INNER
(
GetInnerHeight
(
aInnerHeight
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
*
aInnerHeight
=
GetInnerHeight
(
CallerType
:
:
NonSystem
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerHeightOuter
(
int32_t
aInnerHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
RefPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
GetIsViewportOverridden
(
)
)
{
RefPtr
<
nsPresContext
>
presContext
;
presContext
=
presShell
-
>
GetPresContext
(
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
nscoord
height
=
aInnerHeight
;
nscoord
width
=
shellArea
.
Width
(
)
;
CheckSecurityWidthAndHeight
(
nullptr
&
height
aCallerType
)
;
SetCSSViewportWidthAndHeight
(
width
nsPresContext
:
:
CSSPixelsToAppUnits
(
height
)
)
;
return
;
}
int32_t
height
=
0
;
int32_t
width
=
0
;
nsCOMPtr
<
nsIBaseWindow
>
docShellAsWin
(
do_QueryInterface
(
mDocShell
)
)
;
docShellAsWin
-
>
GetSize
(
&
width
&
height
)
;
CheckSecurityWidthAndHeight
(
nullptr
&
aInnerHeight
aCallerType
)
;
aError
=
SetDocShellWidthAndHeight
(
width
CSSToDevIntPixels
(
aInnerHeight
)
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerHeight
(
int32_t
aInnerHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetInnerHeightOuter
(
aInnerHeight
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerHeight
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetInnerHeight
aValue
"
innerHeight
"
aCallerType
aError
)
;
}
nsIntSize
nsGlobalWindowInner
:
:
GetOuterSize
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
CSSIntSize
size
;
aError
=
GetInnerSize
(
size
)
;
return
nsIntSize
(
size
.
width
size
.
height
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nsIntSize
(
0
0
)
;
}
nsIntSize
sizeDevPixels
;
aError
=
treeOwnerAsWin
-
>
GetSize
(
&
sizeDevPixels
.
width
&
sizeDevPixels
.
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
nsIntSize
(
)
;
}
return
DevToCSSIntPixels
(
sizeDevPixels
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetOuterWidthOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
GetOuterSize
(
aCallerType
aError
)
.
width
;
}
int32_t
nsGlobalWindowInner
:
:
GetOuterWidth
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetOuterWidthOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetOuterWidth
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetOuterWidth
aValue
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetOuterHeightOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
GetOuterSize
(
aCallerType
aError
)
.
height
;
}
int32_t
nsGlobalWindowInner
:
:
GetOuterHeight
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetOuterHeightOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetOuterHeight
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetOuterHeight
aValue
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterSize
(
int32_t
aLengthCSSPixels
bool
aIsWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
CheckSecurityWidthAndHeight
(
aIsWidth
?
&
aLengthCSSPixels
:
nullptr
aIsWidth
?
nullptr
:
&
aLengthCSSPixels
aCallerType
)
;
int32_t
width
height
;
aError
=
treeOwnerAsWin
-
>
GetSize
(
&
width
&
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
int32_t
lengthDevPixels
=
CSSToDevIntPixels
(
aLengthCSSPixels
)
;
if
(
aIsWidth
)
{
width
=
lengthDevPixels
;
}
else
{
height
=
lengthDevPixels
;
}
aError
=
treeOwnerAsWin
-
>
SetSize
(
width
height
true
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterWidthOuter
(
int32_t
aOuterWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
SetOuterSize
(
aOuterWidth
true
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterWidth
(
int32_t
aOuterWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetOuterWidthOuter
(
aOuterWidth
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterWidth
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetOuterWidth
aValue
"
outerWidth
"
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterHeightOuter
(
int32_t
aOuterHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
SetOuterSize
(
aOuterHeight
false
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterHeight
(
int32_t
aOuterHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetOuterHeightOuter
(
aOuterHeight
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterHeight
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetOuterHeight
aValue
"
outerHeight
"
aCallerType
aError
)
;
}
CSSIntPoint
nsGlobalWindowInner
:
:
GetScreenXY
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
CSSIntPoint
(
0
0
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
CSSIntPoint
(
0
0
)
;
}
int32_t
x
=
0
y
=
0
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
!
presContext
)
{
return
CSSIntPoint
(
x
y
)
;
}
nsDeviceContext
*
dc
=
presContext
-
>
DeviceContext
(
)
;
nsRect
screenRect
;
dc
-
>
GetRect
(
screenRect
)
;
LayoutDeviceRect
screenRectDev
=
LayoutDevicePixel
:
:
FromAppUnits
(
screenRect
dc
-
>
AppUnitsPerDevPixel
(
)
)
;
DesktopToLayoutDeviceScale
scale
=
dc
-
>
GetDesktopToDeviceScale
(
)
;
DesktopRect
screenRectDesk
=
screenRectDev
/
scale
;
CSSPoint
cssPt
=
LayoutDevicePoint
(
x
-
screenRectDev
.
x
y
-
screenRectDev
.
y
)
/
presContext
-
>
CSSToDevPixelScale
(
)
;
cssPt
.
x
+
=
screenRectDesk
.
x
;
cssPt
.
y
+
=
screenRectDesk
.
y
;
return
CSSIntPoint
(
NSToIntRound
(
cssPt
.
x
)
NSToIntRound
(
cssPt
.
y
)
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScreenXOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
GetScreenXY
(
aCallerType
aError
)
.
x
;
}
int32_t
nsGlobalWindowInner
:
:
GetScreenX
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScreenXOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetScreenX
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetScreenX
aValue
aCallerType
aError
)
;
}
nsRect
nsGlobalWindowInner
:
:
GetInnerScreenRect
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
nsRect
(
)
;
}
EnsureSizeAndPositionUpToDate
(
)
;
if
(
!
mDocShell
)
{
return
nsRect
(
)
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nsRect
(
)
;
}
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
nsRect
(
)
;
}
return
rootFrame
-
>
GetScreenRectInAppUnits
(
)
;
}
float
nsGlobalWindowInner
:
:
GetMozInnerScreenXOuter
(
CallerType
aCallerType
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
0
.
0
;
}
nsRect
r
=
GetInnerScreenRect
(
)
;
return
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
r
.
x
)
;
}
float
nsGlobalWindowInner
:
:
GetMozInnerScreenX
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetMozInnerScreenXOuter
(
aCallerType
)
aError
0
)
;
}
float
nsGlobalWindowInner
:
:
GetMozInnerScreenYOuter
(
CallerType
aCallerType
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
0
.
0
;
}
nsRect
r
=
GetInnerScreenRect
(
)
;
return
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
r
.
y
)
;
}
float
nsGlobalWindowInner
:
:
GetMozInnerScreenY
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetMozInnerScreenYOuter
(
aCallerType
)
aError
0
)
;
}
double
nsGlobalWindowInner
:
:
GetDevicePixelRatioOuter
(
CallerType
aCallerType
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
1
.
0
;
}
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
!
presContext
)
{
return
1
.
0
;
}
if
(
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
)
{
return
1
.
0
;
}
float
overrideDPPX
=
presContext
-
>
GetOverrideDPPX
(
)
;
if
(
overrideDPPX
>
0
)
{
return
overrideDPPX
;
}
return
double
(
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
/
double
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
double
nsGlobalWindowInner
:
:
GetDevicePixelRatio
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetDevicePixelRatioOuter
(
aCallerType
)
aError
0
.
0
)
;
}
uint64_t
nsGlobalWindowInner
:
:
GetMozPaintCountOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
0
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
return
presShell
?
presShell
-
>
GetPaintCount
(
)
:
0
;
}
uint64_t
nsGlobalWindowInner
:
:
GetMozPaintCount
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetMozPaintCountOuter
(
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
RequestAnimationFrame
(
FrameRequestCallback
&
aCallback
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mDoc
)
{
return
0
;
}
if
(
GetWrapperPreserveColor
(
)
)
{
js
:
:
NotifyAnimationActivity
(
GetWrapperPreserveColor
(
)
)
;
}
int32_t
handle
;
aError
=
mDoc
-
>
ScheduleFrameRequestCallback
(
aCallback
&
handle
)
;
return
handle
;
}
void
nsGlobalWindowInner
:
:
CancelAnimationFrame
(
int32_t
aHandle
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mDoc
)
{
return
;
}
mDoc
-
>
CancelFrameRequestCallback
(
aHandle
)
;
}
already_AddRefed
<
MediaQueryList
>
nsGlobalWindowInner
:
:
MatchMediaOuter
(
const
nsAString
&
aMediaQueryList
CallerType
aCallerType
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDoc
)
{
return
nullptr
;
}
return
mDoc
-
>
MatchMedia
(
aMediaQueryList
aCallerType
)
;
}
already_AddRefed
<
MediaQueryList
>
nsGlobalWindowInner
:
:
MatchMedia
(
const
nsAString
&
aMediaQueryList
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
MatchMediaOuter
(
aMediaQueryList
aCallerType
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenXOuter
(
int32_t
aScreenX
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
x
y
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
CheckSecurityLeftAndTop
(
&
aScreenX
nullptr
aCallerType
)
;
x
=
CSSToDevIntPixels
(
aScreenX
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
x
y
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenX
(
int32_t
aScreenX
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetScreenXOuter
(
aScreenX
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenX
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetScreenX
aValue
"
screenX
"
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScreenYOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
GetScreenXY
(
aCallerType
aError
)
.
y
;
}
int32_t
nsGlobalWindowInner
:
:
GetScreenY
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScreenYOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetScreenY
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetScreenY
aValue
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenYOuter
(
int32_t
aScreenY
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
x
y
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
CheckSecurityLeftAndTop
(
nullptr
&
aScreenY
aCallerType
)
;
y
=
CSSToDevIntPixels
(
aScreenY
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
x
y
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenY
(
int32_t
aScreenY
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetScreenYOuter
(
aScreenY
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenY
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetScreenY
aValue
"
screenY
"
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
CheckSecurityWidthAndHeight
(
int32_t
*
aWidth
int32_t
*
aHeight
CallerType
aCallerType
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
#
ifdef
MOZ_XUL
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
nsContentUtils
:
:
HidePopupsInDocument
(
mDoc
)
;
}
#
endif
if
(
(
aWidth
&
&
*
aWidth
<
100
)
|
|
(
aHeight
&
&
*
aHeight
<
100
)
)
{
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
aWidth
&
&
*
aWidth
<
100
)
{
*
aWidth
=
100
;
}
if
(
aHeight
&
&
*
aHeight
<
100
)
{
*
aHeight
=
100
;
}
}
}
}
nsresult
nsGlobalWindowInner
:
:
SetDocShellWidthAndHeight
(
int32_t
aInnerWidth
int32_t
aInnerHeight
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
NS_ENSURE_TRUE
(
mDocShell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
mDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
NS_ENSURE_TRUE
(
treeOwner
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
treeOwner
-
>
SizeShellTo
(
mDocShell
aInnerWidth
aInnerHeight
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
void
nsGlobalWindowInner
:
:
SetCSSViewportWidthAndHeight
(
nscoord
aInnerWidth
nscoord
aInnerHeight
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
shellArea
.
SetHeight
(
aInnerHeight
)
;
shellArea
.
SetWidth
(
aInnerWidth
)
;
presContext
-
>
SetVisibleArea
(
shellArea
)
;
}
void
nsGlobalWindowInner
:
:
CheckSecurityLeftAndTop
(
int32_t
*
aLeft
int32_t
*
aTop
CallerType
aCallerType
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
#
ifdef
MOZ_XUL
nsContentUtils
:
:
HidePopupsInDocument
(
mDoc
)
;
#
endif
if
(
nsGlobalWindowOuter
*
rootWindow
=
nsGlobalWindowOuter
:
:
Cast
(
GetPrivateRoot
(
)
)
)
{
rootWindow
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwner
=
GetTreeOwnerWindow
(
)
;
nsCOMPtr
<
nsIDOMScreen
>
screen
=
GetScreen
(
)
;
if
(
treeOwner
&
&
screen
)
{
int32_t
screenLeft
screenTop
screenWidth
screenHeight
;
int32_t
winLeft
winTop
winWidth
winHeight
;
treeOwner
-
>
GetPositionAndSize
(
&
winLeft
&
winTop
&
winWidth
&
winHeight
)
;
winLeft
=
DevToCSSIntPixels
(
winLeft
)
;
winTop
=
DevToCSSIntPixels
(
winTop
)
;
winWidth
=
DevToCSSIntPixels
(
winWidth
)
;
winHeight
=
DevToCSSIntPixels
(
winHeight
)
;
screen
-
>
GetAvailLeft
(
&
screenLeft
)
;
screen
-
>
GetAvailWidth
(
&
screenWidth
)
;
screen
-
>
GetAvailHeight
(
&
screenHeight
)
;
#
if
defined
(
XP_MACOSX
)
screen
-
>
GetTop
(
&
screenTop
)
;
#
else
screen
-
>
GetAvailTop
(
&
screenTop
)
;
#
endif
if
(
aLeft
)
{
if
(
screenLeft
+
screenWidth
<
*
aLeft
+
winWidth
)
*
aLeft
=
screenLeft
+
screenWidth
-
winWidth
;
if
(
screenLeft
>
*
aLeft
)
*
aLeft
=
screenLeft
;
}
if
(
aTop
)
{
if
(
screenTop
+
screenHeight
<
*
aTop
+
winHeight
)
*
aTop
=
screenTop
+
screenHeight
-
winHeight
;
if
(
screenTop
>
*
aTop
)
*
aTop
=
screenTop
;
}
}
else
{
if
(
aLeft
)
*
aLeft
=
0
;
if
(
aTop
)
*
aTop
=
0
;
}
}
}
int32_t
nsGlobalWindowInner
:
:
GetScrollBoundaryOuter
(
Side
aSide
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
)
{
return
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
sf
-
>
GetScrollRange
(
)
.
Edge
(
aSide
)
)
;
}
return
0
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMinX
(
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideLeft
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMinY
(
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideTop
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMaxX
(
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideRight
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMaxY
(
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideBottom
)
aError
0
)
;
}
CSSPoint
nsGlobalWindowInner
:
:
GetScrollXY
(
bool
aDoFlush
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
aDoFlush
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
else
{
EnsureSizeAndPositionUpToDate
(
)
;
}
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
!
sf
)
{
return
CSSIntPoint
(
0
0
)
;
}
nsPoint
scrollPos
=
sf
-
>
GetScrollPosition
(
)
;
if
(
scrollPos
!
=
nsPoint
(
0
0
)
&
&
!
aDoFlush
)
{
return
GetScrollXY
(
true
)
;
}
return
CSSPoint
:
:
FromAppUnits
(
scrollPos
)
;
}
double
nsGlobalWindowInner
:
:
GetScrollXOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
GetScrollXY
(
false
)
.
x
;
}
double
nsGlobalWindowInner
:
:
GetScrollX
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollXOuter
(
)
aError
0
)
;
}
double
nsGlobalWindowInner
:
:
GetScrollYOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
GetScrollXY
(
false
)
.
y
;
}
double
nsGlobalWindowInner
:
:
GetScrollY
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollYOuter
(
)
aError
0
)
;
}
uint32_t
nsGlobalWindowInner
:
:
Length
(
)
{
FORWARD_TO_OUTER
(
Length
(
)
0
)
;
nsDOMWindowList
*
windows
=
GetWindowList
(
)
;
return
windows
?
windows
-
>
GetLength
(
)
:
0
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetTopOuter
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
GetScriptableTop
(
)
;
return
top
.
forget
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetTop
(
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetTopOuter
(
)
aError
nullptr
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetChildWindow
(
const
nsAString
&
aName
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
GetDocShell
(
)
)
;
NS_ENSURE_TRUE
(
docShell
nullptr
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
child
;
docShell
-
>
FindChildWithName
(
aName
false
true
nullptr
nullptr
getter_AddRefs
(
child
)
)
;
return
child
?
child
-
>
GetWindow
(
)
:
nullptr
;
}
bool
nsGlobalWindowInner
:
:
DispatchCustomEvent
(
const
nsAString
&
aEventName
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
bool
defaultActionEnabled
=
true
;
nsContentUtils
:
:
DispatchTrustedEvent
(
mDoc
ToSupports
(
this
)
aEventName
true
true
&
defaultActionEnabled
)
;
return
defaultActionEnabled
;
}
bool
nsGlobalWindowInner
:
:
DispatchResizeEvent
(
const
CSSIntSize
&
aSize
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
ErrorResult
res
;
RefPtr
<
Event
>
domEvent
=
mDoc
-
>
CreateEvent
(
NS_LITERAL_STRING
(
"
CustomEvent
"
)
CallerType
:
:
System
res
)
;
if
(
res
.
Failed
(
)
)
{
return
false
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JSAutoCompartment
ac
(
cx
GetWrapperPreserveColor
(
)
)
;
DOMWindowResizeEventDetail
detail
;
detail
.
mWidth
=
aSize
.
width
;
detail
.
mHeight
=
aSize
.
height
;
JS
:
:
Rooted
<
JS
:
:
Value
>
detailValue
(
cx
)
;
if
(
!
ToJSValue
(
cx
detail
&
detailValue
)
)
{
return
false
;
}
CustomEvent
*
customEvent
=
static_cast
<
CustomEvent
*
>
(
domEvent
.
get
(
)
)
;
customEvent
-
>
InitCustomEvent
(
cx
NS_LITERAL_STRING
(
"
DOMWindowResize
"
)
true
true
detailValue
res
)
;
if
(
res
.
Failed
(
)
)
{
return
false
;
}
domEvent
-
>
SetTrusted
(
true
)
;
domEvent
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
nsCOMPtr
<
EventTarget
>
target
=
do_QueryInterface
(
GetOuterWindow
(
)
)
;
domEvent
-
>
SetTarget
(
target
)
;
bool
defaultActionEnabled
=
true
;
target
-
>
DispatchEvent
(
domEvent
&
defaultActionEnabled
)
;
return
defaultActionEnabled
;
}
void
nsGlobalWindowInner
:
:
RefreshCompartmentPrincipal
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
JS_SetCompartmentPrincipals
(
js
:
:
GetObjectCompartment
(
GetWrapperPreserveColor
(
)
)
nsJSPrincipals
:
:
get
(
mDoc
-
>
NodePrincipal
(
)
)
)
;
}
bool
nsGlobalWindowInner
:
:
WindowExists
(
const
nsAString
&
aName
bool
aForceNoOpener
bool
aLookForCallerOnJSStack
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
already_AddRefed
<
nsIWidget
>
nsGlobalWindowInner
:
:
GetMainWidget
(
)
{
FORWARD_TO_OUTER
(
GetMainWidget
(
)
nullptr
)
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
nsCOMPtr
<
nsIWidget
>
widget
;
if
(
treeOwnerAsWin
)
{
treeOwnerAsWin
-
>
GetMainWidget
(
getter_AddRefs
(
widget
)
)
;
}
return
widget
.
forget
(
)
;
}
nsIWidget
*
nsGlobalWindowInner
:
:
GetNearestWidget
(
)
const
{
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
docShell
nullptr
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
nullptr
)
;
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
rootFrame
nullptr
)
;
return
rootFrame
-
>
GetView
(
)
-
>
GetNearestWidget
(
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
SetFullScreenOuter
(
bool
aFullScreen
mozilla
:
:
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
aError
=
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenMode
aFullScreen
)
;
}
void
nsGlobalWindowInner
:
:
SetFullScreen
(
bool
aFullScreen
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetFullScreenOuter
(
aFullScreen
aError
)
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
SetFullScreen
(
bool
aFullScreen
)
{
FORWARD_TO_OUTER
(
SetFullScreen
(
aFullScreen
)
NS_ERROR_NOT_INITIALIZED
)
;
return
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenMode
aFullScreen
)
;
}
nsresult
nsGlobalWindowInner
:
:
SetFullscreenInternal
(
FullscreenReason
aReason
bool
aFullScreen
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
bool
nsGlobalWindowInner
:
:
SetWidgetFullscreen
(
FullscreenReason
aReason
bool
aIsFullscreen
nsIWidget
*
aWidget
nsIScreen
*
aScreen
)
{
MOZ_CRASH
(
"
Only
callable
on
the
outer
window
"
)
;
}
void
nsGlobalWindowInner
:
:
FullscreenWillChange
(
bool
aIsFullscreen
)
{
if
(
aIsFullscreen
)
{
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
willenterfullscreen
"
)
)
;
}
else
{
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
willexitfullscreen
"
)
)
;
}
}
void
nsGlobalWindowInner
:
:
FinishFullscreenChange
(
bool
aIsFullscreen
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
bool
nsGlobalWindowInner
:
:
FullScreen
(
)
const
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
NS_ENSURE_TRUE
(
mDocShell
mFullScreen
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
mDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
rootItem
=
=
mDocShell
)
{
if
(
!
XRE_IsContentProcess
(
)
)
{
return
mFullScreen
;
}
if
(
nsCOMPtr
<
nsIWidget
>
widget
=
GetNearestWidget
(
)
)
{
return
widget
-
>
SizeMode
(
)
=
=
nsSizeMode_Fullscreen
;
}
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
rootItem
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
window
mFullScreen
)
;
return
nsGlobalWindowOuter
:
:
Cast
(
window
)
-
>
FullScreen
(
)
;
}
bool
nsGlobalWindowInner
:
:
GetFullScreenOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
FullScreen
(
)
;
}
bool
nsGlobalWindowInner
:
:
GetFullScreen
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetFullScreenOuter
(
)
aError
false
)
;
}
bool
nsGlobalWindowInner
:
:
GetFullScreen
(
)
{
FORWARD_TO_INNER
(
GetFullScreen
(
)
false
)
;
ErrorResult
dummy
;
bool
fullscreen
=
GetFullScreen
(
dummy
)
;
dummy
.
SuppressException
(
)
;
return
fullscreen
;
}
void
nsGlobalWindowInner
:
:
Dump
(
const
nsAString
&
aStr
)
{
if
(
!
nsContentUtils
:
:
DOMWindowDumpEnabled
(
)
)
{
return
;
}
char
*
cstr
=
ToNewUTF8String
(
aStr
)
;
#
if
defined
(
XP_MACOSX
)
char
*
c
=
cstr
*
cEnd
=
cstr
+
strlen
(
cstr
)
;
while
(
c
<
cEnd
)
{
if
(
*
c
=
=
'
\
r
'
)
*
c
=
'
\
n
'
;
c
+
+
;
}
#
endif
if
(
cstr
)
{
MOZ_LOG
(
nsContentUtils
:
:
DOMDumpLog
(
)
LogLevel
:
:
Debug
(
"
[
Window
.
Dump
]
%
s
"
cstr
)
)
;
#
ifdef
XP_WIN
PrintToDebugger
(
cstr
)
;
#
endif
#
ifdef
ANDROID
__android_log_write
(
ANDROID_LOG_INFO
"
GeckoDump
"
cstr
)
;
#
endif
FILE
*
fp
=
gDumpFile
?
gDumpFile
:
stdout
;
fputs
(
cstr
fp
)
;
fflush
(
fp
)
;
free
(
cstr
)
;
}
}
void
nsGlobalWindowInner
:
:
EnsureReflowFlushAndPaint
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
NS_ASSERTION
(
mDocShell
"
EnsureReflowFlushAndPaint
(
)
called
with
no
"
"
docshell
!
"
)
;
if
(
!
mDocShell
)
return
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
return
;
if
(
mDoc
)
{
mDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
presShell
-
>
UnsuppressPainting
(
)
;
}
void
nsGlobalWindowInner
:
:
MakeScriptDialogTitle
(
nsAString
&
aOutTitle
nsIPrincipal
*
aSubjectPrincipal
)
{
MOZ_ASSERT
(
aSubjectPrincipal
)
;
aOutTitle
.
Truncate
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aSubjectPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
uri
&
&
nsContentUtils
:
:
GetCurrentJSContext
(
)
)
{
nsCOMPtr
<
nsIURIFixup
>
fixup
(
do_GetService
(
NS_URIFIXUP_CONTRACTID
)
)
;
if
(
fixup
)
{
nsCOMPtr
<
nsIURI
>
fixedURI
;
rv
=
fixup
-
>
CreateExposableURI
(
uri
getter_AddRefs
(
fixedURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
fixedURI
)
{
nsAutoCString
host
;
fixedURI
-
>
GetHost
(
host
)
;
if
(
!
host
.
IsEmpty
(
)
)
{
nsAutoCString
prepath
;
fixedURI
-
>
GetDisplayPrePath
(
prepath
)
;
NS_ConvertUTF8toUTF16
ucsPrePath
(
prepath
)
;
const
char16_t
*
formatStrings
[
]
=
{
ucsPrePath
.
get
(
)
}
;
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDlgHeading
"
formatStrings
aOutTitle
)
;
}
}
}
}
if
(
aOutTitle
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDlgGenericHeading
"
aOutTitle
)
;
}
if
(
aOutTitle
.
IsEmpty
(
)
)
{
NS_WARNING
(
"
could
not
get
ScriptDlgGenericHeading
string
from
string
bundle
"
)
;
aOutTitle
.
AssignLiteral
(
"
[
Script
]
"
)
;
}
}
bool
nsGlobalWindowInner
:
:
CanMoveResizeWindows
(
CallerType
aCallerType
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
!
mHadOriginalOpener
)
{
return
false
;
}
if
(
!
CanSetProperty
(
"
dom
.
disable_window_move_resize
"
)
)
{
return
false
;
}
uint32_t
itemCount
=
0
;
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsITabChild
>
child
=
docShell
-
>
GetTabChild
(
)
;
if
(
child
)
{
child
-
>
SendGetTabCount
(
&
itemCount
)
;
}
}
}
else
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
if
(
!
treeOwner
|
|
NS_FAILED
(
treeOwner
-
>
GetTabCount
(
&
itemCount
)
)
)
{
itemCount
=
0
;
}
}
if
(
itemCount
>
1
)
{
return
false
;
}
}
if
(
mDocShell
)
{
bool
allow
;
nsresult
rv
=
mDocShell
-
>
GetAllowWindowControl
(
&
allow
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
allow
)
return
false
;
}
if
(
gMouseDown
&
&
!
gDragServiceDisabled
)
{
nsCOMPtr
<
nsIDragService
>
ds
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
ds
)
{
gDragServiceDisabled
=
true
;
ds
-
>
Suppress
(
)
;
}
}
return
true
;
}
bool
nsGlobalWindowInner
:
:
AlertOrConfirm
(
bool
aAlert
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
AreDialogsEnabled
(
)
)
{
return
false
;
}
nsAutoPopupStatePusher
popupStatePusher
(
openAbused
true
)
;
EnsureReflowFlushAndPaint
(
)
;
nsAutoString
title
;
MakeScriptDialogTitle
(
title
&
aSubjectPrincipal
)
;
nsAutoString
final
;
nsContentUtils
:
:
StripNullChars
(
aMessage
final
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
promptFac
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
false
;
}
nsCOMPtr
<
nsIPrompt
>
prompt
;
aError
=
promptFac
-
>
GetPrompt
(
AsOuter
(
)
NS_GET_IID
(
nsIPrompt
)
getter_AddRefs
(
prompt
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
false
;
}
if
(
nsCOMPtr
<
nsIWritablePropertyBag2
>
promptBag
=
do_QueryInterface
(
prompt
)
)
{
promptBag
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
allowTabModal
"
)
true
)
;
}
bool
result
=
false
;
nsAutoSyncOperation
sync
(
mDoc
)
;
if
(
ShouldPromptToBlockDialogs
(
)
)
{
bool
disallowDialog
=
false
;
nsAutoString
label
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogLabel
"
label
)
;
aError
=
aAlert
?
prompt
-
>
AlertCheck
(
title
.
get
(
)
final
.
get
(
)
label
.
get
(
)
&
disallowDialog
)
:
prompt
-
>
ConfirmCheck
(
title
.
get
(
)
final
.
get
(
)
label
.
get
(
)
&
disallowDialog
&
result
)
;
if
(
disallowDialog
)
DisableDialogs
(
)
;
}
else
{
aError
=
aAlert
?
prompt
-
>
Alert
(
title
.
get
(
)
final
.
get
(
)
)
:
prompt
-
>
Confirm
(
title
.
get
(
)
final
.
get
(
)
&
result
)
;
}
return
result
;
}
void
nsGlobalWindowInner
:
:
Alert
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
Alert
(
EmptyString
(
)
aSubjectPrincipal
aError
)
;
}
void
nsGlobalWindowInner
:
:
AlertOuter
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
AlertOrConfirm
(
true
aMessage
aSubjectPrincipal
aError
)
;
}
void
nsGlobalWindowInner
:
:
Alert
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
AlertOuter
(
aMessage
aSubjectPrincipal
aError
)
aError
)
;
}
bool
nsGlobalWindowInner
:
:
ConfirmOuter
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
return
AlertOrConfirm
(
false
aMessage
aSubjectPrincipal
aError
)
;
}
bool
nsGlobalWindowInner
:
:
Confirm
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
ConfirmOuter
(
aMessage
aSubjectPrincipal
aError
)
aError
false
)
;
}
already_AddRefed
<
Promise
>
nsGlobalWindowInner
:
:
Fetch
(
const
RequestOrUSVString
&
aInput
const
RequestInit
&
aInit
CallerType
aCallerType
ErrorResult
&
aRv
)
{
return
FetchRequest
(
this
aInput
aInit
aCallerType
aRv
)
;
}
void
nsGlobalWindowInner
:
:
PromptOuter
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
SetDOMStringToNull
(
aReturn
)
;
if
(
!
AreDialogsEnabled
(
)
)
{
return
;
}
nsAutoPopupStatePusher
popupStatePusher
(
openAbused
true
)
;
EnsureReflowFlushAndPaint
(
)
;
nsAutoString
title
;
MakeScriptDialogTitle
(
title
&
aSubjectPrincipal
)
;
nsAutoString
fixedMessage
fixedInitial
;
nsContentUtils
:
:
StripNullChars
(
aMessage
fixedMessage
)
;
nsContentUtils
:
:
StripNullChars
(
aInitial
fixedInitial
)
;
nsresult
rv
;
nsCOMPtr
<
nsIPromptFactory
>
promptFac
=
do_GetService
(
"
mozilla
.
org
/
prompter
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
;
}
nsCOMPtr
<
nsIPrompt
>
prompt
;
aError
=
promptFac
-
>
GetPrompt
(
AsOuter
(
)
NS_GET_IID
(
nsIPrompt
)
getter_AddRefs
(
prompt
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
if
(
nsCOMPtr
<
nsIWritablePropertyBag2
>
promptBag
=
do_QueryInterface
(
prompt
)
)
{
promptBag
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
allowTabModal
"
)
true
)
;
}
char16_t
*
inoutValue
=
ToNewUnicode
(
fixedInitial
)
;
bool
disallowDialog
=
false
;
nsAutoString
label
;
label
.
SetIsVoid
(
true
)
;
if
(
ShouldPromptToBlockDialogs
(
)
)
{
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eCOMMON_DIALOG_PROPERTIES
"
ScriptDialogLabel
"
label
)
;
}
nsAutoSyncOperation
sync
(
mDoc
)
;
bool
ok
;
aError
=
prompt
-
>
Prompt
(
title
.
get
(
)
fixedMessage
.
get
(
)
&
inoutValue
label
.
IsVoid
(
)
?
nullptr
:
label
.
get
(
)
&
disallowDialog
&
ok
)
;
if
(
disallowDialog
)
{
DisableDialogs
(
)
;
}
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsString
outValue
;
outValue
.
Adopt
(
inoutValue
)
;
if
(
ok
&
&
inoutValue
)
{
aReturn
.
Assign
(
outValue
)
;
}
}
void
nsGlobalWindowInner
:
:
Prompt
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
PromptOuter
(
aMessage
aInitial
aReturn
aSubjectPrincipal
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
FocusOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
baseWin
=
do_QueryInterface
(
mDocShell
)
;
bool
isVisible
=
false
;
if
(
baseWin
)
{
baseWin
-
>
GetVisibility
(
&
isVisible
)
;
}
if
(
!
isVisible
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
caller
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
nsPIDOMWindowOuter
*
callerOuter
=
caller
?
caller
-
>
GetOuterWindow
(
)
:
nullptr
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
opener
=
GetOpener
(
)
;
bool
canFocus
=
CanSetProperty
(
"
dom
.
disable_window_flip
"
)
|
|
(
opener
=
=
callerOuter
&
&
RevisePopupAbuseLevel
(
gPopupControlState
)
<
openBlocked
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
activeDOMWindow
;
fm
-
>
GetActiveWindow
(
getter_AddRefs
(
activeDOMWindow
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
mDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
rootItem
?
rootItem
-
>
GetWindow
(
)
:
nullptr
;
auto
*
activeWindow
=
nsPIDOMWindowOuter
:
:
From
(
activeDOMWindow
)
;
bool
isActive
=
(
rootWin
=
=
activeWindow
)
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
treeOwnerAsWin
&
&
(
canFocus
|
|
isActive
)
)
{
bool
isEnabled
=
true
;
if
(
NS_SUCCEEDED
(
treeOwnerAsWin
-
>
GetEnabled
(
&
isEnabled
)
)
&
&
!
isEnabled
)
{
NS_WARNING
(
"
Should
not
try
to
set
the
focus
on
a
disabled
window
"
)
;
return
;
}
nsCOMPtr
<
nsIEmbeddingSiteWindow
>
embeddingWin
(
do_GetInterface
(
treeOwnerAsWin
)
)
;
if
(
embeddingWin
)
embeddingWin
-
>
SetFocus
(
)
;
}
if
(
!
mDocShell
)
{
return
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
;
bool
lookForPresShell
=
true
;
if
(
mDocShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
&
&
GetPrivateRoot
(
)
=
=
AsOuter
(
)
&
&
mDoc
)
{
nsIURI
*
ourURI
=
mDoc
-
>
GetDocumentURI
(
)
;
if
(
ourURI
)
{
lookForPresShell
=
!
NS_IsAboutBlank
(
ourURI
)
;
}
}
if
(
lookForPresShell
)
{
mDocShell
-
>
GetEldestPresShell
(
getter_AddRefs
(
presShell
)
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentDsti
;
mDocShell
-
>
GetParent
(
getter_AddRefs
(
parentDsti
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
parentDsti
?
parentDsti
-
>
GetWindow
(
)
:
nullptr
;
if
(
parent
)
{
nsCOMPtr
<
nsIDocument
>
parentdoc
=
parent
-
>
GetDoc
(
)
;
if
(
!
parentdoc
)
{
return
;
}
nsIContent
*
frame
=
parentdoc
-
>
FindContentForSubDocument
(
mDoc
)
;
nsCOMPtr
<
nsIDOMElement
>
frameElement
=
do_QueryInterface
(
frame
)
;
if
(
frameElement
)
{
uint32_t
flags
=
nsIFocusManager
:
:
FLAG_NOSCROLL
;
if
(
canFocus
)
flags
|
=
nsIFocusManager
:
:
FLAG_RAISE
;
aError
=
fm
-
>
SetFocus
(
frameElement
flags
)
;
}
return
;
}
if
(
canFocus
)
{
aError
=
fm
-
>
SetActiveWindow
(
AsOuter
(
)
)
;
}
}
void
nsGlobalWindowInner
:
:
Focus
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
FocusOuter
(
aError
)
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
Focus
(
)
{
FORWARD_TO_INNER
(
Focus
(
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
Focus
(
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
BlurOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
CanSetProperty
(
"
dom
.
disable_window_flip
"
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
nsCOMPtr
<
nsIEmbeddingSiteWindow
>
siteWindow
(
do_GetInterface
(
treeOwner
)
)
;
if
(
siteWindow
)
{
siteWindow
-
>
Blur
(
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
mDoc
)
{
nsCOMPtr
<
nsIDOMElement
>
element
;
fm
-
>
GetFocusedElementForWindow
(
AsOuter
(
)
false
nullptr
getter_AddRefs
(
element
)
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
element
)
;
if
(
content
=
=
mDoc
-
>
GetRootElement
(
)
)
{
fm
-
>
ClearFocus
(
AsOuter
(
)
)
;
}
}
}
}
void
nsGlobalWindowInner
:
:
Blur
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
BlurOuter
(
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
BackOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
!
webNav
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aError
=
webNav
-
>
GoBack
(
)
;
}
void
nsGlobalWindowInner
:
:
Back
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
BackOuter
(
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
ForwardOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
!
webNav
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aError
=
webNav
-
>
GoForward
(
)
;
}
void
nsGlobalWindowInner
:
:
Forward
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
ForwardOuter
(
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
HomeOuter
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
;
}
nsAutoString
homeURL
;
Preferences
:
:
GetLocalizedString
(
PREF_BROWSER_STARTUP_HOMEPAGE
homeURL
)
;
if
(
homeURL
.
IsEmpty
(
)
)
{
#
ifdef
DEBUG_seth
printf
(
"
all
else
failed
.
using
%
s
as
the
home
page
\
n
"
DEFAULT_HOME_PAGE
)
;
#
endif
CopyASCIItoUTF16
(
DEFAULT_HOME_PAGE
homeURL
)
;
}
#
ifdef
MOZ_PHOENIX
{
int32_t
firstPipe
=
homeURL
.
FindChar
(
'
|
'
)
;
if
(
firstPipe
>
0
)
{
homeURL
.
Truncate
(
firstPipe
)
;
}
}
#
endif
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
!
webNav
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aError
=
webNav
-
>
LoadURI
(
homeURL
.
get
(
)
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
nullptr
nullptr
nullptr
&
aSubjectPrincipal
)
;
}
void
nsGlobalWindowInner
:
:
Home
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
HomeOuter
(
aSubjectPrincipal
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
StopOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
mDocShell
)
)
;
if
(
webNav
)
{
aError
=
webNav
-
>
Stop
(
nsIWebNavigation
:
:
STOP_ALL
)
;
}
}
void
nsGlobalWindowInner
:
:
Stop
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
StopOuter
(
aError
)
aError
)
;
}
bool
nsGlobalWindowInner
:
:
IsWindowPrintEnabled
(
JSContext
*
JSObject
*
)
{
static
bool
called
=
false
;
static
bool
printDisabled
=
false
;
if
(
!
called
)
{
called
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
printDisabled
"
dom
.
disable_window_print
"
)
;
}
return
!
printDisabled
;
}
void
nsGlobalWindowInner
:
:
PrintOuter
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
#
ifdef
NS_PRINTING
if
(
!
AreDialogsEnabled
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
if
(
ShouldPromptToBlockDialogs
(
)
&
&
!
ConfirmDialogIfNeeded
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
;
}
nsCOMPtr
<
nsIWebBrowserPrint
>
webBrowserPrint
;
if
(
NS_SUCCEEDED
(
GetInterface
(
NS_GET_IID
(
nsIWebBrowserPrint
)
getter_AddRefs
(
webBrowserPrint
)
)
)
)
{
nsAutoSyncOperation
sync
(
GetCurrentInnerWindowInternal
(
)
?
GetCurrentInnerWindowInternal
(
)
-
>
mDoc
.
get
(
)
:
nullptr
)
;
nsCOMPtr
<
nsIPrintSettingsService
>
printSettingsService
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
)
;
nsCOMPtr
<
nsIPrintSettings
>
printSettings
;
if
(
printSettingsService
)
{
bool
printSettingsAreGlobal
=
Preferences
:
:
GetBool
(
"
print
.
use_global_printsettings
"
false
)
;
if
(
printSettingsAreGlobal
)
{
printSettingsService
-
>
GetGlobalPrintSettings
(
getter_AddRefs
(
printSettings
)
)
;
nsAutoString
printerName
;
printSettings
-
>
GetPrinterName
(
printerName
)
;
bool
shouldGetDefaultPrinterName
=
printerName
.
IsEmpty
(
)
;
#
ifdef
MOZ_X11
if
(
!
XRE_IsParentProcess
(
)
)
{
shouldGetDefaultPrinterName
=
false
;
}
#
endif
if
(
shouldGetDefaultPrinterName
)
{
printSettingsService
-
>
GetDefaultPrinterName
(
printerName
)
;
printSettings
-
>
SetPrinterName
(
printerName
)
;
}
printSettingsService
-
>
InitPrintSettingsFromPrinter
(
printerName
printSettings
)
;
printSettingsService
-
>
InitPrintSettingsFromPrefs
(
printSettings
true
nsIPrintSettings
:
:
kInitSaveAll
)
;
}
else
{
printSettingsService
-
>
GetNewPrintSettings
(
getter_AddRefs
(
printSettings
)
)
;
}
EnterModalState
(
)
;
webBrowserPrint
-
>
Print
(
printSettings
nullptr
)
;
LeaveModalState
(
)
;
bool
savePrintSettings
=
Preferences
:
:
GetBool
(
"
print
.
save_print_settings
"
false
)
;
if
(
printSettingsAreGlobal
&
&
savePrintSettings
)
{
printSettingsService
-
>
SavePrintSettingsToPrefs
(
printSettings
true
nsIPrintSettings
:
:
kInitSaveAll
)
;
printSettingsService
-
>
SavePrintSettingsToPrefs
(
printSettings
false
nsIPrintSettings
:
:
kInitSavePrinterName
)
;
}
}
else
{
webBrowserPrint
-
>
GetGlobalPrintSettings
(
getter_AddRefs
(
printSettings
)
)
;
webBrowserPrint
-
>
Print
(
printSettings
nullptr
)
;
}
}
#
endif
}
void
nsGlobalWindowInner
:
:
Print
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
PrintOuter
(
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
MoveToOuter
(
int32_t
aXPos
int32_t
aYPos
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCOMPtr
<
nsIScreenManager
>
screenMgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
if
(
screenMgr
)
{
CSSIntSize
size
;
GetInnerSize
(
size
)
;
screenMgr
-
>
ScreenForRect
(
aXPos
aYPos
size
.
width
size
.
height
getter_AddRefs
(
screen
)
)
;
}
if
(
screen
)
{
int32_t
screenLeftDeskPx
screenTopDeskPx
w
h
;
screen
-
>
GetRectDisplayPix
(
&
screenLeftDeskPx
&
screenTopDeskPx
&
w
&
h
)
;
CSSIntPoint
cssPos
(
aXPos
-
screenLeftDeskPx
aYPos
-
screenTopDeskPx
)
;
CheckSecurityLeftAndTop
(
&
cssPos
.
x
&
cssPos
.
y
aCallerType
)
;
double
scale
;
screen
-
>
GetDefaultCSSScaleFactor
(
&
scale
)
;
LayoutDevicePoint
devPos
=
cssPos
*
CSSToLayoutDeviceScale
(
scale
)
;
screen
-
>
GetContentsScaleFactor
(
&
scale
)
;
DesktopPoint
deskPos
=
devPos
/
DesktopToLayoutDeviceScale
(
scale
)
;
aError
=
treeOwnerAsWin
-
>
SetPositionDesktopPix
(
screenLeftDeskPx
+
deskPos
.
x
screenTopDeskPx
+
deskPos
.
y
)
;
}
else
{
CSSIntPoint
cssPos
(
aXPos
aXPos
)
;
CheckSecurityLeftAndTop
(
&
cssPos
.
x
&
cssPos
.
y
aCallerType
)
;
LayoutDevicePoint
devPos
=
cssPos
*
CSSToLayoutDeviceScale
(
1
.
0
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
devPos
.
x
devPos
.
y
)
;
}
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowInner
:
:
MoveTo
(
int32_t
aXPos
int32_t
aYPos
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
MoveToOuter
(
aXPos
aYPos
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
MoveByOuter
(
int32_t
aXDif
int32_t
aYDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
x
y
;
aError
=
treeOwnerAsWin
-
>
GetPosition
(
&
x
&
y
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsIntSize
cssPos
(
DevToCSSIntPixels
(
nsIntSize
(
x
y
)
)
)
;
cssPos
.
width
+
=
aXDif
;
cssPos
.
height
+
=
aYDif
;
CheckSecurityLeftAndTop
(
&
cssPos
.
width
&
cssPos
.
height
aCallerType
)
;
nsIntSize
newDevPos
(
CSSToDevIntPixels
(
cssPos
)
)
;
aError
=
treeOwnerAsWin
-
>
SetPosition
(
newDevPos
.
width
newDevPos
.
height
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowInner
:
:
MoveBy
(
int32_t
aXDif
int32_t
aYDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
MoveByOuter
(
aXDif
aYDif
aCallerType
aError
)
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
MoveBy
(
int32_t
aXDif
int32_t
aYDif
)
{
FORWARD_TO_OUTER
(
MoveBy
(
aXDif
aYDif
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
MoveByOuter
(
aXDif
aYDif
CallerType
:
:
System
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
ResizeToOuter
(
int32_t
aWidth
int32_t
aHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
mDocShell
&
&
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
CSSIntSize
size
(
aWidth
aHeight
)
;
if
(
!
DispatchResizeEvent
(
size
)
)
{
return
;
}
}
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIntSize
cssSize
(
aWidth
aHeight
)
;
CheckSecurityWidthAndHeight
(
&
cssSize
.
width
&
cssSize
.
height
aCallerType
)
;
nsIntSize
devSz
(
CSSToDevIntPixels
(
cssSize
)
)
;
aError
=
treeOwnerAsWin
-
>
SetSize
(
devSz
.
width
devSz
.
height
true
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowInner
:
:
ResizeTo
(
int32_t
aWidth
int32_t
aHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
ResizeToOuter
(
aWidth
aHeight
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
ResizeByOuter
(
int32_t
aWidthDif
int32_t
aHeightDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
mDocShell
&
&
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
CSSIntSize
size
;
if
(
NS_FAILED
(
GetInnerSize
(
size
)
)
)
{
return
;
}
size
.
width
+
=
aWidthDif
;
size
.
height
+
=
aHeightDif
;
if
(
!
DispatchResizeEvent
(
size
)
)
{
return
;
}
}
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
!
treeOwnerAsWin
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
width
height
;
aError
=
treeOwnerAsWin
-
>
GetSize
(
&
width
&
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsIntSize
cssSize
(
DevToCSSIntPixels
(
nsIntSize
(
width
height
)
)
)
;
cssSize
.
width
+
=
aWidthDif
;
cssSize
.
height
+
=
aHeightDif
;
CheckSecurityWidthAndHeight
(
&
cssSize
.
width
&
cssSize
.
height
aCallerType
)
;
nsIntSize
newDevSize
(
CSSToDevIntPixels
(
cssSize
)
)
;
aError
=
treeOwnerAsWin
-
>
SetSize
(
newDevSize
.
width
newDevSize
.
height
true
)
;
CheckForDPIChange
(
)
;
}
void
nsGlobalWindowInner
:
:
ResizeBy
(
int32_t
aWidthDif
int32_t
aHeightDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
ResizeByOuter
(
aWidthDif
aHeightDif
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SizeToContentOuter
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
;
}
if
(
!
CanMoveResizeWindows
(
aCallerType
)
|
|
IsFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
!
cv
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
int32_t
width
height
;
aError
=
cv
-
>
GetContentSize
(
&
width
&
height
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
if
(
!
treeOwner
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIntSize
cssSize
(
DevToCSSIntPixels
(
nsIntSize
(
width
height
)
)
)
;
CheckSecurityWidthAndHeight
(
&
cssSize
.
width
&
cssSize
.
height
aCallerType
)
;
nsIntSize
newDevSize
(
CSSToDevIntPixels
(
cssSize
)
)
;
aError
=
treeOwner
-
>
SizeShellTo
(
mDocShell
newDevSize
.
width
newDevSize
.
height
)
;
}
void
nsGlobalWindowInner
:
:
SizeToContent
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SizeToContentOuter
(
aCallerType
aError
)
aError
)
;
}
already_AddRefed
<
nsPIWindowRoot
>
nsGlobalWindowInner
:
:
GetTopWindowRoot
(
)
{
nsPIDOMWindowOuter
*
piWin
=
GetPrivateRoot
(
)
;
if
(
!
piWin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIWindowRoot
>
window
=
do_QueryInterface
(
piWin
-
>
GetChromeEventHandler
(
)
)
;
return
window
.
forget
(
)
;
}
void
nsGlobalWindowInner
:
:
Scroll
(
double
aXScroll
double
aYScroll
)
{
auto
scrollPos
=
CSSIntPoint
:
:
Truncate
(
mozilla
:
:
ToZeroIfNonfinite
(
aXScroll
)
mozilla
:
:
ToZeroIfNonfinite
(
aYScroll
)
)
;
ScrollTo
(
scrollPos
ScrollOptions
(
)
)
;
}
void
nsGlobalWindowInner
:
:
ScrollTo
(
double
aXScroll
double
aYScroll
)
{
auto
scrollPos
=
CSSIntPoint
:
:
Truncate
(
mozilla
:
:
ToZeroIfNonfinite
(
aXScroll
)
mozilla
:
:
ToZeroIfNonfinite
(
aYScroll
)
)
;
ScrollTo
(
scrollPos
ScrollOptions
(
)
)
;
}
void
nsGlobalWindowInner
:
:
ScrollTo
(
const
ScrollToOptions
&
aOptions
)
{
FlushType
flushType
=
(
(
aOptions
.
mLeft
.
WasPassed
(
)
&
&
aOptions
.
mLeft
.
Value
(
)
>
0
)
|
|
(
aOptions
.
mTop
.
WasPassed
(
)
&
&
aOptions
.
mTop
.
Value
(
)
>
0
)
)
?
FlushType
:
:
Layout
:
FlushType
:
:
Frames
;
FlushPendingNotifications
(
flushType
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
CSSIntPoint
scrollPos
=
sf
-
>
GetScrollPositionCSSPixels
(
)
;
if
(
aOptions
.
mLeft
.
WasPassed
(
)
)
{
scrollPos
.
x
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mLeft
.
Value
(
)
)
;
}
if
(
aOptions
.
mTop
.
WasPassed
(
)
)
{
scrollPos
.
y
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mTop
.
Value
(
)
)
;
}
ScrollTo
(
scrollPos
aOptions
)
;
}
}
void
nsGlobalWindowInner
:
:
Scroll
(
const
ScrollToOptions
&
aOptions
)
{
ScrollTo
(
aOptions
)
;
}
void
nsGlobalWindowInner
:
:
ScrollTo
(
const
CSSIntPoint
&
aScroll
const
ScrollOptions
&
aOptions
)
{
FlushType
flushType
=
(
aScroll
.
x
|
|
aScroll
.
y
)
?
FlushType
:
:
Layout
:
FlushType
:
:
Frames
;
FlushPendingNotifications
(
flushType
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
const
int32_t
maxpx
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
0x7fffffff
)
-
4
;
CSSIntPoint
scroll
(
aScroll
)
;
if
(
scroll
.
x
>
maxpx
)
{
scroll
.
x
=
maxpx
;
}
if
(
scroll
.
y
>
maxpx
)
{
scroll
.
y
=
maxpx
;
}
bool
smoothScroll
=
sf
-
>
GetScrollbarStyles
(
)
.
IsSmoothScroll
(
aOptions
.
mBehavior
)
;
sf
-
>
ScrollToCSSPixels
(
scroll
smoothScroll
?
nsIScrollableFrame
:
:
SMOOTH_MSD
:
nsIScrollableFrame
:
:
INSTANT
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollBy
(
double
aXScrollDif
double
aYScrollDif
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
auto
scrollDif
=
CSSIntPoint
:
:
Truncate
(
mozilla
:
:
ToZeroIfNonfinite
(
aXScrollDif
)
mozilla
:
:
ToZeroIfNonfinite
(
aYScrollDif
)
)
;
ScrollTo
(
sf
-
>
GetScrollPositionCSSPixels
(
)
+
scrollDif
ScrollOptions
(
)
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollBy
(
const
ScrollToOptions
&
aOptions
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
CSSIntPoint
scrollPos
=
sf
-
>
GetScrollPositionCSSPixels
(
)
;
if
(
aOptions
.
mLeft
.
WasPassed
(
)
)
{
scrollPos
.
x
+
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mLeft
.
Value
(
)
)
;
}
if
(
aOptions
.
mTop
.
WasPassed
(
)
)
{
scrollPos
.
y
+
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mTop
.
Value
(
)
)
;
}
ScrollTo
(
scrollPos
aOptions
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollByLines
(
int32_t
numLines
const
ScrollOptions
&
aOptions
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
bool
smoothScroll
=
sf
-
>
GetScrollbarStyles
(
)
.
IsSmoothScroll
(
aOptions
.
mBehavior
)
;
sf
-
>
ScrollBy
(
nsIntPoint
(
0
numLines
)
nsIScrollableFrame
:
:
LINES
smoothScroll
?
nsIScrollableFrame
:
:
SMOOTH_MSD
:
nsIScrollableFrame
:
:
INSTANT
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollByPages
(
int32_t
numPages
const
ScrollOptions
&
aOptions
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
bool
smoothScroll
=
sf
-
>
GetScrollbarStyles
(
)
.
IsSmoothScroll
(
aOptions
.
mBehavior
)
;
sf
-
>
ScrollBy
(
nsIntPoint
(
0
numPages
)
nsIScrollableFrame
:
:
PAGES
smoothScroll
?
nsIScrollableFrame
:
:
SMOOTH_MSD
:
nsIScrollableFrame
:
:
INSTANT
)
;
}
}
void
nsGlobalWindowInner
:
:
MozScrollSnap
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
sf
-
>
ScrollSnap
(
)
;
}
}
void
nsGlobalWindowInner
:
:
ClearTimeout
(
int32_t
aHandle
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
aHandle
>
0
)
{
mTimeoutManager
-
>
ClearTimeout
(
aHandle
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
)
;
}
}
void
nsGlobalWindowInner
:
:
ClearInterval
(
int32_t
aHandle
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
aHandle
>
0
)
{
mTimeoutManager
-
>
ClearTimeout
(
aHandle
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
)
;
}
}
void
nsGlobalWindowInner
:
:
SetResizable
(
bool
aResizable
)
const
{
}
void
nsGlobalWindowInner
:
:
CaptureEvents
(
)
{
if
(
mDoc
)
{
mDoc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eUseOfCaptureEvents
)
;
}
}
void
nsGlobalWindowInner
:
:
ReleaseEvents
(
)
{
if
(
mDoc
)
{
mDoc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eUseOfReleaseEvents
)
;
}
}
void
nsGlobalWindowInner
:
:
FirePopupBlockedEvent
(
nsIDocument
*
aDoc
nsIURI
*
aPopupURI
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
"
All
callers
seem
to
assume
we
'
re
an
outer
window
?
"
)
;
MOZ_ASSERT
(
aDoc
)
;
PopupBlockedEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
true
;
init
.
mRequestingWindow
=
GetCurrentInnerWindowInternal
(
)
;
init
.
mPopupWindowURI
=
aPopupURI
;
init
.
mPopupWindowName
=
aPopupWindowName
;
init
.
mPopupWindowFeatures
=
aPopupWindowFeatures
;
RefPtr
<
PopupBlockedEvent
>
event
=
PopupBlockedEvent
:
:
Constructor
(
aDoc
NS_LITERAL_STRING
(
"
DOMPopupBlocked
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
defaultActionEnabled
;
aDoc
-
>
DispatchEvent
(
event
&
defaultActionEnabled
)
;
}
bool
nsGlobalWindowInner
:
:
CanSetProperty
(
const
char
*
aPrefName
)
{
if
(
nsContentUtils
:
:
LegacyIsCallerChromeOrNativeCode
(
)
)
{
return
true
;
}
return
!
Preferences
:
:
GetBool
(
aPrefName
true
)
;
}
bool
nsGlobalWindowInner
:
:
PopupWhitelisted
(
)
{
MOZ_CRASH
(
"
Outer
Window
only
"
)
;
}
PopupControlState
nsGlobalWindowInner
:
:
RevisePopupAbuseLevel
(
PopupControlState
aControl
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
void
nsGlobalWindowInner
:
:
FireAbuseEvents
(
const
nsAString
&
aPopupURL
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetTop
(
)
;
if
(
!
window
)
{
return
;
}
nsCOMPtr
<
nsIDocument
>
topDoc
=
window
-
>
GetDoc
(
)
;
nsCOMPtr
<
nsIURI
>
popupURI
;
nsIURI
*
baseURL
=
nullptr
;
nsCOMPtr
<
nsIDocument
>
doc
=
GetEntryDocument
(
)
;
if
(
doc
)
baseURL
=
doc
-
>
GetDocBaseURI
(
)
;
nsCOMPtr
<
nsIIOService
>
ios
(
do_GetService
(
NS_IOSERVICE_CONTRACTID
)
)
;
if
(
ios
)
ios
-
>
NewURI
(
NS_ConvertUTF16toUTF8
(
aPopupURL
)
nullptr
baseURL
getter_AddRefs
(
popupURI
)
)
;
FirePopupBlockedEvent
(
topDoc
popupURI
aPopupWindowName
aPopupWindowFeatures
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
OpenOuter
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
aError
=
OpenJS
(
aUrl
aName
aOptions
getter_AddRefs
(
window
)
)
;
return
window
.
forget
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
OpenOuter
(
aUrl
aName
aOptions
aError
)
aError
nullptr
)
;
}
nsresult
nsGlobalWindowInner
:
:
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsIDocShellLoadInfo
*
aLoadInfo
bool
aForceNoOpener
nsPIDOMWindowOuter
*
*
_retval
)
{
FORWARD_TO_OUTER
(
Open
(
aUrl
aName
aOptions
aLoadInfo
aForceNoOpener
_retval
)
NS_ERROR_NOT_INITIALIZED
)
;
return
OpenInternal
(
aUrl
aName
aOptions
false
false
true
false
true
nullptr
nullptr
aLoadInfo
aForceNoOpener
_retval
)
;
}
nsresult
nsGlobalWindowInner
:
:
OpenJS
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
return
OpenInternal
(
aUrl
aName
aOptions
false
false
false
true
true
nullptr
nullptr
nullptr
false
_retval
)
;
}
nsresult
nsGlobalWindowInner
:
:
OpenDialog
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsISupports
*
aExtraArgument
nsPIDOMWindowOuter
*
*
_retval
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
return
OpenInternal
(
aUrl
aName
aOptions
true
false
true
false
true
nullptr
aExtraArgument
nullptr
false
_retval
)
;
}
nsresult
nsGlobalWindowInner
:
:
OpenNoNavigate
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
return
OpenInternal
(
aUrl
aName
aOptions
false
false
true
false
false
nullptr
nullptr
nullptr
false
_retval
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
OpenDialogOuter
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIJSArgArray
>
argvArray
;
aError
=
NS_CreateJSArgv
(
aCx
aExtraArgument
.
Length
(
)
aExtraArgument
.
Elements
(
)
getter_AddRefs
(
argvArray
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
dialog
;
aError
=
OpenInternal
(
aUrl
aName
aOptions
true
false
false
false
true
argvArray
nullptr
nullptr
false
getter_AddRefs
(
dialog
)
)
;
return
dialog
.
forget
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
OpenDialog
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
OpenDialogOuter
(
aCx
aUrl
aName
aOptions
aExtraArgument
aError
)
aError
nullptr
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetFramesOuter
(
)
{
RefPtr
<
nsPIDOMWindowOuter
>
frames
(
AsOuter
(
)
)
;
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
return
frames
.
forget
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsGlobalWindowInner
:
:
GetFrames
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetFramesOuter
(
)
aError
nullptr
)
;
}
nsGlobalWindowInner
*
nsGlobalWindowInner
:
:
CallerInnerWindow
(
)
{
JSContext
*
cx
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
;
NS_ENSURE_TRUE
(
cx
nullptr
)
;
nsIGlobalObject
*
global
=
GetIncumbentGlobal
(
)
;
NS_ENSURE_TRUE
(
global
nullptr
)
;
JS
:
:
Rooted
<
JSObject
*
>
scope
(
cx
global
-
>
GetGlobalJSObject
(
)
)
;
NS_ENSURE_TRUE
(
scope
nullptr
)
;
if
(
xpc
:
:
IsSandbox
(
scope
)
)
{
JSAutoCompartment
ac
(
cx
scope
)
;
JS
:
:
Rooted
<
JSObject
*
>
scopeProto
(
cx
)
;
bool
ok
=
JS_GetPrototype
(
cx
scope
&
scopeProto
)
;
NS_ENSURE_TRUE
(
ok
nullptr
)
;
if
(
scopeProto
&
&
xpc
:
:
IsSandboxPrototypeProxy
(
scopeProto
)
&
&
(
scopeProto
=
js
:
:
CheckedUnwrap
(
scopeProto
false
)
)
)
{
global
=
xpc
:
:
NativeGlobal
(
scopeProto
)
;
NS_ENSURE_TRUE
(
global
nullptr
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
global
)
;
return
nsGlobalWindowInner
:
:
Cast
(
win
)
;
}
void
nsGlobalWindowInner
:
:
PostMessageMozOuter
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
RefPtr
<
nsGlobalWindowInner
>
callerInnerWin
=
CallerInnerWindow
(
)
;
nsIPrincipal
*
callerPrin
;
if
(
callerInnerWin
)
{
MOZ_ASSERT
(
callerInnerWin
-
>
IsInnerWindow
(
)
"
should
have
gotten
an
inner
window
here
"
)
;
callerPrin
=
callerInnerWin
-
>
GetPrincipal
(
)
;
}
else
{
nsIGlobalObject
*
global
=
GetIncumbentGlobal
(
)
;
NS_ASSERTION
(
global
"
Why
is
there
no
global
object
?
"
)
;
callerPrin
=
global
-
>
PrincipalOrNull
(
)
;
}
if
(
!
callerPrin
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
callerOuterURI
;
if
(
NS_FAILED
(
callerPrin
-
>
GetURI
(
getter_AddRefs
(
callerOuterURI
)
)
)
)
{
return
;
}
nsAutoString
origin
;
if
(
callerOuterURI
)
{
nsContentUtils
:
:
GetUTFOrigin
(
callerPrin
origin
)
;
}
else
if
(
callerInnerWin
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
callerInnerWin
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
;
}
callerOuterURI
=
doc
-
>
GetDocumentURI
(
)
;
nsContentUtils
:
:
GetUTFOrigin
(
callerOuterURI
origin
)
;
}
else
{
if
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
callerPrin
)
)
{
return
;
}
}
nsCOMPtr
<
nsIPrincipal
>
providedPrincipal
;
if
(
aTargetOrigin
.
EqualsASCII
(
"
/
"
)
)
{
providedPrincipal
=
callerPrin
;
}
else
if
(
!
aTargetOrigin
.
EqualsASCII
(
"
*
"
)
)
{
nsCOMPtr
<
nsIURI
>
originURI
;
if
(
NS_FAILED
(
NS_NewURI
(
getter_AddRefs
(
originURI
)
aTargetOrigin
)
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
;
}
if
(
NS_FAILED
(
originURI
-
>
SetUserPass
(
EmptyCString
(
)
)
)
|
|
NS_FAILED
(
originURI
-
>
SetPathQueryRef
(
EmptyCString
(
)
)
)
)
{
return
;
}
OriginAttributes
attrs
=
aSubjectPrincipal
.
OriginAttributesRef
(
)
;
if
(
aSubjectPrincipal
.
GetIsSystemPrincipal
(
)
)
{
auto
principal
=
BasePrincipal
:
:
Cast
(
GetPrincipal
(
)
)
;
if
(
attrs
!
=
principal
-
>
OriginAttributesRef
(
)
)
{
nsCOMPtr
<
nsIURI
>
targetURI
;
nsAutoCString
targetURL
;
nsAutoCString
sourceOrigin
;
nsAutoCString
targetOrigin
;
if
(
NS_FAILED
(
principal
-
>
GetURI
(
getter_AddRefs
(
targetURI
)
)
)
|
|
NS_FAILED
(
targetURI
-
>
GetAsciiSpec
(
targetURL
)
)
|
|
NS_FAILED
(
principal
-
>
GetOrigin
(
targetOrigin
)
)
|
|
NS_FAILED
(
aSubjectPrincipal
.
GetOrigin
(
sourceOrigin
)
)
)
{
NS_WARNING
(
"
Failed
to
get
source
and
target
origins
"
)
;
return
;
}
nsContentUtils
:
:
LogSimpleConsoleError
(
NS_ConvertUTF8toUTF16
(
nsPrintfCString
(
R
"
(
Attempting
to
post
a
message
to
window
with
url
"
%
s
"
and
)
"
R
"
(
origin
"
%
s
"
from
a
system
principal
scope
with
mismatched
)
"
R
"
(
origin
"
%
s
"
.
)
"
targetURL
.
get
(
)
targetOrigin
.
get
(
)
sourceOrigin
.
get
(
)
)
)
"
DOM
"
)
;
attrs
=
principal
-
>
OriginAttributesRef
(
)
;
}
}
providedPrincipal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
originURI
attrs
)
;
if
(
NS_WARN_IF
(
!
providedPrincipal
)
)
{
return
;
}
}
RefPtr
<
PostMessageEvent
>
event
=
new
PostMessageEvent
(
nsContentUtils
:
:
IsCallerChrome
(
)
|
|
!
callerInnerWin
?
nullptr
:
callerInnerWin
-
>
GetOuterWindowInternal
(
)
origin
AssertOuter
(
)
providedPrincipal
callerInnerWin
?
callerInnerWin
-
>
GetDoc
(
)
:
nullptr
nsContentUtils
:
:
IsCallerChrome
(
)
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
message
(
aCx
aMessage
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
transfer
(
aCx
aTransfer
)
;
event
-
>
Write
(
aCx
message
transfer
JS
:
:
CloneDataPolicy
(
)
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
;
}
aError
=
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
void
nsGlobalWindowInner
:
:
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
PostMessageMozOuter
(
aCx
aMessage
aTargetOrigin
aTransfer
aSubjectPrincipal
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
Sequence
<
JSObject
*
>
&
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
transferArray
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
aRv
=
nsContentUtils
:
:
CreateJSValueFromSequenceOfObject
(
aCx
aTransfer
&
transferArray
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
PostMessageMoz
(
aCx
aMessage
aTargetOrigin
transferArray
aSubjectPrincipal
aRv
)
;
}
bool
nsGlobalWindowInner
:
:
CanClose
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
mIsChrome
)
{
nsCOMPtr
<
nsIBrowserDOMWindow
>
bwin
;
GetBrowserDOMWindow
(
getter_AddRefs
(
bwin
)
)
;
bool
canClose
=
true
;
if
(
bwin
&
&
NS_SUCCEEDED
(
bwin
-
>
CanClose
(
&
canClose
)
)
)
{
return
canClose
;
}
}
if
(
!
mDocShell
)
{
return
true
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
bool
canClose
;
nsresult
rv
=
cv
-
>
PermitUnload
(
&
canClose
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
canClose
)
return
false
;
rv
=
cv
-
>
RequestWindowClose
(
&
canClose
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
canClose
)
return
false
;
}
return
true
;
}
void
nsGlobalWindowInner
:
:
CloseOuter
(
bool
aTrustedCaller
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
|
|
IsInModalState
(
)
|
|
(
IsFrame
(
)
&
&
!
mDocShell
-
>
GetIsMozBrowser
(
)
)
)
{
return
;
}
if
(
mHavePendingClose
)
{
return
;
}
if
(
mBlockScriptedClosingFlag
)
{
return
;
}
nsAutoString
url
;
nsresult
rv
=
mDoc
-
>
GetURL
(
url
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
!
StringBeginsWith
(
url
NS_LITERAL_STRING
(
"
about
:
neterror
"
)
)
&
&
!
mHadOriginalOpener
&
&
!
aTrustedCaller
)
{
bool
allowClose
=
mAllowScriptsToClose
|
|
Preferences
:
:
GetBool
(
"
dom
.
allow_scripts_to_close_windows
"
true
)
;
if
(
!
allowClose
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
Window
"
)
mDoc
nsContentUtils
:
:
eDOM_PROPERTIES
"
WindowCloseBlockedWarning
"
)
;
return
;
}
}
if
(
!
mInClose
&
&
!
mIsClosed
&
&
!
CanClose
(
)
)
{
return
;
}
bool
wasInClose
=
mInClose
;
mInClose
=
true
;
if
(
!
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
DOMWindowClose
"
)
)
)
{
mInClose
=
wasInClose
;
return
;
}
FinalClose
(
)
;
}
void
nsGlobalWindowInner
:
:
Close
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
CloseOuter
(
nsContentUtils
:
:
IsCallerChrome
(
)
)
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
Close
(
)
{
FORWARD_TO_OUTER
(
Close
(
)
NS_ERROR_UNEXPECTED
)
;
CloseOuter
(
true
)
;
return
NS_OK
;
}
void
nsGlobalWindowInner
:
:
ForceClose
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
MOZ_ASSERT
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Default
)
;
if
(
IsFrame
(
)
|
|
!
mDocShell
)
{
return
;
}
if
(
mHavePendingClose
)
{
return
;
}
mInClose
=
true
;
DispatchCustomEvent
(
NS_LITERAL_STRING
(
"
DOMWindowClose
"
)
)
;
FinalClose
(
)
;
}
void
nsGlobalWindowInner
:
:
FinalClose
(
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
void
nsGlobalWindowInner
:
:
ReallyCloseWindow
(
)
{
FORWARD_TO_OUTER_VOID
(
ReallyCloseWindow
(
)
)
;
mHavePendingClose
=
true
;
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
GetTreeOwnerWindow
(
)
;
if
(
treeOwnerAsWin
)
{
if
(
mDocShell
)
{
nsCOMPtr
<
nsIBrowserDOMWindow
>
bwin
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
mDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
rootItem
?
rootItem
-
>
GetWindow
(
)
:
nullptr
;
nsCOMPtr
<
nsIDOMChromeWindow
>
chromeWin
(
do_QueryInterface
(
rootWin
)
)
;
if
(
chromeWin
)
chromeWin
-
>
GetBrowserDOMWindow
(
getter_AddRefs
(
bwin
)
)
;
if
(
rootWin
)
{
bool
isTab
;
if
(
rootWin
=
=
AsOuter
(
)
|
|
!
bwin
|
|
(
NS_SUCCEEDED
(
bwin
-
>
IsTabContentWindow
(
GetOuterWindowInternal
(
)
&
isTab
)
)
&
&
isTab
)
)
{
treeOwnerAsWin
-
>
Destroy
(
)
;
}
}
}
CleanUp
(
)
;
}
}
void
nsGlobalWindowInner
:
:
EnterModalState
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
"
Modal
state
is
maintained
on
outer
windows
"
)
;
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
!
topWin
)
{
NS_ERROR
(
"
Uh
EnterModalState
(
)
called
w
/
o
a
reachable
top
window
?
"
)
;
return
;
}
EventStateManager
*
activeESM
=
static_cast
<
EventStateManager
*
>
(
EventStateManager
:
:
GetActiveEventStateManager
(
)
)
;
if
(
activeESM
&
&
activeESM
-
>
GetPresContext
(
)
)
{
nsIPresShell
*
activeShell
=
activeESM
-
>
GetPresContext
(
)
-
>
GetPresShell
(
)
;
if
(
activeShell
&
&
(
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
activeShell
-
>
GetDocument
(
)
mDoc
)
|
|
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
mDoc
activeShell
-
>
GetDocument
(
)
)
)
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
activeESM
)
;
activeShell
-
>
SetCapturingContent
(
nullptr
0
)
;
if
(
activeShell
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
activeShell
-
>
FrameSelection
(
)
;
frameSelection
-
>
SetDragState
(
false
)
;
}
}
}
nsCOMPtr
<
nsIDragService
>
ds
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
ds
)
{
ds
-
>
EndDragSession
(
true
0
)
;
}
nsIDocument
*
topDoc
=
topWin
-
>
GetExtantDoc
(
)
;
nsIContent
*
capturingContent
=
nsIPresShell
:
:
GetCapturingContent
(
)
;
if
(
capturingContent
&
&
topDoc
&
&
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
capturingContent
topDoc
)
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
if
(
topWin
-
>
mModalStateDepth
=
=
0
)
{
NS_ASSERTION
(
!
topWin
-
>
mSuspendedDoc
"
Shouldn
'
t
have
mSuspendedDoc
here
!
"
)
;
topWin
-
>
mSuspendedDoc
=
topDoc
;
if
(
topDoc
)
{
topDoc
-
>
SuppressEventHandling
(
)
;
}
nsGlobalWindowInner
*
inner
=
topWin
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
inner
)
{
topWin
-
>
GetCurrentInnerWindowInternal
(
)
-
>
Suspend
(
)
;
}
}
topWin
-
>
mModalStateDepth
+
+
;
}
void
nsGlobalWindowInner
:
:
LeaveModalState
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
"
Modal
state
is
maintained
on
outer
windows
"
)
;
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
!
topWin
)
{
NS_ERROR
(
"
Uh
LeaveModalState
(
)
called
w
/
o
a
reachable
top
window
?
"
)
;
return
;
}
MOZ_ASSERT
(
topWin
-
>
mModalStateDepth
!
=
0
)
;
MOZ_ASSERT
(
IsSuspended
(
)
)
;
MOZ_ASSERT
(
topWin
-
>
IsSuspended
(
)
)
;
topWin
-
>
mModalStateDepth
-
-
;
nsGlobalWindowInner
*
inner
=
topWin
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWin
-
>
mModalStateDepth
=
=
0
)
{
if
(
inner
)
{
inner
-
>
Resume
(
)
;
}
if
(
topWin
-
>
mSuspendedDoc
)
{
nsCOMPtr
<
nsIDocument
>
currentDoc
=
topWin
-
>
GetExtantDoc
(
)
;
topWin
-
>
mSuspendedDoc
-
>
UnsuppressEventHandlingAndFireEvents
(
currentDoc
=
=
topWin
-
>
mSuspendedDoc
)
;
topWin
-
>
mSuspendedDoc
=
nullptr
;
}
}
if
(
inner
)
{
inner
-
>
mLastDialogQuitTime
=
TimeStamp
:
:
Now
(
)
;
}
if
(
topWin
-
>
mModalStateDepth
=
=
0
)
{
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
inner
nullptr
nullptr
)
;
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
endmodalstate
"
)
true
false
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
bool
dummy
;
topWin
-
>
DispatchEvent
(
event
&
dummy
)
;
}
}
bool
nsGlobalWindowInner
:
:
IsInModalState
(
)
{
nsGlobalWindowOuter
*
topWin
=
GetScriptableTopInternal
(
)
;
if
(
!
topWin
)
{
return
false
;
}
return
topWin
-
>
mModalStateDepth
!
=
0
;
}
void
nsGlobalWindowInner
:
:
NotifyDOMWindowDestroyed
(
nsGlobalWindowInner
*
aWindow
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
aWindow
)
DOM_WINDOW_DESTROYED_TOPIC
nullptr
)
;
}
}
void
nsGlobalWindowInner
:
:
NotifyWindowIDDestroyed
(
const
char
*
aTopic
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
;
if
(
IsInnerWindow
(
)
)
{
runnable
=
new
WindowDestroyedEvent
(
AssertInner
(
)
mWindowID
aTopic
)
;
}
else
{
runnable
=
new
WindowDestroyedEvent
(
AssertOuter
(
)
mWindowID
aTopic
)
;
}
nsresult
rv
=
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mNotifiedIDDestroyed
=
true
;
}
}
void
nsGlobalWindowInner
:
:
NotifyDOMWindowFrozen
(
nsGlobalWindowInner
*
aWindow
)
{
if
(
aWindow
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
aWindow
)
DOM_WINDOW_FROZEN_TOPIC
nullptr
)
;
}
}
}
void
nsGlobalWindowInner
:
:
NotifyDOMWindowThawed
(
nsGlobalWindowInner
*
aWindow
)
{
if
(
aWindow
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
aWindow
)
DOM_WINDOW_THAWED_TOPIC
nullptr
)
;
}
}
}
JSObject
*
nsGlobalWindowInner
:
:
GetCachedXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
)
{
JS
:
:
Rooted
<
JSObject
*
>
handler
(
RootingCx
(
)
)
;
if
(
mCachedXBLPrototypeHandlers
)
{
mCachedXBLPrototypeHandlers
-
>
Get
(
aKey
handler
.
address
(
)
)
;
}
return
handler
;
}
void
nsGlobalWindowInner
:
:
CacheXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
JS
:
:
Handle
<
JSObject
*
>
aHandler
)
{
if
(
!
mCachedXBLPrototypeHandlers
)
{
mCachedXBLPrototypeHandlers
=
MakeUnique
<
XBLPrototypeHandlerTable
>
(
)
;
PreserveWrapper
(
ToSupports
(
this
)
)
;
}
mCachedXBLPrototypeHandlers
-
>
Put
(
aKey
aHandler
)
;
}
Element
*
nsGlobalWindowInner
:
:
GetFrameElementOuter
(
nsIPrincipal
&
aSubjectPrincipal
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
|
|
mDocShell
-
>
GetIsMozBrowser
(
)
)
{
return
nullptr
;
}
Element
*
element
=
GetRealFrameElementOuter
(
)
;
if
(
!
element
)
{
return
nullptr
;
}
if
(
!
aSubjectPrincipal
.
SubsumesConsideringDomain
(
element
-
>
NodePrincipal
(
)
)
)
{
return
nullptr
;
}
return
element
;
}
Element
*
nsGlobalWindowInner
:
:
GetFrameElement
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetFrameElementOuter
(
aSubjectPrincipal
)
aError
nullptr
)
;
}
Element
*
nsGlobalWindowInner
:
:
GetRealFrameElementOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
parent
;
mDocShell
-
>
GetSameTypeParentIgnoreBrowserBoundaries
(
getter_AddRefs
(
parent
)
)
;
if
(
!
parent
|
|
parent
=
=
mDocShell
)
{
return
nullptr
;
}
return
mFrameElement
;
}
Element
*
nsGlobalWindowInner
:
:
GetRealFrameElement
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetRealFrameElementOuter
(
)
aError
nullptr
)
;
}
already_AddRefed
<
nsIDOMElement
>
nsGlobalWindowInner
:
:
GetFrameElement
(
)
{
FORWARD_TO_INNER
(
GetFrameElement
(
)
nullptr
)
;
ErrorResult
dummy
;
nsCOMPtr
<
nsIDOMElement
>
frameElement
=
do_QueryInterface
(
GetRealFrameElement
(
dummy
)
)
;
dummy
.
SuppressException
(
)
;
return
frameElement
.
forget
(
)
;
}
bool
nsGlobalWindowInner
:
:
TokenizeDialogOptions
(
nsAString
&
aToken
nsAString
:
:
const_iterator
&
aIter
nsAString
:
:
const_iterator
aEnd
)
{
while
(
aIter
!
=
aEnd
&
&
nsCRT
:
:
IsAsciiSpace
(
*
aIter
)
)
{
+
+
aIter
;
}
if
(
aIter
=
=
aEnd
)
{
return
false
;
}
if
(
*
aIter
=
=
'
;
'
|
|
*
aIter
=
=
'
:
'
|
|
*
aIter
=
=
'
=
'
)
{
aToken
.
Assign
(
*
aIter
)
;
+
+
aIter
;
return
true
;
}
nsAString
:
:
const_iterator
start
=
aIter
;
while
(
aIter
!
=
aEnd
&
&
!
nsCRT
:
:
IsAsciiSpace
(
*
aIter
)
&
&
*
aIter
!
=
'
;
'
&
&
*
aIter
!
=
'
:
'
&
&
*
aIter
!
=
'
=
'
)
{
+
+
aIter
;
}
aToken
.
Assign
(
Substring
(
start
aIter
)
)
;
return
true
;
}
void
nsGlobalWindowInner
:
:
ConvertDialogOptions
(
const
nsAString
&
aOptions
nsAString
&
aResult
)
{
nsAString
:
:
const_iterator
end
;
aOptions
.
EndReading
(
end
)
;
nsAString
:
:
const_iterator
iter
;
aOptions
.
BeginReading
(
iter
)
;
nsAutoString
token
;
nsAutoString
name
;
nsAutoString
value
;
while
(
true
)
{
if
(
!
TokenizeDialogOptions
(
name
iter
end
)
)
{
break
;
}
if
(
name
.
EqualsLiteral
(
"
=
"
)
|
|
name
.
EqualsLiteral
(
"
:
"
)
|
|
name
.
EqualsLiteral
(
"
;
"
)
)
{
break
;
}
if
(
!
TokenizeDialogOptions
(
token
iter
end
)
)
{
break
;
}
if
(
!
token
.
EqualsLiteral
(
"
:
"
)
&
&
!
token
.
EqualsLiteral
(
"
=
"
)
)
{
continue
;
}
if
(
!
TokenizeDialogOptions
(
value
iter
end
)
)
{
break
;
}
if
(
name
.
LowerCaseEqualsLiteral
(
"
center
"
)
)
{
if
(
value
.
LowerCaseEqualsLiteral
(
"
on
"
)
|
|
value
.
LowerCaseEqualsLiteral
(
"
yes
"
)
|
|
value
.
LowerCaseEqualsLiteral
(
"
1
"
)
)
{
aResult
.
AppendLiteral
(
"
centerscreen
=
1
"
)
;
}
}
else
if
(
name
.
LowerCaseEqualsLiteral
(
"
dialogwidth
"
)
)
{
if
(
!
value
.
IsEmpty
(
)
)
{
aResult
.
AppendLiteral
(
"
width
=
"
)
;
aResult
.
Append
(
value
)
;
}
}
else
if
(
name
.
LowerCaseEqualsLiteral
(
"
dialogheight
"
)
)
{
if
(
!
value
.
IsEmpty
(
)
)
{
aResult
.
AppendLiteral
(
"
height
=
"
)
;
aResult
.
Append
(
value
)
;
}
}
else
if
(
name
.
LowerCaseEqualsLiteral
(
"
dialogtop
"
)
)
{
if
(
!
value
.
IsEmpty
(
)
)
{
aResult
.
AppendLiteral
(
"
top
=
"
)
;
aResult
.
Append
(
value
)
;
}
}
else
if
(
name
.
LowerCaseEqualsLiteral
(
"
dialogleft
"
)
)
{
if
(
!
value
.
IsEmpty
(
)
)
{
aResult
.
AppendLiteral
(
"
left
=
"
)
;
aResult
.
Append
(
value
)
;
}
}
else
if
(
name
.
LowerCaseEqualsLiteral
(
"
resizable
"
)
)
{
if
(
value
.
LowerCaseEqualsLiteral
(
"
on
"
)
|
|
value
.
LowerCaseEqualsLiteral
(
"
yes
"
)
|
|
value
.
LowerCaseEqualsLiteral
(
"
1
"
)
)
{
aResult
.
AppendLiteral
(
"
resizable
=
1
"
)
;
}
}
else
if
(
name
.
LowerCaseEqualsLiteral
(
"
scroll
"
)
)
{
if
(
value
.
LowerCaseEqualsLiteral
(
"
off
"
)
|
|
value
.
LowerCaseEqualsLiteral
(
"
no
"
)
|
|
value
.
LowerCaseEqualsLiteral
(
"
0
"
)
)
{
aResult
.
AppendLiteral
(
"
scrollbars
=
0
"
)
;
}
}
if
(
iter
=
=
end
|
|
!
TokenizeDialogOptions
(
token
iter
end
)
|
|
!
token
.
EqualsLiteral
(
"
;
"
)
)
{
break
;
}
}
}
nsresult
nsGlobalWindowInner
:
:
UpdateCommands
(
const
nsAString
&
anAction
nsISelection
*
aSel
int16_t
aReason
)
{
if
(
nsIDocShell
*
docShell
=
GetDocShell
(
)
)
{
if
(
nsCOMPtr
<
nsITabChild
>
child
=
docShell
-
>
GetTabChild
(
)
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
GetTopWindowRoot
(
)
;
if
(
root
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
ChildCommandDispatcher
(
root
child
anAction
)
)
;
}
return
NS_OK
;
}
}
nsPIDOMWindowOuter
*
rootWindow
=
GetPrivateRoot
(
)
;
if
(
!
rootWindow
)
return
NS_OK
;
nsCOMPtr
<
nsIDOMXULDocument
>
xulDoc
=
do_QueryInterface
(
rootWindow
-
>
GetExtantDoc
(
)
)
;
if
(
xulDoc
&
&
!
anAction
.
EqualsLiteral
(
"
selectionchange
"
)
)
{
nsCOMPtr
<
nsIDOMXULCommandDispatcher
>
xulCommandDispatcher
;
xulDoc
-
>
GetCommandDispatcher
(
getter_AddRefs
(
xulCommandDispatcher
)
)
;
if
(
xulCommandDispatcher
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
CommandDispatcher
(
xulCommandDispatcher
anAction
)
)
;
}
}
return
NS_OK
;
}
Selection
*
nsGlobalWindowInner
:
:
GetSelectionOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
nsISelection
*
domSelection
=
presShell
-
>
GetCurrentSelection
(
SelectionType
:
:
eNormal
)
;
return
domSelection
?
domSelection
-
>
AsSelection
(
)
:
nullptr
;
}
Selection
*
nsGlobalWindowInner
:
:
GetSelection
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetSelectionOuter
(
)
aError
nullptr
)
;
}
already_AddRefed
<
nsISelection
>
nsGlobalWindowInner
:
:
GetSelection
(
)
{
nsCOMPtr
<
nsISelection
>
selection
=
GetSelectionOuter
(
)
;
return
selection
.
forget
(
)
;
}
bool
nsGlobalWindowInner
:
:
FindOuter
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
Unused
<
<
aShowDialog
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
disable_window_find
"
false
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
false
;
}
nsCOMPtr
<
nsIWebBrowserFind
>
finder
(
do_GetInterface
(
mDocShell
)
)
;
if
(
!
finder
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
false
;
}
aError
=
finder
-
>
SetSearchString
(
PromiseFlatString
(
aString
)
.
get
(
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
false
;
}
finder
-
>
SetMatchCase
(
aCaseSensitive
)
;
finder
-
>
SetFindBackwards
(
aBackwards
)
;
finder
-
>
SetWrapFind
(
aWrapAround
)
;
finder
-
>
SetEntireWord
(
aWholeWord
)
;
finder
-
>
SetSearchFrames
(
aSearchInFrames
)
;
nsCOMPtr
<
nsIWebBrowserFindInFrames
>
framesFinder
(
do_QueryInterface
(
finder
)
)
;
if
(
framesFinder
)
{
framesFinder
-
>
SetRootSearchFrame
(
AsOuter
(
)
)
;
framesFinder
-
>
SetCurrentSearchFrame
(
AsOuter
(
)
)
;
}
if
(
aString
.
IsEmpty
(
)
)
{
return
false
;
}
bool
didFind
=
false
;
aError
=
finder
-
>
FindNext
(
&
didFind
)
;
return
didFind
;
}
bool
nsGlobalWindowInner
:
:
Find
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
FindOuter
(
aString
aCaseSensitive
aBackwards
aWrapAround
aWholeWord
aSearchInFrames
aShowDialog
aError
)
aError
false
)
;
}
void
nsGlobalWindowInner
:
:
GetOrigin
(
nsAString
&
aOrigin
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsInnerWindow
(
)
)
;
nsContentUtils
:
:
GetUTFOrigin
(
GetPrincipal
(
)
aOrigin
)
;
}
void
nsGlobalWindowInner
:
:
Atob
(
const
nsAString
&
aAsciiBase64String
nsAString
&
aBinaryData
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
aError
=
nsContentUtils
:
:
Atob
(
aAsciiBase64String
aBinaryData
)
;
}
void
nsGlobalWindowInner
:
:
Btoa
(
const
nsAString
&
aBinaryData
nsAString
&
aAsciiBase64String
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
aError
=
nsContentUtils
:
:
Btoa
(
aBinaryData
aAsciiBase64String
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetOwnerGlobalForBindings
(
)
{
if
(
IsOuterWindow
(
)
)
{
return
AsOuter
(
)
;
}
return
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
AsInner
(
)
)
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
RemoveEventListener
(
const
nsAString
&
aType
nsIDOMEventListener
*
aListener
bool
aUseCapture
)
{
if
(
RefPtr
<
EventListenerManager
>
elm
=
GetExistingListenerManager
(
)
)
{
elm
-
>
RemoveEventListener
(
aType
aListener
aUseCapture
)
;
}
return
NS_OK
;
}
NS_IMPL_REMOVE_SYSTEM_EVENT_LISTENER
(
nsGlobalWindowInner
)
NS_IMETHODIMP
nsGlobalWindowInner
:
:
DispatchEvent
(
nsIDOMEvent
*
aEvent
bool
*
aRetVal
)
{
FORWARD_TO_INNER
(
DispatchEvent
(
aEvent
aRetVal
)
NS_OK
)
;
if
(
!
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
{
NS_WARNING
(
"
DispatchEvent
called
on
non
-
current
inner
window
dropping
.
"
"
Please
check
the
window
in
the
caller
instead
.
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
!
mDoc
)
{
return
NS_ERROR_FAILURE
;
}
nsIPresShell
*
shell
=
mDoc
-
>
GetShell
(
)
;
RefPtr
<
nsPresContext
>
presContext
;
if
(
shell
)
{
presContext
=
shell
-
>
GetPresContext
(
)
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsresult
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
AsInner
(
)
nullptr
aEvent
presContext
&
status
)
;
*
aRetVal
=
(
status
!
=
nsEventStatus_eConsumeNoDefault
)
;
return
rv
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
AddEventListener
(
const
nsAString
&
aType
nsIDOMEventListener
*
aListener
bool
aUseCapture
bool
aWantsUntrusted
uint8_t
aOptionalArgc
)
{
NS_ASSERTION
(
!
aWantsUntrusted
|
|
aOptionalArgc
>
1
"
Won
'
t
check
if
this
is
chrome
you
want
to
set
"
"
aWantsUntrusted
to
false
or
make
the
aWantsUntrusted
"
"
explicit
by
making
optional_argc
non
-
zero
.
"
)
;
if
(
!
aWantsUntrusted
&
&
(
aOptionalArgc
<
2
&
&
!
nsContentUtils
:
:
IsChromeDoc
(
mDoc
)
)
)
{
aWantsUntrusted
=
true
;
}
EventListenerManager
*
manager
=
GetOrCreateListenerManager
(
)
;
NS_ENSURE_STATE
(
manager
)
;
manager
-
>
AddEventListener
(
aType
aListener
aUseCapture
aWantsUntrusted
)
;
return
NS_OK
;
}
void
nsGlobalWindowInner
:
:
AddEventListener
(
const
nsAString
&
aType
EventListener
*
aListener
const
AddEventListenerOptionsOrBoolean
&
aOptions
const
Nullable
<
bool
>
&
aWantsUntrusted
ErrorResult
&
aRv
)
{
if
(
IsOuterWindow
(
)
&
&
mInnerWindow
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
mInnerWindow
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
bool
wantsUntrusted
;
if
(
aWantsUntrusted
.
IsNull
(
)
)
{
wantsUntrusted
=
!
nsContentUtils
:
:
IsChromeDoc
(
mDoc
)
;
}
else
{
wantsUntrusted
=
aWantsUntrusted
.
Value
(
)
;
}
EventListenerManager
*
manager
=
GetOrCreateListenerManager
(
)
;
if
(
!
manager
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
manager
-
>
AddEventListener
(
aType
aListener
aOptions
wantsUntrusted
)
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
AddSystemEventListener
(
const
nsAString
&
aType
nsIDOMEventListener
*
aListener
bool
aUseCapture
bool
aWantsUntrusted
uint8_t
aOptionalArgc
)
{
NS_ASSERTION
(
!
aWantsUntrusted
|
|
aOptionalArgc
>
1
"
Won
'
t
check
if
this
is
chrome
you
want
to
set
"
"
aWantsUntrusted
to
false
or
make
the
aWantsUntrusted
"
"
explicit
by
making
optional_argc
non
-
zero
.
"
)
;
if
(
IsOuterWindow
(
)
&
&
mInnerWindow
&
&
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
mInnerWindow
)
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
if
(
!
aWantsUntrusted
&
&
(
aOptionalArgc
<
2
&
&
!
nsContentUtils
:
:
IsChromeDoc
(
mDoc
)
)
)
{
aWantsUntrusted
=
true
;
}
return
NS_AddSystemEventListener
(
this
aType
aListener
aUseCapture
aWantsUntrusted
)
;
}
EventListenerManager
*
nsGlobalWindowInner
:
:
GetOrCreateListenerManager
(
)
{
FORWARD_TO_INNER_CREATE
(
GetOrCreateListenerManager
(
)
nullptr
)
;
if
(
!
mListenerManager
)
{
mListenerManager
=
new
EventListenerManager
(
static_cast
<
EventTarget
*
>
(
this
)
)
;
}
return
mListenerManager
;
}
EventListenerManager
*
nsGlobalWindowInner
:
:
GetExistingListenerManager
(
)
const
{
FORWARD_TO_INNER
(
GetExistingListenerManager
(
)
nullptr
)
;
return
mListenerManager
;
}
nsIScriptContext
*
nsGlobalWindowInner
:
:
GetContextForEventHandlers
(
nsresult
*
aRv
)
{
*
aRv
=
NS_ERROR_UNEXPECTED
;
NS_ENSURE_TRUE
(
!
IsInnerWindow
(
)
|
|
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
nullptr
)
;
nsIScriptContext
*
scx
;
if
(
(
scx
=
GetContext
(
)
)
)
{
*
aRv
=
NS_OK
;
return
scx
;
}
return
nullptr
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetPrivateParent
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
GetParent
(
)
;
if
(
AsOuter
(
)
=
=
parent
)
{
nsCOMPtr
<
nsIContent
>
chromeElement
(
do_QueryInterface
(
mChromeEventHandler
)
)
;
if
(
!
chromeElement
)
return
nullptr
;
nsIDocument
*
doc
=
chromeElement
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
return
nullptr
;
return
doc
-
>
GetWindow
(
)
;
}
return
parent
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetPrivateRoot
(
)
{
if
(
IsInnerWindow
(
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
NS_WARNING
(
"
No
outer
window
available
!
"
)
;
return
nullptr
;
}
return
outer
-
>
GetPrivateRoot
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
GetTop
(
)
;
nsCOMPtr
<
nsIContent
>
chromeElement
(
do_QueryInterface
(
mChromeEventHandler
)
)
;
if
(
chromeElement
)
{
nsIDocument
*
doc
=
chromeElement
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
doc
-
>
GetWindow
(
)
;
if
(
parent
)
{
top
=
parent
-
>
GetTop
(
)
;
}
}
}
return
top
;
}
Location
*
nsGlobalWindowInner
:
:
GetLocation
(
)
{
FORWARD_TO_INNER
(
GetLocation
(
)
nullptr
)
;
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mLocation
)
{
mLocation
=
new
dom
:
:
Location
(
AsInner
(
)
GetDocShell
(
)
)
;
}
return
mLocation
;
}
void
nsGlobalWindowInner
:
:
ActivateOrDeactivate
(
bool
aActivate
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDoc
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
mainWidget
=
GetMainWidget
(
)
;
nsCOMPtr
<
nsIWidget
>
topLevelWidget
;
if
(
mainWidget
)
{
topLevelWidget
=
mainWidget
-
>
GetSheetWindowParent
(
)
;
if
(
!
topLevelWidget
)
{
topLevelWidget
=
mainWidget
;
}
}
SetActive
(
aActivate
)
;
if
(
mainWidget
!
=
topLevelWidget
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
topLevelWindow
;
nsIWidgetListener
*
listener
=
topLevelWidget
-
>
GetWidgetListener
(
)
;
if
(
listener
)
{
nsCOMPtr
<
nsIXULWindow
>
window
=
listener
-
>
GetXULWindow
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
req
(
do_QueryInterface
(
window
)
)
;
topLevelWindow
=
do_GetInterface
(
req
)
;
}
if
(
topLevelWindow
)
{
topLevelWindow
-
>
SetActive
(
aActivate
)
;
}
}
}
void
nsGlobalWindowInner
:
:
SetActive
(
bool
aActive
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
bool
nsGlobalWindowInner
:
:
IsTopLevelWindowActive
(
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
GetDocShell
(
)
)
;
if
(
!
treeItem
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
treeItem
-
>
GetRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
!
rootItem
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
rootItem
-
>
GetWindow
(
)
;
return
domWindow
&
&
domWindow
-
>
IsActive
(
)
;
}
void
nsGlobalWindowInner
:
:
SetIsBackground
(
bool
aIsBackground
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
bool
changed
=
aIsBackground
!
=
AsOuter
(
)
-
>
IsBackground
(
)
;
SetIsBackgroundInternal
(
aIsBackground
)
;
nsGlobalWindowInner
*
inner
=
GetCurrentInnerWindowInternal
(
)
;
if
(
inner
&
&
changed
)
{
inner
-
>
mTimeoutManager
-
>
UpdateBackgroundState
(
)
;
}
if
(
aIsBackground
)
{
if
(
inner
&
&
changed
)
{
inner
-
>
StopGamepadHaptics
(
)
;
inner
-
>
ResetVRTelemetry
(
true
)
;
}
return
;
}
if
(
inner
)
{
inner
-
>
ResetVRTelemetry
(
false
)
;
inner
-
>
SyncGamepadState
(
)
;
}
}
void
nsGlobalWindowInner
:
:
SetIsBackgroundInternal
(
bool
aIsBackground
)
{
if
(
mIsBackground
!
=
aIsBackground
)
{
TabGroup
(
)
-
>
WindowChangedBackgroundStatus
(
aIsBackground
)
;
}
mIsBackground
=
aIsBackground
;
}
void
nsGlobalWindowInner
:
:
MaybeUpdateTouchState
(
)
{
FORWARD_TO_INNER_VOID
(
MaybeUpdateTouchState
(
)
)
;
if
(
mMayHaveTouchEventListener
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
DOM_TOUCH_LISTENER_ADDED
nullptr
)
;
}
}
}
void
nsGlobalWindowInner
:
:
EnableGamepadUpdates
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mHasGamepad
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
if
(
gamepadManager
)
{
gamepadManager
-
>
AddListener
(
AssertInner
(
)
)
;
}
}
}
void
nsGlobalWindowInner
:
:
DisableGamepadUpdates
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mHasGamepad
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
if
(
gamepadManager
)
{
gamepadManager
-
>
RemoveListener
(
AssertInner
(
)
)
;
}
}
}
void
nsGlobalWindowInner
:
:
EnableVRUpdates
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mHasVREvents
&
&
!
mVREventObserver
)
{
mVREventObserver
=
new
VREventObserver
(
AssertInner
(
)
)
;
}
}
void
nsGlobalWindowInner
:
:
DisableVRUpdates
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mVREventObserver
)
{
mVREventObserver
-
>
DisconnectFromOwner
(
)
;
mVREventObserver
=
nullptr
;
}
}
void
nsGlobalWindowInner
:
:
ResetVRTelemetry
(
bool
aUpdate
)
{
if
(
mVREventObserver
)
{
mVREventObserver
-
>
UpdateSpentTimeIn2DTelemetry
(
aUpdate
)
;
}
}
void
nsGlobalWindowInner
:
:
SetChromeEventHandler
(
EventTarget
*
aChromeEventHandler
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
SetChromeEventHandlerInternal
(
aChromeEventHandler
)
;
RefPtr
<
nsGlobalWindowInner
>
inner
;
for
(
PRCList
*
node
=
PR_LIST_HEAD
(
this
)
;
node
!
=
this
;
node
=
PR_NEXT_LINK
(
inner
)
)
{
inner
=
static_cast
<
nsGlobalWindowInner
*
>
(
node
)
;
NS_ASSERTION
(
!
inner
-
>
mOuterWindow
|
|
inner
-
>
mOuterWindow
=
=
AsOuter
(
)
"
bad
outer
window
pointer
"
)
;
inner
-
>
SetChromeEventHandlerInternal
(
aChromeEventHandler
)
;
}
}
void
nsGlobalWindowInner
:
:
SetFocusedNode
(
nsIContent
*
aNode
uint32_t
aFocusMethod
bool
aNeedsFocus
)
{
FORWARD_TO_INNER_VOID
(
SetFocusedNode
(
aNode
aFocusMethod
aNeedsFocus
)
)
;
if
(
aNode
&
&
aNode
-
>
GetComposedDoc
(
)
!
=
mDoc
)
{
NS_WARNING
(
"
Trying
to
set
focus
to
a
node
from
a
wrong
document
"
)
;
return
;
}
if
(
mCleanedUp
)
{
NS_ASSERTION
(
!
aNode
"
Trying
to
focus
cleaned
up
window
!
"
)
;
aNode
=
nullptr
;
aNeedsFocus
=
false
;
}
if
(
mFocusedNode
!
=
aNode
)
{
UpdateCanvasFocus
(
false
aNode
)
;
mFocusedNode
=
aNode
;
mFocusMethod
=
aFocusMethod
&
FOCUSMETHOD_MASK
;
mShowFocusRingForContent
=
false
;
}
if
(
mFocusedNode
)
{
if
(
mFocusMethod
&
nsIFocusManager
:
:
FLAG_BYKEY
)
{
mFocusByKeyOccurred
=
true
;
}
else
if
(
#
ifndef
XP_WIN
!
(
mFocusMethod
&
nsIFocusManager
:
:
FLAG_BYMOUSE
)
|
|
ShouldShowFocusRingIfFocusedByMouse
(
aNode
)
|
|
#
endif
aFocusMethod
&
nsIFocusManager
:
:
FLAG_SHOWRING
)
{
mShowFocusRingForContent
=
true
;
}
}
if
(
aNeedsFocus
)
mNeedsFocus
=
aNeedsFocus
;
}
uint32_t
nsGlobalWindowInner
:
:
GetFocusMethod
(
)
{
FORWARD_TO_INNER
(
GetFocusMethod
(
)
0
)
;
return
mFocusMethod
;
}
bool
nsGlobalWindowInner
:
:
ShouldShowFocusRing
(
)
{
FORWARD_TO_INNER
(
ShouldShowFocusRing
(
)
false
)
;
if
(
mShowFocusRingForContent
|
|
mFocusByKeyOccurred
)
{
return
true
;
}
nsCOMPtr
<
nsPIWindowRoot
>
root
=
GetTopWindowRoot
(
)
;
return
root
?
root
-
>
ShowFocusRings
(
)
:
false
;
}
void
nsGlobalWindowInner
:
:
SetKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsPIDOMWindowOuter
*
piWin
=
GetPrivateRoot
(
)
;
if
(
!
piWin
)
{
return
;
}
MOZ_ASSERT
(
piWin
=
=
AsOuter
(
)
)
;
bool
oldShouldShowFocusRing
=
ShouldShowFocusRing
(
)
;
nsCOMPtr
<
nsPIWindowRoot
>
windowRoot
=
do_QueryInterface
(
mChromeEventHandler
)
;
if
(
!
windowRoot
)
{
return
;
}
if
(
aShowAccelerators
!
=
UIStateChangeType_NoChange
)
{
windowRoot
-
>
SetShowAccelerators
(
aShowAccelerators
=
=
UIStateChangeType_Set
)
;
}
if
(
aShowFocusRings
!
=
UIStateChangeType_NoChange
)
{
windowRoot
-
>
SetShowFocusRings
(
aShowFocusRings
=
=
UIStateChangeType_Set
)
;
}
nsContentUtils
:
:
SetKeyboardIndicatorsOnRemoteChildren
(
GetOuterWindow
(
)
aShowAccelerators
aShowFocusRings
)
;
bool
newShouldShowFocusRing
=
ShouldShowFocusRing
(
)
;
if
(
mHasFocus
&
&
mFocusedNode
&
&
oldShouldShowFocusRing
!
=
newShouldShowFocusRing
&
&
mFocusedNode
-
>
IsElement
(
)
)
{
if
(
newShouldShowFocusRing
)
{
mFocusedNode
-
>
AsElement
(
)
-
>
AddStates
(
NS_EVENT_STATE_FOCUSRING
)
;
}
else
{
mFocusedNode
-
>
AsElement
(
)
-
>
RemoveStates
(
NS_EVENT_STATE_FOCUSRING
)
;
}
}
}
bool
nsGlobalWindowInner
:
:
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
{
FORWARD_TO_INNER
(
TakeFocus
(
aFocus
aFocusMethod
)
false
)
;
if
(
mCleanedUp
)
{
return
false
;
}
if
(
aFocus
)
mFocusMethod
=
aFocusMethod
&
FOCUSMETHOD_MASK
;
if
(
mHasFocus
!
=
aFocus
)
{
mHasFocus
=
aFocus
;
UpdateCanvasFocus
(
true
mFocusedNode
)
;
}
if
(
aFocus
&
&
mNeedsFocus
&
&
mDoc
&
&
mDoc
-
>
GetRootElement
(
)
!
=
nullptr
)
{
mNeedsFocus
=
false
;
return
true
;
}
mNeedsFocus
=
false
;
return
false
;
}
void
nsGlobalWindowInner
:
:
SetReadyForFocus
(
)
{
FORWARD_TO_INNER_VOID
(
SetReadyForFocus
(
)
)
;
bool
oldNeedsFocus
=
mNeedsFocus
;
mNeedsFocus
=
false
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
fm
-
>
WindowShown
(
GetOuterWindow
(
)
oldNeedsFocus
)
;
}
}
void
nsGlobalWindowInner
:
:
PageHidden
(
)
{
FORWARD_TO_INNER_VOID
(
PageHidden
(
)
)
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
fm
-
>
WindowHidden
(
GetOuterWindow
(
)
)
;
}
mNeedsFocus
=
true
;
}
class
HashchangeCallback
:
public
Runnable
{
public
:
HashchangeCallback
(
const
nsAString
&
aOldURL
const
nsAString
&
aNewURL
nsGlobalWindowInner
*
aWindow
)
:
mozilla
:
:
Runnable
(
"
HashchangeCallback
"
)
mWindow
(
aWindow
)
{
MOZ_ASSERT
(
mWindow
)
;
MOZ_ASSERT
(
mWindow
-
>
IsInnerWindow
(
)
)
;
mOldURL
.
Assign
(
aOldURL
)
;
mNewURL
.
Assign
(
aNewURL
)
;
}
NS_IMETHOD
Run
(
)
override
{
NS_PRECONDITION
(
NS_IsMainThread
(
)
"
Should
be
called
on
the
main
thread
.
"
)
;
return
mWindow
-
>
FireHashchange
(
mOldURL
mNewURL
)
;
}
private
:
nsString
mOldURL
;
nsString
mNewURL
;
RefPtr
<
nsGlobalWindowInner
>
mWindow
;
}
;
nsresult
nsGlobalWindowInner
:
:
DispatchAsyncHashchange
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
bool
equal
=
false
;
NS_ENSURE_STATE
(
NS_SUCCEEDED
(
aOldURI
-
>
EqualsExceptRef
(
aNewURI
&
equal
)
)
&
&
equal
)
;
nsAutoCString
oldHash
newHash
;
bool
oldHasHash
newHasHash
;
NS_ENSURE_STATE
(
NS_SUCCEEDED
(
aOldURI
-
>
GetRef
(
oldHash
)
)
&
&
NS_SUCCEEDED
(
aNewURI
-
>
GetRef
(
newHash
)
)
&
&
NS_SUCCEEDED
(
aOldURI
-
>
GetHasRef
(
&
oldHasHash
)
)
&
&
NS_SUCCEEDED
(
aNewURI
-
>
GetHasRef
(
&
newHasHash
)
)
&
&
(
oldHasHash
!
=
newHasHash
|
|
!
oldHash
.
Equals
(
newHash
)
)
)
;
nsAutoCString
oldSpec
newSpec
;
nsresult
rv
=
aOldURI
-
>
GetSpec
(
oldSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aNewURI
-
>
GetSpec
(
newSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
oldWideSpec
(
oldSpec
)
;
NS_ConvertUTF8toUTF16
newWideSpec
(
newSpec
)
;
nsCOMPtr
<
nsIRunnable
>
callback
=
new
HashchangeCallback
(
oldWideSpec
newWideSpec
AssertInner
(
)
)
;
return
Dispatch
(
TaskCategory
:
:
Other
callback
.
forget
(
)
)
;
}
nsresult
nsGlobalWindowInner
:
:
FireHashchange
(
const
nsAString
&
aOldURL
const
nsAString
&
aNewURL
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
IsFrozen
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
;
nsIPresShell
*
shell
=
mDoc
-
>
GetShell
(
)
;
RefPtr
<
nsPresContext
>
presContext
;
if
(
shell
)
{
presContext
=
shell
-
>
GetPresContext
(
)
;
}
HashChangeEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
false
;
init
.
mNewURL
=
aNewURL
;
init
.
mOldURL
=
aOldURL
;
RefPtr
<
HashChangeEvent
>
event
=
HashChangeEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
hashchange
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
dummy
;
return
DispatchEvent
(
event
&
dummy
)
;
}
nsresult
nsGlobalWindowInner
:
:
DispatchSyncPopState
(
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Must
be
safe
to
run
script
here
.
"
)
;
nsresult
rv
=
NS_OK
;
if
(
IsFrozen
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIVariant
>
stateObj
;
rv
=
mDoc
-
>
GetStateObject
(
getter_AddRefs
(
stateObj
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIPresShell
*
shell
=
mDoc
-
>
GetShell
(
)
;
RefPtr
<
nsPresContext
>
presContext
;
if
(
shell
)
{
presContext
=
shell
-
>
GetPresContext
(
)
;
}
bool
result
=
true
;
AutoJSAPI
jsapi
;
result
=
jsapi
.
Init
(
AsInner
(
)
)
;
NS_ENSURE_TRUE
(
result
NS_ERROR_FAILURE
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
stateJSValue
(
cx
JS
:
:
NullValue
(
)
)
;
result
=
stateObj
?
VariantToJsval
(
cx
stateObj
&
stateJSValue
)
:
true
;
NS_ENSURE_TRUE
(
result
NS_ERROR_FAILURE
)
;
RootedDictionary
<
PopStateEventInit
>
init
(
cx
)
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
false
;
init
.
mState
=
stateJSValue
;
RefPtr
<
PopStateEvent
>
event
=
PopStateEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
popstate
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
SetTarget
(
this
)
;
bool
dummy
;
return
DispatchEvent
(
event
&
dummy
)
;
}
static
nsCanvasFrame
*
FindCanvasFrame
(
nsIFrame
*
aFrame
)
{
nsCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
canvasFrame
)
{
return
canvasFrame
;
}
for
(
nsIFrame
*
kid
:
aFrame
-
>
PrincipalChildList
(
)
)
{
canvasFrame
=
FindCanvasFrame
(
kid
)
;
if
(
canvasFrame
)
{
return
canvasFrame
;
}
}
return
nullptr
;
}
void
nsGlobalWindowInner
:
:
UpdateCanvasFocus
(
bool
aFocusChanged
nsIContent
*
aNewContent
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
!
docShell
)
return
;
bool
editable
;
docShell
-
>
GetEditable
(
&
editable
)
;
if
(
editable
)
return
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
|
|
!
mDoc
)
return
;
Element
*
rootElement
=
mDoc
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
if
(
(
mHasFocus
|
|
aFocusChanged
)
&
&
(
mFocusedNode
=
=
rootElement
|
|
aNewContent
=
=
rootElement
)
)
{
nsIFrame
*
frame
=
rootElement
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
=
frame
-
>
GetParent
(
)
;
nsCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
frame
)
;
if
(
canvasFrame
)
{
canvasFrame
-
>
SetHasFocus
(
mHasFocus
&
&
rootElement
=
=
aNewContent
)
;
}
}
}
}
else
{
nsIFrame
*
frame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
frame
)
{
nsCanvasFrame
*
canvasFrame
=
FindCanvasFrame
(
frame
)
;
if
(
canvasFrame
)
{
canvasFrame
-
>
SetHasFocus
(
false
)
;
}
}
}
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowInner
:
:
GetComputedStyle
(
Element
&
aElt
const
nsAString
&
aPseudoElt
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
GetComputedStyleHelper
(
aElt
aPseudoElt
false
aError
)
;
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowInner
:
:
GetDefaultComputedStyle
(
Element
&
aElt
const
nsAString
&
aPseudoElt
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
GetComputedStyleHelper
(
aElt
aPseudoElt
true
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetComputedStyleHelper
(
nsIDOMElement
*
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
nsIDOMCSSStyleDeclaration
*
*
aReturn
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
*
aReturn
=
nullptr
;
nsCOMPtr
<
dom
:
:
Element
>
element
=
do_QueryInterface
(
aElt
)
;
if
(
!
element
)
{
return
NS_ERROR_DOM_NOT_SUPPORTED_ERR
;
}
ErrorResult
rv
;
nsCOMPtr
<
nsIDOMCSSStyleDeclaration
>
declaration
=
GetComputedStyleHelper
(
*
element
aPseudoElt
aDefaultStylesOnly
rv
)
;
declaration
.
forget
(
aReturn
)
;
return
rv
.
StealNSResult
(
)
;
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowInner
:
:
GetComputedStyleHelperOuter
(
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
auto
*
parent
=
nsGlobalWindowOuter
:
:
Cast
(
GetPrivateParent
(
)
)
;
if
(
!
parent
)
{
return
nullptr
;
}
parent
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
}
RefPtr
<
nsComputedDOMStyle
>
compStyle
=
NS_NewComputedDOMStyle
(
&
aElt
aPseudoElt
presShell
aDefaultStylesOnly
?
nsComputedDOMStyle
:
:
eDefaultOnly
:
nsComputedDOMStyle
:
:
eAll
)
;
return
compStyle
.
forget
(
)
;
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowInner
:
:
GetComputedStyleHelper
(
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetComputedStyleHelperOuter
(
aElt
aPseudoElt
aDefaultStylesOnly
)
aError
nullptr
)
;
}
Storage
*
nsGlobalWindowInner
:
:
GetSessionStorage
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
!
principal
|
|
!
docShell
|
|
!
Preferences
:
:
GetBool
(
kStorageEnabled
)
)
{
return
nullptr
;
}
if
(
mSessionStorage
)
{
MOZ_LOG
(
gDOMLeakPRLog
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
has
%
p
sessionStorage
"
this
mSessionStorage
.
get
(
)
)
)
;
bool
canAccess
=
principal
-
>
Subsumes
(
mSessionStorage
-
>
Principal
(
)
)
;
NS_ASSERTION
(
canAccess
"
This
window
owned
sessionStorage
"
"
that
could
not
be
accessed
!
"
)
;
if
(
!
canAccess
)
{
mSessionStorage
=
nullptr
;
}
}
if
(
!
mSessionStorage
)
{
nsString
documentURI
;
if
(
mDoc
)
{
aError
=
mDoc
-
>
GetDocumentURI
(
documentURI
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
if
(
!
mDoc
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_QueryInterface
(
docShell
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIDOMStorage
>
storage
;
aError
=
storageManager
-
>
CreateStorage
(
AsInner
(
)
principal
documentURI
IsPrivateBrowsing
(
)
getter_AddRefs
(
storage
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
mSessionStorage
=
static_cast
<
Storage
*
>
(
storage
.
get
(
)
)
;
MOZ_ASSERT
(
mSessionStorage
)
;
MOZ_LOG
(
gDOMLeakPRLog
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
tried
to
get
a
new
sessionStorage
%
p
"
this
mSessionStorage
.
get
(
)
)
)
;
if
(
!
mSessionStorage
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
}
MOZ_LOG
(
gDOMLeakPRLog
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
returns
%
p
sessionStorage
"
this
mSessionStorage
.
get
(
)
)
)
;
return
mSessionStorage
;
}
Storage
*
nsGlobalWindowInner
:
:
GetLocalStorage
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
Preferences
:
:
GetBool
(
kStorageEnabled
)
)
{
return
nullptr
;
}
if
(
!
mLocalStorage
)
{
if
(
nsContentUtils
:
:
StorageAllowedForWindow
(
AsInner
(
)
)
=
=
nsContentUtils
:
:
StorageAccess
:
:
eDeny
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
return
nullptr
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_GetService
(
"
mozilla
.
org
/
dom
/
localStorage
-
manager
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
nsString
documentURI
;
if
(
mDoc
)
{
aError
=
mDoc
-
>
GetDocumentURI
(
documentURI
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
nsCOMPtr
<
nsIDOMStorage
>
storage
;
aError
=
storageManager
-
>
CreateStorage
(
AsInner
(
)
principal
documentURI
IsPrivateBrowsing
(
)
getter_AddRefs
(
storage
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
mLocalStorage
=
static_cast
<
Storage
*
>
(
storage
.
get
(
)
)
;
MOZ_ASSERT
(
mLocalStorage
)
;
}
return
mLocalStorage
;
}
IDBFactory
*
nsGlobalWindowInner
:
:
GetIndexedDB
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mIndexedDB
)
{
aError
=
IDBFactory
:
:
CreateForWindow
(
AsInner
(
)
getter_AddRefs
(
mIndexedDB
)
)
;
}
return
mIndexedDB
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
NS_ENSURE_ARG_POINTER
(
aSink
)
;
*
aSink
=
nullptr
;
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDocCharset
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
NS_WARNING
(
"
Using
deprecated
nsIDocCharset
:
use
nsIDocShell
.
GetCharset
(
)
instead
"
)
;
nsCOMPtr
<
nsIDocCharset
>
docCharset
(
do_QueryInterface
(
outer
-
>
mDocShell
)
)
;
docCharset
.
forget
(
aSink
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebNavigation
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
outer
-
>
mDocShell
)
)
;
webNav
.
forget
(
aSink
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDocShell
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
outer
-
>
mDocShell
;
docShell
.
forget
(
aSink
)
;
}
#
ifdef
NS_PRINTING
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIWebBrowserPrint
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
if
(
outer
-
>
mDocShell
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
;
outer
-
>
mDocShell
-
>
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
nsCOMPtr
<
nsIWebBrowserPrint
>
webBrowserPrint
(
do_QueryInterface
(
viewer
)
)
;
webBrowserPrint
.
forget
(
aSink
)
;
}
}
}
#
endif
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMWindowUtils
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
if
(
!
mWindowUtils
)
{
mWindowUtils
=
new
nsDOMWindowUtils
(
outer
)
;
}
*
aSink
=
mWindowUtils
;
NS_ADDREF
(
(
(
nsISupports
*
)
*
aSink
)
)
;
}
else
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsILoadContext
)
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
(
do_QueryInterface
(
outer
-
>
mDocShell
)
)
;
loadContext
.
forget
(
aSink
)
;
}
else
{
return
QueryInterface
(
aIID
aSink
)
;
}
return
*
aSink
?
NS_OK
:
NS_ERROR_NO_INTERFACE
;
}
void
nsGlobalWindowInner
:
:
GetInterface
(
JSContext
*
aCx
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
dom
:
:
GetInterface
(
aCx
this
aIID
aRetval
aError
)
;
}
already_AddRefed
<
CacheStorage
>
nsGlobalWindowInner
:
:
GetCaches
(
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mCacheStorage
)
{
bool
forceTrustedOrigin
=
GetOuterWindow
(
)
-
>
GetServiceWorkersTestingEnabled
(
)
;
nsContentUtils
:
:
StorageAccess
access
=
nsContentUtils
:
:
StorageAllowedForWindow
(
AsInner
(
)
)
;
bool
storageBlocked
=
access
<
=
nsContentUtils
:
:
StorageAccess
:
:
ePrivateBrowsing
;
mCacheStorage
=
CacheStorage
:
:
CreateOnMainThread
(
cache
:
:
DEFAULT_NAMESPACE
this
GetPrincipal
(
)
storageBlocked
forceTrustedOrigin
aRv
)
;
}
RefPtr
<
CacheStorage
>
ref
=
mCacheStorage
;
return
ref
.
forget
(
)
;
}
already_AddRefed
<
ServiceWorkerRegistration
>
nsPIDOMWindowInner
:
:
GetServiceWorkerRegistration
(
const
nsAString
&
aScope
)
{
RefPtr
<
ServiceWorkerRegistration
>
registration
;
if
(
!
mServiceWorkerRegistrationTable
.
Get
(
aScope
getter_AddRefs
(
registration
)
)
)
{
registration
=
ServiceWorkerRegistration
:
:
CreateForMainThread
(
this
aScope
)
;
mServiceWorkerRegistrationTable
.
Put
(
aScope
registration
)
;
}
return
registration
.
forget
(
)
;
}
void
nsPIDOMWindowInner
:
:
InvalidateServiceWorkerRegistration
(
const
nsAString
&
aScope
)
{
mServiceWorkerRegistrationTable
.
Remove
(
aScope
)
;
}
void
nsGlobalWindowInner
:
:
FireOfflineStatusEventIfChanged
(
)
{
if
(
!
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
return
;
if
(
mWasOffline
=
=
NS_IsOffline
(
)
)
{
return
;
}
mWasOffline
=
!
mWasOffline
;
nsAutoString
name
;
if
(
mWasOffline
)
{
name
.
AssignLiteral
(
"
offline
"
)
;
}
else
{
name
.
AssignLiteral
(
"
online
"
)
;
}
nsCOMPtr
<
EventTarget
>
eventTarget
=
mDoc
.
get
(
)
;
nsHTMLDocument
*
htmlDoc
=
mDoc
-
>
AsHTMLDocument
(
)
;
if
(
htmlDoc
)
{
Element
*
body
=
htmlDoc
-
>
GetBody
(
)
;
if
(
body
)
{
eventTarget
=
body
;
}
}
else
{
Element
*
documentElement
=
mDoc
-
>
GetDocumentElement
(
)
;
if
(
documentElement
)
{
eventTarget
=
documentElement
;
}
}
nsContentUtils
:
:
DispatchTrustedEvent
(
mDoc
eventTarget
name
true
false
)
;
}
class
NotifyIdleObserverRunnable
:
public
Runnable
{
public
:
NotifyIdleObserverRunnable
(
nsIIdleObserver
*
aIdleObserver
uint32_t
aTimeInS
bool
aCallOnidle
nsGlobalWindowInner
*
aIdleWindow
)
:
mozilla
:
:
Runnable
(
"
NotifyIdleObserverRunnable
"
)
mIdleObserver
(
aIdleObserver
)
mTimeInS
(
aTimeInS
)
mIdleWindow
(
aIdleWindow
)
mCallOnidle
(
aCallOnidle
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mIdleWindow
-
>
ContainsIdleObserver
(
mIdleObserver
mTimeInS
)
)
{
return
mCallOnidle
?
mIdleObserver
-
>
Onidle
(
)
:
mIdleObserver
-
>
Onactive
(
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIIdleObserver
>
mIdleObserver
;
uint32_t
mTimeInS
;
RefPtr
<
nsGlobalWindowInner
>
mIdleWindow
;
bool
mCallOnidle
;
}
;
void
nsGlobalWindowInner
:
:
NotifyIdleObserver
(
IdleObserverHolder
*
aIdleObserverHolder
bool
aCallOnidle
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
MOZ_ASSERT
(
aIdleObserverHolder
)
;
aIdleObserverHolder
-
>
mPrevNotificationIdle
=
aCallOnidle
;
nsCOMPtr
<
nsIRunnable
>
caller
=
new
NotifyIdleObserverRunnable
(
aIdleObserverHolder
-
>
mIdleObserver
aIdleObserverHolder
-
>
mTimeInS
aCallOnidle
AssertInner
(
)
)
;
if
(
NS_FAILED
(
Dispatch
(
TaskCategory
:
:
Other
caller
.
forget
(
)
)
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
thread
for
idle
observer
notification
.
"
)
;
}
}
bool
nsGlobalWindowInner
:
:
ContainsIdleObserver
(
nsIIdleObserver
*
aIdleObserver
uint32_t
aTimeInS
)
{
MOZ_ASSERT
(
aIdleObserver
"
Idle
observer
not
instantiated
.
"
)
;
bool
found
=
false
;
nsTObserverArray
<
IdleObserverHolder
>
:
:
ForwardIterator
iter
(
mIdleObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
IdleObserverHolder
&
idleObserver
=
iter
.
GetNext
(
)
;
if
(
idleObserver
.
mIdleObserver
=
=
aIdleObserver
&
&
idleObserver
.
mTimeInS
=
=
aTimeInS
)
{
found
=
true
;
break
;
}
}
return
found
;
}
void
IdleActiveTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
nsGlobalWindowInner
>
idleWindow
=
static_cast
<
nsGlobalWindowInner
*
>
(
aClosure
)
;
MOZ_ASSERT
(
idleWindow
"
Idle
window
has
not
been
instantiated
.
"
)
;
idleWindow
-
>
HandleIdleActiveEvent
(
)
;
}
void
IdleObserverTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
nsGlobalWindowInner
>
idleWindow
=
static_cast
<
nsGlobalWindowInner
*
>
(
aClosure
)
;
MOZ_ASSERT
(
idleWindow
"
Idle
window
has
not
been
instantiated
.
"
)
;
idleWindow
-
>
HandleIdleObserverCallback
(
)
;
}
void
nsGlobalWindowInner
:
:
HandleIdleObserverCallback
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
MOZ_ASSERT
(
static_cast
<
uint32_t
>
(
mIdleCallbackIndex
)
<
mIdleObservers
.
Length
(
)
"
Idle
callback
index
exceeds
array
bounds
!
"
)
;
IdleObserverHolder
&
idleObserver
=
mIdleObservers
.
ElementAt
(
mIdleCallbackIndex
)
;
NotifyIdleObserver
(
&
idleObserver
true
)
;
mIdleCallbackIndex
+
+
;
if
(
NS_FAILED
(
ScheduleNextIdleObserverCallback
(
)
)
)
{
NS_WARNING
(
"
Failed
to
set
next
idle
observer
callback
.
"
)
;
}
}
nsresult
nsGlobalWindowInner
:
:
ScheduleNextIdleObserverCallback
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
MOZ_ASSERT
(
mIdleService
"
No
idle
service
!
"
)
;
if
(
mIdleCallbackIndex
<
0
|
|
static_cast
<
uint32_t
>
(
mIdleCallbackIndex
)
>
=
mIdleObservers
.
Length
(
)
)
{
return
NS_OK
;
}
IdleObserverHolder
&
idleObserver
=
mIdleObservers
.
ElementAt
(
mIdleCallbackIndex
)
;
uint32_t
userIdleTimeMS
=
0
;
nsresult
rv
=
mIdleService
-
>
GetIdleTime
(
&
userIdleTimeMS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
callbackTimeMS
=
0
;
if
(
idleObserver
.
mTimeInS
*
1000
+
mIdleFuzzFactor
>
userIdleTimeMS
)
{
callbackTimeMS
=
idleObserver
.
mTimeInS
*
1000
-
userIdleTimeMS
+
mIdleFuzzFactor
;
}
mIdleTimer
-
>
Cancel
(
)
;
rv
=
mIdleTimer
-
>
InitWithNamedFuncCallback
(
IdleObserverTimerCallback
AssertInner
(
)
callbackTimeMS
nsITimer
:
:
TYPE_ONE_SHOT
"
nsGlobalWindowInner
:
:
ScheduleNextIdleObserverCallback
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
uint32_t
nsGlobalWindowInner
:
:
GetFuzzTimeMS
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
if
(
gIdleObserversAPIFuzzTimeDisabled
)
{
return
0
;
}
uint32_t
randNum
=
MAX_IDLE_FUZZ_TIME_MS
;
size_t
nbytes
=
PR_GetRandomNoise
(
&
randNum
sizeof
(
randNum
)
)
;
if
(
nbytes
!
=
sizeof
(
randNum
)
)
{
NS_WARNING
(
"
PR_GetRandomNoise
(
.
.
.
)
Not
implemented
or
no
available
noise
!
"
)
;
return
MAX_IDLE_FUZZ_TIME_MS
;
}
if
(
randNum
>
MAX_IDLE_FUZZ_TIME_MS
)
{
randNum
%
=
MAX_IDLE_FUZZ_TIME_MS
;
}
return
randNum
;
}
nsresult
nsGlobalWindowInner
:
:
ScheduleActiveTimerCallback
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
if
(
!
mAddActiveEventFuzzTime
)
{
return
HandleIdleActiveEvent
(
)
;
}
MOZ_ASSERT
(
mIdleTimer
)
;
mIdleTimer
-
>
Cancel
(
)
;
uint32_t
fuzzFactorInMS
=
GetFuzzTimeMS
(
)
;
nsresult
rv
=
mIdleTimer
-
>
InitWithNamedFuncCallback
(
IdleActiveTimerCallback
AssertInner
(
)
fuzzFactorInMS
nsITimer
:
:
TYPE_ONE_SHOT
"
nsGlobalWindowInner
:
:
ScheduleActiveTimerCallback
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
HandleIdleActiveEvent
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
if
(
mCurrentlyIdle
)
{
mIdleCallbackIndex
=
0
;
mIdleFuzzFactor
=
GetFuzzTimeMS
(
)
;
nsresult
rv
=
ScheduleNextIdleObserverCallback
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
mIdleCallbackIndex
=
-
1
;
MOZ_ASSERT
(
mIdleTimer
)
;
mIdleTimer
-
>
Cancel
(
)
;
nsTObserverArray
<
IdleObserverHolder
>
:
:
ForwardIterator
iter
(
mIdleObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
IdleObserverHolder
&
idleObserver
=
iter
.
GetNext
(
)
;
if
(
idleObserver
.
mPrevNotificationIdle
)
{
NotifyIdleObserver
(
&
idleObserver
false
)
;
}
}
return
NS_OK
;
}
nsGlobalWindowInner
:
:
SlowScriptResponse
nsGlobalWindowInner
:
:
ShowSlowScriptDialog
(
const
nsString
&
aAddonId
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsresult
rv
;
AutoJSContext
cx
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
always_stop_slow_scripts
"
)
)
{
return
KillSlowScript
;
}
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
JS_ReportWarningASCII
(
cx
"
A
long
running
script
was
terminated
"
)
;
return
KillSlowScript
;
}
if
(
!
AsInner
(
)
-
>
HasActiveDocument
(
)
)
{
return
KillSlowScript
;
}
JS
:
:
AutoFilename
filename
;
unsigned
lineno
;
unsigned
*
linenop
=
XRE_IsParentProcess
(
)
?
&
lineno
:
nullptr
;
bool
hasFrame
=
JS
:
:
DescribeScriptedCaller
(
cx
&
filename
linenop
)
;
if
(
!
mHasHadSlowScript
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SLOW_SCRIPT_PAGE_COUNT
1
)
;
}
mHasHadSlowScript
=
true
;
if
(
XRE_IsContentProcess
(
)
&
&
ProcessHangMonitor
:
:
Get
(
)
)
{
ProcessHangMonitor
:
:
SlowScriptAction
action
;
RefPtr
<
ProcessHangMonitor
>
monitor
=
ProcessHangMonitor
:
:
Get
(
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
nsCOMPtr
<
nsITabChild
>
child
=
docShell
?
docShell
-
>
GetTabChild
(
)
:
nullptr
;
action
=
monitor
-
>
NotifySlowScript
(
child
filename
.
get
(
)
aAddonId
)
;
if
(
action
=
=
ProcessHangMonitor
:
:
Terminate
)
{
return
KillSlowScript
;
}
if
(
action
=
=
ProcessHangMonitor
:
:
TerminateGlobal
)
{
return
KillScriptGlobal
;
}
if
(
action
=
=
ProcessHangMonitor
:
:
StartDebugger
)
{
RefPtr
<
nsGlobalWindowOuter
>
outer
=
GetOuterWindowInternal
(
)
;
outer
-
>
EnterModalState
(
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
monitor
-
>
IsDebuggerStartupComplete
(
)
;
}
)
;
outer
-
>
LeaveModalState
(
)
;
return
ContinueSlowScript
;
}
return
ContinueSlowScriptAndKeepNotifying
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SLOW_SCRIPT_NOTICE_COUNT
1
)
;
nsCOMPtr
<
nsIDocShell
>
ds
=
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
ds
KillSlowScript
)
;
nsCOMPtr
<
nsIPrompt
>
prompt
=
do_GetInterface
(
ds
)
;
NS_ENSURE_TRUE
(
prompt
KillSlowScript
)
;
nsCOMPtr
<
nsISlowScriptDebugCallback
>
debugCallback
;
if
(
hasFrame
)
{
const
char
*
debugCID
=
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
;
nsCOMPtr
<
nsISlowScriptDebug
>
debugService
=
do_GetService
(
debugCID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
debugService
-
>
GetActivationHandler
(
getter_AddRefs
(
debugCallback
)
)
;
}
}
bool
failed
=
false
;
auto
getString
=
[
&
]
(
const
char
*
name
nsContentUtils
:
:
PropertiesFile
propFile
=
nsContentUtils
:
:
eDOM_PROPERTIES
)
{
nsAutoString
result
;
nsresult
rv
=
nsContentUtils
:
:
GetLocalizedString
(
propFile
name
result
)
;
failed
=
failed
|
|
NS_FAILED
(
rv
)
|
|
result
.
IsEmpty
(
)
;
return
Move
(
result
)
;
}
;
bool
isAddonScript
=
!
aAddonId
.
IsEmpty
(
)
;
bool
showDebugButton
=
debugCallback
&
&
!
isAddonScript
;
nsAutoString
title
checkboxMsg
debugButton
msg
;
if
(
isAddonScript
)
{
title
=
getString
(
"
KillAddonScriptTitle
"
)
;
checkboxMsg
=
getString
(
"
KillAddonScriptGlobalMessage
"
)
;
auto
appName
=
getString
(
"
brandShortName
"
nsContentUtils
:
:
eBRAND_PROPERTIES
)
;
nsCOMPtr
<
nsIAddonPolicyService
>
aps
=
do_GetService
(
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
)
;
nsString
addonName
;
if
(
!
aps
|
|
NS_FAILED
(
aps
-
>
GetExtensionName
(
aAddonId
addonName
)
)
)
{
addonName
=
aAddonId
;
}
const
char16_t
*
params
[
]
=
{
addonName
.
get
(
)
appName
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
KillAddonScriptMessage
"
params
msg
)
;
failed
=
failed
|
|
NS_FAILED
(
rv
)
;
}
else
{
title
=
getString
(
"
KillScriptTitle
"
)
;
checkboxMsg
=
getString
(
"
DontAskAgain
"
)
;
if
(
showDebugButton
)
{
debugButton
=
getString
(
"
DebugScriptButton
"
)
;
msg
=
getString
(
"
KillScriptWithDebugMessage
"
)
;
}
else
{
msg
=
getString
(
"
KillScriptMessage
"
)
;
}
}
auto
stopButton
=
getString
(
"
StopScriptButton
"
)
;
auto
waitButton
=
getString
(
"
WaitForScriptButton
"
)
;
if
(
failed
)
{
NS_ERROR
(
"
Failed
to
get
localized
strings
.
"
)
;
return
ContinueSlowScript
;
}
if
(
filename
.
get
(
)
)
{
nsAutoString
scriptLocation
;
NS_ConvertUTF8toUTF16
filenameUTF16
(
filename
.
get
(
)
)
;
if
(
filenameUTF16
.
Length
(
)
>
60
)
{
size_t
cutStart
=
30
;
size_t
cutLength
=
filenameUTF16
.
Length
(
)
-
60
;
MOZ_ASSERT
(
cutLength
>
0
)
;
if
(
NS_IS_LOW_SURROGATE
(
filenameUTF16
[
cutStart
]
)
)
{
+
+
cutStart
;
-
-
cutLength
;
}
if
(
NS_IS_LOW_SURROGATE
(
filenameUTF16
[
cutStart
+
cutLength
]
)
)
{
+
+
cutLength
;
}
filenameUTF16
.
ReplaceLiteral
(
cutStart
cutLength
u
"
\
x2026
"
)
;
}
const
char16_t
*
formatParams
[
]
=
{
filenameUTF16
.
get
(
)
}
;
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
KillScriptLocation
"
formatParams
scriptLocation
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
msg
.
AppendLiteral
(
"
\
n
\
n
"
)
;
msg
.
Append
(
scriptLocation
)
;
msg
.
Append
(
'
:
'
)
;
msg
.
AppendInt
(
lineno
)
;
}
}
uint32_t
buttonFlags
=
nsIPrompt
:
:
BUTTON_POS_1_DEFAULT
+
(
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
*
(
nsIPrompt
:
:
BUTTON_POS_0
+
nsIPrompt
:
:
BUTTON_POS_1
)
)
;
if
(
showDebugButton
)
buttonFlags
+
=
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
*
nsIPrompt
:
:
BUTTON_POS_2
;
bool
checkboxValue
=
false
;
int32_t
buttonPressed
=
0
;
{
AutoDisableJSInterruptCallback
disabler
(
cx
)
;
rv
=
prompt
-
>
ConfirmEx
(
title
.
get
(
)
msg
.
get
(
)
buttonFlags
waitButton
.
get
(
)
stopButton
.
get
(
)
debugButton
.
get
(
)
checkboxMsg
.
get
(
)
&
checkboxValue
&
buttonPressed
)
;
}
if
(
buttonPressed
=
=
0
)
{
if
(
checkboxValue
&
&
!
isAddonScript
&
&
NS_SUCCEEDED
(
rv
)
)
return
AlwaysContinueSlowScript
;
return
ContinueSlowScript
;
}
if
(
buttonPressed
=
=
2
)
{
MOZ_RELEASE_ASSERT
(
debugCallback
)
;
rv
=
debugCallback
-
>
HandleSlowScriptDebug
(
this
)
;
return
NS_SUCCEEDED
(
rv
)
?
ContinueSlowScript
:
KillSlowScript
;
}
JS_ClearPendingException
(
cx
)
;
if
(
checkboxValue
&
&
isAddonScript
)
return
KillScriptGlobal
;
return
KillSlowScript
;
}
uint32_t
nsGlobalWindowInner
:
:
FindInsertionIndex
(
IdleObserverHolder
*
aIdleObserver
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
MOZ_ASSERT
(
aIdleObserver
"
Idle
observer
not
instantiated
.
"
)
;
uint32_t
i
=
0
;
nsTObserverArray
<
IdleObserverHolder
>
:
:
ForwardIterator
iter
(
mIdleObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
IdleObserverHolder
&
idleObserver
=
iter
.
GetNext
(
)
;
if
(
idleObserver
.
mTimeInS
>
aIdleObserver
-
>
mTimeInS
)
{
break
;
}
i
+
+
;
MOZ_ASSERT
(
i
<
=
mIdleObservers
.
Length
(
)
"
Array
index
out
of
bounds
error
.
"
)
;
}
return
i
;
}
nsresult
nsGlobalWindowInner
:
:
RegisterIdleObserver
(
nsIIdleObserver
*
aIdleObserver
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
nsresult
rv
;
if
(
mIdleObservers
.
IsEmpty
(
)
)
{
mIdleService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mIdleService
-
>
AddIdleObserver
(
mObserver
MIN_IDLE_NOTIFICATION_TIME_S
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mIdleTimer
)
{
mIdleTimer
=
NS_NewTimer
(
)
;
NS_ENSURE_TRUE
(
mIdleTimer
NS_ERROR_OUT_OF_MEMORY
)
;
}
else
{
mIdleTimer
-
>
Cancel
(
)
;
}
}
MOZ_ASSERT
(
mIdleService
)
;
MOZ_ASSERT
(
mIdleTimer
)
;
IdleObserverHolder
tmpIdleObserver
;
tmpIdleObserver
.
mIdleObserver
=
aIdleObserver
;
rv
=
aIdleObserver
-
>
GetTime
(
&
tmpIdleObserver
.
mTimeInS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_ARG_MAX
(
tmpIdleObserver
.
mTimeInS
UINT32_MAX
/
1000
)
;
NS_ENSURE_ARG_MIN
(
tmpIdleObserver
.
mTimeInS
MIN_IDLE_NOTIFICATION_TIME_S
)
;
uint32_t
insertAtIndex
=
FindInsertionIndex
(
&
tmpIdleObserver
)
;
if
(
insertAtIndex
=
=
mIdleObservers
.
Length
(
)
)
{
mIdleObservers
.
AppendElement
(
tmpIdleObserver
)
;
}
else
{
mIdleObservers
.
InsertElementAt
(
insertAtIndex
tmpIdleObserver
)
;
}
bool
userIsIdle
=
false
;
rv
=
nsContentUtils
:
:
IsUserIdle
(
MIN_IDLE_NOTIFICATION_TIME_S
&
userIsIdle
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
userIsIdle
&
&
mIdleCallbackIndex
=
=
-
1
)
{
return
NS_OK
;
}
if
(
!
mCurrentlyIdle
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mIdleCallbackIndex
>
=
0
)
;
if
(
static_cast
<
int32_t
>
(
insertAtIndex
)
<
mIdleCallbackIndex
)
{
IdleObserverHolder
&
idleObserver
=
mIdleObservers
.
ElementAt
(
insertAtIndex
)
;
NotifyIdleObserver
(
&
idleObserver
true
)
;
mIdleCallbackIndex
+
+
;
return
NS_OK
;
}
if
(
static_cast
<
int32_t
>
(
insertAtIndex
)
=
=
mIdleCallbackIndex
)
{
mIdleTimer
-
>
Cancel
(
)
;
rv
=
ScheduleNextIdleObserverCallback
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
FindIndexOfElementToRemove
(
nsIIdleObserver
*
aIdleObserver
int32_t
*
aRemoveElementIndex
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
MOZ_ASSERT
(
aIdleObserver
"
Idle
observer
not
instantiated
.
"
)
;
*
aRemoveElementIndex
=
0
;
if
(
mIdleObservers
.
IsEmpty
(
)
)
{
return
NS_ERROR_FAILURE
;
}
uint32_t
aIdleObserverTimeInS
;
nsresult
rv
=
aIdleObserver
-
>
GetTime
(
&
aIdleObserverTimeInS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_ARG_MIN
(
aIdleObserverTimeInS
MIN_IDLE_NOTIFICATION_TIME_S
)
;
nsTObserverArray
<
IdleObserverHolder
>
:
:
ForwardIterator
iter
(
mIdleObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
IdleObserverHolder
&
idleObserver
=
iter
.
GetNext
(
)
;
if
(
idleObserver
.
mTimeInS
=
=
aIdleObserverTimeInS
&
&
idleObserver
.
mIdleObserver
=
=
aIdleObserver
)
{
break
;
}
(
*
aRemoveElementIndex
)
+
+
;
}
return
static_cast
<
uint32_t
>
(
*
aRemoveElementIndex
)
>
=
mIdleObservers
.
Length
(
)
?
NS_ERROR_FAILURE
:
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
UnregisterIdleObserver
(
nsIIdleObserver
*
aIdleObserver
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
"
Must
be
an
inner
window
!
"
)
;
int32_t
removeElementIndex
;
nsresult
rv
=
FindIndexOfElementToRemove
(
aIdleObserver
&
removeElementIndex
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Idle
observer
not
found
in
list
of
idle
observers
.
No
idle
observer
removed
.
"
)
;
return
NS_OK
;
}
mIdleObservers
.
RemoveElementAt
(
removeElementIndex
)
;
MOZ_ASSERT
(
mIdleTimer
)
;
if
(
mIdleObservers
.
IsEmpty
(
)
&
&
mIdleService
)
{
rv
=
mIdleService
-
>
RemoveIdleObserver
(
mObserver
MIN_IDLE_NOTIFICATION_TIME_S
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mIdleService
=
nullptr
;
mIdleTimer
-
>
Cancel
(
)
;
mIdleCallbackIndex
=
-
1
;
return
NS_OK
;
}
if
(
!
mCurrentlyIdle
)
{
return
NS_OK
;
}
if
(
removeElementIndex
<
mIdleCallbackIndex
)
{
mIdleCallbackIndex
-
-
;
return
NS_OK
;
}
if
(
removeElementIndex
!
=
mIdleCallbackIndex
)
{
return
NS_OK
;
}
mIdleTimer
-
>
Cancel
(
)
;
if
(
static_cast
<
uint32_t
>
(
mIdleCallbackIndex
)
=
=
mIdleObservers
.
Length
(
)
)
{
mIdleCallbackIndex
-
-
;
}
rv
=
ScheduleNextIdleObserverCallback
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
)
)
{
if
(
!
IsFrozen
(
)
)
{
FireOfflineStatusEventIfChanged
(
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
MEMORY_PRESSURE_OBSERVER_TOPIC
)
)
{
if
(
mPerformance
)
{
mPerformance
-
>
MemoryPressure
(
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
OBSERVER_TOPIC_IDLE
)
)
{
mCurrentlyIdle
=
true
;
if
(
IsFrozen
(
)
)
{
mNotifyIdleObserversIdleOnThaw
=
true
;
mNotifyIdleObserversActiveOnThaw
=
false
;
}
else
if
(
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
{
HandleIdleActiveEvent
(
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
OBSERVER_TOPIC_ACTIVE
)
)
{
mCurrentlyIdle
=
false
;
if
(
IsFrozen
(
)
)
{
mNotifyIdleObserversActiveOnThaw
=
true
;
mNotifyIdleObserversIdleOnThaw
=
false
;
}
else
if
(
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
ScheduleActiveTimerCallback
(
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
offline
-
cache
-
update
-
added
"
)
)
{
if
(
mApplicationCache
)
return
NS_OK
;
nsCOMPtr
<
nsIDOMOfflineResourceList
>
applicationCache
=
GetApplicationCache
(
)
;
nsCOMPtr
<
nsIObserver
>
observer
=
do_QueryInterface
(
applicationCache
)
;
if
(
observer
)
observer
-
>
Observe
(
aSubject
aTopic
aData
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
MOZ_ASSERT
(
!
NS_strcmp
(
aData
u
"
intl
.
accept_languages
"
)
)
;
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mNavigator
)
{
NavigatorBinding
:
:
ClearCachedLanguageValue
(
mNavigator
)
;
NavigatorBinding
:
:
ClearCachedLanguagesValue
(
mNavigator
)
;
}
if
(
!
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
this
nullptr
nullptr
)
;
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
languagechange
"
)
false
false
)
;
event
-
>
SetTrusted
(
true
)
;
bool
dummy
;
return
DispatchEvent
(
event
&
dummy
)
;
}
NS_WARNING
(
"
unrecognized
topic
in
nsGlobalWindowInner
:
:
Observe
"
)
;
return
NS_ERROR_FAILURE
;
}
void
nsGlobalWindowInner
:
:
ObserveStorageNotification
(
StorageEvent
*
aEvent
const
char16_t
*
aStorageType
bool
aPrivateBrowsing
)
{
MOZ_ASSERT
(
aEvent
)
;
if
(
aPrivateBrowsing
!
=
IsPrivateBrowsing
(
)
)
{
return
;
}
if
(
!
IsInnerWindow
(
)
|
|
!
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
|
|
IsFrozen
(
)
)
{
return
;
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
return
;
}
bool
fireMozStorageChanged
=
false
;
nsAutoString
eventType
;
eventType
.
AssignLiteral
(
"
storage
"
)
;
if
(
!
NS_strcmp
(
aStorageType
u
"
sessionStorage
"
)
)
{
nsCOMPtr
<
nsIDOMStorage
>
changingStorage
=
aEvent
-
>
GetStorageArea
(
)
;
MOZ_ASSERT
(
changingStorage
)
;
bool
check
=
false
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_QueryInterface
(
GetDocShell
(
)
)
;
if
(
storageManager
)
{
nsresult
rv
=
storageManager
-
>
CheckStorage
(
principal
changingStorage
&
check
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
if
(
!
check
)
{
return
;
}
MOZ_LOG
(
gDOMLeakPRLog
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
with
sessionStorage
%
p
passing
event
from
%
p
"
this
mSessionStorage
.
get
(
)
changingStorage
.
get
(
)
)
)
;
fireMozStorageChanged
=
mSessionStorage
=
=
changingStorage
;
if
(
fireMozStorageChanged
)
{
eventType
.
AssignLiteral
(
"
MozSessionStorageChanged
"
)
;
}
}
else
{
MOZ_ASSERT
(
!
NS_strcmp
(
aStorageType
u
"
localStorage
"
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
StorageUtils
:
:
PrincipalsEqual
(
aEvent
-
>
GetPrincipal
(
)
principal
)
)
;
fireMozStorageChanged
=
mLocalStorage
=
=
aEvent
-
>
GetStorageArea
(
)
;
if
(
fireMozStorageChanged
)
{
eventType
.
AssignLiteral
(
"
MozLocalStorageChanged
"
)
;
}
}
IgnoredErrorResult
error
;
RefPtr
<
StorageEvent
>
clonedEvent
=
CloneStorageEvent
(
eventType
aEvent
error
)
;
if
(
error
.
Failed
(
)
)
{
return
;
}
clonedEvent
-
>
SetTrusted
(
true
)
;
if
(
fireMozStorageChanged
)
{
WidgetEvent
*
internalEvent
=
clonedEvent
-
>
WidgetEventPtr
(
)
;
internalEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
}
bool
defaultActionEnabled
;
DispatchEvent
(
clonedEvent
&
defaultActionEnabled
)
;
}
already_AddRefed
<
StorageEvent
>
nsGlobalWindowInner
:
:
CloneStorageEvent
(
const
nsAString
&
aType
const
RefPtr
<
StorageEvent
>
&
aEvent
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
StorageEventInit
dict
;
dict
.
mBubbles
=
aEvent
-
>
Bubbles
(
)
;
dict
.
mCancelable
=
aEvent
-
>
Cancelable
(
)
;
aEvent
-
>
GetKey
(
dict
.
mKey
)
;
aEvent
-
>
GetOldValue
(
dict
.
mOldValue
)
;
aEvent
-
>
GetNewValue
(
dict
.
mNewValue
)
;
aEvent
-
>
GetUrl
(
dict
.
mUrl
)
;
RefPtr
<
Storage
>
storageArea
=
aEvent
-
>
GetStorageArea
(
)
;
RefPtr
<
Storage
>
storage
;
if
(
!
storageArea
)
{
storage
=
GetLocalStorage
(
aRv
)
;
if
(
aRv
.
Failed
(
)
|
|
!
storage
)
{
return
nullptr
;
}
MOZ_ASSERT
(
storage
-
>
Type
(
)
=
=
Storage
:
:
eLocalStorage
)
;
RefPtr
<
LocalStorage
>
localStorage
=
static_cast
<
LocalStorage
*
>
(
storage
.
get
(
)
)
;
localStorage
-
>
ApplyEvent
(
aEvent
)
;
}
else
if
(
storageArea
-
>
Type
(
)
=
=
Storage
:
:
eSessionStorage
)
{
storage
=
GetSessionStorage
(
aRv
)
;
}
else
{
MOZ_ASSERT
(
storageArea
-
>
Type
(
)
=
=
Storage
:
:
eLocalStorage
)
;
storage
=
GetLocalStorage
(
aRv
)
;
}
if
(
aRv
.
Failed
(
)
|
|
!
storage
)
{
return
nullptr
;
}
MOZ_ASSERT
(
storage
)
;
MOZ_ASSERT_IF
(
storageArea
storage
-
>
IsForkOf
(
storageArea
)
)
;
dict
.
mStorageArea
=
storage
;
RefPtr
<
StorageEvent
>
event
=
StorageEvent
:
:
Constructor
(
this
aType
dict
)
;
return
event
.
forget
(
)
;
}
void
nsGlobalWindowInner
:
:
Suspend
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
{
return
;
}
CallOnChildren
(
&
nsGlobalWindowInner
:
:
Suspend
)
;
mSuspendDepth
+
=
1
;
if
(
mSuspendDepth
!
=
1
)
{
return
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
ac
-
>
RemoveWindowListener
(
mEnabledSensors
[
i
]
this
)
;
}
DisableGamepadUpdates
(
)
;
DisableVRUpdates
(
)
;
mozilla
:
:
dom
:
:
workers
:
:
SuspendWorkersForWindow
(
AsInner
(
)
)
;
SuspendIdleRequests
(
)
;
mTimeoutManager
-
>
Suspend
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
ErrorResult
dummy
;
RefPtr
<
Promise
>
d
=
mAudioContexts
[
i
]
-
>
Suspend
(
dummy
)
;
}
}
void
nsGlobalWindowInner
:
:
Resume
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
{
return
;
}
CallOnChildren
(
&
nsGlobalWindowInner
:
:
Resume
)
;
MOZ_ASSERT
(
mSuspendDepth
!
=
0
)
;
mSuspendDepth
-
=
1
;
if
(
mSuspendDepth
!
=
0
)
{
return
;
}
MOZ_ASSERT
(
mFreezeDepth
=
=
0
)
;
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
ac
-
>
AddWindowListener
(
mEnabledSensors
[
i
]
this
)
;
}
EnableGamepadUpdates
(
)
;
EnableVRUpdates
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
ErrorResult
dummy
;
RefPtr
<
Promise
>
d
=
mAudioContexts
[
i
]
-
>
Resume
(
dummy
)
;
}
mTimeoutManager
-
>
Resume
(
)
;
ResumeIdleRequests
(
)
;
mozilla
:
:
dom
:
:
workers
:
:
ResumeWorkersForWindow
(
AsInner
(
)
)
;
}
bool
nsGlobalWindowInner
:
:
IsSuspended
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsOuterWindow
(
)
)
{
if
(
!
mInnerWindow
)
{
return
true
;
}
return
mInnerWindow
-
>
IsSuspended
(
)
;
}
return
mSuspendDepth
!
=
0
;
}
void
nsGlobalWindowInner
:
:
Freeze
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Suspend
(
)
;
FreezeInternal
(
)
;
}
void
nsGlobalWindowInner
:
:
FreezeInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsInnerWindow
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsSuspended
(
)
)
;
CallOnChildren
(
&
nsGlobalWindowInner
:
:
FreezeInternal
)
;
mFreezeDepth
+
=
1
;
MOZ_ASSERT
(
mSuspendDepth
>
=
mFreezeDepth
)
;
if
(
mFreezeDepth
!
=
1
)
{
return
;
}
mozilla
:
:
dom
:
:
workers
:
:
FreezeWorkersForWindow
(
AsInner
(
)
)
;
mTimeoutManager
-
>
Freeze
(
)
;
if
(
IsInnerWindow
(
)
)
{
NotifyDOMWindowFrozen
(
AssertInner
(
)
)
;
}
}
void
nsGlobalWindowInner
:
:
Thaw
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ThawInternal
(
)
;
Resume
(
)
;
}
void
nsGlobalWindowInner
:
:
ThawInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsInnerWindow
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsSuspended
(
)
)
;
CallOnChildren
(
&
nsGlobalWindowInner
:
:
ThawInternal
)
;
MOZ_ASSERT
(
mFreezeDepth
!
=
0
)
;
mFreezeDepth
-
=
1
;
MOZ_ASSERT
(
mSuspendDepth
>
=
mFreezeDepth
)
;
if
(
mFreezeDepth
!
=
0
)
{
return
;
}
mTimeoutManager
-
>
Thaw
(
)
;
mozilla
:
:
dom
:
:
workers
:
:
ThawWorkersForWindow
(
AsInner
(
)
)
;
if
(
IsInnerWindow
(
)
)
{
NotifyDOMWindowThawed
(
AssertInner
(
)
)
;
}
}
bool
nsGlobalWindowInner
:
:
IsFrozen
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
IsOuterWindow
(
)
)
{
if
(
!
mInnerWindow
)
{
return
true
;
}
return
mInnerWindow
-
>
IsFrozen
(
)
;
}
bool
frozen
=
mFreezeDepth
!
=
0
;
MOZ_ASSERT_IF
(
frozen
IsSuspended
(
)
)
;
return
frozen
;
}
void
nsGlobalWindowInner
:
:
SyncStateFromParentWindow
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
MOZ_ASSERT
(
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
;
nsPIDOMWindowOuter
*
outer
=
GetOuterWindow
(
)
;
MOZ_ASSERT
(
outer
)
;
nsCOMPtr
<
Element
>
frame
=
outer
-
>
GetFrameElementInternal
(
)
;
nsPIDOMWindowOuter
*
parentOuter
=
frame
?
frame
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
:
nullptr
;
nsGlobalWindowInner
*
parentInner
=
parentOuter
?
nsGlobalWindowInner
:
:
Cast
(
parentOuter
-
>
GetCurrentInnerWindow
(
)
)
:
nullptr
;
if
(
(
!
parentInner
|
|
!
parentInner
-
>
IsInModalState
(
)
)
&
&
IsInModalState
(
)
)
{
Suspend
(
)
;
}
uint32_t
parentFreezeDepth
=
parentInner
?
parentInner
-
>
mFreezeDepth
:
0
;
uint32_t
parentSuspendDepth
=
parentInner
?
parentInner
-
>
mSuspendDepth
:
0
;
MOZ_ASSERT
(
parentFreezeDepth
<
=
parentSuspendDepth
)
;
for
(
uint32_t
i
=
0
;
i
<
parentFreezeDepth
;
+
+
i
)
{
Freeze
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
(
parentSuspendDepth
-
parentFreezeDepth
)
;
+
+
i
)
{
Suspend
(
)
;
}
}
template
<
typename
Method
>
void
nsGlobalWindowInner
:
:
CallOnChildren
(
Method
aMethod
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
MOZ_ASSERT
(
AsInner
(
)
-
>
IsCurrentInnerWindow
(
)
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
int32_t
childCount
=
0
;
docShell
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
;
docShell
-
>
GetChildAt
(
i
getter_AddRefs
(
childShell
)
)
;
NS_ASSERTION
(
childShell
"
null
child
shell
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
pWin
=
childShell
-
>
GetWindow
(
)
;
if
(
!
pWin
)
{
continue
;
}
auto
*
win
=
nsGlobalWindowOuter
:
:
Cast
(
pWin
)
;
nsGlobalWindowInner
*
inner
=
win
-
>
GetCurrentInnerWindowInternal
(
)
;
nsCOMPtr
<
Element
>
frame
=
pWin
-
>
GetFrameElementInternal
(
)
;
if
(
!
mDoc
|
|
!
frame
|
|
mDoc
!
=
frame
-
>
OwnerDoc
(
)
|
|
!
inner
)
{
continue
;
}
(
inner
-
>
*
aMethod
)
(
)
;
}
}
nsresult
nsGlobalWindowInner
:
:
FireDelayedDOMEvents
(
)
{
FORWARD_TO_INNER
(
FireDelayedDOMEvents
(
)
NS_ERROR_UNEXPECTED
)
;
if
(
mApplicationCache
)
{
static_cast
<
nsDOMOfflineResourceList
*
>
(
mApplicationCache
.
get
(
)
)
-
>
FirePendingEvents
(
)
;
}
FireOfflineStatusEventIfChanged
(
)
;
if
(
mNotifyIdleObserversIdleOnThaw
)
{
mNotifyIdleObserversIdleOnThaw
=
false
;
HandleIdleActiveEvent
(
)
;
}
if
(
mNotifyIdleObserversActiveOnThaw
)
{
mNotifyIdleObserversActiveOnThaw
=
false
;
ScheduleActiveTimerCallback
(
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
int32_t
childCount
=
0
;
docShell
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
;
docShell
-
>
GetChildAt
(
i
getter_AddRefs
(
childShell
)
)
;
NS_ASSERTION
(
childShell
"
null
child
shell
"
)
;
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
pWin
=
childShell
-
>
GetWindow
(
)
)
{
auto
*
win
=
nsGlobalWindowOuter
:
:
Cast
(
pWin
)
;
win
-
>
FireDelayedDOMEvents
(
)
;
}
}
}
return
NS_OK
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetParentInternal
(
)
{
if
(
IsInnerWindow
(
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
return
nullptr
;
}
return
outer
-
>
GetParentInternal
(
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent
=
GetParent
(
)
;
if
(
parent
&
&
parent
!
=
AsOuter
(
)
)
{
return
parent
;
}
return
nullptr
;
}
void
nsGlobalWindowInner
:
:
UnblockScriptedClosing
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
mBlockScriptedClosingFlag
=
false
;
}
nsresult
nsGlobalWindowInner
:
:
OpenInternal
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
bool
aDialog
bool
aContentModal
bool
aCalledNoScript
bool
aDoJSFixups
bool
aNavigate
nsIArray
*
argv
nsISupports
*
aExtraArgument
nsIDocShellLoadInfo
*
aLoadInfo
bool
aForceNoOpener
nsPIDOMWindowOuter
*
*
aReturn
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
nsGlobalWindowInner
*
nsGlobalWindowInner
:
:
InnerForSetTimeoutOrInterval
(
ErrorResult
&
aError
)
{
nsGlobalWindowInner
*
currentInner
;
nsGlobalWindowInner
*
forwardTo
;
if
(
IsInnerWindow
(
)
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
currentInner
=
outer
?
outer
-
>
GetCurrentInnerWindowInternal
(
)
:
AssertInner
(
)
;
forwardTo
=
AssertInner
(
)
;
}
else
{
currentInner
=
GetCurrentInnerWindowInternal
(
)
;
forwardTo
=
CallerInnerWindow
(
)
;
if
(
!
forwardTo
&
&
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
forwardTo
=
currentInner
;
}
if
(
!
forwardTo
)
{
aError
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
if
(
forwardTo
-
>
GetOuterWindow
(
)
!
=
AsOuter
(
)
|
|
!
forwardTo
-
>
IsInnerWindow
(
)
)
{
if
(
!
currentInner
)
{
NS_WARNING
(
"
No
inner
window
available
!
"
)
;
aError
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
return
currentInner
;
}
}
return
forwardTo
-
>
AsInner
(
)
-
>
HasActiveDocument
(
)
?
currentInner
:
nullptr
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeout
(
JSContext
*
aCx
Function
&
aFunction
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
aArguments
ErrorResult
&
aError
)
{
return
SetTimeoutOrInterval
(
aCx
aFunction
aTimeout
aArguments
false
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeout
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
ErrorResult
&
aError
)
{
return
SetTimeoutOrInterval
(
aCx
aHandler
aTimeout
false
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetInterval
(
JSContext
*
aCx
Function
&
aFunction
const
Optional
<
int32_t
>
&
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
aArguments
ErrorResult
&
aError
)
{
int32_t
timeout
;
bool
isInterval
=
IsInterval
(
aTimeout
timeout
)
;
return
SetTimeoutOrInterval
(
aCx
aFunction
timeout
aArguments
isInterval
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
const
Optional
<
int32_t
>
&
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
ErrorResult
&
aError
)
{
int32_t
timeout
;
bool
isInterval
=
IsInterval
(
aTimeout
timeout
)
;
return
SetTimeoutOrInterval
(
aCx
aHandler
timeout
isInterval
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeoutOrInterval
(
JSContext
*
aCx
Function
&
aFunction
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
aArguments
bool
aIsInterval
ErrorResult
&
aError
)
{
nsGlobalWindowInner
*
inner
=
InnerForSetTimeoutOrInterval
(
aError
)
;
if
(
!
inner
)
{
return
-
1
;
}
if
(
inner
!
=
this
)
{
return
inner
-
>
SetTimeoutOrInterval
(
aCx
aFunction
aTimeout
aArguments
aIsInterval
aError
)
;
}
nsCOMPtr
<
nsIScriptTimeoutHandler
>
handler
=
NS_CreateJSTimeoutHandler
(
aCx
AssertInner
(
)
aFunction
aArguments
aError
)
;
if
(
!
handler
)
{
return
0
;
}
int32_t
result
;
aError
=
mTimeoutManager
-
>
SetTimeout
(
handler
aTimeout
aIsInterval
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
&
result
)
;
return
result
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeoutOrInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
bool
aIsInterval
ErrorResult
&
aError
)
{
nsGlobalWindowInner
*
inner
=
InnerForSetTimeoutOrInterval
(
aError
)
;
if
(
!
inner
)
{
return
-
1
;
}
if
(
inner
!
=
this
)
{
return
inner
-
>
SetTimeoutOrInterval
(
aCx
aHandler
aTimeout
aIsInterval
aError
)
;
}
nsCOMPtr
<
nsIScriptTimeoutHandler
>
handler
=
NS_CreateJSTimeoutHandler
(
aCx
AssertInner
(
)
aHandler
aError
)
;
if
(
!
handler
)
{
return
0
;
}
int32_t
result
;
aError
=
mTimeoutManager
-
>
SetTimeout
(
handler
aTimeout
aIsInterval
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
&
result
)
;
return
result
;
}
bool
nsGlobalWindowInner
:
:
RunTimeoutHandler
(
Timeout
*
aTimeout
nsIScriptContext
*
aScx
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
RefPtr
<
Timeout
>
timeout
=
aTimeout
;
Timeout
*
last_running_timeout
=
mTimeoutManager
-
>
BeginRunningTimeout
(
timeout
)
;
timeout
-
>
mRunning
=
true
;
nsAutoPopupStatePusher
popupStatePusher
(
timeout
-
>
mPopupState
)
;
timeout
-
>
mPopupState
=
openAbused
;
bool
trackNestingLevel
=
!
timeout
-
>
mIsInterval
;
uint32_t
nestingLevel
;
if
(
trackNestingLevel
)
{
nestingLevel
=
TimeoutManager
:
:
GetNestingLevel
(
)
;
TimeoutManager
:
:
SetNestingLevel
(
timeout
-
>
mNestingLevel
)
;
}
const
char
*
reason
;
if
(
timeout
-
>
mIsInterval
)
{
reason
=
"
setInterval
handler
"
;
}
else
{
reason
=
"
setTimeout
handler
"
;
}
bool
abortIntervalHandler
=
false
;
nsCOMPtr
<
nsIScriptTimeoutHandler
>
handler
(
do_QueryInterface
(
timeout
-
>
mScriptHandler
)
)
;
if
(
handler
)
{
RefPtr
<
Function
>
callback
=
handler
-
>
GetCallback
(
)
;
if
(
!
callback
)
{
const
nsAString
&
script
=
handler
-
>
GetHandlerText
(
)
;
const
char
*
filename
=
nullptr
;
uint32_t
lineNo
=
0
dummyColumn
=
0
;
handler
-
>
GetLocation
(
&
filename
&
lineNo
&
dummyColumn
)
;
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
this
reason
true
)
;
JS
:
:
CompileOptions
options
(
aes
.
cx
(
)
)
;
options
.
setFileAndLine
(
filename
lineNo
)
.
setVersion
(
JSVERSION_DEFAULT
)
;
options
.
setNoScriptRval
(
true
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aes
.
cx
(
)
FastGetGlobalJSObject
(
)
)
;
nsresult
rv
=
NS_OK
;
{
nsJSUtils
:
:
ExecutionContext
exec
(
aes
.
cx
(
)
global
)
;
rv
=
exec
.
CompileAndExec
(
options
script
)
;
}
if
(
rv
=
=
NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE
)
{
abortIntervalHandler
=
true
;
}
}
else
{
nsCOMPtr
<
nsISupports
>
me
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
)
;
ErrorResult
rv
;
JS
:
:
Rooted
<
JS
:
:
Value
>
ignoredVal
(
RootingCx
(
)
)
;
callback
-
>
Call
(
me
handler
-
>
GetArgs
(
)
&
ignoredVal
rv
reason
)
;
if
(
rv
.
IsUncatchableException
(
)
)
{
abortIntervalHandler
=
true
;
}
rv
.
SuppressException
(
)
;
}
}
else
{
nsCOMPtr
<
nsITimeoutHandler
>
basicHandler
(
timeout
-
>
mScriptHandler
)
;
nsCOMPtr
<
nsISupports
>
kungFuDeathGrip
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip
;
basicHandler
-
>
Call
(
)
;
}
if
(
abortIntervalHandler
)
{
timeout
-
>
mIsInterval
=
false
;
}
Promise
:
:
PerformMicroTaskCheckpoint
(
)
;
if
(
trackNestingLevel
)
{
TimeoutManager
:
:
SetNestingLevel
(
nestingLevel
)
;
}
mTimeoutManager
-
>
EndRunningTimeout
(
last_running_timeout
)
;
timeout
-
>
mRunning
=
false
;
return
timeout
-
>
mCleared
;
}
already_AddRefed
<
nsIDocShellTreeOwner
>
nsGlobalWindowInner
:
:
GetTreeOwner
(
)
{
FORWARD_TO_OUTER
(
GetTreeOwner
(
)
nullptr
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
mDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
return
treeOwner
.
forget
(
)
;
}
already_AddRefed
<
nsIBaseWindow
>
nsGlobalWindowInner
:
:
GetTreeOwnerWindow
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
if
(
mDocShell
)
{
mDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
}
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
treeOwner
)
;
return
baseWindow
.
forget
(
)
;
}
already_AddRefed
<
nsIWebBrowserChrome
>
nsGlobalWindowInner
:
:
GetWebBrowserChrome
(
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
=
do_GetInterface
(
treeOwner
)
;
return
browserChrome
.
forget
(
)
;
}
nsIScrollableFrame
*
nsGlobalWindowInner
:
:
GetScrollFrame
(
)
{
FORWARD_TO_OUTER
(
GetScrollFrame
(
)
nullptr
)
;
if
(
!
mDocShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
return
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
}
return
nullptr
;
}
nsresult
nsGlobalWindowInner
:
:
SecurityCheckURL
(
const
char
*
aURL
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
sourceWindow
=
do_QueryInterface
(
GetEntryGlobal
(
)
)
;
if
(
!
sourceWindow
)
{
sourceWindow
=
AsOuter
(
)
-
>
GetCurrentInnerWindow
(
)
;
}
AutoJSContext
cx
;
nsGlobalWindowInner
*
sourceWin
=
nsGlobalWindowInner
:
:
Cast
(
sourceWindow
)
;
JSAutoCompartment
ac
(
cx
sourceWin
-
>
GetGlobalJSObject
(
)
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
sourceWindow
-
>
GetDoc
(
)
;
nsIURI
*
baseURI
=
nullptr
;
auto
encoding
=
UTF_8_ENCODING
;
if
(
doc
)
{
baseURI
=
doc
-
>
GetDocBaseURI
(
)
;
encoding
=
doc
-
>
GetDocumentCharacterSet
(
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
nsDependentCString
(
aURL
)
encoding
baseURI
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
NS_ERROR_DOM_SYNTAX_ERR
;
}
if
(
NS_FAILED
(
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIFromScript
(
cx
uri
)
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
bool
nsGlobalWindowInner
:
:
IsPrivateBrowsing
(
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_QueryInterface
(
GetDocShell
(
)
)
;
return
loadContext
&
&
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
void
nsGlobalWindowInner
:
:
FlushPendingNotifications
(
FlushType
aType
)
{
if
(
mDoc
)
{
mDoc
-
>
FlushPendingNotifications
(
aType
)
;
}
}
void
nsGlobalWindowInner
:
:
EnsureSizeAndPositionUpToDate
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsGlobalWindowOuter
*
parent
=
nsGlobalWindowOuter
:
:
Cast
(
GetPrivateParent
(
)
)
;
if
(
parent
)
{
parent
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
already_AddRefed
<
nsISupports
>
nsGlobalWindowInner
:
:
SaveWindowState
(
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
nsresult
nsGlobalWindowInner
:
:
RestoreWindowState
(
nsISupports
*
aState
)
{
MOZ_CRASH
(
"
Outer
window
only
"
)
;
}
void
nsGlobalWindowInner
:
:
EnableDeviceSensor
(
uint32_t
aType
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
bool
alreadyEnabled
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
{
if
(
mEnabledSensors
[
i
]
=
=
aType
)
{
alreadyEnabled
=
true
;
break
;
}
}
mEnabledSensors
.
AppendElement
(
aType
)
;
if
(
alreadyEnabled
)
{
return
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
ac
-
>
AddWindowListener
(
aType
this
)
;
}
}
void
nsGlobalWindowInner
:
:
DisableDeviceSensor
(
uint32_t
aType
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
int32_t
doomedElement
=
-
1
;
int32_t
listenerCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
{
if
(
mEnabledSensors
[
i
]
=
=
aType
)
{
doomedElement
=
i
;
listenerCount
+
+
;
}
}
if
(
doomedElement
=
=
-
1
)
{
return
;
}
mEnabledSensors
.
RemoveElementAt
(
doomedElement
)
;
if
(
listenerCount
>
1
)
{
return
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
ac
-
>
RemoveWindowListener
(
aType
this
)
;
}
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
nsGlobalWindowInner
:
:
EnableOrientationChangeListener
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
mDocShell
)
&
&
!
mOrientationChangeObserver
)
{
mOrientationChangeObserver
=
MakeUnique
<
WindowOrientationObserver
>
(
AssertInner
(
)
)
;
}
}
void
nsGlobalWindowInner
:
:
DisableOrientationChangeListener
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mOrientationChangeObserver
=
nullptr
;
}
#
endif
void
nsGlobalWindowInner
:
:
SetHasGamepadEventListener
(
bool
aHasGamepad
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mHasGamepad
=
aHasGamepad
;
if
(
aHasGamepad
)
{
EnableGamepadUpdates
(
)
;
}
}
void
nsGlobalWindowInner
:
:
EventListenerAdded
(
nsAtom
*
aType
)
{
if
(
aType
=
=
nsGkAtoms
:
:
onvrdisplayactivate
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplayconnect
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplaydeactivate
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplaydisconnect
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplaypresentchange
)
{
NotifyVREventListenerAdded
(
)
;
}
if
(
aType
=
=
nsGkAtoms
:
:
onvrdisplayactivate
)
{
mHasVRDisplayActivateEvents
=
true
;
}
if
(
aType
=
=
nsGkAtoms
:
:
onbeforeunload
&
&
mTabChild
&
&
(
!
mDoc
|
|
!
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
)
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mBeforeUnloadListenerCount
+
+
;
MOZ_ASSERT
(
mBeforeUnloadListenerCount
>
0
)
;
mTabChild
-
>
BeforeUnloadAdded
(
)
;
}
if
(
aType
=
=
nsGkAtoms
:
:
onstorage
)
{
ErrorResult
rv
;
GetLocalStorage
(
rv
)
;
rv
.
SuppressException
(
)
;
}
}
void
nsGlobalWindowInner
:
:
EventListenerRemoved
(
nsAtom
*
aType
)
{
if
(
aType
=
=
nsGkAtoms
:
:
onbeforeunload
&
&
mTabChild
&
&
(
!
mDoc
|
|
!
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
)
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mBeforeUnloadListenerCount
-
-
;
MOZ_ASSERT
(
mBeforeUnloadListenerCount
>
=
0
)
;
mTabChild
-
>
BeforeUnloadRemoved
(
)
;
}
}
void
nsGlobalWindowInner
:
:
NotifyVREventListenerAdded
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mHasVREvents
=
true
;
EnableVRUpdates
(
)
;
}
bool
nsGlobalWindowInner
:
:
HasUsedVR
(
)
const
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
mHasVREvents
;
}
bool
nsGlobalWindowInner
:
:
IsVRContentDetected
(
)
const
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
mHasVRDisplayActivateEvents
;
}
bool
nsGlobalWindowInner
:
:
IsVRContentPresenting
(
)
const
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
IsAnyPresenting
(
gfx
:
:
kVRGroupAll
)
)
{
return
true
;
}
}
return
false
;
}
void
nsGlobalWindowInner
:
:
EnableTimeChangeNotifications
(
)
{
mozilla
:
:
time
:
:
AddWindowListener
(
AsInner
(
)
)
;
}
void
nsGlobalWindowInner
:
:
DisableTimeChangeNotifications
(
)
{
mozilla
:
:
time
:
:
RemoveWindowListener
(
AsInner
(
)
)
;
}
void
nsGlobalWindowInner
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
aWindowSizes
.
mDOMOtherSize
+
=
aWindowSizes
.
mState
.
mMallocSizeOf
(
this
)
;
if
(
IsInnerWindow
(
)
)
{
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
if
(
elm
)
{
aWindowSizes
.
mDOMOtherSize
+
=
elm
-
>
SizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
if
(
mDoc
)
{
if
(
!
mDoc
-
>
GetInnerWindow
(
)
|
|
mDoc
-
>
GetInnerWindow
(
)
=
=
AsInner
(
)
)
{
mDoc
-
>
DocAddSizeOfIncludingThis
(
aWindowSizes
)
;
}
}
}
if
(
mNavigator
)
{
aWindowSizes
.
mDOMOtherSize
+
=
mNavigator
-
>
SizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
aWindowSizes
.
mDOMEventTargetsSize
+
=
mEventTargetObjects
.
ShallowSizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
for
(
auto
iter
=
mEventTargetObjects
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DOMEventTargetHelper
*
et
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
nsCOMPtr
<
nsISizeOfEventTarget
>
iSizeOf
=
do_QueryObject
(
et
)
)
{
aWindowSizes
.
mDOMEventTargetsSize
+
=
iSizeOf
-
>
SizeOfEventTargetIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
if
(
EventListenerManager
*
elm
=
et
-
>
GetExistingListenerManager
(
)
)
{
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
+
+
aWindowSizes
.
mDOMEventTargetsCount
;
}
if
(
IsInnerWindow
(
)
&
&
mPerformance
)
{
aWindowSizes
.
mDOMPerformanceUserEntries
=
mPerformance
-
>
SizeOfUserEntries
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
aWindowSizes
.
mDOMPerformanceResourceEntries
=
mPerformance
-
>
SizeOfResourceEntries
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
}
void
nsGlobalWindowInner
:
:
AddGamepad
(
uint32_t
aIndex
Gamepad
*
aGamepad
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
int
index
=
0
;
while
(
mGamepadIndexSet
.
Contains
(
index
)
)
{
+
+
index
;
}
mGamepadIndexSet
.
Put
(
index
)
;
aGamepad
-
>
SetIndex
(
index
)
;
mGamepads
.
Put
(
aIndex
aGamepad
)
;
}
void
nsGlobalWindowInner
:
:
RemoveGamepad
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
RefPtr
<
Gamepad
>
gamepad
;
if
(
!
mGamepads
.
Get
(
aIndex
getter_AddRefs
(
gamepad
)
)
)
{
return
;
}
mGamepadIndexSet
.
Remove
(
gamepad
-
>
Index
(
)
)
;
mGamepads
.
Remove
(
aIndex
)
;
}
void
nsGlobalWindowInner
:
:
GetGamepads
(
nsTArray
<
RefPtr
<
Gamepad
>
>
&
aGamepads
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
aGamepads
.
Clear
(
)
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
)
{
return
;
}
aGamepads
.
SetCapacity
(
mGamepads
.
Count
(
)
)
;
for
(
auto
iter
=
mGamepads
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Gamepad
*
gamepad
=
iter
.
UserData
(
)
;
aGamepads
.
EnsureLengthAtLeast
(
gamepad
-
>
Index
(
)
+
1
)
;
aGamepads
[
gamepad
-
>
Index
(
)
]
=
gamepad
;
}
}
already_AddRefed
<
Gamepad
>
nsGlobalWindowInner
:
:
GetGamepad
(
uint32_t
aIndex
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
RefPtr
<
Gamepad
>
gamepad
;
if
(
mGamepads
.
Get
(
aIndex
getter_AddRefs
(
gamepad
)
)
)
{
return
gamepad
.
forget
(
)
;
}
return
nullptr
;
}
void
nsGlobalWindowInner
:
:
SetHasSeenGamepadInput
(
bool
aHasSeen
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
mHasSeenGamepadInput
=
aHasSeen
;
}
bool
nsGlobalWindowInner
:
:
HasSeenGamepadInput
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
mHasSeenGamepadInput
;
}
void
nsGlobalWindowInner
:
:
SyncGamepadState
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mHasSeenGamepadInput
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
for
(
auto
iter
=
mGamepads
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
gamepadManager
-
>
SyncGamepadState
(
iter
.
Key
(
)
iter
.
UserData
(
)
)
;
}
}
}
void
nsGlobalWindowInner
:
:
StopGamepadHaptics
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mHasSeenGamepadInput
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
gamepadManager
-
>
StopHaptics
(
)
;
}
}
bool
nsGlobalWindowInner
:
:
UpdateVRDisplays
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
VRDisplay
>
>
&
aDevices
)
{
FORWARD_TO_INNER
(
UpdateVRDisplays
(
aDevices
)
false
)
;
VRDisplay
:
:
UpdateVRDisplays
(
mVRDisplays
AsInner
(
)
)
;
aDevices
=
mVRDisplays
;
return
true
;
}
void
nsGlobalWindowInner
:
:
NotifyActiveVRDisplaysChanged
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
mNavigator
)
{
mNavigator
-
>
NotifyActiveVRDisplaysChanged
(
)
;
}
}
uint32_t
nsGlobalWindowInner
:
:
GetAutoActivateVRDisplayID
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
uint32_t
retVal
=
mAutoActivateVRDisplayID
;
mAutoActivateVRDisplayID
=
0
;
return
retVal
;
}
void
nsGlobalWindowInner
:
:
SetAutoActivateVRDisplayID
(
uint32_t
aAutoActivateVRDisplayID
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
mAutoActivateVRDisplayID
=
aAutoActivateVRDisplayID
;
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayActivate
(
uint32_t
aDisplayID
mozilla
:
:
dom
:
:
VRDisplayEventReason
aReason
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
if
(
aReason
!
=
VRDisplayEventReason
:
:
Navigation
&
&
display
-
>
IsAnyPresenting
(
gfx
:
:
kVRGroupContent
)
)
{
continue
;
}
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
init
.
mReason
.
Construct
(
aReason
)
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplayactivate
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
defaultActionEnabled
;
display
-
>
StartHandlingVRNavigationEvent
(
)
;
Unused
<
<
DispatchEvent
(
event
&
defaultActionEnabled
)
;
display
-
>
StopHandlingVRNavigationEvent
(
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayDeactivate
(
uint32_t
aDisplayID
mozilla
:
:
dom
:
:
VRDisplayEventReason
aReason
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
&
&
display
-
>
IsPresenting
(
)
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
init
.
mReason
.
Construct
(
aReason
)
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplaydeactivate
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
defaultActionEnabled
;
Unused
<
<
DispatchEvent
(
event
&
defaultActionEnabled
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayConnect
(
uint32_t
aDisplayID
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplayconnect
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
defaultActionEnabled
;
Unused
<
<
DispatchEvent
(
event
&
defaultActionEnabled
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayDisconnect
(
uint32_t
aDisplayID
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplaydisconnect
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
defaultActionEnabled
;
Unused
<
<
DispatchEvent
(
event
&
defaultActionEnabled
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayPresentChange
(
uint32_t
aDisplayID
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplaypresentchange
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
bool
defaultActionEnabled
;
Unused
<
<
DispatchEvent
(
event
&
defaultActionEnabled
)
;
return
;
}
}
}
enum
WindowState
{
STATE_MAXIMIZED
=
1
STATE_MINIMIZED
=
2
STATE_NORMAL
=
3
STATE_FULLSCREEN
=
4
}
;
uint16_t
nsGlobalWindowInner
:
:
WindowState
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
int32_t
mode
=
widget
?
widget
-
>
SizeMode
(
)
:
0
;
switch
(
mode
)
{
case
nsSizeMode_Minimized
:
return
STATE_MINIMIZED
;
case
nsSizeMode_Maximized
:
return
STATE_MAXIMIZED
;
case
nsSizeMode_Fullscreen
:
return
STATE_FULLSCREEN
;
case
nsSizeMode_Normal
:
return
STATE_NORMAL
;
default
:
NS_WARNING
(
"
Illegal
window
state
for
this
chrome
window
"
)
;
break
;
}
return
STATE_NORMAL
;
}
bool
nsGlobalWindowInner
:
:
IsFullyOccluded
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
return
widget
&
&
widget
-
>
IsFullyOccluded
(
)
;
}
void
nsGlobalWindowInner
:
:
Maximize
(
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
widget
-
>
SetSizeMode
(
nsSizeMode_Maximized
)
;
}
}
void
nsGlobalWindowInner
:
:
Minimize
(
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
widget
-
>
SetSizeMode
(
nsSizeMode_Minimized
)
;
}
}
void
nsGlobalWindowInner
:
:
Restore
(
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
widget
-
>
SetSizeMode
(
nsSizeMode_Normal
)
;
}
}
void
nsGlobalWindowInner
:
:
GetAttention
(
ErrorResult
&
aResult
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
return
GetAttentionWithCycleCount
(
-
1
aResult
)
;
}
void
nsGlobalWindowInner
:
:
GetAttentionWithCycleCount
(
int32_t
aCycleCount
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
aError
=
widget
-
>
GetAttention
(
aCycleCount
)
;
}
}
void
nsGlobalWindowInner
:
:
BeginWindowMove
(
Event
&
aMouseDownEvent
Element
*
aPanel
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIWidget
>
widget
;
#
ifdef
MOZ_XUL
if
(
aPanel
)
{
nsIFrame
*
frame
=
aPanel
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsMenuPopupFrame
(
)
)
{
return
;
}
widget
=
(
static_cast
<
nsMenuPopupFrame
*
>
(
frame
)
)
-
>
GetWidget
(
)
;
}
else
{
#
endif
widget
=
GetMainWidget
(
)
;
#
ifdef
MOZ_XUL
}
#
endif
if
(
!
widget
)
{
return
;
}
WidgetMouseEvent
*
mouseEvent
=
aMouseDownEvent
.
WidgetEventPtr
(
)
-
>
AsMouseEvent
(
)
;
if
(
!
mouseEvent
|
|
mouseEvent
-
>
mClass
!
=
eMouseEventClass
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aError
=
widget
-
>
BeginMoveDrag
(
mouseEvent
)
;
}
already_AddRefed
<
nsWindowRoot
>
nsGlobalWindowInner
:
:
GetWindowRootOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
GetTopWindowRoot
(
)
;
return
root
.
forget
(
)
.
downcast
<
nsWindowRoot
>
(
)
;
}
already_AddRefed
<
nsWindowRoot
>
nsGlobalWindowInner
:
:
GetWindowRoot
(
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetWindowRootOuter
(
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
SetCursorOuter
(
const
nsAString
&
aCursor
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
int32_t
cursor
;
if
(
aCursor
.
EqualsLiteral
(
"
auto
"
)
)
cursor
=
NS_STYLE_CURSOR_AUTO
;
else
{
nsCSSKeyword
keyword
=
nsCSSKeywords
:
:
LookupKeyword
(
aCursor
)
;
if
(
!
nsCSSProps
:
:
FindKeyword
(
keyword
nsCSSProps
:
:
kCursorKTable
cursor
)
)
{
return
;
}
}
RefPtr
<
nsPresContext
>
presContext
;
if
(
mDocShell
)
{
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
}
if
(
presContext
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
=
mDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsViewManager
*
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsView
*
rootView
=
vm
-
>
GetRootView
(
)
;
if
(
!
rootView
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsIWidget
*
widget
=
rootView
-
>
GetNearestWidget
(
nullptr
)
;
if
(
!
widget
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aError
=
presContext
-
>
EventStateManager
(
)
-
>
SetCursor
(
cursor
nullptr
false
0
.
0f
0
.
0f
widget
true
)
;
}
}
void
nsGlobalWindowInner
:
:
SetCursor
(
const
nsAString
&
aCursor
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetCursorOuter
(
aCursor
aError
)
aError
)
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
GetBrowserDOMWindow
(
nsIBrowserDOMWindow
*
*
aBrowserWindow
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
FORWARD_TO_INNER
(
GetBrowserDOMWindow
(
aBrowserWindow
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
NS_IF_ADDREF
(
*
aBrowserWindow
=
GetBrowserDOMWindow
(
rv
)
)
;
return
rv
.
StealNSResult
(
)
;
}
nsIBrowserDOMWindow
*
nsGlobalWindowInner
:
:
GetBrowserDOMWindowOuter
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
return
mChromeFields
.
mBrowserDOMWindow
;
}
nsIBrowserDOMWindow
*
nsGlobalWindowInner
:
:
GetBrowserDOMWindow
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetBrowserDOMWindowOuter
(
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
SetBrowserDOMWindowOuter
(
nsIBrowserDOMWindow
*
aBrowserWindow
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
mChromeFields
.
mBrowserDOMWindow
=
aBrowserWindow
;
}
void
nsGlobalWindowInner
:
:
SetBrowserDOMWindow
(
nsIBrowserDOMWindow
*
aBrowserWindow
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetBrowserDOMWindowOuter
(
aBrowserWindow
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
NotifyDefaultButtonLoaded
(
Element
&
aDefaultButton
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
#
ifdef
MOZ_XUL
nsCOMPtr
<
nsIDOMXULControlElement
>
xulControl
=
do_QueryInterface
(
&
aDefaultButton
)
;
if
(
!
xulControl
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
bool
disabled
;
aError
=
xulControl
-
>
GetDisabled
(
&
disabled
)
;
if
(
aError
.
Failed
(
)
|
|
disabled
)
{
return
;
}
nsIFrame
*
frame
=
aDefaultButton
.
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
LayoutDeviceIntRect
buttonRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
frame
-
>
GetScreenRectInAppUnits
(
)
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
nsIWidget
*
widget
=
GetNearestWidget
(
)
;
if
(
!
widget
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
LayoutDeviceIntRect
widgetRect
=
widget
-
>
GetScreenBounds
(
)
;
buttonRect
-
=
widgetRect
.
TopLeft
(
)
;
nsresult
rv
=
widget
-
>
OnDefaultButtonLoaded
(
buttonRect
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_NOT_IMPLEMENTED
)
{
aError
.
Throw
(
rv
)
;
}
#
else
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
#
endif
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
GetMessageManager
(
nsIMessageBroadcaster
*
*
aManager
)
{
FORWARD_TO_INNER
(
GetMessageManager
(
aManager
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
NS_IF_ADDREF
(
*
aManager
=
GetMessageManager
(
rv
)
)
;
return
rv
.
StealNSResult
(
)
;
}
nsIMessageBroadcaster
*
nsGlobalWindowInner
:
:
GetMessageManager
(
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mChromeFields
.
mMessageManager
)
{
nsCOMPtr
<
nsIMessageBroadcaster
>
globalMM
=
do_GetService
(
"
mozilla
.
org
/
globalmessagemanager
;
1
"
)
;
mChromeFields
.
mMessageManager
=
new
nsFrameMessageManager
(
nullptr
static_cast
<
nsFrameMessageManager
*
>
(
globalMM
.
get
(
)
)
MM_CHROME
|
MM_BROADCASTER
)
;
}
return
mChromeFields
.
mMessageManager
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
GetGroupMessageManager
(
const
nsAString
&
aGroup
nsIMessageBroadcaster
*
*
aManager
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
FORWARD_TO_INNER
(
GetGroupMessageManager
(
aGroup
aManager
)
NS_ERROR_UNEXPECTED
)
;
ErrorResult
rv
;
NS_IF_ADDREF
(
*
aManager
=
GetGroupMessageManager
(
aGroup
rv
)
)
;
return
rv
.
StealNSResult
(
)
;
}
nsIMessageBroadcaster
*
nsGlobalWindowInner
:
:
GetGroupMessageManager
(
const
nsAString
&
aGroup
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
nsCOMPtr
<
nsIMessageBroadcaster
>
messageManager
=
mChromeFields
.
mGroupMessageManagers
.
LookupForAdd
(
aGroup
)
.
OrInsert
(
[
this
&
aError
]
(
)
{
nsFrameMessageManager
*
parent
=
static_cast
<
nsFrameMessageManager
*
>
(
GetMessageManager
(
aError
)
)
;
return
new
nsFrameMessageManager
(
nullptr
parent
MM_CHROME
|
MM_BROADCASTER
)
;
}
)
;
return
messageManager
;
}
nsresult
nsGlobalWindowInner
:
:
SetOpenerForInitialContentBrowser
(
mozIDOMWindowProxy
*
aOpenerWindow
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
MOZ_ASSERT
(
!
mChromeFields
.
mOpenerForInitialContentBrowser
)
;
mChromeFields
.
mOpenerForInitialContentBrowser
=
aOpenerWindow
;
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
TakeOpenerForInitialContentBrowser
(
mozIDOMWindowProxy
*
*
aOpenerWindow
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
mChromeFields
.
mOpenerForInitialContentBrowser
.
forget
(
aOpenerWindow
)
;
return
NS_OK
;
}
void
nsGlobalWindowInner
:
:
InitWasOffline
(
)
{
mWasOffline
=
NS_IsOffline
(
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
int16_t
nsGlobalWindowInner
:
:
Orientation
(
CallerType
aCallerType
)
const
{
return
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
?
0
:
WindowOrientationObserver
:
:
OrientationAngle
(
)
;
}
#
endif
Console
*
nsGlobalWindowInner
:
:
GetConsole
(
ErrorResult
&
aRv
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mConsole
)
{
mConsole
=
Console
:
:
Create
(
AsInner
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
return
mConsole
;
}
bool
nsGlobalWindowInner
:
:
IsSecureContext
(
)
const
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
return
JS_GetIsSecureContext
(
js
:
:
GetObjectCompartment
(
GetWrapperPreserveColor
(
)
)
)
;
}
bool
nsGlobalWindowInner
:
:
IsSecureContextIfOpenerIgnored
(
)
const
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
return
mIsSecureContextIfOpenerIgnored
;
}
already_AddRefed
<
External
>
nsGlobalWindowInner
:
:
GetExternal
(
ErrorResult
&
aRv
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
#
ifdef
HAVE_SIDEBAR
if
(
!
mExternal
)
{
AutoJSContext
cx
;
JS
:
:
Rooted
<
JSObject
*
>
jsImplObj
(
cx
)
;
ConstructJSImplementation
(
"
mozilla
.
org
/
sidebar
;
1
"
this
&
jsImplObj
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
mExternal
=
new
External
(
jsImplObj
this
)
;
}
RefPtr
<
External
>
external
=
static_cast
<
External
*
>
(
mExternal
.
get
(
)
)
;
return
external
.
forget
(
)
;
#
else
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
#
endif
}
void
nsGlobalWindowInner
:
:
GetSidebar
(
OwningExternalOrWindowProxy
&
aResult
ErrorResult
&
aRv
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
#
ifdef
HAVE_SIDEBAR
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
GetChildWindow
(
NS_LITERAL_STRING
(
"
sidebar
"
)
)
;
if
(
domWindow
)
{
aResult
.
SetAsWindowProxy
(
)
=
domWindow
.
forget
(
)
;
return
;
}
RefPtr
<
External
>
external
=
GetExternal
(
aRv
)
;
if
(
external
)
{
aResult
.
SetAsExternal
(
)
=
external
;
}
#
else
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
#
endif
}
void
nsGlobalWindowInner
:
:
ClearDocumentDependentSlots
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
WindowBinding
:
:
ClearCachedDocumentValue
(
aCx
AssertInner
(
)
)
|
|
!
WindowBinding
:
:
ClearCachedPerformanceValue
(
aCx
AssertInner
(
)
)
)
{
MOZ_CRASH
(
"
Unhandlable
OOM
while
clearing
document
dependent
slots
.
"
)
;
}
}
JSObject
*
nsGlobalWindowInner
:
:
CreateNamedPropertiesObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aProto
)
{
return
WindowNamedPropertiesHandler
:
:
Create
(
aCx
aProto
)
;
}
bool
nsGlobalWindowInner
:
:
GetIsPrerendered
(
)
{
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
return
docShell
&
&
docShell
-
>
GetIsPrerendered
(
)
;
}
void
nsGlobalWindowInner
:
:
ReportLargeAllocStatus
(
)
{
MOZ_RELEASE_ASSERT
(
IsOuterWindow
(
)
)
;
uint32_t
errorFlags
=
nsIScriptError
:
:
warningFlag
;
const
char
*
message
=
nullptr
;
switch
(
mLargeAllocStatus
)
{
case
LargeAllocStatus
:
:
SUCCESS
:
errorFlags
=
nsIScriptError
:
:
infoFlag
;
message
=
"
LargeAllocationSuccess
"
;
break
;
case
LargeAllocStatus
:
:
NON_WIN32
:
errorFlags
=
nsIScriptError
:
:
infoFlag
;
message
=
"
LargeAllocationNonWin32
"
;
break
;
case
LargeAllocStatus
:
:
NON_GET
:
message
=
"
LargeAllocationNonGetRequest
"
;
break
;
case
LargeAllocStatus
:
:
NON_E10S
:
message
=
"
LargeAllocationNonE10S
"
;
break
;
case
LargeAllocStatus
:
:
NOT_ONLY_TOPLEVEL_IN_TABGROUP
:
message
=
"
LargeAllocationNotOnlyToplevelInTabGroup
"
;
break
;
default
:
return
;
}
nsContentUtils
:
:
ReportToConsole
(
errorFlags
NS_LITERAL_CSTRING
(
"
DOM
"
)
mDoc
nsContentUtils
:
:
eDOM_PROPERTIES
message
)
;
}
void
nsGlobalWindowInner
:
:
RedefineProperty
(
JSContext
*
aCx
const
char
*
aPropName
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aError
)
{
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
aCx
GetWrapperPreserveColor
(
)
)
;
if
(
!
thisObj
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
!
JS_WrapObject
(
aCx
&
thisObj
)
|
|
!
JS_DefineProperty
(
aCx
thisObj
aPropName
aValue
JSPROP_ENUMERATE
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
void
nsGlobalWindowInner
:
:
GetReplaceableWindowCoord
(
JSContext
*
aCx
nsGlobalWindowInner
:
:
WindowCoordGetter
aGetter
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
int32_t
coord
=
(
this
-
>
*
aGetter
)
(
aCallerType
aError
)
;
if
(
!
aError
.
Failed
(
)
&
&
!
ToJSValue
(
aCx
coord
aRetval
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
void
nsGlobalWindowInner
:
:
SetReplaceableWindowCoord
(
JSContext
*
aCx
nsGlobalWindowInner
:
:
WindowCoordSetter
aSetter
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
const
char
*
aPropName
CallerType
aCallerType
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
|
|
!
outer
-
>
CanMoveResizeWindows
(
aCallerType
)
|
|
outer
-
>
IsFrame
(
)
)
{
RedefineProperty
(
aCx
aPropName
aValue
aError
)
;
return
;
}
int32_t
value
;
if
(
!
ValueToPrimitive
<
int32_t
eDefault
>
(
aCx
aValue
&
value
)
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
GetDocShell
(
)
)
)
{
bool
innerWidthSpecified
=
false
;
bool
innerHeightSpecified
=
false
;
bool
outerWidthSpecified
=
false
;
bool
outerHeightSpecified
=
false
;
if
(
strcmp
(
aPropName
"
innerWidth
"
)
=
=
0
)
{
innerWidthSpecified
=
true
;
}
else
if
(
strcmp
(
aPropName
"
innerHeight
"
)
=
=
0
)
{
innerHeightSpecified
=
true
;
}
else
if
(
strcmp
(
aPropName
"
outerWidth
"
)
=
=
0
)
{
outerWidthSpecified
=
true
;
}
else
if
(
strcmp
(
aPropName
"
outerHeight
"
)
=
=
0
)
{
outerHeightSpecified
=
true
;
}
if
(
innerWidthSpecified
|
|
innerHeightSpecified
|
|
outerWidthSpecified
|
|
outerHeightSpecified
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
outer
-
>
GetTreeOwnerWindow
(
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
int32_t
winLeft
=
0
;
int32_t
winTop
=
0
;
int32_t
winWidth
=
0
;
int32_t
winHeight
=
0
;
double
scale
=
1
.
0
;
if
(
treeOwnerAsWin
&
&
screenMgr
)
{
treeOwnerAsWin
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
treeOwnerAsWin
-
>
GetPositionAndSize
(
&
winLeft
&
winTop
&
winWidth
&
winHeight
)
;
winLeft
=
NSToIntRound
(
winHeight
/
scale
)
;
winTop
=
NSToIntRound
(
winWidth
/
scale
)
;
winWidth
=
NSToIntRound
(
winWidth
/
scale
)
;
winHeight
=
NSToIntRound
(
winHeight
/
scale
)
;
CSSIntSize
contentSize
;
outer
-
>
GetInnerSize
(
contentSize
)
;
screenMgr
-
>
ScreenForRect
(
winLeft
winTop
winWidth
winHeight
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
*
targetContentWidth
=
nullptr
;
int32_t
*
targetContentHeight
=
nullptr
;
int32_t
screenWidth
=
0
;
int32_t
screenHeight
=
0
;
int32_t
chromeWidth
=
0
;
int32_t
chromeHeight
=
0
;
int32_t
inputWidth
=
0
;
int32_t
inputHeight
=
0
;
int32_t
unused
=
0
;
screen
-
>
GetAvailRect
(
&
unused
&
unused
&
screenWidth
&
screenHeight
)
;
screenWidth
=
NSToIntRound
(
screenWidth
/
scale
)
;
screenHeight
=
NSToIntRound
(
screenHeight
/
scale
)
;
chromeWidth
=
winWidth
-
contentSize
.
width
;
chromeHeight
=
winHeight
-
contentSize
.
height
;
if
(
innerWidthSpecified
|
|
outerWidthSpecified
)
{
inputWidth
=
value
;
targetContentWidth
=
&
value
;
targetContentHeight
=
&
unused
;
}
else
if
(
innerHeightSpecified
|
|
outerHeightSpecified
)
{
inputHeight
=
value
;
targetContentWidth
=
&
unused
;
targetContentHeight
=
&
value
;
}
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
chromeWidth
chromeHeight
screenWidth
screenHeight
inputWidth
inputHeight
outerWidthSpecified
outerHeightSpecified
targetContentWidth
targetContentHeight
)
;
}
}
}
}
(
this
-
>
*
aSetter
)
(
value
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
FireOnNewGlobalObject
(
)
{
MOZ_ASSERT
(
IsInnerWindow
(
)
)
;
AutoEntryScript
aes
(
this
"
nsGlobalWindowInner
report
new
global
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aes
.
cx
(
)
GetWrapper
(
)
)
;
JS_FireOnNewGlobalObject
(
aes
.
cx
(
)
global
)
;
}
#
ifdef
_WINDOWS_
#
error
"
Never
include
windows
.
h
in
this
file
!
"
#
endif
already_AddRefed
<
Promise
>
nsGlobalWindowInner
:
:
CreateImageBitmap
(
JSContext
*
aCx
const
ImageBitmapSource
&
aImage
ErrorResult
&
aRv
)
{
if
(
aImage
.
IsArrayBuffer
(
)
|
|
aImage
.
IsArrayBufferView
(
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
return
ImageBitmap
:
:
Create
(
this
aImage
Nothing
(
)
aRv
)
;
}
already_AddRefed
<
Promise
>
nsGlobalWindowInner
:
:
CreateImageBitmap
(
JSContext
*
aCx
const
ImageBitmapSource
&
aImage
int32_t
aSx
int32_t
aSy
int32_t
aSw
int32_t
aSh
ErrorResult
&
aRv
)
{
if
(
aImage
.
IsArrayBuffer
(
)
|
|
aImage
.
IsArrayBufferView
(
)
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
}
return
ImageBitmap
:
:
Create
(
this
aImage
Some
(
gfx
:
:
IntRect
(
aSx
aSy
aSw
aSh
)
)
aRv
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
nsGlobalWindowInner
:
:
CreateImageBitmap
(
JSContext
*
aCx
const
ImageBitmapSource
&
aImage
int32_t
aOffset
int32_t
aLength
ImageBitmapFormat
aFormat
const
Sequence
<
ChannelPixelLayout
>
&
aLayout
ErrorResult
&
aRv
)
{
if
(
!
ImageBitmap
:
:
ExtensionsEnabled
(
aCx
)
)
{
aRv
.
Throw
(
NS_ERROR_TYPE_ERR
)
;
return
nullptr
;
}
if
(
aImage
.
IsArrayBuffer
(
)
|
|
aImage
.
IsArrayBufferView
(
)
)
{
return
ImageBitmap
:
:
Create
(
this
aImage
aOffset
aLength
aFormat
aLayout
aRv
)
;
}
aRv
.
Throw
(
NS_ERROR_TYPE_ERR
)
;
return
nullptr
;
}
void
nsGlobalWindowInner
:
:
CheckForDPIChange
(
)
{
if
(
mDocShell
)
{
RefPtr
<
nsPresContext
>
presContext
;
mDocShell
-
>
GetPresContext
(
getter_AddRefs
(
presContext
)
)
;
if
(
presContext
)
{
if
(
presContext
-
>
DeviceContext
(
)
-
>
CheckDPIChange
(
)
)
{
presContext
-
>
UIResolutionChanged
(
)
;
}
}
}
}
mozilla
:
:
dom
:
:
TabGroup
*
nsGlobalWindowInner
:
:
TabGroupOuter
(
)
{
MOZ_CRASH
(
"
Must
be
an
outer
window
"
)
;
}
mozilla
:
:
dom
:
:
TabGroup
*
nsGlobalWindowInner
:
:
TabGroupInner
(
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mTabGroup
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
MOZ_RELEASE_ASSERT
(
outer
"
Inner
window
without
outer
window
has
no
cached
tab
group
!
"
)
;
mTabGroup
=
outer
-
>
TabGroup
(
)
;
}
MOZ_ASSERT
(
mTabGroup
)
;
#
ifdef
DEBUG
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
MOZ_ASSERT_IF
(
outer
outer
-
>
TabGroup
(
)
=
=
mTabGroup
)
;
#
endif
return
mTabGroup
;
}
nsresult
nsGlobalWindowInner
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
Dispatch
(
aCategory
Move
(
aRunnable
)
)
;
}
return
DispatcherTrait
:
:
Dispatch
(
aCategory
Move
(
aRunnable
)
)
;
}
nsISerialEventTarget
*
nsGlobalWindowInner
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
EventTargetFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
EventTargetFor
(
aCategory
)
;
}
AbstractThread
*
nsGlobalWindowInner
:
:
AbstractMainThreadFor
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
AbstractMainThreadFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
AbstractMainThreadFor
(
aCategory
)
;
}
nsGlobalWindowInner
:
:
TemporarilyDisableDialogs
:
:
TemporarilyDisableDialogs
(
nsGlobalWindowOuter
*
aWindow
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
aWindow
)
;
nsGlobalWindowOuter
*
topWindowOuter
=
aWindow
-
>
GetScriptableTopInternal
(
)
;
if
(
!
topWindowOuter
)
{
NS_ERROR
(
"
nsGlobalWindowInner
:
:
TemporarilyDisableDialogs
used
without
a
top
"
"
window
?
"
)
;
return
;
}
nsGlobalWindowInner
*
topWindow
=
topWindowOuter
-
>
GetCurrentInnerWindowInternal
(
)
;
if
(
topWindow
)
{
mTopWindow
=
topWindow
;
mSavedDialogsEnabled
=
mTopWindow
-
>
mAreDialogsEnabled
;
mTopWindow
-
>
mAreDialogsEnabled
=
false
;
}
}
nsGlobalWindowInner
:
:
TemporarilyDisableDialogs
:
:
~
TemporarilyDisableDialogs
(
)
{
if
(
mTopWindow
)
{
mTopWindow
-
>
mAreDialogsEnabled
=
mSavedDialogsEnabled
;
}
}
Worklet
*
nsGlobalWindowInner
:
:
GetAudioWorklet
(
ErrorResult
&
aRv
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mAudioWorklet
)
{
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
mAudioWorklet
=
new
Worklet
(
AsInner
(
)
principal
Worklet
:
:
eAudioWorklet
)
;
}
return
mAudioWorklet
;
}
Worklet
*
nsGlobalWindowInner
:
:
GetPaintWorklet
(
ErrorResult
&
aRv
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mPaintWorklet
)
{
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
mPaintWorklet
=
new
Worklet
(
AsInner
(
)
principal
Worklet
:
:
ePaintWorklet
)
;
}
return
mPaintWorklet
;
}
void
nsGlobalWindowInner
:
:
GetRegionalPrefsLocales
(
nsTArray
<
nsString
>
&
aLocales
)
{
AutoTArray
<
nsCString
10
>
rpLocales
;
mozilla
:
:
intl
:
:
LocaleService
:
:
GetInstance
(
)
-
>
GetRegionalPrefsLocales
(
rpLocales
)
;
for
(
const
auto
&
loc
:
rpLocales
)
{
aLocales
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
loc
)
)
;
}
}
IntlUtils
*
nsGlobalWindowInner
:
:
GetIntlUtils
(
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsInnerWindow
(
)
)
;
if
(
!
mIntlUtils
)
{
mIntlUtils
=
new
IntlUtils
(
AsInner
(
)
)
;
}
return
mIntlUtils
;
}
already_AddRefed
<
nsGlobalWindowInner
>
nsGlobalWindowInner
:
:
Create
(
nsGlobalWindowOuter
*
aOuterWindow
bool
aIsChrome
)
{
RefPtr
<
nsGlobalWindowInner
>
window
=
new
nsGlobalWindowInner
(
aOuterWindow
)
;
if
(
aIsChrome
)
{
window
-
>
mIsChrome
=
true
;
window
-
>
mCleanMessageManager
=
true
;
}
window
-
>
InitWasOffline
(
)
;
return
window
.
forget
(
)
;
}
