#
include
"
nsGlobalWindow
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
Navigator
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsScreen
.
h
"
#
include
"
nsHistory
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsIDOMStorageManager
.
h
"
#
include
"
mozilla
/
dom
/
CallbackDebuggerNotification
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentFrameMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
CSPEvalChecker
.
h
"
#
include
"
mozilla
/
dom
/
DebuggerNotification
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
DOMJSProxyHandler
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
LocalStorage
.
h
"
#
include
"
mozilla
/
dom
/
LocalStorageCommon
.
h
"
#
include
"
mozilla
/
dom
/
LSObject
.
h
"
#
include
"
mozilla
/
dom
/
PartitionedLocalStorage
.
h
"
#
include
"
mozilla
/
dom
/
Storage
.
h
"
#
include
"
mozilla
/
dom
/
IdleRequest
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
StorageEvent
.
h
"
#
include
"
mozilla
/
dom
/
StorageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
StorageNotifierService
.
h
"
#
include
"
mozilla
/
dom
/
StorageUtils
.
h
"
#
include
"
mozilla
/
dom
/
Timeout
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutHandler
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
#
include
"
mozilla
/
dom
/
VisualViewport
.
h
"
#
include
"
mozilla
/
dom
/
WindowProxyHolder
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
mozilla
/
dom
/
WindowOrientationObserver
.
h
"
#
endif
#
include
"
nsDOMOfflineResourceList
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsISizeOfEventTarget
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
mozilla
/
dom
/
WakeLock
.
h
"
#
include
"
mozilla
/
dom
/
power
/
PowerManagerService
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsIDocumentLoader
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIPermission
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIController
.
h
"
#
include
"
nsISlowScriptDebug
.
h
"
#
include
"
nsWindowMemoryReporter
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
WindowNamedPropertiesHandler
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsVariant
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
WindowDestroyedEvent
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
Warnings
.
h
"
#
include
"
js
/
Wrapper
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
BarProps
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsLayoutStatics
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Debug
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ProcessHangMonitor
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
AudioChannelService
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
PostMessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_page_load
.
h
"
#
include
"
PaintWorkletImpl
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIDeviceSensors
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
Crypto
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsIEmbeddingSiteWindow
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIPromptService
.
h
"
#
include
"
nsIPromptFactory
.
h
"
#
include
"
nsIAddonPolicyService
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWebBrowserChrome
.
h
"
#
include
"
nsIWebBrowserFind
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsDOMWindowUtils
.
h
"
#
include
"
nsIWindowWatcher
.
h
"
#
include
"
nsPIWindowWatcher
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsGlobalWindowCommands
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsIURIFixup
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsIDOMXULControlElement
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
nsIJARChannel
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsICSSDeclaration
.
h
"
#
include
"
xpcprivate
.
h
"
#
ifdef
NS_PRINTING
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsIPrintSettingsService
.
h
"
#
include
"
nsIWebBrowserPrint
.
h
"
#
endif
#
include
"
nsWindowRoot
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsIArray
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
dom
/
IDBFactory
.
h
"
#
include
"
mozilla
/
dom
/
MessageChannel
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
Gamepad
.
h
"
#
include
"
mozilla
/
dom
/
GamepadManager
.
h
"
#
include
"
gfxVR
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplay
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplayEvent
.
h
"
#
include
"
mozilla
/
dom
/
VRDisplayEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
VREventObserver
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
Location
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
prrng
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
mozilla
/
dom
/
AudioContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowserElementDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
cache
/
CacheStorage
.
h
"
#
include
"
mozilla
/
dom
/
Console
.
h
"
#
include
"
mozilla
/
dom
/
Fetch
.
h
"
#
include
"
mozilla
/
dom
/
FunctionBinding
.
h
"
#
include
"
mozilla
/
dom
/
HashChangeEvent
.
h
"
#
include
"
mozilla
/
dom
/
IntlUtils
.
h
"
#
include
"
mozilla
/
dom
/
PopStateEvent
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlockedEvent
.
h
"
#
include
"
mozilla
/
dom
/
PrimitiveConversions
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
nsIBrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
LoadedScript
.
h
"
#
include
"
mozilla
/
dom
/
MediaQueryList
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
NavigatorBinding
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmap
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapBinding
.
h
"
#
include
"
mozilla
/
dom
/
InstallTriggerBinding
.
h
"
#
include
"
mozilla
/
dom
/
Report
.
h
"
#
include
"
mozilla
/
dom
/
ReportingObserver
.
h
"
#
include
"
mozilla
/
dom
/
SharedWorker
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorker
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistration
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrationDescriptor
.
h
"
#
include
"
mozilla
/
dom
/
U2F
.
h
"
#
include
"
mozilla
/
dom
/
WebIDLGlobalNameHash
.
h
"
#
include
"
mozilla
/
dom
/
Worklet
.
h
"
#
ifdef
HAVE_SIDEBAR
#
include
"
mozilla
/
dom
/
ExternalBinding
.
h
"
#
endif
#
ifdef
MOZ_WEBSPEECH
#
include
"
mozilla
/
dom
/
SpeechSynthesis
.
h
"
#
endif
#
include
"
mozilla
/
dom
/
ClientManager
.
h
"
#
include
"
mozilla
/
dom
/
ClientSource
.
h
"
#
include
"
mozilla
/
dom
/
ClientState
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
net
/
CookieSettings
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
SessionStorageCache
.
h
"
#
ifdef
ANDROID
#
include
<
android
/
log
.
h
>
#
endif
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
dom
:
:
ipc
;
using
mozilla
:
:
TimeDuration
;
using
mozilla
:
:
TimeStamp
;
using
mozilla
:
:
dom
:
:
cache
:
:
CacheStorage
;
#
define
FORWARD_TO_OUTER
(
method
args
err_rval
)
\
PR_BEGIN_MACRO
\
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
\
if
(
!
HasActiveDocument
(
)
)
{
\
NS_WARNING
(
outer
?
"
Inner
window
does
not
have
active
document
.
"
\
:
"
No
outer
window
available
!
"
)
;
\
return
err_rval
;
\
}
\
return
outer
-
>
method
args
;
\
PR_END_MACRO
static
nsGlobalWindowOuter
*
GetOuterWindowForForwarding
(
nsGlobalWindowInner
*
aInner
ErrorResult
&
aError
)
{
nsGlobalWindowOuter
*
outer
=
aInner
-
>
GetOuterWindowInternal
(
)
;
if
(
MOZ_LIKELY
(
aInner
-
>
HasActiveDocument
(
)
)
)
{
return
outer
;
}
if
(
!
outer
)
{
NS_WARNING
(
"
No
outer
window
available
!
"
)
;
aError
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
}
else
{
aError
.
Throw
(
NS_ERROR_XPC_SECURITY_MANAGER_VETO
)
;
}
return
nullptr
;
}
#
define
FORWARD_TO_OUTER_OR_THROW
(
method
args
errorresult
err_rval
)
\
PR_BEGIN_MACRO
\
nsGlobalWindowOuter
*
outer
=
GetOuterWindowForForwarding
(
this
errorresult
)
;
\
if
(
MOZ_LIKELY
(
outer
)
)
{
\
return
outer
-
>
method
args
;
\
}
\
return
err_rval
;
\
PR_END_MACRO
#
define
FORWARD_TO_OUTER_VOID
(
method
args
)
\
PR_BEGIN_MACRO
\
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
\
if
(
!
HasActiveDocument
(
)
)
{
\
NS_WARNING
(
outer
?
"
Inner
window
does
not
have
active
document
.
"
\
:
"
No
outer
window
available
!
"
)
;
\
return
;
\
}
\
outer
-
>
method
args
;
\
return
;
\
PR_END_MACRO
#
define
DOM_TOUCH_LISTENER_ADDED
"
dom
-
touch
-
listener
-
added
"
#
define
MEMORY_PRESSURE_OBSERVER_TOPIC
"
memory
-
pressure
"
#
define
DEFAULT_SUCCESSIVE_DIALOG_TIME_LIMIT
3
/
/
3
sec
#
define
MAX_SUCCESSIVE_DIALOG_COUNT
5
#
define
MAX_REPORT_RECORDS
100
static
LazyLogModule
gDOMLeakPRLogInner
(
"
DOMLeakInner
"
)
;
static
FILE
*
gDumpFile
=
nullptr
;
nsGlobalWindowInner
:
:
InnerWindowByIdTable
*
nsGlobalWindowInner
:
:
sInnerWindowsById
=
nullptr
;
bool
nsGlobalWindowInner
:
:
sDragServiceDisabled
=
false
;
bool
nsGlobalWindowInner
:
:
sMouseDown
=
false
;
class
nsGlobalWindowObserver
final
:
public
nsIObserver
public
nsIInterfaceRequestor
public
StorageNotificationObserver
{
public
:
explicit
nsGlobalWindowObserver
(
nsGlobalWindowInner
*
aWindow
)
:
mWindow
(
aWindow
)
{
}
NS_DECL_ISUPPORTS
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
if
(
!
mWindow
)
return
NS_OK
;
return
mWindow
-
>
Observe
(
aSubject
aTopic
aData
)
;
}
void
Forget
(
)
{
mWindow
=
nullptr
;
}
NS_IMETHOD
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
override
{
if
(
mWindow
&
&
aIID
.
Equals
(
NS_GET_IID
(
nsIDOMWindow
)
)
&
&
mWindow
)
{
return
mWindow
-
>
QueryInterface
(
aIID
aResult
)
;
}
return
NS_NOINTERFACE
;
}
void
ObserveStorageNotification
(
StorageEvent
*
aEvent
const
char16_t
*
aStorageType
bool
aPrivateBrowsing
)
override
{
if
(
mWindow
)
{
mWindow
-
>
ObserveStorageNotification
(
aEvent
aStorageType
aPrivateBrowsing
)
;
}
}
nsIPrincipal
*
GetEffectiveStoragePrincipal
(
)
const
override
{
return
mWindow
?
mWindow
-
>
GetEffectiveStoragePrincipal
(
)
:
nullptr
;
}
bool
IsPrivateBrowsing
(
)
const
override
{
return
mWindow
?
mWindow
-
>
IsPrivateBrowsing
(
)
:
false
;
}
nsIEventTarget
*
GetEventTarget
(
)
const
override
{
return
mWindow
?
mWindow
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
:
nullptr
;
}
private
:
~
nsGlobalWindowObserver
(
)
=
default
;
nsGlobalWindowInner
*
MOZ_NON_OWNING_REF
mWindow
;
}
;
NS_IMPL_ISUPPORTS
(
nsGlobalWindowObserver
nsIObserver
nsIInterfaceRequestor
)
class
IdleRequestExecutor
;
class
IdleRequestExecutorTimeoutHandler
final
:
public
TimeoutHandler
{
public
:
explicit
IdleRequestExecutorTimeoutHandler
(
IdleRequestExecutor
*
aExecutor
)
:
mExecutor
(
aExecutor
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
IdleRequestExecutorTimeoutHandler
)
bool
Call
(
const
char
*
)
override
;
private
:
~
IdleRequestExecutorTimeoutHandler
(
)
override
{
}
RefPtr
<
IdleRequestExecutor
>
mExecutor
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
IdleRequestExecutorTimeoutHandler
mExecutor
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IdleRequestExecutorTimeoutHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IdleRequestExecutorTimeoutHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IdleRequestExecutorTimeoutHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
class
IdleRequestExecutor
final
:
public
nsIRunnable
public
nsICancelableRunnable
public
nsINamed
public
nsIIdleRunnable
{
public
:
explicit
IdleRequestExecutor
(
nsGlobalWindowInner
*
aWindow
)
:
mDispatched
(
false
)
mDeadline
(
TimeStamp
:
:
Now
(
)
)
mWindow
(
aWindow
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
)
;
mIdlePeriodLimit
=
{
mDeadline
mWindow
-
>
LastIdleRequestHandle
(
)
}
;
mDelayedExecutorDispatcher
=
new
IdleRequestExecutorTimeoutHandler
(
this
)
;
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
IdleRequestExecutor
nsIRunnable
)
NS_DECL_NSIRUNNABLE
NS_DECL_NSINAMED
nsresult
Cancel
(
)
override
;
void
SetDeadline
(
TimeStamp
aDeadline
)
override
;
bool
IsCancelled
(
)
const
{
return
!
mWindow
|
|
mWindow
-
>
IsDying
(
)
;
}
bool
IneligibleForCurrentIdlePeriod
(
IdleRequest
*
aRequest
)
const
{
return
aRequest
-
>
Handle
(
)
>
=
mIdlePeriodLimit
.
mLastRequestIdInIdlePeriod
&
&
TimeStamp
:
:
Now
(
)
<
=
mIdlePeriodLimit
.
mEndOfIdlePeriod
;
}
void
MaybeUpdateIdlePeriodLimit
(
)
;
void
MaybeDispatch
(
TimeStamp
aDelayUntil
=
TimeStamp
(
)
)
;
void
ScheduleDispatch
(
)
;
private
:
struct
IdlePeriodLimit
{
TimeStamp
mEndOfIdlePeriod
;
uint32_t
mLastRequestIdInIdlePeriod
;
}
;
void
DelayedDispatch
(
uint32_t
aDelay
)
;
~
IdleRequestExecutor
(
)
override
{
}
bool
mDispatched
;
TimeStamp
mDeadline
;
IdlePeriodLimit
mIdlePeriodLimit
;
RefPtr
<
nsGlobalWindowInner
>
mWindow
;
RefPtr
<
TimeoutHandler
>
mDelayedExecutorDispatcher
;
Maybe
<
int32_t
>
mDelayedExecutorHandle
;
}
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDelayedExecutorDispatcher
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
IdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDelayedExecutorDispatcher
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IdleRequestExecutor
)
NS_INTERFACE_MAP_ENTRY
(
nsIRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsICancelableRunnable
)
NS_INTERFACE_MAP_ENTRY
(
nsINamed
)
NS_INTERFACE_MAP_ENTRY
(
nsIIdleRunnable
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIRunnable
)
NS_INTERFACE_MAP_END
NS_IMETHODIMP
IdleRequestExecutor
:
:
GetName
(
nsACString
&
aName
)
{
aName
.
AssignLiteral
(
"
IdleRequestExecutor
"
)
;
return
NS_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
IdleRequestExecutor
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mDispatched
=
false
;
if
(
mWindow
)
{
RefPtr
<
nsGlobalWindowInner
>
window
(
mWindow
)
;
window
-
>
ExecuteIdleRequest
(
mDeadline
)
;
}
return
NS_OK
;
}
nsresult
IdleRequestExecutor
:
:
Cancel
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mDelayedExecutorHandle
&
&
mWindow
)
{
mWindow
-
>
TimeoutManager
(
)
.
ClearTimeout
(
mDelayedExecutorHandle
.
value
(
)
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
)
;
}
mWindow
=
nullptr
;
return
NS_OK
;
}
void
IdleRequestExecutor
:
:
SetDeadline
(
TimeStamp
aDeadline
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mWindow
)
{
return
;
}
mDeadline
=
aDeadline
;
}
void
IdleRequestExecutor
:
:
MaybeUpdateIdlePeriodLimit
(
)
{
if
(
TimeStamp
:
:
Now
(
)
>
mIdlePeriodLimit
.
mEndOfIdlePeriod
)
{
mIdlePeriodLimit
=
{
mDeadline
mWindow
-
>
LastIdleRequestHandle
(
)
}
;
}
}
void
IdleRequestExecutor
:
:
MaybeDispatch
(
TimeStamp
aDelayUntil
)
{
if
(
mDispatched
|
|
IsCancelled
(
)
)
{
return
;
}
mDispatched
=
true
;
nsPIDOMWindowOuter
*
outer
=
mWindow
-
>
GetOuterWindow
(
)
;
if
(
outer
&
&
outer
-
>
IsBackground
(
)
)
{
DelayedDispatch
(
0
)
;
return
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
!
aDelayUntil
|
|
aDelayUntil
<
now
)
{
ScheduleDispatch
(
)
;
return
;
}
TimeDuration
delay
=
aDelayUntil
-
now
;
DelayedDispatch
(
static_cast
<
uint32_t
>
(
delay
.
ToMilliseconds
(
)
)
)
;
}
void
IdleRequestExecutor
:
:
ScheduleDispatch
(
)
{
MOZ_ASSERT
(
mWindow
)
;
mDelayedExecutorHandle
=
Nothing
(
)
;
RefPtr
<
IdleRequestExecutor
>
request
=
this
;
NS_DispatchToCurrentThreadQueue
(
request
.
forget
(
)
EventQueuePriority
:
:
Idle
)
;
}
void
IdleRequestExecutor
:
:
DelayedDispatch
(
uint32_t
aDelay
)
{
MOZ_ASSERT
(
mWindow
)
;
MOZ_ASSERT
(
mDelayedExecutorHandle
.
isNothing
(
)
)
;
int32_t
handle
;
mWindow
-
>
TimeoutManager
(
)
.
SetTimeout
(
mDelayedExecutorDispatcher
aDelay
false
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
&
handle
)
;
mDelayedExecutorHandle
=
Some
(
handle
)
;
}
bool
IdleRequestExecutorTimeoutHandler
:
:
Call
(
const
char
*
)
{
if
(
!
mExecutor
-
>
IsCancelled
(
)
)
{
mExecutor
-
>
ScheduleDispatch
(
)
;
}
return
true
;
}
void
nsGlobalWindowInner
:
:
ScheduleIdleRequestDispatch
(
)
{
AssertIsOnMainThread
(
)
;
if
(
!
mIdleRequestExecutor
)
{
mIdleRequestExecutor
=
new
IdleRequestExecutor
(
this
)
;
}
mIdleRequestExecutor
-
>
MaybeDispatch
(
)
;
}
void
nsGlobalWindowInner
:
:
SuspendIdleRequests
(
)
{
if
(
mIdleRequestExecutor
)
{
mIdleRequestExecutor
-
>
Cancel
(
)
;
mIdleRequestExecutor
=
nullptr
;
}
}
void
nsGlobalWindowInner
:
:
ResumeIdleRequests
(
)
{
MOZ_ASSERT
(
!
mIdleRequestExecutor
)
;
ScheduleIdleRequestDispatch
(
)
;
}
void
nsGlobalWindowInner
:
:
RemoveIdleCallback
(
mozilla
:
:
dom
:
:
IdleRequest
*
aRequest
)
{
AssertIsOnMainThread
(
)
;
if
(
aRequest
-
>
HasTimeout
(
)
)
{
mTimeoutManager
-
>
ClearTimeout
(
aRequest
-
>
GetTimeoutHandle
(
)
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
)
;
}
aRequest
-
>
removeFrom
(
mIdleRequestCallbacks
)
;
}
void
nsGlobalWindowInner
:
:
RunIdleRequest
(
IdleRequest
*
aRequest
DOMHighResTimeStamp
aDeadline
bool
aDidTimeout
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
IdleRequest
>
request
(
aRequest
)
;
RemoveIdleCallback
(
request
)
;
request
-
>
IdleRun
(
this
aDeadline
aDidTimeout
)
;
}
void
nsGlobalWindowInner
:
:
ExecuteIdleRequest
(
TimeStamp
aDeadline
)
{
AssertIsOnMainThread
(
)
;
RefPtr
<
IdleRequest
>
request
=
mIdleRequestCallbacks
.
getFirst
(
)
;
if
(
!
request
)
{
return
;
}
if
(
mIdleRequestExecutor
-
>
IneligibleForCurrentIdlePeriod
(
request
)
)
{
mIdleRequestExecutor
-
>
MaybeDispatch
(
aDeadline
)
;
return
;
}
DOMHighResTimeStamp
deadline
=
0
.
0
;
if
(
Performance
*
perf
=
GetPerformance
(
)
)
{
deadline
=
perf
-
>
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
aDeadline
)
;
}
mIdleRequestExecutor
-
>
MaybeUpdateIdlePeriodLimit
(
)
;
RunIdleRequest
(
request
deadline
false
)
;
if
(
mIdleRequestExecutor
)
{
mIdleRequestExecutor
-
>
MaybeDispatch
(
)
;
}
}
class
IdleRequestTimeoutHandler
final
:
public
TimeoutHandler
{
public
:
IdleRequestTimeoutHandler
(
JSContext
*
aCx
IdleRequest
*
aIdleRequest
nsPIDOMWindowInner
*
aWindow
)
:
TimeoutHandler
(
aCx
)
mIdleRequest
(
aIdleRequest
)
mWindow
(
aWindow
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
IdleRequestTimeoutHandler
)
MOZ_CAN_RUN_SCRIPT
bool
Call
(
const
char
*
)
override
{
RefPtr
<
nsGlobalWindowInner
>
window
(
nsGlobalWindowInner
:
:
Cast
(
mWindow
)
)
;
RefPtr
<
IdleRequest
>
request
(
mIdleRequest
)
;
window
-
>
RunIdleRequest
(
request
0
.
0
true
)
;
return
true
;
}
private
:
~
IdleRequestTimeoutHandler
(
)
override
{
}
RefPtr
<
IdleRequest
>
mIdleRequest
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
IdleRequestTimeoutHandler
mIdleRequest
mWindow
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
IdleRequestTimeoutHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
IdleRequestTimeoutHandler
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
IdleRequestTimeoutHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
uint32_t
nsGlobalWindowInner
:
:
RequestIdleCallback
(
JSContext
*
aCx
IdleRequestCallback
&
aCallback
const
IdleRequestOptions
&
aOptions
ErrorResult
&
aError
)
{
AssertIsOnMainThread
(
)
;
if
(
IsDying
(
)
)
{
return
0
;
}
uint32_t
handle
=
mIdleRequestCallbackCounter
+
+
;
RefPtr
<
IdleRequest
>
request
=
new
IdleRequest
(
&
aCallback
handle
)
;
if
(
aOptions
.
mTimeout
.
WasPassed
(
)
)
{
int32_t
timeoutHandle
;
RefPtr
<
TimeoutHandler
>
handler
(
new
IdleRequestTimeoutHandler
(
aCx
request
this
)
)
;
nsresult
rv
=
mTimeoutManager
-
>
SetTimeout
(
handler
aOptions
.
mTimeout
.
Value
(
)
false
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
&
timeoutHandle
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
0
;
}
request
-
>
SetTimeoutHandle
(
timeoutHandle
)
;
}
mIdleRequestCallbacks
.
insertBack
(
request
)
;
if
(
!
IsSuspended
(
)
)
{
ScheduleIdleRequestDispatch
(
)
;
}
return
handle
;
}
void
nsGlobalWindowInner
:
:
CancelIdleCallback
(
uint32_t
aHandle
)
{
for
(
IdleRequest
*
r
:
mIdleRequestCallbacks
)
{
if
(
r
-
>
Handle
(
)
=
=
aHandle
)
{
RemoveIdleCallback
(
r
)
;
break
;
}
}
}
void
nsGlobalWindowInner
:
:
DisableIdleCallbackRequests
(
)
{
if
(
mIdleRequestExecutor
)
{
mIdleRequestExecutor
-
>
Cancel
(
)
;
mIdleRequestExecutor
=
nullptr
;
}
while
(
!
mIdleRequestCallbacks
.
isEmpty
(
)
)
{
RefPtr
<
IdleRequest
>
request
=
mIdleRequestCallbacks
.
getFirst
(
)
;
RemoveIdleCallback
(
request
)
;
}
}
bool
nsGlobalWindowInner
:
:
IsBackgroundInternal
(
)
const
{
return
!
mOuterWindow
|
|
mOuterWindow
-
>
IsBackground
(
)
;
}
class
PromiseDocumentFlushedResolver
final
{
public
:
PromiseDocumentFlushedResolver
(
Promise
*
aPromise
PromiseDocumentFlushedCallback
&
aCallback
)
:
mPromise
(
aPromise
)
mCallback
(
&
aCallback
)
{
}
virtual
~
PromiseDocumentFlushedResolver
(
)
=
default
;
void
Call
(
)
{
nsMutationGuard
guard
;
ErrorResult
error
;
JS
:
:
Rooted
<
JS
:
:
Value
>
returnVal
(
RootingCx
(
)
)
;
mCallback
-
>
Call
(
&
returnVal
error
)
;
if
(
error
.
Failed
(
)
)
{
mPromise
-
>
MaybeReject
(
error
)
;
}
else
if
(
guard
.
Mutated
(
0
)
)
{
mPromise
-
>
MaybeReject
(
NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR
)
;
}
else
{
mPromise
-
>
MaybeResolve
(
returnVal
)
;
}
}
void
Cancel
(
)
{
mPromise
-
>
MaybeReject
(
NS_ERROR_ABORT
)
;
}
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
PromiseDocumentFlushedCallback
>
mCallback
;
}
;
nsGlobalWindowInner
:
:
nsGlobalWindowInner
(
nsGlobalWindowOuter
*
aOuterWindow
WindowGlobalChild
*
aActor
)
:
nsPIDOMWindowInner
(
aOuterWindow
aActor
)
mWasOffline
(
false
)
mHasHadSlowScript
(
false
)
mIsChrome
(
false
)
mCleanMessageManager
(
false
)
mNeedsFocus
(
true
)
mHasFocus
(
false
)
mShowFocusRingForContent
(
false
)
mFocusByKeyOccurred
(
false
)
mDidFireDocElemInserted
(
false
)
mHasGamepad
(
false
)
mHasVREvents
(
false
)
mHasVRDisplayActivateEvents
(
false
)
mHasSeenGamepadInput
(
false
)
mSuspendDepth
(
0
)
mFreezeDepth
(
0
)
#
ifdef
DEBUG
mSerial
(
0
)
#
endif
mFocusMethod
(
0
)
mIdleRequestCallbackCounter
(
1
)
mIdleRequestExecutor
(
nullptr
)
mDialogAbuseCount
(
0
)
mAreDialogsEnabled
(
true
)
mObservingDidRefresh
(
false
)
mIteratingDocumentFlushedResolvers
(
false
)
mCanSkipCCGeneration
(
0
)
mBeforeUnloadListenerCount
(
0
)
{
mIsInnerWindow
=
true
;
AssertIsOnMainThread
(
)
;
nsLayoutStatics
:
:
AddRef
(
)
;
PR_INIT_CLIST
(
this
)
;
PR_INSERT_AFTER
(
this
aOuterWindow
)
;
mTimeoutManager
=
MakeUnique
<
dom
:
:
TimeoutManager
>
(
*
this
StaticPrefs
:
:
dom_timeout_max_idle_defer_ms
(
)
)
;
mObserver
=
new
nsGlobalWindowObserver
(
this
)
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
mObserver
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
false
)
;
os
-
>
AddObserver
(
mObserver
MEMORY_PRESSURE_OBSERVER_TOPIC
false
)
;
}
Preferences
:
:
AddStrongObserver
(
mObserver
"
intl
.
accept_languages
"
)
;
RefPtr
<
StorageNotifierService
>
sns
=
StorageNotifierService
:
:
GetOrCreate
(
)
;
if
(
sns
)
{
sns
-
>
Register
(
mObserver
)
;
}
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
mBrowserChild
=
docShell
-
>
GetBrowserChild
(
)
;
}
}
if
(
gDumpFile
=
=
nullptr
)
{
nsAutoCString
fname
;
Preferences
:
:
GetCString
(
"
browser
.
dom
.
window
.
dump
.
file
"
fname
)
;
if
(
!
fname
.
IsEmpty
(
)
)
{
gDumpFile
=
fopen
(
fname
.
get
(
)
"
wb
+
"
)
;
}
else
{
gDumpFile
=
stdout
;
}
}
#
ifdef
DEBUG
mSerial
=
nsContentUtils
:
:
InnerOrOuterWindowCreated
(
)
;
if
(
!
PR_GetEnv
(
"
MOZ_QUIET
"
)
)
{
printf_stderr
(
"
+
+
DOMWINDOW
=
=
%
d
(
%
p
)
[
pid
=
%
d
]
[
serial
=
%
d
]
[
outer
=
%
p
]
\
n
"
nsContentUtils
:
:
GetCurrentInnerOrOuterWindowCount
(
)
static_cast
<
void
*
>
(
ToCanonicalSupports
(
this
)
)
getpid
(
)
mSerial
static_cast
<
void
*
>
(
ToCanonicalSupports
(
aOuterWindow
)
)
)
;
}
#
endif
MOZ_LOG
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
created
outer
=
%
p
"
this
aOuterWindow
)
)
;
MOZ_ASSERT
(
sInnerWindowsById
"
Inner
Windows
hash
table
must
be
created
!
"
)
;
MOZ_ASSERT
(
!
sInnerWindowsById
-
>
Get
(
mWindowID
)
"
This
window
shouldn
'
t
be
in
the
hash
table
yet
!
"
)
;
if
(
sInnerWindowsById
)
{
sInnerWindowsById
-
>
Put
(
mWindowID
this
)
;
}
}
#
ifdef
DEBUG
void
nsGlobalWindowInner
:
:
AssertIsOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
#
endif
void
nsGlobalWindowInner
:
:
Init
(
)
{
AssertIsOnMainThread
(
)
;
NS_ASSERTION
(
gDOMLeakPRLogInner
"
gDOMLeakPRLogInner
should
have
been
initialized
!
"
)
;
sInnerWindowsById
=
new
InnerWindowByIdTable
(
)
;
}
nsGlobalWindowInner
:
:
~
nsGlobalWindowInner
(
)
{
AssertIsOnMainThread
(
)
;
if
(
IsChromeWindow
(
)
)
{
MOZ_ASSERT
(
mCleanMessageManager
"
chrome
windows
may
always
disconnect
the
msg
manager
"
)
;
DisconnectAndClearGroupMessageManagers
(
)
;
if
(
mChromeFields
.
mMessageManager
)
{
static_cast
<
nsFrameMessageManager
*
>
(
mChromeFields
.
mMessageManager
.
get
(
)
)
-
>
Disconnect
(
)
;
}
mCleanMessageManager
=
false
;
}
FreeInnerObjects
(
)
;
if
(
sInnerWindowsById
)
{
MOZ_ASSERT
(
sInnerWindowsById
-
>
Get
(
mWindowID
)
"
This
window
should
be
in
the
hash
table
"
)
;
sInnerWindowsById
-
>
Remove
(
mWindowID
)
;
}
nsContentUtils
:
:
InnerOrOuterWindowDestroyed
(
)
;
#
ifdef
DEBUG
if
(
!
PR_GetEnv
(
"
MOZ_QUIET
"
)
)
{
nsAutoCString
url
;
if
(
mLastOpenedURI
)
{
url
=
mLastOpenedURI
-
>
GetSpecOrDefault
(
)
;
const
uint32_t
maxURLLength
=
1000
;
if
(
url
.
Length
(
)
>
maxURLLength
)
{
url
.
Truncate
(
maxURLLength
)
;
}
}
nsGlobalWindowOuter
*
outer
=
nsGlobalWindowOuter
:
:
Cast
(
mOuterWindow
)
;
printf_stderr
(
"
-
-
DOMWINDOW
=
=
%
d
(
%
p
)
[
pid
=
%
d
]
[
serial
=
%
d
]
[
outer
=
%
p
]
[
url
=
"
"
%
s
]
\
n
"
nsContentUtils
:
:
GetCurrentInnerOrOuterWindowCount
(
)
static_cast
<
void
*
>
(
ToCanonicalSupports
(
this
)
)
getpid
(
)
mSerial
static_cast
<
void
*
>
(
ToCanonicalSupports
(
outer
)
)
url
.
get
(
)
)
;
}
#
endif
MOZ_LOG
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
destroyed
"
this
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INNERWINDOWS_WITH_MUTATION_LISTENERS
mMutationBits
?
1
:
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INNERWINDOWS_WITH_TEXT_EVENT_LISTENERS
mMayHaveTextEventListenerInDefaultGroup
?
1
:
0
)
;
PR_REMOVE_LINK
(
this
)
;
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
outer
)
{
outer
-
>
MaybeClearInnerWindow
(
this
)
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
ac
-
>
RemoveWindowAsListener
(
this
)
;
mDeprioritizedLoadRunner
.
clear
(
)
;
nsLayoutStatics
:
:
Release
(
)
;
}
void
nsGlobalWindowInner
:
:
ShutDown
(
)
{
AssertIsOnMainThread
(
)
;
if
(
gDumpFile
&
&
gDumpFile
!
=
stdout
)
{
fclose
(
gDumpFile
)
;
}
gDumpFile
=
nullptr
;
delete
sInnerWindowsById
;
sInnerWindowsById
=
nullptr
;
}
void
nsGlobalWindowInner
:
:
FreeInnerObjects
(
)
{
if
(
IsDying
(
)
)
{
return
;
}
StartDying
(
)
;
NotifyDOMWindowDestroyed
(
this
)
;
if
(
auto
*
reporter
=
nsWindowMemoryReporter
:
:
Get
(
)
)
{
reporter
-
>
ObserveDOMWindowDetached
(
this
)
;
}
CancelWorkersForWindow
(
this
)
;
nsTObserverArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SharedWorker
>
>
:
:
ForwardIterator
iter
(
mSharedWorkers
)
;
while
(
iter
.
HasMore
(
)
)
{
iter
.
GetNext
(
)
-
>
Close
(
)
;
}
if
(
mTimeoutManager
)
{
mTimeoutManager
-
>
ClearAllTimeouts
(
)
;
}
DisableIdleCallbackRequests
(
)
;
mChromeEventHandler
=
nullptr
;
if
(
mListenerManager
)
{
mListenerManager
-
>
Disconnect
(
)
;
mListenerManager
=
nullptr
;
}
mHistory
=
nullptr
;
if
(
mNavigator
)
{
mNavigator
-
>
OnNavigation
(
)
;
mNavigator
-
>
Invalidate
(
)
;
mNavigator
=
nullptr
;
}
mScreen
=
nullptr
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
mOrientationChangeObserver
=
nullptr
;
#
endif
if
(
mDoc
)
{
mDocumentPrincipal
=
mDoc
-
>
NodePrincipal
(
)
;
mDocumentStoragePrincipal
=
mDoc
-
>
EffectiveStoragePrincipal
(
)
;
mDocumentURI
=
mDoc
-
>
GetDocumentURI
(
)
;
mDocBaseURI
=
mDoc
-
>
GetDocBaseURI
(
)
;
mDocumentCsp
=
mDoc
-
>
GetCsp
(
)
;
while
(
mDoc
-
>
EventHandlingSuppressed
(
)
)
{
mDoc
-
>
UnsuppressEventHandlingAndFireEvents
(
false
)
;
}
if
(
mObservingDidRefresh
)
{
PresShell
*
presShell
=
mDoc
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
Unused
<
<
presShell
-
>
RemovePostRefreshObserver
(
this
)
;
}
}
}
mFocusedElement
=
nullptr
;
if
(
mApplicationCache
)
{
static_cast
<
nsDOMOfflineResourceList
*
>
(
mApplicationCache
.
get
(
)
)
-
>
Disconnect
(
)
;
mApplicationCache
=
nullptr
;
}
if
(
mIndexedDB
)
{
mIndexedDB
-
>
DisconnectFromGlobal
(
this
)
;
mIndexedDB
=
nullptr
;
}
UnlinkHostObjectURIs
(
)
;
NotifyWindowIDDestroyed
(
"
inner
-
window
-
destroyed
"
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
mAudioContexts
[
i
]
-
>
Shutdown
(
)
;
}
mAudioContexts
.
Clear
(
)
;
DisableGamepadUpdates
(
)
;
mHasGamepad
=
false
;
mGamepads
.
Clear
(
)
;
DisableVRUpdates
(
)
;
mHasVREvents
=
false
;
mHasVRDisplayActivateEvents
=
false
;
mVRDisplays
.
Clear
(
)
;
mClientSource
.
reset
(
)
;
if
(
mWindowGlobalChild
)
{
int64_t
nListeners
=
mWindowGlobalChild
-
>
BeforeUnloadListeners
(
)
;
for
(
int64_t
i
=
0
;
i
<
nListeners
;
+
+
i
)
{
mWindowGlobalChild
-
>
BeforeUnloadRemoved
(
)
;
}
MOZ_ASSERT
(
mWindowGlobalChild
-
>
BeforeUnloadListeners
(
)
=
=
0
)
;
}
CallDocumentFlushedResolvers
(
)
;
mObservingDidRefresh
=
false
;
DisconnectEventTargetObjects
(
)
;
if
(
mObserver
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
mObserver
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
)
;
os
-
>
RemoveObserver
(
mObserver
MEMORY_PRESSURE_OBSERVER_TOPIC
)
;
}
RefPtr
<
StorageNotifierService
>
sns
=
StorageNotifierService
:
:
GetOrCreate
(
)
;
if
(
sns
)
{
sns
-
>
Unregister
(
mObserver
)
;
}
Preferences
:
:
RemoveObserver
(
mObserver
"
intl
.
accept_languages
"
)
;
mObserver
-
>
Forget
(
)
;
}
mMenubar
=
nullptr
;
mToolbar
=
nullptr
;
mLocationbar
=
nullptr
;
mPersonalbar
=
nullptr
;
mStatusbar
=
nullptr
;
mScrollbars
=
nullptr
;
mConsole
=
nullptr
;
mPaintWorklet
=
nullptr
;
mExternal
=
nullptr
;
mInstallTrigger
=
nullptr
;
mLocalStorage
=
nullptr
;
mSessionStorage
=
nullptr
;
mPerformance
=
nullptr
;
mSharedWorkers
.
Clear
(
)
;
#
ifdef
MOZ_WEBSPEECH
mSpeechSynthesis
=
nullptr
;
#
endif
mParentTarget
=
nullptr
;
if
(
mCleanMessageManager
)
{
MOZ_ASSERT
(
mIsChrome
"
only
chrome
should
have
msg
manager
cleaned
"
)
;
if
(
mChromeFields
.
mMessageManager
)
{
mChromeFields
.
mMessageManager
-
>
Disconnect
(
)
;
}
}
if
(
mWindowGlobalChild
&
&
!
mWindowGlobalChild
-
>
IsClosed
(
)
)
{
mWindowGlobalChild
-
>
Destroy
(
)
;
}
mWindowGlobalChild
=
nullptr
;
mIntlUtils
=
nullptr
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsGlobalWindowInner
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
EventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMWindow
)
NS_INTERFACE_MAP_ENTRY
(
nsIGlobalObject
)
NS_INTERFACE_MAP_ENTRY
(
nsIScriptGlobalObject
)
NS_INTERFACE_MAP_ENTRY
(
nsIScriptObjectPrincipal
)
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
dom
:
:
EventTarget
)
NS_INTERFACE_MAP_ENTRY
(
nsPIDOMWindowInner
)
NS_INTERFACE_MAP_ENTRY
(
mozIDOMWindow
)
NS_INTERFACE_MAP_ENTRY_CONDITIONAL
(
nsIDOMChromeWindow
IsChromeWindow
(
)
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsGlobalWindowInner
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsGlobalWindowInner
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsGlobalWindowInner
)
if
(
tmp
-
>
IsBlackForCC
(
false
)
)
{
if
(
nsCCUncollectableMarker
:
:
InGeneration
(
tmp
-
>
mCanSkipCCGeneration
)
)
{
return
true
;
}
tmp
-
>
mCanSkipCCGeneration
=
nsCCUncollectableMarker
:
:
sGeneration
;
if
(
EventListenerManager
*
elm
=
tmp
-
>
GetExistingListenerManager
(
)
)
{
elm
-
>
MarkForCC
(
)
;
}
if
(
tmp
-
>
mTimeoutManager
)
{
tmp
-
>
mTimeoutManager
-
>
UnmarkGrayTimers
(
)
;
}
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsGlobalWindowInner
)
return
tmp
-
>
IsBlackForCC
(
true
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsGlobalWindowInner
)
return
tmp
-
>
IsBlackForCC
(
false
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsGlobalWindowInner
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL
(
nsGlobalWindowInner
)
if
(
MOZ_UNLIKELY
(
cb
.
WantDebugInfo
(
)
)
)
{
char
name
[
512
]
;
nsAutoCString
uri
;
if
(
tmp
-
>
mDoc
&
&
tmp
-
>
mDoc
-
>
GetDocumentURI
(
)
)
{
uri
=
tmp
-
>
mDoc
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
}
SprintfLiteral
(
name
"
nsGlobalWindowInner
#
%
"
PRIu64
"
inner
%
s
"
tmp
-
>
mWindowID
uri
.
get
(
)
)
;
cb
.
DescribeRefCountedNode
(
tmp
-
>
mRefCnt
.
get
(
)
name
)
;
}
else
{
NS_IMPL_CYCLE_COLLECTION_DESCRIBE
(
nsGlobalWindowInner
tmp
-
>
mRefCnt
.
get
(
)
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNavigator
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPerformance
)
#
ifdef
MOZ_WEBSPEECH
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSpeechSynthesis
)
#
endif
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOuterWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTopInnerWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mListenerManager
)
if
(
tmp
-
>
mTimeoutManager
)
{
tmp
-
>
mTimeoutManager
-
>
ForEachUnorderedTimeout
(
[
&
cb
]
(
Timeout
*
timeout
)
{
cb
.
NoteNativeChild
(
timeout
NS_CYCLE_COLLECTION_PARTICIPANT
(
Timeout
)
)
;
}
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocation
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mHistory
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCustomElements
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSharedWorkers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocalStorage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSessionStorage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mApplicationCache
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIndexedDB
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentPrincipal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentStoragePrincipal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentCsp
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mBrowserChild
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDoc
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIdleRequestExecutor
)
for
(
IdleRequest
*
request
:
tmp
-
>
mIdleRequestCallbacks
)
{
cb
.
NoteNativeChild
(
request
NS_CYCLE_COLLECTION_PARTICIPANT
(
IdleRequest
)
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mClientSource
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mGamepads
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCacheStorage
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mVRDisplays
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDebuggerNotificationManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeEventHandler
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParentTarget
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFocusedElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMenubar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mToolbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLocationbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPersonalbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStatusbar
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScrollbars
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCrypto
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mU2F
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mConsole
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPaintWorklet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mExternal
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mInstallTrigger
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mIntlUtils
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReportRecords
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReportingObservers
)
tmp
-
>
TraverseHostObjectURIs
(
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeFields
.
mMessageManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChromeFields
.
mGroupMessageManagers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPendingPromises
)
for
(
size_t
i
=
0
;
i
<
tmp
-
>
mDocumentFlushedResolvers
.
Length
(
)
;
i
+
+
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentFlushedResolvers
[
i
]
-
>
mPromise
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentFlushedResolvers
[
i
]
-
>
mCallback
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsGlobalWindowInner
)
JSObject
*
wrapper
=
tmp
-
>
GetWrapperPreserveColor
(
)
;
if
(
wrapper
)
{
JS
:
:
RealmBehaviorsRef
(
js
:
:
GetNonCCWObjectRealm
(
wrapper
)
)
.
setNonLive
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mNavigator
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPerformance
)
#
ifdef
MOZ_WEBSPEECH
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSpeechSynthesis
)
#
endif
if
(
tmp
-
>
mOuterWindow
)
{
nsGlobalWindowOuter
:
:
Cast
(
tmp
-
>
mOuterWindow
)
-
>
MaybeClearInnerWindow
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOuterWindow
)
}
if
(
tmp
-
>
mListenerManager
)
{
tmp
-
>
mListenerManager
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mListenerManager
)
}
tmp
-
>
UpdateTopInnerWindow
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTopInnerWindow
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocation
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mHistory
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCustomElements
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSharedWorkers
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocalStorage
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSessionStorage
)
if
(
tmp
-
>
mApplicationCache
)
{
static_cast
<
nsDOMOfflineResourceList
*
>
(
tmp
-
>
mApplicationCache
.
get
(
)
)
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mApplicationCache
)
}
if
(
tmp
-
>
mIndexedDB
)
{
tmp
-
>
mIndexedDB
-
>
DisconnectFromGlobal
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIndexedDB
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentPrincipal
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentStoragePrincipal
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentCsp
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mBrowserChild
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDoc
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mGamepads
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCacheStorage
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mVRDisplays
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDebuggerNotificationManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeEventHandler
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParentTarget
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFocusedElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMenubar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mToolbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLocationbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPersonalbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStatusbar
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mScrollbars
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCrypto
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mU2F
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mConsole
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPaintWorklet
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mExternal
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mInstallTrigger
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIntlUtils
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReportRecords
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReportingObservers
)
tmp
-
>
UnlinkHostObjectURIs
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIdleRequestExecutor
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mClientSource
)
if
(
tmp
-
>
IsChromeWindow
(
)
)
{
if
(
tmp
-
>
mChromeFields
.
mMessageManager
)
{
static_cast
<
nsFrameMessageManager
*
>
(
tmp
-
>
mChromeFields
.
mMessageManager
.
get
(
)
)
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeFields
.
mMessageManager
)
}
tmp
-
>
DisconnectAndClearGroupMessageManagers
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChromeFields
.
mGroupMessageManagers
)
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPendingPromises
)
for
(
size_t
i
=
0
;
i
<
tmp
-
>
mDocumentFlushedResolvers
.
Length
(
)
;
i
+
+
)
{
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentFlushedResolvers
[
i
]
-
>
mPromise
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentFlushedResolvers
[
i
]
-
>
mCallback
)
;
}
tmp
-
>
mDocumentFlushedResolvers
.
Clear
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
#
ifdef
DEBUG
void
nsGlobalWindowInner
:
:
RiskyUnlink
(
)
{
NS_CYCLE_COLLECTION_INNERNAME
.
Unlink
(
this
)
;
}
#
endif
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsGlobalWindowInner
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
bool
nsGlobalWindowInner
:
:
IsBlackForCC
(
bool
aTracingNeeded
)
{
if
(
!
nsCCUncollectableMarker
:
:
sGeneration
)
{
return
false
;
}
return
(
nsCCUncollectableMarker
:
:
InGeneration
(
GetMarkedCCGeneration
(
)
)
|
|
HasKnownLiveWrapper
(
)
)
&
&
(
!
aTracingNeeded
|
|
HasNothingToTrace
(
ToSupports
(
this
)
)
)
;
}
nsresult
nsGlobalWindowInner
:
:
EnsureScriptEnvironment
(
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
NS_WARNING
(
"
No
outer
window
available
!
"
)
;
return
NS_ERROR_FAILURE
;
}
return
outer
-
>
EnsureScriptEnvironment
(
)
;
}
nsIScriptContext
*
nsGlobalWindowInner
:
:
GetScriptContext
(
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
return
nullptr
;
}
return
outer
-
>
GetScriptContext
(
)
;
}
void
nsGlobalWindowInner
:
:
TraceGlobalJSObject
(
JSTracer
*
aTrc
)
{
TraceWrapper
(
aTrc
"
active
window
global
"
)
;
}
void
nsGlobalWindowInner
:
:
InnerSetNewDocument
(
JSContext
*
aCx
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
MOZ_LOG_TEST
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
)
)
{
nsIURI
*
uri
=
aDocument
-
>
GetDocumentURI
(
)
;
MOZ_LOG
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
(
"
DOMWINDOW
%
p
SetNewDocument
%
s
"
this
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
}
mDoc
=
aDocument
;
mFocusedElement
=
nullptr
;
mLocalStorage
=
nullptr
;
mSessionStorage
=
nullptr
;
mPerformance
=
nullptr
;
ClearDocumentDependentSlots
(
aCx
)
;
if
(
!
mWindowGlobalChild
&
&
(
XRE_IsParentProcess
(
)
|
|
mBrowserChild
)
)
{
mWindowGlobalChild
=
WindowGlobalChild
:
:
Create
(
this
)
;
}
if
(
mWindowGlobalChild
&
&
GetBrowsingContext
(
)
)
{
GetBrowsingContext
(
)
-
>
NotifyResetUserGestureActivation
(
)
;
}
#
ifdef
DEBUG
mLastOpenedURI
=
aDocument
-
>
GetDocumentURI
(
)
;
#
endif
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INNERWINDOWS_WITH_MUTATION_LISTENERS
mMutationBits
?
1
:
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INNERWINDOWS_WITH_TEXT_EVENT_LISTENERS
mMayHaveTextEventListenerInDefaultGroup
?
1
:
0
)
;
mMutationBits
=
0
;
mMayHaveTextEventListenerInDefaultGroup
=
false
;
}
nsresult
nsGlobalWindowInner
:
:
EnsureClientSource
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mDoc
)
;
bool
newClientSource
=
false
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
;
nsCOMPtr
<
nsIChannel
>
channel
=
mDoc
-
>
GetChannel
(
)
;
if
(
channel
)
{
nsCOMPtr
<
nsIURI
>
uri
;
Unused
<
<
channel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
bool
ignoreLoadInfo
=
false
;
if
(
uri
-
>
SchemeIs
(
"
about
"
)
)
{
nsCString
spec
=
uri
-
>
GetSpecOrDefault
(
)
;
ignoreLoadInfo
=
spec
.
EqualsLiteral
(
"
about
:
blank
"
)
|
|
spec
.
EqualsLiteral
(
"
about
:
srcdoc
"
)
;
}
else
{
ignoreLoadInfo
=
uri
-
>
SchemeIs
(
"
data
"
)
|
|
uri
-
>
SchemeIs
(
"
blob
"
)
;
}
if
(
!
ignoreLoadInfo
)
{
loadInfo
=
channel
-
>
LoadInfo
(
)
;
}
}
UniquePtr
<
ClientSource
>
initialClientSource
;
nsIDocShell
*
docshell
=
GetDocShell
(
)
;
if
(
docshell
)
{
initialClientSource
=
docshell
-
>
TakeInitialClientSource
(
)
;
}
if
(
loadInfo
)
{
UniquePtr
<
ClientSource
>
reservedClient
=
loadInfo
-
>
TakeReservedClientSource
(
)
;
if
(
reservedClient
)
{
mClientSource
.
reset
(
)
;
mClientSource
=
std
:
:
move
(
reservedClient
)
;
newClientSource
=
true
;
}
}
if
(
!
mClientSource
)
{
mClientSource
=
std
:
:
move
(
initialClientSource
)
;
if
(
mClientSource
)
{
newClientSource
=
true
;
}
}
if
(
mClientSource
)
{
nsCOMPtr
<
nsIPrincipal
>
clientPrincipal
(
mClientSource
-
>
Info
(
)
.
GetPrincipal
(
)
)
;
if
(
!
clientPrincipal
|
|
!
clientPrincipal
-
>
Equals
(
mDoc
-
>
NodePrincipal
(
)
)
)
{
mClientSource
.
reset
(
)
;
}
}
if
(
!
mClientSource
)
{
mClientSource
=
ClientManager
:
:
CreateSource
(
ClientType
:
:
Window
EventTargetFor
(
TaskCategory
:
:
Other
)
mDoc
-
>
NodePrincipal
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mClientSource
)
;
newClientSource
=
true
;
}
else
if
(
loadInfo
)
{
const
Maybe
<
ServiceWorkerDescriptor
>
controller
=
loadInfo
-
>
GetController
(
)
;
if
(
controller
.
isSome
(
)
)
{
mClientSource
-
>
SetController
(
controller
.
ref
(
)
)
;
}
else
if
(
mClientSource
-
>
GetController
(
)
.
isSome
(
)
)
{
mClientSource
.
reset
(
)
;
mClientSource
=
ClientManager
:
:
CreateSource
(
ClientType
:
:
Window
EventTargetFor
(
TaskCategory
:
:
Other
)
mDoc
-
>
NodePrincipal
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mClientSource
)
;
newClientSource
=
true
;
}
}
if
(
mClientSource
)
{
mClientSource
-
>
SetCsp
(
mDoc
-
>
GetCsp
(
)
)
;
DocGroup
*
docGroup
=
GetDocGroup
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
docGroup
)
;
mClientSource
-
>
SetAgentClusterId
(
docGroup
-
>
AgentClusterId
(
)
)
;
}
if
(
newClientSource
&
&
IsFrozen
(
)
)
{
mClientSource
-
>
Freeze
(
)
;
}
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
ExecutionReady
(
)
{
nsresult
rv
=
EnsureClientSource
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mClientSource
-
>
WindowExecutionReady
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
void
nsGlobalWindowInner
:
:
UpdateParentTarget
(
)
{
nsCOMPtr
<
Element
>
frameElement
=
GetOuterWindow
(
)
-
>
GetFrameElementInternal
(
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
nsContentUtils
:
:
TryGetBrowserChildGlobal
(
frameElement
)
;
if
(
!
eventTarget
)
{
nsGlobalWindowOuter
*
topWin
=
GetInProcessScriptableTopInternal
(
)
;
if
(
topWin
)
{
frameElement
=
topWin
-
>
GetFrameElementInternal
(
)
;
eventTarget
=
nsContentUtils
:
:
TryGetBrowserChildGlobal
(
frameElement
)
;
}
}
if
(
!
eventTarget
)
{
eventTarget
=
nsContentUtils
:
:
TryGetBrowserChildGlobal
(
mChromeEventHandler
)
;
}
if
(
!
eventTarget
)
{
eventTarget
=
mChromeEventHandler
;
}
mParentTarget
=
eventTarget
;
}
EventTarget
*
nsGlobalWindowInner
:
:
GetTargetForDOMEvent
(
)
{
return
GetOuterWindowInternal
(
)
;
}
void
nsGlobalWindowInner
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
EventMessage
msg
=
aVisitor
.
mEvent
-
>
mMessage
;
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
mForceContentDispatch
=
true
;
if
(
msg
=
=
eResize
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
if
(
window
)
{
mIsHandlingResizeEvent
=
true
;
}
}
else
if
(
msg
=
=
eMouseDown
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
sMouseDown
=
true
;
}
else
if
(
(
msg
=
=
eMouseUp
|
|
msg
=
=
eDragEnd
)
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
sMouseDown
=
false
;
if
(
sDragServiceDisabled
)
{
nsCOMPtr
<
nsIDragService
>
ds
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
ds
)
{
sDragServiceDisabled
=
false
;
ds
-
>
Unsuppress
(
)
;
}
}
}
aVisitor
.
SetParentTarget
(
GetParentTarget
(
)
true
)
;
}
bool
nsGlobalWindowInner
:
:
DialogsAreBeingAbused
(
)
{
NS_ASSERTION
(
GetInProcessScriptableTopInternal
(
)
&
&
GetInProcessScriptableTopInternal
(
)
-
>
GetCurrentInnerWindowInternal
(
)
=
=
this
"
DialogsAreBeingAbused
called
with
invalid
window
"
)
;
if
(
mLastDialogQuitTime
.
IsNull
(
)
|
|
nsContentUtils
:
:
IsCallerChrome
(
)
)
{
return
false
;
}
TimeDuration
dialogInterval
(
TimeStamp
:
:
Now
(
)
-
mLastDialogQuitTime
)
;
if
(
dialogInterval
.
ToSeconds
(
)
<
Preferences
:
:
GetInt
(
"
dom
.
successive_dialog_time_limit
"
DEFAULT_SUCCESSIVE_DIALOG_TIME_LIMIT
)
)
{
mDialogAbuseCount
+
+
;
return
PopupBlocker
:
:
GetPopupControlState
(
)
>
PopupBlocker
:
:
openAllowed
|
|
mDialogAbuseCount
>
MAX_SUCCESSIVE_DIALOG_COUNT
;
}
mDialogAbuseCount
=
0
;
return
false
;
}
void
nsGlobalWindowInner
:
:
FireFrameLoadEvent
(
bool
aIsTrusted
)
{
if
(
GetBrowsingContext
(
)
-
>
IsTopContent
(
)
|
|
GetBrowsingContext
(
)
-
>
IsChrome
(
)
)
{
return
;
}
RefPtr
<
Element
>
element
=
GetBrowsingContext
(
)
-
>
GetEmbedderElement
(
)
;
if
(
element
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
aIsTrusted
eLoad
)
;
event
.
mFlags
.
mBubbles
=
false
;
event
.
mFlags
.
mCancelable
=
false
;
if
(
mozilla
:
:
dom
:
:
DocGroup
:
:
TryToLoadIframesInBackground
(
)
)
{
nsDocShell
*
ds
=
nsDocShell
:
:
Cast
(
GetDocShell
(
)
)
;
if
(
ds
&
&
!
ds
-
>
HasFakeOnLoadDispatched
(
)
)
{
EventDispatcher
:
:
Dispatch
(
element
nullptr
&
event
nullptr
&
status
)
;
}
}
else
{
EventDispatcher
:
:
Dispatch
(
element
nullptr
&
event
nullptr
&
status
)
;
}
return
;
}
RefPtr
<
BrowserChild
>
browserChild
=
BrowserChild
:
:
GetFrom
(
static_cast
<
nsPIDOMWindowInner
*
>
(
this
)
)
;
if
(
browserChild
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootOuter
=
do_GetInterface
(
browserChild
-
>
WebNavigation
(
)
)
;
if
(
!
rootOuter
|
|
rootOuter
!
=
GetOuterWindow
(
)
)
{
return
;
}
mozilla
:
:
Unused
<
<
browserChild
-
>
SendMaybeFireEmbedderLoadEvents
(
aIsTrusted
true
)
;
}
}
nsresult
nsGlobalWindowInner
:
:
PostHandleEvent
(
EventChainPostVisitor
&
aVisitor
)
{
switch
(
aVisitor
.
mEvent
-
>
mMessage
)
{
case
eResize
:
case
eUnload
:
case
eLoad
:
break
;
default
:
return
NS_OK
;
}
RefPtr
<
EventTarget
>
kungFuDeathGrip1
(
mChromeEventHandler
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip1
;
nsCOMPtr
<
nsIScriptContext
>
kungFuDeathGrip2
(
GetContextInternal
(
)
)
;
mozilla
:
:
Unused
<
<
kungFuDeathGrip2
;
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eResize
)
{
mIsHandlingResizeEvent
=
false
;
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eUnload
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
IsPresenting
(
)
)
{
display
-
>
StartVRNavigation
(
)
;
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
outer
)
{
outer
-
>
SetAutoActivateVRDisplayID
(
display
-
>
DisplayId
(
)
)
;
}
break
;
}
}
mIsDocumentLoaded
=
false
;
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eLoad
&
&
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
{
mIsDocumentLoaded
=
true
;
mTimeoutManager
-
>
OnDocumentLoaded
(
)
;
FireFrameLoadEvent
(
aVisitor
.
mEvent
-
>
IsTrusted
(
)
)
;
if
(
mVREventObserver
)
{
mVREventObserver
-
>
NotifyAfterLoad
(
)
;
}
uint32_t
autoActivateVRDisplayID
=
0
;
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
outer
)
{
autoActivateVRDisplayID
=
outer
-
>
GetAutoActivateVRDisplayID
(
)
;
}
if
(
autoActivateVRDisplayID
)
{
DispatchVRDisplayActivate
(
autoActivateVRDisplayID
VRDisplayEventReason
:
:
Navigation
)
;
}
}
return
NS_OK
;
}
nsresult
nsGlobalWindowInner
:
:
DefineArgumentsProperty
(
nsIArray
*
aArguments
)
{
nsIScriptContext
*
ctx
=
GetOuterWindowInternal
(
)
-
>
mContext
;
NS_ENSURE_TRUE
(
aArguments
&
&
ctx
NS_ERROR_NOT_INITIALIZED
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
RootingCx
(
)
GetWrapperPreserveColor
(
)
)
;
return
ctx
-
>
SetProperty
(
obj
"
arguments
"
aArguments
)
;
}
nsIPrincipal
*
nsGlobalWindowInner
:
:
GetPrincipal
(
)
{
if
(
mDoc
)
{
return
mDoc
-
>
NodePrincipal
(
)
;
}
if
(
mDocumentPrincipal
)
{
return
mDocumentPrincipal
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
objPrincipal
=
do_QueryInterface
(
GetInProcessParentInternal
(
)
)
;
if
(
objPrincipal
)
{
return
objPrincipal
-
>
GetPrincipal
(
)
;
}
return
nullptr
;
}
nsIPrincipal
*
nsGlobalWindowInner
:
:
GetEffectiveStoragePrincipal
(
)
{
if
(
mDoc
)
{
return
mDoc
-
>
EffectiveStoragePrincipal
(
)
;
}
if
(
mDocumentStoragePrincipal
)
{
return
mDocumentStoragePrincipal
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
objPrincipal
=
do_QueryInterface
(
GetInProcessParentInternal
(
)
)
;
if
(
objPrincipal
)
{
return
objPrincipal
-
>
GetEffectiveStoragePrincipal
(
)
;
}
return
nullptr
;
}
bool
nsPIDOMWindowInner
:
:
AddAudioContext
(
AudioContext
*
aAudioContext
)
{
mAudioContexts
.
AppendElement
(
aAudioContext
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
return
docShell
&
&
!
docShell
-
>
GetAllowMedia
(
)
&
&
!
aAudioContext
-
>
IsOffline
(
)
;
}
void
nsPIDOMWindowInner
:
:
RemoveAudioContext
(
AudioContext
*
aAudioContext
)
{
mAudioContexts
.
RemoveElement
(
aAudioContext
)
;
}
void
nsPIDOMWindowInner
:
:
MuteAudioContexts
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
if
(
!
mAudioContexts
[
i
]
-
>
IsOffline
(
)
)
{
mAudioContexts
[
i
]
-
>
Mute
(
)
;
}
}
}
void
nsPIDOMWindowInner
:
:
UnmuteAudioContexts
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
if
(
!
mAudioContexts
[
i
]
-
>
IsOffline
(
)
)
{
mAudioContexts
[
i
]
-
>
Unmute
(
)
;
}
}
}
WindowProxyHolder
nsGlobalWindowInner
:
:
Window
(
)
{
return
WindowProxyHolder
(
GetBrowsingContext
(
)
)
;
}
Navigator
*
nsPIDOMWindowInner
:
:
Navigator
(
)
{
if
(
!
mNavigator
)
{
mNavigator
=
new
mozilla
:
:
dom
:
:
Navigator
(
this
)
;
}
return
mNavigator
;
}
VisualViewport
*
nsGlobalWindowInner
:
:
VisualViewport
(
)
{
if
(
!
mVisualViewport
)
{
mVisualViewport
=
new
mozilla
:
:
dom
:
:
VisualViewport
(
this
)
;
}
return
mVisualViewport
;
}
nsScreen
*
nsGlobalWindowInner
:
:
GetScreen
(
ErrorResult
&
aError
)
{
if
(
!
mScreen
)
{
mScreen
=
nsScreen
:
:
Create
(
this
)
;
if
(
!
mScreen
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
}
return
mScreen
;
}
nsHistory
*
nsGlobalWindowInner
:
:
GetHistory
(
ErrorResult
&
aError
)
{
if
(
!
mHistory
)
{
mHistory
=
new
nsHistory
(
this
)
;
}
return
mHistory
;
}
CustomElementRegistry
*
nsGlobalWindowInner
:
:
CustomElements
(
)
{
if
(
!
mCustomElements
)
{
mCustomElements
=
new
CustomElementRegistry
(
this
)
;
}
return
mCustomElements
;
}
Performance
*
nsPIDOMWindowInner
:
:
GetPerformance
(
)
{
CreatePerformanceObjectIfNeeded
(
)
;
return
mPerformance
;
}
void
nsPIDOMWindowInner
:
:
QueuePerformanceNavigationTiming
(
)
{
CreatePerformanceObjectIfNeeded
(
)
;
if
(
mPerformance
)
{
mPerformance
-
>
QueueNavigationTimingEntry
(
)
;
}
}
void
nsPIDOMWindowInner
:
:
CreatePerformanceObjectIfNeeded
(
)
{
if
(
mPerformance
|
|
!
mDoc
)
{
return
;
}
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDoc
-
>
GetNavigationTiming
(
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
mDoc
-
>
GetChannel
(
)
)
)
;
bool
timingEnabled
=
false
;
if
(
!
timedChannel
|
|
!
NS_SUCCEEDED
(
timedChannel
-
>
GetTimingEnabled
(
&
timingEnabled
)
)
|
|
!
timingEnabled
)
{
timedChannel
=
nullptr
;
}
if
(
timing
)
{
mPerformance
=
Performance
:
:
CreateForMainThread
(
this
mDoc
-
>
NodePrincipal
(
)
timing
timedChannel
)
;
}
}
bool
nsPIDOMWindowInner
:
:
IsSecureContext
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
IsSecureContext
(
)
;
}
void
nsPIDOMWindowInner
:
:
Suspend
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
Suspend
(
)
;
}
void
nsPIDOMWindowInner
:
:
Resume
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
Resume
(
)
;
}
void
nsPIDOMWindowInner
:
:
SyncStateFromParentWindow
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
SyncStateFromParentWindow
(
)
;
}
Maybe
<
ClientInfo
>
nsPIDOMWindowInner
:
:
GetClientInfo
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
GetClientInfo
(
)
;
}
Maybe
<
ClientState
>
nsPIDOMWindowInner
:
:
GetClientState
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
GetClientState
(
)
;
}
Maybe
<
ServiceWorkerDescriptor
>
nsPIDOMWindowInner
:
:
GetController
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
GetController
(
)
;
}
void
nsPIDOMWindowInner
:
:
SetCsp
(
nsIContentSecurityPolicy
*
aCsp
)
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
SetCsp
(
aCsp
)
;
}
void
nsPIDOMWindowInner
:
:
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCsp
)
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
SetPreloadCsp
(
aPreloadCsp
)
;
}
nsIContentSecurityPolicy
*
nsPIDOMWindowInner
:
:
GetCsp
(
)
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
GetCsp
(
)
;
}
void
nsPIDOMWindowInner
:
:
NoteCalledRegisterForServiceWorkerScope
(
const
nsACString
&
aScope
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
NoteCalledRegisterForServiceWorkerScope
(
aScope
)
;
}
void
nsPIDOMWindowInner
:
:
NoteDOMContentLoaded
(
)
{
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
NoteDOMContentLoaded
(
)
;
}
bool
nsGlobalWindowInner
:
:
ShouldReportForServiceWorkerScope
(
const
nsAString
&
aScope
)
{
bool
result
=
false
;
nsPIDOMWindowOuter
*
topOuter
=
GetInProcessScriptableTop
(
)
;
NS_ENSURE_TRUE
(
topOuter
false
)
;
nsGlobalWindowInner
*
topInner
=
nsGlobalWindowInner
:
:
Cast
(
topOuter
-
>
GetCurrentInnerWindow
(
)
)
;
NS_ENSURE_TRUE
(
topInner
false
)
;
topInner
-
>
ShouldReportForServiceWorkerScopeInternal
(
NS_ConvertUTF16toUTF8
(
aScope
)
&
result
)
;
return
result
;
}
InstallTriggerImpl
*
nsGlobalWindowInner
:
:
GetInstallTrigger
(
)
{
if
(
!
mInstallTrigger
)
{
ErrorResult
rv
;
mInstallTrigger
=
ConstructJSImplementation
<
InstallTriggerImpl
>
(
"
mozilla
.
org
/
addons
/
installtrigger
;
1
"
this
rv
)
;
if
(
rv
.
Failed
(
)
)
{
rv
.
SuppressException
(
)
;
return
nullptr
;
}
}
return
mInstallTrigger
;
}
nsIDOMWindowUtils
*
nsGlobalWindowInner
:
:
GetWindowUtils
(
ErrorResult
&
aRv
)
{
FORWARD_TO_OUTER_OR_THROW
(
WindowUtils
(
)
aRv
nullptr
)
;
}
bool
nsGlobalWindowInner
:
:
HasOpenerForInitialContentBrowser
(
)
{
FORWARD_TO_OUTER
(
HasOpenerForInitialContentBrowser
(
)
false
)
;
}
nsGlobalWindowInner
:
:
CallState
nsGlobalWindowInner
:
:
ShouldReportForServiceWorkerScopeInternal
(
const
nsACString
&
aScope
bool
*
aResultOut
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aResultOut
)
;
const
Maybe
<
ServiceWorkerDescriptor
>
swd
=
GetController
(
)
;
if
(
swd
.
isSome
(
)
&
&
swd
.
ref
(
)
.
Scope
(
)
=
=
aScope
)
{
*
aResultOut
=
true
;
return
CallState
:
:
Stop
;
}
if
(
mClientSource
&
&
mClientSource
-
>
CalledRegisterForServiceWorkerScope
(
aScope
)
)
{
*
aResultOut
=
true
;
return
CallState
:
:
Stop
;
}
nsCOMPtr
<
nsIDocumentLoader
>
loader
(
do_QueryInterface
(
GetDocShell
(
)
)
)
;
if
(
loader
)
{
nsCOMPtr
<
nsILoadGroup
>
loadgroup
;
Unused
<
<
loader
-
>
GetLoadGroup
(
getter_AddRefs
(
loadgroup
)
)
;
if
(
loadgroup
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
iter
;
Unused
<
<
loadgroup
-
>
GetRequests
(
getter_AddRefs
(
iter
)
)
;
if
(
iter
)
{
nsCOMPtr
<
nsISupports
>
tmp
;
bool
hasMore
=
true
;
while
(
NS_SUCCEEDED
(
iter
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
iter
-
>
GetNext
(
getter_AddRefs
(
tmp
)
)
;
nsCOMPtr
<
nsIChannel
>
loadingChannel
(
do_QueryInterface
(
tmp
)
)
;
if
(
!
loadingChannel
|
|
!
nsContentUtils
:
:
IsNonSubresourceRequest
(
loadingChannel
)
)
{
continue
;
}
nsCOMPtr
<
nsIURI
>
loadingURL
;
Unused
<
<
loadingChannel
-
>
GetURI
(
getter_AddRefs
(
loadingURL
)
)
;
if
(
!
loadingURL
)
{
continue
;
}
nsAutoCString
loadingSpec
;
Unused
<
<
loadingURL
-
>
GetSpec
(
loadingSpec
)
;
if
(
StringBeginsWith
(
loadingSpec
aScope
)
)
{
*
aResultOut
=
true
;
return
CallState
:
:
Stop
;
}
}
}
}
}
return
CallOnChildren
(
&
nsGlobalWindowInner
:
:
ShouldReportForServiceWorkerScopeInternal
aScope
aResultOut
)
;
}
void
nsGlobalWindowInner
:
:
NoteCalledRegisterForServiceWorkerScope
(
const
nsACString
&
aScope
)
{
if
(
!
mClientSource
)
{
return
;
}
mClientSource
-
>
NoteCalledRegisterForServiceWorkerScope
(
aScope
)
;
}
void
nsGlobalWindowInner
:
:
NoteDOMContentLoaded
(
)
{
if
(
!
mClientSource
)
{
return
;
}
mClientSource
-
>
NoteDOMContentLoaded
(
)
;
}
void
nsGlobalWindowInner
:
:
UpdateTopInnerWindow
(
)
{
if
(
IsTopInnerWindow
(
)
|
|
!
mTopInnerWindow
)
{
return
;
}
mTopInnerWindow
-
>
UpdateWebSocketCount
(
-
(
int32_t
)
mNumOfOpenWebSockets
)
;
}
bool
nsGlobalWindowInner
:
:
IsSharedMemoryAllowed
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
StaticPrefs
:
:
dom_postMessage_sharedArrayBuffer_bypassCOOP_COEP_insecure_enabled
(
)
)
{
return
true
;
}
return
CrossOriginIsolated
(
)
;
}
bool
nsGlobalWindowInner
:
:
CrossOriginIsolated
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
StaticPrefs
:
:
dom_postMessage_sharedArrayBuffer_withCOOP_COEP
(
)
)
{
return
false
;
}
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
bc
)
;
if
(
bc
-
>
Top
(
)
-
>
GetOpenerPolicy
(
)
!
=
nsILoadInfo
:
:
OPENER_POLICY_SAME_ORIGIN_EMBEDDER_POLICY_REQUIRE_CORP
)
{
return
false
;
}
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
if
(
!
cc
|
|
!
StringBeginsWith
(
cc
-
>
GetRemoteType
(
)
NS_LITERAL_STRING
(
WITH_COOP_COEP_REMOTE_TYPE_PREFIX
)
)
)
{
#
if
!
defined
(
ANDROID
)
MOZ_DIAGNOSTIC_ASSERT
(
false
"
COOP
+
COEP
not
in
webCOOP
+
COEP
process
"
)
;
#
endif
return
false
;
}
return
true
;
}
void
nsPIDOMWindowInner
:
:
AddPeerConnection
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
+
+
:
mActivePeerConnections
+
+
;
}
void
nsPIDOMWindowInner
:
:
RemovePeerConnection
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
:
mActivePeerConnections
)
;
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
-
-
:
mActivePeerConnections
-
-
;
}
bool
nsPIDOMWindowInner
:
:
HasActivePeerConnections
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mTopInnerWindow
?
mTopInnerWindow
-
>
mActivePeerConnections
:
mActivePeerConnections
;
}
bool
nsPIDOMWindowInner
:
:
IsPlayingAudio
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
i
+
+
)
{
if
(
mAudioContexts
[
i
]
-
>
IsRunning
(
)
)
{
return
true
;
}
}
RefPtr
<
AudioChannelService
>
acs
=
AudioChannelService
:
:
Get
(
)
;
if
(
!
acs
)
{
return
false
;
}
auto
outer
=
GetOuterWindow
(
)
;
if
(
!
outer
)
{
return
false
;
}
return
acs
-
>
IsWindowActive
(
outer
)
;
}
bool
nsPIDOMWindowInner
:
:
IsDocumentLoaded
(
)
const
{
return
mIsDocumentLoaded
;
}
mozilla
:
:
dom
:
:
TimeoutManager
&
nsPIDOMWindowInner
:
:
TimeoutManager
(
)
{
return
*
mTimeoutManager
;
}
bool
nsPIDOMWindowInner
:
:
IsRunningTimeout
(
)
{
return
TimeoutManager
(
)
.
IsRunningTimeout
(
)
;
}
void
nsPIDOMWindowInner
:
:
TryToCacheTopInnerWindow
(
)
{
if
(
mHasTriedToCacheTopInnerWindow
)
{
return
;
}
nsGlobalWindowInner
*
window
=
nsGlobalWindowInner
:
:
Cast
(
this
)
;
MOZ_ASSERT
(
!
window
-
>
IsDying
(
)
)
;
mHasTriedToCacheTopInnerWindow
=
true
;
MOZ_ASSERT
(
window
)
;
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
topOutter
=
window
-
>
GetInProcessScriptableTop
(
)
)
{
mTopInnerWindow
=
topOutter
-
>
GetCurrentInnerWindow
(
)
;
}
}
void
nsPIDOMWindowInner
:
:
UpdateActiveIndexedDBTransactionCount
(
int32_t
aDelta
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aDelta
=
=
0
)
{
return
;
}
TabGroup
(
)
-
>
IndexedDBTransactionCounter
(
)
+
=
aDelta
;
}
void
nsPIDOMWindowInner
:
:
UpdateActiveIndexedDBDatabaseCount
(
int32_t
aDelta
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aDelta
=
=
0
)
{
return
;
}
uint32_t
&
counter
=
mTopInnerWindow
?
mTopInnerWindow
-
>
mNumOfIndexedDBDatabases
:
mNumOfIndexedDBDatabases
;
counter
+
=
aDelta
;
TabGroup
(
)
-
>
IndexedDBDatabaseCounter
(
)
+
=
aDelta
;
}
bool
nsPIDOMWindowInner
:
:
HasActiveIndexedDBDatabases
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mTopInnerWindow
?
mTopInnerWindow
-
>
mNumOfIndexedDBDatabases
>
0
:
mNumOfIndexedDBDatabases
>
0
;
}
void
nsPIDOMWindowInner
:
:
UpdateWebSocketCount
(
int32_t
aDelta
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aDelta
=
=
0
)
{
return
;
}
if
(
mTopInnerWindow
&
&
!
IsTopInnerWindow
(
)
)
{
mTopInnerWindow
-
>
UpdateWebSocketCount
(
aDelta
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
aDelta
>
0
|
|
(
(
aDelta
+
mNumOfOpenWebSockets
)
<
mNumOfOpenWebSockets
)
)
;
mNumOfOpenWebSockets
+
=
aDelta
;
}
bool
nsPIDOMWindowInner
:
:
HasOpenWebSockets
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mNumOfOpenWebSockets
|
|
(
mTopInnerWindow
&
&
mTopInnerWindow
-
>
mNumOfOpenWebSockets
)
;
}
bool
nsPIDOMWindowInner
:
:
IsCurrentInnerWindow
(
)
const
{
auto
*
bc
=
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
bc
)
;
nsPIDOMWindowOuter
*
outer
;
if
(
!
bc
-
>
IsDiscarded
(
)
)
{
outer
=
bc
-
>
GetDOMWindow
(
)
;
}
else
{
outer
=
mOuterWindow
;
}
return
outer
&
&
outer
-
>
GetCurrentInnerWindow
(
)
=
=
this
;
}
void
nsPIDOMWindowInner
:
:
SetAudioCapture
(
bool
aCapture
)
{
RefPtr
<
AudioChannelService
>
service
=
AudioChannelService
:
:
GetOrCreate
(
)
;
if
(
service
)
{
service
-
>
SetWindowAudioCaptured
(
GetOuterWindow
(
)
mWindowID
aCapture
)
;
}
}
void
nsGlobalWindowInner
:
:
SetActiveLoadingState
(
bool
aIsLoading
)
{
if
(
StaticPrefs
:
:
dom_separate_event_queue_for_post_message_enabled
(
)
)
{
if
(
!
aIsLoading
)
{
Document
*
doc
=
GetExtantDoc
(
)
;
if
(
doc
)
{
if
(
doc
-
>
IsTopLevelContentDocument
(
)
)
{
mozilla
:
:
dom
:
:
TabGroup
*
tabGroup
=
doc
-
>
GetDocGroup
(
)
-
>
GetTabGroup
(
)
;
tabGroup
-
>
FlushPostMessageEvents
(
)
;
}
}
}
}
if
(
!
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
IsChromeWindow
(
)
)
{
mTimeoutManager
-
>
SetLoading
(
aIsLoading
)
;
}
if
(
!
aIsLoading
)
{
while
(
!
mDeprioritizedLoadRunner
.
isEmpty
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
runner
=
mDeprioritizedLoadRunner
.
popFirst
(
)
;
NS_DispatchToCurrentThread
(
runner
.
forget
(
)
)
;
}
}
}
nsPIDOMWindowInner
*
nsPIDOMWindowInner
:
:
GetWindowForDeprioritizedLoadRunner
(
)
{
Document
*
doc
=
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
doc
=
doc
-
>
GetTopLevelContentDocument
(
)
;
if
(
!
doc
|
|
(
doc
-
>
GetReadyStateEnum
(
)
<
=
Document
:
:
READYSTATE_UNINITIALIZED
|
|
doc
-
>
GetReadyStateEnum
(
)
>
=
Document
:
:
READYSTATE_COMPLETE
)
)
{
return
nullptr
;
}
return
doc
-
>
GetInnerWindow
(
)
;
}
void
nsGlobalWindowInner
:
:
AddDeprioritizedLoadRunner
(
nsIRunnable
*
aRunner
)
{
MOZ_ASSERT
(
GetWindowForDeprioritizedLoadRunner
(
)
=
=
this
)
;
RefPtr
<
DeprioritizedLoadRunner
>
runner
=
new
DeprioritizedLoadRunner
(
aRunner
)
;
mDeprioritizedLoadRunner
.
insertBack
(
runner
)
;
NS_DispatchToCurrentThreadQueue
(
runner
.
forget
(
)
StaticPrefs
:
:
page_load_deprioritization_period
(
)
EventQueuePriority
:
:
Idle
)
;
}
#
ifdef
MOZ_WEBSPEECH
SpeechSynthesis
*
nsGlobalWindowInner
:
:
GetSpeechSynthesis
(
ErrorResult
&
aError
)
{
if
(
!
mSpeechSynthesis
)
{
mSpeechSynthesis
=
new
SpeechSynthesis
(
this
)
;
}
return
mSpeechSynthesis
;
}
bool
nsGlobalWindowInner
:
:
HasActiveSpeechSynthesis
(
)
{
if
(
mSpeechSynthesis
)
{
return
!
mSpeechSynthesis
-
>
HasEmptyQueue
(
)
;
}
return
false
;
}
#
endif
Nullable
<
WindowProxyHolder
>
nsGlobalWindowInner
:
:
GetParent
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetParentOuter
(
)
aError
nullptr
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetInProcessScriptableParent
(
)
{
FORWARD_TO_OUTER
(
GetInProcessScriptableParent
(
)
nullptr
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetInProcessScriptableTop
(
)
{
FORWARD_TO_OUTER
(
GetInProcessScriptableTop
(
)
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
GetContent
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetContentOuter
(
aCx
aRetval
aCallerType
aError
)
aError
)
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetMenubar
(
ErrorResult
&
aError
)
{
if
(
!
mMenubar
)
{
mMenubar
=
new
MenubarProp
(
this
)
;
}
return
mMenubar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetToolbar
(
ErrorResult
&
aError
)
{
if
(
!
mToolbar
)
{
mToolbar
=
new
ToolbarProp
(
this
)
;
}
return
mToolbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetLocationbar
(
ErrorResult
&
aError
)
{
if
(
!
mLocationbar
)
{
mLocationbar
=
new
LocationbarProp
(
this
)
;
}
return
mLocationbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetPersonalbar
(
ErrorResult
&
aError
)
{
if
(
!
mPersonalbar
)
{
mPersonalbar
=
new
PersonalbarProp
(
this
)
;
}
return
mPersonalbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetStatusbar
(
ErrorResult
&
aError
)
{
if
(
!
mStatusbar
)
{
mStatusbar
=
new
StatusbarProp
(
this
)
;
}
return
mStatusbar
;
}
BarProp
*
nsGlobalWindowInner
:
:
GetScrollbars
(
ErrorResult
&
aError
)
{
if
(
!
mScrollbars
)
{
mScrollbars
=
new
ScrollbarsProp
(
this
)
;
}
return
mScrollbars
;
}
bool
nsGlobalWindowInner
:
:
GetClosed
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER
(
GetClosedOuter
(
)
true
)
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowInner
:
:
IndexedGetter
(
uint32_t
aIndex
)
{
FORWARD_TO_OUTER
(
IndexedGetterOuter
(
aIndex
)
nullptr
)
;
}
namespace
{
struct
InterfaceShimEntry
{
const
char
*
geckoName
;
const
char
*
domName
;
}
;
}
const
InterfaceShimEntry
kInterfaceShimMap
[
]
=
{
{
"
nsIXMLHttpRequest
"
"
XMLHttpRequest
"
}
{
"
nsIDOMDOMException
"
"
DOMException
"
}
{
"
nsIDOMNode
"
"
Node
"
}
{
"
nsIDOMCSSRule
"
"
CSSRule
"
}
{
"
nsIDOMEvent
"
"
Event
"
}
{
"
nsIDOMNSEvent
"
"
Event
"
}
{
"
nsIDOMKeyEvent
"
"
KeyEvent
"
}
{
"
nsIDOMMouseEvent
"
"
MouseEvent
"
}
{
"
nsIDOMMouseScrollEvent
"
"
MouseScrollEvent
"
}
{
"
nsIDOMMutationEvent
"
"
MutationEvent
"
}
{
"
nsIDOMUIEvent
"
"
UIEvent
"
}
{
"
nsIDOMHTMLMediaElement
"
"
HTMLMediaElement
"
}
{
"
nsIDOMRange
"
"
Range
"
}
{
"
nsIDOMSVGLength
"
"
SVGLength
"
}
{
"
nsIDOMNodeFilter
"
"
NodeFilter
"
}
{
"
nsIDOMXPathResult
"
"
XPathResult
"
}
}
;
bool
nsGlobalWindowInner
:
:
ResolveComponentsShim
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
aDesc
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COMPONENTS_SHIM_ACCESSED_BY_CONTENT
true
)
;
nsCOMPtr
<
Document
>
doc
=
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
WarnOnceAbout
(
Document
:
:
eComponents
true
)
;
}
AssertSameCompartment
(
aCx
aGlobal
)
;
JS
:
:
Rooted
<
JSObject
*
>
components
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
components
)
)
{
return
false
;
}
JS
:
:
Rooted
<
JSObject
*
>
interfaces
(
aCx
JS_NewPlainObject
(
aCx
)
)
;
if
(
NS_WARN_IF
(
!
interfaces
)
)
{
return
false
;
}
bool
ok
=
JS_DefineProperty
(
aCx
components
"
interfaces
"
interfaces
JSPROP_ENUMERATE
|
JSPROP_PERMANENT
|
JSPROP_READONLY
)
;
if
(
NS_WARN_IF
(
!
ok
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kInterfaceShimMap
)
;
+
+
i
)
{
const
char
*
geckoName
=
kInterfaceShimMap
[
i
]
.
geckoName
;
const
char
*
domName
=
kInterfaceShimMap
[
i
]
.
domName
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
ok
=
JS_GetProperty
(
aCx
aGlobal
domName
&
v
)
;
if
(
NS_WARN_IF
(
!
ok
)
)
{
return
false
;
}
if
(
!
v
.
isObject
(
)
)
{
NS_WARNING
(
"
Unable
to
find
interface
object
on
global
"
)
;
continue
;
}
ok
=
JS_DefineProperty
(
aCx
interfaces
geckoName
v
JSPROP_ENUMERATE
|
JSPROP_PERMANENT
|
JSPROP_READONLY
)
;
if
(
NS_WARN_IF
(
!
ok
)
)
{
return
false
;
}
}
FillPropertyDescriptor
(
aDesc
aGlobal
JS
:
:
ObjectValue
(
*
components
)
false
)
;
return
true
;
}
#
ifdef
RELEASE_OR_BETA
#
define
USE_CONTROLLERS_SHIM
#
endif
#
ifdef
USE_CONTROLLERS_SHIM
static
const
JSClass
ControllersShimClass
=
{
"
Controllers
"
0
}
;
static
const
JSClass
XULControllersShimClass
=
{
"
XULControllers
"
0
}
;
#
endif
bool
nsGlobalWindowInner
:
:
DoResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
aDesc
)
{
if
(
!
JSID_IS_STRING
(
aId
)
)
{
return
true
;
}
bool
found
;
if
(
!
WebIDLGlobalNameHash
:
:
DefineIfEnabled
(
aCx
aObj
aId
aDesc
&
found
)
)
{
return
false
;
}
if
(
found
)
{
return
true
;
}
static
bool
watchingComponentsPref
=
false
;
static
bool
useComponentsShim
=
false
;
if
(
!
watchingComponentsPref
)
{
watchingComponentsPref
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
useComponentsShim
"
dom
.
use_components_shim
"
true
)
;
}
if
(
useComponentsShim
&
&
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_COMPONENTS
)
)
{
return
ResolveComponentsShim
(
aCx
aObj
aDesc
)
;
}
#
ifdef
USE_CONTROLLERS_SHIM
if
(
(
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS
)
|
|
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS_CLASS
)
)
&
&
!
xpc
:
:
IsXrayWrapper
(
aObj
)
&
&
!
nsContentUtils
:
:
IsSystemPrincipal
(
nsContentUtils
:
:
ObjectPrincipal
(
aObj
)
)
)
{
if
(
GetExtantDoc
(
)
)
{
GetExtantDoc
(
)
-
>
WarnOnceAbout
(
Document
:
:
eWindow_Cc_ontrollers
)
;
}
const
JSClass
*
clazz
;
if
(
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS
)
)
{
clazz
=
&
XULControllersShimClass
;
}
else
{
clazz
=
&
ControllersShimClass
;
}
MOZ_ASSERT
(
JS_IsGlobalObject
(
aObj
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
shim
(
aCx
JS_NewObject
(
aCx
clazz
)
)
;
if
(
NS_WARN_IF
(
!
shim
)
)
{
return
false
;
}
FillPropertyDescriptor
(
aDesc
aObj
JS
:
:
ObjectValue
(
*
shim
)
false
)
;
return
true
;
}
#
endif
return
true
;
}
bool
nsGlobalWindowInner
:
:
MayResolve
(
jsid
aId
)
{
if
(
!
JSID_IS_STRING
(
aId
)
)
{
return
false
;
}
if
(
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_COMPONENTS
)
)
{
return
true
;
}
if
(
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS
)
|
|
aId
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS_CLASS
)
)
{
return
true
;
}
return
WebIDLGlobalNameHash
:
:
MayResolve
(
aId
)
;
}
void
nsGlobalWindowInner
:
:
GetOwnPropertyNames
(
JSContext
*
aCx
JS
:
:
MutableHandleVector
<
jsid
>
aNames
bool
aEnumerableOnly
ErrorResult
&
aRv
)
{
if
(
aEnumerableOnly
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
wrapper
(
aCx
GetWrapper
(
)
)
;
WebIDLGlobalNameHash
:
:
NameType
nameType
=
js
:
:
IsObjectInContextCompartment
(
wrapper
aCx
)
?
WebIDLGlobalNameHash
:
:
UnresolvedNamesOnly
:
WebIDLGlobalNameHash
:
:
AllNames
;
if
(
!
WebIDLGlobalNameHash
:
:
GetNames
(
aCx
wrapper
nameType
aNames
)
)
{
aRv
.
NoteJSContextException
(
aCx
)
;
}
}
bool
nsGlobalWindowInner
:
:
IsPrivilegedChromeWindow
(
JSContext
*
aCx
JSObject
*
aObj
)
{
nsGlobalWindowInner
*
win
=
xpc
:
:
WindowOrNull
(
aObj
)
;
return
win
&
&
win
-
>
IsChromeWindow
(
)
&
&
nsContentUtils
:
:
ObjectPrincipal
(
aObj
)
=
=
nsContentUtils
:
:
GetSystemPrincipal
(
)
;
}
bool
nsGlobalWindowInner
:
:
IsRequestIdleCallbackEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
{
return
StaticPrefs
:
:
dom_requestIdleCallback_enabled
(
)
|
|
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
;
}
bool
nsGlobalWindowInner
:
:
RegisterProtocolHandlerAllowedForContext
(
JSContext
*
aCx
JSObject
*
aObj
)
{
return
IsSecureContextOrObjectIsFromSecureContext
(
aCx
aObj
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
registerProtocolHandler
.
insecure
.
enabled
"
)
;
}
bool
nsGlobalWindowInner
:
:
DeviceSensorsEnabled
(
JSContext
*
aCx
JSObject
*
aObj
)
{
return
Preferences
:
:
GetBool
(
"
device
.
sensors
.
enabled
"
)
;
}
nsDOMOfflineResourceList
*
nsGlobalWindowInner
:
:
GetApplicationCache
(
ErrorResult
&
aError
)
{
if
(
!
mApplicationCache
)
{
nsCOMPtr
<
nsIWebNavigation
>
webNav
(
do_QueryInterface
(
GetDocShell
(
)
)
)
;
if
(
!
webNav
|
|
!
mDoc
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
;
aError
=
webNav
-
>
GetCurrentURI
(
getter_AddRefs
(
uri
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
manifestURI
;
nsContentUtils
:
:
GetOfflineAppManifest
(
mDoc
getter_AddRefs
(
manifestURI
)
)
;
RefPtr
<
nsDOMOfflineResourceList
>
applicationCache
=
new
nsDOMOfflineResourceList
(
manifestURI
uri
mDoc
-
>
NodePrincipal
(
)
this
)
;
applicationCache
-
>
Init
(
)
;
mApplicationCache
=
applicationCache
;
}
return
mApplicationCache
;
}
nsDOMOfflineResourceList
*
nsGlobalWindowInner
:
:
GetApplicationCache
(
)
{
return
GetApplicationCache
(
IgnoreErrors
(
)
)
;
}
Crypto
*
nsGlobalWindowInner
:
:
GetCrypto
(
ErrorResult
&
aError
)
{
if
(
!
mCrypto
)
{
mCrypto
=
new
Crypto
(
this
)
;
}
return
mCrypto
;
}
mozilla
:
:
dom
:
:
U2F
*
nsGlobalWindowInner
:
:
GetU2f
(
ErrorResult
&
aError
)
{
if
(
!
mU2F
)
{
RefPtr
<
U2F
>
u2f
=
new
U2F
(
this
)
;
u2f
-
>
Init
(
aError
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
mU2F
=
u2f
;
}
return
mU2F
;
}
nsIControllers
*
nsGlobalWindowInner
:
:
GetControllers
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetControllersOuter
(
aError
)
aError
nullptr
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetControllers
(
nsIControllers
*
*
aResult
)
{
ErrorResult
rv
;
nsCOMPtr
<
nsIControllers
>
controllers
=
GetControllers
(
rv
)
;
controllers
.
forget
(
aResult
)
;
return
rv
.
StealNSResult
(
)
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowInner
:
:
GetOpenerWindow
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetOpenerWindowOuter
(
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
Nullable
<
WindowProxyHolder
>
opener
=
GetOpenerWindow
(
aError
)
;
if
(
aError
.
Failed
(
)
|
|
opener
.
IsNull
(
)
)
{
aRetval
.
setNull
(
)
;
return
;
}
if
(
!
ToJSValue
(
aCx
opener
.
Value
(
)
aRetval
)
)
{
aError
.
NoteJSContextException
(
aCx
)
;
}
}
void
nsGlobalWindowInner
:
:
SetOpener
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aOpener
ErrorResult
&
aError
)
{
if
(
aOpener
.
isNull
(
)
)
{
RefPtr
<
BrowsingContext
>
bc
(
GetBrowsingContext
(
)
)
;
if
(
!
bc
-
>
IsDiscarded
(
)
)
{
bc
-
>
SetOpener
(
nullptr
)
;
}
return
;
}
RedefineProperty
(
aCx
"
opener
"
aOpener
aError
)
;
}
void
nsGlobalWindowInner
:
:
GetEvent
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
)
{
if
(
mEvent
)
{
Unused
<
<
nsContentUtils
:
:
WrapNative
(
aCx
mEvent
aRetval
)
;
}
else
{
aRetval
.
setUndefined
(
)
;
}
}
void
nsGlobalWindowInner
:
:
GetStatus
(
nsAString
&
aStatus
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetStatusOuter
(
aStatus
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetStatus
(
const
nsAString
&
aStatus
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetStatusOuter
(
aStatus
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
GetName
(
nsAString
&
aName
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetNameOuter
(
aName
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetName
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetNameOuter
(
aName
aError
)
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetInnerWidth
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetInnerWidthOuter
(
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetInnerWidth
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetInnerWidth
aValue
aCallerType
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetInnerWidth
(
int32_t
*
aInnerWidth
)
{
ErrorResult
rv
;
*
aInnerWidth
=
GetInnerWidth
(
CallerType
:
:
NonSystem
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerWidth
(
int32_t
aInnerWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetInnerWidthOuter
(
aInnerWidth
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerWidth
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetInnerWidth
aValue
"
innerWidth
"
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetInnerHeight
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetInnerHeightOuter
(
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetInnerHeight
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetInnerHeight
aValue
aCallerType
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
GetInnerHeight
(
int32_t
*
aInnerHeight
)
{
ErrorResult
rv
;
*
aInnerHeight
=
GetInnerHeight
(
CallerType
:
:
NonSystem
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerHeight
(
int32_t
aInnerHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetInnerHeightOuter
(
aInnerHeight
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetInnerHeight
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetInnerHeight
aValue
"
innerHeight
"
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetOuterWidth
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetOuterWidthOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetOuterWidth
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetOuterWidth
aValue
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetOuterHeight
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetOuterHeightOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetOuterHeight
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetOuterHeight
aValue
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterWidth
(
int32_t
aOuterWidth
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetOuterWidthOuter
(
aOuterWidth
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterWidth
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetOuterWidth
aValue
"
outerWidth
"
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterHeight
(
int32_t
aOuterHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetOuterHeightOuter
(
aOuterHeight
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetOuterHeight
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetOuterHeight
aValue
"
outerHeight
"
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScreenX
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScreenXOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetScreenX
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetScreenX
aValue
aCallerType
aError
)
;
}
float
nsGlobalWindowInner
:
:
GetMozInnerScreenX
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetMozInnerScreenXOuter
(
aCallerType
)
aError
0
)
;
}
float
nsGlobalWindowInner
:
:
GetMozInnerScreenY
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetMozInnerScreenYOuter
(
aCallerType
)
aError
0
)
;
}
double
nsGlobalWindowInner
:
:
GetDevicePixelRatio
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetDevicePixelRatioOuter
(
aCallerType
)
aError
0
.
0
)
;
}
uint64_t
nsGlobalWindowInner
:
:
GetMozPaintCount
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetMozPaintCountOuter
(
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
RequestAnimationFrame
(
FrameRequestCallback
&
aCallback
ErrorResult
&
aError
)
{
if
(
!
mDoc
)
{
return
0
;
}
if
(
GetWrapperPreserveColor
(
)
)
{
js
:
:
NotifyAnimationActivity
(
GetWrapperPreserveColor
(
)
)
;
}
DebuggerNotificationDispatch
(
this
DebuggerNotificationType
:
:
RequestAnimationFrame
)
;
int32_t
handle
;
aError
=
mDoc
-
>
ScheduleFrameRequestCallback
(
aCallback
&
handle
)
;
return
handle
;
}
void
nsGlobalWindowInner
:
:
CancelAnimationFrame
(
int32_t
aHandle
ErrorResult
&
aError
)
{
if
(
!
mDoc
)
{
return
;
}
DebuggerNotificationDispatch
(
this
DebuggerNotificationType
:
:
CancelAnimationFrame
)
;
mDoc
-
>
CancelFrameRequestCallback
(
aHandle
)
;
}
already_AddRefed
<
MediaQueryList
>
nsGlobalWindowInner
:
:
MatchMedia
(
const
nsAString
&
aMediaQueryList
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
MatchMediaOuter
(
aMediaQueryList
aCallerType
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenX
(
int32_t
aScreenX
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetScreenXOuter
(
aScreenX
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenX
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetScreenX
aValue
"
screenX
"
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScreenY
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScreenYOuter
(
aCallerType
aError
)
aError
0
)
;
}
void
nsGlobalWindowInner
:
:
GetScreenY
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
GetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
GetScreenY
aValue
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenY
(
int32_t
aScreenY
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetScreenYOuter
(
aScreenY
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SetScreenY
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
CallerType
aCallerType
ErrorResult
&
aError
)
{
SetReplaceableWindowCoord
(
aCx
&
nsGlobalWindowInner
:
:
SetScreenY
aValue
"
screenY
"
aCallerType
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMinX
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideLeft
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMinY
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideTop
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMaxX
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideRight
)
aError
0
)
;
}
int32_t
nsGlobalWindowInner
:
:
GetScrollMaxY
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollBoundaryOuter
(
eSideBottom
)
aError
0
)
;
}
double
nsGlobalWindowInner
:
:
GetScrollX
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollXOuter
(
)
aError
0
)
;
}
double
nsGlobalWindowInner
:
:
GetScrollY
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetScrollYOuter
(
)
aError
0
)
;
}
uint32_t
nsGlobalWindowInner
:
:
Length
(
)
{
FORWARD_TO_OUTER
(
Length
(
)
0
)
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowInner
:
:
GetTop
(
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetTopOuter
(
)
aError
nullptr
)
;
}
already_AddRefed
<
BrowsingContext
>
nsGlobalWindowInner
:
:
GetChildWindow
(
const
nsAString
&
aName
)
{
if
(
GetOuterWindowInternal
(
)
)
{
return
GetOuterWindowInternal
(
)
-
>
GetChildWindow
(
aName
)
;
}
return
nullptr
;
}
void
nsGlobalWindowInner
:
:
RefreshRealmPrincipal
(
)
{
JS
:
:
SetRealmPrincipals
(
js
:
:
GetNonCCWObjectRealm
(
GetWrapperPreserveColor
(
)
)
nsJSPrincipals
:
:
get
(
mDoc
-
>
NodePrincipal
(
)
)
)
;
}
already_AddRefed
<
nsIWidget
>
nsGlobalWindowInner
:
:
GetMainWidget
(
)
{
FORWARD_TO_OUTER
(
GetMainWidget
(
)
nullptr
)
;
}
nsIWidget
*
nsGlobalWindowInner
:
:
GetNearestWidget
(
)
const
{
if
(
GetOuterWindowInternal
(
)
)
{
return
GetOuterWindowInternal
(
)
-
>
GetNearestWidget
(
)
;
}
return
nullptr
;
}
void
nsGlobalWindowInner
:
:
SetFullScreen
(
bool
aFullscreen
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetFullscreenOuter
(
aFullscreen
aError
)
aError
)
;
}
bool
nsGlobalWindowInner
:
:
GetFullScreen
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetFullscreenOuter
(
)
aError
false
)
;
}
bool
nsGlobalWindowInner
:
:
GetFullScreen
(
)
{
ErrorResult
dummy
;
bool
fullscreen
=
GetFullScreen
(
dummy
)
;
dummy
.
SuppressException
(
)
;
return
fullscreen
;
}
void
nsGlobalWindowInner
:
:
Dump
(
const
nsAString
&
aStr
)
{
if
(
!
nsJSUtils
:
:
DumpEnabled
(
)
)
{
return
;
}
char
*
cstr
=
ToNewUTF8String
(
aStr
)
;
#
if
defined
(
XP_MACOSX
)
char
*
c
=
cstr
*
cEnd
=
cstr
+
strlen
(
cstr
)
;
while
(
c
<
cEnd
)
{
if
(
*
c
=
=
'
\
r
'
)
*
c
=
'
\
n
'
;
c
+
+
;
}
#
endif
if
(
cstr
)
{
MOZ_LOG
(
nsContentUtils
:
:
DOMDumpLog
(
)
LogLevel
:
:
Debug
(
"
[
Window
.
Dump
]
%
s
"
cstr
)
)
;
#
ifdef
XP_WIN
PrintToDebugger
(
cstr
)
;
#
endif
#
ifdef
ANDROID
__android_log_write
(
ANDROID_LOG_INFO
"
GeckoDump
"
cstr
)
;
#
endif
FILE
*
fp
=
gDumpFile
?
gDumpFile
:
stdout
;
fputs
(
cstr
fp
)
;
fflush
(
fp
)
;
free
(
cstr
)
;
}
}
void
nsGlobalWindowInner
:
:
Alert
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
Alert
(
EmptyString
(
)
aSubjectPrincipal
aError
)
;
}
void
nsGlobalWindowInner
:
:
Alert
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
AlertOuter
(
aMessage
aSubjectPrincipal
aError
)
aError
)
;
}
bool
nsGlobalWindowInner
:
:
Confirm
(
const
nsAString
&
aMessage
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
ConfirmOuter
(
aMessage
aSubjectPrincipal
aError
)
aError
false
)
;
}
already_AddRefed
<
Promise
>
nsGlobalWindowInner
:
:
Fetch
(
const
RequestOrUSVString
&
aInput
const
RequestInit
&
aInit
CallerType
aCallerType
ErrorResult
&
aRv
)
{
return
FetchRequest
(
this
aInput
aInit
aCallerType
aRv
)
;
}
void
nsGlobalWindowInner
:
:
Prompt
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
PromptOuter
(
aMessage
aInitial
aReturn
aSubjectPrincipal
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
Focus
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
FocusOuter
(
)
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
Focus
(
)
{
ErrorResult
rv
;
Focus
(
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
Blur
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
BlurOuter
(
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
Stop
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
StopOuter
(
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
Print
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
PrintOuter
(
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
MoveTo
(
int32_t
aXPos
int32_t
aYPos
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
MoveToOuter
(
aXPos
aYPos
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
MoveBy
(
int32_t
aXDif
int32_t
aYDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
MoveByOuter
(
aXDif
aYDif
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
ResizeTo
(
int32_t
aWidth
int32_t
aHeight
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
ResizeToOuter
(
aWidth
aHeight
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
ResizeBy
(
int32_t
aWidthDif
int32_t
aHeightDif
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
ResizeByOuter
(
aWidthDif
aHeightDif
aCallerType
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
SizeToContent
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SizeToContentOuter
(
aCallerType
aError
)
aError
)
;
}
already_AddRefed
<
nsPIWindowRoot
>
nsGlobalWindowInner
:
:
GetTopWindowRoot
(
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
return
nullptr
;
}
return
outer
-
>
GetTopWindowRoot
(
)
;
}
void
nsGlobalWindowInner
:
:
Scroll
(
double
aXScroll
double
aYScroll
)
{
auto
scrollPos
=
CSSIntPoint
:
:
Truncate
(
mozilla
:
:
ToZeroIfNonfinite
(
aXScroll
)
mozilla
:
:
ToZeroIfNonfinite
(
aYScroll
)
)
;
ScrollTo
(
scrollPos
ScrollOptions
(
)
)
;
}
void
nsGlobalWindowInner
:
:
ScrollTo
(
double
aXScroll
double
aYScroll
)
{
auto
scrollPos
=
CSSIntPoint
:
:
Truncate
(
mozilla
:
:
ToZeroIfNonfinite
(
aXScroll
)
mozilla
:
:
ToZeroIfNonfinite
(
aYScroll
)
)
;
ScrollTo
(
scrollPos
ScrollOptions
(
)
)
;
}
void
nsGlobalWindowInner
:
:
ScrollTo
(
const
ScrollToOptions
&
aOptions
)
{
FlushType
flushType
=
(
(
aOptions
.
mLeft
.
WasPassed
(
)
&
&
aOptions
.
mLeft
.
Value
(
)
>
0
)
|
|
(
aOptions
.
mTop
.
WasPassed
(
)
&
&
aOptions
.
mTop
.
Value
(
)
>
0
)
)
?
FlushType
:
:
Layout
:
FlushType
:
:
Frames
;
FlushPendingNotifications
(
flushType
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
CSSIntPoint
scrollPos
=
sf
-
>
GetScrollPositionCSSPixels
(
)
;
if
(
aOptions
.
mLeft
.
WasPassed
(
)
)
{
scrollPos
.
x
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mLeft
.
Value
(
)
)
;
}
if
(
aOptions
.
mTop
.
WasPassed
(
)
)
{
scrollPos
.
y
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mTop
.
Value
(
)
)
;
}
ScrollTo
(
scrollPos
aOptions
)
;
}
}
void
nsGlobalWindowInner
:
:
Scroll
(
const
ScrollToOptions
&
aOptions
)
{
ScrollTo
(
aOptions
)
;
}
void
nsGlobalWindowInner
:
:
ScrollTo
(
const
CSSIntPoint
&
aScroll
const
ScrollOptions
&
aOptions
)
{
FlushType
flushType
=
(
aScroll
.
x
|
|
aScroll
.
y
)
?
FlushType
:
:
Layout
:
FlushType
:
:
Frames
;
FlushPendingNotifications
(
flushType
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
const
int32_t
maxpx
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
0x7fffffff
)
-
4
;
CSSIntPoint
scroll
(
aScroll
)
;
if
(
scroll
.
x
>
maxpx
)
{
scroll
.
x
=
maxpx
;
}
if
(
scroll
.
y
>
maxpx
)
{
scroll
.
y
=
maxpx
;
}
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
aOptions
.
mBehavior
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollToCSSPixels
(
scroll
scrollMode
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollBy
(
double
aXScrollDif
double
aYScrollDif
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
ScrollToOptions
options
;
options
.
mLeft
.
Construct
(
aXScrollDif
)
;
options
.
mTop
.
Construct
(
aYScrollDif
)
;
ScrollBy
(
options
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollBy
(
const
ScrollToOptions
&
aOptions
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
CSSIntPoint
scrollDelta
;
if
(
aOptions
.
mLeft
.
WasPassed
(
)
)
{
scrollDelta
.
x
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mLeft
.
Value
(
)
)
;
}
if
(
aOptions
.
mTop
.
WasPassed
(
)
)
{
scrollDelta
.
y
=
mozilla
:
:
ToZeroIfNonfinite
(
aOptions
.
mTop
.
Value
(
)
)
;
}
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
aOptions
.
mBehavior
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollByCSSPixels
(
scrollDelta
scrollMode
nsGkAtoms
:
:
relative
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollByLines
(
int32_t
numLines
const
ScrollOptions
&
aOptions
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
aOptions
.
mBehavior
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollBy
(
nsIntPoint
(
0
numLines
)
nsIScrollableFrame
:
:
LINES
scrollMode
)
;
}
}
void
nsGlobalWindowInner
:
:
ScrollByPages
(
int32_t
numPages
const
ScrollOptions
&
aOptions
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
aOptions
.
mBehavior
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollBy
(
nsIntPoint
(
0
numPages
)
nsIScrollableFrame
:
:
PAGES
scrollMode
)
;
}
}
void
nsGlobalWindowInner
:
:
MozScrollSnap
(
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
)
;
if
(
sf
)
{
sf
-
>
ScrollSnap
(
)
;
}
}
void
nsGlobalWindowInner
:
:
ClearTimeout
(
int32_t
aHandle
)
{
DebuggerNotificationDispatch
(
this
DebuggerNotificationType
:
:
ClearTimeout
)
;
if
(
aHandle
>
0
)
{
mTimeoutManager
-
>
ClearTimeout
(
aHandle
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
)
;
}
}
void
nsGlobalWindowInner
:
:
ClearInterval
(
int32_t
aHandle
)
{
DebuggerNotificationDispatch
(
this
DebuggerNotificationType
:
:
ClearInterval
)
;
if
(
aHandle
>
0
)
{
mTimeoutManager
-
>
ClearTimeout
(
aHandle
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
)
;
}
}
void
nsGlobalWindowInner
:
:
SetResizable
(
bool
aResizable
)
const
{
}
void
nsGlobalWindowInner
:
:
CaptureEvents
(
)
{
if
(
mDoc
)
{
mDoc
-
>
WarnOnceAbout
(
Document
:
:
eUseOfCaptureEvents
)
;
}
}
void
nsGlobalWindowInner
:
:
ReleaseEvents
(
)
{
if
(
mDoc
)
{
mDoc
-
>
WarnOnceAbout
(
Document
:
:
eUseOfReleaseEvents
)
;
}
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowInner
:
:
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
OpenOuter
(
aUrl
aName
aOptions
aError
)
aError
nullptr
)
;
}
Nullable
<
WindowProxyHolder
>
nsGlobalWindowInner
:
:
OpenDialog
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
OpenDialogOuter
(
aCx
aUrl
aName
aOptions
aExtraArgument
aError
)
aError
nullptr
)
;
}
WindowProxyHolder
nsGlobalWindowInner
:
:
GetFrames
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetFramesOuter
(
)
aError
Window
(
)
)
;
}
void
nsGlobalWindowInner
:
:
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
PostMessageMozOuter
(
aCx
aMessage
aTargetOrigin
aTransfer
aSubjectPrincipal
aError
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
Sequence
<
JSObject
*
>
&
aTransfer
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
transferArray
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
aRv
=
nsContentUtils
:
:
CreateJSValueFromSequenceOfObject
(
aCx
aTransfer
&
transferArray
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
PostMessageMoz
(
aCx
aMessage
aTargetOrigin
transferArray
aSubjectPrincipal
aRv
)
;
}
void
nsGlobalWindowInner
:
:
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
WindowPostMessageOptions
&
aOptions
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
transferArray
(
aCx
JS
:
:
UndefinedValue
(
)
)
;
aRv
=
nsContentUtils
:
:
CreateJSValueFromSequenceOfObject
(
aCx
aOptions
.
mTransfer
&
transferArray
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
PostMessageMoz
(
aCx
aMessage
aOptions
.
mTargetOrigin
transferArray
aSubjectPrincipal
aRv
)
;
}
void
nsGlobalWindowInner
:
:
Close
(
CallerType
aCallerType
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
CloseOuter
(
aCallerType
=
=
CallerType
:
:
System
)
aError
)
;
}
nsresult
nsGlobalWindowInner
:
:
Close
(
)
{
FORWARD_TO_OUTER
(
Close
(
)
NS_ERROR_UNEXPECTED
)
;
}
bool
nsGlobalWindowInner
:
:
IsInModalState
(
)
{
FORWARD_TO_OUTER
(
IsInModalState
(
)
false
)
;
}
void
nsGlobalWindowInner
:
:
NotifyDOMWindowDestroyed
(
nsGlobalWindowInner
*
aWindow
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
aWindow
)
DOM_WINDOW_DESTROYED_TOPIC
nullptr
)
;
}
}
void
nsGlobalWindowInner
:
:
NotifyWindowIDDestroyed
(
const
char
*
aTopic
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
new
WindowDestroyedEvent
(
this
mWindowID
aTopic
)
;
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
void
nsGlobalWindowInner
:
:
NotifyDOMWindowFrozen
(
nsGlobalWindowInner
*
aWindow
)
{
if
(
aWindow
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
aWindow
)
DOM_WINDOW_FROZEN_TOPIC
nullptr
)
;
}
}
}
void
nsGlobalWindowInner
:
:
NotifyDOMWindowThawed
(
nsGlobalWindowInner
*
aWindow
)
{
if
(
aWindow
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
aWindow
)
DOM_WINDOW_THAWED_TOPIC
nullptr
)
;
}
}
}
Element
*
nsGlobalWindowInner
:
:
GetFrameElement
(
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetFrameElementOuter
(
aSubjectPrincipal
)
aError
nullptr
)
;
}
Element
*
nsGlobalWindowInner
:
:
GetRealFrameElement
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetRealFrameElementOuter
(
)
aError
nullptr
)
;
}
Element
*
nsGlobalWindowInner
:
:
GetFrameElement
(
)
{
return
GetRealFrameElement
(
IgnoreErrors
(
)
)
;
}
void
nsGlobalWindowInner
:
:
UpdateCommands
(
const
nsAString
&
anAction
Selection
*
aSel
int16_t
aReason
)
{
if
(
GetOuterWindowInternal
(
)
)
{
GetOuterWindowInternal
(
)
-
>
UpdateCommands
(
anAction
aSel
aReason
)
;
}
}
Selection
*
nsGlobalWindowInner
:
:
GetSelection
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetSelectionOuter
(
)
aError
nullptr
)
;
}
bool
nsGlobalWindowInner
:
:
Find
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
FindOuter
(
aString
aCaseSensitive
aBackwards
aWrapAround
aWholeWord
aSearchInFrames
aShowDialog
aError
)
aError
false
)
;
}
void
nsGlobalWindowInner
:
:
GetOrigin
(
nsAString
&
aOrigin
)
{
nsContentUtils
:
:
GetUTFOrigin
(
GetPrincipal
(
)
aOrigin
)
;
}
void
nsGlobalWindowInner
:
:
Atob
(
const
nsAString
&
aAsciiBase64String
nsAString
&
aBinaryData
ErrorResult
&
aError
)
{
aError
=
nsContentUtils
:
:
Atob
(
aAsciiBase64String
aBinaryData
)
;
}
void
nsGlobalWindowInner
:
:
Btoa
(
const
nsAString
&
aBinaryData
nsAString
&
aAsciiBase64String
ErrorResult
&
aError
)
{
aError
=
nsContentUtils
:
:
Btoa
(
aBinaryData
aAsciiBase64String
)
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetOwnerGlobalForBindingsInternal
(
)
{
return
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
this
)
;
}
bool
nsGlobalWindowInner
:
:
DispatchEvent
(
Event
&
aEvent
CallerType
aCallerType
ErrorResult
&
aRv
)
{
if
(
!
IsCurrentInnerWindow
(
)
)
{
NS_WARNING
(
"
DispatchEvent
called
on
non
-
current
inner
window
dropping
.
"
"
Please
check
the
window
in
the
caller
instead
.
"
)
;
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
if
(
!
mDoc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
RefPtr
<
nsPresContext
>
presContext
=
mDoc
-
>
GetPresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsresult
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
ToSupports
(
this
)
nullptr
&
aEvent
presContext
&
status
)
;
bool
retval
=
!
aEvent
.
DefaultPrevented
(
aCallerType
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
return
retval
;
}
bool
nsGlobalWindowInner
:
:
ComputeDefaultWantsUntrusted
(
ErrorResult
&
aRv
)
{
return
!
nsContentUtils
:
:
IsChromeDoc
(
mDoc
)
;
}
EventListenerManager
*
nsGlobalWindowInner
:
:
GetOrCreateListenerManager
(
)
{
if
(
!
mListenerManager
)
{
mListenerManager
=
new
EventListenerManager
(
static_cast
<
EventTarget
*
>
(
this
)
)
;
}
return
mListenerManager
;
}
EventListenerManager
*
nsGlobalWindowInner
:
:
GetExistingListenerManager
(
)
const
{
return
mListenerManager
;
}
mozilla
:
:
dom
:
:
DebuggerNotificationManager
*
nsGlobalWindowInner
:
:
GetOrCreateDebuggerNotificationManager
(
)
{
if
(
!
mDebuggerNotificationManager
)
{
mDebuggerNotificationManager
=
new
DebuggerNotificationManager
(
this
)
;
}
return
mDebuggerNotificationManager
;
}
mozilla
:
:
dom
:
:
DebuggerNotificationManager
*
nsGlobalWindowInner
:
:
GetExistingDebuggerNotificationManager
(
)
{
return
mDebuggerNotificationManager
;
}
Location
*
nsGlobalWindowInner
:
:
Location
(
)
{
if
(
!
mLocation
)
{
mLocation
=
new
dom
:
:
Location
(
this
GetBrowsingContext
(
)
)
;
}
return
mLocation
;
}
void
nsGlobalWindowInner
:
:
MaybeUpdateTouchState
(
)
{
if
(
mMayHaveTouchEventListener
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
static_cast
<
nsIDOMWindow
*
>
(
this
)
DOM_TOUCH_LISTENER_ADDED
nullptr
)
;
}
}
}
void
nsGlobalWindowInner
:
:
EnableGamepadUpdates
(
)
{
if
(
mHasGamepad
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
if
(
gamepadManager
)
{
gamepadManager
-
>
AddListener
(
this
)
;
}
}
}
void
nsGlobalWindowInner
:
:
DisableGamepadUpdates
(
)
{
if
(
mHasGamepad
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
if
(
gamepadManager
)
{
gamepadManager
-
>
RemoveListener
(
this
)
;
}
}
}
void
nsGlobalWindowInner
:
:
EnableVRUpdates
(
)
{
if
(
mHasVREvents
&
&
!
mVREventObserver
)
{
MOZ_ASSERT
(
!
IsDying
(
)
)
;
mVREventObserver
=
new
VREventObserver
(
this
)
;
nsPIDOMWindowOuter
*
outer
=
GetOuterWindow
(
)
;
if
(
outer
&
&
!
outer
-
>
IsBackground
(
)
)
{
mVREventObserver
-
>
StartActivity
(
)
;
}
}
}
void
nsGlobalWindowInner
:
:
DisableVRUpdates
(
)
{
if
(
mVREventObserver
)
{
mVREventObserver
-
>
DisconnectFromOwner
(
)
;
mVREventObserver
=
nullptr
;
}
}
void
nsGlobalWindowInner
:
:
ResetVRTelemetry
(
bool
aUpdate
)
{
if
(
mVREventObserver
)
{
mVREventObserver
-
>
UpdateSpentTimeIn2DTelemetry
(
aUpdate
)
;
}
}
void
nsGlobalWindowInner
:
:
StartVRActivity
(
)
{
if
(
mVREventObserver
)
{
mVREventObserver
-
>
StartActivity
(
)
;
}
}
void
nsGlobalWindowInner
:
:
StopVRActivity
(
)
{
if
(
mVREventObserver
)
{
mVREventObserver
-
>
StopActivity
(
)
;
}
}
#
ifndef
XP_WIN
static
bool
ShouldShowFocusRingIfFocusedByMouse
(
nsIContent
*
aNode
)
{
if
(
!
aNode
)
{
return
true
;
}
return
!
nsContentUtils
:
:
ContentIsLink
(
aNode
)
&
&
!
aNode
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
video
nsGkAtoms
:
:
audio
)
;
}
#
endif
void
nsGlobalWindowInner
:
:
SetFocusedElement
(
Element
*
aElement
uint32_t
aFocusMethod
bool
aNeedsFocus
)
{
if
(
aElement
&
&
aElement
-
>
GetComposedDoc
(
)
!
=
mDoc
)
{
NS_WARNING
(
"
Trying
to
set
focus
to
a
node
from
a
wrong
document
"
)
;
return
;
}
if
(
IsDying
(
)
)
{
NS_ASSERTION
(
!
aElement
"
Trying
to
focus
cleaned
up
window
!
"
)
;
aElement
=
nullptr
;
aNeedsFocus
=
false
;
}
if
(
mFocusedElement
!
=
aElement
)
{
UpdateCanvasFocus
(
false
aElement
)
;
mFocusedElement
=
aElement
;
mFocusMethod
=
aFocusMethod
&
FOCUSMETHOD_MASK
;
mShowFocusRingForContent
=
false
;
}
if
(
mFocusedElement
)
{
if
(
mFocusMethod
&
nsIFocusManager
:
:
FLAG_BYKEY
)
{
mFocusByKeyOccurred
=
true
;
}
else
if
(
#
ifndef
XP_WIN
!
(
mFocusMethod
&
nsIFocusManager
:
:
FLAG_BYMOUSE
)
|
|
ShouldShowFocusRingIfFocusedByMouse
(
aElement
)
|
|
#
endif
aFocusMethod
&
nsIFocusManager
:
:
FLAG_SHOWRING
)
{
mShowFocusRingForContent
=
true
;
}
}
if
(
aNeedsFocus
)
mNeedsFocus
=
aNeedsFocus
;
}
uint32_t
nsGlobalWindowInner
:
:
GetFocusMethod
(
)
{
return
mFocusMethod
;
}
bool
nsGlobalWindowInner
:
:
ShouldShowFocusRing
(
)
{
if
(
mShowFocusRingForContent
|
|
mFocusByKeyOccurred
)
{
return
true
;
}
nsCOMPtr
<
nsPIWindowRoot
>
root
=
GetTopWindowRoot
(
)
;
return
root
?
root
-
>
ShowFocusRings
(
)
:
false
;
}
bool
nsGlobalWindowInner
:
:
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
{
if
(
IsDying
(
)
)
{
return
false
;
}
if
(
aFocus
)
mFocusMethod
=
aFocusMethod
&
FOCUSMETHOD_MASK
;
if
(
mHasFocus
!
=
aFocus
)
{
mHasFocus
=
aFocus
;
UpdateCanvasFocus
(
true
mFocusedElement
)
;
}
if
(
aFocus
&
&
mNeedsFocus
&
&
mDoc
&
&
mDoc
-
>
GetRootElement
(
)
!
=
nullptr
)
{
mNeedsFocus
=
false
;
return
true
;
}
mNeedsFocus
=
false
;
return
false
;
}
void
nsGlobalWindowInner
:
:
SetReadyForFocus
(
)
{
bool
oldNeedsFocus
=
mNeedsFocus
;
mNeedsFocus
=
false
;
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
fm
-
>
WindowShown
(
GetOuterWindow
(
)
oldNeedsFocus
)
;
}
}
void
nsGlobalWindowInner
:
:
PageHidden
(
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
fm
-
>
WindowHidden
(
GetOuterWindow
(
)
)
;
}
mNeedsFocus
=
true
;
}
class
HashchangeCallback
:
public
Runnable
{
public
:
HashchangeCallback
(
const
nsAString
&
aOldURL
const
nsAString
&
aNewURL
nsGlobalWindowInner
*
aWindow
)
:
mozilla
:
:
Runnable
(
"
HashchangeCallback
"
)
mWindow
(
aWindow
)
{
MOZ_ASSERT
(
mWindow
)
;
mOldURL
.
Assign
(
aOldURL
)
;
mNewURL
.
Assign
(
aNewURL
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Should
be
called
on
the
main
thread
.
"
)
;
return
mWindow
-
>
FireHashchange
(
mOldURL
mNewURL
)
;
}
private
:
nsString
mOldURL
;
nsString
mNewURL
;
RefPtr
<
nsGlobalWindowInner
>
mWindow
;
}
;
nsresult
nsGlobalWindowInner
:
:
DispatchAsyncHashchange
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
)
{
bool
equal
=
false
;
NS_ENSURE_STATE
(
NS_SUCCEEDED
(
aOldURI
-
>
EqualsExceptRef
(
aNewURI
&
equal
)
)
&
&
equal
)
;
nsAutoCString
oldHash
newHash
;
bool
oldHasHash
newHasHash
;
NS_ENSURE_STATE
(
NS_SUCCEEDED
(
aOldURI
-
>
GetRef
(
oldHash
)
)
&
&
NS_SUCCEEDED
(
aNewURI
-
>
GetRef
(
newHash
)
)
&
&
NS_SUCCEEDED
(
aOldURI
-
>
GetHasRef
(
&
oldHasHash
)
)
&
&
NS_SUCCEEDED
(
aNewURI
-
>
GetHasRef
(
&
newHasHash
)
)
&
&
(
oldHasHash
!
=
newHasHash
|
|
!
oldHash
.
Equals
(
newHash
)
)
)
;
nsAutoCString
oldSpec
newSpec
;
nsresult
rv
=
aOldURI
-
>
GetSpec
(
oldSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aNewURI
-
>
GetSpec
(
newSpec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ConvertUTF8toUTF16
oldWideSpec
(
oldSpec
)
;
NS_ConvertUTF8toUTF16
newWideSpec
(
newSpec
)
;
nsCOMPtr
<
nsIRunnable
>
callback
=
new
HashchangeCallback
(
oldWideSpec
newWideSpec
this
)
;
return
Dispatch
(
TaskCategory
:
:
Other
callback
.
forget
(
)
)
;
}
nsresult
nsGlobalWindowInner
:
:
FireHashchange
(
const
nsAString
&
aOldURL
const
nsAString
&
aNewURL
)
{
if
(
IsFrozen
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
IsCurrentInnerWindow
(
)
)
;
HashChangeEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
false
;
init
.
mNewURL
=
aNewURL
;
init
.
mOldURL
=
aOldURL
;
RefPtr
<
HashChangeEvent
>
event
=
HashChangeEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
hashchange
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
ErrorResult
rv
;
DispatchEvent
(
*
event
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
nsresult
nsGlobalWindowInner
:
:
DispatchSyncPopState
(
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Must
be
safe
to
run
script
here
.
"
)
;
if
(
IsFrozen
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIVariant
>
stateObj
;
nsresult
rv
=
mDoc
-
>
GetStateObject
(
getter_AddRefs
(
stateObj
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
AutoJSAPI
jsapi
;
bool
result
=
jsapi
.
Init
(
this
)
;
NS_ENSURE_TRUE
(
result
NS_ERROR_FAILURE
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
stateJSValue
(
cx
JS
:
:
NullValue
(
)
)
;
result
=
stateObj
?
VariantToJsval
(
cx
stateObj
&
stateJSValue
)
:
true
;
NS_ENSURE_TRUE
(
result
NS_ERROR_FAILURE
)
;
RootedDictionary
<
PopStateEventInit
>
init
(
cx
)
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
false
;
init
.
mState
=
stateJSValue
;
RefPtr
<
PopStateEvent
>
event
=
PopStateEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
popstate
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
SetTarget
(
this
)
;
ErrorResult
err
;
DispatchEvent
(
*
event
err
)
;
return
err
.
StealNSResult
(
)
;
}
void
nsGlobalWindowInner
:
:
UpdateCanvasFocus
(
bool
aFocusChanged
nsIContent
*
aNewContent
)
{
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
!
docShell
)
return
;
bool
editable
;
docShell
-
>
GetEditable
(
&
editable
)
;
if
(
editable
)
return
;
PresShell
*
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
|
|
!
mDoc
)
{
return
;
}
Element
*
rootElement
=
mDoc
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
if
(
(
mHasFocus
|
|
aFocusChanged
)
&
&
(
mFocusedElement
=
=
rootElement
|
|
aNewContent
=
=
rootElement
)
)
{
nsCanvasFrame
*
canvasFrame
=
presShell
-
>
GetCanvasFrame
(
)
;
if
(
canvasFrame
)
{
canvasFrame
-
>
SetHasFocus
(
mHasFocus
&
&
rootElement
=
=
aNewContent
)
;
}
}
}
else
{
nsCanvasFrame
*
canvasFrame
=
presShell
-
>
GetCanvasFrame
(
)
;
if
(
canvasFrame
)
{
canvasFrame
-
>
SetHasFocus
(
false
)
;
}
}
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowInner
:
:
GetComputedStyle
(
Element
&
aElt
const
nsAString
&
aPseudoElt
ErrorResult
&
aError
)
{
return
GetComputedStyleHelper
(
aElt
aPseudoElt
false
aError
)
;
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowInner
:
:
GetDefaultComputedStyle
(
Element
&
aElt
const
nsAString
&
aPseudoElt
ErrorResult
&
aError
)
{
return
GetComputedStyleHelper
(
aElt
aPseudoElt
true
aError
)
;
}
already_AddRefed
<
nsICSSDeclaration
>
nsGlobalWindowInner
:
:
GetComputedStyleHelper
(
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetComputedStyleHelperOuter
(
aElt
aPseudoElt
aDefaultStylesOnly
)
aError
nullptr
)
;
}
Storage
*
nsGlobalWindowInner
:
:
GetSessionStorage
(
ErrorResult
&
aError
)
{
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
!
principal
|
|
!
docShell
|
|
!
Storage
:
:
StoragePrefIsEnabled
(
)
)
{
return
nullptr
;
}
if
(
mSessionStorage
)
{
MOZ_LOG
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
has
%
p
sessionStorage
"
this
mSessionStorage
.
get
(
)
)
)
;
bool
canAccess
=
principal
-
>
Subsumes
(
mSessionStorage
-
>
Principal
(
)
)
;
NS_ASSERTION
(
canAccess
"
This
window
owned
sessionStorage
"
"
that
could
not
be
accessed
!
"
)
;
if
(
!
canAccess
)
{
mSessionStorage
=
nullptr
;
}
}
if
(
!
mSessionStorage
)
{
nsString
documentURI
;
if
(
mDoc
)
{
aError
=
mDoc
-
>
GetDocumentURI
(
documentURI
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
if
(
!
mDoc
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
uint32_t
rejectedReason
=
0
;
StorageAccess
access
=
StorageAllowedForWindow
(
this
&
rejectedReason
)
;
if
(
access
=
=
StorageAccess
:
:
eDeny
&
&
rejectedReason
!
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_FOREIGN
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsresult
rv
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_QueryInterface
(
docShell
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
RefPtr
<
Storage
>
storage
;
aError
=
storageManager
-
>
CreateStorage
(
this
principal
principal
documentURI
IsPrivateBrowsing
(
)
getter_AddRefs
(
storage
)
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
mSessionStorage
=
storage
;
MOZ_ASSERT
(
mSessionStorage
)
;
MOZ_LOG
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
tried
to
get
a
new
sessionStorage
%
p
"
this
mSessionStorage
.
get
(
)
)
)
;
if
(
!
mSessionStorage
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
}
MOZ_LOG
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
returns
%
p
sessionStorage
"
this
mSessionStorage
.
get
(
)
)
)
;
return
mSessionStorage
;
}
Storage
*
nsGlobalWindowInner
:
:
GetLocalStorage
(
ErrorResult
&
aError
)
{
if
(
!
Storage
:
:
StoragePrefIsEnabled
(
)
)
{
return
nullptr
;
}
StorageAccess
access
=
StorageAllowedForWindow
(
this
)
;
bool
isolated
=
false
;
if
(
ShouldPartitionStorage
(
access
)
)
{
if
(
!
mDoc
)
{
access
=
StorageAccess
:
:
eDeny
;
}
else
if
(
!
StoragePartitioningEnabled
(
access
mDoc
-
>
CookieSettings
(
)
)
)
{
static
const
char
*
kPrefName
=
"
privacy
.
restrict3rdpartystorage
.
partitionedHosts
"
;
bool
isInList
=
false
;
mDoc
-
>
NodePrincipal
(
)
-
>
IsURIInPrefList
(
kPrefName
&
isInList
)
;
if
(
!
isInList
)
{
access
=
StorageAccess
:
:
eDeny
;
}
else
{
isolated
=
true
;
}
}
}
if
(
access
=
=
StorageAccess
:
:
eDeny
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsICookieSettings
>
cookieSettings
;
if
(
mDoc
)
{
cookieSettings
=
mDoc
-
>
CookieSettings
(
)
;
}
else
{
cookieSettings
=
net
:
:
CookieSettings
:
:
CreateBlockingAll
(
)
;
}
bool
partitioningEnabled
=
StoragePartitioningEnabled
(
access
cookieSettings
)
;
bool
shouldPartition
=
ShouldPartitionStorage
(
access
)
;
bool
partition
=
partitioningEnabled
&
&
shouldPartition
;
if
(
(
partitioningEnabled
|
|
!
shouldPartition
)
&
&
(
(
mLocalStorage
&
&
(
(
mLocalStorage
-
>
Type
(
)
!
=
(
partition
?
Storage
:
:
ePartitionedLocalStorage
:
Storage
:
:
eLocalStorage
)
)
|
|
mLocalStorage
-
>
StoragePrincipal
(
)
!
=
GetEffectiveStoragePrincipal
(
)
)
)
|
|
(
!
partition
&
&
!
mLocalStorage
)
)
)
{
RefPtr
<
Storage
>
storage
;
if
(
NextGenLocalStorageEnabled
(
)
)
{
aError
=
LSObject
:
:
CreateForWindow
(
this
getter_AddRefs
(
storage
)
)
;
}
else
{
nsresult
rv
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_GetService
(
"
mozilla
.
org
/
dom
/
localStorage
-
manager
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
nsString
documentURI
;
if
(
mDoc
)
{
aError
=
mDoc
-
>
GetDocumentURI
(
documentURI
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsIPrincipal
*
storagePrincipal
=
GetEffectiveStoragePrincipal
(
)
;
if
(
!
storagePrincipal
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
aError
=
storageManager
-
>
CreateStorage
(
this
principal
storagePrincipal
documentURI
IsPrivateBrowsing
(
)
getter_AddRefs
(
storage
)
)
;
}
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
mLocalStorage
=
storage
;
MOZ_ASSERT
(
mLocalStorage
)
;
}
if
(
(
(
partitioningEnabled
&
&
shouldPartition
)
|
|
isolated
)
&
&
!
mLocalStorage
)
{
nsresult
rv
;
nsCOMPtr
<
nsIDOMSessionStorageManager
>
storageManager
=
do_GetService
(
"
mozilla
.
org
/
dom
/
sessionStorage
-
manager
;
1
"
&
rv
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
nsIPrincipal
*
storagePrincipal
=
GetEffectiveStoragePrincipal
(
)
;
if
(
!
storagePrincipal
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
RefPtr
<
SessionStorageCache
>
cache
;
if
(
isolated
)
{
cache
=
new
SessionStorageCache
(
)
;
}
else
{
rv
=
storageManager
-
>
GetSessionStorageCache
(
principal
storagePrincipal
&
cache
)
;
if
(
NS_FAILED
(
rv
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
}
mLocalStorage
=
new
PartitionedLocalStorage
(
this
principal
storagePrincipal
cache
)
;
}
MOZ_ASSERT_IF
(
!
partitioningEnabled
shouldPartition
=
=
(
mLocalStorage
-
>
Type
(
)
=
=
Storage
:
:
ePartitionedLocalStorage
)
)
;
return
mLocalStorage
;
}
IDBFactory
*
nsGlobalWindowInner
:
:
GetIndexedDB
(
ErrorResult
&
aError
)
{
if
(
!
mIndexedDB
)
{
aError
=
IDBFactory
:
:
CreateForWindow
(
this
getter_AddRefs
(
mIndexedDB
)
)
;
}
return
mIndexedDB
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
NS_ENSURE_TRUE
(
outer
NS_ERROR_NOT_INITIALIZED
)
;
nsresult
rv
=
outer
-
>
GetInterfaceInternal
(
aIID
aSink
)
;
if
(
rv
=
=
NS_ERROR_NO_INTERFACE
)
{
return
QueryInterface
(
aIID
aSink
)
;
}
return
rv
;
}
void
nsGlobalWindowInner
:
:
GetInterface
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
ErrorResult
&
aError
)
{
dom
:
:
GetInterface
(
aCx
this
aIID
aRetval
aError
)
;
}
already_AddRefed
<
CacheStorage
>
nsGlobalWindowInner
:
:
GetCaches
(
ErrorResult
&
aRv
)
{
if
(
!
mCacheStorage
)
{
bool
forceTrustedOrigin
=
GetOuterWindow
(
)
-
>
GetServiceWorkersTestingEnabled
(
)
;
mCacheStorage
=
CacheStorage
:
:
CreateOnMainThread
(
cache
:
:
DEFAULT_NAMESPACE
this
GetEffectiveStoragePrincipal
(
)
forceTrustedOrigin
aRv
)
;
}
RefPtr
<
CacheStorage
>
ref
=
mCacheStorage
;
return
ref
.
forget
(
)
;
}
void
nsGlobalWindowInner
:
:
FireOfflineStatusEventIfChanged
(
)
{
if
(
!
IsCurrentInnerWindow
(
)
)
return
;
if
(
mWasOffline
=
=
NS_IsOffline
(
)
)
{
return
;
}
mWasOffline
=
!
mWasOffline
;
nsAutoString
name
;
if
(
mWasOffline
)
{
name
.
AssignLiteral
(
"
offline
"
)
;
}
else
{
name
.
AssignLiteral
(
"
online
"
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
mDoc
static_cast
<
EventTarget
*
>
(
this
)
name
CanBubble
:
:
eNo
Cancelable
:
:
eNo
)
;
}
nsGlobalWindowInner
:
:
SlowScriptResponse
nsGlobalWindowInner
:
:
ShowSlowScriptDialog
(
JSContext
*
aCx
const
nsString
&
aAddonId
)
{
nsresult
rv
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
always_stop_slow_scripts
"
)
)
{
return
KillSlowScript
;
}
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
JS
:
:
WarnASCII
(
aCx
"
A
long
running
script
was
terminated
"
)
;
return
KillSlowScript
;
}
if
(
!
HasActiveDocument
(
)
)
{
return
KillSlowScript
;
}
JS
:
:
AutoFilename
filename
;
unsigned
lineno
;
unsigned
*
linenop
=
XRE_IsParentProcess
(
)
?
&
lineno
:
nullptr
;
bool
hasFrame
=
JS
:
:
DescribeScriptedCaller
(
aCx
&
filename
linenop
)
;
if
(
!
mHasHadSlowScript
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SLOW_SCRIPT_PAGE_COUNT
1
)
;
}
mHasHadSlowScript
=
true
;
if
(
XRE_IsContentProcess
(
)
&
&
ProcessHangMonitor
:
:
Get
(
)
)
{
ProcessHangMonitor
:
:
SlowScriptAction
action
;
RefPtr
<
ProcessHangMonitor
>
monitor
=
ProcessHangMonitor
:
:
Get
(
)
;
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
nsCOMPtr
<
nsIBrowserChild
>
child
=
docShell
?
docShell
-
>
GetBrowserChild
(
)
:
nullptr
;
action
=
monitor
-
>
NotifySlowScript
(
child
filename
.
get
(
)
aAddonId
)
;
if
(
action
=
=
ProcessHangMonitor
:
:
Terminate
)
{
return
KillSlowScript
;
}
if
(
action
=
=
ProcessHangMonitor
:
:
TerminateGlobal
)
{
return
KillScriptGlobal
;
}
if
(
action
=
=
ProcessHangMonitor
:
:
StartDebugger
)
{
RefPtr
<
nsGlobalWindowOuter
>
outer
=
GetOuterWindowInternal
(
)
;
outer
-
>
EnterModalState
(
)
;
SpinEventLoopUntil
(
[
&
]
(
)
{
return
monitor
-
>
IsDebuggerStartupComplete
(
)
;
}
)
;
outer
-
>
LeaveModalState
(
)
;
return
ContinueSlowScript
;
}
return
ContinueSlowScriptAndKeepNotifying
;
}
Telemetry
:
:
Accumulate
(
Telemetry
:
:
SLOW_SCRIPT_NOTICE_COUNT
1
)
;
nsCOMPtr
<
nsIDocShell
>
ds
=
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
ds
KillSlowScript
)
;
nsCOMPtr
<
nsIPrompt
>
prompt
=
do_GetInterface
(
ds
)
;
NS_ENSURE_TRUE
(
prompt
KillSlowScript
)
;
nsCOMPtr
<
nsISlowScriptDebugCallback
>
debugCallback
;
if
(
hasFrame
)
{
const
char
*
debugCID
=
"
mozilla
.
org
/
dom
/
slow
-
script
-
debug
;
1
"
;
nsCOMPtr
<
nsISlowScriptDebug
>
debugService
=
do_GetService
(
debugCID
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
debugService
-
>
GetActivationHandler
(
getter_AddRefs
(
debugCallback
)
)
;
}
}
bool
failed
=
false
;
auto
getString
=
[
&
]
(
const
char
*
name
nsContentUtils
:
:
PropertiesFile
propFile
=
nsContentUtils
:
:
eDOM_PROPERTIES
)
{
nsAutoString
result
;
nsresult
rv
=
nsContentUtils
:
:
GetLocalizedString
(
propFile
name
result
)
;
failed
=
failed
|
|
NS_FAILED
(
rv
)
|
|
result
.
IsEmpty
(
)
;
return
result
;
}
;
bool
isAddonScript
=
!
aAddonId
.
IsEmpty
(
)
;
bool
showDebugButton
=
debugCallback
&
&
!
isAddonScript
;
nsAutoString
title
checkboxMsg
debugButton
msg
;
if
(
isAddonScript
)
{
title
=
getString
(
"
KillAddonScriptTitle
"
)
;
checkboxMsg
=
getString
(
"
KillAddonScriptGlobalMessage
"
)
;
auto
appName
=
getString
(
"
brandShortName
"
nsContentUtils
:
:
eBRAND_PROPERTIES
)
;
nsCOMPtr
<
nsIAddonPolicyService
>
aps
=
do_GetService
(
"
mozilla
.
org
/
addons
/
policy
-
service
;
1
"
)
;
nsString
addonName
;
if
(
!
aps
|
|
NS_FAILED
(
aps
-
>
GetExtensionName
(
aAddonId
addonName
)
)
)
{
addonName
=
aAddonId
;
}
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
msg
nsContentUtils
:
:
eDOM_PROPERTIES
"
KillAddonScriptMessage
"
addonName
appName
)
;
failed
=
failed
|
|
NS_FAILED
(
rv
)
;
}
else
{
title
=
getString
(
"
KillScriptTitle
"
)
;
checkboxMsg
=
getString
(
"
DontAskAgain
"
)
;
if
(
showDebugButton
)
{
debugButton
=
getString
(
"
DebugScriptButton
"
)
;
msg
=
getString
(
"
KillScriptWithDebugMessage
"
)
;
}
else
{
msg
=
getString
(
"
KillScriptMessage
"
)
;
}
}
auto
stopButton
=
getString
(
"
StopScriptButton
"
)
;
auto
waitButton
=
getString
(
"
WaitForScriptButton
"
)
;
if
(
failed
)
{
NS_ERROR
(
"
Failed
to
get
localized
strings
.
"
)
;
return
ContinueSlowScript
;
}
if
(
filename
.
get
(
)
)
{
nsAutoString
scriptLocation
;
NS_ConvertUTF8toUTF16
filenameUTF16
(
filename
.
get
(
)
)
;
if
(
filenameUTF16
.
Length
(
)
>
60
)
{
size_t
cutStart
=
30
;
size_t
cutLength
=
filenameUTF16
.
Length
(
)
-
60
;
MOZ_ASSERT
(
cutLength
>
0
)
;
if
(
NS_IS_LOW_SURROGATE
(
filenameUTF16
[
cutStart
]
)
)
{
+
+
cutStart
;
-
-
cutLength
;
}
if
(
NS_IS_LOW_SURROGATE
(
filenameUTF16
[
cutStart
+
cutLength
]
)
)
{
+
+
cutLength
;
}
filenameUTF16
.
ReplaceLiteral
(
cutStart
cutLength
u
"
\
x2026
"
)
;
}
rv
=
nsContentUtils
:
:
FormatLocalizedString
(
scriptLocation
nsContentUtils
:
:
eDOM_PROPERTIES
"
KillScriptLocation
"
filenameUTF16
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
msg
.
AppendLiteral
(
"
\
n
\
n
"
)
;
msg
.
Append
(
scriptLocation
)
;
msg
.
Append
(
'
:
'
)
;
msg
.
AppendInt
(
lineno
)
;
}
}
uint32_t
buttonFlags
=
nsIPrompt
:
:
BUTTON_POS_1_DEFAULT
+
(
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
*
(
nsIPrompt
:
:
BUTTON_POS_0
+
nsIPrompt
:
:
BUTTON_POS_1
)
)
;
if
(
showDebugButton
)
buttonFlags
+
=
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
*
nsIPrompt
:
:
BUTTON_POS_2
;
bool
checkboxValue
=
false
;
int32_t
buttonPressed
=
0
;
{
AutoDisableJSInterruptCallback
disabler
(
aCx
)
;
rv
=
prompt
-
>
ConfirmEx
(
title
.
get
(
)
msg
.
get
(
)
buttonFlags
waitButton
.
get
(
)
stopButton
.
get
(
)
debugButton
.
get
(
)
checkboxMsg
.
get
(
)
&
checkboxValue
&
buttonPressed
)
;
}
if
(
buttonPressed
=
=
0
)
{
if
(
checkboxValue
&
&
!
isAddonScript
&
&
NS_SUCCEEDED
(
rv
)
)
return
AlwaysContinueSlowScript
;
return
ContinueSlowScript
;
}
if
(
buttonPressed
=
=
2
)
{
MOZ_RELEASE_ASSERT
(
debugCallback
)
;
rv
=
debugCallback
-
>
HandleSlowScriptDebug
(
this
)
;
return
NS_SUCCEEDED
(
rv
)
?
ContinueSlowScript
:
KillSlowScript
;
}
JS_ClearPendingException
(
aCx
)
;
if
(
checkboxValue
&
&
isAddonScript
)
return
KillScriptGlobal
;
return
KillSlowScript
;
}
nsresult
nsGlobalWindowInner
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_IOSERVICE_OFFLINE_STATUS_TOPIC
)
)
{
if
(
!
IsFrozen
(
)
)
{
FireOfflineStatusEventIfChanged
(
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
MEMORY_PRESSURE_OBSERVER_TOPIC
)
)
{
if
(
mPerformance
)
{
mPerformance
-
>
MemoryPressure
(
)
;
mReportRecords
.
Clear
(
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
offline
-
cache
-
update
-
added
"
)
)
{
if
(
mApplicationCache
)
return
NS_OK
;
nsCOMPtr
<
nsIObserver
>
observer
=
GetApplicationCache
(
)
;
if
(
observer
)
observer
-
>
Observe
(
aSubject
aTopic
aData
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
)
{
MOZ_ASSERT
(
!
NS_strcmp
(
aData
u
"
intl
.
accept_languages
"
)
)
;
if
(
mNavigator
)
{
Navigator_Binding
:
:
ClearCachedLanguageValue
(
mNavigator
)
;
Navigator_Binding
:
:
ClearCachedLanguagesValue
(
mNavigator
)
;
}
if
(
!
IsCurrentInnerWindow
(
)
)
{
return
NS_OK
;
}
RefPtr
<
Event
>
event
=
NS_NewDOMEvent
(
this
nullptr
nullptr
)
;
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
languagechange
"
)
false
false
)
;
event
-
>
SetTrusted
(
true
)
;
ErrorResult
rv
;
DispatchEvent
(
*
event
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_WARNING
(
"
unrecognized
topic
in
nsGlobalWindowInner
:
:
Observe
"
)
;
return
NS_ERROR_FAILURE
;
}
void
nsGlobalWindowInner
:
:
ObserveStorageNotification
(
StorageEvent
*
aEvent
const
char16_t
*
aStorageType
bool
aPrivateBrowsing
)
{
MOZ_ASSERT
(
aEvent
)
;
if
(
aPrivateBrowsing
!
=
IsPrivateBrowsing
(
)
)
{
return
;
}
if
(
!
IsCurrentInnerWindow
(
)
|
|
IsFrozen
(
)
)
{
return
;
}
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
return
;
}
nsIPrincipal
*
storagePrincipal
=
GetEffectiveStoragePrincipal
(
)
;
if
(
!
storagePrincipal
)
{
return
;
}
bool
fireMozStorageChanged
=
false
;
nsAutoString
eventType
;
eventType
.
AssignLiteral
(
"
storage
"
)
;
if
(
!
NS_strcmp
(
aStorageType
u
"
sessionStorage
"
)
)
{
RefPtr
<
Storage
>
changingStorage
=
aEvent
-
>
GetStorageArea
(
)
;
MOZ_ASSERT
(
changingStorage
)
;
bool
check
=
false
;
nsCOMPtr
<
nsIDOMStorageManager
>
storageManager
=
do_QueryInterface
(
GetDocShell
(
)
)
;
if
(
storageManager
)
{
nsresult
rv
=
storageManager
-
>
CheckStorage
(
principal
changingStorage
&
check
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
if
(
!
check
)
{
return
;
}
MOZ_LOG
(
gDOMLeakPRLogInner
LogLevel
:
:
Debug
(
"
nsGlobalWindowInner
%
p
with
sessionStorage
%
p
passing
event
from
%
p
"
this
mSessionStorage
.
get
(
)
changingStorage
.
get
(
)
)
)
;
fireMozStorageChanged
=
mSessionStorage
=
=
changingStorage
;
if
(
fireMozStorageChanged
)
{
eventType
.
AssignLiteral
(
"
MozSessionStorageChanged
"
)
;
}
}
else
{
MOZ_ASSERT
(
!
NS_strcmp
(
aStorageType
u
"
localStorage
"
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
StorageUtils
:
:
PrincipalsEqual
(
aEvent
-
>
GetPrincipal
(
)
storagePrincipal
)
)
;
fireMozStorageChanged
=
mLocalStorage
&
&
mLocalStorage
=
=
aEvent
-
>
GetStorageArea
(
)
;
if
(
fireMozStorageChanged
)
{
eventType
.
AssignLiteral
(
"
MozLocalStorageChanged
"
)
;
}
}
IgnoredErrorResult
error
;
RefPtr
<
StorageEvent
>
clonedEvent
=
CloneStorageEvent
(
eventType
aEvent
error
)
;
if
(
error
.
Failed
(
)
|
|
!
clonedEvent
)
{
return
;
}
clonedEvent
-
>
SetTrusted
(
true
)
;
if
(
fireMozStorageChanged
)
{
WidgetEvent
*
internalEvent
=
clonedEvent
-
>
WidgetEventPtr
(
)
;
internalEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
}
DispatchEvent
(
*
clonedEvent
)
;
}
already_AddRefed
<
StorageEvent
>
nsGlobalWindowInner
:
:
CloneStorageEvent
(
const
nsAString
&
aType
const
RefPtr
<
StorageEvent
>
&
aEvent
ErrorResult
&
aRv
)
{
StorageEventInit
dict
;
dict
.
mBubbles
=
aEvent
-
>
Bubbles
(
)
;
dict
.
mCancelable
=
aEvent
-
>
Cancelable
(
)
;
aEvent
-
>
GetKey
(
dict
.
mKey
)
;
aEvent
-
>
GetOldValue
(
dict
.
mOldValue
)
;
aEvent
-
>
GetNewValue
(
dict
.
mNewValue
)
;
aEvent
-
>
GetUrl
(
dict
.
mUrl
)
;
RefPtr
<
Storage
>
storageArea
=
aEvent
-
>
GetStorageArea
(
)
;
RefPtr
<
Storage
>
storage
;
if
(
!
storageArea
)
{
storage
=
GetLocalStorage
(
aRv
)
;
if
(
!
NextGenLocalStorageEnabled
(
)
)
{
if
(
aRv
.
Failed
(
)
|
|
!
storage
)
{
return
nullptr
;
}
if
(
storage
-
>
Type
(
)
=
=
Storage
:
:
eLocalStorage
)
{
RefPtr
<
LocalStorage
>
localStorage
=
static_cast
<
LocalStorage
*
>
(
storage
.
get
(
)
)
;
localStorage
-
>
ApplyEvent
(
aEvent
)
;
}
}
}
else
if
(
storageArea
-
>
Type
(
)
=
=
Storage
:
:
eSessionStorage
)
{
storage
=
GetSessionStorage
(
aRv
)
;
}
else
{
MOZ_ASSERT
(
storageArea
-
>
Type
(
)
=
=
Storage
:
:
eLocalStorage
)
;
storage
=
GetLocalStorage
(
aRv
)
;
}
if
(
aRv
.
Failed
(
)
|
|
!
storage
)
{
return
nullptr
;
}
if
(
storage
-
>
Type
(
)
=
=
Storage
:
:
ePartitionedLocalStorage
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
MOZ_ASSERT
(
storage
)
;
MOZ_ASSERT_IF
(
storageArea
storage
-
>
IsForkOf
(
storageArea
)
)
;
dict
.
mStorageArea
=
storage
;
RefPtr
<
StorageEvent
>
event
=
StorageEvent
:
:
Constructor
(
this
aType
dict
)
;
return
event
.
forget
(
)
;
}
void
nsGlobalWindowInner
:
:
Suspend
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
IsCurrentInnerWindow
(
)
)
{
return
;
}
CallOnChildren
(
&
nsGlobalWindowInner
:
:
Suspend
)
;
mSuspendDepth
+
=
1
;
if
(
mSuspendDepth
!
=
1
)
{
return
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
ac
-
>
RemoveWindowListener
(
mEnabledSensors
[
i
]
this
)
;
}
DisableGamepadUpdates
(
)
;
DisableVRUpdates
(
)
;
SuspendWorkersForWindow
(
this
)
;
nsTObserverArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SharedWorker
>
>
:
:
ForwardIterator
iter
(
mSharedWorkers
)
;
while
(
iter
.
HasMore
(
)
)
{
iter
.
GetNext
(
)
-
>
Suspend
(
)
;
}
SuspendIdleRequests
(
)
;
mTimeoutManager
-
>
Suspend
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
mAudioContexts
[
i
]
-
>
SuspendFromChrome
(
)
;
}
}
void
nsGlobalWindowInner
:
:
Resume
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
IsCurrentInnerWindow
(
)
)
{
return
;
}
CallOnChildren
(
&
nsGlobalWindowInner
:
:
Resume
)
;
MOZ_ASSERT
(
mSuspendDepth
!
=
0
)
;
mSuspendDepth
-
=
1
;
if
(
mSuspendDepth
!
=
0
)
{
return
;
}
MOZ_ASSERT
(
mFreezeDepth
=
=
0
)
;
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
ac
-
>
AddWindowListener
(
mEnabledSensors
[
i
]
this
)
;
}
EnableGamepadUpdates
(
)
;
EnableVRUpdates
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mAudioContexts
.
Length
(
)
;
+
+
i
)
{
mAudioContexts
[
i
]
-
>
ResumeFromChrome
(
)
;
}
mTimeoutManager
-
>
Resume
(
)
;
ResumeIdleRequests
(
)
;
ResumeWorkersForWindow
(
this
)
;
nsTObserverArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SharedWorker
>
>
:
:
ForwardIterator
iter
(
mSharedWorkers
)
;
while
(
iter
.
HasMore
(
)
)
{
iter
.
GetNext
(
)
-
>
Resume
(
)
;
}
}
bool
nsGlobalWindowInner
:
:
IsSuspended
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
mSuspendDepth
!
=
0
;
}
void
nsGlobalWindowInner
:
:
Freeze
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Suspend
(
)
;
FreezeInternal
(
)
;
}
void
nsGlobalWindowInner
:
:
FreezeInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsCurrentInnerWindow
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsSuspended
(
)
)
;
CallOnChildren
(
&
nsGlobalWindowInner
:
:
FreezeInternal
)
;
mFreezeDepth
+
=
1
;
MOZ_ASSERT
(
mSuspendDepth
>
=
mFreezeDepth
)
;
if
(
mFreezeDepth
!
=
1
)
{
return
;
}
FreezeWorkersForWindow
(
this
)
;
nsTObserverArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SharedWorker
>
>
:
:
ForwardIterator
iter
(
mSharedWorkers
)
;
while
(
iter
.
HasMore
(
)
)
{
iter
.
GetNext
(
)
-
>
Freeze
(
)
;
}
mTimeoutManager
-
>
Freeze
(
)
;
if
(
mClientSource
)
{
mClientSource
-
>
Freeze
(
)
;
}
NotifyDOMWindowFrozen
(
this
)
;
}
void
nsGlobalWindowInner
:
:
Thaw
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
ThawInternal
(
)
;
Resume
(
)
;
}
void
nsGlobalWindowInner
:
:
ThawInternal
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsCurrentInnerWindow
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsSuspended
(
)
)
;
CallOnChildren
(
&
nsGlobalWindowInner
:
:
ThawInternal
)
;
MOZ_ASSERT
(
mFreezeDepth
!
=
0
)
;
mFreezeDepth
-
=
1
;
MOZ_ASSERT
(
mSuspendDepth
>
=
mFreezeDepth
)
;
if
(
mFreezeDepth
!
=
0
)
{
return
;
}
if
(
mClientSource
)
{
mClientSource
-
>
Thaw
(
)
;
}
mTimeoutManager
-
>
Thaw
(
)
;
ThawWorkersForWindow
(
this
)
;
nsTObserverArray
<
RefPtr
<
mozilla
:
:
dom
:
:
SharedWorker
>
>
:
:
ForwardIterator
iter
(
mSharedWorkers
)
;
while
(
iter
.
HasMore
(
)
)
{
iter
.
GetNext
(
)
-
>
Thaw
(
)
;
}
NotifyDOMWindowThawed
(
this
)
;
}
bool
nsGlobalWindowInner
:
:
IsFrozen
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
bool
frozen
=
mFreezeDepth
!
=
0
;
MOZ_ASSERT_IF
(
frozen
IsSuspended
(
)
)
;
return
frozen
;
}
void
nsGlobalWindowInner
:
:
SyncStateFromParentWindow
(
)
{
MOZ_ASSERT
(
IsCurrentInnerWindow
(
)
)
;
nsPIDOMWindowOuter
*
outer
=
GetOuterWindow
(
)
;
MOZ_ASSERT
(
outer
)
;
nsCOMPtr
<
Element
>
frame
=
outer
-
>
GetFrameElementInternal
(
)
;
nsPIDOMWindowOuter
*
parentOuter
=
frame
?
frame
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
:
nullptr
;
nsGlobalWindowInner
*
parentInner
=
parentOuter
?
nsGlobalWindowInner
:
:
Cast
(
parentOuter
-
>
GetCurrentInnerWindow
(
)
)
:
nullptr
;
if
(
(
!
parentInner
|
|
!
parentInner
-
>
IsInModalState
(
)
)
&
&
IsInModalState
(
)
)
{
Suspend
(
)
;
}
uint32_t
parentFreezeDepth
=
parentInner
?
parentInner
-
>
mFreezeDepth
:
0
;
uint32_t
parentSuspendDepth
=
parentInner
?
parentInner
-
>
mSuspendDepth
:
0
;
MOZ_ASSERT
(
parentFreezeDepth
<
=
parentSuspendDepth
)
;
for
(
uint32_t
i
=
0
;
i
<
parentFreezeDepth
;
+
+
i
)
{
Freeze
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
(
parentSuspendDepth
-
parentFreezeDepth
)
;
+
+
i
)
{
Suspend
(
)
;
}
}
template
<
typename
Method
typename
.
.
.
Args
>
nsGlobalWindowInner
:
:
CallState
nsGlobalWindowInner
:
:
CallOnChildren
(
Method
aMethod
Args
&
.
.
.
aArgs
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
IsCurrentInnerWindow
(
)
)
;
CallState
state
=
CallState
:
:
Continue
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
state
;
}
int32_t
childCount
=
0
;
docShell
-
>
GetInProcessChildCount
(
&
childCount
)
;
AutoTArray
<
nsCOMPtr
<
nsIDocShellTreeItem
>
8
>
children
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
;
docShell
-
>
GetInProcessChildAt
(
i
getter_AddRefs
(
childShell
)
)
;
if
(
childShell
)
{
children
.
AppendElement
(
childShell
)
;
}
}
for
(
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
:
children
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
pWin
=
childShell
-
>
GetWindow
(
)
;
if
(
!
pWin
)
{
continue
;
}
auto
*
win
=
nsGlobalWindowOuter
:
:
Cast
(
pWin
)
;
nsGlobalWindowInner
*
inner
=
win
-
>
GetCurrentInnerWindowInternal
(
)
;
nsCOMPtr
<
Element
>
frame
=
pWin
-
>
GetFrameElementInternal
(
)
;
if
(
!
mDoc
|
|
!
frame
|
|
mDoc
!
=
frame
-
>
OwnerDoc
(
)
|
|
!
inner
)
{
continue
;
}
typedef
decltype
(
(
inner
-
>
*
aMethod
)
(
aArgs
.
.
.
)
)
returnType
;
state
=
CallChild
<
returnType
>
(
inner
aMethod
aArgs
.
.
.
)
;
if
(
state
=
=
CallState
:
:
Stop
)
{
return
state
;
}
}
return
state
;
}
Maybe
<
ClientInfo
>
nsGlobalWindowInner
:
:
GetClientInfo
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
ClientInfo
>
clientInfo
;
if
(
mClientSource
)
{
clientInfo
.
emplace
(
mClientSource
-
>
Info
(
)
)
;
}
return
clientInfo
;
}
Maybe
<
ClientState
>
nsGlobalWindowInner
:
:
GetClientState
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
ClientState
>
clientState
;
if
(
mClientSource
)
{
ClientState
state
;
nsresult
rv
=
mClientSource
-
>
SnapshotState
(
&
state
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
clientState
.
emplace
(
state
)
;
}
}
return
clientState
;
}
Maybe
<
ServiceWorkerDescriptor
>
nsGlobalWindowInner
:
:
GetController
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
Maybe
<
ServiceWorkerDescriptor
>
controller
;
if
(
mClientSource
)
{
controller
=
mClientSource
-
>
GetController
(
)
;
}
return
controller
;
}
void
nsGlobalWindowInner
:
:
SetCsp
(
nsIContentSecurityPolicy
*
aCsp
)
{
if
(
!
mClientSource
)
{
return
;
}
mClientSource
-
>
SetCsp
(
aCsp
)
;
mDoc
-
>
SetCsp
(
aCsp
)
;
}
void
nsGlobalWindowInner
:
:
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCsp
)
{
if
(
!
mClientSource
)
{
return
;
}
mClientSource
-
>
SetPreloadCsp
(
aPreloadCsp
)
;
mDoc
-
>
SetPreloadCsp
(
aPreloadCsp
)
;
}
nsIContentSecurityPolicy
*
nsGlobalWindowInner
:
:
GetCsp
(
)
{
if
(
mDoc
)
{
return
mDoc
-
>
GetCsp
(
)
;
}
if
(
mDocumentCsp
)
{
return
mDocumentCsp
;
}
return
nullptr
;
}
RefPtr
<
ServiceWorker
>
nsGlobalWindowInner
:
:
GetOrCreateServiceWorker
(
const
ServiceWorkerDescriptor
&
aDescriptor
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ServiceWorker
>
ref
;
ForEachEventTargetObject
(
[
&
]
(
DOMEventTargetHelper
*
aTarget
bool
*
aDoneOut
)
{
RefPtr
<
ServiceWorker
>
sw
=
do_QueryObject
(
aTarget
)
;
if
(
!
sw
|
|
!
sw
-
>
Descriptor
(
)
.
Matches
(
aDescriptor
)
)
{
return
;
}
ref
=
sw
.
forget
(
)
;
*
aDoneOut
=
true
;
}
)
;
if
(
!
ref
)
{
ref
=
ServiceWorker
:
:
Create
(
this
aDescriptor
)
;
}
return
ref
.
forget
(
)
;
}
RefPtr
<
mozilla
:
:
dom
:
:
ServiceWorkerRegistration
>
nsGlobalWindowInner
:
:
GetServiceWorkerRegistration
(
const
mozilla
:
:
dom
:
:
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ServiceWorkerRegistration
>
ref
;
ForEachEventTargetObject
(
[
&
]
(
DOMEventTargetHelper
*
aTarget
bool
*
aDoneOut
)
{
RefPtr
<
ServiceWorkerRegistration
>
swr
=
do_QueryObject
(
aTarget
)
;
if
(
!
swr
|
|
!
swr
-
>
MatchesDescriptor
(
aDescriptor
)
)
{
return
;
}
ref
=
swr
.
forget
(
)
;
*
aDoneOut
=
true
;
}
)
;
return
ref
.
forget
(
)
;
}
RefPtr
<
ServiceWorkerRegistration
>
nsGlobalWindowInner
:
:
GetOrCreateServiceWorkerRegistration
(
const
ServiceWorkerRegistrationDescriptor
&
aDescriptor
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
ServiceWorkerRegistration
>
ref
=
GetServiceWorkerRegistration
(
aDescriptor
)
;
if
(
!
ref
)
{
ref
=
ServiceWorkerRegistration
:
:
CreateForMainThread
(
this
aDescriptor
)
;
}
return
ref
.
forget
(
)
;
}
nsresult
nsGlobalWindowInner
:
:
FireDelayedDOMEvents
(
)
{
if
(
mApplicationCache
)
{
static_cast
<
nsDOMOfflineResourceList
*
>
(
mApplicationCache
.
get
(
)
)
-
>
FirePendingEvents
(
)
;
}
FireOfflineStatusEventIfChanged
(
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
int32_t
childCount
=
0
;
docShell
-
>
GetInProcessChildCount
(
&
childCount
)
;
AutoTArray
<
nsCOMPtr
<
nsIDocShellTreeItem
>
8
>
children
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
;
docShell
-
>
GetInProcessChildAt
(
i
getter_AddRefs
(
childShell
)
)
;
if
(
childShell
)
{
children
.
AppendElement
(
childShell
)
;
}
}
for
(
nsCOMPtr
<
nsIDocShellTreeItem
>
childShell
:
children
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
pWin
=
childShell
-
>
GetWindow
(
)
)
{
auto
*
win
=
nsGlobalWindowOuter
:
:
Cast
(
pWin
)
;
win
-
>
FireDelayedDOMEvents
(
)
;
}
}
}
return
NS_OK
;
}
nsPIDOMWindowOuter
*
nsGlobalWindowInner
:
:
GetInProcessParentInternal
(
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
)
{
return
nullptr
;
}
return
outer
-
>
GetInProcessParentInternal
(
)
;
}
nsIPrincipal
*
nsGlobalWindowInner
:
:
GetTopLevelAntiTrackingPrincipal
(
)
{
nsPIDOMWindowOuter
*
outerWindow
=
GetOuterWindowInternal
(
)
;
if
(
!
outerWindow
)
{
return
nullptr
;
}
nsPIDOMWindowOuter
*
topLevelOuterWindow
=
GetBrowsingContext
(
)
-
>
Top
(
)
-
>
GetDOMWindow
(
)
;
if
(
!
topLevelOuterWindow
)
{
return
nullptr
;
}
bool
stopAtOurLevel
=
mDoc
&
&
mDoc
-
>
CookieSettings
(
)
-
>
GetCookieBehavior
(
)
=
=
nsICookieService
:
:
BEHAVIOR_REJECT_TRACKER
;
if
(
stopAtOurLevel
&
&
topLevelOuterWindow
=
=
outerWindow
)
{
return
nullptr
;
}
nsPIDOMWindowInner
*
topLevelInnerWindow
=
topLevelOuterWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
topLevelInnerWindow
)
)
{
return
nullptr
;
}
nsIPrincipal
*
topLevelPrincipal
=
nsGlobalWindowInner
:
:
Cast
(
topLevelInnerWindow
)
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
topLevelPrincipal
)
)
{
return
nullptr
;
}
return
topLevelPrincipal
;
}
nsIPrincipal
*
nsGlobalWindowInner
:
:
GetTopLevelStorageAreaPrincipal
(
)
{
if
(
mDoc
&
&
(
mDoc
-
>
StorageAccessSandboxed
(
)
)
)
{
return
nullptr
;
}
BrowsingContext
*
parent
=
GetBrowsingContext
(
)
-
>
GetParent
(
)
;
nsPIDOMWindowOuter
*
outerWindow
=
parent
?
parent
-
>
GetDOMWindow
(
)
:
nullptr
;
if
(
!
outerWindow
)
{
return
nullptr
;
}
if
(
!
outerWindow
-
>
IsTopLevelWindow
(
)
)
{
return
nullptr
;
}
nsPIDOMWindowInner
*
innerWindow
=
outerWindow
-
>
GetCurrentInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
innerWindow
)
)
{
return
nullptr
;
}
nsIPrincipal
*
parentPrincipal
=
nsGlobalWindowInner
:
:
Cast
(
innerWindow
)
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
parentPrincipal
)
)
{
return
nullptr
;
}
return
parentPrincipal
;
}
class
WindowScriptTimeoutHandler
final
:
public
ScriptTimeoutHandler
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
WindowScriptTimeoutHandler
ScriptTimeoutHandler
)
WindowScriptTimeoutHandler
(
JSContext
*
aCx
nsIGlobalObject
*
aGlobal
const
nsAString
&
aExpression
)
:
ScriptTimeoutHandler
(
aCx
aGlobal
aExpression
)
mInitiatingScript
(
ScriptLoader
:
:
GetActiveScript
(
aCx
)
)
{
}
MOZ_CAN_RUN_SCRIPT
virtual
bool
Call
(
const
char
*
aExecutionReason
)
override
;
private
:
virtual
~
WindowScriptTimeoutHandler
(
)
{
}
RefPtr
<
LoadedScript
>
mInitiatingScript
;
}
;
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
WindowScriptTimeoutHandler
ScriptTimeoutHandler
mInitiatingScript
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
WindowScriptTimeoutHandler
)
NS_INTERFACE_MAP_END_INHERITING
(
ScriptTimeoutHandler
)
NS_IMPL_ADDREF_INHERITED
(
WindowScriptTimeoutHandler
ScriptTimeoutHandler
)
NS_IMPL_RELEASE_INHERITED
(
WindowScriptTimeoutHandler
ScriptTimeoutHandler
)
bool
WindowScriptTimeoutHandler
:
:
Call
(
const
char
*
aExecutionReason
)
{
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
mGlobal
aExecutionReason
true
)
;
JS
:
:
CompileOptions
options
(
aes
.
cx
(
)
)
;
options
.
setFileAndLine
(
mFileName
.
get
(
)
mLineNo
)
;
options
.
setNoScriptRval
(
true
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aes
.
cx
(
)
mGlobal
-
>
GetGlobalJSObject
(
)
)
;
{
nsJSUtils
:
:
ExecutionContext
exec
(
aes
.
cx
(
)
global
)
;
nsresult
rv
=
exec
.
Compile
(
options
mExpr
)
;
JS
:
:
Rooted
<
JSScript
*
>
script
(
aes
.
cx
(
)
exec
.
MaybeGetScript
(
)
)
;
if
(
script
)
{
if
(
mInitiatingScript
)
{
mInitiatingScript
-
>
AssociateWithScript
(
script
)
;
}
rv
=
exec
.
ExecScript
(
)
;
}
if
(
rv
=
=
NS_SUCCESS_DOM_SCRIPT_EVALUATION_THREW_UNCATCHABLE
)
{
return
false
;
}
}
return
true
;
}
;
nsGlobalWindowInner
*
nsGlobalWindowInner
:
:
InnerForSetTimeoutOrInterval
(
ErrorResult
&
aError
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
nsGlobalWindowInner
*
currentInner
=
outer
?
outer
-
>
GetCurrentInnerWindowInternal
(
)
:
this
;
return
HasActiveDocument
(
)
?
currentInner
:
nullptr
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeout
(
JSContext
*
aCx
Function
&
aFunction
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
aArguments
ErrorResult
&
aError
)
{
return
SetTimeoutOrInterval
(
aCx
aFunction
aTimeout
aArguments
false
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeout
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
ErrorResult
&
aError
)
{
return
SetTimeoutOrInterval
(
aCx
aHandler
aTimeout
false
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetInterval
(
JSContext
*
aCx
Function
&
aFunction
const
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
aArguments
ErrorResult
&
aError
)
{
return
SetTimeoutOrInterval
(
aCx
aFunction
aTimeout
aArguments
true
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
const
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
ErrorResult
&
aError
)
{
return
SetTimeoutOrInterval
(
aCx
aHandler
aTimeout
true
aError
)
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeoutOrInterval
(
JSContext
*
aCx
Function
&
aFunction
int32_t
aTimeout
const
Sequence
<
JS
:
:
Value
>
&
aArguments
bool
aIsInterval
ErrorResult
&
aError
)
{
nsGlobalWindowInner
*
inner
=
InnerForSetTimeoutOrInterval
(
aError
)
;
if
(
!
inner
)
{
return
-
1
;
}
if
(
inner
!
=
this
)
{
RefPtr
<
nsGlobalWindowInner
>
innerRef
(
inner
)
;
return
innerRef
-
>
SetTimeoutOrInterval
(
aCx
aFunction
aTimeout
aArguments
aIsInterval
aError
)
;
}
DebuggerNotificationDispatch
(
this
aIsInterval
?
DebuggerNotificationType
:
:
SetInterval
:
DebuggerNotificationType
:
:
SetTimeout
)
;
if
(
!
GetContextInternal
(
)
|
|
!
HasJSGlobal
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
nsTArray
<
JS
:
:
Heap
<
JS
:
:
Value
>
>
args
;
if
(
!
args
.
AppendElements
(
aArguments
fallible
)
)
{
aError
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
0
;
}
RefPtr
<
TimeoutHandler
>
handler
=
new
CallbackTimeoutHandler
(
aCx
this
&
aFunction
std
:
:
move
(
args
)
)
;
int32_t
result
;
aError
=
mTimeoutManager
-
>
SetTimeout
(
handler
aTimeout
aIsInterval
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
&
result
)
;
return
result
;
}
int32_t
nsGlobalWindowInner
:
:
SetTimeoutOrInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
bool
aIsInterval
ErrorResult
&
aError
)
{
nsGlobalWindowInner
*
inner
=
InnerForSetTimeoutOrInterval
(
aError
)
;
if
(
!
inner
)
{
return
-
1
;
}
if
(
inner
!
=
this
)
{
RefPtr
<
nsGlobalWindowInner
>
innerRef
(
inner
)
;
return
innerRef
-
>
SetTimeoutOrInterval
(
aCx
aHandler
aTimeout
aIsInterval
aError
)
;
}
DebuggerNotificationDispatch
(
this
aIsInterval
?
DebuggerNotificationType
:
:
SetInterval
:
DebuggerNotificationType
:
:
SetTimeout
)
;
if
(
!
GetContextInternal
(
)
|
|
!
HasJSGlobal
(
)
)
{
aError
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
bool
allowEval
=
false
;
aError
=
CSPEvalChecker
:
:
CheckForWindow
(
aCx
this
aHandler
&
allowEval
)
;
if
(
NS_WARN_IF
(
aError
.
Failed
(
)
)
|
|
!
allowEval
)
{
return
0
;
}
RefPtr
<
TimeoutHandler
>
handler
=
new
WindowScriptTimeoutHandler
(
aCx
this
aHandler
)
;
int32_t
result
;
aError
=
mTimeoutManager
-
>
SetTimeout
(
handler
aTimeout
aIsInterval
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
&
result
)
;
return
result
;
}
static
const
char
*
GetTimeoutReasonString
(
Timeout
*
aTimeout
)
{
switch
(
aTimeout
-
>
mReason
)
{
case
Timeout
:
:
Reason
:
:
eTimeoutOrInterval
:
if
(
aTimeout
-
>
mIsInterval
)
{
return
"
setInterval
handler
"
;
}
return
"
setTimeout
handler
"
;
case
Timeout
:
:
Reason
:
:
eIdleCallbackTimeout
:
return
"
setIdleCallback
handler
(
timed
out
)
"
;
default
:
MOZ_CRASH
(
"
Unexpected
enum
value
"
)
;
return
"
"
;
}
}
bool
nsGlobalWindowInner
:
:
RunTimeoutHandler
(
Timeout
*
aTimeout
nsIScriptContext
*
aScx
)
{
RefPtr
<
Timeout
>
timeout
=
aTimeout
;
Timeout
*
last_running_timeout
=
mTimeoutManager
-
>
BeginRunningTimeout
(
timeout
)
;
timeout
-
>
mRunning
=
true
;
AutoPopupStatePusher
popupStatePusher
(
timeout
-
>
mPopupState
)
;
timeout
-
>
mPopupState
=
PopupBlocker
:
:
openAbused
;
bool
trackNestingLevel
=
!
timeout
-
>
mIsInterval
;
uint32_t
nestingLevel
;
if
(
trackNestingLevel
)
{
nestingLevel
=
TimeoutManager
:
:
GetNestingLevel
(
)
;
TimeoutManager
:
:
SetNestingLevel
(
timeout
-
>
mNestingLevel
)
;
}
const
char
*
reason
=
GetTimeoutReasonString
(
timeout
)
;
#
ifdef
MOZ_GECKO_PROFILER
if
(
profiler_can_accept_markers
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
GetDocShell
(
)
;
nsCString
str
;
TimeDuration
originalInterval
=
timeout
-
>
When
(
)
-
timeout
-
>
SubmitTime
(
)
;
str
.
Append
(
reason
)
;
str
.
Append
(
"
with
interval
"
)
;
str
.
AppendInt
(
int
(
originalInterval
.
ToMilliseconds
(
)
)
)
;
str
.
Append
(
"
ms
:
"
)
;
nsCString
handlerDescription
;
timeout
-
>
mScriptHandler
-
>
GetDescription
(
handlerDescription
)
;
str
.
Append
(
handlerDescription
)
;
AUTO_PROFILER_TEXT_MARKER_DOCSHELL_CAUSE
(
"
setTimeout
callback
"
str
JS
docShell
timeout
-
>
TakeProfilerBacktrace
(
)
)
;
}
#
endif
bool
abortIntervalHandler
;
{
RefPtr
<
TimeoutHandler
>
handler
(
timeout
-
>
mScriptHandler
)
;
CallbackDebuggerNotificationGuard
guard
(
this
timeout
-
>
mIsInterval
?
DebuggerNotificationType
:
:
SetIntervalCallback
:
DebuggerNotificationType
:
:
SetTimeoutCallback
)
;
abortIntervalHandler
=
!
handler
-
>
Call
(
reason
)
;
}
if
(
abortIntervalHandler
)
{
timeout
-
>
mIsInterval
=
false
;
}
if
(
trackNestingLevel
)
{
TimeoutManager
:
:
SetNestingLevel
(
nestingLevel
)
;
}
mTimeoutManager
-
>
EndRunningTimeout
(
last_running_timeout
)
;
timeout
-
>
mRunning
=
false
;
return
timeout
-
>
mCleared
;
}
already_AddRefed
<
nsIDocShellTreeOwner
>
nsGlobalWindowInner
:
:
GetTreeOwner
(
)
{
FORWARD_TO_OUTER
(
GetTreeOwner
(
)
nullptr
)
;
}
already_AddRefed
<
nsIWebBrowserChrome
>
nsGlobalWindowInner
:
:
GetWebBrowserChrome
(
)
{
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
=
GetTreeOwner
(
)
;
nsCOMPtr
<
nsIWebBrowserChrome
>
browserChrome
=
do_GetInterface
(
treeOwner
)
;
return
browserChrome
.
forget
(
)
;
}
nsIScrollableFrame
*
nsGlobalWindowInner
:
:
GetScrollFrame
(
)
{
FORWARD_TO_OUTER
(
GetScrollFrame
(
)
nullptr
)
;
}
bool
nsGlobalWindowInner
:
:
IsPrivateBrowsing
(
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_QueryInterface
(
GetDocShell
(
)
)
;
return
loadContext
&
&
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
void
nsGlobalWindowInner
:
:
FlushPendingNotifications
(
FlushType
aType
)
{
if
(
mDoc
)
{
mDoc
-
>
FlushPendingNotifications
(
aType
)
;
}
}
void
nsGlobalWindowInner
:
:
EnableDeviceSensor
(
uint32_t
aType
)
{
bool
alreadyEnabled
=
false
;
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
{
if
(
mEnabledSensors
[
i
]
=
=
aType
)
{
alreadyEnabled
=
true
;
break
;
}
}
mEnabledSensors
.
AppendElement
(
aType
)
;
if
(
alreadyEnabled
)
{
return
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
ac
-
>
AddWindowListener
(
aType
this
)
;
}
}
void
nsGlobalWindowInner
:
:
DisableDeviceSensor
(
uint32_t
aType
)
{
int32_t
doomedElement
=
-
1
;
int32_t
listenerCount
=
0
;
for
(
uint32_t
i
=
0
;
i
<
mEnabledSensors
.
Length
(
)
;
i
+
+
)
{
if
(
mEnabledSensors
[
i
]
=
=
aType
)
{
doomedElement
=
i
;
listenerCount
+
+
;
}
}
if
(
doomedElement
=
=
-
1
)
{
return
;
}
mEnabledSensors
.
RemoveElementAt
(
doomedElement
)
;
if
(
listenerCount
>
1
)
{
return
;
}
nsCOMPtr
<
nsIDeviceSensors
>
ac
=
do_GetService
(
NS_DEVICE_SENSORS_CONTRACTID
)
;
if
(
ac
)
{
ac
-
>
RemoveWindowListener
(
aType
this
)
;
}
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
nsGlobalWindowInner
:
:
EnableOrientationChangeListener
(
)
{
if
(
!
nsContentUtils
:
:
ShouldResistFingerprinting
(
GetDocShell
(
)
)
&
&
!
mOrientationChangeObserver
)
{
mOrientationChangeObserver
=
MakeUnique
<
WindowOrientationObserver
>
(
this
)
;
}
}
void
nsGlobalWindowInner
:
:
DisableOrientationChangeListener
(
)
{
mOrientationChangeObserver
=
nullptr
;
}
#
endif
void
nsGlobalWindowInner
:
:
SetHasGamepadEventListener
(
bool
aHasGamepad
)
{
mHasGamepad
=
aHasGamepad
;
if
(
aHasGamepad
)
{
EnableGamepadUpdates
(
)
;
}
}
void
nsGlobalWindowInner
:
:
EventListenerAdded
(
nsAtom
*
aType
)
{
if
(
aType
=
=
nsGkAtoms
:
:
onvrdisplayactivate
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplayconnect
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplaydeactivate
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplaydisconnect
|
|
aType
=
=
nsGkAtoms
:
:
onvrdisplaypresentchange
)
{
NotifyVREventListenerAdded
(
)
;
}
if
(
aType
=
=
nsGkAtoms
:
:
onvrdisplayactivate
)
{
mHasVRDisplayActivateEvents
=
true
;
}
if
(
aType
=
=
nsGkAtoms
:
:
onbeforeunload
&
&
mWindowGlobalChild
&
&
(
!
mDoc
|
|
!
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
)
)
{
mWindowGlobalChild
-
>
BeforeUnloadAdded
(
)
;
MOZ_ASSERT
(
mWindowGlobalChild
-
>
BeforeUnloadListeners
(
)
>
0
)
;
}
if
(
aType
=
=
nsGkAtoms
:
:
onstorage
)
{
ErrorResult
rv
;
GetLocalStorage
(
rv
)
;
rv
.
SuppressException
(
)
;
if
(
NextGenLocalStorageEnabled
(
)
&
&
mLocalStorage
&
&
mLocalStorage
-
>
Type
(
)
=
=
Storage
:
:
eLocalStorage
)
{
auto
object
=
static_cast
<
LSObject
*
>
(
mLocalStorage
.
get
(
)
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
object
-
>
EnsureObserver
(
)
)
)
;
}
}
}
void
nsGlobalWindowInner
:
:
EventListenerRemoved
(
nsAtom
*
aType
)
{
if
(
aType
=
=
nsGkAtoms
:
:
onbeforeunload
&
&
mWindowGlobalChild
&
&
(
!
mDoc
|
|
!
(
mDoc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
)
)
{
mWindowGlobalChild
-
>
BeforeUnloadRemoved
(
)
;
MOZ_ASSERT
(
mWindowGlobalChild
-
>
BeforeUnloadListeners
(
)
>
=
0
)
;
}
if
(
aType
=
=
nsGkAtoms
:
:
onstorage
)
{
if
(
NextGenLocalStorageEnabled
(
)
&
&
mLocalStorage
&
&
mLocalStorage
-
>
Type
(
)
=
=
Storage
:
:
eLocalStorage
&
&
mListenerManager
&
&
!
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onstorage
)
)
{
auto
object
=
static_cast
<
LSObject
*
>
(
mLocalStorage
.
get
(
)
)
;
object
-
>
DropObserver
(
)
;
}
}
}
void
nsGlobalWindowInner
:
:
NotifyVREventListenerAdded
(
)
{
mHasVREvents
=
true
;
EnableVRUpdates
(
)
;
}
bool
nsGlobalWindowInner
:
:
HasUsedVR
(
)
const
{
return
mHasVREvents
;
}
bool
nsGlobalWindowInner
:
:
IsVRContentDetected
(
)
const
{
return
mHasVRDisplayActivateEvents
;
}
bool
nsGlobalWindowInner
:
:
IsVRContentPresenting
(
)
const
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
IsAnyPresenting
(
gfx
:
:
kVRGroupAll
)
)
{
return
true
;
}
}
return
false
;
}
void
nsGlobalWindowInner
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
aWindowSizes
.
mDOMOtherSize
+
=
aWindowSizes
.
mState
.
mMallocSizeOf
(
this
)
;
aWindowSizes
.
mDOMOtherSize
+
=
nsIGlobalObject
:
:
ShallowSizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
if
(
elm
)
{
aWindowSizes
.
mDOMOtherSize
+
=
elm
-
>
SizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
if
(
mDoc
)
{
if
(
!
mDoc
-
>
GetInnerWindow
(
)
|
|
mDoc
-
>
GetInnerWindow
(
)
=
=
this
)
{
mDoc
-
>
DocAddSizeOfIncludingThis
(
aWindowSizes
)
;
}
}
if
(
mNavigator
)
{
aWindowSizes
.
mDOMOtherSize
+
=
mNavigator
-
>
SizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
ForEachEventTargetObject
(
[
&
]
(
DOMEventTargetHelper
*
et
bool
*
aDoneOut
)
{
if
(
nsCOMPtr
<
nsISizeOfEventTarget
>
iSizeOf
=
do_QueryObject
(
et
)
)
{
aWindowSizes
.
mDOMEventTargetsSize
+
=
iSizeOf
-
>
SizeOfEventTargetIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
if
(
EventListenerManager
*
elm
=
et
-
>
GetExistingListenerManager
(
)
)
{
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
+
+
aWindowSizes
.
mDOMEventTargetsCount
;
}
)
;
if
(
mPerformance
)
{
aWindowSizes
.
mDOMPerformanceUserEntries
=
mPerformance
-
>
SizeOfUserEntries
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
aWindowSizes
.
mDOMPerformanceResourceEntries
=
mPerformance
-
>
SizeOfResourceEntries
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
aWindowSizes
.
mDOMOtherSize
+
=
mPendingPromises
.
ShallowSizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
void
nsGlobalWindowInner
:
:
AddGamepad
(
uint32_t
aIndex
Gamepad
*
aGamepad
)
{
int
index
=
0
;
while
(
mGamepadIndexSet
.
Contains
(
index
)
)
{
+
+
index
;
}
mGamepadIndexSet
.
Put
(
index
)
;
aGamepad
-
>
SetIndex
(
index
)
;
mGamepads
.
Put
(
aIndex
aGamepad
)
;
}
void
nsGlobalWindowInner
:
:
RemoveGamepad
(
uint32_t
aIndex
)
{
RefPtr
<
Gamepad
>
gamepad
;
if
(
!
mGamepads
.
Get
(
aIndex
getter_AddRefs
(
gamepad
)
)
)
{
return
;
}
mGamepadIndexSet
.
Remove
(
gamepad
-
>
Index
(
)
)
;
mGamepads
.
Remove
(
aIndex
)
;
}
void
nsGlobalWindowInner
:
:
GetGamepads
(
nsTArray
<
RefPtr
<
Gamepad
>
>
&
aGamepads
)
{
aGamepads
.
Clear
(
)
;
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
GetDocShell
(
)
)
)
{
return
;
}
aGamepads
.
SetCapacity
(
mGamepads
.
Count
(
)
)
;
for
(
auto
iter
=
mGamepads
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Gamepad
*
gamepad
=
iter
.
UserData
(
)
;
aGamepads
.
EnsureLengthAtLeast
(
gamepad
-
>
Index
(
)
+
1
)
;
aGamepads
[
gamepad
-
>
Index
(
)
]
=
gamepad
;
}
}
already_AddRefed
<
Gamepad
>
nsGlobalWindowInner
:
:
GetGamepad
(
uint32_t
aIndex
)
{
RefPtr
<
Gamepad
>
gamepad
;
if
(
mGamepads
.
Get
(
aIndex
getter_AddRefs
(
gamepad
)
)
)
{
return
gamepad
.
forget
(
)
;
}
return
nullptr
;
}
void
nsGlobalWindowInner
:
:
SetHasSeenGamepadInput
(
bool
aHasSeen
)
{
mHasSeenGamepadInput
=
aHasSeen
;
}
bool
nsGlobalWindowInner
:
:
HasSeenGamepadInput
(
)
{
return
mHasSeenGamepadInput
;
}
void
nsGlobalWindowInner
:
:
SyncGamepadState
(
)
{
if
(
mHasSeenGamepadInput
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
for
(
auto
iter
=
mGamepads
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
gamepadManager
-
>
SyncGamepadState
(
iter
.
Key
(
)
this
iter
.
UserData
(
)
)
;
}
}
}
void
nsGlobalWindowInner
:
:
StopGamepadHaptics
(
)
{
if
(
mHasSeenGamepadInput
)
{
RefPtr
<
GamepadManager
>
gamepadManager
(
GamepadManager
:
:
GetService
(
)
)
;
gamepadManager
-
>
StopHaptics
(
)
;
}
}
bool
nsGlobalWindowInner
:
:
UpdateVRDisplays
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
VRDisplay
>
>
&
aDevices
)
{
VRDisplay
:
:
UpdateVRDisplays
(
mVRDisplays
this
)
;
aDevices
=
mVRDisplays
;
return
true
;
}
void
nsGlobalWindowInner
:
:
NotifyActiveVRDisplaysChanged
(
)
{
if
(
mNavigator
)
{
mNavigator
-
>
NotifyActiveVRDisplaysChanged
(
)
;
}
}
void
nsGlobalWindowInner
:
:
NotifyPresentationGenerationChanged
(
uint32_t
aDisplayID
)
{
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
display
-
>
OnPresentationGenerationChanged
(
)
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayActivate
(
uint32_t
aDisplayID
mozilla
:
:
dom
:
:
VRDisplayEventReason
aReason
)
{
VRDisplay
:
:
UpdateVRDisplays
(
mVRDisplays
this
)
;
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
if
(
aReason
!
=
VRDisplayEventReason
:
:
Navigation
&
&
display
-
>
IsAnyPresenting
(
gfx
:
:
kVRGroupContent
)
)
{
continue
;
}
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
init
.
mReason
.
Construct
(
aReason
)
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplayactivate
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
display
-
>
StartHandlingVRNavigationEvent
(
)
;
DispatchEvent
(
*
event
)
;
display
-
>
StopHandlingVRNavigationEvent
(
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayDeactivate
(
uint32_t
aDisplayID
mozilla
:
:
dom
:
:
VRDisplayEventReason
aReason
)
{
VRDisplay
:
:
UpdateVRDisplays
(
mVRDisplays
this
)
;
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
&
&
display
-
>
IsPresenting
(
)
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
init
.
mReason
.
Construct
(
aReason
)
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplaydeactivate
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchEvent
(
*
event
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayConnect
(
uint32_t
aDisplayID
)
{
VRDisplay
:
:
UpdateVRDisplays
(
mVRDisplays
this
)
;
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplayconnect
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchEvent
(
*
event
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayDisconnect
(
uint32_t
aDisplayID
)
{
VRDisplay
:
:
UpdateVRDisplays
(
mVRDisplays
this
)
;
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplaydisconnect
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchEvent
(
*
event
)
;
return
;
}
}
}
void
nsGlobalWindowInner
:
:
DispatchVRDisplayPresentChange
(
uint32_t
aDisplayID
)
{
VRDisplay
:
:
UpdateVRDisplays
(
mVRDisplays
this
)
;
for
(
const
auto
&
display
:
mVRDisplays
)
{
if
(
display
-
>
DisplayId
(
)
=
=
aDisplayID
)
{
VRDisplayEventInit
init
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mDisplay
=
display
;
RefPtr
<
VRDisplayEvent
>
event
=
VRDisplayEvent
:
:
Constructor
(
this
NS_LITERAL_STRING
(
"
vrdisplaypresentchange
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
DispatchEvent
(
*
event
)
;
return
;
}
}
}
enum
WindowState
{
STATE_MAXIMIZED
=
1
STATE_MINIMIZED
=
2
STATE_NORMAL
=
3
STATE_FULLSCREEN
=
4
}
;
uint16_t
nsGlobalWindowInner
:
:
WindowState
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
int32_t
mode
=
widget
?
widget
-
>
SizeMode
(
)
:
0
;
switch
(
mode
)
{
case
nsSizeMode_Minimized
:
return
STATE_MINIMIZED
;
case
nsSizeMode_Maximized
:
return
STATE_MAXIMIZED
;
case
nsSizeMode_Fullscreen
:
return
STATE_FULLSCREEN
;
case
nsSizeMode_Normal
:
return
STATE_NORMAL
;
default
:
NS_WARNING
(
"
Illegal
window
state
for
this
chrome
window
"
)
;
break
;
}
return
STATE_NORMAL
;
}
bool
nsGlobalWindowInner
:
:
IsFullyOccluded
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
return
widget
&
&
widget
-
>
IsFullyOccluded
(
)
;
}
void
nsGlobalWindowInner
:
:
Maximize
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
widget
-
>
SetSizeMode
(
nsSizeMode_Maximized
)
;
}
}
void
nsGlobalWindowInner
:
:
Minimize
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
widget
-
>
SetSizeMode
(
nsSizeMode_Minimized
)
;
}
}
void
nsGlobalWindowInner
:
:
Restore
(
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
widget
-
>
SetSizeMode
(
nsSizeMode_Normal
)
;
}
}
void
nsGlobalWindowInner
:
:
GetAttention
(
ErrorResult
&
aResult
)
{
return
GetAttentionWithCycleCount
(
-
1
aResult
)
;
}
void
nsGlobalWindowInner
:
:
GetAttentionWithCycleCount
(
int32_t
aCycleCount
ErrorResult
&
aError
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
GetMainWidget
(
)
;
if
(
widget
)
{
aError
=
widget
-
>
GetAttention
(
aCycleCount
)
;
}
}
already_AddRefed
<
Promise
>
nsGlobalWindowInner
:
:
PromiseDocumentFlushed
(
PromiseDocumentFlushedCallback
&
aCallback
ErrorResult
&
aError
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
if
(
!
IsCurrentInnerWindow
(
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
mIteratingDocumentFlushedResolvers
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
if
(
!
mDoc
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
PresShell
*
presShell
=
mDoc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
nsIGlobalObject
*
global
=
GetIncumbentGlobal
(
)
;
if
(
!
global
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
resultPromise
=
Promise
:
:
Create
(
global
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
UniquePtr
<
PromiseDocumentFlushedResolver
>
flushResolver
(
new
PromiseDocumentFlushedResolver
(
resultPromise
aCallback
)
)
;
if
(
!
presShell
-
>
NeedStyleFlush
(
)
&
&
!
presShell
-
>
NeedLayoutFlush
(
)
)
{
flushResolver
-
>
Call
(
)
;
return
resultPromise
.
forget
(
)
;
}
if
(
!
mObservingDidRefresh
)
{
bool
success
=
presShell
-
>
AddPostRefreshObserver
(
this
)
;
if
(
!
success
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
mObservingDidRefresh
=
true
;
}
mDocumentFlushedResolvers
.
AppendElement
(
std
:
:
move
(
flushResolver
)
)
;
return
resultPromise
.
forget
(
)
;
}
template
<
bool
call
>
void
nsGlobalWindowInner
:
:
CallOrCancelDocumentFlushedResolvers
(
)
{
MOZ_ASSERT
(
!
mIteratingDocumentFlushedResolvers
)
;
while
(
true
)
{
{
nsAutoMicroTask
mt
;
mIteratingDocumentFlushedResolvers
=
true
;
for
(
const
auto
&
documentFlushedResolver
:
mDocumentFlushedResolvers
)
{
if
(
call
)
{
documentFlushedResolver
-
>
Call
(
)
;
}
else
{
documentFlushedResolver
-
>
Cancel
(
)
;
}
}
mDocumentFlushedResolvers
.
Clear
(
)
;
mIteratingDocumentFlushedResolvers
=
false
;
}
if
(
!
mDocumentFlushedResolvers
.
Length
(
)
)
{
break
;
}
if
(
mDoc
)
{
PresShell
*
presShell
=
mDoc
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
Unused
<
<
presShell
-
>
AddPostRefreshObserver
(
this
)
;
break
;
}
}
}
}
void
nsGlobalWindowInner
:
:
CallDocumentFlushedResolvers
(
)
{
CallOrCancelDocumentFlushedResolvers
<
true
>
(
)
;
}
void
nsGlobalWindowInner
:
:
CancelDocumentFlushedResolvers
(
)
{
CallOrCancelDocumentFlushedResolvers
<
false
>
(
)
;
}
void
nsGlobalWindowInner
:
:
DidRefresh
(
)
{
auto
rejectionGuard
=
MakeScopeExit
(
[
&
]
{
CancelDocumentFlushedResolvers
(
)
;
mObservingDidRefresh
=
false
;
}
)
;
MOZ_ASSERT
(
mDoc
)
;
PresShell
*
presShell
=
mDoc
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
presShell
)
;
if
(
presShell
-
>
NeedStyleFlush
(
)
|
|
presShell
-
>
NeedLayoutFlush
(
)
)
{
rejectionGuard
.
release
(
)
;
return
;
}
bool
success
=
presShell
-
>
RemovePostRefreshObserver
(
this
)
;
if
(
!
success
)
{
return
;
}
rejectionGuard
.
release
(
)
;
CallDocumentFlushedResolvers
(
)
;
mObservingDidRefresh
=
false
;
}
already_AddRefed
<
nsWindowRoot
>
nsGlobalWindowInner
:
:
GetWindowRoot
(
mozilla
:
:
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetWindowRootOuter
(
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
SetCursor
(
const
nsAString
&
aCursor
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetCursorOuter
(
aCursor
aError
)
aError
)
;
}
NS_IMETHODIMP
nsGlobalWindowInner
:
:
GetBrowserDOMWindow
(
nsIBrowserDOMWindow
*
*
aBrowserWindow
)
{
MOZ_RELEASE_ASSERT
(
IsChromeWindow
(
)
)
;
ErrorResult
rv
;
NS_IF_ADDREF
(
*
aBrowserWindow
=
GetBrowserDOMWindow
(
rv
)
)
;
return
rv
.
StealNSResult
(
)
;
}
nsIBrowserDOMWindow
*
nsGlobalWindowInner
:
:
GetBrowserDOMWindow
(
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
GetBrowserDOMWindowOuter
(
)
aError
nullptr
)
;
}
void
nsGlobalWindowInner
:
:
SetBrowserDOMWindow
(
nsIBrowserDOMWindow
*
aBrowserWindow
ErrorResult
&
aError
)
{
FORWARD_TO_OUTER_OR_THROW
(
SetBrowserDOMWindowOuter
(
aBrowserWindow
)
aError
)
;
}
void
nsGlobalWindowInner
:
:
NotifyDefaultButtonLoaded
(
Element
&
aDefaultButton
ErrorResult
&
aError
)
{
#
ifdef
MOZ_XUL
nsCOMPtr
<
nsIDOMXULControlElement
>
xulControl
=
aDefaultButton
.
AsXULControl
(
)
;
if
(
!
xulControl
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
bool
disabled
;
aError
=
xulControl
-
>
GetDisabled
(
&
disabled
)
;
if
(
aError
.
Failed
(
)
|
|
disabled
)
{
return
;
}
nsIFrame
*
frame
=
aDefaultButton
.
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
LayoutDeviceIntRect
buttonRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
frame
-
>
GetScreenRectInAppUnits
(
)
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
nsIWidget
*
widget
=
GetNearestWidget
(
)
;
if
(
!
widget
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
LayoutDeviceIntRect
widgetRect
=
widget
-
>
GetScreenBounds
(
)
;
buttonRect
-
=
widgetRect
.
TopLeft
(
)
;
nsresult
rv
=
widget
-
>
OnDefaultButtonLoaded
(
buttonRect
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_NOT_IMPLEMENTED
)
{
aError
.
Throw
(
rv
)
;
}
#
else
aError
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
#
endif
}
ChromeMessageBroadcaster
*
nsGlobalWindowInner
:
:
MessageManager
(
)
{
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
if
(
!
mChromeFields
.
mMessageManager
)
{
RefPtr
<
ChromeMessageBroadcaster
>
globalMM
=
nsFrameMessageManager
:
:
GetGlobalMessageManager
(
)
;
mChromeFields
.
mMessageManager
=
new
ChromeMessageBroadcaster
(
globalMM
)
;
}
return
mChromeFields
.
mMessageManager
;
}
ChromeMessageBroadcaster
*
nsGlobalWindowInner
:
:
GetGroupMessageManager
(
const
nsAString
&
aGroup
)
{
MOZ_ASSERT
(
IsChromeWindow
(
)
)
;
RefPtr
<
ChromeMessageBroadcaster
>
messageManager
=
mChromeFields
.
mGroupMessageManagers
.
LookupForAdd
(
aGroup
)
.
OrInsert
(
[
this
]
(
)
{
return
new
ChromeMessageBroadcaster
(
MessageManager
(
)
)
;
}
)
;
return
messageManager
;
}
void
nsGlobalWindowInner
:
:
InitWasOffline
(
)
{
mWasOffline
=
NS_IsOffline
(
)
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
int16_t
nsGlobalWindowInner
:
:
Orientation
(
CallerType
aCallerType
)
const
{
return
nsContentUtils
:
:
ResistFingerprinting
(
aCallerType
)
?
0
:
WindowOrientationObserver
:
:
OrientationAngle
(
)
;
}
#
endif
already_AddRefed
<
Console
>
nsGlobalWindowInner
:
:
GetConsole
(
JSContext
*
aCx
ErrorResult
&
aRv
)
{
if
(
!
mConsole
)
{
mConsole
=
Console
:
:
Create
(
aCx
this
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
}
RefPtr
<
Console
>
console
=
mConsole
;
return
console
.
forget
(
)
;
}
bool
nsGlobalWindowInner
:
:
IsSecureContext
(
)
const
{
JS
:
:
Realm
*
realm
=
js
:
:
GetNonCCWObjectRealm
(
GetWrapperPreserveColor
(
)
)
;
return
JS
:
:
GetIsSecureContext
(
realm
)
;
}
External
*
nsGlobalWindowInner
:
:
GetExternal
(
ErrorResult
&
aRv
)
{
#
ifdef
HAVE_SIDEBAR
if
(
!
mExternal
)
{
mExternal
=
ConstructJSImplementation
<
External
>
(
"
mozilla
.
org
/
sidebar
;
1
"
this
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
return
static_cast
<
External
*
>
(
mExternal
.
get
(
)
)
;
#
else
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
nullptr
;
#
endif
}
void
nsGlobalWindowInner
:
:
GetSidebar
(
OwningExternalOrWindowProxy
&
aResult
ErrorResult
&
aRv
)
{
#
ifdef
HAVE_SIDEBAR
RefPtr
<
BrowsingContext
>
domWindow
=
GetChildWindow
(
NS_LITERAL_STRING
(
"
sidebar
"
)
)
;
if
(
domWindow
)
{
aResult
.
SetAsWindowProxy
(
)
=
domWindow
.
forget
(
)
;
return
;
}
RefPtr
<
External
>
external
=
GetExternal
(
aRv
)
;
if
(
external
)
{
aResult
.
SetAsExternal
(
)
=
external
;
}
#
else
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
#
endif
}
void
nsGlobalWindowInner
:
:
ClearDocumentDependentSlots
(
JSContext
*
aCx
)
{
if
(
!
Window_Binding
:
:
ClearCachedDocumentValue
(
aCx
this
)
|
|
!
Window_Binding
:
:
ClearCachedPerformanceValue
(
aCx
this
)
)
{
MOZ_CRASH
(
"
Unhandlable
OOM
while
clearing
document
dependent
slots
.
"
)
;
}
}
JSObject
*
nsGlobalWindowInner
:
:
CreateNamedPropertiesObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aProto
)
{
return
WindowNamedPropertiesHandler
:
:
Create
(
aCx
aProto
)
;
}
void
nsGlobalWindowInner
:
:
RedefineProperty
(
JSContext
*
aCx
const
char
*
aPropName
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aError
)
{
JS
:
:
Rooted
<
JSObject
*
>
thisObj
(
aCx
GetWrapperPreserveColor
(
)
)
;
if
(
!
thisObj
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
!
JS_WrapObject
(
aCx
&
thisObj
)
|
|
!
JS_DefineProperty
(
aCx
thisObj
aPropName
aValue
JSPROP_ENUMERATE
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
void
nsGlobalWindowInner
:
:
GetReplaceableWindowCoord
(
JSContext
*
aCx
nsGlobalWindowInner
:
:
WindowCoordGetter
aGetter
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
CallerType
aCallerType
ErrorResult
&
aError
)
{
int32_t
coord
=
(
this
-
>
*
aGetter
)
(
aCallerType
aError
)
;
if
(
!
aError
.
Failed
(
)
&
&
!
ToJSValue
(
aCx
coord
aRetval
)
)
{
aError
.
Throw
(
NS_ERROR_FAILURE
)
;
}
}
void
nsGlobalWindowInner
:
:
SetReplaceableWindowCoord
(
JSContext
*
aCx
nsGlobalWindowInner
:
:
WindowCoordSetter
aSetter
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
const
char
*
aPropName
CallerType
aCallerType
ErrorResult
&
aError
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
if
(
!
outer
|
|
!
outer
-
>
CanMoveResizeWindows
(
aCallerType
)
|
|
outer
-
>
IsFrame
(
)
)
{
RedefineProperty
(
aCx
aPropName
aValue
aError
)
;
return
;
}
int32_t
value
;
if
(
!
ValueToPrimitive
<
int32_t
eDefault
>
(
aCx
aValue
&
value
)
)
{
aError
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
nsContentUtils
:
:
ShouldResistFingerprinting
(
GetDocShell
(
)
)
)
{
bool
innerWidthSpecified
=
false
;
bool
innerHeightSpecified
=
false
;
bool
outerWidthSpecified
=
false
;
bool
outerHeightSpecified
=
false
;
if
(
strcmp
(
aPropName
"
innerWidth
"
)
=
=
0
)
{
innerWidthSpecified
=
true
;
}
else
if
(
strcmp
(
aPropName
"
innerHeight
"
)
=
=
0
)
{
innerHeightSpecified
=
true
;
}
else
if
(
strcmp
(
aPropName
"
outerWidth
"
)
=
=
0
)
{
outerWidthSpecified
=
true
;
}
else
if
(
strcmp
(
aPropName
"
outerHeight
"
)
=
=
0
)
{
outerHeightSpecified
=
true
;
}
if
(
innerWidthSpecified
|
|
innerHeightSpecified
|
|
outerWidthSpecified
|
|
outerHeightSpecified
)
{
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
=
outer
-
>
GetTreeOwnerWindow
(
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
int32_t
winLeft
=
0
;
int32_t
winTop
=
0
;
int32_t
winWidth
=
0
;
int32_t
winHeight
=
0
;
double
scale
=
1
.
0
;
if
(
treeOwnerAsWin
&
&
screenMgr
)
{
treeOwnerAsWin
-
>
GetUnscaledDevicePixelsPerCSSPixel
(
&
scale
)
;
treeOwnerAsWin
-
>
GetPositionAndSize
(
&
winLeft
&
winTop
&
winWidth
&
winHeight
)
;
winLeft
=
NSToIntRound
(
winHeight
/
scale
)
;
winTop
=
NSToIntRound
(
winWidth
/
scale
)
;
winWidth
=
NSToIntRound
(
winWidth
/
scale
)
;
winHeight
=
NSToIntRound
(
winHeight
/
scale
)
;
CSSIntSize
contentSize
;
outer
-
>
GetInnerSize
(
contentSize
)
;
screenMgr
-
>
ScreenForRect
(
winLeft
winTop
winWidth
winHeight
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
*
targetContentWidth
=
nullptr
;
int32_t
*
targetContentHeight
=
nullptr
;
int32_t
screenWidth
=
0
;
int32_t
screenHeight
=
0
;
int32_t
chromeWidth
=
0
;
int32_t
chromeHeight
=
0
;
int32_t
inputWidth
=
0
;
int32_t
inputHeight
=
0
;
int32_t
unused
=
0
;
screen
-
>
GetAvailRect
(
&
unused
&
unused
&
screenWidth
&
screenHeight
)
;
screenWidth
=
NSToIntRound
(
screenWidth
/
scale
)
;
screenHeight
=
NSToIntRound
(
screenHeight
/
scale
)
;
chromeWidth
=
winWidth
-
contentSize
.
width
;
chromeHeight
=
winHeight
-
contentSize
.
height
;
if
(
innerWidthSpecified
|
|
outerWidthSpecified
)
{
inputWidth
=
value
;
targetContentWidth
=
&
value
;
targetContentHeight
=
&
unused
;
}
else
if
(
innerHeightSpecified
|
|
outerHeightSpecified
)
{
inputHeight
=
value
;
targetContentWidth
=
&
unused
;
targetContentHeight
=
&
value
;
}
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
chromeWidth
chromeHeight
screenWidth
screenHeight
inputWidth
inputHeight
outerWidthSpecified
outerHeightSpecified
targetContentWidth
targetContentHeight
)
;
}
}
}
}
(
this
-
>
*
aSetter
)
(
value
aCallerType
aError
)
;
}
void
nsGlobalWindowInner
:
:
FireOnNewGlobalObject
(
)
{
AutoEntryScript
aes
(
this
"
nsGlobalWindowInner
report
new
global
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aes
.
cx
(
)
GetWrapper
(
)
)
;
JS_FireOnNewGlobalObject
(
aes
.
cx
(
)
global
)
;
}
#
if
defined
(
_WINDOWS_
)
&
&
!
defined
(
MOZ_WRAPPED_WINDOWS_H
)
#
pragma
message
(
\
"
wrapper
failure
reason
:
"
MOZ_WINDOWS_WRAPPER_DISABLED_REASON
)
#
error
"
Never
include
unwrapped
windows
.
h
in
this
file
!
"
#
endif
already_AddRefed
<
Promise
>
nsGlobalWindowInner
:
:
CreateImageBitmap
(
JSContext
*
aCx
const
ImageBitmapSource
&
aImage
ErrorResult
&
aRv
)
{
return
ImageBitmap
:
:
Create
(
this
aImage
Nothing
(
)
aRv
)
;
}
already_AddRefed
<
Promise
>
nsGlobalWindowInner
:
:
CreateImageBitmap
(
JSContext
*
aCx
const
ImageBitmapSource
&
aImage
int32_t
aSx
int32_t
aSy
int32_t
aSw
int32_t
aSh
ErrorResult
&
aRv
)
{
return
ImageBitmap
:
:
Create
(
this
aImage
Some
(
gfx
:
:
IntRect
(
aSx
aSy
aSw
aSh
)
)
aRv
)
;
}
mozilla
:
:
dom
:
:
TabGroup
*
nsGlobalWindowInner
:
:
TabGroupInner
(
)
{
if
(
!
mTabGroup
)
{
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
MOZ_RELEASE_ASSERT
(
outer
"
Inner
window
without
outer
window
has
no
cached
tab
group
!
"
)
;
mTabGroup
=
outer
-
>
TabGroup
(
)
;
}
MOZ_ASSERT
(
mTabGroup
)
;
#
ifdef
DEBUG
nsGlobalWindowOuter
*
outer
=
GetOuterWindowInternal
(
)
;
MOZ_ASSERT_IF
(
outer
outer
-
>
TabGroup
(
)
=
=
mTabGroup
)
;
#
endif
return
mTabGroup
;
}
nsresult
nsGlobalWindowInner
:
:
Dispatch
(
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
Dispatch
(
aCategory
std
:
:
move
(
aRunnable
)
)
;
}
return
DispatcherTrait
:
:
Dispatch
(
aCategory
std
:
:
move
(
aRunnable
)
)
;
}
nsISerialEventTarget
*
nsGlobalWindowInner
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
EventTargetFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
EventTargetFor
(
aCategory
)
;
}
AbstractThread
*
nsGlobalWindowInner
:
:
AbstractMainThreadFor
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
GetDocGroup
(
)
)
{
return
GetDocGroup
(
)
-
>
AbstractMainThreadFor
(
aCategory
)
;
}
return
DispatcherTrait
:
:
AbstractMainThreadFor
(
aCategory
)
;
}
Worklet
*
nsGlobalWindowInner
:
:
GetPaintWorklet
(
ErrorResult
&
aRv
)
{
if
(
!
mPaintWorklet
)
{
nsIPrincipal
*
principal
=
GetPrincipal
(
)
;
if
(
!
principal
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
mPaintWorklet
=
PaintWorkletImpl
:
:
CreateWorklet
(
this
principal
)
;
}
return
mPaintWorklet
;
}
void
nsGlobalWindowInner
:
:
GetRegionalPrefsLocales
(
nsTArray
<
nsString
>
&
aLocales
)
{
MOZ_ASSERT
(
mozilla
:
:
intl
:
:
LocaleService
:
:
GetInstance
(
)
)
;
AutoTArray
<
nsCString
10
>
rpLocales
;
mozilla
:
:
intl
:
:
LocaleService
:
:
GetInstance
(
)
-
>
GetRegionalPrefsLocales
(
rpLocales
)
;
for
(
const
auto
&
loc
:
rpLocales
)
{
aLocales
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
loc
)
)
;
}
}
void
nsGlobalWindowInner
:
:
GetWebExposedLocales
(
nsTArray
<
nsString
>
&
aLocales
)
{
MOZ_ASSERT
(
mozilla
:
:
intl
:
:
LocaleService
:
:
GetInstance
(
)
)
;
AutoTArray
<
nsCString
10
>
rpLocales
;
mozilla
:
:
intl
:
:
LocaleService
:
:
GetInstance
(
)
-
>
GetWebExposedLocales
(
rpLocales
)
;
for
(
const
auto
&
loc
:
rpLocales
)
{
aLocales
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
loc
)
)
;
}
}
IntlUtils
*
nsGlobalWindowInner
:
:
GetIntlUtils
(
ErrorResult
&
aError
)
{
if
(
!
mIntlUtils
)
{
mIntlUtils
=
new
IntlUtils
(
this
)
;
}
return
mIntlUtils
;
}
void
nsGlobalWindowInner
:
:
StoreSharedWorker
(
SharedWorker
*
aSharedWorker
)
{
MOZ_ASSERT
(
aSharedWorker
)
;
MOZ_ASSERT
(
!
mSharedWorkers
.
Contains
(
aSharedWorker
)
)
;
mSharedWorkers
.
AppendElement
(
aSharedWorker
)
;
}
void
nsGlobalWindowInner
:
:
ForgetSharedWorker
(
SharedWorker
*
aSharedWorker
)
{
MOZ_ASSERT
(
aSharedWorker
)
;
MOZ_ASSERT
(
mSharedWorkers
.
Contains
(
aSharedWorker
)
)
;
mSharedWorkers
.
RemoveElement
(
aSharedWorker
)
;
}
void
nsGlobalWindowInner
:
:
StorageAccessGranted
(
)
{
PropagateFirstPartyStorageAccessGrantedToWorkers
(
this
)
;
if
(
mLocalStorage
)
{
IgnoredErrorResult
error
;
GetLocalStorage
(
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
mLocalStorage
&
&
mLocalStorage
-
>
Type
(
)
=
=
Storage
:
:
eLocalStorage
)
;
if
(
NextGenLocalStorageEnabled
(
)
&
&
mListenerManager
&
&
mListenerManager
-
>
HasListenersFor
(
nsGkAtoms
:
:
onstorage
)
)
{
auto
object
=
static_cast
<
LSObject
*
>
(
mLocalStorage
.
get
(
)
)
;
object
-
>
EnsureObserver
(
)
;
}
}
mIndexedDB
=
nullptr
;
mCacheStorage
=
nullptr
;
if
(
mDoc
)
{
mDoc
-
>
ClearActiveStoragePrincipal
(
)
;
}
}
mozilla
:
:
dom
:
:
TabGroup
*
nsPIDOMWindowInner
:
:
TabGroup
(
)
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
TabGroupInner
(
)
;
}
already_AddRefed
<
nsGlobalWindowInner
>
nsGlobalWindowInner
:
:
Create
(
nsGlobalWindowOuter
*
aOuterWindow
bool
aIsChrome
WindowGlobalChild
*
aActor
)
{
RefPtr
<
nsGlobalWindowInner
>
window
=
new
nsGlobalWindowInner
(
aOuterWindow
aActor
)
;
if
(
aIsChrome
)
{
window
-
>
mIsChrome
=
true
;
window
-
>
mCleanMessageManager
=
true
;
}
if
(
aActor
)
{
aActor
-
>
InitWindowGlobal
(
window
)
;
}
window
-
>
InitWasOffline
(
)
;
return
window
.
forget
(
)
;
}
nsIURI
*
nsPIDOMWindowInner
:
:
GetDocumentURI
(
)
const
{
return
mDoc
?
mDoc
-
>
GetDocumentURI
(
)
:
mDocumentURI
.
get
(
)
;
}
nsIURI
*
nsPIDOMWindowInner
:
:
GetDocBaseURI
(
)
const
{
return
mDoc
?
mDoc
-
>
GetDocBaseURI
(
)
:
mDocBaseURI
.
get
(
)
;
}
void
nsPIDOMWindowInner
:
:
MaybeCreateDoc
(
)
{
MOZ_ASSERT
(
!
mDoc
)
;
if
(
nsIDocShell
*
docShell
=
GetDocShell
(
)
)
{
nsCOMPtr
<
Document
>
document
=
docShell
-
>
GetDocument
(
)
;
Unused
<
<
document
;
}
}
mozilla
:
:
dom
:
:
DocGroup
*
nsPIDOMWindowInner
:
:
GetDocGroup
(
)
const
{
Document
*
doc
=
GetExtantDoc
(
)
;
if
(
doc
)
{
return
doc
-
>
GetDocGroup
(
)
;
}
return
nullptr
;
}
nsIGlobalObject
*
nsPIDOMWindowInner
:
:
AsGlobal
(
)
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
;
}
const
nsIGlobalObject
*
nsPIDOMWindowInner
:
:
AsGlobal
(
)
const
{
return
nsGlobalWindowInner
:
:
Cast
(
this
)
;
}
void
nsPIDOMWindowInner
:
:
SaveStorageAccessGranted
(
const
nsACString
&
aPermissionKey
)
{
if
(
!
HasStorageAccessGranted
(
aPermissionKey
)
)
{
mStorageAccessGranted
.
AppendElement
(
aPermissionKey
)
;
}
nsGlobalWindowInner
:
:
Cast
(
this
)
-
>
ClearActiveStoragePrincipal
(
)
;
}
void
nsGlobalWindowInner
:
:
ClearActiveStoragePrincipal
(
)
{
Document
*
doc
=
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
ClearActiveStoragePrincipal
(
)
;
}
CallOnChildren
(
&
nsGlobalWindowInner
:
:
ClearActiveStoragePrincipal
)
;
}
bool
nsPIDOMWindowInner
:
:
HasStorageAccessGranted
(
const
nsACString
&
aPermissionKey
)
{
return
mStorageAccessGranted
.
Contains
(
aPermissionKey
)
;
}
nsPIDOMWindowInner
:
:
nsPIDOMWindowInner
(
nsPIDOMWindowOuter
*
aOuterWindow
WindowGlobalChild
*
aActor
)
:
mMutationBits
(
0
)
mActivePeerConnections
(
0
)
mIsDocumentLoaded
(
false
)
mIsHandlingResizeEvent
(
false
)
mMayHavePaintEventListener
(
false
)
mMayHaveTouchEventListener
(
false
)
mMayHaveSelectionChangeEventListener
(
false
)
mMayHaveMouseEnterLeaveEventListener
(
false
)
mMayHavePointerEnterLeaveEventListener
(
false
)
mMayHaveTextEventListenerInDefaultGroup
(
false
)
mOuterWindow
(
aOuterWindow
)
mWindowID
(
0
)
mHasNotifiedGlobalCreated
(
false
)
mMarkedCCGeneration
(
0
)
mHasTriedToCacheTopInnerWindow
(
false
)
mNumOfIndexedDBDatabases
(
0
)
mNumOfOpenWebSockets
(
0
)
mEvent
(
nullptr
)
mWindowGlobalChild
(
aActor
)
{
MOZ_ASSERT
(
aOuterWindow
)
;
mBrowsingContext
=
aOuterWindow
-
>
GetBrowsingContext
(
)
;
if
(
mWindowGlobalChild
)
{
mWindowID
=
aActor
-
>
InnerWindowId
(
)
;
MOZ_ASSERT
(
mWindowGlobalChild
-
>
BrowsingContext
(
)
=
=
mBrowsingContext
)
;
}
else
{
mWindowID
=
nsContentUtils
:
:
GenerateWindowId
(
)
;
}
}
void
nsPIDOMWindowInner
:
:
RegisterReportingObserver
(
ReportingObserver
*
aObserver
bool
aBuffered
)
{
MOZ_ASSERT
(
aObserver
)
;
if
(
mReportingObservers
.
Contains
(
aObserver
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
mReportingObservers
.
AppendElement
(
aObserver
fallible
)
)
)
{
return
;
}
if
(
!
aBuffered
)
{
return
;
}
for
(
Report
*
report
:
mReportRecords
)
{
aObserver
-
>
MaybeReport
(
report
)
;
}
}
void
nsPIDOMWindowInner
:
:
UnregisterReportingObserver
(
ReportingObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
)
;
mReportingObservers
.
RemoveElement
(
aObserver
)
;
}
void
nsPIDOMWindowInner
:
:
BroadcastReport
(
Report
*
aReport
)
{
MOZ_ASSERT
(
aReport
)
;
for
(
ReportingObserver
*
observer
:
mReportingObservers
)
{
observer
-
>
MaybeReport
(
aReport
)
;
}
if
(
NS_WARN_IF
(
!
mReportRecords
.
AppendElement
(
aReport
fallible
)
)
)
{
return
;
}
while
(
mReportRecords
.
Length
(
)
>
MAX_REPORT_RECORDS
)
{
mReportRecords
.
RemoveElementAt
(
0
)
;
}
}
void
nsPIDOMWindowInner
:
:
NotifyReportingObservers
(
)
{
nsTArray
<
RefPtr
<
ReportingObserver
>
>
reportingObservers
(
mReportingObservers
)
;
for
(
RefPtr
<
ReportingObserver
>
&
observer
:
reportingObservers
)
{
observer
-
>
MaybeNotify
(
)
;
}
}
nsPIDOMWindowInner
:
:
~
nsPIDOMWindowInner
(
)
{
}
#
undef
FORWARD_TO_OUTER
#
undef
FORWARD_TO_OUTER_OR_THROW
#
undef
FORWARD_TO_OUTER_VOID
