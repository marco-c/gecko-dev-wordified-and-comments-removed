#
include
"
ThirdPartyUtil
.
h
"
#
include
<
cstdint
>
#
include
"
MainThreadUtils
.
h
"
#
include
"
mozIDOMWindow
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
ContentBlockingNotifier
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIDOMWindowInlines
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsTLiteralString
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_ISUPPORTS
(
ThirdPartyUtil
mozIThirdPartyUtil
)
static
mozilla
:
:
LazyLogModule
gThirdPartyLog
(
"
thirdPartyUtil
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
gThirdPartyLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
mozilla
:
:
StaticRefPtr
<
ThirdPartyUtil
>
gService
;
void
ThirdPartyUtil
:
:
Startup
(
)
{
nsCOMPtr
<
mozIThirdPartyUtil
>
tpu
;
if
(
NS_WARN_IF
(
!
(
tpu
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
)
)
)
)
{
NS_WARNING
(
"
Failed
to
get
third
party
util
!
"
)
;
}
}
nsresult
ThirdPartyUtil
:
:
Init
(
)
{
NS_ENSURE_TRUE
(
NS_IsMainThread
(
)
NS_ERROR_NOT_AVAILABLE
)
;
MOZ_ASSERT
(
!
gService
)
;
gService
=
this
;
mozilla
:
:
ClearOnShutdown
(
&
gService
)
;
mTLDService
=
mozilla
:
:
components
:
:
EffectiveTLD
:
:
Service
(
)
;
return
mTLDService
?
NS_OK
:
NS_ERROR_FAILURE
;
}
ThirdPartyUtil
:
:
~
ThirdPartyUtil
(
)
{
gService
=
nullptr
;
}
ThirdPartyUtil
*
ThirdPartyUtil
:
:
GetInstance
(
)
{
if
(
gService
)
{
return
gService
;
}
nsCOMPtr
<
mozIThirdPartyUtil
>
tpuService
=
mozilla
:
:
components
:
:
ThirdPartyUtil
:
:
Service
(
)
;
if
(
!
tpuService
)
{
return
nullptr
;
}
MOZ_ASSERT
(
gService
"
gService
must
have
been
initialized
in
nsEffectiveTLDService
:
:
Init
"
)
;
return
gService
;
}
nsresult
ThirdPartyUtil
:
:
IsThirdPartyInternal
(
const
nsCString
&
aFirstDomain
nsIURI
*
aSecondURI
bool
*
aResult
)
{
if
(
!
aSecondURI
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aSecondURI
-
>
SchemeIs
(
"
blob
"
)
)
{
*
aResult
=
false
;
return
NS_OK
;
}
nsAutoCString
secondDomain
;
nsresult
rv
=
GetBaseDomain
(
aSecondURI
secondDomain
)
;
LOG
(
(
"
ThirdPartyUtil
:
:
IsThirdPartyInternal
%
s
=
?
%
s
"
aFirstDomain
.
get
(
)
secondDomain
.
get
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
*
aResult
=
IsThirdPartyInternal
(
aFirstDomain
secondDomain
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetPrincipalFromWindow
(
mozIDOMWindowProxy
*
aWin
nsIPrincipal
*
*
result
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
scriptObjPrin
=
do_QueryInterface
(
aWin
)
;
if
(
!
scriptObjPrin
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIPrincipal
>
prin
=
scriptObjPrin
-
>
GetPrincipal
(
)
;
if
(
!
prin
)
{
return
NS_ERROR_INVALID_ARG
;
}
prin
.
forget
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetURIFromWindow
(
mozIDOMWindowProxy
*
aWin
nsIURI
*
*
result
)
{
nsCOMPtr
<
nsIPrincipal
>
prin
;
nsresult
rv
=
GetPrincipalFromWindow
(
aWin
getter_AddRefs
(
prin
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
prin
-
>
GetIsNullPrincipal
(
)
)
{
LOG
(
(
"
ThirdPartyUtil
:
:
GetURIFromWindow
can
'
t
use
null
principal
\
n
"
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
prin
)
;
return
basePrin
-
>
GetURI
(
result
)
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
IsThirdPartyURI
(
nsIURI
*
aFirstURI
nsIURI
*
aSecondURI
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aFirstURI
)
;
NS_ENSURE_ARG
(
aSecondURI
)
;
NS_ASSERTION
(
aResult
"
null
outparam
pointer
"
)
;
nsAutoCString
firstHost
;
nsresult
rv
=
GetBaseDomain
(
aFirstURI
firstHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
IsThirdPartyInternal
(
firstHost
aSecondURI
aResult
)
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
IsThirdPartyWindow
(
mozIDOMWindowProxy
*
aWindow
nsIURI
*
aURI
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aWindow
)
;
NS_ASSERTION
(
aResult
"
null
outparam
pointer
"
)
;
bool
result
;
if
(
aURI
&
&
!
NS_IsAboutBlank
(
aURI
)
&
&
!
NS_IsAboutSrcdoc
(
aURI
)
)
{
nsCOMPtr
<
nsIPrincipal
>
prin
;
nsresult
rv
=
GetPrincipalFromWindow
(
aWindow
getter_AddRefs
(
prin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
prin
-
>
IsThirdPartyURI
(
aURI
&
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
result
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
nsPIDOMWindowOuter
*
current
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
auto
*
const
browsingContext
=
current
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
browsingContext
)
;
if
(
browsingContext
-
>
IsTopContent
(
)
)
{
*
aResult
=
false
;
return
NS_OK
;
}
RefPtr
<
Document
>
doc
=
current
-
>
GetExtantDoc
(
)
;
if
(
doc
&
&
(
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
WindowContext
*
wc
=
browsingContext
-
>
GetCurrentWindowContext
(
)
;
if
(
NS_WARN_IF
(
!
wc
)
)
{
*
aResult
=
true
;
return
NS_OK
;
}
*
aResult
=
wc
-
>
GetIsThirdPartyWindow
(
)
;
return
NS_OK
;
}
nsresult
ThirdPartyUtil
:
:
IsThirdPartyGlobal
(
mozilla
:
:
dom
:
:
WindowGlobalParent
*
aWindowGlobal
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aWindowGlobal
)
;
NS_ASSERTION
(
aResult
"
null
outparam
pointer
"
)
;
auto
*
currentWGP
=
aWindowGlobal
;
do
{
MOZ_ASSERT
(
currentWGP
-
>
BrowsingContext
(
)
)
;
if
(
currentWGP
-
>
BrowsingContext
(
)
-
>
IsTop
(
)
)
{
*
aResult
=
false
;
return
NS_OK
;
}
if
(
currentWGP
-
>
SandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
{
*
aResult
=
true
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
currentPrincipal
=
currentWGP
-
>
DocumentPrincipal
(
)
;
RefPtr
<
WindowGlobalParent
>
parent
=
currentWGP
-
>
BrowsingContext
(
)
-
>
GetEmbedderWindowGlobal
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
=
parent
-
>
DocumentPrincipal
(
)
;
nsresult
rv
=
currentPrincipal
-
>
IsThirdPartyPrincipal
(
parentPrincipal
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
*
aResult
)
{
return
NS_OK
;
}
currentWGP
=
parent
;
}
while
(
true
)
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
IsThirdPartyChannel
(
nsIChannel
*
aChannel
nsIURI
*
aURI
bool
*
aResult
)
{
LOG
(
(
"
ThirdPartyUtil
:
:
IsThirdPartyChannel
[
channel
=
%
p
]
"
aChannel
)
)
;
NS_ENSURE_ARG
(
aChannel
)
;
NS_ASSERTION
(
aResult
"
null
outparam
pointer
"
)
;
nsresult
rv
;
bool
doForce
=
false
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannelInternal
)
{
uint32_t
flags
=
0
;
mozilla
:
:
Unused
<
<
httpChannelInternal
-
>
GetThirdPartyFlags
(
&
flags
)
;
doForce
=
(
flags
&
nsIHttpChannelInternal
:
:
THIRD_PARTY_FORCE_ALLOW
)
;
if
(
doForce
&
&
!
aURI
)
{
*
aResult
=
false
;
return
NS_OK
;
}
}
bool
parentIsThird
=
false
;
nsAutoCString
channelDomain
;
nsCOMPtr
<
nsIURI
>
channelURI
;
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
BasePrincipal
*
loadingPrincipal
=
nullptr
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
if
(
!
doForce
)
{
parentIsThird
=
loadInfo
-
>
GetIsInThirdPartyContext
(
)
;
if
(
!
parentIsThird
&
&
loadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
ExtContentPolicy
:
:
TYPE_DOCUMENT
)
{
loadingPrincipal
=
BasePrincipal
:
:
Cast
(
loadInfo
-
>
GetLoadingPrincipal
(
)
)
;
}
}
if
(
NS_IsAboutBlank
(
channelURI
)
|
|
NS_IsAboutSrcdoc
(
channelURI
)
)
{
nsCOMPtr
<
nsIPrincipal
>
principalToInherit
=
loadInfo
-
>
FindPrincipalToInherit
(
aChannel
)
;
if
(
!
principalToInherit
)
{
*
aResult
=
true
;
return
NS_OK
;
}
rv
=
principalToInherit
-
>
GetBaseDomain
(
channelDomain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
loadingPrincipal
)
{
rv
=
loadingPrincipal
-
>
IsThirdPartyPrincipal
(
principalToInherit
&
parentIsThird
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
else
{
rv
=
GetBaseDomain
(
channelURI
channelDomain
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
loadingPrincipal
)
{
rv
=
loadingPrincipal
-
>
IsThirdPartyURI
(
channelURI
&
parentIsThird
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
if
(
!
aURI
|
|
parentIsThird
)
{
*
aResult
=
parentIsThird
;
return
NS_OK
;
}
return
IsThirdPartyInternal
(
channelDomain
aURI
aResult
)
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetTopWindowForChannel
(
nsIChannel
*
aChannel
nsIURI
*
aURIBeingLoaded
mozIDOMWindowProxy
*
*
aWin
)
{
NS_ENSURE_ARG
(
aWin
)
;
nsCOMPtr
<
nsILoadContext
>
ctx
;
NS_QueryNotificationCallbacks
(
aChannel
ctx
)
;
if
(
!
ctx
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
window
;
ctx
-
>
GetAssociatedWindow
(
getter_AddRefs
(
window
)
)
;
if
(
!
window
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
nsGlobalWindowOuter
:
:
Cast
(
window
)
-
>
GetTopExcludingExtensionAccessibleContentFrames
(
aURIBeingLoaded
)
;
top
.
forget
(
aWin
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetBaseDomain
(
nsIURI
*
aHostURI
nsACString
&
aBaseDomain
)
{
if
(
!
aHostURI
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
;
nsCOMPtr
<
nsIPrincipal
>
blobPrincipal
;
if
(
aHostURI
-
>
SchemeIs
(
"
blob
"
)
)
{
if
(
BlobURLProtocolHandler
:
:
GetBlobURLPrincipal
(
aHostURI
getter_AddRefs
(
blobPrincipal
)
)
)
{
rv
=
blobPrincipal
-
>
GetBaseDomain
(
aBaseDomain
)
;
}
else
{
rv
=
nsresult
:
:
NS_ERROR_DOM_BAD_URI
;
}
}
else
{
rv
=
mTLDService
-
>
GetBaseDomain
(
aHostURI
0
aBaseDomain
)
;
}
if
(
aHostURI
-
>
SchemeIs
(
NS_NULLPRINCIPAL_SCHEME
)
)
{
rv
=
aHostURI
-
>
GetFilePath
(
aBaseDomain
)
;
}
if
(
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
if
(
aHostURI
-
>
SchemeIs
(
"
view
-
source
"
)
)
{
rv
=
NS_GetInnermostURIHost
(
aHostURI
aBaseDomain
)
;
}
else
{
rv
=
aHostURI
-
>
GetAsciiHost
(
aBaseDomain
)
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aBaseDomain
.
Length
(
)
=
=
1
&
&
aBaseDomain
.
Last
(
)
=
=
'
.
'
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aBaseDomain
.
IsEmpty
(
)
&
&
!
aHostURI
-
>
SchemeIs
(
"
file
"
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
ThirdPartyAnalysisResult
)
ThirdPartyUtil
:
:
AnalyzeChannel
(
nsIChannel
*
aChannel
bool
aNotify
nsIURI
*
aURI
RequireThirdPartyCheck
aRequireThirdPartyCheck
uint32_t
*
aRejectedReason
)
{
MOZ_ASSERT_IF
(
aNotify
aRejectedReason
)
;
ThirdPartyAnalysisResult
result
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
!
aURI
&
&
aChannel
)
{
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
?
aChannel
-
>
LoadInfo
(
)
:
nullptr
;
bool
isForeign
=
true
;
if
(
aChannel
&
&
(
!
aRequireThirdPartyCheck
|
|
aRequireThirdPartyCheck
(
loadInfo
)
)
)
{
IsThirdPartyChannel
(
aChannel
aURI
?
aURI
:
uri
.
get
(
)
&
isForeign
)
;
}
if
(
isForeign
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsForeign
;
}
nsCOMPtr
<
nsIClassifiedChannel
>
classifiedChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
classifiedChannel
)
{
if
(
classifiedChannel
-
>
IsThirdPartyTrackingResource
(
)
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsThirdPartyTrackingResource
;
}
if
(
classifiedChannel
-
>
IsThirdPartySocialTrackingResource
(
)
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsThirdPartySocialTrackingResource
;
}
bool
performStorageChecks
=
aRequireThirdPartyCheck
?
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
:
true
;
if
(
performStorageChecks
&
&
ShouldAllowAccessFor
(
aChannel
aURI
?
aURI
:
uri
.
get
(
)
aRejectedReason
)
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsStorageAccessPermissionGranted
;
}
if
(
aNotify
&
&
!
result
.
contains
(
ThirdPartyAnalysis
:
:
IsStorageAccessPermissionGranted
)
)
{
ContentBlockingNotifier
:
:
OnDecision
(
aChannel
ContentBlockingNotifier
:
:
BlockingDecision
:
:
eBlock
*
aRejectedReason
)
;
}
}
return
result
;
}
