#
include
"
ThirdPartyUtil
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsIClassifiedChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
NS_IMPL_ISUPPORTS
(
ThirdPartyUtil
mozIThirdPartyUtil
)
static
mozilla
:
:
LazyLogModule
gThirdPartyLog
(
"
thirdPartyUtil
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
MOZ_LOG
(
gThirdPartyLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
static
mozilla
:
:
StaticRefPtr
<
ThirdPartyUtil
>
gService
;
void
ThirdPartyUtil
:
:
Startup
(
)
{
nsCOMPtr
<
mozIThirdPartyUtil
>
tpu
;
if
(
NS_WARN_IF
(
!
(
tpu
=
do_GetService
(
THIRDPARTYUTIL_CONTRACTID
)
)
)
)
{
NS_WARNING
(
"
Failed
to
get
third
party
util
!
"
)
;
}
}
nsresult
ThirdPartyUtil
:
:
Init
(
)
{
NS_ENSURE_TRUE
(
NS_IsMainThread
(
)
NS_ERROR_NOT_AVAILABLE
)
;
MOZ_ASSERT
(
!
gService
)
;
gService
=
this
;
mozilla
:
:
ClearOnShutdown
(
&
gService
)
;
mTLDService
=
nsEffectiveTLDService
:
:
GetInstance
(
)
;
return
mTLDService
?
NS_OK
:
NS_ERROR_FAILURE
;
}
ThirdPartyUtil
:
:
~
ThirdPartyUtil
(
)
{
gService
=
nullptr
;
}
ThirdPartyUtil
*
ThirdPartyUtil
:
:
GetInstance
(
)
{
if
(
gService
)
{
return
gService
;
}
nsCOMPtr
<
mozIThirdPartyUtil
>
tpuService
=
mozilla
:
:
services
:
:
GetThirdPartyUtil
(
)
;
if
(
!
tpuService
)
{
return
nullptr
;
}
MOZ_ASSERT
(
gService
"
gService
must
have
been
initialized
in
nsEffectiveTLDService
:
:
Init
"
)
;
return
gService
;
}
nsresult
ThirdPartyUtil
:
:
IsThirdPartyInternal
(
const
nsCString
&
aFirstDomain
nsIURI
*
aSecondURI
bool
*
aResult
)
{
if
(
!
aSecondURI
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsAutoCString
secondDomain
;
nsresult
rv
=
GetBaseDomain
(
aSecondURI
secondDomain
)
;
LOG
(
(
"
ThirdPartyUtil
:
:
IsThirdPartyInternal
%
s
=
?
%
s
"
aFirstDomain
.
get
(
)
secondDomain
.
get
(
)
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
*
aResult
=
IsThirdPartyInternal
(
aFirstDomain
secondDomain
)
;
return
NS_OK
;
}
nsCString
ThirdPartyUtil
:
:
GetBaseDomainFromWindow
(
nsPIDOMWindowOuter
*
aWindow
)
{
mozilla
:
:
dom
:
:
Document
*
doc
=
aWindow
?
aWindow
-
>
GetExtantDoc
(
)
:
nullptr
;
if
(
!
doc
)
{
return
EmptyCString
(
)
;
}
return
doc
-
>
GetBaseDomain
(
)
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetPrincipalFromWindow
(
mozIDOMWindowProxy
*
aWin
nsIPrincipal
*
*
result
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
scriptObjPrin
=
do_QueryInterface
(
aWin
)
;
if
(
!
scriptObjPrin
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsIPrincipal
>
prin
=
scriptObjPrin
-
>
GetPrincipal
(
)
;
if
(
!
prin
)
{
return
NS_ERROR_INVALID_ARG
;
}
prin
.
forget
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetURIFromWindow
(
mozIDOMWindowProxy
*
aWin
nsIURI
*
*
result
)
{
nsCOMPtr
<
nsIPrincipal
>
prin
;
nsresult
rv
=
GetPrincipalFromWindow
(
aWin
getter_AddRefs
(
prin
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
prin
-
>
GetIsNullPrincipal
(
)
)
{
LOG
(
(
"
ThirdPartyUtil
:
:
GetURIFromWindow
can
'
t
use
null
principal
\
n
"
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
rv
=
prin
-
>
GetURI
(
result
)
;
return
rv
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetContentBlockingAllowListPrincipalFromWindow
(
mozIDOMWindowProxy
*
aWin
nsIURI
*
aURIBeingLoaded
nsIPrincipal
*
*
result
)
{
nsPIDOMWindowOuter
*
outerWindow
=
nsPIDOMWindowOuter
:
:
From
(
aWin
)
;
nsPIDOMWindowInner
*
innerWindow
=
outerWindow
-
>
GetCurrentInnerWindow
(
)
;
Document
*
doc
=
innerWindow
?
innerWindow
-
>
GetExtantDoc
(
)
:
nullptr
;
if
(
!
doc
)
{
return
GetPrincipalFromWindow
(
aWin
result
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
doc
-
>
GetContentBlockingAllowListPrincipal
(
)
;
if
(
aURIBeingLoaded
&
&
principal
&
&
principal
-
>
GetIsNullPrincipal
(
)
)
{
nsIDocShell
*
docShell
=
doc
-
>
GetDocShell
(
)
;
OriginAttributes
attrs
=
docShell
?
nsDocShell
:
:
Cast
(
docShell
)
-
>
GetOriginAttributes
(
)
:
OriginAttributes
(
)
;
principal
=
doc
-
>
RecomputeContentBlockingAllowListPrincipal
(
aURIBeingLoaded
attrs
)
;
}
if
(
!
principal
|
|
!
principal
-
>
GetIsContentPrincipal
(
)
)
{
LOG
(
(
"
ThirdPartyUtil
:
:
GetContentBlockingAllowListPrincipalFromWindow
can
'
t
"
"
use
null
principal
\
n
"
)
)
;
return
NS_ERROR_INVALID_ARG
;
}
principal
.
forget
(
result
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
IsThirdPartyURI
(
nsIURI
*
aFirstURI
nsIURI
*
aSecondURI
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aFirstURI
)
;
NS_ENSURE_ARG
(
aSecondURI
)
;
NS_ASSERTION
(
aResult
"
null
outparam
pointer
"
)
;
nsAutoCString
firstHost
;
nsresult
rv
=
GetBaseDomain
(
aFirstURI
firstHost
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
IsThirdPartyInternal
(
firstHost
aSecondURI
aResult
)
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
IsThirdPartyWindow
(
mozIDOMWindowProxy
*
aWindow
nsIURI
*
aURI
bool
*
aResult
)
{
NS_ENSURE_ARG
(
aWindow
)
;
NS_ASSERTION
(
aResult
"
null
outparam
pointer
"
)
;
bool
result
;
if
(
aURI
&
&
!
NS_IsAboutBlank
(
aURI
)
)
{
nsCOMPtr
<
nsIPrincipal
>
prin
;
nsresult
rv
=
GetPrincipalFromWindow
(
aWindow
getter_AddRefs
(
prin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
prin
-
>
IsThirdPartyURI
(
aURI
&
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
result
)
{
*
aResult
=
true
;
return
NS_OK
;
}
}
nsPIDOMWindowOuter
*
current
=
nsPIDOMWindowOuter
:
:
From
(
aWindow
)
;
do
{
nsPIDOMWindowOuter
*
parent
=
current
-
>
GetInProcessScriptableParent
(
)
;
if
(
parent
=
=
current
)
{
auto
*
const
browsingContext
=
current
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
browsingContext
)
;
*
aResult
=
browsingContext
-
>
IsContentSubframe
(
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrincipal
>
currentPrincipal
;
nsresult
rv
=
GetPrincipalFromWindow
(
current
getter_AddRefs
(
currentPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIPrincipal
>
parentPrincipal
;
rv
=
GetPrincipalFromWindow
(
parent
getter_AddRefs
(
parentPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
currentPrincipal
-
>
IsThirdPartyPrincipal
(
parentPrincipal
&
result
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
result
)
{
*
aResult
=
true
;
return
NS_OK
;
}
current
=
parent
;
}
while
(
1
)
;
MOZ_ASSERT_UNREACHABLE
(
"
should
'
ve
returned
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
IsThirdPartyChannel
(
nsIChannel
*
aChannel
nsIURI
*
aURI
bool
*
aResult
)
{
LOG
(
(
"
ThirdPartyUtil
:
:
IsThirdPartyChannel
[
channel
=
%
p
]
"
aChannel
)
)
;
NS_ENSURE_ARG
(
aChannel
)
;
NS_ASSERTION
(
aResult
"
null
outparam
pointer
"
)
;
nsresult
rv
;
bool
doForce
=
false
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannelInternal
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannelInternal
)
{
uint32_t
flags
=
0
;
mozilla
:
:
Unused
<
<
httpChannelInternal
-
>
GetThirdPartyFlags
(
&
flags
)
;
doForce
=
(
flags
&
nsIHttpChannelInternal
:
:
THIRD_PARTY_FORCE_ALLOW
)
;
if
(
doForce
&
&
!
aURI
)
{
*
aResult
=
false
;
return
NS_OK
;
}
}
bool
parentIsThird
=
false
;
nsCOMPtr
<
nsIURI
>
channelURI
;
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsAutoCString
channelDomain
;
rv
=
GetBaseDomain
(
channelURI
channelDomain
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
!
doForce
)
{
if
(
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
)
{
parentIsThird
=
loadInfo
-
>
GetIsInThirdPartyContext
(
)
;
if
(
!
parentIsThird
&
&
loadInfo
-
>
GetExternalContentPolicyType
(
)
!
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
)
{
rv
=
loadInfo
-
>
LoadingPrincipal
(
)
-
>
IsThirdPartyURI
(
channelURI
&
parentIsThird
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
}
else
{
NS_WARNING
(
"
Found
channel
with
no
loadinfo
assuming
third
-
party
request
"
)
;
parentIsThird
=
true
;
}
}
if
(
!
aURI
|
|
parentIsThird
)
{
*
aResult
=
parentIsThird
;
return
NS_OK
;
}
return
IsThirdPartyInternal
(
channelDomain
aURI
aResult
)
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetTopWindowForChannel
(
nsIChannel
*
aChannel
nsIURI
*
aURIBeingLoaded
mozIDOMWindowProxy
*
*
aWin
)
{
NS_ENSURE_ARG
(
aWin
)
;
nsCOMPtr
<
nsILoadContext
>
ctx
;
NS_QueryNotificationCallbacks
(
aChannel
ctx
)
;
if
(
!
ctx
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
window
;
ctx
-
>
GetAssociatedWindow
(
getter_AddRefs
(
window
)
)
;
if
(
!
window
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
nsGlobalWindowOuter
:
:
Cast
(
window
)
-
>
GetTopExcludingExtensionAccessibleContentFrames
(
aURIBeingLoaded
)
;
top
.
forget
(
aWin
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetBaseDomain
(
nsIURI
*
aHostURI
nsACString
&
aBaseDomain
)
{
if
(
!
aHostURI
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsresult
rv
=
mTLDService
-
>
GetBaseDomain
(
aHostURI
0
aBaseDomain
)
;
if
(
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
rv
=
aHostURI
-
>
GetAsciiHost
(
aBaseDomain
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aBaseDomain
.
Length
(
)
=
=
1
&
&
aBaseDomain
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
if
(
aBaseDomain
.
IsEmpty
(
)
&
&
!
aHostURI
-
>
SchemeIs
(
"
file
"
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
NS_IMETHODIMP
ThirdPartyUtil
:
:
GetBaseDomainFromSchemeHost
(
const
nsACString
&
aScheme
const
nsACString
&
aAsciiHost
nsACString
&
aBaseDomain
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsAscii
(
aAsciiHost
)
)
;
nsresult
rv
=
mTLDService
-
>
GetBaseDomainFromHost
(
aAsciiHost
0
aBaseDomain
)
;
if
(
rv
=
=
NS_ERROR_HOST_IS_IP_ADDRESS
|
|
rv
=
=
NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS
)
{
aBaseDomain
=
aAsciiHost
;
rv
=
NS_OK
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aBaseDomain
.
Length
(
)
=
=
1
&
&
aBaseDomain
.
Last
(
)
=
=
'
.
'
)
return
NS_ERROR_INVALID_ARG
;
if
(
aBaseDomain
.
IsEmpty
(
)
&
&
!
aScheme
.
EqualsLiteral
(
"
file
"
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
ThirdPartyAnalysisResult
)
ThirdPartyUtil
:
:
AnalyzeChannel
(
nsIChannel
*
aChannel
bool
aNotify
nsIURI
*
aURI
RequireThirdPartyCheck
aRequireThirdPartyCheck
uint32_t
*
aRejectedReason
)
{
MOZ_ASSERT_IF
(
aNotify
aRejectedReason
)
;
ThirdPartyAnalysisResult
result
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
!
aURI
&
&
aChannel
)
{
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
?
aChannel
-
>
LoadInfo
(
)
:
nullptr
;
bool
isForeign
=
true
;
if
(
aChannel
&
&
(
!
aRequireThirdPartyCheck
|
|
aRequireThirdPartyCheck
(
loadInfo
)
)
)
{
IsThirdPartyChannel
(
aChannel
aURI
?
aURI
:
uri
.
get
(
)
&
isForeign
)
;
}
if
(
isForeign
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsForeign
;
}
nsCOMPtr
<
nsIClassifiedChannel
>
classifiedChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
classifiedChannel
)
{
if
(
classifiedChannel
-
>
IsTrackingResource
(
)
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsTrackingResource
;
}
if
(
classifiedChannel
-
>
IsSocialTrackingResource
(
)
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsSocialTrackingResource
;
}
bool
performStorageChecks
=
aRequireThirdPartyCheck
?
result
.
contains
(
ThirdPartyAnalysis
:
:
IsForeign
)
:
true
;
if
(
performStorageChecks
&
&
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
aChannel
aURI
?
aURI
:
uri
.
get
(
)
aRejectedReason
)
)
{
result
+
=
ThirdPartyAnalysis
:
:
IsFirstPartyStorageAccessGranted
;
}
if
(
aNotify
&
&
!
result
.
contains
(
ThirdPartyAnalysis
:
:
IsFirstPartyStorageAccessGranted
)
)
{
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
aChannel
AntiTrackingCommon
:
:
BlockingDecision
:
:
eBlock
*
aRejectedReason
)
;
}
}
return
result
;
}
