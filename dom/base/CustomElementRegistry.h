#
ifndef
mozilla_dom_CustomElementRegistry_h
#
define
mozilla_dom_CustomElementRegistry_h
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistryBinding
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FunctionBinding
.
h
"
#
include
"
mozilla
/
dom
/
WebComponentsBinding
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsContentUtils
.
h
"
class
nsDocument
;
namespace
mozilla
{
namespace
dom
{
struct
CustomElementData
;
struct
ElementDefinitionOptions
;
class
CallbackFunction
;
class
CustomElementReaction
;
class
DocGroup
;
class
Function
;
class
Promise
;
struct
LifecycleCallbackArgs
{
nsString
name
;
nsString
oldValue
;
nsString
newValue
;
nsString
namespaceURI
;
}
;
struct
LifecycleAdoptedCallbackArgs
{
nsCOMPtr
<
nsIDocument
>
mOldDocument
;
nsCOMPtr
<
nsIDocument
>
mNewDocument
;
}
;
class
CustomElementCallback
{
public
:
CustomElementCallback
(
Element
*
aThisObject
nsIDocument
:
:
ElementCallbackType
aCallbackType
CallbackFunction
*
aCallback
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
const
;
void
Call
(
)
;
void
SetArgs
(
LifecycleCallbackArgs
&
aArgs
)
{
MOZ_ASSERT
(
mType
=
=
nsIDocument
:
:
eAttributeChanged
"
Arguments
are
only
used
by
attribute
changed
callback
.
"
)
;
mArgs
=
aArgs
;
}
void
SetAdoptedCallbackArgs
(
LifecycleAdoptedCallbackArgs
&
aAdoptedCallbackArgs
)
{
MOZ_ASSERT
(
mType
=
=
nsIDocument
:
:
eAdopted
"
Arguments
are
only
used
by
adopted
callback
.
"
)
;
mAdoptedCallbackArgs
=
aAdoptedCallbackArgs
;
}
private
:
RefPtr
<
Element
>
mThisObject
;
RefPtr
<
CallbackFunction
>
mCallback
;
nsIDocument
:
:
ElementCallbackType
mType
;
LifecycleCallbackArgs
mArgs
;
LifecycleAdoptedCallbackArgs
mAdoptedCallbackArgs
;
}
;
class
CustomElementConstructor
final
:
public
CallbackFunction
{
public
:
explicit
CustomElementConstructor
(
CallbackFunction
*
aOther
)
:
CallbackFunction
(
aOther
)
{
MOZ_ASSERT
(
JS
:
:
IsConstructor
(
mCallback
)
)
;
}
already_AddRefed
<
Element
>
Construct
(
const
char
*
aExecutionReason
ErrorResult
&
aRv
)
;
}
;
struct
CustomElementData
{
NS_INLINE_DECL_REFCOUNTING
(
CustomElementData
)
enum
class
State
{
eUndefined
eFailed
eCustom
}
;
explicit
CustomElementData
(
nsAtom
*
aType
)
;
CustomElementData
(
nsAtom
*
aType
State
aState
)
;
State
mState
;
AutoTArray
<
UniquePtr
<
CustomElementReaction
>
3
>
mReactionQueue
;
void
SetCustomElementDefinition
(
CustomElementDefinition
*
aDefinition
)
;
CustomElementDefinition
*
GetCustomElementDefinition
(
)
;
nsAtom
*
GetCustomElementType
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
const
;
void
Unlink
(
)
;
nsAtom
*
GetIs
(
Element
*
aElement
)
{
return
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
mType
?
nullptr
:
mType
.
get
(
)
;
}
private
:
virtual
~
CustomElementData
(
)
{
}
RefPtr
<
nsAtom
>
mType
;
RefPtr
<
CustomElementDefinition
>
mCustomElementDefinition
;
}
;
#
define
ALREADY_CONSTRUCTED_MARKER
nullptr
struct
CustomElementDefinition
{
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
CustomElementDefinition
)
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
CustomElementDefinition
)
CustomElementDefinition
(
nsAtom
*
aType
nsAtom
*
aLocalName
Function
*
aConstructor
nsTArray
<
RefPtr
<
nsAtom
>
>
&
&
aObservedAttributes
UniquePtr
<
LifecycleCallbacks
>
&
&
aCallbacks
)
;
RefPtr
<
nsAtom
>
mType
;
RefPtr
<
nsAtom
>
mLocalName
;
RefPtr
<
CustomElementConstructor
>
mConstructor
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mObservedAttributes
;
UniquePtr
<
LifecycleCallbacks
>
mCallbacks
;
nsTArray
<
RefPtr
<
Element
>
>
mConstructionStack
;
bool
IsCustomBuiltIn
(
)
{
return
mType
!
=
mLocalName
;
}
bool
IsInObservedAttributeList
(
nsAtom
*
aName
)
{
if
(
mObservedAttributes
.
IsEmpty
(
)
)
{
return
false
;
}
return
mObservedAttributes
.
Contains
(
aName
)
;
}
private
:
~
CustomElementDefinition
(
)
{
}
}
;
class
CustomElementReaction
{
public
:
virtual
~
CustomElementReaction
(
)
=
default
;
virtual
void
Invoke
(
Element
*
aElement
ErrorResult
&
aRv
)
=
0
;
virtual
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
const
=
0
;
bool
IsUpgradeReaction
(
)
{
return
mIsUpgradeReaction
;
}
protected
:
bool
mIsUpgradeReaction
=
false
;
}
;
class
CustomElementReactionsStack
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
CustomElementReactionsStack
)
CustomElementReactionsStack
(
)
:
mIsBackupQueueProcessing
(
false
)
mRecursionDepth
(
0
)
mIsElementQueuePushedForCurrentRecursionDepth
(
false
)
{
}
typedef
AutoTArray
<
RefPtr
<
Element
>
3
>
ElementQueue
;
void
EnqueueUpgradeReaction
(
Element
*
aElement
CustomElementDefinition
*
aDefinition
)
;
void
EnqueueCallbackReaction
(
Element
*
aElement
UniquePtr
<
CustomElementCallback
>
aCustomElementCallback
)
;
bool
EnterCEReactions
(
)
{
bool
temp
=
mIsElementQueuePushedForCurrentRecursionDepth
;
mRecursionDepth
+
+
;
mIsElementQueuePushedForCurrentRecursionDepth
=
false
;
return
temp
;
}
void
LeaveCEReactions
(
JSContext
*
aCx
bool
aWasElementQueuePushed
)
{
MOZ_ASSERT
(
mRecursionDepth
)
;
if
(
mIsElementQueuePushedForCurrentRecursionDepth
)
{
Maybe
<
JS
:
:
AutoSaveExceptionState
>
ases
;
if
(
aCx
)
{
ases
.
emplace
(
aCx
)
;
}
PopAndInvokeElementQueue
(
)
;
}
mRecursionDepth
-
-
;
mIsElementQueuePushedForCurrentRecursionDepth
=
aWasElementQueuePushed
;
MOZ_ASSERT_IF
(
!
mRecursionDepth
mReactionsStack
.
IsEmpty
(
)
)
;
}
private
:
~
CustomElementReactionsStack
(
)
{
}
;
void
CreateAndPushElementQueue
(
)
;
void
PopAndInvokeElementQueue
(
)
;
AutoTArray
<
UniquePtr
<
ElementQueue
>
8
>
mReactionsStack
;
ElementQueue
mBackupQueue
;
bool
mIsBackupQueueProcessing
;
void
InvokeBackupQueue
(
)
;
void
InvokeReactions
(
ElementQueue
*
aElementQueue
nsIGlobalObject
*
aGlobal
)
;
void
Enqueue
(
Element
*
aElement
CustomElementReaction
*
aReaction
)
;
uint32_t
mRecursionDepth
;
bool
mIsElementQueuePushedForCurrentRecursionDepth
;
private
:
class
BackupQueueMicroTask
final
:
public
mozilla
:
:
MicroTaskRunnable
{
public
:
explicit
BackupQueueMicroTask
(
CustomElementReactionsStack
*
aReactionStack
)
:
MicroTaskRunnable
(
)
mReactionStack
(
aReactionStack
)
{
MOZ_ASSERT
(
!
mReactionStack
-
>
mIsBackupQueueProcessing
"
mIsBackupQueueProcessing
should
be
initially
false
"
)
;
mReactionStack
-
>
mIsBackupQueueProcessing
=
true
;
}
virtual
void
Run
(
AutoSlowOperation
&
aAso
)
override
{
mReactionStack
-
>
InvokeBackupQueue
(
)
;
mReactionStack
-
>
mIsBackupQueueProcessing
=
false
;
}
private
:
RefPtr
<
CustomElementReactionsStack
>
mReactionStack
;
}
;
}
;
class
CustomElementRegistry
final
:
public
nsISupports
public
nsWrapperCache
{
friend
class
:
:
nsDocument
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
CustomElementRegistry
)
public
:
static
bool
IsCustomElementEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsCustomElementEnabled
(
nsIDocument
*
aDoc
)
;
explicit
CustomElementRegistry
(
nsPIDOMWindowInner
*
aWindow
)
;
private
:
class
RunCustomElementCreationCallback
:
public
mozilla
:
:
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
RunCustomElementCreationCallback
(
CustomElementRegistry
*
aRegistry
nsAtom
*
aAtom
CustomElementCreationCallback
*
aCallback
)
:
mozilla
:
:
Runnable
(
"
CustomElementRegistry
:
:
RunCustomElementCreationCallback
"
)
mRegistry
(
aRegistry
)
mAtom
(
aAtom
)
mCallback
(
aCallback
)
{
}
private
:
RefPtr
<
CustomElementRegistry
>
mRegistry
;
RefPtr
<
nsAtom
>
mAtom
;
RefPtr
<
CustomElementCreationCallback
>
mCallback
;
}
;
public
:
CustomElementDefinition
*
LookupCustomElementDefinition
(
nsAtom
*
aNameAtom
nsAtom
*
aTypeAtom
)
;
CustomElementDefinition
*
LookupCustomElementDefinition
(
JSContext
*
aCx
JSObject
*
aConstructor
)
const
;
static
void
EnqueueLifecycleCallback
(
nsIDocument
:
:
ElementCallbackType
aType
Element
*
aCustomElement
LifecycleCallbackArgs
*
aArgs
LifecycleAdoptedCallbackArgs
*
aAdoptedCallbackArgs
CustomElementDefinition
*
aDefinition
)
;
static
void
Upgrade
(
Element
*
aElement
CustomElementDefinition
*
aDefinition
ErrorResult
&
aRv
)
;
void
RegisterUnresolvedElement
(
Element
*
aElement
nsAtom
*
aTypeName
=
nullptr
)
;
void
UnregisterUnresolvedElement
(
Element
*
aElement
nsAtom
*
aTypeName
=
nullptr
)
;
inline
void
RegisterCallbackUpgradeElement
(
Element
*
aElement
nsAtom
*
aTypeName
=
nullptr
)
{
if
(
mElementCreationCallbacksUpgradeCandidatesMap
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
nsAtom
>
typeName
=
aTypeName
;
if
(
!
typeName
)
{
typeName
=
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
nsTHashtable
<
nsRefPtrHashKey
<
nsIWeakReference
>
>
*
elements
=
mElementCreationCallbacksUpgradeCandidatesMap
.
Get
(
typeName
)
;
if
(
!
elements
)
{
return
;
}
nsWeakPtr
elem
=
do_GetWeakReference
(
aElement
)
;
elements
-
>
PutEntry
(
elem
)
;
}
private
:
~
CustomElementRegistry
(
)
;
static
UniquePtr
<
CustomElementCallback
>
CreateCustomElementCallback
(
nsIDocument
:
:
ElementCallbackType
aType
Element
*
aCustomElement
LifecycleCallbackArgs
*
aArgs
LifecycleAdoptedCallbackArgs
*
aAdoptedCallbackArgs
CustomElementDefinition
*
aDefinition
)
;
void
UpgradeCandidates
(
nsAtom
*
aKey
CustomElementDefinition
*
aDefinition
ErrorResult
&
aRv
)
;
typedef
nsRefPtrHashtable
<
nsRefPtrHashKey
<
nsAtom
>
CustomElementDefinition
>
DefinitionMap
;
typedef
nsRefPtrHashtable
<
nsRefPtrHashKey
<
nsAtom
>
CustomElementCreationCallback
>
ElementCreationCallbackMap
;
typedef
nsClassHashtable
<
nsRefPtrHashKey
<
nsAtom
>
nsTHashtable
<
nsRefPtrHashKey
<
nsIWeakReference
>
>
>
CandidateMap
;
typedef
JS
:
:
GCHashMap
<
JS
:
:
Heap
<
JSObject
*
>
RefPtr
<
nsAtom
>
js
:
:
MovableCellHasher
<
JS
:
:
Heap
<
JSObject
*
>
>
js
:
:
SystemAllocPolicy
>
ConstructorMap
;
DefinitionMap
mCustomDefinitions
;
ElementCreationCallbackMap
mElementCreationCallbacks
;
ConstructorMap
mConstructors
;
typedef
nsRefPtrHashtable
<
nsRefPtrHashKey
<
nsAtom
>
Promise
>
WhenDefinedPromiseMap
;
WhenDefinedPromiseMap
mWhenDefinedPromiseMap
;
CandidateMap
mCandidatesMap
;
CandidateMap
mElementCreationCallbacksUpgradeCandidatesMap
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
bool
mIsCustomDefinitionRunning
;
private
:
class
MOZ_RAII
AutoSetRunningFlag
final
{
public
:
explicit
AutoSetRunningFlag
(
CustomElementRegistry
*
aRegistry
)
:
mRegistry
(
aRegistry
)
{
MOZ_ASSERT
(
!
mRegistry
-
>
mIsCustomDefinitionRunning
"
IsCustomDefinitionRunning
flag
should
be
initially
false
"
)
;
mRegistry
-
>
mIsCustomDefinitionRunning
=
true
;
}
~
AutoSetRunningFlag
(
)
{
mRegistry
-
>
mIsCustomDefinitionRunning
=
false
;
}
private
:
CustomElementRegistry
*
mRegistry
;
}
;
public
:
nsISupports
*
GetParentObject
(
)
const
;
DocGroup
*
GetDocGroup
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
Define
(
JSContext
*
aCx
const
nsAString
&
aName
Function
&
aFunctionConstructor
const
ElementDefinitionOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
Get
(
JSContext
*
cx
const
nsAString
&
name
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
)
;
already_AddRefed
<
Promise
>
WhenDefined
(
const
nsAString
&
aName
ErrorResult
&
aRv
)
;
void
SetElementCreationCallback
(
const
nsAString
&
aName
CustomElementCreationCallback
&
aCallback
ErrorResult
&
aRv
)
;
void
Upgrade
(
nsINode
&
aRoot
)
;
}
;
class
MOZ_RAII
AutoCEReaction
final
{
public
:
AutoCEReaction
(
CustomElementReactionsStack
*
aReactionsStack
JSContext
*
aCx
)
:
mReactionsStack
(
aReactionsStack
)
mCx
(
aCx
)
{
mIsElementQueuePushedForPreviousRecursionDepth
=
mReactionsStack
-
>
EnterCEReactions
(
)
;
}
~
AutoCEReaction
(
)
{
mReactionsStack
-
>
LeaveCEReactions
(
mCx
mIsElementQueuePushedForPreviousRecursionDepth
)
;
}
private
:
RefPtr
<
CustomElementReactionsStack
>
mReactionsStack
;
JSContext
*
mCx
;
bool
mIsElementQueuePushedForPreviousRecursionDepth
;
}
;
}
}
#
endif
