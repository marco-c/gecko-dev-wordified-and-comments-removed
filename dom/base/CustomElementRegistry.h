#
ifndef
mozilla_dom_CustomElementRegistry_h
#
define
mozilla_dom_CustomElementRegistry_h
#
include
"
js
/
GCHashTable
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FunctionBinding
.
h
"
#
include
"
mozilla
/
dom
/
WebComponentsBinding
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsContentUtils
.
h
"
class
nsDocument
;
namespace
mozilla
{
namespace
dom
{
struct
CustomElementData
;
struct
ElementDefinitionOptions
;
class
CallbackFunction
;
class
CustomElementReaction
;
class
Function
;
class
Promise
;
struct
LifecycleCallbackArgs
{
nsString
name
;
nsString
oldValue
;
nsString
newValue
;
nsString
namespaceURI
;
}
;
struct
LifecycleAdoptedCallbackArgs
{
nsCOMPtr
<
nsIDocument
>
mOldDocument
;
nsCOMPtr
<
nsIDocument
>
mNewDocument
;
}
;
class
CustomElementCallback
{
public
:
CustomElementCallback
(
Element
*
aThisObject
nsIDocument
:
:
ElementCallbackType
aCallbackType
CallbackFunction
*
aCallback
CustomElementData
*
aOwnerData
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
const
;
void
Call
(
)
;
void
SetArgs
(
LifecycleCallbackArgs
&
aArgs
)
{
MOZ_ASSERT
(
mType
=
=
nsIDocument
:
:
eAttributeChanged
"
Arguments
are
only
used
by
attribute
changed
callback
.
"
)
;
mArgs
=
aArgs
;
}
void
SetAdoptedCallbackArgs
(
LifecycleAdoptedCallbackArgs
&
aAdoptedCallbackArgs
)
{
MOZ_ASSERT
(
mType
=
=
nsIDocument
:
:
eAdopted
"
Arguments
are
only
used
by
adopted
callback
.
"
)
;
mAdoptedCallbackArgs
=
aAdoptedCallbackArgs
;
}
private
:
RefPtr
<
Element
>
mThisObject
;
RefPtr
<
CallbackFunction
>
mCallback
;
nsIDocument
:
:
ElementCallbackType
mType
;
LifecycleCallbackArgs
mArgs
;
LifecycleAdoptedCallbackArgs
mAdoptedCallbackArgs
;
CustomElementData
*
mOwnerData
;
}
;
class
CustomElementConstructor
final
:
public
CallbackFunction
{
public
:
explicit
CustomElementConstructor
(
CallbackFunction
*
aOther
)
:
CallbackFunction
(
aOther
)
{
MOZ_ASSERT
(
JS
:
:
IsConstructor
(
mCallback
)
)
;
}
already_AddRefed
<
Element
>
Construct
(
const
char
*
aExecutionReason
ErrorResult
&
aRv
)
;
}
;
struct
CustomElementData
{
NS_INLINE_DECL_REFCOUNTING
(
CustomElementData
)
enum
class
State
{
eUndefined
eFailed
eCustom
}
;
explicit
CustomElementData
(
nsAtom
*
aType
)
;
CustomElementData
(
nsAtom
*
aType
State
aState
)
;
RefPtr
<
nsAtom
>
mType
;
bool
mElementIsBeingCreated
;
bool
mCreatedCallbackInvoked
;
State
mState
;
AutoTArray
<
UniquePtr
<
CustomElementReaction
>
3
>
mReactionQueue
;
RefPtr
<
CustomElementDefinition
>
mCustomElementDefinition
;
void
SetCustomElementDefinition
(
CustomElementDefinition
*
aDefinition
)
{
MOZ_ASSERT
(
!
mCustomElementDefinition
)
;
mCustomElementDefinition
=
aDefinition
;
}
CustomElementDefinition
*
GetCustomElementDefinition
(
)
{
return
mCustomElementDefinition
;
}
private
:
virtual
~
CustomElementData
(
)
{
}
}
;
#
define
ALEADY_CONSTRUCTED_MARKER
nullptr
struct
CustomElementDefinition
{
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_NATIVE_CLASS
(
CustomElementDefinition
)
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
CustomElementDefinition
)
CustomElementDefinition
(
nsAtom
*
aType
nsAtom
*
aLocalName
Function
*
aConstructor
nsTArray
<
RefPtr
<
nsAtom
>
>
&
&
aObservedAttributes
JSObject
*
aPrototype
mozilla
:
:
dom
:
:
LifecycleCallbacks
*
aCallbacks
uint32_t
aDocOrder
)
;
RefPtr
<
nsAtom
>
mType
;
RefPtr
<
nsAtom
>
mLocalName
;
RefPtr
<
CustomElementConstructor
>
mConstructor
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mObservedAttributes
;
JS
:
:
Heap
<
JSObject
*
>
mPrototype
;
UniquePtr
<
mozilla
:
:
dom
:
:
LifecycleCallbacks
>
mCallbacks
;
nsTArray
<
RefPtr
<
nsGenericHTMLElement
>
>
mConstructionStack
;
uint32_t
mDocOrder
;
bool
IsCustomBuiltIn
(
)
{
return
mType
!
=
mLocalName
;
}
bool
IsInObservedAttributeList
(
nsAtom
*
aName
)
{
if
(
mObservedAttributes
.
IsEmpty
(
)
)
{
return
false
;
}
return
mObservedAttributes
.
Contains
(
aName
)
;
}
private
:
~
CustomElementDefinition
(
)
{
}
}
;
class
CustomElementReaction
{
public
:
virtual
~
CustomElementReaction
(
)
=
default
;
virtual
void
Invoke
(
Element
*
aElement
ErrorResult
&
aRv
)
=
0
;
virtual
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
const
{
}
}
;
class
CustomElementUpgradeReaction
final
:
public
CustomElementReaction
{
public
:
explicit
CustomElementUpgradeReaction
(
CustomElementDefinition
*
aDefinition
)
:
mDefinition
(
aDefinition
)
{
}
private
:
virtual
void
Invoke
(
Element
*
aElement
ErrorResult
&
aRv
)
override
;
CustomElementDefinition
*
mDefinition
;
}
;
class
CustomElementCallbackReaction
final
:
public
CustomElementReaction
{
public
:
explicit
CustomElementCallbackReaction
(
UniquePtr
<
CustomElementCallback
>
aCustomElementCallback
)
:
mCustomElementCallback
(
Move
(
aCustomElementCallback
)
)
{
}
virtual
void
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
const
override
{
mCustomElementCallback
-
>
Traverse
(
aCb
)
;
}
private
:
virtual
void
Invoke
(
Element
*
aElement
ErrorResult
&
aRv
)
override
;
UniquePtr
<
CustomElementCallback
>
mCustomElementCallback
;
}
;
class
CustomElementReactionsStack
{
public
:
NS_INLINE_DECL_REFCOUNTING
(
CustomElementReactionsStack
)
CustomElementReactionsStack
(
)
:
mIsBackupQueueProcessing
(
false
)
{
}
typedef
AutoTArray
<
RefPtr
<
Element
>
1
>
ElementQueue
;
void
EnqueueUpgradeReaction
(
Element
*
aElement
CustomElementDefinition
*
aDefinition
)
;
void
EnqueueCallbackReaction
(
Element
*
aElement
UniquePtr
<
CustomElementCallback
>
aCustomElementCallback
)
;
void
CreateAndPushElementQueue
(
)
;
void
PopAndInvokeElementQueue
(
)
;
private
:
~
CustomElementReactionsStack
(
)
{
}
;
AutoTArray
<
UniquePtr
<
ElementQueue
>
8
>
mReactionsStack
;
ElementQueue
mBackupQueue
;
bool
mIsBackupQueueProcessing
;
void
InvokeBackupQueue
(
)
;
void
InvokeReactions
(
ElementQueue
*
aElementQueue
nsIGlobalObject
*
aGlobal
)
;
void
Enqueue
(
Element
*
aElement
CustomElementReaction
*
aReaction
)
;
private
:
class
ProcessBackupQueueRunnable
:
public
mozilla
:
:
Runnable
{
public
:
explicit
ProcessBackupQueueRunnable
(
CustomElementReactionsStack
*
aReactionStack
)
:
Runnable
(
"
dom
:
:
CustomElementReactionsStack
:
:
ProcessBackupQueueRunnable
"
)
mReactionStack
(
aReactionStack
)
{
MOZ_ASSERT
(
!
mReactionStack
-
>
mIsBackupQueueProcessing
"
mIsBackupQueueProcessing
should
be
initially
false
"
)
;
mReactionStack
-
>
mIsBackupQueueProcessing
=
true
;
}
NS_IMETHOD
Run
(
)
override
{
mReactionStack
-
>
InvokeBackupQueue
(
)
;
mReactionStack
-
>
mIsBackupQueueProcessing
=
false
;
return
NS_OK
;
}
private
:
RefPtr
<
CustomElementReactionsStack
>
mReactionStack
;
}
;
}
;
class
CustomElementRegistry
final
:
public
nsISupports
public
nsWrapperCache
{
friend
class
:
:
nsDocument
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
CustomElementRegistry
)
public
:
static
bool
IsCustomElementEnabled
(
JSContext
*
aCx
=
nullptr
JSObject
*
aObject
=
nullptr
)
{
return
nsContentUtils
:
:
IsCustomElementsEnabled
(
)
|
|
nsContentUtils
:
:
IsWebComponentsEnabled
(
)
;
}
explicit
CustomElementRegistry
(
nsPIDOMWindowInner
*
aWindow
)
;
CustomElementDefinition
*
LookupCustomElementDefinition
(
const
nsAString
&
aLocalName
const
nsAString
*
aIs
=
nullptr
)
const
;
CustomElementDefinition
*
LookupCustomElementDefinition
(
JSContext
*
aCx
JSObject
*
aConstructor
)
const
;
void
SetupCustomElement
(
Element
*
aElement
const
nsAString
*
aTypeExtension
)
;
static
void
EnqueueLifecycleCallback
(
nsIDocument
:
:
ElementCallbackType
aType
Element
*
aCustomElement
LifecycleCallbackArgs
*
aArgs
LifecycleAdoptedCallbackArgs
*
aAdoptedCallbackArgs
CustomElementDefinition
*
aDefinition
)
;
void
GetCustomPrototype
(
nsAtom
*
aAtom
JS
:
:
MutableHandle
<
JSObject
*
>
aPrototype
)
;
void
SyncInvokeReactions
(
nsIDocument
:
:
ElementCallbackType
aType
Element
*
aCustomElement
CustomElementDefinition
*
aDefinition
)
;
static
void
Upgrade
(
Element
*
aElement
CustomElementDefinition
*
aDefinition
ErrorResult
&
aRv
)
;
private
:
~
CustomElementRegistry
(
)
;
static
UniquePtr
<
CustomElementCallback
>
CreateCustomElementCallback
(
nsIDocument
:
:
ElementCallbackType
aType
Element
*
aCustomElement
LifecycleCallbackArgs
*
aArgs
LifecycleAdoptedCallbackArgs
*
aAdoptedCallbackArgs
CustomElementDefinition
*
aDefinition
)
;
void
RegisterUnresolvedElement
(
Element
*
aElement
nsAtom
*
aTypeName
=
nullptr
)
;
void
UpgradeCandidates
(
nsAtom
*
aKey
CustomElementDefinition
*
aDefinition
ErrorResult
&
aRv
)
;
typedef
nsRefPtrHashtable
<
nsRefPtrHashKey
<
nsAtom
>
CustomElementDefinition
>
DefinitionMap
;
typedef
nsClassHashtable
<
nsRefPtrHashKey
<
nsAtom
>
nsTArray
<
nsWeakPtr
>
>
CandidateMap
;
typedef
JS
:
:
GCHashMap
<
JS
:
:
Heap
<
JSObject
*
>
RefPtr
<
nsAtom
>
js
:
:
MovableCellHasher
<
JS
:
:
Heap
<
JSObject
*
>
>
js
:
:
SystemAllocPolicy
>
ConstructorMap
;
DefinitionMap
mCustomDefinitions
;
ConstructorMap
mConstructors
;
typedef
nsRefPtrHashtable
<
nsRefPtrHashKey
<
nsAtom
>
Promise
>
WhenDefinedPromiseMap
;
WhenDefinedPromiseMap
mWhenDefinedPromiseMap
;
CandidateMap
mCandidatesMap
;
nsCOMPtr
<
nsPIDOMWindowInner
>
mWindow
;
bool
mIsCustomDefinitionRunning
;
private
:
class
MOZ_RAII
AutoSetRunningFlag
final
{
public
:
explicit
AutoSetRunningFlag
(
CustomElementRegistry
*
aRegistry
)
:
mRegistry
(
aRegistry
)
{
MOZ_ASSERT
(
!
mRegistry
-
>
mIsCustomDefinitionRunning
"
IsCustomDefinitionRunning
flag
should
be
initially
false
"
)
;
mRegistry
-
>
mIsCustomDefinitionRunning
=
true
;
}
~
AutoSetRunningFlag
(
)
{
mRegistry
-
>
mIsCustomDefinitionRunning
=
false
;
}
private
:
CustomElementRegistry
*
mRegistry
;
}
;
class
SyncInvokeReactionRunnable
:
public
mozilla
:
:
Runnable
{
public
:
SyncInvokeReactionRunnable
(
UniquePtr
<
CustomElementReaction
>
aReaction
Element
*
aCustomElement
)
:
Runnable
(
"
dom
:
:
CustomElementRegistry
:
:
SyncInvokeReactionRunnable
"
)
mReaction
(
Move
(
aReaction
)
)
mCustomElement
(
aCustomElement
)
{
}
NS_IMETHOD
Run
(
)
override
{
ErrorResult
rv
;
mReaction
-
>
Invoke
(
mCustomElement
rv
)
;
return
NS_OK
;
}
private
:
UniquePtr
<
CustomElementReaction
>
mReaction
;
Element
*
mCustomElement
;
}
;
public
:
nsISupports
*
GetParentObject
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
void
Define
(
const
nsAString
&
aName
Function
&
aFunctionConstructor
const
ElementDefinitionOptions
&
aOptions
ErrorResult
&
aRv
)
;
void
Get
(
JSContext
*
cx
const
nsAString
&
name
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetVal
)
;
already_AddRefed
<
Promise
>
WhenDefined
(
const
nsAString
&
aName
ErrorResult
&
aRv
)
;
}
;
class
MOZ_RAII
AutoCEReaction
final
{
public
:
explicit
AutoCEReaction
(
CustomElementReactionsStack
*
aReactionsStack
)
:
mReactionsStack
(
aReactionsStack
)
{
mReactionsStack
-
>
CreateAndPushElementQueue
(
)
;
}
~
AutoCEReaction
(
)
{
mReactionsStack
-
>
PopAndInvokeElementQueue
(
)
;
}
private
:
RefPtr
<
CustomElementReactionsStack
>
mReactionsStack
;
}
;
}
}
#
endif
