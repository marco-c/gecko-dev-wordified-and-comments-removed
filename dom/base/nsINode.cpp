#
include
"
nsINode
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
js
/
JSON
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
L10nUtilsBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
SVGUseElement
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsDOMCSSAttrDeclaration
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfoInlines
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsPIBoxObject
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
HTMLLegendElement
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
<
algorithm
>
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
GeometryUtils
.
h
"
#
include
"
nsIAnimationObserver
.
h
"
#
include
"
nsChildContentList
.
h
"
#
include
"
mozilla
/
dom
/
NodeBinding
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
XPathGenerator
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
dom
/
AccessibleNode
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsINode
:
:
nsSlots
:
:
nsSlots
(
)
:
mWeakReference
(
nullptr
)
{
}
nsINode
:
:
nsSlots
:
:
~
nsSlots
(
)
{
if
(
mChildNodes
)
{
mChildNodes
-
>
DropReference
(
)
;
}
if
(
mWeakReference
)
{
mWeakReference
-
>
NoticeNodeDestruction
(
)
;
}
}
void
nsINode
:
:
nsSlots
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
cb
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mSlots
-
>
mChildNodes
"
)
;
cb
.
NoteXPCOMChild
(
mChildNodes
)
;
}
void
nsINode
:
:
nsSlots
:
:
Unlink
(
)
{
if
(
mChildNodes
)
{
mChildNodes
-
>
DropReference
(
)
;
}
}
#
ifdef
MOZILLA_INTERNAL_API
nsINode
:
:
nsINode
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
mNodeInfo
(
std
:
:
move
(
aNodeInfo
)
)
mParent
(
nullptr
)
#
ifndef
BOOL_FLAGS_ON_WRAPPER_CACHE
mBoolFlags
(
0
)
#
endif
mChildCount
(
0
)
mPreviousOrLastSibling
(
nullptr
)
mSubtreeRoot
(
this
)
mSlots
(
nullptr
)
{
}
#
endif
nsINode
:
:
~
nsINode
(
)
{
MOZ_ASSERT
(
!
HasSlots
(
)
"
nsNodeUtils
:
:
LastRelease
was
not
called
?
"
)
;
MOZ_ASSERT
(
mSubtreeRoot
=
=
this
"
Didn
'
t
restore
state
properly
?
"
)
;
}
void
*
nsINode
:
:
GetProperty
(
const
nsAtom
*
aPropertyName
nsresult
*
aStatus
)
const
{
if
(
!
HasProperties
(
)
)
{
if
(
aStatus
)
{
*
aStatus
=
NS_PROPTABLE_PROP_NOT_THERE
;
}
return
nullptr
;
}
return
OwnerDoc
(
)
-
>
PropertyTable
(
)
.
GetProperty
(
this
aPropertyName
aStatus
)
;
}
nsresult
nsINode
:
:
SetProperty
(
nsAtom
*
aPropertyName
void
*
aValue
NSPropertyDtorFunc
aDtor
bool
aTransfer
)
{
nsresult
rv
=
OwnerDoc
(
)
-
>
PropertyTable
(
)
.
SetProperty
(
this
aPropertyName
aValue
aDtor
nullptr
aTransfer
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
SetFlags
(
NODE_HAS_PROPERTIES
)
;
}
return
rv
;
}
void
nsINode
:
:
DeleteProperty
(
const
nsAtom
*
aPropertyName
)
{
OwnerDoc
(
)
-
>
PropertyTable
(
)
.
DeleteProperty
(
this
aPropertyName
)
;
}
void
*
nsINode
:
:
UnsetProperty
(
const
nsAtom
*
aPropertyName
nsresult
*
aStatus
)
{
return
OwnerDoc
(
)
-
>
PropertyTable
(
)
.
UnsetProperty
(
this
aPropertyName
aStatus
)
;
}
nsINode
:
:
nsSlots
*
nsINode
:
:
CreateSlots
(
)
{
return
new
nsSlots
(
)
;
}
nsIContent
*
nsINode
:
:
GetTextEditorRootContent
(
TextEditor
*
*
aTextEditor
)
{
if
(
aTextEditor
)
{
*
aTextEditor
=
nullptr
;
}
for
(
nsINode
*
node
=
this
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
!
node
-
>
IsElement
(
)
|
|
!
node
-
>
IsHTMLElement
(
)
)
continue
;
RefPtr
<
TextEditor
>
textEditor
=
static_cast
<
nsGenericHTMLElement
*
>
(
node
)
-
>
GetTextEditorInternal
(
)
;
if
(
!
textEditor
)
{
continue
;
}
MOZ_ASSERT
(
!
textEditor
-
>
AsHTMLEditor
(
)
"
If
it
were
an
HTML
editor
needs
to
use
GetRootElement
(
)
"
)
;
Element
*
rootElement
=
textEditor
-
>
GetRoot
(
)
;
if
(
aTextEditor
)
{
textEditor
.
forget
(
aTextEditor
)
;
}
return
rootElement
;
}
return
nullptr
;
}
nsINode
*
nsINode
:
:
GetRootNode
(
const
GetRootNodeOptions
&
aOptions
)
{
if
(
aOptions
.
mComposed
)
{
if
(
Document
*
doc
=
GetComposedDoc
(
)
)
{
return
doc
;
}
nsINode
*
node
=
this
;
while
(
node
)
{
node
=
node
-
>
SubtreeRoot
(
)
;
ShadowRoot
*
shadow
=
ShadowRoot
:
:
FromNode
(
node
)
;
if
(
!
shadow
)
{
break
;
}
node
=
shadow
-
>
GetHost
(
)
;
}
return
node
;
}
return
SubtreeRoot
(
)
;
}
nsINode
*
nsINode
:
:
GetParentOrHostNode
(
)
const
{
if
(
mParent
)
{
return
mParent
;
}
const
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
this
)
;
return
shadowRoot
?
shadowRoot
-
>
GetHost
(
)
:
nullptr
;
}
nsINode
*
nsINode
:
:
SubtreeRoot
(
)
const
{
auto
RootOfNode
=
[
]
(
const
nsINode
*
aStart
)
-
>
nsINode
*
{
const
nsINode
*
node
=
aStart
;
const
nsINode
*
iter
=
node
;
while
(
(
iter
=
iter
-
>
GetParentNode
(
)
)
)
{
node
=
iter
;
}
return
const_cast
<
nsINode
*
>
(
node
)
;
}
;
nsINode
*
node
;
if
(
IsInUncomposedDoc
(
)
)
{
node
=
OwnerDocAsNode
(
)
;
}
else
if
(
IsContent
(
)
)
{
ShadowRoot
*
containingShadow
=
AsContent
(
)
-
>
GetContainingShadow
(
)
;
node
=
containingShadow
?
containingShadow
:
mSubtreeRoot
;
if
(
!
node
)
{
NS_WARNING
(
"
Using
SubtreeRoot
(
)
on
unlinked
element
?
"
)
;
node
=
RootOfNode
(
this
)
;
}
}
else
{
node
=
mSubtreeRoot
;
}
MOZ_ASSERT
(
node
"
Should
always
have
a
node
here
!
"
)
;
#
ifdef
DEBUG
{
const
nsINode
*
slowNode
=
RootOfNode
(
this
)
;
MOZ_ASSERT
(
slowNode
=
=
node
"
These
should
always
be
in
sync
!
"
)
;
}
#
endif
return
node
;
}
static
nsIContent
*
GetRootForContentSubtree
(
nsIContent
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
nullptr
)
;
ShadowRoot
*
containingShadow
=
aContent
-
>
GetContainingShadow
(
)
;
if
(
containingShadow
)
{
return
containingShadow
;
}
nsIContent
*
stop
=
aContent
-
>
GetBindingParent
(
)
;
while
(
aContent
)
{
nsIContent
*
parent
=
aContent
-
>
GetParent
(
)
;
if
(
parent
=
=
stop
)
{
break
;
}
aContent
=
parent
;
}
return
aContent
;
}
nsIContent
*
nsINode
:
:
GetSelectionRootContent
(
nsIPresShell
*
aPresShell
)
{
NS_ENSURE_TRUE
(
aPresShell
nullptr
)
;
if
(
IsDocument
(
)
)
return
AsDocument
(
)
-
>
GetRootElement
(
)
;
if
(
!
IsContent
(
)
)
return
nullptr
;
if
(
GetComposedDoc
(
)
!
=
aPresShell
-
>
GetDocument
(
)
)
{
return
nullptr
;
}
if
(
static_cast
<
nsIContent
*
>
(
this
)
-
>
HasIndependentSelection
(
)
)
{
nsIContent
*
content
=
GetTextEditorRootContent
(
)
;
if
(
content
)
return
content
;
}
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
;
if
(
presContext
)
{
HTMLEditor
*
htmlEditor
=
nsContentUtils
:
:
GetHTMLEditor
(
presContext
)
;
if
(
htmlEditor
)
{
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
|
|
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
|
|
!
HasFlag
(
NODE_IS_EDITABLE
)
)
{
nsIContent
*
editorRoot
=
htmlEditor
-
>
GetRoot
(
)
;
NS_ENSURE_TRUE
(
editorRoot
nullptr
)
;
return
nsContentUtils
:
:
IsInSameAnonymousTree
(
this
editorRoot
)
?
editorRoot
:
GetRootForContentSubtree
(
static_cast
<
nsIContent
*
>
(
this
)
)
;
}
return
static_cast
<
nsIContent
*
>
(
this
)
-
>
GetEditingHost
(
)
;
}
}
RefPtr
<
nsFrameSelection
>
fs
=
aPresShell
-
>
FrameSelection
(
)
;
nsIContent
*
content
=
fs
-
>
GetLimiter
(
)
;
if
(
!
content
)
{
content
=
fs
-
>
GetAncestorLimiter
(
)
;
if
(
!
content
)
{
Document
*
doc
=
aPresShell
-
>
GetDocument
(
)
;
NS_ENSURE_TRUE
(
doc
nullptr
)
;
content
=
doc
-
>
GetRootElement
(
)
;
if
(
!
content
)
return
nullptr
;
}
}
NS_ENSURE_TRUE
(
content
nullptr
)
;
if
(
!
nsContentUtils
:
:
IsInSameAnonymousTree
(
this
content
)
)
{
content
=
GetRootForContentSubtree
(
static_cast
<
nsIContent
*
>
(
this
)
)
;
if
(
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
content
)
)
{
content
=
shadowRoot
-
>
GetHost
(
)
;
}
}
return
content
;
}
nsINodeList
*
nsINode
:
:
ChildNodes
(
)
{
nsSlots
*
slots
=
Slots
(
)
;
if
(
!
slots
-
>
mChildNodes
)
{
slots
-
>
mChildNodes
=
IsAttr
(
)
?
new
nsAttrChildContentList
(
this
)
:
new
nsParentNodeChildContentList
(
this
)
;
}
return
slots
-
>
mChildNodes
;
}
nsIContent
*
nsINode
:
:
GetLastChild
(
)
const
{
return
mFirstChild
?
mFirstChild
-
>
mPreviousOrLastSibling
:
nullptr
;
}
void
nsINode
:
:
InvalidateChildNodes
(
)
{
MOZ_ASSERT
(
!
IsAttr
(
)
)
;
nsSlots
*
slots
=
GetExistingSlots
(
)
;
if
(
!
slots
|
|
!
slots
-
>
mChildNodes
)
{
return
;
}
auto
childNodes
=
static_cast
<
nsParentNodeChildContentList
*
>
(
slots
-
>
mChildNodes
.
get
(
)
)
;
childNodes
-
>
InvalidateCache
(
)
;
}
void
nsINode
:
:
GetTextContentInternal
(
nsAString
&
aTextContent
OOMReporter
&
aError
)
{
SetDOMStringToNull
(
aTextContent
)
;
}
DocumentOrShadowRoot
*
nsINode
:
:
GetUncomposedDocOrConnectedShadowRoot
(
)
const
{
if
(
IsInUncomposedDoc
(
)
)
{
return
OwnerDoc
(
)
;
}
if
(
IsInComposedDoc
(
)
&
&
IsInShadowTree
(
)
)
{
return
AsContent
(
)
-
>
GetContainingShadow
(
)
;
}
return
nullptr
;
}
#
ifdef
DEBUG
void
nsINode
:
:
CheckNotNativeAnonymous
(
)
const
{
if
(
!
IsContent
(
)
)
return
;
nsIContent
*
content
=
static_cast
<
const
nsIContent
*
>
(
this
)
-
>
GetBindingParent
(
)
;
while
(
content
)
{
if
(
content
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
NS_ERROR
(
"
Element
not
marked
to
be
in
native
anonymous
subtree
!
"
)
;
break
;
}
content
=
content
-
>
GetBindingParent
(
)
;
}
}
#
endif
bool
nsINode
:
:
IsInAnonymousSubtree
(
)
const
{
if
(
!
IsContent
(
)
)
{
return
false
;
}
return
AsContent
(
)
-
>
IsInAnonymousSubtree
(
)
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
nsINode
&
aNode
)
{
nsAutoString
elemDesc
;
const
nsINode
*
curr
=
&
aNode
;
while
(
curr
)
{
const
nsString
&
localName
=
curr
-
>
LocalName
(
)
;
nsString
id
;
if
(
curr
-
>
IsElement
(
)
)
{
curr
-
>
AsElement
(
)
-
>
GetId
(
id
)
;
}
if
(
!
elemDesc
.
IsEmpty
(
)
)
{
elemDesc
=
elemDesc
+
NS_LITERAL_STRING
(
"
.
"
)
;
}
elemDesc
=
elemDesc
+
localName
;
if
(
!
id
.
IsEmpty
(
)
)
{
elemDesc
=
elemDesc
+
NS_LITERAL_STRING
(
"
[
'
"
)
+
id
+
NS_LITERAL_STRING
(
"
'
]
"
)
;
}
curr
=
curr
-
>
GetParentNode
(
)
;
}
NS_ConvertUTF16toUTF8
str
(
elemDesc
)
;
return
aStream
<
<
str
.
get
(
)
;
}
SVGUseElement
*
nsINode
:
:
DoGetContainingSVGUseShadowHost
(
)
const
{
MOZ_ASSERT
(
IsInShadowTree
(
)
)
;
return
SVGUseElement
:
:
FromNodeOrNull
(
AsContent
(
)
-
>
GetContainingShadowHost
(
)
)
;
}
bool
nsINode
:
:
IsInUAWidget
(
)
const
{
if
(
!
IsInShadowTree
(
)
)
{
return
false
;
}
ShadowRoot
*
shadowRoot
=
AsContent
(
)
-
>
GetContainingShadow
(
)
;
return
shadowRoot
&
&
shadowRoot
-
>
IsUAWidget
(
)
;
}
void
nsINode
:
:
GetNodeValueInternal
(
nsAString
&
aNodeValue
)
{
SetDOMStringToNull
(
aNodeValue
)
;
}
nsINode
*
nsINode
:
:
RemoveChild
(
nsINode
&
aOldChild
ErrorResult
&
aError
)
{
if
(
!
aOldChild
.
IsContent
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
if
(
aOldChild
.
GetParentNode
(
)
=
=
this
)
{
nsContentUtils
:
:
MaybeFireNodeRemoved
(
&
aOldChild
this
)
;
}
if
(
aOldChild
.
AsContent
(
)
-
>
IsRootOfAnonymousSubtree
(
)
|
|
aOldChild
.
GetParentNode
(
)
!
=
this
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
nullptr
;
}
RemoveChildNode
(
aOldChild
.
AsContent
(
)
true
)
;
return
&
aOldChild
;
}
void
nsINode
:
:
Normalize
(
)
{
AutoTArray
<
nsCOMPtr
<
nsIContent
>
50
>
nodes
;
bool
canMerge
=
false
;
for
(
nsIContent
*
node
=
this
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
this
)
)
{
if
(
node
-
>
NodeType
(
)
!
=
TEXT_NODE
)
{
canMerge
=
false
;
continue
;
}
if
(
canMerge
|
|
node
-
>
TextLength
(
)
=
=
0
)
{
nodes
.
AppendElement
(
node
)
;
}
else
{
canMerge
=
true
;
}
canMerge
=
canMerge
&
&
!
!
node
-
>
GetNextSibling
(
)
;
}
if
(
nodes
.
IsEmpty
(
)
)
{
return
;
}
Document
*
doc
=
OwnerDoc
(
)
;
mozAutoSubtreeModified
subtree
(
doc
nullptr
)
;
bool
hasRemoveListeners
=
nsContentUtils
:
:
HasMutationListeners
(
doc
NS_EVENT_BITS_MUTATION_NODEREMOVED
)
;
if
(
hasRemoveListeners
)
{
for
(
uint32_t
i
=
0
;
i
<
nodes
.
Length
(
)
;
+
+
i
)
{
nsINode
*
parentNode
=
nodes
[
i
]
-
>
GetParentNode
(
)
;
if
(
parentNode
)
{
nsContentUtils
:
:
MaybeFireNodeRemoved
(
nodes
[
i
]
parentNode
)
;
}
}
}
mozAutoDocUpdate
batch
(
doc
true
)
;
nsAutoString
tmpStr
;
for
(
uint32_t
i
=
0
;
i
<
nodes
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
node
=
nodes
[
i
]
;
const
nsTextFragment
*
text
=
node
-
>
GetText
(
)
;
if
(
text
-
>
GetLength
(
)
)
{
nsIContent
*
target
=
node
-
>
GetPreviousSibling
(
)
;
NS_ASSERTION
(
(
target
&
&
target
-
>
NodeType
(
)
=
=
TEXT_NODE
)
|
|
hasRemoveListeners
"
Should
always
have
a
previous
text
sibling
unless
"
"
mutation
events
messed
us
up
"
)
;
if
(
!
hasRemoveListeners
|
|
(
target
&
&
target
-
>
NodeType
(
)
=
=
TEXT_NODE
)
)
{
nsTextNode
*
t
=
static_cast
<
nsTextNode
*
>
(
target
)
;
if
(
text
-
>
Is2b
(
)
)
{
t
-
>
AppendTextForNormalize
(
text
-
>
Get2b
(
)
text
-
>
GetLength
(
)
true
node
)
;
}
else
{
tmpStr
.
Truncate
(
)
;
text
-
>
AppendTo
(
tmpStr
)
;
t
-
>
AppendTextForNormalize
(
tmpStr
.
get
(
)
tmpStr
.
Length
(
)
true
node
)
;
}
}
}
nsCOMPtr
<
nsINode
>
parent
=
node
-
>
GetParentNode
(
)
;
NS_ASSERTION
(
parent
|
|
hasRemoveListeners
"
Should
always
have
a
parent
unless
"
"
mutation
events
messed
us
up
"
)
;
if
(
parent
)
{
parent
-
>
RemoveChildNode
(
node
true
)
;
}
}
}
nsresult
nsINode
:
:
GetBaseURI
(
nsAString
&
aURI
)
const
{
nsCOMPtr
<
nsIURI
>
baseURI
=
GetBaseURI
(
)
;
nsAutoCString
spec
;
if
(
baseURI
)
{
nsresult
rv
=
baseURI
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
CopyUTF8toUTF16
(
spec
aURI
)
;
return
NS_OK
;
}
void
nsINode
:
:
GetBaseURIFromJS
(
nsAString
&
aURI
CallerType
aCallerType
ErrorResult
&
aRv
)
const
{
nsCOMPtr
<
nsIURI
>
baseURI
=
GetBaseURI
(
aCallerType
=
=
CallerType
:
:
System
)
;
nsAutoCString
spec
;
if
(
baseURI
)
{
nsresult
res
=
baseURI
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
}
CopyUTF8toUTF16
(
spec
aURI
)
;
}
already_AddRefed
<
nsIURI
>
nsINode
:
:
GetBaseURIObject
(
)
const
{
return
GetBaseURI
(
true
)
;
}
void
nsINode
:
:
LookupPrefix
(
const
nsAString
&
aNamespaceURI
nsAString
&
aPrefix
)
{
Element
*
element
=
GetNameSpaceElement
(
)
;
if
(
element
)
{
for
(
nsIContent
*
content
=
element
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
element
=
content
-
>
AsElement
(
)
;
uint32_t
attrCount
=
element
-
>
GetAttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
const
nsAttrName
*
name
=
element
-
>
GetAttrNameAt
(
i
)
;
if
(
name
-
>
NamespaceEquals
(
kNameSpaceID_XMLNS
)
&
&
element
-
>
AttrValueIs
(
kNameSpaceID_XMLNS
name
-
>
LocalName
(
)
aNamespaceURI
eCaseMatters
)
)
{
nsAtom
*
localName
=
name
-
>
LocalName
(
)
;
if
(
localName
!
=
nsGkAtoms
:
:
xmlns
)
{
localName
-
>
ToString
(
aPrefix
)
;
}
else
{
SetDOMStringToNull
(
aPrefix
)
;
}
return
;
}
}
}
}
SetDOMStringToNull
(
aPrefix
)
;
}
uint16_t
nsINode
:
:
CompareDocumentPosition
(
nsINode
&
aOtherNode
int32_t
*
aThisIndex
int32_t
*
aOtherIndex
)
const
{
if
(
this
=
=
&
aOtherNode
)
{
return
0
;
}
if
(
GetPreviousSibling
(
)
=
=
&
aOtherNode
)
{
MOZ_ASSERT
(
GetParentNode
(
)
=
=
aOtherNode
.
GetParentNode
(
)
)
;
return
Node_Binding
:
:
DOCUMENT_POSITION_PRECEDING
;
}
if
(
GetNextSibling
(
)
=
=
&
aOtherNode
)
{
MOZ_ASSERT
(
GetParentNode
(
)
=
=
aOtherNode
.
GetParentNode
(
)
)
;
return
Node_Binding
:
:
DOCUMENT_POSITION_FOLLOWING
;
}
AutoTArray
<
const
nsINode
*
32
>
parents1
parents2
;
const
nsINode
*
node1
=
&
aOtherNode
;
const
nsINode
*
node2
=
this
;
const
Attr
*
attr1
=
Attr
:
:
FromNode
(
node1
)
;
if
(
attr1
)
{
const
Element
*
elem
=
attr1
-
>
GetElement
(
)
;
if
(
elem
)
{
node1
=
elem
;
parents1
.
AppendElement
(
attr1
)
;
}
}
if
(
auto
*
attr2
=
Attr
:
:
FromNode
(
node2
)
)
{
const
Element
*
elem
=
attr2
-
>
GetElement
(
)
;
if
(
elem
=
=
node1
&
&
attr1
)
{
uint32_t
i
;
const
nsAttrName
*
attrName
;
for
(
i
=
0
;
(
attrName
=
elem
-
>
GetAttrNameAt
(
i
)
)
;
+
+
i
)
{
if
(
attrName
-
>
Equals
(
attr1
-
>
NodeInfo
(
)
)
)
{
NS_ASSERTION
(
!
attrName
-
>
Equals
(
attr2
-
>
NodeInfo
(
)
)
"
Different
attrs
at
same
position
"
)
;
return
Node_Binding
:
:
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
|
Node_Binding
:
:
DOCUMENT_POSITION_PRECEDING
;
}
if
(
attrName
-
>
Equals
(
attr2
-
>
NodeInfo
(
)
)
)
{
return
Node_Binding
:
:
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
|
Node_Binding
:
:
DOCUMENT_POSITION_FOLLOWING
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
neither
attribute
in
the
element
"
)
;
return
Node_Binding
:
:
DOCUMENT_POSITION_DISCONNECTED
;
}
if
(
elem
)
{
node2
=
elem
;
parents2
.
AppendElement
(
attr2
)
;
}
}
do
{
parents1
.
AppendElement
(
node1
)
;
node1
=
node1
-
>
GetParentNode
(
)
;
}
while
(
node1
)
;
do
{
parents2
.
AppendElement
(
node2
)
;
node2
=
node2
-
>
GetParentNode
(
)
;
}
while
(
node2
)
;
uint32_t
pos1
=
parents1
.
Length
(
)
;
uint32_t
pos2
=
parents2
.
Length
(
)
;
const
nsINode
*
top1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
const
nsINode
*
top2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
if
(
top1
!
=
top2
)
{
return
top1
<
top2
?
(
Node_Binding
:
:
DOCUMENT_POSITION_PRECEDING
|
Node_Binding
:
:
DOCUMENT_POSITION_DISCONNECTED
|
Node_Binding
:
:
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
)
:
(
Node_Binding
:
:
DOCUMENT_POSITION_FOLLOWING
|
Node_Binding
:
:
DOCUMENT_POSITION_DISCONNECTED
|
Node_Binding
:
:
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
)
;
}
const
nsINode
*
parent
=
top1
;
uint32_t
len
;
for
(
len
=
std
:
:
min
(
pos1
pos2
)
;
len
>
0
;
-
-
len
)
{
const
nsINode
*
child1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
const
nsINode
*
child2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
if
(
child1
!
=
child2
)
{
int32_t
child1Index
;
bool
cachedChild1Index
=
false
;
if
(
&
aOtherNode
=
=
child1
&
&
aOtherIndex
)
{
cachedChild1Index
=
true
;
child1Index
=
*
aOtherIndex
!
=
-
1
?
*
aOtherIndex
:
parent
-
>
ComputeIndexOf
(
child1
)
;
}
else
{
child1Index
=
parent
-
>
ComputeIndexOf
(
child1
)
;
}
int32_t
child2Index
;
bool
cachedChild2Index
=
false
;
if
(
this
=
=
child2
&
&
aThisIndex
)
{
cachedChild2Index
=
true
;
child2Index
=
*
aThisIndex
!
=
-
1
?
*
aThisIndex
:
parent
-
>
ComputeIndexOf
(
child2
)
;
}
else
{
child2Index
=
parent
-
>
ComputeIndexOf
(
child2
)
;
}
uint16_t
retVal
=
child1Index
<
child2Index
?
Node_Binding
:
:
DOCUMENT_POSITION_PRECEDING
:
Node_Binding
:
:
DOCUMENT_POSITION_FOLLOWING
;
if
(
cachedChild1Index
)
{
*
aOtherIndex
=
child1Index
;
}
if
(
cachedChild2Index
)
{
*
aThisIndex
=
child2Index
;
}
return
retVal
;
}
parent
=
child1
;
}
return
pos1
<
pos2
?
(
Node_Binding
:
:
DOCUMENT_POSITION_PRECEDING
|
Node_Binding
:
:
DOCUMENT_POSITION_CONTAINS
)
:
(
Node_Binding
:
:
DOCUMENT_POSITION_FOLLOWING
|
Node_Binding
:
:
DOCUMENT_POSITION_CONTAINED_BY
)
;
}
bool
nsINode
:
:
IsSameNode
(
nsINode
*
other
)
{
return
other
=
=
this
;
}
bool
nsINode
:
:
IsEqualNode
(
nsINode
*
aOther
)
{
if
(
!
aOther
)
{
return
false
;
}
nsAutoString
string1
string2
;
nsINode
*
node1
=
this
;
nsINode
*
node2
=
aOther
;
do
{
uint16_t
nodeType
=
node1
-
>
NodeType
(
)
;
if
(
nodeType
!
=
node2
-
>
NodeType
(
)
)
{
return
false
;
}
mozilla
:
:
dom
:
:
NodeInfo
*
nodeInfo1
=
node1
-
>
mNodeInfo
;
mozilla
:
:
dom
:
:
NodeInfo
*
nodeInfo2
=
node2
-
>
mNodeInfo
;
if
(
!
nodeInfo1
-
>
Equals
(
nodeInfo2
)
|
|
nodeInfo1
-
>
GetExtraName
(
)
!
=
nodeInfo2
-
>
GetExtraName
(
)
)
{
return
false
;
}
switch
(
nodeType
)
{
case
ELEMENT_NODE
:
{
Element
*
element1
=
node1
-
>
AsElement
(
)
;
Element
*
element2
=
node2
-
>
AsElement
(
)
;
uint32_t
attrCount
=
element1
-
>
GetAttrCount
(
)
;
if
(
attrCount
!
=
element2
-
>
GetAttrCount
(
)
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
attrCount
;
+
+
i
)
{
const
nsAttrName
*
attrName
=
element1
-
>
GetAttrNameAt
(
i
)
;
#
ifdef
DEBUG
bool
hasAttr
=
#
endif
element1
-
>
GetAttr
(
attrName
-
>
NamespaceID
(
)
attrName
-
>
LocalName
(
)
string1
)
;
NS_ASSERTION
(
hasAttr
"
Why
don
'
t
we
have
an
attr
?
"
)
;
if
(
!
element2
-
>
AttrValueIs
(
attrName
-
>
NamespaceID
(
)
attrName
-
>
LocalName
(
)
string1
eCaseMatters
)
)
{
return
false
;
}
}
break
;
}
case
TEXT_NODE
:
case
COMMENT_NODE
:
case
CDATA_SECTION_NODE
:
case
PROCESSING_INSTRUCTION_NODE
:
{
MOZ_ASSERT
(
node1
-
>
IsCharacterData
(
)
)
;
MOZ_ASSERT
(
node2
-
>
IsCharacterData
(
)
)
;
string1
.
Truncate
(
)
;
static_cast
<
CharacterData
*
>
(
node1
)
-
>
AppendTextTo
(
string1
)
;
string2
.
Truncate
(
)
;
static_cast
<
CharacterData
*
>
(
node2
)
-
>
AppendTextTo
(
string2
)
;
if
(
!
string1
.
Equals
(
string2
)
)
{
return
false
;
}
break
;
}
case
DOCUMENT_NODE
:
case
DOCUMENT_FRAGMENT_NODE
:
break
;
case
ATTRIBUTE_NODE
:
{
NS_ASSERTION
(
node1
=
=
this
&
&
node2
=
=
aOther
"
Did
we
come
upon
an
attribute
node
while
walking
a
"
"
subtree
?
"
)
;
node1
-
>
GetNodeValue
(
string1
)
;
node2
-
>
GetNodeValue
(
string2
)
;
return
string1
.
Equals
(
string2
)
;
}
case
DOCUMENT_TYPE_NODE
:
{
DocumentType
*
docType1
=
static_cast
<
DocumentType
*
>
(
node1
)
;
DocumentType
*
docType2
=
static_cast
<
DocumentType
*
>
(
node2
)
;
docType1
-
>
GetPublicId
(
string1
)
;
docType2
-
>
GetPublicId
(
string2
)
;
if
(
!
string1
.
Equals
(
string2
)
)
{
return
false
;
}
docType1
-
>
GetSystemId
(
string1
)
;
docType2
-
>
GetSystemId
(
string2
)
;
if
(
!
string1
.
Equals
(
string2
)
)
{
return
false
;
}
break
;
}
default
:
MOZ_ASSERT
(
false
"
Unknown
node
type
"
)
;
}
nsINode
*
nextNode
=
node1
-
>
GetFirstChild
(
)
;
if
(
nextNode
)
{
node1
=
nextNode
;
node2
=
node2
-
>
GetFirstChild
(
)
;
}
else
{
if
(
node2
-
>
GetFirstChild
(
)
)
{
return
false
;
}
while
(
1
)
{
if
(
node1
=
=
this
)
{
NS_ASSERTION
(
node2
=
=
aOther
"
Should
have
reached
the
start
node
"
"
for
both
trees
at
the
same
time
"
)
;
return
true
;
}
nextNode
=
node1
-
>
GetNextSibling
(
)
;
if
(
nextNode
)
{
node1
=
nextNode
;
node2
=
node2
-
>
GetNextSibling
(
)
;
break
;
}
if
(
node2
-
>
GetNextSibling
(
)
)
{
return
false
;
}
node1
=
node1
-
>
GetParentNode
(
)
;
node2
=
node2
-
>
GetParentNode
(
)
;
NS_ASSERTION
(
node1
&
&
node2
"
no
parent
while
walking
subtree
"
)
;
}
}
}
while
(
node2
)
;
return
false
;
}
void
nsINode
:
:
LookupNamespaceURI
(
const
nsAString
&
aNamespacePrefix
nsAString
&
aNamespaceURI
)
{
Element
*
element
=
GetNameSpaceElement
(
)
;
if
(
!
element
|
|
NS_FAILED
(
element
-
>
LookupNamespaceURIInternal
(
aNamespacePrefix
aNamespaceURI
)
)
)
{
SetDOMStringToNull
(
aNamespaceURI
)
;
}
}
bool
nsINode
:
:
ComputeDefaultWantsUntrusted
(
ErrorResult
&
aRv
)
{
return
!
nsContentUtils
:
:
IsChromeDoc
(
OwnerDoc
(
)
)
;
}
void
nsINode
:
:
GetBoxQuads
(
const
BoxQuadOptions
&
aOptions
nsTArray
<
RefPtr
<
DOMQuad
>
>
&
aResult
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
{
mozilla
:
:
GetBoxQuads
(
this
aOptions
aResult
aCallerType
aRv
)
;
}
already_AddRefed
<
DOMQuad
>
nsINode
:
:
ConvertQuadFromNode
(
DOMQuad
&
aQuad
const
GeometryNode
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
{
return
mozilla
:
:
ConvertQuadFromNode
(
this
aQuad
aFrom
aOptions
aCallerType
aRv
)
;
}
already_AddRefed
<
DOMQuad
>
nsINode
:
:
ConvertRectFromNode
(
DOMRectReadOnly
&
aRect
const
GeometryNode
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
{
return
mozilla
:
:
ConvertRectFromNode
(
this
aRect
aFrom
aOptions
aCallerType
aRv
)
;
}
already_AddRefed
<
DOMPoint
>
nsINode
:
:
ConvertPointFromNode
(
const
DOMPointInit
&
aPoint
const
GeometryNode
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
{
return
mozilla
:
:
ConvertPointFromNode
(
this
aPoint
aFrom
aOptions
aCallerType
aRv
)
;
}
bool
nsINode
:
:
DispatchEvent
(
Event
&
aEvent
CallerType
aCallerType
ErrorResult
&
aRv
)
{
nsCOMPtr
<
Document
>
document
=
OwnerDoc
(
)
;
if
(
!
document
)
{
return
true
;
}
RefPtr
<
nsPresContext
>
context
=
document
-
>
GetPresContext
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsresult
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
this
nullptr
&
aEvent
context
&
status
)
;
bool
retval
=
!
aEvent
.
DefaultPrevented
(
aCallerType
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
return
retval
;
}
nsresult
nsINode
:
:
PostHandleEvent
(
EventChainPostVisitor
&
)
{
return
NS_OK
;
}
EventListenerManager
*
nsINode
:
:
GetOrCreateListenerManager
(
)
{
return
nsContentUtils
:
:
GetListenerManagerForNode
(
this
)
;
}
EventListenerManager
*
nsINode
:
:
GetExistingListenerManager
(
)
const
{
return
nsContentUtils
:
:
GetExistingListenerManagerForNode
(
this
)
;
}
nsPIDOMWindowOuter
*
nsINode
:
:
GetOwnerGlobalForBindingsInternal
(
)
{
bool
dummy
;
auto
*
window
=
static_cast
<
nsGlobalWindowInner
*
>
(
OwnerDoc
(
)
-
>
GetScriptHandlingObject
(
dummy
)
)
;
return
window
?
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
window
-
>
AsInner
(
)
)
:
nullptr
;
}
nsIGlobalObject
*
nsINode
:
:
GetOwnerGlobal
(
)
const
{
bool
dummy
;
return
OwnerDoc
(
)
-
>
GetScriptHandlingObject
(
dummy
)
;
}
bool
nsINode
:
:
UnoptimizableCCNode
(
)
const
{
const
uintptr_t
problematicFlags
=
(
NODE_IS_ANONYMOUS_ROOT
|
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
|
NODE_IS_NATIVE_ANONYMOUS_ROOT
|
NODE_MAY_BE_IN_BINDING_MNGR
)
;
return
HasFlag
(
problematicFlags
)
|
|
NodeType
(
)
=
=
ATTRIBUTE_NODE
|
|
(
IsElement
(
)
&
&
AsElement
(
)
-
>
IsInNamespace
(
kNameSpaceID_XBL
)
)
;
}
bool
nsINode
:
:
Traverse
(
nsINode
*
tmp
nsCycleCollectionTraversalCallback
&
cb
)
{
if
(
MOZ_LIKELY
(
!
cb
.
WantAllTraces
(
)
)
)
{
Document
*
currentDoc
=
tmp
-
>
GetComposedDoc
(
)
;
if
(
currentDoc
&
&
nsCCUncollectableMarker
:
:
InGeneration
(
currentDoc
-
>
GetMarkedCCGeneration
(
)
)
)
{
return
false
;
}
if
(
nsCCUncollectableMarker
:
:
sGeneration
)
{
if
(
tmp
-
>
HasKnownLiveWrapper
(
)
|
|
tmp
-
>
InCCBlackTree
(
)
)
{
return
false
;
}
if
(
!
tmp
-
>
UnoptimizableCCNode
(
)
)
{
if
(
(
currentDoc
&
&
currentDoc
-
>
HasKnownLiveWrapper
(
)
)
)
{
return
false
;
}
nsIContent
*
parent
=
tmp
-
>
GetParent
(
)
;
if
(
parent
&
&
!
parent
-
>
UnoptimizableCCNode
(
)
&
&
parent
-
>
HasKnownLiveWrapper
(
)
)
{
MOZ_ASSERT
(
parent
-
>
ComputeIndexOf
(
tmp
)
>
=
0
"
Parent
doesn
'
t
own
us
?
"
)
;
return
false
;
}
}
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNodeInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFirstChild
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mNextSibling
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR
(
GetParent
(
)
)
nsSlots
*
slots
=
tmp
-
>
GetExistingSlots
(
)
;
if
(
slots
)
{
slots
-
>
Traverse
(
cb
)
;
}
if
(
tmp
-
>
HasProperties
(
)
)
{
nsCOMArray
<
nsISupports
>
*
objects
=
static_cast
<
nsCOMArray
<
nsISupports
>
*
>
(
tmp
-
>
GetProperty
(
nsGkAtoms
:
:
keepobjectsalive
)
)
;
if
(
objects
)
{
for
(
int32_t
i
=
0
;
i
<
objects
-
>
Count
(
)
;
+
+
i
)
{
cb
.
NoteXPCOMChild
(
objects
-
>
ObjectAt
(
i
)
)
;
}
}
#
ifdef
ACCESSIBILITY
AccessibleNode
*
anode
=
static_cast
<
AccessibleNode
*
>
(
tmp
-
>
GetProperty
(
nsGkAtoms
:
:
accessiblenode
)
)
;
if
(
anode
)
{
cb
.
NoteXPCOMChild
(
anode
)
;
}
#
endif
}
if
(
tmp
-
>
NodeType
(
)
!
=
DOCUMENT_NODE
&
&
tmp
-
>
HasFlag
(
NODE_HAS_LISTENERMANAGER
)
)
{
nsContentUtils
:
:
TraverseListenerManager
(
tmp
cb
)
;
}
return
true
;
}
void
nsINode
:
:
Unlink
(
nsINode
*
tmp
)
{
tmp
-
>
ReleaseWrapper
(
tmp
)
;
nsSlots
*
slots
=
tmp
-
>
GetExistingSlots
(
)
;
if
(
slots
)
{
slots
-
>
Unlink
(
)
;
}
if
(
tmp
-
>
NodeType
(
)
!
=
DOCUMENT_NODE
&
&
tmp
-
>
HasFlag
(
NODE_HAS_LISTENERMANAGER
)
)
{
nsContentUtils
:
:
RemoveListenerManager
(
tmp
)
;
tmp
-
>
UnsetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
}
if
(
tmp
-
>
HasProperties
(
)
)
{
tmp
-
>
DeleteProperty
(
nsGkAtoms
:
:
keepobjectsalive
)
;
tmp
-
>
DeleteProperty
(
nsGkAtoms
:
:
accessiblenode
)
;
}
}
static
void
AdoptNodeIntoOwnerDoc
(
nsINode
*
aParent
nsINode
*
aNode
ErrorResult
&
aError
)
{
NS_ASSERTION
(
!
aNode
-
>
GetParentNode
(
)
"
Should
have
removed
from
parent
already
"
)
;
Document
*
doc
=
aParent
-
>
OwnerDoc
(
)
;
DebugOnly
<
nsINode
*
>
adoptedNode
=
doc
-
>
AdoptNode
(
*
aNode
aError
)
;
#
ifdef
DEBUG
if
(
!
aError
.
Failed
(
)
)
{
MOZ_ASSERT
(
aParent
-
>
OwnerDoc
(
)
=
=
doc
"
ownerDoc
chainged
while
adopting
"
)
;
MOZ_ASSERT
(
adoptedNode
=
=
aNode
"
Uh
adopt
node
changed
nodes
?
"
)
;
MOZ_ASSERT
(
aParent
-
>
OwnerDoc
(
)
=
=
aNode
-
>
OwnerDoc
(
)
"
ownerDocument
changed
again
after
adopting
!
"
)
;
}
#
endif
}
static
void
CheckForOutdatedParent
(
nsINode
*
aParent
nsINode
*
aNode
ErrorResult
&
aError
)
{
if
(
JSObject
*
existingObjUnrooted
=
aNode
-
>
GetWrapper
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
existingObj
(
RootingCx
(
)
existingObjUnrooted
)
;
AutoJSContext
cx
;
nsIGlobalObject
*
global
=
aParent
-
>
OwnerDoc
(
)
-
>
GetScopeObject
(
)
;
MOZ_ASSERT
(
global
)
;
if
(
JS
:
:
GetNonCCWObjectGlobal
(
existingObj
)
!
=
global
-
>
GetGlobalJSObject
(
)
)
{
JSAutoRealm
ar
(
cx
existingObj
)
;
UpdateReflectorGlobal
(
cx
existingObj
aError
)
;
}
}
}
static
nsresult
UpdateGlobalsInSubtree
(
nsIContent
*
aRoot
)
{
MOZ_ASSERT
(
ShouldUseNACScope
(
aRoot
)
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
ErrorResult
rv
;
JS
:
:
Rooted
<
JSObject
*
>
reflector
(
cx
)
;
for
(
nsIContent
*
cur
=
aRoot
;
cur
;
cur
=
cur
-
>
GetNextNode
(
aRoot
)
)
{
if
(
(
reflector
=
cur
-
>
GetWrapper
(
)
)
)
{
JSAutoRealm
ar
(
cx
reflector
)
;
UpdateReflectorGlobal
(
cx
reflector
rv
)
;
rv
.
WouldReportJSException
(
)
;
if
(
rv
.
Failed
(
)
)
{
return
rv
.
StealNSResult
(
)
;
}
}
}
return
NS_OK
;
}
nsresult
nsINode
:
:
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aChildToInsertBefore
bool
aNotify
)
{
if
(
!
IsContainerNode
(
)
)
{
return
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
;
}
MOZ_ASSERT
(
!
aKid
-
>
GetParentNode
(
)
"
Inserting
node
that
already
has
parent
"
)
;
MOZ_ASSERT
(
!
IsAttr
(
)
)
;
nsMutationGuard
:
:
DidMutate
(
)
;
Document
*
doc
=
GetUncomposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
GetComposedDoc
(
)
aNotify
)
;
if
(
OwnerDoc
(
)
!
=
aKid
-
>
OwnerDoc
(
)
)
{
ErrorResult
error
;
AdoptNodeIntoOwnerDoc
(
this
aKid
error
)
;
error
.
WouldReportJSException
(
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
else
if
(
OwnerDoc
(
)
-
>
DidDocumentOpen
(
)
)
{
ErrorResult
error
;
CheckForOutdatedParent
(
this
aKid
error
)
;
error
.
WouldReportJSException
(
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
}
if
(
!
aChildToInsertBefore
)
{
AppendChildToChildList
(
aKid
)
;
}
else
{
InsertChildToChildList
(
aKid
aChildToInsertBefore
)
;
}
nsIContent
*
parent
=
IsContent
(
)
?
AsContent
(
)
:
nullptr
;
bool
wasInNACScope
=
ShouldUseNACScope
(
aKid
)
;
nsresult
rv
=
aKid
-
>
BindToTree
(
doc
parent
parent
?
parent
-
>
GetBindingParent
(
)
:
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
wasInNACScope
&
&
ShouldUseNACScope
(
aKid
)
)
{
MOZ_ASSERT
(
ShouldUseNACScope
(
this
)
"
Why
does
the
kid
need
to
use
an
the
anonymous
content
scope
?
"
)
;
rv
=
UpdateGlobalsInSubtree
(
aKid
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
DisconnectChild
(
aKid
)
;
aKid
-
>
UnbindFromTree
(
)
;
return
rv
;
}
InvalidateChildNodes
(
)
;
NS_ASSERTION
(
aKid
-
>
GetParentNode
(
)
=
=
this
"
Did
we
run
script
inappropriately
?
"
)
;
if
(
aNotify
)
{
if
(
parent
&
&
!
aChildToInsertBefore
)
{
nsNodeUtils
:
:
ContentAppended
(
parent
aKid
)
;
}
else
{
nsNodeUtils
:
:
ContentInserted
(
this
aKid
)
;
}
if
(
nsContentUtils
:
:
HasMutationListeners
(
aKid
NS_EVENT_BITS_MUTATION_NODEINSERTED
this
)
)
{
InternalMutationEvent
mutation
(
true
eLegacyNodeInserted
)
;
mutation
.
mRelatedNode
=
this
;
mozAutoSubtreeModified
subtree
(
OwnerDoc
(
)
this
)
;
(
new
AsyncEventDispatcher
(
aKid
mutation
)
)
-
>
RunDOMEventWhenSafe
(
)
;
}
}
return
NS_OK
;
}
nsIContent
*
nsINode
:
:
GetPreviousSibling
(
)
const
{
if
(
mPreviousOrLastSibling
&
&
!
mPreviousOrLastSibling
-
>
mNextSibling
)
{
return
nullptr
;
}
return
mPreviousOrLastSibling
;
}
#
define
CACHE_POINTER_SHIFT
6
#
define
CACHE_NUM_SLOTS
128
#
define
CACHE_CHILD_LIMIT
10
#
define
CACHE_GET_INDEX
(
_parent
)
\
(
(
NS_PTR_TO_INT32
(
_parent
)
>
>
CACHE_POINTER_SHIFT
)
&
(
CACHE_NUM_SLOTS
-
1
)
)
struct
IndexCacheSlot
{
const
nsINode
*
mParent
;
const
nsINode
*
mChild
;
int32_t
mChildIndex
;
}
;
static
IndexCacheSlot
sIndexCache
[
CACHE_NUM_SLOTS
]
;
static
inline
void
AddChildAndIndexToCache
(
const
nsINode
*
aParent
const
nsINode
*
aChild
int32_t
aChildIndex
)
{
uint32_t
index
=
CACHE_GET_INDEX
(
aParent
)
;
sIndexCache
[
index
]
.
mParent
=
aParent
;
sIndexCache
[
index
]
.
mChild
=
aChild
;
sIndexCache
[
index
]
.
mChildIndex
=
aChildIndex
;
}
static
inline
void
GetChildAndIndexFromCache
(
const
nsINode
*
aParent
const
nsINode
*
*
aChild
int32_t
*
aChildIndex
)
{
uint32_t
index
=
CACHE_GET_INDEX
(
aParent
)
;
if
(
sIndexCache
[
index
]
.
mParent
=
=
aParent
)
{
*
aChild
=
sIndexCache
[
index
]
.
mChild
;
*
aChildIndex
=
sIndexCache
[
index
]
.
mChildIndex
;
}
else
{
*
aChild
=
nullptr
;
*
aChildIndex
=
-
1
;
}
}
static
inline
void
RemoveFromCache
(
const
nsINode
*
aParent
)
{
uint32_t
index
=
CACHE_GET_INDEX
(
aParent
)
;
if
(
sIndexCache
[
index
]
.
mParent
=
=
aParent
)
{
sIndexCache
[
index
]
=
{
nullptr
nullptr
-
1
}
;
}
}
void
nsINode
:
:
AppendChildToChildList
(
nsIContent
*
aKid
)
{
MOZ_ASSERT
(
aKid
)
;
MOZ_ASSERT
(
!
aKid
-
>
mNextSibling
)
;
RemoveFromCache
(
this
)
;
if
(
mFirstChild
)
{
nsIContent
*
lastChild
=
GetLastChild
(
)
;
lastChild
-
>
mNextSibling
=
aKid
;
aKid
-
>
mPreviousOrLastSibling
=
lastChild
;
}
else
{
mFirstChild
=
aKid
;
}
mFirstChild
-
>
mPreviousOrLastSibling
=
aKid
;
+
+
mChildCount
;
}
void
nsINode
:
:
InsertChildToChildList
(
nsIContent
*
aKid
nsIContent
*
aNextSibling
)
{
MOZ_ASSERT
(
aKid
)
;
MOZ_ASSERT
(
aNextSibling
)
;
RemoveFromCache
(
this
)
;
nsIContent
*
previousSibling
=
aNextSibling
-
>
mPreviousOrLastSibling
;
aNextSibling
-
>
mPreviousOrLastSibling
=
aKid
;
aKid
-
>
mPreviousOrLastSibling
=
previousSibling
;
aKid
-
>
mNextSibling
=
aNextSibling
;
if
(
aNextSibling
=
=
mFirstChild
)
{
MOZ_ASSERT
(
!
previousSibling
-
>
mNextSibling
)
;
mFirstChild
=
aKid
;
}
else
{
previousSibling
-
>
mNextSibling
=
aKid
;
}
+
+
mChildCount
;
}
void
nsINode
:
:
DisconnectChild
(
nsIContent
*
aKid
)
{
MOZ_ASSERT
(
aKid
)
;
MOZ_ASSERT
(
GetChildCount
(
)
>
0
)
;
RemoveFromCache
(
this
)
;
nsIContent
*
previousSibling
=
aKid
-
>
GetPreviousSibling
(
)
;
nsCOMPtr
<
nsIContent
>
ref
=
aKid
;
if
(
aKid
-
>
mNextSibling
)
{
aKid
-
>
mNextSibling
-
>
mPreviousOrLastSibling
=
aKid
-
>
mPreviousOrLastSibling
;
}
else
{
mFirstChild
-
>
mPreviousOrLastSibling
=
aKid
-
>
mPreviousOrLastSibling
;
}
aKid
-
>
mPreviousOrLastSibling
=
nullptr
;
if
(
previousSibling
)
{
previousSibling
-
>
mNextSibling
=
aKid
-
>
mNextSibling
.
forget
(
)
;
}
else
{
mFirstChild
=
aKid
-
>
mNextSibling
.
forget
(
)
;
}
-
-
mChildCount
;
}
nsIContent
*
nsINode
:
:
GetChildAt_Deprecated
(
uint32_t
aIndex
)
const
{
if
(
aIndex
>
=
GetChildCount
(
)
)
{
return
nullptr
;
}
nsIContent
*
child
=
mFirstChild
;
while
(
aIndex
-
-
)
{
child
=
child
-
>
GetNextSibling
(
)
;
}
return
child
;
}
int32_t
nsINode
:
:
ComputeIndexOf
(
const
nsINode
*
aChild
)
const
{
if
(
!
aChild
)
{
return
-
1
;
}
if
(
aChild
-
>
GetParentNode
(
)
!
=
this
)
{
return
-
1
;
}
if
(
aChild
=
=
GetLastChild
(
)
)
{
return
GetChildCount
(
)
-
1
;
}
if
(
mChildCount
>
=
CACHE_CHILD_LIMIT
)
{
const
nsINode
*
child
;
int32_t
childIndex
;
GetChildAndIndexFromCache
(
this
&
child
&
childIndex
)
;
if
(
child
)
{
if
(
child
=
=
aChild
)
{
return
childIndex
;
}
int32_t
nextIndex
=
childIndex
;
int32_t
prevIndex
=
childIndex
;
nsINode
*
prev
=
child
-
>
GetPreviousSibling
(
)
;
nsINode
*
next
=
child
-
>
GetNextSibling
(
)
;
do
{
if
(
next
)
{
+
+
nextIndex
;
if
(
next
=
=
aChild
)
{
AddChildAndIndexToCache
(
this
aChild
nextIndex
)
;
return
nextIndex
;
}
next
=
next
-
>
GetNextSibling
(
)
;
}
if
(
prev
)
{
-
-
prevIndex
;
if
(
prev
=
=
aChild
)
{
AddChildAndIndexToCache
(
this
aChild
prevIndex
)
;
return
prevIndex
;
}
prev
=
prev
-
>
GetPreviousSibling
(
)
;
}
}
while
(
prev
|
|
next
)
;
}
}
int32_t
index
=
0
;
nsINode
*
current
=
mFirstChild
;
while
(
current
)
{
MOZ_ASSERT
(
current
-
>
GetParentNode
(
)
=
=
this
)
;
if
(
current
=
=
aChild
)
{
if
(
mChildCount
>
=
CACHE_CHILD_LIMIT
)
{
AddChildAndIndexToCache
(
this
current
index
)
;
}
return
index
;
}
current
=
current
-
>
GetNextSibling
(
)
;
+
+
index
;
}
return
-
1
;
}
static
already_AddRefed
<
nsINode
>
GetNodeFromNodeOrString
(
const
OwningNodeOrString
&
aNode
Document
*
aDocument
)
{
if
(
aNode
.
IsNode
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
aNode
.
GetAsNode
(
)
;
return
node
.
forget
(
)
;
}
if
(
aNode
.
IsString
(
)
)
{
RefPtr
<
nsTextNode
>
textNode
=
aDocument
-
>
CreateTextNode
(
aNode
.
GetAsString
(
)
)
;
return
textNode
.
forget
(
)
;
}
MOZ_CRASH
(
"
Impossible
type
"
)
;
}
MOZ_CAN_RUN_SCRIPT
static
already_AddRefed
<
nsINode
>
ConvertNodesOrStringsIntoNode
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
Document
*
aDocument
ErrorResult
&
aRv
)
{
if
(
aNodes
.
Length
(
)
=
=
1
)
{
return
GetNodeFromNodeOrString
(
aNodes
[
0
]
aDocument
)
;
}
nsCOMPtr
<
nsINode
>
fragment
=
aDocument
-
>
CreateDocumentFragment
(
)
;
for
(
const
auto
&
node
:
aNodes
)
{
nsCOMPtr
<
nsINode
>
childNode
=
GetNodeFromNodeOrString
(
node
aDocument
)
;
fragment
-
>
AppendChild
(
*
childNode
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
return
fragment
.
forget
(
)
;
}
static
void
InsertNodesIntoHashset
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
nsTHashtable
<
nsPtrHashKey
<
nsINode
>
>
&
aHashset
)
{
for
(
const
auto
&
node
:
aNodes
)
{
if
(
node
.
IsNode
(
)
)
{
aHashset
.
PutEntry
(
node
.
GetAsNode
(
)
)
;
}
}
}
static
nsINode
*
FindViablePreviousSibling
(
const
nsINode
&
aNode
const
Sequence
<
OwningNodeOrString
>
&
aNodes
)
{
nsTHashtable
<
nsPtrHashKey
<
nsINode
>
>
nodeSet
(
16
)
;
InsertNodesIntoHashset
(
aNodes
nodeSet
)
;
nsINode
*
viablePreviousSibling
=
nullptr
;
for
(
nsINode
*
sibling
=
aNode
.
GetPreviousSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetPreviousSibling
(
)
)
{
if
(
!
nodeSet
.
Contains
(
sibling
)
)
{
viablePreviousSibling
=
sibling
;
break
;
}
}
return
viablePreviousSibling
;
}
static
nsINode
*
FindViableNextSibling
(
const
nsINode
&
aNode
const
Sequence
<
OwningNodeOrString
>
&
aNodes
)
{
nsTHashtable
<
nsPtrHashKey
<
nsINode
>
>
nodeSet
(
16
)
;
InsertNodesIntoHashset
(
aNodes
nodeSet
)
;
nsINode
*
viableNextSibling
=
nullptr
;
for
(
nsINode
*
sibling
=
aNode
.
GetNextSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
!
nodeSet
.
Contains
(
sibling
)
)
{
viableNextSibling
=
sibling
;
break
;
}
}
return
viableNextSibling
;
}
void
nsINode
:
:
Before
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
;
}
nsCOMPtr
<
nsINode
>
viablePreviousSibling
=
FindViablePreviousSibling
(
*
this
aNodes
)
;
nsCOMPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsINode
>
node
=
ConvertNodesOrStringsIntoNode
(
aNodes
doc
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
viablePreviousSibling
=
viablePreviousSibling
?
viablePreviousSibling
-
>
GetNextSibling
(
)
:
parent
-
>
GetFirstChild
(
)
;
parent
-
>
InsertBefore
(
*
node
viablePreviousSibling
aRv
)
;
}
void
nsINode
:
:
After
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
;
}
nsCOMPtr
<
nsINode
>
viableNextSibling
=
FindViableNextSibling
(
*
this
aNodes
)
;
nsCOMPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsINode
>
node
=
ConvertNodesOrStringsIntoNode
(
aNodes
doc
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
parent
-
>
InsertBefore
(
*
node
viableNextSibling
aRv
)
;
}
void
nsINode
:
:
ReplaceWith
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
;
}
nsCOMPtr
<
nsINode
>
viableNextSibling
=
FindViableNextSibling
(
*
this
aNodes
)
;
nsCOMPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsINode
>
node
=
ConvertNodesOrStringsIntoNode
(
aNodes
doc
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
parent
=
=
GetParentNode
(
)
)
{
parent
-
>
ReplaceChild
(
*
node
*
this
aRv
)
;
}
else
{
parent
-
>
InsertBefore
(
*
node
viableNextSibling
aRv
)
;
}
}
void
nsINode
:
:
Remove
(
)
{
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
!
parent
)
{
return
;
}
parent
-
>
RemoveChild
(
*
this
IgnoreErrors
(
)
)
;
}
Element
*
nsINode
:
:
GetFirstElementChild
(
)
const
{
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
return
child
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
Element
*
nsINode
:
:
GetLastElementChild
(
)
const
{
for
(
nsIContent
*
child
=
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
return
child
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
static
bool
MatchAttribute
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAttrName
void
*
aData
)
{
MOZ_ASSERT
(
aElement
"
Must
have
content
node
to
work
with
!
"
)
;
nsString
*
attrValue
=
static_cast
<
nsString
*
>
(
aData
)
;
if
(
aNamespaceID
!
=
kNameSpaceID_Unknown
&
&
aNamespaceID
!
=
kNameSpaceID_Wildcard
)
{
return
attrValue
-
>
EqualsLiteral
(
"
*
"
)
?
aElement
-
>
HasAttr
(
aNamespaceID
aAttrName
)
:
aElement
-
>
AttrValueIs
(
aNamespaceID
aAttrName
*
attrValue
eCaseMatters
)
;
}
uint32_t
count
=
aElement
-
>
GetAttrCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
aElement
-
>
GetAttrNameAt
(
i
)
;
bool
nameMatch
;
if
(
name
-
>
IsAtom
(
)
)
{
nameMatch
=
name
-
>
Atom
(
)
=
=
aAttrName
;
}
else
if
(
aNamespaceID
=
=
kNameSpaceID_Wildcard
)
{
nameMatch
=
name
-
>
NodeInfo
(
)
-
>
Equals
(
aAttrName
)
;
}
else
{
nameMatch
=
name
-
>
NodeInfo
(
)
-
>
QualifiedNameEquals
(
aAttrName
)
;
}
if
(
nameMatch
)
{
return
attrValue
-
>
EqualsLiteral
(
"
*
"
)
|
|
aElement
-
>
AttrValueIs
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
*
attrValue
eCaseMatters
)
;
}
}
return
false
;
}
already_AddRefed
<
nsIHTMLCollection
>
nsINode
:
:
GetElementsByAttribute
(
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
{
RefPtr
<
nsAtom
>
attrAtom
(
NS_Atomize
(
aAttribute
)
)
;
nsAutoPtr
<
nsString
>
attrValue
(
new
nsString
(
aValue
)
)
;
RefPtr
<
nsContentList
>
list
=
new
nsContentList
(
this
MatchAttribute
nsContentUtils
:
:
DestroyMatchString
attrValue
.
forget
(
)
true
attrAtom
kNameSpaceID_Unknown
)
;
return
list
.
forget
(
)
;
}
already_AddRefed
<
nsIHTMLCollection
>
nsINode
:
:
GetElementsByAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aAttribute
const
nsAString
&
aValue
ErrorResult
&
aRv
)
{
RefPtr
<
nsAtom
>
attrAtom
(
NS_Atomize
(
aAttribute
)
)
;
nsAutoPtr
<
nsString
>
attrValue
(
new
nsString
(
aValue
)
)
;
int32_t
nameSpaceId
=
kNameSpaceID_Wildcard
;
if
(
!
aNamespaceURI
.
EqualsLiteral
(
"
*
"
)
)
{
nsresult
rv
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
RegisterNameSpace
(
aNamespaceURI
nameSpaceId
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
}
RefPtr
<
nsContentList
>
list
=
new
nsContentList
(
this
MatchAttribute
nsContentUtils
:
:
DestroyMatchString
attrValue
.
forget
(
)
true
attrAtom
nameSpaceId
)
;
return
list
.
forget
(
)
;
}
void
nsINode
:
:
Prepend
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
{
nsCOMPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsINode
>
node
=
ConvertNodesOrStringsIntoNode
(
aNodes
doc
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
refNode
=
mFirstChild
;
;
InsertBefore
(
*
node
refNode
aRv
)
;
}
void
nsINode
:
:
Append
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
{
nsCOMPtr
<
Document
>
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsINode
>
node
=
ConvertNodesOrStringsIntoNode
(
aNodes
doc
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
AppendChild
(
*
node
aRv
)
;
}
void
nsINode
:
:
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
{
MOZ_ASSERT
(
aKid
&
&
aKid
-
>
GetParentNode
(
)
=
=
this
"
Bogus
aKid
"
)
;
MOZ_ASSERT
(
!
IsAttr
(
)
)
;
nsMutationGuard
:
:
DidMutate
(
)
;
mozAutoDocUpdate
updateBatch
(
GetComposedDoc
(
)
aNotify
)
;
nsIContent
*
previousSibling
=
aKid
-
>
GetPreviousSibling
(
)
;
nsCOMPtr
<
nsIContent
>
kungfuDeathGrip
=
aKid
;
DisconnectChild
(
aKid
)
;
InvalidateChildNodes
(
)
;
if
(
aNotify
)
{
nsNodeUtils
:
:
ContentRemoved
(
this
aKid
previousSibling
)
;
}
aKid
-
>
UnbindFromTree
(
)
;
}
static
void
EnsureAllowedAsChild
(
nsINode
*
aNewChild
nsINode
*
aParent
bool
aIsReplace
nsINode
*
aRefChild
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aNewChild
"
Must
have
new
child
"
)
;
MOZ_ASSERT_IF
(
aIsReplace
aRefChild
)
;
MOZ_ASSERT
(
aParent
)
;
MOZ_ASSERT
(
aParent
-
>
IsDocument
(
)
|
|
aParent
-
>
IsDocumentFragment
(
)
|
|
aParent
-
>
IsElement
(
)
"
Nodes
that
are
not
documents
document
fragments
or
elements
"
"
can
'
t
be
parents
!
"
)
;
if
(
aNewChild
=
=
aParent
|
|
(
(
aNewChild
-
>
GetFirstChild
(
)
|
|
aNewChild
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
_template
|
|
(
aNewChild
-
>
IsElement
(
)
&
&
aNewChild
-
>
AsElement
(
)
-
>
GetShadowRoot
(
)
)
)
&
&
nsContentUtils
:
:
ContentIsHostIncludingDescendantOf
(
aParent
aNewChild
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
if
(
aRefChild
&
&
aRefChild
-
>
GetParentNode
(
)
!
=
aParent
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_FOUND_ERR
)
;
return
;
}
if
(
!
aNewChild
-
>
IsContent
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
switch
(
aNewChild
-
>
NodeType
(
)
)
{
case
nsINode
:
:
COMMENT_NODE
:
case
nsINode
:
:
PROCESSING_INSTRUCTION_NODE
:
return
;
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
CDATA_SECTION_NODE
:
case
nsINode
:
:
ENTITY_REFERENCE_NODE
:
if
(
aParent
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_NODE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
}
return
;
case
nsINode
:
:
ELEMENT_NODE
:
{
if
(
!
aParent
-
>
IsDocument
(
)
)
{
return
;
}
Document
*
parentDocument
=
aParent
-
>
AsDocument
(
)
;
Element
*
rootElement
=
parentDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
if
(
!
aIsReplace
|
|
rootElement
!
=
aRefChild
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
}
return
;
}
if
(
!
aRefChild
)
{
return
;
}
nsIContent
*
docTypeContent
=
parentDocument
-
>
GetDoctype
(
)
;
if
(
!
docTypeContent
)
{
return
;
}
int32_t
doctypeIndex
=
aParent
-
>
ComputeIndexOf
(
docTypeContent
)
;
int32_t
insertIndex
=
aParent
-
>
ComputeIndexOf
(
aRefChild
)
;
bool
ok
=
aIsReplace
?
(
insertIndex
>
=
doctypeIndex
)
:
insertIndex
>
doctypeIndex
;
if
(
!
ok
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
}
return
;
}
case
nsINode
:
:
DOCUMENT_TYPE_NODE
:
{
if
(
!
aParent
-
>
IsDocument
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
Document
*
parentDocument
=
aParent
-
>
AsDocument
(
)
;
nsIContent
*
docTypeContent
=
parentDocument
-
>
GetDoctype
(
)
;
if
(
docTypeContent
)
{
if
(
!
aIsReplace
|
|
docTypeContent
!
=
aRefChild
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
}
return
;
}
Element
*
rootElement
=
parentDocument
-
>
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
if
(
!
aRefChild
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
int32_t
rootIndex
=
aParent
-
>
ComputeIndexOf
(
rootElement
)
;
int32_t
insertIndex
=
aParent
-
>
ComputeIndexOf
(
aRefChild
)
;
if
(
insertIndex
>
rootIndex
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
}
return
;
}
case
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
:
{
if
(
!
aParent
-
>
IsDocument
(
)
)
{
return
;
}
bool
sawElement
=
false
;
for
(
nsIContent
*
child
=
aNewChild
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
if
(
sawElement
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
sawElement
=
true
;
}
EnsureAllowedAsChild
(
child
aParent
aIsReplace
aRefChild
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
return
;
}
default
:
break
;
}
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
}
void
nsINode
:
:
EnsurePreInsertionValidity
(
nsINode
&
aNewChild
nsINode
*
aRefChild
ErrorResult
&
aError
)
{
EnsurePreInsertionValidity1
(
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
;
}
EnsurePreInsertionValidity2
(
false
aNewChild
aRefChild
aError
)
;
}
void
nsINode
:
:
EnsurePreInsertionValidity1
(
ErrorResult
&
aError
)
{
if
(
!
IsDocument
(
)
&
&
!
IsDocumentFragment
(
)
&
&
!
IsElement
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
}
void
nsINode
:
:
EnsurePreInsertionValidity2
(
bool
aReplace
nsINode
&
aNewChild
nsINode
*
aRefChild
ErrorResult
&
aError
)
{
if
(
aNewChild
.
IsContent
(
)
&
&
aNewChild
.
AsContent
(
)
-
>
IsRootOfAnonymousSubtree
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
EnsureAllowedAsChild
(
&
aNewChild
this
aReplace
aRefChild
aError
)
;
}
nsINode
*
nsINode
:
:
ReplaceOrInsertBefore
(
bool
aReplace
nsINode
*
aNewChild
nsINode
*
aRefChild
ErrorResult
&
aError
)
{
MOZ_ASSERT_IF
(
aReplace
aRefChild
)
;
EnsurePreInsertionValidity1
(
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
EnsurePreInsertionValidity2
(
aReplace
*
aNewChild
aRefChild
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
uint16_t
nodeType
=
aNewChild
-
>
NodeType
(
)
;
{
nsMutationGuard
guard
;
if
(
aReplace
&
&
aRefChild
!
=
aNewChild
)
{
nsContentUtils
:
:
MaybeFireNodeRemoved
(
aRefChild
this
)
;
}
nsINode
*
oldParent
=
aNewChild
-
>
GetParentNode
(
)
;
if
(
oldParent
)
{
nsContentUtils
:
:
MaybeFireNodeRemoved
(
aNewChild
oldParent
)
;
}
if
(
nodeType
=
=
DOCUMENT_FRAGMENT_NODE
)
{
static_cast
<
FragmentOrElement
*
>
(
aNewChild
)
-
>
FireNodeRemovedForChildren
(
)
;
}
if
(
guard
.
Mutated
(
0
)
)
{
EnsurePreInsertionValidity2
(
aReplace
*
aNewChild
aRefChild
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
nsIContent
*
nodeToInsertBefore
;
if
(
aReplace
)
{
nodeToInsertBefore
=
aRefChild
-
>
GetNextSibling
(
)
;
}
else
{
nodeToInsertBefore
=
aRefChild
?
aRefChild
-
>
AsContent
(
)
:
nullptr
;
}
if
(
nodeToInsertBefore
=
=
aNewChild
)
{
nodeToInsertBefore
=
nodeToInsertBefore
-
>
GetNextSibling
(
)
;
}
Maybe
<
AutoTArray
<
nsCOMPtr
<
nsIContent
>
50
>
>
fragChildren
;
nsIContent
*
newContent
=
aNewChild
-
>
AsContent
(
)
;
nsCOMPtr
<
nsINode
>
oldParent
=
newContent
-
>
GetParentNode
(
)
;
if
(
oldParent
)
{
nsCOMPtr
<
nsINode
>
kungFuDeathGrip
=
nodeToInsertBefore
;
nsMutationGuard
guard
;
{
mozAutoDocUpdate
batch
(
newContent
-
>
GetComposedDoc
(
)
true
)
;
nsAutoMutationBatch
mb
(
oldParent
true
true
)
;
nsIContent
*
previous
=
aNewChild
-
>
GetPreviousSibling
(
)
;
nsIContent
*
next
=
aNewChild
-
>
GetNextSibling
(
)
;
oldParent
-
>
RemoveChildNode
(
aNewChild
-
>
AsContent
(
)
true
)
;
if
(
nsAutoMutationBatch
:
:
GetCurrentBatch
(
)
=
=
&
mb
)
{
mb
.
RemovalDone
(
)
;
mb
.
SetPrevSibling
(
previous
)
;
mb
.
SetNextSibling
(
next
)
;
}
}
if
(
guard
.
Mutated
(
1
)
)
{
if
(
newContent
-
>
GetParentNode
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
nullptr
;
}
if
(
aNewChild
=
=
aRefChild
)
{
EnsureAllowedAsChild
(
newContent
this
false
nodeToInsertBefore
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
else
{
EnsureAllowedAsChild
(
newContent
this
aReplace
aRefChild
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
aReplace
)
{
nodeToInsertBefore
=
aRefChild
-
>
GetNextSibling
(
)
;
}
else
{
nodeToInsertBefore
=
aRefChild
?
aRefChild
-
>
AsContent
(
)
:
nullptr
;
}
}
}
}
else
if
(
nodeType
=
=
DOCUMENT_FRAGMENT_NODE
)
{
uint32_t
count
=
newContent
-
>
GetChildCount
(
)
;
fragChildren
.
emplace
(
)
;
fragChildren
-
>
SetCapacity
(
count
)
;
for
(
nsIContent
*
child
=
newContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
child
-
>
GetComposedDoc
(
)
=
=
nullptr
"
How
did
we
get
a
child
with
a
current
doc
?
"
)
;
fragChildren
-
>
AppendElement
(
child
)
;
}
nsCOMPtr
<
nsINode
>
kungFuDeathGrip
=
nodeToInsertBefore
;
nsMutationGuard
guard
;
{
mozAutoDocUpdate
batch
(
newContent
-
>
GetComposedDoc
(
)
true
)
;
nsAutoMutationBatch
mb
(
newContent
false
true
)
;
while
(
newContent
-
>
HasChildren
(
)
)
{
newContent
-
>
RemoveChildNode
(
newContent
-
>
GetLastChild
(
)
true
)
;
}
}
if
(
guard
.
Mutated
(
count
)
)
{
if
(
nodeToInsertBefore
&
&
nodeToInsertBefore
-
>
GetParent
(
)
!
=
this
)
{
aError
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
nullptr
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
if
(
fragChildren
-
>
ElementAt
(
i
)
-
>
GetParentNode
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
nullptr
;
}
}
if
(
aRefChild
&
&
aRefChild
-
>
GetParent
(
)
!
=
this
)
{
aError
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
nullptr
;
}
if
(
aReplace
)
{
nodeToInsertBefore
=
aRefChild
-
>
GetNextSibling
(
)
;
}
else
{
nodeToInsertBefore
=
aRefChild
?
aRefChild
-
>
AsContent
(
)
:
nullptr
;
}
if
(
IsDocument
(
)
)
{
bool
sawElement
=
false
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsIContent
*
child
=
fragChildren
-
>
ElementAt
(
i
)
;
if
(
child
-
>
IsElement
(
)
)
{
if
(
sawElement
)
{
aError
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
nullptr
;
}
sawElement
=
true
;
}
EnsureAllowedAsChild
(
child
this
aReplace
aRefChild
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
}
}
mozAutoDocUpdate
batch
(
GetComposedDoc
(
)
true
)
;
nsAutoMutationBatch
mb
;
if
(
aReplace
&
&
aRefChild
!
=
aNewChild
)
{
mb
.
Init
(
this
true
true
)
;
NS_ASSERTION
(
aRefChild
-
>
GetNextSibling
(
)
=
=
nodeToInsertBefore
"
Unexpected
nodeToInsertBefore
"
)
;
nsIContent
*
toBeRemoved
=
nodeToInsertBefore
?
nodeToInsertBefore
-
>
GetPreviousSibling
(
)
:
GetLastChild
(
)
;
MOZ_ASSERT
(
toBeRemoved
)
;
RemoveChildNode
(
toBeRemoved
true
)
;
}
Document
*
doc
=
OwnerDoc
(
)
;
if
(
doc
!
=
newContent
-
>
OwnerDoc
(
)
)
{
AdoptNodeIntoOwnerDoc
(
this
aNewChild
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
else
if
(
doc
-
>
DidDocumentOpen
(
)
)
{
CheckForOutdatedParent
(
this
aNewChild
aError
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
nsINode
*
result
=
aReplace
?
aRefChild
:
aNewChild
;
if
(
nodeType
=
=
DOCUMENT_FRAGMENT_NODE
)
{
if
(
!
aReplace
)
{
mb
.
Init
(
this
true
true
)
;
}
nsAutoMutationBatch
*
mutationBatch
=
nsAutoMutationBatch
:
:
GetCurrentBatch
(
)
;
if
(
mutationBatch
)
{
mutationBatch
-
>
RemovalDone
(
)
;
mutationBatch
-
>
SetPrevSibling
(
nodeToInsertBefore
?
nodeToInsertBefore
-
>
GetPreviousSibling
(
)
:
GetLastChild
(
)
)
;
mutationBatch
-
>
SetNextSibling
(
nodeToInsertBefore
)
;
}
uint32_t
count
=
fragChildren
-
>
Length
(
)
;
if
(
!
count
)
{
return
result
;
}
bool
appending
=
!
IsDocument
(
)
&
&
!
nodeToInsertBefore
;
nsIContent
*
firstInsertedContent
=
fragChildren
-
>
ElementAt
(
0
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
aError
=
InsertChildBefore
(
fragChildren
-
>
ElementAt
(
i
)
nodeToInsertBefore
!
appending
)
;
if
(
aError
.
Failed
(
)
)
{
if
(
appending
&
&
i
!
=
0
)
{
nsNodeUtils
:
:
ContentAppended
(
static_cast
<
nsIContent
*
>
(
this
)
firstInsertedContent
)
;
}
return
nullptr
;
}
}
if
(
mutationBatch
&
&
!
appending
)
{
mutationBatch
-
>
NodesAdded
(
)
;
}
if
(
appending
)
{
nsNodeUtils
:
:
ContentAppended
(
static_cast
<
nsIContent
*
>
(
this
)
firstInsertedContent
)
;
if
(
mutationBatch
)
{
mutationBatch
-
>
NodesAdded
(
)
;
}
if
(
nsContentUtils
:
:
HasMutationListeners
(
doc
NS_EVENT_BITS_MUTATION_NODEINSERTED
)
)
{
Element
:
:
FireNodeInserted
(
doc
this
*
fragChildren
)
;
}
}
}
else
{
if
(
nsAutoMutationBatch
:
:
GetCurrentBatch
(
)
=
=
&
mb
)
{
mb
.
RemovalDone
(
)
;
mb
.
SetPrevSibling
(
nodeToInsertBefore
?
nodeToInsertBefore
-
>
GetPreviousSibling
(
)
:
GetLastChild
(
)
)
;
mb
.
SetNextSibling
(
nodeToInsertBefore
)
;
}
aError
=
InsertChildBefore
(
newContent
nodeToInsertBefore
true
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
}
return
result
;
}
void
nsINode
:
:
BindObject
(
nsISupports
*
aObject
)
{
nsCOMArray
<
nsISupports
>
*
objects
=
static_cast
<
nsCOMArray
<
nsISupports
>
*
>
(
GetProperty
(
nsGkAtoms
:
:
keepobjectsalive
)
)
;
if
(
!
objects
)
{
objects
=
new
nsCOMArray
<
nsISupports
>
(
)
;
SetProperty
(
nsGkAtoms
:
:
keepobjectsalive
objects
nsINode
:
:
DeleteProperty
<
nsCOMArray
<
nsISupports
>
>
true
)
;
}
objects
-
>
AppendObject
(
aObject
)
;
}
void
nsINode
:
:
UnbindObject
(
nsISupports
*
aObject
)
{
nsCOMArray
<
nsISupports
>
*
objects
=
static_cast
<
nsCOMArray
<
nsISupports
>
*
>
(
GetProperty
(
nsGkAtoms
:
:
keepobjectsalive
)
)
;
if
(
objects
)
{
objects
-
>
RemoveObject
(
aObject
)
;
}
}
already_AddRefed
<
AccessibleNode
>
nsINode
:
:
GetAccessibleNode
(
)
{
#
ifdef
ACCESSIBILITY
nsresult
rv
=
NS_OK
;
RefPtr
<
AccessibleNode
>
anode
=
static_cast
<
AccessibleNode
*
>
(
GetProperty
(
nsGkAtoms
:
:
accessiblenode
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
anode
=
new
AccessibleNode
(
this
)
;
RefPtr
<
AccessibleNode
>
temp
=
anode
;
rv
=
SetProperty
(
nsGkAtoms
:
:
accessiblenode
temp
.
forget
(
)
.
take
(
)
nsPropertyTable
:
:
SupportsDtorFunc
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
SetProperty
failed
"
)
;
return
nullptr
;
}
}
return
anode
.
forget
(
)
;
#
else
return
nullptr
;
#
endif
}
void
nsINode
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
if
(
elm
)
{
*
aNodeSize
+
=
elm
-
>
SizeOfIncludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
}
}
void
nsINode
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
*
aNodeSize
+
=
aSizes
.
mState
.
mMallocSizeOf
(
this
)
;
AddSizeOfExcludingThis
(
aSizes
aNodeSize
)
;
}
bool
nsINode
:
:
Contains
(
const
nsINode
*
aOther
)
const
{
if
(
aOther
=
=
this
)
{
return
true
;
}
if
(
!
aOther
|
|
OwnerDoc
(
)
!
=
aOther
-
>
OwnerDoc
(
)
|
|
IsInUncomposedDoc
(
)
!
=
aOther
-
>
IsInUncomposedDoc
(
)
|
|
!
aOther
-
>
IsContent
(
)
|
|
!
GetFirstChild
(
)
)
{
return
false
;
}
const
nsIContent
*
other
=
static_cast
<
const
nsIContent
*
>
(
aOther
)
;
if
(
this
=
=
OwnerDoc
(
)
)
{
return
!
other
-
>
IsInAnonymousSubtree
(
)
;
}
if
(
!
IsElement
(
)
&
&
!
IsDocumentFragment
(
)
)
{
return
false
;
}
if
(
AsContent
(
)
-
>
GetBindingParent
(
)
!
=
other
-
>
GetBindingParent
(
)
)
{
return
false
;
}
return
nsContentUtils
:
:
ContentIsDescendantOf
(
other
this
)
;
}
uint32_t
nsINode
:
:
Length
(
)
const
{
switch
(
NodeType
(
)
)
{
case
DOCUMENT_TYPE_NODE
:
return
0
;
case
TEXT_NODE
:
case
CDATA_SECTION_NODE
:
case
PROCESSING_INSTRUCTION_NODE
:
case
COMMENT_NODE
:
MOZ_ASSERT
(
IsContent
(
)
)
;
return
AsContent
(
)
-
>
TextLength
(
)
;
default
:
return
GetChildCount
(
)
;
}
}
const
RawServoSelectorList
*
nsINode
:
:
ParseSelectorList
(
const
nsAString
&
aSelectorString
ErrorResult
&
aRv
)
{
Document
*
doc
=
OwnerDoc
(
)
;
Document
:
:
SelectorCache
&
cache
=
doc
-
>
GetSelectorCache
(
)
;
Document
:
:
SelectorCache
:
:
SelectorList
*
list
=
cache
.
GetList
(
aSelectorString
)
;
if
(
list
)
{
if
(
!
*
list
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_SYNTAX_ERR
NS_LITERAL_CSTRING
(
"
'
"
)
+
NS_ConvertUTF16toUTF8
(
aSelectorString
)
+
NS_LITERAL_CSTRING
(
"
'
is
not
a
valid
selector
"
)
)
;
return
nullptr
;
}
return
list
-
>
get
(
)
;
}
NS_ConvertUTF16toUTF8
selectorString
(
aSelectorString
)
;
auto
selectorList
=
UniquePtr
<
RawServoSelectorList
>
(
Servo_SelectorList_Parse
(
&
selectorString
)
)
;
if
(
!
selectorList
)
{
aRv
.
ThrowDOMException
(
NS_ERROR_DOM_SYNTAX_ERR
NS_LITERAL_CSTRING
(
"
'
"
)
+
selectorString
+
NS_LITERAL_CSTRING
(
"
'
is
not
a
valid
selector
"
)
)
;
}
auto
*
ret
=
selectorList
.
get
(
)
;
cache
.
CacheList
(
aSelectorString
std
:
:
move
(
selectorList
)
)
;
return
ret
;
}
inline
static
Element
*
FindMatchingElementWithId
(
const
nsAString
&
aId
const
Element
&
aRoot
const
DocumentOrShadowRoot
&
aContainingDocOrShadowRoot
)
{
MOZ_ASSERT
(
aRoot
.
SubtreeRoot
(
)
=
=
&
aContainingDocOrShadowRoot
.
AsNode
(
)
)
;
MOZ_ASSERT
(
aRoot
.
IsInUncomposedDoc
(
)
|
|
aRoot
.
IsInShadowTree
(
)
"
Don
'
t
call
me
if
the
root
is
not
in
the
document
or
in
a
shadow
tree
"
)
;
const
nsTArray
<
Element
*
>
*
elements
=
aContainingDocOrShadowRoot
.
GetAllElementsForId
(
aId
)
;
if
(
!
elements
)
{
return
nullptr
;
}
for
(
Element
*
element
:
*
elements
)
{
if
(
MOZ_UNLIKELY
(
element
=
=
&
aRoot
)
)
{
continue
;
}
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
element
&
aRoot
)
)
{
continue
;
}
return
element
;
}
return
nullptr
;
}
Element
*
nsINode
:
:
QuerySelector
(
const
nsAString
&
aSelector
ErrorResult
&
aResult
)
{
AUTO_PROFILER_LABEL_DYNAMIC_LOSSY_NSSTRING
(
"
nsINode
:
:
QuerySelector
"
LAYOUT_SelectorQuery
aSelector
)
;
const
RawServoSelectorList
*
list
=
ParseSelectorList
(
aSelector
aResult
)
;
if
(
!
list
)
{
return
nullptr
;
}
const
bool
useInvalidation
=
false
;
return
const_cast
<
Element
*
>
(
Servo_SelectorList_QueryFirst
(
this
list
useInvalidation
)
)
;
}
already_AddRefed
<
nsINodeList
>
nsINode
:
:
QuerySelectorAll
(
const
nsAString
&
aSelector
ErrorResult
&
aResult
)
{
AUTO_PROFILER_LABEL_DYNAMIC_LOSSY_NSSTRING
(
"
nsINode
:
:
QuerySelectorAll
"
LAYOUT_SelectorQuery
aSelector
)
;
RefPtr
<
nsSimpleContentList
>
contentList
=
new
nsSimpleContentList
(
this
)
;
const
RawServoSelectorList
*
list
=
ParseSelectorList
(
aSelector
aResult
)
;
if
(
!
list
)
{
return
contentList
.
forget
(
)
;
}
const
bool
useInvalidation
=
false
;
Servo_SelectorList_QueryAll
(
this
list
contentList
.
get
(
)
useInvalidation
)
;
return
contentList
.
forget
(
)
;
}
Element
*
nsINode
:
:
GetElementById
(
const
nsAString
&
aId
)
{
MOZ_ASSERT
(
!
IsShadowRoot
(
)
"
Should
use
the
faster
version
"
)
;
MOZ_ASSERT
(
IsElement
(
)
|
|
IsDocumentFragment
(
)
"
Bogus
this
object
for
GetElementById
call
"
)
;
if
(
IsInUncomposedDoc
(
)
)
{
MOZ_ASSERT
(
IsElement
(
)
"
Huh
?
A
fragment
in
a
document
?
"
)
;
return
FindMatchingElementWithId
(
aId
*
AsElement
(
)
*
OwnerDoc
(
)
)
;
}
if
(
ShadowRoot
*
containingShadow
=
AsContent
(
)
-
>
GetContainingShadow
(
)
)
{
MOZ_ASSERT
(
IsElement
(
)
"
Huh
?
A
fragment
in
a
ShadowRoot
?
"
)
;
return
FindMatchingElementWithId
(
aId
*
AsElement
(
)
*
containingShadow
)
;
}
for
(
nsIContent
*
kid
=
GetFirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextNode
(
this
)
)
{
if
(
!
kid
-
>
IsElement
(
)
)
{
continue
;
}
nsAtom
*
id
=
kid
-
>
AsElement
(
)
-
>
GetID
(
)
;
if
(
id
&
&
id
-
>
Equals
(
aId
)
)
{
return
kid
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
JSObject
*
nsINode
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
bool
hasHadScriptHandlingObject
=
false
;
if
(
!
OwnerDoc
(
)
-
>
GetScriptHandlingObject
(
hasHadScriptHandlingObject
)
&
&
!
hasHadScriptHandlingObject
&
&
!
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
)
{
Throw
(
aCx
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
WrapNode
(
aCx
aGivenProto
)
)
;
if
(
obj
&
&
ChromeOnlyAccess
(
)
)
{
MOZ_RELEASE_ASSERT
(
JS
:
:
GetNonCCWObjectGlobal
(
obj
)
=
=
xpc
:
:
UnprivilegedJunkScope
(
)
|
|
xpc
:
:
IsInUAWidgetScope
(
obj
)
|
|
xpc
:
:
AccessCheck
:
:
isChrome
(
obj
)
)
;
}
return
obj
;
}
already_AddRefed
<
nsINode
>
nsINode
:
:
CloneNode
(
bool
aDeep
ErrorResult
&
aError
)
{
return
nsNodeUtils
:
:
CloneNodeImpl
(
this
aDeep
aError
)
;
}
nsDOMAttributeMap
*
nsINode
:
:
GetAttributes
(
)
{
if
(
!
IsElement
(
)
)
{
return
nullptr
;
}
return
AsElement
(
)
-
>
Attributes
(
)
;
}
Element
*
nsINode
:
:
GetParentElementCrossingShadowRoot
(
)
const
{
if
(
!
mParent
)
{
return
nullptr
;
}
if
(
mParent
-
>
IsElement
(
)
)
{
return
mParent
-
>
AsElement
(
)
;
}
if
(
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
mParent
)
)
{
MOZ_ASSERT
(
shadowRoot
-
>
GetHost
(
)
"
ShowRoots
should
always
have
a
host
"
)
;
return
shadowRoot
-
>
GetHost
(
)
;
}
return
nullptr
;
}
bool
nsINode
:
:
HasBoxQuadsSupport
(
JSContext
*
aCx
JSObject
*
)
{
return
xpc
:
:
AccessCheck
:
:
isChrome
(
js
:
:
GetContextCompartment
(
aCx
)
)
|
|
nsContentUtils
:
:
GetBoxQuadsEnabled
(
)
;
}
nsINode
*
nsINode
:
:
GetScopeChainParent
(
)
const
{
return
nullptr
;
}
Element
*
nsINode
:
:
GetParentFlexElement
(
)
{
if
(
!
IsContent
(
)
)
{
return
nullptr
;
}
nsIFrame
*
primaryFrame
=
AsContent
(
)
-
>
GetPrimaryFrame
(
FlushType
:
:
Frames
)
;
for
(
nsIFrame
*
f
=
primaryFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
!
=
primaryFrame
&
&
!
f
-
>
Style
(
)
-
>
IsAnonBox
(
)
)
{
break
;
}
if
(
f
-
>
IsFlexItem
(
)
)
{
return
f
-
>
GetParent
(
)
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
void
nsINode
:
:
AddAnimationObserver
(
nsIAnimationObserver
*
aAnimationObserver
)
{
AddMutationObserver
(
aAnimationObserver
)
;
OwnerDoc
(
)
-
>
SetMayHaveAnimationObservers
(
)
;
}
void
nsINode
:
:
AddAnimationObserverUnlessExists
(
nsIAnimationObserver
*
aAnimationObserver
)
{
AddMutationObserverUnlessExists
(
aAnimationObserver
)
;
OwnerDoc
(
)
-
>
SetMayHaveAnimationObservers
(
)
;
}
void
nsINode
:
:
GenerateXPath
(
nsAString
&
aResult
)
{
XPathGenerator
:
:
Generate
(
this
aResult
)
;
}
bool
nsINode
:
:
IsApzAware
(
)
const
{
return
IsNodeApzAware
(
)
;
}
bool
nsINode
:
:
IsNodeApzAwareInternal
(
)
const
{
return
EventTarget
:
:
IsApzAware
(
)
;
}
DocGroup
*
nsINode
:
:
GetDocGroup
(
)
const
{
return
OwnerDoc
(
)
-
>
GetDocGroup
(
)
;
}
class
LocalizationHandler
:
public
PromiseNativeHandler
{
public
:
LocalizationHandler
(
)
=
default
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
LocalizationHandler
)
nsTArray
<
nsCOMPtr
<
Element
>
>
&
Elements
(
)
{
return
mElements
;
}
void
SetReturnValuePromise
(
Promise
*
aReturnValuePromise
)
{
mReturnValuePromise
=
aReturnValuePromise
;
}
virtual
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
nsTArray
<
L10nValue
>
l10nData
;
if
(
aValue
.
isObject
(
)
)
{
JS
:
:
ForOfIterator
iter
(
aCx
)
;
if
(
!
iter
.
init
(
aValue
JS
:
:
ForOfIterator
:
:
AllowNonIterable
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
if
(
!
iter
.
valueIsIterable
(
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
temp
(
aCx
)
;
while
(
true
)
{
bool
done
;
if
(
!
iter
.
next
(
&
temp
&
done
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
if
(
done
)
{
break
;
}
L10nValue
*
slotPtr
=
l10nData
.
AppendElement
(
mozilla
:
:
fallible
)
;
if
(
!
slotPtr
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
if
(
!
slotPtr
-
>
Init
(
aCx
temp
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
}
}
if
(
mElements
.
Length
(
)
!
=
l10nData
.
Length
(
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
untranslatedElements
(
aCx
JS_NewArrayObject
(
aCx
mElements
.
Length
(
)
)
)
;
if
(
!
untranslatedElements
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
ErrorResult
rv
;
for
(
size_t
i
=
0
;
i
<
l10nData
.
Length
(
)
;
+
+
i
)
{
Element
*
elem
=
mElements
[
i
]
;
nsString
&
content
=
l10nData
[
i
]
.
mValue
;
if
(
!
content
.
IsVoid
(
)
)
{
elem
-
>
SetTextContent
(
content
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
}
Nullable
<
Sequence
<
AttributeNameValue
>
>
&
attributes
=
l10nData
[
i
]
.
mAttributes
;
if
(
!
attributes
.
IsNull
(
)
)
{
for
(
size_t
j
=
0
;
j
<
attributes
.
Value
(
)
.
Length
(
)
;
+
+
j
)
{
elem
-
>
SetAttribute
(
attributes
.
Value
(
)
[
j
]
.
mName
attributes
.
Value
(
)
[
j
]
.
mValue
rv
)
;
if
(
rv
.
Failed
(
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
}
}
if
(
content
.
IsVoid
(
)
&
&
attributes
.
IsNull
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
wrappedElem
(
aCx
)
;
if
(
!
ToJSValue
(
aCx
elem
&
wrappedElem
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
if
(
!
JS_DefineElement
(
aCx
untranslatedElements
i
wrappedElem
JSPROP_ENUMERATE
)
)
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
}
}
JS
:
:
RootedObject
sourceScope
(
aCx
JS
:
:
CurrentGlobalOrNull
(
aCx
)
)
;
AutoEntryScript
aes
(
mReturnValuePromise
-
>
GetParentObject
(
)
"
Promise
resolution
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
result
(
cx
JS
:
:
ObjectValue
(
*
untranslatedElements
)
)
;
xpc
:
:
StackScopedCloneOptions
options
;
options
.
wrapReflectors
=
true
;
StackScopedClone
(
cx
options
sourceScope
&
result
)
;
mReturnValuePromise
-
>
MaybeResolve
(
result
)
;
}
virtual
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
)
override
{
mReturnValuePromise
-
>
MaybeRejectWithUndefined
(
)
;
}
private
:
~
LocalizationHandler
(
)
=
default
;
nsTArray
<
nsCOMPtr
<
Element
>
>
mElements
;
RefPtr
<
Promise
>
mReturnValuePromise
;
}
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
LocalizationHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
LocalizationHandler
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
LocalizationHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
LocalizationHandler
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
LocalizationHandler
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mElements
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReturnValuePromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
LocalizationHandler
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mElements
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReturnValuePromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
already_AddRefed
<
Promise
>
nsINode
:
:
Localize
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
L10nCallback
&
aCallback
mozilla
:
:
ErrorResult
&
aRv
)
{
Sequence
<
L10nElement
>
l10nElements
;
SequenceRooter
<
L10nElement
>
rooter
(
aCx
&
l10nElements
)
;
RefPtr
<
LocalizationHandler
>
nativeHandler
=
new
LocalizationHandler
(
)
;
nsTArray
<
nsCOMPtr
<
Element
>
>
&
domElements
=
nativeHandler
-
>
Elements
(
)
;
nsIContent
*
node
=
IsContent
(
)
?
AsContent
(
)
:
GetFirstChild
(
)
;
nsAutoString
l10nId
;
nsAutoString
l10nArgs
;
nsAutoString
l10nAttrs
;
nsAutoString
type
;
for
(
;
node
;
node
=
node
-
>
GetNextNode
(
this
)
)
{
if
(
!
node
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
domElement
=
node
-
>
AsElement
(
)
;
if
(
!
domElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
datal10nid
l10nId
)
)
{
continue
;
}
domElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
datal10nargs
l10nArgs
)
;
domElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
datal10nattrs
l10nAttrs
)
;
L10nElement
*
element
=
l10nElements
.
AppendElement
(
fallible
)
;
if
(
!
element
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
if
(
!
domElements
.
AppendElement
(
domElement
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
domElement
-
>
GetNamespaceURI
(
element
-
>
mNamespaceURI
)
;
element
-
>
mLocalName
=
domElement
-
>
LocalName
(
)
;
domElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
type
)
;
if
(
!
type
.
IsEmpty
(
)
)
{
element
-
>
mType
=
type
;
}
element
-
>
mL10nId
=
l10nId
;
if
(
!
l10nAttrs
.
IsEmpty
(
)
)
{
element
-
>
mL10nAttrs
=
l10nAttrs
;
}
if
(
!
l10nArgs
.
IsEmpty
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
json
(
aCx
)
;
if
(
!
JS_ParseJSON
(
aCx
l10nArgs
.
get
(
)
l10nArgs
.
Length
(
)
&
json
)
|
|
!
json
.
isObject
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SYNTAX_ERR
)
;
return
nullptr
;
}
element
-
>
mL10nArgs
=
&
json
.
toObject
(
)
;
}
}
RefPtr
<
Promise
>
callbackResult
=
aCallback
.
Call
(
l10nElements
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
OwnerDoc
(
)
-
>
GetParentObject
(
)
aRv
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
nullptr
;
}
nativeHandler
-
>
SetReturnValuePromise
(
promise
)
;
callbackResult
-
>
AppendNativeHandler
(
nativeHandler
)
;
return
promise
.
forget
(
)
;
}
nsINode
*
nsINode
:
:
GetFlattenedTreeParentNodeNonInline
(
)
const
{
return
GetFlattenedTreeParentNode
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsNodeWeakReference
nsIWeakReference
)
nsNodeWeakReference
:
:
nsNodeWeakReference
(
nsINode
*
aNode
)
:
nsIWeakReference
(
aNode
)
{
}
nsNodeWeakReference
:
:
~
nsNodeWeakReference
(
)
{
nsINode
*
node
=
static_cast
<
nsINode
*
>
(
mObject
)
;
if
(
node
)
{
NS_ASSERTION
(
node
-
>
Slots
(
)
-
>
mWeakReference
=
=
this
"
Weak
reference
has
wrong
value
"
)
;
node
-
>
Slots
(
)
-
>
mWeakReference
=
nullptr
;
}
}
NS_IMETHODIMP
nsNodeWeakReference
:
:
QueryReferentFromScript
(
const
nsIID
&
aIID
void
*
*
aInstancePtr
)
{
return
QueryReferent
(
aIID
aInstancePtr
)
;
}
size_t
nsNodeWeakReference
:
:
SizeOfOnlyThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
;
}
