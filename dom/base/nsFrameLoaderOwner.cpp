#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
FrameLoaderBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
MozFrameLoaderOwnerBinding
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
already_AddRefed
<
nsFrameLoader
>
nsFrameLoaderOwner
:
:
GetFrameLoader
(
)
{
return
do_AddRef
(
mFrameLoader
)
;
}
void
nsFrameLoaderOwner
:
:
SetFrameLoader
(
nsFrameLoader
*
aNewFrameLoader
)
{
mFrameLoader
=
aNewFrameLoader
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
BrowsingContext
>
nsFrameLoaderOwner
:
:
GetBrowsingContext
(
)
{
if
(
mFrameLoader
)
{
return
mFrameLoader
-
>
GetBrowsingContext
(
)
;
}
return
nullptr
;
}
bool
nsFrameLoaderOwner
:
:
UseRemoteSubframes
(
)
{
RefPtr
<
Element
>
owner
=
do_QueryObject
(
this
)
;
MOZ_ASSERT
(
this
)
;
nsILoadContext
*
loadContext
=
owner
-
>
OwnerDoc
(
)
-
>
GetLoadContext
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
loadContext
)
;
return
loadContext
-
>
UseRemoteSubframes
(
)
;
}
bool
nsFrameLoaderOwner
:
:
ShouldPreserveBrowsingContext
(
const
mozilla
:
:
dom
:
:
RemotenessOptions
&
aOptions
)
{
if
(
aOptions
.
mReplaceBrowsingContext
)
{
return
false
;
}
if
(
XRE_IsParentProcess
(
)
&
&
aOptions
.
mRemoteType
.
IsVoid
(
)
)
{
return
false
;
}
return
UseRemoteSubframes
(
)
|
|
StaticPrefs
:
:
fission_preserve_browsing_contexts
(
)
;
}
void
nsFrameLoaderOwner
:
:
ChangeRemotenessCommon
(
bool
aPreserveContext
const
nsAString
&
aRemoteType
std
:
:
function
<
void
(
)
>
&
aFrameLoaderInit
mozilla
:
:
ErrorResult
&
aRv
)
{
RefPtr
<
mozilla
:
:
dom
:
:
BrowsingContext
>
bc
;
bool
networkCreated
=
false
;
RefPtr
<
Element
>
owner
=
do_QueryObject
(
this
)
;
MOZ_ASSERT
(
owner
)
;
Document
*
doc
=
owner
-
>
OwnerDoc
(
)
;
doc
-
>
BlockOnload
(
)
;
auto
cleanup
=
MakeScopeExit
(
[
&
]
(
)
{
doc
-
>
UnblockOnload
(
false
)
;
}
)
;
if
(
mFrameLoader
)
{
if
(
aPreserveContext
)
{
bc
=
mFrameLoader
-
>
GetBrowsingContext
(
)
;
mFrameLoader
-
>
SkipBrowsingContextDetach
(
)
;
}
networkCreated
=
mFrameLoader
-
>
IsNetworkCreated
(
)
;
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
}
mFrameLoader
=
nsFrameLoader
:
:
Recreate
(
owner
bc
aRemoteType
networkCreated
)
;
if
(
NS_WARN_IF
(
!
mFrameLoader
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aFrameLoaderInit
(
)
;
if
(
NS_WARN_IF
(
aRv
.
Failed
(
)
)
)
{
return
;
}
if
(
nsSubDocumentFrame
*
ourFrame
=
do_QueryFrame
(
owner
-
>
GetPrimaryFrame
(
)
)
)
{
ourFrame
-
>
ResetFrameLoader
(
)
;
}
if
(
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
if
(
fm
-
>
GetFocusedElement
(
)
=
=
owner
)
{
fm
-
>
ActivateRemoteFrameIfNeeded
(
*
owner
)
;
}
}
if
(
owner
-
>
GetPrimaryFrame
(
)
)
{
EventStateManager
*
eventManager
=
owner
-
>
GetPrimaryFrame
(
)
-
>
PresContext
(
)
-
>
EventStateManager
(
)
;
eventManager
-
>
RecomputeMouseEnterStateForRemoteFrame
(
*
owner
)
;
}
if
(
owner
-
>
IsXULElement
(
)
)
{
(
new
mozilla
:
:
AsyncEventDispatcher
(
owner
NS_LITERAL_STRING
(
"
XULFrameLoaderCreated
"
)
mozilla
:
:
CanBubble
:
:
eYes
mozilla
:
:
ChromeOnlyDispatch
:
:
eYes
)
)
-
>
RunDOMEventWhenSafe
(
)
;
}
}
void
nsFrameLoaderOwner
:
:
ChangeRemoteness
(
const
mozilla
:
:
dom
:
:
RemotenessOptions
&
aOptions
mozilla
:
:
ErrorResult
&
rv
)
{
std
:
:
function
<
void
(
)
>
frameLoaderInit
=
[
&
]
{
if
(
aOptions
.
mError
.
WasPassed
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
;
}
nsDocShell
*
docShell
=
mFrameLoader
-
>
GetDocShell
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
;
}
bool
displayed
=
false
;
docShell
-
>
DisplayLoadError
(
static_cast
<
nsresult
>
(
aOptions
.
mError
.
Value
(
)
)
uri
u
"
about
:
blank
"
nullptr
&
displayed
)
;
}
else
if
(
aOptions
.
mPendingSwitchID
.
WasPassed
(
)
)
{
mFrameLoader
-
>
ResumeLoad
(
aOptions
.
mPendingSwitchID
.
Value
(
)
)
;
}
else
{
mFrameLoader
-
>
LoadFrame
(
false
)
;
}
}
;
ChangeRemotenessCommon
(
ShouldPreserveBrowsingContext
(
aOptions
)
aOptions
.
mRemoteType
frameLoaderInit
rv
)
;
}
void
nsFrameLoaderOwner
:
:
ChangeRemotenessWithBridge
(
mozilla
:
:
ipc
:
:
ManagedEndpoint
<
mozilla
:
:
dom
:
:
PBrowserBridgeChild
>
aEndpoint
uint64_t
aTabId
mozilla
:
:
ErrorResult
&
rv
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
NS_WARN_IF
(
!
mFrameLoader
)
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
std
:
:
function
<
void
(
)
>
frameLoaderInit
=
[
&
]
{
RefPtr
<
BrowsingContext
>
browsingContext
=
mFrameLoader
-
>
mBrowsingContext
;
RefPtr
<
BrowserBridgeChild
>
bridge
=
new
BrowserBridgeChild
(
mFrameLoader
browsingContext
TabId
(
aTabId
)
)
;
Document
*
ownerDoc
=
mFrameLoader
-
>
GetOwnerDoc
(
)
;
if
(
NS_WARN_IF
(
!
ownerDoc
)
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
RefPtr
<
BrowserChild
>
browser
=
BrowserChild
:
:
GetFrom
(
ownerDoc
-
>
GetDocShell
(
)
)
;
if
(
!
browser
-
>
BindPBrowserBridgeEndpoint
(
std
:
:
move
(
aEndpoint
)
bridge
)
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
RefPtr
<
BrowserBridgeHost
>
host
=
bridge
-
>
FinishInit
(
)
;
browsingContext
-
>
SetEmbedderElement
(
mFrameLoader
-
>
GetOwnerContent
(
)
)
;
mFrameLoader
-
>
mRemoteBrowser
=
host
;
}
;
ChangeRemotenessCommon
(
true
NS_LITERAL_STRING
(
DEFAULT_REMOTE_TYPE
)
frameLoaderInit
rv
)
;
}
