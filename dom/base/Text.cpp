#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
namespace
mozilla
{
namespace
dom
{
already_AddRefed
<
Text
>
Text
:
:
SplitText
(
uint32_t
aOffset
ErrorResult
&
aRv
)
{
nsAutoString
cutText
;
uint32_t
length
=
TextLength
(
)
;
if
(
aOffset
>
length
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
uint32_t
cutStartOffset
=
aOffset
;
uint32_t
cutLength
=
length
-
aOffset
;
SubstringData
(
cutStartOffset
cutLength
cutText
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
nsIDocument
*
document
=
GetComposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
document
UPDATE_CONTENT_MODEL
true
)
;
RefPtr
<
CharacterData
>
clone
=
CloneDataNode
(
mNodeInfo
false
)
;
MOZ_ASSERT
(
clone
&
&
clone
-
>
IsText
(
)
)
;
RefPtr
<
Text
>
newContent
=
static_cast
<
Text
*
>
(
clone
.
get
(
)
)
;
newContent
-
>
SetText
(
cutText
true
)
;
CharacterDataChangeInfo
:
:
Details
details
=
{
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
newContent
}
;
nsresult
rv
=
SetTextInternal
(
cutStartOffset
cutLength
nullptr
0
true
&
details
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
parent
)
{
nsCOMPtr
<
nsIContent
>
beforeNode
=
GetNextSibling
(
)
;
parent
-
>
InsertChildBefore
(
newContent
beforeNode
true
)
;
}
return
newContent
.
forget
(
)
;
}
static
Text
*
FirstLogicallyAdjacentTextNode
(
Text
*
aNode
)
{
do
{
nsIContent
*
sibling
=
aNode
-
>
GetPreviousSibling
(
)
;
if
(
!
sibling
|
|
!
sibling
-
>
IsText
(
)
)
{
return
aNode
;
}
aNode
=
static_cast
<
Text
*
>
(
sibling
)
;
}
while
(
1
)
;
}
static
Text
*
LastLogicallyAdjacentTextNode
(
Text
*
aNode
)
{
do
{
nsIContent
*
sibling
=
aNode
-
>
GetNextSibling
(
)
;
if
(
!
sibling
|
|
!
sibling
-
>
IsText
(
)
)
{
return
aNode
;
}
aNode
=
static_cast
<
Text
*
>
(
sibling
)
;
}
while
(
1
)
;
}
void
Text
:
:
GetWholeText
(
nsAString
&
aWholeText
ErrorResult
&
aRv
)
{
nsIContent
*
parent
=
GetParent
(
)
;
if
(
!
parent
)
{
GetData
(
aWholeText
)
;
return
;
}
int32_t
index
=
parent
-
>
ComputeIndexOf
(
this
)
;
NS_WARNING_ASSERTION
(
index
>
=
0
"
Trying
to
use
.
wholeText
with
an
anonymous
"
"
text
node
child
of
a
binding
parent
?
"
)
;
if
(
NS_WARN_IF
(
index
<
0
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
Text
*
first
=
FirstLogicallyAdjacentTextNode
(
this
)
;
Text
*
last
=
LastLogicallyAdjacentTextNode
(
this
)
;
aWholeText
.
Truncate
(
)
;
nsAutoString
tmp
;
while
(
true
)
{
first
-
>
GetData
(
tmp
)
;
aWholeText
.
Append
(
tmp
)
;
if
(
first
=
=
last
)
{
break
;
}
nsIContent
*
next
=
first
-
>
GetNextSibling
(
)
;
MOZ_ASSERT
(
next
&
&
next
-
>
IsText
(
)
"
How
did
we
run
out
of
text
before
hitting
last
?
"
)
;
first
=
static_cast
<
Text
*
>
(
next
)
;
}
}
already_AddRefed
<
Text
>
Text
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aData
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
|
|
!
window
-
>
GetDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
window
-
>
GetDoc
(
)
-
>
CreateTextNode
(
aData
)
;
}
}
}
