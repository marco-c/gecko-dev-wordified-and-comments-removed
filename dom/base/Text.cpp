#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
namespace
mozilla
:
:
dom
{
already_AddRefed
<
Text
>
Text
:
:
SplitText
(
uint32_t
aOffset
ErrorResult
&
aRv
)
{
nsAutoString
cutText
;
const
uint32_t
length
=
TextLength
(
)
;
if
(
aOffset
>
length
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
nullptr
;
}
const
uint32_t
cutStartOffset
=
aOffset
;
const
uint32_t
cutLength
=
length
-
aOffset
;
SubstringData
(
cutStartOffset
cutLength
cutText
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
Document
*
document
=
GetComposedDoc
(
)
;
mozAutoDocUpdate
updateBatch
(
document
true
)
;
RefPtr
<
CharacterData
>
clone
=
CloneDataNode
(
mNodeInfo
false
)
;
MOZ_ASSERT
(
clone
&
&
clone
-
>
IsText
(
)
)
;
RefPtr
<
Text
>
newContent
=
static_cast
<
Text
*
>
(
clone
.
get
(
)
)
;
newContent
-
>
SetText
(
cutText
true
)
;
CharacterDataChangeInfo
:
:
Details
details
=
{
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
newContent
}
;
nsresult
rv
=
SetTextInternal
(
cutStartOffset
cutLength
nullptr
0
true
&
details
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
nsCOMPtr
<
nsINode
>
parent
=
GetParentNode
(
)
;
if
(
parent
)
{
nsCOMPtr
<
nsIContent
>
beforeNode
=
GetNextSibling
(
)
;
parent
-
>
InsertChildBefore
(
newContent
beforeNode
true
IgnoreErrors
(
)
)
;
}
return
newContent
.
forget
(
)
;
}
static
Text
*
FirstLogicallyAdjacentTextNode
(
Text
*
aNode
)
{
do
{
nsIContent
*
sibling
=
aNode
-
>
GetPreviousSibling
(
)
;
if
(
!
sibling
|
|
!
sibling
-
>
IsText
(
)
)
{
return
aNode
;
}
aNode
=
static_cast
<
Text
*
>
(
sibling
)
;
}
while
(
1
)
;
}
static
Text
*
LastLogicallyAdjacentTextNode
(
Text
*
aNode
)
{
do
{
nsIContent
*
sibling
=
aNode
-
>
GetNextSibling
(
)
;
if
(
!
sibling
|
|
!
sibling
-
>
IsText
(
)
)
{
return
aNode
;
}
aNode
=
static_cast
<
Text
*
>
(
sibling
)
;
}
while
(
1
)
;
}
void
Text
:
:
GetWholeText
(
nsAString
&
aWholeText
)
{
nsIContent
*
parent
=
GetParent
(
)
;
if
(
!
parent
)
{
GetData
(
aWholeText
)
;
return
;
}
Text
*
first
=
FirstLogicallyAdjacentTextNode
(
this
)
;
Text
*
last
=
LastLogicallyAdjacentTextNode
(
this
)
;
aWholeText
.
Truncate
(
)
;
nsAutoString
tmp
;
while
(
true
)
{
first
-
>
GetData
(
tmp
)
;
aWholeText
.
Append
(
tmp
)
;
if
(
first
=
=
last
)
{
break
;
}
nsIContent
*
next
=
first
-
>
GetNextSibling
(
)
;
MOZ_ASSERT
(
next
&
&
next
-
>
IsText
(
)
"
How
did
we
run
out
of
text
before
hitting
last
?
"
)
;
first
=
static_cast
<
Text
*
>
(
next
)
;
}
}
already_AddRefed
<
Text
>
Text
:
:
Constructor
(
const
GlobalObject
&
aGlobal
const
nsAString
&
aData
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
|
|
!
window
-
>
GetDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
window
-
>
GetDoc
(
)
-
>
CreateTextNode
(
aData
)
;
}
bool
Text
:
:
HasTextForTranslation
(
)
{
if
(
mText
.
Is2b
(
)
)
{
return
true
;
}
if
(
HasFlag
(
NS_CACHED_TEXT_IS_ONLY_WHITESPACE
)
&
&
HasFlag
(
NS_TEXT_IS_ONLY_WHITESPACE
)
)
{
return
false
;
}
const
char
*
cp
=
mText
.
Get1b
(
)
;
const
char
*
end
=
cp
+
mText
.
GetLength
(
)
;
unsigned
char
ch
;
for
(
;
cp
<
end
;
cp
+
+
)
{
ch
=
*
cp
;
if
(
(
ch
>
=
'
a
'
&
&
ch
<
=
'
z
'
)
|
|
(
ch
>
=
'
A
'
&
&
ch
<
=
'
Z
'
)
|
|
(
ch
>
=
192
&
&
ch
<
=
214
)
|
|
(
ch
>
=
216
&
&
ch
<
=
246
)
|
|
(
ch
>
=
248
)
)
{
return
true
;
}
}
return
false
;
}
}
