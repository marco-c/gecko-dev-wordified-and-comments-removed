#
ifndef
FragmentOrElement_h___
#
define
FragmentOrElement_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
class
ContentUnbinder
;
class
nsContentList
;
class
nsLabelsNodeList
;
class
nsDOMAttributeMap
;
class
nsDOMTokenList
;
class
nsIControllers
;
class
nsICSSDeclaration
;
class
nsDOMCSSAttributeDeclaration
;
class
nsDOMStringMap
;
class
nsIURI
;
namespace
mozilla
{
class
DeclarationBlock
;
enum
class
ContentRelevancyReason
;
using
ContentRelevancy
=
EnumSet
<
ContentRelevancyReason
uint8_t
>
;
class
ElementAnimationData
;
namespace
dom
{
struct
CustomElementData
;
class
Element
;
class
PopoverData
;
}
}
class
nsNodeSupportsWeakRefTearoff
final
:
public
nsISupportsWeakReference
{
public
:
explicit
nsNodeSupportsWeakRefTearoff
(
nsINode
*
aNode
)
:
mNode
(
aNode
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSISUPPORTSWEAKREFERENCE
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsNodeSupportsWeakRefTearoff
)
private
:
~
nsNodeSupportsWeakRefTearoff
(
)
=
default
;
nsCOMPtr
<
nsINode
>
mNode
;
}
;
namespace
mozilla
:
:
dom
{
class
ShadowRoot
;
class
FragmentOrElement
:
public
nsIContent
{
public
:
explicit
FragmentOrElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
;
explicit
FragmentOrElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
NS_IMETHOD
QueryInterface
(
REFNSIID
aIID
void
*
*
aInstancePtr
)
override
;
NS_INLINE_DECL_REFCOUNTING_INHERITED
(
FragmentOrElement
nsIContent
)
;
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
virtual
void
GetTextContentInternal
(
nsAString
&
aTextContent
mozilla
:
:
OOMReporter
&
aError
)
override
;
virtual
void
SetTextContentInternal
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
override
;
const
nsTextFragment
*
GetText
(
)
override
;
uint32_t
TextLength
(
)
const
override
;
bool
TextIsOnlyWhitespace
(
)
override
;
bool
ThreadSafeTextIsOnlyWhitespace
(
)
const
override
;
void
DestroyContent
(
)
override
;
void
SaveSubtreeState
(
)
override
;
nsIHTMLCollection
*
Children
(
)
;
uint32_t
ChildElementCount
(
)
{
if
(
!
HasChildren
(
)
)
{
return
0
;
}
return
Children
(
)
-
>
Length
(
)
;
}
public
:
static
void
FireNodeInserted
(
Document
*
aDoc
nsINode
*
aParent
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
&
aNodes
)
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_WRAPPERCACHE_CLASS_INHERITED
(
FragmentOrElement
nsIContent
)
static
void
ClearContentUnbinder
(
)
;
static
bool
CanSkip
(
nsINode
*
aNode
bool
aRemovingAllowed
)
;
static
bool
CanSkipInCC
(
nsINode
*
aNode
)
;
static
bool
CanSkipThis
(
nsINode
*
aNode
)
;
static
void
RemoveBlackMarkedNode
(
nsINode
*
aNode
)
;
static
void
MarkNodeChildren
(
nsINode
*
aNode
)
;
static
void
InitCCCallbacks
(
)
;
static
bool
IsHTMLVoid
(
nsAtom
*
aLocalName
)
;
protected
:
virtual
~
FragmentOrElement
(
)
;
nsresult
CopyInnerTo
(
FragmentOrElement
*
aDest
)
{
return
NS_OK
;
}
public
:
class
nsExtendedDOMSlots
:
public
nsIContent
:
:
nsExtendedContentSlots
{
public
:
nsExtendedDOMSlots
(
)
;
~
nsExtendedDOMSlots
(
)
;
void
TraverseExtendedSlots
(
nsCycleCollectionTraversalCallback
&
)
final
;
void
UnlinkExtendedSlots
(
nsIContent
&
)
final
;
size_t
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
final
;
RefPtr
<
nsDOMCSSAttributeDeclaration
>
mSMILOverrideStyle
;
RefPtr
<
DeclarationBlock
>
mSMILOverrideStyleDeclaration
;
nsCOMPtr
<
nsIControllers
>
mControllers
;
RefPtr
<
nsLabelsNodeList
>
mLabelsList
;
RefPtr
<
ShadowRoot
>
mShadowRoot
;
UniquePtr
<
CustomElementData
>
mCustomElementData
;
UniquePtr
<
ElementAnimationData
>
mAnimations
;
UniquePtr
<
PopoverData
>
mPopoverData
;
Maybe
<
float
>
mLastRememberedBSize
;
Maybe
<
float
>
mLastRememberedISize
;
Maybe
<
ContentRelevancy
>
mContentRelevancy
;
Maybe
<
bool
>
mVisibleForContentVisibility
;
nsTHashMap
<
nsRefPtrHashKey
<
nsAtom
>
nsWeakPtr
>
mExplicitlySetAttrElements
;
}
;
class
nsDOMSlots
:
public
nsIContent
:
:
nsContentSlots
{
public
:
nsDOMSlots
(
)
;
~
nsDOMSlots
(
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
)
final
;
void
Unlink
(
nsINode
&
)
final
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsCOMPtr
<
nsICSSDeclaration
>
mStyle
;
nsDOMStringMap
*
mDataset
;
RefPtr
<
nsDOMAttributeMap
>
mAttributeMap
;
RefPtr
<
nsContentList
>
mChildrenList
;
RefPtr
<
nsDOMTokenList
>
mClassList
;
RefPtr
<
nsDOMTokenList
>
mPart
;
}
;
class
FatSlots
final
:
public
nsDOMSlots
public
nsExtendedDOMSlots
{
public
:
FatSlots
(
)
:
nsDOMSlots
(
)
nsExtendedDOMSlots
(
)
{
MOZ_COUNT_CTOR
(
FatSlots
)
;
SetExtendedContentSlots
(
this
false
)
;
}
~
FatSlots
(
)
final
{
MOZ_COUNT_DTOR
(
FatSlots
)
;
}
}
;
protected
:
void
GetMarkup
(
bool
aIncludeSelf
nsAString
&
aMarkup
)
;
void
SetInnerHTMLInternal
(
const
nsAString
&
aInnerHTML
ErrorResult
&
aError
)
;
nsIContent
:
:
nsContentSlots
*
CreateSlots
(
)
override
{
return
new
nsDOMSlots
(
)
;
}
nsIContent
:
:
nsExtendedContentSlots
*
CreateExtendedSlots
(
)
final
{
return
new
nsExtendedDOMSlots
(
)
;
}
nsDOMSlots
*
DOMSlots
(
)
{
return
static_cast
<
nsDOMSlots
*
>
(
Slots
(
)
)
;
}
nsDOMSlots
*
GetExistingDOMSlots
(
)
const
{
return
static_cast
<
nsDOMSlots
*
>
(
GetExistingSlots
(
)
)
;
}
nsExtendedDOMSlots
*
ExtendedDOMSlots
(
)
{
nsContentSlots
*
slots
=
GetExistingContentSlots
(
)
;
if
(
!
slots
)
{
FatSlots
*
fatSlots
=
new
FatSlots
(
)
;
mSlots
=
fatSlots
;
return
fatSlots
;
}
if
(
!
slots
-
>
GetExtendedContentSlots
(
)
)
{
slots
-
>
SetExtendedContentSlots
(
CreateExtendedSlots
(
)
true
)
;
}
return
static_cast
<
nsExtendedDOMSlots
*
>
(
slots
-
>
GetExtendedContentSlots
(
)
)
;
}
const
nsExtendedDOMSlots
*
GetExistingExtendedDOMSlots
(
)
const
{
return
static_cast
<
const
nsExtendedDOMSlots
*
>
(
GetExistingExtendedContentSlots
(
)
)
;
}
nsExtendedDOMSlots
*
GetExistingExtendedDOMSlots
(
)
{
return
static_cast
<
nsExtendedDOMSlots
*
>
(
GetExistingExtendedContentSlots
(
)
)
;
}
friend
class
:
:
ContentUnbinder
;
}
;
}
#
define
NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
\
if
(
NS_SUCCEEDED
(
rv
)
)
return
rv
;
\
\
rv
=
FragmentOrElement
:
:
QueryInterface
(
aIID
aInstancePtr
)
;
\
NS_INTERFACE_TABLE_TO_MAP_SEGUE
#
endif
