#
ifndef
FragmentOrElement_h___
#
define
FragmentOrElement_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsAttrAndChildArray
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsXBLBinding
.
h
"
class
ContentUnbinder
;
class
nsContentList
;
class
nsLabelsNodeList
;
class
nsDOMAttributeMap
;
class
nsDOMTokenList
;
class
nsIControllers
;
class
nsICSSDeclaration
;
class
nsIDocument
;
class
nsDOMStringMap
;
class
nsIURI
;
namespace
mozilla
{
class
DeclarationBlock
;
namespace
dom
{
struct
CustomElementData
;
class
Element
;
}
}
class
nsNodeWeakReference
final
:
public
nsIWeakReference
{
public
:
explicit
nsNodeWeakReference
(
nsINode
*
aNode
)
:
nsIWeakReference
(
aNode
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIWEAKREFERENCE
virtual
size_t
SizeOfOnlyThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
void
NoticeNodeDestruction
(
)
{
mObject
=
nullptr
;
}
private
:
~
nsNodeWeakReference
(
)
;
}
;
class
nsNodeSupportsWeakRefTearoff
final
:
public
nsISupportsWeakReference
{
public
:
explicit
nsNodeSupportsWeakRefTearoff
(
nsINode
*
aNode
)
:
mNode
(
aNode
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_NSISUPPORTSWEAKREFERENCE
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsNodeSupportsWeakRefTearoff
)
private
:
~
nsNodeSupportsWeakRefTearoff
(
)
{
}
nsCOMPtr
<
nsINode
>
mNode
;
}
;
namespace
mozilla
{
namespace
dom
{
class
ShadowRoot
;
class
FragmentOrElement
:
public
nsIContent
{
public
:
explicit
FragmentOrElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
;
explicit
FragmentOrElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
virtual
uint32_t
GetChildCount
(
)
const
override
;
virtual
nsIContent
*
GetChildAt_Deprecated
(
uint32_t
aIndex
)
const
override
;
virtual
int32_t
ComputeIndexOf
(
const
nsINode
*
aPossibleChild
)
const
override
;
virtual
nsresult
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
override
;
virtual
nsresult
InsertChildAt_Deprecated
(
nsIContent
*
aKid
uint32_t
aIndex
bool
aNotify
)
override
;
virtual
void
RemoveChildAt_Deprecated
(
uint32_t
aIndex
bool
aNotify
)
override
;
virtual
void
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
override
;
virtual
void
GetTextContentInternal
(
nsAString
&
aTextContent
mozilla
:
:
OOMReporter
&
aError
)
override
;
virtual
void
SetTextContentInternal
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
override
;
virtual
already_AddRefed
<
nsINodeList
>
GetChildren
(
uint32_t
aFilter
)
override
;
virtual
const
nsTextFragment
*
GetText
(
)
override
;
virtual
uint32_t
TextLength
(
)
const
override
;
virtual
nsresult
SetText
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aNotify
)
override
;
nsresult
SetText
(
const
nsAString
&
aStr
bool
aNotify
)
{
return
SetText
(
aStr
.
BeginReading
(
)
aStr
.
Length
(
)
aNotify
)
;
}
virtual
nsresult
AppendText
(
const
char16_t
*
aBuffer
uint32_t
aLength
bool
aNotify
)
override
;
virtual
bool
TextIsOnlyWhitespace
(
)
override
;
virtual
bool
ThreadSafeTextIsOnlyWhitespace
(
)
const
override
;
virtual
bool
HasTextForTranslation
(
)
override
;
virtual
void
AppendTextTo
(
nsAString
&
aResult
)
override
;
MOZ_MUST_USE
virtual
bool
AppendTextTo
(
nsAString
&
aResult
const
mozilla
:
:
fallible_t
&
)
override
;
virtual
nsXBLBinding
*
DoGetXBLBinding
(
)
const
override
;
virtual
bool
IsLink
(
nsIURI
*
*
aURI
)
const
override
;
virtual
void
DestroyContent
(
)
override
;
virtual
void
SaveSubtreeState
(
)
override
;
nsIHTMLCollection
*
Children
(
)
;
uint32_t
ChildElementCount
(
)
{
return
Children
(
)
-
>
Length
(
)
;
}
void
SetIsElementInStyleScopeFlagOnSubtree
(
bool
aInStyleScope
)
;
public
:
static
void
FireNodeInserted
(
nsIDocument
*
aDoc
nsINode
*
aParent
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
&
aNodes
)
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS
(
FragmentOrElement
)
void
FireNodeRemovedForChildren
(
)
;
virtual
bool
OwnedOnlyByTheDOMTree
(
)
override
{
uint32_t
rc
=
mRefCnt
.
get
(
)
;
if
(
GetParent
(
)
)
{
-
-
rc
;
}
rc
-
=
mAttrsAndChildren
.
ChildCount
(
)
;
return
rc
=
=
0
;
}
virtual
bool
IsPurple
(
)
override
{
return
mRefCnt
.
IsPurple
(
)
;
}
virtual
void
RemovePurple
(
)
override
{
mRefCnt
.
RemovePurple
(
)
;
}
static
void
ClearContentUnbinder
(
)
;
static
bool
CanSkip
(
nsINode
*
aNode
bool
aRemovingAllowed
)
;
static
bool
CanSkipInCC
(
nsINode
*
aNode
)
;
static
bool
CanSkipThis
(
nsINode
*
aNode
)
;
static
void
RemoveBlackMarkedNode
(
nsINode
*
aNode
)
;
static
void
MarkNodeChildren
(
nsINode
*
aNode
)
;
static
void
InitCCCallbacks
(
)
;
static
void
MarkUserData
(
void
*
aObject
nsAtom
*
aKey
void
*
aChild
void
*
aData
)
;
static
bool
IsHTMLVoid
(
nsAtom
*
aLocalName
)
;
protected
:
virtual
~
FragmentOrElement
(
)
;
nsresult
CopyInnerTo
(
FragmentOrElement
*
aDest
bool
aPreallocateChildren
)
;
public
:
class
nsExtendedDOMSlots
final
:
public
nsIContent
:
:
nsExtendedContentSlots
{
public
:
nsExtendedDOMSlots
(
)
;
~
nsExtendedDOMSlots
(
)
final
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
)
final
override
;
void
Unlink
(
)
final
override
;
nsCOMPtr
<
nsICSSDeclaration
>
mSMILOverrideStyle
;
RefPtr
<
mozilla
:
:
DeclarationBlock
>
mSMILOverrideStyleDeclaration
;
nsCOMPtr
<
nsIControllers
>
mControllers
;
RefPtr
<
nsLabelsNodeList
>
mLabelsList
;
RefPtr
<
ShadowRoot
>
mShadowRoot
;
RefPtr
<
nsXBLBinding
>
mXBLBinding
;
RefPtr
<
CustomElementData
>
mCustomElementData
;
nsCOMPtr
<
nsISupports
>
mFrameLoaderOrOpener
;
}
;
class
nsDOMSlots
final
:
public
nsIContent
:
:
nsContentSlots
{
public
:
nsDOMSlots
(
)
;
~
nsDOMSlots
(
)
final
;
void
Traverse
(
nsCycleCollectionTraversalCallback
&
)
final
override
;
void
Unlink
(
)
final
override
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsCOMPtr
<
nsICSSDeclaration
>
mStyle
;
nsDOMStringMap
*
mDataset
;
RefPtr
<
nsDOMAttributeMap
>
mAttributeMap
;
RefPtr
<
nsContentList
>
mChildrenList
;
RefPtr
<
nsDOMTokenList
>
mClassList
;
}
;
protected
:
void
GetMarkup
(
bool
aIncludeSelf
nsAString
&
aMarkup
)
;
void
SetInnerHTMLInternal
(
const
nsAString
&
aInnerHTML
ErrorResult
&
aError
)
;
nsIContent
:
:
nsContentSlots
*
CreateSlots
(
)
override
{
return
new
nsDOMSlots
(
)
;
}
nsIContent
:
:
nsExtendedContentSlots
*
CreateExtendedSlots
(
)
final
override
{
return
new
nsExtendedDOMSlots
(
)
;
}
nsDOMSlots
*
DOMSlots
(
)
{
return
static_cast
<
nsDOMSlots
*
>
(
Slots
(
)
)
;
}
nsDOMSlots
*
GetExistingDOMSlots
(
)
const
{
return
static_cast
<
nsDOMSlots
*
>
(
GetExistingSlots
(
)
)
;
}
nsExtendedDOMSlots
*
ExtendedDOMSlots
(
)
{
return
static_cast
<
nsExtendedDOMSlots
*
>
(
ExtendedContentSlots
(
)
)
;
}
const
nsExtendedDOMSlots
*
GetExistingExtendedDOMSlots
(
)
const
{
return
static_cast
<
const
nsExtendedDOMSlots
*
>
(
GetExistingExtendedContentSlots
(
)
)
;
}
nsExtendedDOMSlots
*
GetExistingExtendedDOMSlots
(
)
{
return
static_cast
<
nsExtendedDOMSlots
*
>
(
GetExistingExtendedContentSlots
(
)
)
;
}
void
SetIsElementInStyleScopeFlagOnShadowTree
(
bool
aInStyleScope
)
;
friend
class
:
:
ContentUnbinder
;
nsAttrAndChildArray
mAttrsAndChildren
;
}
;
}
}
#
define
NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
\
if
(
NS_SUCCEEDED
(
rv
)
)
\
return
rv
;
\
\
rv
=
FragmentOrElement
:
:
QueryInterface
(
aIID
aInstancePtr
)
;
\
NS_INTERFACE_TABLE_TO_MAP_SEGUE
#
endif
