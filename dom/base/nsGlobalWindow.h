#
ifndef
nsGlobalWindow_h___
#
define
nsGlobalWindow_h___
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsJSThingHashtable
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIBrowserDOMWindow
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIDOMModalContentWindow
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
mozFlushType
.
h
"
#
include
"
prclist
.
h
"
#
include
"
mozilla
/
dom
/
StorageEvent
.
h
"
#
include
"
mozilla
/
dom
/
StorageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
UnionTypes
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
nsFrameMessageManager
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsIIdleObserver
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsSize
.
h
"
#
include
"
nsCheapSets
.
h
"
#
include
"
mozilla
/
dom
/
ImageBitmapSource
.
h
"
#
define
DEFAULT_HOME_PAGE
"
www
.
mozilla
.
org
"
#
define
PREF_BROWSER_STARTUP_HOMEPAGE
"
browser
.
startup
.
homepage
"
#
define
DEFAULT_SUCCESSIVE_DIALOG_TIME_LIMIT
3
/
/
3
sec
#
define
MAX_SUCCESSIVE_DIALOG_COUNT
5
#
define
MAX_IDLE_FUZZ_TIME_MS
90000
#
define
MIN_IDLE_NOTIFICATION_TIME_S
1
class
nsIArray
;
class
nsIBaseWindow
;
class
nsIContent
;
class
nsICSSDeclaration
;
class
nsIDocShellTreeOwner
;
class
nsIDOMOfflineResourceList
;
class
nsIScrollableFrame
;
class
nsIControllers
;
class
nsIJSID
;
class
nsIScriptContext
;
class
nsIScriptTimeoutHandler
;
class
nsIWebBrowserChrome
;
class
nsDOMWindowList
;
class
nsLocation
;
class
nsScreen
;
class
nsHistory
;
class
nsGlobalWindowObserver
;
class
nsGlobalWindow
;
class
nsDOMWindowUtils
;
class
nsIIdleService
;
struct
nsRect
;
class
nsWindowSizes
;
namespace
mozilla
{
class
DOMEventTargetHelper
;
namespace
dom
{
class
BarProp
;
class
Console
;
class
Crypto
;
class
External
;
class
Function
;
class
Gamepad
;
class
MediaQueryList
;
class
MozSelfSupport
;
class
Navigator
;
class
OwningExternalOrWindowProxy
;
class
Promise
;
class
PostMessageEvent
;
struct
RequestInit
;
class
RequestOrUSVString
;
class
Selection
;
class
SpeechSynthesis
;
class
U2F
;
class
VRDevice
;
class
WakeLock
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
class
WindowOrientationObserver
;
#
endif
namespace
cache
{
class
CacheStorage
;
}
class
IDBFactory
;
}
namespace
gfx
{
class
VRDeviceProxy
;
}
}
extern
already_AddRefed
<
nsIScriptTimeoutHandler
>
NS_CreateJSTimeoutHandler
(
JSContext
*
aCx
nsGlobalWindow
*
aWindow
mozilla
:
:
dom
:
:
Function
&
aFunction
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
mozilla
:
:
ErrorResult
&
aError
)
;
extern
already_AddRefed
<
nsIScriptTimeoutHandler
>
NS_CreateJSTimeoutHandler
(
JSContext
*
aCx
nsGlobalWindow
*
aWindow
const
nsAString
&
aExpression
mozilla
:
:
ErrorResult
&
aError
)
;
extern
const
js
:
:
Class
OuterWindowProxyClass
;
struct
nsTimeout
final
:
mozilla
:
:
LinkedListElement
<
nsTimeout
>
{
private
:
~
nsTimeout
(
)
;
public
:
nsTimeout
(
)
;
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
nsTimeout
)
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
nsTimeout
)
nsresult
InitTimer
(
uint32_t
aDelay
)
;
bool
HasRefCntOne
(
)
;
RefPtr
<
nsGlobalWindow
>
mWindow
;
nsCOMPtr
<
nsITimer
>
mTimer
;
bool
mCleared
;
bool
mRunning
;
bool
mIsInterval
;
uint32_t
mPublicId
;
uint32_t
mInterval
;
mozilla
:
:
TimeStamp
mWhen
;
mozilla
:
:
TimeDuration
mTimeRemaining
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
uint32_t
mFiringDepth
;
uint32_t
mNestingLevel
;
PopupControlState
mPopupState
;
nsCOMPtr
<
nsIScriptTimeoutHandler
>
mScriptHandler
;
}
;
struct
IdleObserverHolder
{
nsCOMPtr
<
nsIIdleObserver
>
mIdleObserver
;
uint32_t
mTimeInS
;
bool
mPrevNotificationIdle
;
IdleObserverHolder
(
)
:
mTimeInS
(
0
)
mPrevNotificationIdle
(
false
)
{
MOZ_COUNT_CTOR
(
IdleObserverHolder
)
;
}
IdleObserverHolder
(
const
IdleObserverHolder
&
aOther
)
:
mIdleObserver
(
aOther
.
mIdleObserver
)
mTimeInS
(
aOther
.
mTimeInS
)
mPrevNotificationIdle
(
aOther
.
mPrevNotificationIdle
)
{
MOZ_COUNT_CTOR
(
IdleObserverHolder
)
;
}
bool
operator
=
=
(
const
IdleObserverHolder
&
aOther
)
const
{
return
mIdleObserver
=
=
aOther
.
mIdleObserver
&
&
mTimeInS
=
=
aOther
.
mTimeInS
;
}
~
IdleObserverHolder
(
)
{
MOZ_COUNT_DTOR
(
IdleObserverHolder
)
;
}
}
;
class
DialogValueHolder
final
:
public
nsISupports
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
DialogValueHolder
)
DialogValueHolder
(
nsIPrincipal
*
aSubject
nsIVariant
*
aValue
)
:
mOrigin
(
aSubject
)
mValue
(
aValue
)
{
}
nsresult
Get
(
nsIPrincipal
*
aSubject
nsIVariant
*
*
aResult
)
;
void
Get
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aScope
nsIPrincipal
*
aSubject
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aResult
mozilla
:
:
ErrorResult
&
aError
)
;
private
:
virtual
~
DialogValueHolder
(
)
{
}
nsCOMPtr
<
nsIPrincipal
>
mOrigin
;
nsCOMPtr
<
nsIVariant
>
mValue
;
}
;
class
nsGlobalWindow
:
public
mozilla
:
:
dom
:
:
EventTarget
public
nsPIDOMWindow
<
nsISupports
>
private
nsIDOMWindowInternal
public
nsIScriptGlobalObject
public
nsIScriptObjectPrincipal
public
nsSupportsWeakReference
public
nsIInterfaceRequestor
public
PRCListStr
{
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
typedef
mozilla
:
:
TimeDuration
TimeDuration
;
typedef
nsDataHashtable
<
nsUint64HashKey
nsGlobalWindow
*
>
WindowByIdTable
;
static
void
AssertIsOnMainThread
(
)
#
ifdef
DEBUG
;
#
else
{
}
#
endif
static
nsGlobalWindow
*
Cast
(
nsPIDOMWindowInner
*
aPIWin
)
{
return
static_cast
<
nsGlobalWindow
*
>
(
reinterpret_cast
<
nsPIDOMWindow
<
nsISupports
>
*
>
(
aPIWin
)
)
;
}
static
nsGlobalWindow
*
Cast
(
mozIDOMWindow
*
aWin
)
{
return
Cast
(
nsPIDOMWindowInner
:
:
From
(
aWin
)
)
;
}
static
nsGlobalWindow
*
Cast
(
nsPIDOMWindowOuter
*
aPIWin
)
{
return
static_cast
<
nsGlobalWindow
*
>
(
reinterpret_cast
<
nsPIDOMWindow
<
nsISupports
>
*
>
(
aPIWin
)
)
;
}
static
nsGlobalWindow
*
Cast
(
mozIDOMWindowProxy
*
aWin
)
{
return
Cast
(
nsPIDOMWindowOuter
:
:
From
(
aWin
)
)
;
}
nsPIDOMWindowOuter
*
GetPrivateParent
(
)
;
void
ReallyCloseWindow
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
virtual
JSObject
*
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
IsInnerWindow
(
)
|
|
AsOuter
(
)
-
>
EnsureInnerWindow
(
)
?
GetWrapper
(
)
:
nullptr
;
}
virtual
JSObject
*
GetGlobalJSObject
(
)
override
;
JSObject
*
FastGetGlobalJSObject
(
)
const
{
return
GetWrapperPreserveColor
(
)
;
}
void
TraceGlobalJSObject
(
JSTracer
*
aTrc
)
;
virtual
nsresult
EnsureScriptEnvironment
(
)
override
;
virtual
nsIScriptContext
*
GetScriptContext
(
)
override
;
void
PoisonOuterWindowProxy
(
JSObject
*
aObject
)
;
virtual
bool
IsBlackForCC
(
bool
aTracingNeeded
=
true
)
override
;
virtual
nsIPrincipal
*
GetPrincipal
(
)
override
;
NS_DECL_NSIDOMWINDOW
nsresult
OpenJS
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
;
void
CaptureEvents
(
)
;
void
ReleaseEvents
(
)
;
void
Dump
(
const
nsAString
&
aStr
)
;
void
SetResizable
(
bool
aResizable
)
const
;
nsresult
GetScriptableContent
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aVal
)
;
NS_DECL_NSIDOMEVENTTARGET
virtual
mozilla
:
:
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
using
mozilla
:
:
dom
:
:
EventTarget
:
:
RemoveEventListener
;
virtual
void
AddEventListener
(
const
nsAString
&
aType
mozilla
:
:
dom
:
:
EventListener
*
aListener
bool
aUseCapture
const
mozilla
:
:
dom
:
:
Nullable
<
bool
>
&
aWantsUntrusted
mozilla
:
:
ErrorResult
&
aRv
)
override
;
virtual
nsPIDOMWindowOuter
*
GetOwnerGlobalForBindings
(
)
override
;
virtual
nsIGlobalObject
*
GetOwnerGlobal
(
)
const
override
{
if
(
IsOuterWindow
(
)
)
{
return
GetCurrentInnerWindowInternal
(
)
;
}
return
const_cast
<
nsGlobalWindow
*
>
(
this
)
;
}
virtual
nsPIDOMWindowOuter
*
GetPrivateRoot
(
)
override
;
virtual
void
ActivateOrDeactivate
(
bool
aActivate
)
override
;
virtual
void
SetActive
(
bool
aActive
)
override
;
virtual
void
SetIsBackground
(
bool
aIsBackground
)
override
;
virtual
void
SetChromeEventHandler
(
mozilla
:
:
dom
:
:
EventTarget
*
aChromeEventHandler
)
override
;
virtual
void
SetInitialPrincipalToSubject
(
)
override
;
virtual
PopupControlState
PushPopupControlState
(
PopupControlState
state
bool
aForce
)
const
override
;
virtual
void
PopPopupControlState
(
PopupControlState
state
)
const
override
;
virtual
PopupControlState
GetPopupControlState
(
)
const
override
;
virtual
already_AddRefed
<
nsISupports
>
SaveWindowState
(
)
override
;
virtual
nsresult
RestoreWindowState
(
nsISupports
*
aState
)
override
;
virtual
void
SuspendTimeouts
(
uint32_t
aIncrease
=
1
bool
aFreezeChildren
=
true
bool
aFreezeWorkers
=
true
)
override
;
virtual
nsresult
ResumeTimeouts
(
bool
aThawChildren
=
true
bool
aThawWorkers
=
true
)
override
;
virtual
uint32_t
TimeoutSuspendCount
(
)
override
;
virtual
nsresult
FireDelayedDOMEvents
(
)
override
;
virtual
bool
IsFrozen
(
)
const
override
{
return
mIsFrozen
;
}
virtual
bool
IsRunningTimeout
(
)
override
{
return
mTimeoutFiringDepth
>
0
;
}
virtual
bool
WouldReuseInnerWindow
(
nsIDocument
*
aNewDocument
)
override
;
virtual
void
SetDocShell
(
nsIDocShell
*
aDocShell
)
override
;
virtual
void
DetachFromDocShell
(
)
override
;
virtual
nsresult
SetNewDocument
(
nsIDocument
*
aDocument
nsISupports
*
aState
bool
aForceReuseInnerWindow
)
override
;
void
DispatchDOMWindowCreated
(
)
;
virtual
void
SetOpenerWindow
(
nsPIDOMWindowOuter
*
aOpener
bool
aOriginalOpener
)
override
;
virtual
void
EnsureSizeUpToDate
(
)
override
;
virtual
void
EnterModalState
(
)
override
;
virtual
void
LeaveModalState
(
)
override
;
virtual
bool
CanClose
(
)
override
;
virtual
void
ForceClose
(
)
override
;
virtual
void
MaybeUpdateTouchState
(
)
override
;
virtual
bool
DispatchCustomEvent
(
const
nsAString
&
aEventName
)
override
;
bool
DispatchResizeEvent
(
const
mozilla
:
:
CSSIntSize
&
aSize
)
;
void
RefreshCompartmentPrincipal
(
)
;
friend
class
FullscreenTransitionTask
;
virtual
nsresult
SetFullscreenInternal
(
FullscreenReason
aReason
bool
aIsFullscreen
mozilla
:
:
gfx
:
:
VRDeviceProxy
*
aHMD
=
nullptr
)
override
final
;
virtual
void
FinishFullscreenChange
(
bool
aIsFullscreen
)
override
final
;
bool
SetWidgetFullscreen
(
FullscreenReason
aReason
bool
aIsFullscreen
nsIWidget
*
aWidget
nsIScreen
*
aScreen
)
;
bool
FullScreen
(
)
const
;
virtual
void
SetHasGamepadEventListener
(
bool
aHasGamepad
=
true
)
override
;
NS_DECL_NSIINTERFACEREQUESTOR
already_AddRefed
<
nsPIDOMWindowOuter
>
IndexedGetterOuter
(
uint32_t
aIndex
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
IndexedGetter
(
uint32_t
aIndex
)
;
static
bool
IsPrivilegedChromeWindow
(
JSContext
*
JSObject
*
aObj
)
;
static
bool
IsShowModalDialogEnabled
(
JSContext
*
=
nullptr
JSObject
*
=
nullptr
)
;
bool
DoResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObj
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
aDesc
)
;
static
bool
MayResolve
(
jsid
aId
)
;
void
GetOwnPropertyNames
(
JSContext
*
aCx
nsTArray
<
nsString
>
&
aNames
mozilla
:
:
ErrorResult
&
aRv
)
;
static
already_AddRefed
<
nsGlobalWindow
>
Create
(
nsGlobalWindow
*
aOuterWindow
)
;
static
nsGlobalWindow
*
FromSupports
(
nsISupports
*
supports
)
{
return
(
nsGlobalWindow
*
)
(
mozilla
:
:
dom
:
:
EventTarget
*
)
supports
;
}
static
nsGlobalWindow
*
FromWrapper
(
nsIXPConnectWrappedNative
*
wrapper
)
{
return
FromSupports
(
wrapper
-
>
Native
(
)
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTop
(
)
override
;
nsPIDOMWindowOuter
*
GetScriptableTop
(
)
override
;
inline
nsGlobalWindow
*
GetTopInternal
(
)
{
nsGlobalWindow
*
outer
=
IsOuterWindow
(
)
?
this
:
GetOuterWindowInternal
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
outer
?
outer
-
>
GetTop
(
)
:
nullptr
;
if
(
top
)
{
return
nsGlobalWindow
:
:
Cast
(
top
)
;
}
return
nullptr
;
}
inline
nsGlobalWindow
*
GetScriptableTopInternal
(
)
{
nsPIDOMWindowOuter
*
top
=
GetScriptableTop
(
)
;
return
nsGlobalWindow
:
:
Cast
(
top
)
;
}
nsPIDOMWindowOuter
*
GetChildWindow
(
const
nsAString
&
aName
)
;
bool
ShouldPromptToBlockDialogs
(
)
;
bool
DialogsAreBeingAbused
(
)
;
void
EnableDialogs
(
)
;
void
DisableDialogs
(
)
;
bool
AreDialogsEnabled
(
)
;
nsIScriptContext
*
GetContextInternal
(
)
{
if
(
mOuterWindow
)
{
return
GetOuterWindowInternal
(
)
-
>
mContext
;
}
return
mContext
;
}
nsGlobalWindow
*
GetOuterWindowInternal
(
)
{
return
nsGlobalWindow
:
:
Cast
(
GetOuterWindow
(
)
)
;
}
nsGlobalWindow
*
GetCurrentInnerWindowInternal
(
)
const
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
return
nsGlobalWindow
:
:
Cast
(
mInnerWindow
)
;
}
nsGlobalWindow
*
EnsureInnerWindowInternal
(
)
{
return
nsGlobalWindow
:
:
Cast
(
AsOuter
(
)
-
>
EnsureInnerWindow
(
)
)
;
}
bool
IsCreatingInnerWindow
(
)
const
{
return
mCreatingInnerWindow
;
}
bool
IsChromeWindow
(
)
const
{
return
mIsChrome
;
}
using
nsPIDOMWindow
:
:
IsModalContentWindow
;
static
bool
IsModalContentWindow
(
JSContext
*
aCx
JSObject
*
aGlobal
)
;
nsIScrollableFrame
*
GetScrollFrame
(
)
;
nsresult
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
;
void
UnblockScriptedClosing
(
)
;
static
void
Init
(
)
;
static
void
ShutDown
(
)
;
static
void
CleanupCachedXBLHandlers
(
nsGlobalWindow
*
aWindow
)
;
static
bool
IsCallerChrome
(
)
;
static
void
RunPendingTimeoutsRecursive
(
nsGlobalWindow
*
aTopWindow
nsGlobalWindow
*
aWindow
)
;
friend
class
WindowStateHolder
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsGlobalWindow
nsIDOMEventTarget
)
#
ifdef
DEBUG
void
RiskyUnlink
(
)
;
#
endif
virtual
JSObject
*
GetCachedXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
)
override
;
virtual
void
CacheXBLPrototypeHandler
(
nsXBLPrototypeHandler
*
aKey
JS
:
:
Handle
<
JSObject
*
>
aHandler
)
override
;
virtual
bool
TakeFocus
(
bool
aFocus
uint32_t
aFocusMethod
)
override
;
virtual
void
SetReadyForFocus
(
)
override
;
virtual
void
PageHidden
(
)
override
;
virtual
nsresult
DispatchAsyncHashchange
(
nsIURI
*
aOldURI
nsIURI
*
aNewURI
)
override
;
virtual
nsresult
DispatchSyncPopState
(
)
override
;
virtual
void
EnableDeviceSensor
(
uint32_t
aType
)
override
;
virtual
void
DisableDeviceSensor
(
uint32_t
aType
)
override
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
virtual
void
EnableOrientationChangeListener
(
)
override
;
virtual
void
DisableOrientationChangeListener
(
)
override
;
#
endif
virtual
void
EnableTimeChangeNotifications
(
)
override
;
virtual
void
DisableTimeChangeNotifications
(
)
override
;
#
ifdef
MOZ_B2G
virtual
void
EnableNetworkEvent
(
mozilla
:
:
EventMessage
aEventMessage
)
override
;
virtual
void
DisableNetworkEvent
(
mozilla
:
:
EventMessage
aEventMessage
)
override
;
#
endif
virtual
nsresult
SetArguments
(
nsIArray
*
aArguments
)
override
;
void
MaybeForgiveSpamCount
(
)
;
bool
IsClosedOrClosing
(
)
{
return
(
mIsClosed
|
|
mInClose
|
|
mHavePendingClose
|
|
mCleanedUp
)
;
}
bool
HadOriginalOpener
(
)
const
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
return
mHadOriginalOpener
;
}
bool
IsTopLevelWindow
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
nsPIDOMWindowOuter
*
parentWindow
=
GetScriptableTop
(
)
;
return
parentWindow
=
=
this
-
>
AsOuter
(
)
;
}
virtual
void
FirePopupBlockedEvent
(
nsIDocument
*
aDoc
nsIURI
*
aPopupURI
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
override
;
virtual
uint32_t
GetSerial
(
)
override
{
return
mSerial
;
}
static
nsGlobalWindow
*
GetOuterWindowWithId
(
uint64_t
aWindowID
)
{
AssertIsOnMainThread
(
)
;
if
(
!
sWindowsById
)
{
return
nullptr
;
}
nsGlobalWindow
*
outerWindow
=
sWindowsById
-
>
Get
(
aWindowID
)
;
return
outerWindow
&
&
!
outerWindow
-
>
IsInnerWindow
(
)
?
outerWindow
:
nullptr
;
}
static
nsGlobalWindow
*
GetInnerWindowWithId
(
uint64_t
aInnerWindowID
)
{
AssertIsOnMainThread
(
)
;
if
(
!
sWindowsById
)
{
return
nullptr
;
}
nsGlobalWindow
*
innerWindow
=
sWindowsById
-
>
Get
(
aInnerWindowID
)
;
return
innerWindow
&
&
innerWindow
-
>
IsInnerWindow
(
)
?
innerWindow
:
nullptr
;
}
static
WindowByIdTable
*
GetWindowsTable
(
)
{
AssertIsOnMainThread
(
)
;
return
sWindowsById
;
}
void
AddSizeOfIncludingThis
(
nsWindowSizes
*
aWindowSizes
)
const
;
void
UnmarkGrayTimers
(
)
;
void
AddEventTargetObject
(
mozilla
:
:
DOMEventTargetHelper
*
aObject
)
;
void
RemoveEventTargetObject
(
mozilla
:
:
DOMEventTargetHelper
*
aObject
)
;
void
NotifyIdleObserver
(
IdleObserverHolder
*
aIdleObserverHolder
bool
aCallOnidle
)
;
nsresult
HandleIdleActiveEvent
(
)
;
bool
ContainsIdleObserver
(
nsIIdleObserver
*
aIdleObserver
uint32_t
timeInS
)
;
void
HandleIdleObserverCallback
(
)
;
void
AllowScriptsToClose
(
)
{
mAllowScriptsToClose
=
true
;
}
enum
SlowScriptResponse
{
ContinueSlowScript
=
0
ContinueSlowScriptAndKeepNotifying
AlwaysContinueSlowScript
KillSlowScript
}
;
SlowScriptResponse
ShowSlowScriptDialog
(
)
;
#
ifdef
MOZ_GAMEPAD
void
AddGamepad
(
uint32_t
aIndex
mozilla
:
:
dom
:
:
Gamepad
*
aGamepad
)
;
void
RemoveGamepad
(
uint32_t
aIndex
)
;
void
GetGamepads
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Gamepad
>
>
&
aGamepads
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Gamepad
>
GetGamepad
(
uint32_t
aIndex
)
;
void
SetHasSeenGamepadInput
(
bool
aHasSeen
)
;
bool
HasSeenGamepadInput
(
)
;
void
SyncGamepadState
(
)
;
#
endif
void
EnableGamepadUpdates
(
)
;
void
DisableGamepadUpdates
(
)
;
bool
UpdateVRDevices
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
VRDevice
>
>
&
aDevices
)
;
#
define
EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOn
#
#
name_
(
)
\
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
EmptyString
(
)
)
\
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
\
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
EmptyString
(
)
handler
)
;
\
}
\
}
#
define
ERROR_EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
OnErrorEventHandlerNonNull
*
GetOn
#
#
name_
(
)
\
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetOnErrorEventHandler
(
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
OnErrorEventHandlerNonNull
*
handler
)
\
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
handler
)
;
\
}
\
}
#
define
BEFOREUNLOAD_EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
GetOn
#
#
name_
(
)
\
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
;
\
return
elm
?
elm
-
>
GetOnBeforeUnloadEventHandler
(
)
:
nullptr
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
OnBeforeUnloadEventHandlerNonNull
*
handler
)
\
{
\
mozilla
:
:
EventListenerManager
*
elm
=
GetOrCreateListenerManager
(
)
;
\
if
(
elm
)
{
\
elm
-
>
SetEventHandler
(
handler
)
;
\
}
\
}
#
define
WINDOW_ONLY_EVENT
EVENT
#
define
TOUCH_EVENT
EVENT
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
TOUCH_EVENT
#
undef
WINDOW_ONLY_EVENT
#
undef
BEFOREUNLOAD_EVENT
#
undef
ERROR_EVENT
#
undef
EVENT
nsISupports
*
GetParentObject
(
)
{
return
nullptr
;
}
static
JSObject
*
CreateNamedPropertiesObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aProto
)
;
nsGlobalWindow
*
Window
(
)
;
nsGlobalWindow
*
Self
(
)
;
nsIDocument
*
GetDocument
(
)
{
return
GetDoc
(
)
;
}
void
GetNameOuter
(
nsAString
&
aName
)
;
void
GetName
(
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetNameOuter
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetName
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
aError
)
;
nsLocation
*
GetLocation
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsIDOMLocation
*
GetLocation
(
)
override
;
nsHistory
*
GetHistory
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetLocationbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetMenubar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetPersonalbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetScrollbars
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetStatusbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
BarProp
*
GetToolbar
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetStatusOuter
(
nsAString
&
aStatus
)
;
void
GetStatus
(
nsAString
&
aStatus
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetStatusOuter
(
const
nsAString
&
aStatus
)
;
void
SetStatus
(
const
nsAString
&
aStatus
mozilla
:
:
ErrorResult
&
aError
)
;
void
CloseOuter
(
bool
aTrustedCaller
)
;
void
Close
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
Close
(
)
override
;
bool
GetClosedOuter
(
)
;
bool
GetClosed
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
Closed
(
)
override
;
void
StopOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Stop
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
FocusOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Focus
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
Focus
(
)
override
;
void
BlurOuter
(
)
;
void
Blur
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetFramesOuter
(
)
;
already_AddRefed
<
nsIDOMWindowCollection
>
GetFrames
(
)
override
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetFrames
(
mozilla
:
:
ErrorResult
&
aError
)
;
uint32_t
Length
(
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTopOuter
(
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetTop
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetPrompter
(
nsIPrompt
*
*
aPrompt
)
override
;
protected
:
explicit
nsGlobalWindow
(
nsGlobalWindow
*
aOuterWindow
)
;
nsPIDOMWindowOuter
*
GetOpenerWindowOuter
(
)
;
nsPIDOMWindowOuter
*
GetOpenerWindow
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
InitWasOffline
(
)
;
public
:
void
GetOpener
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetOpener
(
)
override
;
void
SetOpener
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aOpener
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetParentOuter
(
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetParent
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetParent
(
)
override
;
nsPIDOMWindowOuter
*
GetScriptableParent
(
)
override
;
mozilla
:
:
dom
:
:
Element
*
GetFrameElementOuter
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetFrameElement
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIDOMElement
>
GetFrameElement
(
)
override
;
already_AddRefed
<
nsPIDOMWindowOuter
>
OpenOuter
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
Open
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
override
;
mozilla
:
:
dom
:
:
Navigator
*
GetNavigator
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsIDOMNavigator
*
GetNavigator
(
)
override
;
nsIDOMOfflineResourceList
*
GetApplicationCache
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIDOMOfflineResourceList
>
GetApplicationCache
(
)
override
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
int16_t
Orientation
(
)
const
;
#
endif
mozilla
:
:
dom
:
:
Console
*
GetConsole
(
mozilla
:
:
ErrorResult
&
aRv
)
;
void
GetSidebar
(
mozilla
:
:
dom
:
:
OwningExternalOrWindowProxy
&
aResult
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
External
>
GetExternal
(
mozilla
:
:
ErrorResult
&
aRv
)
;
static
bool
TokenizeDialogOptions
(
nsAString
&
aToken
nsAString
:
:
const_iterator
&
aIter
nsAString
:
:
const_iterator
aEnd
)
;
static
void
ConvertDialogOptions
(
const
nsAString
&
aOptions
nsAString
&
aResult
)
;
protected
:
bool
AlertOrConfirm
(
bool
aAlert
const
nsAString
&
aMessage
mozilla
:
:
ErrorResult
&
aError
)
;
public
:
void
Alert
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
AlertOuter
(
const
nsAString
&
aMessage
mozilla
:
:
ErrorResult
&
aError
)
;
void
Alert
(
const
nsAString
&
aMessage
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
cache
:
:
CacheStorage
>
GetCaches
(
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
ConfirmOuter
(
const
nsAString
&
aMessage
mozilla
:
:
ErrorResult
&
aError
)
;
bool
Confirm
(
const
nsAString
&
aMessage
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Fetch
(
const
mozilla
:
:
dom
:
:
RequestOrUSVString
&
aInput
const
mozilla
:
:
dom
:
:
RequestInit
&
aInit
mozilla
:
:
ErrorResult
&
aRv
)
;
void
PromptOuter
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
mozilla
:
:
ErrorResult
&
aError
)
;
void
Prompt
(
const
nsAString
&
aMessage
const
nsAString
&
aInitial
nsAString
&
aReturn
mozilla
:
:
ErrorResult
&
aError
)
;
void
PrintOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Print
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
ShowModalDialog
(
JSContext
*
aCx
const
nsAString
&
aUrl
JS
:
:
Handle
<
JS
:
:
Value
>
aArgument
const
nsAString
&
aOptions
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
const
mozilla
:
:
dom
:
:
Optional
<
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
>
&
aTransfer
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
SetTimeout
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Function
&
aFunction
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
SetTimeout
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
mozilla
:
:
ErrorResult
&
aError
)
;
void
ClearTimeout
(
int32_t
aHandle
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
SetInterval
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Function
&
aFunction
const
mozilla
:
:
dom
:
:
Optional
<
int32_t
>
&
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
SetInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
const
mozilla
:
:
dom
:
:
Optional
<
int32_t
>
&
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
mozilla
:
:
ErrorResult
&
aError
)
;
void
ClearInterval
(
int32_t
aHandle
mozilla
:
:
ErrorResult
&
aError
)
;
void
Atob
(
const
nsAString
&
aAsciiBase64String
nsAString
&
aBinaryData
mozilla
:
:
ErrorResult
&
aError
)
;
void
Btoa
(
const
nsAString
&
aBinaryData
nsAString
&
aAsciiBase64String
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
DOMStorage
*
GetSessionStorage
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
DOMStorage
*
GetLocalStorage
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Selection
*
GetSelectionOuter
(
)
;
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsISelection
>
GetSelection
(
)
override
;
mozilla
:
:
dom
:
:
IDBFactory
*
GetIndexedDB
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyle
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
mozilla
:
:
ErrorResult
&
aError
)
override
;
already_AddRefed
<
mozilla
:
:
dom
:
:
MediaQueryList
>
MatchMediaOuter
(
const
nsAString
&
aQuery
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
MediaQueryList
>
MatchMedia
(
const
nsAString
&
aQuery
mozilla
:
:
ErrorResult
&
aError
)
;
nsScreen
*
GetScreen
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsIDOMScreen
*
GetScreen
(
)
override
;
void
MoveToOuter
(
int32_t
aXPos
int32_t
aYPos
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
MoveTo
(
int32_t
aXPos
int32_t
aYPos
mozilla
:
:
ErrorResult
&
aError
)
;
void
MoveByOuter
(
int32_t
aXDif
int32_t
aYDif
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
MoveBy
(
int32_t
aXDif
int32_t
aYDif
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
MoveBy
(
int32_t
aXDif
int32_t
aYDif
)
override
;
void
ResizeToOuter
(
int32_t
aWidth
int32_t
aHeight
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
ResizeTo
(
int32_t
aWidth
int32_t
aHeight
mozilla
:
:
ErrorResult
&
aError
)
;
void
ResizeByOuter
(
int32_t
aWidthDif
int32_t
aHeightDif
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
ResizeBy
(
int32_t
aWidthDif
int32_t
aHeightDif
mozilla
:
:
ErrorResult
&
aError
)
;
void
Scroll
(
double
aXScroll
double
aYScroll
)
;
void
Scroll
(
const
mozilla
:
:
dom
:
:
ScrollToOptions
&
aOptions
)
;
void
ScrollTo
(
double
aXScroll
double
aYScroll
)
;
void
ScrollTo
(
const
mozilla
:
:
dom
:
:
ScrollToOptions
&
aOptions
)
;
void
ScrollBy
(
double
aXScrollDif
double
aYScrollDif
)
;
void
ScrollBy
(
const
mozilla
:
:
dom
:
:
ScrollToOptions
&
aOptions
)
;
void
ScrollByLines
(
int32_t
numLines
const
mozilla
:
:
dom
:
:
ScrollOptions
&
aOptions
)
;
void
ScrollByPages
(
int32_t
numPages
const
mozilla
:
:
dom
:
:
ScrollOptions
&
aOptions
)
;
void
MozScrollSnap
(
)
;
void
GetInnerWidth
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetInnerWidth
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetInnerHeight
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetInnerHeight
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollXOuter
(
)
;
int32_t
GetScrollX
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetPageXOffset
(
mozilla
:
:
ErrorResult
&
aError
)
{
return
GetScrollX
(
aError
)
;
}
int32_t
GetScrollYOuter
(
)
;
int32_t
GetScrollY
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetPageYOffset
(
mozilla
:
:
ErrorResult
&
aError
)
{
return
GetScrollY
(
aError
)
;
}
void
MozRequestOverfill
(
mozilla
:
:
dom
:
:
OverfillCallback
&
aCallback
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetScreenX
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetScreenX
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetScreenY
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetScreenY
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetOuterWidth
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterWidth
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetOuterHeight
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterHeight
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
RequestAnimationFrame
(
mozilla
:
:
dom
:
:
FrameRequestCallback
&
aCallback
mozilla
:
:
ErrorResult
&
aError
)
;
void
CancelAnimationFrame
(
int32_t
aHandle
mozilla
:
:
ErrorResult
&
aError
)
;
#
ifdef
MOZ_WEBSPEECH
mozilla
:
:
dom
:
:
SpeechSynthesis
*
GetSpeechSynthesis
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
HasActiveSpeechSynthesis
(
)
;
#
endif
already_AddRefed
<
nsICSSDeclaration
>
GetDefaultComputedStyle
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
mozilla
:
:
ErrorResult
&
aError
)
;
void
SizeToContentOuter
(
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
SizeToContent
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
Crypto
*
GetCrypto
(
mozilla
:
:
ErrorResult
&
aError
)
;
mozilla
:
:
dom
:
:
U2F
*
GetU2f
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsIControllers
*
GetControllersOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsIControllers
*
GetControllers
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetControllers
(
nsIControllers
*
*
aControllers
)
override
;
mozilla
:
:
dom
:
:
Element
*
GetRealFrameElementOuter
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetRealFrameElement
(
mozilla
:
:
ErrorResult
&
aError
)
;
float
GetMozInnerScreenXOuter
(
)
;
float
GetMozInnerScreenX
(
mozilla
:
:
ErrorResult
&
aError
)
;
float
GetMozInnerScreenYOuter
(
)
;
float
GetMozInnerScreenY
(
mozilla
:
:
ErrorResult
&
aError
)
;
float
GetDevicePixelRatioOuter
(
)
;
float
GetDevicePixelRatio
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetDevicePixelRatio
(
float
*
aRatio
)
override
;
int32_t
GetScrollMinX
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollMinY
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollMaxX
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScrollMaxY
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
GetFullScreenOuter
(
)
;
bool
GetFullScreen
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
GetFullScreen
(
)
override
;
void
SetFullScreenOuter
(
bool
aFullScreen
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetFullScreen
(
bool
aFullScreen
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
SetFullScreen
(
bool
aFullScreen
)
override
;
void
BackOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Back
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
ForwardOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Forward
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
HomeOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Home
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
FindOuter
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
mozilla
:
:
ErrorResult
&
aError
)
;
bool
Find
(
const
nsAString
&
aString
bool
aCaseSensitive
bool
aBackwards
bool
aWrapAround
bool
aWholeWord
bool
aSearchInFrames
bool
aShowDialog
mozilla
:
:
ErrorResult
&
aError
)
;
uint64_t
GetMozPaintCountOuter
(
)
;
uint64_t
GetMozPaintCount
(
mozilla
:
:
ErrorResult
&
aError
)
;
bool
ShouldResistFingerprinting
(
)
;
mozilla
:
:
dom
:
:
MozSelfSupport
*
GetMozSelfSupport
(
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
OpenDialogOuter
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
OpenDialog
(
JSContext
*
aCx
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aExtraArgument
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
OpenDialog
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsISupports
*
aExtraArgument
nsPIDOMWindowOuter
*
*
_retval
)
override
;
nsresult
UpdateCommands
(
const
nsAString
&
anAction
nsISelection
*
aSel
int16_t
aReason
)
override
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetContentInternal
(
mozilla
:
:
ErrorResult
&
aError
bool
aUnprivilegedCaller
)
;
void
GetContentOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetContent
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetContent
(
)
{
MOZ_ASSERT
(
IsOuterWindow
(
)
)
;
mozilla
:
:
ErrorResult
ignored
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
GetContentInternal
(
ignored
false
)
;
ignored
.
SuppressException
(
)
;
return
win
.
forget
(
)
;
}
void
Get_content
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
{
if
(
mDoc
)
{
mDoc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eWindow_Content
)
;
}
GetContent
(
aCx
aRetval
aError
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
CreateImageBitmap
(
const
mozilla
:
:
dom
:
:
ImageBitmapSource
&
aImage
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
CreateImageBitmap
(
const
mozilla
:
:
dom
:
:
ImageBitmapSource
&
aImage
int32_t
aSx
int32_t
aSy
int32_t
aSw
int32_t
aSh
mozilla
:
:
ErrorResult
&
aRv
)
;
uint16_t
WindowState
(
)
;
nsIBrowserDOMWindow
*
GetBrowserDOMWindowOuter
(
)
;
nsIBrowserDOMWindow
*
GetBrowserDOMWindow
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetBrowserDOMWindowOuter
(
nsIBrowserDOMWindow
*
aBrowserWindow
)
;
void
SetBrowserDOMWindow
(
nsIBrowserDOMWindow
*
aBrowserWindow
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetAttention
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetAttentionWithCycleCount
(
int32_t
aCycleCount
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetCursorOuter
(
const
nsAString
&
aCursor
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetCursor
(
const
nsAString
&
aCursor
mozilla
:
:
ErrorResult
&
aError
)
;
void
Maximize
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Minimize
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
Restore
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
NotifyDefaultButtonLoaded
(
mozilla
:
:
dom
:
:
Element
&
aDefaultButton
mozilla
:
:
ErrorResult
&
aError
)
;
nsIMessageBroadcaster
*
GetMessageManager
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsIMessageBroadcaster
*
GetGroupMessageManager
(
const
nsAString
&
aGroup
mozilla
:
:
ErrorResult
&
aError
)
;
void
BeginWindowMove
(
mozilla
:
:
dom
:
:
Event
&
aMouseDownEvent
mozilla
:
:
dom
:
:
Element
*
aPanel
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetDialogArgumentsOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetDialogArguments
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetReturnValueOuter
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aReturnValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetReturnValue
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aReturnValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetReturnValueOuter
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReturnValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetReturnValue
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReturnValue
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetInterface
(
JSContext
*
aCx
nsIJSID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsWindowRoot
>
GetWindowRootOuter
(
)
;
already_AddRefed
<
nsWindowRoot
>
GetWindowRoot
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsPerformance
*
GetPerformance
(
)
;
protected
:
void
RedefineProperty
(
JSContext
*
aCx
const
char
*
aPropName
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
mozilla
:
:
ErrorResult
&
aError
)
;
typedef
int32_t
(
nsGlobalWindow
:
:
*
WindowCoordGetter
)
(
mozilla
:
:
ErrorResult
&
)
;
typedef
void
(
nsGlobalWindow
:
:
*
WindowCoordSetter
)
(
int32_t
mozilla
:
:
ErrorResult
&
)
;
void
GetReplaceableWindowCoord
(
JSContext
*
aCx
WindowCoordGetter
aGetter
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetReplaceableWindowCoord
(
JSContext
*
aCx
WindowCoordSetter
aSetter
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
const
char
*
aPropName
mozilla
:
:
ErrorResult
&
aError
)
;
public
:
int32_t
GetInnerWidthOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
protected
:
int32_t
GetInnerWidth
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetInnerWidth
(
int32_t
*
aWidth
)
override
;
void
SetInnerWidthOuter
(
int32_t
aInnerWidth
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
SetInnerWidth
(
int32_t
aInnerWidth
mozilla
:
:
ErrorResult
&
aError
)
;
public
:
int32_t
GetInnerHeightOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
protected
:
int32_t
GetInnerHeight
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetInnerHeight
(
int32_t
*
aHeight
)
override
;
void
SetInnerHeightOuter
(
int32_t
aInnerHeight
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
SetInnerHeight
(
int32_t
aInnerHeight
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenXOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenX
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetScreenXOuter
(
int32_t
aScreenX
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
SetScreenX
(
int32_t
aScreenX
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenYOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetScreenY
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetScreenYOuter
(
int32_t
aScreenY
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
SetScreenY
(
int32_t
aScreenY
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterWidthOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterWidth
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterWidthOuter
(
int32_t
aOuterWidth
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
SetOuterWidth
(
int32_t
aOuterWidth
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterHeightOuter
(
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
GetOuterHeight
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterHeightOuter
(
int32_t
aOuterHeight
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
void
SetOuterHeight
(
int32_t
aOuterHeight
mozilla
:
:
ErrorResult
&
aError
)
;
nsTObserverArray
<
IdleObserverHolder
>
mIdleObservers
;
nsCOMPtr
<
nsITimer
>
mIdleTimer
;
uint32_t
mIdleFuzzFactor
;
int32_t
mIdleCallbackIndex
;
bool
mCurrentlyIdle
;
bool
mAddActiveEventFuzzTime
;
nsCOMPtr
<
nsIIdleService
>
mIdleService
;
RefPtr
<
mozilla
:
:
dom
:
:
WakeLock
>
mWakeLock
;
static
bool
sIdleObserversAPIFuzzTimeDisabled
;
friend
class
HashchangeCallback
;
friend
class
mozilla
:
:
dom
:
:
BarProp
;
virtual
~
nsGlobalWindow
(
)
;
void
DropOuterWindowDocs
(
)
;
void
CleanUp
(
)
;
void
ClearControllers
(
)
;
void
FinalClose
(
)
;
inline
void
MaybeClearInnerWindow
(
nsGlobalWindow
*
aExpectedInner
)
{
if
(
mInnerWindow
=
=
aExpectedInner
-
>
AsInner
(
)
)
{
mInnerWindow
=
nullptr
;
}
}
void
FreeInnerObjects
(
)
;
nsGlobalWindow
*
CallerInnerWindow
(
)
;
void
InnerSetNewDocument
(
JSContext
*
aCx
nsIDocument
*
aDocument
)
;
nsresult
DefineArgumentsProperty
(
nsIArray
*
aArguments
)
;
nsPIDOMWindowOuter
*
GetParentInternal
(
)
;
bool
IsPopupSpamWindow
(
)
{
if
(
IsInnerWindow
(
)
&
&
!
mOuterWindow
)
{
return
false
;
}
return
GetOuterWindowInternal
(
)
-
>
mIsPopupSpam
;
}
void
SetPopupSpamWindow
(
bool
aPopup
)
{
if
(
IsInnerWindow
(
)
&
&
!
mOuterWindow
)
{
NS_ERROR
(
"
SetPopupSpamWindow
(
)
called
on
inner
window
w
/
o
an
outer
!
"
)
;
return
;
}
GetOuterWindowInternal
(
)
-
>
mIsPopupSpam
=
aPopup
;
}
virtual
nsresult
OpenNoNavigate
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
nsPIDOMWindowOuter
*
*
_retval
)
override
;
private
:
nsresult
OpenInternal
(
const
nsAString
&
aUrl
const
nsAString
&
aName
const
nsAString
&
aOptions
bool
aDialog
bool
aContentModal
bool
aCalledNoScript
bool
aDoJSFixups
bool
aNavigate
nsIArray
*
argv
nsISupports
*
aExtraArgument
JSContext
*
aJSCallerContext
nsPIDOMWindowOuter
*
*
aReturn
)
;
public
:
nsresult
SetTimeoutOrInterval
(
nsIScriptTimeoutHandler
*
aHandler
int32_t
interval
bool
aIsInterval
int32_t
*
aReturn
)
;
int32_t
SetTimeoutOrInterval
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
Function
&
aFunction
int32_t
aTimeout
const
mozilla
:
:
dom
:
:
Sequence
<
JS
:
:
Value
>
&
aArguments
bool
aIsInterval
mozilla
:
:
ErrorResult
&
aError
)
;
int32_t
SetTimeoutOrInterval
(
JSContext
*
aCx
const
nsAString
&
aHandler
int32_t
aTimeout
bool
aIsInterval
mozilla
:
:
ErrorResult
&
aError
)
;
void
ClearTimeoutOrInterval
(
int32_t
aTimerID
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
ResetTimersForNonBackgroundWindow
(
)
;
void
RunTimeout
(
nsTimeout
*
aTimeout
)
;
void
RunTimeout
(
)
{
RunTimeout
(
nullptr
)
;
}
bool
RunTimeoutHandler
(
nsTimeout
*
aTimeout
nsIScriptContext
*
aScx
)
;
bool
RescheduleTimeout
(
nsTimeout
*
aTimeout
const
TimeStamp
&
now
bool
aRunningPendingTimeouts
)
;
void
ClearAllTimeouts
(
)
;
void
InsertTimeoutIntoList
(
nsTimeout
*
aTimeout
)
;
static
void
TimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
static
void
TimerNameCallback
(
nsITimer
*
aTimer
void
*
aClosure
char
*
aBuf
size_t
aLen
)
;
already_AddRefed
<
nsIDocShellTreeOwner
>
GetTreeOwner
(
)
;
already_AddRefed
<
nsIBaseWindow
>
GetTreeOwnerWindow
(
)
;
already_AddRefed
<
nsIWebBrowserChrome
>
GetWebBrowserChrome
(
)
;
nsresult
SecurityCheckURL
(
const
char
*
aURL
)
;
bool
IsPrivateBrowsing
(
)
;
bool
PopupWhitelisted
(
)
;
PopupControlState
RevisePopupAbuseLevel
(
PopupControlState
)
;
void
FireAbuseEvents
(
bool
aBlocked
bool
aWindow
const
nsAString
&
aPopupURL
const
nsAString
&
aPopupWindowName
const
nsAString
&
aPopupWindowFeatures
)
;
void
FireOfflineStatusEventIfChanged
(
)
;
bool
GetIsPrerendered
(
)
;
nsresult
ScheduleNextIdleObserverCallback
(
)
;
uint32_t
GetFuzzTimeMS
(
)
;
nsresult
ScheduleActiveTimerCallback
(
)
;
uint32_t
FindInsertionIndex
(
IdleObserverHolder
*
aIdleObserver
)
;
virtual
nsresult
RegisterIdleObserver
(
nsIIdleObserver
*
aIdleObserverPtr
)
override
;
nsresult
FindIndexOfElementToRemove
(
nsIIdleObserver
*
aIdleObserver
int32_t
*
aRemoveElementIndex
)
;
virtual
nsresult
UnregisterIdleObserver
(
nsIIdleObserver
*
aIdleObserverPtr
)
override
;
nsresult
FireHashchange
(
const
nsAString
&
aOldURL
const
nsAString
&
aNewURL
)
;
void
FlushPendingNotifications
(
mozFlushType
aType
)
;
void
EnsureReflowFlushAndPaint
(
)
;
void
CheckSecurityWidthAndHeight
(
int32_t
*
width
int32_t
*
height
bool
aCallerIsChrome
)
;
void
CheckSecurityLeftAndTop
(
int32_t
*
left
int32_t
*
top
bool
aCallerIsChrome
)
;
void
SetCSSViewportWidthAndHeight
(
nscoord
width
nscoord
height
)
;
nsresult
SetDocShellWidthAndHeight
(
int32_t
width
int32_t
height
)
;
static
bool
CanSetProperty
(
const
char
*
aPrefName
)
;
static
void
MakeScriptDialogTitle
(
nsAString
&
aOutTitle
)
;
bool
CanMoveResizeWindows
(
bool
aCallerIsChrome
)
;
mozilla
:
:
CSSIntPoint
GetScrollXY
(
bool
aDoFlush
)
;
int32_t
GetScrollBoundaryOuter
(
mozilla
:
:
Side
aSide
)
;
nsresult
GetInnerSize
(
mozilla
:
:
CSSIntSize
&
aSize
)
;
nsIntSize
GetOuterSize
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
SetOuterSize
(
int32_t
aLengthCSSPixels
bool
aIsWidth
mozilla
:
:
ErrorResult
&
aError
bool
aCallerIsChrome
)
;
nsRect
GetInnerScreenRect
(
)
;
void
ScrollTo
(
const
mozilla
:
:
CSSIntPoint
&
aScroll
const
mozilla
:
:
dom
:
:
ScrollOptions
&
aOptions
)
;
bool
IsFrame
(
)
{
return
GetParentInternal
(
)
!
=
nullptr
;
}
bool
WindowExists
(
const
nsAString
&
aName
bool
aLookForCallerOnJSStack
)
;
already_AddRefed
<
nsIWidget
>
GetMainWidget
(
)
;
nsIWidget
*
GetNearestWidget
(
)
const
;
void
Freeze
(
)
{
NS_ASSERTION
(
!
IsFrozen
(
)
"
Double
-
freezing
?
"
)
;
mIsFrozen
=
true
;
NotifyDOMWindowFrozen
(
this
)
;
}
void
Thaw
(
)
{
mIsFrozen
=
false
;
NotifyDOMWindowThawed
(
this
)
;
}
bool
IsInModalState
(
)
;
int32_t
DevToCSSIntPixels
(
int32_t
px
)
;
int32_t
CSSToDevIntPixels
(
int32_t
px
)
;
nsIntSize
DevToCSSIntPixels
(
nsIntSize
px
)
;
nsIntSize
CSSToDevIntPixels
(
nsIntSize
px
)
;
virtual
void
SetFocusedNode
(
nsIContent
*
aNode
uint32_t
aFocusMethod
=
0
bool
aNeedsFocus
=
false
)
override
;
virtual
uint32_t
GetFocusMethod
(
)
override
;
virtual
bool
ShouldShowFocusRing
(
)
override
;
virtual
void
SetKeyboardIndicators
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
override
;
virtual
void
GetKeyboardIndicators
(
bool
*
aShowAccelerators
bool
*
aShowFocusRings
)
override
;
void
UpdateCanvasFocus
(
bool
aFocusChanged
nsIContent
*
aNewContent
)
;
public
:
virtual
already_AddRefed
<
nsPIWindowRoot
>
GetTopWindowRoot
(
)
override
;
protected
:
static
void
NotifyDOMWindowDestroyed
(
nsGlobalWindow
*
aWindow
)
;
void
NotifyWindowIDDestroyed
(
const
char
*
aTopic
)
;
static
void
NotifyDOMWindowFrozen
(
nsGlobalWindow
*
aWindow
)
;
static
void
NotifyDOMWindowThawed
(
nsGlobalWindow
*
aWindow
)
;
void
ClearStatus
(
)
;
virtual
void
UpdateParentTarget
(
)
override
;
inline
int32_t
DOMMinTimeoutValue
(
)
const
;
void
ClearDocumentDependentSlots
(
JSContext
*
aCx
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
StorageEvent
>
CloneStorageEvent
(
const
nsAString
&
aType
const
RefPtr
<
mozilla
:
:
dom
:
:
StorageEvent
>
&
aEvent
mozilla
:
:
ErrorResult
&
aRv
)
;
public
:
nsDOMWindowList
*
GetWindowList
(
)
;
protected
:
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyleHelperOuter
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
)
;
already_AddRefed
<
nsICSSDeclaration
>
GetComputedStyleHelper
(
mozilla
:
:
dom
:
:
Element
&
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
GetComputedStyleHelper
(
nsIDOMElement
*
aElt
const
nsAString
&
aPseudoElt
bool
aDefaultStylesOnly
nsIDOMCSSStyleDeclaration
*
*
aReturn
)
;
void
PreloadLocalStorage
(
)
;
mozilla
:
:
CSSIntPoint
GetScreenXY
(
mozilla
:
:
ErrorResult
&
aError
)
;
nsGlobalWindow
*
InnerForSetTimeoutOrInterval
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
PostMessageMozOuter
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
mozilla
:
:
ErrorResult
&
aError
)
;
void
PostMessageMoz
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aMessage
const
nsAString
&
aTargetOrigin
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfer
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIVariant
>
ShowModalDialogOuter
(
const
nsAString
&
aUrl
nsIVariant
*
aArgument
const
nsAString
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsIVariant
>
ShowModalDialog
(
const
nsAString
&
aUrl
nsIVariant
*
aArgument
const
nsAString
&
aOptions
mozilla
:
:
ErrorResult
&
aError
)
;
bool
ConfirmDialogIfNeeded
(
)
;
private
:
void
FireOnNewGlobalObject
(
)
;
void
DisconnectEventTargetObjects
(
)
;
protected
:
bool
mIsFrozen
:
1
;
bool
mFullScreen
:
1
;
bool
mFullscreenMode
:
1
;
bool
mIsClosed
:
1
;
bool
mInClose
:
1
;
bool
mHavePendingClose
:
1
;
bool
mHadOriginalOpener
:
1
;
bool
mIsPopupSpam
:
1
;
bool
mBlockScriptedClosingFlag
:
1
;
bool
mWasOffline
:
1
;
bool
mNotifyIdleObserversIdleOnThaw
:
1
;
bool
mNotifyIdleObserversActiveOnThaw
:
1
;
bool
mCreatingInnerWindow
:
1
;
bool
mIsChrome
:
1
;
bool
mCleanMessageManager
:
1
;
bool
mNeedsFocus
:
1
;
bool
mHasFocus
:
1
;
bool
mShowAccelerators
:
1
;
bool
mShowFocusRings
:
1
;
bool
mShowFocusRingForContent
:
1
;
bool
mFocusByKeyOccurred
:
1
;
bool
mInnerObjectsFreed
:
1
;
bool
mHasGamepad
:
1
;
#
ifdef
MOZ_GAMEPAD
nsCheapSet
<
nsUint32HashKey
>
mGamepadIndexSet
;
nsRefPtrHashtable
<
nsUint32HashKey
mozilla
:
:
dom
:
:
Gamepad
>
mGamepads
;
bool
mHasSeenGamepadInput
;
#
endif
bool
mNotifiedIDDestroyed
:
1
;
bool
mAllowScriptsToClose
:
1
;
nsCOMPtr
<
nsIScriptContext
>
mContext
;
nsWeakPtr
mOpener
;
nsCOMPtr
<
nsIControllers
>
mControllers
;
nsCOMPtr
<
nsIArray
>
mArguments
;
RefPtr
<
DialogValueHolder
>
mDialogArguments
;
RefPtr
<
DialogValueHolder
>
mReturnValue
;
RefPtr
<
mozilla
:
:
dom
:
:
Navigator
>
mNavigator
;
RefPtr
<
nsScreen
>
mScreen
;
RefPtr
<
nsDOMWindowList
>
mFrames
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mMenubar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mToolbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mLocationbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mPersonalbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mStatusbar
;
RefPtr
<
mozilla
:
:
dom
:
:
BarProp
>
mScrollbars
;
RefPtr
<
nsDOMWindowUtils
>
mWindowUtils
;
nsString
mStatus
;
nsString
mDefaultStatus
;
RefPtr
<
nsGlobalWindowObserver
>
mObserver
;
RefPtr
<
mozilla
:
:
dom
:
:
Crypto
>
mCrypto
;
RefPtr
<
mozilla
:
:
dom
:
:
U2F
>
mU2F
;
RefPtr
<
mozilla
:
:
dom
:
:
cache
:
:
CacheStorage
>
mCacheStorage
;
RefPtr
<
mozilla
:
:
dom
:
:
Console
>
mConsole
;
nsCOMPtr
<
nsISupports
>
mExternal
;
RefPtr
<
mozilla
:
:
dom
:
:
MozSelfSupport
>
mMozSelfSupport
;
RefPtr
<
mozilla
:
:
dom
:
:
DOMStorage
>
mLocalStorage
;
RefPtr
<
mozilla
:
:
dom
:
:
DOMStorage
>
mSessionStorage
;
RefPtr
<
mozilla
:
:
EventListenerManager
>
mListenerManager
;
mozilla
:
:
LinkedList
<
nsTimeout
>
mTimeouts
;
nsTimeout
*
mTimeoutInsertionPoint
;
uint32_t
mTimeoutPublicIdCounter
;
uint32_t
mTimeoutFiringDepth
;
RefPtr
<
nsLocation
>
mLocation
;
RefPtr
<
nsHistory
>
mHistory
;
nsCOMPtr
<
nsIPrincipal
>
mDocumentPrincipal
;
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
StorageEvent
>
>
nsDOMStorageEventArray
;
nsDOMStorageEventArray
mPendingStorageEvents
;
uint32_t
mTimeoutsSuspendDepth
;
uint32_t
mFocusMethod
;
uint32_t
mSerial
;
#
ifdef
DEBUG
bool
mSetOpenerWindowCalled
;
nsCOMPtr
<
nsIURI
>
mLastOpenedURI
;
#
endif
#
ifdef
MOZ_B2G
bool
mNetworkUploadObserverEnabled
;
bool
mNetworkDownloadObserverEnabled
;
#
endif
bool
mCleanedUp
;
nsCOMPtr
<
nsIDOMOfflineResourceList
>
mApplicationCache
;
nsAutoPtr
<
nsJSThingHashtable
<
nsPtrHashKey
<
nsXBLPrototypeHandler
>
JSObject
*
>
>
mCachedXBLPrototypeHandlers
;
nsCOMPtr
<
nsIDocument
>
mSuspendedDoc
;
RefPtr
<
mozilla
:
:
dom
:
:
IDBFactory
>
mIndexedDB
;
uint32_t
mDialogAbuseCount
;
TimeStamp
mLastDialogQuitTime
;
bool
mAreDialogsEnabled
;
nsTHashtable
<
nsPtrHashKey
<
mozilla
:
:
DOMEventTargetHelper
>
>
mEventTargetObjects
;
nsTArray
<
uint32_t
>
mEnabledSensors
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_GONK
)
nsAutoPtr
<
mozilla
:
:
dom
:
:
WindowOrientationObserver
>
mOrientationChangeObserver
;
#
endif
#
ifdef
MOZ_WEBSPEECH
RefPtr
<
mozilla
:
:
dom
:
:
SpeechSynthesis
>
mSpeechSynthesis
;
#
endif
uint32_t
mCanSkipCCGeneration
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
VRDevice
>
>
mVRDevices
;
friend
class
nsDOMScriptableHelper
;
friend
class
nsDOMWindowUtils
;
friend
class
mozilla
:
:
dom
:
:
PostMessageEvent
;
friend
class
DesktopNotification
;
static
WindowByIdTable
*
sWindowsById
;
static
bool
sWarnedAboutWindowInternal
;
}
;
inline
nsISupports
*
ToSupports
(
nsGlobalWindow
*
p
)
{
return
static_cast
<
nsIDOMEventTarget
*
>
(
p
)
;
}
inline
nsISupports
*
ToCanonicalSupports
(
nsGlobalWindow
*
p
)
{
return
static_cast
<
nsIDOMEventTarget
*
>
(
p
)
;
}
class
nsGlobalChromeWindow
:
public
nsGlobalWindow
public
nsIDOMChromeWindow
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIDOMCHROMEWINDOW
static
already_AddRefed
<
nsGlobalChromeWindow
>
Create
(
nsGlobalWindow
*
aOuterWindow
)
;
void
DisconnectAndClearGroupMessageManagers
(
)
{
for
(
auto
iter
=
mGroupMessageManagers
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsIMessageBroadcaster
*
mm
=
iter
.
UserData
(
)
;
if
(
mm
)
{
static_cast
<
nsFrameMessageManager
*
>
(
mm
)
-
>
Disconnect
(
)
;
}
}
mGroupMessageManagers
.
Clear
(
)
;
}
protected
:
explicit
nsGlobalChromeWindow
(
nsGlobalWindow
*
aOuterWindow
)
:
nsGlobalWindow
(
aOuterWindow
)
mGroupMessageManagers
(
1
)
{
mIsChrome
=
true
;
mCleanMessageManager
=
true
;
}
~
nsGlobalChromeWindow
(
)
{
MOZ_ASSERT
(
mCleanMessageManager
"
chrome
windows
may
always
disconnect
the
msg
manager
"
)
;
DisconnectAndClearGroupMessageManagers
(
)
;
if
(
mMessageManager
)
{
static_cast
<
nsFrameMessageManager
*
>
(
mMessageManager
.
get
(
)
)
-
>
Disconnect
(
)
;
}
mCleanMessageManager
=
false
;
}
public
:
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsGlobalChromeWindow
nsGlobalWindow
)
using
nsGlobalWindow
:
:
GetBrowserDOMWindow
;
using
nsGlobalWindow
:
:
SetBrowserDOMWindow
;
using
nsGlobalWindow
:
:
GetAttention
;
using
nsGlobalWindow
:
:
GetAttentionWithCycleCount
;
using
nsGlobalWindow
:
:
SetCursor
;
using
nsGlobalWindow
:
:
Maximize
;
using
nsGlobalWindow
:
:
Minimize
;
using
nsGlobalWindow
:
:
Restore
;
using
nsGlobalWindow
:
:
NotifyDefaultButtonLoaded
;
using
nsGlobalWindow
:
:
GetMessageManager
;
using
nsGlobalWindow
:
:
GetGroupMessageManager
;
using
nsGlobalWindow
:
:
BeginWindowMove
;
nsCOMPtr
<
nsIBrowserDOMWindow
>
mBrowserDOMWindow
;
nsCOMPtr
<
nsIMessageBroadcaster
>
mMessageManager
;
nsInterfaceHashtable
<
nsStringHashKey
nsIMessageBroadcaster
>
mGroupMessageManagers
;
}
;
class
nsGlobalModalWindow
:
public
nsGlobalWindow
public
nsIDOMModalContentWindow
{
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIDOMMODALCONTENTWINDOW
static
already_AddRefed
<
nsGlobalModalWindow
>
Create
(
nsGlobalWindow
*
aOuterWindow
)
;
protected
:
explicit
nsGlobalModalWindow
(
nsGlobalWindow
*
aOuterWindow
)
:
nsGlobalWindow
(
aOuterWindow
)
{
mIsModalContentWindow
=
true
;
}
~
nsGlobalModalWindow
(
)
{
}
}
;
inline
already_AddRefed
<
nsGlobalWindow
>
NS_NewScriptGlobalObject
(
bool
aIsChrome
bool
aIsModalContentWindow
)
{
RefPtr
<
nsGlobalWindow
>
global
;
if
(
aIsChrome
)
{
global
=
nsGlobalChromeWindow
:
:
Create
(
nullptr
)
;
}
else
if
(
aIsModalContentWindow
)
{
global
=
nsGlobalModalWindow
:
:
Create
(
nullptr
)
;
}
else
{
global
=
nsGlobalWindow
:
:
Create
(
nullptr
)
;
}
return
global
.
forget
(
)
;
}
#
endif
