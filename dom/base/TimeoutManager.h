#
ifndef
mozilla_dom_TimeoutManager_h__
#
define
mozilla_dom_TimeoutManager_h__
#
include
"
mozilla
/
dom
/
Timeout
.
h
"
class
nsITimeoutHandler
;
class
nsGlobalWindow
;
namespace
mozilla
{
namespace
dom
{
class
TimeoutManager
final
{
public
:
explicit
TimeoutManager
(
nsGlobalWindow
&
aWindow
)
;
TimeoutManager
(
const
TimeoutManager
&
rhs
)
=
delete
;
void
operator
=
(
const
TimeoutManager
&
rhs
)
=
delete
;
bool
IsRunningTimeout
(
)
const
{
return
mTimeoutFiringDepth
>
0
;
}
static
uint32_t
GetNestingLevel
(
)
{
return
sNestingLevel
;
}
static
void
SetNestingLevel
(
uint32_t
aLevel
)
{
sNestingLevel
=
aLevel
;
}
bool
HasTimeouts
(
)
const
{
return
!
mTimeouts
.
IsEmpty
(
)
;
}
nsresult
SetTimeout
(
nsITimeoutHandler
*
aHandler
int32_t
interval
bool
aIsInterval
mozilla
:
:
dom
:
:
Timeout
:
:
Reason
aReason
int32_t
*
aReturn
)
;
void
ClearTimeout
(
int32_t
aTimerId
mozilla
:
:
dom
:
:
Timeout
:
:
Reason
aReason
)
;
void
RunTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
)
;
bool
RescheduleTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
const
TimeStamp
&
now
bool
aRunningPendingTimeouts
)
;
void
ClearAllTimeouts
(
)
;
void
InsertTimeoutIntoList
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
)
;
uint32_t
GetTimeoutId
(
mozilla
:
:
dom
:
:
Timeout
:
:
Reason
aReason
)
;
void
MaybeApplyBackPressure
(
)
;
void
CancelOrUpdateBackPressure
(
nsGlobalWindow
*
aWindow
)
;
nsresult
ResetTimersForThrottleReduction
(
)
;
int32_t
DOMMinTimeoutValue
(
)
const
;
mozilla
:
:
dom
:
:
Timeout
*
BeginRunningTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
)
;
void
EndRunningTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
)
;
void
UnmarkGrayTimers
(
)
;
void
Suspend
(
)
;
void
Resume
(
)
;
void
Freeze
(
)
;
void
Thaw
(
)
;
static
void
Initialize
(
)
;
template
<
class
Callable
>
void
ForEachTimeout
(
Callable
c
)
{
mTimeouts
.
ForEach
(
c
)
;
}
template
<
class
Callable
>
void
ForEachTimeoutAbortable
(
Callable
c
)
{
mTimeouts
.
ForEachAbortable
(
c
)
;
}
private
:
nsresult
ResetTimersForThrottleReduction
(
int32_t
aPreviousThrottleDelayMS
)
;
private
:
typedef
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
Timeout
>
TimeoutList
;
struct
Timeouts
{
Timeouts
(
)
:
mTimeoutInsertionPoint
(
nullptr
)
{
}
const
Timeout
*
GetFirst
(
)
const
{
return
mTimeoutList
.
getFirst
(
)
;
}
Timeout
*
GetFirst
(
)
{
return
mTimeoutList
.
getFirst
(
)
;
}
const
Timeout
*
GetLast
(
)
const
{
return
mTimeoutList
.
getLast
(
)
;
}
Timeout
*
GetLast
(
)
{
return
mTimeoutList
.
getLast
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mTimeoutList
.
isEmpty
(
)
;
}
void
InsertFront
(
Timeout
*
aTimeout
)
{
mTimeoutList
.
insertFront
(
aTimeout
)
;
}
void
Clear
(
)
{
mTimeoutList
.
clear
(
)
;
}
void
SetInsertionPoint
(
Timeout
*
aTimeout
)
{
mTimeoutInsertionPoint
=
aTimeout
;
}
Timeout
*
InsertionPoint
(
)
{
return
mTimeoutInsertionPoint
;
}
template
<
class
Callable
>
void
ForEach
(
Callable
c
)
{
for
(
Timeout
*
timeout
=
GetFirst
(
)
;
timeout
;
timeout
=
timeout
-
>
getNext
(
)
)
{
c
(
timeout
)
;
}
}
template
<
class
Callable
>
void
ForEachAbortable
(
Callable
c
)
{
for
(
Timeout
*
timeout
=
GetFirst
(
)
;
timeout
;
timeout
=
timeout
-
>
getNext
(
)
)
{
if
(
c
(
timeout
)
)
{
break
;
}
}
}
private
:
TimeoutList
mTimeoutList
;
mozilla
:
:
dom
:
:
Timeout
*
mTimeoutInsertionPoint
;
}
;
nsGlobalWindow
&
mWindow
;
Timeouts
mTimeouts
;
uint32_t
mTimeoutIdCounter
;
uint32_t
mTimeoutFiringDepth
;
mozilla
:
:
dom
:
:
Timeout
*
mRunningTimeout
;
uint32_t
mIdleCallbackTimeoutCounter
;
int32_t
mBackPressureDelayMS
;
static
uint32_t
sNestingLevel
;
}
;
}
}
#
endif
