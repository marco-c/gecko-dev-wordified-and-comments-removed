#
ifndef
mozilla_dom_TimeoutManager_h__
#
define
mozilla_dom_TimeoutManager_h__
#
include
"
mozilla
/
dom
/
Timeout
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIEventTarget
;
class
nsITimeoutHandler
;
class
nsGlobalWindow
;
namespace
mozilla
{
namespace
dom
{
class
OrderedTimeoutIterator
;
class
TimeoutManager
final
{
public
:
explicit
TimeoutManager
(
nsGlobalWindow
&
aWindow
)
;
~
TimeoutManager
(
)
;
TimeoutManager
(
const
TimeoutManager
&
rhs
)
=
delete
;
void
operator
=
(
const
TimeoutManager
&
rhs
)
=
delete
;
bool
IsRunningTimeout
(
)
const
;
static
uint32_t
GetNestingLevel
(
)
{
return
sNestingLevel
;
}
static
void
SetNestingLevel
(
uint32_t
aLevel
)
{
sNestingLevel
=
aLevel
;
}
bool
HasTimeouts
(
)
const
{
return
!
mNormalTimeouts
.
IsEmpty
(
)
|
|
!
mTrackingTimeouts
.
IsEmpty
(
)
;
}
nsresult
SetTimeout
(
nsITimeoutHandler
*
aHandler
int32_t
interval
bool
aIsInterval
mozilla
:
:
dom
:
:
Timeout
:
:
Reason
aReason
int32_t
*
aReturn
)
;
void
ClearTimeout
(
int32_t
aTimerId
mozilla
:
:
dom
:
:
Timeout
:
:
Reason
aReason
)
;
void
RunTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
)
;
bool
RescheduleTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
const
TimeStamp
&
now
)
;
void
ClearAllTimeouts
(
)
;
uint32_t
GetTimeoutId
(
mozilla
:
:
dom
:
:
Timeout
:
:
Reason
aReason
)
;
void
MaybeApplyBackPressure
(
)
;
void
CancelOrUpdateBackPressure
(
nsGlobalWindow
*
aWindow
)
;
nsresult
ResetTimersForThrottleReduction
(
)
;
int32_t
DOMMinTimeoutValue
(
bool
aIsTracking
)
const
;
mozilla
:
:
dom
:
:
Timeout
*
BeginRunningTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
)
;
void
EndRunningTimeout
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
)
;
void
UnmarkGrayTimers
(
)
;
void
Suspend
(
)
;
void
Resume
(
)
;
void
Freeze
(
)
;
void
Thaw
(
)
;
static
void
Initialize
(
)
;
bool
IsTimeoutTracking
(
uint32_t
aTimeoutId
)
;
void
OnDocumentLoaded
(
)
;
void
StartThrottlingTrackingTimeouts
(
)
;
template
<
class
Callable
>
void
ForEachUnorderedTimeout
(
Callable
c
)
{
mNormalTimeouts
.
ForEach
(
c
)
;
mTrackingTimeouts
.
ForEach
(
c
)
;
}
template
<
class
Callable
>
void
ForEachUnorderedTimeoutAbortable
(
Callable
c
)
{
if
(
!
mNormalTimeouts
.
ForEachAbortable
(
c
)
)
{
mTrackingTimeouts
.
ForEachAbortable
(
c
)
;
}
}
void
BeginSyncOperation
(
)
;
void
EndSyncOperation
(
)
;
static
const
uint32_t
InvalidFiringId
;
private
:
nsresult
ResetTimersForThrottleReduction
(
int32_t
aPreviousThrottleDelayMS
)
;
void
MaybeStartThrottleTrackingTimout
(
)
;
bool
IsBackground
(
)
const
;
uint32_t
CreateFiringId
(
)
;
void
DestroyFiringId
(
uint32_t
aFiringId
)
;
bool
IsInvalidFiringId
(
uint32_t
aFiringId
)
const
;
private
:
struct
Timeouts
{
Timeouts
(
)
:
mTimeoutInsertionPoint
(
nullptr
)
{
}
enum
class
SortBy
{
TimeRemaining
TimeWhen
}
;
void
Insert
(
mozilla
:
:
dom
:
:
Timeout
*
aTimeout
SortBy
aSortBy
)
;
nsresult
ResetTimersForThrottleReduction
(
int32_t
aPreviousThrottleDelayMS
const
TimeoutManager
&
aTimeoutManager
SortBy
aSortBy
nsIEventTarget
*
aQueue
)
;
const
Timeout
*
GetFirst
(
)
const
{
return
mTimeoutList
.
getFirst
(
)
;
}
Timeout
*
GetFirst
(
)
{
return
mTimeoutList
.
getFirst
(
)
;
}
const
Timeout
*
GetLast
(
)
const
{
return
mTimeoutList
.
getLast
(
)
;
}
Timeout
*
GetLast
(
)
{
return
mTimeoutList
.
getLast
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mTimeoutList
.
isEmpty
(
)
;
}
void
InsertFront
(
Timeout
*
aTimeout
)
{
mTimeoutList
.
insertFront
(
aTimeout
)
;
}
void
Clear
(
)
{
mTimeoutList
.
clear
(
)
;
}
void
SetInsertionPoint
(
Timeout
*
aTimeout
)
{
mTimeoutInsertionPoint
=
aTimeout
;
}
Timeout
*
InsertionPoint
(
)
{
return
mTimeoutInsertionPoint
;
}
template
<
class
Callable
>
void
ForEach
(
Callable
c
)
{
for
(
Timeout
*
timeout
=
GetFirst
(
)
;
timeout
;
timeout
=
timeout
-
>
getNext
(
)
)
{
c
(
timeout
)
;
}
}
template
<
class
Callable
>
bool
ForEachAbortable
(
Callable
c
)
{
for
(
Timeout
*
timeout
=
GetFirst
(
)
;
timeout
;
timeout
=
timeout
-
>
getNext
(
)
)
{
if
(
c
(
timeout
)
)
{
return
true
;
}
}
return
false
;
}
friend
class
OrderedTimeoutIterator
;
private
:
typedef
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
Timeout
>
TimeoutList
;
TimeoutList
mTimeoutList
;
mozilla
:
:
dom
:
:
Timeout
*
mTimeoutInsertionPoint
;
}
;
friend
class
OrderedTimeoutIterator
;
nsGlobalWindow
&
mWindow
;
Timeouts
mNormalTimeouts
;
Timeouts
mTrackingTimeouts
;
uint32_t
mTimeoutIdCounter
;
uint32_t
mNextFiringId
;
AutoTArray
<
uint32_t
2
>
mFiringIdStack
;
mozilla
:
:
dom
:
:
Timeout
*
mRunningTimeout
;
uint32_t
mIdleCallbackTimeoutCounter
;
int32_t
mBackPressureDelayMS
;
nsCOMPtr
<
nsITimer
>
mThrottleTrackingTimeoutsTimer
;
bool
mThrottleTrackingTimeouts
;
static
uint32_t
sNestingLevel
;
}
;
}
}
#
endif
