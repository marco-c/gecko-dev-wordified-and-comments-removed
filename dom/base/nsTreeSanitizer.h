#
ifndef
nsTreeSanitizer_h_
#
define
nsTreeSanitizer_h_
#
include
"
nsAtom
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsHashtablesFwd
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
mozilla
/
dom
/
SanitizerBinding
.
h
"
class
nsIContent
;
class
nsIGlobalObject
;
class
nsINode
;
namespace
mozilla
{
class
DeclarationBlock
;
enum
class
StyleSanitizationKind
:
uint8_t
;
}
namespace
mozilla
:
:
dom
{
class
DocumentFragment
;
class
Element
;
}
class
nsTreeSanitizer
{
public
:
explicit
nsTreeSanitizer
(
uint32_t
aFlags
=
0
)
;
static
void
InitializeStatics
(
)
;
static
void
ReleaseStatics
(
)
;
void
Sanitize
(
mozilla
:
:
dom
:
:
DocumentFragment
*
aFragment
)
;
void
Sanitize
(
mozilla
:
:
dom
:
:
Document
*
aDocument
)
;
void
WithWebSanitizerOptions
(
nsIGlobalObject
*
aGlobal
const
mozilla
:
:
dom
:
:
SanitizerConfig
&
aOptions
)
;
static
void
RemoveConditionalCSSFromSubtree
(
nsINode
*
aRoot
)
;
private
:
bool
mAllowStyles
;
bool
mAllowComments
;
bool
mDropNonCSSPresentation
;
bool
mDropForms
;
bool
mCidEmbedsOnly
;
bool
mDropMedia
;
bool
mFullDocument
;
bool
mLogRemovals
;
uint64_t
mInnerWindowID
=
0
;
class
AtomsTable
:
public
nsTHashSet
<
const
nsStaticAtom
*
>
{
public
:
explicit
AtomsTable
(
uint32_t
aLength
)
:
nsTHashSet
<
const
nsStaticAtom
*
>
(
aLength
)
{
}
bool
Contains
(
nsAtom
*
aAtom
)
{
return
aAtom
-
>
IsStatic
(
)
&
&
GetEntry
(
aAtom
-
>
AsStatic
(
)
)
;
}
}
;
class
ElementName
:
public
PLDHashEntryHdr
{
public
:
using
KeyType
=
const
ElementName
&
;
using
KeyTypePointer
=
const
ElementName
*
;
explicit
ElementName
(
KeyTypePointer
aKey
)
:
mNamespaceID
(
aKey
-
>
mNamespaceID
)
mLocalName
(
aKey
-
>
mLocalName
)
{
}
ElementName
(
int32_t
aNamespaceID
RefPtr
<
nsAtom
>
aLocalName
)
:
mNamespaceID
(
aNamespaceID
)
mLocalName
(
std
:
:
move
(
aLocalName
)
)
{
}
ElementName
(
ElementName
&
&
)
=
default
;
~
ElementName
(
)
=
default
;
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
mNamespaceID
=
=
aKey
-
>
mNamespaceID
&
&
mLocalName
=
=
aKey
-
>
mLocalName
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
if
(
!
aKey
)
{
return
0
;
}
return
mozilla
:
:
HashGeneric
(
aKey
-
>
mNamespaceID
aKey
-
>
mLocalName
.
get
(
)
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
private
:
int32_t
mNamespaceID
=
kNameSpaceID_None
;
RefPtr
<
nsAtom
>
mLocalName
;
}
;
using
ElementNameSet
=
nsTHashSet
<
ElementName
>
;
using
ElementToAttributeSetTable
=
nsTHashMap
<
RefPtr
<
nsAtom
>
mozilla
:
:
UniquePtr
<
ElementNameSet
>
>
;
void
SanitizeChildren
(
nsINode
*
aRoot
)
;
bool
MustFlatten
(
int32_t
aNamespace
nsAtom
*
aLocal
)
;
bool
MustFlattenForSanitizerAPI
(
int32_t
aNamespace
nsAtom
*
aLocal
)
;
bool
MustPrune
(
int32_t
aNamespace
nsAtom
*
aLocal
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
bool
MustPruneForSanitizerAPI
(
int32_t
aNamespace
nsAtom
*
aLocal
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
bool
IsURL
(
const
nsStaticAtom
*
const
*
aURLs
nsAtom
*
aLocalName
)
;
struct
AllowedAttributes
{
AtomsTable
*
mNames
=
nullptr
;
const
nsStaticAtom
*
const
*
mURLs
=
nullptr
;
bool
mXLink
=
false
;
bool
mStyle
=
false
;
bool
mDangerousSrc
=
false
;
}
;
void
SanitizeAttributes
(
mozilla
:
:
dom
:
:
Element
*
aElement
AllowedAttributes
aAllowed
)
;
bool
MustDropAttribute
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aAttrNamespace
nsAtom
*
aAttrLocalName
)
;
bool
MustDropFunkyAttribute
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aAttrNamespace
nsAtom
*
aAttrLocalName
)
;
bool
SanitizeURL
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNamespace
nsAtom
*
aLocalName
bool
aFragmentsOnly
=
false
)
;
bool
SanitizeStyleDeclaration
(
mozilla
:
:
DeclarationBlock
*
aDeclaration
)
;
static
bool
SanitizeInlineStyle
(
mozilla
:
:
dom
:
:
Element
*
mozilla
:
:
StyleSanitizationKind
)
;
static
void
RemoveAllAttributes
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
static
void
RemoveAllAttributesFromDescendants
(
mozilla
:
:
dom
:
:
Element
*
)
;
static
bool
MatchesElementName
(
ElementNameSet
&
aNames
int32_t
aNamespace
nsAtom
*
aLocalName
)
;
static
bool
MatchesAttributeMatchList
(
ElementToAttributeSetTable
&
aMatchList
mozilla
:
:
dom
:
:
Element
&
aElement
int32_t
aAttrNamespace
nsAtom
*
aAttrLocalName
)
;
static
mozilla
:
:
UniquePtr
<
ElementNameSet
>
ConvertElementNames
(
const
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
&
aNames
)
;
void
LogMessage
(
const
char
*
aMessage
mozilla
:
:
dom
:
:
Document
*
aDoc
mozilla
:
:
dom
:
:
Element
*
aElement
=
nullptr
nsAtom
*
aAttr
=
nullptr
)
;
static
AtomsTable
*
sElementsHTML
;
static
AtomsTable
*
sAttributesHTML
;
static
AtomsTable
*
sPresAttributesHTML
;
static
AtomsTable
*
sElementsSVG
;
static
AtomsTable
*
sAttributesSVG
;
static
AtomsTable
*
sElementsMathML
;
static
AtomsTable
*
sAttributesMathML
;
static
AtomsTable
*
sBaselineAttributeAllowlist
;
static
AtomsTable
*
sBaselineElementAllowlist
;
static
AtomsTable
*
sDefaultConfigurationAttributeAllowlist
;
static
AtomsTable
*
sDefaultConfigurationElementAllowlist
;
static
nsIPrincipal
*
sNullPrincipal
;
bool
mIsForSanitizerAPI
=
false
;
bool
mAllowCustomElements
=
false
;
bool
mAllowUnknownMarkup
=
false
;
mozilla
:
:
UniquePtr
<
ElementNameSet
>
mAllowElements
;
mozilla
:
:
UniquePtr
<
ElementNameSet
>
mBlockElements
;
mozilla
:
:
UniquePtr
<
ElementNameSet
>
mDropElements
;
mozilla
:
:
UniquePtr
<
ElementToAttributeSetTable
>
mAllowedAttributes
;
mozilla
:
:
UniquePtr
<
ElementToAttributeSetTable
>
mDroppedAttributes
;
}
;
#
endif
