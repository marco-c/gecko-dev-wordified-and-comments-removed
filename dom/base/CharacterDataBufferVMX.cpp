#
include
<
altivec
.
h
>
#
include
<
algorithm
>
#
include
"
CharacterDataBufferImpl
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
nscore
.
h
"
namespace
mozilla
{
namespace
VMX
{
int32_t
FirstNon8Bit
(
const
char16_t
*
str
const
char16_t
*
end
)
{
const
uint32_t
numUnicharsPerVector
=
8
;
const
uint32_t
numCharsPerVector
=
16
;
MOZ_ASSERT
(
(
numCharsPerVector
/
numUnicharsPerVector
)
=
=
sizeof
(
char16_t
)
)
;
typedef
Non8BitParameters
<
sizeof
(
size_t
)
>
p
;
const
uint32_t
alignMask
=
p
:
:
alignMask
(
)
;
const
size_t
mask
=
p
:
:
mask
(
)
;
const
uint32_t
numUnicharsPerWord
=
p
:
:
numUnicharsPerWord
(
)
;
const
uint32_t
len
=
end
-
str
;
uint32_t
i
=
0
;
uint32_t
i2
=
0
;
uint32_t
alignLen
=
std
:
:
min
(
len
uint32_t
(
(
(
-
NS_PTR_TO_UINT32
(
str
)
)
&
0xf
)
/
sizeof
(
char16_t
)
)
)
;
if
(
(
len
-
alignLen
)
>
=
numUnicharsPerVector
)
{
for
(
;
i
<
alignLen
;
i
+
+
)
{
if
(
str
[
i
]
>
255
)
return
i
;
}
#
if
__LITTLE_ENDIAN__
const
vector
unsigned
short
gtcompare
=
reinterpret_cast
<
vector
unsigned
short
>
(
vec_mergel
(
vec_splat_s8
(
-
1
)
vec_splat_s8
(
0
)
)
)
;
#
else
const
vector
unsigned
short
gtcompare
=
reinterpret_cast
<
vector
unsigned
short
>
(
vec_mergel
(
vec_splat_s8
(
0
)
vec_splat_s8
(
-
1
)
)
)
;
#
endif
const
uint32_t
vectWalkEnd
=
(
(
len
-
i
)
/
numUnicharsPerVector
)
*
numUnicharsPerVector
;
i2
=
i
*
sizeof
(
char16_t
)
;
while
(
1
)
{
vector
unsigned
short
vect
;
#
define
CheckForASCII
\
vect
=
vec_ld
(
i2
reinterpret_cast
<
const
unsigned
short
*
>
(
str
)
)
;
\
if
(
vec_any_gt
(
vect
gtcompare
)
)
return
i
;
\
i
+
=
numUnicharsPerVector
;
\
if
(
!
(
i
<
vectWalkEnd
)
)
break
;
\
i2
+
=
numCharsPerVector
;
CheckForASCII
CheckForASCII
#
undef
CheckForASCII
}
}
else
{
alignLen
=
std
:
:
min
(
len
uint32_t
(
(
(
-
NS_PTR_TO_UINT32
(
str
)
)
&
alignMask
)
/
sizeof
(
char16_t
)
)
)
;
for
(
;
i
<
alignLen
;
i
+
+
)
{
if
(
str
[
i
]
>
255
)
return
i
;
}
}
const
uint32_t
wordWalkEnd
=
(
(
len
-
i
)
/
numUnicharsPerWord
)
*
numUnicharsPerWord
;
for
(
;
i
<
wordWalkEnd
;
i
+
=
numUnicharsPerWord
)
{
const
size_t
word
=
*
reinterpret_cast
<
const
size_t
*
>
(
str
+
i
)
;
if
(
word
&
mask
)
return
i
;
}
for
(
;
i
<
len
;
i
+
+
)
{
if
(
str
[
i
]
>
255
)
{
return
i
;
}
}
return
-
1
;
}
}
}
