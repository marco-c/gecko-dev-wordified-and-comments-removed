#
ifndef
nsIdentifierMapEntry_h
#
define
nsIdentifierMapEntry_h
#
include
"
PLDHashTable
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsIAtom
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
class
nsIContent
;
class
nsIdentifierMapEntry
:
public
PLDHashEntryHdr
{
public
:
struct
AtomOrString
{
MOZ_IMPLICIT
AtomOrString
(
nsIAtom
*
aAtom
)
:
mAtom
(
aAtom
)
{
}
MOZ_IMPLICIT
AtomOrString
(
const
nsAString
&
aString
)
:
mString
(
aString
)
{
}
AtomOrString
(
const
AtomOrString
&
aOther
)
:
mAtom
(
aOther
.
mAtom
)
mString
(
aOther
.
mString
)
{
}
AtomOrString
(
AtomOrString
&
&
aOther
)
:
mAtom
(
aOther
.
mAtom
.
forget
(
)
)
mString
(
aOther
.
mString
)
{
}
RefPtr
<
nsIAtom
>
mAtom
;
const
nsString
mString
;
}
;
typedef
const
AtomOrString
&
KeyType
;
typedef
const
AtomOrString
*
KeyTypePointer
;
typedef
mozilla
:
:
dom
:
:
Element
Element
;
typedef
mozilla
:
:
net
:
:
ReferrerPolicy
ReferrerPolicy
;
explicit
nsIdentifierMapEntry
(
const
AtomOrString
&
aKey
)
:
mKey
(
aKey
)
{
}
explicit
nsIdentifierMapEntry
(
const
AtomOrString
*
aKey
)
:
mKey
(
aKey
?
*
aKey
:
nullptr
)
{
}
nsIdentifierMapEntry
(
nsIdentifierMapEntry
&
&
aOther
)
:
mKey
(
mozilla
:
:
Move
(
aOther
.
mKey
)
)
mIdContentList
(
mozilla
:
:
Move
(
aOther
.
mIdContentList
)
)
mNameContentList
(
aOther
.
mNameContentList
.
forget
(
)
)
mChangeCallbacks
(
aOther
.
mChangeCallbacks
.
forget
(
)
)
mImageElement
(
aOther
.
mImageElement
.
forget
(
)
)
{
}
~
nsIdentifierMapEntry
(
)
;
nsString
GetKeyAsString
(
)
const
{
if
(
mKey
.
mAtom
)
{
return
nsAtomString
(
mKey
.
mAtom
)
;
}
return
mKey
.
mString
;
}
bool
KeyEquals
(
const
KeyTypePointer
aOtherKey
)
const
{
if
(
mKey
.
mAtom
)
{
if
(
aOtherKey
-
>
mAtom
)
{
return
mKey
.
mAtom
=
=
aOtherKey
-
>
mAtom
;
}
return
mKey
.
mAtom
-
>
Equals
(
aOtherKey
-
>
mString
)
;
}
if
(
aOtherKey
-
>
mAtom
)
{
return
aOtherKey
-
>
mAtom
-
>
Equals
(
mKey
.
mString
)
;
}
return
mKey
.
mString
.
Equals
(
aOtherKey
-
>
mString
)
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
const
KeyTypePointer
aKey
)
{
return
aKey
-
>
mAtom
?
aKey
-
>
mAtom
-
>
hash
(
)
:
mozilla
:
:
HashString
(
aKey
-
>
mString
)
;
}
enum
{
ALLOW_MEMMOVE
=
false
}
;
void
AddNameElement
(
nsINode
*
aDocument
Element
*
aElement
)
;
void
RemoveNameElement
(
Element
*
aElement
)
;
bool
IsEmpty
(
)
;
nsBaseContentList
*
GetNameContentList
(
)
{
return
mNameContentList
;
}
bool
HasNameElement
(
)
const
{
return
mNameContentList
&
&
mNameContentList
-
>
Length
(
)
!
=
0
;
}
Element
*
GetIdElement
(
)
;
const
nsTArray
<
Element
*
>
&
GetIdElements
(
)
const
{
return
mIdContentList
;
}
Element
*
GetImageIdElement
(
)
;
void
AppendAllIdContent
(
nsCOMArray
<
nsIContent
>
*
aElements
)
;
bool
AddIdElement
(
Element
*
aElement
)
;
void
RemoveIdElement
(
Element
*
aElement
)
;
void
SetImageElement
(
Element
*
aElement
)
;
bool
HasIdElementExposedAsHTMLDocumentProperty
(
)
;
bool
HasContentChangeCallback
(
)
{
return
mChangeCallbacks
!
=
nullptr
;
}
void
AddContentChangeCallback
(
nsIDocument
:
:
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
;
void
RemoveContentChangeCallback
(
nsIDocument
:
:
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
;
struct
ChangeCallback
{
nsIDocument
:
:
IDTargetObserver
mCallback
;
void
*
mData
;
bool
mForImage
;
}
;
struct
ChangeCallbackEntry
:
public
PLDHashEntryHdr
{
typedef
const
ChangeCallback
KeyType
;
typedef
const
ChangeCallback
*
KeyTypePointer
;
explicit
ChangeCallbackEntry
(
const
ChangeCallback
*
aKey
)
:
mKey
(
*
aKey
)
{
}
ChangeCallbackEntry
(
const
ChangeCallbackEntry
&
toCopy
)
:
mKey
(
toCopy
.
mKey
)
{
}
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
aKey
-
>
mCallback
=
=
mKey
.
mCallback
&
&
aKey
-
>
mData
=
=
mKey
.
mData
&
&
aKey
-
>
mForImage
=
=
mKey
.
mForImage
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
&
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
return
mozilla
:
:
HashGeneric
(
aKey
-
>
mCallback
aKey
-
>
mData
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
ChangeCallback
mKey
;
}
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
private
:
nsIdentifierMapEntry
(
const
nsIdentifierMapEntry
&
aOther
)
=
delete
;
nsIdentifierMapEntry
&
operator
=
(
const
nsIdentifierMapEntry
&
aOther
)
=
delete
;
void
FireChangeCallbacks
(
Element
*
aOldElement
Element
*
aNewElement
bool
aImageOnly
=
false
)
;
AtomOrString
mKey
;
AutoTArray
<
Element
*
1
>
mIdContentList
;
RefPtr
<
nsBaseContentList
>
mNameContentList
;
nsAutoPtr
<
nsTHashtable
<
ChangeCallbackEntry
>
>
mChangeCallbacks
;
RefPtr
<
Element
>
mImageElement
;
}
;
#
endif
