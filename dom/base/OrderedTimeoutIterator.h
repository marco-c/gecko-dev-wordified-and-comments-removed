#
ifndef
mozilla_dom_OrderedTimeoutIterator_h__
#
define
mozilla_dom_OrderedTimeoutIterator_h__
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
Timeout
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
namespace
mozilla
{
namespace
dom
{
class
MOZ_STACK_CLASS
OrderedTimeoutIterator
final
{
public
:
typedef
TimeoutManager
:
:
Timeouts
Timeouts
;
typedef
Timeouts
:
:
TimeoutList
TimeoutList
;
OrderedTimeoutIterator
(
Timeouts
&
aNormalTimeouts
Timeouts
&
aTrackingTimeouts
Timeout
*
aNormalStopAt
Timeout
*
aTrackingStopAt
)
:
mNormalTimeouts
(
aNormalTimeouts
.
mTimeoutList
)
mTrackingTimeouts
(
aTrackingTimeouts
.
mTimeoutList
)
mNormalIter
(
mNormalTimeouts
.
getFirst
(
)
)
mTrackingIter
(
mTrackingTimeouts
.
getFirst
(
)
)
mNormalStopAt
(
aNormalStopAt
)
mTrackingStopAt
(
aTrackingStopAt
)
mKind
(
Kind
:
:
None
)
mUpdateIteratorCalled
(
true
)
{
}
Timeout
*
Next
(
)
{
MOZ_ASSERT
(
mUpdateIteratorCalled
)
;
MOZ_ASSERT_IF
(
mNormalIter
&
&
mNormalIter
!
=
mNormalStopAt
mNormalIter
-
>
isInList
(
)
)
;
MOZ_ASSERT_IF
(
mTrackingIter
&
&
mTrackingIter
!
=
mTrackingStopAt
mTrackingIter
-
>
isInList
(
)
)
;
mUpdateIteratorCalled
=
false
;
mKind
=
Kind
:
:
None
;
Timeout
*
timeout
=
nullptr
;
if
(
mNormalIter
=
=
mNormalStopAt
)
{
if
(
mTrackingIter
=
=
mTrackingStopAt
)
{
return
nullptr
;
}
else
{
timeout
=
mTrackingIter
;
mKind
=
Kind
:
:
Tracking
;
}
}
else
if
(
mTrackingIter
=
=
mTrackingStopAt
)
{
timeout
=
mNormalIter
;
mKind
=
Kind
:
:
Normal
;
}
else
{
if
(
mNormalIter
&
&
mTrackingIter
&
&
mNormalIter
!
=
mNormalStopAt
&
&
mTrackingIter
!
=
mTrackingStopAt
&
&
(
mTrackingIter
-
>
mWhen
<
mNormalIter
-
>
mWhen
|
|
(
mTrackingIter
-
>
mWhen
=
=
mNormalIter
-
>
mWhen
&
&
mTrackingIter
-
>
mTimeoutId
<
mNormalIter
-
>
mTimeoutId
)
)
)
{
timeout
=
mTrackingIter
;
mKind
=
Kind
:
:
Tracking
;
}
else
if
(
mNormalIter
&
&
mNormalIter
!
=
mNormalStopAt
)
{
timeout
=
mNormalIter
;
mKind
=
Kind
:
:
Normal
;
}
else
if
(
mTrackingIter
&
&
mTrackingIter
!
=
mTrackingStopAt
)
{
timeout
=
mTrackingIter
;
mKind
=
Kind
:
:
Tracking
;
}
}
if
(
!
timeout
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mKind
!
=
Kind
:
:
None
)
;
mCurrent
=
timeout
;
MOZ_ASSERT
(
mCurrent
)
;
return
mCurrent
;
}
void
UpdateIterator
(
)
{
MOZ_ASSERT
(
mKind
!
=
Kind
:
:
None
)
;
if
(
mKind
=
=
Kind
:
:
Normal
)
{
mNormalIter
=
mCurrent
-
>
getNext
(
)
;
if
(
mTrackingIter
&
&
mTrackingIter
!
=
mTrackingStopAt
&
&
!
mTrackingIter
-
>
isInList
(
)
)
{
mTrackingIter
=
mTrackingTimeouts
.
getFirst
(
)
;
}
}
else
{
mTrackingIter
=
mCurrent
-
>
getNext
(
)
;
if
(
mNormalIter
&
&
mNormalIter
!
=
mNormalStopAt
&
&
!
mNormalIter
-
>
isInList
(
)
)
{
mNormalIter
=
mNormalTimeouts
.
getFirst
(
)
;
}
}
mUpdateIteratorCalled
=
true
;
}
void
Clear
(
)
{
mNormalIter
=
nullptr
;
mTrackingIter
=
nullptr
;
mCurrent
=
nullptr
;
mKind
=
Kind
:
:
None
;
mUpdateIteratorCalled
=
true
;
}
bool
PickedNormalIter
(
)
const
{
MOZ_ASSERT
(
mKind
!
=
Kind
:
:
None
)
;
return
mKind
=
=
Kind
:
:
Normal
;
}
bool
PickedTrackingIter
(
)
const
{
MOZ_ASSERT
(
mKind
!
=
Kind
:
:
None
)
;
return
mKind
=
=
Kind
:
:
Tracking
;
}
private
:
TimeoutList
&
mNormalTimeouts
;
TimeoutList
&
mTrackingTimeouts
;
RefPtr
<
Timeout
>
mNormalIter
;
RefPtr
<
Timeout
>
mTrackingIter
;
void
*
mNormalStopAt
;
void
*
mTrackingStopAt
;
RefPtr
<
Timeout
>
mCurrent
;
enum
class
Kind
{
Normal
Tracking
None
}
;
Kind
mKind
;
DebugOnly
<
bool
>
mUpdateIteratorCalled
;
}
;
}
}
#
endif
