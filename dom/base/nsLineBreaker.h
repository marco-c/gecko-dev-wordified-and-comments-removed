#
ifndef
NSLINEBREAKER_H_
#
define
NSLINEBREAKER_H_
#
include
"
mozilla
/
intl
/
LineBreaker
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
class
nsAtom
;
class
nsHyphenator
;
class
nsILineBreakSink
{
public
:
virtual
void
SetBreaks
(
uint32_t
aStart
uint32_t
aLength
uint8_t
*
aBreakBefore
)
=
0
;
virtual
void
SetCapitalization
(
uint32_t
aStart
uint32_t
aLength
bool
*
aCapitalize
)
=
0
;
}
;
class
nsLineBreaker
{
public
:
nsLineBreaker
(
)
;
~
nsLineBreaker
(
)
;
static
inline
bool
IsSpace
(
char16_t
u
)
{
return
mozilla
:
:
intl
:
:
NS_IsSpace
(
u
)
;
}
static
inline
bool
IsComplexASCIIChar
(
char16_t
u
)
{
return
!
(
(
0x0030
<
=
u
&
&
u
<
=
0x0039
)
|
|
(
0x0041
<
=
u
&
&
u
<
=
0x005A
)
|
|
(
0x0061
<
=
u
&
&
u
<
=
0x007A
)
|
|
(
0x000a
=
=
u
)
)
;
}
static
inline
bool
IsComplexChar
(
char16_t
u
)
{
return
IsComplexASCIIChar
(
u
)
|
|
mozilla
:
:
intl
:
:
NS_NeedsPlatformNativeHandling
(
u
)
|
|
(
0x1100
<
=
u
&
&
u
<
=
0x11ff
)
|
|
(
0x2000
<
=
u
&
&
u
<
=
0x21ff
)
|
|
(
0x2e80
<
=
u
&
&
u
<
=
0xd7ff
)
|
|
(
0xf900
<
=
u
&
&
u
<
=
0xfaff
)
|
|
(
0xff00
<
=
u
&
&
u
<
=
0xffef
)
;
}
enum
{
BREAK_SUPPRESS_INITIAL
=
0x01
BREAK_SUPPRESS_INSIDE
=
0x02
BREAK_SKIP_SETTING_NO_BREAKS
=
0x04
BREAK_NEED_CAPITALIZATION
=
0x08
BREAK_USE_AUTO_HYPHENATION
=
0x10
}
;
nsresult
AppendInvisibleWhitespace
(
uint32_t
aFlags
)
;
nsresult
AppendText
(
nsAtom
*
aHyphenationLanguage
const
char16_t
*
aText
uint32_t
aLength
uint32_t
aFlags
nsILineBreakSink
*
aSink
)
;
nsresult
AppendText
(
nsAtom
*
aHyphenationLanguage
const
uint8_t
*
aText
uint32_t
aLength
uint32_t
aFlags
nsILineBreakSink
*
aSink
)
;
nsresult
Reset
(
bool
*
aTrailingBreak
)
;
void
SetWordBreak
(
mozilla
:
:
intl
:
:
WordBreakRule
aMode
)
{
if
(
aMode
!
=
mWordBreak
&
&
!
mCurrentWord
.
IsEmpty
(
)
)
{
nsresult
rv
=
FlushCurrentWord
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
FlushCurrentWord
failed
line
-
breaks
may
be
wrong
"
)
;
}
if
(
mWordBreak
=
=
mozilla
:
:
intl
:
:
WordBreakRule
:
:
BreakAll
)
{
mBreakHere
=
true
;
}
}
mWordBreak
=
aMode
;
}
void
SetStrictness
(
mozilla
:
:
intl
:
:
LineBreaker
:
:
Strictness
aMode
)
{
if
(
aMode
!
=
mStrictness
&
&
!
mCurrentWord
.
IsEmpty
(
)
)
{
nsresult
rv
=
FlushCurrentWord
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
FlushCurrentWord
failed
line
-
breaks
may
be
wrong
"
)
;
}
if
(
mStrictness
=
=
mozilla
:
:
intl
:
:
LineBreaker
:
:
Strictness
:
:
Anywhere
)
{
mBreakHere
=
true
;
}
}
mStrictness
=
aMode
;
}
bool
InWord
(
)
const
{
return
!
mCurrentWord
.
IsEmpty
(
)
;
}
void
SetWordContinuation
(
bool
aContinuation
)
{
mWordContinuation
=
aContinuation
;
}
private
:
struct
TextItem
{
TextItem
(
nsILineBreakSink
*
aSink
uint32_t
aSinkOffset
uint32_t
aLength
uint32_t
aFlags
)
:
mSink
(
aSink
)
mSinkOffset
(
aSinkOffset
)
mLength
(
aLength
)
mFlags
(
aFlags
)
{
}
nsILineBreakSink
*
mSink
;
uint32_t
mSinkOffset
;
uint32_t
mLength
;
uint32_t
mFlags
;
}
;
nsresult
FlushCurrentWord
(
)
;
void
UpdateCurrentWordLanguage
(
nsAtom
*
aHyphenationLanguage
)
;
void
FindHyphenationPoints
(
nsHyphenator
*
aHyphenator
const
char16_t
*
aTextStart
const
char16_t
*
aTextLimit
uint8_t
*
aBreakState
)
;
AutoTArray
<
char16_t
100
>
mCurrentWord
;
AutoTArray
<
TextItem
2
>
mTextItems
;
nsAtom
*
mCurrentWordLanguage
;
bool
mCurrentWordContainsMixedLang
;
bool
mCurrentWordContainsComplexChar
;
bool
mScriptIsChineseOrJapanese
;
bool
mAfterBreakableSpace
;
bool
mBreakHere
;
mozilla
:
:
intl
:
:
WordBreakRule
mWordBreak
;
mozilla
:
:
intl
:
:
LineBreaker
:
:
Strictness
mStrictness
;
bool
mWordContinuation
;
}
;
#
endif
