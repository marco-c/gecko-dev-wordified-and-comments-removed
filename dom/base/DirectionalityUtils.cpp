#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsCheapSets
.
h
"
namespace
mozilla
{
using
mozilla
:
:
dom
:
:
Element
;
static
bool
DoesNotParticipateInAutoDirection
(
const
Element
*
aElement
)
{
mozilla
:
:
dom
:
:
NodeInfo
*
nodeInfo
=
aElement
-
>
NodeInfo
(
)
;
return
(
!
aElement
-
>
IsHTMLElement
(
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
script
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
style
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
textarea
)
|
|
aElement
-
>
IsInAnonymousSubtree
(
)
)
;
}
static
bool
DoesNotAffectDirectionOfAncestors
(
const
Element
*
aElement
)
{
return
(
DoesNotParticipateInAutoDirection
(
aElement
)
|
|
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
|
|
aElement
-
>
HasFixedDir
(
)
)
;
}
static
Directionality
GetDirectionFromChar
(
uint32_t
ch
)
{
switch
(
mozilla
:
:
unicode
:
:
GetBidiCat
(
ch
)
)
{
case
eCharType_RightToLeft
:
case
eCharType_RightToLeftArabic
:
return
eDir_RTL
;
case
eCharType_LeftToRight
:
return
eDir_LTR
;
default
:
return
eDir_NotSet
;
}
}
inline
static
bool
NodeAffectsDirAutoAncestor
(
nsINode
*
aTextNode
)
{
Element
*
parent
=
aTextNode
-
>
GetParentElement
(
)
;
return
(
parent
&
&
!
DoesNotParticipateInAutoDirection
(
parent
)
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
&
&
!
aTextNode
-
>
IsInAnonymousSubtree
(
)
)
;
}
Directionality
GetDirectionFromText
(
const
char16_t
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
)
{
const
char16_t
*
start
=
aText
;
const
char16_t
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
uint32_t
ch
=
*
start
+
+
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
start
<
end
&
&
NS_IS_LOW_SURROGATE
(
*
start
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
start
+
+
)
;
current
+
+
;
}
if
(
!
IS_SURROGATE
(
ch
)
)
{
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
eDir_NotSet
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
eDir_NotSet
;
}
static
Directionality
GetDirectionFromText
(
const
char
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
=
nullptr
)
{
const
char
*
start
=
aText
;
const
char
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
unsigned
char
ch
=
(
unsigned
char
)
*
start
+
+
;
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
eDir_NotSet
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
eDir_NotSet
;
}
static
Directionality
GetDirectionFromText
(
const
nsTextFragment
*
aFrag
uint32_t
*
aFirstStrong
=
nullptr
)
{
if
(
aFrag
-
>
Is2b
(
)
)
{
return
GetDirectionFromText
(
aFrag
-
>
Get2b
(
)
aFrag
-
>
GetLength
(
)
aFirstStrong
)
;
}
return
GetDirectionFromText
(
aFrag
-
>
Get1b
(
)
aFrag
-
>
GetLength
(
)
aFirstStrong
)
;
}
static
nsTextNode
*
WalkDescendantsSetDirectionFromText
(
Element
*
aElement
bool
aNotify
=
true
nsINode
*
aChangedNode
=
nullptr
)
{
MOZ_ASSERT
(
aElement
"
Must
have
an
element
"
)
;
MOZ_ASSERT
(
aElement
-
>
HasDirAuto
(
)
"
Element
must
have
dir
=
auto
"
)
;
if
(
DoesNotParticipateInAutoDirection
(
aElement
)
)
{
return
nullptr
;
}
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
DoesNotAffectDirectionOfAncestors
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aElement
)
;
continue
;
}
if
(
child
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
&
&
child
!
=
aChangedNode
)
{
Directionality
textNodeDir
=
GetDirectionFromText
(
child
-
>
GetText
(
)
)
;
if
(
textNodeDir
!
=
eDir_NotSet
)
{
aElement
-
>
SetDirectionality
(
textNodeDir
aNotify
)
;
return
static_cast
<
nsTextNode
*
>
(
child
)
;
}
}
child
=
child
-
>
GetNextNode
(
aElement
)
;
}
aElement
-
>
SetDirectionality
(
eDir_LTR
aNotify
)
;
return
nullptr
;
}
class
nsTextNodeDirectionalityMap
{
static
void
nsTextNodeDirectionalityMapDtor
(
void
*
aObject
nsAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
{
nsINode
*
textNode
=
static_cast
<
nsINode
*
>
(
aObject
)
;
textNode
-
>
ClearHasTextNodeDirectionalityMap
(
)
;
nsTextNodeDirectionalityMap
*
map
=
reinterpret_cast
<
nsTextNodeDirectionalityMap
*
>
(
aPropertyValue
)
;
map
-
>
EnsureMapIsClear
(
)
;
delete
map
;
}
public
:
explicit
nsTextNodeDirectionalityMap
(
nsINode
*
aTextNode
)
:
mElementToBeRemoved
(
nullptr
)
{
MOZ_ASSERT
(
aTextNode
"
Null
text
node
"
)
;
MOZ_COUNT_CTOR
(
nsTextNodeDirectionalityMap
)
;
aTextNode
-
>
SetProperty
(
nsGkAtoms
:
:
textNodeDirectionalityMap
this
nsTextNodeDirectionalityMapDtor
)
;
aTextNode
-
>
SetHasTextNodeDirectionalityMap
(
)
;
}
~
nsTextNodeDirectionalityMap
(
)
{
MOZ_COUNT_DTOR
(
nsTextNodeDirectionalityMap
)
;
}
static
void
nsTextNodeDirectionalityMapPropertyDestructor
(
void
*
aObject
nsAtom
*
aProperty
void
*
aPropertyValue
void
*
aData
)
{
nsTextNode
*
textNode
=
static_cast
<
nsTextNode
*
>
(
aPropertyValue
)
;
nsTextNodeDirectionalityMap
*
map
=
GetDirectionalityMap
(
textNode
)
;
if
(
map
)
{
map
-
>
RemoveEntryForProperty
(
static_cast
<
Element
*
>
(
aObject
)
)
;
}
NS_RELEASE
(
textNode
)
;
}
void
AddEntry
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
if
(
!
mElements
.
Contains
(
aElement
)
)
{
mElements
.
Put
(
aElement
)
;
NS_ADDREF
(
aTextNode
)
;
aElement
-
>
SetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
aTextNode
nsTextNodeDirectionalityMapPropertyDestructor
)
;
aElement
-
>
SetHasDirAutoSet
(
)
;
}
}
void
RemoveEntry
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
NS_ASSERTION
(
mElements
.
Contains
(
aElement
)
"
element
already
removed
from
map
"
)
;
mElements
.
Remove
(
aElement
)
;
aElement
-
>
ClearHasDirAutoSet
(
)
;
aElement
-
>
DeleteProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
;
}
void
RemoveEntryForProperty
(
Element
*
aElement
)
{
if
(
mElementToBeRemoved
!
=
aElement
)
{
mElements
.
Remove
(
aElement
)
;
}
aElement
-
>
ClearHasDirAutoSet
(
)
;
}
private
:
nsCheapSet
<
nsPtrHashKey
<
Element
>
>
mElements
;
Element
*
mElementToBeRemoved
;
static
nsTextNodeDirectionalityMap
*
GetDirectionalityMap
(
nsINode
*
aTextNode
)
{
MOZ_ASSERT
(
aTextNode
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
"
Must
be
a
text
node
"
)
;
nsTextNodeDirectionalityMap
*
map
=
nullptr
;
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
map
=
static_cast
<
nsTextNodeDirectionalityMap
*
>
(
aTextNode
-
>
GetProperty
(
nsGkAtoms
:
:
textNodeDirectionalityMap
)
)
;
}
return
map
;
}
static
nsCheapSetOperator
SetNodeDirection
(
nsPtrHashKey
<
Element
>
*
aEntry
void
*
aDir
)
{
MOZ_ASSERT
(
aEntry
-
>
GetKey
(
)
-
>
IsElement
(
)
"
Must
be
an
Element
"
)
;
aEntry
-
>
GetKey
(
)
-
>
SetDirectionality
(
*
reinterpret_cast
<
Directionality
*
>
(
aDir
)
true
)
;
return
OpNext
;
}
struct
nsTextNodeDirectionalityMapAndElement
{
nsTextNodeDirectionalityMap
*
mMap
;
nsCOMPtr
<
nsINode
>
mNode
;
}
;
static
nsCheapSetOperator
ResetNodeDirection
(
nsPtrHashKey
<
Element
>
*
aEntry
void
*
aData
)
{
MOZ_ASSERT
(
aEntry
-
>
GetKey
(
)
-
>
IsElement
(
)
"
Must
be
an
Element
"
)
;
nsTextNodeDirectionalityMapAndElement
*
data
=
static_cast
<
nsTextNodeDirectionalityMapAndElement
*
>
(
aData
)
;
nsINode
*
oldTextNode
=
data
-
>
mNode
;
Element
*
rootNode
=
aEntry
-
>
GetKey
(
)
;
nsTextNode
*
newTextNode
=
nullptr
;
if
(
rootNode
-
>
GetParentNode
(
)
&
&
rootNode
-
>
HasDirAuto
(
)
)
{
newTextNode
=
WalkDescendantsSetDirectionFromText
(
rootNode
true
oldTextNode
)
;
}
AutoRestore
<
Element
*
>
restore
(
data
-
>
mMap
-
>
mElementToBeRemoved
)
;
data
-
>
mMap
-
>
mElementToBeRemoved
=
rootNode
;
if
(
newTextNode
)
{
nsINode
*
oldDirAutoSetBy
=
static_cast
<
nsTextNode
*
>
(
rootNode
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
if
(
oldDirAutoSetBy
=
=
newTextNode
)
{
return
OpNext
;
}
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
newTextNode
rootNode
)
;
}
else
{
rootNode
-
>
ClearHasDirAutoSet
(
)
;
rootNode
-
>
DeleteProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
;
}
return
OpRemove
;
}
static
nsCheapSetOperator
TakeEntries
(
nsPtrHashKey
<
Element
>
*
aEntry
void
*
aData
)
{
AutoTArray
<
Element
*
8
>
*
entries
=
static_cast
<
AutoTArray
<
Element
*
8
>
*
>
(
aData
)
;
entries
-
>
AppendElement
(
aEntry
-
>
GetKey
(
)
)
;
return
OpRemove
;
}
public
:
uint32_t
UpdateAutoDirection
(
Directionality
aDir
)
{
return
mElements
.
EnumerateEntries
(
SetNodeDirection
&
aDir
)
;
}
void
ResetAutoDirection
(
nsINode
*
aTextNode
)
{
nsTextNodeDirectionalityMapAndElement
data
=
{
this
aTextNode
}
;
mElements
.
EnumerateEntries
(
ResetNodeDirection
&
data
)
;
}
void
EnsureMapIsClear
(
)
{
AutoRestore
<
Element
*
>
restore
(
mElementToBeRemoved
)
;
AutoTArray
<
Element
*
8
>
entries
;
mElements
.
EnumerateEntries
(
TakeEntries
&
entries
)
;
for
(
Element
*
el
:
entries
)
{
el
-
>
ClearHasDirAutoSet
(
)
;
el
-
>
DeleteProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
;
}
}
static
void
RemoveElementFromMap
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
GetDirectionalityMap
(
aTextNode
)
-
>
RemoveEntry
(
aTextNode
aElement
)
;
}
}
static
void
AddEntryToMap
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
nsTextNodeDirectionalityMap
*
map
=
GetDirectionalityMap
(
aTextNode
)
;
if
(
!
map
)
{
map
=
new
nsTextNodeDirectionalityMap
(
aTextNode
)
;
}
map
-
>
AddEntry
(
aTextNode
aElement
)
;
}
static
uint32_t
UpdateTextNodeDirection
(
nsINode
*
aTextNode
Directionality
aDir
)
{
MOZ_ASSERT
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
"
Map
missing
in
UpdateTextNodeDirection
"
)
;
return
GetDirectionalityMap
(
aTextNode
)
-
>
UpdateAutoDirection
(
aDir
)
;
}
static
void
ResetTextNodeDirection
(
nsTextNode
*
aTextNode
nsTextNode
*
aChangedTextNode
)
{
MOZ_ASSERT
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
"
Map
missing
in
ResetTextNodeDirection
"
)
;
RefPtr
<
nsTextNode
>
textNode
=
aTextNode
;
GetDirectionalityMap
(
textNode
)
-
>
ResetAutoDirection
(
aChangedTextNode
)
;
}
static
void
EnsureMapIsClearFor
(
nsINode
*
aTextNode
)
{
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
GetDirectionalityMap
(
aTextNode
)
-
>
EnsureMapIsClear
(
)
;
}
}
}
;
Directionality
RecomputeDirectionality
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
!
aElement
-
>
HasDirAuto
(
)
"
RecomputeDirectionality
called
with
dir
=
auto
"
)
;
Directionality
dir
=
eDir_LTR
;
if
(
aElement
-
>
HasValidDir
(
)
)
{
dir
=
aElement
-
>
GetDirectionality
(
)
;
}
else
{
Element
*
parent
=
aElement
-
>
GetParentElement
(
)
;
if
(
parent
)
{
Directionality
parentDir
=
parent
-
>
GetDirectionality
(
)
;
if
(
parentDir
!
=
eDir_NotSet
)
{
dir
=
parentDir
;
}
}
else
{
dir
=
eDir_LTR
;
}
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
}
return
dir
;
}
void
SetDirectionalityOnDescendants
(
Element
*
aElement
Directionality
aDir
bool
aNotify
)
{
for
(
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
child
;
)
{
if
(
!
child
-
>
IsElement
(
)
)
{
child
=
child
-
>
GetNextNode
(
aElement
)
;
continue
;
}
Element
*
element
=
child
-
>
AsElement
(
)
;
if
(
element
-
>
HasValidDir
(
)
|
|
element
-
>
HasDirAuto
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aElement
)
;
continue
;
}
element
-
>
SetDirectionality
(
aDir
aNotify
)
;
child
=
child
-
>
GetNextNode
(
aElement
)
;
}
}
void
WalkAncestorsResetAutoDirection
(
Element
*
aElement
bool
aNotify
)
{
nsTextNode
*
setByNode
;
Element
*
parent
=
aElement
-
>
GetParentElement
(
)
;
while
(
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
if
(
parent
-
>
HasDirAutoSet
(
)
)
{
setByNode
=
static_cast
<
nsTextNode
*
>
(
parent
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
if
(
setByNode
)
{
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
setByNode
parent
)
;
}
}
if
(
parent
-
>
HasDirAuto
(
)
)
{
setByNode
=
WalkDescendantsSetDirectionFromText
(
parent
aNotify
)
;
if
(
setByNode
)
{
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
setByNode
parent
)
;
}
break
;
}
parent
=
parent
-
>
GetParentElement
(
)
;
}
}
void
WalkDescendantsResetAutoDirection
(
Element
*
aElement
)
{
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
child
-
>
AsElement
(
)
-
>
HasDirAuto
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aElement
)
;
continue
;
}
if
(
child
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
&
&
child
-
>
HasTextNodeDirectionalityMap
(
)
)
{
nsTextNodeDirectionalityMap
:
:
ResetTextNodeDirection
(
static_cast
<
nsTextNode
*
>
(
child
)
nullptr
)
;
}
child
=
child
-
>
GetNextNode
(
aElement
)
;
}
}
void
WalkDescendantsSetDirAuto
(
Element
*
aElement
bool
aNotify
)
{
if
(
!
DoesNotParticipateInAutoDirection
(
aElement
)
)
{
bool
setAncestorDirAutoFlag
=
#
ifdef
DEBUG
true
;
#
else
!
aElement
-
>
AncestorHasDirAuto
(
)
;
#
endif
if
(
setAncestorDirAutoFlag
)
{
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
DoesNotAffectDirectionOfAncestors
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aElement
)
;
continue
;
}
MOZ_ASSERT
(
!
aElement
-
>
AncestorHasDirAuto
(
)
|
|
child
-
>
AncestorHasDirAuto
(
)
"
AncestorHasDirAuto
set
on
node
but
not
its
children
"
)
;
child
-
>
SetAncestorHasDirAuto
(
)
;
child
=
child
-
>
GetNextNode
(
aElement
)
;
}
}
}
nsTextNode
*
textNode
=
WalkDescendantsSetDirectionFromText
(
aElement
aNotify
)
;
if
(
textNode
)
{
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
textNode
aElement
)
;
}
}
void
WalkDescendantsClearAncestorDirAuto
(
Element
*
aElement
)
{
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
child
-
>
AsElement
(
)
-
>
HasDirAuto
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aElement
)
;
continue
;
}
child
-
>
ClearAncestorHasDirAuto
(
)
;
child
=
child
-
>
GetNextNode
(
aElement
)
;
}
}
void
SetAncestorDirectionIfAuto
(
nsTextNode
*
aTextNode
Directionality
aDir
bool
aNotify
=
true
)
{
MOZ_ASSERT
(
aTextNode
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
"
Must
be
a
text
node
"
)
;
Element
*
parent
=
aTextNode
-
>
GetParentElement
(
)
;
while
(
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
if
(
DoesNotParticipateInAutoDirection
(
parent
)
|
|
parent
-
>
HasFixedDir
(
)
)
{
break
;
}
if
(
parent
-
>
HasDirAuto
(
)
)
{
bool
resetDirection
=
false
;
nsTextNode
*
directionWasSetByTextNode
=
static_cast
<
nsTextNode
*
>
(
parent
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
if
(
!
parent
-
>
HasDirAutoSet
(
)
)
{
MOZ_ASSERT
(
!
directionWasSetByTextNode
"
dirAutoSetBy
property
should
be
null
"
)
;
resetDirection
=
true
;
}
else
{
if
(
!
directionWasSetByTextNode
)
{
resetDirection
=
true
;
}
else
if
(
directionWasSetByTextNode
!
=
aTextNode
)
{
nsIContent
*
child
=
aTextNode
-
>
GetNextNode
(
parent
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
DoesNotAffectDirectionOfAncestors
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
parent
)
;
continue
;
}
if
(
child
=
=
directionWasSetByTextNode
)
{
resetDirection
=
true
;
break
;
}
child
=
child
-
>
GetNextNode
(
parent
)
;
}
}
}
if
(
resetDirection
)
{
if
(
directionWasSetByTextNode
)
{
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
directionWasSetByTextNode
parent
)
;
}
parent
-
>
SetDirectionality
(
aDir
aNotify
)
;
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
aTextNode
parent
)
;
SetDirectionalityOnDescendants
(
parent
aDir
aNotify
)
;
}
return
;
}
parent
=
parent
-
>
GetParentElement
(
)
;
}
}
bool
TextNodeWillChangeDirection
(
nsIContent
*
aTextNode
Directionality
*
aOldDir
uint32_t
aOffset
)
{
if
(
!
NodeAffectsDirAutoAncestor
(
aTextNode
)
)
{
nsTextNodeDirectionalityMap
:
:
EnsureMapIsClearFor
(
aTextNode
)
;
return
false
;
}
uint32_t
firstStrong
;
*
aOldDir
=
GetDirectionFromText
(
aTextNode
-
>
GetText
(
)
&
firstStrong
)
;
return
(
aOffset
<
=
firstStrong
)
;
}
void
TextNodeChangedDirection
(
nsTextNode
*
aTextNode
Directionality
aOldDir
bool
aNotify
)
{
Directionality
newDir
=
GetDirectionFromText
(
aTextNode
-
>
GetText
(
)
)
;
if
(
newDir
=
=
eDir_NotSet
)
{
if
(
aOldDir
!
=
eDir_NotSet
&
&
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
nsTextNodeDirectionalityMap
:
:
ResetTextNodeDirection
(
aTextNode
aTextNode
)
;
}
}
else
{
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
&
&
nsTextNodeDirectionalityMap
:
:
UpdateTextNodeDirection
(
aTextNode
newDir
)
)
{
return
;
}
SetAncestorDirectionIfAuto
(
aTextNode
newDir
aNotify
)
;
}
}
void
SetDirectionFromNewTextNode
(
nsTextNode
*
aTextNode
)
{
if
(
!
NodeAffectsDirAutoAncestor
(
aTextNode
)
)
{
return
;
}
Element
*
parent
=
aTextNode
-
>
GetParentElement
(
)
;
if
(
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aTextNode
-
>
SetAncestorHasDirAuto
(
)
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
-
>
GetText
(
)
)
;
if
(
dir
!
=
eDir_NotSet
)
{
SetAncestorDirectionIfAuto
(
aTextNode
dir
)
;
}
}
void
ResetDirectionSetByTextNode
(
nsTextNode
*
aTextNode
)
{
if
(
!
NodeAffectsDirAutoAncestor
(
aTextNode
)
)
{
nsTextNodeDirectionalityMap
:
:
EnsureMapIsClearFor
(
aTextNode
)
;
return
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
-
>
GetText
(
)
)
;
if
(
dir
!
=
eDir_NotSet
&
&
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
nsTextNodeDirectionalityMap
:
:
ResetTextNodeDirection
(
aTextNode
aTextNode
)
;
}
}
void
SetDirectionalityFromValue
(
Element
*
aElement
const
nsAString
&
value
bool
aNotify
)
{
Directionality
dir
=
GetDirectionFromText
(
PromiseFlatString
(
value
)
.
get
(
)
value
.
Length
(
)
)
;
if
(
dir
=
=
eDir_NotSet
)
{
dir
=
eDir_LTR
;
}
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
}
void
OnSetDirAttr
(
Element
*
aElement
const
nsAttrValue
*
aNewValue
bool
hadValidDir
bool
hadDirAuto
bool
aNotify
)
{
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
return
;
}
if
(
aElement
-
>
AncestorHasDirAuto
(
)
)
{
if
(
!
hadValidDir
)
{
WalkDescendantsResetAutoDirection
(
aElement
)
;
}
else
if
(
!
aElement
-
>
HasValidDir
(
)
)
{
WalkAncestorsResetAutoDirection
(
aElement
aNotify
)
;
}
}
else
if
(
hadDirAuto
&
&
!
aElement
-
>
HasDirAuto
(
)
)
{
WalkDescendantsClearAncestorDirAuto
(
aElement
)
;
}
if
(
aElement
-
>
HasDirAuto
(
)
)
{
WalkDescendantsSetDirAuto
(
aElement
aNotify
)
;
}
else
{
if
(
aElement
-
>
HasDirAutoSet
(
)
)
{
nsTextNode
*
setByNode
=
static_cast
<
nsTextNode
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
setByNode
aElement
)
;
}
SetDirectionalityOnDescendants
(
aElement
RecomputeDirectionality
(
aElement
aNotify
)
aNotify
)
;
}
}
void
SetDirOnBind
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsIContent
*
aParent
)
{
if
(
!
DoesNotParticipateInAutoDirection
(
aElement
)
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
&
&
aParent
&
&
aParent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aElement
-
>
SetAncestorHasDirAuto
(
)
;
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
if
(
child
)
{
do
{
if
(
child
-
>
IsElement
(
)
&
&
DoesNotAffectDirectionOfAncestors
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aElement
)
;
continue
;
}
child
-
>
SetAncestorHasDirAuto
(
)
;
child
=
child
-
>
GetNextNode
(
aElement
)
;
}
while
(
child
)
;
WalkAncestorsResetAutoDirection
(
aElement
true
)
;
}
}
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
RecomputeDirectionality
(
aElement
false
)
;
}
}
void
ResetDir
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
{
if
(
aElement
-
>
HasDirAutoSet
(
)
)
{
nsTextNode
*
setByNode
=
static_cast
<
nsTextNode
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
setByNode
aElement
)
;
}
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
RecomputeDirectionality
(
aElement
false
)
;
}
}
}
