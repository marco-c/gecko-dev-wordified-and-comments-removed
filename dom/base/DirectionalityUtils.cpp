#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
intl
/
UnicodeProperties
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsCheapSets
.
h
"
namespace
mozilla
{
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
HTMLInputElement
;
using
mozilla
:
:
dom
:
:
HTMLSlotElement
;
using
mozilla
:
:
dom
:
:
ShadowRoot
;
static
nsIContent
*
GetParentOrHostOrSlot
(
const
nsIContent
*
aContent
bool
*
aCrossedShadowBoundary
=
nullptr
)
{
if
(
HTMLSlotElement
*
slot
=
aContent
-
>
GetAssignedSlot
(
)
)
{
if
(
aCrossedShadowBoundary
)
{
*
aCrossedShadowBoundary
=
true
;
}
return
slot
;
}
nsIContent
*
parent
=
aContent
-
>
GetParent
(
)
;
if
(
parent
)
{
return
parent
;
}
const
ShadowRoot
*
sr
=
ShadowRoot
:
:
FromNode
(
aContent
)
;
if
(
sr
)
{
if
(
aCrossedShadowBoundary
)
{
*
aCrossedShadowBoundary
=
true
;
}
return
sr
-
>
Host
(
)
;
}
return
nullptr
;
}
static
bool
AncestorChainCrossesShadowBoundary
(
nsIContent
*
aDescendant
nsIContent
*
aAncestor
)
{
bool
crossedShadowBoundary
=
false
;
nsIContent
*
content
=
aDescendant
;
while
(
content
&
&
content
!
=
aAncestor
)
{
content
=
GetParentOrHostOrSlot
(
content
&
crossedShadowBoundary
)
;
if
(
crossedShadowBoundary
)
{
return
true
;
}
}
return
false
;
}
static
bool
DoesNotParticipateInAutoDirection
(
const
nsIContent
*
aContent
)
{
mozilla
:
:
dom
:
:
NodeInfo
*
nodeInfo
=
aContent
-
>
NodeInfo
(
)
;
return
(
(
!
aContent
-
>
IsHTMLElement
(
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
script
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
style
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
input
)
|
|
nodeInfo
-
>
Equals
(
nsGkAtoms
:
:
textarea
)
|
|
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
)
&
&
!
aContent
-
>
IsShadowRoot
(
)
;
}
static
bool
DoesNotAffectDirectionOfAncestors
(
const
Element
*
aElement
)
{
return
(
DoesNotParticipateInAutoDirection
(
aElement
)
|
|
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
|
|
aElement
-
>
HasFixedDir
(
)
)
;
}
static
Directionality
GetDirectionFromChar
(
uint32_t
ch
)
{
switch
(
intl
:
:
UnicodeProperties
:
:
GetBidiClass
(
ch
)
)
{
case
intl
:
:
BidiClass
:
:
RightToLeft
:
case
intl
:
:
BidiClass
:
:
RightToLeftArabic
:
return
Directionality
:
:
Rtl
;
case
intl
:
:
BidiClass
:
:
LeftToRight
:
return
Directionality
:
:
Ltr
;
default
:
return
Directionality
:
:
Unset
;
}
}
inline
static
bool
NodeAffectsDirAutoAncestor
(
nsIContent
*
aTextNode
)
{
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aTextNode
)
;
return
(
parent
&
&
!
DoesNotParticipateInAutoDirection
(
parent
)
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
&
&
!
aTextNode
-
>
IsInNativeAnonymousSubtree
(
)
)
;
}
Directionality
GetDirectionFromText
(
const
char16_t
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
)
{
const
char16_t
*
start
=
aText
;
const
char16_t
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
uint32_t
ch
=
*
start
+
+
;
if
(
start
<
end
&
&
NS_IS_SURROGATE_PAIR
(
ch
*
start
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
start
+
+
)
;
current
+
+
;
}
if
(
!
IS_SURROGATE
(
ch
)
)
{
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
GetDirectionFromText
(
const
char
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
=
nullptr
)
{
const
char
*
start
=
aText
;
const
char
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
unsigned
char
ch
=
(
unsigned
char
)
*
start
+
+
;
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
GetDirectionFromText
(
const
mozilla
:
:
dom
:
:
Text
*
aTextNode
uint32_t
*
aFirstStrong
=
nullptr
)
{
const
nsTextFragment
*
frag
=
&
aTextNode
-
>
TextFragment
(
)
;
if
(
frag
-
>
Is2b
(
)
)
{
return
GetDirectionFromText
(
frag
-
>
Get2b
(
)
frag
-
>
GetLength
(
)
aFirstStrong
)
;
}
return
GetDirectionFromText
(
frag
-
>
Get1b
(
)
frag
-
>
GetLength
(
)
aFirstStrong
)
;
}
static
nsTextNode
*
WalkDescendantsAndGetDirectionFromText
(
nsINode
*
aRoot
nsINode
*
aSkip
Directionality
*
aDirectionality
)
{
nsIContent
*
child
=
aRoot
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
(
child
-
>
IsElement
(
)
&
&
DoesNotAffectDirectionOfAncestors
(
child
-
>
AsElement
(
)
)
)
|
|
child
-
>
GetAssignedSlot
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aRoot
)
;
continue
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
for
(
uint32_t
i
=
0
;
i
<
assignedNodes
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
assignedNode
=
assignedNodes
[
i
]
-
>
AsContent
(
)
;
if
(
assignedNode
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
auto
text
=
static_cast
<
nsTextNode
*
>
(
assignedNode
)
;
if
(
assignedNode
!
=
aSkip
)
{
Directionality
textNodeDir
=
GetDirectionFromText
(
text
)
;
if
(
textNodeDir
!
=
Directionality
:
:
Unset
)
{
*
aDirectionality
=
textNodeDir
;
return
text
;
}
}
}
else
if
(
assignedNode
-
>
IsElement
(
)
&
&
!
DoesNotAffectDirectionOfAncestors
(
assignedNode
-
>
AsElement
(
)
)
)
{
nsTextNode
*
text
=
WalkDescendantsAndGetDirectionFromText
(
assignedNode
aSkip
aDirectionality
)
;
if
(
text
)
{
return
text
;
}
}
}
}
if
(
child
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
&
&
child
!
=
aSkip
)
{
auto
text
=
static_cast
<
nsTextNode
*
>
(
child
)
;
Directionality
textNodeDir
=
GetDirectionFromText
(
text
)
;
if
(
textNodeDir
!
=
Directionality
:
:
Unset
)
{
*
aDirectionality
=
textNodeDir
;
return
text
;
}
}
child
=
child
-
>
GetNextNode
(
aRoot
)
;
}
return
nullptr
;
}
static
nsTextNode
*
WalkDescendantsSetDirectionFromText
(
Element
*
aElement
bool
aNotify
nsINode
*
aChangedNode
=
nullptr
)
{
MOZ_ASSERT
(
aElement
"
Must
have
an
element
"
)
;
MOZ_ASSERT
(
aElement
-
>
HasDirAuto
(
)
"
Element
must
have
dir
=
auto
"
)
;
if
(
DoesNotParticipateInAutoDirection
(
aElement
)
)
{
return
nullptr
;
}
Directionality
textNodeDir
=
Directionality
:
:
Unset
;
if
(
ShadowRoot
*
shadowRoot
=
aElement
-
>
GetShadowRoot
(
)
)
{
nsTextNode
*
text
=
WalkDescendantsAndGetDirectionFromText
(
shadowRoot
aChangedNode
&
textNodeDir
)
;
if
(
text
)
{
aElement
-
>
SetDirectionality
(
textNodeDir
aNotify
)
;
return
text
;
}
}
nsTextNode
*
text
=
WalkDescendantsAndGetDirectionFromText
(
aElement
aChangedNode
&
textNodeDir
)
;
if
(
text
)
{
aElement
-
>
SetDirectionality
(
textNodeDir
aNotify
)
;
return
text
;
}
aElement
-
>
SetDirectionality
(
Directionality
:
:
Ltr
aNotify
)
;
return
nullptr
;
}
class
nsTextNodeDirectionalityMap
{
static
void
nsTextNodeDirectionalityMapDtor
(
void
*
aObject
nsAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
{
nsINode
*
textNode
=
static_cast
<
nsINode
*
>
(
aObject
)
;
textNode
-
>
ClearHasTextNodeDirectionalityMap
(
)
;
nsTextNodeDirectionalityMap
*
map
=
reinterpret_cast
<
nsTextNodeDirectionalityMap
*
>
(
aPropertyValue
)
;
map
-
>
EnsureMapIsClear
(
)
;
delete
map
;
}
public
:
explicit
nsTextNodeDirectionalityMap
(
nsINode
*
aTextNode
)
:
mElementToBeRemoved
(
nullptr
)
{
MOZ_ASSERT
(
aTextNode
"
Null
text
node
"
)
;
MOZ_COUNT_CTOR
(
nsTextNodeDirectionalityMap
)
;
aTextNode
-
>
SetProperty
(
nsGkAtoms
:
:
textNodeDirectionalityMap
this
nsTextNodeDirectionalityMapDtor
)
;
aTextNode
-
>
SetHasTextNodeDirectionalityMap
(
)
;
}
MOZ_COUNTED_DTOR
(
nsTextNodeDirectionalityMap
)
static
void
nsTextNodeDirectionalityMapPropertyDestructor
(
void
*
aObject
nsAtom
*
aProperty
void
*
aPropertyValue
void
*
aData
)
{
nsTextNode
*
textNode
=
static_cast
<
nsTextNode
*
>
(
aPropertyValue
)
;
nsTextNodeDirectionalityMap
*
map
=
GetDirectionalityMap
(
textNode
)
;
if
(
map
)
{
map
-
>
RemoveEntryForProperty
(
static_cast
<
Element
*
>
(
aObject
)
)
;
}
NS_RELEASE
(
textNode
)
;
}
void
AddEntry
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
if
(
!
mElements
.
Contains
(
aElement
)
)
{
mElements
.
Put
(
aElement
)
;
NS_ADDREF
(
aTextNode
)
;
aElement
-
>
SetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
aTextNode
nsTextNodeDirectionalityMapPropertyDestructor
)
;
aElement
-
>
SetHasDirAutoSet
(
)
;
}
}
void
RemoveEntry
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
NS_ASSERTION
(
mElements
.
Contains
(
aElement
)
"
element
already
removed
from
map
"
)
;
mElements
.
Remove
(
aElement
)
;
aElement
-
>
ClearHasDirAutoSet
(
)
;
aElement
-
>
RemoveProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
;
}
void
RemoveEntryForProperty
(
Element
*
aElement
)
{
if
(
mElementToBeRemoved
!
=
aElement
)
{
mElements
.
Remove
(
aElement
)
;
}
aElement
-
>
ClearHasDirAutoSet
(
)
;
}
private
:
nsCheapSet
<
nsPtrHashKey
<
Element
>
>
mElements
;
Element
*
mElementToBeRemoved
;
static
nsTextNodeDirectionalityMap
*
GetDirectionalityMap
(
nsINode
*
aTextNode
)
{
MOZ_ASSERT
(
aTextNode
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
"
Must
be
a
text
node
"
)
;
nsTextNodeDirectionalityMap
*
map
=
nullptr
;
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
map
=
static_cast
<
nsTextNodeDirectionalityMap
*
>
(
aTextNode
-
>
GetProperty
(
nsGkAtoms
:
:
textNodeDirectionalityMap
)
)
;
}
return
map
;
}
static
nsCheapSetOperator
SetNodeDirection
(
nsPtrHashKey
<
Element
>
*
aEntry
void
*
aDir
)
{
aEntry
-
>
GetKey
(
)
-
>
SetDirectionality
(
*
reinterpret_cast
<
Directionality
*
>
(
aDir
)
true
)
;
return
OpNext
;
}
struct
nsTextNodeDirectionalityMapAndElement
{
nsTextNodeDirectionalityMap
*
mMap
;
nsCOMPtr
<
nsINode
>
mNode
;
}
;
static
nsCheapSetOperator
ResetNodeDirection
(
nsPtrHashKey
<
Element
>
*
aEntry
void
*
aData
)
{
nsTextNodeDirectionalityMapAndElement
*
data
=
static_cast
<
nsTextNodeDirectionalityMapAndElement
*
>
(
aData
)
;
nsINode
*
oldTextNode
=
data
-
>
mNode
;
Element
*
rootNode
=
aEntry
-
>
GetKey
(
)
;
nsTextNode
*
newTextNode
=
nullptr
;
if
(
rootNode
-
>
GetParentNode
(
)
&
&
rootNode
-
>
HasDirAuto
(
)
)
{
newTextNode
=
WalkDescendantsSetDirectionFromText
(
rootNode
true
oldTextNode
)
;
}
AutoRestore
<
Element
*
>
restore
(
data
-
>
mMap
-
>
mElementToBeRemoved
)
;
data
-
>
mMap
-
>
mElementToBeRemoved
=
rootNode
;
if
(
newTextNode
)
{
nsINode
*
oldDirAutoSetBy
=
static_cast
<
nsTextNode
*
>
(
rootNode
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
if
(
oldDirAutoSetBy
=
=
newTextNode
)
{
return
OpNext
;
}
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
newTextNode
rootNode
)
;
}
else
{
rootNode
-
>
ClearHasDirAutoSet
(
)
;
rootNode
-
>
RemoveProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
;
}
return
OpRemove
;
}
static
nsCheapSetOperator
TakeEntries
(
nsPtrHashKey
<
Element
>
*
aEntry
void
*
aData
)
{
AutoTArray
<
Element
*
8
>
*
entries
=
static_cast
<
AutoTArray
<
Element
*
8
>
*
>
(
aData
)
;
entries
-
>
AppendElement
(
aEntry
-
>
GetKey
(
)
)
;
return
OpRemove
;
}
public
:
uint32_t
UpdateAutoDirection
(
Directionality
aDir
)
{
return
mElements
.
EnumerateEntries
(
SetNodeDirection
&
aDir
)
;
}
void
ResetAutoDirection
(
nsINode
*
aTextNode
)
{
nsTextNodeDirectionalityMapAndElement
data
=
{
this
aTextNode
}
;
mElements
.
EnumerateEntries
(
ResetNodeDirection
&
data
)
;
}
void
EnsureMapIsClear
(
)
{
AutoRestore
<
Element
*
>
restore
(
mElementToBeRemoved
)
;
AutoTArray
<
Element
*
8
>
entries
;
mElements
.
EnumerateEntries
(
TakeEntries
&
entries
)
;
for
(
Element
*
el
:
entries
)
{
el
-
>
ClearHasDirAutoSet
(
)
;
el
-
>
RemoveProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
;
}
}
static
void
RemoveElementFromMap
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
GetDirectionalityMap
(
aTextNode
)
-
>
RemoveEntry
(
aTextNode
aElement
)
;
}
}
static
void
AddEntryToMap
(
nsTextNode
*
aTextNode
Element
*
aElement
)
{
nsTextNodeDirectionalityMap
*
map
=
GetDirectionalityMap
(
aTextNode
)
;
if
(
!
map
)
{
map
=
new
nsTextNodeDirectionalityMap
(
aTextNode
)
;
}
map
-
>
AddEntry
(
aTextNode
aElement
)
;
}
static
uint32_t
UpdateTextNodeDirection
(
nsINode
*
aTextNode
Directionality
aDir
)
{
MOZ_ASSERT
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
"
Map
missing
in
UpdateTextNodeDirection
"
)
;
return
GetDirectionalityMap
(
aTextNode
)
-
>
UpdateAutoDirection
(
aDir
)
;
}
static
void
ResetTextNodeDirection
(
nsTextNode
*
aTextNode
nsTextNode
*
aChangedTextNode
)
{
MOZ_ASSERT
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
"
Map
missing
in
ResetTextNodeDirection
"
)
;
RefPtr
<
nsTextNode
>
textNode
=
aTextNode
;
GetDirectionalityMap
(
textNode
)
-
>
ResetAutoDirection
(
aChangedTextNode
)
;
}
static
void
EnsureMapIsClearFor
(
nsINode
*
aTextNode
)
{
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
GetDirectionalityMap
(
aTextNode
)
-
>
EnsureMapIsClear
(
)
;
}
}
}
;
Directionality
GetParentDirectionality
(
const
Element
*
aElement
)
{
if
(
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aElement
)
)
{
if
(
ShadowRoot
*
shadow
=
ShadowRoot
:
:
FromNode
(
parent
)
)
{
parent
=
shadow
-
>
GetHost
(
)
;
}
if
(
parent
&
&
parent
-
>
IsElement
(
)
)
{
Directionality
parentDir
=
parent
-
>
AsElement
(
)
-
>
GetDirectionality
(
)
;
if
(
parentDir
!
=
Directionality
:
:
Unset
)
{
return
parentDir
;
}
}
}
return
Directionality
:
:
Ltr
;
}
Directionality
RecomputeDirectionality
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
!
aElement
-
>
HasDirAuto
(
)
"
RecomputeDirectionality
called
with
dir
=
auto
"
)
;
if
(
aElement
-
>
HasValidDir
(
)
)
{
return
aElement
-
>
GetDirectionality
(
)
;
}
if
(
auto
*
input
=
HTMLInputElement
:
:
FromNode
(
*
aElement
)
)
{
if
(
input
-
>
ControlType
(
)
=
=
FormControlType
:
:
InputTel
)
{
aElement
-
>
SetDirectionality
(
Directionality
:
:
Ltr
aNotify
)
;
return
Directionality
:
:
Ltr
;
}
}
const
Directionality
dir
=
GetParentDirectionality
(
aElement
)
;
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
return
dir
;
}
static
inline
bool
IsBoundary
(
const
Element
&
aElement
)
{
return
aElement
.
HasValidDir
(
)
|
|
aElement
.
HasDirAuto
(
)
;
}
static
void
SetDirectionalityOnDescendantsInternal
(
nsINode
*
aNode
Directionality
aDir
bool
aNotify
)
{
if
(
Element
*
element
=
Element
:
:
FromNode
(
aNode
)
)
{
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
SetDirectionalityOnDescendantsInternal
(
shadow
aDir
aNotify
)
;
}
}
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
)
{
auto
*
element
=
Element
:
:
FromNode
(
child
)
;
if
(
!
element
)
{
child
=
child
-
>
GetNextNode
(
aNode
)
;
continue
;
}
if
(
IsBoundary
(
*
element
)
|
|
element
-
>
GetAssignedSlot
(
)
|
|
element
-
>
GetDirectionality
(
)
=
=
aDir
)
{
child
=
child
-
>
GetNextNonChildNode
(
aNode
)
;
continue
;
}
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
SetDirectionalityOnDescendantsInternal
(
shadow
aDir
aNotify
)
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
for
(
const
RefPtr
<
nsINode
>
&
assignedNode
:
slot
-
>
AssignedNodes
(
)
)
{
auto
*
assignedElement
=
Element
:
:
FromNode
(
*
assignedNode
)
;
if
(
assignedElement
&
&
!
IsBoundary
(
*
assignedElement
)
)
{
assignedElement
-
>
SetDirectionality
(
aDir
aNotify
)
;
SetDirectionalityOnDescendantsInternal
(
assignedElement
aDir
aNotify
)
;
}
}
}
element
-
>
SetDirectionality
(
aDir
aNotify
)
;
child
=
child
-
>
GetNextNode
(
aNode
)
;
}
}
void
SetDirectionalityOnDescendants
(
Element
*
aElement
Directionality
aDir
bool
aNotify
)
{
return
SetDirectionalityOnDescendantsInternal
(
aElement
aDir
aNotify
)
;
}
static
void
ResetAutoDirection
(
Element
*
aElement
bool
aNotify
)
{
if
(
aElement
-
>
HasDirAutoSet
(
)
)
{
nsTextNode
*
setByNode
=
static_cast
<
nsTextNode
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
if
(
setByNode
)
{
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
setByNode
aElement
)
;
}
}
if
(
aElement
-
>
HasDirAuto
(
)
)
{
nsTextNode
*
setByNode
=
WalkDescendantsSetDirectionFromText
(
aElement
aNotify
)
;
if
(
setByNode
)
{
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
setByNode
aElement
)
;
}
SetDirectionalityOnDescendants
(
aElement
aElement
-
>
GetDirectionality
(
)
aNotify
)
;
}
}
void
WalkAncestorsResetAutoDirection
(
Element
*
aElement
bool
aNotify
)
{
nsTextNode
*
setByNode
;
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aElement
)
;
while
(
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
if
(
!
parent
-
>
IsElement
(
)
)
{
parent
=
GetParentOrHostOrSlot
(
parent
)
;
continue
;
}
Element
*
parentElement
=
parent
-
>
AsElement
(
)
;
if
(
parent
-
>
HasDirAutoSet
(
)
)
{
setByNode
=
static_cast
<
nsTextNode
*
>
(
parent
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
if
(
setByNode
)
{
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
setByNode
parentElement
)
;
}
}
if
(
parentElement
-
>
HasDirAuto
(
)
)
{
setByNode
=
WalkDescendantsSetDirectionFromText
(
parentElement
aNotify
)
;
if
(
setByNode
)
{
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
setByNode
parentElement
)
;
}
SetDirectionalityOnDescendants
(
parentElement
parentElement
-
>
GetDirectionality
(
)
aNotify
)
;
break
;
}
parent
=
GetParentOrHostOrSlot
(
parent
)
;
}
}
static
void
RecomputeSlottedNodeDirection
(
HTMLSlotElement
&
aSlot
nsINode
&
aNode
)
{
auto
*
assignedElement
=
Element
:
:
FromNode
(
aNode
)
;
if
(
!
assignedElement
)
{
return
;
}
if
(
assignedElement
-
>
HasValidDir
(
)
|
|
assignedElement
-
>
HasDirAuto
(
)
)
{
return
;
}
if
(
assignedElement
-
>
GetDirectionality
(
)
=
=
aSlot
.
GetDirectionality
(
)
)
{
return
;
}
assignedElement
-
>
SetDirectionality
(
aSlot
.
GetDirectionality
(
)
true
)
;
SetDirectionalityOnDescendantsInternal
(
assignedElement
aSlot
.
GetDirectionality
(
)
true
)
;
}
void
SlotAssignedNodeChanged
(
HTMLSlotElement
*
aSlot
nsIContent
&
aAssignedNode
)
{
if
(
!
aSlot
)
{
return
;
}
if
(
aSlot
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
SlotStateChanged
(
aSlot
false
)
;
}
if
(
aAssignedNode
.
GetAssignedSlot
(
)
=
=
aSlot
)
{
RecomputeSlottedNodeDirection
(
*
aSlot
aAssignedNode
)
;
}
}
void
SlotStateChanged
(
HTMLSlotElement
*
aSlot
bool
aAllAssignedNodesChanged
)
{
if
(
!
aSlot
)
{
return
;
}
Directionality
oldDir
=
aSlot
-
>
GetDirectionality
(
)
;
if
(
aSlot
-
>
HasDirAuto
(
)
)
{
ResetAutoDirection
(
aSlot
true
)
;
}
if
(
aSlot
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
WalkAncestorsResetAutoDirection
(
aSlot
true
)
;
}
if
(
aAllAssignedNodesChanged
|
|
oldDir
!
=
aSlot
-
>
GetDirectionality
(
)
)
{
for
(
nsINode
*
node
:
aSlot
-
>
AssignedNodes
(
)
)
{
RecomputeSlottedNodeDirection
(
*
aSlot
*
node
)
;
}
}
}
void
WalkDescendantsResetAutoDirection
(
Element
*
aElement
)
{
nsIContent
*
child
=
aElement
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
child
-
>
AsElement
(
)
-
>
HasDirAuto
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aElement
)
;
continue
;
}
if
(
child
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
&
&
child
-
>
HasTextNodeDirectionalityMap
(
)
)
{
nsTextNodeDirectionalityMap
:
:
ResetTextNodeDirection
(
static_cast
<
nsTextNode
*
>
(
child
)
nullptr
)
;
}
child
=
child
-
>
GetNextNode
(
aElement
)
;
}
}
static
void
SetAncestorHasDirAutoOnDescendants
(
nsINode
*
aRoot
)
;
static
void
MaybeSetAncestorHasDirAutoOnShadowDOM
(
nsINode
*
aNode
)
{
if
(
aNode
-
>
IsElement
(
)
)
{
if
(
ShadowRoot
*
sr
=
aNode
-
>
AsElement
(
)
-
>
GetShadowRoot
(
)
)
{
sr
-
>
SetAncestorHasDirAuto
(
)
;
SetAncestorHasDirAutoOnDescendants
(
sr
)
;
}
}
}
static
void
SetAncestorHasDirAutoOnDescendants
(
nsINode
*
aRoot
)
{
MaybeSetAncestorHasDirAutoOnShadowDOM
(
aRoot
)
;
nsIContent
*
child
=
aRoot
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
DoesNotAffectDirectionOfAncestors
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aRoot
)
;
continue
;
}
if
(
!
child
-
>
GetAssignedSlot
(
)
)
{
MaybeSetAncestorHasDirAutoOnShadowDOM
(
child
)
;
child
-
>
SetAncestorHasDirAuto
(
)
;
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
for
(
uint32_t
i
=
0
;
i
<
assignedNodes
.
Length
(
)
;
+
+
i
)
{
assignedNodes
[
i
]
-
>
SetAncestorHasDirAuto
(
)
;
SetAncestorHasDirAutoOnDescendants
(
assignedNodes
[
i
]
)
;
}
}
}
child
=
child
-
>
GetNextNode
(
aRoot
)
;
}
}
void
WalkDescendantsSetDirAuto
(
Element
*
aElement
bool
aNotify
)
{
if
(
!
DoesNotParticipateInAutoDirection
(
aElement
)
&
&
!
aElement
-
>
AncestorHasDirAuto
(
)
)
{
SetAncestorHasDirAutoOnDescendants
(
aElement
)
;
}
nsTextNode
*
textNode
=
WalkDescendantsSetDirectionFromText
(
aElement
aNotify
)
;
if
(
textNode
)
{
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
textNode
aElement
)
;
}
}
void
WalkDescendantsClearAncestorDirAuto
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsElement
(
)
)
{
if
(
ShadowRoot
*
shadowRoot
=
aContent
-
>
AsElement
(
)
-
>
GetShadowRoot
(
)
)
{
shadowRoot
-
>
ClearAncestorHasDirAuto
(
)
;
WalkDescendantsClearAncestorDirAuto
(
shadowRoot
)
;
}
}
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
GetAssignedSlot
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aContent
)
;
continue
;
}
if
(
child
-
>
IsElement
(
)
)
{
if
(
child
-
>
AsElement
(
)
-
>
HasDirAuto
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aContent
)
;
continue
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
for
(
uint32_t
i
=
0
;
i
<
assignedNodes
.
Length
(
)
;
+
+
i
)
{
if
(
assignedNodes
[
i
]
-
>
IsElement
(
)
)
{
Element
*
slottedElement
=
assignedNodes
[
i
]
-
>
AsElement
(
)
;
if
(
slottedElement
-
>
HasDirAuto
(
)
)
{
continue
;
}
}
nsIContent
*
content
=
assignedNodes
[
i
]
-
>
AsContent
(
)
;
content
-
>
ClearAncestorHasDirAuto
(
)
;
WalkDescendantsClearAncestorDirAuto
(
content
)
;
}
}
}
child
-
>
ClearAncestorHasDirAuto
(
)
;
child
=
child
-
>
GetNextNode
(
aContent
)
;
}
}
void
SetAncestorDirectionIfAuto
(
nsTextNode
*
aTextNode
Directionality
aDir
bool
aNotify
=
true
)
{
MOZ_ASSERT
(
aTextNode
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
"
Must
be
a
text
node
"
)
;
bool
crossedShadowBoundary
=
false
;
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aTextNode
&
crossedShadowBoundary
)
;
while
(
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
if
(
!
parent
-
>
IsElement
(
)
)
{
parent
=
GetParentOrHostOrSlot
(
parent
&
crossedShadowBoundary
)
;
continue
;
}
Element
*
parentElement
=
parent
-
>
AsElement
(
)
;
if
(
DoesNotParticipateInAutoDirection
(
parentElement
)
|
|
parentElement
-
>
HasFixedDir
(
)
)
{
break
;
}
if
(
parentElement
-
>
HasDirAuto
(
)
)
{
bool
resetDirection
=
false
;
nsTextNode
*
directionWasSetByTextNode
=
static_cast
<
nsTextNode
*
>
(
parent
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
if
(
!
parent
-
>
HasDirAutoSet
(
)
)
{
MOZ_ASSERT
(
!
directionWasSetByTextNode
"
dirAutoSetBy
property
should
be
null
"
)
;
resetDirection
=
true
;
}
else
{
if
(
!
directionWasSetByTextNode
)
{
resetDirection
=
true
;
}
else
if
(
directionWasSetByTextNode
!
=
aTextNode
)
{
if
(
crossedShadowBoundary
|
|
AncestorChainCrossesShadowBoundary
(
directionWasSetByTextNode
parent
)
)
{
ResetAutoDirection
(
parentElement
aNotify
)
;
return
;
}
nsIContent
*
child
=
aTextNode
-
>
GetNextNode
(
parent
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
DoesNotAffectDirectionOfAncestors
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
parent
)
;
continue
;
}
if
(
child
=
=
directionWasSetByTextNode
)
{
resetDirection
=
true
;
break
;
}
child
=
child
-
>
GetNextNode
(
parent
)
;
}
}
}
if
(
resetDirection
)
{
if
(
directionWasSetByTextNode
)
{
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
directionWasSetByTextNode
parentElement
)
;
}
parentElement
-
>
SetDirectionality
(
aDir
aNotify
)
;
nsTextNodeDirectionalityMap
:
:
AddEntryToMap
(
aTextNode
parentElement
)
;
SetDirectionalityOnDescendants
(
parentElement
aDir
aNotify
)
;
}
return
;
}
parent
=
GetParentOrHostOrSlot
(
parent
&
crossedShadowBoundary
)
;
}
}
bool
TextNodeWillChangeDirection
(
nsTextNode
*
aTextNode
Directionality
*
aOldDir
uint32_t
aOffset
)
{
if
(
!
NodeAffectsDirAutoAncestor
(
aTextNode
)
)
{
nsTextNodeDirectionalityMap
:
:
EnsureMapIsClearFor
(
aTextNode
)
;
return
false
;
}
uint32_t
firstStrong
;
*
aOldDir
=
GetDirectionFromText
(
aTextNode
&
firstStrong
)
;
return
(
aOffset
<
=
firstStrong
)
;
}
void
TextNodeChangedDirection
(
nsTextNode
*
aTextNode
Directionality
aOldDir
bool
aNotify
)
{
Directionality
newDir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
newDir
=
=
Directionality
:
:
Unset
)
{
if
(
aOldDir
!
=
Directionality
:
:
Unset
&
&
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
nsTextNodeDirectionalityMap
:
:
ResetTextNodeDirection
(
aTextNode
aTextNode
)
;
}
}
else
{
if
(
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
&
&
nsTextNodeDirectionalityMap
:
:
UpdateTextNodeDirection
(
aTextNode
newDir
)
)
{
return
;
}
SetAncestorDirectionIfAuto
(
aTextNode
newDir
aNotify
)
;
}
}
void
SetDirectionFromNewTextNode
(
nsTextNode
*
aTextNode
)
{
if
(
!
NodeAffectsDirAutoAncestor
(
aTextNode
)
)
{
return
;
}
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aTextNode
)
;
if
(
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aTextNode
-
>
SetAncestorHasDirAuto
(
)
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
SetAncestorDirectionIfAuto
(
aTextNode
dir
)
;
}
}
void
ResetDirectionSetByTextNode
(
nsTextNode
*
aTextNode
)
{
if
(
!
NodeAffectsDirAutoAncestor
(
aTextNode
)
)
{
nsTextNodeDirectionalityMap
:
:
EnsureMapIsClearFor
(
aTextNode
)
;
return
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
dir
!
=
Directionality
:
:
Unset
&
&
aTextNode
-
>
HasTextNodeDirectionalityMap
(
)
)
{
nsTextNodeDirectionalityMap
:
:
ResetTextNodeDirection
(
aTextNode
aTextNode
)
;
}
}
void
SetDirectionalityFromValue
(
Element
*
aElement
const
nsAString
&
value
bool
aNotify
)
{
Directionality
dir
=
GetDirectionFromText
(
value
.
BeginReading
(
)
value
.
Length
(
)
)
;
if
(
dir
=
=
Directionality
:
:
Unset
)
{
dir
=
Directionality
:
:
Ltr
;
}
if
(
aElement
-
>
GetDirectionality
(
)
!
=
dir
)
{
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
}
}
void
OnSetDirAttr
(
Element
*
aElement
const
nsAttrValue
*
aNewValue
bool
hadValidDir
bool
hadDirAuto
bool
aNotify
)
{
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
|
|
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
textarea
)
)
{
return
;
}
if
(
aElement
-
>
AncestorHasDirAuto
(
)
)
{
if
(
!
hadValidDir
)
{
WalkDescendantsResetAutoDirection
(
aElement
)
;
}
else
if
(
!
aElement
-
>
HasValidDir
(
)
)
{
WalkAncestorsResetAutoDirection
(
aElement
aNotify
)
;
}
}
else
if
(
hadDirAuto
&
&
!
aElement
-
>
HasDirAuto
(
)
)
{
WalkDescendantsClearAncestorDirAuto
(
aElement
)
;
}
if
(
aElement
-
>
HasDirAuto
(
)
)
{
WalkDescendantsSetDirAuto
(
aElement
aNotify
)
;
}
else
{
if
(
aElement
-
>
HasDirAutoSet
(
)
)
{
nsTextNode
*
setByNode
=
static_cast
<
nsTextNode
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
setByNode
aElement
)
;
}
SetDirectionalityOnDescendants
(
aElement
RecomputeDirectionality
(
aElement
aNotify
)
aNotify
)
;
}
}
void
SetDirOnBind
(
Element
*
aElement
nsIContent
*
aParent
)
{
if
(
!
DoesNotParticipateInAutoDirection
(
aElement
)
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
&
&
aParent
&
&
aParent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aElement
-
>
SetAncestorHasDirAuto
(
)
;
SetAncestorHasDirAutoOnDescendants
(
aElement
)
;
if
(
aElement
-
>
GetFirstChild
(
)
|
|
aElement
-
>
GetShadowRoot
(
)
)
{
WalkAncestorsResetAutoDirection
(
aElement
true
)
;
}
}
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
RecomputeDirectionality
(
aElement
false
)
;
}
}
void
ResetDir
(
Element
*
aElement
)
{
if
(
aElement
-
>
HasDirAutoSet
(
)
)
{
nsTextNode
*
setByNode
=
static_cast
<
nsTextNode
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
dirAutoSetBy
)
)
;
nsTextNodeDirectionalityMap
:
:
RemoveElementFromMap
(
setByNode
aElement
)
;
}
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
RecomputeDirectionality
(
aElement
false
)
;
}
}
}
