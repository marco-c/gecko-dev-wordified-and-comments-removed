#
include
"
mozilla
/
dom
/
DirectionalityUtils
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
dom
/
UnbindContext
.
h
"
#
include
"
mozilla
/
intl
/
UnicodeProperties
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsAttrValue
.
h
"
namespace
mozilla
{
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
HTMLInputElement
;
using
mozilla
:
:
dom
:
:
HTMLSlotElement
;
using
mozilla
:
:
dom
:
:
ShadowRoot
;
using
mozilla
:
:
dom
:
:
Text
;
static
nsIContent
*
GetParentOrHostOrSlot
(
const
nsIContent
*
aContent
)
{
if
(
HTMLSlotElement
*
slot
=
aContent
-
>
GetAssignedSlot
(
)
)
{
return
slot
;
}
if
(
nsIContent
*
parent
=
aContent
-
>
GetParent
(
)
)
{
return
parent
;
}
if
(
const
ShadowRoot
*
sr
=
ShadowRoot
:
:
FromNode
(
aContent
)
)
{
return
sr
-
>
GetHost
(
)
;
}
return
nullptr
;
}
static
bool
ParticipatesInAutoDirection
(
const
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
false
;
}
if
(
aContent
-
>
IsShadowRoot
(
)
)
{
return
true
;
}
return
!
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
script
nsGkAtoms
:
:
style
nsGkAtoms
:
:
input
nsGkAtoms
:
:
textarea
)
;
}
static
Directionality
GetDirectionFromChar
(
uint32_t
ch
)
{
switch
(
intl
:
:
UnicodeProperties
:
:
GetBidiClass
(
ch
)
)
{
case
intl
:
:
BidiClass
:
:
RightToLeft
:
case
intl
:
:
BidiClass
:
:
RightToLeftArabic
:
return
Directionality
:
:
Rtl
;
case
intl
:
:
BidiClass
:
:
LeftToRight
:
return
Directionality
:
:
Ltr
;
default
:
return
Directionality
:
:
Unset
;
}
}
inline
static
bool
EstablishesOwnDirection
(
const
Element
*
aElement
)
{
return
!
ParticipatesInAutoDirection
(
aElement
)
|
|
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
|
|
aElement
-
>
HasFixedDir
(
)
|
|
aElement
-
>
HasDirAuto
(
)
;
}
inline
static
bool
AffectsDirAutoElement
(
nsIContent
*
aContent
)
{
return
aContent
&
&
ParticipatesInAutoDirection
(
aContent
)
&
&
aContent
-
>
NodeOrAncestorHasDirAuto
(
)
;
}
Directionality
GetDirectionFromText
(
const
char16_t
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
)
{
const
char16_t
*
start
=
aText
;
const
char16_t
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
uint32_t
ch
=
*
start
+
+
;
if
(
start
<
end
&
&
NS_IS_SURROGATE_PAIR
(
ch
*
start
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
*
start
+
+
)
;
current
+
+
;
}
if
(
!
IS_SURROGATE
(
ch
)
)
{
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
GetDirectionFromText
(
const
char
*
aText
const
uint32_t
aLength
uint32_t
*
aFirstStrong
=
nullptr
)
{
const
char
*
start
=
aText
;
const
char
*
end
=
aText
+
aLength
;
while
(
start
<
end
)
{
uint32_t
current
=
start
-
aText
;
unsigned
char
ch
=
(
unsigned
char
)
*
start
+
+
;
Directionality
dir
=
GetDirectionFromChar
(
ch
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
if
(
aFirstStrong
)
{
*
aFirstStrong
=
current
;
}
return
dir
;
}
}
if
(
aFirstStrong
)
{
*
aFirstStrong
=
UINT32_MAX
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
GetDirectionFromText
(
const
Text
*
aTextNode
uint32_t
*
aFirstStrong
=
nullptr
)
{
const
nsTextFragment
*
frag
=
&
aTextNode
-
>
TextFragment
(
)
;
if
(
frag
-
>
Is2b
(
)
)
{
return
GetDirectionFromText
(
frag
-
>
Get2b
(
)
frag
-
>
GetLength
(
)
aFirstStrong
)
;
}
return
GetDirectionFromText
(
frag
-
>
Get1b
(
)
frag
-
>
GetLength
(
)
aFirstStrong
)
;
}
Directionality
WalkDescendantsAndGetDirectionFromText
(
nsINode
*
aRoot
)
{
nsIContent
*
child
=
aRoot
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
EstablishesOwnDirection
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aRoot
)
;
continue
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
if
(
const
ShadowRoot
*
sr
=
slot
-
>
GetContainingShadow
(
)
)
{
Element
*
host
=
sr
-
>
GetHost
(
)
;
MOZ_ASSERT
(
host
)
;
return
host
-
>
GetDirectionality
(
)
;
}
}
if
(
auto
*
text
=
Text
:
:
FromNode
(
child
)
)
{
Directionality
textNodeDir
=
GetDirectionFromText
(
text
)
;
if
(
textNodeDir
!
=
Directionality
:
:
Unset
)
{
text
-
>
SetMaySetDirAuto
(
)
;
return
textNodeDir
;
}
}
child
=
child
-
>
GetNextNode
(
aRoot
)
;
}
return
Directionality
:
:
Unset
;
}
static
Directionality
ComputeAutoDirectionality
(
Element
*
aElement
bool
aNotify
)
;
Directionality
ComputeAutoDirectionFromAssignedNodes
(
HTMLSlotElement
*
aSlot
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
bool
aNotify
)
{
for
(
const
RefPtr
<
nsINode
>
&
assignedNode
:
assignedNodes
)
{
Directionality
childDirection
=
Directionality
:
:
Unset
;
if
(
auto
*
text
=
Text
:
:
FromNode
(
assignedNode
)
)
{
childDirection
=
GetDirectionFromText
(
text
)
;
if
(
childDirection
!
=
Directionality
:
:
Unset
)
{
text
-
>
SetMaySetDirAuto
(
)
;
}
}
else
{
Element
*
assignedElement
=
Element
:
:
FromNode
(
assignedNode
)
;
MOZ_ASSERT
(
assignedElement
)
;
if
(
ParticipatesInAutoDirection
(
assignedElement
)
)
{
childDirection
=
ComputeAutoDirectionality
(
assignedElement
aNotify
)
;
}
}
if
(
childDirection
!
=
Directionality
:
:
Unset
)
{
return
childDirection
;
}
}
return
Directionality
:
:
Unset
;
}
static
Directionality
ComputeAutoDirectionality
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
aElement
"
Must
have
an
element
"
)
;
if
(
!
ParticipatesInAutoDirection
(
aElement
)
)
{
return
Directionality
:
:
Unset
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
aElement
)
)
{
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
if
(
!
assignedNodes
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
slot
-
>
IsInShadowTree
(
)
)
;
return
ComputeAutoDirectionFromAssignedNodes
(
slot
assignedNodes
aNotify
)
;
}
}
Directionality
nodeDir
=
WalkDescendantsAndGetDirectionFromText
(
aElement
)
;
if
(
nodeDir
!
=
Directionality
:
:
Unset
)
{
return
nodeDir
;
}
return
Directionality
:
:
Unset
;
}
Directionality
GetParentDirectionality
(
const
Element
*
aElement
)
{
if
(
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aElement
)
)
{
if
(
ShadowRoot
*
shadow
=
ShadowRoot
:
:
FromNode
(
parent
)
)
{
parent
=
shadow
-
>
GetHost
(
)
;
}
if
(
parent
&
&
parent
-
>
IsElement
(
)
)
{
Directionality
parentDir
=
parent
-
>
AsElement
(
)
-
>
GetDirectionality
(
)
;
if
(
parentDir
!
=
Directionality
:
:
Unset
)
{
return
parentDir
;
}
}
}
return
Directionality
:
:
Ltr
;
}
Directionality
RecomputeDirectionality
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
!
aElement
-
>
HasDirAuto
(
)
"
RecomputeDirectionality
called
with
dir
=
auto
"
)
;
if
(
aElement
-
>
HasValidDir
(
)
)
{
return
aElement
-
>
GetDirectionality
(
)
;
}
if
(
auto
*
input
=
HTMLInputElement
:
:
FromNode
(
*
aElement
)
)
{
if
(
input
-
>
ControlType
(
)
=
=
FormControlType
:
:
InputTel
)
{
aElement
-
>
SetDirectionality
(
Directionality
:
:
Ltr
aNotify
)
;
return
Directionality
:
:
Ltr
;
}
}
const
Directionality
dir
=
GetParentDirectionality
(
aElement
)
;
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
return
dir
;
}
static
inline
bool
IsBoundary
(
const
Element
&
aElement
)
{
return
aElement
.
HasValidDir
(
)
|
|
aElement
.
HasDirAuto
(
)
;
}
static
void
SetDirectionalityOnDescendantsInternal
(
nsINode
*
aNode
Directionality
aDir
bool
aNotify
)
{
if
(
auto
*
element
=
Element
:
:
FromNode
(
aNode
)
)
{
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
SetDirectionalityOnDescendantsInternal
(
shadow
aDir
aNotify
)
;
}
}
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
)
{
auto
*
element
=
Element
:
:
FromNode
(
child
)
;
if
(
!
element
)
{
child
=
child
-
>
GetNextNode
(
aNode
)
;
continue
;
}
if
(
IsBoundary
(
*
element
)
|
|
element
-
>
GetAssignedSlot
(
)
|
|
element
-
>
GetDirectionality
(
)
=
=
aDir
)
{
child
=
child
-
>
GetNextNonChildNode
(
aNode
)
;
continue
;
}
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
SetDirectionalityOnDescendantsInternal
(
shadow
aDir
aNotify
)
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
for
(
const
RefPtr
<
nsINode
>
&
assignedNode
:
slot
-
>
AssignedNodes
(
)
)
{
auto
*
assignedElement
=
Element
:
:
FromNode
(
*
assignedNode
)
;
if
(
assignedElement
&
&
!
IsBoundary
(
*
assignedElement
)
)
{
assignedElement
-
>
SetDirectionality
(
aDir
aNotify
)
;
SetDirectionalityOnDescendantsInternal
(
assignedElement
aDir
aNotify
)
;
}
}
}
element
-
>
SetDirectionality
(
aDir
aNotify
)
;
child
=
child
-
>
GetNextNode
(
aNode
)
;
}
}
void
SetDirectionalityOnDescendants
(
Element
*
aElement
Directionality
aDir
bool
aNotify
)
{
return
SetDirectionalityOnDescendantsInternal
(
aElement
aDir
aNotify
)
;
}
static
void
ResetAutoDirection
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
aElement
-
>
HasDirAuto
(
)
)
;
Directionality
dir
=
ComputeAutoDirectionality
(
aElement
aNotify
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
}
else
{
aElement
-
>
SetDirectionality
(
Directionality
:
:
Ltr
aNotify
)
;
}
SetDirectionalityOnDescendants
(
aElement
aElement
-
>
GetDirectionality
(
)
aNotify
)
;
}
void
WalkAncestorsResetAutoDirection
(
Element
*
aElement
bool
aNotify
)
{
for
(
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aElement
)
;
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
;
parent
=
GetParentOrHostOrSlot
(
parent
)
)
{
auto
*
parentElement
=
Element
:
:
FromNode
(
*
parent
)
;
if
(
parentElement
&
&
parentElement
-
>
HasDirAuto
(
)
)
{
ResetAutoDirection
(
parentElement
aNotify
)
;
break
;
}
}
}
static
void
RecomputeSlottedNodeDirection
(
HTMLSlotElement
&
aSlot
nsINode
&
aNode
)
{
auto
*
assignedElement
=
Element
:
:
FromNode
(
aNode
)
;
if
(
!
assignedElement
)
{
return
;
}
if
(
assignedElement
-
>
HasValidDir
(
)
|
|
assignedElement
-
>
HasDirAuto
(
)
)
{
return
;
}
if
(
assignedElement
-
>
GetDirectionality
(
)
=
=
aSlot
.
GetDirectionality
(
)
)
{
return
;
}
assignedElement
-
>
SetDirectionality
(
aSlot
.
GetDirectionality
(
)
true
)
;
SetDirectionalityOnDescendantsInternal
(
assignedElement
aSlot
.
GetDirectionality
(
)
true
)
;
}
void
SlotAssignedNodeChanged
(
HTMLSlotElement
*
aSlot
nsIContent
&
aAssignedNode
)
{
if
(
!
aSlot
)
{
return
;
}
if
(
aSlot
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
SlotStateChanged
(
aSlot
false
)
;
}
if
(
aAssignedNode
.
GetAssignedSlot
(
)
=
=
aSlot
)
{
RecomputeSlottedNodeDirection
(
*
aSlot
aAssignedNode
)
;
}
}
void
SlotStateChanged
(
HTMLSlotElement
*
aSlot
bool
aAllAssignedNodesChanged
)
{
if
(
!
aSlot
)
{
return
;
}
Directionality
oldDir
=
aSlot
-
>
GetDirectionality
(
)
;
if
(
aSlot
-
>
HasDirAuto
(
)
)
{
ResetAutoDirection
(
aSlot
true
)
;
}
if
(
aSlot
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
WalkAncestorsResetAutoDirection
(
aSlot
true
)
;
}
if
(
aAllAssignedNodesChanged
|
|
oldDir
!
=
aSlot
-
>
GetDirectionality
(
)
)
{
for
(
nsINode
*
node
:
aSlot
-
>
AssignedNodes
(
)
)
{
RecomputeSlottedNodeDirection
(
*
aSlot
*
node
)
;
}
}
}
static
void
SetAncestorHasDirAutoOnDescendants
(
nsINode
*
aRoot
)
;
static
void
MaybeSetAncestorHasDirAutoOnShadowDOM
(
nsINode
*
aNode
)
{
if
(
aNode
-
>
IsElement
(
)
)
{
if
(
ShadowRoot
*
sr
=
aNode
-
>
AsElement
(
)
-
>
GetShadowRoot
(
)
)
{
sr
-
>
SetAncestorHasDirAuto
(
)
;
SetAncestorHasDirAutoOnDescendants
(
sr
)
;
}
}
}
static
void
SetAncestorHasDirAutoOnDescendants
(
nsINode
*
aRoot
)
{
MaybeSetAncestorHasDirAutoOnShadowDOM
(
aRoot
)
;
nsIContent
*
child
=
aRoot
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
IsElement
(
)
&
&
EstablishesOwnDirection
(
child
-
>
AsElement
(
)
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aRoot
)
;
continue
;
}
if
(
!
child
-
>
GetAssignedSlot
(
)
)
{
MaybeSetAncestorHasDirAutoOnShadowDOM
(
child
)
;
child
-
>
SetAncestorHasDirAuto
(
)
;
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
for
(
uint32_t
i
=
0
;
i
<
assignedNodes
.
Length
(
)
;
+
+
i
)
{
assignedNodes
[
i
]
-
>
SetAncestorHasDirAuto
(
)
;
SetAncestorHasDirAutoOnDescendants
(
assignedNodes
[
i
]
)
;
}
}
}
child
=
child
-
>
GetNextNode
(
aRoot
)
;
}
}
void
WalkDescendantsSetDirAuto
(
Element
*
aElement
bool
aNotify
)
{
MOZ_ASSERT
(
aElement
-
>
HasDirAuto
(
)
)
;
if
(
ParticipatesInAutoDirection
(
aElement
)
&
&
!
aElement
-
>
AncestorHasDirAuto
(
)
)
{
SetAncestorHasDirAutoOnDescendants
(
aElement
)
;
}
ResetAutoDirection
(
aElement
aNotify
)
;
}
void
WalkDescendantsClearAncestorDirAuto
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsElement
(
)
)
{
if
(
ShadowRoot
*
shadowRoot
=
aContent
-
>
AsElement
(
)
-
>
GetShadowRoot
(
)
)
{
shadowRoot
-
>
ClearAncestorHasDirAuto
(
)
;
WalkDescendantsClearAncestorDirAuto
(
shadowRoot
)
;
}
}
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
while
(
child
)
{
if
(
child
-
>
GetAssignedSlot
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aContent
)
;
continue
;
}
if
(
child
-
>
IsElement
(
)
)
{
if
(
child
-
>
AsElement
(
)
-
>
HasDirAuto
(
)
)
{
child
=
child
-
>
GetNextNonChildNode
(
aContent
)
;
continue
;
}
if
(
auto
*
slot
=
HTMLSlotElement
:
:
FromNode
(
child
)
)
{
const
nsTArray
<
RefPtr
<
nsINode
>
>
&
assignedNodes
=
slot
-
>
AssignedNodes
(
)
;
for
(
uint32_t
i
=
0
;
i
<
assignedNodes
.
Length
(
)
;
+
+
i
)
{
if
(
assignedNodes
[
i
]
-
>
IsElement
(
)
)
{
Element
*
slottedElement
=
assignedNodes
[
i
]
-
>
AsElement
(
)
;
if
(
slottedElement
-
>
HasDirAuto
(
)
)
{
continue
;
}
}
nsIContent
*
content
=
assignedNodes
[
i
]
-
>
AsContent
(
)
;
content
-
>
ClearAncestorHasDirAuto
(
)
;
WalkDescendantsClearAncestorDirAuto
(
content
)
;
}
}
}
child
-
>
ClearAncestorHasDirAuto
(
)
;
child
=
child
-
>
GetNextNode
(
aContent
)
;
}
}
struct
DirAutoElementResult
{
Element
*
mElement
=
nullptr
;
bool
mAnswerIsDefinitive
=
false
;
}
;
static
DirAutoElementResult
FindDirAutoElementFrom
(
nsIContent
*
aContent
)
{
for
(
nsIContent
*
parent
=
aContent
;
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
;
parent
=
GetParentOrHostOrSlot
(
parent
)
)
{
auto
*
parentElement
=
Element
:
:
FromNode
(
*
parent
)
;
if
(
!
parentElement
)
{
continue
;
}
if
(
!
ParticipatesInAutoDirection
(
parentElement
)
|
|
parentElement
-
>
HasFixedDir
(
)
)
{
return
{
nullptr
true
}
;
}
if
(
parentElement
-
>
HasDirAuto
(
)
)
{
return
{
parentElement
true
}
;
}
}
return
{
nullptr
false
}
;
}
static
DirAutoElementResult
FindDirAutoElementForText
(
Text
*
aTextNode
)
{
MOZ_ASSERT
(
aTextNode
-
>
IsText
(
)
"
Must
be
a
text
node
"
)
;
return
FindDirAutoElementFrom
(
GetParentOrHostOrSlot
(
aTextNode
)
)
;
}
static
DirAutoElementResult
SetAncestorDirectionIfAuto
(
Text
*
aTextNode
Directionality
aDir
bool
aNotify
=
true
)
{
auto
result
=
FindDirAutoElementForText
(
aTextNode
)
;
if
(
Element
*
parentElement
=
result
.
mElement
)
{
if
(
parentElement
-
>
GetDirectionality
(
)
=
=
aDir
)
{
MOZ_ASSERT
(
aDir
!
=
Directionality
:
:
Unset
)
;
aTextNode
-
>
SetMaySetDirAuto
(
)
;
}
else
{
ResetAutoDirection
(
parentElement
aNotify
)
;
}
}
return
result
;
}
bool
TextNodeWillChangeDirection
(
Text
*
aTextNode
Directionality
*
aOldDir
uint32_t
aOffset
)
{
if
(
!
AffectsDirAutoElement
(
aTextNode
)
)
{
return
false
;
}
uint32_t
firstStrong
;
*
aOldDir
=
GetDirectionFromText
(
aTextNode
&
firstStrong
)
;
return
(
aOffset
<
=
firstStrong
)
;
}
void
TextNodeChangedDirection
(
Text
*
aTextNode
Directionality
aOldDir
bool
aNotify
)
{
MOZ_ASSERT
(
AffectsDirAutoElement
(
aTextNode
)
"
Caller
should
check
"
)
;
Directionality
newDir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
newDir
=
=
aOldDir
)
{
return
;
}
if
(
aOldDir
=
=
Directionality
:
:
Unset
|
|
aTextNode
-
>
MaySetDirAuto
(
)
)
{
SetAncestorDirectionIfAuto
(
aTextNode
newDir
aNotify
)
;
}
}
void
SetDirectionFromNewTextNode
(
Text
*
aTextNode
)
{
if
(
!
AffectsDirAutoElement
(
aTextNode
-
>
GetParent
(
)
)
)
{
return
;
}
nsIContent
*
parent
=
GetParentOrHostOrSlot
(
aTextNode
)
;
if
(
parent
&
&
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aTextNode
-
>
SetAncestorHasDirAuto
(
)
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
dir
!
=
Directionality
:
:
Unset
)
{
SetAncestorDirectionIfAuto
(
aTextNode
dir
)
;
}
}
void
ResetDirectionSetByTextNode
(
Text
*
aTextNode
dom
:
:
UnbindContext
&
aContext
)
{
MOZ_ASSERT
(
!
aTextNode
-
>
IsInComposedDoc
(
)
"
Should
be
disconnected
already
"
)
;
if
(
!
aTextNode
-
>
MaySetDirAuto
(
)
)
{
return
;
}
auto
result
=
FindDirAutoElementForText
(
aTextNode
)
;
if
(
result
.
mAnswerIsDefinitive
)
{
return
;
}
MOZ_ASSERT
(
!
result
.
mElement
)
;
aTextNode
-
>
ClearMaySetDirAuto
(
)
;
auto
*
unboundFrom
=
nsIContent
:
:
FromNodeOrNull
(
aContext
.
GetOriginalSubtreeParent
(
)
)
;
if
(
!
unboundFrom
|
|
!
AffectsDirAutoElement
(
unboundFrom
)
)
{
return
;
}
Directionality
dir
=
GetDirectionFromText
(
aTextNode
)
;
if
(
dir
=
=
Directionality
:
:
Unset
)
{
return
;
}
result
=
FindDirAutoElementFrom
(
unboundFrom
)
;
if
(
!
result
.
mElement
|
|
result
.
mElement
-
>
GetDirectionality
(
)
!
=
dir
)
{
return
;
}
ResetAutoDirection
(
result
.
mElement
true
)
;
}
void
SetDirectionalityFromValue
(
Element
*
aElement
const
nsAString
&
value
bool
aNotify
)
{
Directionality
dir
=
GetDirectionFromText
(
value
.
BeginReading
(
)
value
.
Length
(
)
)
;
if
(
dir
=
=
Directionality
:
:
Unset
)
{
dir
=
Directionality
:
:
Ltr
;
}
if
(
aElement
-
>
GetDirectionality
(
)
!
=
dir
)
{
aElement
-
>
SetDirectionality
(
dir
aNotify
)
;
}
}
void
OnSetDirAttr
(
Element
*
aElement
const
nsAttrValue
*
aNewValue
bool
hadValidDir
bool
hadDirAuto
bool
aNotify
)
{
if
(
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
input
nsGkAtoms
:
:
textarea
)
)
{
return
;
}
if
(
(
hadDirAuto
|
|
hadValidDir
)
&
&
!
EstablishesOwnDirection
(
aElement
)
)
{
if
(
auto
*
parent
=
aElement
-
>
GetParent
(
)
)
{
if
(
parent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
SetAncestorHasDirAutoOnDescendants
(
parent
)
;
}
}
}
if
(
AffectsDirAutoElement
(
aElement
)
)
{
WalkAncestorsResetAutoDirection
(
aElement
aNotify
)
;
}
else
if
(
hadDirAuto
&
&
!
aElement
-
>
HasDirAuto
(
)
)
{
WalkDescendantsClearAncestorDirAuto
(
aElement
)
;
}
if
(
aElement
-
>
HasDirAuto
(
)
)
{
WalkDescendantsSetDirAuto
(
aElement
aNotify
)
;
}
else
{
SetDirectionalityOnDescendants
(
aElement
RecomputeDirectionality
(
aElement
aNotify
)
aNotify
)
;
}
}
void
SetDirOnBind
(
Element
*
aElement
nsIContent
*
aParent
)
{
if
(
ParticipatesInAutoDirection
(
aElement
)
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
bdi
)
&
&
aParent
&
&
aParent
-
>
NodeOrAncestorHasDirAuto
(
)
)
{
aElement
-
>
SetAncestorHasDirAuto
(
)
;
SetAncestorHasDirAutoOnDescendants
(
aElement
)
;
if
(
aElement
-
>
GetFirstChild
(
)
|
|
aElement
-
>
GetShadowRoot
(
)
)
{
WalkAncestorsResetAutoDirection
(
aElement
true
)
;
}
}
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
RecomputeDirectionality
(
aElement
false
)
;
}
}
void
ResetDir
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
HasDirAuto
(
)
)
{
RecomputeDirectionality
(
aElement
false
)
;
}
}
}
