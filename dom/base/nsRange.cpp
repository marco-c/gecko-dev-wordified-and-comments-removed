#
include
"
nscore
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsINodeList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
mozilla
/
dom
/
InspectorFontFace
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
JSObject
*
nsRange
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Range_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
DocGroup
*
nsRange
:
:
GetDocGroup
(
)
const
{
return
mOwner
?
mOwner
-
>
GetDocGroup
(
)
:
nullptr
;
}
static
void
InvalidateAllFrames
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
bad
arg
"
)
;
nsIFrame
*
frame
=
nullptr
;
switch
(
aNode
-
>
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
ELEMENT_NODE
:
{
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
aNode
)
;
frame
=
content
-
>
GetPrimaryFrame
(
)
;
break
;
}
case
nsINode
:
:
DOCUMENT_NODE
:
{
nsIDocument
*
doc
=
static_cast
<
nsIDocument
*
>
(
aNode
)
;
nsIPresShell
*
shell
=
doc
?
doc
-
>
GetShell
(
)
:
nullptr
;
frame
=
shell
?
shell
-
>
GetRootFrame
(
)
:
nullptr
;
break
;
}
}
for
(
nsIFrame
*
f
=
frame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
f
-
>
InvalidateFrameSubtree
(
)
;
}
}
nsresult
nsRange
:
:
CompareNodeToRange
(
nsINode
*
aNode
nsRange
*
aRange
bool
*
outNodeBefore
bool
*
outNodeAfter
)
{
NS_ENSURE_STATE
(
aNode
)
;
if
(
!
aRange
|
|
!
aRange
-
>
IsPositioned
(
)
)
return
NS_ERROR_UNEXPECTED
;
int32_t
nodeStart
nodeEnd
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
parent
=
aNode
;
nodeStart
=
0
;
uint32_t
childCount
=
aNode
-
>
GetChildCount
(
)
;
MOZ_ASSERT
(
childCount
<
=
INT32_MAX
"
There
shouldn
'
t
be
over
INT32_MAX
children
"
)
;
nodeEnd
=
static_cast
<
int32_t
>
(
childCount
)
;
}
else
{
nodeStart
=
parent
-
>
ComputeIndexOf
(
aNode
)
;
nodeEnd
=
nodeStart
+
1
;
MOZ_ASSERT
(
nodeStart
<
nodeEnd
"
nodeStart
shouldn
'
t
be
INT32_MAX
"
)
;
}
nsINode
*
rangeStartContainer
=
aRange
-
>
GetStartContainer
(
)
;
nsINode
*
rangeEndContainer
=
aRange
-
>
GetEndContainer
(
)
;
uint32_t
rangeStartOffset
=
aRange
-
>
StartOffset
(
)
;
uint32_t
rangeEndOffset
=
aRange
-
>
EndOffset
(
)
;
bool
disconnected
=
false
;
*
outNodeBefore
=
nsContentUtils
:
:
ComparePoints
(
rangeStartContainer
static_cast
<
int32_t
>
(
rangeStartOffset
)
parent
nodeStart
&
disconnected
)
>
0
;
NS_ENSURE_TRUE
(
!
disconnected
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
*
outNodeAfter
=
nsContentUtils
:
:
ComparePoints
(
rangeEndContainer
static_cast
<
int32_t
>
(
rangeEndOffset
)
parent
nodeEnd
&
disconnected
)
<
0
;
NS_ENSURE_TRUE
(
!
disconnected
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
return
NS_OK
;
}
static
nsINode
*
GetNextRangeCommonAncestor
(
nsINode
*
aNode
)
{
while
(
aNode
&
&
!
aNode
-
>
IsCommonAncestorForRangeInSelection
(
)
)
{
if
(
!
aNode
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
return
nullptr
;
}
aNode
=
aNode
-
>
GetParentNode
(
)
;
}
return
aNode
;
}
struct
IsItemInRangeComparator
{
nsINode
*
mNode
;
uint32_t
mStartOffset
;
uint32_t
mEndOffset
;
int
operator
(
)
(
const
nsRange
*
const
aRange
)
const
{
int32_t
cmp
=
nsContentUtils
:
:
ComparePoints
(
mNode
static_cast
<
int32_t
>
(
mEndOffset
)
aRange
-
>
GetStartContainer
(
)
static_cast
<
int32_t
>
(
aRange
-
>
StartOffset
(
)
)
)
;
if
(
cmp
=
=
1
)
{
cmp
=
nsContentUtils
:
:
ComparePoints
(
mNode
static_cast
<
int32_t
>
(
mStartOffset
)
aRange
-
>
GetEndContainer
(
)
static_cast
<
int32_t
>
(
aRange
-
>
EndOffset
(
)
)
)
;
if
(
cmp
=
=
-
1
)
{
return
0
;
}
return
1
;
}
return
-
1
;
}
}
;
bool
nsRange
:
:
IsNodeSelected
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
{
MOZ_ASSERT
(
aNode
"
bad
arg
"
)
;
nsINode
*
n
=
GetNextRangeCommonAncestor
(
aNode
)
;
NS_ASSERTION
(
n
|
|
!
aNode
-
>
IsSelectionDescendant
(
)
"
orphan
selection
descendant
"
)
;
nsTHashtable
<
nsPtrHashKey
<
Selection
>
>
ancestorSelections
;
Selection
*
prevSelection
=
nullptr
;
uint32_t
maxRangeCount
=
0
;
for
(
;
n
;
n
=
GetNextRangeCommonAncestor
(
n
-
>
GetParentNode
(
)
)
)
{
LinkedList
<
nsRange
>
*
ranges
=
n
-
>
GetExistingCommonAncestorRanges
(
)
;
if
(
!
ranges
)
{
continue
;
}
for
(
nsRange
*
range
:
*
ranges
)
{
MOZ_ASSERT
(
range
-
>
IsInSelection
(
)
"
Why
is
this
range
registeed
with
a
node
?
"
)
;
if
(
range
-
>
IsInSelection
(
)
)
{
Selection
*
selection
=
range
-
>
mSelection
;
if
(
prevSelection
!
=
selection
)
{
prevSelection
=
selection
;
ancestorSelections
.
PutEntry
(
selection
)
;
}
maxRangeCount
=
std
:
:
max
(
maxRangeCount
selection
-
>
RangeCount
(
)
)
;
}
}
}
IsItemInRangeComparator
comparator
=
{
aNode
aStartOffset
aEndOffset
}
;
if
(
!
ancestorSelections
.
IsEmpty
(
)
)
{
for
(
auto
iter
=
ancestorSelections
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Selection
*
selection
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
size_t
low
=
0
;
size_t
high
=
selection
-
>
RangeCount
(
)
;
while
(
high
!
=
low
)
{
size_t
middle
=
low
+
(
high
-
low
)
/
2
;
const
nsRange
*
const
range
=
selection
-
>
GetRangeAt
(
middle
)
;
int
result
=
comparator
(
range
)
;
if
(
result
=
=
0
)
{
if
(
!
range
-
>
Collapsed
(
)
)
return
true
;
const
nsRange
*
middlePlus1
;
const
nsRange
*
middleMinus1
;
if
(
middle
+
1
<
high
&
&
(
middlePlus1
=
selection
-
>
GetRangeAt
(
middle
+
1
)
)
&
&
nsContentUtils
:
:
ComparePoints
(
aNode
static_cast
<
int32_t
>
(
aEndOffset
)
middlePlus1
-
>
GetStartContainer
(
)
static_cast
<
int32_t
>
(
middlePlus1
-
>
StartOffset
(
)
)
)
>
0
)
{
result
=
1
;
}
else
if
(
middle
>
=
1
&
&
(
middleMinus1
=
selection
-
>
GetRangeAt
(
middle
-
1
)
)
&
&
nsContentUtils
:
:
ComparePoints
(
aNode
static_cast
<
int32_t
>
(
aStartOffset
)
middleMinus1
-
>
GetEndContainer
(
)
static_cast
<
int32_t
>
(
middleMinus1
-
>
EndOffset
(
)
)
)
<
0
)
{
result
=
-
1
;
}
else
{
break
;
}
}
if
(
result
<
0
)
{
high
=
middle
;
}
else
{
low
=
middle
+
1
;
}
}
}
}
return
false
;
}
nsRange
:
:
~
nsRange
(
)
{
NS_ASSERTION
(
!
IsInSelection
(
)
"
deleting
nsRange
that
is
in
use
"
)
;
DoSetRange
(
RawRangeBoundary
(
)
RawRangeBoundary
(
)
nullptr
)
;
}
nsRange
:
:
nsRange
(
nsINode
*
aNode
)
:
mRoot
(
nullptr
)
mRegisteredCommonAncestor
(
nullptr
)
mNextStartRef
(
nullptr
)
mNextEndRef
(
nullptr
)
mIsPositioned
(
false
)
mIsGenerated
(
false
)
mCalledByJS
(
false
)
{
MOZ_ASSERT
(
aNode
"
range
isn
'
t
in
a
document
!
"
)
;
mOwner
=
aNode
-
>
OwnerDoc
(
)
;
}
nsresult
nsRange
:
:
CreateRange
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndParent
uint32_t
aEndOffset
nsRange
*
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
*
aRange
=
nullptr
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aStartContainer
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aStartContainer
aStartOffset
aEndParent
aEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
range
.
forget
(
aRange
)
;
return
NS_OK
;
}
nsresult
nsRange
:
:
CreateRange
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
nsRange
*
*
aRange
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aStart
.
Container
(
)
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aStart
aEnd
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
range
.
forget
(
aRange
)
;
return
NS_OK
;
}
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_ADDREF
(
nsRange
)
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsRange
DoSetRange
(
RawRangeBoundary
(
)
RawRangeBoundary
(
)
nullptr
)
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsRange
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOwner
)
;
if
(
tmp
-
>
mRegisteredCommonAncestor
)
{
tmp
-
>
UnregisterCommonAncestor
(
tmp
-
>
mRegisteredCommonAncestor
true
)
;
}
tmp
-
>
Reset
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
tmp
-
>
isInList
(
)
"
Shouldn
'
t
be
registered
now
that
we
'
re
unlinking
"
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelection
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOwner
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStart
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEnd
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRoot
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
static
void
MarkDescendants
(
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsSelectionDescendant
(
)
)
{
nsINode
*
node
=
aNode
-
>
GetNextNode
(
aNode
)
;
while
(
node
)
{
node
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
if
(
!
node
-
>
IsCommonAncestorForRangeInSelection
(
)
)
{
node
=
node
-
>
GetNextNode
(
aNode
)
;
}
else
{
node
=
node
-
>
GetNextNonChildNode
(
aNode
)
;
}
}
}
}
static
void
UnmarkDescendants
(
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
nsINode
*
node
=
aNode
-
>
GetNextNode
(
aNode
)
;
while
(
node
)
{
node
-
>
ClearDescendantOfCommonAncestorForRangeInSelection
(
)
;
if
(
!
node
-
>
IsCommonAncestorForRangeInSelection
(
)
)
{
node
=
node
-
>
GetNextNode
(
aNode
)
;
}
else
{
node
=
node
-
>
GetNextNonChildNode
(
aNode
)
;
}
}
}
}
void
nsRange
:
:
RegisterCommonAncestor
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
bad
arg
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsInSelection
(
)
"
registering
range
not
in
selection
"
)
;
mRegisteredCommonAncestor
=
aNode
;
MarkDescendants
(
aNode
)
;
UniquePtr
<
LinkedList
<
nsRange
>
>
&
ranges
=
aNode
-
>
GetCommonAncestorRangesPtr
(
)
;
if
(
!
ranges
)
{
ranges
=
MakeUnique
<
LinkedList
<
nsRange
>
>
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
isInList
(
)
)
;
ranges
-
>
insertBack
(
this
)
;
aNode
-
>
SetCommonAncestorForRangeInSelection
(
)
;
}
void
nsRange
:
:
UnregisterCommonAncestor
(
nsINode
*
aNode
bool
aIsUnlinking
)
{
MOZ_ASSERT
(
aNode
"
bad
arg
"
)
;
NS_ASSERTION
(
aNode
-
>
IsCommonAncestorForRangeInSelection
(
)
"
wrong
node
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aNode
=
=
mRegisteredCommonAncestor
"
wrong
node
"
)
;
LinkedList
<
nsRange
>
*
ranges
=
aNode
-
>
GetExistingCommonAncestorRanges
(
)
;
MOZ_ASSERT
(
ranges
)
;
mRegisteredCommonAncestor
=
nullptr
;
#
ifdef
DEBUG
bool
found
=
false
;
for
(
nsRange
*
range
:
*
ranges
)
{
if
(
range
=
=
this
)
{
found
=
true
;
break
;
}
}
MOZ_ASSERT
(
found
"
We
should
be
in
the
list
on
our
registered
common
ancestor
"
)
;
#
endif
remove
(
)
;
if
(
!
aIsUnlinking
&
&
ranges
-
>
isEmpty
(
)
)
{
aNode
-
>
ClearCommonAncestorForRangeInSelection
(
)
;
UnmarkDescendants
(
aNode
)
;
}
}
void
nsRange
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
MOZ_ASSERT
(
!
mNextEndRef
)
;
MOZ_ASSERT
(
!
mNextStartRef
)
;
MOZ_ASSERT
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
nsINode
*
newRoot
=
nullptr
;
RawRangeBoundary
newStart
;
RawRangeBoundary
newEnd
;
if
(
aInfo
.
mDetails
&
&
aInfo
.
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
)
{
nsINode
*
parentNode
=
aContent
-
>
GetParentNode
(
)
;
if
(
parentNode
=
=
mEnd
.
Container
(
)
)
{
if
(
aContent
=
=
mEnd
.
Ref
(
)
)
{
MOZ_ASSERT
(
aInfo
.
mDetails
-
>
mNextSibling
)
;
mNextEndRef
=
aInfo
.
mDetails
-
>
mNextSibling
;
}
}
if
(
parentNode
=
=
mStart
.
Container
(
)
)
{
if
(
aContent
=
=
mStart
.
Ref
(
)
)
{
MOZ_ASSERT
(
aInfo
.
mDetails
-
>
mNextSibling
)
;
mNextStartRef
=
aInfo
.
mDetails
-
>
mNextSibling
;
}
}
}
if
(
aContent
=
=
mStart
.
Container
(
)
&
&
aInfo
.
mChangeStart
<
mStart
.
Offset
(
)
)
{
if
(
aInfo
.
mDetails
)
{
NS_ASSERTION
(
aInfo
.
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
"
only
a
split
can
start
before
the
end
"
)
;
NS_ASSERTION
(
mStart
.
Offset
(
)
<
=
aInfo
.
mChangeEnd
+
1
"
mStart
.
Offset
(
)
is
beyond
the
end
of
this
node
"
)
;
int32_t
newStartOffset
=
mStart
.
Offset
(
)
-
aInfo
.
mChangeStart
;
newStart
.
Set
(
aInfo
.
mDetails
-
>
mNextSibling
newStartOffset
)
;
if
(
MOZ_UNLIKELY
(
aContent
=
=
mRoot
)
)
{
newRoot
=
IsValidBoundary
(
newStart
.
Container
(
)
)
;
}
bool
isCommonAncestor
=
IsInSelection
(
)
&
&
mStart
.
Container
(
)
=
=
mEnd
.
Container
(
)
;
if
(
isCommonAncestor
)
{
UnregisterCommonAncestor
(
mStart
.
Container
(
)
false
)
;
RegisterCommonAncestor
(
newStart
.
Container
(
)
)
;
}
if
(
mStart
.
Container
(
)
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
newStart
.
Container
(
)
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
}
else
{
int32_t
newStartOffset
=
mStart
.
Offset
(
)
<
=
aInfo
.
mChangeEnd
?
aInfo
.
mChangeStart
:
mStart
.
Offset
(
)
+
aInfo
.
mChangeStart
-
aInfo
.
mChangeEnd
+
aInfo
.
mReplaceLength
;
newStart
.
Set
(
mStart
.
Container
(
)
newStartOffset
)
;
}
}
if
(
aContent
=
=
mEnd
.
Container
(
)
&
&
aInfo
.
mChangeStart
<
mEnd
.
Offset
(
)
)
{
if
(
aInfo
.
mDetails
&
&
(
aContent
-
>
GetParentNode
(
)
|
|
newStart
.
Container
(
)
)
)
{
NS_ASSERTION
(
aInfo
.
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
"
only
a
split
can
start
before
the
end
"
)
;
NS_ASSERTION
(
mEnd
.
Offset
(
)
<
=
aInfo
.
mChangeEnd
+
1
"
mEnd
.
Offset
(
)
is
beyond
the
end
of
this
node
"
)
;
newEnd
.
Set
(
aInfo
.
mDetails
-
>
mNextSibling
mEnd
.
Offset
(
)
-
aInfo
.
mChangeStart
)
;
bool
isCommonAncestor
=
IsInSelection
(
)
&
&
mStart
.
Container
(
)
=
=
mEnd
.
Container
(
)
;
if
(
isCommonAncestor
&
&
!
newStart
.
Container
(
)
)
{
UnregisterCommonAncestor
(
mStart
.
Container
(
)
false
)
;
RegisterCommonAncestor
(
mStart
.
Container
(
)
-
>
GetParentNode
(
)
)
;
newEnd
.
Container
(
)
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
else
if
(
mEnd
.
Container
(
)
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
newEnd
.
Container
(
)
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
}
else
{
int32_t
newEndOffset
=
mEnd
.
Offset
(
)
<
=
aInfo
.
mChangeEnd
?
aInfo
.
mChangeStart
:
mEnd
.
Offset
(
)
+
aInfo
.
mChangeStart
-
aInfo
.
mChangeEnd
+
aInfo
.
mReplaceLength
;
newEnd
.
Set
(
mEnd
.
Container
(
)
newEndOffset
)
;
}
}
if
(
aInfo
.
mDetails
&
&
aInfo
.
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eMerge
)
{
nsIContent
*
removed
=
aInfo
.
mDetails
-
>
mNextSibling
;
if
(
removed
=
=
mStart
.
Container
(
)
)
{
newStart
.
Set
(
aContent
mStart
.
Offset
(
)
+
aInfo
.
mChangeStart
)
;
if
(
MOZ_UNLIKELY
(
removed
=
=
mRoot
)
)
{
newRoot
=
IsValidBoundary
(
newStart
.
Container
(
)
)
;
}
}
if
(
removed
=
=
mEnd
.
Container
(
)
)
{
newEnd
.
Set
(
aContent
mEnd
.
Offset
(
)
+
aInfo
.
mChangeStart
)
;
if
(
MOZ_UNLIKELY
(
removed
=
=
mRoot
)
)
{
newRoot
=
IsValidBoundary
(
newEnd
.
Container
(
)
)
;
}
}
nsINode
*
parentNode
=
aContent
-
>
GetParentNode
(
)
;
if
(
parentNode
=
=
mStart
.
Container
(
)
&
&
mStart
.
Offset
(
)
>
0
&
&
mStart
.
Offset
(
)
<
parentNode
-
>
GetChildCount
(
)
&
&
removed
=
=
mStart
.
GetChildAtOffset
(
)
)
{
newStart
.
Set
(
aContent
aInfo
.
mChangeStart
)
;
}
if
(
parentNode
=
=
mEnd
.
Container
(
)
&
&
mEnd
.
Offset
(
)
>
0
&
&
mEnd
.
Offset
(
)
<
parentNode
-
>
GetChildCount
(
)
&
&
removed
=
=
mEnd
.
GetChildAtOffset
(
)
)
{
newEnd
.
Set
(
aContent
aInfo
.
mChangeEnd
)
;
}
}
if
(
newStart
.
IsSet
(
)
|
|
newEnd
.
IsSet
(
)
)
{
if
(
!
newStart
.
IsSet
(
)
)
{
newStart
=
mStart
;
}
if
(
!
newEnd
.
IsSet
(
)
)
{
newEnd
=
mEnd
;
}
DoSetRange
(
newStart
newEnd
newRoot
?
newRoot
:
mRoot
.
get
(
)
!
newEnd
.
Container
(
)
-
>
GetParentNode
(
)
|
|
!
newStart
.
Container
(
)
-
>
GetParentNode
(
)
)
;
}
}
void
nsRange
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
NS_ASSERTION
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
nsINode
*
container
=
aFirstNewContent
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
if
(
container
-
>
IsSelectionDescendant
(
)
&
&
IsInSelection
(
)
)
{
nsINode
*
child
=
aFirstNewContent
;
while
(
child
)
{
if
(
!
child
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
MarkDescendants
(
child
)
;
child
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
}
if
(
mNextStartRef
|
|
mNextEndRef
)
{
if
(
mNextStartRef
)
{
mStart
.
SetAfterRef
(
mStart
.
Container
(
)
mNextStartRef
)
;
MOZ_ASSERT
(
mNextStartRef
=
=
aFirstNewContent
)
;
mNextStartRef
=
nullptr
;
}
if
(
mNextEndRef
)
{
mEnd
.
SetAfterRef
(
mEnd
.
Container
(
)
mNextEndRef
)
;
MOZ_ASSERT
(
mNextEndRef
=
=
aFirstNewContent
)
;
mNextEndRef
=
nullptr
;
}
DoSetRange
(
mStart
.
AsRaw
(
)
mEnd
.
AsRaw
(
)
mRoot
true
)
;
}
}
void
nsRange
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
bool
updateBoundaries
=
false
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
RawRangeBoundary
newStart
(
mStart
)
;
RawRangeBoundary
newEnd
(
mEnd
)
;
MOZ_ASSERT
(
aChild
-
>
GetParentNode
(
)
=
=
container
)
;
if
(
container
=
=
mStart
.
Container
(
)
)
{
newStart
.
InvalidateOffset
(
)
;
updateBoundaries
=
true
;
}
if
(
container
=
=
mEnd
.
Container
(
)
)
{
newEnd
.
InvalidateOffset
(
)
;
updateBoundaries
=
true
;
}
if
(
container
-
>
IsSelectionDescendant
(
)
&
&
!
aChild
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
MarkDescendants
(
aChild
)
;
aChild
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
if
(
mNextStartRef
|
|
mNextEndRef
)
{
if
(
mNextStartRef
)
{
newStart
.
SetAfterRef
(
mStart
.
Container
(
)
mNextStartRef
)
;
MOZ_ASSERT
(
mNextStartRef
=
=
aChild
)
;
mNextStartRef
=
nullptr
;
}
if
(
mNextEndRef
)
{
newEnd
.
SetAfterRef
(
mEnd
.
Container
(
)
mNextEndRef
)
;
MOZ_ASSERT
(
mNextEndRef
=
=
aChild
)
;
mNextEndRef
=
nullptr
;
}
updateBoundaries
=
true
;
}
if
(
updateBoundaries
)
{
DoSetRange
(
newStart
newEnd
mRoot
)
;
}
}
void
nsRange
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
MOZ_ASSERT
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
container
)
;
RawRangeBoundary
newStart
;
RawRangeBoundary
newEnd
;
Maybe
<
bool
>
gravitateStart
;
bool
gravitateEnd
;
if
(
container
=
=
mStart
.
Container
(
)
)
{
if
(
aChild
=
=
mStart
.
Ref
(
)
)
{
newStart
.
SetAfterRef
(
container
aPreviousSibling
)
;
}
else
{
newStart
=
mStart
;
newStart
.
InvalidateOffset
(
)
;
}
}
else
{
gravitateStart
=
Some
(
nsContentUtils
:
:
ContentIsDescendantOf
(
mStart
.
Container
(
)
aChild
)
)
;
if
(
gravitateStart
.
value
(
)
)
{
newStart
.
SetAfterRef
(
container
aPreviousSibling
)
;
}
}
if
(
container
=
=
mEnd
.
Container
(
)
)
{
if
(
aChild
=
=
mEnd
.
Ref
(
)
)
{
newEnd
.
SetAfterRef
(
container
aPreviousSibling
)
;
}
else
{
newEnd
=
mEnd
;
newEnd
.
InvalidateOffset
(
)
;
}
}
else
{
if
(
mStart
.
Container
(
)
=
=
mEnd
.
Container
(
)
&
&
gravitateStart
.
isSome
(
)
)
{
gravitateEnd
=
gravitateStart
.
value
(
)
;
}
else
{
gravitateEnd
=
nsContentUtils
:
:
ContentIsDescendantOf
(
mEnd
.
Container
(
)
aChild
)
;
}
if
(
gravitateEnd
)
{
newEnd
.
SetAfterRef
(
container
aPreviousSibling
)
;
}
}
if
(
newStart
.
IsSet
(
)
|
|
newEnd
.
IsSet
(
)
)
{
DoSetRange
(
newStart
.
IsSet
(
)
?
newStart
:
mStart
.
AsRaw
(
)
newEnd
.
IsSet
(
)
?
newEnd
:
mEnd
.
AsRaw
(
)
mRoot
)
;
}
MOZ_ASSERT
(
mStart
.
Ref
(
)
!
=
aChild
)
;
MOZ_ASSERT
(
mEnd
.
Ref
(
)
!
=
aChild
)
;
if
(
container
-
>
IsSelectionDescendant
(
)
&
&
aChild
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
aChild
-
>
ClearDescendantOfCommonAncestorForRangeInSelection
(
)
;
UnmarkDescendants
(
aChild
)
;
}
}
void
nsRange
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
NS_ASSERTION
(
mRoot
=
=
aContent
"
Wrong
ParentChainChanged
notification
?
"
)
;
nsINode
*
newRoot
=
IsValidBoundary
(
mStart
.
Container
(
)
)
;
NS_ASSERTION
(
newRoot
"
No
valid
boundary
or
root
found
!
"
)
;
if
(
newRoot
!
=
IsValidBoundary
(
mEnd
.
Container
(
)
)
)
{
NS_ASSERTION
(
mEnd
.
Container
(
)
-
>
IsInNativeAnonymousSubtree
(
)
"
This
special
case
should
happen
only
with
"
"
native
-
anonymous
content
"
)
;
Reset
(
)
;
return
;
}
DoSetRange
(
mStart
.
AsRaw
(
)
mEnd
.
AsRaw
(
)
newRoot
)
;
}
bool
nsRange
:
:
IsPointInRange
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aRv
)
{
uint16_t
compareResult
=
ComparePoint
(
aPoint
aRv
)
;
if
(
aRv
.
ErrorCodeIs
(
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
)
{
aRv
.
SuppressException
(
)
;
return
false
;
}
return
compareResult
=
=
0
;
}
int16_t
nsRange
:
:
ComparePoint
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aRv
)
{
if
(
NS_WARN_IF
(
!
aPoint
.
IsSet
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
0
;
}
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
aPoint
.
Container
(
)
mRoot
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
return
0
;
}
if
(
aPoint
.
Container
(
)
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
0
;
}
if
(
aPoint
.
Offset
(
)
>
aPoint
.
Container
(
)
-
>
Length
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
0
;
}
int32_t
cmp
=
nsContentUtils
:
:
ComparePoints
(
aPoint
mStart
.
AsRaw
(
)
)
;
if
(
cmp
<
=
0
)
{
return
cmp
;
}
if
(
nsContentUtils
:
:
ComparePoints
(
mEnd
.
AsRaw
(
)
aPoint
)
=
=
-
1
)
{
return
1
;
}
return
0
;
}
bool
nsRange
:
:
IntersectsNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
false
;
}
nsINode
*
parent
=
aNode
.
GetParentNode
(
)
;
if
(
!
parent
)
{
return
GetRoot
(
)
=
=
&
aNode
;
}
int32_t
nodeIndex
=
parent
-
>
ComputeIndexOf
(
&
aNode
)
;
bool
disconnected
=
false
;
bool
result
=
nsContentUtils
:
:
ComparePoints
(
mStart
.
Container
(
)
mStart
.
Offset
(
)
parent
nodeIndex
+
1
&
disconnected
)
<
0
&
&
nsContentUtils
:
:
ComparePoints
(
parent
nodeIndex
mEnd
.
Container
(
)
mEnd
.
Offset
(
)
&
disconnected
)
<
0
;
if
(
disconnected
)
{
result
=
false
;
}
return
result
;
}
void
nsRange
:
:
NotifySelectionListenersAfterRangeSet
(
)
{
if
(
mSelection
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
false
;
RefPtr
<
Selection
>
selection
=
mSelection
;
selection
-
>
NotifySelectionListeners
(
calledByJSRestorer
.
SavedValue
(
)
)
;
}
}
void
nsRange
:
:
DoSetRange
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
nsINode
*
aRoot
bool
aNotInsertedYet
)
{
MOZ_ASSERT
(
(
aStart
.
IsSet
(
)
&
&
aEnd
.
IsSet
(
)
&
&
aRoot
)
|
|
(
!
aStart
.
IsSet
(
)
&
&
!
aEnd
.
IsSet
(
)
&
&
!
aRoot
)
"
Set
all
or
none
"
)
;
MOZ_ASSERT
(
!
aRoot
|
|
aNotInsertedYet
|
|
(
nsContentUtils
:
:
ContentIsDescendantOf
(
aStart
.
Container
(
)
aRoot
)
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
aEnd
.
Container
(
)
aRoot
)
&
&
aRoot
=
=
IsValidBoundary
(
aStart
.
Container
(
)
)
&
&
aRoot
=
=
IsValidBoundary
(
aEnd
.
Container
(
)
)
)
"
Wrong
root
"
)
;
MOZ_ASSERT
(
!
aRoot
|
|
(
aStart
.
Container
(
)
-
>
IsContent
(
)
&
&
aEnd
.
Container
(
)
-
>
IsContent
(
)
&
&
aRoot
=
=
static_cast
<
nsIContent
*
>
(
aStart
.
Container
(
)
)
-
>
GetBindingParent
(
)
&
&
aRoot
=
=
static_cast
<
nsIContent
*
>
(
aEnd
.
Container
(
)
)
-
>
GetBindingParent
(
)
)
|
|
(
!
aRoot
-
>
GetParentNode
(
)
&
&
(
aRoot
-
>
IsDocument
(
)
|
|
aRoot
-
>
IsAttr
(
)
|
|
aRoot
-
>
IsDocumentFragment
(
)
|
|
aRoot
-
>
IsContent
(
)
)
)
"
Bad
root
"
)
;
if
(
mRoot
!
=
aRoot
)
{
if
(
mRoot
)
{
mRoot
-
>
RemoveMutationObserver
(
this
)
;
}
if
(
aRoot
)
{
aRoot
-
>
AddMutationObserver
(
this
)
;
}
}
bool
checkCommonAncestor
=
(
mStart
.
Container
(
)
!
=
aStart
.
Container
(
)
|
|
mEnd
.
Container
(
)
!
=
aEnd
.
Container
(
)
)
&
&
IsInSelection
(
)
&
&
!
aNotInsertedYet
;
mStart
=
aStart
;
mEnd
=
aEnd
;
mIsPositioned
=
!
!
mStart
.
Container
(
)
;
if
(
checkCommonAncestor
)
{
nsINode
*
oldCommonAncestor
=
mRegisteredCommonAncestor
;
nsINode
*
newCommonAncestor
=
GetCommonAncestor
(
)
;
if
(
newCommonAncestor
!
=
oldCommonAncestor
)
{
if
(
oldCommonAncestor
)
{
UnregisterCommonAncestor
(
oldCommonAncestor
false
)
;
}
if
(
newCommonAncestor
)
{
RegisterCommonAncestor
(
newCommonAncestor
)
;
}
else
{
NS_ASSERTION
(
!
mIsPositioned
"
unexpected
disconnected
nodes
"
)
;
mSelection
=
nullptr
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mRegisteredCommonAncestor
"
How
can
we
have
a
registered
common
ancestor
when
we
"
"
didn
'
t
register
ourselves
?
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
isInList
(
)
"
Shouldn
'
t
be
registered
if
we
have
no
"
"
mRegisteredCommonAncestor
"
)
;
}
}
}
mRoot
=
aRoot
;
if
(
mSelection
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
NotifySelectionListenersAfterRangeSet
"
this
&
nsRange
:
:
NotifySelectionListenersAfterRangeSet
)
)
;
}
}
static
int32_t
IndexOf
(
nsINode
*
aChild
)
{
nsINode
*
parent
=
aChild
-
>
GetParentNode
(
)
;
return
parent
?
parent
-
>
ComputeIndexOf
(
aChild
)
:
-
1
;
}
void
nsRange
:
:
SetSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
)
{
if
(
mSelection
=
=
aSelection
)
{
return
;
}
MOZ_ASSERT
(
!
aSelection
|
|
!
mSelection
)
;
if
(
aSelection
&
&
mSelection
)
{
mSelection
-
>
RemoveRange
(
*
this
IgnoreErrors
(
)
)
;
}
mSelection
=
aSelection
;
if
(
mSelection
)
{
nsINode
*
commonAncestor
=
GetCommonAncestor
(
)
;
NS_ASSERTION
(
commonAncestor
"
unexpected
disconnected
nodes
"
)
;
RegisterCommonAncestor
(
commonAncestor
)
;
}
else
{
UnregisterCommonAncestor
(
mRegisteredCommonAncestor
false
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mRegisteredCommonAncestor
"
How
can
we
have
a
registered
common
ancestor
when
we
"
"
just
unregistered
?
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
isInList
(
)
"
Shouldn
'
t
be
registered
if
we
have
no
"
"
mRegisteredCommonAncestor
after
unregistering
"
)
;
}
}
nsINode
*
nsRange
:
:
GetCommonAncestor
(
)
const
{
return
mIsPositioned
?
nsContentUtils
:
:
GetCommonAncestor
(
mStart
.
Container
(
)
mEnd
.
Container
(
)
)
:
nullptr
;
}
void
nsRange
:
:
Reset
(
)
{
DoSetRange
(
RawRangeBoundary
(
)
RawRangeBoundary
(
)
nullptr
)
;
}
nsINode
*
nsRange
:
:
GetStartContainer
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
return
mStart
.
Container
(
)
;
}
uint32_t
nsRange
:
:
GetStartOffset
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
return
mStart
.
Offset
(
)
;
}
nsINode
*
nsRange
:
:
GetEndContainer
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
return
mEnd
.
Container
(
)
;
}
uint32_t
nsRange
:
:
GetEndOffset
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
return
mEnd
.
Offset
(
)
;
}
nsINode
*
nsRange
:
:
GetCommonAncestorContainer
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
return
nsContentUtils
:
:
GetCommonAncestor
(
mStart
.
Container
(
)
mEnd
.
Container
(
)
)
;
}
bool
nsRange
:
:
IsValidOffset
(
nsINode
*
aNode
uint32_t
aOffset
)
{
return
aNode
&
&
IsValidOffset
(
aOffset
)
&
&
static_cast
<
size_t
>
(
aOffset
)
<
=
aNode
-
>
Length
(
)
;
}
nsINode
*
nsRange
:
:
ComputeRootNode
(
nsINode
*
aNode
)
{
if
(
!
aNode
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsContent
(
)
)
{
if
(
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
documentTypeNodeName
)
{
return
nullptr
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
ShadowRoot
*
containingShadow
=
content
-
>
GetContainingShadow
(
)
)
{
return
containingShadow
;
}
if
(
nsINode
*
root
=
content
-
>
GetBindingParent
(
)
)
{
return
root
;
}
}
if
(
nsINode
*
root
=
aNode
-
>
GetUncomposedDoc
(
)
)
{
return
root
;
}
NS_ASSERTION
(
!
aNode
-
>
SubtreeRoot
(
)
-
>
IsDocument
(
)
"
GetUncomposedDoc
should
have
returned
a
doc
"
)
;
return
aNode
-
>
SubtreeRoot
(
)
;
}
bool
nsRange
:
:
IsValidPoints
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aStartContainer
)
|
|
NS_WARN_IF
(
!
aEndContainer
)
|
|
NS_WARN_IF
(
!
IsValidOffset
(
aStartContainer
aStartOffset
)
)
|
|
NS_WARN_IF
(
!
IsValidOffset
(
aEndContainer
aEndOffset
)
)
)
{
return
false
;
}
if
(
ComputeRootNode
(
aStartContainer
)
!
=
ComputeRootNode
(
aEndContainer
)
)
{
return
false
;
}
bool
disconnected
=
false
;
int32_t
order
=
nsContentUtils
:
:
ComparePoints
(
aStartContainer
static_cast
<
int32_t
>
(
aStartOffset
)
aEndContainer
static_cast
<
int32_t
>
(
aEndOffset
)
&
disconnected
)
;
if
(
order
=
=
1
|
|
NS_WARN_IF
(
disconnected
)
)
{
return
false
;
}
return
true
;
}
void
nsRange
:
:
SetStartJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetStart
(
aNode
aOffset
aErr
)
;
}
void
nsRange
:
:
SetStart
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
SetStart
(
RawRangeBoundary
(
&
aNode
aOffset
)
aRv
)
;
}
void
nsRange
:
:
SetStart
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aRv
)
{
nsINode
*
newRoot
=
IsValidBoundary
(
aPoint
.
Container
(
)
)
;
if
(
!
newRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
if
(
!
aPoint
.
IsSetAndValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
if
(
!
mIsPositioned
|
|
newRoot
!
=
mRoot
|
|
nsContentUtils
:
:
ComparePoints
(
aPoint
mEnd
.
AsRaw
(
)
)
=
=
1
)
{
DoSetRange
(
aPoint
aPoint
newRoot
)
;
return
;
}
DoSetRange
(
aPoint
mEnd
.
AsRaw
(
)
mRoot
)
;
}
void
nsRange
:
:
SetStartBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetStartBefore
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetStartBefore
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetBefore
(
&
aNode
&
offset
)
;
aRv
=
SetStart
(
container
offset
)
;
}
void
nsRange
:
:
SetStartAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetStartAfter
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetStartAfter
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetAfter
(
&
aNode
&
offset
)
;
aRv
=
SetStart
(
container
offset
)
;
}
void
nsRange
:
:
SetEndJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetEnd
(
aNode
aOffset
aErr
)
;
}
void
nsRange
:
:
SetEnd
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
SetEnd
(
RawRangeBoundary
(
&
aNode
aOffset
)
aRv
)
;
}
void
nsRange
:
:
SetEnd
(
const
RawRangeBoundary
&
aPoint
ErrorResult
&
aRv
)
{
nsINode
*
newRoot
=
IsValidBoundary
(
aPoint
.
Container
(
)
)
;
if
(
!
newRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
if
(
!
aPoint
.
IsSetAndValid
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
;
}
if
(
!
mIsPositioned
|
|
newRoot
!
=
mRoot
|
|
nsContentUtils
:
:
ComparePoints
(
mStart
.
AsRaw
(
)
aPoint
)
=
=
1
)
{
DoSetRange
(
aPoint
aPoint
newRoot
)
;
return
;
}
DoSetRange
(
mStart
.
AsRaw
(
)
aPoint
mRoot
)
;
}
void
nsRange
:
:
SelectNodesInContainer
(
nsINode
*
aContainer
nsIContent
*
aStartContent
nsIContent
*
aEndContent
)
{
MOZ_ASSERT
(
aContainer
)
;
MOZ_ASSERT
(
aContainer
-
>
ComputeIndexOf
(
aStartContent
)
<
=
aContainer
-
>
ComputeIndexOf
(
aEndContent
)
)
;
MOZ_ASSERT
(
aStartContent
&
&
aContainer
-
>
ComputeIndexOf
(
aStartContent
)
!
=
-
1
)
;
MOZ_ASSERT
(
aEndContent
&
&
aContainer
-
>
ComputeIndexOf
(
aEndContent
)
!
=
-
1
)
;
nsINode
*
newRoot
=
ComputeRootNode
(
aContainer
)
;
MOZ_ASSERT
(
newRoot
)
;
if
(
!
newRoot
)
{
return
;
}
RawRangeBoundary
start
(
aContainer
aStartContent
-
>
GetPreviousSibling
(
)
)
;
RawRangeBoundary
end
(
aContainer
aEndContent
)
;
DoSetRange
(
start
end
newRoot
)
;
}
nsresult
nsRange
:
:
SetStartAndEnd
(
const
RawRangeBoundary
&
aStart
const
RawRangeBoundary
&
aEnd
)
{
if
(
NS_WARN_IF
(
!
aStart
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aEnd
.
IsSet
(
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsINode
*
newStartRoot
=
IsValidBoundary
(
aStart
.
Container
(
)
)
;
if
(
!
newStartRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aStart
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aStart
.
Container
(
)
=
=
aEnd
.
Container
(
)
)
{
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aStart
.
Offset
(
)
>
aEnd
.
Offset
(
)
)
{
DoSetRange
(
aEnd
aEnd
newStartRoot
)
;
}
else
{
DoSetRange
(
aStart
aEnd
newStartRoot
)
;
}
return
NS_OK
;
}
nsINode
*
newEndRoot
=
IsValidBoundary
(
aEnd
.
Container
(
)
)
;
if
(
!
newEndRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
aEnd
.
IsSetAndValid
(
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
newStartRoot
!
=
newEndRoot
)
{
DoSetRange
(
aEnd
aEnd
newEndRoot
)
;
return
NS_OK
;
}
if
(
nsContentUtils
:
:
ComparePoints
(
aStart
aEnd
)
=
=
1
)
{
DoSetRange
(
aEnd
aEnd
newEndRoot
)
;
return
NS_OK
;
}
DoSetRange
(
aStart
aEnd
newStartRoot
)
;
return
NS_OK
;
}
void
nsRange
:
:
SetEndBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetEndBefore
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetEndBefore
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetBefore
(
&
aNode
&
offset
)
;
aRv
=
SetEnd
(
container
offset
)
;
}
void
nsRange
:
:
SetEndAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetEndAfter
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetEndAfter
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetAfter
(
&
aNode
&
offset
)
;
aRv
=
SetEnd
(
container
offset
)
;
}
void
nsRange
:
:
Collapse
(
bool
aToStart
)
{
if
(
!
mIsPositioned
)
return
;
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
if
(
aToStart
)
{
DoSetRange
(
mStart
.
AsRaw
(
)
mStart
.
AsRaw
(
)
mRoot
)
;
}
else
{
DoSetRange
(
mEnd
.
AsRaw
(
)
mEnd
.
AsRaw
(
)
mRoot
)
;
}
}
void
nsRange
:
:
CollapseJS
(
bool
aToStart
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
Collapse
(
aToStart
)
;
}
void
nsRange
:
:
SelectNodeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SelectNode
(
aNode
aErr
)
;
}
void
nsRange
:
:
SelectNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsINode
*
container
=
aNode
.
GetParentNode
(
)
;
nsINode
*
newRoot
=
IsValidBoundary
(
container
)
;
if
(
!
newRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
int32_t
index
=
container
-
>
ComputeIndexOf
(
&
aNode
)
;
if
(
NS_WARN_IF
(
index
<
0
)
|
|
!
IsValidOffset
(
static_cast
<
uint32_t
>
(
index
)
)
|
|
!
IsValidOffset
(
static_cast
<
uint32_t
>
(
index
)
+
1
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
DoSetRange
(
RawRangeBoundary
(
container
index
)
RawRangeBoundary
(
container
index
+
1
)
newRoot
)
;
}
void
nsRange
:
:
SelectNodeContentsJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SelectNodeContents
(
aNode
aErr
)
;
}
void
nsRange
:
:
SelectNodeContents
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsINode
*
newRoot
=
IsValidBoundary
(
&
aNode
)
;
if
(
!
newRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
DoSetRange
(
RawRangeBoundary
(
&
aNode
0
)
RawRangeBoundary
(
&
aNode
aNode
.
Length
(
)
)
newRoot
)
;
}
class
MOZ_STACK_CLASS
RangeSubtreeIterator
{
private
:
enum
RangeSubtreeIterState
{
eDone
=
0
eUseStart
eUseIterator
eUseEnd
}
;
nsCOMPtr
<
nsIContentIterator
>
mIter
;
RangeSubtreeIterState
mIterState
;
nsCOMPtr
<
nsINode
>
mStart
;
nsCOMPtr
<
nsINode
>
mEnd
;
public
:
RangeSubtreeIterator
(
)
:
mIterState
(
eDone
)
{
}
~
RangeSubtreeIterator
(
)
{
}
nsresult
Init
(
nsRange
*
aRange
)
;
already_AddRefed
<
nsINode
>
GetCurrentNode
(
)
;
void
First
(
)
;
void
Last
(
)
;
void
Next
(
)
;
void
Prev
(
)
;
bool
IsDone
(
)
{
return
mIterState
=
=
eDone
;
}
}
;
nsresult
RangeSubtreeIterator
:
:
Init
(
nsRange
*
aRange
)
{
mIterState
=
eDone
;
if
(
aRange
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
ErrorResult
rv
;
nsCOMPtr
<
nsINode
>
node
=
aRange
-
>
GetStartContainer
(
rv
)
;
if
(
!
node
)
return
NS_ERROR_FAILURE
;
if
(
node
-
>
IsCharacterData
(
)
|
|
(
node
-
>
IsElement
(
)
&
&
node
-
>
AsElement
(
)
-
>
GetChildCount
(
)
=
=
aRange
-
>
GetStartOffset
(
rv
)
)
)
{
mStart
=
node
;
}
node
=
aRange
-
>
GetEndContainer
(
rv
)
;
if
(
!
node
)
return
NS_ERROR_FAILURE
;
if
(
node
-
>
IsCharacterData
(
)
|
|
(
node
-
>
IsElement
(
)
&
&
aRange
-
>
GetEndOffset
(
rv
)
=
=
0
)
)
{
mEnd
=
node
;
}
if
(
mStart
&
&
mStart
=
=
mEnd
)
{
mEnd
=
nullptr
;
}
else
{
mIter
=
NS_NewContentSubtreeIterator
(
)
;
nsresult
res
=
mIter
-
>
Init
(
aRange
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
if
(
mIter
-
>
IsDone
(
)
)
{
mIter
=
nullptr
;
}
}
First
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsINode
>
RangeSubtreeIterator
:
:
GetCurrentNode
(
)
{
nsCOMPtr
<
nsINode
>
node
;
if
(
mIterState
=
=
eUseStart
&
&
mStart
)
{
node
=
mStart
;
}
else
if
(
mIterState
=
=
eUseEnd
&
&
mEnd
)
{
node
=
mEnd
;
}
else
if
(
mIterState
=
=
eUseIterator
&
&
mIter
)
{
node
=
mIter
-
>
GetCurrentNode
(
)
;
}
return
node
.
forget
(
)
;
}
void
RangeSubtreeIterator
:
:
First
(
)
{
if
(
mStart
)
mIterState
=
eUseStart
;
else
if
(
mIter
)
{
mIter
-
>
First
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
mIterState
=
eDone
;
}
void
RangeSubtreeIterator
:
:
Last
(
)
{
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
if
(
mIter
)
{
mIter
-
>
Last
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mStart
)
mIterState
=
eUseStart
;
else
mIterState
=
eDone
;
}
void
RangeSubtreeIterator
:
:
Next
(
)
{
if
(
mIterState
=
=
eUseStart
)
{
if
(
mIter
)
{
mIter
-
>
First
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
mIterState
=
eDone
;
}
else
if
(
mIterState
=
=
eUseIterator
)
{
mIter
-
>
Next
(
)
;
if
(
mIter
-
>
IsDone
(
)
)
{
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
mIterState
=
eDone
;
}
}
else
mIterState
=
eDone
;
}
void
RangeSubtreeIterator
:
:
Prev
(
)
{
if
(
mIterState
=
=
eUseEnd
)
{
if
(
mIter
)
{
mIter
-
>
Last
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mStart
)
mIterState
=
eUseStart
;
else
mIterState
=
eDone
;
}
else
if
(
mIterState
=
=
eUseIterator
)
{
mIter
-
>
Prev
(
)
;
if
(
mIter
-
>
IsDone
(
)
)
{
if
(
mStart
)
mIterState
=
eUseStart
;
else
mIterState
=
eDone
;
}
}
else
mIterState
=
eDone
;
}
static
nsresult
CollapseRangeAfterDelete
(
nsRange
*
aRange
)
{
NS_ENSURE_ARG_POINTER
(
aRange
)
;
if
(
aRange
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
ErrorResult
rv
;
nsCOMPtr
<
nsINode
>
commonAncestor
=
aRange
-
>
GetCommonAncestorContainer
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
aRange
-
>
GetStartContainer
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
aRange
-
>
GetEndContainer
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
if
(
startContainer
=
=
commonAncestor
)
{
aRange
-
>
Collapse
(
true
)
;
return
NS_OK
;
}
if
(
endContainer
=
=
commonAncestor
)
{
aRange
-
>
Collapse
(
false
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
nodeToSelect
(
startContainer
)
;
while
(
nodeToSelect
)
{
nsCOMPtr
<
nsINode
>
parent
=
nodeToSelect
-
>
GetParentNode
(
)
;
if
(
parent
=
=
commonAncestor
)
break
;
nodeToSelect
=
parent
;
}
if
(
!
nodeToSelect
)
return
NS_ERROR_FAILURE
;
aRange
-
>
SelectNode
(
*
nodeToSelect
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
aRange
-
>
Collapse
(
false
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PrependChild
(
nsINode
*
aContainer
nsINode
*
aChild
)
{
nsCOMPtr
<
nsINode
>
first
=
aContainer
-
>
GetFirstChild
(
)
;
ErrorResult
rv
;
aContainer
-
>
InsertBefore
(
*
aChild
first
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
static
bool
ValidateCurrentNode
(
nsRange
*
aRange
RangeSubtreeIterator
&
aIter
)
{
bool
before
after
;
nsCOMPtr
<
nsINode
>
node
=
aIter
.
GetCurrentNode
(
)
;
if
(
!
node
)
{
return
true
;
}
nsresult
res
=
nsRange
:
:
CompareNodeToRange
(
node
aRange
&
before
&
after
)
;
NS_ENSURE_SUCCESS
(
res
false
)
;
if
(
before
|
|
after
)
{
if
(
node
-
>
IsCharacterData
(
)
)
{
if
(
before
&
&
node
=
=
aRange
-
>
GetStartContainer
(
)
)
{
before
=
false
;
}
if
(
after
&
&
node
=
=
aRange
-
>
GetEndContainer
(
)
)
{
after
=
false
;
}
}
}
return
!
before
&
&
!
after
;
}
nsresult
nsRange
:
:
CutContents
(
DocumentFragment
*
*
aFragment
)
{
if
(
aFragment
)
{
*
aFragment
=
nullptr
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mStart
.
Container
(
)
-
>
OwnerDoc
(
)
;
ErrorResult
res
;
nsCOMPtr
<
nsINode
>
commonAncestor
=
GetCommonAncestorContainer
(
res
)
;
NS_ENSURE_TRUE
(
!
res
.
Failed
(
)
res
.
StealNSResult
(
)
)
;
RefPtr
<
DocumentFragment
>
retval
;
if
(
aFragment
)
{
retval
=
new
DocumentFragment
(
doc
-
>
NodeInfoManager
(
)
)
;
}
nsCOMPtr
<
nsINode
>
commonCloneAncestor
=
retval
.
get
(
)
;
mozAutoSubtreeModified
subtree
(
mRoot
?
mRoot
-
>
OwnerDoc
(
)
:
nullptr
nullptr
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
mStart
.
Container
(
)
;
uint32_t
startOffset
=
mStart
.
Offset
(
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
mEnd
.
Container
(
)
;
uint32_t
endOffset
=
mEnd
.
Offset
(
)
;
if
(
retval
)
{
nsCOMPtr
<
nsIDocument
>
commonAncestorDocument
=
do_QueryInterface
(
commonAncestor
)
;
if
(
commonAncestorDocument
)
{
RefPtr
<
DocumentType
>
doctype
=
commonAncestorDocument
-
>
GetDoctype
(
)
;
if
(
doctype
&
&
nsContentUtils
:
:
ComparePoints
(
startContainer
static_cast
<
int32_t
>
(
startOffset
)
doctype
0
)
<
0
&
&
nsContentUtils
:
:
ComparePoints
(
doctype
0
endContainer
static_cast
<
int32_t
>
(
endOffset
)
)
<
0
)
{
return
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
;
}
}
}
RangeSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
iter
.
IsDone
(
)
)
{
rv
=
CollapseRangeAfterDelete
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
aFragment
)
{
retval
.
forget
(
aFragment
)
;
}
return
rv
;
}
iter
.
First
(
)
;
bool
handled
=
false
;
while
(
!
iter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
nodeToResult
;
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
iter
.
Next
(
)
;
nsCOMPtr
<
nsINode
>
nextNode
=
iter
.
GetCurrentNode
(
)
;
while
(
nextNode
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
nextNode
node
)
)
{
iter
.
Next
(
)
;
nextNode
=
iter
.
GetCurrentNode
(
)
;
}
handled
=
false
;
if
(
auto
charData
=
CharacterData
:
:
FromNode
(
node
)
)
{
uint32_t
dataLength
=
0
;
if
(
node
=
=
startContainer
)
{
if
(
node
=
=
endContainer
)
{
if
(
endOffset
>
startOffset
)
{
if
(
retval
)
{
nsAutoString
cutValue
;
ErrorResult
err
;
charData
-
>
SubstringData
(
startOffset
endOffset
-
startOffset
cutValue
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsINode
>
clone
=
node
-
>
CloneNode
(
false
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
clone
-
>
SetNodeValue
(
cutValue
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
nodeToResult
=
clone
;
}
nsMutationGuard
guard
;
ErrorResult
err
;
charData
-
>
DeleteData
(
startOffset
endOffset
-
startOffset
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
0
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
handled
=
true
;
}
else
{
dataLength
=
charData
-
>
Length
(
)
;
if
(
dataLength
>
=
startOffset
)
{
if
(
retval
)
{
nsAutoString
cutValue
;
ErrorResult
err
;
charData
-
>
SubstringData
(
startOffset
dataLength
cutValue
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsINode
>
clone
=
node
-
>
CloneNode
(
false
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
clone
-
>
SetNodeValue
(
cutValue
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
nodeToResult
=
clone
;
}
nsMutationGuard
guard
;
ErrorResult
err
;
charData
-
>
DeleteData
(
startOffset
dataLength
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
0
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
handled
=
true
;
}
}
else
if
(
node
=
=
endContainer
)
{
if
(
retval
)
{
nsAutoString
cutValue
;
ErrorResult
err
;
charData
-
>
SubstringData
(
0
endOffset
cutValue
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
nsCOMPtr
<
nsINode
>
clone
=
node
-
>
CloneNode
(
false
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
clone
-
>
SetNodeValue
(
cutValue
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
nodeToResult
=
clone
;
}
nsMutationGuard
guard
;
ErrorResult
err
;
charData
-
>
DeleteData
(
0
endOffset
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
0
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
handled
=
true
;
}
}
if
(
!
handled
&
&
(
node
=
=
endContainer
|
|
node
=
=
startContainer
)
)
{
if
(
node
&
&
node
-
>
IsElement
(
)
&
&
(
(
node
=
=
endContainer
&
&
endOffset
=
=
0
)
|
|
(
node
=
=
startContainer
&
&
node
-
>
AsElement
(
)
-
>
GetChildCount
(
)
=
=
startOffset
)
)
)
{
if
(
retval
)
{
ErrorResult
rv
;
nodeToResult
=
node
-
>
CloneNode
(
false
rv
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
rv
.
StealNSResult
(
)
)
;
}
handled
=
true
;
}
}
if
(
!
handled
)
{
nodeToResult
=
node
;
}
uint32_t
parentCount
=
0
;
if
(
retval
)
{
nsCOMPtr
<
nsINode
>
oldCommonAncestor
=
commonAncestor
;
if
(
!
iter
.
IsDone
(
)
)
{
NS_ENSURE_STATE
(
nextNode
)
;
commonAncestor
=
nsContentUtils
:
:
GetCommonAncestor
(
node
nextNode
)
;
NS_ENSURE_STATE
(
commonAncestor
)
;
nsCOMPtr
<
nsINode
>
parentCounterNode
=
node
;
while
(
parentCounterNode
&
&
parentCounterNode
!
=
commonAncestor
)
{
+
+
parentCount
;
parentCounterNode
=
parentCounterNode
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
parentCounterNode
)
;
}
}
nsCOMPtr
<
nsINode
>
closestAncestor
farthestAncestor
;
rv
=
CloneParentsBetween
(
oldCommonAncestor
node
getter_AddRefs
(
closestAncestor
)
getter_AddRefs
(
farthestAncestor
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ErrorResult
res
;
if
(
farthestAncestor
)
{
nsCOMPtr
<
nsINode
>
n
=
do_QueryInterface
(
commonCloneAncestor
)
;
n
-
>
AppendChild
(
*
farthestAncestor
res
)
;
res
.
WouldReportJSException
(
)
;
if
(
NS_WARN_IF
(
res
.
Failed
(
)
)
)
{
return
res
.
StealNSResult
(
)
;
}
}
nsMutationGuard
guard
;
nsCOMPtr
<
nsINode
>
parent
=
nodeToResult
-
>
GetParentNode
(
)
;
if
(
closestAncestor
)
{
closestAncestor
-
>
AppendChild
(
*
nodeToResult
res
)
;
}
else
{
commonCloneAncestor
-
>
AppendChild
(
*
nodeToResult
res
)
;
}
res
.
WouldReportJSException
(
)
;
if
(
NS_WARN_IF
(
res
.
Failed
(
)
)
)
{
return
res
.
StealNSResult
(
)
;
}
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
parent
?
2
:
1
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
else
if
(
nodeToResult
)
{
nsMutationGuard
guard
;
nsCOMPtr
<
nsINode
>
node
=
nodeToResult
;
nsCOMPtr
<
nsINode
>
parent
=
node
-
>
GetParentNode
(
)
;
if
(
parent
)
{
mozilla
:
:
ErrorResult
error
;
parent
-
>
RemoveChild
(
*
node
error
)
;
NS_ENSURE_FALSE
(
error
.
Failed
(
)
error
.
StealNSResult
(
)
)
;
}
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
1
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
if
(
!
iter
.
IsDone
(
)
&
&
retval
)
{
nsCOMPtr
<
nsINode
>
newCloneAncestor
=
nodeToResult
;
for
(
uint32_t
i
=
parentCount
;
i
;
-
-
i
)
{
newCloneAncestor
=
newCloneAncestor
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
newCloneAncestor
)
;
}
commonCloneAncestor
=
newCloneAncestor
;
}
}
rv
=
CollapseRangeAfterDelete
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
aFragment
)
{
retval
.
forget
(
aFragment
)
;
}
return
rv
;
}
void
nsRange
:
:
DeleteContents
(
ErrorResult
&
aRv
)
{
aRv
=
CutContents
(
nullptr
)
;
}
already_AddRefed
<
DocumentFragment
>
nsRange
:
:
ExtractContents
(
ErrorResult
&
rv
)
{
RefPtr
<
DocumentFragment
>
fragment
;
rv
=
CutContents
(
getter_AddRefs
(
fragment
)
)
;
return
fragment
.
forget
(
)
;
}
int16_t
nsRange
:
:
CompareBoundaryPoints
(
uint16_t
aHow
nsRange
&
aOtherRange
ErrorResult
&
rv
)
{
if
(
!
mIsPositioned
|
|
!
aOtherRange
.
IsPositioned
(
)
)
{
rv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
nsINode
*
ourNode
*
otherNode
;
uint32_t
ourOffset
otherOffset
;
switch
(
aHow
)
{
case
Range_Binding
:
:
START_TO_START
:
ourNode
=
mStart
.
Container
(
)
;
ourOffset
=
mStart
.
Offset
(
)
;
otherNode
=
aOtherRange
.
GetStartContainer
(
)
;
otherOffset
=
aOtherRange
.
StartOffset
(
)
;
break
;
case
Range_Binding
:
:
START_TO_END
:
ourNode
=
mEnd
.
Container
(
)
;
ourOffset
=
mEnd
.
Offset
(
)
;
otherNode
=
aOtherRange
.
GetStartContainer
(
)
;
otherOffset
=
aOtherRange
.
StartOffset
(
)
;
break
;
case
Range_Binding
:
:
END_TO_START
:
ourNode
=
mStart
.
Container
(
)
;
ourOffset
=
mStart
.
Offset
(
)
;
otherNode
=
aOtherRange
.
GetEndContainer
(
)
;
otherOffset
=
aOtherRange
.
EndOffset
(
)
;
break
;
case
Range_Binding
:
:
END_TO_END
:
ourNode
=
mEnd
.
Container
(
)
;
ourOffset
=
mEnd
.
Offset
(
)
;
otherNode
=
aOtherRange
.
GetEndContainer
(
)
;
otherOffset
=
aOtherRange
.
EndOffset
(
)
;
break
;
default
:
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
0
;
}
if
(
mRoot
!
=
aOtherRange
.
GetRoot
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
return
0
;
}
return
nsContentUtils
:
:
ComparePoints
(
ourNode
static_cast
<
int32_t
>
(
ourOffset
)
otherNode
static_cast
<
int32_t
>
(
otherOffset
)
)
;
}
nsresult
nsRange
:
:
CloneParentsBetween
(
nsINode
*
aAncestor
nsINode
*
aNode
nsINode
*
*
aClosestAncestor
nsINode
*
*
aFarthestAncestor
)
{
NS_ENSURE_ARG_POINTER
(
(
aAncestor
&
&
aNode
&
&
aClosestAncestor
&
&
aFarthestAncestor
)
)
;
*
aClosestAncestor
=
nullptr
;
*
aFarthestAncestor
=
nullptr
;
if
(
aAncestor
=
=
aNode
)
return
NS_OK
;
nsCOMPtr
<
nsINode
>
firstParent
lastParent
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
while
(
parent
&
&
parent
!
=
aAncestor
)
{
ErrorResult
rv
;
nsCOMPtr
<
nsINode
>
clone
=
parent
-
>
CloneNode
(
false
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
rv
.
StealNSResult
(
)
;
}
if
(
!
clone
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
firstParent
)
{
firstParent
=
lastParent
=
clone
;
}
else
{
clone
-
>
AppendChild
(
*
lastParent
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
lastParent
=
clone
;
}
parent
=
parent
-
>
GetParentNode
(
)
;
}
*
aClosestAncestor
=
firstParent
;
NS_IF_ADDREF
(
*
aClosestAncestor
)
;
*
aFarthestAncestor
=
lastParent
;
NS_IF_ADDREF
(
*
aFarthestAncestor
)
;
return
NS_OK
;
}
already_AddRefed
<
DocumentFragment
>
nsRange
:
:
CloneContents
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsINode
>
commonAncestor
=
GetCommonAncestorContainer
(
aRv
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
"
GetCommonAncestorContainer
(
)
shouldn
'
t
fail
!
"
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
mStart
.
Container
(
)
-
>
OwnerDoc
(
)
;
NS_ASSERTION
(
doc
"
CloneContents
needs
a
document
to
continue
.
"
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
DocumentFragment
>
clonedFrag
=
new
DocumentFragment
(
doc
-
>
NodeInfoManager
(
)
)
;
nsCOMPtr
<
nsINode
>
commonCloneAncestor
=
clonedFrag
.
get
(
)
;
RangeSubtreeIterator
iter
;
aRv
=
iter
.
Init
(
this
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
iter
.
IsDone
(
)
)
{
return
clonedFrag
.
forget
(
)
;
}
iter
.
First
(
)
;
while
(
!
iter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
bool
deepClone
=
!
node
-
>
IsElement
(
)
|
|
(
!
(
node
=
=
mEnd
.
Container
(
)
&
&
mEnd
.
Offset
(
)
=
=
0
)
&
&
!
(
node
=
=
mStart
.
Container
(
)
&
&
mStart
.
Offset
(
)
=
=
node
-
>
AsElement
(
)
-
>
GetChildCount
(
)
)
)
;
nsCOMPtr
<
nsINode
>
clone
=
node
-
>
CloneNode
(
deepClone
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
auto
charData
=
CharacterData
:
:
FromNode
(
clone
)
)
{
if
(
node
=
=
mEnd
.
Container
(
)
)
{
uint32_t
dataLength
=
charData
-
>
Length
(
)
;
if
(
dataLength
>
(
uint32_t
)
mEnd
.
Offset
(
)
)
{
charData
-
>
DeleteData
(
mEnd
.
Offset
(
)
dataLength
-
mEnd
.
Offset
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
if
(
node
=
=
mStart
.
Container
(
)
)
{
if
(
mStart
.
Offset
(
)
>
0
)
{
charData
-
>
DeleteData
(
0
mStart
.
Offset
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
}
nsCOMPtr
<
nsINode
>
closestAncestor
farthestAncestor
;
aRv
=
CloneParentsBetween
(
commonAncestor
node
getter_AddRefs
(
closestAncestor
)
getter_AddRefs
(
farthestAncestor
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
farthestAncestor
)
{
commonCloneAncestor
-
>
AppendChild
(
*
farthestAncestor
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
nsCOMPtr
<
nsINode
>
cloneNode
=
do_QueryInterface
(
clone
)
;
if
(
closestAncestor
)
{
closestAncestor
-
>
AppendChild
(
*
cloneNode
aRv
)
;
}
else
{
commonCloneAncestor
-
>
AppendChild
(
*
cloneNode
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
iter
.
Next
(
)
;
if
(
iter
.
IsDone
(
)
)
break
;
nsCOMPtr
<
nsINode
>
nextNode
=
iter
.
GetCurrentNode
(
)
;
if
(
!
nextNode
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
commonAncestor
=
nsContentUtils
:
:
GetCommonAncestor
(
node
nextNode
)
;
if
(
!
commonAncestor
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
while
(
node
&
&
node
!
=
commonAncestor
)
{
node
=
node
-
>
GetParentNode
(
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
!
node
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
cloneNode
=
cloneNode
-
>
GetParentNode
(
)
;
if
(
!
cloneNode
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
}
commonCloneAncestor
=
cloneNode
;
}
return
clonedFrag
.
forget
(
)
;
}
already_AddRefed
<
nsRange
>
nsRange
:
:
CloneRange
(
)
const
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mOwner
)
;
range
-
>
DoSetRange
(
mStart
.
AsRaw
(
)
mEnd
.
AsRaw
(
)
mRoot
)
;
return
range
.
forget
(
)
;
}
void
nsRange
:
:
InsertNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
uint32_t
tStartOffset
=
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
tStartContainer
=
GetStartContainer
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
&
aNode
=
=
tStartContainer
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
nsCOMPtr
<
nsINode
>
referenceNode
;
nsCOMPtr
<
nsINode
>
referenceParentNode
=
tStartContainer
;
RefPtr
<
Text
>
startTextNode
=
tStartContainer
?
tStartContainer
-
>
GetAsText
(
)
:
nullptr
;
nsCOMPtr
<
nsINodeList
>
tChildList
;
if
(
startTextNode
)
{
referenceParentNode
=
tStartContainer
-
>
GetParentNode
(
)
;
if
(
!
referenceParentNode
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
referenceParentNode
-
>
EnsurePreInsertionValidity
(
aNode
tStartContainer
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
RefPtr
<
Text
>
secondPart
=
startTextNode
-
>
SplitText
(
tStartOffset
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
referenceNode
=
do_QueryInterface
(
secondPart
)
;
}
else
{
tChildList
=
tStartContainer
-
>
ChildNodes
(
)
;
referenceNode
=
tChildList
-
>
Item
(
tStartOffset
)
;
tStartContainer
-
>
EnsurePreInsertionValidity
(
aNode
referenceNode
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
uint32_t
newOffset
;
if
(
referenceNode
)
{
int32_t
indexInParent
=
IndexOf
(
referenceNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
newOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
;
}
else
{
newOffset
=
tChildList
-
>
Length
(
)
;
}
if
(
aNode
.
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
newOffset
+
=
aNode
.
GetChildCount
(
)
;
}
else
{
newOffset
+
+
;
}
nsCOMPtr
<
nsINode
>
tResultNode
;
tResultNode
=
referenceParentNode
-
>
InsertBefore
(
aNode
referenceNode
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
Collapsed
(
)
)
{
aRv
=
SetEnd
(
referenceParentNode
newOffset
)
;
}
}
void
nsRange
:
:
SurroundContents
(
nsINode
&
aNewParent
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNewParent
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
!
mRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mStart
.
Container
(
)
!
=
mEnd
.
Container
(
)
)
{
bool
startIsText
=
mStart
.
Container
(
)
-
>
IsText
(
)
;
bool
endIsText
=
mEnd
.
Container
(
)
-
>
IsText
(
)
;
nsINode
*
startGrandParent
=
mStart
.
Container
(
)
-
>
GetParentNode
(
)
;
nsINode
*
endGrandParent
=
mEnd
.
Container
(
)
-
>
GetParentNode
(
)
;
if
(
!
(
(
startIsText
&
&
endIsText
&
&
startGrandParent
&
&
startGrandParent
=
=
endGrandParent
)
|
|
(
startIsText
&
&
startGrandParent
&
&
startGrandParent
=
=
mEnd
.
Container
(
)
)
|
|
(
endIsText
&
&
endGrandParent
&
&
endGrandParent
=
=
mStart
.
Container
(
)
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
}
uint16_t
nodeType
=
aNewParent
.
NodeType
(
)
;
if
(
nodeType
=
=
nsINode
:
:
DOCUMENT_NODE
|
|
nodeType
=
=
nsINode
:
:
DOCUMENT_TYPE_NODE
|
|
nodeType
=
=
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
RefPtr
<
DocumentFragment
>
docFrag
=
ExtractContents
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
docFrag
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCOMPtr
<
nsINodeList
>
children
=
aNewParent
.
ChildNodes
(
)
;
if
(
!
children
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
uint32_t
numChildren
=
children
-
>
Length
(
)
;
while
(
numChildren
)
{
nsCOMPtr
<
nsINode
>
child
=
children
-
>
Item
(
-
-
numChildren
)
;
if
(
!
child
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aNewParent
.
RemoveChild
(
*
child
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
InsertNode
(
aNewParent
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aNewParent
.
AppendChild
(
*
docFrag
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SelectNode
(
aNewParent
aRv
)
;
}
void
nsRange
:
:
ToString
(
nsAString
&
aReturn
ErrorResult
&
aErr
)
{
aReturn
.
Truncate
(
)
;
if
(
!
mIsPositioned
)
{
return
;
}
#
ifdef
DEBUG_range
printf
(
"
Range
dump
:
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
#
endif
if
(
mStart
.
Container
(
)
=
=
mEnd
.
Container
(
)
)
{
Text
*
textNode
=
mStart
.
Container
(
)
?
mStart
.
Container
(
)
-
>
GetAsText
(
)
:
nullptr
;
if
(
textNode
)
{
#
ifdef
DEBUG_range
textNode
-
>
List
(
stdout
)
;
printf
(
"
End
Range
dump
:
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
#
endif
textNode
-
>
SubstringData
(
mStart
.
Offset
(
)
mEnd
.
Offset
(
)
-
mStart
.
Offset
(
)
aReturn
aErr
)
;
return
;
}
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aErr
.
Throw
(
rv
)
;
return
;
}
nsString
tempString
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsINode
*
n
=
iter
-
>
GetCurrentNode
(
)
;
#
ifdef
DEBUG_range
n
-
>
List
(
stdout
)
;
#
endif
Text
*
textNode
=
n
-
>
GetAsText
(
)
;
if
(
textNode
)
{
if
(
n
=
=
mStart
.
Container
(
)
)
{
uint32_t
strLength
=
textNode
-
>
Length
(
)
;
textNode
-
>
SubstringData
(
mStart
.
Offset
(
)
strLength
-
mStart
.
Offset
(
)
tempString
IgnoreErrors
(
)
)
;
aReturn
+
=
tempString
;
}
else
if
(
n
=
=
mEnd
.
Container
(
)
)
{
textNode
-
>
SubstringData
(
0
mEnd
.
Offset
(
)
tempString
IgnoreErrors
(
)
)
;
aReturn
+
=
tempString
;
}
else
{
textNode
-
>
GetData
(
tempString
)
;
aReturn
+
=
tempString
;
}
}
iter
-
>
Next
(
)
;
}
#
ifdef
DEBUG_range
printf
(
"
End
Range
dump
:
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
#
endif
}
void
nsRange
:
:
Detach
(
)
{
}
already_AddRefed
<
DocumentFragment
>
nsRange
:
:
CreateContextualFragment
(
const
nsAString
&
aFragment
ErrorResult
&
aRv
)
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
nsContentUtils
:
:
CreateContextualFragment
(
mStart
.
Container
(
)
aFragment
false
aRv
)
;
}
static
void
ExtractRectFromOffset
(
nsIFrame
*
aFrame
const
int32_t
aOffset
nsRect
*
aR
bool
aFlushToOriginEdge
bool
aClampToEdge
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aR
)
;
nsPoint
point
;
aFrame
-
>
GetPointFromOffset
(
aOffset
&
point
)
;
bool
isVertical
=
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
;
if
(
!
aClampToEdge
&
&
!
aR
-
>
Contains
(
point
)
)
{
if
(
isVertical
)
{
aR
-
>
SetHeight
(
0
)
;
aR
-
>
y
=
point
.
y
;
}
else
{
aR
-
>
SetWidth
(
0
)
;
aR
-
>
x
=
point
.
x
;
}
return
;
}
if
(
aClampToEdge
)
{
point
=
aR
-
>
ClampPoint
(
point
)
;
}
if
(
aFlushToOriginEdge
)
{
if
(
isVertical
)
{
aR
-
>
SetHeight
(
point
.
y
-
aR
-
>
y
)
;
}
else
{
aR
-
>
SetWidth
(
point
.
x
-
aR
-
>
x
)
;
}
}
else
{
if
(
isVertical
)
{
aR
-
>
SetHeight
(
aR
-
>
YMost
(
)
-
point
.
y
)
;
aR
-
>
y
=
point
.
y
;
}
else
{
aR
-
>
SetWidth
(
aR
-
>
XMost
(
)
-
point
.
x
)
;
aR
-
>
x
=
point
.
x
;
}
}
}
static
nsTextFrame
*
GetTextFrameForContent
(
nsIContent
*
aContent
bool
aFlushLayout
)
{
nsIDocument
*
doc
=
aContent
-
>
OwnerDoc
(
)
;
nsIPresShell
*
presShell
=
doc
-
>
GetShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
const
bool
frameWillBeUnsuppressed
=
presShell
-
>
FrameConstructor
(
)
-
>
EnsureFrameForTextNodeIsCreatedAfterFlush
(
static_cast
<
CharacterData
*
>
(
aContent
)
)
;
if
(
aFlushLayout
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
else
if
(
frameWillBeUnsuppressed
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsTextFrame
(
)
)
{
return
nullptr
;
}
return
static_cast
<
nsTextFrame
*
>
(
frame
)
;
}
static
nsresult
GetPartialTextRect
(
nsLayoutUtils
:
:
RectCallback
*
aCallback
Sequence
<
nsString
>
*
aTextList
nsIContent
*
aContent
int32_t
aStartOffset
int32_t
aEndOffset
bool
aClampToEdge
bool
aFlushLayout
)
{
nsTextFrame
*
textFrame
=
GetTextFrameForContent
(
aContent
aFlushLayout
)
;
if
(
textFrame
)
{
nsIFrame
*
relativeTo
=
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
textFrame
)
;
for
(
nsTextFrame
*
f
=
textFrame
;
f
;
f
=
static_cast
<
nsTextFrame
*
>
(
f
-
>
GetNextContinuation
(
)
)
)
{
int32_t
fstart
=
f
-
>
GetContentOffset
(
)
fend
=
f
-
>
GetContentEnd
(
)
;
if
(
fend
<
=
aStartOffset
|
|
fstart
>
=
aEndOffset
)
continue
;
int32_t
textContentStart
=
fstart
;
int32_t
textContentEnd
=
fend
;
f
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
NS_ENSURE_TRUE
(
f
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
NS_ERROR_OUT_OF_MEMORY
)
;
bool
rtl
=
f
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
-
>
IsRightToLeft
(
)
;
nsRect
r
=
f
-
>
GetRectRelativeToSelf
(
)
;
if
(
fstart
<
aStartOffset
)
{
ExtractRectFromOffset
(
f
aStartOffset
&
r
rtl
aClampToEdge
)
;
textContentStart
=
aStartOffset
;
}
if
(
fend
>
aEndOffset
)
{
ExtractRectFromOffset
(
f
aEndOffset
&
r
!
rtl
aClampToEdge
)
;
textContentEnd
=
aEndOffset
;
}
r
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
f
r
relativeTo
)
;
aCallback
-
>
AddRect
(
r
)
;
if
(
aTextList
)
{
nsIFrame
:
:
RenderedText
renderedText
=
f
-
>
GetRenderedText
(
textContentStart
textContentEnd
nsIFrame
:
:
TextOffsetType
:
:
OFFSETS_IN_CONTENT_TEXT
nsIFrame
:
:
TrailingWhitespace
:
:
DONT_TRIM_TRAILING_WHITESPACE
)
;
aTextList
-
>
AppendElement
(
renderedText
.
mString
fallible
)
;
}
}
}
return
NS_OK
;
}
void
nsRange
:
:
CollectClientRectsAndText
(
nsLayoutUtils
:
:
RectCallback
*
aCollector
Sequence
<
nsString
>
*
aTextList
nsRange
*
aRange
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
bool
aClampToEdge
bool
aFlushLayout
)
{
MOZ_ASSERT
(
IsValidOffset
(
aStartOffset
)
)
;
MOZ_ASSERT
(
IsValidOffset
(
aEndOffset
)
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
aStartContainer
;
nsCOMPtr
<
nsINode
>
endContainer
=
aEndContainer
;
if
(
!
aStartContainer
-
>
IsInComposedDoc
(
)
)
{
return
;
}
if
(
aFlushLayout
)
{
aStartContainer
-
>
OwnerDoc
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
aStartContainer
-
>
IsInComposedDoc
(
)
)
{
return
;
}
}
RangeSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
if
(
iter
.
IsDone
(
)
)
{
if
(
aStartContainer
-
>
IsText
(
)
)
{
nsTextFrame
*
textFrame
=
GetTextFrameForContent
(
aStartContainer
-
>
AsText
(
)
aFlushLayout
)
;
if
(
textFrame
)
{
int32_t
outOffset
;
nsIFrame
*
outFrame
;
textFrame
-
>
GetChildFrameContainingOffset
(
static_cast
<
int32_t
>
(
aStartOffset
)
false
&
outOffset
&
outFrame
)
;
if
(
outFrame
)
{
nsIFrame
*
relativeTo
=
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
outFrame
)
;
nsRect
r
=
outFrame
-
>
GetRectRelativeToSelf
(
)
;
ExtractRectFromOffset
(
outFrame
static_cast
<
int32_t
>
(
aStartOffset
)
&
r
false
aClampToEdge
)
;
r
.
SetWidth
(
0
)
;
r
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
outFrame
r
relativeTo
)
;
aCollector
-
>
AddRect
(
r
)
;
}
}
}
return
;
}
do
{
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
iter
.
Next
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
if
(
!
content
)
continue
;
if
(
content
-
>
IsText
(
)
)
{
if
(
node
=
=
startContainer
)
{
int32_t
offset
=
startContainer
=
=
endContainer
?
static_cast
<
int32_t
>
(
aEndOffset
)
:
content
-
>
GetText
(
)
-
>
GetLength
(
)
;
GetPartialTextRect
(
aCollector
aTextList
content
static_cast
<
int32_t
>
(
aStartOffset
)
offset
aClampToEdge
aFlushLayout
)
;
continue
;
}
else
if
(
node
=
=
endContainer
)
{
GetPartialTextRect
(
aCollector
aTextList
content
0
static_cast
<
int32_t
>
(
aEndOffset
)
aClampToEdge
aFlushLayout
)
;
continue
;
}
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsLayoutUtils
:
:
GetAllInFlowRectsAndTexts
(
frame
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
frame
)
aCollector
aTextList
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
;
}
}
while
(
!
iter
.
IsDone
(
)
)
;
}
already_AddRefed
<
DOMRect
>
nsRange
:
:
GetBoundingClientRect
(
bool
aClampToEdge
bool
aFlushLayout
)
{
RefPtr
<
DOMRect
>
rect
=
new
DOMRect
(
ToSupports
(
this
)
)
;
if
(
!
mStart
.
Container
(
)
)
{
return
rect
.
forget
(
)
;
}
nsLayoutUtils
:
:
RectAccumulator
accumulator
;
CollectClientRectsAndText
(
&
accumulator
nullptr
this
mStart
.
Container
(
)
mStart
.
Offset
(
)
mEnd
.
Container
(
)
mEnd
.
Offset
(
)
aClampToEdge
aFlushLayout
)
;
nsRect
r
=
accumulator
.
mResultRect
.
IsEmpty
(
)
?
accumulator
.
mFirstRect
:
accumulator
.
mResultRect
;
rect
-
>
SetLayoutRect
(
r
)
;
return
rect
.
forget
(
)
;
}
already_AddRefed
<
DOMRectList
>
nsRange
:
:
GetClientRects
(
bool
aClampToEdge
bool
aFlushLayout
)
{
if
(
!
mStart
.
Container
(
)
)
{
return
nullptr
;
}
RefPtr
<
DOMRectList
>
rectList
=
new
DOMRectList
(
this
)
;
nsLayoutUtils
:
:
RectListBuilder
builder
(
rectList
)
;
CollectClientRectsAndText
(
&
builder
nullptr
this
mStart
.
Container
(
)
mStart
.
Offset
(
)
mEnd
.
Container
(
)
mEnd
.
Offset
(
)
aClampToEdge
aFlushLayout
)
;
return
rectList
.
forget
(
)
;
}
void
nsRange
:
:
GetClientRectsAndTexts
(
mozilla
:
:
dom
:
:
ClientRectsAndTexts
&
aResult
ErrorResult
&
aErr
)
{
if
(
!
mStart
.
Container
(
)
)
{
return
;
}
aResult
.
mRectList
=
new
DOMRectList
(
this
)
;
nsLayoutUtils
:
:
RectListBuilder
builder
(
aResult
.
mRectList
)
;
CollectClientRectsAndText
(
&
builder
&
aResult
.
mTextList
this
mStart
.
Container
(
)
mStart
.
Offset
(
)
mEnd
.
Container
(
)
mEnd
.
Offset
(
)
true
true
)
;
}
nsresult
nsRange
:
:
GetUsedFontFaces
(
nsTArray
<
nsAutoPtr
<
InspectorFontFace
>
>
&
aResult
uint32_t
aMaxRanges
bool
aSkipCollapsedWhitespace
)
{
NS_ENSURE_TRUE
(
mStart
.
Container
(
)
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
do_QueryInterface
(
mStart
.
Container
(
)
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
do_QueryInterface
(
mEnd
.
Container
(
)
)
;
nsIDocument
*
doc
=
mStart
.
Container
(
)
-
>
OwnerDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_UNEXPECTED
)
;
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
NS_ENSURE_TRUE
(
mStart
.
Container
(
)
-
>
IsInComposedDoc
(
)
NS_ERROR_UNEXPECTED
)
;
nsLayoutUtils
:
:
UsedFontFaceTable
fontFaces
;
RangeSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
!
iter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
iter
.
Next
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
if
(
!
content
)
{
continue
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
continue
;
}
if
(
content
-
>
IsText
(
)
)
{
if
(
node
=
=
startContainer
)
{
int32_t
offset
=
startContainer
=
=
endContainer
?
mEnd
.
Offset
(
)
:
content
-
>
GetText
(
)
-
>
GetLength
(
)
;
nsLayoutUtils
:
:
GetFontFacesForText
(
frame
mStart
.
Offset
(
)
offset
true
fontFaces
aMaxRanges
aSkipCollapsedWhitespace
)
;
continue
;
}
if
(
node
=
=
endContainer
)
{
nsLayoutUtils
:
:
GetFontFacesForText
(
frame
0
mEnd
.
Offset
(
)
true
fontFaces
aMaxRanges
aSkipCollapsedWhitespace
)
;
continue
;
}
}
nsLayoutUtils
:
:
GetFontFacesForFrames
(
frame
fontFaces
aMaxRanges
aSkipCollapsedWhitespace
)
;
}
for
(
auto
iter
=
fontFaces
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
aResult
.
AppendElement
(
std
:
:
move
(
iter
.
Data
(
)
)
)
;
}
return
NS_OK
;
}
nsINode
*
nsRange
:
:
GetRegisteredCommonAncestor
(
)
{
MOZ_ASSERT
(
IsInSelection
(
)
"
GetRegisteredCommonAncestor
only
valid
for
range
in
selection
"
)
;
MOZ_ASSERT
(
mRegisteredCommonAncestor
)
;
return
mRegisteredCommonAncestor
;
}
bool
nsRange
:
:
AutoInvalidateSelection
:
:
sIsNested
;
nsRange
:
:
AutoInvalidateSelection
:
:
~
AutoInvalidateSelection
(
)
{
if
(
!
mCommonAncestor
)
{
return
;
}
sIsNested
=
false
;
:
:
InvalidateAllFrames
(
mCommonAncestor
)
;
if
(
mRange
-
>
IsInSelection
(
)
)
{
nsINode
*
commonAncestor
=
mRange
-
>
GetRegisteredCommonAncestor
(
)
;
if
(
commonAncestor
&
&
commonAncestor
!
=
mCommonAncestor
)
{
:
:
InvalidateAllFrames
(
commonAncestor
)
;
}
}
}
already_AddRefed
<
nsRange
>
nsRange
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
|
|
!
window
-
>
GetDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
window
-
>
GetDoc
(
)
-
>
CreateRange
(
aRv
)
;
}
static
bool
ExcludeIfNextToNonSelectable
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsText
(
)
&
&
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
;
}
void
nsRange
:
:
ExcludeNonSelectableNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
*
aOutRanges
)
{
MOZ_ASSERT
(
mIsPositioned
)
;
MOZ_ASSERT
(
mEnd
.
Container
(
)
)
;
MOZ_ASSERT
(
mStart
.
Container
(
)
)
;
nsRange
*
range
=
this
;
RefPtr
<
nsRange
>
newRange
;
while
(
range
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
bool
added
=
false
;
bool
seenSelectable
=
false
;
nsIContent
*
firstNonSelectableContent
=
nullptr
;
while
(
true
)
{
ErrorResult
err
;
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
iter
-
>
Next
(
)
;
bool
selectable
=
true
;
nsIContent
*
content
=
node
&
&
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
if
(
content
)
{
if
(
firstNonSelectableContent
&
&
ExcludeIfNextToNonSelectable
(
content
)
)
{
selectable
=
false
;
}
if
(
selectable
)
{
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
for
(
nsIContent
*
p
=
content
;
!
frame
&
&
(
p
=
p
-
>
GetParent
(
)
)
;
)
{
frame
=
p
-
>
GetPrimaryFrame
(
)
;
}
if
(
frame
)
{
selectable
=
frame
-
>
IsSelectable
(
nullptr
)
;
}
}
}
if
(
!
selectable
)
{
if
(
!
firstNonSelectableContent
)
{
firstNonSelectableContent
=
content
;
}
if
(
iter
-
>
IsDone
(
)
&
&
seenSelectable
)
{
range
-
>
SetEndBefore
(
*
firstNonSelectableContent
err
)
;
}
}
else
if
(
firstNonSelectableContent
)
{
if
(
range
=
=
this
&
&
!
seenSelectable
)
{
range
-
>
SetStartBefore
(
*
node
err
)
;
if
(
err
.
Failed
(
)
)
{
return
;
}
break
;
}
else
{
nsINode
*
endContainer
=
range
-
>
mEnd
.
Container
(
)
;
int32_t
endOffset
=
range
-
>
mEnd
.
Offset
(
)
;
range
-
>
SetEndBefore
(
*
firstNonSelectableContent
err
)
;
if
(
!
added
&
&
!
err
.
Failed
(
)
)
{
aOutRanges
-
>
AppendElement
(
range
)
;
}
nsINode
*
startContainer
=
node
;
int32_t
startOffset
=
0
;
if
(
content
&
&
content
-
>
HasIndependentSelection
(
)
)
{
nsINode
*
parent
=
startContainer
-
>
GetParent
(
)
;
if
(
parent
)
{
startOffset
=
parent
-
>
ComputeIndexOf
(
startContainer
)
;
startContainer
=
parent
;
}
}
rv
=
CreateRange
(
startContainer
startOffset
endContainer
endOffset
getter_AddRefs
(
newRange
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
newRange
-
>
Collapsed
(
)
)
{
newRange
=
nullptr
;
}
range
=
newRange
;
break
;
}
}
else
{
seenSelectable
=
true
;
if
(
!
added
)
{
added
=
true
;
aOutRanges
-
>
AppendElement
(
range
)
;
}
}
if
(
iter
-
>
IsDone
(
)
)
{
return
;
}
}
}
}
struct
InnerTextAccumulator
{
explicit
InnerTextAccumulator
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
)
:
mString
(
aValue
.
AsAString
(
)
)
mRequiredLineBreakCount
(
0
)
{
}
void
FlushLineBreaks
(
)
{
while
(
mRequiredLineBreakCount
>
0
)
{
if
(
!
mString
.
IsEmpty
(
)
)
{
mString
.
Append
(
'
\
n
'
)
;
}
-
-
mRequiredLineBreakCount
;
}
}
void
Append
(
char
aCh
)
{
Append
(
nsAutoString
(
aCh
)
)
;
}
void
Append
(
const
nsAString
&
aString
)
{
if
(
aString
.
IsEmpty
(
)
)
{
return
;
}
FlushLineBreaks
(
)
;
mString
.
Append
(
aString
)
;
}
void
AddRequiredLineBreakCount
(
int8_t
aCount
)
{
mRequiredLineBreakCount
=
std
:
:
max
(
mRequiredLineBreakCount
aCount
)
;
}
nsAString
&
mString
;
int8_t
mRequiredLineBreakCount
;
}
;
static
bool
IsVisibleAndNotInReplacedElement
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
|
|
!
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
&
&
!
f
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
button
)
&
&
!
f
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ElementIsVisibleNoFlush
(
Element
*
aElement
)
{
if
(
!
aElement
)
{
return
false
;
}
RefPtr
<
ComputedStyle
>
sc
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
aElement
nullptr
)
;
return
sc
&
&
sc
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
static
void
AppendTransformedText
(
InnerTextAccumulator
&
aResult
nsIContent
*
aContainer
)
{
auto
textNode
=
static_cast
<
CharacterData
*
>
(
aContainer
)
;
nsIFrame
*
frame
=
textNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
IsVisibleAndNotInReplacedElement
(
frame
)
)
{
return
;
}
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
0
aContainer
-
>
GetChildCount
(
)
)
;
aResult
.
Append
(
text
.
mString
)
;
}
enum
TreeTraversalState
{
AT_NODE
AFTER_NODE
}
;
static
int8_t
GetRequiredInnerTextLineBreakCount
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
return
2
;
}
const
nsStyleDisplay
*
styleDisplay
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
styleDisplay
-
>
IsBlockOutside
(
aFrame
)
|
|
styleDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCaption
)
{
return
1
;
}
return
0
;
}
static
bool
IsLastCellOfRow
(
nsIFrame
*
aFrame
)
{
LayoutFrameType
type
=
aFrame
-
>
Type
(
)
;
if
(
type
!
=
LayoutFrameType
:
:
TableCell
&
&
type
!
=
LayoutFrameType
:
:
BCTableCell
)
{
return
true
;
}
for
(
nsIFrame
*
c
=
aFrame
;
c
;
c
=
c
-
>
GetNextContinuation
(
)
)
{
if
(
c
-
>
GetNextSibling
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsLastRowOfRowGroup
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsTableRowFrame
(
)
)
{
return
true
;
}
for
(
nsIFrame
*
c
=
aFrame
;
c
;
c
=
c
-
>
GetNextContinuation
(
)
)
{
if
(
c
-
>
GetNextSibling
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsLastNonemptyRowGroupOfTable
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsTableRowGroupFrame
(
)
)
{
return
true
;
}
for
(
nsIFrame
*
c
=
aFrame
;
c
;
c
=
c
-
>
GetNextContinuation
(
)
)
{
for
(
nsIFrame
*
next
=
c
-
>
GetNextSibling
(
)
;
next
;
next
=
next
-
>
GetNextSibling
(
)
)
{
if
(
next
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
return
false
;
}
}
}
return
true
;
}
void
nsRange
:
:
GetInnerTextNoFlush
(
DOMString
&
aValue
ErrorResult
&
aError
nsIContent
*
aContainer
)
{
InnerTextAccumulator
result
(
aValue
)
;
if
(
aContainer
-
>
IsText
(
)
)
{
AppendTransformedText
(
result
aContainer
)
;
return
;
}
nsIContent
*
currentNode
=
aContainer
;
TreeTraversalState
currentState
=
AFTER_NODE
;
nsIContent
*
endNode
=
aContainer
;
TreeTraversalState
endState
=
AFTER_NODE
;
nsIContent
*
firstChild
=
aContainer
-
>
GetFirstChild
(
)
;
if
(
firstChild
)
{
currentNode
=
firstChild
;
currentState
=
AT_NODE
;
}
while
(
currentNode
!
=
endNode
|
|
currentState
!
=
endState
)
{
nsIFrame
*
f
=
currentNode
-
>
GetPrimaryFrame
(
)
;
bool
isVisibleAndNotReplaced
=
IsVisibleAndNotInReplacedElement
(
f
)
;
if
(
currentState
=
=
AT_NODE
)
{
bool
isText
=
currentNode
-
>
IsText
(
)
;
if
(
isText
&
&
currentNode
-
>
GetParent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
rp
)
&
&
ElementIsVisibleNoFlush
(
currentNode
-
>
GetParent
(
)
-
>
AsElement
(
)
)
)
{
nsAutoString
str
;
currentNode
-
>
GetTextContent
(
str
aError
)
;
result
.
Append
(
str
)
;
}
else
if
(
isVisibleAndNotReplaced
)
{
result
.
AddRequiredLineBreakCount
(
GetRequiredInnerTextLineBreakCount
(
f
)
)
;
if
(
isText
)
{
nsIFrame
:
:
RenderedText
text
=
f
-
>
GetRenderedText
(
)
;
result
.
Append
(
text
.
mString
)
;
}
}
nsIContent
*
child
=
currentNode
-
>
GetFirstChild
(
)
;
if
(
child
)
{
currentNode
=
child
;
continue
;
}
currentState
=
AFTER_NODE
;
}
if
(
currentNode
=
=
endNode
&
&
currentState
=
=
endState
)
{
break
;
}
if
(
isVisibleAndNotReplaced
)
{
if
(
currentNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
result
.
Append
(
'
\
n
'
)
;
}
switch
(
f
-
>
StyleDisplay
(
)
-
>
mDisplay
)
{
case
StyleDisplay
:
:
TableCell
:
if
(
!
IsLastCellOfRow
(
f
)
)
{
result
.
Append
(
'
\
t
'
)
;
}
break
;
case
StyleDisplay
:
:
TableRow
:
if
(
!
IsLastRowOfRowGroup
(
f
)
|
|
!
IsLastNonemptyRowGroupOfTable
(
f
-
>
GetParent
(
)
)
)
{
result
.
Append
(
'
\
n
'
)
;
}
break
;
default
:
break
;
}
result
.
AddRequiredLineBreakCount
(
GetRequiredInnerTextLineBreakCount
(
f
)
)
;
}
nsIContent
*
next
=
currentNode
-
>
GetNextSibling
(
)
;
if
(
next
)
{
currentNode
=
next
;
currentState
=
AT_NODE
;
}
else
{
currentNode
=
currentNode
-
>
GetParent
(
)
;
}
}
}
