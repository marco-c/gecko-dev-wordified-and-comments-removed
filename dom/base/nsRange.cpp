#
include
"
nscore
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDOMDocumentFragment
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMText
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIDOMNodeList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGenericDOMDataNode
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsFontFaceList
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
RangeBinding
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
JSObject
*
nsRange
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
RangeBinding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
static
void
InvalidateAllFrames
(
nsINode
*
aNode
)
{
NS_PRECONDITION
(
aNode
"
bad
arg
"
)
;
nsIFrame
*
frame
=
nullptr
;
switch
(
aNode
-
>
NodeType
(
)
)
{
case
nsIDOMNode
:
:
TEXT_NODE
:
case
nsIDOMNode
:
:
ELEMENT_NODE
:
{
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
aNode
)
;
frame
=
content
-
>
GetPrimaryFrame
(
)
;
break
;
}
case
nsIDOMNode
:
:
DOCUMENT_NODE
:
{
nsIDocument
*
doc
=
static_cast
<
nsIDocument
*
>
(
aNode
)
;
nsIPresShell
*
shell
=
doc
?
doc
-
>
GetShell
(
)
:
nullptr
;
frame
=
shell
?
shell
-
>
GetRootFrame
(
)
:
nullptr
;
break
;
}
}
for
(
nsIFrame
*
f
=
frame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
f
-
>
InvalidateFrameSubtree
(
)
;
}
}
nsresult
nsRange
:
:
CompareNodeToRange
(
nsINode
*
aNode
nsRange
*
aRange
bool
*
outNodeBefore
bool
*
outNodeAfter
)
{
NS_ENSURE_STATE
(
aNode
)
;
if
(
!
aRange
|
|
!
aRange
-
>
IsPositioned
(
)
)
return
NS_ERROR_UNEXPECTED
;
int32_t
nodeStart
nodeEnd
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
parent
=
aNode
;
nodeStart
=
0
;
uint32_t
childCount
=
aNode
-
>
GetChildCount
(
)
;
MOZ_ASSERT
(
childCount
<
=
INT32_MAX
"
There
shouldn
'
t
be
over
INT32_MAX
children
"
)
;
nodeEnd
=
static_cast
<
int32_t
>
(
childCount
)
;
}
else
{
nodeStart
=
parent
-
>
IndexOf
(
aNode
)
;
nodeEnd
=
nodeStart
+
1
;
MOZ_ASSERT
(
nodeStart
<
nodeEnd
"
nodeStart
shouldn
'
t
be
INT32_MAX
"
)
;
}
nsINode
*
rangeStartContainer
=
aRange
-
>
GetStartContainer
(
)
;
nsINode
*
rangeEndContainer
=
aRange
-
>
GetEndContainer
(
)
;
uint32_t
rangeStartOffset
=
aRange
-
>
StartOffset
(
)
;
uint32_t
rangeEndOffset
=
aRange
-
>
EndOffset
(
)
;
bool
disconnected
=
false
;
*
outNodeBefore
=
nsContentUtils
:
:
ComparePoints
(
rangeStartContainer
static_cast
<
int32_t
>
(
rangeStartOffset
)
parent
nodeStart
&
disconnected
)
>
0
;
NS_ENSURE_TRUE
(
!
disconnected
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
*
outNodeAfter
=
nsContentUtils
:
:
ComparePoints
(
rangeEndContainer
static_cast
<
int32_t
>
(
rangeEndOffset
)
parent
nodeEnd
&
disconnected
)
<
0
;
NS_ENSURE_TRUE
(
!
disconnected
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
return
NS_OK
;
}
static
nsINode
*
GetNextRangeCommonAncestor
(
nsINode
*
aNode
)
{
while
(
aNode
&
&
!
aNode
-
>
IsCommonAncestorForRangeInSelection
(
)
)
{
if
(
!
aNode
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
return
nullptr
;
}
aNode
=
aNode
-
>
GetParentNode
(
)
;
}
return
aNode
;
}
struct
IsItemInRangeComparator
{
nsINode
*
mNode
;
uint32_t
mStartOffset
;
uint32_t
mEndOffset
;
int
operator
(
)
(
const
nsRange
*
const
aRange
)
const
{
int32_t
cmp
=
nsContentUtils
:
:
ComparePoints
(
mNode
static_cast
<
int32_t
>
(
mEndOffset
)
aRange
-
>
GetStartContainer
(
)
static_cast
<
int32_t
>
(
aRange
-
>
StartOffset
(
)
)
)
;
if
(
cmp
=
=
1
)
{
cmp
=
nsContentUtils
:
:
ComparePoints
(
mNode
static_cast
<
int32_t
>
(
mStartOffset
)
aRange
-
>
GetEndContainer
(
)
static_cast
<
int32_t
>
(
aRange
-
>
EndOffset
(
)
)
)
;
if
(
cmp
=
=
-
1
)
{
return
0
;
}
return
1
;
}
return
-
1
;
}
}
;
bool
nsRange
:
:
IsNodeSelected
(
nsINode
*
aNode
uint32_t
aStartOffset
uint32_t
aEndOffset
)
{
NS_PRECONDITION
(
aNode
"
bad
arg
"
)
;
nsINode
*
n
=
GetNextRangeCommonAncestor
(
aNode
)
;
NS_ASSERTION
(
n
|
|
!
aNode
-
>
IsSelectionDescendant
(
)
"
orphan
selection
descendant
"
)
;
RangeHashTable
ancestorSelectionRanges
;
nsTHashtable
<
nsPtrHashKey
<
Selection
>
>
ancestorSelections
;
uint32_t
maxRangeCount
=
0
;
for
(
;
n
;
n
=
GetNextRangeCommonAncestor
(
n
-
>
GetParentNode
(
)
)
)
{
nsTHashtable
<
nsPtrHashKey
<
nsRange
>
>
*
ranges
=
n
-
>
GetExistingCommonAncestorRanges
(
)
;
if
(
!
ranges
)
{
continue
;
}
for
(
auto
iter
=
ranges
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsRange
*
range
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
if
(
range
-
>
IsInSelection
(
)
&
&
!
range
-
>
Collapsed
(
)
)
{
ancestorSelectionRanges
.
PutEntry
(
range
)
;
Selection
*
selection
=
range
-
>
mSelection
;
ancestorSelections
.
PutEntry
(
selection
)
;
maxRangeCount
=
std
:
:
max
(
maxRangeCount
selection
-
>
RangeCount
(
)
)
;
}
}
}
if
(
!
ancestorSelectionRanges
.
IsEmpty
(
)
)
{
nsTArray
<
const
nsRange
*
>
sortedRanges
(
maxRangeCount
)
;
for
(
auto
iter
=
ancestorSelections
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Selection
*
selection
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
for
(
uint32_t
i
=
0
len
=
selection
-
>
RangeCount
(
)
;
i
<
len
;
+
+
i
)
{
nsRange
*
range
=
selection
-
>
GetRangeAt
(
i
)
;
if
(
ancestorSelectionRanges
.
Contains
(
range
)
)
{
sortedRanges
.
AppendElement
(
range
)
;
}
}
MOZ_ASSERT
(
!
sortedRanges
.
IsEmpty
(
)
)
;
IsItemInRangeComparator
comparator
=
{
aNode
aStartOffset
aEndOffset
}
;
size_t
unused
;
if
(
mozilla
:
:
BinarySearchIf
(
sortedRanges
0
sortedRanges
.
Length
(
)
comparator
&
unused
)
)
{
return
true
;
}
sortedRanges
.
ClearAndRetainStorage
(
)
;
}
}
return
false
;
}
nsRange
:
:
~
nsRange
(
)
{
NS_ASSERTION
(
!
IsInSelection
(
)
"
deleting
nsRange
that
is
in
use
"
)
;
DoSetRange
(
nullptr
0
nullptr
0
nullptr
)
;
}
nsRange
:
:
nsRange
(
nsINode
*
aNode
)
:
mRoot
(
nullptr
)
mStartOffset
(
0
)
mEndOffset
(
0
)
mIsPositioned
(
false
)
mMaySpanAnonymousSubtrees
(
false
)
mIsGenerated
(
false
)
mStartOffsetWasIncremented
(
false
)
mEndOffsetWasIncremented
(
false
)
mCalledByJS
(
false
)
#
ifdef
DEBUG
mAssertNextInsertOrAppendIndex
(
-
1
)
mAssertNextInsertOrAppendNode
(
nullptr
)
#
endif
{
MOZ_ASSERT
(
aNode
"
range
isn
'
t
in
a
document
!
"
)
;
mOwner
=
aNode
-
>
OwnerDoc
(
)
;
}
nsresult
nsRange
:
:
CreateRange
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndParent
uint32_t
aEndOffset
nsRange
*
*
aRange
)
{
MOZ_ASSERT
(
aRange
)
;
*
aRange
=
nullptr
;
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aStartContainer
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aStartContainer
aStartOffset
aEndParent
aEndOffset
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
range
.
forget
(
aRange
)
;
return
NS_OK
;
}
nsresult
nsRange
:
:
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndParent
uint32_t
aEndOffset
nsRange
*
*
aRange
)
{
nsCOMPtr
<
nsINode
>
startContainer
=
do_QueryInterface
(
aStartContainer
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
do_QueryInterface
(
aEndParent
)
;
return
CreateRange
(
startContainer
aStartOffset
endContainer
aEndOffset
aRange
)
;
}
nsresult
nsRange
:
:
CreateRange
(
nsIDOMNode
*
aStartContainer
uint32_t
aStartOffset
nsIDOMNode
*
aEndParent
uint32_t
aEndOffset
nsIDOMRange
*
*
aRange
)
{
RefPtr
<
nsRange
>
range
;
nsresult
rv
=
nsRange
:
:
CreateRange
(
aStartContainer
aStartOffset
aEndParent
aEndOffset
getter_AddRefs
(
range
)
)
;
range
.
forget
(
aRange
)
;
return
rv
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsRange
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsRange
DoSetRange
(
nullptr
0
nullptr
0
nullptr
)
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsRange
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIDOMRange
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDOMRange
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOwner
)
;
tmp
-
>
Reset
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSelection
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOwner
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStartContainer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEndContainer
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mRoot
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSelection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsRange
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_END
static
void
MarkDescendants
(
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsSelectionDescendant
(
)
)
{
nsINode
*
node
=
aNode
-
>
GetNextNode
(
aNode
)
;
while
(
node
)
{
node
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
if
(
!
node
-
>
IsCommonAncestorForRangeInSelection
(
)
)
{
node
=
node
-
>
GetNextNode
(
aNode
)
;
}
else
{
node
=
node
-
>
GetNextNonChildNode
(
aNode
)
;
}
}
}
}
static
void
UnmarkDescendants
(
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
nsINode
*
node
=
aNode
-
>
GetNextNode
(
aNode
)
;
while
(
node
)
{
node
-
>
ClearDescendantOfCommonAncestorForRangeInSelection
(
)
;
if
(
!
node
-
>
IsCommonAncestorForRangeInSelection
(
)
)
{
node
=
node
-
>
GetNextNode
(
aNode
)
;
}
else
{
node
=
node
-
>
GetNextNonChildNode
(
aNode
)
;
}
}
}
}
void
nsRange
:
:
RegisterCommonAncestor
(
nsINode
*
aNode
)
{
NS_PRECONDITION
(
aNode
"
bad
arg
"
)
;
NS_ASSERTION
(
IsInSelection
(
)
"
registering
range
not
in
selection
"
)
;
MarkDescendants
(
aNode
)
;
UniquePtr
<
nsTHashtable
<
nsPtrHashKey
<
nsRange
>
>
>
&
ranges
=
aNode
-
>
GetCommonAncestorRangesPtr
(
)
;
if
(
!
ranges
)
{
ranges
=
MakeUnique
<
nsRange
:
:
RangeHashTable
>
(
)
;
}
ranges
-
>
PutEntry
(
this
)
;
aNode
-
>
SetCommonAncestorForRangeInSelection
(
)
;
}
void
nsRange
:
:
UnregisterCommonAncestor
(
nsINode
*
aNode
)
{
NS_PRECONDITION
(
aNode
"
bad
arg
"
)
;
NS_ASSERTION
(
aNode
-
>
IsCommonAncestorForRangeInSelection
(
)
"
wrong
node
"
)
;
nsTHashtable
<
nsPtrHashKey
<
nsRange
>
>
*
ranges
=
aNode
-
>
GetExistingCommonAncestorRanges
(
)
;
MOZ_ASSERT
(
ranges
)
;
NS_ASSERTION
(
ranges
-
>
GetEntry
(
this
)
"
unknown
range
"
)
;
if
(
ranges
-
>
Count
(
)
=
=
1
)
{
aNode
-
>
ClearCommonAncestorForRangeInSelection
(
)
;
aNode
-
>
GetCommonAncestorRangesPtr
(
)
.
reset
(
)
;
UnmarkDescendants
(
aNode
)
;
}
else
{
ranges
-
>
RemoveEntry
(
this
)
;
}
}
void
nsRange
:
:
CharacterDataChanged
(
nsIDocument
*
aDocument
nsIContent
*
aContent
CharacterDataChangeInfo
*
aInfo
)
{
MOZ_ASSERT
(
mAssertNextInsertOrAppendIndex
=
=
-
1
"
splitText
failed
to
notify
insert
/
append
?
"
)
;
NS_ASSERTION
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
nsINode
*
newRoot
=
nullptr
;
nsINode
*
newStartNode
=
nullptr
;
nsINode
*
newEndNode
=
nullptr
;
uint32_t
newStartOffset
=
0
;
uint32_t
newEndOffset
=
0
;
if
(
aInfo
-
>
mDetails
&
&
aInfo
-
>
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
)
{
nsINode
*
parentNode
=
aContent
-
>
GetParentNode
(
)
;
int32_t
index
=
-
1
;
if
(
parentNode
=
=
mEndContainer
&
&
mEndOffset
>
0
)
{
index
=
parentNode
-
>
IndexOf
(
aContent
)
;
NS_WARNING_ASSERTION
(
index
>
=
0
"
Shouldn
'
t
be
called
during
removing
the
node
or
something
"
)
;
if
(
static_cast
<
uint32_t
>
(
index
+
1
)
=
=
mEndOffset
)
{
newEndNode
=
mEndContainer
;
newEndOffset
=
mEndOffset
+
1
;
MOZ_ASSERT
(
IsValidOffset
(
newEndOffset
)
)
;
mEndOffsetWasIncremented
=
true
;
}
}
if
(
parentNode
=
=
mStartContainer
&
&
mStartOffset
>
0
)
{
if
(
index
<
=
0
)
{
index
=
parentNode
-
>
IndexOf
(
aContent
)
;
}
if
(
static_cast
<
uint32_t
>
(
index
+
1
)
=
=
mStartOffset
)
{
newStartNode
=
mStartContainer
;
newStartOffset
=
mStartOffset
+
1
;
MOZ_ASSERT
(
IsValidOffset
(
newStartOffset
)
)
;
mStartOffsetWasIncremented
=
true
;
}
}
#
ifdef
DEBUG
if
(
mStartOffsetWasIncremented
|
|
mEndOffsetWasIncremented
)
{
mAssertNextInsertOrAppendIndex
=
(
mStartOffsetWasIncremented
?
newStartOffset
:
newEndOffset
)
-
1
;
mAssertNextInsertOrAppendNode
=
aInfo
-
>
mDetails
-
>
mNextSibling
;
}
#
endif
}
if
(
aContent
=
=
mStartContainer
&
&
aInfo
-
>
mChangeStart
<
mStartOffset
)
{
if
(
aInfo
-
>
mDetails
)
{
NS_ASSERTION
(
aInfo
-
>
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
"
only
a
split
can
start
before
the
end
"
)
;
NS_ASSERTION
(
mStartOffset
<
=
aInfo
-
>
mChangeEnd
+
1
"
mStartOffset
is
beyond
the
end
of
this
node
"
)
;
newStartOffset
=
mStartOffset
-
aInfo
-
>
mChangeStart
;
newStartNode
=
aInfo
-
>
mDetails
-
>
mNextSibling
;
if
(
MOZ_UNLIKELY
(
aContent
=
=
mRoot
)
)
{
newRoot
=
IsValidBoundary
(
newStartNode
)
;
}
bool
isCommonAncestor
=
IsInSelection
(
)
&
&
mStartContainer
=
=
mEndContainer
;
if
(
isCommonAncestor
)
{
UnregisterCommonAncestor
(
mStartContainer
)
;
RegisterCommonAncestor
(
newStartNode
)
;
}
if
(
mStartContainer
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
newStartNode
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
}
else
{
newStartNode
=
mStartContainer
;
newStartOffset
=
mStartOffset
<
=
aInfo
-
>
mChangeEnd
?
aInfo
-
>
mChangeStart
:
mStartOffset
+
aInfo
-
>
mChangeStart
-
aInfo
-
>
mChangeEnd
+
aInfo
-
>
mReplaceLength
;
}
}
if
(
aContent
=
=
mEndContainer
&
&
aInfo
-
>
mChangeStart
<
mEndOffset
)
{
if
(
aInfo
-
>
mDetails
&
&
(
aContent
-
>
GetParentNode
(
)
|
|
newStartNode
)
)
{
NS_ASSERTION
(
aInfo
-
>
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eSplit
"
only
a
split
can
start
before
the
end
"
)
;
NS_ASSERTION
(
mEndOffset
<
=
aInfo
-
>
mChangeEnd
+
1
"
mEndOffset
is
beyond
the
end
of
this
node
"
)
;
newEndOffset
=
mEndOffset
-
aInfo
-
>
mChangeStart
;
newEndNode
=
aInfo
-
>
mDetails
-
>
mNextSibling
;
bool
isCommonAncestor
=
IsInSelection
(
)
&
&
mStartContainer
=
=
mEndContainer
;
if
(
isCommonAncestor
&
&
!
newStartNode
)
{
UnregisterCommonAncestor
(
mStartContainer
)
;
RegisterCommonAncestor
(
mStartContainer
-
>
GetParentNode
(
)
)
;
newEndNode
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
else
if
(
mEndContainer
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
newEndNode
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
}
else
{
newEndNode
=
mEndContainer
;
newEndOffset
=
mEndOffset
<
=
aInfo
-
>
mChangeEnd
?
aInfo
-
>
mChangeStart
:
mEndOffset
+
aInfo
-
>
mChangeStart
-
aInfo
-
>
mChangeEnd
+
aInfo
-
>
mReplaceLength
;
}
}
if
(
aInfo
-
>
mDetails
&
&
aInfo
-
>
mDetails
-
>
mType
=
=
CharacterDataChangeInfo
:
:
Details
:
:
eMerge
)
{
nsIContent
*
removed
=
aInfo
-
>
mDetails
-
>
mNextSibling
;
if
(
removed
=
=
mStartContainer
)
{
newStartOffset
=
mStartOffset
+
aInfo
-
>
mChangeStart
;
newStartNode
=
aContent
;
if
(
MOZ_UNLIKELY
(
removed
=
=
mRoot
)
)
{
newRoot
=
IsValidBoundary
(
newStartNode
)
;
}
}
if
(
removed
=
=
mEndContainer
)
{
newEndOffset
=
mEndOffset
+
aInfo
-
>
mChangeStart
;
newEndNode
=
aContent
;
if
(
MOZ_UNLIKELY
(
removed
=
=
mRoot
)
)
{
newRoot
=
IsValidBoundary
(
newEndNode
)
;
}
}
nsINode
*
parentNode
=
aContent
-
>
GetParentNode
(
)
;
if
(
parentNode
=
=
mStartContainer
&
&
mStartOffset
>
0
&
&
mStartOffset
<
parentNode
-
>
GetChildCount
(
)
&
&
removed
=
=
parentNode
-
>
GetChildAt
(
mStartOffset
)
)
{
newStartNode
=
aContent
;
newStartOffset
=
aInfo
-
>
mChangeStart
;
}
if
(
parentNode
=
=
mEndContainer
&
&
mEndOffset
>
0
&
&
mEndOffset
<
parentNode
-
>
GetChildCount
(
)
&
&
removed
=
=
parentNode
-
>
GetChildAt
(
mEndOffset
)
)
{
newEndNode
=
aContent
;
newEndOffset
=
aInfo
-
>
mChangeEnd
;
}
}
if
(
newStartNode
|
|
newEndNode
)
{
if
(
!
newStartNode
)
{
newStartNode
=
mStartContainer
;
newStartOffset
=
mStartOffset
;
}
if
(
!
newEndNode
)
{
newEndNode
=
mEndContainer
;
newEndOffset
=
mEndOffset
;
}
DoSetRange
(
newStartNode
newStartOffset
newEndNode
newEndOffset
newRoot
?
newRoot
:
mRoot
.
get
(
)
!
newEndNode
-
>
GetParentNode
(
)
|
|
!
newStartNode
-
>
GetParentNode
(
)
)
;
}
}
void
nsRange
:
:
ContentAppended
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
int32_t
aNewIndexInContainer
)
{
NS_ASSERTION
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
nsINode
*
container
=
NODE_FROM
(
aContainer
aDocument
)
;
if
(
container
-
>
IsSelectionDescendant
(
)
&
&
IsInSelection
(
)
)
{
nsINode
*
child
=
aFirstNewContent
;
while
(
child
)
{
if
(
!
child
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
MarkDescendants
(
child
)
;
child
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
}
if
(
mStartOffsetWasIncremented
|
|
mEndOffsetWasIncremented
)
{
MOZ_ASSERT
(
mAssertNextInsertOrAppendIndex
=
=
aNewIndexInContainer
)
;
MOZ_ASSERT
(
mAssertNextInsertOrAppendNode
=
=
aFirstNewContent
)
;
MOZ_ASSERT
(
aFirstNewContent
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
)
;
mStartOffsetWasIncremented
=
mEndOffsetWasIncremented
=
false
;
#
ifdef
DEBUG
mAssertNextInsertOrAppendIndex
=
-
1
;
mAssertNextInsertOrAppendNode
=
nullptr
;
#
endif
}
}
void
nsRange
:
:
ContentInserted
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
aIndexInContainer
)
{
NS_ASSERTION
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
bool
rangeChanged
=
false
;
uint32_t
newStartOffset
=
mStartOffset
;
uint32_t
newEndOffset
=
mEndOffset
;
nsINode
*
container
=
NODE_FROM
(
aContainer
aDocument
)
;
if
(
container
=
=
mStartContainer
&
&
(
NS_WARN_IF
(
aIndexInContainer
<
0
)
|
|
static_cast
<
uint32_t
>
(
aIndexInContainer
)
<
mStartOffset
)
&
&
!
mStartOffsetWasIncremented
)
{
+
+
newStartOffset
;
MOZ_ASSERT
(
IsValidOffset
(
newStartOffset
)
)
;
rangeChanged
=
true
;
}
if
(
container
=
=
mEndContainer
&
&
(
NS_WARN_IF
(
aIndexInContainer
<
0
)
|
|
static_cast
<
uint32_t
>
(
aIndexInContainer
)
<
mEndOffset
)
&
&
!
mEndOffsetWasIncremented
)
{
+
+
newEndOffset
;
MOZ_ASSERT
(
IsValidOffset
(
newEndOffset
)
)
;
rangeChanged
=
true
;
}
if
(
container
-
>
IsSelectionDescendant
(
)
&
&
!
aChild
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
MarkDescendants
(
aChild
)
;
aChild
-
>
SetDescendantOfCommonAncestorForRangeInSelection
(
)
;
}
if
(
mStartOffsetWasIncremented
|
|
mEndOffsetWasIncremented
)
{
MOZ_ASSERT
(
mAssertNextInsertOrAppendIndex
=
=
aIndexInContainer
)
;
MOZ_ASSERT
(
mAssertNextInsertOrAppendNode
=
=
aChild
)
;
MOZ_ASSERT
(
aChild
-
>
IsNodeOfType
(
nsINode
:
:
eDATA_NODE
)
)
;
mStartOffsetWasIncremented
=
mEndOffsetWasIncremented
=
false
;
#
ifdef
DEBUG
mAssertNextInsertOrAppendIndex
=
-
1
;
mAssertNextInsertOrAppendNode
=
nullptr
;
#
endif
}
if
(
rangeChanged
)
{
DoSetRange
(
mStartContainer
newStartOffset
mEndContainer
newEndOffset
mRoot
)
;
}
}
void
nsRange
:
:
ContentRemoved
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
aIndexInContainer
nsIContent
*
aPreviousSibling
)
{
NS_ASSERTION
(
mIsPositioned
"
shouldn
'
t
be
notified
if
not
positioned
"
)
;
MOZ_ASSERT
(
!
mStartOffsetWasIncremented
&
&
!
mEndOffsetWasIncremented
&
&
mAssertNextInsertOrAppendIndex
=
=
-
1
"
splitText
failed
to
notify
insert
/
append
?
"
)
;
nsINode
*
container
=
NODE_FROM
(
aContainer
aDocument
)
;
bool
gravitateStart
=
false
;
bool
gravitateEnd
=
false
;
bool
didCheckStartParentDescendant
=
false
;
bool
rangeChanged
=
false
;
uint32_t
newStartOffset
=
mStartOffset
;
uint32_t
newEndOffset
=
mEndOffset
;
if
(
container
=
=
mStartContainer
)
{
if
(
aIndexInContainer
<
static_cast
<
int32_t
>
(
mStartOffset
)
)
{
-
-
newStartOffset
;
rangeChanged
=
true
;
}
}
else
{
didCheckStartParentDescendant
=
true
;
gravitateStart
=
nsContentUtils
:
:
ContentIsDescendantOf
(
mStartContainer
aChild
)
;
}
if
(
container
=
=
mEndContainer
)
{
if
(
aIndexInContainer
<
static_cast
<
int32_t
>
(
mEndOffset
)
)
{
-
-
newEndOffset
;
rangeChanged
=
true
;
}
}
else
if
(
didCheckStartParentDescendant
&
&
mStartContainer
=
=
mEndContainer
)
{
gravitateEnd
=
gravitateStart
;
}
else
{
gravitateEnd
=
nsContentUtils
:
:
ContentIsDescendantOf
(
mEndContainer
aChild
)
;
}
if
(
gravitateStart
|
|
gravitateEnd
|
|
rangeChanged
)
{
DoSetRange
(
gravitateStart
?
container
:
mStartContainer
.
get
(
)
gravitateStart
?
aIndexInContainer
:
newStartOffset
gravitateEnd
?
container
:
mEndContainer
.
get
(
)
gravitateEnd
?
aIndexInContainer
:
newEndOffset
mRoot
)
;
}
if
(
container
-
>
IsSelectionDescendant
(
)
&
&
aChild
-
>
IsDescendantOfCommonAncestorForRangeInSelection
(
)
)
{
aChild
-
>
ClearDescendantOfCommonAncestorForRangeInSelection
(
)
;
UnmarkDescendants
(
aChild
)
;
}
}
void
nsRange
:
:
ParentChainChanged
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
!
mStartOffsetWasIncremented
&
&
!
mEndOffsetWasIncremented
&
&
mAssertNextInsertOrAppendIndex
=
=
-
1
"
splitText
failed
to
notify
insert
/
append
?
"
)
;
NS_ASSERTION
(
mRoot
=
=
aContent
"
Wrong
ParentChainChanged
notification
?
"
)
;
nsINode
*
newRoot
=
IsValidBoundary
(
mStartContainer
)
;
NS_ASSERTION
(
newRoot
"
No
valid
boundary
or
root
found
!
"
)
;
if
(
newRoot
!
=
IsValidBoundary
(
mEndContainer
)
)
{
NS_ASSERTION
(
mEndContainer
-
>
IsInNativeAnonymousSubtree
(
)
"
This
special
case
should
happen
only
with
"
"
native
-
anonymous
content
"
)
;
Reset
(
)
;
return
;
}
DoSetRange
(
mStartContainer
mStartOffset
mEndContainer
mEndOffset
newRoot
)
;
}
NS_IMETHODIMP
nsRange
:
:
IsPointInRange
(
nsIDOMNode
*
aContainer
uint32_t
aOffset
bool
*
aResult
)
{
nsCOMPtr
<
nsINode
>
container
=
do_QueryInterface
(
aContainer
)
;
if
(
!
container
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
if
(
NS_WARN_IF
(
!
IsValidOffset
(
aOffset
)
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
ErrorResult
rv
;
*
aResult
=
IsPointInRange
(
*
container
aOffset
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
bool
nsRange
:
:
IsPointInRange
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
uint16_t
compareResult
=
ComparePoint
(
aContainer
aOffset
aRv
)
;
if
(
aRv
.
ErrorCodeIs
(
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
)
{
aRv
.
SuppressException
(
)
;
return
false
;
}
return
compareResult
=
=
0
;
}
NS_IMETHODIMP
nsRange
:
:
ComparePoint
(
nsIDOMNode
*
aContainer
uint32_t
aOffset
int16_t
*
aResult
)
{
nsCOMPtr
<
nsINode
>
container
=
do_QueryInterface
(
aContainer
)
;
NS_ENSURE_TRUE
(
container
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
ErrorResult
rv
;
*
aResult
=
ComparePoint
(
*
container
aOffset
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
int16_t
nsRange
:
:
ComparePoint
(
nsINode
&
aContainer
uint32_t
aOffset
ErrorResult
&
aRv
)
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
if
(
!
nsContentUtils
:
:
ContentIsDescendantOf
(
&
aContainer
mRoot
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
return
0
;
}
if
(
aContainer
.
NodeType
(
)
=
=
nsIDOMNode
:
:
DOCUMENT_TYPE_NODE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
0
;
}
if
(
aOffset
>
aContainer
.
Length
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INDEX_SIZE_ERR
)
;
return
0
;
}
int32_t
cmp
=
nsContentUtils
:
:
ComparePoints
(
&
aContainer
static_cast
<
int32_t
>
(
aOffset
)
mStartContainer
static_cast
<
int32_t
>
(
mStartOffset
)
)
;
if
(
cmp
<
=
0
)
{
return
cmp
;
}
if
(
nsContentUtils
:
:
ComparePoints
(
mEndContainer
static_cast
<
int32_t
>
(
mEndOffset
)
&
aContainer
static_cast
<
int32_t
>
(
aOffset
)
)
=
=
-
1
)
{
return
1
;
}
return
0
;
}
NS_IMETHODIMP
nsRange
:
:
IntersectsNode
(
nsIDOMNode
*
aNode
bool
*
aResult
)
{
*
aResult
=
false
;
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_ARG
(
node
)
;
ErrorResult
rv
;
*
aResult
=
IntersectsNode
(
*
node
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
bool
nsRange
:
:
IntersectsNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
false
;
}
nsINode
*
parent
=
aNode
.
GetParentNode
(
)
;
if
(
!
parent
)
{
return
GetRoot
(
)
=
=
&
aNode
;
}
int32_t
nodeIndex
=
parent
-
>
IndexOf
(
&
aNode
)
;
bool
disconnected
=
false
;
bool
result
=
nsContentUtils
:
:
ComparePoints
(
mStartContainer
static_cast
<
int32_t
>
(
mStartOffset
)
parent
nodeIndex
+
1
&
disconnected
)
<
0
&
&
nsContentUtils
:
:
ComparePoints
(
parent
nodeIndex
mEndContainer
static_cast
<
int32_t
>
(
mEndOffset
)
&
disconnected
)
<
0
;
if
(
disconnected
)
{
result
=
false
;
}
return
result
;
}
void
nsRange
:
:
DoSetRange
(
nsINode
*
aStartN
uint32_t
aStartOffset
nsINode
*
aEndN
uint32_t
aEndOffset
nsINode
*
aRoot
bool
aNotInsertedYet
)
{
NS_PRECONDITION
(
(
aStartN
&
&
aEndN
&
&
aRoot
)
|
|
(
!
aStartN
&
&
!
aEndN
&
&
!
aRoot
)
"
Set
all
or
none
"
)
;
NS_PRECONDITION
(
!
aRoot
|
|
aNotInsertedYet
|
|
(
nsContentUtils
:
:
ContentIsDescendantOf
(
aStartN
aRoot
)
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
aEndN
aRoot
)
&
&
aRoot
=
=
IsValidBoundary
(
aStartN
)
&
&
aRoot
=
=
IsValidBoundary
(
aEndN
)
)
"
Wrong
root
"
)
;
NS_PRECONDITION
(
!
aRoot
|
|
(
aStartN
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
&
&
aEndN
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
&
&
aRoot
=
=
static_cast
<
nsIContent
*
>
(
aStartN
)
-
>
GetBindingParent
(
)
&
&
aRoot
=
=
static_cast
<
nsIContent
*
>
(
aEndN
)
-
>
GetBindingParent
(
)
)
|
|
(
!
aRoot
-
>
GetParentNode
(
)
&
&
(
aRoot
-
>
IsNodeOfType
(
nsINode
:
:
eDOCUMENT
)
|
|
aRoot
-
>
IsNodeOfType
(
nsINode
:
:
eATTRIBUTE
)
|
|
aRoot
-
>
IsNodeOfType
(
nsINode
:
:
eDOCUMENT_FRAGMENT
)
|
|
aRoot
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
)
"
Bad
root
"
)
;
MOZ_ASSERT
(
IsValidOffset
(
aStartOffset
)
)
;
MOZ_ASSERT
(
IsValidOffset
(
aEndOffset
)
)
;
if
(
mRoot
!
=
aRoot
)
{
if
(
mRoot
)
{
mRoot
-
>
RemoveMutationObserver
(
this
)
;
}
if
(
aRoot
)
{
aRoot
-
>
AddMutationObserver
(
this
)
;
}
}
bool
checkCommonAncestor
=
(
mStartContainer
!
=
aStartN
|
|
mEndContainer
!
=
aEndN
)
&
&
IsInSelection
(
)
&
&
!
aNotInsertedYet
;
nsINode
*
oldCommonAncestor
=
checkCommonAncestor
?
GetCommonAncestor
(
)
:
nullptr
;
mStartContainer
=
aStartN
;
mStartOffset
=
aStartOffset
;
mEndContainer
=
aEndN
;
mEndOffset
=
aEndOffset
;
mIsPositioned
=
!
!
mStartContainer
;
if
(
checkCommonAncestor
)
{
nsINode
*
newCommonAncestor
=
GetCommonAncestor
(
)
;
if
(
newCommonAncestor
!
=
oldCommonAncestor
)
{
if
(
oldCommonAncestor
)
{
UnregisterCommonAncestor
(
oldCommonAncestor
)
;
}
if
(
newCommonAncestor
)
{
RegisterCommonAncestor
(
newCommonAncestor
)
;
}
else
{
NS_ASSERTION
(
!
mIsPositioned
"
unexpected
disconnected
nodes
"
)
;
mSelection
=
nullptr
;
}
}
}
mRoot
=
aRoot
;
if
(
mSelection
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
false
;
RefPtr
<
Selection
>
selection
=
mSelection
;
selection
-
>
NotifySelectionListeners
(
calledByJSRestorer
.
SavedValue
(
)
)
;
}
}
static
int32_t
IndexOf
(
nsINode
*
aChild
)
{
nsINode
*
parent
=
aChild
-
>
GetParentNode
(
)
;
return
parent
?
parent
-
>
IndexOf
(
aChild
)
:
-
1
;
}
void
nsRange
:
:
SetSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
)
{
if
(
mSelection
=
=
aSelection
)
{
return
;
}
MOZ_ASSERT
(
!
aSelection
|
|
!
mSelection
)
;
mSelection
=
aSelection
;
nsINode
*
commonAncestor
=
GetCommonAncestor
(
)
;
NS_ASSERTION
(
commonAncestor
"
unexpected
disconnected
nodes
"
)
;
if
(
mSelection
)
{
RegisterCommonAncestor
(
commonAncestor
)
;
}
else
{
UnregisterCommonAncestor
(
commonAncestor
)
;
}
}
nsINode
*
nsRange
:
:
GetCommonAncestor
(
)
const
{
return
mIsPositioned
?
nsContentUtils
:
:
GetCommonAncestor
(
mStartContainer
mEndContainer
)
:
nullptr
;
}
void
nsRange
:
:
Reset
(
)
{
DoSetRange
(
nullptr
0
nullptr
0
nullptr
)
;
}
NS_IMETHODIMP
nsRange
:
:
GetStartContainer
(
nsIDOMNode
*
*
aStartContainer
)
{
if
(
!
mIsPositioned
)
return
NS_ERROR_NOT_INITIALIZED
;
return
CallQueryInterface
(
mStartContainer
aStartContainer
)
;
}
nsINode
*
nsRange
:
:
GetStartContainer
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
return
mStartContainer
;
}
NS_IMETHODIMP
nsRange
:
:
GetStartOffset
(
uint32_t
*
aStartOffset
)
{
if
(
!
mIsPositioned
)
return
NS_ERROR_NOT_INITIALIZED
;
*
aStartOffset
=
mStartOffset
;
return
NS_OK
;
}
uint32_t
nsRange
:
:
GetStartOffset
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
return
mStartOffset
;
}
NS_IMETHODIMP
nsRange
:
:
GetEndContainer
(
nsIDOMNode
*
*
aEndContainer
)
{
if
(
!
mIsPositioned
)
return
NS_ERROR_NOT_INITIALIZED
;
return
CallQueryInterface
(
mEndContainer
aEndContainer
)
;
}
nsINode
*
nsRange
:
:
GetEndContainer
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
return
mEndContainer
;
}
NS_IMETHODIMP
nsRange
:
:
GetEndOffset
(
uint32_t
*
aEndOffset
)
{
if
(
!
mIsPositioned
)
return
NS_ERROR_NOT_INITIALIZED
;
*
aEndOffset
=
mEndOffset
;
return
NS_OK
;
}
uint32_t
nsRange
:
:
GetEndOffset
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
return
mEndOffset
;
}
NS_IMETHODIMP
nsRange
:
:
GetCollapsed
(
bool
*
aIsCollapsed
)
{
if
(
!
mIsPositioned
)
return
NS_ERROR_NOT_INITIALIZED
;
*
aIsCollapsed
=
Collapsed
(
)
;
return
NS_OK
;
}
nsINode
*
nsRange
:
:
GetCommonAncestorContainer
(
ErrorResult
&
aRv
)
const
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
return
nsContentUtils
:
:
GetCommonAncestor
(
mStartContainer
mEndContainer
)
;
}
NS_IMETHODIMP
nsRange
:
:
GetCommonAncestorContainer
(
nsIDOMNode
*
*
aCommonParent
)
{
ErrorResult
rv
;
nsINode
*
commonAncestor
=
GetCommonAncestorContainer
(
rv
)
;
if
(
commonAncestor
)
{
NS_ADDREF
(
*
aCommonParent
=
commonAncestor
-
>
AsDOMNode
(
)
)
;
}
else
{
*
aCommonParent
=
nullptr
;
}
return
rv
.
StealNSResult
(
)
;
}
bool
nsRange
:
:
IsValidOffset
(
nsINode
*
aNode
uint32_t
aOffset
)
{
return
aNode
&
&
IsValidOffset
(
aOffset
)
&
&
static_cast
<
size_t
>
(
aOffset
)
<
=
aNode
-
>
Length
(
)
;
}
nsINode
*
nsRange
:
:
IsValidBoundary
(
nsINode
*
aNode
)
{
if
(
!
aNode
)
{
return
nullptr
;
}
if
(
aNode
-
>
IsNodeOfType
(
nsINode
:
:
eCONTENT
)
)
{
if
(
aNode
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
documentTypeNodeName
)
{
return
nullptr
;
}
nsIContent
*
content
=
static_cast
<
nsIContent
*
>
(
aNode
)
;
if
(
!
mMaySpanAnonymousSubtrees
)
{
ShadowRoot
*
containingShadow
=
content
-
>
GetContainingShadow
(
)
;
if
(
containingShadow
)
{
return
containingShadow
;
}
nsINode
*
root
=
content
-
>
GetBindingParent
(
)
;
if
(
root
)
{
return
root
;
}
}
}
nsINode
*
root
=
aNode
-
>
GetUncomposedDoc
(
)
;
if
(
root
)
{
return
root
;
}
root
=
aNode
-
>
SubtreeRoot
(
)
;
NS_ASSERTION
(
!
root
-
>
IsNodeOfType
(
nsINode
:
:
eDOCUMENT
)
"
GetUncomposedDoc
should
have
returned
a
doc
"
)
;
return
root
;
}
void
nsRange
:
:
SetStartJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetStart
(
aNode
aOffset
aErr
)
;
}
void
nsRange
:
:
SetStart
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
aRv
=
SetStart
(
&
aNode
aOffset
)
;
}
NS_IMETHODIMP
nsRange
:
:
SetStart
(
nsIDOMNode
*
aContainer
uint32_t
aOffset
)
{
nsCOMPtr
<
nsINode
>
container
=
do_QueryInterface
(
aContainer
)
;
if
(
!
container
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
SetStart
(
*
container
aOffset
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
nsresult
nsRange
:
:
SetStart
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
nsINode
*
newRoot
=
IsValidBoundary
(
aContainer
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
IsValidOffset
(
aContainer
aOffset
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
!
mIsPositioned
|
|
newRoot
!
=
mRoot
|
|
nsContentUtils
:
:
ComparePoints
(
aContainer
static_cast
<
int32_t
>
(
aOffset
)
mEndContainer
static_cast
<
int32_t
>
(
mEndOffset
)
)
=
=
1
)
{
DoSetRange
(
aContainer
aOffset
aContainer
aOffset
newRoot
)
;
return
NS_OK
;
}
DoSetRange
(
aContainer
aOffset
mEndContainer
mEndOffset
mRoot
)
;
return
NS_OK
;
}
void
nsRange
:
:
SetStartBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetStartBefore
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetStartBefore
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetBefore
(
&
aNode
&
offset
)
;
aRv
=
SetStart
(
container
offset
)
;
}
NS_IMETHODIMP
nsRange
:
:
SetStartBefore
(
nsIDOMNode
*
aSibling
)
{
nsCOMPtr
<
nsINode
>
sibling
=
do_QueryInterface
(
aSibling
)
;
if
(
!
sibling
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
SetStartBefore
(
*
sibling
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsRange
:
:
SetStartAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetStartAfter
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetStartAfter
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetAfter
(
&
aNode
&
offset
)
;
aRv
=
SetStart
(
container
offset
)
;
}
NS_IMETHODIMP
nsRange
:
:
SetStartAfter
(
nsIDOMNode
*
aSibling
)
{
nsCOMPtr
<
nsINode
>
sibling
=
do_QueryInterface
(
aSibling
)
;
if
(
!
sibling
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
SetStartAfter
(
*
sibling
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsRange
:
:
SetEndJS
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetEnd
(
aNode
aOffset
aErr
)
;
}
void
nsRange
:
:
SetEnd
(
nsINode
&
aNode
uint32_t
aOffset
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
aRv
=
SetEnd
(
&
aNode
aOffset
)
;
}
NS_IMETHODIMP
nsRange
:
:
SetEnd
(
nsIDOMNode
*
aContainer
uint32_t
aOffset
)
{
nsCOMPtr
<
nsINode
>
container
=
do_QueryInterface
(
aContainer
)
;
if
(
!
container
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
SetEnd
(
*
container
aOffset
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
nsresult
nsRange
:
:
SetEnd
(
nsINode
*
aContainer
uint32_t
aOffset
)
{
nsINode
*
newRoot
=
IsValidBoundary
(
aContainer
)
;
if
(
!
newRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
IsValidOffset
(
aContainer
aOffset
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
!
mIsPositioned
|
|
newRoot
!
=
mRoot
|
|
nsContentUtils
:
:
ComparePoints
(
mStartContainer
static_cast
<
int32_t
>
(
mStartOffset
)
aContainer
static_cast
<
int32_t
>
(
aOffset
)
)
=
=
1
)
{
DoSetRange
(
aContainer
aOffset
aContainer
aOffset
newRoot
)
;
return
NS_OK
;
}
DoSetRange
(
mStartContainer
mStartOffset
aContainer
aOffset
mRoot
)
;
return
NS_OK
;
}
nsresult
nsRange
:
:
SetStartAndEnd
(
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
)
{
if
(
NS_WARN_IF
(
!
aStartContainer
)
|
|
NS_WARN_IF
(
!
aEndContainer
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
nsINode
*
newStartRoot
=
IsValidBoundary
(
aStartContainer
)
;
if
(
!
newStartRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
IsValidOffset
(
aStartContainer
aStartOffset
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aStartContainer
=
=
aEndContainer
)
{
if
(
!
IsValidOffset
(
aEndContainer
aEndOffset
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
aStartOffset
>
aEndOffset
)
{
DoSetRange
(
aEndContainer
aEndOffset
aEndContainer
aEndOffset
newStartRoot
)
;
}
else
{
DoSetRange
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
newStartRoot
)
;
}
return
NS_OK
;
}
nsINode
*
newEndRoot
=
IsValidBoundary
(
aEndContainer
)
;
if
(
!
newEndRoot
)
{
return
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
;
}
if
(
!
IsValidOffset
(
aEndContainer
aEndOffset
)
)
{
return
NS_ERROR_DOM_INDEX_SIZE_ERR
;
}
if
(
newStartRoot
!
=
newEndRoot
)
{
DoSetRange
(
aEndContainer
aEndOffset
aEndContainer
aEndOffset
newEndRoot
)
;
return
NS_OK
;
}
if
(
nsContentUtils
:
:
ComparePoints
(
aStartContainer
static_cast
<
int32_t
>
(
aStartOffset
)
aEndContainer
static_cast
<
int32_t
>
(
aEndOffset
)
)
=
=
1
)
{
DoSetRange
(
aEndContainer
aEndOffset
aEndContainer
aEndOffset
newEndRoot
)
;
return
NS_OK
;
}
DoSetRange
(
aStartContainer
aStartOffset
aEndContainer
aEndOffset
newStartRoot
)
;
return
NS_OK
;
}
void
nsRange
:
:
SetEndBeforeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetEndBefore
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetEndBefore
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetBefore
(
&
aNode
&
offset
)
;
aRv
=
SetEnd
(
container
offset
)
;
}
NS_IMETHODIMP
nsRange
:
:
SetEndBefore
(
nsIDOMNode
*
aSibling
)
{
nsCOMPtr
<
nsINode
>
sibling
=
do_QueryInterface
(
aSibling
)
;
if
(
!
sibling
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
SetEndBefore
(
*
sibling
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsRange
:
:
SetEndAfterJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SetEndAfter
(
aNode
aErr
)
;
}
void
nsRange
:
:
SetEndAfter
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
uint32_t
offset
=
UINT32_MAX
;
nsINode
*
container
=
GetContainerAndOffsetAfter
(
&
aNode
&
offset
)
;
aRv
=
SetEnd
(
container
offset
)
;
}
NS_IMETHODIMP
nsRange
:
:
SetEndAfter
(
nsIDOMNode
*
aSibling
)
{
nsCOMPtr
<
nsINode
>
sibling
=
do_QueryInterface
(
aSibling
)
;
if
(
!
sibling
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
SetEndAfter
(
*
sibling
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsRange
:
:
Collapse
(
bool
aToStart
)
{
if
(
!
mIsPositioned
)
return
NS_ERROR_NOT_INITIALIZED
;
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
if
(
aToStart
)
{
DoSetRange
(
mStartContainer
mStartOffset
mStartContainer
mStartOffset
mRoot
)
;
}
else
{
DoSetRange
(
mEndContainer
mEndOffset
mEndContainer
mEndOffset
mRoot
)
;
}
return
NS_OK
;
}
void
nsRange
:
:
CollapseJS
(
bool
aToStart
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
Unused
<
<
Collapse
(
aToStart
)
;
}
NS_IMETHODIMP
nsRange
:
:
SelectNode
(
nsIDOMNode
*
aN
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aN
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
ErrorResult
rv
;
SelectNode
(
*
node
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsRange
:
:
SelectNodeJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SelectNode
(
aNode
aErr
)
;
}
void
nsRange
:
:
SelectNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsINode
*
container
=
aNode
.
GetParentNode
(
)
;
nsINode
*
newRoot
=
IsValidBoundary
(
container
)
;
if
(
!
newRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
int32_t
index
=
container
-
>
IndexOf
(
&
aNode
)
;
if
(
NS_WARN_IF
(
index
<
0
)
|
|
!
IsValidOffset
(
static_cast
<
uint32_t
>
(
index
)
)
|
|
!
IsValidOffset
(
static_cast
<
uint32_t
>
(
index
)
+
1
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
DoSetRange
(
container
index
container
index
+
1
newRoot
)
;
}
NS_IMETHODIMP
nsRange
:
:
SelectNodeContents
(
nsIDOMNode
*
aN
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aN
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
ErrorResult
rv
;
SelectNodeContents
(
*
node
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsRange
:
:
SelectNodeContentsJS
(
nsINode
&
aNode
ErrorResult
&
aErr
)
{
AutoCalledByJSRestore
calledByJSRestorer
(
*
this
)
;
mCalledByJS
=
true
;
SelectNodeContents
(
aNode
aErr
)
;
}
void
nsRange
:
:
SelectNodeContents
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsINode
*
newRoot
=
IsValidBoundary
(
&
aNode
)
;
if
(
!
newRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
AutoInvalidateSelection
atEndOfBlock
(
this
)
;
DoSetRange
(
&
aNode
0
&
aNode
aNode
.
Length
(
)
newRoot
)
;
}
class
MOZ_STACK_CLASS
RangeSubtreeIterator
{
private
:
enum
RangeSubtreeIterState
{
eDone
=
0
eUseStart
eUseIterator
eUseEnd
}
;
nsCOMPtr
<
nsIContentIterator
>
mIter
;
RangeSubtreeIterState
mIterState
;
nsCOMPtr
<
nsINode
>
mStart
;
nsCOMPtr
<
nsINode
>
mEnd
;
public
:
RangeSubtreeIterator
(
)
:
mIterState
(
eDone
)
{
}
~
RangeSubtreeIterator
(
)
{
}
nsresult
Init
(
nsRange
*
aRange
)
;
already_AddRefed
<
nsINode
>
GetCurrentNode
(
)
;
void
First
(
)
;
void
Last
(
)
;
void
Next
(
)
;
void
Prev
(
)
;
bool
IsDone
(
)
{
return
mIterState
=
=
eDone
;
}
}
;
nsresult
RangeSubtreeIterator
:
:
Init
(
nsRange
*
aRange
)
{
mIterState
=
eDone
;
if
(
aRange
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
ErrorResult
rv
;
nsCOMPtr
<
nsINode
>
node
=
aRange
-
>
GetStartContainer
(
rv
)
;
if
(
!
node
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIDOMCharacterData
>
startData
=
do_QueryInterface
(
node
)
;
if
(
startData
|
|
(
node
-
>
IsElement
(
)
&
&
node
-
>
AsElement
(
)
-
>
GetChildCount
(
)
=
=
aRange
-
>
GetStartOffset
(
rv
)
)
)
{
mStart
=
node
;
}
node
=
aRange
-
>
GetEndContainer
(
rv
)
;
if
(
!
node
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIDOMCharacterData
>
endData
=
do_QueryInterface
(
node
)
;
if
(
endData
|
|
(
node
-
>
IsElement
(
)
&
&
aRange
-
>
GetEndOffset
(
rv
)
=
=
0
)
)
{
mEnd
=
node
;
}
if
(
mStart
&
&
mStart
=
=
mEnd
)
{
mEnd
=
nullptr
;
}
else
{
mIter
=
NS_NewContentSubtreeIterator
(
)
;
nsresult
res
=
mIter
-
>
Init
(
aRange
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
if
(
mIter
-
>
IsDone
(
)
)
{
mIter
=
nullptr
;
}
}
First
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsINode
>
RangeSubtreeIterator
:
:
GetCurrentNode
(
)
{
nsCOMPtr
<
nsINode
>
node
;
if
(
mIterState
=
=
eUseStart
&
&
mStart
)
{
node
=
mStart
;
}
else
if
(
mIterState
=
=
eUseEnd
&
&
mEnd
)
{
node
=
mEnd
;
}
else
if
(
mIterState
=
=
eUseIterator
&
&
mIter
)
{
node
=
mIter
-
>
GetCurrentNode
(
)
;
}
return
node
.
forget
(
)
;
}
void
RangeSubtreeIterator
:
:
First
(
)
{
if
(
mStart
)
mIterState
=
eUseStart
;
else
if
(
mIter
)
{
mIter
-
>
First
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
mIterState
=
eDone
;
}
void
RangeSubtreeIterator
:
:
Last
(
)
{
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
if
(
mIter
)
{
mIter
-
>
Last
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mStart
)
mIterState
=
eUseStart
;
else
mIterState
=
eDone
;
}
void
RangeSubtreeIterator
:
:
Next
(
)
{
if
(
mIterState
=
=
eUseStart
)
{
if
(
mIter
)
{
mIter
-
>
First
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
mIterState
=
eDone
;
}
else
if
(
mIterState
=
=
eUseIterator
)
{
mIter
-
>
Next
(
)
;
if
(
mIter
-
>
IsDone
(
)
)
{
if
(
mEnd
)
mIterState
=
eUseEnd
;
else
mIterState
=
eDone
;
}
}
else
mIterState
=
eDone
;
}
void
RangeSubtreeIterator
:
:
Prev
(
)
{
if
(
mIterState
=
=
eUseEnd
)
{
if
(
mIter
)
{
mIter
-
>
Last
(
)
;
mIterState
=
eUseIterator
;
}
else
if
(
mStart
)
mIterState
=
eUseStart
;
else
mIterState
=
eDone
;
}
else
if
(
mIterState
=
=
eUseIterator
)
{
mIter
-
>
Prev
(
)
;
if
(
mIter
-
>
IsDone
(
)
)
{
if
(
mStart
)
mIterState
=
eUseStart
;
else
mIterState
=
eDone
;
}
}
else
mIterState
=
eDone
;
}
static
nsresult
CollapseRangeAfterDelete
(
nsRange
*
aRange
)
{
NS_ENSURE_ARG_POINTER
(
aRange
)
;
if
(
aRange
-
>
Collapsed
(
)
)
{
return
NS_OK
;
}
ErrorResult
rv
;
nsCOMPtr
<
nsINode
>
commonAncestor
=
aRange
-
>
GetCommonAncestorContainer
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
aRange
-
>
GetStartContainer
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
aRange
-
>
GetEndContainer
(
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
if
(
startContainer
=
=
commonAncestor
)
return
aRange
-
>
Collapse
(
true
)
;
if
(
endContainer
=
=
commonAncestor
)
return
aRange
-
>
Collapse
(
false
)
;
nsCOMPtr
<
nsINode
>
nodeToSelect
(
startContainer
)
;
while
(
nodeToSelect
)
{
nsCOMPtr
<
nsINode
>
parent
=
nodeToSelect
-
>
GetParentNode
(
)
;
if
(
parent
=
=
commonAncestor
)
break
;
nodeToSelect
=
parent
;
}
if
(
!
nodeToSelect
)
return
NS_ERROR_FAILURE
;
aRange
-
>
SelectNode
(
*
nodeToSelect
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
return
aRange
-
>
Collapse
(
false
)
;
}
NS_IMETHODIMP
PrependChild
(
nsINode
*
aContainer
nsINode
*
aChild
)
{
nsCOMPtr
<
nsINode
>
first
=
aContainer
-
>
GetFirstChild
(
)
;
ErrorResult
rv
;
aContainer
-
>
InsertBefore
(
*
aChild
first
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
static
bool
ValidateCurrentNode
(
nsRange
*
aRange
RangeSubtreeIterator
&
aIter
)
{
bool
before
after
;
nsCOMPtr
<
nsINode
>
node
=
aIter
.
GetCurrentNode
(
)
;
if
(
!
node
)
{
return
true
;
}
nsresult
res
=
nsRange
:
:
CompareNodeToRange
(
node
aRange
&
before
&
after
)
;
NS_ENSURE_SUCCESS
(
res
false
)
;
if
(
before
|
|
after
)
{
nsCOMPtr
<
nsIDOMCharacterData
>
charData
=
do_QueryInterface
(
node
)
;
if
(
charData
)
{
if
(
before
&
&
node
=
=
aRange
-
>
GetStartContainer
(
)
)
{
before
=
false
;
}
if
(
after
&
&
node
=
=
aRange
-
>
GetEndContainer
(
)
)
{
after
=
false
;
}
}
}
return
!
before
&
&
!
after
;
}
nsresult
nsRange
:
:
CutContents
(
DocumentFragment
*
*
aFragment
)
{
if
(
aFragment
)
{
*
aFragment
=
nullptr
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mStartContainer
-
>
OwnerDoc
(
)
;
ErrorResult
res
;
nsCOMPtr
<
nsINode
>
commonAncestor
=
GetCommonAncestorContainer
(
res
)
;
NS_ENSURE_TRUE
(
!
res
.
Failed
(
)
res
.
StealNSResult
(
)
)
;
RefPtr
<
DocumentFragment
>
retval
;
if
(
aFragment
)
{
retval
=
new
DocumentFragment
(
doc
-
>
NodeInfoManager
(
)
)
;
}
nsCOMPtr
<
nsINode
>
commonCloneAncestor
=
retval
.
get
(
)
;
mozAutoSubtreeModified
subtree
(
mRoot
?
mRoot
-
>
OwnerDoc
(
)
:
nullptr
nullptr
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
mStartContainer
;
uint32_t
startOffset
=
mStartOffset
;
nsCOMPtr
<
nsINode
>
endContainer
=
mEndContainer
;
uint32_t
endOffset
=
mEndOffset
;
if
(
retval
)
{
nsCOMPtr
<
nsIDocument
>
commonAncestorDocument
=
do_QueryInterface
(
commonAncestor
)
;
if
(
commonAncestorDocument
)
{
RefPtr
<
DocumentType
>
doctype
=
commonAncestorDocument
-
>
GetDoctype
(
)
;
if
(
doctype
&
&
nsContentUtils
:
:
ComparePoints
(
startContainer
static_cast
<
int32_t
>
(
startOffset
)
doctype
0
)
<
0
&
&
nsContentUtils
:
:
ComparePoints
(
doctype
0
endContainer
static_cast
<
int32_t
>
(
endOffset
)
)
<
0
)
{
return
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
;
}
}
}
RangeSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
iter
.
IsDone
(
)
)
{
rv
=
CollapseRangeAfterDelete
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
aFragment
)
{
retval
.
forget
(
aFragment
)
;
}
return
rv
;
}
iter
.
First
(
)
;
bool
handled
=
false
;
while
(
!
iter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
nodeToResult
;
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
iter
.
Next
(
)
;
nsCOMPtr
<
nsINode
>
nextNode
=
iter
.
GetCurrentNode
(
)
;
while
(
nextNode
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
nextNode
node
)
)
{
iter
.
Next
(
)
;
nextNode
=
iter
.
GetCurrentNode
(
)
;
}
handled
=
false
;
nsCOMPtr
<
nsIDOMCharacterData
>
charData
(
do_QueryInterface
(
node
)
)
;
if
(
charData
)
{
uint32_t
dataLength
=
0
;
if
(
node
=
=
startContainer
)
{
if
(
node
=
=
endContainer
)
{
if
(
endOffset
>
startOffset
)
{
if
(
retval
)
{
nsAutoString
cutValue
;
rv
=
charData
-
>
SubstringData
(
startOffset
endOffset
-
startOffset
cutValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMNode
>
clone
;
rv
=
charData
-
>
CloneNode
(
false
1
getter_AddRefs
(
clone
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
clone
-
>
SetNodeValue
(
cutValue
)
;
nodeToResult
=
do_QueryInterface
(
clone
)
;
}
nsMutationGuard
guard
;
rv
=
charData
-
>
DeleteData
(
startOffset
endOffset
-
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
0
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
handled
=
true
;
}
else
{
rv
=
charData
-
>
GetLength
(
&
dataLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
dataLength
>
=
startOffset
)
{
if
(
retval
)
{
nsAutoString
cutValue
;
rv
=
charData
-
>
SubstringData
(
startOffset
dataLength
cutValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMNode
>
clone
;
rv
=
charData
-
>
CloneNode
(
false
1
getter_AddRefs
(
clone
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
clone
-
>
SetNodeValue
(
cutValue
)
;
nodeToResult
=
do_QueryInterface
(
clone
)
;
}
nsMutationGuard
guard
;
rv
=
charData
-
>
DeleteData
(
startOffset
dataLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
0
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
handled
=
true
;
}
}
else
if
(
node
=
=
endContainer
)
{
if
(
retval
)
{
nsAutoString
cutValue
;
rv
=
charData
-
>
SubstringData
(
0
endOffset
cutValue
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDOMNode
>
clone
;
rv
=
charData
-
>
CloneNode
(
false
1
getter_AddRefs
(
clone
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
clone
-
>
SetNodeValue
(
cutValue
)
;
nodeToResult
=
do_QueryInterface
(
clone
)
;
}
nsMutationGuard
guard
;
rv
=
charData
-
>
DeleteData
(
0
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
0
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
handled
=
true
;
}
}
if
(
!
handled
&
&
(
node
=
=
endContainer
|
|
node
=
=
startContainer
)
)
{
if
(
node
&
&
node
-
>
IsElement
(
)
&
&
(
(
node
=
=
endContainer
&
&
endOffset
=
=
0
)
|
|
(
node
=
=
startContainer
&
&
node
-
>
AsElement
(
)
-
>
GetChildCount
(
)
=
=
startOffset
)
)
)
{
if
(
retval
)
{
ErrorResult
rv
;
nodeToResult
=
node
-
>
CloneNode
(
false
rv
)
;
NS_ENSURE_TRUE
(
!
rv
.
Failed
(
)
rv
.
StealNSResult
(
)
)
;
}
handled
=
true
;
}
}
if
(
!
handled
)
{
nodeToResult
=
node
;
}
uint32_t
parentCount
=
0
;
if
(
retval
)
{
nsCOMPtr
<
nsINode
>
oldCommonAncestor
=
commonAncestor
;
if
(
!
iter
.
IsDone
(
)
)
{
NS_ENSURE_STATE
(
nextNode
)
;
commonAncestor
=
nsContentUtils
:
:
GetCommonAncestor
(
node
nextNode
)
;
NS_ENSURE_STATE
(
commonAncestor
)
;
nsCOMPtr
<
nsINode
>
parentCounterNode
=
node
;
while
(
parentCounterNode
&
&
parentCounterNode
!
=
commonAncestor
)
{
+
+
parentCount
;
parentCounterNode
=
parentCounterNode
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
parentCounterNode
)
;
}
}
nsCOMPtr
<
nsINode
>
closestAncestor
farthestAncestor
;
rv
=
CloneParentsBetween
(
oldCommonAncestor
node
getter_AddRefs
(
closestAncestor
)
getter_AddRefs
(
farthestAncestor
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ErrorResult
res
;
if
(
farthestAncestor
)
{
nsCOMPtr
<
nsINode
>
n
=
do_QueryInterface
(
commonCloneAncestor
)
;
n
-
>
AppendChild
(
*
farthestAncestor
res
)
;
if
(
NS_WARN_IF
(
res
.
Failed
(
)
)
)
{
return
res
.
StealNSResult
(
)
;
}
}
nsMutationGuard
guard
;
nsCOMPtr
<
nsINode
>
parent
=
nodeToResult
-
>
GetParentNode
(
)
;
if
(
closestAncestor
)
{
closestAncestor
-
>
AppendChild
(
*
nodeToResult
res
)
;
}
else
{
commonCloneAncestor
-
>
AppendChild
(
*
nodeToResult
res
)
;
}
if
(
NS_WARN_IF
(
res
.
Failed
(
)
)
)
{
return
res
.
StealNSResult
(
)
;
}
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
parent
?
2
:
1
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
else
if
(
nodeToResult
)
{
nsMutationGuard
guard
;
nsCOMPtr
<
nsINode
>
node
=
nodeToResult
;
nsCOMPtr
<
nsINode
>
parent
=
node
-
>
GetParentNode
(
)
;
if
(
parent
)
{
mozilla
:
:
ErrorResult
error
;
parent
-
>
RemoveChild
(
*
node
error
)
;
NS_ENSURE_FALSE
(
error
.
Failed
(
)
error
.
StealNSResult
(
)
)
;
}
NS_ENSURE_STATE
(
!
guard
.
Mutated
(
1
)
|
|
ValidateCurrentNode
(
this
iter
)
)
;
}
if
(
!
iter
.
IsDone
(
)
&
&
retval
)
{
nsCOMPtr
<
nsINode
>
newCloneAncestor
=
nodeToResult
;
for
(
uint32_t
i
=
parentCount
;
i
;
-
-
i
)
{
newCloneAncestor
=
newCloneAncestor
-
>
GetParentNode
(
)
;
NS_ENSURE_STATE
(
newCloneAncestor
)
;
}
commonCloneAncestor
=
newCloneAncestor
;
}
}
rv
=
CollapseRangeAfterDelete
(
this
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
aFragment
)
{
retval
.
forget
(
aFragment
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsRange
:
:
DeleteContents
(
)
{
return
CutContents
(
nullptr
)
;
}
void
nsRange
:
:
DeleteContents
(
ErrorResult
&
aRv
)
{
aRv
=
CutContents
(
nullptr
)
;
}
NS_IMETHODIMP
nsRange
:
:
ExtractContents
(
nsIDOMDocumentFragment
*
*
aReturn
)
{
NS_ENSURE_ARG_POINTER
(
aReturn
)
;
RefPtr
<
DocumentFragment
>
fragment
;
nsresult
rv
=
CutContents
(
getter_AddRefs
(
fragment
)
)
;
fragment
.
forget
(
aReturn
)
;
return
rv
;
}
already_AddRefed
<
DocumentFragment
>
nsRange
:
:
ExtractContents
(
ErrorResult
&
rv
)
{
RefPtr
<
DocumentFragment
>
fragment
;
rv
=
CutContents
(
getter_AddRefs
(
fragment
)
)
;
return
fragment
.
forget
(
)
;
}
NS_IMETHODIMP
nsRange
:
:
CompareBoundaryPoints
(
uint16_t
aHow
nsIDOMRange
*
aOtherRange
int16_t
*
aCmpRet
)
{
nsRange
*
otherRange
=
static_cast
<
nsRange
*
>
(
aOtherRange
)
;
NS_ENSURE_TRUE
(
otherRange
NS_ERROR_NULL_POINTER
)
;
ErrorResult
rv
;
*
aCmpRet
=
CompareBoundaryPoints
(
aHow
*
otherRange
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
int16_t
nsRange
:
:
CompareBoundaryPoints
(
uint16_t
aHow
nsRange
&
aOtherRange
ErrorResult
&
rv
)
{
if
(
!
mIsPositioned
|
|
!
aOtherRange
.
IsPositioned
(
)
)
{
rv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
0
;
}
nsINode
*
ourNode
*
otherNode
;
uint32_t
ourOffset
otherOffset
;
switch
(
aHow
)
{
case
nsIDOMRange
:
:
START_TO_START
:
ourNode
=
mStartContainer
;
ourOffset
=
mStartOffset
;
otherNode
=
aOtherRange
.
GetStartContainer
(
)
;
otherOffset
=
aOtherRange
.
StartOffset
(
)
;
break
;
case
nsIDOMRange
:
:
START_TO_END
:
ourNode
=
mEndContainer
;
ourOffset
=
mEndOffset
;
otherNode
=
aOtherRange
.
GetStartContainer
(
)
;
otherOffset
=
aOtherRange
.
StartOffset
(
)
;
break
;
case
nsIDOMRange
:
:
END_TO_START
:
ourNode
=
mStartContainer
;
ourOffset
=
mStartOffset
;
otherNode
=
aOtherRange
.
GetEndContainer
(
)
;
otherOffset
=
aOtherRange
.
EndOffset
(
)
;
break
;
case
nsIDOMRange
:
:
END_TO_END
:
ourNode
=
mEndContainer
;
ourOffset
=
mEndOffset
;
otherNode
=
aOtherRange
.
GetEndContainer
(
)
;
otherOffset
=
aOtherRange
.
EndOffset
(
)
;
break
;
default
:
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
0
;
}
if
(
mRoot
!
=
aOtherRange
.
GetRoot
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_WRONG_DOCUMENT_ERR
)
;
return
0
;
}
return
nsContentUtils
:
:
ComparePoints
(
ourNode
static_cast
<
int32_t
>
(
ourOffset
)
otherNode
static_cast
<
int32_t
>
(
otherOffset
)
)
;
}
nsresult
nsRange
:
:
CloneParentsBetween
(
nsINode
*
aAncestor
nsINode
*
aNode
nsINode
*
*
aClosestAncestor
nsINode
*
*
aFarthestAncestor
)
{
NS_ENSURE_ARG_POINTER
(
(
aAncestor
&
&
aNode
&
&
aClosestAncestor
&
&
aFarthestAncestor
)
)
;
*
aClosestAncestor
=
nullptr
;
*
aFarthestAncestor
=
nullptr
;
if
(
aAncestor
=
=
aNode
)
return
NS_OK
;
nsCOMPtr
<
nsINode
>
firstParent
lastParent
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
-
>
GetParentNode
(
)
;
while
(
parent
&
&
parent
!
=
aAncestor
)
{
ErrorResult
rv
;
nsCOMPtr
<
nsINode
>
clone
=
parent
-
>
CloneNode
(
false
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
rv
.
StealNSResult
(
)
;
}
if
(
!
clone
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
firstParent
)
{
firstParent
=
lastParent
=
clone
;
}
else
{
clone
-
>
AppendChild
(
*
lastParent
rv
)
;
if
(
rv
.
Failed
(
)
)
return
rv
.
StealNSResult
(
)
;
lastParent
=
clone
;
}
parent
=
parent
-
>
GetParentNode
(
)
;
}
*
aClosestAncestor
=
firstParent
;
NS_IF_ADDREF
(
*
aClosestAncestor
)
;
*
aFarthestAncestor
=
lastParent
;
NS_IF_ADDREF
(
*
aFarthestAncestor
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRange
:
:
CloneContents
(
nsIDOMDocumentFragment
*
*
aReturn
)
{
ErrorResult
rv
;
*
aReturn
=
CloneContents
(
rv
)
.
take
(
)
;
return
rv
.
StealNSResult
(
)
;
}
already_AddRefed
<
DocumentFragment
>
nsRange
:
:
CloneContents
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsINode
>
commonAncestor
=
GetCommonAncestorContainer
(
aRv
)
;
MOZ_ASSERT
(
!
aRv
.
Failed
(
)
"
GetCommonAncestorContainer
(
)
shouldn
'
t
fail
!
"
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
mStartContainer
-
>
OwnerDoc
(
)
;
NS_ASSERTION
(
doc
"
CloneContents
needs
a
document
to
continue
.
"
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
DocumentFragment
>
clonedFrag
=
new
DocumentFragment
(
doc
-
>
NodeInfoManager
(
)
)
;
nsCOMPtr
<
nsINode
>
commonCloneAncestor
=
clonedFrag
.
get
(
)
;
RangeSubtreeIterator
iter
;
aRv
=
iter
.
Init
(
this
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
iter
.
IsDone
(
)
)
{
return
clonedFrag
.
forget
(
)
;
}
iter
.
First
(
)
;
while
(
!
iter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
bool
deepClone
=
!
node
-
>
IsElement
(
)
|
|
(
!
(
node
=
=
mEndContainer
&
&
mEndOffset
=
=
0
)
&
&
!
(
node
=
=
mStartContainer
&
&
mStartOffset
=
=
node
-
>
AsElement
(
)
-
>
GetChildCount
(
)
)
)
;
nsCOMPtr
<
nsINode
>
clone
=
node
-
>
CloneNode
(
deepClone
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDOMCharacterData
>
charData
(
do_QueryInterface
(
clone
)
)
;
if
(
charData
)
{
if
(
node
=
=
mEndContainer
)
{
uint32_t
dataLength
=
0
;
aRv
=
charData
-
>
GetLength
(
&
dataLength
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
dataLength
>
mEndOffset
)
{
aRv
=
charData
-
>
DeleteData
(
mEndOffset
dataLength
-
mEndOffset
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
if
(
node
=
=
mStartContainer
)
{
if
(
mStartOffset
>
0
)
{
aRv
=
charData
-
>
DeleteData
(
0
mStartOffset
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
}
}
nsCOMPtr
<
nsINode
>
closestAncestor
farthestAncestor
;
aRv
=
CloneParentsBetween
(
commonAncestor
node
getter_AddRefs
(
closestAncestor
)
getter_AddRefs
(
farthestAncestor
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
farthestAncestor
)
{
commonCloneAncestor
-
>
AppendChild
(
*
farthestAncestor
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
nsCOMPtr
<
nsINode
>
cloneNode
=
do_QueryInterface
(
clone
)
;
if
(
closestAncestor
)
{
closestAncestor
-
>
AppendChild
(
*
cloneNode
aRv
)
;
}
else
{
commonCloneAncestor
-
>
AppendChild
(
*
cloneNode
aRv
)
;
}
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
iter
.
Next
(
)
;
if
(
iter
.
IsDone
(
)
)
break
;
nsCOMPtr
<
nsINode
>
nextNode
=
iter
.
GetCurrentNode
(
)
;
if
(
!
nextNode
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
commonAncestor
=
nsContentUtils
:
:
GetCommonAncestor
(
node
nextNode
)
;
if
(
!
commonAncestor
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
while
(
node
&
&
node
!
=
commonAncestor
)
{
node
=
node
-
>
GetParentNode
(
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
!
node
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
cloneNode
=
cloneNode
-
>
GetParentNode
(
)
;
if
(
!
cloneNode
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
}
commonCloneAncestor
=
cloneNode
;
}
return
clonedFrag
.
forget
(
)
;
}
already_AddRefed
<
nsRange
>
nsRange
:
:
CloneRange
(
)
const
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mOwner
)
;
range
-
>
SetMaySpanAnonymousSubtrees
(
mMaySpanAnonymousSubtrees
)
;
range
-
>
DoSetRange
(
mStartContainer
mStartOffset
mEndContainer
mEndOffset
mRoot
)
;
return
range
.
forget
(
)
;
}
NS_IMETHODIMP
nsRange
:
:
CloneRange
(
nsIDOMRange
*
*
aReturn
)
{
*
aReturn
=
CloneRange
(
)
.
take
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsRange
:
:
InsertNode
(
nsIDOMNode
*
aNode
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNode
)
;
if
(
!
node
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
InsertNode
(
*
node
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsRange
:
:
InsertNode
(
nsINode
&
aNode
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNode
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
uint32_t
tStartOffset
=
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
tStartContainer
=
GetStartContainer
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
&
aNode
=
=
tStartContainer
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
nsCOMPtr
<
nsINode
>
referenceNode
;
nsCOMPtr
<
nsINode
>
referenceParentNode
=
tStartContainer
;
nsCOMPtr
<
nsIDOMText
>
startTextNode
(
do_QueryInterface
(
tStartContainer
)
)
;
nsCOMPtr
<
nsIDOMNodeList
>
tChildList
;
if
(
startTextNode
)
{
referenceParentNode
=
tStartContainer
-
>
GetParentNode
(
)
;
if
(
!
referenceParentNode
)
{
aRv
.
Throw
(
NS_ERROR_DOM_HIERARCHY_REQUEST_ERR
)
;
return
;
}
referenceParentNode
-
>
EnsurePreInsertionValidity
(
aNode
tStartContainer
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDOMText
>
secondPart
;
aRv
=
startTextNode
-
>
SplitText
(
tStartOffset
getter_AddRefs
(
secondPart
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
referenceNode
=
do_QueryInterface
(
secondPart
)
;
}
else
{
aRv
=
tStartContainer
-
>
AsDOMNode
(
)
-
>
GetChildNodes
(
getter_AddRefs
(
tChildList
)
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDOMNode
>
q
;
aRv
=
tChildList
-
>
Item
(
tStartOffset
getter_AddRefs
(
q
)
)
;
referenceNode
=
do_QueryInterface
(
q
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
tStartContainer
-
>
EnsurePreInsertionValidity
(
aNode
referenceNode
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
uint32_t
newOffset
;
if
(
referenceNode
)
{
int32_t
indexInParent
=
IndexOf
(
referenceNode
)
;
if
(
NS_WARN_IF
(
indexInParent
<
0
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
newOffset
=
static_cast
<
uint32_t
>
(
indexInParent
)
;
}
else
{
aRv
=
tChildList
-
>
GetLength
(
&
newOffset
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
if
(
aNode
.
NodeType
(
)
=
=
nsIDOMNode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
newOffset
+
=
aNode
.
GetChildCount
(
)
;
}
else
{
newOffset
+
+
;
}
nsCOMPtr
<
nsINode
>
tResultNode
;
tResultNode
=
referenceParentNode
-
>
InsertBefore
(
aNode
referenceNode
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
Collapsed
(
)
)
{
aRv
=
SetEnd
(
referenceParentNode
newOffset
)
;
}
}
NS_IMETHODIMP
nsRange
:
:
SurroundContents
(
nsIDOMNode
*
aNewParent
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aNewParent
)
;
if
(
!
node
)
{
return
NS_ERROR_DOM_NOT_OBJECT_ERR
;
}
ErrorResult
rv
;
SurroundContents
(
*
node
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
void
nsRange
:
:
SurroundContents
(
nsINode
&
aNewParent
ErrorResult
&
aRv
)
{
if
(
!
nsContentUtils
:
:
LegacyIsCallerNativeCode
(
)
&
&
!
nsContentUtils
:
:
CanCallerAccess
(
&
aNewParent
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
!
mRoot
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mStartContainer
!
=
mEndContainer
)
{
bool
startIsText
=
mStartContainer
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
;
bool
endIsText
=
mEndContainer
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
;
nsINode
*
startGrandParent
=
mStartContainer
-
>
GetParentNode
(
)
;
nsINode
*
endGrandParent
=
mEndContainer
-
>
GetParentNode
(
)
;
if
(
!
(
(
startIsText
&
&
endIsText
&
&
startGrandParent
&
&
startGrandParent
=
=
endGrandParent
)
|
|
(
startIsText
&
&
startGrandParent
&
&
startGrandParent
=
=
mEndContainer
)
|
|
(
endIsText
&
&
endGrandParent
&
&
endGrandParent
=
=
mStartContainer
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
}
uint16_t
nodeType
=
aNewParent
.
NodeType
(
)
;
if
(
nodeType
=
=
nsIDOMNode
:
:
DOCUMENT_NODE
|
|
nodeType
=
=
nsIDOMNode
:
:
DOCUMENT_TYPE_NODE
|
|
nodeType
=
=
nsIDOMNode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_NODE_TYPE_ERR
)
;
return
;
}
RefPtr
<
DocumentFragment
>
docFrag
=
ExtractContents
(
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
!
docFrag
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCOMPtr
<
nsINodeList
>
children
=
aNewParent
.
ChildNodes
(
)
;
if
(
!
children
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
uint32_t
numChildren
=
children
-
>
Length
(
)
;
while
(
numChildren
)
{
nsCOMPtr
<
nsINode
>
child
=
children
-
>
Item
(
-
-
numChildren
)
;
if
(
!
child
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
aNewParent
.
RemoveChild
(
*
child
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
}
InsertNode
(
aNewParent
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
aNewParent
.
AppendChild
(
*
docFrag
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
SelectNode
(
aNewParent
aRv
)
;
}
NS_IMETHODIMP
nsRange
:
:
ToString
(
nsAString
&
aReturn
)
{
aReturn
.
Truncate
(
)
;
if
(
!
mIsPositioned
)
{
return
NS_OK
;
}
#
ifdef
DEBUG_range
printf
(
"
Range
dump
:
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
#
endif
if
(
mStartContainer
=
=
mEndContainer
)
{
nsCOMPtr
<
nsIDOMText
>
textNode
=
do_QueryInterface
(
mStartContainer
)
;
if
(
textNode
)
{
#
ifdef
DEBUG_range
nsCOMPtr
<
nsIContent
>
cN
=
do_QueryInterface
(
mStartContainer
)
;
if
(
cN
)
cN
-
>
List
(
stdout
)
;
printf
(
"
End
Range
dump
:
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
#
endif
if
(
NS_FAILED
(
textNode
-
>
SubstringData
(
mStartOffset
mEndOffset
-
mStartOffset
aReturn
)
)
)
return
NS_ERROR_UNEXPECTED
;
return
NS_OK
;
}
}
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsString
tempString
;
while
(
!
iter
-
>
IsDone
(
)
)
{
nsINode
*
n
=
iter
-
>
GetCurrentNode
(
)
;
#
ifdef
DEBUG_range
n
-
>
List
(
stdout
)
;
#
endif
nsCOMPtr
<
nsIDOMText
>
textNode
(
do_QueryInterface
(
n
)
)
;
if
(
textNode
)
{
if
(
n
=
=
mStartContainer
)
{
uint32_t
strLength
;
textNode
-
>
GetLength
(
&
strLength
)
;
textNode
-
>
SubstringData
(
mStartOffset
strLength
-
mStartOffset
tempString
)
;
aReturn
+
=
tempString
;
}
else
if
(
n
=
=
mEndContainer
)
{
textNode
-
>
SubstringData
(
0
mEndOffset
tempString
)
;
aReturn
+
=
tempString
;
}
else
{
textNode
-
>
GetData
(
tempString
)
;
aReturn
+
=
tempString
;
}
}
iter
-
>
Next
(
)
;
}
#
ifdef
DEBUG_range
printf
(
"
End
Range
dump
:
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
nsRange
:
:
Detach
(
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsRange
:
:
CreateContextualFragment
(
const
nsAString
&
aFragment
nsIDOMDocumentFragment
*
*
aReturn
)
{
if
(
mIsPositioned
)
{
return
nsContentUtils
:
:
CreateContextualFragment
(
mStartContainer
aFragment
false
aReturn
)
;
}
return
NS_ERROR_FAILURE
;
}
already_AddRefed
<
DocumentFragment
>
nsRange
:
:
CreateContextualFragment
(
const
nsAString
&
aFragment
ErrorResult
&
aRv
)
{
if
(
!
mIsPositioned
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
nsContentUtils
:
:
CreateContextualFragment
(
mStartContainer
aFragment
false
aRv
)
;
}
static
void
ExtractRectFromOffset
(
nsIFrame
*
aFrame
const
int32_t
aOffset
nsRect
*
aR
bool
aKeepLeft
bool
aClampToEdge
)
{
nsPoint
point
;
aFrame
-
>
GetPointFromOffset
(
aOffset
&
point
)
;
if
(
!
aClampToEdge
&
&
!
aR
-
>
Contains
(
point
)
)
{
aR
-
>
width
=
0
;
aR
-
>
x
=
point
.
x
;
return
;
}
if
(
aClampToEdge
)
{
point
=
aR
-
>
ClampPoint
(
point
)
;
}
if
(
aKeepLeft
)
{
aR
-
>
width
=
point
.
x
-
aR
-
>
x
;
}
else
{
aR
-
>
width
=
aR
-
>
XMost
(
)
-
point
.
x
;
aR
-
>
x
=
point
.
x
;
}
}
static
nsTextFrame
*
GetTextFrameForContent
(
nsIContent
*
aContent
bool
aFlushLayout
)
{
nsIPresShell
*
presShell
=
aContent
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
presShell
)
{
presShell
-
>
FrameConstructor
(
)
-
>
EnsureFrameForTextNode
(
static_cast
<
nsGenericDOMDataNode
*
>
(
aContent
)
)
;
if
(
aFlushLayout
)
{
aContent
-
>
OwnerDoc
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsTextFrame
(
)
)
{
return
static_cast
<
nsTextFrame
*
>
(
frame
)
;
}
}
return
nullptr
;
}
static
nsresult
GetPartialTextRect
(
nsLayoutUtils
:
:
RectCallback
*
aCallback
Sequence
<
nsString
>
*
aTextList
nsIContent
*
aContent
int32_t
aStartOffset
int32_t
aEndOffset
bool
aClampToEdge
bool
aFlushLayout
)
{
nsTextFrame
*
textFrame
=
GetTextFrameForContent
(
aContent
aFlushLayout
)
;
if
(
textFrame
)
{
nsIFrame
*
relativeTo
=
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
textFrame
)
;
for
(
nsTextFrame
*
f
=
textFrame
;
f
;
f
=
static_cast
<
nsTextFrame
*
>
(
f
-
>
GetNextContinuation
(
)
)
)
{
int32_t
fstart
=
f
-
>
GetContentOffset
(
)
fend
=
f
-
>
GetContentEnd
(
)
;
if
(
fend
<
=
aStartOffset
|
|
fstart
>
=
aEndOffset
)
continue
;
int32_t
textContentStart
=
fstart
;
int32_t
textContentEnd
=
fend
;
f
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
NS_ENSURE_TRUE
(
f
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
NS_ERROR_OUT_OF_MEMORY
)
;
bool
rtl
=
f
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
-
>
IsRightToLeft
(
)
;
nsRect
r
=
f
-
>
GetRectRelativeToSelf
(
)
;
if
(
fstart
<
aStartOffset
)
{
ExtractRectFromOffset
(
f
aStartOffset
&
r
rtl
aClampToEdge
)
;
textContentStart
=
aStartOffset
;
}
if
(
fend
>
aEndOffset
)
{
ExtractRectFromOffset
(
f
aEndOffset
&
r
!
rtl
aClampToEdge
)
;
textContentEnd
=
aEndOffset
;
}
r
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
f
r
relativeTo
)
;
aCallback
-
>
AddRect
(
r
)
;
if
(
aTextList
)
{
nsIFrame
:
:
RenderedText
renderedText
=
f
-
>
GetRenderedText
(
textContentStart
textContentEnd
nsIFrame
:
:
TextOffsetType
:
:
OFFSETS_IN_CONTENT_TEXT
nsIFrame
:
:
TrailingWhitespace
:
:
DONT_TRIM_TRAILING_WHITESPACE
)
;
aTextList
-
>
AppendElement
(
renderedText
.
mString
fallible
)
;
}
}
}
return
NS_OK
;
}
void
nsRange
:
:
CollectClientRectsAndText
(
nsLayoutUtils
:
:
RectCallback
*
aCollector
Sequence
<
nsString
>
*
aTextList
nsRange
*
aRange
nsINode
*
aStartContainer
uint32_t
aStartOffset
nsINode
*
aEndContainer
uint32_t
aEndOffset
bool
aClampToEdge
bool
aFlushLayout
)
{
MOZ_ASSERT
(
IsValidOffset
(
aStartOffset
)
)
;
MOZ_ASSERT
(
IsValidOffset
(
aEndOffset
)
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
aStartContainer
;
nsCOMPtr
<
nsINode
>
endContainer
=
aEndContainer
;
if
(
!
aStartContainer
-
>
IsInUncomposedDoc
(
)
)
{
return
;
}
if
(
aFlushLayout
)
{
aStartContainer
-
>
OwnerDoc
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
aStartContainer
-
>
IsInUncomposedDoc
(
)
)
{
return
;
}
}
RangeSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
if
(
iter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aStartContainer
)
;
if
(
content
&
&
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
nsTextFrame
*
textFrame
=
GetTextFrameForContent
(
content
aFlushLayout
)
;
if
(
textFrame
)
{
int32_t
outOffset
;
nsIFrame
*
outFrame
;
textFrame
-
>
GetChildFrameContainingOffset
(
static_cast
<
int32_t
>
(
aStartOffset
)
false
&
outOffset
&
outFrame
)
;
if
(
outFrame
)
{
nsIFrame
*
relativeTo
=
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
outFrame
)
;
nsRect
r
=
outFrame
-
>
GetRectRelativeToSelf
(
)
;
ExtractRectFromOffset
(
outFrame
static_cast
<
int32_t
>
(
aStartOffset
)
&
r
false
aClampToEdge
)
;
r
.
width
=
0
;
r
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
outFrame
r
relativeTo
)
;
aCollector
-
>
AddRect
(
r
)
;
}
}
}
return
;
}
do
{
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
iter
.
Next
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
if
(
!
content
)
continue
;
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
node
=
=
startContainer
)
{
int32_t
offset
=
startContainer
=
=
endContainer
?
static_cast
<
int32_t
>
(
aEndOffset
)
:
content
-
>
GetText
(
)
-
>
GetLength
(
)
;
GetPartialTextRect
(
aCollector
aTextList
content
static_cast
<
int32_t
>
(
aStartOffset
)
offset
aClampToEdge
aFlushLayout
)
;
continue
;
}
else
if
(
node
=
=
endContainer
)
{
GetPartialTextRect
(
aCollector
aTextList
content
0
static_cast
<
int32_t
>
(
aEndOffset
)
aClampToEdge
aFlushLayout
)
;
continue
;
}
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsLayoutUtils
:
:
GetAllInFlowRectsAndTexts
(
frame
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
frame
)
aCollector
aTextList
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
;
}
}
while
(
!
iter
.
IsDone
(
)
)
;
}
NS_IMETHODIMP
nsRange
:
:
GetBoundingClientRect
(
nsIDOMClientRect
*
*
aResult
)
{
*
aResult
=
GetBoundingClientRect
(
true
)
.
take
(
)
;
return
NS_OK
;
}
already_AddRefed
<
DOMRect
>
nsRange
:
:
GetBoundingClientRect
(
bool
aClampToEdge
bool
aFlushLayout
)
{
RefPtr
<
DOMRect
>
rect
=
new
DOMRect
(
ToSupports
(
this
)
)
;
if
(
!
mStartContainer
)
{
return
rect
.
forget
(
)
;
}
nsLayoutUtils
:
:
RectAccumulator
accumulator
;
CollectClientRectsAndText
(
&
accumulator
nullptr
this
mStartContainer
mStartOffset
mEndContainer
mEndOffset
aClampToEdge
aFlushLayout
)
;
nsRect
r
=
accumulator
.
mResultRect
.
IsEmpty
(
)
?
accumulator
.
mFirstRect
:
accumulator
.
mResultRect
;
rect
-
>
SetLayoutRect
(
r
)
;
return
rect
.
forget
(
)
;
}
NS_IMETHODIMP
nsRange
:
:
GetClientRects
(
nsIDOMClientRectList
*
*
aResult
)
{
*
aResult
=
GetClientRects
(
true
)
.
take
(
)
;
return
NS_OK
;
}
already_AddRefed
<
DOMRectList
>
nsRange
:
:
GetClientRects
(
bool
aClampToEdge
bool
aFlushLayout
)
{
if
(
!
mStartContainer
)
{
return
nullptr
;
}
RefPtr
<
DOMRectList
>
rectList
=
new
DOMRectList
(
static_cast
<
nsIDOMRange
*
>
(
this
)
)
;
nsLayoutUtils
:
:
RectListBuilder
builder
(
rectList
)
;
CollectClientRectsAndText
(
&
builder
nullptr
this
mStartContainer
mStartOffset
mEndContainer
mEndOffset
aClampToEdge
aFlushLayout
)
;
return
rectList
.
forget
(
)
;
}
void
nsRange
:
:
GetClientRectsAndTexts
(
mozilla
:
:
dom
:
:
ClientRectsAndTexts
&
aResult
ErrorResult
&
aErr
)
{
if
(
!
mStartContainer
)
{
return
;
}
aResult
.
mRectList
=
new
DOMRectList
(
static_cast
<
nsIDOMRange
*
>
(
this
)
)
;
nsLayoutUtils
:
:
RectListBuilder
builder
(
aResult
.
mRectList
)
;
CollectClientRectsAndText
(
&
builder
&
aResult
.
mTextList
this
mStartContainer
mStartOffset
mEndContainer
mEndOffset
true
true
)
;
}
NS_IMETHODIMP
nsRange
:
:
GetUsedFontFaces
(
nsIDOMFontFaceList
*
*
aResult
)
{
*
aResult
=
nullptr
;
NS_ENSURE_TRUE
(
mStartContainer
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsINode
>
startContainer
=
do_QueryInterface
(
mStartContainer
)
;
nsCOMPtr
<
nsINode
>
endContainer
=
do_QueryInterface
(
mEndContainer
)
;
nsIDocument
*
doc
=
mStartContainer
-
>
OwnerDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_UNEXPECTED
)
;
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
NS_ENSURE_TRUE
(
mStartContainer
-
>
IsInUncomposedDoc
(
)
NS_ERROR_UNEXPECTED
)
;
RefPtr
<
nsFontFaceList
>
fontFaceList
=
new
nsFontFaceList
(
)
;
RangeSubtreeIterator
iter
;
nsresult
rv
=
iter
.
Init
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
!
iter
.
IsDone
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
iter
.
GetCurrentNode
(
)
;
iter
.
Next
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
if
(
!
content
)
{
continue
;
}
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
continue
;
}
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
if
(
node
=
=
startContainer
)
{
int32_t
offset
=
startContainer
=
=
endContainer
?
mEndOffset
:
content
-
>
GetText
(
)
-
>
GetLength
(
)
;
nsLayoutUtils
:
:
GetFontFacesForText
(
frame
mStartOffset
offset
true
fontFaceList
)
;
continue
;
}
if
(
node
=
=
endContainer
)
{
nsLayoutUtils
:
:
GetFontFacesForText
(
frame
0
mEndOffset
true
fontFaceList
)
;
continue
;
}
}
nsLayoutUtils
:
:
GetFontFacesForFrames
(
frame
fontFaceList
)
;
}
fontFaceList
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsINode
*
nsRange
:
:
GetRegisteredCommonAncestor
(
)
{
NS_ASSERTION
(
IsInSelection
(
)
"
GetRegisteredCommonAncestor
only
valid
for
range
in
selection
"
)
;
nsINode
*
ancestor
=
GetNextRangeCommonAncestor
(
mStartContainer
)
;
while
(
ancestor
)
{
nsTHashtable
<
nsPtrHashKey
<
nsRange
>
>
*
ranges
=
ancestor
-
>
GetExistingCommonAncestorRanges
(
)
;
if
(
ranges
-
>
GetEntry
(
this
)
)
{
break
;
}
ancestor
=
GetNextRangeCommonAncestor
(
ancestor
-
>
GetParentNode
(
)
)
;
}
NS_ASSERTION
(
ancestor
"
can
'
t
find
common
ancestor
for
selected
range
"
)
;
return
ancestor
;
}
bool
nsRange
:
:
AutoInvalidateSelection
:
:
mIsNested
;
nsRange
:
:
AutoInvalidateSelection
:
:
~
AutoInvalidateSelection
(
)
{
NS_ASSERTION
(
mWasInSelection
=
=
mRange
-
>
IsInSelection
(
)
"
Range
got
unselected
in
AutoInvalidateSelection
block
"
)
;
if
(
!
mCommonAncestor
)
{
return
;
}
mIsNested
=
false
;
:
:
InvalidateAllFrames
(
mCommonAncestor
)
;
nsINode
*
commonAncestor
=
mRange
-
>
GetRegisteredCommonAncestor
(
)
;
if
(
commonAncestor
&
&
commonAncestor
!
=
mCommonAncestor
)
{
:
:
InvalidateAllFrames
(
commonAncestor
)
;
}
}
already_AddRefed
<
nsRange
>
nsRange
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
|
|
!
window
-
>
GetDoc
(
)
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
window
-
>
GetDoc
(
)
-
>
CreateRange
(
aRv
)
;
}
static
bool
ExcludeIfNextToNonSelectable
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
&
&
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
;
}
void
nsRange
:
:
ExcludeNonSelectableNodes
(
nsTArray
<
RefPtr
<
nsRange
>
>
*
aOutRanges
)
{
MOZ_ASSERT
(
mIsPositioned
)
;
MOZ_ASSERT
(
mEndContainer
)
;
MOZ_ASSERT
(
mStartContainer
)
;
nsRange
*
range
=
this
;
RefPtr
<
nsRange
>
newRange
;
while
(
range
)
{
nsCOMPtr
<
nsIContentIterator
>
iter
=
NS_NewPreContentIterator
(
)
;
nsresult
rv
=
iter
-
>
Init
(
range
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
bool
added
=
false
;
bool
seenSelectable
=
false
;
nsIContent
*
firstNonSelectableContent
=
nullptr
;
while
(
true
)
{
ErrorResult
err
;
nsINode
*
node
=
iter
-
>
GetCurrentNode
(
)
;
iter
-
>
Next
(
)
;
bool
selectable
=
true
;
nsIContent
*
content
=
node
&
&
node
-
>
IsContent
(
)
?
node
-
>
AsContent
(
)
:
nullptr
;
if
(
content
)
{
if
(
firstNonSelectableContent
&
&
ExcludeIfNextToNonSelectable
(
content
)
)
{
selectable
=
false
;
}
if
(
selectable
)
{
nsIFrame
*
frame
=
content
-
>
GetPrimaryFrame
(
)
;
for
(
nsIContent
*
p
=
content
;
!
frame
&
&
(
p
=
p
-
>
GetParent
(
)
)
;
)
{
frame
=
p
-
>
GetPrimaryFrame
(
)
;
}
if
(
frame
)
{
selectable
=
frame
-
>
IsSelectable
(
nullptr
)
;
}
}
}
if
(
!
selectable
)
{
if
(
!
firstNonSelectableContent
)
{
firstNonSelectableContent
=
content
;
}
if
(
iter
-
>
IsDone
(
)
&
&
seenSelectable
)
{
range
-
>
SetEndBefore
(
*
firstNonSelectableContent
err
)
;
}
}
else
if
(
firstNonSelectableContent
)
{
if
(
range
=
=
this
&
&
!
seenSelectable
)
{
range
-
>
SetStartBefore
(
*
node
err
)
;
if
(
err
.
Failed
(
)
)
{
return
;
}
break
;
}
else
{
nsINode
*
endContainer
=
range
-
>
mEndContainer
;
int32_t
endOffset
=
range
-
>
mEndOffset
;
range
-
>
SetEndBefore
(
*
firstNonSelectableContent
err
)
;
if
(
!
added
&
&
!
err
.
Failed
(
)
)
{
aOutRanges
-
>
AppendElement
(
range
)
;
}
nsINode
*
startContainer
=
node
;
int32_t
startOffset
=
0
;
if
(
content
&
&
content
-
>
HasIndependentSelection
(
)
)
{
nsINode
*
parent
=
startContainer
-
>
GetParent
(
)
;
if
(
parent
)
{
startOffset
=
parent
-
>
IndexOf
(
startContainer
)
;
startContainer
=
parent
;
}
}
rv
=
CreateRange
(
startContainer
startOffset
endContainer
endOffset
getter_AddRefs
(
newRange
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
newRange
-
>
Collapsed
(
)
)
{
newRange
=
nullptr
;
}
range
=
newRange
;
break
;
}
}
else
{
seenSelectable
=
true
;
if
(
!
added
)
{
added
=
true
;
aOutRanges
-
>
AppendElement
(
range
)
;
}
}
if
(
iter
-
>
IsDone
(
)
)
{
return
;
}
}
}
}
struct
InnerTextAccumulator
{
explicit
InnerTextAccumulator
(
mozilla
:
:
dom
:
:
DOMString
&
aValue
)
:
mString
(
aValue
.
AsAString
(
)
)
mRequiredLineBreakCount
(
0
)
{
}
void
FlushLineBreaks
(
)
{
while
(
mRequiredLineBreakCount
>
0
)
{
if
(
!
mString
.
IsEmpty
(
)
)
{
mString
.
Append
(
'
\
n
'
)
;
}
-
-
mRequiredLineBreakCount
;
}
}
void
Append
(
char
aCh
)
{
Append
(
nsAutoString
(
aCh
)
)
;
}
void
Append
(
const
nsAString
&
aString
)
{
if
(
aString
.
IsEmpty
(
)
)
{
return
;
}
FlushLineBreaks
(
)
;
mString
.
Append
(
aString
)
;
}
void
AddRequiredLineBreakCount
(
int8_t
aCount
)
{
mRequiredLineBreakCount
=
std
:
:
max
(
mRequiredLineBreakCount
aCount
)
;
}
nsAString
&
mString
;
int8_t
mRequiredLineBreakCount
;
}
;
static
bool
IsVisibleAndNotInReplacedElement
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
|
|
!
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
&
&
!
f
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
button
)
&
&
!
f
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ElementIsVisibleNoFlush
(
Element
*
aElement
)
{
if
(
!
aElement
)
{
return
false
;
}
RefPtr
<
nsStyleContext
>
sc
=
nsComputedDOMStyle
:
:
GetStyleContextNoFlush
(
aElement
nullptr
nullptr
)
;
return
sc
&
&
sc
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
static
void
AppendTransformedText
(
InnerTextAccumulator
&
aResult
nsGenericDOMDataNode
*
aTextNode
uint32_t
aStart
uint32_t
aEnd
)
{
nsIFrame
*
frame
=
aTextNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
IsVisibleAndNotInReplacedElement
(
frame
)
)
{
return
;
}
nsIFrame
:
:
RenderedText
text
=
frame
-
>
GetRenderedText
(
aStart
aEnd
)
;
aResult
.
Append
(
text
.
mString
)
;
}
enum
TreeTraversalState
{
AT_NODE
AFTER_NODE
}
;
static
int8_t
GetRequiredInnerTextLineBreakCount
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
p
)
)
{
return
2
;
}
const
nsStyleDisplay
*
styleDisplay
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
styleDisplay
-
>
IsBlockOutside
(
aFrame
)
|
|
styleDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCaption
)
{
return
1
;
}
return
0
;
}
static
bool
IsLastCellOfRow
(
nsIFrame
*
aFrame
)
{
LayoutFrameType
type
=
aFrame
-
>
Type
(
)
;
if
(
type
!
=
LayoutFrameType
:
:
TableCell
&
&
type
!
=
LayoutFrameType
:
:
BCTableCell
)
{
return
true
;
}
for
(
nsIFrame
*
c
=
aFrame
;
c
;
c
=
c
-
>
GetNextContinuation
(
)
)
{
if
(
c
-
>
GetNextSibling
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsLastRowOfRowGroup
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsTableRowFrame
(
)
)
{
return
true
;
}
for
(
nsIFrame
*
c
=
aFrame
;
c
;
c
=
c
-
>
GetNextContinuation
(
)
)
{
if
(
c
-
>
GetNextSibling
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
IsLastNonemptyRowGroupOfTable
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsTableRowGroupFrame
(
)
)
{
return
true
;
}
for
(
nsIFrame
*
c
=
aFrame
;
c
;
c
=
c
-
>
GetNextContinuation
(
)
)
{
for
(
nsIFrame
*
next
=
c
-
>
GetNextSibling
(
)
;
next
;
next
=
next
-
>
GetNextSibling
(
)
)
{
if
(
next
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
return
false
;
}
}
}
return
true
;
}
void
nsRange
:
:
GetInnerTextNoFlush
(
DOMString
&
aValue
ErrorResult
&
aError
nsIContent
*
aStartContainer
uint32_t
aStartOffset
nsIContent
*
aEndContainer
uint32_t
aEndOffset
)
{
InnerTextAccumulator
result
(
aValue
)
;
nsIContent
*
currentNode
=
aStartContainer
;
TreeTraversalState
currentState
=
AFTER_NODE
;
if
(
aStartContainer
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
auto
t
=
static_cast
<
nsGenericDOMDataNode
*
>
(
aStartContainer
)
;
if
(
aStartContainer
=
=
aEndContainer
)
{
AppendTransformedText
(
result
t
aStartOffset
aEndOffset
)
;
return
;
}
AppendTransformedText
(
result
t
aStartOffset
t
-
>
TextLength
(
)
)
;
}
else
{
if
(
uint32_t
(
aStartOffset
)
<
aStartContainer
-
>
GetChildCount
(
)
)
{
currentNode
=
aStartContainer
-
>
GetChildAt
(
aStartOffset
)
;
currentState
=
AT_NODE
;
}
}
nsIContent
*
endNode
=
aEndContainer
;
TreeTraversalState
endState
=
AFTER_NODE
;
if
(
aEndContainer
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
endState
=
AT_NODE
;
}
else
{
if
(
aEndOffset
<
aEndContainer
-
>
GetChildCount
(
)
)
{
endNode
=
aEndContainer
-
>
GetChildAt
(
aEndOffset
)
;
endState
=
AT_NODE
;
}
}
while
(
currentNode
!
=
endNode
|
|
currentState
!
=
endState
)
{
nsIFrame
*
f
=
currentNode
-
>
GetPrimaryFrame
(
)
;
bool
isVisibleAndNotReplaced
=
IsVisibleAndNotInReplacedElement
(
f
)
;
if
(
currentState
=
=
AT_NODE
)
{
bool
isText
=
currentNode
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
;
if
(
isText
&
&
currentNode
-
>
GetParent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
rp
)
&
&
ElementIsVisibleNoFlush
(
currentNode
-
>
GetParent
(
)
-
>
AsElement
(
)
)
)
{
nsAutoString
str
;
currentNode
-
>
GetTextContent
(
str
aError
)
;
result
.
Append
(
str
)
;
}
else
if
(
isVisibleAndNotReplaced
)
{
result
.
AddRequiredLineBreakCount
(
GetRequiredInnerTextLineBreakCount
(
f
)
)
;
if
(
isText
)
{
nsIFrame
:
:
RenderedText
text
=
f
-
>
GetRenderedText
(
)
;
result
.
Append
(
text
.
mString
)
;
}
}
nsIContent
*
child
=
currentNode
-
>
GetFirstChild
(
)
;
if
(
child
)
{
currentNode
=
child
;
continue
;
}
currentState
=
AFTER_NODE
;
}
if
(
currentNode
=
=
endNode
&
&
currentState
=
=
endState
)
{
break
;
}
if
(
isVisibleAndNotReplaced
)
{
if
(
currentNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
result
.
Append
(
'
\
n
'
)
;
}
switch
(
f
-
>
StyleDisplay
(
)
-
>
mDisplay
)
{
case
StyleDisplay
:
:
TableCell
:
if
(
!
IsLastCellOfRow
(
f
)
)
{
result
.
Append
(
'
\
t
'
)
;
}
break
;
case
StyleDisplay
:
:
TableRow
:
if
(
!
IsLastRowOfRowGroup
(
f
)
|
|
!
IsLastNonemptyRowGroupOfTable
(
f
-
>
GetParent
(
)
)
)
{
result
.
Append
(
'
\
n
'
)
;
}
break
;
default
:
break
;
}
result
.
AddRequiredLineBreakCount
(
GetRequiredInnerTextLineBreakCount
(
f
)
)
;
}
nsIContent
*
next
=
currentNode
-
>
GetNextSibling
(
)
;
if
(
next
)
{
currentNode
=
next
;
currentState
=
AT_NODE
;
}
else
{
currentNode
=
currentNode
-
>
GetParent
(
)
;
}
}
if
(
aEndContainer
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
nsGenericDOMDataNode
*
t
=
static_cast
<
nsGenericDOMDataNode
*
>
(
aEndContainer
)
;
AppendTransformedText
(
result
t
0
aEndOffset
)
;
}
}
