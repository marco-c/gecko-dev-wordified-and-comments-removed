#
include
"
TextDirectiveUtil
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
nsFind
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
ContentIterator
.
h
"
#
include
"
Document
.
h
"
#
include
"
fragmentdirectives_ffi_generated
.
h
"
#
include
"
Text
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
ResultVariant
.
h
"
#
include
"
mozilla
/
intl
/
WordBreaker
.
h
"
#
include
"
mozilla
/
SelectionMovementUtils
.
h
"
namespace
mozilla
:
:
dom
{
LazyLogModule
gFragmentDirectiveLog
(
"
FragmentDirective
"
)
;
Result
<
nsString
ErrorResult
>
TextDirectiveUtil
:
:
RangeContentAsString
(
nsRange
*
aRange
)
{
ErrorResult
rv
;
nsString
content
;
if
(
!
aRange
)
{
return
content
;
}
aRange
-
>
ToString
(
content
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
content
.
CompressWhitespace
(
)
;
return
content
;
}
Result
<
nsString
ErrorResult
>
TextDirectiveUtil
:
:
RangeContentAsFoldCase
(
nsRange
*
aRange
)
{
Result
<
nsString
ErrorResult
>
contentResult
=
RangeContentAsString
(
aRange
)
;
if
(
MOZ_UNLIKELY
(
contentResult
.
isErr
(
)
)
)
{
return
contentResult
.
propagateErr
(
)
;
}
nsString
content
=
contentResult
.
unwrap
(
)
;
content
.
CompressWhitespace
(
)
;
ToFoldedCase
(
content
)
;
return
content
;
}
bool
TextDirectiveUtil
:
:
NodeIsVisibleTextNode
(
const
nsINode
&
aNode
)
{
const
Text
*
text
=
Text
:
:
FromNode
(
aNode
)
;
if
(
!
text
)
{
return
false
;
}
const
nsIFrame
*
frame
=
text
-
>
GetPrimaryFrame
(
)
;
return
frame
&
&
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
RefPtr
<
nsRange
>
TextDirectiveUtil
:
:
FindStringInRange
(
const
RangeBoundary
&
aSearchStart
const
RangeBoundary
&
aSearchEnd
const
nsAString
&
aQuery
bool
aWordStartBounded
bool
aWordEndBounded
nsContentUtils
:
:
NodeIndexCache
*
aCache
)
{
TEXT_FRAGMENT_LOG
(
"
query
=
'
{
}
'
wordStartBounded
=
'
{
}
'
wordEndBounded
=
'
{
}
'
.
\
n
"
NS_ConvertUTF16toUTF8
(
aQuery
)
aWordStartBounded
aWordEndBounded
)
;
RefPtr
<
nsFind
>
finder
=
new
nsFind
(
)
;
finder
-
>
SetWordStartBounded
(
aWordStartBounded
)
;
finder
-
>
SetWordEndBounded
(
aWordEndBounded
)
;
finder
-
>
SetCaseSensitive
(
false
)
;
finder
-
>
SetNodeIndexCache
(
aCache
)
;
RefPtr
<
nsRange
>
result
=
finder
-
>
FindFromRangeBoundaries
(
aQuery
aSearchStart
aSearchEnd
)
;
if
(
!
result
|
|
result
-
>
Collapsed
(
)
)
{
TEXT_FRAGMENT_LOG
(
"
Did
not
find
query
'
{
}
'
"
NS_ConvertUTF16toUTF8
(
aQuery
)
)
;
}
else
{
auto
rangeToString
=
[
]
(
nsRange
*
range
)
-
>
nsCString
{
nsString
rangeString
;
range
-
>
ToString
(
rangeString
IgnoreErrors
(
)
)
;
return
NS_ConvertUTF16toUTF8
(
rangeString
)
;
}
;
TEXT_FRAGMENT_LOG
(
"
find
returned
'
{
}
'
"
rangeToString
(
result
)
)
;
}
return
result
;
}
RangeBoundary
TextDirectiveUtil
:
:
MoveRangeBoundaryOneWord
(
const
RangeBoundary
&
aRangeBoundary
TextScanDirection
aDirection
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
PeekOffsetOptions
options
=
{
PeekOffsetOption
:
:
JumpLines
PeekOffsetOption
:
:
StopAtScroller
PeekOffsetOption
:
:
IsKeyboardSelect
}
;
Result
<
RangeBoundary
nsresult
>
newBoundary
=
SelectionMovementUtils
:
:
MoveRangeBoundaryToSomewhere
(
aRangeBoundary
aDirection
=
=
TextScanDirection
:
:
Left
?
nsDirection
:
:
eDirPrevious
:
nsDirection
:
:
eDirNext
aDirection
=
=
TextScanDirection
:
:
Left
?
CaretAssociationHint
:
:
Before
:
CaretAssociationHint
:
:
After
intl
:
:
BidiEmbeddingLevel
:
:
DefaultLTR
(
)
nsSelectionAmount
:
:
eSelectWord
options
)
;
return
newBoundary
.
unwrapOr
(
{
}
)
;
}
bool
TextDirectiveUtil
:
:
IsWhitespaceAtPosition
(
const
Text
*
aText
uint32_t
aPos
)
{
if
(
!
aText
|
|
aText
-
>
Length
(
)
=
=
0
|
|
aPos
>
=
aText
-
>
Length
(
)
)
{
return
false
;
}
const
nsTextFragment
&
frag
=
aText
-
>
TextFragment
(
)
;
const
char
NBSP_CHAR
=
char
(
0xA0
)
;
if
(
frag
.
Is2b
(
)
)
{
const
char16_t
*
content
=
frag
.
Get2b
(
)
;
return
IsSpaceCharacter
(
content
[
aPos
]
)
|
|
content
[
aPos
]
=
=
char16_t
(
NBSP_CHAR
)
;
}
const
char
*
content
=
frag
.
Get1b
(
)
;
return
IsSpaceCharacter
(
content
[
aPos
]
)
|
|
content
[
aPos
]
=
=
NBSP_CHAR
;
}
bool
TextDirectiveUtil
:
:
NodeIsSearchInvisible
(
nsINode
&
aNode
)
{
if
(
!
aNode
.
IsElement
(
)
)
{
return
false
;
}
nsAtom
*
nodeNameAtom
=
aNode
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
FragmentOrElement
:
:
IsHTMLVoid
(
nodeNameAtom
)
)
{
return
true
;
}
if
(
aNode
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
image
nsGkAtoms
:
:
meter
nsGkAtoms
:
:
object
nsGkAtoms
:
:
progress
nsGkAtoms
:
:
style
nsGkAtoms
:
:
script
nsGkAtoms
:
:
video
nsGkAtoms
:
:
audio
)
)
{
return
true
;
}
if
(
aNode
.
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
return
aNode
.
GetAttributes
(
)
-
>
GetNamedItem
(
u
"
multiple
"
_ns
)
=
=
nullptr
;
}
const
Element
*
nodeAsElement
=
Element
:
:
FromNode
(
aNode
)
;
const
RefPtr
<
const
ComputedStyle
>
computedStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
nodeAsElement
)
;
return
!
computedStyle
|
|
computedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
None
;
}
bool
TextDirectiveUtil
:
:
NodeHasBlockLevelDisplay
(
nsINode
&
aNode
)
{
if
(
!
aNode
.
IsElement
(
)
)
{
return
false
;
}
const
Element
*
nodeAsElement
=
Element
:
:
FromNode
(
aNode
)
;
const
RefPtr
<
const
ComputedStyle
>
computedStyle
=
nsComputedDOMStyle
:
:
GetComputedStyleNoFlush
(
nodeAsElement
)
;
if
(
!
computedStyle
)
{
return
false
;
}
const
StyleDisplay
&
styleDisplay
=
computedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
;
return
styleDisplay
=
=
StyleDisplay
:
:
Block
|
|
styleDisplay
=
=
StyleDisplay
:
:
Table
|
|
styleDisplay
=
=
StyleDisplay
:
:
FlowRoot
|
|
styleDisplay
=
=
StyleDisplay
:
:
Grid
|
|
styleDisplay
=
=
StyleDisplay
:
:
Flex
|
|
styleDisplay
.
IsListItem
(
)
;
}
nsINode
*
TextDirectiveUtil
:
:
GetBlockAncestorForNode
(
nsINode
*
aNode
)
{
RefPtr
<
nsINode
>
curNode
=
aNode
;
while
(
curNode
)
{
if
(
!
curNode
-
>
IsText
(
)
&
&
NodeHasBlockLevelDisplay
(
*
curNode
)
)
{
return
curNode
;
}
curNode
=
curNode
-
>
GetParentNode
(
)
;
}
return
aNode
-
>
GetOwnerDocument
(
)
;
}
bool
TextDirectiveUtil
:
:
NodeIsPartOfNonSearchableSubTree
(
nsINode
&
aNode
)
{
nsINode
*
node
=
&
aNode
;
do
{
if
(
NodeIsSearchInvisible
(
*
node
)
)
{
return
true
;
}
}
while
(
(
node
=
node
-
>
GetParentOrShadowHostNode
(
)
)
)
;
return
false
;
}
bool
TextDirectiveUtil
:
:
IsAtWordBoundary
(
const
nsAString
&
aText
uint32_t
aPosition
)
{
const
intl
:
:
WordRange
wordRange
=
intl
:
:
WordBreaker
:
:
FindWord
(
aText
aPosition
)
;
return
wordRange
.
mBegin
=
=
aPosition
|
|
wordRange
.
mEnd
=
=
aPosition
;
}
RangeBoundary
TextDirectiveUtil
:
:
GetBoundaryPointAtIndex
(
uint32_t
aIndex
const
nsTArray
<
RefPtr
<
Text
>
>
&
aTextNodeList
IsEndIndex
aIsEndIndex
)
{
uint32_t
counted
=
0
;
for
(
Text
*
curNode
:
aTextNodeList
)
{
uint32_t
nodeEnd
=
counted
+
curNode
-
>
Length
(
)
;
if
(
aIsEndIndex
=
=
IsEndIndex
:
:
Yes
)
{
+
+
nodeEnd
;
}
if
(
nodeEnd
>
aIndex
)
{
return
RangeBoundary
(
curNode
-
>
AsNode
(
)
aIndex
-
counted
)
;
}
counted
+
=
curNode
-
>
Length
(
)
;
}
return
{
}
;
}
void
TextDirectiveUtil
:
:
AdvanceStartToNextNonWhitespacePosition
(
nsRange
&
aRange
)
{
while
(
!
aRange
.
Collapsed
(
)
)
{
RefPtr
<
nsINode
>
node
=
aRange
.
GetStartContainer
(
)
;
MOZ_ASSERT
(
node
)
;
const
uint32_t
offset
=
aRange
.
StartOffset
(
)
;
if
(
NodeIsPartOfNonSearchableSubTree
(
*
node
)
|
|
!
NodeIsVisibleTextNode
(
*
node
)
|
|
offset
=
=
node
-
>
Length
(
)
)
{
if
(
NS_FAILED
(
aRange
.
SetStart
(
node
-
>
GetNextNode
(
)
0
)
)
)
{
return
;
}
continue
;
}
const
Text
*
text
=
Text
:
:
FromNode
(
node
)
;
MOZ_ASSERT
(
text
)
;
if
(
!
IsWhitespaceAtPosition
(
text
offset
)
)
{
return
;
}
aRange
.
SetStart
(
node
offset
+
1
)
;
}
}
RangeBoundary
TextDirectiveUtil
:
:
MoveBoundaryToNextNonWhitespacePosition
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
nsINode
*
node
=
aRangeBoundary
.
GetContainer
(
)
;
uint32_t
offset
=
*
aRangeBoundary
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
;
while
(
node
)
{
if
(
TextDirectiveUtil
:
:
NodeIsPartOfNonSearchableSubTree
(
*
node
)
|
|
!
TextDirectiveUtil
:
:
NodeIsVisibleTextNode
(
*
node
)
|
|
offset
=
=
node
-
>
Length
(
)
)
{
nsINode
*
newNode
=
node
-
>
GetNextNode
(
)
;
if
(
!
newNode
)
{
return
aRangeBoundary
;
}
node
=
newNode
;
offset
=
0
;
continue
;
}
const
Text
*
text
=
Text
:
:
FromNode
(
node
)
;
MOZ_ASSERT
(
text
)
;
if
(
TextDirectiveUtil
:
:
IsWhitespaceAtPosition
(
text
offset
)
)
{
+
+
offset
;
continue
;
}
return
{
node
offset
}
;
}
MOZ_ASSERT_UNREACHABLE
(
"
All
code
paths
must
return
in
the
loop
.
"
)
;
return
{
}
;
}
RangeBoundary
TextDirectiveUtil
:
:
MoveBoundaryToPreviousNonWhitespacePosition
(
const
RangeBoundary
&
aRangeBoundary
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
nsINode
*
node
=
aRangeBoundary
.
GetContainer
(
)
;
uint32_t
offset
=
*
aRangeBoundary
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
;
while
(
node
)
{
if
(
TextDirectiveUtil
:
:
NodeIsPartOfNonSearchableSubTree
(
*
node
)
|
|
!
TextDirectiveUtil
:
:
NodeIsVisibleTextNode
(
*
node
)
|
|
offset
=
=
0
)
{
nsIContent
*
newNode
=
node
-
>
GetPrevNode
(
)
;
if
(
!
newNode
)
{
return
aRangeBoundary
;
}
node
=
newNode
;
offset
=
node
-
>
Length
(
)
;
continue
;
}
const
Text
*
text
=
Text
:
:
FromNode
(
node
)
;
MOZ_ASSERT
(
text
)
;
if
(
TextDirectiveUtil
:
:
IsWhitespaceAtPosition
(
text
offset
-
1
)
)
{
-
-
offset
;
continue
;
}
return
{
node
offset
}
;
}
MOZ_ASSERT_UNREACHABLE
(
"
All
code
paths
must
return
in
the
loop
.
"
)
;
return
{
}
;
}
Result
<
RangeBoundary
ErrorResult
>
TextDirectiveUtil
:
:
FindNextBlockBoundary
(
const
RangeBoundary
&
aRangeBoundary
TextScanDirection
aDirection
)
{
MOZ_ASSERT
(
aRangeBoundary
.
IsSetAndValid
(
)
)
;
auto
findNextBlockBoundaryInternal
=
[
aDirection
]
(
const
RangeBoundary
&
rangeBoundary
)
-
>
Result
<
RangeBoundary
ErrorResult
>
{
PeekOffsetOptions
options
=
{
PeekOffsetOption
:
:
JumpLines
PeekOffsetOption
:
:
StopAtScroller
PeekOffsetOption
:
:
IsKeyboardSelect
PeekOffsetOption
:
:
Extend
}
;
return
SelectionMovementUtils
:
:
MoveRangeBoundaryToSomewhere
(
rangeBoundary
aDirection
=
=
TextScanDirection
:
:
Left
?
nsDirection
:
:
eDirPrevious
:
nsDirection
:
:
eDirNext
CaretAssociationHint
:
:
After
intl
:
:
BidiEmbeddingLevel
:
:
DefaultLTR
(
)
nsSelectionAmount
:
:
eSelectParagraph
options
)
.
mapErr
(
[
]
(
nsresult
rv
)
{
return
ErrorResult
(
rv
)
;
}
)
;
}
;
auto
maybeNewBoundary
=
findNextBlockBoundaryInternal
(
aRangeBoundary
)
;
if
(
MOZ_UNLIKELY
(
maybeNewBoundary
.
isErr
(
)
)
)
{
return
maybeNewBoundary
.
propagateErr
(
)
;
}
auto
newBoundary
=
maybeNewBoundary
.
unwrap
(
)
;
while
(
NormalizedRangeBoundariesAreEqual
(
aRangeBoundary
newBoundary
)
)
{
maybeNewBoundary
=
findNextBlockBoundaryInternal
(
newBoundary
)
;
if
(
MOZ_UNLIKELY
(
maybeNewBoundary
.
isErr
(
)
)
)
{
return
maybeNewBoundary
.
propagateErr
(
)
;
}
if
(
maybeNewBoundary
.
inspect
(
)
=
=
newBoundary
)
{
return
newBoundary
;
}
newBoundary
=
maybeNewBoundary
.
unwrap
(
)
;
}
return
newBoundary
;
}
Result
<
Maybe
<
RangeBoundary
>
ErrorResult
>
TextDirectiveUtil
:
:
FindBlockBoundaryInRange
(
const
nsRange
&
aRange
TextScanDirection
aDirection
)
{
if
(
aRange
.
Collapsed
(
)
)
{
return
Result
<
Maybe
<
RangeBoundary
>
ErrorResult
>
(
Nothing
{
}
)
;
}
if
(
aDirection
=
=
TextScanDirection
:
:
Right
)
{
Result
<
RangeBoundary
ErrorResult
>
maybeBoundary
=
FindNextBlockBoundary
(
aRange
.
StartRef
(
)
TextScanDirection
:
:
Right
)
;
if
(
MOZ_UNLIKELY
(
maybeBoundary
.
isErr
(
)
)
)
{
return
maybeBoundary
.
propagateErr
(
)
;
}
RangeBoundary
boundary
=
maybeBoundary
.
unwrap
(
)
;
Maybe
<
int32_t
>
compare
=
nsContentUtils
:
:
ComparePoints
(
boundary
aRange
.
EndRef
(
)
)
;
if
(
!
compare
|
|
*
compare
!
=
-
1
)
{
return
Result
<
Maybe
<
RangeBoundary
>
ErrorResult
>
(
Nothing
{
}
)
;
}
return
Some
(
boundary
)
;
}
Result
<
RangeBoundary
ErrorResult
>
maybeBoundary
=
FindNextBlockBoundary
(
aRange
.
EndRef
(
)
TextScanDirection
:
:
Left
)
;
if
(
MOZ_UNLIKELY
(
maybeBoundary
.
isErr
(
)
)
)
{
return
maybeBoundary
.
propagateErr
(
)
;
}
RangeBoundary
boundary
=
maybeBoundary
.
unwrap
(
)
;
auto
compare
=
nsContentUtils
:
:
ComparePoints
(
aRange
.
StartRef
(
)
boundary
)
;
if
(
!
compare
|
|
*
compare
!
=
-
1
)
{
return
Result
<
Maybe
<
RangeBoundary
>
ErrorResult
>
(
Nothing
{
}
)
;
}
return
Some
(
boundary
)
;
}
bool
TextDirectiveUtil
:
:
NormalizedRangeBoundariesAreEqual
(
const
RangeBoundary
&
aRangeBoundary1
const
RangeBoundary
&
aRangeBoundary2
)
{
MOZ_ASSERT
(
aRangeBoundary1
.
IsSetAndValid
(
)
&
&
aRangeBoundary2
.
IsSetAndValid
(
)
)
;
if
(
aRangeBoundary1
=
=
aRangeBoundary2
)
{
return
true
;
}
auto
textSubStringIsOnlyWhitespace
=
[
]
(
const
Text
*
textNode
uint32_t
startIndex
uint32_t
endIndex
)
{
MOZ_ASSERT
(
textNode
)
;
if
(
startIndex
>
endIndex
)
{
std
:
:
swap
(
startIndex
endIndex
)
;
}
MOZ_ASSERT
(
startIndex
<
textNode
-
>
Length
(
)
)
;
if
(
startIndex
=
=
endIndex
)
{
return
true
;
}
const
nsTextFragment
&
textFragment
=
textNode
-
>
TextFragment
(
)
;
for
(
uint32_t
i
=
startIndex
;
i
<
endIndex
;
+
+
i
)
{
char16_t
ch
=
textFragment
.
CharAt
(
i
)
;
if
(
!
nsContentUtils
:
:
IsHTMLWhitespaceOrNBSP
(
ch
)
)
{
return
false
;
}
}
return
true
;
}
;
const
nsINode
*
node1
=
aRangeBoundary1
.
GetContainer
(
)
;
const
nsINode
*
node2
=
aRangeBoundary2
.
GetContainer
(
)
;
size_t
offset1
=
*
aRangeBoundary1
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
;
size_t
offset2
=
*
aRangeBoundary2
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
;
if
(
node1
=
=
node2
)
{
if
(
const
Text
*
text
=
Text
:
:
FromNodeOrNull
(
node1
)
)
{
return
textSubStringIsOnlyWhitespace
(
text
offset1
offset2
)
;
}
return
offset1
=
=
offset2
;
}
mozilla
:
:
UnsafePreContentIterator
iter
;
auto
comp
=
nsContentUtils
:
:
ComparePoints
(
aRangeBoundary1
aRangeBoundary2
)
;
if
(
!
comp
)
{
return
false
;
}
if
(
*
comp
=
=
0
)
{
return
true
;
}
const
auto
&
[
firstBoundary
secondBoundary
]
=
*
comp
=
=
-
1
?
std
:
:
tuple
{
&
aRangeBoundary1
&
aRangeBoundary2
}
:
std
:
:
tuple
{
&
aRangeBoundary2
&
aRangeBoundary1
}
;
if
(
NS_FAILED
(
iter
.
Init
(
firstBoundary
-
>
AsRaw
(
)
secondBoundary
-
>
AsRaw
(
)
)
)
)
{
return
false
;
}
for
(
;
!
iter
.
IsDone
(
)
;
iter
.
Next
(
)
)
{
auto
*
node
=
iter
.
GetCurrentNode
(
)
;
if
(
!
node
|
|
!
TextDirectiveUtil
:
:
NodeIsVisibleTextNode
(
*
node
)
)
{
continue
;
}
if
(
node
=
=
firstBoundary
-
>
GetContainer
(
)
)
{
auto
firstOffset
=
*
firstBoundary
-
>
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
;
if
(
firstOffset
=
=
node
-
>
Length
(
)
)
{
continue
;
}
if
(
const
Text
*
text
=
Text
:
:
FromNodeOrNull
(
node
)
)
{
if
(
textSubStringIsOnlyWhitespace
(
text
firstOffset
text
-
>
Length
(
)
)
)
{
continue
;
}
}
}
if
(
node
=
=
secondBoundary
-
>
GetContainer
(
)
)
{
auto
secondOffset
=
*
secondBoundary
-
>
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOffsets
)
;
if
(
secondOffset
=
=
0
)
{
return
true
;
}
if
(
const
Text
*
text
=
Text
:
:
FromNodeOrNull
(
node
)
)
{
if
(
textSubStringIsOnlyWhitespace
(
text
0
secondOffset
)
)
{
return
true
;
}
}
}
if
(
node
-
>
Length
(
)
&
&
!
node
-
>
AsText
(
)
-
>
TextIsOnlyWhitespace
(
)
)
{
return
false
;
}
}
return
true
;
}
Result
<
Ok
ErrorResult
>
TextDirectiveUtil
:
:
ExtendRangeToWordBoundaries
(
nsRange
&
aRange
)
{
MOZ_ASSERT
(
!
aRange
.
Collapsed
(
)
)
;
PeekOffsetOptions
options
=
{
PeekOffsetOption
:
:
JumpLines
PeekOffsetOption
:
:
StopAtScroller
PeekOffsetOption
:
:
IsKeyboardSelect
PeekOffsetOption
:
:
Extend
}
;
Result
<
Maybe
<
RangeBoundary
>
ErrorResult
>
newStartBoundary
=
SelectionMovementUtils
:
:
MoveRangeBoundaryToSomewhere
(
aRange
.
StartRef
(
)
nsDirection
:
:
eDirNext
CaretAssociationHint
:
:
After
intl
:
:
BidiEmbeddingLevel
:
:
DefaultLTR
(
)
nsSelectionAmount
:
:
eSelectWord
options
)
.
andThen
(
[
&
options
]
(
const
RangeBoundary
&
rangeStartWordEndBoundary
)
{
return
SelectionMovementUtils
:
:
MoveRangeBoundaryToSomewhere
(
rangeStartWordEndBoundary
nsDirection
:
:
eDirPrevious
CaretAssociationHint
:
:
Before
intl
:
:
BidiEmbeddingLevel
:
:
DefaultLTR
(
)
nsSelectionAmount
:
:
eSelectWord
options
)
;
}
)
.
map
(
[
&
rangeStart
=
aRange
.
StartRef
(
)
]
(
RangeBoundary
&
&
rangeStartWordStartBoundary
)
{
return
NormalizedRangeBoundariesAreEqual
(
rangeStartWordStartBoundary
rangeStart
)
?
Nothing
{
}
:
Some
(
std
:
:
move
(
rangeStartWordStartBoundary
)
)
;
}
)
.
mapErr
(
[
]
(
nsresult
rv
)
{
return
ErrorResult
(
rv
)
;
}
)
;
if
(
MOZ_UNLIKELY
(
newStartBoundary
.
isErr
(
)
)
)
{
return
newStartBoundary
.
propagateErr
(
)
;
}
Result
<
Maybe
<
RangeBoundary
>
ErrorResult
>
newEndBoundary
=
SelectionMovementUtils
:
:
MoveRangeBoundaryToSomewhere
(
aRange
.
EndRef
(
)
nsDirection
:
:
eDirPrevious
CaretAssociationHint
:
:
Before
intl
:
:
BidiEmbeddingLevel
:
:
DefaultLTR
(
)
nsSelectionAmount
:
:
eSelectWord
options
)
.
andThen
(
[
&
options
]
(
const
RangeBoundary
&
rangeEndWordStartBoundary
)
{
return
SelectionMovementUtils
:
:
MoveRangeBoundaryToSomewhere
(
rangeEndWordStartBoundary
nsDirection
:
:
eDirNext
CaretAssociationHint
:
:
After
intl
:
:
BidiEmbeddingLevel
:
:
DefaultLTR
(
)
nsSelectionAmount
:
:
eSelectWord
options
)
;
}
)
.
map
(
[
&
rangeEnd
=
aRange
.
EndRef
(
)
]
(
RangeBoundary
&
&
rangeEndWordEndBoundary
)
{
return
NormalizedRangeBoundariesAreEqual
(
rangeEndWordEndBoundary
rangeEnd
)
?
Nothing
{
}
:
Some
(
std
:
:
move
(
rangeEndWordEndBoundary
)
)
;
}
)
.
mapErr
(
[
]
(
auto
rv
)
{
return
ErrorResult
(
rv
)
;
}
)
;
if
(
MOZ_UNLIKELY
(
newEndBoundary
.
isErr
(
)
)
)
{
return
newEndBoundary
.
propagateErr
(
)
;
}
MOZ_TRY
(
newStartBoundary
.
andThen
(
[
&
aRange
]
(
Maybe
<
RangeBoundary
>
&
&
boundary
)
-
>
Result
<
Ok
ErrorResult
>
{
if
(
boundary
.
isNothing
(
)
|
|
!
boundary
-
>
IsSetAndValid
(
)
)
{
return
Ok
(
)
;
}
ErrorResult
rv
;
aRange
.
SetStart
(
boundary
-
>
AsRaw
(
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
Ok
(
)
;
}
)
)
;
MOZ_TRY
(
newEndBoundary
.
andThen
(
[
&
aRange
]
(
Maybe
<
RangeBoundary
>
&
&
boundary
)
-
>
Result
<
Ok
ErrorResult
>
{
if
(
boundary
.
isNothing
(
)
|
|
!
boundary
-
>
IsSetAndValid
(
)
)
{
return
Ok
(
)
;
}
ErrorResult
rv
;
aRange
.
SetEnd
(
boundary
-
>
AsRaw
(
)
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
return
Ok
(
)
;
}
)
)
;
return
Ok
(
)
;
}
Result
<
TextDirective
ErrorResult
>
TextDirectiveUtil
:
:
CreateTextDirectiveFromRanges
(
nsRange
*
aPrefix
nsRange
*
aStart
nsRange
*
aEnd
nsRange
*
aSuffix
)
{
MOZ_ASSERT
(
aStart
&
&
!
aStart
-
>
Collapsed
(
)
)
;
ErrorResult
rv
;
TextDirective
textDirective
;
aStart
-
>
ToString
(
textDirective
.
start
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
textDirective
.
start
.
CompressWhitespace
(
)
;
if
(
aPrefix
&
&
!
aPrefix
-
>
Collapsed
(
)
)
{
aPrefix
-
>
ToString
(
textDirective
.
prefix
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
textDirective
.
prefix
.
CompressWhitespace
(
)
;
}
if
(
aEnd
&
&
!
aEnd
-
>
Collapsed
(
)
)
{
aEnd
-
>
ToString
(
textDirective
.
end
rv
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
textDirective
.
end
.
CompressWhitespace
(
)
;
}
if
(
aSuffix
&
&
!
aSuffix
-
>
Collapsed
(
)
)
{
aSuffix
-
>
ToString
(
textDirective
.
suffix
rv
)
;
textDirective
.
suffix
.
CompressWhitespace
(
)
;
if
(
MOZ_UNLIKELY
(
rv
.
Failed
(
)
)
)
{
return
Err
(
std
:
:
move
(
rv
)
)
;
}
}
return
textDirective
;
}
uint32_t
TextDirectiveUtil
:
:
FindCommonPrefix
(
const
nsAString
&
aFoldedStr1
const
nsAString
&
aFoldedStr2
)
{
const
uint32_t
maxCommonLength
=
std
:
:
min
(
aFoldedStr1
.
Length
(
)
aFoldedStr2
.
Length
(
)
)
;
uint32_t
commonLength
=
0
;
const
char16_t
*
iter1
=
aFoldedStr1
.
BeginReading
(
)
;
const
char16_t
*
iter2
=
aFoldedStr2
.
BeginReading
(
)
;
while
(
commonLength
<
maxCommonLength
)
{
if
(
*
iter1
!
=
*
iter2
)
{
break
;
}
+
+
iter1
;
+
+
iter2
;
+
+
commonLength
;
}
if
(
commonLength
&
&
NS_IS_HIGH_SURROGATE
(
*
(
iter1
-
1
)
)
)
{
-
-
commonLength
;
}
return
commonLength
;
}
uint32_t
TextDirectiveUtil
:
:
FindCommonSuffix
(
const
nsAString
&
aFoldedStr1
const
nsAString
&
aFoldedStr2
)
{
const
uint32_t
maxCommonLength
=
std
:
:
min
(
aFoldedStr1
.
Length
(
)
aFoldedStr2
.
Length
(
)
)
;
uint32_t
commonLength
=
0
;
const
char16_t
*
iter1
=
aFoldedStr1
.
EndReading
(
)
;
const
char16_t
*
iter2
=
aFoldedStr2
.
EndReading
(
)
;
while
(
commonLength
!
=
maxCommonLength
)
{
if
(
*
(
iter1
-
1
)
!
=
*
(
iter2
-
1
)
)
{
break
;
}
-
-
iter1
;
-
-
iter2
;
+
+
commonLength
;
}
if
(
commonLength
&
&
NS_IS_LOW_SURROGATE
(
*
iter1
)
)
{
-
-
commonLength
;
}
return
commonLength
;
}
RangeBoundary
TextDirectiveUtil
:
:
CreateRangeBoundaryByMovingOffsetFromRangeStart
(
nsRange
*
aRange
uint32_t
aLogicalOffset
)
{
MOZ_ASSERT
(
!
aRange
-
>
Collapsed
(
)
)
;
nsINode
*
node
=
aRange
-
>
GetStartContainer
(
)
;
uint32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
uint32_t
remaining
=
startOffset
+
aLogicalOffset
;
while
(
node
&
&
remaining
)
{
if
(
NodeIsPartOfNonSearchableSubTree
(
*
node
)
|
|
!
NodeIsVisibleTextNode
(
*
node
)
)
{
node
=
node
-
>
GetNextNode
(
)
;
continue
;
}
MOZ_ASSERT_IF
(
node
=
=
aRange
-
>
GetEndContainer
(
)
remaining
<
=
node
-
>
Length
(
)
)
;
if
(
node
-
>
Length
(
)
<
=
remaining
)
{
remaining
-
=
node
-
>
Length
(
)
;
node
=
node
-
>
GetNextNode
(
)
;
continue
;
}
return
{
node
remaining
}
;
}
return
{
node
remaining
}
;
}
}
