#
include
"
mozilla
/
dom
/
ResizeObserver
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
<
limits
>
namespace
mozilla
{
namespace
dom
{
static
uint32_t
GetNodeDepth
(
nsINode
*
aNode
)
{
uint32_t
depth
=
1
;
MOZ_ASSERT
(
aNode
"
Node
shouldn
'
t
be
null
"
)
;
while
(
(
aNode
=
aNode
-
>
GetFlattenedTreeParentNode
(
)
)
)
{
+
+
depth
;
}
return
depth
;
}
NS_IMPL_CYCLE_COLLECTION
(
ResizeObservation
mTarget
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
ResizeObservation
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
ResizeObservation
Release
)
bool
ResizeObservation
:
:
IsActive
(
)
const
{
nsRect
rect
=
GetTargetRect
(
)
;
return
(
rect
.
width
!
=
mBroadcastWidth
|
|
rect
.
height
!
=
mBroadcastHeight
)
;
}
void
ResizeObservation
:
:
UpdateBroadcastSize
(
const
nsSize
&
aSize
)
{
mBroadcastWidth
=
aSize
.
width
;
mBroadcastHeight
=
aSize
.
height
;
}
nsRect
ResizeObservation
:
:
GetTargetRect
(
)
const
{
nsRect
rect
;
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
if
(
mTarget
-
>
IsSVGElement
(
)
)
{
gfxRect
bbox
=
nsSVGUtils
:
:
GetBBox
(
frame
)
;
rect
.
width
=
NSFloatPixelsToAppUnits
(
bbox
.
width
AppUnitsPerCSSPixel
(
)
)
;
rect
.
height
=
NSFloatPixelsToAppUnits
(
bbox
.
height
AppUnitsPerCSSPixel
(
)
)
;
}
else
{
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
|
|
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
rect
=
frame
-
>
GetContentRectRelativeToSelf
(
)
;
}
}
}
return
rect
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ResizeObserver
mOwner
mCallback
mActiveTargets
mObservationMap
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserver
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
already_AddRefed
<
ResizeObserver
>
ResizeObserver
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ResizeObserverCallback
&
aCb
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
Document
*
document
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
document
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
RefPtr
<
ResizeObserver
>
observer
=
new
ResizeObserver
(
window
.
forget
(
)
aCb
)
;
document
-
>
AddResizeObserver
(
observer
)
;
return
observer
.
forget
(
)
;
}
void
ResizeObserver
:
:
Observe
(
Element
&
aTarget
ErrorResult
&
aRv
)
{
RefPtr
<
ResizeObservation
>
observation
;
if
(
mObservationMap
.
Get
(
&
aTarget
getter_AddRefs
(
observation
)
)
)
{
return
;
}
observation
=
new
ResizeObservation
(
aTarget
)
;
mObservationMap
.
Put
(
&
aTarget
observation
)
;
mObservationList
.
insertBack
(
observation
)
;
aTarget
.
OwnerDoc
(
)
-
>
ScheduleResizeObserversNotification
(
)
;
}
void
ResizeObserver
:
:
Unobserve
(
Element
&
aTarget
ErrorResult
&
aRv
)
{
RefPtr
<
ResizeObservation
>
observation
;
if
(
!
mObservationMap
.
Remove
(
&
aTarget
getter_AddRefs
(
observation
)
)
)
{
return
;
}
MOZ_ASSERT
(
!
mObservationList
.
isEmpty
(
)
"
If
ResizeObservation
found
for
an
element
observation
list
"
"
must
be
not
empty
.
"
)
;
observation
-
>
remove
(
)
;
}
void
ResizeObserver
:
:
Disconnect
(
)
{
mObservationList
.
clear
(
)
;
mObservationMap
.
Clear
(
)
;
mActiveTargets
.
Clear
(
)
;
}
void
ResizeObserver
:
:
GatherActiveObservations
(
uint32_t
aDepth
)
{
mActiveTargets
.
Clear
(
)
;
mHasSkippedTargets
=
false
;
for
(
auto
observation
:
mObservationList
)
{
if
(
!
observation
-
>
IsActive
(
)
)
{
continue
;
}
uint32_t
targetDepth
=
GetNodeDepth
(
observation
-
>
Target
(
)
)
;
if
(
targetDepth
>
aDepth
)
{
mActiveTargets
.
AppendElement
(
observation
)
;
}
else
{
mHasSkippedTargets
=
true
;
}
}
}
uint32_t
ResizeObserver
:
:
BroadcastActiveObservations
(
)
{
uint32_t
shallowestTargetDepth
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
if
(
!
HasActiveObservations
(
)
)
{
return
shallowestTargetDepth
;
}
Sequence
<
OwningNonNull
<
ResizeObserverEntry
>
>
entries
;
for
(
auto
&
observation
:
mActiveTargets
)
{
RefPtr
<
ResizeObserverEntry
>
entry
=
new
ResizeObserverEntry
(
this
*
observation
-
>
Target
(
)
)
;
nsRect
rect
=
observation
-
>
GetTargetRect
(
)
;
entry
-
>
SetContentRect
(
rect
)
;
if
(
!
entries
.
AppendElement
(
entry
.
forget
(
)
fallible
)
)
{
break
;
}
observation
-
>
UpdateBroadcastSize
(
rect
.
Size
(
)
)
;
uint32_t
targetDepth
=
GetNodeDepth
(
observation
-
>
Target
(
)
)
;
if
(
targetDepth
<
shallowestTargetDepth
)
{
shallowestTargetDepth
=
targetDepth
;
}
}
RefPtr
<
ResizeObserverCallback
>
callback
(
mCallback
)
;
callback
-
>
Call
(
this
entries
*
this
)
;
mActiveTargets
.
Clear
(
)
;
mHasSkippedTargets
=
false
;
return
shallowestTargetDepth
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ResizeObserverEntry
mTarget
mContentRect
mOwner
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserverEntry
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserverEntry
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserverEntry
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
already_AddRefed
<
ResizeObserverEntry
>
ResizeObserverEntry
:
:
Constructor
(
const
GlobalObject
&
aGlobal
Element
&
aTarget
ErrorResult
&
aRv
)
{
RefPtr
<
ResizeObserverEntry
>
observerEntry
=
new
ResizeObserverEntry
(
aGlobal
.
GetAsSupports
(
)
aTarget
)
;
return
observerEntry
.
forget
(
)
;
}
void
ResizeObserverEntry
:
:
SetContentRect
(
const
nsRect
&
aRect
)
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
Maybe
<
nsMargin
>
padding
=
frame
?
Some
(
frame
-
>
GetUsedPadding
(
)
)
:
Nothing
(
)
;
nsRect
rect
(
padding
?
padding
-
>
left
:
aRect
.
x
padding
?
padding
-
>
top
:
aRect
.
y
aRect
.
width
aRect
.
height
)
;
RefPtr
<
DOMRect
>
contentRect
=
new
DOMRect
(
mTarget
)
;
contentRect
-
>
SetLayoutRect
(
rect
)
;
mContentRect
=
contentRect
.
forget
(
)
;
}
}
}
