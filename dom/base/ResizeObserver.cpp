#
include
"
mozilla
/
dom
/
ResizeObserver
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
<
limits
>
namespace
mozilla
:
:
dom
{
static
uint32_t
GetNodeDepth
(
nsINode
*
aNode
)
{
uint32_t
depth
=
1
;
MOZ_ASSERT
(
aNode
"
Node
shouldn
'
t
be
null
"
)
;
while
(
(
aNode
=
aNode
-
>
GetFlattenedTreeParentNode
(
)
)
)
{
+
+
depth
;
}
return
depth
;
}
static
gfx
:
:
Size
GetTargetSize
(
Element
*
aTarget
ResizeObserverBoxOptions
aBox
)
{
gfx
:
:
Size
size
;
nsIFrame
*
frame
=
aTarget
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
size
;
}
if
(
aTarget
-
>
IsSVGElement
(
)
)
{
gfxRect
bbox
=
SVGUtils
:
:
GetBBox
(
frame
)
;
size
.
width
=
static_cast
<
float
>
(
bbox
.
width
)
;
size
.
height
=
static_cast
<
float
>
(
bbox
.
height
)
;
}
else
{
if
(
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
return
size
;
}
switch
(
aBox
)
{
case
ResizeObserverBoxOptions
:
:
Border_box
:
size
=
CSSPixel
:
:
FromAppUnits
(
frame
-
>
GetSize
(
)
)
.
ToUnknownSize
(
)
;
break
;
case
ResizeObserverBoxOptions
:
:
Content_box
:
default
:
size
=
CSSPixel
:
:
FromAppUnits
(
frame
-
>
GetContentRectRelativeToSelf
(
)
.
Size
(
)
)
.
ToUnknownSize
(
)
;
}
}
return
size
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ResizeObservation
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
ResizeObservation
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTarget
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ResizeObservation
)
tmp
-
>
Unlink
(
RemoveFromObserver
:
:
Yes
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
ResizeObservation
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
ResizeObservation
Release
)
ResizeObservation
:
:
ResizeObservation
(
Element
&
aTarget
ResizeObserver
&
aObserver
ResizeObserverBoxOptions
aBox
WritingMode
aWm
)
:
mTarget
(
&
aTarget
)
mObserver
(
&
aObserver
)
mObservedBox
(
aBox
)
{
aTarget
.
BindObject
(
mObserver
)
;
}
void
ResizeObservation
:
:
Unlink
(
RemoveFromObserver
aRemoveFromObserver
)
{
ResizeObserver
*
observer
=
std
:
:
exchange
(
mObserver
nullptr
)
;
nsCOMPtr
<
Element
>
target
=
std
:
:
move
(
mTarget
)
;
if
(
observer
&
&
target
)
{
if
(
aRemoveFromObserver
=
=
RemoveFromObserver
:
:
Yes
)
{
IgnoredErrorResult
rv
;
observer
-
>
Unobserve
(
*
target
rv
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
rv
.
Failed
(
)
"
How
could
we
keep
the
observer
and
target
around
"
"
without
being
in
the
observation
map
?
"
)
;
}
target
-
>
UnbindObject
(
observer
)
;
}
}
bool
ResizeObservation
:
:
IsActive
(
)
const
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
const
WritingMode
wm
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
const
LogicalPixelSize
size
(
wm
GetTargetSize
(
mTarget
mObservedBox
)
)
;
return
mLastReportedSize
!
=
size
;
}
void
ResizeObservation
:
:
UpdateLastReportedSize
(
const
gfx
:
:
Size
&
aSize
)
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
WritingMode
wm
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
mLastReportedSize
=
{
wm
aSize
}
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ResizeObserver
)
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
ResizeObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
ResizeObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOwner
mDocument
mCallback
mActiveTargets
mObservationMap
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
ResizeObserver
)
tmp
-
>
Disconnect
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOwner
mDocument
mCallback
mActiveTargets
mObservationMap
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserver
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
already_AddRefed
<
ResizeObserver
>
ResizeObserver
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ResizeObserverCallback
&
aCb
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
do_AddRef
(
new
ResizeObserver
(
std
:
:
move
(
window
)
doc
aCb
)
)
;
}
void
ResizeObserver
:
:
Observe
(
Element
&
aTarget
const
ResizeObserverOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
MOZ_UNLIKELY
(
!
mDocument
)
)
{
return
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
if
(
mObservationList
.
isEmpty
(
)
)
{
MOZ_ASSERT
(
mObservationMap
.
IsEmpty
(
)
)
;
mDocument
-
>
AddResizeObserver
(
*
this
)
;
}
auto
&
observation
=
mObservationMap
.
LookupOrInsert
(
&
aTarget
)
;
if
(
observation
)
{
if
(
observation
-
>
BoxOptions
(
)
=
=
aOptions
.
mBox
)
{
return
;
}
observation
-
>
remove
(
)
;
observation
=
nullptr
;
}
nsIFrame
*
frame
=
aTarget
.
GetPrimaryFrame
(
)
;
observation
=
new
ResizeObservation
(
aTarget
*
this
aOptions
.
mBox
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
)
;
mObservationList
.
insertBack
(
observation
)
;
mDocument
-
>
ScheduleResizeObserversNotification
(
)
;
}
void
ResizeObserver
:
:
Unobserve
(
Element
&
aTarget
ErrorResult
&
aRv
)
{
RefPtr
<
ResizeObservation
>
observation
;
if
(
!
mObservationMap
.
Remove
(
&
aTarget
getter_AddRefs
(
observation
)
)
)
{
return
;
}
MOZ_ASSERT
(
!
mObservationList
.
isEmpty
(
)
"
If
ResizeObservation
found
for
an
element
observation
list
"
"
must
be
not
empty
.
"
)
;
observation
-
>
remove
(
)
;
if
(
mObservationList
.
isEmpty
(
)
)
{
if
(
MOZ_LIKELY
(
mDocument
)
)
{
mDocument
-
>
RemoveResizeObserver
(
*
this
)
;
}
}
}
void
ResizeObserver
:
:
Disconnect
(
)
{
const
bool
registered
=
!
mObservationList
.
isEmpty
(
)
;
while
(
auto
*
observation
=
mObservationList
.
popFirst
(
)
)
{
observation
-
>
Unlink
(
ResizeObservation
:
:
RemoveFromObserver
:
:
No
)
;
}
MOZ_ASSERT
(
mObservationList
.
isEmpty
(
)
)
;
mObservationMap
.
Clear
(
)
;
mActiveTargets
.
Clear
(
)
;
if
(
registered
&
&
MOZ_LIKELY
(
mDocument
)
)
{
mDocument
-
>
RemoveResizeObserver
(
*
this
)
;
}
}
void
ResizeObserver
:
:
GatherActiveObservations
(
uint32_t
aDepth
)
{
mActiveTargets
.
Clear
(
)
;
mHasSkippedTargets
=
false
;
for
(
auto
*
observation
:
mObservationList
)
{
if
(
!
observation
-
>
IsActive
(
)
)
{
continue
;
}
uint32_t
targetDepth
=
GetNodeDepth
(
observation
-
>
Target
(
)
)
;
if
(
targetDepth
>
aDepth
)
{
mActiveTargets
.
AppendElement
(
observation
)
;
}
else
{
mHasSkippedTargets
=
true
;
}
}
}
uint32_t
ResizeObserver
:
:
BroadcastActiveObservations
(
)
{
uint32_t
shallowestTargetDepth
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
if
(
!
HasActiveObservations
(
)
)
{
return
shallowestTargetDepth
;
}
Sequence
<
OwningNonNull
<
ResizeObserverEntry
>
>
entries
;
for
(
auto
&
observation
:
mActiveTargets
)
{
Element
*
target
=
observation
-
>
Target
(
)
;
gfx
:
:
Size
borderBoxSize
=
GetTargetSize
(
target
ResizeObserverBoxOptions
:
:
Border_box
)
;
gfx
:
:
Size
contentBoxSize
=
GetTargetSize
(
target
ResizeObserverBoxOptions
:
:
Content_box
)
;
RefPtr
<
ResizeObserverEntry
>
entry
=
new
ResizeObserverEntry
(
this
*
target
borderBoxSize
contentBoxSize
)
;
if
(
!
entries
.
AppendElement
(
entry
.
forget
(
)
fallible
)
)
{
break
;
}
switch
(
observation
-
>
BoxOptions
(
)
)
{
case
ResizeObserverBoxOptions
:
:
Border_box
:
observation
-
>
UpdateLastReportedSize
(
borderBoxSize
)
;
break
;
case
ResizeObserverBoxOptions
:
:
Content_box
:
default
:
observation
-
>
UpdateLastReportedSize
(
contentBoxSize
)
;
}
uint32_t
targetDepth
=
GetNodeDepth
(
observation
-
>
Target
(
)
)
;
if
(
targetDepth
<
shallowestTargetDepth
)
{
shallowestTargetDepth
=
targetDepth
;
}
}
RefPtr
<
ResizeObserverCallback
>
callback
(
mCallback
)
;
callback
-
>
Call
(
this
entries
*
this
)
;
mActiveTargets
.
Clear
(
)
;
mHasSkippedTargets
=
false
;
return
shallowestTargetDepth
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ResizeObserverEntry
mOwner
mTarget
mContentRect
mBorderBoxSize
mContentBoxSize
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserverEntry
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserverEntry
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserverEntry
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
ResizeObserverEntry
:
:
GetBorderBoxSize
(
nsTArray
<
RefPtr
<
ResizeObserverSize
>
>
&
aRetVal
)
const
{
aRetVal
.
Clear
(
)
;
aRetVal
.
AppendElement
(
mBorderBoxSize
)
;
}
void
ResizeObserverEntry
:
:
GetContentBoxSize
(
nsTArray
<
RefPtr
<
ResizeObserverSize
>
>
&
aRetVal
)
const
{
aRetVal
.
Clear
(
)
;
aRetVal
.
AppendElement
(
mContentBoxSize
)
;
}
void
ResizeObserverEntry
:
:
SetBorderBoxSize
(
const
gfx
:
:
Size
&
aSize
)
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
const
WritingMode
wm
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
mBorderBoxSize
=
new
ResizeObserverSize
(
this
aSize
wm
)
;
}
void
ResizeObserverEntry
:
:
SetContentRectAndSize
(
const
gfx
:
:
Size
&
aSize
)
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
nsMargin
padding
=
frame
?
frame
-
>
GetUsedPadding
(
)
:
nsMargin
(
)
;
nsRect
rect
(
nsPoint
(
padding
.
left
padding
.
top
)
CSSPixel
:
:
ToAppUnits
(
CSSSize
:
:
FromUnknownSize
(
aSize
)
)
)
;
RefPtr
<
DOMRect
>
contentRect
=
new
DOMRect
(
this
)
;
contentRect
-
>
SetLayoutRect
(
rect
)
;
mContentRect
=
std
:
:
move
(
contentRect
)
;
const
WritingMode
wm
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
mContentBoxSize
=
new
ResizeObserverSize
(
this
aSize
wm
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ResizeObserverSize
mOwner
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserverSize
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserverSize
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserverSize
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
}
