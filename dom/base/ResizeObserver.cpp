#
include
"
mozilla
/
dom
/
ResizeObserver
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
<
limits
>
namespace
mozilla
{
namespace
dom
{
static
uint32_t
GetNodeDepth
(
nsINode
*
aNode
)
{
uint32_t
depth
=
1
;
MOZ_ASSERT
(
aNode
"
Node
shouldn
'
t
be
null
"
)
;
while
(
(
aNode
=
aNode
-
>
GetFlattenedTreeParentNode
(
)
)
)
{
+
+
depth
;
}
return
depth
;
}
static
nsSize
GetTargetSize
(
Element
*
aTarget
ResizeObserverBoxOptions
aBox
)
{
nsSize
size
;
nsIFrame
*
frame
=
aTarget
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
size
;
}
if
(
aTarget
-
>
IsSVGElement
(
)
)
{
gfxRect
bbox
=
nsSVGUtils
:
:
GetBBox
(
frame
)
;
size
.
width
=
NSFloatPixelsToAppUnits
(
bbox
.
width
AppUnitsPerCSSPixel
(
)
)
;
size
.
height
=
NSFloatPixelsToAppUnits
(
bbox
.
height
AppUnitsPerCSSPixel
(
)
)
;
}
else
{
if
(
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
return
size
;
}
switch
(
aBox
)
{
case
ResizeObserverBoxOptions
:
:
Border_box
:
size
=
frame
-
>
GetSize
(
)
;
break
;
case
ResizeObserverBoxOptions
:
:
Content_box
:
default
:
size
=
frame
-
>
GetContentRectRelativeToSelf
(
)
.
Size
(
)
;
}
}
return
size
;
}
NS_IMPL_CYCLE_COLLECTION
(
ResizeObservation
mTarget
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
ResizeObservation
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
ResizeObservation
Release
)
bool
ResizeObservation
:
:
IsActive
(
)
const
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
const
WritingMode
wm
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
const
LogicalSize
size
(
wm
GetTargetSize
(
mTarget
mObservedBox
)
)
;
return
mLastReportedSize
.
ISize
(
mLastReportedWM
)
!
=
size
.
ISize
(
wm
)
|
|
mLastReportedSize
.
BSize
(
mLastReportedWM
)
!
=
size
.
BSize
(
wm
)
;
}
void
ResizeObservation
:
:
UpdateLastReportedSize
(
const
nsSize
&
aSize
)
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
mLastReportedWM
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
mLastReportedSize
=
LogicalSize
(
mLastReportedWM
aSize
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ResizeObserver
mOwner
mDocument
mCallback
mActiveTargets
mObservationMap
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserver
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
already_AddRefed
<
ResizeObserver
>
ResizeObserver
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ResizeObserverCallback
&
aCb
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
window
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
Document
*
doc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
nullptr
;
}
return
do_AddRef
(
new
ResizeObserver
(
window
.
forget
(
)
doc
aCb
)
)
;
}
void
ResizeObserver
:
:
Observe
(
Element
&
aTarget
const
ResizeObserverOptions
&
aOptions
ErrorResult
&
aRv
)
{
if
(
mObservationList
.
isEmpty
(
)
)
{
MOZ_ASSERT
(
mObservationMap
.
IsEmpty
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
mDocument
)
)
{
return
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
mDocument
-
>
AddResizeObserver
(
*
this
)
;
}
RefPtr
<
ResizeObservation
>
&
observation
=
mObservationMap
.
LookupForAdd
(
&
aTarget
)
.
OrInsert
(
[
]
{
return
nullptr
;
}
)
;
if
(
observation
)
{
if
(
observation
-
>
BoxOptions
(
)
=
=
aOptions
.
mBox
)
{
return
;
}
observation
-
>
remove
(
)
;
observation
=
nullptr
;
}
nsIFrame
*
frame
=
aTarget
.
GetPrimaryFrame
(
)
;
observation
=
new
ResizeObservation
(
aTarget
aOptions
.
mBox
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
)
;
mObservationList
.
insertBack
(
observation
)
;
aTarget
.
OwnerDoc
(
)
-
>
ScheduleResizeObserversNotification
(
)
;
}
void
ResizeObserver
:
:
Unobserve
(
Element
&
aTarget
ErrorResult
&
aRv
)
{
RefPtr
<
ResizeObservation
>
observation
;
if
(
!
mObservationMap
.
Remove
(
&
aTarget
getter_AddRefs
(
observation
)
)
)
{
return
;
}
MOZ_ASSERT
(
!
mObservationList
.
isEmpty
(
)
"
If
ResizeObservation
found
for
an
element
observation
list
"
"
must
be
not
empty
.
"
)
;
observation
-
>
remove
(
)
;
if
(
mObservationList
.
isEmpty
(
)
)
{
if
(
MOZ_LIKELY
(
mDocument
)
)
{
mDocument
-
>
RemoveResizeObserver
(
*
this
)
;
}
}
}
void
ResizeObserver
:
:
Disconnect
(
)
{
mObservationList
.
clear
(
)
;
mObservationMap
.
Clear
(
)
;
mActiveTargets
.
Clear
(
)
;
}
void
ResizeObserver
:
:
GatherActiveObservations
(
uint32_t
aDepth
)
{
mActiveTargets
.
Clear
(
)
;
mHasSkippedTargets
=
false
;
for
(
auto
*
observation
:
mObservationList
)
{
if
(
!
observation
-
>
IsActive
(
)
)
{
continue
;
}
uint32_t
targetDepth
=
GetNodeDepth
(
observation
-
>
Target
(
)
)
;
if
(
targetDepth
>
aDepth
)
{
mActiveTargets
.
AppendElement
(
observation
)
;
}
else
{
mHasSkippedTargets
=
true
;
}
}
}
uint32_t
ResizeObserver
:
:
BroadcastActiveObservations
(
)
{
uint32_t
shallowestTargetDepth
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
if
(
!
HasActiveObservations
(
)
)
{
return
shallowestTargetDepth
;
}
Sequence
<
OwningNonNull
<
ResizeObserverEntry
>
>
entries
;
for
(
auto
&
observation
:
mActiveTargets
)
{
Element
*
target
=
observation
-
>
Target
(
)
;
nsSize
borderBoxSize
=
GetTargetSize
(
target
ResizeObserverBoxOptions
:
:
Border_box
)
;
nsSize
contentBoxSize
=
GetTargetSize
(
target
ResizeObserverBoxOptions
:
:
Content_box
)
;
RefPtr
<
ResizeObserverEntry
>
entry
=
new
ResizeObserverEntry
(
this
*
target
borderBoxSize
contentBoxSize
)
;
if
(
!
entries
.
AppendElement
(
entry
.
forget
(
)
fallible
)
)
{
break
;
}
switch
(
observation
-
>
BoxOptions
(
)
)
{
case
ResizeObserverBoxOptions
:
:
Border_box
:
observation
-
>
UpdateLastReportedSize
(
borderBoxSize
)
;
break
;
case
ResizeObserverBoxOptions
:
:
Content_box
:
default
:
observation
-
>
UpdateLastReportedSize
(
contentBoxSize
)
;
}
uint32_t
targetDepth
=
GetNodeDepth
(
observation
-
>
Target
(
)
)
;
if
(
targetDepth
<
shallowestTargetDepth
)
{
shallowestTargetDepth
=
targetDepth
;
}
}
RefPtr
<
ResizeObserverCallback
>
callback
(
mCallback
)
;
callback
-
>
Call
(
this
entries
*
this
)
;
mActiveTargets
.
Clear
(
)
;
mHasSkippedTargets
=
false
;
return
shallowestTargetDepth
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ResizeObserverEntry
mOwner
mTarget
mContentRect
mBorderBoxSize
mContentBoxSize
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserverEntry
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserverEntry
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserverEntry
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
void
ResizeObserverEntry
:
:
SetBorderBoxSize
(
const
nsSize
&
aSize
)
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
const
WritingMode
wm
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
mBorderBoxSize
=
new
ResizeObserverSize
(
this
aSize
wm
)
;
}
void
ResizeObserverEntry
:
:
SetContentRectAndSize
(
const
nsSize
&
aSize
)
{
nsIFrame
*
frame
=
mTarget
-
>
GetPrimaryFrame
(
)
;
nsMargin
padding
=
frame
?
frame
-
>
GetUsedPadding
(
)
:
nsMargin
(
)
;
nsRect
rect
(
nsPoint
(
padding
.
left
padding
.
top
)
aSize
)
;
RefPtr
<
DOMRect
>
contentRect
=
new
DOMRect
(
this
)
;
contentRect
-
>
SetLayoutRect
(
rect
)
;
mContentRect
=
contentRect
.
forget
(
)
;
const
WritingMode
wm
=
frame
?
frame
-
>
GetWritingMode
(
)
:
WritingMode
(
)
;
mContentBoxSize
=
new
ResizeObserverSize
(
this
aSize
wm
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
ResizeObserverSize
mOwner
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ResizeObserverSize
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ResizeObserverSize
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ResizeObserverSize
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
}
}
