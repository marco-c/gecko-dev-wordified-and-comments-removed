#
ifndef
DOM_TEXTDIRECTIVEUTIL_H_
#
define
DOM_TEXTDIRECTIVEUTIL_H_
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsStringFwd
.
h
"
class
nsIURI
;
class
nsINode
;
class
nsRange
;
struct
TextDirective
;
namespace
mozilla
:
:
dom
{
extern
LazyLogModule
gFragmentDirectiveLog
;
#
define
TEXT_FRAGMENT_LOG_FN
(
msg
func
.
.
.
)
\
MOZ_LOG_FMT
(
gFragmentDirectiveLog
LogLevel
:
:
Debug
"
{
}
(
)
:
"
msg
func
\
#
#
__VA_ARGS__
)
#
define
TEXT_FRAGMENT_LOG
(
msg
.
.
.
)
\
TEXT_FRAGMENT_LOG_FN
(
msg
__FUNCTION__
#
#
__VA_ARGS__
)
enum
class
TextScanDirection
{
Left
=
-
1
Right
=
1
}
;
class
TextDirectiveUtil
final
{
public
:
MOZ_ALWAYS_INLINE
static
bool
ShouldLog
(
)
{
return
MOZ_LOG_TEST
(
gFragmentDirectiveLog
LogLevel
:
:
Debug
)
;
}
static
Result
<
nsString
ErrorResult
>
RangeContentAsString
(
nsRange
*
aRange
)
;
static
Result
<
nsString
ErrorResult
>
RangeContentAsFoldCase
(
nsRange
*
aRange
)
;
static
bool
NodeIsVisibleTextNode
(
const
nsINode
&
aNode
)
;
static
RefPtr
<
nsRange
>
FindStringInRange
(
const
RangeBoundary
&
aSearchStart
const
RangeBoundary
&
aSearchEnd
const
nsAString
&
aQuery
bool
aWordStartBounded
bool
aWordEndBounded
nsContentUtils
:
:
NodeIndexCache
*
aCache
=
nullptr
)
;
static
RangeBoundary
MoveRangeBoundaryOneWord
(
const
RangeBoundary
&
aRangeBoundary
TextScanDirection
aDirection
)
;
static
bool
IsWhitespaceAtPosition
(
const
Text
*
aText
uint32_t
aPos
)
;
static
bool
NodeIsSearchInvisible
(
nsINode
&
aNode
)
;
static
bool
NodeHasBlockLevelDisplay
(
nsINode
&
aNode
)
;
static
nsINode
*
GetBlockAncestorForNode
(
nsINode
*
aNode
)
;
static
bool
NodeIsPartOfNonSearchableSubTree
(
nsINode
&
aNode
)
;
static
bool
IsAtWordBoundary
(
const
nsAString
&
aText
uint32_t
aPosition
)
;
enum
class
IsEndIndex
:
bool
{
No
Yes
}
;
static
RangeBoundary
GetBoundaryPointAtIndex
(
uint32_t
aIndex
const
nsTArray
<
RefPtr
<
Text
>
>
&
aTextNodeList
IsEndIndex
aIsEndIndex
)
;
static
void
AdvanceStartToNextNonWhitespacePosition
(
nsRange
&
aRange
)
;
static
RangeBoundary
MoveBoundaryToNextNonWhitespacePosition
(
const
RangeBoundary
&
aRangeBoundary
)
;
static
RangeBoundary
MoveBoundaryToPreviousNonWhitespacePosition
(
const
RangeBoundary
&
aRangeBoundary
)
;
static
Result
<
Maybe
<
RangeBoundary
>
ErrorResult
>
FindBlockBoundaryInRange
(
const
nsRange
&
aRange
TextScanDirection
aDirection
)
;
static
Result
<
RangeBoundary
ErrorResult
>
FindNextBlockBoundary
(
const
RangeBoundary
&
aRangeBoundary
TextScanDirection
aDirection
)
;
static
bool
NormalizedRangeBoundariesAreEqual
(
const
RangeBoundary
&
aRangeBoundary1
const
RangeBoundary
&
aRangeBoundary2
)
;
static
Result
<
Ok
ErrorResult
>
ExtendRangeToWordBoundaries
(
nsRange
&
aRange
)
;
static
Result
<
TextDirective
ErrorResult
>
CreateTextDirectiveFromRanges
(
nsRange
*
aPrefix
nsRange
*
aStart
nsRange
*
aEnd
nsRange
*
aSuffix
)
;
static
uint32_t
FindCommonPrefix
(
const
nsAString
&
aFoldedStr1
const
nsAString
&
aFoldedStr2
)
;
static
uint32_t
FindCommonSuffix
(
const
nsAString
&
aFoldedStr1
const
nsAString
&
aFoldedStr2
)
;
static
RangeBoundary
CreateRangeBoundaryByMovingOffsetFromRangeStart
(
nsRange
*
aRange
uint32_t
aLogicalOffset
)
;
}
;
class
TimeoutWatchdog
final
{
public
:
TimeoutWatchdog
(
)
:
mStartTime
(
TimeStamp
:
:
Now
(
)
)
mDuration
(
TimeDuration
:
:
FromSeconds
(
StaticPrefs
:
:
dom_text_fragments_create_text_fragment_timeout_seconds
(
)
)
)
{
}
bool
IsDone
(
)
const
{
return
TimeStamp
:
:
Now
(
)
-
mStartTime
>
mDuration
;
}
private
:
TimeStamp
mStartTime
;
TimeDuration
mDuration
;
}
;
}
#
endif
