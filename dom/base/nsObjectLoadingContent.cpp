#
include
"
imgLoader
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
dom
/
BindContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIExternalProtocolHandler
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsPluginHost
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsINestedURI
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsIURILoader
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIScriptChannel
.
h
"
#
include
"
nsIBlocklistService
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIAppShell
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCURILoader
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
js
/
Object
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
PluginCrashedEvent
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
widget
/
IMEData
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
HTMLObjectElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLEmbedElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLObjectElement
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
net
/
DocumentChannel
.
h
"
#
include
"
mozilla
/
net
/
UrlClassifierFeatureFactory
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
nsChannelClassifier
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
ifdef
XP_WIN
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
endif
static
const
char
kPrefYoutubeRewrite
[
]
=
"
plugins
.
rewrite_youtube_embeds
"
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
net
;
static
LogModule
*
GetObjectLog
(
)
{
static
LazyLogModule
sLog
(
"
objlc
"
)
;
return
sLog
;
}
#
define
LOG
(
args
)
MOZ_LOG
(
GetObjectLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
GetObjectLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
)
static
bool
IsFlashMIME
(
const
nsACString
&
aMIMEType
)
{
return
nsPluginHost
:
:
GetSpecialType
(
aMIMEType
)
=
=
nsPluginHost
:
:
eSpecialType_Flash
;
}
static
bool
InActiveDocument
(
nsIContent
*
aContent
)
{
if
(
!
aContent
-
>
IsInComposedDoc
(
)
)
{
return
false
;
}
Document
*
doc
=
aContent
-
>
OwnerDoc
(
)
;
return
(
doc
&
&
doc
-
>
IsActive
(
)
)
;
}
static
bool
IsPluginType
(
nsObjectLoadingContent
:
:
ObjectType
type
)
{
return
type
=
=
nsObjectLoadingContent
:
:
eType_Fallback
|
|
type
=
=
nsObjectLoadingContent
:
:
eType_FakePlugin
;
}
class
nsAsyncInstantiateEvent
:
public
Runnable
{
public
:
explicit
nsAsyncInstantiateEvent
(
nsObjectLoadingContent
*
aContent
)
:
Runnable
(
"
nsAsyncInstantiateEvent
"
)
mContent
(
aContent
)
{
}
~
nsAsyncInstantiateEvent
(
)
override
=
default
;
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsIObjectLoadingContent
>
mContent
;
}
;
NS_IMETHODIMP
nsAsyncInstantiateEvent
:
:
Run
(
)
{
nsObjectLoadingContent
*
objLC
=
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
;
if
(
objLC
-
>
mPendingInstantiateEvent
!
=
this
)
{
return
NS_OK
;
}
objLC
-
>
mPendingInstantiateEvent
=
nullptr
;
return
objLC
-
>
SyncStartPluginInstance
(
)
;
}
class
CheckPluginStopEvent
:
public
Runnable
{
public
:
explicit
CheckPluginStopEvent
(
nsObjectLoadingContent
*
aContent
)
:
Runnable
(
"
CheckPluginStopEvent
"
)
mContent
(
aContent
)
{
}
~
CheckPluginStopEvent
(
)
override
=
default
;
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsIObjectLoadingContent
>
mContent
;
}
;
NS_IMETHODIMP
CheckPluginStopEvent
:
:
Run
(
)
{
nsObjectLoadingContent
*
objLC
=
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
;
if
(
objLC
-
>
mPendingCheckPluginStopEvent
!
=
this
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
objLC
)
)
;
if
(
!
InActiveDocument
(
content
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Unloading
plugin
outside
of
document
"
this
)
)
;
objLC
-
>
StopPluginInstance
(
)
;
return
NS_OK
;
}
if
(
content
-
>
GetPrimaryFrame
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
in
active
document
with
frame
"
"
no
action
"
this
)
)
;
objLC
-
>
mPendingCheckPluginStopEvent
=
nullptr
;
return
NS_OK
;
}
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
No
frame
flushing
layout
"
this
)
)
;
Document
*
composedDoc
=
content
-
>
GetComposedDoc
(
)
;
if
(
composedDoc
)
{
composedDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
objLC
-
>
mPendingCheckPluginStopEvent
!
=
this
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
superseded
in
layout
flush
"
this
)
)
;
return
NS_OK
;
}
if
(
content
-
>
GetPrimaryFrame
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
frame
gained
in
layout
flush
"
this
)
)
;
objLC
-
>
mPendingCheckPluginStopEvent
=
nullptr
;
return
NS_OK
;
}
}
LOG
(
(
"
OBJLC
[
%
p
]
:
Stopping
plugin
that
lost
frame
"
this
)
)
;
objLC
-
>
StopPluginInstance
(
)
;
return
NS_OK
;
}
class
AutoSetLoadingToFalse
{
public
:
explicit
AutoSetLoadingToFalse
(
nsObjectLoadingContent
*
aContent
)
:
mContent
(
aContent
)
{
}
~
AutoSetLoadingToFalse
(
)
{
mContent
-
>
mIsLoading
=
false
;
}
private
:
nsObjectLoadingContent
*
mContent
;
}
;
bool
nsObjectLoadingContent
:
:
IsSuccessfulRequest
(
nsIRequest
*
aRequest
nsresult
*
aStatus
)
{
nsresult
rv
=
aRequest
-
>
GetStatus
(
aStatus
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
*
aStatus
)
)
{
return
false
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChan
(
do_QueryInterface
(
aRequest
)
)
;
if
(
httpChan
)
{
bool
success
;
rv
=
httpChan
-
>
GetRequestSucceeded
(
&
success
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
success
)
{
return
false
;
}
}
return
true
;
}
static
bool
CanHandleURI
(
nsIURI
*
aURI
)
{
nsAutoCString
scheme
;
if
(
NS_FAILED
(
aURI
-
>
GetScheme
(
scheme
)
)
)
{
return
false
;
}
nsIIOService
*
ios
=
nsContentUtils
:
:
GetIOService
(
)
;
if
(
!
ios
)
return
false
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
ios
-
>
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
if
(
!
handler
)
{
return
false
;
}
nsCOMPtr
<
nsIExternalProtocolHandler
>
extHandler
=
do_QueryInterface
(
handler
)
;
return
extHandler
=
=
nullptr
;
}
static
bool
inline
URIEquals
(
nsIURI
*
a
nsIURI
*
b
)
{
bool
equal
;
return
(
!
a
&
&
!
b
)
|
|
(
a
&
&
b
&
&
NS_SUCCEEDED
(
a
-
>
Equals
(
b
&
equal
)
)
&
&
equal
)
;
}
void
nsObjectLoadingContent
:
:
QueueCheckPluginStopEvent
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
CheckPluginStopEvent
(
this
)
;
mPendingCheckPluginStopEvent
=
event
;
NS_DispatchToCurrentThread
(
event
)
;
}
void
nsObjectLoadingContent
:
:
SetupFrameLoader
(
int32_t
aJSPluginId
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
mFrameLoader
=
nsFrameLoader
:
:
Create
(
thisContent
-
>
AsElement
(
)
mNetworkCreated
)
;
MOZ_ASSERT
(
mFrameLoader
"
nsFrameLoader
:
:
Create
failed
"
)
;
}
already_AddRefed
<
nsIDocShell
>
nsObjectLoadingContent
:
:
SetupDocShell
(
nsIURI
*
aRecursionCheckURI
)
{
SetupFrameLoader
(
nsFakePluginTag
:
:
NOT_JSPLUGIN
)
;
if
(
!
mFrameLoader
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
;
if
(
aRecursionCheckURI
)
{
nsresult
rv
=
mFrameLoader
-
>
CheckForRecursiveLoad
(
aRecursionCheckURI
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
IgnoredErrorResult
result
;
docShell
=
mFrameLoader
-
>
GetDocShell
(
result
)
;
if
(
result
.
Failed
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Could
not
get
DocShell
from
mFrameLoader
?
"
)
;
}
}
else
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Aborting
recursive
load
"
this
)
)
;
}
}
if
(
!
docShell
)
{
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
return
nullptr
;
}
MaybeStoreCrossOriginFeaturePolicy
(
)
;
return
docShell
.
forget
(
)
;
}
void
nsObjectLoadingContent
:
:
UnbindFromTree
(
bool
aNullParent
)
{
nsImageLoadingContent
:
:
UnbindFromTree
(
aNullParent
)
;
if
(
mType
!
=
eType_Image
)
{
UnloadObject
(
)
;
}
}
nsObjectLoadingContent
:
:
nsObjectLoadingContent
(
)
:
mType
(
eType_Loading
)
mRunID
(
0
)
mHasRunID
(
false
)
mChannelLoaded
(
false
)
mInstantiating
(
false
)
mNetworkCreated
(
true
)
mContentBlockingEnabled
(
false
)
mSkipFakePlugins
(
false
)
mIsStopping
(
false
)
mIsLoading
(
false
)
mScriptRequested
(
false
)
mRewrittenYoutubeEmbed
(
false
)
{
}
nsObjectLoadingContent
:
:
~
nsObjectLoadingContent
(
)
{
if
(
mFrameLoader
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
not
be
tearing
down
frame
loaders
at
this
point
"
)
;
mFrameLoader
-
>
Destroy
(
)
;
}
if
(
mInstantiating
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
not
be
tearing
down
a
plugin
at
this
point
!
"
)
;
StopPluginInstance
(
)
;
}
nsImageLoadingContent
:
:
Destroy
(
)
;
}
nsresult
nsObjectLoadingContent
:
:
InstantiatePluginInstance
(
bool
aIsLoading
)
{
return
NS_ERROR_FAILURE
;
}
void
nsObjectLoadingContent
:
:
GetPluginAttributes
(
nsTArray
<
MozPluginParameter
>
&
aAttributes
)
{
aAttributes
=
mCachedAttributes
.
Clone
(
)
;
}
void
nsObjectLoadingContent
:
:
GetPluginParameters
(
nsTArray
<
MozPluginParameter
>
&
aParameters
)
{
aParameters
=
mCachedParameters
.
Clone
(
)
;
}
void
nsObjectLoadingContent
:
:
GetNestedParams
(
nsTArray
<
MozPluginParameter
>
&
aParams
)
{
nsCOMPtr
<
Element
>
ourElement
=
do_QueryInterface
(
static_cast
<
nsIObjectLoadingContent
*
>
(
this
)
)
;
nsCOMPtr
<
nsIHTMLCollection
>
allParams
;
constexpr
auto
xhtml_ns
=
u
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
_ns
;
ErrorResult
rv
;
allParams
=
ourElement
-
>
GetElementsByTagNameNS
(
xhtml_ns
u
"
param
"
_ns
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
allParams
)
;
uint32_t
numAllParams
=
allParams
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numAllParams
;
i
+
+
)
{
RefPtr
<
Element
>
element
=
allParams
-
>
Item
(
i
)
;
nsAutoString
name
;
element
-
>
GetAttr
(
nsGkAtoms
:
:
name
name
)
;
if
(
name
.
IsEmpty
(
)
)
continue
;
nsCOMPtr
<
nsIContent
>
parent
=
element
-
>
GetParent
(
)
;
RefPtr
<
HTMLObjectElement
>
objectElement
;
while
(
!
objectElement
&
&
parent
)
{
objectElement
=
HTMLObjectElement
:
:
FromNode
(
parent
)
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
objectElement
)
{
parent
=
objectElement
;
}
else
{
continue
;
}
if
(
parent
=
=
ourElement
)
{
MozPluginParameter
param
;
element
-
>
GetAttr
(
nsGkAtoms
:
:
name
param
.
mName
)
;
element
-
>
GetAttr
(
nsGkAtoms
:
:
value
param
.
mValue
)
;
param
.
mName
.
Trim
(
"
\
n
\
r
\
t
\
b
"
true
true
false
)
;
param
.
mValue
.
Trim
(
"
\
n
\
r
\
t
\
b
"
true
true
false
)
;
aParams
.
AppendElement
(
param
)
;
}
}
}
nsresult
nsObjectLoadingContent
:
:
BuildParametersArray
(
)
{
if
(
mCachedAttributes
.
Length
(
)
|
|
mCachedParameters
.
Length
(
)
)
{
MOZ_ASSERT
(
false
"
Parameters
array
should
be
empty
.
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
for
(
uint32_t
i
=
0
;
i
!
=
element
-
>
GetAttrCount
(
)
;
i
+
=
1
)
{
MozPluginParameter
param
;
const
nsAttrName
*
attrName
=
element
-
>
GetAttrNameAt
(
i
)
;
nsAtom
*
atom
=
attrName
-
>
LocalName
(
)
;
element
-
>
GetAttr
(
attrName
-
>
NamespaceID
(
)
atom
param
.
mValue
)
;
atom
-
>
ToString
(
param
.
mName
)
;
mCachedAttributes
.
AppendElement
(
param
)
;
}
nsAutoCString
wmodeOverride
;
Preferences
:
:
GetCString
(
"
plugins
.
force
.
wmode
"
wmodeOverride
)
;
for
(
uint32_t
i
=
0
;
i
<
mCachedAttributes
.
Length
(
)
;
i
+
+
)
{
if
(
!
wmodeOverride
.
IsEmpty
(
)
&
&
mCachedAttributes
[
i
]
.
mName
.
EqualsIgnoreCase
(
"
wmode
"
)
)
{
CopyASCIItoUTF16
(
wmodeOverride
mCachedAttributes
[
i
]
.
mValue
)
;
wmodeOverride
.
Truncate
(
)
;
}
}
if
(
!
wmodeOverride
.
IsEmpty
(
)
)
{
MozPluginParameter
param
;
param
.
mName
=
u
"
wmode
"
_ns
;
CopyASCIItoUTF16
(
wmodeOverride
param
.
mValue
)
;
mCachedAttributes
.
AppendElement
(
param
)
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
&
&
!
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
)
{
MozPluginParameter
param
;
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
data
param
.
mValue
)
;
if
(
!
param
.
mValue
.
IsEmpty
(
)
)
{
param
.
mName
=
u
"
SRC
"
_ns
;
mCachedAttributes
.
AppendElement
(
param
)
;
}
}
GetNestedParams
(
mCachedParameters
)
;
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
if
(
mInstantiating
)
{
QueueCheckPluginStopEvent
(
)
;
}
nsImageLoadingContent
:
:
NotifyOwnerDocumentActivityChanged
(
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
AUTO_PROFILER_LABEL
(
"
nsObjectLoadingContent
:
:
OnStartRequest
"
NETWORK
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
OnStartRequest
"
this
)
)
;
if
(
aRequest
!
=
mChannel
|
|
!
aRequest
)
{
return
NS_BINDING_ABORTED
;
}
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
aRequest
)
)
;
NS_ASSERTION
(
chan
"
Why
is
our
request
not
a
channel
?
"
)
;
nsresult
status
=
NS_OK
;
bool
success
=
IsSuccessfulRequest
(
aRequest
&
status
)
;
if
(
mType
=
=
eType_Document
)
{
if
(
!
mFinalListener
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Already
are
eType_Document
but
don
'
t
have
final
listener
yet
?
"
)
;
return
NS_BINDING_ABORTED
;
}
if
(
success
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
OnStartRequest
:
DocumentChannel
request
succeeded
\
n
"
this
)
)
;
nsCString
channelType
;
MOZ_ALWAYS_SUCCEEDS
(
mChannel
-
>
GetContentType
(
channelType
)
)
;
if
(
GetTypeOfContent
(
channelType
mSkipFakePlugins
)
!
=
eType_Document
)
{
MOZ_CRASH
(
"
DocumentChannel
request
with
non
-
document
MIME
"
)
;
}
mContentType
=
channelType
;
MOZ_ALWAYS_SUCCEEDS
(
NS_GetFinalChannelURI
(
mChannel
getter_AddRefs
(
mURI
)
)
)
;
}
return
mFinalListener
-
>
OnStartRequest
(
aRequest
)
;
}
if
(
mType
!
=
eType_Loading
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
be
type
loading
at
this
point
"
)
;
return
NS_BINDING_ABORTED
;
}
NS_ASSERTION
(
!
mChannelLoaded
"
mChannelLoaded
set
already
?
"
)
;
NS_ASSERTION
(
!
mFinalListener
"
mFinalListener
exists
already
?
"
)
;
mChannelLoaded
=
true
;
if
(
status
=
=
NS_ERROR_BLOCKED_URI
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
console
)
{
nsCOMPtr
<
nsIURI
>
uri
;
chan
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsString
message
=
u
"
Blocking
"
_ns
+
NS_ConvertASCIItoUTF16
(
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
+
nsLiteralString
(
u
"
since
it
was
found
on
an
internal
Firefox
blocklist
.
"
)
;
console
-
>
LogStringMessage
(
message
.
get
(
)
)
;
}
mContentBlockingEnabled
=
true
;
return
NS_ERROR_FAILURE
;
}
if
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
status
)
)
{
mContentBlockingEnabled
=
true
;
return
NS_ERROR_FAILURE
;
}
if
(
!
success
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
OnStartRequest
:
Request
failed
\
n
"
this
)
)
;
mChannel
=
nullptr
;
LoadObject
(
true
false
)
;
return
NS_ERROR_FAILURE
;
}
return
LoadObject
(
true
false
aRequest
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatusCode
)
{
AUTO_PROFILER_LABEL
(
"
nsObjectLoadingContent
:
:
OnStopRequest
"
NETWORK
)
;
if
(
UrlClassifierFeatureFactory
:
:
IsClassifierBlockingErrorCode
(
aStatusCode
)
)
{
nsCOMPtr
<
nsIContent
>
thisNode
=
do_QueryInterface
(
static_cast
<
nsIObjectLoadingContent
*
>
(
this
)
)
;
if
(
thisNode
&
&
thisNode
-
>
IsInComposedDoc
(
)
)
{
thisNode
-
>
GetComposedDoc
(
)
-
>
AddBlockedNodeByClassifier
(
thisNode
)
;
}
}
if
(
aRequest
!
=
mChannel
)
{
return
NS_BINDING_ABORTED
;
}
mChannel
=
nullptr
;
if
(
mFinalListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listenerGrip
(
mFinalListener
)
;
mFinalListener
=
nullptr
;
listenerGrip
-
>
OnStopRequest
(
aRequest
aStatusCode
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
aRequest
!
=
mChannel
)
{
return
NS_BINDING_ABORTED
;
}
if
(
mFinalListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listenerGrip
(
mFinalListener
)
;
return
listenerGrip
-
>
OnDataAvailable
(
aRequest
aInputStream
aOffset
aCount
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Got
data
for
channel
with
no
connected
final
"
"
listener
"
)
;
mChannel
=
nullptr
;
return
NS_ERROR_UNEXPECTED
;
}
void
nsObjectLoadingContent
:
:
PresetOpenerWindow
(
const
Nullable
<
WindowProxyHolder
>
&
aOpenerWindow
ErrorResult
&
aRv
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetActualType
(
nsACString
&
aType
)
{
aType
=
mContentType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetDisplayedType
(
uint32_t
*
aType
)
{
*
aType
=
DisplayedType
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetContentTypeForMIMEType
(
const
nsACString
&
aMIMEType
uint32_t
*
aType
)
{
*
aType
=
GetTypeOfContent
(
PromiseFlatCString
(
aMIMEType
)
false
)
;
return
NS_OK
;
}
class
ObjectInterfaceRequestorShim
final
:
public
nsIInterfaceRequestor
public
nsIChannelEventSink
public
nsIStreamListener
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
ObjectInterfaceRequestorShim
nsIInterfaceRequestor
)
NS_DECL_NSIINTERFACEREQUESTOR
NS_FORWARD_NSICHANNELEVENTSINK
(
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
-
>
)
NS_FORWARD_NSISTREAMLISTENER
(
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
-
>
)
NS_FORWARD_NSIREQUESTOBSERVER
(
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
-
>
)
explicit
ObjectInterfaceRequestorShim
(
nsIObjectLoadingContent
*
aContent
)
:
mContent
(
aContent
)
{
}
protected
:
~
ObjectInterfaceRequestorShim
(
)
=
default
;
nsCOMPtr
<
nsIObjectLoadingContent
>
mContent
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
ObjectInterfaceRequestorShim
mContent
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ObjectInterfaceRequestorShim
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannelEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ObjectInterfaceRequestorShim
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ObjectInterfaceRequestorShim
)
NS_IMETHODIMP
ObjectInterfaceRequestorShim
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
nsIChannelEventSink
*
sink
=
this
;
*
aResult
=
sink
;
NS_ADDREF
(
sink
)
;
return
NS_OK
;
}
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIObjectLoadingContent
)
)
)
{
nsIObjectLoadingContent
*
olc
=
mContent
;
*
aResult
=
olc
;
NS_ADDREF
(
olc
)
;
return
NS_OK
;
}
return
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
if
(
!
mChannel
|
|
aOldChannel
!
=
mChannel
)
{
return
NS_BINDING_ABORTED
;
}
mChannel
=
aNewChannel
;
if
(
mFinalListener
)
{
nsCOMPtr
<
nsIChannelEventSink
>
sink
(
do_QueryInterface
(
mFinalListener
)
)
;
MOZ_RELEASE_ASSERT
(
sink
"
mFinalListener
isn
'
t
nsIChannelEventSink
?
"
)
;
if
(
mType
!
=
eType_Document
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Not
a
DocumentChannel
load
but
we
'
re
getting
a
"
"
AsyncOnChannelRedirect
with
a
mFinalListener
?
"
)
;
return
NS_BINDING_ABORTED
;
}
return
sink
-
>
AsyncOnChannelRedirect
(
aOldChannel
aNewChannel
aFlags
cb
)
;
}
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
ElementState
nsObjectLoadingContent
:
:
ObjectState
(
)
const
{
switch
(
mType
)
{
case
eType_Loading
:
return
ElementState
:
:
LOADING
;
case
eType_Image
:
return
ImageState
(
)
;
case
eType_FakePlugin
:
case
eType_Document
:
return
ElementState
(
)
;
case
eType_Fallback
:
return
ElementState
(
)
;
case
eType_Null
:
return
ElementState
:
:
BROKEN
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unknown
type
?
"
)
;
return
ElementState
:
:
LOADING
;
}
void
nsObjectLoadingContent
:
:
MaybeRewriteYoutubeEmbed
(
nsIURI
*
aURI
nsIURI
*
aBaseURI
nsIURI
*
*
aOutURI
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
Must
be
an
instance
of
content
"
)
;
if
(
!
thisContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
embed
)
&
&
!
thisContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
object
)
)
{
return
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
NS_WARNING
(
"
Could
not
get
TLD
service
!
"
)
;
return
;
}
nsAutoCString
currentBaseDomain
;
bool
ok
=
NS_SUCCEEDED
(
tldService
-
>
GetBaseDomain
(
aURI
0
currentBaseDomain
)
)
;
if
(
!
ok
)
{
return
;
}
if
(
!
currentBaseDomain
.
EqualsLiteral
(
"
youtube
.
com
"
)
&
&
!
currentBaseDomain
.
EqualsLiteral
(
"
youtube
-
nocookie
.
com
"
)
)
{
return
;
}
nsAutoCString
path
;
aURI
-
>
GetPathQueryRef
(
path
)
;
if
(
!
StringBeginsWith
(
path
"
/
v
/
"
_ns
)
)
{
return
;
}
nsAutoCString
uri
;
nsresult
rv
=
aURI
-
>
GetSpec
(
uri
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
int32_t
ampIndex
=
uri
.
FindChar
(
'
&
'
0
)
;
bool
replaceQuery
=
false
;
if
(
ampIndex
!
=
-
1
)
{
int32_t
qmIndex
=
uri
.
FindChar
(
'
?
'
0
)
;
if
(
qmIndex
=
=
-
1
|
|
qmIndex
>
ampIndex
)
{
replaceQuery
=
true
;
}
}
if
(
!
Preferences
:
:
GetBool
(
kPrefYoutubeRewrite
)
)
{
return
;
}
nsAutoString
utf16OldURI
=
NS_ConvertUTF8toUTF16
(
uri
)
;
if
(
replaceQuery
)
{
uri
.
ReplaceChar
(
'
?
'
'
&
'
)
;
uri
.
SetCharAt
(
'
?
'
ampIndex
)
;
}
uri
.
ReplaceSubstring
(
"
/
v
/
"
_ns
"
/
embed
/
"
_ns
)
;
nsAutoString
utf16URI
=
NS_ConvertUTF8toUTF16
(
uri
)
;
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
aOutURI
utf16URI
thisContent
-
>
OwnerDoc
(
)
aBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
AutoTArray
<
nsString
2
>
params
=
{
utf16OldURI
utf16URI
}
;
const
char
*
msgName
;
if
(
!
replaceQuery
)
{
msgName
=
"
RewriteYouTubeEmbed
"
;
}
else
{
msgName
=
"
RewriteYouTubeEmbedPathParams
"
;
}
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Plugins
"
_ns
thisContent
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
msgName
params
)
;
}
bool
nsObjectLoadingContent
:
:
CheckLoadPolicy
(
int16_t
*
aContentPolicy
)
{
if
(
!
aContentPolicy
|
|
!
mURI
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Doing
it
wrong
"
)
;
return
false
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
Must
be
an
instance
of
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
nsContentPolicyType
contentPolicyType
=
GetContentPolicyType
(
)
;
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
doc
-
>
NodePrincipal
(
)
doc
-
>
NodePrincipal
(
)
thisContent
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
contentPolicyType
)
;
*
aContentPolicy
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
mURI
secCheckLoadInfo
mContentType
aContentPolicy
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
NS_CP_REJECTED
(
*
aContentPolicy
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Content
policy
denied
load
of
%
s
"
this
mURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
return
false
;
}
return
true
;
}
bool
nsObjectLoadingContent
:
:
CheckProcessPolicy
(
int16_t
*
aContentPolicy
)
{
if
(
!
aContentPolicy
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Null
out
variable
"
)
;
return
false
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
Must
be
an
instance
of
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
nsContentPolicyType
objectType
;
switch
(
mType
)
{
case
eType_Image
:
objectType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
;
break
;
case
eType_Document
:
objectType
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
;
break
;
case
eType_Fallback
:
case
eType_FakePlugin
:
objectType
=
GetContentPolicyType
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Calling
checkProcessPolicy
with
an
unloadable
"
"
type
"
)
;
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
doc
-
>
NodePrincipal
(
)
doc
-
>
NodePrincipal
(
)
thisContent
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
objectType
)
;
*
aContentPolicy
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentProcessPolicy
(
mURI
?
mURI
:
mBaseURI
secCheckLoadInfo
mContentType
aContentPolicy
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
NS_CP_REJECTED
(
*
aContentPolicy
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckContentProcessPolicy
rejected
load
"
this
)
)
;
return
false
;
}
return
true
;
}
nsObjectLoadingContent
:
:
ParameterUpdateFlags
nsObjectLoadingContent
:
:
UpdateObjectParameters
(
)
{
nsCOMPtr
<
Element
>
thisElement
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
MOZ_ASSERT
(
thisElement
"
Must
be
an
Element
"
)
;
uint32_t
caps
=
GetCapabilities
(
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Updating
object
parameters
"
this
)
)
;
nsresult
rv
;
nsAutoCString
newMime
;
nsAutoString
typeAttr
;
nsCOMPtr
<
nsIURI
>
newURI
;
nsCOMPtr
<
nsIURI
>
newBaseURI
;
ObjectType
newType
;
bool
stateInvalid
=
false
;
nsObjectLoadingContent
:
:
ParameterUpdateFlags
retval
=
eParamNoChange
;
if
(
caps
&
eFallbackIfClassIDPresent
)
{
nsAutoString
classIDAttr
;
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
classid
classIDAttr
)
;
if
(
!
classIDAttr
.
IsEmpty
(
)
)
{
newMime
.
Truncate
(
)
;
stateInvalid
=
true
;
}
}
nsAutoString
codebaseStr
;
nsIURI
*
docBaseURI
=
thisElement
-
>
GetBaseURI
(
)
;
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
codebase
codebaseStr
)
;
if
(
!
codebaseStr
.
IsEmpty
(
)
)
{
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
newBaseURI
)
codebaseStr
thisElement
-
>
OwnerDoc
(
)
docBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Could
not
parse
plugin
'
s
codebase
as
a
URI
"
"
will
use
document
baseURI
instead
"
this
)
)
;
}
}
if
(
!
newBaseURI
)
{
newBaseURI
=
docBaseURI
;
}
nsAutoString
rawTypeAttr
;
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
rawTypeAttr
)
;
if
(
!
rawTypeAttr
.
IsEmpty
(
)
)
{
typeAttr
=
rawTypeAttr
;
nsAutoString
params
;
nsAutoString
mime
;
nsContentUtils
:
:
SplitMimeType
(
rawTypeAttr
mime
params
)
;
CopyUTF16toUTF8
(
mime
newMime
)
;
}
nsAutoString
uriStr
;
if
(
thisElement
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
object
)
)
{
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
data
uriStr
)
;
}
else
if
(
thisElement
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
embed
)
)
{
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
uriStr
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
plugin
-
loading
tag
"
)
;
}
mRewrittenYoutubeEmbed
=
false
;
if
(
!
uriStr
.
IsEmpty
(
)
)
{
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
newURI
)
uriStr
thisElement
-
>
OwnerDoc
(
)
newBaseURI
)
;
nsCOMPtr
<
nsIURI
>
rewrittenURI
;
MaybeRewriteYoutubeEmbed
(
newURI
newBaseURI
getter_AddRefs
(
rewrittenURI
)
)
;
if
(
rewrittenURI
)
{
newURI
=
rewrittenURI
;
mRewrittenYoutubeEmbed
=
true
;
newMime
=
"
text
/
html
"
_ns
;
}
if
(
NS_FAILED
(
rv
)
)
{
stateInvalid
=
true
;
}
}
if
(
(
mOriginalContentType
!
=
newMime
)
|
|
!
URIEquals
(
mOriginalURI
newURI
)
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamChannelChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
parameters
changed
"
this
)
)
;
}
mOriginalContentType
=
newMime
;
mOriginalURI
=
newURI
;
bool
useChannel
=
mChannelLoaded
&
&
!
(
retval
&
eParamChannelChanged
)
;
bool
newChannel
=
useChannel
&
&
mType
=
=
eType_Loading
;
RefPtr
<
DocumentChannel
>
documentChannel
=
do_QueryObject
(
mChannel
)
;
if
(
newChannel
&
&
documentChannel
)
{
newMime
=
TEXT_HTML
;
MOZ_DIAGNOSTIC_ASSERT
(
GetTypeOfContent
(
newMime
mSkipFakePlugins
)
=
=
eType_Document
"
How
is
text
/
html
not
eType_Document
?
"
)
;
}
else
if
(
newChannel
&
&
mChannel
)
{
nsCString
channelType
;
rv
=
mChannel
-
>
GetContentType
(
channelType
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
GetContentType
failed
"
)
;
stateInvalid
=
true
;
channelType
.
Truncate
(
)
;
}
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
has
a
content
type
of
%
s
"
this
channelType
.
get
(
)
)
)
;
bool
binaryChannelType
=
false
;
if
(
channelType
.
EqualsASCII
(
APPLICATION_GUESS_FROM_EXT
)
)
{
channelType
=
APPLICATION_OCTET_STREAM
;
mChannel
-
>
SetContentType
(
channelType
)
;
binaryChannelType
=
true
;
}
else
if
(
channelType
.
EqualsASCII
(
APPLICATION_OCTET_STREAM
)
|
|
channelType
.
EqualsASCII
(
BINARY_OCTET_STREAM
)
)
{
binaryChannelType
=
true
;
}
rv
=
NS_GetFinalChannelURI
(
mChannel
getter_AddRefs
(
newURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
NS_GetFinalChannelURI
failure
"
)
;
stateInvalid
=
true
;
}
ObjectType
typeHint
=
newMime
.
IsEmpty
(
)
?
eType_Null
:
GetTypeOfContent
(
newMime
mSkipFakePlugins
)
;
bool
overrideChannelType
=
false
;
if
(
IsPluginType
(
typeHint
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
plugin
type
hint
in
favor
of
any
channel
type
"
this
)
)
;
overrideChannelType
=
true
;
}
else
if
(
binaryChannelType
&
&
typeHint
!
=
eType_Null
&
&
typeHint
!
=
eType_Document
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
type
hint
in
favor
of
binary
channel
type
"
this
)
)
;
overrideChannelType
=
true
;
}
if
(
overrideChannelType
)
{
nsAutoCString
parsedMime
dummy
;
NS_ParseResponseContentType
(
newMime
parsedMime
dummy
)
;
if
(
!
parsedMime
.
IsEmpty
(
)
)
{
mChannel
-
>
SetContentType
(
parsedMime
)
;
}
}
else
{
newMime
=
channelType
;
}
}
else
if
(
newChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
We
failed
to
open
a
channel
marking
invalid
"
this
)
)
;
stateInvalid
=
true
;
}
ObjectType
newMime_Type
=
GetTypeOfContent
(
newMime
mSkipFakePlugins
)
;
if
(
stateInvalid
)
{
newType
=
eType_Null
;
LOG
(
(
"
OBJLC
[
%
p
]
:
NewType
#
0
:
%
s
-
%
u
"
this
newMime
.
get
(
)
newType
)
)
;
newMime
.
Truncate
(
)
;
}
else
if
(
newChannel
)
{
newType
=
newMime_Type
;
LOG
(
(
"
OBJLC
[
%
p
]
:
NewType
#
1
:
%
s
-
%
u
"
this
newMime
.
get
(
)
newType
)
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
channel
type
"
this
)
)
;
}
else
if
(
(
(
caps
&
eAllowPluginSkipChannel
)
|
|
!
newURI
)
&
&
IsPluginType
(
newMime_Type
)
)
{
newType
=
newMime_Type
;
LOG
(
(
"
OBJLC
[
%
p
]
:
NewType
#
2
:
%
s
-
%
u
"
this
newMime
.
get
(
)
newType
)
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Plugin
type
with
no
URI
skipping
channel
load
"
this
)
)
;
}
else
if
(
newURI
&
&
(
mOriginalContentType
.
IsEmpty
(
)
|
|
newMime_Type
!
=
eType_Null
)
)
{
newType
=
eType_Loading
;
LOG
(
(
"
OBJLC
[
%
p
]
:
NewType
#
3
:
%
u
"
this
newType
)
)
;
}
else
{
newType
=
eType_Null
;
LOG
(
(
"
OBJLC
[
%
p
]
:
NewType
#
4
:
%
u
"
this
newType
)
)
;
}
if
(
useChannel
&
&
newType
=
=
eType_Loading
)
{
newType
=
mType
;
LOG
(
(
"
OBJLC
[
%
p
]
:
NewType
#
5
:
%
u
"
this
newType
)
)
;
newMime
=
mContentType
;
newURI
=
mURI
;
}
else
if
(
useChannel
&
&
!
newChannel
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamChannelChanged
)
;
useChannel
=
false
;
}
if
(
newType
!
=
mType
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamStateChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Type
changed
from
%
u
-
>
%
u
"
this
mType
newType
)
)
;
mType
=
newType
;
}
if
(
!
URIEquals
(
mBaseURI
newBaseURI
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Object
effective
baseURI
changed
"
this
)
)
;
mBaseURI
=
newBaseURI
;
}
if
(
!
URIEquals
(
newURI
mURI
)
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamStateChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Object
effective
URI
changed
"
this
)
)
;
mURI
=
newURI
;
}
if
(
mType
!
=
eType_Loading
&
&
mContentType
!
=
newMime
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamStateChanged
)
;
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamContentTypeChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Object
effective
mime
type
changed
(
%
s
-
>
%
s
)
"
this
mContentType
.
get
(
)
newMime
.
get
(
)
)
)
;
mContentType
=
newMime
;
}
if
(
useChannel
&
&
!
newChannel
&
&
(
retval
&
eParamStateChanged
)
)
{
mType
=
eType_Loading
;
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamChannelChanged
)
;
}
return
retval
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
InitializeFromChannel
(
nsIRequest
*
aChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
InitializeFromChannel
:
%
p
"
this
aChannel
)
)
;
if
(
mType
!
=
eType_Loading
|
|
mChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
not
have
begun
loading
at
this
point
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
UpdateObjectParameters
(
)
;
mType
=
eType_Loading
;
mChannel
=
do_QueryInterface
(
aChannel
)
;
NS_ASSERTION
(
mChannel
"
passed
a
request
that
is
not
a
channel
"
)
;
return
NS_OK
;
}
nsresult
nsObjectLoadingContent
:
:
LoadObject
(
bool
aNotify
bool
aForceLoad
)
{
return
LoadObject
(
aNotify
aForceLoad
nullptr
)
;
}
nsresult
nsObjectLoadingContent
:
:
LoadObject
(
bool
aNotify
bool
aForceLoad
nsIRequest
*
aLoadingChannel
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
nsresult
rv
=
NS_OK
;
if
(
!
doc
-
>
IsCurrentActiveDocument
(
)
)
{
UnloadObject
(
)
;
ObjectType
oldType
=
mType
;
mType
=
eType_Fallback
;
ConfigureFallback
(
)
;
NotifyStateChanged
(
oldType
ObjectState
(
)
true
)
;
return
NS_OK
;
}
if
(
doc
-
>
IsBeingUsedAsImage
(
)
)
{
return
NS_OK
;
}
if
(
doc
-
>
IsLoadedAsData
(
)
&
&
!
doc
-
>
IsStaticDocument
(
)
)
{
return
NS_OK
;
}
if
(
doc
-
>
IsStaticDocument
(
)
)
{
if
(
mType
!
=
eType_Image
&
&
mType
!
=
eType_Loading
)
{
return
NS_OK
;
}
}
LOG
(
(
"
OBJLC
[
%
p
]
:
LoadObject
called
notify
%
u
forceload
%
u
channel
%
p
"
this
aNotify
aForceLoad
aLoadingChannel
)
)
;
if
(
aForceLoad
&
&
mChannelLoaded
)
{
CloseChannel
(
)
;
mChannelLoaded
=
false
;
}
ElementState
oldState
=
ObjectState
(
)
;
ObjectType
oldType
=
mType
;
ParameterUpdateFlags
stateChange
=
UpdateObjectParameters
(
)
;
if
(
!
stateChange
&
&
!
aForceLoad
)
{
return
NS_OK
;
}
LOG
(
(
"
OBJLC
[
%
p
]
:
LoadObject
-
plugin
state
changed
(
%
u
)
"
this
stateChange
)
)
;
if
(
mIsLoading
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Re
-
entering
into
LoadObject
"
this
)
)
;
}
mIsLoading
=
true
;
AutoSetLoadingToFalse
reentryCheck
(
this
)
;
UnloadObject
(
false
)
;
if
(
!
mIsLoading
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Re
-
entered
into
LoadObject
aborting
outer
load
"
this
)
)
;
return
NS_OK
;
}
if
(
stateChange
&
eParamChannelChanged
)
{
CloseChannel
(
)
;
mChannelLoaded
=
false
;
}
else
if
(
mType
=
=
eType_Null
&
&
mChannel
)
{
CloseChannel
(
)
;
}
else
if
(
mType
=
=
eType_Loading
&
&
mChannel
)
{
return
NS_OK
;
}
else
if
(
mChannelLoaded
&
&
mChannel
!
=
aLoadingChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Loading
with
a
channel
but
state
doesn
'
t
make
sense
"
)
;
return
NS_OK
;
}
if
(
mType
!
=
eType_Null
&
&
mType
!
=
eType_Fallback
)
{
bool
allowLoad
=
true
;
int16_t
contentPolicy
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
allowLoad
&
&
mURI
&
&
!
mChannelLoaded
&
&
mType
!
=
eType_Loading
)
{
allowLoad
=
CheckLoadPolicy
(
&
contentPolicy
)
;
}
if
(
allowLoad
&
&
mType
!
=
eType_Loading
)
{
allowLoad
=
CheckProcessPolicy
(
&
contentPolicy
)
;
}
if
(
!
mIsLoading
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
We
re
-
entered
in
content
policy
leaving
original
load
"
this
)
)
;
return
NS_OK
;
}
if
(
!
allowLoad
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Load
denied
by
policy
"
this
)
)
;
mType
=
eType_Null
;
}
}
if
(
mType
!
=
eType_Null
)
{
nsCOMPtr
<
nsIURI
>
tempURI
=
mURI
;
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
tempURI
)
;
while
(
nestedURI
)
{
if
(
tempURI
-
>
SchemeIs
(
"
view
-
source
"
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Blocking
as
effective
URI
has
view
-
source
scheme
"
this
)
)
;
mType
=
eType_Null
;
break
;
}
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
tempURI
)
)
;
nestedURI
=
do_QueryInterface
(
tempURI
)
;
}
}
if
(
(
mType
=
=
eType_Null
|
|
IsPluginType
(
mType
)
)
&
&
ShouldBlockContent
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Enable
content
blocking
"
this
)
)
;
mType
=
eType_Loading
;
}
if
(
mFrameLoader
|
|
mPendingInstantiateEvent
|
|
mPendingCheckPluginStopEvent
|
|
mFinalListener
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
load
new
plugin
with
existing
content
"
)
;
return
NS_OK
;
}
if
(
mType
!
=
eType_Null
&
&
!
!
mChannel
!
=
mChannelLoaded
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
load
with
bad
channel
state
"
)
;
return
NS_OK
;
}
if
(
mType
=
=
eType_Null
)
{
rv
=
BuildParametersArray
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIStreamListener
>
finalListener
;
switch
(
mType
)
{
case
eType_Image
:
if
(
!
mChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Attempting
to
load
image
without
a
channel
?
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
break
;
}
rv
=
LoadImageWithChannel
(
mChannel
getter_AddRefs
(
finalListener
)
)
;
break
;
case
eType_Document
:
{
if
(
!
mChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Attempting
to
load
a
document
without
a
"
"
channel
"
)
;
rv
=
NS_ERROR_FAILURE
;
break
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
SetupDocShell
(
mURI
)
;
if
(
!
docShell
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
nsLoadFlags
flags
=
0
;
mChannel
-
>
GetLoadFlags
(
&
flags
)
;
flags
|
=
nsIChannel
:
:
LOAD_DOCUMENT_URI
;
mChannel
-
>
SetLoadFlags
(
flags
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
req
(
do_QueryInterface
(
docShell
)
)
;
NS_ASSERTION
(
req
"
Docshell
must
be
an
ifreq
"
)
;
nsCOMPtr
<
nsIURILoader
>
uriLoader
(
components
:
:
URILoader
:
:
Service
(
)
)
;
if
(
NS_WARN_IF
(
!
uriLoader
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
to
get
uriLoader
service
"
)
;
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
break
;
}
rv
=
uriLoader
-
>
OpenChannel
(
mChannel
nsIURILoader
:
:
DONT_RETARGET
req
getter_AddRefs
(
finalListener
)
)
;
}
break
;
case
eType_Loading
:
rv
=
OpenChannel
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
OpenChannel
returned
failure
(
%
"
PRIu32
"
)
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
break
;
case
eType_Null
:
case
eType_Fallback
:
break
;
case
eType_FakePlugin
:
MOZ_CRASH
(
"
Shouldn
'
t
reach
here
!
This
means
there
'
s
a
fakeplugin
trying
to
be
"
"
loaded
.
"
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Loading
failed
switching
to
null
"
this
)
)
;
mType
=
eType_Null
;
}
if
(
mType
=
=
eType_Fallback
|
|
mType
=
=
eType_Null
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Switching
to
fallback
state
"
this
)
)
;
MOZ_ASSERT
(
!
mFrameLoader
"
switched
to
fallback
but
also
loaded
something
"
)
;
MaybeFireErrorEvent
(
)
;
if
(
mChannel
)
{
CloseChannel
(
)
;
}
finalListener
=
nullptr
;
ConfigureFallback
(
)
;
}
NotifyStateChanged
(
oldType
oldState
aNotify
)
;
NS_ENSURE_TRUE
(
mIsLoading
NS_OK
)
;
rv
=
NS_OK
;
if
(
finalListener
)
{
NS_ASSERTION
(
mType
!
=
eType_Null
&
&
mType
!
=
eType_Loading
"
We
should
not
have
a
final
listener
with
a
non
-
loaded
type
"
)
;
mFinalListener
=
finalListener
;
RefPtr
<
DocumentChannel
>
documentChannel
=
do_QueryObject
(
mChannel
)
;
if
(
documentChannel
)
{
MOZ_ASSERT
(
mType
=
=
eType_Document
"
We
have
a
DocumentChannel
here
but
aren
'
t
loading
a
document
?
"
)
;
}
else
{
rv
=
finalListener
-
>
OnStartRequest
(
mChannel
)
;
}
}
if
(
NS_FAILED
(
rv
)
&
&
mIsLoading
)
{
oldType
=
mType
;
mType
=
eType_Fallback
;
UnloadObject
(
false
)
;
NS_ENSURE_TRUE
(
mIsLoading
NS_OK
)
;
CloseChannel
(
)
;
ConfigureFallback
(
)
;
NotifyStateChanged
(
oldType
ObjectState
(
)
true
)
;
}
return
NS_OK
;
}
nsresult
nsObjectLoadingContent
:
:
CloseChannel
(
)
{
if
(
mChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Closing
channel
\
n
"
this
)
)
;
nsCOMPtr
<
nsIChannel
>
channelGrip
(
mChannel
)
;
nsCOMPtr
<
nsIStreamListener
>
listenerGrip
(
mFinalListener
)
;
mChannel
=
nullptr
;
mFinalListener
=
nullptr
;
channelGrip
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
if
(
listenerGrip
)
{
listenerGrip
-
>
OnStopRequest
(
channelGrip
NS_BINDING_ABORTED
)
;
}
}
return
NS_OK
;
}
bool
nsObjectLoadingContent
:
:
IsAboutBlankLoadOntoInitialAboutBlank
(
nsIURI
*
aURI
bool
aInheritPrincipal
nsIPrincipal
*
aPrincipalToInherit
)
{
return
NS_IsAboutBlank
(
aURI
)
&
&
aInheritPrincipal
&
&
(
!
mFrameLoader
|
|
!
mFrameLoader
-
>
GetExistingDocShell
(
)
|
|
mFrameLoader
-
>
GetExistingDocShell
(
)
-
>
IsAboutBlankLoadOntoInitialAboutBlank
(
aURI
aInheritPrincipal
aPrincipalToInherit
)
)
;
}
nsresult
nsObjectLoadingContent
:
:
OpenChannel
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
NS_ASSERTION
(
doc
"
No
owner
document
?
"
)
;
nsresult
rv
;
mChannel
=
nullptr
;
if
(
!
mURI
|
|
!
CanHandleURI
(
mURI
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsILoadGroup
>
group
=
doc
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsIChannel
>
chan
;
RefPtr
<
ObjectInterfaceRequestorShim
>
shim
=
new
ObjectInterfaceRequestorShim
(
this
)
;
bool
inheritAttrs
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
thisContent
-
>
NodePrincipal
(
)
mURI
true
false
)
;
bool
inheritPrincipal
=
inheritAttrs
&
&
!
SchemeIsData
(
mURI
)
;
nsSecurityFlags
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_SEC_CONTEXT_IS_NULL
;
if
(
inheritPrincipal
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
}
nsContentPolicyType
contentPolicyType
=
GetContentPolicyType
(
)
;
nsLoadFlags
loadFlags
=
nsIChannel
:
:
LOAD_CALL_CONTENT_SNIFFERS
|
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
|
nsIRequest
:
:
LOAD_HTML_OBJECT_DATA
;
uint32_t
sandboxFlags
=
doc
-
>
GetSandboxFlags
(
)
;
RefPtr
<
nsCSPContext
>
cspToInherit
;
if
(
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
doc
-
>
GetCsp
(
)
)
{
cspToInherit
=
new
nsCSPContext
(
)
;
cspToInherit
-
>
InitFromOther
(
static_cast
<
nsCSPContext
*
>
(
csp
.
get
(
)
)
)
;
}
RefPtr
<
LoadInfo
>
loadInfo
=
new
LoadInfo
(
nullptr
nullptr
thisContent
securityFlags
contentPolicyType
Nothing
(
)
Nothing
(
)
sandboxFlags
)
;
if
(
inheritAttrs
)
{
loadInfo
-
>
SetPrincipalToInherit
(
thisContent
-
>
NodePrincipal
(
)
)
;
}
if
(
cspToInherit
)
{
loadInfo
-
>
SetCSPToInherit
(
cspToInherit
)
;
}
if
(
DocumentChannel
:
:
CanUseDocumentChannel
(
mURI
)
&
&
!
IsAboutBlankLoadOntoInitialAboutBlank
(
mURI
inheritPrincipal
thisContent
-
>
NodePrincipal
(
)
)
)
{
RefPtr
<
nsDocShellLoadState
>
loadState
=
new
nsDocShellLoadState
(
mURI
)
;
loadState
-
>
SetPrincipalToInherit
(
thisContent
-
>
NodePrincipal
(
)
)
;
loadState
-
>
SetTriggeringPrincipal
(
loadInfo
-
>
TriggeringPrincipal
(
)
)
;
if
(
cspToInherit
)
{
loadState
-
>
SetCsp
(
cspToInherit
)
;
}
loadState
-
>
SetTriggeringSandboxFlags
(
sandboxFlags
)
;
auto
referrerInfo
=
MakeRefPtr
<
ReferrerInfo
>
(
*
doc
)
;
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
chan
=
DocumentChannel
:
:
CreateForObject
(
loadState
loadInfo
loadFlags
shim
)
;
MOZ_ASSERT
(
chan
)
;
chan
-
>
SetLoadGroup
(
group
)
;
}
else
{
rv
=
NS_NewChannelInternal
(
getter_AddRefs
(
chan
)
mURI
loadInfo
nullptr
group
shim
loadFlags
nullptr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
inheritAttrs
)
{
nsCOMPtr
<
nsILoadInfo
>
loadinfo
=
chan
-
>
LoadInfo
(
)
;
loadinfo
-
>
SetPrincipalToInherit
(
thisContent
-
>
NodePrincipal
(
)
)
;
}
if
(
cspToInherit
)
{
nsCOMPtr
<
nsILoadInfo
>
loadinfo
=
chan
-
>
LoadInfo
(
)
;
static_cast
<
LoadInfo
*
>
(
loadinfo
.
get
(
)
)
-
>
SetCSPToInherit
(
cspToInherit
)
;
}
}
;
nsCOMPtr
<
nsIHttpChannel
>
httpChan
(
do_QueryInterface
(
chan
)
)
;
if
(
httpChan
)
{
auto
referrerInfo
=
MakeRefPtr
<
ReferrerInfo
>
(
*
doc
)
;
rv
=
httpChan
-
>
SetReferrerInfoWithoutClone
(
referrerInfo
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChan
)
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
thisContent
-
>
LocalName
(
)
)
;
}
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
httpChan
)
)
;
if
(
cos
&
&
UserActivation
:
:
IsHandlingUserInput
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
UrgentStart
)
;
}
}
nsCOMPtr
<
nsIScriptChannel
>
scriptChannel
=
do_QueryInterface
(
chan
)
;
if
(
scriptChannel
)
{
scriptChannel
-
>
SetExecutionPolicy
(
nsIScriptChannel
:
:
EXECUTE_NORMAL
)
;
}
rv
=
chan
-
>
AsyncOpen
(
shim
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
opened
"
this
)
)
;
mChannel
=
chan
;
return
NS_OK
;
}
uint32_t
nsObjectLoadingContent
:
:
GetCapabilities
(
)
const
{
return
eSupportImages
|
eSupportPlugins
|
eSupportDocuments
;
}
void
nsObjectLoadingContent
:
:
Destroy
(
)
{
if
(
mFrameLoader
)
{
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
}
if
(
mInstantiating
)
{
QueueCheckPluginStopEvent
(
)
;
}
UnloadObject
(
)
;
nsImageLoadingContent
:
:
Destroy
(
)
;
}
void
nsObjectLoadingContent
:
:
Traverse
(
nsObjectLoadingContent
*
tmp
nsCycleCollectionTraversalCallback
&
cb
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFrameLoader
)
;
}
void
nsObjectLoadingContent
:
:
Unlink
(
nsObjectLoadingContent
*
tmp
)
{
if
(
tmp
-
>
mFrameLoader
)
{
tmp
-
>
mFrameLoader
-
>
Destroy
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFrameLoader
)
;
}
void
nsObjectLoadingContent
:
:
UnloadObject
(
bool
aResetState
)
{
CancelImageRequests
(
false
)
;
if
(
mFrameLoader
)
{
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
}
if
(
aResetState
)
{
CloseChannel
(
)
;
mChannelLoaded
=
false
;
mType
=
eType_Loading
;
mURI
=
mOriginalURI
=
mBaseURI
=
nullptr
;
mContentType
.
Truncate
(
)
;
mOriginalContentType
.
Truncate
(
)
;
}
mInstantiating
=
false
;
mScriptRequested
=
false
;
mIsStopping
=
false
;
mCachedAttributes
.
Clear
(
)
;
mCachedParameters
.
Clear
(
)
;
StopPluginInstance
(
)
;
}
void
nsObjectLoadingContent
:
:
NotifyStateChanged
(
ObjectType
aOldType
ElementState
aOldState
bool
aNotify
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
NotifyStateChanged
:
(
%
u
%
"
PRIx64
"
)
-
>
(
%
u
%
"
PRIx64
"
)
"
"
(
notify
%
i
)
"
this
aOldType
aOldState
.
GetInternalValue
(
)
mType
ObjectState
(
)
.
GetInternalValue
(
)
aNotify
)
)
;
nsCOMPtr
<
dom
:
:
Element
>
thisEl
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
MOZ_ASSERT
(
thisEl
"
must
be
an
element
"
)
;
thisEl
-
>
UpdateState
(
false
)
;
if
(
!
aNotify
)
{
return
;
}
Document
*
doc
=
thisEl
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
const
ElementState
newState
=
ObjectState
(
)
;
if
(
newState
=
=
aOldState
&
&
mType
=
=
aOldType
)
{
return
;
}
RefPtr
<
PresShell
>
presShell
=
doc
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
(
aOldType
!
=
mType
)
)
{
presShell
-
>
PostRecreateFramesFor
(
thisEl
)
;
}
}
nsObjectLoadingContent
:
:
ObjectType
nsObjectLoadingContent
:
:
GetTypeOfContent
(
const
nsCString
&
aMIMEType
bool
aNoFakePlugin
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
MOZ_ASSERT
(
GetCapabilities
(
)
&
(
eSupportImages
|
eSupportDocuments
|
eSupportPlugins
)
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
calling
HtmlObjectContentTypeForMIMEType
:
aMIMEType
:
%
s
-
"
"
thisContent
:
%
p
\
n
"
this
aMIMEType
.
get
(
)
thisContent
.
get
(
)
)
)
;
auto
ret
=
static_cast
<
ObjectType
>
(
nsContentUtils
:
:
HtmlObjectContentTypeForMIMEType
(
aMIMEType
aNoFakePlugin
)
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
called
HtmlObjectContentTypeForMIMEType
\
n
"
this
)
)
;
return
ret
;
}
void
nsObjectLoadingContent
:
:
CreateStaticClone
(
nsObjectLoadingContent
*
aDest
)
const
{
aDest
-
>
mType
=
mType
;
if
(
mFrameLoader
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
aDest
)
)
;
Document
*
doc
=
content
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsStaticDocument
(
)
)
{
doc
-
>
AddPendingFrameStaticClone
(
aDest
mFrameLoader
)
;
}
}
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
SyncStartPluginInstance
(
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Must
be
able
to
run
script
in
order
to
instantiate
a
plugin
instance
!
"
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
!
InActiveDocument
(
thisContent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
kungFuURIGrip
(
mURI
)
;
mozilla
:
:
Unused
<
<
kungFuURIGrip
;
nsCString
contentType
(
mContentType
)
;
return
InstantiatePluginInstance
(
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
AsyncStartPluginInstance
(
)
{
if
(
mPendingInstantiateEvent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsStaticDocument
(
)
|
|
doc
-
>
IsBeingUsedAsImage
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsAsyncInstantiateEvent
(
this
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
event
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingInstantiateEvent
=
event
;
}
return
rv
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetSrcURI
(
nsIURI
*
*
aURI
)
{
NS_IF_ADDREF
(
*
aURI
=
GetSrcURI
(
)
)
;
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
ConfigureFallback
(
)
{
MOZ_ASSERT
(
!
mFrameLoader
&
&
!
mChannel
"
ConfigureFallback
called
with
loaded
content
"
)
;
MOZ_ASSERT
(
mType
=
=
eType_Fallback
|
|
mType
=
=
eType_Null
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
bool
hasHtmlFallback
=
false
;
if
(
thisContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
{
for
(
nsIContent
*
child
=
thisContent
-
>
GetFirstChild
(
)
;
child
;
)
{
hasHtmlFallback
=
hasHtmlFallback
|
|
(
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
param
)
&
&
nsStyleUtil
:
:
IsSignificantChild
(
child
false
)
)
;
if
(
auto
embed
=
HTMLEmbedElement
:
:
FromNode
(
child
)
)
{
embed
-
>
StartObjectLoad
(
true
true
)
;
child
=
child
-
>
GetNextNonChildNode
(
thisContent
)
;
}
else
if
(
auto
object
=
HTMLObjectElement
:
:
FromNode
(
child
)
)
{
object
-
>
StartObjectLoad
(
true
true
)
;
child
=
child
-
>
GetNextNonChildNode
(
thisContent
)
;
}
else
{
child
=
child
-
>
GetNextNode
(
thisContent
)
;
}
}
}
if
(
hasHtmlFallback
)
{
mType
=
eType_Null
;
}
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
StopPluginInstance
(
)
{
AUTO_PROFILER_LABEL
(
"
nsObjectLoadingContent
:
:
StopPluginInstance
"
OTHER
)
;
mPendingInstantiateEvent
=
nullptr
;
mPendingCheckPluginStopEvent
=
nullptr
;
mInstantiating
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
Reload
(
bool
aClearActivation
)
{
if
(
aClearActivation
)
{
mSkipFakePlugins
=
false
;
}
return
LoadObject
(
true
true
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
SkipFakePlugins
(
)
{
if
(
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
mSkipFakePlugins
=
true
;
if
(
mType
=
=
eType_FakePlugin
)
{
return
LoadObject
(
true
true
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
UpgradeLoadToDocument
(
nsIChannel
*
aRequest
BrowsingContext
*
*
aBrowsingContext
)
{
AUTO_PROFILER_LABEL
(
"
nsObjectLoadingContent
:
:
UpgradeLoadToDocument
"
NETWORK
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
UpgradeLoadToDocument
"
this
)
)
;
if
(
aRequest
!
=
mChannel
|
|
!
aRequest
)
{
return
NS_BINDING_ABORTED
;
}
if
(
mType
!
=
eType_Loading
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
be
type
loading
at
this
point
"
)
;
return
NS_BINDING_ABORTED
;
}
MOZ_ASSERT
(
!
mChannelLoaded
"
mChannelLoaded
set
already
?
"
)
;
MOZ_ASSERT
(
!
mFinalListener
"
mFinalListener
exists
already
?
"
)
;
mChannelLoaded
=
true
;
nsresult
rv
=
LoadObject
(
true
false
aRequest
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
NS_ERROR_FAILURE
;
}
bc
.
forget
(
aBrowsingContext
)
;
return
NS_OK
;
}
uint32_t
nsObjectLoadingContent
:
:
GetRunID
(
SystemCallerGuarantee
ErrorResult
&
aRv
)
{
if
(
!
mHasRunID
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
0
;
}
return
mRunID
;
}
bool
nsObjectLoadingContent
:
:
ShouldBlockContent
(
)
{
if
(
mContentBlockingEnabled
&
&
mURI
&
&
IsFlashMIME
(
mContentType
)
&
&
StaticPrefs
:
:
browser_safebrowsing_blockedURIs_enabled
(
)
)
{
return
true
;
}
return
false
;
}
Document
*
nsObjectLoadingContent
:
:
GetContentDocument
(
nsIPrincipal
&
aSubjectPrincipal
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
!
thisContent
-
>
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
Document
*
sub_doc
=
thisContent
-
>
OwnerDoc
(
)
-
>
GetSubDocumentFor
(
thisContent
)
;
if
(
!
sub_doc
)
{
return
nullptr
;
}
if
(
!
aSubjectPrincipal
.
SubsumesConsideringDomain
(
sub_doc
-
>
NodePrincipal
(
)
)
)
{
return
nullptr
;
}
return
sub_doc
;
}
bool
nsObjectLoadingContent
:
:
DoResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
mozilla
:
:
Maybe
<
JS
:
:
PropertyDescriptor
>
>
aDesc
)
{
return
true
;
}
bool
nsObjectLoadingContent
:
:
MayResolve
(
jsid
aId
)
{
return
true
;
}
void
nsObjectLoadingContent
:
:
GetOwnPropertyNames
(
JSContext
*
aCx
JS
:
:
MutableHandleVector
<
jsid
>
bool
ErrorResult
&
aRv
)
{
}
void
nsObjectLoadingContent
:
:
MaybeFireErrorEvent
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
thisContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
{
RefPtr
<
AsyncEventDispatcher
>
loadBlockingAsyncDispatcher
=
new
LoadBlockingAsyncEventDispatcher
(
thisContent
u
"
error
"
_ns
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
loadBlockingAsyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
bool
nsObjectLoadingContent
:
:
BlockEmbedOrObjectContentLoading
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
for
(
nsIContent
*
parent
=
thisContent
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
if
(
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
video
nsGkAtoms
:
:
audio
)
)
{
return
true
;
}
if
(
HTMLObjectElement
*
object
=
HTMLObjectElement
:
:
FromNode
(
parent
)
)
{
uint32_t
type
=
object
-
>
DisplayedType
(
)
;
if
(
type
!
=
eType_Null
)
{
return
true
;
}
}
}
return
false
;
}
void
nsObjectLoadingContent
:
:
SubdocumentIntrinsicSizeOrRatioChanged
(
const
Maybe
<
IntrinsicSize
>
&
aIntrinsicSize
const
Maybe
<
AspectRatio
>
&
aIntrinsicRatio
)
{
if
(
aIntrinsicSize
=
=
mSubdocumentIntrinsicSize
&
&
aIntrinsicRatio
=
=
mSubdocumentIntrinsicRatio
)
{
return
;
}
mSubdocumentIntrinsicSize
=
aIntrinsicSize
;
mSubdocumentIntrinsicRatio
=
aIntrinsicRatio
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
nsSubDocumentFrame
*
sdf
=
do_QueryFrame
(
thisContent
-
>
GetPrimaryFrame
(
)
)
)
{
sdf
-
>
SubdocumentIntrinsicSizeOrRatioChanged
(
)
;
}
}
void
nsObjectLoadingContent
:
:
MaybeStoreCrossOriginFeaturePolicy
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mFrameLoader
)
;
if
(
!
mFrameLoader
-
>
IsRemoteFrame
(
)
&
&
!
mFrameLoader
-
>
GetExistingDocShell
(
)
)
{
return
;
}
RefPtr
<
BrowsingContext
>
browsingContext
=
mFrameLoader
-
>
GetBrowsingContext
(
)
;
if
(
!
browsingContext
|
|
!
browsingContext
-
>
IsContentSubframe
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
AsContent
(
)
;
if
(
!
thisContent
-
>
IsInComposedDoc
(
)
)
{
return
;
}
FeaturePolicy
*
featurePolicy
=
thisContent
-
>
OwnerDoc
(
)
-
>
FeaturePolicy
(
)
;
if
(
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
)
{
Unused
<
<
cc
-
>
SendSetContainerFeaturePolicy
(
browsingContext
featurePolicy
)
;
}
}
