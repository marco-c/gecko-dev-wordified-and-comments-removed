#
include
"
imgLoader
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIExternalProtocolHandler
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIObjectFrame
.
h
"
#
include
"
nsIOService
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsPluginHost
.
h
"
#
include
"
nsPluginInstanceOwner
.
h
"
#
include
"
nsJSNPRuntime
.
h
"
#
include
"
nsINestedURI
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsIURILoader
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWebNavigationInfo
.
h
"
#
include
"
nsIScriptChannel
.
h
"
#
include
"
nsIBlocklistService
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsIAppShell
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsError
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCURILoader
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsPluginFrame
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
PluginCrashedEvent
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
widget
/
IMEData
.
h
"
#
include
"
mozilla
/
IntegerPrintfMacros
.
h
"
#
include
"
mozilla
/
dom
/
HTMLObjectElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLEmbedElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLObjectElement
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
nsChannelClassifier
.
h
"
#
include
"
nsFocusManager
.
h
"
#
ifdef
XP_WIN
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
endif
static
NS_DEFINE_CID
(
kAppShellCID
NS_APPSHELL_CID
)
;
static
const
char
kPrefYoutubeRewrite
[
]
=
"
plugins
.
rewrite_youtube_embeds
"
;
static
const
char
kPrefBlockURIs
[
]
=
"
browser
.
safebrowsing
.
blockedURIs
.
enabled
"
;
static
const
char
kPrefFavorFallbackMode
[
]
=
"
plugins
.
favorfallback
.
mode
"
;
static
const
char
kPrefFavorFallbackRules
[
]
=
"
plugins
.
favorfallback
.
rules
"
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
net
;
static
LogModule
*
GetObjectLog
(
)
{
static
LazyLogModule
sLog
(
"
objlc
"
)
;
return
sLog
;
}
#
define
LOG
(
args
)
MOZ_LOG
(
GetObjectLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
MOZ_LOG_TEST
(
GetObjectLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
)
static
bool
IsFlashMIME
(
const
nsACString
&
aMIMEType
)
{
return
nsPluginHost
:
:
GetSpecialType
(
aMIMEType
)
=
=
nsPluginHost
:
:
eSpecialType_Flash
;
}
static
bool
InActiveDocument
(
nsIContent
*
aContent
)
{
if
(
!
aContent
-
>
IsInComposedDoc
(
)
)
{
return
false
;
}
Document
*
doc
=
aContent
-
>
OwnerDoc
(
)
;
return
(
doc
&
&
doc
-
>
IsActive
(
)
)
;
}
static
bool
IsPluginType
(
nsObjectLoadingContent
:
:
ObjectType
type
)
{
return
type
=
=
nsObjectLoadingContent
:
:
eType_Plugin
|
|
type
=
=
nsObjectLoadingContent
:
:
eType_FakePlugin
;
}
class
nsAsyncInstantiateEvent
:
public
Runnable
{
public
:
explicit
nsAsyncInstantiateEvent
(
nsObjectLoadingContent
*
aContent
)
:
Runnable
(
"
nsAsyncInstantiateEvent
"
)
mContent
(
aContent
)
{
}
~
nsAsyncInstantiateEvent
(
)
override
=
default
;
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsIObjectLoadingContent
>
mContent
;
}
;
NS_IMETHODIMP
nsAsyncInstantiateEvent
:
:
Run
(
)
{
nsObjectLoadingContent
*
objLC
=
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
;
if
(
objLC
-
>
mPendingInstantiateEvent
!
=
this
)
{
return
NS_OK
;
}
objLC
-
>
mPendingInstantiateEvent
=
nullptr
;
return
objLC
-
>
SyncStartPluginInstance
(
)
;
}
class
CheckPluginStopEvent
:
public
Runnable
{
public
:
explicit
CheckPluginStopEvent
(
nsObjectLoadingContent
*
aContent
)
:
Runnable
(
"
CheckPluginStopEvent
"
)
mContent
(
aContent
)
{
}
~
CheckPluginStopEvent
(
)
override
=
default
;
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsIObjectLoadingContent
>
mContent
;
}
;
NS_IMETHODIMP
CheckPluginStopEvent
:
:
Run
(
)
{
nsObjectLoadingContent
*
objLC
=
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
;
if
(
objLC
-
>
mPendingCheckPluginStopEvent
!
=
this
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
objLC
)
)
;
if
(
!
InActiveDocument
(
content
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Unloading
plugin
outside
of
document
"
this
)
)
;
objLC
-
>
StopPluginInstance
(
)
;
return
NS_OK
;
}
if
(
content
-
>
GetPrimaryFrame
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
in
active
document
with
frame
"
"
no
action
"
this
)
)
;
objLC
-
>
mPendingCheckPluginStopEvent
=
nullptr
;
return
NS_OK
;
}
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
No
frame
flushing
layout
"
this
)
)
;
Document
*
composedDoc
=
content
-
>
GetComposedDoc
(
)
;
if
(
composedDoc
)
{
composedDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
objLC
-
>
mPendingCheckPluginStopEvent
!
=
this
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
superseded
in
layout
flush
"
this
)
)
;
return
NS_OK
;
}
if
(
content
-
>
GetPrimaryFrame
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckPluginStopEvent
-
frame
gained
in
layout
flush
"
this
)
)
;
objLC
-
>
mPendingCheckPluginStopEvent
=
nullptr
;
return
NS_OK
;
}
}
LOG
(
(
"
OBJLC
[
%
p
]
:
Stopping
plugin
that
lost
frame
"
this
)
)
;
objLC
-
>
StopPluginInstance
(
)
;
return
NS_OK
;
}
class
nsSimplePluginEvent
:
public
Runnable
{
public
:
nsSimplePluginEvent
(
nsIContent
*
aTarget
const
nsAString
&
aEvent
)
:
Runnable
(
"
nsSimplePluginEvent
"
)
mTarget
(
aTarget
)
mDocument
(
aTarget
-
>
GetComposedDoc
(
)
)
mEvent
(
aEvent
)
{
MOZ_ASSERT
(
aTarget
&
&
mDocument
)
;
}
nsSimplePluginEvent
(
Document
*
aTarget
const
nsAString
&
aEvent
)
:
mozilla
:
:
Runnable
(
"
nsSimplePluginEvent
"
)
mTarget
(
ToSupports
(
aTarget
)
)
mDocument
(
aTarget
)
mEvent
(
aEvent
)
{
MOZ_ASSERT
(
aTarget
)
;
}
nsSimplePluginEvent
(
nsIContent
*
aTarget
Document
*
aDocument
const
nsAString
&
aEvent
)
:
mozilla
:
:
Runnable
(
"
nsSimplePluginEvent
"
)
mTarget
(
aTarget
)
mDocument
(
aDocument
)
mEvent
(
aEvent
)
{
MOZ_ASSERT
(
aTarget
&
&
aDocument
)
;
}
~
nsSimplePluginEvent
(
)
override
=
default
;
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsISupports
>
mTarget
;
nsCOMPtr
<
Document
>
mDocument
;
nsString
mEvent
;
}
;
NS_IMETHODIMP
nsSimplePluginEvent
:
:
Run
(
)
{
if
(
mDocument
&
&
mDocument
-
>
IsActive
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
nsSimplePluginEvent
firing
event
\
"
%
s
\
"
"
mTarget
.
get
(
)
NS_ConvertUTF16toUTF8
(
mEvent
)
.
get
(
)
)
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
mDocument
mTarget
mEvent
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
}
return
NS_OK
;
}
class
nsPluginCrashedEvent
:
public
Runnable
{
public
:
nsCOMPtr
<
nsIContent
>
mContent
;
nsString
mPluginDumpID
;
nsString
mBrowserDumpID
;
nsString
mPluginName
;
nsString
mPluginFilename
;
bool
mSubmittedCrashReport
;
nsPluginCrashedEvent
(
nsIContent
*
aContent
const
nsAString
&
aPluginDumpID
const
nsAString
&
aBrowserDumpID
const
nsAString
&
aPluginName
const
nsAString
&
aPluginFilename
bool
submittedCrashReport
)
:
Runnable
(
"
nsPluginCrashedEvent
"
)
mContent
(
aContent
)
mPluginDumpID
(
aPluginDumpID
)
mBrowserDumpID
(
aBrowserDumpID
)
mPluginName
(
aPluginName
)
mPluginFilename
(
aPluginFilename
)
mSubmittedCrashReport
(
submittedCrashReport
)
{
}
~
nsPluginCrashedEvent
(
)
override
=
default
;
NS_IMETHOD
Run
(
)
override
;
}
;
NS_IMETHODIMP
nsPluginCrashedEvent
:
:
Run
(
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Firing
plugin
crashed
event
\
n
"
mContent
.
get
(
)
)
)
;
nsCOMPtr
<
Document
>
doc
=
mContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
NS_WARNING
(
"
Couldn
'
t
get
document
for
PluginCrashed
event
!
"
)
;
return
NS_OK
;
}
PluginCrashedEventInit
init
;
init
.
mPluginDumpID
=
mPluginDumpID
;
init
.
mBrowserDumpID
=
mBrowserDumpID
;
init
.
mPluginName
=
mPluginName
;
init
.
mPluginFilename
=
mPluginFilename
;
init
.
mSubmittedCrashReport
=
mSubmittedCrashReport
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
true
;
RefPtr
<
PluginCrashedEvent
>
event
=
PluginCrashedEvent
:
:
Constructor
(
doc
NS_LITERAL_STRING
(
"
PluginCrashed
"
)
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
EventDispatcher
:
:
DispatchDOMEvent
(
mContent
nullptr
event
nullptr
nullptr
)
;
return
NS_OK
;
}
class
AutoSetInstantiatingToFalse
{
public
:
explicit
AutoSetInstantiatingToFalse
(
nsObjectLoadingContent
*
aContent
)
:
mContent
(
aContent
)
{
}
~
AutoSetInstantiatingToFalse
(
)
{
mContent
-
>
mInstantiating
=
false
;
}
private
:
nsObjectLoadingContent
*
mContent
;
}
;
class
AutoSetLoadingToFalse
{
public
:
explicit
AutoSetLoadingToFalse
(
nsObjectLoadingContent
*
aContent
)
:
mContent
(
aContent
)
{
}
~
AutoSetLoadingToFalse
(
)
{
mContent
-
>
mIsLoading
=
false
;
}
private
:
nsObjectLoadingContent
*
mContent
;
}
;
static
bool
IsSuccessfulRequest
(
nsIRequest
*
aRequest
nsresult
*
aStatus
)
{
nsresult
rv
=
aRequest
-
>
GetStatus
(
aStatus
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
*
aStatus
)
)
{
return
false
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChan
(
do_QueryInterface
(
aRequest
)
)
;
if
(
httpChan
)
{
bool
success
;
rv
=
httpChan
-
>
GetRequestSucceeded
(
&
success
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
success
)
{
return
false
;
}
}
return
true
;
}
static
bool
CanHandleURI
(
nsIURI
*
aURI
)
{
nsAutoCString
scheme
;
if
(
NS_FAILED
(
aURI
-
>
GetScheme
(
scheme
)
)
)
{
return
false
;
}
nsIIOService
*
ios
=
nsContentUtils
:
:
GetIOService
(
)
;
if
(
!
ios
)
return
false
;
nsCOMPtr
<
nsIProtocolHandler
>
handler
;
ios
-
>
GetProtocolHandler
(
scheme
.
get
(
)
getter_AddRefs
(
handler
)
)
;
if
(
!
handler
)
{
return
false
;
}
nsCOMPtr
<
nsIExternalProtocolHandler
>
extHandler
=
do_QueryInterface
(
handler
)
;
return
extHandler
=
=
nullptr
;
}
static
bool
inline
URIEquals
(
nsIURI
*
a
nsIURI
*
b
)
{
bool
equal
;
return
(
!
a
&
&
!
b
)
|
|
(
a
&
&
b
&
&
NS_SUCCEEDED
(
a
-
>
Equals
(
b
&
equal
)
)
&
&
equal
)
;
}
static
void
GetExtensionFromURI
(
nsIURI
*
uri
nsCString
&
ext
)
{
nsCOMPtr
<
nsIURL
>
url
(
do_QueryInterface
(
uri
)
)
;
if
(
url
)
{
url
-
>
GetFileExtension
(
ext
)
;
}
else
{
nsCString
spec
;
nsresult
rv
=
uri
-
>
GetSpec
(
spec
)
;
if
(
NS_FAILED
(
rv
)
)
{
ext
.
Truncate
(
)
;
return
;
}
int32_t
offset
=
spec
.
RFindChar
(
'
.
'
)
;
if
(
offset
!
=
kNotFound
)
{
ext
=
Substring
(
spec
offset
+
1
spec
.
Length
(
)
)
;
}
}
}
bool
IsPluginEnabledByExtension
(
nsIURI
*
uri
nsCString
&
mimeType
)
{
nsAutoCString
ext
;
GetExtensionFromURI
(
uri
ext
)
;
if
(
ext
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
ext
.
EqualsIgnoreCase
(
"
pdf
"
)
&
&
nsContentUtils
:
:
IsPDFJSEnabled
(
)
)
{
return
false
;
}
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
!
pluginHost
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
pluginhost
"
)
;
return
false
;
}
return
pluginHost
-
>
HavePluginForExtension
(
ext
mimeType
)
;
}
void
nsObjectLoadingContent
:
:
QueueCheckPluginStopEvent
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
CheckPluginStopEvent
(
this
)
;
mPendingCheckPluginStopEvent
=
event
;
NS_DispatchToCurrentThread
(
event
)
;
}
bool
nsObjectLoadingContent
:
:
MakePluginListener
(
)
{
if
(
!
mInstanceOwner
)
{
MOZ_ASSERT_UNREACHABLE
(
"
expecting
a
spawned
plugin
"
)
;
return
false
;
}
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
!
pluginHost
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
pluginHost
"
)
;
return
false
;
}
NS_ASSERTION
(
!
mFinalListener
"
overwriting
a
final
listener
"
)
;
nsresult
rv
;
RefPtr
<
nsNPAPIPluginInstance
>
inst
=
mInstanceOwner
-
>
GetInstance
(
)
;
nsCOMPtr
<
nsIStreamListener
>
finalListener
;
rv
=
pluginHost
-
>
NewPluginStreamListener
(
mURI
inst
getter_AddRefs
(
finalListener
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
mFinalListener
=
finalListener
;
return
true
;
}
void
nsObjectLoadingContent
:
:
SetupFrameLoader
(
int32_t
aJSPluginId
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
mFrameLoader
=
nsFrameLoader
:
:
Create
(
thisContent
-
>
AsElement
(
)
nullptr
mNetworkCreated
aJSPluginId
)
;
MOZ_ASSERT
(
mFrameLoader
"
nsFrameLoader
:
:
Create
failed
"
)
;
}
already_AddRefed
<
nsIDocShell
>
nsObjectLoadingContent
:
:
SetupDocShell
(
nsIURI
*
aRecursionCheckURI
)
{
SetupFrameLoader
(
nsFakePluginTag
:
:
NOT_JSPLUGIN
)
;
if
(
!
mFrameLoader
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
;
if
(
aRecursionCheckURI
)
{
nsresult
rv
=
mFrameLoader
-
>
CheckForRecursiveLoad
(
aRecursionCheckURI
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
IgnoredErrorResult
result
;
docShell
=
mFrameLoader
-
>
GetDocShell
(
result
)
;
if
(
result
.
Failed
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Could
not
get
DocShell
from
mFrameLoader
?
"
)
;
}
}
else
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Aborting
recursive
load
"
this
)
)
;
}
}
if
(
!
docShell
)
{
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
return
nullptr
;
}
return
docShell
.
forget
(
)
;
}
nsresult
nsObjectLoadingContent
:
:
BindToTree
(
Document
*
aDocument
nsIContent
*
aParent
nsIContent
*
aBindingParent
)
{
nsImageLoadingContent
:
:
BindToTree
(
aDocument
aParent
aBindingParent
)
;
if
(
aDocument
)
{
aDocument
-
>
AddPlugin
(
this
)
;
}
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
UnbindFromTree
(
bool
aDeep
bool
aNullParent
)
{
nsImageLoadingContent
:
:
UnbindFromTree
(
aDeep
aNullParent
)
;
nsCOMPtr
<
Element
>
thisElement
=
do_QueryInterface
(
static_cast
<
nsIObjectLoadingContent
*
>
(
this
)
)
;
MOZ_ASSERT
(
thisElement
)
;
Document
*
ownerDoc
=
thisElement
-
>
OwnerDoc
(
)
;
ownerDoc
-
>
RemovePlugin
(
this
)
;
if
(
mType
=
=
eType_Plugin
&
&
(
mInstanceOwner
|
|
mInstantiating
)
)
{
QueueCheckPluginStopEvent
(
)
;
}
else
if
(
mType
!
=
eType_Image
)
{
UnloadObject
(
)
;
}
if
(
thisElement
-
>
IsInComposedDoc
(
)
&
&
nsContentUtils
:
:
IsUAWidgetEnabled
(
)
)
{
thisElement
-
>
NotifyUAWidgetTeardown
(
)
;
}
if
(
mType
=
=
eType_Plugin
)
{
Document
*
doc
=
thisElement
-
>
GetComposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
IsActive
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
new
nsSimplePluginEvent
(
doc
NS_LITERAL_STRING
(
"
PluginRemoved
"
)
)
;
NS_DispatchToCurrentThread
(
ev
)
;
}
}
}
nsObjectLoadingContent
:
:
nsObjectLoadingContent
(
)
:
mType
(
eType_Loading
)
mFallbackType
(
eFallbackAlternate
)
mRunID
(
0
)
mHasRunID
(
false
)
mChannelLoaded
(
false
)
mInstantiating
(
false
)
mNetworkCreated
(
true
)
mActivated
(
false
)
mContentBlockingEnabled
(
false
)
mSkipFakePlugins
(
false
)
mIsStopping
(
false
)
mIsLoading
(
false
)
mScriptRequested
(
false
)
mRewrittenYoutubeEmbed
(
false
)
mPreferFallback
(
false
)
mPreferFallbackKnown
(
false
)
{
}
nsObjectLoadingContent
:
:
~
nsObjectLoadingContent
(
)
{
if
(
mFrameLoader
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
not
be
tearing
down
frame
loaders
at
this
point
"
)
;
mFrameLoader
-
>
Destroy
(
)
;
}
if
(
mInstanceOwner
|
|
mInstantiating
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
not
be
tearing
down
a
plugin
at
this
point
!
"
)
;
StopPluginInstance
(
)
;
}
DestroyImageLoadingContent
(
)
;
}
nsresult
nsObjectLoadingContent
:
:
InstantiatePluginInstance
(
bool
aIsLoading
)
{
if
(
mInstanceOwner
|
|
mType
!
=
eType_Plugin
|
|
(
mIsLoading
!
=
aIsLoading
)
|
|
mInstantiating
)
{
NS_ASSERTION
(
mIsLoading
|
|
!
aIsLoading
"
aIsLoading
should
only
be
true
inside
LoadObject
"
)
;
return
NS_OK
;
}
mInstantiating
=
true
;
AutoSetInstantiatingToFalse
autoInstantiating
(
this
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
nsCOMPtr
<
Document
>
doc
=
thisContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
|
|
!
InActiveDocument
(
thisContent
)
)
{
NS_ERROR
(
"
Shouldn
'
t
be
calling
"
"
InstantiatePluginInstance
without
an
active
document
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIObjectLoadingContent
>
kungFuDeathGrip
=
this
;
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
NS_ENSURE_TRUE
(
mInstantiating
NS_OK
)
;
if
(
!
thisContent
-
>
GetPrimaryFrame
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Not
instantiating
plugin
with
no
frame
"
this
)
)
;
return
NS_OK
;
}
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
!
pluginHost
)
{
MOZ_ASSERT_UNREACHABLE
(
"
No
pluginhost
"
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIAppShell
>
appShell
=
do_GetService
(
kAppShellCID
)
;
if
(
appShell
)
{
appShell
-
>
SuspendNative
(
)
;
}
RefPtr
<
nsPluginInstanceOwner
>
newOwner
;
nsresult
rv
=
pluginHost
-
>
InstantiatePluginInstance
(
mContentType
mURI
.
get
(
)
this
getter_AddRefs
(
newOwner
)
)
;
if
(
appShell
)
{
appShell
-
>
ResumeNative
(
)
;
}
if
(
!
mInstantiating
|
|
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Plugin
instantiation
failed
or
re
-
entered
"
"
killing
old
instance
"
this
)
)
;
if
(
newOwner
)
{
RefPtr
<
nsNPAPIPluginInstance
>
inst
=
newOwner
-
>
GetInstance
(
)
;
newOwner
-
>
SetFrame
(
nullptr
)
;
if
(
inst
)
{
pluginHost
-
>
StopPluginInstance
(
inst
)
;
}
newOwner
-
>
Destroy
(
)
;
}
return
NS_OK
;
}
mInstanceOwner
=
newOwner
;
if
(
mInstanceOwner
)
{
RefPtr
<
nsNPAPIPluginInstance
>
inst
=
mInstanceOwner
-
>
GetInstance
(
)
;
rv
=
inst
-
>
GetRunID
(
&
mRunID
)
;
mHasRunID
=
NS_SUCCEEDED
(
rv
)
;
}
nsIFrame
*
frame
=
thisContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
mInstanceOwner
)
{
mInstanceOwner
-
>
SetFrame
(
static_cast
<
nsPluginFrame
*
>
(
frame
)
)
;
mInstanceOwner
-
>
CallSetWindow
(
)
;
}
NotifyContentObjectWrapper
(
)
;
RefPtr
<
nsNPAPIPluginInstance
>
pluginInstance
=
GetPluginInstance
(
)
;
if
(
pluginInstance
)
{
nsCOMPtr
<
nsIPluginTag
>
pluginTag
;
pluginHost
-
>
GetPluginTagForInstance
(
pluginInstance
getter_AddRefs
(
pluginTag
)
)
;
uint32_t
blockState
=
nsIBlocklistService
:
:
STATE_NOT_BLOCKED
;
pluginTag
-
>
GetBlocklistState
(
&
blockState
)
;
if
(
blockState
=
=
nsIBlocklistService
:
:
STATE_OUTDATED
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Dispatching
plugin
outdated
event
for
content
\
n
"
this
)
)
;
nsCOMPtr
<
nsIRunnable
>
ev
=
new
nsSimplePluginEvent
(
thisContent
NS_LITERAL_STRING
(
"
PluginOutdated
"
)
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
ev
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
dispatch
nsSimplePluginEvent
"
)
;
}
}
if
(
(
mURI
&
&
!
mChannelLoaded
)
|
|
(
mChannelLoaded
&
&
!
aIsLoading
)
)
{
NS_ASSERTION
(
!
mChannel
"
should
not
have
an
existing
channel
here
"
)
;
OpenChannel
(
)
;
}
}
nsCOMPtr
<
nsIRunnable
>
ev
=
new
nsSimplePluginEvent
(
thisContent
doc
NS_LITERAL_STRING
(
"
PluginInstantiated
"
)
)
;
NS_DispatchToCurrentThread
(
ev
)
;
#
ifdef
XP_MACOSX
HTMLObjectElement
:
:
HandlePluginInstantiated
(
thisContent
-
>
AsElement
(
)
)
;
#
endif
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
GetPluginAttributes
(
nsTArray
<
MozPluginParameter
>
&
aAttributes
)
{
aAttributes
=
mCachedAttributes
;
}
void
nsObjectLoadingContent
:
:
GetPluginParameters
(
nsTArray
<
MozPluginParameter
>
&
aParameters
)
{
aParameters
=
mCachedParameters
;
}
void
nsObjectLoadingContent
:
:
GetNestedParams
(
nsTArray
<
MozPluginParameter
>
&
aParams
)
{
nsCOMPtr
<
Element
>
ourElement
=
do_QueryInterface
(
static_cast
<
nsIObjectLoadingContent
*
>
(
this
)
)
;
nsCOMPtr
<
nsIHTMLCollection
>
allParams
;
NS_NAMED_LITERAL_STRING
(
xhtml_ns
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
)
;
ErrorResult
rv
;
allParams
=
ourElement
-
>
GetElementsByTagNameNS
(
xhtml_ns
NS_LITERAL_STRING
(
"
param
"
)
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
;
}
MOZ_ASSERT
(
allParams
)
;
uint32_t
numAllParams
=
allParams
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numAllParams
;
i
+
+
)
{
RefPtr
<
Element
>
element
=
allParams
-
>
Item
(
i
)
;
nsAutoString
name
;
element
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
name
"
)
name
)
;
if
(
name
.
IsEmpty
(
)
)
continue
;
nsCOMPtr
<
nsIContent
>
parent
=
element
-
>
GetParent
(
)
;
RefPtr
<
HTMLObjectElement
>
objectElement
;
while
(
!
objectElement
&
&
parent
)
{
objectElement
=
HTMLObjectElement
:
:
FromNode
(
parent
)
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
objectElement
)
{
parent
=
objectElement
;
}
else
{
continue
;
}
if
(
parent
=
=
ourElement
)
{
MozPluginParameter
param
;
element
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
name
"
)
param
.
mName
)
;
element
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
value
"
)
param
.
mValue
)
;
param
.
mName
.
Trim
(
"
\
n
\
r
\
t
\
b
"
true
true
false
)
;
param
.
mValue
.
Trim
(
"
\
n
\
r
\
t
\
b
"
true
true
false
)
;
aParams
.
AppendElement
(
param
)
;
}
}
}
nsresult
nsObjectLoadingContent
:
:
BuildParametersArray
(
)
{
if
(
mCachedAttributes
.
Length
(
)
|
|
mCachedParameters
.
Length
(
)
)
{
MOZ_ASSERT
(
false
"
Parameters
array
should
be
empty
.
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
Element
>
element
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
for
(
uint32_t
i
=
0
;
i
!
=
element
-
>
GetAttrCount
(
)
;
i
+
=
1
)
{
MozPluginParameter
param
;
const
nsAttrName
*
attrName
=
element
-
>
GetAttrNameAt
(
i
)
;
nsAtom
*
atom
=
attrName
-
>
LocalName
(
)
;
element
-
>
GetAttr
(
attrName
-
>
NamespaceID
(
)
atom
param
.
mValue
)
;
atom
-
>
ToString
(
param
.
mName
)
;
mCachedAttributes
.
AppendElement
(
param
)
;
}
nsAutoCString
wmodeOverride
;
Preferences
:
:
GetCString
(
"
plugins
.
force
.
wmode
"
wmodeOverride
)
;
for
(
uint32_t
i
=
0
;
i
<
mCachedAttributes
.
Length
(
)
;
i
+
+
)
{
if
(
!
wmodeOverride
.
IsEmpty
(
)
&
&
mCachedAttributes
[
i
]
.
mName
.
EqualsIgnoreCase
(
"
wmode
"
)
)
{
CopyASCIItoUTF16
(
wmodeOverride
mCachedAttributes
[
i
]
.
mValue
)
;
wmodeOverride
.
Truncate
(
)
;
}
}
if
(
!
wmodeOverride
.
IsEmpty
(
)
)
{
MozPluginParameter
param
;
param
.
mName
=
NS_LITERAL_STRING
(
"
wmode
"
)
;
CopyASCIItoUTF16
(
wmodeOverride
param
.
mValue
)
;
mCachedAttributes
.
AppendElement
(
param
)
;
}
if
(
element
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
&
&
!
element
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
)
{
MozPluginParameter
param
;
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
data
param
.
mValue
)
;
if
(
!
param
.
mValue
.
IsEmpty
(
)
)
{
param
.
mName
=
NS_LITERAL_STRING
(
"
SRC
"
)
;
mCachedAttributes
.
AppendElement
(
param
)
;
}
}
GetNestedParams
(
mCachedParameters
)
;
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
NotifyOwnerDocumentActivityChanged
(
)
{
if
(
mInstanceOwner
|
|
mInstantiating
)
{
QueueCheckPluginStopEvent
(
)
;
}
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
OnStartRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
)
{
AUTO_PROFILER_LABEL
(
"
nsObjectLoadingContent
:
:
OnStartRequest
"
NETWORK
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
OnStartRequest
"
this
)
)
;
if
(
aRequest
!
=
mChannel
|
|
!
aRequest
)
{
return
NS_BINDING_ABORTED
;
}
if
(
mType
=
=
eType_Plugin
)
{
if
(
!
mInstanceOwner
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Opened
a
channel
in
plugin
mode
but
don
'
t
have
"
"
a
plugin
"
)
;
return
NS_BINDING_ABORTED
;
}
if
(
MakePluginListener
(
)
)
{
return
mFinalListener
-
>
OnStartRequest
(
aRequest
nullptr
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Failed
to
create
PluginStreamListener
aborting
"
"
channel
"
)
;
return
NS_BINDING_ABORTED
;
}
if
(
mType
!
=
eType_Loading
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
be
type
loading
at
this
point
"
)
;
return
NS_BINDING_ABORTED
;
}
NS_ASSERTION
(
!
mChannelLoaded
"
mChannelLoaded
set
already
?
"
)
;
NS_ASSERTION
(
!
mFinalListener
"
mFinalListener
exists
already
?
"
)
;
mChannelLoaded
=
true
;
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
aRequest
)
)
;
NS_ASSERTION
(
chan
"
Why
is
our
request
not
a
channel
?
"
)
;
nsresult
status
=
NS_OK
;
bool
success
=
IsSuccessfulRequest
(
aRequest
&
status
)
;
if
(
status
=
=
NS_ERROR_BLOCKED_URI
)
{
nsCOMPtr
<
nsIConsoleService
>
console
(
do_GetService
(
"
mozilla
.
org
/
consoleservice
;
1
"
)
)
;
if
(
console
)
{
nsCOMPtr
<
nsIURI
>
uri
;
chan
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsString
message
=
NS_LITERAL_STRING
(
"
Blocking
"
)
+
NS_ConvertASCIItoUTF16
(
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
+
NS_LITERAL_STRING
(
"
since
it
was
found
on
an
internal
Firefox
blocklist
.
"
)
;
console
-
>
LogStringMessage
(
message
.
get
(
)
)
;
}
mContentBlockingEnabled
=
true
;
return
NS_ERROR_FAILURE
;
}
if
(
status
=
=
NS_ERROR_TRACKING_URI
)
{
mContentBlockingEnabled
=
true
;
return
NS_ERROR_FAILURE
;
}
if
(
!
success
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
OnStartRequest
:
Request
failed
\
n
"
this
)
)
;
mChannel
=
nullptr
;
LoadObject
(
true
false
)
;
return
NS_ERROR_FAILURE
;
}
return
LoadObject
(
true
false
aRequest
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsresult
aStatusCode
)
{
AUTO_PROFILER_LABEL
(
"
nsObjectLoadingContent
:
:
OnStopRequest
"
NETWORK
)
;
if
(
aStatusCode
=
=
NS_ERROR_TRACKING_URI
)
{
nsCOMPtr
<
nsIContent
>
thisNode
=
do_QueryInterface
(
static_cast
<
nsIObjectLoadingContent
*
>
(
this
)
)
;
if
(
thisNode
&
&
thisNode
-
>
IsInComposedDoc
(
)
)
{
thisNode
-
>
GetComposedDoc
(
)
-
>
AddBlockedTrackingNode
(
thisNode
)
;
}
}
if
(
aRequest
!
=
mChannel
)
{
return
NS_BINDING_ABORTED
;
}
mChannel
=
nullptr
;
if
(
mFinalListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listenerGrip
(
mFinalListener
)
;
mFinalListener
=
nullptr
;
listenerGrip
-
>
OnStopRequest
(
aRequest
aContext
aStatusCode
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsISupports
*
aContext
nsIInputStream
*
aInputStream
uint64_t
aOffset
uint32_t
aCount
)
{
if
(
aRequest
!
=
mChannel
)
{
return
NS_BINDING_ABORTED
;
}
if
(
mFinalListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listenerGrip
(
mFinalListener
)
;
return
listenerGrip
-
>
OnDataAvailable
(
aRequest
aContext
aInputStream
aOffset
aCount
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Got
data
for
channel
with
no
connected
final
"
"
listener
"
)
;
mChannel
=
nullptr
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
nsFrameLoader
>
)
nsObjectLoadingContent
:
:
GetFrameLoader
(
)
{
RefPtr
<
nsFrameLoader
>
loader
=
mFrameLoader
;
return
loader
.
forget
(
)
;
}
void
nsObjectLoadingContent
:
:
PresetOpenerWindow
(
const
Nullable
<
WindowProxyHolder
>
&
aOpenerWindow
ErrorResult
&
aRv
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
void
nsObjectLoadingContent
:
:
InternalSetFrameLoader
(
nsFrameLoader
*
aNewFrameLoader
)
{
MOZ_CRASH
(
"
You
shouldn
'
t
be
calling
this
function
it
doesn
'
t
make
any
sense
on
"
"
this
type
.
"
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetActualType
(
nsACString
&
aType
)
{
aType
=
mContentType
;
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetDisplayedType
(
uint32_t
*
aType
)
{
*
aType
=
DisplayedType
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
HasNewFrame
(
nsIObjectFrame
*
aFrame
)
{
if
(
mType
!
=
eType_Plugin
)
{
return
NS_OK
;
}
if
(
!
aFrame
)
{
if
(
mInstanceOwner
|
|
mInstantiating
)
{
if
(
mInstanceOwner
)
{
mInstanceOwner
-
>
SetFrame
(
nullptr
)
;
}
QueueCheckPluginStopEvent
(
)
;
}
return
NS_OK
;
}
if
(
!
mInstanceOwner
)
{
AsyncStartPluginInstance
(
)
;
return
NS_OK
;
}
nsPluginFrame
*
objFrame
=
static_cast
<
nsPluginFrame
*
>
(
aFrame
)
;
mInstanceOwner
-
>
SetFrame
(
objFrame
)
;
return
NS_OK
;
}
nsNPAPIPluginInstance
*
nsObjectLoadingContent
:
:
GetPluginInstance
(
)
{
if
(
!
mInstanceOwner
)
{
return
nullptr
;
}
return
mInstanceOwner
-
>
GetInstance
(
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetContentTypeForMIMEType
(
const
nsACString
&
aMIMEType
uint32_t
*
aType
)
{
*
aType
=
GetTypeOfContent
(
PromiseFlatCString
(
aMIMEType
)
false
)
;
return
NS_OK
;
}
class
ObjectInterfaceRequestorShim
final
:
public
nsIInterfaceRequestor
public
nsIChannelEventSink
public
nsIStreamListener
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS
(
ObjectInterfaceRequestorShim
nsIInterfaceRequestor
)
NS_DECL_NSIINTERFACEREQUESTOR
NS_FORWARD_NSICHANNELEVENTSINK
(
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
-
>
)
NS_FORWARD_NSISTREAMLISTENER
(
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
-
>
)
NS_FORWARD_NSIREQUESTOBSERVER
(
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
-
>
)
explicit
ObjectInterfaceRequestorShim
(
nsIObjectLoadingContent
*
aContent
)
:
mContent
(
aContent
)
{
}
protected
:
~
ObjectInterfaceRequestorShim
(
)
=
default
;
nsCOMPtr
<
nsIObjectLoadingContent
>
mContent
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
ObjectInterfaceRequestorShim
mContent
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
ObjectInterfaceRequestorShim
)
NS_INTERFACE_MAP_ENTRY
(
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_ENTRY
(
nsIChannelEventSink
)
NS_INTERFACE_MAP_ENTRY
(
nsIStreamListener
)
NS_INTERFACE_MAP_ENTRY
(
nsIRequestObserver
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIInterfaceRequestor
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
ObjectInterfaceRequestorShim
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
ObjectInterfaceRequestorShim
)
NS_IMETHODIMP
ObjectInterfaceRequestorShim
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsIChannelEventSink
)
)
)
{
nsIChannelEventSink
*
sink
=
this
;
*
aResult
=
sink
;
NS_ADDREF
(
sink
)
;
return
NS_OK
;
}
return
NS_NOINTERFACE
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
if
(
!
mChannel
|
|
aOldChannel
!
=
mChannel
)
{
return
NS_BINDING_ABORTED
;
}
mChannel
=
aNewChannel
;
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
return
NS_OK
;
}
EventStates
nsObjectLoadingContent
:
:
ObjectState
(
)
const
{
switch
(
mType
)
{
case
eType_Loading
:
return
NS_EVENT_STATE_LOADING
;
case
eType_Image
:
return
ImageState
(
)
;
case
eType_Plugin
:
case
eType_FakePlugin
:
case
eType_Document
:
return
EventStates
(
)
;
case
eType_Null
:
switch
(
mFallbackType
)
{
case
eFallbackSuppressed
:
return
NS_EVENT_STATE_SUPPRESSED
;
case
eFallbackUserDisabled
:
return
NS_EVENT_STATE_USERDISABLED
;
case
eFallbackClickToPlay
:
case
eFallbackClickToPlayQuiet
:
return
NS_EVENT_STATE_TYPE_CLICK_TO_PLAY
;
case
eFallbackDisabled
:
return
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_HANDLER_DISABLED
;
case
eFallbackBlocklisted
:
return
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_HANDLER_BLOCKED
;
case
eFallbackCrashed
:
return
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_HANDLER_CRASHED
;
case
eFallbackUnsupported
:
case
eFallbackOutdated
:
case
eFallbackAlternate
:
return
NS_EVENT_STATE_BROKEN
;
case
eFallbackVulnerableUpdatable
:
return
NS_EVENT_STATE_VULNERABLE_UPDATABLE
;
case
eFallbackVulnerableNoUpdate
:
return
NS_EVENT_STATE_VULNERABLE_NO_UPDATE
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
unknown
type
?
"
)
;
return
NS_EVENT_STATE_LOADING
;
}
void
nsObjectLoadingContent
:
:
MaybeRewriteYoutubeEmbed
(
nsIURI
*
aURI
nsIURI
*
aBaseURI
nsIURI
*
*
aOutURI
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
Must
be
an
instance
of
content
"
)
;
if
(
!
thisContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
embed
)
&
&
!
thisContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
object
)
)
{
return
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
NS_WARNING
(
"
Could
not
get
TLD
service
!
"
)
;
return
;
}
nsAutoCString
currentBaseDomain
;
bool
ok
=
NS_SUCCEEDED
(
tldService
-
>
GetBaseDomain
(
aURI
0
currentBaseDomain
)
)
;
if
(
!
ok
)
{
return
;
}
if
(
!
currentBaseDomain
.
EqualsLiteral
(
"
youtube
.
com
"
)
&
&
!
currentBaseDomain
.
EqualsLiteral
(
"
youtube
-
nocookie
.
com
"
)
)
{
return
;
}
nsAutoCString
path
;
aURI
-
>
GetPathQueryRef
(
path
)
;
if
(
!
StringBeginsWith
(
path
NS_LITERAL_CSTRING
(
"
/
v
/
"
)
)
)
{
return
;
}
nsAutoCString
uri
;
nsresult
rv
=
aURI
-
>
GetSpec
(
uri
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
int32_t
ampIndex
=
uri
.
FindChar
(
'
&
'
0
)
;
bool
replaceQuery
=
false
;
if
(
ampIndex
!
=
-
1
)
{
int32_t
qmIndex
=
uri
.
FindChar
(
'
?
'
0
)
;
if
(
qmIndex
=
=
-
1
|
|
qmIndex
>
ampIndex
)
{
replaceQuery
=
true
;
}
}
if
(
!
Preferences
:
:
GetBool
(
kPrefYoutubeRewrite
)
)
{
return
;
}
nsAutoString
utf16OldURI
=
NS_ConvertUTF8toUTF16
(
uri
)
;
if
(
replaceQuery
)
{
uri
.
ReplaceChar
(
'
?
'
'
&
'
)
;
uri
.
SetCharAt
(
'
?
'
ampIndex
)
;
}
uri
.
ReplaceSubstring
(
NS_LITERAL_CSTRING
(
"
/
v
/
"
)
NS_LITERAL_CSTRING
(
"
/
embed
/
"
)
)
;
nsAutoString
utf16URI
=
NS_ConvertUTF8toUTF16
(
uri
)
;
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
aOutURI
utf16URI
thisContent
-
>
OwnerDoc
(
)
aBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
const
char16_t
*
params
[
]
=
{
utf16OldURI
.
get
(
)
utf16URI
.
get
(
)
}
;
const
char
*
msgName
;
if
(
!
replaceQuery
)
{
msgName
=
"
RewriteYouTubeEmbed
"
;
}
else
{
msgName
=
"
RewriteYouTubeEmbedPathParams
"
;
}
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Plugins
"
)
thisContent
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eDOM_PROPERTIES
msgName
params
ArrayLength
(
params
)
)
;
}
bool
nsObjectLoadingContent
:
:
CheckLoadPolicy
(
int16_t
*
aContentPolicy
)
{
if
(
!
aContentPolicy
|
|
!
mURI
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Doing
it
wrong
"
)
;
return
false
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
Must
be
an
instance
of
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
nsContentPolicyType
contentPolicyType
=
GetContentPolicyType
(
)
;
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
doc
-
>
NodePrincipal
(
)
doc
-
>
NodePrincipal
(
)
thisContent
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
contentPolicyType
)
;
*
aContentPolicy
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
mURI
secCheckLoadInfo
mContentType
aContentPolicy
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
NS_CP_REJECTED
(
*
aContentPolicy
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Content
policy
denied
load
of
%
s
"
this
mURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
return
false
;
}
return
true
;
}
bool
nsObjectLoadingContent
:
:
CheckProcessPolicy
(
int16_t
*
aContentPolicy
)
{
if
(
!
aContentPolicy
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Null
out
variable
"
)
;
return
false
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
Must
be
an
instance
of
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
int32_t
objectType
;
switch
(
mType
)
{
case
eType_Image
:
objectType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
;
break
;
case
eType_Document
:
objectType
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
;
break
;
case
eType_FakePlugin
:
case
eType_Plugin
:
objectType
=
GetContentPolicyType
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Calling
checkProcessPolicy
with
an
unloadable
"
"
type
"
)
;
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
LoadInfo
(
doc
-
>
NodePrincipal
(
)
doc
-
>
NodePrincipal
(
)
thisContent
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
objectType
)
;
*
aContentPolicy
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentProcessPolicy
(
mURI
?
mURI
:
mBaseURI
secCheckLoadInfo
mContentType
aContentPolicy
nsContentUtils
:
:
GetContentPolicy
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
NS_CP_REJECTED
(
*
aContentPolicy
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
CheckContentProcessPolicy
rejected
load
"
this
)
)
;
return
false
;
}
return
true
;
}
nsObjectLoadingContent
:
:
ParameterUpdateFlags
nsObjectLoadingContent
:
:
UpdateObjectParameters
(
)
{
nsCOMPtr
<
Element
>
thisElement
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
MOZ_ASSERT
(
thisElement
"
Must
be
an
Element
"
)
;
uint32_t
caps
=
GetCapabilities
(
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Updating
object
parameters
"
this
)
)
;
nsresult
rv
;
nsAutoCString
newMime
;
nsAutoString
typeAttr
;
nsCOMPtr
<
nsIURI
>
newURI
;
nsCOMPtr
<
nsIURI
>
newBaseURI
;
ObjectType
newType
;
bool
stateInvalid
=
false
;
nsObjectLoadingContent
:
:
ParameterUpdateFlags
retval
=
eParamNoChange
;
if
(
caps
&
eFallbackIfClassIDPresent
)
{
nsAutoString
classIDAttr
;
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
classid
classIDAttr
)
;
if
(
!
classIDAttr
.
IsEmpty
(
)
)
{
newMime
.
Truncate
(
)
;
stateInvalid
=
true
;
}
}
nsAutoString
codebaseStr
;
nsCOMPtr
<
nsIURI
>
docBaseURI
=
thisElement
-
>
GetBaseURI
(
)
;
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
codebase
codebaseStr
)
;
if
(
!
codebaseStr
.
IsEmpty
(
)
)
{
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
newBaseURI
)
codebaseStr
thisElement
-
>
OwnerDoc
(
)
docBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Could
not
parse
plugin
'
s
codebase
as
a
URI
"
"
will
use
document
baseURI
instead
"
this
)
)
;
}
}
nsAutoString
rawTypeAttr
;
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
rawTypeAttr
)
;
if
(
!
rawTypeAttr
.
IsEmpty
(
)
)
{
typeAttr
=
rawTypeAttr
;
nsAutoString
params
;
nsAutoString
mime
;
nsContentUtils
:
:
SplitMimeType
(
rawTypeAttr
mime
params
)
;
CopyUTF16toUTF8
(
mime
newMime
)
;
}
if
(
!
newBaseURI
)
{
newBaseURI
=
docBaseURI
;
}
nsAutoString
uriStr
;
if
(
thisElement
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
object
)
)
{
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
data
uriStr
)
;
}
else
if
(
thisElement
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
embed
)
)
{
thisElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
uriStr
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
plugin
-
loading
tag
"
)
;
}
mRewrittenYoutubeEmbed
=
false
;
if
(
!
uriStr
.
IsEmpty
(
)
)
{
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
newURI
)
uriStr
thisElement
-
>
OwnerDoc
(
)
newBaseURI
)
;
nsCOMPtr
<
nsIURI
>
rewrittenURI
;
MaybeRewriteYoutubeEmbed
(
newURI
newBaseURI
getter_AddRefs
(
rewrittenURI
)
)
;
if
(
rewrittenURI
)
{
newURI
=
rewrittenURI
;
mRewrittenYoutubeEmbed
=
true
;
newMime
=
NS_LITERAL_CSTRING
(
"
text
/
html
"
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
stateInvalid
=
true
;
}
}
if
(
!
IsPluginType
(
GetTypeOfContent
(
newMime
mSkipFakePlugins
)
)
&
&
newURI
&
&
(
caps
&
eAllowPluginSkipChannel
)
&
&
IsPluginEnabledByExtension
(
newURI
newMime
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
extension
as
type
hint
(
%
s
)
"
this
newMime
.
get
(
)
)
)
;
}
if
(
(
mOriginalContentType
!
=
newMime
)
|
|
!
URIEquals
(
mOriginalURI
newURI
)
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamChannelChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
parameters
changed
"
this
)
)
;
}
mOriginalContentType
=
newMime
;
mOriginalURI
=
newURI
;
bool
useChannel
=
mChannelLoaded
&
&
!
(
retval
&
eParamChannelChanged
)
;
bool
newChannel
=
useChannel
&
&
mType
=
=
eType_Loading
;
if
(
newChannel
&
&
mChannel
)
{
nsCString
channelType
;
rv
=
mChannel
-
>
GetContentType
(
channelType
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
GetContentType
failed
"
)
;
stateInvalid
=
true
;
channelType
.
Truncate
(
)
;
}
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
has
a
content
type
of
%
s
"
this
channelType
.
get
(
)
)
)
;
bool
binaryChannelType
=
false
;
if
(
channelType
.
EqualsASCII
(
APPLICATION_GUESS_FROM_EXT
)
)
{
channelType
=
APPLICATION_OCTET_STREAM
;
mChannel
-
>
SetContentType
(
channelType
)
;
binaryChannelType
=
true
;
}
else
if
(
channelType
.
EqualsASCII
(
APPLICATION_OCTET_STREAM
)
|
|
channelType
.
EqualsASCII
(
BINARY_OCTET_STREAM
)
)
{
binaryChannelType
=
true
;
}
rv
=
NS_GetFinalChannelURI
(
mChannel
getter_AddRefs
(
newURI
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
NS_GetFinalChannelURI
failure
"
)
;
stateInvalid
=
true
;
}
ObjectType
typeHint
=
newMime
.
IsEmpty
(
)
?
eType_Null
:
GetTypeOfContent
(
newMime
mSkipFakePlugins
)
;
bool
overrideChannelType
=
false
;
if
(
thisElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
typemustmatch
)
)
{
if
(
!
typeAttr
.
LowerCaseEqualsASCII
(
channelType
.
get
(
)
)
)
{
stateInvalid
=
true
;
}
}
else
if
(
IsPluginType
(
typeHint
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
plugin
type
hint
in
favor
of
any
channel
type
"
this
)
)
;
overrideChannelType
=
true
;
}
else
if
(
(
caps
&
eAllowPluginSkipChannel
)
&
&
IsPluginEnabledByExtension
(
newURI
newMime
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
extension
as
type
hint
for
"
"
eAllowPluginSkipChannel
tag
(
%
s
)
"
this
newMime
.
get
(
)
)
)
;
overrideChannelType
=
true
;
}
else
if
(
binaryChannelType
&
&
typeHint
!
=
eType_Null
&
&
typeHint
!
=
eType_Document
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
type
hint
in
favor
of
binary
channel
type
"
this
)
)
;
overrideChannelType
=
true
;
}
else
if
(
binaryChannelType
&
&
IsPluginEnabledByExtension
(
newURI
newMime
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
extension
as
type
hint
for
binary
channel
(
%
s
)
"
this
newMime
.
get
(
)
)
)
;
overrideChannelType
=
true
;
}
if
(
overrideChannelType
)
{
nsAutoCString
parsedMime
dummy
;
NS_ParseResponseContentType
(
newMime
parsedMime
dummy
)
;
if
(
!
parsedMime
.
IsEmpty
(
)
)
{
mChannel
-
>
SetContentType
(
parsedMime
)
;
}
}
else
{
newMime
=
channelType
;
}
}
else
if
(
newChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
We
failed
to
open
a
channel
marking
invalid
"
this
)
)
;
stateInvalid
=
true
;
}
ObjectType
newMime_Type
=
GetTypeOfContent
(
newMime
mSkipFakePlugins
)
;
if
(
stateInvalid
)
{
newType
=
eType_Null
;
newMime
.
Truncate
(
)
;
}
else
if
(
newChannel
)
{
newType
=
newMime_Type
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Using
channel
type
"
this
)
)
;
}
else
if
(
(
(
caps
&
eAllowPluginSkipChannel
)
|
|
!
newURI
)
&
&
IsPluginType
(
newMime_Type
)
)
{
newType
=
newMime_Type
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Plugin
type
with
no
URI
skipping
channel
load
"
this
)
)
;
}
else
if
(
newURI
&
&
(
mOriginalContentType
.
IsEmpty
(
)
|
|
newMime_Type
!
=
eType_Null
)
)
{
newType
=
eType_Loading
;
}
else
{
newType
=
eType_Null
;
}
if
(
useChannel
&
&
newType
=
=
eType_Loading
)
{
newType
=
mType
;
newMime
=
mContentType
;
newURI
=
mURI
;
}
else
if
(
useChannel
&
&
!
newChannel
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamChannelChanged
)
;
useChannel
=
false
;
}
if
(
newType
!
=
mType
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamStateChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Type
changed
from
%
u
-
>
%
u
"
this
mType
newType
)
)
;
bool
updateIMEState
=
(
mType
=
=
eType_Loading
&
&
newType
=
=
eType_Plugin
)
;
mType
=
newType
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
MOZ_ASSERT
(
thisContent
"
should
have
content
"
)
;
if
(
updateIMEState
&
&
thisContent
&
&
fm
&
&
fm
-
>
IsFocused
(
thisContent
)
)
{
widget
:
:
IMEState
state
;
state
.
mEnabled
=
widget
:
:
IMEState
:
:
PLUGIN
;
state
.
mOpen
=
widget
:
:
IMEState
:
:
DONT_CHANGE_OPEN_STATE
;
IMEStateManager
:
:
UpdateIMEState
(
state
thisContent
nullptr
)
;
}
}
if
(
!
URIEquals
(
mBaseURI
newBaseURI
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Object
effective
baseURI
changed
"
this
)
)
;
mBaseURI
=
newBaseURI
;
}
if
(
!
URIEquals
(
newURI
mURI
)
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamStateChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Object
effective
URI
changed
"
this
)
)
;
mURI
=
newURI
;
}
if
(
mType
!
=
eType_Loading
&
&
mContentType
!
=
newMime
)
{
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamStateChanged
)
;
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamContentTypeChanged
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Object
effective
mime
type
changed
(
%
s
-
>
%
s
)
"
this
mContentType
.
get
(
)
newMime
.
get
(
)
)
)
;
mContentType
=
newMime
;
}
if
(
useChannel
&
&
!
newChannel
&
&
(
retval
&
eParamStateChanged
)
)
{
mType
=
eType_Loading
;
retval
=
(
ParameterUpdateFlags
)
(
retval
|
eParamChannelChanged
)
;
}
return
retval
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
InitializeFromChannel
(
nsIRequest
*
aChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
InitializeFromChannel
:
%
p
"
this
aChannel
)
)
;
if
(
mType
!
=
eType_Loading
|
|
mChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
not
have
begun
loading
at
this
point
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
UpdateObjectParameters
(
)
;
mType
=
eType_Loading
;
mChannel
=
do_QueryInterface
(
aChannel
)
;
NS_ASSERTION
(
mChannel
"
passed
a
request
that
is
not
a
channel
"
)
;
return
NS_OK
;
}
nsresult
nsObjectLoadingContent
:
:
LoadObject
(
bool
aNotify
bool
aForceLoad
)
{
return
LoadObject
(
aNotify
aForceLoad
nullptr
)
;
}
nsresult
nsObjectLoadingContent
:
:
LoadObject
(
bool
aNotify
bool
aForceLoad
nsIRequest
*
aLoadingChannel
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
nsresult
rv
=
NS_OK
;
if
(
!
doc
-
>
IsCurrentActiveDocument
(
)
)
{
UnloadObject
(
)
;
LoadFallback
(
eFallbackAlternate
false
)
;
return
NS_OK
;
}
if
(
doc
-
>
IsBeingUsedAsImage
(
)
|
|
doc
-
>
IsLoadedAsData
(
)
)
{
return
NS_OK
;
}
LOG
(
(
"
OBJLC
[
%
p
]
:
LoadObject
called
notify
%
u
forceload
%
u
channel
%
p
"
this
aNotify
aForceLoad
aLoadingChannel
)
)
;
if
(
aForceLoad
&
&
mChannelLoaded
)
{
CloseChannel
(
)
;
mChannelLoaded
=
false
;
}
EventStates
oldState
=
ObjectState
(
)
;
ObjectType
oldType
=
mType
;
ParameterUpdateFlags
stateChange
=
UpdateObjectParameters
(
)
;
if
(
!
stateChange
&
&
!
aForceLoad
)
{
return
NS_OK
;
}
LOG
(
(
"
OBJLC
[
%
p
]
:
LoadObject
-
plugin
state
changed
(
%
u
)
"
this
stateChange
)
)
;
FallbackType
fallbackType
=
eFallbackAlternate
;
if
(
mType
=
=
eType_Null
&
&
GetTypeOfContent
(
mContentType
mSkipFakePlugins
)
=
=
eType_Null
)
{
fallbackType
=
eFallbackUnsupported
;
}
if
(
mActivated
&
&
(
stateChange
&
eParamContentTypeChanged
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Content
type
changed
clearing
activation
state
"
this
)
)
;
mActivated
=
false
;
}
if
(
mIsLoading
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Re
-
entering
into
LoadObject
"
this
)
)
;
}
mIsLoading
=
true
;
AutoSetLoadingToFalse
reentryCheck
(
this
)
;
UnloadObject
(
false
)
;
if
(
!
mIsLoading
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Re
-
entered
into
LoadObject
aborting
outer
load
"
this
)
)
;
return
NS_OK
;
}
if
(
stateChange
&
eParamChannelChanged
)
{
CloseChannel
(
)
;
mChannelLoaded
=
false
;
}
else
if
(
mType
=
=
eType_Null
&
&
mChannel
)
{
CloseChannel
(
)
;
}
else
if
(
mType
=
=
eType_Loading
&
&
mChannel
)
{
return
NS_OK
;
}
else
if
(
mChannelLoaded
&
&
mChannel
!
=
aLoadingChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Loading
with
a
channel
but
state
doesn
'
t
make
sense
"
)
;
return
NS_OK
;
}
if
(
mType
!
=
eType_Null
)
{
bool
allowLoad
=
true
;
int16_t
contentPolicy
=
nsIContentPolicy
:
:
ACCEPT
;
if
(
allowLoad
&
&
mURI
&
&
!
mChannelLoaded
&
&
mType
!
=
eType_Loading
)
{
allowLoad
=
CheckLoadPolicy
(
&
contentPolicy
)
;
}
if
(
allowLoad
&
&
mType
!
=
eType_Loading
)
{
allowLoad
=
CheckProcessPolicy
(
&
contentPolicy
)
;
}
if
(
!
mIsLoading
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
We
re
-
entered
in
content
policy
leaving
original
load
"
this
)
)
;
return
NS_OK
;
}
if
(
!
allowLoad
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Load
denied
by
policy
"
this
)
)
;
mType
=
eType_Null
;
if
(
contentPolicy
=
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
fallbackType
=
eFallbackUserDisabled
;
}
else
{
fallbackType
=
eFallbackSuppressed
;
}
}
}
if
(
mType
!
=
eType_Null
)
{
nsCOMPtr
<
nsIURI
>
tempURI
=
mURI
;
nsCOMPtr
<
nsINestedURI
>
nestedURI
=
do_QueryInterface
(
tempURI
)
;
while
(
nestedURI
)
{
bool
isViewSource
=
false
;
rv
=
tempURI
-
>
SchemeIs
(
"
view
-
source
"
&
isViewSource
)
;
if
(
NS_FAILED
(
rv
)
|
|
isViewSource
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Blocking
as
effective
URI
has
view
-
source
scheme
"
this
)
)
;
mType
=
eType_Null
;
break
;
}
nestedURI
-
>
GetInnerURI
(
getter_AddRefs
(
tempURI
)
)
;
nestedURI
=
do_QueryInterface
(
tempURI
)
;
}
}
if
(
(
mType
=
=
eType_Null
|
|
IsPluginType
(
mType
)
)
&
&
ShouldBlockContent
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Enable
content
blocking
"
this
)
)
;
mType
=
eType_Loading
;
}
FallbackType
clickToPlayReason
;
if
(
!
mActivated
&
&
IsPluginType
(
mType
)
&
&
!
ShouldPlay
(
clickToPlayReason
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Marking
plugin
as
click
-
to
-
play
"
this
)
)
;
mType
=
eType_Null
;
fallbackType
=
clickToPlayReason
;
}
if
(
!
mActivated
&
&
IsPluginType
(
mType
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Object
implicitly
activated
"
this
)
)
;
mActivated
=
true
;
}
if
(
mFrameLoader
|
|
mPendingInstantiateEvent
|
|
mInstanceOwner
|
|
mPendingCheckPluginStopEvent
|
|
mFinalListener
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
load
new
plugin
with
existing
content
"
)
;
return
NS_OK
;
}
if
(
mType
!
=
eType_Null
&
&
!
!
mChannel
!
=
mChannelLoaded
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Trying
to
load
with
bad
channel
state
"
)
;
return
NS_OK
;
}
if
(
mType
=
=
eType_Plugin
|
|
mType
=
=
eType_Null
)
{
rv
=
BuildParametersArray
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIStreamListener
>
finalListener
;
bool
doSpawnPlugin
=
false
;
switch
(
mType
)
{
case
eType_Image
:
if
(
!
mChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Attempting
to
load
image
without
a
channel
?
"
)
;
rv
=
NS_ERROR_UNEXPECTED
;
break
;
}
rv
=
LoadImageWithChannel
(
mChannel
getter_AddRefs
(
finalListener
)
)
;
break
;
case
eType_Plugin
:
{
if
(
mChannel
)
{
NotifyStateChanged
(
oldType
oldState
true
aNotify
)
;
oldType
=
mType
;
oldState
=
ObjectState
(
)
;
if
(
!
thisContent
-
>
GetPrimaryFrame
(
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Aborting
load
-
plugin
-
type
but
no
frame
"
this
)
)
;
CloseChannel
(
)
;
break
;
}
doSpawnPlugin
=
true
;
}
else
{
rv
=
AsyncStartPluginInstance
(
)
;
}
}
break
;
case
eType_FakePlugin
:
{
if
(
mChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Closing
unused
channel
for
fake
plugin
type
"
this
)
)
;
CloseChannel
(
)
;
}
nsCOMPtr
<
nsIPluginTag
>
basetag
=
nsContentUtils
:
:
PluginTagForType
(
mContentType
false
)
;
nsCOMPtr
<
nsIFakePluginTag
>
tag
=
do_QueryInterface
(
basetag
)
;
uint32_t
id
;
if
(
NS_FAILED
(
tag
-
>
GetId
(
&
id
)
)
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
MOZ_ASSERT
(
id
<
=
PR_INT32_MAX
"
Something
went
wrong
nsPluginHost
:
:
RegisterFakePlugin
"
"
shouldn
'
t
have
"
"
given
out
this
id
.
"
)
;
SetupFrameLoader
(
int32_t
(
id
)
)
;
if
(
!
mFrameLoader
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
nsString
sandboxScript
;
tag
-
>
GetSandboxScript
(
sandboxScript
)
;
if
(
!
sandboxScript
.
IsEmpty
(
)
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
sandbox
(
jsapi
.
cx
(
)
)
;
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
CreateSandbox
(
jsapi
.
cx
(
)
nsContentUtils
:
:
GetSystemPrincipal
(
)
sandbox
.
address
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
AutoEntryScript
aes
(
sandbox
"
JS
plugin
sandbox
code
"
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
element
(
aes
.
cx
(
)
)
;
if
(
!
ToJSValue
(
aes
.
cx
(
)
thisContent
&
element
)
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
if
(
!
JS_DefineProperty
(
aes
.
cx
(
)
sandbox
"
pluginElement
"
element
JSPROP_ENUMERATE
)
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
aes
.
cx
(
)
)
;
rv
=
nsContentUtils
:
:
XPConnect
(
)
-
>
EvalInSandboxObject
(
sandboxScript
nullptr
aes
.
cx
(
)
sandbox
&
rval
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
}
nsCOMPtr
<
nsIURI
>
handlerURI
;
if
(
tag
)
{
tag
-
>
GetHandlerURI
(
getter_AddRefs
(
handlerURI
)
)
;
}
if
(
!
handlerURI
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Selected
type
is
not
a
proper
fake
plugin
"
"
handler
"
)
;
rv
=
NS_ERROR_FAILURE
;
break
;
}
nsCString
spec
;
handlerURI
-
>
GetSpec
(
spec
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Loading
fake
plugin
handler
(
%
s
)
"
this
spec
.
get
(
)
)
)
;
rv
=
mFrameLoader
-
>
LoadURI
(
handlerURI
thisContent
-
>
AsElement
(
)
-
>
NodePrincipal
(
)
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
LoadURI
(
)
failed
for
fake
handler
"
this
)
)
;
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
}
}
break
;
case
eType_Document
:
{
if
(
!
mChannel
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Attempting
to
load
a
document
without
a
"
"
channel
"
)
;
rv
=
NS_ERROR_FAILURE
;
break
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
SetupDocShell
(
mURI
)
;
if
(
!
docShell
)
{
rv
=
NS_ERROR_FAILURE
;
break
;
}
nsLoadFlags
flags
=
0
;
mChannel
-
>
GetLoadFlags
(
&
flags
)
;
flags
|
=
nsIChannel
:
:
LOAD_DOCUMENT_URI
;
mChannel
-
>
SetLoadFlags
(
flags
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
req
(
do_QueryInterface
(
docShell
)
)
;
NS_ASSERTION
(
req
"
Docshell
must
be
an
ifreq
"
)
;
nsCOMPtr
<
nsIURILoader
>
uriLoader
(
do_GetService
(
NS_URI_LOADER_CONTRACTID
&
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Failed
to
get
uriLoader
service
"
)
;
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
break
;
}
rv
=
uriLoader
-
>
OpenChannel
(
mChannel
nsIURILoader
:
:
DONT_RETARGET
req
getter_AddRefs
(
finalListener
)
)
;
}
break
;
case
eType_Loading
:
rv
=
OpenChannel
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
OpenChannel
returned
failure
(
%
"
PRIu32
"
)
"
this
static_cast
<
uint32_t
>
(
rv
)
)
)
;
}
break
;
case
eType_Null
:
break
;
}
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Loading
failed
switching
to
fallback
"
this
)
)
;
mType
=
eType_Null
;
}
if
(
mType
=
=
eType_Null
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Loading
fallback
type
%
u
"
this
fallbackType
)
)
;
NS_ASSERTION
(
!
mFrameLoader
&
&
!
mInstanceOwner
"
switched
to
type
null
but
also
loaded
something
"
)
;
if
(
fallbackType
!
=
eFallbackClickToPlay
&
&
fallbackType
!
=
eFallbackClickToPlayQuiet
)
{
MaybeFireErrorEvent
(
)
;
}
if
(
mChannel
)
{
CloseChannel
(
)
;
}
doSpawnPlugin
=
false
;
finalListener
=
nullptr
;
LoadFallback
(
fallbackType
false
)
;
}
NotifyStateChanged
(
oldType
oldState
false
aNotify
)
;
NS_ENSURE_TRUE
(
mIsLoading
NS_OK
)
;
rv
=
NS_OK
;
if
(
doSpawnPlugin
)
{
rv
=
InstantiatePluginInstance
(
true
)
;
NS_ENSURE_TRUE
(
mIsLoading
NS_OK
)
;
if
(
aLoadingChannel
&
&
NS_SUCCEEDED
(
rv
)
)
{
if
(
NS_SUCCEEDED
(
rv
)
&
&
MakePluginListener
(
)
)
{
rv
=
mFinalListener
-
>
OnStartRequest
(
mChannel
nullptr
)
;
if
(
NS_FAILED
(
rv
)
)
{
CloseChannel
(
)
;
NS_ENSURE_TRUE
(
mIsLoading
NS_OK
)
;
rv
=
NS_OK
;
}
}
}
}
else
if
(
finalListener
)
{
NS_ASSERTION
(
mType
!
=
eType_Null
&
&
mType
!
=
eType_Loading
"
We
should
not
have
a
final
listener
with
a
non
-
loaded
type
"
)
;
mFinalListener
=
finalListener
;
rv
=
finalListener
-
>
OnStartRequest
(
mChannel
nullptr
)
;
}
if
(
NS_FAILED
(
rv
)
&
&
mIsLoading
)
{
mType
=
eType_Null
;
UnloadObject
(
false
)
;
NS_ENSURE_TRUE
(
mIsLoading
NS_OK
)
;
CloseChannel
(
)
;
LoadFallback
(
fallbackType
true
)
;
}
return
NS_OK
;
}
nsresult
nsObjectLoadingContent
:
:
CloseChannel
(
)
{
if
(
mChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Closing
channel
\
n
"
this
)
)
;
nsCOMPtr
<
nsIChannel
>
channelGrip
(
mChannel
)
;
nsCOMPtr
<
nsIStreamListener
>
listenerGrip
(
mFinalListener
)
;
mChannel
=
nullptr
;
mFinalListener
=
nullptr
;
channelGrip
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
if
(
listenerGrip
)
{
listenerGrip
-
>
OnStopRequest
(
channelGrip
nullptr
NS_BINDING_ABORTED
)
;
}
}
return
NS_OK
;
}
nsresult
nsObjectLoadingContent
:
:
OpenChannel
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
NS_ASSERTION
(
doc
"
No
owner
document
?
"
)
;
nsresult
rv
;
mChannel
=
nullptr
;
if
(
!
mURI
|
|
!
CanHandleURI
(
mURI
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsILoadGroup
>
group
=
doc
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsIChannel
>
chan
;
RefPtr
<
ObjectInterfaceRequestorShim
>
shim
=
new
ObjectInterfaceRequestorShim
(
this
)
;
bool
isSandBoxed
=
doc
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
;
bool
inherit
=
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
thisContent
-
>
NodePrincipal
(
)
mURI
true
false
)
;
nsSecurityFlags
securityFlags
=
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
;
bool
isData
;
bool
isURIUniqueOrigin
=
nsIOService
:
:
IsDataURIUniqueOpaqueOrigin
(
)
&
&
NS_SUCCEEDED
(
mURI
-
>
SchemeIs
(
"
data
"
&
isData
)
)
&
&
isData
;
if
(
inherit
&
&
!
isURIUniqueOrigin
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_FORCE_INHERIT_PRINCIPAL
;
}
if
(
isSandBoxed
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_SANDBOXED
;
}
nsContentPolicyType
contentPolicyType
=
GetContentPolicyType
(
)
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
chan
)
mURI
thisContent
securityFlags
contentPolicyType
nullptr
group
shim
nsIChannel
:
:
LOAD_CALL_CONTENT_SNIFFERS
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
|
nsIChannel
:
:
LOAD_BYPASS_SERVICE_WORKER
|
nsIRequest
:
:
LOAD_HTML_OBJECT_DATA
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
inherit
)
{
nsCOMPtr
<
nsILoadInfo
>
loadinfo
=
chan
-
>
GetLoadInfo
(
)
;
NS_ENSURE_STATE
(
loadinfo
)
;
loadinfo
-
>
SetPrincipalToInherit
(
thisContent
-
>
NodePrincipal
(
)
)
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChan
(
do_QueryInterface
(
chan
)
)
;
if
(
httpChan
)
{
rv
=
httpChan
-
>
SetReferrerWithPolicy
(
doc
-
>
GetDocumentURI
(
)
doc
-
>
GetReferrerPolicy
(
)
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChan
)
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
thisContent
-
>
LocalName
(
)
)
;
}
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
httpChan
)
)
;
if
(
cos
&
&
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
UrgentStart
)
;
}
}
nsCOMPtr
<
nsIScriptChannel
>
scriptChannel
=
do_QueryInterface
(
chan
)
;
if
(
scriptChannel
)
{
scriptChannel
-
>
SetExecutionPolicy
(
nsIScriptChannel
:
:
EXECUTE_NORMAL
)
;
}
rv
=
chan
-
>
AsyncOpen2
(
shim
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Channel
opened
"
this
)
)
;
mChannel
=
chan
;
return
NS_OK
;
}
uint32_t
nsObjectLoadingContent
:
:
GetCapabilities
(
)
const
{
return
eSupportImages
|
eSupportPlugins
|
eSupportDocuments
;
}
void
nsObjectLoadingContent
:
:
DestroyContent
(
)
{
if
(
mFrameLoader
)
{
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
}
if
(
mInstanceOwner
|
|
mInstantiating
)
{
QueueCheckPluginStopEvent
(
)
;
}
}
void
nsObjectLoadingContent
:
:
Traverse
(
nsObjectLoadingContent
*
tmp
nsCycleCollectionTraversalCallback
&
cb
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFrameLoader
)
;
}
void
nsObjectLoadingContent
:
:
UnloadObject
(
bool
aResetState
)
{
CancelImageRequests
(
false
)
;
if
(
mFrameLoader
)
{
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
}
if
(
aResetState
)
{
if
(
mType
!
=
eType_Plugin
)
{
CloseChannel
(
)
;
}
mChannelLoaded
=
false
;
mType
=
eType_Loading
;
mURI
=
mOriginalURI
=
mBaseURI
=
nullptr
;
mContentType
.
Truncate
(
)
;
mOriginalContentType
.
Truncate
(
)
;
}
mInstantiating
=
false
;
mScriptRequested
=
false
;
if
(
mIsStopping
)
{
TeardownProtoChain
(
)
;
mIsStopping
=
false
;
}
mCachedAttributes
.
Clear
(
)
;
mCachedParameters
.
Clear
(
)
;
StopPluginInstance
(
)
;
}
void
nsObjectLoadingContent
:
:
NotifyStateChanged
(
ObjectType
aOldType
EventStates
aOldState
bool
aSync
bool
aNotify
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Notifying
about
state
change
:
(
%
u
%
"
PRIx64
"
)
-
>
(
%
u
%
"
PRIx64
"
)
"
"
(
sync
%
i
notify
%
i
)
"
this
aOldType
aOldState
.
GetInternalValue
(
)
mType
ObjectState
(
)
.
GetInternalValue
(
)
aSync
aNotify
)
)
;
nsCOMPtr
<
dom
:
:
Element
>
thisEl
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
MOZ_ASSERT
(
thisEl
"
must
be
an
element
"
)
;
thisEl
-
>
UpdateState
(
false
)
;
if
(
!
aNotify
)
{
return
;
}
Document
*
doc
=
thisEl
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
EventStates
newState
=
ObjectState
(
)
;
if
(
newState
=
=
aOldState
&
&
mType
=
=
aOldType
)
{
return
;
}
if
(
newState
!
=
aOldState
)
{
MOZ_ASSERT
(
thisEl
-
>
IsInComposedDoc
(
)
"
Something
is
confused
"
)
;
EventStates
changedBits
=
aOldState
^
newState
;
{
nsAutoScriptBlocker
scriptBlocker
;
doc
-
>
ContentStateChanged
(
thisEl
changedBits
)
;
}
if
(
nsContentUtils
:
:
IsUAWidgetEnabled
(
)
)
{
const
EventStates
pluginProblemState
=
NS_EVENT_STATE_HANDLER_BLOCKED
|
NS_EVENT_STATE_HANDLER_CRASHED
|
NS_EVENT_STATE_TYPE_CLICK_TO_PLAY
|
NS_EVENT_STATE_VULNERABLE_UPDATABLE
|
NS_EVENT_STATE_VULNERABLE_NO_UPDATE
;
bool
hadProblemState
=
!
(
aOldState
&
pluginProblemState
)
.
IsEmpty
(
)
;
bool
hasProblemState
=
!
(
newState
&
pluginProblemState
)
.
IsEmpty
(
)
;
if
(
hadProblemState
&
&
!
hasProblemState
)
{
thisEl
-
>
NotifyUAWidgetTeardown
(
)
;
}
else
if
(
!
hadProblemState
&
&
hasProblemState
)
{
thisEl
-
>
AttachAndSetUAShadowRoot
(
)
;
thisEl
-
>
NotifyUAWidgetSetupOrChange
(
)
;
}
}
}
else
if
(
aOldType
!
=
mType
)
{
nsCOMPtr
<
nsIPresShell
>
shell
=
doc
-
>
GetShell
(
)
;
if
(
shell
)
{
shell
-
>
PostRecreateFramesFor
(
thisEl
)
;
}
}
if
(
aSync
)
{
MOZ_ASSERT
(
InActiveDocument
(
thisEl
)
"
Something
is
confused
"
)
;
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
}
nsObjectLoadingContent
:
:
ObjectType
nsObjectLoadingContent
:
:
GetTypeOfContent
(
const
nsCString
&
aMIMEType
bool
aNoFakePlugin
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
ObjectType
type
=
static_cast
<
ObjectType
>
(
nsContentUtils
:
:
HtmlObjectContentTypeForMIMEType
(
aMIMEType
aNoFakePlugin
thisContent
)
)
;
uint32_t
caps
=
GetCapabilities
(
)
;
if
(
!
(
caps
&
eSupportImages
)
&
&
type
=
=
eType_Image
)
{
type
=
eType_Null
;
}
if
(
!
(
caps
&
eSupportDocuments
)
&
&
type
=
=
eType_Document
)
{
type
=
eType_Null
;
}
if
(
!
(
caps
&
eSupportPlugins
)
&
&
(
type
=
=
eType_Plugin
|
|
type
=
=
eType_FakePlugin
)
)
{
type
=
eType_Null
;
}
return
type
;
}
nsPluginFrame
*
nsObjectLoadingContent
:
:
GetExistingFrame
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
nsIFrame
*
frame
=
thisContent
-
>
GetPrimaryFrame
(
)
;
nsIObjectFrame
*
objFrame
=
do_QueryFrame
(
frame
)
;
return
static_cast
<
nsPluginFrame
*
>
(
objFrame
)
;
}
void
nsObjectLoadingContent
:
:
CreateStaticClone
(
nsObjectLoadingContent
*
aDest
)
const
{
nsImageLoadingContent
:
:
CreateStaticImageClone
(
aDest
)
;
aDest
-
>
mType
=
mType
;
nsObjectLoadingContent
*
thisObj
=
const_cast
<
nsObjectLoadingContent
*
>
(
this
)
;
if
(
thisObj
-
>
mPrintFrame
.
IsAlive
(
)
)
{
aDest
-
>
mPrintFrame
=
thisObj
-
>
mPrintFrame
;
}
else
{
aDest
-
>
mPrintFrame
=
const_cast
<
nsObjectLoadingContent
*
>
(
this
)
-
>
GetExistingFrame
(
)
;
}
if
(
mFrameLoader
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
aDest
)
)
;
nsFrameLoader
*
fl
=
nsFrameLoader
:
:
Create
(
content
-
>
AsElement
(
)
nullptr
false
)
;
if
(
fl
)
{
aDest
-
>
mFrameLoader
=
fl
;
mFrameLoader
-
>
CreateStaticClone
(
fl
)
;
}
}
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetPrintFrame
(
nsIFrame
*
*
aFrame
)
{
*
aFrame
=
mPrintFrame
.
GetFrame
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
PluginDestroyed
(
)
{
TeardownProtoChain
(
)
;
if
(
mInstanceOwner
)
{
mInstanceOwner
-
>
Destroy
(
)
;
mInstanceOwner
=
nullptr
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
PluginCrashed
(
nsIPluginTag
*
aPluginTag
const
nsAString
&
pluginDumpID
const
nsAString
&
browserDumpID
bool
submittedCrashReport
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Plugin
Crashed
queuing
crash
event
"
this
)
)
;
NS_ASSERTION
(
mType
=
=
eType_Plugin
"
PluginCrashed
at
non
-
plugin
type
"
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
#
ifdef
XP_MACOSX
HTMLObjectElement
:
:
HandlePluginCrashed
(
thisContent
-
>
AsElement
(
)
)
;
#
endif
PluginDestroyed
(
)
;
LoadFallback
(
eFallbackCrashed
true
)
;
nsAutoCString
pluginName
;
aPluginTag
-
>
GetName
(
pluginName
)
;
nsAutoCString
pluginFilename
;
aPluginTag
-
>
GetFilename
(
pluginFilename
)
;
nsCOMPtr
<
nsIRunnable
>
ev
=
new
nsPluginCrashedEvent
(
thisContent
pluginDumpID
browserDumpID
NS_ConvertUTF8toUTF16
(
pluginName
)
NS_ConvertUTF8toUTF16
(
pluginFilename
)
submittedCrashReport
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
ev
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
dispatch
nsPluginCrashedEvent
"
)
;
}
return
NS_OK
;
}
nsNPAPIPluginInstance
*
nsObjectLoadingContent
:
:
ScriptRequestPluginInstance
(
JSContext
*
aCx
)
{
MOZ_ASSERT_IF
(
nsContentUtils
:
:
GetCurrentJSContext
(
)
aCx
=
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
)
;
bool
callerIsContentJS
=
(
nsContentUtils
:
:
GetCurrentJSContext
(
)
&
&
!
nsContentUtils
:
:
IsCallerChrome
(
)
&
&
!
nsContentUtils
:
:
IsCallerContentXBL
(
)
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
callerIsContentJS
&
&
!
mScriptRequested
&
&
InActiveDocument
(
thisContent
)
&
&
mType
=
=
eType_Null
&
&
mFallbackType
>
=
eFallbackClickToPlay
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
new
nsSimplePluginEvent
(
thisContent
NS_LITERAL_STRING
(
"
PluginScripted
"
)
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
ev
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
failed
to
dispatch
PluginScripted
event
"
)
;
}
mScriptRequested
=
true
;
}
else
if
(
callerIsContentJS
&
&
mType
=
=
eType_Plugin
&
&
!
mInstanceOwner
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
&
&
InActiveDocument
(
thisContent
)
)
{
SyncStartPluginInstance
(
)
;
}
if
(
mInstanceOwner
)
{
return
mInstanceOwner
-
>
GetInstance
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
SyncStartPluginInstance
(
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Must
be
able
to
run
script
in
order
to
instantiate
a
plugin
instance
!
"
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
!
InActiveDocument
(
thisContent
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
kungFuURIGrip
(
mURI
)
;
mozilla
:
:
Unused
<
<
kungFuURIGrip
;
nsCString
contentType
(
mContentType
)
;
return
InstantiatePluginInstance
(
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
AsyncStartPluginInstance
(
)
{
if
(
mInstanceOwner
|
|
mPendingInstantiateEvent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
Document
*
doc
=
thisContent
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsStaticDocument
(
)
|
|
doc
-
>
IsBeingUsedAsImage
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsAsyncInstantiateEvent
(
this
)
;
nsresult
rv
=
NS_DispatchToCurrentThread
(
event
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingInstantiateEvent
=
event
;
}
return
rv
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetSrcURI
(
nsIURI
*
*
aURI
)
{
NS_IF_ADDREF
(
*
aURI
=
GetSrcURI
(
)
)
;
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
LoadFallback
(
FallbackType
aType
bool
aNotify
)
{
EventStates
oldState
=
ObjectState
(
)
;
ObjectType
oldType
=
mType
;
NS_ASSERTION
(
!
mInstanceOwner
&
&
!
mFrameLoader
&
&
!
mChannel
"
LoadFallback
called
with
loaded
content
"
)
;
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
if
(
!
thisContent
-
>
IsHTMLElement
(
)
|
|
mContentType
.
IsEmpty
(
)
)
{
aType
=
eFallbackAlternate
;
}
mType
=
eType_Null
;
bool
thisIsObject
=
thisContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
;
nsTArray
<
nsINodeList
*
>
childNodes
;
if
(
thisContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
&
&
(
aType
=
=
eFallbackUnsupported
|
|
aType
=
=
eFallbackDisabled
|
|
aType
=
=
eFallbackBlocklisted
|
|
aType
=
=
eFallbackAlternate
)
)
{
for
(
nsIContent
*
child
=
thisContent
-
>
GetFirstChild
(
)
;
child
;
)
{
bool
skipChildDescendants
=
false
;
if
(
aType
!
=
eFallbackAlternate
&
&
!
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
param
)
&
&
nsStyleUtil
:
:
IsSignificantChild
(
child
false
)
)
{
aType
=
eFallbackAlternate
;
}
if
(
thisIsObject
)
{
if
(
auto
embed
=
HTMLEmbedElement
:
:
FromNode
(
child
)
)
{
embed
-
>
StartObjectLoad
(
true
true
)
;
skipChildDescendants
=
true
;
}
else
if
(
auto
object
=
HTMLObjectElement
:
:
FromNode
(
child
)
)
{
object
-
>
StartObjectLoad
(
true
true
)
;
skipChildDescendants
=
true
;
}
}
if
(
skipChildDescendants
)
{
child
=
child
-
>
GetNextNonChildNode
(
thisContent
)
;
}
else
{
child
=
child
-
>
GetNextNode
(
thisContent
)
;
}
}
}
mFallbackType
=
aType
;
if
(
!
aNotify
)
{
return
;
}
NotifyStateChanged
(
oldType
oldState
false
true
)
;
}
void
nsObjectLoadingContent
:
:
DoStopPlugin
(
nsPluginInstanceOwner
*
aInstanceOwner
)
{
if
(
mIsStopping
)
{
return
;
}
mIsStopping
=
true
;
RefPtr
<
nsPluginInstanceOwner
>
kungFuDeathGrip
(
aInstanceOwner
)
;
if
(
mType
=
=
eType_FakePlugin
)
{
if
(
mFrameLoader
)
{
mFrameLoader
-
>
Destroy
(
)
;
mFrameLoader
=
nullptr
;
}
}
else
{
RefPtr
<
nsNPAPIPluginInstance
>
inst
=
aInstanceOwner
-
>
GetInstance
(
)
;
if
(
inst
)
{
#
if
defined
(
XP_MACOSX
)
aInstanceOwner
-
>
HidePluginWindow
(
)
;
#
endif
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
NS_ASSERTION
(
pluginHost
"
No
plugin
host
?
"
)
;
pluginHost
-
>
StopPluginInstance
(
inst
)
;
}
}
aInstanceOwner
-
>
Destroy
(
)
;
if
(
!
mIsStopping
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
Re
-
entered
in
plugin
teardown
"
this
)
)
;
return
;
}
TeardownProtoChain
(
)
;
mIsStopping
=
false
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
StopPluginInstance
(
)
{
AUTO_PROFILER_LABEL
(
"
nsObjectLoadingContent
:
:
StopPluginInstance
"
OTHER
)
;
mPendingInstantiateEvent
=
nullptr
;
mPendingCheckPluginStopEvent
=
nullptr
;
mInstantiating
=
false
;
if
(
!
mInstanceOwner
)
{
return
NS_OK
;
}
if
(
mChannel
)
{
LOG
(
(
"
OBJLC
[
%
p
]
:
StopPluginInstance
-
Closing
used
channel
"
this
)
)
;
CloseChannel
(
)
;
}
mInstanceOwner
-
>
SetFrame
(
nullptr
)
;
RefPtr
<
nsPluginInstanceOwner
>
ownerGrip
(
mInstanceOwner
)
;
mInstanceOwner
=
nullptr
;
DoStopPlugin
(
ownerGrip
)
;
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
NotifyContentObjectWrapper
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
thisContent
-
>
GetWrapper
(
)
)
;
if
(
!
obj
)
{
return
;
}
SetupProtoChain
(
cx
obj
)
;
}
void
nsObjectLoadingContent
:
:
PlayPlugin
(
SystemCallerGuarantee
ErrorResult
&
aRv
)
{
if
(
!
mActivated
)
{
mActivated
=
true
;
LOG
(
(
"
OBJLC
[
%
p
]
:
Activated
by
user
"
this
)
)
;
}
if
(
mType
=
=
eType_Null
&
&
mFallbackType
>
=
eFallbackClickToPlay
)
{
aRv
=
LoadObject
(
true
true
)
;
}
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
Reload
(
bool
aClearActivation
)
{
if
(
aClearActivation
)
{
mActivated
=
false
;
mSkipFakePlugins
=
false
;
}
return
LoadObject
(
true
true
)
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
GetActivated
(
bool
*
aActivated
)
{
*
aActivated
=
Activated
(
)
;
return
NS_OK
;
}
uint32_t
nsObjectLoadingContent
:
:
DefaultFallbackType
(
)
{
FallbackType
reason
;
if
(
ShouldPlay
(
reason
)
)
{
return
PLUGIN_ACTIVE
;
}
return
reason
;
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
SkipFakePlugins
(
)
{
if
(
!
nsContentUtils
:
:
IsCallerChrome
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
mSkipFakePlugins
=
true
;
if
(
mType
=
=
eType_FakePlugin
)
{
return
LoadObject
(
true
true
)
;
}
return
NS_OK
;
}
uint32_t
nsObjectLoadingContent
:
:
GetRunID
(
SystemCallerGuarantee
ErrorResult
&
aRv
)
{
if
(
!
mHasRunID
)
{
aRv
.
Throw
(
NS_ERROR_NOT_IMPLEMENTED
)
;
return
0
;
}
return
mRunID
;
}
static
bool
sPrefsInitialized
;
static
uint32_t
sSessionTimeoutMinutes
;
static
uint32_t
sPersistentTimeoutDays
;
static
bool
sBlockURIs
;
static
void
initializeObjectLoadingContentPrefs
(
)
{
if
(
!
sPrefsInitialized
)
{
Preferences
:
:
AddUintVarCache
(
&
sSessionTimeoutMinutes
"
plugin
.
sessionPermissionNow
.
intervalInMinutes
"
60
)
;
Preferences
:
:
AddUintVarCache
(
&
sPersistentTimeoutDays
"
plugin
.
persistentPermissionAlways
.
intervalInDays
"
90
)
;
Preferences
:
:
AddBoolVarCache
(
&
sBlockURIs
kPrefBlockURIs
false
)
;
sPrefsInitialized
=
true
;
}
}
bool
nsObjectLoadingContent
:
:
ShouldBlockContent
(
)
{
if
(
!
sPrefsInitialized
)
{
initializeObjectLoadingContentPrefs
(
)
;
}
if
(
mContentBlockingEnabled
&
&
mURI
&
&
IsFlashMIME
(
mContentType
)
&
&
sBlockURIs
)
{
return
true
;
}
return
false
;
}
bool
nsObjectLoadingContent
:
:
ShouldPlay
(
FallbackType
&
aReason
)
{
nsresult
rv
;
if
(
!
sPrefsInitialized
)
{
initializeObjectLoadingContentPrefs
(
)
;
}
if
(
BrowserTabsRemoteAutostart
(
)
)
{
bool
shouldLoadInParent
=
nsPluginHost
:
:
ShouldLoadTypeInParent
(
mContentType
)
;
bool
inParent
=
XRE_IsParentProcess
(
)
;
if
(
shouldLoadInParent
!
=
inParent
)
{
aReason
=
eFallbackDisabled
;
return
false
;
}
}
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
aReason
=
eFallbackClickToPlay
;
uint32_t
enabledState
=
nsIPluginTag
:
:
STATE_DISABLED
;
pluginHost
-
>
GetStateForType
(
mContentType
nsPluginHost
:
:
eExcludeNone
&
enabledState
)
;
if
(
nsIPluginTag
:
:
STATE_DISABLED
=
=
enabledState
)
{
aReason
=
eFallbackDisabled
;
return
false
;
}
uint32_t
blocklistState
=
nsIBlocklistService
:
:
STATE_BLOCKED
;
pluginHost
-
>
GetBlocklistStateForType
(
mContentType
nsPluginHost
:
:
eExcludeNone
&
blocklistState
)
;
if
(
blocklistState
=
=
nsIBlocklistService
:
:
STATE_BLOCKED
)
{
aReason
=
eFallbackBlocklisted
;
return
false
;
}
if
(
blocklistState
=
=
nsIBlocklistService
:
:
STATE_VULNERABLE_UPDATE_AVAILABLE
)
{
aReason
=
eFallbackVulnerableUpdatable
;
}
else
if
(
blocklistState
=
=
nsIBlocklistService
:
:
STATE_VULNERABLE_NO_UPDATE
)
{
aReason
=
eFallbackVulnerableNoUpdate
;
}
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIObjectLoadingContent
*
>
(
this
)
)
;
MOZ_ASSERT
(
thisContent
)
;
Document
*
ownerDoc
=
thisContent
-
>
OwnerDoc
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
ownerDoc
-
>
GetWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
window
-
>
GetTop
(
)
;
NS_ENSURE_TRUE
(
topWindow
false
)
;
nsCOMPtr
<
Document
>
topDoc
=
topWindow
-
>
GetDoc
(
)
;
NS_ENSURE_TRUE
(
topDoc
false
)
;
FlashClassification
documentClassification
=
FlashClassification
:
:
Unknown
;
if
(
IsFlashMIME
(
mContentType
)
)
{
documentClassification
=
ownerDoc
-
>
DocumentFlashClassification
(
)
;
}
if
(
documentClassification
=
=
FlashClassification
:
:
Denied
)
{
aReason
=
eFallbackSuppressed
;
return
false
;
}
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
services
:
:
GetPermissionManager
(
)
;
NS_ENSURE_TRUE
(
permissionManager
false
)
;
if
(
!
nsContentUtils
:
:
IsSystemPrincipal
(
topDoc
-
>
NodePrincipal
(
)
)
)
{
nsAutoCString
permissionString
;
rv
=
pluginHost
-
>
GetPermissionStringForType
(
mContentType
nsPluginHost
:
:
eExcludeNone
permissionString
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
uint32_t
permission
;
rv
=
permissionManager
-
>
TestPermissionFromPrincipal
(
topDoc
-
>
NodePrincipal
(
)
permissionString
.
Data
(
)
&
permission
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
permission
!
=
nsIPermissionManager
:
:
UNKNOWN_ACTION
)
{
uint64_t
nowms
=
PR_Now
(
)
/
1000
;
permissionManager
-
>
UpdateExpireTime
(
topDoc
-
>
NodePrincipal
(
)
permissionString
.
Data
(
)
false
nowms
+
sSessionTimeoutMinutes
*
60
*
1000
nowms
/
1000
+
uint64_t
(
sPersistentTimeoutDays
)
*
24
*
60
*
60
*
1000
)
;
}
switch
(
permission
)
{
case
nsIPermissionManager
:
:
ALLOW_ACTION
:
if
(
PreferFallback
(
false
)
)
{
aReason
=
eFallbackAlternate
;
return
false
;
}
return
true
;
case
nsIPermissionManager
:
:
DENY_ACTION
:
aReason
=
eFallbackDisabled
;
return
false
;
case
PLUGIN_PERMISSION_PROMPT_ACTION_QUIET
:
if
(
PreferFallback
(
true
)
)
{
aReason
=
eFallbackAlternate
;
}
else
{
aReason
=
eFallbackClickToPlayQuiet
;
}
return
false
;
case
nsIPermissionManager
:
:
PROMPT_ACTION
:
if
(
PreferFallback
(
true
)
)
{
aReason
=
eFallbackAlternate
;
}
return
false
;
case
nsIPermissionManager
:
:
UNKNOWN_ACTION
:
break
;
default
:
MOZ_ASSERT
(
false
)
;
return
false
;
}
}
if
(
blocklistState
=
=
nsIBlocklistService
:
:
STATE_VULNERABLE_UPDATE_AVAILABLE
|
|
blocklistState
=
=
nsIBlocklistService
:
:
STATE_VULNERABLE_NO_UPDATE
)
{
return
false
;
}
if
(
PreferFallback
(
enabledState
=
=
nsIPluginTag
:
:
STATE_CLICKTOPLAY
)
)
{
aReason
=
eFallbackAlternate
;
return
false
;
}
switch
(
enabledState
)
{
case
nsIPluginTag
:
:
STATE_ENABLED
:
return
true
;
case
nsIPluginTag
:
:
STATE_CLICKTOPLAY
:
if
(
documentClassification
=
=
FlashClassification
:
:
Allowed
)
{
return
true
;
}
return
false
;
}
MOZ_CRASH
(
"
Unexpected
enabledState
"
)
;
}
bool
nsObjectLoadingContent
:
:
FavorFallbackMode
(
bool
aIsPluginClickToPlay
)
{
if
(
!
IsFlashMIME
(
mContentType
)
)
{
return
false
;
}
nsAutoCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
kPrefFavorFallbackMode
prefString
)
)
)
{
if
(
aIsPluginClickToPlay
&
&
prefString
.
EqualsLiteral
(
"
follow
-
ctp
"
)
)
{
return
true
;
}
if
(
prefString
.
EqualsLiteral
(
"
always
"
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsObjectLoadingContent
:
:
HasGoodFallback
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ASSERTION
(
thisContent
"
must
be
a
content
"
)
;
if
(
!
thisContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
|
|
mContentType
.
IsEmpty
(
)
)
{
return
false
;
}
nsTArray
<
nsCString
>
rulesList
;
nsAutoCString
prefString
;
if
(
NS_SUCCEEDED
(
Preferences
:
:
GetCString
(
kPrefFavorFallbackRules
prefString
)
)
)
{
ParseString
(
prefString
'
'
rulesList
)
;
}
for
(
uint32_t
i
=
0
;
i
<
rulesList
.
Length
(
)
;
+
+
i
)
{
if
(
rulesList
[
i
]
.
EqualsLiteral
(
"
embed
"
)
)
{
nsTArray
<
nsINodeList
*
>
childNodes
;
for
(
nsIContent
*
child
=
thisContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextNode
(
thisContent
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
embed
)
)
{
return
false
;
}
}
}
if
(
rulesList
[
i
]
.
EqualsLiteral
(
"
video
"
)
)
{
nsTArray
<
nsINodeList
*
>
childNodes
;
for
(
nsIContent
*
child
=
thisContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextNode
(
thisContent
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
video
)
)
{
return
true
;
}
}
}
if
(
rulesList
[
i
]
.
EqualsLiteral
(
"
nosrc
"
)
)
{
if
(
!
mOriginalURI
)
{
return
true
;
}
}
if
(
rulesList
[
i
]
.
EqualsLiteral
(
"
adobelink
"
)
)
{
nsTArray
<
nsINodeList
*
>
childNodes
;
for
(
nsIContent
*
child
=
thisContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextNode
(
thisContent
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
nsCOMPtr
<
nsIURI
>
href
=
child
-
>
GetHrefURI
(
)
;
if
(
href
)
{
nsAutoCString
asciiHost
;
nsresult
rv
=
href
-
>
GetAsciiHost
(
asciiHost
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
asciiHost
.
IsEmpty
(
)
&
&
(
asciiHost
.
EqualsLiteral
(
"
adobe
.
com
"
)
|
|
StringEndsWith
(
asciiHost
NS_LITERAL_CSTRING
(
"
.
adobe
.
com
"
)
)
)
)
{
return
false
;
}
}
}
}
}
if
(
rulesList
[
i
]
.
EqualsLiteral
(
"
installinstructions
"
)
)
{
nsAutoString
textContent
;
ErrorResult
rv
;
thisContent
-
>
GetTextContent
(
textContent
rv
)
;
bool
hasText
=
!
rv
.
Failed
(
)
&
&
(
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
Flash
"
)
textContent
)
|
|
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
Install
"
)
textContent
)
|
|
CaseInsensitiveFindInReadable
(
NS_LITERAL_STRING
(
"
Download
"
)
textContent
)
)
;
if
(
hasText
)
{
return
false
;
}
}
if
(
rulesList
[
i
]
.
EqualsLiteral
(
"
true
"
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsObjectLoadingContent
:
:
PreferFallback
(
bool
aIsPluginClickToPlay
)
{
if
(
mPreferFallbackKnown
)
{
return
mPreferFallback
;
}
mPreferFallbackKnown
=
true
;
mPreferFallback
=
FavorFallbackMode
(
aIsPluginClickToPlay
)
&
&
HasGoodFallback
(
)
;
return
mPreferFallback
;
}
Document
*
nsObjectLoadingContent
:
:
GetContentDocument
(
nsIPrincipal
&
aSubjectPrincipal
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
!
thisContent
-
>
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
Document
*
sub_doc
=
thisContent
-
>
OwnerDoc
(
)
-
>
GetSubDocumentFor
(
thisContent
)
;
if
(
!
sub_doc
)
{
return
nullptr
;
}
if
(
!
aSubjectPrincipal
.
SubsumesConsideringDomain
(
sub_doc
-
>
NodePrincipal
(
)
)
)
{
return
nullptr
;
}
return
sub_doc
;
}
void
nsObjectLoadingContent
:
:
SetupProtoChain
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
)
{
if
(
mType
!
=
eType_Plugin
)
{
return
;
}
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
RefPtr
<
SetupProtoChainRunner
>
runner
=
new
SetupProtoChainRunner
(
this
)
;
nsContentUtils
:
:
AddScriptRunner
(
runner
)
;
return
;
}
MOZ_ASSERT
(
aCx
=
=
nsContentUtils
:
:
GetCurrentJSContext
(
)
)
;
MOZ_ASSERT
(
IsDOMObject
(
aObject
)
)
;
JSAutoRealm
ar
(
aCx
aObject
)
;
RefPtr
<
nsNPAPIPluginInstance
>
pi
=
ScriptRequestPluginInstance
(
aCx
)
;
if
(
!
pi
)
{
return
;
}
JS
:
:
Rooted
<
JSObject
*
>
pi_obj
(
aCx
)
;
JS
:
:
Rooted
<
JSObject
*
>
pi_proto
(
aCx
)
;
nsresult
rv
=
GetPluginJSObject
(
aCx
pi
&
pi_obj
&
pi_proto
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
!
pi_obj
)
{
return
;
}
JS
:
:
Handle
<
JSObject
*
>
my_proto
=
GetDOMClass
(
aObject
)
-
>
mGetProto
(
aCx
)
;
MOZ_ASSERT
(
my_proto
)
;
if
(
!
:
:
JS_SetPrototype
(
aCx
aObject
pi_obj
)
)
{
return
;
}
if
(
pi_proto
&
&
js
:
:
GetObjectClass
(
pi_proto
)
!
=
js
:
:
ObjectClassPtr
)
{
if
(
pi_proto
!
=
my_proto
&
&
!
:
:
JS_SetPrototype
(
aCx
pi_proto
my_proto
)
)
{
return
;
}
}
else
{
if
(
!
:
:
JS_SetPrototype
(
aCx
pi_obj
my_proto
)
)
{
return
;
}
}
}
nsresult
nsObjectLoadingContent
:
:
GetPluginJSObject
(
JSContext
*
cx
nsNPAPIPluginInstance
*
plugin_inst
JS
:
:
MutableHandle
<
JSObject
*
>
plugin_obj
JS
:
:
MutableHandle
<
JSObject
*
>
plugin_proto
)
{
if
(
plugin_inst
)
{
plugin_inst
-
>
GetJSObject
(
cx
plugin_obj
.
address
(
)
)
;
if
(
plugin_obj
)
{
if
(
!
:
:
JS_GetPrototype
(
cx
plugin_obj
plugin_proto
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
}
}
return
NS_OK
;
}
void
nsObjectLoadingContent
:
:
TeardownProtoChain
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
NS_ENSURE_TRUE_VOID
(
thisContent
-
>
GetWrapper
(
)
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
thisContent
-
>
GetWrapper
(
)
)
;
MOZ_ASSERT
(
obj
)
;
JS
:
:
Rooted
<
JSObject
*
>
proto
(
cx
)
;
JSAutoRealm
ar
(
cx
obj
)
;
DebugOnly
<
bool
>
removed
=
false
;
while
(
obj
)
{
if
(
!
:
:
JS_GetPrototype
(
cx
obj
&
proto
)
)
{
return
;
}
if
(
!
proto
)
{
break
;
}
if
(
nsNPObjWrapper
:
:
IsWrapper
(
js
:
:
UncheckedUnwrap
(
proto
)
)
)
{
if
(
!
:
:
JS_GetPrototype
(
cx
proto
&
proto
)
)
{
return
;
}
MOZ_ASSERT
(
!
removed
"
more
than
one
NPObject
in
prototype
chain
"
)
;
removed
=
true
;
:
:
JS_SetPrototype
(
cx
obj
proto
)
;
}
obj
=
proto
;
}
}
bool
nsObjectLoadingContent
:
:
DoResolve
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aObject
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
aDesc
)
{
Unused
<
<
ScriptRequestPluginInstance
(
aCx
)
;
return
true
;
}
bool
nsObjectLoadingContent
:
:
MayResolve
(
jsid
aId
)
{
return
true
;
}
void
nsObjectLoadingContent
:
:
GetOwnPropertyNames
(
JSContext
*
aCx
JS
:
:
AutoIdVector
&
bool
ErrorResult
&
aRv
)
{
Unused
<
<
ScriptRequestPluginInstance
(
aCx
)
;
}
void
nsObjectLoadingContent
:
:
MaybeFireErrorEvent
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
if
(
thisContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
{
RefPtr
<
AsyncEventDispatcher
>
loadBlockingAsyncDispatcher
=
new
LoadBlockingAsyncEventDispatcher
(
thisContent
NS_LITERAL_STRING
(
"
error
"
)
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
loadBlockingAsyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
bool
nsObjectLoadingContent
:
:
BlockEmbedOrObjectContentLoading
(
)
{
nsCOMPtr
<
nsIContent
>
thisContent
=
do_QueryInterface
(
static_cast
<
nsIImageLoadingContent
*
>
(
this
)
)
;
for
(
nsIContent
*
parent
=
thisContent
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
if
(
parent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
video
nsGkAtoms
:
:
audio
)
)
{
return
true
;
}
if
(
HTMLObjectElement
*
object
=
HTMLObjectElement
:
:
FromNode
(
parent
)
)
{
uint32_t
type
=
object
-
>
DisplayedType
(
)
;
if
(
type
!
=
eType_Null
)
{
return
true
;
}
}
}
return
false
;
}
nsObjectLoadingContent
:
:
SetupProtoChainRunner
:
:
SetupProtoChainRunner
(
nsObjectLoadingContent
*
aContent
)
:
mContent
(
aContent
)
{
}
NS_IMETHODIMP
nsObjectLoadingContent
:
:
SetupProtoChainRunner
:
:
Run
(
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
nsCOMPtr
<
nsIContent
>
content
;
CallQueryInterface
(
mContent
.
get
(
)
getter_AddRefs
(
content
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
content
-
>
GetWrapper
(
)
)
;
if
(
!
obj
)
{
return
NS_OK
;
}
nsObjectLoadingContent
*
objectLoadingContent
=
static_cast
<
nsObjectLoadingContent
*
>
(
mContent
.
get
(
)
)
;
objectLoadingContent
-
>
SetupProtoChain
(
cx
obj
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsObjectLoadingContent
:
:
SetupProtoChainRunner
nsIRunnable
)
