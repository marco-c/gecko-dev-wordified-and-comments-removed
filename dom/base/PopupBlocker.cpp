#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsIPermissionManager
.
h
"
namespace
mozilla
{
namespace
dom
{
namespace
{
static
char
*
sPopupAllowedEvents
;
static
PopupBlocker
:
:
PopupControlState
sPopupControlState
=
PopupBlocker
:
:
openAbused
;
static
uint32_t
sPopupStatePusherCount
=
0
;
static
TimeStamp
sLastAllowedExternalProtocolIFrameTimeStamp
;
static
bool
sUnusedPopupToken
=
false
;
void
PopupAllowedEventsChanged
(
)
{
if
(
sPopupAllowedEvents
)
{
free
(
sPopupAllowedEvents
)
;
}
nsAutoCString
str
;
Preferences
:
:
GetCString
(
"
dom
.
popup_allowed_events
"
str
)
;
sPopupAllowedEvents
=
ToNewCString
(
str
)
;
}
bool
PopupAllowedForEvent
(
const
char
*
eventName
)
{
if
(
!
sPopupAllowedEvents
)
{
PopupAllowedEventsChanged
(
)
;
if
(
!
sPopupAllowedEvents
)
{
return
false
;
}
}
nsDependentCString
events
(
sPopupAllowedEvents
)
;
nsCString
:
:
const_iterator
start
end
;
nsCString
:
:
const_iterator
startiter
(
events
.
BeginReading
(
start
)
)
;
events
.
EndReading
(
end
)
;
while
(
startiter
!
=
end
)
{
nsCString
:
:
const_iterator
enditer
(
end
)
;
if
(
!
FindInReadable
(
nsDependentCString
(
eventName
)
startiter
enditer
)
)
return
false
;
if
(
(
startiter
=
=
start
|
|
*
-
-
startiter
=
=
'
'
)
&
&
(
enditer
=
=
end
|
|
*
enditer
=
=
'
'
)
)
{
return
true
;
}
startiter
=
enditer
;
}
return
false
;
}
void
OnPrefChange
(
const
char
*
aPrefName
void
*
)
{
nsDependentCString
prefName
(
aPrefName
)
;
if
(
prefName
.
EqualsLiteral
(
"
dom
.
popup_allowed_events
"
)
)
{
PopupAllowedEventsChanged
(
)
;
}
}
}
PopupBlocker
:
:
PopupControlState
PopupBlocker
:
:
PushPopupControlState
(
PopupBlocker
:
:
PopupControlState
aState
bool
aForce
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
PopupBlocker
:
:
PopupControlState
old
=
sPopupControlState
;
if
(
aState
<
old
|
|
aForce
)
{
sPopupControlState
=
aState
;
}
return
old
;
}
void
PopupBlocker
:
:
PopPopupControlState
(
PopupBlocker
:
:
PopupControlState
aState
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sPopupControlState
=
aState
;
}
PopupBlocker
:
:
PopupControlState
PopupBlocker
:
:
GetPopupControlState
(
)
{
return
sPopupControlState
;
}
bool
PopupBlocker
:
:
CanShowPopupByPermission
(
nsIPrincipal
*
aPrincipal
)
{
MOZ_ASSERT
(
aPrincipal
)
;
uint32_t
permit
;
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
services
:
:
GetPermissionManager
(
)
;
if
(
permissionManager
&
&
NS_SUCCEEDED
(
permissionManager
-
>
TestPermissionFromPrincipal
(
aPrincipal
NS_LITERAL_CSTRING
(
"
popup
"
)
&
permit
)
)
)
{
if
(
permit
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
return
true
;
}
if
(
permit
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
{
return
false
;
}
}
return
!
StaticPrefs
:
:
dom_disable_open_during_load
(
)
;
}
bool
PopupBlocker
:
:
TryUsePopupOpeningToken
(
)
{
MOZ_ASSERT
(
sPopupStatePusherCount
)
;
if
(
!
sUnusedPopupToken
)
{
sUnusedPopupToken
=
true
;
return
true
;
}
return
false
;
}
bool
PopupBlocker
:
:
IsPopupOpeningTokenUnused
(
)
{
return
sUnusedPopupToken
;
}
void
PopupBlocker
:
:
PopupStatePusherCreated
(
)
{
+
+
sPopupStatePusherCount
;
}
void
PopupBlocker
:
:
PopupStatePusherDestroyed
(
)
{
MOZ_ASSERT
(
sPopupStatePusherCount
)
;
if
(
!
-
-
sPopupStatePusherCount
)
{
sUnusedPopupToken
=
false
;
}
}
PopupBlocker
:
:
PopupControlState
PopupBlocker
:
:
GetEventPopupControlState
(
WidgetEvent
*
aEvent
Event
*
aDOMEvent
)
{
PopupBlocker
:
:
PopupControlState
abuse
=
PopupBlocker
:
:
openAbused
;
if
(
aDOMEvent
&
&
aDOMEvent
-
>
GetWantsPopupControlCheck
(
)
)
{
nsAutoString
type
;
aDOMEvent
-
>
GetType
(
type
)
;
if
(
PopupAllowedForEvent
(
NS_ConvertUTF16toUTF8
(
type
)
.
get
(
)
)
)
{
return
PopupBlocker
:
:
openAllowed
;
}
}
switch
(
aEvent
-
>
mClass
)
{
case
eBasicEventClass
:
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
switch
(
aEvent
-
>
mMessage
)
{
case
eFormSelect
:
if
(
PopupAllowedForEvent
(
"
select
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eFormChange
:
if
(
PopupAllowedForEvent
(
"
change
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
default
:
break
;
}
}
break
;
case
eEditorInputEventClass
:
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
switch
(
aEvent
-
>
mMessage
)
{
case
eEditorInput
:
if
(
PopupAllowedForEvent
(
"
input
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
default
:
break
;
}
}
break
;
case
eInputEventClass
:
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
switch
(
aEvent
-
>
mMessage
)
{
case
eFormChange
:
if
(
PopupAllowedForEvent
(
"
change
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eXULCommand
:
abuse
=
PopupBlocker
:
:
openControlled
;
break
;
default
:
break
;
}
}
break
;
case
eKeyboardEventClass
:
if
(
aEvent
-
>
IsTrusted
(
)
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
uint32_t
key
=
aEvent
-
>
AsKeyboardEvent
(
)
-
>
mKeyCode
;
switch
(
aEvent
-
>
mMessage
)
{
case
eKeyPress
:
if
(
key
=
=
NS_VK_RETURN
)
{
abuse
=
PopupBlocker
:
:
openAllowed
;
}
else
if
(
PopupAllowedForEvent
(
"
keypress
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eKeyUp
:
if
(
key
=
=
NS_VK_SPACE
)
{
abuse
=
PopupBlocker
:
:
openAllowed
;
}
else
if
(
PopupAllowedForEvent
(
"
keyup
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eKeyDown
:
if
(
PopupAllowedForEvent
(
"
keydown
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
default
:
break
;
}
}
break
;
case
eTouchEventClass
:
if
(
aEvent
-
>
IsTrusted
(
)
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
switch
(
aEvent
-
>
mMessage
)
{
case
eTouchStart
:
if
(
PopupAllowedForEvent
(
"
touchstart
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eTouchEnd
:
if
(
PopupAllowedForEvent
(
"
touchend
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
default
:
break
;
}
}
break
;
case
eMouseEventClass
:
if
(
aEvent
-
>
IsTrusted
(
)
)
{
if
(
aEvent
-
>
AsMouseEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
switch
(
aEvent
-
>
mMessage
)
{
case
eMouseUp
:
if
(
PopupAllowedForEvent
(
"
mouseup
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eMouseDown
:
if
(
PopupAllowedForEvent
(
"
mousedown
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eMouseClick
:
if
(
PopupAllowedForEvent
(
"
click
"
)
)
{
abuse
=
PopupBlocker
:
:
openAllowed
;
}
break
;
case
eMouseDoubleClick
:
if
(
PopupAllowedForEvent
(
"
dblclick
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
default
:
break
;
}
}
switch
(
aEvent
-
>
mMessage
)
{
case
eContextMenu
:
if
(
PopupAllowedForEvent
(
"
contextmenu
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
else
{
abuse
=
PopupBlocker
:
:
openBlocked
;
}
break
;
default
:
break
;
}
}
break
;
case
ePointerEventClass
:
if
(
aEvent
-
>
IsTrusted
(
)
&
&
aEvent
-
>
AsPointerEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
ePointerUp
:
if
(
PopupAllowedForEvent
(
"
pointerup
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
ePointerDown
:
if
(
PopupAllowedForEvent
(
"
pointerdown
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
default
:
break
;
}
}
break
;
case
eFormEventClass
:
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
abuse
=
PopupBlocker
:
:
openBlocked
;
switch
(
aEvent
-
>
mMessage
)
{
case
eFormSubmit
:
if
(
PopupAllowedForEvent
(
"
submit
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
case
eFormReset
:
if
(
PopupAllowedForEvent
(
"
reset
"
)
)
{
abuse
=
PopupBlocker
:
:
openControlled
;
}
break
;
default
:
break
;
}
}
break
;
default
:
break
;
}
return
abuse
;
}
void
PopupBlocker
:
:
Initialize
(
)
{
DebugOnly
<
nsresult
>
rv
=
Preferences
:
:
RegisterCallback
(
OnPrefChange
"
dom
.
popup_allowed_events
"
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
Failed
to
observe
\
"
dom
.
popup_allowed_events
\
"
"
)
;
}
void
PopupBlocker
:
:
Shutdown
(
)
{
if
(
sPopupAllowedEvents
)
{
free
(
sPopupAllowedEvents
)
;
}
Preferences
:
:
UnregisterCallback
(
OnPrefChange
"
dom
.
popup_allowed_events
"
)
;
}
bool
PopupBlocker
:
:
ConsumeTimerTokenForExternalProtocolIframe
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
if
(
sLastAllowedExternalProtocolIFrameTimeStamp
.
IsNull
(
)
)
{
sLastAllowedExternalProtocolIFrameTimeStamp
=
now
;
return
true
;
}
if
(
(
now
-
sLastAllowedExternalProtocolIFrameTimeStamp
)
.
ToSeconds
(
)
<
(
StaticPrefs
:
:
dom_delay_block_external_protocol_in_iframes
(
)
)
)
{
return
false
;
}
sLastAllowedExternalProtocolIFrameTimeStamp
=
now
;
return
true
;
}
TimeStamp
PopupBlocker
:
:
WhenLastExternalProtocolIframeAllowed
(
)
{
return
sLastAllowedExternalProtocolIFrameTimeStamp
;
}
void
PopupBlocker
:
:
ResetLastExternalProtocolIframeAllowed
(
)
{
sLastAllowedExternalProtocolIFrameTimeStamp
=
TimeStamp
(
)
;
}
}
}
nsAutoPopupStatePusherInternal
:
:
nsAutoPopupStatePusherInternal
(
mozilla
:
:
dom
:
:
PopupBlocker
:
:
PopupControlState
aState
bool
aForce
)
:
mOldState
(
mozilla
:
:
dom
:
:
PopupBlocker
:
:
PushPopupControlState
(
aState
aForce
)
)
{
mozilla
:
:
dom
:
:
PopupBlocker
:
:
PopupStatePusherCreated
(
)
;
}
nsAutoPopupStatePusherInternal
:
:
~
nsAutoPopupStatePusherInternal
(
)
{
mozilla
:
:
dom
:
:
PopupBlocker
:
:
PopPopupControlState
(
mOldState
)
;
mozilla
:
:
dom
:
:
PopupBlocker
:
:
PopupStatePusherDestroyed
(
)
;
}
