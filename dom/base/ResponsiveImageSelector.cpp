#
include
"
mozilla
/
dom
/
ResponsiveImageSelector
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
nsCSSProps
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
namespace
dom
{
NS_IMPL_CYCLE_COLLECTION
(
ResponsiveImageSelector
mOwnerNode
)
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
ResponsiveImageSelector
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
ResponsiveImageSelector
Release
)
static
bool
ParseInteger
(
const
nsAString
&
aString
int32_t
&
aInt
)
{
nsContentUtils
:
:
ParseHTMLIntegerResultFlags
parseResult
;
aInt
=
nsContentUtils
:
:
ParseHTMLInteger
(
aString
&
parseResult
)
;
return
!
(
parseResult
&
(
nsContentUtils
:
:
eParseHTMLInteger_Error
|
nsContentUtils
:
:
eParseHTMLInteger_DidNotConsumeAllInput
|
nsContentUtils
:
:
eParseHTMLInteger_IsPercent
|
nsContentUtils
:
:
eParseHTMLInteger_NonStandard
)
)
;
}
static
bool
ParseFloat
(
const
nsAString
&
aString
double
&
aDouble
)
{
nsAString
:
:
const_iterator
iter
end
;
aString
.
BeginReading
(
iter
)
;
aString
.
EndReading
(
end
)
;
if
(
iter
=
=
end
)
{
return
false
;
}
if
(
*
iter
=
=
char16_t
(
'
-
'
)
&
&
+
+
iter
=
=
end
)
{
return
false
;
}
if
(
IsAsciiDigit
(
*
iter
)
)
{
for
(
;
iter
!
=
end
&
&
IsAsciiDigit
(
*
iter
)
;
+
+
iter
)
;
}
else
if
(
*
iter
=
=
char16_t
(
'
.
'
)
)
{
}
else
{
return
false
;
}
if
(
*
iter
=
=
char16_t
(
'
.
'
)
)
{
+
+
iter
;
if
(
iter
=
=
end
|
|
!
IsAsciiDigit
(
*
iter
)
)
{
return
false
;
}
for
(
;
iter
!
=
end
&
&
IsAsciiDigit
(
*
iter
)
;
+
+
iter
)
;
}
if
(
iter
!
=
end
&
&
(
*
iter
=
=
char16_t
(
'
e
'
)
|
|
*
iter
=
=
char16_t
(
'
E
'
)
)
)
{
+
+
iter
;
if
(
*
iter
=
=
char16_t
(
'
-
'
)
|
|
*
iter
=
=
char16_t
(
'
+
'
)
)
{
+
+
iter
;
}
if
(
iter
=
=
end
|
|
!
IsAsciiDigit
(
*
iter
)
)
{
return
false
;
}
for
(
;
iter
!
=
end
&
&
IsAsciiDigit
(
*
iter
)
;
+
+
iter
)
;
}
if
(
iter
!
=
end
)
{
return
false
;
}
nsresult
rv
;
aDouble
=
PromiseFlatString
(
aString
)
.
ToDouble
(
&
rv
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
ResponsiveImageSelector
:
:
ResponsiveImageSelector
(
nsIContent
*
aContent
)
:
mOwnerNode
(
aContent
)
mSelectedCandidateIndex
(
-
1
)
{
}
ResponsiveImageSelector
:
:
ResponsiveImageSelector
(
nsIDocument
*
aDocument
)
:
mOwnerNode
(
aDocument
)
mSelectedCandidateIndex
(
-
1
)
{
}
ResponsiveImageSelector
:
:
~
ResponsiveImageSelector
(
)
{
}
bool
ResponsiveImageSelector
:
:
SetCandidatesFromSourceSet
(
const
nsAString
&
aSrcSet
nsIPrincipal
*
aTriggeringPrincipal
)
{
ClearSelectedCandidate
(
)
;
nsCOMPtr
<
nsIURI
>
docBaseURI
=
mOwnerNode
?
mOwnerNode
-
>
GetBaseURI
(
)
:
nullptr
;
if
(
!
docBaseURI
)
{
MOZ_ASSERT
(
false
"
Should
not
be
parsing
SourceSet
without
a
document
"
)
;
return
false
;
}
mCandidates
.
Clear
(
)
;
nsAString
:
:
const_iterator
iter
end
;
aSrcSet
.
BeginReading
(
iter
)
;
aSrcSet
.
EndReading
(
end
)
;
while
(
iter
!
=
end
)
{
nsAString
:
:
const_iterator
url
urlEnd
descriptor
;
for
(
;
iter
!
=
end
&
&
(
nsContentUtils
:
:
IsHTMLWhitespace
(
*
iter
)
|
|
*
iter
=
=
char16_t
(
'
'
)
)
;
+
+
iter
)
;
if
(
iter
=
=
end
)
{
break
;
}
url
=
iter
;
for
(
;
iter
!
=
end
&
&
!
nsContentUtils
:
:
IsHTMLWhitespace
(
*
iter
)
;
+
+
iter
)
;
while
(
iter
!
=
url
)
{
if
(
*
(
-
-
iter
)
!
=
char16_t
(
'
'
)
)
{
iter
+
+
;
break
;
}
}
const
nsDependentSubstring
&
urlStr
=
Substring
(
url
iter
)
;
MOZ_ASSERT
(
url
!
=
iter
"
Shouldn
'
t
have
empty
URL
at
this
point
"
)
;
ResponsiveImageCandidate
candidate
;
if
(
candidate
.
ConsumeDescriptors
(
iter
end
)
)
{
candidate
.
SetURLSpec
(
urlStr
)
;
candidate
.
SetTriggeringPrincipal
(
nsContentUtils
:
:
GetAttrTriggeringPrincipal
(
Content
(
)
urlStr
aTriggeringPrincipal
)
)
;
AppendCandidateIfUnique
(
candidate
)
;
}
}
bool
parsedCandidates
=
mCandidates
.
Length
(
)
>
0
;
MaybeAppendDefaultCandidate
(
)
;
return
parsedCandidates
;
}
uint32_t
ResponsiveImageSelector
:
:
NumCandidates
(
bool
aIncludeDefault
)
{
uint32_t
candidates
=
mCandidates
.
Length
(
)
;
if
(
!
aIncludeDefault
&
&
candidates
&
&
(
mCandidates
[
candidates
-
1
]
.
Type
(
)
=
=
ResponsiveImageCandidate
:
:
eCandidateType_Default
)
)
{
candidates
-
-
;
}
return
candidates
;
}
nsIContent
*
ResponsiveImageSelector
:
:
Content
(
)
{
return
mOwnerNode
-
>
IsContent
(
)
?
mOwnerNode
-
>
AsContent
(
)
:
nullptr
;
}
nsIDocument
*
ResponsiveImageSelector
:
:
Document
(
)
{
return
mOwnerNode
-
>
OwnerDoc
(
)
;
}
void
ResponsiveImageSelector
:
:
SetDefaultSource
(
const
nsAString
&
aURLString
nsIPrincipal
*
aPrincipal
)
{
ClearSelectedCandidate
(
)
;
int32_t
candidates
=
mCandidates
.
Length
(
)
;
if
(
candidates
&
&
(
mCandidates
[
candidates
-
1
]
.
Type
(
)
=
=
ResponsiveImageCandidate
:
:
eCandidateType_Default
)
)
{
mCandidates
.
RemoveElementAt
(
candidates
-
1
)
;
}
mDefaultSourceURL
=
aURLString
;
mDefaultSourceTriggeringPrincipal
=
aPrincipal
;
MaybeAppendDefaultCandidate
(
)
;
}
void
ResponsiveImageSelector
:
:
ClearSelectedCandidate
(
)
{
mSelectedCandidateIndex
=
-
1
;
mSelectedCandidateURL
=
nullptr
;
}
bool
ResponsiveImageSelector
:
:
SetSizesFromDescriptor
(
const
nsAString
&
aSizes
)
{
ClearSelectedCandidate
(
)
;
NS_ConvertUTF16toUTF8
sizes
(
aSizes
)
;
mServoSourceSizeList
.
reset
(
Servo_SourceSizeList_Parse
(
&
sizes
)
)
;
return
!
!
mServoSourceSizeList
;
}
void
ResponsiveImageSelector
:
:
AppendCandidateIfUnique
(
const
ResponsiveImageCandidate
&
aCandidate
)
{
int
numCandidates
=
mCandidates
.
Length
(
)
;
if
(
aCandidate
.
Type
(
)
=
=
ResponsiveImageCandidate
:
:
eCandidateType_Default
)
{
return
;
}
for
(
int
i
=
0
;
i
<
numCandidates
;
i
+
+
)
{
if
(
mCandidates
[
i
]
.
HasSameParameter
(
aCandidate
)
)
{
return
;
}
}
mCandidates
.
AppendElement
(
aCandidate
)
;
}
void
ResponsiveImageSelector
:
:
MaybeAppendDefaultCandidate
(
)
{
if
(
mDefaultSourceURL
.
IsEmpty
(
)
)
{
return
;
}
int
numCandidates
=
mCandidates
.
Length
(
)
;
for
(
int
i
=
0
;
i
<
numCandidates
;
i
+
+
)
{
if
(
mCandidates
[
i
]
.
IsComputedFromWidth
(
)
)
{
return
;
}
else
if
(
mCandidates
[
i
]
.
Density
(
this
)
=
=
1
.
0
)
{
return
;
}
}
ResponsiveImageCandidate
defaultCandidate
;
defaultCandidate
.
SetParameterDefault
(
)
;
defaultCandidate
.
SetURLSpec
(
mDefaultSourceURL
)
;
defaultCandidate
.
SetTriggeringPrincipal
(
mDefaultSourceTriggeringPrincipal
)
;
mCandidates
.
AppendElement
(
defaultCandidate
)
;
}
already_AddRefed
<
nsIURI
>
ResponsiveImageSelector
:
:
GetSelectedImageURL
(
)
{
SelectImage
(
)
;
nsCOMPtr
<
nsIURI
>
url
=
mSelectedCandidateURL
;
return
url
.
forget
(
)
;
}
bool
ResponsiveImageSelector
:
:
GetSelectedImageURLSpec
(
nsAString
&
aResult
)
{
SelectImage
(
)
;
if
(
mSelectedCandidateIndex
=
=
-
1
)
{
return
false
;
}
aResult
.
Assign
(
mCandidates
[
mSelectedCandidateIndex
]
.
URLString
(
)
)
;
return
true
;
}
double
ResponsiveImageSelector
:
:
GetSelectedImageDensity
(
)
{
int
bestIndex
=
GetSelectedCandidateIndex
(
)
;
if
(
bestIndex
<
0
)
{
return
1
.
0
;
}
return
mCandidates
[
bestIndex
]
.
Density
(
this
)
;
}
nsIPrincipal
*
ResponsiveImageSelector
:
:
GetSelectedImageTriggeringPrincipal
(
)
{
int
bestIndex
=
GetSelectedCandidateIndex
(
)
;
if
(
bestIndex
<
0
)
{
return
nullptr
;
}
return
mCandidates
[
bestIndex
]
.
TriggeringPrincipal
(
)
;
}
bool
ResponsiveImageSelector
:
:
SelectImage
(
bool
aReselect
)
{
if
(
!
aReselect
&
&
mSelectedCandidateIndex
!
=
-
1
)
{
return
false
;
}
int
oldBest
=
mSelectedCandidateIndex
;
ClearSelectedCandidate
(
)
;
int
numCandidates
=
mCandidates
.
Length
(
)
;
if
(
!
numCandidates
)
{
return
oldBest
!
=
-
1
;
}
nsIDocument
*
doc
=
Document
(
)
;
nsPresContext
*
pctx
=
doc
-
>
GetPresContext
(
)
;
nsCOMPtr
<
nsIURI
>
baseURI
=
mOwnerNode
-
>
GetBaseURI
(
)
;
if
(
!
pctx
|
|
!
baseURI
)
{
return
oldBest
!
=
-
1
;
}
double
displayDensity
=
pctx
-
>
CSSPixelsToDevPixels
(
1
.
0f
)
;
double
overrideDPPX
=
pctx
-
>
GetOverrideDPPX
(
)
;
if
(
overrideDPPX
>
0
)
{
displayDensity
=
overrideDPPX
;
}
double
computedWidth
=
-
1
;
for
(
int
i
=
0
;
i
<
numCandidates
;
i
+
+
)
{
if
(
mCandidates
[
i
]
.
IsComputedFromWidth
(
)
)
{
DebugOnly
<
bool
>
computeResult
=
ComputeFinalWidthForCurrentViewport
(
&
computedWidth
)
;
MOZ_ASSERT
(
computeResult
"
Computed
candidates
not
allowed
without
sizes
data
"
)
;
break
;
}
}
int
bestIndex
=
-
1
;
double
bestDensity
=
-
1
.
0
;
for
(
int
i
=
0
;
i
<
numCandidates
;
i
+
+
)
{
double
candidateDensity
=
\
(
computedWidth
=
=
-
1
)
?
mCandidates
[
i
]
.
Density
(
this
)
:
mCandidates
[
i
]
.
Density
(
computedWidth
)
;
if
(
bestIndex
=
=
-
1
|
|
(
bestDensity
<
displayDensity
&
&
candidateDensity
>
bestDensity
)
|
|
(
candidateDensity
>
=
displayDensity
&
&
candidateDensity
<
bestDensity
)
)
{
bestIndex
=
i
;
bestDensity
=
candidateDensity
;
}
}
MOZ_ASSERT
(
bestIndex
>
=
0
&
&
bestIndex
<
numCandidates
)
;
nsresult
rv
;
const
nsAString
&
urlStr
=
mCandidates
[
bestIndex
]
.
URLString
(
)
;
nsCOMPtr
<
nsIURI
>
candidateURL
;
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
candidateURL
)
urlStr
doc
baseURI
)
;
mSelectedCandidateURL
=
NS_SUCCEEDED
(
rv
)
?
candidateURL
:
nullptr
;
mSelectedCandidateIndex
=
bestIndex
;
return
mSelectedCandidateIndex
!
=
oldBest
;
}
int
ResponsiveImageSelector
:
:
GetSelectedCandidateIndex
(
)
{
SelectImage
(
)
;
return
mSelectedCandidateIndex
;
}
bool
ResponsiveImageSelector
:
:
ComputeFinalWidthForCurrentViewport
(
double
*
aWidth
)
{
nsIDocument
*
doc
=
Document
(
)
;
nsIPresShell
*
presShell
=
doc
-
>
GetShell
(
)
;
nsPresContext
*
pctx
=
presShell
?
presShell
-
>
GetPresContext
(
)
:
nullptr
;
if
(
!
pctx
)
{
return
false
;
}
nscoord
effectiveWidth
=
presShell
-
>
StyleSet
(
)
-
>
EvaluateSourceSizeList
(
mServoSourceSizeList
.
get
(
)
)
;
*
aWidth
=
nsPresContext
:
:
AppUnitsToDoubleCSSPixels
(
std
:
:
max
(
effectiveWidth
0
)
)
;
return
true
;
}
ResponsiveImageCandidate
:
:
ResponsiveImageCandidate
(
)
{
mType
=
eCandidateType_Invalid
;
mValue
.
mDensity
=
1
.
0
;
}
ResponsiveImageCandidate
:
:
ResponsiveImageCandidate
(
const
nsAString
&
aURLString
double
aDensity
nsIPrincipal
*
aTriggeringPrincipal
)
:
mURLString
(
aURLString
)
mTriggeringPrincipal
(
aTriggeringPrincipal
)
{
mType
=
eCandidateType_Density
;
mValue
.
mDensity
=
aDensity
;
}
void
ResponsiveImageCandidate
:
:
SetURLSpec
(
const
nsAString
&
aURLString
)
{
mURLString
=
aURLString
;
}
void
ResponsiveImageCandidate
:
:
SetTriggeringPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
mTriggeringPrincipal
=
aPrincipal
;
}
void
ResponsiveImageCandidate
:
:
SetParameterAsComputedWidth
(
int32_t
aWidth
)
{
mType
=
eCandidateType_ComputedFromWidth
;
mValue
.
mWidth
=
aWidth
;
}
void
ResponsiveImageCandidate
:
:
SetParameterDefault
(
)
{
MOZ_ASSERT
(
mType
=
=
eCandidateType_Invalid
"
double
setting
candidate
type
"
)
;
mType
=
eCandidateType_Default
;
mValue
.
mDensity
=
1
.
0
;
}
void
ResponsiveImageCandidate
:
:
SetParameterInvalid
(
)
{
mType
=
eCandidateType_Invalid
;
mValue
.
mDensity
=
1
.
0
;
}
void
ResponsiveImageCandidate
:
:
SetParameterAsDensity
(
double
aDensity
)
{
MOZ_ASSERT
(
mType
=
=
eCandidateType_Invalid
"
double
setting
candidate
type
"
)
;
mType
=
eCandidateType_Density
;
mValue
.
mDensity
=
aDensity
;
}
struct
ResponsiveImageDescriptors
{
ResponsiveImageDescriptors
(
)
:
mInvalid
(
false
)
{
}
;
Maybe
<
double
>
mDensity
;
Maybe
<
int32_t
>
mWidth
;
Maybe
<
int32_t
>
mFutureCompatHeight
;
bool
mInvalid
;
void
AddDescriptor
(
const
nsAString
&
aDescriptor
)
;
bool
Valid
(
)
;
void
FillCandidate
(
ResponsiveImageCandidate
&
aCandidate
)
;
}
;
void
ResponsiveImageDescriptors
:
:
AddDescriptor
(
const
nsAString
&
aDescriptor
)
{
if
(
aDescriptor
.
IsEmpty
(
)
)
{
return
;
}
nsAString
:
:
const_iterator
descStart
descType
;
aDescriptor
.
BeginReading
(
descStart
)
;
aDescriptor
.
EndReading
(
descType
)
;
descType
-
-
;
const
nsDependentSubstring
&
valueStr
=
Substring
(
descStart
descType
)
;
if
(
*
descType
=
=
char16_t
(
'
w
'
)
)
{
int32_t
possibleWidth
;
if
(
ParseInteger
(
valueStr
possibleWidth
)
&
&
possibleWidth
>
=
0
)
{
if
(
possibleWidth
!
=
0
&
&
mWidth
.
isNothing
(
)
&
&
mDensity
.
isNothing
(
)
)
{
mWidth
.
emplace
(
possibleWidth
)
;
}
else
{
mInvalid
=
true
;
}
return
;
}
}
else
if
(
*
descType
=
=
char16_t
(
'
h
'
)
)
{
int32_t
possibleHeight
;
if
(
ParseInteger
(
valueStr
possibleHeight
)
&
&
possibleHeight
>
=
0
)
{
if
(
possibleHeight
!
=
0
&
&
mFutureCompatHeight
.
isNothing
(
)
&
&
mDensity
.
isNothing
(
)
)
{
mFutureCompatHeight
.
emplace
(
possibleHeight
)
;
}
else
{
mInvalid
=
true
;
}
return
;
}
}
else
if
(
*
descType
=
=
char16_t
(
'
x
'
)
)
{
double
possibleDensity
=
0
.
0
;
if
(
ParseFloat
(
valueStr
possibleDensity
)
)
{
if
(
possibleDensity
>
=
0
.
0
&
&
mWidth
.
isNothing
(
)
&
&
mDensity
.
isNothing
(
)
&
&
mFutureCompatHeight
.
isNothing
(
)
)
{
mDensity
.
emplace
(
possibleDensity
)
;
}
else
{
mInvalid
=
true
;
}
return
;
}
}
mInvalid
=
true
;
}
bool
ResponsiveImageDescriptors
:
:
Valid
(
)
{
return
!
mInvalid
&
&
!
(
mFutureCompatHeight
.
isSome
(
)
&
&
mWidth
.
isNothing
(
)
)
;
}
void
ResponsiveImageDescriptors
:
:
FillCandidate
(
ResponsiveImageCandidate
&
aCandidate
)
{
if
(
!
Valid
(
)
)
{
aCandidate
.
SetParameterInvalid
(
)
;
}
else
if
(
mWidth
.
isSome
(
)
)
{
MOZ_ASSERT
(
mDensity
.
isNothing
(
)
)
;
aCandidate
.
SetParameterAsComputedWidth
(
*
mWidth
)
;
}
else
if
(
mDensity
.
isSome
(
)
)
{
MOZ_ASSERT
(
mWidth
.
isNothing
(
)
)
;
aCandidate
.
SetParameterAsDensity
(
*
mDensity
)
;
}
else
{
aCandidate
.
SetParameterAsDensity
(
1
.
0
)
;
}
}
bool
ResponsiveImageCandidate
:
:
ConsumeDescriptors
(
nsAString
:
:
const_iterator
&
aIter
const
nsAString
:
:
const_iterator
&
aIterEnd
)
{
nsAString
:
:
const_iterator
&
iter
=
aIter
;
const
nsAString
:
:
const_iterator
&
end
=
aIterEnd
;
bool
inParens
=
false
;
ResponsiveImageDescriptors
descriptors
;
for
(
;
iter
!
=
end
&
&
nsContentUtils
:
:
IsHTMLWhitespace
(
*
iter
)
;
+
+
iter
)
;
nsAString
:
:
const_iterator
currentDescriptor
=
iter
;
for
(
;
;
iter
+
+
)
{
if
(
iter
=
=
end
)
{
descriptors
.
AddDescriptor
(
Substring
(
currentDescriptor
iter
)
)
;
break
;
}
else
if
(
inParens
)
{
if
(
*
iter
=
=
char16_t
(
'
)
'
)
)
{
inParens
=
false
;
}
}
else
{
if
(
*
iter
=
=
char16_t
(
'
'
)
)
{
descriptors
.
AddDescriptor
(
Substring
(
currentDescriptor
iter
)
)
;
iter
+
+
;
break
;
}
else
if
(
nsContentUtils
:
:
IsHTMLWhitespace
(
*
iter
)
)
{
descriptors
.
AddDescriptor
(
Substring
(
currentDescriptor
iter
)
)
;
for
(
;
iter
!
=
end
&
&
nsContentUtils
:
:
IsHTMLWhitespace
(
*
iter
)
;
+
+
iter
)
;
if
(
iter
=
=
end
)
{
break
;
}
currentDescriptor
=
iter
;
iter
-
-
;
}
else
if
(
*
iter
=
=
char16_t
(
'
(
'
)
)
{
inParens
=
true
;
}
}
}
descriptors
.
FillCandidate
(
*
this
)
;
return
Type
(
)
!
=
eCandidateType_Invalid
;
}
bool
ResponsiveImageCandidate
:
:
HasSameParameter
(
const
ResponsiveImageCandidate
&
aOther
)
const
{
if
(
aOther
.
mType
!
=
mType
)
{
return
false
;
}
if
(
mType
=
=
eCandidateType_Default
)
{
return
true
;
}
if
(
mType
=
=
eCandidateType_Density
)
{
return
aOther
.
mValue
.
mDensity
=
=
mValue
.
mDensity
;
}
if
(
mType
=
=
eCandidateType_Invalid
)
{
MOZ_ASSERT
(
false
"
Comparing
invalid
candidates
?
"
)
;
return
true
;
}
else
if
(
mType
=
=
eCandidateType_ComputedFromWidth
)
{
return
aOther
.
mValue
.
mWidth
=
=
mValue
.
mWidth
;
}
MOZ_ASSERT
(
false
"
Somebody
forgot
to
check
for
all
uses
of
this
enum
"
)
;
return
false
;
}
const
nsAString
&
ResponsiveImageCandidate
:
:
URLString
(
)
const
{
return
mURLString
;
}
nsIPrincipal
*
ResponsiveImageCandidate
:
:
TriggeringPrincipal
(
)
const
{
return
mTriggeringPrincipal
;
}
double
ResponsiveImageCandidate
:
:
Density
(
ResponsiveImageSelector
*
aSelector
)
const
{
if
(
mType
=
=
eCandidateType_ComputedFromWidth
)
{
double
width
;
if
(
!
aSelector
-
>
ComputeFinalWidthForCurrentViewport
(
&
width
)
)
{
return
1
.
0
;
}
return
Density
(
width
)
;
}
MOZ_ASSERT
(
mType
=
=
eCandidateType_Default
|
|
mType
=
=
eCandidateType_Density
"
unhandled
candidate
type
"
)
;
return
Density
(
-
1
)
;
}
double
ResponsiveImageCandidate
:
:
Density
(
double
aMatchingWidth
)
const
{
if
(
mType
=
=
eCandidateType_Invalid
)
{
MOZ_ASSERT
(
false
"
Getting
density
for
uninitialized
candidate
"
)
;
return
1
.
0
;
}
if
(
mType
=
=
eCandidateType_Default
)
{
return
1
.
0
;
}
if
(
mType
=
=
eCandidateType_Density
)
{
return
mValue
.
mDensity
;
}
else
if
(
mType
=
=
eCandidateType_ComputedFromWidth
)
{
if
(
aMatchingWidth
<
0
)
{
MOZ_ASSERT
(
false
"
Don
'
t
expect
to
have
a
negative
matching
width
at
this
point
"
)
;
return
1
.
0
;
}
double
density
=
double
(
mValue
.
mWidth
)
/
aMatchingWidth
;
MOZ_ASSERT
(
density
>
0
.
0
)
;
return
density
;
}
MOZ_ASSERT
(
false
"
Unknown
candidate
type
"
)
;
return
1
.
0
;
}
bool
ResponsiveImageCandidate
:
:
IsComputedFromWidth
(
)
const
{
if
(
mType
=
=
eCandidateType_ComputedFromWidth
)
{
return
true
;
}
MOZ_ASSERT
(
mType
=
=
eCandidateType_Default
|
|
mType
=
=
eCandidateType_Density
"
Unknown
candidate
type
"
)
;
return
false
;
}
}
}
