#
ifndef
mozilla_dom_AbstractRange_h
#
define
mozilla_dom_AbstractRange_h
#
include
<
cstdint
>
#
include
<
ostream
>
#
include
"
ErrorList
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
JSObject
;
class
nsIContent
;
class
nsINode
;
class
nsRange
;
struct
JSContext
;
namespace
mozilla
:
:
dom
{
class
Document
;
class
Selection
;
class
StaticRange
;
enum
class
AllowRangeCrossShadowBoundary
:
bool
{
No
Yes
}
;
class
AbstractRange
:
public
nsISupports
public
nsWrapperCache
public
mozilla
:
:
LinkedListElement
<
AbstractRange
>
{
using
AllowRangeCrossShadowBoundary
=
mozilla
:
:
dom
:
:
AllowRangeCrossShadowBoundary
;
protected
:
explicit
AbstractRange
(
nsINode
*
aNode
bool
aIsDynamicRange
)
;
virtual
~
AbstractRange
(
)
;
public
:
AbstractRange
(
)
=
delete
;
explicit
AbstractRange
(
const
AbstractRange
&
aOther
)
=
delete
;
static
void
Shutdown
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
AbstractRange
)
const
RangeBoundary
&
StartRef
(
)
const
{
return
mStart
;
}
const
RangeBoundary
&
MayCrossShadowBoundaryStartRef
(
)
const
;
const
RangeBoundary
&
EndRef
(
)
const
{
return
mEnd
;
}
const
RangeBoundary
&
MayCrossShadowBoundaryEndRef
(
)
const
;
nsIContent
*
GetChildAtStartOffset
(
)
const
{
return
mStart
.
GetChildAtOffset
(
)
;
}
nsIContent
*
GetMayCrossShadowBoundaryChildAtStartOffset
(
)
const
;
nsIContent
*
GetChildAtEndOffset
(
)
const
{
return
mEnd
.
GetChildAtOffset
(
)
;
}
nsIContent
*
GetMayCrossShadowBoundaryChildAtEndOffset
(
)
const
;
bool
IsPositioned
(
)
const
{
return
mIsPositioned
;
}
nsINode
*
GetClosestCommonInclusiveAncestor
(
AllowRangeCrossShadowBoundary
aAllowCrossShadowBoundary
=
AllowRangeCrossShadowBoundary
:
:
No
)
const
;
nsINode
*
GetStartContainer
(
)
const
{
return
mStart
.
GetContainer
(
)
;
}
nsINode
*
GetMayCrossShadowBoundaryStartContainer
(
)
const
;
nsINode
*
GetEndContainer
(
)
const
{
return
mEnd
.
GetContainer
(
)
;
}
nsINode
*
GetMayCrossShadowBoundaryEndContainer
(
)
const
;
[
[
nodiscard
]
]
bool
IsPositionedAndSameContainer
(
)
const
{
return
MOZ_LIKELY
(
mIsPositioned
)
&
&
mStart
.
GetContainer
(
)
=
=
mEnd
.
GetContainer
(
)
;
}
[
[
nodiscard
]
]
bool
IsPositionedAndSameContainerMayCrossShadowBoundary
(
)
const
{
return
MOZ_LIKELY
(
mIsPositioned
)
&
&
GetMayCrossShadowBoundaryStartContainer
(
)
=
=
GetMayCrossShadowBoundaryEndContainer
(
)
;
}
bool
MayCrossShadowBoundary
(
)
const
;
Document
*
GetComposedDocOfContainers
(
)
const
{
return
mStart
.
GetComposedDoc
(
)
;
}
uint32_t
StartOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
*
mStart
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
;
}
uint32_t
MayCrossShadowBoundaryStartOffset
(
)
const
;
uint32_t
EndOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
*
mEnd
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
;
}
uint32_t
MayCrossShadowBoundaryEndOffset
(
)
const
;
bool
Collapsed
(
)
const
{
return
!
mIsPositioned
|
|
(
mStart
.
GetContainer
(
)
=
=
mEnd
.
GetContainer
(
)
&
&
StartOffset
(
)
=
=
EndOffset
(
)
)
;
}
bool
AreNormalRangeAndCrossShadowBoundaryRangeCollapsed
(
)
const
;
nsINode
*
GetParentObject
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
bool
HasEqualBoundaries
(
const
AbstractRange
&
aOther
)
const
{
return
(
mStart
=
=
aOther
.
mStart
)
&
&
(
mEnd
=
=
aOther
.
mEnd
)
;
}
bool
IsDynamicRange
(
)
const
{
return
mIsDynamicRange
;
}
bool
IsStaticRange
(
)
const
{
return
!
mIsDynamicRange
;
}
inline
nsRange
*
AsDynamicRange
(
)
;
inline
const
nsRange
*
AsDynamicRange
(
)
const
;
inline
StaticRange
*
AsStaticRange
(
)
;
inline
const
StaticRange
*
AsStaticRange
(
)
const
;
bool
IsInAnySelection
(
)
const
{
return
!
mSelections
.
IsEmpty
(
)
;
}
MOZ_CAN_RUN_SCRIPT
void
RegisterSelection
(
mozilla
:
:
dom
:
:
Selection
&
aSelection
)
;
void
UnregisterSelection
(
const
mozilla
:
:
dom
:
:
Selection
&
aSelection
)
;
const
nsTArray
<
WeakPtr
<
Selection
>
>
&
GetSelections
(
)
const
;
bool
IsInSelection
(
const
mozilla
:
:
dom
:
:
Selection
&
aSelection
)
const
;
static
bool
IsRootUAWidget
(
const
nsINode
*
aRoot
)
;
protected
:
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
typename
RangeType
>
static
nsresult
SetStartAndEndInternal
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
RangeType
*
aRange
)
;
template
<
class
RangeType
>
static
bool
MaybeCacheToReuse
(
RangeType
&
aInstance
)
;
void
Init
(
nsINode
*
aNode
)
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
AbstractRange
&
aRange
)
{
if
(
aRange
.
Collapsed
(
)
)
{
aStream
<
<
"
{
mStart
=
mEnd
=
"
<
<
aRange
.
mStart
;
}
else
{
aStream
<
<
"
{
mStart
=
"
<
<
aRange
.
mStart
<
<
"
mEnd
=
"
<
<
aRange
.
mEnd
;
}
return
aStream
<
<
"
mIsGenerated
=
"
<
<
(
aRange
.
mIsGenerated
?
"
true
"
:
"
false
"
)
<
<
"
mCalledByJS
=
"
<
<
(
aRange
.
mIsPositioned
?
"
true
"
:
"
false
"
)
<
<
"
mIsDynamicRange
=
"
<
<
(
aRange
.
mIsDynamicRange
?
"
true
"
:
"
false
"
)
<
<
"
}
"
;
}
void
RegisterClosestCommonInclusiveAncestor
(
nsINode
*
aNode
)
;
void
UnregisterClosestCommonInclusiveAncestor
(
bool
aIsUnlinking
=
false
)
;
void
UpdateCommonAncestorIfNecessary
(
)
;
static
void
MarkDescendants
(
const
nsINode
&
aNode
)
;
static
void
UnmarkDescendants
(
const
nsINode
&
aNode
)
;
private
:
void
ClearForReuse
(
)
;
protected
:
RefPtr
<
Document
>
mOwner
;
RangeBoundary
mStart
;
RangeBoundary
mEnd
;
AutoTArray
<
WeakPtr
<
Selection
>
1
>
mSelections
;
nsCOMPtr
<
nsINode
>
mRegisteredClosestCommonInclusiveAncestor
;
bool
mIsPositioned
;
bool
mIsGenerated
;
bool
mCalledByJS
;
const
bool
mIsDynamicRange
;
static
bool
sHasShutDown
;
}
;
}
#
endif
