#
ifndef
mozilla_dom_AbstractRange_h
#
define
mozilla_dom_AbstractRange_h
#
include
<
cstdint
>
#
include
"
ErrorList
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
RangeBoundary
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsWrapperCache
.
h
"
class
JSObject
;
class
nsIContent
;
class
nsINode
;
struct
JSContext
;
namespace
mozilla
:
:
dom
{
class
Document
;
class
AbstractRange
:
public
nsISupports
public
nsWrapperCache
{
protected
:
explicit
AbstractRange
(
nsINode
*
aNode
)
;
virtual
~
AbstractRange
(
)
;
public
:
AbstractRange
(
)
=
delete
;
explicit
AbstractRange
(
const
AbstractRange
&
aOther
)
=
delete
;
static
void
Shutdown
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
AbstractRange
)
const
RangeBoundary
&
StartRef
(
)
const
{
return
mStart
;
}
const
RangeBoundary
&
EndRef
(
)
const
{
return
mEnd
;
}
nsIContent
*
GetChildAtStartOffset
(
)
const
{
return
mStart
.
GetChildAtOffset
(
)
;
}
nsIContent
*
GetChildAtEndOffset
(
)
const
{
return
mEnd
.
GetChildAtOffset
(
)
;
}
bool
IsPositioned
(
)
const
{
return
mIsPositioned
;
}
nsINode
*
GetClosestCommonInclusiveAncestor
(
)
const
;
nsINode
*
GetStartContainer
(
)
const
{
return
mStart
.
Container
(
)
;
}
nsINode
*
GetEndContainer
(
)
const
{
return
mEnd
.
Container
(
)
;
}
uint32_t
StartOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
*
mStart
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
;
}
uint32_t
EndOffset
(
)
const
{
return
static_cast
<
uint32_t
>
(
*
mEnd
.
Offset
(
RangeBoundary
:
:
OffsetFilter
:
:
kValidOrInvalidOffsets
)
)
;
}
bool
Collapsed
(
)
const
{
return
!
mIsPositioned
|
|
(
mStart
.
Container
(
)
=
=
mEnd
.
Container
(
)
&
&
StartOffset
(
)
=
=
EndOffset
(
)
)
;
}
nsINode
*
GetParentObject
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
bool
HasEqualBoundaries
(
const
AbstractRange
&
aOther
)
const
{
return
(
mStart
=
=
aOther
.
mStart
)
&
&
(
mEnd
=
=
aOther
.
mEnd
)
;
}
protected
:
template
<
typename
SPT
typename
SRT
typename
EPT
typename
ERT
typename
RangeType
>
static
nsresult
SetStartAndEndInternal
(
const
RangeBoundaryBase
<
SPT
SRT
>
&
aStartBoundary
const
RangeBoundaryBase
<
EPT
ERT
>
&
aEndBoundary
RangeType
*
aRange
)
;
template
<
class
RangeType
>
static
bool
MaybeCacheToReuse
(
RangeType
&
aInstance
)
;
void
Init
(
nsINode
*
aNode
)
;
private
:
void
ClearForReuse
(
)
;
protected
:
RefPtr
<
Document
>
mOwner
;
RangeBoundary
mStart
;
RangeBoundary
mEnd
;
bool
mIsPositioned
;
bool
mIsGenerated
;
bool
mCalledByJS
;
static
bool
sHasShutDown
;
}
;
}
#
endif
