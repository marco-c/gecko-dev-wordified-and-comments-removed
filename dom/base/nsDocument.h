#
ifndef
nsDocument_h___
#
define
nsDocument_h___
#
include
"
nsIDocument
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
nsWeakPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIdentifierMapEntry
.
h
"
#
include
"
nsStubDocumentObserver
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsJSThingHashtable
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIRadioGroupContainer
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsIChannel
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
dom
/
BoxObject
.
h
"
#
include
"
mozilla
/
dom
/
DOMImplementation
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetList
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsIURIClassifier
.
h
"
#
define
XML_DECLARATION_BITS_DECLARATION_EXISTS
(
1
<
<
0
)
#
define
XML_DECLARATION_BITS_ENCODING_EXISTS
(
1
<
<
1
)
#
define
XML_DECLARATION_BITS_STANDALONE_EXISTS
(
1
<
<
2
)
#
define
XML_DECLARATION_BITS_STANDALONE_YES
(
1
<
<
3
)
class
nsDOMStyleSheetSetList
;
class
nsDocument
;
class
nsIRadioVisitor
;
class
nsIFormControl
;
struct
nsRadioGroupStruct
;
class
nsOnloadBlocker
;
class
nsDOMNavigationTiming
;
class
nsWindowSizes
;
class
nsHtml5TreeOpExecutor
;
class
nsDocumentOnStack
;
class
nsISecurityConsoleMessage
;
namespace
mozilla
{
class
EventChainPreVisitor
;
namespace
dom
{
class
ImageTracker
;
struct
LifecycleCallbacks
;
class
CallbackFunction
;
class
DOMIntersectionObserver
;
class
Performance
;
struct
FullscreenRequest
:
public
LinkedListElement
<
FullscreenRequest
>
{
explicit
FullscreenRequest
(
Element
*
aElement
)
;
FullscreenRequest
(
const
FullscreenRequest
&
)
=
delete
;
~
FullscreenRequest
(
)
;
Element
*
GetElement
(
)
const
{
return
mElement
;
}
nsIDocument
*
GetDocument
(
)
const
{
return
mDocument
;
}
private
:
RefPtr
<
Element
>
mElement
;
RefPtr
<
nsIDocument
>
mDocument
;
public
:
bool
mIsCallerChrome
=
false
;
bool
mShouldNotifyNewOrigin
=
true
;
}
;
}
}
class
nsOnloadBlocker
final
:
public
nsIRequest
{
public
:
nsOnloadBlocker
(
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUEST
private
:
~
nsOnloadBlocker
(
)
{
}
}
;
class
nsDocument
:
public
nsIDocument
public
nsSupportsWeakReference
public
nsIScriptObjectPrincipal
public
nsIRadioGroupContainer
public
nsIApplicationCacheContainer
public
nsStubMutationObserver
{
friend
class
nsIDocument
;
public
:
typedef
mozilla
:
:
dom
:
:
Element
Element
;
typedef
mozilla
:
:
net
:
:
ReferrerPolicy
ReferrerPolicy
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
=
true
nsIContentSink
*
aContentSink
=
nullptr
)
override
=
0
;
virtual
void
StopDocumentLoad
(
)
override
;
static
bool
IsWebAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsWebAnimationsEnabled
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
virtual
void
EndUpdate
(
)
override
;
virtual
void
BeginLoad
(
)
override
;
virtual
void
EndLoad
(
)
override
;
NS_IMETHOD
WalkRadioGroup
(
const
nsAString
&
aName
nsIRadioVisitor
*
aVisitor
bool
aFlushContent
)
override
;
virtual
void
SetCurrentRadioButton
(
const
nsAString
&
aName
mozilla
:
:
dom
:
:
HTMLInputElement
*
aRadio
)
override
;
virtual
mozilla
:
:
dom
:
:
HTMLInputElement
*
GetCurrentRadioButton
(
const
nsAString
&
aName
)
override
;
NS_IMETHOD
GetNextRadioButton
(
const
nsAString
&
aName
const
bool
aPrevious
mozilla
:
:
dom
:
:
HTMLInputElement
*
aFocusedRadio
mozilla
:
:
dom
:
:
HTMLInputElement
*
*
aRadioOut
)
override
;
virtual
void
AddToRadioGroup
(
const
nsAString
&
aName
mozilla
:
:
dom
:
:
HTMLInputElement
*
aRadio
)
override
;
virtual
void
RemoveFromRadioGroup
(
const
nsAString
&
aName
mozilla
:
:
dom
:
:
HTMLInputElement
*
aRadio
)
override
;
virtual
uint32_t
GetRequiredRadioCount
(
const
nsAString
&
aName
)
const
override
;
virtual
void
RadioRequiredWillChange
(
const
nsAString
&
aName
bool
aRequiredAdded
)
override
;
virtual
bool
GetValueMissingState
(
const
nsAString
&
aName
)
const
override
;
virtual
void
SetValueMissingState
(
const
nsAString
&
aName
bool
aValue
)
override
;
nsRadioGroupStruct
*
GetRadioGroup
(
const
nsAString
&
aName
)
const
;
nsRadioGroupStruct
*
GetOrCreateRadioGroup
(
const
nsAString
&
aName
)
;
static
bool
IsShadowDOMEnabled
(
JSContext
*
aCx
JSObject
*
aGlobal
)
;
static
bool
IsShadowDOMEnabledAndCallerIsChromeOrAddon
(
JSContext
*
aCx
JSObject
*
aObject
)
;
static
bool
IsShadowDOMEnabled
(
const
nsINode
*
aNode
)
;
public
:
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementById
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByTagName
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByTagNameNS
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByClassName
;
void
GetEventTargetParent
(
mozilla
:
:
EventChainPreVisitor
&
aVisitor
)
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
virtual
nsIPrincipal
*
GetPrincipal
(
)
override
;
NS_DECL_NSIAPPLICATIONCACHECONTAINER
virtual
nsresult
Init
(
)
;
virtual
void
Destroy
(
)
override
;
virtual
void
RemovedFromDocShell
(
)
override
;
virtual
void
BlockOnload
(
)
override
;
virtual
void
UnblockOnload
(
bool
aFireSync
)
override
;
NS_DECL_CYCLE_COLLECTION_SKIPPABLE_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsDocument
nsIDocument
)
void
SetLoadedAsData
(
bool
aLoadedAsData
)
{
mLoadedAsData
=
aLoadedAsData
;
}
void
SetLoadedAsInteractiveData
(
bool
aLoadedAsInteractiveData
)
{
mLoadedAsInteractiveData
=
aLoadedAsInteractiveData
;
}
nsresult
CloneDocHelper
(
nsDocument
*
clone
bool
aPreallocateChildren
)
const
;
void
AsyncBlockOnload
(
)
;
virtual
void
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
override
;
protected
:
friend
class
nsNodeUtils
;
void
RetrieveRelevantHeaders
(
nsIChannel
*
aChannel
)
;
void
TryChannelCharset
(
nsIChannel
*
aChannel
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
nsHtml5TreeOpExecutor
*
aExecutor
)
;
nsIContent
*
GetFirstBaseNodeWithHref
(
)
;
nsresult
SetFirstBaseNodeWithHref
(
nsIContent
*
node
)
;
#
define
NS_DOCUMENT_NOTIFY_OBSERVERS
(
func_
params_
)
do
{
\
NS_OBSERVER_ARRAY_NOTIFY_XPCOM_OBSERVERS
(
mObservers
nsIDocumentObserver
\
func_
params_
)
;
\
/
*
FIXME
(
emilio
)
:
Apparently
we
can
keep
observing
from
the
BFCache
?
That
\
looks
bogus
.
*
/
\
if
(
nsIPresShell
*
shell
=
GetObservingShell
(
)
)
{
\
shell
-
>
func_
params_
;
\
}
\
}
while
(
0
)
#
ifdef
DEBUG
void
VerifyRootContentState
(
)
;
#
endif
explicit
nsDocument
(
const
char
*
aContentType
)
;
virtual
~
nsDocument
(
)
;
public
:
js
:
:
ExpandoAndGeneration
mExpandoAndGeneration
;
nsClassHashtable
<
nsStringHashKey
nsRadioGroupStruct
>
mRadioGroups
;
friend
class
nsCallRequestFullScreen
;
nsCOMPtr
<
nsIApplicationCache
>
mApplicationCache
;
nsCOMPtr
<
nsIContent
>
mFirstBaseNodeWithHref
;
private
:
friend
class
nsUnblockOnloadEvent
;
nsDocument
(
const
nsDocument
&
aOther
)
;
nsDocument
&
operator
=
(
const
nsDocument
&
aOther
)
;
}
;
class
nsDocumentOnStack
{
public
:
explicit
nsDocumentOnStack
(
nsIDocument
*
aDoc
)
:
mDoc
(
aDoc
)
{
mDoc
-
>
IncreaseStackRefCnt
(
)
;
}
~
nsDocumentOnStack
(
)
{
mDoc
-
>
DecreaseStackRefCnt
(
)
;
}
private
:
nsIDocument
*
mDoc
;
}
;
#
endif
