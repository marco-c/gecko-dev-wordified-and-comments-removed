#
ifndef
AttrArray_h___
#
define
AttrArray_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
dom
/
BorrowedAttrInfo
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsCaseTreatment
.
h
"
namespace
mozilla
{
class
AttributeStyles
;
struct
StyleLockedDeclarationBlock
;
}
class
AttrArray
{
using
BorrowedAttrInfo
=
mozilla
:
:
dom
:
:
BorrowedAttrInfo
;
public
:
AttrArray
(
)
=
default
;
~
AttrArray
(
)
=
default
;
bool
HasAttrs
(
)
const
{
return
!
!
AttrCount
(
)
;
}
uint32_t
AttrCount
(
)
const
{
return
mImpl
?
mImpl
-
>
mAttrCount
:
0
;
}
const
nsAttrValue
*
GetAttr
(
const
nsAtom
*
aLocalName
)
const
;
const
nsAttrValue
*
GetAttr
(
const
nsAtom
*
aLocalName
int32_t
aNamespaceID
)
const
;
const
nsAttrValue
*
GetAttr
(
const
nsAString
&
aName
)
const
;
const
nsAttrValue
*
GetAttr
(
const
nsAString
&
aName
nsCaseTreatment
aCaseSensitive
)
const
;
const
nsAttrValue
*
AttrAt
(
uint32_t
aPos
)
const
;
nsresult
SetAndSwapAttr
(
nsAtom
*
aLocalName
nsAttrValue
&
aValue
bool
*
aHadValue
)
;
nsresult
SetAndSwapAttr
(
mozilla
:
:
dom
:
:
NodeInfo
*
aName
nsAttrValue
&
aValue
bool
*
aHadValue
)
;
void
SetMappedDeclarationBlock
(
already_AddRefed
<
mozilla
:
:
StyleLockedDeclarationBlock
>
)
;
bool
IsPendingMappedAttributeEvaluation
(
)
const
{
return
mImpl
&
&
mImpl
-
>
mMappedAttributeBits
&
1
;
}
mozilla
:
:
StyleLockedDeclarationBlock
*
GetMappedDeclarationBlock
(
)
const
{
return
mImpl
?
mImpl
-
>
GetMappedDeclarationBlock
(
)
:
nullptr
;
}
nsresult
RemoveAttrAt
(
uint32_t
aPos
nsAttrValue
&
aValue
)
;
const
nsAttrName
*
AttrNameAt
(
uint32_t
aPos
)
const
;
BorrowedAttrInfo
AttrInfoAt
(
uint32_t
aPos
)
const
;
const
nsAttrName
*
GetSafeAttrNameAt
(
uint32_t
aPos
)
const
;
const
nsAttrName
*
GetExistingAttrNameFromQName
(
const
nsAString
&
aName
)
const
;
int32_t
IndexOfAttr
(
const
nsAtom
*
aLocalName
)
const
;
int32_t
IndexOfAttr
(
const
nsAtom
*
aLocalName
int32_t
aNamespaceID
)
const
;
void
Compact
(
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
bool
MarkAsPendingPresAttributeEvaluation
(
)
{
if
(
MOZ_UNLIKELY
(
!
mImpl
)
&
&
!
GrowBy
(
1
)
)
{
return
false
;
}
InfallibleMarkAsPendingPresAttributeEvaluation
(
)
;
return
true
;
}
void
InfallibleMarkAsPendingPresAttributeEvaluation
(
)
{
MOZ_ASSERT
(
mImpl
)
;
mImpl
-
>
mMappedAttributeBits
|
=
1
;
}
void
ClearMappedServoStyle
(
)
;
nsresult
EnsureCapacityToClone
(
const
AttrArray
&
aOther
)
;
enum
AttrValuesState
{
ATTR_MISSING
=
-
1
ATTR_VALUE_NO_MATCH
=
-
2
}
;
using
AttrValuesArray
=
nsStaticAtom
*
const
;
int32_t
FindAttrValueIn
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
AttrValuesArray
*
aValues
nsCaseTreatment
aCaseSensitive
)
const
;
inline
bool
GetAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
nsAString
&
aResult
)
const
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
"
Should
have
empty
string
coming
in
"
)
;
const
nsAttrValue
*
val
=
GetAttr
(
aName
aNameSpaceID
)
;
if
(
!
val
)
{
return
false
;
}
val
-
>
ToString
(
aResult
)
;
return
true
;
}
inline
bool
GetAttr
(
const
nsAtom
*
aName
nsAString
&
aResult
)
const
{
MOZ_ASSERT
(
aResult
.
IsEmpty
(
)
"
Should
have
empty
string
coming
in
"
)
;
const
nsAttrValue
*
val
=
GetAttr
(
aName
)
;
if
(
!
val
)
{
return
false
;
}
val
-
>
ToString
(
aResult
)
;
return
true
;
}
inline
bool
HasAttr
(
const
nsAtom
*
aName
)
const
{
return
!
!
GetAttr
(
aName
)
;
}
inline
bool
HasAttr
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
)
const
{
return
!
!
GetAttr
(
aName
aNameSpaceID
)
;
}
inline
bool
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAString
&
aValue
nsCaseTreatment
aCaseSensitive
)
const
{
NS_ASSERTION
(
aName
"
Must
have
attr
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
const
nsAttrValue
*
val
=
GetAttr
(
aName
aNameSpaceID
)
;
return
val
&
&
val
-
>
Equals
(
aValue
aCaseSensitive
)
;
}
inline
bool
AttrValueIs
(
int32_t
aNameSpaceID
const
nsAtom
*
aName
const
nsAtom
*
aValue
nsCaseTreatment
aCaseSensitive
)
const
{
NS_ASSERTION
(
aName
"
Must
have
attr
name
"
)
;
NS_ASSERTION
(
aNameSpaceID
!
=
kNameSpaceID_Unknown
"
Must
have
namespace
"
)
;
NS_ASSERTION
(
aValue
"
Null
value
atom
"
)
;
const
nsAttrValue
*
val
=
GetAttr
(
aName
aNameSpaceID
)
;
return
val
&
&
val
-
>
Equals
(
aValue
aCaseSensitive
)
;
}
struct
InternalAttr
{
nsAttrName
mName
;
nsAttrValue
mValue
;
}
;
AttrArray
(
const
AttrArray
&
aOther
)
=
delete
;
AttrArray
&
operator
=
(
const
AttrArray
&
aOther
)
=
delete
;
bool
GrowBy
(
uint32_t
aGrowSize
)
;
bool
GrowTo
(
uint32_t
aCapacity
)
;
private
:
template
<
typename
Name
>
nsresult
AddNewAttribute
(
Name
*
nsAttrValue
&
)
;
class
Impl
{
public
:
constexpr
static
size_t
AllocationSizeForAttributes
(
uint32_t
aAttrCount
)
{
return
sizeof
(
Impl
)
+
aAttrCount
*
sizeof
(
InternalAttr
)
;
}
mozilla
:
:
StyleLockedDeclarationBlock
*
GetMappedDeclarationBlock
(
)
const
{
return
reinterpret_cast
<
mozilla
:
:
StyleLockedDeclarationBlock
*
>
(
mMappedAttributeBits
&
~
uintptr_t
(
1
)
)
;
}
auto
Attrs
(
)
const
{
return
mozilla
:
:
Span
<
const
InternalAttr
>
{
mBuffer
mAttrCount
}
;
}
auto
Attrs
(
)
{
return
mozilla
:
:
Span
<
InternalAttr
>
{
mBuffer
mAttrCount
}
;
}
Impl
(
const
Impl
&
)
=
delete
;
Impl
(
Impl
&
&
)
=
delete
;
~
Impl
(
)
;
uint32_t
mAttrCount
;
uint32_t
mCapacity
;
uintptr_t
mMappedAttributeBits
=
0
;
InternalAttr
mBuffer
[
0
]
;
}
;
mozilla
:
:
Span
<
InternalAttr
>
Attrs
(
)
{
return
mImpl
?
mImpl
-
>
Attrs
(
)
:
mozilla
:
:
Span
<
InternalAttr
>
(
)
;
}
mozilla
:
:
Span
<
const
InternalAttr
>
Attrs
(
)
const
{
return
mImpl
?
mImpl
-
>
Attrs
(
)
:
mozilla
:
:
Span
<
const
InternalAttr
>
(
)
;
}
mozilla
:
:
UniquePtr
<
Impl
>
mImpl
;
}
;
#
endif
