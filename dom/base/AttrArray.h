#
ifndef
AttrArray_h___
#
define
AttrArray_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
BorrowedAttrInfo
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsCaseTreatment
.
h
"
class
nsINode
;
class
nsIContent
;
class
nsMappedAttributes
;
class
nsHTMLStyleSheet
;
class
nsRuleWalker
;
class
nsMappedAttributeElement
;
#
define
ATTRCHILD_ARRAY_GROWSIZE
8
#
define
ATTRCHILD_ARRAY_LINEAR_THRESHOLD
32
#
define
ATTRSIZE
(
sizeof
(
InternalAttr
)
/
sizeof
(
void
*
)
)
class
AttrArray
{
typedef
mozilla
:
:
dom
:
:
BorrowedAttrInfo
BorrowedAttrInfo
;
public
:
AttrArray
(
)
;
~
AttrArray
(
)
;
bool
HasAttrs
(
)
const
{
return
MappedAttrCount
(
)
|
|
(
AttrSlotCount
(
)
&
&
AttrSlotIsTaken
(
0
)
)
;
}
uint32_t
AttrCount
(
)
const
;
const
nsAttrValue
*
GetAttr
(
nsAtom
*
aLocalName
int32_t
aNamespaceID
=
kNameSpaceID_None
)
const
;
const
nsAttrValue
*
GetAttr
(
const
nsAString
&
aName
)
const
;
const
nsAttrValue
*
GetAttr
(
const
nsAString
&
aName
nsCaseTreatment
aCaseSensitive
)
const
;
const
nsAttrValue
*
AttrAt
(
uint32_t
aPos
)
const
;
nsresult
SetAndSwapAttr
(
nsAtom
*
aLocalName
nsAttrValue
&
aValue
bool
*
aHadValue
)
;
nsresult
SetAndSwapAttr
(
mozilla
:
:
dom
:
:
NodeInfo
*
aName
nsAttrValue
&
aValue
bool
*
aHadValue
)
;
nsresult
RemoveAttrAt
(
uint32_t
aPos
nsAttrValue
&
aValue
)
;
const
nsAttrName
*
AttrNameAt
(
uint32_t
aPos
)
const
;
BorrowedAttrInfo
AttrInfoAt
(
uint32_t
aPos
)
const
;
const
nsAttrName
*
GetSafeAttrNameAt
(
uint32_t
aPos
)
const
;
const
nsAttrName
*
GetExistingAttrNameFromQName
(
const
nsAString
&
aName
)
const
;
int32_t
IndexOfAttr
(
nsAtom
*
aLocalName
int32_t
aNamespaceID
=
kNameSpaceID_None
)
const
;
nsresult
SetAndSwapMappedAttr
(
nsAtom
*
aLocalName
nsAttrValue
&
aValue
nsMappedAttributeElement
*
aContent
nsHTMLStyleSheet
*
aSheet
bool
*
aHadValue
)
;
nsresult
SetMappedAttrStyleSheet
(
nsHTMLStyleSheet
*
aSheet
)
{
if
(
!
mImpl
|
|
!
mImpl
-
>
mMappedAttrs
)
{
return
NS_OK
;
}
return
DoSetMappedAttrStyleSheet
(
aSheet
)
;
}
nsresult
UpdateMappedAttrRuleMapper
(
nsMappedAttributeElement
&
aElement
)
{
if
(
!
mImpl
|
|
!
mImpl
-
>
mMappedAttrs
)
{
return
NS_OK
;
}
return
DoUpdateMappedAttrRuleMapper
(
aElement
)
;
}
void
Compact
(
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
bool
HasMappedAttrs
(
)
const
{
return
MappedAttrCount
(
)
;
}
const
nsMappedAttributes
*
GetMapped
(
)
const
;
nsresult
ForceMapped
(
nsMappedAttributeElement
*
aContent
nsIDocument
*
aDocument
)
;
void
ClearMappedServoStyle
(
)
;
nsresult
EnsureCapacityToClone
(
const
AttrArray
&
aOther
bool
aAllocateChildren
)
;
private
:
AttrArray
(
const
AttrArray
&
aOther
)
=
delete
;
AttrArray
&
operator
=
(
const
AttrArray
&
aOther
)
=
delete
;
void
Clear
(
)
;
uint32_t
NonMappedAttrCount
(
)
const
;
uint32_t
MappedAttrCount
(
)
const
;
nsMappedAttributes
*
GetModifiableMapped
(
nsMappedAttributeElement
*
aContent
nsHTMLStyleSheet
*
aSheet
bool
aWillAddAttr
int32_t
aAttrCount
=
1
)
;
nsresult
MakeMappedUnique
(
nsMappedAttributes
*
aAttributes
)
;
uint32_t
AttrSlotsSize
(
)
const
{
return
AttrSlotCount
(
)
*
ATTRSIZE
;
}
uint32_t
AttrSlotCount
(
)
const
{
return
mImpl
?
mImpl
-
>
mAttrCount
:
0
;
}
bool
AttrSlotIsTaken
(
uint32_t
aSlot
)
const
{
MOZ_ASSERT
(
aSlot
<
AttrSlotCount
(
)
"
out
-
of
-
bounds
"
)
;
return
mImpl
-
>
mBuffer
[
aSlot
*
ATTRSIZE
]
;
}
void
SetAttrSlotCount
(
uint32_t
aCount
)
{
mImpl
-
>
mAttrCount
=
aCount
;
}
bool
GrowBy
(
uint32_t
aGrowSize
)
;
bool
AddAttrSlot
(
)
;
nsresult
DoSetMappedAttrStyleSheet
(
nsHTMLStyleSheet
*
aSheet
)
;
nsresult
DoUpdateMappedAttrRuleMapper
(
nsMappedAttributeElement
&
aElement
)
;
struct
InternalAttr
{
nsAttrName
mName
;
nsAttrValue
mValue
;
}
;
struct
Impl
{
uint32_t
mAttrCount
;
uint32_t
mBufferSize
;
nsMappedAttributes
*
mMappedAttrs
;
void
*
mBuffer
[
1
]
;
}
;
Impl
*
mImpl
;
}
;
#
endif
