#
ifndef
nsINode_h___
#
define
nsINode_h___
#
include
"
mozilla
/
DoublyLinkedList
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsIMutationObserver
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsPropertyTable
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
dom
/
DOMString
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
NodeBinding
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
<
iosfwd
>
#
ifdef
XP_WIN
#
ifdef
GetClassInfo
#
undef
GetClassInfo
#
endif
#
endif
class
AttrArray
;
class
nsAttrChildContentList
;
template
<
typename
T
>
class
nsCOMArray
;
class
nsDOMAttributeMap
;
class
nsGenericHTMLElement
;
class
nsIAnimationObserver
;
class
nsIContent
;
class
nsIContentSecurityPolicy
;
class
nsIFrame
;
class
nsIHTMLCollection
;
class
nsMultiMutationObserver
;
class
nsINode
;
class
nsINodeList
;
class
nsIPrincipal
;
class
nsIURI
;
class
nsNodeSupportsWeakRefTearoff
;
class
nsDOMMutationObserver
;
class
nsRange
;
class
nsWindowSizes
;
struct
RawServoSelectorList
;
namespace
mozilla
{
class
EventListenerManager
;
template
<
typename
T
>
class
Maybe
;
class
PresShell
;
class
TextEditor
;
namespace
dom
{
inline
bool
IsSpaceCharacter
(
char16_t
aChar
)
{
return
aChar
=
=
'
'
|
|
aChar
=
=
'
\
t
'
|
|
aChar
=
=
'
\
n
'
|
|
aChar
=
=
'
\
r
'
|
|
aChar
=
=
'
\
f
'
;
}
inline
bool
IsSpaceCharacter
(
char
aChar
)
{
return
aChar
=
=
'
'
|
|
aChar
=
=
'
\
t
'
|
|
aChar
=
=
'
\
n
'
|
|
aChar
=
=
'
\
r
'
|
|
aChar
=
=
'
\
f
'
;
}
class
AccessibleNode
;
template
<
typename
T
>
class
AncestorsOfTypeIterator
;
struct
BoxQuadOptions
;
struct
ConvertCoordinateOptions
;
class
DocGroup
;
class
Document
;
class
DocumentFragment
;
class
DocumentOrShadowRoot
;
class
DOMPoint
;
class
DOMQuad
;
class
DOMRectReadOnly
;
class
Element
;
class
EventHandlerNonNull
;
template
<
typename
T
>
class
FlatTreeAncestorsOfTypeIterator
;
template
<
typename
T
>
class
InclusiveAncestorsOfTypeIterator
;
template
<
typename
T
>
class
InclusiveFlatTreeAncestorsOfTypeIterator
;
class
LinkStyle
;
class
MutationObservers
;
template
<
typename
T
>
class
Optional
;
class
OwningNodeOrString
;
template
<
typename
>
class
Sequence
;
class
ShadowRoot
;
class
SVGUseElement
;
class
Text
;
class
TextOrElementOrDocument
;
struct
DOMPointInit
;
struct
GetRootNodeOptions
;
enum
class
CallerType
:
uint32_t
;
}
}
#
define
NODE_FLAG_BIT
(
n_
)
\
(
nsWrapperCache
:
:
FlagsType
(
1U
)
<
<
(
WRAPPER_CACHE_FLAGS_BITS_USED
+
(
n_
)
)
)
enum
:
uint32_t
{
NODE_HAS_LISTENERMANAGER
=
NODE_FLAG_BIT
(
0
)
NODE_HAS_PROPERTIES
=
NODE_FLAG_BIT
(
1
)
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
=
NODE_FLAG_BIT
(
2
)
NODE_IS_NATIVE_ANONYMOUS_ROOT
=
NODE_FLAG_BIT
(
3
)
NODE_IS_EDITABLE
=
NODE_FLAG_BIT
(
4
)
NODE_IS_IN_SHADOW_TREE
=
NODE_FLAG_BIT
(
5
)
NODE_HAS_EMPTY_SELECTOR
=
NODE_FLAG_BIT
(
6
)
NODE_HAS_SLOW_SELECTOR
=
NODE_FLAG_BIT
(
7
)
NODE_HAS_EDGE_CHILD_SELECTOR
=
NODE_FLAG_BIT
(
8
)
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
=
NODE_FLAG_BIT
(
9
)
NODE_HAS_SLOW_SELECTOR_NTH_OF
=
NODE_FLAG_BIT
(
10
)
NODE_ALL_SELECTOR_FLAGS
=
NODE_HAS_EMPTY_SELECTOR
|
NODE_HAS_SLOW_SELECTOR
|
NODE_HAS_EDGE_CHILD_SELECTOR
|
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
|
NODE_HAS_SLOW_SELECTOR_NTH_OF
NODE_NEEDS_FRAME
=
NODE_FLAG_BIT
(
11
)
NODE_DESCENDANTS_NEED_FRAMES
=
NODE_FLAG_BIT
(
12
)
NODE_HAS_ACCESSKEY
=
NODE_FLAG_BIT
(
13
)
NODE_HAS_DIRECTION_RTL
=
NODE_FLAG_BIT
(
14
)
NODE_HAS_DIRECTION_LTR
=
NODE_FLAG_BIT
(
15
)
NODE_ALL_DIRECTION_FLAGS
=
NODE_HAS_DIRECTION_LTR
|
NODE_HAS_DIRECTION_RTL
NODE_HAS_BEEN_IN_UA_WIDGET
=
NODE_FLAG_BIT
(
16
)
NODE_HAS_NONCE_AND_HEADER_CSP
=
NODE_FLAG_BIT
(
17
)
NODE_KEEPS_DOMARENA
=
NODE_FLAG_BIT
(
18
)
NODE_MAY_HAVE_ELEMENT_CHILDREN
=
NODE_FLAG_BIT
(
19
)
NODE_TYPE_SPECIFIC_BITS_OFFSET
=
20
}
;
#
define
ASSERT_NODE_FLAGS_SPACE
(
n
)
\
static_assert
(
WRAPPER_CACHE_FLAGS_BITS_USED
+
(
n
)
<
=
\
sizeof
(
nsWrapperCache
:
:
FlagsType
)
*
8
\
"
Not
enough
space
for
our
bits
"
)
ASSERT_NODE_FLAGS_SPACE
(
NODE_TYPE_SPECIFIC_BITS_OFFSET
)
;
class
nsMutationGuard
{
public
:
nsMutationGuard
(
)
{
mStartingGeneration
=
sGeneration
;
}
bool
Mutated
(
uint8_t
aIgnoreCount
)
{
return
(
sGeneration
-
mStartingGeneration
)
>
aIgnoreCount
;
}
static
void
DidMutate
(
)
{
sGeneration
+
+
;
}
private
:
uint64_t
mStartingGeneration
;
static
uint64_t
sGeneration
;
}
;
class
nsNodeWeakReference
final
:
public
nsIWeakReference
{
public
:
explicit
nsNodeWeakReference
(
nsINode
*
aNode
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIWEAKREFERENCE
void
NoticeNodeDestruction
(
)
{
mObject
=
nullptr
;
}
private
:
~
nsNodeWeakReference
(
)
;
}
;
#
define
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
\
virtual
void
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
\
size_t
*
aNodeSize
)
const
override
;
#
define
NS_INODE_IID
\
{
\
0x70ba4547
0x7699
0x44fc
{
\
0xb3
0x20
0x52
0xdb
0xe3
0xd1
0xf9
0x0a
\
}
\
}
class
nsINode
:
public
mozilla
:
:
dom
:
:
EventTarget
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
void
AssertInvariantsOnNodeInfoChange
(
)
;
#
endif
public
:
using
BoxQuadOptions
=
mozilla
:
:
dom
:
:
BoxQuadOptions
;
using
ConvertCoordinateOptions
=
mozilla
:
:
dom
:
:
ConvertCoordinateOptions
;
using
DocGroup
=
mozilla
:
:
dom
:
:
DocGroup
;
using
Document
=
mozilla
:
:
dom
:
:
Document
;
using
DOMPoint
=
mozilla
:
:
dom
:
:
DOMPoint
;
using
DOMPointInit
=
mozilla
:
:
dom
:
:
DOMPointInit
;
using
DOMQuad
=
mozilla
:
:
dom
:
:
DOMQuad
;
using
DOMRectReadOnly
=
mozilla
:
:
dom
:
:
DOMRectReadOnly
;
using
OwningNodeOrString
=
mozilla
:
:
dom
:
:
OwningNodeOrString
;
using
TextOrElementOrDocument
=
mozilla
:
:
dom
:
:
TextOrElementOrDocument
;
using
CallerType
=
mozilla
:
:
dom
:
:
CallerType
;
using
ErrorResult
=
mozilla
:
:
ErrorResult
;
static
const
auto
ELEMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ELEMENT_NODE
;
static
const
auto
ATTRIBUTE_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ATTRIBUTE_NODE
;
static
const
auto
TEXT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
TEXT_NODE
;
static
const
auto
CDATA_SECTION_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
CDATA_SECTION_NODE
;
static
const
auto
ENTITY_REFERENCE_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ENTITY_REFERENCE_NODE
;
static
const
auto
ENTITY_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ENTITY_NODE
;
static
const
auto
PROCESSING_INSTRUCTION_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
PROCESSING_INSTRUCTION_NODE
;
static
const
auto
COMMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
COMMENT_NODE
;
static
const
auto
DOCUMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
DOCUMENT_NODE
;
static
const
auto
DOCUMENT_TYPE_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
DOCUMENT_TYPE_NODE
;
static
const
auto
DOCUMENT_FRAGMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
DOCUMENT_FRAGMENT_NODE
;
static
const
auto
NOTATION_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
NOTATION_NODE
;
static
const
auto
MAX_NODE_TYPE
=
NOTATION_NODE
;
void
*
operator
new
(
size_t
aSize
nsNodeInfoManager
*
aManager
)
;
void
*
operator
new
(
size_t
aSize
)
=
delete
;
void
operator
delete
(
void
*
aPtr
)
;
template
<
class
T
>
using
Sequence
=
mozilla
:
:
dom
:
:
Sequence
<
T
>
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_INODE_IID
)
virtual
void
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
;
friend
class
nsNodeWeakReference
;
friend
class
nsNodeSupportsWeakRefTearoff
;
friend
class
AttrArray
;
#
ifdef
MOZILLA_INTERNAL_API
explicit
nsINode
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
;
#
endif
virtual
~
nsINode
(
)
;
bool
IsContainerNode
(
)
const
{
return
IsElement
(
)
|
|
IsDocument
(
)
|
|
IsDocumentFragment
(
)
;
}
bool
IsTemplateElement
(
)
const
{
return
IsHTMLElement
(
nsGkAtoms
:
:
_template
)
;
}
bool
IsSlotable
(
)
const
{
return
IsElement
(
)
|
|
IsText
(
)
;
}
bool
IsDocument
(
)
const
{
return
!
GetParentNode
(
)
&
&
IsInUncomposedDoc
(
)
;
}
inline
Document
*
AsDocument
(
)
;
inline
const
Document
*
AsDocument
(
)
const
;
bool
IsDocumentFragment
(
)
const
{
return
NodeType
(
)
=
=
DOCUMENT_FRAGMENT_NODE
;
}
virtual
bool
IsHTMLFormControlElement
(
)
const
{
return
false
;
}
bool
IsInclusiveDescendantOf
(
const
nsINode
*
aNode
)
const
;
bool
IsShadowIncludingInclusiveDescendantOf
(
const
nsINode
*
aNode
)
const
;
bool
IsInclusiveFlatTreeDescendantOf
(
const
nsINode
*
aNode
)
const
;
inline
mozilla
:
:
dom
:
:
DocumentFragment
*
AsDocumentFragment
(
)
;
inline
const
mozilla
:
:
dom
:
:
DocumentFragment
*
AsDocumentFragment
(
)
const
;
JSObject
*
WrapObject
(
JSContext
*
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
final
;
virtual
void
ConstructUbiNode
(
void
*
storage
)
=
0
;
static
bool
HasBoxQuadsSupport
(
JSContext
*
aCx
JSObject
*
)
;
protected
:
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
=
0
;
public
:
mozilla
:
:
dom
:
:
ParentObject
GetParentObject
(
)
const
;
nsIContent
*
GetFirstChildOfTemplateOrNode
(
)
;
virtual
nsINode
*
GetScopeChainParent
(
)
const
;
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
dom
:
:
Element
*
GetParentFlexElement
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetNearestInclusiveOpenPopover
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetNearestInclusiveTargetPopoverForInvoker
(
)
const
;
nsGenericHTMLElement
*
GetEffectivePopoverTargetElement
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetTopmostClickedPopover
(
)
const
;
bool
IsNode
(
)
const
final
{
return
true
;
}
NS_IMPL_FROMEVENTTARGET_HELPER
(
nsINode
IsNode
(
)
)
bool
IsElement
(
)
const
{
return
GetBoolFlag
(
NodeIsElement
)
;
}
virtual
bool
IsTextControlElement
(
)
const
{
return
false
;
}
virtual
bool
IsGenericHTMLFormControlElementWithState
(
)
const
{
return
false
;
}
virtual
const
mozilla
:
:
dom
:
:
LinkStyle
*
AsLinkStyle
(
)
const
{
return
nullptr
;
}
mozilla
:
:
dom
:
:
LinkStyle
*
AsLinkStyle
(
)
{
return
const_cast
<
mozilla
:
:
dom
:
:
LinkStyle
*
>
(
static_cast
<
const
nsINode
*
>
(
this
)
-
>
AsLinkStyle
(
)
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
AsElement
(
)
;
inline
const
mozilla
:
:
dom
:
:
Element
*
AsElement
(
)
const
;
virtual
bool
IsStyledElement
(
)
const
{
return
false
;
}
nsIContent
*
AsContent
(
)
{
MOZ_ASSERT
(
IsContent
(
)
)
;
return
reinterpret_cast
<
nsIContent
*
>
(
this
)
;
}
const
nsIContent
*
AsContent
(
)
const
{
MOZ_ASSERT
(
IsContent
(
)
)
;
return
reinterpret_cast
<
const
nsIContent
*
>
(
this
)
;
}
bool
IsText
(
)
const
{
uint32_t
nodeType
=
NodeType
(
)
;
return
nodeType
=
=
TEXT_NODE
|
|
nodeType
=
=
CDATA_SECTION_NODE
;
}
inline
mozilla
:
:
dom
:
:
Text
*
GetAsText
(
)
;
inline
const
mozilla
:
:
dom
:
:
Text
*
GetAsText
(
)
const
;
inline
mozilla
:
:
dom
:
:
Text
*
AsText
(
)
;
inline
const
mozilla
:
:
dom
:
:
Text
*
AsText
(
)
const
;
bool
IsProcessingInstruction
(
)
const
{
return
NodeType
(
)
=
=
PROCESSING_INSTRUCTION_NODE
;
}
bool
IsCharacterData
(
)
const
{
uint32_t
nodeType
=
NodeType
(
)
;
return
nodeType
=
=
TEXT_NODE
|
|
nodeType
=
=
CDATA_SECTION_NODE
|
|
nodeType
=
=
PROCESSING_INSTRUCTION_NODE
|
|
nodeType
=
=
COMMENT_NODE
;
}
bool
IsComment
(
)
const
{
return
NodeType
(
)
=
=
COMMENT_NODE
;
}
bool
IsAttr
(
)
const
{
return
NodeType
(
)
=
=
ATTRIBUTE_NODE
;
}
bool
HasChildren
(
)
const
{
return
!
!
mFirstChild
;
}
uint32_t
GetChildCount
(
)
const
{
return
mChildCount
;
}
nsIContent
*
GetChildAt_Deprecated
(
uint32_t
aIndex
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
ComputeIndexOf
(
const
nsINode
*
aPossibleChild
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
ComputeIndexInParentNode
(
)
const
;
mozilla
:
:
Maybe
<
uint32_t
>
ComputeIndexInParentContent
(
)
const
;
int32_t
ComputeIndexOf_Deprecated
(
const
nsINode
*
aPossibleChild
)
const
;
Document
*
OwnerDoc
(
)
const
MOZ_NONNULL_RETURN
{
return
mNodeInfo
-
>
GetDocument
(
)
;
}
inline
nsINode
*
OwnerDocAsNode
(
)
const
MOZ_NONNULL_RETURN
;
bool
IsInUncomposedDoc
(
)
const
{
return
GetBoolFlag
(
IsInDocument
)
;
}
Document
*
GetUncomposedDoc
(
)
const
{
return
IsInUncomposedDoc
(
)
?
OwnerDoc
(
)
:
nullptr
;
}
bool
IsInComposedDoc
(
)
const
{
return
GetBoolFlag
(
IsConnected
)
;
}
Document
*
GetComposedDoc
(
)
const
{
return
IsInComposedDoc
(
)
?
OwnerDoc
(
)
:
nullptr
;
}
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
*
GetContainingDocumentOrShadowRoot
(
)
const
;
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
*
GetUncomposedDocOrConnectedShadowRoot
(
)
const
;
void
LastRelease
(
)
;
uint16_t
NodeType
(
)
const
{
return
mNodeInfo
-
>
NodeType
(
)
;
}
const
nsString
&
NodeName
(
)
const
{
return
mNodeInfo
-
>
NodeName
(
)
;
}
const
nsString
&
LocalName
(
)
const
{
return
mNodeInfo
-
>
LocalName
(
)
;
}
inline
mozilla
:
:
dom
:
:
NodeInfo
*
NodeInfo
(
)
const
{
return
mNodeInfo
;
}
virtual
void
NodeInfoChanged
(
Document
*
aOldDoc
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
AssertInvariantsOnNodeInfoChange
(
)
;
#
endif
}
inline
bool
IsInNamespace
(
int32_t
aNamespace
)
const
{
return
mNodeInfo
-
>
NamespaceID
(
)
=
=
aNamespace
;
}
DocGroup
*
GetDocGroup
(
)
const
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
nsINode
&
aNode
)
;
protected
:
inline
bool
IsNodeInternal
(
)
const
{
return
false
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsNodeInternal
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
mNodeInfo
-
>
Equals
(
aFirst
)
|
|
IsNodeInternal
(
aArgs
.
.
.
)
;
}
public
:
inline
bool
IsHTMLElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_XHTML
)
;
}
inline
bool
IsHTMLElement
(
const
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_XHTML
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsHTMLElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsSVGElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_SVG
)
;
}
inline
bool
IsSVGElement
(
const
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_SVG
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfSVGElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsSVGElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
virtual
bool
IsSVGAnimationElement
(
)
const
{
return
false
;
}
virtual
bool
IsSVGGeometryElement
(
)
const
{
return
false
;
}
virtual
bool
IsSVGGraphicsElement
(
)
const
{
return
false
;
}
inline
bool
IsXULElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_XUL
)
;
}
inline
bool
IsXULElement
(
const
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_XUL
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfXULElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsXULElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsMathMLElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_MathML
)
;
}
inline
bool
IsMathMLElement
(
const
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_MathML
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfMathMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsMathMLElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
bool
IsShadowRoot
(
)
const
{
const
bool
isShadowRoot
=
IsInShadowTree
(
)
&
&
!
GetParentNode
(
)
;
MOZ_ASSERT_IF
(
isShadowRoot
IsDocumentFragment
(
)
)
;
return
isShadowRoot
;
}
bool
IsHTMLHeadingElement
(
)
const
{
return
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
)
;
}
virtual
void
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
mozilla
:
:
ErrorResult
&
aRv
)
;
void
AppendChildTo
(
nsIContent
*
aKid
bool
aNotify
mozilla
:
:
ErrorResult
&
aRv
)
{
InsertChildBefore
(
aKid
nullptr
aNotify
aRv
)
;
}
virtual
void
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
;
void
*
GetProperty
(
const
nsAtom
*
aPropertyName
nsresult
*
aStatus
=
nullptr
)
const
;
nsresult
SetProperty
(
nsAtom
*
aPropertyName
void
*
aValue
NSPropertyDtorFunc
aDtor
=
nullptr
bool
aTransfer
=
false
)
;
template
<
class
T
>
static
void
DeleteProperty
(
void
*
nsAtom
*
void
*
aPropertyValue
void
*
)
{
delete
static_cast
<
T
*
>
(
aPropertyValue
)
;
}
void
RemoveProperty
(
const
nsAtom
*
aPropertyName
)
;
void
*
TakeProperty
(
const
nsAtom
*
aPropertyName
nsresult
*
aStatus
=
nullptr
)
;
bool
HasProperties
(
)
const
{
return
HasFlag
(
NODE_HAS_PROPERTIES
)
;
}
nsIPrincipal
*
NodePrincipal
(
)
const
{
return
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
DocumentPrincipal
(
)
;
}
nsIContentSecurityPolicy
*
GetCsp
(
)
const
;
nsIContent
*
GetParent
(
)
const
{
return
MOZ_LIKELY
(
GetBoolFlag
(
ParentIsContent
)
)
?
mParent
-
>
AsContent
(
)
:
nullptr
;
}
nsINode
*
GetParentNode
(
)
const
{
return
mParent
;
}
private
:
nsIContent
*
DoGetShadowHost
(
)
const
;
public
:
nsINode
*
GetParentOrShadowHostNode
(
)
const
{
if
(
MOZ_LIKELY
(
mParent
)
)
{
return
mParent
;
}
return
IsInShadowTree
(
)
?
reinterpret_cast
<
nsINode
*
>
(
DoGetShadowHost
(
)
)
:
nullptr
;
}
enum
FlattenedParentType
{
eNotForStyle
eForStyle
}
;
inline
nsINode
*
GetFlattenedTreeParentNode
(
)
const
;
nsINode
*
GetFlattenedTreeParentNodeNonInline
(
)
const
;
inline
nsINode
*
GetFlattenedTreeParentNodeForStyle
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFlattenedTreeParentElement
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFlattenedTreeParentElementForStyle
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetParentElement
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetParentElementCrossingShadowRoot
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetAsElementOrParentElement
(
)
const
;
nsINode
*
SubtreeRoot
(
)
const
;
nsINode
*
GetRootNode
(
const
mozilla
:
:
dom
:
:
GetRootNodeOptions
&
aOptions
)
;
virtual
mozilla
:
:
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
EventCallbackDebuggerNotificationType
>
GetDebuggerNotificationType
(
)
const
override
;
bool
ComputeDefaultWantsUntrusted
(
mozilla
:
:
ErrorResult
&
aRv
)
final
;
virtual
bool
IsApzAware
(
)
const
override
;
virtual
nsPIDOMWindowOuter
*
GetOwnerGlobalForBindingsInternal
(
)
override
;
virtual
nsIGlobalObject
*
GetOwnerGlobal
(
)
const
override
;
using
mozilla
:
:
dom
:
:
EventTarget
:
:
DispatchEvent
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
DispatchEvent
(
mozilla
:
:
dom
:
:
Event
&
aEvent
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
PostHandleEvent
(
mozilla
:
:
EventChainPostVisitor
&
aVisitor
)
override
;
void
AddMutationObserver
(
nsIMutationObserver
*
aMutationObserver
)
{
nsSlots
*
s
=
Slots
(
)
;
if
(
aMutationObserver
)
{
NS_ASSERTION
(
!
s
-
>
mMutationObservers
.
contains
(
aMutationObserver
)
"
Observer
already
in
the
list
"
)
;
s
-
>
mMutationObservers
.
pushBack
(
aMutationObserver
)
;
}
}
void
AddMutationObserver
(
nsMultiMutationObserver
*
aMultiMutationObserver
)
;
void
AddMutationObserverUnlessExists
(
nsIMutationObserver
*
aMutationObserver
)
{
nsSlots
*
s
=
Slots
(
)
;
if
(
aMutationObserver
&
&
!
s
-
>
mMutationObservers
.
contains
(
aMutationObserver
)
)
{
s
-
>
mMutationObservers
.
pushBack
(
aMutationObserver
)
;
}
}
void
AddMutationObserverUnlessExists
(
nsMultiMutationObserver
*
aMultiMutationObserver
)
;
void
AddAnimationObserver
(
nsIAnimationObserver
*
aAnimationObserver
)
;
void
AddAnimationObserverUnlessExists
(
nsIAnimationObserver
*
aAnimationObserver
)
;
void
RemoveMutationObserver
(
nsIMutationObserver
*
aMutationObserver
)
{
nsSlots
*
s
=
GetExistingSlots
(
)
;
if
(
s
)
{
s
-
>
mMutationObservers
.
remove
(
aMutationObserver
)
;
}
}
void
RemoveMutationObserver
(
nsMultiMutationObserver
*
aMultiMutationObserver
)
;
mozilla
:
:
SafeDoublyLinkedList
<
nsIMutationObserver
>
*
GetMutationObservers
(
)
;
template
<
typename
T
>
inline
mozilla
:
:
dom
:
:
AncestorsOfTypeIterator
<
T
>
AncestorsOfType
(
)
const
;
template
<
typename
T
>
inline
mozilla
:
:
dom
:
:
InclusiveAncestorsOfTypeIterator
<
T
>
InclusiveAncestorsOfType
(
)
const
;
template
<
typename
T
>
inline
mozilla
:
:
dom
:
:
FlatTreeAncestorsOfTypeIterator
<
T
>
FlatTreeAncestorsOfType
(
)
const
;
template
<
typename
T
>
inline
mozilla
:
:
dom
:
:
InclusiveFlatTreeAncestorsOfTypeIterator
<
T
>
InclusiveFlatTreeAncestorsOfType
(
)
const
;
template
<
typename
T
>
T
*
FirstAncestorOfType
(
)
const
;
private
:
static
already_AddRefed
<
nsINode
>
CloneAndAdopt
(
nsINode
*
aNode
bool
aClone
bool
aDeep
nsNodeInfoManager
*
aNewNodeInfoManager
JS
:
:
Handle
<
JSObject
*
>
aReparentScope
nsINode
*
aParent
mozilla
:
:
ErrorResult
&
aError
)
;
public
:
void
Adopt
(
nsNodeInfoManager
*
aNewNodeInfoManager
JS
:
:
Handle
<
JSObject
*
>
aReparentScope
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsINode
>
Clone
(
bool
aDeep
nsNodeInfoManager
*
aNewNodeInfoManager
mozilla
:
:
ErrorResult
&
aError
)
;
virtual
nsresult
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
nsINode
*
*
aResult
)
const
=
0
;
class
nsSlots
{
public
:
nsSlots
(
)
;
virtual
~
nsSlots
(
)
;
virtual
void
Traverse
(
nsCycleCollectionTraversalCallback
&
)
;
virtual
void
Unlink
(
nsINode
&
)
;
mozilla
:
:
SafeDoublyLinkedList
<
nsIMutationObserver
>
mMutationObservers
;
RefPtr
<
nsAttrChildContentList
>
mChildNodes
;
nsNodeWeakReference
*
MOZ_NON_OWNING_REF
mWeakReference
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
LinkedList
<
nsRange
>
>
mClosestCommonInclusiveAncestorRanges
;
}
;
#
ifdef
DEBUG
nsSlots
*
DebugGetSlots
(
)
{
return
Slots
(
)
;
}
#
endif
void
SetFlags
(
FlagsType
aFlagsToSet
)
{
NS_ASSERTION
(
!
(
aFlagsToSet
&
(
NODE_IS_NATIVE_ANONYMOUS_ROOT
|
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
|
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
|
NODE_HAS_BEEN_IN_UA_WIDGET
)
)
|
|
IsContent
(
)
"
Flag
only
permitted
on
nsIContent
nodes
"
)
;
nsWrapperCache
:
:
SetFlags
(
aFlagsToSet
)
;
}
void
UnsetFlags
(
FlagsType
aFlagsToUnset
)
{
NS_ASSERTION
(
!
(
aFlagsToUnset
&
(
NODE_HAS_BEEN_IN_UA_WIDGET
|
NODE_IS_NATIVE_ANONYMOUS_ROOT
)
)
"
Trying
to
unset
write
-
only
flags
"
)
;
nsWrapperCache
:
:
UnsetFlags
(
aFlagsToUnset
)
;
}
void
SetEditableFlag
(
bool
aEditable
)
{
if
(
aEditable
)
{
SetFlags
(
NODE_IS_EDITABLE
)
;
}
else
{
UnsetFlags
(
NODE_IS_EDITABLE
)
;
}
}
inline
bool
IsEditable
(
)
const
;
inline
bool
IsInDesignMode
(
)
const
;
bool
IsInNativeAnonymousSubtree
(
)
const
{
return
HasFlag
(
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
)
;
}
nsIContent
*
GetClosestNativeAnonymousSubtreeRoot
(
)
const
{
if
(
!
IsInNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
IsContent
(
)
"
How
did
non
-
content
end
up
in
NAC
?
"
)
;
for
(
const
nsINode
*
node
=
this
;
node
;
node
=
node
-
>
GetParentNode
(
)
)
{
if
(
node
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
const_cast
<
nsINode
*
>
(
node
)
-
>
AsContent
(
)
;
}
}
NS_WARNING
(
"
GetClosestNativeAnonymousSubtreeRoot
on
disconnected
NAC
!
"
)
;
return
nullptr
;
}
nsIContent
*
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
const
{
const
auto
*
root
=
reinterpret_cast
<
const
nsINode
*
>
(
GetClosestNativeAnonymousSubtreeRoot
(
)
)
;
if
(
!
root
)
{
return
nullptr
;
}
if
(
nsIContent
*
parent
=
root
-
>
GetParent
(
)
)
{
return
parent
;
}
if
(
MOZ_UNLIKELY
(
root
-
>
IsInShadowTree
(
)
)
)
{
return
root
-
>
DoGetShadowHost
(
)
;
}
return
nullptr
;
}
mozilla
:
:
dom
:
:
ShadowRoot
*
GetContainingShadow
(
)
const
;
nsIContent
*
GetContainingShadowHost
(
)
const
;
bool
IsInSVGUseShadowTree
(
)
const
{
return
!
!
GetContainingSVGUseShadowHost
(
)
;
}
mozilla
:
:
dom
:
:
SVGUseElement
*
GetContainingSVGUseShadowHost
(
)
const
{
if
(
!
IsInShadowTree
(
)
)
{
return
nullptr
;
}
return
DoGetContainingSVGUseShadowHost
(
)
;
}
bool
HasBeenInUAWidget
(
)
const
{
return
HasFlag
(
NODE_HAS_BEEN_IN_UA_WIDGET
)
;
}
bool
ChromeOnlyAccess
(
)
const
{
return
IsInNativeAnonymousSubtree
(
)
;
}
const
nsIContent
*
GetChromeOnlyAccessSubtreeRootParent
(
)
const
{
return
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
;
}
bool
IsInShadowTree
(
)
const
{
return
HasFlag
(
NODE_IS_IN_SHADOW_TREE
)
;
}
bool
IsRootOfNativeAnonymousSubtree
(
)
const
{
NS_ASSERTION
(
!
HasFlag
(
NODE_IS_NATIVE_ANONYMOUS_ROOT
)
|
|
IsInNativeAnonymousSubtree
(
)
"
Some
flags
seem
to
be
missing
!
"
)
;
return
HasFlag
(
NODE_IS_NATIVE_ANONYMOUS_ROOT
)
;
}
bool
IsRootOfChromeAccessOnlySubtree
(
)
const
{
return
IsRootOfNativeAnonymousSubtree
(
)
;
}
bool
IsMaybeSelected
(
)
const
{
return
IsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
(
)
|
|
IsClosestCommonInclusiveAncestorForRangeInSelection
(
)
;
}
bool
IsSelected
(
uint32_t
aStartOffset
uint32_t
aEndOffset
)
const
;
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
dom
:
:
Element
*
GetAnonymousRootElementOfTextEditor
(
mozilla
:
:
TextEditor
*
*
aTextEditor
=
nullptr
)
;
MOZ_CAN_RUN_SCRIPT
nsIContent
*
GetSelectionRootContent
(
mozilla
:
:
PresShell
*
aPresShell
)
;
nsINodeList
*
ChildNodes
(
)
;
nsIContent
*
GetFirstChild
(
)
const
{
return
mFirstChild
;
}
nsIContent
*
GetLastChild
(
)
const
;
Document
*
GetOwnerDocument
(
)
const
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Normalize
(
)
;
virtual
nsIURI
*
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
=
false
)
const
=
0
;
nsIURI
*
GetBaseURIObject
(
)
const
;
bool
IsNodeApzAware
(
)
const
{
return
NodeMayBeApzAware
(
)
?
IsNodeApzAwareInternal
(
)
:
false
;
}
virtual
bool
IsNodeApzAwareInternal
(
)
const
;
void
GetTextContent
(
nsAString
&
aTextContent
mozilla
:
:
OOMReporter
&
aError
)
{
GetTextContentInternal
(
aTextContent
aError
)
;
}
void
SetTextContent
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
{
SetTextContentInternal
(
aTextContent
aSubjectPrincipal
aError
)
;
}
void
SetTextContent
(
const
nsAString
&
aTextContent
mozilla
:
:
ErrorResult
&
aError
)
{
SetTextContentInternal
(
aTextContent
nullptr
aError
)
;
}
mozilla
:
:
dom
:
:
Element
*
QuerySelector
(
const
nsACString
&
aSelector
mozilla
:
:
ErrorResult
&
aResult
)
;
already_AddRefed
<
nsINodeList
>
QuerySelectorAll
(
const
nsACString
&
aSelector
mozilla
:
:
ErrorResult
&
aResult
)
;
protected
:
mozilla
:
:
dom
:
:
Element
*
GetElementById
(
const
nsAString
&
aId
)
;
void
AppendChildToChildList
(
nsIContent
*
aKid
)
;
void
InsertChildToChildList
(
nsIContent
*
aKid
nsIContent
*
aNextSibling
)
;
void
DisconnectChild
(
nsIContent
*
aKid
)
;
public
:
void
LookupPrefix
(
const
nsAString
&
aNamespace
nsAString
&
aResult
)
;
bool
IsDefaultNamespace
(
const
nsAString
&
aNamespaceURI
)
{
nsAutoString
defaultNamespace
;
LookupNamespaceURI
(
u
"
"
_ns
defaultNamespace
)
;
return
aNamespaceURI
.
Equals
(
defaultNamespace
)
;
}
void
LookupNamespaceURI
(
const
nsAString
&
aNamespacePrefix
nsAString
&
aNamespaceURI
)
;
nsIContent
*
GetNextSibling
(
)
const
{
return
mNextSibling
;
}
nsIContent
*
GetPreviousSibling
(
)
const
;
bool
IsBeingRemoved
(
)
const
{
return
mParent
&
&
!
mNextSibling
&
&
!
mPreviousOrLastSibling
;
}
nsIContent
*
GetNextNode
(
const
nsINode
*
aRoot
=
nullptr
)
const
{
return
GetNextNodeImpl
(
aRoot
false
)
;
}
nsIContent
*
GetNextNonChildNode
(
const
nsINode
*
aRoot
=
nullptr
)
const
{
return
GetNextNodeImpl
(
aRoot
true
)
;
}
bool
Contains
(
const
nsINode
*
aOther
)
const
;
bool
UnoptimizableCCNode
(
)
const
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
FireNodeRemovedForChildren
(
)
;
private
:
mozilla
:
:
dom
:
:
SVGUseElement
*
DoGetContainingSVGUseShadowHost
(
)
const
;
nsIContent
*
GetNextNodeImpl
(
const
nsINode
*
aRoot
const
bool
aSkipChildren
)
const
{
#
ifdef
DEBUG
if
(
aRoot
)
{
const
nsINode
*
cur
=
this
;
for
(
;
cur
;
cur
=
cur
-
>
GetParentNode
(
)
)
if
(
cur
=
=
aRoot
)
break
;
NS_ASSERTION
(
cur
"
aRoot
not
an
ancestor
of
|
this
|
?
"
)
;
}
#
endif
if
(
!
aSkipChildren
)
{
nsIContent
*
kid
=
GetFirstChild
(
)
;
if
(
kid
)
{
return
kid
;
}
}
if
(
this
=
=
aRoot
)
{
return
nullptr
;
}
const
nsINode
*
cur
=
this
;
while
(
1
)
{
nsIContent
*
next
=
cur
-
>
GetNextSibling
(
)
;
if
(
next
)
{
return
next
;
}
nsINode
*
parent
=
cur
-
>
GetParentNode
(
)
;
if
(
parent
=
=
aRoot
)
{
return
nullptr
;
}
cur
=
parent
;
}
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
get
here
?
"
)
;
}
public
:
nsIContent
*
GetPreviousContent
(
const
nsINode
*
aRoot
=
nullptr
)
const
{
#
ifdef
DEBUG
if
(
aRoot
)
{
const
nsINode
*
cur
=
this
;
for
(
;
cur
;
cur
=
cur
-
>
GetParentNode
(
)
)
if
(
cur
=
=
aRoot
)
break
;
NS_ASSERTION
(
cur
"
aRoot
not
an
ancestor
of
|
this
|
?
"
)
;
}
#
endif
if
(
this
=
=
aRoot
)
{
return
nullptr
;
}
nsIContent
*
cur
=
this
-
>
GetParent
(
)
;
nsIContent
*
iter
=
this
-
>
GetPreviousSibling
(
)
;
while
(
iter
)
{
cur
=
iter
;
iter
=
reinterpret_cast
<
nsINode
*
>
(
iter
)
-
>
GetLastChild
(
)
;
}
return
cur
;
}
private
:
enum
BooleanFlag
{
NodeHasRenderingObservers
IsInDocument
IsConnected
ParentIsContent
NodeIsElement
ElementHasID
ElementMayHaveClass
ElementMayHaveStyle
ElementHasName
ElementHasPart
ElementMayHaveContentEditableAttr
NodeIsClosestCommonInclusiveAncestorForRangeInSelection
NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
NodeIsCCMarkedRoot
NodeIsCCBlackTree
NodeIsPurpleRoot
ElementHasLockedStyleStates
ElementHasPointerLock
NodeMayHaveDOMMutationObserver
NodeIsContent
ElementHasAnimations
NodeHasValidDirAttribute
NodeHasDirAutoSet
NodeHasTextNodeDirectionalityMap
NodeAncestorHasDirAuto
NodeHandlingClick
ElementHasWeirdParserInsertionMode
ParserHasNotified
MayBeApzAware
ElementMayHaveAnonymousChildren
ElementHasCustomElementData
ElementCreatedFromPrototypeAndHasUnmodifiedL10n
BooleanFlagCount
}
;
void
SetBoolFlag
(
BooleanFlag
name
bool
value
)
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
mBoolFlags
=
(
mBoolFlags
&
~
(
1
<
<
name
)
)
|
(
value
<
<
name
)
;
}
void
SetBoolFlag
(
BooleanFlag
name
)
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
mBoolFlags
|
=
(
1
<
<
name
)
;
}
void
ClearBoolFlag
(
BooleanFlag
name
)
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
mBoolFlags
&
=
~
(
1
<
<
name
)
;
}
bool
GetBoolFlag
(
BooleanFlag
name
)
const
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
return
mBoolFlags
&
(
1
<
<
name
)
;
}
public
:
bool
HasRenderingObservers
(
)
const
{
return
GetBoolFlag
(
NodeHasRenderingObservers
)
;
}
void
SetHasRenderingObservers
(
bool
aValue
)
{
SetBoolFlag
(
NodeHasRenderingObservers
aValue
)
;
}
bool
IsContent
(
)
const
{
return
GetBoolFlag
(
NodeIsContent
)
;
}
bool
HasID
(
)
const
{
return
GetBoolFlag
(
ElementHasID
)
;
}
bool
MayHaveClass
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveClass
)
;
}
void
SetMayHaveClass
(
)
{
SetBoolFlag
(
ElementMayHaveClass
)
;
}
bool
MayHaveStyle
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveStyle
)
;
}
bool
HasName
(
)
const
{
return
GetBoolFlag
(
ElementHasName
)
;
}
bool
HasPartAttribute
(
)
const
{
return
GetBoolFlag
(
ElementHasPart
)
;
}
bool
MayHaveContentEditableAttr
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveContentEditableAttr
)
;
}
bool
IsClosestCommonInclusiveAncestorForRangeInSelection
(
)
const
{
return
GetBoolFlag
(
NodeIsClosestCommonInclusiveAncestorForRangeInSelection
)
;
}
void
SetClosestCommonInclusiveAncestorForRangeInSelection
(
)
{
SetBoolFlag
(
NodeIsClosestCommonInclusiveAncestorForRangeInSelection
)
;
}
void
ClearClosestCommonInclusiveAncestorForRangeInSelection
(
)
{
ClearBoolFlag
(
NodeIsClosestCommonInclusiveAncestorForRangeInSelection
)
;
}
bool
IsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
(
)
const
{
return
GetBoolFlag
(
NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
)
;
}
void
SetDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
(
)
{
SetBoolFlag
(
NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
)
;
}
void
ClearDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
(
)
{
ClearBoolFlag
(
NodeIsDescendantOfClosestCommonInclusiveAncestorForRangeInSelection
)
;
}
void
SetCCMarkedRoot
(
bool
aValue
)
{
SetBoolFlag
(
NodeIsCCMarkedRoot
aValue
)
;
}
bool
CCMarkedRoot
(
)
const
{
return
GetBoolFlag
(
NodeIsCCMarkedRoot
)
;
}
void
SetInCCBlackTree
(
bool
aValue
)
{
SetBoolFlag
(
NodeIsCCBlackTree
aValue
)
;
}
bool
InCCBlackTree
(
)
const
{
return
GetBoolFlag
(
NodeIsCCBlackTree
)
;
}
void
SetIsPurpleRoot
(
bool
aValue
)
{
SetBoolFlag
(
NodeIsPurpleRoot
aValue
)
;
}
bool
IsPurpleRoot
(
)
const
{
return
GetBoolFlag
(
NodeIsPurpleRoot
)
;
}
bool
MayHaveDOMMutationObserver
(
)
{
return
GetBoolFlag
(
NodeMayHaveDOMMutationObserver
)
;
}
void
SetMayHaveDOMMutationObserver
(
)
{
SetBoolFlag
(
NodeMayHaveDOMMutationObserver
true
)
;
}
bool
HasListenerManager
(
)
{
return
HasFlag
(
NODE_HAS_LISTENERMANAGER
)
;
}
bool
HasPointerLock
(
)
const
{
return
GetBoolFlag
(
ElementHasPointerLock
)
;
}
void
SetPointerLock
(
)
{
SetBoolFlag
(
ElementHasPointerLock
)
;
}
void
ClearPointerLock
(
)
{
ClearBoolFlag
(
ElementHasPointerLock
)
;
}
bool
MayHaveAnimations
(
)
const
{
return
GetBoolFlag
(
ElementHasAnimations
)
;
}
void
SetMayHaveAnimations
(
)
{
SetBoolFlag
(
ElementHasAnimations
)
;
}
void
ClearMayHaveAnimations
(
)
{
ClearBoolFlag
(
ElementHasAnimations
)
;
}
void
SetHasValidDir
(
)
{
SetBoolFlag
(
NodeHasValidDirAttribute
)
;
}
void
ClearHasValidDir
(
)
{
ClearBoolFlag
(
NodeHasValidDirAttribute
)
;
}
bool
HasValidDir
(
)
const
{
return
GetBoolFlag
(
NodeHasValidDirAttribute
)
;
}
void
SetHasDirAutoSet
(
)
{
MOZ_ASSERT
(
NodeType
(
)
!
=
TEXT_NODE
"
SetHasDirAutoSet
on
text
node
"
)
;
SetBoolFlag
(
NodeHasDirAutoSet
)
;
}
void
ClearHasDirAutoSet
(
)
{
MOZ_ASSERT
(
NodeType
(
)
!
=
TEXT_NODE
"
ClearHasDirAutoSet
on
text
node
"
)
;
ClearBoolFlag
(
NodeHasDirAutoSet
)
;
}
bool
HasDirAutoSet
(
)
const
{
return
GetBoolFlag
(
NodeHasDirAutoSet
)
;
}
void
SetHasTextNodeDirectionalityMap
(
)
{
MOZ_ASSERT
(
NodeType
(
)
=
=
TEXT_NODE
"
SetHasTextNodeDirectionalityMap
on
non
-
text
node
"
)
;
SetBoolFlag
(
NodeHasTextNodeDirectionalityMap
)
;
}
void
ClearHasTextNodeDirectionalityMap
(
)
{
MOZ_ASSERT
(
NodeType
(
)
=
=
TEXT_NODE
"
ClearHasTextNodeDirectionalityMap
on
non
-
text
node
"
)
;
ClearBoolFlag
(
NodeHasTextNodeDirectionalityMap
)
;
}
bool
HasTextNodeDirectionalityMap
(
)
const
{
MOZ_ASSERT
(
NodeType
(
)
=
=
TEXT_NODE
"
HasTextNodeDirectionalityMap
on
non
-
text
node
"
)
;
return
GetBoolFlag
(
NodeHasTextNodeDirectionalityMap
)
;
}
void
SetAncestorHasDirAuto
(
)
{
SetBoolFlag
(
NodeAncestorHasDirAuto
)
;
}
void
ClearAncestorHasDirAuto
(
)
{
ClearBoolFlag
(
NodeAncestorHasDirAuto
)
;
}
bool
AncestorHasDirAuto
(
)
const
{
return
GetBoolFlag
(
NodeAncestorHasDirAuto
)
;
}
inline
bool
NodeOrAncestorHasDirAuto
(
)
const
;
void
SetParserHasNotified
(
)
{
SetBoolFlag
(
ParserHasNotified
)
;
}
;
bool
HasParserNotified
(
)
{
return
GetBoolFlag
(
ParserHasNotified
)
;
}
void
SetMayBeApzAware
(
)
{
SetBoolFlag
(
MayBeApzAware
)
;
}
bool
NodeMayBeApzAware
(
)
const
{
return
GetBoolFlag
(
MayBeApzAware
)
;
}
void
SetMayHaveAnonymousChildren
(
)
{
SetBoolFlag
(
ElementMayHaveAnonymousChildren
)
;
}
bool
MayHaveAnonymousChildren
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveAnonymousChildren
)
;
}
void
SetHasCustomElementData
(
)
{
SetBoolFlag
(
ElementHasCustomElementData
)
;
}
bool
HasCustomElementData
(
)
const
{
return
GetBoolFlag
(
ElementHasCustomElementData
)
;
}
void
SetElementCreatedFromPrototypeAndHasUnmodifiedL10n
(
)
{
SetBoolFlag
(
ElementCreatedFromPrototypeAndHasUnmodifiedL10n
)
;
}
bool
HasElementCreatedFromPrototypeAndHasUnmodifiedL10n
(
)
{
return
GetBoolFlag
(
ElementCreatedFromPrototypeAndHasUnmodifiedL10n
)
;
}
void
ClearElementCreatedFromPrototypeAndHasUnmodifiedL10n
(
)
{
ClearBoolFlag
(
ElementCreatedFromPrototypeAndHasUnmodifiedL10n
)
;
}
protected
:
void
SetParentIsContent
(
bool
aValue
)
{
SetBoolFlag
(
ParentIsContent
aValue
)
;
}
void
SetIsInDocument
(
)
{
SetBoolFlag
(
IsInDocument
)
;
}
void
ClearInDocument
(
)
{
ClearBoolFlag
(
IsInDocument
)
;
}
void
SetIsConnected
(
bool
aConnected
)
{
SetBoolFlag
(
IsConnected
aConnected
)
;
}
void
SetNodeIsContent
(
)
{
SetBoolFlag
(
NodeIsContent
)
;
}
void
SetIsElement
(
)
{
SetBoolFlag
(
NodeIsElement
)
;
}
void
SetHasID
(
)
{
SetBoolFlag
(
ElementHasID
)
;
}
void
ClearHasID
(
)
{
ClearBoolFlag
(
ElementHasID
)
;
}
void
SetMayHaveStyle
(
)
{
SetBoolFlag
(
ElementMayHaveStyle
)
;
}
void
SetHasName
(
)
{
SetBoolFlag
(
ElementHasName
)
;
}
void
ClearHasName
(
)
{
ClearBoolFlag
(
ElementHasName
)
;
}
void
SetHasPartAttribute
(
bool
aPart
)
{
SetBoolFlag
(
ElementHasPart
aPart
)
;
}
void
SetMayHaveContentEditableAttr
(
)
{
SetBoolFlag
(
ElementMayHaveContentEditableAttr
)
;
}
void
SetHasLockedStyleStates
(
)
{
SetBoolFlag
(
ElementHasLockedStyleStates
)
;
}
void
ClearHasLockedStyleStates
(
)
{
ClearBoolFlag
(
ElementHasLockedStyleStates
)
;
}
bool
HasLockedStyleStates
(
)
const
{
return
GetBoolFlag
(
ElementHasLockedStyleStates
)
;
}
void
SetHasWeirdParserInsertionMode
(
)
{
SetBoolFlag
(
ElementHasWeirdParserInsertionMode
)
;
}
bool
HasWeirdParserInsertionMode
(
)
const
{
return
GetBoolFlag
(
ElementHasWeirdParserInsertionMode
)
;
}
bool
HandlingClick
(
)
const
{
return
GetBoolFlag
(
NodeHandlingClick
)
;
}
void
SetHandlingClick
(
)
{
SetBoolFlag
(
NodeHandlingClick
)
;
}
void
ClearHandlingClick
(
)
{
ClearBoolFlag
(
NodeHandlingClick
)
;
}
void
SetSubtreeRootPointer
(
nsINode
*
aSubtreeRoot
)
{
NS_ASSERTION
(
aSubtreeRoot
"
aSubtreeRoot
can
never
be
null
!
"
)
;
NS_ASSERTION
(
!
(
IsContent
(
)
&
&
IsInUncomposedDoc
(
)
)
&
&
!
IsInShadowTree
(
)
"
Shouldn
'
t
be
here
!
"
)
;
mSubtreeRoot
=
aSubtreeRoot
;
}
void
ClearSubtreeRootPointer
(
)
{
mSubtreeRoot
=
nullptr
;
}
public
:
void
BindObject
(
nsISupports
*
aObject
)
;
void
UnbindObject
(
nsISupports
*
aObject
)
;
void
GenerateXPath
(
nsAString
&
aResult
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
AccessibleNode
>
GetAccessibleNode
(
)
;
uint32_t
Length
(
)
const
;
void
GetNodeName
(
mozilla
:
:
dom
:
:
DOMString
&
aNodeName
)
{
const
nsString
&
nodeName
=
NodeName
(
)
;
aNodeName
.
SetKnownLiveString
(
nodeName
)
;
}
[
[
nodiscard
]
]
nsresult
GetBaseURI
(
nsAString
&
aBaseURI
)
const
;
void
GetBaseURIFromJS
(
nsAString
&
aBaseURI
CallerType
aCallerType
ErrorResult
&
aRv
)
const
;
bool
HasChildNodes
(
)
const
{
return
HasChildren
(
)
;
}
uint16_t
CompareDocumentPosition
(
nsINode
&
aOther
mozilla
:
:
Maybe
<
uint32_t
>
*
aThisIndex
=
nullptr
mozilla
:
:
Maybe
<
uint32_t
>
*
aOtherIndex
=
nullptr
)
const
;
void
GetNodeValue
(
nsAString
&
aNodeValue
)
{
GetNodeValueInternal
(
aNodeValue
)
;
}
void
SetNodeValue
(
const
nsAString
&
aNodeValue
mozilla
:
:
ErrorResult
&
aError
)
{
SetNodeValueInternal
(
aNodeValue
aError
)
;
}
virtual
void
GetNodeValueInternal
(
nsAString
&
aNodeValue
)
;
virtual
void
SetNodeValueInternal
(
const
nsAString
&
aNodeValue
mozilla
:
:
ErrorResult
&
aError
)
{
}
void
EnsurePreInsertionValidity
(
nsINode
&
aNewChild
nsINode
*
aRefChild
mozilla
:
:
ErrorResult
&
aError
)
;
nsINode
*
InsertBefore
(
nsINode
&
aNode
nsINode
*
aChild
mozilla
:
:
ErrorResult
&
aError
)
{
return
ReplaceOrInsertBefore
(
false
&
aNode
aChild
aError
)
;
}
nsINode
*
AppendChild
(
nsINode
&
aNode
mozilla
:
:
ErrorResult
&
aError
)
{
return
InsertBefore
(
aNode
nullptr
aError
)
;
}
nsINode
*
ReplaceChild
(
nsINode
&
aNode
nsINode
&
aChild
mozilla
:
:
ErrorResult
&
aError
)
{
return
ReplaceOrInsertBefore
(
true
&
aNode
&
aChild
aError
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsINode
*
RemoveChild
(
nsINode
&
aChild
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsINode
>
CloneNode
(
bool
aDeep
mozilla
:
:
ErrorResult
&
aError
)
;
bool
IsSameNode
(
nsINode
*
aNode
)
;
bool
IsEqualNode
(
nsINode
*
aNode
)
;
void
GetNamespaceURI
(
nsAString
&
aNamespaceURI
)
const
{
mNodeInfo
-
>
GetNamespaceURI
(
aNamespaceURI
)
;
}
#
ifdef
MOZILLA_INTERNAL_API
void
GetPrefix
(
nsAString
&
aPrefix
)
{
mNodeInfo
-
>
GetPrefix
(
aPrefix
)
;
}
#
endif
void
GetLocalName
(
mozilla
:
:
dom
:
:
DOMString
&
aLocalName
)
const
{
const
nsString
&
localName
=
LocalName
(
)
;
aLocalName
.
SetKnownLiveString
(
localName
)
;
}
nsDOMAttributeMap
*
GetAttributes
(
)
;
nsresult
RemoveFromParent
(
)
{
nsINode
*
parent
=
GetParentNode
(
)
;
mozilla
:
:
ErrorResult
rv
;
parent
-
>
RemoveChild
(
*
this
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
GetPreviousElementSibling
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetNextElementSibling
(
)
const
;
MOZ_CAN_RUN_SCRIPT
void
Before
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
After
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReplaceWith
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
void
Remove
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetFirstElementChild
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetLastElementChild
(
)
const
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByAttribute
(
const
nsAString
&
aAttribute
const
nsAString
&
aValue
)
;
already_AddRefed
<
nsIHTMLCollection
>
GetElementsByAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aAttribute
const
nsAString
&
aValue
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
Prepend
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
Append
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReplaceChildren
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReplaceChildren
(
nsINode
*
aNode
ErrorResult
&
aRv
)
;
void
GetBoxQuads
(
const
BoxQuadOptions
&
aOptions
nsTArray
<
RefPtr
<
DOMQuad
>
>
&
aResult
CallerType
aCallerType
ErrorResult
&
aRv
)
;
void
GetBoxQuadsFromWindowOrigin
(
const
BoxQuadOptions
&
aOptions
nsTArray
<
RefPtr
<
DOMQuad
>
>
&
aResult
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMQuad
>
ConvertQuadFromNode
(
DOMQuad
&
aQuad
const
TextOrElementOrDocument
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMQuad
>
ConvertRectFromNode
(
DOMRectReadOnly
&
aRect
const
TextOrElementOrDocument
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMPoint
>
ConvertPointFromNode
(
const
DOMPointInit
&
aPoint
const
TextOrElementOrDocument
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
;
const
mozilla
:
:
LinkedList
<
nsRange
>
*
GetExistingClosestCommonInclusiveAncestorRanges
(
)
const
{
if
(
!
HasSlots
(
)
)
{
return
nullptr
;
}
return
GetExistingSlots
(
)
-
>
mClosestCommonInclusiveAncestorRanges
.
get
(
)
;
}
mozilla
:
:
LinkedList
<
nsRange
>
*
GetExistingClosestCommonInclusiveAncestorRanges
(
)
{
if
(
!
HasSlots
(
)
)
{
return
nullptr
;
}
return
GetExistingSlots
(
)
-
>
mClosestCommonInclusiveAncestorRanges
.
get
(
)
;
}
mozilla
:
:
UniquePtr
<
mozilla
:
:
LinkedList
<
nsRange
>
>
&
GetClosestCommonInclusiveAncestorRangesPtr
(
)
{
return
Slots
(
)
-
>
mClosestCommonInclusiveAncestorRanges
;
}
nsIWeakReference
*
GetExistingWeakReference
(
)
{
return
HasSlots
(
)
?
GetExistingSlots
(
)
-
>
mWeakReference
:
nullptr
;
}
protected
:
virtual
nsINode
:
:
nsSlots
*
CreateSlots
(
)
;
bool
HasSlots
(
)
const
{
return
mSlots
!
=
nullptr
;
}
nsSlots
*
GetExistingSlots
(
)
const
{
return
mSlots
;
}
nsSlots
*
Slots
(
)
{
if
(
!
HasSlots
(
)
)
{
mSlots
=
CreateSlots
(
)
;
MOZ_ASSERT
(
mSlots
)
;
}
return
GetExistingSlots
(
)
;
}
void
InvalidateChildNodes
(
)
;
virtual
void
GetTextContentInternal
(
nsAString
&
aTextContent
mozilla
:
:
OOMReporter
&
aError
)
;
virtual
void
SetTextContentInternal
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
{
}
void
EnsurePreInsertionValidity1
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
EnsurePreInsertionValidity2
(
bool
aReplace
nsINode
&
aNewChild
nsINode
*
aRefChild
mozilla
:
:
ErrorResult
&
aError
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsINode
*
ReplaceOrInsertBefore
(
bool
aReplace
nsINode
*
aNewChild
nsINode
*
aRefChild
mozilla
:
:
ErrorResult
&
aError
)
;
virtual
mozilla
:
:
dom
:
:
Element
*
GetNameSpaceElement
(
)
=
0
;
const
RawServoSelectorList
*
ParseSelectorList
(
const
nsACString
&
aSelectorString
mozilla
:
:
ErrorResult
&
)
;
public
:
#
define
EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOn
#
#
name_
(
)
{
\
return
GetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
)
;
\
}
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
handler
)
{
\
SetEventHandler
(
nsGkAtoms
:
:
on
#
#
name_
handler
)
;
\
}
#
define
TOUCH_EVENT
EVENT
#
define
DOCUMENT_ONLY_EVENT
EVENT
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
DOCUMENT_ONLY_EVENT
#
undef
TOUCH_EVENT
#
undef
EVENT
protected
:
static
bool
Traverse
(
nsINode
*
tmp
nsCycleCollectionTraversalCallback
&
cb
)
;
static
void
Unlink
(
nsINode
*
tmp
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
mNodeInfo
;
nsINode
*
MOZ_OWNING_REF
mParent
;
private
:
#
ifndef
BOOL_FLAGS_ON_WRAPPER_CACHE
uint32_t
mBoolFlags
;
#
endif
uint32_t
mChildCount
;
protected
:
nsCOMPtr
<
nsIContent
>
mFirstChild
;
nsCOMPtr
<
nsIContent
>
mNextSibling
;
nsIContent
*
MOZ_NON_OWNING_REF
mPreviousOrLastSibling
;
union
{
nsIFrame
*
mPrimaryFrame
;
nsINode
*
MOZ_NON_OWNING_REF
mSubtreeRoot
;
}
;
nsSlots
*
mSlots
;
}
;
inline
nsINode
*
mozilla
:
:
dom
:
:
EventTarget
:
:
GetAsNode
(
)
{
return
IsNode
(
)
?
AsNode
(
)
:
nullptr
;
}
inline
const
nsINode
*
mozilla
:
:
dom
:
:
EventTarget
:
:
GetAsNode
(
)
const
{
return
const_cast
<
mozilla
:
:
dom
:
:
EventTarget
*
>
(
this
)
-
>
GetAsNode
(
)
;
}
inline
nsINode
*
mozilla
:
:
dom
:
:
EventTarget
:
:
AsNode
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsNode
(
)
)
;
return
static_cast
<
nsINode
*
>
(
this
)
;
}
inline
const
nsINode
*
mozilla
:
:
dom
:
:
EventTarget
:
:
AsNode
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
IsNode
(
)
)
;
return
static_cast
<
const
nsINode
*
>
(
this
)
;
}
template
<
class
C
class
D
>
inline
nsINode
*
NODE_FROM
(
C
&
aContent
D
&
aDocument
)
{
if
(
aContent
)
return
static_cast
<
nsINode
*
>
(
aContent
)
;
return
static_cast
<
nsINode
*
>
(
aDocument
)
;
}
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsINode
NS_INODE_IID
)
inline
nsISupports
*
ToSupports
(
nsINode
*
aPointer
)
{
return
aPointer
;
}
#
define
NS_IMPL_FROMNODE_GENERIC
(
_class
_check
_const
)
\
template
<
typename
T
>
\
static
auto
FromNode
(
_const
T
&
aNode
)
\
-
>
decltype
(
static_cast
<
_const
_class
*
>
(
&
aNode
)
)
{
\
return
aNode
.
_check
?
static_cast
<
_const
_class
*
>
(
&
aNode
)
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
_const
_class
*
FromNode
(
_const
T
*
aNode
)
{
\
return
FromNode
(
*
aNode
)
;
\
}
\
template
<
typename
T
>
\
static
_const
_class
*
FromNodeOrNull
(
_const
T
*
aNode
)
{
\
return
aNode
?
FromNode
(
*
aNode
)
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
auto
FromEventTarget
(
_const
T
&
aEventTarget
)
\
-
>
decltype
(
static_cast
<
_const
_class
*
>
(
&
aEventTarget
)
)
{
\
return
aEventTarget
.
IsNode
(
)
&
&
aEventTarget
.
AsNode
(
)
-
>
_check
\
?
static_cast
<
_const
_class
*
>
(
&
aEventTarget
)
\
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
_const
_class
*
FromEventTarget
(
_const
T
*
aEventTarget
)
{
\
return
FromEventTarget
(
*
aEventTarget
)
;
\
}
\
template
<
typename
T
>
\
static
_const
_class
*
FromEventTargetOrNull
(
_const
T
*
aEventTarget
)
{
\
return
aEventTarget
?
FromEventTarget
(
*
aEventTarget
)
:
nullptr
;
\
}
#
define
NS_IMPL_FROMNODE_HELPER
(
_class
_check
)
\
NS_IMPL_FROMNODE_GENERIC
(
_class
_check
)
\
NS_IMPL_FROMNODE_GENERIC
(
_class
_check
const
)
\
\
template
<
typename
T
>
\
static
_class
*
FromNode
(
T
&
&
aNode
)
{
\
/
*
We
need
the
double
-
cast
in
case
aNode
is
a
smartptr
.
Those
*
/
\
/
*
can
cast
to
superclasses
of
the
type
they
'
re
templated
on
*
/
\
/
*
but
not
directly
to
subclasses
.
*
/
\
return
aNode
-
>
_check
?
static_cast
<
_class
*
>
(
static_cast
<
nsINode
*
>
(
aNode
)
)
\
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
_class
*
FromNodeOrNull
(
T
&
&
aNode
)
{
\
return
aNode
?
FromNode
(
aNode
)
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
_class
*
FromEventTarget
(
T
&
&
aEventTarget
)
{
\
/
*
We
need
the
double
-
cast
in
case
aEventTarget
is
a
smartptr
.
Those
*
/
\
/
*
can
cast
to
superclasses
of
the
type
they
'
re
templated
on
*
/
\
/
*
but
not
directly
to
subclasses
.
*
/
\
return
aEventTarget
-
>
IsNode
(
)
&
&
aEventTarget
-
>
AsNode
(
)
-
>
_check
\
?
static_cast
<
_class
*
>
(
static_cast
<
EventTarget
*
>
(
aEventTarget
)
)
\
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
_class
*
FromEventTargetOrNull
(
T
&
&
aEventTarget
)
{
\
return
aEventTarget
?
FromEventTarget
(
aEventTarget
)
:
nullptr
;
\
}
#
define
NS_IMPL_FROMNODE
(
_class
_nsid
)
\
NS_IMPL_FROMNODE_HELPER
(
_class
IsInNamespace
(
_nsid
)
)
#
define
NS_IMPL_FROMNODE_WITH_TAG
(
_class
_nsid
_tag
)
\
NS_IMPL_FROMNODE_HELPER
(
_class
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
_tag
_nsid
)
)
#
define
NS_IMPL_FROMNODE_HTML_WITH_TAG
(
_class
_tag
)
\
NS_IMPL_FROMNODE_WITH_TAG
(
_class
kNameSpaceID_XHTML
_tag
)
#
endif
