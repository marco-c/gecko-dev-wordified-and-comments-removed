#
ifndef
nsINode_h___
#
define
nsINode_h___
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsPropertyTable
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
EventTarget
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
dom
/
DOMString
.
h
"
#
include
"
mozilla
/
dom
/
BindingDeclarations
.
h
"
#
include
"
mozilla
/
dom
/
NodeBinding
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
<
iosfwd
>
#
ifdef
XP_WIN
#
ifdef
GetClassInfo
#
undef
GetClassInfo
#
endif
#
endif
class
nsAttrAndChildArray
;
class
nsAttrChildContentList
;
class
nsDOMAttributeMap
;
class
nsIAnimationObserver
;
class
nsIContent
;
class
nsIDocument
;
class
nsIFrame
;
class
nsIMutationObserver
;
class
nsINode
;
class
nsINodeList
;
class
nsIPresShell
;
class
nsIPrincipal
;
class
nsIURI
;
class
nsNodeSupportsWeakRefTearoff
;
class
nsDOMMutationObserver
;
class
nsRange
;
class
nsWindowSizes
;
struct
RawServoSelectorList
;
namespace
mozilla
{
class
EventListenerManager
;
class
TextEditor
;
namespace
dom
{
inline
bool
IsSpaceCharacter
(
char16_t
aChar
)
{
return
aChar
=
=
'
'
|
|
aChar
=
=
'
\
t
'
|
|
aChar
=
=
'
\
n
'
|
|
aChar
=
=
'
\
r
'
|
|
aChar
=
=
'
\
f
'
;
}
inline
bool
IsSpaceCharacter
(
char
aChar
)
{
return
aChar
=
=
'
'
|
|
aChar
=
=
'
\
t
'
|
|
aChar
=
=
'
\
n
'
|
|
aChar
=
=
'
\
r
'
|
|
aChar
=
=
'
\
f
'
;
}
class
AccessibleNode
;
struct
BoxQuadOptions
;
struct
ConvertCoordinateOptions
;
class
DocGroup
;
class
DocumentFragment
;
class
DocumentOrShadowRoot
;
class
DOMPoint
;
class
DOMQuad
;
class
DOMRectReadOnly
;
class
Element
;
class
EventHandlerNonNull
;
class
L10nCallback
;
template
<
typename
T
>
class
Optional
;
class
OwningNodeOrString
;
class
Promise
;
template
<
typename
>
class
Sequence
;
class
Text
;
class
TextOrElementOrDocument
;
struct
DOMPointInit
;
struct
GetRootNodeOptions
;
enum
class
CallerType
:
uint32_t
;
}
}
#
define
NODE_FLAG_BIT
(
n_
)
\
(
nsWrapperCache
:
:
FlagsType
(
1U
)
<
<
(
WRAPPER_CACHE_FLAGS_BITS_USED
+
(
n_
)
)
)
enum
{
NODE_HAS_LISTENERMANAGER
=
NODE_FLAG_BIT
(
0
)
NODE_HAS_PROPERTIES
=
NODE_FLAG_BIT
(
1
)
NODE_IS_ANONYMOUS_ROOT
=
NODE_FLAG_BIT
(
2
)
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
=
NODE_FLAG_BIT
(
3
)
NODE_IS_NATIVE_ANONYMOUS_ROOT
=
NODE_FLAG_BIT
(
4
)
NODE_MAY_BE_IN_BINDING_MNGR
=
NODE_FLAG_BIT
(
5
)
NODE_IS_EDITABLE
=
NODE_FLAG_BIT
(
6
)
NODE_IS_IN_SHADOW_TREE
=
NODE_FLAG_BIT
(
8
)
NODE_HAS_EMPTY_SELECTOR
=
NODE_FLAG_BIT
(
9
)
NODE_HAS_SLOW_SELECTOR
=
NODE_FLAG_BIT
(
10
)
NODE_HAS_EDGE_CHILD_SELECTOR
=
NODE_FLAG_BIT
(
11
)
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
=
NODE_FLAG_BIT
(
12
)
NODE_ALL_SELECTOR_FLAGS
=
NODE_HAS_EMPTY_SELECTOR
|
NODE_HAS_SLOW_SELECTOR
|
NODE_HAS_EDGE_CHILD_SELECTOR
|
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
NODE_NEEDS_FRAME
=
NODE_FLAG_BIT
(
13
)
NODE_DESCENDANTS_NEED_FRAMES
=
NODE_FLAG_BIT
(
14
)
NODE_HAS_ACCESSKEY
=
NODE_FLAG_BIT
(
15
)
NODE_HAS_DIRECTION_RTL
=
NODE_FLAG_BIT
(
16
)
NODE_HAS_DIRECTION_LTR
=
NODE_FLAG_BIT
(
17
)
NODE_ALL_DIRECTION_FLAGS
=
NODE_HAS_DIRECTION_LTR
|
NODE_HAS_DIRECTION_RTL
NODE_CHROME_ONLY_ACCESS
=
NODE_FLAG_BIT
(
18
)
NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS
=
NODE_FLAG_BIT
(
19
)
NODE_TYPE_SPECIFIC_BITS_OFFSET
=
20
}
;
#
define
ASSERT_NODE_FLAGS_SPACE
(
n
)
\
static_assert
(
WRAPPER_CACHE_FLAGS_BITS_USED
+
(
n
)
<
=
\
sizeof
(
nsWrapperCache
:
:
FlagsType
)
*
8
\
"
Not
enough
space
for
our
bits
"
)
ASSERT_NODE_FLAGS_SPACE
(
NODE_TYPE_SPECIFIC_BITS_OFFSET
)
;
class
nsMutationGuard
{
public
:
nsMutationGuard
(
)
{
mStartingGeneration
=
sGeneration
;
}
bool
Mutated
(
uint8_t
aIgnoreCount
)
{
return
(
sGeneration
-
mStartingGeneration
)
>
aIgnoreCount
;
}
static
void
DidMutate
(
)
{
sGeneration
+
+
;
}
private
:
uint64_t
mStartingGeneration
;
static
uint64_t
sGeneration
;
}
;
class
nsNodeWeakReference
final
:
public
nsIWeakReference
{
public
:
explicit
nsNodeWeakReference
(
nsINode
*
aNode
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIWEAKREFERENCE
size_t
SizeOfOnlyThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
void
NoticeNodeDestruction
(
)
{
mObject
=
nullptr
;
}
private
:
~
nsNodeWeakReference
(
)
;
}
;
#
define
NS_DECL_ADDSIZEOFEXCLUDINGTHIS
\
virtual
void
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
\
size_t
*
aNodeSize
)
const
override
;
#
define
NS_INODE_IID
\
{
0x70ba4547
0x7699
0x44fc
\
{
0xb3
0x20
0x52
0xdb
0xe3
0xd1
0xf9
0x0a
}
}
class
nsINode
:
public
mozilla
:
:
dom
:
:
EventTarget
{
public
:
typedef
mozilla
:
:
dom
:
:
BoxQuadOptions
BoxQuadOptions
;
typedef
mozilla
:
:
dom
:
:
ConvertCoordinateOptions
ConvertCoordinateOptions
;
typedef
mozilla
:
:
dom
:
:
DocGroup
DocGroup
;
typedef
mozilla
:
:
dom
:
:
DOMPoint
DOMPoint
;
typedef
mozilla
:
:
dom
:
:
DOMPointInit
DOMPointInit
;
typedef
mozilla
:
:
dom
:
:
DOMQuad
DOMQuad
;
typedef
mozilla
:
:
dom
:
:
DOMRectReadOnly
DOMRectReadOnly
;
typedef
mozilla
:
:
dom
:
:
OwningNodeOrString
OwningNodeOrString
;
typedef
mozilla
:
:
dom
:
:
TextOrElementOrDocument
TextOrElementOrDocument
;
typedef
mozilla
:
:
dom
:
:
CallerType
CallerType
;
typedef
mozilla
:
:
ErrorResult
ErrorResult
;
static
const
auto
ELEMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ELEMENT_NODE
;
static
const
auto
ATTRIBUTE_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ATTRIBUTE_NODE
;
static
const
auto
TEXT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
TEXT_NODE
;
static
const
auto
CDATA_SECTION_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
CDATA_SECTION_NODE
;
static
const
auto
ENTITY_REFERENCE_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ENTITY_REFERENCE_NODE
;
static
const
auto
ENTITY_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
ENTITY_NODE
;
static
const
auto
PROCESSING_INSTRUCTION_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
PROCESSING_INSTRUCTION_NODE
;
static
const
auto
COMMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
COMMENT_NODE
;
static
const
auto
DOCUMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
DOCUMENT_NODE
;
static
const
auto
DOCUMENT_TYPE_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
DOCUMENT_TYPE_NODE
;
static
const
auto
DOCUMENT_FRAGMENT_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
DOCUMENT_FRAGMENT_NODE
;
static
const
auto
NOTATION_NODE
=
mozilla
:
:
dom
:
:
Node_Binding
:
:
NOTATION_NODE
;
template
<
class
T
>
using
Sequence
=
mozilla
:
:
dom
:
:
Sequence
<
T
>
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_INODE_IID
)
virtual
void
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
;
friend
class
nsNodeUtils
;
friend
class
nsNodeWeakReference
;
friend
class
nsNodeSupportsWeakRefTearoff
;
friend
class
nsAttrAndChildArray
;
#
ifdef
MOZILLA_INTERNAL_API
explicit
nsINode
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
mNodeInfo
(
aNodeInfo
)
mParent
(
nullptr
)
#
ifndef
BOOL_FLAGS_ON_WRAPPER_CACHE
mBoolFlags
(
0
)
#
endif
mNextSibling
(
nullptr
)
mPreviousSibling
(
nullptr
)
mFirstChild
(
nullptr
)
mSubtreeRoot
(
this
)
mSlots
(
nullptr
)
{
}
#
endif
virtual
~
nsINode
(
)
;
enum
{
eHTML_FORM_CONTROL
=
1
<
<
6
eANIMATION
=
1
<
<
10
eFILTER
=
1
<
<
11
eSHAPE
=
1
<
<
12
}
;
virtual
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
=
0
;
bool
IsContainerNode
(
)
const
{
return
IsElement
(
)
|
|
IsDocument
(
)
|
|
IsDocumentFragment
(
)
;
}
bool
IsSlotable
(
)
const
{
return
IsElement
(
)
|
|
IsText
(
)
;
}
bool
IsDocument
(
)
const
{
return
!
GetParentNode
(
)
&
&
IsInUncomposedDoc
(
)
;
}
inline
nsIDocument
*
AsDocument
(
)
;
inline
const
nsIDocument
*
AsDocument
(
)
const
;
bool
IsDocumentFragment
(
)
const
{
return
NodeType
(
)
=
=
DOCUMENT_FRAGMENT_NODE
;
}
inline
mozilla
:
:
dom
:
:
DocumentFragment
*
AsDocumentFragment
(
)
;
inline
const
mozilla
:
:
dom
:
:
DocumentFragment
*
AsDocumentFragment
(
)
const
;
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
;
static
bool
HasBoxQuadsSupport
(
JSContext
*
aCx
JSObject
*
)
;
protected
:
virtual
JSObject
*
WrapNode
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
=
0
;
public
:
mozilla
:
:
dom
:
:
ParentObject
GetParentObject
(
)
const
;
virtual
nsINode
*
GetScopeChainParent
(
)
const
;
bool
IsElement
(
)
const
{
return
GetBoolFlag
(
NodeIsElement
)
;
}
inline
mozilla
:
:
dom
:
:
Element
*
AsElement
(
)
;
inline
const
mozilla
:
:
dom
:
:
Element
*
AsElement
(
)
const
;
inline
nsIContent
*
AsContent
(
)
;
inline
const
nsIContent
*
AsContent
(
)
const
;
bool
IsText
(
)
const
{
uint32_t
nodeType
=
NodeType
(
)
;
return
nodeType
=
=
TEXT_NODE
|
|
nodeType
=
=
CDATA_SECTION_NODE
;
}
inline
mozilla
:
:
dom
:
:
Text
*
GetAsText
(
)
;
inline
const
mozilla
:
:
dom
:
:
Text
*
GetAsText
(
)
const
;
inline
mozilla
:
:
dom
:
:
Text
*
AsText
(
)
;
inline
const
mozilla
:
:
dom
:
:
Text
*
AsText
(
)
const
;
bool
IsProcessingInstruction
(
)
const
{
return
NodeType
(
)
=
=
PROCESSING_INSTRUCTION_NODE
;
}
bool
IsCharacterData
(
)
const
{
uint32_t
nodeType
=
NodeType
(
)
;
return
nodeType
=
=
TEXT_NODE
|
|
nodeType
=
=
CDATA_SECTION_NODE
|
|
nodeType
=
=
PROCESSING_INSTRUCTION_NODE
|
|
nodeType
=
=
COMMENT_NODE
;
}
bool
IsComment
(
)
const
{
return
NodeType
(
)
=
=
COMMENT_NODE
;
}
bool
IsAttr
(
)
const
{
return
NodeType
(
)
=
=
ATTRIBUTE_NODE
;
}
bool
HasChildren
(
)
const
{
return
!
!
mFirstChild
;
}
virtual
uint32_t
GetChildCount
(
)
const
=
0
;
virtual
nsIContent
*
GetChildAt_Deprecated
(
uint32_t
aIndex
)
const
=
0
;
virtual
int32_t
ComputeIndexOf
(
const
nsINode
*
aPossibleChild
)
const
=
0
;
nsIDocument
*
OwnerDoc
(
)
const
{
return
mNodeInfo
-
>
GetDocument
(
)
;
}
inline
nsINode
*
OwnerDocAsNode
(
)
const
;
bool
IsInUncomposedDoc
(
)
const
{
return
GetBoolFlag
(
IsInDocument
)
;
}
nsIDocument
*
GetUncomposedDoc
(
)
const
{
return
IsInUncomposedDoc
(
)
?
OwnerDoc
(
)
:
nullptr
;
}
nsIDocument
*
GetComposedDoc
(
)
const
{
return
IsInShadowTree
(
)
?
GetComposedDocInternal
(
)
:
GetUncomposedDoc
(
)
;
}
bool
IsInComposedDoc
(
)
const
{
return
IsInUncomposedDoc
(
)
|
|
(
IsInShadowTree
(
)
&
&
GetComposedDocInternal
(
)
)
;
}
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
*
GetUncomposedDocOrConnectedShadowRoot
(
)
const
;
uint16_t
NodeType
(
)
const
{
return
mNodeInfo
-
>
NodeType
(
)
;
}
const
nsString
&
NodeName
(
)
const
{
return
mNodeInfo
-
>
NodeName
(
)
;
}
const
nsString
&
LocalName
(
)
const
{
return
mNodeInfo
-
>
LocalName
(
)
;
}
inline
mozilla
:
:
dom
:
:
NodeInfo
*
NodeInfo
(
)
const
{
return
mNodeInfo
;
}
inline
bool
IsInNamespace
(
int32_t
aNamespace
)
const
{
return
mNodeInfo
-
>
NamespaceID
(
)
=
=
aNamespace
;
}
DocGroup
*
GetDocGroup
(
)
const
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
nsINode
&
aNode
)
;
protected
:
inline
bool
IsNodeInternal
(
)
const
{
return
false
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsNodeInternal
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
mNodeInfo
-
>
Equals
(
aFirst
)
|
|
IsNodeInternal
(
aArgs
.
.
.
)
;
}
public
:
inline
bool
IsHTMLElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_XHTML
)
;
}
inline
bool
IsHTMLElement
(
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_XHTML
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfHTMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsHTMLElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsSVGElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_SVG
)
;
}
inline
bool
IsSVGElement
(
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_SVG
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfSVGElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsSVGElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsXULElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_XUL
)
;
}
inline
bool
IsXULElement
(
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_XUL
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfXULElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsXULElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
inline
bool
IsMathMLElement
(
)
const
{
return
IsElement
(
)
&
&
IsInNamespace
(
kNameSpaceID_MathML
)
;
}
inline
bool
IsMathMLElement
(
nsAtom
*
aTag
)
const
{
return
IsElement
(
)
&
&
mNodeInfo
-
>
Equals
(
aTag
kNameSpaceID_MathML
)
;
}
template
<
typename
First
typename
.
.
.
Args
>
inline
bool
IsAnyOfMathMLElements
(
First
aFirst
Args
.
.
.
aArgs
)
const
{
return
IsMathMLElement
(
)
&
&
IsNodeInternal
(
aFirst
aArgs
.
.
.
)
;
}
bool
IsShadowRoot
(
)
const
{
const
bool
isShadowRoot
=
IsInShadowTree
(
)
&
&
!
GetParentNode
(
)
;
MOZ_ASSERT_IF
(
isShadowRoot
IsDocumentFragment
(
)
)
;
return
isShadowRoot
;
}
virtual
nsresult
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
=
0
;
nsresult
AppendChildTo
(
nsIContent
*
aKid
bool
aNotify
)
{
return
InsertChildBefore
(
aKid
nullptr
aNotify
)
;
}
virtual
void
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
=
0
;
void
*
GetProperty
(
nsAtom
*
aPropertyName
nsresult
*
aStatus
=
nullptr
)
const
;
nsresult
SetProperty
(
nsAtom
*
aPropertyName
void
*
aValue
NSPropertyDtorFunc
aDtor
=
nullptr
bool
aTransfer
=
false
)
;
template
<
class
T
>
static
void
DeleteProperty
(
void
*
nsAtom
*
void
*
aPropertyValue
void
*
)
{
delete
static_cast
<
T
*
>
(
aPropertyValue
)
;
}
void
DeleteProperty
(
nsAtom
*
aPropertyName
)
;
void
*
UnsetProperty
(
nsAtom
*
aPropertyName
nsresult
*
aStatus
=
nullptr
)
;
bool
HasProperties
(
)
const
{
return
HasFlag
(
NODE_HAS_PROPERTIES
)
;
}
nsIPrincipal
*
NodePrincipal
(
)
const
{
return
mNodeInfo
-
>
NodeInfoManager
(
)
-
>
DocumentPrincipal
(
)
;
}
nsIContent
*
GetParent
(
)
const
{
return
MOZ_LIKELY
(
GetBoolFlag
(
ParentIsContent
)
)
?
reinterpret_cast
<
nsIContent
*
>
(
mParent
)
:
nullptr
;
}
nsINode
*
GetParentNode
(
)
const
{
return
mParent
;
}
nsINode
*
GetParentOrHostNode
(
)
const
;
enum
FlattenedParentType
{
eNotForStyle
eForStyle
}
;
inline
nsINode
*
GetFlattenedTreeParentNode
(
)
const
;
inline
nsINode
*
GetFlattenedTreeParentNodeForStyle
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFlattenedTreeParentElement
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetFlattenedTreeParentElementForStyle
(
)
const
;
inline
mozilla
:
:
dom
:
:
Element
*
GetParentElement
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetParentElementCrossingShadowRoot
(
)
const
;
nsINode
*
SubtreeRoot
(
)
const
;
nsINode
*
GetRootNode
(
const
mozilla
:
:
dom
:
:
GetRootNodeOptions
&
aOptions
)
;
virtual
mozilla
:
:
EventListenerManager
*
GetExistingListenerManager
(
)
const
override
;
virtual
mozilla
:
:
EventListenerManager
*
GetOrCreateListenerManager
(
)
override
;
bool
ComputeDefaultWantsUntrusted
(
mozilla
:
:
ErrorResult
&
aRv
)
final
;
virtual
bool
IsApzAware
(
)
const
override
;
virtual
nsPIDOMWindowOuter
*
GetOwnerGlobalForBindings
(
)
override
;
virtual
nsIGlobalObject
*
GetOwnerGlobal
(
)
const
override
;
using
mozilla
:
:
dom
:
:
EventTarget
:
:
DispatchEvent
;
bool
DispatchEvent
(
mozilla
:
:
dom
:
:
Event
&
aEvent
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
override
;
nsresult
PostHandleEvent
(
mozilla
:
:
EventChainPostVisitor
&
aVisitor
)
override
;
void
AddMutationObserver
(
nsIMutationObserver
*
aMutationObserver
)
{
nsSlots
*
s
=
Slots
(
)
;
NS_ASSERTION
(
s
-
>
mMutationObservers
.
IndexOf
(
aMutationObserver
)
=
=
nsTArray
<
int
>
:
:
NoIndex
"
Observer
already
in
the
list
"
)
;
s
-
>
mMutationObservers
.
AppendElement
(
aMutationObserver
)
;
}
void
AddMutationObserverUnlessExists
(
nsIMutationObserver
*
aMutationObserver
)
{
nsSlots
*
s
=
Slots
(
)
;
s
-
>
mMutationObservers
.
AppendElementUnlessExists
(
aMutationObserver
)
;
}
void
AddAnimationObserver
(
nsIAnimationObserver
*
aAnimationObserver
)
;
void
AddAnimationObserverUnlessExists
(
nsIAnimationObserver
*
aAnimationObserver
)
;
void
RemoveMutationObserver
(
nsIMutationObserver
*
aMutationObserver
)
{
nsSlots
*
s
=
GetExistingSlots
(
)
;
if
(
s
)
{
s
-
>
mMutationObservers
.
RemoveElement
(
aMutationObserver
)
;
}
}
virtual
nsresult
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
=
0
;
class
nsSlots
{
public
:
nsSlots
(
)
;
virtual
~
nsSlots
(
)
;
virtual
void
Traverse
(
nsCycleCollectionTraversalCallback
&
)
;
virtual
void
Unlink
(
)
;
nsAutoTObserverArray
<
nsIMutationObserver
*
1
>
mMutationObservers
;
RefPtr
<
nsAttrChildContentList
>
mChildNodes
;
nsNodeWeakReference
*
MOZ_NON_OWNING_REF
mWeakReference
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
LinkedList
<
nsRange
>
>
mCommonAncestorRanges
;
uint32_t
mEditableDescendantCount
;
}
;
#
ifdef
DEBUG
nsSlots
*
DebugGetSlots
(
)
{
return
Slots
(
)
;
}
#
endif
void
SetFlags
(
FlagsType
aFlagsToSet
)
{
NS_ASSERTION
(
!
(
aFlagsToSet
&
(
NODE_IS_ANONYMOUS_ROOT
|
NODE_IS_NATIVE_ANONYMOUS_ROOT
|
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
|
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
|
NODE_CHROME_ONLY_ACCESS
)
)
|
|
IsContent
(
)
"
Flag
only
permitted
on
nsIContent
nodes
"
)
;
nsWrapperCache
:
:
SetFlags
(
aFlagsToSet
)
;
}
void
UnsetFlags
(
FlagsType
aFlagsToUnset
)
{
NS_ASSERTION
(
!
(
aFlagsToUnset
&
(
NODE_IS_ANONYMOUS_ROOT
|
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
|
NODE_IS_NATIVE_ANONYMOUS_ROOT
)
)
"
Trying
to
unset
write
-
only
flags
"
)
;
nsWrapperCache
:
:
UnsetFlags
(
aFlagsToUnset
)
;
}
void
ChangeEditableDescendantCount
(
int32_t
aDelta
)
;
uint32_t
EditableDescendantCount
(
)
;
void
ResetEditableDescendantCount
(
)
;
void
SetEditableFlag
(
bool
aEditable
)
{
if
(
aEditable
)
{
SetFlags
(
NODE_IS_EDITABLE
)
;
}
else
{
UnsetFlags
(
NODE_IS_EDITABLE
)
;
}
}
inline
bool
IsEditable
(
)
const
;
bool
IsInNativeAnonymousSubtree
(
)
const
{
#
ifdef
DEBUG
if
(
HasFlag
(
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
)
)
{
return
true
;
}
CheckNotNativeAnonymous
(
)
;
return
false
;
#
else
return
HasFlag
(
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
)
;
#
endif
}
bool
IsInAnonymousSubtree
(
)
const
;
bool
IsAnonymousContentInSVGUseSubtree
(
)
const
;
bool
ChromeOnlyAccess
(
)
const
{
return
HasFlag
(
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
|
NODE_CHROME_ONLY_ACCESS
)
;
}
bool
IsInShadowTree
(
)
const
{
return
HasFlag
(
NODE_IS_IN_SHADOW_TREE
)
;
}
bool
IsSelectionDescendant
(
)
const
{
return
IsDescendantOfCommonAncestorForRangeInSelection
(
)
|
|
IsCommonAncestorForRangeInSelection
(
)
;
}
nsIContent
*
GetTextEditorRootContent
(
mozilla
:
:
TextEditor
*
*
aTextEditor
=
nullptr
)
;
nsIContent
*
GetSelectionRootContent
(
nsIPresShell
*
aPresShell
)
;
nsINodeList
*
ChildNodes
(
)
;
nsIContent
*
GetFirstChild
(
)
const
{
return
mFirstChild
;
}
nsIContent
*
GetLastChild
(
)
const
{
uint32_t
count
=
GetChildCount
(
)
;
return
count
>
0
?
GetChildAt_Deprecated
(
count
-
1
)
:
nullptr
;
}
nsIDocument
*
GetOwnerDocument
(
)
const
;
void
Normalize
(
)
;
virtual
already_AddRefed
<
nsIURI
>
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
=
false
)
const
=
0
;
already_AddRefed
<
nsIURI
>
GetBaseURIObject
(
)
const
;
bool
IsNodeApzAware
(
)
const
{
return
NodeMayBeApzAware
(
)
?
IsNodeApzAwareInternal
(
)
:
false
;
}
virtual
bool
IsNodeApzAwareInternal
(
)
const
;
void
GetTextContent
(
nsAString
&
aTextContent
mozilla
:
:
OOMReporter
&
aError
)
{
GetTextContentInternal
(
aTextContent
aError
)
;
}
void
SetTextContent
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
{
SetTextContentInternal
(
aTextContent
aSubjectPrincipal
aError
)
;
}
void
SetTextContent
(
const
nsAString
&
aTextContent
mozilla
:
:
ErrorResult
&
aError
)
{
SetTextContentInternal
(
aTextContent
nullptr
aError
)
;
}
mozilla
:
:
dom
:
:
Element
*
QuerySelector
(
const
nsAString
&
aSelector
mozilla
:
:
ErrorResult
&
aResult
)
;
already_AddRefed
<
nsINodeList
>
QuerySelectorAll
(
const
nsAString
&
aSelector
mozilla
:
:
ErrorResult
&
aResult
)
;
protected
:
mozilla
:
:
dom
:
:
Element
*
GetElementById
(
const
nsAString
&
aId
)
;
public
:
void
LookupPrefix
(
const
nsAString
&
aNamespace
nsAString
&
aResult
)
;
bool
IsDefaultNamespace
(
const
nsAString
&
aNamespaceURI
)
{
nsAutoString
defaultNamespace
;
LookupNamespaceURI
(
EmptyString
(
)
defaultNamespace
)
;
return
aNamespaceURI
.
Equals
(
defaultNamespace
)
;
}
void
LookupNamespaceURI
(
const
nsAString
&
aNamespacePrefix
nsAString
&
aNamespaceURI
)
;
nsIContent
*
GetNextSibling
(
)
const
{
return
mNextSibling
;
}
nsIContent
*
GetPreviousSibling
(
)
const
{
return
mPreviousSibling
;
}
nsIContent
*
GetNextNode
(
const
nsINode
*
aRoot
=
nullptr
)
const
{
return
GetNextNodeImpl
(
aRoot
false
)
;
}
nsIContent
*
GetNextNonChildNode
(
const
nsINode
*
aRoot
=
nullptr
)
const
{
return
GetNextNodeImpl
(
aRoot
true
)
;
}
bool
Contains
(
const
nsINode
*
aOther
)
const
;
bool
UnoptimizableCCNode
(
)
const
;
private
:
nsIDocument
*
GetComposedDocInternal
(
)
const
;
nsIContent
*
GetNextNodeImpl
(
const
nsINode
*
aRoot
const
bool
aSkipChildren
)
const
{
#
ifdef
DEBUG
if
(
aRoot
)
{
const
nsINode
*
cur
=
this
;
for
(
;
cur
;
cur
=
cur
-
>
GetParentNode
(
)
)
if
(
cur
=
=
aRoot
)
break
;
NS_ASSERTION
(
cur
"
aRoot
not
an
ancestor
of
|
this
|
?
"
)
;
}
#
endif
if
(
!
aSkipChildren
)
{
nsIContent
*
kid
=
GetFirstChild
(
)
;
if
(
kid
)
{
return
kid
;
}
}
if
(
this
=
=
aRoot
)
{
return
nullptr
;
}
const
nsINode
*
cur
=
this
;
while
(
1
)
{
nsIContent
*
next
=
cur
-
>
GetNextSibling
(
)
;
if
(
next
)
{
return
next
;
}
nsINode
*
parent
=
cur
-
>
GetParentNode
(
)
;
if
(
parent
=
=
aRoot
)
{
return
nullptr
;
}
cur
=
parent
;
}
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
get
here
?
"
)
;
}
public
:
nsIContent
*
GetPreviousContent
(
const
nsINode
*
aRoot
=
nullptr
)
const
{
#
ifdef
DEBUG
if
(
aRoot
)
{
const
nsINode
*
cur
=
this
;
for
(
;
cur
;
cur
=
cur
-
>
GetParentNode
(
)
)
if
(
cur
=
=
aRoot
)
break
;
NS_ASSERTION
(
cur
"
aRoot
not
an
ancestor
of
|
this
|
?
"
)
;
}
#
endif
if
(
this
=
=
aRoot
)
{
return
nullptr
;
}
nsIContent
*
cur
=
this
-
>
GetParent
(
)
;
nsIContent
*
iter
=
this
-
>
GetPreviousSibling
(
)
;
while
(
iter
)
{
cur
=
iter
;
iter
=
reinterpret_cast
<
nsINode
*
>
(
iter
)
-
>
GetLastChild
(
)
;
}
return
cur
;
}
private
:
enum
BooleanFlag
{
NodeHasRenderingObservers
IsInDocument
ParentIsContent
NodeIsElement
ElementHasID
ElementMayHaveClass
ElementMayHaveStyle
ElementHasName
ElementMayHaveContentEditableAttr
NodeIsCommonAncestorForRangeInSelection
NodeIsDescendantOfCommonAncestorForRangeInSelection
NodeIsCCMarkedRoot
NodeIsCCBlackTree
NodeIsPurpleRoot
ElementHasLockedStyleStates
ElementHasPointerLock
NodeMayHaveDOMMutationObserver
NodeIsContent
ElementHasAnimations
NodeHasValidDirAttribute
NodeHasDirAutoSet
NodeHasTextNodeDirectionalityMap
NodeAncestorHasDirAuto
NodeHandlingClick
NodeHasRelevantHoverRules
ElementHasWeirdParserInsertionMode
ParserHasNotified
MayBeApzAware
ElementMayHaveAnonymousChildren
BooleanFlagCount
}
;
void
SetBoolFlag
(
BooleanFlag
name
bool
value
)
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
mBoolFlags
=
(
mBoolFlags
&
~
(
1
<
<
name
)
)
|
(
value
<
<
name
)
;
}
void
SetBoolFlag
(
BooleanFlag
name
)
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
mBoolFlags
|
=
(
1
<
<
name
)
;
}
void
ClearBoolFlag
(
BooleanFlag
name
)
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
mBoolFlags
&
=
~
(
1
<
<
name
)
;
}
bool
GetBoolFlag
(
BooleanFlag
name
)
const
{
static_assert
(
BooleanFlagCount
<
=
8
*
sizeof
(
mBoolFlags
)
"
Too
many
boolean
flags
"
)
;
return
mBoolFlags
&
(
1
<
<
name
)
;
}
public
:
bool
HasRenderingObservers
(
)
const
{
return
GetBoolFlag
(
NodeHasRenderingObservers
)
;
}
void
SetHasRenderingObservers
(
bool
aValue
)
{
SetBoolFlag
(
NodeHasRenderingObservers
aValue
)
;
}
bool
IsContent
(
)
const
{
return
GetBoolFlag
(
NodeIsContent
)
;
}
bool
HasID
(
)
const
{
return
GetBoolFlag
(
ElementHasID
)
;
}
bool
MayHaveClass
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveClass
)
;
}
void
SetMayHaveClass
(
)
{
SetBoolFlag
(
ElementMayHaveClass
)
;
}
bool
MayHaveStyle
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveStyle
)
;
}
bool
HasName
(
)
const
{
return
GetBoolFlag
(
ElementHasName
)
;
}
bool
MayHaveContentEditableAttr
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveContentEditableAttr
)
;
}
bool
IsCommonAncestorForRangeInSelection
(
)
const
{
return
GetBoolFlag
(
NodeIsCommonAncestorForRangeInSelection
)
;
}
void
SetCommonAncestorForRangeInSelection
(
)
{
SetBoolFlag
(
NodeIsCommonAncestorForRangeInSelection
)
;
}
void
ClearCommonAncestorForRangeInSelection
(
)
{
ClearBoolFlag
(
NodeIsCommonAncestorForRangeInSelection
)
;
}
bool
IsDescendantOfCommonAncestorForRangeInSelection
(
)
const
{
return
GetBoolFlag
(
NodeIsDescendantOfCommonAncestorForRangeInSelection
)
;
}
void
SetDescendantOfCommonAncestorForRangeInSelection
(
)
{
SetBoolFlag
(
NodeIsDescendantOfCommonAncestorForRangeInSelection
)
;
}
void
ClearDescendantOfCommonAncestorForRangeInSelection
(
)
{
ClearBoolFlag
(
NodeIsDescendantOfCommonAncestorForRangeInSelection
)
;
}
void
SetCCMarkedRoot
(
bool
aValue
)
{
SetBoolFlag
(
NodeIsCCMarkedRoot
aValue
)
;
}
bool
CCMarkedRoot
(
)
const
{
return
GetBoolFlag
(
NodeIsCCMarkedRoot
)
;
}
void
SetInCCBlackTree
(
bool
aValue
)
{
SetBoolFlag
(
NodeIsCCBlackTree
aValue
)
;
}
bool
InCCBlackTree
(
)
const
{
return
GetBoolFlag
(
NodeIsCCBlackTree
)
;
}
void
SetIsPurpleRoot
(
bool
aValue
)
{
SetBoolFlag
(
NodeIsPurpleRoot
aValue
)
;
}
bool
IsPurpleRoot
(
)
const
{
return
GetBoolFlag
(
NodeIsPurpleRoot
)
;
}
bool
MayHaveDOMMutationObserver
(
)
{
return
GetBoolFlag
(
NodeMayHaveDOMMutationObserver
)
;
}
void
SetMayHaveDOMMutationObserver
(
)
{
SetBoolFlag
(
NodeMayHaveDOMMutationObserver
true
)
;
}
bool
HasListenerManager
(
)
{
return
HasFlag
(
NODE_HAS_LISTENERMANAGER
)
;
}
bool
HasPointerLock
(
)
const
{
return
GetBoolFlag
(
ElementHasPointerLock
)
;
}
void
SetPointerLock
(
)
{
SetBoolFlag
(
ElementHasPointerLock
)
;
}
void
ClearPointerLock
(
)
{
ClearBoolFlag
(
ElementHasPointerLock
)
;
}
bool
MayHaveAnimations
(
)
const
{
return
GetBoolFlag
(
ElementHasAnimations
)
;
}
void
SetMayHaveAnimations
(
)
{
SetBoolFlag
(
ElementHasAnimations
)
;
}
void
SetHasValidDir
(
)
{
SetBoolFlag
(
NodeHasValidDirAttribute
)
;
}
void
ClearHasValidDir
(
)
{
ClearBoolFlag
(
NodeHasValidDirAttribute
)
;
}
bool
HasValidDir
(
)
const
{
return
GetBoolFlag
(
NodeHasValidDirAttribute
)
;
}
void
SetHasDirAutoSet
(
)
{
MOZ_ASSERT
(
NodeType
(
)
!
=
TEXT_NODE
"
SetHasDirAutoSet
on
text
node
"
)
;
SetBoolFlag
(
NodeHasDirAutoSet
)
;
}
void
ClearHasDirAutoSet
(
)
{
MOZ_ASSERT
(
NodeType
(
)
!
=
TEXT_NODE
"
ClearHasDirAutoSet
on
text
node
"
)
;
ClearBoolFlag
(
NodeHasDirAutoSet
)
;
}
bool
HasDirAutoSet
(
)
const
{
return
GetBoolFlag
(
NodeHasDirAutoSet
)
;
}
void
SetHasTextNodeDirectionalityMap
(
)
{
MOZ_ASSERT
(
NodeType
(
)
=
=
TEXT_NODE
"
SetHasTextNodeDirectionalityMap
on
non
-
text
node
"
)
;
SetBoolFlag
(
NodeHasTextNodeDirectionalityMap
)
;
}
void
ClearHasTextNodeDirectionalityMap
(
)
{
MOZ_ASSERT
(
NodeType
(
)
=
=
TEXT_NODE
"
ClearHasTextNodeDirectionalityMap
on
non
-
text
node
"
)
;
ClearBoolFlag
(
NodeHasTextNodeDirectionalityMap
)
;
}
bool
HasTextNodeDirectionalityMap
(
)
const
{
MOZ_ASSERT
(
NodeType
(
)
=
=
TEXT_NODE
"
HasTextNodeDirectionalityMap
on
non
-
text
node
"
)
;
return
GetBoolFlag
(
NodeHasTextNodeDirectionalityMap
)
;
}
void
SetAncestorHasDirAuto
(
)
{
SetBoolFlag
(
NodeAncestorHasDirAuto
)
;
}
void
ClearAncestorHasDirAuto
(
)
{
ClearBoolFlag
(
NodeAncestorHasDirAuto
)
;
}
bool
AncestorHasDirAuto
(
)
const
{
return
GetBoolFlag
(
NodeAncestorHasDirAuto
)
;
}
inline
bool
NodeOrAncestorHasDirAuto
(
)
const
;
bool
HasRelevantHoverRules
(
)
const
{
return
GetBoolFlag
(
NodeHasRelevantHoverRules
)
;
}
void
SetHasRelevantHoverRules
(
)
{
SetBoolFlag
(
NodeHasRelevantHoverRules
)
;
}
void
SetParserHasNotified
(
)
{
SetBoolFlag
(
ParserHasNotified
)
;
}
;
bool
HasParserNotified
(
)
{
return
GetBoolFlag
(
ParserHasNotified
)
;
}
void
SetMayBeApzAware
(
)
{
SetBoolFlag
(
MayBeApzAware
)
;
}
bool
NodeMayBeApzAware
(
)
const
{
return
GetBoolFlag
(
MayBeApzAware
)
;
}
void
SetMayHaveAnonymousChildren
(
)
{
SetBoolFlag
(
ElementMayHaveAnonymousChildren
)
;
}
bool
MayHaveAnonymousChildren
(
)
const
{
return
GetBoolFlag
(
ElementMayHaveAnonymousChildren
)
;
}
protected
:
void
SetParentIsContent
(
bool
aValue
)
{
SetBoolFlag
(
ParentIsContent
aValue
)
;
}
void
SetIsInDocument
(
)
{
SetBoolFlag
(
IsInDocument
)
;
}
void
SetNodeIsContent
(
)
{
SetBoolFlag
(
NodeIsContent
)
;
}
void
ClearInDocument
(
)
{
ClearBoolFlag
(
IsInDocument
)
;
}
void
SetIsElement
(
)
{
SetBoolFlag
(
NodeIsElement
)
;
}
void
SetHasID
(
)
{
SetBoolFlag
(
ElementHasID
)
;
}
void
ClearHasID
(
)
{
ClearBoolFlag
(
ElementHasID
)
;
}
void
SetMayHaveStyle
(
)
{
SetBoolFlag
(
ElementMayHaveStyle
)
;
}
void
SetHasName
(
)
{
SetBoolFlag
(
ElementHasName
)
;
}
void
ClearHasName
(
)
{
ClearBoolFlag
(
ElementHasName
)
;
}
void
SetMayHaveContentEditableAttr
(
)
{
SetBoolFlag
(
ElementMayHaveContentEditableAttr
)
;
}
void
SetHasLockedStyleStates
(
)
{
SetBoolFlag
(
ElementHasLockedStyleStates
)
;
}
void
ClearHasLockedStyleStates
(
)
{
ClearBoolFlag
(
ElementHasLockedStyleStates
)
;
}
bool
HasLockedStyleStates
(
)
const
{
return
GetBoolFlag
(
ElementHasLockedStyleStates
)
;
}
void
SetHasWeirdParserInsertionMode
(
)
{
SetBoolFlag
(
ElementHasWeirdParserInsertionMode
)
;
}
bool
HasWeirdParserInsertionMode
(
)
const
{
return
GetBoolFlag
(
ElementHasWeirdParserInsertionMode
)
;
}
bool
HandlingClick
(
)
const
{
return
GetBoolFlag
(
NodeHandlingClick
)
;
}
void
SetHandlingClick
(
)
{
SetBoolFlag
(
NodeHandlingClick
)
;
}
void
ClearHandlingClick
(
)
{
ClearBoolFlag
(
NodeHandlingClick
)
;
}
void
SetSubtreeRootPointer
(
nsINode
*
aSubtreeRoot
)
{
NS_ASSERTION
(
aSubtreeRoot
"
aSubtreeRoot
can
never
be
null
!
"
)
;
NS_ASSERTION
(
!
(
IsContent
(
)
&
&
IsInUncomposedDoc
(
)
)
&
&
!
IsInShadowTree
(
)
"
Shouldn
'
t
be
here
!
"
)
;
mSubtreeRoot
=
aSubtreeRoot
;
}
void
ClearSubtreeRootPointer
(
)
{
mSubtreeRoot
=
nullptr
;
}
public
:
void
BindObject
(
nsISupports
*
aObject
)
;
void
UnbindObject
(
nsISupports
*
aObject
)
;
void
GenerateXPath
(
nsAString
&
aResult
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Localize
(
JSContext
*
aCx
mozilla
:
:
dom
:
:
L10nCallback
&
aCallback
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
AccessibleNode
>
GetAccessibleNode
(
)
;
uint32_t
Length
(
)
const
;
void
GetNodeName
(
mozilla
:
:
dom
:
:
DOMString
&
aNodeName
)
{
const
nsString
&
nodeName
=
NodeName
(
)
;
aNodeName
.
SetKnownLiveString
(
nodeName
)
;
}
MOZ_MUST_USE
nsresult
GetBaseURI
(
nsAString
&
aBaseURI
)
const
;
void
GetBaseURIFromJS
(
nsAString
&
aBaseURI
CallerType
aCallerType
ErrorResult
&
aRv
)
const
;
bool
HasChildNodes
(
)
const
{
return
HasChildren
(
)
;
}
uint16_t
CompareDocumentPosition
(
nsINode
&
aOther
)
const
;
void
GetNodeValue
(
nsAString
&
aNodeValue
)
{
GetNodeValueInternal
(
aNodeValue
)
;
}
void
SetNodeValue
(
const
nsAString
&
aNodeValue
mozilla
:
:
ErrorResult
&
aError
)
{
SetNodeValueInternal
(
aNodeValue
aError
)
;
}
virtual
void
GetNodeValueInternal
(
nsAString
&
aNodeValue
)
;
virtual
void
SetNodeValueInternal
(
const
nsAString
&
aNodeValue
mozilla
:
:
ErrorResult
&
aError
)
{
}
void
EnsurePreInsertionValidity
(
nsINode
&
aNewChild
nsINode
*
aRefChild
mozilla
:
:
ErrorResult
&
aError
)
;
nsINode
*
InsertBefore
(
nsINode
&
aNode
nsINode
*
aChild
mozilla
:
:
ErrorResult
&
aError
)
{
return
ReplaceOrInsertBefore
(
false
&
aNode
aChild
aError
)
;
}
nsINode
*
AppendChild
(
nsINode
&
aNode
mozilla
:
:
ErrorResult
&
aError
)
{
return
InsertBefore
(
aNode
nullptr
aError
)
;
}
nsINode
*
ReplaceChild
(
nsINode
&
aNode
nsINode
&
aChild
mozilla
:
:
ErrorResult
&
aError
)
{
return
ReplaceOrInsertBefore
(
true
&
aNode
&
aChild
aError
)
;
}
nsINode
*
RemoveChild
(
nsINode
&
aChild
mozilla
:
:
ErrorResult
&
aError
)
;
already_AddRefed
<
nsINode
>
CloneNode
(
bool
aDeep
mozilla
:
:
ErrorResult
&
aError
)
;
bool
IsSameNode
(
nsINode
*
aNode
)
;
bool
IsEqualNode
(
nsINode
*
aNode
)
;
void
GetNamespaceURI
(
nsAString
&
aNamespaceURI
)
const
{
mNodeInfo
-
>
GetNamespaceURI
(
aNamespaceURI
)
;
}
#
ifdef
MOZILLA_INTERNAL_API
void
GetPrefix
(
nsAString
&
aPrefix
)
{
mNodeInfo
-
>
GetPrefix
(
aPrefix
)
;
}
#
endif
void
GetLocalName
(
mozilla
:
:
dom
:
:
DOMString
&
aLocalName
)
const
{
const
nsString
&
localName
=
LocalName
(
)
;
aLocalName
.
SetKnownLiveString
(
localName
)
;
}
nsDOMAttributeMap
*
GetAttributes
(
)
;
nsresult
RemoveFromParent
(
)
{
nsINode
*
parent
=
GetParentNode
(
)
;
mozilla
:
:
ErrorResult
rv
;
parent
-
>
RemoveChild
(
*
this
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
mozilla
:
:
dom
:
:
Element
*
GetPreviousElementSibling
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetNextElementSibling
(
)
const
;
MOZ_CAN_RUN_SCRIPT
void
Before
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
After
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
ReplaceWith
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
void
Remove
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetFirstElementChild
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetLastElementChild
(
)
const
;
MOZ_CAN_RUN_SCRIPT
void
Prepend
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
MOZ_CAN_RUN_SCRIPT
void
Append
(
const
Sequence
<
OwningNodeOrString
>
&
aNodes
ErrorResult
&
aRv
)
;
void
GetBoxQuads
(
const
BoxQuadOptions
&
aOptions
nsTArray
<
RefPtr
<
DOMQuad
>
>
&
aResult
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMQuad
>
ConvertQuadFromNode
(
DOMQuad
&
aQuad
const
TextOrElementOrDocument
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMQuad
>
ConvertRectFromNode
(
DOMRectReadOnly
&
aRect
const
TextOrElementOrDocument
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
;
already_AddRefed
<
DOMPoint
>
ConvertPointFromNode
(
const
DOMPointInit
&
aPoint
const
TextOrElementOrDocument
&
aFrom
const
ConvertCoordinateOptions
&
aOptions
CallerType
aCallerType
ErrorResult
&
aRv
)
;
const
mozilla
:
:
LinkedList
<
nsRange
>
*
GetExistingCommonAncestorRanges
(
)
const
{
if
(
!
HasSlots
(
)
)
{
return
nullptr
;
}
return
GetExistingSlots
(
)
-
>
mCommonAncestorRanges
.
get
(
)
;
}
mozilla
:
:
LinkedList
<
nsRange
>
*
GetExistingCommonAncestorRanges
(
)
{
if
(
!
HasSlots
(
)
)
{
return
nullptr
;
}
return
GetExistingSlots
(
)
-
>
mCommonAncestorRanges
.
get
(
)
;
}
mozilla
:
:
UniquePtr
<
mozilla
:
:
LinkedList
<
nsRange
>
>
&
GetCommonAncestorRangesPtr
(
)
{
return
Slots
(
)
-
>
mCommonAncestorRanges
;
}
nsIWeakReference
*
GetExistingWeakReference
(
)
{
return
HasSlots
(
)
?
GetExistingSlots
(
)
-
>
mWeakReference
:
nullptr
;
}
protected
:
virtual
nsINode
:
:
nsSlots
*
CreateSlots
(
)
;
bool
HasSlots
(
)
const
{
return
mSlots
!
=
nullptr
;
}
nsSlots
*
GetExistingSlots
(
)
const
{
return
mSlots
;
}
nsSlots
*
Slots
(
)
{
if
(
!
HasSlots
(
)
)
{
mSlots
=
CreateSlots
(
)
;
MOZ_ASSERT
(
mSlots
)
;
}
return
GetExistingSlots
(
)
;
}
nsAutoTObserverArray
<
nsIMutationObserver
*
1
>
*
GetMutationObservers
(
)
{
return
HasSlots
(
)
?
&
GetExistingSlots
(
)
-
>
mMutationObservers
:
nullptr
;
}
void
InvalidateChildNodes
(
)
;
virtual
void
GetTextContentInternal
(
nsAString
&
aTextContent
mozilla
:
:
OOMReporter
&
aError
)
;
virtual
void
SetTextContentInternal
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
aError
)
{
}
#
ifdef
DEBUG
virtual
void
CheckNotNativeAnonymous
(
)
const
;
#
endif
void
EnsurePreInsertionValidity1
(
nsINode
&
aNewChild
nsINode
*
aRefChild
mozilla
:
:
ErrorResult
&
aError
)
;
void
EnsurePreInsertionValidity2
(
bool
aReplace
nsINode
&
aNewChild
nsINode
*
aRefChild
mozilla
:
:
ErrorResult
&
aError
)
;
nsINode
*
ReplaceOrInsertBefore
(
bool
aReplace
nsINode
*
aNewChild
nsINode
*
aRefChild
mozilla
:
:
ErrorResult
&
aError
)
;
virtual
mozilla
:
:
dom
:
:
Element
*
GetNameSpaceElement
(
)
=
0
;
void
doRemoveChildAt
(
uint32_t
aIndex
bool
aNotify
nsIContent
*
aKid
nsAttrAndChildArray
&
aChildArray
)
;
nsresult
doInsertChildAt
(
nsIContent
*
aKid
uint32_t
aIndex
bool
aNotify
nsAttrAndChildArray
&
aChildArray
)
;
const
RawServoSelectorList
*
ParseSelectorList
(
const
nsAString
&
aSelectorString
mozilla
:
:
ErrorResult
&
)
;
public
:
#
define
EVENT
(
name_
id_
type_
struct_
)
\
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
GetOn
#
#
name_
(
)
;
\
void
SetOn
#
#
name_
(
mozilla
:
:
dom
:
:
EventHandlerNonNull
*
listener
)
;
#
define
TOUCH_EVENT
EVENT
#
define
DOCUMENT_ONLY_EVENT
EVENT
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
DOCUMENT_ONLY_EVENT
#
undef
TOUCH_EVENT
#
undef
EVENT
protected
:
static
bool
Traverse
(
nsINode
*
tmp
nsCycleCollectionTraversalCallback
&
cb
)
;
static
void
Unlink
(
nsINode
*
tmp
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
mNodeInfo
;
nsINode
*
MOZ_OWNING_REF
mParent
;
private
:
#
ifndef
BOOL_FLAGS_ON_WRAPPER_CACHE
uint32_t
mBoolFlags
;
#
endif
protected
:
nsIContent
*
MOZ_NON_OWNING_REF
mNextSibling
;
nsIContent
*
MOZ_NON_OWNING_REF
mPreviousSibling
;
nsIContent
*
MOZ_NON_OWNING_REF
mFirstChild
;
union
{
nsIFrame
*
mPrimaryFrame
;
nsINode
*
MOZ_NON_OWNING_REF
mSubtreeRoot
;
}
;
nsSlots
*
mSlots
;
}
;
template
<
class
C
class
D
>
inline
nsINode
*
NODE_FROM
(
C
&
aContent
D
&
aDocument
)
{
if
(
aContent
)
return
static_cast
<
nsINode
*
>
(
aContent
)
;
return
static_cast
<
nsINode
*
>
(
aDocument
)
;
}
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsINode
NS_INODE_IID
)
inline
nsISupports
*
ToSupports
(
nsINode
*
aPointer
)
{
return
aPointer
;
}
#
define
NS_IMPL_FROMNODE_GENERIC
(
_class
_check
_const
)
\
template
<
typename
T
>
\
static
auto
FromNode
(
_const
T
&
aNode
)
\
-
>
decltype
(
static_cast
<
_const
_class
*
>
(
&
aNode
)
)
\
{
\
return
aNode
.
_check
?
static_cast
<
_const
_class
*
>
(
&
aNode
)
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
_const
_class
*
FromNode
(
_const
T
*
aNode
)
\
{
\
return
FromNode
(
*
aNode
)
;
\
}
\
template
<
typename
T
>
\
static
_const
_class
*
FromNodeOrNull
(
_const
T
*
aNode
)
\
{
\
return
aNode
?
FromNode
(
*
aNode
)
:
nullptr
;
\
}
#
define
NS_IMPL_FROMNODE_HELPER
(
_class
_check
)
\
NS_IMPL_FROMNODE_GENERIC
(
_class
_check
)
\
NS_IMPL_FROMNODE_GENERIC
(
_class
_check
const
)
\
\
template
<
typename
T
>
\
static
_class
*
FromNode
(
T
&
&
aNode
)
\
{
\
/
*
We
need
the
double
-
cast
in
case
aNode
is
a
smartptr
.
Those
*
/
\
/
*
can
cast
to
superclasses
of
the
type
they
'
re
templated
on
*
/
\
/
*
but
not
directly
to
subclasses
.
*
/
\
return
aNode
-
>
_check
\
?
static_cast
<
_class
*
>
(
static_cast
<
nsINode
*
>
(
aNode
)
)
\
:
nullptr
;
\
}
\
template
<
typename
T
>
\
static
_class
*
FromNodeOrNull
(
T
&
&
aNode
)
\
{
\
return
aNode
?
FromNode
(
aNode
)
:
nullptr
;
\
}
#
define
NS_IMPL_FROMNODE
(
_class
_nsid
)
\
NS_IMPL_FROMNODE_HELPER
(
_class
IsInNamespace
(
_nsid
)
)
#
define
NS_IMPL_FROMNODE_WITH_TAG
(
_class
_nsid
_tag
)
\
NS_IMPL_FROMNODE_HELPER
(
_class
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
_tag
_nsid
)
)
#
define
NS_IMPL_FROMNODE_HTML_WITH_TAG
(
_class
_tag
)
\
NS_IMPL_FROMNODE_WITH_TAG
(
_class
kNameSpaceID_XHTML
_tag
)
#
endif
