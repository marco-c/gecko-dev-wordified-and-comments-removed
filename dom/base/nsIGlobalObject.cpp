#
include
"
nsIGlobalObject
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorker
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsHostObjectProtocolHandler
.
h
"
using
mozilla
:
:
MallocSizeOf
;
using
mozilla
:
:
Maybe
;
using
mozilla
:
:
DOMEventTargetHelper
;
using
mozilla
:
:
dom
:
:
ClientInfo
;
using
mozilla
:
:
dom
:
:
ServiceWorker
;
using
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
;
nsIGlobalObject
:
:
~
nsIGlobalObject
(
)
{
UnlinkHostObjectURIs
(
)
;
DisconnectEventTargetObjects
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mEventTargetObjects
.
IsEmpty
(
)
)
;
}
nsIPrincipal
*
nsIGlobalObject
:
:
PrincipalOrNull
(
)
{
JSObject
*
global
=
GetGlobalJSObject
(
)
;
if
(
NS_WARN_IF
(
!
global
)
)
return
nullptr
;
return
nsContentUtils
:
:
ObjectPrincipal
(
global
)
;
}
void
nsIGlobalObject
:
:
RegisterHostObjectURI
(
const
nsACString
&
aURI
)
{
MOZ_ASSERT
(
!
mHostObjectURIs
.
Contains
(
aURI
)
)
;
mHostObjectURIs
.
AppendElement
(
aURI
)
;
}
void
nsIGlobalObject
:
:
UnregisterHostObjectURI
(
const
nsACString
&
aURI
)
{
mHostObjectURIs
.
RemoveElement
(
aURI
)
;
}
namespace
{
class
UnlinkHostObjectURIsRunnable
final
:
public
mozilla
:
:
Runnable
{
public
:
explicit
UnlinkHostObjectURIsRunnable
(
nsTArray
<
nsCString
>
&
aURIs
)
:
mozilla
:
:
Runnable
(
"
UnlinkHostObjectURIsRunnable
"
)
{
mURIs
.
SwapElements
(
aURIs
)
;
}
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
uint32_t
index
=
0
;
index
<
mURIs
.
Length
(
)
;
+
+
index
)
{
nsHostObjectProtocolHandler
:
:
RemoveDataEntry
(
mURIs
[
index
]
)
;
}
return
NS_OK
;
}
private
:
~
UnlinkHostObjectURIsRunnable
(
)
{
}
nsTArray
<
nsCString
>
mURIs
;
}
;
}
void
nsIGlobalObject
:
:
UnlinkHostObjectURIs
(
)
{
if
(
mHostObjectURIs
.
IsEmpty
(
)
)
{
return
;
}
if
(
NS_IsMainThread
(
)
)
{
for
(
uint32_t
index
=
0
;
index
<
mHostObjectURIs
.
Length
(
)
;
+
+
index
)
{
nsHostObjectProtocolHandler
:
:
RemoveDataEntry
(
mHostObjectURIs
[
index
]
)
;
}
mHostObjectURIs
.
Clear
(
)
;
return
;
}
RefPtr
<
UnlinkHostObjectURIsRunnable
>
runnable
=
new
UnlinkHostObjectURIsRunnable
(
mHostObjectURIs
)
;
MOZ_ASSERT
(
mHostObjectURIs
.
IsEmpty
(
)
)
;
nsresult
rv
=
NS_DispatchToMainThread
(
runnable
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
Failed
to
dispatch
a
runnable
to
the
main
-
thread
.
"
)
;
}
}
void
nsIGlobalObject
:
:
TraverseHostObjectURIs
(
nsCycleCollectionTraversalCallback
&
aCb
)
{
if
(
mHostObjectURIs
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
NS_IsMainThread
(
)
)
{
return
;
}
for
(
uint32_t
index
=
0
;
index
<
mHostObjectURIs
.
Length
(
)
;
+
+
index
)
{
nsHostObjectProtocolHandler
:
:
Traverse
(
mHostObjectURIs
[
index
]
aCb
)
;
}
}
void
nsIGlobalObject
:
:
AddEventTargetObject
(
DOMEventTargetHelper
*
aObject
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aObject
)
;
MOZ_ASSERT
(
!
mEventTargetObjects
.
Contains
(
aObject
)
)
;
mEventTargetObjects
.
PutEntry
(
aObject
)
;
}
void
nsIGlobalObject
:
:
RemoveEventTargetObject
(
DOMEventTargetHelper
*
aObject
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aObject
)
;
MOZ_ASSERT
(
mEventTargetObjects
.
Contains
(
aObject
)
)
;
mEventTargetObjects
.
RemoveEntry
(
aObject
)
;
}
void
nsIGlobalObject
:
:
ForEachEventTargetObject
(
const
std
:
:
function
<
void
(
DOMEventTargetHelper
*
)
>
&
aFunc
)
const
{
AutoTArray
<
DOMEventTargetHelper
*
64
>
targetList
;
for
(
auto
iter
=
mEventTargetObjects
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
targetList
.
AppendElement
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
for
(
auto
target
:
targetList
)
{
aFunc
(
target
)
;
}
}
void
nsIGlobalObject
:
:
DisconnectEventTargetObjects
(
)
{
ForEachEventTargetObject
(
[
&
]
(
DOMEventTargetHelper
*
aTarget
)
{
aTarget
-
>
DisconnectFromOwner
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mEventTargetObjects
.
Contains
(
aTarget
)
)
;
}
)
;
}
Maybe
<
ClientInfo
>
nsIGlobalObject
:
:
GetClientInfo
(
)
const
{
return
Maybe
<
ClientInfo
>
(
)
;
}
Maybe
<
ServiceWorkerDescriptor
>
nsIGlobalObject
:
:
GetController
(
)
const
{
return
Maybe
<
ServiceWorkerDescriptor
>
(
)
;
}
RefPtr
<
ServiceWorker
>
nsIGlobalObject
:
:
GetOrCreateServiceWorker
(
const
ServiceWorkerDescriptor
&
aDescriptor
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
this
global
should
not
have
any
service
workers
"
)
;
return
nullptr
;
}
size_t
nsIGlobalObject
:
:
ShallowSizeOfExcludingThis
(
MallocSizeOf
aSizeOf
)
const
{
size_t
rtn
=
mHostObjectURIs
.
ShallowSizeOfExcludingThis
(
aSizeOf
)
;
rtn
+
=
mEventTargetObjects
.
ShallowSizeOfExcludingThis
(
aSizeOf
)
;
return
rtn
;
}
