#
include
"
nsContentUtils
.
h
"
#
include
<
algorithm
>
#
include
<
math
.
h
>
#
include
"
DecoderTraits
.
h
"
#
include
"
harfbuzz
/
hb
.
h
"
#
include
"
imgICache
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
JSON
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsAppRunner
.
h
"
#
include
"
nsNPAPIPluginInstance
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
AntiTrackingCommon
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
AutoTimelineMarker
.
h
"
#
include
"
mozilla
/
BackgroundHangMonitor
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
CheckedInt
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
LoadInfo
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
MessageBroadcaster
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DOMException
.
h
"
#
include
"
mozilla
/
dom
/
DOMExceptionBinding
.
h
"
#
include
"
mozilla
/
dom
/
DOMTypes
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
FileSystemSecurity
.
h
"
#
include
"
mozilla
/
dom
/
FileBlobImpl
.
h
"
#
include
"
mozilla
/
dom
/
FontTableURIProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTemplateElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
IDTracker
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
IPCBlobUtils
.
h
"
#
include
"
mozilla
/
dom
/
NodeBinding
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
XULCommandEvent
.
h
"
#
include
"
mozilla
/
dom
/
WorkerCommon
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
gfx
/
DataSurfaceHelpers
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
ManualNAC
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsArrayUtils
.
h
"
#
include
"
nsAString
.
h
"
#
include
"
nsAttrName
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsCharSeparatedTokenizer
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentDLF
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsContentSecurityManager
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
mozilla
/
dom
/
DataTransfer
.
h
"
#
include
"
nsDOMJSUtils
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGenericHTMLFrameElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHtml5Module
.
h
"
#
include
"
nsHtml5StringParser
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsHTMLTags
.
h
"
#
include
"
nsIAddonPolicyService
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsIAsyncVerifyRedirectCallback
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsICharsetDetectionObserver
.
h
"
#
include
"
nsIChromeRegistry
.
h
"
#
include
"
nsIConsoleService
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIContentSink
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsIDOMWindowUtils
.
h
"
#
include
"
nsIDragService
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsIForm
.
h
"
#
include
"
nsIFragmentContentSink
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIdleService
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsIMemoryReporter
.
h
"
#
include
"
nsIMIMEHeaderParam
.
h
"
#
include
"
nsIMIMEService
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIOfflineCacheUpdate
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIParserUtils
.
h
"
#
include
"
nsIPermissionManager
.
h
"
#
include
"
nsIPluginHost
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptObjectPrincipal
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIScrollable
.
h
"
#
include
"
nsIStreamConverter
.
h
"
#
include
"
nsIStreamConverterService
.
h
"
#
include
"
nsIStringBundle
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIURIWithSpecialOrigin
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIWindowMediator
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsParserCIID
.
h
"
#
include
"
nsParserConstants
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsScriptSecurityManager
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsStreamUtils
.
h
"
#
include
"
nsTextEditorState
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsTreeSanitizer
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsURLHelper
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsIWindowProvider
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
HTMLSplitOnSpacesTokenizer
.
h
"
#
include
"
InProcessTabChildMessageManager
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsICookiePermission
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
BloomFilter
.
h
"
#
include
"
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
nsIWebNavigationInfo
.
h
"
#
include
"
nsPluginHost
.
h
"
#
include
"
nsIBrowser
.
h
"
#
include
"
mozilla
/
HangAnnotations
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
mozilla
/
RecordReplay
.
h
"
#
include
"
nsThreadManager
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
if
defined
(
XP_WIN
)
#
undef
LoadImage
#
endif
extern
"
C
"
int
MOZ_XMLTranslateEntity
(
const
char
*
ptr
const
char
*
end
const
char
*
*
next
char16_t
*
result
)
;
extern
"
C
"
int
MOZ_XMLCheckQName
(
const
char
*
ptr
const
char
*
end
int
ns_aware
const
char
*
*
colon
)
;
class
imgLoader
;
class
nsAtom
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
;
const
char
kLoadAsData
[
]
=
"
loadAsData
"
;
nsIXPConnect
*
nsContentUtils
:
:
sXPConnect
;
nsIScriptSecurityManager
*
nsContentUtils
:
:
sSecurityManager
;
nsIPrincipal
*
nsContentUtils
:
:
sSystemPrincipal
;
nsIPrincipal
*
nsContentUtils
:
:
sNullSubjectPrincipal
;
nsNameSpaceManager
*
nsContentUtils
:
:
sNameSpaceManager
;
nsIIOService
*
nsContentUtils
:
:
sIOService
;
nsIUUIDGenerator
*
nsContentUtils
:
:
sUUIDGenerator
;
nsIConsoleService
*
nsContentUtils
:
:
sConsoleService
;
nsDataHashtable
<
nsRefPtrHashKey
<
nsAtom
>
EventNameMapping
>
*
nsContentUtils
:
:
sAtomEventTable
=
nullptr
;
nsDataHashtable
<
nsStringHashKey
EventNameMapping
>
*
nsContentUtils
:
:
sStringEventTable
=
nullptr
;
nsTArray
<
RefPtr
<
nsAtom
>
>
*
nsContentUtils
:
:
sUserDefinedEvents
=
nullptr
;
nsIStringBundleService
*
nsContentUtils
:
:
sStringBundleService
;
nsIStringBundle
*
nsContentUtils
:
:
sStringBundles
[
PropertiesFile_COUNT
]
;
nsIContentPolicy
*
nsContentUtils
:
:
sContentPolicyService
;
bool
nsContentUtils
:
:
sTriedToGetContentPolicy
=
false
;
RefPtr
<
mozilla
:
:
intl
:
:
LineBreaker
>
nsContentUtils
:
:
sLineBreaker
;
RefPtr
<
mozilla
:
:
intl
:
:
WordBreaker
>
nsContentUtils
:
:
sWordBreaker
;
StaticRefPtr
<
nsIBidiKeyboard
>
nsContentUtils
:
:
sBidiKeyboard
;
uint32_t
nsContentUtils
:
:
sScriptBlockerCount
=
0
;
uint32_t
nsContentUtils
:
:
sDOMNodeRemovedSuppressCount
=
0
;
AutoTArray
<
nsCOMPtr
<
nsIRunnable
>
8
>
*
nsContentUtils
:
:
sBlockedScriptRunners
=
nullptr
;
uint32_t
nsContentUtils
:
:
sRunnersCountAtFirstBlocker
=
0
;
nsIInterfaceRequestor
*
nsContentUtils
:
:
sSameOriginChecker
=
nullptr
;
bool
nsContentUtils
:
:
sIsHandlingKeyBoardEvent
=
false
;
bool
nsContentUtils
:
:
sAllowXULXBL_for_file
=
false
;
nsString
*
nsContentUtils
:
:
sShiftText
=
nullptr
;
nsString
*
nsContentUtils
:
:
sControlText
=
nullptr
;
nsString
*
nsContentUtils
:
:
sMetaText
=
nullptr
;
nsString
*
nsContentUtils
:
:
sOSText
=
nullptr
;
nsString
*
nsContentUtils
:
:
sAltText
=
nullptr
;
nsString
*
nsContentUtils
:
:
sModifierSeparator
=
nullptr
;
bool
nsContentUtils
:
:
sInitialized
=
false
;
bool
nsContentUtils
:
:
sIsFullscreenApiEnabled
=
false
;
bool
nsContentUtils
:
:
sIsUnprefixedFullscreenApiEnabled
=
false
;
bool
nsContentUtils
:
:
sTrustedFullscreenOnly
=
true
;
bool
nsContentUtils
:
:
sIsCutCopyAllowed
=
true
;
bool
nsContentUtils
:
:
sIsUpgradableDisplayContentPrefEnabled
=
false
;
bool
nsContentUtils
:
:
sIsFrameTimingPrefEnabled
=
false
;
bool
nsContentUtils
:
:
sIsPerformanceTimingEnabled
=
false
;
bool
nsContentUtils
:
:
sIsResourceTimingEnabled
=
false
;
bool
nsContentUtils
:
:
sIsPerformanceNavigationTimingEnabled
=
false
;
bool
nsContentUtils
:
:
sIsFormAutofillAutocompleteEnabled
=
false
;
bool
nsContentUtils
:
:
sIsUAWidgetEnabled
=
false
;
bool
nsContentUtils
:
:
sSendPerformanceTimingNotifications
=
false
;
bool
nsContentUtils
:
:
sUseActivityCursor
=
false
;
bool
nsContentUtils
:
:
sAnimationsAPICoreEnabled
=
false
;
bool
nsContentUtils
:
:
sGetBoxQuadsEnabled
=
false
;
bool
nsContentUtils
:
:
sSkipCursorMoveForSameValueSet
=
false
;
bool
nsContentUtils
:
:
sRequestIdleCallbackEnabled
=
false
;
bool
nsContentUtils
:
:
sTailingEnabled
=
false
;
bool
nsContentUtils
:
:
sShowInputPlaceholderOnFocus
=
true
;
bool
nsContentUtils
:
:
sAutoFocusEnabled
=
true
;
#
ifndef
RELEASE_OR_BETA
bool
nsContentUtils
:
:
sBypassCSSOMOriginCheck
=
false
;
#
endif
bool
nsContentUtils
:
:
sIsBytecodeCacheEnabled
=
false
;
int32_t
nsContentUtils
:
:
sBytecodeCacheStrategy
=
0
;
nsCString
*
nsContentUtils
:
:
sJSBytecodeMimeType
=
nullptr
;
int32_t
nsContentUtils
:
:
sPrivacyMaxInnerWidth
=
1000
;
int32_t
nsContentUtils
:
:
sPrivacyMaxInnerHeight
=
1000
;
nsContentUtils
:
:
UserInteractionObserver
*
nsContentUtils
:
:
sUserInteractionObserver
=
nullptr
;
uint32_t
nsContentUtils
:
:
sHandlingInputTimeout
=
1000
;
uint32_t
nsContentUtils
:
:
sCookiesLifetimePolicy
=
nsICookieService
:
:
ACCEPT_NORMALLY
;
nsHtml5StringParser
*
nsContentUtils
:
:
sHTMLFragmentParser
=
nullptr
;
nsIParser
*
nsContentUtils
:
:
sXMLFragmentParser
=
nullptr
;
nsIFragmentContentSink
*
nsContentUtils
:
:
sXMLFragmentSink
=
nullptr
;
bool
nsContentUtils
:
:
sFragmentParsingActive
=
false
;
bool
nsContentUtils
:
:
sDoNotTrackEnabled
=
false
;
bool
nsContentUtils
:
:
sAntiTrackingControlCenterUIEnabled
=
false
;
mozilla
:
:
LazyLogModule
nsContentUtils
:
:
sDOMDumpLog
(
"
Dump
"
)
;
int32_t
nsContentUtils
:
:
sInnerOrOuterWindowCount
=
0
;
uint32_t
nsContentUtils
:
:
sInnerOrOuterWindowSerialCounter
=
0
;
enum
AutocompleteUnsupportedFieldName
:
uint8_t
{
#
define
AUTOCOMPLETE_UNSUPPORTED_FIELD_NAME
(
name_
value_
)
\
eAutocompleteUnsupportedFieldName_
#
#
name_
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_UNSUPPORTED_FIELD_NAME
}
;
enum
AutocompleteNoPersistFieldName
:
uint8_t
{
#
define
AUTOCOMPLETE_NO_PERSIST_FIELD_NAME
(
name_
value_
)
\
eAutocompleteNoPersistFieldName_
#
#
name_
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_NO_PERSIST_FIELD_NAME
}
;
enum
AutocompleteUnsupportFieldContactHint
:
uint8_t
{
#
define
AUTOCOMPLETE_UNSUPPORTED_FIELD_CONTACT_HINT
(
name_
value_
)
\
eAutocompleteUnsupportedFieldContactHint_
#
#
name_
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_UNSUPPORTED_FIELD_CONTACT_HINT
}
;
enum
AutocompleteFieldName
:
uint8_t
{
#
define
AUTOCOMPLETE_FIELD_NAME
(
name_
value_
)
eAutocompleteFieldName_
#
#
name_
#
define
AUTOCOMPLETE_CONTACT_FIELD_NAME
(
name_
value_
)
\
AUTOCOMPLETE_FIELD_NAME
(
name_
value_
)
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_FIELD_NAME
#
undef
AUTOCOMPLETE_CONTACT_FIELD_NAME
}
;
enum
AutocompleteFieldHint
:
uint8_t
{
#
define
AUTOCOMPLETE_FIELD_HINT
(
name_
value_
)
eAutocompleteFieldHint_
#
#
name_
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_FIELD_HINT
}
;
enum
AutocompleteFieldContactHint
:
uint8_t
{
#
define
AUTOCOMPLETE_FIELD_CONTACT_HINT
(
name_
value_
)
\
eAutocompleteFieldContactHint_
#
#
name_
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_FIELD_CONTACT_HINT
}
;
enum
AutocompleteCategory
{
#
define
AUTOCOMPLETE_CATEGORY
(
name_
value_
)
eAutocompleteCategory_
#
#
name_
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_CATEGORY
}
;
static
const
nsAttrValue
:
:
EnumTable
kAutocompleteUnsupportedFieldNameTable
[
]
=
{
#
define
AUTOCOMPLETE_UNSUPPORTED_FIELD_NAME
(
name_
value_
)
\
{
value_
eAutocompleteUnsupportedFieldName_
#
#
name_
}
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_UNSUPPORTED_FIELD_NAME
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kAutocompleteNoPersistFieldNameTable
[
]
=
{
#
define
AUTOCOMPLETE_NO_PERSIST_FIELD_NAME
(
name_
value_
)
\
{
value_
eAutocompleteNoPersistFieldName_
#
#
name_
}
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_NO_PERSIST_FIELD_NAME
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kAutocompleteUnsupportedContactFieldHintTable
[
]
=
{
#
define
AUTOCOMPLETE_UNSUPPORTED_FIELD_CONTACT_HINT
(
name_
value_
)
\
{
value_
eAutocompleteUnsupportedFieldContactHint_
#
#
name_
}
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_UNSUPPORTED_FIELD_CONTACT_HINT
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kAutocompleteFieldNameTable
[
]
=
{
#
define
AUTOCOMPLETE_FIELD_NAME
(
name_
value_
)
\
{
value_
eAutocompleteFieldName_
#
#
name_
}
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_FIELD_NAME
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kAutocompleteContactFieldNameTable
[
]
=
{
#
define
AUTOCOMPLETE_CONTACT_FIELD_NAME
(
name_
value_
)
\
{
value_
eAutocompleteFieldName_
#
#
name_
}
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_CONTACT_FIELD_NAME
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kAutocompleteFieldHintTable
[
]
=
{
#
define
AUTOCOMPLETE_FIELD_HINT
(
name_
value_
)
\
{
value_
eAutocompleteFieldHint_
#
#
name_
}
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_FIELD_HINT
{
nullptr
0
}
}
;
static
const
nsAttrValue
:
:
EnumTable
kAutocompleteContactFieldHintTable
[
]
=
{
#
define
AUTOCOMPLETE_FIELD_CONTACT_HINT
(
name_
value_
)
\
{
value_
eAutocompleteFieldContactHint_
#
#
name_
}
#
include
"
AutocompleteFieldList
.
h
"
#
undef
AUTOCOMPLETE_FIELD_CONTACT_HINT
{
nullptr
0
}
}
;
namespace
{
static
NS_DEFINE_CID
(
kCParserCID
NS_PARSER_CID
)
;
static
PLDHashTable
*
sEventListenerManagersHash
;
class
DOMEventListenerManagersHashReporter
final
:
public
nsIMemoryReporter
{
MOZ_DEFINE_MALLOC_SIZE_OF
(
MallocSizeOf
)
~
DOMEventListenerManagersHashReporter
(
)
=
default
;
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
override
{
int64_t
amount
=
sEventListenerManagersHash
?
sEventListenerManagersHash
-
>
ShallowSizeOfIncludingThis
(
MallocSizeOf
)
:
0
;
MOZ_COLLECT_REPORT
(
"
explicit
/
dom
/
event
-
listener
-
managers
-
hash
"
KIND_HEAP
UNITS_BYTES
amount
"
Memory
used
by
the
event
listener
manager
'
s
hash
table
.
"
)
;
return
NS_OK
;
}
}
;
NS_IMPL_ISUPPORTS
(
DOMEventListenerManagersHashReporter
nsIMemoryReporter
)
class
EventListenerManagerMapEntry
:
public
PLDHashEntryHdr
{
public
:
explicit
EventListenerManagerMapEntry
(
const
void
*
aKey
)
:
mKey
(
aKey
)
{
}
~
EventListenerManagerMapEntry
(
)
{
NS_ASSERTION
(
!
mListenerManager
"
caller
must
release
and
disconnect
ELM
"
)
;
}
protected
:
const
void
*
mKey
;
public
:
RefPtr
<
EventListenerManager
>
mListenerManager
;
}
;
static
void
EventListenerManagerHashInitEntry
(
PLDHashEntryHdr
*
entry
const
void
*
key
)
{
new
(
entry
)
EventListenerManagerMapEntry
(
key
)
;
}
static
void
EventListenerManagerHashClearEntry
(
PLDHashTable
*
table
PLDHashEntryHdr
*
entry
)
{
EventListenerManagerMapEntry
*
lm
=
static_cast
<
EventListenerManagerMapEntry
*
>
(
entry
)
;
lm
-
>
~
EventListenerManagerMapEntry
(
)
;
}
class
SameOriginCheckerImpl
final
:
public
nsIChannelEventSink
public
nsIInterfaceRequestor
{
~
SameOriginCheckerImpl
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_NSICHANNELEVENTSINK
NS_DECL_NSIINTERFACEREQUESTOR
}
;
}
class
nsContentUtils
:
:
UserInteractionObserver
final
:
public
nsIObserver
public
BackgroundHangAnnotator
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
void
Init
(
)
;
void
Shutdown
(
)
;
void
AnnotateHang
(
BackgroundHangAnnotations
&
aAnnotations
)
override
;
static
Atomic
<
bool
>
sUserActive
;
private
:
~
UserInteractionObserver
(
)
{
}
}
;
TimeDuration
nsContentUtils
:
:
HandlingUserInputTimeout
(
)
{
return
TimeDuration
:
:
FromMilliseconds
(
sHandlingInputTimeout
)
;
}
nsresult
nsContentUtils
:
:
Init
(
)
{
if
(
sInitialized
)
{
NS_WARNING
(
"
Init
(
)
called
twice
"
)
;
return
NS_OK
;
}
nsHTMLTags
:
:
AddRefTable
(
)
;
sNameSpaceManager
=
nsNameSpaceManager
:
:
GetInstance
(
)
;
NS_ENSURE_TRUE
(
sNameSpaceManager
NS_ERROR_OUT_OF_MEMORY
)
;
sXPConnect
=
nsXPConnect
:
:
XPConnect
(
)
;
NS_ADDREF
(
sXPConnect
)
;
sSecurityManager
=
nsScriptSecurityManager
:
:
GetScriptSecurityManager
(
)
;
if
(
!
sSecurityManager
)
return
NS_ERROR_FAILURE
;
NS_ADDREF
(
sSecurityManager
)
;
sSecurityManager
-
>
GetSystemPrincipal
(
&
sSystemPrincipal
)
;
MOZ_ASSERT
(
sSystemPrincipal
)
;
RefPtr
<
NullPrincipal
>
nullPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
if
(
!
nullPrincipal
)
{
return
NS_ERROR_FAILURE
;
}
nullPrincipal
.
forget
(
&
sNullSubjectPrincipal
)
;
nsresult
rv
=
CallGetService
(
NS_IOSERVICE_CONTRACTID
&
sIOService
)
;
if
(
NS_FAILED
(
rv
)
)
{
sIOService
=
nullptr
;
}
sLineBreaker
=
mozilla
:
:
intl
:
:
LineBreaker
:
:
Create
(
)
;
sWordBreaker
=
mozilla
:
:
intl
:
:
WordBreaker
:
:
Create
(
)
;
if
(
!
InitializeEventTable
(
)
)
return
NS_ERROR_FAILURE
;
if
(
!
sEventListenerManagersHash
)
{
static
const
PLDHashTableOps
hash_table_ops
=
{
PLDHashTable
:
:
HashVoidPtrKeyStub
PLDHashTable
:
:
MatchEntryStub
PLDHashTable
:
:
MoveEntryStub
EventListenerManagerHashClearEntry
EventListenerManagerHashInitEntry
}
;
sEventListenerManagersHash
=
new
PLDHashTable
(
&
hash_table_ops
sizeof
(
EventListenerManagerMapEntry
)
)
;
RegisterStrongMemoryReporter
(
new
DOMEventListenerManagersHashReporter
(
)
)
;
}
sBlockedScriptRunners
=
new
AutoTArray
<
nsCOMPtr
<
nsIRunnable
>
8
>
;
Preferences
:
:
AddBoolVarCache
(
&
sAllowXULXBL_for_file
"
dom
.
allow_XUL_XBL_for_file
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsFullscreenApiEnabled
"
full
-
screen
-
api
.
enabled
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsUnprefixedFullscreenApiEnabled
"
full
-
screen
-
api
.
unprefix
.
enabled
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sTrustedFullscreenOnly
"
full
-
screen
-
api
.
allow
-
trusted
-
requests
-
only
"
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsCutCopyAllowed
"
dom
.
allow_cut_copy
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsPerformanceTimingEnabled
"
dom
.
enable_performance
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsResourceTimingEnabled
"
dom
.
enable_resource_timing
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsPerformanceNavigationTimingEnabled
"
dom
.
enable_performance_navigation_timing
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsUpgradableDisplayContentPrefEnabled
"
security
.
mixed_content
.
upgrade_display_content
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsFrameTimingPrefEnabled
"
dom
.
enable_frame_timing
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsFormAutofillAutocompleteEnabled
"
dom
.
forms
.
autocomplete
.
formautofill
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsUAWidgetEnabled
"
dom
.
ua_widget
.
enabled
"
false
)
;
Preferences
:
:
AddIntVarCache
(
&
sPrivacyMaxInnerWidth
"
privacy
.
window
.
maxInnerWidth
"
1000
)
;
Preferences
:
:
AddIntVarCache
(
&
sPrivacyMaxInnerHeight
"
privacy
.
window
.
maxInnerHeight
"
1000
)
;
Preferences
:
:
AddUintVarCache
(
&
sHandlingInputTimeout
"
dom
.
event
.
handling
-
user
-
input
-
time
-
limit
"
1000
)
;
Preferences
:
:
AddBoolVarCache
(
&
sSendPerformanceTimingNotifications
"
dom
.
performance
.
enable_notify_performance_timing
"
false
)
;
Preferences
:
:
AddUintVarCache
(
&
sCookiesLifetimePolicy
"
network
.
cookie
.
lifetimePolicy
"
nsICookieService
:
:
ACCEPT_NORMALLY
)
;
Preferences
:
:
AddBoolVarCache
(
&
sDoNotTrackEnabled
"
privacy
.
donottrackheader
.
enabled
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sUseActivityCursor
"
ui
.
use_activity_cursor
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sAnimationsAPICoreEnabled
"
dom
.
animations
-
api
.
core
.
enabled
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sGetBoxQuadsEnabled
"
layout
.
css
.
getBoxQuads
.
enabled
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sSkipCursorMoveForSameValueSet
"
dom
.
input
.
skip_cursor_move_for_same_value_set
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sRequestIdleCallbackEnabled
"
dom
.
requestIdleCallback
.
enabled
"
false
)
;
#
ifndef
RELEASE_OR_BETA
sBypassCSSOMOriginCheck
=
getenv
(
"
MOZ_BYPASS_CSSOM_ORIGIN_CHECK
"
)
;
#
endif
Preferences
:
:
AddBoolVarCache
(
&
sTailingEnabled
"
network
.
http
.
tailing
.
enabled
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sShowInputPlaceholderOnFocus
"
dom
.
placeholder
.
show_on_focus
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sAutoFocusEnabled
"
browser
.
autofocus
"
true
)
;
Preferences
:
:
AddBoolVarCache
(
&
sIsBytecodeCacheEnabled
"
dom
.
script_loader
.
bytecode_cache
.
enabled
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sAntiTrackingControlCenterUIEnabled
"
browser
.
contentblocking
.
rejecttrackers
.
control
-
center
.
ui
.
enabled
"
false
)
;
Preferences
:
:
AddIntVarCache
(
&
sBytecodeCacheStrategy
"
dom
.
script_loader
.
bytecode_cache
.
strategy
"
0
)
;
nsDependentCString
buildID
(
mozilla
:
:
PlatformBuildID
(
)
)
;
sJSBytecodeMimeType
=
new
nsCString
(
NS_LITERAL_CSTRING
(
"
javascript
/
moz
-
bytecode
-
"
)
+
buildID
)
;
Element
:
:
InitCCCallbacks
(
)
;
Unused
<
<
nsRFPService
:
:
GetOrCreate
(
)
;
nsCOMPtr
<
nsIUUIDGenerator
>
uuidGenerator
=
do_GetService
(
"
mozilla
.
org
/
uuid
-
generator
;
1
"
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
uuidGenerator
.
forget
(
&
sUUIDGenerator
)
;
if
(
XRE_IsParentProcess
(
)
)
{
AsyncPrecreateStringBundles
(
)
;
}
RefPtr
<
UserInteractionObserver
>
uio
=
new
UserInteractionObserver
(
)
;
uio
-
>
Init
(
)
;
uio
.
forget
(
&
sUserInteractionObserver
)
;
sInitialized
=
true
;
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
RemoveWyciwygScheme
(
nsIURI
*
aURI
nsIURI
*
*
aReturn
)
{
#
ifdef
DEBUG
bool
isWyciwyg
=
false
;
aURI
-
>
SchemeIs
(
"
wyciwyg
"
&
isWyciwyg
)
;
MOZ_ASSERT
(
isWyciwyg
"
Scheme
should
be
wyciwyg
"
)
;
#
endif
nsAutoCString
path
;
nsresult
rv
=
aURI
-
>
GetPathQueryRef
(
path
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
pathLength
=
path
.
Length
(
)
;
if
(
pathLength
<
=
2
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
slashIndex
=
path
.
FindChar
(
'
/
'
2
)
;
if
(
slashIndex
=
=
kNotFound
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_NewURI
(
aReturn
Substring
(
path
slashIndex
+
1
pathLength
-
slashIndex
-
1
)
)
;
}
void
nsContentUtils
:
:
GetShiftText
(
nsAString
&
text
)
{
if
(
!
sShiftText
)
InitializeModifierStrings
(
)
;
text
.
Assign
(
*
sShiftText
)
;
}
void
nsContentUtils
:
:
GetControlText
(
nsAString
&
text
)
{
if
(
!
sControlText
)
InitializeModifierStrings
(
)
;
text
.
Assign
(
*
sControlText
)
;
}
void
nsContentUtils
:
:
GetMetaText
(
nsAString
&
text
)
{
if
(
!
sMetaText
)
InitializeModifierStrings
(
)
;
text
.
Assign
(
*
sMetaText
)
;
}
void
nsContentUtils
:
:
GetOSText
(
nsAString
&
text
)
{
if
(
!
sOSText
)
{
InitializeModifierStrings
(
)
;
}
text
.
Assign
(
*
sOSText
)
;
}
void
nsContentUtils
:
:
GetAltText
(
nsAString
&
text
)
{
if
(
!
sAltText
)
InitializeModifierStrings
(
)
;
text
.
Assign
(
*
sAltText
)
;
}
void
nsContentUtils
:
:
GetModifierSeparatorText
(
nsAString
&
text
)
{
if
(
!
sModifierSeparator
)
InitializeModifierStrings
(
)
;
text
.
Assign
(
*
sModifierSeparator
)
;
}
void
nsContentUtils
:
:
InitializeModifierStrings
(
)
{
nsCOMPtr
<
nsIStringBundleService
>
bundleService
=
mozilla
:
:
services
:
:
GetStringBundleService
(
)
;
nsCOMPtr
<
nsIStringBundle
>
bundle
;
DebugOnly
<
nsresult
>
rv
=
NS_OK
;
if
(
bundleService
)
{
rv
=
bundleService
-
>
CreateBundle
(
"
chrome
:
/
/
global
-
platform
/
locale
/
platformKeys
.
properties
"
getter_AddRefs
(
bundle
)
)
;
}
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
&
&
bundle
"
chrome
:
/
/
global
/
locale
/
platformKeys
.
properties
could
not
be
loaded
"
)
;
nsAutoString
shiftModifier
;
nsAutoString
metaModifier
;
nsAutoString
osModifier
;
nsAutoString
altModifier
;
nsAutoString
controlModifier
;
nsAutoString
modifierSeparator
;
if
(
bundle
)
{
bundle
-
>
GetStringFromName
(
"
VK_SHIFT
"
shiftModifier
)
;
bundle
-
>
GetStringFromName
(
"
VK_META
"
metaModifier
)
;
bundle
-
>
GetStringFromName
(
"
VK_WIN
"
osModifier
)
;
bundle
-
>
GetStringFromName
(
"
VK_ALT
"
altModifier
)
;
bundle
-
>
GetStringFromName
(
"
VK_CONTROL
"
controlModifier
)
;
bundle
-
>
GetStringFromName
(
"
MODIFIER_SEPARATOR
"
modifierSeparator
)
;
}
sShiftText
=
new
nsString
(
shiftModifier
)
;
sMetaText
=
new
nsString
(
metaModifier
)
;
sOSText
=
new
nsString
(
osModifier
)
;
sAltText
=
new
nsString
(
altModifier
)
;
sControlText
=
new
nsString
(
controlModifier
)
;
sModifierSeparator
=
new
nsString
(
modifierSeparator
)
;
}
mozilla
:
:
EventClassID
nsContentUtils
:
:
GetEventClassIDFromMessage
(
EventMessage
aEventMessage
)
{
switch
(
aEventMessage
)
{
#
define
MESSAGE_TO_EVENT
(
name_
message_
type_
struct_
)
\
case
message_
:
\
return
struct_
;
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
MESSAGE_TO_EVENT
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
event
message
?
"
)
;
return
eBasicEventClass
;
}
}
static
nsAtom
*
GetEventTypeFromMessage
(
EventMessage
aEventMessage
)
{
switch
(
aEventMessage
)
{
#
define
MESSAGE_TO_EVENT
(
name_
message_
type_
struct_
)
\
case
message_
:
\
return
nsGkAtoms
:
:
on
#
#
name_
;
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
MESSAGE_TO_EVENT
default
:
return
nullptr
;
}
}
static
bool
ShouldAddEventToStringEventTable
(
const
EventNameMapping
&
aMapping
)
{
MOZ_ASSERT
(
aMapping
.
mAtom
)
;
return
GetEventTypeFromMessage
(
aMapping
.
mMessage
)
=
=
aMapping
.
mAtom
;
}
bool
nsContentUtils
:
:
InitializeEventTable
(
)
{
NS_ASSERTION
(
!
sAtomEventTable
"
EventTable
already
initialized
!
"
)
;
NS_ASSERTION
(
!
sStringEventTable
"
EventTable
already
initialized
!
"
)
;
static
const
EventNameMapping
eventArray
[
]
=
{
#
define
EVENT
(
name_
_message
_type
_class
)
\
{
nsGkAtoms
:
:
on
#
#
name_
_type
_message
_class
false
}
#
define
WINDOW_ONLY_EVENT
EVENT
#
define
DOCUMENT_ONLY_EVENT
EVENT
#
define
NON_IDL_EVENT
EVENT
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
WINDOW_ONLY_EVENT
#
undef
NON_IDL_EVENT
#
undef
EVENT
{
nullptr
}
}
;
sAtomEventTable
=
new
nsDataHashtable
<
nsRefPtrHashKey
<
nsAtom
>
EventNameMapping
>
(
ArrayLength
(
eventArray
)
)
;
sStringEventTable
=
new
nsDataHashtable
<
nsStringHashKey
EventNameMapping
>
(
ArrayLength
(
eventArray
)
)
;
sUserDefinedEvents
=
new
nsTArray
<
RefPtr
<
nsAtom
>
>
(
64
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
eventArray
)
-
1
;
+
+
i
)
{
MOZ_ASSERT
(
!
sAtomEventTable
-
>
Lookup
(
eventArray
[
i
]
.
mAtom
)
"
Double
-
defining
event
name
;
fix
your
EventNameList
.
h
"
)
;
sAtomEventTable
-
>
Put
(
eventArray
[
i
]
.
mAtom
eventArray
[
i
]
)
;
if
(
ShouldAddEventToStringEventTable
(
eventArray
[
i
]
)
)
{
sStringEventTable
-
>
Put
(
Substring
(
nsDependentAtomString
(
eventArray
[
i
]
.
mAtom
)
2
)
eventArray
[
i
]
)
;
}
}
return
true
;
}
void
nsContentUtils
:
:
InitializeTouchEventTable
(
)
{
static
bool
sEventTableInitialized
=
false
;
if
(
!
sEventTableInitialized
&
&
sAtomEventTable
&
&
sStringEventTable
)
{
sEventTableInitialized
=
true
;
static
const
EventNameMapping
touchEventArray
[
]
=
{
#
define
EVENT
(
name_
_message
_type
_class
)
#
define
TOUCH_EVENT
(
name_
_message
_type
_class
)
\
{
nsGkAtoms
:
:
on
#
#
name_
_type
_message
_class
}
#
include
"
mozilla
/
EventNameList
.
h
"
#
undef
TOUCH_EVENT
#
undef
EVENT
{
nullptr
}
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
touchEventArray
)
-
1
;
+
+
i
)
{
sAtomEventTable
-
>
Put
(
touchEventArray
[
i
]
.
mAtom
touchEventArray
[
i
]
)
;
sStringEventTable
-
>
Put
(
Substring
(
nsDependentAtomString
(
touchEventArray
[
i
]
.
mAtom
)
2
)
touchEventArray
[
i
]
)
;
}
}
}
static
bool
Is8bit
(
const
nsAString
&
aString
)
{
static
const
char16_t
EIGHT_BIT
=
char16_t
(
~
0x00FF
)
;
for
(
nsAString
:
:
const_char_iterator
start
=
aString
.
BeginReading
(
)
end
=
aString
.
EndReading
(
)
;
start
!
=
end
;
+
+
start
)
{
if
(
*
start
&
EIGHT_BIT
)
{
return
false
;
}
}
return
true
;
}
nsresult
nsContentUtils
:
:
Btoa
(
const
nsAString
&
aBinaryData
nsAString
&
aAsciiBase64String
)
{
if
(
!
Is8bit
(
aBinaryData
)
)
{
aAsciiBase64String
.
Truncate
(
)
;
return
NS_ERROR_DOM_INVALID_CHARACTER_ERR
;
}
return
Base64Encode
(
aBinaryData
aAsciiBase64String
)
;
}
nsresult
nsContentUtils
:
:
Atob
(
const
nsAString
&
aAsciiBase64String
nsAString
&
aBinaryData
)
{
if
(
!
Is8bit
(
aAsciiBase64String
)
)
{
aBinaryData
.
Truncate
(
)
;
return
NS_ERROR_DOM_INVALID_CHARACTER_ERR
;
}
const
char16_t
*
start
=
aAsciiBase64String
.
BeginReading
(
)
;
const
char16_t
*
cur
=
start
;
const
char16_t
*
end
=
aAsciiBase64String
.
EndReading
(
)
;
bool
hasWhitespace
=
false
;
while
(
cur
<
end
)
{
if
(
nsContentUtils
:
:
IsHTMLWhitespace
(
*
cur
)
)
{
hasWhitespace
=
true
;
break
;
}
cur
+
+
;
}
nsresult
rv
;
if
(
hasWhitespace
)
{
nsString
trimmedString
;
if
(
!
trimmedString
.
SetCapacity
(
aAsciiBase64String
.
Length
(
)
fallible
)
)
{
return
NS_ERROR_DOM_INVALID_CHARACTER_ERR
;
}
trimmedString
.
Append
(
start
cur
-
start
)
;
while
(
cur
<
end
)
{
if
(
!
nsContentUtils
:
:
IsHTMLWhitespace
(
*
cur
)
)
{
trimmedString
.
Append
(
*
cur
)
;
}
cur
+
+
;
}
rv
=
Base64Decode
(
trimmedString
aBinaryData
)
;
}
else
{
rv
=
Base64Decode
(
aAsciiBase64String
aBinaryData
)
;
}
if
(
NS_FAILED
(
rv
)
&
&
rv
=
=
NS_ERROR_INVALID_ARG
)
{
return
NS_ERROR_DOM_INVALID_CHARACTER_ERR
;
}
return
rv
;
}
bool
nsContentUtils
:
:
IsAutocompleteEnabled
(
mozilla
:
:
dom
:
:
HTMLInputElement
*
aInput
)
{
MOZ_ASSERT
(
aInput
"
aInput
should
not
be
null
!
"
)
;
nsAutoString
autocomplete
;
aInput
-
>
GetAutocomplete
(
autocomplete
)
;
if
(
autocomplete
.
IsEmpty
(
)
)
{
auto
*
form
=
aInput
-
>
GetForm
(
)
;
if
(
!
form
)
{
return
true
;
}
form
-
>
GetAutocomplete
(
autocomplete
)
;
}
return
!
autocomplete
.
EqualsLiteral
(
"
off
"
)
;
}
nsContentUtils
:
:
AutocompleteAttrState
nsContentUtils
:
:
SerializeAutocompleteAttribute
(
const
nsAttrValue
*
aAttr
nsAString
&
aResult
AutocompleteAttrState
aCachedState
)
{
if
(
!
aAttr
|
|
aCachedState
=
=
nsContentUtils
:
:
eAutocompleteAttrState_Invalid
)
{
return
aCachedState
;
}
if
(
aCachedState
=
=
nsContentUtils
:
:
eAutocompleteAttrState_Valid
)
{
uint32_t
atomCount
=
aAttr
-
>
GetAtomCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
atomCount
;
i
+
+
)
{
if
(
i
!
=
0
)
{
aResult
.
Append
(
'
'
)
;
}
aResult
.
Append
(
nsDependentAtomString
(
aAttr
-
>
AtomAt
(
i
)
)
)
;
}
nsContentUtils
:
:
ASCIIToLower
(
aResult
)
;
return
aCachedState
;
}
aResult
.
Truncate
(
)
;
mozilla
:
:
dom
:
:
AutocompleteInfo
info
;
AutocompleteAttrState
state
=
InternalSerializeAutocompleteAttribute
(
aAttr
info
)
;
if
(
state
=
=
eAutocompleteAttrState_Valid
)
{
aResult
=
info
.
mSection
;
if
(
!
info
.
mAddressType
.
IsEmpty
(
)
)
{
if
(
!
aResult
.
IsEmpty
(
)
)
{
aResult
+
=
'
'
;
}
aResult
+
=
info
.
mAddressType
;
}
if
(
!
info
.
mContactType
.
IsEmpty
(
)
)
{
if
(
!
aResult
.
IsEmpty
(
)
)
{
aResult
+
=
'
'
;
}
aResult
+
=
info
.
mContactType
;
}
if
(
!
info
.
mFieldName
.
IsEmpty
(
)
)
{
if
(
!
aResult
.
IsEmpty
(
)
)
{
aResult
+
=
'
'
;
}
aResult
+
=
info
.
mFieldName
;
}
}
return
state
;
}
nsContentUtils
:
:
AutocompleteAttrState
nsContentUtils
:
:
SerializeAutocompleteAttribute
(
const
nsAttrValue
*
aAttr
mozilla
:
:
dom
:
:
AutocompleteInfo
&
aInfo
AutocompleteAttrState
aCachedState
bool
aGrantAllValidValue
)
{
if
(
!
aAttr
|
|
aCachedState
=
=
nsContentUtils
:
:
eAutocompleteAttrState_Invalid
)
{
return
aCachedState
;
}
return
InternalSerializeAutocompleteAttribute
(
aAttr
aInfo
aGrantAllValidValue
)
;
}
nsContentUtils
:
:
AutocompleteAttrState
nsContentUtils
:
:
InternalSerializeAutocompleteAttribute
(
const
nsAttrValue
*
aAttrVal
mozilla
:
:
dom
:
:
AutocompleteInfo
&
aInfo
bool
aGrantAllValidValue
)
{
if
(
!
aAttrVal
)
{
return
eAutocompleteAttrState_Invalid
;
}
uint32_t
numTokens
=
aAttrVal
-
>
GetAtomCount
(
)
;
if
(
!
numTokens
)
{
return
eAutocompleteAttrState_Invalid
;
}
uint32_t
index
=
numTokens
-
1
;
nsString
tokenString
=
nsDependentAtomString
(
aAttrVal
-
>
AtomAt
(
index
)
)
;
AutocompleteCategory
category
;
nsAttrValue
enumValue
;
bool
unsupported
=
false
;
if
(
!
aGrantAllValidValue
)
{
unsupported
=
enumValue
.
ParseEnumValue
(
tokenString
kAutocompleteUnsupportedFieldNameTable
false
)
;
if
(
unsupported
)
{
return
eAutocompleteAttrState_Invalid
;
}
}
nsAutoString
str
;
bool
result
=
enumValue
.
ParseEnumValue
(
tokenString
kAutocompleteFieldNameTable
false
)
;
if
(
result
)
{
if
(
enumValue
.
Equals
(
NS_LITERAL_STRING
(
"
off
"
)
eIgnoreCase
)
|
|
enumValue
.
Equals
(
NS_LITERAL_STRING
(
"
on
"
)
eIgnoreCase
)
)
{
if
(
numTokens
>
1
)
{
return
eAutocompleteAttrState_Invalid
;
}
enumValue
.
ToString
(
str
)
;
ASCIIToLower
(
str
)
;
aInfo
.
mFieldName
.
Assign
(
str
)
;
aInfo
.
mCanAutomaticallyPersist
=
!
enumValue
.
Equals
(
NS_LITERAL_STRING
(
"
off
"
)
eIgnoreCase
)
;
return
eAutocompleteAttrState_Valid
;
}
if
(
!
sIsFormAutofillAutocompleteEnabled
&
&
!
aGrantAllValidValue
)
{
return
eAutocompleteAttrState_Invalid
;
}
if
(
numTokens
>
3
)
{
return
eAutocompleteAttrState_Invalid
;
}
category
=
eAutocompleteCategory_NORMAL
;
}
else
{
if
(
!
sIsFormAutofillAutocompleteEnabled
&
&
!
aGrantAllValidValue
)
{
return
eAutocompleteAttrState_Invalid
;
}
result
=
enumValue
.
ParseEnumValue
(
tokenString
kAutocompleteContactFieldNameTable
false
)
;
if
(
!
result
|
|
numTokens
>
4
)
{
return
eAutocompleteAttrState_Invalid
;
}
category
=
eAutocompleteCategory_CONTACT
;
}
enumValue
.
ToString
(
str
)
;
ASCIIToLower
(
str
)
;
aInfo
.
mFieldName
.
Assign
(
str
)
;
aInfo
.
mCanAutomaticallyPersist
=
!
enumValue
.
ParseEnumValue
(
tokenString
kAutocompleteNoPersistFieldNameTable
false
)
;
if
(
numTokens
=
=
1
)
{
return
eAutocompleteAttrState_Valid
;
}
-
-
index
;
tokenString
=
nsDependentAtomString
(
aAttrVal
-
>
AtomAt
(
index
)
)
;
if
(
category
=
=
eAutocompleteCategory_CONTACT
)
{
if
(
!
aGrantAllValidValue
)
{
unsupported
=
enumValue
.
ParseEnumValue
(
tokenString
kAutocompleteUnsupportedContactFieldHintTable
false
)
;
if
(
unsupported
)
{
return
eAutocompleteAttrState_Invalid
;
}
}
nsAttrValue
contactFieldHint
;
result
=
contactFieldHint
.
ParseEnumValue
(
tokenString
kAutocompleteContactFieldHintTable
false
)
;
if
(
result
)
{
nsAutoString
contactFieldHintString
;
contactFieldHint
.
ToString
(
contactFieldHintString
)
;
ASCIIToLower
(
contactFieldHintString
)
;
aInfo
.
mContactType
.
Assign
(
contactFieldHintString
)
;
if
(
index
=
=
0
)
{
return
eAutocompleteAttrState_Valid
;
}
-
-
index
;
tokenString
=
nsDependentAtomString
(
aAttrVal
-
>
AtomAt
(
index
)
)
;
}
}
nsAttrValue
fieldHint
;
if
(
fieldHint
.
ParseEnumValue
(
tokenString
kAutocompleteFieldHintTable
false
)
)
{
nsString
fieldHintString
;
fieldHint
.
ToString
(
fieldHintString
)
;
ASCIIToLower
(
fieldHintString
)
;
aInfo
.
mAddressType
.
Assign
(
fieldHintString
)
;
if
(
index
=
=
0
)
{
return
eAutocompleteAttrState_Valid
;
}
-
-
index
;
tokenString
=
nsDependentAtomString
(
aAttrVal
-
>
AtomAt
(
index
)
)
;
}
const
nsDependentSubstring
&
section
=
Substring
(
tokenString
0
8
)
;
if
(
section
.
LowerCaseEqualsASCII
(
"
section
-
"
)
)
{
ASCIIToLower
(
tokenString
)
;
aInfo
.
mSection
.
Assign
(
tokenString
)
;
if
(
index
=
=
0
)
{
return
eAutocompleteAttrState_Valid
;
}
}
aInfo
.
mSection
.
Truncate
(
)
;
aInfo
.
mAddressType
.
Truncate
(
)
;
aInfo
.
mContactType
.
Truncate
(
)
;
aInfo
.
mFieldName
.
Truncate
(
)
;
return
eAutocompleteAttrState_Invalid
;
}
int32_t
nsContentUtils
:
:
ParseHTMLInteger
(
const
nsAString
&
aValue
ParseHTMLIntegerResultFlags
*
aResult
)
{
int
result
=
eParseHTMLInteger_NoFlags
;
nsAString
:
:
const_iterator
iter
end
;
aValue
.
BeginReading
(
iter
)
;
aValue
.
EndReading
(
end
)
;
while
(
iter
!
=
end
&
&
nsContentUtils
:
:
IsHTMLWhitespace
(
*
iter
)
)
{
result
|
=
eParseHTMLInteger_NonStandard
;
+
+
iter
;
}
if
(
iter
=
=
end
)
{
result
|
=
eParseHTMLInteger_Error
|
eParseHTMLInteger_ErrorNoValue
;
*
aResult
=
(
ParseHTMLIntegerResultFlags
)
result
;
return
0
;
}
int
sign
=
1
;
if
(
*
iter
=
=
char16_t
(
'
-
'
)
)
{
sign
=
-
1
;
result
|
=
eParseHTMLInteger_Negative
;
+
+
iter
;
}
else
if
(
*
iter
=
=
char16_t
(
'
+
'
)
)
{
result
|
=
eParseHTMLInteger_NonStandard
;
+
+
iter
;
}
bool
foundValue
=
false
;
CheckedInt32
value
=
0
;
uint64_t
leadingZeros
=
0
;
while
(
iter
!
=
end
)
{
if
(
*
iter
!
=
char16_t
(
'
0
'
)
)
{
break
;
}
+
+
leadingZeros
;
foundValue
=
true
;
+
+
iter
;
}
while
(
iter
!
=
end
)
{
if
(
*
iter
>
=
char16_t
(
'
0
'
)
&
&
*
iter
<
=
char16_t
(
'
9
'
)
)
{
value
=
(
value
*
10
)
+
(
*
iter
-
char16_t
(
'
0
'
)
)
*
sign
;
+
+
iter
;
if
(
!
value
.
isValid
(
)
)
{
result
|
=
eParseHTMLInteger_Error
|
eParseHTMLInteger_ErrorOverflow
;
break
;
}
foundValue
=
true
;
}
else
if
(
*
iter
=
=
char16_t
(
'
%
'
)
)
{
+
+
iter
;
result
|
=
eParseHTMLInteger_IsPercent
;
break
;
}
else
{
break
;
}
}
if
(
!
foundValue
)
{
result
|
=
eParseHTMLInteger_Error
|
eParseHTMLInteger_ErrorNoValue
;
}
if
(
value
.
isValid
(
)
&
&
(
(
leadingZeros
>
1
|
|
(
leadingZeros
=
=
1
&
&
!
(
value
=
=
0
)
)
)
|
|
(
sign
=
=
-
1
&
&
value
=
=
0
)
)
)
{
result
|
=
eParseHTMLInteger_NonStandard
;
}
if
(
iter
!
=
end
)
{
result
|
=
eParseHTMLInteger_DidNotConsumeAllInput
;
}
*
aResult
=
(
ParseHTMLIntegerResultFlags
)
result
;
return
value
.
isValid
(
)
?
value
.
value
(
)
:
0
;
}
#
define
SKIP_WHITESPACE
(
iter
end_iter
end_res
)
\
while
(
(
iter
)
!
=
(
end_iter
)
&
&
nsCRT
:
:
IsAsciiSpace
(
*
(
iter
)
)
)
{
\
+
+
(
iter
)
;
\
}
\
if
(
(
iter
)
=
=
(
end_iter
)
)
{
\
return
(
end_res
)
;
\
}
#
define
SKIP_ATTR_NAME
(
iter
end_iter
)
\
while
(
(
iter
)
!
=
(
end_iter
)
&
&
!
nsCRT
:
:
IsAsciiSpace
(
*
(
iter
)
)
&
&
\
*
(
iter
)
!
=
'
=
'
)
{
\
+
+
(
iter
)
;
\
}
bool
nsContentUtils
:
:
GetPseudoAttributeValue
(
const
nsString
&
aSource
nsAtom
*
aName
nsAString
&
aValue
)
{
aValue
.
Truncate
(
)
;
const
char16_t
*
start
=
aSource
.
get
(
)
;
const
char16_t
*
end
=
start
+
aSource
.
Length
(
)
;
const
char16_t
*
iter
;
while
(
start
!
=
end
)
{
SKIP_WHITESPACE
(
start
end
false
)
iter
=
start
;
SKIP_ATTR_NAME
(
iter
end
)
if
(
start
=
=
iter
)
{
return
false
;
}
const
nsDependentSubstring
&
attrName
=
Substring
(
start
iter
)
;
start
=
iter
;
SKIP_WHITESPACE
(
start
end
false
)
if
(
*
start
!
=
'
=
'
)
{
return
false
;
}
+
+
start
;
SKIP_WHITESPACE
(
start
end
false
)
char16_t
q
=
*
start
;
if
(
q
!
=
kQuote
&
&
q
!
=
kApostrophe
)
{
return
false
;
}
+
+
start
;
iter
=
start
;
while
(
iter
!
=
end
&
&
*
iter
!
=
q
)
{
+
+
iter
;
}
if
(
iter
=
=
end
)
{
return
false
;
}
if
(
aName
-
>
Equals
(
attrName
)
)
{
const
char16_t
*
chunkEnd
=
start
;
while
(
chunkEnd
!
=
iter
)
{
if
(
*
chunkEnd
=
=
kLessThan
)
{
aValue
.
Truncate
(
)
;
return
false
;
}
if
(
*
chunkEnd
=
=
kAmpersand
)
{
aValue
.
Append
(
start
chunkEnd
-
start
)
;
const
char16_t
*
afterEntity
=
nullptr
;
char16_t
result
[
2
]
;
uint32_t
count
=
MOZ_XMLTranslateEntity
(
reinterpret_cast
<
const
char
*
>
(
chunkEnd
)
reinterpret_cast
<
const
char
*
>
(
iter
)
reinterpret_cast
<
const
char
*
*
>
(
&
afterEntity
)
result
)
;
if
(
count
=
=
0
)
{
aValue
.
Truncate
(
)
;
return
false
;
}
aValue
.
Append
(
result
count
)
;
start
=
chunkEnd
=
afterEntity
;
}
else
{
+
+
chunkEnd
;
}
}
aValue
.
Append
(
start
iter
-
start
)
;
return
true
;
}
start
=
iter
+
1
;
}
return
false
;
}
bool
nsContentUtils
:
:
IsJavaScriptLanguage
(
const
nsString
&
aName
)
{
return
aName
.
LowerCaseEqualsLiteral
(
"
javascript
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
livescript
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
mocha
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
javascript1
.
0
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
javascript1
.
1
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
javascript1
.
2
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
javascript1
.
3
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
javascript1
.
4
"
)
|
|
aName
.
LowerCaseEqualsLiteral
(
"
javascript1
.
5
"
)
;
}
void
nsContentUtils
:
:
SplitMimeType
(
const
nsAString
&
aValue
nsString
&
aType
nsString
&
aParams
)
{
aType
.
Truncate
(
)
;
aParams
.
Truncate
(
)
;
int32_t
semiIndex
=
aValue
.
FindChar
(
char16_t
(
'
;
'
)
)
;
if
(
-
1
!
=
semiIndex
)
{
aType
=
Substring
(
aValue
0
semiIndex
)
;
aParams
=
Substring
(
aValue
semiIndex
+
1
aValue
.
Length
(
)
-
(
semiIndex
+
1
)
)
;
aParams
.
StripWhitespace
(
)
;
}
else
{
aType
=
aValue
;
}
aType
.
StripWhitespace
(
)
;
}
nsresult
nsContentUtils
:
:
IsUserIdle
(
uint32_t
aRequestedIdleTimeInMS
bool
*
aUserIsIdle
)
{
nsresult
rv
;
nsCOMPtr
<
nsIIdleService
>
idleService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
idleservice
;
1
"
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
idleTimeInMS
;
rv
=
idleService
-
>
GetIdleTime
(
&
idleTimeInMS
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aUserIsIdle
=
idleTimeInMS
>
=
aRequestedIdleTimeInMS
;
return
NS_OK
;
}
uint32_t
nsContentUtils
:
:
ParseSandboxAttributeToFlags
(
const
nsAttrValue
*
aSandboxAttr
)
{
if
(
!
aSandboxAttr
)
{
return
SANDBOXED_NONE
;
}
uint32_t
out
=
SANDBOX_ALL_FLAGS
;
#
define
SANDBOX_KEYWORD
(
string
atom
flags
)
\
if
(
aSandboxAttr
-
>
Contains
(
nsGkAtoms
:
:
atom
eIgnoreCase
)
)
{
\
out
&
=
~
(
flags
)
;
\
}
#
include
"
IframeSandboxKeywordList
.
h
"
#
undef
SANDBOX_KEYWORD
return
out
;
}
bool
nsContentUtils
:
:
IsValidSandboxFlag
(
const
nsAString
&
aFlag
)
{
#
define
SANDBOX_KEYWORD
(
string
atom
flags
)
\
if
(
EqualsIgnoreASCIICase
(
nsDependentAtomString
(
nsGkAtoms
:
:
atom
)
aFlag
)
)
{
\
return
true
;
\
}
#
include
"
IframeSandboxKeywordList
.
h
"
#
undef
SANDBOX_KEYWORD
return
false
;
}
void
nsContentUtils
:
:
SandboxFlagsToString
(
uint32_t
aFlags
nsAString
&
aString
)
{
if
(
!
aFlags
)
{
SetDOMStringToNull
(
aString
)
;
return
;
}
aString
.
Truncate
(
)
;
#
define
SANDBOX_KEYWORD
(
string
atom
flags
)
\
if
(
!
(
aFlags
&
(
flags
)
)
)
{
\
if
(
!
aString
.
IsEmpty
(
)
)
{
\
aString
.
AppendLiteral
(
u
"
"
)
;
\
}
\
aString
.
Append
(
nsDependentAtomString
(
nsGkAtoms
:
:
atom
)
)
;
\
}
#
include
"
IframeSandboxKeywordList
.
h
"
#
undef
SANDBOX_KEYWORD
}
nsIBidiKeyboard
*
nsContentUtils
:
:
GetBidiKeyboard
(
)
{
if
(
!
sBidiKeyboard
)
{
sBidiKeyboard
=
nsIWidget
:
:
CreateBidiKeyboard
(
)
;
}
return
sBidiKeyboard
;
}
bool
nsContentUtils
:
:
IsFirstLetterPunctuation
(
uint32_t
aChar
)
{
switch
(
mozilla
:
:
unicode
:
:
GetGeneralCategory
(
aChar
)
)
{
case
HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION
:
return
true
;
default
:
return
false
;
}
}
bool
nsContentUtils
:
:
IsFirstLetterPunctuationAt
(
const
nsTextFragment
*
aFrag
uint32_t
aOffset
)
{
char16_t
h
=
aFrag
-
>
CharAt
(
aOffset
)
;
if
(
!
IS_SURROGATE
(
h
)
)
{
return
IsFirstLetterPunctuation
(
h
)
;
}
if
(
NS_IS_HIGH_SURROGATE
(
h
)
&
&
aOffset
+
1
<
aFrag
-
>
GetLength
(
)
)
{
char16_t
l
=
aFrag
-
>
CharAt
(
aOffset
+
1
)
;
if
(
NS_IS_LOW_SURROGATE
(
l
)
)
{
return
IsFirstLetterPunctuation
(
SURROGATE_TO_UCS4
(
h
l
)
)
;
}
}
return
false
;
}
bool
nsContentUtils
:
:
IsAlphanumeric
(
uint32_t
aChar
)
{
nsUGenCategory
cat
=
mozilla
:
:
unicode
:
:
GetGenCategory
(
aChar
)
;
return
(
cat
=
=
nsUGenCategory
:
:
kLetter
|
|
cat
=
=
nsUGenCategory
:
:
kNumber
)
;
}
bool
nsContentUtils
:
:
IsAlphanumericAt
(
const
nsTextFragment
*
aFrag
uint32_t
aOffset
)
{
char16_t
h
=
aFrag
-
>
CharAt
(
aOffset
)
;
if
(
!
IS_SURROGATE
(
h
)
)
{
return
IsAlphanumeric
(
h
)
;
}
if
(
NS_IS_HIGH_SURROGATE
(
h
)
&
&
aOffset
+
1
<
aFrag
-
>
GetLength
(
)
)
{
char16_t
l
=
aFrag
-
>
CharAt
(
aOffset
+
1
)
;
if
(
NS_IS_LOW_SURROGATE
(
l
)
)
{
return
IsAlphanumeric
(
SURROGATE_TO_UCS4
(
h
l
)
)
;
}
}
return
false
;
}
bool
nsContentUtils
:
:
IsHTMLWhitespace
(
char16_t
aChar
)
{
return
aChar
=
=
char16_t
(
0x0009
)
|
|
aChar
=
=
char16_t
(
0x000A
)
|
|
aChar
=
=
char16_t
(
0x000C
)
|
|
aChar
=
=
char16_t
(
0x000D
)
|
|
aChar
=
=
char16_t
(
0x0020
)
;
}
bool
nsContentUtils
:
:
IsHTMLWhitespaceOrNBSP
(
char16_t
aChar
)
{
return
IsHTMLWhitespace
(
aChar
)
|
|
aChar
=
=
char16_t
(
0xA0
)
;
}
bool
nsContentUtils
:
:
IsHTMLBlock
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
address
nsGkAtoms
:
:
article
nsGkAtoms
:
:
aside
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
center
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
div
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
fieldset
nsGkAtoms
:
:
figure
nsGkAtoms
:
:
footer
nsGkAtoms
:
:
form
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
nsGkAtoms
:
:
header
nsGkAtoms
:
:
hgroup
nsGkAtoms
:
:
hr
nsGkAtoms
:
:
li
nsGkAtoms
:
:
listing
nsGkAtoms
:
:
menu
nsGkAtoms
:
:
nav
nsGkAtoms
:
:
ol
nsGkAtoms
:
:
p
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
section
nsGkAtoms
:
:
table
nsGkAtoms
:
:
ul
nsGkAtoms
:
:
xmp
)
;
}
bool
nsContentUtils
:
:
ParseIntMarginValue
(
const
nsAString
&
aString
nsIntMargin
&
result
)
{
nsAutoString
marginStr
(
aString
)
;
marginStr
.
CompressWhitespace
(
true
true
)
;
if
(
marginStr
.
IsEmpty
(
)
)
{
return
false
;
}
int32_t
start
=
0
end
=
0
;
for
(
int
count
=
0
;
count
<
4
;
count
+
+
)
{
if
(
(
uint32_t
)
end
>
=
marginStr
.
Length
(
)
)
return
false
;
if
(
count
<
3
)
end
=
Substring
(
marginStr
start
)
.
FindChar
(
'
'
)
;
else
end
=
Substring
(
marginStr
start
)
.
Length
(
)
;
if
(
end
<
=
0
)
return
false
;
nsresult
ec
;
int32_t
val
=
nsString
(
Substring
(
marginStr
start
end
)
)
.
ToInteger
(
&
ec
)
;
if
(
NS_FAILED
(
ec
)
)
return
false
;
switch
(
count
)
{
case
0
:
result
.
top
=
val
;
break
;
case
1
:
result
.
right
=
val
;
break
;
case
2
:
result
.
bottom
=
val
;
break
;
case
3
:
result
.
left
=
val
;
break
;
}
start
+
=
end
+
1
;
}
return
true
;
}
int32_t
nsContentUtils
:
:
ParseLegacyFontSize
(
const
nsAString
&
aValue
)
{
nsAString
:
:
const_iterator
iter
end
;
aValue
.
BeginReading
(
iter
)
;
aValue
.
EndReading
(
end
)
;
while
(
iter
!
=
end
&
&
nsContentUtils
:
:
IsHTMLWhitespace
(
*
iter
)
)
{
+
+
iter
;
}
if
(
iter
=
=
end
)
{
return
0
;
}
bool
relative
=
false
;
bool
negate
=
false
;
if
(
*
iter
=
=
char16_t
(
'
-
'
)
)
{
relative
=
true
;
negate
=
true
;
+
+
iter
;
}
else
if
(
*
iter
=
=
char16_t
(
'
+
'
)
)
{
relative
=
true
;
+
+
iter
;
}
if
(
iter
=
=
end
|
|
*
iter
<
char16_t
(
'
0
'
)
|
|
*
iter
>
char16_t
(
'
9
'
)
)
{
return
0
;
}
int32_t
value
=
0
;
while
(
iter
!
=
end
&
&
*
iter
>
=
char16_t
(
'
0
'
)
&
&
*
iter
<
=
char16_t
(
'
9
'
)
)
{
value
=
10
*
value
+
(
*
iter
-
char16_t
(
'
0
'
)
)
;
if
(
value
>
=
7
)
{
break
;
}
+
+
iter
;
}
if
(
relative
)
{
if
(
negate
)
{
value
=
3
-
value
;
}
else
{
value
=
3
+
value
;
}
}
return
clamped
(
value
1
7
)
;
}
void
nsContentUtils
:
:
GetOfflineAppManifest
(
Document
*
aDocument
nsIURI
*
*
aURI
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aDocument
)
;
*
aURI
=
nullptr
;
if
(
aDocument
-
>
GetController
(
)
.
isSome
(
)
)
{
return
;
}
Element
*
docElement
=
aDocument
-
>
GetRootElement
(
)
;
if
(
!
docElement
)
{
return
;
}
nsAutoString
manifestSpec
;
docElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
manifest
manifestSpec
)
;
if
(
manifestSpec
.
IsEmpty
(
)
|
|
manifestSpec
.
Contains
(
'
#
'
)
)
{
return
;
}
nsContentUtils
:
:
NewURIWithDocumentCharset
(
aURI
manifestSpec
aDocument
aDocument
-
>
GetDocBaseURI
(
)
)
;
}
bool
nsContentUtils
:
:
OfflineAppAllowed
(
nsIURI
*
aURI
)
{
nsCOMPtr
<
nsIOfflineCacheUpdateService
>
updateService
=
components
:
:
OfflineCacheUpdate
:
:
Service
(
)
;
if
(
!
updateService
)
{
return
false
;
}
bool
allowed
;
nsresult
rv
=
updateService
-
>
OfflineAppAllowedForURI
(
aURI
Preferences
:
:
GetRootBranch
(
)
&
allowed
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
allowed
;
}
bool
nsContentUtils
:
:
OfflineAppAllowed
(
nsIPrincipal
*
aPrincipal
)
{
nsCOMPtr
<
nsIOfflineCacheUpdateService
>
updateService
=
components
:
:
OfflineCacheUpdate
:
:
Service
(
)
;
if
(
!
updateService
)
{
return
false
;
}
bool
allowed
;
nsresult
rv
=
updateService
-
>
OfflineAppAllowed
(
aPrincipal
Preferences
:
:
GetRootBranch
(
)
&
allowed
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
allowed
;
}
bool
nsContentUtils
:
:
MaybeAllowOfflineAppByDefault
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
Preferences
:
:
GetRootBranch
(
)
)
return
false
;
nsresult
rv
;
bool
allowedByDefault
;
rv
=
Preferences
:
:
GetRootBranch
(
)
-
>
GetBoolPref
(
"
offline
-
apps
.
allow_by_default
"
&
allowedByDefault
)
;
if
(
NS_FAILED
(
rv
)
)
return
false
;
if
(
!
allowedByDefault
)
return
false
;
nsCOMPtr
<
nsIOfflineCacheUpdateService
>
updateService
=
components
:
:
OfflineCacheUpdate
:
:
Service
(
)
;
if
(
!
updateService
)
{
return
false
;
}
rv
=
updateService
-
>
AllowOfflineApp
(
aPrincipal
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
void
nsContentUtils
:
:
Shutdown
(
)
{
sInitialized
=
false
;
nsHTMLTags
:
:
ReleaseTable
(
)
;
NS_IF_RELEASE
(
sContentPolicyService
)
;
sTriedToGetContentPolicy
=
false
;
uint32_t
i
;
for
(
i
=
0
;
i
<
PropertiesFile_COUNT
;
+
+
i
)
NS_IF_RELEASE
(
sStringBundles
[
i
]
)
;
NS_IF_RELEASE
(
sStringBundleService
)
;
NS_IF_RELEASE
(
sConsoleService
)
;
NS_IF_RELEASE
(
sXPConnect
)
;
NS_IF_RELEASE
(
sSecurityManager
)
;
NS_IF_RELEASE
(
sSystemPrincipal
)
;
NS_IF_RELEASE
(
sNullSubjectPrincipal
)
;
NS_IF_RELEASE
(
sIOService
)
;
NS_IF_RELEASE
(
sUUIDGenerator
)
;
sLineBreaker
=
nullptr
;
sWordBreaker
=
nullptr
;
sBidiKeyboard
=
nullptr
;
delete
sAtomEventTable
;
sAtomEventTable
=
nullptr
;
delete
sStringEventTable
;
sStringEventTable
=
nullptr
;
delete
sUserDefinedEvents
;
sUserDefinedEvents
=
nullptr
;
if
(
sEventListenerManagersHash
)
{
NS_ASSERTION
(
sEventListenerManagersHash
-
>
EntryCount
(
)
=
=
0
"
Event
listener
manager
hash
not
empty
at
shutdown
!
"
)
;
if
(
sEventListenerManagersHash
-
>
EntryCount
(
)
=
=
0
)
{
delete
sEventListenerManagersHash
;
sEventListenerManagersHash
=
nullptr
;
}
}
NS_ASSERTION
(
!
sBlockedScriptRunners
|
|
sBlockedScriptRunners
-
>
Length
(
)
=
=
0
"
How
'
d
this
happen
?
"
)
;
delete
sBlockedScriptRunners
;
sBlockedScriptRunners
=
nullptr
;
delete
sShiftText
;
sShiftText
=
nullptr
;
delete
sControlText
;
sControlText
=
nullptr
;
delete
sMetaText
;
sMetaText
=
nullptr
;
delete
sOSText
;
sOSText
=
nullptr
;
delete
sAltText
;
sAltText
=
nullptr
;
delete
sModifierSeparator
;
sModifierSeparator
=
nullptr
;
delete
sJSBytecodeMimeType
;
sJSBytecodeMimeType
=
nullptr
;
NS_IF_RELEASE
(
sSameOriginChecker
)
;
if
(
sUserInteractionObserver
)
{
sUserInteractionObserver
-
>
Shutdown
(
)
;
NS_RELEASE
(
sUserInteractionObserver
)
;
}
HTMLInputElement
:
:
Shutdown
(
)
;
nsMappedAttributes
:
:
Shutdown
(
)
;
}
nsresult
nsContentUtils
:
:
CheckSameOrigin
(
const
nsINode
*
aTrustedNode
const
nsINode
*
unTrustedNode
)
{
MOZ_ASSERT
(
aTrustedNode
)
;
MOZ_ASSERT
(
unTrustedNode
)
;
nsIPrincipal
*
trustedPrincipal
=
aTrustedNode
-
>
NodePrincipal
(
)
;
nsIPrincipal
*
unTrustedPrincipal
=
unTrustedNode
-
>
NodePrincipal
(
)
;
if
(
trustedPrincipal
=
=
unTrustedPrincipal
)
{
return
NS_OK
;
}
bool
equal
;
if
(
NS_FAILED
(
trustedPrincipal
-
>
Equals
(
unTrustedPrincipal
&
equal
)
)
|
|
!
equal
)
{
return
NS_ERROR_DOM_PROP_ACCESS_DENIED
;
}
return
NS_OK
;
}
bool
nsContentUtils
:
:
CanCallerAccess
(
nsIPrincipal
*
aSubjectPrincipal
nsIPrincipal
*
aPrincipal
)
{
bool
subsumes
;
nsresult
rv
=
aSubjectPrincipal
-
>
Subsumes
(
aPrincipal
&
subsumes
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
subsumes
)
{
return
true
;
}
return
IsCallerChrome
(
)
;
}
bool
nsContentUtils
:
:
CanCallerAccess
(
const
nsINode
*
aNode
)
{
nsIPrincipal
*
subject
=
SubjectPrincipal
(
)
;
if
(
IsSystemPrincipal
(
subject
)
)
{
return
true
;
}
if
(
aNode
-
>
ChromeOnlyAccess
(
)
)
{
return
false
;
}
return
CanCallerAccess
(
subject
aNode
-
>
NodePrincipal
(
)
)
;
}
bool
nsContentUtils
:
:
CanCallerAccess
(
nsPIDOMWindowInner
*
aWindow
)
{
nsCOMPtr
<
nsIScriptObjectPrincipal
>
scriptObject
=
do_QueryInterface
(
aWindow
)
;
NS_ENSURE_TRUE
(
scriptObject
false
)
;
return
CanCallerAccess
(
SubjectPrincipal
(
)
scriptObject
-
>
GetPrincipal
(
)
)
;
}
bool
nsContentUtils
:
:
PrincipalHasPermission
(
nsIPrincipal
*
aPrincipal
const
nsAtom
*
aPerm
)
{
if
(
IsSystemPrincipal
(
aPrincipal
)
)
{
return
true
;
}
return
BasePrincipal
:
:
Cast
(
aPrincipal
)
-
>
AddonHasPermission
(
aPerm
)
;
}
bool
nsContentUtils
:
:
CallerHasPermission
(
JSContext
*
aCx
const
nsAtom
*
aPerm
)
{
return
PrincipalHasPermission
(
SubjectPrincipal
(
aCx
)
aPerm
)
;
}
nsIPrincipal
*
nsContentUtils
:
:
GetAttrTriggeringPrincipal
(
nsIContent
*
aContent
const
nsAString
&
aAttrValue
nsIPrincipal
*
aSubjectPrincipal
)
{
nsIPrincipal
*
contentPrin
=
aContent
?
aContent
-
>
NodePrincipal
(
)
:
nullptr
;
if
(
contentPrin
=
=
aSubjectPrincipal
|
|
!
aSubjectPrincipal
)
{
return
contentPrin
;
}
if
(
!
aAttrValue
.
IsEmpty
(
)
&
&
IsAbsoluteURL
(
NS_ConvertUTF16toUTF8
(
aAttrValue
)
)
)
{
return
aSubjectPrincipal
;
}
return
contentPrin
;
}
bool
nsContentUtils
:
:
IsAbsoluteURL
(
const
nsACString
&
aURL
)
{
nsAutoCString
scheme
;
if
(
NS_FAILED
(
net_ExtractURLScheme
(
aURL
scheme
)
)
)
{
return
false
;
}
if
(
net_IsAbsoluteURL
(
aURL
)
)
{
return
true
;
}
uint32_t
flags
;
if
(
NS_SUCCEEDED
(
sIOService
-
>
GetProtocolFlags
(
scheme
.
get
(
)
&
flags
)
)
)
{
return
flags
&
nsIProtocolHandler
:
:
URI_NORELATIVE
;
}
return
false
;
}
bool
nsContentUtils
:
:
InProlog
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
missing
node
to
nsContentUtils
:
:
InProlog
"
)
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
if
(
!
parent
|
|
!
parent
-
>
IsDocument
(
)
)
{
return
false
;
}
Document
*
doc
=
parent
-
>
AsDocument
(
)
;
nsIContent
*
root
=
doc
-
>
GetRootElement
(
)
;
return
!
root
|
|
doc
-
>
ComputeIndexOf
(
aNode
)
<
doc
-
>
ComputeIndexOf
(
root
)
;
}
bool
nsContentUtils
:
:
IsCallerChrome
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
SubjectPrincipal
(
)
=
=
sSystemPrincipal
)
{
return
true
;
}
return
xpc
:
:
IsUniversalXPConnectEnabled
(
GetCurrentJSContext
(
)
)
;
}
#
ifdef
FUZZING
bool
nsContentUtils
:
:
IsFuzzingEnabled
(
)
{
return
StaticPrefs
:
:
fuzzing_enabled
(
)
;
}
#
endif
bool
nsContentUtils
:
:
ShouldResistFingerprinting
(
)
{
return
StaticPrefs
:
:
privacy_resistFingerprinting
(
)
;
}
bool
nsContentUtils
:
:
ShouldResistFingerprinting
(
nsIDocShell
*
aDocShell
)
{
if
(
!
aDocShell
)
{
return
false
;
}
return
ShouldResistFingerprinting
(
aDocShell
-
>
GetDocument
(
)
)
;
}
bool
nsContentUtils
:
:
ShouldResistFingerprinting
(
Document
*
aDoc
)
{
if
(
!
aDoc
)
{
return
false
;
}
bool
isChrome
=
nsContentUtils
:
:
IsChromeDoc
(
aDoc
)
;
return
!
isChrome
&
&
ShouldResistFingerprinting
(
)
;
}
void
nsContentUtils
:
:
CalcRoundedWindowSizeForResistingFingerprinting
(
int32_t
aChromeWidth
int32_t
aChromeHeight
int32_t
aScreenWidth
int32_t
aScreenHeight
int32_t
aInputWidth
int32_t
aInputHeight
bool
aSetOuterWidth
bool
aSetOuterHeight
int32_t
*
aOutputWidth
int32_t
*
aOutputHeight
)
{
MOZ_ASSERT
(
aOutputWidth
)
;
MOZ_ASSERT
(
aOutputHeight
)
;
int32_t
availContentWidth
=
0
;
int32_t
availContentHeight
=
0
;
availContentWidth
=
std
:
:
min
(
sPrivacyMaxInnerWidth
aScreenWidth
-
aChromeWidth
)
;
#
ifdef
MOZ_WIDGET_GTK
availContentHeight
=
std
:
:
min
(
sPrivacyMaxInnerHeight
(
-
40
+
aScreenHeight
)
-
aChromeHeight
)
;
#
else
availContentHeight
=
std
:
:
min
(
sPrivacyMaxInnerHeight
aScreenHeight
-
aChromeHeight
)
;
#
endif
availContentWidth
=
availContentWidth
-
(
availContentWidth
%
200
)
;
availContentHeight
=
availContentHeight
-
(
availContentHeight
%
100
)
;
int32_t
chromeOffsetWidth
=
aSetOuterWidth
?
aChromeWidth
:
0
;
int32_t
chromeOffsetHeight
=
aSetOuterHeight
?
aChromeHeight
:
0
;
int32_t
resultWidth
=
0
resultHeight
=
0
;
if
(
aInputWidth
>
(
availContentWidth
+
chromeOffsetWidth
)
)
{
resultWidth
=
availContentWidth
+
chromeOffsetWidth
;
}
else
if
(
aInputWidth
<
(
200
+
chromeOffsetWidth
)
)
{
resultWidth
=
200
+
chromeOffsetWidth
;
}
else
{
resultWidth
=
NSToIntCeil
(
(
aInputWidth
-
chromeOffsetWidth
)
/
200
.
0
)
*
200
+
chromeOffsetWidth
;
}
if
(
aInputHeight
>
(
availContentHeight
+
chromeOffsetHeight
)
)
{
resultHeight
=
availContentHeight
+
chromeOffsetHeight
;
}
else
if
(
aInputHeight
<
(
100
+
chromeOffsetHeight
)
)
{
resultHeight
=
100
+
chromeOffsetHeight
;
}
else
{
resultHeight
=
NSToIntCeil
(
(
aInputHeight
-
chromeOffsetHeight
)
/
100
.
0
)
*
100
+
chromeOffsetHeight
;
}
*
aOutputWidth
=
resultWidth
;
*
aOutputHeight
=
resultHeight
;
}
bool
nsContentUtils
:
:
ThreadsafeIsCallerChrome
(
)
{
return
NS_IsMainThread
(
)
?
IsCallerChrome
(
)
:
IsCurrentThreadRunningChromeWorker
(
)
;
}
bool
nsContentUtils
:
:
IsCallerContentXBL
(
)
{
JSContext
*
cx
=
GetCurrentJSContext
(
)
;
if
(
!
cx
)
return
false
;
JS
:
:
Realm
*
realm
=
JS
:
:
GetCurrentRealmOrNull
(
cx
)
;
if
(
!
realm
)
return
false
;
if
(
!
xpc
:
:
AllowContentXBLScope
(
realm
)
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
AllowXULXBLForPrincipal
(
xpc
:
:
GetRealmPrincipal
(
realm
)
)
)
;
return
true
;
}
return
xpc
:
:
IsContentXBLScope
(
realm
)
;
}
bool
nsContentUtils
:
:
IsCallerUAWidget
(
)
{
JSContext
*
cx
=
GetCurrentJSContext
(
)
;
if
(
!
cx
)
{
return
false
;
}
JS
:
:
Realm
*
realm
=
JS
:
:
GetCurrentRealmOrNull
(
cx
)
;
if
(
!
realm
)
{
return
false
;
}
return
xpc
:
:
IsUAWidgetScope
(
realm
)
;
}
bool
nsContentUtils
:
:
IsSystemCaller
(
JSContext
*
aCx
)
{
return
SubjectPrincipal
(
aCx
)
=
=
sSystemPrincipal
;
}
bool
nsContentUtils
:
:
ThreadsafeIsSystemCaller
(
JSContext
*
aCx
)
{
CycleCollectedJSContext
*
ccjscx
=
CycleCollectedJSContext
:
:
Get
(
)
;
MOZ_ASSERT
(
ccjscx
-
>
Context
(
)
=
=
aCx
)
;
return
ccjscx
-
>
IsSystemCaller
(
)
;
}
bool
nsContentUtils
:
:
LookupBindingMember
(
JSContext
*
aCx
nsIContent
*
aContent
JS
:
:
Handle
<
jsid
>
aId
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
aDesc
)
{
nsXBLBinding
*
binding
=
aContent
-
>
GetXBLBinding
(
)
;
if
(
!
binding
)
return
true
;
return
binding
-
>
LookupMember
(
aCx
aId
aDesc
)
;
}
nsINode
*
nsContentUtils
:
:
GetCrossDocParentNode
(
nsINode
*
aChild
)
{
MOZ_ASSERT
(
aChild
"
The
child
is
null
!
"
)
;
nsINode
*
parent
=
aChild
-
>
GetParentNode
(
)
;
if
(
parent
&
&
parent
-
>
IsContent
(
)
&
&
aChild
-
>
IsContent
(
)
)
{
parent
=
aChild
-
>
AsContent
(
)
-
>
GetFlattenedTreeParent
(
)
;
}
if
(
parent
|
|
!
aChild
-
>
IsDocument
(
)
)
{
return
parent
;
}
Document
*
doc
=
aChild
-
>
AsDocument
(
)
;
Document
*
parentDoc
=
doc
-
>
GetParentDocument
(
)
;
return
parentDoc
?
parentDoc
-
>
FindContentForSubDocument
(
doc
)
:
nullptr
;
}
bool
nsContentUtils
:
:
ContentIsDescendantOf
(
const
nsINode
*
aPossibleDescendant
const
nsINode
*
aPossibleAncestor
)
{
MOZ_ASSERT
(
aPossibleDescendant
"
The
possible
descendant
is
null
!
"
)
;
MOZ_ASSERT
(
aPossibleAncestor
"
The
possible
ancestor
is
null
!
"
)
;
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
return
true
;
aPossibleDescendant
=
aPossibleDescendant
-
>
GetParentNode
(
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
bool
nsContentUtils
:
:
ContentIsHostIncludingDescendantOf
(
const
nsINode
*
aPossibleDescendant
const
nsINode
*
aPossibleAncestor
)
{
MOZ_ASSERT
(
aPossibleDescendant
"
The
possible
descendant
is
null
!
"
)
;
MOZ_ASSERT
(
aPossibleAncestor
"
The
possible
ancestor
is
null
!
"
)
;
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
return
true
;
if
(
aPossibleDescendant
-
>
IsDocumentFragment
(
)
)
{
aPossibleDescendant
=
aPossibleDescendant
-
>
AsDocumentFragment
(
)
-
>
GetHost
(
)
;
}
else
{
aPossibleDescendant
=
aPossibleDescendant
-
>
GetParentNode
(
)
;
}
}
while
(
aPossibleDescendant
)
;
return
false
;
}
bool
nsContentUtils
:
:
ContentIsShadowIncludingDescendantOf
(
const
nsINode
*
aPossibleDescendant
const
nsINode
*
aPossibleAncestor
)
{
MOZ_ASSERT
(
aPossibleDescendant
"
The
possible
descendant
is
null
!
"
)
;
MOZ_ASSERT
(
aPossibleAncestor
"
The
possible
ancestor
is
null
!
"
)
;
if
(
aPossibleAncestor
=
=
aPossibleDescendant
-
>
GetComposedDoc
(
)
)
{
return
true
;
}
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
{
return
true
;
}
if
(
aPossibleDescendant
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
const_cast
<
nsINode
*
>
(
aPossibleDescendant
)
)
;
aPossibleDescendant
=
shadowRoot
?
shadowRoot
-
>
GetHost
(
)
:
nullptr
;
}
else
{
aPossibleDescendant
=
aPossibleDescendant
-
>
GetParentNode
(
)
;
}
}
while
(
aPossibleDescendant
)
;
return
false
;
}
bool
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
nsINode
*
aPossibleDescendant
nsINode
*
aPossibleAncestor
)
{
MOZ_ASSERT
(
aPossibleDescendant
"
The
possible
descendant
is
null
!
"
)
;
MOZ_ASSERT
(
aPossibleAncestor
"
The
possible
ancestor
is
null
!
"
)
;
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
return
true
;
aPossibleDescendant
=
GetCrossDocParentNode
(
aPossibleDescendant
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
bool
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOf
(
const
nsINode
*
aPossibleDescendant
const
nsINode
*
aPossibleAncestor
)
{
MOZ_ASSERT
(
aPossibleDescendant
"
The
possible
descendant
is
null
!
"
)
;
MOZ_ASSERT
(
aPossibleAncestor
"
The
possible
ancestor
is
null
!
"
)
;
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
{
return
true
;
}
aPossibleDescendant
=
aPossibleDescendant
-
>
GetFlattenedTreeParentNode
(
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
bool
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOfForStyle
(
const
nsINode
*
aPossibleDescendant
const
nsINode
*
aPossibleAncestor
)
{
MOZ_ASSERT
(
aPossibleDescendant
"
The
possible
descendant
is
null
!
"
)
;
MOZ_ASSERT
(
aPossibleAncestor
"
The
possible
ancestor
is
null
!
"
)
;
do
{
if
(
aPossibleDescendant
=
=
aPossibleAncestor
)
{
return
true
;
}
aPossibleDescendant
=
aPossibleDescendant
-
>
GetFlattenedTreeParentNodeForStyle
(
)
;
}
while
(
aPossibleDescendant
)
;
return
false
;
}
nsINode
*
nsContentUtils
:
:
Retarget
(
nsINode
*
aTargetA
nsINode
*
aTargetB
)
{
while
(
true
&
&
aTargetA
)
{
nsINode
*
root
=
aTargetA
-
>
SubtreeRoot
(
)
;
if
(
!
root
-
>
IsShadowRoot
(
)
)
{
return
aTargetA
;
}
if
(
nsContentUtils
:
:
ContentIsShadowIncludingDescendantOf
(
aTargetB
root
)
)
{
return
aTargetA
;
}
aTargetA
=
ShadowRoot
:
:
FromNode
(
root
)
-
>
GetHost
(
)
;
}
return
nullptr
;
}
nsresult
nsContentUtils
:
:
GetAncestors
(
nsINode
*
aNode
nsTArray
<
nsINode
*
>
&
aArray
)
{
while
(
aNode
)
{
aArray
.
AppendElement
(
aNode
)
;
aNode
=
aNode
-
>
GetParentNode
(
)
;
}
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
GetAncestorsAndOffsets
(
nsINode
*
aNode
int32_t
aOffset
nsTArray
<
nsIContent
*
>
*
aAncestorNodes
nsTArray
<
int32_t
>
*
aAncestorOffsets
)
{
NS_ENSURE_ARG_POINTER
(
aNode
)
;
if
(
!
aNode
-
>
IsContent
(
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIContent
*
content
=
aNode
-
>
AsContent
(
)
;
if
(
!
aAncestorNodes
-
>
IsEmpty
(
)
)
{
NS_WARNING
(
"
aAncestorNodes
is
not
empty
"
)
;
aAncestorNodes
-
>
Clear
(
)
;
}
if
(
!
aAncestorOffsets
-
>
IsEmpty
(
)
)
{
NS_WARNING
(
"
aAncestorOffsets
is
not
empty
"
)
;
aAncestorOffsets
-
>
Clear
(
)
;
}
aAncestorNodes
-
>
AppendElement
(
content
)
;
aAncestorOffsets
-
>
AppendElement
(
aOffset
)
;
nsIContent
*
child
=
content
;
nsIContent
*
parent
=
child
-
>
GetParent
(
)
;
while
(
parent
)
{
aAncestorNodes
-
>
AppendElement
(
parent
)
;
aAncestorOffsets
-
>
AppendElement
(
parent
-
>
ComputeIndexOf
(
child
)
)
;
child
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
}
return
NS_OK
;
}
template
<
typename
Node
typename
GetParentFunc
>
static
Node
*
GetCommonAncestorInternal
(
Node
*
aNode1
Node
*
aNode2
GetParentFunc
aGetParentFunc
)
{
MOZ_ASSERT
(
aNode1
!
=
aNode2
)
;
AutoTArray
<
Node
*
30
>
parents1
parents2
;
do
{
parents1
.
AppendElement
(
aNode1
)
;
aNode1
=
aGetParentFunc
(
aNode1
)
;
}
while
(
aNode1
)
;
do
{
parents2
.
AppendElement
(
aNode2
)
;
aNode2
=
aGetParentFunc
(
aNode2
)
;
}
while
(
aNode2
)
;
uint32_t
pos1
=
parents1
.
Length
(
)
;
uint32_t
pos2
=
parents2
.
Length
(
)
;
Node
*
parent
=
nullptr
;
uint32_t
len
;
for
(
len
=
std
:
:
min
(
pos1
pos2
)
;
len
>
0
;
-
-
len
)
{
Node
*
child1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
Node
*
child2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
if
(
child1
!
=
child2
)
{
break
;
}
parent
=
child1
;
}
return
parent
;
}
nsINode
*
nsContentUtils
:
:
GetCommonAncestorHelper
(
nsINode
*
aNode1
nsINode
*
aNode2
)
{
return
GetCommonAncestorInternal
(
aNode1
aNode2
[
]
(
nsINode
*
aNode
)
{
return
aNode
-
>
GetParentNode
(
)
;
}
)
;
}
nsIContent
*
nsContentUtils
:
:
GetCommonFlattenedTreeAncestorHelper
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
{
return
GetCommonAncestorInternal
(
aContent1
aContent2
[
]
(
nsIContent
*
aContent
)
{
return
aContent
-
>
GetFlattenedTreeParent
(
)
;
}
)
;
}
Element
*
nsContentUtils
:
:
GetCommonFlattenedTreeAncestorForStyle
(
Element
*
aElement1
Element
*
aElement2
)
{
return
GetCommonAncestorInternal
(
aElement1
aElement2
[
]
(
Element
*
aElement
)
{
return
aElement
-
>
GetFlattenedTreeParentElementForStyle
(
)
;
}
)
;
}
bool
nsContentUtils
:
:
PositionIsBefore
(
nsINode
*
aNode1
nsINode
*
aNode2
int32_t
*
aNode1Index
int32_t
*
aNode2Index
)
{
return
(
aNode2
-
>
CompareDocumentPosition
(
*
aNode1
aNode2Index
aNode1Index
)
&
(
Node_Binding
:
:
DOCUMENT_POSITION_PRECEDING
|
Node_Binding
:
:
DOCUMENT_POSITION_DISCONNECTED
)
)
=
=
Node_Binding
:
:
DOCUMENT_POSITION_PRECEDING
;
}
int32_t
nsContentUtils
:
:
ComparePoints
(
nsINode
*
aParent1
int32_t
aOffset1
nsINode
*
aParent2
int32_t
aOffset2
bool
*
aDisconnected
ComparePointsCache
*
aParent1Cache
)
{
if
(
aParent1
=
=
aParent2
)
{
return
aOffset1
<
aOffset2
?
-
1
:
aOffset1
>
aOffset2
?
1
:
0
;
}
AutoTArray
<
nsINode
*
32
>
parents1
parents2
;
nsINode
*
node1
=
aParent1
;
nsINode
*
node2
=
aParent2
;
do
{
parents1
.
AppendElement
(
node1
)
;
node1
=
node1
-
>
GetParentNode
(
)
;
}
while
(
node1
)
;
do
{
parents2
.
AppendElement
(
node2
)
;
node2
=
node2
-
>
GetParentNode
(
)
;
}
while
(
node2
)
;
uint32_t
pos1
=
parents1
.
Length
(
)
-
1
;
uint32_t
pos2
=
parents2
.
Length
(
)
-
1
;
bool
disconnected
=
parents1
.
ElementAt
(
pos1
)
!
=
parents2
.
ElementAt
(
pos2
)
;
if
(
aDisconnected
)
{
*
aDisconnected
=
disconnected
;
}
if
(
disconnected
)
{
NS_ASSERTION
(
aDisconnected
"
unexpected
disconnected
nodes
"
)
;
return
1
;
}
nsINode
*
parent
=
parents1
.
ElementAt
(
pos1
)
;
uint32_t
len
;
for
(
len
=
std
:
:
min
(
pos1
pos2
)
;
len
>
0
;
-
-
len
)
{
nsINode
*
child1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
nsINode
*
child2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
if
(
child1
!
=
child2
)
{
int32_t
child1index
=
aParent1Cache
?
aParent1Cache
-
>
ComputeIndexOf
(
parent
child1
)
:
parent
-
>
ComputeIndexOf
(
child1
)
;
return
child1index
<
parent
-
>
ComputeIndexOf
(
child2
)
?
-
1
:
1
;
}
parent
=
child1
;
}
NS_ASSERTION
(
!
pos1
|
|
!
pos2
"
should
have
run
out
of
parent
chain
for
one
of
the
nodes
"
)
;
if
(
!
pos1
)
{
nsINode
*
child2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
return
aOffset1
<
=
parent
-
>
ComputeIndexOf
(
child2
)
?
-
1
:
1
;
}
nsINode
*
child1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
int32_t
child1index
=
aParent1Cache
?
aParent1Cache
-
>
ComputeIndexOf
(
parent
child1
)
:
parent
-
>
ComputeIndexOf
(
child1
)
;
return
child1index
<
aOffset2
?
-
1
:
1
;
}
nsINode
*
nsContentUtils
:
:
GetCommonAncestorUnderInteractiveContent
(
nsINode
*
aNode1
nsINode
*
aNode2
)
{
if
(
!
aNode1
|
|
!
aNode2
)
{
return
nullptr
;
}
if
(
aNode1
=
=
aNode2
)
{
return
aNode1
;
}
AutoTArray
<
nsINode
*
30
>
parents1
;
do
{
parents1
.
AppendElement
(
aNode1
)
;
if
(
aNode1
-
>
IsElement
(
)
&
&
aNode1
-
>
AsElement
(
)
-
>
IsInteractiveHTMLContent
(
true
)
)
{
break
;
}
aNode1
=
aNode1
-
>
GetFlattenedTreeParentNode
(
)
;
}
while
(
aNode1
)
;
AutoTArray
<
nsINode
*
30
>
parents2
;
do
{
parents2
.
AppendElement
(
aNode2
)
;
if
(
aNode2
-
>
IsElement
(
)
&
&
aNode2
-
>
AsElement
(
)
-
>
IsInteractiveHTMLContent
(
true
)
)
{
break
;
}
aNode2
=
aNode2
-
>
GetFlattenedTreeParentNode
(
)
;
}
while
(
aNode2
)
;
uint32_t
pos1
=
parents1
.
Length
(
)
;
uint32_t
pos2
=
parents2
.
Length
(
)
;
nsINode
*
parent
=
nullptr
;
for
(
uint32_t
len
=
std
:
:
min
(
pos1
pos2
)
;
len
>
0
;
-
-
len
)
{
nsINode
*
child1
=
parents1
.
ElementAt
(
-
-
pos1
)
;
nsINode
*
child2
=
parents2
.
ElementAt
(
-
-
pos2
)
;
if
(
child1
!
=
child2
)
{
break
;
}
parent
=
child1
;
}
return
parent
;
}
int32_t
nsContentUtils
:
:
ComparePoints
(
const
RawRangeBoundary
&
aFirst
const
RawRangeBoundary
&
aSecond
bool
*
aDisconnected
)
{
if
(
NS_WARN_IF
(
!
aFirst
.
IsSet
(
)
)
|
|
NS_WARN_IF
(
!
aSecond
.
IsSet
(
)
)
)
{
return
-
1
;
}
return
ComparePoints
(
aFirst
.
Container
(
)
aFirst
.
Offset
(
)
aSecond
.
Container
(
)
aSecond
.
Offset
(
)
aDisconnected
)
;
}
inline
bool
IsCharInSet
(
const
char
*
aSet
const
char16_t
aChar
)
{
char16_t
ch
;
while
(
(
ch
=
*
aSet
)
)
{
if
(
aChar
=
=
char16_t
(
ch
)
)
{
return
true
;
}
+
+
aSet
;
}
return
false
;
}
const
nsDependentSubstring
nsContentUtils
:
:
TrimCharsInSet
(
const
char
*
aSet
const
nsAString
&
aValue
)
{
nsAString
:
:
const_iterator
valueCurrent
valueEnd
;
aValue
.
BeginReading
(
valueCurrent
)
;
aValue
.
EndReading
(
valueEnd
)
;
while
(
valueCurrent
!
=
valueEnd
)
{
if
(
!
IsCharInSet
(
aSet
*
valueCurrent
)
)
{
break
;
}
+
+
valueCurrent
;
}
if
(
valueCurrent
!
=
valueEnd
)
{
for
(
;
;
)
{
-
-
valueEnd
;
if
(
!
IsCharInSet
(
aSet
*
valueEnd
)
)
{
break
;
}
}
+
+
valueEnd
;
}
return
Substring
(
valueCurrent
valueEnd
)
;
}
template
<
bool
IsWhitespace
(
char16_t
)
>
const
nsDependentSubstring
nsContentUtils
:
:
TrimWhitespace
(
const
nsAString
&
aStr
bool
aTrimTrailing
)
{
nsAString
:
:
const_iterator
start
end
;
aStr
.
BeginReading
(
start
)
;
aStr
.
EndReading
(
end
)
;
while
(
start
!
=
end
&
&
IsWhitespace
(
*
start
)
)
{
+
+
start
;
}
if
(
aTrimTrailing
)
{
while
(
end
!
=
start
)
{
-
-
end
;
if
(
!
IsWhitespace
(
*
end
)
)
{
+
+
end
;
break
;
}
}
}
return
Substring
(
start
end
)
;
}
template
const
nsDependentSubstring
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
const
nsAString
&
bool
)
;
template
const
nsDependentSubstring
nsContentUtils
:
:
TrimWhitespace
<
nsContentUtils
:
:
IsHTMLWhitespace
>
(
const
nsAString
&
bool
)
;
template
const
nsDependentSubstring
nsContentUtils
:
:
TrimWhitespace
<
nsContentUtils
:
:
IsHTMLWhitespaceOrNBSP
>
(
const
nsAString
&
bool
)
;
static
inline
void
KeyAppendSep
(
nsACString
&
aKey
)
{
if
(
!
aKey
.
IsEmpty
(
)
)
{
aKey
.
Append
(
'
>
'
)
;
}
}
static
inline
void
KeyAppendString
(
const
nsAString
&
aString
nsACString
&
aKey
)
{
KeyAppendSep
(
aKey
)
;
AppendUTF16toUTF8
(
aString
aKey
)
;
}
static
inline
void
KeyAppendString
(
const
nsACString
&
aString
nsACString
&
aKey
)
{
KeyAppendSep
(
aKey
)
;
aKey
.
Append
(
aString
)
;
}
static
inline
void
KeyAppendInt
(
int32_t
aInt
nsACString
&
aKey
)
{
KeyAppendSep
(
aKey
)
;
aKey
.
Append
(
nsPrintfCString
(
"
%
d
"
aInt
)
)
;
}
static
inline
bool
IsAutocompleteOff
(
const
nsIContent
*
aContent
)
{
return
aContent
-
>
IsElement
(
)
&
&
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
autocomplete
NS_LITERAL_STRING
(
"
off
"
)
eIgnoreCase
)
;
}
nsresult
nsContentUtils
:
:
GenerateStateKey
(
nsIContent
*
aContent
Document
*
aDocument
nsACString
&
aKey
)
{
aKey
.
Truncate
(
)
;
uint32_t
partID
=
aDocument
?
aDocument
-
>
GetPartID
(
)
:
0
;
NS_ENSURE_TRUE
(
aContent
NS_ERROR_FAILURE
)
;
if
(
aContent
-
>
IsInAnonymousSubtree
(
)
)
{
return
NS_OK
;
}
if
(
IsAutocompleteOff
(
aContent
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHTMLDocument
>
htmlDocument
=
do_QueryInterface
(
aContent
-
>
GetUncomposedDoc
(
)
)
;
KeyAppendInt
(
partID
aKey
)
;
bool
generatedUniqueKey
=
false
;
if
(
htmlDocument
)
{
nsHTMLDocument
*
htmlDoc
=
static_cast
<
nsHTMLDocument
*
>
(
htmlDocument
.
get
(
)
)
;
RefPtr
<
nsContentList
>
htmlForms
;
RefPtr
<
nsContentList
>
htmlFormControls
;
htmlDoc
-
>
GetFormsAndFormControls
(
getter_AddRefs
(
htmlForms
)
getter_AddRefs
(
htmlFormControls
)
)
;
nsCOMPtr
<
nsIFormControl
>
control
(
do_QueryInterface
(
aContent
)
)
;
if
(
control
)
{
KeyAppendInt
(
control
-
>
ControlType
(
)
aKey
)
;
Element
*
formElement
=
control
-
>
GetFormElement
(
)
;
if
(
formElement
)
{
if
(
IsAutocompleteOff
(
formElement
)
)
{
aKey
.
Truncate
(
)
;
return
NS_OK
;
}
KeyAppendString
(
NS_LITERAL_CSTRING
(
"
f
"
)
aKey
)
;
int32_t
index
=
htmlForms
-
>
IndexOf
(
formElement
false
)
;
if
(
index
<
=
-
1
)
{
index
=
htmlDocument
-
>
GetNumFormsSynchronous
(
)
-
1
;
}
if
(
index
>
-
1
)
{
KeyAppendInt
(
index
aKey
)
;
nsCOMPtr
<
nsIForm
>
form
(
do_QueryInterface
(
formElement
)
)
;
index
=
form
-
>
IndexOfControl
(
control
)
;
if
(
index
>
-
1
)
{
KeyAppendInt
(
index
aKey
)
;
generatedUniqueKey
=
true
;
}
}
nsAutoString
formName
;
formElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
formName
)
;
KeyAppendString
(
formName
aKey
)
;
}
else
{
KeyAppendString
(
NS_LITERAL_CSTRING
(
"
d
"
)
aKey
)
;
int32_t
index
=
htmlFormControls
-
>
IndexOf
(
aContent
true
)
;
if
(
index
>
-
1
)
{
KeyAppendInt
(
index
aKey
)
;
generatedUniqueKey
=
true
;
}
}
nsAutoString
name
;
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
;
KeyAppendString
(
name
aKey
)
;
}
}
if
(
!
generatedUniqueKey
)
{
if
(
aContent
-
>
IsElement
(
)
)
{
KeyAppendString
(
nsDependentAtomString
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
aKey
)
;
}
else
{
KeyAppendString
(
NS_LITERAL_CSTRING
(
"
o
"
)
aKey
)
;
}
nsINode
*
parent
=
aContent
-
>
GetParentNode
(
)
;
nsINode
*
content
=
aContent
;
while
(
parent
)
{
KeyAppendInt
(
parent
-
>
ComputeIndexOf
(
content
)
aKey
)
;
content
=
parent
;
parent
=
content
-
>
GetParentNode
(
)
;
}
}
return
NS_OK
;
}
nsIPrincipal
*
nsContentUtils
:
:
SubjectPrincipal
(
JSContext
*
aCx
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
JS
:
:
Realm
*
realm
=
js
:
:
GetContextRealm
(
aCx
)
;
MOZ_ASSERT
(
realm
)
;
JSPrincipals
*
principals
=
JS
:
:
GetRealmPrincipals
(
realm
)
;
return
nsJSPrincipals
:
:
get
(
principals
)
;
}
nsIPrincipal
*
nsContentUtils
:
:
SubjectPrincipal
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
JSContext
*
cx
=
GetCurrentJSContext
(
)
;
if
(
!
cx
)
{
MOZ_CRASH
(
"
Accessing
the
Subject
Principal
without
an
AutoJSAPI
on
the
stack
is
"
"
forbidden
"
)
;
}
JS
:
:
Realm
*
realm
=
js
:
:
GetContextRealm
(
cx
)
;
if
(
!
realm
)
{
return
sNullSubjectPrincipal
;
}
return
SubjectPrincipal
(
cx
)
;
}
nsIPrincipal
*
nsContentUtils
:
:
ObjectPrincipal
(
JSObject
*
aObj
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
DEBUG
JS
:
:
AssertObjectBelongsToCurrentThread
(
aObj
)
;
#
endif
MOZ_DIAGNOSTIC_ASSERT
(
!
js
:
:
IsCrossCompartmentWrapper
(
aObj
)
)
;
JS
:
:
Realm
*
realm
=
js
:
:
GetNonCCWObjectRealm
(
aObj
)
;
JSPrincipals
*
principals
=
JS
:
:
GetRealmPrincipals
(
realm
)
;
return
nsJSPrincipals
:
:
get
(
principals
)
;
}
nsresult
nsContentUtils
:
:
NewURIWithDocumentCharset
(
nsIURI
*
*
aResult
const
nsAString
&
aSpec
Document
*
aDocument
nsIURI
*
aBaseURI
)
{
if
(
aDocument
)
{
return
NS_NewURI
(
aResult
aSpec
aDocument
-
>
GetDocumentCharacterSet
(
)
aBaseURI
sIOService
)
;
}
return
NS_NewURI
(
aResult
aSpec
nullptr
aBaseURI
sIOService
)
;
}
bool
nsContentUtils
:
:
IsNameWithDash
(
nsAtom
*
aName
)
{
const
char16_t
*
name
=
aName
-
>
GetUTF16String
(
)
;
uint32_t
len
=
aName
-
>
GetLength
(
)
;
bool
hasDash
=
false
;
if
(
!
len
|
|
name
[
0
]
<
'
a
'
|
|
name
[
0
]
>
'
z
'
)
{
return
false
;
}
uint32_t
i
=
1
;
while
(
i
<
len
)
{
if
(
NS_IS_HIGH_SURROGATE
(
name
[
i
]
)
&
&
i
+
1
<
len
&
&
NS_IS_LOW_SURROGATE
(
name
[
i
+
1
]
)
)
{
char32_t
code
=
SURROGATE_TO_UCS4
(
name
[
i
]
name
[
i
+
1
]
)
;
if
(
code
<
0x10000
|
|
code
>
0xEFFFF
)
{
return
false
;
}
i
+
=
2
;
}
else
{
if
(
name
[
i
]
=
=
'
-
'
)
{
hasDash
=
true
;
}
if
(
name
[
i
]
!
=
'
-
'
&
&
name
[
i
]
!
=
'
.
'
&
&
name
[
i
]
!
=
'
_
'
&
&
name
[
i
]
!
=
0xB7
&
&
(
name
[
i
]
<
'
0
'
|
|
name
[
i
]
>
'
9
'
)
&
&
(
name
[
i
]
<
'
a
'
|
|
name
[
i
]
>
'
z
'
)
&
&
(
name
[
i
]
<
0xC0
|
|
name
[
i
]
>
0xD6
)
&
&
(
name
[
i
]
<
0xF8
|
|
name
[
i
]
>
0x37D
)
&
&
(
name
[
i
]
<
0x37F
|
|
name
[
i
]
>
0x1FFF
)
&
&
(
name
[
i
]
<
0x200C
|
|
name
[
i
]
>
0x200D
)
&
&
(
name
[
i
]
<
0x203F
|
|
name
[
i
]
>
0x2040
)
&
&
(
name
[
i
]
<
0x2070
|
|
name
[
i
]
>
0x218F
)
&
&
(
name
[
i
]
<
0x2C00
|
|
name
[
i
]
>
0x2FEF
)
&
&
(
name
[
i
]
<
0x3001
|
|
name
[
i
]
>
0xD7FF
)
&
&
(
name
[
i
]
<
0xF900
|
|
name
[
i
]
>
0xFDCF
)
&
&
(
name
[
i
]
<
0xFDF0
|
|
name
[
i
]
>
0xFFFD
)
)
{
return
false
;
}
i
+
+
;
}
}
return
hasDash
;
}
bool
nsContentUtils
:
:
IsCustomElementName
(
nsAtom
*
aName
uint32_t
aNameSpaceID
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_XUL
)
{
return
true
;
}
bool
hasDash
=
IsNameWithDash
(
aName
)
;
if
(
!
hasDash
)
{
return
false
;
}
return
aName
!
=
nsGkAtoms
:
:
annotation_xml_
&
&
aName
!
=
nsGkAtoms
:
:
colorProfile
&
&
aName
!
=
nsGkAtoms
:
:
font_face
&
&
aName
!
=
nsGkAtoms
:
:
font_face_src
&
&
aName
!
=
nsGkAtoms
:
:
font_face_uri
&
&
aName
!
=
nsGkAtoms
:
:
font_face_format
&
&
aName
!
=
nsGkAtoms
:
:
font_face_name
&
&
aName
!
=
nsGkAtoms
:
:
missingGlyph
;
}
nsresult
nsContentUtils
:
:
CheckQName
(
const
nsAString
&
aQualifiedName
bool
aNamespaceAware
const
char16_t
*
*
aColon
)
{
const
char
*
colon
=
nullptr
;
const
char16_t
*
begin
=
aQualifiedName
.
BeginReading
(
)
;
const
char16_t
*
end
=
aQualifiedName
.
EndReading
(
)
;
int
result
=
MOZ_XMLCheckQName
(
reinterpret_cast
<
const
char
*
>
(
begin
)
reinterpret_cast
<
const
char
*
>
(
end
)
aNamespaceAware
&
colon
)
;
if
(
!
result
)
{
if
(
aColon
)
{
*
aColon
=
reinterpret_cast
<
const
char16_t
*
>
(
colon
)
;
}
return
NS_OK
;
}
return
NS_ERROR_DOM_INVALID_CHARACTER_ERR
;
}
nsresult
nsContentUtils
:
:
SplitQName
(
const
nsIContent
*
aNamespaceResolver
const
nsString
&
aQName
int32_t
*
aNamespace
nsAtom
*
*
aLocalName
)
{
const
char16_t
*
colon
;
nsresult
rv
=
nsContentUtils
:
:
CheckQName
(
aQName
true
&
colon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
colon
)
{
const
char16_t
*
end
;
aQName
.
EndReading
(
end
)
;
nsAutoString
nameSpace
;
rv
=
aNamespaceResolver
-
>
LookupNamespaceURIInternal
(
Substring
(
aQName
.
get
(
)
colon
)
nameSpace
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
*
aNamespace
=
NameSpaceManager
(
)
-
>
GetNameSpaceID
(
nameSpace
nsContentUtils
:
:
IsChromeDoc
(
aNamespaceResolver
-
>
OwnerDoc
(
)
)
)
;
if
(
*
aNamespace
=
=
kNameSpaceID_Unknown
)
return
NS_ERROR_FAILURE
;
*
aLocalName
=
NS_AtomizeMainThread
(
Substring
(
colon
+
1
end
)
)
.
take
(
)
;
}
else
{
*
aNamespace
=
kNameSpaceID_None
;
*
aLocalName
=
NS_AtomizeMainThread
(
aQName
)
.
take
(
)
;
}
NS_ENSURE_TRUE
(
aLocalName
NS_ERROR_OUT_OF_MEMORY
)
;
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
GetNodeInfoFromQName
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
nsNodeInfoManager
*
aNodeInfoManager
uint16_t
aNodeType
mozilla
:
:
dom
:
:
NodeInfo
*
*
aNodeInfo
)
{
const
nsString
&
qName
=
PromiseFlatString
(
aQualifiedName
)
;
const
char16_t
*
colon
;
nsresult
rv
=
nsContentUtils
:
:
CheckQName
(
qName
true
&
colon
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
nsID
;
sNameSpaceManager
-
>
RegisterNameSpace
(
aNamespaceURI
nsID
)
;
if
(
colon
)
{
const
char16_t
*
end
;
qName
.
EndReading
(
end
)
;
RefPtr
<
nsAtom
>
prefix
=
NS_AtomizeMainThread
(
Substring
(
qName
.
get
(
)
colon
)
)
;
rv
=
aNodeInfoManager
-
>
GetNodeInfo
(
Substring
(
colon
+
1
end
)
prefix
nsID
aNodeType
aNodeInfo
)
;
}
else
{
rv
=
aNodeInfoManager
-
>
GetNodeInfo
(
aQualifiedName
nullptr
nsID
aNodeType
aNodeInfo
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
nsContentUtils
:
:
IsValidNodeName
(
(
*
aNodeInfo
)
-
>
NameAtom
(
)
(
*
aNodeInfo
)
-
>
GetPrefixAtom
(
)
(
*
aNodeInfo
)
-
>
NamespaceID
(
)
)
?
NS_OK
:
NS_ERROR_DOM_NAMESPACE_ERR
;
}
void
nsContentUtils
:
:
SplitExpatName
(
const
char16_t
*
aExpatName
nsAtom
*
*
aPrefix
nsAtom
*
*
aLocalName
int32_t
*
aNameSpaceID
)
{
const
char16_t
*
uriEnd
=
nullptr
;
const
char16_t
*
nameEnd
=
nullptr
;
const
char16_t
*
pos
;
for
(
pos
=
aExpatName
;
*
pos
;
+
+
pos
)
{
if
(
*
pos
=
=
0xFFFF
)
{
if
(
uriEnd
)
{
nameEnd
=
pos
;
}
else
{
uriEnd
=
pos
;
}
}
}
const
char16_t
*
nameStart
;
if
(
uriEnd
)
{
if
(
sNameSpaceManager
)
{
sNameSpaceManager
-
>
RegisterNameSpace
(
nsDependentSubstring
(
aExpatName
uriEnd
)
*
aNameSpaceID
)
;
}
else
{
*
aNameSpaceID
=
kNameSpaceID_Unknown
;
}
nameStart
=
(
uriEnd
+
1
)
;
if
(
nameEnd
)
{
const
char16_t
*
prefixStart
=
nameEnd
+
1
;
*
aPrefix
=
NS_AtomizeMainThread
(
Substring
(
prefixStart
pos
)
)
.
take
(
)
;
}
else
{
nameEnd
=
pos
;
*
aPrefix
=
nullptr
;
}
}
else
{
*
aNameSpaceID
=
kNameSpaceID_None
;
nameStart
=
aExpatName
;
nameEnd
=
pos
;
*
aPrefix
=
nullptr
;
}
*
aLocalName
=
NS_AtomizeMainThread
(
Substring
(
nameStart
nameEnd
)
)
.
take
(
)
;
}
nsIPresShell
*
nsContentUtils
:
:
GetPresShellForContent
(
const
nsIContent
*
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
return
doc
-
>
GetShell
(
)
;
}
nsPresContext
*
nsContentUtils
:
:
GetContextForContent
(
const
nsIContent
*
aContent
)
{
nsIPresShell
*
presShell
=
GetPresShellForContent
(
aContent
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
return
presShell
-
>
GetPresContext
(
)
;
}
bool
nsContentUtils
:
:
CanLoadImage
(
nsIURI
*
aURI
nsINode
*
aNode
Document
*
aLoadingDocument
nsIPrincipal
*
aLoadingPrincipal
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aLoadingDocument
"
Must
have
a
document
"
)
;
MOZ_ASSERT
(
aLoadingPrincipal
"
Must
have
a
loading
principal
"
)
;
nsresult
rv
;
auto
appType
=
nsIDocShell
:
:
APP_TYPE_UNKNOWN
;
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellTreeItem
=
aLoadingDocument
-
>
GetDocShell
(
)
;
if
(
docShellTreeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
docShellTreeItem
-
>
GetRootTreeItem
(
getter_AddRefs
(
root
)
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
root
)
)
;
if
(
docShell
)
{
appType
=
docShell
-
>
GetAppType
(
)
;
}
}
}
if
(
appType
!
=
nsIDocShell
:
:
APP_TYPE_EDITOR
)
{
rv
=
sSecurityManager
-
>
CheckLoadURIWithPrincipal
(
aLoadingPrincipal
aURI
nsIScriptSecurityManager
:
:
ALLOW_CHROME
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
}
nsCOMPtr
<
nsILoadInfo
>
secCheckLoadInfo
=
new
mozilla
:
:
net
:
:
LoadInfo
(
aLoadingPrincipal
aLoadingPrincipal
aNode
nsILoadInfo
:
:
SEC_ONLY_FOR_EXPLICIT_CONTENTSEC_CHECK
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
)
;
int16_t
decision
=
nsIContentPolicy
:
:
ACCEPT
;
rv
=
NS_CheckContentLoadPolicy
(
aURI
secCheckLoadInfo
EmptyCString
(
)
&
decision
GetContentPolicy
(
)
)
;
return
NS_FAILED
(
rv
)
?
false
:
NS_CP_ACCEPTED
(
decision
)
;
}
mozilla
:
:
OriginAttributes
nsContentUtils
:
:
GetOriginAttributes
(
Document
*
aDocument
)
{
if
(
!
aDocument
)
{
return
mozilla
:
:
OriginAttributes
(
)
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aDocument
-
>
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
return
GetOriginAttributes
(
loadGroup
)
;
}
mozilla
:
:
OriginAttributes
attrs
;
nsCOMPtr
<
nsIChannel
>
channel
=
aDocument
-
>
GetChannel
(
)
;
if
(
channel
)
{
NS_GetOriginAttributes
(
channel
attrs
)
;
}
return
attrs
;
}
mozilla
:
:
OriginAttributes
nsContentUtils
:
:
GetOriginAttributes
(
nsILoadGroup
*
aLoadGroup
)
{
if
(
!
aLoadGroup
)
{
return
mozilla
:
:
OriginAttributes
(
)
;
}
mozilla
:
:
OriginAttributes
attrs
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_GetInterface
(
callbacks
)
;
if
(
loadContext
)
{
loadContext
-
>
GetOriginAttributes
(
attrs
)
;
}
}
return
attrs
;
}
bool
nsContentUtils
:
:
IsInPrivateBrowsing
(
Document
*
aDoc
)
{
if
(
!
aDoc
)
{
return
false
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aDoc
-
>
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
loadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_GetInterface
(
callbacks
)
;
if
(
loadContext
)
{
return
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
}
}
nsCOMPtr
<
nsIChannel
>
channel
=
aDoc
-
>
GetChannel
(
)
;
return
channel
&
&
NS_UsePrivateBrowsing
(
channel
)
;
}
bool
nsContentUtils
:
:
IsInPrivateBrowsing
(
nsILoadGroup
*
aLoadGroup
)
{
if
(
!
aLoadGroup
)
{
return
false
;
}
bool
isPrivate
=
false
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
callbacks
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_GetInterface
(
callbacks
)
;
isPrivate
=
loadContext
&
&
loadContext
-
>
UsePrivateBrowsing
(
)
;
}
return
isPrivate
;
}
bool
nsContentUtils
:
:
DocumentInactiveForImageLoads
(
Document
*
aDocument
)
{
if
(
aDocument
&
&
!
IsChromeDoc
(
aDocument
)
&
&
!
aDocument
-
>
IsResourceDoc
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
aDocument
-
>
GetScopeObject
(
)
)
;
return
!
win
|
|
!
win
-
>
GetDocShell
(
)
;
}
return
false
;
}
imgLoader
*
nsContentUtils
:
:
GetImgLoaderForDocument
(
Document
*
aDoc
)
{
NS_ENSURE_TRUE
(
!
DocumentInactiveForImageLoads
(
aDoc
)
nullptr
)
;
if
(
!
aDoc
)
{
return
imgLoader
:
:
NormalLoader
(
)
;
}
bool
isPrivate
=
IsInPrivateBrowsing
(
aDoc
)
;
return
isPrivate
?
imgLoader
:
:
PrivateBrowsingLoader
(
)
:
imgLoader
:
:
NormalLoader
(
)
;
}
imgLoader
*
nsContentUtils
:
:
GetImgLoaderForChannel
(
nsIChannel
*
aChannel
Document
*
aContext
)
{
NS_ENSURE_TRUE
(
!
DocumentInactiveForImageLoads
(
aContext
)
nullptr
)
;
if
(
!
aChannel
)
{
return
imgLoader
:
:
NormalLoader
(
)
;
}
nsCOMPtr
<
nsILoadContext
>
context
;
NS_QueryNotificationCallbacks
(
aChannel
context
)
;
return
context
&
&
context
-
>
UsePrivateBrowsing
(
)
?
imgLoader
:
:
PrivateBrowsingLoader
(
)
:
imgLoader
:
:
NormalLoader
(
)
;
}
bool
nsContentUtils
:
:
IsImageInCache
(
nsIURI
*
aURI
Document
*
aDocument
)
{
imgILoader
*
loader
=
GetImgLoaderForDocument
(
aDocument
)
;
nsCOMPtr
<
imgICache
>
cache
=
do_QueryInterface
(
loader
)
;
nsCOMPtr
<
nsIProperties
>
props
;
nsresult
rv
=
cache
-
>
FindEntryProperties
(
aURI
aDocument
getter_AddRefs
(
props
)
)
;
return
(
NS_SUCCEEDED
(
rv
)
&
&
props
)
;
}
int32_t
nsContentUtils
:
:
CORSModeToLoadImageFlags
(
mozilla
:
:
CORSMode
aMode
)
{
switch
(
aMode
)
{
case
CORS_ANONYMOUS
:
return
imgILoader
:
:
LOAD_CORS_ANONYMOUS
;
case
CORS_USE_CREDENTIALS
:
return
imgILoader
:
:
LOAD_CORS_USE_CREDENTIALS
;
default
:
return
0
;
}
}
nsresult
nsContentUtils
:
:
LoadImage
(
nsIURI
*
aURI
nsINode
*
aContext
Document
*
aLoadingDocument
nsIPrincipal
*
aLoadingPrincipal
uint64_t
aRequestContextID
nsIURI
*
aReferrer
net
:
:
ReferrerPolicy
aReferrerPolicy
imgINotificationObserver
*
aObserver
int32_t
aLoadFlags
const
nsAString
&
initiatorType
imgRequestProxy
*
*
aRequest
uint32_t
aContentPolicyType
bool
aUseUrgentStartForChannel
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aContext
"
Must
have
a
context
"
)
;
MOZ_ASSERT
(
aLoadingDocument
"
Must
have
a
document
"
)
;
MOZ_ASSERT
(
aLoadingPrincipal
"
Must
have
a
principal
"
)
;
MOZ_ASSERT
(
aRequest
"
Null
out
param
"
)
;
imgLoader
*
imgLoader
=
GetImgLoaderForDocument
(
aLoadingDocument
)
;
if
(
!
imgLoader
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aLoadingDocument
-
>
GetDocumentLoadGroup
(
)
;
nsIURI
*
documentURI
=
aLoadingDocument
-
>
GetDocumentURI
(
)
;
NS_ASSERTION
(
loadGroup
|
|
IsFontTableURI
(
documentURI
)
"
Could
not
get
loadgroup
;
onload
may
fire
too
early
"
)
;
return
imgLoader
-
>
LoadImage
(
aURI
documentURI
aReferrer
aReferrerPolicy
aLoadingPrincipal
aRequestContextID
loadGroup
aObserver
aContext
aLoadingDocument
aLoadFlags
nullptr
aContentPolicyType
initiatorType
aUseUrgentStartForChannel
aRequest
)
;
}
already_AddRefed
<
imgIContainer
>
nsContentUtils
:
:
GetImageFromContent
(
nsIImageLoadingContent
*
aContent
imgIRequest
*
*
aRequest
)
{
if
(
aRequest
)
{
*
aRequest
=
nullptr
;
}
NS_ENSURE_TRUE
(
aContent
nullptr
)
;
nsCOMPtr
<
imgIRequest
>
imgRequest
;
aContent
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgRequest
)
)
;
if
(
!
imgRequest
)
{
return
nullptr
;
}
nsCOMPtr
<
imgIContainer
>
imgContainer
;
imgRequest
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
if
(
!
imgContainer
)
{
return
nullptr
;
}
if
(
aRequest
)
{
imgRequest
.
swap
(
*
aRequest
)
;
}
return
imgContainer
.
forget
(
)
;
}
already_AddRefed
<
imgRequestProxy
>
nsContentUtils
:
:
GetStaticRequest
(
Document
*
aLoadingDocument
imgRequestProxy
*
aRequest
)
{
NS_ENSURE_TRUE
(
aRequest
nullptr
)
;
RefPtr
<
imgRequestProxy
>
retval
;
aRequest
-
>
GetStaticRequest
(
aLoadingDocument
getter_AddRefs
(
retval
)
)
;
return
retval
.
forget
(
)
;
}
bool
nsContentUtils
:
:
ContentIsDraggable
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
if
(
auto
htmlElement
=
nsGenericHTMLElement
:
:
FromNode
(
aContent
)
)
{
if
(
htmlElement
-
>
Draggable
(
)
)
{
return
true
;
}
if
(
htmlElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
draggable
nsGkAtoms
:
:
_false
eIgnoreCase
)
)
{
return
false
;
}
}
return
IsDraggableImage
(
aContent
)
|
|
IsDraggableLink
(
aContent
)
;
}
bool
nsContentUtils
:
:
IsDraggableImage
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
"
Must
have
content
node
to
test
"
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageContent
(
do_QueryInterface
(
aContent
)
)
;
if
(
!
imageContent
)
{
return
false
;
}
nsCOMPtr
<
imgIRequest
>
imgRequest
;
imageContent
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgRequest
)
)
;
return
imgRequest
!
=
nullptr
;
}
bool
nsContentUtils
:
:
IsDraggableLink
(
const
nsIContent
*
aContent
)
{
nsCOMPtr
<
nsIURI
>
absURI
;
return
aContent
-
>
IsLink
(
getter_AddRefs
(
absURI
)
)
;
}
nsresult
nsContentUtils
:
:
QNameChanged
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsAtom
*
aName
mozilla
:
:
dom
:
:
NodeInfo
*
*
aResult
)
{
nsNodeInfoManager
*
niMgr
=
aNodeInfo
-
>
NodeInfoManager
(
)
;
*
aResult
=
niMgr
-
>
GetNodeInfo
(
aName
nullptr
aNodeInfo
-
>
NamespaceID
(
)
aNodeInfo
-
>
NodeType
(
)
aNodeInfo
-
>
GetExtraName
(
)
)
.
take
(
)
;
return
NS_OK
;
}
static
bool
TestSitePerm
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
uint32_t
aPerm
bool
aExactHostMatch
)
{
if
(
!
aPrincipal
)
{
return
aPerm
!
=
nsIPermissionManager
:
:
ALLOW_ACTION
;
}
nsCOMPtr
<
nsIPermissionManager
>
permMgr
=
services
:
:
GetPermissionManager
(
)
;
NS_ENSURE_TRUE
(
permMgr
false
)
;
uint32_t
perm
;
nsresult
rv
;
if
(
aExactHostMatch
)
{
rv
=
permMgr
-
>
TestExactPermissionFromPrincipal
(
aPrincipal
aType
&
perm
)
;
}
else
{
rv
=
permMgr
-
>
TestPermissionFromPrincipal
(
aPrincipal
aType
&
perm
)
;
}
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
perm
=
=
aPerm
;
}
bool
nsContentUtils
:
:
IsSitePermAllow
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
)
{
return
TestSitePerm
(
aPrincipal
aType
nsIPermissionManager
:
:
ALLOW_ACTION
false
)
;
}
bool
nsContentUtils
:
:
IsSitePermDeny
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
)
{
return
TestSitePerm
(
aPrincipal
aType
nsIPermissionManager
:
:
DENY_ACTION
false
)
;
}
bool
nsContentUtils
:
:
IsExactSitePermAllow
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
)
{
return
TestSitePerm
(
aPrincipal
aType
nsIPermissionManager
:
:
ALLOW_ACTION
true
)
;
}
bool
nsContentUtils
:
:
IsExactSitePermDeny
(
nsIPrincipal
*
aPrincipal
const
char
*
aType
)
{
return
TestSitePerm
(
aPrincipal
aType
nsIPermissionManager
:
:
DENY_ACTION
true
)
;
}
static
const
char
*
gEventNames
[
]
=
{
"
event
"
}
;
static
const
char
*
gSVGEventNames
[
]
=
{
"
evt
"
}
;
static
const
char
*
gOnErrorNames
[
]
=
{
"
event
"
"
source
"
"
lineno
"
"
colno
"
"
error
"
}
;
void
nsContentUtils
:
:
GetEventArgNames
(
int32_t
aNameSpaceID
nsAtom
*
aEventName
bool
aIsForWindow
uint32_t
*
aArgCount
const
char
*
*
*
aArgArray
)
{
#
define
SET_EVENT_ARG_NAMES
(
names
)
\
*
aArgCount
=
sizeof
(
names
)
/
sizeof
(
names
[
0
]
)
;
\
*
aArgArray
=
names
;
if
(
aEventName
=
=
nsGkAtoms
:
:
onerror
&
&
aIsForWindow
)
{
SET_EVENT_ARG_NAMES
(
gOnErrorNames
)
;
}
else
if
(
aNameSpaceID
=
=
kNameSpaceID_SVG
)
{
SET_EVENT_ARG_NAMES
(
gSVGEventNames
)
;
}
else
{
SET_EVENT_ARG_NAMES
(
gEventNames
)
;
}
}
static
const
char
gPropertiesFiles
[
nsContentUtils
:
:
PropertiesFile_COUNT
]
[
56
]
=
{
"
chrome
:
/
/
global
/
locale
/
css
.
properties
"
"
chrome
:
/
/
global
/
locale
/
xbl
.
properties
"
"
chrome
:
/
/
global
/
locale
/
xul
.
properties
"
"
chrome
:
/
/
global
/
locale
/
layout_errors
.
properties
"
"
chrome
:
/
/
global
/
locale
/
layout
/
HtmlForm
.
properties
"
"
chrome
:
/
/
global
/
locale
/
printing
.
properties
"
"
chrome
:
/
/
global
/
locale
/
dom
/
dom
.
properties
"
"
chrome
:
/
/
global
/
locale
/
layout
/
htmlparser
.
properties
"
"
chrome
:
/
/
global
/
locale
/
svg
/
svg
.
properties
"
"
chrome
:
/
/
branding
/
locale
/
brand
.
properties
"
"
chrome
:
/
/
global
/
locale
/
commonDialogs
.
properties
"
"
chrome
:
/
/
global
/
locale
/
mathml
/
mathml
.
properties
"
"
chrome
:
/
/
global
/
locale
/
security
/
security
.
properties
"
"
chrome
:
/
/
necko
/
locale
/
necko
.
properties
"
}
;
nsresult
nsContentUtils
:
:
EnsureStringBundle
(
PropertiesFile
aFile
)
{
if
(
!
sStringBundles
[
aFile
]
)
{
if
(
!
sStringBundleService
)
{
nsresult
rv
=
CallGetService
(
NS_STRINGBUNDLE_CONTRACTID
&
sStringBundleService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsIStringBundle
*
bundle
;
nsresult
rv
=
sStringBundleService
-
>
CreateBundle
(
gPropertiesFiles
[
aFile
]
&
bundle
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
sStringBundles
[
aFile
]
=
bundle
;
}
return
NS_OK
;
}
void
nsContentUtils
:
:
AsyncPrecreateStringBundles
(
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
for
(
uint32_t
bundleIndex
=
0
;
bundleIndex
<
PropertiesFile_COUNT
;
+
+
bundleIndex
)
{
nsresult
rv
=
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
AsyncPrecreateStringBundles
"
[
bundleIndex
]
(
)
{
PropertiesFile
file
=
static_cast
<
PropertiesFile
>
(
bundleIndex
)
;
EnsureStringBundle
(
file
)
;
nsIStringBundle
*
bundle
=
sStringBundles
[
file
]
;
bundle
-
>
AsyncPreload
(
)
;
}
)
EventQueuePriority
:
:
Idle
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
}
nsresult
nsContentUtils
:
:
GetLocalizedString
(
PropertiesFile
aFile
const
char
*
aKey
nsAString
&
aResult
)
{
nsresult
rv
=
EnsureStringBundle
(
aFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIStringBundle
*
bundle
=
sStringBundles
[
aFile
]
;
return
bundle
-
>
GetStringFromName
(
aKey
aResult
)
;
}
nsresult
nsContentUtils
:
:
FormatLocalizedString
(
PropertiesFile
aFile
const
char
*
aKey
const
char16_t
*
*
aParams
uint32_t
aParamsLength
nsAString
&
aResult
)
{
nsresult
rv
=
EnsureStringBundle
(
aFile
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIStringBundle
*
bundle
=
sStringBundles
[
aFile
]
;
if
(
!
aParams
|
|
!
aParamsLength
)
{
return
bundle
-
>
GetStringFromName
(
aKey
aResult
)
;
}
return
bundle
-
>
FormatStringFromName
(
aKey
aParams
aParamsLength
aResult
)
;
}
nsresult
nsContentUtils
:
:
FormatLocalizedString
(
PropertiesFile
aFile
const
char
*
aKey
const
nsTArray
<
nsString
>
&
aParamArray
nsAString
&
aResult
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
UniquePtr
<
const
char16_t
*
[
]
>
params
;
uint32_t
paramsLength
=
aParamArray
.
Length
(
)
;
if
(
paramsLength
>
0
)
{
params
=
MakeUnique
<
const
char16_t
*
[
]
>
(
paramsLength
)
;
for
(
uint32_t
i
=
0
;
i
<
paramsLength
;
+
+
i
)
{
params
[
i
]
=
aParamArray
[
i
]
.
get
(
)
;
}
}
return
FormatLocalizedString
(
aFile
aKey
params
.
get
(
)
paramsLength
aResult
)
;
}
void
nsContentUtils
:
:
LogSimpleConsoleError
(
const
nsAString
&
aErrorText
const
char
*
classification
bool
aFromPrivateWindow
)
{
nsCOMPtr
<
nsIScriptError
>
scriptError
=
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
)
;
if
(
scriptError
)
{
nsCOMPtr
<
nsIConsoleService
>
console
=
do_GetService
(
NS_CONSOLESERVICE_CONTRACTID
)
;
if
(
console
&
&
NS_SUCCEEDED
(
scriptError
-
>
Init
(
aErrorText
EmptyString
(
)
EmptyString
(
)
0
0
nsIScriptError
:
:
errorFlag
classification
aFromPrivateWindow
)
)
)
{
console
-
>
LogMessage
(
scriptError
)
;
}
}
}
nsresult
nsContentUtils
:
:
ReportToConsole
(
uint32_t
aErrorFlags
const
nsACString
&
aCategory
const
Document
*
aDocument
PropertiesFile
aFile
const
char
*
aMessageName
const
char16_t
*
*
aParams
uint32_t
aParamsLength
nsIURI
*
aURI
const
nsString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
)
{
NS_ASSERTION
(
(
aParams
&
&
aParamsLength
)
|
|
(
!
aParams
&
&
!
aParamsLength
)
"
Supply
either
both
parameters
and
their
number
or
no
"
"
parameters
and
0
.
"
)
;
nsresult
rv
;
nsAutoString
errorText
;
if
(
aParams
)
{
rv
=
FormatLocalizedString
(
aFile
aMessageName
aParams
aParamsLength
errorText
)
;
}
else
{
rv
=
GetLocalizedString
(
aFile
aMessageName
errorText
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ReportToConsoleNonLocalized
(
errorText
aErrorFlags
aCategory
aDocument
aURI
aSourceLine
aLineNumber
aColumnNumber
)
;
}
void
nsContentUtils
:
:
ReportEmptyGetElementByIdArg
(
const
Document
*
aDoc
)
{
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
aDoc
nsContentUtils
:
:
eDOM_PROPERTIES
"
EmptyGetElementByIdParam
"
)
;
}
nsresult
nsContentUtils
:
:
ReportToConsoleNonLocalized
(
const
nsAString
&
aErrorText
uint32_t
aErrorFlags
const
nsACString
&
aCategory
const
Document
*
aDocument
nsIURI
*
aURI
const
nsString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
MissingErrorLocationMode
aLocationMode
)
{
uint64_t
innerWindowID
=
0
;
if
(
aDocument
)
{
if
(
!
aURI
)
{
aURI
=
aDocument
-
>
GetDocumentURI
(
)
;
}
innerWindowID
=
aDocument
-
>
InnerWindowID
(
)
;
}
return
ReportToConsoleByWindowID
(
aErrorText
aErrorFlags
aCategory
innerWindowID
aURI
aSourceLine
aLineNumber
aColumnNumber
aLocationMode
)
;
}
nsresult
nsContentUtils
:
:
ReportToConsoleByWindowID
(
const
nsAString
&
aErrorText
uint32_t
aErrorFlags
const
nsACString
&
aCategory
uint64_t
aInnerWindowID
nsIURI
*
aURI
const
nsString
&
aSourceLine
uint32_t
aLineNumber
uint32_t
aColumnNumber
MissingErrorLocationMode
aLocationMode
)
{
nsresult
rv
;
if
(
!
sConsoleService
)
{
rv
=
CallGetService
(
NS_CONSOLESERVICE_CONTRACTID
&
sConsoleService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsAutoCString
spec
;
if
(
!
aLineNumber
&
&
aLocationMode
=
=
eUSE_CALLING_LOCATION
)
{
JSContext
*
cx
=
GetCurrentJSContext
(
)
;
if
(
cx
)
{
nsJSUtils
:
:
GetCallingLocation
(
cx
spec
&
aLineNumber
&
aColumnNumber
)
;
}
}
nsCOMPtr
<
nsIScriptError
>
errorObject
=
do_CreateInstance
(
NS_SCRIPTERROR_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
spec
.
IsEmpty
(
)
)
{
rv
=
errorObject
-
>
InitWithWindowID
(
aErrorText
NS_ConvertUTF8toUTF16
(
spec
)
aSourceLine
aLineNumber
aColumnNumber
aErrorFlags
aCategory
aInnerWindowID
)
;
}
else
{
rv
=
errorObject
-
>
InitWithSourceURI
(
aErrorText
aURI
aSourceLine
aLineNumber
aColumnNumber
aErrorFlags
aCategory
aInnerWindowID
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
sConsoleService
-
>
LogMessage
(
errorObject
)
;
}
void
nsContentUtils
:
:
LogMessageToConsole
(
const
char
*
aMsg
)
{
if
(
!
sConsoleService
)
{
CallGetService
(
NS_CONSOLESERVICE_CONTRACTID
&
sConsoleService
)
;
if
(
!
sConsoleService
)
{
return
;
}
}
sConsoleService
-
>
LogStringMessage
(
NS_ConvertUTF8toUTF16
(
aMsg
)
.
get
(
)
)
;
}
bool
nsContentUtils
:
:
IsChromeDoc
(
const
Document
*
aDocument
)
{
return
aDocument
&
&
aDocument
-
>
NodePrincipal
(
)
=
=
sSystemPrincipal
;
}
bool
nsContentUtils
:
:
IsChildOfSameType
(
Document
*
aDoc
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellAsItem
(
aDoc
-
>
GetDocShell
(
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeParent
;
if
(
docShellAsItem
)
{
docShellAsItem
-
>
GetSameTypeParent
(
getter_AddRefs
(
sameTypeParent
)
)
;
}
return
sameTypeParent
!
=
nullptr
;
}
bool
nsContentUtils
:
:
IsPlainTextType
(
const
nsACString
&
aContentType
)
{
return
aContentType
.
EqualsLiteral
(
TEXT_PLAIN
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_CSS
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_CACHE_MANIFEST
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_VTT
)
|
|
aContentType
.
EqualsLiteral
(
APPLICATION_JAVASCRIPT
)
|
|
aContentType
.
EqualsLiteral
(
APPLICATION_XJAVASCRIPT
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_ECMASCRIPT
)
|
|
aContentType
.
EqualsLiteral
(
APPLICATION_ECMASCRIPT
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_JAVASCRIPT
)
|
|
aContentType
.
EqualsLiteral
(
APPLICATION_JSON
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_JSON
)
;
}
bool
nsContentUtils
:
:
IsUtf8OnlyPlainTextType
(
const
nsACString
&
aContentType
)
{
return
aContentType
.
EqualsLiteral
(
TEXT_CACHE_MANIFEST
)
|
|
aContentType
.
EqualsLiteral
(
APPLICATION_JSON
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_JSON
)
|
|
aContentType
.
EqualsLiteral
(
TEXT_VTT
)
;
}
bool
nsContentUtils
:
:
IsInChromeDocshell
(
Document
*
aDocument
)
{
if
(
!
aDocument
)
{
return
false
;
}
if
(
aDocument
-
>
GetDisplayDocument
(
)
)
{
return
IsInChromeDocshell
(
aDocument
-
>
GetDisplayDocument
(
)
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
docShell
=
aDocument
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
return
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
;
}
nsIContentPolicy
*
nsContentUtils
:
:
GetContentPolicy
(
)
{
if
(
!
sTriedToGetContentPolicy
)
{
CallGetService
(
NS_CONTENTPOLICY_CONTRACTID
&
sContentPolicyService
)
;
sTriedToGetContentPolicy
=
true
;
}
return
sContentPolicyService
;
}
bool
nsContentUtils
:
:
IsEventAttributeName
(
nsAtom
*
aName
int32_t
aType
)
{
const
char16_t
*
name
=
aName
-
>
GetUTF16String
(
)
;
if
(
name
[
0
]
!
=
'
o
'
|
|
name
[
1
]
!
=
'
n
'
)
return
false
;
EventNameMapping
mapping
;
return
(
sAtomEventTable
-
>
Get
(
aName
&
mapping
)
&
&
mapping
.
mType
&
aType
)
;
}
EventMessage
nsContentUtils
:
:
GetEventMessage
(
nsAtom
*
aName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
sAtomEventTable
is
not
threadsafe
"
)
;
if
(
aName
)
{
EventNameMapping
mapping
;
if
(
sAtomEventTable
-
>
Get
(
aName
&
mapping
)
)
{
return
mapping
.
mMessage
;
}
}
return
eUnidentifiedEvent
;
}
mozilla
:
:
EventClassID
nsContentUtils
:
:
GetEventClassID
(
const
nsAString
&
aName
)
{
EventNameMapping
mapping
;
if
(
sStringEventTable
-
>
Get
(
aName
&
mapping
)
)
return
mapping
.
mEventClassID
;
return
eBasicEventClass
;
}
nsAtom
*
nsContentUtils
:
:
GetEventMessageAndAtom
(
const
nsAString
&
aName
mozilla
:
:
EventClassID
aEventClassID
EventMessage
*
aEventMessage
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Our
hashtables
are
not
threadsafe
"
)
;
EventNameMapping
mapping
;
if
(
sStringEventTable
-
>
Get
(
aName
&
mapping
)
)
{
*
aEventMessage
=
mapping
.
mEventClassID
=
=
aEventClassID
?
mapping
.
mMessage
:
eUnidentifiedEvent
;
return
mapping
.
mAtom
;
}
if
(
sUserDefinedEvents
-
>
Length
(
)
>
127
)
{
while
(
sUserDefinedEvents
-
>
Length
(
)
>
64
)
{
nsAtom
*
first
=
sUserDefinedEvents
-
>
ElementAt
(
0
)
;
sStringEventTable
-
>
Remove
(
Substring
(
nsDependentAtomString
(
first
)
2
)
)
;
sUserDefinedEvents
-
>
RemoveElementAt
(
0
)
;
}
}
*
aEventMessage
=
eUnidentifiedEvent
;
RefPtr
<
nsAtom
>
atom
=
NS_AtomizeMainThread
(
NS_LITERAL_STRING
(
"
on
"
)
+
aName
)
;
sUserDefinedEvents
-
>
AppendElement
(
atom
)
;
mapping
.
mAtom
=
atom
;
mapping
.
mMessage
=
eUnidentifiedEvent
;
mapping
.
mType
=
EventNameType_None
;
mapping
.
mEventClassID
=
eBasicEventClass
;
mapping
.
mMaybeSpecialSVGorSMILEvent
=
GetEventMessage
(
atom
)
!
=
eUnidentifiedEvent
;
sStringEventTable
-
>
Put
(
aName
mapping
)
;
return
mapping
.
mAtom
;
}
EventMessage
nsContentUtils
:
:
GetEventMessageAndAtomForListener
(
const
nsAString
&
aName
nsAtom
*
*
aOnName
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
"
Our
hashtables
are
not
threadsafe
"
)
;
EventNameMapping
mapping
;
EventMessage
msg
=
eUnidentifiedEvent
;
RefPtr
<
nsAtom
>
atom
;
if
(
sStringEventTable
-
>
Get
(
aName
&
mapping
)
)
{
if
(
mapping
.
mMaybeSpecialSVGorSMILEvent
)
{
atom
=
NS_AtomizeMainThread
(
NS_LITERAL_STRING
(
"
on
"
)
+
aName
)
;
msg
=
GetEventMessage
(
atom
)
;
}
else
{
atom
=
mapping
.
mAtom
;
msg
=
mapping
.
mMessage
;
}
atom
.
forget
(
aOnName
)
;
return
msg
;
}
GetEventMessageAndAtom
(
aName
eBasicEventClass
&
msg
)
;
return
GetEventMessageAndAtomForListener
(
aName
aOnName
)
;
}
static
nsresult
GetEventAndTarget
(
Document
*
aDoc
nsISupports
*
aTarget
const
nsAString
&
aEventName
CanBubble
aCanBubble
Cancelable
aCancelable
Composed
aComposed
Trusted
aTrusted
Event
*
*
aEvent
EventTarget
*
*
aTargetOut
)
{
nsCOMPtr
<
EventTarget
>
target
(
do_QueryInterface
(
aTarget
)
)
;
NS_ENSURE_TRUE
(
aDoc
&
&
target
NS_ERROR_INVALID_ARG
)
;
ErrorResult
err
;
RefPtr
<
Event
>
event
=
aDoc
-
>
CreateEvent
(
NS_LITERAL_STRING
(
"
Events
"
)
CallerType
:
:
System
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
event
-
>
InitEvent
(
aEventName
aCanBubble
aCancelable
aComposed
)
;
event
-
>
SetTrusted
(
aTrusted
=
=
Trusted
:
:
eYes
)
;
event
-
>
SetTarget
(
target
)
;
event
.
forget
(
aEvent
)
;
target
.
forget
(
aTargetOut
)
;
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
DispatchTrustedEvent
(
Document
*
aDoc
nsISupports
*
aTarget
const
nsAString
&
aEventName
CanBubble
aCanBubble
Cancelable
aCancelable
Composed
aComposed
bool
*
aDefaultAction
)
{
MOZ_ASSERT
(
!
aEventName
.
EqualsLiteral
(
"
input
"
)
"
Use
DispatchInputEvent
(
)
instead
"
)
;
return
DispatchEvent
(
aDoc
aTarget
aEventName
aCanBubble
aCancelable
aComposed
Trusted
:
:
eYes
aDefaultAction
)
;
}
nsresult
nsContentUtils
:
:
DispatchUntrustedEvent
(
Document
*
aDoc
nsISupports
*
aTarget
const
nsAString
&
aEventName
CanBubble
aCanBubble
Cancelable
aCancelable
bool
*
aDefaultAction
)
{
return
DispatchEvent
(
aDoc
aTarget
aEventName
aCanBubble
aCancelable
Composed
:
:
eDefault
Trusted
:
:
eNo
aDefaultAction
)
;
}
nsresult
nsContentUtils
:
:
DispatchEvent
(
Document
*
aDoc
nsISupports
*
aTarget
const
nsAString
&
aEventName
CanBubble
aCanBubble
Cancelable
aCancelable
Composed
aComposed
Trusted
aTrusted
bool
*
aDefaultAction
ChromeOnlyDispatch
aOnlyChromeDispatch
)
{
RefPtr
<
Event
>
event
;
nsCOMPtr
<
EventTarget
>
target
;
nsresult
rv
=
GetEventAndTarget
(
aDoc
aTarget
aEventName
aCanBubble
aCancelable
aComposed
aTrusted
getter_AddRefs
(
event
)
getter_AddRefs
(
target
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlyChromeDispatch
=
aOnlyChromeDispatch
=
=
ChromeOnlyDispatch
:
:
eYes
;
ErrorResult
err
;
bool
doDefault
=
target
-
>
DispatchEvent
(
*
event
CallerType
:
:
System
err
)
;
if
(
aDefaultAction
)
{
*
aDefaultAction
=
doDefault
;
}
return
err
.
StealNSResult
(
)
;
}
nsresult
nsContentUtils
:
:
DispatchEvent
(
Document
*
aDoc
nsISupports
*
aTarget
WidgetEvent
&
aEvent
EventMessage
aEventMessage
CanBubble
aCanBubble
Cancelable
aCancelable
Trusted
aTrusted
bool
*
aDefaultAction
ChromeOnlyDispatch
aOnlyChromeDispatch
)
{
MOZ_ASSERT_IF
(
aOnlyChromeDispatch
=
=
ChromeOnlyDispatch
:
:
eYes
aTrusted
=
=
Trusted
:
:
eYes
)
;
nsCOMPtr
<
EventTarget
>
target
(
do_QueryInterface
(
aTarget
)
)
;
aEvent
.
mTime
=
PR_Now
(
)
;
aEvent
.
mSpecifiedEventType
=
GetEventTypeFromMessage
(
aEventMessage
)
;
aEvent
.
SetDefaultComposed
(
)
;
aEvent
.
SetDefaultComposedInNativeAnonymousContent
(
)
;
aEvent
.
mFlags
.
mBubbles
=
aCanBubble
=
=
CanBubble
:
:
eYes
;
aEvent
.
mFlags
.
mCancelable
=
aCancelable
=
=
Cancelable
:
:
eYes
;
aEvent
.
mFlags
.
mOnlyChromeDispatch
=
aOnlyChromeDispatch
=
=
ChromeOnlyDispatch
:
:
eYes
;
aEvent
.
mTarget
=
target
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsresult
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
target
&
aEvent
nullptr
nullptr
&
status
)
;
if
(
aDefaultAction
)
{
*
aDefaultAction
=
(
status
!
=
nsEventStatus_eConsumeNoDefault
)
;
}
return
rv
;
}
nsresult
nsContentUtils
:
:
DispatchInputEvent
(
Element
*
aEventTargetElement
)
{
RefPtr
<
TextEditor
>
textEditor
;
return
DispatchInputEvent
(
aEventTargetElement
EditorInputType
:
:
eUnknown
textEditor
)
;
}
nsresult
nsContentUtils
:
:
DispatchInputEvent
(
Element
*
aEventTargetElement
EditorInputType
aEditorInputType
TextEditor
*
aTextEditor
)
{
if
(
NS_WARN_IF
(
!
aEventTargetElement
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
bool
useInputEvent
=
false
;
if
(
aTextEditor
)
{
useInputEvent
=
true
;
}
else
if
(
HTMLTextAreaElement
*
textAreaElement
=
HTMLTextAreaElement
:
:
FromNode
(
aEventTargetElement
)
)
{
aTextEditor
=
textAreaElement
-
>
GetTextEditorWithoutCreation
(
)
;
useInputEvent
=
true
;
}
else
if
(
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNode
(
aEventTargetElement
)
)
{
if
(
inputElement
-
>
IsInputEventTarget
(
)
)
{
aTextEditor
=
inputElement
-
>
GetTextEditorWithoutCreation
(
)
;
useInputEvent
=
true
;
}
}
#
ifdef
DEBUG
else
{
nsCOMPtr
<
nsITextControlElement
>
textControlElement
=
do_QueryInterface
(
aEventTargetElement
)
;
MOZ_ASSERT
(
!
textControlElement
"
The
event
target
may
have
editor
but
we
'
ve
not
known
it
yet
.
"
)
;
}
#
endif
if
(
!
useInputEvent
)
{
MOZ_ASSERT
(
aEditorInputType
=
=
EditorInputType
:
:
eUnknown
)
;
WidgetEvent
widgetEvent
(
true
eUnidentifiedEvent
)
;
widgetEvent
.
mSpecifiedEventType
=
nsGkAtoms
:
:
oninput
;
widgetEvent
.
mFlags
.
mCancelable
=
false
;
widgetEvent
.
mTime
=
PR_Now
(
)
;
(
new
AsyncEventDispatcher
(
aEventTargetElement
widgetEvent
)
)
-
>
RunDOMEventWhenSafe
(
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIWidget
>
widget
;
if
(
aTextEditor
)
{
widget
=
aTextEditor
-
>
GetWidget
(
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
NS_ERROR_FAILURE
;
}
}
else
{
Document
*
document
=
aEventTargetElement
-
>
OwnerDoc
(
)
;
if
(
NS_WARN_IF
(
!
document
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIPresShell
*
presShell
=
document
-
>
GetShell
(
)
;
if
(
presShell
)
{
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
NS_ERROR_FAILURE
;
}
widget
=
presContext
-
>
GetRootWidget
(
)
;
if
(
NS_WARN_IF
(
!
widget
)
)
{
return
NS_ERROR_FAILURE
;
}
}
}
InternalEditorInputEvent
inputEvent
(
true
eEditorInput
widget
)
;
inputEvent
.
mTime
=
static_cast
<
uint64_t
>
(
PR_Now
(
)
/
1000
)
;
inputEvent
.
mIsComposing
=
aTextEditor
?
!
!
aTextEditor
-
>
GetComposition
(
)
:
false
;
inputEvent
.
mInputType
=
aEditorInputType
;
(
new
AsyncEventDispatcher
(
aEventTargetElement
inputEvent
)
)
-
>
RunDOMEventWhenSafe
(
)
;
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
DispatchChromeEvent
(
Document
*
aDoc
nsISupports
*
aTarget
const
nsAString
&
aEventName
CanBubble
aCanBubble
Cancelable
aCancelable
bool
*
aDefaultAction
)
{
RefPtr
<
Event
>
event
;
nsCOMPtr
<
EventTarget
>
target
;
nsresult
rv
=
GetEventAndTarget
(
aDoc
aTarget
aEventName
aCanBubble
aCancelable
Composed
:
:
eDefault
Trusted
:
:
eYes
getter_AddRefs
(
event
)
getter_AddRefs
(
target
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
aDoc
"
GetEventAndTarget
lied
?
"
)
;
if
(
!
aDoc
-
>
GetWindow
(
)
)
return
NS_ERROR_INVALID_ARG
;
EventTarget
*
piTarget
=
aDoc
-
>
GetWindow
(
)
-
>
GetParentTarget
(
)
;
if
(
!
piTarget
)
return
NS_ERROR_INVALID_ARG
;
ErrorResult
err
;
bool
defaultActionEnabled
=
piTarget
-
>
DispatchEvent
(
*
event
CallerType
:
:
System
err
)
;
if
(
aDefaultAction
)
{
*
aDefaultAction
=
defaultActionEnabled
;
}
return
err
.
StealNSResult
(
)
;
}
nsresult
nsContentUtils
:
:
DispatchFocusChromeEvent
(
nsPIDOMWindowOuter
*
aWindow
)
{
MOZ_ASSERT
(
aWindow
)
;
RefPtr
<
Document
>
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
!
doc
)
{
return
NS_ERROR_FAILURE
;
}
return
DispatchChromeEvent
(
doc
aWindow
NS_LITERAL_STRING
(
"
DOMWindowFocus
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
}
nsresult
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
Document
*
aDoc
nsISupports
*
aTarget
const
nsAString
&
aEventName
CanBubble
aCanBubble
Cancelable
aCancelable
bool
*
aDefaultAction
)
{
return
DispatchEvent
(
aDoc
aTarget
aEventName
aCanBubble
aCancelable
Composed
:
:
eDefault
Trusted
:
:
eYes
aDefaultAction
ChromeOnlyDispatch
:
:
eYes
)
;
}
Element
*
nsContentUtils
:
:
MatchElementId
(
nsIContent
*
aContent
const
nsAtom
*
aId
)
{
for
(
nsIContent
*
cur
=
aContent
;
cur
;
cur
=
cur
-
>
GetNextNode
(
aContent
)
)
{
if
(
aId
=
=
cur
-
>
GetID
(
)
)
{
return
cur
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
Element
*
nsContentUtils
:
:
MatchElementId
(
nsIContent
*
aContent
const
nsAString
&
aId
)
{
MOZ_ASSERT
(
!
aId
.
IsEmpty
(
)
"
Will
match
random
elements
"
)
;
RefPtr
<
nsAtom
>
id
(
NS_Atomize
(
aId
)
)
;
if
(
!
id
)
{
return
nullptr
;
}
return
MatchElementId
(
aContent
id
)
;
}
Document
*
nsContentUtils
:
:
GetSubdocumentWithOuterWindowId
(
Document
*
aDocument
uint64_t
aOuterWindowId
)
{
if
(
!
aDocument
|
|
!
aOuterWindowId
)
{
return
nullptr
;
}
RefPtr
<
nsGlobalWindowOuter
>
window
=
nsGlobalWindowOuter
:
:
GetOuterWindowWithId
(
aOuterWindowId
)
;
if
(
!
window
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
outerWindow
=
window
-
>
AsOuter
(
)
;
RefPtr
<
Document
>
foundDoc
=
outerWindow
-
>
GetDoc
(
)
;
if
(
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
foundDoc
aDocument
)
)
{
return
foundDoc
;
}
return
nullptr
;
}
void
nsContentUtils
:
:
RegisterShutdownObserver
(
nsIObserver
*
aObserver
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
AddObserver
(
aObserver
NS_XPCOM_SHUTDOWN_OBSERVER_ID
false
)
;
}
}
void
nsContentUtils
:
:
UnregisterShutdownObserver
(
nsIObserver
*
aObserver
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
RemoveObserver
(
aObserver
NS_XPCOM_SHUTDOWN_OBSERVER_ID
)
;
}
}
bool
nsContentUtils
:
:
HasNonEmptyAttr
(
const
nsIContent
*
aContent
int32_t
aNameSpaceID
nsAtom
*
aName
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
_empty
nullptr
}
;
return
aContent
-
>
IsElement
(
)
&
&
aContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
aNameSpaceID
aName
strings
eCaseMatters
)
=
=
Element
:
:
ATTR_VALUE_NO_MATCH
;
}
bool
nsContentUtils
:
:
HasMutationListeners
(
nsINode
*
aNode
uint32_t
aType
nsINode
*
aTargetForSubtreeModified
)
{
Document
*
doc
=
aNode
-
>
OwnerDoc
(
)
;
nsPIDOMWindowInner
*
window
=
doc
-
>
GetInnerWindow
(
)
;
if
(
window
&
&
!
window
-
>
HasMutationListeners
(
aType
)
)
{
return
false
;
}
if
(
aNode
-
>
ChromeOnlyAccess
(
)
|
|
aNode
-
>
IsInShadowTree
(
)
)
{
return
false
;
}
doc
-
>
MayDispatchMutationEvent
(
aTargetForSubtreeModified
)
;
if
(
aNode
-
>
IsInUncomposedDoc
(
)
)
{
nsCOMPtr
<
EventTarget
>
piTarget
(
do_QueryInterface
(
window
)
)
;
if
(
piTarget
)
{
EventListenerManager
*
manager
=
piTarget
-
>
GetExistingListenerManager
(
)
;
if
(
manager
&
&
manager
-
>
HasMutationListeners
(
)
)
{
return
true
;
}
}
}
while
(
aNode
)
{
EventListenerManager
*
manager
=
aNode
-
>
GetExistingListenerManager
(
)
;
if
(
manager
&
&
manager
-
>
HasMutationListeners
(
)
)
{
return
true
;
}
if
(
aNode
-
>
IsContent
(
)
)
{
nsIContent
*
insertionPoint
=
aNode
-
>
AsContent
(
)
-
>
GetXBLInsertionPoint
(
)
;
if
(
insertionPoint
)
{
aNode
=
insertionPoint
-
>
GetParent
(
)
;
MOZ_ASSERT
(
aNode
)
;
continue
;
}
}
aNode
=
aNode
-
>
GetParentNode
(
)
;
}
return
false
;
}
bool
nsContentUtils
:
:
HasMutationListeners
(
Document
*
aDocument
uint32_t
aType
)
{
nsPIDOMWindowInner
*
window
=
aDocument
?
aDocument
-
>
GetInnerWindow
(
)
:
nullptr
;
return
!
window
|
|
window
-
>
HasMutationListeners
(
aType
)
;
}
void
nsContentUtils
:
:
MaybeFireNodeRemoved
(
nsINode
*
aChild
nsINode
*
aParent
)
{
MOZ_ASSERT
(
aChild
"
Missing
child
"
)
;
MOZ_ASSERT
(
aChild
-
>
GetParentNode
(
)
=
=
aParent
"
Wrong
parent
"
)
;
MOZ_ASSERT
(
aChild
-
>
OwnerDoc
(
)
=
=
aParent
-
>
OwnerDoc
(
)
"
Wrong
owner
-
doc
"
)
;
if
(
!
IsSafeToRunScript
(
)
)
{
if
(
!
(
aChild
-
>
IsContent
(
)
&
&
aChild
-
>
AsContent
(
)
-
>
IsInNativeAnonymousSubtree
(
)
)
&
&
!
sDOMNodeRemovedSuppressCount
)
{
NS_ERROR
(
"
Want
to
fire
DOMNodeRemoved
event
but
it
'
s
not
safe
"
)
;
WarnScriptWasIgnored
(
aChild
-
>
OwnerDoc
(
)
)
;
}
return
;
}
if
(
HasMutationListeners
(
aChild
NS_EVENT_BITS_MUTATION_NODEREMOVED
aParent
)
)
{
InternalMutationEvent
mutation
(
true
eLegacyNodeRemoved
)
;
mutation
.
mRelatedNode
=
aParent
;
mozAutoSubtreeModified
subtree
(
aParent
-
>
OwnerDoc
(
)
aParent
)
;
EventDispatcher
:
:
Dispatch
(
aChild
nullptr
&
mutation
)
;
}
}
void
nsContentUtils
:
:
UnmarkGrayJSListenersInCCGenerationDocuments
(
)
{
if
(
!
sEventListenerManagersHash
)
{
return
;
}
for
(
auto
i
=
sEventListenerManagersHash
-
>
Iter
(
)
;
!
i
.
Done
(
)
;
i
.
Next
(
)
)
{
auto
entry
=
static_cast
<
EventListenerManagerMapEntry
*
>
(
i
.
Get
(
)
)
;
nsINode
*
n
=
static_cast
<
nsINode
*
>
(
entry
-
>
mListenerManager
-
>
GetTarget
(
)
)
;
if
(
n
&
&
n
-
>
IsInComposedDoc
(
)
&
&
nsCCUncollectableMarker
:
:
InGeneration
(
n
-
>
OwnerDoc
(
)
-
>
GetMarkedCCGeneration
(
)
)
)
{
entry
-
>
mListenerManager
-
>
MarkForCC
(
)
;
}
}
}
void
nsContentUtils
:
:
TraverseListenerManager
(
nsINode
*
aNode
nsCycleCollectionTraversalCallback
&
cb
)
{
if
(
!
sEventListenerManagersHash
)
{
return
;
}
auto
entry
=
static_cast
<
EventListenerManagerMapEntry
*
>
(
sEventListenerManagersHash
-
>
Search
(
aNode
)
)
;
if
(
entry
)
{
CycleCollectionNoteChild
(
cb
entry
-
>
mListenerManager
.
get
(
)
"
[
via
hash
]
mListenerManager
"
)
;
}
}
EventListenerManager
*
nsContentUtils
:
:
GetListenerManagerForNode
(
nsINode
*
aNode
)
{
if
(
!
sEventListenerManagersHash
)
{
return
nullptr
;
}
auto
entry
=
static_cast
<
EventListenerManagerMapEntry
*
>
(
sEventListenerManagersHash
-
>
Add
(
aNode
fallible
)
)
;
if
(
!
entry
)
{
return
nullptr
;
}
if
(
!
entry
-
>
mListenerManager
)
{
entry
-
>
mListenerManager
=
new
EventListenerManager
(
aNode
)
;
aNode
-
>
SetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
}
return
entry
-
>
mListenerManager
;
}
EventListenerManager
*
nsContentUtils
:
:
GetExistingListenerManagerForNode
(
const
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
HasFlag
(
NODE_HAS_LISTENERMANAGER
)
)
{
return
nullptr
;
}
if
(
!
sEventListenerManagersHash
)
{
return
nullptr
;
}
auto
entry
=
static_cast
<
EventListenerManagerMapEntry
*
>
(
sEventListenerManagersHash
-
>
Search
(
aNode
)
)
;
if
(
entry
)
{
return
entry
-
>
mListenerManager
;
}
return
nullptr
;
}
void
nsContentUtils
:
:
RemoveListenerManager
(
nsINode
*
aNode
)
{
if
(
sEventListenerManagersHash
)
{
auto
entry
=
static_cast
<
EventListenerManagerMapEntry
*
>
(
sEventListenerManagersHash
-
>
Search
(
aNode
)
)
;
if
(
entry
)
{
RefPtr
<
EventListenerManager
>
listenerManager
;
listenerManager
.
swap
(
entry
-
>
mListenerManager
)
;
sEventListenerManagersHash
-
>
RawRemove
(
entry
)
;
if
(
listenerManager
)
{
listenerManager
-
>
Disconnect
(
)
;
}
}
}
}
bool
nsContentUtils
:
:
IsValidNodeName
(
nsAtom
*
aLocalName
nsAtom
*
aPrefix
int32_t
aNamespaceID
)
{
if
(
aNamespaceID
=
=
kNameSpaceID_Unknown
)
{
return
false
;
}
if
(
!
aPrefix
)
{
return
(
aLocalName
=
=
nsGkAtoms
:
:
xmlns
)
=
=
(
aNamespaceID
=
=
kNameSpaceID_XMLNS
)
;
}
if
(
aNamespaceID
=
=
kNameSpaceID_None
)
{
return
false
;
}
if
(
aNamespaceID
=
=
kNameSpaceID_XMLNS
)
{
return
aPrefix
=
=
nsGkAtoms
:
:
xmlns
&
&
aLocalName
!
=
nsGkAtoms
:
:
xmlns
;
}
return
aPrefix
!
=
nsGkAtoms
:
:
xmlns
&
&
(
aNamespaceID
=
=
kNameSpaceID_XML
|
|
aPrefix
!
=
nsGkAtoms
:
:
xml
)
;
}
already_AddRefed
<
DocumentFragment
>
nsContentUtils
:
:
CreateContextualFragment
(
nsINode
*
aContextNode
const
nsAString
&
aFragment
bool
aPreventScriptExecution
ErrorResult
&
aRv
)
{
if
(
!
aContextNode
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
nullptr
;
}
RefPtr
<
Document
>
document
=
aContextNode
-
>
OwnerDoc
(
)
;
bool
isHTML
=
document
-
>
IsHTMLDocument
(
)
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
document
)
;
NS_ASSERTION
(
!
isHTML
|
|
htmlDoc
"
Should
have
HTMLDocument
here
!
"
)
;
#
endif
if
(
isHTML
)
{
RefPtr
<
DocumentFragment
>
frag
=
new
DocumentFragment
(
document
-
>
NodeInfoManager
(
)
)
;
nsCOMPtr
<
nsIContent
>
contextAsContent
=
do_QueryInterface
(
aContextNode
)
;
if
(
contextAsContent
&
&
!
contextAsContent
-
>
IsElement
(
)
)
{
contextAsContent
=
contextAsContent
-
>
GetParent
(
)
;
if
(
contextAsContent
&
&
!
contextAsContent
-
>
IsElement
(
)
)
{
contextAsContent
=
nullptr
;
}
}
if
(
contextAsContent
&
&
!
contextAsContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
)
{
aRv
=
ParseFragmentHTML
(
aFragment
frag
contextAsContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
contextAsContent
-
>
GetNameSpaceID
(
)
(
document
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
)
aPreventScriptExecution
)
;
}
else
{
aRv
=
ParseFragmentHTML
(
aFragment
frag
nsGkAtoms
:
:
body
kNameSpaceID_XHTML
(
document
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
)
aPreventScriptExecution
)
;
}
return
frag
.
forget
(
)
;
}
AutoTArray
<
nsString
32
>
tagStack
;
nsAutoString
uriStr
nameStr
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aContextNode
)
;
if
(
content
&
&
!
content
-
>
IsElement
(
)
)
content
=
content
-
>
GetParent
(
)
;
while
(
content
&
&
content
-
>
IsElement
(
)
)
{
nsString
&
tagName
=
*
tagStack
.
AppendElement
(
)
;
tagName
=
content
-
>
NodeInfo
(
)
-
>
QualifiedName
(
)
;
uint32_t
count
=
content
-
>
AsElement
(
)
-
>
GetAttrCount
(
)
;
bool
setDefaultNamespace
=
false
;
if
(
count
>
0
)
{
uint32_t
index
;
for
(
index
=
0
;
index
<
count
;
index
+
+
)
{
const
BorrowedAttrInfo
info
=
content
-
>
AsElement
(
)
-
>
GetAttrInfoAt
(
index
)
;
const
nsAttrName
*
name
=
info
.
mName
;
if
(
name
-
>
NamespaceEquals
(
kNameSpaceID_XMLNS
)
)
{
info
.
mValue
-
>
ToString
(
uriStr
)
;
tagName
.
AppendLiteral
(
"
xmlns
"
)
;
if
(
name
-
>
GetPrefix
(
)
)
{
tagName
.
Append
(
char16_t
(
'
:
'
)
)
;
name
-
>
LocalName
(
)
-
>
ToString
(
nameStr
)
;
tagName
.
Append
(
nameStr
)
;
}
else
{
setDefaultNamespace
=
true
;
}
tagName
.
AppendLiteral
(
R
"
(
=
"
)
"
)
;
tagName
.
Append
(
uriStr
)
;
tagName
.
Append
(
'
"
'
)
;
}
}
}
if
(
!
setDefaultNamespace
)
{
mozilla
:
:
dom
:
:
NodeInfo
*
info
=
content
-
>
NodeInfo
(
)
;
if
(
!
info
-
>
GetPrefixAtom
(
)
&
&
info
-
>
NamespaceID
(
)
!
=
kNameSpaceID_None
)
{
info
-
>
GetNamespaceURI
(
uriStr
)
;
tagName
.
AppendLiteral
(
R
"
(
xmlns
=
"
)
"
)
;
tagName
.
Append
(
uriStr
)
;
tagName
.
Append
(
'
"
'
)
;
}
}
content
=
content
-
>
GetParent
(
)
;
}
RefPtr
<
DocumentFragment
>
frag
;
aRv
=
ParseFragmentXML
(
aFragment
document
tagStack
aPreventScriptExecution
getter_AddRefs
(
frag
)
)
;
return
frag
.
forget
(
)
;
}
void
nsContentUtils
:
:
DropFragmentParsers
(
)
{
NS_IF_RELEASE
(
sHTMLFragmentParser
)
;
NS_IF_RELEASE
(
sXMLFragmentParser
)
;
NS_IF_RELEASE
(
sXMLFragmentSink
)
;
}
void
nsContentUtils
:
:
XPCOMShutdown
(
)
{
nsContentUtils
:
:
DropFragmentParsers
(
)
;
}
nsresult
nsContentUtils
:
:
ParseFragmentHTML
(
const
nsAString
&
aSourceBuffer
nsIContent
*
aTargetNode
nsAtom
*
aContextLocalName
int32_t
aContextNamespace
bool
aQuirks
bool
aPreventScriptExecution
)
{
AutoTimelineMarker
m
(
aTargetNode
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
"
Parse
HTML
"
)
;
if
(
nsContentUtils
:
:
sFragmentParsingActive
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Re
-
entrant
fragment
parsing
attempted
.
"
)
;
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
mozilla
:
:
AutoRestore
<
bool
>
guard
(
nsContentUtils
:
:
sFragmentParsingActive
)
;
nsContentUtils
:
:
sFragmentParsingActive
=
true
;
if
(
!
sHTMLFragmentParser
)
{
NS_ADDREF
(
sHTMLFragmentParser
=
new
nsHtml5StringParser
(
)
)
;
}
nsIContent
*
target
=
aTargetNode
;
RefPtr
<
DocumentFragment
>
fragment
;
if
(
IsSystemPrincipal
(
aTargetNode
-
>
NodePrincipal
(
)
)
)
{
fragment
=
new
DocumentFragment
(
aTargetNode
-
>
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
)
;
target
=
fragment
;
}
nsresult
rv
=
sHTMLFragmentParser
-
>
ParseFragment
(
aSourceBuffer
target
aContextLocalName
aContextNamespace
aQuirks
aPreventScriptExecution
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
fragment
)
{
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
nsTreeSanitizer
sanitizer
(
nsIParserUtils
:
:
SanitizerAllowStyle
|
nsIParserUtils
:
:
SanitizerAllowComments
|
nsIParserUtils
:
:
SanitizerDropForms
|
nsIParserUtils
:
:
SanitizerLogRemovals
)
;
sanitizer
.
Sanitize
(
fragment
)
;
ErrorResult
error
;
aTargetNode
-
>
AppendChild
(
*
fragment
error
)
;
rv
=
error
.
StealNSResult
(
)
;
}
return
rv
;
}
nsresult
nsContentUtils
:
:
ParseDocumentHTML
(
const
nsAString
&
aSourceBuffer
Document
*
aTargetDocument
bool
aScriptingEnabledForNoscriptParsing
)
{
AutoTimelineMarker
m
(
aTargetDocument
-
>
GetDocShell
(
)
"
Parse
HTML
"
)
;
if
(
nsContentUtils
:
:
sFragmentParsingActive
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Re
-
entrant
fragment
parsing
attempted
.
"
)
;
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
mozilla
:
:
AutoRestore
<
bool
>
guard
(
nsContentUtils
:
:
sFragmentParsingActive
)
;
nsContentUtils
:
:
sFragmentParsingActive
=
true
;
if
(
!
sHTMLFragmentParser
)
{
NS_ADDREF
(
sHTMLFragmentParser
=
new
nsHtml5StringParser
(
)
)
;
}
nsresult
rv
=
sHTMLFragmentParser
-
>
ParseDocument
(
aSourceBuffer
aTargetDocument
aScriptingEnabledForNoscriptParsing
)
;
return
rv
;
}
nsresult
nsContentUtils
:
:
ParseFragmentXML
(
const
nsAString
&
aSourceBuffer
Document
*
aDocument
nsTArray
<
nsString
>
&
aTagStack
bool
aPreventScriptExecution
DocumentFragment
*
*
aReturn
)
{
AutoTimelineMarker
m
(
aDocument
-
>
GetDocShell
(
)
"
Parse
XML
"
)
;
if
(
nsContentUtils
:
:
sFragmentParsingActive
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Re
-
entrant
fragment
parsing
attempted
.
"
)
;
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
mozilla
:
:
AutoRestore
<
bool
>
guard
(
nsContentUtils
:
:
sFragmentParsingActive
)
;
nsContentUtils
:
:
sFragmentParsingActive
=
true
;
if
(
!
sXMLFragmentParser
)
{
nsCOMPtr
<
nsIParser
>
parser
=
do_CreateInstance
(
kCParserCID
)
;
parser
.
forget
(
&
sXMLFragmentParser
)
;
}
if
(
!
sXMLFragmentSink
)
{
NS_NewXMLFragmentContentSink
(
&
sXMLFragmentSink
)
;
}
nsCOMPtr
<
nsIContentSink
>
contentsink
=
do_QueryInterface
(
sXMLFragmentSink
)
;
MOZ_ASSERT
(
contentsink
"
Sink
doesn
'
t
QI
to
nsIContentSink
!
"
)
;
sXMLFragmentParser
-
>
SetContentSink
(
contentsink
)
;
sXMLFragmentSink
-
>
SetTargetDocument
(
aDocument
)
;
sXMLFragmentSink
-
>
SetPreventScriptExecution
(
aPreventScriptExecution
)
;
nsresult
rv
=
sXMLFragmentParser
-
>
ParseFragment
(
aSourceBuffer
aTagStack
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_IF_RELEASE
(
sXMLFragmentParser
)
;
NS_IF_RELEASE
(
sXMLFragmentSink
)
;
return
rv
;
}
rv
=
sXMLFragmentSink
-
>
FinishFragmentParsing
(
aReturn
)
;
sXMLFragmentParser
-
>
Reset
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
IsSystemPrincipal
(
aDocument
-
>
NodePrincipal
(
)
)
)
{
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
nsTreeSanitizer
sanitizer
(
nsIParserUtils
:
:
SanitizerAllowStyle
|
nsIParserUtils
:
:
SanitizerAllowComments
|
nsIParserUtils
:
:
SanitizerDropForms
|
nsIParserUtils
:
:
SanitizerLogRemovals
)
;
sanitizer
.
Sanitize
(
*
aReturn
)
;
}
return
rv
;
}
nsresult
nsContentUtils
:
:
ConvertToPlainText
(
const
nsAString
&
aSourceBuffer
nsAString
&
aResultBuffer
uint32_t
aFlags
uint32_t
aWrapCol
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
RefPtr
<
Document
>
document
;
nsresult
rv
=
NS_NewDOMDocument
(
getter_AddRefs
(
document
)
EmptyString
(
)
EmptyString
(
)
nullptr
uri
uri
principal
true
nullptr
DocumentFlavorHTML
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsContentUtils
:
:
ParseDocumentHTML
(
aSourceBuffer
document
!
(
aFlags
&
nsIDocumentEncoder
:
:
OutputNoScriptContent
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDocumentEncoder
>
encoder
=
do_createDocumentEncoder
(
"
text
/
plain
"
)
;
rv
=
encoder
-
>
Init
(
document
NS_LITERAL_STRING
(
"
text
/
plain
"
)
aFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
encoder
-
>
SetWrapColumn
(
aWrapCol
)
;
return
encoder
-
>
EncodeToString
(
aResultBuffer
)
;
}
nsresult
nsContentUtils
:
:
SetNodeTextContent
(
nsIContent
*
aContent
const
nsAString
&
aValue
bool
aTryReuse
)
{
nsCOMPtr
<
nsIContent
>
owningContent
;
mozAutoSubtreeModified
subtree
(
nullptr
nullptr
)
;
{
Document
*
doc
=
aContent
-
>
OwnerDoc
(
)
;
if
(
HasMutationListeners
(
doc
NS_EVENT_BITS_MUTATION_NODEREMOVED
)
)
{
subtree
.
UpdateTarget
(
doc
nullptr
)
;
owningContent
=
aContent
;
nsCOMPtr
<
nsINode
>
child
;
bool
skipFirst
=
aTryReuse
;
for
(
child
=
aContent
-
>
GetFirstChild
(
)
;
child
&
&
child
-
>
GetParentNode
(
)
=
=
aContent
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
skipFirst
&
&
child
-
>
IsText
(
)
)
{
skipFirst
=
false
;
continue
;
}
nsContentUtils
:
:
MaybeFireNodeRemoved
(
child
aContent
)
;
}
}
}
mozAutoDocUpdate
updateBatch
(
aContent
-
>
GetComposedDoc
(
)
true
)
;
nsAutoMutationBatch
mb
;
if
(
aTryReuse
&
&
!
aValue
.
IsEmpty
(
)
)
{
while
(
aContent
-
>
HasChildren
(
)
)
{
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
if
(
child
-
>
IsText
(
)
)
{
break
;
}
aContent
-
>
RemoveChildNode
(
child
true
)
;
}
if
(
aContent
-
>
HasChildren
(
)
)
{
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
nsresult
rv
=
child
-
>
AsText
(
)
-
>
SetText
(
aValue
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
while
(
nsIContent
*
nextChild
=
child
-
>
GetNextSibling
(
)
)
{
aContent
-
>
RemoveChildNode
(
nextChild
true
)
;
}
}
if
(
aContent
-
>
HasChildren
(
)
)
{
return
NS_OK
;
}
}
else
{
mb
.
Init
(
aContent
true
false
)
;
while
(
aContent
-
>
HasChildren
(
)
)
{
aContent
-
>
RemoveChildNode
(
aContent
-
>
GetFirstChild
(
)
true
)
;
}
}
mb
.
RemovalDone
(
)
;
if
(
aValue
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsTextNode
>
textContent
=
new
nsTextNode
(
aContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
)
;
textContent
-
>
SetText
(
aValue
true
)
;
nsresult
rv
=
aContent
-
>
AppendChildTo
(
textContent
true
)
;
mb
.
NodesAdded
(
)
;
return
rv
;
}
static
bool
AppendNodeTextContentsRecurse
(
nsINode
*
aNode
nsAString
&
aResult
const
fallible_t
&
aFallible
)
{
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
bool
ok
=
AppendNodeTextContentsRecurse
(
child
aResult
aFallible
)
;
if
(
!
ok
)
{
return
false
;
}
}
else
if
(
Text
*
text
=
child
-
>
GetAsText
(
)
)
{
bool
ok
=
text
-
>
AppendTextTo
(
aResult
aFallible
)
;
if
(
!
ok
)
{
return
false
;
}
}
}
return
true
;
}
bool
nsContentUtils
:
:
AppendNodeTextContent
(
nsINode
*
aNode
bool
aDeep
nsAString
&
aResult
const
fallible_t
&
aFallible
)
{
if
(
Text
*
text
=
aNode
-
>
GetAsText
(
)
)
{
return
text
-
>
AppendTextTo
(
aResult
aFallible
)
;
}
if
(
aDeep
)
{
return
AppendNodeTextContentsRecurse
(
aNode
aResult
aFallible
)
;
}
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
Text
*
text
=
child
-
>
GetAsText
(
)
)
{
bool
ok
=
text
-
>
AppendTextTo
(
aResult
fallible
)
;
if
(
!
ok
)
{
return
false
;
}
}
}
return
true
;
}
bool
nsContentUtils
:
:
HasNonEmptyTextContent
(
nsINode
*
aNode
TextContentDiscoverMode
aDiscoverMode
)
{
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsText
(
)
&
&
child
-
>
TextLength
(
)
>
0
)
{
return
true
;
}
if
(
aDiscoverMode
=
=
eRecurseIntoChildren
&
&
HasNonEmptyTextContent
(
child
aDiscoverMode
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsContentUtils
:
:
IsInSameAnonymousTree
(
const
nsINode
*
aNode
const
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aNode
"
Must
have
a
node
to
work
with
"
)
;
MOZ_ASSERT
(
aContent
"
Must
have
a
content
to
work
with
"
)
;
if
(
!
aNode
-
>
IsContent
(
)
)
{
return
aContent
-
>
GetBindingParent
(
)
=
=
nullptr
;
}
return
aNode
-
>
AsContent
(
)
-
>
GetBindingParent
(
)
=
=
aContent
-
>
GetBindingParent
(
)
;
}
void
nsContentUtils
:
:
NotifyInstalledMenuKeyboardListener
(
bool
aInstalling
)
{
IMEStateManager
:
:
OnInstalledMenuKeyboardListener
(
aInstalling
)
;
}
bool
nsContentUtils
:
:
SchemeIs
(
nsIURI
*
aURI
const
char
*
aScheme
)
{
nsCOMPtr
<
nsIURI
>
baseURI
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_TRUE
(
baseURI
false
)
;
bool
isScheme
=
false
;
return
NS_SUCCEEDED
(
baseURI
-
>
SchemeIs
(
aScheme
&
isScheme
)
)
&
&
isScheme
;
}
bool
nsContentUtils
:
:
IsSystemPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
return
aPrincipal
&
&
aPrincipal
-
>
IsSystemPrincipal
(
)
;
}
bool
nsContentUtils
:
:
IsExpandedPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
nsCOMPtr
<
nsIExpandedPrincipal
>
ep
=
do_QueryInterface
(
aPrincipal
)
;
return
!
!
ep
;
}
nsIPrincipal
*
nsContentUtils
:
:
GetSystemPrincipal
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
return
sSystemPrincipal
;
}
bool
nsContentUtils
:
:
CombineResourcePrincipals
(
nsCOMPtr
<
nsIPrincipal
>
*
aResourcePrincipal
nsIPrincipal
*
aExtraPrincipal
)
{
if
(
!
aExtraPrincipal
)
{
return
false
;
}
if
(
!
*
aResourcePrincipal
)
{
*
aResourcePrincipal
=
aExtraPrincipal
;
return
true
;
}
if
(
*
aResourcePrincipal
=
=
aExtraPrincipal
)
{
return
false
;
}
bool
subsumes
;
if
(
NS_SUCCEEDED
(
(
*
aResourcePrincipal
)
-
>
Subsumes
(
aExtraPrincipal
&
subsumes
)
)
&
&
subsumes
)
{
return
false
;
}
*
aResourcePrincipal
=
sSystemPrincipal
;
return
true
;
}
void
nsContentUtils
:
:
TriggerLink
(
nsIContent
*
aContent
nsPresContext
*
aPresContext
nsIURI
*
aLinkURI
const
nsString
&
aTargetSpec
bool
aClick
bool
aIsTrusted
)
{
NS_ASSERTION
(
aPresContext
"
Need
a
nsPresContext
"
)
;
MOZ_ASSERT
(
aLinkURI
"
No
link
URI
"
)
;
if
(
aContent
-
>
IsEditable
(
)
)
{
return
;
}
nsILinkHandler
*
handler
=
aPresContext
-
>
GetLinkHandler
(
)
;
if
(
!
handler
)
{
return
;
}
if
(
!
aClick
)
{
handler
-
>
OnOverLink
(
aContent
aLinkURI
aTargetSpec
)
;
return
;
}
nsresult
proceed
=
NS_OK
;
if
(
sSecurityManager
)
{
uint32_t
flag
=
static_cast
<
uint32_t
>
(
nsIScriptSecurityManager
:
:
STANDARD
)
;
proceed
=
sSecurityManager
-
>
CheckLoadURIWithPrincipal
(
aContent
-
>
NodePrincipal
(
)
aLinkURI
flag
)
;
}
if
(
NS_SUCCEEDED
(
proceed
)
)
{
nsAutoString
fileName
;
if
(
(
!
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
&
&
!
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
&
&
!
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
a
)
)
|
|
!
aContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
download
fileName
)
|
|
NS_FAILED
(
aContent
-
>
NodePrincipal
(
)
-
>
CheckMayLoad
(
aLinkURI
false
true
)
)
)
{
fileName
.
SetIsVoid
(
true
)
;
}
handler
-
>
OnLinkClick
(
aContent
aLinkURI
fileName
.
IsVoid
(
)
?
aTargetSpec
:
EmptyString
(
)
fileName
nullptr
nullptr
EventStateManager
:
:
IsHandlingUserInput
(
)
aIsTrusted
aContent
-
>
NodePrincipal
(
)
)
;
}
}
void
nsContentUtils
:
:
GetLinkLocation
(
Element
*
aElement
nsString
&
aLocationString
)
{
nsCOMPtr
<
nsIURI
>
hrefURI
=
aElement
-
>
GetHrefURI
(
)
;
if
(
hrefURI
)
{
nsAutoCString
specUTF8
;
nsresult
rv
=
hrefURI
-
>
GetSpec
(
specUTF8
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
CopyUTF8toUTF16
(
specUTF8
aLocationString
)
;
}
}
nsIWidget
*
nsContentUtils
:
:
GetTopLevelWidget
(
nsIWidget
*
aWidget
)
{
if
(
!
aWidget
)
return
nullptr
;
return
aWidget
-
>
GetTopLevelWidget
(
)
;
}
const
nsDependentString
nsContentUtils
:
:
GetLocalizedEllipsis
(
)
{
static
char16_t
sBuf
[
4
]
=
{
0
0
0
0
}
;
if
(
!
sBuf
[
0
]
)
{
nsAutoString
tmp
;
Preferences
:
:
GetLocalizedString
(
"
intl
.
ellipsis
"
tmp
)
;
uint32_t
len
=
std
:
:
min
(
uint32_t
(
tmp
.
Length
(
)
)
uint32_t
(
ArrayLength
(
sBuf
)
-
1
)
)
;
CopyUnicodeTo
(
tmp
0
sBuf
len
)
;
if
(
!
sBuf
[
0
]
)
sBuf
[
0
]
=
char16_t
(
0x2026
)
;
}
return
nsDependentString
(
sBuf
)
;
}
void
nsContentUtils
:
:
AddScriptBlocker
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sScriptBlockerCount
)
{
MOZ_ASSERT
(
sRunnersCountAtFirstBlocker
=
=
0
"
Should
not
already
have
a
count
"
)
;
sRunnersCountAtFirstBlocker
=
sBlockedScriptRunners
?
sBlockedScriptRunners
-
>
Length
(
)
:
0
;
}
+
+
sScriptBlockerCount
;
}
#
ifdef
DEBUG
static
bool
sRemovingScriptBlockers
=
false
;
#
endif
void
nsContentUtils
:
:
RemoveScriptBlocker
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
sRemovingScriptBlockers
)
;
NS_ASSERTION
(
sScriptBlockerCount
!
=
0
"
Negative
script
blockers
"
)
;
-
-
sScriptBlockerCount
;
if
(
sScriptBlockerCount
)
{
return
;
}
if
(
!
sBlockedScriptRunners
)
{
return
;
}
uint32_t
firstBlocker
=
sRunnersCountAtFirstBlocker
;
uint32_t
lastBlocker
=
sBlockedScriptRunners
-
>
Length
(
)
;
uint32_t
originalFirstBlocker
=
firstBlocker
;
uint32_t
blockersCount
=
lastBlocker
-
firstBlocker
;
sRunnersCountAtFirstBlocker
=
0
;
NS_ASSERTION
(
firstBlocker
<
=
lastBlocker
"
bad
sRunnersCountAtFirstBlocker
"
)
;
while
(
firstBlocker
<
lastBlocker
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
;
runnable
.
swap
(
(
*
sBlockedScriptRunners
)
[
firstBlocker
]
)
;
+
+
firstBlocker
;
runnable
-
>
Run
(
)
;
runnable
=
nullptr
;
NS_ASSERTION
(
sRunnersCountAtFirstBlocker
=
=
0
"
Bad
count
"
)
;
NS_ASSERTION
(
!
sScriptBlockerCount
"
This
is
really
bad
"
)
;
}
#
ifdef
DEBUG
AutoRestore
<
bool
>
removingScriptBlockers
(
sRemovingScriptBlockers
)
;
sRemovingScriptBlockers
=
true
;
#
endif
sBlockedScriptRunners
-
>
RemoveElementsAt
(
originalFirstBlocker
blockersCount
)
;
}
nsIWindowProvider
*
nsContentUtils
:
:
GetWindowProviderForContentProcess
(
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
return
ContentChild
:
:
GetSingleton
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
nsContentUtils
:
:
GetMostRecentNonPBWindow
(
)
{
nsCOMPtr
<
nsIWindowMediator
>
wm
=
do_GetService
(
NS_WINDOWMEDIATOR_CONTRACTID
)
;
nsCOMPtr
<
mozIDOMWindowProxy
>
window
;
wm
-
>
GetMostRecentNonPBWindow
(
u
"
navigator
:
browser
"
getter_AddRefs
(
window
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwindow
;
pwindow
=
do_QueryInterface
(
window
)
;
return
pwindow
.
forget
(
)
;
}
void
nsContentUtils
:
:
WarnScriptWasIgnored
(
Document
*
aDocument
)
{
nsAutoString
msg
;
bool
privateBrowsing
=
false
;
if
(
aDocument
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aDocument
-
>
GetDocumentURI
(
)
;
if
(
uri
)
{
msg
.
Append
(
NS_ConvertUTF8toUTF16
(
uri
-
>
GetSpecOrDefault
(
)
)
)
;
msg
.
AppendLiteral
(
"
:
"
)
;
}
privateBrowsing
=
!
!
aDocument
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
.
mPrivateBrowsingId
;
}
msg
.
AppendLiteral
(
"
Unable
to
run
script
because
scripts
are
blocked
internally
.
"
)
;
LogSimpleConsoleError
(
msg
"
DOM
"
privateBrowsing
)
;
}
void
nsContentUtils
:
:
AddScriptRunner
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
if
(
!
runnable
)
{
return
;
}
if
(
sScriptBlockerCount
)
{
sBlockedScriptRunners
-
>
AppendElement
(
runnable
.
forget
(
)
)
;
return
;
}
runnable
-
>
Run
(
)
;
}
void
nsContentUtils
:
:
AddScriptRunner
(
nsIRunnable
*
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
=
aRunnable
;
AddScriptRunner
(
runnable
.
forget
(
)
)
;
}
void
nsContentUtils
:
:
RunInStableState
(
already_AddRefed
<
nsIRunnable
>
aRunnable
)
{
MOZ_ASSERT
(
CycleCollectedJSContext
:
:
Get
(
)
"
Must
be
on
a
script
thread
!
"
)
;
CycleCollectedJSContext
:
:
Get
(
)
-
>
RunInStableState
(
std
:
:
move
(
aRunnable
)
)
;
}
void
nsContentUtils
:
:
AddPendingIDBTransaction
(
already_AddRefed
<
nsIRunnable
>
aTransaction
)
{
MOZ_ASSERT
(
CycleCollectedJSContext
:
:
Get
(
)
"
Must
be
on
a
script
thread
!
"
)
;
CycleCollectedJSContext
:
:
Get
(
)
-
>
AddPendingIDBTransaction
(
std
:
:
move
(
aTransaction
)
)
;
}
bool
nsContentUtils
:
:
IsInStableOrMetaStableState
(
)
{
MOZ_ASSERT
(
CycleCollectedJSContext
:
:
Get
(
)
"
Must
be
on
a
script
thread
!
"
)
;
return
CycleCollectedJSContext
:
:
Get
(
)
-
>
IsInStableOrMetaStableState
(
)
;
}
static
void
ProcessViewportToken
(
Document
*
aDocument
const
nsAString
&
token
)
{
nsAString
:
:
const_iterator
tip
tail
end
;
token
.
BeginReading
(
tip
)
;
tail
=
tip
;
token
.
EndReading
(
end
)
;
while
(
(
tip
!
=
end
)
&
&
(
*
tip
!
=
'
=
'
)
)
+
+
tip
;
if
(
tip
=
=
end
)
return
;
const
nsAString
&
key
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
Substring
(
tail
tip
)
true
)
;
const
nsAString
&
value
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
Substring
(
+
+
tip
end
)
true
)
;
RefPtr
<
nsAtom
>
key_atom
=
NS_Atomize
(
key
)
;
if
(
key_atom
=
=
nsGkAtoms
:
:
height
)
aDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
viewport_height
value
)
;
else
if
(
key_atom
=
=
nsGkAtoms
:
:
width
)
aDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
viewport_width
value
)
;
else
if
(
key_atom
=
=
nsGkAtoms
:
:
initial_scale
)
aDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
viewport_initial_scale
value
)
;
else
if
(
key_atom
=
=
nsGkAtoms
:
:
minimum_scale
)
aDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
viewport_minimum_scale
value
)
;
else
if
(
key_atom
=
=
nsGkAtoms
:
:
maximum_scale
)
aDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
viewport_maximum_scale
value
)
;
else
if
(
key_atom
=
=
nsGkAtoms
:
:
user_scalable
)
aDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
viewport_user_scalable
value
)
;
}
#
define
IS_SEPARATOR
(
c
)
\
(
(
c
=
=
'
=
'
)
|
|
(
c
=
=
'
'
)
|
|
(
c
=
=
'
;
'
)
|
|
(
c
=
=
'
\
t
'
)
|
|
(
c
=
=
'
\
n
'
)
|
|
\
(
c
=
=
'
\
r
'
)
)
nsresult
nsContentUtils
:
:
ProcessViewportInfo
(
Document
*
aDocument
const
nsAString
&
viewportInfo
)
{
nsresult
rv
=
NS_OK
;
aDocument
-
>
SetHeaderData
(
nsGkAtoms
:
:
viewport
viewportInfo
)
;
nsAString
:
:
const_iterator
tip
tail
end
;
viewportInfo
.
BeginReading
(
tip
)
;
tail
=
tip
;
viewportInfo
.
EndReading
(
end
)
;
while
(
(
tip
!
=
end
)
&
&
(
IS_SEPARATOR
(
*
tip
)
|
|
nsCRT
:
:
IsAsciiSpace
(
*
tip
)
)
)
+
+
tip
;
while
(
tip
!
=
end
)
{
tail
=
tip
;
while
(
(
tip
!
=
end
)
&
&
!
IS_SEPARATOR
(
*
tip
)
)
+
+
tip
;
if
(
(
tip
!
=
end
)
&
&
(
*
tip
=
=
'
=
'
)
)
{
+
+
tip
;
while
(
(
tip
!
=
end
)
&
&
nsCRT
:
:
IsAsciiSpace
(
*
tip
)
)
+
+
tip
;
while
(
(
tip
!
=
end
)
&
&
!
(
IS_SEPARATOR
(
*
tip
)
|
|
nsCRT
:
:
IsAsciiSpace
(
*
tip
)
)
)
+
+
tip
;
}
ProcessViewportToken
(
aDocument
Substring
(
tail
tip
)
)
;
while
(
(
tip
!
=
end
)
&
&
(
IS_SEPARATOR
(
*
tip
)
|
|
nsCRT
:
:
IsAsciiSpace
(
*
tip
)
)
)
+
+
tip
;
}
return
rv
;
}
#
undef
IS_SEPARATOR
void
nsContentUtils
:
:
HidePopupsInDocument
(
Document
*
aDocument
)
{
#
ifdef
MOZ_XUL
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
&
&
aDocument
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellToHide
=
aDocument
-
>
GetDocShell
(
)
;
if
(
docShellToHide
)
pm
-
>
HidePopupsInDocShell
(
docShellToHide
)
;
}
#
endif
}
already_AddRefed
<
nsIDragSession
>
nsContentUtils
:
:
GetDragSession
(
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
;
nsCOMPtr
<
nsIDragService
>
dragService
=
do_GetService
(
"
mozilla
.
org
/
widget
/
dragservice
;
1
"
)
;
if
(
dragService
)
dragService
-
>
GetCurrentSession
(
getter_AddRefs
(
dragSession
)
)
;
return
dragSession
.
forget
(
)
;
}
nsresult
nsContentUtils
:
:
SetDataTransferInEvent
(
WidgetDragEvent
*
aDragEvent
)
{
if
(
aDragEvent
-
>
mDataTransfer
|
|
!
aDragEvent
-
>
IsTrusted
(
)
)
{
return
NS_OK
;
}
NS_ASSERTION
(
aDragEvent
-
>
mMessage
!
=
eDragStart
"
draggesture
event
created
without
a
dataTransfer
"
)
;
nsCOMPtr
<
nsIDragSession
>
dragSession
=
GetDragSession
(
)
;
NS_ENSURE_TRUE
(
dragSession
NS_OK
)
;
RefPtr
<
DataTransfer
>
initialDataTransfer
=
dragSession
-
>
GetDataTransfer
(
)
;
if
(
!
initialDataTransfer
)
{
initialDataTransfer
=
new
DataTransfer
(
aDragEvent
-
>
mTarget
aDragEvent
-
>
mMessage
true
-
1
)
;
dragSession
-
>
SetDataTransfer
(
initialDataTransfer
)
;
}
bool
isCrossDomainSubFrameDrop
=
false
;
if
(
aDragEvent
-
>
mMessage
=
=
eDrop
)
{
isCrossDomainSubFrameDrop
=
CheckForSubFrameDrop
(
dragSession
aDragEvent
)
;
}
initialDataTransfer
-
>
Clone
(
aDragEvent
-
>
mTarget
aDragEvent
-
>
mMessage
aDragEvent
-
>
mUserCancelled
isCrossDomainSubFrameDrop
getter_AddRefs
(
aDragEvent
-
>
mDataTransfer
)
)
;
if
(
NS_WARN_IF
(
!
aDragEvent
-
>
mDataTransfer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
aDragEvent
-
>
mMessage
=
=
eDragEnter
|
|
aDragEvent
-
>
mMessage
=
=
eDragOver
)
{
uint32_t
action
;
dragSession
-
>
GetDragAction
(
&
action
)
;
uint32_t
effectAllowed
=
aDragEvent
-
>
mDataTransfer
-
>
EffectAllowedInt
(
)
;
aDragEvent
-
>
mDataTransfer
-
>
SetDropEffectInt
(
FilterDropEffect
(
action
effectAllowed
)
)
;
}
else
if
(
aDragEvent
-
>
mMessage
=
=
eDrop
|
|
aDragEvent
-
>
mMessage
=
=
eDragEnd
)
{
aDragEvent
-
>
mDataTransfer
-
>
SetDropEffectInt
(
initialDataTransfer
-
>
DropEffectInt
(
)
)
;
}
return
NS_OK
;
}
uint32_t
nsContentUtils
:
:
FilterDropEffect
(
uint32_t
aAction
uint32_t
aEffectAllowed
)
{
if
(
aAction
&
nsIDragService
:
:
DRAGDROP_ACTION_COPY
)
aAction
=
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
else
if
(
aAction
&
nsIDragService
:
:
DRAGDROP_ACTION_LINK
)
aAction
=
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
else
if
(
aAction
&
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
)
aAction
=
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
if
(
aAction
&
aEffectAllowed
|
|
aEffectAllowed
=
=
nsIDragService
:
:
DRAGDROP_ACTION_UNINITIALIZED
)
return
aAction
;
if
(
aEffectAllowed
&
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
)
return
nsIDragService
:
:
DRAGDROP_ACTION_MOVE
;
if
(
aEffectAllowed
&
nsIDragService
:
:
DRAGDROP_ACTION_COPY
)
return
nsIDragService
:
:
DRAGDROP_ACTION_COPY
;
if
(
aEffectAllowed
&
nsIDragService
:
:
DRAGDROP_ACTION_LINK
)
return
nsIDragService
:
:
DRAGDROP_ACTION_LINK
;
return
nsIDragService
:
:
DRAGDROP_ACTION_NONE
;
}
bool
nsContentUtils
:
:
CheckForSubFrameDrop
(
nsIDragSession
*
aDragSession
WidgetDragEvent
*
aDropEvent
)
{
nsCOMPtr
<
nsIContent
>
target
=
do_QueryInterface
(
aDropEvent
-
>
mOriginalTarget
)
;
if
(
!
target
)
{
return
true
;
}
Document
*
targetDoc
=
target
-
>
OwnerDoc
(
)
;
nsPIDOMWindowOuter
*
targetWin
=
targetDoc
-
>
GetWindow
(
)
;
if
(
!
targetWin
)
{
return
true
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
tdsti
=
targetWin
-
>
GetDocShell
(
)
;
if
(
!
tdsti
)
{
return
true
;
}
if
(
tdsti
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
false
;
}
RefPtr
<
Document
>
doc
;
aDragSession
-
>
GetSourceDocument
(
getter_AddRefs
(
doc
)
)
;
if
(
doc
)
{
do
{
doc
=
doc
-
>
GetParentDocument
(
)
;
if
(
doc
=
=
targetDoc
)
{
return
true
;
}
}
while
(
doc
)
;
}
return
false
;
}
bool
nsContentUtils
:
:
URIIsLocalFile
(
nsIURI
*
aURI
)
{
bool
isFile
;
nsCOMPtr
<
nsINetUtil
>
util
=
do_QueryInterface
(
sIOService
)
;
return
util
&
&
NS_SUCCEEDED
(
util
-
>
ProtocolHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_IS_LOCAL_FILE
&
isFile
)
)
&
&
isFile
;
}
JSContext
*
nsContentUtils
:
:
GetCurrentJSContext
(
)
{
MOZ_ASSERT
(
IsInitialized
(
)
)
;
if
(
!
IsJSAPIActive
(
)
)
{
return
nullptr
;
}
return
danger
:
:
GetJSContext
(
)
;
}
template
<
typename
StringType
typename
CharType
>
void
_ASCIIToLowerInSitu
(
StringType
&
aStr
)
{
CharType
*
iter
=
aStr
.
BeginWriting
(
)
;
CharType
*
end
=
aStr
.
EndWriting
(
)
;
MOZ_ASSERT
(
iter
&
&
end
)
;
while
(
iter
!
=
end
)
{
CharType
c
=
*
iter
;
if
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
{
*
iter
=
c
+
(
'
a
'
-
'
A
'
)
;
}
+
+
iter
;
}
}
void
nsContentUtils
:
:
ASCIIToLower
(
nsAString
&
aStr
)
{
return
_ASCIIToLowerInSitu
<
nsAString
char16_t
>
(
aStr
)
;
}
void
nsContentUtils
:
:
ASCIIToLower
(
nsACString
&
aStr
)
{
return
_ASCIIToLowerInSitu
<
nsACString
char
>
(
aStr
)
;
}
template
<
typename
StringType
typename
CharType
>
void
_ASCIIToLowerCopy
(
const
StringType
&
aSource
StringType
&
aDest
)
{
uint32_t
len
=
aSource
.
Length
(
)
;
aDest
.
SetLength
(
len
)
;
MOZ_ASSERT
(
aDest
.
Length
(
)
=
=
len
)
;
CharType
*
dest
=
aDest
.
BeginWriting
(
)
;
MOZ_ASSERT
(
dest
)
;
const
CharType
*
iter
=
aSource
.
BeginReading
(
)
;
const
CharType
*
end
=
aSource
.
EndReading
(
)
;
while
(
iter
!
=
end
)
{
CharType
c
=
*
iter
;
*
dest
=
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
?
c
+
(
'
a
'
-
'
A
'
)
:
c
;
+
+
iter
;
+
+
dest
;
}
}
void
nsContentUtils
:
:
ASCIIToLower
(
const
nsAString
&
aSource
nsAString
&
aDest
)
{
return
_ASCIIToLowerCopy
<
nsAString
char16_t
>
(
aSource
aDest
)
;
}
void
nsContentUtils
:
:
ASCIIToLower
(
const
nsACString
&
aSource
nsACString
&
aDest
)
{
return
_ASCIIToLowerCopy
<
nsACString
char
>
(
aSource
aDest
)
;
}
template
<
typename
StringType
typename
CharType
>
void
_ASCIIToUpperInSitu
(
StringType
&
aStr
)
{
CharType
*
iter
=
aStr
.
BeginWriting
(
)
;
CharType
*
end
=
aStr
.
EndWriting
(
)
;
MOZ_ASSERT
(
iter
&
&
end
)
;
while
(
iter
!
=
end
)
{
CharType
c
=
*
iter
;
if
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
{
*
iter
=
c
+
(
'
A
'
-
'
a
'
)
;
}
+
+
iter
;
}
}
void
nsContentUtils
:
:
ASCIIToUpper
(
nsAString
&
aStr
)
{
return
_ASCIIToUpperInSitu
<
nsAString
char16_t
>
(
aStr
)
;
}
void
nsContentUtils
:
:
ASCIIToUpper
(
nsACString
&
aStr
)
{
return
_ASCIIToUpperInSitu
<
nsACString
char
>
(
aStr
)
;
}
template
<
typename
StringType
typename
CharType
>
void
_ASCIIToUpperCopy
(
const
StringType
&
aSource
StringType
&
aDest
)
{
uint32_t
len
=
aSource
.
Length
(
)
;
aDest
.
SetLength
(
len
)
;
MOZ_ASSERT
(
aDest
.
Length
(
)
=
=
len
)
;
CharType
*
dest
=
aDest
.
BeginWriting
(
)
;
MOZ_ASSERT
(
dest
)
;
const
CharType
*
iter
=
aSource
.
BeginReading
(
)
;
const
CharType
*
end
=
aSource
.
EndReading
(
)
;
while
(
iter
!
=
end
)
{
CharType
c
=
*
iter
;
*
dest
=
(
c
>
=
'
a
'
&
&
c
<
=
'
z
'
)
?
c
+
(
'
A
'
-
'
a
'
)
:
c
;
+
+
iter
;
+
+
dest
;
}
}
void
nsContentUtils
:
:
ASCIIToUpper
(
const
nsAString
&
aSource
nsAString
&
aDest
)
{
return
_ASCIIToUpperCopy
<
nsAString
char16_t
>
(
aSource
aDest
)
;
}
void
nsContentUtils
:
:
ASCIIToUpper
(
const
nsACString
&
aSource
nsACString
&
aDest
)
{
return
_ASCIIToUpperCopy
<
nsACString
char
>
(
aSource
aDest
)
;
}
bool
nsContentUtils
:
:
EqualsIgnoreASCIICase
(
const
nsAString
&
aStr1
const
nsAString
&
aStr2
)
{
uint32_t
len
=
aStr1
.
Length
(
)
;
if
(
len
!
=
aStr2
.
Length
(
)
)
{
return
false
;
}
const
char16_t
*
str1
=
aStr1
.
BeginReading
(
)
;
const
char16_t
*
str2
=
aStr2
.
BeginReading
(
)
;
const
char16_t
*
end
=
str1
+
len
;
while
(
str1
<
end
)
{
char16_t
c1
=
*
str1
+
+
;
char16_t
c2
=
*
str2
+
+
;
if
(
(
c1
^
c2
)
&
0xffdf
)
{
return
false
;
}
if
(
c1
!
=
c2
)
{
char16_t
c1Upper
=
c1
&
0xffdf
;
if
(
!
(
'
A
'
<
=
c1Upper
&
&
c1Upper
<
=
'
Z
'
)
)
{
return
false
;
}
}
}
return
true
;
}
bool
nsContentUtils
:
:
StringContainsASCIIUpper
(
const
nsAString
&
aStr
)
{
const
char16_t
*
iter
=
aStr
.
BeginReading
(
)
;
const
char16_t
*
end
=
aStr
.
EndReading
(
)
;
while
(
iter
!
=
end
)
{
char16_t
c
=
*
iter
;
if
(
c
>
=
'
A
'
&
&
c
<
=
'
Z
'
)
{
return
true
;
}
+
+
iter
;
}
return
false
;
}
nsIInterfaceRequestor
*
nsContentUtils
:
:
SameOriginChecker
(
)
{
if
(
!
sSameOriginChecker
)
{
sSameOriginChecker
=
new
SameOriginCheckerImpl
(
)
;
NS_ADDREF
(
sSameOriginChecker
)
;
}
return
sSameOriginChecker
;
}
nsresult
nsContentUtils
:
:
CheckSameOrigin
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
)
{
if
(
!
nsContentUtils
:
:
GetSecurityManager
(
)
)
return
NS_ERROR_NOT_AVAILABLE
;
nsCOMPtr
<
nsIPrincipal
>
oldPrincipal
;
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
aOldChannel
getter_AddRefs
(
oldPrincipal
)
)
;
nsCOMPtr
<
nsIURI
>
newURI
;
aNewChannel
-
>
GetURI
(
getter_AddRefs
(
newURI
)
)
;
nsCOMPtr
<
nsIURI
>
newOriginalURI
;
aNewChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
newOriginalURI
)
)
;
NS_ENSURE_STATE
(
oldPrincipal
&
&
newURI
&
&
newOriginalURI
)
;
nsresult
rv
=
oldPrincipal
-
>
CheckMayLoad
(
newURI
false
false
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
newOriginalURI
!
=
newURI
)
{
rv
=
oldPrincipal
-
>
CheckMayLoad
(
newOriginalURI
false
false
)
;
}
return
rv
;
}
NS_IMPL_ISUPPORTS
(
SameOriginCheckerImpl
nsIChannelEventSink
nsIInterfaceRequestor
)
NS_IMETHODIMP
SameOriginCheckerImpl
:
:
AsyncOnChannelRedirect
(
nsIChannel
*
aOldChannel
nsIChannel
*
aNewChannel
uint32_t
aFlags
nsIAsyncVerifyRedirectCallback
*
cb
)
{
MOZ_ASSERT
(
aNewChannel
"
Redirecting
to
null
channel
?
"
)
;
nsresult
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
aOldChannel
aNewChannel
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
cb
-
>
OnRedirectVerifyCallback
(
NS_OK
)
;
}
return
rv
;
}
NS_IMETHODIMP
SameOriginCheckerImpl
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aResult
)
{
return
QueryInterface
(
aIID
aResult
)
;
}
nsresult
nsContentUtils
:
:
GetASCIIOrigin
(
nsIPrincipal
*
aPrincipal
nsACString
&
aOrigin
)
{
MOZ_ASSERT
(
aPrincipal
"
missing
principal
"
)
;
aOrigin
.
Truncate
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
uri
)
{
return
GetASCIIOrigin
(
uri
aOrigin
)
;
}
aOrigin
.
AssignLiteral
(
"
null
"
)
;
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
GetASCIIOrigin
(
nsIURI
*
aURI
nsACString
&
aOrigin
)
{
MOZ_ASSERT
(
aURI
"
missing
uri
"
)
;
bool
isBlobURL
=
false
;
nsresult
rv
=
aURI
-
>
SchemeIs
(
BLOBURI_SCHEME
&
isBlobURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isBlobURL
)
{
nsAutoCString
path
;
rv
=
aURI
-
>
GetPathQueryRef
(
path
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
aOrigin
.
AssignLiteral
(
"
null
"
)
;
return
NS_OK
;
}
return
GetASCIIOrigin
(
uri
aOrigin
)
;
}
aOrigin
.
Truncate
(
)
;
nsCOMPtr
<
nsIURI
>
uri
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_TRUE
(
uri
NS_ERROR_UNEXPECTED
)
;
nsAutoCString
host
;
rv
=
uri
-
>
GetAsciiHost
(
host
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
host
.
IsEmpty
(
)
)
{
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
port
=
-
1
;
uri
-
>
GetPort
(
&
port
)
;
if
(
port
!
=
-
1
&
&
port
=
=
NS_GetDefaultPort
(
scheme
.
get
(
)
)
)
port
=
-
1
;
nsAutoCString
hostPort
;
rv
=
NS_GenerateHostPort
(
host
port
hostPort
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aOrigin
=
scheme
+
NS_LITERAL_CSTRING
(
"
:
/
/
"
)
+
hostPort
;
}
else
{
aOrigin
.
AssignLiteral
(
"
null
"
)
;
}
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
GetUTFOrigin
(
nsIPrincipal
*
aPrincipal
nsAString
&
aOrigin
)
{
MOZ_ASSERT
(
aPrincipal
"
missing
principal
"
)
;
aOrigin
.
Truncate
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
uri
)
{
return
GetUTFOrigin
(
uri
aOrigin
)
;
}
aOrigin
.
AssignLiteral
(
"
null
"
)
;
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
GetUTFOrigin
(
nsIURI
*
aURI
nsAString
&
aOrigin
)
{
MOZ_ASSERT
(
aURI
"
missing
uri
"
)
;
nsresult
rv
;
#
if
defined
(
MOZ_THUNDERBIRD
)
|
|
defined
(
MOZ_SUITE
)
nsCOMPtr
<
nsIURIWithSpecialOrigin
>
uriWithSpecialOrigin
=
do_QueryInterface
(
aURI
)
;
if
(
uriWithSpecialOrigin
)
{
nsCOMPtr
<
nsIURI
>
origin
;
rv
=
uriWithSpecialOrigin
-
>
GetOrigin
(
getter_AddRefs
(
origin
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
GetUTFOrigin
(
origin
aOrigin
)
;
}
#
endif
bool
isBlobURL
=
false
;
rv
=
aURI
-
>
SchemeIs
(
BLOBURI_SCHEME
&
isBlobURL
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
isBlobURL
)
{
nsAutoCString
path
;
rv
=
aURI
-
>
GetPathQueryRef
(
path
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
path
)
;
if
(
NS_FAILED
(
rv
)
)
{
aOrigin
.
AssignLiteral
(
"
null
"
)
;
return
NS_OK
;
}
return
GetUTFOrigin
(
uri
aOrigin
)
;
}
aOrigin
.
Truncate
(
)
;
nsCOMPtr
<
nsIURI
>
uri
=
NS_GetInnermostURI
(
aURI
)
;
NS_ENSURE_TRUE
(
uri
NS_ERROR_UNEXPECTED
)
;
nsAutoCString
host
;
rv
=
uri
-
>
GetHost
(
host
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
host
.
IsEmpty
(
)
)
{
nsAutoCString
scheme
;
rv
=
uri
-
>
GetScheme
(
scheme
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
port
=
-
1
;
uri
-
>
GetPort
(
&
port
)
;
if
(
port
!
=
-
1
&
&
port
=
=
NS_GetDefaultPort
(
scheme
.
get
(
)
)
)
port
=
-
1
;
nsAutoCString
hostPort
;
rv
=
NS_GenerateHostPort
(
host
port
hostPort
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aOrigin
=
NS_ConvertUTF8toUTF16
(
scheme
+
NS_LITERAL_CSTRING
(
"
:
/
/
"
)
+
hostPort
)
;
}
else
{
aOrigin
.
AssignLiteral
(
"
null
"
)
;
}
return
NS_OK
;
}
bool
nsContentUtils
:
:
CheckMayLoad
(
nsIPrincipal
*
aPrincipal
nsIChannel
*
aChannel
bool
aAllowIfInheritsPrincipal
)
{
nsCOMPtr
<
nsIURI
>
channelURI
;
nsresult
rv
=
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
channelURI
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
NS_SUCCEEDED
(
aPrincipal
-
>
CheckMayLoad
(
channelURI
false
aAllowIfInheritsPrincipal
)
)
;
}
bool
nsContentUtils
:
:
CanAccessNativeAnon
(
)
{
return
LegacyIsCallerChromeOrNativeCode
(
)
|
|
IsCallerContentXBL
(
)
;
}
nsresult
nsContentUtils
:
:
DispatchXULCommand
(
nsIContent
*
aTarget
bool
aTrusted
Event
*
aSourceEvent
nsIPresShell
*
aShell
bool
aCtrl
bool
aAlt
bool
aShift
bool
aMeta
uint16_t
aInputSource
)
{
NS_ENSURE_STATE
(
aTarget
)
;
Document
*
doc
=
aTarget
-
>
OwnerDoc
(
)
;
nsPresContext
*
presContext
=
doc
-
>
GetPresContext
(
)
;
RefPtr
<
XULCommandEvent
>
xulCommand
=
new
XULCommandEvent
(
doc
presContext
nullptr
)
;
xulCommand
-
>
InitCommandEvent
(
NS_LITERAL_STRING
(
"
command
"
)
true
true
nsGlobalWindowInner
:
:
Cast
(
doc
-
>
GetInnerWindow
(
)
)
0
aCtrl
aAlt
aShift
aMeta
aSourceEvent
aInputSource
IgnoreErrors
(
)
)
;
if
(
aShell
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsCOMPtr
<
nsIPresShell
>
kungFuDeathGrip
=
aShell
;
return
aShell
-
>
HandleDOMEventWithTarget
(
aTarget
xulCommand
&
status
)
;
}
ErrorResult
rv
;
aTarget
-
>
DispatchEvent
(
*
xulCommand
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
nsresult
nsContentUtils
:
:
WrapNative
(
JSContext
*
cx
nsISupports
*
native
nsWrapperCache
*
cache
const
nsIID
*
aIID
JS
:
:
MutableHandle
<
JS
:
:
Value
>
vp
bool
aAllowWrapping
)
{
MOZ_ASSERT
(
cx
=
=
GetCurrentJSContext
(
)
)
;
if
(
!
native
)
{
vp
.
setNull
(
)
;
return
NS_OK
;
}
JSObject
*
wrapper
=
xpc_FastGetCachedWrapper
(
cx
cache
vp
)
;
if
(
wrapper
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
sXPConnect
NS_ERROR_UNEXPECTED
)
;
if
(
!
NS_IsMainThread
(
)
)
{
MOZ_CRASH
(
)
;
}
JS
:
:
Rooted
<
JSObject
*
>
scope
(
cx
JS
:
:
CurrentGlobalOrNull
(
cx
)
)
;
nsresult
rv
=
sXPConnect
-
>
WrapNativeToJSVal
(
cx
scope
native
cache
aIID
aAllowWrapping
vp
)
;
return
rv
;
}
nsresult
nsContentUtils
:
:
CreateArrayBuffer
(
JSContext
*
aCx
const
nsACString
&
aData
JSObject
*
*
aResult
)
{
if
(
!
aCx
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
dataLen
=
aData
.
Length
(
)
;
*
aResult
=
JS_NewArrayBuffer
(
aCx
dataLen
)
;
if
(
!
*
aResult
)
{
return
NS_ERROR_FAILURE
;
}
if
(
dataLen
>
0
)
{
NS_ASSERTION
(
JS_IsArrayBufferObject
(
*
aResult
)
"
What
happened
?
"
)
;
JS
:
:
AutoCheckCannotGC
nogc
;
bool
isShared
;
memcpy
(
JS_GetArrayBufferData
(
*
aResult
&
isShared
nogc
)
aData
.
BeginReading
(
)
dataLen
)
;
MOZ_ASSERT
(
!
isShared
)
;
}
return
NS_OK
;
}
void
nsContentUtils
:
:
StripNullChars
(
const
nsAString
&
aInStr
nsAString
&
aOutStr
)
{
int32_t
firstNullPos
=
aInStr
.
FindChar
(
'
\
0
'
)
;
if
(
firstNullPos
=
=
kNotFound
)
{
aOutStr
.
Assign
(
aInStr
)
;
return
;
}
aOutStr
.
SetCapacity
(
aInStr
.
Length
(
)
-
1
)
;
nsAString
:
:
const_iterator
start
end
;
aInStr
.
BeginReading
(
start
)
;
aInStr
.
EndReading
(
end
)
;
while
(
start
!
=
end
)
{
if
(
*
start
!
=
'
\
0
'
)
aOutStr
.
Append
(
*
start
)
;
+
+
start
;
}
}
struct
ClassMatchingInfo
{
AtomArray
mClasses
;
nsCaseTreatment
mCaseTreatment
;
}
;
bool
nsContentUtils
:
:
MatchClassNames
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
const
nsAttrValue
*
classAttr
=
aElement
-
>
GetClasses
(
)
;
if
(
!
classAttr
)
{
return
false
;
}
ClassMatchingInfo
*
info
=
static_cast
<
ClassMatchingInfo
*
>
(
aData
)
;
uint32_t
length
=
info
-
>
mClasses
.
Length
(
)
;
if
(
!
length
)
{
return
false
;
}
uint32_t
i
;
for
(
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
!
classAttr
-
>
Contains
(
info
-
>
mClasses
[
i
]
info
-
>
mCaseTreatment
)
)
{
return
false
;
}
}
return
true
;
}
void
nsContentUtils
:
:
DestroyClassNameArray
(
void
*
aData
)
{
ClassMatchingInfo
*
info
=
static_cast
<
ClassMatchingInfo
*
>
(
aData
)
;
delete
info
;
}
void
*
nsContentUtils
:
:
AllocClassMatchingInfo
(
nsINode
*
aRootNode
const
nsString
*
aClasses
)
{
nsAttrValue
attrValue
;
attrValue
.
ParseAtomArray
(
*
aClasses
)
;
auto
*
info
=
new
ClassMatchingInfo
;
if
(
attrValue
.
Type
(
)
=
=
nsAttrValue
:
:
eAtomArray
)
{
info
-
>
mClasses
.
SwapElements
(
*
(
attrValue
.
GetAtomArrayValue
(
)
)
)
;
}
else
if
(
attrValue
.
Type
(
)
=
=
nsAttrValue
:
:
eAtom
)
{
info
-
>
mClasses
.
AppendElement
(
attrValue
.
GetAtomValue
(
)
)
;
}
info
-
>
mCaseTreatment
=
aRootNode
-
>
OwnerDoc
(
)
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
?
eIgnoreCase
:
eCaseMatters
;
return
info
;
}
bool
nsContentUtils
:
:
IsFocusedContent
(
const
nsIContent
*
aContent
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
return
fm
&
&
fm
-
>
GetFocusedElement
(
)
=
=
aContent
;
}
bool
nsContentUtils
:
:
IsSubDocumentTabbable
(
nsIContent
*
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
if
(
EventStateManager
:
:
IsRemoteTarget
(
aContent
)
)
{
return
true
;
}
Document
*
subDoc
=
doc
-
>
GetSubDocumentFor
(
aContent
)
;
if
(
!
subDoc
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
subDoc
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
nsCOMPtr
<
nsIContentViewer
>
contentViewer
;
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
contentViewer
)
)
;
if
(
!
contentViewer
)
{
return
false
;
}
if
(
contentViewer
-
>
GetPreviousViewer
(
)
)
{
bool
inOnLoad
=
false
;
docShell
-
>
GetIsExecutingOnLoadHandler
(
&
inOnLoad
)
;
return
inOnLoad
;
}
return
true
;
}
bool
nsContentUtils
:
:
IsUserFocusIgnored
(
nsINode
*
aNode
)
{
if
(
!
nsGenericHTMLFrameElement
:
:
BrowserFramesEnabled
(
)
)
{
return
false
;
}
while
(
aNode
)
{
nsCOMPtr
<
nsIMozBrowserFrame
>
browserFrame
=
do_QueryInterface
(
aNode
)
;
if
(
browserFrame
&
&
aNode
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
ignoreuserfocus
)
&
&
browserFrame
-
>
GetReallyIsBrowser
(
)
)
{
return
true
;
}
nsPIDOMWindowOuter
*
win
=
aNode
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
;
aNode
=
win
?
win
-
>
GetFrameElementInternal
(
)
:
nullptr
;
}
return
false
;
}
bool
nsContentUtils
:
:
HasScrollgrab
(
nsIContent
*
aContent
)
{
return
false
;
}
void
nsContentUtils
:
:
FlushLayoutForTree
(
nsPIDOMWindowOuter
*
aWindow
)
{
if
(
!
aWindow
)
{
return
;
}
if
(
RefPtr
<
Document
>
doc
=
aWindow
-
>
GetDoc
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
)
{
int32_t
i
=
0
i_end
;
docShell
-
>
GetChildCount
(
&
i_end
)
;
for
(
;
i
<
i_end
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
if
(
docShell
-
>
GetChildAt
(
i
getter_AddRefs
(
item
)
)
=
=
NS_OK
&
&
item
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
item
-
>
GetWindow
(
)
)
{
FlushLayoutForTree
(
win
)
;
}
}
}
}
}
void
nsContentUtils
:
:
RemoveNewlines
(
nsString
&
aString
)
{
aString
.
StripCRLF
(
)
;
}
void
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
nsString
&
aString
)
{
if
(
!
PlatformToDOMLineBreaks
(
aString
fallible
)
)
{
aString
.
AllocFailed
(
aString
.
Length
(
)
)
;
}
}
bool
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
nsString
&
aString
const
fallible_t
&
aFallible
)
{
if
(
aString
.
FindChar
(
char16_t
(
'
\
r
'
)
)
!
=
-
1
)
{
if
(
!
aString
.
ReplaceSubstring
(
u
"
\
r
\
n
"
u
"
\
n
"
aFallible
)
)
{
return
false
;
}
if
(
!
aString
.
ReplaceSubstring
(
u
"
\
r
"
u
"
\
n
"
aFallible
)
)
{
return
false
;
}
}
return
true
;
}
void
nsContentUtils
:
:
PopulateStringFromStringBuffer
(
nsStringBuffer
*
aBuf
nsAString
&
aResultString
)
{
MOZ_ASSERT
(
aBuf
"
Expecting
a
non
-
null
string
buffer
"
)
;
uint32_t
stringLen
=
NS_strlen
(
static_cast
<
char16_t
*
>
(
aBuf
-
>
Data
(
)
)
)
;
uint32_t
allocStringLen
=
(
aBuf
-
>
StorageSize
(
)
/
sizeof
(
char16_t
)
)
-
1
;
MOZ_ASSERT
(
stringLen
<
=
allocStringLen
"
string
buffer
lacks
null
terminator
!
"
)
;
stringLen
=
std
:
:
min
(
stringLen
allocStringLen
)
;
aBuf
-
>
ToString
(
stringLen
aResultString
)
;
}
nsIPresShell
*
nsContentUtils
:
:
FindPresShellForDocument
(
const
Document
*
aDoc
)
{
const
Document
*
doc
=
aDoc
;
Document
*
displayDoc
=
doc
-
>
GetDisplayDocument
(
)
;
if
(
displayDoc
)
{
doc
=
displayDoc
;
}
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
;
if
(
shell
)
{
return
shell
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellTreeItem
=
doc
-
>
GetDocShell
(
)
;
while
(
docShellTreeItem
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
docShellTreeItem
)
;
nsIPresShell
*
presShell
=
docShell
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
return
presShell
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
docShellTreeItem
-
>
GetParent
(
getter_AddRefs
(
parent
)
)
;
docShellTreeItem
=
parent
;
}
return
nullptr
;
}
nsIWidget
*
nsContentUtils
:
:
WidgetForDocument
(
const
Document
*
aDoc
)
{
nsIPresShell
*
shell
=
FindPresShellForDocument
(
aDoc
)
;
if
(
shell
)
{
nsViewManager
*
VM
=
shell
-
>
GetViewManager
(
)
;
if
(
VM
)
{
nsView
*
rootView
=
VM
-
>
GetRootView
(
)
;
if
(
rootView
)
{
nsView
*
displayRoot
=
nsViewManager
:
:
GetDisplayRootFor
(
rootView
)
;
if
(
displayRoot
)
{
return
displayRoot
-
>
GetNearestWidget
(
nullptr
)
;
}
}
}
}
return
nullptr
;
}
nsIWidget
*
nsContentUtils
:
:
WidgetForContent
(
const
nsIContent
*
aContent
)
{
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
frame
)
;
nsView
*
view
=
frame
-
>
GetView
(
)
;
if
(
view
)
{
return
view
-
>
GetWidget
(
)
;
}
}
return
nullptr
;
}
already_AddRefed
<
LayerManager
>
nsContentUtils
:
:
LayerManagerForContent
(
const
nsIContent
*
aContent
)
{
nsIWidget
*
widget
=
nsContentUtils
:
:
WidgetForContent
(
aContent
)
;
if
(
widget
)
{
RefPtr
<
LayerManager
>
manager
=
widget
-
>
GetLayerManager
(
)
;
return
manager
.
forget
(
)
;
}
return
nullptr
;
}
static
already_AddRefed
<
LayerManager
>
LayerManagerForDocumentInternal
(
const
Document
*
aDoc
bool
aRequirePersistent
)
{
nsIWidget
*
widget
=
nsContentUtils
:
:
WidgetForDocument
(
aDoc
)
;
if
(
widget
)
{
RefPtr
<
LayerManager
>
manager
=
widget
-
>
GetLayerManager
(
aRequirePersistent
?
nsIWidget
:
:
LAYER_MANAGER_PERSISTENT
:
nsIWidget
:
:
LAYER_MANAGER_CURRENT
)
;
return
manager
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
LayerManager
>
nsContentUtils
:
:
LayerManagerForDocument
(
const
Document
*
aDoc
)
{
return
LayerManagerForDocumentInternal
(
aDoc
false
)
;
}
already_AddRefed
<
LayerManager
>
nsContentUtils
:
:
PersistentLayerManagerForDocument
(
Document
*
aDoc
)
{
return
LayerManagerForDocumentInternal
(
aDoc
true
)
;
}
bool
nsContentUtils
:
:
AllowXULXBLForPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
aPrincipal
)
{
return
false
;
}
if
(
aPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
princURI
;
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
princURI
)
)
;
return
princURI
&
&
(
(
sAllowXULXBL_for_file
&
&
SchemeIs
(
princURI
"
file
"
)
)
|
|
IsSitePermAllow
(
aPrincipal
"
allowXULXBL
"
)
)
;
}
bool
nsContentUtils
:
:
IsPDFJSEnabled
(
)
{
nsCOMPtr
<
nsIStreamConverter
>
conv
=
do_CreateInstance
(
"
mozilla
.
org
/
streamconv
;
1
?
from
=
application
/
pdf
&
to
=
text
/
html
"
)
;
return
conv
;
}
already_AddRefed
<
nsIDocumentLoaderFactory
>
nsContentUtils
:
:
FindInternalContentViewer
(
const
nsACString
&
aType
ContentViewerType
*
aLoaderType
)
{
if
(
aLoaderType
)
{
*
aLoaderType
=
TYPE_UNSUPPORTED
;
}
nsCOMPtr
<
nsICategoryManager
>
catMan
(
do_GetService
(
NS_CATEGORYMANAGER_CONTRACTID
)
)
;
if
(
!
catMan
)
return
nullptr
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docFactory
;
nsCString
contractID
;
nsresult
rv
=
catMan
-
>
GetCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
aType
contractID
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
docFactory
=
do_GetService
(
contractID
.
get
(
)
)
;
if
(
docFactory
&
&
aLoaderType
)
{
if
(
contractID
.
EqualsLiteral
(
CONTENT_DLF_CONTRACTID
)
)
*
aLoaderType
=
TYPE_CONTENT
;
else
if
(
contractID
.
EqualsLiteral
(
PLUGIN_DLF_CONTRACTID
)
)
*
aLoaderType
=
TYPE_PLUGIN
;
else
*
aLoaderType
=
TYPE_UNKNOWN
;
}
return
docFactory
.
forget
(
)
;
}
if
(
DecoderTraits
:
:
IsSupportedInVideoDocument
(
aType
)
)
{
docFactory
=
do_GetService
(
"
mozilla
.
org
/
content
/
document
-
loader
-
factory
;
1
"
)
;
if
(
docFactory
&
&
aLoaderType
)
{
*
aLoaderType
=
TYPE_CONTENT
;
}
return
docFactory
.
forget
(
)
;
}
return
nullptr
;
}
static
void
ReportPatternCompileFailure
(
nsAString
&
aPattern
Document
*
aDocument
JSContext
*
cx
)
{
MOZ_ASSERT
(
JS_IsExceptionPending
(
cx
)
)
;
JS
:
:
RootedValue
exn
(
cx
)
;
if
(
!
JS_GetPendingException
(
cx
&
exn
)
)
{
return
;
}
if
(
!
exn
.
isObject
(
)
)
{
return
;
}
JS
:
:
AutoSaveExceptionState
savedExc
(
cx
)
;
JS
:
:
RootedObject
exnObj
(
cx
&
exn
.
toObject
(
)
)
;
JS
:
:
RootedValue
messageVal
(
cx
)
;
if
(
!
JS_GetProperty
(
cx
exnObj
"
message
"
&
messageVal
)
)
{
return
;
}
MOZ_ASSERT
(
messageVal
.
isString
(
)
)
;
JS
:
:
RootedString
messageStr
(
cx
messageVal
.
toString
(
)
)
;
MOZ_ASSERT
(
messageStr
)
;
nsAutoString
wideMessage
;
if
(
!
AssignJSString
(
cx
wideMessage
messageStr
)
)
{
return
;
}
const
nsString
&
pattern
=
PromiseFlatString
(
aPattern
)
;
const
char16_t
*
strings
[
]
=
{
pattern
.
get
(
)
wideMessage
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
DOM
"
)
aDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
PatternAttributeCompileFailure
"
strings
ArrayLength
(
strings
)
)
;
savedExc
.
drop
(
)
;
}
bool
nsContentUtils
:
:
IsPatternMatching
(
nsAString
&
aValue
nsAString
&
aPattern
Document
*
aDocument
)
{
NS_ASSERTION
(
aDocument
"
aDocument
should
be
a
valid
pointer
(
not
null
)
"
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
AutoDisableJSInterruptCallback
disabler
(
cx
)
;
JSAutoRealm
ar
(
cx
xpc
:
:
UnprivilegedJunkScope
(
)
)
;
aPattern
.
InsertLiteral
(
u
"
^
(
?
:
"
0
)
;
aPattern
.
AppendLiteral
(
"
)
"
)
;
JS
:
:
Rooted
<
JSObject
*
>
re
(
cx
JS_NewUCRegExpObject
(
cx
static_cast
<
char16_t
*
>
(
aPattern
.
BeginWriting
(
)
)
aPattern
.
Length
(
)
JSREG_UNICODE
)
)
;
if
(
!
re
)
{
aPattern
.
Cut
(
0
4
)
;
aPattern
.
Cut
(
aPattern
.
Length
(
)
-
2
2
)
;
ReportPatternCompileFailure
(
aPattern
aDocument
cx
)
;
return
true
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
rval
(
cx
JS
:
:
NullValue
(
)
)
;
size_t
idx
=
0
;
if
(
!
JS_ExecuteRegExpNoStatics
(
cx
re
static_cast
<
char16_t
*
>
(
aValue
.
BeginWriting
(
)
)
aValue
.
Length
(
)
&
idx
true
&
rval
)
)
{
return
true
;
}
return
!
rval
.
isNull
(
)
;
}
nsresult
nsContentUtils
:
:
URIInheritsSecurityContext
(
nsIURI
*
aURI
bool
*
aResult
)
{
return
NS_URIChainHasFlags
(
aURI
nsIProtocolHandler
:
:
URI_INHERITS_SECURITY_CONTEXT
aResult
)
;
}
bool
nsContentUtils
:
:
ChannelShouldInheritPrincipal
(
nsIPrincipal
*
aLoadingPrincipal
nsIURI
*
aURI
bool
aInheritForAboutBlank
bool
aForceInherit
)
{
MOZ_ASSERT
(
aLoadingPrincipal
"
Can
not
check
inheritance
without
a
principal
"
)
;
bool
inherit
=
aForceInherit
;
if
(
!
inherit
)
{
bool
uriInherits
;
inherit
=
(
NS_SUCCEEDED
(
URIInheritsSecurityContext
(
aURI
&
uriInherits
)
)
&
&
(
uriInherits
|
|
(
aInheritForAboutBlank
&
&
NS_IsAboutBlank
(
aURI
)
)
)
)
|
|
(
URIIsLocalFile
(
aURI
)
&
&
NS_SUCCEEDED
(
aLoadingPrincipal
-
>
CheckMayLoad
(
aURI
false
false
)
)
&
&
!
aLoadingPrincipal
-
>
IsSystemPrincipal
(
)
)
;
}
return
inherit
;
}
bool
nsContentUtils
:
:
IsFullscreenApiEnabled
(
)
{
return
sIsFullscreenApiEnabled
;
}
bool
nsContentUtils
:
:
IsRequestFullscreenAllowed
(
CallerType
aCallerType
)
{
if
(
!
sTrustedFullscreenOnly
|
|
aCallerType
=
=
CallerType
:
:
System
)
{
return
true
;
}
if
(
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
TimeDuration
timeout
=
HandlingUserInputTimeout
(
)
;
return
timeout
<
=
TimeDuration
(
nullptr
)
|
|
(
TimeStamp
:
:
Now
(
)
-
EventStateManager
:
:
GetHandlingInputStart
(
)
)
<
=
timeout
;
}
return
false
;
}
bool
nsContentUtils
:
:
IsCutCopyAllowed
(
nsIPrincipal
*
aSubjectPrincipal
)
{
if
(
!
IsCutCopyRestricted
(
)
&
&
EventStateManager
:
:
IsHandlingUserInput
(
)
)
{
return
true
;
}
return
PrincipalHasPermission
(
aSubjectPrincipal
nsGkAtoms
:
:
clipboardWrite
)
;
}
bool
nsContentUtils
:
:
IsFrameTimingEnabled
(
)
{
return
sIsFrameTimingPrefEnabled
;
}
bool
nsContentUtils
:
:
HaveEqualPrincipals
(
Document
*
aDoc1
Document
*
aDoc2
)
{
if
(
!
aDoc1
|
|
!
aDoc2
)
{
return
false
;
}
bool
principalsEqual
=
false
;
aDoc1
-
>
NodePrincipal
(
)
-
>
Equals
(
aDoc2
-
>
NodePrincipal
(
)
&
principalsEqual
)
;
return
principalsEqual
;
}
bool
nsContentUtils
:
:
HasPluginWithUncontrolledEventDispatch
(
nsIContent
*
aContent
)
{
#
ifdef
XP_MACOSX
return
false
;
#
else
if
(
!
aContent
|
|
!
aContent
-
>
IsInComposedDoc
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIObjectLoadingContent
>
olc
=
do_QueryInterface
(
aContent
)
;
if
(
!
olc
)
{
return
false
;
}
RefPtr
<
nsNPAPIPluginInstance
>
plugin
=
olc
-
>
GetPluginInstance
(
)
;
if
(
!
plugin
)
{
return
false
;
}
bool
isWindowless
=
false
;
nsresult
res
=
plugin
-
>
IsWindowless
(
&
isWindowless
)
;
if
(
NS_FAILED
(
res
)
)
{
return
false
;
}
return
!
isWindowless
;
#
endif
}
void
nsContentUtils
:
:
FireMutationEventsForDirectParsing
(
Document
*
aDoc
nsIContent
*
aDest
int32_t
aOldChildCount
)
{
int32_t
newChildCount
=
aDest
-
>
GetChildCount
(
)
;
if
(
newChildCount
&
&
nsContentUtils
:
:
HasMutationListeners
(
aDoc
NS_EVENT_BITS_MUTATION_NODEINSERTED
)
)
{
AutoTArray
<
nsCOMPtr
<
nsIContent
>
50
>
childNodes
;
NS_ASSERTION
(
newChildCount
-
aOldChildCount
>
=
0
"
What
some
unexpected
dom
mutation
has
happened
?
"
)
;
childNodes
.
SetCapacity
(
newChildCount
-
aOldChildCount
)
;
for
(
nsIContent
*
child
=
aDest
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
childNodes
.
AppendElement
(
child
)
;
}
FragmentOrElement
:
:
FireNodeInserted
(
aDoc
aDest
childNodes
)
;
}
}
Document
*
nsContentUtils
:
:
GetRootDocument
(
Document
*
aDoc
)
{
if
(
!
aDoc
)
{
return
nullptr
;
}
Document
*
doc
=
aDoc
;
while
(
doc
-
>
GetParentDocument
(
)
)
{
doc
=
doc
-
>
GetParentDocument
(
)
;
}
return
doc
;
}
bool
nsContentUtils
:
:
IsInPointerLockContext
(
nsPIDOMWindowOuter
*
aWin
)
{
if
(
!
aWin
)
{
return
false
;
}
nsCOMPtr
<
Document
>
pointerLockedDoc
=
do_QueryReferent
(
EventStateManager
:
:
sPointerLockedDoc
)
;
if
(
!
pointerLockedDoc
|
|
!
pointerLockedDoc
-
>
GetWindow
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
lockTop
=
pointerLockedDoc
-
>
GetWindow
(
)
-
>
GetScriptableTop
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
aWin
-
>
GetScriptableTop
(
)
;
return
top
=
=
lockTop
;
}
int32_t
nsContentUtils
:
:
GetAdjustedOffsetInTextControl
(
nsIFrame
*
aOffsetFrame
int32_t
aOffset
)
{
nsIFrame
*
firstChild
=
aOffsetFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
firstChild
)
{
return
firstChild
-
>
GetContent
(
)
-
>
Length
(
)
;
}
if
(
aOffsetFrame
-
>
GetPrevSibling
(
)
&
&
!
aOffsetFrame
-
>
GetNextSibling
(
)
)
{
int32_t
aOutOffset
=
aOffsetFrame
-
>
GetParent
(
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetContent
(
)
-
>
Length
(
)
;
return
aOutOffset
;
}
return
aOffset
;
}
void
nsContentUtils
:
:
GetSelectionInTextControl
(
Selection
*
aSelection
Element
*
aRoot
uint32_t
&
aOutStartOffset
uint32_t
&
aOutEndOffset
)
{
MOZ_ASSERT
(
aSelection
&
&
aRoot
)
;
const
nsRange
*
range
=
aSelection
-
>
GetAnchorFocusRange
(
)
;
if
(
!
range
)
{
aOutStartOffset
=
aOutEndOffset
=
0
;
return
;
}
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
uint32_t
startOffset
=
range
-
>
StartOffset
(
)
;
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
uint32_t
endOffset
=
range
-
>
EndOffset
(
)
;
NS_ASSERTION
(
aRoot
-
>
GetChildCount
(
)
<
=
2
"
Unexpected
children
"
)
;
nsIContent
*
firstChild
=
aRoot
-
>
GetFirstChild
(
)
;
#
ifdef
DEBUG
nsCOMPtr
<
nsIContent
>
lastChild
=
aRoot
-
>
GetLastChild
(
)
;
NS_ASSERTION
(
startContainer
=
=
aRoot
|
|
startContainer
=
=
firstChild
|
|
startContainer
=
=
lastChild
"
Unexpected
startContainer
"
)
;
NS_ASSERTION
(
endContainer
=
=
aRoot
|
|
endContainer
=
=
firstChild
|
|
endContainer
=
=
lastChild
"
Unexpected
endContainer
"
)
;
MOZ_ASSERT_IF
(
firstChild
firstChild
-
>
IsText
(
)
|
|
firstChild
-
>
IsElement
(
)
)
;
#
endif
if
(
!
firstChild
|
|
firstChild
-
>
IsElement
(
)
)
{
startOffset
=
endOffset
=
0
;
}
else
{
if
(
(
startContainer
=
=
aRoot
&
&
startOffset
!
=
0
)
|
|
(
startContainer
!
=
aRoot
&
&
startContainer
!
=
firstChild
)
)
{
startOffset
=
firstChild
-
>
Length
(
)
;
}
if
(
(
endContainer
=
=
aRoot
&
&
endOffset
!
=
0
)
|
|
(
endContainer
!
=
aRoot
&
&
endContainer
!
=
firstChild
)
)
{
endOffset
=
firstChild
-
>
Length
(
)
;
}
}
MOZ_ASSERT
(
startOffset
<
=
endOffset
)
;
aOutStartOffset
=
startOffset
;
aOutEndOffset
=
endOffset
;
}
HTMLEditor
*
nsContentUtils
:
:
GetHTMLEditor
(
nsPresContext
*
aPresContext
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
aPresContext
-
>
GetDocShell
(
)
)
;
bool
isEditable
;
if
(
!
docShell
|
|
NS_FAILED
(
docShell
-
>
GetEditable
(
&
isEditable
)
)
|
|
!
isEditable
)
return
nullptr
;
return
docShell
-
>
GetHTMLEditor
(
)
;
}
bool
nsContentUtils
:
:
IsForbiddenRequestHeader
(
const
nsACString
&
aHeader
)
{
if
(
IsForbiddenSystemRequestHeader
(
aHeader
)
)
{
return
true
;
}
return
StringBeginsWith
(
aHeader
NS_LITERAL_CSTRING
(
"
proxy
-
"
)
nsCaseInsensitiveCStringComparator
(
)
)
|
|
StringBeginsWith
(
aHeader
NS_LITERAL_CSTRING
(
"
sec
-
"
)
nsCaseInsensitiveCStringComparator
(
)
)
;
}
bool
nsContentUtils
:
:
IsForbiddenSystemRequestHeader
(
const
nsACString
&
aHeader
)
{
static
const
char
*
kInvalidHeaders
[
]
=
{
"
accept
-
charset
"
"
accept
-
encoding
"
"
access
-
control
-
request
-
headers
"
"
access
-
control
-
request
-
method
"
"
connection
"
"
content
-
length
"
"
cookie
"
"
cookie2
"
"
date
"
"
dnt
"
"
expect
"
"
host
"
"
keep
-
alive
"
"
origin
"
"
referer
"
"
te
"
"
trailer
"
"
transfer
-
encoding
"
"
upgrade
"
"
via
"
}
;
for
(
auto
&
kInvalidHeader
:
kInvalidHeaders
)
{
if
(
aHeader
.
LowerCaseEqualsASCII
(
kInvalidHeader
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsContentUtils
:
:
IsForbiddenResponseHeader
(
const
nsACString
&
aHeader
)
{
return
(
aHeader
.
LowerCaseEqualsASCII
(
"
set
-
cookie
"
)
|
|
aHeader
.
LowerCaseEqualsASCII
(
"
set
-
cookie2
"
)
)
;
}
bool
nsContentUtils
:
:
IsCorsUnsafeRequestHeaderValue
(
const
nsACString
&
aHeaderValue
)
{
const
char
*
cur
=
aHeaderValue
.
BeginReading
(
)
;
const
char
*
end
=
aHeaderValue
.
EndReading
(
)
;
while
(
cur
!
=
end
)
{
if
(
(
*
cur
<
'
'
&
&
*
cur
!
=
'
\
t
'
)
|
|
*
cur
=
=
'
"
'
|
|
*
cur
=
=
'
(
'
|
|
*
cur
=
=
'
)
'
|
|
*
cur
=
=
'
:
'
|
|
*
cur
=
=
'
<
'
|
|
*
cur
=
=
'
>
'
|
|
*
cur
=
=
'
?
'
|
|
*
cur
=
=
'
'
|
|
*
cur
=
=
'
[
'
|
|
*
cur
=
=
'
\
\
'
|
|
*
cur
=
=
'
]
'
|
|
*
cur
=
=
'
{
'
|
|
*
cur
=
=
'
}
'
|
|
*
cur
=
=
0x7F
)
{
return
true
;
}
cur
+
+
;
}
return
false
;
}
bool
nsContentUtils
:
:
IsAllowedNonCorsAccept
(
const
nsACString
&
aHeaderValue
)
{
if
(
IsCorsUnsafeRequestHeaderValue
(
aHeaderValue
)
)
{
return
false
;
}
return
true
;
}
bool
nsContentUtils
:
:
IsAllowedNonCorsContentType
(
const
nsACString
&
aHeaderValue
)
{
nsAutoCString
contentType
;
nsAutoCString
unused
;
if
(
IsCorsUnsafeRequestHeaderValue
(
aHeaderValue
)
)
{
return
false
;
}
nsresult
rv
=
NS_ParseRequestContentType
(
aHeaderValue
contentType
unused
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
contentType
.
LowerCaseEqualsLiteral
(
"
text
/
plain
"
)
|
|
contentType
.
LowerCaseEqualsLiteral
(
"
application
/
x
-
www
-
form
-
urlencoded
"
)
|
|
contentType
.
LowerCaseEqualsLiteral
(
"
multipart
/
form
-
data
"
)
;
}
bool
nsContentUtils
:
:
IsAllowedNonCorsLanguage
(
const
nsACString
&
aHeaderValue
)
{
const
char
*
cur
=
aHeaderValue
.
BeginReading
(
)
;
const
char
*
end
=
aHeaderValue
.
EndReading
(
)
;
while
(
cur
!
=
end
)
{
if
(
(
*
cur
>
=
'
0
'
&
&
*
cur
<
=
'
9
'
)
|
|
(
*
cur
>
=
'
A
'
&
&
*
cur
<
=
'
Z
'
)
|
|
(
*
cur
>
=
'
a
'
&
&
*
cur
<
=
'
z
'
)
|
|
*
cur
=
=
'
'
|
|
*
cur
=
=
'
*
'
|
|
*
cur
=
=
'
'
|
|
*
cur
=
=
'
-
'
|
|
*
cur
=
=
'
.
'
|
|
*
cur
=
=
'
;
'
|
|
*
cur
=
=
'
=
'
)
{
cur
+
+
;
continue
;
}
return
false
;
}
return
true
;
}
bool
nsContentUtils
:
:
DoNotTrackEnabled
(
)
{
return
nsContentUtils
:
:
sDoNotTrackEnabled
;
}
mozilla
:
:
LogModule
*
nsContentUtils
:
:
DOMDumpLog
(
)
{
return
sDOMDumpLog
;
}
bool
nsContentUtils
:
:
GetNodeTextContent
(
nsINode
*
aNode
bool
aDeep
nsAString
&
aResult
const
fallible_t
&
aFallible
)
{
aResult
.
Truncate
(
)
;
return
AppendNodeTextContent
(
aNode
aDeep
aResult
aFallible
)
;
}
void
nsContentUtils
:
:
GetNodeTextContent
(
nsINode
*
aNode
bool
aDeep
nsAString
&
aResult
)
{
if
(
!
GetNodeTextContent
(
aNode
aDeep
aResult
fallible
)
)
{
NS_ABORT_OOM
(
0
)
;
}
}
void
nsContentUtils
:
:
DestroyMatchString
(
void
*
aData
)
{
if
(
aData
)
{
nsString
*
matchString
=
static_cast
<
nsString
*
>
(
aData
)
;
delete
matchString
;
}
}
bool
nsContentUtils
:
:
IsJavascriptMIMEType
(
const
nsAString
&
aMIMEType
)
{
static
const
char
*
jsTypes
[
]
=
{
"
text
/
javascript
"
"
text
/
ecmascript
"
"
application
/
javascript
"
"
application
/
ecmascript
"
"
application
/
x
-
javascript
"
"
application
/
x
-
ecmascript
"
"
text
/
javascript1
.
0
"
"
text
/
javascript1
.
1
"
"
text
/
javascript1
.
2
"
"
text
/
javascript1
.
3
"
"
text
/
javascript1
.
4
"
"
text
/
javascript1
.
5
"
"
text
/
jscript
"
"
text
/
livescript
"
"
text
/
x
-
ecmascript
"
"
text
/
x
-
javascript
"
nullptr
}
;
for
(
uint32_t
i
=
0
;
jsTypes
[
i
]
;
+
+
i
)
{
if
(
aMIMEType
.
LowerCaseEqualsASCII
(
jsTypes
[
i
]
)
)
{
return
true
;
}
}
return
false
;
}
nsresult
nsContentUtils
:
:
GenerateUUIDInPlace
(
nsID
&
aUUID
)
{
MOZ_ASSERT
(
sUUIDGenerator
)
;
nsresult
rv
=
sUUIDGenerator
-
>
GenerateUUIDInPlace
(
&
aUUID
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
nsContentUtils
:
:
PrefetchPreloadEnabled
(
nsIDocShell
*
aDocShell
)
{
if
(
!
aDocShell
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShell
>
docshell
=
aDocShell
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
do
{
auto
appType
=
docshell
-
>
GetAppType
(
)
;
if
(
appType
=
=
nsIDocShell
:
:
APP_TYPE_MAIL
)
{
return
false
;
}
docshell
-
>
GetParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
parentItem
)
{
docshell
=
do_QueryInterface
(
parentItem
)
;
if
(
!
docshell
)
{
NS_ERROR
(
"
cannot
get
a
docshell
from
a
treeItem
!
"
)
;
return
false
;
}
}
}
while
(
parentItem
)
;
return
true
;
}
uint64_t
nsContentUtils
:
:
GetInnerWindowID
(
nsIRequest
*
aRequest
)
{
if
(
!
aRequest
)
{
return
0
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsresult
rv
=
aRequest
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
loadGroup
)
{
return
0
;
}
return
GetInnerWindowID
(
loadGroup
)
;
}
uint64_t
nsContentUtils
:
:
GetInnerWindowID
(
nsILoadGroup
*
aLoadGroup
)
{
if
(
!
aLoadGroup
)
{
return
0
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
nsresult
rv
=
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
callbacks
)
{
return
0
;
}
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_GetInterface
(
callbacks
)
;
if
(
!
loadContext
)
{
return
0
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
window
;
rv
=
loadContext
-
>
GetAssociatedWindow
(
getter_AddRefs
(
window
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
window
)
{
return
0
;
}
auto
*
pwindow
=
nsPIDOMWindowOuter
:
:
From
(
window
)
;
if
(
!
pwindow
)
{
return
0
;
}
nsPIDOMWindowInner
*
inner
=
pwindow
-
>
GetCurrentInnerWindow
(
)
;
return
inner
?
inner
-
>
WindowID
(
)
:
0
;
}
nsresult
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
nsIURI
*
aURI
nsCString
&
aHost
)
{
aHost
.
Truncate
(
)
;
nsresult
rv
=
aURI
-
>
GetHost
(
aHost
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
aHost
.
FindChar
(
'
:
'
)
!
=
-
1
)
{
MOZ_ASSERT
(
!
aHost
.
Length
(
)
|
|
(
aHost
[
0
]
!
=
'
[
'
&
&
aHost
[
aHost
.
Length
(
)
-
1
]
!
=
'
]
'
)
)
;
aHost
.
Insert
(
'
[
'
0
)
;
aHost
.
Append
(
'
]
'
)
;
}
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
nsIURI
*
aURI
nsAString
&
aHost
)
{
nsAutoCString
hostname
;
nsresult
rv
=
GetHostOrIPv6WithBrackets
(
aURI
hostname
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
CopyUTF8toUTF16
(
hostname
aHost
)
;
return
NS_OK
;
}
bool
nsContentUtils
:
:
CallOnAllRemoteChildren
(
MessageBroadcaster
*
aManager
CallOnRemoteChildFunction
aCallback
void
*
aArg
)
{
uint32_t
tabChildCount
=
aManager
-
>
ChildCount
(
)
;
for
(
uint32_t
j
=
0
;
j
<
tabChildCount
;
+
+
j
)
{
RefPtr
<
MessageListenerManager
>
childMM
=
aManager
-
>
GetChildAt
(
j
)
;
if
(
!
childMM
)
{
continue
;
}
RefPtr
<
MessageBroadcaster
>
nonLeafMM
=
MessageBroadcaster
:
:
From
(
childMM
)
;
if
(
nonLeafMM
)
{
if
(
CallOnAllRemoteChildren
(
nonLeafMM
aCallback
aArg
)
)
{
return
true
;
}
continue
;
}
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerCallback
*
cb
=
childMM
-
>
GetCallback
(
)
;
if
(
cb
)
{
nsFrameLoader
*
fl
=
static_cast
<
nsFrameLoader
*
>
(
cb
)
;
TabParent
*
remote
=
TabParent
:
:
GetFrom
(
fl
)
;
if
(
remote
&
&
aCallback
)
{
if
(
aCallback
(
remote
aArg
)
)
{
return
true
;
}
}
}
}
return
false
;
}
void
nsContentUtils
:
:
CallOnAllRemoteChildren
(
nsPIDOMWindowOuter
*
aWindow
CallOnRemoteChildFunction
aCallback
void
*
aArg
)
{
nsGlobalWindowOuter
*
window
=
nsGlobalWindowOuter
:
:
Cast
(
aWindow
)
;
if
(
window
-
>
IsChromeWindow
(
)
)
{
RefPtr
<
MessageBroadcaster
>
windowMM
=
window
-
>
GetMessageManager
(
)
;
if
(
windowMM
)
{
CallOnAllRemoteChildren
(
windowMM
aCallback
aArg
)
;
}
}
}
struct
UIStateChangeInfo
{
UIStateChangeType
mShowAccelerators
;
UIStateChangeType
mShowFocusRings
;
UIStateChangeInfo
(
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
:
mShowAccelerators
(
aShowAccelerators
)
mShowFocusRings
(
aShowFocusRings
)
{
}
}
;
bool
SetKeyboardIndicatorsChild
(
TabParent
*
aParent
void
*
aArg
)
{
UIStateChangeInfo
*
stateInfo
=
static_cast
<
UIStateChangeInfo
*
>
(
aArg
)
;
Unused
<
<
aParent
-
>
SendSetKeyboardIndicators
(
stateInfo
-
>
mShowAccelerators
stateInfo
-
>
mShowFocusRings
)
;
return
false
;
}
void
nsContentUtils
:
:
SetKeyboardIndicatorsOnRemoteChildren
(
nsPIDOMWindowOuter
*
aWindow
UIStateChangeType
aShowAccelerators
UIStateChangeType
aShowFocusRings
)
{
UIStateChangeInfo
stateInfo
(
aShowAccelerators
aShowFocusRings
)
;
CallOnAllRemoteChildren
(
aWindow
SetKeyboardIndicatorsChild
(
void
*
)
&
stateInfo
)
;
}
nsresult
nsContentUtils
:
:
IPCTransferableToTransferable
(
const
IPCDataTransfer
&
aDataTransfer
const
bool
&
aIsPrivateData
nsIPrincipal
*
aRequestingPrincipal
const
nsContentPolicyType
&
aContentPolicyType
nsITransferable
*
aTransferable
mozilla
:
:
dom
:
:
nsIContentParent
*
aContentParent
mozilla
:
:
dom
:
:
TabChild
*
aTabChild
)
{
nsresult
rv
;
const
nsTArray
<
IPCDataTransferItem
>
&
items
=
aDataTransfer
.
items
(
)
;
for
(
const
auto
&
item
:
items
)
{
aTransferable
-
>
AddDataFlavor
(
item
.
flavor
(
)
.
get
(
)
)
;
if
(
item
.
data
(
)
.
type
(
)
=
=
IPCDataTransferData
:
:
TnsString
)
{
nsCOMPtr
<
nsISupportsString
>
dataWrapper
=
do_CreateInstance
(
NS_SUPPORTS_STRING_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
nsString
&
text
=
item
.
data
(
)
.
get_nsString
(
)
;
rv
=
dataWrapper
-
>
SetData
(
text
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aTransferable
-
>
SetTransferData
(
item
.
flavor
(
)
.
get
(
)
dataWrapper
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
if
(
item
.
data
(
)
.
type
(
)
=
=
IPCDataTransferData
:
:
TShmem
)
{
if
(
nsContentUtils
:
:
IsFlavorImage
(
item
.
flavor
(
)
)
)
{
nsCOMPtr
<
imgIContainer
>
imageContainer
;
rv
=
nsContentUtils
:
:
DataTransferItemToImage
(
item
getter_AddRefs
(
imageContainer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aTransferable
-
>
SetTransferData
(
item
.
flavor
(
)
.
get
(
)
imageContainer
)
;
}
else
{
nsCOMPtr
<
nsISupportsCString
>
dataWrapper
=
do_CreateInstance
(
NS_SUPPORTS_CSTRING_CONTRACTID
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Shmem
itemData
=
item
.
data
(
)
.
get_Shmem
(
)
;
const
nsDependentCSubstring
text
(
itemData
.
get
<
char
>
(
)
itemData
.
Size
<
char
>
(
)
)
;
rv
=
dataWrapper
-
>
SetData
(
text
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
aTransferable
-
>
SetTransferData
(
item
.
flavor
(
)
.
get
(
)
dataWrapper
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
aContentParent
)
{
Unused
<
<
aContentParent
-
>
DeallocShmem
(
item
.
data
(
)
.
get_Shmem
(
)
)
;
}
else
if
(
aTabChild
)
{
Unused
<
<
aTabChild
-
>
DeallocShmem
(
item
.
data
(
)
.
get_Shmem
(
)
)
;
}
}
}
aTransferable
-
>
SetIsPrivateData
(
aIsPrivateData
)
;
aTransferable
-
>
SetRequestingPrincipal
(
aRequestingPrincipal
)
;
aTransferable
-
>
SetContentPolicyType
(
aContentPolicyType
)
;
return
NS_OK
;
}
void
nsContentUtils
:
:
TransferablesToIPCTransferables
(
nsIArray
*
aTransferables
nsTArray
<
IPCDataTransfer
>
&
aIPC
bool
aInSyncMessage
mozilla
:
:
dom
:
:
nsIContentChild
*
aChild
mozilla
:
:
dom
:
:
nsIContentParent
*
aParent
)
{
aIPC
.
Clear
(
)
;
if
(
aTransferables
)
{
uint32_t
transferableCount
=
0
;
aTransferables
-
>
GetLength
(
&
transferableCount
)
;
for
(
uint32_t
i
=
0
;
i
<
transferableCount
;
+
+
i
)
{
IPCDataTransfer
*
dt
=
aIPC
.
AppendElement
(
)
;
nsCOMPtr
<
nsITransferable
>
transferable
=
do_QueryElementAt
(
aTransferables
i
)
;
TransferableToIPCTransferable
(
transferable
dt
aInSyncMessage
aChild
aParent
)
;
}
}
}
nsresult
nsContentUtils
:
:
SlurpFileToString
(
nsIFile
*
aFile
nsACString
&
aString
)
{
aString
.
Truncate
(
)
;
nsCOMPtr
<
nsIURI
>
fileURI
;
nsresult
rv
=
NS_NewFileURI
(
getter_AddRefs
(
fileURI
)
aFile
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
fileURI
nsContentUtils
:
:
GetSystemPrincipal
(
)
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
nsIContentPolicy
:
:
TYPE_OTHER
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsCOMPtr
<
nsIInputStream
>
stream
;
rv
=
channel
-
>
Open2
(
getter_AddRefs
(
stream
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
NS_ConsumeStream
(
stream
UINT32_MAX
aString
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
stream
-
>
Close
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
bool
nsContentUtils
:
:
IsFileImage
(
nsIFile
*
aFile
nsACString
&
aType
)
{
nsCOMPtr
<
nsIMIMEService
>
mime
=
do_GetService
(
"
mozilla
.
org
/
mime
;
1
"
)
;
if
(
!
mime
)
{
return
false
;
}
nsresult
rv
=
mime
-
>
GetTypeFromFile
(
aFile
aType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
StringBeginsWith
(
aType
NS_LITERAL_CSTRING
(
"
image
/
"
)
)
;
}
nsresult
nsContentUtils
:
:
CalculateBufferSizeForImage
(
const
uint32_t
&
aStride
const
IntSize
&
aImageSize
const
SurfaceFormat
&
aFormat
size_t
*
aMaxBufferSize
size_t
*
aUsedBufferSize
)
{
CheckedInt32
requiredBytes
=
CheckedInt32
(
aStride
)
*
CheckedInt32
(
aImageSize
.
height
)
;
CheckedInt32
usedBytes
=
requiredBytes
-
aStride
+
(
CheckedInt32
(
aImageSize
.
width
)
*
BytesPerPixel
(
aFormat
)
)
;
if
(
!
usedBytes
.
isValid
(
)
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_ASSERT
(
requiredBytes
.
isValid
(
)
"
usedBytes
valid
but
not
required
?
"
)
;
*
aMaxBufferSize
=
requiredBytes
.
value
(
)
;
*
aUsedBufferSize
=
usedBytes
.
value
(
)
;
return
NS_OK
;
}
nsresult
nsContentUtils
:
:
DataTransferItemToImage
(
const
IPCDataTransferItem
&
aItem
imgIContainer
*
*
aContainer
)
{
MOZ_ASSERT
(
aItem
.
data
(
)
.
type
(
)
=
=
IPCDataTransferData
:
:
TShmem
)
;
MOZ_ASSERT
(
IsFlavorImage
(
aItem
.
flavor
(
)
)
)
;
const
IPCDataTransferImage
&
imageDetails
=
aItem
.
imageDetails
(
)
;
const
IntSize
size
(
imageDetails
.
width
(
)
imageDetails
.
height
(
)
)
;
if
(
!
size
.
width
|
|
!
size
.
height
)
{
return
NS_ERROR_FAILURE
;
}
Shmem
data
=
aItem
.
data
(
)
.
get_Shmem
(
)
;
size_t
imageBufLen
=
0
;
size_t
maxBufLen
=
0
;
nsresult
rv
=
CalculateBufferSizeForImage
(
imageDetails
.
stride
(
)
size
imageDetails
.
format
(
)
&
maxBufLen
&
imageBufLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
imageBufLen
>
data
.
Size
<
uint8_t
>
(
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
DataSourceSurface
>
image
=
CreateDataSourceSurfaceFromData
(
size
imageDetails
.
format
(
)
data
.
get
<
uint8_t
>
(
)
imageDetails
.
stride
(
)
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxSurfaceDrawable
(
image
size
)
;
nsCOMPtr
<
imgIContainer
>
imageContainer
=
image
:
:
ImageOps
:
:
CreateFromDrawable
(
drawable
)
;
imageContainer
.
forget
(
aContainer
)
;
return
NS_OK
;
}
bool
nsContentUtils
:
:
IsFlavorImage
(
const
nsACString
&
aFlavor
)
{
return
aFlavor
.
EqualsLiteral
(
kNativeImageMime
)
|
|
aFlavor
.
EqualsLiteral
(
kJPEGImageMime
)
|
|
aFlavor
.
EqualsLiteral
(
kJPGImageMime
)
|
|
aFlavor
.
EqualsLiteral
(
kPNGImageMime
)
|
|
aFlavor
.
EqualsLiteral
(
kGIFImageMime
)
;
}
static
Shmem
ConvertToShmem
(
mozilla
:
:
dom
:
:
nsIContentChild
*
aChild
mozilla
:
:
dom
:
:
nsIContentParent
*
aParent
const
nsACString
&
aInput
)
{
MOZ_ASSERT
(
(
aChild
&
&
!
aParent
)
|
|
(
!
aChild
&
&
aParent
)
)
;
IShmemAllocator
*
allocator
=
aChild
?
static_cast
<
IShmemAllocator
*
>
(
aChild
)
:
static_cast
<
IShmemAllocator
*
>
(
aParent
)
;
Shmem
result
;
if
(
!
allocator
-
>
AllocShmem
(
aInput
.
Length
(
)
SharedMemory
:
:
TYPE_BASIC
&
result
)
)
{
return
result
;
}
memcpy
(
result
.
get
<
char
>
(
)
aInput
.
BeginReading
(
)
aInput
.
Length
(
)
)
;
return
result
;
}
void
nsContentUtils
:
:
TransferableToIPCTransferable
(
nsITransferable
*
aTransferable
IPCDataTransfer
*
aIPCDataTransfer
bool
aInSyncMessage
mozilla
:
:
dom
:
:
nsIContentChild
*
aChild
mozilla
:
:
dom
:
:
nsIContentParent
*
aParent
)
{
MOZ_ASSERT
(
(
aChild
&
&
!
aParent
)
|
|
(
!
aChild
&
&
aParent
)
)
;
if
(
aTransferable
)
{
nsTArray
<
nsCString
>
flavorList
;
aTransferable
-
>
FlavorsTransferableCanExport
(
flavorList
)
;
for
(
uint32_t
j
=
0
;
j
<
flavorList
.
Length
(
)
;
+
+
j
)
{
nsCString
&
flavorStr
=
flavorList
[
j
]
;
if
(
!
flavorStr
.
Length
(
)
)
{
continue
;
}
nsCOMPtr
<
nsISupports
>
data
;
nsresult
rv
=
aTransferable
-
>
GetTransferData
(
flavorStr
.
get
(
)
getter_AddRefs
(
data
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
data
)
{
if
(
aInSyncMessage
)
{
continue
;
}
if
(
flavorStr
.
EqualsLiteral
(
kFilePromiseMime
)
)
{
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
flavorStr
;
item
-
>
data
(
)
=
NS_ConvertUTF8toUTF16
(
flavorStr
)
;
continue
;
}
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
flavorStr
;
item
-
>
data
(
)
=
nsString
(
)
;
continue
;
}
if
(
nsCOMPtr
<
nsISupportsString
>
text
=
do_QueryInterface
(
data
)
)
{
nsAutoString
dataAsString
;
text
-
>
GetData
(
dataAsString
)
;
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
flavorStr
;
item
-
>
data
(
)
=
dataAsString
;
}
else
if
(
nsCOMPtr
<
nsISupportsCString
>
ctext
=
do_QueryInterface
(
data
)
)
{
nsAutoCString
dataAsString
;
ctext
-
>
GetData
(
dataAsString
)
;
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
flavorStr
;
Shmem
dataAsShmem
=
ConvertToShmem
(
aChild
aParent
dataAsString
)
;
if
(
!
dataAsShmem
.
IsReadable
(
)
|
|
!
dataAsShmem
.
Size
<
char
>
(
)
)
{
continue
;
}
item
-
>
data
(
)
=
dataAsShmem
;
}
else
if
(
nsCOMPtr
<
nsIInputStream
>
stream
=
do_QueryInterface
(
data
)
)
{
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
flavorStr
;
nsCString
imageData
;
NS_ConsumeStream
(
stream
UINT32_MAX
imageData
)
;
Shmem
imageDataShmem
=
ConvertToShmem
(
aChild
aParent
imageData
)
;
if
(
!
imageDataShmem
.
IsReadable
(
)
|
|
!
imageDataShmem
.
Size
<
char
>
(
)
)
{
continue
;
}
item
-
>
data
(
)
=
imageDataShmem
;
}
else
if
(
nsCOMPtr
<
imgIContainer
>
image
=
do_QueryInterface
(
data
)
)
{
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
surface
=
image
-
>
GetFrame
(
imgIContainer
:
:
FRAME_CURRENT
imgIContainer
:
:
FLAG_SYNC_DECODE
)
;
if
(
!
surface
)
{
continue
;
}
RefPtr
<
mozilla
:
:
gfx
:
:
DataSourceSurface
>
dataSurface
=
surface
-
>
GetDataSurface
(
)
;
if
(
!
dataSurface
)
{
continue
;
}
size_t
length
;
int32_t
stride
;
IShmemAllocator
*
allocator
=
aChild
?
static_cast
<
IShmemAllocator
*
>
(
aChild
)
:
static_cast
<
IShmemAllocator
*
>
(
aParent
)
;
Maybe
<
Shmem
>
surfaceData
=
GetSurfaceData
(
dataSurface
&
length
&
stride
allocator
)
;
if
(
surfaceData
.
isNothing
(
)
)
{
continue
;
}
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
flavorStr
;
item
-
>
data
(
)
=
surfaceData
.
ref
(
)
;
IPCDataTransferImage
&
imageDetails
=
item
-
>
imageDetails
(
)
;
mozilla
:
:
gfx
:
:
IntSize
size
=
dataSurface
-
>
GetSize
(
)
;
imageDetails
.
width
(
)
=
size
.
width
;
imageDetails
.
height
(
)
=
size
.
height
;
imageDetails
.
stride
(
)
=
stride
;
imageDetails
.
format
(
)
=
dataSurface
-
>
GetFormat
(
)
;
}
else
{
nsCOMPtr
<
BlobImpl
>
blobImpl
;
if
(
nsCOMPtr
<
nsIFile
>
file
=
do_QueryInterface
(
data
)
)
{
if
(
aInSyncMessage
)
{
nsAutoCString
type
;
if
(
IsFileImage
(
file
type
)
)
{
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
type
;
nsAutoCString
data
;
SlurpFileToString
(
file
data
)
;
Shmem
dataAsShmem
=
ConvertToShmem
(
aChild
aParent
data
)
;
item
-
>
data
(
)
=
dataAsShmem
;
}
continue
;
}
if
(
aParent
)
{
bool
isDir
=
false
;
if
(
NS_SUCCEEDED
(
file
-
>
IsDirectory
(
&
isDir
)
)
&
&
isDir
)
{
nsAutoString
path
;
if
(
NS_WARN_IF
(
NS_FAILED
(
file
-
>
GetPath
(
path
)
)
)
)
{
continue
;
}
RefPtr
<
FileSystemSecurity
>
fss
=
FileSystemSecurity
:
:
GetOrCreate
(
)
;
fss
-
>
GrantAccessToContentProcess
(
aParent
-
>
ChildID
(
)
path
)
;
}
}
blobImpl
=
new
FileBlobImpl
(
file
)
;
IgnoredErrorResult
rv
;
blobImpl
-
>
GetSize
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
continue
;
}
blobImpl
-
>
GetLastModified
(
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
continue
;
}
}
else
{
if
(
aInSyncMessage
)
{
continue
;
}
blobImpl
=
do_QueryInterface
(
data
)
;
}
if
(
blobImpl
)
{
IPCDataTransferData
data
;
IPCBlob
ipcBlob
;
if
(
aChild
)
{
nsresult
rv
=
IPCBlobUtils
:
:
Serialize
(
blobImpl
aChild
ipcBlob
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
data
=
ipcBlob
;
}
else
if
(
aParent
)
{
nsresult
rv
=
IPCBlobUtils
:
:
Serialize
(
blobImpl
aParent
ipcBlob
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
continue
;
}
data
=
ipcBlob
;
}
IPCDataTransferItem
*
item
=
aIPCDataTransfer
-
>
items
(
)
.
AppendElement
(
)
;
item
-
>
flavor
(
)
=
flavorStr
;
item
-
>
data
(
)
=
data
;
}
}
}
}
}
namespace
{
struct
GetSurfaceDataRawBuffer
{
using
ReturnType
=
mozilla
:
:
UniquePtr
<
char
[
]
>
;
using
BufferType
=
char
*
;
ReturnType
Allocate
(
size_t
aSize
)
{
return
ReturnType
(
new
char
[
aSize
]
)
;
}
static
BufferType
GetBuffer
(
const
ReturnType
&
aReturnValue
)
{
return
aReturnValue
.
get
(
)
;
}
static
ReturnType
NullValue
(
)
{
return
ReturnType
(
)
;
}
}
;
struct
GetSurfaceDataShmem
{
using
ReturnType
=
Maybe
<
Shmem
>
;
using
BufferType
=
char
*
;
explicit
GetSurfaceDataShmem
(
IShmemAllocator
*
aAllocator
)
:
mAllocator
(
aAllocator
)
{
}
ReturnType
Allocate
(
size_t
aSize
)
{
Shmem
shmem
;
if
(
!
mAllocator
-
>
AllocShmem
(
aSize
SharedMemory
:
:
TYPE_BASIC
&
shmem
)
)
{
return
Nothing
(
)
;
}
return
Some
(
shmem
)
;
}
static
BufferType
GetBuffer
(
const
ReturnType
&
aReturnValue
)
{
return
aReturnValue
.
isSome
(
)
?
aReturnValue
.
ref
(
)
.
get
<
char
>
(
)
:
nullptr
;
}
static
ReturnType
NullValue
(
)
{
return
ReturnType
(
)
;
}
private
:
IShmemAllocator
*
mAllocator
;
}
;
template
<
typename
GetSurfaceDataContext
=
GetSurfaceDataRawBuffer
>
typename
GetSurfaceDataContext
:
:
ReturnType
GetSurfaceDataImpl
(
mozilla
:
:
gfx
:
:
DataSourceSurface
*
aSurface
size_t
*
aLength
int32_t
*
aStride
GetSurfaceDataContext
aContext
=
GetSurfaceDataContext
(
)
)
{
mozilla
:
:
gfx
:
:
DataSourceSurface
:
:
MappedSurface
map
;
if
(
!
aSurface
-
>
Map
(
mozilla
:
:
gfx
:
:
DataSourceSurface
:
:
MapType
:
:
READ
&
map
)
)
{
return
GetSurfaceDataContext
:
:
NullValue
(
)
;
}
size_t
bufLen
=
0
;
size_t
maxBufLen
=
0
;
nsresult
rv
=
nsContentUtils
:
:
CalculateBufferSizeForImage
(
map
.
mStride
aSurface
-
>
GetSize
(
)
aSurface
-
>
GetFormat
(
)
&
maxBufLen
&
bufLen
)
;
if
(
NS_FAILED
(
rv
)
)
{
aSurface
-
>
Unmap
(
)
;
return
GetSurfaceDataContext
:
:
NullValue
(
)
;
}
typename
GetSurfaceDataContext
:
:
ReturnType
surfaceData
=
aContext
.
Allocate
(
maxBufLen
+
1
)
;
if
(
GetSurfaceDataContext
:
:
GetBuffer
(
surfaceData
)
)
{
memcpy
(
GetSurfaceDataContext
:
:
GetBuffer
(
surfaceData
)
reinterpret_cast
<
char
*
>
(
map
.
mData
)
bufLen
)
;
memset
(
GetSurfaceDataContext
:
:
GetBuffer
(
surfaceData
)
+
bufLen
0
maxBufLen
-
bufLen
+
1
)
;
}
*
aLength
=
maxBufLen
;
*
aStride
=
map
.
mStride
;
aSurface
-
>
Unmap
(
)
;
return
surfaceData
;
}
}
mozilla
:
:
UniquePtr
<
char
[
]
>
nsContentUtils
:
:
GetSurfaceData
(
NotNull
<
mozilla
:
:
gfx
:
:
DataSourceSurface
*
>
aSurface
size_t
*
aLength
int32_t
*
aStride
)
{
return
GetSurfaceDataImpl
(
aSurface
aLength
aStride
)
;
}
Maybe
<
Shmem
>
nsContentUtils
:
:
GetSurfaceData
(
mozilla
:
:
gfx
:
:
DataSourceSurface
*
aSurface
size_t
*
aLength
int32_t
*
aStride
IShmemAllocator
*
aAllocator
)
{
return
GetSurfaceDataImpl
(
aSurface
aLength
aStride
GetSurfaceDataShmem
(
aAllocator
)
)
;
}
mozilla
:
:
Modifiers
nsContentUtils
:
:
GetWidgetModifiers
(
int32_t
aModifiers
)
{
Modifiers
result
=
0
;
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_SHIFT
)
{
result
|
=
mozilla
:
:
MODIFIER_SHIFT
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_CONTROL
)
{
result
|
=
mozilla
:
:
MODIFIER_CONTROL
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_ALT
)
{
result
|
=
mozilla
:
:
MODIFIER_ALT
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_META
)
{
result
|
=
mozilla
:
:
MODIFIER_META
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_ALTGRAPH
)
{
result
|
=
mozilla
:
:
MODIFIER_ALTGRAPH
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_CAPSLOCK
)
{
result
|
=
mozilla
:
:
MODIFIER_CAPSLOCK
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_FN
)
{
result
|
=
mozilla
:
:
MODIFIER_FN
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_FNLOCK
)
{
result
|
=
mozilla
:
:
MODIFIER_FNLOCK
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_NUMLOCK
)
{
result
|
=
mozilla
:
:
MODIFIER_NUMLOCK
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_SCROLLLOCK
)
{
result
|
=
mozilla
:
:
MODIFIER_SCROLLLOCK
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOL
)
{
result
|
=
mozilla
:
:
MODIFIER_SYMBOL
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_SYMBOLLOCK
)
{
result
|
=
mozilla
:
:
MODIFIER_SYMBOLLOCK
;
}
if
(
aModifiers
&
nsIDOMWindowUtils
:
:
MODIFIER_OS
)
{
result
|
=
mozilla
:
:
MODIFIER_OS
;
}
return
result
;
}
nsIWidget
*
nsContentUtils
:
:
GetWidget
(
nsIPresShell
*
aPresShell
nsPoint
*
aOffset
)
{
if
(
aPresShell
)
{
nsIFrame
*
frame
=
aPresShell
-
>
GetRootFrame
(
)
;
if
(
frame
)
return
frame
-
>
GetView
(
)
-
>
GetNearestWidget
(
aOffset
)
;
}
return
nullptr
;
}
int16_t
nsContentUtils
:
:
GetButtonsFlagForButton
(
int32_t
aButton
)
{
switch
(
aButton
)
{
case
-
1
:
return
WidgetMouseEvent
:
:
eNoButtonFlag
;
case
WidgetMouseEvent
:
:
eLeftButton
:
return
WidgetMouseEvent
:
:
eLeftButtonFlag
;
case
WidgetMouseEvent
:
:
eMiddleButton
:
return
WidgetMouseEvent
:
:
eMiddleButtonFlag
;
case
WidgetMouseEvent
:
:
eRightButton
:
return
WidgetMouseEvent
:
:
eRightButtonFlag
;
case
4
:
return
WidgetMouseEvent
:
:
e4thButtonFlag
;
case
5
:
return
WidgetMouseEvent
:
:
e5thButtonFlag
;
default
:
NS_ERROR
(
"
Button
not
known
.
"
)
;
return
0
;
}
}
LayoutDeviceIntPoint
nsContentUtils
:
:
ToWidgetPoint
(
const
CSSPoint
&
aPoint
const
nsPoint
&
aOffset
nsPresContext
*
aPresContext
)
{
return
LayoutDeviceIntPoint
:
:
FromAppUnitsRounded
(
(
CSSPoint
:
:
ToAppUnits
(
aPoint
)
+
aOffset
)
.
ApplyResolution
(
nsLayoutUtils
:
:
GetCurrentAPZResolutionScale
(
aPresContext
-
>
PresShell
(
)
)
)
aPresContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
nsView
*
nsContentUtils
:
:
GetViewToDispatchEvent
(
nsPresContext
*
presContext
nsIPresShell
*
*
presShell
)
{
if
(
presContext
&
&
presShell
)
{
*
presShell
=
presContext
-
>
PresShell
(
)
;
if
(
*
presShell
)
{
NS_ADDREF
(
*
presShell
)
;
if
(
nsViewManager
*
viewManager
=
(
*
presShell
)
-
>
GetViewManager
(
)
)
{
if
(
nsView
*
view
=
viewManager
-
>
GetRootView
(
)
)
{
return
view
;
}
}
}
}
return
nullptr
;
}
nsresult
nsContentUtils
:
:
SendMouseEvent
(
const
nsCOMPtr
<
nsIPresShell
>
&
aPresShell
const
nsAString
&
aType
float
aX
float
aY
int32_t
aButton
int32_t
aButtons
int32_t
aClickCount
int32_t
aModifiers
bool
aIgnoreRootScrollFrame
float
aPressure
unsigned
short
aInputSourceArg
uint32_t
aIdentifier
bool
aToWindow
bool
*
aPreventDefault
bool
aIsDOMEventSynthesized
bool
aIsWidgetEventSynthesized
)
{
nsPoint
offset
;
nsCOMPtr
<
nsIWidget
>
widget
=
GetWidget
(
aPresShell
&
offset
)
;
if
(
!
widget
)
return
NS_ERROR_FAILURE
;
EventMessage
msg
;
WidgetMouseEvent
:
:
ExitFrom
exitFrom
=
WidgetMouseEvent
:
:
eChild
;
bool
contextMenuKey
=
false
;
if
(
aType
.
EqualsLiteral
(
"
mousedown
"
)
)
{
msg
=
eMouseDown
;
}
else
if
(
aType
.
EqualsLiteral
(
"
mouseup
"
)
)
{
msg
=
eMouseUp
;
}
else
if
(
aType
.
EqualsLiteral
(
"
mousemove
"
)
)
{
msg
=
eMouseMove
;
}
else
if
(
aType
.
EqualsLiteral
(
"
mouseover
"
)
)
{
msg
=
eMouseEnterIntoWidget
;
}
else
if
(
aType
.
EqualsLiteral
(
"
mouseout
"
)
)
{
msg
=
eMouseExitFromWidget
;
}
else
if
(
aType
.
EqualsLiteral
(
"
mousecancel
"
)
)
{
msg
=
eMouseExitFromWidget
;
exitFrom
=
WidgetMouseEvent
:
:
eTopLevel
;
}
else
if
(
aType
.
EqualsLiteral
(
"
mouselongtap
"
)
)
{
msg
=
eMouseLongTap
;
}
else
if
(
aType
.
EqualsLiteral
(
"
contextmenu
"
)
)
{
msg
=
eContextMenu
;
contextMenuKey
=
(
aButton
=
=
0
)
;
}
else
if
(
aType
.
EqualsLiteral
(
"
MozMouseHittest
"
)
)
{
msg
=
eMouseHitTest
;
}
else
{
return
NS_ERROR_FAILURE
;
}
if
(
aInputSourceArg
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_UNKNOWN
)
{
aInputSourceArg
=
MouseEvent_Binding
:
:
MOZ_SOURCE_MOUSE
;
}
WidgetMouseEvent
event
(
true
msg
widget
aIsWidgetEventSynthesized
?
WidgetMouseEvent
:
:
eSynthesized
:
WidgetMouseEvent
:
:
eReal
contextMenuKey
?
WidgetMouseEvent
:
:
eContextMenuKey
:
WidgetMouseEvent
:
:
eNormal
)
;
event
.
pointerId
=
aIdentifier
;
event
.
mModifiers
=
GetWidgetModifiers
(
aModifiers
)
;
event
.
button
=
aButton
;
event
.
buttons
=
aButtons
!
=
nsIDOMWindowUtils
:
:
MOUSE_BUTTONS_NOT_SPECIFIED
?
aButtons
:
msg
=
=
eMouseUp
?
0
:
GetButtonsFlagForButton
(
aButton
)
;
event
.
pressure
=
aPressure
;
event
.
inputSource
=
aInputSourceArg
;
event
.
mClickCount
=
aClickCount
;
event
.
mTime
=
PR_IntervalNow
(
)
;
event
.
mFlags
.
mIsSynthesizedForTests
=
aIsDOMEventSynthesized
;
event
.
mExitFrom
=
exitFrom
;
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
return
NS_ERROR_FAILURE
;
event
.
mRefPoint
=
ToWidgetPoint
(
CSSPoint
(
aX
aY
)
offset
presContext
)
;
event
.
mIgnoreRootScrollFrame
=
aIgnoreRootScrollFrame
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
aToWindow
)
{
nsCOMPtr
<
nsIPresShell
>
presShell
;
nsView
*
view
=
GetViewToDispatchEvent
(
presContext
getter_AddRefs
(
presShell
)
)
;
if
(
!
presShell
|
|
!
view
)
{
return
NS_ERROR_FAILURE
;
}
return
presShell
-
>
HandleEvent
(
view
-
>
GetFrame
(
)
&
event
false
&
status
)
;
}
if
(
gfxPrefs
:
:
TestEventsAsyncEnabled
(
)
)
{
status
=
widget
-
>
DispatchInputEvent
(
&
event
)
;
}
else
{
nsresult
rv
=
widget
-
>
DispatchEvent
(
&
event
status
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
aPreventDefault
)
{
*
aPreventDefault
=
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
;
}
return
NS_OK
;
}
void
nsContentUtils
:
:
FirePageHideEvent
(
nsIDocShellTreeItem
*
aItem
EventTarget
*
aChromeEventHandler
bool
aOnlySystemGroup
)
{
RefPtr
<
Document
>
doc
=
aItem
-
>
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
What
happened
here
?
"
)
;
doc
-
>
OnPageHide
(
true
aChromeEventHandler
aOnlySystemGroup
)
;
int32_t
childCount
=
0
;
aItem
-
>
GetChildCount
(
&
childCount
)
;
AutoTArray
<
nsCOMPtr
<
nsIDocShellTreeItem
>
8
>
kids
;
kids
.
AppendElements
(
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
aItem
-
>
GetChildAt
(
i
getter_AddRefs
(
kids
[
i
]
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
kids
.
Length
(
)
;
+
+
i
)
{
if
(
kids
[
i
]
)
{
FirePageHideEvent
(
kids
[
i
]
aChromeEventHandler
aOnlySystemGroup
)
;
}
}
}
void
nsContentUtils
:
:
FirePageShowEvent
(
nsIDocShellTreeItem
*
aItem
EventTarget
*
aChromeEventHandler
bool
aFireIfShowing
bool
aOnlySystemGroup
)
{
int32_t
childCount
=
0
;
aItem
-
>
GetChildCount
(
&
childCount
)
;
AutoTArray
<
nsCOMPtr
<
nsIDocShellTreeItem
>
8
>
kids
;
kids
.
AppendElements
(
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
aItem
-
>
GetChildAt
(
i
getter_AddRefs
(
kids
[
i
]
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
kids
.
Length
(
)
;
+
+
i
)
{
if
(
kids
[
i
]
)
{
FirePageShowEvent
(
kids
[
i
]
aChromeEventHandler
aFireIfShowing
aOnlySystemGroup
)
;
}
}
RefPtr
<
Document
>
doc
=
aItem
-
>
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
What
happened
here
?
"
)
;
if
(
doc
-
>
IsShowing
(
)
=
=
aFireIfShowing
)
{
doc
-
>
OnPageShow
(
true
aChromeEventHandler
aOnlySystemGroup
)
;
}
}
already_AddRefed
<
nsPIWindowRoot
>
nsContentUtils
:
:
GetWindowRoot
(
Document
*
aDoc
)
{
if
(
aDoc
)
{
if
(
nsPIDOMWindowOuter
*
win
=
aDoc
-
>
GetWindow
(
)
)
{
return
win
-
>
GetTopWindowRoot
(
)
;
}
}
return
nullptr
;
}
bool
nsContentUtils
:
:
IsPreloadType
(
nsContentPolicyType
aType
)
{
return
(
aType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
|
|
aType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
|
|
aType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_STYLESHEET_PRELOAD
)
;
}
bool
nsContentUtils
:
:
IsUpgradableDisplayType
(
nsContentPolicyType
aType
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
(
aType
=
=
nsIContentPolicy
:
:
TYPE_IMAGE
|
|
aType
=
=
nsIContentPolicy
:
:
TYPE_MEDIA
)
;
}
nsresult
nsContentUtils
:
:
SetFetchReferrerURIWithPolicy
(
nsIPrincipal
*
aPrincipal
Document
*
aDoc
nsIHttpChannel
*
aChannel
mozilla
:
:
net
:
:
ReferrerPolicy
aReferrerPolicy
)
{
NS_ENSURE_ARG_POINTER
(
aPrincipal
)
;
NS_ENSURE_ARG_POINTER
(
aChannel
)
;
nsCOMPtr
<
nsIURI
>
principalURI
;
if
(
aPrincipal
-
>
IsSystemPrincipal
(
)
)
{
return
NS_OK
;
}
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
principalURI
)
)
;
if
(
!
aDoc
)
{
return
aChannel
-
>
SetReferrerWithPolicy
(
principalURI
aReferrerPolicy
)
;
}
nsCOMPtr
<
nsIURI
>
docCurURI
=
aDoc
-
>
GetDocumentURI
(
)
;
nsCOMPtr
<
nsIURI
>
docOrigURI
=
aDoc
-
>
GetOriginalURI
(
)
;
nsCOMPtr
<
nsIURI
>
referrerURI
;
if
(
principalURI
&
&
docCurURI
&
&
docOrigURI
)
{
bool
equal
=
false
;
principalURI
-
>
Equals
(
docOrigURI
&
equal
)
;
if
(
equal
)
{
referrerURI
=
docCurURI
;
}
}
if
(
!
referrerURI
)
{
referrerURI
=
principalURI
;
}
return
aChannel
-
>
SetReferrerWithPolicy
(
referrerURI
aReferrerPolicy
)
;
}
net
:
:
ReferrerPolicy
nsContentUtils
:
:
GetReferrerPolicyFromHeader
(
const
nsAString
&
aHeader
)
{
nsCharSeparatedTokenizer
tokenizer
(
aHeader
'
'
)
;
nsAutoString
token
;
net
:
:
ReferrerPolicy
referrerPolicy
=
mozilla
:
:
net
:
:
RP_Unset
;
while
(
tokenizer
.
hasMoreTokens
(
)
)
{
token
=
tokenizer
.
nextToken
(
)
;
if
(
token
.
IsEmpty
(
)
)
{
continue
;
}
net
:
:
ReferrerPolicy
policy
=
net
:
:
ReferrerPolicyFromString
(
token
)
;
if
(
policy
!
=
net
:
:
RP_Unset
)
{
referrerPolicy
=
policy
;
}
}
return
referrerPolicy
;
}
net
:
:
ReferrerPolicy
nsContentUtils
:
:
GetReferrerPolicyFromChannel
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
!
httpChannel
)
{
return
net
:
:
RP_Unset
;
}
nsresult
rv
;
nsAutoCString
headerValue
;
rv
=
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
referrer
-
policy
"
)
headerValue
)
;
if
(
NS_FAILED
(
rv
)
|
|
headerValue
.
IsEmpty
(
)
)
{
return
net
:
:
RP_Unset
;
}
return
GetReferrerPolicyFromHeader
(
NS_ConvertUTF8toUTF16
(
headerValue
)
)
;
}
bool
nsContentUtils
:
:
IsNonSubresourceRequest
(
nsIChannel
*
aChannel
)
{
nsLoadFlags
loadFlags
=
0
;
aChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
if
(
loadFlags
&
nsIChannel
:
:
LOAD_DOCUMENT_URI
)
{
return
true
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
if
(
!
loadInfo
)
{
return
false
;
}
nsContentPolicyType
type
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
return
IsNonSubresourceInternalPolicyType
(
type
)
;
}
bool
nsContentUtils
:
:
IsNonSubresourceInternalPolicyType
(
nsContentPolicyType
aType
)
{
return
aType
=
=
nsIContentPolicy
:
:
TYPE_DOCUMENT
|
|
aType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IFRAME
|
|
aType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_FRAME
|
|
aType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_WORKER
|
|
aType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_SHARED_WORKER
;
}
nsContentUtils
:
:
StorageAccess
nsContentUtils
:
:
StorageAllowedForWindow
(
nsPIDOMWindowInner
*
aWindow
uint32_t
*
aRejectedReason
)
{
uint32_t
rejectedReason
;
if
(
!
aRejectedReason
)
{
aRejectedReason
=
&
rejectedReason
;
}
*
aRejectedReason
=
0
;
if
(
Document
*
document
=
aWindow
-
>
GetExtantDoc
(
)
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
document
-
>
NodePrincipal
(
)
;
nsIChannel
*
channel
=
document
-
>
GetChannel
(
)
;
return
InternalStorageAllowedForPrincipal
(
principal
aWindow
nullptr
channel
*
aRejectedReason
)
;
}
return
StorageAccess
:
:
eDeny
;
}
nsContentUtils
:
:
StorageAccess
nsContentUtils
:
:
StorageAllowedForDocument
(
Document
*
aDoc
)
{
MOZ_ASSERT
(
aDoc
)
;
if
(
nsPIDOMWindowInner
*
inner
=
aDoc
-
>
GetInnerWindow
(
)
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
aDoc
-
>
NodePrincipal
(
)
;
nsIChannel
*
channel
=
aDoc
-
>
GetChannel
(
)
;
uint32_t
rejectedReason
=
0
;
return
InternalStorageAllowedForPrincipal
(
principal
inner
nullptr
channel
rejectedReason
)
;
}
return
StorageAccess
:
:
eDeny
;
}
nsContentUtils
:
:
StorageAccess
nsContentUtils
:
:
StorageAllowedForNewWindow
(
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
nsPIDOMWindowInner
*
aParent
)
{
MOZ_ASSERT
(
aPrincipal
)
;
MOZ_ASSERT
(
aURI
)
;
uint32_t
rejectedReason
=
0
;
return
InternalStorageAllowedForPrincipal
(
aPrincipal
aParent
aURI
nullptr
rejectedReason
)
;
}
nsContentUtils
:
:
StorageAccess
nsContentUtils
:
:
StorageAllowedForChannel
(
nsIChannel
*
aChannel
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sSecurityManager
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aChannel
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
Unused
<
<
sSecurityManager
-
>
GetChannelResultPrincipal
(
aChannel
getter_AddRefs
(
principal
)
)
;
NS_ENSURE_TRUE
(
principal
nsContentUtils
:
:
StorageAccess
:
:
eDeny
)
;
uint32_t
rejectedReason
=
0
;
nsContentUtils
:
:
StorageAccess
result
=
InternalStorageAllowedForPrincipal
(
principal
nullptr
nullptr
aChannel
rejectedReason
)
;
return
result
;
}
nsContentUtils
:
:
StorageAccess
nsContentUtils
:
:
StorageAllowedForPrincipal
(
nsIPrincipal
*
aPrincipal
)
{
uint32_t
rejectedReason
=
0
;
return
InternalStorageAllowedForPrincipal
(
aPrincipal
nullptr
nullptr
nullptr
rejectedReason
)
;
}
void
nsContentUtils
:
:
GetCookieLifetimePolicyForPrincipal
(
nsIPrincipal
*
aPrincipal
uint32_t
*
aLifetimePolicy
)
{
*
aLifetimePolicy
=
sCookiesLifetimePolicy
;
nsCOMPtr
<
nsIPermissionManager
>
permissionManager
=
services
:
:
GetPermissionManager
(
)
;
if
(
!
permissionManager
)
{
return
;
}
uint32_t
perm
;
permissionManager
-
>
TestPermissionFromPrincipal
(
aPrincipal
"
cookie
"
&
perm
)
;
switch
(
perm
)
{
case
nsICookiePermission
:
:
ACCESS_ALLOW
:
*
aLifetimePolicy
=
nsICookieService
:
:
ACCEPT_NORMALLY
;
break
;
case
nsICookiePermission
:
:
ACCESS_DENY
:
*
aLifetimePolicy
=
nsICookieService
:
:
ACCEPT_NORMALLY
;
break
;
case
nsICookiePermission
:
:
ACCESS_SESSION
:
*
aLifetimePolicy
=
nsICookieService
:
:
ACCEPT_SESSION
;
break
;
}
}
bool
nsContentUtils
:
:
IsThirdPartyWindowOrChannel
(
nsPIDOMWindowInner
*
aWindow
nsIChannel
*
aChannel
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
!
aWindow
|
|
!
aChannel
"
A
window
and
channel
should
not
both
be
provided
.
"
)
;
nsCOMPtr
<
mozIThirdPartyUtil
>
thirdPartyUtil
=
services
:
:
GetThirdPartyUtil
(
)
;
if
(
!
thirdPartyUtil
)
{
return
false
;
}
bool
thirdParty
=
false
;
if
(
aWindow
)
{
nsresult
rv
=
thirdPartyUtil
-
>
IsThirdPartyWindow
(
aWindow
-
>
GetOuterWindow
(
)
aURI
&
thirdParty
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
}
if
(
aChannel
)
{
nsresult
rv
=
thirdPartyUtil
-
>
IsThirdPartyChannel
(
aChannel
nullptr
&
thirdParty
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
thirdParty
=
true
;
}
bool
isThirdPartyWindow
=
true
;
nsCOMPtr
<
nsIHttpChannelInternal
>
chan
=
do_QueryInterface
(
aChannel
&
rv
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
chan
)
{
nsCOMPtr
<
nsIURI
>
topWinURI
;
rv
=
chan
-
>
GetTopWindowURI
(
getter_AddRefs
(
topWinURI
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
topWinURI
)
{
rv
=
thirdPartyUtil
-
>
IsThirdPartyURI
(
aURI
topWinURI
&
isThirdPartyWindow
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
thirdParty
=
thirdParty
&
&
isThirdPartyWindow
;
}
}
}
}
return
thirdParty
;
}
bool
nsContentUtils
:
:
IsTrackingResourceWindow
(
nsPIDOMWindowInner
*
aWindow
)
{
MOZ_ASSERT
(
aWindow
)
;
Document
*
document
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
!
document
)
{
return
false
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
document
-
>
GetChannel
(
)
)
;
if
(
!
httpChannel
)
{
return
false
;
}
return
httpChannel
-
>
GetIsTrackingResource
(
)
;
}
bool
nsContentUtils
:
:
IsThirdPartyTrackingResourceWindow
(
nsPIDOMWindowInner
*
aWindow
)
{
MOZ_ASSERT
(
aWindow
)
;
Document
*
document
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
!
document
)
{
return
false
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
document
-
>
GetChannel
(
)
)
;
if
(
!
httpChannel
)
{
return
false
;
}
return
httpChannel
-
>
GetIsThirdPartyTrackingResource
(
)
;
}
static
bool
StorageDisabledByAntiTrackingInternal
(
nsPIDOMWindowInner
*
aWindow
nsIChannel
*
aChannel
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
uint32_t
&
aRejectedReason
)
{
MOZ_ASSERT
(
aWindow
|
|
aChannel
|
|
aPrincipal
)
;
if
(
aWindow
)
{
nsIURI
*
documentURI
=
aURI
?
aURI
:
aWindow
-
>
GetDocumentURI
(
)
;
return
!
documentURI
|
|
!
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
aWindow
documentURI
&
aRejectedReason
)
;
}
if
(
aChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
!
httpChannel
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
httpChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
return
!
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
httpChannel
uri
&
aRejectedReason
)
;
}
MOZ_ASSERT
(
aPrincipal
)
;
return
!
AntiTrackingCommon
:
:
IsFirstPartyStorageAccessGrantedFor
(
aPrincipal
)
;
}
bool
nsContentUtils
:
:
StorageDisabledByAntiTracking
(
nsPIDOMWindowInner
*
aWindow
nsIChannel
*
aChannel
nsIPrincipal
*
aPrincipal
nsIURI
*
aURI
uint32_t
&
aRejectedReason
)
{
bool
disabled
=
StorageDisabledByAntiTrackingInternal
(
aWindow
aChannel
aPrincipal
aURI
aRejectedReason
)
;
if
(
sAntiTrackingControlCenterUIEnabled
)
{
if
(
aWindow
)
{
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
aWindow
disabled
?
AntiTrackingCommon
:
:
BlockingDecision
:
:
eBlock
:
AntiTrackingCommon
:
:
BlockingDecision
:
:
eAllow
aRejectedReason
)
;
}
else
if
(
aChannel
)
{
AntiTrackingCommon
:
:
NotifyBlockingDecision
(
aChannel
disabled
?
AntiTrackingCommon
:
:
BlockingDecision
:
:
eBlock
:
AntiTrackingCommon
:
:
BlockingDecision
:
:
eAllow
aRejectedReason
)
;
}
}
return
disabled
;
}
nsContentUtils
:
:
StorageAccess
nsContentUtils
:
:
InternalStorageAllowedForPrincipal
(
nsIPrincipal
*
aPrincipal
nsPIDOMWindowInner
*
aWindow
nsIURI
*
aURI
nsIChannel
*
aChannel
uint32_t
&
aRejectedReason
)
{
MOZ_ASSERT
(
aPrincipal
)
;
aRejectedReason
=
0
;
StorageAccess
access
=
StorageAccess
:
:
eAllow
;
if
(
aPrincipal
-
>
GetIsNullPrincipal
(
)
)
{
return
StorageAccess
:
:
eDeny
;
}
if
(
aWindow
)
{
Document
*
document
=
aWindow
-
>
GetExtantDoc
(
)
;
if
(
document
&
&
document
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
{
return
StorageAccess
:
:
eDeny
;
}
if
(
IsInPrivateBrowsing
(
document
)
)
{
access
=
StorageAccess
:
:
ePrivateBrowsing
;
}
}
uint32_t
lifetimePolicy
;
auto
policy
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
-
>
AddonPolicy
(
)
;
if
(
policy
)
{
lifetimePolicy
=
nsICookieService
:
:
ACCEPT_NORMALLY
;
}
else
{
GetCookieLifetimePolicyForPrincipal
(
aPrincipal
&
lifetimePolicy
)
;
}
if
(
lifetimePolicy
=
=
nsICookieService
:
:
ACCEPT_SESSION
)
{
access
=
std
:
:
min
(
StorageAccess
:
:
eSessionScoped
access
)
;
}
nsCOMPtr
<
nsIURI
>
uri
=
aURI
;
if
(
!
uri
)
{
Unused
<
<
aPrincipal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
}
if
(
uri
)
{
bool
isAbout
=
false
;
MOZ_ALWAYS_SUCCEEDS
(
uri
-
>
SchemeIs
(
"
about
"
&
isAbout
)
)
;
if
(
isAbout
)
{
return
access
;
}
}
if
(
!
StorageDisabledByAntiTracking
(
aWindow
aChannel
aPrincipal
aURI
aRejectedReason
)
)
{
return
access
;
}
if
(
aRejectedReason
=
=
nsIWebProgressListener
:
:
STATE_COOKIES_BLOCKED_TRACKER
)
{
return
StorageAccess
:
:
ePartitionedOrDeny
;
}
return
StorageAccess
:
:
eDeny
;
}
namespace
{
class
BulkAppender
{
typedef
typename
nsAString
:
:
size_type
size_type
;
public
:
explicit
BulkAppender
(
BulkWriteHandle
<
char16_t
>
&
&
aHandle
)
:
mHandle
(
std
:
:
move
(
aHandle
)
)
mPosition
(
0
)
{
}
~
BulkAppender
(
)
=
default
;
template
<
int
N
>
void
AppendLiteral
(
const
char16_t
(
&
aStr
)
[
N
]
)
{
size_t
len
=
N
-
1
;
MOZ_ASSERT
(
mPosition
+
len
<
=
mHandle
.
Length
(
)
)
;
memcpy
(
mHandle
.
Elements
(
)
+
mPosition
aStr
len
*
sizeof
(
char16_t
)
)
;
mPosition
+
=
len
;
}
void
Append
(
Span
<
const
char16_t
>
aStr
)
{
size_t
len
=
aStr
.
Length
(
)
;
MOZ_ASSERT
(
mPosition
+
len
<
=
mHandle
.
Length
(
)
)
;
memcpy
(
mHandle
.
Elements
(
)
+
mPosition
aStr
.
Elements
(
)
len
*
sizeof
(
char16_t
)
)
;
mPosition
+
=
len
;
}
void
Append
(
Span
<
const
char
>
aStr
)
{
size_t
len
=
aStr
.
Length
(
)
;
MOZ_ASSERT
(
mPosition
+
len
<
=
mHandle
.
Length
(
)
)
;
ConvertLatin1toUTF16
(
aStr
mHandle
.
AsSpan
(
)
.
From
(
mPosition
)
)
;
mPosition
+
=
len
;
}
void
Finish
(
)
{
mHandle
.
Finish
(
mPosition
false
)
;
}
private
:
mozilla
:
:
BulkWriteHandle
<
char16_t
>
mHandle
;
size_type
mPosition
;
}
;
class
StringBuilder
{
private
:
static
const
uint32_t
STRING_BUFFER_UNITS
=
1020
;
class
Unit
{
public
:
Unit
(
)
:
mAtom
(
nullptr
)
mType
(
eUnknown
)
mLength
(
0
)
{
MOZ_COUNT_CTOR
(
StringBuilder
:
:
Unit
)
;
}
~
Unit
(
)
{
if
(
mType
=
=
eString
|
|
mType
=
=
eStringWithEncode
)
{
delete
mString
;
}
MOZ_COUNT_DTOR
(
StringBuilder
:
:
Unit
)
;
}
enum
Type
{
eUnknown
eAtom
eString
eStringWithEncode
eLiteral
eTextFragment
eTextFragmentWithEncode
}
;
union
{
nsAtom
*
mAtom
;
const
char16_t
*
mLiteral
;
nsAutoString
*
mString
;
const
nsTextFragment
*
mTextFragment
;
}
;
Type
mType
;
uint32_t
mLength
;
}
;
public
:
StringBuilder
(
)
:
mLast
(
this
)
mLength
(
0
)
{
MOZ_COUNT_CTOR
(
StringBuilder
)
;
}
~
StringBuilder
(
)
{
MOZ_COUNT_DTOR
(
StringBuilder
)
;
}
void
Append
(
nsAtom
*
aAtom
)
{
Unit
*
u
=
AddUnit
(
)
;
u
-
>
mAtom
=
aAtom
;
u
-
>
mType
=
Unit
:
:
eAtom
;
uint32_t
len
=
aAtom
-
>
GetLength
(
)
;
u
-
>
mLength
=
len
;
mLength
+
=
len
;
}
template
<
int
N
>
void
Append
(
const
char16_t
(
&
aLiteral
)
[
N
]
)
{
Unit
*
u
=
AddUnit
(
)
;
u
-
>
mLiteral
=
aLiteral
;
u
-
>
mType
=
Unit
:
:
eLiteral
;
uint32_t
len
=
N
-
1
;
u
-
>
mLength
=
len
;
mLength
+
=
len
;
}
void
Append
(
const
nsAString
&
aString
)
{
Unit
*
u
=
AddUnit
(
)
;
u
-
>
mString
=
new
nsAutoString
(
aString
)
;
u
-
>
mType
=
Unit
:
:
eString
;
uint32_t
len
=
aString
.
Length
(
)
;
u
-
>
mLength
=
len
;
mLength
+
=
len
;
}
void
Append
(
nsAutoString
*
aString
)
{
Unit
*
u
=
AddUnit
(
)
;
u
-
>
mString
=
aString
;
u
-
>
mType
=
Unit
:
:
eString
;
uint32_t
len
=
aString
-
>
Length
(
)
;
u
-
>
mLength
=
len
;
mLength
+
=
len
;
}
void
AppendWithAttrEncode
(
nsAutoString
*
aString
uint32_t
aLen
)
{
Unit
*
u
=
AddUnit
(
)
;
u
-
>
mString
=
aString
;
u
-
>
mType
=
Unit
:
:
eStringWithEncode
;
u
-
>
mLength
=
aLen
;
mLength
+
=
aLen
;
}
void
Append
(
const
nsTextFragment
*
aTextFragment
)
{
Unit
*
u
=
AddUnit
(
)
;
u
-
>
mTextFragment
=
aTextFragment
;
u
-
>
mType
=
Unit
:
:
eTextFragment
;
uint32_t
len
=
aTextFragment
-
>
GetLength
(
)
;
u
-
>
mLength
=
len
;
mLength
+
=
len
;
}
void
AppendWithEncode
(
const
nsTextFragment
*
aTextFragment
uint32_t
aLen
)
{
Unit
*
u
=
AddUnit
(
)
;
u
-
>
mTextFragment
=
aTextFragment
;
u
-
>
mType
=
Unit
:
:
eTextFragmentWithEncode
;
u
-
>
mLength
=
aLen
;
mLength
+
=
aLen
;
}
bool
ToString
(
nsAString
&
aOut
)
{
if
(
!
mLength
.
isValid
(
)
)
{
return
false
;
}
nsresult
rv
;
BulkAppender
appender
(
aOut
.
BulkWrite
(
mLength
.
value
(
)
0
true
rv
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
for
(
StringBuilder
*
current
=
this
;
current
;
current
=
current
-
>
mNext
)
{
uint32_t
len
=
current
-
>
mUnits
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
Unit
&
u
=
current
-
>
mUnits
[
i
]
;
switch
(
u
.
mType
)
{
case
Unit
:
:
eAtom
:
appender
.
Append
(
*
(
u
.
mAtom
)
)
;
break
;
case
Unit
:
:
eString
:
appender
.
Append
(
*
(
u
.
mString
)
)
;
break
;
case
Unit
:
:
eStringWithEncode
:
EncodeAttrString
(
*
(
u
.
mString
)
appender
)
;
break
;
case
Unit
:
:
eLiteral
:
appender
.
Append
(
MakeSpan
(
u
.
mLiteral
u
.
mLength
)
)
;
break
;
case
Unit
:
:
eTextFragment
:
if
(
u
.
mTextFragment
-
>
Is2b
(
)
)
{
appender
.
Append
(
MakeSpan
(
u
.
mTextFragment
-
>
Get2b
(
)
u
.
mTextFragment
-
>
GetLength
(
)
)
)
;
}
else
{
appender
.
Append
(
MakeSpan
(
u
.
mTextFragment
-
>
Get1b
(
)
u
.
mTextFragment
-
>
GetLength
(
)
)
)
;
}
break
;
case
Unit
:
:
eTextFragmentWithEncode
:
if
(
u
.
mTextFragment
-
>
Is2b
(
)
)
{
EncodeTextFragment
(
MakeSpan
(
u
.
mTextFragment
-
>
Get2b
(
)
u
.
mTextFragment
-
>
GetLength
(
)
)
appender
)
;
}
else
{
EncodeTextFragment
(
MakeSpan
(
u
.
mTextFragment
-
>
Get1b
(
)
u
.
mTextFragment
-
>
GetLength
(
)
)
appender
)
;
}
break
;
default
:
MOZ_CRASH
(
"
Unknown
unit
type
?
"
)
;
}
}
}
appender
.
Finish
(
)
;
return
true
;
}
private
:
Unit
*
AddUnit
(
)
{
if
(
mLast
-
>
mUnits
.
Length
(
)
=
=
STRING_BUFFER_UNITS
)
{
new
StringBuilder
(
this
)
;
}
return
mLast
-
>
mUnits
.
AppendElement
(
)
;
}
explicit
StringBuilder
(
StringBuilder
*
aFirst
)
:
mLast
(
nullptr
)
mLength
(
0
)
{
MOZ_COUNT_CTOR
(
StringBuilder
)
;
aFirst
-
>
mLast
-
>
mNext
=
this
;
aFirst
-
>
mLast
=
this
;
}
void
EncodeAttrString
(
Span
<
const
char16_t
>
aStr
BulkAppender
&
aAppender
)
{
size_t
flushedUntil
=
0
;
size_t
currentPosition
=
0
;
for
(
char16_t
c
:
aStr
)
{
switch
(
c
)
{
case
'
"
'
:
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
aAppender
.
AppendLiteral
(
u
"
&
quot
;
"
)
;
flushedUntil
=
currentPosition
+
1
;
break
;
case
'
&
'
:
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
aAppender
.
AppendLiteral
(
u
"
&
amp
;
"
)
;
flushedUntil
=
currentPosition
+
1
;
break
;
case
0x00A0
:
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
aAppender
.
AppendLiteral
(
u
"
&
nbsp
;
"
)
;
flushedUntil
=
currentPosition
+
1
;
break
;
default
:
break
;
}
currentPosition
+
+
;
}
if
(
currentPosition
>
flushedUntil
)
{
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
}
}
template
<
class
T
>
void
EncodeTextFragment
(
Span
<
const
T
>
aStr
BulkAppender
&
aAppender
)
{
size_t
flushedUntil
=
0
;
size_t
currentPosition
=
0
;
for
(
T
c
:
aStr
)
{
switch
(
c
)
{
case
'
<
'
:
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
aAppender
.
AppendLiteral
(
u
"
&
lt
;
"
)
;
flushedUntil
=
currentPosition
+
1
;
break
;
case
'
>
'
:
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
aAppender
.
AppendLiteral
(
u
"
&
gt
;
"
)
;
flushedUntil
=
currentPosition
+
1
;
break
;
case
'
&
'
:
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
aAppender
.
AppendLiteral
(
u
"
&
amp
;
"
)
;
flushedUntil
=
currentPosition
+
1
;
break
;
case
T
(
0xA0
)
:
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
aAppender
.
AppendLiteral
(
u
"
&
nbsp
;
"
)
;
flushedUntil
=
currentPosition
+
1
;
break
;
default
:
break
;
}
currentPosition
+
+
;
}
if
(
currentPosition
>
flushedUntil
)
{
aAppender
.
Append
(
aStr
.
FromTo
(
flushedUntil
currentPosition
)
)
;
}
}
AutoTArray
<
Unit
STRING_BUFFER_UNITS
>
mUnits
;
nsAutoPtr
<
StringBuilder
>
mNext
;
StringBuilder
*
mLast
;
CheckedInt
<
uint32_t
>
mLength
;
}
;
}
static
void
AppendEncodedCharacters
(
const
nsTextFragment
*
aText
StringBuilder
&
aBuilder
)
{
uint32_t
extraSpaceNeeded
=
0
;
uint32_t
len
=
aText
-
>
GetLength
(
)
;
if
(
aText
-
>
Is2b
(
)
)
{
const
char16_t
*
data
=
aText
-
>
Get2b
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
char16_t
c
=
data
[
i
]
;
switch
(
c
)
{
case
'
<
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
lt
;
"
)
-
2
;
break
;
case
'
>
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
gt
;
"
)
-
2
;
break
;
case
'
&
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
amp
;
"
)
-
2
;
break
;
case
0x00A0
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
nbsp
;
"
)
-
2
;
break
;
default
:
break
;
}
}
}
else
{
const
char
*
data
=
aText
-
>
Get1b
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
unsigned
char
c
=
data
[
i
]
;
switch
(
c
)
{
case
'
<
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
lt
;
"
)
-
2
;
break
;
case
'
>
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
gt
;
"
)
-
2
;
break
;
case
'
&
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
amp
;
"
)
-
2
;
break
;
case
0x00A0
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
nbsp
;
"
)
-
2
;
break
;
default
:
break
;
}
}
}
if
(
extraSpaceNeeded
)
{
aBuilder
.
AppendWithEncode
(
aText
len
+
extraSpaceNeeded
)
;
}
else
{
aBuilder
.
Append
(
aText
)
;
}
}
static
void
AppendEncodedAttributeValue
(
nsAutoString
*
aValue
StringBuilder
&
aBuilder
)
{
const
char16_t
*
c
=
aValue
-
>
BeginReading
(
)
;
const
char16_t
*
end
=
aValue
-
>
EndReading
(
)
;
uint32_t
extraSpaceNeeded
=
0
;
while
(
c
<
end
)
{
switch
(
*
c
)
{
case
'
"
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
quot
;
"
)
-
2
;
break
;
case
'
&
'
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
amp
;
"
)
-
2
;
break
;
case
0x00A0
:
extraSpaceNeeded
+
=
ArrayLength
(
"
&
nbsp
;
"
)
-
2
;
break
;
default
:
break
;
}
+
+
c
;
}
if
(
extraSpaceNeeded
)
{
aBuilder
.
AppendWithAttrEncode
(
aValue
aValue
-
>
Length
(
)
+
extraSpaceNeeded
)
;
}
else
{
aBuilder
.
Append
(
aValue
)
;
}
}
static
void
StartElement
(
Element
*
aContent
StringBuilder
&
aBuilder
)
{
nsAtom
*
localName
=
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
int32_t
tagNS
=
aContent
-
>
GetNameSpaceID
(
)
;
aBuilder
.
Append
(
u
"
<
"
)
;
if
(
aContent
-
>
IsHTMLElement
(
)
|
|
aContent
-
>
IsSVGElement
(
)
|
|
aContent
-
>
IsMathMLElement
(
)
)
{
aBuilder
.
Append
(
localName
)
;
}
else
{
aBuilder
.
Append
(
aContent
-
>
NodeName
(
)
)
;
}
CustomElementData
*
ceData
=
aContent
-
>
GetCustomElementData
(
)
;
if
(
ceData
)
{
nsAtom
*
isAttr
=
ceData
-
>
GetIs
(
aContent
)
;
if
(
isAttr
&
&
!
aContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
is
)
)
{
aBuilder
.
Append
(
uR
"
(
is
=
"
)
"
)
;
aBuilder
.
Append
(
nsDependentAtomString
(
isAttr
)
)
;
aBuilder
.
Append
(
uR
"
(
"
)
"
)
;
}
}
int32_t
count
=
aContent
-
>
GetAttrCount
(
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
const
nsAttrName
*
name
=
aContent
-
>
GetAttrNameAt
(
i
)
;
int32_t
attNs
=
name
-
>
NamespaceID
(
)
;
nsAtom
*
attName
=
name
-
>
LocalName
(
)
;
nsDependentAtomString
attrNameStr
(
attName
)
;
if
(
StringBeginsWith
(
attrNameStr
NS_LITERAL_STRING
(
"
_moz
"
)
)
|
|
StringBeginsWith
(
attrNameStr
NS_LITERAL_STRING
(
"
-
moz
"
)
)
)
{
continue
;
}
auto
*
attValue
=
new
nsAutoString
(
)
;
aContent
-
>
GetAttr
(
attNs
attName
*
attValue
)
;
if
(
localName
=
=
nsGkAtoms
:
:
br
&
&
tagNS
=
=
kNameSpaceID_XHTML
&
&
attName
=
=
nsGkAtoms
:
:
type
&
&
attNs
=
=
kNameSpaceID_None
&
&
StringBeginsWith
(
*
attValue
NS_LITERAL_STRING
(
"
_moz
"
)
)
)
{
delete
attValue
;
continue
;
}
aBuilder
.
Append
(
u
"
"
)
;
if
(
MOZ_LIKELY
(
attNs
=
=
kNameSpaceID_None
)
|
|
(
attNs
=
=
kNameSpaceID_XMLNS
&
&
attName
=
=
nsGkAtoms
:
:
xmlns
)
)
{
}
else
if
(
attNs
=
=
kNameSpaceID_XML
)
{
aBuilder
.
Append
(
u
"
xml
:
"
)
;
}
else
if
(
attNs
=
=
kNameSpaceID_XMLNS
)
{
aBuilder
.
Append
(
u
"
xmlns
:
"
)
;
}
else
if
(
attNs
=
=
kNameSpaceID_XLink
)
{
aBuilder
.
Append
(
u
"
xlink
:
"
)
;
}
else
{
nsAtom
*
prefix
=
name
-
>
GetPrefix
(
)
;
if
(
prefix
)
{
aBuilder
.
Append
(
prefix
)
;
aBuilder
.
Append
(
u
"
:
"
)
;
}
}
aBuilder
.
Append
(
attName
)
;
aBuilder
.
Append
(
uR
"
(
=
"
)
"
)
;
AppendEncodedAttributeValue
(
attValue
aBuilder
)
;
aBuilder
.
Append
(
uR
"
(
"
)
"
)
;
}
aBuilder
.
Append
(
u
"
>
"
)
;
}
static
inline
bool
ShouldEscape
(
nsIContent
*
aParent
)
{
if
(
!
aParent
|
|
!
aParent
-
>
IsHTMLElement
(
)
)
{
return
true
;
}
static
const
nsAtom
*
nonEscapingElements
[
]
=
{
nsGkAtoms
:
:
style
nsGkAtoms
:
:
script
nsGkAtoms
:
:
xmp
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
noembed
nsGkAtoms
:
:
noframes
nsGkAtoms
:
:
plaintext
nsGkAtoms
:
:
noscript
}
;
static
mozilla
:
:
BloomFilter
<
12
nsAtom
>
sFilter
;
static
bool
sInitialized
=
false
;
if
(
!
sInitialized
)
{
sInitialized
=
true
;
for
(
auto
&
nonEscapingElement
:
nonEscapingElements
)
{
sFilter
.
add
(
nonEscapingElement
)
;
}
}
nsAtom
*
tag
=
aParent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
sFilter
.
mightContain
(
tag
)
)
{
for
(
auto
&
nonEscapingElement
:
nonEscapingElements
)
{
if
(
tag
=
=
nonEscapingElement
)
{
return
false
;
}
}
}
return
true
;
}
static
inline
bool
IsVoidTag
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
return
FragmentOrElement
:
:
IsHTMLVoid
(
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
bool
nsContentUtils
:
:
SerializeNodeToMarkup
(
nsINode
*
aRoot
bool
aDescendentsOnly
nsAString
&
aOut
)
{
MOZ_ASSERT
(
aDescendentsOnly
|
|
aRoot
-
>
NodeType
(
)
!
=
nsINode
:
:
DOCUMENT_NODE
)
;
nsINode
*
current
=
aDescendentsOnly
?
nsNodeUtils
:
:
GetFirstChildOfTemplateOrNode
(
aRoot
)
:
aRoot
;
if
(
!
current
)
{
return
true
;
}
StringBuilder
builder
;
nsIContent
*
next
;
while
(
true
)
{
bool
isVoid
=
false
;
switch
(
current
-
>
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
{
Element
*
elem
=
current
-
>
AsElement
(
)
;
StartElement
(
elem
builder
)
;
isVoid
=
IsVoidTag
(
elem
)
;
if
(
!
isVoid
&
&
(
next
=
nsNodeUtils
:
:
GetFirstChildOfTemplateOrNode
(
current
)
)
)
{
current
=
next
;
continue
;
}
break
;
}
case
nsINode
:
:
TEXT_NODE
:
case
nsINode
:
:
CDATA_SECTION_NODE
:
{
const
nsTextFragment
*
text
=
static_cast
<
nsIContent
*
>
(
current
)
-
>
GetText
(
)
;
nsIContent
*
parent
=
current
-
>
GetParent
(
)
;
if
(
ShouldEscape
(
parent
)
)
{
AppendEncodedCharacters
(
text
builder
)
;
}
else
{
builder
.
Append
(
text
)
;
}
break
;
}
case
nsINode
:
:
COMMENT_NODE
:
{
builder
.
Append
(
u
"
<
!
-
-
"
)
;
builder
.
Append
(
static_cast
<
nsIContent
*
>
(
current
)
-
>
GetText
(
)
)
;
builder
.
Append
(
u
"
-
-
>
"
)
;
break
;
}
case
nsINode
:
:
DOCUMENT_TYPE_NODE
:
{
builder
.
Append
(
u
"
<
!
DOCTYPE
"
)
;
builder
.
Append
(
current
-
>
NodeName
(
)
)
;
builder
.
Append
(
u
"
>
"
)
;
break
;
}
case
nsINode
:
:
PROCESSING_INSTRUCTION_NODE
:
{
builder
.
Append
(
u
"
<
?
"
)
;
builder
.
Append
(
current
-
>
NodeName
(
)
)
;
builder
.
Append
(
u
"
"
)
;
builder
.
Append
(
static_cast
<
nsIContent
*
>
(
current
)
-
>
GetText
(
)
)
;
builder
.
Append
(
u
"
>
"
)
;
break
;
}
}
while
(
true
)
{
if
(
!
isVoid
&
&
current
-
>
NodeType
(
)
=
=
nsINode
:
:
ELEMENT_NODE
)
{
builder
.
Append
(
u
"
<
/
"
)
;
nsIContent
*
elem
=
static_cast
<
nsIContent
*
>
(
current
)
;
if
(
elem
-
>
IsHTMLElement
(
)
|
|
elem
-
>
IsSVGElement
(
)
|
|
elem
-
>
IsMathMLElement
(
)
)
{
builder
.
Append
(
elem
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
}
else
{
builder
.
Append
(
current
-
>
NodeName
(
)
)
;
}
builder
.
Append
(
u
"
>
"
)
;
}
isVoid
=
false
;
if
(
current
=
=
aRoot
)
{
return
builder
.
ToString
(
aOut
)
;
}
if
(
(
next
=
current
-
>
GetNextSibling
(
)
)
)
{
current
=
next
;
break
;
}
current
=
current
-
>
GetParentNode
(
)
;
if
(
current
!
=
aRoot
&
&
current
-
>
NodeType
(
)
=
=
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
DocumentFragment
*
frag
=
static_cast
<
DocumentFragment
*
>
(
current
)
;
nsIContent
*
fragHost
=
frag
-
>
GetHost
(
)
;
if
(
fragHost
&
&
nsNodeUtils
:
:
IsTemplateElement
(
fragHost
)
)
{
current
=
fragHost
;
}
}
if
(
aDescendentsOnly
&
&
current
=
=
aRoot
)
{
return
builder
.
ToString
(
aOut
)
;
}
}
}
}
bool
nsContentUtils
:
:
IsSpecificAboutPage
(
JSObject
*
aGlobal
const
char
*
aUri
)
{
MOZ_ASSERT
(
strncmp
(
aUri
"
about
:
"
6
)
=
=
0
)
;
MOZ_DIAGNOSTIC_ASSERT
(
JS_IsGlobalObject
(
aGlobal
)
)
;
nsGlobalWindowInner
*
win
=
xpc
:
:
WindowOrNull
(
aGlobal
)
;
if
(
!
win
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
win
-
>
GetPrincipal
(
)
;
NS_ENSURE_TRUE
(
principal
false
)
;
nsCOMPtr
<
nsIURI
>
uri
;
principal
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
if
(
!
uri
)
{
return
false
;
}
bool
isAbout
=
false
;
uri
-
>
SchemeIs
(
"
about
"
&
isAbout
)
;
if
(
!
isAbout
)
{
return
false
;
}
nsAutoCString
spec
;
uri
-
>
GetSpecIgnoringRef
(
spec
)
;
return
spec
.
EqualsASCII
(
aUri
)
;
}
void
nsContentUtils
:
:
SetScrollbarsVisibility
(
nsIDocShell
*
aDocShell
bool
aVisible
)
{
nsCOMPtr
<
nsIScrollable
>
scroller
=
do_QueryInterface
(
aDocShell
)
;
if
(
scroller
)
{
int32_t
prefValue
;
if
(
aVisible
)
{
prefValue
=
nsIScrollable
:
:
Scrollbar_Auto
;
}
else
{
prefValue
=
nsIScrollable
:
:
Scrollbar_Never
;
}
scroller
-
>
SetDefaultScrollbarPreferences
(
nsIScrollable
:
:
ScrollOrientation_Y
prefValue
)
;
scroller
-
>
SetDefaultScrollbarPreferences
(
nsIScrollable
:
:
ScrollOrientation_X
prefValue
)
;
}
}
void
nsContentUtils
:
:
GetPresentationURL
(
nsIDocShell
*
aDocShell
nsAString
&
aPresentationUrl
)
{
MOZ_ASSERT
(
aDocShell
)
;
if
(
Preferences
:
:
GetBool
(
"
dom
.
presentation
.
testing
.
simulate
-
receiver
"
)
)
{
RefPtr
<
Document
>
doc
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
docShellWin
=
do_QueryInterface
(
aDocShell
-
>
GetScriptGlobalObject
(
)
)
;
if
(
docShellWin
)
{
doc
=
docShellWin
-
>
GetExtantDoc
(
)
;
}
if
(
NS_WARN_IF
(
!
doc
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
=
doc
-
>
GetDocumentURI
(
)
;
if
(
NS_WARN_IF
(
!
uri
)
)
{
return
;
}
nsAutoCString
uriStr
;
uri
-
>
GetSpec
(
uriStr
)
;
aPresentationUrl
=
NS_ConvertUTF8toUTF16
(
uriStr
)
;
return
;
}
if
(
XRE_IsContentProcess
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
sameTypeRoot
;
aDocShell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
sameTypeRoot
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
aDocShell
-
>
GetRootTreeItem
(
getter_AddRefs
(
root
)
)
;
if
(
sameTypeRoot
.
get
(
)
=
=
root
.
get
(
)
)
{
TabChild
*
tabChild
=
TabChild
:
:
GetFrom
(
aDocShell
)
;
if
(
tabChild
)
{
aPresentationUrl
=
tabChild
-
>
PresentationURL
(
)
;
}
return
;
}
}
nsCOMPtr
<
nsILoadContext
>
loadContext
(
do_QueryInterface
(
aDocShell
)
)
;
RefPtr
<
Element
>
topFrameElt
;
loadContext
-
>
GetTopFrameElement
(
getter_AddRefs
(
topFrameElt
)
)
;
if
(
!
topFrameElt
)
{
return
;
}
topFrameElt
-
>
GetAttribute
(
NS_LITERAL_STRING
(
"
mozpresentation
"
)
aPresentationUrl
)
;
}
nsIDocShell
*
nsContentUtils
:
:
GetDocShellForEventTarget
(
EventTarget
*
aTarget
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
innerWindow
;
if
(
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aTarget
)
)
{
bool
ignore
;
innerWindow
=
do_QueryInterface
(
node
-
>
OwnerDoc
(
)
-
>
GetScriptHandlingObject
(
ignore
)
)
;
}
else
if
(
(
innerWindow
=
do_QueryInterface
(
aTarget
)
)
)
{
}
else
{
nsCOMPtr
<
DOMEventTargetHelper
>
helper
=
do_QueryInterface
(
aTarget
)
;
if
(
helper
)
{
innerWindow
=
helper
-
>
GetOwner
(
)
;
}
}
if
(
innerWindow
)
{
return
innerWindow
-
>
GetDocShell
(
)
;
}
return
nullptr
;
}
bool
nsContentUtils
:
:
HttpsStateIsModern
(
Document
*
aDocument
)
{
if
(
!
aDocument
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aDocument
-
>
NodePrincipal
(
)
;
if
(
principal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
if
(
principal
-
>
GetIsNullPrincipal
(
)
&
&
(
aDocument
-
>
GetSandboxFlags
(
)
&
SANDBOXED_ORIGIN
)
)
{
nsIChannel
*
channel
=
aDocument
-
>
GetChannel
(
)
;
if
(
channel
)
{
nsCOMPtr
<
nsIScriptSecurityManager
>
ssm
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsresult
rv
=
ssm
-
>
GetChannelResultPrincipalIfNotSandboxed
(
channel
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
principal
-
>
IsSystemPrincipal
(
)
)
{
return
false
;
}
}
}
if
(
principal
-
>
GetIsNullPrincipal
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
principal
-
>
GetIsCodebasePrincipal
(
)
)
;
nsCOMPtr
<
nsIContentSecurityManager
>
csm
=
do_GetService
(
NS_CONTENTSECURITYMANAGER_CONTRACTID
)
;
NS_WARNING_ASSERTION
(
csm
"
csm
is
null
"
)
;
if
(
csm
)
{
bool
isTrustworthyOrigin
=
false
;
csm
-
>
IsOriginPotentiallyTrustworthy
(
principal
&
isTrustworthyOrigin
)
;
if
(
isTrustworthyOrigin
)
{
return
true
;
}
}
return
false
;
}
void
nsContentUtils
:
:
TryToUpgradeElement
(
Element
*
aElement
)
{
NodeInfo
*
nodeInfo
=
aElement
-
>
NodeInfo
(
)
;
RefPtr
<
nsAtom
>
typeAtom
=
aElement
-
>
GetCustomElementData
(
)
-
>
GetCustomElementType
(
)
;
MOZ_ASSERT
(
nodeInfo
-
>
NameAtom
(
)
-
>
Equals
(
nodeInfo
-
>
LocalName
(
)
)
)
;
CustomElementDefinition
*
definition
=
nsContentUtils
:
:
LookupCustomElementDefinition
(
nodeInfo
-
>
GetDocument
(
)
nodeInfo
-
>
NameAtom
(
)
nodeInfo
-
>
NamespaceID
(
)
typeAtom
)
;
if
(
definition
)
{
nsContentUtils
:
:
EnqueueUpgradeReaction
(
aElement
definition
)
;
}
else
{
nsContentUtils
:
:
RegisterUnresolvedElement
(
aElement
typeAtom
)
;
}
}
static
void
DoCustomElementCreate
(
Element
*
*
aElement
Document
*
aDoc
NodeInfo
*
aNodeInfo
CustomElementConstructor
*
aConstructor
ErrorResult
&
aRv
)
{
RefPtr
<
Element
>
element
=
aConstructor
-
>
Construct
(
"
Custom
Element
Create
"
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
;
}
if
(
aNodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
)
{
if
(
!
element
|
|
!
element
-
>
IsHTMLElement
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_THIS_DOES_NOT_IMPLEMENT_INTERFACE
>
(
NS_LITERAL_STRING
(
"
HTMLElement
"
)
)
;
return
;
}
}
else
{
if
(
!
element
|
|
!
element
-
>
IsXULElement
(
)
)
{
aRv
.
ThrowTypeError
<
MSG_THIS_DOES_NOT_IMPLEMENT_INTERFACE
>
(
NS_LITERAL_STRING
(
"
XULElement
"
)
)
;
return
;
}
}
nsAtom
*
localName
=
aNodeInfo
-
>
NameAtom
(
)
;
if
(
aDoc
!
=
element
-
>
OwnerDoc
(
)
|
|
element
-
>
GetParentNode
(
)
|
|
element
-
>
HasChildren
(
)
|
|
element
-
>
GetAttrCount
(
)
|
|
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
localName
)
{
aRv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
;
}
element
.
forget
(
aElement
)
;
}
nsresult
nsContentUtils
:
:
NewXULOrHTMLElement
(
Element
*
*
aResult
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
FromParser
aFromParser
nsAtom
*
aIsAtom
mozilla
:
:
dom
:
:
CustomElementDefinition
*
aDefinition
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
aNodeInfo
;
MOZ_ASSERT
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
|
|
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XUL
)
"
Can
only
create
XUL
or
XHTML
elements
.
"
)
;
nsAtom
*
name
=
nodeInfo
-
>
NameAtom
(
)
;
int32_t
tag
=
eHTMLTag_unknown
;
bool
isCustomElementName
=
false
;
if
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
)
{
tag
=
nsHTMLTags
:
:
CaseSensitiveAtomTagToId
(
name
)
;
isCustomElementName
=
(
tag
=
=
eHTMLTag_userdefined
&
&
nsContentUtils
:
:
IsCustomElementName
(
name
kNameSpaceID_XHTML
)
)
;
}
else
{
if
(
aIsAtom
)
{
if
(
nsContentUtils
:
:
IsNameWithDash
(
aIsAtom
)
&
&
!
nsContentUtils
:
:
IsNameWithDash
(
name
)
)
{
isCustomElementName
=
false
;
}
else
{
isCustomElementName
=
nsContentUtils
:
:
IsCustomElementName
(
name
kNameSpaceID_XUL
)
;
}
}
else
{
isCustomElementName
=
nsContentUtils
:
:
IsCustomElementName
(
name
kNameSpaceID_XUL
)
;
}
}
nsAtom
*
tagAtom
=
nodeInfo
-
>
NameAtom
(
)
;
nsAtom
*
typeAtom
=
nullptr
;
bool
isCustomElement
=
isCustomElementName
|
|
aIsAtom
;
if
(
isCustomElement
)
{
typeAtom
=
isCustomElementName
?
tagAtom
:
aIsAtom
;
}
MOZ_ASSERT_IF
(
aDefinition
isCustomElement
)
;
CustomElementDefinition
*
definition
=
aDefinition
;
if
(
isCustomElement
&
&
!
definition
)
{
MOZ_ASSERT
(
nodeInfo
-
>
NameAtom
(
)
-
>
Equals
(
nodeInfo
-
>
LocalName
(
)
)
)
;
definition
=
nsContentUtils
:
:
LookupCustomElementDefinition
(
nodeInfo
-
>
GetDocument
(
)
nodeInfo
-
>
NameAtom
(
)
nodeInfo
-
>
NamespaceID
(
)
typeAtom
)
;
}
if
(
definition
)
{
bool
synchronousCustomElements
=
aFromParser
!
=
dom
:
:
FROM_PARSER_FRAGMENT
|
|
aFromParser
=
=
dom
:
:
NOT_FROM_PARSER
;
nsIGlobalObject
*
global
;
if
(
aFromParser
=
=
dom
:
:
NOT_FROM_PARSER
)
{
global
=
GetEntryGlobal
(
)
;
if
(
!
global
)
{
Document
*
doc
=
nodeInfo
-
>
GetDocument
(
)
;
if
(
doc
&
&
doc
-
>
IsXULDocument
(
)
)
{
global
=
doc
-
>
GetScopeObject
(
)
;
}
}
}
else
{
global
=
nodeInfo
-
>
GetDocument
(
)
-
>
GetScopeObject
(
)
;
}
if
(
!
global
)
{
return
NS_ERROR_FAILURE
;
}
AutoEntryScript
aes
(
global
"
create
custom
elements
"
)
;
JSContext
*
cx
=
aes
.
cx
(
)
;
ErrorResult
rv
;
if
(
definition
-
>
IsCustomBuiltIn
(
)
)
{
if
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
)
{
*
aResult
=
CreateHTMLElement
(
tag
nodeInfo
.
forget
(
)
aFromParser
)
.
take
(
)
;
}
else
{
NS_IF_ADDREF
(
*
aResult
=
nsXULElement
:
:
Construct
(
nodeInfo
.
forget
(
)
)
)
;
}
(
*
aResult
)
-
>
SetCustomElementData
(
new
CustomElementData
(
typeAtom
)
)
;
if
(
synchronousCustomElements
)
{
CustomElementRegistry
:
:
Upgrade
(
*
aResult
definition
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
aes
.
ReportException
(
)
;
}
}
else
{
nsContentUtils
:
:
EnqueueUpgradeReaction
(
*
aResult
definition
)
;
}
return
NS_OK
;
}
if
(
synchronousCustomElements
)
{
definition
-
>
mPrefixStack
.
AppendElement
(
nodeInfo
-
>
GetPrefixAtom
(
)
)
;
DoCustomElementCreate
(
aResult
nodeInfo
-
>
GetDocument
(
)
nodeInfo
definition
-
>
mConstructor
rv
)
;
if
(
rv
.
MaybeSetPendingException
(
cx
)
)
{
if
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
)
{
NS_IF_ADDREF
(
*
aResult
=
NS_NewHTMLUnknownElement
(
nodeInfo
.
forget
(
)
aFromParser
)
)
;
}
else
{
NS_IF_ADDREF
(
*
aResult
=
nsXULElement
:
:
Construct
(
nodeInfo
.
forget
(
)
)
)
;
}
(
*
aResult
)
-
>
SetDefined
(
false
)
;
}
definition
-
>
mPrefixStack
.
RemoveLastElement
(
)
;
return
NS_OK
;
}
if
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
)
{
NS_IF_ADDREF
(
*
aResult
=
NS_NewHTMLElement
(
nodeInfo
.
forget
(
)
aFromParser
)
)
;
}
else
{
NS_IF_ADDREF
(
*
aResult
=
nsXULElement
:
:
Construct
(
nodeInfo
.
forget
(
)
)
)
;
}
(
*
aResult
)
-
>
SetCustomElementData
(
new
CustomElementData
(
definition
-
>
mType
)
)
;
nsContentUtils
:
:
EnqueueUpgradeReaction
(
*
aResult
definition
)
;
return
NS_OK
;
}
if
(
nodeInfo
-
>
NamespaceEquals
(
kNameSpaceID_XHTML
)
)
{
if
(
isCustomElementName
)
{
NS_IF_ADDREF
(
*
aResult
=
NS_NewHTMLElement
(
nodeInfo
.
forget
(
)
aFromParser
)
)
;
}
else
{
*
aResult
=
CreateHTMLElement
(
tag
nodeInfo
.
forget
(
)
aFromParser
)
.
take
(
)
;
}
}
else
{
NS_IF_ADDREF
(
*
aResult
=
nsXULElement
:
:
Construct
(
nodeInfo
.
forget
(
)
)
)
;
}
if
(
!
*
aResult
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
isCustomElement
)
{
(
*
aResult
)
-
>
SetCustomElementData
(
new
CustomElementData
(
typeAtom
)
)
;
nsContentUtils
:
:
RegisterCallbackUpgradeElement
(
*
aResult
typeAtom
)
;
}
return
NS_OK
;
}
CustomElementRegistry
*
nsContentUtils
:
:
GetCustomElementRegistry
(
Document
*
aDoc
)
{
MOZ_ASSERT
(
aDoc
)
;
if
(
!
aDoc
-
>
GetDocShell
(
)
)
{
return
nullptr
;
}
nsPIDOMWindowInner
*
window
=
aDoc
-
>
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
return
window
-
>
CustomElements
(
)
;
}
CustomElementDefinition
*
nsContentUtils
:
:
LookupCustomElementDefinition
(
Document
*
aDoc
nsAtom
*
aNameAtom
uint32_t
aNameSpaceID
nsAtom
*
aTypeAtom
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_XUL
&
&
aNameSpaceID
!
=
kNameSpaceID_XHTML
)
{
return
nullptr
;
}
RefPtr
<
CustomElementRegistry
>
registry
=
GetCustomElementRegistry
(
aDoc
)
;
if
(
!
registry
)
{
return
nullptr
;
}
return
registry
-
>
LookupCustomElementDefinition
(
aNameAtom
aNameSpaceID
aTypeAtom
)
;
}
void
nsContentUtils
:
:
RegisterCallbackUpgradeElement
(
Element
*
aElement
nsAtom
*
aTypeName
)
{
MOZ_ASSERT
(
aElement
)
;
Document
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
CustomElementRegistry
*
registry
=
GetCustomElementRegistry
(
doc
)
;
if
(
registry
)
{
registry
-
>
RegisterCallbackUpgradeElement
(
aElement
aTypeName
)
;
}
}
void
nsContentUtils
:
:
RegisterUnresolvedElement
(
Element
*
aElement
nsAtom
*
aTypeName
)
{
MOZ_ASSERT
(
aElement
)
;
Document
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
CustomElementRegistry
*
registry
=
GetCustomElementRegistry
(
doc
)
;
if
(
registry
)
{
registry
-
>
RegisterUnresolvedElement
(
aElement
aTypeName
)
;
}
}
void
nsContentUtils
:
:
UnregisterUnresolvedElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
nsAtom
*
typeAtom
=
aElement
-
>
GetCustomElementData
(
)
-
>
GetCustomElementType
(
)
;
Document
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
CustomElementRegistry
*
registry
=
GetCustomElementRegistry
(
doc
)
;
if
(
registry
)
{
registry
-
>
UnregisterUnresolvedElement
(
aElement
typeAtom
)
;
}
}
void
nsContentUtils
:
:
EnqueueUpgradeReaction
(
Element
*
aElement
CustomElementDefinition
*
aDefinition
)
{
MOZ_ASSERT
(
aElement
)
;
Document
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
if
(
!
doc
-
>
GetDocGroup
(
)
)
{
return
;
}
CustomElementReactionsStack
*
stack
=
doc
-
>
GetDocGroup
(
)
-
>
CustomElementReactionsStack
(
)
;
stack
-
>
EnqueueUpgradeReaction
(
aElement
aDefinition
)
;
}
void
nsContentUtils
:
:
EnqueueLifecycleCallback
(
Document
:
:
ElementCallbackType
aType
Element
*
aCustomElement
LifecycleCallbackArgs
*
aArgs
LifecycleAdoptedCallbackArgs
*
aAdoptedCallbackArgs
CustomElementDefinition
*
aDefinition
)
{
if
(
!
aCustomElement
-
>
OwnerDoc
(
)
-
>
GetDocGroup
(
)
)
{
return
;
}
CustomElementRegistry
:
:
EnqueueLifecycleCallback
(
aType
aCustomElement
aArgs
aAdoptedCallbackArgs
aDefinition
)
;
}
bool
nsContentUtils
:
:
AttemptLargeAllocationLoad
(
nsIHttpChannel
*
aChannel
)
{
MOZ_ASSERT
(
aChannel
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsresult
rv
=
aChannel
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
!
loadGroup
)
)
{
return
false
;
}
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
rv
=
loadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
!
callbacks
)
)
{
return
false
;
}
nsCOMPtr
<
nsILoadContext
>
loadContext
=
do_GetInterface
(
callbacks
)
;
if
(
NS_WARN_IF
(
!
loadContext
)
)
{
return
false
;
}
nsCOMPtr
<
mozIDOMWindowProxy
>
window
;
rv
=
loadContext
-
>
GetAssociatedWindow
(
getter_AddRefs
(
window
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
|
|
!
window
)
)
{
return
false
;
}
nsPIDOMWindowOuter
*
outer
=
nsPIDOMWindowOuter
:
:
From
(
window
)
;
if
(
NS_WARN_IF
(
!
outer
)
)
{
return
false
;
}
if
(
!
XRE_IsContentProcess
(
)
)
{
outer
-
>
SetLargeAllocStatus
(
LargeAllocStatus
:
:
NON_E10S
)
;
return
false
;
}
nsIDocShell
*
docShell
=
outer
-
>
GetDocShell
(
)
;
if
(
!
docShell
-
>
GetIsOnlyToplevelInTabGroup
(
)
)
{
outer
-
>
SetLargeAllocStatus
(
LargeAllocStatus
:
:
NOT_ONLY_TOPLEVEL_IN_TABGROUP
)
;
return
false
;
}
nsAutoCString
requestMethod
;
rv
=
aChannel
-
>
GetRequestMethod
(
requestMethod
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
NS_WARN_IF
(
!
requestMethod
.
LowerCaseEqualsLiteral
(
"
get
"
)
)
)
{
outer
-
>
SetLargeAllocStatus
(
LargeAllocStatus
:
:
NON_GET
)
;
return
false
;
}
TabChild
*
tabChild
=
TabChild
:
:
GetFrom
(
outer
-
>
AsOuter
(
)
)
;
NS_ENSURE_TRUE
(
tabChild
false
)
;
if
(
tabChild
-
>
IsAwaitingLargeAlloc
(
)
)
{
NS_WARNING
(
"
In
a
Large
-
Allocation
TabChild
ignoring
Large
-
Allocation
header
!
"
)
;
tabChild
-
>
StopAwaitingLargeAlloc
(
)
;
outer
-
>
SetLargeAllocStatus
(
LargeAllocStatus
:
:
SUCCESS
)
;
return
false
;
}
#
if
defined
(
XP_WIN
)
&
&
defined
(
_X86_
)
const
bool
isWin32
=
true
;
#
else
const
bool
isWin32
=
false
;
#
endif
static
bool
sLargeAllocForceEnable
=
false
;
static
bool
sCachedLargeAllocForceEnable
=
false
;
if
(
!
sCachedLargeAllocForceEnable
)
{
sCachedLargeAllocForceEnable
=
true
;
mozilla
:
:
Preferences
:
:
AddBoolVarCache
(
&
sLargeAllocForceEnable
"
dom
.
largeAllocation
.
forceEnable
"
)
;
}
bool
largeAllocEnabled
=
isWin32
|
|
sLargeAllocForceEnable
;
if
(
!
largeAllocEnabled
)
{
NS_WARNING
(
"
dom
.
largeAllocation
.
forceEnable
not
set
-
"
"
ignoring
otherwise
successful
Large
-
Allocation
header
.
"
)
;
outer
-
>
SetLargeAllocStatus
(
LargeAllocStatus
:
:
NON_WIN32
)
;
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
docShell
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
NS_ENSURE_TRUE
(
treeOwner
false
)
;
nsCOMPtr
<
nsIWebBrowserChrome3
>
wbc3
=
do_GetInterface
(
treeOwner
)
;
NS_ENSURE_TRUE
(
wbc3
false
)
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
NS_ENSURE_TRUE
(
uri
false
)
;
nsCOMPtr
<
nsIURI
>
referrer
;
rv
=
aChannel
-
>
GetReferrer
(
getter_AddRefs
(
referrer
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
GetLoadInfo
(
)
;
if
(
!
loadInfo
)
{
return
false
;
}
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
loadInfo
-
>
TriggeringPrincipal
(
)
;
nsLoadFlags
channelLoadFlags
;
aChannel
-
>
GetLoadFlags
(
&
channelLoadFlags
)
;
uint32_t
webnavLoadFlags
=
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
;
if
(
channelLoadFlags
&
nsIRequest
:
:
LOAD_BYPASS_CACHE
)
{
webnavLoadFlags
|
=
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_CACHE
;
webnavLoadFlags
|
=
nsIWebNavigation
:
:
LOAD_FLAGS_BYPASS_PROXY
;
}
else
if
(
channelLoadFlags
&
nsIRequest
:
:
VALIDATE_ALWAYS
)
{
webnavLoadFlags
|
=
nsIWebNavigation
:
:
LOAD_FLAGS_IS_REFRESH
;
}
bool
reloadSucceeded
=
false
;
rv
=
wbc3
-
>
ReloadInFreshProcess
(
docShell
uri
referrer
triggeringPrincipal
webnavLoadFlags
&
reloadSucceeded
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
reloadSucceeded
;
}
void
nsContentUtils
:
:
AppendDocumentLevelNativeAnonymousContentTo
(
Document
*
aDocument
nsTArray
<
nsIContent
*
>
&
aElements
)
{
MOZ_ASSERT
(
aDocument
)
;
#
ifdef
DEBUG
size_t
oldLength
=
aElements
.
Length
(
)
;
#
endif
if
(
nsIPresShell
*
presShell
=
aDocument
-
>
GetShell
(
)
)
{
if
(
nsIFrame
*
scrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
)
{
nsIAnonymousContentCreator
*
creator
=
do_QueryFrame
(
scrollFrame
)
;
MOZ_ASSERT
(
creator
"
scroll
frame
should
always
implement
nsIAnonymousContentCreator
"
)
;
creator
-
>
AppendAnonymousContentTo
(
aElements
0
)
;
}
if
(
nsCanvasFrame
*
canvasFrame
=
presShell
-
>
GetCanvasFrame
(
)
)
{
if
(
Element
*
container
=
canvasFrame
-
>
GetCustomContentContainer
(
)
)
{
aElements
.
AppendElement
(
container
)
;
}
}
}
#
ifdef
DEBUG
for
(
size_t
i
=
oldLength
;
i
<
aElements
.
Length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
aElements
[
i
]
-
>
GetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
)
"
Someone
here
has
lied
or
missed
to
flag
the
node
"
)
;
}
#
endif
}
static
void
AppendNativeAnonymousChildrenFromFrame
(
nsIFrame
*
aFrame
nsTArray
<
nsIContent
*
>
&
aKids
uint32_t
aFlags
)
{
if
(
nsIAnonymousContentCreator
*
ac
=
do_QueryFrame
(
aFrame
)
)
{
ac
-
>
AppendAnonymousContentTo
(
aKids
aFlags
)
;
}
}
void
nsContentUtils
:
:
AppendNativeAnonymousChildren
(
const
nsIContent
*
aContent
nsTArray
<
nsIContent
*
>
&
aKids
uint32_t
aFlags
)
{
if
(
aContent
-
>
MayHaveAnonymousChildren
(
)
)
{
if
(
nsIFrame
*
primaryFrame
=
aContent
-
>
GetPrimaryFrame
(
)
)
{
AppendNativeAnonymousChildrenFromFrame
(
primaryFrame
aKids
aFlags
)
;
AutoTArray
<
nsIFrame
:
:
OwnedAnonBox
8
>
ownedAnonBoxes
;
primaryFrame
-
>
AppendOwnedAnonBoxes
(
ownedAnonBoxes
)
;
for
(
nsIFrame
:
:
OwnedAnonBox
&
box
:
ownedAnonBoxes
)
{
MOZ_ASSERT
(
box
.
mAnonBoxFrame
-
>
GetContent
(
)
=
=
aContent
)
;
AppendNativeAnonymousChildrenFromFrame
(
box
.
mAnonBoxFrame
aKids
aFlags
)
;
}
}
if
(
auto
nac
=
static_cast
<
ManualNACArray
*
>
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
manualNACProperty
)
)
)
{
aKids
.
AppendElements
(
*
nac
)
;
}
}
if
(
!
(
aFlags
&
nsIContent
:
:
eSkipDocumentLevelNativeAnonymousContent
)
&
&
aContent
=
=
aContent
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
)
{
AppendDocumentLevelNativeAnonymousContentTo
(
aContent
-
>
OwnerDoc
(
)
aKids
)
;
}
}
bool
nsContentUtils
:
:
QueryTriggeringPrincipal
(
nsIContent
*
aLoadingNode
nsIPrincipal
*
aDefaultPrincipal
nsIPrincipal
*
*
aTriggeringPrincipal
)
{
MOZ_ASSERT
(
aLoadingNode
)
;
MOZ_ASSERT
(
aTriggeringPrincipal
)
;
bool
result
=
false
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
aDefaultPrincipal
;
if
(
!
loadingPrincipal
)
{
loadingPrincipal
=
aLoadingNode
-
>
NodePrincipal
(
)
;
}
if
(
!
aLoadingNode
-
>
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
loadingPrincipal
.
forget
(
aTriggeringPrincipal
)
;
return
result
;
}
nsAutoString
loadingStr
;
if
(
aLoadingNode
-
>
IsElement
(
)
)
{
aLoadingNode
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
triggeringprincipal
loadingStr
)
;
}
if
(
loadingStr
.
IsEmpty
(
)
)
{
loadingPrincipal
.
forget
(
aTriggeringPrincipal
)
;
return
result
;
}
nsCOMPtr
<
nsISupports
>
serializedPrincipal
;
NS_DeserializeObject
(
NS_ConvertUTF16toUTF8
(
loadingStr
)
getter_AddRefs
(
serializedPrincipal
)
)
;
nsCOMPtr
<
nsIPrincipal
>
serializedPrin
=
do_QueryInterface
(
serializedPrincipal
)
;
if
(
serializedPrin
)
{
result
=
true
;
serializedPrin
.
forget
(
aTriggeringPrincipal
)
;
}
else
{
loadingPrincipal
.
forget
(
aTriggeringPrincipal
)
;
}
return
result
;
}
void
nsContentUtils
:
:
GetContentPolicyTypeForUIImageLoading
(
nsIContent
*
aLoadingNode
nsIPrincipal
*
*
aTriggeringPrincipal
nsContentPolicyType
&
aContentPolicyType
uint64_t
*
aRequestContextID
)
{
MOZ_ASSERT
(
aRequestContextID
)
;
bool
result
=
QueryTriggeringPrincipal
(
aLoadingNode
aTriggeringPrincipal
)
;
if
(
result
)
{
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
;
nsAutoString
requestContextID
;
if
(
aLoadingNode
-
>
IsElement
(
)
)
{
aLoadingNode
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
requestcontextid
requestContextID
)
;
}
nsresult
rv
;
int64_t
val
=
requestContextID
.
ToInteger64
(
&
rv
)
;
*
aRequestContextID
=
NS_SUCCEEDED
(
rv
)
?
val
:
0
;
}
else
{
aContentPolicyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
;
}
}
nsresult
nsContentUtils
:
:
CreateJSValueFromSequenceOfObject
(
JSContext
*
aCx
const
Sequence
<
JSObject
*
>
&
aTransfer
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
)
{
if
(
aTransfer
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
JS
:
:
Rooted
<
JSObject
*
>
array
(
aCx
JS_NewArrayObject
(
aCx
aTransfer
.
Length
(
)
)
)
;
if
(
!
array
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
for
(
uint32_t
i
=
0
;
i
<
aTransfer
.
Length
(
)
;
+
+
i
)
{
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
aTransfer
[
i
]
)
;
if
(
!
object
)
{
continue
;
}
if
(
NS_WARN_IF
(
!
JS_DefineElement
(
aCx
array
i
object
JSPROP_ENUMERATE
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
aValue
.
setObject
(
*
array
)
;
return
NS_OK
;
}
bool
nsContentUtils
:
:
ShouldBlockReservedKeys
(
WidgetKeyboardEvent
*
aKeyEvent
)
{
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
Element
>
targetElement
=
do_QueryInterface
(
aKeyEvent
-
>
mOriginalTarget
)
;
nsCOMPtr
<
nsIBrowser
>
targetBrowser
;
if
(
targetElement
)
{
targetBrowser
=
targetElement
-
>
AsBrowser
(
)
;
}
bool
isRemoteBrowser
=
false
;
if
(
targetBrowser
)
{
targetBrowser
-
>
GetIsRemoteBrowser
(
&
isRemoteBrowser
)
;
}
if
(
isRemoteBrowser
)
{
targetBrowser
-
>
GetContentPrincipal
(
getter_AddRefs
(
principal
)
)
;
}
else
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aKeyEvent
-
>
mOriginalTarget
)
;
if
(
content
)
{
Document
*
doc
=
content
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShell
=
doc
-
>
GetDocShell
(
)
;
if
(
docShell
&
&
docShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
docShell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
rootItem
&
&
rootItem
-
>
GetDocument
(
)
)
{
principal
=
rootItem
-
>
GetDocument
(
)
-
>
NodePrincipal
(
)
;
}
}
}
}
}
if
(
principal
)
{
return
nsContentUtils
:
:
IsSitePermDeny
(
principal
"
shortcuts
"
)
;
}
return
false
;
}
static
bool
HtmlObjectContentSupportsDocument
(
const
nsCString
&
aMimeType
nsIContent
*
aContent
)
{
nsCOMPtr
<
nsIWebNavigationInfo
>
info
(
do_GetService
(
NS_WEBNAVIGATION_INFO_CONTRACTID
)
)
;
if
(
!
info
)
{
return
false
;
}
nsCOMPtr
<
nsIWebNavigation
>
webNav
;
if
(
aContent
)
{
Document
*
currentDoc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
currentDoc
)
{
webNav
=
do_GetInterface
(
currentDoc
-
>
GetWindow
(
)
)
;
}
}
uint32_t
supported
;
nsresult
rv
=
info
-
>
IsTypeSupported
(
aMimeType
webNav
&
supported
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
if
(
supported
!
=
nsIWebNavigationInfo
:
:
UNSUPPORTED
)
{
return
supported
!
=
nsIWebNavigationInfo
:
:
PLUGIN
;
}
nsCOMPtr
<
nsIStreamConverterService
>
convServ
=
do_GetService
(
"
mozilla
.
org
/
streamConverters
;
1
"
)
;
bool
canConvert
=
false
;
if
(
convServ
)
{
rv
=
convServ
-
>
CanConvert
(
aMimeType
.
get
(
)
"
*
/
*
"
&
canConvert
)
;
}
return
NS_SUCCEEDED
(
rv
)
&
&
canConvert
;
}
already_AddRefed
<
nsIPluginTag
>
nsContentUtils
:
:
PluginTagForType
(
const
nsCString
&
aMIMEType
bool
aNoFakePlugin
)
{
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
nsCOMPtr
<
nsIPluginTag
>
tag
;
NS_ENSURE_TRUE
(
pluginHost
nullptr
)
;
pluginHost
-
>
GetPluginTagForType
(
aMIMEType
aNoFakePlugin
?
nsPluginHost
:
:
eExcludeFake
:
nsPluginHost
:
:
eExcludeNone
getter_AddRefs
(
tag
)
)
;
return
tag
.
forget
(
)
;
}
uint32_t
nsContentUtils
:
:
HtmlObjectContentTypeForMIMEType
(
const
nsCString
&
aMIMEType
bool
aNoFakePlugin
nsIContent
*
aContent
)
{
if
(
aMIMEType
.
IsEmpty
(
)
)
{
return
nsIObjectLoadingContent
:
:
TYPE_NULL
;
}
if
(
imgLoader
:
:
SupportImageWithMimeType
(
aMIMEType
.
get
(
)
)
)
{
return
nsIObjectLoadingContent
:
:
TYPE_IMAGE
;
}
if
(
aMIMEType
.
LowerCaseEqualsLiteral
(
"
application
/
pdf
"
)
&
&
IsPDFJSEnabled
(
)
)
{
return
nsIObjectLoadingContent
:
:
TYPE_DOCUMENT
;
}
if
(
HtmlObjectContentSupportsDocument
(
aMIMEType
aContent
)
)
{
return
nsIObjectLoadingContent
:
:
TYPE_DOCUMENT
;
}
RefPtr
<
nsPluginHost
>
pluginHost
=
nsPluginHost
:
:
GetInst
(
)
;
if
(
pluginHost
)
{
nsCOMPtr
<
nsIPluginTag
>
tag
=
PluginTagForType
(
aMIMEType
aNoFakePlugin
)
;
if
(
tag
)
{
if
(
!
aNoFakePlugin
&
&
nsCOMPtr
<
nsIFakePluginTag
>
(
do_QueryInterface
(
tag
)
)
)
{
return
nsIObjectLoadingContent
:
:
TYPE_FAKE_PLUGIN
;
}
return
nsIObjectLoadingContent
:
:
TYPE_PLUGIN
;
}
}
return
nsIObjectLoadingContent
:
:
TYPE_NULL
;
}
already_AddRefed
<
nsISerialEventTarget
>
nsContentUtils
:
:
GetEventTargetByLoadInfo
(
nsILoadInfo
*
aLoadInfo
TaskCategory
aCategory
)
{
if
(
NS_WARN_IF
(
!
aLoadInfo
)
)
{
return
nullptr
;
}
RefPtr
<
Document
>
doc
;
aLoadInfo
-
>
GetLoadingDocument
(
getter_AddRefs
(
doc
)
)
;
nsCOMPtr
<
nsISerialEventTarget
>
target
;
if
(
doc
)
{
if
(
DocGroup
*
group
=
doc
-
>
GetDocGroup
(
)
)
{
target
=
group
-
>
EventTargetFor
(
aCategory
)
;
}
}
else
{
uint64_t
outerWindowId
;
if
(
NS_FAILED
(
aLoadInfo
-
>
GetOuterWindowID
(
&
outerWindowId
)
)
)
{
return
nullptr
;
}
RefPtr
<
nsGlobalWindowOuter
>
window
=
nsGlobalWindowOuter
:
:
GetOuterWindowWithId
(
outerWindowId
)
;
if
(
!
window
)
{
return
nullptr
;
}
target
=
window
-
>
TabGroup
(
)
-
>
EventTargetFor
(
aCategory
)
;
}
return
target
.
forget
(
)
;
}
bool
nsContentUtils
:
:
IsLocalRefURL
(
const
nsString
&
aString
)
{
return
!
aString
.
IsEmpty
(
)
&
&
aString
[
0
]
=
=
'
#
'
;
}
static
const
uint64_t
kIdProcessBits
=
32
;
static
const
uint64_t
kIdBits
=
64
-
kIdProcessBits
;
uint64_t
GenerateProcessSpecificId
(
uint64_t
aId
)
{
uint64_t
processId
=
0
;
if
(
XRE_IsContentProcess
(
)
)
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
processId
=
cc
-
>
GetID
(
)
;
}
MOZ_RELEASE_ASSERT
(
processId
<
(
uint64_t
(
1
)
<
<
kIdProcessBits
)
)
;
uint64_t
processBits
=
processId
&
(
(
uint64_t
(
1
)
<
<
kIdProcessBits
)
-
1
)
;
uint64_t
id
=
aId
;
MOZ_RELEASE_ASSERT
(
id
<
(
uint64_t
(
1
)
<
<
kIdBits
)
)
;
uint64_t
bits
=
id
&
(
(
uint64_t
(
1
)
<
<
kIdBits
)
-
1
)
;
if
(
recordreplay
:
:
IsMiddleman
(
)
)
{
bits
|
=
uint64_t
(
1
)
<
<
(
kIdBits
-
1
)
;
}
return
(
processBits
<
<
kIdBits
)
|
bits
;
}
static
uint64_t
gNextTabId
=
0
;
uint64_t
nsContentUtils
:
:
GenerateTabId
(
)
{
return
GenerateProcessSpecificId
(
+
+
gNextTabId
)
;
}
static
uint64_t
gNextBrowsingContextId
=
0
;
uint64_t
nsContentUtils
:
:
GenerateBrowsingContextId
(
)
{
return
GenerateProcessSpecificId
(
+
+
gNextBrowsingContextId
)
;
}
bool
nsContentUtils
:
:
GetUserIsInteracting
(
)
{
return
UserInteractionObserver
:
:
sUserActive
;
}
bool
nsContentUtils
:
:
GetSourceMapURL
(
nsIHttpChannel
*
aChannel
nsACString
&
aResult
)
{
nsresult
rv
=
aChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
SourceMap
"
)
aResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
aChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
X
-
SourceMap
"
)
aResult
)
;
}
return
NS_SUCCEEDED
(
rv
)
;
}
bool
nsContentUtils
:
:
IsMessageInputEvent
(
const
IPC
:
:
Message
&
aMsg
)
{
if
(
(
aMsg
.
type
(
)
&
mozilla
:
:
dom
:
:
PBrowser
:
:
PBrowserStart
)
=
=
mozilla
:
:
dom
:
:
PBrowser
:
:
PBrowserStart
)
{
switch
(
aMsg
.
type
(
)
)
{
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_RealMouseMoveEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_RealMouseButtonEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_RealKeyEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_MouseWheelEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_RealTouchEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_RealTouchMoveEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_RealDragEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_UpdateDimensions__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_MouseEvent__ID
:
case
mozilla
:
:
dom
:
:
PBrowser
:
:
Msg_SetDocShellIsActive__ID
:
return
true
;
}
}
return
false
;
}
static
const
char
*
kUserInteractionInactive
=
"
user
-
interaction
-
inactive
"
;
static
const
char
*
kUserInteractionActive
=
"
user
-
interaction
-
active
"
;
void
nsContentUtils
:
:
UserInteractionObserver
:
:
Init
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obs
-
>
AddObserver
(
this
kUserInteractionInactive
false
)
;
obs
-
>
AddObserver
(
this
kUserInteractionActive
false
)
;
RefPtr
<
UserInteractionObserver
>
self
=
this
;
NS_DispatchToMainThread
(
NS_NewRunnableFunction
(
"
nsContentUtils
:
:
UserInteractionObserver
:
:
Init
"
[
=
]
(
)
{
BackgroundHangMonitor
:
:
RegisterAnnotator
(
*
self
)
;
}
)
)
;
}
void
nsContentUtils
:
:
UserInteractionObserver
:
:
Shutdown
(
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
kUserInteractionInactive
)
;
obs
-
>
RemoveObserver
(
this
kUserInteractionActive
)
;
}
BackgroundHangMonitor
:
:
UnregisterAnnotator
(
*
this
)
;
}
void
nsContentUtils
:
:
UserInteractionObserver
:
:
AnnotateHang
(
BackgroundHangAnnotations
&
aAnnotations
)
{
if
(
sUserActive
)
{
aAnnotations
.
AddAnnotation
(
NS_LITERAL_STRING
(
"
UserInteracting
"
)
true
)
;
}
}
NS_IMETHODIMP
nsContentUtils
:
:
UserInteractionObserver
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
strcmp
(
aTopic
kUserInteractionInactive
)
)
{
sUserActive
=
false
;
}
else
if
(
!
strcmp
(
aTopic
kUserInteractionActive
)
)
{
sUserActive
=
true
;
}
else
{
NS_WARNING
(
"
Unexpected
observer
notification
"
)
;
}
return
NS_OK
;
}
Atomic
<
bool
>
nsContentUtils
:
:
UserInteractionObserver
:
:
sUserActive
(
false
)
;
NS_IMPL_ISUPPORTS
(
nsContentUtils
:
:
UserInteractionObserver
nsIObserver
)
bool
nsContentUtils
:
:
IsOverridingWindowName
(
const
nsAString
&
aName
)
{
return
!
aName
.
IsEmpty
(
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_top
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_parent
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_self
"
)
;
}
#
define
EXTRACT_EXN_VALUES
(
T
.
.
.
)
\
ExtractExceptionValues
<
mozilla
:
:
dom
:
:
prototypes
:
:
id
:
:
T
\
T
#
#
_Binding
:
:
NativeType
T
>
(
__VA_ARGS__
)
\
.
isOk
(
)
template
<
prototypes
:
:
ID
PrototypeID
class
NativeType
typename
T
>
static
Result
<
Ok
nsresult
>
ExtractExceptionValues
(
JSContext
*
aCx
JS
:
:
HandleObject
aObj
nsAString
&
aSourceSpecOut
uint32_t
*
aLineOut
uint32_t
*
aColumnOut
nsString
&
aMessageOut
)
{
RefPtr
<
T
>
exn
;
MOZ_TRY
(
(
UnwrapObject
<
PrototypeID
NativeType
>
(
aObj
exn
)
)
)
;
exn
-
>
GetFilename
(
aCx
aSourceSpecOut
)
;
if
(
!
aSourceSpecOut
.
IsEmpty
(
)
)
{
*
aLineOut
=
exn
-
>
LineNumber
(
aCx
)
;
*
aColumnOut
=
exn
-
>
ColumnNumber
(
)
;
}
exn
-
>
GetName
(
aMessageOut
)
;
aMessageOut
.
AppendLiteral
(
"
:
"
)
;
nsAutoString
message
;
exn
-
>
GetMessageMoz
(
message
)
;
aMessageOut
.
Append
(
message
)
;
return
Ok
(
)
;
}
void
nsContentUtils
:
:
ExtractErrorValues
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
nsACString
&
aSourceSpecOut
uint32_t
*
aLineOut
uint32_t
*
aColumnOut
nsString
&
aMessageOut
)
{
nsAutoString
sourceSpec
;
ExtractErrorValues
(
aCx
aValue
sourceSpec
aLineOut
aColumnOut
aMessageOut
)
;
CopyUTF16toUTF8
(
sourceSpec
aSourceSpecOut
)
;
}
void
nsContentUtils
:
:
ExtractErrorValues
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
nsAString
&
aSourceSpecOut
uint32_t
*
aLineOut
uint32_t
*
aColumnOut
nsString
&
aMessageOut
)
{
MOZ_ASSERT
(
aLineOut
)
;
MOZ_ASSERT
(
aColumnOut
)
;
if
(
aValue
.
isObject
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
aCx
&
aValue
.
toObject
(
)
)
;
JSErrorReport
*
err
=
obj
?
JS_ErrorFromException
(
aCx
obj
)
:
nullptr
;
if
(
err
)
{
RefPtr
<
xpc
:
:
ErrorReport
>
report
=
new
xpc
:
:
ErrorReport
(
)
;
report
-
>
Init
(
err
"
<
unknown
>
"
false
0
)
;
if
(
!
report
-
>
mFileName
.
IsEmpty
(
)
)
{
aSourceSpecOut
=
report
-
>
mFileName
;
*
aLineOut
=
report
-
>
mLineNumber
;
*
aColumnOut
=
report
-
>
mColumn
;
}
aMessageOut
.
Assign
(
report
-
>
mErrorMsg
)
;
}
else
if
(
EXTRACT_EXN_VALUES
(
DOMException
aCx
obj
aSourceSpecOut
aLineOut
aColumnOut
aMessageOut
)
)
{
return
;
}
else
if
(
EXTRACT_EXN_VALUES
(
Exception
aCx
obj
aSourceSpecOut
aLineOut
aColumnOut
aMessageOut
)
)
{
return
;
}
}
if
(
aMessageOut
.
IsEmpty
(
)
)
{
nsAutoJSString
jsString
;
if
(
jsString
.
init
(
aCx
aValue
)
)
{
aMessageOut
=
jsString
;
}
else
{
JS_ClearPendingException
(
aCx
)
;
}
}
}
#
undef
EXTRACT_EXN_VALUES
bool
nsContentUtils
:
:
ContentIsLink
(
nsIContent
*
aContent
)
{
if
(
!
aContent
|
|
!
aContent
-
>
IsElement
(
)
)
{
return
false
;
}
if
(
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
return
true
;
}
return
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_XLink
nsGkAtoms
:
:
type
nsGkAtoms
:
:
simple
eCaseMatters
)
;
}
already_AddRefed
<
ContentFrameMessageManager
>
nsContentUtils
:
:
TryGetTabChildGlobal
(
nsISupports
*
aFrom
)
{
nsCOMPtr
<
nsIFrameLoaderOwner
>
frameLoaderOwner
=
do_QueryInterface
(
aFrom
)
;
if
(
!
frameLoaderOwner
)
{
return
nullptr
;
}
RefPtr
<
nsFrameLoader
>
frameLoader
=
frameLoaderOwner
-
>
GetFrameLoader
(
)
;
if
(
!
frameLoader
)
{
return
nullptr
;
}
RefPtr
<
ContentFrameMessageManager
>
manager
=
frameLoader
-
>
GetTabChildMessageManager
(
)
;
return
manager
.
forget
(
)
;
}
uint32_t
nsContentUtils
:
:
InnerOrOuterWindowCreated
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
+
+
sInnerOrOuterWindowCount
;
return
+
+
sInnerOrOuterWindowSerialCounter
;
}
void
nsContentUtils
:
:
InnerOrOuterWindowDestroyed
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
sInnerOrOuterWindowCount
>
0
)
;
-
-
sInnerOrOuterWindowCount
;
}
static
bool
JSONCreator
(
const
char16_t
*
aBuf
uint32_t
aLen
void
*
aData
)
{
nsAString
*
result
=
static_cast
<
nsAString
*
>
(
aData
)
;
result
-
>
Append
(
static_cast
<
const
char16_t
*
>
(
aBuf
)
static_cast
<
uint32_t
>
(
aLen
)
)
;
return
true
;
}
bool
nsContentUtils
:
:
StringifyJSON
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aValue
nsAString
&
aOutStr
)
{
MOZ_ASSERT
(
aCx
)
;
aOutStr
.
Truncate
(
)
;
JS
:
:
RootedValue
value
(
aCx
aValue
.
get
(
)
)
;
nsAutoString
serializedValue
;
NS_ENSURE_TRUE
(
JS_Stringify
(
aCx
&
value
nullptr
JS
:
:
NullHandleValue
JSONCreator
&
serializedValue
)
false
)
;
aOutStr
=
serializedValue
;
return
true
;
}
bool
nsContentUtils
:
:
HighPriorityEventPendingForTopLevelDocumentBeforeContentfulPaint
(
Document
*
aDocument
)
{
if
(
!
aDocument
|
|
aDocument
-
>
IsLoadedAsData
(
)
)
{
return
false
;
}
Document
*
topLevel
=
aDocument
-
>
GetTopLevelContentDocument
(
)
;
return
topLevel
&
&
topLevel
-
>
GetShell
(
)
&
&
topLevel
-
>
GetShell
(
)
-
>
GetPresContext
(
)
&
&
!
topLevel
-
>
GetShell
(
)
-
>
GetPresContext
(
)
-
>
HadContentfulPaint
(
)
&
&
nsThreadManager
:
:
MainThreadHasPendingHighPriorityEvents
(
)
;
}
bool
nsContentUtils
:
:
IsURIInPrefList
(
nsIURI
*
aURI
const
char
*
aPrefName
)
{
MOZ_ASSERT
(
aPrefName
)
;
nsAutoCString
blackList
;
Preferences
:
:
GetCString
(
aPrefName
blackList
)
;
ToLowerCase
(
blackList
)
;
return
IsURIInList
(
aURI
blackList
)
;
}
bool
nsContentUtils
:
:
IsURIInList
(
nsIURI
*
aURI
const
nsCString
&
aBlackList
)
{
#
ifdef
DEBUG
nsAutoCString
blackListLowerCase
(
aBlackList
)
;
ToLowerCase
(
blackListLowerCase
)
;
MOZ_ASSERT
(
blackListLowerCase
.
Equals
(
aBlackList
)
"
The
aBlackList
argument
should
be
lower
-
case
"
)
;
#
endif
if
(
!
aURI
)
{
return
false
;
}
nsAutoCString
scheme
;
aURI
-
>
GetScheme
(
scheme
)
;
if
(
!
scheme
.
EqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
)
{
return
false
;
}
nsAutoCString
host
;
aURI
-
>
GetHost
(
host
)
;
if
(
host
.
IsEmpty
(
)
)
{
return
false
;
}
ToLowerCase
(
host
)
;
if
(
aBlackList
.
IsEmpty
(
)
)
{
return
false
;
}
for
(
;
;
)
{
int32_t
index
=
aBlackList
.
Find
(
host
false
)
;
if
(
index
>
=
0
&
&
static_cast
<
uint32_t
>
(
index
)
+
host
.
Length
(
)
<
=
aBlackList
.
Length
(
)
&
&
(
!
index
|
|
aBlackList
[
index
-
1
]
=
=
'
'
)
)
{
size_t
indexAfterHost
=
index
+
host
.
Length
(
)
;
if
(
indexAfterHost
=
=
aBlackList
.
Length
(
)
|
|
aBlackList
[
indexAfterHost
]
=
=
'
'
)
{
return
true
;
}
if
(
aBlackList
[
indexAfterHost
]
=
=
'
/
'
)
{
int32_t
endOfPath
=
aBlackList
.
Find
(
"
"
false
indexAfterHost
)
;
nsDependentCSubstring
:
:
size_type
length
=
endOfPath
<
0
?
static_cast
<
nsDependentCSubstring
:
:
size_type
>
(
-
1
)
:
endOfPath
-
indexAfterHost
;
nsDependentCSubstring
pathInBlackList
(
aBlackList
indexAfterHost
length
)
;
nsAutoCString
filePath
;
aURI
-
>
GetFilePath
(
filePath
)
;
ToLowerCase
(
filePath
)
;
if
(
StringBeginsWith
(
filePath
pathInBlackList
)
)
{
return
true
;
}
}
}
int32_t
startIndexOfCurrentLevel
=
host
[
0
]
=
=
'
*
'
?
1
:
0
;
int32_t
startIndexOfNextLevel
=
host
.
Find
(
"
.
"
false
startIndexOfCurrentLevel
+
1
)
;
if
(
startIndexOfNextLevel
<
=
0
)
{
return
false
;
}
host
=
NS_LITERAL_CSTRING
(
"
*
"
)
+
nsDependentCSubstring
(
host
startIndexOfNextLevel
)
;
}
}
