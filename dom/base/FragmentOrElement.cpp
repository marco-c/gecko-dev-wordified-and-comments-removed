#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
FragmentOrElement
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
DeclarationBlock
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
URLExtraData
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsDOMCID
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsDOMCSSAttrDeclaration
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsDocument
.
h
"
#
include
"
nsAttrValueOrString
.
h
"
#
include
"
nsQueryObject
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULElement
.
h
"
#
endif
#
include
"
nsFrameSelection
.
h
"
#
ifdef
DEBUG
#
include
"
nsRange
.
h
"
#
endif
#
include
"
nsBindingManager
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPIBoxObject
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
mozilla
/
dom
/
NodeListBinding
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTemplateElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGUseElement
.
h
"
#
include
"
nsStyledElement
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsChildContentList
.
h
"
#
include
"
mozilla
/
BloomFilter
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
int32_t
nsIContent
:
:
sTabFocusModel
=
eTabFocus_any
;
bool
nsIContent
:
:
sTabFocusModelAppliesToXUL
=
false
;
uint64_t
nsMutationGuard
:
:
sGeneration
=
0
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsIContent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsIContent
)
MOZ_ASSERT_UNREACHABLE
(
"
Our
subclasses
don
'
t
call
us
"
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsIContent
)
MOZ_ASSERT_UNREACHABLE
(
"
Our
subclasses
don
'
t
call
us
"
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN
(
nsIContent
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIContent
)
NS_INTERFACE_MAP_ENTRY
(
nsINode
)
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
dom
:
:
EventTarget
)
NS_INTERFACE_MAP_ENTRY_TEAROFF
(
nsISupportsWeakReference
new
nsNodeSupportsWeakRefTearoff
(
this
)
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_ADDREF
(
nsIContent
)
NS_IMPL_MAIN_THREAD_ONLY_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsIContent
nsNodeUtils
:
:
LastRelease
(
this
)
)
nsIContent
*
nsIContent
:
:
FindFirstNonChromeOnlyAccessContent
(
)
const
{
for
(
const
nsIContent
*
content
=
this
;
content
;
content
=
content
-
>
GetBindingParent
(
)
)
{
if
(
!
content
-
>
ChromeOnlyAccess
(
)
)
{
return
const_cast
<
nsIContent
*
>
(
content
)
;
}
}
return
nullptr
;
}
HTMLSlotElement
*
nsIContent
:
:
GetAssignedSlotByMode
(
)
const
{
HTMLSlotElement
*
slot
=
GetAssignedSlot
(
)
;
if
(
!
slot
)
{
return
nullptr
;
}
MOZ_ASSERT
(
GetParent
(
)
)
;
MOZ_ASSERT
(
GetParent
(
)
-
>
GetShadowRoot
(
)
)
;
if
(
GetParent
(
)
-
>
GetShadowRoot
(
)
-
>
IsClosed
(
)
)
{
return
nullptr
;
}
return
slot
;
}
nsIContent
:
:
IMEState
nsIContent
:
:
GetDesiredIMEState
(
)
{
if
(
!
IsEditable
(
)
)
{
if
(
!
IsElement
(
)
|
|
!
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_MOZ_READWRITE
)
)
{
return
IMEState
(
IMEState
:
:
DISABLED
)
;
}
}
nsIContent
*
editableAncestor
=
GetEditingHost
(
)
;
if
(
editableAncestor
&
&
editableAncestor
!
=
this
)
{
return
editableAncestor
-
>
GetDesiredIMEState
(
)
;
}
nsIDocument
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
IMEState
(
IMEState
:
:
DISABLED
)
;
}
nsPresContext
*
pc
=
doc
-
>
GetPresContext
(
)
;
if
(
!
pc
)
{
return
IMEState
(
IMEState
:
:
DISABLED
)
;
}
HTMLEditor
*
htmlEditor
=
nsContentUtils
:
:
GetHTMLEditor
(
pc
)
;
if
(
!
htmlEditor
)
{
return
IMEState
(
IMEState
:
:
DISABLED
)
;
}
IMEState
state
;
htmlEditor
-
>
GetPreferredIMEState
(
&
state
)
;
return
state
;
}
bool
nsIContent
:
:
HasIndependentSelection
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
return
(
frame
&
&
frame
-
>
GetStateBits
(
)
&
NS_FRAME_INDEPENDENT_SELECTION
)
;
}
dom
:
:
Element
*
nsIContent
:
:
GetEditingHost
(
)
{
if
(
!
IsEditable
(
)
)
{
return
nullptr
;
}
nsIDocument
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
if
(
doc
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
!
IsInShadowTree
(
)
)
{
return
doc
-
>
GetBodyElement
(
)
;
}
nsIContent
*
content
=
this
;
for
(
dom
:
:
Element
*
parent
=
GetParentElement
(
)
;
parent
&
&
parent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
parent
=
content
-
>
GetParentElement
(
)
)
{
content
=
parent
;
}
return
content
-
>
AsElement
(
)
;
}
nsresult
nsIContent
:
:
LookupNamespaceURIInternal
(
const
nsAString
&
aNamespacePrefix
nsAString
&
aNamespaceURI
)
const
{
if
(
aNamespacePrefix
.
EqualsLiteral
(
"
xml
"
)
)
{
aNamespaceURI
.
AssignLiteral
(
"
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
"
)
;
return
NS_OK
;
}
if
(
aNamespacePrefix
.
EqualsLiteral
(
"
xmlns
"
)
)
{
aNamespaceURI
.
AssignLiteral
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
xmlns
/
"
)
;
return
NS_OK
;
}
RefPtr
<
nsAtom
>
name
;
if
(
!
aNamespacePrefix
.
IsEmpty
(
)
)
{
name
=
NS_Atomize
(
aNamespacePrefix
)
;
NS_ENSURE_TRUE
(
name
NS_ERROR_OUT_OF_MEMORY
)
;
}
else
{
name
=
nsGkAtoms
:
:
xmlns
;
}
const
nsIContent
*
content
=
this
;
do
{
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_XMLNS
name
aNamespaceURI
)
)
return
NS_OK
;
}
while
(
(
content
=
content
-
>
GetParent
(
)
)
)
;
return
NS_ERROR_FAILURE
;
}
nsAtom
*
nsIContent
:
:
GetLang
(
)
const
{
for
(
const
auto
*
content
=
this
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
!
content
-
>
IsElement
(
)
)
{
continue
;
}
auto
*
element
=
content
-
>
AsElement
(
)
;
if
(
!
element
-
>
GetAttrCount
(
)
)
{
continue
;
}
const
nsAttrValue
*
attr
=
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
lang
kNameSpaceID_XML
)
;
if
(
!
attr
&
&
element
-
>
SupportsLangAttr
(
)
)
{
attr
=
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
lang
)
;
}
if
(
attr
)
{
MOZ_ASSERT
(
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
)
;
MOZ_ASSERT
(
attr
-
>
GetAtomValue
(
)
)
;
return
attr
-
>
GetAtomValue
(
)
;
}
}
return
nullptr
;
}
already_AddRefed
<
nsIURI
>
nsIContent
:
:
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
)
const
{
if
(
IsInAnonymousSubtree
(
)
&
&
IsAnonymousContentInSVGUseSubtree
(
)
)
{
nsIContent
*
bindingParent
=
GetBindingParent
(
)
;
MOZ_ASSERT
(
bindingParent
)
;
SVGUseElement
*
useElement
=
static_cast
<
SVGUseElement
*
>
(
bindingParent
)
;
if
(
URLExtraData
*
data
=
useElement
-
>
GetContentURLData
(
)
)
{
return
do_AddRef
(
data
-
>
BaseURI
(
)
)
;
}
}
nsIDocument
*
doc
=
OwnerDoc
(
)
;
nsCOMPtr
<
nsIURI
>
base
=
doc
-
>
GetBaseURI
(
aTryUseXHRDocBaseURI
)
;
AutoTArray
<
nsString
5
>
baseAttrs
;
nsString
attr
;
const
nsIContent
*
elem
=
this
;
do
{
if
(
elem
-
>
IsSVGElement
(
)
)
{
nsIContent
*
bindingParent
=
elem
-
>
GetBindingParent
(
)
;
if
(
bindingParent
)
{
nsXBLBinding
*
binding
=
bindingParent
-
>
GetXBLBinding
(
)
;
if
(
binding
)
{
base
=
binding
-
>
PrototypeBinding
(
)
-
>
DocURI
(
)
;
break
;
}
}
}
if
(
elem
-
>
IsElement
(
)
)
{
elem
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_XML
nsGkAtoms
:
:
base
attr
)
;
if
(
!
attr
.
IsEmpty
(
)
)
{
baseAttrs
.
AppendElement
(
attr
)
;
}
}
elem
=
elem
-
>
GetParent
(
)
;
}
while
(
elem
)
;
if
(
!
baseAttrs
.
IsEmpty
(
)
)
{
doc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eXMLBaseAttribute
)
;
for
(
uint32_t
i
=
baseAttrs
.
Length
(
)
-
1
;
i
!
=
uint32_t
(
-
1
)
;
-
-
i
)
{
nsCOMPtr
<
nsIURI
>
newBase
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
newBase
)
baseAttrs
[
i
]
doc
-
>
GetDocumentCharacterSet
(
)
base
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
i
=
=
0
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIWithPrincipal
(
NodePrincipal
(
)
newBase
nsIScriptSecurityManager
:
:
STANDARD
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
base
.
swap
(
newBase
)
;
}
}
}
return
base
.
forget
(
)
;
}
nsIURI
*
nsIContent
:
:
GetBaseURIForStyleAttr
(
)
const
{
if
(
IsInAnonymousSubtree
(
)
&
&
IsAnonymousContentInSVGUseSubtree
(
)
)
{
nsIContent
*
bindingParent
=
GetBindingParent
(
)
;
MOZ_ASSERT
(
bindingParent
)
;
SVGUseElement
*
useElement
=
static_cast
<
SVGUseElement
*
>
(
bindingParent
)
;
if
(
URLExtraData
*
data
=
useElement
-
>
GetContentURLData
(
)
)
{
return
data
-
>
BaseURI
(
)
;
}
}
return
OwnerDoc
(
)
-
>
GetDocBaseURI
(
)
;
}
already_AddRefed
<
URLExtraData
>
nsIContent
:
:
GetURLDataForStyleAttr
(
nsIPrincipal
*
aSubjectPrincipal
)
const
{
if
(
IsInAnonymousSubtree
(
)
&
&
IsAnonymousContentInSVGUseSubtree
(
)
)
{
nsIContent
*
bindingParent
=
GetBindingParent
(
)
;
MOZ_ASSERT
(
bindingParent
)
;
SVGUseElement
*
useElement
=
static_cast
<
SVGUseElement
*
>
(
bindingParent
)
;
if
(
URLExtraData
*
data
=
useElement
-
>
GetContentURLData
(
)
)
{
return
do_AddRef
(
data
)
;
}
}
if
(
aSubjectPrincipal
&
&
aSubjectPrincipal
!
=
NodePrincipal
(
)
)
{
return
MakeAndAddRef
<
URLExtraData
>
(
OwnerDoc
(
)
-
>
GetDocBaseURI
(
)
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
aSubjectPrincipal
)
;
}
return
do_AddRef
(
OwnerDoc
(
)
-
>
DefaultStyleAttrURLData
(
)
)
;
}
static
inline
JSObject
*
GetJSObjectChild
(
nsWrapperCache
*
aCache
)
{
return
aCache
-
>
PreservingWrapper
(
)
?
aCache
-
>
GetWrapperPreserveColor
(
)
:
nullptr
;
}
static
bool
NeedsScriptTraverse
(
nsINode
*
aNode
)
{
return
aNode
-
>
PreservingWrapper
(
)
&
&
aNode
-
>
GetWrapperPreserveColor
(
)
&
&
!
aNode
-
>
HasKnownLiveWrapperAndDoesNotNeedTracing
(
aNode
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsAttrChildContentList
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsAttrChildContentList
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0
(
nsAttrChildContentList
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsAttrChildContentList
)
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsAttrChildContentList
)
return
tmp
-
>
HasKnownLiveWrapperAndDoesNotNeedTracing
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsAttrChildContentList
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_TABLE_HEAD
(
nsAttrChildContentList
)
NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY
NS_INTERFACE_TABLE
(
nsAttrChildContentList
nsINodeList
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
nsAttrChildContentList
)
NS_INTERFACE_MAP_END
JSObject
*
nsAttrChildContentList
:
:
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
NodeList_Binding
:
:
Wrap
(
cx
this
aGivenProto
)
;
}
uint32_t
nsAttrChildContentList
:
:
Length
(
)
{
return
mNode
?
mNode
-
>
GetChildCount
(
)
:
0
;
}
nsIContent
*
nsAttrChildContentList
:
:
Item
(
uint32_t
aIndex
)
{
if
(
mNode
)
{
return
mNode
-
>
GetChildAt_Deprecated
(
aIndex
)
;
}
return
nullptr
;
}
int32_t
nsAttrChildContentList
:
:
IndexOf
(
nsIContent
*
aContent
)
{
if
(
mNode
)
{
return
mNode
-
>
ComputeIndexOf
(
aContent
)
;
}
return
-
1
;
}
uint32_t
nsParentNodeChildContentList
:
:
Length
(
)
{
if
(
!
mIsCacheValid
&
&
!
ValidateCache
(
)
)
{
return
0
;
}
MOZ_ASSERT
(
mIsCacheValid
)
;
return
mCachedChildArray
.
Length
(
)
;
}
nsIContent
*
nsParentNodeChildContentList
:
:
Item
(
uint32_t
aIndex
)
{
if
(
!
mIsCacheValid
&
&
!
ValidateCache
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
mIsCacheValid
)
;
return
mCachedChildArray
.
SafeElementAt
(
aIndex
nullptr
)
;
}
int32_t
nsParentNodeChildContentList
:
:
IndexOf
(
nsIContent
*
aContent
)
{
if
(
!
mIsCacheValid
&
&
!
ValidateCache
(
)
)
{
return
-
1
;
}
MOZ_ASSERT
(
mIsCacheValid
)
;
return
mCachedChildArray
.
IndexOf
(
aContent
)
;
}
bool
nsParentNodeChildContentList
:
:
ValidateCache
(
)
{
MOZ_ASSERT
(
!
mIsCacheValid
)
;
MOZ_ASSERT
(
mCachedChildArray
.
IsEmpty
(
)
)
;
nsINode
*
parent
=
GetParentObject
(
)
;
if
(
!
parent
)
{
return
false
;
}
for
(
nsIContent
*
node
=
parent
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
mCachedChildArray
.
AppendElement
(
node
)
;
}
mIsCacheValid
=
true
;
return
true
;
}
nsIHTMLCollection
*
FragmentOrElement
:
:
Children
(
)
{
nsDOMSlots
*
slots
=
DOMSlots
(
)
;
if
(
!
slots
-
>
mChildrenList
)
{
slots
-
>
mChildrenList
=
new
nsContentList
(
this
kNameSpaceID_Wildcard
nsGkAtoms
:
:
_asterisk
nsGkAtoms
:
:
_asterisk
false
)
;
}
return
slots
-
>
mChildrenList
;
}
NS_IMPL_CYCLE_COLLECTION
(
nsNodeSupportsWeakRefTearoff
mNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsNodeSupportsWeakRefTearoff
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END_AGGREGATED
(
mNode
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsNodeSupportsWeakRefTearoff
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsNodeSupportsWeakRefTearoff
)
NS_IMETHODIMP
nsNodeSupportsWeakRefTearoff
:
:
GetWeakReference
(
nsIWeakReference
*
*
aInstancePtr
)
{
nsINode
:
:
nsSlots
*
slots
=
mNode
-
>
Slots
(
)
;
if
(
!
slots
-
>
mWeakReference
)
{
slots
-
>
mWeakReference
=
new
nsNodeWeakReference
(
mNode
)
;
}
NS_ADDREF
(
*
aInstancePtr
=
slots
-
>
mWeakReference
)
;
return
NS_OK
;
}
static
const
size_t
MaxDOMSlotSizeAllowed
=
#
ifdef
HAVE_64BIT_BUILD
128
;
#
else
64
;
#
endif
static_assert
(
sizeof
(
nsINode
:
:
nsSlots
)
<
=
MaxDOMSlotSizeAllowed
"
DOM
slots
cannot
be
grown
without
consideration
"
)
;
static_assert
(
sizeof
(
FragmentOrElement
:
:
nsDOMSlots
)
<
=
MaxDOMSlotSizeAllowed
"
DOM
slots
cannot
be
grown
without
consideration
"
)
;
void
nsIContent
:
:
nsExtendedContentSlots
:
:
UnlinkExtendedSlots
(
)
{
mBindingParent
=
nullptr
;
mXBLInsertionPoint
=
nullptr
;
mContainingShadow
=
nullptr
;
mAssignedSlot
=
nullptr
;
}
void
nsIContent
:
:
nsExtendedContentSlots
:
:
TraverseExtendedSlots
(
nsCycleCollectionTraversalCallback
&
aCb
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mBindingParent
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIContent
*
mBindingParent
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mContainingShadow
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIContent
*
mContainingShadow
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mAssignedSlot
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIContent
*
mAssignedSlot
.
get
(
)
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mXBLInsertionPoint
"
)
;
aCb
.
NoteXPCOMChild
(
mXBLInsertionPoint
.
get
(
)
)
;
}
nsIContent
:
:
nsExtendedContentSlots
:
:
nsExtendedContentSlots
(
)
{
}
nsIContent
:
:
nsExtendedContentSlots
:
:
~
nsExtendedContentSlots
(
)
=
default
;
FragmentOrElement
:
:
nsDOMSlots
:
:
nsDOMSlots
(
)
:
nsIContent
:
:
nsContentSlots
(
)
mDataset
(
nullptr
)
{
MOZ_COUNT_CTOR
(
nsDOMSlots
)
;
}
FragmentOrElement
:
:
nsDOMSlots
:
:
~
nsDOMSlots
(
)
{
MOZ_COUNT_DTOR
(
nsDOMSlots
)
;
if
(
mAttributeMap
)
{
mAttributeMap
-
>
DropReference
(
)
;
}
}
void
FragmentOrElement
:
:
nsDOMSlots
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
{
nsIContent
:
:
nsContentSlots
:
:
Traverse
(
aCb
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mStyle
"
)
;
aCb
.
NoteXPCOMChild
(
mStyle
.
get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mAttributeMap
"
)
;
aCb
.
NoteXPCOMChild
(
mAttributeMap
.
get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mChildrenList
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsINodeList
*
mChildrenList
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mClassList
"
)
;
aCb
.
NoteXPCOMChild
(
mClassList
.
get
(
)
)
;
}
void
FragmentOrElement
:
:
nsDOMSlots
:
:
Unlink
(
)
{
nsIContent
:
:
nsContentSlots
:
:
Unlink
(
)
;
mStyle
=
nullptr
;
if
(
mAttributeMap
)
{
mAttributeMap
-
>
DropReference
(
)
;
mAttributeMap
=
nullptr
;
}
mChildrenList
=
nullptr
;
mClassList
=
nullptr
;
}
size_t
FragmentOrElement
:
:
nsDOMSlots
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
if
(
OwnsExtendedSlots
(
)
)
{
n
+
=
aMallocSizeOf
(
GetExtendedContentSlots
(
)
)
;
}
if
(
mAttributeMap
)
{
n
+
=
mAttributeMap
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
nsExtendedDOMSlots
(
)
=
default
;
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
~
nsExtendedDOMSlots
(
)
{
}
void
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
UnlinkExtendedSlots
(
)
{
nsIContent
:
:
nsExtendedContentSlots
:
:
UnlinkExtendedSlots
(
)
;
mSMILOverrideStyle
=
nullptr
;
mControllers
=
nullptr
;
mLabelsList
=
nullptr
;
if
(
mCustomElementData
)
{
mCustomElementData
-
>
Unlink
(
)
;
mCustomElementData
=
nullptr
;
}
}
void
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
TraverseExtendedSlots
(
nsCycleCollectionTraversalCallback
&
aCb
)
{
nsIContent
:
:
nsExtendedContentSlots
:
:
TraverseExtendedSlots
(
aCb
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mSMILOverrideStyle
"
)
;
aCb
.
NoteXPCOMChild
(
mSMILOverrideStyle
.
get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mControllers
"
)
;
aCb
.
NoteXPCOMChild
(
mControllers
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mLabelsList
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsINodeList
*
mLabelsList
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mShadowRoot
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIContent
*
mShadowRoot
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mXBLBinding
"
)
;
aCb
.
NoteNativeChild
(
mXBLBinding
NS_CYCLE_COLLECTION_PARTICIPANT
(
nsXBLBinding
)
)
;
if
(
mCustomElementData
)
{
mCustomElementData
-
>
Traverse
(
aCb
)
;
}
}
FragmentOrElement
:
:
FragmentOrElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
aNodeInfo
)
:
nsIContent
(
aNodeInfo
)
{
}
FragmentOrElement
:
:
FragmentOrElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsIContent
(
aNodeInfo
)
{
}
FragmentOrElement
:
:
~
FragmentOrElement
(
)
{
MOZ_ASSERT
(
!
IsInUncomposedDoc
(
)
"
Please
remove
this
from
the
document
properly
"
)
;
if
(
GetParent
(
)
)
{
NS_RELEASE
(
mParent
)
;
}
}
already_AddRefed
<
nsINodeList
>
FragmentOrElement
:
:
GetChildren
(
uint32_t
aFilter
)
{
RefPtr
<
nsSimpleContentList
>
list
=
new
nsSimpleContentList
(
this
)
;
AllChildrenIterator
iter
(
this
aFilter
)
;
while
(
nsIContent
*
kid
=
iter
.
GetNextChild
(
)
)
{
list
-
>
AppendElement
(
kid
)
;
}
return
list
.
forget
(
)
;
}
static
nsIContent
*
FindChromeAccessOnlySubtreeOwner
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
ChromeOnlyAccess
(
)
)
{
bool
chromeAccessOnly
=
false
;
while
(
aContent
&
&
!
chromeAccessOnly
)
{
chromeAccessOnly
=
aContent
-
>
IsRootOfChromeAccessOnlySubtree
(
)
;
aContent
=
aContent
-
>
GetParent
(
)
;
}
}
return
aContent
;
}
already_AddRefed
<
nsINode
>
FindChromeAccessOnlySubtreeOwner
(
EventTarget
*
aTarget
)
{
nsCOMPtr
<
nsINode
>
node
=
do_QueryInterface
(
aTarget
)
;
if
(
!
node
|
|
!
node
-
>
ChromeOnlyAccess
(
)
)
{
return
node
.
forget
(
)
;
}
if
(
!
node
-
>
IsContent
(
)
)
{
return
nullptr
;
}
node
=
FindChromeAccessOnlySubtreeOwner
(
node
-
>
AsContent
(
)
)
;
return
node
.
forget
(
)
;
}
void
nsIContent
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
mMayHaveListenerManager
=
HasListenerManager
(
)
;
if
(
IsInShadowTree
(
)
)
{
aVisitor
.
mItemInShadowTree
=
true
;
}
bool
isAnonForEvents
=
IsRootOfChromeAccessOnlySubtree
(
)
;
aVisitor
.
mRootOfClosedTree
=
isAnonForEvents
;
if
(
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseOver
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseOut
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
ePointerOver
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
ePointerOut
)
&
&
(
(
this
=
=
aVisitor
.
mEvent
-
>
mOriginalTarget
&
&
!
ChromeOnlyAccess
(
)
)
|
|
isAnonForEvents
)
)
{
nsCOMPtr
<
nsIContent
>
relatedTarget
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
-
>
mRelatedTarget
)
;
if
(
relatedTarget
&
&
relatedTarget
-
>
OwnerDoc
(
)
=
=
OwnerDoc
(
)
)
{
if
(
isAnonForEvents
|
|
aVisitor
.
mRelatedTargetIsInAnon
|
|
(
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
this
&
&
(
aVisitor
.
mRelatedTargetIsInAnon
=
relatedTarget
-
>
ChromeOnlyAccess
(
)
)
)
)
{
nsIContent
*
anonOwner
=
FindChromeAccessOnlySubtreeOwner
(
this
)
;
if
(
anonOwner
)
{
nsIContent
*
anonOwnerRelated
=
FindChromeAccessOnlySubtreeOwner
(
relatedTarget
)
;
if
(
anonOwnerRelated
)
{
while
(
anonOwner
!
=
anonOwnerRelated
&
&
anonOwnerRelated
-
>
ChromeOnlyAccess
(
)
)
{
anonOwnerRelated
=
FindChromeAccessOnlySubtreeOwner
(
anonOwnerRelated
)
;
}
if
(
anonOwner
=
=
anonOwnerRelated
)
{
#
ifdef
DEBUG_smaug
nsCOMPtr
<
nsIContent
>
originalTarget
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
nsAutoString
ot
ct
rt
;
if
(
originalTarget
)
{
originalTarget
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
ot
)
;
}
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
ct
)
;
relatedTarget
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
rt
)
;
printf
(
"
Stopping
%
s
propagation
:
"
"
\
n
\
toriginalTarget
=
%
s
\
n
\
tcurrentTarget
=
%
s
%
s
"
"
\
n
\
trelatedTarget
=
%
s
%
s
\
n
%
s
"
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseOver
)
?
"
mouseover
"
:
"
mouseout
"
NS_ConvertUTF16toUTF8
(
ot
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
ct
)
.
get
(
)
isAnonForEvents
?
"
(
is
native
anonymous
)
"
:
(
ChromeOnlyAccess
(
)
?
"
(
is
in
native
anonymous
subtree
)
"
:
"
"
)
NS_ConvertUTF16toUTF8
(
rt
)
.
get
(
)
relatedTarget
-
>
ChromeOnlyAccess
(
)
?
"
(
is
in
native
anonymous
subtree
)
"
:
"
"
(
originalTarget
&
&
relatedTarget
-
>
FindFirstNonChromeOnlyAccessContent
(
)
=
=
originalTarget
-
>
FindFirstNonChromeOnlyAccessContent
(
)
)
?
"
"
:
"
Wrong
event
propagation
!
?
!
\
n
"
)
;
#
endif
aVisitor
.
SetParentTarget
(
nullptr
false
)
;
aVisitor
.
mCanHandle
=
isAnonForEvents
;
return
;
}
}
}
}
}
}
HTMLSlotElement
*
slot
=
GetAssignedSlot
(
)
;
nsIContent
*
parent
=
slot
?
slot
:
GetParent
(
)
;
if
(
isAnonForEvents
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIContent
>
t
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
NS_ASSERTION
(
!
t
|
|
!
t
-
>
ChromeOnlyAccess
(
)
|
|
aVisitor
.
mEvent
-
>
mClass
!
=
eMutationEventClass
|
|
aVisitor
.
mDOMEvent
"
Mutation
event
dispatched
in
native
anonymous
content
!
?
!
"
)
;
#
endif
aVisitor
.
mEventTargetAtParent
=
parent
;
}
else
if
(
parent
&
&
aVisitor
.
mOriginalTargetIsInAnon
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mTarget
)
)
;
if
(
content
&
&
content
-
>
GetBindingParent
(
)
=
=
parent
)
{
aVisitor
.
mEventTargetAtParent
=
parent
;
}
}
if
(
HasFlag
(
NODE_MAY_BE_IN_BINDING_MNGR
)
)
{
nsIContent
*
insertionParent
=
GetXBLInsertionParent
(
)
;
NS_ASSERTION
(
!
(
aVisitor
.
mEventTargetAtParent
&
&
insertionParent
&
&
aVisitor
.
mEventTargetAtParent
!
=
insertionParent
)
"
Retargeting
and
having
insertion
parent
!
"
)
;
if
(
insertionParent
)
{
parent
=
insertionParent
;
}
}
if
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mComposedInNativeAnonymousContent
&
&
IsRootOfNativeAnonymousSubtree
(
)
&
&
OwnerDoc
(
)
-
>
GetWindow
(
)
)
{
aVisitor
.
SetParentTarget
(
OwnerDoc
(
)
-
>
GetWindow
(
)
-
>
GetParentTarget
(
)
true
)
;
}
else
if
(
parent
)
{
aVisitor
.
SetParentTarget
(
parent
false
)
;
if
(
slot
)
{
ShadowRoot
*
root
=
slot
-
>
GetContainingShadow
(
)
;
if
(
root
&
&
root
-
>
IsClosed
(
)
)
{
aVisitor
.
mParentIsSlotInClosedTree
=
true
;
}
}
}
else
{
aVisitor
.
SetParentTarget
(
GetComposedDoc
(
)
false
)
;
}
if
(
!
ChromeOnlyAccess
(
)
&
&
!
aVisitor
.
mRelatedTargetRetargetedInCurrentScope
)
{
aVisitor
.
mRelatedTargetRetargetedInCurrentScope
=
true
;
if
(
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
)
{
bool
initialTarget
=
this
=
=
aVisitor
.
mEvent
-
>
mOriginalTarget
;
nsCOMPtr
<
nsINode
>
originalTargetAsNode
;
if
(
!
initialTarget
&
&
aVisitor
.
mOriginalTargetIsInAnon
)
{
originalTargetAsNode
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
initialTarget
=
originalTargetAsNode
=
=
this
;
}
if
(
initialTarget
)
{
nsCOMPtr
<
nsINode
>
relatedTargetAsNode
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
)
;
if
(
!
originalTargetAsNode
)
{
originalTargetAsNode
=
do_QueryInterface
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
}
if
(
relatedTargetAsNode
&
&
originalTargetAsNode
)
{
nsINode
*
retargetedRelatedTarget
=
nsContentUtils
:
:
Retarget
(
relatedTargetAsNode
originalTargetAsNode
)
;
if
(
originalTargetAsNode
=
=
retargetedRelatedTarget
&
&
retargetedRelatedTarget
!
=
relatedTargetAsNode
)
{
aVisitor
.
IgnoreCurrentTargetBecauseOfShadowDOMRetargeting
(
)
;
aVisitor
.
mEvent
-
>
mTarget
=
aVisitor
.
mTargetInKnownToBeHandledScope
;
return
;
}
aVisitor
.
mRetargetedRelatedTarget
=
retargetedRelatedTarget
;
}
}
else
{
nsCOMPtr
<
nsINode
>
relatedTargetAsNode
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
)
;
if
(
relatedTargetAsNode
)
{
nsINode
*
retargetedRelatedTarget
=
nsContentUtils
:
:
Retarget
(
relatedTargetAsNode
this
)
;
nsCOMPtr
<
nsINode
>
targetInKnownToBeHandledScope
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mTargetInKnownToBeHandledScope
)
;
if
(
targetInKnownToBeHandledScope
&
&
nsContentUtils
:
:
ContentIsShadowIncludingDescendantOf
(
this
targetInKnownToBeHandledScope
-
>
SubtreeRoot
(
)
)
)
{
aVisitor
.
mRetargetedRelatedTarget
=
retargetedRelatedTarget
;
}
else
if
(
this
=
=
retargetedRelatedTarget
)
{
aVisitor
.
IgnoreCurrentTargetBecauseOfShadowDOMRetargeting
(
)
;
aVisitor
.
mEvent
-
>
mTarget
=
aVisitor
.
mTargetInKnownToBeHandledScope
;
return
;
}
else
if
(
targetInKnownToBeHandledScope
)
{
aVisitor
.
mRetargetedRelatedTarget
=
retargetedRelatedTarget
;
}
}
}
}
if
(
aVisitor
.
mEvent
-
>
mClass
=
=
eTouchEventClass
)
{
MOZ_ASSERT
(
!
aVisitor
.
mRetargetedTouchTargets
.
isSome
(
)
)
;
aVisitor
.
mRetargetedTouchTargets
.
emplace
(
)
;
WidgetTouchEvent
*
touchEvent
=
aVisitor
.
mEvent
-
>
AsTouchEvent
(
)
;
WidgetTouchEvent
:
:
TouchArray
&
touches
=
touchEvent
-
>
mTouches
;
for
(
uint32_t
i
=
0
;
i
<
touches
.
Length
(
)
;
+
+
i
)
{
Touch
*
touch
=
touches
[
i
]
;
EventTarget
*
originalTarget
=
touch
-
>
mOriginalTarget
;
EventTarget
*
touchTarget
=
originalTarget
;
nsCOMPtr
<
nsINode
>
targetAsNode
=
do_QueryInterface
(
originalTarget
)
;
if
(
targetAsNode
)
{
EventTarget
*
retargeted
=
nsContentUtils
:
:
Retarget
(
targetAsNode
this
)
;
if
(
retargeted
)
{
touchTarget
=
retargeted
;
}
}
aVisitor
.
mRetargetedTouchTargets
-
>
AppendElement
(
touchTarget
)
;
touch
-
>
mTarget
=
touchTarget
;
}
MOZ_ASSERT
(
aVisitor
.
mRetargetedTouchTargets
-
>
Length
(
)
=
=
touches
.
Length
(
)
)
;
}
}
if
(
slot
)
{
aVisitor
.
mRelatedTargetRetargetedInCurrentScope
=
false
;
}
}
bool
nsIContent
:
:
IsFocusable
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
bool
focusable
=
IsFocusableInternal
(
aTabIndex
aWithMouse
)
;
if
(
focusable
|
|
(
aTabIndex
&
&
*
aTabIndex
!
=
-
1
)
)
{
if
(
nsContentUtils
:
:
IsUserFocusIgnored
(
this
)
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
return
false
;
}
return
focusable
;
}
return
false
;
}
bool
nsIContent
:
:
IsFocusableInternal
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
return
false
;
}
bool
FragmentOrElement
:
:
IsLink
(
nsIURI
*
*
aURI
)
const
{
*
aURI
=
nullptr
;
return
false
;
}
nsXBLBinding
*
FragmentOrElement
:
:
DoGetXBLBinding
(
)
const
{
MOZ_ASSERT
(
HasFlag
(
NODE_MAY_BE_IN_BINDING_MNGR
)
)
;
const
nsExtendedDOMSlots
*
slots
=
GetExistingExtendedDOMSlots
(
)
;
return
slots
?
slots
-
>
mXBLBinding
.
get
(
)
:
nullptr
;
}
nsIContent
*
nsIContent
:
:
GetContainingShadowHost
(
)
const
{
if
(
mozilla
:
:
dom
:
:
ShadowRoot
*
shadow
=
GetContainingShadow
(
)
)
{
return
shadow
-
>
GetHost
(
)
;
}
return
nullptr
;
}
void
nsIContent
:
:
SetAssignedSlot
(
HTMLSlotElement
*
aSlot
)
{
MOZ_ASSERT
(
aSlot
|
|
GetExistingExtendedContentSlots
(
)
)
;
ExtendedContentSlots
(
)
-
>
mAssignedSlot
=
aSlot
;
}
void
nsIContent
:
:
SetXBLInsertionPoint
(
nsIContent
*
aContent
)
{
if
(
aContent
)
{
nsExtendedContentSlots
*
slots
=
ExtendedContentSlots
(
)
;
SetFlags
(
NODE_MAY_BE_IN_BINDING_MNGR
)
;
slots
-
>
mXBLInsertionPoint
=
aContent
;
}
else
{
if
(
nsExtendedContentSlots
*
slots
=
GetExistingExtendedContentSlots
(
)
)
{
slots
-
>
mXBLInsertionPoint
=
nullptr
;
}
}
}
nsresult
FragmentOrElement
:
:
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
{
MOZ_ASSERT
(
aKid
"
null
ptr
"
)
;
int32_t
index
=
aBeforeThis
?
ComputeIndexOf
(
aBeforeThis
)
:
GetChildCount
(
)
;
MOZ_ASSERT
(
index
>
=
0
)
;
return
doInsertChildAt
(
aKid
index
aNotify
mAttrsAndChildren
)
;
}
void
FragmentOrElement
:
:
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
{
nsCOMPtr
<
nsIContent
>
kungFuDeathGrip
=
aKid
;
doRemoveChildAt
(
ComputeIndexOf
(
aKid
)
aNotify
aKid
mAttrsAndChildren
)
;
}
void
FragmentOrElement
:
:
GetTextContentInternal
(
nsAString
&
aTextContent
OOMReporter
&
aError
)
{
if
(
!
nsContentUtils
:
:
GetNodeTextContent
(
this
true
aTextContent
fallible
)
)
{
aError
.
ReportOOM
(
)
;
}
}
void
FragmentOrElement
:
:
SetTextContentInternal
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
{
aError
=
nsContentUtils
:
:
SetNodeTextContent
(
this
aTextContent
false
)
;
}
void
FragmentOrElement
:
:
DestroyContent
(
)
{
if
(
IsElement
(
)
)
{
AsElement
(
)
-
>
ClearServoData
(
)
;
}
nsIDocument
*
document
=
OwnerDoc
(
)
;
document
-
>
BindingManager
(
)
-
>
RemovedFromDocument
(
this
document
nsBindingManager
:
:
eRunDtor
)
;
document
-
>
ClearBoxObjectFor
(
this
)
;
#
ifdef
DEBUG
uint32_t
oldChildCount
=
GetChildCount
(
)
;
#
endif
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
DestroyContent
(
)
;
MOZ_ASSERT
(
child
-
>
GetParent
(
)
=
=
this
"
Mutating
the
tree
during
XBL
destructors
is
evil
"
)
;
}
MOZ_ASSERT
(
oldChildCount
=
=
GetChildCount
(
)
"
Mutating
the
tree
during
XBL
destructors
is
evil
"
)
;
if
(
ShadowRoot
*
shadowRoot
=
GetShadowRoot
(
)
)
{
shadowRoot
-
>
DestroyContent
(
)
;
}
}
void
FragmentOrElement
:
:
SaveSubtreeState
(
)
{
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
SaveSubtreeState
(
)
;
}
}
void
FragmentOrElement
:
:
FireNodeInserted
(
nsIDocument
*
aDoc
nsINode
*
aParent
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
&
aNodes
)
{
uint32_t
count
=
aNodes
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsIContent
*
childContent
=
aNodes
[
i
]
;
if
(
nsContentUtils
:
:
HasMutationListeners
(
childContent
NS_EVENT_BITS_MUTATION_NODEINSERTED
aParent
)
)
{
InternalMutationEvent
mutation
(
true
eLegacyNodeInserted
)
;
mutation
.
mRelatedNode
=
aParent
;
mozAutoSubtreeModified
subtree
(
aDoc
aParent
)
;
(
new
AsyncEventDispatcher
(
childContent
mutation
)
)
-
>
RunDOMEventWhenSafe
(
)
;
}
}
}
#
define
SUBTREE_UNBINDINGS_PER_RUNNABLE
500
class
ContentUnbinder
:
public
Runnable
{
public
:
ContentUnbinder
(
)
:
Runnable
(
"
ContentUnbinder
"
)
{
mLast
=
this
;
}
~
ContentUnbinder
(
)
{
Run
(
)
;
}
void
UnbindSubtree
(
nsIContent
*
aNode
)
{
if
(
aNode
-
>
NodeType
(
)
!
=
nsINode
:
:
ELEMENT_NODE
&
&
aNode
-
>
NodeType
(
)
!
=
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
return
;
}
FragmentOrElement
*
container
=
static_cast
<
FragmentOrElement
*
>
(
aNode
)
;
uint32_t
childCount
=
container
-
>
mAttrsAndChildren
.
ChildCount
(
)
;
if
(
childCount
)
{
container
-
>
InvalidateChildNodes
(
)
;
while
(
childCount
-
-
>
0
)
{
nsCOMPtr
<
nsIContent
>
child
=
container
-
>
mAttrsAndChildren
.
TakeChildAt
(
childCount
)
;
if
(
childCount
=
=
0
)
{
container
-
>
mFirstChild
=
nullptr
;
}
UnbindSubtree
(
child
)
;
child
-
>
UnbindFromTree
(
)
;
}
}
}
NS_IMETHOD
Run
(
)
override
{
nsAutoScriptBlocker
scriptBlocker
;
uint32_t
len
=
mSubtreeRoots
.
Length
(
)
;
if
(
len
)
{
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
UnbindSubtree
(
mSubtreeRoots
[
i
]
)
;
}
mSubtreeRoots
.
Clear
(
)
;
}
nsCycleCollector_dispatchDeferredDeletion
(
)
;
if
(
this
=
=
sContentUnbinder
)
{
sContentUnbinder
=
nullptr
;
if
(
mNext
)
{
RefPtr
<
ContentUnbinder
>
next
;
next
.
swap
(
mNext
)
;
sContentUnbinder
=
next
;
next
-
>
mLast
=
mLast
;
mLast
=
nullptr
;
NS_IdleDispatchToCurrentThread
(
next
.
forget
(
)
)
;
}
}
return
NS_OK
;
}
static
void
UnbindAll
(
)
{
RefPtr
<
ContentUnbinder
>
ub
=
sContentUnbinder
;
sContentUnbinder
=
nullptr
;
while
(
ub
)
{
ub
-
>
Run
(
)
;
ub
=
ub
-
>
mNext
;
}
}
static
void
Append
(
nsIContent
*
aSubtreeRoot
)
{
if
(
!
sContentUnbinder
)
{
sContentUnbinder
=
new
ContentUnbinder
(
)
;
nsCOMPtr
<
nsIRunnable
>
e
=
sContentUnbinder
;
NS_IdleDispatchToCurrentThread
(
e
.
forget
(
)
)
;
}
if
(
sContentUnbinder
-
>
mLast
-
>
mSubtreeRoots
.
Length
(
)
>
=
SUBTREE_UNBINDINGS_PER_RUNNABLE
)
{
sContentUnbinder
-
>
mLast
-
>
mNext
=
new
ContentUnbinder
(
)
;
sContentUnbinder
-
>
mLast
=
sContentUnbinder
-
>
mLast
-
>
mNext
;
}
sContentUnbinder
-
>
mLast
-
>
mSubtreeRoots
.
AppendElement
(
aSubtreeRoot
)
;
}
private
:
AutoTArray
<
nsCOMPtr
<
nsIContent
>
SUBTREE_UNBINDINGS_PER_RUNNABLE
>
mSubtreeRoots
;
RefPtr
<
ContentUnbinder
>
mNext
;
ContentUnbinder
*
mLast
;
static
ContentUnbinder
*
sContentUnbinder
;
}
;
ContentUnbinder
*
ContentUnbinder
:
:
sContentUnbinder
=
nullptr
;
void
FragmentOrElement
:
:
ClearContentUnbinder
(
)
{
ContentUnbinder
:
:
UnbindAll
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
FragmentOrElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
FragmentOrElement
)
nsIContent
:
:
Unlink
(
tmp
)
;
if
(
tmp
-
>
HasProperties
(
)
)
{
if
(
tmp
-
>
IsElement
(
)
)
{
Element
*
elem
=
tmp
-
>
AsElement
(
)
;
elem
-
>
UnlinkIntersectionObservers
(
)
;
}
if
(
tmp
-
>
IsHTMLElement
(
)
|
|
tmp
-
>
IsSVGElement
(
)
)
{
nsStaticAtom
*
*
*
props
=
Element
:
:
HTMLSVGPropertiesToTraverseAndUnlink
(
)
;
for
(
uint32_t
i
=
0
;
props
[
i
]
;
+
+
i
)
{
tmp
-
>
DeleteProperty
(
*
props
[
i
]
)
;
}
if
(
tmp
-
>
MayHaveAnimations
(
)
)
{
nsAtom
*
*
effectProps
=
EffectSet
:
:
GetEffectSetPropertyAtoms
(
)
;
for
(
uint32_t
i
=
0
;
effectProps
[
i
]
;
+
+
i
)
{
tmp
-
>
DeleteProperty
(
effectProps
[
i
]
)
;
}
}
}
}
if
(
tmp
-
>
UnoptimizableCCNode
(
)
|
|
!
nsCCUncollectableMarker
:
:
sGeneration
)
{
uint32_t
childCount
=
tmp
-
>
mAttrsAndChildren
.
ChildCount
(
)
;
if
(
childCount
)
{
nsAutoScriptBlocker
scriptBlocker
;
while
(
childCount
-
-
>
0
)
{
nsCOMPtr
<
nsIContent
>
child
=
tmp
-
>
mAttrsAndChildren
.
TakeChildAt
(
childCount
)
;
if
(
childCount
=
=
0
)
{
tmp
-
>
mFirstChild
=
nullptr
;
}
child
-
>
UnbindFromTree
(
)
;
}
}
}
else
if
(
!
tmp
-
>
GetParent
(
)
&
&
tmp
-
>
mAttrsAndChildren
.
ChildCount
(
)
)
{
ContentUnbinder
:
:
Append
(
tmp
)
;
}
tmp
-
>
UnsetFlags
(
NODE_IS_IN_SHADOW_TREE
)
;
if
(
ShadowRoot
*
shadowRoot
=
tmp
-
>
GetShadowRoot
(
)
)
{
for
(
nsIContent
*
child
=
shadowRoot
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
UnbindFromTree
(
true
false
)
;
}
shadowRoot
-
>
SetIsComposedDocParticipant
(
false
)
;
tmp
-
>
ExtendedDOMSlots
(
)
-
>
mShadowRoot
=
nullptr
;
}
nsIDocument
*
doc
=
tmp
-
>
OwnerDoc
(
)
;
doc
-
>
BindingManager
(
)
-
>
RemovedFromDocument
(
tmp
doc
nsBindingManager
:
:
eDoNotRunDtor
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE
(
FragmentOrElement
)
void
FragmentOrElement
:
:
MarkNodeChildren
(
nsINode
*
aNode
)
{
JSObject
*
o
=
GetJSObjectChild
(
aNode
)
;
if
(
o
)
{
JS
:
:
ExposeObjectToActiveJS
(
o
)
;
}
EventListenerManager
*
elm
=
aNode
-
>
GetExistingListenerManager
(
)
;
if
(
elm
)
{
elm
-
>
MarkForCC
(
)
;
}
}
nsINode
*
FindOptimizableSubtreeRoot
(
nsINode
*
aNode
)
{
nsINode
*
p
;
while
(
(
p
=
aNode
-
>
GetParentNode
(
)
)
)
{
if
(
aNode
-
>
UnoptimizableCCNode
(
)
)
{
return
nullptr
;
}
aNode
=
p
;
}
if
(
aNode
-
>
UnoptimizableCCNode
(
)
)
{
return
nullptr
;
}
return
aNode
;
}
StaticAutoPtr
<
nsTHashtable
<
nsPtrHashKey
<
nsINode
>
>
>
gCCBlackMarkedNodes
;
static
void
ClearBlackMarkedNodes
(
)
{
if
(
!
gCCBlackMarkedNodes
)
{
return
;
}
for
(
auto
iter
=
gCCBlackMarkedNodes
-
>
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsINode
*
n
=
iter
.
Get
(
)
-
>
GetKey
(
)
;
n
-
>
SetCCMarkedRoot
(
false
)
;
n
-
>
SetInCCBlackTree
(
false
)
;
}
gCCBlackMarkedNodes
=
nullptr
;
}
void
FragmentOrElement
:
:
RemoveBlackMarkedNode
(
nsINode
*
aNode
)
{
if
(
!
gCCBlackMarkedNodes
)
{
return
;
}
gCCBlackMarkedNodes
-
>
RemoveEntry
(
aNode
)
;
}
static
bool
IsCertainlyAliveNode
(
nsINode
*
aNode
nsIDocument
*
aDoc
)
{
MOZ_ASSERT
(
aNode
-
>
GetComposedDoc
(
)
=
=
aDoc
)
;
return
nsCCUncollectableMarker
:
:
InGeneration
(
aDoc
-
>
GetMarkedCCGeneration
(
)
)
|
|
(
nsCCUncollectableMarker
:
:
sGeneration
&
&
aDoc
-
>
IsBeingUsedAsImage
(
)
&
&
aDoc
-
>
IsVisible
(
)
)
;
}
bool
FragmentOrElement
:
:
CanSkipInCC
(
nsINode
*
aNode
)
{
if
(
nsCCUncollectableMarker
:
:
sGeneration
=
=
0
)
{
return
false
;
}
nsIDocument
*
currentDoc
=
aNode
-
>
GetComposedDoc
(
)
;
if
(
currentDoc
&
&
IsCertainlyAliveNode
(
aNode
currentDoc
)
)
{
return
!
NeedsScriptTraverse
(
aNode
)
;
}
if
(
aNode
-
>
UnoptimizableCCNode
(
)
)
{
return
false
;
}
nsINode
*
root
=
currentDoc
?
static_cast
<
nsINode
*
>
(
currentDoc
)
:
FindOptimizableSubtreeRoot
(
aNode
)
;
if
(
!
root
)
{
return
false
;
}
if
(
root
-
>
CCMarkedRoot
(
)
)
{
return
root
-
>
InCCBlackTree
(
)
&
&
!
NeedsScriptTraverse
(
aNode
)
;
}
if
(
!
gCCBlackMarkedNodes
)
{
gCCBlackMarkedNodes
=
new
nsTHashtable
<
nsPtrHashKey
<
nsINode
>
>
(
1020
)
;
}
AutoTArray
<
nsIContent
*
1020
>
nodesToUnpurple
;
AutoTArray
<
nsINode
*
1020
>
grayNodes
;
bool
foundLiveWrapper
=
root
-
>
HasKnownLiveWrapper
(
)
;
if
(
root
!
=
currentDoc
)
{
currentDoc
=
nullptr
;
if
(
NeedsScriptTraverse
(
root
)
)
{
grayNodes
.
AppendElement
(
root
)
;
}
else
if
(
static_cast
<
nsIContent
*
>
(
root
)
-
>
IsPurple
(
)
)
{
nodesToUnpurple
.
AppendElement
(
static_cast
<
nsIContent
*
>
(
root
)
)
;
}
}
for
(
nsIContent
*
node
=
root
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
root
)
)
{
foundLiveWrapper
=
foundLiveWrapper
|
|
node
-
>
HasKnownLiveWrapper
(
)
;
if
(
foundLiveWrapper
&
&
currentDoc
)
{
break
;
}
if
(
NeedsScriptTraverse
(
node
)
)
{
grayNodes
.
AppendElement
(
node
)
;
}
else
if
(
node
-
>
IsPurple
(
)
)
{
nodesToUnpurple
.
AppendElement
(
node
)
;
}
}
root
-
>
SetCCMarkedRoot
(
true
)
;
root
-
>
SetInCCBlackTree
(
foundLiveWrapper
)
;
gCCBlackMarkedNodes
-
>
PutEntry
(
root
)
;
if
(
!
foundLiveWrapper
)
{
return
false
;
}
if
(
currentDoc
)
{
currentDoc
-
>
MarkUncollectableForCCGeneration
(
nsCCUncollectableMarker
:
:
sGeneration
)
;
}
else
{
for
(
uint32_t
i
=
0
;
i
<
grayNodes
.
Length
(
)
;
+
+
i
)
{
nsINode
*
node
=
grayNodes
[
i
]
;
node
-
>
SetInCCBlackTree
(
true
)
;
gCCBlackMarkedNodes
-
>
PutEntry
(
node
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
nodesToUnpurple
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
purple
=
nodesToUnpurple
[
i
]
;
if
(
purple
!
=
aNode
)
{
purple
-
>
RemovePurple
(
)
;
}
}
return
!
NeedsScriptTraverse
(
aNode
)
;
}
AutoTArray
<
nsINode
*
1020
>
*
gPurpleRoots
=
nullptr
;
AutoTArray
<
nsIContent
*
1020
>
*
gNodesToUnbind
=
nullptr
;
void
ClearCycleCollectorCleanupData
(
)
{
if
(
gPurpleRoots
)
{
uint32_t
len
=
gPurpleRoots
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsINode
*
n
=
gPurpleRoots
-
>
ElementAt
(
i
)
;
n
-
>
SetIsPurpleRoot
(
false
)
;
}
delete
gPurpleRoots
;
gPurpleRoots
=
nullptr
;
}
if
(
gNodesToUnbind
)
{
uint32_t
len
=
gNodesToUnbind
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsIContent
*
c
=
gNodesToUnbind
-
>
ElementAt
(
i
)
;
c
-
>
SetIsPurpleRoot
(
false
)
;
ContentUnbinder
:
:
Append
(
c
)
;
}
delete
gNodesToUnbind
;
gNodesToUnbind
=
nullptr
;
}
}
static
bool
ShouldClearPurple
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
if
(
aContent
-
>
IsPurple
(
)
)
{
return
true
;
}
JSObject
*
o
=
GetJSObjectChild
(
aContent
)
;
if
(
o
&
&
JS
:
:
ObjectIsMarkedGray
(
o
)
)
{
return
true
;
}
if
(
aContent
-
>
HasListenerManager
(
)
)
{
return
true
;
}
return
aContent
-
>
HasProperties
(
)
;
}
bool
NodeHasActiveFrame
(
nsIDocument
*
aCurrentDoc
nsINode
*
aNode
)
{
return
aCurrentDoc
-
>
GetShell
(
)
&
&
aNode
-
>
IsElement
(
)
&
&
aNode
-
>
AsElement
(
)
-
>
GetPrimaryFrame
(
)
;
}
bool
OwnedByBindingManager
(
nsIDocument
*
aCurrentDoc
nsINode
*
aNode
)
{
return
aNode
-
>
IsElement
(
)
&
&
aNode
-
>
AsElement
(
)
-
>
GetXBLBinding
(
)
;
}
bool
FragmentOrElement
:
:
CanSkip
(
nsINode
*
aNode
bool
aRemovingAllowed
)
{
if
(
nsCCUncollectableMarker
:
:
sGeneration
=
=
0
)
{
return
false
;
}
bool
unoptimizable
=
aNode
-
>
UnoptimizableCCNode
(
)
;
nsIDocument
*
currentDoc
=
aNode
-
>
GetComposedDoc
(
)
;
if
(
currentDoc
&
&
IsCertainlyAliveNode
(
aNode
currentDoc
)
&
&
(
!
unoptimizable
|
|
NodeHasActiveFrame
(
currentDoc
aNode
)
|
|
OwnedByBindingManager
(
currentDoc
aNode
)
)
)
{
MarkNodeChildren
(
aNode
)
;
return
true
;
}
if
(
unoptimizable
)
{
return
false
;
}
nsINode
*
root
=
currentDoc
?
static_cast
<
nsINode
*
>
(
currentDoc
)
:
FindOptimizableSubtreeRoot
(
aNode
)
;
if
(
!
root
)
{
return
false
;
}
if
(
root
-
>
IsPurpleRoot
(
)
)
{
return
false
;
}
AutoTArray
<
nsIContent
*
1020
>
nodesToClear
;
bool
foundLiveWrapper
=
root
-
>
HasKnownLiveWrapper
(
)
;
bool
domOnlyCycle
=
false
;
if
(
root
!
=
currentDoc
)
{
currentDoc
=
nullptr
;
if
(
!
foundLiveWrapper
)
{
domOnlyCycle
=
static_cast
<
nsIContent
*
>
(
root
)
-
>
OwnedOnlyByTheDOMTree
(
)
;
}
if
(
ShouldClearPurple
(
static_cast
<
nsIContent
*
>
(
root
)
)
)
{
nodesToClear
.
AppendElement
(
static_cast
<
nsIContent
*
>
(
root
)
)
;
}
}
for
(
nsIContent
*
node
=
root
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
root
)
)
{
foundLiveWrapper
=
foundLiveWrapper
|
|
node
-
>
HasKnownLiveWrapper
(
)
;
if
(
foundLiveWrapper
)
{
domOnlyCycle
=
false
;
if
(
currentDoc
)
{
break
;
}
if
(
node
-
>
IsPurple
(
)
&
&
(
node
!
=
aNode
|
|
aRemovingAllowed
)
)
{
node
-
>
RemovePurple
(
)
;
}
MarkNodeChildren
(
node
)
;
}
else
{
domOnlyCycle
=
domOnlyCycle
&
&
node
-
>
OwnedOnlyByTheDOMTree
(
)
;
if
(
ShouldClearPurple
(
node
)
)
{
nodesToClear
.
AppendElement
(
node
)
;
}
}
}
if
(
!
currentDoc
|
|
!
foundLiveWrapper
)
{
root
-
>
SetIsPurpleRoot
(
true
)
;
if
(
domOnlyCycle
)
{
if
(
!
gNodesToUnbind
)
{
gNodesToUnbind
=
new
AutoTArray
<
nsIContent
*
1020
>
(
)
;
}
gNodesToUnbind
-
>
AppendElement
(
static_cast
<
nsIContent
*
>
(
root
)
)
;
for
(
uint32_t
i
=
0
;
i
<
nodesToClear
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
n
=
nodesToClear
[
i
]
;
if
(
(
n
!
=
aNode
|
|
aRemovingAllowed
)
&
&
n
-
>
IsPurple
(
)
)
{
n
-
>
RemovePurple
(
)
;
}
}
return
true
;
}
else
{
if
(
!
gPurpleRoots
)
{
gPurpleRoots
=
new
AutoTArray
<
nsINode
*
1020
>
(
)
;
}
gPurpleRoots
-
>
AppendElement
(
root
)
;
}
}
if
(
!
foundLiveWrapper
)
{
return
false
;
}
if
(
currentDoc
)
{
currentDoc
-
>
MarkUncollectableForCCGeneration
(
nsCCUncollectableMarker
:
:
sGeneration
)
;
MarkNodeChildren
(
currentDoc
)
;
}
for
(
uint32_t
i
=
0
;
i
<
nodesToClear
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
n
=
nodesToClear
[
i
]
;
MarkNodeChildren
(
n
)
;
if
(
(
n
!
=
aNode
|
|
aRemovingAllowed
)
&
&
n
-
>
IsPurple
(
)
)
{
n
-
>
RemovePurple
(
)
;
}
}
return
true
;
}
bool
FragmentOrElement
:
:
CanSkipThis
(
nsINode
*
aNode
)
{
if
(
nsCCUncollectableMarker
:
:
sGeneration
=
=
0
)
{
return
false
;
}
if
(
aNode
-
>
HasKnownLiveWrapper
(
)
)
{
return
true
;
}
nsIDocument
*
c
=
aNode
-
>
GetComposedDoc
(
)
;
return
(
(
c
&
&
IsCertainlyAliveNode
(
aNode
c
)
)
|
|
aNode
-
>
InCCBlackTree
(
)
)
&
&
!
NeedsScriptTraverse
(
aNode
)
;
}
void
FragmentOrElement
:
:
InitCCCallbacks
(
)
{
nsCycleCollector_setForgetSkippableCallback
(
ClearCycleCollectorCleanupData
)
;
nsCycleCollector_setBeforeUnlinkCallback
(
ClearBlackMarkedNodes
)
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
FragmentOrElement
)
return
FragmentOrElement
:
:
CanSkip
(
tmp
aRemovingAllowed
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
FragmentOrElement
)
return
FragmentOrElement
:
:
CanSkipInCC
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
FragmentOrElement
)
return
FragmentOrElement
:
:
CanSkipThis
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
static
const
char
*
kNSURIs
[
]
=
{
"
(
[
none
]
)
"
"
(
xmlns
)
"
"
(
xml
)
"
"
(
xhtml
)
"
"
(
XLink
)
"
"
(
XSLT
)
"
"
(
XBL
)
"
"
(
MathML
)
"
"
(
RDF
)
"
"
(
XUL
)
"
"
(
SVG
)
"
"
(
XML
Events
)
"
}
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL
(
FragmentOrElement
)
if
(
MOZ_UNLIKELY
(
cb
.
WantDebugInfo
(
)
)
)
{
char
name
[
512
]
;
uint32_t
nsid
=
tmp
-
>
GetNameSpaceID
(
)
;
nsAtomCString
localName
(
tmp
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
nsAutoCString
uri
;
if
(
tmp
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
)
{
uri
=
tmp
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
}
nsAutoString
id
;
nsAtom
*
idAtom
=
tmp
-
>
GetID
(
)
;
if
(
idAtom
)
{
id
.
AppendLiteral
(
"
id
=
'
"
)
;
id
.
Append
(
nsDependentAtomString
(
idAtom
)
)
;
id
.
Append
(
'
\
'
'
)
;
}
nsAutoString
classes
;
const
nsAttrValue
*
classAttrValue
=
tmp
-
>
IsElement
(
)
?
tmp
-
>
AsElement
(
)
-
>
GetClasses
(
)
:
nullptr
;
if
(
classAttrValue
)
{
classes
.
AppendLiteral
(
"
class
=
'
"
)
;
nsAutoString
classString
;
classAttrValue
-
>
ToString
(
classString
)
;
classString
.
ReplaceChar
(
char16_t
(
'
\
n
'
)
char16_t
(
'
'
)
)
;
classes
.
Append
(
classString
)
;
classes
.
Append
(
'
\
'
'
)
;
}
nsAutoCString
orphan
;
if
(
!
tmp
-
>
IsInComposedDoc
(
)
&
&
!
tmp
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
content
kNameSpaceID_XBL
)
)
{
orphan
.
AppendLiteral
(
"
(
orphan
)
"
)
;
}
const
char
*
nsuri
=
nsid
<
ArrayLength
(
kNSURIs
)
?
kNSURIs
[
nsid
]
:
"
"
;
SprintfLiteral
(
name
"
FragmentOrElement
%
s
%
s
%
s
%
s
%
s
%
s
"
nsuri
localName
.
get
(
)
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
classes
)
.
get
(
)
orphan
.
get
(
)
uri
.
get
(
)
)
;
cb
.
DescribeRefCountedNode
(
tmp
-
>
mRefCnt
.
get
(
)
name
)
;
}
else
{
NS_IMPL_CYCLE_COLLECTION_DESCRIBE
(
FragmentOrElement
tmp
-
>
mRefCnt
.
get
(
)
)
}
if
(
!
nsIContent
:
:
Traverse
(
tmp
cb
)
)
{
return
NS_SUCCESS_INTERRUPTED_TRAVERSE
;
}
tmp
-
>
OwnerDoc
(
)
-
>
BindingManager
(
)
-
>
Traverse
(
tmp
cb
)
;
#
ifdef
DEBUG
nsAtom
*
*
effectProps
=
EffectSet
:
:
GetEffectSetPropertyAtoms
(
)
;
for
(
uint32_t
i
=
0
;
effectProps
[
i
]
;
+
+
i
)
{
MOZ_ASSERT_IF
(
tmp
-
>
GetProperty
(
effectProps
[
i
]
)
tmp
-
>
MayHaveAnimations
(
)
)
;
}
#
endif
if
(
tmp
-
>
HasProperties
(
)
)
{
if
(
tmp
-
>
IsElement
(
)
)
{
Element
*
elem
=
tmp
-
>
AsElement
(
)
;
IntersectionObserverList
*
observers
=
static_cast
<
IntersectionObserverList
*
>
(
elem
-
>
GetProperty
(
nsGkAtoms
:
:
intersectionobserverlist
)
)
;
if
(
observers
)
{
for
(
auto
iter
=
observers
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
DOMIntersectionObserver
*
observer
=
iter
.
Key
(
)
;
cb
.
NoteXPCOMChild
(
observer
)
;
}
}
}
if
(
tmp
-
>
IsHTMLElement
(
)
|
|
tmp
-
>
IsSVGElement
(
)
)
{
nsStaticAtom
*
*
*
props
=
Element
:
:
HTMLSVGPropertiesToTraverseAndUnlink
(
)
;
for
(
uint32_t
i
=
0
;
props
[
i
]
;
+
+
i
)
{
nsISupports
*
property
=
static_cast
<
nsISupports
*
>
(
tmp
-
>
GetProperty
(
*
props
[
i
]
)
)
;
cb
.
NoteXPCOMChild
(
property
)
;
}
if
(
tmp
-
>
MayHaveAnimations
(
)
)
{
nsAtom
*
*
effectProps
=
EffectSet
:
:
GetEffectSetPropertyAtoms
(
)
;
for
(
uint32_t
i
=
0
;
effectProps
[
i
]
;
+
+
i
)
{
EffectSet
*
effectSet
=
static_cast
<
EffectSet
*
>
(
tmp
-
>
GetProperty
(
effectProps
[
i
]
)
)
;
if
(
effectSet
)
{
effectSet
-
>
Traverse
(
cb
)
;
}
}
}
}
}
{
uint32_t
i
;
uint32_t
attrs
=
tmp
-
>
mAttrsAndChildren
.
AttrCount
(
)
;
for
(
i
=
0
;
i
<
attrs
;
i
+
+
)
{
const
nsAttrName
*
name
=
tmp
-
>
mAttrsAndChildren
.
AttrNameAt
(
i
)
;
if
(
!
name
-
>
IsAtom
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mAttrsAndChildren
[
i
]
-
>
NodeInfo
(
)
"
)
;
cb
.
NoteNativeChild
(
name
-
>
NodeInfo
(
)
NS_CYCLE_COLLECTION_PARTICIPANT
(
NodeInfo
)
)
;
}
}
uint32_t
kids
=
tmp
-
>
mAttrsAndChildren
.
ChildCount
(
)
;
for
(
i
=
0
;
i
<
kids
;
i
+
+
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mAttrsAndChildren
[
i
]
"
)
;
cb
.
NoteXPCOMChild
(
tmp
-
>
mAttrsAndChildren
.
GetSafeChildAt
(
i
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN
(
FragmentOrElement
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
FragmentOrElement
)
NS_INTERFACE_MAP_END_INHERITING
(
nsIContent
)
nsresult
FragmentOrElement
:
:
CopyInnerTo
(
FragmentOrElement
*
aDst
bool
aPreallocateChildren
)
{
nsresult
rv
=
aDst
-
>
mAttrsAndChildren
.
EnsureCapacityToClone
(
mAttrsAndChildren
aPreallocateChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
i
count
=
mAttrsAndChildren
.
AttrCount
(
)
;
for
(
i
=
0
;
i
<
count
;
+
+
i
)
{
const
nsAttrName
*
name
=
mAttrsAndChildren
.
AttrNameAt
(
i
)
;
const
nsAttrValue
*
value
=
mAttrsAndChildren
.
AttrAt
(
i
)
;
nsAutoString
valStr
;
value
-
>
ToString
(
valStr
)
;
rv
=
aDst
-
>
AsElement
(
)
-
>
SetAttr
(
name
-
>
NamespaceID
(
)
name
-
>
LocalName
(
)
name
-
>
GetPrefix
(
)
valStr
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
const
nsTextFragment
*
FragmentOrElement
:
:
GetText
(
)
{
return
nullptr
;
}
uint32_t
FragmentOrElement
:
:
TextLength
(
)
const
{
MOZ_ASSERT_UNREACHABLE
(
"
called
FragmentOrElement
:
:
TextLength
"
)
;
return
0
;
}
bool
FragmentOrElement
:
:
TextIsOnlyWhitespace
(
)
{
return
false
;
}
bool
FragmentOrElement
:
:
ThreadSafeTextIsOnlyWhitespace
(
)
const
{
return
false
;
}
uint32_t
FragmentOrElement
:
:
GetChildCount
(
)
const
{
return
mAttrsAndChildren
.
ChildCount
(
)
;
}
nsIContent
*
FragmentOrElement
:
:
GetChildAt_Deprecated
(
uint32_t
aIndex
)
const
{
return
mAttrsAndChildren
.
GetSafeChildAt
(
aIndex
)
;
}
int32_t
FragmentOrElement
:
:
ComputeIndexOf
(
const
nsINode
*
aPossibleChild
)
const
{
return
mAttrsAndChildren
.
IndexOfChild
(
aPossibleChild
)
;
}
static
inline
bool
IsVoidTag
(
nsAtom
*
aTag
)
{
static
const
nsAtom
*
voidElements
[
]
=
{
nsGkAtoms
:
:
area
nsGkAtoms
:
:
base
nsGkAtoms
:
:
basefont
nsGkAtoms
:
:
bgsound
nsGkAtoms
:
:
br
nsGkAtoms
:
:
col
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
frame
nsGkAtoms
:
:
hr
nsGkAtoms
:
:
img
nsGkAtoms
:
:
input
nsGkAtoms
:
:
keygen
nsGkAtoms
:
:
link
nsGkAtoms
:
:
meta
nsGkAtoms
:
:
param
nsGkAtoms
:
:
source
nsGkAtoms
:
:
track
nsGkAtoms
:
:
wbr
}
;
static
mozilla
:
:
BloomFilter
<
12
nsAtom
>
sFilter
;
static
bool
sInitialized
=
false
;
if
(
!
sInitialized
)
{
sInitialized
=
true
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
voidElements
)
;
+
+
i
)
{
sFilter
.
add
(
voidElements
[
i
]
)
;
}
}
if
(
sFilter
.
mightContain
(
aTag
)
)
{
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
voidElements
)
;
+
+
i
)
{
if
(
aTag
=
=
voidElements
[
i
]
)
{
return
true
;
}
}
}
return
false
;
}
bool
FragmentOrElement
:
:
IsHTMLVoid
(
nsAtom
*
aLocalName
)
{
return
aLocalName
&
&
IsVoidTag
(
aLocalName
)
;
}
void
FragmentOrElement
:
:
GetMarkup
(
bool
aIncludeSelf
nsAString
&
aMarkup
)
{
aMarkup
.
Truncate
(
)
;
nsIDocument
*
doc
=
OwnerDoc
(
)
;
if
(
IsInHTMLDocument
(
)
)
{
nsContentUtils
:
:
SerializeNodeToMarkup
(
this
!
aIncludeSelf
aMarkup
)
;
return
;
}
nsAutoString
contentType
;
doc
-
>
GetContentType
(
contentType
)
;
bool
tryToCacheEncoder
=
!
aIncludeSelf
;
nsCOMPtr
<
nsIDocumentEncoder
>
docEncoder
=
doc
-
>
GetCachedEncoder
(
)
;
if
(
!
docEncoder
)
{
docEncoder
=
do_CreateInstance
(
PromiseFlatCString
(
nsDependentCString
(
NS_DOC_ENCODER_CONTRACTID_BASE
)
+
NS_ConvertUTF16toUTF8
(
contentType
)
)
.
get
(
)
)
;
}
if
(
!
docEncoder
)
{
contentType
.
AssignLiteral
(
"
application
/
xml
"
)
;
docEncoder
=
do_CreateInstance
(
NS_DOC_ENCODER_CONTRACTID_BASE
"
application
/
xml
"
)
;
tryToCacheEncoder
=
false
;
}
NS_ENSURE_TRUE_VOID
(
docEncoder
)
;
uint32_t
flags
=
nsIDocumentEncoder
:
:
OutputEncodeBasicEntities
|
nsIDocumentEncoder
:
:
OutputLFLineBreak
|
nsIDocumentEncoder
:
:
OutputRaw
|
nsIDocumentEncoder
:
:
OutputIgnoreMozDirty
;
if
(
IsEditable
(
)
)
{
nsCOMPtr
<
Element
>
elem
=
do_QueryInterface
(
this
)
;
TextEditor
*
textEditor
=
elem
?
elem
-
>
GetTextEditorInternal
(
)
:
nullptr
;
if
(
textEditor
&
&
textEditor
-
>
OutputsMozDirty
(
)
)
{
flags
&
=
~
nsIDocumentEncoder
:
:
OutputIgnoreMozDirty
;
}
}
DebugOnly
<
nsresult
>
rv
=
docEncoder
-
>
NativeInit
(
doc
contentType
flags
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
aIncludeSelf
)
{
docEncoder
-
>
SetNode
(
this
)
;
}
else
{
docEncoder
-
>
SetContainerNode
(
this
)
;
}
rv
=
docEncoder
-
>
EncodeToString
(
aMarkup
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
tryToCacheEncoder
)
{
doc
-
>
SetCachedEncoder
(
docEncoder
.
forget
(
)
)
;
}
}
static
bool
ContainsMarkup
(
const
nsAString
&
aStr
)
{
const
char16_t
*
start
=
aStr
.
BeginReading
(
)
;
const
char16_t
*
end
=
aStr
.
EndReading
(
)
;
while
(
start
!
=
end
)
{
char16_t
c
=
*
start
;
if
(
c
=
=
char16_t
(
'
<
'
)
|
|
c
=
=
char16_t
(
'
&
'
)
|
|
c
=
=
char16_t
(
'
\
r
'
)
|
|
c
=
=
char16_t
(
'
\
0
'
)
)
{
return
true
;
}
+
+
start
;
}
return
false
;
}
void
FragmentOrElement
:
:
SetInnerHTMLInternal
(
const
nsAString
&
aInnerHTML
ErrorResult
&
aError
)
{
FragmentOrElement
*
target
=
this
;
if
(
nsNodeUtils
:
:
IsTemplateElement
(
target
)
)
{
DocumentFragment
*
frag
=
static_cast
<
HTMLTemplateElement
*
>
(
target
)
-
>
Content
(
)
;
MOZ_ASSERT
(
frag
)
;
target
=
frag
;
}
if
(
!
target
-
>
HasWeirdParserInsertionMode
(
)
&
&
aInnerHTML
.
Length
(
)
<
100
&
&
!
ContainsMarkup
(
aInnerHTML
)
)
{
aError
=
nsContentUtils
:
:
SetNodeTextContent
(
target
aInnerHTML
false
)
;
return
;
}
nsIDocument
*
doc
=
target
-
>
OwnerDoc
(
)
;
mozAutoSubtreeModified
subtree
(
doc
nullptr
)
;
target
-
>
FireNodeRemovedForChildren
(
)
;
mozAutoDocUpdate
updateBatch
(
doc
true
)
;
nsAutoMutationBatch
mb
(
target
true
false
)
;
while
(
target
-
>
HasChildren
(
)
)
{
target
-
>
RemoveChildNode
(
target
-
>
GetFirstChild
(
)
true
)
;
}
mb
.
RemovalDone
(
)
;
nsAutoScriptLoaderDisabler
sld
(
doc
)
;
nsAtom
*
contextLocalName
=
NodeInfo
(
)
-
>
NameAtom
(
)
;
int32_t
contextNameSpaceID
=
GetNameSpaceID
(
)
;
if
(
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
this
)
)
{
contextLocalName
=
shadowRoot
-
>
GetHost
(
)
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
contextNameSpaceID
=
shadowRoot
-
>
GetHost
(
)
-
>
GetNameSpaceID
(
)
;
}
if
(
doc
-
>
IsHTMLDocument
(
)
)
{
int32_t
oldChildCount
=
target
-
>
GetChildCount
(
)
;
aError
=
nsContentUtils
:
:
ParseFragmentHTML
(
aInnerHTML
target
contextLocalName
contextNameSpaceID
doc
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
true
)
;
mb
.
NodesAdded
(
)
;
nsContentUtils
:
:
FireMutationEventsForDirectParsing
(
doc
target
oldChildCount
)
;
}
else
{
RefPtr
<
DocumentFragment
>
df
=
nsContentUtils
:
:
CreateContextualFragment
(
target
aInnerHTML
true
aError
)
;
if
(
!
aError
.
Failed
(
)
)
{
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
static_cast
<
nsINode
*
>
(
target
)
-
>
AppendChild
(
*
df
aError
)
;
mb
.
NodesAdded
(
)
;
}
}
}
void
FragmentOrElement
:
:
FireNodeRemovedForChildren
(
)
{
nsIDocument
*
doc
=
OwnerDoc
(
)
;
if
(
!
nsContentUtils
:
:
HasMutationListeners
(
doc
NS_EVENT_BITS_MUTATION_NODEREMOVED
)
)
{
return
;
}
nsCOMPtr
<
nsINode
>
child
;
for
(
child
=
GetFirstChild
(
)
;
child
&
&
child
-
>
GetParentNode
(
)
=
=
this
;
child
=
child
-
>
GetNextSibling
(
)
)
{
nsContentUtils
:
:
MaybeFireNodeRemoved
(
child
this
)
;
}
}
void
FragmentOrElement
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
nsIContent
:
:
AddSizeOfExcludingThis
(
aSizes
aNodeSize
)
;
*
aNodeSize
+
=
mAttrsAndChildren
.
SizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
nsDOMSlots
*
slots
=
GetExistingDOMSlots
(
)
;
if
(
slots
)
{
*
aNodeSize
+
=
slots
-
>
SizeOfIncludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
}
}
