#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
dom
/
FragmentOrElement
.
h
"
#
include
"
DOMIntersectionObserver
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
ElementAnimationData
.
h
"
#
include
"
mozilla
/
DeclarationBlock
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
mozInlineSpellChecker
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
URLExtraData
.
h
"
#
include
"
mozilla
/
dom
/
Attr
.
h
"
#
include
"
mozilla
/
dom
/
RadioGroupContainer
.
h
"
#
include
"
mozilla
/
dom
/
UnbindContext
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
CloseWatcher
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
CustomElementRegistry
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsIControllers
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsDOMCSSAttrDeclaration
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
ifdef
DEBUG
#
include
"
nsRange
.
h
"
#
endif
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsView
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
NodeListBinding
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsDOMMutationObserver
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsCycleCollector
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTemplateElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGUseElement
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsChildContentList
.
h
"
#
include
"
mozilla
/
BloomFilter
.
h
"
#
include
"
NodeUbiReporting
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
uint64_t
nsMutationGuard
:
:
sGeneration
=
0
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsIContent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsIContent
)
MOZ_ASSERT_UNREACHABLE
(
"
Our
subclasses
don
'
t
call
us
"
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsIContent
)
MOZ_ASSERT_UNREACHABLE
(
"
Our
subclasses
don
'
t
call
us
"
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN
(
nsIContent
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY
(
nsIContent
)
NS_INTERFACE_MAP_ENTRY
(
nsINode
)
NS_INTERFACE_MAP_ENTRY
(
mozilla
:
:
dom
:
:
EventTarget
)
NS_INTERFACE_MAP_ENTRY_TEAROFF
(
nsISupportsWeakReference
new
nsNodeSupportsWeakRefTearoff
(
this
)
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsIContent
)
NS_IMPL_DOMARENA_DESTROY
(
nsIContent
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE_AND_DESTROY
(
nsIContent
LastRelease
(
)
Destroy
(
)
)
nsIContent
*
nsIContent
:
:
FindFirstNonChromeOnlyAccessContent
(
)
const
{
for
(
const
nsIContent
*
content
=
this
;
content
;
content
=
content
-
>
GetChromeOnlyAccessSubtreeRootParent
(
)
)
{
if
(
!
content
-
>
ChromeOnlyAccess
(
)
)
{
return
const_cast
<
nsIContent
*
>
(
content
)
;
}
}
return
nullptr
;
}
void
nsIContent
:
:
UnbindFromTree
(
)
{
UnbindContext
context
(
*
this
)
;
UnbindFromTree
(
context
)
;
}
HTMLSlotElement
*
nsIContent
:
:
GetAssignedSlotByMode
(
)
const
{
HTMLSlotElement
*
slot
=
GetAssignedSlot
(
)
;
if
(
!
slot
)
{
return
nullptr
;
}
MOZ_ASSERT
(
GetParent
(
)
)
;
MOZ_ASSERT
(
GetParent
(
)
-
>
GetShadowRoot
(
)
)
;
if
(
GetParent
(
)
-
>
GetShadowRoot
(
)
-
>
IsClosed
(
)
)
{
return
nullptr
;
}
return
slot
;
}
nsIContent
:
:
IMEState
nsIContent
:
:
GetDesiredIMEState
(
)
{
if
(
!
IsEditable
(
)
|
|
!
IsInComposedDoc
(
)
)
{
if
(
!
IsElement
(
)
|
|
!
AsElement
(
)
-
>
State
(
)
.
HasState
(
ElementState
:
:
READWRITE
)
)
{
return
IMEState
(
IMEEnabled
:
:
Disabled
)
;
}
}
nsIContent
*
editableAncestor
=
GetEditingHost
(
)
;
if
(
editableAncestor
&
&
editableAncestor
!
=
this
)
{
return
editableAncestor
-
>
GetDesiredIMEState
(
)
;
}
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
IMEState
(
IMEEnabled
:
:
Disabled
)
;
}
nsPresContext
*
pc
=
doc
-
>
GetPresContext
(
)
;
if
(
!
pc
)
{
return
IMEState
(
IMEEnabled
:
:
Disabled
)
;
}
HTMLEditor
*
htmlEditor
=
nsContentUtils
:
:
GetHTMLEditor
(
pc
)
;
if
(
!
htmlEditor
)
{
return
IMEState
(
IMEEnabled
:
:
Disabled
)
;
}
IMEState
state
;
htmlEditor
-
>
GetPreferredIMEState
(
&
state
)
;
return
state
;
}
bool
nsIContent
:
:
HasIndependentSelection
(
)
const
{
nsIFrame
*
frame
=
GetPrimaryFrame
(
)
;
return
(
frame
&
&
frame
-
>
HasAnyStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
)
;
}
dom
:
:
Element
*
nsIContent
:
:
GetEditingHost
(
)
{
if
(
!
IsEditable
(
)
)
{
return
nullptr
;
}
Document
*
doc
=
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
if
(
IsInDesignMode
(
)
&
&
!
IsInShadowTree
(
)
)
{
return
doc
-
>
GetBodyElement
(
)
;
}
dom
:
:
Element
*
editableParentElement
=
nullptr
;
for
(
dom
:
:
Element
*
parent
=
GetParentElement
(
)
;
parent
&
&
parent
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
parent
=
editableParentElement
-
>
GetParentElement
(
)
)
{
editableParentElement
=
parent
;
}
return
editableParentElement
?
editableParentElement
:
dom
:
:
Element
:
:
FromNode
(
this
)
;
}
nsresult
nsIContent
:
:
LookupNamespaceURIInternal
(
const
nsAString
&
aNamespacePrefix
nsAString
&
aNamespaceURI
)
const
{
if
(
aNamespacePrefix
.
EqualsLiteral
(
"
xml
"
)
)
{
aNamespaceURI
.
AssignLiteral
(
"
http
:
/
/
www
.
w3
.
org
/
XML
/
1998
/
namespace
"
)
;
return
NS_OK
;
}
if
(
aNamespacePrefix
.
EqualsLiteral
(
"
xmlns
"
)
)
{
aNamespaceURI
.
AssignLiteral
(
"
http
:
/
/
www
.
w3
.
org
/
2000
/
xmlns
/
"
)
;
return
NS_OK
;
}
RefPtr
<
nsAtom
>
name
;
if
(
!
aNamespacePrefix
.
IsEmpty
(
)
)
{
name
=
NS_Atomize
(
aNamespacePrefix
)
;
NS_ENSURE_TRUE
(
name
NS_ERROR_OUT_OF_MEMORY
)
;
}
else
{
name
=
nsGkAtoms
:
:
xmlns
;
}
for
(
Element
*
element
=
GetAsElementOrParentElement
(
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
if
(
element
-
>
GetAttr
(
kNameSpaceID_XMLNS
name
aNamespaceURI
)
)
{
return
NS_OK
;
}
}
return
NS_ERROR_FAILURE
;
}
nsAtom
*
nsIContent
:
:
GetLang
(
)
const
{
for
(
const
Element
*
element
=
GetAsElementOrParentElement
(
)
;
element
;
element
=
element
-
>
GetParentElement
(
)
)
{
if
(
!
element
-
>
GetAttrCount
(
)
)
{
continue
;
}
const
nsAttrValue
*
attr
=
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
lang
kNameSpaceID_XML
)
;
if
(
!
attr
&
&
element
-
>
SupportsLangAttr
(
)
)
{
attr
=
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
lang
)
;
}
if
(
attr
)
{
MOZ_ASSERT
(
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eAtom
)
;
MOZ_ASSERT
(
attr
-
>
GetAtomValue
(
)
)
;
return
attr
-
>
GetAtomValue
(
)
;
}
}
return
nullptr
;
}
nsIURI
*
nsIContent
:
:
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
)
const
{
if
(
SVGUseElement
*
use
=
GetContainingSVGUseShadowHost
(
)
)
{
if
(
URLExtraData
*
data
=
use
-
>
GetContentURLData
(
)
)
{
return
data
-
>
BaseURI
(
)
;
}
}
return
OwnerDoc
(
)
-
>
GetBaseURI
(
aTryUseXHRDocBaseURI
)
;
}
nsIURI
*
nsIContent
:
:
GetBaseURIForStyleAttr
(
)
const
{
if
(
SVGUseElement
*
use
=
GetContainingSVGUseShadowHost
(
)
)
{
if
(
URLExtraData
*
data
=
use
-
>
GetContentURLData
(
)
)
{
return
data
-
>
BaseURI
(
)
;
}
}
return
OwnerDoc
(
)
-
>
GetDocBaseURI
(
)
;
}
already_AddRefed
<
URLExtraData
>
nsIContent
:
:
GetURLDataForStyleAttr
(
nsIPrincipal
*
aSubjectPrincipal
)
const
{
if
(
SVGUseElement
*
use
=
GetContainingSVGUseShadowHost
(
)
)
{
if
(
URLExtraData
*
data
=
use
-
>
GetContentURLData
(
)
)
{
return
do_AddRef
(
data
)
;
}
}
auto
*
doc
=
OwnerDoc
(
)
;
if
(
aSubjectPrincipal
&
&
aSubjectPrincipal
!
=
NodePrincipal
(
)
)
{
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
doc
-
>
ReferrerInfoForInternalCSSAndSVGResources
(
)
;
return
MakeAndAddRef
<
URLExtraData
>
(
doc
-
>
GetDocBaseURI
(
)
referrerInfo
aSubjectPrincipal
)
;
}
return
do_AddRef
(
doc
-
>
DefaultStyleAttrURLData
(
)
)
;
}
void
nsIContent
:
:
ConstructUbiNode
(
void
*
storage
)
{
JS
:
:
ubi
:
:
Concrete
<
nsIContent
>
:
:
construct
(
storage
this
)
;
}
bool
nsIContent
:
:
InclusiveDescendantMayNeedSpellchecking
(
HTMLEditor
*
aEditor
)
{
return
HasFlag
(
NODE_MAY_HAVE_ELEMENT_CHILDREN
)
|
|
mozInlineSpellChecker
:
:
ShouldSpellCheckNode
(
aEditor
this
)
;
}
static
inline
JSObject
*
GetJSObjectChild
(
nsWrapperCache
*
aCache
)
{
return
aCache
-
>
PreservingWrapper
(
)
?
aCache
-
>
GetWrapperPreserveColor
(
)
:
nullptr
;
}
static
bool
NeedsScriptTraverse
(
nsINode
*
aNode
)
{
return
aNode
-
>
PreservingWrapper
(
)
&
&
aNode
-
>
GetWrapperPreserveColor
(
)
&
&
!
aNode
-
>
HasKnownLiveWrapperAndDoesNotNeedTracing
(
aNode
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsAttrChildContentList
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsAttrChildContentList
)
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
nsAttrChildContentList
mNode
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
nsAttrChildContentList
)
return
tmp
-
>
HasKnownLiveWrapper
(
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
nsAttrChildContentList
)
return
tmp
-
>
HasKnownLiveWrapperAndDoesNotNeedTracing
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
nsAttrChildContentList
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_INTERFACE_TABLE_HEAD
(
nsAttrChildContentList
)
NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY
NS_INTERFACE_TABLE
(
nsAttrChildContentList
nsINodeList
)
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
nsAttrChildContentList
)
NS_INTERFACE_MAP_END
JSObject
*
nsAttrChildContentList
:
:
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
NodeList_Binding
:
:
Wrap
(
cx
this
aGivenProto
)
;
}
uint32_t
nsAttrChildContentList
:
:
Length
(
)
{
return
mNode
?
mNode
-
>
GetChildCount
(
)
:
0
;
}
nsIContent
*
nsAttrChildContentList
:
:
Item
(
uint32_t
aIndex
)
{
if
(
mNode
)
{
return
mNode
-
>
GetChildAt_Deprecated
(
aIndex
)
;
}
return
nullptr
;
}
int32_t
nsAttrChildContentList
:
:
IndexOf
(
nsIContent
*
aContent
)
{
if
(
mNode
)
{
return
mNode
-
>
ComputeIndexOf_Deprecated
(
aContent
)
;
}
return
-
1
;
}
uint32_t
nsParentNodeChildContentList
:
:
Length
(
)
{
return
mNode
?
mNode
-
>
GetChildCount
(
)
:
0
;
}
nsIContent
*
nsParentNodeChildContentList
:
:
Item
(
uint32_t
aIndex
)
{
if
(
!
mIsCacheValid
)
{
if
(
MOZ_UNLIKELY
(
!
mNode
)
)
{
return
nullptr
;
}
if
(
aIndex
=
=
0
)
{
return
mNode
-
>
GetFirstChild
(
)
;
}
if
(
aIndex
-
1
=
=
mNode
-
>
GetChildCount
(
)
)
{
return
mNode
-
>
GetLastChild
(
)
;
}
ValidateCache
(
)
;
MOZ_ASSERT
(
mIsCacheValid
)
;
}
return
mCachedChildArray
.
SafeElementAt
(
aIndex
nullptr
)
;
}
int32_t
nsParentNodeChildContentList
:
:
IndexOf
(
nsIContent
*
aContent
)
{
EnsureCacheValid
(
)
;
return
mCachedChildArray
.
IndexOf
(
aContent
)
;
}
void
nsParentNodeChildContentList
:
:
ValidateCache
(
)
{
MOZ_ASSERT
(
!
mIsCacheValid
)
;
MOZ_ASSERT
(
mCachedChildArray
.
IsEmpty
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
mNode
)
)
{
return
;
}
for
(
nsIContent
*
node
=
mNode
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
mCachedChildArray
.
AppendElement
(
node
)
;
}
mIsCacheValid
=
true
;
}
nsIHTMLCollection
*
FragmentOrElement
:
:
Children
(
)
{
nsDOMSlots
*
slots
=
DOMSlots
(
)
;
if
(
!
slots
-
>
mChildrenList
)
{
slots
-
>
mChildrenList
=
new
nsContentList
(
this
kNameSpaceID_Wildcard
nsGkAtoms
:
:
_asterisk
nsGkAtoms
:
:
_asterisk
false
)
;
}
return
slots
-
>
mChildrenList
;
}
NS_IMPL_CYCLE_COLLECTION
(
nsNodeSupportsWeakRefTearoff
mNode
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsNodeSupportsWeakRefTearoff
)
NS_INTERFACE_MAP_ENTRY
(
nsISupportsWeakReference
)
NS_INTERFACE_MAP_END_AGGREGATED
(
mNode
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsNodeSupportsWeakRefTearoff
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsNodeSupportsWeakRefTearoff
)
NS_IMETHODIMP
nsNodeSupportsWeakRefTearoff
:
:
GetWeakReference
(
nsIWeakReference
*
*
aInstancePtr
)
{
nsINode
:
:
nsSlots
*
slots
=
mNode
-
>
Slots
(
)
;
if
(
!
slots
-
>
mWeakReference
)
{
slots
-
>
mWeakReference
=
new
nsNodeWeakReference
(
mNode
)
;
}
NS_ADDREF
(
*
aInstancePtr
=
slots
-
>
mWeakReference
)
;
return
NS_OK
;
}
static
const
size_t
MaxDOMSlotSizeAllowed
=
#
ifdef
HAVE_64BIT_BUILD
128
;
#
else
64
;
#
endif
static_assert
(
sizeof
(
nsINode
:
:
nsSlots
)
<
=
MaxDOMSlotSizeAllowed
"
DOM
slots
cannot
be
grown
without
consideration
"
)
;
static_assert
(
sizeof
(
FragmentOrElement
:
:
nsDOMSlots
)
<
=
MaxDOMSlotSizeAllowed
"
DOM
slots
cannot
be
grown
without
consideration
"
)
;
void
nsIContent
:
:
nsExtendedContentSlots
:
:
UnlinkExtendedSlots
(
nsIContent
&
)
{
mContainingShadow
=
nullptr
;
mAssignedSlot
=
nullptr
;
}
void
nsIContent
:
:
nsExtendedContentSlots
:
:
TraverseExtendedSlots
(
nsCycleCollectionTraversalCallback
&
aCb
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mContainingShadow
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIContent
*
mContainingShadow
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mAssignedSlot
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIContent
*
mAssignedSlot
.
get
(
)
)
)
;
}
nsIContent
:
:
nsExtendedContentSlots
:
:
nsExtendedContentSlots
(
)
=
default
;
nsIContent
:
:
nsExtendedContentSlots
:
:
~
nsExtendedContentSlots
(
)
{
MOZ_ASSERT
(
!
mManualSlotAssignment
)
;
}
size_t
nsIContent
:
:
nsExtendedContentSlots
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
FragmentOrElement
:
:
nsDOMSlots
:
:
nsDOMSlots
(
)
{
MOZ_COUNT_CTOR
(
nsDOMSlots
)
;
}
FragmentOrElement
:
:
nsDOMSlots
:
:
~
nsDOMSlots
(
)
{
MOZ_COUNT_DTOR
(
nsDOMSlots
)
;
if
(
mAttributeMap
)
{
mAttributeMap
-
>
DropReference
(
)
;
}
}
void
FragmentOrElement
:
:
nsDOMSlots
:
:
Traverse
(
nsCycleCollectionTraversalCallback
&
aCb
)
{
nsIContent
:
:
nsContentSlots
:
:
Traverse
(
aCb
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mStyle
"
)
;
aCb
.
NoteXPCOMChild
(
mStyle
.
get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mAttributeMap
"
)
;
aCb
.
NoteXPCOMChild
(
mAttributeMap
.
get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mChildrenList
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsINodeList
*
mChildrenList
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mClassList
"
)
;
aCb
.
NoteXPCOMChild
(
mClassList
.
get
(
)
)
;
}
void
FragmentOrElement
:
:
nsDOMSlots
:
:
Unlink
(
nsINode
&
aNode
)
{
nsIContent
:
:
nsContentSlots
:
:
Unlink
(
aNode
)
;
mStyle
=
nullptr
;
if
(
mAttributeMap
)
{
mAttributeMap
-
>
DropReference
(
)
;
mAttributeMap
=
nullptr
;
}
mChildrenList
=
nullptr
;
mClassList
=
nullptr
;
}
size_t
FragmentOrElement
:
:
nsDOMSlots
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
nsExtendedContentSlots
*
extendedSlots
=
GetExtendedContentSlots
(
)
;
if
(
extendedSlots
)
{
if
(
OwnsExtendedSlots
(
)
)
{
n
+
=
aMallocSizeOf
(
extendedSlots
)
;
}
n
+
=
extendedSlots
-
>
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
if
(
mAttributeMap
)
{
n
+
=
mAttributeMap
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mChildrenList
)
{
n
+
=
mChildrenList
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
nsExtendedDOMSlots
(
)
=
default
;
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
~
nsExtendedDOMSlots
(
)
=
default
;
void
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
UnlinkExtendedSlots
(
nsIContent
&
aContent
)
{
nsIContent
:
:
nsExtendedContentSlots
:
:
UnlinkExtendedSlots
(
aContent
)
;
mSMILOverrideStyle
=
nullptr
;
mControllers
=
nullptr
;
mLabelsList
=
nullptr
;
mPopoverData
=
nullptr
;
if
(
mCustomElementData
)
{
mCustomElementData
-
>
Unlink
(
)
;
mCustomElementData
=
nullptr
;
}
if
(
mAnimations
)
{
mAnimations
=
nullptr
;
aContent
.
ClearMayHaveAnimations
(
)
;
}
mExplicitlySetAttrElementMap
.
Clear
(
)
;
mAttrElementsMap
.
Clear
(
)
;
mRadioGroupContainer
=
nullptr
;
mPart
=
nullptr
;
}
void
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
TraverseExtendedSlots
(
nsCycleCollectionTraversalCallback
&
aCb
)
{
nsIContent
:
:
nsExtendedContentSlots
:
:
TraverseExtendedSlots
(
aCb
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mSMILOverrideStyle
"
)
;
aCb
.
NoteXPCOMChild
(
mSMILOverrideStyle
.
get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mControllers
"
)
;
aCb
.
NoteXPCOMChild
(
mControllers
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mLabelsList
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsINodeList
*
mLabelsList
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mExtendedSlots
-
>
mShadowRoot
"
)
;
aCb
.
NoteXPCOMChild
(
NS_ISUPPORTS_CAST
(
nsIContent
*
mShadowRoot
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
aCb
"
mSlots
-
>
mPart
"
)
;
aCb
.
NoteXPCOMChild
(
mPart
.
get
(
)
)
;
for
(
auto
&
tableEntry
:
mAttrElementsMap
)
{
auto
&
[
explicitlySetElements
cachedAttrElements
]
=
*
tableEntry
.
GetModifiableData
(
)
;
if
(
cachedAttrElements
)
{
ImplCycleCollectionTraverse
(
aCb
*
cachedAttrElements
"
cached
attribute
elements
entry
"
0
)
;
}
}
if
(
mCustomElementData
)
{
mCustomElementData
-
>
Traverse
(
aCb
)
;
}
if
(
mAnimations
)
{
mAnimations
-
>
Traverse
(
aCb
)
;
}
if
(
mRadioGroupContainer
)
{
RadioGroupContainer
:
:
Traverse
(
mRadioGroupContainer
.
get
(
)
aCb
)
;
}
}
size_t
FragmentOrElement
:
:
nsExtendedDOMSlots
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
nsIContent
:
:
nsExtendedContentSlots
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
if
(
mSMILOverrideStyle
)
{
n
+
=
aMallocSizeOf
(
mSMILOverrideStyle
)
;
}
if
(
mControllers
)
{
n
+
=
aMallocSizeOf
(
mControllers
)
;
}
if
(
mLabelsList
)
{
n
+
=
mLabelsList
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mCustomElementData
)
{
n
+
=
mCustomElementData
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
if
(
mRadioGroupContainer
)
{
n
+
=
mRadioGroupContainer
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
FragmentOrElement
:
:
FragmentOrElement
(
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeInfo
>
&
&
aNodeInfo
)
:
nsIContent
(
std
:
:
move
(
aNodeInfo
)
)
{
}
FragmentOrElement
:
:
~
FragmentOrElement
(
)
{
MOZ_ASSERT
(
!
IsInUncomposedDoc
(
)
"
Please
remove
this
from
the
document
properly
"
)
;
if
(
GetParent
(
)
)
{
NS_RELEASE
(
mParent
)
;
}
}
static
nsINode
*
FindChromeAccessOnlySubtreeOwner
(
nsINode
*
aNode
)
{
if
(
!
aNode
-
>
ChromeOnlyAccess
(
)
)
{
return
aNode
;
}
return
const_cast
<
nsIContent
*
>
(
aNode
-
>
GetChromeOnlyAccessSubtreeRootParent
(
)
)
;
}
nsINode
*
FindChromeAccessOnlySubtreeOwner
(
EventTarget
*
aTarget
)
{
nsINode
*
node
=
nsINode
:
:
FromEventTargetOrNull
(
aTarget
)
;
if
(
!
node
)
{
return
nullptr
;
}
return
FindChromeAccessOnlySubtreeOwner
(
node
)
;
}
void
nsIContent
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
mMayHaveListenerManager
=
HasListenerManager
(
)
;
if
(
IsInShadowTree
(
)
)
{
aVisitor
.
mItemInShadowTree
=
true
;
}
const
bool
isAnonForEvents
=
IsRootOfChromeAccessOnlySubtree
(
)
;
aVisitor
.
mRootOfClosedTree
=
isAnonForEvents
;
if
(
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseOver
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseOut
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
ePointerOver
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
ePointerOut
)
&
&
(
(
this
=
=
aVisitor
.
mEvent
-
>
mOriginalTarget
&
&
!
ChromeOnlyAccess
(
)
)
|
|
isAnonForEvents
)
)
{
nsIContent
*
relatedTarget
=
nsIContent
:
:
FromEventTargetOrNull
(
aVisitor
.
mEvent
-
>
AsMouseEvent
(
)
-
>
mRelatedTarget
)
;
if
(
relatedTarget
&
&
relatedTarget
-
>
OwnerDoc
(
)
=
=
OwnerDoc
(
)
)
{
if
(
isAnonForEvents
|
|
aVisitor
.
mRelatedTargetIsInAnon
|
|
(
aVisitor
.
mEvent
-
>
mOriginalTarget
=
=
this
&
&
(
aVisitor
.
mRelatedTargetIsInAnon
=
relatedTarget
-
>
ChromeOnlyAccess
(
)
)
)
)
{
nsINode
*
anonOwner
=
FindChromeAccessOnlySubtreeOwner
(
this
)
;
if
(
anonOwner
)
{
nsINode
*
anonOwnerRelated
=
FindChromeAccessOnlySubtreeOwner
(
relatedTarget
)
;
if
(
anonOwnerRelated
)
{
while
(
anonOwner
!
=
anonOwnerRelated
&
&
anonOwnerRelated
-
>
ChromeOnlyAccess
(
)
)
{
anonOwnerRelated
=
FindChromeAccessOnlySubtreeOwner
(
anonOwnerRelated
)
;
}
if
(
anonOwner
=
=
anonOwnerRelated
)
{
#
ifdef
DEBUG_smaug
nsIContent
*
originalTarget
=
nsIContent
:
:
FromEventTargetOrNull
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
nsAutoString
ot
ct
rt
;
if
(
originalTarget
)
{
originalTarget
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
ot
)
;
}
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
ct
)
;
relatedTarget
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
rt
)
;
printf
(
"
Stopping
%
s
propagation
:
"
"
\
n
\
toriginalTarget
=
%
s
\
n
\
tcurrentTarget
=
%
s
%
s
"
"
\
n
\
trelatedTarget
=
%
s
%
s
\
n
%
s
"
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseOver
)
?
"
mouseover
"
:
"
mouseout
"
NS_ConvertUTF16toUTF8
(
ot
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
ct
)
.
get
(
)
isAnonForEvents
?
"
(
is
native
anonymous
)
"
:
(
ChromeOnlyAccess
(
)
?
"
(
is
in
native
anonymous
subtree
)
"
:
"
"
)
NS_ConvertUTF16toUTF8
(
rt
)
.
get
(
)
relatedTarget
-
>
ChromeOnlyAccess
(
)
?
"
(
is
in
native
anonymous
subtree
)
"
:
"
"
(
originalTarget
&
&
relatedTarget
-
>
FindFirstNonChromeOnlyAccessContent
(
)
=
=
originalTarget
-
>
FindFirstNonChromeOnlyAccessContent
(
)
)
?
"
"
:
"
Wrong
event
propagation
!
?
!
\
n
"
)
;
#
endif
aVisitor
.
SetParentTarget
(
nullptr
false
)
;
aVisitor
.
mCanHandle
=
isAnonForEvents
;
return
;
}
}
}
}
}
}
HTMLSlotElement
*
slot
=
GetAssignedSlot
(
)
;
nsIContent
*
parent
=
slot
?
slot
:
GetParent
(
)
;
if
(
isAnonForEvents
)
{
#
ifdef
DEBUG
nsIContent
*
t
=
nsIContent
:
:
FromEventTargetOrNull
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
NS_ASSERTION
(
!
t
|
|
!
t
-
>
ChromeOnlyAccess
(
)
|
|
aVisitor
.
mEvent
-
>
mClass
!
=
eMutationEventClass
|
|
aVisitor
.
mDOMEvent
"
Mutation
event
dispatched
in
native
anonymous
content
!
?
!
"
)
;
#
endif
if
(
aVisitor
.
mEvent
-
>
mClass
=
=
eTransitionEventClass
|
|
aVisitor
.
mEvent
-
>
mClass
=
=
eAnimationEventClass
)
{
aVisitor
.
SetParentTarget
(
nullptr
false
)
;
return
;
}
aVisitor
.
mEventTargetAtParent
=
parent
;
}
else
if
(
parent
&
&
aVisitor
.
mOriginalTargetIsInAnon
)
{
nsIContent
*
content
=
nsIContent
:
:
FromEventTargetOrNull
(
aVisitor
.
mEvent
-
>
mTarget
)
;
if
(
content
&
&
content
-
>
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
=
=
parent
)
{
aVisitor
.
mEventTargetAtParent
=
parent
;
}
}
if
(
!
aVisitor
.
mEvent
-
>
mFlags
.
mComposedInNativeAnonymousContent
&
&
IsRootOfNativeAnonymousSubtree
(
)
&
&
OwnerDoc
(
)
-
>
GetWindow
(
)
)
{
aVisitor
.
SetParentTarget
(
OwnerDoc
(
)
-
>
GetWindow
(
)
-
>
GetParentTarget
(
)
true
)
;
}
else
if
(
parent
)
{
aVisitor
.
SetParentTarget
(
parent
false
)
;
if
(
slot
)
{
ShadowRoot
*
root
=
slot
-
>
GetContainingShadow
(
)
;
if
(
root
&
&
root
-
>
IsClosed
(
)
)
{
aVisitor
.
mParentIsSlotInClosedTree
=
true
;
}
}
}
else
{
aVisitor
.
SetParentTarget
(
GetComposedDoc
(
)
false
)
;
}
if
(
!
ChromeOnlyAccess
(
)
&
&
!
aVisitor
.
mRelatedTargetRetargetedInCurrentScope
)
{
aVisitor
.
mRelatedTargetRetargetedInCurrentScope
=
true
;
if
(
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
)
{
bool
initialTarget
=
this
=
=
aVisitor
.
mEvent
-
>
mOriginalTarget
;
nsCOMPtr
<
nsINode
>
originalTargetAsNode
;
if
(
!
initialTarget
&
&
aVisitor
.
mOriginalTargetIsInAnon
)
{
originalTargetAsNode
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
initialTarget
=
originalTargetAsNode
=
=
this
;
}
if
(
initialTarget
)
{
nsCOMPtr
<
nsINode
>
relatedTargetAsNode
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
)
;
if
(
!
originalTargetAsNode
)
{
originalTargetAsNode
=
nsINode
:
:
FromEventTargetOrNull
(
aVisitor
.
mEvent
-
>
mOriginalTarget
)
;
}
if
(
relatedTargetAsNode
&
&
originalTargetAsNode
)
{
nsINode
*
retargetedRelatedTarget
=
nsContentUtils
:
:
Retarget
(
relatedTargetAsNode
originalTargetAsNode
)
;
if
(
originalTargetAsNode
=
=
retargetedRelatedTarget
&
&
retargetedRelatedTarget
!
=
relatedTargetAsNode
)
{
aVisitor
.
IgnoreCurrentTargetBecauseOfShadowDOMRetargeting
(
)
;
aVisitor
.
mEvent
-
>
mTarget
=
aVisitor
.
mTargetInKnownToBeHandledScope
;
return
;
}
aVisitor
.
mRetargetedRelatedTarget
=
retargetedRelatedTarget
;
}
}
else
{
nsCOMPtr
<
nsINode
>
relatedTargetAsNode
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mEvent
-
>
mOriginalRelatedTarget
)
;
if
(
relatedTargetAsNode
)
{
nsINode
*
retargetedRelatedTarget
=
nsContentUtils
:
:
Retarget
(
relatedTargetAsNode
this
)
;
nsCOMPtr
<
nsINode
>
targetInKnownToBeHandledScope
=
FindChromeAccessOnlySubtreeOwner
(
aVisitor
.
mTargetInKnownToBeHandledScope
)
;
if
(
targetInKnownToBeHandledScope
&
&
IsShadowIncludingInclusiveDescendantOf
(
targetInKnownToBeHandledScope
-
>
SubtreeRoot
(
)
)
)
{
aVisitor
.
mRetargetedRelatedTarget
=
retargetedRelatedTarget
;
}
else
if
(
this
=
=
retargetedRelatedTarget
)
{
aVisitor
.
IgnoreCurrentTargetBecauseOfShadowDOMRetargeting
(
)
;
aVisitor
.
mEvent
-
>
mTarget
=
aVisitor
.
mTargetInKnownToBeHandledScope
;
return
;
}
else
if
(
targetInKnownToBeHandledScope
)
{
aVisitor
.
mRetargetedRelatedTarget
=
retargetedRelatedTarget
;
}
}
}
}
if
(
aVisitor
.
mEvent
-
>
mClass
=
=
eTouchEventClass
)
{
MOZ_ASSERT
(
!
aVisitor
.
mRetargetedTouchTargets
.
isSome
(
)
)
;
aVisitor
.
mRetargetedTouchTargets
.
emplace
(
)
;
WidgetTouchEvent
*
touchEvent
=
aVisitor
.
mEvent
-
>
AsTouchEvent
(
)
;
WidgetTouchEvent
:
:
TouchArray
&
touches
=
touchEvent
-
>
mTouches
;
for
(
uint32_t
i
=
0
;
i
<
touches
.
Length
(
)
;
+
+
i
)
{
Touch
*
touch
=
touches
[
i
]
;
EventTarget
*
originalTarget
=
touch
-
>
mOriginalTarget
;
EventTarget
*
touchTarget
=
originalTarget
;
nsCOMPtr
<
nsINode
>
targetAsNode
=
nsINode
:
:
FromEventTargetOrNull
(
originalTarget
)
;
if
(
targetAsNode
)
{
EventTarget
*
retargeted
=
nsContentUtils
:
:
Retarget
(
targetAsNode
this
)
;
if
(
retargeted
)
{
touchTarget
=
retargeted
;
}
}
aVisitor
.
mRetargetedTouchTargets
-
>
AppendElement
(
touchTarget
)
;
touch
-
>
mTarget
=
touchTarget
;
}
MOZ_ASSERT
(
aVisitor
.
mRetargetedTouchTargets
-
>
Length
(
)
=
=
touches
.
Length
(
)
)
;
}
}
if
(
slot
)
{
aVisitor
.
mRelatedTargetRetargetedInCurrentScope
=
false
;
}
}
Element
*
nsIContent
:
:
GetAutofocusDelegate
(
IsFocusableFlags
aFlags
)
const
{
for
(
nsINode
*
node
=
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
this
)
)
{
auto
*
descendant
=
Element
:
:
FromNode
(
*
node
)
;
if
(
!
descendant
|
|
!
descendant
-
>
GetBoolAttr
(
nsGkAtoms
:
:
autofocus
)
)
{
continue
;
}
nsIFrame
*
frame
=
descendant
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsFocusable
(
aFlags
)
)
{
return
descendant
;
}
}
return
nullptr
;
}
Element
*
nsIContent
:
:
GetFocusDelegate
(
IsFocusableFlags
aFlags
)
const
{
const
nsIContent
*
whereToLook
=
this
;
if
(
ShadowRoot
*
root
=
GetShadowRoot
(
)
)
{
if
(
!
root
-
>
DelegatesFocus
(
)
)
{
return
nullptr
;
}
whereToLook
=
root
;
}
auto
IsFocusable
=
[
&
]
(
Element
*
aElement
)
-
>
Focusable
{
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
{
}
;
}
return
frame
-
>
IsFocusable
(
aFlags
)
;
}
;
Element
*
potentialFocus
=
nullptr
;
for
(
nsINode
*
node
=
whereToLook
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
whereToLook
)
)
{
auto
*
el
=
Element
:
:
FromNode
(
*
node
)
;
if
(
!
el
)
{
continue
;
}
const
bool
autofocus
=
el
-
>
GetBoolAttr
(
nsGkAtoms
:
:
autofocus
)
;
if
(
autofocus
)
{
if
(
IsFocusable
(
el
)
)
{
return
el
;
}
}
else
if
(
!
potentialFocus
)
{
if
(
Focusable
focusable
=
IsFocusable
(
el
)
)
{
if
(
IsHTMLElement
(
nsGkAtoms
:
:
dialog
)
)
{
if
(
focusable
.
mTabIndex
>
=
0
)
{
potentialFocus
=
el
;
}
}
else
{
potentialFocus
=
el
;
}
}
}
if
(
!
autofocus
&
&
potentialFocus
)
{
continue
;
}
if
(
auto
*
shadow
=
el
-
>
GetShadowRoot
(
)
)
{
if
(
shadow
-
>
DelegatesFocus
(
)
)
{
if
(
Element
*
delegatedFocus
=
shadow
-
>
GetFocusDelegate
(
aFlags
)
)
{
if
(
autofocus
)
{
return
delegatedFocus
;
}
if
(
!
potentialFocus
)
{
potentialFocus
=
delegatedFocus
;
}
}
}
}
}
return
potentialFocus
;
}
Focusable
nsIContent
:
:
IsFocusableWithoutStyle
(
IsFocusableFlags
)
{
return
{
}
;
}
void
nsIContent
:
:
SetAssignedSlot
(
HTMLSlotElement
*
aSlot
)
{
MOZ_ASSERT
(
aSlot
|
|
GetExistingExtendedContentSlots
(
)
)
;
ExtendedContentSlots
(
)
-
>
mAssignedSlot
=
aSlot
;
}
#
ifdef
MOZ_DOM_LIST
void
nsIContent
:
:
Dump
(
)
{
List
(
)
;
}
#
endif
void
FragmentOrElement
:
:
GetTextContentInternal
(
nsAString
&
aTextContent
OOMReporter
&
aError
)
{
if
(
!
nsContentUtils
:
:
GetNodeTextContent
(
this
true
aTextContent
fallible
)
)
{
aError
.
ReportOOM
(
)
;
}
}
void
FragmentOrElement
:
:
SetTextContentInternal
(
const
nsAString
&
aTextContent
nsIPrincipal
*
aSubjectPrincipal
ErrorResult
&
aError
)
{
bool
tryReuse
=
false
;
if
(
!
aTextContent
.
IsEmpty
(
)
)
{
if
(
nsIContent
*
firstChild
=
GetFirstChild
(
)
)
{
tryReuse
=
firstChild
-
>
NodeType
(
)
=
=
TEXT_NODE
&
&
!
firstChild
-
>
GetNextSibling
(
)
&
&
firstChild
-
>
OwnedOnlyByTheDOMAndFrameTrees
(
)
&
&
#
ifdef
ACCESSIBILITY
!
GetAccService
(
)
&
&
#
endif
!
OwnerDoc
(
)
-
>
MayHaveDOMMutationObservers
(
)
&
&
!
nsContentUtils
:
:
HasMutationListeners
(
OwnerDoc
(
)
NS_EVENT_BITS_MUTATION_ALL
)
;
}
}
aError
=
nsContentUtils
:
:
SetNodeTextContent
(
this
aTextContent
tryReuse
)
;
}
void
FragmentOrElement
:
:
DestroyContent
(
)
{
if
(
IsElement
(
)
)
{
AsElement
(
)
-
>
ClearServoData
(
)
;
}
#
ifdef
DEBUG
uint32_t
oldChildCount
=
GetChildCount
(
)
;
#
endif
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
DestroyContent
(
)
;
MOZ_ASSERT
(
child
-
>
GetParent
(
)
=
=
this
"
Mutating
the
tree
during
XBL
destructors
is
evil
"
)
;
}
MOZ_ASSERT
(
oldChildCount
=
=
GetChildCount
(
)
"
Mutating
the
tree
during
XBL
destructors
is
evil
"
)
;
if
(
ShadowRoot
*
shadowRoot
=
GetShadowRoot
(
)
)
{
shadowRoot
-
>
DestroyContent
(
)
;
}
}
void
FragmentOrElement
:
:
SaveSubtreeState
(
)
{
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
SaveSubtreeState
(
)
;
}
}
void
FragmentOrElement
:
:
FireNodeInserted
(
Document
*
aDoc
nsINode
*
aParent
const
nsTArray
<
nsCOMPtr
<
nsIContent
>
>
&
aNodes
)
{
for
(
const
nsCOMPtr
<
nsIContent
>
&
childContent
:
aNodes
)
{
if
(
nsContentUtils
:
:
WantMutationEvents
(
childContent
NS_EVENT_BITS_MUTATION_NODEINSERTED
aParent
)
)
{
InternalMutationEvent
mutation
(
true
eLegacyNodeInserted
)
;
mutation
.
mRelatedNode
=
aParent
;
mozAutoSubtreeModified
subtree
(
aDoc
aParent
)
;
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
*
childContent
mutation
)
;
}
}
}
#
define
SUBTREE_UNBINDINGS_PER_RUNNABLE
500
class
ContentUnbinder
:
public
Runnable
{
public
:
ContentUnbinder
(
)
:
Runnable
(
"
ContentUnbinder
"
)
{
mLast
=
this
;
}
~
ContentUnbinder
(
)
{
Run
(
)
;
}
void
UnbindSubtree
(
nsIContent
*
aNode
)
{
if
(
aNode
-
>
NodeType
(
)
!
=
nsINode
:
:
ELEMENT_NODE
&
&
aNode
-
>
NodeType
(
)
!
=
nsINode
:
:
DOCUMENT_FRAGMENT_NODE
)
{
return
;
}
FragmentOrElement
*
container
=
static_cast
<
FragmentOrElement
*
>
(
aNode
)
;
if
(
container
-
>
HasChildren
(
)
)
{
container
-
>
InvalidateChildNodes
(
)
;
while
(
container
-
>
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
container
-
>
GetLastChild
(
)
;
container
-
>
DisconnectChild
(
child
)
;
UnbindSubtree
(
child
)
;
child
-
>
UnbindFromTree
(
)
;
}
}
}
NS_IMETHOD
Run
(
)
override
{
nsAutoScriptBlocker
scriptBlocker
;
uint32_t
len
=
mSubtreeRoots
.
Length
(
)
;
if
(
len
)
{
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
UnbindSubtree
(
mSubtreeRoots
[
i
]
)
;
}
mSubtreeRoots
.
Clear
(
)
;
}
nsCycleCollector_dispatchDeferredDeletion
(
)
;
if
(
this
=
=
sContentUnbinder
)
{
sContentUnbinder
=
nullptr
;
if
(
mNext
)
{
RefPtr
<
ContentUnbinder
>
next
;
next
.
swap
(
mNext
)
;
sContentUnbinder
=
next
;
next
-
>
mLast
=
mLast
;
mLast
=
nullptr
;
NS_DispatchToCurrentThreadQueue
(
next
.
forget
(
)
EventQueuePriority
:
:
Idle
)
;
}
}
return
NS_OK
;
}
static
void
UnbindAll
(
)
{
RefPtr
<
ContentUnbinder
>
ub
=
sContentUnbinder
;
sContentUnbinder
=
nullptr
;
while
(
ub
)
{
ub
-
>
Run
(
)
;
ub
=
ub
-
>
mNext
;
}
}
static
void
Append
(
nsIContent
*
aSubtreeRoot
)
{
if
(
!
sContentUnbinder
)
{
sContentUnbinder
=
new
ContentUnbinder
(
)
;
nsCOMPtr
<
nsIRunnable
>
e
=
sContentUnbinder
;
NS_DispatchToCurrentThreadQueue
(
e
.
forget
(
)
EventQueuePriority
:
:
Idle
)
;
}
if
(
sContentUnbinder
-
>
mLast
-
>
mSubtreeRoots
.
Length
(
)
>
=
SUBTREE_UNBINDINGS_PER_RUNNABLE
)
{
sContentUnbinder
-
>
mLast
-
>
mNext
=
new
ContentUnbinder
(
)
;
sContentUnbinder
-
>
mLast
=
sContentUnbinder
-
>
mLast
-
>
mNext
;
}
sContentUnbinder
-
>
mLast
-
>
mSubtreeRoots
.
AppendElement
(
aSubtreeRoot
)
;
}
private
:
AutoTArray
<
nsCOMPtr
<
nsIContent
>
SUBTREE_UNBINDINGS_PER_RUNNABLE
>
mSubtreeRoots
;
RefPtr
<
ContentUnbinder
>
mNext
;
ContentUnbinder
*
mLast
;
static
ContentUnbinder
*
sContentUnbinder
;
}
;
ContentUnbinder
*
ContentUnbinder
:
:
sContentUnbinder
=
nullptr
;
void
FragmentOrElement
:
:
ClearContentUnbinder
(
)
{
ContentUnbinder
:
:
UnbindAll
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_CLASS
(
FragmentOrElement
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
FragmentOrElement
)
nsIContent
:
:
Unlink
(
tmp
)
;
if
(
tmp
-
>
UnoptimizableCCNode
(
)
|
|
!
nsCCUncollectableMarker
:
:
sGeneration
)
{
nsAutoScriptBlocker
scriptBlocker
;
while
(
tmp
-
>
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
tmp
-
>
GetLastChild
(
)
;
tmp
-
>
DisconnectChild
(
child
)
;
child
-
>
UnbindFromTree
(
)
;
}
}
else
if
(
!
tmp
-
>
GetParent
(
)
&
&
tmp
-
>
HasChildren
(
)
)
{
ContentUnbinder
:
:
Append
(
tmp
)
;
}
if
(
ShadowRoot
*
shadowRoot
=
tmp
-
>
GetShadowRoot
(
)
)
{
shadowRoot
-
>
Unbind
(
)
;
tmp
-
>
ExtendedDOMSlots
(
)
-
>
mShadowRoot
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
void
FragmentOrElement
:
:
MarkNodeChildren
(
nsINode
*
aNode
)
{
JSObject
*
o
=
GetJSObjectChild
(
aNode
)
;
if
(
o
)
{
JS
:
:
ExposeObjectToActiveJS
(
o
)
;
}
EventListenerManager
*
elm
=
aNode
-
>
GetExistingListenerManager
(
)
;
if
(
elm
)
{
elm
-
>
MarkForCC
(
)
;
}
}
nsINode
*
FindOptimizableSubtreeRoot
(
nsINode
*
aNode
)
{
nsINode
*
p
;
while
(
(
p
=
aNode
-
>
GetParentNode
(
)
)
)
{
if
(
aNode
-
>
UnoptimizableCCNode
(
)
)
{
return
nullptr
;
}
aNode
=
p
;
}
if
(
aNode
-
>
UnoptimizableCCNode
(
)
)
{
return
nullptr
;
}
return
aNode
;
}
StaticAutoPtr
<
nsTHashSet
<
nsINode
*
>
>
gCCBlackMarkedNodes
;
static
void
ClearBlackMarkedNodes
(
)
{
if
(
!
gCCBlackMarkedNodes
)
{
return
;
}
for
(
nsINode
*
n
:
*
gCCBlackMarkedNodes
)
{
n
-
>
SetCCMarkedRoot
(
false
)
;
n
-
>
SetInCCBlackTree
(
false
)
;
}
gCCBlackMarkedNodes
=
nullptr
;
}
void
FragmentOrElement
:
:
RemoveBlackMarkedNode
(
nsINode
*
aNode
)
{
if
(
!
gCCBlackMarkedNodes
)
{
return
;
}
gCCBlackMarkedNodes
-
>
Remove
(
aNode
)
;
}
static
bool
IsCertainlyAliveNode
(
nsINode
*
aNode
Document
*
aDoc
)
{
MOZ_ASSERT
(
aNode
-
>
GetComposedDoc
(
)
=
=
aDoc
)
;
return
nsCCUncollectableMarker
:
:
InGeneration
(
aDoc
-
>
GetMarkedCCGeneration
(
)
)
|
|
(
nsCCUncollectableMarker
:
:
sGeneration
&
&
aDoc
-
>
IsBeingUsedAsImage
(
)
&
&
aDoc
-
>
IsVisible
(
)
)
;
}
bool
FragmentOrElement
:
:
CanSkipInCC
(
nsINode
*
aNode
)
{
if
(
nsCCUncollectableMarker
:
:
sGeneration
=
=
0
)
{
return
false
;
}
Document
*
currentDoc
=
aNode
-
>
GetComposedDoc
(
)
;
if
(
currentDoc
&
&
IsCertainlyAliveNode
(
aNode
currentDoc
)
)
{
return
!
NeedsScriptTraverse
(
aNode
)
;
}
if
(
aNode
-
>
UnoptimizableCCNode
(
)
)
{
return
false
;
}
nsINode
*
root
=
currentDoc
?
static_cast
<
nsINode
*
>
(
currentDoc
)
:
FindOptimizableSubtreeRoot
(
aNode
)
;
if
(
!
root
)
{
return
false
;
}
if
(
root
-
>
CCMarkedRoot
(
)
)
{
return
root
-
>
InCCBlackTree
(
)
&
&
!
NeedsScriptTraverse
(
aNode
)
;
}
if
(
!
gCCBlackMarkedNodes
)
{
gCCBlackMarkedNodes
=
new
nsTHashSet
<
nsINode
*
>
(
1020
)
;
}
AutoTArray
<
nsIContent
*
1020
>
nodesToUnpurple
;
AutoTArray
<
nsINode
*
1020
>
grayNodes
;
bool
foundLiveWrapper
=
root
-
>
HasKnownLiveWrapper
(
)
;
if
(
root
!
=
currentDoc
)
{
currentDoc
=
nullptr
;
if
(
NeedsScriptTraverse
(
root
)
)
{
grayNodes
.
AppendElement
(
root
)
;
}
else
if
(
static_cast
<
nsIContent
*
>
(
root
)
-
>
IsPurple
(
)
)
{
nodesToUnpurple
.
AppendElement
(
static_cast
<
nsIContent
*
>
(
root
)
)
;
}
}
for
(
nsIContent
*
node
=
root
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
root
)
)
{
foundLiveWrapper
=
foundLiveWrapper
|
|
node
-
>
HasKnownLiveWrapper
(
)
;
if
(
foundLiveWrapper
&
&
currentDoc
)
{
break
;
}
if
(
NeedsScriptTraverse
(
node
)
)
{
grayNodes
.
AppendElement
(
node
)
;
}
else
if
(
node
-
>
IsPurple
(
)
)
{
nodesToUnpurple
.
AppendElement
(
node
)
;
}
}
root
-
>
SetCCMarkedRoot
(
true
)
;
root
-
>
SetInCCBlackTree
(
foundLiveWrapper
)
;
gCCBlackMarkedNodes
-
>
Insert
(
root
)
;
if
(
!
foundLiveWrapper
)
{
return
false
;
}
if
(
currentDoc
)
{
currentDoc
-
>
MarkUncollectableForCCGeneration
(
nsCCUncollectableMarker
:
:
sGeneration
)
;
}
else
{
for
(
uint32_t
i
=
0
;
i
<
grayNodes
.
Length
(
)
;
+
+
i
)
{
nsINode
*
node
=
grayNodes
[
i
]
;
node
-
>
SetInCCBlackTree
(
true
)
;
gCCBlackMarkedNodes
-
>
Insert
(
node
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
nodesToUnpurple
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
purple
=
nodesToUnpurple
[
i
]
;
if
(
purple
!
=
aNode
)
{
purple
-
>
RemovePurple
(
)
;
}
}
return
!
NeedsScriptTraverse
(
aNode
)
;
}
AutoTArray
<
nsINode
*
1020
>
*
gPurpleRoots
=
nullptr
;
AutoTArray
<
nsIContent
*
1020
>
*
gNodesToUnbind
=
nullptr
;
void
ClearCycleCollectorCleanupData
(
)
{
if
(
gPurpleRoots
)
{
uint32_t
len
=
gPurpleRoots
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsINode
*
n
=
gPurpleRoots
-
>
ElementAt
(
i
)
;
n
-
>
SetIsPurpleRoot
(
false
)
;
}
delete
gPurpleRoots
;
gPurpleRoots
=
nullptr
;
}
if
(
gNodesToUnbind
)
{
uint32_t
len
=
gNodesToUnbind
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsIContent
*
c
=
gNodesToUnbind
-
>
ElementAt
(
i
)
;
c
-
>
SetIsPurpleRoot
(
false
)
;
ContentUnbinder
:
:
Append
(
c
)
;
}
delete
gNodesToUnbind
;
gNodesToUnbind
=
nullptr
;
}
}
static
bool
ShouldClearPurple
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
if
(
aContent
-
>
IsPurple
(
)
)
{
return
true
;
}
JSObject
*
o
=
GetJSObjectChild
(
aContent
)
;
if
(
o
&
&
JS
:
:
ObjectIsMarkedGray
(
o
)
)
{
return
true
;
}
if
(
aContent
-
>
HasListenerManager
(
)
)
{
return
true
;
}
return
aContent
-
>
HasProperties
(
)
;
}
bool
NodeHasActiveFrame
(
Document
*
aCurrentDoc
nsINode
*
aNode
)
{
return
aCurrentDoc
-
>
GetPresShell
(
)
&
&
aNode
-
>
IsElement
(
)
&
&
aNode
-
>
AsElement
(
)
-
>
GetPrimaryFrame
(
)
;
}
bool
FragmentOrElement
:
:
CanSkip
(
nsINode
*
aNode
bool
aRemovingAllowed
)
{
if
(
nsCCUncollectableMarker
:
:
sGeneration
=
=
0
)
{
return
false
;
}
bool
unoptimizable
=
aNode
-
>
UnoptimizableCCNode
(
)
;
Document
*
currentDoc
=
aNode
-
>
GetComposedDoc
(
)
;
if
(
currentDoc
&
&
IsCertainlyAliveNode
(
aNode
currentDoc
)
&
&
(
!
unoptimizable
|
|
NodeHasActiveFrame
(
currentDoc
aNode
)
)
)
{
MarkNodeChildren
(
aNode
)
;
return
true
;
}
if
(
unoptimizable
)
{
return
false
;
}
nsINode
*
root
=
currentDoc
?
static_cast
<
nsINode
*
>
(
currentDoc
)
:
FindOptimizableSubtreeRoot
(
aNode
)
;
if
(
!
root
)
{
return
false
;
}
if
(
root
-
>
IsPurpleRoot
(
)
)
{
return
false
;
}
AutoTArray
<
nsIContent
*
1020
>
nodesToClear
;
bool
foundLiveWrapper
=
root
-
>
HasKnownLiveWrapper
(
)
;
bool
domOnlyCycle
=
false
;
if
(
root
!
=
currentDoc
)
{
currentDoc
=
nullptr
;
if
(
!
foundLiveWrapper
)
{
domOnlyCycle
=
static_cast
<
nsIContent
*
>
(
root
)
-
>
OwnedOnlyByTheDOMTree
(
)
;
}
if
(
ShouldClearPurple
(
static_cast
<
nsIContent
*
>
(
root
)
)
)
{
nodesToClear
.
AppendElement
(
static_cast
<
nsIContent
*
>
(
root
)
)
;
}
}
for
(
nsIContent
*
node
=
root
-
>
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
root
)
)
{
foundLiveWrapper
=
foundLiveWrapper
|
|
node
-
>
HasKnownLiveWrapper
(
)
;
if
(
foundLiveWrapper
)
{
domOnlyCycle
=
false
;
if
(
currentDoc
)
{
break
;
}
if
(
node
-
>
IsPurple
(
)
&
&
(
node
!
=
aNode
|
|
aRemovingAllowed
)
)
{
node
-
>
RemovePurple
(
)
;
}
MarkNodeChildren
(
node
)
;
}
else
{
domOnlyCycle
=
domOnlyCycle
&
&
node
-
>
OwnedOnlyByTheDOMTree
(
)
;
if
(
ShouldClearPurple
(
node
)
)
{
nodesToClear
.
AppendElement
(
node
)
;
}
}
}
if
(
!
currentDoc
|
|
!
foundLiveWrapper
)
{
root
-
>
SetIsPurpleRoot
(
true
)
;
if
(
domOnlyCycle
)
{
if
(
!
gNodesToUnbind
)
{
gNodesToUnbind
=
new
AutoTArray
<
nsIContent
*
1020
>
(
)
;
}
gNodesToUnbind
-
>
AppendElement
(
static_cast
<
nsIContent
*
>
(
root
)
)
;
for
(
uint32_t
i
=
0
;
i
<
nodesToClear
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
n
=
nodesToClear
[
i
]
;
if
(
(
n
!
=
aNode
|
|
aRemovingAllowed
)
&
&
n
-
>
IsPurple
(
)
)
{
n
-
>
RemovePurple
(
)
;
}
}
return
true
;
}
else
{
if
(
!
gPurpleRoots
)
{
gPurpleRoots
=
new
AutoTArray
<
nsINode
*
1020
>
(
)
;
}
gPurpleRoots
-
>
AppendElement
(
root
)
;
}
}
if
(
!
foundLiveWrapper
)
{
return
false
;
}
if
(
currentDoc
)
{
currentDoc
-
>
MarkUncollectableForCCGeneration
(
nsCCUncollectableMarker
:
:
sGeneration
)
;
MarkNodeChildren
(
currentDoc
)
;
}
for
(
uint32_t
i
=
0
;
i
<
nodesToClear
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
n
=
nodesToClear
[
i
]
;
MarkNodeChildren
(
n
)
;
if
(
(
n
!
=
aNode
|
|
aRemovingAllowed
)
&
&
n
-
>
IsPurple
(
)
)
{
n
-
>
RemovePurple
(
)
;
}
}
return
true
;
}
bool
FragmentOrElement
:
:
CanSkipThis
(
nsINode
*
aNode
)
{
if
(
nsCCUncollectableMarker
:
:
sGeneration
=
=
0
)
{
return
false
;
}
if
(
aNode
-
>
HasKnownLiveWrapper
(
)
)
{
return
true
;
}
Document
*
c
=
aNode
-
>
GetComposedDoc
(
)
;
return
(
(
c
&
&
IsCertainlyAliveNode
(
aNode
c
)
)
|
|
aNode
-
>
InCCBlackTree
(
)
)
&
&
!
NeedsScriptTraverse
(
aNode
)
;
}
void
FragmentOrElement
:
:
InitCCCallbacks
(
)
{
nsCycleCollector_setForgetSkippableCallback
(
ClearCycleCollectorCleanupData
)
;
nsCycleCollector_setBeforeUnlinkCallback
(
ClearBlackMarkedNodes
)
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
FragmentOrElement
)
return
FragmentOrElement
:
:
CanSkip
(
tmp
aRemovingAllowed
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
FragmentOrElement
)
return
FragmentOrElement
:
:
CanSkipInCC
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
FragmentOrElement
)
return
FragmentOrElement
:
:
CanSkipThis
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL
(
FragmentOrElement
)
if
(
MOZ_UNLIKELY
(
cb
.
WantDebugInfo
(
)
)
)
{
char
name
[
512
]
;
uint32_t
nsid
=
tmp
-
>
GetNameSpaceID
(
)
;
nsAtomCString
localName
(
tmp
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
nsAutoCString
uri
;
if
(
tmp
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
)
{
uri
=
tmp
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
}
nsAutoString
id
;
nsAtom
*
idAtom
=
tmp
-
>
GetID
(
)
;
if
(
idAtom
)
{
id
.
AppendLiteral
(
"
id
=
'
"
)
;
id
.
Append
(
nsDependentAtomString
(
idAtom
)
)
;
id
.
Append
(
'
\
'
'
)
;
}
nsAutoString
classes
;
const
nsAttrValue
*
classAttrValue
=
tmp
-
>
IsElement
(
)
?
tmp
-
>
AsElement
(
)
-
>
GetClasses
(
)
:
nullptr
;
if
(
classAttrValue
)
{
classes
.
AppendLiteral
(
"
class
=
'
"
)
;
nsAutoString
classString
;
classAttrValue
-
>
ToString
(
classString
)
;
classString
.
ReplaceChar
(
char16_t
(
'
\
n
'
)
char16_t
(
'
'
)
)
;
classes
.
Append
(
classString
)
;
classes
.
Append
(
'
\
'
'
)
;
}
nsAutoCString
orphan
;
if
(
!
tmp
-
>
IsInComposedDoc
(
)
)
{
orphan
.
AppendLiteral
(
"
(
orphan
)
"
)
;
}
const
char
*
nsuri
=
nsNameSpaceManager
:
:
GetNameSpaceDisplayName
(
nsid
)
;
SprintfLiteral
(
name
"
FragmentOrElement
%
s
%
s
%
s
%
s
%
s
%
s
"
nsuri
localName
.
get
(
)
NS_ConvertUTF16toUTF8
(
id
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
classes
)
.
get
(
)
orphan
.
get
(
)
uri
.
get
(
)
)
;
cb
.
DescribeRefCountedNode
(
tmp
-
>
mRefCnt
.
get
(
)
name
)
;
}
else
{
NS_IMPL_CYCLE_COLLECTION_DESCRIBE
(
FragmentOrElement
tmp
-
>
mRefCnt
.
get
(
)
)
}
if
(
!
nsIContent
:
:
Traverse
(
tmp
cb
)
)
{
return
NS_SUCCESS_INTERRUPTED_TRAVERSE
;
}
if
(
tmp
-
>
IsElement
(
)
)
{
Element
*
element
=
tmp
-
>
AsElement
(
)
;
uint32_t
i
;
uint32_t
attrs
=
element
-
>
GetAttrCount
(
)
;
for
(
i
=
0
;
i
<
attrs
;
i
+
+
)
{
const
nsAttrName
*
name
=
element
-
>
GetUnsafeAttrNameAt
(
i
)
;
if
(
!
name
-
>
IsAtom
(
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mAttrs
[
i
]
-
>
NodeInfo
(
)
"
)
;
cb
.
NoteNativeChild
(
name
-
>
NodeInfo
(
)
NS_CYCLE_COLLECTION_PARTICIPANT
(
NodeInfo
)
)
;
}
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_INTERFACE_MAP_BEGIN
(
FragmentOrElement
)
NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION
(
FragmentOrElement
)
NS_INTERFACE_MAP_END_INHERITING
(
nsIContent
)
const
nsTextFragment
*
FragmentOrElement
:
:
GetText
(
)
{
return
nullptr
;
}
uint32_t
FragmentOrElement
:
:
TextLength
(
)
const
{
MOZ_ASSERT_UNREACHABLE
(
"
called
FragmentOrElement
:
:
TextLength
"
)
;
return
0
;
}
bool
FragmentOrElement
:
:
TextIsOnlyWhitespace
(
)
{
return
false
;
}
bool
FragmentOrElement
:
:
ThreadSafeTextIsOnlyWhitespace
(
)
const
{
return
false
;
}
static
inline
bool
IsVoidTag
(
nsAtom
*
aTag
)
{
static
const
nsAtom
*
voidElements
[
]
=
{
nsGkAtoms
:
:
area
nsGkAtoms
:
:
base
nsGkAtoms
:
:
basefont
nsGkAtoms
:
:
bgsound
nsGkAtoms
:
:
br
nsGkAtoms
:
:
col
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
frame
nsGkAtoms
:
:
hr
nsGkAtoms
:
:
img
nsGkAtoms
:
:
input
nsGkAtoms
:
:
keygen
nsGkAtoms
:
:
link
nsGkAtoms
:
:
meta
nsGkAtoms
:
:
param
nsGkAtoms
:
:
source
nsGkAtoms
:
:
track
nsGkAtoms
:
:
wbr
}
;
static
mozilla
:
:
BitBloomFilter
<
12
nsAtom
>
sFilter
;
static
bool
sInitialized
=
false
;
if
(
!
sInitialized
)
{
sInitialized
=
true
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
voidElements
)
;
+
+
i
)
{
sFilter
.
add
(
voidElements
[
i
]
)
;
}
}
if
(
sFilter
.
mightContain
(
aTag
)
)
{
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
voidElements
)
;
+
+
i
)
{
if
(
aTag
=
=
voidElements
[
i
]
)
{
return
true
;
}
}
}
return
false
;
}
bool
FragmentOrElement
:
:
IsHTMLVoid
(
nsAtom
*
aLocalName
)
{
return
aLocalName
&
&
IsVoidTag
(
aLocalName
)
;
}
void
FragmentOrElement
:
:
GetMarkup
(
bool
aIncludeSelf
nsAString
&
aMarkup
)
{
aMarkup
.
Truncate
(
)
;
Document
*
doc
=
OwnerDoc
(
)
;
if
(
IsInHTMLDocument
(
)
)
{
nsContentUtils
:
:
SerializeNodeToMarkup
(
this
!
aIncludeSelf
aMarkup
false
{
}
)
;
return
;
}
nsAutoString
contentType
;
doc
-
>
GetContentType
(
contentType
)
;
bool
tryToCacheEncoder
=
!
aIncludeSelf
;
nsCOMPtr
<
nsIDocumentEncoder
>
docEncoder
=
doc
-
>
GetCachedEncoder
(
)
;
if
(
!
docEncoder
)
{
docEncoder
=
do_createDocumentEncoder
(
PromiseFlatCString
(
NS_ConvertUTF16toUTF8
(
contentType
)
)
.
get
(
)
)
;
}
if
(
!
docEncoder
)
{
contentType
.
AssignLiteral
(
"
application
/
xml
"
)
;
docEncoder
=
do_createDocumentEncoder
(
"
application
/
xml
"
)
;
tryToCacheEncoder
=
false
;
}
NS_ENSURE_TRUE_VOID
(
docEncoder
)
;
uint32_t
flags
=
nsIDocumentEncoder
:
:
OutputEncodeBasicEntities
|
nsIDocumentEncoder
:
:
OutputLFLineBreak
|
nsIDocumentEncoder
:
:
OutputRaw
|
nsIDocumentEncoder
:
:
OutputIgnoreMozDirty
;
if
(
IsEditable
(
)
)
{
nsCOMPtr
<
Element
>
elem
=
do_QueryInterface
(
this
)
;
TextEditor
*
textEditor
=
elem
?
elem
-
>
GetTextEditorInternal
(
)
:
nullptr
;
if
(
textEditor
&
&
textEditor
-
>
OutputsMozDirty
(
)
)
{
flags
&
=
~
nsIDocumentEncoder
:
:
OutputIgnoreMozDirty
;
}
}
DebugOnly
<
nsresult
>
rv
=
docEncoder
-
>
NativeInit
(
doc
contentType
flags
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
aIncludeSelf
)
{
docEncoder
-
>
SetNode
(
this
)
;
}
else
{
docEncoder
-
>
SetContainerNode
(
this
)
;
}
rv
=
docEncoder
-
>
EncodeToString
(
aMarkup
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
tryToCacheEncoder
)
{
doc
-
>
SetCachedEncoder
(
docEncoder
.
forget
(
)
)
;
}
}
static
bool
ContainsMarkup
(
const
nsAString
&
aStr
)
{
const
char16_t
*
start
=
aStr
.
BeginReading
(
)
;
const
char16_t
*
end
=
aStr
.
EndReading
(
)
;
while
(
start
!
=
end
)
{
char16_t
c
=
*
start
;
if
(
c
=
=
char16_t
(
'
<
'
)
|
|
c
=
=
char16_t
(
'
&
'
)
|
|
c
=
=
char16_t
(
'
\
r
'
)
|
|
c
=
=
char16_t
(
'
\
0
'
)
)
{
return
true
;
}
+
+
start
;
}
return
false
;
}
void
FragmentOrElement
:
:
SetInnerHTMLInternal
(
const
nsAString
&
aInnerHTML
ErrorResult
&
aError
)
{
FragmentOrElement
*
target
=
this
;
if
(
target
-
>
IsTemplateElement
(
)
)
{
DocumentFragment
*
frag
=
static_cast
<
HTMLTemplateElement
*
>
(
target
)
-
>
Content
(
)
;
MOZ_ASSERT
(
frag
)
;
target
=
frag
;
}
if
(
!
target
-
>
HasWeirdParserInsertionMode
(
)
&
&
aInnerHTML
.
Length
(
)
<
100
&
&
!
ContainsMarkup
(
aInnerHTML
)
)
{
aError
=
nsContentUtils
:
:
SetNodeTextContent
(
target
aInnerHTML
false
)
;
return
;
}
Document
*
const
doc
=
target
-
>
OwnerDoc
(
)
;
mozAutoSubtreeModified
subtree
(
doc
nullptr
)
;
target
-
>
FireNodeRemovedForChildren
(
)
;
mozAutoDocUpdate
updateBatch
(
doc
true
)
;
nsAutoMutationBatch
mb
(
target
true
false
)
;
while
(
target
-
>
HasChildren
(
)
)
{
target
-
>
RemoveChildNode
(
target
-
>
GetFirstChild
(
)
true
)
;
}
mb
.
RemovalDone
(
)
;
nsAutoScriptLoaderDisabler
sld
(
doc
)
;
FragmentOrElement
*
parseContext
=
this
;
if
(
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
this
)
)
{
parseContext
=
shadowRoot
-
>
GetHost
(
)
;
}
if
(
doc
-
>
IsHTMLDocument
(
)
)
{
doc
-
>
SuspendDOMNotifications
(
)
;
nsAtom
*
contextLocalName
=
parseContext
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
int32_t
contextNameSpaceID
=
parseContext
-
>
GetNameSpaceID
(
)
;
int32_t
oldChildCount
=
target
-
>
GetChildCount
(
)
;
aError
=
nsContentUtils
:
:
ParseFragmentHTML
(
aInnerHTML
target
contextLocalName
contextNameSpaceID
doc
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
true
)
;
doc
-
>
ResumeDOMNotifications
(
)
;
if
(
target
-
>
GetFirstChild
(
)
)
{
MutationObservers
:
:
NotifyContentAppended
(
target
target
-
>
GetFirstChild
(
)
)
;
}
mb
.
NodesAdded
(
)
;
nsContentUtils
:
:
FireMutationEventsForDirectParsing
(
doc
target
oldChildCount
)
;
}
else
{
RefPtr
<
DocumentFragment
>
df
=
nsContentUtils
:
:
CreateContextualFragment
(
parseContext
aInnerHTML
true
aError
)
;
if
(
!
aError
.
Failed
(
)
)
{
nsAutoScriptBlockerSuppressNodeRemoved
scriptBlocker
;
target
-
>
AppendChild
(
*
df
aError
)
;
mb
.
NodesAdded
(
)
;
}
}
}
void
FragmentOrElement
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
nsIContent
:
:
AddSizeOfExcludingThis
(
aSizes
aNodeSize
)
;
nsDOMSlots
*
slots
=
GetExistingDOMSlots
(
)
;
if
(
slots
)
{
*
aNodeSize
+
=
slots
-
>
SizeOfIncludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
}
}
