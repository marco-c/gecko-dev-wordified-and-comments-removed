#
ifndef
mozilla_dom_EventSourceEventService_h
#
define
mozilla_dom_EventSourceEventService_h
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
nsIEventSourceEventService
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
:
:
dom
{
class
EventSourceEventService
final
:
public
nsIEventSourceEventService
public
nsIObserver
{
friend
class
EventSourceBaseRunnable
;
public
:
NS_DECL_THREADSAFE_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIEVENTSOURCEEVENTSERVICE
static
already_AddRefed
<
EventSourceEventService
>
GetOrCreate
(
)
;
void
EventSourceConnectionOpened
(
uint64_t
aHttpChannelId
uint64_t
aInnerWindowID
)
;
void
EventSourceConnectionClosed
(
uint64_t
aHttpChannelId
uint64_t
aInnerWindowID
)
;
void
EventReceived
(
uint64_t
aHttpChannelId
uint64_t
aInnerWindowID
const
nsAString
&
aEventName
const
nsAString
&
aLastEventID
const
nsAString
&
aData
uint32_t
aRetry
DOMHighResTimeStamp
aTimeStamp
)
;
private
:
EventSourceEventService
(
)
;
~
EventSourceEventService
(
)
;
bool
HasListeners
(
)
const
;
void
Shutdown
(
)
;
using
EventSourceListeners
=
nsTArray
<
nsCOMPtr
<
nsIEventSourceEventListener
>
>
;
struct
WindowListener
{
EventSourceListeners
mListeners
;
}
;
void
GetListeners
(
uint64_t
aInnerWindowID
EventSourceListeners
&
aListeners
)
const
;
nsClassHashtable
<
nsUint64HashKey
WindowListener
>
mWindows
;
Atomic
<
uint64_t
>
mCountListeners
;
}
;
}
inline
nsISupports
*
ToSupports
(
mozilla
:
:
dom
:
:
EventSourceEventService
*
p
)
{
return
NS_ISUPPORTS_CAST
(
nsIEventSourceEventService
*
p
)
;
}
#
endif
