#
include
"
nsFrameLoader
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIPrintSettingsService
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWebProgress
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsDocShellLoadState
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIBrowser
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsIMozBrowserFrame
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsMappedAttributes
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsBaseWidget
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
ReferrerInfo
.
h
"
#
include
"
nsIOpenWindowInfo
.
h
"
#
include
"
nsISHistory
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
InProcessBrowserChildMessageManager
.
h
"
#
include
"
Layers
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
ContentParent
.
h
"
#
include
"
BrowserParent
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ExpandedPrincipal
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
ProcessPriorityManager
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
ChromeMessageSender
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
FrameCrashedEvent
.
h
"
#
include
"
mozilla
/
dom
/
FrameLoaderBinding
.
h
"
#
include
"
mozilla
/
dom
/
MozFrameLoaderOwnerBinding
.
h
"
#
include
"
mozilla
/
dom
/
PBrowser
.
h
"
#
include
"
mozilla
/
dom
/
SessionHistoryEntry
.
h
"
#
include
"
mozilla
/
dom
/
SessionStoreChangeListener
.
h
"
#
include
"
mozilla
/
dom
/
SessionStoreListener
.
h
"
#
include
"
mozilla
/
dom
/
SessionStoreUtils
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalParent
.
h
"
#
include
"
mozilla
/
dom
/
XULFrameElement
.
h
"
#
include
"
mozilla
/
gfx
/
CrossProcessPaint
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
nsGenericHTMLFrameElement
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
CustomEvent
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StructuredCloneData
.
h
"
#
include
"
mozilla
/
WebBrowserPersistLocalDocument
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ChildSHistory
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentProcessManager
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowserHost
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeHost
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
SessionStorageManager
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
dom
/
PBackgroundSessionStorageCache
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundUtils
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
ContentPrincipal
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPopupManager
.
h
"
#
endif
#
ifdef
NS_PRINTING
#
include
"
mozilla
/
embedding
/
printingui
/
PrintingParent
.
h
"
#
include
"
nsIWebBrowserPrint
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
hal
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
dom
:
:
ipc
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
layout
;
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
using
PrintPreviewResolver
=
std
:
:
function
<
void
(
const
PrintPreviewResultInfo
&
)
>
;
#
define
MAX_DEPTH_CONTENT_FRAMES
10
NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE
(
nsFrameLoader
mPendingBrowsingContext
mMessageManager
mChildMessageManager
mRemoteBrowser
mSessionStoreChangeListener
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsFrameLoader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsFrameLoader
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsFrameLoader
)
NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
NS_INTERFACE_MAP_ENTRY_CONCRETE
(
nsFrameLoader
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
nsFrameLoader
:
:
nsFrameLoader
(
Element
*
aOwner
BrowsingContext
*
aBrowsingContext
bool
aIsRemoteFrame
bool
aNetworkCreated
)
:
mPendingBrowsingContext
(
aBrowsingContext
)
mOwnerContent
(
aOwner
)
mDetachedSubdocFrame
(
nullptr
)
mPendingSwitchID
(
0
)
mChildID
(
0
)
mRemoteType
(
NOT_REMOTE_TYPE
)
mDepthTooGreat
(
false
)
mIsTopLevelContent
(
false
)
mDestroyCalled
(
false
)
mNeedsAsyncDestroy
(
false
)
mInSwap
(
false
)
mInShow
(
false
)
mHideCalled
(
false
)
mNetworkCreated
(
aNetworkCreated
)
mLoadingOriginalSrc
(
false
)
mRemoteBrowserShown
(
false
)
mIsRemoteFrame
(
aIsRemoteFrame
)
mWillChangeProcess
(
false
)
mObservingOwnerContent
(
false
)
mTabProcessCrashFired
(
false
)
mNotifyingCrash
(
false
)
{
nsCOMPtr
<
nsFrameLoaderOwner
>
owner
=
do_QueryInterface
(
aOwner
)
;
owner
-
>
AttachFrameLoader
(
this
)
;
}
nsFrameLoader
:
:
~
nsFrameLoader
(
)
{
if
(
mMessageManager
)
{
mMessageManager
-
>
Disconnect
(
)
;
}
MOZ_ASSERT
(
!
mOwnerContent
)
;
MOZ_RELEASE_ASSERT
(
mDestroyCalled
)
;
}
static
nsAtom
*
TypeAttrName
(
Element
*
aOwnerContent
)
{
return
aOwnerContent
-
>
IsXULElement
(
)
?
nsGkAtoms
:
:
type
:
nsGkAtoms
:
:
mozframetype
;
}
static
void
GetFrameName
(
Element
*
aOwnerContent
nsAString
&
aFrameName
)
{
int32_t
namespaceID
=
aOwnerContent
-
>
GetNameSpaceID
(
)
;
if
(
namespaceID
=
=
kNameSpaceID_XHTML
&
&
!
aOwnerContent
-
>
IsInHTMLDocument
(
)
)
{
aOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aFrameName
)
;
}
else
{
aOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
aFrameName
)
;
if
(
aFrameName
.
IsEmpty
(
)
&
&
namespaceID
=
=
kNameSpaceID_XUL
)
{
aOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aFrameName
)
;
}
}
}
static
bool
IsTopContent
(
BrowsingContext
*
aParent
Element
*
aOwner
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIMozBrowserFrame
>
mozbrowser
=
aOwner
-
>
GetAsMozBrowserFrame
(
)
;
if
(
mozbrowser
&
&
mozbrowser
-
>
GetReallyIsBrowser
(
)
)
{
return
true
;
}
if
(
aParent
-
>
IsContent
(
)
)
{
return
aOwner
-
>
IsXULElement
(
)
&
&
aOwner
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
return
aOwner
-
>
AttrValueIs
(
kNameSpaceID_None
TypeAttrName
(
aOwner
)
nsGkAtoms
:
:
content
eIgnoreCase
)
;
}
static
already_AddRefed
<
BrowsingContext
>
CreateBrowsingContext
(
Element
*
aOwner
nsIOpenWindowInfo
*
aOpenWindowInfo
BrowsingContextGroup
*
aSpecificGroup
bool
aNetworkCreated
=
false
)
{
MOZ_ASSERT
(
!
aOpenWindowInfo
|
|
!
aSpecificGroup
"
Only
one
of
SpecificGroup
and
OpenWindowInfo
may
be
provided
!
"
)
;
if
(
aOpenWindowInfo
&
&
aOpenWindowInfo
-
>
GetNextRemoteBrowser
(
)
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
do_AddRef
(
aOpenWindowInfo
-
>
GetNextRemoteBrowser
(
)
-
>
GetBrowsingContext
(
)
)
;
}
RefPtr
<
BrowsingContext
>
opener
;
if
(
aOpenWindowInfo
&
&
!
aOpenWindowInfo
-
>
GetForceNoOpener
(
)
)
{
opener
=
aOpenWindowInfo
-
>
GetParent
(
)
;
if
(
opener
)
{
MOZ_ASSERT
(
opener
-
>
IsInProcess
(
)
)
;
if
(
opener
-
>
IsDiscarded
(
)
)
{
NS_WARNING
(
"
Opener
was
closed
from
a
nested
event
loop
in
the
parent
process
.
"
"
Please
fix
this
.
"
)
;
opener
=
nullptr
;
}
}
}
RefPtr
<
nsGlobalWindowInner
>
parentInner
=
nsGlobalWindowInner
:
:
Cast
(
aOwner
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
if
(
NS_WARN_IF
(
!
parentInner
)
|
|
parentInner
-
>
IsDying
(
)
)
{
return
nullptr
;
}
BrowsingContext
*
parentBC
=
parentInner
-
>
GetBrowsingContext
(
)
;
if
(
NS_WARN_IF
(
!
parentBC
)
|
|
parentBC
-
>
IsDiscarded
(
)
)
{
return
nullptr
;
}
nsAutoString
frameName
;
GetFrameName
(
aOwner
frameName
)
;
if
(
IsTopContent
(
parentBC
aOwner
)
)
{
return
BrowsingContext
:
:
CreateDetached
(
nullptr
opener
aSpecificGroup
frameName
BrowsingContext
:
:
Type
:
:
Content
)
;
}
MOZ_ASSERT
(
!
aOpenWindowInfo
"
Can
'
t
have
openWindowInfo
for
non
-
toplevel
context
"
)
;
MOZ_ASSERT
(
!
aSpecificGroup
"
Can
'
t
force
BrowsingContextGroup
for
non
-
toplevel
context
"
)
;
return
BrowsingContext
:
:
CreateDetached
(
parentInner
nullptr
nullptr
frameName
parentBC
-
>
GetType
(
)
!
aNetworkCreated
)
;
}
static
bool
InitialLoadIsRemote
(
Element
*
aOwner
)
{
if
(
PR_GetEnv
(
"
MOZ_DISABLE_OOP_TABS
"
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
ipc
.
tabs
.
disabled
"
false
)
)
{
return
false
;
}
if
(
XRE_IsContentProcess
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIMozBrowserFrame
>
browserFrame
=
do_QueryInterface
(
aOwner
)
;
bool
isMozBrowserFrame
=
browserFrame
&
&
browserFrame
-
>
GetReallyIsBrowser
(
)
;
if
(
isMozBrowserFrame
&
&
!
aOwner
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
)
)
{
return
Preferences
:
:
GetBool
(
"
dom
.
ipc
.
browser_frames
.
oop_by_default
"
false
)
;
}
return
(
isMozBrowserFrame
|
|
aOwner
-
>
GetNameSpaceID
(
)
=
=
kNameSpaceID_XUL
)
&
&
aOwner
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
static
already_AddRefed
<
BrowsingContextGroup
>
InitialBrowsingContextGroup
(
Element
*
aOwner
)
{
nsAutoString
attrString
;
if
(
aOwner
-
>
GetNameSpaceID
(
)
!
=
kNameSpaceID_XUL
|
|
!
aOwner
-
>
GetAttr
(
nsGkAtoms
:
:
initialBrowsingContextGroupId
attrString
)
)
{
return
nullptr
;
}
nsresult
rv
=
NS_OK
;
int64_t
signedGroupId
=
attrString
.
ToInteger64
(
&
rv
10
)
;
if
(
NS_FAILED
(
rv
)
|
|
signedGroupId
<
=
0
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
we
intended
to
have
a
particular
id
but
failed
to
parse
it
!
"
)
;
return
nullptr
;
}
return
BrowsingContextGroup
:
:
GetOrCreate
(
uint64_t
(
signedGroupId
)
)
;
}
already_AddRefed
<
nsFrameLoader
>
nsFrameLoader
:
:
Create
(
Element
*
aOwner
bool
aNetworkCreated
nsIOpenWindowInfo
*
aOpenWindowInfo
)
{
NS_ENSURE_TRUE
(
aOwner
nullptr
)
;
Document
*
doc
=
aOwner
-
>
OwnerDoc
(
)
;
NS_ENSURE_TRUE
(
!
doc
-
>
IsResourceDoc
(
)
&
&
(
(
!
doc
-
>
IsLoadedAsData
(
)
&
&
aOwner
-
>
IsInComposedDoc
(
)
)
|
|
doc
-
>
IsStaticDocument
(
)
)
nullptr
)
;
RefPtr
<
BrowsingContextGroup
>
group
=
InitialBrowsingContextGroup
(
aOwner
)
;
RefPtr
<
BrowsingContext
>
context
=
CreateBrowsingContext
(
aOwner
aOpenWindowInfo
group
aNetworkCreated
)
;
NS_ENSURE_TRUE
(
context
nullptr
)
;
if
(
XRE_IsParentProcess
(
)
&
&
aOpenWindowInfo
)
{
MOZ_ASSERT
(
context
-
>
IsTopContent
(
)
)
;
if
(
RefPtr
<
BrowsingContext
>
crossGroupOpener
=
aOpenWindowInfo
-
>
GetParent
(
)
)
{
context
-
>
Canonical
(
)
-
>
SetCrossGroupOpenerId
(
crossGroupOpener
-
>
Id
(
)
)
;
}
}
bool
isRemoteFrame
=
InitialLoadIsRemote
(
aOwner
)
;
RefPtr
<
nsFrameLoader
>
fl
=
new
nsFrameLoader
(
aOwner
context
isRemoteFrame
aNetworkCreated
)
;
fl
-
>
mOpenWindowInfo
=
aOpenWindowInfo
;
if
(
isRemoteFrame
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsAutoString
remoteType
;
if
(
aOwner
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
RemoteType
remoteType
)
&
&
!
remoteType
.
IsEmpty
(
)
)
{
CopyUTF16toUTF8
(
remoteType
fl
-
>
mRemoteType
)
;
}
else
{
fl
-
>
mRemoteType
=
DEFAULT_REMOTE_TYPE
;
}
}
return
fl
.
forget
(
)
;
}
already_AddRefed
<
nsFrameLoader
>
nsFrameLoader
:
:
Recreate
(
mozilla
:
:
dom
:
:
Element
*
aOwner
BrowsingContext
*
aContext
BrowsingContextGroup
*
aSpecificGroup
const
RemotenessChangeOptions
&
aRemotenessOptions
bool
aIsRemote
bool
aNetworkCreated
bool
aPreserveContext
)
{
NS_ENSURE_TRUE
(
aOwner
nullptr
)
;
#
ifdef
DEBUG
Document
*
doc
=
aOwner
-
>
OwnerDoc
(
)
;
MOZ_ASSERT
(
!
doc
-
>
IsResourceDoc
(
)
)
;
MOZ_ASSERT
(
(
!
doc
-
>
IsLoadedAsData
(
)
&
&
aOwner
-
>
IsInComposedDoc
(
)
)
|
|
doc
-
>
IsStaticDocument
(
)
)
;
#
endif
RefPtr
<
BrowsingContext
>
context
=
aContext
;
if
(
!
context
|
|
!
aPreserveContext
)
{
context
=
CreateBrowsingContext
(
aOwner
nullptr
aSpecificGroup
)
;
if
(
aContext
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
"
Recreating
browing
contexts
only
supported
in
the
parent
process
"
)
;
aContext
-
>
Canonical
(
)
-
>
ReplacedBy
(
context
-
>
Canonical
(
)
aRemotenessOptions
)
;
}
}
NS_ENSURE_TRUE
(
context
nullptr
)
;
RefPtr
<
nsFrameLoader
>
fl
=
new
nsFrameLoader
(
aOwner
context
aIsRemote
aNetworkCreated
)
;
return
fl
.
forget
(
)
;
}
void
nsFrameLoader
:
:
LoadFrame
(
bool
aOriginalSrc
)
{
if
(
NS_WARN_IF
(
!
mOwnerContent
)
)
{
return
;
}
nsAutoString
src
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
bool
isSrcdoc
=
mOwnerContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
mOwnerContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
srcdoc
)
;
if
(
isSrcdoc
)
{
src
.
AssignLiteral
(
"
about
:
srcdoc
"
)
;
principal
=
mOwnerContent
-
>
NodePrincipal
(
)
;
csp
=
mOwnerContent
-
>
GetCsp
(
)
;
}
else
{
GetURL
(
src
getter_AddRefs
(
principal
)
getter_AddRefs
(
csp
)
)
;
src
.
Trim
(
"
\
t
\
n
\
r
"
)
;
if
(
src
.
IsEmpty
(
)
)
{
if
(
mOwnerContent
-
>
IsXULElement
(
)
&
&
mOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
nodefaultsrc
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
;
}
src
.
AssignLiteral
(
"
about
:
blank
"
)
;
principal
=
mOwnerContent
-
>
NodePrincipal
(
)
;
csp
=
mOwnerContent
-
>
GetCsp
(
)
;
}
}
Document
*
doc
=
mOwnerContent
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsStaticDocument
(
)
)
{
return
;
}
nsIURI
*
base_uri
=
mOwnerContent
-
>
GetBaseURI
(
)
;
auto
encoding
=
doc
-
>
GetDocumentCharacterSet
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
src
encoding
base_uri
)
;
if
(
rv
=
=
NS_ERROR_MALFORMED_URI
)
{
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
u
"
about
:
blank
"
_ns
encoding
base_uri
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
LoadURI
(
uri
principal
csp
aOriginalSrc
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
FireErrorEvent
(
)
;
}
}
void
nsFrameLoader
:
:
ConfigRemoteProcess
(
const
nsACString
&
aRemoteType
ContentParent
*
aContentParent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsRemoteFrame
(
)
"
Must
be
a
remote
frame
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mRemoteBrowser
"
Must
not
have
a
browser
yet
"
)
;
MOZ_DIAGNOSTIC_ASSERT_IF
(
aContentParent
aContentParent
-
>
GetRemoteType
(
)
=
=
aRemoteType
)
;
mRemoteType
=
aRemoteType
;
mChildID
=
aContentParent
?
aContentParent
-
>
ChildID
(
)
:
0
;
}
void
nsFrameLoader
:
:
FireErrorEvent
(
)
{
if
(
!
mOwnerContent
)
{
return
;
}
RefPtr
<
AsyncEventDispatcher
>
loadBlockingAsyncDispatcher
=
new
LoadBlockingAsyncEventDispatcher
(
mOwnerContent
u
"
error
"
_ns
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
loadBlockingAsyncDispatcher
-
>
PostDOMEvent
(
)
;
}
nsresult
nsFrameLoader
:
:
LoadURI
(
nsIURI
*
aURI
nsIPrincipal
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
aCsp
bool
aOriginalSrc
)
{
if
(
!
aURI
)
return
NS_ERROR_INVALID_POINTER
;
NS_ENSURE_STATE
(
!
mDestroyCalled
&
&
mOwnerContent
)
;
MOZ_ASSERT
(
aTriggeringPrincipal
"
Must
have
an
explicit
triggeringPrincipal
to
nsFrameLoader
:
:
LoadURI
.
"
)
;
mLoadingOriginalSrc
=
aOriginalSrc
;
nsCOMPtr
<
Document
>
doc
=
mOwnerContent
-
>
OwnerDoc
(
)
;
nsresult
rv
;
rv
=
CheckURILoad
(
aURI
aTriggeringPrincipal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mURIToLoad
=
aURI
;
mTriggeringPrincipal
=
aTriggeringPrincipal
;
mCsp
=
aCsp
;
rv
=
doc
-
>
InitializeFrameLoader
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
mURIToLoad
=
nullptr
;
mTriggeringPrincipal
=
nullptr
;
mCsp
=
nullptr
;
}
return
rv
;
}
void
nsFrameLoader
:
:
ResumeLoad
(
uint64_t
aPendingSwitchID
)
{
Document
*
doc
=
mOwnerContent
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsStaticDocument
(
)
)
{
return
;
}
if
(
NS_WARN_IF
(
mDestroyCalled
|
|
!
mOwnerContent
)
)
{
FireErrorEvent
(
)
;
return
;
}
mLoadingOriginalSrc
=
false
;
mURIToLoad
=
nullptr
;
mPendingSwitchID
=
aPendingSwitchID
;
mTriggeringPrincipal
=
mOwnerContent
-
>
NodePrincipal
(
)
;
mCsp
=
mOwnerContent
-
>
GetCsp
(
)
;
nsresult
rv
=
doc
-
>
InitializeFrameLoader
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPendingSwitchID
=
0
;
mTriggeringPrincipal
=
nullptr
;
mCsp
=
nullptr
;
FireErrorEvent
(
)
;
}
}
nsresult
nsFrameLoader
:
:
ReallyStartLoading
(
)
{
nsresult
rv
=
ReallyStartLoadingInternal
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
FireErrorEvent
(
)
;
}
return
rv
;
}
nsresult
nsFrameLoader
:
:
ReallyStartLoadingInternal
(
)
{
NS_ENSURE_STATE
(
(
mURIToLoad
|
|
mPendingSwitchID
)
&
&
mOwnerContent
&
&
mOwnerContent
-
>
IsInComposedDoc
(
)
)
;
AUTO_PROFILER_LABEL
(
"
nsFrameLoader
:
:
ReallyStartLoadingInternal
"
OTHER
)
;
RefPtr
<
nsDocShellLoadState
>
loadState
;
if
(
!
mPendingSwitchID
)
{
loadState
=
new
nsDocShellLoadState
(
mURIToLoad
)
;
loadState
-
>
SetOriginalFrameSrc
(
mLoadingOriginalSrc
)
;
if
(
mTriggeringPrincipal
)
{
loadState
-
>
SetTriggeringPrincipal
(
mTriggeringPrincipal
)
;
}
else
{
loadState
-
>
SetTriggeringPrincipal
(
mOwnerContent
-
>
NodePrincipal
(
)
)
;
}
if
(
mCsp
)
{
loadState
-
>
SetCsp
(
mCsp
)
;
}
else
if
(
!
mTriggeringPrincipal
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
mOwnerContent
-
>
GetCsp
(
)
;
loadState
-
>
SetCsp
(
csp
)
;
}
nsAutoString
srcdoc
;
bool
isSrcdoc
=
mOwnerContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
srcdoc
srcdoc
)
;
if
(
isSrcdoc
)
{
loadState
-
>
SetSrcdocData
(
srcdoc
)
;
loadState
-
>
SetBaseURI
(
mOwnerContent
-
>
GetBaseURI
(
)
)
;
}
auto
referrerInfo
=
MakeRefPtr
<
ReferrerInfo
>
(
*
mOwnerContent
)
;
loadState
-
>
SetReferrerInfo
(
referrerInfo
)
;
loadState
-
>
SetIsFromProcessingFrameAttributes
(
)
;
int32_t
flags
=
nsIWebNavigation
:
:
LOAD_FLAGS_NONE
;
if
(
OwnerIsMozBrowserFrame
(
)
)
{
flags
=
nsIWebNavigation
:
:
LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP
|
nsIWebNavigation
:
:
LOAD_FLAGS_DISALLOW_INHERIT_PRINCIPAL
;
}
loadState
-
>
SetLoadFlags
(
flags
)
;
loadState
-
>
SetFirstParty
(
false
)
;
}
if
(
IsRemoteFrame
(
)
)
{
if
(
!
EnsureRemoteBrowser
(
)
)
{
NS_WARNING
(
"
Couldn
'
t
create
child
process
for
iframe
.
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mPendingSwitchID
)
{
mRemoteBrowser
-
>
ResumeLoad
(
mPendingSwitchID
)
;
mPendingSwitchID
=
0
;
}
else
{
mRemoteBrowser
-
>
LoadURL
(
loadState
)
;
}
if
(
!
mRemoteBrowserShown
)
{
Unused
<
<
ShowRemoteFrame
(
ScreenIntSize
(
0
0
)
)
;
}
return
NS_OK
;
}
if
(
GetDocShell
(
)
)
{
GetDocShell
(
)
-
>
MaybeClearStorageAccessFlag
(
)
;
}
nsresult
rv
=
MaybeCreateDocShell
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
GetDocShell
(
)
"
MaybeCreateDocShell
succeeded
with
a
null
docShell
"
)
;
if
(
mPendingSwitchID
)
{
bool
tmpState
=
mNeedsAsyncDestroy
;
mNeedsAsyncDestroy
=
true
;
rv
=
GetDocShell
(
)
-
>
ResumeRedirectedLoad
(
mPendingSwitchID
-
1
)
;
mNeedsAsyncDestroy
=
tmpState
;
mPendingSwitchID
=
0
;
return
rv
;
}
rv
=
CheckURILoad
(
mURIToLoad
mTriggeringPrincipal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mLoadingOriginalSrc
=
false
;
bool
tmpState
=
mNeedsAsyncDestroy
;
mNeedsAsyncDestroy
=
true
;
rv
=
GetDocShell
(
)
-
>
LoadURI
(
loadState
false
)
;
mNeedsAsyncDestroy
=
tmpState
;
mURIToLoad
=
nullptr
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
NS_OK
;
}
nsresult
nsFrameLoader
:
:
CheckURILoad
(
nsIURI
*
aURI
nsIPrincipal
*
aTriggeringPrincipal
)
{
nsIScriptSecurityManager
*
secMan
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
nsIPrincipal
*
principal
=
(
aTriggeringPrincipal
?
aTriggeringPrincipal
:
mOwnerContent
-
>
NodePrincipal
(
)
)
;
nsresult
rv
=
secMan
-
>
CheckLoadURIWithPrincipal
(
principal
aURI
nsIScriptSecurityManager
:
:
STANDARD
mOwnerContent
-
>
OwnerDoc
(
)
-
>
InnerWindowID
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
IsRemoteFrame
(
)
)
{
return
NS_OK
;
}
return
CheckForRecursiveLoad
(
aURI
)
;
}
nsDocShell
*
nsFrameLoader
:
:
GetDocShell
(
ErrorResult
&
aRv
)
{
if
(
IsRemoteFrame
(
)
)
{
return
nullptr
;
}
if
(
mOwnerContent
)
{
nsresult
rv
=
MaybeCreateDocShell
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
MOZ_ASSERT
(
GetDocShell
(
)
"
MaybeCreateDocShell
succeeded
but
null
docShell
"
)
;
}
return
GetDocShell
(
)
;
}
static
void
SetTreeOwnerAndChromeEventHandlerOnDocshellTree
(
nsIDocShellTreeItem
*
aItem
nsIDocShellTreeOwner
*
aOwner
EventTarget
*
aHandler
)
{
MOZ_ASSERT
(
aItem
"
Must
have
item
"
)
;
aItem
-
>
SetTreeOwner
(
aOwner
)
;
int32_t
childCount
=
0
;
aItem
-
>
GetInProcessChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
aItem
-
>
GetInProcessChildAt
(
i
getter_AddRefs
(
item
)
)
;
if
(
aHandler
)
{
nsCOMPtr
<
nsIDocShell
>
shell
(
do_QueryInterface
(
item
)
)
;
shell
-
>
SetChromeEventHandler
(
aHandler
)
;
}
SetTreeOwnerAndChromeEventHandlerOnDocshellTree
(
item
aOwner
aHandler
)
;
}
}
#
if
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
static
bool
CheckDocShellType
(
mozilla
:
:
dom
:
:
Element
*
aOwnerContent
nsIDocShellTreeItem
*
aDocShell
nsAtom
*
aAtom
)
{
bool
isContent
=
aOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
aAtom
nsGkAtoms
:
:
content
eIgnoreCase
)
;
if
(
!
isContent
)
{
nsCOMPtr
<
nsIMozBrowserFrame
>
mozbrowser
=
aOwnerContent
-
>
GetAsMozBrowserFrame
(
)
;
if
(
mozbrowser
)
{
mozbrowser
-
>
GetMozbrowser
(
&
isContent
)
;
}
}
if
(
isContent
)
{
return
aDocShell
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeContent
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
aDocShell
-
>
GetInProcessParent
(
getter_AddRefs
(
parent
)
)
;
return
parent
&
&
parent
-
>
ItemType
(
)
=
=
aDocShell
-
>
ItemType
(
)
;
}
#
endif
void
nsFrameLoader
:
:
AddTreeItemToTreeOwner
(
nsIDocShellTreeItem
*
aItem
nsIDocShellTreeOwner
*
aOwner
)
{
MOZ_ASSERT
(
aItem
"
Must
have
docshell
treeitem
"
)
;
MOZ_ASSERT
(
mOwnerContent
"
Must
have
owning
content
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
CheckDocShellType
(
mOwnerContent
aItem
TypeAttrName
(
mOwnerContent
)
)
"
Correct
ItemType
should
be
set
when
creating
BrowsingContext
"
)
;
if
(
mIsTopLevelContent
)
{
bool
is_primary
=
mOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
primary
nsGkAtoms
:
:
_true
eIgnoreCase
)
;
if
(
aOwner
)
{
mOwnerContent
-
>
AddMutationObserver
(
this
)
;
mObservingOwnerContent
=
true
;
aOwner
-
>
ContentShellAdded
(
aItem
is_primary
)
;
}
}
}
static
bool
AllDescendantsOfType
(
BrowsingContext
*
aParent
BrowsingContext
:
:
Type
aType
)
{
for
(
auto
&
child
:
aParent
-
>
Children
(
)
)
{
if
(
child
-
>
GetType
(
)
!
=
aType
|
|
!
AllDescendantsOfType
(
child
aType
)
)
{
return
false
;
}
}
return
true
;
}
void
nsFrameLoader
:
:
MaybeShowFrame
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrameOfOwningContent
(
)
;
if
(
frame
)
{
nsSubDocumentFrame
*
subDocFrame
=
do_QueryFrame
(
frame
)
;
if
(
subDocFrame
)
{
subDocFrame
-
>
MaybeShowViewer
(
)
;
}
}
}
static
ScrollbarPreference
GetScrollbarPreference
(
const
Element
*
aOwner
)
{
if
(
!
aOwner
)
{
return
ScrollbarPreference
:
:
Auto
;
}
const
nsAttrValue
*
attrValue
=
aOwner
-
>
GetParsedAttr
(
nsGkAtoms
:
:
scrolling
)
;
return
nsGenericHTMLFrameElement
:
:
MapScrollingAttribute
(
attrValue
)
;
}
static
CSSIntSize
GetMarginAttributes
(
const
Element
*
aOwner
)
{
CSSIntSize
result
(
-
1
-
1
)
;
auto
*
content
=
nsGenericHTMLElement
:
:
FromNodeOrNull
(
aOwner
)
;
if
(
!
content
)
{
return
result
;
}
const
nsAttrValue
*
attr
=
content
-
>
GetParsedAttr
(
nsGkAtoms
:
:
marginwidth
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
result
.
width
=
attr
-
>
GetIntegerValue
(
)
;
}
attr
=
content
-
>
GetParsedAttr
(
nsGkAtoms
:
:
marginheight
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
result
.
height
=
attr
-
>
GetIntegerValue
(
)
;
}
return
result
;
}
bool
nsFrameLoader
:
:
Show
(
nsSubDocumentFrame
*
frame
)
{
if
(
mInShow
)
{
return
false
;
}
mInShow
=
true
;
auto
resetInShow
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
mInShow
=
false
;
}
)
;
ScreenIntSize
size
=
frame
-
>
GetSubdocumentSize
(
)
;
if
(
IsRemoteFrame
(
)
)
{
return
ShowRemoteFrame
(
size
frame
)
;
}
nsresult
rv
=
MaybeCreateDocShell
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
nsDocShell
*
ds
=
GetDocShell
(
)
;
MOZ_ASSERT
(
ds
"
MaybeCreateDocShell
succeeded
but
null
docShell
"
)
;
if
(
!
ds
)
{
return
false
;
}
ds
-
>
SetScrollbarPreference
(
GetScrollbarPreference
(
mOwnerContent
)
)
;
const
bool
marginsChanged
=
ds
-
>
UpdateFrameMargins
(
GetMarginAttributes
(
mOwnerContent
)
)
;
if
(
PresShell
*
presShell
=
ds
-
>
GetPresShell
(
)
)
{
if
(
marginsChanged
)
{
if
(
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
)
{
presShell
-
>
FrameNeedsReflow
(
rootScrollFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_IS_DIRTY
)
;
}
}
return
true
;
}
nsView
*
view
=
frame
-
>
EnsureInnerView
(
)
;
if
(
!
view
)
return
false
;
RefPtr
<
nsDocShell
>
baseWindow
=
GetDocShell
(
)
;
baseWindow
-
>
InitWindow
(
nullptr
view
-
>
GetWidget
(
)
0
0
size
.
width
size
.
height
)
;
baseWindow
-
>
SetVisibility
(
true
)
;
NS_ENSURE_TRUE
(
GetDocShell
(
)
false
)
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetDocShell
(
)
-
>
GetPresShell
(
)
)
{
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
nsHTMLDocument
*
htmlDoc
=
doc
&
&
doc
-
>
IsHTMLOrXHTML
(
)
?
doc
-
>
AsHTMLDocument
(
)
:
nullptr
;
if
(
htmlDoc
)
{
nsAutoString
designMode
;
htmlDoc
-
>
GetDesignMode
(
designMode
)
;
if
(
designMode
.
EqualsLiteral
(
"
on
"
)
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetDocShell
(
)
-
>
GetHTMLEditor
(
)
;
Unused
<
<
htmlEditor
;
htmlDoc
-
>
SetDesignMode
(
u
"
off
"
_ns
Nothing
(
)
IgnoreErrors
(
)
)
;
htmlDoc
-
>
SetDesignMode
(
u
"
on
"
_ns
Nothing
(
)
IgnoreErrors
(
)
)
;
}
else
{
bool
editable
=
false
hasEditingSession
=
false
;
GetDocShell
(
)
-
>
GetEditable
(
&
editable
)
;
GetDocShell
(
)
-
>
GetHasEditingSession
(
&
hasEditingSession
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetDocShell
(
)
-
>
GetHTMLEditor
(
)
;
if
(
editable
&
&
hasEditingSession
&
&
htmlEditor
)
{
htmlEditor
-
>
PostCreate
(
)
;
}
}
}
}
mInShow
=
false
;
if
(
mHideCalled
)
{
mHideCalled
=
false
;
Hide
(
)
;
return
false
;
}
return
true
;
}
void
nsFrameLoader
:
:
MarginsChanged
(
)
{
if
(
IsRemoteFrame
(
)
)
{
return
;
}
nsDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
if
(
!
docShell
-
>
UpdateFrameMargins
(
GetMarginAttributes
(
mOwnerContent
)
)
)
{
return
;
}
if
(
Document
*
doc
=
docShell
-
>
GetDocument
(
)
)
{
for
(
nsINode
*
cur
=
doc
;
cur
;
cur
=
cur
-
>
GetNextNode
(
)
)
{
if
(
cur
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
static_cast
<
HTMLBodyElement
*
>
(
cur
)
-
>
ClearMappedServoStyle
(
)
;
}
}
}
if
(
nsPresContext
*
presContext
=
docShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
RebuildAllStyleData
(
nsChangeHint
(
0
)
RestyleHint
:
:
RestyleSubtree
(
)
)
;
}
}
bool
nsFrameLoader
:
:
ShowRemoteFrame
(
const
ScreenIntSize
&
size
nsSubDocumentFrame
*
aFrame
)
{
AUTO_PROFILER_LABEL
(
"
nsFrameLoader
:
:
ShowRemoteFrame
"
OTHER
)
;
NS_ASSERTION
(
IsRemoteFrame
(
)
"
ShowRemote
only
makes
sense
on
remote
frames
.
"
)
;
if
(
!
EnsureRemoteBrowser
(
)
)
{
NS_ERROR
(
"
Couldn
'
t
create
child
process
.
"
)
;
return
false
;
}
if
(
!
mRemoteBrowserShown
)
{
if
(
!
mOwnerContent
|
|
!
mOwnerContent
-
>
GetComposedDoc
(
)
)
{
return
false
;
}
nsIWidget
*
widget
=
nsContentUtils
:
:
WidgetForContent
(
mOwnerContent
)
;
if
(
!
widget
|
|
static_cast
<
nsBaseWidget
*
>
(
widget
)
-
>
IsSmallPopup
(
)
)
{
return
false
;
}
if
(
BrowserHost
*
bh
=
mRemoteBrowser
-
>
AsBrowserHost
(
)
)
{
RefPtr
<
BrowsingContext
>
bc
=
bh
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
;
bc
-
>
SetIsActiveBrowserWindow
(
bc
-
>
GetIsActiveBrowserWindow
(
)
)
;
}
nsCOMPtr
<
nsISupports
>
container
=
mOwnerContent
-
>
OwnerDoc
(
)
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
container
)
;
nsCOMPtr
<
nsIWidget
>
mainWidget
;
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
nsSizeMode
sizeMode
=
mainWidget
?
mainWidget
-
>
SizeMode
(
)
:
nsSizeMode_Normal
;
OwnerShowInfo
info
(
size
GetScrollbarPreference
(
mOwnerContent
)
sizeMode
)
;
if
(
!
mRemoteBrowser
-
>
Show
(
info
)
)
{
return
false
;
}
mRemoteBrowserShown
=
true
;
if
(
!
GetBrowserBridgeChild
(
)
)
{
if
(
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
)
{
os
-
>
NotifyObservers
(
ToSupports
(
this
)
"
remote
-
browser
-
shown
"
nullptr
)
;
}
ProcessPriorityManager
:
:
RemoteBrowserFrameShown
(
this
)
;
}
}
else
{
nsIntRect
dimensions
;
NS_ENSURE_SUCCESS
(
GetWindowDimensions
(
dimensions
)
false
)
;
if
(
!
aFrame
|
|
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
mRemoteBrowser
-
>
UpdateDimensions
(
dimensions
size
)
;
}
}
return
true
;
}
void
nsFrameLoader
:
:
Hide
(
)
{
if
(
mHideCalled
)
{
return
;
}
if
(
mInShow
)
{
mHideCalled
=
true
;
return
;
}
if
(
!
GetDocShell
(
)
)
{
return
;
}
GetDocShell
(
)
-
>
MaybeClearStorageAccessFlag
(
)
;
nsCOMPtr
<
nsIContentViewer
>
contentViewer
;
GetDocShell
(
)
-
>
GetContentViewer
(
getter_AddRefs
(
contentViewer
)
)
;
if
(
contentViewer
)
contentViewer
-
>
SetSticky
(
false
)
;
RefPtr
<
nsDocShell
>
baseWin
=
GetDocShell
(
)
;
baseWin
-
>
SetVisibility
(
false
)
;
baseWin
-
>
SetParentWidget
(
nullptr
)
;
}
void
nsFrameLoader
:
:
ForceLayoutIfNecessary
(
)
{
nsIFrame
*
frame
=
GetPrimaryFrameOfOwningContent
(
)
;
if
(
!
frame
)
{
return
;
}
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
if
(
RefPtr
<
PresShell
>
presShell
=
presContext
-
>
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
}
nsresult
nsFrameLoader
:
:
SwapWithOtherRemoteLoader
(
nsFrameLoader
*
aOther
nsFrameLoaderOwner
*
aThisOwner
nsFrameLoaderOwner
*
aOtherOwner
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
DEBUG
RefPtr
<
nsFrameLoader
>
first
=
aThisOwner
-
>
GetFrameLoader
(
)
;
RefPtr
<
nsFrameLoader
>
second
=
aOtherOwner
-
>
GetFrameLoader
(
)
;
MOZ_ASSERT
(
first
=
=
this
"
aThisOwner
must
own
this
"
)
;
MOZ_ASSERT
(
second
=
=
aOther
"
aOtherOwner
must
own
aOther
"
)
;
#
endif
Element
*
ourContent
=
mOwnerContent
;
Element
*
otherContent
=
aOther
-
>
mOwnerContent
;
if
(
!
ourContent
|
|
!
otherContent
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
equal
;
nsresult
rv
=
ourContent
-
>
NodePrincipal
(
)
-
>
Equals
(
otherContent
-
>
NodePrincipal
(
)
&
equal
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
equal
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
Document
*
ourDoc
=
ourContent
-
>
GetComposedDoc
(
)
;
Document
*
otherDoc
=
otherContent
-
>
GetComposedDoc
(
)
;
if
(
!
ourDoc
|
|
!
otherDoc
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
PresShell
*
ourPresShell
=
ourDoc
-
>
GetPresShell
(
)
;
PresShell
*
otherPresShell
=
otherDoc
-
>
GetPresShell
(
)
;
if
(
!
ourPresShell
|
|
!
otherPresShell
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
auto
*
browserParent
=
GetBrowserParent
(
)
;
auto
*
otherBrowserParent
=
aOther
-
>
GetBrowserParent
(
)
;
if
(
!
browserParent
|
|
!
otherBrowserParent
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
BrowsingContext
>
ourBc
=
browserParent
-
>
GetBrowsingContext
(
)
;
RefPtr
<
BrowsingContext
>
otherBc
=
otherBrowserParent
-
>
GetBrowsingContext
(
)
;
OriginAttributes
ourOriginAttributes
=
ourBc
-
>
OriginAttributesRef
(
)
;
rv
=
PopulateOriginContextIdsFromAttributes
(
ourOriginAttributes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
otherOriginAttributes
=
otherBc
-
>
OriginAttributesRef
(
)
;
rv
=
aOther
-
>
PopulateOriginContextIdsFromAttributes
(
otherOriginAttributes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
ourOriginAttributes
.
EqualsIgnoringFPD
(
otherOriginAttributes
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
ourHasHistory
=
mIsTopLevelContent
&
&
ourContent
-
>
IsXULElement
(
nsGkAtoms
:
:
browser
)
&
&
!
ourContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disablehistory
)
;
bool
otherHasHistory
=
aOther
-
>
mIsTopLevelContent
&
&
otherContent
-
>
IsXULElement
(
nsGkAtoms
:
:
browser
)
&
&
!
otherContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disablehistory
)
;
if
(
ourHasHistory
!
=
otherHasHistory
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
mInSwap
|
|
aOther
-
>
mInSwap
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
mInSwap
=
aOther
-
>
mInSwap
=
true
;
nsIFrame
*
ourFrame
=
ourContent
-
>
GetPrimaryFrame
(
)
;
nsIFrame
*
otherFrame
=
otherContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
ourFrame
|
|
!
otherFrame
)
{
mInSwap
=
aOther
-
>
mInSwap
=
false
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsSubDocumentFrame
*
ourFrameFrame
=
do_QueryFrame
(
ourFrame
)
;
if
(
!
ourFrameFrame
)
{
mInSwap
=
aOther
-
>
mInSwap
=
false
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
rv
=
ourFrameFrame
-
>
BeginSwapDocShells
(
otherFrame
)
;
if
(
NS_FAILED
(
rv
)
)
{
mInSwap
=
aOther
-
>
mInSwap
=
false
;
return
rv
;
}
nsCOMPtr
<
nsIBrowserDOMWindow
>
otherBrowserDOMWindow
=
otherBrowserParent
-
>
GetBrowserDOMWindow
(
)
;
nsCOMPtr
<
nsIBrowserDOMWindow
>
browserDOMWindow
=
browserParent
-
>
GetBrowserDOMWindow
(
)
;
if
(
!
!
otherBrowserDOMWindow
!
=
!
!
browserDOMWindow
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
OwnerIsMozBrowserFrame
(
)
&
&
!
aOther
-
>
OwnerIsMozBrowserFrame
(
)
)
{
DestroyBrowserFrameScripts
(
)
;
}
if
(
!
OwnerIsMozBrowserFrame
(
)
&
&
aOther
-
>
OwnerIsMozBrowserFrame
(
)
)
{
aOther
-
>
DestroyBrowserFrameScripts
(
)
;
}
otherBrowserParent
-
>
SetBrowserDOMWindow
(
browserDOMWindow
)
;
browserParent
-
>
SetBrowserDOMWindow
(
otherBrowserDOMWindow
)
;
MaybeUpdatePrimaryBrowserParent
(
eBrowserParentRemoved
)
;
aOther
-
>
MaybeUpdatePrimaryBrowserParent
(
eBrowserParentRemoved
)
;
if
(
mozilla
:
:
BFCacheInParent
(
)
&
&
XRE_IsParentProcess
(
)
)
{
auto
evict
=
[
]
(
nsFrameLoader
*
aFrameLoader
)
{
if
(
BrowsingContext
*
bc
=
aFrameLoader
-
>
GetMaybePendingBrowsingContext
(
)
)
{
nsCOMPtr
<
nsISHistory
>
shistory
=
bc
-
>
Canonical
(
)
-
>
GetSessionHistory
(
)
;
if
(
shistory
)
{
shistory
-
>
EvictAllContentViewers
(
)
;
}
}
}
;
evict
(
this
)
;
evict
(
aOther
)
;
}
SetOwnerContent
(
otherContent
)
;
aOther
-
>
SetOwnerContent
(
ourContent
)
;
browserParent
-
>
SetOwnerElement
(
otherContent
)
;
otherBrowserParent
-
>
SetOwnerElement
(
ourContent
)
;
bool
ourActive
=
otherBc
-
>
GetIsActiveBrowserWindow
(
)
;
bool
otherActive
=
ourBc
-
>
GetIsActiveBrowserWindow
(
)
;
if
(
ourBc
-
>
IsTop
(
)
)
{
ourBc
-
>
SetIsActiveBrowserWindow
(
otherActive
)
;
}
if
(
otherBc
-
>
IsTop
(
)
)
{
otherBc
-
>
SetIsActiveBrowserWindow
(
ourActive
)
;
}
MaybeUpdatePrimaryBrowserParent
(
eBrowserParentChanged
)
;
aOther
-
>
MaybeUpdatePrimaryBrowserParent
(
eBrowserParentChanged
)
;
RefPtr
<
nsFrameMessageManager
>
ourMessageManager
=
mMessageManager
;
RefPtr
<
nsFrameMessageManager
>
otherMessageManager
=
aOther
-
>
mMessageManager
;
if
(
ourMessageManager
)
{
ourMessageManager
-
>
SetCallback
(
aOther
)
;
}
if
(
otherMessageManager
)
{
otherMessageManager
-
>
SetCallback
(
this
)
;
}
mMessageManager
.
swap
(
aOther
-
>
mMessageManager
)
;
RefPtr
<
nsFrameLoader
>
kungFuDeathGrip
(
this
)
;
aThisOwner
-
>
SetFrameLoader
(
aOther
)
;
aOtherOwner
-
>
SetFrameLoader
(
kungFuDeathGrip
)
;
ourFrameFrame
-
>
EndSwapDocShells
(
otherFrame
)
;
ourPresShell
-
>
BackingScaleFactorChanged
(
)
;
otherPresShell
-
>
BackingScaleFactorChanged
(
)
;
InitializeBrowserAPI
(
)
;
aOther
-
>
InitializeBrowserAPI
(
)
;
mInSwap
=
aOther
-
>
mInSwap
=
false
;
MutableTabContext
ourContext
;
rv
=
GetNewTabContext
(
&
ourContext
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
MutableTabContext
otherContext
;
rv
=
aOther
-
>
GetNewTabContext
(
&
otherContext
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
Unused
<
<
browserParent
-
>
SendSwappedWithOtherRemoteLoader
(
ourContext
.
AsIPCTabContext
(
)
)
;
Unused
<
<
otherBrowserParent
-
>
SendSwappedWithOtherRemoteLoader
(
otherContext
.
AsIPCTabContext
(
)
)
;
return
NS_OK
;
}
class
MOZ_RAII
AutoResetInFrameSwap
final
{
public
:
AutoResetInFrameSwap
(
nsFrameLoader
*
aThisFrameLoader
nsFrameLoader
*
aOtherFrameLoader
nsDocShell
*
aThisDocShell
nsDocShell
*
aOtherDocShell
EventTarget
*
aThisEventTarget
EventTarget
*
aOtherEventTarget
)
:
mThisFrameLoader
(
aThisFrameLoader
)
mOtherFrameLoader
(
aOtherFrameLoader
)
mThisDocShell
(
aThisDocShell
)
mOtherDocShell
(
aOtherDocShell
)
mThisEventTarget
(
aThisEventTarget
)
mOtherEventTarget
(
aOtherEventTarget
)
{
mThisFrameLoader
-
>
mInSwap
=
true
;
mOtherFrameLoader
-
>
mInSwap
=
true
;
mThisDocShell
-
>
SetInFrameSwap
(
true
)
;
mOtherDocShell
-
>
SetInFrameSwap
(
true
)
;
nsContentUtils
:
:
FirePageShowEventForFrameLoaderSwap
(
mThisDocShell
mThisEventTarget
false
)
;
nsContentUtils
:
:
FirePageShowEventForFrameLoaderSwap
(
mOtherDocShell
mOtherEventTarget
false
)
;
nsContentUtils
:
:
FirePageHideEventForFrameLoaderSwap
(
mThisDocShell
mThisEventTarget
)
;
nsContentUtils
:
:
FirePageHideEventForFrameLoaderSwap
(
mOtherDocShell
mOtherEventTarget
)
;
}
~
AutoResetInFrameSwap
(
)
{
nsContentUtils
:
:
FirePageShowEventForFrameLoaderSwap
(
mThisDocShell
mThisEventTarget
true
)
;
nsContentUtils
:
:
FirePageShowEventForFrameLoaderSwap
(
mOtherDocShell
mOtherEventTarget
true
)
;
mThisFrameLoader
-
>
mInSwap
=
false
;
mOtherFrameLoader
-
>
mInSwap
=
false
;
mThisDocShell
-
>
SetInFrameSwap
(
false
)
;
mOtherDocShell
-
>
SetInFrameSwap
(
false
)
;
if
(
RefPtr
<
Document
>
doc
=
mThisDocShell
-
>
GetDocument
(
)
)
{
doc
-
>
UpdateVisibilityState
(
)
;
}
if
(
RefPtr
<
Document
>
doc
=
mOtherDocShell
-
>
GetDocument
(
)
)
{
doc
-
>
UpdateVisibilityState
(
)
;
}
}
private
:
RefPtr
<
nsFrameLoader
>
mThisFrameLoader
;
RefPtr
<
nsFrameLoader
>
mOtherFrameLoader
;
RefPtr
<
nsDocShell
>
mThisDocShell
;
RefPtr
<
nsDocShell
>
mOtherDocShell
;
nsCOMPtr
<
EventTarget
>
mThisEventTarget
;
nsCOMPtr
<
EventTarget
>
mOtherEventTarget
;
}
;
nsresult
nsFrameLoader
:
:
SwapWithOtherLoader
(
nsFrameLoader
*
aOther
nsFrameLoaderOwner
*
aThisOwner
nsFrameLoaderOwner
*
aOtherOwner
)
{
#
ifdef
DEBUG
RefPtr
<
nsFrameLoader
>
first
=
aThisOwner
-
>
GetFrameLoader
(
)
;
RefPtr
<
nsFrameLoader
>
second
=
aOtherOwner
-
>
GetFrameLoader
(
)
;
MOZ_ASSERT
(
first
=
=
this
"
aThisOwner
must
own
this
"
)
;
MOZ_ASSERT
(
second
=
=
aOther
"
aOtherOwner
must
own
aOther
"
)
;
#
endif
NS_ENSURE_STATE
(
!
mInShow
&
&
!
aOther
-
>
mInShow
)
;
if
(
IsRemoteFrame
(
)
!
=
aOther
-
>
IsRemoteFrame
(
)
)
{
NS_WARNING
(
"
Swapping
remote
and
non
-
remote
frames
is
not
currently
supported
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
Element
>
ourContent
=
mOwnerContent
;
RefPtr
<
Element
>
otherContent
=
aOther
-
>
mOwnerContent
;
if
(
!
ourContent
|
|
!
otherContent
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIFrame
*
ourFrame
=
ourContent
-
>
GetPrimaryFrame
(
FlushType
:
:
Frames
)
;
nsIFrame
*
otherFrame
=
otherContent
-
>
GetPrimaryFrame
(
FlushType
:
:
Frames
)
;
if
(
!
ourFrame
|
|
!
otherFrame
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
ourContent
!
=
mOwnerContent
|
|
otherContent
!
=
aOther
-
>
mOwnerContent
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
ourHasSrcdoc
=
ourContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
ourContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
srcdoc
)
;
bool
otherHasSrcdoc
=
otherContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
otherContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
srcdoc
)
;
if
(
ourHasSrcdoc
|
|
otherHasSrcdoc
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
bool
ourFullscreenAllowed
=
ourContent
-
>
IsXULElement
(
)
|
|
(
OwnerIsMozBrowserFrame
(
)
&
&
ourContent
-
>
HasAttr
(
nsGkAtoms
:
:
allowfullscreen
)
)
;
bool
otherFullscreenAllowed
=
otherContent
-
>
IsXULElement
(
)
|
|
(
aOther
-
>
OwnerIsMozBrowserFrame
(
)
&
&
otherContent
-
>
HasAttr
(
nsGkAtoms
:
:
allowfullscreen
)
)
;
if
(
ourFullscreenAllowed
!
=
otherFullscreenAllowed
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsILoadContext
*
ourLoadContext
=
ourContent
-
>
OwnerDoc
(
)
-
>
GetLoadContext
(
)
;
nsILoadContext
*
otherLoadContext
=
otherContent
-
>
OwnerDoc
(
)
-
>
GetLoadContext
(
)
;
MOZ_ASSERT
(
ourLoadContext
&
&
otherLoadContext
"
Swapping
frames
within
dead
documents
?
"
)
;
if
(
ourLoadContext
-
>
UseRemoteTabs
(
)
!
=
otherLoadContext
-
>
UseRemoteTabs
(
)
)
{
NS_WARNING
(
"
Can
'
t
swap
between
e10s
and
non
-
e10s
windows
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
ourLoadContext
-
>
UseRemoteSubframes
(
)
!
=
otherLoadContext
-
>
UseRemoteSubframes
(
)
)
{
NS_WARNING
(
"
Can
'
t
swap
between
fission
and
non
-
fission
windows
"
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
IsRemoteFrame
(
)
)
{
MOZ_ASSERT
(
aOther
-
>
IsRemoteFrame
(
)
)
;
return
SwapWithOtherRemoteLoader
(
aOther
aThisOwner
aOtherOwner
)
;
}
bool
equal
;
nsresult
rv
=
ourContent
-
>
NodePrincipal
(
)
-
>
Equals
(
otherContent
-
>
NodePrincipal
(
)
&
equal
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
equal
)
{
return
NS_ERROR_DOM_SECURITY_ERR
;
}
RefPtr
<
nsDocShell
>
ourDocshell
=
static_cast
<
nsDocShell
*
>
(
GetExistingDocShell
(
)
)
;
RefPtr
<
nsDocShell
>
otherDocshell
=
static_cast
<
nsDocShell
*
>
(
aOther
-
>
GetExistingDocShell
(
)
)
;
if
(
!
ourDocshell
|
|
!
otherDocshell
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
ourRootTreeItem
otherRootTreeItem
;
ourDocshell
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
ourRootTreeItem
)
)
;
otherDocshell
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
otherRootTreeItem
)
)
;
nsCOMPtr
<
nsIWebNavigation
>
ourRootWebnav
=
do_QueryInterface
(
ourRootTreeItem
)
;
nsCOMPtr
<
nsIWebNavigation
>
otherRootWebnav
=
do_QueryInterface
(
otherRootTreeItem
)
;
if
(
!
ourRootWebnav
|
|
!
otherRootWebnav
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
ChildSHistory
>
ourHistory
=
ourRootWebnav
-
>
GetSessionHistory
(
)
;
RefPtr
<
ChildSHistory
>
otherHistory
=
otherRootWebnav
-
>
GetSessionHistory
(
)
;
if
(
(
ourRootTreeItem
!
=
ourDocshell
|
|
otherRootTreeItem
!
=
otherDocshell
)
&
&
(
ourHistory
|
|
otherHistory
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
RefPtr
<
BrowsingContext
>
ourBc
=
ourDocshell
-
>
GetBrowsingContext
(
)
;
RefPtr
<
BrowsingContext
>
otherBc
=
otherDocshell
-
>
GetBrowsingContext
(
)
;
if
(
ourBc
-
>
GetType
(
)
!
=
otherBc
-
>
GetType
(
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
ourBc
-
>
IsTop
(
)
!
=
otherBc
-
>
IsTop
(
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
!
ourBc
-
>
IsContent
(
)
&
&
(
!
AllDescendantsOfType
(
ourBc
ourBc
-
>
GetType
(
)
)
|
|
!
AllDescendantsOfType
(
otherBc
otherBc
-
>
GetType
(
)
)
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
ourOwner
otherOwner
;
ourDocshell
-
>
GetTreeOwner
(
getter_AddRefs
(
ourOwner
)
)
;
otherDocshell
-
>
GetTreeOwner
(
getter_AddRefs
(
otherOwner
)
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
ourParentItem
otherParentItem
;
ourDocshell
-
>
GetInProcessParent
(
getter_AddRefs
(
ourParentItem
)
)
;
otherDocshell
-
>
GetInProcessParent
(
getter_AddRefs
(
otherParentItem
)
)
;
if
(
!
ourParentItem
|
|
!
otherParentItem
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
ourWindow
=
ourDocshell
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
otherWindow
=
otherDocshell
-
>
GetWindow
(
)
;
nsCOMPtr
<
Element
>
ourFrameElement
=
ourWindow
-
>
GetFrameElementInternal
(
)
;
nsCOMPtr
<
Element
>
otherFrameElement
=
otherWindow
-
>
GetFrameElementInternal
(
)
;
nsCOMPtr
<
EventTarget
>
ourChromeEventHandler
=
ourWindow
-
>
GetChromeEventHandler
(
)
;
nsCOMPtr
<
EventTarget
>
otherChromeEventHandler
=
otherWindow
-
>
GetChromeEventHandler
(
)
;
nsCOMPtr
<
EventTarget
>
ourEventTarget
=
ourWindow
-
>
GetParentTarget
(
)
;
nsCOMPtr
<
EventTarget
>
otherEventTarget
=
otherWindow
-
>
GetParentTarget
(
)
;
NS_ASSERTION
(
SameCOMIdentity
(
ourFrameElement
ourContent
)
&
&
SameCOMIdentity
(
otherFrameElement
otherContent
)
&
&
SameCOMIdentity
(
ourChromeEventHandler
ourContent
)
&
&
SameCOMIdentity
(
otherChromeEventHandler
otherContent
)
"
How
did
that
happen
exactly
?
"
)
;
nsCOMPtr
<
Document
>
ourChildDocument
=
ourWindow
-
>
GetExtantDoc
(
)
;
nsCOMPtr
<
Document
>
otherChildDocument
=
otherWindow
-
>
GetExtantDoc
(
)
;
if
(
!
ourChildDocument
|
|
!
otherChildDocument
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsCOMPtr
<
Document
>
ourParentDocument
=
ourChildDocument
-
>
GetInProcessParentDocument
(
)
;
nsCOMPtr
<
Document
>
otherParentDocument
=
otherChildDocument
-
>
GetInProcessParentDocument
(
)
;
Document
*
ourDoc
=
ourContent
-
>
GetComposedDoc
(
)
;
Document
*
otherDoc
=
otherContent
-
>
GetComposedDoc
(
)
;
if
(
!
ourDoc
|
|
!
otherDoc
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_ASSERTION
(
ourDoc
=
=
ourParentDocument
"
Unexpected
parent
document
"
)
;
NS_ASSERTION
(
otherDoc
=
=
otherParentDocument
"
Unexpected
parent
document
"
)
;
PresShell
*
ourPresShell
=
ourDoc
-
>
GetPresShell
(
)
;
PresShell
*
otherPresShell
=
otherDoc
-
>
GetPresShell
(
)
;
if
(
!
ourPresShell
|
|
!
otherPresShell
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
OriginAttributes
ourOriginAttributes
=
ourDocshell
-
>
GetOriginAttributes
(
)
;
rv
=
PopulateOriginContextIdsFromAttributes
(
ourOriginAttributes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
OriginAttributes
otherOriginAttributes
=
otherDocshell
-
>
GetOriginAttributes
(
)
;
rv
=
aOther
-
>
PopulateOriginContextIdsFromAttributes
(
otherOriginAttributes
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
ourOriginAttributes
!
=
otherOriginAttributes
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
if
(
mInSwap
|
|
aOther
-
>
mInSwap
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
AutoResetInFrameSwap
autoFrameSwap
(
this
aOther
ourDocshell
otherDocshell
ourEventTarget
otherEventTarget
)
;
nsSubDocumentFrame
*
ourFrameFrame
=
do_QueryFrame
(
ourFrame
)
;
if
(
!
ourFrameFrame
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
rv
=
ourFrameFrame
-
>
BeginSwapDocShells
(
otherFrame
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
OwnerIsMozBrowserFrame
(
)
&
&
!
aOther
-
>
OwnerIsMozBrowserFrame
(
)
)
{
DestroyBrowserFrameScripts
(
)
;
}
if
(
!
OwnerIsMozBrowserFrame
(
)
&
&
aOther
-
>
OwnerIsMozBrowserFrame
(
)
)
{
aOther
-
>
DestroyBrowserFrameScripts
(
)
;
}
ourParentItem
-
>
RemoveChild
(
ourDocshell
)
;
otherParentItem
-
>
RemoveChild
(
otherDocshell
)
;
if
(
ourBc
-
>
IsContent
(
)
)
{
ourOwner
-
>
ContentShellRemoved
(
ourDocshell
)
;
otherOwner
-
>
ContentShellRemoved
(
otherDocshell
)
;
}
ourParentItem
-
>
AddChild
(
otherDocshell
)
;
otherParentItem
-
>
AddChild
(
ourDocshell
)
;
ourDocshell
-
>
SetChromeEventHandler
(
otherChromeEventHandler
)
;
otherDocshell
-
>
SetChromeEventHandler
(
ourChromeEventHandler
)
;
SetTreeOwnerAndChromeEventHandlerOnDocshellTree
(
ourDocshell
otherOwner
ourBc
-
>
IsContent
(
)
?
otherChromeEventHandler
.
get
(
)
:
nullptr
)
;
SetTreeOwnerAndChromeEventHandlerOnDocshellTree
(
otherDocshell
ourOwner
ourBc
-
>
IsContent
(
)
?
ourChromeEventHandler
.
get
(
)
:
nullptr
)
;
SetOwnerContent
(
otherContent
)
;
aOther
-
>
SetOwnerContent
(
ourContent
)
;
AddTreeItemToTreeOwner
(
ourDocshell
otherOwner
)
;
aOther
-
>
AddTreeItemToTreeOwner
(
otherDocshell
ourOwner
)
;
ourParentDocument
-
>
SetSubDocumentFor
(
ourContent
nullptr
)
;
otherParentDocument
-
>
SetSubDocumentFor
(
otherContent
nullptr
)
;
ourParentDocument
-
>
SetSubDocumentFor
(
ourContent
otherChildDocument
)
;
otherParentDocument
-
>
SetSubDocumentFor
(
otherContent
ourChildDocument
)
;
ourWindow
-
>
SetFrameElementInternal
(
otherFrameElement
)
;
otherWindow
-
>
SetFrameElementInternal
(
ourFrameElement
)
;
RefPtr
<
nsFrameMessageManager
>
ourMessageManager
=
mMessageManager
;
RefPtr
<
nsFrameMessageManager
>
otherMessageManager
=
aOther
-
>
mMessageManager
;
if
(
mChildMessageManager
)
{
InProcessBrowserChildMessageManager
*
browserChild
=
mChildMessageManager
;
browserChild
-
>
SetOwner
(
otherContent
)
;
browserChild
-
>
SetChromeMessageManager
(
otherMessageManager
)
;
}
if
(
aOther
-
>
mChildMessageManager
)
{
InProcessBrowserChildMessageManager
*
otherBrowserChild
=
aOther
-
>
mChildMessageManager
;
otherBrowserChild
-
>
SetOwner
(
ourContent
)
;
otherBrowserChild
-
>
SetChromeMessageManager
(
ourMessageManager
)
;
}
if
(
mMessageManager
)
{
mMessageManager
-
>
SetCallback
(
aOther
)
;
}
if
(
aOther
-
>
mMessageManager
)
{
aOther
-
>
mMessageManager
-
>
SetCallback
(
this
)
;
}
mMessageManager
.
swap
(
aOther
-
>
mMessageManager
)
;
RefPtr
<
nsFrameLoader
>
kungFuDeathGrip
(
this
)
;
aThisOwner
-
>
SetFrameLoader
(
aOther
)
;
aOtherOwner
-
>
SetFrameLoader
(
kungFuDeathGrip
)
;
if
(
ourHistory
)
{
ourHistory
-
>
EvictLocalContentViewers
(
)
;
}
if
(
otherHistory
)
{
otherHistory
-
>
EvictLocalContentViewers
(
)
;
}
NS_ASSERTION
(
ourFrame
=
=
ourContent
-
>
GetPrimaryFrame
(
)
&
&
otherFrame
=
=
otherContent
-
>
GetPrimaryFrame
(
)
"
changed
primary
frame
"
)
;
ourFrameFrame
-
>
EndSwapDocShells
(
otherFrame
)
;
ourFrame
-
>
PresShell
(
)
-
>
BackingScaleFactorChanged
(
)
;
otherFrame
-
>
PresShell
(
)
-
>
BackingScaleFactorChanged
(
)
;
InitializeBrowserAPI
(
)
;
aOther
-
>
InitializeBrowserAPI
(
)
;
return
NS_OK
;
}
void
nsFrameLoader
:
:
Destroy
(
bool
aForProcessSwitch
)
{
StartDestroy
(
aForProcessSwitch
)
;
}
class
nsFrameLoaderDestroyRunnable
:
public
Runnable
{
enum
DestroyPhase
{
eDestroyDocShell
eWaitForUnloadMessage
eDestroyComplete
}
;
RefPtr
<
nsFrameLoader
>
mFrameLoader
;
DestroyPhase
mPhase
;
public
:
explicit
nsFrameLoaderDestroyRunnable
(
nsFrameLoader
*
aFrameLoader
)
:
mozilla
:
:
Runnable
(
"
nsFrameLoaderDestroyRunnable
"
)
mFrameLoader
(
aFrameLoader
)
mPhase
(
eDestroyDocShell
)
{
}
NS_IMETHOD
Run
(
)
override
;
}
;
void
nsFrameLoader
:
:
StartDestroy
(
bool
aForProcessSwitch
)
{
if
(
mDestroyCalled
)
{
return
;
}
mDestroyCalled
=
true
;
if
(
!
aForProcessSwitch
)
{
RequestFinalTabStateFlush
(
)
;
}
if
(
mMessageManager
)
{
mMessageManager
-
>
Close
(
)
;
}
if
(
mChildMessageManager
|
|
mRemoteBrowser
)
{
mOwnerContentStrong
=
mOwnerContent
;
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
browserParent
-
>
CacheFrameLoader
(
this
)
;
}
if
(
mChildMessageManager
)
{
mChildMessageManager
-
>
CacheFrameLoader
(
this
)
;
}
}
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
browserParent
-
>
RemoveWindowListeners
(
)
;
}
nsCOMPtr
<
Document
>
doc
;
bool
dynamicSubframeRemoval
=
false
;
if
(
mOwnerContent
)
{
doc
=
mOwnerContent
-
>
OwnerDoc
(
)
;
dynamicSubframeRemoval
=
!
aForProcessSwitch
&
&
mPendingBrowsingContext
-
>
IsFrame
(
)
&
&
!
doc
-
>
InUnlinkOrDeletion
(
)
;
doc
-
>
SetSubDocumentFor
(
mOwnerContent
nullptr
)
;
MaybeUpdatePrimaryBrowserParent
(
eBrowserParentRemoved
)
;
nsCOMPtr
<
nsFrameLoaderOwner
>
owner
=
do_QueryInterface
(
mOwnerContent
)
;
owner
-
>
FrameLoaderDestroying
(
this
)
;
SetOwnerContent
(
nullptr
)
;
}
if
(
dynamicSubframeRemoval
)
{
BrowsingContext
*
browsingContext
=
GetExtantBrowsingContext
(
)
;
if
(
browsingContext
)
{
RefPtr
<
ChildSHistory
>
childSHistory
=
browsingContext
-
>
Top
(
)
-
>
GetChildSessionHistory
(
)
;
if
(
childSHistory
)
{
if
(
mozilla
:
:
SessionHistoryInParent
(
)
)
{
uint32_t
addedEntries
=
0
;
browsingContext
-
>
PreOrderWalk
(
[
&
addedEntries
]
(
BrowsingContext
*
aBC
)
{
addedEntries
+
=
aBC
-
>
GetHistoryEntryCount
(
)
-
1
;
}
)
;
nsID
changeID
=
{
}
;
if
(
addedEntries
>
0
)
{
ChildSHistory
*
shistory
=
browsingContext
-
>
Top
(
)
-
>
GetChildSessionHistory
(
)
;
if
(
shistory
)
{
changeID
=
shistory
-
>
AddPendingHistoryChange
(
0
-
addedEntries
)
;
}
}
browsingContext
-
>
RemoveFromSessionHistory
(
changeID
)
;
}
else
{
AutoTArray
<
nsID
16
>
ids
(
{
browsingContext
-
>
GetHistoryID
(
)
}
)
;
childSHistory
-
>
LegacySHistory
(
)
-
>
RemoveEntries
(
ids
childSHistory
-
>
Index
(
)
)
;
}
}
}
}
if
(
mIsTopLevelContent
)
{
if
(
GetDocShell
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetDocShell
(
)
-
>
GetInProcessParent
(
getter_AddRefs
(
parentItem
)
)
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
=
do_GetInterface
(
parentItem
)
;
if
(
owner
)
{
owner
-
>
ContentShellRemoved
(
GetDocShell
(
)
)
;
}
}
}
if
(
GetDocShell
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win_private
(
GetDocShell
(
)
-
>
GetWindow
(
)
)
;
if
(
win_private
)
{
win_private
-
>
SetFrameElementInternal
(
nullptr
)
;
}
}
nsCOMPtr
<
nsIRunnable
>
destroyRunnable
=
new
nsFrameLoaderDestroyRunnable
(
this
)
;
if
(
mNeedsAsyncDestroy
|
|
!
doc
|
|
NS_FAILED
(
doc
-
>
FinalizeFrameLoader
(
this
destroyRunnable
)
)
)
{
NS_DispatchToCurrentThread
(
destroyRunnable
)
;
}
}
nsresult
nsFrameLoaderDestroyRunnable
:
:
Run
(
)
{
switch
(
mPhase
)
{
case
eDestroyDocShell
:
mFrameLoader
-
>
DestroyDocShell
(
)
;
if
(
mFrameLoader
-
>
mChildMessageManager
)
{
mPhase
=
eWaitForUnloadMessage
;
NS_DispatchToCurrentThread
(
this
)
;
}
break
;
case
eWaitForUnloadMessage
:
mPhase
=
eDestroyComplete
;
NS_DispatchToCurrentThread
(
this
)
;
break
;
case
eDestroyComplete
:
mFrameLoader
-
>
DestroyComplete
(
)
;
break
;
}
return
NS_OK
;
}
void
nsFrameLoader
:
:
DestroyDocShell
(
)
{
if
(
mRemoteBrowser
)
{
mRemoteBrowser
-
>
DestroyStart
(
)
;
}
if
(
mChildMessageManager
)
{
mChildMessageManager
-
>
FireUnloadEvent
(
)
;
}
if
(
mSessionStoreListener
)
{
mSessionStoreListener
-
>
RemoveListeners
(
)
;
mSessionStoreListener
=
nullptr
;
}
if
(
mSessionStoreChangeListener
)
{
mSessionStoreChangeListener
-
>
Stop
(
)
;
mSessionStoreChangeListener
=
nullptr
;
}
if
(
GetDocShell
(
)
)
{
GetDocShell
(
)
-
>
Destroy
(
)
;
}
if
(
!
mWillChangeProcess
&
&
mPendingBrowsingContext
&
&
mPendingBrowsingContext
-
>
EverAttached
(
)
)
{
mPendingBrowsingContext
-
>
Detach
(
)
;
}
mPendingBrowsingContext
=
nullptr
;
mDocShell
=
nullptr
;
if
(
mChildMessageManager
)
{
mChildMessageManager
-
>
DisconnectEventListeners
(
)
;
}
}
void
nsFrameLoader
:
:
DestroyComplete
(
)
{
if
(
mChildMessageManager
|
|
mRemoteBrowser
)
{
mOwnerContentStrong
=
nullptr
;
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
browserParent
-
>
CacheFrameLoader
(
nullptr
)
;
}
if
(
mChildMessageManager
)
{
mChildMessageManager
-
>
CacheFrameLoader
(
nullptr
)
;
}
}
if
(
mRemoteBrowser
)
{
mRemoteBrowser
-
>
DestroyComplete
(
)
;
mRemoteBrowser
=
nullptr
;
}
if
(
mMessageManager
)
{
mMessageManager
-
>
Disconnect
(
)
;
}
if
(
mChildMessageManager
)
{
mChildMessageManager
-
>
Disconnect
(
)
;
}
mMessageManager
=
nullptr
;
mChildMessageManager
=
nullptr
;
}
void
nsFrameLoader
:
:
SetOwnerContent
(
Element
*
aContent
)
{
if
(
mObservingOwnerContent
)
{
mObservingOwnerContent
=
false
;
mOwnerContent
-
>
RemoveMutationObserver
(
this
)
;
}
if
(
RefPtr
<
nsFrameLoaderOwner
>
owner
=
do_QueryObject
(
mOwnerContent
)
)
{
owner
-
>
DetachFrameLoader
(
this
)
;
}
mOwnerContent
=
aContent
;
if
(
RefPtr
<
nsFrameLoaderOwner
>
owner
=
do_QueryObject
(
mOwnerContent
)
)
{
owner
-
>
AttachFrameLoader
(
this
)
;
#
ifdef
NIGHTLY_BUILD
if
(
mozilla
:
:
BFCacheInParent
(
)
&
&
XRE_IsParentProcess
(
)
)
{
if
(
BrowsingContext
*
bc
=
GetMaybePendingBrowsingContext
(
)
)
{
nsISHistory
*
shistory
=
bc
-
>
Canonical
(
)
-
>
GetSessionHistory
(
)
;
if
(
shistory
)
{
uint32_t
count
=
shistory
-
>
GetCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsISHEntry
>
entry
;
shistory
-
>
GetEntryAtIndex
(
i
getter_AddRefs
(
entry
)
)
;
nsCOMPtr
<
SessionHistoryEntry
>
she
=
do_QueryInterface
(
entry
)
;
MOZ_RELEASE_ASSERT
(
!
she
|
|
!
she
-
>
GetFrameLoader
(
)
)
;
}
}
}
}
#
endif
}
if
(
mSessionStoreListener
&
&
mOwnerContent
)
{
mSessionStoreListener
-
>
SetOwnerContent
(
mOwnerContent
)
;
}
if
(
RefPtr
<
BrowsingContext
>
browsingContext
=
GetExtantBrowsingContext
(
)
)
{
browsingContext
-
>
SetEmbedderElement
(
mOwnerContent
)
;
}
if
(
mSessionStoreChangeListener
)
{
mSessionStoreChangeListener
-
>
UpdateEventTargets
(
)
;
}
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JS
:
:
RootedObject
wrapper
(
jsapi
.
cx
(
)
GetWrapper
(
)
)
;
if
(
wrapper
)
{
JSAutoRealm
ar
(
jsapi
.
cx
(
)
wrapper
)
;
IgnoredErrorResult
rv
;
UpdateReflectorGlobal
(
jsapi
.
cx
(
)
wrapper
rv
)
;
Unused
<
<
NS_WARN_IF
(
rv
.
Failed
(
)
)
;
}
}
bool
nsFrameLoader
:
:
OwnerIsMozBrowserFrame
(
)
{
nsCOMPtr
<
nsIMozBrowserFrame
>
browserFrame
=
do_QueryInterface
(
mOwnerContent
)
;
return
browserFrame
?
browserFrame
-
>
GetReallyIsBrowser
(
)
:
false
;
}
nsIContent
*
nsFrameLoader
:
:
GetParentObject
(
)
const
{
return
mOwnerContent
;
}
void
nsFrameLoader
:
:
AssertSafeToInit
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
|
|
mOwnerContent
-
>
OwnerDoc
(
)
-
>
IsStaticDocument
(
)
"
FrameLoader
should
never
be
initialized
during
"
"
document
update
or
reflow
!
"
)
;
}
nsresult
nsFrameLoader
:
:
MaybeCreateDocShell
(
)
{
if
(
GetDocShell
(
)
)
{
return
NS_OK
;
}
if
(
IsRemoteFrame
(
)
)
{
return
NS_OK
;
}
NS_ENSURE_STATE
(
!
mDestroyCalled
)
;
AssertSafeToInit
(
)
;
Document
*
doc
=
mOwnerContent
-
>
OwnerDoc
(
)
;
MOZ_RELEASE_ASSERT
(
!
doc
-
>
IsResourceDoc
(
)
"
We
shouldn
'
t
even
exist
"
)
;
if
(
!
doc
-
>
IsStaticDocument
(
)
&
&
(
!
doc
-
>
GetWindow
(
)
|
|
!
mOwnerContent
-
>
IsInComposedDoc
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
!
doc
-
>
IsActive
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsDocShell
>
parentDocShell
=
nsDocShell
:
:
Cast
(
doc
-
>
GetDocShell
(
)
)
;
if
(
NS_WARN_IF
(
!
parentDocShell
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
doc
-
>
GetWindowContext
(
)
-
>
IsDiscarded
(
)
|
|
parentDocShell
-
>
GetBrowsingContext
(
)
-
>
IsDiscarded
(
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
if
(
!
EnsureBrowsingContextAttached
(
)
)
{
return
NS_ERROR_FAILURE
;
}
mPendingBrowsingContext
-
>
SetEmbedderElement
(
mOwnerContent
)
;
RefPtr
<
nsDocShell
>
docShell
=
nsDocShell
:
:
Create
(
mPendingBrowsingContext
)
;
NS_ENSURE_TRUE
(
docShell
NS_ERROR_FAILURE
)
;
mDocShell
=
docShell
;
mPendingBrowsingContext
-
>
Embed
(
)
;
InvokeBrowsingContextReadyCallback
(
)
;
mIsTopLevelContent
=
mPendingBrowsingContext
-
>
IsTopContent
(
)
;
if
(
mIsTopLevelContent
)
{
parentDocShell
-
>
AddChild
(
docShell
)
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
;
parentDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
parentTreeOwner
)
)
;
AddTreeItemToTreeOwner
(
docShell
parentTreeOwner
)
;
RefPtr
<
EventTarget
>
chromeEventHandler
;
bool
parentIsContent
=
parentDocShell
-
>
GetBrowsingContext
(
)
-
>
IsContent
(
)
;
if
(
parentIsContent
)
{
parentDocShell
-
>
GetChromeEventHandler
(
getter_AddRefs
(
chromeEventHandler
)
)
;
}
else
{
chromeEventHandler
=
mOwnerContent
;
}
docShell
-
>
SetChromeEventHandler
(
chromeEventHandler
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
newWindow
=
docShell
-
>
GetWindow
(
)
;
if
(
NS_WARN_IF
(
!
newWindow
)
)
{
NS_WARNING
(
"
Something
wrong
when
creating
the
docshell
for
a
frameloader
!
"
)
;
return
NS_ERROR_FAILURE
;
}
newWindow
-
>
SetFrameElementInternal
(
mOwnerContent
)
;
if
(
mOwnerContent
-
>
IsXULElement
(
nsGkAtoms
:
:
browser
)
&
&
mOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
allowscriptstoclose
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
nsGlobalWindowOuter
:
:
Cast
(
newWindow
)
-
>
AllowScriptsToClose
(
)
;
}
if
(
!
docShell
-
>
Initialize
(
)
)
{
NS_WARNING
(
"
Something
wrong
when
creating
the
docshell
for
a
frameloader
!
"
)
;
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mOwnerContent
)
;
if
(
mIsTopLevelContent
&
&
mOwnerContent
-
>
IsXULElement
(
nsGkAtoms
:
:
browser
)
&
&
!
mOwnerContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disablehistory
)
)
{
mPendingBrowsingContext
-
>
InitSessionHistory
(
)
;
}
uint32_t
sandboxFlags
=
0
;
HTMLIFrameElement
*
iframe
=
HTMLIFrameElement
:
:
FromNode
(
mOwnerContent
)
;
if
(
iframe
)
{
sandboxFlags
=
iframe
-
>
GetSandboxFlags
(
)
;
}
ApplySandboxFlags
(
sandboxFlags
)
;
MOZ_ALWAYS_SUCCEEDS
(
mPendingBrowsingContext
-
>
SetInitialSandboxFlags
(
mPendingBrowsingContext
-
>
GetSandboxFlags
(
)
)
)
;
if
(
OwnerIsMozBrowserFrame
(
)
)
{
nsAutoString
name
;
if
(
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
name
)
)
{
docShell
-
>
SetName
(
name
)
;
}
}
ReallyLoadFrameScripts
(
)
;
InitializeBrowserAPI
(
)
;
if
(
mIsTopLevelContent
&
&
mPendingBrowsingContext
-
>
GetMessageManagerGroup
(
)
=
=
u
"
browsers
"
_ns
)
{
Unused
<
<
mDocShell
-
>
GetDocument
(
)
;
}
return
NS_OK
;
}
void
nsFrameLoader
:
:
GetURL
(
nsString
&
aURI
nsIPrincipal
*
*
aTriggeringPrincipal
nsIContentSecurityPolicy
*
*
aCsp
)
{
aURI
.
Truncate
(
)
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
=
mOwnerContent
-
>
NodePrincipal
(
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
mOwnerContent
-
>
GetCsp
(
)
;
if
(
mOwnerContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
)
{
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
data
aURI
)
;
}
else
{
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
aURI
)
;
if
(
RefPtr
<
nsGenericHTMLFrameElement
>
frame
=
do_QueryObject
(
mOwnerContent
)
)
{
nsCOMPtr
<
nsIPrincipal
>
srcPrincipal
=
frame
-
>
GetSrcTriggeringPrincipal
(
)
;
if
(
srcPrincipal
)
{
triggeringPrincipal
=
srcPrincipal
;
nsCOMPtr
<
nsIExpandedPrincipal
>
ep
=
do_QueryInterface
(
triggeringPrincipal
)
;
if
(
ep
)
{
csp
=
ep
-
>
GetCsp
(
)
;
}
}
}
}
triggeringPrincipal
.
forget
(
aTriggeringPrincipal
)
;
csp
.
forget
(
aCsp
)
;
}
nsresult
nsFrameLoader
:
:
CheckForRecursiveLoad
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
!
IsRemoteFrame
(
)
"
Shouldn
'
t
call
CheckForRecursiveLoad
on
remote
frames
.
"
)
;
mDepthTooGreat
=
false
;
RefPtr
<
BrowsingContext
>
parentBC
(
mOwnerContent
-
>
OwnerDoc
(
)
-
>
GetBrowsingContext
(
)
)
;
MOZ_ASSERT
(
parentBC
"
How
can
we
not
have
a
parent
here
?
"
)
;
if
(
!
parentBC
-
>
IsContent
(
)
)
{
return
NS_OK
;
}
int32_t
depth
=
0
;
for
(
BrowsingContext
*
bc
=
parentBC
;
bc
;
bc
=
bc
-
>
GetParent
(
)
)
{
+
+
depth
;
if
(
depth
>
=
MAX_DEPTH_CONTENT_FRAMES
)
{
mDepthTooGreat
=
true
;
NS_WARNING
(
"
Too
many
nested
content
frames
so
giving
up
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
}
return
NS_OK
;
}
nsresult
nsFrameLoader
:
:
GetWindowDimensions
(
nsIntRect
&
aRect
)
{
if
(
!
mOwnerContent
)
{
return
NS_ERROR_FAILURE
;
}
Document
*
doc
=
mOwnerContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
NS_ERROR_FAILURE
;
}
MOZ_RELEASE_ASSERT
(
!
doc
-
>
IsResourceDoc
(
)
"
We
shouldn
'
t
even
exist
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
doc
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentAsItem
(
win
-
>
GetDocShell
(
)
)
;
if
(
!
parentAsItem
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentOwner
;
if
(
NS_FAILED
(
parentAsItem
-
>
GetTreeOwner
(
getter_AddRefs
(
parentOwner
)
)
)
|
|
!
parentOwner
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIBaseWindow
>
treeOwnerAsWin
(
do_GetInterface
(
parentOwner
)
)
;
treeOwnerAsWin
-
>
GetPosition
(
&
aRect
.
x
&
aRect
.
y
)
;
treeOwnerAsWin
-
>
GetSize
(
&
aRect
.
width
&
aRect
.
height
)
;
return
NS_OK
;
}
nsresult
nsFrameLoader
:
:
UpdatePositionAndSize
(
nsSubDocumentFrame
*
aIFrame
)
{
if
(
IsRemoteFrame
(
)
)
{
if
(
mRemoteBrowser
)
{
ScreenIntSize
size
=
aIFrame
-
>
GetSubdocumentSize
(
)
;
if
(
!
mRemoteBrowserShown
)
{
ShowRemoteFrame
(
size
aIFrame
)
;
}
nsIntRect
dimensions
;
NS_ENSURE_SUCCESS
(
GetWindowDimensions
(
dimensions
)
NS_ERROR_FAILURE
)
;
mLazySize
=
size
;
mRemoteBrowser
-
>
UpdateDimensions
(
dimensions
size
)
;
}
return
NS_OK
;
}
UpdateBaseWindowPositionAndSize
(
aIFrame
)
;
return
NS_OK
;
}
void
nsFrameLoader
:
:
SendIsUnderHiddenEmbedderElement
(
bool
aIsUnderHiddenEmbedderElement
)
{
MOZ_ASSERT
(
IsRemoteFrame
(
)
)
;
if
(
auto
*
browserBridgeChild
=
GetBrowserBridgeChild
(
)
)
{
browserBridgeChild
-
>
SetIsUnderHiddenEmbedderElement
(
aIsUnderHiddenEmbedderElement
)
;
}
}
void
nsFrameLoader
:
:
UpdateBaseWindowPositionAndSize
(
nsSubDocumentFrame
*
aIFrame
)
{
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
GetDocShell
(
IgnoreErrors
(
)
)
;
if
(
baseWindow
)
{
int32_t
x
=
0
;
int32_t
y
=
0
;
AutoWeakFrame
weakFrame
(
aIFrame
)
;
baseWindow
-
>
GetPosition
(
&
x
&
y
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
ScreenIntSize
size
=
aIFrame
-
>
GetSubdocumentSize
(
)
;
mLazySize
=
size
;
baseWindow
-
>
SetPositionAndSize
(
x
y
size
.
width
size
.
height
nsIBaseWindow
:
:
eDelayResize
)
;
}
}
uint32_t
nsFrameLoader
:
:
LazyWidth
(
)
const
{
uint32_t
lazyWidth
=
mLazySize
.
width
;
nsIFrame
*
frame
=
GetPrimaryFrameOfOwningContent
(
)
;
if
(
frame
)
{
lazyWidth
=
frame
-
>
PresContext
(
)
-
>
DevPixelsToIntCSSPixels
(
lazyWidth
)
;
}
return
lazyWidth
;
}
uint32_t
nsFrameLoader
:
:
LazyHeight
(
)
const
{
uint32_t
lazyHeight
=
mLazySize
.
height
;
nsIFrame
*
frame
=
GetPrimaryFrameOfOwningContent
(
)
;
if
(
frame
)
{
lazyHeight
=
frame
-
>
PresContext
(
)
-
>
DevPixelsToIntCSSPixels
(
lazyHeight
)
;
}
return
lazyHeight
;
}
bool
nsFrameLoader
:
:
EnsureRemoteBrowser
(
)
{
MOZ_ASSERT
(
IsRemoteFrame
(
)
)
;
return
mRemoteBrowser
|
|
TryRemoteBrowser
(
)
;
}
bool
nsFrameLoader
:
:
TryRemoteBrowserInternal
(
)
{
NS_ASSERTION
(
!
mRemoteBrowser
"
TryRemoteBrowser
called
with
a
remote
browser
already
?
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
"
Remote
subframes
should
only
be
created
using
the
"
"
CanonicalBrowsingContext
:
:
ChangeRemoteness
API
"
)
;
AssertSafeToInit
(
)
;
if
(
!
mOwnerContent
)
{
return
false
;
}
RefPtr
<
Document
>
doc
=
mOwnerContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
false
;
}
MOZ_RELEASE_ASSERT
(
!
doc
-
>
IsResourceDoc
(
)
"
We
shouldn
'
t
even
exist
"
)
;
if
(
!
OwnerIsMozBrowserFrame
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
if
(
mRemoteBrowser
)
{
return
true
;
}
if
(
!
mOwnerContent
|
|
mOwnerContent
-
>
OwnerDoc
(
)
!
=
doc
|
|
!
mOwnerContent
-
>
IsInComposedDoc
(
)
)
{
return
false
;
}
if
(
!
doc
-
>
IsActive
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
parentWin
=
doc
-
>
GetWindow
(
)
;
if
(
!
parentWin
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShell
>
parentDocShell
=
parentWin
-
>
GetDocShell
(
)
;
if
(
!
parentDocShell
)
{
return
false
;
}
if
(
!
EnsureBrowsingContextAttached
(
)
)
{
return
false
;
}
if
(
mPendingBrowsingContext
-
>
IsTop
(
)
)
{
mPendingBrowsingContext
-
>
InitSessionHistory
(
)
;
}
if
(
!
OwnerIsMozBrowserFrame
(
)
&
&
!
XRE_IsContentProcess
(
)
)
{
if
(
parentDocShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
nsIURI
*
parentURI
=
parentWin
-
>
GetDocumentURI
(
)
;
if
(
!
parentURI
)
{
return
false
;
}
nsAutoCString
specIgnoringRef
;
if
(
NS_FAILED
(
parentURI
-
>
GetSpecIgnoringRef
(
specIgnoringRef
)
)
)
{
return
false
;
}
if
(
!
(
specIgnoringRef
.
EqualsLiteral
(
"
about
:
addons
"
)
|
|
specIgnoringRef
.
EqualsLiteral
(
"
chrome
:
/
/
mozapps
/
content
/
extensions
/
aboutaddons
.
html
"
)
|
|
#
ifdef
MOZ_THUNDERBIRD
specIgnoringRef
.
EqualsLiteral
(
"
about
:
preferences
"
)
|
|
#
endif
specIgnoringRef
.
EqualsLiteral
(
"
chrome
:
/
/
browser
/
content
/
webext
-
panels
.
xhtml
"
)
)
)
{
return
false
;
}
}
if
(
!
mOwnerContent
-
>
IsXULElement
(
)
)
{
return
false
;
}
if
(
!
mOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
content
eIgnoreCase
)
)
{
return
false
;
}
}
uint32_t
chromeFlags
=
0
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentOwner
;
if
(
NS_FAILED
(
parentDocShell
-
>
GetTreeOwner
(
getter_AddRefs
(
parentOwner
)
)
)
|
|
!
parentOwner
)
{
return
false
;
}
nsCOMPtr
<
nsIAppWindow
>
window
(
do_GetInterface
(
parentOwner
)
)
;
if
(
window
&
&
NS_FAILED
(
window
-
>
GetChromeFlags
(
&
chromeFlags
)
)
)
{
return
false
;
}
AUTO_PROFILER_LABEL
(
"
nsFrameLoader
:
:
TryRemoteBrowser
:
Create
"
OTHER
)
;
MutableTabContext
context
;
nsresult
rv
=
GetNewTabContext
(
&
context
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
RefPtr
<
Element
>
ownerElement
=
mOwnerContent
;
RefPtr
<
BrowserParent
>
nextRemoteBrowser
=
mOpenWindowInfo
?
mOpenWindowInfo
-
>
GetNextRemoteBrowser
(
)
:
nullptr
;
if
(
nextRemoteBrowser
)
{
mRemoteBrowser
=
new
BrowserHost
(
nextRemoteBrowser
)
;
if
(
nextRemoteBrowser
-
>
GetOwnerElement
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Shouldn
'
t
have
an
owner
element
before
"
)
;
return
false
;
}
nextRemoteBrowser
-
>
SetOwnerElement
(
ownerElement
)
;
}
else
{
RefPtr
<
ContentParent
>
contentParent
;
if
(
mChildID
!
=
0
)
{
ContentProcessManager
*
cpm
=
ContentProcessManager
:
:
GetSingleton
(
)
;
contentParent
=
cpm
-
>
GetContentProcessById
(
ContentParentId
(
mChildID
)
)
;
}
mRemoteBrowser
=
ContentParent
:
:
CreateBrowser
(
context
ownerElement
mRemoteType
mPendingBrowsingContext
contentParent
)
;
}
if
(
!
mRemoteBrowser
)
{
return
false
;
}
MOZ_DIAGNOSTIC_ASSERT
(
mPendingBrowsingContext
=
=
mRemoteBrowser
-
>
GetBrowsingContext
(
)
)
;
mRemoteBrowser
-
>
GetBrowsingContext
(
)
-
>
Embed
(
)
;
InvokeBrowsingContextReadyCallback
(
)
;
RefPtr
<
BrowserParent
>
browserParent
=
GetBrowserParent
(
)
;
ownerElement
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
RemoteType
false
)
;
browserParent
-
>
InitRendering
(
)
;
MaybeUpdatePrimaryBrowserParent
(
eBrowserParentChanged
)
;
mChildID
=
browserParent
-
>
Manager
(
)
-
>
ChildID
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
parentDocShell
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
rootItem
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsIDOMChromeWindow
>
rootChromeWin
=
do_QueryInterface
(
rootWin
)
;
if
(
rootChromeWin
)
{
nsCOMPtr
<
nsIBrowserDOMWindow
>
browserDOMWin
;
rootChromeWin
-
>
GetBrowserDOMWindow
(
getter_AddRefs
(
browserDOMWin
)
)
;
browserParent
-
>
SetBrowserDOMWindow
(
browserDOMWin
)
;
}
if
(
mOwnerContent
-
>
IsXULElement
(
)
)
{
nsAutoString
frameName
;
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
name
frameName
)
;
if
(
nsContentUtils
:
:
IsOverridingWindowName
(
frameName
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mPendingBrowsingContext
-
>
SetName
(
frameName
)
)
;
}
if
(
mOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
allowscriptstoclose
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
Unused
<
<
browserParent
-
>
SendAllowScriptsToClose
(
)
;
}
}
ReallyLoadFrameScripts
(
)
;
InitializeBrowserAPI
(
)
;
return
true
;
}
bool
nsFrameLoader
:
:
TryRemoteBrowser
(
)
{
if
(
TryRemoteBrowserInternal
(
)
)
{
return
true
;
}
if
(
XRE_IsParentProcess
(
)
&
&
mOwnerContent
&
&
mOwnerContent
-
>
IsXULElement
(
)
)
{
MaybeNotifyCrashed
(
nullptr
ContentParentId
(
)
nullptr
)
;
}
return
false
;
}
nsIFrame
*
nsFrameLoader
:
:
GetPrimaryFrameOfOwningContent
(
)
const
{
return
mOwnerContent
?
mOwnerContent
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
Document
*
nsFrameLoader
:
:
GetOwnerDoc
(
)
const
{
return
mOwnerContent
?
mOwnerContent
-
>
OwnerDoc
(
)
:
nullptr
;
}
bool
nsFrameLoader
:
:
IsRemoteFrame
(
)
{
if
(
mIsRemoteFrame
)
{
MOZ_ASSERT
(
!
GetDocShell
(
)
"
Found
a
remote
frame
with
a
DocShell
"
)
;
return
true
;
}
return
false
;
}
RemoteBrowser
*
nsFrameLoader
:
:
GetRemoteBrowser
(
)
const
{
return
mRemoteBrowser
;
}
BrowserParent
*
nsFrameLoader
:
:
GetBrowserParent
(
)
const
{
if
(
!
mRemoteBrowser
)
{
return
nullptr
;
}
RefPtr
<
BrowserHost
>
browserHost
=
mRemoteBrowser
-
>
AsBrowserHost
(
)
;
if
(
!
browserHost
)
{
return
nullptr
;
}
return
browserHost
-
>
GetActor
(
)
;
}
BrowserBridgeChild
*
nsFrameLoader
:
:
GetBrowserBridgeChild
(
)
const
{
if
(
!
mRemoteBrowser
)
{
return
nullptr
;
}
RefPtr
<
BrowserBridgeHost
>
browserBridgeHost
=
mRemoteBrowser
-
>
AsBrowserBridgeHost
(
)
;
if
(
!
browserBridgeHost
)
{
return
nullptr
;
}
return
browserBridgeHost
-
>
GetActor
(
)
;
}
mozilla
:
:
layers
:
:
LayersId
nsFrameLoader
:
:
GetLayersId
(
)
const
{
MOZ_ASSERT
(
mIsRemoteFrame
)
;
return
mRemoteBrowser
-
>
GetLayersId
(
)
;
}
void
nsFrameLoader
:
:
ActivateRemoteFrame
(
ErrorResult
&
aRv
)
{
auto
*
browserParent
=
GetBrowserParent
(
)
;
if
(
!
browserParent
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
browserParent
-
>
Activate
(
nsFocusManager
:
:
GenerateFocusActionId
(
)
)
;
}
void
nsFrameLoader
:
:
DeactivateRemoteFrame
(
ErrorResult
&
aRv
)
{
auto
*
browserParent
=
GetBrowserParent
(
)
;
if
(
!
browserParent
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
browserParent
-
>
Deactivate
(
false
nsFocusManager
:
:
GenerateFocusActionId
(
)
)
;
}
void
nsFrameLoader
:
:
ActivateFrameEvent
(
const
nsAString
&
aType
bool
aCapture
ErrorResult
&
aRv
)
{
auto
*
browserParent
=
GetBrowserParent
(
)
;
if
(
!
browserParent
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
bool
ok
=
browserParent
-
>
SendActivateFrameEvent
(
nsString
(
aType
)
aCapture
)
;
if
(
!
ok
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
}
}
nsresult
nsFrameLoader
:
:
DoRemoteStaticClone
(
nsFrameLoader
*
aStaticCloneOf
)
{
MOZ_ASSERT
(
aStaticCloneOf
-
>
IsRemoteFrame
(
)
)
;
auto
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
if
(
!
cc
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
return
NS_ERROR_NOT_IMPLEMENTED
;
}
BrowsingContext
*
bcToClone
=
aStaticCloneOf
-
>
GetBrowsingContext
(
)
;
if
(
NS_WARN_IF
(
!
bcToClone
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
bc
)
;
cc
-
>
SendCloneDocumentTreeInto
(
bcToClone
bc
)
;
return
NS_OK
;
}
nsresult
nsFrameLoader
:
:
FinishStaticClone
(
nsFrameLoader
*
aStaticCloneOf
bool
*
aOutHasInProcessPrintCallbacks
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
A
script
blocker
should
be
on
the
stack
while
FinishStaticClone
is
run
"
)
;
if
(
NS_WARN_IF
(
IsDead
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
aStaticCloneOf
-
>
IsRemoteFrame
(
)
)
{
return
DoRemoteStaticClone
(
aStaticCloneOf
)
;
}
nsIDocShell
*
origDocShell
=
aStaticCloneOf
-
>
GetDocShell
(
)
;
NS_ENSURE_STATE
(
origDocShell
)
;
nsCOMPtr
<
Document
>
doc
=
origDocShell
-
>
GetDocument
(
)
;
NS_ENSURE_STATE
(
doc
)
;
MaybeCreateDocShell
(
)
;
RefPtr
<
nsDocShell
>
docShell
=
GetDocShell
(
)
;
NS_ENSURE_STATE
(
docShell
)
;
nsCOMPtr
<
Document
>
kungFuDeathGrip
=
docShell
-
>
GetDocument
(
)
;
Unused
<
<
kungFuDeathGrip
;
nsCOMPtr
<
nsIContentViewer
>
viewer
;
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
NS_ENSURE_STATE
(
viewer
)
;
nsCOMPtr
<
Document
>
clonedDoc
=
doc
-
>
CreateStaticClone
(
docShell
viewer
aOutHasInProcessPrintCallbacks
)
;
return
NS_OK
;
}
bool
nsFrameLoader
:
:
DoLoadMessageManagerScript
(
const
nsAString
&
aURL
bool
aRunInGlobalScope
)
{
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
return
browserParent
-
>
SendLoadRemoteScript
(
nsString
(
aURL
)
aRunInGlobalScope
)
;
}
RefPtr
<
InProcessBrowserChildMessageManager
>
browserChild
=
GetBrowserChildMessageManager
(
)
;
if
(
browserChild
)
{
browserChild
-
>
LoadFrameScript
(
aURL
aRunInGlobalScope
)
;
}
return
true
;
}
class
nsAsyncMessageToChild
:
public
nsSameProcessAsyncMessageBase
public
Runnable
{
public
:
explicit
nsAsyncMessageToChild
(
nsFrameLoader
*
aFrameLoader
)
:
nsSameProcessAsyncMessageBase
(
)
mozilla
:
:
Runnable
(
"
nsAsyncMessageToChild
"
)
mFrameLoader
(
aFrameLoader
)
{
}
NS_IMETHOD
Run
(
)
override
{
InProcessBrowserChildMessageManager
*
browserChild
=
mFrameLoader
-
>
mChildMessageManager
;
if
(
browserChild
&
&
browserChild
-
>
GetInnerManager
(
)
&
&
mFrameLoader
-
>
GetExistingDocShell
(
)
)
{
JS
:
:
Rooted
<
JSObject
*
>
kungFuDeathGrip
(
dom
:
:
RootingCx
(
)
browserChild
-
>
GetWrapper
(
)
)
;
ReceiveMessage
(
static_cast
<
EventTarget
*
>
(
browserChild
)
mFrameLoader
browserChild
-
>
GetInnerManager
(
)
)
;
}
return
NS_OK
;
}
RefPtr
<
nsFrameLoader
>
mFrameLoader
;
}
;
nsresult
nsFrameLoader
:
:
DoSendAsyncMessage
(
const
nsAString
&
aMessage
StructuredCloneData
&
aData
)
{
auto
*
browserParent
=
GetBrowserParent
(
)
;
if
(
browserParent
)
{
ClonedMessageData
data
;
ContentParent
*
cp
=
browserParent
-
>
Manager
(
)
;
if
(
!
BuildClonedMessageDataForParent
(
cp
aData
data
)
)
{
MOZ_CRASH
(
)
;
return
NS_ERROR_DOM_DATA_CLONE_ERR
;
}
if
(
browserParent
-
>
SendAsyncMessage
(
nsString
(
aMessage
)
data
)
)
{
return
NS_OK
;
}
else
{
return
NS_ERROR_UNEXPECTED
;
}
}
if
(
mChildMessageManager
)
{
RefPtr
<
nsAsyncMessageToChild
>
ev
=
new
nsAsyncMessageToChild
(
this
)
;
nsresult
rv
=
ev
-
>
Init
(
aMessage
aData
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
NS_DispatchToCurrentThread
(
ev
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
rv
;
}
return
NS_ERROR_UNEXPECTED
;
}
already_AddRefed
<
MessageSender
>
nsFrameLoader
:
:
GetMessageManager
(
)
{
EnsureMessageManager
(
)
;
return
do_AddRef
(
mMessageManager
)
;
}
nsresult
nsFrameLoader
:
:
EnsureMessageManager
(
)
{
NS_ENSURE_STATE
(
mOwnerContent
)
;
if
(
mMessageManager
)
{
return
NS_OK
;
}
if
(
!
mIsTopLevelContent
&
&
!
OwnerIsMozBrowserFrame
(
)
&
&
!
IsRemoteFrame
(
)
&
&
!
(
mOwnerContent
-
>
IsXULElement
(
)
&
&
mOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
forcemessagemanager
nsGkAtoms
:
:
_true
eCaseMatters
)
)
)
{
return
NS_OK
;
}
RefPtr
<
nsGlobalWindowOuter
>
window
=
nsGlobalWindowOuter
:
:
Cast
(
GetOwnerDoc
(
)
-
>
GetWindow
(
)
)
;
RefPtr
<
ChromeMessageBroadcaster
>
parentManager
;
if
(
window
&
&
window
-
>
IsChromeWindow
(
)
)
{
nsAutoString
messagemanagergroup
;
if
(
mOwnerContent
-
>
IsXULElement
(
)
&
&
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
messagemanagergroup
messagemanagergroup
)
)
{
parentManager
=
window
-
>
GetGroupMessageManager
(
messagemanagergroup
)
;
}
if
(
!
parentManager
)
{
parentManager
=
window
-
>
GetMessageManager
(
)
;
}
}
else
{
parentManager
=
nsFrameMessageManager
:
:
GetGlobalMessageManager
(
)
;
}
mMessageManager
=
new
ChromeMessageSender
(
parentManager
)
;
if
(
!
IsRemoteFrame
(
)
)
{
nsresult
rv
=
MaybeCreateDocShell
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
MOZ_ASSERT
(
GetDocShell
(
)
"
MaybeCreateDocShell
succeeded
but
null
docShell
"
)
;
if
(
!
GetDocShell
(
)
)
{
return
NS_ERROR_FAILURE
;
}
mChildMessageManager
=
InProcessBrowserChildMessageManager
:
:
Create
(
GetDocShell
(
)
mOwnerContent
mMessageManager
)
;
NS_ENSURE_TRUE
(
mChildMessageManager
NS_ERROR_UNEXPECTED
)
;
if
constexpr
(
SessionStoreUtils
:
:
NATIVE_LISTENER
)
{
if
(
XRE_IsParentProcess
(
)
)
{
mSessionStoreListener
=
new
TabListener
(
GetDocShell
(
)
mOwnerContent
)
;
rv
=
mSessionStoreListener
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mSessionStoreChangeListener
=
SessionStoreChangeListener
:
:
Create
(
GetExtantBrowsingContext
(
)
)
;
}
}
}
return
NS_OK
;
}
nsresult
nsFrameLoader
:
:
ReallyLoadFrameScripts
(
)
{
nsresult
rv
=
EnsureMessageManager
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
mMessageManager
)
{
mMessageManager
-
>
InitWithCallback
(
this
)
;
}
return
NS_OK
;
}
already_AddRefed
<
Element
>
nsFrameLoader
:
:
GetOwnerElement
(
)
{
return
do_AddRef
(
mOwnerContent
)
;
}
void
nsFrameLoader
:
:
SetDetachedSubdocFrame
(
nsIFrame
*
aDetachedFrame
Document
*
aContainerDoc
)
{
mDetachedSubdocFrame
=
aDetachedFrame
;
mContainerDocWhileDetached
=
aContainerDoc
;
}
nsIFrame
*
nsFrameLoader
:
:
GetDetachedSubdocFrame
(
Document
*
*
aContainerDoc
)
const
{
NS_IF_ADDREF
(
*
aContainerDoc
=
mContainerDocWhileDetached
)
;
return
mDetachedSubdocFrame
.
GetFrame
(
)
;
}
void
nsFrameLoader
:
:
ApplySandboxFlags
(
uint32_t
sandboxFlags
)
{
BrowsingContext
*
context
=
GetExtantBrowsingContext
(
)
;
if
(
!
context
)
{
MOZ_ASSERT
(
!
IsRemoteFrame
(
)
"
cannot
apply
sandbox
flags
to
an
uninitialized
"
"
initially
-
remote
frame
"
)
;
return
;
}
uint32_t
parentSandboxFlags
=
mOwnerContent
-
>
OwnerDoc
(
)
-
>
GetSandboxFlags
(
)
;
sandboxFlags
|
=
parentSandboxFlags
;
MOZ_ALWAYS_SUCCEEDS
(
context
-
>
SetSandboxFlags
(
sandboxFlags
)
)
;
}
void
nsFrameLoader
:
:
AttributeChanged
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MOZ_ASSERT
(
mObservingOwnerContent
)
;
if
(
aElement
!
=
mOwnerContent
)
{
return
;
}
if
(
aNameSpaceID
!
=
kNameSpaceID_None
|
|
(
aAttribute
!
=
TypeAttrName
(
aElement
)
&
&
aAttribute
!
=
nsGkAtoms
:
:
primary
)
)
{
return
;
}
if
(
!
GetDocShell
(
)
)
{
MaybeUpdatePrimaryBrowserParent
(
eBrowserParentChanged
)
;
return
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
GetDocShell
(
)
-
>
GetInProcessParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
!
parentItem
)
{
return
;
}
if
(
parentItem
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
;
parentItem
-
>
GetTreeOwner
(
getter_AddRefs
(
parentTreeOwner
)
)
;
if
(
!
parentTreeOwner
)
{
return
;
}
bool
is_primary
=
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
primary
nsGkAtoms
:
:
_true
eIgnoreCase
)
;
#
ifdef
MOZ_XUL
if
(
!
is_primary
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
HidePopupsInDocShell
(
GetDocShell
(
)
)
;
}
}
#
endif
parentTreeOwner
-
>
ContentShellRemoved
(
GetDocShell
(
)
)
;
if
(
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
TypeAttrName
(
aElement
)
nsGkAtoms
:
:
content
eIgnoreCase
)
)
{
parentTreeOwner
-
>
ContentShellAdded
(
GetDocShell
(
)
is_primary
)
;
}
}
void
nsFrameLoader
:
:
RequestNotifyAfterRemotePaint
(
)
{
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
Unused
<
<
browserParent
-
>
SendRequestNotifyAfterRemotePaint
(
)
;
}
}
void
nsFrameLoader
:
:
RequestUpdatePosition
(
ErrorResult
&
aRv
)
{
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
nsresult
rv
=
browserParent
-
>
UpdatePosition
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
}
already_AddRefed
<
Promise
>
nsFrameLoader
:
:
RequestTabStateFlush
(
ErrorResult
&
aRv
)
{
MOZ_DIAGNOSTIC_ASSERT
(
XRE_IsParentProcess
(
)
)
;
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetOwnerDoc
(
)
-
>
GetOwnerGlobal
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
BrowsingContext
>
context
=
GetExtantBrowsingContext
(
)
;
if
(
!
context
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
if
(
mSessionStoreListener
)
{
context
-
>
FlushSessionStore
(
)
;
mSessionStoreListener
-
>
ForceFlushFromParent
(
)
;
context
-
>
Canonical
(
)
-
>
UpdateSessionStoreSessionStorage
(
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
)
;
return
promise
.
forget
(
)
;
}
using
FlushPromise
=
ContentParent
:
:
FlushTabStatePromise
;
nsTArray
<
RefPtr
<
FlushPromise
>
>
flushPromises
;
context
-
>
Group
(
)
-
>
EachParent
(
[
&
]
(
ContentParent
*
aParent
)
{
if
(
aParent
-
>
CanSend
(
)
)
{
flushPromises
.
AppendElement
(
aParent
-
>
SendFlushTabState
(
context
)
)
;
}
}
)
;
RefPtr
<
FlushPromise
:
:
AllPromiseType
>
flushPromise
=
FlushPromise
:
:
All
(
GetCurrentSerialEventTarget
(
)
flushPromises
)
;
context
-
>
Canonical
(
)
-
>
UpdateSessionStoreSessionStorage
(
[
flushPromise
promise
]
(
)
{
flushPromise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
)
;
}
)
;
return
promise
.
forget
(
)
;
}
void
nsFrameLoader
:
:
RequestFinalTabStateFlush
(
)
{
BrowsingContext
*
context
=
GetExtantBrowsingContext
(
)
;
if
(
!
context
|
|
!
context
-
>
IsTop
(
)
)
{
return
;
}
RefPtr
<
WindowGlobalParent
>
wgp
=
context
-
>
Canonical
(
)
-
>
GetCurrentWindowGlobal
(
)
;
RefPtr
<
Element
>
embedder
=
context
-
>
GetEmbedderElement
(
)
;
if
(
mSessionStoreListener
)
{
context
-
>
FlushSessionStore
(
)
;
mSessionStoreListener
-
>
ForceFlushFromParent
(
)
;
if
(
wgp
)
{
wgp
-
>
NotifySessionStoreUpdatesComplete
(
embedder
)
;
}
return
;
}
using
FlushPromise
=
ContentParent
:
:
FlushTabStatePromise
;
nsTArray
<
RefPtr
<
FlushPromise
>
>
flushPromises
;
context
-
>
Group
(
)
-
>
EachParent
(
[
&
]
(
ContentParent
*
aParent
)
{
if
(
aParent
-
>
CanSend
(
)
)
{
flushPromises
.
AppendElement
(
aParent
-
>
SendFlushTabState
(
context
)
)
;
}
}
)
;
FlushPromise
:
:
All
(
GetCurrentSerialEventTarget
(
)
flushPromises
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
wgp
embedder
]
(
)
{
if
(
wgp
)
{
wgp
-
>
NotifySessionStoreUpdatesComplete
(
embedder
)
;
}
}
)
;
}
void
nsFrameLoader
:
:
RequestEpochUpdate
(
uint32_t
aEpoch
)
{
BrowsingContext
*
context
=
GetExtantBrowsingContext
(
)
;
if
(
context
)
{
BrowsingContext
*
top
=
context
-
>
Top
(
)
;
Unused
<
<
top
-
>
SetSessionStoreEpoch
(
aEpoch
)
;
}
if
(
mSessionStoreListener
)
{
mSessionStoreListener
-
>
SetEpoch
(
aEpoch
)
;
return
;
}
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
Unused
<
<
browserParent
-
>
SendUpdateEpoch
(
aEpoch
)
;
}
}
void
nsFrameLoader
:
:
RequestSHistoryUpdate
(
)
{
if
(
mSessionStoreListener
)
{
mSessionStoreListener
-
>
UpdateSHistoryChanges
(
)
;
return
;
}
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
Unused
<
<
browserParent
-
>
SendUpdateSHistory
(
)
;
}
}
already_AddRefed
<
Promise
>
nsFrameLoader
:
:
PrintPreview
(
nsIPrintSettings
*
aPrintSettings
BrowsingContext
*
aSourceBrowsingContext
ErrorResult
&
aRv
)
{
auto
*
ownerDoc
=
GetOwnerDoc
(
)
;
if
(
!
ownerDoc
)
{
aRv
.
ThrowNotSupportedError
(
"
No
owner
document
"
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
ownerDoc
-
>
GetOwnerGlobal
(
)
aRv
)
;
if
(
!
promise
)
{
return
nullptr
;
}
#
ifndef
NS_PRINTING
promise
-
>
MaybeRejectWithNotSupportedError
(
"
Build
does
not
support
printing
"
)
;
return
promise
.
forget
(
)
;
#
else
auto
resolve
=
[
promise
]
(
PrintPreviewResultInfo
aInfo
)
{
if
(
aInfo
.
sheetCount
(
)
>
0
)
{
PrintPreviewSuccessInfo
info
;
info
.
mSheetCount
=
aInfo
.
sheetCount
(
)
;
info
.
mTotalPageCount
=
aInfo
.
totalPageCount
(
)
;
info
.
mHasSelection
=
aInfo
.
hasSelection
(
)
;
info
.
mHasSelfSelection
=
aInfo
.
hasSelfSelection
(
)
;
info
.
mIsEmpty
=
aInfo
.
isEmpty
(
)
;
promise
-
>
MaybeResolve
(
info
)
;
}
else
{
promise
-
>
MaybeRejectWithUnknownError
(
"
Print
preview
failed
"
)
;
}
}
;
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
nsCOMPtr
<
nsIPrintSettingsService
>
printSettingsSvc
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
)
;
if
(
!
printSettingsSvc
)
{
promise
-
>
MaybeRejectWithNotSupportedError
(
"
No
nsIPrintSettingsService
"
)
;
return
promise
.
forget
(
)
;
}
embedding
:
:
PrintData
printData
;
nsresult
rv
=
printSettingsSvc
-
>
SerializeToPrintData
(
aPrintSettings
&
printData
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeReject
(
ErrorResult
(
rv
)
)
;
return
promise
.
forget
(
)
;
}
browserParent
-
>
SendPrintPreview
(
printData
aSourceBrowsingContext
)
-
>
Then
(
GetMainThreadSerialEventTarget
(
)
__func__
std
:
:
move
(
resolve
)
[
promise
]
(
const
mozilla
:
:
ipc
:
:
ResponseRejectReason
)
{
promise
-
>
MaybeRejectWithUnknownError
(
"
Print
preview
IPC
failed
"
)
;
}
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
nsGlobalWindowOuter
>
sourceWindow
;
if
(
aSourceBrowsingContext
)
{
sourceWindow
=
nsGlobalWindowOuter
:
:
Cast
(
aSourceBrowsingContext
-
>
GetDOMWindow
(
)
)
;
}
else
{
auto
*
ourDocshell
=
static_cast
<
nsDocShell
*
>
(
GetExistingDocShell
(
)
)
;
if
(
NS_WARN_IF
(
!
ourDocshell
)
)
{
promise
-
>
MaybeRejectWithNotSupportedError
(
"
No
print
preview
docShell
"
)
;
return
promise
.
forget
(
)
;
}
sourceWindow
=
nsGlobalWindowOuter
:
:
Cast
(
ourDocshell
-
>
GetWindow
(
)
)
;
}
if
(
NS_WARN_IF
(
!
sourceWindow
)
)
{
promise
-
>
MaybeRejectWithNotSupportedError
(
"
No
print
preview
source
window
"
)
;
return
promise
.
forget
(
)
;
}
nsIDocShell
*
docShellToCloneInto
=
nullptr
;
if
(
aSourceBrowsingContext
)
{
docShellToCloneInto
=
GetExistingDocShell
(
)
;
if
(
NS_WARN_IF
(
!
docShellToCloneInto
)
)
{
promise
-
>
MaybeRejectWithNotSupportedError
(
"
No
print
preview
docShell
"
)
;
return
promise
.
forget
(
)
;
}
}
ErrorResult
rv
;
sourceWindow
-
>
Print
(
aPrintSettings
nullptr
docShellToCloneInto
nsGlobalWindowOuter
:
:
IsPreview
:
:
Yes
nsGlobalWindowOuter
:
:
IsForWindowDotPrint
:
:
No
[
resolve
]
(
const
PrintPreviewResultInfo
&
aInfo
)
{
resolve
(
aInfo
)
;
}
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
promise
-
>
MaybeReject
(
std
:
:
move
(
rv
)
)
;
}
return
promise
.
forget
(
)
;
#
endif
}
void
nsFrameLoader
:
:
ExitPrintPreview
(
)
{
#
ifdef
NS_PRINTING
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
Unused
<
<
browserParent
-
>
SendExitPrintPreview
(
)
;
return
;
}
if
(
NS_WARN_IF
(
!
GetExistingDocShell
(
)
)
)
{
return
;
}
nsCOMPtr
<
nsIWebBrowserPrint
>
webBrowserPrint
=
do_GetInterface
(
ToSupports
(
GetExistingDocShell
(
)
-
>
GetWindow
(
)
)
)
;
if
(
NS_WARN_IF
(
!
webBrowserPrint
)
)
{
return
;
}
webBrowserPrint
-
>
ExitPrintPreview
(
)
;
#
endif
}
already_AddRefed
<
nsIRemoteTab
>
nsFrameLoader
:
:
GetRemoteTab
(
)
{
if
(
!
mRemoteBrowser
)
{
return
nullptr
;
}
if
(
auto
*
browserHost
=
mRemoteBrowser
-
>
AsBrowserHost
(
)
)
{
return
do_AddRef
(
browserHost
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsILoadContext
>
nsFrameLoader
:
:
LoadContext
(
)
{
return
do_AddRef
(
GetBrowsingContext
(
)
)
;
}
BrowsingContext
*
nsFrameLoader
:
:
GetBrowsingContext
(
)
{
if
(
mNotifyingCrash
)
{
if
(
mPendingBrowsingContext
&
&
mPendingBrowsingContext
-
>
EverAttached
(
)
)
{
return
mPendingBrowsingContext
;
}
return
nullptr
;
}
if
(
IsRemoteFrame
(
)
)
{
Unused
<
<
EnsureRemoteBrowser
(
)
;
}
else
if
(
mOwnerContent
)
{
Unused
<
<
MaybeCreateDocShell
(
)
;
}
return
GetExtantBrowsingContext
(
)
;
}
BrowsingContext
*
nsFrameLoader
:
:
GetExtantBrowsingContext
(
)
{
if
(
!
mPendingBrowsingContext
)
{
return
nullptr
;
}
BrowsingContext
*
browsingContext
=
nullptr
;
if
(
mRemoteBrowser
)
{
browsingContext
=
mRemoteBrowser
-
>
GetBrowsingContext
(
)
;
}
else
if
(
mDocShell
)
{
browsingContext
=
mDocShell
-
>
GetBrowsingContext
(
)
;
}
MOZ_ASSERT_IF
(
browsingContext
browsingContext
=
=
mPendingBrowsingContext
)
;
return
browsingContext
;
}
void
nsFrameLoader
:
:
InitializeBrowserAPI
(
)
{
if
(
!
OwnerIsMozBrowserFrame
(
)
)
{
return
;
}
nsresult
rv
=
EnsureMessageManager
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
mMessageManager
-
>
LoadFrameScript
(
u
"
chrome
:
/
/
global
/
content
/
BrowserElementChild
.
js
"
_ns
true
true
IgnoreErrors
(
)
)
;
nsCOMPtr
<
nsIMozBrowserFrame
>
browserFrame
=
do_QueryInterface
(
mOwnerContent
)
;
if
(
browserFrame
)
{
browserFrame
-
>
InitializeBrowserAPI
(
)
;
}
}
void
nsFrameLoader
:
:
DestroyBrowserFrameScripts
(
)
{
if
(
!
OwnerIsMozBrowserFrame
(
)
)
{
return
;
}
nsCOMPtr
<
nsIMozBrowserFrame
>
browserFrame
=
do_QueryInterface
(
mOwnerContent
)
;
if
(
browserFrame
)
{
browserFrame
-
>
DestroyBrowserFrameScripts
(
)
;
}
}
void
nsFrameLoader
:
:
StartPersistence
(
BrowsingContext
*
aContext
nsIWebBrowserPersistDocumentReceiver
*
aRecv
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
aRecv
)
;
RefPtr
<
BrowsingContext
>
context
=
aContext
?
aContext
:
GetBrowsingContext
(
)
;
if
(
!
context
|
|
!
context
-
>
IsInSubtreeOf
(
GetBrowsingContext
(
)
)
)
{
aRecv
-
>
OnError
(
NS_ERROR_NO_CONTENT
)
;
return
;
}
if
(
!
context
-
>
GetDocShell
(
)
&
&
XRE_IsParentProcess
(
)
)
{
CanonicalBrowsingContext
*
canonical
=
CanonicalBrowsingContext
:
:
Cast
(
context
)
;
if
(
!
canonical
-
>
GetCurrentWindowGlobal
(
)
)
{
aRecv
-
>
OnError
(
NS_ERROR_NO_CONTENT
)
;
return
;
}
RefPtr
<
BrowserParent
>
browserParent
=
canonical
-
>
GetCurrentWindowGlobal
(
)
-
>
GetBrowserParent
(
)
;
browserParent
-
>
StartPersistence
(
canonical
aRecv
aRv
)
;
return
;
}
nsCOMPtr
<
Document
>
foundDoc
=
context
-
>
GetDocument
(
)
;
if
(
!
foundDoc
)
{
aRecv
-
>
OnError
(
NS_ERROR_NO_CONTENT
)
;
}
else
{
nsCOMPtr
<
nsIWebBrowserPersistDocument
>
pdoc
=
new
mozilla
:
:
WebBrowserPersistLocalDocument
(
foundDoc
)
;
aRecv
-
>
OnDocumentReady
(
pdoc
)
;
}
}
void
nsFrameLoader
:
:
MaybeUpdatePrimaryBrowserParent
(
BrowserParentChange
aChange
)
{
if
(
!
mOwnerContent
|
|
!
mRemoteBrowser
)
{
return
;
}
RefPtr
<
BrowserHost
>
browserHost
=
mRemoteBrowser
-
>
AsBrowserHost
(
)
;
if
(
!
browserHost
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
mOwnerContent
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
BrowsingContext
*
browsingContext
=
docShell
-
>
GetBrowsingContext
(
)
;
if
(
!
browsingContext
-
>
IsChrome
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
parentTreeOwner
;
docShell
-
>
GetTreeOwner
(
getter_AddRefs
(
parentTreeOwner
)
)
;
if
(
!
parentTreeOwner
)
{
return
;
}
if
(
!
mObservingOwnerContent
)
{
mOwnerContent
-
>
AddMutationObserver
(
this
)
;
mObservingOwnerContent
=
true
;
}
parentTreeOwner
-
>
RemoteTabRemoved
(
browserHost
)
;
if
(
aChange
=
=
eBrowserParentChanged
)
{
bool
isPrimary
=
mOwnerContent
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
primary
nsGkAtoms
:
:
_true
eIgnoreCase
)
;
parentTreeOwner
-
>
RemoteTabAdded
(
browserHost
isPrimary
)
;
}
}
nsresult
nsFrameLoader
:
:
GetNewTabContext
(
MutableTabContext
*
aTabContext
nsIURI
*
aURI
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
mOwnerContent
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsILoadContext
>
parentContext
=
do_QueryInterface
(
docShell
)
;
NS_ENSURE_STATE
(
parentContext
)
;
MOZ_ASSERT
(
mPendingBrowsingContext
-
>
EverAttached
(
)
)
;
UIStateChangeType
showFocusRings
=
UIStateChangeType_NoChange
;
uint64_t
chromeOuterWindowID
=
0
;
Document
*
doc
=
mOwnerContent
-
>
OwnerDoc
(
)
;
if
(
doc
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
nsContentUtils
:
:
GetWindowRoot
(
doc
)
;
if
(
root
)
{
showFocusRings
=
root
-
>
ShowFocusRings
(
)
?
UIStateChangeType_Set
:
UIStateChangeType_Clear
;
nsPIDOMWindowOuter
*
outerWin
=
root
-
>
GetWindow
(
)
;
if
(
outerWin
)
{
chromeOuterWindowID
=
outerWin
-
>
WindowID
(
)
;
}
}
}
uint32_t
maxTouchPoints
=
BrowserParent
:
:
GetMaxTouchPoints
(
mOwnerContent
)
;
bool
tabContextUpdated
=
aTabContext
-
>
SetTabContext
(
chromeOuterWindowID
showFocusRings
maxTouchPoints
)
;
NS_ENSURE_STATE
(
tabContextUpdated
)
;
return
NS_OK
;
}
nsresult
nsFrameLoader
:
:
PopulateOriginContextIdsFromAttributes
(
OriginAttributes
&
aAttr
)
{
uint32_t
namespaceID
=
mOwnerContent
-
>
GetNameSpaceID
(
)
;
if
(
namespaceID
!
=
kNameSpaceID_XUL
&
&
!
OwnerIsMozBrowserFrame
(
)
)
{
return
NS_OK
;
}
nsAutoString
attributeValue
;
if
(
aAttr
.
mUserContextId
=
=
nsIScriptSecurityManager
:
:
DEFAULT_USER_CONTEXT_ID
&
&
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
usercontextid
attributeValue
)
&
&
!
attributeValue
.
IsEmpty
(
)
)
{
nsresult
rv
;
aAttr
.
mUserContextId
=
attributeValue
.
ToInteger
(
&
rv
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
aAttr
.
mGeckoViewSessionContextId
.
IsEmpty
(
)
&
&
mOwnerContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
geckoViewSessionContextId
attributeValue
)
&
&
!
attributeValue
.
IsEmpty
(
)
)
{
aAttr
.
mGeckoViewSessionContextId
=
attributeValue
;
}
return
NS_OK
;
}
ProcessMessageManager
*
nsFrameLoader
:
:
GetProcessMessageManager
(
)
const
{
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
return
browserParent
-
>
Manager
(
)
-
>
GetMessageManager
(
)
;
}
return
nullptr
;
}
;
JSObject
*
nsFrameLoader
:
:
WrapObject
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
JS
:
:
RootedObject
result
(
cx
)
;
FrameLoader_Binding
:
:
Wrap
(
cx
this
this
aGivenProto
&
result
)
;
return
result
;
}
void
nsFrameLoader
:
:
SetWillChangeProcess
(
)
{
mWillChangeProcess
=
true
;
if
(
IsRemoteFrame
(
)
)
{
if
(
auto
*
browserParent
=
GetBrowserParent
(
)
)
{
if
(
auto
*
bc
=
CanonicalBrowsingContext
:
:
Cast
(
mPendingBrowsingContext
)
;
bc
&
&
bc
-
>
EverAttached
(
)
)
{
bc
-
>
StartUnloadingHost
(
browserParent
-
>
Manager
(
)
-
>
ChildID
(
)
)
;
bc
-
>
SetCurrentBrowserParent
(
nullptr
)
;
}
Unused
<
<
browserParent
-
>
SendWillChangeProcess
(
)
;
}
else
if
(
auto
*
browserBridgeChild
=
GetBrowserBridgeChild
(
)
)
{
Unused
<
<
browserBridgeChild
-
>
SendWillChangeProcess
(
)
;
}
return
;
}
RefPtr
<
nsDocShell
>
docshell
=
GetDocShell
(
)
;
MOZ_ASSERT
(
docshell
)
;
docshell
-
>
SetWillChangeProcess
(
)
;
}
void
nsFrameLoader
:
:
MaybeNotifyCrashed
(
BrowsingContext
*
aBrowsingContext
ContentParentId
aChildID
mozilla
:
:
ipc
:
:
MessageChannel
*
aChannel
)
{
if
(
mTabProcessCrashFired
)
{
return
;
}
if
(
mPendingBrowsingContext
=
=
aBrowsingContext
)
{
mTabProcessCrashFired
=
true
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
services
:
:
GetObserverService
(
)
;
if
(
!
os
)
{
return
;
}
mNotifyingCrash
=
true
;
auto
resetNotifyCrash
=
mozilla
:
:
MakeScopeExit
(
[
&
]
{
mNotifyingCrash
=
false
;
}
)
;
os
-
>
NotifyObservers
(
ToSupports
(
this
)
"
oop
-
frameloader
-
crashed
"
nullptr
)
;
RefPtr
<
nsFrameLoaderOwner
>
owner
=
do_QueryObject
(
mOwnerContent
)
;
if
(
!
owner
)
{
return
;
}
RefPtr
<
nsFrameLoader
>
currentFrameLoader
=
owner
-
>
GetFrameLoader
(
)
;
if
(
currentFrameLoader
!
=
this
)
{
return
;
}
nsString
eventName
;
if
(
aChannel
&
&
!
aChannel
-
>
DoBuildIDsMatch
(
)
)
{
eventName
=
u
"
oop
-
browser
-
buildid
-
mismatch
"
_ns
;
}
else
{
eventName
=
u
"
oop
-
browser
-
crashed
"
_ns
;
}
FrameCrashedEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
true
;
if
(
aBrowsingContext
)
{
init
.
mBrowsingContextId
=
aBrowsingContext
-
>
Id
(
)
;
init
.
mIsTopFrame
=
aBrowsingContext
-
>
IsTop
(
)
;
init
.
mChildID
=
aChildID
;
}
RefPtr
<
FrameCrashedEvent
>
event
=
FrameCrashedEvent
:
:
Constructor
(
mOwnerContent
-
>
OwnerDoc
(
)
eventName
init
)
;
event
-
>
SetTrusted
(
true
)
;
EventDispatcher
:
:
DispatchDOMEvent
(
mOwnerContent
nullptr
event
nullptr
nullptr
)
;
}
bool
nsFrameLoader
:
:
EnsureBrowsingContextAttached
(
)
{
nsresult
rv
;
Document
*
parentDoc
=
mOwnerContent
-
>
OwnerDoc
(
)
;
MOZ_ASSERT
(
parentDoc
)
;
BrowsingContext
*
parentContext
=
parentDoc
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
parentContext
)
;
bool
usePrivateBrowsing
=
parentContext
-
>
UsePrivateBrowsing
(
)
;
bool
useRemoteSubframes
=
parentContext
-
>
UseRemoteSubframes
(
)
;
bool
useRemoteTabs
=
parentContext
-
>
UseRemoteTabs
(
)
;
OriginAttributes
attrs
;
if
(
mPendingBrowsingContext
-
>
IsContent
(
)
)
{
if
(
mPendingBrowsingContext
-
>
GetParent
(
)
)
{
MOZ_ASSERT
(
mPendingBrowsingContext
-
>
GetParent
(
)
=
=
parentContext
)
;
parentContext
-
>
GetOriginAttributes
(
attrs
)
;
}
if
(
parentContext
-
>
IsContent
(
)
&
&
!
parentDoc
-
>
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
&
&
!
OwnerIsMozBrowserFrame
(
)
)
{
OriginAttributes
docAttrs
=
parentDoc
-
>
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
;
MOZ_ASSERT
(
attrs
.
EqualsIgnoringFPD
(
docAttrs
)
)
;
attrs
.
mFirstPartyDomain
=
docAttrs
.
mFirstPartyDomain
;
}
attrs
.
SyncAttributesWithPrivateBrowsing
(
usePrivateBrowsing
)
;
rv
=
PopulateOriginContextIdsFromAttributes
(
attrs
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
if
(
OwnerIsMozBrowserFrame
(
)
)
{
if
(
mOwnerContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozprivatebrowsing
)
)
{
attrs
.
SyncAttributesWithPrivateBrowsing
(
true
)
;
usePrivateBrowsing
=
true
;
}
}
}
if
(
mPendingBrowsingContext
-
>
EverAttached
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPendingBrowsingContext
-
>
UsePrivateBrowsing
(
)
=
=
usePrivateBrowsing
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPendingBrowsingContext
-
>
UseRemoteTabs
(
)
=
=
useRemoteTabs
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPendingBrowsingContext
-
>
UseRemoteSubframes
(
)
=
=
useRemoteSubframes
)
;
return
true
;
}
rv
=
mPendingBrowsingContext
-
>
SetOriginAttributes
(
attrs
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
mPendingBrowsingContext
-
>
SetUsePrivateBrowsing
(
usePrivateBrowsing
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
mPendingBrowsingContext
-
>
SetRemoteTabs
(
useRemoteTabs
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
rv
=
mPendingBrowsingContext
-
>
SetRemoteSubframes
(
useRemoteSubframes
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
mPendingBrowsingContext
-
>
EnsureAttached
(
)
;
return
true
;
}
void
nsFrameLoader
:
:
InvokeBrowsingContextReadyCallback
(
)
{
if
(
mOpenWindowInfo
)
{
if
(
RefPtr
<
nsIBrowsingContextReadyCallback
>
callback
=
mOpenWindowInfo
-
>
BrowsingContextReadyCallback
(
)
)
{
callback
-
>
BrowsingContextReady
(
mPendingBrowsingContext
)
;
}
}
}
