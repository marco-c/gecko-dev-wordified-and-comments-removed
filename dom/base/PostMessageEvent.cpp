#
include
"
PostMessageEvent
.
h
"
#
include
"
MessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
BlobBinding
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
FileList
.
h
"
#
include
"
mozilla
/
dom
/
FileListBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePort
.
h
"
#
include
"
mozilla
/
dom
/
MessagePortBinding
.
h
"
#
include
"
mozilla
/
dom
/
PMessagePort
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneTags
.
h
"
#
include
"
mozilla
/
dom
/
UnionConversions
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsQueryObject
.
h
"
namespace
mozilla
{
namespace
dom
{
PostMessageEvent
:
:
PostMessageEvent
(
nsGlobalWindowOuter
*
aSource
const
nsAString
&
aCallerOrigin
nsGlobalWindowOuter
*
aTargetWindow
nsIPrincipal
*
aProvidedPrincipal
nsIDocument
*
aSourceDocument
bool
aTrustedCaller
)
:
Runnable
(
"
dom
:
:
PostMessageEvent
"
)
StructuredCloneHolder
(
CloningSupported
TransferringSupported
StructuredCloneScope
:
:
SameProcessSameThread
)
mSource
(
aSource
)
mCallerOrigin
(
aCallerOrigin
)
mTargetWindow
(
aTargetWindow
)
mProvidedPrincipal
(
aProvidedPrincipal
)
mSourceDocument
(
aSourceDocument
)
mTrustedCaller
(
aTrustedCaller
)
{
}
PostMessageEvent
:
:
~
PostMessageEvent
(
)
{
}
NS_IMETHODIMP
PostMessageEvent
:
:
Run
(
)
{
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
nsCOMPtr
<
nsIDocument
>
sourceDocument
;
sourceDocument
.
swap
(
mSourceDocument
)
;
RefPtr
<
nsGlobalWindowInner
>
targetWindow
;
if
(
mTargetWindow
-
>
IsClosedOrClosing
(
)
|
|
!
(
targetWindow
=
mTargetWindow
-
>
GetCurrentInnerWindowInternal
(
)
)
|
|
targetWindow
-
>
IsDying
(
)
)
return
NS_OK
;
JSAutoRealmAllowCCW
ar
(
cx
targetWindow
-
>
GetWrapper
(
)
)
;
if
(
mProvidedPrincipal
)
{
nsIPrincipal
*
targetPrin
=
targetWindow
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
targetPrin
)
)
return
NS_OK
;
if
(
!
targetPrin
-
>
Equals
(
mProvidedPrincipal
)
)
{
OriginAttributes
sourceAttrs
=
mProvidedPrincipal
-
>
OriginAttributesRef
(
)
;
OriginAttributes
targetAttrs
=
targetPrin
-
>
OriginAttributesRef
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sourceAttrs
.
mAppId
=
=
targetAttrs
.
mAppId
"
Target
and
source
should
have
the
same
mAppId
attribute
.
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sourceAttrs
.
mUserContextId
=
=
targetAttrs
.
mUserContextId
"
Target
and
source
should
have
the
same
userContextId
attribute
.
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
sourceAttrs
.
mInIsolatedMozBrowser
=
=
targetAttrs
.
mInIsolatedMozBrowser
"
Target
and
source
should
have
the
same
inIsolatedMozBrowser
attribute
.
"
)
;
if
(
!
nsContentUtils
:
:
IsSystemOrExpandedPrincipal
(
targetPrin
)
&
&
!
nsContentUtils
:
:
IsSystemOrExpandedPrincipal
(
mProvidedPrincipal
)
&
&
!
mTrustedCaller
)
{
MOZ_DIAGNOSTIC_ASSERT
(
sourceAttrs
.
mPrivateBrowsingId
=
=
targetAttrs
.
mPrivateBrowsingId
"
Target
and
source
should
have
the
same
mPrivateBrowsingId
attribute
.
"
)
;
}
nsAutoString
providedOrigin
targetOrigin
;
nsresult
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
targetPrin
targetOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
mProvidedPrincipal
providedOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
char16_t
*
params
[
]
=
{
providedOrigin
.
get
(
)
targetOrigin
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
DOM
Window
"
)
sourceDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
TargetPrincipalDoesNotMatch
"
params
ArrayLength
(
params
)
)
;
return
NS_OK
;
}
}
IgnoredErrorResult
rv
;
JS
:
:
Rooted
<
JS
:
:
Value
>
messageData
(
cx
)
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
eventTarget
=
do_QueryObject
(
targetWindow
)
;
Read
(
targetWindow
-
>
AsInner
(
)
cx
&
messageData
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
DispatchError
(
cx
targetWindow
eventTarget
)
;
return
NS_OK
;
}
RefPtr
<
MessageEvent
>
event
=
new
MessageEvent
(
eventTarget
nullptr
nullptr
)
;
Nullable
<
WindowProxyOrMessagePortOrServiceWorker
>
source
;
source
.
SetValue
(
)
.
SetAsWindowProxy
(
)
=
mSource
?
mSource
-
>
AsOuter
(
)
:
nullptr
;
Sequence
<
OwningNonNull
<
MessagePort
>
>
ports
;
if
(
!
TakeTransferredPortsAsSequence
(
ports
)
)
{
DispatchError
(
cx
targetWindow
eventTarget
)
;
return
NS_OK
;
}
event
-
>
InitMessageEvent
(
nullptr
NS_LITERAL_STRING
(
"
message
"
)
CanBubble
:
:
eNo
Cancelable
:
:
eNo
messageData
mCallerOrigin
EmptyString
(
)
source
ports
)
;
Dispatch
(
targetWindow
event
)
;
return
NS_OK
;
}
void
PostMessageEvent
:
:
DispatchError
(
JSContext
*
aCx
nsGlobalWindowInner
*
aTargetWindow
mozilla
:
:
dom
:
:
EventTarget
*
aEventTarget
)
{
RootedDictionary
<
MessageEventInit
>
init
(
aCx
)
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
init
.
mOrigin
=
mCallerOrigin
;
if
(
mSource
)
{
init
.
mSource
.
SetValue
(
)
.
SetAsWindowProxy
(
)
=
mSource
-
>
AsOuter
(
)
;
}
RefPtr
<
Event
>
event
=
MessageEvent
:
:
Constructor
(
aEventTarget
NS_LITERAL_STRING
(
"
messageerror
"
)
init
)
;
Dispatch
(
aTargetWindow
event
)
;
}
void
PostMessageEvent
:
:
Dispatch
(
nsGlobalWindowInner
*
aTargetWindow
Event
*
aEvent
)
{
RefPtr
<
nsPresContext
>
presContext
=
aTargetWindow
-
>
GetExtantDoc
(
)
-
>
GetPresContext
(
)
;
aEvent
-
>
SetTrusted
(
mTrustedCaller
)
;
WidgetEvent
*
internalEvent
=
aEvent
-
>
WidgetEventPtr
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
aTargetWindow
-
>
AsInner
(
)
presContext
internalEvent
aEvent
&
status
)
;
}
}
}
