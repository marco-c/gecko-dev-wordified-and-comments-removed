#
include
"
PostMessageEvent
.
h
"
#
include
"
MessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
BlobBinding
.
h
"
#
include
"
mozilla
/
dom
/
File
.
h
"
#
include
"
mozilla
/
dom
/
FileList
.
h
"
#
include
"
mozilla
/
dom
/
FileListBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessageEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MessagePort
.
h
"
#
include
"
mozilla
/
dom
/
MessagePortBinding
.
h
"
#
include
"
mozilla
/
dom
/
PMessagePort
.
h
"
#
include
"
mozilla
/
dom
/
StructuredCloneTags
.
h
"
#
include
"
mozilla
/
dom
/
UnionConversions
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsPresContext
.
h
"
namespace
mozilla
{
namespace
dom
{
PostMessageEvent
:
:
PostMessageEvent
(
nsGlobalWindow
*
aSource
const
nsAString
&
aCallerOrigin
nsGlobalWindow
*
aTargetWindow
nsIPrincipal
*
aProvidedPrincipal
nsIDocument
*
aSourceDocument
bool
aTrustedCaller
)
:
StructuredCloneHolder
(
CloningSupported
TransferringSupported
SameProcessSameThread
)
mSource
(
aSource
)
mCallerOrigin
(
aCallerOrigin
)
mTargetWindow
(
aTargetWindow
)
mProvidedPrincipal
(
aProvidedPrincipal
)
mSourceDocument
(
aSourceDocument
)
mTrustedCaller
(
aTrustedCaller
)
{
MOZ_COUNT_CTOR
(
PostMessageEvent
)
;
}
PostMessageEvent
:
:
~
PostMessageEvent
(
)
{
MOZ_COUNT_DTOR
(
PostMessageEvent
)
;
}
NS_IMETHODIMP
PostMessageEvent
:
:
Run
(
)
{
MOZ_ASSERT
(
mTargetWindow
-
>
IsOuterWindow
(
)
"
should
have
been
passed
an
outer
window
!
"
)
;
MOZ_ASSERT
(
!
mSource
|
|
mSource
-
>
IsOuterWindow
(
)
"
should
have
been
passed
an
outer
window
!
"
)
;
AutoJSAPI
jsapi
;
jsapi
.
Init
(
)
;
JSContext
*
cx
=
jsapi
.
cx
(
)
;
nsCOMPtr
<
nsIDocument
>
sourceDocument
;
sourceDocument
.
swap
(
mSourceDocument
)
;
RefPtr
<
nsGlobalWindow
>
targetWindow
;
if
(
mTargetWindow
-
>
IsClosedOrClosing
(
)
|
|
!
(
targetWindow
=
mTargetWindow
-
>
GetCurrentInnerWindowInternal
(
)
)
|
|
targetWindow
-
>
IsClosedOrClosing
(
)
)
return
NS_OK
;
MOZ_ASSERT
(
targetWindow
-
>
IsInnerWindow
(
)
"
we
ordered
an
inner
window
!
"
)
;
JSAutoCompartment
ac
(
cx
targetWindow
-
>
GetWrapperPreserveColor
(
)
)
;
if
(
mProvidedPrincipal
)
{
nsIPrincipal
*
targetPrin
=
targetWindow
-
>
GetPrincipal
(
)
;
if
(
NS_WARN_IF
(
!
targetPrin
)
)
return
NS_OK
;
if
(
!
targetPrin
-
>
Equals
(
mProvidedPrincipal
)
)
{
nsAutoString
providedOrigin
targetOrigin
;
nsresult
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
targetPrin
targetOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
nsContentUtils
:
:
GetUTFOrigin
(
mProvidedPrincipal
providedOrigin
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
const
char16_t
*
params
[
]
=
{
providedOrigin
.
get
(
)
targetOrigin
.
get
(
)
}
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
DOM
Window
"
)
sourceDocument
nsContentUtils
:
:
eDOM_PROPERTIES
"
TargetPrincipalDoesNotMatch
"
params
ArrayLength
(
params
)
)
;
return
NS_OK
;
}
}
ErrorResult
rv
;
JS
:
:
Rooted
<
JS
:
:
Value
>
messageData
(
cx
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
targetWindow
-
>
AsInner
(
)
;
Read
(
window
cx
&
messageData
rv
)
;
if
(
NS_WARN_IF
(
rv
.
Failed
(
)
)
)
{
return
rv
.
StealNSResult
(
)
;
}
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
eventTarget
=
do_QueryObject
(
targetWindow
)
;
RefPtr
<
MessageEvent
>
event
=
new
MessageEvent
(
eventTarget
nullptr
nullptr
)
;
Nullable
<
WindowProxyOrMessagePort
>
source
;
source
.
SetValue
(
)
.
SetAsWindowProxy
(
)
=
mSource
?
mSource
-
>
AsOuter
(
)
:
nullptr
;
event
-
>
InitMessageEvent
(
nullptr
NS_LITERAL_STRING
(
"
message
"
)
false
false
messageData
mCallerOrigin
EmptyString
(
)
source
nullptr
)
;
nsTArray
<
RefPtr
<
MessagePort
>
>
ports
=
TakeTransferredPorts
(
)
;
event
-
>
SetPorts
(
new
MessagePortList
(
static_cast
<
dom
:
:
Event
*
>
(
event
.
get
(
)
)
ports
)
)
;
nsIPresShell
*
shell
=
targetWindow
-
>
GetExtantDoc
(
)
-
>
GetShell
(
)
;
RefPtr
<
nsPresContext
>
presContext
;
if
(
shell
)
presContext
=
shell
-
>
GetPresContext
(
)
;
event
-
>
SetTrusted
(
mTrustedCaller
)
;
WidgetEvent
*
internalEvent
=
event
-
>
GetInternalNSEvent
(
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
window
presContext
internalEvent
static_cast
<
dom
:
:
Event
*
>
(
event
.
get
(
)
)
&
status
)
;
return
NS_OK
;
}
}
}
