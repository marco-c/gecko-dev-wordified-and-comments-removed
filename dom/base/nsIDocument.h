#
ifndef
nsIDocument_h___
#
define
nsIDocument_h___
#
include
"
jsfriendapi
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPropertyTable
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
mozilla
/
UseCounter
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsContentListDeclarations
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
DispatcherTrait
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
StyleBackendType
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
bitset
>
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
dom
/
DocumentBinding
.
h
"
#
else
namespace
mozilla
{
namespace
dom
{
class
ElementCreationOptionsOrString
;
}
}
#
endif
class
gfxUserFontSet
;
class
imgIRequest
;
class
nsBindingManager
;
class
nsCachableElementsByNameNodeList
;
class
nsIDocShell
;
class
nsDocShell
;
class
nsDOMNavigationTiming
;
class
nsDOMStyleSheetSetList
;
class
nsFrameLoader
;
class
nsGlobalWindowInner
;
class
nsHTMLCSSStyleSheet
;
class
nsHTMLDocument
;
class
nsHTMLStyleSheet
;
class
nsGenericHTMLElement
;
class
nsAtom
;
class
nsIBFCacheEntry
;
class
nsIChannel
;
class
nsIContent
;
class
nsIContentSink
;
class
nsIDocShell
;
class
nsIDocShellTreeItem
;
class
nsIDocumentEncoder
;
class
nsIDocumentObserver
;
class
nsIDOMDocument
;
class
nsIDOMDocumentType
;
class
nsIDOMElement
;
class
nsIDOMNodeList
;
class
nsIHTMLCollection
;
class
nsILayoutHistoryState
;
class
nsILoadContext
;
class
nsIObjectLoadingContent
;
class
nsIObserver
;
class
nsIPrincipal
;
class
nsIRequest
;
class
nsIRunnable
;
class
nsIStreamListener
;
class
nsIStructuredCloneContainer
;
class
nsIURI
;
class
nsIVariant
;
class
nsViewManager
;
class
nsPresContext
;
class
nsRange
;
class
nsSMILAnimationController
;
class
nsSVGElement
;
class
nsTextNode
;
class
nsWindowSizes
;
class
nsDOMCaretPosition
;
class
nsViewportInfo
;
class
nsIGlobalObject
;
struct
nsCSSSelectorList
;
namespace
mozilla
{
class
AbstractThread
;
class
CSSStyleSheet
;
class
Encoding
;
class
ErrorResult
;
class
EventStates
;
class
PendingAnimationTracker
;
class
StyleSetHandle
;
template
<
typename
>
class
OwningNonNull
;
struct
URLExtraData
;
namespace
css
{
class
Loader
;
class
ImageLoader
;
class
Rule
;
}
namespace
dom
{
class
AboutCapabilities
;
class
Animation
;
class
AnonymousContent
;
class
Attr
;
class
BoxObject
;
class
ClientInfo
;
class
ClientState
;
class
CDATASection
;
class
Comment
;
struct
CustomElementDefinition
;
class
DocGroup
;
class
DocumentFragment
;
class
DocumentTimeline
;
class
DocumentType
;
class
DOMImplementation
;
class
DOMIntersectionObserver
;
class
DOMStringList
;
class
Element
;
struct
ElementCreationOptions
;
class
Event
;
class
EventTarget
;
class
FontFaceSet
;
class
FrameRequestCallback
;
struct
FullscreenRequest
;
class
ImageTracker
;
class
HTMLBodyElement
;
struct
LifecycleCallbackArgs
;
class
Link
;
class
Location
;
class
MediaQueryList
;
class
GlobalObject
;
class
NodeFilter
;
class
NodeIterator
;
enum
class
OrientationType
:
uint8_t
;
class
ProcessingInstruction
;
class
Promise
;
class
ScriptLoader
;
class
Selection
;
class
ServiceWorkerDescriptor
;
class
StyleSheetList
;
class
SVGDocument
;
class
SVGSVGElement
;
class
Touch
;
class
TouchList
;
class
TreeWalker
;
class
XPathEvaluator
;
class
XPathExpression
;
class
XPathNSResolver
;
class
XPathResult
;
class
XULDocument
;
template
<
typename
>
class
Sequence
;
template
<
typename
typename
>
class
CallbackObjectHolder
;
enum
class
CallerType
:
uint32_t
;
}
}
#
define
NS_IDOCUMENT_IID
\
{
0xce1f7627
0x7109
0x4977
\
{
0xba
0x77
0x49
0x0f
0xfd
0xe0
0x7a
0xaa
}
}
enum
DocumentFlavor
{
DocumentFlavorLegacyGuess
DocumentFlavorHTML
DocumentFlavorSVG
DocumentFlavorPlain
}
;
#
define
NS_DOCUMENT_STATE_RTL_LOCALE
NS_DEFINE_EVENT_STATE_MACRO
(
0
)
#
define
NS_DOCUMENT_STATE_WINDOW_INACTIVE
NS_DEFINE_EVENT_STATE_MACRO
(
1
)
class
nsContentList
;
class
nsDocumentOnStack
;
class
nsDocHeaderData
{
public
:
nsDocHeaderData
(
nsAtom
*
aField
const
nsAString
&
aData
)
:
mField
(
aField
)
mData
(
aData
)
mNext
(
nullptr
)
{
}
~
nsDocHeaderData
(
void
)
{
delete
mNext
;
}
RefPtr
<
nsAtom
>
mField
;
nsString
mData
;
nsDocHeaderData
*
mNext
;
}
;
class
PrincipalFlashClassifier
;
class
nsIDocument
:
public
nsINode
public
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
public
mozilla
:
:
dom
:
:
DispatcherTrait
{
typedef
mozilla
:
:
dom
:
:
GlobalObject
GlobalObject
;
protected
:
using
Encoding
=
mozilla
:
:
Encoding
;
template
<
typename
T
>
using
NotNull
=
mozilla
:
:
NotNull
<
T
>
;
public
:
typedef
mozilla
:
:
net
:
:
ReferrerPolicy
ReferrerPolicyEnum
;
typedef
mozilla
:
:
dom
:
:
Element
Element
;
typedef
mozilla
:
:
dom
:
:
FullscreenRequest
FullscreenRequest
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_IDOCUMENT_IID
)
#
ifdef
MOZILLA_INTERNAL_API
nsIDocument
(
)
;
#
endif
class
MOZ_RAII
PageUnloadingEventTimeStamp
{
nsCOMPtr
<
nsIDocument
>
mDocument
;
bool
mSet
;
public
:
explicit
PageUnloadingEventTimeStamp
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
mSet
(
false
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
mDocument
-
>
mPageUnloadingEventTimeStamp
.
IsNull
(
)
)
{
mDocument
-
>
SetPageUnloadingEventTimeStamp
(
)
;
mSet
=
true
;
}
}
~
PageUnloadingEventTimeStamp
(
)
{
if
(
mSet
)
{
mDocument
-
>
CleanUnloadEventsTimeStamp
(
)
;
}
}
}
;
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
=
nullptr
)
=
0
;
virtual
void
StopDocumentLoad
(
)
=
0
;
virtual
void
SetSuppressParserErrorElement
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorElement
(
)
{
return
false
;
}
virtual
void
SetSuppressParserErrorConsoleMessages
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorConsoleMessages
(
)
{
return
false
;
}
void
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
;
nsIURI
*
GetDocumentURI
(
)
const
{
return
mDocumentURI
;
}
nsIURI
*
GetOriginalURI
(
)
const
{
return
mOriginalURI
;
}
void
SetDocumentURI
(
nsIURI
*
aURI
)
;
void
SetChromeXHRDocURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocURI
=
aURI
;
}
void
SetChromeXHRDocBaseURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocBaseURI
=
aURI
;
}
void
ApplySettingsFromCSP
(
bool
aSpeculative
)
;
already_AddRefed
<
nsIParser
>
CreatorParserOrNull
(
)
{
nsCOMPtr
<
nsIParser
>
parser
=
mParser
;
return
parser
.
forget
(
)
;
}
ReferrerPolicyEnum
GetReferrerPolicy
(
)
const
{
return
mReferrerPolicy
;
}
uint32_t
ReferrerPolicy
(
)
const
{
return
GetReferrerPolicy
(
)
;
}
bool
GetBlockAllMixedContent
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mBlockAllMixedContentPreloads
;
}
return
mBlockAllMixedContent
;
}
bool
GetUpgradeInsecureRequests
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mUpgradeInsecurePreloads
;
}
return
mUpgradeInsecureRequests
;
}
void
SetReferrer
(
const
nsACString
&
aReferrer
)
{
mReferrer
=
aReferrer
;
}
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
const
nsTArray
<
nsCOMPtr
<
nsIPrincipal
>
>
&
AncestorPrincipals
(
)
const
{
return
mAncestorPrincipals
;
}
const
nsTArray
<
uint64_t
>
&
AncestorOuterWindowIDs
(
)
const
{
return
mAncestorOuterWindowIDs
;
}
already_AddRefed
<
nsILoadGroup
>
GetDocumentLoadGroup
(
)
const
{
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
return
group
.
forget
(
)
;
}
nsIURI
*
GetFallbackBaseURI
(
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
)
{
return
mParentDocument
-
>
GetDocBaseURI
(
)
;
}
return
mDocumentURI
;
}
nsIURI
*
GetDocBaseURI
(
)
const
{
if
(
mDocumentBaseURI
)
{
return
mDocumentBaseURI
;
}
return
GetFallbackBaseURI
(
)
;
}
already_AddRefed
<
nsIURI
>
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
=
false
)
const
final
;
void
SetBaseURI
(
nsIURI
*
aURI
)
;
mozilla
:
:
URLExtraData
*
DefaultStyleAttrURLData
(
)
;
void
GetBaseTarget
(
nsAString
&
aBaseTarget
)
const
{
aBaseTarget
=
mBaseTarget
;
}
void
SetBaseTarget
(
const
nsString
&
aBaseTarget
)
{
mBaseTarget
=
aBaseTarget
;
}
NotNull
<
const
Encoding
*
>
GetDocumentCharacterSet
(
)
const
{
return
mCharacterSet
;
}
virtual
void
SetDocumentCharacterSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
=
0
;
int32_t
GetDocumentCharacterSetSource
(
)
const
{
return
mCharacterSetSource
;
}
void
SetDocumentCharacterSetSource
(
int32_t
aCharsetSource
)
{
mCharacterSetSource
=
aCharsetSource
;
}
typedef
bool
(
*
IDTargetObserver
)
(
Element
*
aOldElement
Element
*
aNewelement
void
*
aData
)
;
Element
*
AddIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
;
void
RemoveIDTargetObserver
(
nsAtom
*
aID
IDTargetObserver
aObserver
void
*
aData
bool
aForImage
)
;
inline
bool
CheckGetElementByIdArg
(
const
nsAString
&
aId
)
{
if
(
aId
.
IsEmpty
(
)
)
{
ReportEmptyGetElementByIdArg
(
)
;
return
false
;
}
return
true
;
}
void
ReportEmptyGetElementByIdArg
(
)
;
void
GetContentType
(
nsAString
&
aContentType
)
;
virtual
void
SetContentType
(
const
nsAString
&
aContentType
)
=
0
;
void
GetContentLanguage
(
nsAString
&
aContentLanguage
)
const
{
CopyASCIItoUTF16
(
mContentLanguage
aContentLanguage
)
;
}
bool
GetBidiEnabled
(
)
const
{
return
mBidiEnabled
;
}
void
SetBidiEnabled
(
)
{
mBidiEnabled
=
true
;
}
bool
GetMathMLEnabled
(
)
const
{
return
mMathMLEnabled
;
}
void
SetMathMLEnabled
(
)
{
mMathMLEnabled
=
true
;
}
bool
IsInitialDocument
(
)
const
{
return
mIsInitialDocumentInWindow
;
}
void
SetIsInitialDocument
(
bool
aIsInitialDocument
)
{
mIsInitialDocumentInWindow
=
aIsInitialDocument
;
}
void
IgnoreDocGroupMismatches
(
)
{
mIgnoreDocGroupMismatches
=
true
;
}
uint32_t
GetBidiOptions
(
)
const
{
return
mBidiOptions
;
}
void
SetBidiOptions
(
uint32_t
aBidiOptions
)
{
mBidiOptions
=
aBidiOptions
;
}
bool
GetHasMixedActiveContentLoaded
(
)
{
return
mHasMixedActiveContentLoaded
;
}
void
SetHasMixedActiveContentLoaded
(
bool
aHasMixedActiveContentLoaded
)
{
mHasMixedActiveContentLoaded
=
aHasMixedActiveContentLoaded
;
}
bool
GetHasMixedActiveContentBlocked
(
)
{
return
mHasMixedActiveContentBlocked
;
}
void
SetHasMixedActiveContentBlocked
(
bool
aHasMixedActiveContentBlocked
)
{
mHasMixedActiveContentBlocked
=
aHasMixedActiveContentBlocked
;
}
bool
GetHasMixedDisplayContentLoaded
(
)
{
return
mHasMixedDisplayContentLoaded
;
}
void
SetHasMixedDisplayContentLoaded
(
bool
aHasMixedDisplayContentLoaded
)
{
mHasMixedDisplayContentLoaded
=
aHasMixedDisplayContentLoaded
;
}
bool
GetHasMixedDisplayContentBlocked
(
)
{
return
mHasMixedDisplayContentBlocked
;
}
void
SetHasReferrerPolicyCSP
(
bool
aHasReferrerPolicyCSP
)
{
mHasReferrerPolicyCSP
=
aHasReferrerPolicyCSP
;
}
void
SetHasMixedDisplayContentBlocked
(
bool
aHasMixedDisplayContentBlocked
)
{
mHasMixedDisplayContentBlocked
=
aHasMixedDisplayContentBlocked
;
}
void
SetHasMixedContentObjectSubrequest
(
bool
aHasMixedContentObjectSubrequest
)
{
mHasMixedContentObjectSubrequest
=
aHasMixedContentObjectSubrequest
;
}
void
SetHasCSP
(
bool
aHasCSP
)
{
mHasCSP
=
aHasCSP
;
}
void
SetHasUnsafeInlineCSP
(
bool
aHasUnsafeInlineCSP
)
{
mHasUnsafeInlineCSP
=
aHasUnsafeInlineCSP
;
}
void
SetHasUnsafeEvalCSP
(
bool
aHasUnsafeEvalCSP
)
{
mHasUnsafeEvalCSP
=
aHasUnsafeEvalCSP
;
}
bool
GetHasTrackingContentBlocked
(
)
{
return
mHasTrackingContentBlocked
;
}
void
SetHasTrackingContentBlocked
(
bool
aHasTrackingContentBlocked
)
{
mHasTrackingContentBlocked
=
aHasTrackingContentBlocked
;
}
bool
GetHasTrackingContentLoaded
(
)
{
return
mHasTrackingContentLoaded
;
}
void
SetHasTrackingContentLoaded
(
bool
aHasTrackingContentLoaded
)
{
mHasTrackingContentLoaded
=
aHasTrackingContentLoaded
;
}
uint32_t
GetSandboxFlags
(
)
const
{
return
mSandboxFlags
;
}
void
GetSandboxFlagsAsString
(
nsAString
&
aFlags
)
;
void
SetSandboxFlags
(
uint32_t
sandboxFlags
)
{
mSandboxFlags
=
sandboxFlags
;
}
void
StartBufferingCSPViolations
(
)
{
MOZ_ASSERT
(
!
mBufferingCSPViolations
)
;
mBufferingCSPViolations
=
true
;
}
void
StopBufferingCSPViolations
(
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
&
aResult
)
{
MOZ_ASSERT
(
mBufferingCSPViolations
)
;
mBufferingCSPViolations
=
false
;
aResult
.
SwapElements
(
mBufferedCSPViolations
)
;
mBufferedCSPViolations
.
Clear
(
)
;
}
bool
ShouldBufferCSPViolations
(
)
const
{
return
mBufferingCSPViolations
;
}
void
BufferCSPViolation
(
nsIRunnable
*
aReportingRunnable
)
{
MOZ_ASSERT
(
mBufferingCSPViolations
)
;
mBufferedCSPViolations
.
AppendElement
(
aReportingRunnable
mozilla
:
:
fallible
)
;
}
void
DisableEncodingMenu
(
)
{
mEncodingMenuDisabled
=
true
;
}
void
GetHeaderData
(
nsAtom
*
aHeaderField
nsAString
&
aData
)
const
;
void
SetHeaderData
(
nsAtom
*
aheaderField
const
nsAString
&
aData
)
;
virtual
already_AddRefed
<
nsIPresShell
>
CreateShell
(
nsPresContext
*
aContext
nsViewManager
*
aViewManager
mozilla
:
:
StyleSetHandle
aStyleSet
)
=
0
;
virtual
void
DeleteShell
(
)
=
0
;
nsIPresShell
*
GetShell
(
)
const
{
return
GetBFCacheEntry
(
)
?
nullptr
:
mPresShell
;
}
nsIPresShell
*
GetObservingShell
(
)
const
{
return
mPresShell
&
&
mPresShell
-
>
IsObservingDocument
(
)
?
mPresShell
:
nullptr
;
}
bool
IsSafeToFlush
(
)
const
;
nsPresContext
*
GetPresContext
(
)
const
{
nsIPresShell
*
shell
=
GetShell
(
)
;
return
shell
?
shell
-
>
GetPresContext
(
)
:
nullptr
;
}
bool
HasShellOrBFCacheEntry
(
)
const
{
return
mPresShell
|
|
mBFCacheEntry
;
}
void
DisallowBFCaching
(
)
{
NS_ASSERTION
(
!
mBFCacheEntry
"
We
'
re
already
in
the
bfcache
!
"
)
;
mBFCacheDisallowed
=
true
;
}
bool
IsBFCachingAllowed
(
)
const
{
return
!
mBFCacheDisallowed
;
}
void
SetBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
{
NS_ASSERTION
(
IsBFCachingAllowed
(
)
|
|
!
aEntry
"
You
should
have
checked
!
"
)
;
mBFCacheEntry
=
aEntry
;
}
nsIBFCacheEntry
*
GetBFCacheEntry
(
)
const
{
return
mBFCacheEntry
;
}
nsIDocument
*
GetParentDocument
(
)
const
{
return
mParentDocument
;
}
void
SetParentDocument
(
nsIDocument
*
aParent
)
{
mParentDocument
=
aParent
;
if
(
aParent
)
{
mIgnoreDocGroupMismatches
=
aParent
-
>
mIgnoreDocGroupMismatches
;
}
}
bool
GetAllowPlugins
(
)
;
nsresult
SetSubDocumentFor
(
Element
*
aContent
nsIDocument
*
aSubDoc
)
;
nsIDocument
*
GetSubDocumentFor
(
nsIContent
*
aContent
)
const
;
Element
*
FindContentForSubDocument
(
nsIDocument
*
aDocument
)
const
;
mozilla
:
:
dom
:
:
DocumentType
*
GetDoctype
(
)
const
;
Element
*
GetRootElement
(
)
const
;
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
mozilla
:
:
ErrorResult
&
aRv
)
;
virtual
nsIContent
*
GetUnfocusedKeyEventTarget
(
)
;
virtual
nsViewportInfo
GetViewportInfo
(
const
mozilla
:
:
ScreenIntSize
&
aDisplaySize
)
=
0
;
virtual
bool
WillIgnoreCharsetOverride
(
)
{
return
true
;
}
bool
IsSrcdocDocument
(
)
const
{
return
mIsSrcdocDocument
;
}
void
SetIsSrcdocDocument
(
bool
aIsSrcdocDocument
)
{
mIsSrcdocDocument
=
aIsSrcdocDocument
;
}
nsresult
GetSrcdocData
(
nsAString
&
aSrcdocData
)
;
bool
DidDocumentOpen
(
)
{
return
mDidDocumentOpen
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
AnonymousContent
>
InsertAnonymousContent
(
mozilla
:
:
dom
:
:
Element
&
aElement
mozilla
:
:
ErrorResult
&
aError
)
;
void
RemoveAnonymousContent
(
mozilla
:
:
dom
:
:
AnonymousContent
&
aContent
mozilla
:
:
ErrorResult
&
aError
)
;
Element
*
GetAnonRootIfInAnonymousContentContainer
(
nsINode
*
aNode
)
const
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
AnonymousContent
>
>
&
GetAnonymousContents
(
)
{
return
mAnonymousContents
;
}
mozilla
:
:
TimeStamp
GetPageUnloadingEventTimeStamp
(
)
const
{
if
(
!
mParentDocument
)
{
return
mPageUnloadingEventTimeStamp
;
}
mozilla
:
:
TimeStamp
parentTimeStamp
(
mParentDocument
-
>
GetPageUnloadingEventTimeStamp
(
)
)
;
if
(
parentTimeStamp
.
IsNull
(
)
)
{
return
mPageUnloadingEventTimeStamp
;
}
if
(
!
mPageUnloadingEventTimeStamp
|
|
parentTimeStamp
<
mPageUnloadingEventTimeStamp
)
{
return
parentTimeStamp
;
}
return
mPageUnloadingEventTimeStamp
;
}
virtual
void
NotifyLayerManagerRecreated
(
)
=
0
;
void
ScheduleSVGForPresAttrEvaluation
(
nsSVGElement
*
aSVG
)
{
mLazySVGPresElements
.
PutEntry
(
aSVG
)
;
}
void
UnscheduleSVGForPresAttrEvaluation
(
nsSVGElement
*
aSVG
)
{
mLazySVGPresElements
.
RemoveEntry
(
aSVG
)
;
}
void
ResolveScheduledSVGPresAttrs
(
)
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
GetClientInfo
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientState
>
GetClientState
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
GetController
(
)
const
;
protected
:
virtual
Element
*
GetRootElementInternal
(
)
const
=
0
;
void
DoNotifyPossibleTitleChange
(
)
;
void
SetPageUnloadingEventTimeStamp
(
)
{
MOZ_ASSERT
(
!
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
;
}
void
CleanUnloadEventsTimeStamp
(
)
{
MOZ_ASSERT
(
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
mozilla
:
:
TimeStamp
(
)
;
}
void
ClearStaleServoData
(
)
;
private
:
class
SelectorCacheKey
{
public
:
explicit
SelectorCacheKey
(
const
nsAString
&
aString
)
:
mKey
(
aString
)
{
MOZ_COUNT_CTOR
(
SelectorCacheKey
)
;
}
nsString
mKey
;
nsExpirationState
mState
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mState
;
}
~
SelectorCacheKey
(
)
{
MOZ_COUNT_DTOR
(
SelectorCacheKey
)
;
}
}
;
class
SelectorCacheKeyDeleter
;
public
:
class
SelectorCache
final
:
public
nsExpirationTracker
<
SelectorCacheKey
4
>
{
public
:
class
SelectorList
{
public
:
SelectorList
(
)
:
mIsServo
(
false
)
mGecko
(
nullptr
)
{
}
SelectorList
(
SelectorList
&
&
aOther
)
{
*
this
=
mozilla
:
:
Move
(
aOther
)
;
}
SelectorList
&
operator
=
(
SelectorList
&
&
aOther
)
{
Reset
(
)
;
mIsServo
=
aOther
.
mIsServo
;
if
(
mIsServo
)
{
mServo
=
aOther
.
mServo
;
aOther
.
mServo
=
nullptr
;
}
else
{
#
ifdef
MOZ_OLD_STYLE
mGecko
=
aOther
.
mGecko
;
aOther
.
mGecko
=
nullptr
;
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
return
*
this
;
}
SelectorList
(
const
SelectorList
&
aOther
)
=
delete
;
explicit
SelectorList
(
mozilla
:
:
UniquePtr
<
RawServoSelectorList
>
&
&
aList
)
:
mIsServo
(
true
)
mServo
(
aList
.
release
(
)
)
{
}
#
ifdef
MOZ_OLD_STYLE
explicit
SelectorList
(
mozilla
:
:
UniquePtr
<
nsCSSSelectorList
>
&
&
aList
)
:
mIsServo
(
false
)
mGecko
(
aList
.
release
(
)
)
{
}
#
endif
~
SelectorList
(
)
{
Reset
(
)
;
}
bool
IsServo
(
)
const
{
return
mIsServo
;
}
bool
IsGecko
(
)
const
{
return
!
IsServo
(
)
;
}
explicit
operator
bool
(
)
const
{
return
IsServo
(
)
?
!
!
AsServo
(
)
:
!
!
AsGecko
(
)
;
}
nsCSSSelectorList
*
AsGecko
(
)
const
{
MOZ_ASSERT
(
IsGecko
(
)
)
;
return
mGecko
;
}
RawServoSelectorList
*
AsServo
(
)
const
{
MOZ_ASSERT
(
IsServo
(
)
)
;
return
mServo
;
}
private
:
void
Reset
(
)
;
bool
mIsServo
;
union
{
nsCSSSelectorList
*
mGecko
;
RawServoSelectorList
*
mServo
;
}
;
}
;
explicit
SelectorCache
(
nsIEventTarget
*
aEventTarget
)
;
void
CacheList
(
const
nsAString
&
aSelector
mozilla
:
:
UniquePtr
<
nsCSSSelectorList
>
&
&
aSelectorList
)
;
void
CacheList
(
const
nsAString
&
aSelector
mozilla
:
:
UniquePtr
<
RawServoSelectorList
>
&
&
aSelectorList
)
;
virtual
void
NotifyExpired
(
SelectorCacheKey
*
aSelector
)
override
;
SelectorList
*
GetList
(
const
nsAString
&
aSelector
)
{
return
mTable
.
GetValue
(
aSelector
)
;
}
~
SelectorCache
(
)
;
private
:
nsDataHashtable
<
nsStringHashKey
SelectorList
>
mTable
;
}
;
SelectorCache
&
GetSelectorCache
(
mozilla
:
:
StyleBackendType
aBackendType
)
{
mozilla
:
:
UniquePtr
<
SelectorCache
>
&
cache
=
aBackendType
=
=
mozilla
:
:
StyleBackendType
:
:
Servo
?
mServoSelectorCache
:
mGeckoSelectorCache
;
if
(
!
cache
)
{
cache
.
reset
(
new
SelectorCache
(
EventTargetFor
(
mozilla
:
:
TaskCategory
:
:
Other
)
)
)
;
}
return
*
cache
;
}
Element
*
GetHtmlElement
(
)
const
;
Element
*
GetHtmlChildElement
(
nsAtom
*
aTag
)
;
mozilla
:
:
dom
:
:
HTMLBodyElement
*
GetBodyElement
(
)
;
Element
*
GetHeadElement
(
)
{
return
GetHtmlChildElement
(
nsGkAtoms
:
:
head
)
;
}
nsGenericHTMLElement
*
GetBody
(
)
;
void
SetBody
(
nsGenericHTMLElement
*
aBody
mozilla
:
:
ErrorResult
&
rv
)
;
void
EnsureOnDemandBuiltInUASheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
mozilla
:
:
dom
:
:
StyleSheetList
*
StyleSheets
(
)
{
return
&
DocumentOrShadowRoot
:
:
EnsureDOMStyleSheets
(
)
;
}
void
InsertStyleSheetAt
(
mozilla
:
:
StyleSheet
*
aSheet
size_t
aIndex
)
;
void
UpdateStyleSheets
(
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aOldSheets
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aNewSheets
)
;
void
AddStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
RemoveStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
SetStyleSheetApplicableState
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aApplicable
)
;
enum
additionalSheetType
{
eAgentSheet
eUserSheet
eAuthorSheet
AdditionalSheetTypeCount
}
;
nsresult
LoadAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
;
nsresult
AddAdditionalStyleSheet
(
additionalSheetType
aType
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
RemoveAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
sheetURI
)
;
mozilla
:
:
StyleSheet
*
GetFirstAdditionalAuthorSheet
(
)
{
return
mAdditionalSheets
[
eAuthorSheet
]
.
SafeElementAt
(
0
)
;
}
template
<
typename
T
>
size_t
FindDocStyleSheetInsertionPoint
(
const
nsTArray
<
T
>
&
aDocSheets
const
mozilla
:
:
StyleSheet
&
aSheet
)
;
mozilla
:
:
css
:
:
Loader
*
CSSLoader
(
)
const
{
return
mCSSLoader
;
}
mozilla
:
:
StyleBackendType
GetStyleBackendType
(
)
const
{
MOZ_ASSERT
(
mStyleBackendType
!
=
mozilla
:
:
StyleBackendType
:
:
None
"
Not
initialized
yet
"
)
;
return
mStyleBackendType
;
}
void
UpdateStyleBackendType
(
)
;
bool
IsStyledByServo
(
)
const
{
return
GetStyleBackendType
(
)
=
=
mozilla
:
:
StyleBackendType
:
:
Servo
;
}
mozilla
:
:
css
:
:
ImageLoader
*
StyleImageLoader
(
)
const
{
return
mStyleImageLoader
;
}
virtual
nsIChannel
*
GetChannel
(
)
const
=
0
;
nsHTMLStyleSheet
*
GetAttributeStyleSheet
(
)
const
{
return
mAttrStyleSheet
;
}
nsHTMLCSSStyleSheet
*
GetInlineStyleSheet
(
)
const
{
return
mStyleAttrStyleSheet
;
}
virtual
void
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aGlobalObject
)
=
0
;
nsIScriptGlobalObject
*
GetScriptHandlingObject
(
bool
&
aHasHadScriptHandlingObject
)
const
{
aHasHadScriptHandlingObject
=
mHasHadScriptHandlingObject
;
return
mScriptGlobalObject
?
mScriptGlobalObject
.
get
(
)
:
GetScriptHandlingObjectInternal
(
)
;
}
void
SetScriptHandlingObject
(
nsIScriptGlobalObject
*
aScriptObject
)
;
nsIGlobalObject
*
GetScopeObject
(
)
const
;
void
SetScopeObject
(
nsIGlobalObject
*
aGlobal
)
;
nsPIDOMWindowOuter
*
GetWindow
(
)
const
{
return
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
GetWindowInternal
(
)
;
}
bool
IsInBackgroundWindow
(
)
const
{
auto
*
outer
=
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
nullptr
;
return
outer
&
&
outer
-
>
IsBackground
(
)
;
}
nsPIDOMWindowInner
*
GetInnerWindow
(
)
const
{
return
mRemovedFromDocShell
?
nullptr
:
mWindow
;
}
uint64_t
OuterWindowID
(
)
const
{
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
uint64_t
InnerWindowID
(
)
const
{
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
bool
IsTopLevelWindowInactive
(
)
const
;
virtual
mozilla
:
:
dom
:
:
ScriptLoader
*
ScriptLoader
(
)
=
0
;
void
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
AddToNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
void
RemoveFromNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
nsTArray
<
Element
*
>
GetFullscreenStack
(
)
const
;
void
AsyncRequestFullScreen
(
mozilla
:
:
UniquePtr
<
FullscreenRequest
>
&
&
)
;
bool
FullscreenElementReadyCheck
(
Element
*
aElement
bool
aWasCallerChrome
)
;
void
RequestFullScreen
(
mozilla
:
:
UniquePtr
<
FullscreenRequest
>
&
&
aRequest
)
;
void
CleanupFullscreenState
(
)
;
bool
FullScreenStackPush
(
Element
*
aElement
)
;
void
FullScreenStackPop
(
)
;
nsresult
RemoteFrameFullscreenChanged
(
nsIDOMElement
*
aFrameElement
)
;
nsresult
RemoteFrameFullscreenReverted
(
)
;
void
RestorePreviousFullScreenState
(
)
;
bool
IsFullscreenLeaf
(
)
;
nsIDocument
*
GetFullscreenRoot
(
)
;
void
SetFullscreenRoot
(
nsIDocument
*
aRoot
)
;
static
void
ExitFullscreenInDocTree
(
nsIDocument
*
aDocument
)
;
static
void
AsyncExitFullscreen
(
nsIDocument
*
aDocument
)
;
static
bool
HandlePendingFullscreenRequests
(
nsIDocument
*
aDocument
)
;
void
DispatchFullscreenError
(
const
char
*
aMessage
)
;
virtual
void
RequestPointerLock
(
Element
*
aElement
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
=
0
;
static
void
UnlockPointer
(
nsIDocument
*
aDoc
=
nullptr
)
;
virtual
void
SetCurrentOrientation
(
mozilla
:
:
dom
:
:
OrientationType
aType
uint16_t
aAngle
)
=
0
;
virtual
uint16_t
CurrentOrientationAngle
(
)
const
=
0
;
virtual
mozilla
:
:
dom
:
:
OrientationType
CurrentOrientationType
(
)
const
=
0
;
virtual
void
SetOrientationPendingPromise
(
mozilla
:
:
dom
:
:
Promise
*
aPromise
)
=
0
;
virtual
mozilla
:
:
dom
:
:
Promise
*
GetOrientationPendingPromise
(
)
const
=
0
;
void
AddObserver
(
nsIDocumentObserver
*
aObserver
)
;
bool
RemoveObserver
(
nsIDocumentObserver
*
aObserver
)
;
void
BeginUpdate
(
nsUpdateType
aUpdateType
)
;
virtual
void
EndUpdate
(
nsUpdateType
aUpdateType
)
=
0
;
virtual
void
BeginLoad
(
)
=
0
;
virtual
void
EndLoad
(
)
=
0
;
enum
ReadyState
{
READYSTATE_UNINITIALIZED
=
0
READYSTATE_LOADING
=
1
READYSTATE_INTERACTIVE
=
3
READYSTATE_COMPLETE
=
4
}
;
void
SetReadyStateInternal
(
ReadyState
rs
)
;
ReadyState
GetReadyStateEnum
(
)
{
return
mReadyState
;
}
void
ContentStateChanged
(
nsIContent
*
aContent
mozilla
:
:
EventStates
aStateMask
)
;
void
DocumentStatesChanged
(
mozilla
:
:
EventStates
aStateMask
)
;
void
StyleRuleChanged
(
mozilla
:
:
StyleSheet
*
aStyleSheet
mozilla
:
:
css
:
:
Rule
*
aStyleRule
)
;
void
StyleRuleAdded
(
mozilla
:
:
StyleSheet
*
aStyleSheet
mozilla
:
:
css
:
:
Rule
*
aStyleRule
)
;
void
StyleRuleRemoved
(
mozilla
:
:
StyleSheet
*
aStyleSheet
mozilla
:
:
css
:
:
Rule
*
aStyleRule
)
;
void
FlushPendingNotifications
(
mozilla
:
:
FlushType
aType
)
;
void
FlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aFlush
)
;
virtual
void
FlushExternalResources
(
mozilla
:
:
FlushType
aType
)
=
0
;
nsBindingManager
*
BindingManager
(
)
const
{
return
mNodeInfoManager
-
>
GetBindingManager
(
)
;
}
nsNodeInfoManager
*
NodeInfoManager
(
)
const
{
return
mNodeInfoManager
;
}
virtual
void
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
=
0
;
virtual
void
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
)
=
0
;
virtual
void
SetContainer
(
nsDocShell
*
aContainer
)
;
virtual
nsISupports
*
GetContainer
(
)
const
;
nsILoadContext
*
GetLoadContext
(
)
const
;
nsIDocShell
*
GetDocShell
(
)
const
;
virtual
void
SetXMLDeclaration
(
const
char16_t
*
aVersion
const
char16_t
*
aEncoding
const
int32_t
aStandalone
)
=
0
;
virtual
void
GetXMLDeclaration
(
nsAString
&
aVersion
nsAString
&
aEncoding
nsAString
&
Standalone
)
=
0
;
bool
IsHTMLDocument
(
)
const
{
return
mType
=
=
eHTML
;
}
bool
IsHTMLOrXHTML
(
)
const
{
return
mType
=
=
eHTML
|
|
mType
=
=
eXHTML
;
}
bool
IsXMLDocument
(
)
const
{
return
!
IsHTMLDocument
(
)
;
}
bool
IsSVGDocument
(
)
const
{
return
mType
=
=
eSVG
;
}
bool
IsXULDocument
(
)
const
{
return
mType
=
=
eXUL
;
}
bool
IsUnstyledDocument
(
)
{
return
IsLoadedAsData
(
)
|
|
IsLoadedAsInteractiveData
(
)
;
}
bool
LoadsFullXULStyleSheetUpFront
(
)
{
return
IsXULDocument
(
)
|
|
AllowXULXBL
(
)
;
}
bool
IsScriptEnabled
(
)
;
bool
IsTopLevelContentDocument
(
)
const
{
return
mIsTopLevelContentDocument
;
}
void
SetIsTopLevelContentDocument
(
bool
aIsTopLevelContentDocument
)
{
mIsTopLevelContentDocument
=
aIsTopLevelContentDocument
;
if
(
aIsTopLevelContentDocument
)
{
SetAllowPaymentRequest
(
true
)
;
}
}
bool
IsContentDocument
(
)
const
{
return
mIsContentDocument
;
}
void
SetIsContentDocument
(
bool
aIsContentDocument
)
{
mIsContentDocument
=
aIsContentDocument
;
}
virtual
already_AddRefed
<
Element
>
CreateElem
(
const
nsAString
&
aName
nsAtom
*
aPrefix
int32_t
aNamespaceID
const
nsAString
*
aIs
=
nullptr
)
=
0
;
nsISupports
*
GetSecurityInfo
(
)
{
return
mSecurityInfo
;
}
virtual
nsIChannel
*
GetFailedChannel
(
)
const
=
0
;
virtual
void
SetFailedChannel
(
nsIChannel
*
aChannel
)
=
0
;
int32_t
GetDefaultNamespaceID
(
)
const
{
return
mDefaultElementType
;
}
void
DeleteAllProperties
(
)
;
void
DeleteAllPropertiesFor
(
nsINode
*
aNode
)
;
nsPropertyTable
*
PropertyTable
(
uint16_t
aCategory
)
{
if
(
aCategory
=
=
0
)
return
&
mPropertyTable
;
return
GetExtraPropertyTable
(
aCategory
)
;
}
uint32_t
GetPropertyTableCount
(
)
{
return
mExtraPropertyTables
.
Length
(
)
+
1
;
}
void
SetPartID
(
uint32_t
aID
)
{
mPartID
=
aID
;
}
uint32_t
GetPartID
(
)
const
{
return
mPartID
;
}
virtual
void
Sanitize
(
)
=
0
;
typedef
bool
(
*
nsSubDocEnumFunc
)
(
nsIDocument
*
aDocument
void
*
aData
)
;
virtual
void
EnumerateSubDocuments
(
nsSubDocEnumFunc
aCallback
void
*
aData
)
=
0
;
typedef
bool
(
*
nsDocTestFunc
)
(
const
nsIDocument
*
aDocument
)
;
virtual
void
CollectDescendantDocuments
(
nsTArray
<
nsCOMPtr
<
nsIDocument
>
>
&
aDescendants
nsDocTestFunc
aCallback
)
const
=
0
;
virtual
bool
CanSavePresentation
(
nsIRequest
*
aNewRequest
)
=
0
;
virtual
void
Destroy
(
)
=
0
;
virtual
void
RemovedFromDocShell
(
)
=
0
;
virtual
already_AddRefed
<
nsILayoutHistoryState
>
GetLayoutHistoryState
(
)
const
=
0
;
virtual
void
BlockOnload
(
)
=
0
;
virtual
void
UnblockOnload
(
bool
aFireSync
)
=
0
;
void
BlockDOMContentLoaded
(
)
{
+
+
mBlockDOMContentLoaded
;
}
virtual
void
UnblockDOMContentLoaded
(
)
=
0
;
virtual
void
OnPageShow
(
bool
aPersisted
mozilla
:
:
dom
:
:
EventTarget
*
aDispatchStartTarget
)
=
0
;
virtual
void
OnPageHide
(
bool
aPersisted
mozilla
:
:
dom
:
:
EventTarget
*
aDispatchStartTarget
)
=
0
;
void
AddStyleRelevantLink
(
mozilla
:
:
dom
:
:
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
mozilla
:
:
dom
:
:
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
!
entry
"
Document
already
knows
about
this
Link
!
"
)
;
mStyledLinksCleared
=
false
;
#
endif
mStyledLinks
.
PutEntry
(
aLink
)
;
}
void
ForgetLink
(
mozilla
:
:
dom
:
:
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
mozilla
:
:
dom
:
:
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
entry
|
|
mStyledLinksCleared
"
Document
knows
nothing
about
this
Link
!
"
)
;
#
endif
mStyledLinks
.
RemoveEntry
(
aLink
)
;
}
void
RefreshLinkHrefs
(
)
;
virtual
void
ClearBoxObjectFor
(
nsIContent
*
aContent
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
dom
:
:
BoxObject
>
GetBoxObjectFor
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
ErrorResult
&
aRv
)
=
0
;
already_AddRefed
<
mozilla
:
:
dom
:
:
MediaQueryList
>
MatchMedia
(
const
nsAString
&
aMediaQueryList
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
MediaQueryList
>
&
MediaQueryLists
(
)
{
return
mDOMMediaQueryLists
;
}
nsCompatibility
GetCompatibilityMode
(
)
const
{
return
mCompatMode
;
}
bool
HaveFiredDOMTitleChange
(
)
const
{
return
mHaveFiredTitleChange
;
}
virtual
Element
*
GetAnonymousElementByAttribute
(
nsIContent
*
aElement
nsAtom
*
aAttrName
const
nsAString
&
aAttrValue
)
const
=
0
;
virtual
nsresult
NodesFromRectHelper
(
float
aX
float
aY
float
aTopSize
float
aRightSize
float
aBottomSize
float
aLeftSize
bool
aIgnoreRootScrollFrame
bool
aFlushLayout
nsIDOMNodeList
*
*
aReturn
)
=
0
;
virtual
void
FlushSkinBindings
(
)
=
0
;
void
MayDispatchMutationEvent
(
nsINode
*
aTarget
)
{
if
(
mSubtreeModifiedDepth
>
0
)
{
mSubtreeModifiedTargets
.
AppendObject
(
aTarget
)
;
}
}
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
bool
IsCookieAverse
(
)
const
{
if
(
!
GetInnerWindow
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
codebaseURI
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
codebaseURI
)
)
;
if
(
!
codebaseURI
)
{
return
true
;
}
nsAutoCString
scheme
;
codebaseURI
-
>
GetScheme
(
scheme
)
;
return
!
scheme
.
EqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
ftp
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
file
"
)
;
}
bool
IsLoadedAsData
(
)
{
return
mLoadedAsData
;
}
bool
IsLoadedAsInteractiveData
(
)
{
return
mLoadedAsInteractiveData
;
}
bool
MayStartLayout
(
)
{
return
mMayStartLayout
;
}
virtual
void
SetMayStartLayout
(
bool
aMayStartLayout
)
;
already_AddRefed
<
nsIDocumentEncoder
>
GetCachedEncoder
(
)
;
void
SetCachedEncoder
(
already_AddRefed
<
nsIDocumentEncoder
>
aEncoder
)
;
virtual
nsresult
InitializeFrameLoader
(
nsFrameLoader
*
aLoader
)
=
0
;
virtual
nsresult
FinalizeFrameLoader
(
nsFrameLoader
*
aLoader
nsIRunnable
*
aFinalizer
)
=
0
;
virtual
void
TryCancelFrameLoaderInitialization
(
nsIDocShell
*
aShell
)
=
0
;
bool
IsRootDisplayDocument
(
)
const
{
return
!
mParentDocument
&
&
!
mDisplayDocument
;
}
bool
IsBeingUsedAsImage
(
)
const
{
return
mIsBeingUsedAsImage
;
}
void
SetIsBeingUsedAsImage
(
)
{
mIsBeingUsedAsImage
=
true
;
}
bool
IsSVGGlyphsDocument
(
)
const
{
return
mIsSVGGlyphsDocument
;
}
void
SetIsSVGGlyphsDocument
(
)
{
mIsSVGGlyphsDocument
=
true
;
}
bool
IsResourceDoc
(
)
const
{
return
IsBeingUsedAsImage
(
)
|
|
mHasDisplayDocument
;
}
nsIDocument
*
GetDisplayDocument
(
)
const
{
return
mDisplayDocument
;
}
void
SetDisplayDocument
(
nsIDocument
*
aDisplayDocument
)
{
MOZ_ASSERT
(
!
GetShell
(
)
&
&
!
GetContainer
(
)
&
&
!
GetWindow
(
)
"
Shouldn
'
t
set
mDisplayDocument
on
documents
that
already
"
"
have
a
presentation
or
a
docshell
or
a
window
"
)
;
MOZ_ASSERT
(
aDisplayDocument
"
Must
not
be
null
"
)
;
MOZ_ASSERT
(
aDisplayDocument
!
=
this
"
Should
be
different
document
"
)
;
MOZ_ASSERT
(
!
aDisplayDocument
-
>
GetDisplayDocument
(
)
"
Display
documents
should
not
nest
"
)
;
mDisplayDocument
=
aDisplayDocument
;
mHasDisplayDocument
=
!
!
aDisplayDocument
;
}
class
ExternalResourceLoad
:
public
nsISupports
{
public
:
virtual
~
ExternalResourceLoad
(
)
{
}
void
AddObserver
(
nsIObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
"
Must
have
observer
"
)
;
mObservers
.
AppendElement
(
aObserver
)
;
}
const
nsTArray
<
nsCOMPtr
<
nsIObserver
>
>
&
Observers
(
)
{
return
mObservers
;
}
protected
:
AutoTArray
<
nsCOMPtr
<
nsIObserver
>
8
>
mObservers
;
}
;
virtual
nsIDocument
*
RequestExternalResource
(
nsIURI
*
aURI
nsINode
*
aRequestingNode
ExternalResourceLoad
*
*
aPendingLoad
)
=
0
;
virtual
void
EnumerateExternalResources
(
nsSubDocEnumFunc
aCallback
void
*
aData
)
=
0
;
bool
IsShowing
(
)
const
{
return
mIsShowing
;
}
bool
IsVisible
(
)
const
{
return
mVisible
;
}
bool
IsVisibleConsideringAncestors
(
)
const
;
bool
IsActive
(
)
const
{
return
mDocumentContainer
&
&
!
mRemovedFromDocShell
;
}
bool
IsCurrentActiveDocument
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
return
inner
&
&
inner
-
>
IsCurrentInnerWindow
(
)
&
&
inner
-
>
GetDoc
(
)
=
=
this
;
}
bool
ShouldLoadImages
(
)
const
{
return
IsCurrentActiveDocument
(
)
|
|
IsBeingUsedAsImage
(
)
;
}
void
RegisterActivityObserver
(
nsISupports
*
aSupports
)
;
bool
UnregisterActivityObserver
(
nsISupports
*
aSupports
)
;
typedef
void
(
*
ActivityObserverEnumerator
)
(
nsISupports
*
void
*
)
;
void
EnumerateActivityObservers
(
ActivityObserverEnumerator
aEnumerator
void
*
aData
)
;
bool
HasAnimationController
(
)
{
return
!
!
mAnimationController
;
}
virtual
nsSMILAnimationController
*
GetAnimationController
(
)
=
0
;
virtual
mozilla
:
:
PendingAnimationTracker
*
GetPendingAnimationTracker
(
)
=
0
;
virtual
mozilla
:
:
PendingAnimationTracker
*
GetOrCreatePendingAnimationTracker
(
)
=
0
;
virtual
void
SuppressEventHandling
(
uint32_t
aIncrease
=
1
)
=
0
;
virtual
void
UnsuppressEventHandlingAndFireEvents
(
bool
aFireEvents
)
=
0
;
uint32_t
EventHandlingSuppressed
(
)
const
{
return
mEventsSuppressed
;
}
bool
IsEventHandlingEnabled
(
)
{
return
!
EventHandlingSuppressed
(
)
&
&
mScriptGlobalObject
;
}
void
IncrementIgnoreDestructiveWritesCounter
(
)
{
+
+
mIgnoreDestructiveWritesCounter
;
}
void
DecrementIgnoreDestructiveWritesCounter
(
)
{
-
-
mIgnoreDestructiveWritesCounter
;
}
bool
IsDNSPrefetchAllowed
(
)
const
{
return
mAllowDNSPrefetch
;
}
bool
AllowXULXBL
(
)
{
return
mAllowXULXBL
=
=
eTriTrue
?
true
:
mAllowXULXBL
=
=
eTriFalse
?
false
:
InternalAllowXULXBL
(
)
;
}
void
ForceEnableXULXBL
(
)
{
mAllowXULXBL
=
eTriTrue
;
}
virtual
nsIDocument
*
GetTemplateContentsOwner
(
)
=
0
;
bool
IsStaticDocument
(
)
{
return
mIsStaticDocument
;
}
virtual
already_AddRefed
<
nsIDocument
>
CreateStaticClone
(
nsIDocShell
*
aCloneContainer
)
;
nsIDocument
*
GetOriginalDocument
(
)
{
MOZ_ASSERT
(
!
mOriginalDocument
|
|
!
mOriginalDocument
-
>
GetOriginalDocument
(
)
)
;
return
mOriginalDocument
;
}
void
UnlinkOriginalDocumentIfStatic
(
)
;
virtual
void
PreloadPictureOpened
(
)
=
0
;
virtual
void
PreloadPictureClosed
(
)
=
0
;
virtual
void
PreloadPictureImageSource
(
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
)
=
0
;
virtual
already_AddRefed
<
nsIURI
>
ResolvePreloadImage
(
nsIURI
*
aBaseURI
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
bool
*
aIsImgSet
)
=
0
;
virtual
void
MaybePreLoadImage
(
nsIURI
*
uri
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
bool
aIsImgSet
)
=
0
;
virtual
void
ForgetImagePreload
(
nsIURI
*
aURI
)
=
0
;
void
PreloadStyle
(
nsIURI
*
aURI
const
mozilla
:
:
Encoding
*
aEncoding
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
const
nsAString
&
aIntegrity
)
;
nsresult
LoadChromeSheetSync
(
nsIURI
*
aURI
bool
aIsAgentSheet
RefPtr
<
mozilla
:
:
StyleSheet
>
*
aSheet
)
;
virtual
bool
IsDocumentRightToLeft
(
)
{
return
false
;
}
virtual
void
MaybePreconnect
(
nsIURI
*
uri
mozilla
:
:
CORSMode
aCORSMode
)
=
0
;
enum
DocumentTheme
{
Doc_Theme_Uninitialized
Doc_Theme_None
Doc_Theme_Neutral
Doc_Theme_Dark
Doc_Theme_Bright
}
;
void
SetStateObject
(
nsIStructuredCloneContainer
*
scContainer
)
;
virtual
DocumentTheme
GetDocumentLWTheme
(
)
{
return
Doc_Theme_None
;
}
virtual
DocumentTheme
ThreadSafeGetDocumentLWTheme
(
)
const
{
return
Doc_Theme_None
;
}
mozilla
:
:
EventStates
GetDocumentState
(
)
const
{
return
mDocumentState
;
}
virtual
nsISupports
*
GetCurrentContentSink
(
)
=
0
;
void
SetAutoFocusElement
(
Element
*
aAutoFocusElement
)
;
void
TriggerAutoFocus
(
)
;
virtual
void
SetScrollToRef
(
nsIURI
*
aDocumentURI
)
=
0
;
virtual
void
ScrollToRef
(
)
=
0
;
virtual
void
ResetScrolledToRefAlready
(
)
=
0
;
virtual
void
SetChangeScrollPosWhenScrollingToRef
(
bool
aValue
)
=
0
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementById
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByTagName
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByTagNameNS
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByClassName
;
Element
*
LookupImageElement
(
const
nsAString
&
aElementId
)
;
virtual
mozilla
:
:
dom
:
:
DocumentTimeline
*
Timeline
(
)
=
0
;
virtual
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
DocumentTimeline
>
&
Timelines
(
)
=
0
;
virtual
void
GetAnimations
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Animation
>
>
&
aAnimations
)
=
0
;
mozilla
:
:
dom
:
:
SVGSVGElement
*
GetSVGRootElement
(
)
const
;
nsresult
ScheduleFrameRequestCallback
(
mozilla
:
:
dom
:
:
FrameRequestCallback
&
aCallback
int32_t
*
aHandle
)
;
void
CancelFrameRequestCallback
(
int32_t
aHandle
)
;
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
FrameRequestCallback
>
>
FrameRequestCallbackList
;
void
TakeFrameRequestCallbacks
(
FrameRequestCallbackList
&
aCallbacks
)
;
bool
ShouldThrottleFrameRequests
(
)
;
bool
InUnlinkOrDeletion
(
)
{
return
mInUnlinkOrDeletion
;
}
mozilla
:
:
dom
:
:
ImageTracker
*
ImageTracker
(
)
;
virtual
nsresult
AddPlugin
(
nsIObjectLoadingContent
*
aPlugin
)
=
0
;
virtual
void
RemovePlugin
(
nsIObjectLoadingContent
*
aPlugin
)
=
0
;
virtual
void
GetPlugins
(
nsTArray
<
nsIObjectLoadingContent
*
>
&
aPlugins
)
=
0
;
virtual
nsresult
AddResponsiveContent
(
nsIContent
*
aContent
)
=
0
;
virtual
void
RemoveResponsiveContent
(
nsIContent
*
aContent
)
=
0
;
virtual
void
NotifyMediaFeatureValuesChanged
(
)
=
0
;
virtual
nsresult
GetStateObject
(
nsIVariant
*
*
aResult
)
=
0
;
nsDOMNavigationTiming
*
GetNavigationTiming
(
)
const
{
return
mTiming
;
}
void
SetNavigationTiming
(
nsDOMNavigationTiming
*
aTiming
)
;
virtual
Element
*
FindImageMap
(
const
nsAString
&
aNormalizedMapName
)
=
0
;
void
RegisterPendingLinkUpdate
(
mozilla
:
:
dom
:
:
Link
*
aLink
)
;
void
FlushPendingLinkUpdates
(
)
;
void
FlushPendingLinkUpdatesFromRunnable
(
)
;
#
define
DEPRECATED_OPERATION
(
_op
)
e
#
#
_op
enum
DeprecatedOperations
{
#
include
"
nsDeprecatedOperationList
.
h
"
eDeprecatedOperationCount
}
;
#
undef
DEPRECATED_OPERATION
bool
HasWarnedAbout
(
DeprecatedOperations
aOperation
)
const
;
void
WarnOnceAbout
(
DeprecatedOperations
aOperation
bool
asError
=
false
)
const
;
#
define
DOCUMENT_WARNING
(
_op
)
e
#
#
_op
enum
DocumentWarnings
{
#
include
"
nsDocumentWarningList
.
h
"
eDocumentWarningCount
}
;
#
undef
DOCUMENT_WARNING
bool
HasWarnedAbout
(
DocumentWarnings
aWarning
)
const
;
void
WarnOnceAbout
(
DocumentWarnings
aWarning
bool
asError
=
false
const
char16_t
*
*
aParams
=
nullptr
uint32_t
aParamsLength
=
0
)
const
;
void
PostVisibilityUpdateEvent
(
)
;
bool
IsSyntheticDocument
(
)
const
{
return
mIsSyntheticDocument
;
}
virtual
void
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
virtual
void
DocAddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
bool
MayHaveDOMMutationObservers
(
)
{
return
mMayHaveDOMMutationObservers
;
}
void
SetMayHaveDOMMutationObservers
(
)
{
mMayHaveDOMMutationObservers
=
true
;
}
bool
MayHaveAnimationObservers
(
)
{
return
mMayHaveAnimationObservers
;
}
void
SetMayHaveAnimationObservers
(
)
{
mMayHaveAnimationObservers
=
true
;
}
bool
IsInSyncOperation
(
)
{
return
mInSyncOperationCount
!
=
0
;
}
void
SetIsInSyncOperation
(
bool
aSync
)
{
if
(
aSync
)
{
+
+
mInSyncOperationCount
;
}
else
{
-
-
mInSyncOperationCount
;
}
}
bool
CreatingStaticClone
(
)
const
{
return
mCreatingStaticClone
;
}
already_AddRefed
<
Element
>
CreateHTMLElement
(
nsAtom
*
aTag
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetScopeObject
(
)
;
}
static
already_AddRefed
<
nsIDocument
>
Constructor
(
const
GlobalObject
&
aGlobal
mozilla
:
:
ErrorResult
&
rv
)
;
mozilla
:
:
dom
:
:
DOMImplementation
*
GetImplementation
(
mozilla
:
:
ErrorResult
&
rv
)
;
MOZ_MUST_USE
nsresult
GetURL
(
nsString
&
retval
)
const
;
MOZ_MUST_USE
nsresult
GetDocumentURI
(
nsString
&
retval
)
const
;
void
GetDocumentURIFromJS
(
nsString
&
aDocumentURI
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
const
;
void
GetCompatMode
(
nsString
&
retval
)
const
;
void
GetCharacterSet
(
nsAString
&
retval
)
const
;
Element
*
GetDocumentElement
(
)
const
{
return
GetRootElement
(
)
;
}
enum
ElementCallbackType
{
eConnected
eDisconnected
eAdopted
eAttributeChanged
}
;
nsIDocument
*
GetTopLevelContentDocument
(
)
;
virtual
already_AddRefed
<
Element
>
CreateElement
(
const
nsAString
&
aTagName
const
mozilla
:
:
dom
:
:
ElementCreationOptionsOrString
&
aOptions
mozilla
:
:
ErrorResult
&
rv
)
=
0
;
virtual
already_AddRefed
<
Element
>
CreateElementNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
const
mozilla
:
:
dom
:
:
ElementCreationOptionsOrString
&
aOptions
mozilla
:
:
ErrorResult
&
rv
)
=
0
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CreateDocumentFragment
(
)
const
;
already_AddRefed
<
nsTextNode
>
CreateTextNode
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
nsTextNode
>
CreateEmptyTextNode
(
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Comment
>
CreateComment
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
ProcessingInstruction
>
CreateProcessingInstruction
(
const
nsAString
&
target
const
nsAString
&
data
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsINode
>
ImportNode
(
nsINode
&
aNode
bool
aDeep
mozilla
:
:
ErrorResult
&
rv
)
const
;
nsINode
*
AdoptNode
(
nsINode
&
aNode
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Event
>
CreateEvent
(
const
nsAString
&
aEventType
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsRange
>
CreateRange
(
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeIterator
>
CreateNodeIterator
(
nsINode
&
aRoot
uint32_t
aWhatToShow
mozilla
:
:
dom
:
:
NodeFilter
*
aFilter
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TreeWalker
>
CreateTreeWalker
(
nsINode
&
aRoot
uint32_t
aWhatToShow
mozilla
:
:
dom
:
:
NodeFilter
*
aFilter
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
CDATASection
>
CreateCDATASection
(
const
nsAString
&
aData
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Attr
>
CreateAttribute
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Attr
>
CreateAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
mozilla
:
:
ErrorResult
&
rv
)
;
void
SetAllowUnsafeHTML
(
bool
aAllow
)
{
mAllowUnsafeHTML
=
aAllow
;
}
bool
AllowUnsafeHTML
(
)
const
;
void
GetInputEncoding
(
nsAString
&
aInputEncoding
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Location
>
GetLocation
(
)
const
;
void
GetReferrer
(
nsAString
&
aReferrer
)
const
;
void
GetLastModified
(
nsAString
&
aLastModified
)
const
;
void
GetReadyState
(
nsAString
&
aReadyState
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
AboutCapabilities
>
GetAboutCapabilities
(
ErrorResult
&
aRv
)
;
void
GetTitle
(
nsAString
&
aTitle
)
;
void
SetTitle
(
const
nsAString
&
aTitle
mozilla
:
:
ErrorResult
&
rv
)
;
void
GetDir
(
nsAString
&
aDirection
)
const
;
void
SetDir
(
const
nsAString
&
aDirection
)
;
already_AddRefed
<
nsContentList
>
GetElementsByName
(
const
nsAString
&
aName
)
{
return
GetFuncStringContentList
<
nsCachableElementsByNameNodeList
>
(
this
MatchNameAttribute
nullptr
UseExistingNameString
aName
)
;
}
nsPIDOMWindowOuter
*
GetDefaultView
(
)
const
{
return
GetWindow
(
)
;
}
Element
*
GetActiveElement
(
)
;
bool
HasFocus
(
mozilla
:
:
ErrorResult
&
rv
)
const
;
mozilla
:
:
TimeStamp
LastFocusTime
(
)
const
;
void
SetLastFocusTime
(
const
mozilla
:
:
TimeStamp
&
aFocusTime
)
;
bool
MozSyntheticDocument
(
)
const
{
return
IsSyntheticDocument
(
)
;
}
Element
*
GetCurrentScript
(
)
;
void
ReleaseCapture
(
)
const
;
void
MozSetImageElement
(
const
nsAString
&
aImageElementId
Element
*
aElement
)
;
nsIURI
*
GetDocumentURIObject
(
)
const
;
bool
FullscreenEnabled
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
Element
*
FullScreenStackTop
(
)
;
bool
Fullscreen
(
)
{
return
!
!
GetFullscreenElement
(
)
;
}
void
ExitFullscreen
(
)
;
void
ExitPointerLock
(
)
{
UnlockPointer
(
this
)
;
}
static
bool
IsUnprefixedFullscreenEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
#
ifdef
MOZILLA_INTERNAL_API
bool
Hidden
(
)
const
{
return
mVisibilityState
!
=
mozilla
:
:
dom
:
:
VisibilityState
:
:
Visible
;
}
mozilla
:
:
dom
:
:
VisibilityState
VisibilityState
(
)
const
{
return
mVisibilityState
;
}
#
endif
void
GetSelectedStyleSheetSet
(
nsAString
&
aSheetSet
)
;
void
SetSelectedStyleSheetSet
(
const
nsAString
&
aSheetSet
)
;
void
GetLastStyleSheetSet
(
nsAString
&
aSheetSet
)
;
void
GetPreferredStyleSheetSet
(
nsAString
&
aSheetSet
)
;
mozilla
:
:
dom
:
:
DOMStringList
*
StyleSheetSets
(
)
;
void
EnableStyleSheetsForSet
(
const
nsAString
&
aSheetSet
)
;
already_AddRefed
<
nsDOMCaretPosition
>
CaretPositionFromPoint
(
float
aX
float
aY
)
;
Element
*
GetScrollingElement
(
)
;
bool
IsScrollingElement
(
Element
*
aElement
)
;
nsINodeList
*
GetAnonymousNodes
(
Element
&
aElement
)
;
Element
*
GetAnonymousElementByAttribute
(
Element
&
aElement
const
nsAString
&
aAttrName
const
nsAString
&
aAttrValue
)
;
Element
*
GetBindingParent
(
nsINode
&
aNode
)
;
void
LoadBindingDocument
(
const
nsAString
&
aURI
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
rv
)
;
mozilla
:
:
dom
:
:
XPathExpression
*
CreateExpression
(
const
nsAString
&
aExpression
mozilla
:
:
dom
:
:
XPathNSResolver
*
aResolver
mozilla
:
:
ErrorResult
&
rv
)
;
nsINode
*
CreateNSResolver
(
nsINode
&
aNodeResolver
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
XPathResult
>
Evaluate
(
JSContext
*
aCx
const
nsAString
&
aExpression
nsINode
&
aContextNode
mozilla
:
:
dom
:
:
XPathNSResolver
*
aResolver
uint16_t
aType
JS
:
:
Handle
<
JSObject
*
>
aResult
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Touch
>
CreateTouch
(
nsGlobalWindowInner
*
aView
mozilla
:
:
dom
:
:
EventTarget
*
aTarget
int32_t
aIdentifier
int32_t
aPageX
int32_t
aPageY
int32_t
aScreenX
int32_t
aScreenY
int32_t
aClientX
int32_t
aClientY
int32_t
aRadiusX
int32_t
aRadiusY
float
aRotationAngle
float
aForce
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TouchList
>
CreateTouchList
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TouchList
>
CreateTouchList
(
mozilla
:
:
dom
:
:
Touch
&
aTouch
const
mozilla
:
:
dom
:
:
Sequence
<
mozilla
:
:
OwningNonNull
<
mozilla
:
:
dom
:
:
Touch
>
>
&
aTouches
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TouchList
>
CreateTouchList
(
const
mozilla
:
:
dom
:
:
Sequence
<
mozilla
:
:
OwningNonNull
<
mozilla
:
:
dom
:
:
Touch
>
>
&
aTouches
)
;
void
SetStyleSheetChangeEventsEnabled
(
bool
aValue
)
{
mStyleSheetChangeEventsEnabled
=
aValue
;
}
bool
StyleSheetChangeEventsEnabled
(
)
const
{
return
mStyleSheetChangeEventsEnabled
;
}
void
ObsoleteSheet
(
nsIURI
*
aSheetURI
mozilla
:
:
ErrorResult
&
rv
)
;
void
ObsoleteSheet
(
const
nsAString
&
aSheetURI
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
BlockParsing
(
mozilla
:
:
dom
:
:
Promise
&
aPromise
const
mozilla
:
:
dom
:
:
BlockParsingOptions
&
aOptions
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsIURI
>
GetMozDocumentURIIfNotForErrorPages
(
)
;
mozilla
:
:
dom
:
:
Promise
*
GetDocumentReadyForIdle
(
mozilla
:
:
ErrorResult
&
aRv
)
;
nsIHTMLCollection
*
Children
(
)
;
uint32_t
ChildElementCount
(
)
;
virtual
nsHTMLDocument
*
AsHTMLDocument
(
)
{
return
nullptr
;
}
virtual
mozilla
:
:
dom
:
:
SVGDocument
*
AsSVGDocument
(
)
{
return
nullptr
;
}
virtual
mozilla
:
:
dom
:
:
XULDocument
*
AsXULDocument
(
)
{
return
nullptr
;
}
void
AddBlockedTrackingNode
(
nsINode
*
node
)
{
if
(
!
node
)
{
return
;
}
nsWeakPtr
weakNode
=
do_GetWeakReference
(
node
)
;
if
(
weakNode
)
{
mBlockedTrackingNodes
.
AppendElement
(
weakNode
)
;
}
}
gfxUserFontSet
*
GetUserFontSet
(
bool
aFlushUserFontSet
=
true
)
;
void
FlushUserFontSet
(
)
;
void
MarkUserFontSetDirty
(
)
;
mozilla
:
:
dom
:
:
FontFaceSet
*
GetFonts
(
)
{
return
mFontFaceSet
;
}
mozilla
:
:
dom
:
:
FontFaceSet
*
Fonts
(
)
;
bool
DidFireDOMContentLoaded
(
)
const
{
return
mDidFireDOMContentLoaded
;
}
void
SetDocumentUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
if
(
!
mUseCounters
[
aUseCounter
]
)
{
mUseCounters
[
aUseCounter
]
=
true
;
}
}
void
SetPageUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
;
void
SetDocumentAndPageUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
SetDocumentUseCounter
(
aUseCounter
)
;
SetPageUseCounter
(
aUseCounter
)
;
}
void
PropagateUseCounters
(
nsIDocument
*
aParentDocument
)
;
void
SetDocumentIncCounter
(
mozilla
:
:
IncCounter
aIncCounter
uint32_t
inc
=
1
)
{
mIncCounters
[
aIncCounter
]
+
=
inc
;
}
void
SetUserHasInteracted
(
bool
aUserHasInteracted
)
;
bool
UserHasInteracted
(
)
{
return
mUserHasInteracted
;
}
void
NotifyUserActivation
(
)
;
bool
HasBeenUserActivated
(
)
;
bool
HasScriptsBlockedBySandbox
(
)
;
bool
InlineScriptAllowedByCSP
(
)
;
void
ReportHasScrollLinkedEffect
(
)
;
bool
HasScrollLinkedEffect
(
)
const
{
return
mHasScrollLinkedEffect
;
}
mozilla
:
:
dom
:
:
DocGroup
*
GetDocGroup
(
)
const
;
void
AddIntersectionObserver
(
mozilla
:
:
dom
:
:
DOMIntersectionObserver
*
aObserver
)
{
MOZ_ASSERT
(
!
mIntersectionObservers
.
Contains
(
aObserver
)
"
Intersection
observer
already
in
the
list
"
)
;
mIntersectionObservers
.
PutEntry
(
aObserver
)
;
}
void
RemoveIntersectionObserver
(
mozilla
:
:
dom
:
:
DOMIntersectionObserver
*
aObserver
)
{
mIntersectionObservers
.
RemoveEntry
(
aObserver
)
;
}
bool
HasIntersectionObservers
(
)
const
{
return
!
mIntersectionObservers
.
IsEmpty
(
)
;
}
void
UpdateIntersectionObservations
(
)
;
void
ScheduleIntersectionObserverNotification
(
)
;
void
NotifyIntersectionObservers
(
)
;
nsresult
Dispatch
(
mozilla
:
:
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
final
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
override
;
virtual
mozilla
:
:
AbstractThread
*
AbstractMainThreadFor
(
mozilla
:
:
TaskCategory
aCategory
)
override
;
void
NoteScriptTrackingStatus
(
const
nsACString
&
aURL
bool
isTracking
)
;
bool
IsScriptTracking
(
const
nsACString
&
aURL
)
const
;
mozilla
:
:
dom
:
:
FlashClassification
DocumentFlashClassification
(
)
;
bool
IsThirdParty
(
)
;
bool
IsScopedStyleEnabled
(
)
;
nsINode
*
GetServoRestyleRoot
(
)
const
{
return
mServoRestyleRoot
;
}
uint32_t
GetServoRestyleRootDirtyBits
(
)
const
{
MOZ_ASSERT
(
mServoRestyleRoot
)
;
MOZ_ASSERT
(
mServoRestyleRootDirtyBits
)
;
return
mServoRestyleRootDirtyBits
;
}
void
ClearServoRestyleRoot
(
)
{
mServoRestyleRoot
=
nullptr
;
mServoRestyleRootDirtyBits
=
0
;
}
inline
void
SetServoRestyleRoot
(
nsINode
*
aRoot
uint32_t
aDirtyBits
)
;
inline
void
SetServoRestyleRootDirtyBits
(
uint32_t
aDirtyBits
)
;
bool
ShouldThrowOnDynamicMarkupInsertion
(
)
{
return
mThrowOnDynamicMarkupInsertionCounter
;
}
void
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
{
+
+
mThrowOnDynamicMarkupInsertionCounter
;
}
void
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
{
MOZ_ASSERT
(
mThrowOnDynamicMarkupInsertionCounter
)
;
-
-
mThrowOnDynamicMarkupInsertionCounter
;
}
bool
ShouldIgnoreOpens
(
)
const
{
return
mIgnoreOpensDuringUnloadCounter
;
}
void
IncrementIgnoreOpensDuringUnloadCounter
(
)
{
+
+
mIgnoreOpensDuringUnloadCounter
;
}
void
DecrementIgnoreOpensDuringUnloadCounter
(
)
{
MOZ_ASSERT
(
mIgnoreOpensDuringUnloadCounter
)
;
-
-
mIgnoreOpensDuringUnloadCounter
;
}
bool
AllowPaymentRequest
(
)
const
{
return
mAllowPaymentRequest
;
}
void
SetAllowPaymentRequest
(
bool
aAllowPaymentRequest
)
{
mAllowPaymentRequest
=
aAllowPaymentRequest
;
}
bool
IsShadowDOMEnabled
(
)
const
{
return
mIsShadowDOMEnabled
;
}
bool
ModuleScriptsEnabled
(
)
;
nsIContent
*
GetContentInThisDocument
(
nsIFrame
*
aFrame
)
const
;
protected
:
Element
*
GetTitleElement
(
)
;
mozilla
:
:
dom
:
:
FlashClassification
PrincipalFlashClassification
(
)
;
mozilla
:
:
dom
:
:
FlashClassification
ComputeFlashClassification
(
)
;
void
RecordNavigationTiming
(
ReadyState
aReadyState
)
;
void
UpdateVisibilityState
(
)
;
mozilla
:
:
dom
:
:
VisibilityState
ComputeVisibilityState
(
)
const
;
void
MaybeActiveMediaComponents
(
)
;
bool
ApplyFullscreen
(
const
FullscreenRequest
&
aRequest
)
;
bool
GetUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
return
mUseCounters
[
aUseCounter
]
;
}
void
SetChildDocumentUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
if
(
!
mChildDocumentUseCounters
[
aUseCounter
]
)
{
mChildDocumentUseCounters
[
aUseCounter
]
=
true
;
}
}
bool
GetChildDocumentUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
return
mChildDocumentUseCounters
[
aUseCounter
]
;
}
void
UpdateDocumentStates
(
mozilla
:
:
EventStates
)
;
void
AddOnDemandBuiltInUASheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
RemoveDocStyleSheetsFromStyleSets
(
)
;
void
RemoveStyleSheetsFromStyleSets
(
const
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aSheets
mozilla
:
:
SheetType
aType
)
;
void
ResetStylesheetsToURI
(
nsIURI
*
aURI
)
;
void
FillStyleSet
(
mozilla
:
:
StyleSetHandle
aStyleSet
)
;
void
AddStyleSheetToStyleSets
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
RemoveStyleSheetFromStyleSets
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
NotifyStyleSheetAdded
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aDocumentSheet
)
;
void
NotifyStyleSheetRemoved
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aDocumentSheet
)
;
void
NotifyStyleSheetApplicableStateChanged
(
)
;
void
EnableStyleSheetsForSetInternal
(
const
nsAString
&
aSheetSet
bool
aUpdateCSSLoader
)
;
private
:
mutable
std
:
:
bitset
<
eDeprecatedOperationCount
>
mDeprecationWarnedAbout
;
mutable
std
:
:
bitset
<
eDocumentWarningCount
>
mDocWarningWarnedAbout
;
mozilla
:
:
UniquePtr
<
SelectorCache
>
mServoSelectorCache
;
mozilla
:
:
UniquePtr
<
SelectorCache
>
mGeckoSelectorCache
;
protected
:
friend
class
nsDocumentOnStack
;
void
IncreaseStackRefCnt
(
)
{
+
+
mStackRefCnt
;
}
void
DecreaseStackRefCnt
(
)
{
if
(
-
-
mStackRefCnt
=
=
0
&
&
mNeedsReleaseAfterStackRefCntRelease
)
{
mNeedsReleaseAfterStackRefCntRelease
=
false
;
NS_RELEASE_THIS
(
)
;
}
}
~
nsIDocument
(
)
;
nsPropertyTable
*
GetExtraPropertyTable
(
uint16_t
aCategory
)
;
nsPIDOMWindowOuter
*
GetWindowInternal
(
)
const
;
nsIScriptGlobalObject
*
GetScriptHandlingObjectInternal
(
)
const
;
bool
InternalAllowXULXBL
(
)
;
virtual
void
WillDispatchMutationEvent
(
nsINode
*
aTarget
)
=
0
;
virtual
void
MutationEventDispatched
(
nsINode
*
aTarget
)
=
0
;
friend
class
mozAutoSubtreeModified
;
virtual
Element
*
GetNameSpaceElement
(
)
override
{
return
GetRootElement
(
)
;
}
void
SetContentTypeInternal
(
const
nsACString
&
aType
)
;
nsCString
GetContentTypeInternal
(
)
const
{
return
mContentType
;
}
mozilla
:
:
dom
:
:
XPathEvaluator
*
XPathEvaluator
(
)
;
void
UpdateFrameRequestCallbackSchedulingState
(
nsIPresShell
*
aOldShell
=
nullptr
)
;
bool
IsPotentiallyScrollable
(
mozilla
:
:
dom
:
:
HTMLBodyElement
*
aBody
)
;
nsIDocument
*
GetSameTypeParentDocument
(
)
;
nsIDocument
*
GetFirstParentDocumentWithSamePrincipal
(
nsIPrincipal
*
aPrincipal
)
;
void
ActivateByUserGesture
(
)
;
void
MaybeActivateByUserGesture
(
nsIPrincipal
*
aPrincipal
)
;
static
bool
MatchNameAttribute
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
;
static
void
*
UseExistingNameString
(
nsINode
*
aRootNode
const
nsString
*
aName
)
;
void
MaybeResolveReadyForIdle
(
)
;
nsCString
mReferrer
;
nsString
mLastModified
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIURI
>
mOriginalURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocURI
;
nsCOMPtr
<
nsIURI
>
mDocumentBaseURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocBaseURI
;
#
ifdef
MOZ_STYLO
RefPtr
<
mozilla
:
:
URLExtraData
>
mCachedURLData
;
#
endif
nsWeakPtr
mDocumentLoadGroup
;
bool
mReferrerPolicySet
;
ReferrerPolicyEnum
mReferrerPolicy
;
bool
mBlockAllMixedContent
;
bool
mBlockAllMixedContentPreloads
;
bool
mUpgradeInsecureRequests
;
bool
mUpgradeInsecurePreloads
;
mozilla
:
:
WeakPtr
<
nsDocShell
>
mDocumentContainer
;
NotNull
<
const
Encoding
*
>
mCharacterSet
;
int32_t
mCharacterSetSource
;
nsIDocument
*
mParentDocument
;
mozilla
:
:
dom
:
:
Element
*
mCachedRootElement
;
nsNodeInfoManager
*
mNodeInfoManager
;
RefPtr
<
mozilla
:
:
css
:
:
Loader
>
mCSSLoader
;
RefPtr
<
mozilla
:
:
css
:
:
ImageLoader
>
mStyleImageLoader
;
RefPtr
<
nsHTMLStyleSheet
>
mAttrStyleSheet
;
RefPtr
<
nsHTMLCSSStyleSheet
>
mStyleAttrStyleSheet
;
RefPtr
<
mozilla
:
:
dom
:
:
ImageTracker
>
mImageTracker
;
nsAutoPtr
<
nsTHashtable
<
nsPtrHashKey
<
nsISupports
>
>
>
mActivityObservers
;
nsTHashtable
<
nsPtrHashKey
<
mozilla
:
:
dom
:
:
Link
>
>
mStyledLinks
;
#
ifdef
DEBUG
bool
mStyledLinksCleared
;
#
endif
static
const
size_t
kSegmentSize
=
128
;
typedef
mozilla
:
:
SegmentedVector
<
nsCOMPtr
<
mozilla
:
:
dom
:
:
Link
>
kSegmentSize
InfallibleAllocPolicy
>
LinksToUpdateList
;
LinksToUpdateList
mLinksToUpdate
;
RefPtr
<
nsSMILAnimationController
>
mAnimationController
;
nsPropertyTable
mPropertyTable
;
nsTArray
<
nsAutoPtr
<
nsPropertyTable
>
>
mExtraPropertyTables
;
nsCOMPtr
<
nsIHTMLCollection
>
mChildrenCollection
;
RefPtr
<
mozilla
:
:
dom
:
:
FontFaceSet
>
mFontFaceSet
;
mozilla
:
:
TimeStamp
mLastFocusTime
;
mozilla
:
:
EventStates
mDocumentState
;
RefPtr
<
mozilla
:
:
dom
:
:
Promise
>
mReadyForIdle
;
RefPtr
<
mozilla
:
:
dom
:
:
AboutCapabilities
>
mAboutCapabilities
;
bool
mBidiEnabled
:
1
;
bool
mMathMLEnabled
:
1
;
bool
mIsInitialDocumentInWindow
:
1
;
bool
mIgnoreDocGroupMismatches
:
1
;
bool
mLoadedAsData
:
1
;
bool
mLoadedAsInteractiveData
:
1
;
bool
mMayStartLayout
:
1
;
bool
mHaveFiredTitleChange
:
1
;
bool
mIsShowing
:
1
;
bool
mVisible
:
1
;
bool
mHasReferrerPolicyCSP
:
1
;
bool
mRemovedFromDocShell
:
1
;
bool
mAllowDNSPrefetch
:
1
;
bool
mIsStaticDocument
:
1
;
bool
mCreatingStaticClone
:
1
;
bool
mInUnlinkOrDeletion
:
1
;
bool
mHasHadScriptHandlingObject
:
1
;
bool
mIsBeingUsedAsImage
:
1
;
bool
mIsSyntheticDocument
:
1
;
bool
mHasLinksToUpdateRunnable
:
1
;
bool
mFlushingPendingLinkUpdates
:
1
;
bool
mMayHaveDOMMutationObservers
:
1
;
bool
mMayHaveAnimationObservers
:
1
;
bool
mHasMixedActiveContentLoaded
:
1
;
bool
mHasMixedActiveContentBlocked
:
1
;
bool
mHasMixedDisplayContentLoaded
:
1
;
bool
mHasMixedDisplayContentBlocked
:
1
;
bool
mHasMixedContentObjectSubrequest
:
1
;
bool
mHasCSP
:
1
;
bool
mHasUnsafeEvalCSP
:
1
;
bool
mHasUnsafeInlineCSP
:
1
;
bool
mHasTrackingContentBlocked
:
1
;
bool
mHasTrackingContentLoaded
:
1
;
bool
mBFCacheDisallowed
:
1
;
bool
mHasHadDefaultView
:
1
;
bool
mStyleSheetChangeEventsEnabled
:
1
;
bool
mIsSrcdocDocument
:
1
;
bool
mDidDocumentOpen
:
1
;
bool
mHasDisplayDocument
:
1
;
bool
mFontFaceSetDirty
:
1
;
bool
mGetUserFontSetCalled
:
1
;
bool
mDidFireDOMContentLoaded
:
1
;
bool
mHasScrollLinkedEffect
:
1
;
bool
mFrameRequestCallbacksScheduled
:
1
;
bool
mIsTopLevelContentDocument
:
1
;
bool
mIsContentDocument
:
1
;
bool
mDidCallBeginLoad
:
1
;
bool
mBufferingCSPViolations
:
1
;
bool
mAllowPaymentRequest
:
1
;
bool
mEncodingMenuDisabled
:
1
;
bool
mIsShadowDOMEnabled
:
1
;
bool
mIsSVGGlyphsDocument
:
1
;
bool
mAllowUnsafeHTML
:
1
;
bool
mInDestructor
:
1
;
bool
mIsGoingAway
:
1
;
bool
mInXBLUpdate
:
1
;
bool
mNeedsReleaseAfterStackRefCntRelease
:
1
;
bool
mStyleSetFilled
:
1
;
bool
mSSApplicableStateNotificationPending
:
1
;
bool
mMayHaveTitleElement
:
1
;
bool
mDOMLoadingSet
:
1
;
bool
mDOMInteractiveSet
:
1
;
bool
mDOMCompleteSet
:
1
;
bool
mAutoFocusFired
:
1
;
enum
{
eScopedStyle_Unknown
eScopedStyle_Disabled
eScopedStyle_Enabled
}
;
unsigned
int
mIsScopedStyleEnabled
:
2
;
uint8_t
mPendingFullscreenRequests
;
nsCompatibility
mCompatMode
;
ReadyState
mReadyState
;
mozilla
:
:
StyleBackendType
mStyleBackendType
;
#
ifdef
MOZILLA_INTERNAL_API
mozilla
:
:
dom
:
:
VisibilityState
mVisibilityState
;
static_assert
(
sizeof
(
mozilla
:
:
dom
:
:
VisibilityState
)
=
=
sizeof
(
uint8_t
)
"
Error
size
of
mVisibilityState
and
mDummy
"
)
;
#
else
uint8_t
mDummy
;
#
endif
enum
Type
{
eUnknown
eHTML
eXHTML
eGenericXML
eSVG
eXUL
}
;
Type
mType
;
uint8_t
mDefaultElementType
;
enum
Tri
{
eTriUnset
=
0
eTriFalse
eTriTrue
}
;
Tri
mAllowXULXBL
;
nsCOMPtr
<
nsIScriptGlobalObject
>
mScriptGlobalObject
;
nsCOMPtr
<
nsIDocument
>
mOriginalDocument
;
uint32_t
mBidiOptions
;
uint32_t
mSandboxFlags
;
nsCString
mContentLanguage
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
private
:
nsCString
mContentType
;
protected
:
nsCOMPtr
<
nsISupports
>
mSecurityInfo
;
nsCOMPtr
<
nsIChannel
>
mFailedChannel
;
uint32_t
mPartID
;
uint32_t
mMarkedCCGeneration
;
nsIPresShell
*
mPresShell
;
nsCOMArray
<
nsINode
>
mSubtreeModifiedTargets
;
uint32_t
mSubtreeModifiedDepth
;
nsCOMPtr
<
nsIDocument
>
mDisplayDocument
;
uint32_t
mEventsSuppressed
;
uint32_t
mIgnoreDestructiveWritesCounter
;
int32_t
mFrameRequestCallbackCounter
;
uint32_t
mStaticCloneCount
;
nsTArray
<
nsWeakPtr
>
mBlockedTrackingNodes
;
nsPIDOMWindowInner
*
mWindow
;
nsCOMPtr
<
nsIDocumentEncoder
>
mCachedEncoder
;
struct
FrameRequest
;
nsTArray
<
FrameRequest
>
mFrameRequestCallbacks
;
nsIBFCacheEntry
*
mBFCacheEntry
;
nsString
mBaseTarget
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
mStateObjectContainer
;
nsCOMPtr
<
nsIVariant
>
mStateObjectCached
;
uint32_t
mInSyncOperationCount
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
dom
:
:
XPathEvaluator
>
mXPathEvaluator
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
AnonymousContent
>
>
mAnonymousContents
;
uint32_t
mBlockDOMContentLoaded
;
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
MediaQueryList
>
mDOMMediaQueryLists
;
nsTObserverArray
<
nsIDocumentObserver
*
>
mObservers
;
std
:
:
bitset
<
mozilla
:
:
eUseCounter_Count
>
mUseCounters
;
std
:
:
bitset
<
mozilla
:
:
eUseCounter_Count
>
mChildDocumentUseCounters
;
std
:
:
bitset
<
mozilla
:
:
eUseCounter_Count
>
mNotifiedPageForUseCounter
;
mozilla
:
:
Array
<
uint16_t
mozilla
:
:
eIncCounter_Count
>
mIncCounters
;
bool
mUserHasInteracted
;
bool
mUserHasActivatedInteraction
;
mozilla
:
:
TimeStamp
mPageUnloadingEventTimeStamp
;
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
nsTHashtable
<
nsCStringHashKey
>
mTrackingScripts
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mBufferedCSPViolations
;
nsTArray
<
nsCOMPtr
<
nsIPrincipal
>
>
mAncestorPrincipals
;
nsTArray
<
uint64_t
>
mAncestorOuterWindowIDs
;
nsCOMPtr
<
nsIParser
>
mParser
;
nsrefcnt
mStackRefCnt
;
nsWeakPtr
mWeakSink
;
uint32_t
mUpdateNestLevel
;
enum
ViewportType
{
DisplayWidthHeight
Specified
Unknown
}
;
ViewportType
mViewportType
;
PLDHashTable
*
mSubDocuments
;
nsDocHeaderData
*
mHeaderData
;
RefPtr
<
PrincipalFlashClassifier
>
mPrincipalFlashClassifier
;
mozilla
:
:
dom
:
:
FlashClassification
mFlashClassification
;
mozilla
:
:
Maybe
<
bool
>
mIsThirdParty
;
nsRevocableEventPtr
<
nsRunnableMethod
<
nsIDocument
void
false
>
>
mPendingTitleChangeEvent
;
RefPtr
<
nsDOMNavigationTiming
>
mTiming
;
mozilla
:
:
TimeStamp
mLoadingTimeStamp
;
nsWeakPtr
mAutoFocusElement
;
nsWeakPtr
mScopeObject
;
nsTHashtable
<
nsPtrHashKey
<
mozilla
:
:
dom
:
:
DOMIntersectionObserver
>
>
mIntersectionObservers
;
nsTArray
<
nsWeakPtr
>
mFullScreenStack
;
nsWeakPtr
mFullscreenRoot
;
RefPtr
<
mozilla
:
:
dom
:
:
DOMImplementation
>
mDOMImplementation
;
public
:
js
:
:
ExpandoAndGeneration
mExpandoAndGeneration
;
protected
:
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
mOnDemandBuiltInUASheets
;
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
mAdditionalSheets
[
AdditionalSheetTypeCount
]
;
nsString
mLastStyleSheetSet
;
RefPtr
<
nsDOMStyleSheetSetList
>
mStyleSheetSetList
;
nsTHashtable
<
nsPtrHashKey
<
nsSVGElement
>
>
mLazySVGPresElements
;
nsCOMPtr
<
nsINode
>
mServoRestyleRoot
;
uint32_t
mServoRestyleRootDirtyBits
;
uint32_t
mThrowOnDynamicMarkupInsertionCounter
;
uint32_t
mIgnoreOpensDuringUnloadCounter
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsIDocument
NS_IDOCUMENT_IID
)
class
MOZ_STACK_CLASS
mozAutoSubtreeModified
{
public
:
mozAutoSubtreeModified
(
nsIDocument
*
aSubtreeOwner
nsINode
*
aTarget
)
{
UpdateTarget
(
aSubtreeOwner
aTarget
)
;
}
~
mozAutoSubtreeModified
(
)
{
UpdateTarget
(
nullptr
nullptr
)
;
}
void
UpdateTarget
(
nsIDocument
*
aSubtreeOwner
nsINode
*
aTarget
)
{
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
MutationEventDispatched
(
mTarget
)
;
}
mTarget
=
aTarget
;
mSubtreeOwner
=
aSubtreeOwner
;
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
WillDispatchMutationEvent
(
mTarget
)
;
}
}
private
:
nsCOMPtr
<
nsINode
>
mTarget
;
nsCOMPtr
<
nsIDocument
>
mSubtreeOwner
;
}
;
class
MOZ_STACK_CLASS
nsAutoSyncOperation
{
public
:
explicit
nsAutoSyncOperation
(
nsIDocument
*
aDocument
)
;
~
nsAutoSyncOperation
(
)
;
private
:
nsCOMArray
<
nsIDocument
>
mDocuments
;
uint32_t
mMicroTaskLevel
;
}
;
class
MOZ_RAII
AutoSetThrowOnDynamicMarkupInsertionCounter
final
{
public
:
explicit
AutoSetThrowOnDynamicMarkupInsertionCounter
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
{
mDocument
-
>
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
~
AutoSetThrowOnDynamicMarkupInsertionCounter
(
)
{
mDocument
-
>
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
private
:
nsIDocument
*
mDocument
;
}
;
class
MOZ_RAII
IgnoreOpensDuringUnload
final
{
public
:
explicit
IgnoreOpensDuringUnload
(
nsIDocument
*
aDoc
)
:
mDoc
(
aDoc
)
{
mDoc
-
>
IncrementIgnoreOpensDuringUnloadCounter
(
)
;
}
~
IgnoreOpensDuringUnload
(
)
{
mDoc
-
>
DecrementIgnoreOpensDuringUnloadCounter
(
)
;
}
private
:
nsIDocument
*
mDoc
;
}
;
nsresult
NS_NewHTMLDocument
(
nsIDocument
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
)
;
nsresult
NS_NewXMLDocument
(
nsIDocument
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
bool
aIsPlainDocument
=
false
)
;
nsresult
NS_NewSVGDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
nsresult
NS_NewImageDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
nsresult
NS_NewVideoDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
nsresult
NS_NewDOMDocument
(
nsIDOMDocument
*
*
aInstancePtrResult
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
nsIDOMDocumentType
*
aDoctype
nsIURI
*
aDocumentURI
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
bool
aLoadedAsData
nsIGlobalObject
*
aEventObject
DocumentFlavor
aFlavor
)
;
nsresult
NS_NewXBLDocument
(
nsIDOMDocument
*
*
aInstancePtrResult
nsIURI
*
aDocumentURI
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
)
;
nsresult
NS_NewPluginDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
inline
nsIDocument
*
nsINode
:
:
GetOwnerDocument
(
)
const
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
return
ownerDoc
!
=
this
?
ownerDoc
:
nullptr
;
}
inline
nsINode
*
nsINode
:
:
OwnerDocAsNode
(
)
const
{
return
OwnerDoc
(
)
;
}
inline
mozilla
:
:
dom
:
:
ParentObject
nsINode
:
:
GetParentObject
(
)
const
{
mozilla
:
:
dom
:
:
ParentObject
p
(
OwnerDoc
(
)
)
;
p
.
mUseXBLScope
=
IsInAnonymousSubtree
(
)
&
&
!
IsAnonymousContentInSVGUseSubtree
(
)
;
return
p
;
}
#
endif
