#
ifndef
nsIDocument_h___
#
define
nsIDocument_h___
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
nsAttrAndChildArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIApplicationCache
.
h
"
#
include
"
nsIApplicationCacheContainer
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIParser
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIChannelEventSink
.
h
"
#
include
"
nsIProgressEventSink
.
h
"
#
include
"
nsISecurityEventSink
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIUUIDGenerator
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPropertyTable
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
mozilla
/
UseCounter
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
Units
.
h
"
#
include
"
nsContentListDeclarations
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
DispatcherTrait
.
h
"
#
include
"
mozilla
/
dom
/
DocumentOrShadowRoot
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
SegmentedVector
.
h
"
#
include
"
mozilla
/
ServoBindingTypes
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
<
bitset
>
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
#
ifdef
MOZILLA_INTERNAL_API
#
include
"
mozilla
/
dom
/
DocumentBinding
.
h
"
#
else
namespace
mozilla
{
namespace
dom
{
class
ElementCreationOptionsOrString
;
}
}
#
endif
class
gfxUserFontSet
;
class
imgIRequest
;
class
nsBindingManager
;
class
nsCachableElementsByNameNodeList
;
class
nsIDocShell
;
class
nsDocShell
;
class
nsDOMNavigationTiming
;
class
nsDOMStyleSheetSetList
;
class
nsFrameLoader
;
class
nsGlobalWindowInner
;
class
nsHTMLCSSStyleSheet
;
class
nsHTMLDocument
;
class
nsHTMLStyleSheet
;
class
nsGenericHTMLElement
;
class
nsAtom
;
class
nsIBFCacheEntry
;
class
nsIChannel
;
class
nsIContent
;
class
nsIContentSink
;
class
nsIDocShell
;
class
nsIDocShellTreeItem
;
class
nsIDocumentEncoder
;
class
nsIDocumentObserver
;
class
nsIHTMLCollection
;
class
nsILayoutHistoryState
;
class
nsILoadContext
;
class
nsIObjectLoadingContent
;
class
nsIObserver
;
class
nsIPrincipal
;
class
nsIRequest
;
class
nsIRunnable
;
class
nsISecurityConsoleMessage
;
class
nsIStreamListener
;
class
nsIStructuredCloneContainer
;
class
nsIURI
;
class
nsIVariant
;
class
nsViewManager
;
class
nsPresContext
;
class
nsRange
;
class
nsSMILAnimationController
;
class
nsSVGElement
;
class
nsTextNode
;
class
nsUnblockOnloadEvent
;
class
nsWindowSizes
;
class
nsDOMCaretPosition
;
class
nsViewportInfo
;
class
nsIGlobalObject
;
class
nsIXULWindow
;
namespace
mozilla
{
class
AbstractThread
;
class
CSSStyleSheet
;
class
Encoding
;
class
ErrorResult
;
class
EventStates
;
class
EventListenerManager
;
class
PendingAnimationTracker
;
class
ServoStyleSet
;
template
<
typename
>
class
OwningNonNull
;
struct
URLExtraData
;
namespace
css
{
class
Loader
;
class
ImageLoader
;
class
Rule
;
}
namespace
dom
{
class
Animation
;
class
AnonymousContent
;
class
Attr
;
class
BoxObject
;
class
ClientInfo
;
class
ClientState
;
class
CDATASection
;
class
Comment
;
struct
CustomElementDefinition
;
class
DocGroup
;
class
DocumentFragment
;
class
DocumentTimeline
;
class
DocumentType
;
class
DOMImplementation
;
class
DOMIntersectionObserver
;
class
DOMStringList
;
class
Element
;
struct
ElementCreationOptions
;
class
Event
;
class
EventTarget
;
class
FontFaceSet
;
class
FrameRequestCallback
;
struct
FullscreenRequest
;
class
ImageTracker
;
class
HTMLBodyElement
;
class
HTMLSharedElement
;
class
HTMLImageElement
;
struct
LifecycleCallbackArgs
;
class
Link
;
class
Location
;
class
MediaQueryList
;
class
GlobalObject
;
class
NodeFilter
;
class
NodeIterator
;
enum
class
OrientationType
:
uint8_t
;
class
ProcessingInstruction
;
class
Promise
;
class
ScriptLoader
;
class
Selection
;
class
ServiceWorkerDescriptor
;
class
StyleSheetList
;
class
SVGDocument
;
class
SVGSVGElement
;
class
Touch
;
class
TouchList
;
class
TreeWalker
;
class
XPathEvaluator
;
class
XPathExpression
;
class
XPathNSResolver
;
class
XPathResult
;
class
XULDocument
;
template
<
typename
>
class
Sequence
;
template
<
typename
typename
>
class
CallbackObjectHolder
;
enum
class
CallerType
:
uint32_t
;
}
}
#
define
NS_IDOCUMENT_IID
\
{
0xce1f7627
0x7109
0x4977
\
{
0xba
0x77
0x49
0x0f
0xfd
0xe0
0x7a
0xaa
}
}
enum
DocumentFlavor
{
DocumentFlavorLegacyGuess
DocumentFlavorHTML
DocumentFlavorSVG
DocumentFlavorPlain
}
;
#
define
NS_DOCUMENT_STATE_RTL_LOCALE
NS_DEFINE_EVENT_STATE_MACRO
(
0
)
#
define
NS_DOCUMENT_STATE_WINDOW_INACTIVE
NS_DEFINE_EVENT_STATE_MACRO
(
1
)
class
nsContentList
;
class
nsDocumentOnStack
;
class
nsDocHeaderData
{
public
:
nsDocHeaderData
(
nsAtom
*
aField
const
nsAString
&
aData
)
:
mField
(
aField
)
mData
(
aData
)
mNext
(
nullptr
)
{
}
~
nsDocHeaderData
(
void
)
{
delete
mNext
;
}
RefPtr
<
nsAtom
>
mField
;
nsString
mData
;
nsDocHeaderData
*
mNext
;
}
;
class
nsExternalResourceMap
{
typedef
bool
(
*
nsSubDocEnumFunc
)
(
nsIDocument
*
aDocument
void
*
aData
)
;
public
:
class
ExternalResourceLoad
:
public
nsISupports
{
public
:
virtual
~
ExternalResourceLoad
(
)
{
}
void
AddObserver
(
nsIObserver
*
aObserver
)
{
MOZ_ASSERT
(
aObserver
"
Must
have
observer
"
)
;
mObservers
.
AppendElement
(
aObserver
)
;
}
const
nsTArray
<
nsCOMPtr
<
nsIObserver
>
>
&
Observers
(
)
{
return
mObservers
;
}
protected
:
AutoTArray
<
nsCOMPtr
<
nsIObserver
>
8
>
mObservers
;
}
;
nsExternalResourceMap
(
)
;
nsIDocument
*
RequestResource
(
nsIURI
*
aURI
nsINode
*
aRequestingNode
nsIDocument
*
aDisplayDocument
ExternalResourceLoad
*
*
aPendingLoad
)
;
void
EnumerateResources
(
nsSubDocEnumFunc
aCallback
void
*
aData
)
;
void
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
const
;
void
Shutdown
(
)
{
mPendingLoads
.
Clear
(
)
;
mMap
.
Clear
(
)
;
mHaveShutDown
=
true
;
}
bool
HaveShutDown
(
)
const
{
return
mHaveShutDown
;
}
struct
ExternalResource
{
~
ExternalResource
(
)
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
nsCOMPtr
<
nsIContentViewer
>
mViewer
;
nsCOMPtr
<
nsILoadGroup
>
mLoadGroup
;
}
;
void
HideViewers
(
)
;
void
ShowViewers
(
)
;
protected
:
class
PendingLoad
:
public
ExternalResourceLoad
public
nsIStreamListener
{
~
PendingLoad
(
)
{
}
public
:
explicit
PendingLoad
(
nsIDocument
*
aDisplayDocument
)
:
mDisplayDocument
(
aDisplayDocument
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSISTREAMLISTENER
NS_DECL_NSIREQUESTOBSERVER
nsresult
StartLoad
(
nsIURI
*
aURI
nsINode
*
aRequestingNode
)
;
nsresult
SetupViewer
(
nsIRequest
*
aRequest
nsIContentViewer
*
*
aViewer
nsILoadGroup
*
*
aLoadGroup
)
;
private
:
nsCOMPtr
<
nsIDocument
>
mDisplayDocument
;
nsCOMPtr
<
nsIStreamListener
>
mTargetListener
;
nsCOMPtr
<
nsIURI
>
mURI
;
}
;
friend
class
PendingLoad
;
class
LoadgroupCallbacks
final
:
public
nsIInterfaceRequestor
{
~
LoadgroupCallbacks
(
)
{
}
public
:
explicit
LoadgroupCallbacks
(
nsIInterfaceRequestor
*
aOtherCallbacks
)
:
mCallbacks
(
aOtherCallbacks
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIINTERFACEREQUESTOR
private
:
nsCOMPtr
<
nsIInterfaceRequestor
>
mCallbacks
;
#
define
DECL_SHIM
(
_i
_allcaps
)
\
class
_i
#
#
Shim
final
:
public
nsIInterfaceRequestor
\
public
_i
\
{
\
~
_i
#
#
Shim
(
)
{
}
\
public
:
\
_i
#
#
Shim
(
nsIInterfaceRequestor
*
aIfreq
_i
*
aRealPtr
)
\
:
mIfReq
(
aIfreq
)
mRealPtr
(
aRealPtr
)
\
{
\
NS_ASSERTION
(
mIfReq
"
Expected
non
-
null
here
"
)
;
\
NS_ASSERTION
(
mRealPtr
"
Expected
non
-
null
here
"
)
;
\
}
\
NS_DECL_ISUPPORTS
\
NS_FORWARD_NSIINTERFACEREQUESTOR
(
mIfReq
-
>
)
\
NS_FORWARD_
#
#
_allcaps
(
mRealPtr
-
>
)
\
private
:
\
nsCOMPtr
<
nsIInterfaceRequestor
>
mIfReq
;
\
nsCOMPtr
<
_i
>
mRealPtr
;
\
}
;
DECL_SHIM
(
nsILoadContext
NSILOADCONTEXT
)
DECL_SHIM
(
nsIProgressEventSink
NSIPROGRESSEVENTSINK
)
DECL_SHIM
(
nsIChannelEventSink
NSICHANNELEVENTSINK
)
DECL_SHIM
(
nsISecurityEventSink
NSISECURITYEVENTSINK
)
DECL_SHIM
(
nsIApplicationCacheContainer
NSIAPPLICATIONCACHECONTAINER
)
#
undef
DECL_SHIM
}
;
nsresult
AddExternalResource
(
nsIURI
*
aURI
nsIContentViewer
*
aViewer
nsILoadGroup
*
aLoadGroup
nsIDocument
*
aDisplayDocument
)
;
nsClassHashtable
<
nsURIHashKey
ExternalResource
>
mMap
;
nsRefPtrHashtable
<
nsURIHashKey
PendingLoad
>
mPendingLoads
;
bool
mHaveShutDown
;
}
;
class
PrincipalFlashClassifier
;
class
nsIDocument
:
public
nsINode
public
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
public
mozilla
:
:
dom
:
:
DispatcherTrait
{
typedef
mozilla
:
:
dom
:
:
GlobalObject
GlobalObject
;
protected
:
using
Encoding
=
mozilla
:
:
Encoding
;
template
<
typename
T
>
using
NotNull
=
mozilla
:
:
NotNull
<
T
>
;
public
:
typedef
nsExternalResourceMap
:
:
ExternalResourceLoad
ExternalResourceLoad
;
typedef
mozilla
:
:
net
:
:
ReferrerPolicy
ReferrerPolicyEnum
;
typedef
mozilla
:
:
dom
:
:
Element
Element
;
typedef
mozilla
:
:
dom
:
:
FullscreenRequest
FullscreenRequest
;
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_IDOCUMENT_IID
)
#
ifdef
MOZILLA_INTERNAL_API
nsIDocument
(
)
;
#
endif
class
MOZ_RAII
PageUnloadingEventTimeStamp
{
nsCOMPtr
<
nsIDocument
>
mDocument
;
bool
mSet
;
public
:
explicit
PageUnloadingEventTimeStamp
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
mSet
(
false
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
mDocument
-
>
mPageUnloadingEventTimeStamp
.
IsNull
(
)
)
{
mDocument
-
>
SetPageUnloadingEventTimeStamp
(
)
;
mSet
=
true
;
}
}
~
PageUnloadingEventTimeStamp
(
)
{
if
(
mSet
)
{
mDocument
-
>
CleanUnloadEventsTimeStamp
(
)
;
}
}
}
;
virtual
nsresult
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
nsIContentSink
*
aSink
=
nullptr
)
=
0
;
virtual
void
StopDocumentLoad
(
)
=
0
;
virtual
void
SetSuppressParserErrorElement
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorElement
(
)
{
return
false
;
}
virtual
void
SetSuppressParserErrorConsoleMessages
(
bool
aSuppress
)
{
}
virtual
bool
SuppressParserErrorConsoleMessages
(
)
{
return
false
;
}
bool
IsNodeOfType
(
uint32_t
aFlags
)
const
final
;
nsIContent
*
GetChildAt_Deprecated
(
uint32_t
aIndex
)
const
final
{
return
mChildren
.
GetSafeChildAt
(
aIndex
)
;
}
int32_t
ComputeIndexOf
(
const
nsINode
*
aPossibleChild
)
const
final
{
return
mChildren
.
IndexOfChild
(
aPossibleChild
)
;
}
uint32_t
GetChildCount
(
)
const
final
{
return
mChildren
.
ChildCount
(
)
;
}
nsresult
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
)
override
;
void
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
final
;
nsresult
Clone
(
mozilla
:
:
dom
:
:
NodeInfo
*
aNodeInfo
nsINode
*
*
aResult
bool
aPreallocateChildren
)
const
override
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
void
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
;
nsIURI
*
GetDocumentURI
(
)
const
{
return
mDocumentURI
;
}
nsIURI
*
GetOriginalURI
(
)
const
{
return
mOriginalURI
;
}
void
SetDocumentURI
(
nsIURI
*
aURI
)
;
void
SetChromeXHRDocURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocURI
=
aURI
;
}
void
SetChromeXHRDocBaseURI
(
nsIURI
*
aURI
)
{
mChromeXHRDocBaseURI
=
aURI
;
}
void
ApplySettingsFromCSP
(
bool
aSpeculative
)
;
already_AddRefed
<
nsIParser
>
CreatorParserOrNull
(
)
{
nsCOMPtr
<
nsIParser
>
parser
=
mParser
;
return
parser
.
forget
(
)
;
}
ReferrerPolicyEnum
GetReferrerPolicy
(
)
const
{
return
mReferrerPolicy
;
}
uint32_t
ReferrerPolicy
(
)
const
{
return
GetReferrerPolicy
(
)
;
}
bool
GetBlockAllMixedContent
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mBlockAllMixedContentPreloads
;
}
return
mBlockAllMixedContent
;
}
bool
GetUpgradeInsecureRequests
(
bool
aPreload
)
const
{
if
(
aPreload
)
{
return
mUpgradeInsecurePreloads
;
}
return
mUpgradeInsecureRequests
;
}
void
SetReferrer
(
const
nsACString
&
aReferrer
)
{
mReferrer
=
aReferrer
;
}
void
SetPrincipal
(
nsIPrincipal
*
aPrincipal
)
;
const
nsTArray
<
nsCOMPtr
<
nsIPrincipal
>
>
&
AncestorPrincipals
(
)
const
{
return
mAncestorPrincipals
;
}
const
nsTArray
<
uint64_t
>
&
AncestorOuterWindowIDs
(
)
const
{
return
mAncestorOuterWindowIDs
;
}
already_AddRefed
<
nsILoadGroup
>
GetDocumentLoadGroup
(
)
const
{
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
return
group
.
forget
(
)
;
}
nsIURI
*
GetFallbackBaseURI
(
)
const
{
if
(
mIsSrcdocDocument
&
&
mParentDocument
)
{
return
mParentDocument
-
>
GetDocBaseURI
(
)
;
}
return
mDocumentURI
;
}
nsIURI
*
GetDocBaseURI
(
)
const
{
if
(
mDocumentBaseURI
)
{
return
mDocumentBaseURI
;
}
return
GetFallbackBaseURI
(
)
;
}
already_AddRefed
<
nsIURI
>
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
=
false
)
const
final
;
void
SetBaseURI
(
nsIURI
*
aURI
)
;
mozilla
:
:
URLExtraData
*
DefaultStyleAttrURLData
(
)
;
void
GetBaseTarget
(
nsAString
&
aBaseTarget
)
const
{
aBaseTarget
=
mBaseTarget
;
}
void
SetBaseTarget
(
const
nsString
&
aBaseTarget
)
{
mBaseTarget
=
aBaseTarget
;
}
NotNull
<
const
Encoding
*
>
GetDocumentCharacterSet
(
)
const
{
return
mCharacterSet
;
}
virtual
void
SetDocumentCharacterSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
;
int32_t
GetDocumentCharacterSetSource
(
)
const
{
return
mCharacterSetSource
;
}
void
SetDocumentCharacterSetSource
(
int32_t
aCharsetSource
)
{
mCharacterSetSource
=
aCharsetSource
;
}
void
GetContentType
(
nsAString
&
aContentType
)
;
virtual
void
SetContentType
(
const
nsAString
&
aContentType
)
;
void
GetContentLanguage
(
nsAString
&
aContentLanguage
)
const
{
CopyASCIItoUTF16
(
mContentLanguage
aContentLanguage
)
;
}
bool
GetBidiEnabled
(
)
const
{
return
mBidiEnabled
;
}
void
SetBidiEnabled
(
)
{
mBidiEnabled
=
true
;
}
void
SetMathMLEnabled
(
)
{
mMathMLEnabled
=
true
;
}
bool
IsInitialDocument
(
)
const
{
return
mIsInitialDocumentInWindow
;
}
void
SetIsInitialDocument
(
bool
aIsInitialDocument
)
{
mIsInitialDocumentInWindow
=
aIsInitialDocument
;
}
void
IgnoreDocGroupMismatches
(
)
{
mIgnoreDocGroupMismatches
=
true
;
}
uint32_t
GetBidiOptions
(
)
const
{
return
mBidiOptions
;
}
void
SetBidiOptions
(
uint32_t
aBidiOptions
)
{
mBidiOptions
=
aBidiOptions
;
}
bool
GetHasMixedActiveContentLoaded
(
)
{
return
mHasMixedActiveContentLoaded
;
}
void
SetHasMixedActiveContentLoaded
(
bool
aHasMixedActiveContentLoaded
)
{
mHasMixedActiveContentLoaded
=
aHasMixedActiveContentLoaded
;
}
bool
GetHasMixedActiveContentBlocked
(
)
{
return
mHasMixedActiveContentBlocked
;
}
void
SetHasMixedActiveContentBlocked
(
bool
aHasMixedActiveContentBlocked
)
{
mHasMixedActiveContentBlocked
=
aHasMixedActiveContentBlocked
;
}
bool
GetHasMixedDisplayContentLoaded
(
)
{
return
mHasMixedDisplayContentLoaded
;
}
void
SetHasMixedDisplayContentLoaded
(
bool
aHasMixedDisplayContentLoaded
)
{
mHasMixedDisplayContentLoaded
=
aHasMixedDisplayContentLoaded
;
}
bool
GetHasMixedDisplayContentBlocked
(
)
{
return
mHasMixedDisplayContentBlocked
;
}
void
SetHasMixedDisplayContentBlocked
(
bool
aHasMixedDisplayContentBlocked
)
{
mHasMixedDisplayContentBlocked
=
aHasMixedDisplayContentBlocked
;
}
void
SetHasMixedContentObjectSubrequest
(
bool
aHasMixedContentObjectSubrequest
)
{
mHasMixedContentObjectSubrequest
=
aHasMixedContentObjectSubrequest
;
}
void
SetHasCSP
(
bool
aHasCSP
)
{
mHasCSP
=
aHasCSP
;
}
void
SetHasUnsafeInlineCSP
(
bool
aHasUnsafeInlineCSP
)
{
mHasUnsafeInlineCSP
=
aHasUnsafeInlineCSP
;
}
void
SetHasUnsafeEvalCSP
(
bool
aHasUnsafeEvalCSP
)
{
mHasUnsafeEvalCSP
=
aHasUnsafeEvalCSP
;
}
bool
GetHasTrackingContentBlocked
(
)
{
return
mHasTrackingContentBlocked
;
}
void
SetHasTrackingContentBlocked
(
bool
aHasTrackingContentBlocked
)
{
mHasTrackingContentBlocked
=
aHasTrackingContentBlocked
;
}
bool
GetHasTrackingContentLoaded
(
)
{
return
mHasTrackingContentLoaded
;
}
void
SetHasTrackingContentLoaded
(
bool
aHasTrackingContentLoaded
)
{
mHasTrackingContentLoaded
=
aHasTrackingContentLoaded
;
}
uint32_t
GetSandboxFlags
(
)
const
{
return
mSandboxFlags
;
}
void
GetSandboxFlagsAsString
(
nsAString
&
aFlags
)
;
void
SetSandboxFlags
(
uint32_t
sandboxFlags
)
{
mSandboxFlags
=
sandboxFlags
;
}
void
EnableEncodingMenu
(
)
{
mEncodingMenuDisabled
=
false
;
}
void
GetHeaderData
(
nsAtom
*
aHeaderField
nsAString
&
aData
)
const
;
void
SetHeaderData
(
nsAtom
*
aheaderField
const
nsAString
&
aData
)
;
already_AddRefed
<
nsIPresShell
>
CreateShell
(
nsPresContext
*
aContext
nsViewManager
*
aViewManager
mozilla
:
:
UniquePtr
<
mozilla
:
:
ServoStyleSet
>
aStyleSet
)
;
void
DeleteShell
(
)
;
nsIPresShell
*
GetShell
(
)
const
{
return
GetBFCacheEntry
(
)
?
nullptr
:
mPresShell
;
}
nsIPresShell
*
GetObservingShell
(
)
const
{
return
mPresShell
&
&
mPresShell
-
>
IsObservingDocument
(
)
?
mPresShell
:
nullptr
;
}
bool
IsSafeToFlush
(
)
const
;
nsPresContext
*
GetPresContext
(
)
const
{
nsIPresShell
*
shell
=
GetShell
(
)
;
return
shell
?
shell
-
>
GetPresContext
(
)
:
nullptr
;
}
bool
HasShellOrBFCacheEntry
(
)
const
{
return
mPresShell
|
|
mBFCacheEntry
;
}
void
DisallowBFCaching
(
)
{
NS_ASSERTION
(
!
mBFCacheEntry
"
We
'
re
already
in
the
bfcache
!
"
)
;
mBFCacheDisallowed
=
true
;
}
bool
IsBFCachingAllowed
(
)
const
{
return
!
mBFCacheDisallowed
;
}
void
SetBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
;
nsIBFCacheEntry
*
GetBFCacheEntry
(
)
const
{
return
mBFCacheEntry
;
}
nsIDocument
*
GetParentDocument
(
)
const
{
return
mParentDocument
;
}
void
SetParentDocument
(
nsIDocument
*
aParent
)
{
mParentDocument
=
aParent
;
if
(
aParent
)
{
mIgnoreDocGroupMismatches
=
aParent
-
>
mIgnoreDocGroupMismatches
;
}
}
bool
GetAllowPlugins
(
)
;
nsresult
SetSubDocumentFor
(
Element
*
aContent
nsIDocument
*
aSubDoc
)
;
nsIDocument
*
GetSubDocumentFor
(
nsIContent
*
aContent
)
const
;
Element
*
FindContentForSubDocument
(
nsIDocument
*
aDocument
)
const
;
mozilla
:
:
dom
:
:
DocumentType
*
GetDoctype
(
)
const
;
Element
*
GetRootElement
(
)
const
;
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
mozilla
:
:
ErrorResult
&
aRv
)
;
virtual
nsIContent
*
GetUnfocusedKeyEventTarget
(
)
;
nsViewportInfo
GetViewportInfo
(
const
mozilla
:
:
ScreenIntSize
&
aDisplaySize
)
;
void
UpdateViewportOverflowType
(
nscoord
aScrolledWidth
nscoord
aScrollportWidth
)
;
virtual
bool
WillIgnoreCharsetOverride
(
)
{
return
true
;
}
bool
IsSrcdocDocument
(
)
const
{
return
mIsSrcdocDocument
;
}
void
SetIsSrcdocDocument
(
bool
aIsSrcdocDocument
)
{
mIsSrcdocDocument
=
aIsSrcdocDocument
;
}
nsresult
GetSrcdocData
(
nsAString
&
aSrcdocData
)
;
bool
DidDocumentOpen
(
)
{
return
mDidDocumentOpen
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
AnonymousContent
>
InsertAnonymousContent
(
mozilla
:
:
dom
:
:
Element
&
aElement
mozilla
:
:
ErrorResult
&
aError
)
;
void
RemoveAnonymousContent
(
mozilla
:
:
dom
:
:
AnonymousContent
&
aContent
mozilla
:
:
ErrorResult
&
aError
)
;
Element
*
GetAnonRootIfInAnonymousContentContainer
(
nsINode
*
aNode
)
const
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
AnonymousContent
>
>
&
GetAnonymousContents
(
)
{
return
mAnonymousContents
;
}
mozilla
:
:
TimeStamp
GetPageUnloadingEventTimeStamp
(
)
const
{
if
(
!
mParentDocument
)
{
return
mPageUnloadingEventTimeStamp
;
}
mozilla
:
:
TimeStamp
parentTimeStamp
(
mParentDocument
-
>
GetPageUnloadingEventTimeStamp
(
)
)
;
if
(
parentTimeStamp
.
IsNull
(
)
)
{
return
mPageUnloadingEventTimeStamp
;
}
if
(
!
mPageUnloadingEventTimeStamp
|
|
parentTimeStamp
<
mPageUnloadingEventTimeStamp
)
{
return
parentTimeStamp
;
}
return
mPageUnloadingEventTimeStamp
;
}
void
NotifyLayerManagerRecreated
(
)
;
void
ScheduleSVGForPresAttrEvaluation
(
nsSVGElement
*
aSVG
)
{
mLazySVGPresElements
.
PutEntry
(
aSVG
)
;
}
void
UnscheduleSVGForPresAttrEvaluation
(
nsSVGElement
*
aSVG
)
{
mLazySVGPresElements
.
RemoveEntry
(
aSVG
)
;
}
void
ResolveScheduledSVGPresAttrs
(
)
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientInfo
>
GetClientInfo
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ClientState
>
GetClientState
(
)
const
;
mozilla
:
:
Maybe
<
mozilla
:
:
dom
:
:
ServiceWorkerDescriptor
>
GetController
(
)
const
;
long
BlockedTrackingNodeCount
(
)
const
{
return
mBlockedTrackingNodes
.
Length
(
)
;
}
already_AddRefed
<
nsSimpleContentList
>
BlockedTrackingNodes
(
)
const
;
protected
:
friend
class
nsUnblockOnloadEvent
;
nsresult
InitCSP
(
nsIChannel
*
aChannel
)
;
void
PostUnblockOnloadEvent
(
)
;
void
DoUnblockOnload
(
)
;
void
ClearAllBoxObjects
(
)
;
void
MaybeEndOutermostXBLUpdate
(
)
;
void
DispatchContentLoadedEvents
(
)
;
void
DispatchPageTransition
(
mozilla
:
:
dom
:
:
EventTarget
*
aDispatchTarget
const
nsAString
&
aType
bool
aPersisted
)
;
void
DestroyElementMaps
(
)
;
Element
*
GetRootElementInternal
(
)
const
;
void
DoNotifyPossibleTitleChange
(
)
;
void
SetPageUnloadingEventTimeStamp
(
)
{
MOZ_ASSERT
(
!
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
mozilla
:
:
TimeStamp
:
:
NowLoRes
(
)
;
}
void
CleanUnloadEventsTimeStamp
(
)
{
MOZ_ASSERT
(
mPageUnloadingEventTimeStamp
)
;
mPageUnloadingEventTimeStamp
=
mozilla
:
:
TimeStamp
(
)
;
}
void
ClearStaleServoData
(
)
;
private
:
class
SelectorCacheKey
{
public
:
explicit
SelectorCacheKey
(
const
nsAString
&
aString
)
:
mKey
(
aString
)
{
MOZ_COUNT_CTOR
(
SelectorCacheKey
)
;
}
nsString
mKey
;
nsExpirationState
mState
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mState
;
}
~
SelectorCacheKey
(
)
{
MOZ_COUNT_DTOR
(
SelectorCacheKey
)
;
}
}
;
class
SelectorCacheKeyDeleter
;
public
:
class
SelectorCache
final
:
public
nsExpirationTracker
<
SelectorCacheKey
4
>
{
public
:
using
SelectorList
=
mozilla
:
:
UniquePtr
<
RawServoSelectorList
>
;
explicit
SelectorCache
(
nsIEventTarget
*
aEventTarget
)
;
void
CacheList
(
const
nsAString
&
aSelector
SelectorList
aSelectorList
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
SelectorCacheKey
*
key
=
new
SelectorCacheKey
(
aSelector
)
;
mTable
.
Put
(
key
-
>
mKey
std
:
:
move
(
aSelectorList
)
)
;
AddObject
(
key
)
;
}
void
NotifyExpired
(
SelectorCacheKey
*
aSelector
)
final
;
SelectorList
*
GetList
(
const
nsAString
&
aSelector
)
{
return
mTable
.
GetValue
(
aSelector
)
;
}
~
SelectorCache
(
)
;
private
:
nsDataHashtable
<
nsStringHashKey
SelectorList
>
mTable
;
}
;
SelectorCache
&
GetSelectorCache
(
)
{
if
(
!
mSelectorCache
)
{
mSelectorCache
=
mozilla
:
:
MakeUnique
<
SelectorCache
>
(
EventTargetFor
(
mozilla
:
:
TaskCategory
:
:
Other
)
)
;
}
return
*
mSelectorCache
;
}
Element
*
GetHtmlElement
(
)
const
;
Element
*
GetHtmlChildElement
(
nsAtom
*
aTag
)
;
mozilla
:
:
dom
:
:
HTMLBodyElement
*
GetBodyElement
(
)
;
Element
*
GetHeadElement
(
)
{
return
GetHtmlChildElement
(
nsGkAtoms
:
:
head
)
;
}
nsGenericHTMLElement
*
GetBody
(
)
;
void
SetBody
(
nsGenericHTMLElement
*
aBody
mozilla
:
:
ErrorResult
&
rv
)
;
mozilla
:
:
dom
:
:
HTMLSharedElement
*
GetHead
(
)
;
mozilla
:
:
dom
:
:
StyleSheetList
*
StyleSheets
(
)
{
return
&
DocumentOrShadowRoot
:
:
EnsureDOMStyleSheets
(
)
;
}
void
InsertSheetAt
(
size_t
aIndex
mozilla
:
:
StyleSheet
&
)
;
void
UpdateStyleSheets
(
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aOldSheets
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aNewSheets
)
;
void
AddStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
{
MOZ_ASSERT
(
aSheet
)
;
InsertSheetAt
(
SheetCount
(
)
*
aSheet
)
;
}
void
RemoveStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
SetStyleSheetApplicableState
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aApplicable
)
;
enum
additionalSheetType
{
eAgentSheet
eUserSheet
eAuthorSheet
AdditionalSheetTypeCount
}
;
nsresult
LoadAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
;
nsresult
AddAdditionalStyleSheet
(
additionalSheetType
aType
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
RemoveAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
sheetURI
)
;
mozilla
:
:
StyleSheet
*
GetFirstAdditionalAuthorSheet
(
)
{
return
mAdditionalSheets
[
eAuthorSheet
]
.
SafeElementAt
(
0
)
;
}
template
<
typename
T
>
size_t
FindDocStyleSheetInsertionPoint
(
const
nsTArray
<
T
>
&
aDocSheets
const
mozilla
:
:
StyleSheet
&
aSheet
)
;
mozilla
:
:
css
:
:
Loader
*
CSSLoader
(
)
const
{
return
mCSSLoader
;
}
mozilla
:
:
css
:
:
ImageLoader
*
StyleImageLoader
(
)
const
{
return
mStyleImageLoader
;
}
nsIChannel
*
GetChannel
(
)
const
{
return
mChannel
;
}
nsHTMLStyleSheet
*
GetAttributeStyleSheet
(
)
const
{
return
mAttrStyleSheet
;
}
nsHTMLCSSStyleSheet
*
GetInlineStyleSheet
(
)
const
{
return
mStyleAttrStyleSheet
;
}
virtual
void
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aGlobalObject
)
;
nsIScriptGlobalObject
*
GetScriptHandlingObject
(
bool
&
aHasHadScriptHandlingObject
)
const
{
aHasHadScriptHandlingObject
=
mHasHadScriptHandlingObject
;
return
mScriptGlobalObject
?
mScriptGlobalObject
.
get
(
)
:
GetScriptHandlingObjectInternal
(
)
;
}
void
SetScriptHandlingObject
(
nsIScriptGlobalObject
*
aScriptObject
)
;
nsIGlobalObject
*
GetScopeObject
(
)
const
;
void
SetScopeObject
(
nsIGlobalObject
*
aGlobal
)
;
nsPIDOMWindowOuter
*
GetWindow
(
)
const
{
return
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
GetWindowInternal
(
)
;
}
bool
IsInBackgroundWindow
(
)
const
{
auto
*
outer
=
mWindow
?
mWindow
-
>
GetOuterWindow
(
)
:
nullptr
;
return
outer
&
&
outer
-
>
IsBackground
(
)
;
}
nsPIDOMWindowInner
*
GetInnerWindow
(
)
const
{
return
mRemovedFromDocShell
?
nullptr
:
mWindow
;
}
uint64_t
OuterWindowID
(
)
const
{
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
uint64_t
InnerWindowID
(
)
const
{
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
return
window
?
window
-
>
WindowID
(
)
:
0
;
}
bool
IsTopLevelWindowInactive
(
)
const
;
mozilla
:
:
dom
:
:
ScriptLoader
*
ScriptLoader
(
)
{
return
mScriptLoader
;
}
void
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
;
void
AddToNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
void
RemoveFromNameTable
(
Element
*
aElement
nsAtom
*
aName
)
;
nsTArray
<
Element
*
>
GetFullscreenStack
(
)
const
;
void
AsyncRequestFullScreen
(
mozilla
:
:
UniquePtr
<
FullscreenRequest
>
&
&
)
;
bool
FullscreenElementReadyCheck
(
Element
*
aElement
bool
aWasCallerChrome
)
;
void
RequestFullScreen
(
mozilla
:
:
UniquePtr
<
FullscreenRequest
>
&
&
aRequest
)
;
void
CleanupFullscreenState
(
)
;
bool
FullScreenStackPush
(
Element
*
aElement
)
;
void
FullScreenStackPop
(
)
;
nsresult
RemoteFrameFullscreenChanged
(
mozilla
:
:
dom
:
:
Element
*
aFrameElement
)
;
nsresult
RemoteFrameFullscreenReverted
(
)
;
void
RestorePreviousFullScreenState
(
)
;
bool
IsFullscreenLeaf
(
)
;
nsIDocument
*
GetFullscreenRoot
(
)
;
void
SetFullscreenRoot
(
nsIDocument
*
aRoot
)
;
static
void
ExitFullscreenInDocTree
(
nsIDocument
*
aDocument
)
;
static
void
AsyncExitFullscreen
(
nsIDocument
*
aDocument
)
;
static
bool
HandlePendingFullscreenRequests
(
nsIDocument
*
aDocument
)
;
void
DispatchFullscreenError
(
const
char
*
aMessage
)
;
void
RequestPointerLock
(
Element
*
aElement
mozilla
:
:
dom
:
:
CallerType
)
;
bool
SetPointerLock
(
Element
*
aElement
int
aCursorStyle
)
;
static
void
UnlockPointer
(
nsIDocument
*
aDoc
=
nullptr
)
;
void
SetCurrentOrientation
(
mozilla
:
:
dom
:
:
OrientationType
aType
uint16_t
aAngle
)
{
mCurrentOrientationType
=
aType
;
mCurrentOrientationAngle
=
aAngle
;
}
uint16_t
CurrentOrientationAngle
(
)
const
{
return
mCurrentOrientationAngle
;
}
mozilla
:
:
dom
:
:
OrientationType
CurrentOrientationType
(
)
const
{
return
mCurrentOrientationType
;
}
void
SetOrientationPendingPromise
(
mozilla
:
:
dom
:
:
Promise
*
aPromise
)
;
mozilla
:
:
dom
:
:
Promise
*
GetOrientationPendingPromise
(
)
const
{
return
mOrientationPendingPromise
;
}
void
AddObserver
(
nsIDocumentObserver
*
aObserver
)
;
bool
RemoveObserver
(
nsIDocumentObserver
*
aObserver
)
;
void
BeginUpdate
(
)
;
virtual
void
EndUpdate
(
)
=
0
;
uint32_t
UpdateNestingLevel
(
)
{
return
mUpdateNestLevel
;
}
virtual
void
BeginLoad
(
)
=
0
;
virtual
void
EndLoad
(
)
=
0
;
enum
ReadyState
{
READYSTATE_UNINITIALIZED
=
0
READYSTATE_LOADING
=
1
READYSTATE_INTERACTIVE
=
3
READYSTATE_COMPLETE
=
4
}
;
void
SetReadyStateInternal
(
ReadyState
rs
)
;
ReadyState
GetReadyStateEnum
(
)
{
return
mReadyState
;
}
void
ContentStateChanged
(
nsIContent
*
aContent
mozilla
:
:
EventStates
aStateMask
)
;
void
DocumentStatesChanged
(
mozilla
:
:
EventStates
aStateMask
)
;
void
StyleRuleChanged
(
mozilla
:
:
StyleSheet
*
aStyleSheet
mozilla
:
:
css
:
:
Rule
*
aStyleRule
)
;
void
StyleRuleAdded
(
mozilla
:
:
StyleSheet
*
aStyleSheet
mozilla
:
:
css
:
:
Rule
*
aStyleRule
)
;
void
StyleRuleRemoved
(
mozilla
:
:
StyleSheet
*
aStyleSheet
mozilla
:
:
css
:
:
Rule
*
aStyleRule
)
;
void
FlushPendingNotifications
(
mozilla
:
:
FlushType
aType
)
;
void
FlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aFlush
)
;
void
FlushExternalResources
(
mozilla
:
:
FlushType
aType
)
;
nsBindingManager
*
BindingManager
(
)
const
{
return
mNodeInfoManager
-
>
GetBindingManager
(
)
;
}
nsNodeInfoManager
*
NodeInfoManager
(
)
const
{
return
mNodeInfoManager
;
}
virtual
void
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
;
virtual
void
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
)
;
virtual
void
SetContainer
(
nsDocShell
*
aContainer
)
;
virtual
nsISupports
*
GetContainer
(
)
const
;
nsILoadContext
*
GetLoadContext
(
)
const
;
nsIDocShell
*
GetDocShell
(
)
const
;
void
SetXMLDeclaration
(
const
char16_t
*
aVersion
const
char16_t
*
aEncoding
const
int32_t
aStandalone
)
;
void
GetXMLDeclaration
(
nsAString
&
aVersion
nsAString
&
aEncoding
nsAString
&
Standalone
)
;
bool
IsHTMLDocument
(
)
const
{
return
mType
=
=
eHTML
;
}
bool
IsHTMLOrXHTML
(
)
const
{
return
mType
=
=
eHTML
|
|
mType
=
=
eXHTML
;
}
bool
IsXMLDocument
(
)
const
{
return
!
IsHTMLDocument
(
)
;
}
bool
IsSVGDocument
(
)
const
{
return
mType
=
=
eSVG
;
}
bool
IsXULDocument
(
)
const
{
return
mType
=
=
eXUL
;
}
bool
IsUnstyledDocument
(
)
{
return
IsLoadedAsData
(
)
|
|
IsLoadedAsInteractiveData
(
)
;
}
bool
LoadsFullXULStyleSheetUpFront
(
)
{
if
(
IsXULDocument
(
)
)
{
return
true
;
}
if
(
IsSVGDocument
(
)
)
{
return
false
;
}
return
AllowXULXBL
(
)
;
}
bool
IsScriptEnabled
(
)
;
bool
IsTopLevelContentDocument
(
)
const
{
return
mIsTopLevelContentDocument
;
}
void
SetIsTopLevelContentDocument
(
bool
aIsTopLevelContentDocument
)
{
mIsTopLevelContentDocument
=
aIsTopLevelContentDocument
;
if
(
aIsTopLevelContentDocument
)
{
SetAllowPaymentRequest
(
true
)
;
}
}
bool
IsContentDocument
(
)
const
{
return
mIsContentDocument
;
}
void
SetIsContentDocument
(
bool
aIsContentDocument
)
{
mIsContentDocument
=
aIsContentDocument
;
}
already_AddRefed
<
Element
>
CreateElem
(
const
nsAString
&
aName
nsAtom
*
aPrefix
int32_t
aNamespaceID
const
nsAString
*
aIs
=
nullptr
)
;
nsISupports
*
GetSecurityInfo
(
)
{
return
mSecurityInfo
;
}
nsIChannel
*
GetFailedChannel
(
)
const
{
return
mFailedChannel
;
}
void
SetFailedChannel
(
nsIChannel
*
aChannel
)
{
mFailedChannel
=
aChannel
;
}
int32_t
GetDefaultNamespaceID
(
)
const
{
return
mDefaultElementType
;
}
void
DeleteAllProperties
(
)
;
void
DeleteAllPropertiesFor
(
nsINode
*
aNode
)
;
nsPropertyTable
&
PropertyTable
(
)
{
return
mPropertyTable
;
}
void
SetPartID
(
uint32_t
aID
)
{
mPartID
=
aID
;
}
uint32_t
GetPartID
(
)
const
{
return
mPartID
;
}
void
Sanitize
(
)
;
typedef
bool
(
*
nsSubDocEnumFunc
)
(
nsIDocument
*
aDocument
void
*
aData
)
;
void
EnumerateSubDocuments
(
nsSubDocEnumFunc
aCallback
void
*
aData
)
;
typedef
bool
(
*
nsDocTestFunc
)
(
const
nsIDocument
*
aDocument
)
;
void
CollectDescendantDocuments
(
nsTArray
<
nsCOMPtr
<
nsIDocument
>
>
&
aDescendants
nsDocTestFunc
aCallback
)
const
;
virtual
bool
CanSavePresentation
(
nsIRequest
*
aNewRequest
)
;
virtual
void
Destroy
(
)
=
0
;
virtual
void
RemovedFromDocShell
(
)
=
0
;
already_AddRefed
<
nsILayoutHistoryState
>
GetLayoutHistoryState
(
)
const
;
virtual
void
BlockOnload
(
)
=
0
;
virtual
void
UnblockOnload
(
bool
aFireSync
)
=
0
;
void
BlockDOMContentLoaded
(
)
{
+
+
mBlockDOMContentLoaded
;
}
void
UnblockDOMContentLoaded
(
)
;
virtual
void
OnPageShow
(
bool
aPersisted
mozilla
:
:
dom
:
:
EventTarget
*
aDispatchStartTarget
)
;
void
OnPageHide
(
bool
aPersisted
mozilla
:
:
dom
:
:
EventTarget
*
aDispatchStartTarget
)
;
void
AddStyleRelevantLink
(
mozilla
:
:
dom
:
:
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
mozilla
:
:
dom
:
:
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
!
entry
"
Document
already
knows
about
this
Link
!
"
)
;
mStyledLinksCleared
=
false
;
#
endif
mStyledLinks
.
PutEntry
(
aLink
)
;
}
void
ForgetLink
(
mozilla
:
:
dom
:
:
Link
*
aLink
)
{
NS_ASSERTION
(
aLink
"
Passing
in
a
null
link
.
Expect
crashes
RSN
!
"
)
;
#
ifdef
DEBUG
nsPtrHashKey
<
mozilla
:
:
dom
:
:
Link
>
*
entry
=
mStyledLinks
.
GetEntry
(
aLink
)
;
NS_ASSERTION
(
entry
|
|
mStyledLinksCleared
"
Document
knows
nothing
about
this
Link
!
"
)
;
#
endif
mStyledLinks
.
RemoveEntry
(
aLink
)
;
}
void
RefreshLinkHrefs
(
)
;
void
ClearBoxObjectFor
(
nsIContent
*
aContent
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
BoxObject
>
GetBoxObjectFor
(
mozilla
:
:
dom
:
:
Element
*
aElement
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
MediaQueryList
>
MatchMedia
(
const
nsAString
&
aMediaQueryList
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
MediaQueryList
>
&
MediaQueryLists
(
)
{
return
mDOMMediaQueryLists
;
}
nsCompatibility
GetCompatibilityMode
(
)
const
{
return
mCompatMode
;
}
bool
HaveFiredDOMTitleChange
(
)
const
{
return
mHaveFiredTitleChange
;
}
Element
*
GetAnonymousElementByAttribute
(
nsIContent
*
aElement
nsAtom
*
aAttrName
const
nsAString
&
aAttrValue
)
const
;
nsresult
NodesFromRectHelper
(
float
aX
float
aY
float
aTopSize
float
aRightSize
float
aBottomSize
float
aLeftSize
bool
aIgnoreRootScrollFrame
bool
aFlushLayout
nsINodeList
*
*
aReturn
)
;
void
FlushSkinBindings
(
)
;
void
MayDispatchMutationEvent
(
nsINode
*
aTarget
)
{
if
(
mSubtreeModifiedDepth
>
0
)
{
mSubtreeModifiedTargets
.
AppendObject
(
aTarget
)
;
}
}
void
MarkUncollectableForCCGeneration
(
uint32_t
aGeneration
)
{
mMarkedCCGeneration
=
aGeneration
;
}
uint32_t
GetMarkedCCGeneration
(
)
{
return
mMarkedCCGeneration
;
}
bool
IsCookieAverse
(
)
const
{
if
(
!
GetInnerWindow
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsIURI
>
codebaseURI
;
NodePrincipal
(
)
-
>
GetURI
(
getter_AddRefs
(
codebaseURI
)
)
;
if
(
!
codebaseURI
)
{
return
true
;
}
nsAutoCString
scheme
;
codebaseURI
-
>
GetScheme
(
scheme
)
;
return
!
scheme
.
EqualsLiteral
(
"
http
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
https
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
ftp
"
)
&
&
!
scheme
.
EqualsLiteral
(
"
file
"
)
;
}
bool
IsLoadedAsData
(
)
{
return
mLoadedAsData
;
}
bool
IsLoadedAsInteractiveData
(
)
{
return
mLoadedAsInteractiveData
;
}
bool
MayStartLayout
(
)
{
return
mMayStartLayout
;
}
virtual
void
SetMayStartLayout
(
bool
aMayStartLayout
)
;
already_AddRefed
<
nsIDocumentEncoder
>
GetCachedEncoder
(
)
;
void
SetCachedEncoder
(
already_AddRefed
<
nsIDocumentEncoder
>
aEncoder
)
;
nsresult
InitializeFrameLoader
(
nsFrameLoader
*
aLoader
)
;
nsresult
FinalizeFrameLoader
(
nsFrameLoader
*
aLoader
nsIRunnable
*
aFinalizer
)
;
void
TryCancelFrameLoaderInitialization
(
nsIDocShell
*
aShell
)
;
bool
IsRootDisplayDocument
(
)
const
{
return
!
mParentDocument
&
&
!
mDisplayDocument
;
}
bool
IsBeingUsedAsImage
(
)
const
{
return
mIsBeingUsedAsImage
;
}
void
SetIsBeingUsedAsImage
(
)
{
mIsBeingUsedAsImage
=
true
;
}
bool
IsSVGGlyphsDocument
(
)
const
{
return
mIsSVGGlyphsDocument
;
}
void
SetIsSVGGlyphsDocument
(
)
{
mIsSVGGlyphsDocument
=
true
;
}
bool
IsResourceDoc
(
)
const
{
return
IsBeingUsedAsImage
(
)
|
|
mHasDisplayDocument
;
}
nsIDocument
*
GetDisplayDocument
(
)
const
{
return
mDisplayDocument
;
}
void
SetDisplayDocument
(
nsIDocument
*
aDisplayDocument
)
{
MOZ_ASSERT
(
!
GetShell
(
)
&
&
!
GetContainer
(
)
&
&
!
GetWindow
(
)
"
Shouldn
'
t
set
mDisplayDocument
on
documents
that
already
"
"
have
a
presentation
or
a
docshell
or
a
window
"
)
;
MOZ_ASSERT
(
aDisplayDocument
"
Must
not
be
null
"
)
;
MOZ_ASSERT
(
aDisplayDocument
!
=
this
"
Should
be
different
document
"
)
;
MOZ_ASSERT
(
!
aDisplayDocument
-
>
GetDisplayDocument
(
)
"
Display
documents
should
not
nest
"
)
;
mDisplayDocument
=
aDisplayDocument
;
mHasDisplayDocument
=
!
!
aDisplayDocument
;
}
nsIDocument
*
RequestExternalResource
(
nsIURI
*
aURI
nsINode
*
aRequestingNode
ExternalResourceLoad
*
*
aPendingLoad
)
;
void
EnumerateExternalResources
(
nsSubDocEnumFunc
aCallback
void
*
aData
)
;
nsExternalResourceMap
&
ExternalResourceMap
(
)
{
return
mExternalResourceMap
;
}
bool
IsShowing
(
)
const
{
return
mIsShowing
;
}
bool
IsVisible
(
)
const
{
return
mVisible
;
}
bool
IsVisibleConsideringAncestors
(
)
const
;
bool
IsActive
(
)
const
{
return
mDocumentContainer
&
&
!
mRemovedFromDocShell
;
}
bool
IsCurrentActiveDocument
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
return
inner
&
&
inner
-
>
IsCurrentInnerWindow
(
)
&
&
inner
-
>
GetDoc
(
)
=
=
this
;
}
bool
ShouldLoadImages
(
)
const
{
return
IsCurrentActiveDocument
(
)
|
|
IsBeingUsedAsImage
(
)
;
}
void
RegisterActivityObserver
(
nsISupports
*
aSupports
)
;
bool
UnregisterActivityObserver
(
nsISupports
*
aSupports
)
;
typedef
void
(
*
ActivityObserverEnumerator
)
(
nsISupports
*
void
*
)
;
void
EnumerateActivityObservers
(
ActivityObserverEnumerator
aEnumerator
void
*
aData
)
;
bool
HasAnimationController
(
)
{
return
!
!
mAnimationController
;
}
nsSMILAnimationController
*
GetAnimationController
(
)
;
mozilla
:
:
PendingAnimationTracker
*
GetPendingAnimationTracker
(
)
{
return
mPendingAnimationTracker
;
}
mozilla
:
:
PendingAnimationTracker
*
GetOrCreatePendingAnimationTracker
(
)
;
void
SuppressEventHandling
(
uint32_t
aIncrease
=
1
)
;
void
UnsuppressEventHandlingAndFireEvents
(
bool
aFireEvents
)
;
uint32_t
EventHandlingSuppressed
(
)
const
{
return
mEventsSuppressed
;
}
bool
IsEventHandlingEnabled
(
)
{
return
!
EventHandlingSuppressed
(
)
&
&
mScriptGlobalObject
;
}
void
DecreaseEventSuppression
(
)
{
MOZ_ASSERT
(
mEventsSuppressed
)
;
-
-
mEventsSuppressed
;
UpdateFrameRequestCallbackSchedulingState
(
)
;
}
void
IncrementIgnoreDestructiveWritesCounter
(
)
{
+
+
mIgnoreDestructiveWritesCounter
;
}
void
DecrementIgnoreDestructiveWritesCounter
(
)
{
-
-
mIgnoreDestructiveWritesCounter
;
}
bool
IsDNSPrefetchAllowed
(
)
const
{
return
mAllowDNSPrefetch
;
}
bool
AllowXULXBL
(
)
{
return
mAllowXULXBL
=
=
eTriTrue
?
true
:
mAllowXULXBL
=
=
eTriFalse
?
false
:
InternalAllowXULXBL
(
)
;
}
void
ForceEnableXULXBL
(
)
{
mAllowXULXBL
=
eTriTrue
;
}
nsIDocument
*
GetTemplateContentsOwner
(
)
;
bool
IsStaticDocument
(
)
{
return
mIsStaticDocument
;
}
virtual
already_AddRefed
<
nsIDocument
>
CreateStaticClone
(
nsIDocShell
*
aCloneContainer
)
;
nsIDocument
*
GetOriginalDocument
(
)
{
MOZ_ASSERT
(
!
mOriginalDocument
|
|
!
mOriginalDocument
-
>
GetOriginalDocument
(
)
)
;
return
mOriginalDocument
;
}
void
UnlinkOriginalDocumentIfStatic
(
)
;
void
PreloadPictureOpened
(
)
{
mPreloadPictureDepth
+
+
;
}
void
PreloadPictureClosed
(
)
;
void
PreloadPictureImageSource
(
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
)
;
already_AddRefed
<
nsIURI
>
ResolvePreloadImage
(
nsIURI
*
aBaseURI
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
bool
*
aIsImgSet
)
;
void
MaybePreLoadImage
(
nsIURI
*
uri
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
bool
aIsImgSet
)
;
void
ForgetImagePreload
(
nsIURI
*
aURI
)
;
void
PreloadStyle
(
nsIURI
*
aURI
const
mozilla
:
:
Encoding
*
aEncoding
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
const
nsAString
&
aIntegrity
)
;
nsresult
LoadChromeSheetSync
(
nsIURI
*
aURI
bool
aIsAgentSheet
RefPtr
<
mozilla
:
:
StyleSheet
>
*
aSheet
)
;
virtual
bool
IsDocumentRightToLeft
(
)
{
return
false
;
}
void
MaybePreconnect
(
nsIURI
*
uri
mozilla
:
:
CORSMode
aCORSMode
)
;
enum
DocumentTheme
{
Doc_Theme_Uninitialized
Doc_Theme_None
Doc_Theme_Neutral
Doc_Theme_Dark
Doc_Theme_Bright
}
;
void
SetStateObject
(
nsIStructuredCloneContainer
*
scContainer
)
;
virtual
DocumentTheme
GetDocumentLWTheme
(
)
{
return
Doc_Theme_None
;
}
virtual
DocumentTheme
ThreadSafeGetDocumentLWTheme
(
)
const
{
return
Doc_Theme_None
;
}
mozilla
:
:
EventStates
GetDocumentState
(
)
const
{
return
mDocumentState
;
}
nsISupports
*
GetCurrentContentSink
(
)
;
void
SetAutoFocusElement
(
Element
*
aAutoFocusElement
)
;
void
TriggerAutoFocus
(
)
;
void
SetScrollToRef
(
nsIURI
*
aDocumentURI
)
;
void
ScrollToRef
(
)
;
void
ResetScrolledToRefAlready
(
)
{
mScrolledToRefAlready
=
false
;
}
void
SetChangeScrollPosWhenScrollingToRef
(
bool
aValue
)
{
mChangeScrollPosWhenScrollingToRef
=
aValue
;
}
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementById
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByTagName
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByTagNameNS
;
using
mozilla
:
:
dom
:
:
DocumentOrShadowRoot
:
:
GetElementsByClassName
;
Element
*
LookupImageElement
(
const
nsAString
&
aElementId
)
;
mozilla
:
:
dom
:
:
DocumentTimeline
*
Timeline
(
)
;
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
DocumentTimeline
>
&
Timelines
(
)
{
return
mTimelines
;
}
void
GetAnimations
(
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Animation
>
>
&
aAnimations
)
;
mozilla
:
:
dom
:
:
SVGSVGElement
*
GetSVGRootElement
(
)
const
;
nsresult
ScheduleFrameRequestCallback
(
mozilla
:
:
dom
:
:
FrameRequestCallback
&
aCallback
int32_t
*
aHandle
)
;
void
CancelFrameRequestCallback
(
int32_t
aHandle
)
;
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
FrameRequestCallback
>
>
FrameRequestCallbackList
;
void
TakeFrameRequestCallbacks
(
FrameRequestCallbackList
&
aCallbacks
)
;
bool
ShouldThrottleFrameRequests
(
)
;
bool
InUnlinkOrDeletion
(
)
{
return
mInUnlinkOrDeletion
;
}
mozilla
:
:
dom
:
:
ImageTracker
*
ImageTracker
(
)
;
void
AddPlugin
(
nsIObjectLoadingContent
*
aPlugin
)
{
MOZ_ASSERT
(
aPlugin
)
;
mPlugins
.
PutEntry
(
aPlugin
)
;
}
void
RemovePlugin
(
nsIObjectLoadingContent
*
aPlugin
)
{
MOZ_ASSERT
(
aPlugin
)
;
mPlugins
.
RemoveEntry
(
aPlugin
)
;
}
void
GetPlugins
(
nsTArray
<
nsIObjectLoadingContent
*
>
&
aPlugins
)
;
void
AddResponsiveContent
(
mozilla
:
:
dom
:
:
HTMLImageElement
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
mResponsiveContent
.
PutEntry
(
aContent
)
;
}
void
RemoveResponsiveContent
(
mozilla
:
:
dom
:
:
HTMLImageElement
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
mResponsiveContent
.
RemoveEntry
(
aContent
)
;
}
void
AddComposedDocShadowRoot
(
mozilla
:
:
dom
:
:
ShadowRoot
&
aShadowRoot
)
{
MOZ_ASSERT
(
IsShadowDOMEnabled
(
)
)
;
mComposedShadowRoots
.
PutEntry
(
&
aShadowRoot
)
;
}
using
ShadowRootSet
=
nsTHashtable
<
nsPtrHashKey
<
mozilla
:
:
dom
:
:
ShadowRoot
>
>
;
void
RemoveComposedDocShadowRoot
(
mozilla
:
:
dom
:
:
ShadowRoot
&
aShadowRoot
)
{
MOZ_ASSERT
(
IsShadowDOMEnabled
(
)
)
;
mComposedShadowRoots
.
RemoveEntry
(
&
aShadowRoot
)
;
}
bool
IsComposedDocShadowRoot
(
mozilla
:
:
dom
:
:
ShadowRoot
&
aShadowRoot
)
{
return
mComposedShadowRoots
.
Contains
(
&
aShadowRoot
)
;
}
const
ShadowRootSet
&
ComposedShadowRoots
(
)
const
{
return
mComposedShadowRoots
;
}
void
NotifyMediaFeatureValuesChanged
(
)
;
nsresult
GetStateObject
(
nsIVariant
*
*
aResult
)
;
nsDOMNavigationTiming
*
GetNavigationTiming
(
)
const
{
return
mTiming
;
}
void
SetNavigationTiming
(
nsDOMNavigationTiming
*
aTiming
)
;
nsContentList
*
ImageMapList
(
)
;
void
RegisterPendingLinkUpdate
(
mozilla
:
:
dom
:
:
Link
*
aLink
)
;
void
FlushPendingLinkUpdates
(
)
;
void
FlushPendingLinkUpdatesFromRunnable
(
)
;
#
define
DEPRECATED_OPERATION
(
_op
)
e
#
#
_op
enum
DeprecatedOperations
{
#
include
"
nsDeprecatedOperationList
.
h
"
eDeprecatedOperationCount
}
;
#
undef
DEPRECATED_OPERATION
bool
HasWarnedAbout
(
DeprecatedOperations
aOperation
)
const
;
void
WarnOnceAbout
(
DeprecatedOperations
aOperation
bool
asError
=
false
)
const
;
#
define
DOCUMENT_WARNING
(
_op
)
e
#
#
_op
enum
DocumentWarnings
{
#
include
"
nsDocumentWarningList
.
h
"
eDocumentWarningCount
}
;
#
undef
DOCUMENT_WARNING
bool
HasWarnedAbout
(
DocumentWarnings
aWarning
)
const
;
void
WarnOnceAbout
(
DocumentWarnings
aWarning
bool
asError
=
false
const
char16_t
*
*
aParams
=
nullptr
uint32_t
aParamsLength
=
0
)
const
;
void
PostVisibilityUpdateEvent
(
)
;
bool
IsSyntheticDocument
(
)
const
{
return
mIsSyntheticDocument
;
}
virtual
void
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
virtual
void
DocAddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
;
bool
MayHaveDOMMutationObservers
(
)
{
return
mMayHaveDOMMutationObservers
;
}
void
SetMayHaveDOMMutationObservers
(
)
{
mMayHaveDOMMutationObservers
=
true
;
}
bool
MayHaveAnimationObservers
(
)
{
return
mMayHaveAnimationObservers
;
}
void
SetMayHaveAnimationObservers
(
)
{
mMayHaveAnimationObservers
=
true
;
}
bool
IsInSyncOperation
(
)
{
return
mInSyncOperationCount
!
=
0
;
}
void
SetIsInSyncOperation
(
bool
aSync
)
{
if
(
aSync
)
{
+
+
mInSyncOperationCount
;
}
else
{
-
-
mInSyncOperationCount
;
}
}
bool
CreatingStaticClone
(
)
const
{
return
mCreatingStaticClone
;
}
already_AddRefed
<
Element
>
CreateHTMLElement
(
nsAtom
*
aTag
)
;
nsIGlobalObject
*
GetParentObject
(
)
const
{
return
GetScopeObject
(
)
;
}
static
already_AddRefed
<
nsIDocument
>
Constructor
(
const
GlobalObject
&
aGlobal
mozilla
:
:
ErrorResult
&
rv
)
;
mozilla
:
:
dom
:
:
DOMImplementation
*
GetImplementation
(
mozilla
:
:
ErrorResult
&
rv
)
;
MOZ_MUST_USE
nsresult
GetURL
(
nsString
&
retval
)
const
;
MOZ_MUST_USE
nsresult
GetDocumentURI
(
nsString
&
retval
)
const
;
void
GetDocumentURIFromJS
(
nsString
&
aDocumentURI
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
aRv
)
const
;
void
GetCompatMode
(
nsString
&
retval
)
const
;
void
GetCharacterSet
(
nsAString
&
retval
)
const
;
Element
*
GetDocumentElement
(
)
const
{
return
GetRootElement
(
)
;
}
enum
ElementCallbackType
{
eConnected
eDisconnected
eAdopted
eAttributeChanged
}
;
nsIDocument
*
GetTopLevelContentDocument
(
)
;
already_AddRefed
<
nsIXULWindow
>
GetXULWindowIfToplevelChrome
(
)
const
;
already_AddRefed
<
Element
>
CreateElement
(
const
nsAString
&
aTagName
const
mozilla
:
:
dom
:
:
ElementCreationOptionsOrString
&
aOptions
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
Element
>
CreateElementNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
const
mozilla
:
:
dom
:
:
ElementCreationOptionsOrString
&
aOptions
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
DocumentFragment
>
CreateDocumentFragment
(
)
const
;
already_AddRefed
<
nsTextNode
>
CreateTextNode
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
nsTextNode
>
CreateEmptyTextNode
(
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Comment
>
CreateComment
(
const
nsAString
&
aData
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
ProcessingInstruction
>
CreateProcessingInstruction
(
const
nsAString
&
target
const
nsAString
&
data
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsINode
>
ImportNode
(
nsINode
&
aNode
bool
aDeep
mozilla
:
:
ErrorResult
&
rv
)
const
;
nsINode
*
AdoptNode
(
nsINode
&
aNode
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Event
>
CreateEvent
(
const
nsAString
&
aEventType
mozilla
:
:
dom
:
:
CallerType
aCallerType
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
nsRange
>
CreateRange
(
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
NodeIterator
>
CreateNodeIterator
(
nsINode
&
aRoot
uint32_t
aWhatToShow
mozilla
:
:
dom
:
:
NodeFilter
*
aFilter
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TreeWalker
>
CreateTreeWalker
(
nsINode
&
aRoot
uint32_t
aWhatToShow
mozilla
:
:
dom
:
:
NodeFilter
*
aFilter
mozilla
:
:
ErrorResult
&
rv
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
CDATASection
>
CreateCDATASection
(
const
nsAString
&
aData
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Attr
>
CreateAttribute
(
const
nsAString
&
aName
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Attr
>
CreateAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
mozilla
:
:
ErrorResult
&
rv
)
;
void
GetInputEncoding
(
nsAString
&
aInputEncoding
)
const
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Location
>
GetLocation
(
)
const
;
void
GetReferrer
(
nsAString
&
aReferrer
)
const
;
void
GetLastModified
(
nsAString
&
aLastModified
)
const
;
void
GetReadyState
(
nsAString
&
aReadyState
)
const
;
void
GetTitle
(
nsAString
&
aTitle
)
;
void
SetTitle
(
const
nsAString
&
aTitle
mozilla
:
:
ErrorResult
&
rv
)
;
void
GetDir
(
nsAString
&
aDirection
)
const
;
void
SetDir
(
const
nsAString
&
aDirection
)
;
nsIHTMLCollection
*
Images
(
)
;
nsIHTMLCollection
*
Embeds
(
)
;
nsIHTMLCollection
*
Plugins
(
)
{
return
Embeds
(
)
;
}
nsIHTMLCollection
*
Links
(
)
;
nsIHTMLCollection
*
Forms
(
)
;
nsIHTMLCollection
*
Scripts
(
)
;
already_AddRefed
<
nsContentList
>
GetElementsByName
(
const
nsAString
&
aName
)
{
return
GetFuncStringContentList
<
nsCachableElementsByNameNodeList
>
(
this
MatchNameAttribute
nullptr
UseExistingNameString
aName
)
;
}
nsPIDOMWindowOuter
*
GetDefaultView
(
)
const
{
return
GetWindow
(
)
;
}
Element
*
GetActiveElement
(
)
;
bool
HasFocus
(
mozilla
:
:
ErrorResult
&
rv
)
const
;
nsIHTMLCollection
*
Applets
(
)
;
nsIHTMLCollection
*
Anchors
(
)
;
mozilla
:
:
TimeStamp
LastFocusTime
(
)
const
;
void
SetLastFocusTime
(
const
mozilla
:
:
TimeStamp
&
aFocusTime
)
;
bool
MozSyntheticDocument
(
)
const
{
return
IsSyntheticDocument
(
)
;
}
Element
*
GetCurrentScript
(
)
;
void
ReleaseCapture
(
)
const
;
void
MozSetImageElement
(
const
nsAString
&
aImageElementId
Element
*
aElement
)
;
nsIURI
*
GetDocumentURIObject
(
)
const
;
bool
FullscreenEnabled
(
mozilla
:
:
dom
:
:
CallerType
aCallerType
)
;
Element
*
FullScreenStackTop
(
)
;
bool
Fullscreen
(
)
{
return
!
!
GetFullscreenElement
(
)
;
}
void
ExitFullscreen
(
)
;
void
ExitPointerLock
(
)
{
UnlockPointer
(
this
)
;
}
static
bool
IsUnprefixedFullscreenEnabled
(
JSContext
*
aCx
JSObject
*
aObject
)
;
#
ifdef
MOZILLA_INTERNAL_API
bool
Hidden
(
)
const
{
return
mVisibilityState
!
=
mozilla
:
:
dom
:
:
VisibilityState
:
:
Visible
;
}
mozilla
:
:
dom
:
:
VisibilityState
VisibilityState
(
)
const
{
return
mVisibilityState
;
}
#
endif
void
GetSelectedStyleSheetSet
(
nsAString
&
aSheetSet
)
;
void
SetSelectedStyleSheetSet
(
const
nsAString
&
aSheetSet
)
;
void
GetLastStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
=
mLastStyleSheetSet
;
}
const
nsString
&
GetCurrentStyleSheetSet
(
)
const
{
return
mLastStyleSheetSet
.
IsEmpty
(
)
?
mPreferredStyleSheetSet
:
mLastStyleSheetSet
;
}
void
SetPreferredStyleSheetSet
(
const
nsAString
&
)
;
void
GetPreferredStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
=
mPreferredStyleSheetSet
;
}
mozilla
:
:
dom
:
:
DOMStringList
*
StyleSheetSets
(
)
;
void
EnableStyleSheetsForSet
(
const
nsAString
&
aSheetSet
)
;
already_AddRefed
<
nsDOMCaretPosition
>
CaretPositionFromPoint
(
float
aX
float
aY
)
;
Element
*
GetScrollingElement
(
)
;
bool
IsScrollingElement
(
Element
*
aElement
)
;
nsINodeList
*
GetAnonymousNodes
(
Element
&
aElement
)
;
Element
*
GetAnonymousElementByAttribute
(
Element
&
aElement
const
nsAString
&
aAttrName
const
nsAString
&
aAttrValue
)
;
Element
*
GetBindingParent
(
nsINode
&
aNode
)
;
void
LoadBindingDocument
(
const
nsAString
&
aURI
nsIPrincipal
&
aSubjectPrincipal
mozilla
:
:
ErrorResult
&
rv
)
;
mozilla
:
:
dom
:
:
XPathExpression
*
CreateExpression
(
const
nsAString
&
aExpression
mozilla
:
:
dom
:
:
XPathNSResolver
*
aResolver
mozilla
:
:
ErrorResult
&
rv
)
;
nsINode
*
CreateNSResolver
(
nsINode
&
aNodeResolver
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
XPathResult
>
Evaluate
(
JSContext
*
aCx
const
nsAString
&
aExpression
nsINode
&
aContextNode
mozilla
:
:
dom
:
:
XPathNSResolver
*
aResolver
uint16_t
aType
JS
:
:
Handle
<
JSObject
*
>
aResult
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Touch
>
CreateTouch
(
nsGlobalWindowInner
*
aView
mozilla
:
:
dom
:
:
EventTarget
*
aTarget
int32_t
aIdentifier
int32_t
aPageX
int32_t
aPageY
int32_t
aScreenX
int32_t
aScreenY
int32_t
aClientX
int32_t
aClientY
int32_t
aRadiusX
int32_t
aRadiusY
float
aRotationAngle
float
aForce
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TouchList
>
CreateTouchList
(
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TouchList
>
CreateTouchList
(
mozilla
:
:
dom
:
:
Touch
&
aTouch
const
mozilla
:
:
dom
:
:
Sequence
<
mozilla
:
:
OwningNonNull
<
mozilla
:
:
dom
:
:
Touch
>
>
&
aTouches
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
TouchList
>
CreateTouchList
(
const
mozilla
:
:
dom
:
:
Sequence
<
mozilla
:
:
OwningNonNull
<
mozilla
:
:
dom
:
:
Touch
>
>
&
aTouches
)
;
void
SetStyleSheetChangeEventsEnabled
(
bool
aValue
)
{
mStyleSheetChangeEventsEnabled
=
aValue
;
}
bool
StyleSheetChangeEventsEnabled
(
)
const
{
return
mStyleSheetChangeEventsEnabled
;
}
void
ObsoleteSheet
(
nsIURI
*
aSheetURI
mozilla
:
:
ErrorResult
&
rv
)
;
void
ObsoleteSheet
(
const
nsAString
&
aSheetURI
mozilla
:
:
ErrorResult
&
rv
)
;
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
BlockParsing
(
mozilla
:
:
dom
:
:
Promise
&
aPromise
const
mozilla
:
:
dom
:
:
BlockParsingOptions
&
aOptions
mozilla
:
:
ErrorResult
&
aRv
)
;
already_AddRefed
<
nsIURI
>
GetMozDocumentURIIfNotForErrorPages
(
)
;
mozilla
:
:
dom
:
:
Promise
*
GetDocumentReadyForIdle
(
mozilla
:
:
ErrorResult
&
aRv
)
;
nsIHTMLCollection
*
Children
(
)
;
uint32_t
ChildElementCount
(
)
;
inline
nsHTMLDocument
*
AsHTMLDocument
(
)
;
inline
mozilla
:
:
dom
:
:
SVGDocument
*
AsSVGDocument
(
)
;
inline
mozilla
:
:
dom
:
:
XULDocument
*
AsXULDocument
(
)
;
void
AddBlockedTrackingNode
(
nsINode
*
node
)
{
if
(
!
node
)
{
return
;
}
nsWeakPtr
weakNode
=
do_GetWeakReference
(
node
)
;
if
(
weakNode
)
{
mBlockedTrackingNodes
.
AppendElement
(
weakNode
)
;
}
}
gfxUserFontSet
*
GetUserFontSet
(
bool
aFlushUserFontSet
=
true
)
;
void
FlushUserFontSet
(
)
;
void
MarkUserFontSetDirty
(
)
;
mozilla
:
:
dom
:
:
FontFaceSet
*
GetFonts
(
)
{
return
mFontFaceSet
;
}
mozilla
:
:
dom
:
:
FontFaceSet
*
Fonts
(
)
;
bool
DidFireDOMContentLoaded
(
)
const
{
return
mDidFireDOMContentLoaded
;
}
bool
IsSynthesized
(
)
;
enum
class
UseCounterReportKind
{
eDefault
eIncludeExternalResources
}
;
void
ReportUseCounters
(
UseCounterReportKind
aKind
=
UseCounterReportKind
:
:
eDefault
)
;
void
SetDocumentUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
if
(
!
mUseCounters
[
aUseCounter
]
)
{
mUseCounters
[
aUseCounter
]
=
true
;
}
}
void
SetPageUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
;
void
SetDocumentAndPageUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
SetDocumentUseCounter
(
aUseCounter
)
;
SetPageUseCounter
(
aUseCounter
)
;
}
void
PropagateUseCounters
(
nsIDocument
*
aParentDocument
)
;
void
SetUserHasInteracted
(
bool
aUserHasInteracted
)
;
bool
UserHasInteracted
(
)
{
return
mUserHasInteracted
;
}
void
NotifyUserGestureActivation
(
)
;
bool
HasBeenUserGestureActivated
(
)
;
bool
HasScriptsBlockedBySandbox
(
)
;
bool
InlineScriptAllowedByCSP
(
)
;
void
ReportHasScrollLinkedEffect
(
)
;
bool
HasScrollLinkedEffect
(
)
const
{
return
mHasScrollLinkedEffect
;
}
mozilla
:
:
dom
:
:
DocGroup
*
GetDocGroup
(
)
const
;
void
AddIntersectionObserver
(
mozilla
:
:
dom
:
:
DOMIntersectionObserver
*
aObserver
)
{
MOZ_ASSERT
(
!
mIntersectionObservers
.
Contains
(
aObserver
)
"
Intersection
observer
already
in
the
list
"
)
;
mIntersectionObservers
.
PutEntry
(
aObserver
)
;
}
void
RemoveIntersectionObserver
(
mozilla
:
:
dom
:
:
DOMIntersectionObserver
*
aObserver
)
{
mIntersectionObservers
.
RemoveEntry
(
aObserver
)
;
}
bool
HasIntersectionObservers
(
)
const
{
return
!
mIntersectionObservers
.
IsEmpty
(
)
;
}
void
UpdateIntersectionObservations
(
)
;
void
ScheduleIntersectionObserverNotification
(
)
;
void
NotifyIntersectionObservers
(
)
;
nsresult
Dispatch
(
mozilla
:
:
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
final
;
virtual
nsISerialEventTarget
*
EventTargetFor
(
mozilla
:
:
TaskCategory
aCategory
)
const
override
;
virtual
mozilla
:
:
AbstractThread
*
AbstractMainThreadFor
(
mozilla
:
:
TaskCategory
aCategory
)
override
;
void
NoteScriptTrackingStatus
(
const
nsACString
&
aURL
bool
isTracking
)
;
bool
IsScriptTracking
(
const
nsACString
&
aURL
)
const
;
mozilla
:
:
dom
:
:
FlashClassification
DocumentFlashClassification
(
)
;
bool
IsThirdParty
(
)
;
bool
IsScopedStyleEnabled
(
)
;
nsINode
*
GetServoRestyleRoot
(
)
const
{
return
mServoRestyleRoot
;
}
uint32_t
GetServoRestyleRootDirtyBits
(
)
const
{
MOZ_ASSERT
(
mServoRestyleRoot
)
;
MOZ_ASSERT
(
mServoRestyleRootDirtyBits
)
;
return
mServoRestyleRootDirtyBits
;
}
void
ClearServoRestyleRoot
(
)
{
mServoRestyleRoot
=
nullptr
;
mServoRestyleRootDirtyBits
=
0
;
}
inline
void
SetServoRestyleRoot
(
nsINode
*
aRoot
uint32_t
aDirtyBits
)
;
inline
void
SetServoRestyleRootDirtyBits
(
uint32_t
aDirtyBits
)
;
bool
ShouldThrowOnDynamicMarkupInsertion
(
)
{
return
mThrowOnDynamicMarkupInsertionCounter
;
}
void
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
{
+
+
mThrowOnDynamicMarkupInsertionCounter
;
}
void
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
{
MOZ_ASSERT
(
mThrowOnDynamicMarkupInsertionCounter
)
;
-
-
mThrowOnDynamicMarkupInsertionCounter
;
}
bool
ShouldIgnoreOpens
(
)
const
{
return
mIgnoreOpensDuringUnloadCounter
;
}
void
IncrementIgnoreOpensDuringUnloadCounter
(
)
{
+
+
mIgnoreOpensDuringUnloadCounter
;
}
void
DecrementIgnoreOpensDuringUnloadCounter
(
)
{
MOZ_ASSERT
(
mIgnoreOpensDuringUnloadCounter
)
;
-
-
mIgnoreOpensDuringUnloadCounter
;
}
bool
AllowPaymentRequest
(
)
const
{
return
mAllowPaymentRequest
;
}
void
SetAllowPaymentRequest
(
bool
aAllowPaymentRequest
)
{
mAllowPaymentRequest
=
aAllowPaymentRequest
;
}
bool
IsShadowDOMEnabled
(
)
const
{
return
mIsShadowDOMEnabled
;
}
bool
ModuleScriptsEnabled
(
)
;
nsIContent
*
GetContentInThisDocument
(
nsIFrame
*
aFrame
)
const
;
void
ReportShadowDOMUsage
(
)
;
protected
:
already_AddRefed
<
nsIPrincipal
>
MaybeDowngradePrincipal
(
nsIPrincipal
*
aPrincipal
)
;
void
EnsureOnloadBlocker
(
)
;
void
SendToConsole
(
nsCOMArray
<
nsISecurityConsoleMessage
>
&
aMessages
)
;
bool
IsAboutPage
(
)
const
;
bool
ContainsEMEContent
(
)
;
bool
ContainsMSEContent
(
)
;
void
MaybeInitializeFinalizeFrameLoaders
(
)
;
Element
*
GetTitleElement
(
)
;
mozilla
:
:
dom
:
:
FlashClassification
PrincipalFlashClassification
(
)
;
mozilla
:
:
dom
:
:
FlashClassification
ComputeFlashClassification
(
)
;
void
RecordNavigationTiming
(
ReadyState
aReadyState
)
;
void
UpdateVisibilityState
(
)
;
mozilla
:
:
dom
:
:
VisibilityState
ComputeVisibilityState
(
)
const
;
void
MaybeActiveMediaComponents
(
)
;
bool
ApplyFullscreen
(
const
FullscreenRequest
&
aRequest
)
;
bool
GetUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
return
mUseCounters
[
aUseCounter
]
;
}
void
SetChildDocumentUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
if
(
!
mChildDocumentUseCounters
[
aUseCounter
]
)
{
mChildDocumentUseCounters
[
aUseCounter
]
=
true
;
}
}
bool
GetChildDocumentUseCounter
(
mozilla
:
:
UseCounter
aUseCounter
)
{
return
mChildDocumentUseCounters
[
aUseCounter
]
;
}
void
UpdateDocumentStates
(
mozilla
:
:
EventStates
)
;
void
RemoveDocStyleSheetsFromStyleSets
(
)
;
void
RemoveStyleSheetsFromStyleSets
(
const
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aSheets
mozilla
:
:
SheetType
aType
)
;
void
ResetStylesheetsToURI
(
nsIURI
*
aURI
)
;
void
FillStyleSet
(
mozilla
:
:
ServoStyleSet
*
aStyleSet
)
;
void
AddStyleSheetToStyleSets
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
RemoveStyleSheetFromStyleSets
(
mozilla
:
:
StyleSheet
*
aSheet
)
;
void
NotifyStyleSheetAdded
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aDocumentSheet
)
;
void
NotifyStyleSheetRemoved
(
mozilla
:
:
StyleSheet
*
aSheet
bool
aDocumentSheet
)
;
void
NotifyStyleSheetApplicableStateChanged
(
)
;
void
EnableStyleSheetsForSetInternal
(
const
nsAString
&
aSheetSet
bool
aUpdateCSSLoader
)
;
private
:
mutable
std
:
:
bitset
<
eDeprecatedOperationCount
>
mDeprecationWarnedAbout
;
mutable
std
:
:
bitset
<
eDocumentWarningCount
>
mDocWarningWarnedAbout
;
mozilla
:
:
UniquePtr
<
SelectorCache
>
mSelectorCache
;
protected
:
friend
class
nsDocumentOnStack
;
void
IncreaseStackRefCnt
(
)
{
+
+
mStackRefCnt
;
}
void
DecreaseStackRefCnt
(
)
{
if
(
-
-
mStackRefCnt
=
=
0
&
&
mNeedsReleaseAfterStackRefCntRelease
)
{
mNeedsReleaseAfterStackRefCntRelease
=
false
;
NS_RELEASE_THIS
(
)
;
}
}
~
nsIDocument
(
)
;
nsPIDOMWindowOuter
*
GetWindowInternal
(
)
const
;
nsIScriptGlobalObject
*
GetScriptHandlingObjectInternal
(
)
const
;
bool
InternalAllowXULXBL
(
)
;
void
WillDispatchMutationEvent
(
nsINode
*
aTarget
)
;
void
MutationEventDispatched
(
nsINode
*
aTarget
)
;
friend
class
mozAutoSubtreeModified
;
virtual
Element
*
GetNameSpaceElement
(
)
override
{
return
GetRootElement
(
)
;
}
void
SetContentTypeInternal
(
const
nsACString
&
aType
)
;
nsCString
GetContentTypeInternal
(
)
const
{
return
mContentType
;
}
mozilla
:
:
dom
:
:
XPathEvaluator
*
XPathEvaluator
(
)
;
void
UpdateFrameRequestCallbackSchedulingState
(
nsIPresShell
*
aOldShell
=
nullptr
)
;
bool
IsPotentiallyScrollable
(
mozilla
:
:
dom
:
:
HTMLBodyElement
*
aBody
)
;
nsIDocument
*
GetSameTypeParentDocument
(
)
;
void
MaybeAllowStorageForOpener
(
)
;
static
bool
MatchNameAttribute
(
mozilla
:
:
dom
:
:
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
;
static
void
*
UseExistingNameString
(
nsINode
*
aRootNode
const
nsString
*
aName
)
;
void
MaybeResolveReadyForIdle
(
)
;
nsCString
mReferrer
;
nsString
mLastModified
;
nsCOMPtr
<
nsIURI
>
mDocumentURI
;
nsCOMPtr
<
nsIURI
>
mOriginalURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocURI
;
nsCOMPtr
<
nsIURI
>
mDocumentBaseURI
;
nsCOMPtr
<
nsIURI
>
mChromeXHRDocBaseURI
;
RefPtr
<
mozilla
:
:
URLExtraData
>
mCachedURLData
;
nsWeakPtr
mDocumentLoadGroup
;
bool
mReferrerPolicySet
;
ReferrerPolicyEnum
mReferrerPolicy
;
bool
mBlockAllMixedContent
;
bool
mBlockAllMixedContentPreloads
;
bool
mUpgradeInsecureRequests
;
bool
mUpgradeInsecurePreloads
;
mozilla
:
:
WeakPtr
<
nsDocShell
>
mDocumentContainer
;
NotNull
<
const
Encoding
*
>
mCharacterSet
;
int32_t
mCharacterSetSource
;
nsIDocument
*
mParentDocument
;
mozilla
:
:
dom
:
:
Element
*
mCachedRootElement
;
nsNodeInfoManager
*
mNodeInfoManager
;
RefPtr
<
mozilla
:
:
css
:
:
Loader
>
mCSSLoader
;
RefPtr
<
mozilla
:
:
css
:
:
ImageLoader
>
mStyleImageLoader
;
RefPtr
<
nsHTMLStyleSheet
>
mAttrStyleSheet
;
RefPtr
<
nsHTMLCSSStyleSheet
>
mStyleAttrStyleSheet
;
RefPtr
<
mozilla
:
:
dom
:
:
ImageTracker
>
mImageTracker
;
ShadowRootSet
mComposedShadowRoots
;
nsAutoPtr
<
nsTHashtable
<
nsPtrHashKey
<
nsISupports
>
>
>
mActivityObservers
;
nsTHashtable
<
nsPtrHashKey
<
mozilla
:
:
dom
:
:
Link
>
>
mStyledLinks
;
#
ifdef
DEBUG
bool
mStyledLinksCleared
;
#
endif
static
const
size_t
kSegmentSize
=
128
;
typedef
mozilla
:
:
SegmentedVector
<
nsCOMPtr
<
mozilla
:
:
dom
:
:
Link
>
kSegmentSize
InfallibleAllocPolicy
>
LinksToUpdateList
;
LinksToUpdateList
mLinksToUpdate
;
RefPtr
<
nsSMILAnimationController
>
mAnimationController
;
nsPropertyTable
mPropertyTable
;
nsCOMPtr
<
nsIHTMLCollection
>
mChildrenCollection
;
RefPtr
<
nsContentList
>
mImages
;
RefPtr
<
nsContentList
>
mEmbeds
;
RefPtr
<
nsContentList
>
mLinks
;
RefPtr
<
nsContentList
>
mForms
;
RefPtr
<
nsContentList
>
mScripts
;
nsCOMPtr
<
nsIHTMLCollection
>
mApplets
;
RefPtr
<
nsContentList
>
mAnchors
;
RefPtr
<
mozilla
:
:
dom
:
:
FontFaceSet
>
mFontFaceSet
;
mozilla
:
:
TimeStamp
mLastFocusTime
;
mozilla
:
:
EventStates
mDocumentState
;
RefPtr
<
mozilla
:
:
dom
:
:
Promise
>
mReadyForIdle
;
bool
mBidiEnabled
:
1
;
bool
mMathMLEnabled
:
1
;
bool
mIsInitialDocumentInWindow
:
1
;
bool
mIgnoreDocGroupMismatches
:
1
;
bool
mLoadedAsData
:
1
;
bool
mLoadedAsInteractiveData
:
1
;
bool
mMayStartLayout
:
1
;
bool
mHaveFiredTitleChange
:
1
;
bool
mIsShowing
:
1
;
bool
mVisible
:
1
;
bool
mRemovedFromDocShell
:
1
;
bool
mAllowDNSPrefetch
:
1
;
bool
mIsStaticDocument
:
1
;
bool
mCreatingStaticClone
:
1
;
bool
mInUnlinkOrDeletion
:
1
;
bool
mHasHadScriptHandlingObject
:
1
;
bool
mIsBeingUsedAsImage
:
1
;
bool
mIsSyntheticDocument
:
1
;
bool
mHasLinksToUpdateRunnable
:
1
;
bool
mFlushingPendingLinkUpdates
:
1
;
bool
mMayHaveDOMMutationObservers
:
1
;
bool
mMayHaveAnimationObservers
:
1
;
bool
mHasMixedActiveContentLoaded
:
1
;
bool
mHasMixedActiveContentBlocked
:
1
;
bool
mHasMixedDisplayContentLoaded
:
1
;
bool
mHasMixedDisplayContentBlocked
:
1
;
bool
mHasMixedContentObjectSubrequest
:
1
;
bool
mHasCSP
:
1
;
bool
mHasUnsafeEvalCSP
:
1
;
bool
mHasUnsafeInlineCSP
:
1
;
bool
mHasTrackingContentBlocked
:
1
;
bool
mHasTrackingContentLoaded
:
1
;
bool
mBFCacheDisallowed
:
1
;
bool
mHasHadDefaultView
:
1
;
bool
mStyleSheetChangeEventsEnabled
:
1
;
bool
mIsSrcdocDocument
:
1
;
bool
mDidDocumentOpen
:
1
;
bool
mHasDisplayDocument
:
1
;
bool
mFontFaceSetDirty
:
1
;
bool
mGetUserFontSetCalled
:
1
;
bool
mDidFireDOMContentLoaded
:
1
;
bool
mHasScrollLinkedEffect
:
1
;
bool
mFrameRequestCallbacksScheduled
:
1
;
bool
mIsTopLevelContentDocument
:
1
;
bool
mIsContentDocument
:
1
;
bool
mDidCallBeginLoad
:
1
;
bool
mAllowPaymentRequest
:
1
;
bool
mEncodingMenuDisabled
:
1
;
bool
mIsShadowDOMEnabled
:
1
;
bool
mIsSVGGlyphsDocument
:
1
;
bool
mInDestructor
:
1
;
bool
mIsGoingAway
:
1
;
bool
mInXBLUpdate
:
1
;
bool
mNeedsReleaseAfterStackRefCntRelease
:
1
;
bool
mStyleSetFilled
:
1
;
bool
mSSApplicableStateNotificationPending
:
1
;
bool
mMayHaveTitleElement
:
1
;
bool
mDOMLoadingSet
:
1
;
bool
mDOMInteractiveSet
:
1
;
bool
mDOMCompleteSet
:
1
;
bool
mAutoFocusFired
:
1
;
bool
mScrolledToRefAlready
:
1
;
bool
mChangeScrollPosWhenScrollingToRef
:
1
;
bool
mHasWarnedAboutBoxObjects
:
1
;
bool
mDelayFrameLoaderInitialization
:
1
;
bool
mSynchronousDOMContentLoaded
:
1
;
bool
mMaybeServiceWorkerControlled
:
1
;
bool
mValidWidth
:
1
;
bool
mValidHeight
:
1
;
bool
mAutoSize
:
1
;
bool
mAllowZoom
:
1
;
bool
mAllowDoubleTapZoom
:
1
;
bool
mValidScaleFloat
:
1
;
bool
mValidMaxScale
:
1
;
bool
mScaleStrEmpty
:
1
;
bool
mWidthStrEmpty
:
1
;
bool
mParserAborted
:
1
;
bool
mReportedUseCounters
:
1
;
bool
mHasReportedShadowDOMUsage
:
1
;
#
ifdef
DEBUG
public
:
bool
mWillReparent
:
1
;
protected
:
#
endif
uint8_t
mPendingFullscreenRequests
;
uint8_t
mXMLDeclarationBits
;
uint32_t
mOnloadBlockCount
;
uint32_t
mAsyncOnloadBlockCount
;
nsCompatibility
mCompatMode
;
ReadyState
mReadyState
;
#
ifdef
MOZILLA_INTERNAL_API
mozilla
:
:
dom
:
:
VisibilityState
mVisibilityState
;
static_assert
(
sizeof
(
mozilla
:
:
dom
:
:
VisibilityState
)
=
=
sizeof
(
uint8_t
)
"
Error
size
of
mVisibilityState
and
mDummy
"
)
;
#
else
uint8_t
mDummy
;
#
endif
enum
Type
{
eUnknown
eHTML
eXHTML
eGenericXML
eSVG
eXUL
}
;
Type
mType
;
uint8_t
mDefaultElementType
;
enum
Tri
{
eTriUnset
=
0
eTriFalse
eTriTrue
}
;
Tri
mAllowXULXBL
;
nsCOMPtr
<
nsIScriptGlobalObject
>
mScriptGlobalObject
;
nsCOMPtr
<
nsIDocument
>
mOriginalDocument
;
uint32_t
mBidiOptions
;
uint32_t
mSandboxFlags
;
nsCString
mContentLanguage
;
nsCOMPtr
<
nsIChannel
>
mChannel
;
private
:
nsCString
mContentType
;
protected
:
nsCString
mContentTypeForWriteCalls
;
nsCOMPtr
<
nsISupports
>
mSecurityInfo
;
nsCOMPtr
<
nsIChannel
>
mFailedChannel
;
uint32_t
mPartID
;
uint32_t
mMarkedCCGeneration
;
nsIPresShell
*
mPresShell
;
nsCOMArray
<
nsINode
>
mSubtreeModifiedTargets
;
uint32_t
mSubtreeModifiedDepth
;
nsRefPtrHashtable
<
nsURIHashKey
imgIRequest
>
mPreloadingImages
;
nsDataHashtable
<
nsURIHashKey
bool
>
mPreloadedPreconnects
;
uint32_t
mPreloadPictureDepth
;
nsString
mPreloadPictureFoundSource
;
nsCOMPtr
<
nsIDocument
>
mDisplayDocument
;
uint32_t
mEventsSuppressed
;
uint32_t
mIgnoreDestructiveWritesCounter
;
int32_t
mFrameRequestCallbackCounter
;
uint32_t
mStaticCloneCount
;
nsTArray
<
nsWeakPtr
>
mBlockedTrackingNodes
;
nsPIDOMWindowInner
*
mWindow
;
nsCOMPtr
<
nsIDocumentEncoder
>
mCachedEncoder
;
struct
FrameRequest
;
nsTArray
<
FrameRequest
>
mFrameRequestCallbacks
;
nsIBFCacheEntry
*
mBFCacheEntry
;
nsString
mBaseTarget
;
nsCOMPtr
<
nsIStructuredCloneContainer
>
mStateObjectContainer
;
nsCOMPtr
<
nsIVariant
>
mStateObjectCached
;
uint32_t
mInSyncOperationCount
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
dom
:
:
XPathEvaluator
>
mXPathEvaluator
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
AnonymousContent
>
>
mAnonymousContents
;
uint32_t
mBlockDOMContentLoaded
;
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
MediaQueryList
>
mDOMMediaQueryLists
;
nsTObserverArray
<
nsIDocumentObserver
*
>
mObservers
;
std
:
:
bitset
<
mozilla
:
:
eUseCounter_Count
>
mUseCounters
;
std
:
:
bitset
<
mozilla
:
:
eUseCounter_Count
>
mChildDocumentUseCounters
;
std
:
:
bitset
<
mozilla
:
:
eUseCounter_Count
>
mNotifiedPageForUseCounter
;
bool
mUserHasInteracted
;
bool
mUserGestureActivated
;
mozilla
:
:
TimeStamp
mPageUnloadingEventTimeStamp
;
RefPtr
<
mozilla
:
:
dom
:
:
DocGroup
>
mDocGroup
;
nsTHashtable
<
nsCStringHashKey
>
mTrackingScripts
;
nsTArray
<
nsCOMPtr
<
nsIPrincipal
>
>
mAncestorPrincipals
;
nsTArray
<
uint64_t
>
mAncestorOuterWindowIDs
;
nsCOMPtr
<
nsIParser
>
mParser
;
nsrefcnt
mStackRefCnt
;
nsWeakPtr
mWeakSink
;
uint32_t
mUpdateNestLevel
;
enum
ViewportType
:
uint8_t
{
DisplayWidthHeight
Specified
Unknown
}
;
ViewportType
mViewportType
;
enum
class
ViewportOverflowType
:
uint8_t
{
NoOverflow
Desktop
ButNotMinScaleSize
MinScaleSize
}
;
ViewportOverflowType
mViewportOverflowType
;
PLDHashTable
*
mSubDocuments
;
nsDocHeaderData
*
mHeaderData
;
RefPtr
<
PrincipalFlashClassifier
>
mPrincipalFlashClassifier
;
mozilla
:
:
dom
:
:
FlashClassification
mFlashClassification
;
mozilla
:
:
Maybe
<
bool
>
mIsThirdParty
;
nsRevocableEventPtr
<
nsRunnableMethod
<
nsIDocument
void
false
>
>
mPendingTitleChangeEvent
;
RefPtr
<
nsDOMNavigationTiming
>
mTiming
;
mozilla
:
:
TimeStamp
mLoadingTimeStamp
;
nsWeakPtr
mAutoFocusElement
;
nsCString
mScrollToRef
;
nsWeakPtr
mScopeObject
;
nsTHashtable
<
nsPtrHashKey
<
mozilla
:
:
dom
:
:
DOMIntersectionObserver
>
>
mIntersectionObservers
;
nsTArray
<
nsWeakPtr
>
mFullScreenStack
;
nsWeakPtr
mFullscreenRoot
;
RefPtr
<
mozilla
:
:
dom
:
:
DOMImplementation
>
mDOMImplementation
;
RefPtr
<
nsContentList
>
mImageMaps
;
nsTHashtable
<
nsPtrHashKey
<
mozilla
:
:
dom
:
:
HTMLImageElement
>
>
mResponsiveContent
;
nsTHashtable
<
nsPtrHashKey
<
nsIObjectLoadingContent
>
>
mPlugins
;
nsAttrAndChildArray
mChildren
;
RefPtr
<
mozilla
:
:
dom
:
:
DocumentTimeline
>
mDocumentTimeline
;
mozilla
:
:
LinkedList
<
mozilla
:
:
dom
:
:
DocumentTimeline
>
mTimelines
;
RefPtr
<
mozilla
:
:
dom
:
:
ScriptLoader
>
mScriptLoader
;
nsRefPtrHashtable
<
nsPtrHashKey
<
nsIContent
>
mozilla
:
:
dom
:
:
BoxObject
>
*
mBoxObjectTable
;
RefPtr
<
mozilla
:
:
PendingAnimationTracker
>
mPendingAnimationTracker
;
nsCOMPtr
<
nsIDocument
>
mTemplateContentsOwner
;
nsExternalResourceMap
mExternalResourceMap
;
RefPtr
<
mozilla
:
:
dom
:
:
Promise
>
mOrientationPendingPromise
;
uint16_t
mCurrentOrientationAngle
;
mozilla
:
:
dom
:
:
OrientationType
mCurrentOrientationType
;
nsTArray
<
RefPtr
<
nsFrameLoader
>
>
mInitializableFrameLoaders
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mFrameLoaderFinalizers
;
RefPtr
<
nsRunnableMethod
<
nsIDocument
>
>
mFrameLoaderRunner
;
nsCOMPtr
<
nsILayoutHistoryState
>
mLayoutHistoryState
;
mozilla
:
:
LayoutDeviceToScreenScale
mScaleMinFloat
;
mozilla
:
:
LayoutDeviceToScreenScale
mScaleMaxFloat
;
mozilla
:
:
LayoutDeviceToScreenScale
mScaleFloat
;
mozilla
:
:
CSSToLayoutDeviceScale
mPixelRatio
;
mozilla
:
:
CSSSize
mViewportSize
;
RefPtr
<
mozilla
:
:
EventListenerManager
>
mListenerManager
;
nsCOMPtr
<
nsIRunnable
>
mMaybeEndOutermostXBLUpdateRunner
;
nsCOMPtr
<
nsIRequest
>
mOnloadBlocker
;
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
mAdditionalSheets
[
AdditionalSheetTypeCount
]
;
nsString
mLastStyleSheetSet
;
nsString
mPreferredStyleSheetSet
;
RefPtr
<
nsDOMStyleSheetSetList
>
mStyleSheetSetList
;
nsTHashtable
<
nsPtrHashKey
<
nsSVGElement
>
>
mLazySVGPresElements
;
nsCOMPtr
<
nsINode
>
mServoRestyleRoot
;
uint32_t
mServoRestyleRootDirtyBits
;
uint32_t
mThrowOnDynamicMarkupInsertionCounter
;
uint32_t
mIgnoreOpensDuringUnloadCounter
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsIDocument
NS_IDOCUMENT_IID
)
class
MOZ_STACK_CLASS
mozAutoSubtreeModified
{
public
:
mozAutoSubtreeModified
(
nsIDocument
*
aSubtreeOwner
nsINode
*
aTarget
)
{
UpdateTarget
(
aSubtreeOwner
aTarget
)
;
}
~
mozAutoSubtreeModified
(
)
{
UpdateTarget
(
nullptr
nullptr
)
;
}
void
UpdateTarget
(
nsIDocument
*
aSubtreeOwner
nsINode
*
aTarget
)
{
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
MutationEventDispatched
(
mTarget
)
;
}
mTarget
=
aTarget
;
mSubtreeOwner
=
aSubtreeOwner
;
if
(
mSubtreeOwner
)
{
mSubtreeOwner
-
>
WillDispatchMutationEvent
(
mTarget
)
;
}
}
private
:
nsCOMPtr
<
nsINode
>
mTarget
;
nsCOMPtr
<
nsIDocument
>
mSubtreeOwner
;
}
;
class
MOZ_STACK_CLASS
nsAutoSyncOperation
{
public
:
explicit
nsAutoSyncOperation
(
nsIDocument
*
aDocument
)
;
~
nsAutoSyncOperation
(
)
;
private
:
nsCOMArray
<
nsIDocument
>
mDocuments
;
uint32_t
mMicroTaskLevel
;
}
;
class
MOZ_RAII
AutoSetThrowOnDynamicMarkupInsertionCounter
final
{
public
:
explicit
AutoSetThrowOnDynamicMarkupInsertionCounter
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
{
mDocument
-
>
IncrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
~
AutoSetThrowOnDynamicMarkupInsertionCounter
(
)
{
mDocument
-
>
DecrementThrowOnDynamicMarkupInsertionCounter
(
)
;
}
private
:
nsIDocument
*
mDocument
;
}
;
class
MOZ_RAII
IgnoreOpensDuringUnload
final
{
public
:
explicit
IgnoreOpensDuringUnload
(
nsIDocument
*
aDoc
)
:
mDoc
(
aDoc
)
{
mDoc
-
>
IncrementIgnoreOpensDuringUnloadCounter
(
)
;
}
~
IgnoreOpensDuringUnload
(
)
{
mDoc
-
>
DecrementIgnoreOpensDuringUnloadCounter
(
)
;
}
private
:
nsIDocument
*
mDoc
;
}
;
nsresult
NS_NewHTMLDocument
(
nsIDocument
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
)
;
nsresult
NS_NewXMLDocument
(
nsIDocument
*
*
aInstancePtrResult
bool
aLoadedAsData
=
false
bool
aIsPlainDocument
=
false
)
;
nsresult
NS_NewSVGDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
nsresult
NS_NewImageDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
nsresult
NS_NewVideoDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
nsresult
NS_NewDOMDocument
(
nsIDocument
*
*
aInstancePtrResult
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
mozilla
:
:
dom
:
:
DocumentType
*
aDoctype
nsIURI
*
aDocumentURI
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
bool
aLoadedAsData
nsIGlobalObject
*
aEventObject
DocumentFlavor
aFlavor
)
;
nsresult
NS_NewXBLDocument
(
nsIDocument
*
*
aInstancePtrResult
nsIURI
*
aDocumentURI
nsIURI
*
aBaseURI
nsIPrincipal
*
aPrincipal
)
;
nsresult
NS_NewPluginDocument
(
nsIDocument
*
*
aInstancePtrResult
)
;
inline
nsIDocument
*
nsINode
:
:
GetOwnerDocument
(
)
const
{
nsIDocument
*
ownerDoc
=
OwnerDoc
(
)
;
return
ownerDoc
!
=
this
?
ownerDoc
:
nullptr
;
}
inline
nsINode
*
nsINode
:
:
OwnerDocAsNode
(
)
const
{
return
OwnerDoc
(
)
;
}
template
<
typename
T
>
inline
bool
ShouldUseXBLScope
(
const
T
*
aNode
)
{
return
aNode
-
>
IsInAnonymousSubtree
(
)
&
&
!
aNode
-
>
IsAnonymousContentInSVGUseSubtree
(
)
;
}
inline
mozilla
:
:
dom
:
:
ParentObject
nsINode
:
:
GetParentObject
(
)
const
{
mozilla
:
:
dom
:
:
ParentObject
p
(
OwnerDoc
(
)
)
;
p
.
mUseXBLScope
=
ShouldUseXBLScope
(
this
)
;
return
p
;
}
inline
nsIDocument
*
nsINode
:
:
AsDocument
(
)
{
MOZ_ASSERT
(
IsDocument
(
)
)
;
return
static_cast
<
nsIDocument
*
>
(
this
)
;
}
inline
const
nsIDocument
*
nsINode
:
:
AsDocument
(
)
const
{
MOZ_ASSERT
(
IsDocument
(
)
)
;
return
static_cast
<
const
nsIDocument
*
>
(
this
)
;
}
#
endif
