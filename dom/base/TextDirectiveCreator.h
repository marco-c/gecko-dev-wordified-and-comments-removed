#
ifndef
DOM_TEXTDIRECTIVECREATOR_H_
#
define
DOM_TEXTDIRECTIVECREATOR_H_
#
include
<
tuple
>
#
include
"
RangeBoundary
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
Result
.
h
"
class
nsRange
;
namespace
mozilla
{
class
ErrorResult
;
}
namespace
mozilla
:
:
dom
{
class
Document
;
class
RangeContentCache
{
public
:
Result
<
std
:
:
tuple
<
const
nsString
&
const
nsString
&
>
ErrorResult
>
Get
(
nsRange
*
aRange1
nsRange
*
aRange2
)
;
private
:
nsTHashMap
<
nsRange
*
nsString
>
mCache
;
}
;
class
TextDirectiveCandidate
{
public
:
TextDirectiveCandidate
(
TextDirectiveCandidate
&
&
)
=
default
;
TextDirectiveCandidate
&
operator
=
(
TextDirectiveCandidate
&
&
)
=
default
;
TextDirectiveCandidate
(
const
TextDirectiveCandidate
&
)
=
delete
;
TextDirectiveCandidate
&
operator
=
(
const
TextDirectiveCandidate
&
)
=
delete
;
static
Result
<
TextDirectiveCandidate
ErrorResult
>
CreateFromInputRange
(
const
nsRange
*
aInputRange
)
;
static
Result
<
TextDirectiveCandidate
ErrorResult
>
CreateFromStartAndEndRange
(
const
nsRange
*
aStartRange
const
nsRange
*
aEndRange
)
;
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
CreateNewCandidatesForMatches
(
const
nsTArray
<
const
TextDirectiveCandidate
*
>
&
aMatches
RangeContentCache
&
aRangeContentCache
)
;
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
CreateNewCandidatesForGivenMatch
(
const
TextDirectiveCandidate
&
aOther
RangeContentCache
&
aRangeContentCache
)
const
;
Result
<
TextDirectiveCandidate
ErrorResult
>
CloneWith
(
RefPtr
<
nsRange
>
&
&
aNewPrefixRange
RefPtr
<
nsRange
>
&
&
aNewStartRange
RefPtr
<
nsRange
>
&
&
aNewEndRange
RefPtr
<
nsRange
>
&
&
aNewSuffixRange
)
const
;
Result
<
bool
ErrorResult
>
ThisCandidateMatchesOther
(
const
TextDirectiveCandidate
&
aOther
RangeContentCache
&
aRangeContentCache
)
const
;
nsTArray
<
const
TextDirectiveCandidate
*
>
FilterNonMatchingCandidates
(
const
nsTArray
<
const
TextDirectiveCandidate
*
>
&
aMatches
RangeContentCache
&
aRangeContentCache
)
;
bool
UseExactMatch
(
)
const
{
return
!
mEndRange
;
}
nsRange
*
StartRange
(
)
{
return
mStartRange
;
}
const
nsRange
*
StartRange
(
)
const
{
return
mStartRange
;
}
nsRange
*
EndRange
(
)
{
return
mEndRange
;
}
const
nsRange
*
EndRange
(
)
const
{
return
mEndRange
;
}
const
nsCString
&
TextDirectiveString
(
)
const
;
void
LogCurrentState
(
const
char
*
aCallerFunc
)
const
;
private
:
TextDirectiveCandidate
(
nsRange
*
aStartRange
nsRange
*
aFullStartRange
nsRange
*
aEndRange
nsRange
*
aFullEndRange
nsRange
*
aPrefixRange
nsRange
*
aFullPrefixRange
nsRange
*
aSuffixRange
nsRange
*
aFullSuffixRange
)
;
static
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
MaybeCreateStartToBlockBoundaryRange
(
const
nsRange
&
aRange
)
;
static
Result
<
RefPtr
<
nsRange
>
ErrorResult
>
MaybeCreateEndToBlockBoundaryRange
(
const
nsRange
&
aRange
)
;
static
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
CreatePrefixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
;
static
Result
<
std
:
:
tuple
<
RefPtr
<
nsRange
>
RefPtr
<
nsRange
>
>
ErrorResult
>
CreateSuffixRanges
(
const
RangeBoundary
&
aRangeBoundary
)
;
Result
<
Ok
ErrorResult
>
CreateTextDirectiveString
(
)
;
RefPtr
<
nsRange
>
mStartRange
;
RefPtr
<
nsRange
>
mFullStartRange
;
RefPtr
<
nsRange
>
mEndRange
;
RefPtr
<
nsRange
>
mFullEndRange
;
RefPtr
<
nsRange
>
mPrefixRange
;
RefPtr
<
nsRange
>
mFullPrefixRange
;
RefPtr
<
nsRange
>
mSuffixRange
;
RefPtr
<
nsRange
>
mFullSuffixRange
;
nsCString
mTextDirectiveString
;
}
;
class
TextDirectiveCreator
final
{
public
:
static
Result
<
nsCString
ErrorResult
>
CreateTextDirectiveFromRange
(
Document
&
aDocument
nsRange
*
aInputRange
)
;
private
:
TextDirectiveCreator
(
Document
&
aDocument
nsRange
*
aInputRange
TextDirectiveCandidate
&
&
aTextDirective
)
;
Result
<
nsTArray
<
TextDirectiveCandidate
>
ErrorResult
>
FindAllMatchingCandidates
(
)
;
Result
<
nsTArray
<
RefPtr
<
nsRange
>
>
ErrorResult
>
FindAllMatchingRanges
(
const
nsString
&
aSearchQuery
)
;
Result
<
nsCString
ErrorResult
>
CreateTextDirectiveFromMatches
(
const
nsTArray
<
TextDirectiveCandidate
>
&
aTextDirectiveMatches
)
;
Document
&
mDocument
;
RefPtr
<
nsRange
>
mInputRange
;
TextDirectiveCandidate
mTextDirective
;
RangeContentCache
mRangeContentCache
;
}
;
}
#
endif
