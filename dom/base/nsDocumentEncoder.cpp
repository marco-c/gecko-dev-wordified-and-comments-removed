#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsIFactory
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContentSerializer
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsITransferable
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsNodeUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
mozilla
/
dom
/
Comment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ProcessingInstruction
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
enum
nsRangeIterationDirection
{
kDirectionOut
=
-
1
kDirectionIn
=
1
}
;
class
nsDocumentEncoder
:
public
nsIDocumentEncoder
{
public
:
nsDocumentEncoder
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsDocumentEncoder
)
NS_DECL_NSIDOCUMENTENCODER
protected
:
virtual
~
nsDocumentEncoder
(
)
;
void
Initialize
(
bool
aClearCachedSerializer
=
true
)
;
nsresult
SerializeNodeStart
(
nsINode
&
aOriginalNode
int32_t
aStartOffset
int32_t
aEndOffset
nsAString
&
aStr
nsINode
*
aFixupNode
=
nullptr
)
;
nsresult
SerializeToStringRecursive
(
nsINode
*
aNode
nsAString
&
aStr
bool
aDontSerializeRoot
uint32_t
aMaxLength
=
0
)
;
nsresult
SerializeNodeEnd
(
nsINode
&
aNode
nsAString
&
aStr
)
;
nsresult
SerializeToStringIterative
(
nsINode
*
aNode
nsAString
&
aStr
)
;
nsresult
SerializeRangeToString
(
nsRange
*
aRange
nsAString
&
aOutputString
)
;
nsresult
SerializeRangeNodes
(
nsRange
*
aRange
nsINode
*
aNode
nsAString
&
aString
int32_t
aDepth
)
;
nsresult
SerializeRangeContextStart
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
nsAString
&
aString
)
;
nsresult
SerializeRangeContextEnd
(
nsAString
&
aString
)
;
virtual
int32_t
GetImmediateContextCount
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
{
return
-
1
;
}
nsresult
FlushText
(
nsAString
&
aString
bool
aForce
)
;
bool
IsVisibleNode
(
nsINode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
null
node
"
)
;
if
(
mFlags
&
SkipInvisibleContent
)
{
if
(
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
aNode
)
)
{
aNode
=
shadowRoot
-
>
GetHost
(
)
;
}
if
(
aNode
-
>
IsContent
(
)
)
{
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
if
(
aNode
-
>
IsElement
(
)
&
&
aNode
-
>
AsElement
(
)
-
>
IsDisplayContents
(
)
)
{
return
true
;
}
if
(
aNode
-
>
IsText
(
)
)
{
return
true
;
}
if
(
aNode
-
>
IsHTMLElement
(
nsGkAtoms
:
:
rp
)
)
{
return
true
;
}
return
false
;
}
bool
isVisible
=
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
if
(
!
isVisible
&
&
aNode
-
>
IsText
(
)
)
return
false
;
}
}
return
true
;
}
virtual
bool
IncludeInContext
(
nsINode
*
aNode
)
;
void
Clear
(
)
;
class
MOZ_STACK_CLASS
AutoReleaseDocumentIfNeeded
final
{
public
:
explicit
AutoReleaseDocumentIfNeeded
(
nsDocumentEncoder
*
aEncoder
)
:
mEncoder
(
aEncoder
)
{
}
~
AutoReleaseDocumentIfNeeded
(
)
{
if
(
mEncoder
-
>
mFlags
&
RequiresReinitAfterOutput
)
{
mEncoder
-
>
Clear
(
)
;
}
}
private
:
nsDocumentEncoder
*
mEncoder
;
}
;
nsCOMPtr
<
Document
>
mDocument
;
RefPtr
<
Selection
>
mSelection
;
RefPtr
<
nsRange
>
mRange
;
nsCOMPtr
<
nsINode
>
mNode
;
nsCOMPtr
<
nsIOutputStream
>
mStream
;
nsCOMPtr
<
nsIContentSerializer
>
mSerializer
;
UniquePtr
<
Encoder
>
mUnicodeEncoder
;
nsCOMPtr
<
nsINode
>
mCommonParent
;
nsCOMPtr
<
nsIDocumentEncoderNodeFixup
>
mNodeFixup
;
nsString
mMimeType
;
const
Encoding
*
mEncoding
;
uint32_t
mFlags
;
uint32_t
mWrapColumn
;
uint32_t
mStartDepth
;
uint32_t
mEndDepth
;
int32_t
mStartRootIndex
;
int32_t
mEndRootIndex
;
AutoTArray
<
nsINode
*
8
>
mCommonAncestors
;
AutoTArray
<
nsIContent
*
8
>
mStartNodes
;
AutoTArray
<
int32_t
8
>
mStartOffsets
;
AutoTArray
<
nsIContent
*
8
>
mEndNodes
;
AutoTArray
<
int32_t
8
>
mEndOffsets
;
AutoTArray
<
AutoTArray
<
nsINode
*
8
>
8
>
mRangeContexts
;
bool
mNeedsPreformatScanning
;
bool
mHaltRangeHint
;
bool
mDisableContextSerialize
;
bool
mIsCopying
;
bool
mNodeIsContainer
;
bool
mIsPlainText
;
nsStringBuffer
*
mCachedBuffer
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsDocumentEncoder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsDocumentEncoder
Clear
(
)
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsDocumentEncoder
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentEncoder
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsDocumentEncoder
mDocument
mSelection
mRange
mNode
mSerializer
mCommonParent
)
nsDocumentEncoder
:
:
nsDocumentEncoder
(
)
:
mEncoding
(
nullptr
)
mIsCopying
(
false
)
mCachedBuffer
(
nullptr
)
{
Initialize
(
)
;
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
}
void
nsDocumentEncoder
:
:
Initialize
(
bool
aClearCachedSerializer
)
{
mFlags
=
0
;
mWrapColumn
=
72
;
mStartDepth
=
0
;
mEndDepth
=
0
;
mStartRootIndex
=
0
;
mEndRootIndex
=
0
;
mNeedsPreformatScanning
=
false
;
mHaltRangeHint
=
false
;
mDisableContextSerialize
=
false
;
mNodeIsContainer
=
false
;
mIsPlainText
=
false
;
if
(
aClearCachedSerializer
)
{
mSerializer
=
nullptr
;
}
}
nsDocumentEncoder
:
:
~
nsDocumentEncoder
(
)
{
if
(
mCachedBuffer
)
{
mCachedBuffer
-
>
Release
(
)
;
}
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
Init
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
{
return
NativeInit
(
aDocument
aMimeType
aFlags
)
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
NativeInit
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
{
if
(
!
aDocument
)
return
NS_ERROR_INVALID_ARG
;
Initialize
(
!
mMimeType
.
Equals
(
aMimeType
)
)
;
mDocument
=
aDocument
;
mMimeType
=
aMimeType
;
mFlags
=
aFlags
;
mIsCopying
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetWrapColumn
(
uint32_t
aWC
)
{
mWrapColumn
=
aWC
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetSelection
(
Selection
*
aSelection
)
{
mSelection
=
aSelection
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetRange
(
nsRange
*
aRange
)
{
mRange
=
aRange
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetNode
(
nsINode
*
aNode
)
{
mNodeIsContainer
=
false
;
mNode
=
aNode
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetContainerNode
(
nsINode
*
aContainer
)
{
mNodeIsContainer
=
true
;
mNode
=
aContainer
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetCharset
(
const
nsACString
&
aCharset
)
{
const
Encoding
*
encoding
=
Encoding
:
:
ForLabel
(
aCharset
)
;
if
(
!
encoding
)
{
return
NS_ERROR_UCONV_NOCONV
;
}
mEncoding
=
encoding
-
>
OutputEncoding
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
GetMimeType
(
nsAString
&
aMimeType
)
{
aMimeType
=
mMimeType
;
return
NS_OK
;
}
bool
nsDocumentEncoder
:
:
IncludeInContext
(
nsINode
*
aNode
)
{
return
false
;
}
class
FixupNodeDeterminer
{
public
:
FixupNodeDeterminer
(
nsIDocumentEncoderNodeFixup
*
aNodeFixup
nsINode
*
aFixupNode
nsINode
&
aOriginalNode
)
:
mIsSerializationOfFixupChildrenNeeded
{
false
}
mNodeFixup
(
aNodeFixup
)
mOriginalNode
(
aOriginalNode
)
{
if
(
mNodeFixup
)
{
if
(
aFixupNode
)
{
mFixupNode
=
aFixupNode
;
}
else
{
mNodeFixup
-
>
FixupNode
(
&
mOriginalNode
&
mIsSerializationOfFixupChildrenNeeded
getter_AddRefs
(
mFixupNode
)
)
;
}
}
}
bool
IsSerializationOfFixupChildrenNeeded
(
)
const
{
return
mIsSerializationOfFixupChildrenNeeded
;
}
nsINode
&
GetFixupNodeFallBackToOriginalNode
(
)
const
{
return
mFixupNode
?
*
mFixupNode
:
mOriginalNode
;
}
private
:
bool
mIsSerializationOfFixupChildrenNeeded
;
nsIDocumentEncoderNodeFixup
*
mNodeFixup
;
nsCOMPtr
<
nsINode
>
mFixupNode
;
nsINode
&
mOriginalNode
;
}
;
nsresult
nsDocumentEncoder
:
:
SerializeNodeStart
(
nsINode
&
aOriginalNode
int32_t
aStartOffset
int32_t
aEndOffset
nsAString
&
aStr
nsINode
*
aFixupNode
)
{
if
(
mNeedsPreformatScanning
)
{
if
(
aOriginalNode
.
IsElement
(
)
)
{
mSerializer
-
>
ScanElementForPreformat
(
aOriginalNode
.
AsElement
(
)
)
;
}
else
if
(
aOriginalNode
.
IsText
(
)
)
{
const
nsCOMPtr
<
nsINode
>
parent
=
aOriginalNode
.
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsElement
(
)
)
{
mSerializer
-
>
ScanElementForPreformat
(
parent
-
>
AsElement
(
)
)
;
}
}
}
if
(
!
IsVisibleNode
(
&
aOriginalNode
)
)
{
return
NS_OK
;
}
FixupNodeDeterminer
fixupNodeDeterminer
{
mNodeFixup
aFixupNode
aOriginalNode
}
;
nsINode
*
node
=
&
fixupNodeDeterminer
.
GetFixupNodeFallBackToOriginalNode
(
)
;
if
(
node
-
>
IsElement
(
)
)
{
if
(
(
mFlags
&
(
nsIDocumentEncoder
:
:
OutputPreformatted
|
nsIDocumentEncoder
:
:
OutputDropInvisibleBreak
)
)
&
&
nsLayoutUtils
:
:
IsInvisibleBreak
(
node
)
)
{
return
NS_OK
;
}
Element
*
originalElement
=
aOriginalNode
.
AsElement
(
)
;
mSerializer
-
>
AppendElementStart
(
node
-
>
AsElement
(
)
originalElement
aStr
)
;
return
NS_OK
;
}
switch
(
node
-
>
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
{
mSerializer
-
>
AppendText
(
static_cast
<
nsIContent
*
>
(
node
)
aStartOffset
aEndOffset
aStr
)
;
break
;
}
case
nsINode
:
:
CDATA_SECTION_NODE
:
{
mSerializer
-
>
AppendCDATASection
(
static_cast
<
nsIContent
*
>
(
node
)
aStartOffset
aEndOffset
aStr
)
;
break
;
}
case
nsINode
:
:
PROCESSING_INSTRUCTION_NODE
:
{
mSerializer
-
>
AppendProcessingInstruction
(
static_cast
<
ProcessingInstruction
*
>
(
node
)
aStartOffset
aEndOffset
aStr
)
;
break
;
}
case
nsINode
:
:
COMMENT_NODE
:
{
mSerializer
-
>
AppendComment
(
static_cast
<
Comment
*
>
(
node
)
aStartOffset
aEndOffset
aStr
)
;
break
;
}
case
nsINode
:
:
DOCUMENT_TYPE_NODE
:
{
mSerializer
-
>
AppendDoctype
(
static_cast
<
DocumentType
*
>
(
node
)
aStr
)
;
break
;
}
}
return
NS_OK
;
}
nsresult
nsDocumentEncoder
:
:
SerializeNodeEnd
(
nsINode
&
aNode
nsAString
&
aStr
)
{
if
(
mNeedsPreformatScanning
)
{
if
(
aNode
.
IsElement
(
)
)
{
mSerializer
-
>
ForgetElementForPreformat
(
aNode
.
AsElement
(
)
)
;
}
else
if
(
aNode
.
IsText
(
)
)
{
const
nsCOMPtr
<
nsINode
>
parent
=
aNode
.
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsElement
(
)
)
{
mSerializer
-
>
ForgetElementForPreformat
(
parent
-
>
AsElement
(
)
)
;
}
}
}
if
(
!
IsVisibleNode
(
&
aNode
)
)
{
return
NS_OK
;
}
if
(
aNode
.
IsElement
(
)
)
{
mSerializer
-
>
AppendElementEnd
(
aNode
.
AsElement
(
)
aStr
)
;
}
return
NS_OK
;
}
nsresult
nsDocumentEncoder
:
:
SerializeToStringRecursive
(
nsINode
*
aNode
nsAString
&
aStr
bool
aDontSerializeRoot
uint32_t
aMaxLength
)
{
if
(
aMaxLength
>
0
&
&
aStr
.
Length
(
)
>
=
aMaxLength
)
{
return
NS_OK
;
}
if
(
!
IsVisibleNode
(
aNode
)
)
return
NS_OK
;
nsresult
rv
=
NS_OK
;
MOZ_ASSERT
(
aNode
"
aNode
shouldn
'
t
be
nullptr
.
"
)
;
FixupNodeDeterminer
fixupNodeDeterminer
{
mNodeFixup
nullptr
*
aNode
}
;
nsINode
*
maybeFixedNode
=
&
fixupNodeDeterminer
.
GetFixupNodeFallBackToOriginalNode
(
)
;
if
(
(
mFlags
&
SkipInvisibleContent
)
&
&
!
(
mFlags
&
OutputNonTextContentAsPlaceholder
)
)
{
if
(
aNode
-
>
IsContent
(
)
)
{
if
(
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
)
{
if
(
!
frame
-
>
IsSelectable
(
nullptr
)
)
{
aDontSerializeRoot
=
true
;
}
}
}
}
if
(
!
aDontSerializeRoot
)
{
int32_t
endOffset
=
-
1
;
if
(
aMaxLength
>
0
)
{
MOZ_ASSERT
(
aMaxLength
>
=
aStr
.
Length
(
)
)
;
endOffset
=
aMaxLength
-
aStr
.
Length
(
)
;
}
rv
=
SerializeNodeStart
(
*
aNode
0
endOffset
aStr
maybeFixedNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsINode
*
node
=
fixupNodeDeterminer
.
IsSerializationOfFixupChildrenNeeded
(
)
?
maybeFixedNode
:
aNode
;
for
(
nsINode
*
child
=
nsNodeUtils
:
:
GetFirstChildOfTemplateOrNode
(
node
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
rv
=
SerializeToStringRecursive
(
child
aStr
false
aMaxLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aDontSerializeRoot
)
{
rv
=
SerializeNodeEnd
(
*
maybeFixedNode
aStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
FlushText
(
aStr
false
)
;
}
nsresult
nsDocumentEncoder
:
:
SerializeToStringIterative
(
nsINode
*
aNode
nsAString
&
aStr
)
{
nsresult
rv
;
nsINode
*
node
=
nsNodeUtils
:
:
GetFirstChildOfTemplateOrNode
(
aNode
)
;
while
(
node
)
{
nsINode
*
current
=
node
;
rv
=
SerializeNodeStart
(
*
current
0
-
1
aStr
current
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
node
=
nsNodeUtils
:
:
GetFirstChildOfTemplateOrNode
(
current
)
;
while
(
!
node
&
&
current
&
&
current
!
=
aNode
)
{
rv
=
SerializeNodeEnd
(
*
current
aStr
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
node
=
current
-
>
GetNextSibling
(
)
;
if
(
!
node
)
{
current
=
current
-
>
GetParentNode
(
)
;
if
(
current
&
&
current
!
=
aNode
&
&
current
-
>
IsDocumentFragment
(
)
)
{
nsIContent
*
host
=
current
-
>
AsDocumentFragment
(
)
-
>
GetHost
(
)
;
if
(
host
&
&
host
-
>
IsHTMLElement
(
nsGkAtoms
:
:
_template
)
)
{
current
=
host
;
}
}
}
}
}
return
NS_OK
;
}
static
nsresult
ConvertAndWrite
(
const
nsAString
&
aString
nsIOutputStream
*
aStream
Encoder
*
aEncoder
bool
aIsPlainText
)
{
NS_ENSURE_ARG_POINTER
(
aStream
)
;
NS_ENSURE_ARG_POINTER
(
aEncoder
)
;
if
(
!
aString
.
Length
(
)
)
{
return
NS_OK
;
}
uint8_t
buffer
[
4096
]
;
auto
src
=
MakeSpan
(
aString
)
;
auto
bufferSpan
=
MakeSpan
(
buffer
)
;
auto
dst
=
bufferSpan
.
To
(
bufferSpan
.
Length
(
)
-
1
)
;
for
(
;
;
)
{
uint32_t
result
;
size_t
read
;
size_t
written
;
bool
hadErrors
;
if
(
aIsPlainText
)
{
Tie
(
result
read
written
)
=
aEncoder
-
>
EncodeFromUTF16WithoutReplacement
(
src
dst
false
)
;
if
(
result
!
=
kInputEmpty
&
&
result
!
=
kOutputFull
)
{
dst
[
written
+
+
]
=
'
?
'
;
}
}
else
{
Tie
(
result
read
written
hadErrors
)
=
aEncoder
-
>
EncodeFromUTF16
(
src
dst
false
)
;
}
Unused
<
<
hadErrors
;
src
=
src
.
From
(
read
)
;
bufferSpan
[
written
]
=
0
;
uint32_t
streamWritten
;
nsresult
rv
=
aStream
-
>
Write
(
reinterpret_cast
<
char
*
>
(
dst
.
Elements
(
)
)
written
&
streamWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
result
=
=
kInputEmpty
)
{
return
NS_OK
;
}
}
}
nsresult
nsDocumentEncoder
:
:
FlushText
(
nsAString
&
aString
bool
aForce
)
{
if
(
!
mStream
)
return
NS_OK
;
nsresult
rv
=
NS_OK
;
if
(
aString
.
Length
(
)
>
1024
|
|
aForce
)
{
rv
=
ConvertAndWrite
(
aString
mStream
mUnicodeEncoder
.
get
(
)
mIsPlainText
)
;
aString
.
Truncate
(
)
;
}
return
rv
;
}
static
bool
IsTextNode
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsText
(
)
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeNodes
(
nsRange
*
const
aRange
nsINode
*
const
aNode
nsAString
&
aString
const
int32_t
aDepth
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
if
(
!
IsVisibleNode
(
aNode
)
)
return
NS_OK
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIContent
>
startNode
endNode
;
{
int32_t
start
=
mStartRootIndex
-
aDepth
;
if
(
start
>
=
0
&
&
(
uint32_t
)
start
<
=
mStartNodes
.
Length
(
)
)
startNode
=
mStartNodes
[
start
]
;
int32_t
end
=
mEndRootIndex
-
aDepth
;
if
(
end
>
=
0
&
&
(
uint32_t
)
end
<
=
mEndNodes
.
Length
(
)
)
endNode
=
mEndNodes
[
end
]
;
}
if
(
startNode
!
=
content
&
&
endNode
!
=
content
)
{
rv
=
SerializeToStringRecursive
(
aNode
aString
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
IsTextNode
(
aNode
)
)
{
if
(
startNode
=
=
content
)
{
int32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
rv
=
SerializeNodeStart
(
*
aNode
startOffset
-
1
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
int32_t
endOffset
=
aRange
-
>
EndOffset
(
)
;
rv
=
SerializeNodeStart
(
*
aNode
0
endOffset
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
SerializeNodeEnd
(
*
aNode
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
aNode
!
=
mCommonParent
)
{
if
(
IncludeInContext
(
aNode
)
)
{
mHaltRangeHint
=
true
;
}
if
(
(
startNode
=
=
content
)
&
&
!
mHaltRangeHint
)
mStartDepth
+
+
;
if
(
(
endNode
=
=
content
)
&
&
!
mHaltRangeHint
)
mEndDepth
+
+
;
rv
=
SerializeNodeStart
(
*
aNode
0
-
1
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
int32_t
startOffset
=
0
endOffset
=
-
1
;
if
(
startNode
=
=
content
&
&
mStartRootIndex
>
=
aDepth
)
startOffset
=
mStartOffsets
[
mStartRootIndex
-
aDepth
]
;
if
(
endNode
=
=
content
&
&
mEndRootIndex
>
=
aDepth
)
endOffset
=
mEndOffsets
[
mEndRootIndex
-
aDepth
]
;
uint32_t
childCount
=
content
-
>
GetChildCount
(
)
;
if
(
startOffset
=
=
-
1
)
startOffset
=
0
;
if
(
endOffset
=
=
-
1
)
endOffset
=
childCount
;
else
{
if
(
aNode
!
=
aRange
-
>
GetEndContainer
(
)
)
{
endOffset
+
+
;
}
}
if
(
endOffset
)
{
nsIContent
*
childAsNode
=
content
-
>
GetFirstChild
(
)
;
int32_t
j
=
0
;
for
(
;
j
<
startOffset
&
&
childAsNode
;
+
+
j
)
{
childAsNode
=
childAsNode
-
>
GetNextSibling
(
)
;
}
NS_ENSURE_TRUE
(
!
!
childAsNode
NS_ERROR_FAILURE
)
;
MOZ_ASSERT
(
j
=
=
startOffset
)
;
for
(
;
childAsNode
&
&
j
<
endOffset
;
+
+
j
)
{
if
(
(
j
=
=
startOffset
)
|
|
(
j
=
=
endOffset
-
1
)
)
{
rv
=
SerializeRangeNodes
(
aRange
childAsNode
aString
aDepth
+
1
)
;
}
else
{
rv
=
SerializeToStringRecursive
(
childAsNode
aString
false
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
childAsNode
=
childAsNode
-
>
GetNextSibling
(
)
;
}
}
if
(
aNode
!
=
mCommonParent
)
{
rv
=
SerializeNodeEnd
(
*
aNode
aString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeContextStart
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
nsAString
&
aString
)
{
if
(
mDisableContextSerialize
)
{
return
NS_OK
;
}
AutoTArray
<
nsINode
*
8
>
*
serializedContext
=
mRangeContexts
.
AppendElement
(
)
;
int32_t
i
=
aAncestorArray
.
Length
(
)
j
;
nsresult
rv
=
NS_OK
;
j
=
GetImmediateContextCount
(
aAncestorArray
)
;
while
(
i
>
0
)
{
nsINode
*
node
=
aAncestorArray
.
ElementAt
(
-
-
i
)
;
if
(
!
node
)
break
;
if
(
IncludeInContext
(
node
)
|
|
i
<
j
)
{
rv
=
SerializeNodeStart
(
*
node
0
-
1
aString
)
;
serializedContext
-
>
AppendElement
(
node
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
}
}
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeContextEnd
(
nsAString
&
aString
)
{
if
(
mDisableContextSerialize
)
{
return
NS_OK
;
}
MOZ_RELEASE_ASSERT
(
!
mRangeContexts
.
IsEmpty
(
)
"
Tried
to
end
context
without
starting
one
.
"
)
;
AutoTArray
<
nsINode
*
8
>
&
serializedContext
=
mRangeContexts
.
LastElement
(
)
;
nsresult
rv
=
NS_OK
;
for
(
nsINode
*
node
:
Reversed
(
serializedContext
)
)
{
rv
=
SerializeNodeEnd
(
*
node
aString
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
}
mRangeContexts
.
RemoveLastElement
(
)
;
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeToString
(
nsRange
*
aRange
nsAString
&
aOutputString
)
{
if
(
!
aRange
|
|
aRange
-
>
Collapsed
(
)
)
return
NS_OK
;
mCommonParent
=
aRange
-
>
GetCommonAncestor
(
)
;
if
(
!
mCommonParent
)
return
NS_OK
;
nsINode
*
startContainer
=
aRange
-
>
GetStartContainer
(
)
;
NS_ENSURE_TRUE
(
startContainer
NS_ERROR_FAILURE
)
;
int32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
nsINode
*
endContainer
=
aRange
-
>
GetEndContainer
(
)
;
NS_ENSURE_TRUE
(
endContainer
NS_ERROR_FAILURE
)
;
int32_t
endOffset
=
aRange
-
>
EndOffset
(
)
;
mStartDepth
=
mEndDepth
=
0
;
mCommonAncestors
.
Clear
(
)
;
mStartNodes
.
Clear
(
)
;
mStartOffsets
.
Clear
(
)
;
mEndNodes
.
Clear
(
)
;
mEndOffsets
.
Clear
(
)
;
nsContentUtils
:
:
GetAncestors
(
mCommonParent
mCommonAncestors
)
;
nsContentUtils
:
:
GetAncestorsAndOffsets
(
startContainer
startOffset
&
mStartNodes
&
mStartOffsets
)
;
nsContentUtils
:
:
GetAncestorsAndOffsets
(
endContainer
endOffset
&
mEndNodes
&
mEndOffsets
)
;
nsCOMPtr
<
nsIContent
>
commonContent
=
do_QueryInterface
(
mCommonParent
)
;
mStartRootIndex
=
mStartNodes
.
IndexOf
(
commonContent
)
;
mEndRootIndex
=
mEndNodes
.
IndexOf
(
commonContent
)
;
nsresult
rv
=
NS_OK
;
rv
=
SerializeRangeContextStart
(
mCommonAncestors
aOutputString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
startContainer
=
=
endContainer
&
&
IsTextNode
(
startContainer
)
)
{
if
(
mFlags
&
SkipInvisibleContent
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
startContainer
)
;
if
(
content
&
&
!
content
-
>
GetPrimaryFrame
(
)
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
!
parent
|
|
!
IsVisibleNode
(
parent
)
)
return
NS_OK
;
}
}
rv
=
SerializeNodeStart
(
*
startContainer
startOffset
endOffset
aOutputString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SerializeNodeEnd
(
*
startContainer
aOutputString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
SerializeRangeNodes
(
aRange
mCommonParent
aOutputString
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
SerializeRangeContextEnd
(
aOutputString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
void
nsDocumentEncoder
:
:
Clear
(
)
{
mDocument
=
nullptr
;
mSelection
=
nullptr
;
mRange
=
nullptr
;
mNode
=
nullptr
;
mCommonParent
=
nullptr
;
mNodeFixup
=
nullptr
;
Initialize
(
false
)
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToString
(
nsAString
&
aOutputString
)
{
return
EncodeToStringWithMaxLength
(
0
aOutputString
)
;
}
static
bool
ParentIsTR
(
nsIContent
*
aContent
)
{
mozilla
:
:
dom
:
:
Element
*
parent
=
aContent
-
>
GetParentElement
(
)
;
if
(
!
parent
)
{
return
false
;
}
return
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToStringWithMaxLength
(
uint32_t
aMaxLength
nsAString
&
aOutputString
)
{
MOZ_ASSERT
(
mRangeContexts
.
IsEmpty
(
)
"
Re
-
entrant
call
to
nsDocumentEncoder
.
"
)
;
auto
rangeContextGuard
=
MakeScopeExit
(
[
&
]
{
mRangeContexts
.
Clear
(
)
;
}
)
;
if
(
!
mDocument
)
return
NS_ERROR_NOT_INITIALIZED
;
AutoReleaseDocumentIfNeeded
autoReleaseDocument
(
this
)
;
aOutputString
.
Truncate
(
)
;
nsString
output
;
static
const
size_t
bufferSize
=
2048
;
if
(
!
mCachedBuffer
)
{
mCachedBuffer
=
nsStringBuffer
:
:
Alloc
(
bufferSize
)
.
take
(
)
;
if
(
NS_WARN_IF
(
!
mCachedBuffer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
NS_ASSERTION
(
!
mCachedBuffer
-
>
IsReadonly
(
)
"
nsIDocumentEncoder
shouldn
'
t
keep
reference
to
non
-
readonly
buffer
!
"
)
;
static_cast
<
char16_t
*
>
(
mCachedBuffer
-
>
Data
(
)
)
[
0
]
=
char16_t
(
0
)
;
mCachedBuffer
-
>
ToString
(
0
output
true
)
;
mCachedBuffer
=
nullptr
;
if
(
!
mSerializer
)
{
nsAutoCString
progId
(
NS_CONTENTSERIALIZER_CONTRACTID_PREFIX
)
;
AppendUTF16toUTF8
(
mMimeType
progId
)
;
mSerializer
=
do_CreateInstance
(
progId
.
get
(
)
)
;
NS_ENSURE_TRUE
(
mSerializer
NS_ERROR_NOT_IMPLEMENTED
)
;
}
nsresult
rv
=
NS_OK
;
bool
rewriteEncodingDeclaration
=
!
(
mSelection
|
|
mRange
|
|
mNode
)
&
&
!
(
mFlags
&
OutputDontRewriteEncodingDeclaration
)
;
mSerializer
-
>
Init
(
mFlags
mWrapColumn
mEncoding
mIsCopying
rewriteEncodingDeclaration
&
mNeedsPreformatScanning
)
;
if
(
mSelection
)
{
uint32_t
count
=
mSelection
-
>
RangeCount
(
)
;
nsCOMPtr
<
nsINode
>
node
prevNode
;
uint32_t
firstRangeStartDepth
=
0
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
RefPtr
<
nsRange
>
range
=
mSelection
-
>
GetRangeAt
(
i
)
;
node
=
range
-
>
GetStartContainer
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
if
(
node
!
=
prevNode
)
{
if
(
prevNode
)
{
rv
=
SerializeNodeEnd
(
*
prevNode
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
&
&
!
ParentIsTR
(
content
)
)
{
if
(
!
prevNode
)
{
mCommonAncestors
.
Clear
(
)
;
nsContentUtils
:
:
GetAncestors
(
node
-
>
GetParentNode
(
)
mCommonAncestors
)
;
rv
=
SerializeRangeContextStart
(
mCommonAncestors
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDisableContextSerialize
=
true
;
}
rv
=
SerializeNodeStart
(
*
node
0
-
1
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
prevNode
=
node
;
}
else
if
(
prevNode
)
{
mDisableContextSerialize
=
false
;
rv
=
SerializeRangeContextEnd
(
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
prevNode
=
nullptr
;
}
}
rv
=
SerializeRangeToString
(
range
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
i
=
=
0
)
{
firstRangeStartDepth
=
mStartDepth
;
}
}
mStartDepth
=
firstRangeStartDepth
;
if
(
prevNode
)
{
rv
=
SerializeNodeEnd
(
*
prevNode
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDisableContextSerialize
=
false
;
rv
=
SerializeRangeContextEnd
(
output
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mDisableContextSerialize
=
false
;
mSelection
=
nullptr
;
}
else
if
(
mRange
)
{
rv
=
SerializeRangeToString
(
mRange
output
)
;
mRange
=
nullptr
;
}
else
if
(
mNode
)
{
if
(
!
mNodeFixup
&
&
!
(
mFlags
&
SkipInvisibleContent
)
&
&
!
mStream
&
&
mNodeIsContainer
)
{
rv
=
SerializeToStringIterative
(
mNode
output
)
;
}
else
{
rv
=
SerializeToStringRecursive
(
mNode
output
mNodeIsContainer
)
;
}
mNode
=
nullptr
;
}
else
{
rv
=
mSerializer
-
>
AppendDocumentStart
(
mDocument
output
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
SerializeToStringRecursive
(
mDocument
output
false
aMaxLength
)
;
}
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mSerializer
-
>
Flush
(
output
)
;
mCachedBuffer
=
nsStringBuffer
:
:
FromString
(
output
)
;
bool
setOutput
=
false
;
if
(
mCachedBuffer
)
{
if
(
mCachedBuffer
-
>
StorageSize
(
)
=
=
bufferSize
&
&
!
mCachedBuffer
-
>
IsReadonly
(
)
)
{
mCachedBuffer
-
>
AddRef
(
)
;
}
else
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
mCachedBuffer
-
>
ToString
(
output
.
Length
(
)
aOutputString
)
;
setOutput
=
true
;
}
mCachedBuffer
=
nullptr
;
}
}
if
(
!
setOutput
&
&
NS_SUCCEEDED
(
rv
)
)
{
aOutputString
.
Append
(
output
.
get
(
)
output
.
Length
(
)
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToStream
(
nsIOutputStream
*
aStream
)
{
MOZ_ASSERT
(
mRangeContexts
.
IsEmpty
(
)
"
Re
-
entrant
call
to
nsDocumentEncoder
.
"
)
;
auto
rangeContextGuard
=
MakeScopeExit
(
[
&
]
{
mRangeContexts
.
Clear
(
)
;
}
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mDocument
)
return
NS_ERROR_NOT_INITIALIZED
;
if
(
!
mEncoding
)
{
return
NS_ERROR_UCONV_NOCONV
;
}
mUnicodeEncoder
=
mEncoding
-
>
NewEncoder
(
)
;
mIsPlainText
=
(
mMimeType
.
LowerCaseEqualsLiteral
(
"
text
/
plain
"
)
)
;
mStream
=
aStream
;
nsAutoString
buf
;
rv
=
EncodeToString
(
buf
)
;
FlushText
(
buf
true
)
;
mStream
=
nullptr
;
mUnicodeEncoder
=
nullptr
;
return
rv
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToStringWithContext
(
nsAString
&
aContextString
nsAString
&
aInfoString
nsAString
&
aEncodedString
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetNodeFixup
(
nsIDocumentEncoderNodeFixup
*
aFixup
)
{
mNodeFixup
=
aFixup
;
return
NS_OK
;
}
bool
do_getDocumentTypeSupportedForEncoding
(
const
char
*
aContentType
)
{
if
(
!
nsCRT
:
:
strcmp
(
aContentType
"
text
/
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
application
/
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
application
/
xhtml
+
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
image
/
svg
+
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
text
/
html
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
text
/
plain
"
)
)
{
return
true
;
}
return
false
;
}
already_AddRefed
<
nsIDocumentEncoder
>
do_createDocumentEncoder
(
const
char
*
aContentType
)
{
if
(
do_getDocumentTypeSupportedForEncoding
(
aContentType
)
)
{
return
do_AddRef
(
new
nsDocumentEncoder
)
;
}
return
nullptr
;
}
class
nsHTMLCopyEncoder
:
public
nsDocumentEncoder
{
public
:
nsHTMLCopyEncoder
(
)
;
virtual
~
nsHTMLCopyEncoder
(
)
;
NS_IMETHOD
Init
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
SetSelection
(
Selection
*
aSelection
)
override
;
NS_IMETHOD
EncodeToStringWithContext
(
nsAString
&
aContextString
nsAString
&
aInfoString
nsAString
&
aEncodedString
)
override
;
NS_IMETHOD
EncodeToString
(
nsAString
&
aOutputString
)
override
;
protected
:
enum
Endpoint
{
kStart
kEnd
}
;
nsresult
PromoteRange
(
nsRange
*
inRange
)
;
nsresult
PromoteAncestorChain
(
nsCOMPtr
<
nsINode
>
*
ioNode
int32_t
*
ioStartOffset
int32_t
*
ioEndOffset
)
;
nsresult
GetPromotedPoint
(
Endpoint
aWhere
nsINode
*
aNode
int32_t
aOffset
nsCOMPtr
<
nsINode
>
*
outNode
int32_t
*
outOffset
nsINode
*
aCommon
)
;
static
nsCOMPtr
<
nsINode
>
GetChildAt
(
nsINode
*
aParent
int32_t
aOffset
)
;
static
bool
IsMozBR
(
Element
*
aNode
)
;
static
nsresult
GetNodeLocation
(
nsINode
*
inChild
nsCOMPtr
<
nsINode
>
*
outParent
int32_t
*
outOffset
)
;
bool
IsRoot
(
nsINode
*
aNode
)
;
static
bool
IsFirstNode
(
nsINode
*
aNode
)
;
static
bool
IsLastNode
(
nsINode
*
aNode
)
;
virtual
bool
IncludeInContext
(
nsINode
*
aNode
)
override
;
virtual
int32_t
GetImmediateContextCount
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
override
;
bool
mIsTextWidget
;
}
;
nsHTMLCopyEncoder
:
:
nsHTMLCopyEncoder
(
)
{
mIsTextWidget
=
false
;
}
nsHTMLCopyEncoder
:
:
~
nsHTMLCopyEncoder
(
)
{
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
Init
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
{
if
(
!
aDocument
)
return
NS_ERROR_INVALID_ARG
;
mIsTextWidget
=
false
;
Initialize
(
)
;
mIsCopying
=
true
;
mDocument
=
aDocument
;
if
(
aMimeType
.
EqualsLiteral
(
"
text
/
plain
"
)
)
{
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
}
else
{
mMimeType
.
AssignLiteral
(
"
text
/
html
"
)
;
}
mFlags
=
aFlags
|
OutputAbsoluteLinks
;
if
(
!
mDocument
-
>
IsScriptEnabled
(
)
)
mFlags
|
=
OutputNoScriptContent
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
SetSelection
(
Selection
*
aSelection
)
{
if
(
!
aSelection
)
return
NS_ERROR_NULL_POINTER
;
uint32_t
rangeCount
=
aSelection
-
>
RangeCount
(
)
;
if
(
!
rangeCount
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
aSelection
-
>
GetRangeAt
(
0
)
;
nsINode
*
commonParent
=
range
-
>
GetCommonAncestor
(
)
;
for
(
nsCOMPtr
<
nsIContent
>
selContent
(
do_QueryInterface
(
commonParent
)
)
;
selContent
;
selContent
=
selContent
-
>
GetParent
(
)
)
{
if
(
selContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
input
nsGkAtoms
:
:
textarea
)
)
{
mIsTextWidget
=
true
;
break
;
}
}
if
(
mIsTextWidget
)
{
mSelection
=
aSelection
;
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
mDocument
)
;
if
(
!
(
htmlDoc
&
&
mDocument
-
>
IsHTMLDocument
(
)
)
)
{
mIsTextWidget
=
true
;
mSelection
=
aSelection
;
return
NS_OK
;
}
mSelection
=
new
Selection
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
range
=
aSelection
-
>
GetRangeAt
(
rangeIdx
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
RefPtr
<
nsRange
>
myRange
=
range
-
>
CloneRange
(
)
;
MOZ_ASSERT
(
myRange
)
;
nsresult
rv
=
PromoteRange
(
myRange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ErrorResult
result
;
RefPtr
<
Selection
>
selection
(
mSelection
)
;
RefPtr
<
Document
>
document
(
mDocument
)
;
selection
-
>
AddRangeInternal
(
*
myRange
document
result
)
;
rv
=
result
.
StealNSResult
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
EncodeToString
(
nsAString
&
aOutputString
)
{
if
(
mIsTextWidget
)
{
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
}
return
nsDocumentEncoder
:
:
EncodeToString
(
aOutputString
)
;
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
EncodeToStringWithContext
(
nsAString
&
aContextString
nsAString
&
aInfoString
nsAString
&
aEncodedString
)
{
nsresult
rv
=
EncodeToString
(
aEncodedString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mIsTextWidget
)
return
NS_OK
;
int32_t
count
=
mCommonAncestors
.
Length
(
)
;
int32_t
i
;
nsCOMPtr
<
nsINode
>
node
;
if
(
count
>
0
)
node
=
mCommonAncestors
.
ElementAt
(
0
)
;
if
(
node
&
&
IsTextNode
(
node
)
)
{
mCommonAncestors
.
RemoveElementAt
(
0
)
;
if
(
mStartDepth
)
mStartDepth
-
-
;
if
(
mEndDepth
)
mEndDepth
-
-
;
count
-
-
;
}
i
=
count
;
while
(
i
>
0
)
{
node
=
mCommonAncestors
.
ElementAt
(
-
-
i
)
;
SerializeNodeStart
(
*
node
0
-
1
aContextString
)
;
}
while
(
i
<
count
)
{
node
=
mCommonAncestors
.
ElementAt
(
i
+
+
)
;
SerializeNodeEnd
(
*
node
aContextString
)
;
}
nsAutoString
infoString
;
infoString
.
AppendInt
(
mStartDepth
)
;
infoString
.
Append
(
char16_t
(
'
'
)
)
;
infoString
.
AppendInt
(
mEndDepth
)
;
aInfoString
=
infoString
;
return
NS_OK
;
}
bool
nsHTMLCopyEncoder
:
:
IncludeInContext
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aNode
)
)
;
if
(
!
content
)
return
false
;
return
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
b
nsGkAtoms
:
:
i
nsGkAtoms
:
:
u
nsGkAtoms
:
:
a
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
s
nsGkAtoms
:
:
big
nsGkAtoms
:
:
small
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
em
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
code
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
var
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
font
nsGkAtoms
:
:
script
nsGkAtoms
:
:
span
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
)
;
}
nsresult
nsHTMLCopyEncoder
:
:
PromoteRange
(
nsRange
*
inRange
)
{
if
(
!
inRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsINode
>
startNode
=
inRange
-
>
GetStartContainer
(
)
;
uint32_t
startOffset
=
inRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
inRange
-
>
GetEndContainer
(
)
;
uint32_t
endOffset
=
inRange
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
common
=
inRange
-
>
GetCommonAncestor
(
)
;
nsCOMPtr
<
nsINode
>
opStartNode
;
nsCOMPtr
<
nsINode
>
opEndNode
;
int32_t
opStartOffset
opEndOffset
;
nsresult
rv
=
GetPromotedPoint
(
kStart
startNode
static_cast
<
int32_t
>
(
startOffset
)
address_of
(
opStartNode
)
&
opStartOffset
common
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPromotedPoint
(
kEnd
endNode
static_cast
<
int32_t
>
(
endOffset
)
address_of
(
opEndNode
)
&
opEndOffset
common
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
opStartNode
=
=
common
&
&
opEndNode
=
=
common
)
{
rv
=
PromoteAncestorChain
(
address_of
(
opStartNode
)
&
opStartOffset
&
opEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
opEndNode
=
opStartNode
;
}
ErrorResult
err
;
inRange
-
>
SetStart
(
*
opStartNode
static_cast
<
uint32_t
>
(
opStartOffset
)
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
inRange
-
>
SetEnd
(
*
opEndNode
static_cast
<
uint32_t
>
(
opEndOffset
)
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
nsHTMLCopyEncoder
:
:
PromoteAncestorChain
(
nsCOMPtr
<
nsINode
>
*
ioNode
int32_t
*
ioStartOffset
int32_t
*
ioEndOffset
)
{
if
(
!
ioNode
|
|
!
ioStartOffset
|
|
!
ioEndOffset
)
return
NS_ERROR_NULL_POINTER
;
nsresult
rv
=
NS_OK
;
bool
done
=
false
;
nsCOMPtr
<
nsINode
>
frontNode
endNode
parent
;
int32_t
frontOffset
endOffset
;
nsCOMPtr
<
nsINode
>
node
=
*
ioNode
;
bool
isEditable
=
node
-
>
IsEditable
(
)
;
while
(
!
done
)
{
node
=
*
ioNode
;
parent
=
node
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
done
=
true
;
}
else
{
rv
=
GetPromotedPoint
(
kStart
*
ioNode
*
ioStartOffset
address_of
(
frontNode
)
&
frontOffset
parent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPromotedPoint
(
kEnd
*
ioNode
*
ioEndOffset
address_of
(
endNode
)
&
endOffset
parent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
(
frontNode
!
=
parent
)
|
|
(
endNode
!
=
parent
)
|
|
(
frontNode
-
>
IsEditable
(
)
!
=
isEditable
)
)
done
=
true
;
else
{
*
ioNode
=
frontNode
;
*
ioStartOffset
=
frontOffset
;
*
ioEndOffset
=
endOffset
;
}
}
}
return
rv
;
}
nsresult
nsHTMLCopyEncoder
:
:
GetPromotedPoint
(
Endpoint
aWhere
nsINode
*
aNode
int32_t
aOffset
nsCOMPtr
<
nsINode
>
*
outNode
int32_t
*
outOffset
nsINode
*
common
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsINode
>
node
=
aNode
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
;
int32_t
offset
=
aOffset
;
bool
bResetPromotion
=
false
;
*
outNode
=
node
;
*
outOffset
=
offset
;
if
(
common
=
=
node
)
return
NS_OK
;
if
(
aWhere
=
=
kStart
)
{
if
(
auto
nodeAsText
=
aNode
-
>
GetAsText
(
)
)
{
if
(
offset
>
0
)
{
nsAutoString
text
;
nodeAsText
-
>
SubstringData
(
0
offset
text
IgnoreErrors
(
)
)
;
text
.
CompressWhitespace
(
)
;
if
(
!
text
.
IsEmpty
(
)
)
return
NS_OK
;
bResetPromotion
=
true
;
}
rv
=
GetNodeLocation
(
aNode
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
node
=
GetChildAt
(
parent
offset
)
;
}
if
(
!
node
)
node
=
parent
;
if
(
!
IsRoot
(
node
)
&
&
(
parent
!
=
common
)
)
{
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
return
NS_OK
;
while
(
(
IsFirstNode
(
node
)
)
&
&
(
!
IsRoot
(
parent
)
)
&
&
(
parent
!
=
common
)
)
{
if
(
bResetPromotion
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
parent
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
)
)
{
if
(
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
)
{
bResetPromotion
=
false
;
}
}
}
node
=
parent
;
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
{
parent
=
node
;
offset
=
0
;
break
;
}
}
if
(
bResetPromotion
)
{
*
outNode
=
aNode
;
*
outOffset
=
aOffset
;
}
else
{
*
outNode
=
parent
;
*
outOffset
=
offset
;
}
return
rv
;
}
}
if
(
aWhere
=
=
kEnd
)
{
if
(
auto
nodeAsText
=
aNode
-
>
GetAsText
(
)
)
{
uint32_t
len
=
aNode
-
>
Length
(
)
;
if
(
offset
<
(
int32_t
)
len
)
{
nsAutoString
text
;
nodeAsText
-
>
SubstringData
(
offset
len
-
offset
text
IgnoreErrors
(
)
)
;
text
.
CompressWhitespace
(
)
;
if
(
!
text
.
IsEmpty
(
)
)
return
NS_OK
;
bResetPromotion
=
true
;
}
rv
=
GetNodeLocation
(
aNode
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
offset
)
offset
-
-
;
node
=
GetChildAt
(
parent
offset
)
;
}
if
(
!
node
)
node
=
parent
;
if
(
!
IsRoot
(
node
)
&
&
(
parent
!
=
common
)
)
{
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
return
NS_OK
;
while
(
(
IsLastNode
(
node
)
)
&
&
(
!
IsRoot
(
parent
)
)
&
&
(
parent
!
=
common
)
)
{
if
(
bResetPromotion
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
parent
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
)
)
{
if
(
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
)
{
bResetPromotion
=
false
;
}
}
}
node
=
parent
;
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
{
parent
=
node
;
offset
=
0
;
break
;
}
}
if
(
bResetPromotion
)
{
*
outNode
=
aNode
;
*
outOffset
=
aOffset
;
}
else
{
*
outNode
=
parent
;
offset
+
+
;
*
outOffset
=
offset
;
}
return
rv
;
}
}
return
rv
;
}
nsCOMPtr
<
nsINode
>
nsHTMLCopyEncoder
:
:
GetChildAt
(
nsINode
*
aParent
int32_t
aOffset
)
{
nsCOMPtr
<
nsINode
>
resultNode
;
if
(
!
aParent
)
return
resultNode
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aParent
)
;
MOZ_ASSERT
(
content
"
null
content
in
nsHTMLCopyEncoder
:
:
GetChildAt
"
)
;
resultNode
=
content
-
>
GetChildAt_Deprecated
(
aOffset
)
;
return
resultNode
;
}
bool
nsHTMLCopyEncoder
:
:
IsMozBR
(
Element
*
aElement
)
{
return
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
&
&
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
_moz
"
)
eIgnoreCase
)
;
}
nsresult
nsHTMLCopyEncoder
:
:
GetNodeLocation
(
nsINode
*
inChild
nsCOMPtr
<
nsINode
>
*
outParent
int32_t
*
outOffset
)
{
NS_ASSERTION
(
(
inChild
&
&
outParent
&
&
outOffset
)
"
bad
args
"
)
;
if
(
inChild
&
&
outParent
&
&
outOffset
)
{
nsCOMPtr
<
nsIContent
>
child
=
do_QueryInterface
(
inChild
)
;
if
(
!
child
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsIContent
*
parent
=
child
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
outParent
=
parent
;
*
outOffset
=
parent
-
>
ComputeIndexOf
(
child
)
;
return
NS_OK
;
}
return
NS_ERROR_NULL_POINTER
;
}
bool
nsHTMLCopyEncoder
:
:
IsRoot
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aNode
)
;
if
(
!
content
)
{
return
false
;
}
if
(
mIsTextWidget
)
{
return
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
;
}
return
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
;
}
bool
nsHTMLCopyEncoder
:
:
IsFirstNode
(
nsINode
*
aNode
)
{
for
(
nsIContent
*
sibling
=
aNode
-
>
GetPreviousSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetPreviousSibling
(
)
)
{
if
(
!
sibling
-
>
TextIsOnlyWhitespace
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsHTMLCopyEncoder
:
:
IsLastNode
(
nsINode
*
aNode
)
{
for
(
nsIContent
*
sibling
=
aNode
-
>
GetNextSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
sibling
-
>
IsElement
(
)
&
&
IsMozBR
(
sibling
-
>
AsElement
(
)
)
)
{
continue
;
}
if
(
!
sibling
-
>
TextIsOnlyWhitespace
(
)
)
{
return
false
;
}
}
return
true
;
}
already_AddRefed
<
nsIDocumentEncoder
>
do_createHTMLCopyEncoder
(
)
{
return
do_AddRef
(
new
nsHTMLCopyEncoder
)
;
}
int32_t
nsHTMLCopyEncoder
:
:
GetImmediateContextCount
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
{
int32_t
i
=
aAncestorArray
.
Length
(
)
j
=
0
;
while
(
j
<
i
)
{
nsINode
*
node
=
aAncestorArray
.
ElementAt
(
j
)
;
if
(
!
node
)
{
break
;
}
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
node
)
)
;
if
(
!
content
|
|
!
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
table
)
)
{
break
;
}
+
+
j
;
}
return
j
;
}
