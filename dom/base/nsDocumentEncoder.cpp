#
include
"
nsIDocumentEncoder
.
h
"
#
include
<
utility
>
#
include
"
nscore
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContentSerializer
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
nsIOutputStream
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsElementTable
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsStringBuffer
.
h
"
#
include
"
mozilla
/
dom
/
Comment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
mozilla
/
dom
/
ProcessingInstruction
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
enum
nsRangeIterationDirection
{
kDirectionOut
=
-
1
kDirectionIn
=
1
}
;
class
TextStreamer
{
public
:
TextStreamer
(
nsIOutputStream
&
aStream
UniquePtr
<
Encoder
>
aUnicodeEncoder
bool
aIsPlainText
nsAString
&
aOutputBuffer
)
;
nsresult
FlushIfStringLongEnough
(
)
;
nsresult
ForceFlush
(
)
;
private
:
const
static
uint32_t
kMaxLengthBeforeFlush
=
1024
;
const
static
uint32_t
kEncoderBufferSizeInBytes
=
4096
;
nsresult
EncodeAndWrite
(
)
;
nsresult
EncodeAndWriteAndTruncate
(
)
;
const
nsCOMPtr
<
nsIOutputStream
>
mStream
;
const
UniquePtr
<
Encoder
>
mUnicodeEncoder
;
const
bool
mIsPlainText
;
nsAString
&
mOutputBuffer
;
}
;
TextStreamer
:
:
TextStreamer
(
nsIOutputStream
&
aStream
UniquePtr
<
Encoder
>
aUnicodeEncoder
bool
aIsPlainText
nsAString
&
aOutputBuffer
)
:
mStream
{
&
aStream
}
mUnicodeEncoder
(
std
:
:
move
(
aUnicodeEncoder
)
)
mIsPlainText
(
aIsPlainText
)
mOutputBuffer
(
aOutputBuffer
)
{
MOZ_ASSERT
(
mUnicodeEncoder
)
;
}
nsresult
TextStreamer
:
:
FlushIfStringLongEnough
(
)
{
nsresult
rv
=
NS_OK
;
if
(
mOutputBuffer
.
Length
(
)
>
kMaxLengthBeforeFlush
)
{
rv
=
EncodeAndWriteAndTruncate
(
)
;
}
return
rv
;
}
nsresult
TextStreamer
:
:
ForceFlush
(
)
{
return
EncodeAndWriteAndTruncate
(
)
;
}
nsresult
TextStreamer
:
:
EncodeAndWrite
(
)
{
if
(
mOutputBuffer
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
uint8_t
buffer
[
kEncoderBufferSizeInBytes
]
;
auto
src
=
MakeSpan
(
mOutputBuffer
)
;
auto
bufferSpan
=
MakeSpan
(
buffer
)
;
auto
dst
=
bufferSpan
.
To
(
bufferSpan
.
Length
(
)
-
1
)
;
for
(
;
;
)
{
uint32_t
result
;
size_t
read
;
size_t
written
;
bool
hadErrors
;
if
(
mIsPlainText
)
{
Tie
(
result
read
written
)
=
mUnicodeEncoder
-
>
EncodeFromUTF16WithoutReplacement
(
src
dst
false
)
;
if
(
result
!
=
kInputEmpty
&
&
result
!
=
kOutputFull
)
{
dst
[
written
+
+
]
=
'
?
'
;
}
}
else
{
Tie
(
result
read
written
hadErrors
)
=
mUnicodeEncoder
-
>
EncodeFromUTF16
(
src
dst
false
)
;
}
Unused
<
<
hadErrors
;
src
=
src
.
From
(
read
)
;
bufferSpan
[
written
]
=
0
;
uint32_t
streamWritten
;
nsresult
rv
=
mStream
-
>
Write
(
reinterpret_cast
<
char
*
>
(
dst
.
Elements
(
)
)
written
&
streamWritten
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
result
=
=
kInputEmpty
)
{
return
NS_OK
;
}
}
}
nsresult
TextStreamer
:
:
EncodeAndWriteAndTruncate
(
)
{
const
nsresult
rv
=
EncodeAndWrite
(
)
;
mOutputBuffer
.
Truncate
(
)
;
return
rv
;
}
class
EncodingScope
{
public
:
bool
IsLimited
(
)
const
;
RefPtr
<
Selection
>
mSelection
;
RefPtr
<
nsRange
>
mRange
;
nsCOMPtr
<
nsINode
>
mNode
;
bool
mNodeIsContainer
=
false
;
}
;
bool
EncodingScope
:
:
IsLimited
(
)
const
{
return
mSelection
|
|
mRange
|
|
mNode
;
}
struct
RangeBoundaryPathsAndOffsets
{
using
ContainerPath
=
AutoTArray
<
nsIContent
*
8
>
;
using
ContainerOffsets
=
AutoTArray
<
int32_t
8
>
;
ContainerPath
mStartContainerPath
;
ContainerOffsets
mStartContainerOffsets
;
ContainerPath
mEndContainerPath
;
ContainerOffsets
mEndContainerOffsets
;
}
;
struct
ContextInfoDepth
{
uint32_t
mStart
=
0
;
uint32_t
mEnd
=
0
;
}
;
class
nsDocumentEncoder
:
public
nsIDocumentEncoder
{
public
:
nsDocumentEncoder
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsDocumentEncoder
)
NS_DECL_NSIDOCUMENTENCODER
protected
:
virtual
~
nsDocumentEncoder
(
)
;
void
Initialize
(
bool
aClearCachedSerializer
=
true
)
;
nsresult
SerializeDependingOnScope
(
uint32_t
aMaxLength
)
;
nsresult
SerializeSelection
(
)
;
nsresult
SerializeNode
(
)
;
nsresult
SerializeWholeDocument
(
uint32_t
aMaxLength
)
;
nsresult
SerializeNodeStart
(
nsINode
&
aOriginalNode
int32_t
aStartOffset
int32_t
aEndOffset
nsINode
*
aFixupNode
=
nullptr
)
;
nsresult
SerializeToStringRecursive
(
nsINode
*
aNode
bool
aDontSerializeRoot
uint32_t
aMaxLength
=
0
)
;
nsresult
SerializeNodeEnd
(
nsINode
&
aOriginalNode
nsINode
*
aFixupNode
=
nullptr
)
;
nsresult
SerializeToStringIterative
(
nsINode
*
aNode
)
;
nsresult
SerializeRangeToString
(
nsRange
*
aRange
)
;
nsresult
SerializeRangeNodes
(
nsRange
*
aRange
nsINode
*
aNode
int32_t
aDepth
)
;
nsresult
SerializeRangeContextStart
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
;
nsresult
SerializeRangeContextEnd
(
)
;
virtual
int32_t
GetImmediateContextCount
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
{
return
-
1
;
}
bool
IsInvisibleNodeAndShouldBeSkipped
(
nsINode
&
aNode
)
const
{
if
(
mFlags
&
SkipInvisibleContent
)
{
nsINode
*
node
{
&
aNode
}
;
if
(
ShadowRoot
*
shadowRoot
=
ShadowRoot
:
:
FromNode
(
node
)
)
{
node
=
shadowRoot
-
>
GetHost
(
)
;
}
if
(
node
-
>
IsContent
(
)
)
{
nsIFrame
*
frame
=
node
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
if
(
node
-
>
IsElement
(
)
&
&
node
-
>
AsElement
(
)
-
>
IsDisplayContents
(
)
)
{
return
false
;
}
if
(
node
-
>
IsText
(
)
)
{
return
false
;
}
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
rp
)
)
{
return
false
;
}
return
true
;
}
bool
isVisible
=
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
if
(
!
isVisible
&
&
node
-
>
IsText
(
)
)
{
return
true
;
}
}
}
return
false
;
}
virtual
bool
IncludeInContext
(
nsINode
*
aNode
)
;
void
ReleaseDocumentReferenceAndInitialize
(
bool
aClearCachedSerializer
)
;
class
MOZ_STACK_CLASS
AutoReleaseDocumentIfNeeded
final
{
public
:
explicit
AutoReleaseDocumentIfNeeded
(
nsDocumentEncoder
*
aEncoder
)
:
mEncoder
(
aEncoder
)
{
}
~
AutoReleaseDocumentIfNeeded
(
)
{
if
(
mEncoder
-
>
mFlags
&
RequiresReinitAfterOutput
)
{
const
bool
clearCachedSerializer
=
false
;
mEncoder
-
>
ReleaseDocumentReferenceAndInitialize
(
clearCachedSerializer
)
;
}
}
private
:
nsDocumentEncoder
*
mEncoder
;
}
;
nsCOMPtr
<
Document
>
mDocument
;
EncodingScope
mEncodingScope
;
nsCOMPtr
<
nsIContentSerializer
>
mSerializer
;
Maybe
<
TextStreamer
>
mTextStreamer
;
nsCOMPtr
<
nsINode
>
mCommonAncestorOfRange
;
nsCOMPtr
<
nsIDocumentEncoderNodeFixup
>
mNodeFixup
;
nsString
mMimeType
;
const
Encoding
*
mEncoding
;
uint32_t
mFlags
;
uint32_t
mWrapColumn
;
ContextInfoDepth
mContextInfoDepth
;
int32_t
mStartRootIndex
;
int32_t
mEndRootIndex
;
AutoTArray
<
nsINode
*
8
>
mCommonAncestors
;
RangeBoundaryPathsAndOffsets
mRangeBoundaryPathsAndOffsets
;
AutoTArray
<
AutoTArray
<
nsINode
*
8
>
8
>
mRangeContexts
;
bool
mNeedsPreformatScanning
;
bool
mHaltRangeHint
;
bool
mDisableContextSerialize
;
bool
mIsCopying
;
nsStringBuffer
*
mCachedBuffer
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsDocumentEncoder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsDocumentEncoder
ReleaseDocumentReferenceAndInitialize
(
true
)
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsDocumentEncoder
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentEncoder
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsDocumentEncoder
mDocument
mEncodingScope
.
mSelection
mEncodingScope
.
mRange
mEncodingScope
.
mNode
mSerializer
mCommonAncestorOfRange
)
nsDocumentEncoder
:
:
nsDocumentEncoder
(
)
:
mEncoding
(
nullptr
)
mIsCopying
(
false
)
mCachedBuffer
(
nullptr
)
{
Initialize
(
)
;
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
}
void
nsDocumentEncoder
:
:
Initialize
(
bool
aClearCachedSerializer
)
{
mFlags
=
0
;
mWrapColumn
=
72
;
mContextInfoDepth
=
{
}
;
mStartRootIndex
=
0
;
mEndRootIndex
=
0
;
mNeedsPreformatScanning
=
false
;
mHaltRangeHint
=
false
;
mDisableContextSerialize
=
false
;
mEncodingScope
=
{
}
;
mCommonAncestorOfRange
=
nullptr
;
mNodeFixup
=
nullptr
;
mRangeBoundaryPathsAndOffsets
=
{
}
;
if
(
aClearCachedSerializer
)
{
mSerializer
=
nullptr
;
}
}
static
bool
ParentIsTR
(
nsIContent
*
aContent
)
{
mozilla
:
:
dom
:
:
Element
*
parent
=
aContent
-
>
GetParentElement
(
)
;
if
(
!
parent
)
{
return
false
;
}
return
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
;
}
nsresult
nsDocumentEncoder
:
:
SerializeDependingOnScope
(
uint32_t
aMaxLength
)
{
nsresult
rv
=
NS_OK
;
if
(
mEncodingScope
.
mSelection
)
{
rv
=
SerializeSelection
(
)
;
}
else
if
(
nsRange
*
range
=
mEncodingScope
.
mRange
)
{
rv
=
SerializeRangeToString
(
range
)
;
}
else
if
(
mEncodingScope
.
mNode
)
{
rv
=
SerializeNode
(
)
;
}
else
{
rv
=
SerializeWholeDocument
(
aMaxLength
)
;
}
mEncodingScope
=
{
}
;
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeSelection
(
)
{
NS_ENSURE_TRUE
(
mEncodingScope
.
mSelection
NS_ERROR_FAILURE
)
;
nsresult
rv
=
NS_OK
;
Selection
*
selection
=
mEncodingScope
.
mSelection
;
uint32_t
count
=
selection
-
>
RangeCount
(
)
;
nsCOMPtr
<
nsINode
>
node
;
nsCOMPtr
<
nsINode
>
prevNode
;
uint32_t
firstRangeStartDepth
=
0
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
i
)
;
node
=
range
-
>
GetStartContainer
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
if
(
node
!
=
prevNode
)
{
if
(
prevNode
)
{
rv
=
SerializeNodeEnd
(
*
prevNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
node
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
tr
)
&
&
!
ParentIsTR
(
content
)
)
{
if
(
!
prevNode
)
{
mCommonAncestors
.
Clear
(
)
;
nsContentUtils
:
:
GetAncestors
(
node
-
>
GetParentNode
(
)
mCommonAncestors
)
;
rv
=
SerializeRangeContextStart
(
mCommonAncestors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDisableContextSerialize
=
true
;
}
rv
=
SerializeNodeStart
(
*
node
0
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
prevNode
=
node
;
}
else
if
(
prevNode
)
{
mDisableContextSerialize
=
false
;
rv
=
SerializeRangeContextEnd
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
prevNode
=
nullptr
;
}
}
rv
=
SerializeRangeToString
(
range
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
i
=
=
0
)
{
firstRangeStartDepth
=
mContextInfoDepth
.
mStart
;
}
}
mContextInfoDepth
.
mStart
=
firstRangeStartDepth
;
if
(
prevNode
)
{
rv
=
SerializeNodeEnd
(
*
prevNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDisableContextSerialize
=
false
;
rv
=
SerializeRangeContextEnd
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mDisableContextSerialize
=
false
;
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeNode
(
)
{
NS_ENSURE_TRUE
(
mEncodingScope
.
mNode
NS_ERROR_FAILURE
)
;
nsresult
rv
=
NS_OK
;
nsINode
*
node
=
mEncodingScope
.
mNode
;
const
bool
nodeIsContainer
=
mEncodingScope
.
mNodeIsContainer
;
if
(
!
mNodeFixup
&
&
!
(
mFlags
&
SkipInvisibleContent
)
&
&
!
mTextStreamer
&
&
nodeIsContainer
)
{
rv
=
SerializeToStringIterative
(
node
)
;
}
else
{
rv
=
SerializeToStringRecursive
(
node
nodeIsContainer
)
;
}
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeWholeDocument
(
uint32_t
aMaxLength
)
{
NS_ENSURE_FALSE
(
mEncodingScope
.
mSelection
NS_ERROR_FAILURE
)
;
NS_ENSURE_FALSE
(
mEncodingScope
.
mRange
NS_ERROR_FAILURE
)
;
NS_ENSURE_FALSE
(
mEncodingScope
.
mNode
NS_ERROR_FAILURE
)
;
nsresult
rv
=
mSerializer
-
>
AppendDocumentStart
(
mDocument
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SerializeToStringRecursive
(
mDocument
false
aMaxLength
)
;
return
rv
;
}
nsDocumentEncoder
:
:
~
nsDocumentEncoder
(
)
{
if
(
mCachedBuffer
)
{
mCachedBuffer
-
>
Release
(
)
;
}
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
Init
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
{
return
NativeInit
(
aDocument
aMimeType
aFlags
)
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
NativeInit
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
{
if
(
!
aDocument
)
return
NS_ERROR_INVALID_ARG
;
Initialize
(
!
mMimeType
.
Equals
(
aMimeType
)
)
;
mDocument
=
aDocument
;
mMimeType
=
aMimeType
;
mFlags
=
aFlags
;
mIsCopying
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetWrapColumn
(
uint32_t
aWC
)
{
mWrapColumn
=
aWC
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetSelection
(
Selection
*
aSelection
)
{
mEncodingScope
.
mSelection
=
aSelection
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetRange
(
nsRange
*
aRange
)
{
mEncodingScope
.
mRange
=
aRange
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetNode
(
nsINode
*
aNode
)
{
mEncodingScope
.
mNodeIsContainer
=
false
;
mEncodingScope
.
mNode
=
aNode
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetContainerNode
(
nsINode
*
aContainer
)
{
mEncodingScope
.
mNodeIsContainer
=
true
;
mEncodingScope
.
mNode
=
aContainer
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetCharset
(
const
nsACString
&
aCharset
)
{
const
Encoding
*
encoding
=
Encoding
:
:
ForLabel
(
aCharset
)
;
if
(
!
encoding
)
{
return
NS_ERROR_UCONV_NOCONV
;
}
mEncoding
=
encoding
-
>
OutputEncoding
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
GetMimeType
(
nsAString
&
aMimeType
)
{
aMimeType
=
mMimeType
;
return
NS_OK
;
}
bool
nsDocumentEncoder
:
:
IncludeInContext
(
nsINode
*
aNode
)
{
return
false
;
}
class
FixupNodeDeterminer
{
public
:
FixupNodeDeterminer
(
nsIDocumentEncoderNodeFixup
*
aNodeFixup
nsINode
*
aFixupNode
nsINode
&
aOriginalNode
)
:
mIsSerializationOfFixupChildrenNeeded
{
false
}
mNodeFixup
(
aNodeFixup
)
mOriginalNode
(
aOriginalNode
)
{
if
(
mNodeFixup
)
{
if
(
aFixupNode
)
{
mFixupNode
=
aFixupNode
;
}
else
{
mNodeFixup
-
>
FixupNode
(
&
mOriginalNode
&
mIsSerializationOfFixupChildrenNeeded
getter_AddRefs
(
mFixupNode
)
)
;
}
}
}
bool
IsSerializationOfFixupChildrenNeeded
(
)
const
{
return
mIsSerializationOfFixupChildrenNeeded
;
}
nsINode
&
GetFixupNodeFallBackToOriginalNode
(
)
const
{
return
mFixupNode
?
*
mFixupNode
:
mOriginalNode
;
}
private
:
bool
mIsSerializationOfFixupChildrenNeeded
;
nsIDocumentEncoderNodeFixup
*
mNodeFixup
;
nsCOMPtr
<
nsINode
>
mFixupNode
;
nsINode
&
mOriginalNode
;
}
;
nsresult
nsDocumentEncoder
:
:
SerializeNodeStart
(
nsINode
&
aOriginalNode
int32_t
aStartOffset
int32_t
aEndOffset
nsINode
*
aFixupNode
)
{
if
(
mNeedsPreformatScanning
)
{
if
(
aOriginalNode
.
IsElement
(
)
)
{
mSerializer
-
>
ScanElementForPreformat
(
aOriginalNode
.
AsElement
(
)
)
;
}
else
if
(
aOriginalNode
.
IsText
(
)
)
{
const
nsCOMPtr
<
nsINode
>
parent
=
aOriginalNode
.
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsElement
(
)
)
{
mSerializer
-
>
ScanElementForPreformat
(
parent
-
>
AsElement
(
)
)
;
}
}
}
if
(
IsInvisibleNodeAndShouldBeSkipped
(
aOriginalNode
)
)
{
return
NS_OK
;
}
FixupNodeDeterminer
fixupNodeDeterminer
{
mNodeFixup
aFixupNode
aOriginalNode
}
;
nsINode
*
node
=
&
fixupNodeDeterminer
.
GetFixupNodeFallBackToOriginalNode
(
)
;
nsresult
rv
=
NS_OK
;
if
(
node
-
>
IsElement
(
)
)
{
if
(
(
mFlags
&
(
nsIDocumentEncoder
:
:
OutputPreformatted
|
nsIDocumentEncoder
:
:
OutputDropInvisibleBreak
)
)
&
&
nsLayoutUtils
:
:
IsInvisibleBreak
(
node
)
)
{
return
rv
;
}
rv
=
mSerializer
-
>
AppendElementStart
(
node
-
>
AsElement
(
)
aOriginalNode
.
AsElement
(
)
)
;
return
rv
;
}
switch
(
node
-
>
NodeType
(
)
)
{
case
nsINode
:
:
TEXT_NODE
:
{
rv
=
mSerializer
-
>
AppendText
(
static_cast
<
nsIContent
*
>
(
node
)
aStartOffset
aEndOffset
)
;
break
;
}
case
nsINode
:
:
CDATA_SECTION_NODE
:
{
rv
=
mSerializer
-
>
AppendCDATASection
(
static_cast
<
nsIContent
*
>
(
node
)
aStartOffset
aEndOffset
)
;
break
;
}
case
nsINode
:
:
PROCESSING_INSTRUCTION_NODE
:
{
rv
=
mSerializer
-
>
AppendProcessingInstruction
(
static_cast
<
ProcessingInstruction
*
>
(
node
)
aStartOffset
aEndOffset
)
;
break
;
}
case
nsINode
:
:
COMMENT_NODE
:
{
rv
=
mSerializer
-
>
AppendComment
(
static_cast
<
Comment
*
>
(
node
)
aStartOffset
aEndOffset
)
;
break
;
}
case
nsINode
:
:
DOCUMENT_TYPE_NODE
:
{
rv
=
mSerializer
-
>
AppendDoctype
(
static_cast
<
DocumentType
*
>
(
node
)
)
;
break
;
}
}
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeNodeEnd
(
nsINode
&
aOriginalNode
nsINode
*
aFixupNode
)
{
if
(
mNeedsPreformatScanning
)
{
if
(
aOriginalNode
.
IsElement
(
)
)
{
mSerializer
-
>
ForgetElementForPreformat
(
aOriginalNode
.
AsElement
(
)
)
;
}
else
if
(
aOriginalNode
.
IsText
(
)
)
{
const
nsCOMPtr
<
nsINode
>
parent
=
aOriginalNode
.
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsElement
(
)
)
{
mSerializer
-
>
ForgetElementForPreformat
(
parent
-
>
AsElement
(
)
)
;
}
}
}
if
(
IsInvisibleNodeAndShouldBeSkipped
(
aOriginalNode
)
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
FixupNodeDeterminer
fixupNodeDeterminer
{
mNodeFixup
aFixupNode
aOriginalNode
}
;
nsINode
*
node
=
&
fixupNodeDeterminer
.
GetFixupNodeFallBackToOriginalNode
(
)
;
if
(
node
-
>
IsElement
(
)
)
{
rv
=
mSerializer
-
>
AppendElementEnd
(
node
-
>
AsElement
(
)
aOriginalNode
.
AsElement
(
)
)
;
}
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeToStringRecursive
(
nsINode
*
aNode
bool
aDontSerializeRoot
uint32_t
aMaxLength
)
{
uint32_t
outputLength
{
0
}
;
nsresult
rv
=
mSerializer
-
>
GetOutputLength
(
outputLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aMaxLength
>
0
&
&
outputLength
>
=
aMaxLength
)
{
return
NS_OK
;
}
NS_ENSURE_TRUE
(
aNode
NS_ERROR_NULL_POINTER
)
;
if
(
IsInvisibleNodeAndShouldBeSkipped
(
*
aNode
)
)
{
return
NS_OK
;
}
FixupNodeDeterminer
fixupNodeDeterminer
{
mNodeFixup
nullptr
*
aNode
}
;
nsINode
*
maybeFixedNode
=
&
fixupNodeDeterminer
.
GetFixupNodeFallBackToOriginalNode
(
)
;
if
(
mFlags
&
SkipInvisibleContent
)
{
if
(
aNode
-
>
IsContent
(
)
)
{
if
(
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
)
{
if
(
!
frame
-
>
IsSelectable
(
nullptr
)
)
{
aDontSerializeRoot
=
true
;
}
}
}
}
if
(
!
aDontSerializeRoot
)
{
int32_t
endOffset
=
-
1
;
if
(
aMaxLength
>
0
)
{
MOZ_ASSERT
(
aMaxLength
>
=
outputLength
)
;
endOffset
=
aMaxLength
-
outputLength
;
}
rv
=
SerializeNodeStart
(
*
aNode
0
endOffset
maybeFixedNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsINode
*
node
=
fixupNodeDeterminer
.
IsSerializationOfFixupChildrenNeeded
(
)
?
maybeFixedNode
:
aNode
;
for
(
nsINode
*
child
=
node
-
>
GetFirstChildOfTemplateOrNode
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
rv
=
SerializeToStringRecursive
(
child
false
aMaxLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aDontSerializeRoot
)
{
rv
=
SerializeNodeEnd
(
*
aNode
maybeFixedNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
mTextStreamer
)
{
rv
=
mTextStreamer
-
>
FlushIfStringLongEnough
(
)
;
}
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeToStringIterative
(
nsINode
*
aNode
)
{
nsresult
rv
;
nsINode
*
node
=
aNode
-
>
GetFirstChildOfTemplateOrNode
(
)
;
while
(
node
)
{
nsINode
*
current
=
node
;
rv
=
SerializeNodeStart
(
*
current
0
-
1
current
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
node
=
current
-
>
GetFirstChildOfTemplateOrNode
(
)
;
while
(
!
node
&
&
current
&
&
current
!
=
aNode
)
{
rv
=
SerializeNodeEnd
(
*
current
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
node
=
current
-
>
GetNextSibling
(
)
;
if
(
!
node
)
{
current
=
current
-
>
GetParentNode
(
)
;
if
(
current
&
&
current
!
=
aNode
&
&
current
-
>
IsDocumentFragment
(
)
)
{
nsIContent
*
host
=
current
-
>
AsDocumentFragment
(
)
-
>
GetHost
(
)
;
if
(
host
&
&
host
-
>
IsHTMLElement
(
nsGkAtoms
:
:
_template
)
)
{
current
=
host
;
}
}
}
}
}
return
NS_OK
;
}
static
bool
IsTextNode
(
nsINode
*
aNode
)
{
return
aNode
&
&
aNode
-
>
IsText
(
)
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeNodes
(
nsRange
*
const
aRange
nsINode
*
const
aNode
const
int32_t
aDepth
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aNode
)
;
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
if
(
IsInvisibleNodeAndShouldBeSkipped
(
*
aNode
)
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIContent
>
startNode
endNode
;
{
auto
&
startContainerPath
=
mRangeBoundaryPathsAndOffsets
.
mStartContainerPath
;
auto
&
endContainerPath
=
mRangeBoundaryPathsAndOffsets
.
mEndContainerPath
;
int32_t
start
=
mStartRootIndex
-
aDepth
;
if
(
start
>
=
0
&
&
(
uint32_t
)
start
<
=
startContainerPath
.
Length
(
)
)
{
startNode
=
startContainerPath
[
start
]
;
}
int32_t
end
=
mEndRootIndex
-
aDepth
;
if
(
end
>
=
0
&
&
(
uint32_t
)
end
<
=
endContainerPath
.
Length
(
)
)
{
endNode
=
endContainerPath
[
end
]
;
}
}
if
(
startNode
!
=
content
&
&
endNode
!
=
content
)
{
rv
=
SerializeToStringRecursive
(
aNode
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
IsTextNode
(
aNode
)
)
{
if
(
startNode
=
=
content
)
{
int32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
rv
=
SerializeNodeStart
(
*
aNode
startOffset
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
int32_t
endOffset
=
aRange
-
>
EndOffset
(
)
;
rv
=
SerializeNodeStart
(
*
aNode
0
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
SerializeNodeEnd
(
*
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
aNode
!
=
mCommonAncestorOfRange
)
{
if
(
IncludeInContext
(
aNode
)
)
{
mHaltRangeHint
=
true
;
}
if
(
(
startNode
=
=
content
)
&
&
!
mHaltRangeHint
)
{
+
+
mContextInfoDepth
.
mStart
;
}
if
(
(
endNode
=
=
content
)
&
&
!
mHaltRangeHint
)
{
+
+
mContextInfoDepth
.
mEnd
;
}
rv
=
SerializeNodeStart
(
*
aNode
0
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
const
auto
&
startContainerOffsets
=
mRangeBoundaryPathsAndOffsets
.
mStartContainerOffsets
;
const
auto
&
endContainerOffsets
=
mRangeBoundaryPathsAndOffsets
.
mEndContainerOffsets
;
int32_t
startOffset
=
0
endOffset
=
-
1
;
if
(
startNode
=
=
content
&
&
mStartRootIndex
>
=
aDepth
)
{
startOffset
=
startContainerOffsets
[
mStartRootIndex
-
aDepth
]
;
}
if
(
endNode
=
=
content
&
&
mEndRootIndex
>
=
aDepth
)
{
endOffset
=
endContainerOffsets
[
mEndRootIndex
-
aDepth
]
;
}
uint32_t
childCount
=
content
-
>
GetChildCount
(
)
;
if
(
startOffset
=
=
-
1
)
startOffset
=
0
;
if
(
endOffset
=
=
-
1
)
endOffset
=
childCount
;
else
{
if
(
aNode
!
=
aRange
-
>
GetEndContainer
(
)
)
{
endOffset
+
+
;
}
}
if
(
endOffset
)
{
nsIContent
*
childAsNode
=
content
-
>
GetFirstChild
(
)
;
int32_t
j
=
0
;
for
(
;
j
<
startOffset
&
&
childAsNode
;
+
+
j
)
{
childAsNode
=
childAsNode
-
>
GetNextSibling
(
)
;
}
MOZ_ASSERT
(
j
=
=
startOffset
)
;
for
(
;
childAsNode
&
&
j
<
endOffset
;
+
+
j
)
{
if
(
(
j
=
=
startOffset
)
|
|
(
j
=
=
endOffset
-
1
)
)
{
rv
=
SerializeRangeNodes
(
aRange
childAsNode
aDepth
+
1
)
;
}
else
{
rv
=
SerializeToStringRecursive
(
childAsNode
false
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
childAsNode
=
childAsNode
-
>
GetNextSibling
(
)
;
}
}
if
(
aNode
!
=
mCommonAncestorOfRange
)
{
rv
=
SerializeNodeEnd
(
*
aNode
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
return
NS_OK
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeContextStart
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
{
if
(
mDisableContextSerialize
)
{
return
NS_OK
;
}
AutoTArray
<
nsINode
*
8
>
*
serializedContext
=
mRangeContexts
.
AppendElement
(
)
;
int32_t
i
=
aAncestorArray
.
Length
(
)
j
;
nsresult
rv
=
NS_OK
;
j
=
GetImmediateContextCount
(
aAncestorArray
)
;
while
(
i
>
0
)
{
nsINode
*
node
=
aAncestorArray
.
ElementAt
(
-
-
i
)
;
if
(
!
node
)
break
;
if
(
IncludeInContext
(
node
)
|
|
i
<
j
)
{
rv
=
SerializeNodeStart
(
*
node
0
-
1
)
;
serializedContext
-
>
AppendElement
(
node
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
}
}
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeContextEnd
(
)
{
if
(
mDisableContextSerialize
)
{
return
NS_OK
;
}
MOZ_RELEASE_ASSERT
(
!
mRangeContexts
.
IsEmpty
(
)
"
Tried
to
end
context
without
starting
one
.
"
)
;
AutoTArray
<
nsINode
*
8
>
&
serializedContext
=
mRangeContexts
.
LastElement
(
)
;
nsresult
rv
=
NS_OK
;
for
(
nsINode
*
node
:
Reversed
(
serializedContext
)
)
{
rv
=
SerializeNodeEnd
(
*
node
)
;
if
(
NS_FAILED
(
rv
)
)
break
;
}
mRangeContexts
.
RemoveLastElement
(
)
;
return
rv
;
}
nsresult
nsDocumentEncoder
:
:
SerializeRangeToString
(
nsRange
*
aRange
)
{
if
(
!
aRange
|
|
aRange
-
>
Collapsed
(
)
)
return
NS_OK
;
mCommonAncestorOfRange
=
aRange
-
>
GetClosestCommonInclusiveAncestor
(
)
;
if
(
!
mCommonAncestorOfRange
)
{
return
NS_OK
;
}
nsINode
*
startContainer
=
aRange
-
>
GetStartContainer
(
)
;
NS_ENSURE_TRUE
(
startContainer
NS_ERROR_FAILURE
)
;
int32_t
startOffset
=
aRange
-
>
StartOffset
(
)
;
nsINode
*
endContainer
=
aRange
-
>
GetEndContainer
(
)
;
NS_ENSURE_TRUE
(
endContainer
NS_ERROR_FAILURE
)
;
int32_t
endOffset
=
aRange
-
>
EndOffset
(
)
;
mContextInfoDepth
=
{
}
;
mCommonAncestors
.
Clear
(
)
;
mRangeBoundaryPathsAndOffsets
=
{
}
;
auto
&
startContainerPath
=
mRangeBoundaryPathsAndOffsets
.
mStartContainerPath
;
auto
&
startContainerOffsets
=
mRangeBoundaryPathsAndOffsets
.
mStartContainerOffsets
;
auto
&
endContainerPath
=
mRangeBoundaryPathsAndOffsets
.
mEndContainerPath
;
auto
&
endContainerOffsets
=
mRangeBoundaryPathsAndOffsets
.
mEndContainerOffsets
;
nsContentUtils
:
:
GetAncestors
(
mCommonAncestorOfRange
mCommonAncestors
)
;
nsContentUtils
:
:
GetAncestorsAndOffsets
(
startContainer
startOffset
&
startContainerPath
&
startContainerOffsets
)
;
nsContentUtils
:
:
GetAncestorsAndOffsets
(
endContainer
endOffset
&
endContainerPath
&
endContainerOffsets
)
;
nsCOMPtr
<
nsIContent
>
commonContent
=
do_QueryInterface
(
mCommonAncestorOfRange
)
;
mStartRootIndex
=
startContainerPath
.
IndexOf
(
commonContent
)
;
mEndRootIndex
=
endContainerPath
.
IndexOf
(
commonContent
)
;
nsresult
rv
=
NS_OK
;
rv
=
SerializeRangeContextStart
(
mCommonAncestors
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
startContainer
=
=
endContainer
&
&
IsTextNode
(
startContainer
)
)
{
if
(
mFlags
&
SkipInvisibleContent
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
startContainer
)
;
if
(
content
&
&
!
content
-
>
GetPrimaryFrame
(
)
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
!
parent
|
|
IsInvisibleNodeAndShouldBeSkipped
(
*
parent
)
)
{
return
NS_OK
;
}
}
}
rv
=
SerializeNodeStart
(
*
startContainer
startOffset
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
SerializeNodeEnd
(
*
startContainer
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
rv
=
SerializeRangeNodes
(
aRange
mCommonAncestorOfRange
0
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
SerializeRangeContextEnd
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
rv
;
}
void
nsDocumentEncoder
:
:
ReleaseDocumentReferenceAndInitialize
(
bool
aClearCachedSerializer
)
{
mDocument
=
nullptr
;
Initialize
(
aClearCachedSerializer
)
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToString
(
nsAString
&
aOutputString
)
{
return
EncodeToStringWithMaxLength
(
0
aOutputString
)
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToStringWithMaxLength
(
uint32_t
aMaxLength
nsAString
&
aOutputString
)
{
MOZ_ASSERT
(
mRangeContexts
.
IsEmpty
(
)
"
Re
-
entrant
call
to
nsDocumentEncoder
.
"
)
;
auto
rangeContextGuard
=
MakeScopeExit
(
[
&
]
{
mRangeContexts
.
Clear
(
)
;
}
)
;
if
(
!
mDocument
)
return
NS_ERROR_NOT_INITIALIZED
;
AutoReleaseDocumentIfNeeded
autoReleaseDocument
(
this
)
;
aOutputString
.
Truncate
(
)
;
nsString
output
;
static
const
size_t
kStringBufferSizeInBytes
=
2048
;
if
(
!
mCachedBuffer
)
{
mCachedBuffer
=
nsStringBuffer
:
:
Alloc
(
kStringBufferSizeInBytes
)
.
take
(
)
;
if
(
NS_WARN_IF
(
!
mCachedBuffer
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
NS_ASSERTION
(
!
mCachedBuffer
-
>
IsReadonly
(
)
"
nsIDocumentEncoder
shouldn
'
t
keep
reference
to
non
-
readonly
buffer
!
"
)
;
static_cast
<
char16_t
*
>
(
mCachedBuffer
-
>
Data
(
)
)
[
0
]
=
char16_t
(
0
)
;
mCachedBuffer
-
>
ToString
(
0
output
true
)
;
mCachedBuffer
=
nullptr
;
if
(
!
mSerializer
)
{
nsAutoCString
progId
(
NS_CONTENTSERIALIZER_CONTRACTID_PREFIX
)
;
AppendUTF16toUTF8
(
mMimeType
progId
)
;
mSerializer
=
do_CreateInstance
(
progId
.
get
(
)
)
;
NS_ENSURE_TRUE
(
mSerializer
NS_ERROR_NOT_IMPLEMENTED
)
;
}
nsresult
rv
=
NS_OK
;
bool
rewriteEncodingDeclaration
=
!
mEncodingScope
.
IsLimited
(
)
&
&
!
(
mFlags
&
OutputDontRewriteEncodingDeclaration
)
;
mSerializer
-
>
Init
(
mFlags
mWrapColumn
mEncoding
mIsCopying
rewriteEncodingDeclaration
&
mNeedsPreformatScanning
output
)
;
rv
=
SerializeDependingOnScope
(
aMaxLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
mSerializer
-
>
FlushAndFinish
(
)
;
mCachedBuffer
=
nsStringBuffer
:
:
FromString
(
output
)
;
bool
setOutput
=
false
;
if
(
mCachedBuffer
)
{
if
(
(
mCachedBuffer
-
>
StorageSize
(
)
=
=
kStringBufferSizeInBytes
)
&
&
!
mCachedBuffer
-
>
IsReadonly
(
)
)
{
mCachedBuffer
-
>
AddRef
(
)
;
}
else
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
mCachedBuffer
-
>
ToString
(
output
.
Length
(
)
aOutputString
)
;
setOutput
=
true
;
}
mCachedBuffer
=
nullptr
;
}
}
if
(
!
setOutput
&
&
NS_SUCCEEDED
(
rv
)
)
{
aOutputString
.
Append
(
output
.
get
(
)
output
.
Length
(
)
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToStream
(
nsIOutputStream
*
aStream
)
{
MOZ_ASSERT
(
mRangeContexts
.
IsEmpty
(
)
"
Re
-
entrant
call
to
nsDocumentEncoder
.
"
)
;
auto
rangeContextGuard
=
MakeScopeExit
(
[
&
]
{
mRangeContexts
.
Clear
(
)
;
}
)
;
NS_ENSURE_ARG_POINTER
(
aStream
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mDocument
)
return
NS_ERROR_NOT_INITIALIZED
;
if
(
!
mEncoding
)
{
return
NS_ERROR_UCONV_NOCONV
;
}
nsAutoString
buf
;
const
bool
isPlainText
=
mMimeType
.
LowerCaseEqualsLiteral
(
kTextMime
)
;
mTextStreamer
.
emplace
(
*
aStream
mEncoding
-
>
NewEncoder
(
)
isPlainText
buf
)
;
rv
=
EncodeToString
(
buf
)
;
rv
=
mTextStreamer
-
>
ForceFlush
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mTextStreamer
.
reset
(
)
;
return
rv
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
EncodeToStringWithContext
(
nsAString
&
aContextString
nsAString
&
aInfoString
nsAString
&
aEncodedString
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
NS_IMETHODIMP
nsDocumentEncoder
:
:
SetNodeFixup
(
nsIDocumentEncoderNodeFixup
*
aFixup
)
{
mNodeFixup
=
aFixup
;
return
NS_OK
;
}
bool
do_getDocumentTypeSupportedForEncoding
(
const
char
*
aContentType
)
{
if
(
!
nsCRT
:
:
strcmp
(
aContentType
"
text
/
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
application
/
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
application
/
xhtml
+
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
image
/
svg
+
xml
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
text
/
html
"
)
|
|
!
nsCRT
:
:
strcmp
(
aContentType
"
text
/
plain
"
)
)
{
return
true
;
}
return
false
;
}
already_AddRefed
<
nsIDocumentEncoder
>
do_createDocumentEncoder
(
const
char
*
aContentType
)
{
if
(
do_getDocumentTypeSupportedForEncoding
(
aContentType
)
)
{
return
do_AddRef
(
new
nsDocumentEncoder
)
;
}
return
nullptr
;
}
class
nsHTMLCopyEncoder
:
public
nsDocumentEncoder
{
public
:
nsHTMLCopyEncoder
(
)
;
virtual
~
nsHTMLCopyEncoder
(
)
;
NS_IMETHOD
Init
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
SetSelection
(
Selection
*
aSelection
)
override
;
NS_IMETHOD
EncodeToStringWithContext
(
nsAString
&
aContextString
nsAString
&
aInfoString
nsAString
&
aEncodedString
)
override
;
NS_IMETHOD
EncodeToString
(
nsAString
&
aOutputString
)
override
;
protected
:
enum
Endpoint
{
kStart
kEnd
}
;
nsresult
PromoteRange
(
nsRange
*
inRange
)
;
nsresult
PromoteAncestorChain
(
nsCOMPtr
<
nsINode
>
*
ioNode
int32_t
*
ioStartOffset
int32_t
*
ioEndOffset
)
;
nsresult
GetPromotedPoint
(
Endpoint
aWhere
nsINode
*
aNode
int32_t
aOffset
nsCOMPtr
<
nsINode
>
*
outNode
int32_t
*
outOffset
nsINode
*
aCommon
)
;
static
nsCOMPtr
<
nsINode
>
GetChildAt
(
nsINode
*
aParent
int32_t
aOffset
)
;
static
bool
IsMozBR
(
Element
*
aNode
)
;
static
nsresult
GetNodeLocation
(
nsINode
*
inChild
nsCOMPtr
<
nsINode
>
*
outParent
int32_t
*
outOffset
)
;
bool
IsRoot
(
nsINode
*
aNode
)
;
static
bool
IsFirstNode
(
nsINode
*
aNode
)
;
static
bool
IsLastNode
(
nsINode
*
aNode
)
;
virtual
bool
IncludeInContext
(
nsINode
*
aNode
)
override
;
virtual
int32_t
GetImmediateContextCount
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
override
;
bool
mIsTextWidget
;
}
;
nsHTMLCopyEncoder
:
:
nsHTMLCopyEncoder
(
)
{
mIsTextWidget
=
false
;
}
nsHTMLCopyEncoder
:
:
~
nsHTMLCopyEncoder
(
)
{
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
Init
(
Document
*
aDocument
const
nsAString
&
aMimeType
uint32_t
aFlags
)
{
if
(
!
aDocument
)
return
NS_ERROR_INVALID_ARG
;
mIsTextWidget
=
false
;
Initialize
(
)
;
mIsCopying
=
true
;
mDocument
=
aDocument
;
if
(
aMimeType
.
EqualsLiteral
(
"
text
/
plain
"
)
)
{
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
}
else
{
mMimeType
.
AssignLiteral
(
"
text
/
html
"
)
;
}
mFlags
=
aFlags
|
OutputAbsoluteLinks
;
if
(
!
mDocument
-
>
IsScriptEnabled
(
)
)
mFlags
|
=
OutputNoScriptContent
;
return
NS_OK
;
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
SetSelection
(
Selection
*
aSelection
)
{
if
(
!
aSelection
)
return
NS_ERROR_NULL_POINTER
;
uint32_t
rangeCount
=
aSelection
-
>
RangeCount
(
)
;
if
(
!
rangeCount
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsRange
>
range
=
aSelection
-
>
GetRangeAt
(
0
)
;
nsINode
*
commonParent
=
range
-
>
GetClosestCommonInclusiveAncestor
(
)
;
for
(
nsCOMPtr
<
nsIContent
>
selContent
(
do_QueryInterface
(
commonParent
)
)
;
selContent
;
selContent
=
selContent
-
>
GetParent
(
)
)
{
if
(
selContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
input
nsGkAtoms
:
:
textarea
)
)
{
mIsTextWidget
=
true
;
break
;
}
}
if
(
mIsTextWidget
)
{
mEncodingScope
.
mSelection
=
aSelection
;
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
return
NS_OK
;
}
if
(
!
(
mDocument
&
&
mDocument
-
>
IsHTMLDocument
(
)
)
)
{
mIsTextWidget
=
true
;
mEncodingScope
.
mSelection
=
aSelection
;
return
NS_OK
;
}
mEncodingScope
.
mSelection
=
new
Selection
(
)
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
rangeCount
;
+
+
rangeIdx
)
{
range
=
aSelection
-
>
GetRangeAt
(
rangeIdx
)
;
NS_ENSURE_TRUE
(
range
NS_ERROR_FAILURE
)
;
RefPtr
<
nsRange
>
myRange
=
range
-
>
CloneRange
(
)
;
MOZ_ASSERT
(
myRange
)
;
nsresult
rv
=
PromoteRange
(
myRange
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ErrorResult
result
;
RefPtr
<
Selection
>
selection
(
mEncodingScope
.
mSelection
)
;
RefPtr
<
Document
>
document
(
mDocument
)
;
selection
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
myRange
document
result
)
;
rv
=
result
.
StealNSResult
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
EncodeToString
(
nsAString
&
aOutputString
)
{
if
(
mIsTextWidget
)
{
mMimeType
.
AssignLiteral
(
"
text
/
plain
"
)
;
}
return
nsDocumentEncoder
:
:
EncodeToString
(
aOutputString
)
;
}
NS_IMETHODIMP
nsHTMLCopyEncoder
:
:
EncodeToStringWithContext
(
nsAString
&
aContextString
nsAString
&
aInfoString
nsAString
&
aEncodedString
)
{
nsresult
rv
=
EncodeToString
(
aEncodedString
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mIsTextWidget
)
return
NS_OK
;
mSerializer
-
>
Init
(
mFlags
mWrapColumn
mEncoding
mIsCopying
false
&
mNeedsPreformatScanning
aContextString
)
;
int32_t
count
=
mCommonAncestors
.
Length
(
)
;
int32_t
i
;
nsCOMPtr
<
nsINode
>
node
;
if
(
count
>
0
)
node
=
mCommonAncestors
.
ElementAt
(
0
)
;
if
(
node
&
&
IsTextNode
(
node
)
)
{
mCommonAncestors
.
RemoveElementAt
(
0
)
;
if
(
mContextInfoDepth
.
mStart
)
{
-
-
mContextInfoDepth
.
mStart
;
}
if
(
mContextInfoDepth
.
mEnd
)
{
-
-
mContextInfoDepth
.
mEnd
;
}
count
-
-
;
}
i
=
count
;
while
(
i
>
0
)
{
node
=
mCommonAncestors
.
ElementAt
(
-
-
i
)
;
rv
=
SerializeNodeStart
(
*
node
0
-
1
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
while
(
i
<
count
)
{
node
=
mCommonAncestors
.
ElementAt
(
i
+
+
)
;
rv
=
SerializeNodeEnd
(
*
node
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mSerializer
-
>
Finish
(
)
;
nsAutoString
infoString
;
infoString
.
AppendInt
(
mContextInfoDepth
.
mStart
)
;
infoString
.
Append
(
char16_t
(
'
'
)
)
;
infoString
.
AppendInt
(
mContextInfoDepth
.
mEnd
)
;
aInfoString
=
infoString
;
return
rv
;
}
bool
nsHTMLCopyEncoder
:
:
IncludeInContext
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aNode
)
)
;
if
(
!
content
)
return
false
;
return
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
b
nsGkAtoms
:
:
i
nsGkAtoms
:
:
u
nsGkAtoms
:
:
a
nsGkAtoms
:
:
tt
nsGkAtoms
:
:
s
nsGkAtoms
:
:
big
nsGkAtoms
:
:
small
nsGkAtoms
:
:
strike
nsGkAtoms
:
:
em
nsGkAtoms
:
:
strong
nsGkAtoms
:
:
dfn
nsGkAtoms
:
:
code
nsGkAtoms
:
:
cite
nsGkAtoms
:
:
var
nsGkAtoms
:
:
abbr
nsGkAtoms
:
:
font
nsGkAtoms
:
:
script
nsGkAtoms
:
:
span
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
)
;
}
nsresult
nsHTMLCopyEncoder
:
:
PromoteRange
(
nsRange
*
inRange
)
{
if
(
!
inRange
-
>
IsPositioned
(
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsCOMPtr
<
nsINode
>
startNode
=
inRange
-
>
GetStartContainer
(
)
;
uint32_t
startOffset
=
inRange
-
>
StartOffset
(
)
;
nsCOMPtr
<
nsINode
>
endNode
=
inRange
-
>
GetEndContainer
(
)
;
uint32_t
endOffset
=
inRange
-
>
EndOffset
(
)
;
nsCOMPtr
<
nsINode
>
common
=
inRange
-
>
GetClosestCommonInclusiveAncestor
(
)
;
nsCOMPtr
<
nsINode
>
opStartNode
;
nsCOMPtr
<
nsINode
>
opEndNode
;
int32_t
opStartOffset
opEndOffset
;
nsresult
rv
=
GetPromotedPoint
(
kStart
startNode
static_cast
<
int32_t
>
(
startOffset
)
address_of
(
opStartNode
)
&
opStartOffset
common
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPromotedPoint
(
kEnd
endNode
static_cast
<
int32_t
>
(
endOffset
)
address_of
(
opEndNode
)
&
opEndOffset
common
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
opStartNode
=
=
common
&
&
opEndNode
=
=
common
)
{
rv
=
PromoteAncestorChain
(
address_of
(
opStartNode
)
&
opStartOffset
&
opEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
opEndNode
=
opStartNode
;
}
ErrorResult
err
;
inRange
-
>
SetStart
(
*
opStartNode
static_cast
<
uint32_t
>
(
opStartOffset
)
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
inRange
-
>
SetEnd
(
*
opEndNode
static_cast
<
uint32_t
>
(
opEndOffset
)
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
return
NS_OK
;
}
nsresult
nsHTMLCopyEncoder
:
:
PromoteAncestorChain
(
nsCOMPtr
<
nsINode
>
*
ioNode
int32_t
*
ioStartOffset
int32_t
*
ioEndOffset
)
{
if
(
!
ioNode
|
|
!
ioStartOffset
|
|
!
ioEndOffset
)
return
NS_ERROR_NULL_POINTER
;
nsresult
rv
=
NS_OK
;
bool
done
=
false
;
nsCOMPtr
<
nsINode
>
frontNode
endNode
parent
;
int32_t
frontOffset
endOffset
;
nsCOMPtr
<
nsINode
>
node
=
*
ioNode
;
bool
isEditable
=
node
-
>
IsEditable
(
)
;
while
(
!
done
)
{
node
=
*
ioNode
;
parent
=
node
-
>
GetParentNode
(
)
;
if
(
!
parent
)
{
done
=
true
;
}
else
{
rv
=
GetPromotedPoint
(
kStart
*
ioNode
*
ioStartOffset
address_of
(
frontNode
)
&
frontOffset
parent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
GetPromotedPoint
(
kEnd
*
ioNode
*
ioEndOffset
address_of
(
endNode
)
&
endOffset
parent
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
(
frontNode
!
=
parent
)
|
|
(
endNode
!
=
parent
)
|
|
(
frontNode
-
>
IsEditable
(
)
!
=
isEditable
)
)
done
=
true
;
else
{
*
ioNode
=
frontNode
;
*
ioStartOffset
=
frontOffset
;
*
ioEndOffset
=
endOffset
;
}
}
}
return
rv
;
}
nsresult
nsHTMLCopyEncoder
:
:
GetPromotedPoint
(
Endpoint
aWhere
nsINode
*
aNode
int32_t
aOffset
nsCOMPtr
<
nsINode
>
*
outNode
int32_t
*
outOffset
nsINode
*
common
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsINode
>
node
=
aNode
;
nsCOMPtr
<
nsINode
>
parent
=
aNode
;
int32_t
offset
=
aOffset
;
bool
bResetPromotion
=
false
;
*
outNode
=
node
;
*
outOffset
=
offset
;
if
(
common
=
=
node
)
return
NS_OK
;
if
(
aWhere
=
=
kStart
)
{
if
(
auto
nodeAsText
=
aNode
-
>
GetAsText
(
)
)
{
if
(
offset
>
0
)
{
nsAutoString
text
;
nodeAsText
-
>
SubstringData
(
0
offset
text
IgnoreErrors
(
)
)
;
text
.
CompressWhitespace
(
)
;
if
(
!
text
.
IsEmpty
(
)
)
return
NS_OK
;
bResetPromotion
=
true
;
}
rv
=
GetNodeLocation
(
aNode
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
node
=
GetChildAt
(
parent
offset
)
;
}
if
(
!
node
)
node
=
parent
;
if
(
!
IsRoot
(
node
)
&
&
(
parent
!
=
common
)
)
{
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
return
NS_OK
;
while
(
(
IsFirstNode
(
node
)
)
&
&
(
!
IsRoot
(
parent
)
)
&
&
(
parent
!
=
common
)
)
{
if
(
bResetPromotion
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
parent
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
)
)
{
if
(
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
)
{
bResetPromotion
=
false
;
}
}
}
node
=
parent
;
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
{
parent
=
node
;
offset
=
0
;
break
;
}
}
if
(
bResetPromotion
)
{
*
outNode
=
aNode
;
*
outOffset
=
aOffset
;
}
else
{
*
outNode
=
parent
;
*
outOffset
=
offset
;
}
return
rv
;
}
}
if
(
aWhere
=
=
kEnd
)
{
if
(
auto
nodeAsText
=
aNode
-
>
GetAsText
(
)
)
{
uint32_t
len
=
aNode
-
>
Length
(
)
;
if
(
offset
<
(
int32_t
)
len
)
{
nsAutoString
text
;
nodeAsText
-
>
SubstringData
(
offset
len
-
offset
text
IgnoreErrors
(
)
)
;
text
.
CompressWhitespace
(
)
;
if
(
!
text
.
IsEmpty
(
)
)
return
NS_OK
;
bResetPromotion
=
true
;
}
rv
=
GetNodeLocation
(
aNode
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
if
(
offset
)
offset
-
-
;
node
=
GetChildAt
(
parent
offset
)
;
}
if
(
!
node
)
node
=
parent
;
if
(
!
IsRoot
(
node
)
&
&
(
parent
!
=
common
)
)
{
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
return
NS_OK
;
while
(
(
IsLastNode
(
node
)
)
&
&
(
!
IsRoot
(
parent
)
)
&
&
(
parent
!
=
common
)
)
{
if
(
bResetPromotion
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
parent
)
;
if
(
content
&
&
content
-
>
IsHTMLElement
(
)
)
{
if
(
nsHTMLElement
:
:
IsBlock
(
nsHTMLTags
:
:
AtomTagToId
(
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
)
{
bResetPromotion
=
false
;
}
}
}
node
=
parent
;
rv
=
GetNodeLocation
(
node
address_of
(
parent
)
&
offset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
offset
=
=
-
1
)
{
parent
=
node
;
offset
=
0
;
break
;
}
}
if
(
bResetPromotion
)
{
*
outNode
=
aNode
;
*
outOffset
=
aOffset
;
}
else
{
*
outNode
=
parent
;
offset
+
+
;
*
outOffset
=
offset
;
}
return
rv
;
}
}
return
rv
;
}
nsCOMPtr
<
nsINode
>
nsHTMLCopyEncoder
:
:
GetChildAt
(
nsINode
*
aParent
int32_t
aOffset
)
{
nsCOMPtr
<
nsINode
>
resultNode
;
if
(
!
aParent
)
return
resultNode
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aParent
)
;
MOZ_ASSERT
(
content
"
null
content
in
nsHTMLCopyEncoder
:
:
GetChildAt
"
)
;
resultNode
=
content
-
>
GetChildAt_Deprecated
(
aOffset
)
;
return
resultNode
;
}
bool
nsHTMLCopyEncoder
:
:
IsMozBR
(
Element
*
aElement
)
{
HTMLBRElement
*
brElement
=
HTMLBRElement
:
:
FromNodeOrNull
(
aElement
)
;
return
brElement
&
&
brElement
-
>
IsPaddingForEmptyLastLine
(
)
;
}
nsresult
nsHTMLCopyEncoder
:
:
GetNodeLocation
(
nsINode
*
inChild
nsCOMPtr
<
nsINode
>
*
outParent
int32_t
*
outOffset
)
{
NS_ASSERTION
(
(
inChild
&
&
outParent
&
&
outOffset
)
"
bad
args
"
)
;
if
(
inChild
&
&
outParent
&
&
outOffset
)
{
nsCOMPtr
<
nsIContent
>
child
=
do_QueryInterface
(
inChild
)
;
if
(
!
child
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsIContent
*
parent
=
child
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
outParent
=
parent
;
*
outOffset
=
parent
-
>
ComputeIndexOf
(
child
)
;
return
NS_OK
;
}
return
NS_ERROR_NULL_POINTER
;
}
bool
nsHTMLCopyEncoder
:
:
IsRoot
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aNode
)
;
if
(
!
content
)
{
return
false
;
}
if
(
mIsTextWidget
)
{
return
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
div
)
;
}
return
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
;
}
bool
nsHTMLCopyEncoder
:
:
IsFirstNode
(
nsINode
*
aNode
)
{
for
(
nsIContent
*
sibling
=
aNode
-
>
GetPreviousSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetPreviousSibling
(
)
)
{
if
(
!
sibling
-
>
TextIsOnlyWhitespace
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsHTMLCopyEncoder
:
:
IsLastNode
(
nsINode
*
aNode
)
{
for
(
nsIContent
*
sibling
=
aNode
-
>
GetNextSibling
(
)
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
sibling
-
>
IsElement
(
)
&
&
IsMozBR
(
sibling
-
>
AsElement
(
)
)
)
{
continue
;
}
if
(
!
sibling
-
>
TextIsOnlyWhitespace
(
)
)
{
return
false
;
}
}
return
true
;
}
already_AddRefed
<
nsIDocumentEncoder
>
do_createHTMLCopyEncoder
(
)
{
return
do_AddRef
(
new
nsHTMLCopyEncoder
)
;
}
int32_t
nsHTMLCopyEncoder
:
:
GetImmediateContextCount
(
const
nsTArray
<
nsINode
*
>
&
aAncestorArray
)
{
int32_t
i
=
aAncestorArray
.
Length
(
)
j
=
0
;
while
(
j
<
i
)
{
nsINode
*
node
=
aAncestorArray
.
ElementAt
(
j
)
;
if
(
!
node
)
{
break
;
}
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
node
)
)
;
if
(
!
content
|
|
!
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
tr
nsGkAtoms
:
:
thead
nsGkAtoms
:
:
tbody
nsGkAtoms
:
:
tfoot
nsGkAtoms
:
:
table
)
)
{
break
;
}
+
+
j
;
}
return
j
;
}
