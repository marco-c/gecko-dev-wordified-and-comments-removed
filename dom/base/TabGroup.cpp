#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIURI
.
h
"
namespace
mozilla
{
namespace
dom
{
static
StaticRefPtr
<
TabGroup
>
sChromeTabGroup
;
LinkedList
<
TabGroup
>
*
TabGroup
:
:
sTabGroups
=
nullptr
;
TabGroup
:
:
TabGroup
(
bool
aIsChrome
)
:
mLastWindowLeft
(
false
)
mThrottledQueuesInitialized
(
false
)
mNumOfIndexedDBTransactions
(
0
)
mNumOfIndexedDBDatabases
(
0
)
mIsChrome
(
aIsChrome
)
mForegroundCount
(
0
)
{
if
(
!
sTabGroups
)
{
sTabGroups
=
new
LinkedList
<
TabGroup
>
(
)
;
}
sTabGroups
-
>
insertBack
(
this
)
;
CreateEventTargets
(
!
aIsChrome
)
;
if
(
aIsChrome
)
{
MOZ_ASSERT
(
!
sChromeTabGroup
)
;
return
;
}
if
(
NS_IsMainThread
(
)
)
{
EnsureThrottledEventQueues
(
)
;
}
}
TabGroup
:
:
~
TabGroup
(
)
{
MOZ_ASSERT
(
mDocGroups
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mWindows
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
mLastWindowLeft
|
|
mIsChrome
)
;
LinkedListElement
<
TabGroup
>
*
listElement
=
static_cast
<
LinkedListElement
<
TabGroup
>
*
>
(
this
)
;
listElement
-
>
remove
(
)
;
if
(
sTabGroups
-
>
isEmpty
(
)
)
{
delete
sTabGroups
;
sTabGroups
=
nullptr
;
}
}
void
TabGroup
:
:
EnsureThrottledEventQueues
(
)
{
if
(
mThrottledQueuesInitialized
)
{
return
;
}
mThrottledQueuesInitialized
=
true
;
for
(
size_t
i
=
0
;
i
<
size_t
(
TaskCategory
:
:
Count
)
;
i
+
+
)
{
TaskCategory
category
=
static_cast
<
TaskCategory
>
(
i
)
;
if
(
category
=
=
TaskCategory
:
:
Worker
)
{
mEventTargets
[
i
]
=
ThrottledEventQueue
:
:
Create
(
mEventTargets
[
i
]
"
TabGroup
worker
queue
"
)
;
}
else
if
(
category
=
=
TaskCategory
:
:
Timer
)
{
mEventTargets
[
i
]
=
ThrottledEventQueue
:
:
Create
(
mEventTargets
[
i
]
"
TabGroup
timer
queue
"
)
;
}
}
}
TabGroup
*
TabGroup
:
:
GetChromeTabGroup
(
)
{
if
(
!
sChromeTabGroup
)
{
sChromeTabGroup
=
new
TabGroup
(
true
)
;
ClearOnShutdown
(
&
sChromeTabGroup
)
;
}
return
sChromeTabGroup
;
}
TabGroup
*
TabGroup
:
:
GetFromWindow
(
mozIDOMWindowProxy
*
aWindow
)
{
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
aWindow
)
)
{
return
browserChild
-
>
TabGroup
(
)
;
}
return
nullptr
;
}
TabGroup
*
TabGroup
:
:
GetFromActor
(
BrowserChild
*
aBrowserChild
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
recordreplay
:
:
IsMiddleman
(
)
)
{
return
GetChromeTabGroup
(
)
;
}
nsCOMPtr
<
nsIEventTarget
>
target
=
aBrowserChild
-
>
Manager
(
)
-
>
GetEventTargetFor
(
aBrowserChild
)
;
if
(
!
target
)
{
return
nullptr
;
}
RefPtr
<
SchedulerGroup
>
group
=
SchedulerGroup
:
:
FromEventTarget
(
target
)
;
MOZ_RELEASE_ASSERT
(
group
)
;
auto
tabGroup
=
group
-
>
AsTabGroup
(
)
;
MOZ_RELEASE_ASSERT
(
tabGroup
)
;
tabGroup
-
>
EnsureThrottledEventQueues
(
)
;
return
tabGroup
;
}
already_AddRefed
<
DocGroup
>
TabGroup
:
:
GetDocGroup
(
const
nsACString
&
aKey
)
{
RefPtr
<
DocGroup
>
docGroup
(
mDocGroups
.
GetEntry
(
aKey
)
-
>
mDocGroup
)
;
return
docGroup
.
forget
(
)
;
}
already_AddRefed
<
DocGroup
>
TabGroup
:
:
AddDocument
(
const
nsACString
&
aKey
Document
*
aDocument
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
HashEntry
*
entry
=
mDocGroups
.
PutEntry
(
aKey
)
;
RefPtr
<
DocGroup
>
docGroup
;
if
(
entry
-
>
mDocGroup
)
{
docGroup
=
entry
-
>
mDocGroup
;
}
else
{
const
nsID
agentClusterId
=
nsContentUtils
:
:
GenerateUUID
(
)
;
docGroup
=
new
DocGroup
(
this
aKey
agentClusterId
)
;
entry
-
>
mDocGroup
=
docGroup
;
}
MOZ_ASSERT
(
RefPtr
<
DocGroup
>
(
GetDocGroup
(
aKey
)
)
=
=
docGroup
)
;
docGroup
-
>
mDocuments
.
AppendElement
(
aDocument
)
;
return
docGroup
.
forget
(
)
;
}
already_AddRefed
<
TabGroup
>
TabGroup
:
:
Join
(
nsPIDOMWindowOuter
*
aWindow
TabGroup
*
aTabGroup
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
TabGroup
>
tabGroup
=
aTabGroup
;
if
(
!
tabGroup
)
{
tabGroup
=
new
TabGroup
(
)
;
}
MOZ_RELEASE_ASSERT
(
!
tabGroup
-
>
mLastWindowLeft
)
;
MOZ_ASSERT
(
!
tabGroup
-
>
mWindows
.
Contains
(
aWindow
)
)
;
tabGroup
-
>
mWindows
.
AppendElement
(
aWindow
)
;
if
(
!
aWindow
-
>
IsBackground
(
)
)
{
tabGroup
-
>
mForegroundCount
+
+
;
}
return
tabGroup
.
forget
(
)
;
}
void
TabGroup
:
:
Leave
(
nsPIDOMWindowOuter
*
aWindow
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mWindows
.
Contains
(
aWindow
)
)
;
mWindows
.
RemoveElement
(
aWindow
)
;
if
(
!
aWindow
-
>
IsBackground
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mForegroundCount
>
0
)
;
mForegroundCount
-
-
;
}
MaybeDestroy
(
)
;
}
void
TabGroup
:
:
MaybeDestroy
(
)
{
if
(
!
mIsChrome
&
&
!
mLastWindowLeft
&
&
mWindows
.
IsEmpty
(
)
)
{
mLastWindowLeft
=
true
;
Shutdown
(
false
)
;
}
}
TabGroup
:
:
HashEntry
:
:
HashEntry
(
const
nsACString
*
aKey
)
:
nsCStringHashKey
(
aKey
)
mDocGroup
(
nullptr
)
{
}
nsISerialEventTarget
*
TabGroup
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
if
(
aCategory
=
=
TaskCategory
:
:
Worker
|
|
aCategory
=
=
TaskCategory
:
:
Timer
)
{
MOZ_RELEASE_ASSERT
(
mThrottledQueuesInitialized
|
|
mIsChrome
)
;
}
return
SchedulerGroup
:
:
EventTargetFor
(
aCategory
)
;
}
AbstractThread
*
TabGroup
:
:
AbstractMainThreadForImpl
(
TaskCategory
aCategory
)
{
if
(
this
=
=
sChromeTabGroup
|
|
NS_WARN_IF
(
mLastWindowLeft
)
)
{
return
AbstractThread
:
:
MainThread
(
)
;
}
return
SchedulerGroup
:
:
AbstractMainThreadForImpl
(
aCategory
)
;
}
void
TabGroup
:
:
WindowChangedBackgroundStatus
(
bool
aIsNowBackground
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
aIsNowBackground
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mForegroundCount
>
0
)
;
mForegroundCount
-
=
1
;
}
else
{
mForegroundCount
+
=
1
;
}
}
bool
TabGroup
:
:
IsBackground
(
)
const
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifdef
DEBUG
uint32_t
foregrounded
=
0
;
for
(
auto
&
window
:
mWindows
)
{
if
(
!
window
-
>
IsBackground
(
)
)
{
foregrounded
+
+
;
}
}
MOZ_ASSERT
(
foregrounded
=
=
mForegroundCount
)
;
#
endif
return
mForegroundCount
=
=
0
;
}
uint32_t
TabGroup
:
:
Count
(
bool
aActiveOnly
)
const
{
if
(
!
aActiveOnly
)
{
return
mDocGroups
.
Count
(
)
;
}
uint32_t
count
=
0
;
for
(
auto
iter
=
mDocGroups
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Get
(
)
-
>
mDocGroup
-
>
IsActive
(
)
)
{
+
+
count
;
}
}
return
count
;
}
}
}
