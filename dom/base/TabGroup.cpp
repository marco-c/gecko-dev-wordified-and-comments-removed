#
include
"
mozilla
/
dom
/
TabGroup
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
AbstractThread
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIURI
.
h
"
namespace
mozilla
{
namespace
dom
{
static
StaticRefPtr
<
TabGroup
>
sChromeTabGroup
;
TabGroup
:
:
TabGroup
(
bool
aIsChrome
)
:
mLastWindowLeft
(
false
)
mThrottledQueuesInitialized
(
false
)
mIsChrome
(
aIsChrome
)
{
for
(
size_t
i
=
0
;
i
<
size_t
(
TaskCategory
:
:
Count
)
;
i
+
+
)
{
TaskCategory
category
=
static_cast
<
TaskCategory
>
(
i
)
;
if
(
aIsChrome
)
{
mEventTargets
[
i
]
=
do_GetMainThread
(
)
;
}
else
{
mEventTargets
[
i
]
=
CreateEventTargetFor
(
category
)
;
}
}
if
(
aIsChrome
)
{
MOZ_ASSERT
(
!
sChromeTabGroup
)
;
return
;
}
if
(
NS_IsMainThread
(
)
)
{
EnsureThrottledEventQueues
(
)
;
}
}
TabGroup
:
:
~
TabGroup
(
)
{
MOZ_ASSERT
(
mDocGroups
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mWindows
.
IsEmpty
(
)
)
;
MOZ_RELEASE_ASSERT
(
mLastWindowLeft
|
|
mIsChrome
)
;
}
void
TabGroup
:
:
EnsureThrottledEventQueues
(
)
{
if
(
mThrottledQueuesInitialized
)
{
return
;
}
mThrottledQueuesInitialized
=
true
;
for
(
size_t
i
=
0
;
i
<
size_t
(
TaskCategory
:
:
Count
)
;
i
+
+
)
{
TaskCategory
category
=
static_cast
<
TaskCategory
>
(
i
)
;
if
(
category
=
=
TaskCategory
:
:
Worker
|
|
category
=
=
TaskCategory
:
:
Timer
)
{
nsCOMPtr
<
nsIEventTarget
>
target
=
ThrottledEventQueue
:
:
Create
(
mEventTargets
[
i
]
)
;
if
(
target
)
{
mEventTargets
[
i
]
=
target
;
}
}
}
}
TabGroup
*
TabGroup
:
:
GetChromeTabGroup
(
)
{
if
(
!
sChromeTabGroup
)
{
sChromeTabGroup
=
new
TabGroup
(
true
)
;
ClearOnShutdown
(
&
sChromeTabGroup
)
;
}
return
sChromeTabGroup
;
}
TabGroup
*
TabGroup
:
:
GetFromWindowActor
(
mozIDOMWindowProxy
*
aWindow
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
TabChild
*
tabChild
=
TabChild
:
:
GetFrom
(
aWindow
)
;
if
(
!
tabChild
)
{
return
nullptr
;
}
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
nsCOMPtr
<
nsIEventTarget
>
target
=
cc
-
>
GetActorEventTarget
(
tabChild
)
;
if
(
!
target
)
{
return
nullptr
;
}
RefPtr
<
Dispatcher
>
dispatcher
=
Dispatcher
:
:
FromEventTarget
(
target
)
;
MOZ_RELEASE_ASSERT
(
dispatcher
)
;
auto
tabGroup
=
dispatcher
-
>
AsTabGroup
(
)
;
MOZ_RELEASE_ASSERT
(
tabGroup
)
;
tabGroup
-
>
EnsureThrottledEventQueues
(
)
;
return
tabGroup
;
}
already_AddRefed
<
DocGroup
>
TabGroup
:
:
GetDocGroup
(
const
nsACString
&
aKey
)
{
RefPtr
<
DocGroup
>
docGroup
(
mDocGroups
.
GetEntry
(
aKey
)
-
>
mDocGroup
)
;
return
docGroup
.
forget
(
)
;
}
already_AddRefed
<
DocGroup
>
TabGroup
:
:
AddDocument
(
const
nsACString
&
aKey
nsIDocument
*
aDocument
)
{
HashEntry
*
entry
=
mDocGroups
.
PutEntry
(
aKey
)
;
RefPtr
<
DocGroup
>
docGroup
;
if
(
entry
-
>
mDocGroup
)
{
docGroup
=
entry
-
>
mDocGroup
;
}
else
{
docGroup
=
new
DocGroup
(
this
aKey
)
;
entry
-
>
mDocGroup
=
docGroup
;
}
MOZ_ASSERT
(
RefPtr
<
DocGroup
>
(
GetDocGroup
(
aKey
)
)
=
=
docGroup
)
;
docGroup
-
>
mDocuments
.
AppendElement
(
aDocument
)
;
return
docGroup
.
forget
(
)
;
}
already_AddRefed
<
TabGroup
>
TabGroup
:
:
Join
(
nsPIDOMWindowOuter
*
aWindow
TabGroup
*
aTabGroup
)
{
RefPtr
<
TabGroup
>
tabGroup
=
aTabGroup
;
if
(
!
tabGroup
)
{
tabGroup
=
new
TabGroup
(
)
;
}
MOZ_RELEASE_ASSERT
(
!
tabGroup
-
>
mLastWindowLeft
)
;
MOZ_ASSERT
(
!
tabGroup
-
>
mWindows
.
Contains
(
aWindow
)
)
;
tabGroup
-
>
mWindows
.
AppendElement
(
aWindow
)
;
return
tabGroup
.
forget
(
)
;
}
void
TabGroup
:
:
Leave
(
nsPIDOMWindowOuter
*
aWindow
)
{
MOZ_ASSERT
(
mWindows
.
Contains
(
aWindow
)
)
;
mWindows
.
RemoveElement
(
aWindow
)
;
if
(
!
mIsChrome
&
&
mWindows
.
IsEmpty
(
)
)
{
mLastWindowLeft
=
true
;
for
(
size_t
i
=
0
;
i
<
size_t
(
TaskCategory
:
:
Count
)
;
i
+
+
)
{
mEventTargets
[
i
]
=
nullptr
;
mAbstractThreads
[
i
]
=
nullptr
;
}
}
}
nsresult
TabGroup
:
:
FindItemWithName
(
const
nsAString
&
aName
nsIDocShellTreeItem
*
aRequestor
nsIDocShellTreeItem
*
aOriginalRequestor
nsIDocShellTreeItem
*
*
aFoundItem
)
{
NS_ENSURE_ARG_POINTER
(
aFoundItem
)
;
*
aFoundItem
=
nullptr
;
MOZ_ASSERT
(
!
aName
.
LowerCaseEqualsLiteral
(
"
_blank
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_top
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_parent
"
)
&
&
!
aName
.
LowerCaseEqualsLiteral
(
"
_self
"
)
)
;
for
(
nsPIDOMWindowOuter
*
outerWindow
:
mWindows
)
{
if
(
outerWindow
-
>
GetScriptableParentOrNull
(
)
)
{
continue
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
docshell
=
outerWindow
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
continue
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
docshell
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
MOZ_RELEASE_ASSERT
(
docshell
=
=
root
)
;
if
(
root
&
&
aRequestor
!
=
root
)
{
root
-
>
FindItemWithName
(
aName
aRequestor
aOriginalRequestor
true
aFoundItem
)
;
if
(
*
aFoundItem
)
{
break
;
}
}
}
return
NS_OK
;
}
nsTArray
<
nsPIDOMWindowOuter
*
>
TabGroup
:
:
GetTopLevelWindows
(
)
{
nsTArray
<
nsPIDOMWindowOuter
*
>
array
;
for
(
nsPIDOMWindowOuter
*
outerWindow
:
mWindows
)
{
if
(
outerWindow
-
>
GetDocShell
(
)
&
&
!
outerWindow
-
>
GetScriptableParentOrNull
(
)
)
{
array
.
AppendElement
(
outerWindow
)
;
}
}
return
array
;
}
TabGroup
:
:
HashEntry
:
:
HashEntry
(
const
nsACString
*
aKey
)
:
nsCStringHashKey
(
aKey
)
mDocGroup
(
nullptr
)
{
}
nsresult
TabGroup
:
:
Dispatch
(
const
char
*
aName
TaskCategory
aCategory
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
{
nsCOMPtr
<
nsIRunnable
>
runnable
(
aRunnable
)
;
if
(
aName
)
{
if
(
nsCOMPtr
<
nsINamed
>
named
=
do_QueryInterface
(
runnable
)
)
{
named
-
>
SetName
(
aName
)
;
}
}
if
(
NS_IsMainThread
(
)
)
{
return
NS_DispatchToCurrentThread
(
runnable
.
forget
(
)
)
;
}
else
{
return
NS_DispatchToMainThread
(
runnable
.
forget
(
)
)
;
}
}
nsIEventTarget
*
TabGroup
:
:
EventTargetFor
(
TaskCategory
aCategory
)
const
{
MOZ_ASSERT
(
aCategory
!
=
TaskCategory
:
:
Count
)
;
if
(
aCategory
=
=
TaskCategory
:
:
Worker
|
|
aCategory
=
=
TaskCategory
:
:
Timer
)
{
MOZ_RELEASE_ASSERT
(
mThrottledQueuesInitialized
|
|
mIsChrome
)
;
}
if
(
NS_WARN_IF
(
mLastWindowLeft
)
)
{
nsCOMPtr
<
nsIEventTarget
>
main
=
do_GetMainThread
(
)
;
return
main
;
}
return
mEventTargets
[
size_t
(
aCategory
)
]
;
}
AbstractThread
*
TabGroup
:
:
AbstractMainThreadForImpl
(
TaskCategory
aCategory
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aCategory
!
=
TaskCategory
:
:
Count
)
;
if
(
this
=
=
sChromeTabGroup
|
|
NS_WARN_IF
(
mLastWindowLeft
)
)
{
return
AbstractThread
:
:
MainThread
(
)
;
}
if
(
!
mAbstractThreads
[
size_t
(
aCategory
)
]
)
{
mAbstractThreads
[
size_t
(
aCategory
)
]
=
AbstractThread
:
:
CreateEventTargetWrapper
(
mEventTargets
[
size_t
(
aCategory
)
]
true
)
;
}
return
mAbstractThreads
[
size_t
(
aCategory
)
]
;
}
}
}
