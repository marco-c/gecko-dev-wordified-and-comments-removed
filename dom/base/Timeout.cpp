#
include
"
Timeout
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsITimeoutHandler
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
namespace
mozilla
{
namespace
dom
{
Timeout
:
:
Timeout
(
)
:
mCleared
(
false
)
mRunning
(
false
)
mIsInterval
(
false
)
mIsTracking
(
false
)
mReason
(
Reason
:
:
eTimeoutOrInterval
)
mTimeoutId
(
0
)
mInterval
(
0
)
mFiringId
(
TimeoutManager
:
:
InvalidFiringId
)
mNestingLevel
(
0
)
mPopupState
(
openAllowed
)
{
}
Timeout
:
:
~
Timeout
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Timeout
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Timeout
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mScriptHandler
)
tmp
-
>
remove
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Timeout
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScriptHandler
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
Timeout
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
Timeout
Release
)
namespace
{
void
TimerCallback
(
nsITimer
*
void
*
aClosure
)
{
RefPtr
<
Timeout
>
timeout
=
(
Timeout
*
)
aClosure
;
timeout
-
>
mWindow
-
>
AsInner
(
)
-
>
TimeoutManager
(
)
.
RunTimeout
(
TimeStamp
:
:
Now
(
)
timeout
-
>
When
(
)
)
;
timeout
-
>
mClosureSelfRef
=
nullptr
;
}
void
TimerNameCallback
(
nsITimer
*
aTimer
bool
aAnonymize
void
*
aClosure
char
*
aBuf
size_t
aLen
)
{
RefPtr
<
Timeout
>
timeout
=
(
Timeout
*
)
aClosure
;
if
(
aAnonymize
)
{
if
(
timeout
-
>
mIsInterval
)
{
snprintf
(
aBuf
aLen
"
setInterval
"
)
;
}
else
{
snprintf
(
aBuf
aLen
"
setTimeout
"
)
;
}
return
;
}
const
char
*
filename
;
uint32_t
lineNum
column
;
timeout
-
>
mScriptHandler
-
>
GetLocation
(
&
filename
&
lineNum
&
column
)
;
snprintf
(
aBuf
aLen
"
[
content
]
%
s
:
%
u
:
%
u
"
filename
lineNum
column
)
;
}
}
nsresult
Timeout
:
:
InitTimer
(
nsIEventTarget
*
aTarget
uint32_t
aDelay
)
{
nsCOMPtr
<
nsIEventTarget
>
currentTarget
;
MOZ_ALWAYS_SUCCEEDS
(
mTimer
-
>
GetTarget
(
getter_AddRefs
(
currentTarget
)
)
)
;
if
(
(
aTarget
&
&
currentTarget
!
=
aTarget
)
|
|
(
!
aTarget
&
&
currentTarget
!
=
NS_GetCurrentThread
(
)
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
mTimer
-
>
Cancel
(
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
mTimer
-
>
SetTarget
(
aTarget
)
)
;
}
nsresult
rv
=
mTimer
-
>
InitWithNameableFuncCallback
(
TimerCallback
this
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
TimerNameCallback
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mClosureSelfRef
=
this
;
}
return
rv
;
}
void
Timeout
:
:
MaybeCancelTimer
(
)
{
if
(
!
mTimer
)
{
return
;
}
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
mClosureSelfRef
=
nullptr
;
}
void
Timeout
:
:
SetWhenOrTimeRemaining
(
const
TimeStamp
&
aBaseTime
const
TimeDuration
&
aDelay
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
)
;
if
(
mWindow
-
>
IsFrozen
(
)
)
{
mWhen
=
TimeStamp
(
)
;
mTimeRemaining
=
aDelay
;
mScheduledDelay
=
TimeDuration
(
0
)
;
return
;
}
mWhen
=
aBaseTime
+
aDelay
;
mTimeRemaining
=
TimeDuration
(
0
)
;
mScheduledDelay
=
aDelay
;
}
void
Timeout
:
:
SetDummyWhen
(
const
TimeStamp
&
aWhen
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mWindow
)
;
mWhen
=
aWhen
;
}
const
TimeStamp
&
Timeout
:
:
When
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mWhen
.
IsNull
(
)
)
;
return
mWhen
;
}
const
TimeDuration
&
Timeout
:
:
TimeRemaining
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mWhen
.
IsNull
(
)
)
;
return
mTimeRemaining
;
}
const
TimeDuration
&
Timeout
:
:
ScheduledDelay
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mWhen
.
IsNull
(
)
)
;
return
mScheduledDelay
;
}
}
}
