#
include
"
Timeout
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
namespace
mozilla
{
namespace
dom
{
Timeout
:
:
Timeout
(
)
:
mTimeoutId
(
0
)
mFiringId
(
TimeoutManager
:
:
InvalidFiringId
)
#
ifdef
DEBUG
mFiringIndex
(
-
1
)
#
endif
mPopupState
(
PopupBlocker
:
:
openAllowed
)
mReason
(
Reason
:
:
eTimeoutOrInterval
)
mNestingLevel
(
0
)
mCleared
(
false
)
mRunning
(
false
)
mIsInterval
(
false
)
{
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Timeout
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Timeout
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mScriptHandler
)
if
(
tmp
-
>
isInList
(
)
)
{
tmp
-
>
remove
(
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
Timeout
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mWindow
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScriptHandler
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
Timeout
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
Timeout
Release
)
void
Timeout
:
:
SetWhenOrTimeRemaining
(
const
TimeStamp
&
aBaseTime
const
TimeDuration
&
aDelay
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mWindow
)
;
mSubmitTime
=
aBaseTime
;
mSubmitTime
=
aBaseTime
;
#
ifdef
MOZ_GECKO_PROFILER
if
(
profiler_is_active
(
)
)
{
mCause
=
profiler_get_backtrace
(
)
;
}
#
endif
if
(
mWindow
-
>
IsFrozen
(
)
)
{
mWhen
=
TimeStamp
(
)
;
mTimeRemaining
=
aDelay
;
return
;
}
mWhen
=
aBaseTime
+
aDelay
;
mTimeRemaining
=
TimeDuration
(
0
)
;
}
const
TimeStamp
&
Timeout
:
:
When
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mWhen
.
IsNull
(
)
)
;
return
mWhen
;
}
const
TimeStamp
&
Timeout
:
:
SubmitTime
(
)
const
{
return
mSubmitTime
;
}
const
TimeDuration
&
Timeout
:
:
TimeRemaining
(
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
mWhen
.
IsNull
(
)
)
;
return
mTimeRemaining
;
}
}
}
