#
include
"
nsScriptLoader
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
SRILogHelper
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIDOMHTMLScriptElement
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
ImportManager
.
h
"
#
include
"
mozilla
/
dom
/
EncodingUtils
.
h
"
#
include
"
mozilla
/
ConsoleReportCollector
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsIScriptError
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
JS
:
:
SourceBufferHolder
;
static
LazyLogModule
gCspPRLog
(
"
CSP
"
)
;
void
ImplCycleCollectionUnlink
(
nsScriptLoadRequestList
&
aField
)
;
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsScriptLoadRequestList
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsScriptLoadRequest
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_0
(
nsScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsScriptLoadRequest
)
nsScriptLoadRequest
:
:
~
nsScriptLoadRequest
(
)
{
js_free
(
mScriptTextBuf
)
;
MOZ_ASSERT
(
!
mOffThreadToken
)
;
MaybeCancelOffThreadScript
(
)
;
}
void
nsScriptLoadRequest
:
:
SetReady
(
)
{
MOZ_ASSERT
(
mProgress
!
=
Progress
:
:
Ready
)
;
mProgress
=
Progress
:
:
Ready
;
}
void
nsScriptLoadRequest
:
:
Cancel
(
)
{
MaybeCancelOffThreadScript
(
)
;
mIsCanceled
=
true
;
}
void
nsScriptLoadRequest
:
:
MaybeCancelOffThreadScript
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mOffThreadToken
)
{
return
;
}
JSContext
*
cx
=
danger
:
:
GetJSContext
(
)
;
JS
:
:
CancelOffThreadScript
(
cx
mOffThreadToken
)
;
mOffThreadToken
=
nullptr
;
}
class
nsModuleLoadRequest
final
:
public
nsScriptLoadRequest
{
~
nsModuleLoadRequest
(
)
{
}
nsModuleLoadRequest
(
const
nsModuleLoadRequest
&
aOther
)
=
delete
;
nsModuleLoadRequest
(
nsModuleLoadRequest
&
&
aOther
)
=
delete
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED
(
nsModuleLoadRequest
nsScriptLoadRequest
)
nsModuleLoadRequest
(
nsIScriptElement
*
aElement
uint32_t
aVersion
CORSMode
aCORSMode
const
SRIMetadata
&
aIntegrity
nsScriptLoader
*
aLoader
)
;
bool
IsTopLevel
(
)
const
{
return
mIsTopLevel
;
}
void
SetReady
(
)
override
;
void
Cancel
(
)
override
;
void
ModuleLoaded
(
)
;
void
DependenciesLoaded
(
)
;
void
LoadFailed
(
)
;
bool
mIsTopLevel
;
nsCOMPtr
<
nsIURI
>
mBaseURL
;
RefPtr
<
nsScriptLoader
>
mLoader
;
RefPtr
<
nsModuleLoadRequest
>
mParent
;
RefPtr
<
nsModuleScript
>
mModuleScript
;
MozPromiseHolder
<
GenericPromise
>
mReady
;
nsTArray
<
RefPtr
<
nsModuleLoadRequest
>
>
mImports
;
}
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED
(
nsModuleLoadRequest
)
NS_INTERFACE_MAP_END_INHERITING
(
nsScriptLoadRequest
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsModuleLoadRequest
nsScriptLoadRequest
mBaseURL
mLoader
mParent
mModuleScript
mImports
)
NS_IMPL_ADDREF_INHERITED
(
nsModuleLoadRequest
nsScriptLoadRequest
)
NS_IMPL_RELEASE_INHERITED
(
nsModuleLoadRequest
nsScriptLoadRequest
)
nsModuleLoadRequest
:
:
nsModuleLoadRequest
(
nsIScriptElement
*
aElement
uint32_t
aVersion
CORSMode
aCORSMode
const
SRIMetadata
&
aIntegrity
nsScriptLoader
*
aLoader
)
:
nsScriptLoadRequest
(
nsScriptKind
:
:
Module
aElement
aVersion
aCORSMode
aIntegrity
)
mIsTopLevel
(
true
)
mLoader
(
aLoader
)
{
}
inline
nsModuleLoadRequest
*
nsScriptLoadRequest
:
:
AsModuleRequest
(
)
{
MOZ_ASSERT
(
IsModuleRequest
(
)
)
;
return
static_cast
<
nsModuleLoadRequest
*
>
(
this
)
;
}
void
nsModuleLoadRequest
:
:
Cancel
(
)
{
nsScriptLoadRequest
:
:
Cancel
(
)
;
mModuleScript
=
nullptr
;
mProgress
=
nsScriptLoadRequest
:
:
Progress
:
:
Ready
;
for
(
size_t
i
=
0
;
i
<
mImports
.
Length
(
)
;
i
+
+
)
{
mImports
[
i
]
-
>
Cancel
(
)
;
}
mReady
.
RejectIfExists
(
NS_ERROR_FAILURE
__func__
)
;
}
void
nsModuleLoadRequest
:
:
SetReady
(
)
{
#
ifdef
DEBUG
for
(
size_t
i
=
0
;
i
<
mImports
.
Length
(
)
;
i
+
+
)
{
MOZ_ASSERT
(
mImports
[
i
]
-
>
IsReadyToRun
(
)
)
;
}
#
endif
nsScriptLoadRequest
:
:
SetReady
(
)
;
mReady
.
ResolveIfExists
(
true
__func__
)
;
}
void
nsModuleLoadRequest
:
:
ModuleLoaded
(
)
{
mModuleScript
=
mLoader
-
>
GetFetchedModule
(
mURI
)
;
mLoader
-
>
StartFetchingModuleDependencies
(
this
)
;
}
void
nsModuleLoadRequest
:
:
DependenciesLoaded
(
)
{
if
(
!
mLoader
-
>
InstantiateModuleTree
(
this
)
)
{
LoadFailed
(
)
;
return
;
}
SetReady
(
)
;
mLoader
-
>
ProcessLoadedModuleTree
(
this
)
;
mLoader
=
nullptr
;
mParent
=
nullptr
;
}
void
nsModuleLoadRequest
:
:
LoadFailed
(
)
{
Cancel
(
)
;
mLoader
-
>
ProcessLoadedModuleTree
(
this
)
;
mLoader
=
nullptr
;
mParent
=
nullptr
;
}
class
nsModuleScript
final
:
public
nsISupports
{
enum
InstantiationState
{
Uninstantiated
Instantiated
Errored
}
;
RefPtr
<
nsScriptLoader
>
mLoader
;
nsCOMPtr
<
nsIURI
>
mBaseURL
;
JS
:
:
Heap
<
JSObject
*
>
mModuleRecord
;
JS
:
:
Heap
<
JS
:
:
Value
>
mException
;
InstantiationState
mInstantiationState
;
~
nsModuleScript
(
)
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
nsModuleScript
)
nsModuleScript
(
nsScriptLoader
*
aLoader
nsIURI
*
aBaseURL
JS
:
:
Handle
<
JSObject
*
>
aModuleRecord
)
;
nsScriptLoader
*
Loader
(
)
const
{
return
mLoader
;
}
JSObject
*
ModuleRecord
(
)
const
{
if
(
mModuleRecord
)
{
JS
:
:
ExposeObjectToActiveJS
(
mModuleRecord
)
;
}
return
mModuleRecord
;
}
JS
:
:
Value
Exception
(
)
const
{
JS
:
:
ExposeValueToActiveJS
(
mException
)
;
return
mException
;
}
nsIURI
*
BaseURL
(
)
const
{
return
mBaseURL
;
}
void
SetInstantiationResult
(
JS
:
:
Handle
<
JS
:
:
Value
>
aMaybeException
)
;
bool
IsUninstantiated
(
)
const
{
return
mInstantiationState
=
=
Uninstantiated
;
}
bool
IsInstantiated
(
)
const
{
return
mInstantiationState
=
=
Instantiated
;
}
bool
InstantiationFailed
(
)
const
{
return
mInstantiationState
=
=
Errored
;
}
void
UnlinkModuleRecord
(
)
;
}
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsModuleScript
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsModuleScript
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsModuleScript
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLoader
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mBaseURL
)
tmp
-
>
UnlinkModuleRecord
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsModuleScript
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLoader
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
nsModuleScript
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mModuleRecord
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mException
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsModuleScript
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsModuleScript
)
nsModuleScript
:
:
nsModuleScript
(
nsScriptLoader
*
aLoader
nsIURI
*
aBaseURL
JS
:
:
Handle
<
JSObject
*
>
aModuleRecord
)
:
mLoader
(
aLoader
)
mBaseURL
(
aBaseURL
)
mModuleRecord
(
aModuleRecord
)
mInstantiationState
(
Uninstantiated
)
{
MOZ_ASSERT
(
mLoader
)
;
MOZ_ASSERT
(
mBaseURL
)
;
MOZ_ASSERT
(
mModuleRecord
)
;
MOZ_ASSERT
(
mException
.
isUndefined
(
)
)
;
JS
:
:
SetModuleHostDefinedField
(
mModuleRecord
JS
:
:
PrivateValue
(
this
)
)
;
HoldJSObjects
(
this
)
;
}
void
nsModuleScript
:
:
UnlinkModuleRecord
(
)
{
if
(
mModuleRecord
)
{
MOZ_ASSERT
(
JS
:
:
GetModuleHostDefinedField
(
mModuleRecord
)
.
toPrivate
(
)
=
=
this
)
;
JS
:
:
SetModuleHostDefinedField
(
mModuleRecord
JS
:
:
UndefinedValue
(
)
)
;
}
mModuleRecord
=
nullptr
;
mException
.
setUndefined
(
)
;
}
nsModuleScript
:
:
~
nsModuleScript
(
)
{
if
(
mModuleRecord
)
{
UnlinkModuleRecord
(
)
;
}
DropJSObjects
(
this
)
;
}
void
nsModuleScript
:
:
SetInstantiationResult
(
JS
:
:
Handle
<
JS
:
:
Value
>
aMaybeException
)
{
MOZ_ASSERT
(
mInstantiationState
=
=
Uninstantiated
)
;
MOZ_ASSERT
(
mModuleRecord
)
;
MOZ_ASSERT
(
mException
.
isUndefined
(
)
)
;
if
(
aMaybeException
.
isUndefined
(
)
)
{
mInstantiationState
=
Instantiated
;
}
else
{
mModuleRecord
=
nullptr
;
mException
=
aMaybeException
;
mInstantiationState
=
Errored
;
}
}
nsScriptLoadRequestList
:
:
~
nsScriptLoadRequestList
(
)
{
Clear
(
)
;
}
void
nsScriptLoadRequestList
:
:
Clear
(
)
{
while
(
!
isEmpty
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
first
=
StealFirst
(
)
;
first
-
>
Cancel
(
)
;
}
}
#
ifdef
DEBUG
bool
nsScriptLoadRequestList
:
:
Contains
(
nsScriptLoadRequest
*
aElem
)
const
{
for
(
const
nsScriptLoadRequest
*
req
=
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
if
(
req
=
=
aElem
)
{
return
true
;
}
}
return
false
;
}
#
endif
inline
void
ImplCycleCollectionUnlink
(
nsScriptLoadRequestList
&
aField
)
{
while
(
!
aField
.
isEmpty
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
first
=
aField
.
StealFirst
(
)
;
}
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsScriptLoadRequestList
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
for
(
nsScriptLoadRequest
*
request
=
aField
.
getFirst
(
)
;
request
;
request
=
request
-
>
getNext
(
)
)
{
CycleCollectionNoteChild
(
aCallback
request
aName
aFlags
)
;
}
}
inline
void
ImplCycleCollectionUnlink
(
nsScriptLoader
:
:
PreloadInfo
&
aField
)
{
ImplCycleCollectionUnlink
(
aField
.
mRequest
)
;
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsScriptLoader
:
:
PreloadInfo
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mRequest
aName
aFlags
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsScriptLoader
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
nsScriptLoader
mNonAsyncExternalScriptInsertedRequests
mLoadingAsyncRequests
mLoadedAsyncRequests
mDeferRequests
mXSLTRequests
mParserBlockingRequest
mPreloads
mPendingChildLoaders
mFetchedModules
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsScriptLoader
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsScriptLoader
)
nsScriptLoader
:
:
nsScriptLoader
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
mParserBlockingBlockerCount
(
0
)
mBlockerCount
(
0
)
mNumberOfProcessors
(
0
)
mEnabled
(
true
)
mDeferEnabled
(
false
)
mDocumentParsingDone
(
false
)
mBlockingDOMContentLoaded
(
false
)
mReporter
(
new
ConsoleReportCollector
(
)
)
{
}
nsScriptLoader
:
:
~
nsScriptLoader
(
)
{
mObservers
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mXSLTRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mDeferRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mLoadingAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mLoadedAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
uint32_t
j
=
0
;
j
<
mPendingChildLoaders
.
Length
(
)
;
+
+
j
)
{
mPendingChildLoaders
[
j
]
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
}
static
bool
IsScriptEventHandler
(
nsIContent
*
aScriptElement
)
{
if
(
!
aScriptElement
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
nsAutoString
forAttr
eventAttr
;
if
(
!
aScriptElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
forAttr
)
|
|
!
aScriptElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
event
eventAttr
)
)
{
return
false
;
}
const
nsAString
&
for_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
forAttr
)
;
if
(
!
for_str
.
LowerCaseEqualsLiteral
(
"
window
"
)
)
{
return
true
;
}
const
nsAString
&
event_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
eventAttr
false
)
;
if
(
!
StringBeginsWith
(
event_str
NS_LITERAL_STRING
(
"
onload
"
)
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
nsAutoString
:
:
const_iterator
start
end
;
event_str
.
BeginReading
(
start
)
;
event_str
.
EndReading
(
end
)
;
start
.
advance
(
6
)
;
if
(
start
!
=
end
&
&
*
start
!
=
'
(
'
&
&
*
start
!
=
'
'
)
{
return
true
;
}
return
false
;
}
nsresult
nsScriptLoader
:
:
CheckContentPolicy
(
nsIDocument
*
aDocument
nsISupports
*
aContext
nsIURI
*
aURI
const
nsAString
&
aType
bool
aIsPreLoad
)
{
nsContentPolicyType
contentPolicyType
=
aIsPreLoad
?
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
contentPolicyType
aURI
aDocument
-
>
NodePrincipal
(
)
aContext
NS_LossyConvertUTF16toASCII
(
aType
)
nullptr
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
nsContentUtils
:
:
GetSecurityManager
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
NS_FAILED
(
rv
)
|
|
shouldLoad
!
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
return
NS_OK
;
}
bool
nsScriptLoader
:
:
ModuleMapContainsModule
(
nsModuleLoadRequest
*
aRequest
)
const
{
return
mFetchingModules
.
Contains
(
aRequest
-
>
mURI
)
|
|
mFetchedModules
.
Contains
(
aRequest
-
>
mURI
)
;
}
bool
nsScriptLoader
:
:
IsFetchingModule
(
nsModuleLoadRequest
*
aRequest
)
const
{
bool
fetching
=
mFetchingModules
.
Contains
(
aRequest
-
>
mURI
)
;
MOZ_ASSERT_IF
(
fetching
!
mFetchedModules
.
Contains
(
aRequest
-
>
mURI
)
)
;
return
fetching
;
}
void
nsScriptLoader
:
:
SetModuleFetchStarted
(
nsModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
MOZ_ASSERT
(
!
ModuleMapContainsModule
(
aRequest
)
)
;
mFetchingModules
.
Put
(
aRequest
-
>
mURI
nullptr
)
;
}
void
nsScriptLoader
:
:
SetModuleFetchFinishedAndResumeWaitingRequests
(
nsModuleLoadRequest
*
aRequest
nsresult
aResult
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsReadyToRun
(
)
)
;
RefPtr
<
GenericPromise
:
:
Private
>
promise
;
MOZ_ALWAYS_TRUE
(
mFetchingModules
.
Get
(
aRequest
-
>
mURI
getter_AddRefs
(
promise
)
)
)
;
mFetchingModules
.
Remove
(
aRequest
-
>
mURI
)
;
RefPtr
<
nsModuleScript
>
ms
(
aRequest
-
>
mModuleScript
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
aResult
)
=
=
(
ms
!
=
nullptr
)
)
;
mFetchedModules
.
Put
(
aRequest
-
>
mURI
ms
)
;
if
(
promise
)
{
if
(
ms
)
{
promise
-
>
Resolve
(
true
__func__
)
;
}
else
{
promise
-
>
Reject
(
aResult
__func__
)
;
}
}
}
RefPtr
<
GenericPromise
>
nsScriptLoader
:
:
WaitForModuleFetch
(
nsModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
ModuleMapContainsModule
(
aRequest
)
)
;
RefPtr
<
GenericPromise
:
:
Private
>
promise
;
if
(
mFetchingModules
.
Get
(
aRequest
-
>
mURI
getter_AddRefs
(
promise
)
)
)
{
if
(
!
promise
)
{
promise
=
new
GenericPromise
:
:
Private
(
__func__
)
;
mFetchingModules
.
Put
(
aRequest
-
>
mURI
promise
)
;
}
return
promise
;
}
RefPtr
<
nsModuleScript
>
ms
;
MOZ_ALWAYS_TRUE
(
mFetchedModules
.
Get
(
aRequest
-
>
mURI
getter_AddRefs
(
ms
)
)
)
;
if
(
!
ms
)
{
return
GenericPromise
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
return
GenericPromise
:
:
CreateAndResolve
(
true
__func__
)
;
}
nsModuleScript
*
nsScriptLoader
:
:
GetFetchedModule
(
nsIURI
*
aURL
)
const
{
bool
found
;
nsModuleScript
*
ms
=
mFetchedModules
.
GetWeak
(
aURL
&
found
)
;
MOZ_ASSERT
(
found
)
;
return
ms
;
}
nsresult
nsScriptLoader
:
:
ProcessFetchedModuleSource
(
nsModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
mModuleScript
)
;
nsresult
rv
=
CreateModuleScript
(
aRequest
)
;
SetModuleFetchFinishedAndResumeWaitingRequests
(
aRequest
rv
)
;
free
(
aRequest
-
>
mScriptTextBuf
)
;
aRequest
-
>
mScriptTextBuf
=
nullptr
;
aRequest
-
>
mScriptTextLength
=
0
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
StartFetchingModuleDependencies
(
aRequest
)
;
}
return
rv
;
}
nsresult
nsScriptLoader
:
:
CreateModuleScript
(
nsModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
!
aRequest
-
>
mModuleScript
)
;
MOZ_ASSERT
(
aRequest
-
>
mBaseURL
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
globalObject
"
CompileModule
"
true
)
;
bool
oldProcessingScriptTag
=
context
-
>
GetProcessingScriptTag
(
)
;
context
-
>
SetProcessingScriptTag
(
true
)
;
nsresult
rv
;
{
AutoCurrentScriptUpdater
scriptUpdater
(
this
aRequest
-
>
mElement
)
;
Maybe
<
AutoCurrentScriptUpdater
>
masterScriptUpdater
;
nsCOMPtr
<
nsIDocument
>
master
=
mDocument
-
>
MasterDocument
(
)
;
if
(
master
!
=
mDocument
)
{
masterScriptUpdater
.
emplace
(
master
-
>
ScriptLoader
(
)
aRequest
-
>
mElement
)
;
}
JSContext
*
cx
=
aes
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
cx
)
;
if
(
aRequest
-
>
mWasCompiledOMT
)
{
module
=
JS
:
:
FinishOffThreadModule
(
cx
aRequest
-
>
mOffThreadToken
)
;
aRequest
-
>
mOffThreadToken
=
nullptr
;
rv
=
module
?
NS_OK
:
NS_ERROR_FAILURE
;
}
else
{
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
rv
=
FillCompileOptionsForRequest
(
aes
aRequest
global
&
options
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
inlineData
;
SourceBufferHolder
srcBuf
=
GetScriptSource
(
aRequest
inlineData
)
;
rv
=
nsJSUtils
:
:
CompileModule
(
cx
srcBuf
global
options
&
module
)
;
}
}
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
=
=
(
module
!
=
nullptr
)
)
;
if
(
module
)
{
aRequest
-
>
mModuleScript
=
new
nsModuleScript
(
this
aRequest
-
>
mBaseURL
module
)
;
}
}
context
-
>
SetProcessingScriptTag
(
oldProcessingScriptTag
)
;
return
rv
;
}
static
bool
ThrowTypeError
(
JSContext
*
aCx
nsModuleScript
*
aScript
const
nsString
&
aMessage
)
{
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
aScript
-
>
ModuleRecord
(
)
)
;
JS
:
:
Rooted
<
JSScript
*
>
script
(
aCx
JS
:
:
GetModuleScript
(
aCx
module
)
)
;
JS
:
:
Rooted
<
JSString
*
>
filename
(
aCx
)
;
filename
=
JS_NewStringCopyZ
(
aCx
JS_GetScriptFilename
(
script
)
)
;
if
(
!
filename
)
{
return
false
;
}
JS
:
:
Rooted
<
JSString
*
>
message
(
aCx
JS_NewUCStringCopyZ
(
aCx
aMessage
.
get
(
)
)
)
;
if
(
!
message
)
{
return
false
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
error
(
aCx
)
;
if
(
!
JS
:
:
CreateError
(
aCx
JSEXN_TYPEERR
nullptr
filename
0
0
nullptr
message
&
error
)
)
{
return
false
;
}
JS_SetPendingException
(
aCx
error
)
;
return
false
;
}
static
bool
HandleResolveFailure
(
JSContext
*
aCx
nsModuleScript
*
aScript
const
nsAString
&
aSpecifier
)
{
nsAutoString
message
(
NS_LITERAL_STRING
(
"
Error
resolving
module
specifier
:
"
)
)
;
message
.
Append
(
aSpecifier
)
;
return
ThrowTypeError
(
aCx
aScript
message
)
;
}
static
bool
HandleModuleNotFound
(
JSContext
*
aCx
nsModuleScript
*
aScript
const
nsAString
&
aSpecifier
)
{
nsAutoString
message
(
NS_LITERAL_STRING
(
"
Resolved
module
not
found
in
map
:
"
)
)
;
message
.
Append
(
aSpecifier
)
;
return
ThrowTypeError
(
aCx
aScript
message
)
;
}
static
already_AddRefed
<
nsIURI
>
ResolveModuleSpecifier
(
nsModuleScript
*
aScript
const
nsAString
&
aSpecifier
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
uri
.
forget
(
)
;
}
if
(
rv
!
=
NS_ERROR_MALFORMED_URI
)
{
return
nullptr
;
}
if
(
!
StringBeginsWith
(
aSpecifier
NS_LITERAL_STRING
(
"
/
"
)
)
&
&
!
StringBeginsWith
(
aSpecifier
NS_LITERAL_STRING
(
"
.
/
"
)
)
&
&
!
StringBeginsWith
(
aSpecifier
NS_LITERAL_STRING
(
"
.
.
/
"
)
)
)
{
return
nullptr
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
nullptr
aScript
-
>
BaseURL
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
uri
.
forget
(
)
;
}
return
nullptr
;
}
static
nsresult
RequestedModuleIsInAncestorList
(
nsModuleLoadRequest
*
aRequest
nsIURI
*
aURL
bool
*
aResult
)
{
const
size_t
ImportDepthLimit
=
100
;
*
aResult
=
false
;
size_t
depth
=
0
;
while
(
aRequest
)
{
if
(
depth
+
+
=
=
ImportDepthLimit
)
{
return
NS_ERROR_FAILURE
;
}
bool
equal
;
nsresult
rv
=
aURL
-
>
Equals
(
aRequest
-
>
mURI
&
equal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
equal
)
{
*
aResult
=
true
;
return
NS_OK
;
}
aRequest
=
aRequest
-
>
mParent
;
}
return
NS_OK
;
}
static
nsresult
ResolveRequestedModules
(
nsModuleLoadRequest
*
aRequest
nsCOMArray
<
nsIURI
>
&
aUrls
)
{
nsModuleScript
*
ms
=
aRequest
-
>
mModuleScript
;
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
ms
-
>
ModuleRecord
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
moduleRecord
(
cx
ms
-
>
ModuleRecord
(
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
specifiers
(
cx
JS
:
:
GetRequestedModules
(
cx
moduleRecord
)
)
;
uint32_t
length
;
if
(
!
JS_GetArrayLength
(
cx
specifiers
&
length
)
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
val
(
cx
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
if
(
!
JS_GetElement
(
cx
specifiers
i
&
val
)
)
{
return
NS_ERROR_FAILURE
;
}
nsAutoJSString
specifier
;
if
(
!
specifier
.
init
(
cx
val
)
)
{
return
NS_ERROR_FAILURE
;
}
nsModuleScript
*
ms
=
aRequest
-
>
mModuleScript
;
nsCOMPtr
<
nsIURI
>
uri
=
ResolveModuleSpecifier
(
ms
specifier
)
;
if
(
!
uri
)
{
HandleResolveFailure
(
cx
ms
specifier
)
;
return
NS_ERROR_FAILURE
;
}
bool
isAncestor
;
nsresult
rv
=
RequestedModuleIsInAncestorList
(
aRequest
uri
&
isAncestor
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
isAncestor
)
{
aUrls
.
AppendElement
(
uri
.
forget
(
)
)
;
}
}
return
NS_OK
;
}
void
nsScriptLoader
:
:
StartFetchingModuleDependencies
(
nsModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mModuleScript
)
;
MOZ_ASSERT
(
!
aRequest
-
>
IsReadyToRun
(
)
)
;
aRequest
-
>
mProgress
=
nsModuleLoadRequest
:
:
Progress
:
:
FetchingImports
;
nsCOMArray
<
nsIURI
>
urls
;
nsresult
rv
=
ResolveRequestedModules
(
aRequest
urls
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRequest
-
>
LoadFailed
(
)
;
return
;
}
if
(
urls
.
Length
(
)
=
=
0
)
{
aRequest
-
>
DependenciesLoaded
(
)
;
return
;
}
nsTArray
<
RefPtr
<
GenericPromise
>
>
importsReady
;
for
(
size_t
i
=
0
;
i
<
urls
.
Length
(
)
;
i
+
+
)
{
RefPtr
<
GenericPromise
>
childReady
=
StartFetchingModuleAndDependencies
(
aRequest
urls
[
i
]
)
;
importsReady
.
AppendElement
(
childReady
)
;
}
RefPtr
<
GenericPromise
:
:
AllPromiseType
>
allReady
=
GenericPromise
:
:
All
(
AbstractThread
:
:
GetCurrent
(
)
importsReady
)
;
allReady
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
__func__
aRequest
&
nsModuleLoadRequest
:
:
DependenciesLoaded
&
nsModuleLoadRequest
:
:
LoadFailed
)
;
}
RefPtr
<
GenericPromise
>
nsScriptLoader
:
:
StartFetchingModuleAndDependencies
(
nsModuleLoadRequest
*
aRequest
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
RefPtr
<
nsModuleLoadRequest
>
childRequest
=
new
nsModuleLoadRequest
(
aRequest
-
>
mElement
aRequest
-
>
mJSVersion
aRequest
-
>
mCORSMode
aRequest
-
>
mIntegrity
this
)
;
childRequest
-
>
mIsTopLevel
=
false
;
childRequest
-
>
mURI
=
aURI
;
childRequest
-
>
mIsInline
=
false
;
childRequest
-
>
mReferrerPolicy
=
aRequest
-
>
mReferrerPolicy
;
childRequest
-
>
mParent
=
aRequest
;
RefPtr
<
GenericPromise
>
ready
=
childRequest
-
>
mReady
.
Ensure
(
__func__
)
;
nsresult
rv
=
StartLoad
(
childRequest
NS_LITERAL_STRING
(
"
module
"
)
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
childRequest
-
>
mReady
.
Reject
(
rv
__func__
)
;
return
ready
;
}
aRequest
-
>
mImports
.
AppendElement
(
childRequest
)
;
return
ready
;
}
bool
HostResolveImportedModule
(
JSContext
*
aCx
unsigned
argc
JS
:
:
Value
*
vp
)
{
MOZ_ASSERT
(
argc
=
=
2
)
;
JS
:
:
CallArgs
args
=
JS
:
:
CallArgsFromVp
(
argc
vp
)
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
aCx
&
args
[
0
]
.
toObject
(
)
)
;
JS
:
:
Rooted
<
JSString
*
>
specifier
(
aCx
args
[
1
]
.
toString
(
)
)
;
JS
:
:
Value
value
=
JS
:
:
GetModuleHostDefinedField
(
module
)
;
auto
script
=
static_cast
<
nsModuleScript
*
>
(
value
.
toPrivate
(
)
)
;
MOZ_ASSERT
(
script
-
>
ModuleRecord
(
)
=
=
module
)
;
nsAutoJSString
string
;
if
(
!
string
.
init
(
aCx
specifier
)
)
{
return
false
;
}
nsCOMPtr
<
nsIURI
>
uri
=
ResolveModuleSpecifier
(
script
string
)
;
if
(
!
uri
)
{
return
HandleResolveFailure
(
aCx
script
string
)
;
}
nsModuleScript
*
ms
=
script
-
>
Loader
(
)
-
>
GetFetchedModule
(
uri
)
;
if
(
!
ms
)
{
return
HandleModuleNotFound
(
aCx
script
string
)
;
}
if
(
ms
-
>
InstantiationFailed
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
aCx
ms
-
>
Exception
(
)
)
;
JS_SetPendingException
(
aCx
exception
)
;
return
false
;
}
*
vp
=
JS
:
:
ObjectValue
(
*
ms
-
>
ModuleRecord
(
)
)
;
return
true
;
}
static
nsresult
EnsureModuleResolveHook
(
JSContext
*
aCx
)
{
if
(
JS
:
:
GetModuleResolveHook
(
aCx
)
)
{
return
NS_OK
;
}
JS
:
:
Rooted
<
JSFunction
*
>
func
(
aCx
)
;
func
=
JS_NewFunction
(
aCx
HostResolveImportedModule
2
0
"
HostResolveImportedModule
"
)
;
if
(
!
func
)
{
return
NS_ERROR_FAILURE
;
}
JS
:
:
SetModuleResolveHook
(
aCx
func
)
;
return
NS_OK
;
}
void
nsScriptLoader
:
:
ProcessLoadedModuleTree
(
nsModuleLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
IsTopLevel
(
)
)
{
MaybeMoveToLoadedList
(
aRequest
)
;
ProcessPendingRequests
(
)
;
}
if
(
aRequest
-
>
mWasCompiledOMT
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
}
}
bool
nsScriptLoader
:
:
InstantiateModuleTree
(
nsModuleLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
)
;
nsModuleScript
*
ms
=
aRequest
-
>
mModuleScript
;
MOZ_ASSERT
(
ms
)
;
if
(
!
ms
-
>
ModuleRecord
(
)
)
{
return
false
;
}
AutoJSAPI
jsapi
;
if
(
NS_WARN_IF
(
!
jsapi
.
Init
(
ms
-
>
ModuleRecord
(
)
)
)
)
{
return
false
;
}
nsresult
rv
=
EnsureModuleResolveHook
(
jsapi
.
cx
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
JS
:
:
Rooted
<
JSObject
*
>
module
(
jsapi
.
cx
(
)
ms
-
>
ModuleRecord
(
)
)
;
bool
ok
=
NS_SUCCEEDED
(
nsJSUtils
:
:
ModuleDeclarationInstantiation
(
jsapi
.
cx
(
)
module
)
)
;
JS
:
:
RootedValue
exception
(
jsapi
.
cx
(
)
)
;
if
(
!
ok
)
{
MOZ_ASSERT
(
jsapi
.
HasException
(
)
)
;
if
(
!
jsapi
.
StealException
(
&
exception
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
exception
.
isUndefined
(
)
)
;
}
mozilla
:
:
Vector
<
nsModuleLoadRequest
*
1
>
requests
;
if
(
!
requests
.
append
(
aRequest
)
)
{
return
false
;
}
while
(
!
requests
.
empty
(
)
)
{
nsModuleLoadRequest
*
request
=
requests
.
popCopy
(
)
;
nsModuleScript
*
ms
=
request
-
>
mModuleScript
;
if
(
!
ms
-
>
IsUninstantiated
(
)
)
{
continue
;
}
ms
-
>
SetInstantiationResult
(
exception
)
;
for
(
auto
import
:
request
-
>
mImports
)
{
if
(
import
-
>
mModuleScript
-
>
IsUninstantiated
(
)
&
&
!
requests
.
append
(
import
)
)
{
return
false
;
}
}
}
return
true
;
}
nsresult
nsScriptLoader
:
:
StartLoad
(
nsScriptLoadRequest
*
aRequest
const
nsAString
&
aType
bool
aScriptFromHead
)
{
MOZ_ASSERT
(
aRequest
-
>
IsLoading
(
)
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NULL_POINTER
)
;
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
NS_OK
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
nsModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
if
(
ModuleMapContainsModule
(
request
)
)
{
WaitForModuleFetch
(
request
)
-
>
Then
(
AbstractThread
:
:
GetCurrent
(
)
__func__
request
&
nsModuleLoadRequest
:
:
ModuleLoaded
&
nsModuleLoadRequest
:
:
LoadFailed
)
;
return
NS_OK
;
}
SetModuleFetchStarted
(
request
)
;
}
nsContentPolicyType
contentPolicyType
=
aRequest
-
>
IsPreload
(
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
nsCOMPtr
<
nsINode
>
context
;
if
(
aRequest
-
>
mElement
)
{
context
=
do_QueryInterface
(
aRequest
-
>
mElement
)
;
}
else
{
context
=
mDocument
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
MasterDocument
(
)
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_NULL_POINTER
)
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
prompter
(
do_QueryInterface
(
docshell
)
)
;
nsSecurityFlags
securityFlags
;
securityFlags
=
aRequest
-
>
mCORSMode
=
=
CORS_NONE
?
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
:
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
aRequest
-
>
mCORSMode
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
aRequest
-
>
mCORSMode
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aRequest
-
>
mURI
context
securityFlags
contentPolicyType
loadGroup
prompter
nsIRequest
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIScriptElement
*
script
=
aRequest
-
>
mElement
;
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
channel
)
)
;
if
(
cos
)
{
if
(
aScriptFromHead
&
&
!
(
script
&
&
(
script
-
>
GetScriptAsync
(
)
|
|
script
-
>
GetScriptDeferred
(
)
)
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
else
if
(
!
(
script
&
&
script
-
>
GetScriptDeferred
(
)
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Unblocked
)
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Accept
"
)
NS_LITERAL_CSTRING
(
"
*
/
*
"
)
false
)
;
httpChannel
-
>
SetReferrerWithPolicy
(
mDocument
-
>
GetDocumentURI
(
)
aRequest
-
>
mReferrerPolicy
)
;
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
internalChannel
)
{
internalChannel
-
>
SetIntegrityMetadata
(
aRequest
-
>
mIntegrity
.
GetIntegrityString
(
)
)
;
}
}
nsCOMPtr
<
nsILoadContext
>
loadContext
(
do_QueryInterface
(
docshell
)
)
;
mozilla
:
:
net
:
:
PredictorLearn
(
aRequest
-
>
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
loadContext
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
script
"
)
)
;
}
nsAutoPtr
<
mozilla
:
:
dom
:
:
SRICheckDataVerifier
>
sriDataVerifier
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
)
{
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
sriDataVerifier
=
new
SRICheckDataVerifier
(
aRequest
-
>
mIntegrity
sourceUri
mReporter
)
;
}
RefPtr
<
nsScriptLoadHandler
>
handler
=
new
nsScriptLoadHandler
(
this
aRequest
sriDataVerifier
.
forget
(
)
)
;
nsCOMPtr
<
nsIIncrementalStreamLoader
>
loader
;
rv
=
NS_NewIncrementalStreamLoader
(
getter_AddRefs
(
loader
)
handler
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
channel
-
>
AsyncOpen2
(
loader
)
;
}
bool
nsScriptLoader
:
:
PreloadURIComparator
:
:
Equals
(
const
PreloadInfo
&
aPi
nsIURI
*
const
&
aURI
)
const
{
bool
same
;
return
NS_SUCCEEDED
(
aPi
.
mRequest
-
>
mURI
-
>
Equals
(
aURI
&
same
)
)
&
&
same
;
}
class
nsScriptRequestProcessor
:
public
Runnable
{
private
:
RefPtr
<
nsScriptLoader
>
mLoader
;
RefPtr
<
nsScriptLoadRequest
>
mRequest
;
public
:
nsScriptRequestProcessor
(
nsScriptLoader
*
aLoader
nsScriptLoadRequest
*
aRequest
)
:
mLoader
(
aLoader
)
mRequest
(
aRequest
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mLoader
-
>
ProcessRequest
(
mRequest
)
;
}
}
;
static
inline
bool
ParseTypeAttribute
(
const
nsAString
&
aType
JSVersion
*
aVersion
)
{
MOZ_ASSERT
(
!
aType
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aVersion
)
;
MOZ_ASSERT
(
*
aVersion
=
=
JSVERSION_DEFAULT
)
;
nsContentTypeParser
parser
(
aType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
mimeType
)
)
{
return
false
;
}
nsAutoString
versionName
;
rv
=
parser
.
GetParameter
(
"
version
"
versionName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aVersion
=
nsContentUtils
:
:
ParseJavascriptVersion
(
versionName
)
;
}
else
if
(
rv
!
=
NS_ERROR_INVALID_ARG
)
{
return
false
;
}
return
true
;
}
static
bool
CSPAllowsInlineScript
(
nsIScriptElement
*
aElement
nsIDocument
*
aDocument
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
nsresult
rv
=
aDocument
-
>
NodePrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
csp
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
nsAutoString
nonce
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
nonce
nonce
)
;
nsAutoString
scriptText
;
aElement
-
>
GetScriptText
(
scriptText
)
;
bool
allowInlineScript
=
false
;
rv
=
csp
-
>
GetAllowsInline
(
nsIContentPolicy
:
:
TYPE_SCRIPT
nonce
scriptText
aElement
-
>
GetScriptLineNumber
(
)
&
allowInlineScript
)
;
return
allowInlineScript
;
}
nsScriptLoadRequest
*
nsScriptLoader
:
:
CreateLoadRequest
(
nsScriptKind
aKind
nsIScriptElement
*
aElement
uint32_t
aVersion
CORSMode
aCORSMode
const
SRIMetadata
&
aIntegrity
)
{
if
(
aKind
=
=
nsScriptKind
:
:
Classic
)
{
return
new
nsScriptLoadRequest
(
aKind
aElement
aVersion
aCORSMode
aIntegrity
)
;
}
MOZ_ASSERT
(
aKind
=
=
nsScriptKind
:
:
Module
)
;
return
new
nsModuleLoadRequest
(
aElement
aVersion
aCORSMode
aIntegrity
this
)
;
}
bool
nsScriptLoader
:
:
ProcessScriptElement
(
nsIScriptElement
*
aElement
)
{
NS_ENSURE_TRUE
(
mDocument
false
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
false
;
}
NS_ASSERTION
(
!
aElement
-
>
IsMalformed
(
)
"
Executing
malformed
script
"
)
;
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
if
(
IsScriptEventHandler
(
scriptContent
)
)
{
return
false
;
}
JSVersion
version
=
JSVERSION_DEFAULT
;
nsAutoString
type
;
bool
hasType
=
aElement
-
>
GetScriptType
(
type
)
;
nsScriptKind
scriptKind
=
nsScriptKind
:
:
Classic
;
if
(
!
type
.
IsEmpty
(
)
)
{
if
(
nsContentUtils
:
:
IsChromeDoc
(
mDocument
)
&
&
type
.
LowerCaseEqualsASCII
(
"
module
"
)
)
{
scriptKind
=
nsScriptKind
:
:
Module
;
}
else
{
NS_ENSURE_TRUE
(
ParseTypeAttribute
(
type
&
version
)
false
)
;
}
}
else
if
(
!
hasType
)
{
if
(
scriptContent
-
>
IsHTMLElement
(
)
)
{
nsAutoString
language
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
language
language
)
;
if
(
!
language
.
IsEmpty
(
)
)
{
if
(
!
nsContentUtils
:
:
IsJavaScriptLanguage
(
language
)
)
{
return
false
;
}
}
}
}
nsresult
rv
=
NS_OK
;
RefPtr
<
nsScriptLoadRequest
>
request
;
if
(
aElement
-
>
GetScriptExternal
(
)
)
{
nsCOMPtr
<
nsIURI
>
scriptURI
=
aElement
-
>
GetScriptURI
(
)
;
if
(
!
scriptURI
)
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
mozilla
:
:
net
:
:
ReferrerPolicy
ourRefPolicy
=
mDocument
-
>
GetReferrerPolicy
(
)
;
CORSMode
ourCORSMode
=
aElement
-
>
GetCORSMode
(
)
;
nsTArray
<
PreloadInfo
>
:
:
index_type
i
=
mPreloads
.
IndexOf
(
scriptURI
.
get
(
)
0
PreloadURIComparator
(
)
)
;
if
(
i
!
=
nsTArray
<
PreloadInfo
>
:
:
NoIndex
)
{
request
=
mPreloads
[
i
]
.
mRequest
;
request
-
>
mElement
=
aElement
;
nsString
preloadCharset
(
mPreloads
[
i
]
.
mCharset
)
;
mPreloads
.
RemoveElementAt
(
i
)
;
nsAutoString
elementCharset
;
aElement
-
>
GetScriptCharset
(
elementCharset
)
;
if
(
elementCharset
.
Equals
(
preloadCharset
)
&
&
ourCORSMode
=
=
request
-
>
mCORSMode
&
&
ourRefPolicy
=
=
request
-
>
mReferrerPolicy
&
&
scriptKind
=
=
request
-
>
mKind
)
{
rv
=
CheckContentPolicy
(
mDocument
aElement
request
-
>
mURI
type
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
request
-
>
Cancel
(
)
;
return
false
;
}
}
else
{
request
=
nullptr
;
}
}
if
(
!
request
)
{
SRIMetadata
sriMetadata
;
{
nsAutoString
integrity
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
integrity
integrity
)
;
if
(
!
integrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
nsScriptLoader
:
:
ProcessScriptElement
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
integrity
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
integrity
sourceUri
mReporter
&
sriMetadata
)
;
}
}
request
=
CreateLoadRequest
(
scriptKind
aElement
version
ourCORSMode
sriMetadata
)
;
request
-
>
mURI
=
scriptURI
;
request
-
>
mIsInline
=
false
;
request
-
>
mReferrerPolicy
=
ourRefPolicy
;
rv
=
StartLoad
(
request
type
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
}
NS_ASSERTION
(
!
request
-
>
InCompilingStage
(
)
"
Request
should
not
yet
be
in
compiling
stage
.
"
)
;
request
-
>
mJSVersion
=
version
;
if
(
aElement
-
>
GetScriptAsync
(
)
)
{
request
-
>
mIsAsync
=
true
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
mLoadedAsyncRequests
.
AppendElement
(
request
)
;
ProcessPendingRequestsAsync
(
)
;
}
else
{
mLoadingAsyncRequests
.
AppendElement
(
request
)
;
}
return
false
;
}
if
(
!
aElement
-
>
GetParserCreated
(
)
&
&
!
request
-
>
IsModuleRequest
(
)
)
{
request
-
>
mIsNonAsyncScriptInserted
=
true
;
mNonAsyncExternalScriptInsertedRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
false
;
}
if
(
aElement
-
>
GetScriptDeferred
(
)
|
|
request
-
>
IsModuleRequest
(
)
)
{
NS_ASSERTION
(
mDocument
-
>
GetCurrentContentSink
(
)
|
|
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
"
Non
-
XSLT
Defer
script
on
a
document
without
an
active
parser
;
bug
592366
.
"
)
;
AddDeferRequest
(
request
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
request
-
>
mIsXSLT
=
true
;
mXSLTRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsReadyToRun
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
true
;
}
if
(
request
-
>
IsReadyToRun
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
ProcessPendingRequestsAsync
(
)
;
return
true
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
return
true
;
}
if
(
mDocument
-
>
HasScriptsBlockedBySandbox
(
)
)
{
return
false
;
}
if
(
!
CSPAllowsInlineScript
(
aElement
mDocument
)
)
{
return
false
;
}
request
=
CreateLoadRequest
(
scriptKind
aElement
version
CORS_NONE
SRIMetadata
(
)
)
;
request
-
>
mJSVersion
=
version
;
request
-
>
mIsInline
=
true
;
request
-
>
mURI
=
mDocument
-
>
GetDocumentURI
(
)
;
request
-
>
mLineNo
=
aElement
-
>
GetScriptLineNumber
(
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
nsModuleLoadRequest
*
modReq
=
request
-
>
AsModuleRequest
(
)
;
modReq
-
>
mBaseURL
=
mDocument
-
>
GetDocBaseURI
(
)
;
rv
=
CreateModuleScript
(
modReq
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
StartFetchingModuleDependencies
(
modReq
)
;
if
(
aElement
-
>
GetScriptAsync
(
)
)
{
mLoadingAsyncRequests
.
AppendElement
(
request
)
;
}
else
{
AddDeferRequest
(
request
)
;
}
return
false
;
}
request
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress
:
:
Ready
;
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
&
&
(
!
ReadyToExecuteParserBlockingScripts
(
)
|
|
!
mXSLTRequests
.
isEmpty
(
)
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mXSLTRequests
.
AppendElement
(
request
)
;
return
true
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
NOT_FROM_PARSER
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
A
script
-
inserted
script
is
inserted
without
an
update
batch
?
"
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsScriptRequestProcessor
(
this
request
)
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
&
&
!
ReadyToExecuteParserBlockingScripts
(
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
mParserBlockingRequest
=
request
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
return
true
;
}
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Not
safe
to
run
a
parser
-
inserted
script
?
"
)
;
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
namespace
{
class
NotifyOffThreadScriptLoadCompletedRunnable
:
public
Runnable
{
RefPtr
<
nsScriptLoadRequest
>
mRequest
;
RefPtr
<
nsScriptLoader
>
mLoader
;
void
*
mToken
;
public
:
NotifyOffThreadScriptLoadCompletedRunnable
(
nsScriptLoadRequest
*
aRequest
nsScriptLoader
*
aLoader
)
:
mRequest
(
aRequest
)
mLoader
(
aLoader
)
mToken
(
nullptr
)
{
}
virtual
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
;
void
SetToken
(
void
*
aToken
)
{
MOZ_ASSERT
(
aToken
&
&
!
mToken
)
;
mToken
=
aToken
;
}
NS_DECL_NSIRUNNABLE
}
;
}
nsresult
nsScriptLoader
:
:
ProcessOffThreadRequest
(
nsScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mProgress
=
=
nsScriptLoadRequest
:
:
Progress
:
:
Compiling
)
;
MOZ_ASSERT
(
!
aRequest
-
>
mWasCompiledOMT
)
;
aRequest
-
>
mWasCompiledOMT
=
true
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
MOZ_ASSERT
(
aRequest
-
>
mOffThreadToken
)
;
nsModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
nsresult
rv
=
ProcessFetchedModuleSource
(
request
)
;
if
(
NS_FAILED
(
rv
)
)
{
request
-
>
LoadFailed
(
)
;
}
return
rv
;
}
aRequest
-
>
SetReady
(
)
;
if
(
aRequest
=
=
mParserBlockingRequest
)
{
if
(
!
ReadyToExecuteParserBlockingScripts
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
return
NS_OK
;
}
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
aRequest
)
;
ProcessRequest
(
aRequest
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
ContinueParserAsync
(
aRequest
)
;
return
NS_OK
;
}
nsresult
rv
=
ProcessRequest
(
aRequest
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
return
rv
;
}
NotifyOffThreadScriptLoadCompletedRunnable
:
:
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
{
if
(
MOZ_UNLIKELY
(
mRequest
|
|
mLoader
)
&
&
!
NS_IsMainThread
(
)
)
{
NS_ReleaseOnMainThread
(
mRequest
.
forget
(
)
)
;
NS_ReleaseOnMainThread
(
mLoader
.
forget
(
)
)
;
}
}
NS_IMETHODIMP
NotifyOffThreadScriptLoadCompletedRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsScriptLoadRequest
>
request
=
mRequest
.
forget
(
)
;
RefPtr
<
nsScriptLoader
>
loader
=
mLoader
.
forget
(
)
;
request
-
>
mOffThreadToken
=
mToken
;
nsresult
rv
=
loader
-
>
ProcessOffThreadRequest
(
request
)
;
return
rv
;
}
static
void
OffThreadScriptLoaderCallback
(
void
*
aToken
void
*
aCallbackData
)
{
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
aRunnable
=
dont_AddRef
(
static_cast
<
NotifyOffThreadScriptLoadCompletedRunnable
*
>
(
aCallbackData
)
)
;
aRunnable
-
>
SetToken
(
aToken
)
;
NS_DispatchToMainThread
(
aRunnable
)
;
}
nsresult
nsScriptLoader
:
:
AttemptAsyncScriptCompile
(
nsScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT_IF
(
!
aRequest
-
>
IsModuleRequest
(
)
aRequest
-
>
IsReadyToRun
(
)
)
;
MOZ_ASSERT
(
!
aRequest
-
>
mWasCompiledOMT
)
;
if
(
aRequest
-
>
mIsInline
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
globalObject
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
nsresult
rv
=
FillCompileOptionsForRequest
(
jsapi
aRequest
global
&
options
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
JS
:
:
CanCompileOffThread
(
cx
options
aRequest
-
>
mScriptTextLength
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
runnable
=
new
NotifyOffThreadScriptLoadCompletedRunnable
(
aRequest
this
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
if
(
!
JS
:
:
CompileOffThreadModule
(
cx
options
aRequest
-
>
mScriptTextBuf
aRequest
-
>
mScriptTextLength
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
else
{
if
(
!
JS
:
:
CompileOffThread
(
cx
options
aRequest
-
>
mScriptTextBuf
aRequest
-
>
mScriptTextLength
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
mDocument
-
>
BlockOnload
(
)
;
aRequest
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress
:
:
Compiling
;
Unused
<
<
runnable
.
forget
(
)
;
return
NS_OK
;
}
nsresult
nsScriptLoader
:
:
CompileOffThreadOrProcessRequest
(
nsScriptLoadRequest
*
aRequest
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
!
aRequest
-
>
mOffThreadToken
"
Candidate
for
off
-
thread
compile
is
already
parsed
off
-
thread
"
)
;
NS_ASSERTION
(
!
aRequest
-
>
InCompilingStage
(
)
"
Candidate
for
off
-
thread
compile
is
already
in
compiling
stage
.
"
)
;
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
return
ProcessRequest
(
aRequest
)
;
}
SourceBufferHolder
nsScriptLoader
:
:
GetScriptSource
(
nsScriptLoadRequest
*
aRequest
nsAutoString
&
inlineData
)
{
if
(
aRequest
-
>
mIsInline
)
{
aRequest
-
>
mElement
-
>
GetScriptText
(
inlineData
)
;
return
SourceBufferHolder
(
inlineData
.
get
(
)
inlineData
.
Length
(
)
SourceBufferHolder
:
:
NoOwnership
)
;
}
return
SourceBufferHolder
(
aRequest
-
>
mScriptTextBuf
aRequest
-
>
mScriptTextLength
SourceBufferHolder
:
:
NoOwnership
)
;
}
nsresult
nsScriptLoader
:
:
ProcessRequest
(
nsScriptLoadRequest
*
aRequest
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
aRequest
-
>
IsReadyToRun
(
)
"
Processing
a
request
that
is
not
ready
to
run
.
"
)
;
NS_ENSURE_ARG
(
aRequest
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
AsModuleRequest
(
)
-
>
mModuleScript
)
{
FireScriptAvailable
(
NS_ERROR_FAILURE
aRequest
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
scriptElem
=
do_QueryInterface
(
aRequest
-
>
mElement
)
;
nsCOMPtr
<
nsIDocument
>
doc
;
if
(
!
aRequest
-
>
mIsInline
)
{
doc
=
scriptElem
-
>
OwnerDoc
(
)
;
}
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
;
uint32_t
parserCreated
=
aRequest
-
>
mElement
-
>
GetParserCreated
(
)
;
if
(
parserCreated
)
{
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
mElement
;
}
aRequest
-
>
mElement
-
>
BeginEvaluating
(
)
;
FireScriptAvailable
(
NS_OK
aRequest
)
;
nsCOMPtr
<
nsIDocument
>
master
=
mDocument
-
>
MasterDocument
(
)
;
{
nsAutoMicroTask
mt
;
}
nsPIDOMWindowInner
*
pwin
=
master
-
>
GetInnerWindow
(
)
;
bool
runScript
=
!
!
pwin
;
if
(
runScript
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
NS_LITERAL_STRING
(
"
beforescriptexecute
"
)
true
true
&
runScript
)
;
}
pwin
=
master
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
runScript
=
false
;
}
nsresult
rv
=
NS_OK
;
if
(
runScript
)
{
if
(
doc
)
{
doc
-
>
BeginEvaluatingExternalScript
(
)
;
}
rv
=
EvaluateScript
(
aRequest
)
;
if
(
doc
)
{
doc
-
>
EndEvaluatingExternalScript
(
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
NS_LITERAL_STRING
(
"
afterscriptexecute
"
)
true
false
)
;
}
FireScriptEvaluated
(
rv
aRequest
)
;
aRequest
-
>
mElement
-
>
EndEvaluating
(
)
;
if
(
parserCreated
)
{
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
if
(
aRequest
-
>
mOffThreadToken
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
aRequest
-
>
MaybeCancelOffThreadScript
(
)
;
}
free
(
aRequest
-
>
mScriptTextBuf
)
;
aRequest
-
>
mScriptTextBuf
=
nullptr
;
aRequest
-
>
mScriptTextLength
=
0
;
return
rv
;
}
void
nsScriptLoader
:
:
FireScriptAvailable
(
nsresult
aResult
nsScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptAvailable
(
aResult
aRequest
-
>
mElement
aRequest
-
>
mIsInline
aRequest
-
>
mURI
aRequest
-
>
mLineNo
)
;
}
aRequest
-
>
FireScriptAvailable
(
aResult
)
;
}
void
nsScriptLoader
:
:
FireScriptEvaluated
(
nsresult
aResult
nsScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptEvaluated
(
aResult
aRequest
-
>
mElement
aRequest
-
>
mIsInline
)
;
}
aRequest
-
>
FireScriptEvaluated
(
aResult
)
;
}
already_AddRefed
<
nsIScriptGlobalObject
>
nsScriptLoader
:
:
GetScriptGlobalObject
(
)
{
nsCOMPtr
<
nsIDocument
>
master
=
mDocument
-
>
MasterDocument
(
)
;
nsPIDOMWindowInner
*
pwin
=
master
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
do_QueryInterface
(
pwin
)
;
NS_ASSERTION
(
globalObject
"
windows
must
be
global
objects
"
)
;
nsresult
rv
=
globalObject
-
>
EnsureScriptEnvironment
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
globalObject
.
forget
(
)
;
}
nsresult
nsScriptLoader
:
:
FillCompileOptionsForRequest
(
const
AutoJSAPI
&
jsapi
nsScriptLoadRequest
*
aRequest
JS
:
:
Handle
<
JSObject
*
>
aScopeChain
JS
:
:
CompileOptions
*
aOptions
)
{
nsresult
rv
;
nsContentUtils
:
:
GetWrapperSafeScriptFilename
(
mDocument
aRequest
-
>
mURI
aRequest
-
>
mURL
&
rv
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
bool
isScriptElement
=
!
aRequest
-
>
IsModuleRequest
(
)
|
|
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
;
aOptions
-
>
setIntroductionType
(
isScriptElement
?
"
scriptElement
"
:
"
importedModule
"
)
;
aOptions
-
>
setFileAndLine
(
aRequest
-
>
mURL
.
get
(
)
aRequest
-
>
mLineNo
)
;
aOptions
-
>
setVersion
(
JSVersion
(
aRequest
-
>
mJSVersion
)
)
;
aOptions
-
>
setIsRunOnce
(
true
)
;
aOptions
-
>
setNoScriptRval
(
true
)
;
if
(
aRequest
-
>
mHasSourceMapURL
)
{
aOptions
-
>
setSourceMapURL
(
aRequest
-
>
mSourceMapURL
.
get
(
)
)
;
}
if
(
aRequest
-
>
mOriginPrincipal
)
{
nsIPrincipal
*
scriptPrin
=
nsContentUtils
:
:
ObjectPrincipal
(
aScopeChain
)
;
bool
subsumes
=
scriptPrin
-
>
Subsumes
(
aRequest
-
>
mOriginPrincipal
)
;
aOptions
-
>
setMutedErrors
(
!
subsumes
)
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
elementVal
(
cx
)
;
MOZ_ASSERT
(
aRequest
-
>
mElement
)
;
if
(
NS_SUCCEEDED
(
nsContentUtils
:
:
WrapNative
(
cx
aRequest
-
>
mElement
&
elementVal
true
)
)
)
{
MOZ_ASSERT
(
elementVal
.
isObject
(
)
)
;
aOptions
-
>
setElement
(
&
elementVal
.
toObject
(
)
)
;
}
return
NS_OK
;
}
nsresult
nsScriptLoader
:
:
EvaluateScript
(
nsScriptLoadRequest
*
aRequest
)
{
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
scriptContent
(
do_QueryInterface
(
aRequest
-
>
mElement
)
)
;
nsIDocument
*
ownerDoc
=
scriptContent
-
>
OwnerDoc
(
)
;
if
(
ownerDoc
!
=
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
scriptContent
"
no
content
-
what
is
default
script
-
type
?
"
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
JSVersion
version
=
JSVersion
(
aRequest
-
>
mJSVersion
)
;
if
(
version
=
=
JSVERSION_UNKNOWN
)
{
return
NS_OK
;
}
nsAutoMicroTask
mt
;
AutoEntryScript
aes
(
globalObject
"
<
script
>
element
"
true
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
aes
.
cx
(
)
globalObject
-
>
GetGlobalJSObject
(
)
)
;
bool
oldProcessingScriptTag
=
context
-
>
GetProcessingScriptTag
(
)
;
context
-
>
SetProcessingScriptTag
(
true
)
;
nsresult
rv
;
{
AutoCurrentScriptUpdater
scriptUpdater
(
this
aRequest
-
>
mElement
)
;
Maybe
<
AutoCurrentScriptUpdater
>
masterScriptUpdater
;
nsCOMPtr
<
nsIDocument
>
master
=
mDocument
-
>
MasterDocument
(
)
;
if
(
master
!
=
mDocument
)
{
masterScriptUpdater
.
emplace
(
master
-
>
ScriptLoader
(
)
aRequest
-
>
mElement
)
;
}
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
nsModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
MOZ_ASSERT
(
request
-
>
mModuleScript
)
;
MOZ_ASSERT
(
!
request
-
>
mOffThreadToken
)
;
nsModuleScript
*
ms
=
request
-
>
mModuleScript
;
MOZ_ASSERT
(
!
ms
-
>
IsUninstantiated
(
)
)
;
if
(
ms
-
>
InstantiationFailed
(
)
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
exception
(
aes
.
cx
(
)
ms
-
>
Exception
(
)
)
;
JS_SetPendingException
(
aes
.
cx
(
)
exception
)
;
rv
=
NS_ERROR_FAILURE
;
}
else
{
JS
:
:
Rooted
<
JSObject
*
>
module
(
aes
.
cx
(
)
ms
-
>
ModuleRecord
(
)
)
;
MOZ_ASSERT
(
module
)
;
rv
=
nsJSUtils
:
:
ModuleEvaluation
(
aes
.
cx
(
)
module
)
;
}
}
else
{
JS
:
:
CompileOptions
options
(
aes
.
cx
(
)
)
;
rv
=
FillCompileOptionsForRequest
(
aes
aRequest
global
&
options
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
nsAutoString
inlineData
;
SourceBufferHolder
srcBuf
=
GetScriptSource
(
aRequest
inlineData
)
;
rv
=
nsJSUtils
:
:
EvaluateString
(
aes
.
cx
(
)
srcBuf
global
options
aRequest
-
>
OffThreadTokenPtr
(
)
)
;
}
}
}
context
-
>
SetProcessingScriptTag
(
oldProcessingScriptTag
)
;
return
rv
;
}
void
nsScriptLoader
:
:
ProcessPendingRequestsAsync
(
)
{
if
(
mParserBlockingRequest
|
|
!
mXSLTRequests
.
isEmpty
(
)
|
|
!
mLoadedAsyncRequests
.
isEmpty
(
)
|
|
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
|
|
!
mDeferRequests
.
isEmpty
(
)
|
|
!
mPendingChildLoaders
.
IsEmpty
(
)
)
{
NS_DispatchToCurrentThread
(
NewRunnableMethod
(
this
&
nsScriptLoader
:
:
ProcessPendingRequests
)
)
;
}
}
void
nsScriptLoader
:
:
ProcessPendingRequests
(
)
{
RefPtr
<
nsScriptLoadRequest
>
request
;
if
(
mParserBlockingRequest
&
&
mParserBlockingRequest
-
>
IsReadyToRun
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
request
.
swap
(
mParserBlockingRequest
)
;
UnblockParser
(
request
)
;
ProcessRequest
(
request
)
;
if
(
request
-
>
mWasCompiledOMT
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
}
ContinueParserAsync
(
request
)
;
}
while
(
ReadyToExecuteParserBlockingScripts
(
)
&
&
!
mXSLTRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mXSLTRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mLoadedAsyncRequests
.
isEmpty
(
)
)
{
request
=
mLoadedAsyncRequests
.
StealFirst
(
)
;
if
(
request
-
>
IsModuleRequest
(
)
)
{
ProcessRequest
(
request
)
;
}
else
{
CompileOffThreadOrProcessRequest
(
request
)
;
}
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mNonAsyncExternalScriptInsertedRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
if
(
mDocumentParsingDone
&
&
mXSLTRequests
.
isEmpty
(
)
)
{
while
(
ReadyToExecuteScripts
(
)
&
&
!
mDeferRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mDeferRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
}
while
(
!
mPendingChildLoaders
.
IsEmpty
(
)
&
&
ReadyToExecuteParserBlockingScripts
(
)
)
{
RefPtr
<
nsScriptLoader
>
child
=
mPendingChildLoaders
[
0
]
;
mPendingChildLoaders
.
RemoveElementAt
(
0
)
;
child
-
>
RemoveParserBlockingScriptExecutionBlocker
(
)
;
}
if
(
mDocumentParsingDone
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
&
&
MaybeRemovedDeferRequests
(
)
)
{
return
ProcessPendingRequests
(
)
;
}
if
(
mDocumentParsingDone
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mLoadingAsyncRequests
.
isEmpty
(
)
&
&
mLoadedAsyncRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
)
{
mDocumentParsingDone
=
false
;
mDocument
-
>
UnblockOnload
(
true
)
;
}
}
bool
nsScriptLoader
:
:
ReadyToExecuteParserBlockingScripts
(
)
{
if
(
!
SelfReadyToExecuteParserBlockingScripts
(
)
)
{
return
false
;
}
for
(
nsIDocument
*
doc
=
mDocument
;
doc
;
doc
=
doc
-
>
GetParentDocument
(
)
)
{
nsScriptLoader
*
ancestor
=
doc
-
>
ScriptLoader
(
)
;
if
(
!
ancestor
-
>
SelfReadyToExecuteParserBlockingScripts
(
)
&
&
ancestor
-
>
AddPendingChildLoader
(
this
)
)
{
AddParserBlockingScriptExecutionBlocker
(
)
;
return
false
;
}
}
if
(
mDocument
&
&
!
mDocument
-
>
IsMasterDocument
(
)
)
{
RefPtr
<
ImportManager
>
im
=
mDocument
-
>
ImportManager
(
)
;
RefPtr
<
ImportLoader
>
loader
=
im
-
>
Find
(
mDocument
)
;
MOZ_ASSERT
(
loader
"
How
can
we
have
an
import
document
without
a
loader
?
"
)
;
nsCOMPtr
<
nsINode
>
referrer
=
loader
-
>
GetMainReferrer
(
)
;
MOZ_ASSERT
(
referrer
"
There
has
to
be
a
main
referring
link
for
each
imports
"
)
;
RefPtr
<
ImportLoader
>
lastPred
=
im
-
>
GetNearestPredecessor
(
referrer
)
;
if
(
!
lastPred
)
{
return
true
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
lastPred
-
>
GetDocument
(
)
;
if
(
lastPred
-
>
IsBlocking
(
)
|
|
!
doc
|
|
!
doc
-
>
ScriptLoader
(
)
-
>
SelfReadyToExecuteParserBlockingScripts
(
)
)
{
lastPred
-
>
AddBlockedScriptLoader
(
this
)
;
loader
-
>
SetBlockingPredecessor
(
lastPred
)
;
return
false
;
}
}
return
true
;
}
static
bool
DetectByteOrderMark
(
const
unsigned
char
*
aBytes
int32_t
aLen
nsCString
&
oCharset
)
{
if
(
aLen
<
2
)
return
false
;
switch
(
aBytes
[
0
]
)
{
case
0xEF
:
if
(
aLen
>
=
3
&
&
0xBB
=
=
aBytes
[
1
]
&
&
0xBF
=
=
aBytes
[
2
]
)
{
oCharset
.
AssignLiteral
(
"
UTF
-
8
"
)
;
}
break
;
case
0xFE
:
if
(
0xFF
=
=
aBytes
[
1
]
)
{
oCharset
.
AssignLiteral
(
"
UTF
-
16BE
"
)
;
}
break
;
case
0xFF
:
if
(
0xFE
=
=
aBytes
[
1
]
)
{
oCharset
.
AssignLiteral
(
"
UTF
-
16LE
"
)
;
}
break
;
}
return
!
oCharset
.
IsEmpty
(
)
;
}
nsresult
nsScriptLoader
:
:
ConvertToUTF16
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
nsIDocument
*
aDocument
char16_t
*
&
aBufOut
size_t
&
aLengthOut
)
{
if
(
!
aLength
)
{
aBufOut
=
nullptr
;
aLengthOut
=
0
;
return
NS_OK
;
}
nsAutoCString
charset
;
nsCOMPtr
<
nsIUnicodeDecoder
>
unicodeDecoder
;
if
(
DetectByteOrderMark
(
aData
aLength
charset
)
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
&
&
aChannel
&
&
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
charset
)
)
&
&
EncodingUtils
:
:
FindEncodingForLabel
(
charset
charset
)
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
&
&
EncodingUtils
:
:
FindEncodingForLabel
(
aHintCharset
charset
)
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
&
&
aDocument
)
{
charset
=
aDocument
-
>
GetDocumentCharacterSet
(
)
;
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
"
windows
-
1252
"
)
;
}
int32_t
unicodeLength
=
0
;
nsresult
rv
=
unicodeDecoder
-
>
GetMaxLength
(
reinterpret_cast
<
const
char
*
>
(
aData
)
aLength
&
unicodeLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aBufOut
=
static_cast
<
char16_t
*
>
(
js_malloc
(
unicodeLength
*
sizeof
(
char16_t
)
)
)
;
if
(
!
aBufOut
)
{
aLengthOut
=
0
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
aLengthOut
=
unicodeLength
;
rv
=
unicodeDecoder
-
>
Convert
(
reinterpret_cast
<
const
char
*
>
(
aData
)
(
int32_t
*
)
&
aLength
aBufOut
&
unicodeLength
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
aLengthOut
=
unicodeLength
;
if
(
NS_FAILED
(
rv
)
)
{
js_free
(
aBufOut
)
;
aBufOut
=
nullptr
;
aLengthOut
=
0
;
}
return
rv
;
}
nsresult
nsScriptLoader
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aChannelStatus
nsresult
aSRIStatus
mozilla
:
:
Vector
<
char16_t
>
&
aString
mozilla
:
:
dom
:
:
SRICheckDataVerifier
*
aSRIDataVerifier
)
{
nsScriptLoadRequest
*
request
=
static_cast
<
nsScriptLoadRequest
*
>
(
aContext
)
;
NS_ASSERTION
(
request
"
null
request
in
stream
complete
handler
"
)
;
NS_ENSURE_TRUE
(
request
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsIRequest
>
channelRequest
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channelRequest
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
channel
=
do_QueryInterface
(
channelRequest
)
;
nsresult
rv
=
NS_OK
;
if
(
!
request
-
>
mIntegrity
.
IsEmpty
(
)
&
&
NS_SUCCEEDED
(
(
rv
=
aSRIStatus
)
)
)
{
MOZ_ASSERT
(
aSRIDataVerifier
)
;
MOZ_ASSERT
(
mReporter
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
&
&
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
rv
=
aSRIDataVerifier
-
>
Verify
(
request
-
>
mIntegrity
channel
sourceUri
mReporter
)
;
mReporter
-
>
FlushConsoleReports
(
mDocument
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
NS_ERROR_SRI_CORRUPT
;
}
}
else
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
channel
-
>
GetLoadInfo
(
)
;
if
(
loadInfo
-
>
GetEnforceSRI
(
)
)
{
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
nsScriptLoader
:
:
OnStreamComplete
required
SRI
not
found
"
)
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
loadInfo
-
>
LoadingPrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
nsAutoCString
violationURISpec
;
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
violationURISpec
)
;
uint32_t
lineNo
=
request
-
>
mElement
?
request
-
>
mElement
-
>
GetScriptLineNumber
(
)
:
0
;
csp
-
>
LogViolationDetails
(
nsIContentSecurityPolicy
:
:
VIOLATION_TYPE_REQUIRE_SRI_FOR_SCRIPT
NS_ConvertUTF8toUTF16
(
violationURISpec
)
EmptyString
(
)
lineNo
EmptyString
(
)
EmptyString
(
)
)
;
rv
=
NS_ERROR_SRI_CORRUPT
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
PrepareLoadedRequest
(
request
aLoader
aChannelStatus
aString
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_TRACKING_URI
)
{
nsCOMPtr
<
nsIContent
>
cont
=
do_QueryInterface
(
request
-
>
mElement
)
;
mDocument
-
>
AddBlockedTrackingNode
(
cont
)
;
}
if
(
request
-
>
mIsDefer
)
{
MOZ_ASSERT_IF
(
request
-
>
IsModuleRequest
(
)
request
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mDeferRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
request
-
>
mIsAsync
)
{
MOZ_ASSERT_IF
(
request
-
>
IsModuleRequest
(
)
request
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
)
;
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
request
-
>
mIsNonAsyncScriptInserted
)
{
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mNonAsyncExternalScriptInsertedRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
request
-
>
mIsXSLT
)
{
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mXSLTRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
request
-
>
IsModuleRequest
(
)
)
{
nsModuleLoadRequest
*
modReq
=
request
-
>
AsModuleRequest
(
)
;
MOZ_ASSERT
(
!
modReq
-
>
IsTopLevel
(
)
)
;
MOZ_ASSERT
(
!
modReq
-
>
isInList
(
)
)
;
modReq
-
>
Cancel
(
)
;
FireScriptAvailable
(
rv
request
)
;
}
else
if
(
mParserBlockingRequest
=
=
request
)
{
MOZ_ASSERT
(
!
request
-
>
isInList
(
)
)
;
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
request
)
;
MOZ_ASSERT
(
request
-
>
mElement
-
>
GetParserCreated
(
)
)
;
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
request
-
>
mElement
;
FireScriptAvailable
(
rv
request
)
;
ContinueParserAsync
(
request
)
;
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
else
{
mPreloads
.
RemoveElement
(
request
PreloadRequestComparator
(
)
)
;
}
}
ProcessPendingRequests
(
)
;
return
NS_OK
;
}
void
nsScriptLoader
:
:
UnblockParser
(
nsScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
mElement
-
>
UnblockParser
(
)
;
}
void
nsScriptLoader
:
:
ContinueParserAsync
(
nsScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
mElement
-
>
ContinueParserAsync
(
)
;
}
uint32_t
nsScriptLoader
:
:
NumberOfProcessors
(
)
{
if
(
mNumberOfProcessors
>
0
)
return
mNumberOfProcessors
;
int32_t
numProcs
=
PR_GetNumberOfProcessors
(
)
;
if
(
numProcs
>
0
)
mNumberOfProcessors
=
numProcs
;
return
mNumberOfProcessors
;
}
void
nsScriptLoader
:
:
MaybeMoveToLoadedList
(
nsScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
IsReadyToRun
(
)
)
;
if
(
aRequest
-
>
mIsAsync
)
{
MOZ_ASSERT
(
aRequest
-
>
isInList
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
mLoadedAsyncRequests
.
AppendElement
(
req
)
;
}
}
}
nsresult
nsScriptLoader
:
:
PrepareLoadedRequest
(
nsScriptLoadRequest
*
aRequest
nsIIncrementalStreamLoader
*
aLoader
nsresult
aStatus
mozilla
:
:
Vector
<
char16_t
>
&
aString
)
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
aStatus
;
}
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
NS_BINDING_ABORTED
;
}
if
(
!
mDocument
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
req
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
rv
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
requestSucceeded
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
sourceMapURL
;
rv
=
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
X
-
SourceMap
"
)
sourceMapURL
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aRequest
-
>
mHasSourceMapURL
=
true
;
aRequest
-
>
mSourceMapURL
=
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
aRequest
-
>
mCORSMode
=
=
CORS_NONE
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
aRequest
-
>
mOriginPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aString
.
empty
(
)
)
{
aRequest
-
>
mScriptTextLength
=
aString
.
length
(
)
;
aRequest
-
>
mScriptTextBuf
=
aString
.
extractOrCopyRawBuffer
(
)
;
}
NS_ASSERTION
(
mDeferRequests
.
Contains
(
aRequest
)
|
|
mLoadingAsyncRequests
.
Contains
(
aRequest
)
|
|
mNonAsyncExternalScriptInsertedRequests
.
Contains
(
aRequest
)
|
|
mXSLTRequests
.
Contains
(
aRequest
)
|
|
(
aRequest
-
>
IsModuleRequest
(
)
&
&
!
aRequest
-
>
AsModuleRequest
(
)
-
>
IsTopLevel
(
)
&
&
!
aRequest
-
>
isInList
(
)
)
|
|
mPreloads
.
Contains
(
aRequest
PreloadRequestComparator
(
)
)
|
|
mParserBlockingRequest
"
aRequest
should
be
pending
!
"
)
;
if
(
aRequest
-
>
IsModuleRequest
(
)
)
{
nsModuleLoadRequest
*
request
=
aRequest
-
>
AsModuleRequest
(
)
;
nsAutoCString
mimeType
;
channel
-
>
GetContentType
(
mimeType
)
;
NS_ConvertUTF8toUTF16
typeString
(
mimeType
)
;
if
(
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
typeString
)
)
{
return
NS_ERROR_FAILURE
;
}
channel
-
>
GetURI
(
getter_AddRefs
(
request
-
>
mBaseURL
)
)
;
rv
=
AttemptAsyncScriptCompile
(
request
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
return
rv
;
}
return
ProcessFetchedModuleSource
(
request
)
;
}
aRequest
-
>
SetReady
(
)
;
if
(
aRequest
=
=
mParserBlockingRequest
&
&
(
NumberOfProcessors
(
)
>
1
)
)
{
MOZ_ASSERT
(
!
aRequest
-
>
IsModuleRequest
(
)
)
;
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
)
;
if
(
rv
=
=
NS_OK
)
{
MOZ_ASSERT
(
aRequest
-
>
mProgress
=
=
nsScriptLoadRequest
:
:
Progress
:
:
Compiling
"
Request
should
be
off
-
thread
compiling
now
.
"
)
;
return
NS_OK
;
}
if
(
rv
!
=
NS_ERROR_FAILURE
)
{
return
rv
;
}
}
MaybeMoveToLoadedList
(
aRequest
)
;
return
NS_OK
;
}
void
nsScriptLoader
:
:
ParsingComplete
(
bool
aTerminated
)
{
if
(
mDeferEnabled
)
{
mDocumentParsingDone
=
true
;
}
mDeferEnabled
=
false
;
if
(
aTerminated
)
{
mDeferRequests
.
Clear
(
)
;
mLoadingAsyncRequests
.
Clear
(
)
;
mLoadedAsyncRequests
.
Clear
(
)
;
mNonAsyncExternalScriptInsertedRequests
.
Clear
(
)
;
mXSLTRequests
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
Cancel
(
)
;
mParserBlockingRequest
=
nullptr
;
}
}
ProcessPendingRequests
(
)
;
}
void
nsScriptLoader
:
:
PreloadURI
(
nsIURI
*
aURI
const
nsAString
&
aCharset
const
nsAString
&
aType
const
nsAString
&
aCrossOrigin
const
nsAString
&
aIntegrity
bool
aScriptFromHead
const
mozilla
:
:
net
:
:
ReferrerPolicy
aReferrerPolicy
)
{
NS_ENSURE_TRUE_VOID
(
mDocument
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
;
}
if
(
nsContentUtils
:
:
IsChromeDoc
(
mDocument
)
&
&
aType
.
LowerCaseEqualsASCII
(
"
module
"
)
)
{
return
;
}
SRIMetadata
sriMetadata
;
if
(
!
aIntegrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
SRILogHelper
:
:
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
nsScriptLoader
:
:
PreloadURI
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrity
)
.
get
(
)
)
)
;
nsAutoCString
sourceUri
;
if
(
mDocument
-
>
GetDocumentURI
(
)
)
{
mDocument
-
>
GetDocumentURI
(
)
-
>
GetAsciiSpec
(
sourceUri
)
;
}
SRICheck
:
:
IntegrityMetadata
(
aIntegrity
sourceUri
mReporter
&
sriMetadata
)
;
}
RefPtr
<
nsScriptLoadRequest
>
request
=
CreateLoadRequest
(
nsScriptKind
:
:
Classic
nullptr
0
Element
:
:
StringToCORSMode
(
aCrossOrigin
)
sriMetadata
)
;
request
-
>
mURI
=
aURI
;
request
-
>
mIsInline
=
false
;
request
-
>
mReferrerPolicy
=
aReferrerPolicy
;
nsresult
rv
=
StartLoad
(
request
aType
aScriptFromHead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
PreloadInfo
*
pi
=
mPreloads
.
AppendElement
(
)
;
pi
-
>
mRequest
=
request
;
pi
-
>
mCharset
=
aCharset
;
}
void
nsScriptLoader
:
:
AddDeferRequest
(
nsScriptLoadRequest
*
aRequest
)
{
aRequest
-
>
mIsDefer
=
true
;
mDeferRequests
.
AppendElement
(
aRequest
)
;
if
(
mDeferEnabled
&
&
aRequest
=
=
mDeferRequests
.
getFirst
(
)
&
&
mDocument
&
&
!
mBlockingDOMContentLoaded
)
{
MOZ_ASSERT
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
nsIDocument
:
:
READYSTATE_LOADING
)
;
mBlockingDOMContentLoaded
=
true
;
mDocument
-
>
BlockDOMContentLoaded
(
)
;
}
}
bool
nsScriptLoader
:
:
MaybeRemovedDeferRequests
(
)
{
if
(
mDeferRequests
.
isEmpty
(
)
&
&
mDocument
&
&
mBlockingDOMContentLoaded
)
{
mBlockingDOMContentLoaded
=
false
;
mDocument
-
>
UnblockDOMContentLoaded
(
)
;
return
true
;
}
return
false
;
}
nsScriptLoadHandler
:
:
nsScriptLoadHandler
(
nsScriptLoader
*
aScriptLoader
nsScriptLoadRequest
*
aRequest
mozilla
:
:
dom
:
:
SRICheckDataVerifier
*
aSRIDataVerifier
)
:
mScriptLoader
(
aScriptLoader
)
mRequest
(
aRequest
)
mSRIDataVerifier
(
aSRIDataVerifier
)
mSRIStatus
(
NS_OK
)
mDecoder
(
)
mBuffer
(
)
{
}
nsScriptLoadHandler
:
:
~
nsScriptLoadHandler
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsScriptLoadHandler
nsIIncrementalStreamLoaderObserver
)
NS_IMETHODIMP
nsScriptLoadHandler
:
:
OnIncrementalData
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
uint32_t
aDataLength
const
uint8_t
*
aData
uint32_t
*
aConsumedLength
)
{
if
(
mRequest
-
>
IsCanceled
(
)
)
{
*
aConsumedLength
=
aDataLength
;
return
NS_OK
;
}
if
(
!
EnsureDecoder
(
aLoader
aData
aDataLength
false
)
)
{
return
NS_OK
;
}
*
aConsumedLength
=
aDataLength
;
nsresult
rv
=
TryDecodeRawData
(
aData
aDataLength
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mSRIDataVerifier
&
&
NS_SUCCEEDED
(
mSRIStatus
)
)
{
mSRIStatus
=
mSRIDataVerifier
-
>
Update
(
aDataLength
aData
)
;
}
return
rv
;
}
nsresult
nsScriptLoadHandler
:
:
TryDecodeRawData
(
const
uint8_t
*
aData
uint32_t
aDataLength
bool
aEndOfStream
)
{
int32_t
srcLen
=
aDataLength
;
const
char
*
src
=
reinterpret_cast
<
const
char
*
>
(
aData
)
;
int32_t
dstLen
;
nsresult
rv
=
mDecoder
-
>
GetMaxLength
(
src
srcLen
&
dstLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
haveRead
=
mBuffer
.
length
(
)
;
uint32_t
capacity
=
haveRead
+
dstLen
;
if
(
!
mBuffer
.
reserve
(
capacity
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
rv
=
mDecoder
-
>
Convert
(
src
&
srcLen
mBuffer
.
begin
(
)
+
haveRead
&
dstLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
haveRead
+
=
dstLen
;
MOZ_ASSERT
(
haveRead
<
=
capacity
"
mDecoder
produced
more
data
than
expected
"
)
;
MOZ_ALWAYS_TRUE
(
mBuffer
.
resizeUninitialized
(
haveRead
)
)
;
return
NS_OK
;
}
bool
nsScriptLoadHandler
:
:
EnsureDecoder
(
nsIIncrementalStreamLoader
*
aLoader
const
uint8_t
*
aData
uint32_t
aDataLength
bool
aEndOfStream
)
{
if
(
mDecoder
)
{
return
true
;
}
nsAutoCString
charset
;
if
(
mRequest
-
>
IsModuleRequest
(
)
)
{
charset
=
"
UTF
-
8
"
;
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
if
(
!
aEndOfStream
&
&
(
aDataLength
<
3
)
)
{
return
false
;
}
if
(
DetectByteOrderMark
(
aData
aDataLength
charset
)
)
{
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
channel
&
&
NS_SUCCEEDED
(
channel
-
>
GetContentCharset
(
charset
)
)
&
&
EncodingUtils
:
:
FindEncodingForLabel
(
charset
charset
)
)
{
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
nsAutoString
hintCharset
;
if
(
!
mRequest
-
>
IsPreload
(
)
)
{
mRequest
-
>
mElement
-
>
GetScriptCharset
(
hintCharset
)
;
}
else
{
nsTArray
<
nsScriptLoader
:
:
PreloadInfo
>
:
:
index_type
i
=
mScriptLoader
-
>
mPreloads
.
IndexOf
(
mRequest
0
nsScriptLoader
:
:
PreloadRequestComparator
(
)
)
;
NS_ASSERTION
(
i
!
=
mScriptLoader
-
>
mPreloads
.
NoIndex
"
Incorrect
preload
bookkeeping
"
)
;
hintCharset
=
mScriptLoader
-
>
mPreloads
[
i
]
.
mCharset
;
}
if
(
EncodingUtils
:
:
FindEncodingForLabel
(
hintCharset
charset
)
)
{
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
if
(
mScriptLoader
-
>
mDocument
)
{
charset
=
mScriptLoader
-
>
mDocument
-
>
GetDocumentCharacterSet
(
)
;
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
charset
=
"
windows
-
1252
"
;
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
NS_IMETHODIMP
nsScriptLoadHandler
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aDataLength
const
uint8_t
*
aData
)
{
if
(
!
mRequest
-
>
IsCanceled
(
)
)
{
DebugOnly
<
bool
>
encoderSet
=
EnsureDecoder
(
aLoader
aData
aDataLength
true
)
;
MOZ_ASSERT
(
encoderSet
)
;
DebugOnly
<
nsresult
>
rv
=
TryDecodeRawData
(
aData
aDataLength
true
)
;
if
(
mSRIDataVerifier
&
&
NS_SUCCEEDED
(
mSRIStatus
)
)
{
mSRIStatus
=
mSRIDataVerifier
-
>
Update
(
aDataLength
aData
)
;
}
}
return
mScriptLoader
-
>
OnStreamComplete
(
aLoader
mRequest
aStatus
mSRIStatus
mBuffer
mSRIDataVerifier
)
;
}
