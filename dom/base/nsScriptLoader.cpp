#
include
"
nsScriptLoader
.
h
"
#
include
"
prsystem
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptContext
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsJSPrincipals
.
h
"
#
include
"
nsContentPolicyUtils
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIClassOfService
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIDOMHTMLScriptElement
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDocShellCID
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsCORSListenerProxy
.
h
"
#
include
"
nsProxyRelease
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsContentTypeParser
.
h
"
#
include
"
nsINetworkPredictor
.
h
"
#
include
"
ImportManager
.
h
"
#
include
"
mozilla
/
dom
/
EncodingUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
unused
.
h
"
#
include
"
nsIScriptError
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
LazyLogModule
gCspPRLog
(
"
CSP
"
)
;
static
LogModule
*
GetSriLog
(
)
{
static
LazyLogModule
gSriPRLog
(
"
SRI
"
)
;
return
gSriPRLog
;
}
NS_IMPL_ISUPPORTS0
(
nsScriptLoadRequest
)
nsScriptLoadRequestList
:
:
~
nsScriptLoadRequestList
(
)
{
Clear
(
)
;
}
void
nsScriptLoadRequestList
:
:
Clear
(
)
{
while
(
!
isEmpty
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
first
=
StealFirst
(
)
;
first
-
>
Cancel
(
)
;
}
}
#
ifdef
DEBUG
bool
nsScriptLoadRequestList
:
:
Contains
(
nsScriptLoadRequest
*
aElem
)
{
for
(
nsScriptLoadRequest
*
req
=
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
if
(
req
=
=
aElem
)
{
return
true
;
}
}
return
false
;
}
#
endif
nsScriptLoader
:
:
nsScriptLoader
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
mBlockerCount
(
0
)
mNumberOfProcessors
(
0
)
mEnabled
(
true
)
mDeferEnabled
(
false
)
mDocumentParsingDone
(
false
)
mBlockingDOMContentLoaded
(
false
)
{
}
nsScriptLoader
:
:
~
nsScriptLoader
(
)
{
mObservers
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mXSLTRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mDeferRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mLoadingAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mLoadedAsyncRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
nsScriptLoadRequest
*
req
=
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
;
req
;
req
=
req
-
>
getNext
(
)
)
{
req
-
>
FireScriptAvailable
(
NS_ERROR_ABORT
)
;
}
for
(
uint32_t
j
=
0
;
j
<
mPendingChildLoaders
.
Length
(
)
;
+
+
j
)
{
mPendingChildLoaders
[
j
]
-
>
RemoveExecuteBlocker
(
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsScriptLoader
nsISupports
)
static
bool
IsScriptEventHandler
(
nsIContent
*
aScriptElement
)
{
if
(
!
aScriptElement
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
nsAutoString
forAttr
eventAttr
;
if
(
!
aScriptElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
forAttr
)
|
|
!
aScriptElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
event
eventAttr
)
)
{
return
false
;
}
const
nsAString
&
for_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
forAttr
)
;
if
(
!
for_str
.
LowerCaseEqualsLiteral
(
"
window
"
)
)
{
return
true
;
}
const
nsAString
&
event_str
=
nsContentUtils
:
:
TrimWhitespace
<
nsCRT
:
:
IsAsciiSpace
>
(
eventAttr
false
)
;
if
(
!
StringBeginsWith
(
event_str
NS_LITERAL_STRING
(
"
onload
"
)
nsCaseInsensitiveStringComparator
(
)
)
)
{
return
true
;
}
nsAutoString
:
:
const_iterator
start
end
;
event_str
.
BeginReading
(
start
)
;
event_str
.
EndReading
(
end
)
;
start
.
advance
(
6
)
;
if
(
start
!
=
end
&
&
*
start
!
=
'
(
'
&
&
*
start
!
=
'
'
)
{
return
true
;
}
return
false
;
}
nsresult
nsScriptLoader
:
:
CheckContentPolicy
(
nsIDocument
*
aDocument
nsISupports
*
aContext
nsIURI
*
aURI
const
nsAString
&
aType
bool
aIsPreLoad
)
{
nsContentPolicyType
contentPolicyType
=
aIsPreLoad
?
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
int16_t
shouldLoad
=
nsIContentPolicy
:
:
ACCEPT
;
nsresult
rv
=
NS_CheckContentLoadPolicy
(
contentPolicyType
aURI
aDocument
-
>
NodePrincipal
(
)
aContext
NS_LossyConvertUTF16toASCII
(
aType
)
nullptr
&
shouldLoad
nsContentUtils
:
:
GetContentPolicy
(
)
nsContentUtils
:
:
GetSecurityManager
(
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_CP_REJECTED
(
shouldLoad
)
)
{
if
(
NS_FAILED
(
rv
)
|
|
shouldLoad
!
=
nsIContentPolicy
:
:
REJECT_TYPE
)
{
return
NS_ERROR_CONTENT_BLOCKED
;
}
return
NS_ERROR_CONTENT_BLOCKED_SHOW_ALT
;
}
return
NS_OK
;
}
nsresult
nsScriptLoader
:
:
ShouldLoadScript
(
nsIDocument
*
aDocument
nsISupports
*
aContext
nsIURI
*
aURI
const
nsAString
&
aType
bool
aIsPreLoad
)
{
nsresult
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
CheckLoadURIWithPrincipal
(
aDocument
-
>
NodePrincipal
(
)
aURI
nsIScriptSecurityManager
:
:
ALLOW_CHROME
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
CheckContentPolicy
(
aDocument
aContext
aURI
aType
aIsPreLoad
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
NS_OK
;
}
nsresult
nsScriptLoader
:
:
StartLoad
(
nsScriptLoadRequest
*
aRequest
const
nsAString
&
aType
bool
aScriptFromHead
)
{
if
(
mDocument
-
>
GetSandboxFlags
(
)
&
SANDBOXED_SCRIPTS
)
{
return
NS_OK
;
}
nsContentPolicyType
contentPolicyType
=
aRequest
-
>
IsPreload
(
)
?
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT_PRELOAD
:
nsIContentPolicy
:
:
TYPE_INTERNAL_SCRIPT
;
nsCOMPtr
<
nsINode
>
context
;
if
(
aRequest
-
>
mElement
)
{
context
=
do_QueryInterface
(
aRequest
-
>
mElement
)
;
}
else
{
context
=
mDocument
;
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
mDocument
-
>
GetDocumentLoadGroup
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
MasterDocument
(
)
-
>
GetWindow
(
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_NULL_POINTER
)
;
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
prompter
(
do_QueryInterface
(
docshell
)
)
;
nsSecurityFlags
securityFlags
=
aRequest
-
>
mCORSMode
=
=
CORS_NONE
?
nsILoadInfo
:
:
SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL
:
nsILoadInfo
:
:
SEC_REQUIRE_CORS_DATA_INHERITS
;
if
(
aRequest
-
>
mCORSMode
=
=
CORS_ANONYMOUS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_SAME_ORIGIN
;
}
else
if
(
aRequest
-
>
mCORSMode
=
=
CORS_USE_CREDENTIALS
)
{
securityFlags
|
=
nsILoadInfo
:
:
SEC_COOKIES_INCLUDE
;
}
securityFlags
|
=
nsILoadInfo
:
:
SEC_ALLOW_CHROME
;
nsCOMPtr
<
nsIChannel
>
channel
;
nsresult
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aRequest
-
>
mURI
context
securityFlags
contentPolicyType
loadGroup
prompter
nsIRequest
:
:
LOAD_NORMAL
|
nsIChannel
:
:
LOAD_CLASSIFY_URI
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIScriptElement
*
script
=
aRequest
-
>
mElement
;
nsCOMPtr
<
nsIClassOfService
>
cos
(
do_QueryInterface
(
channel
)
)
;
if
(
cos
)
{
if
(
aScriptFromHead
&
&
!
(
script
&
&
(
script
-
>
GetScriptAsync
(
)
|
|
script
-
>
GetScriptDeferred
(
)
)
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Leader
)
;
}
else
if
(
!
(
script
&
&
script
-
>
GetScriptDeferred
(
)
)
)
{
cos
-
>
AddClassFlags
(
nsIClassOfService
:
:
Unblocked
)
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
httpChannel
-
>
SetRequestHeader
(
NS_LITERAL_CSTRING
(
"
Accept
"
)
NS_LITERAL_CSTRING
(
"
*
/
*
"
)
false
)
;
httpChannel
-
>
SetReferrerWithPolicy
(
mDocument
-
>
GetDocumentURI
(
)
aRequest
-
>
mReferrerPolicy
)
;
}
nsCOMPtr
<
nsILoadContext
>
loadContext
(
do_QueryInterface
(
docshell
)
)
;
mozilla
:
:
net
:
:
PredictorLearn
(
aRequest
-
>
mURI
mDocument
-
>
GetDocumentURI
(
)
nsINetworkPredictor
:
:
LEARN_LOAD_SUBRESOURCE
loadContext
)
;
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
httpChannel
)
)
;
if
(
timedChannel
)
{
timedChannel
-
>
SetInitiatorType
(
NS_LITERAL_STRING
(
"
script
"
)
)
;
}
nsAutoPtr
<
mozilla
:
:
dom
:
:
SRICheckDataVerifier
>
sriDataVerifier
;
if
(
!
aRequest
-
>
mIntegrity
.
IsEmpty
(
)
)
{
sriDataVerifier
=
new
SRICheckDataVerifier
(
aRequest
-
>
mIntegrity
mDocument
)
;
}
RefPtr
<
nsScriptLoadHandler
>
handler
=
new
nsScriptLoadHandler
(
this
aRequest
sriDataVerifier
.
forget
(
)
)
;
nsCOMPtr
<
nsIIncrementalStreamLoader
>
loader
;
rv
=
NS_NewIncrementalStreamLoader
(
getter_AddRefs
(
loader
)
handler
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
channel
-
>
AsyncOpen2
(
loader
)
;
}
bool
nsScriptLoader
:
:
PreloadURIComparator
:
:
Equals
(
const
PreloadInfo
&
aPi
nsIURI
*
const
&
aURI
)
const
{
bool
same
;
return
NS_SUCCEEDED
(
aPi
.
mRequest
-
>
mURI
-
>
Equals
(
aURI
&
same
)
)
&
&
same
;
}
class
nsScriptRequestProcessor
:
public
nsRunnable
{
private
:
RefPtr
<
nsScriptLoader
>
mLoader
;
RefPtr
<
nsScriptLoadRequest
>
mRequest
;
public
:
nsScriptRequestProcessor
(
nsScriptLoader
*
aLoader
nsScriptLoadRequest
*
aRequest
)
:
mLoader
(
aLoader
)
mRequest
(
aRequest
)
{
}
NS_IMETHODIMP
Run
(
)
{
return
mLoader
-
>
ProcessRequest
(
mRequest
)
;
}
}
;
static
inline
bool
ParseTypeAttribute
(
const
nsAString
&
aType
JSVersion
*
aVersion
)
{
MOZ_ASSERT
(
!
aType
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aVersion
)
;
MOZ_ASSERT
(
*
aVersion
=
=
JSVERSION_DEFAULT
)
;
nsContentTypeParser
parser
(
aType
)
;
nsAutoString
mimeType
;
nsresult
rv
=
parser
.
GetType
(
mimeType
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
nsContentUtils
:
:
IsJavascriptMIMEType
(
mimeType
)
)
{
return
false
;
}
nsAutoString
versionName
;
rv
=
parser
.
GetParameter
(
"
version
"
versionName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
*
aVersion
=
nsContentUtils
:
:
ParseJavascriptVersion
(
versionName
)
;
}
else
if
(
rv
!
=
NS_ERROR_INVALID_ARG
)
{
return
false
;
}
return
true
;
}
static
bool
CSPAllowsInlineScript
(
nsIScriptElement
*
aElement
nsIDocument
*
aDocument
)
{
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
;
nsresult
rv
=
aDocument
-
>
NodePrincipal
(
)
-
>
GetCsp
(
getter_AddRefs
(
csp
)
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
if
(
!
csp
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
nsAutoString
nonce
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
nonce
nonce
)
;
nsAutoString
scriptText
;
aElement
-
>
GetScriptText
(
scriptText
)
;
bool
allowInlineScript
=
false
;
rv
=
csp
-
>
GetAllowsInline
(
nsIContentPolicy
:
:
TYPE_SCRIPT
nonce
scriptText
aElement
-
>
GetScriptLineNumber
(
)
&
allowInlineScript
)
;
return
allowInlineScript
;
}
bool
nsScriptLoader
:
:
ProcessScriptElement
(
nsIScriptElement
*
aElement
)
{
NS_ENSURE_TRUE
(
mDocument
false
)
;
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
false
;
}
NS_ASSERTION
(
!
aElement
-
>
IsMalformed
(
)
"
Executing
malformed
script
"
)
;
nsCOMPtr
<
nsIContent
>
scriptContent
=
do_QueryInterface
(
aElement
)
;
if
(
IsScriptEventHandler
(
scriptContent
)
)
{
return
false
;
}
JSVersion
version
=
JSVERSION_DEFAULT
;
nsAutoString
type
;
aElement
-
>
GetScriptType
(
type
)
;
if
(
!
type
.
IsEmpty
(
)
)
{
NS_ENSURE_TRUE
(
ParseTypeAttribute
(
type
&
version
)
false
)
;
}
else
{
if
(
scriptContent
-
>
IsHTMLElement
(
)
)
{
nsAutoString
language
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
language
language
)
;
if
(
!
language
.
IsEmpty
(
)
)
{
if
(
!
nsContentUtils
:
:
IsJavaScriptLanguage
(
language
)
)
{
return
false
;
}
}
}
}
nsresult
rv
=
NS_OK
;
RefPtr
<
nsScriptLoadRequest
>
request
;
if
(
aElement
-
>
GetScriptExternal
(
)
)
{
nsCOMPtr
<
nsIURI
>
scriptURI
=
aElement
-
>
GetScriptURI
(
)
;
if
(
!
scriptURI
)
{
NS_DispatchToCurrentThread
(
NS_NewRunnableMethod
(
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
mozilla
:
:
net
:
:
ReferrerPolicy
ourRefPolicy
=
mDocument
-
>
GetReferrerPolicy
(
)
;
CORSMode
ourCORSMode
=
aElement
-
>
GetCORSMode
(
)
;
nsTArray
<
PreloadInfo
>
:
:
index_type
i
=
mPreloads
.
IndexOf
(
scriptURI
.
get
(
)
0
PreloadURIComparator
(
)
)
;
if
(
i
!
=
nsTArray
<
PreloadInfo
>
:
:
NoIndex
)
{
request
=
mPreloads
[
i
]
.
mRequest
;
request
-
>
mElement
=
aElement
;
nsString
preloadCharset
(
mPreloads
[
i
]
.
mCharset
)
;
mPreloads
.
RemoveElementAt
(
i
)
;
nsAutoString
elementCharset
;
aElement
-
>
GetScriptCharset
(
elementCharset
)
;
if
(
elementCharset
.
Equals
(
preloadCharset
)
&
&
ourCORSMode
=
=
request
-
>
mCORSMode
&
&
ourRefPolicy
=
=
request
-
>
mReferrerPolicy
)
{
rv
=
CheckContentPolicy
(
mDocument
aElement
request
-
>
mURI
type
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
request
-
>
Cancel
(
)
;
return
false
;
}
}
else
{
request
=
nullptr
;
}
}
if
(
!
request
)
{
SRIMetadata
sriMetadata
;
{
nsAutoString
integrity
;
scriptContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
integrity
integrity
)
;
if
(
!
integrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
nsScriptLoader
:
:
ProcessScriptElement
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
integrity
)
.
get
(
)
)
)
;
SRICheck
:
:
IntegrityMetadata
(
integrity
mDocument
&
sriMetadata
)
;
}
}
request
=
new
nsScriptLoadRequest
(
aElement
version
ourCORSMode
sriMetadata
)
;
request
-
>
mURI
=
scriptURI
;
request
-
>
mIsInline
=
false
;
request
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress_Loading
;
request
-
>
mReferrerPolicy
=
ourRefPolicy
;
rv
=
StartLoad
(
request
type
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_DispatchToCurrentThread
(
NS_NewRunnableMethod
(
aElement
&
nsIScriptElement
:
:
FireErrorEvent
)
)
;
return
false
;
}
}
NS_ASSERTION
(
!
request
-
>
InCompilingStage
(
)
"
Request
should
not
yet
be
in
compiling
stage
.
"
)
;
request
-
>
mJSVersion
=
version
;
if
(
aElement
-
>
GetScriptAsync
(
)
)
{
request
-
>
mIsAsync
=
true
;
if
(
request
-
>
IsDoneLoading
(
)
)
{
mLoadedAsyncRequests
.
AppendElement
(
request
)
;
ProcessPendingRequestsAsync
(
)
;
}
else
{
mLoadingAsyncRequests
.
AppendElement
(
request
)
;
}
return
false
;
}
if
(
!
aElement
-
>
GetParserCreated
(
)
)
{
request
-
>
mIsNonAsyncScriptInserted
=
true
;
mNonAsyncExternalScriptInsertedRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsDoneLoading
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
false
;
}
if
(
aElement
-
>
GetScriptDeferred
(
)
)
{
NS_ASSERTION
(
mDocument
-
>
GetCurrentContentSink
(
)
|
|
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
"
Non
-
XSLT
Defer
script
on
a
document
without
an
active
parser
;
bug
592366
.
"
)
;
AddDeferRequest
(
request
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
request
-
>
mIsXSLT
=
true
;
mXSLTRequests
.
AppendElement
(
request
)
;
if
(
request
-
>
IsDoneLoading
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
}
return
true
;
}
if
(
request
-
>
IsDoneLoading
(
)
&
&
ReadyToExecuteScripts
(
)
)
{
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
)
{
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
ProcessPendingRequestsAsync
(
)
;
return
true
;
}
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mParserBlockingRequest
=
request
;
return
true
;
}
if
(
mDocument
-
>
GetSandboxFlags
(
)
&
SANDBOXED_SCRIPTS
)
{
return
false
;
}
if
(
!
CSPAllowsInlineScript
(
aElement
mDocument
)
)
{
return
false
;
}
request
=
new
nsScriptLoadRequest
(
aElement
version
CORS_NONE
SRIMetadata
(
)
)
;
request
-
>
mJSVersion
=
version
;
request
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress_DoneLoading
;
request
-
>
mIsInline
=
true
;
request
-
>
mURI
=
mDocument
-
>
GetDocumentURI
(
)
;
request
-
>
mLineNo
=
aElement
-
>
GetScriptLineNumber
(
)
;
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_XSLT
&
&
(
!
ReadyToExecuteScripts
(
)
|
|
!
mXSLTRequests
.
isEmpty
(
)
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
mXSLTRequests
.
AppendElement
(
request
)
;
return
true
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
NOT_FROM_PARSER
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
A
script
-
inserted
script
is
inserted
without
an
update
batch
?
"
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsScriptRequestProcessor
(
this
request
)
)
;
return
false
;
}
if
(
aElement
-
>
GetParserCreated
(
)
=
=
FROM_PARSER_NETWORK
&
&
!
ReadyToExecuteScripts
(
)
)
{
NS_ASSERTION
(
!
mParserBlockingRequest
"
There
can
be
only
one
parser
-
blocking
script
at
a
time
"
)
;
mParserBlockingRequest
=
request
;
NS_ASSERTION
(
mXSLTRequests
.
isEmpty
(
)
"
Parser
-
blocking
scripts
and
XSLT
scripts
in
the
same
doc
!
"
)
;
return
true
;
}
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Not
safe
to
run
a
parser
-
inserted
script
?
"
)
;
return
ProcessRequest
(
request
)
=
=
NS_ERROR_HTMLPARSER_BLOCK
;
}
namespace
{
class
NotifyOffThreadScriptLoadCompletedRunnable
:
public
nsRunnable
{
RefPtr
<
nsScriptLoadRequest
>
mRequest
;
RefPtr
<
nsScriptLoader
>
mLoader
;
void
*
mToken
;
public
:
NotifyOffThreadScriptLoadCompletedRunnable
(
nsScriptLoadRequest
*
aRequest
nsScriptLoader
*
aLoader
)
:
mRequest
(
aRequest
)
mLoader
(
aLoader
)
mToken
(
nullptr
)
{
}
virtual
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
;
void
SetToken
(
void
*
aToken
)
{
MOZ_ASSERT
(
aToken
&
&
!
mToken
)
;
mToken
=
aToken
;
}
NS_DECL_NSIRUNNABLE
}
;
}
nsresult
nsScriptLoader
:
:
ProcessOffThreadRequest
(
nsScriptLoadRequest
*
aRequest
)
{
MOZ_ASSERT
(
aRequest
-
>
mProgress
=
=
nsScriptLoadRequest
:
:
Progress_Compiling
)
;
aRequest
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress_DoneCompiling
;
if
(
aRequest
=
=
mParserBlockingRequest
)
{
if
(
!
ReadyToExecuteScripts
(
)
)
{
ProcessPendingRequestsAsync
(
)
;
return
NS_OK
;
}
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
aRequest
)
;
ProcessRequest
(
aRequest
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
ContinueParserAsync
(
aRequest
)
;
return
NS_OK
;
}
nsresult
rv
=
ProcessRequest
(
aRequest
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
return
rv
;
}
NotifyOffThreadScriptLoadCompletedRunnable
:
:
~
NotifyOffThreadScriptLoadCompletedRunnable
(
)
{
if
(
MOZ_UNLIKELY
(
mRequest
|
|
mLoader
)
&
&
!
NS_IsMainThread
(
)
)
{
nsCOMPtr
<
nsIThread
>
mainThread
;
NS_GetMainThread
(
getter_AddRefs
(
mainThread
)
)
;
if
(
mainThread
)
{
NS_ProxyRelease
(
mainThread
mRequest
)
;
NS_ProxyRelease
(
mainThread
mLoader
)
;
}
else
{
MOZ_ASSERT
(
false
"
We
really
shouldn
'
t
leak
!
"
)
;
Unused
<
<
mRequest
.
forget
(
)
;
Unused
<
<
mLoader
.
forget
(
)
;
}
}
}
NS_IMETHODIMP
NotifyOffThreadScriptLoadCompletedRunnable
:
:
Run
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsScriptLoadRequest
>
request
=
mRequest
.
forget
(
)
;
RefPtr
<
nsScriptLoader
>
loader
=
mLoader
.
forget
(
)
;
request
-
>
mOffThreadToken
=
mToken
;
nsresult
rv
=
loader
-
>
ProcessOffThreadRequest
(
request
)
;
return
rv
;
}
static
void
OffThreadScriptLoaderCallback
(
void
*
aToken
void
*
aCallbackData
)
{
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
aRunnable
=
dont_AddRef
(
static_cast
<
NotifyOffThreadScriptLoadCompletedRunnable
*
>
(
aCallbackData
)
)
;
aRunnable
-
>
SetToken
(
aToken
)
;
NS_DispatchToMainThread
(
aRunnable
)
;
}
nsresult
nsScriptLoader
:
:
AttemptAsyncScriptCompile
(
nsScriptLoadRequest
*
aRequest
)
{
if
(
aRequest
-
>
mIsInline
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
InitWithLegacyErrorReporting
(
globalObject
)
)
{
return
NS_ERROR_FAILURE
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
globalObject
-
>
GetGlobalJSObject
(
)
)
;
JS
:
:
CompileOptions
options
(
cx
)
;
FillCompileOptionsForRequest
(
jsapi
aRequest
global
&
options
)
;
if
(
!
JS
:
:
CanCompileOffThread
(
cx
options
aRequest
-
>
mScriptTextLength
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
NotifyOffThreadScriptLoadCompletedRunnable
>
runnable
=
new
NotifyOffThreadScriptLoadCompletedRunnable
(
aRequest
this
)
;
if
(
!
JS
:
:
CompileOffThread
(
cx
options
aRequest
-
>
mScriptTextBuf
aRequest
-
>
mScriptTextLength
OffThreadScriptLoaderCallback
static_cast
<
void
*
>
(
runnable
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
mDocument
-
>
BlockOnload
(
)
;
aRequest
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress_Compiling
;
Unused
<
<
runnable
.
forget
(
)
;
return
NS_OK
;
}
nsresult
nsScriptLoader
:
:
CompileOffThreadOrProcessRequest
(
nsScriptLoadRequest
*
aRequest
bool
*
oCompiledOffThread
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
!
aRequest
-
>
mOffThreadToken
"
Candidate
for
off
-
thread
compile
is
already
parsed
off
-
thread
"
)
;
NS_ASSERTION
(
!
aRequest
-
>
InCompilingStage
(
)
"
Candidate
for
off
-
thread
compile
is
already
in
compiling
stage
.
"
)
;
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
)
;
if
(
rv
!
=
NS_ERROR_FAILURE
)
{
if
(
oCompiledOffThread
&
&
rv
=
=
NS_OK
)
{
*
oCompiledOffThread
=
true
;
}
return
rv
;
}
return
ProcessRequest
(
aRequest
)
;
}
nsresult
nsScriptLoader
:
:
ProcessRequest
(
nsScriptLoadRequest
*
aRequest
)
{
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Processing
requests
when
running
scripts
is
unsafe
.
"
)
;
NS_ASSERTION
(
aRequest
-
>
IsReadyToRun
(
)
"
Processing
a
request
that
is
not
ready
to
run
.
"
)
;
NS_ENSURE_ARG
(
aRequest
)
;
nsAutoString
textData
;
const
char16_t
*
scriptBuf
=
nullptr
;
size_t
scriptLength
=
0
;
JS
:
:
SourceBufferHolder
:
:
Ownership
giveScriptOwnership
=
JS
:
:
SourceBufferHolder
:
:
NoOwnership
;
nsCOMPtr
<
nsIDocument
>
doc
;
nsCOMPtr
<
nsINode
>
scriptElem
=
do_QueryInterface
(
aRequest
-
>
mElement
)
;
if
(
aRequest
-
>
mIsInline
)
{
aRequest
-
>
mElement
-
>
GetScriptText
(
textData
)
;
scriptBuf
=
textData
.
get
(
)
;
scriptLength
=
textData
.
Length
(
)
;
giveScriptOwnership
=
JS
:
:
SourceBufferHolder
:
:
NoOwnership
;
}
else
{
scriptBuf
=
aRequest
-
>
mScriptTextBuf
;
scriptLength
=
aRequest
-
>
mScriptTextLength
;
giveScriptOwnership
=
JS
:
:
SourceBufferHolder
:
:
GiveOwnership
;
aRequest
-
>
mScriptTextBuf
=
nullptr
;
aRequest
-
>
mScriptTextLength
=
0
;
doc
=
scriptElem
-
>
OwnerDoc
(
)
;
}
JS
:
:
SourceBufferHolder
srcBuf
(
scriptBuf
scriptLength
giveScriptOwnership
)
;
nsCOMPtr
<
nsIScriptElement
>
oldParserInsertedScript
;
uint32_t
parserCreated
=
aRequest
-
>
mElement
-
>
GetParserCreated
(
)
;
if
(
parserCreated
)
{
oldParserInsertedScript
=
mCurrentParserInsertedScript
;
mCurrentParserInsertedScript
=
aRequest
-
>
mElement
;
}
FireScriptAvailable
(
NS_OK
aRequest
)
;
nsCOMPtr
<
nsIDocument
>
master
=
mDocument
-
>
MasterDocument
(
)
;
{
nsAutoMicroTask
mt
;
}
nsPIDOMWindowInner
*
pwin
=
master
-
>
GetInnerWindow
(
)
;
bool
runScript
=
!
!
pwin
;
if
(
runScript
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
NS_LITERAL_STRING
(
"
beforescriptexecute
"
)
true
true
&
runScript
)
;
}
pwin
=
master
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
runScript
=
false
;
}
nsresult
rv
=
NS_OK
;
if
(
runScript
)
{
if
(
doc
)
{
doc
-
>
BeginEvaluatingExternalScript
(
)
;
}
aRequest
-
>
mElement
-
>
BeginEvaluating
(
)
;
rv
=
EvaluateScript
(
aRequest
srcBuf
)
;
aRequest
-
>
mElement
-
>
EndEvaluating
(
)
;
if
(
doc
)
{
doc
-
>
EndEvaluatingExternalScript
(
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
scriptElem
-
>
OwnerDoc
(
)
scriptElem
NS_LITERAL_STRING
(
"
afterscriptexecute
"
)
true
false
)
;
}
FireScriptEvaluated
(
rv
aRequest
)
;
if
(
parserCreated
)
{
mCurrentParserInsertedScript
=
oldParserInsertedScript
;
}
if
(
aRequest
-
>
mOffThreadToken
)
{
JS
:
:
FinishOffThreadScript
(
nullptr
xpc
:
:
GetJSRuntime
(
)
aRequest
-
>
mOffThreadToken
)
;
aRequest
-
>
mOffThreadToken
=
nullptr
;
}
return
rv
;
}
void
nsScriptLoader
:
:
FireScriptAvailable
(
nsresult
aResult
nsScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptAvailable
(
aResult
aRequest
-
>
mElement
aRequest
-
>
mIsInline
aRequest
-
>
mURI
aRequest
-
>
mLineNo
)
;
}
aRequest
-
>
FireScriptAvailable
(
aResult
)
;
}
void
nsScriptLoader
:
:
FireScriptEvaluated
(
nsresult
aResult
nsScriptLoadRequest
*
aRequest
)
{
for
(
int32_t
i
=
0
;
i
<
mObservers
.
Count
(
)
;
i
+
+
)
{
nsCOMPtr
<
nsIScriptLoaderObserver
>
obs
=
mObservers
[
i
]
;
obs
-
>
ScriptEvaluated
(
aResult
aRequest
-
>
mElement
aRequest
-
>
mIsInline
)
;
}
aRequest
-
>
FireScriptEvaluated
(
aResult
)
;
}
already_AddRefed
<
nsIScriptGlobalObject
>
nsScriptLoader
:
:
GetScriptGlobalObject
(
)
{
nsCOMPtr
<
nsIDocument
>
master
=
mDocument
-
>
MasterDocument
(
)
;
nsPIDOMWindowInner
*
pwin
=
master
-
>
GetInnerWindow
(
)
;
if
(
!
pwin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
do_QueryInterface
(
pwin
)
;
NS_ASSERTION
(
globalObject
"
windows
must
be
global
objects
"
)
;
nsresult
rv
=
globalObject
-
>
EnsureScriptEnvironment
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
globalObject
.
forget
(
)
;
}
void
nsScriptLoader
:
:
FillCompileOptionsForRequest
(
const
AutoJSAPI
&
jsapi
nsScriptLoadRequest
*
aRequest
JS
:
:
Handle
<
JSObject
*
>
aScopeChain
JS
:
:
CompileOptions
*
aOptions
)
{
nsContentUtils
:
:
GetWrapperSafeScriptFilename
(
mDocument
aRequest
-
>
mURI
aRequest
-
>
mURL
)
;
aOptions
-
>
setIntroductionType
(
"
scriptElement
"
)
;
aOptions
-
>
setFileAndLine
(
aRequest
-
>
mURL
.
get
(
)
aRequest
-
>
mLineNo
)
;
aOptions
-
>
setVersion
(
JSVersion
(
aRequest
-
>
mJSVersion
)
)
;
aOptions
-
>
setIsRunOnce
(
true
)
;
aOptions
-
>
setNoScriptRval
(
true
)
;
if
(
aRequest
-
>
mHasSourceMapURL
)
{
aOptions
-
>
setSourceMapURL
(
aRequest
-
>
mSourceMapURL
.
get
(
)
)
;
}
if
(
aRequest
-
>
mOriginPrincipal
)
{
nsIPrincipal
*
scriptPrin
=
nsContentUtils
:
:
ObjectPrincipal
(
aScopeChain
)
;
bool
subsumes
=
scriptPrin
-
>
Subsumes
(
aRequest
-
>
mOriginPrincipal
)
;
aOptions
-
>
setMutedErrors
(
!
subsumes
)
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
elementVal
(
cx
)
;
MOZ_ASSERT
(
aRequest
-
>
mElement
)
;
if
(
NS_SUCCEEDED
(
nsContentUtils
:
:
WrapNative
(
cx
aRequest
-
>
mElement
&
elementVal
true
)
)
)
{
MOZ_ASSERT
(
elementVal
.
isObject
(
)
)
;
aOptions
-
>
setElement
(
&
elementVal
.
toObject
(
)
)
;
}
}
nsresult
nsScriptLoader
:
:
EvaluateScript
(
nsScriptLoadRequest
*
aRequest
JS
:
:
SourceBufferHolder
&
aSrcBuf
)
{
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIContent
>
scriptContent
(
do_QueryInterface
(
aRequest
-
>
mElement
)
)
;
nsIDocument
*
ownerDoc
=
scriptContent
-
>
OwnerDoc
(
)
;
if
(
ownerDoc
!
=
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
NS_ASSERTION
(
scriptContent
"
no
content
-
what
is
default
script
-
type
?
"
)
;
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
GetScriptGlobalObject
(
)
;
if
(
!
globalObject
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIScriptContext
>
context
=
globalObject
-
>
GetScriptContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
JSVersion
version
=
JSVersion
(
aRequest
-
>
mJSVersion
)
;
if
(
version
=
=
JSVERSION_UNKNOWN
)
{
return
NS_OK
;
}
nsAutoMicroTask
mt
;
AutoEntryScript
entryScript
(
globalObject
"
<
script
>
element
"
true
context
-
>
GetNativeContext
(
)
)
;
entryScript
.
TakeOwnershipOfErrorReporting
(
)
;
JS
:
:
Rooted
<
JSObject
*
>
global
(
entryScript
.
cx
(
)
globalObject
-
>
GetGlobalJSObject
(
)
)
;
bool
oldProcessingScriptTag
=
context
-
>
GetProcessingScriptTag
(
)
;
context
-
>
SetProcessingScriptTag
(
true
)
;
nsresult
rv
;
{
AutoCurrentScriptUpdater
scriptUpdater
(
this
aRequest
-
>
mElement
)
;
Maybe
<
AutoCurrentScriptUpdater
>
masterScriptUpdater
;
nsCOMPtr
<
nsIDocument
>
master
=
mDocument
-
>
MasterDocument
(
)
;
if
(
master
!
=
mDocument
)
{
masterScriptUpdater
.
emplace
(
master
-
>
ScriptLoader
(
)
aRequest
-
>
mElement
)
;
}
JS
:
:
CompileOptions
options
(
entryScript
.
cx
(
)
)
;
FillCompileOptionsForRequest
(
entryScript
aRequest
global
&
options
)
;
rv
=
nsJSUtils
:
:
EvaluateString
(
entryScript
.
cx
(
)
aSrcBuf
global
options
aRequest
-
>
OffThreadTokenPtr
(
)
)
;
}
context
-
>
SetProcessingScriptTag
(
oldProcessingScriptTag
)
;
return
rv
;
}
void
nsScriptLoader
:
:
ProcessPendingRequestsAsync
(
)
{
if
(
mParserBlockingRequest
|
|
!
mPendingChildLoaders
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
NS_NewRunnableMethod
(
this
&
nsScriptLoader
:
:
ProcessPendingRequests
)
;
NS_DispatchToCurrentThread
(
ev
)
;
}
}
void
nsScriptLoader
:
:
ProcessPendingRequests
(
)
{
RefPtr
<
nsScriptLoadRequest
>
request
;
if
(
mParserBlockingRequest
&
&
mParserBlockingRequest
-
>
IsReadyToRun
(
)
&
&
ReadyToExecuteScripts
(
)
)
{
request
.
swap
(
mParserBlockingRequest
)
;
bool
offThreadCompiled
=
request
-
>
mProgress
=
=
nsScriptLoadRequest
:
:
Progress_DoneCompiling
;
UnblockParser
(
request
)
;
ProcessRequest
(
request
)
;
if
(
offThreadCompiled
)
{
mDocument
-
>
UnblockOnload
(
false
)
;
}
ContinueParserAsync
(
request
)
;
}
while
(
ReadyToExecuteScripts
(
)
&
&
!
mXSLTRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mXSLTRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
while
(
mEnabled
&
&
!
mLoadedAsyncRequests
.
isEmpty
(
)
)
{
request
=
mLoadedAsyncRequests
.
StealFirst
(
)
;
CompileOffThreadOrProcessRequest
(
request
)
;
}
while
(
mEnabled
&
&
!
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mNonAsyncExternalScriptInsertedRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
if
(
mDocumentParsingDone
&
&
mXSLTRequests
.
isEmpty
(
)
)
{
while
(
!
mDeferRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
getFirst
(
)
-
>
IsReadyToRun
(
)
)
{
request
=
mDeferRequests
.
StealFirst
(
)
;
ProcessRequest
(
request
)
;
}
}
while
(
!
mPendingChildLoaders
.
IsEmpty
(
)
&
&
ReadyToExecuteScripts
(
)
)
{
RefPtr
<
nsScriptLoader
>
child
=
mPendingChildLoaders
[
0
]
;
mPendingChildLoaders
.
RemoveElementAt
(
0
)
;
child
-
>
RemoveExecuteBlocker
(
)
;
}
if
(
mDocumentParsingDone
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
&
&
MaybeRemovedDeferRequests
(
)
)
{
return
ProcessPendingRequests
(
)
;
}
if
(
mDocumentParsingDone
&
&
mDocument
&
&
!
mParserBlockingRequest
&
&
mLoadingAsyncRequests
.
isEmpty
(
)
&
&
mLoadedAsyncRequests
.
isEmpty
(
)
&
&
mNonAsyncExternalScriptInsertedRequests
.
isEmpty
(
)
&
&
mXSLTRequests
.
isEmpty
(
)
&
&
mDeferRequests
.
isEmpty
(
)
)
{
mDocumentParsingDone
=
false
;
mDocument
-
>
UnblockOnload
(
true
)
;
}
}
bool
nsScriptLoader
:
:
ReadyToExecuteScripts
(
)
{
if
(
!
SelfReadyToExecuteScripts
(
)
)
{
return
false
;
}
for
(
nsIDocument
*
doc
=
mDocument
;
doc
;
doc
=
doc
-
>
GetParentDocument
(
)
)
{
nsScriptLoader
*
ancestor
=
doc
-
>
ScriptLoader
(
)
;
if
(
!
ancestor
-
>
SelfReadyToExecuteScripts
(
)
&
&
ancestor
-
>
AddPendingChildLoader
(
this
)
)
{
AddExecuteBlocker
(
)
;
return
false
;
}
}
if
(
mDocument
&
&
!
mDocument
-
>
IsMasterDocument
(
)
)
{
RefPtr
<
ImportManager
>
im
=
mDocument
-
>
ImportManager
(
)
;
RefPtr
<
ImportLoader
>
loader
=
im
-
>
Find
(
mDocument
)
;
MOZ_ASSERT
(
loader
"
How
can
we
have
an
import
document
without
a
loader
?
"
)
;
nsCOMPtr
<
nsINode
>
referrer
=
loader
-
>
GetMainReferrer
(
)
;
MOZ_ASSERT
(
referrer
"
There
has
to
be
a
main
referring
link
for
each
imports
"
)
;
RefPtr
<
ImportLoader
>
lastPred
=
im
-
>
GetNearestPredecessor
(
referrer
)
;
if
(
!
lastPred
)
{
return
true
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
lastPred
-
>
GetDocument
(
)
;
if
(
lastPred
-
>
IsBlocking
(
)
|
|
!
doc
|
|
(
doc
&
&
!
doc
-
>
ScriptLoader
(
)
-
>
SelfReadyToExecuteScripts
(
)
)
)
{
lastPred
-
>
AddBlockedScriptLoader
(
this
)
;
loader
-
>
SetBlockingPredecessor
(
lastPred
)
;
return
false
;
}
}
return
true
;
}
static
bool
DetectByteOrderMark
(
const
unsigned
char
*
aBytes
int32_t
aLen
nsCString
&
oCharset
)
{
if
(
aLen
<
2
)
return
false
;
switch
(
aBytes
[
0
]
)
{
case
0xEF
:
if
(
aLen
>
=
3
&
&
0xBB
=
=
aBytes
[
1
]
&
&
0xBF
=
=
aBytes
[
2
]
)
{
oCharset
.
AssignLiteral
(
"
UTF
-
8
"
)
;
}
break
;
case
0xFE
:
if
(
0xFF
=
=
aBytes
[
1
]
)
{
oCharset
.
AssignLiteral
(
"
UTF
-
16BE
"
)
;
}
break
;
case
0xFF
:
if
(
0xFE
=
=
aBytes
[
1
]
)
{
oCharset
.
AssignLiteral
(
"
UTF
-
16LE
"
)
;
}
break
;
}
return
!
oCharset
.
IsEmpty
(
)
;
}
nsresult
nsScriptLoader
:
:
ConvertToUTF16
(
nsIChannel
*
aChannel
const
uint8_t
*
aData
uint32_t
aLength
const
nsAString
&
aHintCharset
nsIDocument
*
aDocument
char16_t
*
&
aBufOut
size_t
&
aLengthOut
)
{
if
(
!
aLength
)
{
aBufOut
=
nullptr
;
aLengthOut
=
0
;
return
NS_OK
;
}
nsAutoCString
charset
;
nsCOMPtr
<
nsIUnicodeDecoder
>
unicodeDecoder
;
if
(
DetectByteOrderMark
(
aData
aLength
charset
)
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
&
&
aChannel
&
&
NS_SUCCEEDED
(
aChannel
-
>
GetContentCharset
(
charset
)
)
&
&
EncodingUtils
:
:
FindEncodingForLabel
(
charset
charset
)
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
&
&
EncodingUtils
:
:
FindEncodingForLabel
(
aHintCharset
charset
)
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
&
&
aDocument
)
{
charset
=
aDocument
-
>
GetDocumentCharacterSet
(
)
;
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
}
if
(
!
unicodeDecoder
)
{
unicodeDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
"
windows
-
1252
"
)
;
}
int32_t
unicodeLength
=
0
;
nsresult
rv
=
unicodeDecoder
-
>
GetMaxLength
(
reinterpret_cast
<
const
char
*
>
(
aData
)
aLength
&
unicodeLength
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aBufOut
=
static_cast
<
char16_t
*
>
(
js_malloc
(
unicodeLength
*
sizeof
(
char16_t
)
)
)
;
if
(
!
aBufOut
)
{
aLengthOut
=
0
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
aLengthOut
=
unicodeLength
;
rv
=
unicodeDecoder
-
>
Convert
(
reinterpret_cast
<
const
char
*
>
(
aData
)
(
int32_t
*
)
&
aLength
aBufOut
&
unicodeLength
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
aLengthOut
=
unicodeLength
;
if
(
NS_FAILED
(
rv
)
)
{
js_free
(
aBufOut
)
;
aBufOut
=
nullptr
;
aLengthOut
=
0
;
}
return
rv
;
}
nsresult
nsScriptLoader
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aChannelStatus
nsresult
aSRIStatus
mozilla
:
:
Vector
<
char16_t
>
&
aString
mozilla
:
:
dom
:
:
SRICheckDataVerifier
*
aSRIDataVerifier
)
{
nsScriptLoadRequest
*
request
=
static_cast
<
nsScriptLoadRequest
*
>
(
aContext
)
;
NS_ASSERTION
(
request
"
null
request
in
stream
complete
handler
"
)
;
NS_ENSURE_TRUE
(
request
NS_ERROR_FAILURE
)
;
nsresult
rv
=
NS_OK
;
if
(
!
request
-
>
mIntegrity
.
IsEmpty
(
)
&
&
NS_SUCCEEDED
(
(
rv
=
aSRIStatus
)
)
)
{
MOZ_ASSERT
(
aSRIDataVerifier
)
;
nsCOMPtr
<
nsIRequest
>
channelRequest
;
aLoader
-
>
GetRequest
(
getter_AddRefs
(
channelRequest
)
)
;
nsCOMPtr
<
nsIChannel
>
channel
;
channel
=
do_QueryInterface
(
channelRequest
)
;
if
(
NS_FAILED
(
aSRIDataVerifier
-
>
Verify
(
request
-
>
mIntegrity
channel
request
-
>
mCORSMode
mDocument
)
)
)
{
rv
=
NS_ERROR_SRI_CORRUPT
;
}
}
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
PrepareLoadedRequest
(
request
aLoader
aChannelStatus
aString
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_TRACKING_URI
)
{
nsCOMPtr
<
nsIContent
>
cont
=
do_QueryInterface
(
request
-
>
mElement
)
;
mDocument
-
>
AddBlockedTrackingNode
(
cont
)
;
}
if
(
request
-
>
mIsDefer
)
{
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mDeferRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
request
-
>
mIsAsync
)
{
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
request
-
>
mIsNonAsyncScriptInserted
)
{
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mNonAsyncExternalScriptInsertedRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
request
-
>
mIsXSLT
)
{
if
(
request
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mXSLTRequests
.
Steal
(
request
)
;
FireScriptAvailable
(
rv
req
)
;
}
}
else
if
(
mParserBlockingRequest
=
=
request
)
{
mParserBlockingRequest
=
nullptr
;
UnblockParser
(
request
)
;
FireScriptAvailable
(
rv
request
)
;
ContinueParserAsync
(
request
)
;
}
else
{
mPreloads
.
RemoveElement
(
request
PreloadRequestComparator
(
)
)
;
}
}
ProcessPendingRequests
(
)
;
return
NS_OK
;
}
void
nsScriptLoader
:
:
UnblockParser
(
nsScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
mElement
-
>
UnblockParser
(
)
;
}
void
nsScriptLoader
:
:
ContinueParserAsync
(
nsScriptLoadRequest
*
aParserBlockingRequest
)
{
aParserBlockingRequest
-
>
mElement
-
>
ContinueParserAsync
(
)
;
}
uint32_t
nsScriptLoader
:
:
NumberOfProcessors
(
)
{
if
(
mNumberOfProcessors
>
0
)
return
mNumberOfProcessors
;
int32_t
numProcs
=
PR_GetNumberOfProcessors
(
)
;
if
(
numProcs
>
0
)
mNumberOfProcessors
=
numProcs
;
return
mNumberOfProcessors
;
}
nsresult
nsScriptLoader
:
:
PrepareLoadedRequest
(
nsScriptLoadRequest
*
aRequest
nsIIncrementalStreamLoader
*
aLoader
nsresult
aStatus
mozilla
:
:
Vector
<
char16_t
>
&
aString
)
{
if
(
NS_FAILED
(
aStatus
)
)
{
return
aStatus
;
}
if
(
aRequest
-
>
IsCanceled
(
)
)
{
return
NS_BINDING_ABORTED
;
}
if
(
!
mDocument
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
req
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
rv
=
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
requestSucceeded
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
nsAutoCString
sourceMapURL
;
rv
=
httpChannel
-
>
GetResponseHeader
(
NS_LITERAL_CSTRING
(
"
X
-
SourceMap
"
)
sourceMapURL
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
aRequest
-
>
mHasSourceMapURL
=
true
;
aRequest
-
>
mSourceMapURL
=
NS_ConvertUTF8toUTF16
(
sourceMapURL
)
;
}
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
aRequest
-
>
mCORSMode
=
=
CORS_NONE
)
{
rv
=
nsContentUtils
:
:
GetSecurityManager
(
)
-
>
GetChannelResultPrincipal
(
channel
getter_AddRefs
(
aRequest
-
>
mOriginPrincipal
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
aString
.
empty
(
)
)
{
aRequest
-
>
mScriptTextLength
=
aString
.
length
(
)
;
aRequest
-
>
mScriptTextBuf
=
aString
.
extractRawBuffer
(
)
;
}
NS_ASSERTION
(
mDeferRequests
.
Contains
(
aRequest
)
|
|
mLoadingAsyncRequests
.
Contains
(
aRequest
)
|
|
mNonAsyncExternalScriptInsertedRequests
.
Contains
(
aRequest
)
|
|
mXSLTRequests
.
Contains
(
aRequest
)
|
|
mPreloads
.
Contains
(
aRequest
PreloadRequestComparator
(
)
)
|
|
mParserBlockingRequest
"
aRequest
should
be
pending
!
"
)
;
aRequest
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress_DoneLoading
;
if
(
aRequest
=
=
mParserBlockingRequest
&
&
(
NumberOfProcessors
(
)
>
1
)
)
{
nsresult
rv
=
AttemptAsyncScriptCompile
(
aRequest
)
;
if
(
rv
=
=
NS_OK
)
{
NS_ASSERTION
(
aRequest
-
>
mProgress
=
=
nsScriptLoadRequest
:
:
Progress_Compiling
"
Request
should
be
off
-
thread
compiling
now
.
"
)
;
return
NS_OK
;
}
if
(
rv
!
=
NS_ERROR_FAILURE
)
{
return
rv
;
}
}
if
(
aRequest
-
>
mIsAsync
)
{
MOZ_ASSERT
(
aRequest
-
>
isInList
(
)
)
;
if
(
aRequest
-
>
isInList
(
)
)
{
RefPtr
<
nsScriptLoadRequest
>
req
=
mLoadingAsyncRequests
.
Steal
(
aRequest
)
;
mLoadedAsyncRequests
.
AppendElement
(
req
)
;
}
}
return
NS_OK
;
}
void
nsScriptLoader
:
:
ParsingComplete
(
bool
aTerminated
)
{
if
(
mDeferEnabled
)
{
mDocumentParsingDone
=
true
;
}
mDeferEnabled
=
false
;
if
(
aTerminated
)
{
mDeferRequests
.
Clear
(
)
;
mLoadingAsyncRequests
.
Clear
(
)
;
mLoadedAsyncRequests
.
Clear
(
)
;
mNonAsyncExternalScriptInsertedRequests
.
Clear
(
)
;
mXSLTRequests
.
Clear
(
)
;
if
(
mParserBlockingRequest
)
{
mParserBlockingRequest
-
>
Cancel
(
)
;
mParserBlockingRequest
=
nullptr
;
}
}
ProcessPendingRequests
(
)
;
}
void
nsScriptLoader
:
:
PreloadURI
(
nsIURI
*
aURI
const
nsAString
&
aCharset
const
nsAString
&
aType
const
nsAString
&
aCrossOrigin
const
nsAString
&
aIntegrity
bool
aScriptFromHead
const
mozilla
:
:
net
:
:
ReferrerPolicy
aReferrerPolicy
)
{
if
(
!
mEnabled
|
|
!
mDocument
-
>
IsScriptEnabled
(
)
)
{
return
;
}
SRIMetadata
sriMetadata
;
if
(
!
aIntegrity
.
IsEmpty
(
)
)
{
MOZ_LOG
(
GetSriLog
(
)
mozilla
:
:
LogLevel
:
:
Debug
(
"
nsScriptLoader
:
:
PreloadURI
integrity
=
%
s
"
NS_ConvertUTF16toUTF8
(
aIntegrity
)
.
get
(
)
)
)
;
SRICheck
:
:
IntegrityMetadata
(
aIntegrity
mDocument
&
sriMetadata
)
;
}
RefPtr
<
nsScriptLoadRequest
>
request
=
new
nsScriptLoadRequest
(
nullptr
0
Element
:
:
StringToCORSMode
(
aCrossOrigin
)
sriMetadata
)
;
request
-
>
mURI
=
aURI
;
request
-
>
mIsInline
=
false
;
request
-
>
mProgress
=
nsScriptLoadRequest
:
:
Progress_Loading
;
request
-
>
mReferrerPolicy
=
aReferrerPolicy
;
nsresult
rv
=
StartLoad
(
request
aType
aScriptFromHead
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
PreloadInfo
*
pi
=
mPreloads
.
AppendElement
(
)
;
pi
-
>
mRequest
=
request
;
pi
-
>
mCharset
=
aCharset
;
}
void
nsScriptLoader
:
:
AddDeferRequest
(
nsScriptLoadRequest
*
aRequest
)
{
aRequest
-
>
mIsDefer
=
true
;
mDeferRequests
.
AppendElement
(
aRequest
)
;
if
(
mDeferEnabled
&
&
aRequest
=
=
mDeferRequests
.
getFirst
(
)
&
&
mDocument
&
&
!
mBlockingDOMContentLoaded
)
{
MOZ_ASSERT
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
nsIDocument
:
:
READYSTATE_LOADING
)
;
mBlockingDOMContentLoaded
=
true
;
mDocument
-
>
BlockDOMContentLoaded
(
)
;
}
}
bool
nsScriptLoader
:
:
MaybeRemovedDeferRequests
(
)
{
if
(
mDeferRequests
.
isEmpty
(
)
&
&
mDocument
&
&
mBlockingDOMContentLoaded
)
{
mBlockingDOMContentLoaded
=
false
;
mDocument
-
>
UnblockDOMContentLoaded
(
)
;
return
true
;
}
return
false
;
}
nsScriptLoadHandler
:
:
nsScriptLoadHandler
(
nsScriptLoader
*
aScriptLoader
nsScriptLoadRequest
*
aRequest
mozilla
:
:
dom
:
:
SRICheckDataVerifier
*
aSRIDataVerifier
)
:
mScriptLoader
(
aScriptLoader
)
mRequest
(
aRequest
)
mSRIDataVerifier
(
aSRIDataVerifier
)
mSRIStatus
(
NS_OK
)
mDecoder
(
)
mBuffer
(
)
{
}
nsScriptLoadHandler
:
:
~
nsScriptLoadHandler
(
)
{
}
NS_IMPL_ISUPPORTS
(
nsScriptLoadHandler
nsIIncrementalStreamLoaderObserver
)
NS_IMETHODIMP
nsScriptLoadHandler
:
:
OnIncrementalData
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
uint32_t
aDataLength
const
uint8_t
*
aData
uint32_t
*
aConsumedLength
)
{
if
(
mRequest
-
>
IsCanceled
(
)
)
{
*
aConsumedLength
=
aDataLength
;
return
NS_OK
;
}
if
(
!
EnsureDecoder
(
aLoader
aData
aDataLength
false
)
)
{
return
NS_OK
;
}
*
aConsumedLength
=
aDataLength
;
nsresult
rv
=
TryDecodeRawData
(
aData
aDataLength
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mSRIDataVerifier
&
&
NS_SUCCEEDED
(
mSRIStatus
)
)
{
mSRIStatus
=
mSRIDataVerifier
-
>
Update
(
aDataLength
aData
)
;
}
return
rv
;
}
nsresult
nsScriptLoadHandler
:
:
TryDecodeRawData
(
const
uint8_t
*
aData
uint32_t
aDataLength
bool
aEndOfStream
)
{
int32_t
srcLen
=
aDataLength
;
const
char
*
src
=
reinterpret_cast
<
const
char
*
>
(
aData
)
;
int32_t
dstLen
;
nsresult
rv
=
mDecoder
-
>
GetMaxLength
(
src
srcLen
&
dstLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
uint32_t
haveRead
=
mBuffer
.
length
(
)
;
uint32_t
capacity
=
haveRead
+
dstLen
;
if
(
!
mBuffer
.
reserve
(
capacity
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
rv
=
mDecoder
-
>
Convert
(
src
&
srcLen
mBuffer
.
begin
(
)
+
haveRead
&
dstLen
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
haveRead
+
=
dstLen
;
MOZ_ASSERT
(
haveRead
<
=
capacity
"
mDecoder
produced
more
data
than
expected
"
)
;
MOZ_ALWAYS_TRUE
(
mBuffer
.
resizeUninitialized
(
haveRead
)
)
;
return
NS_OK
;
}
bool
nsScriptLoadHandler
:
:
EnsureDecoder
(
nsIIncrementalStreamLoader
*
aLoader
const
uint8_t
*
aData
uint32_t
aDataLength
bool
aEndOfStream
)
{
if
(
mDecoder
)
{
return
true
;
}
nsAutoCString
charset
;
if
(
!
aEndOfStream
&
&
(
aDataLength
<
3
)
)
{
return
false
;
}
if
(
DetectByteOrderMark
(
aData
aDataLength
charset
)
)
{
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
nsCOMPtr
<
nsIRequest
>
req
;
nsresult
rv
=
aLoader
-
>
GetRequest
(
getter_AddRefs
(
req
)
)
;
NS_ASSERTION
(
req
"
StreamLoader
'
s
request
went
away
prematurely
"
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
req
)
;
if
(
channel
&
&
NS_SUCCEEDED
(
channel
-
>
GetContentCharset
(
charset
)
)
&
&
EncodingUtils
:
:
FindEncodingForLabel
(
charset
charset
)
)
{
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
nsAutoString
hintCharset
;
if
(
!
mRequest
-
>
IsPreload
(
)
)
{
mRequest
-
>
mElement
-
>
GetScriptCharset
(
hintCharset
)
;
}
else
{
nsTArray
<
nsScriptLoader
:
:
PreloadInfo
>
:
:
index_type
i
=
mScriptLoader
-
>
mPreloads
.
IndexOf
(
mRequest
0
nsScriptLoader
:
:
PreloadRequestComparator
(
)
)
;
NS_ASSERTION
(
i
!
=
mScriptLoader
-
>
mPreloads
.
NoIndex
"
Incorrect
preload
bookkeeping
"
)
;
hintCharset
=
mScriptLoader
-
>
mPreloads
[
i
]
.
mCharset
;
}
if
(
EncodingUtils
:
:
FindEncodingForLabel
(
hintCharset
charset
)
)
{
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
if
(
mScriptLoader
-
>
mDocument
)
{
charset
=
mScriptLoader
-
>
mDocument
-
>
GetDocumentCharacterSet
(
)
;
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
charset
=
"
windows
-
1252
"
;
mDecoder
=
EncodingUtils
:
:
DecoderForEncoding
(
charset
)
;
return
true
;
}
NS_IMETHODIMP
nsScriptLoadHandler
:
:
OnStreamComplete
(
nsIIncrementalStreamLoader
*
aLoader
nsISupports
*
aContext
nsresult
aStatus
uint32_t
aDataLength
const
uint8_t
*
aData
)
{
if
(
!
mRequest
-
>
IsCanceled
(
)
)
{
DebugOnly
<
bool
>
encoderSet
=
EnsureDecoder
(
aLoader
aData
aDataLength
true
)
;
MOZ_ASSERT
(
encoderSet
)
;
DebugOnly
<
nsresult
>
rv
=
TryDecodeRawData
(
aData
aDataLength
true
)
;
if
(
mSRIDataVerifier
&
&
NS_SUCCEEDED
(
mSRIStatus
)
)
{
mSRIStatus
=
mSRIDataVerifier
-
>
Update
(
aDataLength
aData
)
;
}
}
return
mScriptLoader
-
>
OnStreamComplete
(
aLoader
mRequest
aStatus
mSRIStatus
mBuffer
mSRIDataVerifier
)
;
}
