#
include
"
mozilla
/
ArrayUtils
.
h
"
#
ifdef
XP_WIN
#
undef
GetClassName
#
endif
#
include
"
jsapi
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
WrapperFactory
.
h
"
#
include
"
AccessCheck
.
h
"
#
include
"
XrayWrapper
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
xpcprivate
.
h
"
#
include
"
xpc_make_class
.
h
"
#
include
"
XPCWrapper
.
h
"
#
include
"
mozilla
/
DOMEventTargetHelper
.
h
"
#
include
"
mozilla
/
dom
/
RegisterBindings
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsDOMClassInfo
.
h
"
#
include
"
nsIDOMClassInfo
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsIComponentRegistrar
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsISupportsPrimitives
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
xptcall
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIDOMGlobalPropertyInitializer
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsScriptNameSpaceManager
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIDOMEventTarget
.
h
"
#
include
"
nsMemory
.
h
"
#
include
"
nsIEventListenerService
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCollectionBinding
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
mozilla
/
dom
/
BindingUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsIInterfaceInfoManager
.
h
"
#
ifdef
MOZ_TIME_MANAGER
#
include
"
TimeManager
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
DOMCLASSINFO_STANDARD_FLAGS
\
(
nsIClassInfo
:
:
MAIN_THREAD_ONLY
|
\
nsIClassInfo
:
:
DOM_OBJECT
|
\
nsIClassInfo
:
:
SINGLETON_CLASSINFO
)
#
ifdef
DEBUG
#
define
NS_DEFINE_CLASSINFO_DATA_DEBUG
(
_class
)
\
eDOMClassInfo_
#
#
_class
#
#
_id
#
else
#
define
NS_DEFINE_CLASSINFO_DATA_DEBUG
(
_class
)
#
endif
#
define
NS_DEFINE_CLASSINFO_DATA_HELPER
(
_class
_helper
_flags
)
\
{
nullptr
\
XPC_MAKE_CLASS_OPS
(
_flags
)
\
XPC_MAKE_CLASS
(
#
_class
_flags
\
&
sClassInfoData
[
eDOMClassInfo_
#
#
_class
#
#
_id
]
.
mClassOps
)
\
_helper
:
:
doCreate
\
nullptr
\
nullptr
\
nullptr
\
_flags
\
true
\
false
\
NS_DEFINE_CLASSINFO_DATA_DEBUG
(
_class
)
\
}
#
define
NS_DEFINE_CLASSINFO_DATA
(
_class
_helper
_flags
)
\
NS_DEFINE_CLASSINFO_DATA_HELPER
(
_class
_helper
_flags
)
nsIXPConnect
*
nsDOMClassInfo
:
:
sXPConnect
=
nullptr
;
bool
nsDOMClassInfo
:
:
sIsInitialized
=
false
;
jsid
nsDOMClassInfo
:
:
sConstructor_id
=
JSID_VOID
;
jsid
nsDOMClassInfo
:
:
sWrappedJSObject_id
=
JSID_VOID
;
static
inline
nsresult
SetParentToWindow
(
nsGlobalWindowInner
*
win
JSObject
*
*
parent
)
{
MOZ_ASSERT
(
win
)
;
*
parent
=
win
-
>
FastGetGlobalJSObject
(
)
;
if
(
MOZ_UNLIKELY
(
!
*
parent
)
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
nsDOMClassInfo
:
:
DefineStaticJSVals
(
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
xpc
:
:
UnprivilegedJunkScope
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
JSContext
*
cx
=
jsapi
.
cx
(
)
;
#
define
SET_JSID_TO_STRING
(
_id
_cx
_str
)
\
if
(
JSString
*
str
=
:
:
JS_AtomizeAndPinString
(
_cx
_str
)
)
\
_id
=
INTERNED_STRING_TO_JSID
(
_cx
str
)
;
\
else
\
return
NS_ERROR_OUT_OF_MEMORY
;
SET_JSID_TO_STRING
(
sConstructor_id
cx
"
constructor
"
)
;
SET_JSID_TO_STRING
(
sWrappedJSObject_id
cx
"
wrappedJSObject
"
)
;
return
NS_OK
;
}
bool
nsDOMClassInfo
:
:
ObjectIsNativeWrapper
(
JSContext
*
cx
JSObject
*
obj
)
{
return
xpc
:
:
WrapperFactory
:
:
IsXrayWrapper
(
obj
)
&
&
xpc
:
:
AccessCheck
:
:
wrapperSubsumes
(
obj
)
;
}
nsDOMClassInfo
:
:
nsDOMClassInfo
(
nsDOMClassInfoData
*
aData
)
:
mData
(
aData
)
{
}
NS_IMPL_ADDREF
(
nsDOMClassInfo
)
NS_IMPL_RELEASE
(
nsDOMClassInfo
)
NS_INTERFACE_MAP_BEGIN
(
nsDOMClassInfo
)
if
(
aIID
.
Equals
(
NS_GET_IID
(
nsXPCClassInfo
)
)
)
foundInterface
=
static_cast
<
nsIClassInfo
*
>
(
static_cast
<
nsXPCClassInfo
*
>
(
this
)
)
;
else
NS_INTERFACE_MAP_ENTRY
(
nsIXPCScriptable
)
NS_INTERFACE_MAP_ENTRY
(
nsIClassInfo
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIClassInfo
)
NS_INTERFACE_MAP_END
static
const
JSClass
sDOMConstructorProtoClass
=
{
"
DOM
Constructor
.
prototype
"
0
}
;
#
define
_DOM_CLASSINFO_MAP_BEGIN
(
_class
_ifptr
_has_class_if
)
\
{
\
nsDOMClassInfoData
&
d
=
sClassInfoData
[
eDOMClassInfo_
#
#
_class
#
#
_id
]
;
\
d
.
mProtoChainInterface
=
_ifptr
;
\
d
.
mHasClassInterface
=
_has_class_if
;
\
static
const
nsIID
*
interface_list
[
]
=
{
#
define
DOM_CLASSINFO_MAP_BEGIN
(
_class
_interface
)
\
_DOM_CLASSINFO_MAP_BEGIN
(
_class
&
NS_GET_IID
(
_interface
)
true
)
#
define
DOM_CLASSINFO_MAP_BEGIN_NO_CLASS_IF
(
_class
_interface
)
\
_DOM_CLASSINFO_MAP_BEGIN
(
_class
&
NS_GET_IID
(
_interface
)
false
)
#
define
DOM_CLASSINFO_MAP_ENTRY
(
_if
)
\
&
NS_GET_IID
(
_if
)
#
define
DOM_CLASSINFO_MAP_CONDITIONAL_ENTRY
(
_if
_cond
)
\
(
_cond
)
?
&
NS_GET_IID
(
_if
)
:
nullptr
#
define
DOM_CLASSINFO_MAP_END
\
nullptr
\
}
;
\
\
/
*
Compact
the
interface
list
*
/
\
size_t
count
=
ArrayLength
(
interface_list
)
;
\
/
*
count
is
the
number
of
array
entries
which
is
one
greater
than
the
*
/
\
/
*
number
of
interfaces
due
to
the
terminating
null
*
/
\
for
(
size_t
i
=
0
;
i
<
count
-
1
;
+
+
i
)
{
\
if
(
!
interface_list
[
i
]
)
{
\
/
*
We
are
moving
the
element
at
index
i
+
1
and
successors
*
/
\
/
*
so
we
must
move
only
count
-
(
i
+
1
)
elements
total
.
*
/
\
memmove
(
&
interface_list
[
i
]
&
interface_list
[
i
+
1
]
\
sizeof
(
nsIID
*
)
*
(
count
-
(
i
+
1
)
)
)
;
\
/
*
Make
sure
to
examine
the
new
pointer
we
ended
up
with
at
this
*
/
\
/
*
slot
since
it
may
be
null
too
*
/
\
-
-
i
;
\
-
-
count
;
\
}
\
}
\
\
d
.
mInterfaces
=
interface_list
;
\
}
nsresult
nsDOMClassInfo
:
:
Init
(
)
{
static_assert
(
sizeof
(
uintptr_t
)
=
=
sizeof
(
void
*
)
"
BAD
!
You
'
ll
need
to
adjust
the
size
of
uintptr_t
to
the
"
"
size
of
a
pointer
on
your
platform
.
"
)
;
NS_ENSURE_TRUE
(
!
sIsInitialized
NS_ERROR_ALREADY_INITIALIZED
)
;
nsScriptNameSpaceManager
*
nameSpaceManager
=
GetNameSpaceManager
(
)
;
NS_ENSURE_TRUE
(
nameSpaceManager
NS_ERROR_NOT_INITIALIZED
)
;
NS_ADDREF
(
sXPConnect
=
nsContentUtils
:
:
XPConnect
(
)
)
;
nsCOMPtr
<
nsIXPCFunctionThisTranslator
>
elt
=
new
nsEventListenerThisTranslator
(
)
;
sXPConnect
-
>
SetFunctionThisTranslator
(
NS_GET_IID
(
nsIDOMEventListener
)
elt
)
;
DefineStaticJSVals
(
)
;
sIsInitialized
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetInterfaces
(
uint32_t
*
aCount
nsIID
*
*
*
aArray
)
{
uint32_t
count
=
0
;
while
(
mData
-
>
mInterfaces
[
count
]
)
{
count
+
+
;
}
*
aCount
=
count
;
if
(
!
count
)
{
*
aArray
=
nullptr
;
return
NS_OK
;
}
*
aArray
=
static_cast
<
nsIID
*
*
>
(
moz_xmalloc
(
count
*
sizeof
(
nsIID
*
)
)
)
;
uint32_t
i
;
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
*
(
(
*
aArray
)
+
i
)
=
mData
-
>
mInterfaces
[
i
]
-
>
Clone
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetScriptableHelper
(
nsIXPCScriptable
*
*
_retval
)
{
nsCOMPtr
<
nsIXPCScriptable
>
rval
=
this
;
rval
.
forget
(
_retval
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetContractID
(
nsACString
&
aContractID
)
{
aContractID
.
SetIsVoid
(
true
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetClassDescription
(
nsACString
&
aClassDescription
)
{
return
GetClassName
(
aClassDescription
)
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetClassID
(
nsCID
*
*
aClassID
)
{
*
aClassID
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetClassIDNoAlloc
(
nsCID
*
aClassID
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetFlags
(
uint32_t
*
aFlags
)
{
*
aFlags
=
DOMCLASSINFO_STANDARD_FLAGS
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
GetClassName
(
nsACString
&
aClassName
)
{
aClassName
.
Assign
(
mData
-
>
mClass
.
name
)
;
return
NS_OK
;
}
uint32_t
nsDOMClassInfo
:
:
GetScriptableFlags
(
)
{
return
mData
-
>
mScriptableFlags
;
}
const
js
:
:
Class
*
nsDOMClassInfo
:
:
GetClass
(
)
{
return
&
mData
-
>
mClass
;
}
const
JSClass
*
nsDOMClassInfo
:
:
GetJSClass
(
)
{
return
Jsvalify
(
&
mData
-
>
mClass
)
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
PreCreate
(
nsISupports
*
nativeObj
JSContext
*
cx
JSObject
*
globalObj
JSObject
*
*
parentObj
)
{
*
parentObj
=
globalObj
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
Enumerate
(
nsIXPConnectWrappedNative
*
wrapper
JSContext
*
cx
JSObject
*
obj
bool
*
_retval
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
NewEnumerate
(
nsIXPConnectWrappedNative
*
wrapper
JSContext
*
cx
JSObject
*
obj
JS
:
:
AutoIdVector
&
properties
bool
*
_retval
)
{
NS_WARNING
(
"
nsDOMClassInfo
:
:
NewEnumerate
Don
'
t
call
me
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
Resolve
(
nsIXPConnectWrappedNative
*
wrapper
JSContext
*
cx
JSObject
*
aObj
jsid
aId
bool
*
resolvedp
bool
*
_retval
)
{
JS
:
:
Rooted
<
JSObject
*
>
obj
(
cx
aObj
)
;
JS
:
:
Rooted
<
jsid
>
id
(
cx
aId
)
;
if
(
id
!
=
sConstructor_id
)
{
*
resolvedp
=
false
;
return
NS_OK
;
}
JS
:
:
Rooted
<
JSObject
*
>
global
(
cx
:
:
JS_GetGlobalForObject
(
cx
obj
)
)
;
JS
:
:
Rooted
<
JS
:
:
PropertyDescriptor
>
desc
(
cx
)
;
if
(
!
JS_GetPropertyDescriptor
(
cx
global
mData
-
>
mClass
.
name
&
desc
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
desc
.
object
(
)
&
&
!
desc
.
hasGetterOrSetter
(
)
&
&
desc
.
value
(
)
.
isObject
(
)
)
{
if
(
!
:
:
JS_DefinePropertyById
(
cx
obj
id
desc
.
value
(
)
JSPROP_ENUMERATE
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
*
resolvedp
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
Finalize
(
nsIXPConnectWrappedNative
*
wrapper
JSFreeOp
*
fop
JSObject
*
obj
)
{
NS_WARNING
(
"
nsDOMClassInfo
:
:
Finalize
Don
'
t
call
me
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
Call
(
nsIXPConnectWrappedNative
*
wrapper
JSContext
*
cx
JSObject
*
obj
const
JS
:
:
CallArgs
&
args
bool
*
_retval
)
{
NS_WARNING
(
"
nsDOMClassInfo
:
:
Call
Don
'
t
call
me
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
Construct
(
nsIXPConnectWrappedNative
*
wrapper
JSContext
*
cx
JSObject
*
obj
const
JS
:
:
CallArgs
&
args
bool
*
_retval
)
{
NS_WARNING
(
"
nsDOMClassInfo
:
:
Construct
Don
'
t
call
me
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
HasInstance
(
nsIXPConnectWrappedNative
*
wrapper
JSContext
*
cx
JSObject
*
obj
JS
:
:
Handle
<
JS
:
:
Value
>
val
bool
*
bp
bool
*
_retval
)
{
NS_WARNING
(
"
nsDOMClassInfo
:
:
HasInstance
Don
'
t
call
me
!
"
)
;
return
NS_ERROR_UNEXPECTED
;
}
NS_IMETHODIMP
nsDOMClassInfo
:
:
PostCreatePrototype
(
JSContext
*
cx
JSObject
*
aProto
)
{
return
NS_OK
;
}
void
nsDOMClassInfo
:
:
ShutDown
(
)
{
sConstructor_id
=
JSID_VOID
;
sWrappedJSObject_id
=
JSID_VOID
;
NS_IF_RELEASE
(
sXPConnect
)
;
sIsInitialized
=
false
;
}
static
nsresult
LookupComponentsShim
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
nsPIDOMWindowInner
*
win
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
)
;
bool
nsWindowSH
:
:
NameStructEnabled
(
JSContext
*
aCx
nsGlobalWindowInner
*
aWin
const
nsAString
&
aName
const
nsGlobalNameStruct
&
aNameStruct
)
{
return
!
aName
.
EqualsLiteral
(
"
DOMConstructor
"
)
;
}
#
ifdef
RELEASE_OR_BETA
#
define
USE_CONTROLLERS_SHIM
#
endif
#
ifdef
USE_CONTROLLERS_SHIM
static
const
JSClass
ControllersShimClass
=
{
"
Controllers
"
0
}
;
static
const
JSClass
XULControllersShimClass
=
{
"
XULControllers
"
0
}
;
#
endif
nsresult
nsWindowSH
:
:
GlobalResolve
(
nsGlobalWindowInner
*
aWin
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
obj
JS
:
:
Handle
<
jsid
>
id
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
)
{
if
(
id
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_COMPONENTS
)
)
{
return
LookupComponentsShim
(
cx
obj
aWin
-
>
AsInner
(
)
desc
)
;
}
#
ifdef
USE_CONTROLLERS_SHIM
if
(
(
id
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS
)
|
|
id
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS_CLASS
)
)
&
&
!
xpc
:
:
IsXrayWrapper
(
obj
)
&
&
!
nsContentUtils
:
:
IsSystemPrincipal
(
nsContentUtils
:
:
ObjectPrincipal
(
obj
)
)
)
{
if
(
aWin
-
>
GetDoc
(
)
)
{
aWin
-
>
GetDoc
(
)
-
>
WarnOnceAbout
(
nsIDocument
:
:
eWindow_Cc_ontrollers
)
;
}
const
JSClass
*
clazz
;
if
(
id
=
=
XPCJSRuntime
:
:
Get
(
)
-
>
GetStringID
(
XPCJSContext
:
:
IDX_CONTROLLERS
)
)
{
clazz
=
&
XULControllersShimClass
;
}
else
{
clazz
=
&
ControllersShimClass
;
}
MOZ_ASSERT
(
JS_IsGlobalObject
(
obj
)
)
;
JS
:
:
Rooted
<
JSObject
*
>
shim
(
cx
JS_NewObject
(
cx
clazz
)
)
;
if
(
NS_WARN_IF
(
!
shim
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
FillPropertyDescriptor
(
desc
obj
JS
:
:
ObjectValue
(
*
shim
)
false
)
;
return
NS_OK
;
}
#
endif
nsScriptNameSpaceManager
*
nameSpaceManager
=
GetNameSpaceManager
(
)
;
NS_ENSURE_TRUE
(
nameSpaceManager
NS_ERROR_NOT_INITIALIZED
)
;
nsAutoJSString
name
;
if
(
!
name
.
init
(
cx
JSID_TO_STRING
(
id
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
const
char16_t
*
class_name
=
nullptr
;
const
nsGlobalNameStruct
*
name_struct
=
nameSpaceManager
-
>
LookupName
(
name
&
class_name
)
;
if
(
!
name_struct
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
name
.
Equals
(
class_name
)
)
;
NS_ENSURE_TRUE
(
class_name
NS_ERROR_UNEXPECTED
)
;
nsresult
rv
=
NS_OK
;
if
(
name_struct
-
>
mType
=
=
nsGlobalNameStruct
:
:
eTypeProperty
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
childWin
=
aWin
-
>
GetChildWindow
(
name
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsISupports
>
native
(
do_CreateInstance
(
name_struct
-
>
mCID
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
prop_val
(
cx
JS
:
:
UndefinedValue
(
)
)
;
nsCOMPtr
<
nsIDOMGlobalPropertyInitializer
>
gpi
(
do_QueryInterface
(
native
)
)
;
if
(
gpi
)
{
rv
=
gpi
-
>
Init
(
aWin
-
>
AsInner
(
)
&
prop_val
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
prop_val
.
isPrimitive
(
)
&
&
!
prop_val
.
isNull
(
)
)
{
rv
=
nsContentUtils
:
:
WrapNative
(
cx
native
&
prop_val
true
)
;
}
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
JS_WrapValue
(
cx
&
prop_val
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
FillPropertyDescriptor
(
desc
obj
prop_val
false
)
;
return
NS_OK
;
}
return
rv
;
}
struct
InterfaceShimEntry
{
const
char
*
geckoName
;
const
char
*
domName
;
}
;
const
InterfaceShimEntry
kInterfaceShimMap
[
]
=
{
{
"
nsIXMLHttpRequest
"
"
XMLHttpRequest
"
}
{
"
nsIDOMDOMException
"
"
DOMException
"
}
{
"
nsIDOMNode
"
"
Node
"
}
{
"
nsIDOMCSSPrimitiveValue
"
"
CSSPrimitiveValue
"
}
{
"
nsIDOMCSSRule
"
"
CSSRule
"
}
{
"
nsIDOMCSSValue
"
"
CSSValue
"
}
{
"
nsIDOMEvent
"
"
Event
"
}
{
"
nsIDOMNSEvent
"
"
Event
"
}
{
"
nsIDOMKeyEvent
"
"
KeyEvent
"
}
{
"
nsIDOMMouseEvent
"
"
MouseEvent
"
}
{
"
nsIDOMMouseScrollEvent
"
"
MouseScrollEvent
"
}
{
"
nsIDOMMutationEvent
"
"
MutationEvent
"
}
{
"
nsIDOMSimpleGestureEvent
"
"
SimpleGestureEvent
"
}
{
"
nsIDOMUIEvent
"
"
UIEvent
"
}
{
"
nsIDOMHTMLMediaElement
"
"
HTMLMediaElement
"
}
{
"
nsIDOMOfflineResourceList
"
"
OfflineResourceList
"
}
{
"
nsIDOMRange
"
"
Range
"
}
{
"
nsIDOMSVGLength
"
"
SVGLength
"
}
{
"
nsIDOMNodeFilter
"
"
NodeFilter
"
}
{
"
nsIDOMXPathResult
"
"
XPathResult
"
}
}
;
static
nsresult
LookupComponentsShim
(
JSContext
*
cx
JS
:
:
Handle
<
JSObject
*
>
global
nsPIDOMWindowInner
*
win
JS
:
:
MutableHandle
<
JS
:
:
PropertyDescriptor
>
desc
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
COMPONENTS_SHIM_ACCESSED_BY_CONTENT
true
)
;
nsCOMPtr
<
nsIDocument
>
doc
=
win
-
>
GetExtantDoc
(
)
;
if
(
doc
)
{
doc
-
>
WarnOnceAbout
(
nsIDocument
:
:
eComponents
true
)
;
}
AssertSameCompartment
(
cx
global
)
;
JS
:
:
Rooted
<
JSObject
*
>
components
(
cx
JS_NewPlainObject
(
cx
)
)
;
NS_ENSURE_TRUE
(
components
NS_ERROR_OUT_OF_MEMORY
)
;
JS
:
:
Rooted
<
JSObject
*
>
interfaces
(
cx
JS_NewPlainObject
(
cx
)
)
;
NS_ENSURE_TRUE
(
interfaces
NS_ERROR_OUT_OF_MEMORY
)
;
bool
ok
=
JS_DefineProperty
(
cx
components
"
interfaces
"
interfaces
JSPROP_ENUMERATE
|
JSPROP_PERMANENT
|
JSPROP_READONLY
)
;
NS_ENSURE_TRUE
(
ok
NS_ERROR_OUT_OF_MEMORY
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
kInterfaceShimMap
)
;
+
+
i
)
{
const
char
*
geckoName
=
kInterfaceShimMap
[
i
]
.
geckoName
;
const
char
*
domName
=
kInterfaceShimMap
[
i
]
.
domName
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
cx
JS
:
:
UndefinedValue
(
)
)
;
ok
=
JS_GetProperty
(
cx
global
domName
&
v
)
;
NS_ENSURE_TRUE
(
ok
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
!
v
.
isObject
(
)
)
{
NS_WARNING
(
"
Unable
to
find
interface
object
on
global
"
)
;
continue
;
}
ok
=
JS_DefineProperty
(
cx
interfaces
geckoName
v
JSPROP_ENUMERATE
|
JSPROP_PERMANENT
|
JSPROP_READONLY
)
;
NS_ENSURE_TRUE
(
ok
NS_ERROR_OUT_OF_MEMORY
)
;
}
FillPropertyDescriptor
(
desc
global
JS
:
:
ObjectValue
(
*
components
)
false
)
;
return
NS_OK
;
}
NS_INTERFACE_MAP_BEGIN
(
nsEventListenerThisTranslator
)
NS_INTERFACE_MAP_ENTRY
(
nsIXPCFunctionThisTranslator
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_ADDREF
(
nsEventListenerThisTranslator
)
NS_IMPL_RELEASE
(
nsEventListenerThisTranslator
)
NS_IMETHODIMP
nsEventListenerThisTranslator
:
:
TranslateThis
(
nsISupports
*
aInitialThis
nsISupports
*
*
_retval
)
{
nsCOMPtr
<
nsIDOMEvent
>
event
(
do_QueryInterface
(
aInitialThis
)
)
;
NS_ENSURE_TRUE
(
event
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
EventTarget
>
target
=
event
-
>
InternalDOMEvent
(
)
-
>
GetCurrentTarget
(
)
;
target
.
forget
(
_retval
)
;
return
NS_OK
;
}
