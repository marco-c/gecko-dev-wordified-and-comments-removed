#
ifndef
nsFrameMessageManager_h__
#
define
nsFrameMessageManager_h__
#
include
"
nsIMessageManager
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIPrincipal
.
h
"
#
include
"
nsIXPConnect
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsWeakPtr
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
dom
/
CallbackObject
.
h
"
#
include
"
mozilla
/
dom
/
SameProcessMessageQueue
.
h
"
#
include
"
mozilla
/
dom
/
ipc
/
StructuredCloneData
.
h
"
#
include
"
mozilla
/
jsipc
/
CpowHolder
.
h
"
class
nsFrameLoader
;
namespace
mozilla
{
namespace
dom
{
class
nsIContentParent
;
class
nsIContentChild
;
class
ChildProcessMessageManager
;
class
ChromeMessageSender
;
class
ClonedMessageData
;
class
MessageListener
;
class
MessageListenerManager
;
class
MessageManagerReporter
;
template
<
typename
T
>
class
Optional
;
namespace
ipc
{
static
const
uint32_t
kMinTelemetrySyncMessageManagerLatencyMs
=
1
;
enum
class
MessageManagerFlags
{
MM_NONE
=
0
MM_CHROME
=
1
MM_GLOBAL
=
2
MM_PROCESSMANAGER
=
4
MM_BROADCASTER
=
8
MM_OWNSCALLBACK
=
16
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
MessageManagerFlags
)
;
class
MessageManagerCallback
{
public
:
virtual
~
MessageManagerCallback
(
)
{
}
virtual
bool
DoLoadMessageManagerScript
(
const
nsAString
&
aURL
bool
aRunInGlobalScope
)
{
return
true
;
}
virtual
bool
DoSendBlockingMessage
(
JSContext
*
aCx
const
nsAString
&
aMessage
StructuredCloneData
&
aData
JS
:
:
Handle
<
JSObject
*
>
aCpows
nsIPrincipal
*
aPrincipal
nsTArray
<
StructuredCloneData
>
*
aRetVal
bool
aIsSync
)
{
return
true
;
}
virtual
nsresult
DoSendAsyncMessage
(
JSContext
*
aCx
const
nsAString
&
aMessage
StructuredCloneData
&
aData
JS
:
:
Handle
<
JSObject
*
>
aCpows
nsIPrincipal
*
aPrincipal
)
{
return
NS_OK
;
}
virtual
nsIMessageSender
*
GetProcessMessageManager
(
)
const
{
return
nullptr
;
}
virtual
nsresult
DoGetRemoteType
(
nsAString
&
aRemoteType
)
const
{
aRemoteType
.
Truncate
(
)
;
nsIMessageSender
*
parent
=
GetProcessMessageManager
(
)
;
if
(
parent
)
{
return
parent
-
>
GetRemoteType
(
aRemoteType
)
;
}
return
NS_OK
;
}
protected
:
bool
BuildClonedMessageDataForParent
(
nsIContentParent
*
aParent
StructuredCloneData
&
aData
ClonedMessageData
&
aClonedData
)
;
bool
BuildClonedMessageDataForChild
(
nsIContentChild
*
aChild
StructuredCloneData
&
aData
ClonedMessageData
&
aClonedData
)
;
}
;
void
UnpackClonedMessageDataForParent
(
const
ClonedMessageData
&
aClonedData
StructuredCloneData
&
aData
)
;
void
UnpackClonedMessageDataForChild
(
const
ClonedMessageData
&
aClonedData
StructuredCloneData
&
aData
)
;
}
typedef
CallbackObjectHolder
<
mozilla
:
:
dom
:
:
MessageListener
nsIMessageListener
>
MessageListenerHolder
;
}
}
struct
nsMessageListenerInfo
{
bool
operator
=
=
(
const
nsMessageListenerInfo
&
aOther
)
const
{
return
&
aOther
=
=
this
;
}
mozilla
:
:
dom
:
:
MessageListenerHolder
mStrongListener
;
nsWeakPtr
mWeakListener
;
bool
mListenWhenClosed
;
}
;
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
nsMessageListenerInfo
&
aField
const
char
*
aName
uint32_t
aFlags
=
0
)
{
ImplCycleCollectionTraverse
(
aCallback
aField
.
mStrongListener
aName
aFlags
)
;
ImplCycleCollectionTraverse
(
aCallback
aField
.
mWeakListener
aName
aFlags
)
;
}
class
MOZ_STACK_CLASS
SameProcessCpowHolder
:
public
mozilla
:
:
jsipc
:
:
CpowHolder
{
public
:
SameProcessCpowHolder
(
JS
:
:
RootingContext
*
aRootingCx
JS
:
:
Handle
<
JSObject
*
>
aObj
)
:
mObj
(
aRootingCx
aObj
)
{
}
virtual
bool
ToObject
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JSObject
*
>
aObjp
)
override
;
private
:
JS
:
:
Rooted
<
JSObject
*
>
mObj
;
}
;
class
nsFrameMessageManager
:
public
nsIContentFrameMessageManager
public
nsIMessageBroadcaster
public
nsIFrameScriptLoader
public
nsIProcessScriptLoader
{
friend
class
mozilla
:
:
dom
:
:
MessageManagerReporter
;
typedef
mozilla
:
:
dom
:
:
ipc
:
:
StructuredCloneData
StructuredCloneData
;
protected
:
typedef
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerFlags
MessageManagerFlags
;
nsFrameMessageManager
(
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerCallback
*
aCallback
MessageManagerFlags
aFlags
)
;
virtual
~
nsFrameMessageManager
(
)
;
public
:
explicit
nsFrameMessageManager
(
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerCallback
*
aCallback
)
:
nsFrameMessageManager
(
aCallback
MessageManagerFlags
:
:
MM_NONE
)
{
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS
(
nsFrameMessageManager
nsIContentFrameMessageManager
)
void
AddMessageListener
(
const
nsAString
&
aMessageName
mozilla
:
:
dom
:
:
MessageListener
&
aListener
bool
aListenWhenClosed
mozilla
:
:
ErrorResult
&
aError
)
;
void
RemoveMessageListener
(
const
nsAString
&
aMessageName
mozilla
:
:
dom
:
:
MessageListener
&
aListener
mozilla
:
:
ErrorResult
&
aError
)
;
void
AddWeakMessageListener
(
const
nsAString
&
aMessageName
mozilla
:
:
dom
:
:
MessageListener
&
aListener
mozilla
:
:
ErrorResult
&
aError
)
;
void
RemoveWeakMessageListener
(
const
nsAString
&
aMessageName
mozilla
:
:
dom
:
:
MessageListener
&
aListener
mozilla
:
:
ErrorResult
&
aError
)
;
void
SendAsyncMessage
(
JSContext
*
aCx
const
nsAString
&
aMessageName
JS
:
:
Handle
<
JS
:
:
Value
>
aObj
JS
:
:
Handle
<
JSObject
*
>
aObjects
nsIPrincipal
*
aPrincipal
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfers
mozilla
:
:
ErrorResult
&
aError
)
{
DispatchAsyncMessage
(
aCx
aMessageName
aObj
aObjects
aPrincipal
aTransfers
aError
)
;
}
already_AddRefed
<
nsIMessageSender
>
GetProcessMessageManager
(
mozilla
:
:
ErrorResult
&
aError
)
;
void
GetRemoteType
(
nsAString
&
aRemoteType
mozilla
:
:
ErrorResult
&
aError
)
const
;
void
SendSyncMessage
(
JSContext
*
aCx
const
nsAString
&
aMessageName
JS
:
:
Handle
<
JS
:
:
Value
>
aObj
JS
:
:
Handle
<
JSObject
*
>
aObjects
nsIPrincipal
*
aPrincipal
nsTArray
<
JS
:
:
Value
>
&
aResult
mozilla
:
:
ErrorResult
&
aError
)
{
SendMessage
(
aCx
aMessageName
aObj
aObjects
aPrincipal
true
aResult
aError
)
;
}
void
SendRpcMessage
(
JSContext
*
aCx
const
nsAString
&
aMessageName
JS
:
:
Handle
<
JS
:
:
Value
>
aObj
JS
:
:
Handle
<
JSObject
*
>
aObjects
nsIPrincipal
*
aPrincipal
nsTArray
<
JS
:
:
Value
>
&
aResult
mozilla
:
:
ErrorResult
&
aError
)
{
SendMessage
(
aCx
aMessageName
aObj
aObjects
aPrincipal
false
aResult
aError
)
;
}
void
GetInitialProcessData
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aInitialProcessData
mozilla
:
:
ErrorResult
&
aError
)
;
NS_DECL_NSIMESSAGELISTENERMANAGER
NS_DECL_NSIMESSAGESENDER
NS_DECL_NSIMESSAGEBROADCASTER
NS_DECL_NSISYNCMESSAGESENDER
NS_DECL_NSIMESSAGEMANAGERGLOBAL
NS_DECL_NSICONTENTFRAMEMESSAGEMANAGER
NS_DECL_NSIFRAMESCRIPTLOADER
NS_DECL_NSIPROCESSSCRIPTLOADER
static
mozilla
:
:
dom
:
:
ChromeMessageSender
*
NewProcessMessageManager
(
bool
aIsRemote
)
;
nsresult
ReceiveMessage
(
nsISupports
*
aTarget
nsFrameLoader
*
aTargetFrameLoader
const
nsAString
&
aMessage
bool
aIsSync
StructuredCloneData
*
aCloneData
mozilla
:
:
jsipc
:
:
CpowHolder
*
aCpows
nsIPrincipal
*
aPrincipal
nsTArray
<
StructuredCloneData
>
*
aRetVal
)
;
void
AddChildManager
(
mozilla
:
:
dom
:
:
MessageListenerManager
*
aManager
)
;
void
RemoveChildManager
(
mozilla
:
:
dom
:
:
MessageListenerManager
*
aManager
)
;
void
Disconnect
(
bool
aRemoveFromParent
=
true
)
;
void
Close
(
)
;
void
SetCallback
(
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerCallback
*
aCallback
)
;
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerCallback
*
GetCallback
(
)
{
return
mCallback
;
}
nsresult
DispatchAsyncMessage
(
const
nsAString
&
aMessageName
const
JS
:
:
Value
&
aJSON
const
JS
:
:
Value
&
aObjects
nsIPrincipal
*
aPrincipal
const
JS
:
:
Value
&
aTransfers
JSContext
*
aCx
uint8_t
aArgc
)
;
nsresult
DispatchAsyncMessageInternal
(
JSContext
*
aCx
const
nsAString
&
aMessage
StructuredCloneData
&
aData
JS
:
:
Handle
<
JSObject
*
>
aCpows
nsIPrincipal
*
aPrincipal
)
;
bool
IsGlobal
(
)
{
return
mGlobal
;
}
bool
IsBroadcaster
(
)
{
return
mIsBroadcaster
;
}
static
nsFrameMessageManager
*
GetParentProcessManager
(
)
{
return
sParentProcessManager
;
}
static
mozilla
:
:
dom
:
:
ChildProcessMessageManager
*
GetChildProcessManager
(
)
{
return
sChildProcessManager
;
}
static
void
SetChildProcessManager
(
mozilla
:
:
dom
:
:
ChildProcessMessageManager
*
aManager
)
{
sChildProcessManager
=
aManager
;
}
void
SetInitialProcessData
(
JS
:
:
HandleValue
aInitialData
)
;
void
LoadPendingScripts
(
)
;
protected
:
friend
class
MMListenerRemover
;
virtual
nsFrameMessageManager
*
GetParentManager
(
)
{
return
nullptr
;
}
virtual
void
ClearParentManager
(
bool
aRemove
)
{
}
void
DispatchAsyncMessage
(
JSContext
*
aCx
const
nsAString
&
aMessageName
JS
:
:
Handle
<
JS
:
:
Value
>
aObj
JS
:
:
Handle
<
JSObject
*
>
aObjects
nsIPrincipal
*
aPrincipal
JS
:
:
Handle
<
JS
:
:
Value
>
aTransfers
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
SendMessage
(
const
nsAString
&
aMessageName
JS
:
:
Handle
<
JS
:
:
Value
>
aJSON
JS
:
:
Handle
<
JS
:
:
Value
>
aObjects
nsIPrincipal
*
aPrincipal
JSContext
*
aCx
uint8_t
aArgc
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aRetval
bool
aIsSync
)
;
void
SendMessage
(
JSContext
*
aCx
const
nsAString
&
aMessageName
JS
:
:
Handle
<
JS
:
:
Value
>
aObj
JS
:
:
Handle
<
JSObject
*
>
aObjects
nsIPrincipal
*
aPrincipal
bool
aIsSync
nsTArray
<
JS
:
:
Value
>
&
aResult
mozilla
:
:
ErrorResult
&
aError
)
;
void
SendMessage
(
JSContext
*
aCx
const
nsAString
&
aMessageName
StructuredCloneData
&
aData
JS
:
:
Handle
<
JSObject
*
>
aObjects
nsIPrincipal
*
aPrincipal
bool
aIsSync
nsTArray
<
JS
:
:
Value
>
&
aResult
mozilla
:
:
ErrorResult
&
aError
)
;
nsresult
ReceiveMessage
(
nsISupports
*
aTarget
nsFrameLoader
*
aTargetFrameLoader
bool
aTargetClosed
const
nsAString
&
aMessage
bool
aIsSync
StructuredCloneData
*
aCloneData
mozilla
:
:
jsipc
:
:
CpowHolder
*
aCpows
nsIPrincipal
*
aPrincipal
nsTArray
<
StructuredCloneData
>
*
aRetVal
)
;
void
LoadScript
(
const
nsAString
&
aURL
bool
aAllowDelayedLoad
bool
aRunInGlobalScope
mozilla
:
:
ErrorResult
&
aError
)
;
void
RemoveDelayedScript
(
const
nsAString
&
aURL
)
;
nsresult
GetDelayedScripts
(
JSContext
*
aCx
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aList
)
;
void
GetDelayedScripts
(
JSContext
*
aCx
nsTArray
<
nsTArray
<
JS
:
:
Value
>
>
&
aList
mozilla
:
:
ErrorResult
&
aError
)
;
enum
ProcessCheckerType
{
PROCESS_CHECKER_PERMISSION
PROCESS_CHECKER_MANIFEST_URL
ASSERT_APP_HAS_PERMISSION
}
;
bool
AssertProcessInternal
(
ProcessCheckerType
aType
const
nsAString
&
aCapability
mozilla
:
:
ErrorResult
&
aError
)
;
nsClassHashtable
<
nsStringHashKey
nsAutoTObserverArray
<
nsMessageListenerInfo
1
>
>
mListeners
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
MessageListenerManager
>
>
mChildManagers
;
bool
mChrome
;
bool
mGlobal
;
bool
mIsProcessManager
;
bool
mIsBroadcaster
;
bool
mOwnsCallback
;
bool
mHandlingMessage
;
bool
mClosed
;
bool
mDisconnected
;
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerCallback
*
mCallback
;
nsAutoPtr
<
mozilla
:
:
dom
:
:
ipc
:
:
MessageManagerCallback
>
mOwnedCallback
;
nsTArray
<
nsString
>
mPendingScripts
;
nsTArray
<
bool
>
mPendingScriptsGlobalStates
;
JS
:
:
Heap
<
JS
:
:
Value
>
mInitialProcessData
;
void
LoadPendingScripts
(
nsFrameMessageManager
*
aManager
nsFrameMessageManager
*
aChildMM
)
;
public
:
static
nsFrameMessageManager
*
sParentProcessManager
;
static
nsFrameMessageManager
*
sSameProcessParentManager
;
static
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
*
sPendingSameProcessAsyncMessages
;
private
:
void
AddMessageListener
(
const
nsAString
&
aMessageName
mozilla
:
:
dom
:
:
MessageListenerHolder
&
&
aListener
bool
aListenWhenClosed
)
;
void
RemoveMessageListener
(
const
nsAString
&
aMessageName
const
mozilla
:
:
dom
:
:
MessageListenerHolder
&
aListener
)
;
static
mozilla
:
:
dom
:
:
ChildProcessMessageManager
*
sChildProcessManager
;
}
;
class
nsSameProcessAsyncMessageBase
{
public
:
typedef
mozilla
:
:
dom
:
:
ipc
:
:
StructuredCloneData
StructuredCloneData
;
nsSameProcessAsyncMessageBase
(
JS
:
:
RootingContext
*
aRootingCx
JS
:
:
Handle
<
JSObject
*
>
aCpows
)
;
nsresult
Init
(
const
nsAString
&
aMessage
StructuredCloneData
&
aData
nsIPrincipal
*
aPrincipal
)
;
void
ReceiveMessage
(
nsISupports
*
aTarget
nsFrameLoader
*
aTargetFrameLoader
nsFrameMessageManager
*
aManager
)
;
private
:
nsSameProcessAsyncMessageBase
(
const
nsSameProcessAsyncMessageBase
&
)
;
nsString
mMessage
;
StructuredCloneData
mData
;
JS
:
:
PersistentRooted
<
JSObject
*
>
mCpows
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
#
ifdef
DEBUG
bool
mCalledInit
;
#
endif
}
;
class
nsScriptCacheCleaner
;
struct
nsMessageManagerScriptHolder
{
nsMessageManagerScriptHolder
(
JSContext
*
aCx
JSScript
*
aScript
bool
aRunInGlobalScope
)
:
mScript
(
aCx
aScript
)
mRunInGlobalScope
(
aRunInGlobalScope
)
{
MOZ_COUNT_CTOR
(
nsMessageManagerScriptHolder
)
;
}
~
nsMessageManagerScriptHolder
(
)
{
MOZ_COUNT_DTOR
(
nsMessageManagerScriptHolder
)
;
}
bool
WillRunInGlobalScope
(
)
{
return
mRunInGlobalScope
;
}
JS
:
:
PersistentRooted
<
JSScript
*
>
mScript
;
bool
mRunInGlobalScope
;
}
;
class
nsMessageManagerScriptExecutor
{
public
:
static
void
PurgeCache
(
)
;
static
void
Shutdown
(
)
;
void
MarkScopesForCC
(
)
;
protected
:
friend
class
nsMessageManagerScriptCx
;
nsMessageManagerScriptExecutor
(
)
{
MOZ_COUNT_CTOR
(
nsMessageManagerScriptExecutor
)
;
}
~
nsMessageManagerScriptExecutor
(
)
{
MOZ_COUNT_DTOR
(
nsMessageManagerScriptExecutor
)
;
}
void
DidCreateGlobal
(
)
;
void
LoadScriptInternal
(
JS
:
:
Handle
<
JSObject
*
>
aGlobal
const
nsAString
&
aURL
bool
aRunInGlobalScope
)
;
void
TryCacheLoadAndCompileScript
(
const
nsAString
&
aURL
bool
aRunInGlobalScope
bool
aShouldCache
JS
:
:
MutableHandle
<
JSScript
*
>
aScriptp
)
;
void
TryCacheLoadAndCompileScript
(
const
nsAString
&
aURL
bool
aRunInGlobalScope
)
;
bool
InitChildGlobalInternal
(
const
nsACString
&
aID
)
;
virtual
bool
WrapGlobalObject
(
JSContext
*
aCx
JS
:
:
CompartmentOptions
&
aOptions
JS
:
:
MutableHandle
<
JSObject
*
>
aReflector
)
=
0
;
void
Trace
(
const
TraceCallbacks
&
aCallbacks
void
*
aClosure
)
;
void
Unlink
(
)
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
AutoTArray
<
JS
:
:
Heap
<
JSObject
*
>
2
>
mAnonymousGlobalScopes
;
static
nsDataHashtable
<
nsStringHashKey
nsMessageManagerScriptHolder
*
>
*
sCachedScripts
;
static
mozilla
:
:
StaticRefPtr
<
nsScriptCacheCleaner
>
sScriptCacheCleaner
;
}
;
class
nsScriptCacheCleaner
final
:
public
nsIObserver
{
~
nsScriptCacheCleaner
(
)
{
}
NS_DECL_ISUPPORTS
nsScriptCacheCleaner
(
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsSvc
)
{
obsSvc
-
>
AddObserver
(
this
"
message
-
manager
-
flush
-
caches
"
false
)
;
obsSvc
-
>
AddObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
}
}
NS_IMETHOD
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
override
{
if
(
strcmp
(
"
message
-
manager
-
flush
-
caches
"
aTopic
)
=
=
0
)
{
nsMessageManagerScriptExecutor
:
:
PurgeCache
(
)
;
}
else
if
(
strcmp
(
"
xpcom
-
shutdown
"
aTopic
)
=
=
0
)
{
nsMessageManagerScriptExecutor
:
:
Shutdown
(
)
;
}
return
NS_OK
;
}
}
;
#
endif
