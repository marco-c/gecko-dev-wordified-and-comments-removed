#
include
"
nsScreen
.
h
"
#
include
"
mozilla
/
GeckoBindings
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
widget
/
ScreenManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsScreen
:
:
nsScreen
(
nsPIDOMWindowInner
*
aWindow
)
:
DOMEventTargetHelper
(
aWindow
)
mScreenOrientation
(
new
ScreenOrientation
(
aWindow
this
)
)
{
}
nsScreen
:
:
~
nsScreen
(
)
=
default
;
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsScreen
)
NS_INTERFACE_MAP_END_INHERITING
(
DOMEventTargetHelper
)
NS_IMPL_ADDREF_INHERITED
(
nsScreen
DOMEventTargetHelper
)
NS_IMPL_RELEASE_INHERITED
(
nsScreen
DOMEventTargetHelper
)
NS_IMPL_CYCLE_COLLECTION_INHERITED
(
nsScreen
DOMEventTargetHelper
mScreenOrientation
)
int32_t
nsScreen
:
:
PixelDepth
(
)
{
if
(
ShouldResistFingerprinting
(
RFPTarget
:
:
ScreenPixelDepth
)
)
{
return
24
;
}
nsDeviceContext
*
context
=
GetDeviceContext
(
)
;
if
(
NS_WARN_IF
(
!
context
)
)
{
return
24
;
}
return
context
-
>
GetDepth
(
)
;
}
nsPIDOMWindowOuter
*
nsScreen
:
:
GetOuter
(
)
const
{
if
(
nsPIDOMWindowInner
*
inner
=
GetOwnerWindow
(
)
)
{
return
inner
-
>
GetOuterWindow
(
)
;
}
return
nullptr
;
}
nsDeviceContext
*
nsScreen
:
:
GetDeviceContext
(
)
const
{
return
nsLayoutUtils
:
:
GetDeviceContextForScreenInfo
(
GetOuter
(
)
)
;
}
CSSIntRect
nsScreen
:
:
GetRect
(
)
{
if
(
ShouldResistFingerprinting
(
RFPTarget
:
:
ScreenRect
)
)
{
return
GetTopWindowInnerRectForRFP
(
)
;
}
if
(
nsPIDOMWindowInner
*
owner
=
GetOwnerWindow
(
)
)
{
if
(
Document
*
doc
=
owner
-
>
GetExtantDoc
(
)
)
{
Maybe
<
CSSIntSize
>
deviceSize
=
nsGlobalWindowOuter
:
:
GetRDMDeviceSize
(
*
doc
)
;
if
(
deviceSize
.
isSome
(
)
)
{
const
CSSIntSize
&
size
=
deviceSize
.
value
(
)
;
return
{
0
0
size
.
width
size
.
height
}
;
}
}
}
nsDeviceContext
*
context
=
GetDeviceContext
(
)
;
if
(
NS_WARN_IF
(
!
context
)
)
{
return
{
}
;
}
return
CSSIntRect
:
:
FromAppUnitsRounded
(
context
-
>
GetRect
(
)
)
;
}
CSSIntRect
nsScreen
:
:
GetAvailRect
(
)
{
if
(
ShouldResistFingerprinting
(
RFPTarget
:
:
ScreenAvailRect
)
)
{
return
GetTopWindowInnerRectForRFP
(
)
;
}
if
(
ShouldResistFingerprinting
(
RFPTarget
:
:
ScreenAvailToResolution
)
)
{
nsDeviceContext
*
context
=
GetDeviceContext
(
)
;
if
(
NS_WARN_IF
(
!
context
)
)
{
return
{
}
;
}
return
nsRFPService
:
:
GetSpoofedScreenAvailSize
(
context
-
>
GetRect
(
)
context
-
>
GetFullZoom
(
)
IsFullscreen
(
)
)
;
}
if
(
nsPIDOMWindowInner
*
owner
=
GetOwnerWindow
(
)
)
{
if
(
Document
*
doc
=
owner
-
>
GetExtantDoc
(
)
)
{
Maybe
<
CSSIntSize
>
deviceSize
=
nsGlobalWindowOuter
:
:
GetRDMDeviceSize
(
*
doc
)
;
if
(
deviceSize
.
isSome
(
)
)
{
const
CSSIntSize
&
size
=
deviceSize
.
value
(
)
;
return
{
0
0
size
.
width
size
.
height
}
;
}
}
}
nsDeviceContext
*
context
=
GetDeviceContext
(
)
;
if
(
NS_WARN_IF
(
!
context
)
)
{
return
{
}
;
}
return
CSSIntRect
:
:
FromAppUnitsRounded
(
context
-
>
GetClientRect
(
)
)
;
}
bool
nsScreen
:
:
IsFullscreen
(
)
const
{
if
(
nsPIDOMWindowInner
*
owner
=
GetOwnerWindow
(
)
)
{
if
(
Document
*
doc
=
owner
-
>
GetExtantDoc
(
)
)
{
return
StyleDisplayMode
:
:
Fullscreen
=
=
Gecko_MediaFeatures_GetDisplayMode
(
doc
)
;
}
}
return
false
;
}
uint16_t
nsScreen
:
:
GetOrientationAngle
(
)
const
{
nsDeviceContext
*
context
=
GetDeviceContext
(
)
;
if
(
context
)
{
return
context
-
>
GetScreenOrientationAngle
(
)
;
}
RefPtr
<
widget
:
:
Screen
>
s
=
widget
:
:
ScreenManager
:
:
GetSingleton
(
)
.
GetPrimaryScreen
(
)
;
return
s
-
>
GetOrientationAngle
(
)
;
}
hal
:
:
ScreenOrientation
nsScreen
:
:
GetOrientationType
(
)
const
{
nsDeviceContext
*
context
=
GetDeviceContext
(
)
;
if
(
context
)
{
return
context
-
>
GetScreenOrientationType
(
)
;
}
RefPtr
<
widget
:
:
Screen
>
s
=
widget
:
:
ScreenManager
:
:
GetSingleton
(
)
.
GetPrimaryScreen
(
)
;
return
s
-
>
GetOrientationType
(
)
;
}
ScreenOrientation
*
nsScreen
:
:
Orientation
(
)
const
{
return
mScreenOrientation
;
}
void
nsScreen
:
:
GetMozOrientation
(
nsString
&
aOrientation
CallerType
aCallerType
)
const
{
switch
(
mScreenOrientation
-
>
DeviceType
(
aCallerType
)
)
{
case
OrientationType
:
:
Portrait_primary
:
aOrientation
.
AssignLiteral
(
"
portrait
-
primary
"
)
;
break
;
case
OrientationType
:
:
Portrait_secondary
:
aOrientation
.
AssignLiteral
(
"
portrait
-
secondary
"
)
;
break
;
case
OrientationType
:
:
Landscape_primary
:
aOrientation
.
AssignLiteral
(
"
landscape
-
primary
"
)
;
break
;
case
OrientationType
:
:
Landscape_secondary
:
aOrientation
.
AssignLiteral
(
"
landscape
-
secondary
"
)
;
break
;
default
:
MOZ_CRASH
(
"
Unacceptable
screen
orientation
type
.
"
)
;
}
}
JSObject
*
nsScreen
:
:
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
{
return
Screen_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
CSSIntRect
nsScreen
:
:
GetTopWindowInnerRectForRFP
(
)
{
if
(
nsPIDOMWindowInner
*
inner
=
GetOwnerWindow
(
)
)
{
if
(
BrowsingContext
*
bc
=
inner
-
>
GetBrowsingContext
(
)
)
{
CSSIntSize
size
=
bc
-
>
Top
(
)
-
>
GetTopInnerSizeForRFP
(
)
;
return
{
0
0
size
.
width
size
.
height
}
;
}
}
return
{
}
;
}
bool
nsScreen
:
:
ShouldResistFingerprinting
(
RFPTarget
aTarget
)
const
{
nsGlobalWindowInner
*
owner
=
GetOwnerWindow
(
)
;
return
owner
&
&
owner
-
>
ShouldResistFingerprinting
(
aTarget
)
;
}
