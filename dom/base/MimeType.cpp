#
include
"
MimeType
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsUnicharUtils
.
h
"
template
<
typename
char_type
>
mozilla
:
:
UniquePtr
<
TMimeType
<
char_type
>
>
TMimeType
<
char_type
>
:
:
Parse
(
const
nsTSubstring
<
char_type
>
&
aMimeType
)
{
const
char_type
*
pos
=
aMimeType
.
BeginReading
(
)
;
const
char_type
*
end
=
aMimeType
.
EndReading
(
)
;
while
(
pos
<
end
&
&
NS_IsHTTPWhitespace
(
*
pos
)
)
{
+
+
pos
;
}
if
(
pos
=
=
end
)
{
return
nullptr
;
}
while
(
end
>
pos
&
&
NS_IsHTTPWhitespace
(
*
(
end
-
1
)
)
)
{
-
-
end
;
}
const
char_type
*
typeStart
=
pos
;
while
(
pos
<
end
&
&
*
pos
!
=
'
/
'
)
{
if
(
!
NS_IsHTTPTokenPoint
(
*
pos
)
)
{
return
nullptr
;
}
+
+
pos
;
}
const
char_type
*
typeEnd
=
pos
;
if
(
typeStart
=
=
typeEnd
)
{
return
nullptr
;
}
if
(
pos
=
=
end
)
{
return
nullptr
;
}
+
+
pos
;
const
char_type
*
subtypeStart
=
pos
;
const
char_type
*
subtypeEnd
=
nullptr
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
if
(
!
NS_IsHTTPTokenPoint
(
*
pos
)
)
{
if
(
NS_IsHTTPWhitespace
(
*
pos
)
)
{
subtypeEnd
=
pos
;
+
+
pos
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
if
(
!
NS_IsHTTPWhitespace
(
*
pos
)
)
{
return
nullptr
;
}
+
+
pos
;
}
break
;
}
return
nullptr
;
}
+
+
pos
;
}
if
(
subtypeEnd
=
=
nullptr
)
{
subtypeEnd
=
pos
;
}
if
(
subtypeStart
=
=
subtypeEnd
)
{
return
nullptr
;
}
nsTString
<
char_type
>
type
;
nsTString
<
char_type
>
subtype
;
for
(
const
char_type
*
c
=
typeStart
;
c
<
typeEnd
;
+
+
c
)
{
type
.
Append
(
ToLowerCaseASCII
(
*
c
)
)
;
}
for
(
const
char_type
*
c
=
subtypeStart
;
c
<
subtypeEnd
;
+
+
c
)
{
subtype
.
Append
(
ToLowerCaseASCII
(
*
c
)
)
;
}
mozilla
:
:
UniquePtr
<
TMimeType
<
char_type
>
>
mimeType
(
mozilla
:
:
MakeUnique
<
TMimeType
<
char_type
>
>
(
type
subtype
)
)
;
while
(
pos
<
end
)
{
+
+
pos
;
while
(
pos
<
end
&
&
NS_IsHTTPWhitespace
(
*
pos
)
)
{
+
+
pos
;
}
const
char_type
*
namePos
=
pos
;
nsTString
<
char_type
>
paramName
;
bool
paramNameHadInvalidChars
=
false
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
&
&
*
pos
!
=
'
=
'
)
{
if
(
!
NS_IsHTTPTokenPoint
(
*
pos
)
)
{
paramNameHadInvalidChars
=
true
;
}
paramName
.
Append
(
ToLowerCaseASCII
(
*
pos
)
)
;
+
+
pos
;
}
if
(
*
pos
!
=
'
=
'
)
{
while
(
namePos
<
pos
&
&
NS_IsHTTPWhitespace
(
*
namePos
)
)
{
+
+
namePos
;
}
if
(
namePos
<
pos
&
&
ToLowerCaseASCII
(
*
namePos
)
=
=
'
b
'
&
&
+
+
namePos
<
pos
&
&
ToLowerCaseASCII
(
*
namePos
)
=
=
'
a
'
&
&
+
+
namePos
<
pos
&
&
ToLowerCaseASCII
(
*
namePos
)
=
=
'
s
'
&
&
+
+
namePos
<
pos
&
&
ToLowerCaseASCII
(
*
namePos
)
=
=
'
e
'
&
&
+
+
namePos
<
pos
&
&
ToLowerCaseASCII
(
*
namePos
)
=
=
'
6
'
&
&
+
+
namePos
<
pos
&
&
ToLowerCaseASCII
(
*
namePos
)
=
=
'
4
'
)
{
while
(
+
+
namePos
<
pos
&
&
NS_IsHTTPWhitespace
(
*
namePos
)
)
{
}
mimeType
-
>
mIsBase64
=
namePos
=
=
pos
;
}
}
if
(
pos
<
end
)
{
if
(
*
pos
=
=
'
;
'
)
{
continue
;
}
+
+
pos
;
}
if
(
pos
=
=
end
)
{
break
;
}
ParameterValue
paramValue
;
bool
paramValueHadInvalidChars
=
false
;
if
(
*
pos
=
=
'
"
'
)
{
+
+
pos
;
while
(
true
)
{
while
(
pos
<
end
&
&
*
pos
!
=
'
"
'
&
&
*
pos
!
=
'
\
\
'
)
{
if
(
!
NS_IsHTTPQuotedStringTokenPoint
(
*
pos
)
)
{
paramValueHadInvalidChars
=
true
;
}
if
(
!
NS_IsHTTPTokenPoint
(
*
pos
)
)
{
paramValue
.
mRequiresQuoting
=
true
;
}
paramValue
.
Append
(
*
pos
)
;
+
+
pos
;
}
if
(
pos
<
end
&
&
*
pos
=
=
'
\
\
'
)
{
+
+
pos
;
if
(
pos
<
end
)
{
if
(
!
NS_IsHTTPQuotedStringTokenPoint
(
*
pos
)
)
{
paramValueHadInvalidChars
=
true
;
}
if
(
!
NS_IsHTTPTokenPoint
(
*
pos
)
)
{
paramValue
.
mRequiresQuoting
=
true
;
}
paramValue
.
Append
(
*
pos
)
;
+
+
pos
;
continue
;
}
paramValue
.
Append
(
'
\
\
'
)
;
paramValue
.
mRequiresQuoting
=
true
;
}
break
;
}
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
+
+
pos
;
}
}
else
{
const
char_type
*
paramValueStart
=
pos
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
+
+
pos
;
}
const
char_type
*
paramValueLastChar
=
pos
-
1
;
while
(
paramValueLastChar
>
=
paramValueStart
&
&
NS_IsHTTPWhitespace
(
*
paramValueLastChar
)
)
{
-
-
paramValueLastChar
;
}
if
(
paramValueStart
>
paramValueLastChar
)
{
continue
;
}
for
(
const
char_type
*
c
=
paramValueStart
;
c
<
=
paramValueLastChar
;
+
+
c
)
{
if
(
!
NS_IsHTTPQuotedStringTokenPoint
(
*
c
)
)
{
paramValueHadInvalidChars
=
true
;
}
if
(
!
NS_IsHTTPTokenPoint
(
*
c
)
)
{
paramValue
.
mRequiresQuoting
=
true
;
}
paramValue
.
Append
(
*
c
)
;
}
}
if
(
!
paramName
.
IsEmpty
(
)
&
&
!
paramNameHadInvalidChars
&
&
!
paramValueHadInvalidChars
)
{
paramValue
=
mimeType
-
>
mParameters
.
LookupOrInsertWith
(
paramName
[
&
]
{
mimeType
-
>
mParameterNames
.
AppendElement
(
paramName
)
;
return
paramValue
;
}
)
;
}
}
return
mimeType
;
}
template
<
typename
char_type
>
void
TMimeType
<
char_type
>
:
:
Serialize
(
nsTSubstring
<
char_type
>
&
aOutput
)
const
{
aOutput
.
Assign
(
mType
)
;
aOutput
.
AppendLiteral
(
"
/
"
)
;
aOutput
.
Append
(
mSubtype
)
;
for
(
uint32_t
i
=
0
;
i
<
mParameterNames
.
Length
(
)
;
i
+
+
)
{
auto
name
=
mParameterNames
[
i
]
;
aOutput
.
AppendLiteral
(
"
;
"
)
;
aOutput
.
Append
(
name
)
;
aOutput
.
AppendLiteral
(
"
=
"
)
;
GetParameterValue
(
name
aOutput
true
)
;
}
}
template
<
typename
char_type
>
void
TMimeType
<
char_type
>
:
:
GetFullType
(
nsTSubstring
<
char_type
>
&
aOutput
)
const
{
aOutput
.
Assign
(
mType
)
;
aOutput
.
AppendLiteral
(
"
/
"
)
;
aOutput
.
Append
(
mSubtype
)
;
}
template
<
typename
char_type
>
bool
TMimeType
<
char_type
>
:
:
HasParameter
(
const
nsTSubstring
<
char_type
>
&
aName
)
const
{
return
mParameters
.
Get
(
aName
nullptr
)
;
}
template
<
typename
char_type
>
bool
TMimeType
<
char_type
>
:
:
GetParameterValue
(
const
nsTSubstring
<
char_type
>
&
aName
nsTSubstring
<
char_type
>
&
aOutput
bool
aAppend
)
const
{
if
(
!
aAppend
)
{
aOutput
.
Truncate
(
)
;
}
ParameterValue
value
;
if
(
!
mParameters
.
Get
(
aName
&
value
)
)
{
return
false
;
}
if
(
value
.
mRequiresQuoting
|
|
value
.
IsEmpty
(
)
)
{
aOutput
.
AppendLiteral
(
"
\
"
"
)
;
const
char_type
*
vcur
=
value
.
BeginReading
(
)
;
const
char_type
*
vend
=
value
.
EndReading
(
)
;
while
(
vcur
<
vend
)
{
if
(
*
vcur
=
=
'
"
'
|
|
*
vcur
=
=
'
\
\
'
)
{
aOutput
.
AppendLiteral
(
"
\
\
"
)
;
}
aOutput
.
Append
(
*
vcur
)
;
vcur
+
+
;
}
aOutput
.
AppendLiteral
(
"
\
"
"
)
;
}
else
{
aOutput
.
Append
(
value
)
;
}
return
true
;
}
template
<
typename
char_type
>
void
TMimeType
<
char_type
>
:
:
SetParameterValue
(
const
nsTSubstring
<
char_type
>
&
aName
const
nsTSubstring
<
char_type
>
&
aValue
)
{
mParameters
.
WithEntryHandle
(
aName
[
&
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
mParameterNames
.
AppendElement
(
aName
)
;
}
ParameterValue
value
;
value
.
Append
(
aValue
)
;
entry
.
InsertOrUpdate
(
std
:
:
move
(
value
)
)
;
}
)
;
}
template
mozilla
:
:
UniquePtr
<
TMimeType
<
char16_t
>
>
TMimeType
<
char16_t
>
:
:
Parse
(
const
nsTSubstring
<
char16_t
>
&
aMimeType
)
;
template
mozilla
:
:
UniquePtr
<
TMimeType
<
char
>
>
TMimeType
<
char
>
:
:
Parse
(
const
nsTSubstring
<
char
>
&
aMimeType
)
;
template
void
TMimeType
<
char16_t
>
:
:
Serialize
(
nsTSubstring
<
char16_t
>
&
aOutput
)
const
;
template
void
TMimeType
<
char
>
:
:
Serialize
(
nsTSubstring
<
char
>
&
aOutput
)
const
;
template
void
TMimeType
<
char16_t
>
:
:
GetFullType
(
nsTSubstring
<
char16_t
>
&
aOutput
)
const
;
template
void
TMimeType
<
char
>
:
:
GetFullType
(
nsTSubstring
<
char
>
&
aOutput
)
const
;
template
bool
TMimeType
<
char16_t
>
:
:
HasParameter
(
const
nsTSubstring
<
char16_t
>
&
aName
)
const
;
template
bool
TMimeType
<
char
>
:
:
HasParameter
(
const
nsTSubstring
<
char
>
&
aName
)
const
;
template
bool
TMimeType
<
char16_t
>
:
:
GetParameterValue
(
const
nsTSubstring
<
char16_t
>
&
aName
nsTSubstring
<
char16_t
>
&
aOutput
bool
aAppend
)
const
;
template
bool
TMimeType
<
char
>
:
:
GetParameterValue
(
const
nsTSubstring
<
char
>
&
aName
nsTSubstring
<
char
>
&
aOutput
bool
aAppend
)
const
;
template
void
TMimeType
<
char16_t
>
:
:
SetParameterValue
(
const
nsTSubstring
<
char16_t
>
&
aName
const
nsTSubstring
<
char16_t
>
&
aValue
)
;
template
void
TMimeType
<
char
>
:
:
SetParameterValue
(
const
nsTSubstring
<
char
>
&
aName
const
nsTSubstring
<
char
>
&
aValue
)
;
