#
include
"
MimeType
.
h
"
#
include
"
nsUnicharUtils
.
h
"
namespace
{
template
<
typename
char_type
>
static
inline
bool
IsHTTPTokenPoint
(
const
char_type
c
)
{
return
c
=
=
'
!
'
|
|
c
=
=
'
#
'
|
|
c
=
=
'
'
|
|
c
=
=
'
%
'
|
|
c
=
=
'
&
'
|
|
c
=
=
'
\
'
'
|
|
c
=
=
'
*
'
|
|
c
=
=
'
+
'
|
|
c
=
=
'
-
'
|
|
c
=
=
'
.
'
|
|
c
=
=
'
^
'
|
|
c
=
=
'
_
'
|
|
c
=
=
'
'
|
|
c
=
=
'
|
'
|
|
c
=
=
'
~
'
|
|
mozilla
:
:
IsAsciiAlphanumeric
(
c
)
;
}
template
<
typename
char_type
>
static
inline
bool
IsHTTPQuotedStringTokenPoint
(
const
char_type
c
)
{
return
c
=
=
0x9
|
|
(
c
>
=
'
'
&
&
c
<
=
'
~
'
)
|
|
mozilla
:
:
IsNonAsciiLatin1
(
c
)
;
}
}
template
<
typename
char_type
>
mozilla
:
:
UniquePtr
<
TMimeType
<
char_type
>
>
TMimeType
<
char_type
>
:
:
Parse
(
const
nsTSubstring
<
char_type
>
&
aMimeType
)
{
const
char_type
*
pos
=
aMimeType
.
BeginReading
(
)
;
const
char_type
*
end
=
aMimeType
.
EndReading
(
)
;
while
(
pos
<
end
&
&
mozilla
:
:
IsAsciiWhitespace
(
*
pos
)
)
{
+
+
pos
;
}
if
(
pos
=
=
end
)
{
return
nullptr
;
}
while
(
end
>
pos
&
&
mozilla
:
:
IsAsciiWhitespace
(
*
(
end
-
1
)
)
)
{
-
-
end
;
}
const
char_type
*
typeStart
=
pos
;
while
(
pos
<
end
&
&
*
pos
!
=
'
/
'
)
{
if
(
!
IsHTTPTokenPoint
(
*
pos
)
)
{
return
nullptr
;
}
+
+
pos
;
}
const
char_type
*
typeEnd
=
pos
;
if
(
typeStart
=
=
typeEnd
)
{
return
nullptr
;
}
if
(
pos
=
=
end
)
{
return
nullptr
;
}
+
+
pos
;
const
char_type
*
subtypeStart
=
pos
;
const
char_type
*
subtypeEnd
=
nullptr
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
if
(
!
IsHTTPTokenPoint
(
*
pos
)
)
{
if
(
mozilla
:
:
IsAsciiWhitespace
(
*
pos
)
)
{
subtypeEnd
=
pos
;
+
+
pos
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
if
(
!
mozilla
:
:
IsAsciiWhitespace
(
*
pos
)
)
{
return
nullptr
;
}
+
+
pos
;
}
break
;
}
else
{
return
nullptr
;
}
}
+
+
pos
;
}
if
(
subtypeEnd
=
=
nullptr
)
{
subtypeEnd
=
pos
;
}
if
(
subtypeStart
=
=
subtypeEnd
)
{
return
nullptr
;
}
nsTString
<
char_type
>
type
;
nsTString
<
char_type
>
subtype
;
for
(
const
char_type
*
c
=
typeStart
;
c
<
typeEnd
;
+
+
c
)
{
type
.
Append
(
ToLowerCaseASCII
(
*
c
)
)
;
}
for
(
const
char_type
*
c
=
subtypeStart
;
c
<
subtypeEnd
;
+
+
c
)
{
subtype
.
Append
(
ToLowerCaseASCII
(
*
c
)
)
;
}
mozilla
:
:
UniquePtr
<
TMimeType
<
char_type
>
>
mimeType
(
mozilla
:
:
MakeUnique
<
TMimeType
<
char_type
>
>
(
type
subtype
)
)
;
while
(
pos
<
end
)
{
+
+
pos
;
while
(
pos
<
end
&
&
mozilla
:
:
IsAsciiWhitespace
(
*
pos
)
)
{
+
+
pos
;
}
nsTString
<
char_type
>
paramName
;
bool
paramNameHadInvalidChars
=
false
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
&
&
*
pos
!
=
'
=
'
)
{
if
(
!
IsHTTPTokenPoint
(
*
pos
)
)
{
paramNameHadInvalidChars
=
true
;
}
paramName
.
Append
(
ToLowerCaseASCII
(
*
pos
)
)
;
+
+
pos
;
}
if
(
pos
<
end
)
{
if
(
*
pos
=
=
'
;
'
)
{
continue
;
}
+
+
pos
;
}
ParameterValue
paramValue
;
bool
paramValueHadInvalidChars
=
false
;
if
(
pos
<
end
)
{
if
(
*
pos
=
=
'
"
'
)
{
+
+
pos
;
while
(
true
)
{
while
(
pos
<
end
&
&
*
pos
!
=
'
"
'
&
&
*
pos
!
=
'
\
\
'
)
{
if
(
!
IsHTTPQuotedStringTokenPoint
(
*
pos
)
)
{
paramValueHadInvalidChars
=
true
;
}
if
(
!
IsHTTPTokenPoint
(
*
pos
)
)
{
paramValue
.
mRequiresQuoting
=
true
;
}
paramValue
.
Append
(
*
pos
)
;
+
+
pos
;
}
if
(
pos
<
end
&
&
*
pos
=
=
'
\
\
'
)
{
+
+
pos
;
if
(
pos
<
end
)
{
if
(
!
IsHTTPQuotedStringTokenPoint
(
*
pos
)
)
{
paramValueHadInvalidChars
=
true
;
}
if
(
!
IsHTTPTokenPoint
(
*
pos
)
)
{
paramValue
.
mRequiresQuoting
=
true
;
}
paramValue
.
Append
(
*
pos
)
;
+
+
pos
;
continue
;
}
paramValue
.
Append
(
'
\
\
'
)
;
paramValue
.
mRequiresQuoting
=
true
;
break
;
}
else
{
break
;
}
}
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
+
+
pos
;
}
}
else
{
const
char_type
*
paramValueStart
=
pos
;
while
(
pos
<
end
&
&
*
pos
!
=
'
;
'
)
{
if
(
!
IsHTTPQuotedStringTokenPoint
(
*
pos
)
)
{
paramValueHadInvalidChars
=
true
;
}
if
(
!
IsHTTPTokenPoint
(
*
pos
)
)
{
paramValue
.
mRequiresQuoting
=
true
;
}
+
+
pos
;
}
const
char_type
*
paramValueEnd
=
pos
-
1
;
while
(
paramValueEnd
>
=
paramValueStart
&
&
mozilla
:
:
IsAsciiWhitespace
(
*
paramValueEnd
)
)
{
-
-
paramValueEnd
;
}
for
(
const
char_type
*
c
=
paramValueStart
;
c
<
=
paramValueEnd
;
+
+
c
)
{
paramValue
.
Append
(
*
c
)
;
}
}
if
(
!
paramName
.
IsEmpty
(
)
&
&
!
paramValue
.
IsEmpty
(
)
&
&
!
paramNameHadInvalidChars
&
&
!
paramValueHadInvalidChars
&
&
!
mimeType
-
>
mParameters
.
Get
(
paramName
&
paramValue
)
)
{
mimeType
-
>
mParameters
.
Put
(
paramName
paramValue
)
;
mimeType
-
>
mParameterNames
.
AppendElement
(
paramName
)
;
}
}
}
return
mimeType
;
}
template
<
typename
char_type
>
void
TMimeType
<
char_type
>
:
:
Serialize
(
nsTSubstring
<
char_type
>
&
aOutput
)
const
{
aOutput
.
Assign
(
mType
)
;
aOutput
.
AppendLiteral
(
"
/
"
)
;
aOutput
.
Append
(
mSubtype
)
;
for
(
uint32_t
i
=
0
;
i
<
mParameterNames
.
Length
(
)
;
i
+
+
)
{
auto
name
=
mParameterNames
[
i
]
;
ParameterValue
value
;
mParameters
.
Get
(
name
&
value
)
;
aOutput
.
AppendLiteral
(
"
;
"
)
;
aOutput
.
Append
(
name
)
;
aOutput
.
AppendLiteral
(
"
=
"
)
;
if
(
value
.
mRequiresQuoting
)
{
aOutput
.
AppendLiteral
(
"
\
"
"
)
;
const
char_type
*
vcur
=
value
.
BeginReading
(
)
;
const
char_type
*
vend
=
value
.
EndReading
(
)
;
while
(
vcur
<
vend
)
{
if
(
*
vcur
=
=
'
"
'
|
|
*
vcur
=
=
'
\
\
'
)
{
aOutput
.
AppendLiteral
(
"
\
\
"
)
;
}
aOutput
.
Append
(
*
vcur
)
;
vcur
+
+
;
}
aOutput
.
AppendLiteral
(
"
\
"
"
)
;
}
else
{
aOutput
.
Append
(
value
)
;
}
}
}
template
mozilla
:
:
UniquePtr
<
TMimeType
<
char16_t
>
>
TMimeType
<
char16_t
>
:
:
Parse
(
const
nsTSubstring
<
char16_t
>
&
aMimeType
)
;
template
mozilla
:
:
UniquePtr
<
TMimeType
<
char
>
>
TMimeType
<
char
>
:
:
Parse
(
const
nsTSubstring
<
char
>
&
aMimeType
)
;
template
void
TMimeType
<
char16_t
>
:
:
Serialize
(
nsTSubstring
<
char16_t
>
&
aOutput
)
const
;
template
void
TMimeType
<
char
>
:
:
Serialize
(
nsTSubstring
<
char
>
&
aOutput
)
const
;
