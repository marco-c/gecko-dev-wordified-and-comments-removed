#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
<
inttypes
.
h
>
#
include
<
stdlib
.
h
>
#
include
<
string
.
h
>
#
include
<
algorithm
>
#
include
<
cstddef
>
#
include
<
cstdint
>
#
include
<
initializer_list
>
#
include
<
iterator
>
#
include
<
limits
>
#
include
<
type_traits
>
#
include
"
Attr
.
h
"
#
include
"
ErrorList
.
h
"
#
include
"
ExpandedPrincipal
.
h
"
#
include
"
MainThreadUtils
.
h
"
#
include
"
MobileViewportManager
.
h
"
#
include
"
NodeUbiReporting
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
StorageAccessPermissionRequest
.
h
"
#
include
"
ThirdPartyUtil
.
h
"
#
include
"
domstubs
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
mozAutoDocUpdate
.
h
"
#
include
"
mozIDOMWindow
.
h
"
#
include
"
mozIThirdPartyUtil
.
h
"
#
include
"
mozilla
/
AntiTrackingUtils
.
h
"
#
include
"
mozilla
/
ArrayIterator
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Base64
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
CSSEnabledState
.
h
"
#
include
"
mozilla
/
ContentBlockingAllowList
.
h
"
#
include
"
mozilla
/
ContentBlockingNotifier
.
h
"
#
include
"
mozilla
/
ContentBlockingUserInteraction
.
h
"
#
include
"
mozilla
/
ContentPrincipal
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
AttributeStyles
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
EditorBase
.
h
"
#
include
"
mozilla
/
EditorCommands
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventQueue
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
ExtensionPolicyService
.
h
"
#
include
"
mozilla
/
FullscreenChange
.
h
"
#
include
"
mozilla
/
GlobalStyleSheetCache
.
h
"
#
include
"
mozilla
/
MappedDeclarationsBuilder
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
IdentifierMapEntry
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
InternalMutationEvent
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MacroForEach
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MediaFeatureChange
.
h
"
#
include
"
mozilla
/
MediaManager
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
NullPrincipal
.
h
"
#
include
"
mozilla
/
OriginAttributes
.
h
"
#
include
"
mozilla
/
OwningNonNull
.
h
"
#
include
"
mozilla
/
PendingFullscreenEvent
.
h
"
#
include
"
mozilla
/
PermissionDelegateHandler
.
h
"
#
include
"
mozilla
/
PermissionManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PreloadHashKey
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellForwards
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
PseudoStyleType
.
h
"
#
include
"
mozilla
/
RefCountType
.
h
"
#
include
"
mozilla
/
RelativeTo
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
mozilla
/
SchedulerGroup
.
h
"
#
include
"
mozilla
/
ScrollTimelineAnimationTracker
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
mozilla
/
SMILTimeContainer
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Components
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
mozilla
/
ServoTypes
.
h
"
#
include
"
mozilla
/
SizeOfState
.
h
"
#
include
"
mozilla
/
Span
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticAnalysisFunctions
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_docshell
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StaticPrefs_full_screen_api
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_network
.
h
"
#
include
"
mozilla
/
StaticPrefs_page_load
.
h
"
#
include
"
mozilla
/
StaticPrefs_privacy
.
h
"
#
include
"
mozilla
/
StaticPrefs_security
.
h
"
#
include
"
mozilla
/
StaticPrefs_widget
.
h
"
#
include
"
mozilla
/
StaticPresData
.
h
"
#
include
"
mozilla
/
StorageAccess
.
h
"
#
include
"
mozilla
/
StoragePrincipalHelper
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
TelemetryHistogramEnums
.
h
"
#
include
"
mozilla
/
TelemetryScalarEnums
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
mozilla
/
URLDecorationStripper
.
h
"
#
include
"
mozilla
/
URLExtraData
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
mozilla
/
css
/
Rule
.
h
"
#
include
"
mozilla
/
css
/
SheetParsingMode
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
dom
/
BlobURLProtocolHandler
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContextGroup
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContextHelper
.
h
"
#
include
"
mozilla
/
dom
/
CDATASection
.
h
"
#
include
"
mozilla
/
dom
/
CSPDictionariesBinding
.
h
"
#
include
"
mozilla
/
dom
/
ChromeObserver
.
h
"
#
include
"
mozilla
/
dom
/
ClientInfo
.
h
"
#
include
"
mozilla
/
dom
/
ClientState
.
h
"
#
include
"
mozilla
/
dom
/
Comment
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
DOMImplementation
.
h
"
#
include
"
mozilla
/
dom
/
DOMIntersectionObserver
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
dom
/
DocumentBinding
.
h
"
#
include
"
mozilla
/
dom
/
DocumentFragment
.
h
"
#
include
"
mozilla
/
dom
/
DocumentL10n
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
DocumentType
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
ErrorEvent
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
EventListenerBinding
.
h
"
#
include
"
mozilla
/
dom
/
FailedCertSecurityInfoBinding
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicy
.
h
"
#
include
"
mozilla
/
dom
/
FeaturePolicyUtils
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
mozilla
/
dom
/
FromParser
.
h
"
#
include
"
mozilla
/
dom
/
HighlightRegistry
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAllCollection
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCollectionBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDialogElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFormElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLIFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLinkElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMetaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSharedElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
mozilla
/
dom
/
MediaQueryList
.
h
"
#
include
"
mozilla
/
dom
/
MediaSource
.
h
"
#
include
"
mozilla
/
dom
/
MutationObservers
.
h
"
#
include
"
mozilla
/
dom
/
NameSpaceConstants
.
h
"
#
include
"
mozilla
/
dom
/
Navigator
.
h
"
#
include
"
mozilla
/
dom
/
NetErrorInfoBinding
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
mozilla
/
dom
/
NodeIterator
.
h
"
#
include
"
mozilla
/
dom
/
PContentChild
.
h
"
#
include
"
mozilla
/
dom
/
PWindowGlobalChild
.
h
"
#
include
"
mozilla
/
dom
/
PageTransitionEvent
.
h
"
#
include
"
mozilla
/
dom
/
PageTransitionEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
PermissionMessageUtils
.
h
"
#
include
"
mozilla
/
dom
/
PostMessageEvent
.
h
"
#
include
"
mozilla
/
dom
/
ProcessingInstruction
.
h
"
#
include
"
mozilla
/
dom
/
Promise
.
h
"
#
include
"
mozilla
/
dom
/
PromiseNativeHandler
.
h
"
#
include
"
mozilla
/
dom
/
ResizeObserver
.
h
"
#
include
"
mozilla
/
dom
/
RustTypes
.
h
"
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGDocument
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGUseElement
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerContainer
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerDescriptor
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerManager
.
h
"
#
include
"
mozilla
/
dom
/
ShadowIncludingTreeIterator
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetApplicableStateChangeEvent
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetApplicableStateChangeEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetList
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetRemovedEvent
.
h
"
#
include
"
mozilla
/
dom
/
StyleSheetRemovedEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
TimeoutManager
.
h
"
#
include
"
mozilla
/
dom
/
ToggleEvent
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
dom
/
TreeOrderedArrayInlines
.
h
"
#
include
"
mozilla
/
dom
/
TreeWalker
.
h
"
#
include
"
mozilla
/
dom
/
URL
.
h
"
#
include
"
mozilla
/
dom
/
UseCounterMetrics
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
dom
/
WindowContext
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
#
include
"
mozilla
/
dom
/
WindowProxyHolder
.
h
"
#
include
"
mozilla
/
dom
/
WorkerDocumentListener
.
h
"
#
include
"
mozilla
/
dom
/
XPathEvaluator
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPContext
.
h
"
#
include
"
mozilla
/
dom
/
nsCSPUtils
.
h
"
#
include
"
mozilla
/
extensions
/
WebExtensionPolicy
.
h
"
#
include
"
mozilla
/
fallible
.
h
"
#
include
"
mozilla
/
gfx
/
BaseCoord
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
mozilla
/
gfx
/
Coord
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
gfx
/
ScaleFactor
.
h
"
#
include
"
mozilla
/
glean
/
GleanMetrics
.
h
"
#
include
"
mozilla
/
intl
/
LocaleService
.
h
"
#
include
"
mozilla
/
ipc
/
IdleSchedulerChild
.
h
"
#
include
"
mozilla
/
ipc
/
MessageChannel
.
h
"
#
include
"
mozilla
/
net
/
ChannelEventQueue
.
h
"
#
include
"
mozilla
/
net
/
CookieJarSettings
.
h
"
#
include
"
mozilla
/
net
/
NeckoChannelParams
.
h
"
#
include
"
mozilla
/
net
/
RequestContextService
.
h
"
#
include
"
nsAboutProtocolUtils
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsBaseHashtable
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsCSSPropertyID
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsCaseTreatment
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
nsCommandManager
.
h
"
#
include
"
nsCommandParams
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsContentPermissionHelper
.
h
"
#
include
"
nsContentSecurityUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsCycleCollectionNoteChild
.
h
"
#
include
"
nsCycleCollectionTraversalCallback
.
h
"
#
include
"
nsDOMAttributeMap
.
h
"
#
include
"
nsDOMCaretPosition
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsDOMString
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsDocShellLoadTypes
.
h
"
#
include
"
nsEffectiveTLDService
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsFrameLoaderOwner
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsHtml5Module
.
h
"
#
include
"
nsHtml5Parser
.
h
"
#
include
"
nsHtml5TreeOpExecutor
.
h
"
#
include
"
nsIAsyncShutdown
.
h
"
#
include
"
nsIAuthPrompt
.
h
"
#
include
"
nsIAuthPrompt2
.
h
"
#
include
"
nsIBFCacheEntry
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIBrowserChild
.
h
"
#
include
"
nsIBrowserUsage
.
h
"
#
include
"
nsICSSLoaderObserver
.
h
"
#
include
"
nsICategoryManager
.
h
"
#
include
"
nsICertOverrideService
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIContentPolicy
.
h
"
#
include
"
nsIContentSecurityPolicy
.
h
"
#
include
"
nsIContentSink
.
h
"
#
include
"
nsICookieJarSettings
.
h
"
#
include
"
nsICookieService
.
h
"
#
include
"
nsIDOMXULCommandDispatcher
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIDocumentActivity
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsIDocumentLoader
.
h
"
#
include
"
nsIDocumentLoaderFactory
.
h
"
#
include
"
nsIDocumentObserver
.
h
"
#
include
"
nsIDNSService
.
h
"
#
include
"
nsIEditingSession
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIEffectiveTLDService
.
h
"
#
include
"
nsIFile
.
h
"
#
include
"
nsIFileChannel
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
nsIHTMLCollection
.
h
"
#
include
"
nsIHttpChannel
.
h
"
#
include
"
nsIHttpChannelInternal
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsIInlineSpellChecker
.
h
"
#
include
"
nsIInputStreamChannel
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsIMultiPartChannel
.
h
"
#
include
"
nsIMutationObserver
.
h
"
#
include
"
nsINSSErrorsService
.
h
"
#
include
"
nsINamed
.
h
"
#
include
"
nsINodeList
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsIPermission
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
nsIPropertyBag2
.
h
"
#
include
"
nsIPublicKeyPinningService
.
h
"
#
include
"
nsIReferrerInfo
.
h
"
#
include
"
nsIRefreshURI
.
h
"
#
include
"
nsIRequest
.
h
"
#
include
"
nsIRequestContext
.
h
"
#
include
"
nsIRunnable
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsIScriptGlobalObject
.
h
"
#
include
"
nsIScriptSecurityManager
.
h
"
#
include
"
nsISecurityConsoleMessage
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISerialEventTarget
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsISiteSecurityService
.
h
"
#
include
"
nsISocketProvider
.
h
"
#
include
"
nsISpeculativeConnect
.
h
"
#
include
"
nsIStructuredCloneContainer
.
h
"
#
include
"
nsIThread
.
h
"
#
include
"
nsITimedChannel
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsITransportSecurityInfo
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
nsIVariant
.
h
"
#
include
"
nsIWeakReference
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsIX509Cert
.
h
"
#
include
"
nsIX509CertValidity
.
h
"
#
include
"
nsIXMLContentSink
.
h
"
#
include
"
nsIHTMLContentSink
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsImageLoadingContent
.
h
"
#
include
"
nsImportModule
.
h
"
#
include
"
nsLanguageAtomService
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsMimeTypes
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsPIDOMWindowInlines
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsPointerHashKeys
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStringFlags
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsStringIterator
.
h
"
#
include
"
nsStyleSheetService
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsWrapperCache
.
h
"
#
include
"
nsWrapperCacheInlines
.
h
"
#
include
"
nsXPCOMCID
.
h
"
#
include
"
nsXULAppAPI
.
h
"
#
include
"
prthread
.
h
"
#
include
"
prtime
.
h
"
#
include
"
prtypes
.
h
"
#
include
"
xpcpublic
.
h
"
#
include
"
encoding_rs
.
h
"
#
include
"
mozilla
/
dom
/
XULBroadcastManager
.
h
"
#
include
"
mozilla
/
dom
/
XULPersist
.
h
"
#
include
"
nsIAppWindow
.
h
"
#
include
"
nsXULPrototypeDocument
.
h
"
#
include
"
nsXULCommandDispatcher
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
define
XML_DECLARATION_BITS_DECLARATION_EXISTS
(
1
<
<
0
)
#
define
XML_DECLARATION_BITS_ENCODING_EXISTS
(
1
<
<
1
)
#
define
XML_DECLARATION_BITS_STANDALONE_EXISTS
(
1
<
<
2
)
#
define
XML_DECLARATION_BITS_STANDALONE_YES
(
1
<
<
3
)
#
define
NS_MAX_DOCUMENT_WRITE_DEPTH
20
mozilla
:
:
LazyLogModule
gPageCacheLog
(
"
PageCache
"
)
;
mozilla
:
:
LazyLogModule
gSHIPBFCacheLog
(
"
SHIPBFCache
"
)
;
mozilla
:
:
LazyLogModule
gTimeoutDeferralLog
(
"
TimeoutDefer
"
)
;
mozilla
:
:
LazyLogModule
gUseCountersLog
(
"
UseCounters
"
)
;
namespace
mozilla
{
namespace
dom
{
class
Document
:
:
HeaderData
{
public
:
HeaderData
(
nsAtom
*
aField
const
nsAString
&
aData
)
:
mField
(
aField
)
mData
(
aData
)
{
}
~
HeaderData
(
)
{
UniquePtr
<
HeaderData
>
next
=
std
:
:
move
(
mNext
)
;
while
(
next
)
{
next
=
std
:
:
move
(
next
-
>
mNext
)
;
}
}
RefPtr
<
nsAtom
>
mField
;
nsString
mData
;
UniquePtr
<
HeaderData
>
mNext
;
}
;
AutoTArray
<
Document
*
8
>
*
Document
:
:
sLoadingForegroundTopLevelContentDocument
=
nullptr
;
static
LazyLogModule
gDocumentLeakPRLog
(
"
DocumentLeak
"
)
;
static
LazyLogModule
gCspPRLog
(
"
CSP
"
)
;
LazyLogModule
gUserInteractionPRLog
(
"
UserInteraction
"
)
;
static
nsresult
GetHttpChannelHelper
(
nsIChannel
*
aChannel
nsIHttpChannel
*
*
aHttpChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
httpChannel
)
{
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIMultiPartChannel
>
multipart
=
do_QueryInterface
(
aChannel
)
;
if
(
!
multipart
)
{
*
aHttpChannel
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsIChannel
>
baseChannel
;
nsresult
rv
=
multipart
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
httpChannel
=
do_QueryInterface
(
baseChannel
)
;
httpChannel
.
forget
(
aHttpChannel
)
;
return
NS_OK
;
}
}
#
define
NAME_NOT_VALID
(
(
nsSimpleContentList
*
)
1
)
IdentifierMapEntry
:
:
IdentifierMapEntry
(
const
IdentifierMapEntry
:
:
DependentAtomOrString
*
aKey
)
:
mKey
(
aKey
?
*
aKey
:
nullptr
)
{
}
void
IdentifierMapEntry
:
:
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mIdentifierMap
mNameContentList
"
)
;
aCallback
-
>
NoteXPCOMChild
(
static_cast
<
nsINodeList
*
>
(
mNameContentList
)
)
;
if
(
mImageElement
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mIdentifierMap
mImageElement
element
"
)
;
nsIContent
*
imageElement
=
mImageElement
;
aCallback
-
>
NoteXPCOMChild
(
imageElement
)
;
}
}
bool
IdentifierMapEntry
:
:
IsEmpty
(
)
{
return
mIdContentList
-
>
IsEmpty
(
)
&
&
!
mNameContentList
&
&
!
mChangeCallbacks
&
&
!
mImageElement
;
}
bool
IdentifierMapEntry
:
:
HasNameElement
(
)
const
{
return
mNameContentList
&
&
mNameContentList
-
>
Length
(
)
!
=
0
;
}
void
IdentifierMapEntry
:
:
AddContentChangeCallback
(
Document
:
:
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
{
if
(
!
mChangeCallbacks
)
{
mChangeCallbacks
=
MakeUnique
<
nsTHashtable
<
ChangeCallbackEntry
>
>
(
)
;
}
ChangeCallback
cc
=
{
aCallback
aData
aForImage
}
;
mChangeCallbacks
-
>
PutEntry
(
cc
)
;
}
void
IdentifierMapEntry
:
:
RemoveContentChangeCallback
(
Document
:
:
IDTargetObserver
aCallback
void
*
aData
bool
aForImage
)
{
if
(
!
mChangeCallbacks
)
return
;
ChangeCallback
cc
=
{
aCallback
aData
aForImage
}
;
mChangeCallbacks
-
>
RemoveEntry
(
cc
)
;
if
(
mChangeCallbacks
-
>
Count
(
)
=
=
0
)
{
mChangeCallbacks
=
nullptr
;
}
}
void
IdentifierMapEntry
:
:
FireChangeCallbacks
(
Element
*
aOldElement
Element
*
aNewElement
bool
aImageOnly
)
{
if
(
!
mChangeCallbacks
)
return
;
for
(
auto
iter
=
mChangeCallbacks
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
IdentifierMapEntry
:
:
ChangeCallbackEntry
*
entry
=
iter
.
Get
(
)
;
if
(
entry
-
>
mKey
.
mForImage
?
(
mImageElement
&
&
!
aImageOnly
)
:
aImageOnly
)
{
continue
;
}
if
(
!
entry
-
>
mKey
.
mCallback
(
aOldElement
aNewElement
entry
-
>
mKey
.
mData
)
)
{
iter
.
Remove
(
)
;
}
}
}
void
IdentifierMapEntry
:
:
AddIdElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
"
Must
have
element
"
)
;
MOZ_ASSERT
(
!
mIdContentList
-
>
Contains
(
nullptr
)
"
Why
is
null
in
our
list
?
"
)
;
size_t
index
=
mIdContentList
.
Insert
(
*
aElement
)
;
if
(
index
=
=
0
)
{
Element
*
oldElement
=
mIdContentList
-
>
SafeElementAt
(
1
)
;
FireChangeCallbacks
(
oldElement
aElement
)
;
}
}
void
IdentifierMapEntry
:
:
RemoveIdElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
"
Missing
element
"
)
;
NS_ASSERTION
(
!
aElement
-
>
OwnerDoc
(
)
-
>
IsHTMLDocument
(
)
|
|
mIdContentList
-
>
Contains
(
aElement
)
"
Removing
id
entry
that
doesn
'
t
exist
"
)
;
Element
*
currentElement
=
mIdContentList
-
>
SafeElementAt
(
0
)
;
mIdContentList
.
RemoveElement
(
*
aElement
)
;
if
(
currentElement
=
=
aElement
)
{
FireChangeCallbacks
(
currentElement
mIdContentList
-
>
SafeElementAt
(
0
)
)
;
}
}
void
IdentifierMapEntry
:
:
SetImageElement
(
Element
*
aElement
)
{
Element
*
oldElement
=
GetImageIdElement
(
)
;
mImageElement
=
aElement
;
Element
*
newElement
=
GetImageIdElement
(
)
;
if
(
oldElement
!
=
newElement
)
{
FireChangeCallbacks
(
oldElement
newElement
true
)
;
}
}
void
IdentifierMapEntry
:
:
ClearAndNotify
(
)
{
Element
*
currentElement
=
mIdContentList
-
>
SafeElementAt
(
0
)
;
mIdContentList
.
Clear
(
)
;
if
(
currentElement
)
{
FireChangeCallbacks
(
currentElement
nullptr
)
;
}
mNameContentList
=
nullptr
;
if
(
mImageElement
)
{
SetImageElement
(
nullptr
)
;
}
mChangeCallbacks
=
nullptr
;
}
namespace
dom
{
class
SimpleHTMLCollection
final
:
public
nsSimpleContentList
public
nsIHTMLCollection
{
public
:
explicit
SimpleHTMLCollection
(
nsINode
*
aRoot
)
:
nsSimpleContentList
(
aRoot
)
{
}
NS_DECL_ISUPPORTS_INHERITED
virtual
nsINode
*
GetParentObject
(
)
override
{
return
nsSimpleContentList
:
:
GetParentObject
(
)
;
}
virtual
uint32_t
Length
(
)
override
{
return
nsSimpleContentList
:
:
Length
(
)
;
}
virtual
Element
*
GetElementAt
(
uint32_t
aIndex
)
override
{
return
mElements
.
SafeElementAt
(
aIndex
)
-
>
AsElement
(
)
;
}
virtual
Element
*
GetFirstNamedElement
(
const
nsAString
&
aName
bool
&
aFound
)
override
{
aFound
=
false
;
RefPtr
<
nsAtom
>
name
=
NS_Atomize
(
aName
)
;
for
(
uint32_t
i
=
0
;
i
<
mElements
.
Length
(
)
;
i
+
+
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mElements
[
i
]
)
;
Element
*
element
=
mElements
[
i
]
-
>
AsElement
(
)
;
if
(
element
-
>
GetID
(
)
=
=
name
|
|
(
element
-
>
HasName
(
)
&
&
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
=
=
name
)
)
{
aFound
=
true
;
return
element
;
}
}
return
nullptr
;
}
virtual
void
GetSupportedNames
(
nsTArray
<
nsString
>
&
aNames
)
override
{
AutoTArray
<
nsAtom
*
8
>
atoms
;
for
(
uint32_t
i
=
0
;
i
<
mElements
.
Length
(
)
;
i
+
+
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mElements
[
i
]
)
;
Element
*
element
=
mElements
[
i
]
-
>
AsElement
(
)
;
nsAtom
*
id
=
element
-
>
GetID
(
)
;
MOZ_ASSERT
(
id
!
=
nsGkAtoms
:
:
_empty
)
;
if
(
id
&
&
!
atoms
.
Contains
(
id
)
)
{
atoms
.
AppendElement
(
id
)
;
}
if
(
element
-
>
HasName
(
)
)
{
nsAtom
*
name
=
element
-
>
GetParsedAttr
(
nsGkAtoms
:
:
name
)
-
>
GetAtomValue
(
)
;
MOZ_ASSERT
(
name
&
&
name
!
=
nsGkAtoms
:
:
_empty
)
;
if
(
name
&
&
!
atoms
.
Contains
(
name
)
)
{
atoms
.
AppendElement
(
name
)
;
}
}
}
nsString
*
names
=
aNames
.
AppendElements
(
atoms
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
atoms
.
Length
(
)
;
i
+
+
)
{
atoms
[
i
]
-
>
ToString
(
names
[
i
]
)
;
}
}
virtual
JSObject
*
GetWrapperPreserveColorInternal
(
)
override
{
return
nsWrapperCache
:
:
GetWrapperPreserveColor
(
)
;
}
virtual
void
PreserveWrapperInternal
(
nsISupports
*
aScriptObjectHolder
)
override
{
nsWrapperCache
:
:
PreserveWrapper
(
aScriptObjectHolder
)
;
}
virtual
JSObject
*
WrapObject
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGivenProto
)
override
{
return
HTMLCollection_Binding
:
:
Wrap
(
aCx
this
aGivenProto
)
;
}
using
nsBaseContentList
:
:
Item
;
private
:
virtual
~
SimpleHTMLCollection
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
SimpleHTMLCollection
nsSimpleContentList
nsIHTMLCollection
)
}
void
IdentifierMapEntry
:
:
AddNameElement
(
nsINode
*
aNode
Element
*
aElement
)
{
if
(
!
mNameContentList
)
{
mNameContentList
=
new
dom
:
:
SimpleHTMLCollection
(
aNode
)
;
}
mNameContentList
-
>
AppendElement
(
aElement
)
;
}
void
IdentifierMapEntry
:
:
RemoveNameElement
(
Element
*
aElement
)
{
if
(
mNameContentList
)
{
mNameContentList
-
>
RemoveElement
(
aElement
)
;
}
}
bool
IdentifierMapEntry
:
:
HasIdElementExposedAsHTMLDocumentProperty
(
)
const
{
Element
*
idElement
=
GetIdElement
(
)
;
return
idElement
&
&
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
idElement
)
;
}
size_t
IdentifierMapEntry
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mKey
.
mString
.
SizeOfExcludingThisIfUnshared
(
aMallocSizeOf
)
;
}
class
SubDocMapEntry
:
public
PLDHashEntryHdr
{
public
:
dom
:
:
Element
*
mKey
;
dom
:
:
Document
*
mSubDocument
;
}
;
class
OnloadBlocker
final
:
public
nsIRequest
{
public
:
OnloadBlocker
(
)
=
default
;
NS_DECL_ISUPPORTS
NS_DECL_NSIREQUEST
private
:
~
OnloadBlocker
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
OnloadBlocker
nsIRequest
)
NS_IMETHODIMP
OnloadBlocker
:
:
GetName
(
nsACString
&
aResult
)
{
aResult
.
AssignLiteral
(
"
about
:
document
-
onload
-
blocker
"
)
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
IsPending
(
bool
*
_retval
)
{
*
_retval
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetStatus
(
nsresult
*
status
)
{
*
status
=
NS_OK
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
SetCanceledReason
(
const
nsACString
&
aReason
)
{
return
SetCanceledReasonImpl
(
aReason
)
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetCanceledReason
(
nsACString
&
aReason
)
{
return
GetCanceledReasonImpl
(
aReason
)
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
CancelWithReason
(
nsresult
aStatus
const
nsACString
&
aReason
)
{
return
CancelWithReasonImpl
(
aStatus
aReason
)
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
Cancel
(
nsresult
status
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
Suspend
(
void
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
Resume
(
void
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetLoadGroup
(
nsILoadGroup
*
*
aLoadGroup
)
{
*
aLoadGroup
=
nullptr
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
SetLoadGroup
(
nsILoadGroup
*
aLoadGroup
)
{
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetLoadFlags
(
nsLoadFlags
*
aLoadFlags
)
{
*
aLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
return
NS_OK
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
GetTRRMode
(
nsIRequest
:
:
TRRMode
*
aTRRMode
)
{
return
GetTRRModeImpl
(
aTRRMode
)
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
SetTRRMode
(
nsIRequest
:
:
TRRMode
aTRRMode
)
{
return
SetTRRModeImpl
(
aTRRMode
)
;
}
NS_IMETHODIMP
OnloadBlocker
:
:
SetLoadFlags
(
nsLoadFlags
aLoadFlags
)
{
return
NS_OK
;
}
namespace
dom
{
ExternalResourceMap
:
:
ExternalResourceMap
(
)
:
mHaveShutDown
(
false
)
{
}
Document
*
ExternalResourceMap
:
:
RequestResource
(
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
Document
*
aDisplayDocument
ExternalResourceLoad
*
*
aPendingLoad
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aRequestingNode
"
Must
have
a
node
"
)
;
MOZ_ASSERT
(
aReferrerInfo
"
Must
have
a
referrerInfo
"
)
;
*
aPendingLoad
=
nullptr
;
if
(
mHaveShutDown
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
clone
;
nsresult
rv
=
NS_GetURIWithoutRef
(
aURI
getter_AddRefs
(
clone
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
clone
)
{
return
nullptr
;
}
ExternalResource
*
resource
;
mMap
.
Get
(
clone
&
resource
)
;
if
(
resource
)
{
return
resource
-
>
mDocument
;
}
bool
loadStartSucceeded
=
mPendingLoads
.
WithEntryHandle
(
clone
[
&
]
(
auto
&
&
loadEntry
)
{
if
(
!
loadEntry
)
{
loadEntry
.
Insert
(
MakeRefPtr
<
PendingLoad
>
(
aDisplayDocument
)
)
;
if
(
NS_FAILED
(
loadEntry
.
Data
(
)
-
>
StartLoad
(
clone
aReferrerInfo
aRequestingNode
)
)
)
{
return
false
;
}
}
RefPtr
<
PendingLoad
>
load
(
loadEntry
.
Data
(
)
)
;
load
.
forget
(
aPendingLoad
)
;
return
true
;
}
)
;
if
(
!
loadStartSucceeded
)
{
AddExternalResource
(
clone
nullptr
nullptr
aDisplayDocument
)
;
}
return
nullptr
;
}
void
ExternalResourceMap
:
:
EnumerateResources
(
SubDocEnumFunc
aCallback
)
{
nsTArray
<
RefPtr
<
Document
>
>
docs
(
mMap
.
Count
(
)
)
;
for
(
const
auto
&
entry
:
mMap
.
Values
(
)
)
{
if
(
Document
*
doc
=
entry
-
>
mDocument
)
{
docs
.
AppendElement
(
doc
)
;
}
}
for
(
auto
&
doc
:
docs
)
{
if
(
aCallback
(
*
doc
)
=
=
CallState
:
:
Stop
)
{
return
;
}
}
}
void
ExternalResourceMap
:
:
Traverse
(
nsCycleCollectionTraversalCallback
*
aCallback
)
const
{
for
(
const
auto
&
entry
:
mMap
)
{
ExternalResourceMap
:
:
ExternalResource
*
resource
=
entry
.
GetWeak
(
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mExternalResourceMap
.
mMap
entry
"
"
-
>
mDocument
"
)
;
aCallback
-
>
NoteXPCOMChild
(
ToSupports
(
resource
-
>
mDocument
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mExternalResourceMap
.
mMap
entry
"
"
-
>
mViewer
"
)
;
aCallback
-
>
NoteXPCOMChild
(
resource
-
>
mViewer
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
*
aCallback
"
mExternalResourceMap
.
mMap
entry
"
"
-
>
mLoadGroup
"
)
;
aCallback
-
>
NoteXPCOMChild
(
resource
-
>
mLoadGroup
)
;
}
}
void
ExternalResourceMap
:
:
HideViewers
(
)
{
for
(
const
auto
&
entry
:
mMap
)
{
nsCOMPtr
<
nsIDocumentViewer
>
viewer
=
entry
.
GetData
(
)
-
>
mViewer
;
if
(
viewer
)
{
viewer
-
>
Hide
(
)
;
}
}
}
void
ExternalResourceMap
:
:
ShowViewers
(
)
{
for
(
const
auto
&
entry
:
mMap
)
{
nsCOMPtr
<
nsIDocumentViewer
>
viewer
=
entry
.
GetData
(
)
-
>
mViewer
;
if
(
viewer
)
{
viewer
-
>
Show
(
)
;
}
}
}
void
TransferShowingState
(
Document
*
aFromDoc
Document
*
aToDoc
)
{
MOZ_ASSERT
(
aFromDoc
&
&
aToDoc
"
transferring
showing
state
from
/
to
null
doc
"
)
;
if
(
aFromDoc
-
>
IsShowing
(
)
)
{
aToDoc
-
>
OnPageShow
(
true
nullptr
)
;
}
}
nsresult
ExternalResourceMap
:
:
AddExternalResource
(
nsIURI
*
aURI
nsIDocumentViewer
*
aViewer
nsILoadGroup
*
aLoadGroup
Document
*
aDisplayDocument
)
{
MOZ_ASSERT
(
aURI
"
Unexpected
call
"
)
;
MOZ_ASSERT
(
(
aViewer
&
&
aLoadGroup
)
|
|
(
!
aViewer
&
&
!
aLoadGroup
)
"
Must
have
both
or
neither
"
)
;
RefPtr
<
PendingLoad
>
load
;
mPendingLoads
.
Remove
(
aURI
getter_AddRefs
(
load
)
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
Document
>
doc
;
if
(
aViewer
)
{
doc
=
aViewer
-
>
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
Must
have
a
document
"
)
;
doc
-
>
SetDisplayDocument
(
aDisplayDocument
)
;
aViewer
-
>
SetSticky
(
false
)
;
rv
=
aViewer
-
>
Init
(
nullptr
nsIntRect
(
0
0
0
0
)
nullptr
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
rv
=
aViewer
-
>
Open
(
nullptr
nullptr
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
doc
=
nullptr
;
aViewer
=
nullptr
;
aLoadGroup
=
nullptr
;
}
}
ExternalResource
*
newResource
=
mMap
.
InsertOrUpdate
(
aURI
MakeUnique
<
ExternalResource
>
(
)
)
.
get
(
)
;
newResource
-
>
mDocument
=
doc
;
newResource
-
>
mViewer
=
aViewer
;
newResource
-
>
mLoadGroup
=
aLoadGroup
;
if
(
doc
)
{
if
(
nsPresContext
*
pc
=
doc
-
>
GetPresContext
(
)
)
{
pc
-
>
RecomputeBrowsingContextDependentData
(
)
;
}
TransferShowingState
(
aDisplayDocument
doc
)
;
}
const
nsTArray
<
nsCOMPtr
<
nsIObserver
>
>
&
obs
=
load
-
>
Observers
(
)
;
for
(
uint32_t
i
=
0
;
i
<
obs
.
Length
(
)
;
+
+
i
)
{
obs
[
i
]
-
>
Observe
(
ToSupports
(
doc
)
"
external
-
resource
-
document
-
created
"
nullptr
)
;
}
return
rv
;
}
NS_IMPL_ISUPPORTS
(
ExternalResourceMap
:
:
PendingLoad
nsIStreamListener
nsIRequestObserver
)
NS_IMETHODIMP
ExternalResourceMap
:
:
PendingLoad
:
:
OnStartRequest
(
nsIRequest
*
aRequest
)
{
ExternalResourceMap
&
map
=
mDisplayDocument
-
>
ExternalResourceMap
(
)
;
if
(
map
.
HaveShutDown
(
)
)
{
return
NS_BINDING_ABORTED
;
}
nsCOMPtr
<
nsIDocumentViewer
>
viewer
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsresult
rv
=
SetupViewer
(
aRequest
getter_AddRefs
(
viewer
)
getter_AddRefs
(
loadGroup
)
)
;
nsresult
rv2
=
map
.
AddExternalResource
(
mURI
viewer
loadGroup
mDisplayDocument
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
NS_FAILED
(
rv2
)
)
{
mTargetListener
=
nullptr
;
return
rv2
;
}
return
mTargetListener
-
>
OnStartRequest
(
aRequest
)
;
}
nsresult
ExternalResourceMap
:
:
PendingLoad
:
:
SetupViewer
(
nsIRequest
*
aRequest
nsIDocumentViewer
*
*
aViewer
nsILoadGroup
*
*
aLoadGroup
)
{
MOZ_ASSERT
(
!
mTargetListener
"
Unexpected
call
to
OnStartRequest
"
)
;
*
aViewer
=
nullptr
;
*
aLoadGroup
=
nullptr
;
nsCOMPtr
<
nsIChannel
>
chan
(
do_QueryInterface
(
aRequest
)
)
;
NS_ENSURE_TRUE
(
chan
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
aRequest
)
)
;
if
(
httpChannel
)
{
bool
requestSucceeded
;
if
(
NS_FAILED
(
httpChannel
-
>
GetRequestSucceeded
(
&
requestSucceeded
)
)
|
|
!
requestSucceeded
)
{
return
NS_BINDING_ABORTED
;
}
}
nsAutoCString
type
;
chan
-
>
GetContentType
(
type
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
chan
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
nsCOMPtr
<
nsILoadGroup
>
newLoadGroup
=
do_CreateInstance
(
NS_LOADGROUP_CONTRACTID
)
;
NS_ENSURE_TRUE
(
newLoadGroup
NS_ERROR_OUT_OF_MEMORY
)
;
newLoadGroup
-
>
SetLoadGroup
(
loadGroup
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
callbacks
;
loadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
callbacks
)
)
;
nsCOMPtr
<
nsIInterfaceRequestor
>
newCallbacks
=
new
LoadgroupCallbacks
(
callbacks
)
;
newLoadGroup
-
>
SetNotificationCallbacks
(
newCallbacks
)
;
nsCOMPtr
<
nsICategoryManager
>
catMan
=
do_GetService
(
NS_CATEGORYMANAGER_CONTRACTID
)
;
NS_ENSURE_TRUE
(
catMan
NS_ERROR_NOT_AVAILABLE
)
;
nsCString
contractId
;
nsresult
rv
=
catMan
-
>
GetCategoryEntry
(
"
Gecko
-
Content
-
Viewers
"
type
contractId
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIDocumentLoaderFactory
>
docLoaderFactory
=
do_GetService
(
contractId
.
get
(
)
)
;
NS_ENSURE_TRUE
(
docLoaderFactory
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIDocumentViewer
>
viewer
;
nsCOMPtr
<
nsIStreamListener
>
listener
;
rv
=
docLoaderFactory
-
>
CreateInstance
(
"
external
-
resource
"
chan
newLoadGroup
type
nullptr
nullptr
getter_AddRefs
(
listener
)
getter_AddRefs
(
viewer
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_TRUE
(
viewer
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsIParser
>
parser
=
do_QueryInterface
(
listener
)
;
if
(
!
parser
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsIContentSink
*
sink
=
parser
-
>
GetContentSink
(
)
;
nsCOMPtr
<
nsIXMLContentSink
>
xmlSink
=
do_QueryInterface
(
sink
)
;
if
(
!
xmlSink
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
listener
.
swap
(
mTargetListener
)
;
viewer
.
forget
(
aViewer
)
;
newLoadGroup
.
forget
(
aLoadGroup
)
;
return
NS_OK
;
}
NS_IMETHODIMP
ExternalResourceMap
:
:
PendingLoad
:
:
OnDataAvailable
(
nsIRequest
*
aRequest
nsIInputStream
*
aStream
uint64_t
aOffset
uint32_t
aCount
)
{
NS_ENSURE_TRUE
(
mTargetListener
NS_ERROR_FAILURE
)
;
if
(
mDisplayDocument
-
>
ExternalResourceMap
(
)
.
HaveShutDown
(
)
)
{
return
NS_BINDING_ABORTED
;
}
return
mTargetListener
-
>
OnDataAvailable
(
aRequest
aStream
aOffset
aCount
)
;
}
NS_IMETHODIMP
ExternalResourceMap
:
:
PendingLoad
:
:
OnStopRequest
(
nsIRequest
*
aRequest
nsresult
aStatus
)
{
if
(
mTargetListener
)
{
nsCOMPtr
<
nsIStreamListener
>
listener
;
mTargetListener
.
swap
(
listener
)
;
return
listener
-
>
OnStopRequest
(
aRequest
aStatus
)
;
}
return
NS_OK
;
}
nsresult
ExternalResourceMap
:
:
PendingLoad
:
:
StartLoad
(
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aRequestingNode
"
Must
have
a
node
"
)
;
MOZ_ASSERT
(
aReferrerInfo
"
Must
have
a
referrerInfo
"
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
aRequestingNode
-
>
OwnerDoc
(
)
-
>
GetDocumentLoadGroup
(
)
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIChannel
>
channel
;
rv
=
NS_NewChannel
(
getter_AddRefs
(
channel
)
aURI
aRequestingNode
nsILoadInfo
:
:
SEC_REQUIRE_SAME_ORIGIN_INHERITS_SEC_CONTEXT
nsIContentPolicy
:
:
TYPE_OTHER
nullptr
loadGroup
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
(
do_QueryInterface
(
channel
)
)
;
if
(
httpChannel
)
{
rv
=
httpChannel
-
>
SetReferrerInfo
(
aReferrerInfo
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
mURI
=
aURI
;
return
channel
-
>
AsyncOpen
(
this
)
;
}
NS_IMPL_ISUPPORTS
(
ExternalResourceMap
:
:
LoadgroupCallbacks
nsIInterfaceRequestor
)
#
define
IMPL_SHIM
(
_i
)
\
NS_IMPL_ISUPPORTS
(
ExternalResourceMap
:
:
LoadgroupCallbacks
:
:
_i
#
#
Shim
_i
)
IMPL_SHIM
(
nsILoadContext
)
IMPL_SHIM
(
nsIProgressEventSink
)
IMPL_SHIM
(
nsIChannelEventSink
)
#
undef
IMPL_SHIM
#
define
IID_IS
(
_i
)
aIID
.
Equals
(
NS_GET_IID
(
_i
)
)
#
define
TRY_SHIM
(
_i
)
\
PR_BEGIN_MACRO
\
if
(
IID_IS
(
_i
)
)
{
\
nsCOMPtr
<
_i
>
real
=
do_GetInterface
(
mCallbacks
)
;
\
if
(
!
real
)
{
\
return
NS_NOINTERFACE
;
\
}
\
nsCOMPtr
<
_i
>
shim
=
new
_i
#
#
Shim
(
this
real
)
;
\
shim
.
forget
(
aSink
)
;
\
return
NS_OK
;
\
}
\
PR_END_MACRO
NS_IMETHODIMP
ExternalResourceMap
:
:
LoadgroupCallbacks
:
:
GetInterface
(
const
nsIID
&
aIID
void
*
*
aSink
)
{
if
(
mCallbacks
&
&
(
IID_IS
(
nsIPrompt
)
|
|
IID_IS
(
nsIAuthPrompt
)
|
|
IID_IS
(
nsIAuthPrompt2
)
|
|
IID_IS
(
nsIBrowserChild
)
)
)
{
return
mCallbacks
-
>
GetInterface
(
aIID
aSink
)
;
}
*
aSink
=
nullptr
;
TRY_SHIM
(
nsILoadContext
)
;
TRY_SHIM
(
nsIProgressEventSink
)
;
TRY_SHIM
(
nsIChannelEventSink
)
;
return
NS_NOINTERFACE
;
}
#
undef
TRY_SHIM
#
undef
IID_IS
ExternalResourceMap
:
:
ExternalResource
:
:
~
ExternalResource
(
)
{
if
(
mViewer
)
{
mViewer
-
>
Close
(
nullptr
)
;
mViewer
-
>
Destroy
(
)
;
}
}
class
DOMStyleSheetSetList
final
:
public
DOMStringList
{
public
:
explicit
DOMStyleSheetSetList
(
Document
*
aDocument
)
;
void
Disconnect
(
)
{
mDocument
=
nullptr
;
}
virtual
void
EnsureFresh
(
)
override
;
protected
:
Document
*
mDocument
;
}
;
DOMStyleSheetSetList
:
:
DOMStyleSheetSetList
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
NS_ASSERTION
(
mDocument
"
Must
have
document
!
"
)
;
}
void
DOMStyleSheetSetList
:
:
EnsureFresh
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mNames
.
Clear
(
)
;
if
(
!
mDocument
)
{
return
;
}
size_t
count
=
mDocument
-
>
SheetCount
(
)
;
nsAutoString
title
;
for
(
size_t
index
=
0
;
index
<
count
;
index
+
+
)
{
StyleSheet
*
sheet
=
mDocument
-
>
SheetAt
(
index
)
;
NS_ASSERTION
(
sheet
"
Null
sheet
in
sheet
list
!
"
)
;
sheet
-
>
GetTitle
(
title
)
;
if
(
!
title
.
IsEmpty
(
)
&
&
!
mNames
.
Contains
(
title
)
&
&
!
Add
(
title
)
)
{
return
;
}
}
}
Document
:
:
PendingFrameStaticClone
:
:
~
PendingFrameStaticClone
(
)
=
default
;
Document
:
:
InternalCommandDataHashtable
*
Document
:
:
sInternalCommandDataHashtable
=
nullptr
;
void
Document
:
:
Shutdown
(
)
{
if
(
sInternalCommandDataHashtable
)
{
sInternalCommandDataHashtable
-
>
Clear
(
)
;
delete
sInternalCommandDataHashtable
;
sInternalCommandDataHashtable
=
nullptr
;
}
}
Document
:
:
Document
(
const
char
*
aContentType
)
:
nsINode
(
nullptr
)
DocumentOrShadowRoot
(
this
)
mCharacterSet
(
WINDOWS_1252_ENCODING
)
mCharacterSetSource
(
0
)
mParentDocument
(
nullptr
)
mCachedRootElement
(
nullptr
)
mNodeInfoManager
(
nullptr
)
#
ifdef
DEBUG
mStyledLinksCleared
(
false
)
#
endif
mCachedStateObjectValid
(
false
)
mBlockAllMixedContent
(
false
)
mBlockAllMixedContentPreloads
(
false
)
mUpgradeInsecureRequests
(
false
)
mUpgradeInsecurePreloads
(
false
)
mDevToolsWatchingDOMMutations
(
false
)
mBidiEnabled
(
false
)
mMayNeedFontPrefsUpdate
(
true
)
mMathMLEnabled
(
false
)
mIsInitialDocumentInWindow
(
false
)
mIgnoreDocGroupMismatches
(
false
)
mLoadedAsData
(
false
)
mAddedToMemoryReportingAsDataDocument
(
false
)
mMayStartLayout
(
true
)
mHaveFiredTitleChange
(
false
)
mIsShowing
(
false
)
mVisible
(
true
)
mRemovedFromDocShell
(
false
)
mAllowDNSPrefetch
(
true
)
mIsStaticDocument
(
false
)
mCreatingStaticClone
(
false
)
mHasPrintCallbacks
(
false
)
mInUnlinkOrDeletion
(
false
)
mHasHadScriptHandlingObject
(
false
)
mIsBeingUsedAsImage
(
false
)
mChromeRulesEnabled
(
false
)
mInChromeDocShell
(
false
)
mIsSyntheticDocument
(
false
)
mHasLinksToUpdateRunnable
(
false
)
mFlushingPendingLinkUpdates
(
false
)
mMayHaveDOMMutationObservers
(
false
)
mMayHaveAnimationObservers
(
false
)
mHasCSPDeliveredThroughHeader
(
false
)
mBFCacheDisallowed
(
false
)
mHasHadDefaultView
(
false
)
mStyleSheetChangeEventsEnabled
(
false
)
mDevToolsAnonymousAndShadowEventsEnabled
(
false
)
mIsSrcdocDocument
(
false
)
mHasDisplayDocument
(
false
)
mFontFaceSetDirty
(
true
)
mDidFireDOMContentLoaded
(
true
)
mFrameRequestCallbacksScheduled
(
false
)
mIsTopLevelContentDocument
(
false
)
mIsContentDocument
(
false
)
mDidCallBeginLoad
(
false
)
mEncodingMenuDisabled
(
false
)
mLinksEnabled
(
true
)
mIsSVGGlyphsDocument
(
false
)
mInDestructor
(
false
)
mIsGoingAway
(
false
)
mInXBLUpdate
(
false
)
mStyleSetFilled
(
false
)
mQuirkSheetAdded
(
false
)
mContentEditableSheetAdded
(
false
)
mDesignModeSheetAdded
(
false
)
mMayHaveTitleElement
(
false
)
mDOMLoadingSet
(
false
)
mDOMInteractiveSet
(
false
)
mDOMCompleteSet
(
false
)
mAutoFocusFired
(
false
)
mScrolledToRefAlready
(
false
)
mChangeScrollPosWhenScrollingToRef
(
false
)
mDelayFrameLoaderInitialization
(
false
)
mSynchronousDOMContentLoaded
(
false
)
mMaybeServiceWorkerControlled
(
false
)
mAllowZoom
(
false
)
mValidScaleFloat
(
false
)
mValidMinScale
(
false
)
mValidMaxScale
(
false
)
mWidthStrEmpty
(
false
)
mParserAborted
(
false
)
mReportedDocumentUseCounters
(
false
)
mHasReportedShadowDOMUsage
(
false
)
mHasDelayedRefreshEvent
(
false
)
mLoadEventFiring
(
false
)
mSkipLoadEventAfterClose
(
false
)
mDisableCookieAccess
(
false
)
mDisableDocWrite
(
false
)
mTooDeepWriteRecursion
(
false
)
mPendingMaybeEditingStateChanged
(
false
)
mHasBeenEditable
(
false
)
mHasWarnedAboutZoom
(
false
)
mIsRunningExecCommand
(
false
)
mSetCompleteAfterDOMContentLoaded
(
false
)
mDidHitCompleteSheetCache
(
false
)
mUseCountersInitialized
(
false
)
mShouldReportUseCounters
(
false
)
mShouldSendPageUseCounters
(
false
)
mUserHasInteracted
(
false
)
mHasUserInteractionTimerScheduled
(
false
)
mShouldResistFingerprinting
(
false
)
mCloningForSVGUse
(
false
)
mXMLDeclarationBits
(
0
)
mOnloadBlockCount
(
0
)
mWriteLevel
(
0
)
mContentEditableCount
(
0
)
mEditingState
(
EditingState
:
:
eOff
)
mCompatMode
(
eCompatibility_FullStandards
)
mReadyState
(
ReadyState
:
:
READYSTATE_UNINITIALIZED
)
mAncestorIsLoading
(
false
)
mVisibilityState
(
dom
:
:
VisibilityState
:
:
Hidden
)
mType
(
eUnknown
)
mDefaultElementType
(
0
)
mAllowXULXBL
(
eTriUnset
)
mSkipDTDSecurityChecks
(
false
)
mBidiOptions
(
IBMBIDI_DEFAULT_BIDI_OPTIONS
)
mSandboxFlags
(
0
)
mPartID
(
0
)
mMarkedCCGeneration
(
0
)
mPresShell
(
nullptr
)
mSubtreeModifiedDepth
(
0
)
mPreloadPictureDepth
(
0
)
mEventsSuppressed
(
0
)
mIgnoreDestructiveWritesCounter
(
0
)
mStaticCloneCount
(
0
)
mWindow
(
nullptr
)
mBFCacheEntry
(
nullptr
)
mInSyncOperationCount
(
0
)
mBlockDOMContentLoaded
(
0
)
mUpdateNestLevel
(
0
)
mHttpsOnlyStatus
(
nsILoadInfo
:
:
HTTPS_ONLY_UNINITIALIZED
)
mViewportType
(
Unknown
)
mViewportFit
(
ViewportFitType
:
:
Auto
)
mSubDocuments
(
nullptr
)
mHeaderData
(
nullptr
)
mServoRestyleRootDirtyBits
(
0
)
mThrowOnDynamicMarkupInsertionCounter
(
0
)
mIgnoreOpensDuringUnloadCounter
(
0
)
mSavedResolution
(
1
.
0f
)
mSavedResolutionBeforeMVM
(
1
.
0f
)
mGeneration
(
0
)
mCachedTabSizeGeneration
(
0
)
mNextFormNumber
(
0
)
mNextControlNumber
(
0
)
mPreloadService
(
this
)
mShouldNotifyFetchSuccess
(
false
)
mShouldNotifyFormOrPasswordRemoved
(
false
)
{
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
created
"
this
)
)
;
SetIsInDocument
(
)
;
SetIsConnected
(
true
)
;
mStyleUseCounters
.
reset
(
Servo_UseCounters_Create
(
)
)
;
SetContentType
(
nsDependentCString
(
aContentType
)
)
;
SetDOMStringToNull
(
mLastStyleSheetSet
)
;
mPreloadPictureFoundSource
.
SetIsVoid
(
true
)
;
RecomputeLanguageFromCharset
(
)
;
mPreloadReferrerInfo
=
new
dom
:
:
ReferrerInfo
(
nullptr
)
;
mReferrerInfo
=
new
dom
:
:
ReferrerInfo
(
nullptr
)
;
}
#
ifndef
ANDROID
static
bool
IsAboutErrorPage
(
nsGlobalWindowInner
*
aWin
const
char
*
aSpec
)
{
if
(
NS_WARN_IF
(
!
aWin
)
)
{
return
false
;
}
nsIURI
*
uri
=
aWin
-
>
GetDocumentURI
(
)
;
if
(
NS_WARN_IF
(
!
uri
)
)
{
return
false
;
}
if
(
!
uri
-
>
SchemeIs
(
"
about
"
)
)
{
return
false
;
}
nsAutoCString
aboutSpec
;
nsresult
rv
=
NS_GetAboutModuleName
(
uri
aboutSpec
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
return
aboutSpec
.
EqualsASCII
(
aSpec
)
;
}
#
endif
bool
Document
:
:
CallerIsTrustedAboutNetError
(
JSContext
*
aCx
JSObject
*
aObject
)
{
nsGlobalWindowInner
*
win
=
xpc
:
:
WindowOrNull
(
aObject
)
;
#
ifdef
ANDROID
return
win
&
&
win
-
>
GetDocument
(
)
&
&
win
-
>
GetDocument
(
)
-
>
IsErrorPage
(
)
;
#
else
return
win
&
&
IsAboutErrorPage
(
win
"
neterror
"
)
;
#
endif
}
bool
Document
:
:
CallerIsTrustedAboutHttpsOnlyError
(
JSContext
*
aCx
JSObject
*
aObject
)
{
nsGlobalWindowInner
*
win
=
xpc
:
:
WindowOrNull
(
aObject
)
;
#
ifdef
ANDROID
return
win
&
&
win
-
>
GetDocument
(
)
&
&
win
-
>
GetDocument
(
)
-
>
IsErrorPage
(
)
;
#
else
return
win
&
&
IsAboutErrorPage
(
win
"
httpsonlyerror
"
)
;
#
endif
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Document
:
:
AddCertException
(
bool
aIsTemporary
ErrorResult
&
aError
)
{
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
GetScopeObject
(
)
aError
Promise
:
:
ePropagateUserInteraction
)
;
if
(
aError
.
Failed
(
)
)
{
return
nullptr
;
}
nsresult
rv
=
NS_OK
;
if
(
NS_WARN_IF
(
!
mFailedChannel
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIURI
>
failedChannelURI
;
NS_GetFinalChannelURI
(
mFailedChannel
getter_AddRefs
(
failedChannelURI
)
)
;
if
(
!
failedChannelURI
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIURI
>
innerURI
=
NS_GetInnermostURI
(
failedChannelURI
)
;
if
(
!
innerURI
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
nsAutoCString
host
;
innerURI
-
>
GetAsciiHost
(
host
)
;
int32_t
port
;
innerURI
-
>
GetPort
(
&
port
)
;
nsCOMPtr
<
nsITransportSecurityInfo
>
tsi
;
rv
=
mFailedChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
tsi
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeReject
(
rv
)
;
return
promise
.
forget
(
)
;
}
if
(
NS_WARN_IF
(
!
tsi
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIX509Cert
>
cert
;
rv
=
tsi
-
>
GetServerCert
(
getter_AddRefs
(
cert
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeReject
(
rv
)
;
return
promise
.
forget
(
)
;
}
if
(
NS_WARN_IF
(
!
cert
)
)
{
promise
-
>
MaybeReject
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
promise
.
forget
(
)
;
}
if
(
XRE_IsContentProcess
(
)
)
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
OriginAttributes
const
&
attrs
=
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
;
cc
-
>
SendAddCertException
(
cert
host
port
attrs
aIsTemporary
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
const
mozilla
:
:
MozPromise
<
nsresult
mozilla
:
:
ipc
:
:
ResponseRejectReason
true
>
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
promise
-
>
MaybeResolve
(
aValue
.
ResolveValue
(
)
)
;
}
else
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
}
)
;
return
promise
.
forget
(
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsCOMPtr
<
nsICertOverrideService
>
overrideService
=
do_GetService
(
NS_CERTOVERRIDE_CONTRACTID
)
;
if
(
!
overrideService
)
{
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
promise
.
forget
(
)
;
}
OriginAttributes
const
&
attrs
=
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
;
rv
=
overrideService
-
>
RememberValidityOverride
(
host
port
attrs
cert
aIsTemporary
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeReject
(
rv
)
;
return
promise
.
forget
(
)
;
}
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
promise
-
>
MaybeReject
(
NS_ERROR_FAILURE
)
;
return
promise
.
forget
(
)
;
}
void
Document
:
:
ReloadWithHttpsOnlyException
(
)
{
if
(
WindowGlobalChild
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
SendReloadWithHttpsOnlyException
(
)
;
}
}
void
Document
:
:
GetNetErrorInfo
(
NetErrorInfo
&
aInfo
ErrorResult
&
aRv
)
{
nsresult
rv
=
NS_OK
;
if
(
NS_WARN_IF
(
!
mFailedChannel
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsCOMPtr
<
nsITransportSecurityInfo
>
tsi
;
rv
=
mFailedChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
tsi
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
NS_WARN_IF
(
!
tsi
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsAutoString
errorCodeString
;
rv
=
tsi
-
>
GetErrorCodeString
(
errorCodeString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
aInfo
.
mErrorCodeString
.
Assign
(
errorCodeString
)
;
}
bool
Document
:
:
CallerIsTrustedAboutCertError
(
JSContext
*
aCx
JSObject
*
aObject
)
{
nsGlobalWindowInner
*
win
=
xpc
:
:
WindowOrNull
(
aObject
)
;
#
ifdef
ANDROID
return
win
&
&
win
-
>
GetDocument
(
)
&
&
win
-
>
GetDocument
(
)
-
>
IsErrorPage
(
)
;
#
else
return
win
&
&
IsAboutErrorPage
(
win
"
certerror
"
)
;
#
endif
}
bool
Document
:
:
CallerCanAccessPrivilegeSSA
(
JSContext
*
aCx
JSObject
*
aObject
)
{
RefPtr
<
BasePrincipal
>
principal
=
BasePrincipal
:
:
Cast
(
nsContentUtils
:
:
SubjectPrincipal
(
aCx
)
)
;
if
(
!
principal
)
{
return
false
;
}
if
(
principal
-
>
IsSystemPrincipal
(
)
)
{
return
true
;
}
if
(
auto
*
policy
=
principal
-
>
ContentScriptAddonPolicy
(
)
)
{
nsAutoString
addonID
;
policy
-
>
GetId
(
addonID
)
;
return
addonID
.
EqualsLiteral
(
"
webcompat
mozilla
.
org
"
)
;
}
return
false
;
}
bool
Document
:
:
IsErrorPage
(
)
const
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
?
mChannel
-
>
LoadInfo
(
)
:
nullptr
;
return
loadInfo
&
&
loadInfo
-
>
GetLoadErrorPage
(
)
;
}
void
Document
:
:
GetFailedCertSecurityInfo
(
FailedCertSecurityInfo
&
aInfo
ErrorResult
&
aRv
)
{
nsresult
rv
=
NS_OK
;
if
(
NS_WARN_IF
(
!
mFailedChannel
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsCOMPtr
<
nsITransportSecurityInfo
>
tsi
;
rv
=
mFailedChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
tsi
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
NS_WARN_IF
(
!
tsi
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsAutoString
errorCodeString
;
rv
=
tsi
-
>
GetErrorCodeString
(
errorCodeString
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
aInfo
.
mErrorCodeString
.
Assign
(
errorCodeString
)
;
nsITransportSecurityInfo
:
:
OverridableErrorCategory
errorCategory
;
rv
=
tsi
-
>
GetOverridableErrorCategory
(
&
errorCategory
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
switch
(
errorCategory
)
{
case
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_TRUST
:
aInfo
.
mOverridableErrorCategory
=
dom
:
:
OverridableErrorCategory
:
:
Trust_error
;
break
;
case
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_DOMAIN
:
aInfo
.
mOverridableErrorCategory
=
dom
:
:
OverridableErrorCategory
:
:
Domain_mismatch
;
break
;
case
nsITransportSecurityInfo
:
:
OverridableErrorCategory
:
:
ERROR_TIME
:
aInfo
.
mOverridableErrorCategory
=
dom
:
:
OverridableErrorCategory
:
:
Expired_or_not_yet_valid
;
break
;
default
:
aInfo
.
mOverridableErrorCategory
=
dom
:
:
OverridableErrorCategory
:
:
Unset
;
break
;
}
nsCOMPtr
<
nsIX509Cert
>
cert
;
nsCOMPtr
<
nsIX509CertValidity
>
validity
;
rv
=
tsi
-
>
GetServerCert
(
getter_AddRefs
(
cert
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
NS_WARN_IF
(
!
cert
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
rv
=
cert
-
>
GetValidity
(
getter_AddRefs
(
validity
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
NS_WARN_IF
(
!
validity
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
PRTime
validityResult
;
rv
=
validity
-
>
GetNotBefore
(
&
validityResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
aInfo
.
mValidNotBefore
=
DOMTimeStamp
(
validityResult
/
PR_USEC_PER_MSEC
)
;
rv
=
validity
-
>
GetNotAfter
(
&
validityResult
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
aInfo
.
mValidNotAfter
=
DOMTimeStamp
(
validityResult
/
PR_USEC_PER_MSEC
)
;
nsAutoString
issuerCommonName
;
nsAutoString
certChainPEMString
;
Sequence
<
nsString
>
&
certChainStrings
=
aInfo
.
mCertChainStrings
.
Construct
(
)
;
int64_t
maxValidity
=
std
:
:
numeric_limits
<
int64_t
>
:
:
max
(
)
;
int64_t
minValidity
=
0
;
PRTime
notBefore
notAfter
;
nsTArray
<
RefPtr
<
nsIX509Cert
>
>
failedCertArray
;
rv
=
tsi
-
>
GetFailedCertChain
(
failedCertArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
NS_WARN_IF
(
failedCertArray
.
IsEmpty
(
)
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
for
(
const
auto
&
certificate
:
failedCertArray
)
{
rv
=
certificate
-
>
GetIssuerCommonName
(
issuerCommonName
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
rv
=
certificate
-
>
GetValidity
(
getter_AddRefs
(
validity
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
NS_WARN_IF
(
!
validity
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
rv
=
validity
-
>
GetNotBefore
(
&
notBefore
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
rv
=
validity
-
>
GetNotAfter
(
&
notAfter
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
notBefore
=
std
:
:
max
(
minValidity
notBefore
)
;
notAfter
=
std
:
:
min
(
maxValidity
notAfter
)
;
nsTArray
<
uint8_t
>
certArray
;
rv
=
certificate
-
>
GetRawDER
(
certArray
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
nsAutoString
der64
;
rv
=
Base64Encode
(
reinterpret_cast
<
const
char
*
>
(
certArray
.
Elements
(
)
)
certArray
.
Length
(
)
der64
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
if
(
!
certChainStrings
.
AppendElement
(
der64
fallible
)
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
;
}
}
aInfo
.
mIssuerCommonName
.
Assign
(
issuerCommonName
)
;
aInfo
.
mCertValidityRangeNotAfter
=
DOMTimeStamp
(
notAfter
/
PR_USEC_PER_MSEC
)
;
aInfo
.
mCertValidityRangeNotBefore
=
DOMTimeStamp
(
notBefore
/
PR_USEC_PER_MSEC
)
;
int32_t
errorCode
;
rv
=
tsi
-
>
GetErrorCode
(
&
errorCode
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
nsCOMPtr
<
nsINSSErrorsService
>
nsserr
=
do_GetService
(
"
mozilla
.
org
/
nss_errors_service
;
1
"
)
;
if
(
NS_WARN_IF
(
!
nsserr
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
nsresult
res
;
rv
=
nsserr
-
>
GetXPCOMFromNSSError
(
errorCode
&
res
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
rv
=
nsserr
-
>
GetErrorMessage
(
res
aInfo
.
mErrorMessage
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
;
}
OriginAttributes
attrs
;
StoragePrincipalHelper
:
:
GetRegularPrincipalOriginAttributes
(
this
attrs
)
;
nsCOMPtr
<
nsIURI
>
aURI
;
mFailedChannel
-
>
GetURI
(
getter_AddRefs
(
aURI
)
)
;
if
(
XRE_IsContentProcess
(
)
)
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
cc
-
>
SendIsSecureURI
(
aURI
attrs
&
aInfo
.
mHasHSTS
)
;
}
else
{
nsCOMPtr
<
nsISiteSecurityService
>
sss
=
do_GetService
(
NS_SSSERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
sss
)
)
{
return
;
}
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
sss
-
>
IsSecureURI
(
aURI
attrs
&
aInfo
.
mHasHSTS
)
)
)
;
}
nsCOMPtr
<
nsIPublicKeyPinningService
>
pkps
=
do_GetService
(
NS_PKPSERVICE_CONTRACTID
)
;
if
(
NS_WARN_IF
(
!
pkps
)
)
{
return
;
}
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
pkps
-
>
HostHasPins
(
aURI
&
aInfo
.
mHasHPKP
)
)
)
;
}
bool
Document
:
:
IsAboutPage
(
)
const
{
return
NodePrincipal
(
)
-
>
SchemeIs
(
"
about
"
)
;
}
void
Document
:
:
ConstructUbiNode
(
void
*
storage
)
{
JS
:
:
ubi
:
:
Concrete
<
Document
>
:
:
construct
(
storage
this
)
;
}
void
Document
:
:
LoadEventFired
(
)
{
glean
:
:
perf
:
:
PageLoadExtra
pageLoadEventData
;
AccumulateJSTelemetry
(
pageLoadEventData
)
;
AccumulatePageLoadTelemetry
(
pageLoadEventData
)
;
RecordPageLoadEventTelemetry
(
pageLoadEventData
)
;
if
(
ScriptLoader
(
)
)
{
ScriptLoader
(
)
-
>
LoadEventFired
(
)
;
}
}
static
uint32_t
ConvertToUnsignedFromDouble
(
double
aNumber
)
{
return
aNumber
<
0
?
0
:
static_cast
<
uint32_t
>
(
aNumber
)
;
}
void
Document
:
:
RecordPageLoadEventTelemetry
(
glean
:
:
perf
:
:
PageLoadExtra
&
aEventTelemetryData
)
{
if
(
!
aEventTelemetryData
.
loadTime
)
{
return
;
}
MOZ_ASSERT
(
IsTopLevelContentDocument
(
)
)
;
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
;
}
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
;
}
nsAutoCString
loadTypeStr
;
switch
(
docshell
-
>
GetLoadType
(
)
)
{
case
LOAD_NORMAL
:
case
LOAD_NORMAL_REPLACE
:
case
LOAD_NORMAL_BYPASS_CACHE
:
case
LOAD_NORMAL_BYPASS_PROXY
:
case
LOAD_NORMAL_BYPASS_PROXY_AND_CACHE
:
loadTypeStr
.
Append
(
"
NORMAL
"
)
;
break
;
case
LOAD_HISTORY
:
loadTypeStr
.
Append
(
"
HISTORY
"
)
;
break
;
case
LOAD_RELOAD_NORMAL
:
case
LOAD_RELOAD_BYPASS_CACHE
:
case
LOAD_RELOAD_BYPASS_PROXY
:
case
LOAD_RELOAD_BYPASS_PROXY_AND_CACHE
:
case
LOAD_REFRESH
:
case
LOAD_REFRESH_REPLACE
:
case
LOAD_RELOAD_CHARSET_CHANGE
:
case
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_PROXY_AND_CACHE
:
case
LOAD_RELOAD_CHARSET_CHANGE_BYPASS_CACHE
:
loadTypeStr
.
Append
(
"
RELOAD
"
)
;
break
;
case
LOAD_LINK
:
loadTypeStr
.
Append
(
"
LINK
"
)
;
break
;
case
LOAD_STOP_CONTENT
:
case
LOAD_STOP_CONTENT_AND_REPLACE
:
loadTypeStr
.
Append
(
"
STOP
"
)
;
break
;
case
LOAD_ERROR_PAGE
:
loadTypeStr
.
Append
(
"
ERROR
"
)
;
break
;
default
:
loadTypeStr
.
Append
(
"
OTHER
"
)
;
break
;
}
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
tldService
&
&
mReferrerInfo
&
&
(
docshell
-
>
GetLoadType
(
)
&
nsIDocShell
:
:
LOAD_CMD_NORMAL
)
)
{
nsAutoCString
currentBaseDomain
referrerBaseDomain
;
nsCOMPtr
<
nsIURI
>
referrerURI
=
mReferrerInfo
-
>
GetComputedReferrer
(
)
;
if
(
referrerURI
)
{
auto
result
=
NS_SUCCEEDED
(
tldService
-
>
GetBaseDomain
(
referrerURI
0
referrerBaseDomain
)
)
;
if
(
result
)
{
bool
sameOrigin
=
false
;
NodePrincipal
(
)
-
>
IsSameOrigin
(
referrerURI
&
sameOrigin
)
;
aEventTelemetryData
.
sameOriginNav
=
mozilla
:
:
Some
(
sameOrigin
)
;
}
}
}
aEventTelemetryData
.
loadType
=
mozilla
:
:
Some
(
loadTypeStr
)
;
if
(
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
)
{
cc
-
>
SendRecordPageLoadEvent
(
aEventTelemetryData
)
;
}
}
void
Document
:
:
AccumulatePageLoadTelemetry
(
glean
:
:
perf
:
:
PageLoadExtra
&
aEventTelemetryDataOut
)
{
if
(
!
ShouldIncludeInTelemetry
(
false
)
|
|
!
IsTopLevelContentDocument
(
)
|
|
!
GetNavigationTiming
(
)
|
|
!
GetNavigationTiming
(
)
-
>
DocShellHasBeenActiveSinceNavigationStart
(
)
)
{
return
;
}
if
(
!
GetChannel
(
)
)
{
return
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
GetChannel
(
)
)
)
;
if
(
!
timedChannel
)
{
return
;
}
const
TimeDuration
zeroDuration
;
TimeStamp
responseStart
;
timedChannel
-
>
GetResponseStart
(
&
responseStart
)
;
TimeStamp
redirectStart
redirectEnd
;
timedChannel
-
>
GetRedirectStart
(
&
redirectStart
)
;
timedChannel
-
>
GetRedirectEnd
(
&
redirectEnd
)
;
uint8_t
redirectCount
;
timedChannel
-
>
GetRedirectCount
(
&
redirectCount
)
;
if
(
redirectCount
)
{
aEventTelemetryDataOut
.
redirectCount
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
redirectCount
)
)
;
}
if
(
!
redirectStart
.
IsNull
(
)
&
&
!
redirectEnd
.
IsNull
(
)
)
{
TimeDuration
redirectTime
=
redirectEnd
-
redirectStart
;
if
(
redirectTime
>
zeroDuration
)
{
aEventTelemetryDataOut
.
redirectTime
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
redirectTime
.
ToMilliseconds
(
)
)
)
;
}
}
TimeStamp
dnsLookupStart
dnsLookupEnd
;
timedChannel
-
>
GetDomainLookupStart
(
&
dnsLookupStart
)
;
timedChannel
-
>
GetDomainLookupEnd
(
&
dnsLookupEnd
)
;
if
(
!
dnsLookupStart
.
IsNull
(
)
&
&
!
dnsLookupEnd
.
IsNull
(
)
)
{
TimeDuration
dnsLookupTime
=
dnsLookupEnd
-
dnsLookupStart
;
if
(
dnsLookupTime
>
zeroDuration
)
{
aEventTelemetryDataOut
.
dnsLookupTime
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
dnsLookupTime
.
ToMilliseconds
(
)
)
)
;
}
}
TimeStamp
navigationStart
=
GetNavigationTiming
(
)
-
>
GetNavigationStartTimeStamp
(
)
;
if
(
!
responseStart
|
|
!
navigationStart
)
{
return
;
}
nsAutoCString
dnsKey
(
"
Native
"
)
;
nsAutoCString
http3Key
;
nsAutoCString
http3WithPriorityKey
;
nsAutoCString
earlyHintKey
;
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChannel
=
do_QueryInterface
(
GetChannel
(
)
)
;
if
(
httpChannel
)
{
bool
resolvedByTRR
=
false
;
Unused
<
<
httpChannel
-
>
GetIsResolvedByTRR
(
&
resolvedByTRR
)
;
if
(
resolvedByTRR
)
{
if
(
nsCOMPtr
<
nsIDNSService
>
dns
=
do_GetService
(
NS_DNSSERVICE_CONTRACTID
)
)
{
dns
-
>
GetTRRDomainKey
(
dnsKey
)
;
}
else
{
dnsKey
=
"
(
fail
)
"
_ns
;
}
aEventTelemetryDataOut
.
trrDomain
=
mozilla
:
:
Some
(
dnsKey
)
;
}
uint32_t
major
;
uint32_t
minor
;
if
(
NS_SUCCEEDED
(
httpChannel
-
>
GetResponseVersion
(
&
major
&
minor
)
)
)
{
if
(
major
=
=
3
)
{
http3Key
=
"
http3
"
_ns
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel2
=
do_QueryInterface
(
GetChannel
(
)
)
;
nsCString
header
;
if
(
httpChannel2
&
&
NS_SUCCEEDED
(
httpChannel2
-
>
GetResponseHeader
(
"
priority
"
_ns
header
)
)
&
&
!
header
.
IsEmpty
(
)
)
{
http3WithPriorityKey
=
"
with_priority
"
_ns
;
}
else
{
http3WithPriorityKey
=
"
without_priority
"
_ns
;
}
}
else
if
(
major
=
=
2
)
{
bool
supportHttp3
=
false
;
if
(
NS_FAILED
(
httpChannel
-
>
GetSupportsHTTP3
(
&
supportHttp3
)
)
)
{
supportHttp3
=
false
;
}
if
(
supportHttp3
)
{
http3Key
=
"
supports_http3
"
_ns
;
}
}
aEventTelemetryDataOut
.
httpVer
=
mozilla
:
:
Some
(
major
)
;
}
uint32_t
earlyHintType
=
0
;
Unused
<
<
httpChannel
-
>
GetEarlyHintLinkType
(
&
earlyHintType
)
;
if
(
earlyHintType
&
LinkStyle
:
:
ePRECONNECT
)
{
earlyHintKey
.
Append
(
"
preconnect_
"
_ns
)
;
}
if
(
earlyHintType
&
LinkStyle
:
:
ePRELOAD
)
{
earlyHintKey
.
Append
(
"
preload_
"
_ns
)
;
earlyHintKey
.
Append
(
mPreloadService
.
GetEarlyHintUsed
(
)
?
"
1
"
_ns
:
"
0
"
_ns
)
;
}
}
TimeStamp
asyncOpen
;
timedChannel
-
>
GetAsyncOpen
(
&
asyncOpen
)
;
if
(
asyncOpen
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
DNS_PERF_FIRST_BYTE_MS
dnsKey
asyncOpen
responseStart
)
;
}
if
(
TimeStamp
firstContentfulComposite
=
GetNavigationTiming
(
)
-
>
GetFirstContentfulCompositeTimeStamp
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_FIRST_CONTENTFUL_PAINT_MS
navigationStart
firstContentfulComposite
)
;
if
(
!
http3Key
.
IsEmpty
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
HTTP3_PERF_FIRST_CONTENTFUL_PAINT_MS
http3Key
navigationStart
firstContentfulComposite
)
;
}
if
(
!
http3WithPriorityKey
.
IsEmpty
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
H3P_PERF_FIRST_CONTENTFUL_PAINT_MS
http3WithPriorityKey
navigationStart
firstContentfulComposite
)
;
}
if
(
!
earlyHintKey
.
IsEmpty
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
EH_PERF_FIRST_CONTENTFUL_PAINT_MS
earlyHintKey
navigationStart
firstContentfulComposite
)
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
DNS_PERF_FIRST_CONTENTFUL_PAINT_MS
dnsKey
navigationStart
firstContentfulComposite
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_FIRST_CONTENTFUL_PAINT_FROM_RESPONSESTART_MS
responseStart
firstContentfulComposite
)
;
TimeDuration
fcpTime
=
firstContentfulComposite
-
navigationStart
;
if
(
fcpTime
>
zeroDuration
)
{
aEventTelemetryDataOut
.
fcpTime
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
fcpTime
.
ToMilliseconds
(
)
)
)
;
}
}
if
(
TimeStamp
lcpTime
=
GetNavigationTiming
(
)
-
>
GetLargestContentfulRenderTimeStamp
(
)
)
{
aEventTelemetryDataOut
.
lcpTime
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
(
lcpTime
-
navigationStart
)
.
ToMilliseconds
(
)
)
)
;
}
if
(
TimeStamp
dclEventStart
=
GetNavigationTiming
(
)
-
>
GetDOMContentLoadedEventStartTimeStamp
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_DOM_CONTENT_LOADED_TIME_MS
navigationStart
dclEventStart
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_DOM_CONTENT_LOADED_TIME_FROM_RESPONSESTART_MS
responseStart
dclEventStart
)
;
}
if
(
TimeStamp
loadEventStart
=
GetNavigationTiming
(
)
-
>
GetLoadEventStartTimeStamp
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_PAGE_LOAD_TIME_MS
navigationStart
loadEventStart
)
;
if
(
!
http3Key
.
IsEmpty
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
HTTP3_PERF_PAGE_LOAD_TIME_MS
http3Key
navigationStart
loadEventStart
)
;
}
if
(
!
http3WithPriorityKey
.
IsEmpty
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
H3P_PERF_PAGE_LOAD_TIME_MS
http3WithPriorityKey
navigationStart
loadEventStart
)
;
}
if
(
!
earlyHintKey
.
IsEmpty
(
)
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
EH_PERF_PAGE_LOAD_TIME_MS
earlyHintKey
navigationStart
loadEventStart
)
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_PAGE_LOAD_TIME_FROM_RESPONSESTART_MS
responseStart
loadEventStart
)
;
TimeDuration
responseTime
=
responseStart
-
navigationStart
;
if
(
responseTime
>
zeroDuration
)
{
aEventTelemetryDataOut
.
responseTime
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
responseTime
.
ToMilliseconds
(
)
)
)
;
}
TimeDuration
loadTime
=
loadEventStart
-
navigationStart
;
if
(
loadTime
>
zeroDuration
)
{
aEventTelemetryDataOut
.
loadTime
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
loadTime
.
ToMilliseconds
(
)
)
)
;
}
}
}
void
Document
:
:
AccumulateJSTelemetry
(
glean
:
:
perf
:
:
PageLoadExtra
&
aEventTelemetryDataOut
)
{
if
(
!
IsTopLevelContentDocument
(
)
|
|
!
ShouldIncludeInTelemetry
(
false
)
)
{
return
;
}
if
(
!
GetScopeObject
(
)
|
|
!
GetScopeObject
(
)
-
>
GetGlobalJSObject
(
)
)
{
return
;
}
AutoJSContext
cx
;
JSObject
*
globalObject
=
GetScopeObject
(
)
-
>
GetGlobalJSObject
(
)
;
JSAutoRealm
ar
(
cx
globalObject
)
;
JS
:
:
JSTimers
timers
=
JS
:
:
GetJSTimers
(
cx
)
;
if
(
!
timers
.
executionTime
.
IsZero
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PAGELOAD_EXECUTION_MS
ConvertToUnsignedFromDouble
(
timers
.
executionTime
.
ToMilliseconds
(
)
)
)
;
aEventTelemetryDataOut
.
jsExecTime
=
mozilla
:
:
Some
(
static_cast
<
uint32_t
>
(
timers
.
executionTime
.
ToMilliseconds
(
)
)
)
;
}
if
(
!
timers
.
delazificationTime
.
IsZero
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PAGELOAD_DELAZIFICATION_MS
ConvertToUnsignedFromDouble
(
timers
.
delazificationTime
.
ToMilliseconds
(
)
)
)
;
}
if
(
!
timers
.
xdrEncodingTime
.
IsZero
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PAGELOAD_XDR_ENCODING_MS
ConvertToUnsignedFromDouble
(
timers
.
xdrEncodingTime
.
ToMilliseconds
(
)
)
)
;
}
if
(
!
timers
.
baselineCompileTime
.
IsZero
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PAGELOAD_BASELINE_COMPILE_MS
ConvertToUnsignedFromDouble
(
timers
.
baselineCompileTime
.
ToMilliseconds
(
)
)
)
;
}
if
(
!
timers
.
gcTime
.
IsZero
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PAGELOAD_GC_MS
ConvertToUnsignedFromDouble
(
timers
.
gcTime
.
ToMilliseconds
(
)
)
)
;
}
if
(
!
timers
.
protectTime
.
IsZero
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
JS_PAGELOAD_PROTECT_MS
ConvertToUnsignedFromDouble
(
timers
.
protectTime
.
ToMilliseconds
(
)
)
)
;
}
}
Document
:
:
~
Document
(
)
{
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
destroyed
"
this
)
)
;
MOZ_ASSERT
(
!
IsTopLevelContentDocument
(
)
|
|
!
IsResourceDoc
(
)
"
Can
'
t
be
top
-
level
and
a
resource
doc
at
the
same
time
"
)
;
NS_ASSERTION
(
!
mIsShowing
"
Destroying
a
currently
-
showing
document
"
)
;
if
(
IsTopLevelContentDocument
(
)
)
{
RemoveToplevelLoadingDocument
(
this
)
;
if
(
!
IsAboutPage
(
)
)
{
if
(
MOZ_UNLIKELY
(
mMathMLEnabled
)
)
{
ScalarAdd
(
Telemetry
:
:
ScalarID
:
:
MATHML_DOC_COUNT
1
)
;
}
if
(
IsHTMLDocument
(
)
)
{
switch
(
GetCompatibilityMode
(
)
)
{
case
eCompatibility_FullStandards
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUIRKS_MODE
:
:
FullStandards
)
;
break
;
case
eCompatibility_AlmostStandards
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUIRKS_MODE
:
:
AlmostStandards
)
;
break
;
case
eCompatibility_NavQuirks
:
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_QUIRKS_MODE
:
:
NavQuirks
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
quirks
mode
"
)
;
break
;
}
}
}
}
mInDestructor
=
true
;
mInUnlinkOrDeletion
=
true
;
mozilla
:
:
DropJSObjects
(
this
)
;
mObservers
.
Clear
(
)
;
mIntersectionObservers
.
Clear
(
)
;
if
(
mStyleSheetSetList
)
{
mStyleSheetSetList
-
>
Disconnect
(
)
;
}
if
(
mAnimationController
)
{
mAnimationController
-
>
Disconnect
(
)
;
}
MOZ_ASSERT
(
mTimelines
.
isEmpty
(
)
)
;
mParentDocument
=
nullptr
;
delete
mSubDocuments
;
mSubDocuments
=
nullptr
;
nsAutoScriptBlocker
scriptBlocker
;
DestroyElementMaps
(
)
;
InvalidateChildNodes
(
)
;
MOZ_ASSERT
(
!
HasChildren
(
)
)
;
mCachedRootElement
=
nullptr
;
for
(
auto
&
sheets
:
mAdditionalSheets
)
{
UnlinkStyleSheets
(
sheets
)
;
}
if
(
mAttributeStyles
)
{
mAttributeStyles
-
>
SetOwningDocument
(
nullptr
)
;
}
if
(
mListenerManager
)
{
mListenerManager
-
>
Disconnect
(
)
;
UnsetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
}
if
(
mScriptLoader
)
{
mScriptLoader
-
>
DropDocumentReference
(
)
;
}
if
(
mCSSLoader
)
{
mCSSLoader
-
>
DropDocumentReference
(
)
;
}
if
(
mStyleImageLoader
)
{
mStyleImageLoader
-
>
DropDocumentReference
(
)
;
}
if
(
mXULBroadcastManager
)
{
mXULBroadcastManager
-
>
DropDocumentReference
(
)
;
}
if
(
mXULPersist
)
{
mXULPersist
-
>
DropDocumentReference
(
)
;
}
if
(
mPermissionDelegateHandler
)
{
mPermissionDelegateHandler
-
>
DropDocumentReference
(
)
;
}
mHeaderData
=
nullptr
;
mPendingTitleChangeEvent
.
Revoke
(
)
;
MOZ_ASSERT
(
mDOMMediaQueryLists
.
isEmpty
(
)
"
must
not
have
media
query
lists
left
"
)
;
if
(
mNodeInfoManager
)
{
mNodeInfoManager
-
>
DropDocumentReference
(
)
;
}
if
(
mDocGroup
)
{
MOZ_ASSERT
(
mDocGroup
-
>
GetBrowsingContextGroup
(
)
)
;
mDocGroup
-
>
GetBrowsingContextGroup
(
)
-
>
RemoveDocument
(
this
mDocGroup
)
;
}
UnlinkOriginalDocumentIfStatic
(
)
;
UnregisterFromMemoryReportingForDataDocument
(
)
;
}
NS_INTERFACE_TABLE_HEAD
(
Document
)
NS_WRAPPERCACHE_INTERFACE_TABLE_ENTRY
NS_INTERFACE_TABLE_BEGIN
NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS
(
Document
nsISupports
nsINode
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsINode
)
NS_INTERFACE_TABLE_ENTRY
(
Document
Document
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsIScriptObjectPrincipal
)
NS_INTERFACE_TABLE_ENTRY
(
Document
EventTarget
)
NS_INTERFACE_TABLE_ENTRY
(
Document
nsISupportsWeakReference
)
NS_INTERFACE_TABLE_END
NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION
(
Document
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
Document
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
Document
LastRelease
(
)
)
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN
(
Document
)
if
(
Element
:
:
CanSkip
(
tmp
aRemovingAllowed
)
)
{
EventListenerManager
*
elm
=
tmp
-
>
GetExistingListenerManager
(
)
;
if
(
elm
)
{
elm
-
>
MarkForCC
(
)
;
}
return
true
;
}
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN
(
Document
)
return
Element
:
:
CanSkipInCC
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN
(
Document
)
return
Element
:
:
CanSkipThis
(
tmp
)
;
NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL
(
Document
)
if
(
MOZ_UNLIKELY
(
cb
.
WantDebugInfo
(
)
)
)
{
char
name
[
512
]
;
nsAutoCString
loadedAsData
;
if
(
tmp
-
>
IsLoadedAsData
(
)
)
{
loadedAsData
.
AssignLiteral
(
"
data
"
)
;
}
else
{
loadedAsData
.
AssignLiteral
(
"
normal
"
)
;
}
uint32_t
nsid
=
tmp
-
>
GetDefaultNamespaceID
(
)
;
nsAutoCString
uri
;
if
(
tmp
-
>
mDocumentURI
)
uri
=
tmp
-
>
mDocumentURI
-
>
GetSpecOrDefault
(
)
;
static
const
char
*
kNSURIs
[
]
=
{
"
(
[
none
]
)
"
"
(
xmlns
)
"
"
(
xml
)
"
"
(
xhtml
)
"
"
(
XLink
)
"
"
(
XSLT
)
"
"
(
MathML
)
"
"
(
RDF
)
"
"
(
XUL
)
"
}
;
if
(
nsid
<
ArrayLength
(
kNSURIs
)
)
{
SprintfLiteral
(
name
"
Document
%
s
%
s
%
s
"
loadedAsData
.
get
(
)
kNSURIs
[
nsid
]
uri
.
get
(
)
)
;
}
else
{
SprintfLiteral
(
name
"
Document
%
s
%
s
"
loadedAsData
.
get
(
)
uri
.
get
(
)
)
;
}
cb
.
DescribeRefCountedNode
(
tmp
-
>
mRefCnt
.
get
(
)
name
)
;
}
else
{
NS_IMPL_CYCLE_COLLECTION_DESCRIBE
(
Document
tmp
-
>
mRefCnt
.
get
(
)
)
}
if
(
!
nsINode
:
:
Traverse
(
tmp
cb
)
)
{
return
NS_SUCCESS_INTERRUPTED_TRAVERSE
;
}
tmp
-
>
mExternalResourceMap
.
Traverse
(
&
cb
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSecurityInfo
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDisplayDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFontFaceSet
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReadyForIdle
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentL10n
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mHighlightRegistry
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mParser
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScriptGlobalObject
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mListenerManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStyleSheetSetList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScriptLoader
)
DocumentOrShadowRoot
:
:
Traverse
(
tmp
cb
)
;
if
(
tmp
-
>
mRadioGroupContainer
)
{
RadioGroupContainer
:
:
Traverse
(
tmp
-
>
mRadioGroupContainer
.
get
(
)
cb
)
;
}
for
(
auto
&
sheets
:
tmp
-
>
mAdditionalSheets
)
{
tmp
-
>
TraverseStyleSheets
(
sheets
"
mAdditionalSheets
[
<
origin
>
]
[
i
]
"
cb
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOnloadBlocker
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLazyLoadObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLastRememberedSizeObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContentVisibilityObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDOMImplementation
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mImageMaps
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOrientationPendingPromise
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mOriginalDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCachedEncoder
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocumentTimeline
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScrollTimelineAnimationTracker
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTemplateContentsOwner
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mChildrenCollection
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mImages
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEmbeds
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLinks
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mForms
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mScripts
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mApplets
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnchors
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnonymousContents
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCommandDispatcher
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mSuppressedEventListener
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPrototypeDocument
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMidasCommandManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAll
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocGroup
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mFrameRequestManager
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mContentIdentifiersForLCP
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPreloadingImages
)
if
(
tmp
-
>
mAnimationController
)
{
tmp
-
>
mAnimationController
-
>
Traverse
(
&
cb
)
;
}
if
(
tmp
-
>
mSubDocuments
)
{
for
(
auto
iter
=
tmp
-
>
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mSubDocuments
entry
-
>
mKey
"
)
;
cb
.
NoteXPCOMChild
(
entry
-
>
mKey
)
;
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mSubDocuments
entry
-
>
mSubDocument
"
)
;
cb
.
NoteXPCOMChild
(
ToSupports
(
entry
-
>
mSubDocument
)
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCSSLoader
)
for
(
MediaQueryList
*
mql
=
tmp
-
>
mDOMMediaQueryLists
.
getFirst
(
)
;
mql
;
mql
=
static_cast
<
LinkedListElement
<
MediaQueryList
>
*
>
(
mql
)
-
>
getNext
(
)
)
{
if
(
mql
-
>
HasListeners
(
)
&
&
NS_SUCCEEDED
(
mql
-
>
CheckCurrentGlobalCorrectness
(
)
)
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mDOMMediaQueryLists
item
"
)
;
cb
.
NoteXPCOMChild
(
mql
)
;
}
}
for
(
const
auto
&
entry
:
tmp
-
>
mL10nProtoElements
)
{
NS_CYCLE_COLLECTION_NOTE_EDGE_NAME
(
cb
"
mL10nProtoElements
key
"
)
;
cb
.
NoteXPCOMChild
(
entry
.
GetKey
(
)
)
;
CycleCollectionNoteChild
(
cb
entry
.
GetWeak
(
)
"
mL10nProtoElements
value
"
)
;
}
for
(
size_t
i
=
0
;
i
<
tmp
-
>
mPendingFrameStaticClones
.
Length
(
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPendingFrameStaticClones
[
i
]
.
mElement
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPendingFrameStaticClones
[
i
]
.
mStaticCloneOf
)
;
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
Document
)
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN
(
Document
)
NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mCachedStateObject
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
Document
)
tmp
-
>
mInUnlinkOrDeletion
=
true
;
tmp
-
>
SetStateObject
(
nullptr
)
;
tmp
-
>
mExternalResourceMap
.
Shutdown
(
)
;
nsAutoScriptBlocker
scriptBlocker
;
nsINode
:
:
Unlink
(
tmp
)
;
while
(
tmp
-
>
HasChildren
(
)
)
{
nsCOMPtr
<
nsIContent
>
child
=
tmp
-
>
GetLastChild
(
)
;
tmp
-
>
DisconnectChild
(
child
)
;
child
-
>
UnbindFromTree
(
)
;
}
tmp
-
>
UnlinkOriginalDocumentIfStatic
(
)
;
tmp
-
>
mCachedRootElement
=
nullptr
;
tmp
-
>
SetScriptGlobalObject
(
nullptr
)
;
for
(
auto
&
sheets
:
tmp
-
>
mAdditionalSheets
)
{
tmp
-
>
UnlinkStyleSheets
(
sheets
)
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSecurityInfo
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDisplayDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLazyLoadObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mContentVisibilityObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLastRememberedSizeObserver
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFontFaceSet
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReadyForIdle
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentL10n
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mHighlightRegistry
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mParser
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOnloadBlocker
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDOMImplementation
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mImageMaps
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOrientationPendingPromise
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mOriginalDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCachedEncoder
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocumentTimeline
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mScrollTimelineAnimationTracker
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTemplateContentsOwner
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mChildrenCollection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mImages
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEmbeds
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLinks
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mForms
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mScripts
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mApplets
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnchors
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnonymousContents
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCommandDispatcher
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFeaturePolicy
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mSuppressedEventListener
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPrototypeDocument
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMidasCommandManager
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAll
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReferrerInfo
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPreloadReferrerInfo
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mContentIdentifiersForLCP
)
;
if
(
tmp
-
>
mDocGroup
&
&
tmp
-
>
mDocGroup
-
>
GetBrowsingContextGroup
(
)
)
{
tmp
-
>
mDocGroup
-
>
GetBrowsingContextGroup
(
)
-
>
RemoveDocument
(
tmp
tmp
-
>
mDocGroup
)
;
}
tmp
-
>
mDocGroup
=
nullptr
;
if
(
tmp
-
>
IsTopLevelContentDocument
(
)
)
{
RemoveToplevelLoadingDocument
(
tmp
)
;
}
tmp
-
>
mParentDocument
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPreloadingImages
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mIntersectionObservers
)
if
(
tmp
-
>
mListenerManager
)
{
tmp
-
>
mListenerManager
-
>
Disconnect
(
)
;
tmp
-
>
UnsetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
tmp
-
>
mListenerManager
=
nullptr
;
}
if
(
tmp
-
>
mStyleSheetSetList
)
{
tmp
-
>
mStyleSheetSetList
-
>
Disconnect
(
)
;
tmp
-
>
mStyleSheetSetList
=
nullptr
;
}
delete
tmp
-
>
mSubDocuments
;
tmp
-
>
mSubDocuments
=
nullptr
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mFrameRequestManager
)
MOZ_RELEASE_ASSERT
(
!
tmp
-
>
mFrameRequestCallbacksScheduled
"
How
did
we
get
here
without
our
presshell
going
away
"
"
first
?
"
)
;
DocumentOrShadowRoot
:
:
Unlink
(
tmp
)
;
tmp
-
>
mRadioGroupContainer
=
nullptr
;
tmp
-
>
mExpandoAndGeneration
.
OwnerUnlinked
(
)
;
if
(
tmp
-
>
mAnimationController
)
{
tmp
-
>
mAnimationController
-
>
Unlink
(
)
;
}
tmp
-
>
mPendingTitleChangeEvent
.
Revoke
(
)
;
if
(
tmp
-
>
mCSSLoader
)
{
tmp
-
>
mCSSLoader
-
>
DropDocumentReference
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCSSLoader
)
}
for
(
MediaQueryList
*
mql
=
tmp
-
>
mDOMMediaQueryLists
.
getFirst
(
)
;
mql
;
)
{
MediaQueryList
*
next
=
static_cast
<
LinkedListElement
<
MediaQueryList
>
*
>
(
mql
)
-
>
getNext
(
)
;
mql
-
>
Disconnect
(
)
;
mql
=
next
;
}
tmp
-
>
mPendingFrameStaticClones
.
Clear
(
)
;
tmp
-
>
mInUnlinkOrDeletion
=
false
;
tmp
-
>
UnregisterFromMemoryReportingForDataDocument
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mL10nProtoElements
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_PTR
NS_IMPL_CYCLE_COLLECTION_UNLINK_WEAK_REFERENCE
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
nsresult
Document
:
:
Init
(
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aPartitionedPrincipal
)
{
if
(
mCSSLoader
|
|
mStyleImageLoader
|
|
mNodeInfoManager
|
|
mScriptLoader
)
{
return
NS_ERROR_ALREADY_INITIALIZED
;
}
mOnloadBlocker
=
new
OnloadBlocker
(
)
;
mStyleImageLoader
=
new
css
:
:
ImageLoader
(
this
)
;
mNodeInfoManager
=
new
nsNodeInfoManager
(
this
aPrincipal
)
;
mNodeInfo
=
mNodeInfoManager
-
>
GetDocumentNodeInfo
(
)
;
NS_ENSURE_TRUE
(
mNodeInfo
NS_ERROR_OUT_OF_MEMORY
)
;
MOZ_ASSERT
(
mNodeInfo
-
>
NodeType
(
)
=
=
DOCUMENT_NODE
"
Bad
NodeType
in
aNodeInfo
"
)
;
NS_ASSERTION
(
OwnerDoc
(
)
=
=
this
"
Our
nodeinfo
is
busted
!
"
)
;
mCSSLoader
=
new
css
:
:
Loader
(
this
)
;
mCSSLoader
-
>
SetCompatibilityMode
(
eCompatibility_FullStandards
)
;
nsCOMPtr
<
nsIGlobalObject
>
global
=
xpc
:
:
NativeGlobal
(
xpc
:
:
PrivilegedJunkScope
(
)
)
;
NS_ENSURE_TRUE
(
global
NS_ERROR_FAILURE
)
;
mScopeObject
=
do_GetWeakReference
(
global
)
;
MOZ_ASSERT
(
mScopeObject
)
;
mScriptLoader
=
new
dom
:
:
ScriptLoader
(
this
)
;
mFeaturePolicy
=
new
dom
:
:
FeaturePolicy
(
this
)
;
mFeaturePolicy
-
>
SetDefaultOrigin
(
NodePrincipal
(
)
)
;
if
(
aPrincipal
)
{
SetPrincipals
(
aPrincipal
aPartitionedPrincipal
)
;
}
else
{
RecomputeResistFingerprinting
(
)
;
}
return
NS_OK
;
}
void
Document
:
:
RemoveAllProperties
(
)
{
PropertyTable
(
)
.
RemoveAllProperties
(
)
;
}
void
Document
:
:
RemoveAllPropertiesFor
(
nsINode
*
aNode
)
{
PropertyTable
(
)
.
RemoveAllPropertiesFor
(
aNode
)
;
}
void
Document
:
:
Reset
(
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsCOMPtr
<
nsIPrincipal
>
partitionedPrincipal
;
if
(
aChannel
)
{
NS_GetFinalChannelURI
(
aChannel
getter_AddRefs
(
uri
)
)
;
nsIScriptSecurityManager
*
securityManager
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
securityManager
)
{
securityManager
-
>
GetChannelResultPrincipals
(
aChannel
getter_AddRefs
(
principal
)
getter_AddRefs
(
partitionedPrincipal
)
)
;
}
}
bool
equal
=
principal
-
>
Equals
(
partitionedPrincipal
)
;
principal
=
MaybeDowngradePrincipal
(
principal
)
;
if
(
equal
)
{
partitionedPrincipal
=
principal
;
}
else
{
partitionedPrincipal
=
MaybeDowngradePrincipal
(
partitionedPrincipal
)
;
}
ResetToURI
(
uri
aLoadGroup
principal
partitionedPrincipal
)
;
mDocumentTimeline
=
nullptr
;
if
(
nsCOMPtr
<
nsIPropertyBag2
>
bag
=
do_QueryInterface
(
aChannel
)
)
{
if
(
nsCOMPtr
<
nsIURI
>
baseURI
=
do_GetProperty
(
bag
u
"
baseURI
"
_ns
)
)
{
mDocumentBaseURI
=
baseURI
.
forget
(
)
;
mChromeXHRDocBaseURI
=
nullptr
;
}
}
mChannel
=
aChannel
;
RecomputeResistFingerprinting
(
)
;
}
void
Document
:
:
DisconnectNodeTree
(
)
{
delete
mSubDocuments
;
mSubDocuments
=
nullptr
;
bool
oldVal
=
mInUnlinkOrDeletion
;
mInUnlinkOrDeletion
=
true
;
{
MOZ_AUTO_DOC_UPDATE
(
this
true
)
;
DestroyElementMaps
(
)
;
InvalidateChildNodes
(
)
;
while
(
HasChildren
(
)
)
{
nsMutationGuard
:
:
DidMutate
(
)
;
nsCOMPtr
<
nsIContent
>
content
=
GetLastChild
(
)
;
nsIContent
*
previousSibling
=
content
-
>
GetPreviousSibling
(
)
;
DisconnectChild
(
content
)
;
if
(
content
=
=
mCachedRootElement
)
{
mCachedRootElement
=
nullptr
;
}
MutationObservers
:
:
NotifyContentRemoved
(
this
content
previousSibling
)
;
content
-
>
UnbindFromTree
(
)
;
}
MOZ_ASSERT
(
!
mCachedRootElement
"
After
removing
all
children
there
should
be
no
root
elem
"
)
;
}
mInUnlinkOrDeletion
=
oldVal
;
}
void
Document
:
:
ResetToURI
(
nsIURI
*
aURI
nsILoadGroup
*
aLoadGroup
nsIPrincipal
*
aPrincipal
nsIPrincipal
*
aPartitionedPrincipal
)
{
MOZ_ASSERT
(
aURI
"
Null
URI
passed
to
ResetToURI
"
)
;
MOZ_ASSERT
(
!
!
aPrincipal
=
=
!
!
aPartitionedPrincipal
)
;
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
ResetToURI
%
s
"
this
aURI
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
mSecurityInfo
=
nullptr
;
nsCOMPtr
<
nsILoadGroup
>
group
=
do_QueryReferent
(
mDocumentLoadGroup
)
;
if
(
!
aLoadGroup
|
|
group
!
=
aLoadGroup
)
{
mDocumentLoadGroup
=
nullptr
;
}
DisconnectNodeTree
(
)
;
ResetStylesheetsToURI
(
aURI
)
;
if
(
mListenerManager
)
{
mListenerManager
-
>
Disconnect
(
)
;
mListenerManager
=
nullptr
;
}
mDOMStyleSheets
=
nullptr
;
SetPrincipals
(
nullptr
nullptr
)
;
mOriginalURI
=
nullptr
;
SetDocumentURI
(
aURI
)
;
mChromeXHRDocURI
=
nullptr
;
mDocumentBaseURI
=
nullptr
;
mChromeXHRDocBaseURI
=
nullptr
;
if
(
aLoadGroup
)
{
mDocumentLoadGroup
=
do_GetWeakReference
(
aLoadGroup
)
;
if
(
IsContentDocument
(
)
)
{
nsCOMPtr
<
nsIRequestContextService
>
rcsvc
=
net
:
:
RequestContextService
:
:
GetOrCreate
(
)
;
if
(
rcsvc
)
{
nsCOMPtr
<
nsIRequestContext
>
rc
;
rcsvc
-
>
GetRequestContextFromLoadGroup
(
aLoadGroup
getter_AddRefs
(
rc
)
)
;
if
(
rc
)
{
rc
-
>
BeginLoad
(
)
;
}
}
}
}
mLastModified
.
Truncate
(
)
;
SetContentType
(
"
"
_ns
)
;
mContentLanguage
=
nullptr
;
mBaseTarget
.
Truncate
(
)
;
mXMLDeclarationBits
=
0
;
if
(
aPrincipal
)
{
SetPrincipals
(
aPrincipal
aPartitionedPrincipal
)
;
}
else
{
nsIScriptSecurityManager
*
securityManager
=
nsContentUtils
:
:
GetSecurityManager
(
)
;
if
(
securityManager
)
{
nsCOMPtr
<
nsILoadContext
>
loadContext
(
mDocumentContainer
)
;
if
(
!
loadContext
&
&
aLoadGroup
)
{
nsCOMPtr
<
nsIInterfaceRequestor
>
cbs
;
aLoadGroup
-
>
GetNotificationCallbacks
(
getter_AddRefs
(
cbs
)
)
;
loadContext
=
do_GetInterface
(
cbs
)
;
}
MOZ_ASSERT
(
loadContext
"
must
have
a
load
context
or
pass
in
an
explicit
principal
"
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
;
nsresult
rv
=
securityManager
-
>
GetLoadContextContentPrincipal
(
mDocumentURI
loadContext
getter_AddRefs
(
principal
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
SetPrincipals
(
principal
principal
)
;
}
}
}
if
(
mFontFaceSet
)
{
mFontFaceSet
-
>
RefreshStandardFontLoadPrincipal
(
)
;
}
if
(
nsPIDOMWindowInner
*
win
=
GetInnerWindow
(
)
)
{
nsGlobalWindowInner
:
:
Cast
(
win
)
-
>
RefreshRealmPrincipal
(
)
;
}
}
already_AddRefed
<
nsIPrincipal
>
Document
:
:
MaybeDowngradePrincipal
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
aPrincipal
)
{
return
nullptr
;
}
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
aPrincipal
)
;
if
(
basePrin
-
>
Is
<
ExpandedPrincipal
>
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Should
never
try
to
create
a
document
with
"
"
an
expanded
principal
"
)
;
auto
*
expanded
=
basePrin
-
>
As
<
ExpandedPrincipal
>
(
)
;
return
do_AddRef
(
expanded
-
>
AllowList
(
)
.
LastElement
(
)
)
;
}
if
(
aPrincipal
-
>
IsSystemPrincipal
(
)
&
&
mDocumentContainer
)
{
if
(
RefPtr
<
BrowsingContext
>
parent
=
mDocumentContainer
-
>
GetBrowsingContext
(
)
-
>
GetParent
(
)
)
{
auto
*
parentWin
=
nsGlobalWindowOuter
:
:
Cast
(
parent
-
>
GetDOMWindow
(
)
)
;
if
(
!
parentWin
|
|
!
parentWin
-
>
GetPrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
nsCOMPtr
<
nsIPrincipal
>
nullPrincipal
=
NullPrincipal
:
:
CreateWithoutOriginAttributes
(
)
;
return
nullPrincipal
.
forget
(
)
;
}
}
}
nsCOMPtr
<
nsIPrincipal
>
principal
(
aPrincipal
)
;
return
principal
.
forget
(
)
;
}
size_t
Document
:
:
FindDocStyleSheetInsertionPoint
(
const
StyleSheet
&
aSheet
)
{
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
ServoStyleSet
&
styleSet
=
EnsureStyleSet
(
)
;
int32_t
newDocIndex
=
StyleOrderIndexOfSheet
(
aSheet
)
;
size_t
count
=
styleSet
.
SheetCount
(
StyleOrigin
:
:
Author
)
;
size_t
index
=
0
;
for
(
;
index
<
count
;
index
+
+
)
{
auto
*
sheet
=
styleSet
.
SheetAt
(
StyleOrigin
:
:
Author
index
)
;
MOZ_ASSERT
(
sheet
)
;
int32_t
sheetDocIndex
=
StyleOrderIndexOfSheet
(
*
sheet
)
;
if
(
sheetDocIndex
>
newDocIndex
)
{
break
;
}
if
(
sheetDocIndex
<
0
)
{
if
(
sheetService
)
{
auto
&
authorSheets
=
*
sheetService
-
>
AuthorStyleSheets
(
)
;
if
(
authorSheets
.
IndexOf
(
sheet
)
!
=
authorSheets
.
NoIndex
)
{
break
;
}
}
if
(
sheet
=
=
GetFirstAdditionalAuthorSheet
(
)
)
{
break
;
}
}
}
return
index
;
}
void
Document
:
:
ResetStylesheetsToURI
(
nsIURI
*
aURI
)
{
MOZ_ASSERT
(
aURI
)
;
ClearAdoptedStyleSheets
(
)
;
ServoStyleSet
&
styleSet
=
EnsureStyleSet
(
)
;
auto
ClearSheetList
=
[
&
]
(
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheetList
)
{
for
(
auto
&
sheet
:
Reversed
(
aSheetList
)
)
{
sheet
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
if
(
mStyleSetFilled
)
{
styleSet
.
RemoveStyleSheet
(
*
sheet
)
;
}
}
aSheetList
.
Clear
(
)
;
}
;
ClearSheetList
(
mStyleSheets
)
;
for
(
auto
&
sheets
:
mAdditionalSheets
)
{
ClearSheetList
(
sheets
)
;
}
if
(
mStyleSetFilled
)
{
if
(
auto
*
ss
=
nsStyleSheetService
:
:
GetInstance
(
)
)
{
for
(
auto
&
sheet
:
Reversed
(
*
ss
-
>
AuthorStyleSheets
(
)
)
)
{
MOZ_ASSERT
(
!
sheet
-
>
GetAssociatedDocumentOrShadowRoot
(
)
)
;
if
(
sheet
-
>
IsApplicable
(
)
)
{
styleSet
.
RemoveStyleSheet
(
*
sheet
)
;
}
}
}
}
if
(
mAttributeStyles
)
{
mAttributeStyles
-
>
Reset
(
)
;
mAttributeStyles
-
>
SetOwningDocument
(
this
)
;
}
else
{
mAttributeStyles
=
new
AttributeStyles
(
this
)
;
}
if
(
mStyleSetFilled
)
{
FillStyleSetDocumentSheets
(
)
;
if
(
styleSet
.
StyleSheetsHaveChanged
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
}
static
void
AppendSheetsToStyleSet
(
ServoStyleSet
*
aStyleSet
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
)
{
for
(
StyleSheet
*
sheet
:
Reversed
(
aSheets
)
)
{
aStyleSet
-
>
AppendStyleSheet
(
*
sheet
)
;
}
}
void
Document
:
:
FillStyleSetUserAndUASheets
(
)
{
auto
*
cache
=
GlobalStyleSheetCache
:
:
Singleton
(
)
;
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
MOZ_ASSERT
(
sheetService
"
should
never
be
creating
a
StyleSet
after
the
style
sheet
"
"
service
has
gone
"
)
;
ServoStyleSet
&
styleSet
=
EnsureStyleSet
(
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
UserStyleSheets
(
)
)
{
styleSet
.
AppendStyleSheet
(
*
sheet
)
;
}
StyleSheet
*
sheet
=
IsInChromeDocShell
(
)
?
cache
-
>
GetUserChromeSheet
(
)
:
cache
-
>
GetUserContentSheet
(
)
;
if
(
sheet
)
{
styleSet
.
AppendStyleSheet
(
*
sheet
)
;
}
styleSet
.
AppendStyleSheet
(
*
cache
-
>
UASheet
(
)
)
;
if
(
MOZ_LIKELY
(
NodeInfoManager
(
)
-
>
MathMLEnabled
(
)
)
)
{
styleSet
.
AppendStyleSheet
(
*
cache
-
>
MathMLSheet
(
)
)
;
}
if
(
MOZ_LIKELY
(
NodeInfoManager
(
)
-
>
SVGEnabled
(
)
)
)
{
styleSet
.
AppendStyleSheet
(
*
cache
-
>
SVGSheet
(
)
)
;
}
styleSet
.
AppendStyleSheet
(
*
cache
-
>
HTMLSheet
(
)
)
;
if
(
nsLayoutUtils
:
:
ShouldUseNoFramesSheet
(
this
)
)
{
styleSet
.
AppendStyleSheet
(
*
cache
-
>
NoFramesSheet
(
)
)
;
}
styleSet
.
AppendStyleSheet
(
*
cache
-
>
CounterStylesSheet
(
)
)
;
if
(
LoadsFullXULStyleSheetUpFront
(
)
)
{
styleSet
.
AppendStyleSheet
(
*
cache
-
>
XULSheet
(
)
)
;
}
styleSet
.
AppendStyleSheet
(
*
cache
-
>
FormsSheet
(
)
)
;
styleSet
.
AppendStyleSheet
(
*
cache
-
>
ScrollbarsSheet
(
)
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
AgentStyleSheets
(
)
)
{
styleSet
.
AppendStyleSheet
(
*
sheet
)
;
}
MOZ_ASSERT
(
!
mQuirkSheetAdded
)
;
if
(
NeedsQuirksSheet
(
)
)
{
styleSet
.
AppendStyleSheet
(
*
cache
-
>
QuirkSheet
(
)
)
;
mQuirkSheetAdded
=
true
;
}
}
void
Document
:
:
FillStyleSet
(
)
{
MOZ_ASSERT
(
!
mStyleSetFilled
)
;
FillStyleSetUserAndUASheets
(
)
;
FillStyleSetDocumentSheets
(
)
;
mStyleSetFilled
=
true
;
}
void
Document
:
:
RemoveContentEditableStyleSheets
(
)
{
MOZ_ASSERT
(
IsHTMLOrXHTML
(
)
)
;
ServoStyleSet
&
styleSet
=
EnsureStyleSet
(
)
;
auto
*
cache
=
GlobalStyleSheetCache
:
:
Singleton
(
)
;
bool
changed
=
false
;
if
(
mDesignModeSheetAdded
)
{
styleSet
.
RemoveStyleSheet
(
*
cache
-
>
DesignModeSheet
(
)
)
;
mDesignModeSheetAdded
=
false
;
changed
=
true
;
}
if
(
mContentEditableSheetAdded
)
{
styleSet
.
RemoveStyleSheet
(
*
cache
-
>
ContentEditableSheet
(
)
)
;
mContentEditableSheetAdded
=
false
;
changed
=
true
;
}
if
(
changed
)
{
MOZ_ASSERT
(
mStyleSetFilled
)
;
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
AddContentEditableStyleSheetsToStyleSet
(
bool
aDesignMode
)
{
MOZ_ASSERT
(
IsHTMLOrXHTML
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mStyleSetFilled
"
Caller
should
ensure
we
'
re
being
rendered
"
)
;
ServoStyleSet
&
styleSet
=
EnsureStyleSet
(
)
;
auto
*
cache
=
GlobalStyleSheetCache
:
:
Singleton
(
)
;
bool
changed
=
false
;
if
(
!
mContentEditableSheetAdded
)
{
styleSet
.
AppendStyleSheet
(
*
cache
-
>
ContentEditableSheet
(
)
)
;
mContentEditableSheetAdded
=
true
;
changed
=
true
;
}
if
(
mDesignModeSheetAdded
!
=
aDesignMode
)
{
if
(
mDesignModeSheetAdded
)
{
styleSet
.
RemoveStyleSheet
(
*
cache
-
>
DesignModeSheet
(
)
)
;
}
else
{
styleSet
.
AppendStyleSheet
(
*
cache
-
>
DesignModeSheet
(
)
)
;
}
mDesignModeSheetAdded
=
!
mDesignModeSheetAdded
;
changed
=
true
;
}
if
(
changed
)
{
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
FillStyleSetDocumentSheets
(
)
{
ServoStyleSet
&
styleSet
=
EnsureStyleSet
(
)
;
MOZ_ASSERT
(
styleSet
.
SheetCount
(
StyleOrigin
:
:
Author
)
=
=
0
"
Style
set
already
has
document
sheets
?
"
)
;
for
(
StyleSheet
*
sheet
:
Reversed
(
mStyleSheets
)
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
styleSet
.
AddDocStyleSheet
(
*
sheet
)
;
}
}
EnumerateUniqueAdoptedStyleSheetsBackToFront
(
[
&
]
(
StyleSheet
&
aSheet
)
{
if
(
aSheet
.
IsApplicable
(
)
)
{
styleSet
.
AddDocStyleSheet
(
aSheet
)
;
}
}
)
;
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
AuthorStyleSheets
(
)
)
{
styleSet
.
AppendStyleSheet
(
*
sheet
)
;
}
AppendSheetsToStyleSet
(
&
styleSet
mAdditionalSheets
[
eAgentSheet
]
)
;
AppendSheetsToStyleSet
(
&
styleSet
mAdditionalSheets
[
eUserSheet
]
)
;
AppendSheetsToStyleSet
(
&
styleSet
mAdditionalSheets
[
eAuthorSheet
]
)
;
}
void
Document
:
:
CompatibilityModeChanged
(
)
{
MOZ_ASSERT
(
IsHTMLOrXHTML
(
)
)
;
CSSLoader
(
)
-
>
SetCompatibilityMode
(
mCompatMode
)
;
if
(
mStyleSet
)
{
mStyleSet
-
>
CompatibilityModeChanged
(
)
;
}
if
(
!
mStyleSetFilled
)
{
MOZ_ASSERT
(
!
mQuirkSheetAdded
)
;
return
;
}
MOZ_ASSERT
(
mStyleSet
)
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
EnsureStyleFlush
(
)
;
}
if
(
mQuirkSheetAdded
=
=
NeedsQuirksSheet
(
)
)
{
return
;
}
auto
*
cache
=
GlobalStyleSheetCache
:
:
Singleton
(
)
;
StyleSheet
*
sheet
=
cache
-
>
QuirkSheet
(
)
;
if
(
mQuirkSheetAdded
)
{
mStyleSet
-
>
RemoveStyleSheet
(
*
sheet
)
;
}
else
{
mStyleSet
-
>
AppendStyleSheet
(
*
sheet
)
;
}
mQuirkSheetAdded
=
!
mQuirkSheetAdded
;
ApplicableStylesChanged
(
)
;
}
void
Document
:
:
SetCompatibilityMode
(
nsCompatibility
aMode
)
{
NS_ASSERTION
(
IsHTMLDocument
(
)
|
|
aMode
=
=
eCompatibility_FullStandards
"
Bad
compat
mode
for
XHTML
document
!
"
)
;
if
(
mCompatMode
=
=
aMode
)
{
return
;
}
mCompatMode
=
aMode
;
CompatibilityModeChanged
(
)
;
mViewportType
=
Unknown
;
}
static
void
WarnIfSandboxIneffective
(
nsIDocShell
*
aDocShell
uint32_t
aSandboxFlags
nsIChannel
*
aChannel
)
{
if
(
aSandboxFlags
!
=
SANDBOXED_NONE
&
&
!
(
aSandboxFlags
&
SANDBOXED_TOPLEVEL_NAVIGATION
)
&
&
!
(
aSandboxFlags
&
SANDBOXED_TOPLEVEL_NAVIGATION_USER_ACTIVATION
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Iframe
Sandbox
"
_ns
aDocShell
-
>
GetDocument
(
)
nsContentUtils
:
:
eSECURITY_PROPERTIES
"
BothAllowTopNavigationAndUserActivationPresent
"
)
;
}
if
(
aSandboxFlags
&
SANDBOXED_NAVIGATION
&
&
!
(
aSandboxFlags
&
SANDBOXED_SCRIPTS
)
&
&
!
(
aSandboxFlags
&
SANDBOXED_ORIGIN
)
)
{
RefPtr
<
BrowsingContext
>
bc
=
aDocShell
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
bc
-
>
IsInProcess
(
)
)
;
RefPtr
<
BrowsingContext
>
parentBC
=
bc
-
>
GetParent
(
)
;
if
(
!
parentBC
|
|
!
parentBC
-
>
IsInProcess
(
)
)
{
return
;
}
if
(
!
parentBC
-
>
IsTopContent
(
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
parentDocShell
=
parentBC
-
>
GetDocShell
(
)
;
MOZ_ASSERT
(
parentDocShell
)
;
nsCOMPtr
<
nsIChannel
>
parentChannel
;
parentDocShell
-
>
GetCurrentDocumentChannel
(
getter_AddRefs
(
parentChannel
)
)
;
if
(
!
parentChannel
)
{
return
;
}
nsresult
rv
=
nsContentUtils
:
:
CheckSameOrigin
(
aChannel
parentChannel
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
Document
>
parentDocument
=
parentDocShell
-
>
GetDocument
(
)
;
nsCOMPtr
<
nsIURI
>
iframeUri
;
parentChannel
-
>
GetURI
(
getter_AddRefs
(
iframeUri
)
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Iframe
Sandbox
"
_ns
parentDocument
nsContentUtils
:
:
eSECURITY_PROPERTIES
"
BothAllowScriptsAndSameOriginPresent
"
nsTArray
<
nsString
>
(
)
iframeUri
)
;
}
}
bool
Document
:
:
IsSynthesized
(
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
?
mChannel
-
>
LoadInfo
(
)
:
nullptr
;
return
loadInfo
&
&
loadInfo
-
>
GetServiceWorkerTaintingSynthesized
(
)
;
}
bool
Document
:
:
IsCallerChromeOrAddon
(
JSContext
*
aCx
JSObject
*
aObject
)
{
nsIPrincipal
*
principal
=
nsContentUtils
:
:
SubjectPrincipal
(
aCx
)
;
return
principal
&
&
(
principal
-
>
IsSystemPrincipal
(
)
|
|
principal
-
>
GetIsAddonOrExpandedAddonPrincipal
(
)
)
;
}
static
void
CheckIsBadPolicy
(
nsILoadInfo
:
:
CrossOriginOpenerPolicy
aPolicy
BrowsingContext
*
aContext
nsIChannel
*
aChannel
)
{
#
if
defined
(
EARLY_BETA_OR_EARLIER
)
auto
requireCORP
=
nsILoadInfo
:
:
OPENER_POLICY_SAME_ORIGIN_EMBEDDER_POLICY_REQUIRE_CORP
;
if
(
aContext
-
>
GetOpenerPolicy
(
)
=
=
aPolicy
|
|
(
aContext
-
>
GetOpenerPolicy
(
)
!
=
requireCORP
&
&
aPolicy
!
=
requireCORP
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
bool
hasURI
=
NS_SUCCEEDED
(
aChannel
-
>
GetOriginalURI
(
getter_AddRefs
(
uri
)
)
)
;
bool
isViewSource
=
hasURI
&
&
uri
-
>
SchemeIs
(
"
view
-
source
"
)
;
nsCString
contentType
;
nsCOMPtr
<
nsIPropertyBag2
>
bag
=
do_QueryInterface
(
aChannel
)
;
bool
isPDFJS
=
bag
&
&
NS_SUCCEEDED
(
bag
-
>
GetPropertyAsACString
(
u
"
contentType
"
_ns
contentType
)
)
&
&
contentType
.
EqualsLiteral
(
APPLICATION_PDF
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
isViewSource
"
Bug
1834864
:
Assert
due
to
view
-
source
.
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
isPDFJS
"
Bug
1834864
:
Assert
due
to
pdfjs
.
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aPolicy
=
=
requireCORP
"
Assert
due
to
clearing
REQUIRE_CORP
.
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aContext
-
>
GetOpenerPolicy
(
)
=
=
requireCORP
"
Assert
due
to
setting
REQUIRE_CORP
.
"
)
;
#
endif
}
nsresult
Document
:
:
StartDocumentLoad
(
const
char
*
aCommand
nsIChannel
*
aChannel
nsILoadGroup
*
aLoadGroup
nsISupports
*
aContainer
nsIStreamListener
*
*
aDocListener
bool
aReset
)
{
if
(
MOZ_LOG_TEST
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
StartDocumentLoad
%
s
"
this
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
}
MOZ_ASSERT
(
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_UNINITIALIZED
"
Bad
readyState
"
)
;
SetReadyStateInternal
(
READYSTATE_LOADING
)
;
if
(
nsCRT
:
:
strcmp
(
kLoadAsData
aCommand
)
=
=
0
)
{
mLoadedAsData
=
true
;
SetLoadedAsData
(
true
true
)
;
ScriptLoader
(
)
-
>
SetEnabled
(
false
)
;
CSSLoader
(
)
-
>
SetEnabled
(
false
)
;
}
else
if
(
nsCRT
:
:
strcmp
(
"
external
-
resource
"
aCommand
)
=
=
0
)
{
ScriptLoader
(
)
-
>
SetEnabled
(
false
)
;
}
mMayStartLayout
=
false
;
MOZ_ASSERT
(
!
mReadyForIdle
"
We
should
never
hit
DOMContentLoaded
before
this
point
"
)
;
if
(
aReset
)
{
Reset
(
aChannel
aLoadGroup
)
;
}
nsAutoCString
contentType
;
nsCOMPtr
<
nsIPropertyBag2
>
bag
=
do_QueryInterface
(
aChannel
)
;
if
(
(
bag
&
&
NS_SUCCEEDED
(
bag
-
>
GetPropertyAsACString
(
u
"
contentType
"
_ns
contentType
)
)
)
|
|
NS_SUCCEEDED
(
aChannel
-
>
GetContentType
(
contentType
)
)
)
{
nsACString
:
:
const_iterator
start
end
semicolon
;
contentType
.
BeginReading
(
start
)
;
contentType
.
EndReading
(
end
)
;
semicolon
=
start
;
FindCharInReadable
(
'
;
'
semicolon
end
)
;
SetContentType
(
Substring
(
start
semicolon
)
)
;
}
RetrieveRelevantHeaders
(
aChannel
)
;
mChannel
=
aChannel
;
RecomputeResistFingerprinting
(
)
;
nsCOMPtr
<
nsIInputStreamChannel
>
inStrmChan
=
do_QueryInterface
(
mChannel
)
;
if
(
inStrmChan
)
{
bool
isSrcdocChannel
;
inStrmChan
-
>
GetIsSrcdocChannel
(
&
isSrcdocChannel
)
;
if
(
isSrcdocChannel
)
{
mIsSrcdocDocument
=
true
;
}
}
if
(
mChannel
)
{
nsLoadFlags
loadFlags
;
mChannel
-
>
GetLoadFlags
(
&
loadFlags
)
;
bool
isDocument
=
false
;
mChannel
-
>
GetIsDocument
(
&
isDocument
)
;
if
(
loadFlags
&
nsIRequest
:
:
LOAD_DOCUMENT_NEEDS_COOKIE
&
&
isDocument
&
&
IsSynthesized
(
)
&
&
XRE_IsContentProcess
(
)
)
{
ContentChild
:
:
UpdateCookieStatus
(
mChannel
)
;
}
mChannel
-
>
GetSecurityInfo
(
getter_AddRefs
(
mSecurityInfo
)
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
aContainer
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
if
(
docShell
&
&
!
loadInfo
-
>
GetLoadErrorPage
(
)
)
{
mSandboxFlags
=
loadInfo
-
>
GetSandboxFlags
(
)
;
WarnIfSandboxIneffective
(
docShell
mSandboxFlags
GetChannel
(
)
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
httpChan
=
do_QueryInterface
(
mChannel
)
;
nsILoadInfo
:
:
CrossOriginOpenerPolicy
policy
=
nsILoadInfo
:
:
OPENER_POLICY_UNSAFE_NONE
;
if
(
IsTopLevelContentDocument
(
)
&
&
httpChan
&
&
NS_SUCCEEDED
(
httpChan
-
>
GetCrossOriginOpenerPolicy
(
&
policy
)
)
&
&
docShell
&
&
docShell
-
>
GetBrowsingContext
(
)
)
{
CheckIsBadPolicy
(
policy
docShell
-
>
GetBrowsingContext
(
)
aChannel
)
;
Unused
<
<
docShell
-
>
GetBrowsingContext
(
)
-
>
SetOpenerPolicy
(
policy
)
;
}
mUpgradeInsecureRequests
=
loadInfo
-
>
GetUpgradeInsecureRequests
(
)
;
mUpgradeInsecurePreloads
=
mUpgradeInsecureRequests
;
mBlockAllMixedContent
=
loadInfo
-
>
GetBlockAllMixedContent
(
)
;
mBlockAllMixedContentPreloads
=
mBlockAllMixedContent
;
mHttpsOnlyStatus
=
loadInfo
-
>
GetHttpsOnlyStatus
(
)
;
nsresult
rv
=
InitReferrerInfo
(
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InitCOEP
(
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsIContentSecurityPolicy
>
cspToInherit
=
loadInfo
-
>
GetCspToInherit
(
)
;
if
(
cspToInherit
)
{
bool
allowsNavigateTo
=
false
;
rv
=
cspToInherit
-
>
GetAllowsNavigateTo
(
mDocumentURI
loadInfo
-
>
GetIsFormSubmission
(
)
!
loadInfo
-
>
RedirectChain
(
)
.
IsEmpty
(
)
true
&
allowsNavigateTo
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
allowsNavigateTo
)
{
aChannel
-
>
Cancel
(
NS_ERROR_CSP_NAVIGATE_TO_VIOLATION
)
;
return
NS_OK
;
}
}
rv
=
InitCSP
(
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
InitFeaturePolicy
(
aChannel
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
loadInfo
-
>
GetCookieJarSettings
(
getter_AddRefs
(
mCookieJarSettings
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsContentPolicyType
internalContentType
=
loadInfo
-
>
InternalContentPolicyType
(
)
;
if
(
internalContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_OBJECT
|
|
internalContentType
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_EMBED
)
{
nsContentSecurityUtils
:
:
PerformCSPFrameAncestorAndXFOCheck
(
aChannel
)
;
nsresult
status
;
aChannel
-
>
GetStatus
(
&
status
)
;
if
(
status
=
=
NS_ERROR_XFO_VIOLATION
)
{
RefPtr
<
NullPrincipal
>
nullPrincipal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
NodePrincipal
(
)
)
;
MOZ_ASSERT
(
!
mFontFaceSet
&
&
!
GetInnerWindow
(
)
)
;
SetPrincipals
(
nullPrincipal
nullPrincipal
)
;
}
}
return
NS_OK
;
}
void
Document
:
:
SetLoadedAsData
(
bool
aLoadedAsData
bool
aConsiderForMemoryReporting
)
{
mLoadedAsData
=
aLoadedAsData
;
if
(
aConsiderForMemoryReporting
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
global
)
{
if
(
nsPIDOMWindowInner
*
window
=
global
-
>
GetAsInnerWindow
(
)
)
{
nsGlobalWindowInner
:
:
Cast
(
window
)
-
>
RegisterDataDocumentForMemoryReporting
(
this
)
;
}
}
}
}
nsIContentSecurityPolicy
*
Document
:
:
GetCsp
(
)
const
{
return
mCSP
;
}
void
Document
:
:
SetCsp
(
nsIContentSecurityPolicy
*
aCSP
)
{
mCSP
=
aCSP
;
}
nsIContentSecurityPolicy
*
Document
:
:
GetPreloadCsp
(
)
const
{
return
mPreloadCSP
;
}
void
Document
:
:
SetPreloadCsp
(
nsIContentSecurityPolicy
*
aPreloadCSP
)
{
mPreloadCSP
=
aPreloadCSP
;
}
void
Document
:
:
GetCspJSON
(
nsString
&
aJSON
)
{
aJSON
.
Truncate
(
)
;
if
(
!
mCSP
)
{
dom
:
:
CSPPolicies
jsonPolicies
;
jsonPolicies
.
ToJSON
(
aJSON
)
;
return
;
}
mCSP
-
>
ToJSON
(
aJSON
)
;
}
void
Document
:
:
SendToConsole
(
nsCOMArray
<
nsISecurityConsoleMessage
>
&
aMessages
)
{
for
(
uint32_t
i
=
0
;
i
<
aMessages
.
Length
(
)
;
+
+
i
)
{
nsAutoString
messageTag
;
aMessages
[
i
]
-
>
GetTag
(
messageTag
)
;
nsAutoString
category
;
aMessages
[
i
]
-
>
GetCategory
(
category
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_ConvertUTF16toUTF8
(
category
)
this
nsContentUtils
:
:
eSECURITY_PROPERTIES
NS_ConvertUTF16toUTF8
(
messageTag
)
.
get
(
)
)
;
}
}
void
Document
:
:
ApplySettingsFromCSP
(
bool
aSpeculative
)
{
nsresult
rv
=
NS_OK
;
if
(
!
aSpeculative
)
{
if
(
mCSP
)
{
if
(
!
mBlockAllMixedContent
)
{
bool
block
=
false
;
rv
=
mCSP
-
>
GetBlockAllMixedContent
(
&
block
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mBlockAllMixedContent
=
block
;
}
if
(
!
mBlockAllMixedContentPreloads
)
{
mBlockAllMixedContentPreloads
=
mBlockAllMixedContent
;
}
if
(
!
mUpgradeInsecureRequests
)
{
bool
upgrade
=
false
;
rv
=
mCSP
-
>
GetUpgradeInsecureRequests
(
&
upgrade
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mUpgradeInsecureRequests
=
upgrade
;
}
if
(
!
mUpgradeInsecurePreloads
)
{
mUpgradeInsecurePreloads
=
mUpgradeInsecureRequests
;
}
if
(
auto
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
SendUpdateDocumentCspSettings
(
mBlockAllMixedContent
mUpgradeInsecureRequests
)
;
}
}
return
;
}
if
(
mPreloadCSP
)
{
if
(
!
mBlockAllMixedContentPreloads
)
{
bool
block
=
false
;
rv
=
mPreloadCSP
-
>
GetBlockAllMixedContent
(
&
block
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mBlockAllMixedContent
=
block
;
}
if
(
!
mUpgradeInsecurePreloads
)
{
bool
upgrade
=
false
;
rv
=
mPreloadCSP
-
>
GetUpgradeInsecureRequests
(
&
upgrade
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
mUpgradeInsecurePreloads
=
upgrade
;
}
}
}
nsresult
Document
:
:
InitCSP
(
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
!
mScriptGlobalObject
"
CSP
must
be
initialized
before
mScriptGlobalObject
is
set
!
"
)
;
if
(
mLoadedAsData
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
aChannel
-
>
LoadInfo
(
)
;
if
(
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_IMAGE
|
|
loadInfo
-
>
GetExternalContentPolicyType
(
)
=
=
ExtContentPolicy
:
:
TYPE_IMAGESET
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
!
mCSP
"
where
did
mCSP
get
set
if
not
here
?
"
)
;
bool
inheritedCSP
=
CSP_ShouldResponseInheritCSP
(
aChannel
)
;
if
(
inheritedCSP
)
{
mCSP
=
loadInfo
-
>
GetCspToInherit
(
)
;
}
if
(
!
mCSP
)
{
mCSP
=
new
nsCSPContext
(
)
;
}
nsresult
rv
=
mCSP
-
>
SetRequestContextWithDocument
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsAutoCString
tCspHeaderValue
tCspROHeaderValue
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
httpChannel
)
{
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
"
content
-
security
-
policy
"
_ns
tCspHeaderValue
)
;
Unused
<
<
httpChannel
-
>
GetResponseHeader
(
"
content
-
security
-
policy
-
report
-
only
"
_ns
tCspROHeaderValue
)
;
}
NS_ConvertASCIItoUTF16
cspHeaderValue
(
tCspHeaderValue
)
;
NS_ConvertASCIItoUTF16
cspROHeaderValue
(
tCspROHeaderValue
)
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
NodePrincipal
(
)
;
auto
addonPolicy
=
BasePrincipal
:
:
Cast
(
principal
)
-
>
AddonPolicy
(
)
;
if
(
!
inheritedCSP
&
&
!
addonPolicy
&
&
cspHeaderValue
.
IsEmpty
(
)
&
&
cspROHeaderValue
.
IsEmpty
(
)
)
{
if
(
MOZ_LOG_TEST
(
gCspPRLog
LogLevel
:
:
Debug
)
)
{
nsCOMPtr
<
nsIURI
>
chanURI
;
aChannel
-
>
GetURI
(
getter_AddRefs
(
chanURI
)
)
;
nsAutoCString
aspec
;
chanURI
-
>
GetAsciiSpec
(
aspec
)
;
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
no
CSP
for
document
%
s
"
aspec
.
get
(
)
)
)
;
}
return
NS_OK
;
}
MOZ_LOG
(
gCspPRLog
LogLevel
:
:
Debug
(
"
Document
is
an
add
-
on
or
CSP
header
specified
%
p
"
this
)
)
;
if
(
addonPolicy
)
{
mCSP
-
>
AppendPolicy
(
addonPolicy
-
>
BaseCSP
(
)
false
false
)
;
mCSP
-
>
AppendPolicy
(
addonPolicy
-
>
ExtensionPageCSP
(
)
false
false
)
;
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
principal
)
;
if
(
basePrin
-
>
Is
<
ExpandedPrincipal
>
(
)
)
{
basePrin
-
>
As
<
ExpandedPrincipal
>
(
)
-
>
SetCsp
(
mCSP
)
;
}
}
if
(
!
cspHeaderValue
.
IsEmpty
(
)
)
{
mHasCSPDeliveredThroughHeader
=
true
;
rv
=
CSP_AppendCSPFromHeader
(
mCSP
cspHeaderValue
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
if
(
!
cspROHeaderValue
.
IsEmpty
(
)
)
{
rv
=
CSP_AppendCSPFromHeader
(
mCSP
cspROHeaderValue
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
uint32_t
cspSandboxFlags
=
SANDBOXED_NONE
;
rv
=
mCSP
-
>
GetCSPSandboxFlags
(
&
cspSandboxFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
needNewNullPrincipal
=
(
cspSandboxFlags
&
SANDBOXED_ORIGIN
)
&
&
!
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
;
mSandboxFlags
|
=
cspSandboxFlags
;
if
(
needNewNullPrincipal
)
{
principal
=
NullPrincipal
:
:
CreateWithInheritedAttributes
(
principal
)
;
SetPrincipals
(
principal
principal
)
;
}
ApplySettingsFromCSP
(
false
)
;
return
NS_OK
;
}
static
Document
*
GetInProcessParentDocumentFrom
(
BrowsingContext
*
aContext
)
{
BrowsingContext
*
parentContext
=
aContext
-
>
GetParent
(
)
;
if
(
!
parentContext
)
{
return
nullptr
;
}
WindowContext
*
windowContext
=
parentContext
-
>
GetCurrentWindowContext
(
)
;
if
(
!
windowContext
)
{
return
nullptr
;
}
return
windowContext
-
>
GetDocument
(
)
;
}
already_AddRefed
<
dom
:
:
FeaturePolicy
>
Document
:
:
GetParentFeaturePolicy
(
)
{
BrowsingContext
*
browsingContext
=
GetBrowsingContext
(
)
;
if
(
!
browsingContext
)
{
return
nullptr
;
}
if
(
!
browsingContext
-
>
IsContentSubframe
(
)
)
{
return
nullptr
;
}
HTMLIFrameElement
*
iframe
=
HTMLIFrameElement
:
:
FromNodeOrNull
(
browsingContext
-
>
GetEmbedderElement
(
)
)
;
if
(
iframe
)
{
return
do_AddRef
(
iframe
-
>
FeaturePolicy
(
)
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
return
do_AddRef
(
browsingContext
-
>
Canonical
(
)
-
>
GetContainerFeaturePolicy
(
)
)
;
}
if
(
Document
*
parentDocument
=
GetInProcessParentDocumentFrom
(
browsingContext
)
)
{
return
do_AddRef
(
parentDocument
-
>
FeaturePolicy
(
)
)
;
}
WindowContext
*
windowContext
=
browsingContext
-
>
GetCurrentWindowContext
(
)
;
if
(
!
windowContext
)
{
return
nullptr
;
}
WindowGlobalChild
*
child
=
windowContext
-
>
GetWindowGlobalChild
(
)
;
if
(
!
child
)
{
return
nullptr
;
}
return
do_AddRef
(
child
-
>
GetContainerFeaturePolicy
(
)
)
;
}
void
Document
:
:
InitFeaturePolicy
(
)
{
MOZ_ASSERT
(
mFeaturePolicy
"
we
should
have
FeaturePolicy
created
"
)
;
mFeaturePolicy
-
>
ResetDeclaredPolicy
(
)
;
mFeaturePolicy
-
>
SetDefaultOrigin
(
NodePrincipal
(
)
)
;
RefPtr
<
mozilla
:
:
dom
:
:
FeaturePolicy
>
parentPolicy
=
GetParentFeaturePolicy
(
)
;
if
(
parentPolicy
)
{
mFeaturePolicy
-
>
InheritPolicy
(
parentPolicy
)
;
mFeaturePolicy
-
>
SetSrcOrigin
(
parentPolicy
-
>
GetSrcOrigin
(
)
)
;
}
}
nsresult
Document
:
:
InitFeaturePolicy
(
nsIChannel
*
aChannel
)
{
InitFeaturePolicy
(
)
;
if
(
!
StaticPrefs
:
:
dom_security_featurePolicy_header_enabled
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
nsresult
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
httpChannel
)
{
return
NS_OK
;
}
nsAutoCString
value
;
rv
=
httpChannel
-
>
GetResponseHeader
(
"
Feature
-
Policy
"
_ns
value
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mFeaturePolicy
-
>
SetDeclaredPolicy
(
this
NS_ConvertUTF8toUTF16
(
value
)
NodePrincipal
(
)
nullptr
)
;
}
return
NS_OK
;
}
void
Document
:
:
EnsureNotEnteringAndExitFullscreen
(
)
{
Document
:
:
ClearPendingFullscreenRequests
(
this
)
;
if
(
GetFullscreenElement
(
)
)
{
Document
:
:
AsyncExitFullscreen
(
this
)
;
}
}
void
Document
:
:
SetReferrerInfo
(
nsIReferrerInfo
*
aReferrerInfo
)
{
mReferrerInfo
=
aReferrerInfo
;
mCachedReferrerInfoForInternalCSSAndSVGResources
=
nullptr
;
mCachedURLData
=
nullptr
;
}
nsresult
Document
:
:
InitReferrerInfo
(
nsIChannel
*
aChannel
)
{
MOZ_ASSERT
(
mReferrerInfo
)
;
MOZ_ASSERT
(
mPreloadReferrerInfo
)
;
if
(
ReferrerInfo
:
:
ShouldResponseInheritReferrerInfo
(
aChannel
)
)
{
if
(
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
)
{
Document
*
parentDoc
=
bc
-
>
GetEmbedderElement
(
)
?
bc
-
>
GetEmbedderElement
(
)
-
>
OwnerDoc
(
)
:
nullptr
;
if
(
parentDoc
)
{
SetReferrerInfo
(
parentDoc
-
>
GetReferrerInfo
(
)
)
;
mPreloadReferrerInfo
=
mReferrerInfo
;
return
NS_OK
;
}
MOZ_ASSERT
(
bc
-
>
IsInProcess
(
)
|
|
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
)
"
srcdoc
without
null
principal
as
toplevel
!
"
)
;
}
}
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
nsresult
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
if
(
!
httpChannel
)
{
return
NS_OK
;
}
if
(
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
httpChannel
-
>
GetReferrerInfo
(
)
)
{
SetReferrerInfo
(
referrerInfo
)
;
}
mozilla
:
:
dom
:
:
ReferrerPolicy
policy
=
nsContentUtils
:
:
GetReferrerPolicyFromChannel
(
aChannel
)
;
nsCOMPtr
<
nsIReferrerInfo
>
clone
=
static_cast
<
dom
:
:
ReferrerInfo
*
>
(
mReferrerInfo
.
get
(
)
)
-
>
CloneWithNewPolicy
(
policy
)
;
SetReferrerInfo
(
clone
)
;
mPreloadReferrerInfo
=
mReferrerInfo
;
return
NS_OK
;
}
nsresult
Document
:
:
InitCOEP
(
nsIChannel
*
aChannel
)
{
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
nsresult
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
intChannel
=
do_QueryInterface
(
httpChannel
)
;
if
(
!
intChannel
)
{
return
NS_OK
;
}
nsILoadInfo
:
:
CrossOriginEmbedderPolicy
policy
=
nsILoadInfo
:
:
EMBEDDER_POLICY_NULL
;
if
(
NS_SUCCEEDED
(
intChannel
-
>
GetResponseEmbedderPolicy
(
mTrials
.
IsEnabled
(
OriginTrial
:
:
CoepCredentialless
)
&
policy
)
)
)
{
mEmbedderPolicy
=
Some
(
policy
)
;
}
return
NS_OK
;
}
void
Document
:
:
StopDocumentLoad
(
)
{
if
(
mParser
)
{
mParserAborted
=
true
;
mParser
-
>
Terminate
(
)
;
}
}
void
Document
:
:
SetDocumentURI
(
nsIURI
*
aURI
)
{
nsCOMPtr
<
nsIURI
>
oldBase
=
GetDocBaseURI
(
)
;
mDocumentURI
=
aURI
;
nsIURI
*
newBase
=
GetDocBaseURI
(
)
;
mChromeRulesEnabled
=
URLExtraData
:
:
ChromeRulesEnabled
(
aURI
)
;
bool
equalBases
=
false
;
if
(
oldBase
&
&
newBase
)
{
oldBase
-
>
EqualsExceptRef
(
newBase
&
equalBases
)
;
}
else
{
equalBases
=
!
oldBase
&
&
!
newBase
;
}
if
(
!
mOriginalURI
)
mOriginalURI
=
mDocumentURI
;
if
(
!
equalBases
)
{
mCachedURLData
=
nullptr
;
RefreshLinkHrefs
(
)
;
}
mBaseDomain
.
Truncate
(
)
;
ThirdPartyUtil
*
thirdPartyUtil
=
ThirdPartyUtil
:
:
GetInstance
(
)
;
if
(
thirdPartyUtil
)
{
Unused
<
<
thirdPartyUtil
-
>
GetBaseDomain
(
mDocumentURI
mBaseDomain
)
;
}
if
(
WindowGlobalChild
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
SetDocumentURI
(
mDocumentURI
)
;
}
}
static
void
GetFormattedTimeString
(
PRTime
aTime
nsAString
&
aFormattedTimeString
)
{
PRExplodedTime
prtime
;
PR_ExplodeTime
(
aTime
PR_LocalTimeParameters
&
prtime
)
;
char
formatedTime
[
24
]
;
if
(
SprintfLiteral
(
formatedTime
"
%
02d
/
%
02d
/
%
04d
%
02d
:
%
02d
:
%
02d
"
prtime
.
tm_month
+
1
prtime
.
tm_mday
int
(
prtime
.
tm_year
)
prtime
.
tm_hour
prtime
.
tm_min
prtime
.
tm_sec
)
)
{
CopyASCIItoUTF16
(
nsDependentCString
(
formatedTime
)
aFormattedTimeString
)
;
}
else
{
aFormattedTimeString
.
AssignLiteral
(
u
"
01
/
01
/
1970
00
:
00
:
00
"
)
;
}
}
void
Document
:
:
GetLastModified
(
nsAString
&
aLastModified
)
const
{
if
(
!
mLastModified
.
IsEmpty
(
)
)
{
aLastModified
.
Assign
(
mLastModified
)
;
}
else
{
GetFormattedTimeString
(
PR_Now
(
)
aLastModified
)
;
}
}
static
void
IncrementExpandoGeneration
(
Document
&
aDoc
)
{
+
+
aDoc
.
mExpandoAndGeneration
.
generation
;
}
void
Document
:
:
AddToNameTable
(
Element
*
aElement
nsAtom
*
aName
)
{
MOZ_ASSERT
(
nsGenericHTMLElement
:
:
ShouldExposeNameAsHTMLDocumentProperty
(
aElement
)
"
Only
put
elements
that
need
to
be
exposed
as
document
[
'
name
'
]
in
"
"
the
named
table
.
"
)
;
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aName
)
;
if
(
entry
)
{
if
(
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
entry
-
>
AddNameElement
(
this
aElement
)
;
}
}
void
Document
:
:
RemoveFromNameTable
(
Element
*
aElement
nsAtom
*
aName
)
{
if
(
mIdentifierMap
.
Count
(
)
=
=
0
)
return
;
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aName
)
;
if
(
!
entry
)
return
;
entry
-
>
RemoveNameElement
(
aElement
)
;
if
(
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
}
void
Document
:
:
AddToIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aId
)
;
if
(
entry
)
{
if
(
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
aElement
)
&
&
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
entry
-
>
AddIdElement
(
aElement
)
;
}
}
void
Document
:
:
RemoveFromIdTable
(
Element
*
aElement
nsAtom
*
aId
)
{
NS_ASSERTION
(
aId
"
huhwhatnow
?
"
)
;
if
(
mIdentifierMap
.
Count
(
)
=
=
0
)
{
return
;
}
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
GetEntry
(
aId
)
;
if
(
!
entry
)
return
;
entry
-
>
RemoveIdElement
(
aElement
)
;
if
(
nsGenericHTMLElement
:
:
ShouldExposeIdAsHTMLDocumentProperty
(
aElement
)
&
&
!
entry
-
>
HasNameElement
(
)
&
&
!
entry
-
>
HasIdElementExposedAsHTMLDocumentProperty
(
)
)
{
IncrementExpandoGeneration
(
*
this
)
;
}
if
(
entry
-
>
IsEmpty
(
)
)
{
mIdentifierMap
.
RemoveEntry
(
entry
)
;
}
}
void
Document
:
:
UpdateReferrerInfoFromMeta
(
const
nsAString
&
aMetaReferrer
bool
aPreload
)
{
ReferrerPolicyEnum
policy
=
ReferrerInfo
:
:
ReferrerPolicyFromMetaString
(
aMetaReferrer
)
;
if
(
policy
=
=
ReferrerPolicy
:
:
_empty
)
{
return
;
}
MOZ_ASSERT
(
mReferrerInfo
)
;
MOZ_ASSERT
(
mPreloadReferrerInfo
)
;
if
(
aPreload
)
{
mPreloadReferrerInfo
=
static_cast
<
mozilla
:
:
dom
:
:
ReferrerInfo
*
>
(
(
mPreloadReferrerInfo
)
.
get
(
)
)
-
>
CloneWithNewPolicy
(
policy
)
;
}
else
{
nsCOMPtr
<
nsIReferrerInfo
>
clone
=
static_cast
<
mozilla
:
:
dom
:
:
ReferrerInfo
*
>
(
(
mReferrerInfo
)
.
get
(
)
)
-
>
CloneWithNewPolicy
(
policy
)
;
SetReferrerInfo
(
clone
)
;
}
}
void
Document
:
:
SetPrincipals
(
nsIPrincipal
*
aNewPrincipal
nsIPrincipal
*
aNewPartitionedPrincipal
)
{
MOZ_ASSERT
(
!
!
aNewPrincipal
=
=
!
!
aNewPartitionedPrincipal
)
;
if
(
aNewPrincipal
&
&
mAllowDNSPrefetch
&
&
StaticPrefs
:
:
network_dns_disablePrefetchFromHTTPS
(
)
)
{
if
(
aNewPrincipal
-
>
SchemeIs
(
"
https
"
)
)
{
mAllowDNSPrefetch
=
false
;
}
}
mCSSLoader
-
>
DeregisterFromSheetCache
(
)
;
mNodeInfoManager
-
>
SetDocumentPrincipal
(
aNewPrincipal
)
;
mPartitionedPrincipal
=
aNewPartitionedPrincipal
;
mCachedURLData
=
nullptr
;
mCSSLoader
-
>
RegisterInSheetCache
(
)
;
RecomputeResistFingerprinting
(
)
;
#
ifdef
DEBUG
if
(
aNewPrincipal
)
{
GetDocGroup
(
)
;
}
#
endif
}
#
ifdef
DEBUG
void
Document
:
:
AssertDocGroupMatchesKey
(
)
const
{
if
(
!
GetBrowsingContext
(
)
|
|
!
GetBrowsingContext
(
)
-
>
Group
(
)
)
{
return
;
}
if
(
mDocGroup
&
&
mDocGroup
-
>
GetBrowsingContextGroup
(
)
)
{
MOZ_ASSERT
(
mDocGroup
-
>
GetBrowsingContextGroup
(
)
=
=
GetBrowsingContext
(
)
-
>
Group
(
)
)
;
nsAutoCString
docGroupKey
;
nsresult
rv
=
mozilla
:
:
dom
:
:
DocGroup
:
:
GetKey
(
NodePrincipal
(
)
GetBrowsingContext
(
)
-
>
Group
(
)
-
>
IsPotentiallyCrossOriginIsolated
(
)
docGroupKey
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_ASSERT
(
mDocGroup
-
>
MatchesKey
(
docGroupKey
)
)
;
}
}
}
#
endif
nsresult
Document
:
:
Dispatch
(
already_AddRefed
<
nsIRunnable
>
&
&
aRunnable
)
const
{
return
SchedulerGroup
:
:
Dispatch
(
std
:
:
move
(
aRunnable
)
)
;
}
void
Document
:
:
NoteScriptTrackingStatus
(
const
nsACString
&
aURL
bool
aIsTracking
)
{
if
(
aIsTracking
)
{
mTrackingScripts
.
Insert
(
aURL
)
;
}
else
{
MOZ_ASSERT
(
!
mTrackingScripts
.
Contains
(
aURL
)
)
;
}
}
bool
Document
:
:
IsScriptTracking
(
JSContext
*
aCx
)
const
{
JS
:
:
AutoFilename
filename
;
if
(
!
JS
:
:
DescribeScriptedCaller
(
aCx
&
filename
)
)
{
return
false
;
}
return
mTrackingScripts
.
Contains
(
nsDependentCString
(
filename
.
get
(
)
)
)
;
}
void
Document
:
:
GetContentType
(
nsAString
&
aContentType
)
{
CopyUTF8toUTF16
(
GetContentTypeInternal
(
)
aContentType
)
;
}
void
Document
:
:
SetContentType
(
const
nsACString
&
aContentType
)
{
if
(
!
IsHTMLOrXHTML
(
)
&
&
mDefaultElementType
=
=
kNameSpaceID_None
&
&
aContentType
.
EqualsLiteral
(
"
application
/
xhtml
+
xml
"
)
)
{
mDefaultElementType
=
kNameSpaceID_XHTML
;
}
mCachedEncoder
=
nullptr
;
mContentType
=
aContentType
;
}
bool
Document
:
:
GetAllowPlugins
(
)
{
auto
*
browsingContext
=
GetBrowsingContext
(
)
;
if
(
browsingContext
)
{
if
(
!
browsingContext
-
>
GetAllowPlugins
(
)
)
{
return
false
;
}
if
(
mSandboxFlags
&
SANDBOXED_PLUGINS
)
{
return
false
;
}
}
return
true
;
}
bool
Document
:
:
HasPendingInitialTranslation
(
)
{
return
mDocumentL10n
&
&
mDocumentL10n
-
>
GetState
(
)
!
=
DocumentL10nState
:
:
Ready
;
}
bool
Document
:
:
HasPendingL10nMutations
(
)
const
{
return
mDocumentL10n
&
&
mDocumentL10n
-
>
HasPendingMutations
(
)
;
}
bool
Document
:
:
DocumentSupportsL10n
(
JSContext
*
aCx
JSObject
*
aObject
)
{
JS
:
:
Rooted
<
JSObject
*
>
object
(
aCx
aObject
)
;
nsCOMPtr
<
nsIPrincipal
>
callerPrincipal
=
nsContentUtils
:
:
SubjectPrincipal
(
aCx
)
;
nsGlobalWindowInner
*
win
=
xpc
:
:
WindowOrNull
(
object
)
;
bool
allowed
=
false
;
callerPrincipal
-
>
IsL10nAllowed
(
win
?
win
-
>
GetDocumentURI
(
)
:
nullptr
&
allowed
)
;
return
allowed
;
}
void
Document
:
:
LocalizationLinkAdded
(
Element
*
aLinkElement
)
{
if
(
!
AllowsL10n
(
)
)
{
return
;
}
nsAutoString
href
;
aLinkElement
-
>
GetAttr
(
nsGkAtoms
:
:
href
href
)
;
if
(
!
mDocumentL10n
)
{
Element
*
elem
=
GetDocumentElement
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
elem
)
;
bool
isSync
=
elem
-
>
HasAttr
(
nsGkAtoms
:
:
datal10nsync
)
;
mDocumentL10n
=
DocumentL10n
:
:
Create
(
this
isSync
)
;
if
(
NS_WARN_IF
(
!
mDocumentL10n
)
)
{
return
;
}
}
mDocumentL10n
-
>
AddResourceId
(
NS_ConvertUTF16toUTF8
(
href
)
)
;
if
(
mReadyState
>
=
READYSTATE_INTERACTIVE
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
DocumentL10n
:
:
TriggerInitialTranslation
(
)
"
mDocumentL10n
&
DocumentL10n
:
:
TriggerInitialTranslation
)
)
;
}
else
{
if
(
!
mDocumentL10n
-
>
mBlockingLayout
)
{
BlockOnload
(
)
;
mDocumentL10n
-
>
mBlockingLayout
=
true
;
}
}
}
void
Document
:
:
LocalizationLinkRemoved
(
Element
*
aLinkElement
)
{
if
(
!
AllowsL10n
(
)
)
{
return
;
}
if
(
mDocumentL10n
)
{
nsAutoString
href
;
aLinkElement
-
>
GetAttr
(
nsGkAtoms
:
:
href
href
)
;
uint32_t
remaining
=
mDocumentL10n
-
>
RemoveResourceId
(
NS_ConvertUTF16toUTF8
(
href
)
)
;
if
(
remaining
=
=
0
)
{
if
(
mDocumentL10n
-
>
mBlockingLayout
)
{
mDocumentL10n
-
>
mBlockingLayout
=
false
;
UnblockOnload
(
false
)
;
}
mDocumentL10n
=
nullptr
;
}
}
}
void
Document
:
:
OnL10nResourceContainerParsed
(
)
{
}
void
Document
:
:
OnParsingCompleted
(
)
{
OnL10nResourceContainerParsed
(
)
;
if
(
mDocumentL10n
)
{
RefPtr
<
DocumentL10n
>
l10n
=
mDocumentL10n
;
l10n
-
>
TriggerInitialTranslation
(
)
;
}
}
void
Document
:
:
InitialTranslationCompleted
(
bool
aL10nCached
)
{
if
(
mDocumentL10n
&
&
mDocumentL10n
-
>
mBlockingLayout
)
{
mDocumentL10n
-
>
mBlockingLayout
=
false
;
UnblockOnload
(
false
)
;
}
mL10nProtoElements
.
Clear
(
)
;
nsXULPrototypeDocument
*
proto
=
GetPrototype
(
)
;
if
(
proto
)
{
proto
-
>
SetIsL10nCached
(
aL10nCached
)
;
}
}
bool
Document
:
:
AllowsL10n
(
)
const
{
if
(
IsStaticDocument
(
)
)
{
return
false
;
}
bool
allowed
=
false
;
NodePrincipal
(
)
-
>
IsL10nAllowed
(
GetDocumentURI
(
)
&
allowed
)
;
return
allowed
;
}
bool
Document
:
:
IsWebAnimationsGetAnimationsEnabled
(
JSContext
*
aCx
JSObject
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
StaticPrefs
:
:
dom_animations_api_getAnimations_enabled
(
)
;
}
bool
Document
:
:
AreWebAnimationsTimelinesEnabled
(
JSContext
*
aCx
JSObject
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
nsContentUtils
:
:
IsSystemCaller
(
aCx
)
|
|
StaticPrefs
:
:
dom_animations_api_timelines_enabled
(
)
;
}
DocumentTimeline
*
Document
:
:
Timeline
(
)
{
if
(
!
mDocumentTimeline
)
{
mDocumentTimeline
=
new
DocumentTimeline
(
this
TimeDuration
(
0
)
)
;
}
return
mDocumentTimeline
;
}
SVGSVGElement
*
Document
:
:
GetSVGRootElement
(
)
const
{
Element
*
root
=
GetRootElement
(
)
;
if
(
!
root
|
|
!
root
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
return
nullptr
;
}
return
static_cast
<
SVGSVGElement
*
>
(
root
)
;
}
bool
Document
:
:
HasFocus
(
ErrorResult
&
rv
)
const
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
rv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
false
;
}
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
false
;
}
if
(
!
fm
-
>
IsInActiveWindow
(
bc
)
)
{
return
false
;
}
return
fm
-
>
IsSameOrAncestor
(
bc
fm
-
>
GetFocusedBrowsingContext
(
)
)
;
}
bool
Document
:
:
ThisDocumentHasFocus
(
)
const
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
return
fm
&
&
fm
-
>
GetFocusedWindow
(
)
&
&
fm
-
>
GetFocusedWindow
(
)
-
>
GetExtantDoc
(
)
=
=
this
;
}
void
Document
:
:
GetDesignMode
(
nsAString
&
aDesignMode
)
{
if
(
IsInDesignMode
(
)
)
{
aDesignMode
.
AssignLiteral
(
"
on
"
)
;
}
else
{
aDesignMode
.
AssignLiteral
(
"
off
"
)
;
}
}
void
Document
:
:
SetDesignMode
(
const
nsAString
&
aDesignMode
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
rv
)
{
SetDesignMode
(
aDesignMode
Some
(
&
aSubjectPrincipal
)
rv
)
;
}
static
void
NotifyEditableStateChange
(
Document
&
aDoc
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsMutationGuard
g
;
#
endif
for
(
nsIContent
*
node
=
aDoc
.
GetNextNode
(
&
aDoc
)
;
node
;
node
=
node
-
>
GetNextNode
(
&
aDoc
)
)
{
if
(
auto
*
element
=
Element
:
:
FromNode
(
node
)
)
{
element
-
>
UpdateEditableState
(
true
)
;
}
}
MOZ_DIAGNOSTIC_ASSERT
(
!
g
.
Mutated
(
0
)
)
;
}
void
Document
:
:
SetDesignMode
(
const
nsAString
&
aDesignMode
const
Maybe
<
nsIPrincipal
*
>
&
aSubjectPrincipal
ErrorResult
&
rv
)
{
if
(
aSubjectPrincipal
.
isSome
(
)
&
&
!
aSubjectPrincipal
.
value
(
)
-
>
Subsumes
(
NodePrincipal
(
)
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_PROP_ACCESS_DENIED
)
;
return
;
}
const
bool
editableMode
=
IsInDesignMode
(
)
;
if
(
aDesignMode
.
LowerCaseEqualsASCII
(
editableMode
?
"
off
"
:
"
on
"
)
)
{
SetEditableFlag
(
!
editableMode
)
;
NotifyEditableStateChange
(
*
this
)
;
rv
=
EditingStateChanged
(
)
;
}
}
nsCommandManager
*
Document
:
:
GetMidasCommandManager
(
)
{
if
(
mMidasCommandManager
)
{
return
mMidasCommandManager
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
nullptr
;
}
mMidasCommandManager
=
docshell
-
>
GetCommandManager
(
)
;
return
mMidasCommandManager
;
}
void
Document
:
:
EnsureInitializeInternalCommandDataHashtable
(
)
{
if
(
sInternalCommandDataHashtable
)
{
return
;
}
using
CommandOnTextEditor
=
InternalCommandData
:
:
CommandOnTextEditor
;
sInternalCommandDataHashtable
=
new
InternalCommandDataHashtable
(
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
bold
"
_ns
InternalCommandData
(
"
cmd_bold
"
Command
:
:
FormatBold
ExecCommandParam
:
:
Ignore
StyleUpdatingCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
italic
"
_ns
InternalCommandData
(
"
cmd_italic
"
Command
:
:
FormatItalic
ExecCommandParam
:
:
Ignore
StyleUpdatingCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
underline
"
_ns
InternalCommandData
(
"
cmd_underline
"
Command
:
:
FormatUnderline
ExecCommandParam
:
:
Ignore
StyleUpdatingCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
strikethrough
"
_ns
InternalCommandData
(
"
cmd_strikethrough
"
Command
:
:
FormatStrikeThrough
ExecCommandParam
:
:
Ignore
StyleUpdatingCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
subscript
"
_ns
InternalCommandData
(
"
cmd_subscript
"
Command
:
:
FormatSubscript
ExecCommandParam
:
:
Ignore
StyleUpdatingCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
superscript
"
_ns
InternalCommandData
(
"
cmd_superscript
"
Command
:
:
FormatSuperscript
ExecCommandParam
:
:
Ignore
StyleUpdatingCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
cut
"
_ns
InternalCommandData
(
"
cmd_cut
"
Command
:
:
Cut
ExecCommandParam
:
:
Ignore
CutCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
copy
"
_ns
InternalCommandData
(
"
cmd_copy
"
Command
:
:
Copy
ExecCommandParam
:
:
Ignore
CopyCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
paste
"
_ns
InternalCommandData
(
"
cmd_paste
"
Command
:
:
Paste
ExecCommandParam
:
:
Ignore
PasteCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
delete
"
_ns
InternalCommandData
(
"
cmd_deleteCharBackward
"
Command
:
:
DeleteCharBackward
ExecCommandParam
:
:
Ignore
DeleteCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
forwarddelete
"
_ns
InternalCommandData
(
"
cmd_deleteCharForward
"
Command
:
:
DeleteCharForward
ExecCommandParam
:
:
Ignore
DeleteCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
selectall
"
_ns
InternalCommandData
(
"
cmd_selectAll
"
Command
:
:
SelectAll
ExecCommandParam
:
:
Ignore
SelectAllCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
undo
"
_ns
InternalCommandData
(
"
cmd_undo
"
Command
:
:
HistoryUndo
ExecCommandParam
:
:
Ignore
UndoCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
redo
"
_ns
InternalCommandData
(
"
cmd_redo
"
Command
:
:
HistoryRedo
ExecCommandParam
:
:
Ignore
RedoCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
indent
"
_ns
InternalCommandData
(
"
cmd_indent
"
Command
:
:
FormatIndent
ExecCommandParam
:
:
Ignore
IndentCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
outdent
"
_ns
InternalCommandData
(
"
cmd_outdent
"
Command
:
:
FormatOutdent
ExecCommandParam
:
:
Ignore
OutdentCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
backcolor
"
_ns
InternalCommandData
(
"
cmd_highlight
"
Command
:
:
FormatBackColor
ExecCommandParam
:
:
String
HighlightColorStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
hilitecolor
"
_ns
InternalCommandData
(
"
cmd_highlight
"
Command
:
:
FormatBackColor
ExecCommandParam
:
:
String
HighlightColorStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
forecolor
"
_ns
InternalCommandData
(
"
cmd_fontColor
"
Command
:
:
FormatFontColor
ExecCommandParam
:
:
String
FontColorStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
fontname
"
_ns
InternalCommandData
(
"
cmd_fontFace
"
Command
:
:
FormatFontName
ExecCommandParam
:
:
String
FontFaceStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
fontsize
"
_ns
InternalCommandData
(
"
cmd_fontSize
"
Command
:
:
FormatFontSize
ExecCommandParam
:
:
String
FontSizeStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
inserthorizontalrule
"
_ns
InternalCommandData
(
"
cmd_insertHR
"
Command
:
:
InsertHorizontalRule
ExecCommandParam
:
:
Ignore
InsertTagCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
createlink
"
_ns
InternalCommandData
(
"
cmd_insertLinkNoUI
"
Command
:
:
InsertLink
ExecCommandParam
:
:
String
InsertTagCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
insertimage
"
_ns
InternalCommandData
(
"
cmd_insertImageNoUI
"
Command
:
:
InsertImage
ExecCommandParam
:
:
String
InsertTagCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
inserthtml
"
_ns
InternalCommandData
(
"
cmd_insertHTML
"
Command
:
:
InsertHTML
ExecCommandParam
:
:
String
InsertHTMLCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
inserttext
"
_ns
InternalCommandData
(
"
cmd_insertText
"
Command
:
:
InsertText
ExecCommandParam
:
:
String
InsertPlaintextCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
justifyleft
"
_ns
InternalCommandData
(
"
cmd_align
"
Command
:
:
FormatJustifyLeft
ExecCommandParam
:
:
Ignore
AlignCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
justifyright
"
_ns
InternalCommandData
(
"
cmd_align
"
Command
:
:
FormatJustifyRight
ExecCommandParam
:
:
Ignore
AlignCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
justifycenter
"
_ns
InternalCommandData
(
"
cmd_align
"
Command
:
:
FormatJustifyCenter
ExecCommandParam
:
:
Ignore
AlignCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
justifyfull
"
_ns
InternalCommandData
(
"
cmd_align
"
Command
:
:
FormatJustifyFull
ExecCommandParam
:
:
Ignore
AlignCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
removeformat
"
_ns
InternalCommandData
(
"
cmd_removeStyles
"
Command
:
:
FormatRemove
ExecCommandParam
:
:
Ignore
RemoveStylesCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
unlink
"
_ns
InternalCommandData
(
"
cmd_removeLinks
"
Command
:
:
FormatRemoveLink
ExecCommandParam
:
:
Ignore
StyleUpdatingCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
insertorderedlist
"
_ns
InternalCommandData
(
"
cmd_ol
"
Command
:
:
InsertOrderedList
ExecCommandParam
:
:
Ignore
ListCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
insertunorderedlist
"
_ns
InternalCommandData
(
"
cmd_ul
"
Command
:
:
InsertUnorderedList
ExecCommandParam
:
:
Ignore
ListCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
insertparagraph
"
_ns
InternalCommandData
(
"
cmd_insertParagraph
"
Command
:
:
InsertParagraph
ExecCommandParam
:
:
Ignore
InsertParagraphCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
insertlinebreak
"
_ns
InternalCommandData
(
"
cmd_insertLineBreak
"
Command
:
:
InsertLineBreak
ExecCommandParam
:
:
Ignore
InsertLineBreakCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
formatblock
"
_ns
InternalCommandData
(
"
cmd_formatBlock
"
Command
:
:
FormatBlock
ExecCommandParam
:
:
String
FormatBlockStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
styleWithCSS
"
_ns
InternalCommandData
(
"
cmd_setDocumentUseCSS
"
Command
:
:
SetDocumentUseCSS
ExecCommandParam
:
:
Boolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
usecss
"
_ns
InternalCommandData
(
"
cmd_setDocumentUseCSS
"
Command
:
:
SetDocumentUseCSS
ExecCommandParam
:
:
InvertedBoolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
contentReadOnly
"
_ns
InternalCommandData
(
"
cmd_setDocumentReadOnly
"
Command
:
:
SetDocumentReadOnly
ExecCommandParam
:
:
Boolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
Enabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
insertBrOnReturn
"
_ns
InternalCommandData
(
"
cmd_insertBrOnReturn
"
Command
:
:
SetDocumentInsertBROnEnterKeyPress
ExecCommandParam
:
:
Boolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
defaultParagraphSeparator
"
_ns
InternalCommandData
(
"
cmd_defaultParagraphSeparator
"
Command
:
:
SetDocumentDefaultParagraphSeparator
ExecCommandParam
:
:
String
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
enableObjectResizing
"
_ns
InternalCommandData
(
"
cmd_enableObjectResizing
"
Command
:
:
ToggleObjectResizers
ExecCommandParam
:
:
Boolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
enableInlineTableEditing
"
_ns
InternalCommandData
(
"
cmd_enableInlineTableEditing
"
Command
:
:
ToggleInlineTableEditor
ExecCommandParam
:
:
Boolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
enableAbsolutePositionEditing
"
_ns
InternalCommandData
(
"
cmd_enableAbsolutePositionEditing
"
Command
:
:
ToggleAbsolutePositionEditor
ExecCommandParam
:
:
Boolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
enableCompatibleJoinSplitDirection
"
_ns
InternalCommandData
(
"
cmd_enableCompatibleJoinSplitNodeDirection
"
Command
:
:
EnableCompatibleJoinSplitNodeDirection
ExecCommandParam
:
:
Boolean
SetDocumentStateCommand
:
:
GetInstance
CommandOnTextEditor
:
:
FallThrough
)
)
;
#
if
0
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
justifynone
"
_ns
InternalCommandData
(
"
cmd_align
"
Command
:
:
Undefined
ExecCommandParam
:
:
Ignore
nullptr
CommandOnTextEditor
:
:
Disabled
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
saveas
"
_ns
InternalCommandData
(
"
cmd_saveAs
"
Command
:
:
Undefined
ExecCommandParam
:
:
Boolean
nullptr
CommandOnTextEditor
:
:
FallThrough
)
)
;
sInternalCommandDataHashtable
-
>
InsertOrUpdate
(
u
"
print
"
_ns
InternalCommandData
(
"
cmd_print
"
Command
:
:
Undefined
ExecCommandParam
:
:
Boolean
nullptr
CommandOnTextEditor
:
:
FallThrough
)
)
;
#
endif
}
Document
:
:
InternalCommandData
Document
:
:
ConvertToInternalCommand
(
const
nsAString
&
aHTMLCommandName
const
nsAString
&
aValue
nsAString
*
aAdjustedValue
)
{
MOZ_ASSERT
(
!
aAdjustedValue
|
|
aAdjustedValue
-
>
IsEmpty
(
)
)
;
EnsureInitializeInternalCommandDataHashtable
(
)
;
InternalCommandData
commandData
;
if
(
!
sInternalCommandDataHashtable
-
>
Get
(
aHTMLCommandName
&
commandData
)
)
{
return
InternalCommandData
(
)
;
}
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
SetDocumentReadOnly
:
if
(
!
StaticPrefs
:
:
dom_document_edit_command_contentReadOnly_enabled
(
)
&
&
aHTMLCommandName
.
LowerCaseEqualsLiteral
(
"
contentreadonly
"
)
)
{
return
InternalCommandData
(
)
;
}
break
;
case
Command
:
:
SetDocumentInsertBROnEnterKeyPress
:
MOZ_DIAGNOSTIC_ASSERT
(
aHTMLCommandName
.
LowerCaseEqualsLiteral
(
"
insertbronreturn
"
)
)
;
if
(
!
StaticPrefs
:
:
dom_document_edit_command_insertBrOnReturn_enabled
(
)
)
{
return
InternalCommandData
(
)
;
}
break
;
default
:
break
;
}
if
(
!
aAdjustedValue
)
{
return
commandData
;
}
switch
(
commandData
.
mExecCommandParam
)
{
case
ExecCommandParam
:
:
Ignore
:
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
FormatJustifyLeft
:
aAdjustedValue
-
>
AssignLiteral
(
"
left
"
)
;
break
;
case
Command
:
:
FormatJustifyRight
:
aAdjustedValue
-
>
AssignLiteral
(
"
right
"
)
;
break
;
case
Command
:
:
FormatJustifyCenter
:
aAdjustedValue
-
>
AssignLiteral
(
"
center
"
)
;
break
;
case
Command
:
:
FormatJustifyFull
:
aAdjustedValue
-
>
AssignLiteral
(
"
justify
"
)
;
break
;
default
:
MOZ_ASSERT
(
EditorCommand
:
:
GetParamType
(
commandData
.
mCommand
)
=
=
EditorCommandParamType
:
:
None
)
;
break
;
}
return
commandData
;
case
ExecCommandParam
:
:
Boolean
:
MOZ_ASSERT
(
!
!
(
EditorCommand
:
:
GetParamType
(
commandData
.
mCommand
)
&
EditorCommandParamType
:
:
Bool
)
)
;
if
(
!
aValue
.
LowerCaseEqualsLiteral
(
"
false
"
)
)
{
aAdjustedValue
-
>
AssignLiteral
(
"
true
"
)
;
}
else
{
aAdjustedValue
-
>
AssignLiteral
(
"
false
"
)
;
}
return
commandData
;
case
ExecCommandParam
:
:
InvertedBoolean
:
MOZ_ASSERT
(
!
!
(
EditorCommand
:
:
GetParamType
(
commandData
.
mCommand
)
&
EditorCommandParamType
:
:
Bool
)
)
;
if
(
aValue
.
LowerCaseEqualsLiteral
(
"
false
"
)
)
{
aAdjustedValue
-
>
AssignLiteral
(
"
true
"
)
;
}
else
{
aAdjustedValue
-
>
AssignLiteral
(
"
false
"
)
;
}
return
commandData
;
case
ExecCommandParam
:
:
String
:
MOZ_ASSERT
(
!
!
(
EditorCommand
:
:
GetParamType
(
commandData
.
mCommand
)
&
(
EditorCommandParamType
:
:
String
|
EditorCommandParamType
:
:
CString
)
)
)
;
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
FormatBlock
:
{
const
char16_t
*
start
=
aValue
.
BeginReading
(
)
;
const
char16_t
*
end
=
aValue
.
EndReading
(
)
;
if
(
start
!
=
end
&
&
*
start
=
=
'
<
'
&
&
*
(
end
-
1
)
=
=
'
>
'
)
{
+
+
start
;
-
-
end
;
}
static
const
nsStaticAtom
*
kFormattableBlockTags
[
]
=
{
nsGkAtoms
:
:
address
nsGkAtoms
:
:
article
nsGkAtoms
:
:
aside
nsGkAtoms
:
:
blockquote
nsGkAtoms
:
:
dd
nsGkAtoms
:
:
div
nsGkAtoms
:
:
dl
nsGkAtoms
:
:
dt
nsGkAtoms
:
:
footer
nsGkAtoms
:
:
h1
nsGkAtoms
:
:
h2
nsGkAtoms
:
:
h3
nsGkAtoms
:
:
h4
nsGkAtoms
:
:
h5
nsGkAtoms
:
:
h6
nsGkAtoms
:
:
header
nsGkAtoms
:
:
hgroup
nsGkAtoms
:
:
main
nsGkAtoms
:
:
nav
nsGkAtoms
:
:
p
nsGkAtoms
:
:
pre
nsGkAtoms
:
:
section
}
;
nsAutoString
value
(
nsDependentSubstring
(
start
end
)
)
;
ToLowerCase
(
value
)
;
const
nsStaticAtom
*
valueAtom
=
NS_GetStaticAtom
(
value
)
;
for
(
const
nsStaticAtom
*
kTag
:
kFormattableBlockTags
)
{
if
(
valueAtom
=
=
kTag
)
{
kTag
-
>
ToString
(
*
aAdjustedValue
)
;
return
commandData
;
}
}
return
InternalCommandData
(
)
;
}
case
Command
:
:
FormatFontSize
:
{
int32_t
size
=
nsContentUtils
:
:
ParseLegacyFontSize
(
aValue
)
;
if
(
!
size
)
{
return
InternalCommandData
(
)
;
}
MOZ_ASSERT
(
aAdjustedValue
-
>
IsEmpty
(
)
)
;
aAdjustedValue
-
>
AppendInt
(
size
)
;
return
commandData
;
}
case
Command
:
:
InsertImage
:
case
Command
:
:
InsertLink
:
if
(
aValue
.
IsEmpty
(
)
)
{
return
InternalCommandData
(
)
;
}
aAdjustedValue
-
>
Assign
(
aValue
)
;
return
commandData
;
case
Command
:
:
SetDocumentDefaultParagraphSeparator
:
if
(
!
aValue
.
LowerCaseEqualsLiteral
(
"
div
"
)
&
&
!
aValue
.
LowerCaseEqualsLiteral
(
"
p
"
)
&
&
!
aValue
.
LowerCaseEqualsLiteral
(
"
br
"
)
)
{
return
InternalCommandData
(
)
;
}
aAdjustedValue
-
>
Assign
(
aValue
)
;
return
commandData
;
default
:
aAdjustedValue
-
>
Assign
(
aValue
)
;
return
commandData
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
New
ExecCommandParam
value
hasn
'
t
been
handled
"
)
;
return
InternalCommandData
(
)
;
}
}
Document
:
:
AutoEditorCommandTarget
:
:
AutoEditorCommandTarget
(
Document
&
aDocument
const
InternalCommandData
&
aCommandData
)
:
mCommandData
(
aCommandData
)
{
aDocument
.
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
aDocument
.
GetPresShell
(
)
|
|
aDocument
.
GetPresShell
(
)
-
>
IsDestroying
(
)
)
{
mDoNothing
=
true
;
return
;
}
if
(
nsPresContext
*
presContext
=
aDocument
.
GetPresContext
(
)
)
{
if
(
aCommandData
.
IsCutOrCopyCommand
(
)
)
{
mActiveEditor
=
nsContentUtils
:
:
GetActiveEditor
(
presContext
)
;
}
else
{
mActiveEditor
=
nsContentUtils
:
:
GetActiveEditor
(
presContext
)
;
mHTMLEditor
=
nsContentUtils
:
:
GetHTMLEditor
(
presContext
)
;
if
(
!
mActiveEditor
)
{
mActiveEditor
=
mHTMLEditor
;
}
}
}
if
(
!
mActiveEditor
)
{
if
(
aCommandData
.
IsAvailableOnlyWhenEditable
(
)
)
{
mDoNothing
=
true
;
return
;
}
return
;
}
mEditorCommand
=
aCommandData
.
mGetEditorCommandFunc
?
aCommandData
.
mGetEditorCommandFunc
(
)
:
nullptr
;
if
(
!
mEditorCommand
)
{
mDoNothing
=
true
;
mActiveEditor
=
nullptr
;
mHTMLEditor
=
nullptr
;
return
;
}
if
(
IsCommandEnabled
(
)
)
{
return
;
}
if
(
aCommandData
.
IsAvailableOnlyWhenEditable
(
)
)
{
mDoNothing
=
true
;
return
;
}
mEditorCommand
=
nullptr
;
mActiveEditor
=
nullptr
;
mHTMLEditor
=
nullptr
;
}
EditorBase
*
Document
:
:
AutoEditorCommandTarget
:
:
GetTargetEditor
(
)
const
{
using
CommandOnTextEditor
=
InternalCommandData
:
:
CommandOnTextEditor
;
switch
(
mCommandData
.
mCommandOnTextEditor
)
{
case
CommandOnTextEditor
:
:
Enabled
:
return
mActiveEditor
;
case
CommandOnTextEditor
:
:
Disabled
:
return
mActiveEditor
&
&
mActiveEditor
-
>
IsTextEditor
(
)
?
nullptr
:
mActiveEditor
.
get
(
)
;
case
CommandOnTextEditor
:
:
FallThrough
:
return
mHTMLEditor
;
}
return
nullptr
;
}
bool
Document
:
:
AutoEditorCommandTarget
:
:
IsEditable
(
Document
*
aDocument
)
const
{
if
(
RefPtr
<
Document
>
doc
=
aDocument
-
>
GetInProcessParentDocument
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
EditorBase
*
targetEditor
=
GetTargetEditor
(
)
;
if
(
targetEditor
&
&
targetEditor
-
>
IsTextEditor
(
)
)
{
return
!
targetEditor
-
>
IsReadonly
(
)
;
}
return
aDocument
-
>
IsEditingOn
(
)
;
}
bool
Document
:
:
AutoEditorCommandTarget
:
:
IsCommandEnabled
(
)
const
{
EditorBase
*
targetEditor
=
GetTargetEditor
(
)
;
if
(
!
targetEditor
)
{
return
false
;
}
MOZ_ASSERT
(
targetEditor
=
=
mActiveEditor
|
|
targetEditor
=
=
mHTMLEditor
)
;
return
MOZ_KnownLive
(
mEditorCommand
)
-
>
IsCommandEnabled
(
mCommandData
.
mCommand
MOZ_KnownLive
(
targetEditor
)
)
;
}
nsresult
Document
:
:
AutoEditorCommandTarget
:
:
DoCommand
(
nsIPrincipal
*
aPrincipal
)
const
{
MOZ_ASSERT
(
!
DoNothing
(
)
)
;
MOZ_ASSERT
(
mEditorCommand
)
;
EditorBase
*
targetEditor
=
GetTargetEditor
(
)
;
if
(
!
targetEditor
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
MOZ_ASSERT
(
targetEditor
=
=
mActiveEditor
|
|
targetEditor
=
=
mHTMLEditor
)
;
return
MOZ_KnownLive
(
mEditorCommand
)
-
>
DoCommand
(
mCommandData
.
mCommand
MOZ_KnownLive
(
*
targetEditor
)
aPrincipal
)
;
}
template
<
typename
ParamType
>
nsresult
Document
:
:
AutoEditorCommandTarget
:
:
DoCommandParam
(
const
ParamType
&
aParam
nsIPrincipal
*
aPrincipal
)
const
{
MOZ_ASSERT
(
!
DoNothing
(
)
)
;
MOZ_ASSERT
(
mEditorCommand
)
;
EditorBase
*
targetEditor
=
GetTargetEditor
(
)
;
if
(
!
targetEditor
)
{
return
NS_SUCCESS_DOM_NO_OPERATION
;
}
MOZ_ASSERT
(
targetEditor
=
=
mActiveEditor
|
|
targetEditor
=
=
mHTMLEditor
)
;
return
MOZ_KnownLive
(
mEditorCommand
)
-
>
DoCommandParam
(
mCommandData
.
mCommand
aParam
MOZ_KnownLive
(
*
targetEditor
)
aPrincipal
)
;
}
nsresult
Document
:
:
AutoEditorCommandTarget
:
:
GetCommandStateParams
(
nsCommandParams
&
aParams
)
const
{
MOZ_ASSERT
(
mEditorCommand
)
;
EditorBase
*
targetEditor
=
GetTargetEditor
(
)
;
if
(
!
targetEditor
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
targetEditor
=
=
mActiveEditor
|
|
targetEditor
=
=
mHTMLEditor
)
;
return
MOZ_KnownLive
(
mEditorCommand
)
-
>
GetCommandStateParams
(
mCommandData
.
mCommand
MOZ_KnownLive
(
aParams
)
MOZ_KnownLive
(
targetEditor
)
nullptr
)
;
}
bool
Document
:
:
ExecCommand
(
const
nsAString
&
aHTMLCommandName
bool
aShowUI
const
nsAString
&
aValue
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
IsHTMLOrXHTML
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
execCommand
is
only
supported
on
HTML
documents
"
)
;
return
false
;
}
if
(
aShowUI
)
{
return
false
;
}
if
(
!
StaticPrefs
:
:
dom_document_exec_command_nested_calls_allowed
(
)
&
&
mIsRunningExecCommand
)
{
return
false
;
}
nsAutoString
adjustedValue
;
InternalCommandData
commandData
=
ConvertToInternalCommand
(
aHTMLCommandName
aValue
&
adjustedValue
)
;
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
DoNothing
:
return
false
;
case
Command
:
:
SetDocumentReadOnly
:
SetUseCounter
(
eUseCounter_custom_DocumentExecCommandContentReadOnly
)
;
break
;
case
Command
:
:
EnableCompatibleJoinSplitNodeDirection
:
if
(
!
adjustedValue
.
EqualsLiteral
(
"
true
"
)
)
{
return
false
;
}
break
;
default
:
break
;
}
if
(
commandData
.
IsCutOrCopyCommand
(
)
)
{
if
(
!
nsContentUtils
:
:
IsCutCopyAllowed
(
this
aSubjectPrincipal
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
DOM
"
_ns
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
ExecCommandCutCopyDeniedNotInputDriven
"
)
;
return
false
;
}
}
else
if
(
commandData
.
IsPasteCommand
(
)
)
{
if
(
!
nsContentUtils
:
:
PrincipalHasPermission
(
aSubjectPrincipal
nsGkAtoms
:
:
clipboardRead
)
)
{
return
false
;
}
}
AutoRunningExecCommandMarker
markRunningExecCommand
(
*
this
)
;
AutoEditorCommandTarget
editCommandTarget
(
*
this
commandData
)
;
if
(
commandData
.
IsAvailableOnlyWhenEditable
(
)
&
&
!
editCommandTarget
.
IsEditable
(
this
)
)
{
return
false
;
}
if
(
editCommandTarget
.
DoNothing
(
)
)
{
return
false
;
}
if
(
!
editCommandTarget
.
IsEditor
(
)
)
{
MOZ_ASSERT
(
!
commandData
.
IsAvailableOnlyWhenEditable
(
)
)
;
if
(
commandData
.
IsCutOrCopyCommand
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
!
docShell
)
{
return
false
;
}
nsresult
rv
=
docShell
-
>
DoCommand
(
commandData
.
mXULCommandName
)
;
if
(
rv
=
=
NS_SUCCESS_DOM_NO_OPERATION
)
{
return
false
;
}
return
NS_SUCCEEDED
(
rv
)
;
}
RefPtr
<
nsCommandManager
>
commandManager
=
GetMidasCommandManager
(
)
;
if
(
!
commandManager
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
if
(
!
commandManager
-
>
IsCommandEnabled
(
nsDependentCString
(
commandData
.
mXULCommandName
)
window
)
)
{
return
false
;
}
MOZ_ASSERT
(
commandData
.
IsPasteCommand
(
)
|
|
commandData
.
mCommand
=
=
Command
:
:
SelectAll
)
;
nsresult
rv
=
commandManager
-
>
DoCommand
(
commandData
.
mXULCommandName
nullptr
window
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
rv
!
=
NS_SUCCESS_DOM_NO_OPERATION
;
}
EditorCommandParamType
paramType
=
EditorCommand
:
:
GetParamType
(
commandData
.
mCommand
)
;
if
(
adjustedValue
.
IsEmpty
(
)
|
|
paramType
=
=
EditorCommandParamType
:
:
None
)
{
MOZ_ASSERT
(
!
(
paramType
&
EditorCommandParamType
:
:
Bool
)
)
;
nsresult
rv
=
editCommandTarget
.
DoCommand
(
&
aSubjectPrincipal
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
rv
!
=
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
!
!
(
paramType
&
EditorCommandParamType
:
:
Bool
)
)
{
MOZ_ASSERT
(
adjustedValue
.
EqualsLiteral
(
"
true
"
)
|
|
adjustedValue
.
EqualsLiteral
(
"
false
"
)
)
;
nsresult
rv
=
editCommandTarget
.
DoCommandParam
(
Some
(
adjustedValue
.
EqualsLiteral
(
"
true
"
)
)
&
aSubjectPrincipal
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
rv
!
=
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
!
!
(
paramType
&
EditorCommandParamType
:
:
String
)
)
{
MOZ_ASSERT
(
!
adjustedValue
.
IsVoid
(
)
)
;
nsresult
rv
=
editCommandTarget
.
DoCommandParam
(
adjustedValue
&
aSubjectPrincipal
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
rv
!
=
NS_SUCCESS_DOM_NO_OPERATION
;
}
if
(
!
!
(
paramType
&
EditorCommandParamType
:
:
CString
)
)
{
NS_ConvertUTF16toUTF8
utf8Value
(
adjustedValue
)
;
MOZ_ASSERT
(
!
utf8Value
.
IsVoid
(
)
)
;
nsresult
rv
=
editCommandTarget
.
DoCommandParam
(
utf8Value
&
aSubjectPrincipal
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
rv
!
=
NS_SUCCESS_DOM_NO_OPERATION
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Not
yet
implemented
to
handle
new
EditorCommandParamType
"
)
;
return
false
;
}
bool
Document
:
:
QueryCommandEnabled
(
const
nsAString
&
aHTMLCommandName
nsIPrincipal
&
aSubjectPrincipal
ErrorResult
&
aRv
)
{
if
(
!
IsHTMLOrXHTML
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
queryCommandEnabled
is
only
supported
on
HTML
documents
"
)
;
return
false
;
}
InternalCommandData
commandData
=
ConvertToInternalCommand
(
aHTMLCommandName
)
;
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
DoNothing
:
return
false
;
case
Command
:
:
SetDocumentReadOnly
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandSupportedOrEnabledContentReadOnly
)
;
break
;
case
Command
:
:
SetDocumentInsertBROnEnterKeyPress
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandSupportedOrEnabledInsertBrOnReturn
)
;
break
;
default
:
break
;
}
if
(
commandData
.
IsCutOrCopyCommand
(
)
)
{
return
nsContentUtils
:
:
IsCutCopyAllowed
(
this
aSubjectPrincipal
)
;
}
if
(
commandData
.
IsPasteCommand
(
)
&
&
!
aSubjectPrincipal
.
IsSystemPrincipal
(
)
)
{
return
false
;
}
AutoEditorCommandTarget
editCommandTarget
(
*
this
commandData
)
;
if
(
commandData
.
IsAvailableOnlyWhenEditable
(
)
&
&
!
editCommandTarget
.
IsEditable
(
this
)
)
{
return
false
;
}
if
(
editCommandTarget
.
IsEditor
(
)
)
{
return
editCommandTarget
.
IsCommandEnabled
(
)
;
}
RefPtr
<
nsCommandManager
>
commandManager
=
GetMidasCommandManager
(
)
;
if
(
!
commandManager
)
{
return
false
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
return
commandManager
-
>
IsCommandEnabled
(
nsDependentCString
(
commandData
.
mXULCommandName
)
window
)
;
}
bool
Document
:
:
QueryCommandIndeterm
(
const
nsAString
&
aHTMLCommandName
ErrorResult
&
aRv
)
{
if
(
!
IsHTMLOrXHTML
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
queryCommandIndeterm
is
only
supported
on
HTML
documents
"
)
;
return
false
;
}
InternalCommandData
commandData
=
ConvertToInternalCommand
(
aHTMLCommandName
)
;
if
(
commandData
.
mCommand
=
=
Command
:
:
DoNothing
)
{
return
false
;
}
AutoEditorCommandTarget
editCommandTarget
(
*
this
commandData
)
;
if
(
commandData
.
IsAvailableOnlyWhenEditable
(
)
&
&
!
editCommandTarget
.
IsEditable
(
this
)
)
{
return
false
;
}
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
if
(
editCommandTarget
.
IsEditor
(
)
)
{
if
(
NS_FAILED
(
editCommandTarget
.
GetCommandStateParams
(
*
params
)
)
)
{
return
false
;
}
}
else
{
RefPtr
<
nsCommandManager
>
commandManager
=
GetMidasCommandManager
(
)
;
if
(
!
commandManager
)
{
return
false
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
if
(
NS_FAILED
(
commandManager
-
>
GetCommandState
(
commandData
.
mXULCommandName
window
params
)
)
)
{
return
false
;
}
}
return
params
-
>
GetBool
(
"
state_mixed
"
)
;
}
bool
Document
:
:
QueryCommandState
(
const
nsAString
&
aHTMLCommandName
ErrorResult
&
aRv
)
{
if
(
!
IsHTMLOrXHTML
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
queryCommandState
is
only
supported
on
HTML
documents
"
)
;
return
false
;
}
InternalCommandData
commandData
=
ConvertToInternalCommand
(
aHTMLCommandName
)
;
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
DoNothing
:
return
false
;
case
Command
:
:
SetDocumentReadOnly
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandStateOrValueContentReadOnly
)
;
break
;
case
Command
:
:
SetDocumentInsertBROnEnterKeyPress
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandStateOrValueInsertBrOnReturn
)
;
break
;
default
:
break
;
}
if
(
aHTMLCommandName
.
LowerCaseEqualsLiteral
(
"
usecss
"
)
)
{
return
false
;
}
AutoEditorCommandTarget
editCommandTarget
(
*
this
commandData
)
;
if
(
commandData
.
IsAvailableOnlyWhenEditable
(
)
&
&
!
editCommandTarget
.
IsEditable
(
this
)
)
{
return
false
;
}
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
if
(
editCommandTarget
.
IsEditor
(
)
)
{
if
(
NS_FAILED
(
editCommandTarget
.
GetCommandStateParams
(
*
params
)
)
)
{
return
false
;
}
}
else
{
RefPtr
<
nsCommandManager
>
commandManager
=
GetMidasCommandManager
(
)
;
if
(
!
commandManager
)
{
return
false
;
}
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
if
(
NS_FAILED
(
commandManager
-
>
GetCommandState
(
commandData
.
mXULCommandName
window
params
)
)
)
{
return
false
;
}
}
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
FormatJustifyLeft
:
{
nsAutoCString
currentValue
;
nsresult
rv
=
params
-
>
GetCString
(
"
state_attribute
"
currentValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
currentValue
.
EqualsLiteral
(
"
left
"
)
;
}
case
Command
:
:
FormatJustifyRight
:
{
nsAutoCString
currentValue
;
nsresult
rv
=
params
-
>
GetCString
(
"
state_attribute
"
currentValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
currentValue
.
EqualsLiteral
(
"
right
"
)
;
}
case
Command
:
:
FormatJustifyCenter
:
{
nsAutoCString
currentValue
;
nsresult
rv
=
params
-
>
GetCString
(
"
state_attribute
"
currentValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
currentValue
.
EqualsLiteral
(
"
center
"
)
;
}
case
Command
:
:
FormatJustifyFull
:
{
nsAutoCString
currentValue
;
nsresult
rv
=
params
-
>
GetCString
(
"
state_attribute
"
currentValue
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
false
;
}
return
currentValue
.
EqualsLiteral
(
"
justify
"
)
;
}
default
:
break
;
}
return
params
-
>
GetBool
(
"
state_all
"
)
;
}
bool
Document
:
:
QueryCommandSupported
(
const
nsAString
&
aHTMLCommandName
CallerType
aCallerType
ErrorResult
&
aRv
)
{
if
(
!
IsHTMLOrXHTML
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
queryCommandSupported
is
only
supported
on
HTML
documents
"
)
;
return
false
;
}
InternalCommandData
commandData
=
ConvertToInternalCommand
(
aHTMLCommandName
)
;
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
DoNothing
:
return
false
;
case
Command
:
:
SetDocumentReadOnly
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandSupportedOrEnabledContentReadOnly
)
;
break
;
case
Command
:
:
SetDocumentInsertBROnEnterKeyPress
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandSupportedOrEnabledInsertBrOnReturn
)
;
break
;
default
:
break
;
}
if
(
aCallerType
!
=
CallerType
:
:
System
)
{
if
(
commandData
.
IsPasteCommand
(
)
)
{
return
false
;
}
if
(
commandData
.
IsCutOrCopyCommand
(
)
&
&
!
StaticPrefs
:
:
dom_allow_cut_copy
(
)
)
{
return
false
;
}
}
return
true
;
}
void
Document
:
:
QueryCommandValue
(
const
nsAString
&
aHTMLCommandName
nsAString
&
aValue
ErrorResult
&
aRv
)
{
aValue
.
Truncate
(
)
;
if
(
!
IsHTMLOrXHTML
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
queryCommandValue
is
only
supported
on
HTML
documents
"
)
;
return
;
}
InternalCommandData
commandData
=
ConvertToInternalCommand
(
aHTMLCommandName
)
;
switch
(
commandData
.
mCommand
)
{
case
Command
:
:
DoNothing
:
return
;
case
Command
:
:
SetDocumentReadOnly
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandStateOrValueContentReadOnly
)
;
break
;
case
Command
:
:
SetDocumentInsertBROnEnterKeyPress
:
SetUseCounter
(
eUseCounter_custom_DocumentQueryCommandStateOrValueInsertBrOnReturn
)
;
break
;
default
:
break
;
}
AutoEditorCommandTarget
editCommandTarget
(
*
this
commandData
)
;
if
(
commandData
.
IsAvailableOnlyWhenEditable
(
)
&
&
!
editCommandTarget
.
IsEditable
(
this
)
)
{
return
;
}
RefPtr
<
nsCommandParams
>
params
=
new
nsCommandParams
(
)
;
if
(
editCommandTarget
.
IsEditor
(
)
)
{
if
(
NS_FAILED
(
params
-
>
SetCString
(
"
state_attribute
"
"
"
_ns
)
)
)
{
return
;
}
if
(
NS_FAILED
(
editCommandTarget
.
GetCommandStateParams
(
*
params
)
)
)
{
return
;
}
}
else
{
RefPtr
<
nsCommandManager
>
commandManager
=
GetMidasCommandManager
(
)
;
if
(
!
commandManager
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
;
}
if
(
NS_FAILED
(
params
-
>
SetCString
(
"
state_attribute
"
"
"
_ns
)
)
)
{
return
;
}
if
(
NS_FAILED
(
commandManager
-
>
GetCommandState
(
commandData
.
mXULCommandName
window
params
)
)
)
{
return
;
}
}
nsAutoCString
result
;
params
-
>
GetCString
(
"
state_attribute
"
result
)
;
CopyUTF8toUTF16
(
result
aValue
)
;
}
void
Document
:
:
MaybeEditingStateChanged
(
)
{
if
(
!
mPendingMaybeEditingStateChanged
&
&
mMayStartLayout
&
&
mUpdateNestLevel
=
=
0
&
&
(
mContentEditableCount
>
0
)
!
=
IsEditingOn
(
)
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
EditingStateChanged
(
)
;
}
else
if
(
!
mInDestructor
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
Document
:
:
MaybeEditingStateChanged
"
this
&
Document
:
:
MaybeEditingStateChanged
)
)
;
}
}
}
void
Document
:
:
NotifyFetchOrXHRSuccess
(
)
{
if
(
mShouldNotifyFetchSuccess
)
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
this
this
u
"
DOMDocFetchSuccess
"
_ns
CanBubble
:
:
eNo
Cancelable
:
:
eNo
nullptr
)
;
}
}
void
Document
:
:
SetNotifyFetchSuccess
(
bool
aShouldNotify
)
{
mShouldNotifyFetchSuccess
=
aShouldNotify
;
}
void
Document
:
:
SetNotifyFormOrPasswordRemoved
(
bool
aShouldNotify
)
{
mShouldNotifyFormOrPasswordRemoved
=
aShouldNotify
;
}
void
Document
:
:
TearingDownEditor
(
)
{
if
(
IsEditingOn
(
)
)
{
mEditingState
=
EditingState
:
:
eTearingDown
;
if
(
IsHTMLOrXHTML
(
)
)
{
RemoveContentEditableStyleSheets
(
)
;
}
}
}
nsresult
Document
:
:
TurnEditingOff
(
)
{
NS_ASSERTION
(
mEditingState
!
=
EditingState
:
:
eOff
"
Editing
is
already
off
.
"
)
;
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
NS_ERROR_FAILURE
;
}
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
NS_ERROR_FAILURE
;
}
bool
isBeingDestroyed
=
false
;
docshell
-
>
IsBeingDestroyed
(
&
isBeingDestroyed
)
;
if
(
isBeingDestroyed
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIEditingSession
>
editSession
;
nsresult
rv
=
docshell
-
>
GetEditingSession
(
getter_AddRefs
(
editSession
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
editSession
-
>
TearDownEditorOnWindow
(
window
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mEditingState
=
EditingState
:
:
eOff
;
if
(
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
if
(
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
FromNodeOrNull
(
fm
-
>
GetFocusedElement
(
)
)
)
{
if
(
RefPtr
<
TextEditor
>
textEditor
=
textControlElement
-
>
GetTextEditor
(
)
)
{
textEditor
-
>
ReinitializeSelection
(
*
textControlElement
)
;
}
}
}
return
NS_OK
;
}
static
bool
HasPresShell
(
nsPIDOMWindowOuter
*
aWindow
)
{
nsIDocShell
*
docShell
=
aWindow
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
return
docShell
-
>
GetPresShell
(
)
!
=
nullptr
;
}
HTMLEditor
*
Document
:
:
GetHTMLEditor
(
)
const
{
nsPIDOMWindowOuter
*
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
nullptr
;
}
return
docshell
-
>
GetHTMLEditor
(
)
;
}
nsresult
Document
:
:
EditingStateChanged
(
)
{
if
(
mRemovedFromDocShell
)
{
return
NS_OK
;
}
if
(
mEditingState
=
=
EditingState
:
:
eSettingUp
|
|
mEditingState
=
=
EditingState
:
:
eTearingDown
)
{
return
NS_OK
;
}
const
bool
designMode
=
IsInDesignMode
(
)
;
EditingState
newState
=
designMode
?
EditingState
:
:
eDesignMode
:
(
mContentEditableCount
>
0
?
EditingState
:
:
eContentEditable
:
EditingState
:
:
eOff
)
;
if
(
mEditingState
=
=
newState
)
{
return
NS_OK
;
}
const
bool
thisDocumentHasFocus
=
ThisDocumentHasFocus
(
)
;
if
(
newState
=
=
EditingState
:
:
eOff
)
{
nsAutoScriptBlocker
scriptBlocker
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetHTMLEditor
(
)
;
NotifyEditableStateChange
(
*
this
)
;
nsresult
rv
=
TurnEditingOff
(
)
;
RefPtr
<
Element
>
focusedElement
=
nsFocusManager
:
:
GetFocusManager
(
)
?
nsFocusManager
:
:
GetFocusManager
(
)
-
>
GetFocusedElement
(
)
:
nullptr
;
DebugOnly
<
nsresult
>
rvIgnored
=
HTMLEditor
:
:
FocusedElementOrDocumentBecomesNotEditable
(
htmlEditor
*
this
focusedElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
FocusedElementOrDocumentBecomesNotEditable
(
)
failed
but
"
"
ignored
"
)
;
return
rv
;
}
if
(
mParentDocument
)
{
mParentDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
}
const
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
NS_ERROR_FAILURE
;
}
nsIDocShell
*
docshell
=
window
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
NS_ERROR_FAILURE
;
}
bool
isBeingDestroyed
=
false
;
docshell
-
>
IsBeingDestroyed
(
&
isBeingDestroyed
)
;
if
(
isBeingDestroyed
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIEditingSession
>
editSession
;
nsresult
rv
=
docshell
-
>
GetEditingSession
(
getter_AddRefs
(
editSession
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
editSession
-
>
GetHTMLEditorForWindow
(
window
)
;
if
(
htmlEditor
)
{
uint32_t
flags
=
0
;
htmlEditor
-
>
GetFlags
(
&
flags
)
;
if
(
flags
&
nsIEditor
:
:
eEditorMailMask
)
{
return
NS_OK
;
}
}
if
(
!
HasPresShell
(
window
)
)
{
return
NS_OK
;
}
bool
makeWindowEditable
=
mEditingState
=
=
EditingState
:
:
eOff
;
bool
spellRecheckAll
=
false
;
bool
putOffToRemoveScriptBlockerUntilModifyingEditingState
=
false
;
htmlEditor
=
nullptr
;
{
EditingState
oldState
=
mEditingState
;
nsAutoEditingState
push
(
this
EditingState
:
:
eSettingUp
)
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
bool
collapseSelectionAtBeginningOfDocument
=
designMode
&
&
oldState
=
=
EditingState
:
:
eOff
;
if
(
collapseSelectionAtBeginningOfDocument
&
&
mContentEditableCount
)
{
Selection
*
selection
=
presShell
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_WARNING_ASSERTION
(
selection
"
Why
don
'
t
we
have
Selection
?
"
)
;
if
(
selection
&
&
selection
-
>
RangeCount
(
)
)
{
collapseSelectionAtBeginningOfDocument
=
false
;
}
}
MOZ_ASSERT
(
mStyleSetFilled
)
;
if
(
IsHTMLOrXHTML
(
)
)
{
AddContentEditableStyleSheetsToStyleSet
(
designMode
)
;
}
if
(
designMode
)
{
spellRecheckAll
=
oldState
=
=
EditingState
:
:
eContentEditable
;
}
nsAutoScriptBlocker
scriptBlocker
;
if
(
designMode
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsIContent
*
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
if
(
focusedContent
)
{
nsIFrame
*
focusedFrame
=
focusedContent
-
>
GetPrimaryFrame
(
)
;
bool
clearFocus
=
focusedFrame
?
!
focusedFrame
-
>
IsFocusable
(
)
:
!
focusedContent
-
>
IsFocusable
(
)
;
if
(
clearFocus
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
fm
-
>
ClearFocus
(
window
)
;
putOffToRemoveScriptBlockerUntilModifyingEditingState
=
true
;
}
}
}
}
if
(
makeWindowEditable
)
{
rv
=
editSession
-
>
MakeWindowEditable
(
window
"
html
"
false
false
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
htmlEditor
=
docshell
-
>
GetHTMLEditor
(
)
;
if
(
!
htmlEditor
)
{
return
NS_OK
;
}
if
(
collapseSelectionAtBeginningOfDocument
)
{
htmlEditor
-
>
BeginningOfDocument
(
)
;
}
if
(
putOffToRemoveScriptBlockerUntilModifyingEditingState
)
{
nsContentUtils
:
:
AddScriptBlocker
(
)
;
}
}
mEditingState
=
newState
;
if
(
putOffToRemoveScriptBlockerUntilModifyingEditingState
)
{
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
if
(
mEditingState
=
=
EditingState
:
:
eOff
)
{
return
NS_OK
;
}
}
if
(
makeWindowEditable
)
{
if
(
MOZ_UNLIKELY
(
NS_WARN_IF
(
!
IsHTMLOrXHTML
(
)
)
)
)
{
editSession
-
>
TearDownEditorOnWindow
(
window
)
;
mEditingState
=
EditingState
:
:
eOff
;
return
NS_ERROR_DOM_INVALID_STATE_ERR
;
}
htmlEditor
-
>
SetReturnInParagraphCreatesNewParagraph
(
true
)
;
}
if
(
spellRecheckAll
)
{
nsCOMPtr
<
nsISelectionController
>
selectionController
=
htmlEditor
-
>
GetSelectionController
(
)
;
if
(
NS_WARN_IF
(
!
selectionController
)
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Selection
>
spellCheckSelection
=
selectionController
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_SPELLCHECK
)
;
if
(
spellCheckSelection
)
{
spellCheckSelection
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
}
htmlEditor
-
>
SyncRealTimeSpell
(
)
;
MaybeDispatchCheckKeyPressEventModelEvent
(
)
;
if
(
thisDocumentHasFocus
&
&
htmlEditor
-
>
IsInDesignMode
(
)
&
&
ThisDocumentHasFocus
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
htmlEditor
-
>
FocusedElementOrDocumentBecomesEditable
(
*
this
nullptr
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
FocusedElementOrDocumentBecomesEditable
(
)
"
"
failed
but
ignored
"
)
;
}
return
NS_OK
;
}
class
DeferredContentEditableCountChangeEvent
:
public
Runnable
{
public
:
DeferredContentEditableCountChangeEvent
(
Document
*
aDoc
Element
*
aElement
)
:
mozilla
:
:
Runnable
(
"
DeferredContentEditableCountChangeEvent
"
)
mDoc
(
aDoc
)
mElement
(
aElement
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
mElement
&
&
mElement
-
>
OwnerDoc
(
)
=
=
mDoc
)
{
RefPtr
<
Document
>
doc
=
std
:
:
move
(
mDoc
)
;
RefPtr
<
Element
>
element
=
std
:
:
move
(
mElement
)
;
doc
-
>
DeferredContentEditableCountChange
(
element
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
Document
>
mDoc
;
RefPtr
<
Element
>
mElement
;
}
;
void
Document
:
:
ChangeContentEditableCount
(
Element
*
aElement
int32_t
aChange
)
{
NS_ASSERTION
(
int32_t
(
mContentEditableCount
)
+
aChange
>
=
0
"
Trying
to
decrement
too
much
.
"
)
;
mContentEditableCount
+
=
aChange
;
if
(
aElement
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
DeferredContentEditableCountChangeEvent
(
this
aElement
)
)
;
}
}
void
Document
:
:
DeferredContentEditableCountChange
(
Element
*
aElement
)
{
const
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
const
bool
elementHasFocus
=
aElement
&
&
fm
&
&
fm
-
>
GetFocusedElement
(
)
=
=
aElement
;
if
(
elementHasFocus
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetHTMLEditor
(
)
;
if
(
aElement
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
if
(
htmlEditor
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
htmlEditor
-
>
FocusedElementOrDocumentBecomesEditable
(
*
this
aElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
FocusedElementOrDocumentBecomesEditable
(
)
failed
but
"
"
ignored
"
)
;
}
}
else
{
DebugOnly
<
nsresult
>
rvIgnored
=
HTMLEditor
:
:
FocusedElementOrDocumentBecomesNotEditable
(
htmlEditor
*
this
aElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
FocusedElementOrDocumentBecomesNotEditable
(
)
failed
"
"
but
ignored
"
)
;
}
}
if
(
mParser
|
|
(
mUpdateNestLevel
>
0
&
&
(
mContentEditableCount
>
0
)
!
=
IsEditingOn
(
)
)
)
{
return
;
}
EditingState
oldState
=
mEditingState
;
nsresult
rv
=
EditingStateChanged
(
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
oldState
=
=
mEditingState
&
&
mEditingState
=
=
EditingState
:
:
eContentEditable
)
{
if
(
aElement
)
{
if
(
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetHTMLEditor
(
)
)
{
nsCOMPtr
<
nsIInlineSpellChecker
>
spellChecker
;
rv
=
htmlEditor
-
>
GetInlineSpellChecker
(
false
getter_AddRefs
(
spellChecker
)
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
if
(
spellChecker
&
&
aElement
-
>
InclusiveDescendantMayNeedSpellchecking
(
htmlEditor
)
)
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aElement
)
;
IgnoredErrorResult
res
;
range
-
>
SelectNode
(
*
aElement
res
)
;
if
(
res
.
Failed
(
)
)
{
return
;
}
rv
=
spellChecker
-
>
SpellCheckRange
(
range
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
}
}
}
}
if
(
elementHasFocus
&
&
aElement
-
>
HasFlag
(
NODE_IS_EDITABLE
)
&
&
fm
-
>
GetFocusedElement
(
)
=
=
aElement
)
{
if
(
RefPtr
<
HTMLEditor
>
htmlEditor
=
GetHTMLEditor
(
)
)
{
DebugOnly
<
nsresult
>
rvIgnored
=
htmlEditor
-
>
FocusedElementOrDocumentBecomesEditable
(
*
this
aElement
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rvIgnored
)
"
HTMLEditor
:
:
FocusedElementOrDocumentBecomesEditable
(
)
failed
but
"
"
ignored
"
)
;
}
}
}
void
Document
:
:
MaybeDispatchCheckKeyPressEventModelEvent
(
)
{
if
(
mEditingState
!
=
EditingState
:
:
eContentEditable
)
{
return
;
}
if
(
mHasBeenEditable
)
{
return
;
}
mHasBeenEditable
=
true
;
WidgetEvent
checkEvent
(
true
eUnidentifiedEvent
)
;
checkEvent
.
mSpecifiedEventType
=
nsGkAtoms
:
:
onCheckKeyPressEventModel
;
checkEvent
.
mFlags
.
mCancelable
=
false
;
checkEvent
.
mFlags
.
mBubbles
=
false
;
checkEvent
.
mFlags
.
mOnlySystemGroupDispatch
=
true
;
(
new
AsyncEventDispatcher
(
this
checkEvent
)
)
-
>
PostDOMEvent
(
)
;
}
void
Document
:
:
SetKeyPressEventModel
(
uint16_t
aKeyPressEventModel
)
{
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
presShell
-
>
SetKeyPressEventModel
(
aKeyPressEventModel
)
;
}
TimeStamp
Document
:
:
LastFocusTime
(
)
const
{
return
mLastFocusTime
;
}
void
Document
:
:
SetLastFocusTime
(
const
TimeStamp
&
aFocusTime
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aFocusTime
.
IsNull
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mLastFocusTime
.
IsNull
(
)
|
|
aFocusTime
>
=
mLastFocusTime
)
;
mLastFocusTime
=
aFocusTime
;
}
void
Document
:
:
GetReferrer
(
nsAString
&
aReferrer
)
const
{
aReferrer
.
Truncate
(
)
;
if
(
!
mReferrerInfo
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
referrer
=
mReferrerInfo
-
>
GetComputedReferrer
(
)
;
if
(
!
referrer
)
{
return
;
}
nsAutoCString
uri
;
nsresult
rv
=
URLDecorationStripper
:
:
StripTrackingIdentifiers
(
referrer
uri
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
CopyUTF8toUTF16
(
uri
aReferrer
)
;
}
void
Document
:
:
GetCookie
(
nsAString
&
aCookie
ErrorResult
&
aRv
)
{
aCookie
.
Truncate
(
)
;
if
(
mDisableCookieAccess
)
{
return
;
}
if
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
{
aRv
.
ThrowSecurityError
(
"
Forbidden
in
a
sandboxed
document
without
the
'
allow
-
same
-
origin
'
"
"
flag
.
"
)
;
return
;
}
StorageAccess
storageAccess
=
CookieAllowedForDocument
(
this
)
;
if
(
storageAccess
=
=
StorageAccess
:
:
eDeny
)
{
return
;
}
if
(
ShouldPartitionStorage
(
storageAccess
)
&
&
!
StoragePartitioningEnabled
(
storageAccess
CookieJarSettings
(
)
)
)
{
return
;
}
if
(
IsCookieAverse
(
)
)
{
return
;
}
nsCOMPtr
<
nsICookieService
>
service
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
if
(
service
)
{
nsAutoCString
cookie
;
service
-
>
GetCookieStringFromDocument
(
this
cookie
)
;
UTF_8_ENCODING
-
>
DecodeWithoutBOMHandling
(
cookie
aCookie
)
;
}
}
void
Document
:
:
SetCookie
(
const
nsAString
&
aCookie
ErrorResult
&
aRv
)
{
if
(
mDisableCookieAccess
)
{
return
;
}
if
(
mSandboxFlags
&
SANDBOXED_ORIGIN
)
{
aRv
.
ThrowSecurityError
(
"
Forbidden
in
a
sandboxed
document
without
the
'
allow
-
same
-
origin
'
"
"
flag
.
"
)
;
return
;
}
StorageAccess
storageAccess
=
CookieAllowedForDocument
(
this
)
;
if
(
storageAccess
=
=
StorageAccess
:
:
eDeny
)
{
return
;
}
if
(
ShouldPartitionStorage
(
storageAccess
)
&
&
!
StoragePartitioningEnabled
(
storageAccess
CookieJarSettings
(
)
)
)
{
return
;
}
if
(
IsCookieAverse
(
)
)
{
return
;
}
if
(
!
mDocumentURI
)
{
return
;
}
nsCOMPtr
<
nsICookieService
>
service
=
do_GetService
(
NS_COOKIESERVICE_CONTRACTID
)
;
if
(
!
service
)
{
return
;
}
NS_ConvertUTF16toUTF8
cookie
(
aCookie
)
;
nsresult
rv
=
service
-
>
SetCookieStringFromDocument
(
this
cookie
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
this
)
"
document
-
set
-
cookie
"
nsString
(
aCookie
)
.
get
(
)
)
;
}
}
ReferrerPolicy
Document
:
:
GetReferrerPolicy
(
)
const
{
return
mReferrerInfo
?
mReferrerInfo
-
>
ReferrerPolicy
(
)
:
ReferrerPolicy
:
:
_empty
;
}
void
Document
:
:
GetAlinkColor
(
nsAString
&
aAlinkColor
)
{
aAlinkColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetALink
(
aAlinkColor
)
;
}
}
void
Document
:
:
SetAlinkColor
(
const
nsAString
&
aAlinkColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetALink
(
aAlinkColor
)
;
}
}
void
Document
:
:
GetLinkColor
(
nsAString
&
aLinkColor
)
{
aLinkColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetLink
(
aLinkColor
)
;
}
}
void
Document
:
:
SetLinkColor
(
const
nsAString
&
aLinkColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetLink
(
aLinkColor
)
;
}
}
void
Document
:
:
GetVlinkColor
(
nsAString
&
aVlinkColor
)
{
aVlinkColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetVLink
(
aVlinkColor
)
;
}
}
void
Document
:
:
SetVlinkColor
(
const
nsAString
&
aVlinkColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetVLink
(
aVlinkColor
)
;
}
}
void
Document
:
:
GetBgColor
(
nsAString
&
aBgColor
)
{
aBgColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetBgColor
(
aBgColor
)
;
}
}
void
Document
:
:
SetBgColor
(
const
nsAString
&
aBgColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetBgColor
(
aBgColor
)
;
}
}
void
Document
:
:
GetFgColor
(
nsAString
&
aFgColor
)
{
aFgColor
.
Truncate
(
)
;
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
GetText
(
aFgColor
)
;
}
}
void
Document
:
:
SetFgColor
(
const
nsAString
&
aFgColor
)
{
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
body
)
{
body
-
>
SetText
(
aFgColor
)
;
}
}
void
Document
:
:
CaptureEvents
(
)
{
WarnOnceAbout
(
DeprecatedOperations
:
:
eUseOfCaptureEvents
)
;
}
void
Document
:
:
ReleaseEvents
(
)
{
WarnOnceAbout
(
DeprecatedOperations
:
:
eUseOfReleaseEvents
)
;
}
HTMLAllCollection
*
Document
:
:
All
(
)
{
if
(
!
mAll
)
{
mAll
=
new
HTMLAllCollection
(
this
)
;
}
return
mAll
;
}
nsresult
Document
:
:
GetSrcdocData
(
nsAString
&
aSrcdocData
)
{
if
(
mIsSrcdocDocument
)
{
nsCOMPtr
<
nsIInputStreamChannel
>
inStrmChan
=
do_QueryInterface
(
mChannel
)
;
if
(
inStrmChan
)
{
return
inStrmChan
-
>
GetSrcdocData
(
aSrcdocData
)
;
}
}
aSrcdocData
=
VoidString
(
)
;
return
NS_OK
;
}
Nullable
<
WindowProxyHolder
>
Document
:
:
GetDefaultView
(
)
const
{
nsPIDOMWindowOuter
*
win
=
GetWindow
(
)
;
if
(
!
win
)
{
return
nullptr
;
}
return
WindowProxyHolder
(
win
-
>
GetBrowsingContext
(
)
)
;
}
nsIContent
*
Document
:
:
GetUnretargetedFocusedContent
(
IncludeChromeOnly
aIncludeChromeOnly
)
const
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsIContent
*
focusedContent
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
focusedContent
)
{
return
nullptr
;
}
if
(
focusedContent
-
>
OwnerDoc
(
)
!
=
this
)
{
return
nullptr
;
}
if
(
focusedContent
-
>
ChromeOnlyAccess
(
)
&
&
aIncludeChromeOnly
=
=
IncludeChromeOnly
:
:
No
)
{
return
focusedContent
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
}
return
focusedContent
;
}
Element
*
Document
:
:
GetActiveElement
(
)
{
Element
*
focusedElement
=
GetRetargetedFocusedElement
(
)
;
if
(
focusedElement
)
{
return
focusedElement
;
}
if
(
IsHTMLOrXHTML
(
)
)
{
Element
*
bodyElement
=
AsHTMLDocument
(
)
-
>
GetBody
(
)
;
if
(
bodyElement
)
{
return
bodyElement
;
}
if
(
nsContentUtils
:
:
IsChromeDoc
(
this
)
)
{
Element
*
docElement
=
GetDocumentElement
(
)
;
if
(
docElement
&
&
docElement
-
>
IsXULElement
(
)
)
{
return
docElement
;
}
}
return
nullptr
;
}
return
GetDocumentElement
(
)
;
}
Element
*
Document
:
:
GetCurrentScript
(
)
{
nsCOMPtr
<
Element
>
el
(
do_QueryInterface
(
ScriptLoader
(
)
-
>
GetCurrentScript
(
)
)
)
;
return
el
;
}
void
Document
:
:
ReleaseCapture
(
)
const
{
nsCOMPtr
<
nsINode
>
node
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
node
&
&
nsContentUtils
:
:
CanCallerAccess
(
node
)
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
}
nsIURI
*
Document
:
:
GetBaseURI
(
bool
aTryUseXHRDocBaseURI
)
const
{
if
(
aTryUseXHRDocBaseURI
&
&
mChromeXHRDocBaseURI
)
{
return
mChromeXHRDocBaseURI
;
}
return
GetDocBaseURI
(
)
;
}
void
Document
:
:
SetBaseURI
(
nsIURI
*
aURI
)
{
if
(
!
aURI
&
&
!
mDocumentBaseURI
)
{
return
;
}
if
(
aURI
&
&
mDocumentBaseURI
)
{
bool
equalBases
=
false
;
mDocumentBaseURI
-
>
Equals
(
aURI
&
equalBases
)
;
if
(
equalBases
)
{
return
;
}
}
mDocumentBaseURI
=
aURI
;
mCachedURLData
=
nullptr
;
RefreshLinkHrefs
(
)
;
}
Result
<
OwningNonNull
<
nsIURI
>
nsresult
>
Document
:
:
ResolveWithBaseURI
(
const
nsAString
&
aURI
)
{
RefPtr
<
nsIURI
>
resolvedURI
;
MOZ_TRY
(
NS_NewURI
(
getter_AddRefs
(
resolvedURI
)
aURI
nullptr
GetDocBaseURI
(
)
)
)
;
return
OwningNonNull
<
nsIURI
>
(
std
:
:
move
(
resolvedURI
)
)
;
}
nsIReferrerInfo
*
Document
:
:
ReferrerInfoForInternalCSSAndSVGResources
(
)
{
if
(
!
mCachedReferrerInfoForInternalCSSAndSVGResources
)
{
mCachedReferrerInfoForInternalCSSAndSVGResources
=
ReferrerInfo
:
:
CreateForInternalCSSAndSVGResources
(
this
)
;
}
return
mCachedReferrerInfoForInternalCSSAndSVGResources
;
}
URLExtraData
*
Document
:
:
DefaultStyleAttrURLData
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mCachedURLData
)
{
mCachedURLData
=
new
URLExtraData
(
GetDocBaseURI
(
)
ReferrerInfoForInternalCSSAndSVGResources
(
)
NodePrincipal
(
)
)
;
}
return
mCachedURLData
;
}
void
Document
:
:
SetDocumentCharacterSet
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
if
(
mCharacterSet
!
=
aEncoding
)
{
mCharacterSet
=
aEncoding
;
mEncodingMenuDisabled
=
aEncoding
=
=
UTF_8_ENCODING
;
RecomputeLanguageFromCharset
(
)
;
if
(
nsPresContext
*
context
=
GetPresContext
(
)
)
{
context
-
>
DocumentCharSetChanged
(
aEncoding
)
;
}
}
}
void
Document
:
:
GetSandboxFlagsAsString
(
nsAString
&
aFlags
)
{
nsContentUtils
:
:
SandboxFlagsToString
(
mSandboxFlags
aFlags
)
;
}
void
Document
:
:
GetHeaderData
(
nsAtom
*
aHeaderField
nsAString
&
aData
)
const
{
aData
.
Truncate
(
)
;
const
HeaderData
*
data
=
mHeaderData
.
get
(
)
;
while
(
data
)
{
if
(
data
-
>
mField
=
=
aHeaderField
)
{
aData
=
data
-
>
mData
;
break
;
}
data
=
data
-
>
mNext
.
get
(
)
;
}
}
void
Document
:
:
SetHeaderData
(
nsAtom
*
aHeaderField
const
nsAString
&
aData
)
{
if
(
!
aHeaderField
)
{
NS_ERROR
(
"
null
headerField
"
)
;
return
;
}
if
(
!
mHeaderData
)
{
if
(
!
aData
.
IsEmpty
(
)
)
{
mHeaderData
=
MakeUnique
<
HeaderData
>
(
aHeaderField
aData
)
;
}
}
else
{
HeaderData
*
data
=
mHeaderData
.
get
(
)
;
UniquePtr
<
HeaderData
>
*
lastPtr
=
&
mHeaderData
;
bool
found
=
false
;
do
{
if
(
data
-
>
mField
=
=
aHeaderField
)
{
if
(
!
aData
.
IsEmpty
(
)
)
{
data
-
>
mData
.
Assign
(
aData
)
;
}
else
{
*
lastPtr
=
std
:
:
move
(
data
-
>
mNext
)
;
}
found
=
true
;
break
;
}
lastPtr
=
&
data
-
>
mNext
;
data
=
lastPtr
-
>
get
(
)
;
}
while
(
data
)
;
if
(
!
aData
.
IsEmpty
(
)
&
&
!
found
)
{
*
lastPtr
=
MakeUnique
<
HeaderData
>
(
aHeaderField
aData
)
;
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
headerContentLanguage
)
{
if
(
aData
.
IsEmpty
(
)
)
{
mContentLanguage
=
nullptr
;
}
else
{
mContentLanguage
=
NS_AtomizeMainThread
(
aData
)
;
}
mMayNeedFontPrefsUpdate
=
true
;
if
(
auto
*
presContext
=
GetPresContext
(
)
)
{
presContext
-
>
ContentLanguageChanged
(
)
;
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
origin_trial
)
{
mTrials
.
UpdateFromToken
(
aData
NodePrincipal
(
)
)
;
if
(
mTrials
.
IsEnabled
(
OriginTrial
:
:
CoepCredentialless
)
)
{
InitCOEP
(
mChannel
)
;
if
(
WindowContext
*
ctx
=
GetWindowContext
(
)
)
{
if
(
mEmbedderPolicy
)
{
Unused
<
<
ctx
-
>
SetEmbedderPolicy
(
mEmbedderPolicy
.
value
(
)
)
;
}
}
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
headerDefaultStyle
)
{
SetPreferredStyleSheetSet
(
aData
)
;
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
refresh
&
&
!
IsStaticDocument
(
)
)
{
if
(
mDocumentContainer
)
{
mDocumentContainer
-
>
SetupRefreshURIFromHeader
(
this
aData
)
;
}
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
headerDNSPrefetchControl
&
&
mAllowDNSPrefetch
)
{
mAllowDNSPrefetch
=
aData
.
IsEmpty
(
)
|
|
aData
.
LowerCaseEqualsLiteral
(
"
on
"
)
;
}
if
(
aHeaderField
=
=
nsGkAtoms
:
:
handheldFriendly
)
{
mViewportType
=
Unknown
;
}
}
void
Document
:
:
SetEarlyHints
(
nsTArray
<
net
:
:
EarlyHintConnectArgs
>
&
&
aEarlyHints
)
{
mEarlyHints
=
std
:
:
move
(
aEarlyHints
)
;
}
void
Document
:
:
TryChannelCharset
(
nsIChannel
*
aChannel
int32_t
&
aCharsetSource
NotNull
<
const
Encoding
*
>
&
aEncoding
nsHtml5TreeOpExecutor
*
aExecutor
)
{
if
(
aChannel
)
{
nsAutoCString
charsetVal
;
nsresult
rv
=
aChannel
-
>
GetContentCharset
(
charsetVal
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
const
Encoding
*
preferred
=
Encoding
:
:
ForLabel
(
charsetVal
)
;
if
(
preferred
)
{
if
(
aExecutor
&
&
preferred
=
=
REPLACEMENT_ENCODING
)
{
aExecutor
-
>
ComplainAboutBogusProtocolCharset
(
this
false
)
;
}
aEncoding
=
WrapNotNull
(
preferred
)
;
aCharsetSource
=
kCharsetFromChannel
;
return
;
}
else
if
(
aExecutor
&
&
!
charsetVal
.
IsEmpty
(
)
)
{
aExecutor
-
>
ComplainAboutBogusProtocolCharset
(
this
true
)
;
}
}
}
}
static
inline
void
AssertNoStaleServoDataIn
(
nsINode
&
aSubtreeRoot
)
{
#
ifdef
DEBUG
for
(
nsINode
*
node
:
ShadowIncludingTreeIterator
(
aSubtreeRoot
)
)
{
const
Element
*
element
=
Element
:
:
FromNode
(
node
)
;
if
(
!
element
)
{
continue
;
}
MOZ_ASSERT
(
!
element
-
>
HasServoData
(
)
)
;
}
#
endif
}
already_AddRefed
<
PresShell
>
Document
:
:
CreatePresShell
(
nsPresContext
*
aContext
nsViewManager
*
aViewManager
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mPresShell
"
We
have
a
presshell
already
!
"
)
;
NS_ENSURE_FALSE
(
GetBFCacheEntry
(
)
nullptr
)
;
AssertNoStaleServoDataIn
(
*
this
)
;
RefPtr
<
PresShell
>
presShell
=
new
PresShell
(
this
)
;
mPresShell
=
presShell
;
if
(
!
mStyleSetFilled
)
{
FillStyleSet
(
)
;
}
presShell
-
>
Init
(
aContext
aViewManager
)
;
if
(
RefPtr
<
class
HighlightRegistry
>
highlightRegistry
=
mHighlightRegistry
)
{
highlightRegistry
-
>
AddHighlightSelectionsToFrameSelection
(
)
;
}
aContext
-
>
MediaFeatureValuesChanged
(
{
MediaFeatureChange
:
:
kAllChanges
}
MediaFeatureChangePropagation
:
:
JustThisDocument
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
&
&
docShell
-
>
IsInvisible
(
)
)
{
presShell
-
>
SetNeverPainting
(
true
)
;
}
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
with
PressShell
%
p
and
DocShell
%
p
"
this
presShell
.
get
(
)
docShell
.
get
(
)
)
)
;
mExternalResourceMap
.
ShowViewers
(
)
;
UpdateFrameRequestCallbackSchedulingState
(
)
;
if
(
mDocumentL10n
)
{
mDocumentL10n
-
>
OnCreatePresShell
(
)
;
}
if
(
HasAutoFocusCandidates
(
)
)
{
ScheduleFlushAutoFocusCandidates
(
)
;
}
MarkUserFontSetDirty
(
)
;
if
(
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
)
{
presShell
-
>
SetAuthorStyleDisabled
(
bc
-
>
Top
(
)
-
>
AuthorStyleDisabledDefault
(
)
)
;
}
return
presShell
.
forget
(
)
;
}
void
Document
:
:
UpdateFrameRequestCallbackSchedulingState
(
PresShell
*
aOldPresShell
)
{
bool
shouldBeScheduled
=
WouldScheduleFrameRequestCallbacks
(
)
&
&
!
mFrameRequestManager
.
IsEmpty
(
)
;
if
(
shouldBeScheduled
=
=
mFrameRequestCallbacksScheduled
)
{
return
;
}
PresShell
*
presShell
=
aOldPresShell
?
aOldPresShell
:
mPresShell
;
MOZ_RELEASE_ASSERT
(
presShell
)
;
nsRefreshDriver
*
rd
=
presShell
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
if
(
shouldBeScheduled
)
{
rd
-
>
ScheduleFrameRequestCallbacks
(
this
)
;
}
else
{
rd
-
>
RevokeFrameRequestCallbacks
(
this
)
;
}
mFrameRequestCallbacksScheduled
=
shouldBeScheduled
;
}
void
Document
:
:
TakeFrameRequestCallbacks
(
nsTArray
<
FrameRequest
>
&
aCallbacks
)
{
MOZ_ASSERT
(
aCallbacks
.
IsEmpty
(
)
)
;
mFrameRequestManager
.
Take
(
aCallbacks
)
;
mFrameRequestCallbacksScheduled
=
false
;
}
bool
Document
:
:
ShouldThrottleFrameRequests
(
)
const
{
if
(
mStaticCloneCount
>
0
)
{
return
false
;
}
if
(
Hidden
(
)
)
{
return
true
;
}
if
(
!
mPresShell
)
{
return
false
;
}
if
(
!
mPresShell
-
>
IsActive
(
)
)
{
return
true
;
}
if
(
mPresShell
-
>
IsPaintingSuppressed
(
)
)
{
return
true
;
}
if
(
mPresShell
-
>
IsUnderHiddenEmbedderElement
(
)
)
{
return
true
;
}
Element
*
el
=
GetEmbedderElement
(
)
;
if
(
!
el
)
{
return
false
;
}
if
(
!
StaticPrefs
:
:
layout_throttle_in_process_iframes
(
)
)
{
return
false
;
}
const
IntersectionInput
input
=
DOMIntersectionObserver
:
:
ComputeInput
(
*
el
-
>
OwnerDoc
(
)
nullptr
nullptr
)
;
const
IntersectionOutput
output
=
DOMIntersectionObserver
:
:
Intersect
(
input
*
el
)
;
return
!
output
.
Intersects
(
)
;
}
void
Document
:
:
DeletePresShell
(
)
{
mExternalResourceMap
.
HideViewers
(
)
;
if
(
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
RefreshDriver
(
)
-
>
CancelPendingFullscreenEvents
(
this
)
;
presContext
-
>
RefreshDriver
(
)
-
>
CancelFlushAutoFocus
(
this
)
;
}
ImageTracker
(
)
-
>
RequestDiscardAll
(
)
;
MarkUserFontSetDirty
(
)
;
if
(
IsEditingOn
(
)
)
{
TurnEditingOff
(
)
;
}
PresShell
*
oldPresShell
=
mPresShell
;
mPresShell
=
nullptr
;
UpdateFrameRequestCallbackSchedulingState
(
oldPresShell
)
;
ClearStaleServoData
(
)
;
AssertNoStaleServoDataIn
(
*
this
)
;
mStyleSet
-
>
ShellDetachedFromDocument
(
)
;
mStyleSetFilled
=
false
;
mQuirkSheetAdded
=
false
;
mContentEditableSheetAdded
=
false
;
mDesignModeSheetAdded
=
false
;
}
void
Document
:
:
DisallowBFCaching
(
uint32_t
aStatus
)
{
NS_ASSERTION
(
!
mBFCacheEntry
"
We
'
re
already
in
the
bfcache
!
"
)
;
if
(
!
mBFCacheDisallowed
)
{
if
(
WindowGlobalChild
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
SendUpdateBFCacheStatus
(
aStatus
0
)
;
}
}
mBFCacheDisallowed
=
true
;
}
void
Document
:
:
SetBFCacheEntry
(
nsIBFCacheEntry
*
aEntry
)
{
MOZ_ASSERT
(
IsBFCachingAllowed
(
)
|
|
!
aEntry
"
You
should
have
checked
!
"
)
;
if
(
mPresShell
)
{
if
(
aEntry
)
{
mPresShell
-
>
StopObservingRefreshDriver
(
)
;
}
else
if
(
mBFCacheEntry
)
{
mPresShell
-
>
StartObservingRefreshDriver
(
)
;
}
}
mBFCacheEntry
=
aEntry
;
}
bool
Document
:
:
RemoveFromBFCacheSync
(
)
{
bool
removed
=
false
;
if
(
nsCOMPtr
<
nsIBFCacheEntry
>
entry
=
GetBFCacheEntry
(
)
)
{
entry
-
>
RemoveFromBFCacheSync
(
)
;
removed
=
true
;
}
else
if
(
!
IsCurrentActiveDocument
(
)
)
{
DisallowBFCaching
(
)
;
removed
=
true
;
}
if
(
mozilla
:
:
SessionHistoryInParent
(
)
&
&
XRE_IsContentProcess
(
)
)
{
if
(
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
)
{
if
(
bc
-
>
IsInBFCache
(
)
)
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
cc
-
>
SendRemoveFromBFCache
(
bc
-
>
Top
(
)
)
;
removed
=
true
;
}
}
}
return
removed
;
}
static
void
SubDocClearEntry
(
PLDHashTable
*
table
PLDHashEntryHdr
*
entry
)
{
SubDocMapEntry
*
e
=
static_cast
<
SubDocMapEntry
*
>
(
entry
)
;
NS_RELEASE
(
e
-
>
mKey
)
;
if
(
e
-
>
mSubDocument
)
{
e
-
>
mSubDocument
-
>
SetParentDocument
(
nullptr
)
;
NS_RELEASE
(
e
-
>
mSubDocument
)
;
}
}
static
void
SubDocInitEntry
(
PLDHashEntryHdr
*
entry
const
void
*
key
)
{
SubDocMapEntry
*
e
=
const_cast
<
SubDocMapEntry
*
>
(
static_cast
<
const
SubDocMapEntry
*
>
(
entry
)
)
;
e
-
>
mKey
=
const_cast
<
Element
*
>
(
static_cast
<
const
Element
*
>
(
key
)
)
;
NS_ADDREF
(
e
-
>
mKey
)
;
e
-
>
mSubDocument
=
nullptr
;
}
nsresult
Document
:
:
SetSubDocumentFor
(
Element
*
aElement
Document
*
aSubDoc
)
{
NS_ENSURE_TRUE
(
aElement
NS_ERROR_UNEXPECTED
)
;
if
(
!
aSubDoc
)
{
if
(
mSubDocuments
)
{
mSubDocuments
-
>
Remove
(
aElement
)
;
}
}
else
{
if
(
!
mSubDocuments
)
{
static
const
PLDHashTableOps
hash_table_ops
=
{
PLDHashTable
:
:
HashVoidPtrKeyStub
PLDHashTable
:
:
MatchEntryStub
PLDHashTable
:
:
MoveEntryStub
SubDocClearEntry
SubDocInitEntry
}
;
mSubDocuments
=
new
PLDHashTable
(
&
hash_table_ops
sizeof
(
SubDocMapEntry
)
)
;
}
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
mSubDocuments
-
>
Add
(
aElement
fallible
)
)
;
if
(
!
entry
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
entry
-
>
mSubDocument
)
{
entry
-
>
mSubDocument
-
>
SetParentDocument
(
nullptr
)
;
NS_RELEASE
(
entry
-
>
mSubDocument
)
;
}
entry
-
>
mSubDocument
=
aSubDoc
;
NS_ADDREF
(
entry
-
>
mSubDocument
)
;
aSubDoc
-
>
SetParentDocument
(
this
)
;
}
return
NS_OK
;
}
Document
*
Document
:
:
GetSubDocumentFor
(
nsIContent
*
aContent
)
const
{
if
(
mSubDocuments
&
&
aContent
-
>
IsElement
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
mSubDocuments
-
>
Search
(
aContent
-
>
AsElement
(
)
)
)
;
if
(
entry
)
{
return
entry
-
>
mSubDocument
;
}
}
return
nullptr
;
}
Element
*
Document
:
:
GetEmbedderElement
(
)
const
{
if
(
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
)
{
return
bc
-
>
GetExtantDocument
(
)
=
=
this
?
bc
-
>
GetEmbedderElement
(
)
:
nullptr
;
}
return
nullptr
;
}
Element
*
Document
:
:
GetRootElement
(
)
const
{
return
(
mCachedRootElement
&
&
mCachedRootElement
-
>
GetParentNode
(
)
=
=
this
)
?
mCachedRootElement
:
GetRootElementInternal
(
)
;
}
Element
*
Document
:
:
GetUnfocusedKeyEventTarget
(
)
{
return
GetRootElement
(
)
;
}
Element
*
Document
:
:
GetRootElementInternal
(
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
nsIContent
*
child
=
GetLastChild
(
)
;
child
;
child
=
child
-
>
GetPreviousSibling
(
)
)
{
if
(
Element
*
element
=
Element
:
:
FromNode
(
child
)
)
{
const_cast
<
Document
*
>
(
this
)
-
>
mCachedRootElement
=
element
;
return
element
;
}
}
const_cast
<
Document
*
>
(
this
)
-
>
mCachedRootElement
=
nullptr
;
return
nullptr
;
}
void
Document
:
:
InsertChildBefore
(
nsIContent
*
aKid
nsIContent
*
aBeforeThis
bool
aNotify
ErrorResult
&
aRv
)
{
if
(
aKid
-
>
IsElement
(
)
&
&
GetRootElement
(
)
)
{
NS_WARNING
(
"
Inserting
root
element
when
we
already
have
one
"
)
;
aRv
.
ThrowHierarchyRequestError
(
"
There
is
already
a
root
element
.
"
)
;
return
;
}
nsINode
:
:
InsertChildBefore
(
aKid
aBeforeThis
aNotify
aRv
)
;
}
void
Document
:
:
RemoveChildNode
(
nsIContent
*
aKid
bool
aNotify
)
{
Maybe
<
mozAutoDocUpdate
>
updateBatch
;
if
(
aKid
-
>
IsElement
(
)
)
{
updateBatch
.
emplace
(
this
aNotify
)
;
DestroyElementMaps
(
)
;
}
mCachedRootElement
=
nullptr
;
nsINode
:
:
RemoveChildNode
(
aKid
aNotify
)
;
MOZ_ASSERT
(
mCachedRootElement
!
=
aKid
"
Stale
pointer
in
mCachedRootElement
after
we
tried
to
clear
it
"
"
(
maybe
somebody
called
GetRootElement
(
)
too
early
?
)
"
)
;
}
void
Document
:
:
AddStyleSheetToStyleSets
(
StyleSheet
&
aSheet
)
{
if
(
mStyleSetFilled
)
{
EnsureStyleSet
(
)
.
AddDocStyleSheet
(
aSheet
)
;
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
RecordShadowStyleChange
(
ShadowRoot
&
aShadowRoot
)
{
EnsureStyleSet
(
)
.
RecordShadowStyleChange
(
aShadowRoot
)
;
ApplicableStylesChanged
(
true
)
;
}
void
Document
:
:
ApplicableStylesChanged
(
bool
aKnownInShadowTree
)
{
if
(
!
mStyleSetFilled
)
{
return
;
}
if
(
!
aKnownInShadowTree
)
{
MarkUserFontSetDirty
(
)
;
}
PresShell
*
ps
=
GetPresShell
(
)
;
if
(
!
ps
)
{
return
;
}
ps
-
>
EnsureStyleFlush
(
)
;
nsPresContext
*
pc
=
ps
-
>
GetPresContext
(
)
;
if
(
!
pc
)
{
return
;
}
if
(
!
aKnownInShadowTree
)
{
pc
-
>
MarkCounterStylesDirty
(
)
;
pc
-
>
MarkFontFeatureValuesDirty
(
)
;
pc
-
>
MarkFontPaletteValuesDirty
(
)
;
}
pc
-
>
RestyleManager
(
)
-
>
NextRestyleIsForCSSRuleChanges
(
)
;
}
void
Document
:
:
RemoveStyleSheetFromStyleSets
(
StyleSheet
&
aSheet
)
{
if
(
mStyleSetFilled
)
{
mStyleSet
-
>
RemoveStyleSheet
(
aSheet
)
;
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
InsertSheetAt
(
size_t
aIndex
StyleSheet
&
aSheet
)
{
DocumentOrShadowRoot
:
:
InsertSheetAt
(
aIndex
aSheet
)
;
if
(
aSheet
.
IsApplicable
(
)
)
{
AddStyleSheetToStyleSets
(
aSheet
)
;
}
}
void
Document
:
:
StyleSheetApplicableStateChanged
(
StyleSheet
&
aSheet
)
{
const
bool
applicable
=
aSheet
.
IsApplicable
(
)
;
if
(
StyleOrderIndexOfSheet
(
aSheet
)
>
=
0
)
{
if
(
applicable
)
{
AddStyleSheetToStyleSets
(
aSheet
)
;
}
else
{
RemoveStyleSheetFromStyleSets
(
aSheet
)
;
}
}
}
void
Document
:
:
PostStyleSheetApplicableStateChangeEvent
(
StyleSheet
&
aSheet
)
{
if
(
!
StyleSheetChangeEventsEnabled
(
)
)
{
return
;
}
StyleSheetApplicableStateChangeEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
true
;
init
.
mStylesheet
=
&
aSheet
;
init
.
mApplicable
=
aSheet
.
IsApplicable
(
)
;
RefPtr
<
StyleSheetApplicableStateChangeEvent
>
event
=
StyleSheetApplicableStateChangeEvent
:
:
Constructor
(
this
u
"
StyleSheetApplicableStateChanged
"
_ns
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
SetTarget
(
this
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
event
.
forget
(
)
ChromeOnlyDispatch
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
void
Document
:
:
PostStyleSheetRemovedEvent
(
StyleSheet
&
aSheet
)
{
if
(
!
StyleSheetChangeEventsEnabled
(
)
)
{
return
;
}
StyleSheetRemovedEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
false
;
init
.
mStylesheet
=
&
aSheet
;
RefPtr
<
StyleSheetRemovedEvent
>
event
=
StyleSheetRemovedEvent
:
:
Constructor
(
this
u
"
StyleSheetRemoved
"
_ns
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
SetTarget
(
this
)
;
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
event
.
forget
(
)
ChromeOnlyDispatch
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
static
int32_t
FindSheet
(
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
nsIURI
*
aSheetURI
)
{
for
(
int32_t
i
=
aSheets
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
bool
bEqual
;
nsIURI
*
uri
=
aSheets
[
i
]
-
>
GetSheetURI
(
)
;
if
(
uri
&
&
NS_SUCCEEDED
(
uri
-
>
Equals
(
aSheetURI
&
bEqual
)
)
&
&
bEqual
)
return
i
;
}
return
-
1
;
}
nsresult
Document
:
:
LoadAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
{
MOZ_ASSERT
(
aSheetURI
"
null
arg
"
)
;
if
(
FindSheet
(
mAdditionalSheets
[
aType
]
aSheetURI
)
>
=
0
)
return
NS_ERROR_INVALID_ARG
;
RefPtr
<
css
:
:
Loader
>
loader
=
new
css
:
:
Loader
(
GetDocGroup
(
)
)
;
css
:
:
SheetParsingMode
parsingMode
;
switch
(
aType
)
{
case
Document
:
:
eAgentSheet
:
parsingMode
=
css
:
:
eAgentSheetFeatures
;
break
;
case
Document
:
:
eUserSheet
:
parsingMode
=
css
:
:
eUserSheetFeatures
;
break
;
case
Document
:
:
eAuthorSheet
:
parsingMode
=
css
:
:
eAuthorSheetFeatures
;
break
;
default
:
MOZ_CRASH
(
"
impossible
value
for
aType
"
)
;
}
auto
result
=
loader
-
>
LoadSheetSync
(
aSheetURI
parsingMode
css
:
:
Loader
:
:
UseSystemPrincipal
:
:
Yes
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
unwrapErr
(
)
;
}
RefPtr
<
StyleSheet
>
sheet
=
result
.
unwrap
(
)
;
sheet
-
>
SetAssociatedDocumentOrShadowRoot
(
this
)
;
MOZ_ASSERT
(
sheet
-
>
IsApplicable
(
)
)
;
return
AddAdditionalStyleSheet
(
aType
sheet
)
;
}
nsresult
Document
:
:
AddAdditionalStyleSheet
(
additionalSheetType
aType
StyleSheet
*
aSheet
)
{
if
(
mAdditionalSheets
[
aType
]
.
Contains
(
aSheet
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
!
aSheet
-
>
IsApplicable
(
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
mAdditionalSheets
[
aType
]
.
AppendElement
(
aSheet
)
;
if
(
mStyleSetFilled
)
{
EnsureStyleSet
(
)
.
AppendStyleSheet
(
*
aSheet
)
;
ApplicableStylesChanged
(
)
;
}
return
NS_OK
;
}
void
Document
:
:
RemoveAdditionalStyleSheet
(
additionalSheetType
aType
nsIURI
*
aSheetURI
)
{
MOZ_ASSERT
(
aSheetURI
)
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
sheets
=
mAdditionalSheets
[
aType
]
;
int32_t
i
=
FindSheet
(
mAdditionalSheets
[
aType
]
aSheetURI
)
;
if
(
i
>
=
0
)
{
RefPtr
<
StyleSheet
>
sheetRef
=
std
:
:
move
(
sheets
[
i
]
)
;
sheets
.
RemoveElementAt
(
i
)
;
if
(
!
mIsGoingAway
)
{
MOZ_ASSERT
(
sheetRef
-
>
IsApplicable
(
)
)
;
if
(
mStyleSetFilled
)
{
EnsureStyleSet
(
)
.
RemoveStyleSheet
(
*
sheetRef
)
;
ApplicableStylesChanged
(
)
;
}
}
sheetRef
-
>
ClearAssociatedDocumentOrShadowRoot
(
)
;
}
}
nsIGlobalObject
*
Document
:
:
GetScopeObject
(
)
const
{
nsCOMPtr
<
nsIGlobalObject
>
scope
(
do_QueryReferent
(
mScopeObject
)
)
;
return
scope
;
}
DocGroup
*
Document
:
:
GetDocGroupOrCreate
(
)
{
if
(
!
mDocGroup
&
&
GetBrowsingContext
(
)
)
{
BrowsingContextGroup
*
group
=
GetBrowsingContext
(
)
-
>
Group
(
)
;
MOZ_ASSERT
(
group
)
;
nsAutoCString
docGroupKey
;
nsresult
rv
=
mozilla
:
:
dom
:
:
DocGroup
:
:
GetKey
(
NodePrincipal
(
)
group
-
>
IsPotentiallyCrossOriginIsolated
(
)
docGroupKey
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mDocGroup
=
group
-
>
AddDocument
(
docGroupKey
this
)
;
}
}
return
mDocGroup
;
}
void
Document
:
:
SetScopeObject
(
nsIGlobalObject
*
aGlobal
)
{
mScopeObject
=
do_GetWeakReference
(
aGlobal
)
;
if
(
aGlobal
)
{
mHasHadScriptHandlingObject
=
true
;
nsPIDOMWindowInner
*
window
=
aGlobal
-
>
GetAsInnerWindow
(
)
;
if
(
!
window
)
{
return
;
}
if
(
mLoadedAsData
&
&
window
-
>
GetExtantDoc
(
)
&
&
window
-
>
GetExtantDoc
(
)
!
=
this
&
&
window
-
>
GetExtantDoc
(
)
-
>
NodePrincipal
(
)
=
=
NodePrincipal
(
)
)
{
DocGroup
*
docGroup
=
window
-
>
GetExtantDoc
(
)
-
>
GetDocGroup
(
)
;
if
(
docGroup
)
{
if
(
!
mDocGroup
)
{
mDocGroup
=
docGroup
;
mDocGroup
-
>
AddDocument
(
this
)
;
}
else
{
MOZ_ASSERT
(
mDocGroup
=
=
docGroup
"
Data
document
has
a
mismatched
doc
group
?
"
)
;
}
#
ifdef
DEBUG
AssertDocGroupMatchesKey
(
)
;
#
endif
return
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Scope
window
doesn
'
t
have
DocGroup
when
creating
data
document
?
"
)
;
}
BrowsingContextGroup
*
browsingContextGroup
=
window
-
>
GetBrowsingContextGroup
(
)
;
nsAutoCString
docGroupKey
;
nsresult
rv
=
mozilla
:
:
dom
:
:
DocGroup
:
:
GetKey
(
NodePrincipal
(
)
browsingContextGroup
-
>
IsPotentiallyCrossOriginIsolated
(
)
docGroupKey
)
;
if
(
mDocGroup
)
{
if
(
NS_SUCCEEDED
(
rv
)
)
{
MOZ_RELEASE_ASSERT
(
mDocGroup
-
>
MatchesKey
(
docGroupKey
)
)
;
}
MOZ_RELEASE_ASSERT
(
mDocGroup
-
>
GetBrowsingContextGroup
(
)
=
=
browsingContextGroup
)
;
}
else
{
mDocGroup
=
browsingContextGroup
-
>
AddDocument
(
docGroupKey
this
)
;
MOZ_ASSERT
(
mDocGroup
)
;
}
MOZ_ASSERT_IF
(
mNodeInfoManager
-
>
GetArenaAllocator
(
)
mNodeInfoManager
-
>
GetArenaAllocator
(
)
=
=
mDocGroup
-
>
ArenaAllocator
(
)
)
;
}
}
bool
Document
:
:
ContainsEMEContent
(
)
{
nsPIDOMWindowInner
*
win
=
GetInnerWindow
(
)
;
return
win
&
&
win
-
>
HasActiveMediaKeysInstance
(
)
;
}
bool
Document
:
:
ContainsMSEContent
(
)
{
bool
containsMSE
=
false
;
auto
check
=
[
&
containsMSE
]
(
nsISupports
*
aSupports
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aSupports
)
)
;
if
(
auto
*
mediaElem
=
HTMLMediaElement
:
:
FromNodeOrNull
(
content
)
)
{
RefPtr
<
MediaSource
>
ms
=
mediaElem
-
>
GetMozMediaSourceObject
(
)
;
if
(
ms
)
{
containsMSE
=
true
;
}
}
}
;
EnumerateActivityObservers
(
check
)
;
return
containsMSE
;
}
static
void
NotifyActivityChangedCallback
(
nsISupports
*
aSupports
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aSupports
)
)
;
if
(
auto
mediaElem
=
HTMLMediaElement
:
:
FromNodeOrNull
(
content
)
)
{
mediaElem
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
nsCOMPtr
<
nsIObjectLoadingContent
>
objectLoadingContent
(
do_QueryInterface
(
aSupports
)
)
;
if
(
objectLoadingContent
)
{
nsObjectLoadingContent
*
olc
=
static_cast
<
nsObjectLoadingContent
*
>
(
objectLoadingContent
.
get
(
)
)
;
olc
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
nsCOMPtr
<
nsIDocumentActivity
>
objectDocumentActivity
(
do_QueryInterface
(
aSupports
)
)
;
if
(
objectDocumentActivity
)
{
objectDocumentActivity
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
else
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoadingContent
(
do_QueryInterface
(
aSupports
)
)
;
if
(
imageLoadingContent
)
{
auto
ilc
=
static_cast
<
nsImageLoadingContent
*
>
(
imageLoadingContent
.
get
(
)
)
;
ilc
-
>
NotifyOwnerDocumentActivityChanged
(
)
;
}
}
}
void
Document
:
:
NotifyActivityChanged
(
)
{
EnumerateActivityObservers
(
NotifyActivityChangedCallback
)
;
}
void
Document
:
:
SetContainer
(
nsDocShell
*
aContainer
)
{
if
(
aContainer
)
{
mDocumentContainer
=
aContainer
;
}
else
{
mDocumentContainer
=
WeakPtr
<
nsDocShell
>
(
)
;
}
mInChromeDocShell
=
aContainer
&
&
aContainer
-
>
GetBrowsingContext
(
)
-
>
IsChrome
(
)
;
NotifyActivityChanged
(
)
;
UpdateDocumentStates
(
DocumentState
:
:
WINDOW_INACTIVE
false
)
;
if
(
!
aContainer
)
{
return
;
}
BrowsingContext
*
context
=
aContainer
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT_IF
(
context
&
&
mDocGroup
context
-
>
Group
(
)
=
=
mDocGroup
-
>
GetBrowsingContextGroup
(
)
)
;
if
(
context
&
&
context
-
>
IsContent
(
)
)
{
SetIsTopLevelContentDocument
(
context
-
>
IsTopContent
(
)
)
;
SetIsContentDocument
(
true
)
;
}
else
{
SetIsTopLevelContentDocument
(
false
)
;
SetIsContentDocument
(
false
)
;
}
}
nsISupports
*
Document
:
:
GetContainer
(
)
const
{
return
static_cast
<
nsIDocShell
*
>
(
mDocumentContainer
)
;
}
void
Document
:
:
SetScriptGlobalObject
(
nsIScriptGlobalObject
*
aScriptGlobalObject
)
{
MOZ_ASSERT
(
aScriptGlobalObject
|
|
!
mAnimationController
|
|
mAnimationController
-
>
IsPausedByType
(
SMILTimeContainer
:
:
PAUSE_PAGEHIDE
|
SMILTimeContainer
:
:
PAUSE_BEGIN
)
"
Clearing
window
pointer
while
animations
are
unpaused
"
)
;
if
(
mScriptGlobalObject
&
&
!
aScriptGlobalObject
)
{
mLayoutHistoryState
=
GetLayoutHistoryState
(
)
;
if
(
mOnloadBlockCount
!
=
0
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
loadGroup
-
>
RemoveRequest
(
mOnloadBlocker
nullptr
NS_OK
)
;
}
}
if
(
GetController
(
)
.
isSome
(
)
)
{
if
(
imgLoader
*
loader
=
nsContentUtils
:
:
GetImgLoaderForDocument
(
this
)
)
{
loader
-
>
ClearCacheForControlledDocument
(
this
)
;
}
mMaybeServiceWorkerControlled
=
false
;
}
if
(
GetWindowContext
(
)
)
{
SendPageUseCounters
(
)
;
}
}
bool
needOnloadBlocker
=
!
mScriptGlobalObject
&
&
aScriptGlobalObject
;
mScriptGlobalObject
=
aScriptGlobalObject
;
if
(
needOnloadBlocker
)
{
EnsureOnloadBlocker
(
)
;
}
UpdateFrameRequestCallbackSchedulingState
(
)
;
if
(
aScriptGlobalObject
)
{
mLayoutHistoryState
=
nullptr
;
SetScopeObject
(
aScriptGlobalObject
)
;
mHasHadDefaultView
=
true
;
if
(
mAllowDNSPrefetch
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_GetInterface
(
aScriptGlobalObject
)
;
NS_ASSERTION
(
SameCOMIdentity
(
webNav
docShell
)
"
Unexpected
container
or
script
global
?
"
)
;
#
endif
bool
allowDNSPrefetch
;
docShell
-
>
GetAllowDNSPrefetch
(
&
allowDNSPrefetch
)
;
mAllowDNSPrefetch
=
allowDNSPrefetch
;
}
}
if
(
HasFocus
(
IgnoreErrors
(
)
)
)
{
SetLastFocusTime
(
TimeStamp
:
:
Now
(
)
)
;
}
}
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
mScriptGlobalObject
)
;
mWindow
=
window
;
if
(
mCSP
)
{
static_cast
<
nsCSPContext
*
>
(
mCSP
.
get
(
)
)
-
>
flushConsoleMessages
(
)
;
}
nsCOMPtr
<
nsIHttpChannelInternal
>
internalChannel
=
do_QueryInterface
(
GetChannel
(
)
)
;
if
(
internalChannel
)
{
nsCOMArray
<
nsISecurityConsoleMessage
>
messages
;
DebugOnly
<
nsresult
>
rv
=
internalChannel
-
>
TakeAllSecurityMessages
(
messages
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
SendToConsole
(
messages
)
;
}
UpdateVisibilityState
(
DispatchVisibilityChange
:
:
No
)
;
if
(
mTemplateContentsOwner
&
&
mTemplateContentsOwner
!
=
this
)
{
mTemplateContentsOwner
-
>
SetScriptGlobalObject
(
aScriptGlobalObject
)
;
}
if
(
mScriptLoader
&
&
!
IsTemplateContentsOwner
(
)
)
{
mScriptLoader
-
>
SetGlobalObject
(
mScriptGlobalObject
)
;
}
if
(
!
mMaybeServiceWorkerControlled
&
&
mDocumentContainer
&
&
mScriptGlobalObject
&
&
GetChannel
(
)
)
{
if
(
mDocumentContainer
-
>
IsForceReloading
(
)
)
{
NS_WARNING
(
"
Page
was
shift
reloaded
skipping
ServiceWorker
control
"
)
;
return
;
}
mMaybeServiceWorkerControlled
=
true
;
}
}
nsIScriptGlobalObject
*
Document
:
:
GetScriptHandlingObjectInternal
(
)
const
{
MOZ_ASSERT
(
!
mScriptGlobalObject
"
Do
not
call
this
when
mScriptGlobalObject
is
set
!
"
)
;
if
(
mHasHadDefaultView
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
scriptHandlingObject
=
do_QueryReferent
(
mScopeObject
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
do_QueryInterface
(
scriptHandlingObject
)
;
if
(
win
)
{
nsPIDOMWindowOuter
*
outer
=
win
-
>
GetOuterWindow
(
)
;
if
(
!
outer
|
|
outer
-
>
GetCurrentInnerWindow
(
)
!
=
win
)
{
NS_WARNING
(
"
Wrong
inner
/
outer
window
combination
!
"
)
;
return
nullptr
;
}
}
return
scriptHandlingObject
;
}
void
Document
:
:
SetScriptHandlingObject
(
nsIScriptGlobalObject
*
aScriptObject
)
{
NS_ASSERTION
(
!
mScriptGlobalObject
|
|
mScriptGlobalObject
=
=
aScriptObject
"
Wrong
script
object
!
"
)
;
if
(
aScriptObject
)
{
SetScopeObject
(
aScriptObject
)
;
mHasHadDefaultView
=
false
;
}
}
nsPIDOMWindowOuter
*
Document
:
:
GetWindowInternal
(
)
const
{
MOZ_ASSERT
(
!
mWindow
"
This
should
not
be
called
when
mWindow
is
not
null
!
"
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
;
if
(
mRemovedFromDocShell
)
{
nsCOMPtr
<
nsIDocShell
>
kungFuDeathGrip
(
mDocumentContainer
)
;
if
(
kungFuDeathGrip
)
{
win
=
kungFuDeathGrip
-
>
GetWindow
(
)
;
}
}
else
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
do_QueryInterface
(
mScriptGlobalObject
)
)
{
win
=
inner
-
>
GetOuterWindow
(
)
;
}
}
return
win
;
}
bool
Document
:
:
InternalAllowXULXBL
(
)
{
if
(
nsContentUtils
:
:
AllowXULXBLForPrincipal
(
NodePrincipal
(
)
)
)
{
mAllowXULXBL
=
eTriTrue
;
return
true
;
}
mAllowXULXBL
=
eTriFalse
;
return
false
;
}
void
Document
:
:
AddObserver
(
nsIDocumentObserver
*
aObserver
)
{
NS_ASSERTION
(
mObservers
.
IndexOf
(
aObserver
)
=
=
nsTArray
<
int
>
:
:
NoIndex
"
Observer
already
in
the
list
"
)
;
mObservers
.
AppendElement
(
aObserver
)
;
AddMutationObserver
(
aObserver
)
;
}
bool
Document
:
:
RemoveObserver
(
nsIDocumentObserver
*
aObserver
)
{
if
(
!
mInDestructor
)
{
RemoveMutationObserver
(
aObserver
)
;
return
mObservers
.
RemoveElement
(
aObserver
)
;
}
return
mObservers
.
Contains
(
aObserver
)
;
}
void
Document
:
:
BeginUpdate
(
)
{
+
+
mUpdateNestLevel
;
nsContentUtils
:
:
AddScriptBlocker
(
)
;
NS_DOCUMENT_NOTIFY_OBSERVERS
(
BeginUpdate
(
this
)
)
;
}
void
Document
:
:
EndUpdate
(
)
{
const
bool
reset
=
!
mPendingMaybeEditingStateChanged
;
mPendingMaybeEditingStateChanged
=
true
;
NS_DOCUMENT_NOTIFY_OBSERVERS
(
EndUpdate
(
this
)
)
;
-
-
mUpdateNestLevel
;
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
if
(
mXULBroadcastManager
)
{
mXULBroadcastManager
-
>
MaybeBroadcast
(
)
;
}
if
(
reset
)
{
mPendingMaybeEditingStateChanged
=
false
;
}
MaybeEditingStateChanged
(
)
;
}
void
Document
:
:
BeginLoad
(
)
{
if
(
IsEditingOn
(
)
)
{
TurnEditingOff
(
)
;
EditingStateChanged
(
)
;
}
MOZ_ASSERT
(
!
mDidCallBeginLoad
)
;
mDidCallBeginLoad
=
true
;
BlockOnload
(
)
;
mDidFireDOMContentLoaded
=
false
;
BlockDOMContentLoaded
(
)
;
if
(
mScriptLoader
)
{
mScriptLoader
-
>
BeginDeferringScripts
(
)
;
}
NS_DOCUMENT_NOTIFY_OBSERVERS
(
BeginLoad
(
this
)
)
;
}
void
Document
:
:
MozSetImageElement
(
const
nsAString
&
aImageElementId
Element
*
aElement
)
{
if
(
aImageElementId
.
IsEmpty
(
)
)
return
;
nsAutoScriptBlocker
scriptBlocker
;
IdentifierMapEntry
*
entry
=
mIdentifierMap
.
PutEntry
(
aImageElementId
)
;
if
(
entry
)
{
entry
-
>
SetImageElement
(
aElement
)
;
if
(
entry
-
>
IsEmpty
(
)
)
{
mIdentifierMap
.
RemoveEntry
(
entry
)
;
}
}
}
void
Document
:
:
DispatchContentLoadedEvents
(
)
{
mPreloadingImages
.
Clear
(
)
;
mPreloadedPreconnects
.
Clear
(
)
;
if
(
mTiming
)
{
mTiming
-
>
NotifyDOMContentLoadedStart
(
Document
:
:
GetDocumentURI
(
)
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
this
)
principal
-
>
IsSystemPrincipal
(
)
?
"
chrome
-
document
-
interactive
"
:
"
content
-
document
-
interactive
"
nullptr
)
;
}
nsContentUtils
:
:
DispatchTrustedEvent
(
this
this
u
"
DOMContentLoaded
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
if
(
auto
*
const
window
=
GetInnerWindow
(
)
)
{
const
RefPtr
<
ServiceWorkerContainer
>
serviceWorker
=
window
-
>
Navigator
(
)
-
>
ServiceWorker
(
)
;
serviceWorker
-
>
StartMessages
(
)
;
}
if
(
MayStartLayout
(
)
)
{
MaybeResolveReadyForIdle
(
)
;
}
if
(
mTiming
)
{
mTiming
-
>
NotifyDOMContentLoadedEnd
(
Document
:
:
GetDocumentURI
(
)
)
;
}
nsCOMPtr
<
Element
>
target_frame
=
GetEmbedderElement
(
)
;
if
(
target_frame
&
&
target_frame
-
>
IsInComposedDoc
(
)
)
{
nsCOMPtr
<
Document
>
parent
=
target_frame
-
>
OwnerDoc
(
)
;
while
(
parent
)
{
RefPtr
<
Event
>
event
;
if
(
parent
)
{
IgnoredErrorResult
ignored
;
event
=
parent
-
>
CreateEvent
(
u
"
Events
"
_ns
CallerType
:
:
System
ignored
)
;
}
if
(
event
)
{
event
-
>
InitEvent
(
u
"
DOMFrameContentLoaded
"
_ns
true
true
)
;
event
-
>
SetTarget
(
target_frame
)
;
event
-
>
SetTrusted
(
true
)
;
WidgetEvent
*
innerEvent
=
event
-
>
WidgetEventPtr
(
)
;
if
(
innerEvent
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
RefPtr
<
nsPresContext
>
context
=
parent
-
>
GetPresContext
(
)
)
{
EventDispatcher
:
:
Dispatch
(
parent
context
innerEvent
event
&
status
)
;
}
}
}
parent
=
parent
-
>
GetInProcessParentDocument
(
)
;
}
}
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
inner
)
{
inner
-
>
NoteDOMContentLoaded
(
)
;
}
if
(
mMaybeServiceWorkerControlled
)
{
using
mozilla
:
:
dom
:
:
ServiceWorkerManager
;
RefPtr
<
ServiceWorkerManager
>
swm
=
ServiceWorkerManager
:
:
GetInstance
(
)
;
if
(
swm
)
{
Maybe
<
ClientInfo
>
clientInfo
=
GetClientInfo
(
)
;
if
(
clientInfo
.
isSome
(
)
)
{
swm
-
>
MaybeCheckNavigationUpdate
(
clientInfo
.
ref
(
)
)
;
}
}
}
if
(
mSetCompleteAfterDOMContentLoaded
)
{
SetReadyStateInternal
(
ReadyState
:
:
READYSTATE_COMPLETE
)
;
mSetCompleteAfterDOMContentLoaded
=
false
;
}
UnblockOnload
(
true
)
;
}
void
Document
:
:
EndLoad
(
)
{
bool
turnOnEditing
=
mParser
&
&
(
IsInDesignMode
(
)
|
|
mContentEditableCount
>
0
)
;
#
if
defined
(
DEBUG
)
if
(
!
mParserAborted
)
{
nsContentSecurityUtils
:
:
AssertAboutPageHasCSP
(
this
)
;
}
#
endif
if
(
mParser
)
{
mWeakSink
=
do_GetWeakReference
(
mParser
-
>
GetContentSink
(
)
)
;
mParser
=
nullptr
;
}
if
(
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
)
{
if
(
RefPtr
<
Performance
>
performance
=
window
-
>
GetPerformance
(
)
)
{
performance
-
>
UpdateNavigationTimingEntry
(
)
;
}
}
NS_DOCUMENT_NOTIFY_OBSERVERS
(
EndLoad
(
this
)
)
;
if
(
!
mDidCallBeginLoad
)
{
return
;
}
mDidCallBeginLoad
=
false
;
UnblockDOMContentLoaded
(
)
;
if
(
turnOnEditing
)
{
EditingStateChanged
(
)
;
}
if
(
!
GetWindow
(
)
)
{
SetReadyStateInternal
(
Document
:
:
READYSTATE_COMPLETE
false
)
;
mSkipLoadEventAfterClose
=
false
;
}
}
void
Document
:
:
UnblockDOMContentLoaded
(
)
{
MOZ_ASSERT
(
mBlockDOMContentLoaded
)
;
if
(
-
-
mBlockDOMContentLoaded
!
=
0
|
|
mDidFireDOMContentLoaded
)
{
return
;
}
MOZ_LOG
(
gDocumentLeakPRLog
LogLevel
:
:
Debug
(
"
DOCUMENT
%
p
UnblockDOMContentLoaded
"
this
)
)
;
mDidFireDOMContentLoaded
=
true
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
GetRefreshDriver
(
)
-
>
NotifyDOMContentLoaded
(
)
;
}
MOZ_ASSERT
(
mReadyState
=
=
READYSTATE_INTERACTIVE
)
;
if
(
!
mSynchronousDOMContentLoaded
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
Document
:
:
DispatchContentLoadedEvents
"
this
&
Document
:
:
DispatchContentLoadedEvents
)
;
Dispatch
(
ev
.
forget
(
)
)
;
}
else
{
DispatchContentLoadedEvents
(
)
;
}
}
void
Document
:
:
ElementStateChanged
(
Element
*
aElement
ElementState
aStateMask
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Someone
forgot
a
scriptblocker
"
)
;
NS_DOCUMENT_NOTIFY_OBSERVERS
(
ElementStateChanged
(
this
aElement
aStateMask
)
)
;
}
void
Document
:
:
RuleChanged
(
StyleSheet
&
aSheet
css
:
:
Rule
*
StyleRuleChangeKind
)
{
if
(
aSheet
.
IsApplicable
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
RuleAdded
(
StyleSheet
&
aSheet
css
:
:
Rule
&
aRule
)
{
if
(
aRule
.
IsIncompleteImportRule
(
)
)
{
return
;
}
if
(
aSheet
.
IsApplicable
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
ImportRuleLoaded
(
dom
:
:
CSSImportRule
&
aRule
StyleSheet
&
aSheet
)
{
if
(
aSheet
.
IsApplicable
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
RuleRemoved
(
StyleSheet
&
aSheet
css
:
:
Rule
&
aRule
)
{
if
(
aSheet
.
IsApplicable
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
static
Element
*
GetCustomContentContainer
(
PresShell
*
aPresShell
)
{
if
(
!
aPresShell
|
|
!
aPresShell
-
>
GetCanvasFrame
(
)
)
{
return
nullptr
;
}
return
aPresShell
-
>
GetCanvasFrame
(
)
-
>
GetCustomContentContainer
(
)
;
}
already_AddRefed
<
AnonymousContent
>
Document
:
:
InsertAnonymousContent
(
bool
aForce
ErrorResult
&
aRv
)
{
RefPtr
<
PresShell
>
shell
=
GetPresShell
(
)
;
if
(
aForce
&
&
!
GetCustomContentContainer
(
shell
)
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
shell
=
GetPresShell
(
)
;
}
nsAutoScriptBlocker
scriptBlocker
;
RefPtr
<
AnonymousContent
>
anonContent
=
AnonymousContent
:
:
Create
(
*
this
)
;
if
(
!
anonContent
)
{
aRv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
mAnonymousContents
.
AppendElement
(
anonContent
)
;
if
(
RefPtr
<
Element
>
container
=
GetCustomContentContainer
(
shell
)
)
{
if
(
container
-
>
HasChildren
(
)
|
|
mAnonymousContents
.
Length
(
)
=
=
1
)
{
container
-
>
AppendChildTo
(
anonContent
-
>
Host
(
)
true
IgnoreErrors
(
)
)
;
if
(
auto
*
canvasFrame
=
shell
-
>
GetCanvasFrame
(
)
)
{
canvasFrame
-
>
ShowCustomContentContainer
(
)
;
}
}
}
return
anonContent
.
forget
(
)
;
}
static
void
RemoveAnonContentFromCanvas
(
AnonymousContent
&
aAnonContent
PresShell
*
aPresShell
)
{
RefPtr
<
Element
>
container
=
GetCustomContentContainer
(
aPresShell
)
;
if
(
!
container
)
{
return
;
}
container
-
>
RemoveChild
(
*
aAnonContent
.
Host
(
)
IgnoreErrors
(
)
)
;
}
void
Document
:
:
RemoveAnonymousContent
(
AnonymousContent
&
aContent
)
{
nsAutoScriptBlocker
scriptBlocker
;
auto
index
=
mAnonymousContents
.
IndexOf
(
&
aContent
)
;
if
(
index
=
=
mAnonymousContents
.
NoIndex
)
{
return
;
}
mAnonymousContents
.
RemoveElementAt
(
index
)
;
RemoveAnonContentFromCanvas
(
aContent
GetPresShell
(
)
)
;
if
(
mAnonymousContents
.
IsEmpty
(
)
&
&
GetCustomContentContainer
(
GetPresShell
(
)
)
)
{
GetPresShell
(
)
-
>
GetCanvasFrame
(
)
-
>
HideCustomContentContainer
(
)
;
}
}
Element
*
Document
:
:
GetAnonRootIfInAnonymousContentContainer
(
nsINode
*
aNode
)
const
{
if
(
!
aNode
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
|
|
!
presShell
-
>
GetCanvasFrame
(
)
)
{
return
nullptr
;
}
nsAutoScriptBlocker
scriptBlocker
;
nsCOMPtr
<
Element
>
customContainer
=
presShell
-
>
GetCanvasFrame
(
)
-
>
GetCustomContentContainer
(
)
;
if
(
!
customContainer
)
{
return
nullptr
;
}
nsINode
*
child
=
aNode
;
nsINode
*
parent
=
aNode
-
>
GetParentNode
(
)
;
while
(
parent
&
&
parent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
if
(
parent
=
=
customContainer
)
{
return
Element
:
:
FromNode
(
child
)
;
}
child
=
parent
;
parent
=
child
-
>
GetParentNode
(
)
;
}
return
nullptr
;
}
Maybe
<
ClientInfo
>
Document
:
:
GetClientInfo
(
)
const
{
if
(
const
Document
*
orig
=
GetOriginalDocument
(
)
)
{
if
(
Maybe
<
ClientInfo
>
info
=
orig
-
>
GetClientInfo
(
)
)
{
return
info
;
}
}
if
(
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
)
{
return
inner
-
>
GetClientInfo
(
)
;
}
return
Maybe
<
ClientInfo
>
(
)
;
}
Maybe
<
ClientState
>
Document
:
:
GetClientState
(
)
const
{
if
(
const
Document
*
orig
=
GetOriginalDocument
(
)
)
{
if
(
Maybe
<
ClientState
>
state
=
orig
-
>
GetClientState
(
)
)
{
return
state
;
}
}
if
(
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
)
{
return
inner
-
>
GetClientState
(
)
;
}
return
Maybe
<
ClientState
>
(
)
;
}
Maybe
<
ServiceWorkerDescriptor
>
Document
:
:
GetController
(
)
const
{
if
(
const
Document
*
orig
=
GetOriginalDocument
(
)
)
{
if
(
Maybe
<
ServiceWorkerDescriptor
>
controller
=
orig
-
>
GetController
(
)
)
{
return
controller
;
}
}
if
(
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
)
{
return
inner
-
>
GetController
(
)
;
}
return
Maybe
<
ServiceWorkerDescriptor
>
(
)
;
}
DocumentType
*
Document
:
:
GetDoctype
(
)
const
{
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
NodeType
(
)
=
=
DOCUMENT_TYPE_NODE
)
{
return
static_cast
<
DocumentType
*
>
(
child
)
;
}
}
return
nullptr
;
}
DOMImplementation
*
Document
:
:
GetImplementation
(
ErrorResult
&
rv
)
{
if
(
!
mDOMImplementation
)
{
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
)
;
if
(
!
uri
)
{
rv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
bool
hasHadScriptObject
=
true
;
nsIScriptGlobalObject
*
scriptObject
=
GetScriptHandlingObject
(
hasHadScriptObject
)
;
if
(
!
scriptObject
&
&
hasHadScriptObject
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
mDOMImplementation
=
new
DOMImplementation
(
this
scriptObject
?
scriptObject
:
GetScopeObject
(
)
uri
uri
)
;
}
return
mDOMImplementation
;
}
bool
IsLowercaseASCII
(
const
nsAString
&
aValue
)
{
int32_t
len
=
aValue
.
Length
(
)
;
for
(
int32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
char16_t
c
=
aValue
[
i
]
;
if
(
!
(
0x0061
<
=
(
c
)
&
&
(
(
c
)
<
=
0x007a
)
)
)
{
return
false
;
}
}
return
true
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
{
rv
=
nsContentUtils
:
:
CheckQName
(
aTagName
false
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
bool
needsLowercase
=
IsHTMLDocument
(
)
&
&
!
IsLowercaseASCII
(
aTagName
)
;
nsAutoString
lcTagName
;
if
(
needsLowercase
)
{
nsContentUtils
:
:
ASCIIToLower
(
aTagName
lcTagName
)
;
}
const
nsString
*
is
=
nullptr
;
PseudoStyleType
pseudoType
=
PseudoStyleType
:
:
NotPseudo
;
if
(
aOptions
.
IsElementCreationOptions
(
)
)
{
const
ElementCreationOptions
&
options
=
aOptions
.
GetAsElementCreationOptions
(
)
;
if
(
options
.
mIs
.
WasPassed
(
)
)
{
is
=
&
options
.
mIs
.
Value
(
)
;
}
if
(
options
.
mPseudo
.
WasPassed
(
)
)
{
Maybe
<
PseudoStyleType
>
type
=
nsCSSPseudoElements
:
:
GetPseudoType
(
options
.
mPseudo
.
Value
(
)
)
;
if
(
!
type
|
|
*
type
=
=
PseudoStyleType
:
:
NotPseudo
|
|
!
nsCSSPseudoElements
:
:
PseudoElementIsJSCreatedNAC
(
*
type
)
)
{
rv
.
ThrowNotSupportedError
(
"
Invalid
pseudo
-
element
"
)
;
return
nullptr
;
}
pseudoType
=
*
type
;
}
}
RefPtr
<
Element
>
elem
=
CreateElem
(
needsLowercase
?
lcTagName
:
aTagName
nullptr
mDefaultElementType
is
)
;
if
(
pseudoType
!
=
PseudoStyleType
:
:
NotPseudo
)
{
elem
-
>
SetPseudoElementType
(
pseudoType
)
;
}
return
elem
.
forget
(
)
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateElementNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
rv
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
rv
=
nsContentUtils
:
:
GetNodeInfoFromQName
(
aNamespaceURI
aQualifiedName
mNodeInfoManager
ELEMENT_NODE
getter_AddRefs
(
nodeInfo
)
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
const
nsString
*
is
=
nullptr
;
if
(
aOptions
.
IsElementCreationOptions
(
)
)
{
const
ElementCreationOptions
&
options
=
aOptions
.
GetAsElementCreationOptions
(
)
;
if
(
options
.
mIs
.
WasPassed
(
)
)
{
is
=
&
options
.
mIs
.
Value
(
)
;
}
}
nsCOMPtr
<
Element
>
element
;
rv
=
NS_NewElement
(
getter_AddRefs
(
element
)
nodeInfo
.
forget
(
)
NOT_FROM_PARSER
is
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
return
element
.
forget
(
)
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateXULElement
(
const
nsAString
&
aTagName
const
ElementCreationOptionsOrString
&
aOptions
ErrorResult
&
aRv
)
{
aRv
=
nsContentUtils
:
:
CheckQName
(
aTagName
false
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
const
nsString
*
is
=
nullptr
;
if
(
aOptions
.
IsElementCreationOptions
(
)
)
{
const
ElementCreationOptions
&
options
=
aOptions
.
GetAsElementCreationOptions
(
)
;
if
(
options
.
mIs
.
WasPassed
(
)
)
{
is
=
&
options
.
mIs
.
Value
(
)
;
}
}
RefPtr
<
Element
>
elem
=
CreateElem
(
aTagName
nullptr
kNameSpaceID_XUL
is
)
;
if
(
!
elem
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
return
elem
.
forget
(
)
;
}
already_AddRefed
<
nsTextNode
>
Document
:
:
CreateEmptyTextNode
(
)
const
{
RefPtr
<
nsTextNode
>
text
=
new
(
mNodeInfoManager
)
nsTextNode
(
mNodeInfoManager
)
;
return
text
.
forget
(
)
;
}
already_AddRefed
<
nsTextNode
>
Document
:
:
CreateTextNode
(
const
nsAString
&
aData
)
const
{
RefPtr
<
nsTextNode
>
text
=
new
(
mNodeInfoManager
)
nsTextNode
(
mNodeInfoManager
)
;
text
-
>
SetText
(
aData
false
)
;
return
text
.
forget
(
)
;
}
already_AddRefed
<
DocumentFragment
>
Document
:
:
CreateDocumentFragment
(
)
const
{
RefPtr
<
DocumentFragment
>
frag
=
new
(
mNodeInfoManager
)
DocumentFragment
(
mNodeInfoManager
)
;
return
frag
.
forget
(
)
;
}
already_AddRefed
<
dom
:
:
Comment
>
Document
:
:
CreateComment
(
const
nsAString
&
aData
)
const
{
RefPtr
<
dom
:
:
Comment
>
comment
=
new
(
mNodeInfoManager
)
dom
:
:
Comment
(
mNodeInfoManager
)
;
comment
-
>
SetText
(
aData
false
)
;
return
comment
.
forget
(
)
;
}
already_AddRefed
<
CDATASection
>
Document
:
:
CreateCDATASection
(
const
nsAString
&
aData
ErrorResult
&
rv
)
{
if
(
IsHTMLDocument
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
if
(
FindInReadable
(
u
"
]
]
>
"
_ns
aData
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_CHARACTER_ERR
)
;
return
nullptr
;
}
RefPtr
<
CDATASection
>
cdata
=
new
(
mNodeInfoManager
)
CDATASection
(
mNodeInfoManager
)
;
cdata
-
>
SetText
(
aData
false
)
;
return
cdata
.
forget
(
)
;
}
already_AddRefed
<
ProcessingInstruction
>
Document
:
:
CreateProcessingInstruction
(
const
nsAString
&
aTarget
const
nsAString
&
aData
ErrorResult
&
rv
)
const
{
nsresult
res
=
nsContentUtils
:
:
CheckQName
(
aTarget
false
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
if
(
FindInReadable
(
u
"
?
>
"
_ns
aData
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_CHARACTER_ERR
)
;
return
nullptr
;
}
RefPtr
<
ProcessingInstruction
>
pi
=
NS_NewXMLProcessingInstruction
(
mNodeInfoManager
aTarget
aData
)
;
return
pi
.
forget
(
)
;
}
already_AddRefed
<
Attr
>
Document
:
:
CreateAttribute
(
const
nsAString
&
aName
ErrorResult
&
rv
)
{
if
(
!
mNodeInfoManager
)
{
rv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
nsresult
res
=
nsContentUtils
:
:
CheckQName
(
aName
false
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
nsAutoString
name
;
if
(
IsHTMLDocument
(
)
)
{
nsContentUtils
:
:
ASCIIToLower
(
aName
name
)
;
}
else
{
name
=
aName
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
res
=
mNodeInfoManager
-
>
GetNodeInfo
(
name
nullptr
kNameSpaceID_None
ATTRIBUTE_NODE
getter_AddRefs
(
nodeInfo
)
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
RefPtr
<
Attr
>
attribute
=
new
(
mNodeInfoManager
)
Attr
(
nullptr
nodeInfo
.
forget
(
)
u
"
"
_ns
)
;
return
attribute
.
forget
(
)
;
}
already_AddRefed
<
Attr
>
Document
:
:
CreateAttributeNS
(
const
nsAString
&
aNamespaceURI
const
nsAString
&
aQualifiedName
ErrorResult
&
rv
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
rv
=
nsContentUtils
:
:
GetNodeInfoFromQName
(
aNamespaceURI
aQualifiedName
mNodeInfoManager
ATTRIBUTE_NODE
getter_AddRefs
(
nodeInfo
)
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
Attr
>
attribute
=
new
(
mNodeInfoManager
)
Attr
(
nullptr
nodeInfo
.
forget
(
)
u
"
"
_ns
)
;
return
attribute
.
forget
(
)
;
}
void
Document
:
:
ScheduleForPresAttrEvaluation
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
-
>
IsInComposedDoc
(
)
)
;
DebugOnly
<
bool
>
inserted
=
mLazyPresElements
.
EnsureInserted
(
aElement
)
;
MOZ_ASSERT
(
inserted
)
;
if
(
aElement
-
>
HasServoData
(
)
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
aElement
RestyleHint
:
:
RESTYLE_SELF
nsChangeHint
(
0
)
)
;
}
}
void
Document
:
:
UnscheduleForPresAttrEvaluation
(
Element
*
aElement
)
{
mLazyPresElements
.
Remove
(
aElement
)
;
}
void
Document
:
:
DoResolveScheduledPresAttrs
(
)
{
MOZ_ASSERT
(
!
mLazyPresElements
.
IsEmpty
(
)
)
;
for
(
Element
*
el
:
mLazyPresElements
)
{
MOZ_ASSERT
(
el
-
>
IsInComposedDoc
(
)
"
Un
-
schedule
when
removing
from
the
document
"
)
;
MOZ_ASSERT
(
el
-
>
IsPendingMappedAttributeEvaluation
(
)
)
;
if
(
auto
*
svg
=
SVGElement
:
:
FromNode
(
el
)
)
{
svg
-
>
UpdateMappedDeclarationBlock
(
)
;
}
else
{
MappedDeclarationsBuilder
builder
(
*
el
*
this
el
-
>
GetMappedAttributeStyle
(
)
)
;
auto
function
=
el
-
>
GetAttributeMappingFunction
(
)
;
function
(
builder
)
;
el
-
>
SetMappedDeclarationBlock
(
builder
.
TakeDeclarationBlock
(
)
)
;
}
MOZ_ASSERT
(
!
el
-
>
IsPendingMappedAttributeEvaluation
(
)
)
;
}
mLazyPresElements
.
Clear
(
)
;
}
already_AddRefed
<
nsSimpleContentList
>
Document
:
:
BlockedNodesByClassifier
(
)
const
{
RefPtr
<
nsSimpleContentList
>
list
=
new
nsSimpleContentList
(
nullptr
)
;
for
(
const
nsWeakPtr
&
weakNode
:
mBlockedNodesByClassifier
)
{
if
(
nsCOMPtr
<
nsIContent
>
node
=
do_QueryReferent
(
weakNode
)
)
{
list
-
>
AppendElement
(
node
)
;
}
}
return
list
.
forget
(
)
;
}
void
Document
:
:
GetSelectedStyleSheetSet
(
nsAString
&
aSheetSet
)
{
aSheetSet
.
Truncate
(
)
;
size_t
count
=
SheetCount
(
)
;
nsAutoString
title
;
for
(
size_t
index
=
0
;
index
<
count
;
index
+
+
)
{
StyleSheet
*
sheet
=
SheetAt
(
index
)
;
NS_ASSERTION
(
sheet
"
Null
sheet
in
sheet
list
!
"
)
;
if
(
sheet
-
>
Disabled
(
)
)
{
continue
;
}
sheet
-
>
GetTitle
(
title
)
;
if
(
aSheetSet
.
IsEmpty
(
)
)
{
aSheetSet
=
title
;
}
else
if
(
!
title
.
IsEmpty
(
)
&
&
!
aSheetSet
.
Equals
(
title
)
)
{
SetDOMStringToNull
(
aSheetSet
)
;
return
;
}
}
}
void
Document
:
:
SetSelectedStyleSheetSet
(
const
nsAString
&
aSheetSet
)
{
if
(
DOMStringIsNull
(
aSheetSet
)
)
{
return
;
}
mLastStyleSheetSet
=
aSheetSet
;
EnableStyleSheetsForSetInternal
(
aSheetSet
true
)
;
}
void
Document
:
:
SetPreferredStyleSheetSet
(
const
nsAString
&
aSheetSet
)
{
mPreferredStyleSheetSet
=
aSheetSet
;
if
(
DOMStringIsNull
(
mLastStyleSheetSet
)
)
{
EnableStyleSheetsForSetInternal
(
aSheetSet
true
)
;
}
}
DOMStringList
*
Document
:
:
StyleSheetSets
(
)
{
if
(
!
mStyleSheetSetList
)
{
mStyleSheetSetList
=
new
DOMStyleSheetSetList
(
this
)
;
}
return
mStyleSheetSetList
;
}
void
Document
:
:
EnableStyleSheetsForSet
(
const
nsAString
&
aSheetSet
)
{
if
(
!
DOMStringIsNull
(
aSheetSet
)
)
{
EnableStyleSheetsForSetInternal
(
aSheetSet
false
)
;
}
}
void
Document
:
:
EnableStyleSheetsForSetInternal
(
const
nsAString
&
aSheetSet
bool
aUpdateCSSLoader
)
{
size_t
count
=
SheetCount
(
)
;
nsAutoString
title
;
for
(
size_t
index
=
0
;
index
<
count
;
index
+
+
)
{
StyleSheet
*
sheet
=
SheetAt
(
index
)
;
NS_ASSERTION
(
sheet
"
Null
sheet
in
sheet
list
!
"
)
;
sheet
-
>
GetTitle
(
title
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
sheet
-
>
SetEnabled
(
title
.
Equals
(
aSheetSet
)
)
;
}
}
if
(
aUpdateCSSLoader
)
{
CSSLoader
(
)
-
>
DocumentStyleSheetSetChanged
(
)
;
}
if
(
EnsureStyleSet
(
)
.
StyleSheetsHaveChanged
(
)
)
{
ApplicableStylesChanged
(
)
;
}
}
void
Document
:
:
GetCharacterSet
(
nsAString
&
aCharacterSet
)
const
{
nsAutoCString
charset
;
GetDocumentCharacterSet
(
)
-
>
Name
(
charset
)
;
CopyASCIItoUTF16
(
charset
aCharacterSet
)
;
}
already_AddRefed
<
nsINode
>
Document
:
:
ImportNode
(
nsINode
&
aNode
bool
aDeep
ErrorResult
&
rv
)
const
{
nsINode
*
imported
=
&
aNode
;
switch
(
imported
-
>
NodeType
(
)
)
{
case
DOCUMENT_NODE
:
{
break
;
}
case
DOCUMENT_FRAGMENT_NODE
:
case
ATTRIBUTE_NODE
:
case
ELEMENT_NODE
:
case
PROCESSING_INSTRUCTION_NODE
:
case
TEXT_NODE
:
case
CDATA_SECTION_NODE
:
case
COMMENT_NODE
:
case
DOCUMENT_TYPE_NODE
:
{
return
imported
-
>
Clone
(
aDeep
mNodeInfoManager
rv
)
;
}
default
:
{
NS_WARNING
(
"
Don
'
t
know
how
to
clone
this
nodetype
for
importNode
.
"
)
;
}
}
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
already_AddRefed
<
nsRange
>
Document
:
:
CreateRange
(
ErrorResult
&
rv
)
{
return
nsRange
:
:
Create
(
this
0
this
0
rv
)
;
}
already_AddRefed
<
NodeIterator
>
Document
:
:
CreateNodeIterator
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
{
RefPtr
<
NodeIterator
>
iterator
=
new
NodeIterator
(
&
aRoot
aWhatToShow
aFilter
)
;
return
iterator
.
forget
(
)
;
}
already_AddRefed
<
TreeWalker
>
Document
:
:
CreateTreeWalker
(
nsINode
&
aRoot
uint32_t
aWhatToShow
NodeFilter
*
aFilter
ErrorResult
&
rv
)
const
{
RefPtr
<
TreeWalker
>
walker
=
new
TreeWalker
(
&
aRoot
aWhatToShow
aFilter
)
;
return
walker
.
forget
(
)
;
}
already_AddRefed
<
Location
>
Document
:
:
GetLocation
(
)
const
{
nsCOMPtr
<
nsPIDOMWindowInner
>
w
=
do_QueryInterface
(
mScriptGlobalObject
)
;
if
(
!
w
)
{
return
nullptr
;
}
return
do_AddRef
(
w
-
>
Location
(
)
)
;
}
already_AddRefed
<
nsIURI
>
Document
:
:
GetDomainURI
(
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
principal
-
>
GetDomain
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
return
uri
.
forget
(
)
;
}
auto
*
basePrin
=
BasePrincipal
:
:
Cast
(
principal
)
;
basePrin
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
return
uri
.
forget
(
)
;
}
void
Document
:
:
GetDomain
(
nsAString
&
aDomain
)
{
nsCOMPtr
<
nsIURI
>
uri
=
GetDomainURI
(
)
;
if
(
!
uri
)
{
aDomain
.
Truncate
(
)
;
return
;
}
nsAutoCString
hostName
;
nsresult
rv
=
nsContentUtils
:
:
GetHostOrIPv6WithBrackets
(
uri
hostName
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
CopyUTF8toUTF16
(
hostName
aDomain
)
;
}
else
{
aDomain
.
Truncate
(
)
;
}
}
void
Document
:
:
SetDomain
(
const
nsAString
&
aDomain
ErrorResult
&
rv
)
{
if
(
!
GetBrowsingContext
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
mSandboxFlags
&
SANDBOXED_DOMAIN
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
!
FeaturePolicyUtils
:
:
IsFeatureAllowed
(
this
u
"
document
-
domain
"
_ns
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
aDomain
.
IsEmpty
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
uri
=
GetDomainURI
(
)
;
if
(
!
uri
)
{
rv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
newURI
=
RegistrableDomainSuffixOfInternal
(
aDomain
uri
)
;
if
(
!
newURI
)
{
rv
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
;
}
if
(
GetBrowsingContext
(
)
-
>
Group
(
)
-
>
IsPotentiallyCrossOriginIsolated
(
)
)
{
WarnOnceAbout
(
Document
:
:
eDocumentSetDomainNotAllowed
)
;
return
;
}
MOZ_ALWAYS_SUCCEEDS
(
NodePrincipal
(
)
-
>
SetDomain
(
newURI
)
)
;
MOZ_ALWAYS_SUCCEEDS
(
PartitionedPrincipal
(
)
-
>
SetDomain
(
newURI
)
)
;
if
(
WindowGlobalChild
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
SendSetDocumentDomain
(
newURI
)
;
}
}
already_AddRefed
<
nsIURI
>
Document
:
:
CreateInheritingURIForHost
(
const
nsACString
&
aHostString
)
{
if
(
aHostString
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
=
GetDomainURI
(
)
;
if
(
!
uri
)
{
return
nullptr
;
}
nsresult
rv
;
rv
=
NS_MutateURI
(
uri
)
.
SetUserPass
(
"
"
_ns
)
.
SetPort
(
-
1
)
.
SetHostPort
(
aHostString
)
.
Finalize
(
uri
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
Document
:
:
RegistrableDomainSuffixOfInternal
(
const
nsAString
&
aNewDomain
nsIURI
*
aOrigHost
)
{
if
(
NS_WARN_IF
(
!
aOrigHost
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
newURI
=
CreateInheritingURIForHost
(
NS_ConvertUTF16toUTF8
(
aNewDomain
)
)
;
if
(
!
newURI
)
{
return
nullptr
;
}
if
(
!
IsValidDomain
(
aOrigHost
newURI
)
)
{
return
nullptr
;
}
nsAutoCString
domain
;
if
(
NS_FAILED
(
newURI
-
>
GetAsciiHost
(
domain
)
)
)
{
return
nullptr
;
}
return
CreateInheritingURIForHost
(
domain
)
;
}
bool
Document
:
:
IsValidDomain
(
nsIURI
*
aOrigHost
nsIURI
*
aNewURI
)
{
nsAutoCString
current
;
nsAutoCString
domain
;
if
(
NS_FAILED
(
aOrigHost
-
>
GetAsciiHost
(
current
)
)
)
{
current
.
Truncate
(
)
;
}
if
(
NS_FAILED
(
aNewURI
-
>
GetAsciiHost
(
domain
)
)
)
{
domain
.
Truncate
(
)
;
}
bool
ok
=
current
.
Equals
(
domain
)
;
if
(
current
.
Length
(
)
>
domain
.
Length
(
)
&
&
StringEndsWith
(
current
domain
)
&
&
current
.
CharAt
(
current
.
Length
(
)
-
domain
.
Length
(
)
-
1
)
=
=
'
.
'
)
{
nsCOMPtr
<
nsIEffectiveTLDService
>
tldService
=
do_GetService
(
NS_EFFECTIVETLDSERVICE_CONTRACTID
)
;
if
(
!
tldService
)
{
return
false
;
}
nsAutoCString
currentBaseDomain
;
ok
=
NS_SUCCEEDED
(
tldService
-
>
GetBaseDomain
(
aOrigHost
0
currentBaseDomain
)
)
;
NS_ASSERTION
(
StringEndsWith
(
domain
currentBaseDomain
)
=
=
(
domain
.
Length
(
)
>
=
currentBaseDomain
.
Length
(
)
)
"
uh
-
oh
!
slight
optimization
wasn
'
t
valid
somehow
!
"
)
;
ok
=
ok
&
&
domain
.
Length
(
)
>
=
currentBaseDomain
.
Length
(
)
;
}
return
ok
;
}
Element
*
Document
:
:
GetHtmlElement
(
)
const
{
Element
*
rootElement
=
GetRootElement
(
)
;
if
(
rootElement
&
&
rootElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
)
return
rootElement
;
return
nullptr
;
}
Element
*
Document
:
:
GetHtmlChildElement
(
nsAtom
*
aTag
)
{
Element
*
html
=
GetHtmlElement
(
)
;
if
(
!
html
)
return
nullptr
;
for
(
nsIContent
*
child
=
html
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
aTag
)
)
return
child
-
>
AsElement
(
)
;
}
return
nullptr
;
}
nsGenericHTMLElement
*
Document
:
:
GetBody
(
)
{
Element
*
html
=
GetHtmlElement
(
)
;
if
(
!
html
)
{
return
nullptr
;
}
for
(
nsIContent
*
child
=
html
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
|
|
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
frameset
)
)
{
return
static_cast
<
nsGenericHTMLElement
*
>
(
child
)
;
}
}
return
nullptr
;
}
void
Document
:
:
SetBody
(
nsGenericHTMLElement
*
newBody
ErrorResult
&
rv
)
{
nsCOMPtr
<
Element
>
root
=
GetRootElement
(
)
;
if
(
!
newBody
|
|
!
newBody
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
frameset
)
)
{
rv
.
ThrowHierarchyRequestError
(
"
The
new
body
must
be
either
a
body
tag
or
frameset
tag
.
"
)
;
return
;
}
if
(
!
root
)
{
rv
.
ThrowHierarchyRequestError
(
"
No
root
element
.
"
)
;
return
;
}
nsCOMPtr
<
Element
>
currentBody
=
GetBody
(
)
;
if
(
currentBody
)
{
root
-
>
ReplaceChild
(
*
newBody
*
currentBody
rv
)
;
}
else
{
root
-
>
AppendChild
(
*
newBody
rv
)
;
}
}
HTMLSharedElement
*
Document
:
:
GetHead
(
)
{
return
static_cast
<
HTMLSharedElement
*
>
(
GetHeadElement
(
)
)
;
}
Element
*
Document
:
:
GetTitleElement
(
)
{
if
(
!
mMayHaveTitleElement
)
{
return
nullptr
;
}
Element
*
root
=
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
for
(
nsIContent
*
child
=
root
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsSVGElement
(
nsGkAtoms
:
:
title
)
)
{
return
child
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
for
(
nsINode
*
node
=
GetFirstChild
(
)
;
node
;
node
=
node
-
>
GetNextNode
(
this
)
)
{
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
title
)
)
{
return
node
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
void
Document
:
:
GetTitle
(
nsAString
&
aTitle
)
{
aTitle
.
Truncate
(
)
;
Element
*
rootElement
=
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
if
(
rootElement
-
>
IsXULElement
(
)
)
{
rootElement
-
>
GetAttr
(
nsGkAtoms
:
:
title
aTitle
)
;
}
else
if
(
Element
*
title
=
GetTitleElement
(
)
)
{
nsContentUtils
:
:
GetNodeTextContent
(
title
false
aTitle
)
;
}
else
{
return
;
}
aTitle
.
CompressWhitespace
(
)
;
}
void
Document
:
:
SetTitle
(
const
nsAString
&
aTitle
ErrorResult
&
aRv
)
{
Element
*
rootElement
=
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
if
(
rootElement
-
>
IsXULElement
(
)
)
{
aRv
=
rootElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
title
aTitle
true
)
;
return
;
}
Maybe
<
mozAutoDocUpdate
>
updateBatch
;
nsCOMPtr
<
Element
>
title
=
GetTitleElement
(
)
;
if
(
rootElement
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
if
(
!
title
)
{
updateBatch
.
emplace
(
this
true
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
titleInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
title
nullptr
kNameSpaceID_SVG
ELEMENT_NODE
)
;
NS_NewSVGElement
(
getter_AddRefs
(
title
)
titleInfo
.
forget
(
)
NOT_FROM_PARSER
)
;
if
(
!
title
)
{
return
;
}
rootElement
-
>
InsertChildBefore
(
title
rootElement
-
>
GetFirstChild
(
)
true
IgnoreErrors
(
)
)
;
}
}
else
if
(
rootElement
-
>
IsHTMLElement
(
)
)
{
if
(
!
title
)
{
updateBatch
.
emplace
(
this
true
)
;
Element
*
head
=
GetHeadElement
(
)
;
if
(
!
head
)
{
return
;
}
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
titleInfo
;
titleInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
title
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
title
=
NS_NewHTMLTitleElement
(
titleInfo
.
forget
(
)
)
;
if
(
!
title
)
{
return
;
}
head
-
>
AppendChildTo
(
title
true
IgnoreErrors
(
)
)
;
}
}
else
{
return
;
}
aRv
=
nsContentUtils
:
:
SetNodeTextContent
(
title
aTitle
false
)
;
}
void
Document
:
:
NotifyPossibleTitleChange
(
bool
aBoundTitleElement
)
{
NS_ASSERTION
(
!
mInUnlinkOrDeletion
|
|
!
aBoundTitleElement
"
Setting
a
title
while
unlinking
or
destroying
the
element
?
"
)
;
if
(
mInUnlinkOrDeletion
)
{
return
;
}
if
(
aBoundTitleElement
)
{
mMayHaveTitleElement
=
true
;
}
if
(
mPendingTitleChangeEvent
.
IsPending
(
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
nsRunnableMethod
<
Document
void
false
>
>
event
=
NewNonOwningRunnableMethod
(
"
Document
:
:
DoNotifyPossibleTitleChange
"
this
&
Document
:
:
DoNotifyPossibleTitleChange
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
Dispatch
(
do_AddRef
(
event
)
)
)
)
)
{
return
;
}
mPendingTitleChangeEvent
=
std
:
:
move
(
event
)
;
}
void
Document
:
:
DoNotifyPossibleTitleChange
(
)
{
if
(
!
mPendingTitleChangeEvent
.
IsPending
(
)
)
{
return
;
}
mPendingTitleChangeEvent
.
Revoke
(
)
;
mHaveFiredTitleChange
=
true
;
nsAutoString
title
;
GetTitle
(
title
)
;
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
nsCOMPtr
<
nsISupports
>
container
=
presShell
-
>
GetPresContext
(
)
-
>
GetContainerWeak
(
)
;
if
(
container
)
{
if
(
nsCOMPtr
<
nsIBaseWindow
>
docShellWin
=
do_QueryInterface
(
container
)
)
{
docShellWin
-
>
SetTitle
(
title
)
;
}
}
}
if
(
WindowGlobalChild
*
child
=
GetWindowGlobalChild
(
)
)
{
child
-
>
SendUpdateDocumentTitle
(
title
)
;
}
nsContentUtils
:
:
DispatchChromeEvent
(
this
this
u
"
DOMTitleChanged
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
NotifyObservers
(
ToSupports
(
this
)
"
document
-
title
-
changed
"
nullptr
)
;
}
}
already_AddRefed
<
MediaQueryList
>
Document
:
:
MatchMedia
(
const
nsACString
&
aMediaQueryList
CallerType
aCallerType
)
{
RefPtr
<
MediaQueryList
>
result
=
new
MediaQueryList
(
this
aMediaQueryList
aCallerType
)
;
mDOMMediaQueryLists
.
insertBack
(
result
)
;
return
result
.
forget
(
)
;
}
void
Document
:
:
SetMayStartLayout
(
bool
aMayStartLayout
)
{
mMayStartLayout
=
aMayStartLayout
;
if
(
MayStartLayout
(
)
)
{
if
(
nsCOMPtr
<
nsIAppWindow
>
win
=
GetAppWindowIfToplevelChrome
(
)
)
{
win
-
>
BeforeStartLayout
(
)
;
}
ReadyState
state
=
GetReadyStateEnum
(
)
;
if
(
state
>
=
READYSTATE_INTERACTIVE
)
{
MaybeResolveReadyForIdle
(
)
;
}
}
MaybeEditingStateChanged
(
)
;
}
nsresult
Document
:
:
InitializeFrameLoader
(
nsFrameLoader
*
aLoader
)
{
mInitializableFrameLoaders
.
RemoveElement
(
aLoader
)
;
if
(
mInDestructor
)
{
NS_WARNING
(
"
Trying
to
initialize
a
frame
loader
while
"
"
document
is
being
deleted
"
)
;
return
NS_ERROR_FAILURE
;
}
mInitializableFrameLoaders
.
AppendElement
(
aLoader
)
;
if
(
!
mFrameLoaderRunner
)
{
mFrameLoaderRunner
=
NewRunnableMethod
(
"
Document
:
:
MaybeInitializeFinalizeFrameLoaders
"
this
&
Document
:
:
MaybeInitializeFinalizeFrameLoaders
)
;
NS_ENSURE_TRUE
(
mFrameLoaderRunner
NS_ERROR_OUT_OF_MEMORY
)
;
nsContentUtils
:
:
AddScriptRunner
(
mFrameLoaderRunner
)
;
}
return
NS_OK
;
}
nsresult
Document
:
:
FinalizeFrameLoader
(
nsFrameLoader
*
aLoader
nsIRunnable
*
aFinalizer
)
{
mInitializableFrameLoaders
.
RemoveElement
(
aLoader
)
;
if
(
mInDestructor
)
{
return
NS_ERROR_FAILURE
;
}
LogRunnable
:
:
LogDispatch
(
aFinalizer
)
;
mFrameLoaderFinalizers
.
AppendElement
(
aFinalizer
)
;
if
(
!
mFrameLoaderRunner
)
{
mFrameLoaderRunner
=
NewRunnableMethod
(
"
Document
:
:
MaybeInitializeFinalizeFrameLoaders
"
this
&
Document
:
:
MaybeInitializeFinalizeFrameLoaders
)
;
NS_ENSURE_TRUE
(
mFrameLoaderRunner
NS_ERROR_OUT_OF_MEMORY
)
;
nsContentUtils
:
:
AddScriptRunner
(
mFrameLoaderRunner
)
;
}
return
NS_OK
;
}
void
Document
:
:
MaybeInitializeFinalizeFrameLoaders
(
)
{
if
(
mDelayFrameLoaderInitialization
)
{
mFrameLoaderRunner
=
nullptr
;
return
;
}
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
if
(
!
mInDestructor
&
&
!
mFrameLoaderRunner
&
&
(
mInitializableFrameLoaders
.
Length
(
)
|
|
mFrameLoaderFinalizers
.
Length
(
)
)
)
{
mFrameLoaderRunner
=
NewRunnableMethod
(
"
Document
:
:
MaybeInitializeFinalizeFrameLoaders
"
this
&
Document
:
:
MaybeInitializeFinalizeFrameLoaders
)
;
nsContentUtils
:
:
AddScriptRunner
(
mFrameLoaderRunner
)
;
}
return
;
}
mFrameLoaderRunner
=
nullptr
;
while
(
mInitializableFrameLoaders
.
Length
(
)
)
{
RefPtr
<
nsFrameLoader
>
loader
=
mInitializableFrameLoaders
[
0
]
;
mInitializableFrameLoaders
.
RemoveElementAt
(
0
)
;
NS_ASSERTION
(
loader
"
null
frameloader
in
the
array
?
"
)
;
loader
-
>
ReallyStartLoading
(
)
;
}
uint32_t
length
=
mFrameLoaderFinalizers
.
Length
(
)
;
if
(
length
>
0
)
{
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
finalizers
=
std
:
:
move
(
mFrameLoaderFinalizers
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
LogRunnable
:
:
Run
run
(
finalizers
[
i
]
)
;
finalizers
[
i
]
-
>
Run
(
)
;
}
}
}
void
Document
:
:
TryCancelFrameLoaderInitialization
(
nsIDocShell
*
aShell
)
{
uint32_t
length
=
mInitializableFrameLoaders
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
mInitializableFrameLoaders
[
i
]
-
>
GetExistingDocShell
(
)
=
=
aShell
)
{
mInitializableFrameLoaders
.
RemoveElementAt
(
i
)
;
return
;
}
}
}
void
Document
:
:
SetPrototypeDocument
(
nsXULPrototypeDocument
*
aPrototype
)
{
mPrototypeDocument
=
aPrototype
;
mSynchronousDOMContentLoaded
=
true
;
}
nsIPermissionDelegateHandler
*
Document
:
:
PermDelegateHandler
(
)
{
return
GetPermissionDelegateHandler
(
)
;
}
Document
*
Document
:
:
RequestExternalResource
(
nsIURI
*
aURI
nsIReferrerInfo
*
aReferrerInfo
nsINode
*
aRequestingNode
ExternalResourceLoad
*
*
aPendingLoad
)
{
MOZ_ASSERT
(
aURI
"
Must
have
a
URI
"
)
;
MOZ_ASSERT
(
aRequestingNode
"
Must
have
a
node
"
)
;
MOZ_ASSERT
(
aReferrerInfo
"
Must
have
a
referrerInfo
"
)
;
if
(
mDisplayDocument
)
{
return
mDisplayDocument
-
>
RequestExternalResource
(
aURI
aReferrerInfo
aRequestingNode
aPendingLoad
)
;
}
return
mExternalResourceMap
.
RequestResource
(
aURI
aReferrerInfo
aRequestingNode
this
aPendingLoad
)
;
}
void
Document
:
:
EnumerateExternalResources
(
SubDocEnumFunc
aCallback
)
{
mExternalResourceMap
.
EnumerateResources
(
aCallback
)
;
}
SMILAnimationController
*
Document
:
:
GetAnimationController
(
)
{
if
(
mAnimationController
)
return
mAnimationController
;
if
(
mLoadedAsData
)
return
nullptr
;
mAnimationController
=
new
SMILAnimationController
(
this
)
;
nsPresContext
*
context
=
GetPresContext
(
)
;
if
(
mAnimationController
&
&
context
&
&
context
-
>
ImageAnimationMode
(
)
=
=
imgIContainer
:
:
kDontAnimMode
)
{
mAnimationController
-
>
Pause
(
SMILTimeContainer
:
:
PAUSE_USERPREF
)
;
}
if
(
!
mIsShowing
&
&
!
mIsBeingUsedAsImage
)
{
mAnimationController
-
>
OnPageHide
(
)
;
}
return
mAnimationController
;
}
ScrollTimelineAnimationTracker
*
Document
:
:
GetOrCreateScrollTimelineAnimationTracker
(
)
{
if
(
!
mScrollTimelineAnimationTracker
)
{
mScrollTimelineAnimationTracker
=
new
ScrollTimelineAnimationTracker
(
this
)
;
}
return
mScrollTimelineAnimationTracker
;
}
void
Document
:
:
GetDir
(
nsAString
&
aDirection
)
const
{
aDirection
.
Truncate
(
)
;
Element
*
rootElement
=
GetHtmlElement
(
)
;
if
(
rootElement
)
{
static_cast
<
nsGenericHTMLElement
*
>
(
rootElement
)
-
>
GetDir
(
aDirection
)
;
}
}
void
Document
:
:
SetDir
(
const
nsAString
&
aDirection
)
{
Element
*
rootElement
=
GetHtmlElement
(
)
;
if
(
rootElement
)
{
rootElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
aDirection
true
)
;
}
}
nsIHTMLCollection
*
Document
:
:
Images
(
)
{
if
(
!
mImages
)
{
mImages
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
img
nsGkAtoms
:
:
img
)
;
}
return
mImages
;
}
nsIHTMLCollection
*
Document
:
:
Embeds
(
)
{
if
(
!
mEmbeds
)
{
mEmbeds
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
embed
)
;
}
return
mEmbeds
;
}
static
bool
MatchLinks
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
return
aElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
area
)
&
&
aElement
-
>
HasAttr
(
nsGkAtoms
:
:
href
)
;
}
nsIHTMLCollection
*
Document
:
:
Links
(
)
{
if
(
!
mLinks
)
{
mLinks
=
new
nsContentList
(
this
MatchLinks
nullptr
nullptr
)
;
}
return
mLinks
;
}
nsIHTMLCollection
*
Document
:
:
Forms
(
)
{
if
(
!
mForms
)
{
mForms
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
form
nsGkAtoms
:
:
form
)
;
}
return
mForms
;
}
nsIHTMLCollection
*
Document
:
:
Scripts
(
)
{
if
(
!
mScripts
)
{
mScripts
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
script
nsGkAtoms
:
:
script
)
;
}
return
mScripts
;
}
nsIHTMLCollection
*
Document
:
:
Applets
(
)
{
if
(
!
mApplets
)
{
mApplets
=
new
nsEmptyContentList
(
this
)
;
}
return
mApplets
;
}
static
bool
MatchAnchors
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
return
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
&
&
aElement
-
>
HasAttr
(
nsGkAtoms
:
:
name
)
;
}
nsIHTMLCollection
*
Document
:
:
Anchors
(
)
{
if
(
!
mAnchors
)
{
mAnchors
=
new
nsContentList
(
this
MatchAnchors
nullptr
nullptr
)
;
}
return
mAnchors
;
}
mozilla
:
:
dom
:
:
Nullable
<
mozilla
:
:
dom
:
:
WindowProxyHolder
>
Document
:
:
Open
(
const
nsAString
&
aURL
const
nsAString
&
aName
const
nsAString
&
aFeatures
ErrorResult
&
rv
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
CanCallerAccess
(
this
)
"
XOW
should
have
caught
this
!
"
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetInnerWindow
(
)
;
if
(
!
window
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_ACCESS_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
outer
=
nsPIDOMWindowOuter
:
:
GetFromCurrentInner
(
window
)
;
if
(
!
outer
)
{
rv
.
Throw
(
NS_ERROR_NOT_INITIALIZED
)
;
return
nullptr
;
}
RefPtr
<
nsGlobalWindowOuter
>
win
=
nsGlobalWindowOuter
:
:
Cast
(
outer
)
;
RefPtr
<
BrowsingContext
>
newBC
;
rv
=
win
-
>
OpenJS
(
aURL
aName
aFeatures
getter_AddRefs
(
newBC
)
)
;
if
(
!
newBC
)
{
return
nullptr
;
}
return
WindowProxyHolder
(
std
:
:
move
(
newBC
)
)
;
}
Document
*
Document
:
:
Open
(
const
Optional
<
nsAString
>
&
const
Optional
<
nsAString
>
&
ErrorResult
&
aError
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
CanCallerAccess
(
this
)
"
XOW
should
have
caught
this
!
"
)
;
if
(
!
IsHTMLDocument
(
)
|
|
mDisableDocWrite
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
if
(
ShouldThrowOnDynamicMarkupInsertion
(
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
nullptr
;
}
nsCOMPtr
<
Document
>
callerDoc
=
GetEntryDocument
(
)
;
if
(
!
callerDoc
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
if
(
!
callerDoc
-
>
NodePrincipal
(
)
-
>
Equals
(
NodePrincipal
(
)
)
)
{
aError
.
Throw
(
NS_ERROR_DOM_SECURITY_ERR
)
;
return
nullptr
;
}
if
(
(
mParser
&
&
mParser
-
>
HasNonzeroScriptNestingLevel
(
)
)
|
|
mParserAborted
)
{
return
this
;
}
if
(
ShouldIgnoreOpens
(
)
)
{
return
this
;
}
RefPtr
<
nsDocShell
>
shell
(
mDocumentContainer
)
;
if
(
shell
)
{
bool
inUnload
;
shell
-
>
GetIsInUnload
(
&
inUnload
)
;
if
(
inUnload
)
{
return
this
;
}
}
nsCOMPtr
<
nsIContentSecurityPolicy
>
csp
=
callerDoc
-
>
GetCsp
(
)
;
if
(
csp
)
{
RefPtr
<
nsCSPContext
>
cspToInherit
=
new
nsCSPContext
(
)
;
cspToInherit
-
>
InitFromOther
(
static_cast
<
nsCSPContext
*
>
(
csp
.
get
(
)
)
)
;
mCSP
=
cspToInherit
;
}
SetUseCounter
(
eUseCounter_custom_DocumentOpen
)
;
if
(
shell
&
&
IsCurrentActiveDocument
(
)
&
&
shell
-
>
GetIsAttemptingToNavigate
(
)
)
{
shell
-
>
Stop
(
nsIWebNavigation
:
:
STOP_NETWORK
)
;
EnsureOnloadBlocker
(
)
;
}
for
(
nsINode
*
node
:
ShadowIncludingTreeIterator
(
*
this
)
)
{
if
(
EventListenerManager
*
elm
=
node
-
>
GetExistingListenerManager
(
)
)
{
elm
-
>
RemoveAllListeners
(
)
;
}
}
if
(
nsPIDOMWindowInner
*
win
=
GetInnerWindow
(
)
)
{
if
(
win
-
>
GetExtantDoc
(
)
=
=
this
)
{
if
(
EventListenerManager
*
elm
=
nsGlobalWindowInner
:
:
Cast
(
win
)
-
>
GetExistingListenerManager
(
)
)
{
elm
-
>
RemoveAllListeners
(
)
;
}
}
}
if
(
mParser
)
{
MOZ_ASSERT
(
!
mParser
-
>
HasNonzeroScriptNestingLevel
(
)
"
Why
didn
'
t
we
take
the
early
return
?
"
)
;
IgnoreOpensDuringUnload
ignoreOpenGuard
(
this
)
;
mParser
-
>
Terminate
(
)
;
MOZ_RELEASE_ASSERT
(
!
mParser
"
mParser
should
have
been
null
'
d
out
"
)
;
}
{
IgnoreOpensDuringUnload
ignoreOpenGuard
(
this
)
;
DisconnectNodeTree
(
)
;
}
if
(
shell
&
&
IsCurrentActiveDocument
(
)
)
{
nsCOMPtr
<
nsIURI
>
newURI
=
callerDoc
-
>
GetDocumentURI
(
)
;
if
(
callerDoc
!
=
this
)
{
nsCOMPtr
<
nsIURI
>
noFragmentURI
;
nsresult
rv
=
NS_GetURIWithoutRef
(
newURI
getter_AddRefs
(
noFragmentURI
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
newURI
=
std
:
:
move
(
noFragmentURI
)
;
}
nsCOMPtr
<
nsIURI
>
currentURI
=
GetDocumentURI
(
)
;
bool
equalURIs
;
nsresult
rv
=
currentURI
-
>
Equals
(
newURI
&
equalURIs
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIStructuredCloneContainer
>
stateContainer
(
mStateObjectContainer
)
;
rv
=
shell
-
>
UpdateURLAndHistory
(
this
newURI
stateContainer
u
"
"
_ns
true
currentURI
equalURIs
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
mSecurityInfo
=
callerDoc
-
>
GetSecurityInfo
(
)
;
SetIsInitialDocument
(
false
)
;
nsDocShell
:
:
Cast
(
shell
)
-
>
SetDocumentOpenedButNotLoaded
(
)
;
}
mSkipLoadEventAfterClose
=
mLoadEventFiring
;
SetReadyStateInternal
(
READYSTATE_UNINITIALIZED
false
)
;
mSetCompleteAfterDOMContentLoaded
=
false
;
SetCompatibilityMode
(
eCompatibility_FullStandards
)
;
mParserAborted
=
false
;
RefPtr
<
nsHtml5Parser
>
parser
=
nsHtml5Module
:
:
NewHtml5Parser
(
)
;
mParser
=
parser
;
parser
-
>
Initialize
(
this
GetDocumentURI
(
)
ToSupports
(
shell
)
nullptr
)
;
nsresult
rv
=
parser
-
>
StartExecutor
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aError
.
Throw
(
rv
)
;
return
nullptr
;
}
mLayoutHistoryState
=
nullptr
;
if
(
shell
)
{
shell
-
>
PrepareForNewContentModel
(
)
;
nsCOMPtr
<
nsIDocumentViewer
>
viewer
;
shell
-
>
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
viewer
-
>
LoadStart
(
this
)
;
}
}
SetReadyStateInternal
(
Document
:
:
READYSTATE_LOADING
false
)
;
return
this
;
}
void
Document
:
:
Close
(
ErrorResult
&
rv
)
{
if
(
!
IsHTMLDocument
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
ShouldThrowOnDynamicMarkupInsertion
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
!
mParser
|
|
!
mParser
-
>
IsScriptCreated
(
)
)
{
return
;
}
+
+
mWriteLevel
;
rv
=
(
static_cast
<
nsHtml5Parser
*
>
(
mParser
.
get
(
)
)
)
-
>
Parse
(
u
"
"
_ns
nullptr
true
)
;
-
-
mWriteLevel
;
}
void
Document
:
:
WriteCommon
(
const
Sequence
<
nsString
>
&
aText
bool
aNewlineTerminate
mozilla
:
:
ErrorResult
&
rv
)
{
if
(
aText
.
Length
(
)
=
=
1
)
{
WriteCommon
(
aText
[
0
]
aNewlineTerminate
rv
)
;
}
else
{
nsString
text
;
for
(
size_t
i
=
0
;
i
<
aText
.
Length
(
)
;
+
+
i
)
{
text
.
Append
(
aText
[
i
]
)
;
}
WriteCommon
(
text
aNewlineTerminate
rv
)
;
}
}
void
Document
:
:
WriteCommon
(
const
nsAString
&
aText
bool
aNewlineTerminate
ErrorResult
&
aRv
)
{
#
ifdef
DEBUG
{
nsCOMPtr
<
nsIPrincipal
>
principal
=
NodePrincipal
(
)
;
bool
isAboutOrPrivContext
=
principal
-
>
IsSystemPrincipal
(
)
;
if
(
!
isAboutOrPrivContext
)
{
if
(
principal
-
>
SchemeIs
(
"
about
"
)
)
{
nsAutoCString
host
;
principal
-
>
GetHost
(
host
)
;
isAboutOrPrivContext
=
!
host
.
EqualsLiteral
(
"
blank
"
)
;
}
}
MOZ_ASSERT
(
!
isAboutOrPrivContext
|
|
aText
.
IsEmpty
(
)
"
do
not
use
doc
.
write
in
privileged
context
!
"
)
;
}
#
endif
mTooDeepWriteRecursion
=
(
mWriteLevel
>
NS_MAX_DOCUMENT_WRITE_DEPTH
|
|
mTooDeepWriteRecursion
)
;
if
(
NS_WARN_IF
(
mTooDeepWriteRecursion
)
)
{
aRv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
;
}
if
(
!
IsHTMLDocument
(
)
|
|
mDisableDocWrite
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
ShouldThrowOnDynamicMarkupInsertion
(
)
)
{
aRv
.
Throw
(
NS_ERROR_DOM_INVALID_STATE_ERR
)
;
return
;
}
if
(
mParserAborted
)
{
return
;
}
if
(
ShouldIgnoreOpens
(
)
)
{
return
;
}
void
*
key
=
GenerateParserKey
(
)
;
if
(
mParser
&
&
!
mParser
-
>
IsInsertionPointDefined
(
)
)
{
if
(
mIgnoreDestructiveWritesCounter
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
DOM
Events
"
_ns
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
DocumentWriteIgnored
"
)
;
return
;
}
IgnoreOpensDuringUnload
ignoreOpenGuard
(
this
)
;
mParser
-
>
Terminate
(
)
;
MOZ_RELEASE_ASSERT
(
!
mParser
"
mParser
should
have
been
null
'
d
out
"
)
;
}
if
(
!
mParser
)
{
if
(
mIgnoreDestructiveWritesCounter
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
DOM
Events
"
_ns
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
DocumentWriteIgnored
"
)
;
return
;
}
Open
(
{
}
{
}
aRv
)
;
if
(
aRv
.
Failed
(
)
|
|
!
mParser
)
{
return
;
}
}
static
constexpr
auto
new_line
=
u
"
\
n
"
_ns
;
+
+
mWriteLevel
;
if
(
aNewlineTerminate
)
{
aRv
=
(
static_cast
<
nsHtml5Parser
*
>
(
mParser
.
get
(
)
)
)
-
>
Parse
(
aText
+
new_line
key
false
)
;
}
else
{
aRv
=
(
static_cast
<
nsHtml5Parser
*
>
(
mParser
.
get
(
)
)
)
-
>
Parse
(
aText
key
false
)
;
}
-
-
mWriteLevel
;
mTooDeepWriteRecursion
=
(
mWriteLevel
!
=
0
&
&
mTooDeepWriteRecursion
)
;
}
void
Document
:
:
Write
(
const
Sequence
<
nsString
>
&
aText
ErrorResult
&
rv
)
{
WriteCommon
(
aText
false
rv
)
;
}
void
Document
:
:
Writeln
(
const
Sequence
<
nsString
>
&
aText
ErrorResult
&
rv
)
{
WriteCommon
(
aText
true
rv
)
;
}
void
*
Document
:
:
GenerateParserKey
(
void
)
{
if
(
!
mScriptLoader
)
{
return
nullptr
;
}
nsIScriptElement
*
script
=
mScriptLoader
-
>
GetCurrentParserInsertedScript
(
)
;
if
(
script
&
&
mParser
&
&
mParser
-
>
IsScriptCreated
(
)
)
{
nsCOMPtr
<
nsIParser
>
creatorParser
=
script
-
>
GetCreatorParser
(
)
;
if
(
creatorParser
!
=
mParser
)
{
return
nullptr
;
}
}
return
script
;
}
bool
Document
:
:
MatchNameAttribute
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAtom
void
*
aData
)
{
MOZ_ASSERT
(
aElement
"
Must
have
element
to
work
with
!
"
)
;
if
(
!
aElement
-
>
HasName
(
)
)
{
return
false
;
}
nsString
*
elementName
=
static_cast
<
nsString
*
>
(
aData
)
;
return
aElement
-
>
GetNameSpaceID
(
)
=
=
kNameSpaceID_XHTML
&
&
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
*
elementName
eCaseMatters
)
;
}
void
*
Document
:
:
UseExistingNameString
(
nsINode
*
aRootNode
const
nsString
*
aName
)
{
return
const_cast
<
nsString
*
>
(
aName
)
;
}
nsresult
Document
:
:
GetDocumentURI
(
nsString
&
aDocumentURI
)
const
{
if
(
mDocumentURI
)
{
nsAutoCString
uri
;
nsresult
rv
=
mDocumentURI
-
>
GetSpec
(
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
CopyUTF8toUTF16
(
uri
aDocumentURI
)
;
}
else
{
aDocumentURI
.
Truncate
(
)
;
}
return
NS_OK
;
}
nsresult
Document
:
:
GetURL
(
nsString
&
aURL
)
const
{
return
GetDocumentURI
(
aURL
)
;
}
void
Document
:
:
GetDocumentURIFromJS
(
nsString
&
aDocumentURI
CallerType
aCallerType
ErrorResult
&
aRv
)
const
{
if
(
!
mChromeXHRDocURI
|
|
aCallerType
!
=
CallerType
:
:
System
)
{
aRv
=
GetDocumentURI
(
aDocumentURI
)
;
return
;
}
nsAutoCString
uri
;
nsresult
res
=
mChromeXHRDocURI
-
>
GetSpec
(
uri
)
;
if
(
NS_FAILED
(
res
)
)
{
aRv
.
Throw
(
res
)
;
return
;
}
CopyUTF8toUTF16
(
uri
aDocumentURI
)
;
}
nsIURI
*
Document
:
:
GetDocumentURIObject
(
)
const
{
if
(
!
mChromeXHRDocURI
)
{
return
GetDocumentURI
(
)
;
}
return
mChromeXHRDocURI
;
}
void
Document
:
:
GetCompatMode
(
nsString
&
aCompatMode
)
const
{
NS_ASSERTION
(
mCompatMode
=
=
eCompatibility_NavQuirks
|
|
mCompatMode
=
=
eCompatibility_AlmostStandards
|
|
mCompatMode
=
=
eCompatibility_FullStandards
"
mCompatMode
is
neither
quirks
nor
strict
for
this
document
"
)
;
if
(
mCompatMode
=
=
eCompatibility_NavQuirks
)
{
aCompatMode
.
AssignLiteral
(
"
BackCompat
"
)
;
}
else
{
aCompatMode
.
AssignLiteral
(
"
CSS1Compat
"
)
;
}
}
}
}
void
nsDOMAttributeMap
:
:
BlastSubtreeToPieces
(
nsINode
*
aNode
)
{
if
(
Element
*
element
=
Element
:
:
FromNode
(
aNode
)
)
{
if
(
const
nsDOMAttributeMap
*
map
=
element
-
>
GetAttributeMap
(
)
)
{
while
(
true
)
{
RefPtr
<
Attr
>
attr
;
{
auto
iter
=
map
-
>
mAttributeCache
.
ConstIter
(
)
;
if
(
iter
.
Done
(
)
)
{
break
;
}
attr
=
iter
.
UserData
(
)
;
}
BlastSubtreeToPieces
(
attr
)
;
mozilla
:
:
DebugOnly
<
nsresult
>
rv
=
element
-
>
UnsetAttr
(
attr
-
>
NodeInfo
(
)
-
>
NamespaceID
(
)
attr
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
false
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
Uh
-
oh
UnsetAttr
shouldn
'
t
fail
!
"
)
;
}
}
if
(
mozilla
:
:
dom
:
:
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
BlastSubtreeToPieces
(
shadow
)
;
element
-
>
UnattachShadow
(
)
;
}
}
while
(
aNode
-
>
HasChildren
(
)
)
{
nsIContent
*
node
=
aNode
-
>
GetFirstChild
(
)
;
BlastSubtreeToPieces
(
node
)
;
aNode
-
>
RemoveChildNode
(
node
false
)
;
}
}
namespace
mozilla
:
:
dom
{
nsINode
*
Document
:
:
AdoptNode
(
nsINode
&
aAdoptedNode
ErrorResult
&
rv
bool
aAcceptShadowRoot
)
{
OwningNonNull
<
nsINode
>
adoptedNode
=
aAdoptedNode
;
if
(
adoptedNode
-
>
IsShadowRoot
(
)
&
&
!
aAcceptShadowRoot
)
{
rv
.
ThrowHierarchyRequestError
(
"
The
adopted
node
is
a
shadow
root
.
"
)
;
return
nullptr
;
}
{
if
(
nsCOMPtr
<
nsINode
>
parent
=
adoptedNode
-
>
GetParentNode
(
)
)
{
nsContentUtils
:
:
MaybeFireNodeRemoved
(
adoptedNode
parent
)
;
}
}
nsAutoScriptBlocker
scriptBlocker
;
switch
(
adoptedNode
-
>
NodeType
(
)
)
{
case
ATTRIBUTE_NODE
:
{
OwningNonNull
<
Attr
>
adoptedAttr
=
static_cast
<
Attr
&
>
(
*
adoptedNode
)
;
nsCOMPtr
<
Element
>
ownerElement
=
adoptedAttr
-
>
GetOwnerElement
(
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
ownerElement
)
{
OwningNonNull
<
Attr
>
newAttr
=
ownerElement
-
>
RemoveAttributeNode
(
*
adoptedAttr
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
}
break
;
}
case
DOCUMENT_FRAGMENT_NODE
:
case
ELEMENT_NODE
:
case
PROCESSING_INSTRUCTION_NODE
:
case
TEXT_NODE
:
case
CDATA_SECTION_NODE
:
case
COMMENT_NODE
:
case
DOCUMENT_TYPE_NODE
:
{
if
(
adoptedNode
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
while
(
bc
)
{
nsCOMPtr
<
nsINode
>
node
=
bc
-
>
GetEmbedderElement
(
)
;
if
(
node
&
&
node
-
>
IsInclusiveDescendantOf
(
adoptedNode
)
)
{
rv
.
ThrowHierarchyRequestError
(
"
Trying
to
adopt
a
node
into
its
own
contentDocument
or
a
"
"
descendant
contentDocument
.
"
)
;
return
nullptr
;
}
if
(
XRE_IsParentProcess
(
)
)
{
bc
=
bc
-
>
Canonical
(
)
-
>
GetParentCrossChromeBoundary
(
)
;
}
else
{
bc
=
bc
-
>
GetParent
(
)
;
}
}
nsCOMPtr
<
nsINode
>
parent
=
adoptedNode
-
>
GetParentNode
(
)
;
if
(
parent
)
{
parent
-
>
RemoveChildNode
(
adoptedNode
-
>
AsContent
(
)
true
)
;
}
else
{
MOZ_ASSERT
(
!
adoptedNode
-
>
IsInUncomposedDoc
(
)
)
;
}
break
;
}
case
DOCUMENT_NODE
:
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
default
:
{
NS_WARNING
(
"
Don
'
t
know
how
to
adopt
this
nodetype
for
adoptNode
.
"
)
;
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
}
nsCOMPtr
<
Document
>
oldDocument
=
adoptedNode
-
>
OwnerDoc
(
)
;
bool
sameDocument
=
oldDocument
=
=
this
;
AutoJSContext
cx
;
JS
:
:
Rooted
<
JSObject
*
>
newScope
(
cx
nullptr
)
;
if
(
!
sameDocument
)
{
newScope
=
GetWrapper
(
)
;
if
(
!
newScope
&
&
GetScopeObject
(
)
&
&
GetScopeObject
(
)
-
>
HasJSGlobal
(
)
)
{
JSObject
*
globalObject
=
GetScopeObject
(
)
-
>
GetGlobalJSObject
(
)
;
JSAutoRealm
ar
(
cx
globalObject
)
;
JS
:
:
Rooted
<
JS
:
:
Value
>
v
(
cx
)
;
rv
=
nsContentUtils
:
:
WrapNative
(
cx
ToSupports
(
this
)
this
&
v
false
)
;
if
(
rv
.
Failed
(
)
)
return
nullptr
;
newScope
=
&
v
.
toObject
(
)
;
}
}
adoptedNode
-
>
Adopt
(
sameDocument
?
nullptr
:
mNodeInfoManager
newScope
rv
)
;
if
(
rv
.
Failed
(
)
)
{
nsDOMAttributeMap
:
:
BlastSubtreeToPieces
(
adoptedNode
)
;
return
nullptr
;
}
MOZ_ASSERT
(
adoptedNode
-
>
OwnerDoc
(
)
=
=
this
"
Should
still
be
in
the
document
we
just
got
adopted
into
"
)
;
return
adoptedNode
;
}
bool
Document
:
:
UseWidthDeviceWidthFallbackViewport
(
)
const
{
return
false
;
}
static
Maybe
<
LayoutDeviceToScreenScale
>
ParseScaleString
(
const
nsString
&
aScaleString
)
{
if
(
aScaleString
.
EqualsLiteral
(
"
device
-
width
"
)
|
|
aScaleString
.
EqualsLiteral
(
"
device
-
height
"
)
)
{
return
Some
(
LayoutDeviceToScreenScale
(
10
.
0f
)
)
;
}
else
if
(
aScaleString
.
EqualsLiteral
(
"
yes
"
)
)
{
return
Some
(
LayoutDeviceToScreenScale
(
1
.
0f
)
)
;
}
else
if
(
aScaleString
.
EqualsLiteral
(
"
no
"
)
)
{
return
Some
(
LayoutDeviceToScreenScale
(
ViewportMinScale
(
)
)
)
;
}
else
if
(
aScaleString
.
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
nsresult
scaleErrorCode
;
float
scale
=
aScaleString
.
ToFloatAllowTrailingChars
(
&
scaleErrorCode
)
;
if
(
NS_FAILED
(
scaleErrorCode
)
)
{
return
Some
(
LayoutDeviceToScreenScale
(
ViewportMinScale
(
)
)
)
;
}
if
(
scale
<
0
)
{
return
Nothing
(
)
;
}
return
Some
(
clamped
(
LayoutDeviceToScreenScale
(
scale
)
ViewportMinScale
(
)
ViewportMaxScale
(
)
)
)
;
}
void
Document
:
:
ParseScalesInViewportMetaData
(
const
ViewportMetaData
&
aViewportMetaData
)
{
Maybe
<
LayoutDeviceToScreenScale
>
scale
;
scale
=
ParseScaleString
(
aViewportMetaData
.
mInitialScale
)
;
mScaleFloat
=
scale
.
valueOr
(
LayoutDeviceToScreenScale
(
0
.
0f
)
)
;
mValidScaleFloat
=
scale
.
isSome
(
)
;
scale
=
ParseScaleString
(
aViewportMetaData
.
mMaximumScale
)
;
mScaleMaxFloat
=
scale
.
valueOr
(
ViewportMaxScale
(
)
)
;
mValidMaxScale
=
scale
.
isSome
(
)
;
scale
=
ParseScaleString
(
aViewportMetaData
.
mMinimumScale
)
;
mScaleMinFloat
=
scale
.
valueOr
(
ViewportMinScale
(
)
)
;
mValidMinScale
=
scale
.
isSome
(
)
;
if
(
mValidMaxScale
&
&
mValidMinScale
)
{
mScaleMaxFloat
=
std
:
:
max
(
mScaleMinFloat
mScaleMaxFloat
)
;
}
}
void
Document
:
:
ParseWidthAndHeightInMetaViewport
(
const
nsAString
&
aWidthString
const
nsAString
&
aHeightString
bool
aHasValidScale
)
{
mMinWidth
=
nsViewportInfo
:
:
kAuto
;
mMaxWidth
=
nsViewportInfo
:
:
kAuto
;
if
(
!
aWidthString
.
IsEmpty
(
)
)
{
mMinWidth
=
nsViewportInfo
:
:
kExtendToZoom
;
if
(
aWidthString
.
EqualsLiteral
(
"
device
-
width
"
)
)
{
mMaxWidth
=
nsViewportInfo
:
:
kDeviceSize
;
}
else
{
nsresult
widthErrorCode
;
mMaxWidth
=
aWidthString
.
ToInteger
(
&
widthErrorCode
)
;
if
(
NS_FAILED
(
widthErrorCode
)
)
{
mMaxWidth
=
nsViewportInfo
:
:
kAuto
;
}
else
if
(
mMaxWidth
>
=
0
.
0f
)
{
mMaxWidth
=
clamped
(
mMaxWidth
CSSCoord
(
1
.
0f
)
CSSCoord
(
10000
.
0f
)
)
;
}
else
{
mMaxWidth
=
nsViewportInfo
:
:
kAuto
;
}
}
}
else
if
(
aHasValidScale
)
{
if
(
aHeightString
.
IsEmpty
(
)
)
{
mMinWidth
=
nsViewportInfo
:
:
kExtendToZoom
;
mMaxWidth
=
nsViewportInfo
:
:
kExtendToZoom
;
}
}
else
if
(
aHeightString
.
IsEmpty
(
)
&
&
UseWidthDeviceWidthFallbackViewport
(
)
)
{
mMinWidth
=
nsViewportInfo
:
:
kExtendToZoom
;
mMaxWidth
=
nsViewportInfo
:
:
kDeviceSize
;
}
mMinHeight
=
nsViewportInfo
:
:
kAuto
;
mMaxHeight
=
nsViewportInfo
:
:
kAuto
;
if
(
!
aHeightString
.
IsEmpty
(
)
)
{
mMinHeight
=
nsViewportInfo
:
:
kExtendToZoom
;
if
(
aHeightString
.
EqualsLiteral
(
"
device
-
height
"
)
)
{
mMaxHeight
=
nsViewportInfo
:
:
kDeviceSize
;
}
else
{
nsresult
heightErrorCode
;
mMaxHeight
=
aHeightString
.
ToInteger
(
&
heightErrorCode
)
;
if
(
NS_FAILED
(
heightErrorCode
)
)
{
mMaxHeight
=
nsViewportInfo
:
:
kAuto
;
}
else
if
(
mMaxHeight
>
=
0
.
0f
)
{
mMaxHeight
=
clamped
(
mMaxHeight
CSSCoord
(
1
.
0f
)
CSSCoord
(
10000
.
0f
)
)
;
}
else
{
mMaxHeight
=
nsViewportInfo
:
:
kAuto
;
}
}
}
}
nsViewportInfo
Document
:
:
GetViewportInfo
(
const
ScreenIntSize
&
aDisplaySize
)
{
MOZ_ASSERT
(
mPresShell
)
;
nsPresContext
*
context
=
mPresShell
-
>
GetPresContext
(
)
;
float
fullZoom
=
context
?
context
-
>
DeviceContext
(
)
-
>
GetFullZoom
(
)
:
1
.
0
;
fullZoom
=
(
fullZoom
=
=
0
.
0
)
?
1
.
0
:
fullZoom
;
CSSToLayoutDeviceScale
layoutDeviceScale
=
context
?
context
-
>
CSSToDevPixelScale
(
)
:
CSSToLayoutDeviceScale
(
1
)
;
CSSToScreenScale
defaultScale
=
layoutDeviceScale
*
LayoutDeviceToScreenScale
(
1
.
0
)
;
const
bool
fullscreen
=
Fullscreen
(
)
;
auto
*
bc
=
GetBrowsingContext
(
)
;
if
(
bc
&
&
bc
-
>
ForceDesktopViewport
(
)
&
&
!
IsAboutPage
(
)
&
&
!
fullscreen
)
{
CSSCoord
viewportWidth
=
StaticPrefs
:
:
browser_viewport_desktopWidth
(
)
/
fullZoom
;
CSSToScreenScale
scaleToFit
(
aDisplaySize
.
width
/
viewportWidth
)
;
float
aspectRatio
=
(
float
)
aDisplaySize
.
height
/
aDisplaySize
.
width
;
CSSSize
viewportSize
(
viewportWidth
viewportWidth
*
aspectRatio
)
;
ScreenIntSize
fakeDesktopSize
=
RoundedToInt
(
viewportSize
*
scaleToFit
)
;
return
nsViewportInfo
(
fakeDesktopSize
scaleToFit
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
nsViewportInfo
:
:
ZoomBehaviour
:
:
Mobile
nsViewportInfo
:
:
AutoScaleFlag
:
:
AutoScale
)
;
}
if
(
fullscreen
|
|
!
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
this
)
)
{
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsLayoutUtils
:
:
AllowZoomingForDocument
(
this
)
?
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
:
nsViewportInfo
:
:
ZoomFlag
:
:
DisallowZoom
StaticPrefs
:
:
apz_allow_zooming_out
(
)
?
nsViewportInfo
:
:
ZoomBehaviour
:
:
Mobile
:
nsViewportInfo
:
:
ZoomBehaviour
:
:
Desktop
)
;
}
switch
(
mViewportType
)
{
case
DisplayWidthHeight
:
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
nsViewportInfo
:
:
ZoomBehaviour
:
:
Mobile
)
;
case
Unknown
:
{
if
(
!
mLastModifiedViewportMetaData
)
{
if
(
RefPtr
<
DocumentType
>
docType
=
GetDoctype
(
)
)
{
nsAutoString
docId
;
docType
-
>
GetPublicId
(
docId
)
;
if
(
(
docId
.
Find
(
u
"
WAP
"
)
!
=
-
1
)
|
|
(
docId
.
Find
(
u
"
Mobile
"
)
!
=
-
1
)
|
|
(
docId
.
Find
(
u
"
WML
"
)
!
=
-
1
)
)
{
mViewportType
=
DisplayWidthHeight
;
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
nsViewportInfo
:
:
ZoomBehaviour
:
:
Mobile
)
;
}
}
nsAutoString
handheldFriendly
;
GetHeaderData
(
nsGkAtoms
:
:
handheldFriendly
handheldFriendly
)
;
if
(
handheldFriendly
.
EqualsLiteral
(
"
true
"
)
)
{
mViewportType
=
DisplayWidthHeight
;
return
nsViewportInfo
(
aDisplaySize
defaultScale
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
nsViewportInfo
:
:
ZoomBehaviour
:
:
Mobile
)
;
}
}
ViewportMetaData
metaData
=
GetViewportMetaData
(
)
;
ParseScalesInViewportMetaData
(
metaData
)
;
ParseWidthAndHeightInMetaViewport
(
metaData
.
mWidth
metaData
.
mHeight
mValidScaleFloat
)
;
mAllowZoom
=
true
;
if
(
(
metaData
.
mUserScalable
.
EqualsLiteral
(
"
0
"
)
)
|
|
(
metaData
.
mUserScalable
.
EqualsLiteral
(
"
no
"
)
)
|
|
(
metaData
.
mUserScalable
.
EqualsLiteral
(
"
false
"
)
)
)
{
mAllowZoom
=
false
;
}
mViewportFit
=
ViewportFitType
:
:
Auto
;
if
(
!
metaData
.
mViewportFit
.
IsEmpty
(
)
)
{
if
(
metaData
.
mViewportFit
.
EqualsLiteral
(
"
contain
"
)
)
{
mViewportFit
=
ViewportFitType
:
:
Contain
;
}
else
if
(
metaData
.
mViewportFit
.
EqualsLiteral
(
"
cover
"
)
)
{
mViewportFit
=
ViewportFitType
:
:
Cover
;
}
}
mWidthStrEmpty
=
metaData
.
mWidth
.
IsEmpty
(
)
;
mViewportType
=
Specified
;
[
[
fallthrough
]
]
;
}
case
Specified
:
default
:
LayoutDeviceToScreenScale
effectiveMinScale
=
mScaleMinFloat
;
LayoutDeviceToScreenScale
effectiveMaxScale
=
mScaleMaxFloat
;
bool
effectiveValidMaxScale
=
mValidMaxScale
;
nsViewportInfo
:
:
ZoomFlag
effectiveZoomFlag
=
mAllowZoom
?
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
:
nsViewportInfo
:
:
ZoomFlag
:
:
DisallowZoom
;
if
(
StaticPrefs
:
:
browser_ui_zoom_force_user_scalable
(
)
)
{
effectiveMinScale
=
ViewportMinScale
(
)
;
effectiveMaxScale
=
ViewportMaxScale
(
)
;
effectiveValidMaxScale
=
true
;
effectiveZoomFlag
=
nsViewportInfo
:
:
ZoomFlag
:
:
AllowZoom
;
}
auto
ComputeExtendZoom
=
[
&
]
(
)
-
>
float
{
if
(
mValidScaleFloat
&
&
effectiveValidMaxScale
)
{
return
std
:
:
min
(
mScaleFloat
.
scale
effectiveMaxScale
.
scale
)
;
}
if
(
mValidScaleFloat
)
{
return
mScaleFloat
.
scale
;
}
if
(
effectiveValidMaxScale
)
{
return
effectiveMaxScale
.
scale
;
}
return
nsViewportInfo
:
:
kAuto
;
}
;
float
extendZoom
=
ComputeExtendZoom
(
)
;
CSSCoord
minWidth
=
mMinWidth
;
CSSCoord
maxWidth
=
mMaxWidth
;
CSSCoord
minHeight
=
mMinHeight
;
CSSCoord
maxHeight
=
mMaxHeight
;
CSSSize
displaySize
=
ScreenSize
(
aDisplaySize
)
/
defaultScale
;
if
(
maxWidth
=
=
nsViewportInfo
:
:
kAuto
&
&
!
mValidScaleFloat
)
{
if
(
bc
&
&
bc
-
>
TouchEventsOverride
(
)
=
=
TouchEventsOverride
:
:
Enabled
&
&
bc
-
>
InRDMPane
(
)
)
{
maxWidth
=
nsViewportInfo
:
:
Max
(
displaySize
.
width
StaticPrefs
:
:
browser_viewport_desktopWidth
(
)
)
;
}
else
{
maxWidth
=
StaticPrefs
:
:
browser_viewport_desktopWidth
(
)
;
}
maxWidth
/
=
fullZoom
;
minWidth
=
nsViewportInfo
:
:
kExtendToZoom
;
}
if
(
maxWidth
=
=
nsViewportInfo
:
:
kDeviceSize
)
{
maxWidth
=
displaySize
.
width
;
}
if
(
maxHeight
=
=
nsViewportInfo
:
:
kDeviceSize
)
{
maxHeight
=
displaySize
.
height
;
}
if
(
extendZoom
=
=
nsViewportInfo
:
:
kAuto
)
{
if
(
maxWidth
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
maxWidth
=
nsViewportInfo
:
:
kAuto
;
}
if
(
maxHeight
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
maxHeight
=
nsViewportInfo
:
:
kAuto
;
}
if
(
minWidth
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
minWidth
=
maxWidth
;
}
if
(
minHeight
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
minHeight
=
maxHeight
;
}
}
else
{
CSSSize
extendSize
=
displaySize
/
extendZoom
;
if
(
maxWidth
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
maxWidth
=
extendSize
.
width
;
}
if
(
maxHeight
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
maxHeight
=
extendSize
.
height
;
}
if
(
minWidth
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
minWidth
=
nsViewportInfo
:
:
Max
(
extendSize
.
width
maxWidth
)
;
}
if
(
minHeight
=
=
nsViewportInfo
:
:
kExtendToZoom
)
{
minHeight
=
nsViewportInfo
:
:
Max
(
extendSize
.
height
maxHeight
)
;
}
}
CSSCoord
width
=
nsViewportInfo
:
:
kAuto
;
if
(
minWidth
!
=
nsViewportInfo
:
:
kAuto
|
|
maxWidth
!
=
nsViewportInfo
:
:
kAuto
)
{
width
=
nsViewportInfo
:
:
Max
(
minWidth
nsViewportInfo
:
:
Min
(
maxWidth
displaySize
.
width
)
)
;
}
CSSCoord
height
=
nsViewportInfo
:
:
kAuto
;
if
(
minHeight
!
=
nsViewportInfo
:
:
kAuto
|
|
maxHeight
!
=
nsViewportInfo
:
:
kAuto
)
{
height
=
nsViewportInfo
:
:
Max
(
minHeight
nsViewportInfo
:
:
Min
(
maxHeight
displaySize
.
height
)
)
;
}
if
(
width
=
=
nsViewportInfo
:
:
kAuto
)
{
if
(
height
=
=
nsViewportInfo
:
:
kAuto
|
|
aDisplaySize
.
height
=
=
0
)
{
width
=
displaySize
.
width
;
}
else
{
width
=
height
*
aDisplaySize
.
width
/
aDisplaySize
.
height
;
}
}
if
(
height
=
=
nsViewportInfo
:
:
kAuto
)
{
if
(
aDisplaySize
.
width
=
=
0
)
{
height
=
displaySize
.
height
;
}
else
{
height
=
width
*
aDisplaySize
.
height
/
aDisplaySize
.
width
;
}
}
MOZ_ASSERT
(
width
!
=
nsViewportInfo
:
:
kAuto
&
&
height
!
=
nsViewportInfo
:
:
kAuto
)
;
CSSSize
size
(
width
height
)
;
CSSToScreenScale
scaleFloat
=
mScaleFloat
*
layoutDeviceScale
;
CSSToScreenScale
scaleMinFloat
=
effectiveMinScale
*
layoutDeviceScale
;
CSSToScreenScale
scaleMaxFloat
=
effectiveMaxScale
*
layoutDeviceScale
;
nsViewportInfo
:
:
AutoSizeFlag
sizeFlag
=
nsViewportInfo
:
:
AutoSizeFlag
:
:
FixedSize
;
if
(
mMaxWidth
=
=
nsViewportInfo
:
:
kDeviceSize
|
|
(
mWidthStrEmpty
&
&
(
mMaxHeight
=
=
nsViewportInfo
:
:
kDeviceSize
|
|
mScaleFloat
.
scale
=
=
1
.
0f
)
)
|
|
(
!
mWidthStrEmpty
&
&
mMaxWidth
=
=
nsViewportInfo
:
:
kAuto
&
&
mMaxHeight
<
0
)
)
{
sizeFlag
=
nsViewportInfo
:
:
AutoSizeFlag
:
:
AutoSize
;
}
if
(
sizeFlag
=
=
nsViewportInfo
:
:
AutoSizeFlag
:
:
AutoSize
)
{
size
=
displaySize
;
}
CSSSize
effectiveMinSize
=
Min
(
CSSSize
(
kViewportMinSize
)
displaySize
)
;
size
.
width
=
clamped
(
size
.
width
effectiveMinSize
.
width
float
(
kViewportMaxSize
.
width
)
)
;
if
(
!
mValidScaleFloat
&
&
!
mWidthStrEmpty
)
{
CSSToScreenScale
bestFitScale
(
float
(
aDisplaySize
.
width
)
/
size
.
width
)
;
scaleFloat
=
(
scaleFloat
>
bestFitScale
)
?
scaleFloat
:
bestFitScale
;
}
size
.
height
=
clamped
(
size
.
height
effectiveMinSize
.
height
float
(
kViewportMaxSize
.
height
)
)
;
if
(
effectiveZoomFlag
=
=
nsViewportInfo
:
:
ZoomFlag
:
:
DisallowZoom
&
&
scaleFloat
>
CSSToScreenScale
(
0
.
0f
)
)
{
scaleFloat
=
scaleMinFloat
=
scaleMaxFloat
=
clamped
(
scaleFloat
scaleMinFloat
scaleMaxFloat
)
;
}
MOZ_ASSERT
(
scaleFloat
>
CSSToScreenScale
(
0
.
0f
)
|
|
!
mValidScaleFloat
"
If
we
don
'
t
have
a
positive
scale
we
should
be
using
auto
scale
.
"
)
;
if
(
mValidScaleFloat
&
&
scaleFloat
>
=
scaleMinFloat
&
&
scaleFloat
<
=
scaleMaxFloat
)
{
CSSSize
displaySize
=
ScreenSize
(
aDisplaySize
)
/
scaleFloat
;
size
.
width
=
std
:
:
max
(
size
.
width
displaySize
.
width
)
;
size
.
height
=
std
:
:
max
(
size
.
height
displaySize
.
height
)
;
}
else
if
(
effectiveValidMaxScale
)
{
CSSSize
displaySize
=
ScreenSize
(
aDisplaySize
)
/
scaleMaxFloat
;
size
.
width
=
std
:
:
max
(
size
.
width
displaySize
.
width
)
;
size
.
height
=
std
:
:
max
(
size
.
height
displaySize
.
height
)
;
}
return
nsViewportInfo
(
scaleFloat
scaleMinFloat
scaleMaxFloat
size
sizeFlag
mValidScaleFloat
?
nsViewportInfo
:
:
AutoScaleFlag
:
:
FixedScale
:
nsViewportInfo
:
:
AutoScaleFlag
:
:
AutoScale
effectiveZoomFlag
mViewportFit
)
;
}
}
ViewportMetaData
Document
:
:
GetViewportMetaData
(
)
const
{
return
mLastModifiedViewportMetaData
?
*
mLastModifiedViewportMetaData
:
ViewportMetaData
(
)
;
}
void
Document
:
:
SetMetaViewportData
(
UniquePtr
<
ViewportMetaData
>
aData
)
{
mLastModifiedViewportMetaData
=
std
:
:
move
(
aData
)
;
mViewportType
=
Unknown
;
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
*
this
u
"
DOMMetaViewportFitChanged
"
_ns
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
;
}
EventListenerManager
*
Document
:
:
GetOrCreateListenerManager
(
)
{
if
(
!
mListenerManager
)
{
mListenerManager
=
new
EventListenerManager
(
static_cast
<
EventTarget
*
>
(
this
)
)
;
SetFlags
(
NODE_HAS_LISTENERMANAGER
)
;
}
return
mListenerManager
;
}
EventListenerManager
*
Document
:
:
GetExistingListenerManager
(
)
const
{
return
mListenerManager
;
}
void
Document
:
:
GetEventTargetParent
(
EventChainPreVisitor
&
aVisitor
)
{
aVisitor
.
mCanHandle
=
true
;
aVisitor
.
mForceContentDispatch
=
true
;
if
(
aVisitor
.
mEvent
-
>
mMessage
!
=
eLoad
)
{
nsGlobalWindowOuter
*
window
=
nsGlobalWindowOuter
:
:
Cast
(
GetWindow
(
)
)
;
aVisitor
.
SetParentTarget
(
window
?
window
-
>
GetTargetForEventTargetChain
(
)
:
nullptr
false
)
;
}
}
already_AddRefed
<
Event
>
Document
:
:
CreateEvent
(
const
nsAString
&
aEventType
CallerType
aCallerType
ErrorResult
&
rv
)
const
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
RefPtr
<
Event
>
ev
=
EventDispatcher
:
:
CreateEvent
(
const_cast
<
Document
*
>
(
this
)
presContext
nullptr
aEventType
aCallerType
)
;
if
(
!
ev
)
{
rv
.
Throw
(
NS_ERROR_DOM_NOT_SUPPORTED_ERR
)
;
return
nullptr
;
}
WidgetEvent
*
e
=
ev
-
>
WidgetEventPtr
(
)
;
e
-
>
mFlags
.
mBubbles
=
false
;
e
-
>
mFlags
.
mCancelable
=
false
;
return
ev
.
forget
(
)
;
}
void
Document
:
:
FlushPendingNotifications
(
FlushType
aType
)
{
mozilla
:
:
ChangesToFlush
flush
(
aType
aType
>
=
FlushType
:
:
Style
)
;
FlushPendingNotifications
(
flush
)
;
}
void
Document
:
:
FlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aFlush
)
{
FlushType
flushType
=
aFlush
.
mFlushType
;
RefPtr
<
Document
>
documentOnStack
=
this
;
if
(
(
!
IsHTMLDocument
(
)
|
|
(
flushType
>
FlushType
:
:
ContentAndNotify
&
&
mPresShell
&
&
!
mPresShell
-
>
DidInitialize
(
)
)
)
&
&
(
mParser
|
|
mWeakSink
)
)
{
nsCOMPtr
<
nsIContentSink
>
sink
;
if
(
mParser
)
{
sink
=
mParser
-
>
GetContentSink
(
)
;
}
else
{
sink
=
do_QueryReferent
(
mWeakSink
)
;
if
(
!
sink
)
{
mWeakSink
=
nullptr
;
}
}
if
(
sink
&
&
(
flushType
=
=
FlushType
:
:
Content
|
|
IsSafeToFlush
(
)
)
)
{
sink
-
>
FlushPendingNotifications
(
flushType
)
;
}
}
if
(
flushType
<
=
FlushType
:
:
ContentAndNotify
)
{
return
;
}
if
(
StyleOrLayoutObservablyDependsOnParentDocumentLayout
(
)
&
&
mParentDocument
-
>
MayStartLayout
(
)
&
&
IsSafeToFlush
(
)
)
{
ChangesToFlush
parentFlush
=
aFlush
;
if
(
flushType
>
=
FlushType
:
:
Style
)
{
parentFlush
.
mFlushType
=
std
:
:
max
(
FlushType
:
:
Layout
flushType
)
;
}
mParentDocument
-
>
FlushPendingNotifications
(
parentFlush
)
;
}
if
(
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
aFlush
)
;
}
}
void
Document
:
:
FlushExternalResources
(
FlushType
aType
)
{
NS_ASSERTION
(
aType
>
=
FlushType
:
:
Style
"
should
only
need
to
flush
for
style
or
higher
in
external
resources
"
)
;
if
(
GetDisplayDocument
(
)
)
{
return
;
}
auto
flush
=
[
aType
]
(
Document
&
aDoc
)
{
aDoc
.
FlushPendingNotifications
(
aType
)
;
return
CallState
:
:
Continue
;
}
;
EnumerateExternalResources
(
flush
)
;
}
void
Document
:
:
SetXMLDeclaration
(
const
char16_t
*
aVersion
const
char16_t
*
aEncoding
const
int32_t
aStandalone
)
{
if
(
!
aVersion
|
|
*
aVersion
=
=
'
\
0
'
)
{
mXMLDeclarationBits
=
0
;
return
;
}
mXMLDeclarationBits
=
XML_DECLARATION_BITS_DECLARATION_EXISTS
;
if
(
aEncoding
&
&
*
aEncoding
!
=
'
\
0
'
)
{
mXMLDeclarationBits
|
=
XML_DECLARATION_BITS_ENCODING_EXISTS
;
}
if
(
aStandalone
=
=
1
)
{
mXMLDeclarationBits
|
=
XML_DECLARATION_BITS_STANDALONE_EXISTS
|
XML_DECLARATION_BITS_STANDALONE_YES
;
}
else
if
(
aStandalone
=
=
0
)
{
mXMLDeclarationBits
|
=
XML_DECLARATION_BITS_STANDALONE_EXISTS
;
}
}
void
Document
:
:
GetXMLDeclaration
(
nsAString
&
aVersion
nsAString
&
aEncoding
nsAString
&
aStandalone
)
{
aVersion
.
Truncate
(
)
;
aEncoding
.
Truncate
(
)
;
aStandalone
.
Truncate
(
)
;
if
(
!
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_DECLARATION_EXISTS
)
)
{
return
;
}
aVersion
.
AssignLiteral
(
"
1
.
0
"
)
;
if
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_ENCODING_EXISTS
)
{
GetCharacterSet
(
aEncoding
)
;
}
if
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_STANDALONE_EXISTS
)
{
if
(
mXMLDeclarationBits
&
XML_DECLARATION_BITS_STANDALONE_YES
)
{
aStandalone
.
AssignLiteral
(
"
yes
"
)
;
}
else
{
aStandalone
.
AssignLiteral
(
"
no
"
)
;
}
}
}
void
Document
:
:
AddColorSchemeMeta
(
HTMLMetaElement
&
aMeta
)
{
mColorSchemeMetaTags
.
Insert
(
aMeta
)
;
RecomputeColorScheme
(
)
;
}
void
Document
:
:
RemoveColorSchemeMeta
(
HTMLMetaElement
&
aMeta
)
{
mColorSchemeMetaTags
.
RemoveElement
(
aMeta
)
;
RecomputeColorScheme
(
)
;
}
void
Document
:
:
RecomputeColorScheme
(
)
{
auto
oldColorScheme
=
mColorSchemeBits
;
mColorSchemeBits
=
0
;
const
nsTArray
<
HTMLMetaElement
*
>
&
elements
=
mColorSchemeMetaTags
;
for
(
const
HTMLMetaElement
*
el
:
elements
)
{
nsAutoString
content
;
if
(
!
el
-
>
GetAttr
(
nsGkAtoms
:
:
content
content
)
)
{
continue
;
}
NS_ConvertUTF16toUTF8
contentU8
(
content
)
;
if
(
Servo_ColorScheme_Parse
(
&
contentU8
&
mColorSchemeBits
)
)
{
break
;
}
}
if
(
mColorSchemeBits
=
=
oldColorScheme
)
{
return
;
}
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
pc
-
>
RebuildAllStyleData
(
nsChangeHint
(
0
)
RestyleHint
:
:
RecascadeSubtree
(
)
)
;
}
}
bool
Document
:
:
IsScriptEnabled
(
)
const
{
if
(
HasScriptsBlockedBySandbox
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIScriptGlobalObject
>
globalObject
=
do_QueryInterface
(
GetInnerWindow
(
)
)
;
if
(
!
globalObject
|
|
!
globalObject
-
>
HasJSGlobal
(
)
)
{
return
false
;
}
return
xpc
:
:
Scriptability
:
:
Get
(
globalObject
-
>
GetGlobalJSObjectPreserveColor
(
)
)
.
Allowed
(
)
;
}
void
Document
:
:
RetrieveRelevantHeaders
(
nsIChannel
*
aChannel
)
{
PRTime
modDate
=
0
;
nsresult
rv
;
nsCOMPtr
<
nsIHttpChannel
>
httpChannel
;
rv
=
GetHttpChannelHelper
(
aChannel
getter_AddRefs
(
httpChannel
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
if
(
httpChannel
)
{
nsAutoCString
tmp
;
rv
=
httpChannel
-
>
GetResponseHeader
(
"
last
-
modified
"
_ns
tmp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
PRTime
time
;
PRStatus
st
=
PR_ParseTimeString
(
tmp
.
get
(
)
true
&
time
)
;
if
(
st
=
=
PR_SUCCESS
)
{
modDate
=
time
;
}
}
static
const
char
*
const
headers
[
]
=
{
"
default
-
style
"
"
content
-
style
-
type
"
"
content
-
language
"
"
content
-
disposition
"
"
refresh
"
"
x
-
dns
-
prefetch
-
control
"
"
x
-
frame
-
options
"
"
origin
-
trial
"
0
}
;
nsAutoCString
headerVal
;
const
char
*
const
*
name
=
headers
;
while
(
*
name
)
{
rv
=
httpChannel
-
>
GetResponseHeader
(
nsDependentCString
(
*
name
)
headerVal
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
headerVal
.
IsEmpty
(
)
)
{
RefPtr
<
nsAtom
>
key
=
NS_Atomize
(
*
name
)
;
SetHeaderData
(
key
NS_ConvertASCIItoUTF16
(
headerVal
)
)
;
}
+
+
name
;
}
}
else
{
nsCOMPtr
<
nsIFileChannel
>
fileChannel
=
do_QueryInterface
(
aChannel
)
;
if
(
fileChannel
)
{
nsCOMPtr
<
nsIFile
>
file
;
fileChannel
-
>
GetFile
(
getter_AddRefs
(
file
)
)
;
if
(
file
)
{
PRTime
msecs
;
rv
=
file
-
>
GetLastModifiedTime
(
&
msecs
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
modDate
=
msecs
*
int64_t
(
PR_USEC_PER_MSEC
)
;
}
}
}
else
{
nsAutoCString
contentDisp
;
rv
=
aChannel
-
>
GetContentDispositionHeader
(
contentDisp
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
SetHeaderData
(
nsGkAtoms
:
:
headerContentDisposition
NS_ConvertASCIItoUTF16
(
contentDisp
)
)
;
}
}
}
mLastModified
.
Truncate
(
)
;
if
(
modDate
!
=
0
)
{
GetFormattedTimeString
(
modDate
mLastModified
)
;
}
}
void
Document
:
:
ProcessMETATag
(
HTMLMetaElement
*
aMetaElement
)
{
nsAutoString
header
;
aMetaElement
-
>
GetAttr
(
nsGkAtoms
:
:
httpEquiv
header
)
;
if
(
!
header
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
ASCIIToLower
(
header
)
;
if
(
nsGkAtoms
:
:
refresh
-
>
Equals
(
header
)
&
&
(
GetSandboxFlags
(
)
&
SANDBOXED_AUTOMATIC_FEATURES
)
)
{
return
;
}
nsAutoString
result
;
aMetaElement
-
>
GetAttr
(
nsGkAtoms
:
:
content
result
)
;
if
(
!
result
.
IsEmpty
(
)
)
{
RefPtr
<
nsAtom
>
fieldAtom
(
NS_Atomize
(
header
)
)
;
SetHeaderData
(
fieldAtom
result
)
;
}
}
if
(
aMetaElement
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
nsGkAtoms
:
:
handheldFriendly
eIgnoreCase
)
)
{
nsAutoString
result
;
aMetaElement
-
>
GetAttr
(
nsGkAtoms
:
:
content
result
)
;
if
(
!
result
.
IsEmpty
(
)
)
{
nsContentUtils
:
:
ASCIIToLower
(
result
)
;
SetHeaderData
(
nsGkAtoms
:
:
handheldFriendly
result
)
;
}
}
}
already_AddRefed
<
Element
>
Document
:
:
CreateElem
(
const
nsAString
&
aName
nsAtom
*
aPrefix
int32_t
aNamespaceID
const
nsAString
*
aIs
)
{
#
ifdef
DEBUG
nsAutoString
qName
;
if
(
aPrefix
)
{
aPrefix
-
>
ToString
(
qName
)
;
qName
.
Append
(
'
:
'
)
;
}
qName
.
Append
(
aName
)
;
bool
nsAware
=
aPrefix
!
=
nullptr
|
|
aNamespaceID
!
=
GetDefaultNamespaceID
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
nsContentUtils
:
:
CheckQName
(
qName
nsAware
)
)
"
Don
'
t
pass
invalid
prefixes
to
Document
:
:
CreateElem
"
"
check
caller
.
"
)
;
#
endif
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
mNodeInfoManager
-
>
GetNodeInfo
(
aName
aPrefix
aNamespaceID
ELEMENT_NODE
getter_AddRefs
(
nodeInfo
)
)
;
NS_ENSURE_TRUE
(
nodeInfo
nullptr
)
;
nsCOMPtr
<
Element
>
element
;
nsresult
rv
=
NS_NewElement
(
getter_AddRefs
(
element
)
nodeInfo
.
forget
(
)
NOT_FROM_PARSER
aIs
)
;
return
NS_SUCCEEDED
(
rv
)
?
element
.
forget
(
)
:
nullptr
;
}
bool
Document
:
:
IsSafeToFlush
(
)
const
{
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
true
;
}
return
presShell
-
>
IsSafeToFlush
(
)
;
}
void
Document
:
:
Sanitize
(
)
{
RefPtr
<
nsContentList
>
nodes
=
GetElementsByTagName
(
u
"
input
"
_ns
)
;
nsAutoString
value
;
uint32_t
length
=
nodes
-
>
Length
(
true
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
NS_ASSERTION
(
nodes
-
>
Item
(
i
)
"
null
item
in
node
list
!
"
)
;
RefPtr
<
HTMLInputElement
>
input
=
HTMLInputElement
:
:
FromNodeOrNull
(
nodes
-
>
Item
(
i
)
)
;
if
(
!
input
)
continue
;
input
-
>
GetAttr
(
nsGkAtoms
:
:
autocomplete
value
)
;
if
(
value
.
LowerCaseEqualsLiteral
(
"
off
"
)
|
|
input
-
>
HasBeenTypePassword
(
)
)
{
input
-
>
Reset
(
)
;
}
}
nodes
=
GetElementsByTagName
(
u
"
form
"
_ns
)
;
length
=
nodes
-
>
Length
(
true
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
RefPtr
<
HTMLFormElement
>
form
=
HTMLFormElement
:
:
FromNodeOrNull
(
nodes
-
>
Item
(
i
)
)
;
if
(
!
form
)
continue
;
form
-
>
GetAttr
(
nsGkAtoms
:
:
autocomplete
value
)
;
if
(
value
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
form
-
>
Reset
(
)
;
}
}
void
Document
:
:
EnumerateSubDocuments
(
SubDocEnumFunc
aCallback
)
{
if
(
!
mSubDocuments
)
{
return
;
}
AutoTArray
<
RefPtr
<
Document
>
8
>
subdocs
;
for
(
auto
iter
=
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
if
(
Document
*
subdoc
=
entry
-
>
mSubDocument
)
{
subdocs
.
AppendElement
(
subdoc
)
;
}
}
for
(
auto
&
subdoc
:
subdocs
)
{
if
(
aCallback
(
*
subdoc
)
=
=
CallState
:
:
Stop
)
{
break
;
}
}
}
void
Document
:
:
CollectDescendantDocuments
(
nsTArray
<
RefPtr
<
Document
>
>
&
aDescendants
nsDocTestFunc
aCallback
)
const
{
if
(
!
mSubDocuments
)
{
return
;
}
for
(
auto
iter
=
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
const
Document
*
subdoc
=
entry
-
>
mSubDocument
;
if
(
subdoc
)
{
if
(
aCallback
(
subdoc
)
)
{
aDescendants
.
AppendElement
(
entry
-
>
mSubDocument
)
;
}
subdoc
-
>
CollectDescendantDocuments
(
aDescendants
aCallback
)
;
}
}
}
bool
Document
:
:
CanSavePresentation
(
nsIRequest
*
aNewRequest
uint32_t
&
aBFCacheCombo
bool
aIncludeSubdocuments
bool
aAllowUnloadListeners
)
{
bool
ret
=
true
;
if
(
!
IsBFCachingAllowed
(
)
)
{
aBFCacheCombo
|
=
BFCacheStatus
:
:
NOT_ALLOWED
;
ret
=
false
;
}
nsAutoCString
uri
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Verbose
)
)
)
{
if
(
mDocumentURI
)
{
mDocumentURI
-
>
GetSpec
(
uri
)
;
}
}
if
(
EventHandlingSuppressed
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
on
event
handling
suppression
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
EVENT_HANDLING_SUPPRESSED
;
ret
=
false
;
}
nsPIDOMWindowInner
*
win
=
GetInnerWindow
(
)
;
if
(
win
&
&
win
-
>
IsSuspended
(
)
&
&
!
win
-
>
IsFrozen
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
on
suspended
Window
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
SUSPENDED
;
ret
=
false
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
aNewRequest
)
;
bool
thirdParty
=
false
;
bool
allowUnloadListeners
=
aAllowUnloadListeners
&
&
StaticPrefs
:
:
docshell_shistory_bfcache_allow_unload_listeners
(
)
&
&
(
!
channel
|
|
(
NS_SUCCEEDED
(
NodePrincipal
(
)
-
>
IsThirdPartyChannel
(
channel
&
thirdParty
)
)
&
&
thirdParty
)
)
;
nsCOMPtr
<
EventTarget
>
piTarget
=
do_QueryInterface
(
mScriptGlobalObject
)
;
if
(
!
allowUnloadListeners
&
&
piTarget
)
{
EventListenerManager
*
manager
=
piTarget
-
>
GetExistingListenerManager
(
)
;
if
(
manager
)
{
if
(
manager
-
>
HasUnloadListeners
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
unload
handlers
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
UNLOAD_LISTENER
;
ret
=
false
;
}
if
(
manager
-
>
HasBeforeUnloadListeners
(
)
)
{
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
|
|
!
StaticPrefs
:
:
docshell_shistory_bfcache_ship_allow_beforeunload_listeners
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
beforeUnload
handlers
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
BEFOREUNLOAD_LISTENER
;
ret
=
false
;
}
}
}
}
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
loadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
bool
hasMore
=
false
;
nsCOMPtr
<
nsIChannel
>
baseChannel
;
nsCOMPtr
<
nsIMultiPartChannel
>
part
(
do_QueryInterface
(
aNewRequest
)
)
;
if
(
part
)
{
part
-
>
GetBaseChannel
(
getter_AddRefs
(
baseChannel
)
)
;
}
while
(
NS_SUCCEEDED
(
requests
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
requests
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
nsCOMPtr
<
nsIRequest
>
request
=
do_QueryInterface
(
elem
)
;
if
(
request
&
&
request
!
=
aNewRequest
&
&
request
!
=
baseChannel
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
do_QueryInterface
(
request
)
;
if
(
channel
)
{
nsCOMPtr
<
nsILoadInfo
>
li
=
channel
-
>
LoadInfo
(
)
;
if
(
li
-
>
InternalContentPolicyType
(
)
=
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
)
{
continue
;
}
}
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
gPageCacheLog
LogLevel
:
:
Verbose
)
)
)
{
nsAutoCString
requestName
;
request
-
>
GetName
(
requestName
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
because
document
has
request
%
s
"
uri
.
get
(
)
requestName
.
get
(
)
)
)
;
}
aBFCacheCombo
|
=
BFCacheStatus
:
:
REQUEST
;
ret
=
false
;
}
}
}
if
(
MediaManager
:
:
Exists
(
)
&
&
win
&
&
MediaManager
:
:
Get
(
)
-
>
IsWindowStillActive
(
win
-
>
WindowID
(
)
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
GetUserMedia
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
ACTIVE_GET_USER_MEDIA
;
ret
=
false
;
}
#
ifdef
MOZ_WEBRTC
if
(
win
&
&
win
-
>
HasActivePeerConnections
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
PeerConnection
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
ACTIVE_PEER_CONNECTION
;
ret
=
false
;
}
#
endif
if
(
ContainsEMEContent
(
)
)
{
aBFCacheCombo
|
=
BFCacheStatus
:
:
CONTAINS_EME_CONTENT
;
ret
=
false
;
}
if
(
ContainsMSEContent
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
MSE
use
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
CONTAINS_MSE_CONTENT
;
ret
=
false
;
}
if
(
aIncludeSubdocuments
&
&
mSubDocuments
)
{
for
(
auto
iter
=
mSubDocuments
-
>
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
entry
=
static_cast
<
SubDocMapEntry
*
>
(
iter
.
Get
(
)
)
;
Document
*
subdoc
=
entry
-
>
mSubDocument
;
uint32_t
subDocBFCacheCombo
=
0
;
bool
canCache
=
subdoc
?
subdoc
-
>
CanSavePresentation
(
nullptr
subDocBFCacheCombo
true
allowUnloadListeners
)
:
false
;
if
(
!
canCache
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
subdocument
blocked
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
subDocBFCacheCombo
;
ret
=
false
;
}
}
}
if
(
!
mozilla
:
:
BFCacheInParent
(
)
)
{
if
(
RefPtr
<
BrowsingContext
>
browsingContext
=
GetBrowsingContext
(
)
)
{
for
(
auto
&
child
:
browsingContext
-
>
Children
(
)
)
{
if
(
!
child
-
>
IsInProcess
(
)
)
{
aBFCacheCombo
|
=
BFCacheStatus
:
:
CONTAINS_REMOTE_SUBFRAMES
;
ret
=
false
;
break
;
}
}
}
}
if
(
win
)
{
auto
*
globalWindow
=
nsGlobalWindowInner
:
:
Cast
(
win
)
;
#
ifdef
MOZ_WEBSPEECH
if
(
globalWindow
-
>
HasActiveSpeechSynthesis
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
Speech
use
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
HAS_ACTIVE_SPEECH_SYNTHESIS
;
ret
=
false
;
}
#
endif
if
(
globalWindow
-
>
HasUsedVR
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
having
used
VR
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
HAS_USED_VR
;
ret
=
false
;
}
if
(
win
-
>
HasActiveLocks
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
having
active
lock
requests
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
ACTIVE_LOCK
;
ret
=
false
;
}
if
(
win
-
>
HasActiveWebTransports
(
)
)
{
MOZ_LOG
(
gPageCacheLog
mozilla
:
:
LogLevel
:
:
Verbose
(
"
Save
of
%
s
blocked
due
to
WebTransport
"
uri
.
get
(
)
)
)
;
aBFCacheCombo
|
=
BFCacheStatus
:
:
ACTIVE_WEBTRANSPORT
;
ret
=
false
;
}
}
return
ret
;
}
void
Document
:
:
Destroy
(
)
{
if
(
mIsGoingAway
)
{
return
;
}
ReportDocumentUseCounters
(
)
;
ReportLCP
(
)
;
SetDevToolsWatchingDOMMutations
(
false
)
;
mIsGoingAway
=
true
;
ScriptLoader
(
)
-
>
Destroy
(
)
;
SetScriptGlobalObject
(
nullptr
)
;
RemovedFromDocShell
(
)
;
bool
oldVal
=
mInUnlinkOrDeletion
;
mInUnlinkOrDeletion
=
true
;
#
ifdef
DEBUG
uint32_t
oldChildCount
=
GetChildCount
(
)
;
#
endif
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
DestroyContent
(
)
;
MOZ_ASSERT
(
child
-
>
GetParentNode
(
)
=
=
this
)
;
}
MOZ_ASSERT
(
oldChildCount
=
=
GetChildCount
(
)
)
;
MOZ_ASSERT
(
!
mSubDocuments
|
|
mSubDocuments
-
>
EntryCount
(
)
=
=
0
)
;
mInUnlinkOrDeletion
=
oldVal
;
mLayoutHistoryState
=
nullptr
;
if
(
mOriginalDocument
)
{
mOriginalDocument
-
>
mLatestStaticClone
=
nullptr
;
}
if
(
IsStaticDocument
(
)
)
{
RemoveProperty
(
nsGkAtoms
:
:
printisfocuseddoc
)
;
RemoveProperty
(
nsGkAtoms
:
:
printselectionranges
)
;
}
mExternalResourceMap
.
Shutdown
(
)
;
mReadyForIdle
=
nullptr
;
mOrientationPendingPromise
=
nullptr
;
mPreloadService
.
ClearAllPreloads
(
)
;
if
(
mDocumentL10n
)
{
mDocumentL10n
-
>
Destroy
(
)
;
}
}
void
Document
:
:
RemovedFromDocShell
(
)
{
mEditingState
=
EditingState
:
:
eOff
;
if
(
mRemovedFromDocShell
)
return
;
mRemovedFromDocShell
=
true
;
NotifyActivityChanged
(
)
;
for
(
nsIContent
*
child
=
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
child
-
>
SaveSubtreeState
(
)
;
}
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
docShell
-
>
SynchronizeLayoutHistoryState
(
)
;
}
}
already_AddRefed
<
nsILayoutHistoryState
>
Document
:
:
GetLayoutHistoryState
(
)
const
{
nsCOMPtr
<
nsILayoutHistoryState
>
state
;
if
(
!
mScriptGlobalObject
)
{
state
=
mLayoutHistoryState
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mDocumentContainer
)
;
if
(
docShell
)
{
docShell
-
>
GetLayoutHistoryState
(
getter_AddRefs
(
state
)
)
;
}
}
return
state
.
forget
(
)
;
}
void
Document
:
:
EnsureOnloadBlocker
(
)
{
if
(
mOnloadBlockCount
!
=
0
&
&
mScriptGlobalObject
)
{
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
;
if
(
loadGroup
)
{
nsCOMPtr
<
nsISimpleEnumerator
>
requests
;
loadGroup
-
>
GetRequests
(
getter_AddRefs
(
requests
)
)
;
bool
hasMore
=
false
;
while
(
NS_SUCCEEDED
(
requests
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
elem
;
requests
-
>
GetNext
(
getter_AddRefs
(
elem
)
)
;
nsCOMPtr
<
nsIRequest
>
request
=
do_QueryInterface
(
elem
)
;
if
(
request
&
&
request
=
=
mOnloadBlocker
)
{
return
;
}
}
loadGroup
-
>
AddRequest
(
mOnloadBlocker
nullptr
)
;
}
}
}
void
Document
:
:
BlockOnload
(
)
{
if
(
mDisplayDocument
)
{
mDisplayDocument
-
>
BlockOnload
(
)
;
return
;
}
if
(
mOnloadBlockCount
=
=
0
&
&
mScriptGlobalObject
)
{
if
(
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
)
{
loadGroup
-
>
AddRequest
(
mOnloadBlocker
nullptr
)
;
}
}
+
+
mOnloadBlockCount
;
}
void
Document
:
:
UnblockOnload
(
bool
aFireSync
)
{
if
(
mDisplayDocument
)
{
mDisplayDocument
-
>
UnblockOnload
(
aFireSync
)
;
return
;
}
-
-
mOnloadBlockCount
;
if
(
mOnloadBlockCount
=
=
0
)
{
if
(
mScriptGlobalObject
)
{
if
(
aFireSync
)
{
+
+
mOnloadBlockCount
;
DoUnblockOnload
(
)
;
}
else
{
PostUnblockOnloadEvent
(
)
;
}
}
else
if
(
mIsBeingUsedAsImage
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
this
u
"
MozSVGAsImageDocumentLoad
"
_ns
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
}
}
class
nsUnblockOnloadEvent
:
public
Runnable
{
public
:
explicit
nsUnblockOnloadEvent
(
Document
*
aDoc
)
:
mozilla
:
:
Runnable
(
"
nsUnblockOnloadEvent
"
)
mDoc
(
aDoc
)
{
}
NS_IMETHOD
Run
(
)
override
{
mDoc
-
>
DoUnblockOnload
(
)
;
return
NS_OK
;
}
private
:
RefPtr
<
Document
>
mDoc
;
}
;
void
Document
:
:
PostUnblockOnloadEvent
(
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
evt
=
new
nsUnblockOnloadEvent
(
this
)
;
nsresult
rv
=
Dispatch
(
evt
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
+
+
mOnloadBlockCount
;
}
else
{
NS_WARNING
(
"
failed
to
dispatch
nsUnblockOnloadEvent
"
)
;
}
}
void
Document
:
:
DoUnblockOnload
(
)
{
MOZ_ASSERT
(
!
mDisplayDocument
"
Shouldn
'
t
get
here
for
resource
document
"
)
;
MOZ_ASSERT
(
mOnloadBlockCount
!
=
0
"
Shouldn
'
t
have
a
count
of
zero
here
since
we
stabilized
in
"
"
PostUnblockOnloadEvent
"
)
;
-
-
mOnloadBlockCount
;
if
(
mOnloadBlockCount
!
=
0
)
{
return
;
}
if
(
mScriptGlobalObject
)
{
if
(
nsCOMPtr
<
nsILoadGroup
>
loadGroup
=
GetDocumentLoadGroup
(
)
)
{
loadGroup
-
>
RemoveRequest
(
mOnloadBlocker
nullptr
NS_OK
)
;
}
}
}
nsIContent
*
Document
:
:
GetContentInThisDocument
(
nsIFrame
*
aFrame
)
const
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
f
)
)
{
nsIContent
*
content
=
f
-
>
GetContent
(
)
;
if
(
!
content
)
{
continue
;
}
if
(
content
-
>
OwnerDoc
(
)
=
=
this
)
{
return
content
;
}
f
=
f
-
>
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetRootFrame
(
)
;
}
return
nullptr
;
}
void
Document
:
:
DispatchPageTransition
(
EventTarget
*
aDispatchTarget
const
nsAString
&
aType
bool
aInFrameSwap
bool
aPersisted
bool
aOnlySystemGroup
)
{
if
(
!
aDispatchTarget
)
{
return
;
}
PageTransitionEventInit
init
;
init
.
mBubbles
=
true
;
init
.
mCancelable
=
true
;
init
.
mPersisted
=
aPersisted
;
init
.
mInFrameSwap
=
aInFrameSwap
;
RefPtr
<
PageTransitionEvent
>
event
=
PageTransitionEvent
:
:
Constructor
(
this
aType
init
)
;
event
-
>
SetTrusted
(
true
)
;
event
-
>
SetTarget
(
this
)
;
if
(
aOnlySystemGroup
)
{
event
-
>
WidgetEventPtr
(
)
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
=
true
;
}
EventDispatcher
:
:
DispatchDOMEvent
(
aDispatchTarget
nullptr
event
nullptr
nullptr
)
;
}
void
Document
:
:
OnPageShow
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
)
{
if
(
MOZ_LOG_TEST
(
gSHIPBFCacheLog
LogLevel
:
:
Debug
)
)
{
nsCString
uri
;
if
(
GetDocumentURI
(
)
)
{
uri
=
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
}
MOZ_LOG
(
gSHIPBFCacheLog
LogLevel
:
:
Debug
(
"
Document
:
:
OnPageShow
[
%
s
]
persisted
=
%
i
"
uri
.
get
(
)
aPersisted
)
)
;
}
const
bool
inFrameLoaderSwap
=
!
!
aDispatchStartTarget
;
MOZ_DIAGNOSTIC_ASSERT
(
inFrameLoaderSwap
=
=
(
mDocumentContainer
&
&
mDocumentContainer
-
>
InFrameSwap
(
)
)
)
;
Element
*
root
=
GetRootElement
(
)
;
if
(
aPersisted
&
&
root
)
{
RefPtr
<
nsContentList
>
links
=
NS_GetContentList
(
root
kNameSpaceID_XHTML
u
"
link
"
_ns
)
;
uint32_t
linkCount
=
links
-
>
Length
(
true
)
;
for
(
uint32_t
i
=
0
;
i
<
linkCount
;
+
+
i
)
{
static_cast
<
HTMLLinkElement
*
>
(
links
-
>
Item
(
i
false
)
)
-
>
LinkAdded
(
)
;
}
}
if
(
!
inFrameLoaderSwap
)
{
if
(
aPersisted
)
{
ImageTracker
(
)
-
>
SetAnimatingState
(
true
)
;
}
mIsShowing
=
true
;
mVisible
=
true
;
UpdateVisibilityState
(
)
;
}
NotifyActivityChanged
(
)
;
auto
notifyExternal
=
[
aPersisted
]
(
Document
&
aExternalResource
)
{
aExternalResource
.
OnPageShow
(
aPersisted
nullptr
)
;
return
CallState
:
:
Continue
;
}
;
EnumerateExternalResources
(
notifyExternal
)
;
if
(
mAnimationController
)
{
mAnimationController
-
>
OnPageShow
(
)
;
}
if
(
!
mIsBeingUsedAsImage
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
this
)
principal
-
>
IsSystemPrincipal
(
)
?
"
chrome
-
page
-
shown
"
:
"
content
-
page
-
shown
"
nullptr
)
;
}
nsCOMPtr
<
EventTarget
>
target
=
aDispatchStartTarget
;
if
(
!
target
)
{
target
=
do_QueryInterface
(
GetWindow
(
)
)
;
}
DispatchPageTransition
(
target
u
"
pageshow
"
_ns
inFrameLoaderSwap
aPersisted
aOnlySystemGroup
)
;
}
}
static
void
DispatchFullscreenChange
(
Document
&
aDocument
nsINode
*
aTarget
)
{
if
(
nsPresContext
*
presContext
=
aDocument
.
GetPresContext
(
)
)
{
auto
pendingEvent
=
MakeUnique
<
PendingFullscreenEvent
>
(
FullscreenEventType
:
:
Change
&
aDocument
aTarget
)
;
presContext
-
>
RefreshDriver
(
)
-
>
ScheduleFullscreenEvent
(
std
:
:
move
(
pendingEvent
)
)
;
}
}
void
Document
:
:
OnPageHide
(
bool
aPersisted
EventTarget
*
aDispatchStartTarget
bool
aOnlySystemGroup
)
{
if
(
MOZ_LOG_TEST
(
gSHIPBFCacheLog
LogLevel
:
:
Debug
)
)
{
nsCString
uri
;
if
(
GetDocumentURI
(
)
)
{
uri
=
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
;
}
MOZ_LOG
(
gSHIPBFCacheLog
LogLevel
:
:
Debug
(
"
Document
:
:
OnPageHide
%
s
persisted
=
%
i
"
uri
.
get
(
)
aPersisted
)
)
;
}
const
bool
inFrameLoaderSwap
=
!
!
aDispatchStartTarget
;
MOZ_DIAGNOSTIC_ASSERT
(
inFrameLoaderSwap
=
=
(
mDocumentContainer
&
&
mDocumentContainer
-
>
InFrameSwap
(
)
)
)
;
if
(
mAnimationController
)
{
mAnimationController
-
>
OnPageHide
(
)
;
}
if
(
!
inFrameLoaderSwap
)
{
if
(
aPersisted
)
{
ImageTracker
(
)
-
>
SetAnimatingState
(
false
)
;
}
mIsShowing
=
false
;
mVisible
=
false
;
}
ExitPointerLock
(
)
;
if
(
!
mIsBeingUsedAsImage
)
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
this
)
principal
-
>
IsSystemPrincipal
(
)
?
"
chrome
-
page
-
hidden
"
:
"
content
-
page
-
hidden
"
nullptr
)
;
}
nsCOMPtr
<
EventTarget
>
target
=
aDispatchStartTarget
;
if
(
!
target
)
{
target
=
do_QueryInterface
(
GetWindow
(
)
)
;
}
{
PageUnloadingEventTimeStamp
timeStamp
(
this
)
;
DispatchPageTransition
(
target
u
"
pagehide
"
_ns
inFrameLoaderSwap
aPersisted
aOnlySystemGroup
)
;
}
}
if
(
!
inFrameLoaderSwap
)
{
UpdateVisibilityState
(
)
;
}
auto
notifyExternal
=
[
aPersisted
]
(
Document
&
aExternalResource
)
{
aExternalResource
.
OnPageHide
(
aPersisted
nullptr
)
;
return
CallState
:
:
Continue
;
}
;
EnumerateExternalResources
(
notifyExternal
)
;
NotifyActivityChanged
(
)
;
ClearPendingFullscreenRequests
(
this
)
;
if
(
Fullscreen
(
)
)
{
Document
:
:
ExitFullscreenInDocTree
(
this
)
;
CleanupFullscreenState
(
)
;
}
}
void
Document
:
:
WillDispatchMutationEvent
(
nsINode
*
aTarget
)
{
NS_ASSERTION
(
mSubtreeModifiedDepth
!
=
0
|
|
mSubtreeModifiedTargets
.
Count
(
)
=
=
0
"
mSubtreeModifiedTargets
not
cleared
after
dispatching
?
"
)
;
+
+
mSubtreeModifiedDepth
;
if
(
aTarget
)
{
int32_t
count
=
mSubtreeModifiedTargets
.
Count
(
)
;
if
(
!
count
|
|
mSubtreeModifiedTargets
[
count
-
1
]
!
=
aTarget
)
{
mSubtreeModifiedTargets
.
AppendObject
(
aTarget
)
;
}
}
}
void
Document
:
:
MutationEventDispatched
(
nsINode
*
aTarget
)
{
if
(
-
-
mSubtreeModifiedDepth
)
{
return
;
}
int32_t
count
=
mSubtreeModifiedTargets
.
Count
(
)
;
if
(
!
count
)
{
return
;
}
nsPIDOMWindowInner
*
window
=
GetInnerWindow
(
)
;
if
(
window
&
&
!
window
-
>
HasMutationListeners
(
NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED
)
)
{
mSubtreeModifiedTargets
.
Clear
(
)
;
return
;
}
nsCOMArray
<
nsINode
>
realTargets
;
for
(
nsINode
*
possibleTarget
:
mSubtreeModifiedTargets
)
{
if
(
possibleTarget
-
>
ChromeOnlyAccess
(
)
)
{
continue
;
}
nsINode
*
commonAncestor
=
nullptr
;
int32_t
realTargetCount
=
realTargets
.
Count
(
)
;
for
(
int32_t
j
=
0
;
j
<
realTargetCount
;
+
+
j
)
{
commonAncestor
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
possibleTarget
realTargets
[
j
]
)
;
if
(
commonAncestor
)
{
realTargets
.
ReplaceObjectAt
(
commonAncestor
j
)
;
break
;
}
}
if
(
!
commonAncestor
)
{
realTargets
.
AppendObject
(
possibleTarget
)
;
}
}
mSubtreeModifiedTargets
.
Clear
(
)
;
for
(
const
nsCOMPtr
<
nsINode
>
&
target
:
realTargets
)
{
InternalMutationEvent
mutation
(
true
eLegacySubtreeModified
)
;
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
MOZ_KnownLive
(
*
target
)
mutation
)
;
}
}
void
Document
:
:
DestroyElementMaps
(
)
{
#
ifdef
DEBUG
mStyledLinksCleared
=
true
;
#
endif
mStyledLinks
.
Clear
(
)
;
for
(
auto
iter
=
mIdentifierMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Get
(
)
-
>
ClearAndNotify
(
)
;
}
mIdentifierMap
.
Clear
(
)
;
mComposedShadowRoots
.
Clear
(
)
;
mResponsiveContent
.
Clear
(
)
;
IncrementExpandoGeneration
(
*
this
)
;
}
void
Document
:
:
RefreshLinkHrefs
(
)
{
const
nsTArray
<
Link
*
>
linksToNotify
=
ToArray
(
mStyledLinks
)
;
nsAutoScriptBlocker
scriptBlocker
;
for
(
Link
*
link
:
linksToNotify
)
{
link
-
>
ResetLinkState
(
true
)
;
}
}
nsresult
Document
:
:
CloneDocHelper
(
Document
*
clone
)
const
{
clone
-
>
mIsStaticDocument
=
mCreatingStaticClone
;
nsresult
rv
=
clone
-
>
Init
(
NodePrincipal
(
)
mPartitionedPrincipal
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
mCreatingStaticClone
)
{
if
(
mOriginalDocument
)
{
clone
-
>
mOriginalDocument
=
mOriginalDocument
;
}
else
{
clone
-
>
mOriginalDocument
=
const_cast
<
Document
*
>
(
this
)
;
}
clone
-
>
mOriginalDocument
-
>
mLatestStaticClone
=
clone
;
clone
-
>
mOriginalDocument
-
>
mStaticCloneCount
+
+
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
nsCOMPtr
<
nsIDocumentLoader
>
docLoader
(
mDocumentContainer
)
;
if
(
docLoader
)
{
docLoader
-
>
GetLoadGroup
(
getter_AddRefs
(
loadGroup
)
)
;
}
nsCOMPtr
<
nsIChannel
>
channel
=
GetChannel
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
if
(
channel
)
{
NS_GetFinalChannelURI
(
channel
getter_AddRefs
(
uri
)
)
;
}
else
{
uri
=
Document
:
:
GetDocumentURI
(
)
;
}
clone
-
>
mChannel
=
channel
;
clone
-
>
mShouldResistFingerprinting
=
mShouldResistFingerprinting
;
if
(
uri
)
{
clone
-
>
ResetToURI
(
uri
loadGroup
NodePrincipal
(
)
mPartitionedPrincipal
)
;
}
clone
-
>
mIsSrcdocDocument
=
mIsSrcdocDocument
;
clone
-
>
SetContainer
(
mDocumentContainer
)
;
MOZ_ASSERT
(
!
clone
-
>
GetNavigationTiming
(
)
"
Navigation
time
was
already
set
?
"
)
;
if
(
mTiming
)
{
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mTiming
-
>
CloneNavigationTime
(
nsDocShell
:
:
Cast
(
clone
-
>
GetDocShell
(
)
)
)
;
clone
-
>
SetNavigationTiming
(
timing
)
;
}
clone
-
>
SetCsp
(
mCSP
)
;
}
clone
-
>
SetDocumentURI
(
Document
:
:
GetDocumentURI
(
)
)
;
clone
-
>
SetChromeXHRDocURI
(
mChromeXHRDocURI
)
;
clone
-
>
mActiveStoragePrincipal
=
mActiveStoragePrincipal
;
clone
-
>
mActiveCookiePrincipal
=
mActiveCookiePrincipal
;
clone
-
>
mDocumentBaseURI
=
GetDocBaseURI
(
)
;
clone
-
>
SetChromeXHRDocBaseURI
(
mChromeXHRDocBaseURI
)
;
clone
-
>
mReferrerInfo
=
static_cast
<
dom
:
:
ReferrerInfo
*
>
(
mReferrerInfo
.
get
(
)
)
-
>
Clone
(
)
;
clone
-
>
mPreloadReferrerInfo
=
clone
-
>
mReferrerInfo
;
bool
hasHadScriptObject
=
true
;
nsIScriptGlobalObject
*
scriptObject
=
GetScriptHandlingObject
(
hasHadScriptObject
)
;
NS_ENSURE_STATE
(
scriptObject
|
|
!
hasHadScriptObject
)
;
if
(
mCreatingStaticClone
)
{
clone
-
>
mHasHadScriptHandlingObject
=
true
;
}
else
if
(
scriptObject
)
{
clone
-
>
SetScriptHandlingObject
(
scriptObject
)
;
}
else
{
clone
-
>
SetScopeObject
(
GetScopeObject
(
)
)
;
}
clone
-
>
SetLoadedAsData
(
true
!
mCreatingStaticClone
)
;
clone
-
>
mCharacterSet
=
mCharacterSet
;
clone
-
>
mCharacterSetSource
=
mCharacterSetSource
;
clone
-
>
SetCompatibilityMode
(
mCompatMode
)
;
clone
-
>
mBidiOptions
=
mBidiOptions
;
clone
-
>
mContentLanguage
=
mContentLanguage
;
clone
-
>
SetContentType
(
GetContentTypeInternal
(
)
)
;
clone
-
>
mSecurityInfo
=
mSecurityInfo
;
clone
-
>
mType
=
mType
;
clone
-
>
mXMLDeclarationBits
=
mXMLDeclarationBits
;
clone
-
>
mBaseTarget
=
mBaseTarget
;
return
NS_OK
;
}
void
Document
:
:
NotifyLoading
(
bool
aNewParentIsLoading
const
ReadyState
&
aCurrentState
ReadyState
aNewState
)
{
bool
was_loading
=
mAncestorIsLoading
|
|
aCurrentState
=
=
READYSTATE_LOADING
|
|
aCurrentState
=
=
READYSTATE_INTERACTIVE
;
bool
is_loading
=
aNewParentIsLoading
|
|
aNewState
=
=
READYSTATE_LOADING
|
|
aNewState
=
=
READYSTATE_INTERACTIVE
;
bool
set_load_state
=
was_loading
!
=
is_loading
;
MOZ_LOG
(
gTimeoutDeferralLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
NotifyLoading
for
doc
%
p
:
currentAncestor
:
%
d
newParent
:
%
d
"
"
currentState
%
d
newState
:
%
d
was_loading
:
%
d
is_loading
:
%
d
"
"
set_load_state
:
%
d
"
(
void
*
)
this
mAncestorIsLoading
aNewParentIsLoading
(
int
)
aCurrentState
(
int
)
aNewState
was_loading
is_loading
set_load_state
)
)
;
mAncestorIsLoading
=
aNewParentIsLoading
;
if
(
set_load_state
&
&
StaticPrefs
:
:
dom_timeout_defer_during_load
(
)
)
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
inner
)
{
inner
-
>
SetActiveLoadingState
(
is_loading
)
;
}
BrowsingContext
*
context
=
GetBrowsingContext
(
)
;
if
(
context
)
{
for
(
auto
&
child
:
context
-
>
Children
(
)
)
{
MOZ_LOG
(
gTimeoutDeferralLog
mozilla
:
:
LogLevel
:
:
Debug
(
"
bc
:
%
p
SetAncestorLoading
(
%
d
)
"
(
void
*
)
child
is_loading
)
)
;
Unused
<
<
child
-
>
SetAncestorLoading
(
is_loading
)
;
}
}
}
}
void
Document
:
:
SetReadyStateInternal
(
ReadyState
aReadyState
bool
aUpdateTimingInformation
)
{
if
(
aReadyState
=
=
READYSTATE_UNINITIALIZED
)
{
mReadyState
=
aReadyState
;
return
;
}
if
(
IsTopLevelContentDocument
(
)
)
{
if
(
aReadyState
=
=
READYSTATE_LOADING
)
{
AddToplevelLoadingDocument
(
this
)
;
}
else
if
(
aReadyState
=
=
READYSTATE_COMPLETE
)
{
RemoveToplevelLoadingDocument
(
this
)
;
}
}
if
(
aUpdateTimingInformation
&
&
READYSTATE_LOADING
=
=
aReadyState
)
{
SetLoadingOrRestoredFromBFCacheTimeStampToNow
(
)
;
}
NotifyLoading
(
mAncestorIsLoading
mReadyState
aReadyState
)
;
mReadyState
=
aReadyState
;
if
(
aUpdateTimingInformation
&
&
mTiming
)
{
switch
(
aReadyState
)
{
case
READYSTATE_LOADING
:
mTiming
-
>
NotifyDOMLoading
(
GetDocumentURI
(
)
)
;
break
;
case
READYSTATE_INTERACTIVE
:
mTiming
-
>
NotifyDOMInteractive
(
GetDocumentURI
(
)
)
;
break
;
case
READYSTATE_COMPLETE
:
mTiming
-
>
NotifyDOMComplete
(
GetDocumentURI
(
)
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
ReadyState
value
"
)
;
break
;
}
}
if
(
READYSTATE_INTERACTIVE
=
=
aReadyState
&
&
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
if
(
!
mXULPersist
)
{
mXULPersist
=
new
XULPersist
(
this
)
;
mXULPersist
-
>
Init
(
)
;
}
if
(
!
mChromeObserver
)
{
mChromeObserver
=
new
ChromeObserver
(
this
)
;
mChromeObserver
-
>
Init
(
)
;
}
}
if
(
aUpdateTimingInformation
)
{
RecordNavigationTiming
(
aReadyState
)
;
}
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
*
this
u
"
readystatechange
"
_ns
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eNo
)
;
}
void
Document
:
:
GetReadyState
(
nsAString
&
aReadyState
)
const
{
switch
(
mReadyState
)
{
case
READYSTATE_LOADING
:
aReadyState
.
AssignLiteral
(
u
"
loading
"
)
;
break
;
case
READYSTATE_INTERACTIVE
:
aReadyState
.
AssignLiteral
(
u
"
interactive
"
)
;
break
;
case
READYSTATE_COMPLETE
:
aReadyState
.
AssignLiteral
(
u
"
complete
"
)
;
break
;
default
:
aReadyState
.
AssignLiteral
(
u
"
uninitialized
"
)
;
}
}
void
Document
:
:
SuppressEventHandling
(
uint32_t
aIncrease
)
{
mEventsSuppressed
+
=
aIncrease
;
if
(
mEventsSuppressed
=
=
aIncrease
)
{
if
(
WindowGlobalChild
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
BlockBFCacheFor
(
BFCacheStatus
:
:
EVENT_HANDLING_SUPPRESSED
)
;
}
}
UpdateFrameRequestCallbackSchedulingState
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aIncrease
;
+
+
i
)
{
ScriptLoader
(
)
-
>
AddExecuteBlocker
(
)
;
}
auto
suppressInSubDoc
=
[
aIncrease
]
(
Document
&
aSubDoc
)
{
aSubDoc
.
SuppressEventHandling
(
aIncrease
)
;
return
CallState
:
:
Continue
;
}
;
EnumerateSubDocuments
(
suppressInSubDoc
)
;
}
void
Document
:
:
NotifyAbortedLoad
(
)
{
if
(
mBlockDOMContentLoaded
>
0
&
&
!
mDidFireDOMContentLoaded
)
{
mSetCompleteAfterDOMContentLoaded
=
true
;
return
;
}
if
(
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_INTERACTIVE
)
{
SetReadyStateInternal
(
Document
:
:
READYSTATE_COMPLETE
)
;
}
}
MOZ_CAN_RUN_SCRIPT
static
void
FireOrClearDelayedEvents
(
nsTArray
<
nsCOMPtr
<
Document
>
>
&
&
aDocuments
bool
aFireEvents
)
{
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
MOZ_UNLIKELY
(
!
fm
)
)
{
return
;
}
nsTArray
<
nsCOMPtr
<
Document
>
>
documents
=
std
:
:
move
(
aDocuments
)
;
for
(
uint32_t
i
=
0
;
i
<
documents
.
Length
(
)
;
+
+
i
)
{
nsCOMPtr
<
Document
>
document
=
std
:
:
move
(
documents
[
i
]
)
;
if
(
!
document
-
>
EventHandlingSuppressed
(
)
)
{
fm
-
>
FireDelayedEvents
(
document
)
;
RefPtr
<
PresShell
>
presShell
=
document
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
bool
fire
=
aFireEvents
&
&
document
-
>
GetInnerWindow
(
)
&
&
document
-
>
GetInnerWindow
(
)
-
>
IsCurrentInnerWindow
(
)
;
presShell
-
>
FireOrClearDelayedEvents
(
fire
)
;
}
document
-
>
FireOrClearPostMessageEvents
(
aFireEvents
)
;
}
}
}
void
Document
:
:
PreloadPictureClosed
(
)
{
MOZ_ASSERT
(
mPreloadPictureDepth
>
0
)
;
mPreloadPictureDepth
-
-
;
if
(
mPreloadPictureDepth
=
=
0
)
{
mPreloadPictureFoundSource
.
SetIsVoid
(
true
)
;
}
}
void
Document
:
:
PreloadPictureImageSource
(
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
const
nsAString
&
aTypeAttr
const
nsAString
&
aMediaAttr
)
{
if
(
mPreloadPictureDepth
=
=
1
&
&
mPreloadPictureFoundSource
.
IsVoid
(
)
)
{
bool
found
=
HTMLImageElement
:
:
SelectSourceForTagWithAttrs
(
this
true
VoidString
(
)
aSrcsetAttr
aSizesAttr
aTypeAttr
aMediaAttr
mPreloadPictureFoundSource
)
;
if
(
found
&
&
mPreloadPictureFoundSource
.
IsVoid
(
)
)
{
mPreloadPictureFoundSource
.
SetIsVoid
(
false
)
;
}
}
}
already_AddRefed
<
nsIURI
>
Document
:
:
ResolvePreloadImage
(
nsIURI
*
aBaseURI
const
nsAString
&
aSrcAttr
const
nsAString
&
aSrcsetAttr
const
nsAString
&
aSizesAttr
bool
*
aIsImgSet
)
{
nsString
sourceURL
;
bool
isImgSet
;
if
(
mPreloadPictureDepth
=
=
1
&
&
!
mPreloadPictureFoundSource
.
IsVoid
(
)
)
{
sourceURL
=
mPreloadPictureFoundSource
;
isImgSet
=
true
;
}
else
{
HTMLImageElement
:
:
SelectSourceForTagWithAttrs
(
this
false
aSrcAttr
aSrcsetAttr
aSizesAttr
VoidString
(
)
VoidString
(
)
sourceURL
)
;
isImgSet
=
!
aSrcsetAttr
.
IsEmpty
(
)
;
}
if
(
sourceURL
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsresult
rv
;
nsCOMPtr
<
nsIURI
>
uri
;
rv
=
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
uri
)
sourceURL
this
aBaseURI
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
*
aIsImgSet
=
isImgSet
;
return
uri
.
forget
(
)
;
}
void
Document
:
:
PreLoadImage
(
nsIURI
*
aUri
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
bool
aIsImgSet
bool
aLinkPreload
uint64_t
aEarlyHintPreloaderId
)
{
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
|
nsContentUtils
:
:
CORSModeToLoadImageFlags
(
Element
:
:
StringToCORSMode
(
aCrossOriginAttr
)
)
;
nsContentPolicyType
policyType
=
aIsImgSet
?
nsIContentPolicy
:
:
TYPE_IMAGESET
:
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_PRELOAD
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateFromDocumentAndPolicyOverride
(
this
aReferrerPolicy
)
;
RefPtr
<
imgRequestProxy
>
request
;
nsLiteralString
initiator
=
aEarlyHintPreloaderId
?
u
"
early
-
hints
"
_ns
:
(
aLinkPreload
?
u
"
link
"
_ns
:
u
"
img
"
_ns
)
;
nsresult
rv
=
nsContentUtils
:
:
LoadImage
(
aUri
static_cast
<
nsINode
*
>
(
this
)
this
NodePrincipal
(
)
0
referrerInfo
nullptr
loadFlags
initiator
getter_AddRefs
(
request
)
policyType
false
aLinkPreload
aEarlyHintPreloaderId
)
;
if
(
!
aLinkPreload
&
&
NS_SUCCEEDED
(
rv
)
)
{
mPreloadingImages
.
InsertOrUpdate
(
aUri
std
:
:
move
(
request
)
)
;
}
}
void
Document
:
:
MaybePreLoadImage
(
nsIURI
*
aUri
const
nsAString
&
aCrossOriginAttr
ReferrerPolicyEnum
aReferrerPolicy
bool
aIsImgSet
bool
aLinkPreload
)
{
const
CORSMode
corsMode
=
dom
:
:
Element
:
:
StringToCORSMode
(
aCrossOriginAttr
)
;
if
(
aLinkPreload
)
{
PreloadHashKey
key
=
PreloadHashKey
:
:
CreateAsImage
(
aUri
NodePrincipal
(
)
corsMode
)
;
if
(
!
mPreloadService
.
PreloadExists
(
key
)
)
{
PreLoadImage
(
aUri
aCrossOriginAttr
aReferrerPolicy
aIsImgSet
aLinkPreload
0
)
;
}
return
;
}
if
(
nsContentUtils
:
:
IsImageAvailable
(
aUri
NodePrincipal
(
)
corsMode
this
)
)
{
return
;
}
PreLoadImage
(
aUri
aCrossOriginAttr
aReferrerPolicy
aIsImgSet
aLinkPreload
0
)
;
}
void
Document
:
:
MaybePreconnect
(
nsIURI
*
aOrigURI
mozilla
:
:
CORSMode
aCORSMode
)
{
if
(
!
StaticPrefs
:
:
network_preconnect
(
)
)
{
return
;
}
NS_MutateURI
mutator
(
aOrigURI
)
;
if
(
NS_FAILED
(
mutator
.
GetStatus
(
)
)
)
{
return
;
}
if
(
aCORSMode
=
=
CORS_ANONYMOUS
)
{
mutator
.
SetPathQueryRef
(
"
/
anonymous
"
_ns
)
;
}
else
{
mutator
.
SetPathQueryRef
(
"
/
"
_ns
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
=
mutator
.
Finalize
(
uri
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
const
bool
existingEntryFound
=
mPreloadedPreconnects
.
WithEntryHandle
(
uri
[
]
(
auto
&
&
entry
)
{
if
(
entry
)
{
return
true
;
}
entry
.
Insert
(
true
)
;
return
false
;
}
)
;
if
(
existingEntryFound
)
{
return
;
}
nsCOMPtr
<
nsISpeculativeConnect
>
speculator
=
mozilla
:
:
components
:
:
IO
:
:
Service
(
)
;
if
(
!
speculator
)
{
return
;
}
OriginAttributes
oa
;
StoragePrincipalHelper
:
:
GetOriginAttributesForNetworkState
(
this
oa
)
;
speculator
-
>
SpeculativeConnectWithOriginAttributesNative
(
uri
std
:
:
move
(
oa
)
nullptr
aCORSMode
=
=
CORS_ANONYMOUS
)
;
}
void
Document
:
:
ForgetImagePreload
(
nsIURI
*
aURI
)
{
if
(
mPreloadingImages
.
Count
(
)
!
=
0
)
{
nsCOMPtr
<
imgIRequest
>
req
;
mPreloadingImages
.
Remove
(
aURI
getter_AddRefs
(
req
)
)
;
if
(
req
)
{
req
-
>
CancelAndForgetObserver
(
NS_BINDING_ABORTED
)
;
}
}
}
void
Document
:
:
UpdateDocumentStates
(
DocumentState
aMaybeChangedStates
bool
aNotify
)
{
const
DocumentState
oldStates
=
mState
;
if
(
aMaybeChangedStates
.
HasAtLeastOneOfStates
(
DocumentState
:
:
ALL_LOCALEDIR_BITS
)
)
{
mState
&
=
~
DocumentState
:
:
ALL_LOCALEDIR_BITS
;
if
(
IsDocumentRightToLeft
(
)
)
{
mState
|
=
DocumentState
:
:
RTL_LOCALE
;
}
else
{
mState
|
=
DocumentState
:
:
LTR_LOCALE
;
}
}
if
(
aMaybeChangedStates
.
HasAtLeastOneOfStates
(
DocumentState
:
:
LWTHEME
)
)
{
if
(
ComputeDocumentLWTheme
(
)
)
{
mState
|
=
DocumentState
:
:
LWTHEME
;
}
else
{
mState
&
=
~
DocumentState
:
:
LWTHEME
;
}
}
if
(
aMaybeChangedStates
.
HasState
(
DocumentState
:
:
WINDOW_INACTIVE
)
)
{
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
|
|
!
bc
-
>
GetIsActiveBrowserWindow
(
)
)
{
mState
|
=
DocumentState
:
:
WINDOW_INACTIVE
;
}
else
{
mState
&
=
~
DocumentState
:
:
WINDOW_INACTIVE
;
}
}
const
DocumentState
changedStates
=
oldStates
^
mState
;
if
(
aNotify
&
&
!
changedStates
.
IsEmpty
(
)
)
{
if
(
PresShell
*
ps
=
GetObservingPresShell
(
)
)
{
ps
-
>
DocumentStatesChanged
(
changedStates
)
;
}
}
}
namespace
{
class
StubCSSLoaderObserver
final
:
public
nsICSSLoaderObserver
{
~
StubCSSLoaderObserver
(
)
=
default
;
public
:
NS_IMETHOD
StyleSheetLoaded
(
StyleSheet
*
bool
nsresult
)
override
{
return
NS_OK
;
}
NS_DECL_ISUPPORTS
}
;
NS_IMPL_ISUPPORTS
(
StubCSSLoaderObserver
nsICSSLoaderObserver
)
}
SheetPreloadStatus
Document
:
:
PreloadStyle
(
nsIURI
*
uri
const
Encoding
*
aEncoding
const
nsAString
&
aCrossOriginAttr
const
enum
ReferrerPolicy
aReferrerPolicy
const
nsAString
&
aNonce
const
nsAString
&
aIntegrity
css
:
:
StylePreloadKind
aKind
uint64_t
aEarlyHintPreloaderId
)
{
MOZ_ASSERT
(
aKind
!
=
css
:
:
StylePreloadKind
:
:
None
)
;
nsCOMPtr
<
nsICSSLoaderObserver
>
obs
=
new
StubCSSLoaderObserver
(
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateFromDocumentAndPolicyOverride
(
this
aReferrerPolicy
)
;
auto
result
=
CSSLoader
(
)
-
>
LoadSheet
(
uri
aKind
aEncoding
referrerInfo
obs
aEarlyHintPreloaderId
Element
:
:
StringToCORSMode
(
aCrossOriginAttr
)
aNonce
aIntegrity
)
;
if
(
result
.
isErr
(
)
)
{
return
SheetPreloadStatus
:
:
Errored
;
}
RefPtr
<
StyleSheet
>
sheet
=
result
.
unwrap
(
)
;
if
(
sheet
-
>
IsComplete
(
)
)
{
return
SheetPreloadStatus
:
:
AlreadyComplete
;
}
return
SheetPreloadStatus
:
:
InProgress
;
}
RefPtr
<
StyleSheet
>
Document
:
:
LoadChromeSheetSync
(
nsIURI
*
uri
)
{
return
CSSLoader
(
)
-
>
LoadSheetSync
(
uri
css
:
:
eAuthorSheetFeatures
)
.
unwrapOr
(
nullptr
)
;
}
void
Document
:
:
ResetDocumentDirection
(
)
{
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
this
)
)
{
return
;
}
UpdateDocumentStates
(
DocumentState
:
:
ALL_LOCALEDIR_BITS
true
)
;
}
bool
Document
:
:
IsDocumentRightToLeft
(
)
{
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
this
)
)
{
return
false
;
}
Element
*
element
=
GetRootElement
(
)
;
if
(
element
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
ltr
nsGkAtoms
:
:
rtl
nullptr
}
;
switch
(
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
localedir
strings
eCaseMatters
)
)
{
case
0
:
return
false
;
case
1
:
return
true
;
default
:
break
;
}
}
if
(
!
mDocumentURI
-
>
SchemeIs
(
"
chrome
"
)
&
&
!
mDocumentURI
-
>
SchemeIs
(
"
about
"
)
&
&
!
mDocumentURI
-
>
SchemeIs
(
"
resource
"
)
)
{
return
false
;
}
return
intl
:
:
LocaleService
:
:
GetInstance
(
)
-
>
IsAppLocaleRTL
(
)
;
}
class
nsDelayedEventDispatcher
:
public
Runnable
{
public
:
explicit
nsDelayedEventDispatcher
(
nsTArray
<
nsCOMPtr
<
Document
>
>
&
&
aDocuments
)
:
mozilla
:
:
Runnable
(
"
nsDelayedEventDispatcher
"
)
mDocuments
(
std
:
:
move
(
aDocuments
)
)
{
}
virtual
~
nsDelayedEventDispatcher
(
)
=
default
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
FireOrClearDelayedEvents
(
std
:
:
move
(
mDocuments
)
true
)
;
return
NS_OK
;
}
private
:
nsTArray
<
nsCOMPtr
<
Document
>
>
mDocuments
;
}
;
static
void
GetAndUnsuppressSubDocuments
(
Document
&
aDocument
nsTArray
<
nsCOMPtr
<
Document
>
>
&
aDocuments
)
{
if
(
aDocument
.
EventHandlingSuppressed
(
)
>
0
)
{
aDocument
.
DecreaseEventSuppression
(
)
;
aDocument
.
ScriptLoader
(
)
-
>
RemoveExecuteBlocker
(
)
;
}
aDocuments
.
AppendElement
(
&
aDocument
)
;
auto
recurse
=
[
&
aDocuments
]
(
Document
&
aSubDoc
)
{
GetAndUnsuppressSubDocuments
(
aSubDoc
aDocuments
)
;
return
CallState
:
:
Continue
;
}
;
aDocument
.
EnumerateSubDocuments
(
recurse
)
;
}
void
Document
:
:
UnsuppressEventHandlingAndFireEvents
(
bool
aFireEvents
)
{
nsTArray
<
nsCOMPtr
<
Document
>
>
documents
;
GetAndUnsuppressSubDocuments
(
*
this
documents
)
;
for
(
nsCOMPtr
<
Document
>
&
doc
:
documents
)
{
if
(
!
doc
-
>
EventHandlingSuppressed
(
)
)
{
if
(
WindowGlobalChild
*
wgc
=
doc
-
>
GetWindowGlobalChild
(
)
)
{
wgc
-
>
UnblockBFCacheFor
(
BFCacheStatus
:
:
EVENT_HANDLING_SUPPRESSED
)
;
}
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
nsTArray
<
RefPtr
<
net
:
:
ChannelEventQueue
>
>
queues
=
std
:
:
move
(
doc
-
>
mSuspendedQueues
)
;
for
(
net
:
:
ChannelEventQueue
*
queue
:
queues
)
{
queue
-
>
Resume
(
)
;
}
if
(
doc
-
>
mHasDelayedRefreshEvent
)
{
doc
-
>
mHasDelayedRefreshEvent
=
false
;
if
(
doc
-
>
mPresShell
)
{
nsRefreshDriver
*
rd
=
doc
-
>
mPresShell
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
rd
-
>
RunDelayedEventsSoon
(
)
;
}
}
}
}
if
(
aFireEvents
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
ded
=
new
nsDelayedEventDispatcher
(
std
:
:
move
(
documents
)
)
;
Dispatch
(
ded
.
forget
(
)
)
;
}
else
{
FireOrClearDelayedEvents
(
std
:
:
move
(
documents
)
false
)
;
}
}
bool
Document
:
:
AreClipboardCommandsUnconditionallyEnabled
(
)
const
{
return
IsHTMLOrXHTML
(
)
&
&
!
nsContentUtils
:
:
IsChromeDoc
(
this
)
;
}
void
Document
:
:
AddSuspendedChannelEventQueue
(
net
:
:
ChannelEventQueue
*
aQueue
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
EventHandlingSuppressed
(
)
)
;
mSuspendedQueues
.
AppendElement
(
aQueue
)
;
}
bool
Document
:
:
SuspendPostMessageEvent
(
PostMessageEvent
*
aEvent
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
EventHandlingSuppressed
(
)
|
|
!
mSuspendedPostMessageEvents
.
IsEmpty
(
)
)
{
mSuspendedPostMessageEvents
.
AppendElement
(
aEvent
)
;
return
true
;
}
return
false
;
}
void
Document
:
:
FireOrClearPostMessageEvents
(
bool
aFireEvents
)
{
nsTArray
<
RefPtr
<
PostMessageEvent
>
>
events
=
std
:
:
move
(
mSuspendedPostMessageEvents
)
;
if
(
aFireEvents
)
{
for
(
PostMessageEvent
*
event
:
events
)
{
event
-
>
Run
(
)
;
}
}
}
void
Document
:
:
SetSuppressedEventListener
(
EventListener
*
aListener
)
{
mSuppressedEventListener
=
aListener
;
auto
setOnSubDocs
=
[
&
]
(
Document
&
aDocument
)
{
aDocument
.
SetSuppressedEventListener
(
aListener
)
;
return
CallState
:
:
Continue
;
}
;
EnumerateSubDocuments
(
setOnSubDocs
)
;
}
bool
Document
:
:
IsActive
(
)
const
{
return
mDocumentContainer
&
&
!
mRemovedFromDocShell
&
&
GetBrowsingContext
(
)
&
&
!
GetBrowsingContext
(
)
-
>
IsInBFCache
(
)
;
}
nsISupports
*
Document
:
:
GetCurrentContentSink
(
)
{
return
mParser
?
mParser
-
>
GetContentSink
(
)
:
nullptr
;
}
Document
*
Document
:
:
GetTemplateContentsOwner
(
)
{
if
(
!
mTemplateContentsOwner
)
{
bool
hasHadScriptObject
=
true
;
nsIScriptGlobalObject
*
scriptObject
=
GetScriptHandlingObject
(
hasHadScriptObject
)
;
nsCOMPtr
<
Document
>
document
;
nsresult
rv
=
NS_NewDOMDocument
(
getter_AddRefs
(
document
)
u
"
"
_ns
u
"
"
_ns
nullptr
Document
:
:
GetDocumentURI
(
)
Document
:
:
GetDocBaseURI
(
)
NodePrincipal
(
)
true
scriptObject
IsHTMLDocument
(
)
?
DocumentFlavorHTML
:
DocumentFlavorXML
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
mTemplateContentsOwner
=
document
;
NS_ENSURE_TRUE
(
mTemplateContentsOwner
nullptr
)
;
if
(
!
scriptObject
)
{
mTemplateContentsOwner
-
>
SetScopeObject
(
GetScopeObject
(
)
)
;
}
mTemplateContentsOwner
-
>
mHasHadScriptHandlingObject
=
hasHadScriptObject
;
mTemplateContentsOwner
-
>
mTemplateContentsOwner
=
mTemplateContentsOwner
;
}
MOZ_ASSERT
(
mTemplateContentsOwner
-
>
IsTemplateContentsOwner
(
)
)
;
return
mTemplateContentsOwner
;
}
void
Document
:
:
ElementWithAutoFocusInserted
(
Element
*
aAutoFocusCandidate
)
{
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
;
}
if
(
!
IsCurrentActiveDocument
(
)
)
{
return
;
}
if
(
GetSandboxFlags
(
)
&
SANDBOXED_AUTOMATIC_FEATURES
)
{
return
;
}
while
(
bc
)
{
BrowsingContext
*
parent
=
bc
-
>
GetParent
(
)
;
if
(
!
parent
)
{
break
;
}
if
(
!
parent
-
>
IsInProcess
(
)
)
{
return
;
}
Document
*
currentDocument
=
bc
-
>
GetDocument
(
)
;
if
(
!
currentDocument
)
{
return
;
}
Document
*
parentDocument
=
parent
-
>
GetDocument
(
)
;
if
(
!
parentDocument
)
{
return
;
}
if
(
!
currentDocument
-
>
NodePrincipal
(
)
-
>
Equals
(
parentDocument
-
>
NodePrincipal
(
)
)
)
{
return
;
}
bc
=
parent
;
}
MOZ_ASSERT
(
bc
-
>
IsTop
(
)
)
;
Document
*
topDocument
=
bc
-
>
GetDocument
(
)
;
MOZ_ASSERT
(
topDocument
)
;
topDocument
-
>
AppendAutoFocusCandidateToTopDocument
(
aAutoFocusCandidate
)
;
}
void
Document
:
:
ScheduleFlushAutoFocusCandidates
(
)
{
MOZ_ASSERT
(
mPresShell
&
&
mPresShell
-
>
DidInitialize
(
)
)
;
MOZ_ASSERT
(
GetBrowsingContext
(
)
-
>
IsTop
(
)
)
;
if
(
nsRefreshDriver
*
rd
=
mPresShell
-
>
GetRefreshDriver
(
)
)
{
rd
-
>
ScheduleAutoFocusFlush
(
this
)
;
}
}
void
Document
:
:
AppendAutoFocusCandidateToTopDocument
(
Element
*
aAutoFocusCandidate
)
{
MOZ_ASSERT
(
GetBrowsingContext
(
)
-
>
IsTop
(
)
)
;
if
(
mAutoFocusFired
)
{
return
;
}
if
(
!
HasAutoFocusCandidates
(
)
)
{
if
(
mPresShell
&
&
mPresShell
-
>
DidInitialize
(
)
)
{
ScheduleFlushAutoFocusCandidates
(
)
;
}
}
nsWeakPtr
element
=
do_GetWeakReference
(
aAutoFocusCandidate
)
;
mAutoFocusCandidates
.
RemoveElement
(
element
)
;
mAutoFocusCandidates
.
AppendElement
(
element
)
;
}
void
Document
:
:
SetAutoFocusFired
(
)
{
mAutoFocusCandidates
.
Clear
(
)
;
mAutoFocusFired
=
true
;
}
void
Document
:
:
FlushAutoFocusCandidates
(
)
{
MOZ_ASSERT
(
GetBrowsingContext
(
)
-
>
IsTop
(
)
)
;
if
(
mAutoFocusFired
)
{
return
;
}
if
(
!
mPresShell
)
{
return
;
}
MOZ_ASSERT
(
HasAutoFocusCandidates
(
)
)
;
MOZ_ASSERT
(
mPresShell
-
>
DidInitialize
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
GetWindow
(
)
;
if
(
!
topWindow
)
{
return
;
}
#
ifdef
DEBUG
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
top
=
topWindow
-
>
GetInProcessTop
(
)
;
MOZ_ASSERT
(
topWindow
=
=
top
)
;
}
#
endif
if
(
topWindow
-
>
GetFocusedElement
(
)
)
{
SetAutoFocusFired
(
)
;
return
;
}
MOZ_ASSERT
(
mDocumentURI
)
;
nsAutoCString
ref
;
nsresult
rv
=
mDocumentURI
-
>
GetRef
(
ref
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
nsContentUtils
:
:
GetTargetElement
(
this
NS_ConvertUTF8toUTF16
(
ref
)
)
)
{
SetAutoFocusFired
(
)
;
return
;
}
nsTObserverArray
<
nsWeakPtr
>
:
:
ForwardIterator
iter
(
mAutoFocusCandidates
)
;
while
(
iter
.
HasMore
(
)
)
{
nsCOMPtr
<
Element
>
autoFocusElement
=
do_QueryReferent
(
iter
.
GetNext
(
)
)
;
if
(
!
autoFocusElement
)
{
continue
;
}
RefPtr
<
Document
>
autoFocusElementDoc
=
autoFocusElement
-
>
OwnerDoc
(
)
;
autoFocusElementDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
if
(
!
mPresShell
)
{
return
;
}
autoFocusElementDoc
=
autoFocusElement
-
>
OwnerDoc
(
)
;
BrowsingContext
*
bc
=
autoFocusElementDoc
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
continue
;
}
if
(
!
autoFocusElementDoc
-
>
IsCurrentActiveDocument
(
)
)
{
iter
.
Remove
(
)
;
continue
;
}
nsCOMPtr
<
nsIContentSink
>
sink
=
do_QueryInterface
(
autoFocusElementDoc
-
>
GetCurrentContentSink
(
)
)
;
if
(
sink
)
{
nsHtml5TreeOpExecutor
*
executor
=
static_cast
<
nsHtml5TreeOpExecutor
*
>
(
sink
-
>
AsExecutor
(
)
)
;
if
(
executor
)
{
MOZ_ASSERT
(
autoFocusElementDoc
-
>
IsHTMLDocument
(
)
)
;
if
(
executor
-
>
WaitForPendingSheets
(
)
)
{
ScheduleFlushAutoFocusCandidates
(
)
;
return
;
}
}
}
if
(
bc
-
>
Top
(
)
-
>
GetDocument
(
)
!
=
this
)
{
continue
;
}
iter
.
Remove
(
)
;
bool
shouldFocus
=
true
;
while
(
bc
)
{
Document
*
doc
=
bc
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
shouldFocus
=
false
;
break
;
}
nsIURI
*
uri
=
doc
-
>
GetDocumentURI
(
)
;
if
(
!
uri
)
{
shouldFocus
=
false
;
break
;
}
nsAutoCString
ref
;
nsresult
rv
=
uri
-
>
GetRef
(
ref
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
nsContentUtils
:
:
GetTargetElement
(
doc
NS_ConvertUTF8toUTF16
(
ref
)
)
)
{
shouldFocus
=
false
;
break
;
}
bc
=
bc
-
>
GetParent
(
)
;
}
if
(
!
shouldFocus
)
{
continue
;
}
MOZ_ASSERT
(
topWindow
)
;
if
(
TryAutoFocusCandidate
(
*
autoFocusElement
)
)
{
SetAutoFocusFired
(
)
;
break
;
}
}
if
(
HasAutoFocusCandidates
(
)
)
{
ScheduleFlushAutoFocusCandidates
(
)
;
}
}
bool
Document
:
:
TryAutoFocusCandidate
(
Element
&
aElement
)
{
const
FocusOptions
options
;
if
(
RefPtr
<
Element
>
target
=
nsFocusManager
:
:
GetTheFocusableArea
(
&
aElement
nsFocusManager
:
:
ProgrammaticFocusFlags
(
options
)
)
)
{
target
-
>
Focus
(
options
CallerType
:
:
NonSystem
IgnoreErrors
(
)
)
;
return
true
;
}
return
false
;
}
void
Document
:
:
SetScrollToRef
(
nsIURI
*
aDocumentURI
)
{
if
(
!
aDocumentURI
)
{
return
;
}
nsAutoCString
ref
;
nsresult
rv
=
aDocumentURI
-
>
GetSpec
(
ref
)
;
if
(
NS_FAILED
(
rv
)
)
{
Unused
<
<
aDocumentURI
-
>
GetRef
(
mScrollToRef
)
;
return
;
}
nsReadingIterator
<
char
>
start
end
;
ref
.
BeginReading
(
start
)
;
ref
.
EndReading
(
end
)
;
if
(
FindCharInReadable
(
'
#
'
start
end
)
)
{
+
+
start
;
mScrollToRef
=
Substring
(
start
end
)
;
}
}
void
Document
:
:
ScrollToRef
(
)
{
if
(
mScrolledToRefAlready
)
{
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
ScrollToAnchor
(
)
;
}
return
;
}
if
(
mScrollToRef
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
NS_ConvertUTF8toUTF16
ref
(
mScrollToRef
)
;
auto
rv
=
presShell
-
>
GoToAnchor
(
ref
mChangeScrollPosWhenScrollingToRef
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mScrolledToRefAlready
=
true
;
return
;
}
nsAutoCString
fragmentBytes
;
const
bool
unescaped
=
NS_UnescapeURL
(
mScrollToRef
.
Data
(
)
mScrollToRef
.
Length
(
)
0
fragmentBytes
)
;
if
(
!
unescaped
|
|
fragmentBytes
.
IsEmpty
(
)
)
{
return
;
}
nsAutoString
decodedFragment
;
rv
=
UTF_8_ENCODING
-
>
DecodeWithoutBOMHandling
(
fragmentBytes
decodedFragment
)
;
NS_ENSURE_SUCCESS_VOID
(
rv
)
;
rv
=
presShell
-
>
GoToAnchor
(
decodedFragment
mChangeScrollPosWhenScrollingToRef
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mScrolledToRefAlready
=
true
;
}
}
void
Document
:
:
RegisterActivityObserver
(
nsISupports
*
aSupports
)
{
if
(
!
mActivityObservers
)
{
mActivityObservers
=
MakeUnique
<
nsTHashSet
<
nsISupports
*
>
>
(
)
;
}
mActivityObservers
-
>
Insert
(
aSupports
)
;
}
bool
Document
:
:
UnregisterActivityObserver
(
nsISupports
*
aSupports
)
{
if
(
!
mActivityObservers
)
{
return
false
;
}
return
mActivityObservers
-
>
EnsureRemoved
(
aSupports
)
;
}
void
Document
:
:
EnumerateActivityObservers
(
ActivityObserverEnumerator
aEnumerator
)
{
if
(
!
mActivityObservers
)
{
return
;
}
const
auto
keyArray
=
ToTArray
<
nsTArray
<
nsCOMPtr
<
nsISupports
>
>
>
(
*
mActivityObservers
)
;
for
(
auto
&
observer
:
keyArray
)
{
aEnumerator
(
observer
.
get
(
)
)
;
}
}
void
Document
:
:
RegisterPendingLinkUpdate
(
Link
*
aLink
)
{
if
(
aLink
-
>
HasPendingLinkUpdate
(
)
)
{
return
;
}
aLink
-
>
SetHasPendingLinkUpdate
(
)
;
if
(
!
mHasLinksToUpdateRunnable
&
&
!
mFlushingPendingLinkUpdates
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
(
"
Document
:
:
FlushPendingLinkUpdates
"
this
&
Document
:
:
FlushPendingLinkUpdates
)
;
nsresult
rv
=
NS_DispatchToCurrentThreadQueue
(
event
.
forget
(
)
1000
EventQueuePriority
:
:
Idle
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
mHasLinksToUpdateRunnable
=
true
;
}
mLinksToUpdate
.
InfallibleAppend
(
aLink
)
;
}
void
Document
:
:
FlushPendingLinkUpdates
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mFlushingPendingLinkUpdates
)
;
MOZ_ASSERT
(
mHasLinksToUpdateRunnable
)
;
mHasLinksToUpdateRunnable
=
false
;
auto
restore
=
MakeScopeExit
(
[
&
]
{
mFlushingPendingLinkUpdates
=
false
;
}
)
;
mFlushingPendingLinkUpdates
=
true
;
while
(
!
mLinksToUpdate
.
IsEmpty
(
)
)
{
LinksToUpdateList
links
(
std
:
:
move
(
mLinksToUpdate
)
)
;
for
(
auto
iter
=
links
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Link
*
link
=
iter
.
Get
(
)
;
Element
*
element
=
link
-
>
GetElement
(
)
;
if
(
element
-
>
OwnerDoc
(
)
=
=
this
)
{
link
-
>
ClearHasPendingLinkUpdate
(
)
;
if
(
element
-
>
IsInComposedDoc
(
)
)
{
link
-
>
TriggerLinkUpdate
(
true
)
;
}
}
}
}
}
static
nsINode
*
GetCorrespondingNodeInDocument
(
const
nsINode
*
aOrigNode
Document
&
aStaticClone
)
{
MOZ_ASSERT
(
aOrigNode
)
;
if
(
NS_WARN_IF
(
aOrigNode
-
>
IsInNativeAnonymousSubtree
(
)
)
)
{
return
nullptr
;
}
if
(
NS_WARN_IF
(
!
aOrigNode
-
>
IsInComposedDoc
(
)
)
)
{
return
nullptr
;
}
AutoTArray
<
Maybe
<
uint32_t
>
32
>
indexArray
;
const
nsINode
*
current
=
aOrigNode
;
while
(
const
nsINode
*
parent
=
current
-
>
GetParentNode
(
)
)
{
Maybe
<
uint32_t
>
index
=
parent
-
>
ComputeIndexOf
(
current
)
;
NS_ENSURE_TRUE
(
index
.
isSome
(
)
nullptr
)
;
indexArray
.
AppendElement
(
std
:
:
move
(
index
)
)
;
current
=
parent
;
}
MOZ_ASSERT
(
current
-
>
IsDocument
(
)
|
|
current
-
>
IsShadowRoot
(
)
)
;
nsINode
*
correspondingNode
=
[
&
]
(
)
-
>
nsINode
*
{
if
(
current
-
>
IsDocument
(
)
)
{
return
&
aStaticClone
;
}
const
auto
*
shadow
=
ShadowRoot
:
:
FromNode
(
*
current
)
;
if
(
!
shadow
)
{
return
nullptr
;
}
nsINode
*
correspondingHost
=
GetCorrespondingNodeInDocument
(
shadow
-
>
Host
(
)
aStaticClone
)
;
if
(
NS_WARN_IF
(
!
correspondingHost
|
|
!
correspondingHost
-
>
IsElement
(
)
)
)
{
return
nullptr
;
}
return
correspondingHost
-
>
AsElement
(
)
-
>
GetShadowRoot
(
)
;
}
(
)
;
if
(
NS_WARN_IF
(
!
correspondingNode
)
)
{
return
nullptr
;
}
for
(
const
Maybe
<
uint32_t
>
&
index
:
Reversed
(
indexArray
)
)
{
correspondingNode
=
correspondingNode
-
>
GetChildAt_Deprecated
(
*
index
)
;
NS_ENSURE_TRUE
(
correspondingNode
nullptr
)
;
}
return
correspondingNode
;
}
static
void
CachePrintSelectionRanges
(
const
Document
&
aSourceDoc
Document
&
aStaticClone
)
{
MOZ_ASSERT
(
aStaticClone
.
IsStaticDocument
(
)
)
;
MOZ_ASSERT
(
!
aStaticClone
.
GetProperty
(
nsGkAtoms
:
:
printisfocuseddoc
)
)
;
MOZ_ASSERT
(
!
aStaticClone
.
GetProperty
(
nsGkAtoms
:
:
printselectionranges
)
)
;
bool
sourceDocIsStatic
=
aSourceDoc
.
IsStaticDocument
(
)
;
const
bool
isFocusedDoc
=
[
&
]
{
if
(
sourceDocIsStatic
)
{
return
bool
(
aSourceDoc
.
GetProperty
(
nsGkAtoms
:
:
printisfocuseddoc
)
)
;
}
nsPIDOMWindowOuter
*
window
=
aSourceDoc
.
GetWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
window
-
>
GetPrivateRoot
(
)
;
if
(
!
rootWindow
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsFocusManager
:
:
GetFocusedDescendant
(
rootWindow
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
focusedWindow
)
)
;
return
focusedWindow
&
&
focusedWindow
-
>
GetExtantDoc
(
)
=
=
&
aSourceDoc
;
}
(
)
;
if
(
isFocusedDoc
)
{
aStaticClone
.
SetProperty
(
nsGkAtoms
:
:
printisfocuseddoc
reinterpret_cast
<
void
*
>
(
true
)
)
;
}
const
Selection
*
origSelection
=
nullptr
;
const
nsTArray
<
RefPtr
<
nsRange
>
>
*
origRanges
=
nullptr
;
if
(
sourceDocIsStatic
)
{
origRanges
=
static_cast
<
nsTArray
<
RefPtr
<
nsRange
>
>
*
>
(
aSourceDoc
.
GetProperty
(
nsGkAtoms
:
:
printselectionranges
)
)
;
}
else
if
(
PresShell
*
shell
=
aSourceDoc
.
GetPresShell
(
)
)
{
origSelection
=
shell
-
>
GetCurrentSelection
(
SelectionType
:
:
eNormal
)
;
}
if
(
!
origSelection
&
&
!
origRanges
)
{
return
;
}
const
uint32_t
rangeCount
=
sourceDocIsStatic
?
origRanges
-
>
Length
(
)
:
origSelection
-
>
RangeCount
(
)
;
auto
printRanges
=
MakeUnique
<
nsTArray
<
RefPtr
<
nsRange
>
>
>
(
rangeCount
)
;
for
(
const
uint32_t
i
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT_IF
(
!
sourceDocIsStatic
origSelection
-
>
RangeCount
(
)
=
=
rangeCount
)
;
const
nsRange
*
range
=
sourceDocIsStatic
?
origRanges
-
>
ElementAt
(
i
)
.
get
(
)
:
origSelection
-
>
GetRangeAt
(
i
)
;
MOZ_ASSERT
(
range
)
;
nsINode
*
startContainer
=
range
-
>
GetStartContainer
(
)
;
nsINode
*
endContainer
=
range
-
>
GetEndContainer
(
)
;
if
(
!
startContainer
|
|
!
endContainer
)
{
continue
;
}
nsINode
*
startNode
=
GetCorrespondingNodeInDocument
(
startContainer
aStaticClone
)
;
nsINode
*
endNode
=
GetCorrespondingNodeInDocument
(
endContainer
aStaticClone
)
;
if
(
NS_WARN_IF
(
!
startNode
|
|
!
endNode
)
)
{
continue
;
}
RefPtr
<
nsRange
>
clonedRange
=
nsRange
:
:
Create
(
startNode
range
-
>
StartOffset
(
)
endNode
range
-
>
EndOffset
(
)
IgnoreErrors
(
)
)
;
if
(
clonedRange
&
&
!
clonedRange
-
>
Collapsed
(
)
)
{
printRanges
-
>
AppendElement
(
std
:
:
move
(
clonedRange
)
)
;
}
}
if
(
printRanges
-
>
IsEmpty
(
)
)
{
return
;
}
aStaticClone
.
SetProperty
(
nsGkAtoms
:
:
printselectionranges
printRanges
.
release
(
)
nsINode
:
:
DeleteProperty
<
nsTArray
<
RefPtr
<
nsRange
>
>
>
)
;
}
already_AddRefed
<
Document
>
Document
:
:
CreateStaticClone
(
nsIDocShell
*
aCloneContainer
nsIDocumentViewer
*
aViewer
nsIPrintSettings
*
aPrintSettings
bool
*
aOutHasInProcessPrintCallbacks
)
{
MOZ_ASSERT
(
!
mCreatingStaticClone
)
;
MOZ_ASSERT
(
!
GetProperty
(
nsGkAtoms
:
:
adoptedsheetclones
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aViewer
)
;
mCreatingStaticClone
=
true
;
SetProperty
(
nsGkAtoms
:
:
adoptedsheetclones
new
AdoptedStyleSheetCloneCache
(
)
nsINode
:
:
DeleteProperty
<
AdoptedStyleSheetCloneCache
>
)
;
auto
raii
=
MakeScopeExit
(
[
&
]
{
RemoveProperty
(
nsGkAtoms
:
:
adoptedsheetclones
)
;
mCreatingStaticClone
=
false
;
}
)
;
RefPtr
<
nsDocShell
>
originalShell
=
mDocumentContainer
.
get
(
)
;
SetContainer
(
nsDocShell
:
:
Cast
(
aCloneContainer
)
)
;
IgnoredErrorResult
rv
;
nsCOMPtr
<
nsINode
>
clonedNode
=
CloneNode
(
true
rv
)
;
SetContainer
(
originalShell
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
Document
>
clonedDoc
=
do_QueryInterface
(
clonedNode
)
;
if
(
!
clonedDoc
)
{
return
nullptr
;
}
size_t
sheetsCount
=
SheetCount
(
)
;
for
(
size_t
i
=
0
;
i
<
sheetsCount
;
+
+
i
)
{
RefPtr
<
StyleSheet
>
sheet
=
SheetAt
(
i
)
;
if
(
sheet
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
RefPtr
<
StyleSheet
>
clonedSheet
=
sheet
-
>
Clone
(
nullptr
clonedDoc
)
;
NS_WARNING_ASSERTION
(
clonedSheet
"
Cloning
a
stylesheet
didn
'
t
work
!
"
)
;
if
(
clonedSheet
)
{
clonedDoc
-
>
AddStyleSheet
(
clonedSheet
)
;
}
}
}
}
clonedDoc
-
>
CloneAdoptedSheetsFrom
(
*
this
)
;
for
(
int
t
=
0
;
t
<
AdditionalSheetTypeCount
;
+
+
t
)
{
auto
&
sheets
=
mAdditionalSheets
[
additionalSheetType
(
t
)
]
;
for
(
StyleSheet
*
sheet
:
sheets
)
{
if
(
sheet
-
>
IsApplicable
(
)
)
{
RefPtr
<
StyleSheet
>
clonedSheet
=
sheet
-
>
Clone
(
nullptr
clonedDoc
)
;
NS_WARNING_ASSERTION
(
clonedSheet
"
Cloning
a
stylesheet
didn
'
t
work
!
"
)
;
if
(
clonedSheet
)
{
clonedDoc
-
>
AddAdditionalStyleSheet
(
additionalSheetType
(
t
)
clonedSheet
)
;
}
}
}
}
if
(
const
FontFaceSet
*
set
=
GetFonts
(
)
)
{
set
-
>
CopyNonRuleFacesTo
(
clonedDoc
-
>
Fonts
(
)
)
;
}
clonedDoc
-
>
mReferrerInfo
=
static_cast
<
dom
:
:
ReferrerInfo
*
>
(
mReferrerInfo
.
get
(
)
)
-
>
Clone
(
)
;
clonedDoc
-
>
mPreloadReferrerInfo
=
clonedDoc
-
>
mReferrerInfo
;
CachePrintSelectionRanges
(
*
this
*
clonedDoc
)
;
aViewer
-
>
SetDocument
(
clonedDoc
)
;
*
aOutHasInProcessPrintCallbacks
|
=
clonedDoc
-
>
HasPrintCallbacks
(
)
;
auto
pendingClones
=
std
:
:
move
(
clonedDoc
-
>
mPendingFrameStaticClones
)
;
for
(
const
auto
&
clone
:
pendingClones
)
{
RefPtr
<
Element
>
element
=
do_QueryObject
(
clone
.
mElement
)
;
RefPtr
<
nsFrameLoader
>
frameLoader
=
nsFrameLoader
:
:
Create
(
element
false
)
;
if
(
NS_WARN_IF
(
!
frameLoader
)
)
{
continue
;
}
clone
.
mElement
-
>
SetFrameLoader
(
frameLoader
)
;
nsresult
rv
=
frameLoader
-
>
FinishStaticClone
(
clone
.
mStaticCloneOf
aPrintSettings
aOutHasInProcessPrintCallbacks
)
;
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
;
}
return
clonedDoc
.
forget
(
)
;
}
void
Document
:
:
UnlinkOriginalDocumentIfStatic
(
)
{
if
(
IsStaticDocument
(
)
&
&
mOriginalDocument
)
{
MOZ_ASSERT
(
mOriginalDocument
-
>
mStaticCloneCount
>
0
)
;
mOriginalDocument
-
>
mStaticCloneCount
-
-
;
mOriginalDocument
=
nullptr
;
}
MOZ_ASSERT
(
!
mOriginalDocument
)
;
}
nsresult
Document
:
:
ScheduleFrameRequestCallback
(
FrameRequestCallback
&
aCallback
int32_t
*
aHandle
)
{
nsresult
rv
=
mFrameRequestManager
.
Schedule
(
aCallback
aHandle
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
UpdateFrameRequestCallbackSchedulingState
(
)
;
return
NS_OK
;
}
void
Document
:
:
CancelFrameRequestCallback
(
int32_t
aHandle
)
{
if
(
mFrameRequestManager
.
Cancel
(
aHandle
)
)
{
UpdateFrameRequestCallbackSchedulingState
(
)
;
}
}
bool
Document
:
:
IsCanceledFrameRequestCallback
(
int32_t
aHandle
)
const
{
return
mFrameRequestManager
.
IsCanceled
(
aHandle
)
;
}
nsresult
Document
:
:
GetStateObject
(
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aState
)
{
if
(
!
mCachedStateObjectValid
)
{
if
(
mStateObjectContainer
)
{
AutoJSAPI
jsapi
;
if
(
!
jsapi
.
Init
(
GetScopeObject
(
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
JS
:
:
Rooted
<
JS
:
:
Value
>
value
(
jsapi
.
cx
(
)
)
;
nsresult
rv
=
mStateObjectContainer
-
>
DeserializeToJsval
(
jsapi
.
cx
(
)
&
value
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCachedStateObject
=
value
;
if
(
!
value
.
isNullOrUndefined
(
)
)
{
mozilla
:
:
HoldJSObjects
(
this
)
;
}
}
else
{
mCachedStateObject
=
JS
:
:
NullValue
(
)
;
}
mCachedStateObjectValid
=
true
;
}
aState
.
set
(
mCachedStateObject
)
;
return
NS_OK
;
}
void
Document
:
:
SetNavigationTiming
(
nsDOMNavigationTiming
*
aTiming
)
{
mTiming
=
aTiming
;
if
(
!
mLoadingOrRestoredFromBFCacheTimeStamp
.
IsNull
(
)
&
&
mTiming
)
{
mTiming
-
>
SetDOMLoadingTimeStamp
(
GetDocumentURI
(
)
mLoadingOrRestoredFromBFCacheTimeStamp
)
;
}
if
(
mDocumentTimeline
)
{
mDocumentTimeline
-
>
UpdateLastRefreshDriverTime
(
)
;
}
}
nsContentList
*
Document
:
:
ImageMapList
(
)
{
if
(
!
mImageMaps
)
{
mImageMaps
=
new
nsContentList
(
this
kNameSpaceID_XHTML
nsGkAtoms
:
:
map
nsGkAtoms
:
:
map
)
;
}
return
mImageMaps
;
}
#
define
DEPRECATED_OPERATION
(
_op
)
#
_op
"
Warning
"
static
const
char
*
kDeprecationWarnings
[
]
=
{
#
include
"
nsDeprecatedOperationList
.
h
"
nullptr
}
;
#
undef
DEPRECATED_OPERATION
#
define
DOCUMENT_WARNING
(
_op
)
#
_op
"
Warning
"
static
const
char
*
kDocumentWarnings
[
]
=
{
#
include
"
nsDocumentWarningList
.
h
"
nullptr
}
;
#
undef
DOCUMENT_WARNING
static
UseCounter
OperationToUseCounter
(
DeprecatedOperations
aOperation
)
{
switch
(
aOperation
)
{
#
define
DEPRECATED_OPERATION
(
_op
)
\
case
DeprecatedOperations
:
:
e
#
#
_op
:
\
return
eUseCounter_
#
#
_op
;
#
include
"
nsDeprecatedOperationList
.
h
"
#
undef
DEPRECATED_OPERATION
default
:
MOZ_CRASH
(
)
;
}
}
bool
Document
:
:
HasWarnedAbout
(
DeprecatedOperations
aOperation
)
const
{
return
mDeprecationWarnedAbout
[
static_cast
<
size_t
>
(
aOperation
)
]
;
}
void
Document
:
:
WarnOnceAbout
(
DeprecatedOperations
aOperation
bool
asError
const
nsTArray
<
nsString
>
&
aParams
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
HasWarnedAbout
(
aOperation
)
)
{
return
;
}
mDeprecationWarnedAbout
[
static_cast
<
size_t
>
(
aOperation
)
]
=
true
;
if
(
!
IsAboutPage
(
)
)
{
const_cast
<
Document
*
>
(
this
)
-
>
SetUseCounter
(
OperationToUseCounter
(
aOperation
)
)
;
}
uint32_t
flags
=
asError
?
nsIScriptError
:
:
errorFlag
:
nsIScriptError
:
:
warningFlag
;
nsContentUtils
:
:
ReportToConsole
(
flags
"
DOM
Core
"
_ns
this
nsContentUtils
:
:
eDOM_PROPERTIES
kDeprecationWarnings
[
static_cast
<
size_t
>
(
aOperation
)
]
aParams
)
;
}
bool
Document
:
:
HasWarnedAbout
(
DocumentWarnings
aWarning
)
const
{
return
mDocWarningWarnedAbout
[
aWarning
]
;
}
void
Document
:
:
WarnOnceAbout
(
DocumentWarnings
aWarning
bool
asError
const
nsTArray
<
nsString
>
&
aParams
)
const
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
HasWarnedAbout
(
aWarning
)
)
{
return
;
}
mDocWarningWarnedAbout
[
aWarning
]
=
true
;
uint32_t
flags
=
asError
?
nsIScriptError
:
:
errorFlag
:
nsIScriptError
:
:
warningFlag
;
nsContentUtils
:
:
ReportToConsole
(
flags
"
DOM
Core
"
_ns
this
nsContentUtils
:
:
eDOM_PROPERTIES
kDocumentWarnings
[
aWarning
]
aParams
)
;
}
mozilla
:
:
dom
:
:
ImageTracker
*
Document
:
:
ImageTracker
(
)
{
if
(
!
mImageTracker
)
{
mImageTracker
=
new
mozilla
:
:
dom
:
:
ImageTracker
;
}
return
mImageTracker
;
}
void
Document
:
:
ScheduleSVGUseElementShadowTreeUpdate
(
SVGUseElement
&
aUseElement
)
{
MOZ_ASSERT
(
aUseElement
.
IsInComposedDoc
(
)
)
;
if
(
MOZ_UNLIKELY
(
mIsStaticDocument
)
)
{
return
;
}
mSVGUseElementsNeedingShadowTreeUpdate
.
Insert
(
&
aUseElement
)
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
EnsureStyleFlush
(
)
;
}
}
void
Document
:
:
DoUpdateSVGUseElementShadowTrees
(
)
{
MOZ_ASSERT
(
!
mSVGUseElementsNeedingShadowTreeUpdate
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
mCloningForSVGUse
)
;
mCloningForSVGUse
=
true
;
do
{
const
auto
useElementsToUpdate
=
ToTArray
<
nsTArray
<
RefPtr
<
SVGUseElement
>
>
>
(
mSVGUseElementsNeedingShadowTreeUpdate
)
;
mSVGUseElementsNeedingShadowTreeUpdate
.
Clear
(
)
;
for
(
const
auto
&
useElement
:
useElementsToUpdate
)
{
if
(
MOZ_UNLIKELY
(
!
useElement
-
>
IsInComposedDoc
(
)
)
)
{
MOZ_ASSERT
(
useElementsToUpdate
.
Length
(
)
>
1
)
;
continue
;
}
useElement
-
>
UpdateShadowTree
(
)
;
}
}
while
(
!
mSVGUseElementsNeedingShadowTreeUpdate
.
IsEmpty
(
)
)
;
mCloningForSVGUse
=
false
;
}
void
Document
:
:
NotifyMediaFeatureValuesChanged
(
)
{
for
(
RefPtr
<
HTMLImageElement
>
imageElement
:
mResponsiveContent
)
{
imageElement
-
>
MediaFeatureValuesChanged
(
)
;
}
}
already_AddRefed
<
Touch
>
Document
:
:
CreateTouch
(
nsGlobalWindowInner
*
aView
EventTarget
*
aTarget
int32_t
aIdentifier
int32_t
aPageX
int32_t
aPageY
int32_t
aScreenX
int32_t
aScreenY
int32_t
aClientX
int32_t
aClientY
int32_t
aRadiusX
int32_t
aRadiusY
float
aRotationAngle
float
aForce
)
{
RefPtr
<
Touch
>
touch
=
new
Touch
(
aTarget
aIdentifier
aPageX
aPageY
aScreenX
aScreenY
aClientX
aClientY
aRadiusX
aRadiusY
aRotationAngle
aForce
)
;
return
touch
.
forget
(
)
;
}
already_AddRefed
<
TouchList
>
Document
:
:
CreateTouchList
(
)
{
RefPtr
<
TouchList
>
retval
=
new
TouchList
(
ToSupports
(
this
)
)
;
return
retval
.
forget
(
)
;
}
already_AddRefed
<
TouchList
>
Document
:
:
CreateTouchList
(
Touch
&
aTouch
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
{
RefPtr
<
TouchList
>
retval
=
new
TouchList
(
ToSupports
(
this
)
)
;
retval
-
>
Append
(
&
aTouch
)
;
for
(
uint32_t
i
=
0
;
i
<
aTouches
.
Length
(
)
;
+
+
i
)
{
retval
-
>
Append
(
aTouches
[
i
]
.
get
(
)
)
;
}
return
retval
.
forget
(
)
;
}
already_AddRefed
<
TouchList
>
Document
:
:
CreateTouchList
(
const
Sequence
<
OwningNonNull
<
Touch
>
>
&
aTouches
)
{
RefPtr
<
TouchList
>
retval
=
new
TouchList
(
ToSupports
(
this
)
)
;
for
(
uint32_t
i
=
0
;
i
<
aTouches
.
Length
(
)
;
+
+
i
)
{
retval
-
>
Append
(
aTouches
[
i
]
.
get
(
)
)
;
}
return
retval
.
forget
(
)
;
}
already_AddRefed
<
nsDOMCaretPosition
>
Document
:
:
CaretPositionFromPoint
(
float
aX
float
aY
)
{
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
nscoord
x
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aX
)
;
nscoord
y
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aY
)
;
nsPoint
pt
(
x
y
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
nullptr
;
}
nsIFrame
*
ptFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
RelativeTo
{
rootFrame
}
pt
{
{
FrameForPointOption
:
:
IgnorePaintSuppression
FrameForPointOption
:
:
IgnoreCrossDoc
}
}
)
;
if
(
!
ptFrame
)
{
return
nullptr
;
}
nsPoint
adjustedPoint
=
pt
;
if
(
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
{
rootFrame
}
RelativeTo
{
ptFrame
}
adjustedPoint
)
!
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
return
nullptr
;
}
nsIFrame
:
:
ContentOffsets
offsets
=
ptFrame
-
>
GetContentOffsetsFromPoint
(
adjustedPoint
)
;
nsCOMPtr
<
nsIContent
>
node
=
offsets
.
content
;
uint32_t
offset
=
offsets
.
offset
;
nsCOMPtr
<
nsIContent
>
anonNode
=
node
;
bool
nodeIsAnonymous
=
node
&
&
node
-
>
IsInNativeAnonymousSubtree
(
)
;
if
(
nodeIsAnonymous
)
{
node
=
ptFrame
-
>
GetContent
(
)
;
nsIContent
*
nonanon
=
node
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
nonanon
)
;
nsITextControlFrame
*
textFrame
=
do_QueryFrame
(
nonanon
-
>
GetPrimaryFrame
(
)
)
;
if
(
textFrame
)
{
nsCOMPtr
<
nsIContent
>
firstChild
=
anonNode
-
>
GetFirstChild
(
)
;
if
(
firstChild
)
{
anonNode
=
firstChild
;
}
if
(
textArea
)
{
offset
=
nsContentUtils
:
:
GetAdjustedOffsetInTextControl
(
ptFrame
offset
)
;
}
node
=
nonanon
;
}
else
{
node
=
nullptr
;
offset
=
0
;
}
}
RefPtr
<
nsDOMCaretPosition
>
aCaretPos
=
new
nsDOMCaretPosition
(
node
offset
)
;
if
(
nodeIsAnonymous
)
{
aCaretPos
-
>
SetAnonymousContentNode
(
anonNode
)
;
}
return
aCaretPos
.
forget
(
)
;
}
bool
Document
:
:
IsPotentiallyScrollable
(
HTMLBodyElement
*
aBody
)
{
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
nsIFrame
*
bodyFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
aBody
)
;
if
(
!
bodyFrame
)
{
return
false
;
}
MOZ_ASSERT
(
aBody
-
>
GetParent
(
)
=
=
aBody
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
)
;
nsIFrame
*
parentFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
aBody
-
>
GetParent
(
)
)
;
if
(
parentFrame
&
&
parentFrame
-
>
StyleDisplay
(
)
-
>
OverflowIsVisibleInBothAxis
(
)
)
{
return
false
;
}
return
!
bodyFrame
-
>
StyleDisplay
(
)
-
>
OverflowIsVisibleInBothAxis
(
)
;
}
Element
*
Document
:
:
GetScrollingElement
(
)
{
if
(
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
)
{
RefPtr
<
HTMLBodyElement
>
body
=
GetBodyElement
(
)
;
if
(
body
&
&
!
IsPotentiallyScrollable
(
body
)
)
{
return
body
;
}
return
nullptr
;
}
return
GetRootElement
(
)
;
}
bool
Document
:
:
IsScrollingElement
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
)
;
if
(
GetCompatibilityMode
(
)
!
=
eCompatibility_NavQuirks
)
{
return
aElement
=
=
GetRootElement
(
)
;
}
HTMLBodyElement
*
body
=
GetBodyElement
(
)
;
if
(
aElement
!
=
body
)
{
return
false
;
}
RefPtr
<
HTMLBodyElement
>
strongBody
(
body
)
;
return
!
IsPotentiallyScrollable
(
strongBody
)
;
}
class
UnblockParsingPromiseHandler
final
:
public
PromiseNativeHandler
{
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
UnblockParsingPromiseHandler
)
explicit
UnblockParsingPromiseHandler
(
Document
*
aDocument
Promise
*
aPromise
const
BlockParsingOptions
&
aOptions
)
:
mPromise
(
aPromise
)
{
nsCOMPtr
<
nsIParser
>
parser
=
aDocument
-
>
CreatorParserOrNull
(
)
;
if
(
parser
&
&
(
aOptions
.
mBlockScriptCreated
|
|
!
parser
-
>
IsScriptCreated
(
)
)
)
{
parser
-
>
BlockParser
(
)
;
mParser
=
do_GetWeakReference
(
parser
)
;
mDocument
=
aDocument
;
mDocument
-
>
BlockOnload
(
)
;
mDocument
-
>
BlockDOMContentLoaded
(
)
;
}
}
void
ResolvedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
MaybeUnblockParser
(
)
;
mPromise
-
>
MaybeResolve
(
aValue
)
;
}
void
RejectedCallback
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aValue
ErrorResult
&
aRv
)
override
{
MaybeUnblockParser
(
)
;
mPromise
-
>
MaybeReject
(
aValue
)
;
}
protected
:
virtual
~
UnblockParsingPromiseHandler
(
)
{
if
(
mDocument
)
{
MaybeUnblockParser
(
)
;
}
}
private
:
void
MaybeUnblockParser
(
)
{
nsCOMPtr
<
nsIParser
>
parser
=
do_QueryReferent
(
mParser
)
;
if
(
parser
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mDocument
)
;
nsCOMPtr
<
nsIParser
>
docParser
=
mDocument
-
>
CreatorParserOrNull
(
)
;
if
(
parser
=
=
docParser
)
{
parser
-
>
UnblockParser
(
)
;
parser
-
>
ContinueInterruptedParsingAsync
(
)
;
}
}
if
(
mDocument
)
{
mDocument
-
>
UnblockDOMContentLoaded
(
)
;
mDocument
-
>
UnblockOnload
(
false
)
;
}
mParser
=
nullptr
;
mDocument
=
nullptr
;
}
nsWeakPtr
mParser
;
RefPtr
<
Promise
>
mPromise
;
RefPtr
<
Document
>
mDocument
;
}
;
NS_IMPL_CYCLE_COLLECTION
(
UnblockParsingPromiseHandler
mDocument
mPromise
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
UnblockParsingPromiseHandler
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
UnblockParsingPromiseHandler
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
UnblockParsingPromiseHandler
)
already_AddRefed
<
Promise
>
Document
:
:
BlockParsing
(
Promise
&
aPromise
const
BlockParsingOptions
&
aOptions
ErrorResult
&
aRv
)
{
RefPtr
<
Promise
>
resultPromise
=
Promise
:
:
Create
(
aPromise
.
GetParentObject
(
)
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
RefPtr
<
PromiseNativeHandler
>
promiseHandler
=
new
UnblockParsingPromiseHandler
(
this
resultPromise
aOptions
)
;
aPromise
.
AppendNativeHandler
(
promiseHandler
)
;
return
resultPromise
.
forget
(
)
;
}
already_AddRefed
<
nsIURI
>
Document
:
:
GetMozDocumentURIIfNotForErrorPages
(
)
{
if
(
mFailedChannel
)
{
nsCOMPtr
<
nsIURI
>
failedURI
;
if
(
NS_SUCCEEDED
(
mFailedChannel
-
>
GetURI
(
getter_AddRefs
(
failedURI
)
)
)
)
{
return
failedURI
.
forget
(
)
;
}
}
nsCOMPtr
<
nsIURI
>
uri
=
GetDocumentURIObject
(
)
;
if
(
!
uri
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
Promise
*
Document
:
:
GetDocumentReadyForIdle
(
ErrorResult
&
aRv
)
{
if
(
mIsGoingAway
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
if
(
!
mReadyForIdle
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
mReadyForIdle
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
}
return
mReadyForIdle
;
}
void
Document
:
:
MaybeResolveReadyForIdle
(
)
{
IgnoredErrorResult
rv
;
Promise
*
readyPromise
=
GetDocumentReadyForIdle
(
rv
)
;
if
(
readyPromise
)
{
readyPromise
-
>
MaybeResolveWithUndefined
(
)
;
}
}
mozilla
:
:
dom
:
:
FeaturePolicy
*
Document
:
:
FeaturePolicy
(
)
const
{
MOZ_ASSERT
(
mFeaturePolicy
)
;
return
mFeaturePolicy
;
}
nsIDOMXULCommandDispatcher
*
Document
:
:
GetCommandDispatcher
(
)
{
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
this
)
)
{
return
nullptr
;
}
if
(
!
mCommandDispatcher
)
{
mCommandDispatcher
=
new
nsXULCommandDispatcher
(
this
)
;
}
return
mCommandDispatcher
;
}
void
Document
:
:
InitializeXULBroadcastManager
(
)
{
if
(
mXULBroadcastManager
)
{
return
;
}
mXULBroadcastManager
=
new
XULBroadcastManager
(
this
)
;
}
namespace
{
class
DevToolsMutationObserver
final
:
public
nsStubMutationObserver
{
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
DevToolsMutationObserver
(
)
=
default
;
private
:
void
FireEvent
(
nsINode
*
aTarget
const
nsAString
&
aType
)
;
~
DevToolsMutationObserver
(
)
=
default
;
}
;
NS_IMPL_ISUPPORTS
(
DevToolsMutationObserver
nsIMutationObserver
)
void
DevToolsMutationObserver
:
:
FireEvent
(
nsINode
*
aTarget
const
nsAString
&
aType
)
{
AsyncEventDispatcher
:
:
RunDOMEventWhenSafe
(
*
aTarget
aType
CanBubble
:
:
eNo
ChromeOnlyDispatch
:
:
eYes
Composed
:
:
eYes
)
;
}
void
DevToolsMutationObserver
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNamespaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
FireEvent
(
aElement
u
"
devtoolsattrmodified
"
_ns
)
;
}
void
DevToolsMutationObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
for
(
nsIContent
*
c
=
aFirstNewContent
;
c
;
c
=
c
-
>
GetNextSibling
(
)
)
{
ContentInserted
(
c
)
;
}
}
void
DevToolsMutationObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
FireEvent
(
aChild
u
"
devtoolschildinserted
"
_ns
)
;
}
static
StaticRefPtr
<
DevToolsMutationObserver
>
sDevToolsMutationObserver
;
}
void
Document
:
:
SetDevToolsWatchingDOMMutations
(
bool
aValue
)
{
if
(
mDevToolsWatchingDOMMutations
=
=
aValue
|
|
mIsGoingAway
)
{
return
;
}
mDevToolsWatchingDOMMutations
=
aValue
;
if
(
aValue
)
{
if
(
MOZ_UNLIKELY
(
!
sDevToolsMutationObserver
)
)
{
sDevToolsMutationObserver
=
new
DevToolsMutationObserver
(
)
;
ClearOnShutdown
(
&
sDevToolsMutationObserver
)
;
}
AddMutationObserver
(
sDevToolsMutationObserver
)
;
}
else
if
(
sDevToolsMutationObserver
)
{
RemoveMutationObserver
(
sDevToolsMutationObserver
)
;
}
}
void
EvaluateMediaQueryLists
(
nsTArray
<
RefPtr
<
MediaQueryList
>
>
&
aListsToNotify
Document
&
aDocument
bool
aRecurse
)
{
if
(
nsPresContext
*
pc
=
aDocument
.
GetPresContext
(
)
)
{
pc
-
>
FlushPendingMediaFeatureValuesChanged
(
)
;
}
for
(
MediaQueryList
*
mql
:
aDocument
.
MediaQueryLists
(
)
)
{
if
(
mql
-
>
EvaluateOnRenderingUpdate
(
)
)
{
aListsToNotify
.
AppendElement
(
mql
)
;
}
}
if
(
!
aRecurse
)
{
return
;
}
auto
recurse
=
[
&
]
(
Document
&
aSubDoc
)
{
EvaluateMediaQueryLists
(
aListsToNotify
aSubDoc
true
)
;
return
CallState
:
:
Continue
;
}
;
aDocument
.
EnumerateSubDocuments
(
recurse
)
;
}
void
Document
:
:
EvaluateMediaQueriesAndReportChanges
(
bool
aRecurse
)
{
AutoTArray
<
RefPtr
<
MediaQueryList
>
32
>
mqls
;
EvaluateMediaQueryLists
(
mqls
*
this
aRecurse
)
;
for
(
auto
&
mql
:
mqls
)
{
mql
-
>
FireChangeEvent
(
)
;
}
}
void
Document
:
:
MaybeWarnAboutZoom
(
)
{
if
(
mHasWarnedAboutZoom
)
{
return
;
}
const
bool
usedZoom
=
Servo_IsPropertyIdRecordedInUseCounter
(
mStyleUseCounters
.
get
(
)
eCSSProperty_zoom
)
;
if
(
!
usedZoom
)
{
return
;
}
mHasWarnedAboutZoom
=
true
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Layout
"
_ns
this
nsContentUtils
:
:
eLAYOUT_PROPERTIES
"
ZoomPropertyWarning
"
)
;
}
nsIHTMLCollection
*
Document
:
:
Children
(
)
{
if
(
!
mChildrenCollection
)
{
mChildrenCollection
=
new
nsContentList
(
this
kNameSpaceID_Wildcard
nsGkAtoms
:
:
_asterisk
nsGkAtoms
:
:
_asterisk
false
)
;
}
return
mChildrenCollection
;
}
uint32_t
Document
:
:
ChildElementCount
(
)
{
return
Children
(
)
-
>
Length
(
)
;
}
class
FullscreenRoots
{
public
:
static
void
Add
(
Document
*
aDoc
)
;
static
void
ForEach
(
void
(
*
aFunction
)
(
Document
*
aDoc
)
)
;
static
void
Remove
(
Document
*
aDoc
)
;
static
bool
IsEmpty
(
)
;
private
:
MOZ_COUNTED_DEFAULT_CTOR
(
FullscreenRoots
)
MOZ_COUNTED_DTOR
(
FullscreenRoots
)
enum
:
uint32_t
{
NotFound
=
uint32_t
(
-
1
)
}
;
static
uint32_t
Find
(
Document
*
aRoot
)
;
static
bool
Contains
(
Document
*
aRoot
)
;
static
FullscreenRoots
*
sInstance
;
nsTArray
<
nsWeakPtr
>
mRoots
;
}
;
FullscreenRoots
*
FullscreenRoots
:
:
sInstance
=
nullptr
;
void
FullscreenRoots
:
:
ForEach
(
void
(
*
aFunction
)
(
Document
*
aDoc
)
)
{
if
(
!
sInstance
)
{
return
;
}
nsTArray
<
nsWeakPtr
>
roots
(
sInstance
-
>
mRoots
.
Clone
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
roots
.
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
Document
>
root
=
do_QueryReferent
(
roots
[
i
]
)
;
if
(
root
&
&
FullscreenRoots
:
:
Contains
(
root
)
)
{
aFunction
(
root
)
;
}
}
}
bool
FullscreenRoots
:
:
Contains
(
Document
*
aRoot
)
{
return
FullscreenRoots
:
:
Find
(
aRoot
)
!
=
NotFound
;
}
void
FullscreenRoots
:
:
Add
(
Document
*
aDoc
)
{
nsCOMPtr
<
Document
>
root
=
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
aDoc
)
;
if
(
!
FullscreenRoots
:
:
Contains
(
root
)
)
{
if
(
!
sInstance
)
{
sInstance
=
new
FullscreenRoots
(
)
;
}
sInstance
-
>
mRoots
.
AppendElement
(
do_GetWeakReference
(
root
)
)
;
}
}
uint32_t
FullscreenRoots
:
:
Find
(
Document
*
aRoot
)
{
if
(
!
sInstance
)
{
return
NotFound
;
}
nsTArray
<
nsWeakPtr
>
&
roots
=
sInstance
-
>
mRoots
;
for
(
uint32_t
i
=
0
;
i
<
roots
.
Length
(
)
;
i
+
+
)
{
nsCOMPtr
<
Document
>
otherRoot
(
do_QueryReferent
(
roots
[
i
]
)
)
;
if
(
otherRoot
=
=
aRoot
)
{
return
i
;
}
}
return
NotFound
;
}
void
FullscreenRoots
:
:
Remove
(
Document
*
aDoc
)
{
nsCOMPtr
<
Document
>
root
=
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
aDoc
)
;
uint32_t
index
=
Find
(
root
)
;
NS_ASSERTION
(
index
!
=
NotFound
"
Should
only
try
to
remove
roots
which
are
still
added
!
"
)
;
if
(
index
=
=
NotFound
|
|
!
sInstance
)
{
return
;
}
sInstance
-
>
mRoots
.
RemoveElementAt
(
index
)
;
if
(
sInstance
-
>
mRoots
.
IsEmpty
(
)
)
{
delete
sInstance
;
sInstance
=
nullptr
;
}
}
bool
FullscreenRoots
:
:
IsEmpty
(
)
{
return
!
sInstance
;
}
class
PendingFullscreenChangeList
{
public
:
PendingFullscreenChangeList
(
)
=
delete
;
template
<
typename
T
>
static
void
Add
(
UniquePtr
<
T
>
aChange
)
{
sList
.
insertBack
(
aChange
.
release
(
)
)
;
}
static
const
FullscreenChange
*
GetLast
(
)
{
return
sList
.
getLast
(
)
;
}
enum
IteratorOption
{
eDocumentsWithSameRoot
eInclusiveDescendants
}
;
template
<
typename
T
>
class
Iterator
{
public
:
explicit
Iterator
(
Document
*
aDoc
IteratorOption
aOption
)
:
mCurrent
(
PendingFullscreenChangeList
:
:
sList
.
getFirst
(
)
)
{
if
(
mCurrent
)
{
if
(
aDoc
-
>
GetBrowsingContext
(
)
)
{
mRootBCForIteration
=
aDoc
-
>
GetBrowsingContext
(
)
;
if
(
aOption
=
=
eDocumentsWithSameRoot
)
{
RefPtr
<
BrowsingContext
>
bc
=
GetParentIgnoreChromeBoundary
(
mRootBCForIteration
)
;
while
(
bc
)
{
mRootBCForIteration
=
bc
;
bc
=
GetParentIgnoreChromeBoundary
(
mRootBCForIteration
)
;
}
}
}
SkipToNextMatch
(
)
;
}
}
UniquePtr
<
T
>
TakeAndNext
(
)
{
auto
thisChange
=
TakeAndNextInternal
(
)
;
SkipToNextMatch
(
)
;
return
thisChange
;
}
bool
AtEnd
(
)
const
{
return
mCurrent
=
=
nullptr
;
}
private
:
already_AddRefed
<
BrowsingContext
>
GetParentIgnoreChromeBoundary
(
BrowsingContext
*
aBC
)
{
if
(
XRE_IsParentProcess
(
)
)
{
return
aBC
-
>
Canonical
(
)
-
>
GetParentCrossChromeBoundary
(
)
;
}
return
do_AddRef
(
aBC
-
>
GetParent
(
)
)
;
}
UniquePtr
<
T
>
TakeAndNextInternal
(
)
{
FullscreenChange
*
thisChange
=
mCurrent
;
MOZ_ASSERT
(
thisChange
-
>
Type
(
)
=
=
T
:
:
kType
)
;
mCurrent
=
mCurrent
-
>
removeAndGetNext
(
)
;
return
WrapUnique
(
static_cast
<
T
*
>
(
thisChange
)
)
;
}
void
SkipToNextMatch
(
)
{
while
(
mCurrent
)
{
if
(
mCurrent
-
>
Type
(
)
=
=
T
:
:
kType
)
{
RefPtr
<
BrowsingContext
>
bc
=
mCurrent
-
>
Document
(
)
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
UniquePtr
<
T
>
change
=
TakeAndNextInternal
(
)
;
change
-
>
MayRejectPromise
(
"
Document
is
not
active
"
)
;
continue
;
}
while
(
bc
&
&
bc
!
=
mRootBCForIteration
)
{
bc
=
GetParentIgnoreChromeBoundary
(
bc
)
;
}
if
(
bc
)
{
break
;
}
}
mCurrent
=
mCurrent
-
>
getNext
(
)
;
}
}
FullscreenChange
*
mCurrent
;
RefPtr
<
BrowsingContext
>
mRootBCForIteration
;
}
;
private
:
static
LinkedList
<
FullscreenChange
>
sList
;
}
;
LinkedList
<
FullscreenChange
>
PendingFullscreenChangeList
:
:
sList
;
Document
*
Document
:
:
GetFullscreenRoot
(
)
{
nsCOMPtr
<
Document
>
root
=
do_QueryReferent
(
mFullscreenRoot
)
;
return
root
;
}
size_t
Document
:
:
CountFullscreenElements
(
)
const
{
size_t
count
=
0
;
for
(
const
nsWeakPtr
&
ptr
:
mTopLayer
)
{
if
(
nsCOMPtr
<
Element
>
elem
=
do_QueryReferent
(
ptr
)
)
{
if
(
elem
-
>
State
(
)
.
HasState
(
ElementState
:
:
FULLSCREEN
)
)
{
count
+
+
;
}
}
}
return
count
;
}
void
Document
:
:
SetFullscreenRoot
(
Document
*
aRoot
)
{
mFullscreenRoot
=
do_GetWeakReference
(
aRoot
)
;
}
void
Document
:
:
HandleEscKey
(
)
{
for
(
const
nsWeakPtr
&
weakPtr
:
Reversed
(
mTopLayer
)
)
{
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
weakPtr
)
)
;
if
(
RefPtr
popoverHTMLEl
=
nsGenericHTMLElement
:
:
FromNodeOrNull
(
element
)
)
{
if
(
element
-
>
IsAutoPopover
(
)
&
&
element
-
>
IsPopoverOpen
(
)
)
{
popoverHTMLEl
-
>
HidePopover
(
IgnoreErrors
(
)
)
;
break
;
}
}
if
(
auto
*
dialog
=
HTMLDialogElement
:
:
FromNodeOrNull
(
element
)
)
{
dialog
-
>
QueueCancelDialog
(
)
;
break
;
}
}
}
already_AddRefed
<
Promise
>
Document
:
:
ExitFullscreen
(
ErrorResult
&
aRv
)
{
UniquePtr
<
FullscreenExit
>
exit
=
FullscreenExit
:
:
Create
(
this
aRv
)
;
RefPtr
<
Promise
>
promise
=
exit
-
>
GetPromise
(
)
;
RestorePreviousFullscreenState
(
std
:
:
move
(
exit
)
)
;
return
promise
.
forget
(
)
;
}
static
void
AskWindowToExitFullscreen
(
Document
*
aDoc
)
{
if
(
XRE_GetProcessType
(
)
=
=
GeckoProcessType_Content
)
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
aDoc
aDoc
u
"
MozDOMFullscreen
:
Exit
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
}
else
{
if
(
nsPIDOMWindowOuter
*
win
=
aDoc
-
>
GetWindow
(
)
)
{
win
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenAPI
false
)
;
}
}
}
class
nsCallExitFullscreen
:
public
Runnable
{
public
:
explicit
nsCallExitFullscreen
(
Document
*
aDoc
)
:
mozilla
:
:
Runnable
(
"
nsCallExitFullscreen
"
)
mDoc
(
aDoc
)
{
}
NS_IMETHOD
Run
(
)
final
{
if
(
!
mDoc
)
{
FullscreenRoots
:
:
ForEach
(
&
AskWindowToExitFullscreen
)
;
}
else
{
AskWindowToExitFullscreen
(
mDoc
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
Document
>
mDoc
;
}
;
void
Document
:
:
AsyncExitFullscreen
(
Document
*
aDoc
)
{
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
exit
=
new
nsCallExitFullscreen
(
aDoc
)
;
NS_DispatchToCurrentThread
(
exit
.
forget
(
)
)
;
}
static
uint32_t
CountFullscreenSubDocuments
(
Document
&
aDoc
)
{
uint32_t
count
=
0
;
auto
subDoc
=
[
&
count
]
(
Document
&
aSubDoc
)
{
if
(
aSubDoc
.
Fullscreen
(
)
)
{
count
+
+
;
}
return
CallState
:
:
Continue
;
}
;
aDoc
.
EnumerateSubDocuments
(
subDoc
)
;
return
count
;
}
bool
Document
:
:
IsFullscreenLeaf
(
)
{
return
Fullscreen
(
)
&
&
CountFullscreenSubDocuments
(
*
this
)
=
=
0
;
}
static
Document
*
GetFullscreenLeaf
(
Document
&
aDoc
)
{
if
(
aDoc
.
IsFullscreenLeaf
(
)
)
{
return
&
aDoc
;
}
if
(
!
aDoc
.
Fullscreen
(
)
)
{
return
nullptr
;
}
Document
*
leaf
=
nullptr
;
auto
recurse
=
[
&
leaf
]
(
Document
&
aSubDoc
)
{
leaf
=
GetFullscreenLeaf
(
aSubDoc
)
;
return
leaf
?
CallState
:
:
Stop
:
CallState
:
:
Continue
;
}
;
aDoc
.
EnumerateSubDocuments
(
recurse
)
;
return
leaf
;
}
static
Document
*
GetFullscreenLeaf
(
Document
*
aDoc
)
{
if
(
Document
*
leaf
=
GetFullscreenLeaf
(
*
aDoc
)
)
{
return
leaf
;
}
Document
*
root
=
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
aDoc
)
;
return
GetFullscreenLeaf
(
*
root
)
;
}
static
CallState
ResetFullscreen
(
Document
&
aDocument
)
{
if
(
Element
*
fsElement
=
aDocument
.
GetUnretargetedFullscreenElement
(
)
)
{
NS_ASSERTION
(
CountFullscreenSubDocuments
(
aDocument
)
<
=
1
"
Should
have
at
most
1
fullscreen
subdocument
.
"
)
;
aDocument
.
CleanupFullscreenState
(
)
;
NS_ASSERTION
(
!
aDocument
.
Fullscreen
(
)
"
Should
reset
fullscreen
"
)
;
DispatchFullscreenChange
(
aDocument
fsElement
)
;
aDocument
.
EnumerateSubDocuments
(
ResetFullscreen
)
;
}
return
CallState
:
:
Continue
;
}
class
ExitFullscreenScriptRunnable
:
public
Runnable
{
public
:
explicit
ExitFullscreenScriptRunnable
(
Document
*
aRoot
Document
*
aLeaf
)
:
mozilla
:
:
Runnable
(
"
ExitFullscreenScriptRunnable
"
)
mRoot
(
aRoot
)
mLeaf
(
aLeaf
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
mLeaf
mLeaf
u
"
MozDOMFullscreen
:
Exited
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
if
(
nsPIDOMWindowOuter
*
win
=
mRoot
-
>
GetWindow
(
)
)
{
if
(
!
mRoot
-
>
HasPendingFullscreenRequests
(
)
)
{
win
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForForceExitFullscreen
false
)
;
}
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
Document
>
mRoot
;
nsCOMPtr
<
Document
>
mLeaf
;
}
;
void
Document
:
:
ExitFullscreenInDocTree
(
Document
*
aMaybeNotARootDoc
)
{
MOZ_ASSERT
(
aMaybeNotARootDoc
)
;
PointerLockManager
:
:
Unlock
(
)
;
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenExit
>
iter
(
aMaybeNotARootDoc
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
while
(
!
iter
.
AtEnd
(
)
)
{
UniquePtr
<
FullscreenExit
>
exit
=
iter
.
TakeAndNext
(
)
;
exit
-
>
MayResolvePromise
(
)
;
}
nsCOMPtr
<
Document
>
root
=
aMaybeNotARootDoc
-
>
GetFullscreenRoot
(
)
;
if
(
!
root
|
|
!
root
-
>
Fullscreen
(
)
)
{
return
;
}
Document
*
fullscreenLeaf
=
GetFullscreenLeaf
(
root
)
;
ResetFullscreen
(
*
root
)
;
NS_ASSERTION
(
!
root
-
>
Fullscreen
(
)
"
Fullscreen
root
should
no
longer
be
a
fullscreen
doc
.
.
.
"
)
;
FullscreenRoots
:
:
Remove
(
root
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
ExitFullscreenScriptRunnable
(
root
fullscreenLeaf
)
)
;
}
static
void
DispatchFullscreenNewOriginEvent
(
Document
*
aDoc
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
aDoc
u
"
MozDOMFullscreen
:
NewOrigin
"
_ns
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
;
asyncDispatcher
-
>
PostDOMEvent
(
)
;
}
void
Document
:
:
RestorePreviousFullscreenState
(
UniquePtr
<
FullscreenExit
>
aExit
)
{
NS_ASSERTION
(
!
Fullscreen
(
)
|
|
!
FullscreenRoots
:
:
IsEmpty
(
)
"
Should
have
at
least
1
fullscreen
root
when
fullscreen
!
"
)
;
if
(
!
GetWindow
(
)
)
{
aExit
-
>
MayRejectPromise
(
"
No
active
window
"
)
;
return
;
}
if
(
!
Fullscreen
(
)
|
|
FullscreenRoots
:
:
IsEmpty
(
)
)
{
aExit
-
>
MayRejectPromise
(
"
Not
in
fullscreen
mode
"
)
;
return
;
}
nsCOMPtr
<
Document
>
fullScreenDoc
=
GetFullscreenLeaf
(
this
)
;
AutoTArray
<
Element
*
8
>
exitElements
;
Document
*
doc
=
fullScreenDoc
;
for
(
;
doc
!
=
this
;
doc
=
doc
-
>
GetInProcessParentDocument
(
)
)
{
Element
*
fsElement
=
doc
-
>
GetUnretargetedFullscreenElement
(
)
;
MOZ_ASSERT
(
fsElement
"
Parent
document
of
"
"
a
fullscreen
document
without
fullscreen
element
?
"
)
;
exitElements
.
AppendElement
(
fsElement
)
;
}
MOZ_ASSERT
(
doc
=
=
this
"
Must
have
reached
this
doc
"
)
;
for
(
;
doc
;
doc
=
doc
-
>
GetInProcessParentDocument
(
)
)
{
Element
*
fsElement
=
doc
-
>
GetUnretargetedFullscreenElement
(
)
;
MOZ_ASSERT
(
fsElement
"
Ancestor
of
fullscreen
document
must
also
be
in
fullscreen
"
)
;
if
(
doc
!
=
this
)
{
if
(
auto
*
iframe
=
HTMLIFrameElement
:
:
FromNode
(
fsElement
)
)
{
if
(
iframe
-
>
FullscreenFlag
(
)
)
{
break
;
}
}
}
exitElements
.
AppendElement
(
fsElement
)
;
if
(
doc
-
>
CountFullscreenElements
(
)
>
1
)
{
break
;
}
}
Document
*
lastDoc
=
exitElements
.
LastElement
(
)
-
>
OwnerDoc
(
)
;
size_t
fullscreenCount
=
lastDoc
-
>
CountFullscreenElements
(
)
;
if
(
!
lastDoc
-
>
GetInProcessParentDocument
(
)
&
&
fullscreenCount
=
=
1
)
{
PendingFullscreenChangeList
:
:
Add
(
std
:
:
move
(
aExit
)
)
;
AskWindowToExitFullscreen
(
this
)
;
return
;
}
PointerLockManager
:
:
Unlock
(
)
;
for
(
auto
i
:
IntegerRange
(
exitElements
.
Length
(
)
-
1
)
)
{
exitElements
[
i
]
-
>
OwnerDoc
(
)
-
>
CleanupFullscreenState
(
)
;
}
Document
*
newFullscreenDoc
;
if
(
fullscreenCount
>
1
)
{
DebugOnly
<
bool
>
removedFullscreenElement
=
lastDoc
-
>
PopFullscreenElement
(
)
;
MOZ_ASSERT
(
removedFullscreenElement
)
;
newFullscreenDoc
=
lastDoc
;
}
else
{
lastDoc
-
>
CleanupFullscreenState
(
)
;
newFullscreenDoc
=
lastDoc
-
>
GetInProcessParentDocument
(
)
;
}
for
(
Element
*
e
:
Reversed
(
exitElements
)
)
{
DispatchFullscreenChange
(
*
e
-
>
OwnerDoc
(
)
e
)
;
}
aExit
-
>
MayResolvePromise
(
)
;
MOZ_ASSERT
(
newFullscreenDoc
"
If
we
were
going
to
exit
from
fullscreen
on
"
"
all
documents
in
this
doctree
we
should
'
ve
asked
the
window
to
"
"
exit
first
instead
of
reaching
here
.
"
)
;
if
(
fullScreenDoc
!
=
newFullscreenDoc
&
&
!
nsContentUtils
:
:
HaveEqualPrincipals
(
fullScreenDoc
newFullscreenDoc
)
)
{
DispatchFullscreenNewOriginEvent
(
newFullscreenDoc
)
;
}
}
static
void
UpdateViewportScrollbarOverrideForFullscreen
(
Document
*
aDoc
)
{
if
(
nsPresContext
*
presContext
=
aDoc
-
>
GetPresContext
(
)
)
{
presContext
-
>
UpdateViewportScrollStylesOverride
(
)
;
}
}
static
void
NotifyFullScreenChangedForMediaElement
(
Element
&
aElement
)
{
if
(
auto
*
mediaElem
=
HTMLMediaElement
:
:
FromNode
(
aElement
)
)
{
mediaElem
-
>
NotifyFullScreenChanged
(
)
;
}
}
void
Document
:
:
CleanupFullscreenState
(
)
{
while
(
PopFullscreenElement
(
UpdateViewport
:
:
No
)
)
{
}
UpdateViewportScrollbarOverrideForFullscreen
(
this
)
;
mFullscreenRoot
=
nullptr
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
if
(
presShell
-
>
GetMobileViewportManager
(
)
)
{
presShell
-
>
SetResolutionAndScaleTo
(
mSavedResolution
ResolutionChangeOrigin
:
:
MainThreadRestore
)
;
}
}
}
bool
Document
:
:
PopFullscreenElement
(
UpdateViewport
aUpdateViewport
)
{
Element
*
removedElement
=
TopLayerPop
(
[
]
(
Element
*
element
)
-
>
bool
{
return
element
-
>
State
(
)
.
HasState
(
ElementState
:
:
FULLSCREEN
)
;
}
)
;
if
(
!
removedElement
)
{
return
false
;
}
MOZ_ASSERT
(
removedElement
-
>
State
(
)
.
HasState
(
ElementState
:
:
FULLSCREEN
)
)
;
removedElement
-
>
RemoveStates
(
ElementState
:
:
FULLSCREEN
|
ElementState
:
:
MODAL
)
;
NotifyFullScreenChangedForMediaElement
(
*
removedElement
)
;
if
(
auto
*
iframe
=
HTMLIFrameElement
:
:
FromNode
(
removedElement
)
)
{
iframe
-
>
SetFullscreenFlag
(
false
)
;
}
if
(
aUpdateViewport
=
=
UpdateViewport
:
:
Yes
)
{
UpdateViewportScrollbarOverrideForFullscreen
(
this
)
;
}
return
true
;
}
void
Document
:
:
SetFullscreenElement
(
Element
&
aElement
)
{
ElementState
statesToAdd
=
ElementState
:
:
FULLSCREEN
;
if
(
!
IsInChromeDocShell
(
)
)
{
statesToAdd
|
=
ElementState
:
:
MODAL
;
}
aElement
.
AddStates
(
statesToAdd
)
;
TopLayerPush
(
aElement
)
;
NotifyFullScreenChangedForMediaElement
(
aElement
)
;
UpdateViewportScrollbarOverrideForFullscreen
(
this
)
;
}
void
Document
:
:
TopLayerPush
(
Element
&
aElement
)
{
const
bool
modal
=
aElement
.
State
(
)
.
HasState
(
ElementState
:
:
MODAL
)
;
TopLayerPop
(
aElement
)
;
mTopLayer
.
AppendElement
(
do_GetWeakReference
(
&
aElement
)
)
;
NS_ASSERTION
(
GetTopLayerTop
(
)
=
=
&
aElement
"
Should
match
"
)
;
if
(
modal
)
{
aElement
.
AddStates
(
ElementState
:
:
TOPMOST_MODAL
)
;
bool
foundExistingModalElement
=
false
;
for
(
const
nsWeakPtr
&
weakPtr
:
Reversed
(
mTopLayer
)
)
{
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
weakPtr
)
)
;
if
(
element
&
&
element
!
=
&
aElement
&
&
element
-
>
State
(
)
.
HasState
(
ElementState
:
:
TOPMOST_MODAL
)
)
{
element
-
>
RemoveStates
(
ElementState
:
:
TOPMOST_MODAL
)
;
foundExistingModalElement
=
true
;
break
;
}
}
if
(
!
foundExistingModalElement
)
{
Element
*
root
=
GetRootElement
(
)
;
MOZ_RELEASE_ASSERT
(
root
"
top
layer
element
outside
of
document
?
"
)
;
if
(
&
aElement
!
=
root
)
{
root
-
>
AddStates
(
ElementState
:
:
INERT
)
;
}
}
}
}
void
Document
:
:
AddModalDialog
(
HTMLDialogElement
&
aDialogElement
)
{
aDialogElement
.
AddStates
(
ElementState
:
:
MODAL
)
;
TopLayerPush
(
aDialogElement
)
;
}
void
Document
:
:
RemoveModalDialog
(
HTMLDialogElement
&
aDialogElement
)
{
DebugOnly
<
Element
*
>
removedElement
=
TopLayerPop
(
aDialogElement
)
;
MOZ_ASSERT
(
removedElement
=
=
&
aDialogElement
)
;
aDialogElement
.
RemoveStates
(
ElementState
:
:
MODAL
)
;
}
Element
*
Document
:
:
TopLayerPop
(
FunctionRef
<
bool
(
Element
*
)
>
aPredicate
)
{
if
(
mTopLayer
.
IsEmpty
(
)
)
{
return
nullptr
;
}
Element
*
removedElement
=
nullptr
;
for
(
auto
i
:
Reversed
(
IntegerRange
(
mTopLayer
.
Length
(
)
)
)
)
{
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
mTopLayer
[
i
]
)
)
;
if
(
element
&
&
aPredicate
(
element
)
)
{
removedElement
=
element
;
mTopLayer
.
RemoveElementAt
(
i
)
;
break
;
}
}
while
(
!
mTopLayer
.
IsEmpty
(
)
)
{
Element
*
element
=
GetTopLayerTop
(
)
;
if
(
!
element
|
|
element
-
>
GetComposedDoc
(
)
!
=
this
)
{
mTopLayer
.
RemoveLastElement
(
)
;
}
else
{
break
;
}
}
if
(
!
removedElement
)
{
return
nullptr
;
}
const
bool
modal
=
removedElement
-
>
State
(
)
.
HasState
(
ElementState
:
:
MODAL
)
;
if
(
modal
)
{
removedElement
-
>
RemoveStates
(
ElementState
:
:
TOPMOST_MODAL
)
;
bool
foundExistingModalElement
=
false
;
for
(
const
nsWeakPtr
&
weakPtr
:
Reversed
(
mTopLayer
)
)
{
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
weakPtr
)
)
;
if
(
element
&
&
element
-
>
State
(
)
.
HasState
(
ElementState
:
:
MODAL
)
)
{
element
-
>
AddStates
(
ElementState
:
:
TOPMOST_MODAL
)
;
foundExistingModalElement
=
true
;
break
;
}
}
if
(
!
foundExistingModalElement
)
{
Element
*
root
=
GetRootElement
(
)
;
if
(
root
&
&
!
root
-
>
GetBoolAttr
(
nsGkAtoms
:
:
inert
)
)
{
root
-
>
RemoveStates
(
ElementState
:
:
INERT
)
;
}
}
}
return
removedElement
;
}
Element
*
Document
:
:
TopLayerPop
(
Element
&
aElement
)
{
auto
predictFunc
=
[
&
aElement
]
(
Element
*
element
)
{
return
element
=
=
&
aElement
;
}
;
return
TopLayerPop
(
predictFunc
)
;
}
void
Document
:
:
GetWireframe
(
bool
aIncludeNodes
Nullable
<
Wireframe
>
&
aWireframe
)
{
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
GetWireframeWithoutFlushing
(
aIncludeNodes
aWireframe
)
;
}
void
Document
:
:
GetWireframeWithoutFlushing
(
bool
aIncludeNodes
Nullable
<
Wireframe
>
&
aWireframe
)
{
using
FrameForPointOptions
=
nsLayoutUtils
:
:
FrameForPointOptions
;
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
PresShell
*
shell
=
GetPresShell
(
)
;
if
(
!
shell
)
{
return
;
}
nsPresContext
*
pc
=
shell
-
>
GetPresContext
(
)
;
if
(
!
pc
)
{
return
;
}
nsIFrame
*
rootFrame
=
shell
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
auto
&
wireframe
=
aWireframe
.
SetValue
(
)
;
wireframe
.
mCanvasBackground
=
shell
-
>
ComputeCanvasBackground
(
)
.
mViewportColor
;
FrameForPointOptions
options
;
options
.
mBits
+
=
FrameForPointOption
:
:
IgnoreCrossDoc
;
options
.
mBits
+
=
FrameForPointOption
:
:
IgnorePaintSuppression
;
options
.
mBits
+
=
FrameForPointOption
:
:
OnlyVisible
;
AutoTArray
<
nsIFrame
*
32
>
frames
;
const
RelativeTo
relativeTo
{
rootFrame
mozilla
:
:
ViewportType
:
:
Layout
}
;
nsLayoutUtils
:
:
GetFramesForArea
(
relativeTo
pc
-
>
GetVisibleArea
(
)
frames
options
)
;
auto
&
rects
=
wireframe
.
mRects
.
Construct
(
)
;
if
(
!
rects
.
SetCapacity
(
frames
.
Length
(
)
fallible
)
)
{
return
;
}
for
(
nsIFrame
*
frame
:
Reversed
(
frames
)
)
{
auto
[
rectColor
rectType
]
=
[
&
]
(
)
-
>
std
:
:
tuple
<
nscolor
WireframeRectType
>
{
if
(
frame
-
>
IsTextFrame
(
)
)
{
return
{
frame
-
>
StyleText
(
)
-
>
mWebkitTextFillColor
.
CalcColor
(
frame
)
WireframeRectType
:
:
Text
}
;
}
if
(
frame
-
>
IsImageFrame
(
)
|
|
frame
-
>
IsSVGOuterSVGFrame
(
)
)
{
return
{
0
WireframeRectType
:
:
Image
}
;
}
if
(
frame
-
>
IsThemed
(
)
)
{
return
{
0
WireframeRectType
:
:
Background
}
;
}
bool
drawImage
=
false
;
bool
drawColor
=
false
;
if
(
const
auto
*
bgStyle
=
nsCSSRendering
:
:
FindBackground
(
frame
)
)
{
const
nscolor
color
=
nsCSSRendering
:
:
DetermineBackgroundColor
(
pc
bgStyle
frame
drawImage
drawColor
)
;
if
(
drawImage
&
&
!
bgStyle
-
>
StyleBackground
(
)
-
>
mImage
.
BottomLayer
(
)
.
mImage
.
IsNone
(
)
)
{
return
{
color
WireframeRectType
:
:
Image
}
;
}
if
(
drawColor
&
&
!
frame
-
>
IsCanvasFrame
(
)
)
{
return
{
color
WireframeRectType
:
:
Background
}
;
}
}
return
{
0
WireframeRectType
:
:
Unknown
}
;
}
(
)
;
if
(
rectType
=
=
WireframeRectType
:
:
Unknown
)
{
continue
;
}
const
auto
r
=
CSSRect
:
:
FromAppUnits
(
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
frame
frame
-
>
GetRectRelativeToSelf
(
)
relativeTo
)
)
;
if
(
(
uint32_t
)
r
.
Area
(
)
<
StaticPrefs
:
:
browser_history_wireframeAreaThreshold
(
)
)
{
continue
;
}
auto
&
taggedRect
=
*
rects
.
AppendElement
(
fallible
)
;
if
(
aIncludeNodes
)
{
if
(
nsIContent
*
c
=
frame
-
>
GetContent
(
)
)
{
taggedRect
.
mNode
.
Construct
(
c
)
;
}
}
taggedRect
.
mX
=
r
.
x
;
taggedRect
.
mY
=
r
.
y
;
taggedRect
.
mWidth
=
r
.
width
;
taggedRect
.
mHeight
=
r
.
height
;
taggedRect
.
mColor
=
rectColor
;
taggedRect
.
mType
.
Construct
(
rectType
)
;
}
}
Element
*
Document
:
:
GetTopLayerTop
(
)
{
if
(
mTopLayer
.
IsEmpty
(
)
)
{
return
nullptr
;
}
uint32_t
last
=
mTopLayer
.
Length
(
)
-
1
;
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
mTopLayer
[
last
]
)
)
;
NS_ASSERTION
(
element
"
Should
have
a
top
layer
element
!
"
)
;
NS_ASSERTION
(
element
-
>
IsInComposedDoc
(
)
"
Top
layer
element
should
be
in
doc
"
)
;
NS_ASSERTION
(
element
-
>
OwnerDoc
(
)
=
=
this
"
Top
layer
element
should
be
in
this
doc
"
)
;
return
element
;
}
Element
*
Document
:
:
GetUnretargetedFullscreenElement
(
)
const
{
for
(
const
nsWeakPtr
&
weakPtr
:
Reversed
(
mTopLayer
)
)
{
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
weakPtr
)
)
;
if
(
element
&
&
element
-
>
State
(
)
.
HasState
(
ElementState
:
:
FULLSCREEN
)
)
{
return
element
;
}
}
return
nullptr
;
}
nsTArray
<
Element
*
>
Document
:
:
GetTopLayer
(
)
const
{
nsTArray
<
Element
*
>
elements
;
for
(
const
nsWeakPtr
&
ptr
:
mTopLayer
)
{
if
(
nsCOMPtr
<
Element
>
elem
=
do_QueryReferent
(
ptr
)
)
{
elements
.
AppendElement
(
elem
)
;
}
}
return
elements
;
}
bool
Document
:
:
TopLayerContains
(
Element
&
aElement
)
const
{
if
(
mTopLayer
.
IsEmpty
(
)
)
{
return
false
;
}
nsWeakPtr
weakElement
=
do_GetWeakReference
(
&
aElement
)
;
return
mTopLayer
.
Contains
(
weakElement
)
;
}
void
Document
:
:
HideAllPopoversUntil
(
nsINode
&
aEndpoint
bool
aFocusPreviousElement
bool
aFireEvents
)
{
auto
closeAllOpenPopovers
=
[
&
aFocusPreviousElement
&
aFireEvents
this
]
(
)
MOZ_CAN_RUN_SCRIPT_FOR_DEFINITION
{
while
(
RefPtr
<
Element
>
topmost
=
GetTopmostAutoPopover
(
)
)
{
HidePopover
(
*
topmost
aFocusPreviousElement
aFireEvents
IgnoreErrors
(
)
)
;
}
}
;
if
(
&
aEndpoint
=
=
this
)
{
closeAllOpenPopovers
(
)
;
return
;
}
auto
needRepeatingHide
=
[
&
]
(
)
{
auto
autoList
=
AutoPopoverList
(
)
;
return
autoList
.
Contains
(
&
aEndpoint
)
&
&
&
aEndpoint
!
=
autoList
.
LastElement
(
)
;
}
;
MOZ_ASSERT
(
(
&
aEndpoint
)
-
>
IsElement
(
)
&
&
(
&
aEndpoint
)
-
>
AsElement
(
)
-
>
IsAutoPopover
(
)
)
;
bool
repeatingHide
=
false
;
bool
fireEvents
=
aFireEvents
;
do
{
RefPtr
<
const
Element
>
lastToHide
=
nullptr
;
bool
foundEndpoint
=
false
;
for
(
const
Element
*
popover
:
AutoPopoverList
(
)
)
{
if
(
popover
=
=
&
aEndpoint
)
{
foundEndpoint
=
true
;
}
else
if
(
foundEndpoint
)
{
lastToHide
=
popover
;
break
;
}
}
if
(
!
foundEndpoint
)
{
closeAllOpenPopovers
(
)
;
return
;
}
while
(
lastToHide
&
&
lastToHide
-
>
IsPopoverOpen
(
)
)
{
RefPtr
<
Element
>
topmost
=
GetTopmostAutoPopover
(
)
;
if
(
!
topmost
)
{
break
;
}
HidePopover
(
*
topmost
aFocusPreviousElement
fireEvents
IgnoreErrors
(
)
)
;
}
repeatingHide
=
needRepeatingHide
(
)
;
if
(
repeatingHide
)
{
fireEvents
=
false
;
}
}
while
(
repeatingHide
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Document
:
:
HideAllPopoversWithoutRunningScript
(
)
{
return
HideAllPopoversUntil
(
*
this
false
false
)
;
}
void
Document
:
:
HidePopover
(
Element
&
aPopover
bool
aFocusPreviousElement
bool
aFireEvents
ErrorResult
&
aRv
)
{
RefPtr
<
nsGenericHTMLElement
>
popoverHTMLEl
=
nsGenericHTMLElement
:
:
FromNode
(
aPopover
)
;
NS_ASSERTION
(
popoverHTMLEl
"
Not
a
HTML
element
"
)
;
if
(
!
popoverHTMLEl
-
>
CheckPopoverValidity
(
PopoverVisibilityState
:
:
Showing
nullptr
aRv
)
)
{
return
;
}
bool
wasShowingOrHiding
=
popoverHTMLEl
-
>
GetPopoverData
(
)
-
>
IsShowingOrHiding
(
)
;
popoverHTMLEl
-
>
GetPopoverData
(
)
-
>
SetIsShowingOrHiding
(
true
)
;
const
bool
fireEvents
=
aFireEvents
&
&
!
wasShowingOrHiding
;
auto
cleanupHidingFlag
=
MakeScopeExit
(
[
&
]
(
)
{
if
(
auto
*
popoverData
=
popoverHTMLEl
-
>
GetPopoverData
(
)
)
{
popoverData
-
>
SetIsShowingOrHiding
(
wasShowingOrHiding
)
;
}
}
)
;
if
(
popoverHTMLEl
-
>
IsAutoPopover
(
)
)
{
HideAllPopoversUntil
(
*
popoverHTMLEl
aFocusPreviousElement
fireEvents
)
;
if
(
!
popoverHTMLEl
-
>
CheckPopoverValidity
(
PopoverVisibilityState
:
:
Showing
nullptr
aRv
)
)
{
return
;
}
if
(
NS_WARN_IF
(
GetTopmostAutoPopover
(
)
!
=
popoverHTMLEl
)
)
{
HideAllPopoversUntil
(
*
popoverHTMLEl
aFocusPreviousElement
false
)
;
if
(
!
popoverHTMLEl
-
>
CheckPopoverValidity
(
PopoverVisibilityState
:
:
Showing
nullptr
aRv
)
)
{
return
;
}
MOZ_ASSERT
(
GetTopmostAutoPopover
(
)
=
=
popoverHTMLEl
"
popoverHTMLEl
should
be
on
top
of
auto
popover
list
"
)
;
}
}
auto
*
data
=
popoverHTMLEl
-
>
GetPopoverData
(
)
;
MOZ_ASSERT
(
data
"
Should
have
popover
data
"
)
;
data
-
>
SetInvoker
(
nullptr
)
;
if
(
fireEvents
)
{
popoverHTMLEl
-
>
FireToggleEvent
(
PopoverVisibilityState
:
:
Showing
PopoverVisibilityState
:
:
Hidden
u
"
beforetoggle
"
_ns
)
;
if
(
!
popoverHTMLEl
-
>
CheckPopoverValidity
(
PopoverVisibilityState
:
:
Showing
nullptr
aRv
)
)
{
return
;
}
}
RemovePopoverFromTopLayer
(
aPopover
)
;
popoverHTMLEl
-
>
PopoverPseudoStateUpdate
(
false
true
)
;
popoverHTMLEl
-
>
GetPopoverData
(
)
-
>
SetPopoverVisibilityState
(
PopoverVisibilityState
:
:
Hidden
)
;
if
(
fireEvents
)
{
popoverHTMLEl
-
>
QueuePopoverEventTask
(
PopoverVisibilityState
:
:
Showing
)
;
}
if
(
aFocusPreviousElement
)
{
popoverHTMLEl
-
>
FocusPreviousElementAfterHidingPopover
(
)
;
}
else
{
popoverHTMLEl
-
>
ForgetPreviouslyFocusedElementAfterHidingPopover
(
)
;
}
}
nsTArray
<
Element
*
>
Document
:
:
AutoPopoverList
(
)
const
{
nsTArray
<
Element
*
>
elements
;
for
(
const
nsWeakPtr
&
ptr
:
mTopLayer
)
{
if
(
nsCOMPtr
<
Element
>
element
=
do_QueryReferent
(
ptr
)
)
{
if
(
element
&
&
element
-
>
IsAutoPopover
(
)
&
&
element
-
>
IsPopoverOpen
(
)
)
{
elements
.
AppendElement
(
element
)
;
}
}
}
return
elements
;
}
Element
*
Document
:
:
GetTopmostAutoPopover
(
)
const
{
for
(
const
nsWeakPtr
&
weakPtr
:
Reversed
(
mTopLayer
)
)
{
nsCOMPtr
<
Element
>
element
(
do_QueryReferent
(
weakPtr
)
)
;
if
(
element
&
&
element
-
>
IsAutoPopover
(
)
&
&
element
-
>
IsPopoverOpen
(
)
)
{
return
element
;
}
}
return
nullptr
;
}
void
Document
:
:
AddToAutoPopoverList
(
Element
&
aElement
)
{
MOZ_ASSERT
(
aElement
.
IsAutoPopover
(
)
)
;
TopLayerPush
(
aElement
)
;
}
void
Document
:
:
RemoveFromAutoPopoverList
(
Element
&
aElement
)
{
MOZ_ASSERT
(
aElement
.
IsAutoPopover
(
)
)
;
TopLayerPop
(
aElement
)
;
}
void
Document
:
:
AddPopoverToTopLayer
(
Element
&
aElement
)
{
MOZ_ASSERT
(
aElement
.
GetPopoverData
(
)
)
;
TopLayerPush
(
aElement
)
;
}
void
Document
:
:
RemovePopoverFromTopLayer
(
Element
&
aElement
)
{
MOZ_ASSERT
(
aElement
.
GetPopoverData
(
)
)
;
TopLayerPop
(
aElement
)
;
}
bool
IsInFocusedTab
(
Document
*
aDoc
)
{
BrowsingContext
*
bc
=
aDoc
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
false
;
}
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
{
return
false
;
}
if
(
XRE_IsParentProcess
(
)
)
{
nsIDocShell
*
docshell
=
aDoc
-
>
GetDocShell
(
)
;
if
(
!
docshell
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
docshell
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
if
(
!
rootItem
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
rootItem
-
>
GetWindow
(
)
;
if
(
!
rootWin
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
activeWindow
;
activeWindow
=
fm
-
>
GetActiveWindow
(
)
;
if
(
!
activeWindow
)
{
return
false
;
}
return
activeWindow
=
=
rootWin
;
}
return
fm
-
>
GetActiveBrowsingContext
(
)
=
=
bc
-
>
Top
(
)
;
}
bool
IsInActiveTab
(
Document
*
aDoc
)
{
if
(
!
IsInFocusedTab
(
aDoc
)
)
{
return
false
;
}
BrowsingContext
*
bc
=
aDoc
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
bc
"
With
no
BrowsingContext
we
should
have
failed
earlier
.
"
)
;
return
bc
-
>
IsActive
(
)
;
}
void
Document
:
:
RemoteFrameFullscreenChanged
(
Element
*
aFrameElement
)
{
auto
request
=
FullscreenRequest
:
:
CreateForRemote
(
aFrameElement
)
;
RequestFullscreen
(
std
:
:
move
(
request
)
XRE_IsContentProcess
(
)
)
;
}
void
Document
:
:
RemoteFrameFullscreenReverted
(
)
{
UniquePtr
<
FullscreenExit
>
exit
=
FullscreenExit
:
:
CreateForRemote
(
this
)
;
RestorePreviousFullscreenState
(
std
:
:
move
(
exit
)
)
;
}
static
bool
HasFullscreenSubDocument
(
Document
&
aDoc
)
{
uint32_t
count
=
CountFullscreenSubDocuments
(
aDoc
)
;
NS_ASSERTION
(
count
<
=
1
"
Fullscreen
docs
should
have
at
most
1
fullscreen
child
!
"
)
;
return
count
>
=
1
;
}
const
char
*
Document
:
:
GetFullscreenError
(
CallerType
aCallerType
)
{
if
(
!
StaticPrefs
:
:
full_screen_api_enabled
(
)
)
{
return
"
FullscreenDeniedDisabled
"
;
}
if
(
aCallerType
=
=
CallerType
:
:
System
)
{
return
nullptr
;
}
if
(
!
IsVisible
(
)
)
{
return
"
FullscreenDeniedHidden
"
;
}
if
(
!
FeaturePolicyUtils
:
:
IsFeatureAllowed
(
this
u
"
fullscreen
"
_ns
)
)
{
return
"
FullscreenDeniedFeaturePolicy
"
;
}
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
;
if
(
!
bc
|
|
!
bc
-
>
FullscreenAllowed
(
)
)
{
return
"
FullscreenDeniedContainerNotAllowed
"
;
}
return
nullptr
;
}
bool
Document
:
:
FullscreenElementReadyCheck
(
FullscreenRequest
&
aRequest
)
{
Element
*
elem
=
aRequest
.
Element
(
)
;
Element
*
fullscreenElement
=
GetUnretargetedFullscreenElement
(
)
;
if
(
elem
=
=
fullscreenElement
)
{
aRequest
.
MayResolvePromise
(
)
;
return
false
;
}
if
(
!
elem
-
>
IsInComposedDoc
(
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedNotInDocument
"
)
;
return
false
;
}
if
(
elem
-
>
IsPopoverOpen
(
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedPopoverOpen
"
)
;
return
false
;
}
if
(
elem
-
>
OwnerDoc
(
)
!
=
this
)
{
aRequest
.
Reject
(
"
FullscreenDeniedMovedDocument
"
)
;
return
false
;
}
if
(
!
GetWindow
(
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedLostWindow
"
)
;
return
false
;
}
if
(
const
char
*
msg
=
GetFullscreenError
(
aRequest
.
mCallerType
)
)
{
aRequest
.
Reject
(
msg
)
;
return
false
;
}
if
(
HasFullscreenSubDocument
(
*
this
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedSubDocFullScreen
"
)
;
return
false
;
}
if
(
elem
-
>
IsHTMLElement
(
nsGkAtoms
:
:
dialog
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedHTMLDialog
"
)
;
return
false
;
}
if
(
!
nsContentUtils
:
:
IsChromeDoc
(
this
)
&
&
!
IsInFocusedTab
(
this
)
)
{
aRequest
.
Reject
(
"
FullscreenDeniedNotFocusedTab
"
)
;
return
false
;
}
return
true
;
}
static
nsCOMPtr
<
nsPIDOMWindowOuter
>
GetRootWindow
(
Document
*
aDoc
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsIDocShell
*
docShell
=
aDoc
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
rootItem
;
docShell
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
rootItem
)
)
;
return
rootItem
?
rootItem
-
>
GetWindow
(
)
:
nullptr
;
}
static
bool
ShouldApplyFullscreenDirectly
(
Document
*
aDoc
nsPIDOMWindowOuter
*
aRootWin
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
if
(
!
aRootWin
-
>
GetFullScreen
(
)
)
{
return
false
;
}
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenRequest
>
iter
(
aDoc
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
if
(
!
iter
.
AtEnd
(
)
)
{
return
false
;
}
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenExit
>
iterExit
(
aDoc
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
if
(
!
iterExit
.
AtEnd
(
)
)
{
return
false
;
}
return
true
;
}
static
bool
CheckFullscreenAllowedElementType
(
const
Element
*
elem
)
{
return
elem
-
>
IsHTMLElement
(
)
|
|
elem
-
>
IsXULElement
(
)
|
|
elem
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
|
|
elem
-
>
IsMathMLElement
(
nsGkAtoms
:
:
math
)
;
}
void
Document
:
:
RequestFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
bool
aApplyFullscreenDirectly
)
{
if
(
XRE_IsContentProcess
(
)
)
{
RequestFullscreenInContentProcess
(
std
:
:
move
(
aRequest
)
aApplyFullscreenDirectly
)
;
}
else
{
RequestFullscreenInParentProcess
(
std
:
:
move
(
aRequest
)
aApplyFullscreenDirectly
)
;
}
}
void
Document
:
:
RequestFullscreenInContentProcess
(
UniquePtr
<
FullscreenRequest
>
aRequest
bool
aApplyFullscreenDirectly
)
{
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
if
(
aApplyFullscreenDirectly
|
|
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
this
)
-
>
Fullscreen
(
)
)
{
ApplyFullscreen
(
std
:
:
move
(
aRequest
)
)
;
return
;
}
if
(
!
CheckFullscreenAllowedElementType
(
aRequest
-
>
Element
(
)
)
)
{
aRequest
-
>
Reject
(
"
FullscreenDeniedNotHTMLSVGOrMathML
"
)
;
return
;
}
if
(
!
FullscreenElementReadyCheck
(
*
aRequest
)
)
{
return
;
}
PendingFullscreenChangeList
:
:
Add
(
std
:
:
move
(
aRequest
)
)
;
Dispatch
(
NS_NewRunnableFunction
(
"
Document
:
:
RequestFullscreenInContentProcess
"
[
self
=
RefPtr
{
this
}
]
{
if
(
!
self
-
>
HasPendingFullscreenRequests
(
)
)
{
return
;
}
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
self
self
u
"
MozDOMFullscreen
:
Request
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
}
)
)
;
}
void
Document
:
:
RequestFullscreenInParentProcess
(
UniquePtr
<
FullscreenRequest
>
aRequest
bool
aApplyFullscreenDirectly
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
GetRootWindow
(
this
)
;
if
(
!
rootWin
)
{
aRequest
-
>
MayRejectPromise
(
"
No
active
window
"
)
;
return
;
}
if
(
aApplyFullscreenDirectly
|
|
ShouldApplyFullscreenDirectly
(
this
rootWin
)
)
{
ApplyFullscreen
(
std
:
:
move
(
aRequest
)
)
;
return
;
}
if
(
!
CheckFullscreenAllowedElementType
(
aRequest
-
>
Element
(
)
)
)
{
aRequest
-
>
Reject
(
"
FullscreenDeniedNotHTMLSVGOrMathML
"
)
;
return
;
}
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenExit
>
iter
(
this
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
if
(
!
iter
.
AtEnd
(
)
)
{
PendingFullscreenChangeList
:
:
Add
(
std
:
:
move
(
aRequest
)
)
;
rootWin
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenAPI
true
)
;
return
;
}
if
(
!
FullscreenElementReadyCheck
(
*
aRequest
)
)
{
return
;
}
PendingFullscreenChangeList
:
:
Add
(
std
:
:
move
(
aRequest
)
)
;
rootWin
-
>
SetFullscreenInternal
(
FullscreenReason
:
:
ForFullscreenAPI
true
)
;
}
bool
Document
:
:
HandlePendingFullscreenRequests
(
Document
*
aDoc
)
{
bool
handled
=
false
;
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenRequest
>
iter
(
aDoc
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
while
(
!
iter
.
AtEnd
(
)
)
{
UniquePtr
<
FullscreenRequest
>
request
=
iter
.
TakeAndNext
(
)
;
Document
*
doc
=
request
-
>
Document
(
)
;
if
(
doc
-
>
ApplyFullscreen
(
std
:
:
move
(
request
)
)
)
{
handled
=
true
;
}
}
return
handled
;
}
void
Document
:
:
ClearPendingFullscreenRequests
(
Document
*
aDoc
)
{
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenRequest
>
iter
(
aDoc
PendingFullscreenChangeList
:
:
eInclusiveDescendants
)
;
while
(
!
iter
.
AtEnd
(
)
)
{
UniquePtr
<
FullscreenRequest
>
request
=
iter
.
TakeAndNext
(
)
;
request
-
>
MayRejectPromise
(
"
Fullscreen
request
aborted
"
)
;
}
}
bool
Document
:
:
HasPendingFullscreenRequests
(
)
{
PendingFullscreenChangeList
:
:
Iterator
<
FullscreenRequest
>
iter
(
this
PendingFullscreenChangeList
:
:
eDocumentsWithSameRoot
)
;
return
!
iter
.
AtEnd
(
)
;
}
bool
Document
:
:
ApplyFullscreen
(
UniquePtr
<
FullscreenRequest
>
aRequest
)
{
if
(
!
FullscreenElementReadyCheck
(
*
aRequest
)
)
{
return
false
;
}
RefPtr
<
Document
>
doc
=
aRequest
-
>
Document
(
)
;
doc
-
>
HideAllPopoversWithoutRunningScript
(
)
;
nsCOMPtr
<
Document
>
previousFullscreenDoc
=
GetFullscreenLeaf
(
this
)
;
AutoTArray
<
Document
*
8
>
changed
;
Document
*
fullScreenRootDoc
=
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
this
)
;
PointerLockManager
:
:
Unlock
(
)
;
Element
*
elem
=
aRequest
-
>
Element
(
)
;
SetFullscreenElement
(
*
elem
)
;
if
(
auto
*
iframe
=
HTMLIFrameElement
:
:
FromNode
(
elem
)
)
{
iframe
-
>
SetFullscreenFlag
(
true
)
;
}
changed
.
AppendElement
(
this
)
;
Document
*
child
=
this
;
while
(
true
)
{
child
-
>
SetFullscreenRoot
(
fullScreenRootDoc
)
;
if
(
PresShell
*
presShell
=
child
-
>
GetPresShell
(
)
)
{
if
(
RefPtr
<
MobileViewportManager
>
manager
=
presShell
-
>
GetMobileViewportManager
(
)
)
{
child
-
>
mSavedResolution
=
presShell
-
>
GetResolution
(
)
;
presShell
-
>
SetResolutionAndScaleTo
(
manager
-
>
ComputeIntrinsicResolution
(
)
ResolutionChangeOrigin
:
:
MainThreadRestore
)
;
}
}
NS_ASSERTION
(
child
-
>
GetFullscreenRoot
(
)
=
=
fullScreenRootDoc
"
Fullscreen
root
should
be
set
!
"
)
;
if
(
child
=
=
fullScreenRootDoc
)
{
break
;
}
Element
*
element
=
child
-
>
GetEmbedderElement
(
)
;
if
(
!
element
)
{
break
;
}
Document
*
parent
=
child
-
>
GetInProcessParentDocument
(
)
;
parent
-
>
SetFullscreenElement
(
*
element
)
;
changed
.
AppendElement
(
parent
)
;
child
=
parent
;
}
FullscreenRoots
:
:
Add
(
this
)
;
if
(
!
previousFullscreenDoc
)
{
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
this
elem
u
"
MozDOMFullscreen
:
Entered
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
nullptr
)
;
}
if
(
aRequest
-
>
mShouldNotifyNewOrigin
&
&
previousFullscreenDoc
&
&
!
nsContentUtils
:
:
HaveEqualPrincipals
(
previousFullscreenDoc
this
)
)
{
DispatchFullscreenNewOriginEvent
(
this
)
;
}
for
(
Document
*
d
:
Reversed
(
changed
)
)
{
DispatchFullscreenChange
(
*
d
d
-
>
GetUnretargetedFullscreenElement
(
)
)
;
}
aRequest
-
>
MayResolvePromise
(
)
;
return
true
;
}
void
Document
:
:
ClearOrientationPendingPromise
(
)
{
mOrientationPendingPromise
=
nullptr
;
}
bool
Document
:
:
SetOrientationPendingPromise
(
Promise
*
aPromise
)
{
if
(
mIsGoingAway
)
{
return
false
;
}
mOrientationPendingPromise
=
aPromise
;
return
true
;
}
void
Document
:
:
UpdateVisibilityState
(
DispatchVisibilityChange
aDispatchEvent
)
{
dom
:
:
VisibilityState
oldState
=
mVisibilityState
;
mVisibilityState
=
ComputeVisibilityState
(
)
;
if
(
oldState
!
=
mVisibilityState
)
{
if
(
aDispatchEvent
=
=
DispatchVisibilityChange
:
:
Yes
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
this
this
u
"
visibilitychange
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
NotifyActivityChanged
(
)
;
if
(
mVisibilityState
=
=
dom
:
:
VisibilityState
:
:
Visible
)
{
MaybeActiveMediaComponents
(
)
;
}
bool
visible
=
!
Hidden
(
)
;
for
(
auto
*
listener
:
mWorkerListeners
)
{
listener
-
>
OnVisible
(
visible
)
;
}
}
}
void
Document
:
:
AddWorkerDocumentListener
(
WorkerDocumentListener
*
aListener
)
{
mWorkerListeners
.
Insert
(
aListener
)
;
aListener
-
>
OnVisible
(
!
Hidden
(
)
)
;
}
void
Document
:
:
RemoveWorkerDocumentListener
(
WorkerDocumentListener
*
aListener
)
{
mWorkerListeners
.
Remove
(
aListener
)
;
}
VisibilityState
Document
:
:
ComputeVisibilityState
(
)
const
{
if
(
!
IsVisible
(
)
|
|
!
mWindow
|
|
!
mWindow
-
>
GetOuterWindow
(
)
|
|
mWindow
-
>
GetOuterWindow
(
)
-
>
IsBackground
(
)
)
{
return
dom
:
:
VisibilityState
:
:
Hidden
;
}
return
dom
:
:
VisibilityState
:
:
Visible
;
}
void
Document
:
:
PostVisibilityUpdateEvent
(
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
NewRunnableMethod
<
DispatchVisibilityChange
>
(
"
Document
:
:
UpdateVisibilityState
"
this
&
Document
:
:
UpdateVisibilityState
DispatchVisibilityChange
:
:
Yes
)
;
Dispatch
(
event
.
forget
(
)
)
;
}
void
Document
:
:
MaybeActiveMediaComponents
(
)
{
auto
*
window
=
GetWindow
(
)
;
if
(
!
window
|
|
!
window
-
>
ShouldDelayMediaFromStart
(
)
)
{
return
;
}
window
-
>
ActivateMediaComponents
(
)
;
}
void
Document
:
:
DocAddSizeOfExcludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
nsINode
:
:
AddSizeOfExcludingThis
(
aWindowSizes
&
aWindowSizes
.
mDOMSizes
.
mDOMOtherSize
)
;
for
(
nsIContent
*
kid
=
GetFirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
AddSizeOfNodeTree
(
*
kid
aWindowSizes
)
;
}
if
(
mPresShell
)
{
mPresShell
-
>
AddSizeOfIncludingThis
(
aWindowSizes
)
;
}
if
(
mStyleSet
)
{
mStyleSet
-
>
AddSizeOfIncludingThis
(
aWindowSizes
)
;
}
aWindowSizes
.
mPropertyTablesSize
+
=
mPropertyTable
.
SizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
if
(
EventListenerManager
*
elm
=
GetExistingListenerManager
(
)
)
{
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
if
(
mNodeInfoManager
)
{
mNodeInfoManager
-
>
AddSizeOfIncludingThis
(
aWindowSizes
)
;
}
aWindowSizes
.
mDOMSizes
.
mDOMMediaQueryLists
+
=
mDOMMediaQueryLists
.
sizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
for
(
const
MediaQueryList
*
mql
:
mDOMMediaQueryLists
)
{
aWindowSizes
.
mDOMSizes
.
mDOMMediaQueryLists
+
=
mql
-
>
SizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
DocumentOrShadowRoot
:
:
AddSizeOfExcludingThis
(
aWindowSizes
)
;
for
(
auto
&
sheetArray
:
mAdditionalSheets
)
{
AddSizeOfOwnedSheetArrayExcludingThis
(
aWindowSizes
sheetArray
)
;
}
if
(
mCSSLoader
)
{
aWindowSizes
.
mLayoutStyleSheetsSize
+
=
mCSSLoader
-
>
SizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
aWindowSizes
.
mDOMSizes
.
mDOMResizeObserverControllerSize
+
=
mResizeObservers
.
ShallowSizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
if
(
mAttributeStyles
)
{
aWindowSizes
.
mDOMSizes
.
mDOMOtherSize
+
=
mAttributeStyles
-
>
DOMSizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
if
(
mRadioGroupContainer
)
{
aWindowSizes
.
mDOMSizes
.
mDOMOtherSize
+
=
mRadioGroupContainer
-
>
SizeOfIncludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
aWindowSizes
.
mDOMSizes
.
mDOMOtherSize
+
=
mStyledLinks
.
ShallowSizeOfExcludingThis
(
aWindowSizes
.
mState
.
mMallocSizeOf
)
;
}
void
Document
:
:
DocAddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
{
aWindowSizes
.
mDOMSizes
.
mDOMOtherSize
+
=
aWindowSizes
.
mState
.
mMallocSizeOf
(
this
)
;
DocAddSizeOfExcludingThis
(
aWindowSizes
)
;
}
void
Document
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
size_t
*
aNodeSize
)
const
{
MOZ_CRASH
(
)
;
}
void
Document
:
:
AddSizeOfNodeTree
(
nsINode
&
aNode
nsWindowSizes
&
aWindowSizes
)
{
size_t
nodeSize
=
0
;
aNode
.
AddSizeOfIncludingThis
(
aWindowSizes
&
nodeSize
)
;
switch
(
aNode
.
NodeType
(
)
)
{
case
nsINode
:
:
ELEMENT_NODE
:
aWindowSizes
.
mDOMSizes
.
mDOMElementNodesSize
+
=
nodeSize
;
break
;
case
nsINode
:
:
TEXT_NODE
:
aWindowSizes
.
mDOMSizes
.
mDOMTextNodesSize
+
=
nodeSize
;
break
;
case
nsINode
:
:
CDATA_SECTION_NODE
:
aWindowSizes
.
mDOMSizes
.
mDOMCDATANodesSize
+
=
nodeSize
;
break
;
case
nsINode
:
:
COMMENT_NODE
:
aWindowSizes
.
mDOMSizes
.
mDOMCommentNodesSize
+
=
nodeSize
;
break
;
default
:
aWindowSizes
.
mDOMSizes
.
mDOMOtherSize
+
=
nodeSize
;
break
;
}
if
(
EventListenerManager
*
elm
=
aNode
.
GetExistingListenerManager
(
)
)
{
aWindowSizes
.
mDOMEventListenersCount
+
=
elm
-
>
ListenerCount
(
)
;
}
if
(
aNode
.
IsContent
(
)
)
{
nsTArray
<
nsIContent
*
>
anonKids
;
nsContentUtils
:
:
AppendNativeAnonymousChildren
(
aNode
.
AsContent
(
)
anonKids
nsIContent
:
:
eAllChildren
)
;
for
(
nsIContent
*
anonKid
:
anonKids
)
{
AddSizeOfNodeTree
(
*
anonKid
aWindowSizes
)
;
}
if
(
auto
*
element
=
Element
:
:
FromNode
(
aNode
)
)
{
if
(
ShadowRoot
*
shadow
=
element
-
>
GetShadowRoot
(
)
)
{
AddSizeOfNodeTree
(
*
shadow
aWindowSizes
)
;
}
}
}
for
(
nsIContent
*
kid
=
aNode
.
GetFirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
AddSizeOfNodeTree
(
*
kid
aWindowSizes
)
;
}
}
already_AddRefed
<
Document
>
Document
:
:
Constructor
(
const
GlobalObject
&
aGlobal
ErrorResult
&
rv
)
{
nsCOMPtr
<
nsIScriptGlobalObject
>
global
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
global
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIScriptObjectPrincipal
>
prin
=
do_QueryInterface
(
aGlobal
.
GetAsSupports
(
)
)
;
if
(
!
prin
)
{
rv
.
Throw
(
NS_ERROR_UNEXPECTED
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
;
NS_NewURI
(
getter_AddRefs
(
uri
)
"
about
:
blank
"
)
;
if
(
!
uri
)
{
rv
.
Throw
(
NS_ERROR_OUT_OF_MEMORY
)
;
return
nullptr
;
}
nsCOMPtr
<
Document
>
doc
;
nsresult
res
=
NS_NewDOMDocument
(
getter_AddRefs
(
doc
)
VoidString
(
)
u
"
"
_ns
nullptr
uri
uri
prin
-
>
GetPrincipal
(
)
true
global
DocumentFlavorPlain
)
;
if
(
NS_FAILED
(
res
)
)
{
rv
.
Throw
(
res
)
;
return
nullptr
;
}
doc
-
>
SetReadyStateInternal
(
Document
:
:
READYSTATE_COMPLETE
)
;
return
doc
.
forget
(
)
;
}
XPathExpression
*
Document
:
:
CreateExpression
(
const
nsAString
&
aExpression
XPathNSResolver
*
aResolver
ErrorResult
&
rv
)
{
return
XPathEvaluator
(
)
-
>
CreateExpression
(
aExpression
aResolver
rv
)
;
}
nsINode
*
Document
:
:
CreateNSResolver
(
nsINode
&
aNodeResolver
)
{
return
XPathEvaluator
(
)
-
>
CreateNSResolver
(
aNodeResolver
)
;
}
already_AddRefed
<
XPathResult
>
Document
:
:
Evaluate
(
JSContext
*
aCx
const
nsAString
&
aExpression
nsINode
&
aContextNode
XPathNSResolver
*
aResolver
uint16_t
aType
JS
:
:
Handle
<
JSObject
*
>
aResult
ErrorResult
&
rv
)
{
return
XPathEvaluator
(
)
-
>
Evaluate
(
aCx
aExpression
aContextNode
aResolver
aType
aResult
rv
)
;
}
already_AddRefed
<
nsIAppWindow
>
Document
:
:
GetAppWindowIfToplevelChrome
(
)
const
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
=
GetDocShell
(
)
;
if
(
!
item
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
;
item
-
>
GetTreeOwner
(
getter_AddRefs
(
owner
)
)
;
nsCOMPtr
<
nsIAppWindow
>
appWin
=
do_GetInterface
(
owner
)
;
if
(
!
appWin
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
appWinShell
;
appWin
-
>
GetDocShell
(
getter_AddRefs
(
appWinShell
)
)
;
if
(
!
SameCOMIdentity
(
appWinShell
item
)
)
{
return
nullptr
;
}
return
appWin
.
forget
(
)
;
}
WindowContext
*
Document
:
:
GetTopLevelWindowContext
(
)
const
{
WindowContext
*
windowContext
=
GetWindowContext
(
)
;
return
windowContext
?
windowContext
-
>
TopWindowContext
(
)
:
nullptr
;
}
Document
*
Document
:
:
GetTopLevelContentDocumentIfSameProcess
(
)
{
Document
*
parent
;
if
(
!
mLoadedAsData
)
{
parent
=
this
;
}
else
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
GetScopeObject
(
)
)
;
if
(
!
window
)
{
return
nullptr
;
}
parent
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
}
do
{
if
(
parent
-
>
IsTopLevelContentDocument
(
)
)
{
break
;
}
if
(
!
parent
-
>
IsContentDocument
(
)
)
{
return
nullptr
;
}
parent
=
parent
-
>
GetInProcessParentDocument
(
)
;
}
while
(
parent
)
;
return
parent
;
}
const
Document
*
Document
:
:
GetTopLevelContentDocumentIfSameProcess
(
)
const
{
return
const_cast
<
Document
*
>
(
this
)
-
>
GetTopLevelContentDocumentIfSameProcess
(
)
;
}
void
Document
:
:
PropagateImageUseCounters
(
Document
*
aReferencingDocument
)
{
MOZ_ASSERT
(
IsBeingUsedAsImage
(
)
)
;
MOZ_ASSERT
(
aReferencingDocument
)
;
if
(
!
aReferencingDocument
-
>
mShouldReportUseCounters
)
{
return
;
}
MOZ_LOG
(
gUseCountersLog
LogLevel
:
:
Debug
(
"
PropagateImageUseCounters
from
%
s
to
%
s
"
nsContentUtils
:
:
TruncatedURLForDisplay
(
mDocumentURI
)
.
get
(
)
nsContentUtils
:
:
TruncatedURLForDisplay
(
aReferencingDocument
-
>
mDocumentURI
)
.
get
(
)
)
)
;
if
(
aReferencingDocument
-
>
IsBeingUsedAsImage
(
)
)
{
NS_WARNING
(
"
Page
use
counters
from
nested
image
documents
may
not
"
"
propagate
to
the
top
-
level
document
(
bug
1657805
)
"
)
;
}
SetCssUseCounterBits
(
)
;
aReferencingDocument
-
>
mChildDocumentUseCounters
|
=
mUseCounters
;
aReferencingDocument
-
>
mChildDocumentUseCounters
|
=
mChildDocumentUseCounters
;
}
bool
Document
:
:
HasScriptsBlockedBySandbox
(
)
const
{
return
mSandboxFlags
&
SANDBOXED_SCRIPTS
;
}
static_assert
(
size_t
(
eUseCounter_EndCSSProperties
)
-
size_t
(
eUseCounter_FirstCSSProperty
)
=
=
size_t
(
eCSSProperty_COUNT_with_aliases
)
"
We
should
have
the
right
amount
of
CSS
property
use
counters
"
)
;
static_assert
(
size_t
(
eUseCounter_Count
)
-
size_t
(
eUseCounter_FirstCountedUnknownProperty
)
=
=
size_t
(
CountedUnknownProperty
:
:
Count
)
"
We
should
have
the
right
amount
of
counted
unknown
properties
"
"
use
counters
"
)
;
static_assert
(
size_t
(
eUseCounter_Count
)
*
2
=
=
size_t
(
Telemetry
:
:
HistogramUseCounterCount
)
"
There
should
be
two
histograms
(
document
and
page
)
"
"
for
each
use
counter
"
)
;
#
define
ASSERT_CSS_COUNTER
(
id_
method_
)
\
static_assert
(
size_t
(
eUseCounter_property_
#
#
method_
)
-
\
size_t
(
eUseCounter_FirstCSSProperty
)
=
=
\
size_t
(
id_
)
\
"
Order
for
CSS
counters
and
CSS
property
id
should
match
"
)
;
#
define
CSS_PROP_PUBLIC_OR_PRIVATE
(
publicname_
privatename_
)
privatename_
#
define
CSS_PROP_LONGHAND
(
name_
id_
method_
.
.
.
)
\
ASSERT_CSS_COUNTER
(
eCSSProperty_
#
#
id_
method_
)
#
define
CSS_PROP_SHORTHAND
(
name_
id_
method_
.
.
.
)
\
ASSERT_CSS_COUNTER
(
eCSSProperty_
#
#
id_
method_
)
#
define
CSS_PROP_ALIAS
(
name_
aliasid_
id_
method_
.
.
.
)
\
ASSERT_CSS_COUNTER
(
eCSSPropertyAlias_
#
#
aliasid_
method_
)
#
include
"
mozilla
/
ServoCSSPropList
.
h
"
#
undef
CSS_PROP_ALIAS
#
undef
CSS_PROP_SHORTHAND
#
undef
CSS_PROP_LONGHAND
#
undef
CSS_PROP_PUBLIC_OR_PRIVATE
#
undef
ASSERT_CSS_COUNTER
void
Document
:
:
SetCssUseCounterBits
(
)
{
if
(
StaticPrefs
:
:
layout_css_use_counters_enabled
(
)
)
{
for
(
size_t
i
=
0
;
i
<
eCSSProperty_COUNT_with_aliases
;
+
+
i
)
{
auto
id
=
nsCSSPropertyID
(
i
)
;
if
(
Servo_IsPropertyIdRecordedInUseCounter
(
mStyleUseCounters
.
get
(
)
id
)
)
{
SetUseCounter
(
nsCSSProps
:
:
UseCounterFor
(
id
)
)
;
}
}
}
if
(
StaticPrefs
:
:
layout_css_use_counters_unimplemented_enabled
(
)
)
{
for
(
size_t
i
=
0
;
i
<
size_t
(
CountedUnknownProperty
:
:
Count
)
;
+
+
i
)
{
auto
id
=
CountedUnknownProperty
(
i
)
;
if
(
Servo_IsUnknownPropertyRecordedInUseCounter
(
mStyleUseCounters
.
get
(
)
id
)
)
{
SetUseCounter
(
UseCounter
(
eUseCounter_FirstCountedUnknownProperty
+
i
)
)
;
}
}
}
}
void
Document
:
:
InitUseCounters
(
)
{
if
(
mUseCountersInitialized
)
{
return
;
}
mUseCountersInitialized
=
true
;
static_assert
(
Telemetry
:
:
HistogramUseCounterCount
>
0
)
;
if
(
!
ShouldIncludeInTelemetry
(
true
)
)
{
return
;
}
mShouldReportUseCounters
=
true
;
WindowContext
*
top
=
GetWindowContextForPageUseCounters
(
)
;
if
(
!
top
)
{
MOZ_LOG
(
gUseCountersLog
LogLevel
:
:
Debug
(
"
InitUseCounters
for
a
non
-
displayed
document
[
%
s
]
"
nsContentUtils
:
:
TruncatedURLForDisplay
(
mDocumentURI
)
.
get
(
)
)
)
;
return
;
}
RefPtr
<
WindowGlobalChild
>
wgc
=
GetWindowGlobalChild
(
)
;
if
(
!
wgc
)
{
return
;
}
MOZ_LOG
(
gUseCountersLog
LogLevel
:
:
Debug
(
"
InitUseCounters
for
a
displayed
document
:
%
"
PRIu64
"
-
>
%
"
PRIu64
"
[
from
%
s
]
"
wgc
-
>
InnerWindowId
(
)
top
-
>
Id
(
)
nsContentUtils
:
:
TruncatedURLForDisplay
(
mDocumentURI
)
.
get
(
)
)
)
;
wgc
-
>
SendExpectPageUseCounters
(
top
)
;
mShouldSendPageUseCounters
=
true
;
}
void
Document
:
:
ReportDocumentUseCounters
(
)
{
if
(
!
mShouldReportUseCounters
|
|
mReportedDocumentUseCounters
)
{
return
;
}
mReportedDocumentUseCounters
=
true
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_DOCUMENTS_DESTROYED
1
)
;
glean
:
:
use_counter
:
:
content_documents_destroyed
.
Add
(
)
;
EnumerateExternalResources
(
[
]
(
Document
&
aDoc
)
{
aDoc
.
ReportDocumentUseCounters
(
)
;
return
CallState
:
:
Continue
;
}
)
;
SetCssUseCounterBits
(
)
;
Maybe
<
nsCString
>
urlForLogging
;
const
bool
dumpCounters
=
StaticPrefs
:
:
dom_use_counters_dump_document
(
)
;
if
(
dumpCounters
)
{
urlForLogging
.
emplace
(
nsContentUtils
:
:
TruncatedURLForDisplay
(
GetDocumentURI
(
)
)
)
;
}
for
(
int32_t
c
=
0
;
c
<
eUseCounter_Count
;
+
+
c
)
{
auto
uc
=
static_cast
<
UseCounter
>
(
c
)
;
if
(
!
mUseCounters
[
uc
]
)
{
continue
;
}
auto
id
=
static_cast
<
Telemetry
:
:
HistogramID
>
(
Telemetry
:
:
HistogramFirstUseCounter
+
uc
*
2
)
;
if
(
dumpCounters
)
{
printf_stderr
(
"
USE_COUNTER_DOCUMENT
:
%
s
-
%
s
\
n
"
Telemetry
:
:
GetHistogramName
(
id
)
urlForLogging
-
>
get
(
)
)
;
}
Telemetry
:
:
Accumulate
(
id
1
)
;
IncrementUseCounter
(
uc
false
)
;
}
}
void
Document
:
:
ReportLCP
(
)
{
const
nsDOMNavigationTiming
*
timing
=
GetNavigationTiming
(
)
;
if
(
!
timing
)
{
return
;
}
TimeStamp
lcpTime
=
timing
-
>
GetLargestContentfulRenderTimeStamp
(
)
;
if
(
!
lcpTime
)
{
return
;
}
mozilla
:
:
glean
:
:
perf
:
:
largest_contentful_paint
.
AccumulateRawDuration
(
lcpTime
-
timing
-
>
GetNavigationStartTimeStamp
(
)
)
;
if
(
!
GetChannel
(
)
)
{
return
;
}
nsCOMPtr
<
nsITimedChannel
>
timedChannel
(
do_QueryInterface
(
GetChannel
(
)
)
)
;
if
(
!
timedChannel
)
{
return
;
}
TimeStamp
responseStart
;
timedChannel
-
>
GetResponseStart
(
&
responseStart
)
;
if
(
!
responseStart
)
{
return
;
}
mozilla
:
:
glean
:
:
perf
:
:
largest_contentful_paint_from_response_start
.
AccumulateRawDuration
(
lcpTime
-
responseStart
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
MarkerInnerWindowId
innerWindowID
=
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
)
)
;
GetNavigationTiming
(
)
-
>
MaybeAddLCPProfilerMarker
(
innerWindowID
)
;
}
}
void
Document
:
:
SendPageUseCounters
(
)
{
if
(
!
mShouldReportUseCounters
|
|
!
mShouldSendPageUseCounters
)
{
return
;
}
EnumerateExternalResources
(
[
]
(
Document
&
aDoc
)
{
aDoc
.
SendPageUseCounters
(
)
;
return
CallState
:
:
Continue
;
}
)
;
RefPtr
<
WindowGlobalChild
>
wgc
=
GetWindowGlobalChild
(
)
;
if
(
!
wgc
)
{
MOZ_ASSERT_UNREACHABLE
(
"
SendPageUseCounters
should
be
called
while
we
still
have
access
"
"
to
our
WindowContext
"
)
;
MOZ_LOG
(
gUseCountersLog
LogLevel
:
:
Debug
(
"
>
too
late
to
send
page
use
counters
"
)
)
;
return
;
}
MOZ_LOG
(
gUseCountersLog
LogLevel
:
:
Debug
(
"
Sending
page
use
counters
:
from
WindowContext
%
"
PRIu64
"
[
%
s
]
"
wgc
-
>
WindowContext
(
)
-
>
Id
(
)
nsContentUtils
:
:
TruncatedURLForDisplay
(
GetDocumentURI
(
)
)
.
get
(
)
)
)
;
SetCssUseCounterBits
(
)
;
UseCounters
counters
=
mUseCounters
|
mChildDocumentUseCounters
;
wgc
-
>
SendAccumulatePageUseCounters
(
counters
)
;
}
bool
Document
:
:
RecomputeResistFingerprinting
(
)
{
mOverriddenFingerprintingSettings
.
reset
(
)
;
const
bool
previous
=
mShouldResistFingerprinting
;
RefPtr
<
BrowsingContext
>
opener
=
GetBrowsingContext
(
)
?
GetBrowsingContext
(
)
-
>
GetOpener
(
)
:
nullptr
;
auto
shouldInheritFrom
=
[
this
]
(
Document
*
aDoc
)
{
return
aDoc
&
&
(
this
-
>
NodePrincipal
(
)
-
>
Equals
(
aDoc
-
>
NodePrincipal
(
)
)
|
|
this
-
>
NodePrincipal
(
)
-
>
GetIsNullPrincipal
(
)
)
;
}
;
if
(
shouldInheritFrom
(
mParentDocument
)
)
{
MOZ_LOG
(
nsContentUtils
:
:
ResistFingerprintingLog
(
)
LogLevel
:
:
Debug
(
"
Inside
RecomputeResistFingerprinting
with
URI
%
s
and
deferring
"
"
to
parent
document
%
s
"
GetDocumentURI
(
)
?
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
null
"
mParentDocument
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
mShouldResistFingerprinting
=
mParentDocument
-
>
ShouldResistFingerprinting
(
RFPTarget
:
:
IsAlwaysEnabledForPrecompute
)
;
mOverriddenFingerprintingSettings
=
mParentDocument
-
>
mOverriddenFingerprintingSettings
;
}
else
if
(
opener
&
&
shouldInheritFrom
(
opener
-
>
GetDocument
(
)
)
)
{
MOZ_LOG
(
nsContentUtils
:
:
ResistFingerprintingLog
(
)
LogLevel
:
:
Debug
(
"
Inside
RecomputeResistFingerprinting
with
URI
%
s
and
deferring
to
"
"
opener
document
%
s
"
GetDocumentURI
(
)
?
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
null
"
opener
-
>
GetDocument
(
)
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
mShouldResistFingerprinting
=
opener
-
>
GetDocument
(
)
-
>
ShouldResistFingerprinting
(
RFPTarget
:
:
IsAlwaysEnabledForPrecompute
)
;
mOverriddenFingerprintingSettings
=
opener
-
>
GetDocument
(
)
-
>
mOverriddenFingerprintingSettings
;
}
else
if
(
nsContentUtils
:
:
IsChromeDoc
(
this
)
)
{
MOZ_LOG
(
nsContentUtils
:
:
ResistFingerprintingLog
(
)
LogLevel
:
:
Debug
(
"
Inside
RecomputeResistFingerprinting
with
a
ChromeDoc
"
)
)
;
mShouldResistFingerprinting
=
false
;
mOverriddenFingerprintingSettings
.
reset
(
)
;
}
else
if
(
mChannel
)
{
MOZ_LOG
(
nsContentUtils
:
:
ResistFingerprintingLog
(
)
LogLevel
:
:
Debug
(
"
Inside
RecomputeResistFingerprinting
with
URI
%
s
"
GetDocumentURI
(
)
?
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
null
"
)
)
;
mShouldResistFingerprinting
=
nsContentUtils
:
:
ShouldResistFingerprinting
(
mChannel
RFPTarget
:
:
IsAlwaysEnabledForPrecompute
)
;
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
mOverriddenFingerprintingSettings
=
loadInfo
-
>
GetOverriddenFingerprintingSettings
(
)
;
}
else
{
MOZ_LOG
(
nsContentUtils
:
:
ResistFingerprintingLog
(
)
LogLevel
:
:
Debug
(
"
Inside
RecomputeResistFingerprinting
fallback
case
.
"
)
)
;
mShouldResistFingerprinting
=
nsContentUtils
:
:
ShouldResistFingerprinting
(
mChannel
RFPTarget
:
:
IsAlwaysEnabledForPrecompute
)
;
mOverriddenFingerprintingSettings
.
reset
(
)
;
}
MOZ_LOG
(
nsContentUtils
:
:
ResistFingerprintingLog
(
)
LogLevel
:
:
Debug
(
"
Finished
RecomputeResistFingerprinting
with
result
%
x
"
mShouldResistFingerprinting
)
)
;
bool
changed
=
previous
!
=
mShouldResistFingerprinting
;
if
(
changed
)
{
if
(
auto
win
=
nsGlobalWindowInner
:
:
Cast
(
GetInnerWindow
(
)
)
)
{
win
-
>
RefreshReduceTimerPrecisionCallerType
(
)
;
}
}
return
changed
;
}
bool
Document
:
:
ShouldResistFingerprinting
(
RFPTarget
aTarget
)
const
{
return
mShouldResistFingerprinting
&
&
nsRFPService
:
:
IsRFPEnabledFor
(
aTarget
mOverriddenFingerprintingSettings
)
;
}
void
Document
:
:
RecordCanvasUsage
(
CanvasUsage
&
aUsage
)
{
const
size_t
kTrackedCanvasLimit
=
8
;
const
uint64_t
kTimeoutUsec
=
3000
*
1000
;
uint64_t
now
=
PR_Now
(
)
;
if
(
(
mCanvasUsage
.
Length
(
)
>
kTrackedCanvasLimit
)
|
|
(
(
now
-
mLastCanvasUsage
)
>
kTimeoutUsec
)
)
{
mCanvasUsage
.
ClearAndRetainStorage
(
)
;
}
mCanvasUsage
.
AppendElement
(
aUsage
)
;
mLastCanvasUsage
=
now
;
nsCString
originNoSuffix
;
if
(
NS_FAILED
(
NodePrincipal
(
)
-
>
GetOriginNoSuffix
(
originNoSuffix
)
)
)
{
return
;
}
nsRFPService
:
:
MaybeReportCanvasFingerprinter
(
mCanvasUsage
GetChannel
(
)
originNoSuffix
)
;
}
void
Document
:
:
RecordFontFingerprinting
(
)
{
nsCString
originNoSuffix
;
if
(
NS_FAILED
(
NodePrincipal
(
)
-
>
GetOriginNoSuffix
(
originNoSuffix
)
)
)
{
return
;
}
nsRFPService
:
:
MaybeReportFontFingerprinter
(
GetChannel
(
)
originNoSuffix
)
;
}
WindowContext
*
Document
:
:
GetWindowContextForPageUseCounters
(
)
const
{
if
(
mDisplayDocument
)
{
return
mDisplayDocument
-
>
GetWindowContextForPageUseCounters
(
)
;
}
if
(
mOriginalDocument
)
{
return
mOriginalDocument
-
>
GetWindowContextForPageUseCounters
(
)
;
}
WindowContext
*
wc
=
GetTopLevelWindowContext
(
)
;
if
(
!
wc
|
|
!
wc
-
>
GetBrowsingContext
(
)
-
>
IsContent
(
)
)
{
return
nullptr
;
}
return
wc
;
}
void
Document
:
:
UpdateIntersectionObservations
(
TimeStamp
aNowTime
)
{
if
(
mIntersectionObservers
.
IsEmpty
(
)
)
{
return
;
}
DOMHighResTimeStamp
time
=
0
;
if
(
nsPIDOMWindowInner
*
win
=
GetInnerWindow
(
)
)
{
if
(
Performance
*
perf
=
win
-
>
GetPerformance
(
)
)
{
time
=
perf
-
>
TimeStampToDOMHighResForRendering
(
aNowTime
)
;
}
}
const
auto
observers
=
ToTArray
<
nsTArray
<
RefPtr
<
DOMIntersectionObserver
>
>
>
(
mIntersectionObservers
)
;
for
(
const
auto
&
observer
:
observers
)
{
if
(
observer
)
{
observer
-
>
Update
(
*
this
time
)
;
}
}
}
void
Document
:
:
ScheduleIntersectionObserverNotification
(
)
{
if
(
mIntersectionObservers
.
IsEmpty
(
)
)
{
return
;
}
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
nsCOMPtr
<
nsIRunnable
>
notification
=
NewRunnableMethod
(
"
Document
:
:
NotifyIntersectionObservers
"
this
&
Document
:
:
NotifyIntersectionObservers
)
;
Dispatch
(
notification
.
forget
(
)
)
;
}
void
Document
:
:
NotifyIntersectionObservers
(
)
{
const
auto
observers
=
ToTArray
<
nsTArray
<
RefPtr
<
DOMIntersectionObserver
>
>
>
(
mIntersectionObservers
)
;
for
(
const
auto
&
observer
:
observers
)
{
if
(
observer
)
{
MOZ_KnownLive
(
observer
)
-
>
Notify
(
)
;
}
}
}
DOMIntersectionObserver
&
Document
:
:
EnsureLazyLoadObserver
(
)
{
if
(
!
mLazyLoadObserver
)
{
mLazyLoadObserver
=
DOMIntersectionObserver
:
:
CreateLazyLoadObserver
(
*
this
)
;
}
return
*
mLazyLoadObserver
;
}
DOMIntersectionObserver
&
Document
:
:
EnsureContentVisibilityObserver
(
)
{
if
(
!
mContentVisibilityObserver
)
{
mContentVisibilityObserver
=
DOMIntersectionObserver
:
:
CreateContentVisibilityObserver
(
*
this
)
;
}
return
*
mContentVisibilityObserver
;
}
void
Document
:
:
ObserveForContentVisibility
(
Element
&
aElement
)
{
EnsureContentVisibilityObserver
(
)
.
Observe
(
aElement
)
;
}
void
Document
:
:
UnobserveForContentVisibility
(
Element
&
aElement
)
{
if
(
mContentVisibilityObserver
)
{
mContentVisibilityObserver
-
>
Unobserve
(
aElement
)
;
}
}
ResizeObserver
&
Document
:
:
EnsureLastRememberedSizeObserver
(
)
{
if
(
!
mLastRememberedSizeObserver
)
{
mLastRememberedSizeObserver
=
ResizeObserver
:
:
CreateLastRememberedSizeObserver
(
*
this
)
;
}
return
*
mLastRememberedSizeObserver
;
}
void
Document
:
:
ObserveForLastRememberedSize
(
Element
&
aElement
)
{
if
(
NS_WARN_IF
(
!
IsActive
(
)
)
)
{
return
;
}
static
ResizeObserverOptions
options
;
EnsureLastRememberedSizeObserver
(
)
.
Observe
(
aElement
options
)
;
}
void
Document
:
:
UnobserveForLastRememberedSize
(
Element
&
aElement
)
{
if
(
mLastRememberedSizeObserver
)
{
mLastRememberedSizeObserver
-
>
Unobserve
(
aElement
)
;
}
}
void
Document
:
:
NotifyLayerManagerRecreated
(
)
{
NotifyActivityChanged
(
)
;
EnumerateSubDocuments
(
[
]
(
Document
&
aSubDoc
)
{
aSubDoc
.
NotifyLayerManagerRecreated
(
)
;
return
CallState
:
:
Continue
;
}
)
;
}
XPathEvaluator
*
Document
:
:
XPathEvaluator
(
)
{
if
(
!
mXPathEvaluator
)
{
mXPathEvaluator
.
reset
(
new
dom
:
:
XPathEvaluator
(
this
)
)
;
}
return
mXPathEvaluator
.
get
(
)
;
}
already_AddRefed
<
nsIDocumentEncoder
>
Document
:
:
GetCachedEncoder
(
)
{
return
mCachedEncoder
.
forget
(
)
;
}
void
Document
:
:
SetCachedEncoder
(
already_AddRefed
<
nsIDocumentEncoder
>
aEncoder
)
{
mCachedEncoder
=
aEncoder
;
}
nsILoadContext
*
Document
:
:
GetLoadContext
(
)
const
{
return
mDocumentContainer
;
}
nsIDocShell
*
Document
:
:
GetDocShell
(
)
const
{
return
mDocumentContainer
;
}
void
Document
:
:
SetStateObject
(
nsIStructuredCloneContainer
*
scContainer
)
{
mStateObjectContainer
=
scContainer
;
mCachedStateObject
=
JS
:
:
UndefinedValue
(
)
;
mCachedStateObjectValid
=
false
;
}
bool
Document
:
:
ComputeDocumentLWTheme
(
)
const
{
if
(
!
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
return
false
;
}
Element
*
element
=
GetRootElement
(
)
;
return
element
&
&
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
lwtheme
nsGkAtoms
:
:
_true
eCaseMatters
)
;
}
already_AddRefed
<
Element
>
Document
:
:
CreateHTMLElement
(
nsAtom
*
aTag
)
{
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
;
nodeInfo
=
mNodeInfoManager
-
>
GetNodeInfo
(
aTag
nullptr
kNameSpaceID_XHTML
ELEMENT_NODE
)
;
MOZ_ASSERT
(
nodeInfo
"
GetNodeInfo
should
never
fail
"
)
;
nsCOMPtr
<
Element
>
element
;
DebugOnly
<
nsresult
>
rv
=
NS_NewHTMLElement
(
getter_AddRefs
(
element
)
nodeInfo
.
forget
(
)
mozilla
:
:
dom
:
:
NOT_FROM_PARSER
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
"
NS_NewHTMLElement
should
never
fail
"
)
;
return
element
.
forget
(
)
;
}
void
AutoWalkBrowsingContextGroup
:
:
SuppressBrowsingContext
(
BrowsingContext
*
aContext
)
{
aContext
-
>
PreOrderWalk
(
[
&
]
(
BrowsingContext
*
aBC
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
aBC
-
>
GetDOMWindow
(
)
)
{
if
(
RefPtr
<
Document
>
doc
=
win
-
>
GetExtantDoc
(
)
)
{
SuppressDocument
(
doc
)
;
mDocuments
.
AppendElement
(
doc
)
;
}
}
}
)
;
}
void
AutoWalkBrowsingContextGroup
:
:
SuppressBrowsingContextGroup
(
BrowsingContextGroup
*
aGroup
)
{
for
(
const
auto
&
bc
:
aGroup
-
>
Toplevels
(
)
)
{
SuppressBrowsingContext
(
bc
)
;
}
}
nsAutoSyncOperation
:
:
nsAutoSyncOperation
(
Document
*
aDoc
SyncOperationBehavior
aSyncBehavior
)
:
mSyncBehavior
(
aSyncBehavior
)
{
mMicroTaskLevel
=
0
;
if
(
CycleCollectedJSContext
*
ccjs
=
CycleCollectedJSContext
:
:
Get
(
)
)
{
mMicroTaskLevel
=
ccjs
-
>
MicroTaskLevel
(
)
;
ccjs
-
>
SetMicroTaskLevel
(
0
)
;
}
if
(
aDoc
)
{
mBrowsingContext
=
aDoc
-
>
GetBrowsingContext
(
)
;
if
(
InputTaskManager
:
:
CanSuspendInputEvent
(
)
)
{
if
(
auto
*
bcg
=
aDoc
-
>
GetDocGroup
(
)
-
>
GetBrowsingContextGroup
(
)
)
{
SuppressBrowsingContextGroup
(
bcg
)
;
}
}
else
if
(
mBrowsingContext
)
{
SuppressBrowsingContext
(
mBrowsingContext
-
>
Top
(
)
)
;
}
if
(
mBrowsingContext
&
&
mSyncBehavior
=
=
SyncOperationBehavior
:
:
eSuspendInput
&
&
InputTaskManager
:
:
CanSuspendInputEvent
(
)
)
{
mBrowsingContext
-
>
Group
(
)
-
>
IncInputEventSuspensionLevel
(
)
;
}
}
}
void
nsAutoSyncOperation
:
:
SuppressDocument
(
Document
*
aDoc
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
aDoc
-
>
GetInnerWindow
(
)
)
{
win
-
>
TimeoutManager
(
)
.
BeginSyncOperation
(
)
;
}
aDoc
-
>
SetIsInSyncOperation
(
true
)
;
}
void
nsAutoSyncOperation
:
:
UnsuppressDocument
(
Document
*
aDoc
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
win
=
aDoc
-
>
GetInnerWindow
(
)
)
{
win
-
>
TimeoutManager
(
)
.
EndSyncOperation
(
)
;
}
aDoc
-
>
SetIsInSyncOperation
(
false
)
;
}
nsAutoSyncOperation
:
:
~
nsAutoSyncOperation
(
)
{
UnsuppressDocuments
(
)
;
CycleCollectedJSContext
*
ccjs
=
CycleCollectedJSContext
:
:
Get
(
)
;
if
(
ccjs
)
{
ccjs
-
>
SetMicroTaskLevel
(
mMicroTaskLevel
)
;
}
if
(
mBrowsingContext
&
&
mSyncBehavior
=
=
SyncOperationBehavior
:
:
eSuspendInput
&
&
InputTaskManager
:
:
CanSuspendInputEvent
(
)
)
{
mBrowsingContext
-
>
Group
(
)
-
>
DecInputEventSuspensionLevel
(
)
;
}
}
void
Document
:
:
SetIsInSyncOperation
(
bool
aSync
)
{
if
(
CycleCollectedJSContext
*
ccjs
=
CycleCollectedJSContext
:
:
Get
(
)
)
{
ccjs
-
>
UpdateMicroTaskSuppressionGeneration
(
)
;
}
if
(
aSync
)
{
+
+
mInSyncOperationCount
;
}
else
{
-
-
mInSyncOperationCount
;
}
}
gfxUserFontSet
*
Document
:
:
GetUserFontSet
(
)
{
if
(
!
mFontFaceSet
)
{
return
nullptr
;
}
return
mFontFaceSet
-
>
GetImpl
(
)
;
}
void
Document
:
:
FlushUserFontSet
(
)
{
if
(
!
mFontFaceSetDirty
)
{
return
;
}
mFontFaceSetDirty
=
false
;
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
DownloadableFontsEnabled
(
)
)
{
nsTArray
<
nsFontFaceRuleContainer
>
rules
;
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
MOZ_ASSERT
(
mStyleSetFilled
)
;
EnsureStyleSet
(
)
.
AppendFontFaceRules
(
rules
)
;
}
if
(
!
mFontFaceSet
&
&
!
rules
.
IsEmpty
(
)
)
{
mFontFaceSet
=
FontFaceSet
:
:
CreateForDocument
(
this
)
;
}
bool
changed
=
false
;
if
(
mFontFaceSet
)
{
changed
=
mFontFaceSet
-
>
UpdateRules
(
rules
)
;
}
if
(
changed
&
&
presShell
)
{
if
(
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
UserFontSetUpdated
(
)
;
}
}
}
}
void
Document
:
:
MarkUserFontSetDirty
(
)
{
if
(
mFontFaceSetDirty
)
{
return
;
}
mFontFaceSetDirty
=
true
;
if
(
PresShell
*
presShell
=
GetPresShell
(
)
)
{
presShell
-
>
EnsureStyleFlush
(
)
;
}
}
FontFaceSet
*
Document
:
:
Fonts
(
)
{
if
(
!
mFontFaceSet
)
{
mFontFaceSet
=
FontFaceSet
:
:
CreateForDocument
(
this
)
;
FlushUserFontSet
(
)
;
}
return
mFontFaceSet
;
}
void
Document
:
:
ReportHasScrollLinkedEffect
(
const
TimeStamp
&
aTimeStamp
)
{
MOZ_ASSERT
(
!
aTimeStamp
.
IsNull
(
)
)
;
if
(
!
mLastScrollLinkedEffectDetectionTime
.
IsNull
(
)
&
&
mLastScrollLinkedEffectDetectionTime
>
=
aTimeStamp
)
{
return
;
}
if
(
mLastScrollLinkedEffectDetectionTime
.
IsNull
(
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
"
Async
Pan
/
Zoom
"
_ns
this
nsContentUtils
:
:
eLAYOUT_PROPERTIES
"
ScrollLinkedEffectFound3
"
)
;
}
mLastScrollLinkedEffectDetectionTime
=
aTimeStamp
;
}
bool
Document
:
:
HasScrollLinkedEffect
(
)
const
{
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
return
mLastScrollLinkedEffectDetectionTime
=
=
pc
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
}
return
false
;
}
void
Document
:
:
SetSHEntryHasUserInteraction
(
bool
aHasInteraction
)
{
if
(
RefPtr
<
WindowContext
>
topWc
=
GetTopLevelWindowContext
(
)
)
{
Unused
<
<
topWc
-
>
SetSHEntryHasUserInteraction
(
aHasInteraction
)
;
}
}
bool
Document
:
:
GetSHEntryHasUserInteraction
(
)
{
if
(
RefPtr
<
WindowContext
>
topWc
=
GetTopLevelWindowContext
(
)
)
{
return
topWc
-
>
GetSHEntryHasUserInteraction
(
)
;
}
return
false
;
}
void
Document
:
:
SetUserHasInteracted
(
)
{
MOZ_LOG
(
gUserInteractionPRLog
LogLevel
:
:
Debug
(
"
Document
%
p
has
been
interacted
by
user
.
"
this
)
)
;
MaybeStoreUserInteractionAsPermission
(
)
;
if
(
!
GetSHEntryHasUserInteraction
(
)
)
{
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsISHEntry
>
currentEntry
;
bool
oshe
;
nsresult
rv
=
docShell
-
>
GetCurrentSHEntry
(
getter_AddRefs
(
currentEntry
)
&
oshe
)
;
if
(
!
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
&
&
currentEntry
)
{
currentEntry
-
>
SetHasUserInteraction
(
true
)
;
}
}
SetSHEntryHasUserInteraction
(
true
)
;
}
if
(
mUserHasInteracted
)
{
return
;
}
mUserHasInteracted
=
true
;
if
(
mChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
loadInfo
-
>
SetDocumentHasUserInteracted
(
true
)
;
}
if
(
auto
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
SendUpdateDocumentHasUserInteracted
(
true
)
;
}
MaybeAllowStorageForOpenerAfterUserInteraction
(
)
;
}
BrowsingContext
*
Document
:
:
GetBrowsingContext
(
)
const
{
return
mDocumentContainer
?
mDocumentContainer
-
>
GetBrowsingContext
(
)
:
nullptr
;
}
void
Document
:
:
NotifyUserGestureActivation
(
)
{
RefPtr
<
BrowsingContext
>
currentBC
=
GetBrowsingContext
(
)
;
if
(
!
currentBC
)
{
return
;
}
RefPtr
<
WindowContext
>
currentWC
=
GetWindowContext
(
)
;
if
(
!
currentWC
)
{
return
;
}
currentWC
-
>
NotifyUserGestureActivation
(
)
;
for
(
WindowContext
*
wc
=
currentWC
;
wc
;
wc
=
wc
-
>
GetParentWindowContext
(
)
)
{
wc
-
>
NotifyUserGestureActivation
(
)
;
}
currentBC
-
>
PreOrderWalk
(
[
&
]
(
BrowsingContext
*
bc
)
{
WindowContext
*
wc
=
bc
-
>
GetCurrentWindowContext
(
)
;
if
(
!
wc
)
{
return
;
}
WindowGlobalChild
*
wgc
=
wc
-
>
GetWindowGlobalChild
(
)
;
if
(
!
wgc
|
|
!
wgc
-
>
IsSameOriginWith
(
currentWC
)
)
{
return
;
}
wc
-
>
NotifyUserGestureActivation
(
)
;
}
)
;
}
bool
Document
:
:
HasBeenUserGestureActivated
(
)
{
RefPtr
<
WindowContext
>
wc
=
GetWindowContext
(
)
;
return
wc
&
&
wc
-
>
HasBeenUserGestureActivated
(
)
;
}
DOMHighResTimeStamp
Document
:
:
LastUserGestureTimeStamp
(
)
{
if
(
RefPtr
<
WindowContext
>
wc
=
GetWindowContext
(
)
)
{
if
(
nsGlobalWindowInner
*
innerWindow
=
wc
-
>
GetInnerWindow
(
)
)
{
if
(
Performance
*
perf
=
innerWindow
-
>
GetPerformance
(
)
)
{
return
perf
-
>
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
wc
-
>
GetUserGestureStart
(
)
)
;
}
}
}
NS_WARNING
(
"
Unable
to
calculate
DOMHighResTimeStamp
for
LastUserGestureTimeStamp
"
)
;
return
0
;
}
void
Document
:
:
ClearUserGestureActivation
(
)
{
if
(
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
)
{
bc
=
bc
-
>
Top
(
)
;
bc
-
>
PreOrderWalk
(
[
&
]
(
BrowsingContext
*
aBC
)
{
if
(
WindowContext
*
windowContext
=
aBC
-
>
GetCurrentWindowContext
(
)
)
{
windowContext
-
>
NotifyResetUserGestureActivation
(
)
;
}
}
)
;
}
}
bool
Document
:
:
HasValidTransientUserGestureActivation
(
)
const
{
RefPtr
<
WindowContext
>
wc
=
GetWindowContext
(
)
;
return
wc
&
&
wc
-
>
HasValidTransientUserGestureActivation
(
)
;
}
bool
Document
:
:
ConsumeTransientUserGestureActivation
(
)
{
RefPtr
<
WindowContext
>
wc
=
GetWindowContext
(
)
;
return
wc
&
&
wc
-
>
ConsumeTransientUserGestureActivation
(
)
;
}
void
Document
:
:
SetDocTreeHadMedia
(
)
{
RefPtr
<
WindowContext
>
topWc
=
GetTopLevelWindowContext
(
)
;
if
(
topWc
&
&
!
topWc
-
>
IsDiscarded
(
)
&
&
!
topWc
-
>
GetDocTreeHadMedia
(
)
)
{
MOZ_ALWAYS_SUCCEEDS
(
topWc
-
>
SetDocTreeHadMedia
(
true
)
)
;
}
}
void
Document
:
:
MaybeAllowStorageForOpenerAfterUserInteraction
(
)
{
if
(
!
CookieJarSettings
(
)
-
>
GetRejectThirdPartyContexts
(
)
)
{
return
;
}
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
;
}
if
(
!
nsContentUtils
:
:
IsFirstPartyTrackingResourceWindow
(
inner
)
)
{
return
;
}
auto
*
outer
=
nsGlobalWindowOuter
:
:
Cast
(
inner
-
>
GetOuterWindow
(
)
)
;
if
(
NS_WARN_IF
(
!
outer
)
)
{
return
;
}
RefPtr
<
BrowsingContext
>
openerBC
=
outer
-
>
GetOpenerBrowsingContext
(
)
;
if
(
!
openerBC
)
{
return
;
}
if
(
openerBC
-
>
IsInProcess
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
outerOpener
=
openerBC
-
>
GetDOMWindow
(
)
;
if
(
NS_WARN_IF
(
!
outerOpener
)
)
{
return
;
}
nsCOMPtr
<
nsPIDOMWindowInner
>
openerInner
=
outerOpener
-
>
GetCurrentInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
openerInner
)
)
{
return
;
}
RefPtr
<
Document
>
openerDocument
=
openerInner
-
>
GetExtantDoc
(
)
;
if
(
NS_WARN_IF
(
!
openerDocument
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
openerURI
=
openerDocument
-
>
GetDocumentURI
(
)
;
if
(
NS_WARN_IF
(
!
openerURI
)
)
{
return
;
}
if
(
!
AntiTrackingUtils
:
:
IsThirdPartyWindow
(
inner
openerURI
)
&
&
!
AntiTrackingUtils
:
:
IsThirdPartyWindow
(
openerInner
nullptr
)
)
{
return
;
}
}
Unused
<
<
StorageAccessAPIHelper
:
:
AllowAccessFor
(
NodePrincipal
(
)
openerBC
ContentBlockingNotifier
:
:
eOpenerAfterUserInteraction
)
;
}
namespace
{
class
UserInteractionTimer
final
:
public
Runnable
public
nsITimerCallback
public
nsIAsyncShutdownBlocker
{
public
:
NS_DECL_ISUPPORTS_INHERITED
explicit
UserInteractionTimer
(
Document
*
aDocument
)
:
Runnable
(
"
UserInteractionTimer
"
)
mPrincipal
(
aDocument
-
>
NodePrincipal
(
)
)
mDocument
(
do_GetWeakReference
(
aDocument
)
)
{
static
int32_t
userInteractionTimerId
=
0
;
mBlockerName
.
AppendPrintf
(
"
UserInteractionTimer
%
d
for
document
%
p
"
+
+
userInteractionTimerId
aDocument
)
;
}
NS_IMETHOD
Run
(
)
override
{
uint32_t
interval
=
StaticPrefs
:
:
privacy_userInteraction_document_interval
(
)
;
if
(
!
interval
)
{
return
NS_OK
;
}
RefPtr
<
UserInteractionTimer
>
self
=
this
;
auto
raii
=
MakeScopeExit
(
[
self
]
{
self
-
>
CancelTimerAndStoreUserInteraction
(
)
;
}
)
;
nsresult
rv
=
NS_NewTimerWithCallback
(
getter_AddRefs
(
mTimer
)
this
interval
*
1000
nsITimer
:
:
TYPE_ONE_SHOT
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
=
GetShutdownPhase
(
)
;
NS_ENSURE_TRUE
(
!
!
phase
NS_OK
)
;
rv
=
phase
-
>
AddBlocker
(
this
NS_LITERAL_STRING_FROM_CSTRING
(
__FILE__
)
__LINE__
u
"
UserInteractionTimer
shutdown
"
_ns
)
;
NS_ENSURE_SUCCESS
(
rv
NS_OK
)
;
raii
.
release
(
)
;
return
NS_OK
;
}
NS_IMETHOD
Notify
(
nsITimer
*
aTimer
)
override
{
StoreUserInteraction
(
)
;
return
NS_OK
;
}
#
ifdef
MOZ_COLLECTING_RUNNABLE_TELEMETRY
using
nsINamed
:
:
GetName
;
#
endif
NS_IMETHOD
GetName
(
nsAString
&
aName
)
override
{
aName
=
mBlockerName
;
return
NS_OK
;
}
NS_IMETHOD
BlockShutdown
(
nsIAsyncShutdownClient
*
aClient
)
override
{
CancelTimerAndStoreUserInteraction
(
)
;
return
NS_OK
;
}
NS_IMETHOD
GetState
(
nsIPropertyBag
*
*
)
override
{
return
NS_OK
;
}
private
:
~
UserInteractionTimer
(
)
=
default
;
void
StoreUserInteraction
(
)
{
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
=
GetShutdownPhase
(
)
;
if
(
phase
)
{
phase
-
>
RemoveBlocker
(
this
)
;
}
nsCOMPtr
<
Document
>
document
=
do_QueryReferent
(
mDocument
)
;
if
(
document
)
{
ContentBlockingUserInteraction
:
:
Observe
(
mPrincipal
)
;
document
-
>
ResetUserInteractionTimer
(
)
;
}
}
void
CancelTimerAndStoreUserInteraction
(
)
{
if
(
mTimer
)
{
mTimer
-
>
Cancel
(
)
;
mTimer
=
nullptr
;
}
StoreUserInteraction
(
)
;
}
static
already_AddRefed
<
nsIAsyncShutdownClient
>
GetShutdownPhase
(
)
{
nsCOMPtr
<
nsIAsyncShutdownService
>
svc
=
services
:
:
GetAsyncShutdownService
(
)
;
NS_ENSURE_TRUE
(
!
!
svc
nullptr
)
;
nsCOMPtr
<
nsIAsyncShutdownClient
>
phase
;
nsresult
rv
=
svc
-
>
GetXpcomWillShutdown
(
getter_AddRefs
(
phase
)
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
phase
.
forget
(
)
;
}
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsWeakPtr
mDocument
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsString
mBlockerName
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
UserInteractionTimer
Runnable
nsITimerCallback
nsIAsyncShutdownBlocker
)
}
void
Document
:
:
MaybeStoreUserInteractionAsPermission
(
)
{
if
(
!
IsTopLevelContentDocument
(
)
)
{
bool
hasSA
;
nsresult
rv
=
HasStorageAccessSync
(
hasSA
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
hasSA
)
{
return
;
}
}
if
(
!
mUserHasInteracted
)
{
ContentBlockingUserInteraction
:
:
Observe
(
NodePrincipal
(
)
)
;
return
;
}
if
(
mHasUserInteractionTimerScheduled
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
task
=
new
UserInteractionTimer
(
this
)
;
nsresult
rv
=
NS_DispatchToCurrentThreadQueue
(
task
.
forget
(
)
2500
EventQueuePriority
:
:
Idle
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
;
}
mHasUserInteractionTimerScheduled
=
true
;
}
void
Document
:
:
ResetUserInteractionTimer
(
)
{
mHasUserInteractionTimerScheduled
=
false
;
}
bool
Document
:
:
IsExtensionPage
(
)
const
{
return
BasePrincipal
:
:
Cast
(
NodePrincipal
(
)
)
-
>
AddonPolicy
(
)
;
}
void
Document
:
:
AddResizeObserver
(
ResizeObserver
&
aObserver
)
{
MOZ_ASSERT
(
!
mResizeObservers
.
Contains
(
&
aObserver
)
)
;
if
(
aObserver
.
HasNativeCallback
(
)
)
{
mResizeObservers
.
InsertElementAt
(
0
&
aObserver
)
;
}
else
{
mResizeObservers
.
AppendElement
(
&
aObserver
)
;
}
}
void
Document
:
:
RemoveResizeObserver
(
ResizeObserver
&
aObserver
)
{
MOZ_ASSERT
(
mResizeObservers
.
Contains
(
&
aObserver
)
)
;
mResizeObservers
.
RemoveElement
(
&
aObserver
)
;
}
PermissionDelegateHandler
*
Document
:
:
GetPermissionDelegateHandler
(
)
{
if
(
!
mPermissionDelegateHandler
)
{
mPermissionDelegateHandler
=
MakeAndAddRef
<
PermissionDelegateHandler
>
(
this
)
;
}
if
(
!
mPermissionDelegateHandler
-
>
Initialize
(
)
)
{
mPermissionDelegateHandler
=
nullptr
;
}
return
mPermissionDelegateHandler
;
}
void
Document
:
:
ScheduleResizeObserversNotification
(
)
const
{
if
(
!
mPresShell
)
{
return
;
}
if
(
nsRefreshDriver
*
rd
=
mPresShell
-
>
GetRefreshDriver
(
)
)
{
rd
-
>
EnsureResizeObserverUpdateHappens
(
)
;
}
}
static
void
FlushLayoutForWholeBrowsingContextTree
(
Document
&
aDoc
)
{
if
(
BrowsingContext
*
bc
=
aDoc
.
GetBrowsingContext
(
)
)
{
RefPtr
<
BrowsingContext
>
top
=
bc
-
>
Top
(
)
;
top
-
>
PreOrderWalk
(
[
]
(
BrowsingContext
*
aCur
)
{
if
(
Document
*
doc
=
aCur
-
>
GetExtantDocument
(
)
)
{
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
)
;
}
else
{
aDoc
.
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
void
Document
:
:
NotifyResizeObservers
(
)
{
if
(
mResizeObservers
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
shallowestTargetDepth
=
0
;
while
(
true
)
{
FlushLayoutForWholeBrowsingContextTree
(
*
this
)
;
GatherAllActiveResizeObservations
(
shallowestTargetDepth
)
;
if
(
!
HasAnyActiveResizeObservations
(
)
)
{
break
;
}
DebugOnly
<
uint32_t
>
oldShallowestTargetDepth
=
shallowestTargetDepth
;
shallowestTargetDepth
=
BroadcastAllActiveResizeObservations
(
)
;
NS_ASSERTION
(
oldShallowestTargetDepth
<
shallowestTargetDepth
"
shallowestTargetDepth
should
be
getting
strictly
deeper
"
)
;
}
if
(
HasAnySkippedResizeObservations
(
)
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetInnerWindow
(
)
)
{
RootedDictionary
<
ErrorEventInit
>
init
(
RootingCx
(
)
)
;
init
.
mMessage
.
AssignLiteral
(
"
ResizeObserver
loop
completed
with
undelivered
notifications
.
"
)
;
init
.
mBubbles
=
false
;
init
.
mCancelable
=
false
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsCOMPtr
<
nsIScriptGlobalObject
>
sgo
=
do_QueryInterface
(
window
)
;
MOZ_ASSERT
(
sgo
)
;
if
(
NS_WARN_IF
(
sgo
-
>
HandleScriptError
(
init
&
status
)
)
)
{
status
=
nsEventStatus_eIgnore
;
}
}
else
{
}
ScheduleResizeObserversNotification
(
)
;
}
}
void
Document
:
:
GatherAllActiveResizeObservations
(
uint32_t
aDepth
)
{
for
(
ResizeObserver
*
observer
:
mResizeObservers
)
{
observer
-
>
GatherActiveObservations
(
aDepth
)
;
}
}
uint32_t
Document
:
:
BroadcastAllActiveResizeObservations
(
)
{
uint32_t
shallowestTargetDepth
=
std
:
:
numeric_limits
<
uint32_t
>
:
:
max
(
)
;
const
auto
observers
=
ToTArray
<
nsTArray
<
RefPtr
<
ResizeObserver
>
>
>
(
mResizeObservers
)
;
for
(
const
auto
&
observer
:
observers
)
{
uint32_t
targetDepth
=
MOZ_KnownLive
(
observer
)
-
>
BroadcastActiveObservations
(
)
;
if
(
targetDepth
<
shallowestTargetDepth
)
{
shallowestTargetDepth
=
targetDepth
;
}
}
return
shallowestTargetDepth
;
}
bool
Document
:
:
HasAnySkippedResizeObservations
(
)
const
{
for
(
const
auto
&
observer
:
mResizeObservers
)
{
if
(
observer
-
>
HasSkippedObservations
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
Document
:
:
HasAnyActiveResizeObservations
(
)
const
{
for
(
const
auto
&
observer
:
mResizeObservers
)
{
if
(
observer
-
>
HasActiveObservations
(
)
)
{
return
true
;
}
}
return
false
;
}
void
Document
:
:
ClearStaleServoData
(
)
{
DocumentStyleRootIterator
iter
(
this
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
RestyleManager
:
:
ClearServoDataFromSubtree
(
root
)
;
}
}
Selection
*
Document
:
:
GetSelection
(
ErrorResult
&
aRv
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
GetInnerWindow
(
)
;
if
(
!
window
)
{
return
nullptr
;
}
if
(
!
window
-
>
IsCurrentInnerWindow
(
)
)
{
return
nullptr
;
}
return
nsGlobalWindowInner
:
:
Cast
(
window
)
-
>
GetSelection
(
aRv
)
;
}
void
Document
:
:
MakeBrowsingContextNonSynthetic
(
)
{
if
(
nsContentUtils
:
:
ShouldHideObjectOrEmbedImageDocument
(
)
)
{
if
(
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
)
{
if
(
bc
-
>
GetSyntheticDocumentContainer
(
)
)
{
Unused
<
<
bc
-
>
SetSyntheticDocumentContainer
(
false
)
;
}
}
}
}
nsresult
Document
:
:
HasStorageAccessSync
(
bool
&
aHasStorageAccess
)
{
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
GetInnerWindow
(
)
;
if
(
!
inner
)
{
aHasStorageAccess
=
false
;
return
NS_OK
;
}
Maybe
<
bool
>
resultBecauseCookiesApproved
=
StorageAccessAPIHelper
:
:
CheckCookiesPermittedDecidesStorageAccessAPI
(
CookieJarSettings
(
)
NodePrincipal
(
)
)
;
if
(
resultBecauseCookiesApproved
.
isSome
(
)
)
{
if
(
resultBecauseCookiesApproved
.
value
(
)
)
{
aHasStorageAccess
=
true
;
return
NS_OK
;
}
else
{
aHasStorageAccess
=
false
;
return
NS_OK
;
}
}
bool
isThirdPartyDocument
=
AntiTrackingUtils
:
:
IsThirdPartyDocument
(
this
)
;
bool
isOnThirdPartySkipList
=
false
;
if
(
mChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
isOnThirdPartySkipList
=
loadInfo
-
>
GetStoragePermission
(
)
=
=
nsILoadInfo
:
:
StoragePermissionAllowListed
;
}
bool
isThirdPartyTracker
=
nsContentUtils
:
:
IsThirdPartyTrackingResourceWindow
(
inner
)
;
Maybe
<
bool
>
resultBecauseBrowserSettings
=
StorageAccessAPIHelper
:
:
CheckBrowserSettingsDecidesStorageAccessAPI
(
CookieJarSettings
(
)
isThirdPartyDocument
isOnThirdPartySkipList
isThirdPartyTracker
)
;
if
(
resultBecauseBrowserSettings
.
isSome
(
)
)
{
if
(
resultBecauseBrowserSettings
.
value
(
)
)
{
aHasStorageAccess
=
true
;
return
NS_OK
;
}
else
{
aHasStorageAccess
=
false
;
return
NS_OK
;
}
}
Maybe
<
bool
>
resultBecauseCallContext
=
StorageAccessAPIHelper
:
:
CheckCallingContextDecidesStorageAccessAPI
(
this
false
)
;
if
(
resultBecauseCallContext
.
isSome
(
)
)
{
if
(
resultBecauseCallContext
.
value
(
)
)
{
aHasStorageAccess
=
true
;
return
NS_OK
;
}
else
{
aHasStorageAccess
=
false
;
return
NS_OK
;
}
}
Maybe
<
bool
>
resultBecausePreviousPermission
=
StorageAccessAPIHelper
:
:
CheckExistingPermissionDecidesStorageAccessAPI
(
this
false
)
;
if
(
resultBecausePreviousPermission
.
isSome
(
)
)
{
if
(
resultBecausePreviousPermission
.
value
(
)
)
{
aHasStorageAccess
=
true
;
return
NS_OK
;
}
else
{
aHasStorageAccess
=
false
;
return
NS_OK
;
}
}
aHasStorageAccess
=
false
;
return
NS_OK
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Document
:
:
HasStorageAccess
(
mozilla
:
:
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
Promise
:
:
ePropagateUserInteraction
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
!
IsCurrentActiveDocument
(
)
)
{
promise
-
>
MaybeRejectWithInvalidStateError
(
"
hasStorageAccess
requires
an
active
document
"
)
;
return
promise
.
forget
(
)
;
}
bool
hasStorageAccess
;
nsresult
rv
=
HasStorageAccessSync
(
hasStorageAccess
)
;
if
(
NS_FAILED
(
rv
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeResolve
(
hasStorageAccess
)
;
}
return
promise
.
forget
(
)
;
}
RefPtr
<
Document
:
:
GetContentBlockingEventsPromise
>
Document
:
:
GetContentBlockingEvents
(
)
{
RefPtr
<
WindowGlobalChild
>
wgc
=
GetWindowGlobalChild
(
)
;
if
(
!
wgc
)
{
return
nullptr
;
}
return
wgc
-
>
SendGetContentBlockingEvents
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
]
(
const
WindowGlobalChild
:
:
GetContentBlockingEventsPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
return
Document
:
:
GetContentBlockingEventsPromise
:
:
CreateAndResolve
(
aValue
.
ResolveValue
(
)
__func__
)
;
}
return
Document
:
:
GetContentBlockingEventsPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
StorageAccessAPIHelper
:
:
PerformPermissionGrant
Document
:
:
CreatePermissionGrantPromise
(
nsPIDOMWindowInner
*
aInnerWindow
nsIPrincipal
*
aPrincipal
bool
aHasUserInteraction
bool
aRequireUserInteraction
const
Maybe
<
nsCString
>
&
aTopLevelBaseDomain
bool
aFrameOnly
)
{
MOZ_ASSERT
(
aInnerWindow
)
;
MOZ_ASSERT
(
aPrincipal
)
;
RefPtr
<
Document
>
self
(
this
)
;
RefPtr
<
nsPIDOMWindowInner
>
inner
(
aInnerWindow
)
;
RefPtr
<
nsIPrincipal
>
principal
(
aPrincipal
)
;
return
[
inner
self
principal
aHasUserInteraction
aRequireUserInteraction
aTopLevelBaseDomain
aFrameOnly
]
(
)
{
RefPtr
<
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
Private
>
p
=
new
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
Private
(
__func__
)
;
RefPtr
<
PWindowGlobalChild
:
:
GetStorageAccessPermissionPromise
>
promise
;
MOZ_ASSERT
(
XRE_IsContentProcess
(
)
)
;
WindowGlobalChild
*
wgc
=
inner
-
>
GetWindowGlobalChild
(
)
;
MOZ_ASSERT
(
wgc
)
;
promise
=
wgc
-
>
SendGetStorageAccessPermission
(
)
;
MOZ_ASSERT
(
promise
)
;
promise
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
p
inner
principal
aHasUserInteraction
aRequireUserInteraction
aTopLevelBaseDomain
aFrameOnly
]
(
uint32_t
aAction
)
{
if
(
aAction
=
=
nsIPermissionManager
:
:
ALLOW_ACTION
)
{
p
-
>
Resolve
(
StorageAccessAPIHelper
:
:
eAllow
__func__
)
;
return
;
}
if
(
aAction
=
=
nsIPermissionManager
:
:
DENY_ACTION
)
{
p
-
>
Reject
(
false
__func__
)
;
return
;
}
if
(
!
aHasUserInteraction
&
&
aRequireUserInteraction
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
self
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessUserGesture
"
)
;
p
-
>
Reject
(
false
__func__
)
;
return
;
}
RefPtr
<
StorageAccessPermissionRequest
>
sapr
=
StorageAccessPermissionRequest
:
:
Create
(
inner
principal
aTopLevelBaseDomain
aFrameOnly
[
p
]
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_API_UI
:
:
Allow
)
;
p
-
>
Resolve
(
StorageAccessAPIHelper
:
:
eAllow
__func__
)
;
}
[
p
]
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_API_UI
:
:
Deny
)
;
p
-
>
Reject
(
false
__func__
)
;
}
)
;
using
PromptResult
=
ContentPermissionRequestBase
:
:
PromptResult
;
PromptResult
pr
=
sapr
-
>
CheckPromptPrefs
(
)
;
if
(
pr
=
=
PromptResult
:
:
Pending
)
{
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_API_UI
:
:
Request
)
;
}
self
-
>
AutomaticStorageAccessPermissionCanBeGranted
(
aHasUserInteraction
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
p
pr
sapr
inner
]
(
const
Document
:
:
AutomaticStorageAccessPermissionGrantPromise
:
:
ResolveOrRejectValue
&
aValue
)
-
>
void
{
PromptResult
pr2
=
pr
;
bool
storageAccessCanBeGrantedAutomatically
=
aValue
.
IsResolve
(
)
&
&
aValue
.
ResolveValue
(
)
;
bool
autoGrant
=
false
;
if
(
pr2
=
=
PromptResult
:
:
Pending
&
&
storageAccessCanBeGrantedAutomatically
)
{
pr2
=
PromptResult
:
:
Granted
;
autoGrant
=
true
;
Telemetry
:
:
AccumulateCategorical
(
Telemetry
:
:
LABELS_STORAGE_ACCESS_API_UI
:
:
AllowAutomatically
)
;
}
if
(
pr2
!
=
PromptResult
:
:
Pending
)
{
MOZ_ASSERT_IF
(
pr2
!
=
PromptResult
:
:
Granted
pr2
=
=
PromptResult
:
:
Denied
)
;
if
(
pr2
=
=
PromptResult
:
:
Granted
)
{
StorageAccessAPIHelper
:
:
StorageAccessPromptChoices
choice
=
StorageAccessAPIHelper
:
:
eAllow
;
if
(
autoGrant
)
{
choice
=
StorageAccessAPIHelper
:
:
eAllowAutoGrant
;
}
if
(
!
autoGrant
)
{
p
-
>
Resolve
(
choice
__func__
)
;
}
else
{
sapr
-
>
MaybeDelayAutomaticGrants
(
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
p
sapr
choice
]
{
p
-
>
Resolve
(
choice
__func__
)
;
}
[
p
sapr
]
{
p
-
>
Reject
(
false
__func__
)
;
}
)
;
}
return
;
}
p
-
>
Reject
(
false
__func__
)
;
return
;
}
sapr
-
>
RequestDelayedTask
(
GetMainThreadSerialEventTarget
(
)
ContentPermissionRequestBase
:
:
DelayedTaskType
:
:
Request
)
;
}
)
;
}
[
p
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
aError
)
{
p
-
>
Reject
(
false
__func__
)
;
return
p
;
}
)
;
return
p
;
}
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Document
:
:
RequestStorageAccess
(
mozilla
:
:
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
!
IsCurrentActiveDocument
(
)
)
{
promise
-
>
MaybeRejectWithInvalidStateError
(
"
requestStorageAccess
requires
an
active
document
"
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
nsPIDOMWindowInner
>
inner
=
GetInnerWindow
(
)
;
if
(
!
inner
)
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
Maybe
<
bool
>
resultBecauseCookiesApproved
=
StorageAccessAPIHelper
:
:
CheckCookiesPermittedDecidesStorageAccessAPI
(
CookieJarSettings
(
)
NodePrincipal
(
)
)
;
if
(
resultBecauseCookiesApproved
.
isSome
(
)
)
{
if
(
resultBecauseCookiesApproved
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
else
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
}
bool
isThirdPartyDocument
=
AntiTrackingUtils
:
:
IsThirdPartyDocument
(
this
)
;
bool
isOnThirdPartySkipList
=
false
;
if
(
mChannel
)
{
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
isOnThirdPartySkipList
=
loadInfo
-
>
GetStoragePermission
(
)
=
=
nsILoadInfo
:
:
StoragePermissionAllowListed
;
}
bool
isThirdPartyTracker
=
nsContentUtils
:
:
IsThirdPartyTrackingResourceWindow
(
inner
)
;
Maybe
<
bool
>
resultBecauseBrowserSettings
=
StorageAccessAPIHelper
:
:
CheckBrowserSettingsDecidesStorageAccessAPI
(
CookieJarSettings
(
)
isThirdPartyDocument
isOnThirdPartySkipList
isThirdPartyTracker
)
;
if
(
resultBecauseBrowserSettings
.
isSome
(
)
)
{
if
(
resultBecauseBrowserSettings
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
else
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
}
Maybe
<
bool
>
resultBecauseCallContext
=
StorageAccessAPIHelper
:
:
CheckCallingContextDecidesStorageAccessAPI
(
this
true
)
;
if
(
resultBecauseCallContext
.
isSome
(
)
)
{
if
(
resultBecauseCallContext
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
else
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
}
Maybe
<
bool
>
resultBecausePreviousPermission
=
StorageAccessAPIHelper
:
:
CheckExistingPermissionDecidesStorageAccessAPI
(
this
true
)
;
if
(
resultBecausePreviousPermission
.
isSome
(
)
)
{
if
(
resultBecausePreviousPermission
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
else
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
}
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
RefPtr
<
nsGlobalWindowOuter
>
outer
=
nsGlobalWindowOuter
:
:
Cast
(
inner
-
>
GetOuterWindow
(
)
)
;
if
(
!
outer
)
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
Document
>
self
(
this
)
;
StorageAccessAPIHelper
:
:
RequestStorageAccessAsyncHelper
(
this
inner
bc
NodePrincipal
(
)
self
-
>
HasValidTransientUserGestureActivation
(
)
true
true
ContentBlockingNotifier
:
:
eStorageAccessAPI
true
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
inner
promise
]
{
inner
-
>
SaveStorageAccessPermissionGranted
(
)
;
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
self
promise
]
{
self
-
>
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
mozilla
:
:
dom
:
:
Promise
>
Document
:
:
RequestStorageAccessForOrigin
(
const
nsAString
&
aThirdPartyOrigin
const
bool
aRequireUserActivation
mozilla
:
:
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
aRequireUserActivation
&
&
!
HasValidTransientUserGestureActivation
(
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
nsLiteralCString
(
"
requestStorageAccess
"
)
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessUserGesture
"
)
;
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIURI
>
thirdPartyURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
thirdPartyURI
)
aThirdPartyOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
bool
isThirdPartyDocument
;
rv
=
NodePrincipal
(
)
-
>
IsThirdPartyURI
(
thirdPartyURI
&
isThirdPartyDocument
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
Maybe
<
bool
>
resultBecauseBrowserSettings
=
StorageAccessAPIHelper
:
:
CheckBrowserSettingsDecidesStorageAccessAPI
(
CookieJarSettings
(
)
isThirdPartyDocument
false
true
)
;
if
(
resultBecauseBrowserSettings
.
isSome
(
)
)
{
if
(
resultBecauseBrowserSettings
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
Maybe
<
bool
>
resultBecauseCallContext
=
StorageAccessAPIHelper
:
:
CheckSameSiteCallingContextDecidesStorageAccessAPI
(
this
aRequireUserActivation
)
;
if
(
resultBecauseCallContext
.
isSome
(
)
)
{
if
(
resultBecauseCallContext
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
GetInnerWindow
(
)
;
if
(
!
inner
)
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
nsGlobalWindowOuter
>
outer
=
nsGlobalWindowOuter
:
:
Cast
(
inner
-
>
GetOuterWindow
(
)
)
;
if
(
!
outer
)
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
thirdPartyURI
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
)
;
if
(
!
principal
)
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
Document
>
self
(
this
)
;
bool
hasUserActivation
=
HasValidTransientUserGestureActivation
(
)
;
ConsumeTransientUserGestureActivation
(
)
;
StorageAccessAPIHelper
:
:
AsyncCheckCookiesPermittedDecidesStorageAccessAPI
(
GetBrowsingContext
(
)
principal
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
inner
thirdPartyURI
bc
principal
hasUserActivation
aRequireUserActivation
self
promise
]
(
Maybe
<
bool
>
cookieResult
)
{
if
(
cookieResult
.
isSome
(
)
)
{
if
(
cookieResult
.
value
(
)
)
{
return
MozPromise
<
int
bool
true
>
:
:
CreateAndResolve
(
true
__func__
)
;
}
return
MozPromise
<
int
bool
true
>
:
:
CreateAndReject
(
false
__func__
)
;
}
nsAutoCString
type
;
bool
ok
=
AntiTrackingUtils
:
:
CreateStoragePermissionKey
(
principal
type
)
;
if
(
!
ok
)
{
return
MozPromise
<
int
bool
true
>
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
AntiTrackingUtils
:
:
CheckStoragePermission
(
self
-
>
NodePrincipal
(
)
type
nsContentUtils
:
:
IsInPrivateBrowsing
(
self
)
nullptr
0
)
)
{
return
MozPromise
<
int
bool
true
>
:
:
CreateAndResolve
(
true
__func__
)
;
}
return
StorageAccessAPIHelper
:
:
RequestStorageAccessAsyncHelper
(
self
inner
bc
principal
hasUserActivation
aRequireUserActivation
false
ContentBlockingNotifier
:
:
ePrivilegeStorageAccessForOriginAPI
true
)
;
}
[
promise
]
(
)
{
return
MozPromise
<
int
bool
true
>
:
:
CreateAndReject
(
false
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
inner
promise
]
{
inner
-
>
SaveStorageAccessPermissionGranted
(
)
;
self
-
>
NotifyUserGestureActivation
(
)
;
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
{
promise
-
>
MaybeRejectWithNotAllowedError
(
"
requestStorageAccess
not
allowed
"
_ns
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
Document
:
:
RequestStorageAccessUnderSite
(
const
nsAString
&
aSerializedSite
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
if
(
!
ConsumeTransientUserGestureActivation
(
)
)
{
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
"
requestStorageAccess
"
_ns
this
nsContentUtils
:
:
eDOM_PROPERTIES
"
RequestStorageAccessUserGesture
"
)
;
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIURI
>
siteURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
siteURI
)
aSerializedSite
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
bool
isCrossSiteArgument
;
rv
=
NodePrincipal
(
)
-
>
IsThirdPartyURI
(
siteURI
&
isCrossSiteArgument
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
if
(
!
isCrossSiteArgument
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
Maybe
<
bool
>
resultBecauseCookiesApproved
=
StorageAccessAPIHelper
:
:
CheckCookiesPermittedDecidesStorageAccessAPI
(
CookieJarSettings
(
)
NodePrincipal
(
)
)
;
if
(
resultBecauseCookiesApproved
.
isSome
(
)
)
{
if
(
resultBecauseCookiesApproved
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
Maybe
<
bool
>
resultBecauseBrowserSettings
=
StorageAccessAPIHelper
:
:
CheckBrowserSettingsDecidesStorageAccessAPI
(
CookieJarSettings
(
)
true
false
true
)
;
if
(
resultBecauseBrowserSettings
.
isSome
(
)
)
{
if
(
resultBecauseBrowserSettings
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
Maybe
<
bool
>
resultBecauseCallContext
=
StorageAccessAPIHelper
:
:
CheckSameSiteCallingContextDecidesStorageAccessAPI
(
this
false
)
;
if
(
resultBecauseCallContext
.
isSome
(
)
)
{
if
(
resultBecauseCallContext
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
(
NodePrincipal
(
)
)
;
nsCOMPtr
<
nsIPrincipal
>
argumentPrincipal
=
BasePrincipal
:
:
CreateContentPrincipal
(
siteURI
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
)
;
if
(
!
argumentPrincipal
)
{
ConsumeTransientUserGestureActivation
(
)
;
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
nsCString
originNoSuffix
;
rv
=
NodePrincipal
(
)
-
>
GetOriginNoSuffix
(
originNoSuffix
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
RefPtr
<
Document
>
self
(
this
)
;
cc
-
>
SendTestStorageAccessPermission
(
argumentPrincipal
originNoSuffix
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
siteURI
self
]
(
const
ContentChild
:
:
TestStorageAccessPermissionPromise
:
:
ResolveValueType
&
aResult
)
{
if
(
aResult
)
{
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
StorageAccessAPIHelper
:
:
eAllow
__func__
)
;
}
nsCString
serializedSite
;
RefPtr
<
nsEffectiveTLDService
>
etld
=
nsEffectiveTLDService
:
:
GetInstance
(
)
;
if
(
!
etld
)
{
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsresult
rv
=
etld
-
>
GetSite
(
siteURI
serializedSite
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
return
self
-
>
CreatePermissionGrantPromise
(
self
-
>
GetInnerWindow
(
)
self
-
>
NodePrincipal
(
)
true
true
Some
(
serializedSite
)
false
)
(
)
;
}
[
]
(
const
ContentChild
:
:
TestStorageAccessPermissionPromise
:
:
RejectValueType
&
aResult
)
{
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
principal
siteURI
]
(
int
result
)
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
if
(
!
cc
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
;
}
cc
-
>
SendSetAllowStorageAccessRequestFlag
(
principal
siteURI
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
promise
]
(
bool
success
)
{
if
(
success
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
else
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
}
[
promise
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
reason
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
}
[
promise
]
(
bool
result
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
return
promise
.
forget
(
)
;
}
already_AddRefed
<
Promise
>
Document
:
:
CompleteStorageAccessRequestFromSite
(
const
nsAString
&
aSerializedOrigin
ErrorResult
&
aRv
)
{
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
!
global
)
{
aRv
.
Throw
(
NS_ERROR_NOT_AVAILABLE
)
;
return
nullptr
;
}
RefPtr
<
Promise
>
promise
=
Promise
:
:
Create
(
global
aRv
)
;
if
(
aRv
.
Failed
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
argumentURI
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
argumentURI
)
aSerializedOrigin
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
bool
isCrossSiteArgument
;
rv
=
NodePrincipal
(
)
-
>
IsThirdPartyURI
(
argumentURI
&
isCrossSiteArgument
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
aRv
.
Throw
(
rv
)
;
return
nullptr
;
}
if
(
!
isCrossSiteArgument
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
Maybe
<
bool
>
resultBecauseBrowserSettings
=
StorageAccessAPIHelper
:
:
CheckBrowserSettingsDecidesStorageAccessAPI
(
CookieJarSettings
(
)
true
false
true
)
;
if
(
resultBecauseBrowserSettings
.
isSome
(
)
)
{
if
(
resultBecauseBrowserSettings
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
Maybe
<
bool
>
resultBecauseCallContext
=
StorageAccessAPIHelper
:
:
CheckSameSiteCallingContextDecidesStorageAccessAPI
(
this
false
)
;
if
(
resultBecauseCallContext
.
isSome
(
)
)
{
if
(
resultBecauseCallContext
.
value
(
)
)
{
promise
-
>
MaybeResolveWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
BasePrincipal
:
:
CreateContentPrincipal
(
argumentURI
NodePrincipal
(
)
-
>
OriginAttributesRef
(
)
)
;
if
(
!
principal
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
Document
>
self
(
this
)
;
RefPtr
<
BrowsingContext
>
bc
=
GetBrowsingContext
(
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
inner
=
GetInnerWindow
(
)
;
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
if
(
!
cc
)
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
return
promise
.
forget
(
)
;
}
cc
-
>
SendTestAllowStorageAccessRequestFlag
(
NodePrincipal
(
)
argumentURI
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
inner
bc
self
principal
]
(
bool
success
)
{
if
(
success
)
{
return
StorageAccessAPIHelper
:
:
AsyncCheckCookiesPermittedDecidesStorageAccessAPI
(
bc
principal
)
;
}
return
MozPromise
<
Maybe
<
bool
>
nsresult
true
>
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
[
]
(
mozilla
:
:
ipc
:
:
ResponseRejectReason
reason
)
{
return
MozPromise
<
Maybe
<
bool
>
nsresult
true
>
:
:
CreateAndReject
(
NS_ERROR_FAILURE
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
inner
bc
principal
self
promise
]
(
Maybe
<
bool
>
cookieResult
)
{
if
(
cookieResult
.
isSome
(
)
)
{
if
(
cookieResult
.
value
(
)
)
{
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
StorageAccessAPIHelper
:
:
eAllowAutoGrant
__func__
)
;
}
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
nsAutoCString
type
;
bool
ok
=
AntiTrackingUtils
:
:
CreateStoragePermissionKey
(
principal
type
)
;
if
(
!
ok
)
{
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
if
(
AntiTrackingUtils
:
:
CheckStoragePermission
(
self
-
>
NodePrincipal
(
)
type
nsContentUtils
:
:
IsInPrivateBrowsing
(
self
)
nullptr
0
)
)
{
return
StorageAccessAPIHelper
:
:
StorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
StorageAccessAPIHelper
:
:
eAllowAutoGrant
__func__
)
;
}
return
StorageAccessAPIHelper
:
:
RequestStorageAccessAsyncHelper
(
self
inner
bc
principal
true
true
false
ContentBlockingNotifier
:
:
eStorageAccessAPI
false
)
;
}
[
promise
]
(
)
{
return
MozPromise
<
int
bool
true
>
:
:
CreateAndReject
(
false
__func__
)
;
}
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
self
inner
promise
]
{
inner
-
>
SaveStorageAccessPermissionGranted
(
)
;
promise
-
>
MaybeResolveWithUndefined
(
)
;
}
[
promise
]
{
promise
-
>
MaybeRejectWithUndefined
(
)
;
}
)
;
return
promise
.
forget
(
)
;
}
RefPtr
<
Document
:
:
AutomaticStorageAccessPermissionGrantPromise
>
Document
:
:
AutomaticStorageAccessPermissionCanBeGranted
(
bool
hasUserActivation
)
{
if
(
!
hasUserActivation
|
|
!
StaticPrefs
:
:
privacy_antitracking_enableWebcompat
(
)
)
{
return
AutomaticStorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
false
__func__
)
;
}
if
(
XRE_IsContentProcess
(
)
)
{
ContentChild
*
cc
=
ContentChild
:
:
GetSingleton
(
)
;
MOZ_ASSERT
(
cc
)
;
return
cc
-
>
SendAutomaticStorageAccessPermissionCanBeGranted
(
NodePrincipal
(
)
)
-
>
Then
(
GetCurrentSerialEventTarget
(
)
__func__
[
]
(
const
ContentChild
:
:
AutomaticStorageAccessPermissionCanBeGrantedPromise
:
:
ResolveOrRejectValue
&
aValue
)
{
if
(
aValue
.
IsResolve
(
)
)
{
return
AutomaticStorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
aValue
.
ResolveValue
(
)
__func__
)
;
}
return
AutomaticStorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
)
;
}
if
(
XRE_IsParentProcess
(
)
)
{
return
AutomaticStorageAccessPermissionGrantPromise
:
:
CreateAndResolve
(
AutomaticStorageAccessPermissionCanBeGranted
(
NodePrincipal
(
)
)
__func__
)
;
}
return
AutomaticStorageAccessPermissionGrantPromise
:
:
CreateAndReject
(
false
__func__
)
;
}
bool
Document
:
:
AutomaticStorageAccessPermissionCanBeGranted
(
nsIPrincipal
*
aPrincipal
)
{
if
(
!
StaticPrefs
:
:
dom_storage_access_auto_grants
(
)
)
{
return
false
;
}
if
(
!
ContentBlockingUserInteraction
:
:
Exists
(
aPrincipal
)
)
{
return
false
;
}
nsCOMPtr
<
nsIBrowserUsage
>
bu
=
do_ImportESModule
(
"
resource
:
/
/
/
modules
/
BrowserUsageTelemetry
.
sys
.
mjs
"
fallible
)
;
if
(
NS_WARN_IF
(
!
bu
)
)
{
return
false
;
}
uint32_t
uniqueDomainsVisitedInPast24Hours
=
0
;
nsresult
rv
=
bu
-
>
GetUniqueDomainsVisitedInPast24Hours
(
&
uniqueDomainsVisitedInPast24Hours
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
false
;
}
Maybe
<
size_t
>
maybeOriginsThirdPartyHasAccessTo
=
AntiTrackingUtils
:
:
CountSitesAllowStorageAccess
(
aPrincipal
)
;
if
(
maybeOriginsThirdPartyHasAccessTo
.
isNothing
(
)
)
{
return
false
;
}
size_t
originsThirdPartyHasAccessTo
=
maybeOriginsThirdPartyHasAccessTo
.
value
(
)
;
size_t
maxConcurrentAutomaticGrants
=
std
:
:
max
(
std
:
:
max
(
int
(
std
:
:
floor
(
uniqueDomainsVisitedInPast24Hours
/
100
)
)
StaticPrefs
:
:
dom_storage_access_max_concurrent_auto_grants
(
)
)
0
)
;
return
originsThirdPartyHasAccessTo
<
maxConcurrentAutomaticGrants
;
}
void
Document
:
:
RecordNavigationTiming
(
ReadyState
aReadyState
)
{
if
(
!
XRE_IsContentProcess
(
)
)
{
return
;
}
if
(
!
IsTopLevelContentDocument
(
)
)
{
return
;
}
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mTiming
;
if
(
!
timing
)
{
if
(
!
mDocumentContainer
)
{
return
;
}
timing
=
mDocumentContainer
-
>
GetNavigationTiming
(
)
;
if
(
!
timing
)
{
return
;
}
}
TimeStamp
startTime
=
timing
-
>
GetNavigationStartTimeStamp
(
)
;
switch
(
aReadyState
)
{
case
READYSTATE_LOADING
:
if
(
!
mDOMLoadingSet
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TIME_TO_DOM_LOADING_MS
startTime
)
;
mDOMLoadingSet
=
true
;
}
break
;
case
READYSTATE_INTERACTIVE
:
if
(
!
mDOMInteractiveSet
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TIME_TO_DOM_INTERACTIVE_MS
startTime
)
;
mDOMInteractiveSet
=
true
;
}
break
;
case
READYSTATE_COMPLETE
:
if
(
!
mDOMCompleteSet
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
TIME_TO_DOM_COMPLETE_MS
startTime
)
;
mDOMCompleteSet
=
true
;
}
break
;
default
:
NS_WARNING
(
"
Unexpected
ReadyState
value
"
)
;
break
;
}
}
bool
Document
:
:
ImportMapsEnabled
(
)
const
{
return
nsContentUtils
:
:
IsChromeDoc
(
this
)
|
|
StaticPrefs
:
:
dom_importMaps_enabled
(
)
;
}
void
Document
:
:
ReportShadowDOMUsage
(
)
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
NS_WARN_IF
(
!
inner
)
)
{
return
;
}
WindowContext
*
wc
=
inner
-
>
GetWindowContext
(
)
;
if
(
NS_WARN_IF
(
!
wc
|
|
wc
-
>
IsDiscarded
(
)
)
)
{
return
;
}
WindowContext
*
topWc
=
wc
-
>
TopWindowContext
(
)
;
if
(
topWc
-
>
GetHasReportedShadowDOMUsage
(
)
)
{
return
;
}
MOZ_ALWAYS_SUCCEEDS
(
topWc
-
>
SetHasReportedShadowDOMUsage
(
true
)
)
;
}
bool
Document
:
:
StorageAccessSandboxed
(
uint32_t
aSandboxFlags
)
{
return
StaticPrefs
:
:
dom_storage_access_enabled
(
)
&
&
(
aSandboxFlags
&
SANDBOXED_STORAGE_ACCESS
)
!
=
0
;
}
bool
Document
:
:
StorageAccessSandboxed
(
)
const
{
return
Document
:
:
StorageAccessSandboxed
(
GetSandboxFlags
(
)
)
;
}
bool
Document
:
:
GetCachedSizes
(
nsTabSizes
*
aSizes
)
{
if
(
mCachedTabSizeGeneration
=
=
0
|
|
GetGeneration
(
)
!
=
mCachedTabSizeGeneration
)
{
return
false
;
}
aSizes
-
>
mDom
+
=
mCachedTabSizes
.
mDom
;
aSizes
-
>
mStyle
+
=
mCachedTabSizes
.
mStyle
;
aSizes
-
>
mOther
+
=
mCachedTabSizes
.
mOther
;
return
true
;
}
void
Document
:
:
SetCachedSizes
(
nsTabSizes
*
aSizes
)
{
mCachedTabSizes
.
mDom
=
aSizes
-
>
mDom
;
mCachedTabSizes
.
mStyle
=
aSizes
-
>
mStyle
;
mCachedTabSizes
.
mOther
=
aSizes
-
>
mOther
;
mCachedTabSizeGeneration
=
GetGeneration
(
)
;
}
nsAtom
*
Document
:
:
GetContentLanguageAsAtomForStyle
(
)
const
{
if
(
mContentLanguage
&
&
!
nsDependentAtomString
(
mContentLanguage
)
.
Contains
(
char16_t
(
'
'
)
)
)
{
return
GetContentLanguage
(
)
;
}
return
nullptr
;
}
nsAtom
*
Document
:
:
GetLanguageForStyle
(
)
const
{
if
(
nsAtom
*
lang
=
GetContentLanguageAsAtomForStyle
(
)
)
{
return
lang
;
}
return
mLanguageFromCharset
.
get
(
)
;
}
void
Document
:
:
GetContentLanguageForBindings
(
DOMString
&
aString
)
const
{
aString
.
SetKnownLiveAtom
(
mContentLanguage
DOMString
:
:
eTreatNullAsEmpty
)
;
}
const
LangGroupFontPrefs
*
Document
:
:
GetFontPrefsForLang
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
)
const
{
nsAtom
*
lang
=
aLanguage
?
aLanguage
:
mLanguageFromCharset
.
get
(
)
;
return
StaticPresData
:
:
Get
(
)
-
>
GetFontPrefsForLang
(
lang
aNeedsToCache
)
;
}
void
Document
:
:
DoCacheAllKnownLangPrefs
(
)
{
MOZ_ASSERT
(
mMayNeedFontPrefsUpdate
)
;
RefPtr
<
nsAtom
>
lang
=
GetLanguageForStyle
(
)
;
StaticPresData
*
data
=
StaticPresData
:
:
Get
(
)
;
data
-
>
GetFontPrefsForLang
(
lang
?
lang
.
get
(
)
:
mLanguageFromCharset
.
get
(
)
)
;
data
-
>
GetFontPrefsForLang
(
nsGkAtoms
:
:
x_math
)
;
data
-
>
GetFontPrefsForLang
(
nsGkAtoms
:
:
Unicode
)
;
for
(
const
auto
&
key
:
mLanguagesUsed
)
{
data
-
>
GetFontPrefsForLang
(
key
)
;
}
mMayNeedFontPrefsUpdate
=
false
;
}
void
Document
:
:
RecomputeLanguageFromCharset
(
)
{
nsLanguageAtomService
*
service
=
nsLanguageAtomService
:
:
GetService
(
)
;
RefPtr
<
nsAtom
>
language
=
service
-
>
LookupCharSet
(
mCharacterSet
)
;
if
(
language
=
=
nsGkAtoms
:
:
Unicode
)
{
language
=
service
-
>
GetLocaleLanguage
(
)
;
}
if
(
language
=
=
mLanguageFromCharset
)
{
return
;
}
mMayNeedFontPrefsUpdate
=
true
;
mLanguageFromCharset
=
std
:
:
move
(
language
)
;
}
nsICookieJarSettings
*
Document
:
:
CookieJarSettings
(
)
{
if
(
!
mCookieJarSettings
)
{
Document
*
inProcessParent
=
GetInProcessParentDocument
(
)
;
if
(
inProcessParent
)
{
mCookieJarSettings
=
net
:
:
CookieJarSettings
:
:
Create
(
inProcessParent
-
>
CookieJarSettings
(
)
-
>
GetCookieBehavior
(
)
mozilla
:
:
net
:
:
CookieJarSettings
:
:
Cast
(
inProcessParent
-
>
CookieJarSettings
(
)
)
-
>
GetPartitionKey
(
)
inProcessParent
-
>
CookieJarSettings
(
)
-
>
GetIsFirstPartyIsolated
(
)
inProcessParent
-
>
CookieJarSettings
(
)
-
>
GetIsOnContentBlockingAllowList
(
)
inProcessParent
-
>
CookieJarSettings
(
)
-
>
GetShouldResistFingerprinting
(
)
)
;
nsTArray
<
uint8_t
>
randomKey
;
nsresult
rv
=
inProcessParent
-
>
CookieJarSettings
(
)
-
>
GetFingerprintingRandomizationKey
(
randomKey
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
net
:
:
CookieJarSettings
:
:
Cast
(
mCookieJarSettings
)
-
>
SetFingerprintingRandomizationKey
(
randomKey
)
;
}
}
else
{
mCookieJarSettings
=
net
:
:
CookieJarSettings
:
:
Create
(
NodePrincipal
(
)
)
;
}
if
(
auto
*
wgc
=
GetWindowGlobalChild
(
)
)
{
net
:
:
CookieJarSettingsArgs
csArgs
;
net
:
:
CookieJarSettings
:
:
Cast
(
mCookieJarSettings
)
-
>
Serialize
(
csArgs
)
;
if
(
!
wgc
-
>
SendUpdateCookieJarSettings
(
csArgs
)
)
{
NS_WARNING
(
"
Failed
to
update
document
'
s
cookie
jar
settings
on
the
"
"
WindowGlobalParent
"
)
;
}
}
}
return
mCookieJarSettings
;
}
bool
Document
:
:
UsingStorageAccess
(
)
{
if
(
WindowContext
*
wc
=
GetWindowContext
(
)
)
{
return
wc
-
>
GetUsingStorageAccess
(
)
;
}
if
(
!
mChannel
)
{
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
return
loadInfo
-
>
GetStoragePermission
(
)
!
=
nsILoadInfo
:
:
NoStoragePermission
;
}
bool
Document
:
:
HasStorageAccessPermissionGrantedByAllowList
(
)
{
if
(
!
mChannel
)
{
return
false
;
}
nsCOMPtr
<
nsILoadInfo
>
loadInfo
=
mChannel
-
>
LoadInfo
(
)
;
return
loadInfo
-
>
GetStoragePermission
(
)
=
=
nsILoadInfo
:
:
StoragePermissionAllowListed
;
}
nsIPrincipal
*
Document
:
:
EffectiveStoragePrincipal
(
)
const
{
if
(
!
StaticPrefs
:
:
privacy_partition_always_partition_third_party_non_cookie_storage
(
)
)
{
return
EffectiveCookiePrincipal
(
)
;
}
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
!
inner
)
{
return
NodePrincipal
(
)
;
}
if
(
mActiveStoragePrincipal
)
{
return
mActiveStoragePrincipal
;
}
nsIPrincipal
*
principal
=
NodePrincipal
(
)
;
if
(
principal
&
&
(
principal
-
>
IsSystemPrincipal
(
)
|
|
principal
-
>
GetIsAddonOrExpandedAddonPrincipal
(
)
)
)
{
return
mActiveStoragePrincipal
=
NodePrincipal
(
)
;
}
auto
cookieJarSettings
=
const_cast
<
Document
*
>
(
this
)
-
>
CookieJarSettings
(
)
;
if
(
cookieJarSettings
-
>
GetIsOnContentBlockingAllowList
(
)
)
{
return
mActiveStoragePrincipal
=
NodePrincipal
(
)
;
}
StorageAccess
storageAccess
=
StorageAllowedForDocument
(
this
)
;
if
(
!
ShouldPartitionStorage
(
storageAccess
)
|
|
!
StoragePartitioningEnabled
(
storageAccess
cookieJarSettings
)
)
{
return
mActiveStoragePrincipal
=
NodePrincipal
(
)
;
}
Unused
<
<
NS_WARN_IF
(
NS_FAILED
(
StoragePrincipalHelper
:
:
GetPrincipal
(
nsGlobalWindowInner
:
:
Cast
(
inner
)
StoragePrincipalHelper
:
:
eForeignPartitionedPrincipal
getter_AddRefs
(
mActiveStoragePrincipal
)
)
)
)
;
return
mActiveStoragePrincipal
;
}
nsIPrincipal
*
Document
:
:
EffectiveCookiePrincipal
(
)
const
{
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
;
if
(
!
inner
)
{
return
NodePrincipal
(
)
;
}
if
(
mActiveCookiePrincipal
)
{
return
mActiveCookiePrincipal
;
}
uint32_t
rejectedReason
=
0
;
if
(
ShouldAllowAccessFor
(
inner
GetDocumentURI
(
)
&
rejectedReason
)
)
{
return
mActiveCookiePrincipal
=
NodePrincipal
(
)
;
}
if
(
ShouldPartitionStorage
(
rejectedReason
)
&
&
!
StoragePartitioningEnabled
(
rejectedReason
const_cast
<
Document
*
>
(
this
)
-
>
CookieJarSettings
(
)
)
)
{
return
mActiveCookiePrincipal
=
NodePrincipal
(
)
;
}
return
mActiveCookiePrincipal
=
mPartitionedPrincipal
;
}
nsIPrincipal
*
Document
:
:
GetPrincipalForPrefBasedHacks
(
)
const
{
for
(
const
Document
*
document
=
this
;
document
&
&
document
-
>
IsContentDocument
(
)
;
document
=
document
-
>
GetInProcessParentDocument
(
)
)
{
nsIPrincipal
*
principal
=
document
-
>
NodePrincipal
(
)
;
if
(
principal
-
>
GetIsNullPrincipal
(
)
)
{
continue
;
}
return
principal
;
}
return
nullptr
;
}
void
Document
:
:
SetIsInitialDocument
(
bool
aIsInitialDocument
)
{
mIsInitialDocumentInWindow
=
aIsInitialDocument
;
if
(
auto
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
SendSetIsInitialDocument
(
aIsInitialDocument
)
;
}
}
void
Document
:
:
AddToplevelLoadingDocument
(
Document
*
aDoc
)
{
MOZ_ASSERT
(
aDoc
&
&
aDoc
-
>
IsTopLevelContentDocument
(
)
)
;
if
(
aDoc
-
>
IsInBackgroundWindow
(
)
|
|
!
XRE_IsContentProcess
(
)
)
{
return
;
}
if
(
!
sLoadingForegroundTopLevelContentDocument
)
{
sLoadingForegroundTopLevelContentDocument
=
new
AutoTArray
<
Document
*
8
>
(
)
;
mozilla
:
:
ipc
:
:
IdleSchedulerChild
*
idleScheduler
=
mozilla
:
:
ipc
:
:
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
idleScheduler
)
{
idleScheduler
-
>
SendRunningPrioritizedOperation
(
)
;
}
}
if
(
!
sLoadingForegroundTopLevelContentDocument
-
>
Contains
(
aDoc
)
)
{
sLoadingForegroundTopLevelContentDocument
-
>
AppendElement
(
aDoc
)
;
}
}
void
Document
:
:
RemoveToplevelLoadingDocument
(
Document
*
aDoc
)
{
MOZ_ASSERT
(
aDoc
&
&
aDoc
-
>
IsTopLevelContentDocument
(
)
)
;
if
(
sLoadingForegroundTopLevelContentDocument
)
{
sLoadingForegroundTopLevelContentDocument
-
>
RemoveElement
(
aDoc
)
;
if
(
sLoadingForegroundTopLevelContentDocument
-
>
IsEmpty
(
)
)
{
delete
sLoadingForegroundTopLevelContentDocument
;
sLoadingForegroundTopLevelContentDocument
=
nullptr
;
mozilla
:
:
ipc
:
:
IdleSchedulerChild
*
idleScheduler
=
mozilla
:
:
ipc
:
:
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
idleScheduler
)
{
idleScheduler
-
>
SendPrioritizedOperationDone
(
)
;
}
}
}
}
ColorScheme
Document
:
:
DefaultColorScheme
(
)
const
{
return
LookAndFeel
:
:
ColorSchemeForStyle
(
*
this
{
GetColorSchemeBits
(
)
}
)
;
}
ColorScheme
Document
:
:
PreferredColorScheme
(
IgnoreRFP
aIgnoreRFP
)
const
{
if
(
ShouldResistFingerprinting
(
RFPTarget
:
:
CSSPrefersColorScheme
)
&
&
aIgnoreRFP
=
=
IgnoreRFP
:
:
No
)
{
return
ColorScheme
:
:
Light
;
}
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
if
(
auto
scheme
=
pc
-
>
GetOverriddenOrEmbedderColorScheme
(
)
)
{
return
*
scheme
;
}
}
return
PreferenceSheet
:
:
PrefsFor
(
*
this
)
.
mColorScheme
;
}
bool
Document
:
:
HasRecentlyStartedForegroundLoads
(
)
{
if
(
!
sLoadingForegroundTopLevelContentDocument
)
{
return
false
;
}
for
(
size_t
i
=
0
;
i
<
sLoadingForegroundTopLevelContentDocument
-
>
Length
(
)
;
+
+
i
)
{
Document
*
doc
=
sLoadingForegroundTopLevelContentDocument
-
>
ElementAt
(
i
)
;
if
(
!
doc
-
>
IsInBackgroundWindow
(
)
)
{
nsPIDOMWindowInner
*
win
=
doc
-
>
GetInnerWindow
(
)
;
if
(
win
)
{
Performance
*
perf
=
win
-
>
GetPerformance
(
)
;
if
(
perf
&
&
perf
-
>
Now
(
)
<
StaticPrefs
:
:
page_load_deprioritization_period
(
)
)
{
return
true
;
}
}
}
}
delete
sLoadingForegroundTopLevelContentDocument
;
sLoadingForegroundTopLevelContentDocument
=
nullptr
;
mozilla
:
:
ipc
:
:
IdleSchedulerChild
*
idleScheduler
=
mozilla
:
:
ipc
:
:
IdleSchedulerChild
:
:
GetMainThreadIdleScheduler
(
)
;
if
(
idleScheduler
)
{
idleScheduler
-
>
SendPrioritizedOperationDone
(
)
;
}
return
false
;
}
void
Document
:
:
AddPendingFrameStaticClone
(
nsFrameLoaderOwner
*
aElement
nsFrameLoader
*
aStaticCloneOf
)
{
PendingFrameStaticClone
*
clone
=
mPendingFrameStaticClones
.
AppendElement
(
)
;
clone
-
>
mElement
=
aElement
;
clone
-
>
mStaticCloneOf
=
aStaticCloneOf
;
}
bool
Document
:
:
ShouldAvoidNativeTheme
(
)
const
{
return
StaticPrefs
:
:
widget_non_native_theme_enabled
(
)
&
&
(
!
IsInChromeDocShell
(
)
|
|
XRE_IsContentProcess
(
)
)
;
}
bool
Document
:
:
UseRegularPrincipal
(
)
const
{
return
EffectiveStoragePrincipal
(
)
=
=
NodePrincipal
(
)
;
}
bool
Document
:
:
HasThirdPartyChannel
(
)
{
nsCOMPtr
<
nsIChannel
>
channel
=
GetChannel
(
)
;
if
(
channel
)
{
bool
thirdParty
=
true
;
nsCOMPtr
<
mozIThirdPartyUtil
>
thirdPartyUtil
=
components
:
:
ThirdPartyUtil
:
:
Service
(
)
;
if
(
!
thirdPartyUtil
)
{
return
thirdParty
;
}
nsresult
rv
=
thirdPartyUtil
-
>
IsThirdPartyChannel
(
channel
nullptr
&
thirdParty
)
;
if
(
NS_FAILED
(
rv
)
)
{
thirdParty
=
true
;
}
return
thirdParty
;
}
if
(
mParentDocument
)
{
return
mParentDocument
-
>
HasThirdPartyChannel
(
)
;
}
return
false
;
}
bool
Document
:
:
IsLikelyContentInaccessibleTopLevelAboutBlank
(
)
const
{
if
(
!
mDocumentURI
|
|
!
NS_IsAboutBlank
(
mDocumentURI
)
)
{
return
false
;
}
BrowsingContext
*
bc
=
GetBrowsingContext
(
)
;
return
bc
&
&
bc
-
>
IsTop
(
)
&
&
!
bc
-
>
HadOriginalOpener
(
)
;
}
bool
Document
:
:
ShouldIncludeInTelemetry
(
bool
aAllowExtensionURIs
)
{
if
(
!
IsContentDocument
(
)
&
&
!
IsResourceDoc
(
)
)
{
return
false
;
}
if
(
IsLikelyContentInaccessibleTopLevelAboutBlank
(
)
)
{
return
false
;
}
nsIPrincipal
*
prin
=
NodePrincipal
(
)
;
if
(
!
aAllowExtensionURIs
&
&
prin
-
>
GetIsAddonOrExpandedAddonPrincipal
(
)
)
{
return
false
;
}
if
(
prin
-
>
IsSystemPrincipal
(
)
|
|
prin
-
>
SchemeIs
(
"
about
"
)
|
|
prin
-
>
SchemeIs
(
"
chrome
"
)
|
|
prin
-
>
SchemeIs
(
"
resource
"
)
)
{
return
false
;
}
return
true
;
}
void
Document
:
:
GetConnectedShadowRoots
(
nsTArray
<
RefPtr
<
ShadowRoot
>
>
&
aOut
)
const
{
AppendToArray
(
aOut
mComposedShadowRoots
)
;
}
void
Document
:
:
AddMediaElementWithMSE
(
)
{
if
(
mMediaElementWithMSECount
+
+
=
=
0
)
{
if
(
WindowGlobalChild
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
BlockBFCacheFor
(
BFCacheStatus
:
:
CONTAINS_MSE_CONTENT
)
;
}
}
}
void
Document
:
:
RemoveMediaElementWithMSE
(
)
{
MOZ_ASSERT
(
mMediaElementWithMSECount
>
0
)
;
if
(
-
-
mMediaElementWithMSECount
=
=
0
)
{
if
(
WindowGlobalChild
*
wgc
=
GetWindowGlobalChild
(
)
)
{
wgc
-
>
UnblockBFCacheFor
(
BFCacheStatus
:
:
CONTAINS_MSE_CONTENT
)
;
}
}
}
void
Document
:
:
UnregisterFromMemoryReportingForDataDocument
(
)
{
if
(
!
mAddedToMemoryReportingAsDataDocument
)
{
return
;
}
mAddedToMemoryReportingAsDataDocument
=
false
;
nsIGlobalObject
*
global
=
GetScopeObject
(
)
;
if
(
global
)
{
if
(
nsPIDOMWindowInner
*
win
=
global
-
>
GetAsInnerWindow
(
)
)
{
nsGlobalWindowInner
:
:
Cast
(
win
)
-
>
UnregisterDataDocumentForMemoryReporting
(
this
)
;
}
}
}
void
Document
:
:
OOPChildLoadStarted
(
BrowserBridgeChild
*
aChild
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mOOPChildrenLoading
.
Contains
(
aChild
)
)
;
mOOPChildrenLoading
.
AppendElement
(
aChild
)
;
if
(
mOOPChildrenLoading
.
Length
(
)
=
=
1
)
{
BlockOnload
(
)
;
}
}
void
Document
:
:
OOPChildLoadDone
(
BrowserBridgeChild
*
aChild
)
{
if
(
mOOPChildrenLoading
.
RemoveElement
(
aChild
)
)
{
if
(
mOOPChildrenLoading
.
IsEmpty
(
)
)
{
UnblockOnload
(
false
)
;
}
RefPtr
<
nsDocLoader
>
docLoader
(
mDocumentContainer
)
;
if
(
docLoader
)
{
docLoader
-
>
OOPChildrenLoadingIsEmpty
(
)
;
}
}
}
void
Document
:
:
ClearOOPChildrenLoading
(
)
{
nsTArray
<
const
BrowserBridgeChild
*
>
oopChildrenLoading
;
mOOPChildrenLoading
.
SwapElements
(
oopChildrenLoading
)
;
if
(
!
oopChildrenLoading
.
IsEmpty
(
)
)
{
UnblockOnload
(
false
)
;
}
}
bool
Document
:
:
MayHaveDOMActivateListeners
(
)
const
{
if
(
nsPIDOMWindowInner
*
inner
=
GetInnerWindow
(
)
)
{
return
inner
-
>
HasDOMActivateEventListeners
(
)
;
}
return
true
;
}
HighlightRegistry
&
Document
:
:
HighlightRegistry
(
)
{
if
(
!
mHighlightRegistry
)
{
mHighlightRegistry
=
MakeRefPtr
<
class
HighlightRegistry
>
(
this
)
;
}
return
*
mHighlightRegistry
;
}
RadioGroupContainer
&
Document
:
:
OwnedRadioGroupContainer
(
)
{
if
(
!
mRadioGroupContainer
)
{
mRadioGroupContainer
=
MakeUnique
<
RadioGroupContainer
>
(
)
;
}
return
*
mRadioGroupContainer
;
}
}
